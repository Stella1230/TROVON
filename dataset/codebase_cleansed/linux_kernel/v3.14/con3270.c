static void con3270_set_timer(struct con3270 *cp, int expires)\r\n{\r\nif (expires == 0)\r\ndel_timer(&cp->timer);\r\nelse\r\nmod_timer(&cp->timer, jiffies + expires);\r\n}\r\nstatic void\r\ncon3270_update_status(struct con3270 *cp)\r\n{\r\nchar *str;\r\nstr = (cp->nr_up != 0) ? "History" : "Running";\r\nmemcpy(cp->status->string + 24, str, 7);\r\ncodepage_convert(cp->view.ascebc, cp->status->string + 24, 7);\r\ncp->update_flags |= CON_UPDATE_STATUS;\r\n}\r\nstatic void\r\ncon3270_create_status(struct con3270 *cp)\r\n{\r\nstatic const unsigned char blueprint[] =\r\n{ TO_SBA, 0, 0, TO_SF,TF_LOG,TO_SA,TAT_COLOR, TAC_GREEN,\r\n'c','o','n','s','o','l','e',' ','v','i','e','w',\r\nTO_RA,0,0,0,'R','u','n','n','i','n','g',TO_SF,TF_LOG };\r\ncp->status = alloc_string(&cp->freemem, sizeof(blueprint));\r\nmemcpy(cp->status->string, blueprint, sizeof(blueprint));\r\nraw3270_buffer_address(cp->view.dev, cp->status->string + 1,\r\ncp->view.cols * (cp->view.rows - 1));\r\nraw3270_buffer_address(cp->view.dev, cp->status->string + 21,\r\ncp->view.cols * cp->view.rows - 8);\r\ncodepage_convert(cp->view.ascebc, cp->status->string + 8, 12);\r\ncodepage_convert(cp->view.ascebc, cp->status->string + 24, 7);\r\n}\r\nstatic void\r\ncon3270_update_string(struct con3270 *cp, struct string *s, int nr)\r\n{\r\nif (s->len >= cp->view.cols - 5)\r\nreturn;\r\nraw3270_buffer_address(cp->view.dev, s->string + s->len - 3,\r\ncp->view.cols * (nr + 1));\r\n}\r\nstatic void\r\ncon3270_rebuild_update(struct con3270 *cp)\r\n{\r\nstruct string *s, *n;\r\nint nr;\r\nlist_for_each_entry_safe(s, n, &cp->update, update)\r\nlist_del_init(&s->update);\r\nnr = cp->view.rows - 2 + cp->nr_up;\r\nlist_for_each_entry_reverse(s, &cp->lines, list) {\r\nif (nr < cp->view.rows - 1)\r\nlist_add(&s->update, &cp->update);\r\nif (--nr < 0)\r\nbreak;\r\n}\r\ncp->line_nr = 0;\r\ncp->update_flags |= CON_UPDATE_LIST;\r\n}\r\nstatic struct string *\r\ncon3270_alloc_string(struct con3270 *cp, size_t size)\r\n{\r\nstruct string *s, *n;\r\ns = alloc_string(&cp->freemem, size);\r\nif (s)\r\nreturn s;\r\nlist_for_each_entry_safe(s, n, &cp->lines, list) {\r\nlist_del(&s->list);\r\nif (!list_empty(&s->update))\r\nlist_del(&s->update);\r\ncp->nr_lines--;\r\nif (free_string(&cp->freemem, s) >= size)\r\nbreak;\r\n}\r\ns = alloc_string(&cp->freemem, size);\r\nBUG_ON(!s);\r\nif (cp->nr_up != 0 && cp->nr_up + cp->view.rows > cp->nr_lines) {\r\ncp->nr_up = cp->nr_lines - cp->view.rows + 1;\r\ncon3270_rebuild_update(cp);\r\ncon3270_update_status(cp);\r\n}\r\nreturn s;\r\n}\r\nstatic void\r\ncon3270_write_callback(struct raw3270_request *rq, void *data)\r\n{\r\nraw3270_request_reset(rq);\r\nxchg(&((struct con3270 *) rq->view)->write, rq);\r\n}\r\nstatic void\r\ncon3270_update(struct con3270 *cp)\r\n{\r\nstruct raw3270_request *wrq;\r\nchar wcc, prolog[6];\r\nunsigned long flags;\r\nunsigned long updated;\r\nstruct string *s, *n;\r\nint rc;\r\nif (cp->view.dev)\r\nraw3270_activate_view(&cp->view);\r\nwrq = xchg(&cp->write, 0);\r\nif (!wrq) {\r\ncon3270_set_timer(cp, 1);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cp->view.lock, flags);\r\nupdated = 0;\r\nif (cp->update_flags & CON_UPDATE_ALL) {\r\ncon3270_rebuild_update(cp);\r\ncon3270_update_status(cp);\r\ncp->update_flags = CON_UPDATE_ERASE | CON_UPDATE_LIST |\r\nCON_UPDATE_STATUS;\r\n}\r\nif (cp->update_flags & CON_UPDATE_ERASE) {\r\nraw3270_request_set_cmd(wrq, TC_EWRITEA);\r\nupdated |= CON_UPDATE_ERASE;\r\n} else\r\nraw3270_request_set_cmd(wrq, TC_WRITE);\r\nwcc = TW_NONE;\r\nraw3270_request_add_data(wrq, &wcc, 1);\r\nif (cp->update_flags & CON_UPDATE_STATUS)\r\nif (raw3270_request_add_data(wrq, cp->status->string,\r\ncp->status->len) == 0)\r\nupdated |= CON_UPDATE_STATUS;\r\nif (cp->update_flags & CON_UPDATE_LIST) {\r\nprolog[0] = TO_SBA;\r\nprolog[3] = TO_SA;\r\nprolog[4] = TAT_COLOR;\r\nprolog[5] = TAC_TURQ;\r\nraw3270_buffer_address(cp->view.dev, prolog + 1,\r\ncp->view.cols * cp->line_nr);\r\nraw3270_request_add_data(wrq, prolog, 6);\r\nlist_for_each_entry_safe(s, n, &cp->update, update) {\r\nif (s != cp->cline)\r\ncon3270_update_string(cp, s, cp->line_nr);\r\nif (raw3270_request_add_data(wrq, s->string,\r\ns->len) != 0)\r\nbreak;\r\nlist_del_init(&s->update);\r\nif (s != cp->cline)\r\ncp->line_nr++;\r\n}\r\nif (list_empty(&cp->update))\r\nupdated |= CON_UPDATE_LIST;\r\n}\r\nwrq->callback = con3270_write_callback;\r\nrc = raw3270_start(&cp->view, wrq);\r\nif (rc == 0) {\r\ncp->update_flags &= ~updated;\r\nif (cp->update_flags)\r\ncon3270_set_timer(cp, 1);\r\n} else {\r\nraw3270_request_reset(wrq);\r\nxchg(&cp->write, wrq);\r\n}\r\nspin_unlock_irqrestore(&cp->view.lock, flags);\r\n}\r\nstatic void\r\ncon3270_read_tasklet(struct raw3270_request *rrq)\r\n{\r\nstatic char kreset_data = TW_KR;\r\nstruct con3270 *cp;\r\nunsigned long flags;\r\nint nr_up, deactivate;\r\ncp = (struct con3270 *) rrq->view;\r\nspin_lock_irqsave(&cp->view.lock, flags);\r\nnr_up = cp->nr_up;\r\ndeactivate = 0;\r\nswitch (cp->input->string[0]) {\r\ncase 0x7d:\r\nnr_up = 0;\r\nbreak;\r\ncase 0xf3:\r\ndeactivate = 1;\r\nbreak;\r\ncase 0x6d:\r\ncp->update_flags = CON_UPDATE_ALL;\r\ncon3270_set_timer(cp, 1);\r\nbreak;\r\ncase 0xf7:\r\nnr_up += cp->view.rows - 2;\r\nif (nr_up + cp->view.rows - 1 > cp->nr_lines) {\r\nnr_up = cp->nr_lines - cp->view.rows + 1;\r\nif (nr_up < 0)\r\nnr_up = 0;\r\n}\r\nbreak;\r\ncase 0xf8:\r\nnr_up -= cp->view.rows - 2;\r\nif (nr_up < 0)\r\nnr_up = 0;\r\nbreak;\r\n}\r\nif (nr_up != cp->nr_up) {\r\ncp->nr_up = nr_up;\r\ncon3270_rebuild_update(cp);\r\ncon3270_update_status(cp);\r\ncon3270_set_timer(cp, 1);\r\n}\r\nspin_unlock_irqrestore(&cp->view.lock, flags);\r\nraw3270_request_reset(cp->kreset);\r\nraw3270_request_set_cmd(cp->kreset, TC_WRITE);\r\nraw3270_request_add_data(cp->kreset, &kreset_data, 1);\r\nraw3270_start(&cp->view, cp->kreset);\r\nif (deactivate)\r\nraw3270_deactivate_view(&cp->view);\r\nraw3270_request_reset(rrq);\r\nxchg(&cp->read, rrq);\r\nraw3270_put_view(&cp->view);\r\n}\r\nstatic void\r\ncon3270_read_callback(struct raw3270_request *rq, void *data)\r\n{\r\nraw3270_get_view(rq->view);\r\ntasklet_schedule(&((struct con3270 *) rq->view)->readlet);\r\n}\r\nstatic void\r\ncon3270_issue_read(struct con3270 *cp)\r\n{\r\nstruct raw3270_request *rrq;\r\nint rc;\r\nrrq = xchg(&cp->read, 0);\r\nif (!rrq)\r\nreturn;\r\nrrq->callback = con3270_read_callback;\r\nrrq->callback_data = cp;\r\nraw3270_request_set_cmd(rrq, TC_READMOD);\r\nraw3270_request_set_data(rrq, cp->input->string, cp->input->len);\r\nrc = raw3270_start_irq(&cp->view, rrq);\r\nif (rc)\r\nraw3270_request_reset(rrq);\r\n}\r\nstatic int\r\ncon3270_activate(struct raw3270_view *view)\r\n{\r\nstruct con3270 *cp;\r\ncp = (struct con3270 *) view;\r\ncp->update_flags = CON_UPDATE_ALL;\r\ncon3270_set_timer(cp, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\ncon3270_deactivate(struct raw3270_view *view)\r\n{\r\nstruct con3270 *cp;\r\ncp = (struct con3270 *) view;\r\ndel_timer(&cp->timer);\r\n}\r\nstatic int\r\ncon3270_irq(struct con3270 *cp, struct raw3270_request *rq, struct irb *irb)\r\n{\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION)\r\ncon3270_issue_read(cp);\r\nif (rq) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nrq->rc = -EIO;\r\nelse\r\nrq->rescnt = irb->scsw.cmd.count;\r\n}\r\nreturn RAW3270_IO_DONE;\r\n}\r\nstatic inline void\r\ncon3270_cline_add(struct con3270 *cp)\r\n{\r\nif (!list_empty(&cp->cline->list))\r\nreturn;\r\nlist_add_tail(&cp->cline->list, &cp->lines);\r\ncp->nr_lines++;\r\ncon3270_rebuild_update(cp);\r\n}\r\nstatic inline void\r\ncon3270_cline_insert(struct con3270 *cp, unsigned char c)\r\n{\r\ncp->cline->string[cp->cline->len++] =\r\ncp->view.ascebc[(c < ' ') ? ' ' : c];\r\nif (list_empty(&cp->cline->update)) {\r\nlist_add_tail(&cp->cline->update, &cp->update);\r\ncp->update_flags |= CON_UPDATE_LIST;\r\n}\r\n}\r\nstatic inline void\r\ncon3270_cline_end(struct con3270 *cp)\r\n{\r\nstruct string *s;\r\nunsigned int size;\r\nsize = (cp->cline->len < cp->view.cols - 5) ?\r\ncp->cline->len + 4 : cp->view.cols;\r\ns = con3270_alloc_string(cp, size);\r\nmemcpy(s->string, cp->cline->string, cp->cline->len);\r\nif (s->len < cp->view.cols - 5) {\r\ns->string[s->len - 4] = TO_RA;\r\ns->string[s->len - 1] = 0;\r\n} else {\r\nwhile (--size > cp->cline->len)\r\ns->string[size] = cp->view.ascebc[' '];\r\n}\r\nlist_add(&s->list, &cp->cline->list);\r\nlist_del_init(&cp->cline->list);\r\nif (!list_empty(&cp->cline->update)) {\r\nlist_add(&s->update, &cp->cline->update);\r\nlist_del_init(&cp->cline->update);\r\n}\r\ncp->cline->len = 0;\r\n}\r\nstatic void\r\ncon3270_write(struct console *co, const char *str, unsigned int count)\r\n{\r\nstruct con3270 *cp;\r\nunsigned long flags;\r\nunsigned char c;\r\ncp = condev;\r\nspin_lock_irqsave(&cp->view.lock, flags);\r\nwhile (count-- > 0) {\r\nc = *str++;\r\nif (cp->cline->len == 0)\r\ncon3270_cline_add(cp);\r\nif (c != '\n')\r\ncon3270_cline_insert(cp, c);\r\nif (c == '\n' || cp->cline->len >= cp->view.cols)\r\ncon3270_cline_end(cp);\r\n}\r\ncp->nr_up = 0;\r\nif (cp->view.dev && !timer_pending(&cp->timer))\r\ncon3270_set_timer(cp, HZ/10);\r\nspin_unlock_irqrestore(&cp->view.lock,flags);\r\n}\r\nstatic struct tty_driver *\r\ncon3270_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn tty3270_driver;\r\n}\r\nstatic void\r\ncon3270_wait_write(struct con3270 *cp)\r\n{\r\nwhile (!cp->write) {\r\nraw3270_wait_cons_dev(cp->view.dev);\r\nbarrier();\r\n}\r\n}\r\nstatic void\r\ncon3270_flush(void)\r\n{\r\nstruct con3270 *cp;\r\nunsigned long flags;\r\ncp = condev;\r\nif (!cp->view.dev)\r\nreturn;\r\nraw3270_pm_unfreeze(&cp->view);\r\nspin_lock_irqsave(&cp->view.lock, flags);\r\ncon3270_wait_write(cp);\r\ncp->nr_up = 0;\r\ncon3270_rebuild_update(cp);\r\ncon3270_update_status(cp);\r\nwhile (cp->update_flags != 0) {\r\nspin_unlock_irqrestore(&cp->view.lock, flags);\r\ncon3270_update(cp);\r\nspin_lock_irqsave(&cp->view.lock, flags);\r\ncon3270_wait_write(cp);\r\n}\r\nspin_unlock_irqrestore(&cp->view.lock, flags);\r\n}\r\nstatic int con3270_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\ncon3270_flush();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init\r\ncon3270_init(void)\r\n{\r\nstruct ccw_device *cdev;\r\nstruct raw3270 *rp;\r\nvoid *cbuf;\r\nint i;\r\nif (!CONSOLE_IS_3270)\r\nreturn -ENODEV;\r\nif (MACHINE_IS_VM) {\r\ncpcmd("TERM CONMODE 3270", NULL, 0, NULL);\r\ncpcmd("TERM AUTOCR OFF", NULL, 0, NULL);\r\n}\r\ncdev = ccw_device_probe_console();\r\nif (IS_ERR(cdev))\r\nreturn -ENODEV;\r\nrp = raw3270_setup_console(cdev);\r\nif (IS_ERR(rp))\r\nreturn PTR_ERR(rp);\r\ncondev = kzalloc(sizeof(struct con3270), GFP_KERNEL | GFP_DMA);\r\ncondev->view.dev = rp;\r\ncondev->read = raw3270_request_alloc(0);\r\ncondev->read->callback = con3270_read_callback;\r\ncondev->read->callback_data = condev;\r\ncondev->write = raw3270_request_alloc(CON3270_OUTPUT_BUFFER_SIZE);\r\ncondev->kreset = raw3270_request_alloc(1);\r\nINIT_LIST_HEAD(&condev->lines);\r\nINIT_LIST_HEAD(&condev->update);\r\nsetup_timer(&condev->timer, (void (*)(unsigned long)) con3270_update,\r\n(unsigned long) condev);\r\ntasklet_init(&condev->readlet,\r\n(void (*)(unsigned long)) con3270_read_tasklet,\r\n(unsigned long) condev->read);\r\nraw3270_add_view(&condev->view, &con3270_fn, 1);\r\nINIT_LIST_HEAD(&condev->freemem);\r\nfor (i = 0; i < CON3270_STRING_PAGES; i++) {\r\ncbuf = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nadd_string_memory(&condev->freemem, cbuf, PAGE_SIZE);\r\n}\r\ncondev->cline = alloc_string(&condev->freemem, condev->view.cols);\r\ncondev->cline->len = 0;\r\ncon3270_create_status(condev);\r\ncondev->input = alloc_string(&condev->freemem, 80);\r\natomic_notifier_chain_register(&panic_notifier_list, &on_panic_nb);\r\nregister_reboot_notifier(&on_reboot_nb);\r\nregister_console(&con3270);\r\nreturn 0;\r\n}
