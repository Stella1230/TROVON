int mga_warp_install_microcode(drm_mga_private_t *dev_priv)\r\n{\r\nunsigned char *vcbase = dev_priv->warp->handle;\r\nunsigned long pcbase = dev_priv->warp->offset;\r\nconst char *firmware_name;\r\nstruct platform_device *pdev;\r\nconst struct firmware *fw = NULL;\r\nconst struct ihex_binrec *rec;\r\nunsigned int size;\r\nint n_pipes, where;\r\nint rc = 0;\r\nswitch (dev_priv->chipset) {\r\ncase MGA_CARD_TYPE_G400:\r\ncase MGA_CARD_TYPE_G550:\r\nfirmware_name = FIRMWARE_G400;\r\nn_pipes = MGA_MAX_G400_PIPES;\r\nbreak;\r\ncase MGA_CARD_TYPE_G200:\r\nfirmware_name = FIRMWARE_G200;\r\nn_pipes = MGA_MAX_G200_PIPES;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npdev = platform_device_register_simple("mga_warp", 0, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nDRM_ERROR("mga: Failed to register microcode\n");\r\nreturn PTR_ERR(pdev);\r\n}\r\nrc = request_ihex_firmware(&fw, firmware_name, &pdev->dev);\r\nplatform_device_unregister(pdev);\r\nif (rc) {\r\nDRM_ERROR("mga: Failed to load microcode \"%s\"\n",\r\nfirmware_name);\r\nreturn rc;\r\n}\r\nsize = 0;\r\nwhere = 0;\r\nfor (rec = (const struct ihex_binrec *)fw->data;\r\nrec;\r\nrec = ihex_next_binrec(rec)) {\r\nsize += WARP_UCODE_SIZE(be16_to_cpu(rec->len));\r\nwhere++;\r\n}\r\nif (where != n_pipes) {\r\nDRM_ERROR("mga: Invalid microcode \"%s\"\n", firmware_name);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nsize = PAGE_ALIGN(size);\r\nDRM_DEBUG("MGA ucode size = %d bytes\n", size);\r\nif (size > dev_priv->warp->size) {\r\nDRM_ERROR("microcode too large! (%u > %lu)\n",\r\nsize, dev_priv->warp->size);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset(dev_priv->warp_pipe_phys, 0, sizeof(dev_priv->warp_pipe_phys));\r\nwhere = 0;\r\nfor (rec = (const struct ihex_binrec *)fw->data;\r\nrec;\r\nrec = ihex_next_binrec(rec)) {\r\nunsigned int src_size, dst_size;\r\nDRM_DEBUG(" pcbase = 0x%08lx vcbase = %p\n", pcbase, vcbase);\r\ndev_priv->warp_pipe_phys[where] = pcbase;\r\nsrc_size = be16_to_cpu(rec->len);\r\ndst_size = WARP_UCODE_SIZE(src_size);\r\nmemcpy(vcbase, rec->data, src_size);\r\npcbase += dst_size;\r\nvcbase += dst_size;\r\nwhere++;\r\n}\r\nout:\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}\r\nint mga_warp_init(drm_mga_private_t *dev_priv)\r\n{\r\nu32 wmisc;\r\nswitch (dev_priv->chipset) {\r\ncase MGA_CARD_TYPE_G400:\r\ncase MGA_CARD_TYPE_G550:\r\nMGA_WRITE(MGA_WIADDR2, MGA_WMODE_SUSPEND);\r\nMGA_WRITE(MGA_WGETMSB, 0x00000E00);\r\nMGA_WRITE(MGA_WVRTXSZ, 0x00001807);\r\nMGA_WRITE(MGA_WACCEPTSEQ, 0x18000000);\r\nbreak;\r\ncase MGA_CARD_TYPE_G200:\r\nMGA_WRITE(MGA_WIADDR, MGA_WMODE_SUSPEND);\r\nMGA_WRITE(MGA_WGETMSB, 0x1606);\r\nMGA_WRITE(MGA_WVRTXSZ, 7);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nMGA_WRITE(MGA_WMISC, (MGA_WUCODECACHE_ENABLE |\r\nMGA_WMASTER_ENABLE | MGA_WCACHEFLUSH_ENABLE));\r\nwmisc = MGA_READ(MGA_WMISC);\r\nif (wmisc != WMISC_EXPECTED) {\r\nDRM_ERROR("WARP engine config failed! 0x%x != 0x%x\n",\r\nwmisc, WMISC_EXPECTED);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
