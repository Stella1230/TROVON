static void ess_exec_commands\r\n(sb_devc *devc, struct ess_command *cmdtab[])\r\n{\r\nstruct ess_command *cmd;\r\ncmd = cmdtab [ ((devc->channels != 1) << 1) + (devc->bits != AFMT_U8) ];\r\nwhile (cmd->cmd != -1) {\r\ness_write (devc, cmd->cmd, cmd->data);\r\ncmd++;\r\n}\r\n}\r\nstatic void ess_change\r\n(sb_devc *devc, unsigned int reg, unsigned int mask, unsigned int val)\r\n{\r\nint value;\r\nvalue = ess_read (devc, reg);\r\nvalue = (value & ~mask) | (val & mask);\r\ness_write (devc, reg, value);\r\n}\r\nstatic void ess_set_output_parms\r\n(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (devc->duplex) {\r\ndevc->trg_buf_16 = buf;\r\ndevc->trg_bytes_16 = nr_bytes;\r\ndevc->trg_intrflag_16 = intrflag;\r\ndevc->irq_mode_16 = IMODE_OUTPUT;\r\n} else {\r\ndevc->trg_buf = buf;\r\ndevc->trg_bytes = nr_bytes;\r\ndevc->trg_intrflag = intrflag;\r\ndevc->irq_mode = IMODE_OUTPUT;\r\n}\r\n}\r\nstatic void ess_set_input_parms\r\n(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\ndevc->trg_buf = buf;\r\ndevc->trg_bytes = count;\r\ndevc->trg_intrflag = intrflag;\r\ndevc->irq_mode = IMODE_INPUT;\r\n}\r\nstatic int ess_calc_div (int clock, int revert, int *speedp, int *diffp)\r\n{\r\nint divider;\r\nint speed, diff;\r\nint retval;\r\nspeed = *speedp;\r\ndivider = (clock + speed / 2) / speed;\r\nretval = revert - divider;\r\nif (retval > revert - 1) {\r\nretval = revert - 1;\r\ndivider = revert - retval;\r\n}\r\n*speedp = clock / divider;\r\ndiff = speed - *speedp;\r\nif (diff < 0) diff =-diff;\r\n*diffp = diff;\r\nreturn retval;\r\n}\r\nstatic int ess_calc_best_speed\r\n(int clock1, int rev1, int clock2, int rev2, int *divp, int *speedp)\r\n{\r\nint speed1 = *speedp, speed2 = *speedp;\r\nint div1, div2;\r\nint diff1, diff2;\r\nint retval;\r\ndiv1 = ess_calc_div (clock1, rev1, &speed1, &diff1);\r\ndiv2 = ess_calc_div (clock2, rev2, &speed2, &diff2);\r\nif (diff1 < diff2) {\r\n*divp = div1;\r\n*speedp = speed1;\r\nretval = 1;\r\n} else {\r\n*divp = 0x80 | div2;\r\n*speedp = speed2;\r\nretval = 2;\r\n}\r\nreturn retval;\r\n}\r\nstatic void ess_common_speed (sb_devc *devc, int *speedp, int *divp)\r\n{\r\nint diff = 0, div;\r\nif (devc->duplex) {\r\nif (devc->submodel == SUBMDL_ES1888) {\r\ndiv = 0x80 | ess_calc_div (795500, 256, speedp, &diff);\r\n} else {\r\ndiv = 0x80 | ess_calc_div (795500, 128, speedp, &diff);\r\n}\r\n} else if(devc->caps & SB_CAP_ES18XX_RATE) {\r\nif (devc->submodel == SUBMDL_ES1888) {\r\ness_calc_best_speed(397700, 128, 795500, 256,\r\n&div, speedp);\r\n} else {\r\ness_calc_best_speed(ES18XX_CLOCK1, 128, ES18XX_CLOCK2, 256,\r\n&div, speedp);\r\n}\r\n} else {\r\nif (*speedp > 22000) {\r\ndiv = 0x80 | ess_calc_div (ES1688_CLOCK1, 256, speedp, &diff);\r\n} else {\r\ndiv = 0x00 | ess_calc_div (ES1688_CLOCK2, 128, speedp, &diff);\r\n}\r\n}\r\n*divp = div;\r\n}\r\nstatic void ess_speed (sb_devc *devc, int audionum)\r\n{\r\nint speed;\r\nint div, div2;\r\ness_common_speed (devc, &(devc->speed), &div);\r\n#ifdef FKS_REG_LOGGING\r\nprintk (KERN_INFO "FKS: ess_speed (%d) b speed = %d, div=%x\n", audionum, devc->speed, div);\r\n#endif\r\nspeed = (devc->speed * 9) / 20;\r\ndiv2 = 256 - 7160000 / (speed * 82);\r\nif (!devc->duplex) audionum = 1;\r\nif (audionum == 1) {\r\ness_write (devc, 0xa1, div);\r\ness_write (devc, 0xa2, div2);\r\n} else {\r\ness_setmixer (devc, 0x70, div);\r\ness_write (devc, 0xa2, div2);\r\ness_setmixer (devc, 0x72, div2);\r\n}\r\n}\r\nstatic int ess_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\ness_speed(devc, 1);\r\nsb_dsp_command(devc, DSP_CMD_SPKOFF);\r\ness_write (devc, 0xb8, 0x0e);\r\ness_change (devc, 0xa8, 0x03, 3 - devc->channels);\r\ness_write (devc, 0xb9, 2);\r\ness_exec_commands (devc, ess_inp_cmds);\r\ness_change (devc, 0xb1, 0xf0, 0x50);\r\ness_change (devc, 0xb2, 0xf0, 0x50);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int ess_audio_prepare_for_output_audio1 (int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nsb_dsp_reset(devc);\r\ness_speed(devc, 1);\r\ness_write (devc, 0xb8, 4);\r\ness_change (devc, 0xa8, 0x03, 3 - devc->channels);\r\ness_write (devc, 0xb9, 2);\r\ness_exec_commands (devc, ess_out_cmds);\r\ness_change (devc, 0xb1, 0xf0, 0x50);\r\ness_change (devc, 0xb2, 0xf0, 0x50);\r\nsb_dsp_command(devc, DSP_CMD_SPKON);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int ess_audio_prepare_for_output_audio2 (int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned char bits;\r\ness_chgmixer (devc, 0x78, 0xd0, 0xd0);\r\ness_speed(devc, 2);\r\nbits = ess_getmixer (devc, 0x7a) & 0x18;\r\nif (devc->channels != 1) bits |= 0x02;\r\nif (devc->bits != AFMT_U8) bits |= 0x05;\r\nbits |= 0x60;\r\ness_setmixer (devc, 0x7a, bits);\r\ness_mixer_reload (devc, SOUND_MIXER_PCM);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int ess_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\n#ifdef FKS_REG_LOGGING\r\nprintk(KERN_INFO "ess_audio_prepare_for_output: dma_out=%d,dma_in=%d\n"\r\n, audio_devs[dev]->dmap_out->dma, audio_devs[dev]->dmap_in->dma);\r\n#endif\r\nif (devc->duplex) {\r\nreturn ess_audio_prepare_for_output_audio2 (dev, bsize, bcount);\r\n} else {\r\nreturn ess_audio_prepare_for_output_audio1 (dev, bsize, bcount);\r\n}\r\n}\r\nstatic void ess_audio_halt_xfer(int dev)\r\n{\r\nunsigned long flags;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nsb_dsp_reset(devc);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nif (devc->duplex) ess_chgmixer(devc, 0x78, 0x03, 0x00);\r\n}\r\nstatic void ess_audio_start_input\r\n(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nshort c = -nr_bytes;\r\nif (audio_devs[dev]->dmap_in->dma > 3) count >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_INPUT;\r\ness_write (devc, 0xa4, (unsigned char) ((unsigned short) c & 0xff));\r\ness_write (devc, 0xa5, (unsigned char) (((unsigned short) c >> 8) & 0xff));\r\ness_change (devc, 0xb8, 0x0f, 0x0f);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void ess_audio_output_block_audio1\r\n(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nshort c = -nr_bytes;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_OUTPUT;\r\ness_write (devc, 0xa4, (unsigned char) ((unsigned short) c & 0xff));\r\ness_write (devc, 0xa5, (unsigned char) (((unsigned short) c >> 8) & 0xff));\r\ness_change (devc, 0xb8, 0x05, 0x05);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void ess_audio_output_block_audio2\r\n(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nshort c = -nr_bytes;\r\nif (audio_devs[dev]->dmap_out->dma > 3) count >>= 1;\r\ncount--;\r\ness_setmixer (devc, 0x74, (unsigned char) ((unsigned short) c & 0xff));\r\ness_setmixer (devc, 0x76, (unsigned char) (((unsigned short) c >> 8) & 0xff));\r\ness_chgmixer (devc, 0x78, 0x03, 0x03);\r\ndevc->irq_mode_16 = IMODE_OUTPUT;\r\ndevc->intr_active_16 = 1;\r\n}\r\nstatic void ess_audio_output_block\r\n(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (devc->duplex) {\r\ness_audio_output_block_audio2 (dev, buf, nr_bytes, intrflag);\r\n} else {\r\ness_audio_output_block_audio1 (dev, buf, nr_bytes, intrflag);\r\n}\r\n}\r\nstatic void ess_audio_trigger(int dev, int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint bits_16 = bits & devc->irq_mode_16;\r\nbits &= devc->irq_mode;\r\nif (!bits && !bits_16) {\r\nsb_dsp_command(devc, 0xd0);\r\n}\r\nif (bits) {\r\nswitch (devc->irq_mode)\r\n{\r\ncase IMODE_INPUT:\r\ness_audio_start_input(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\ness_audio_output_block(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\n}\r\n}\r\nif (bits_16) {\r\nswitch (devc->irq_mode_16) {\r\ncase IMODE_INPUT:\r\ness_audio_start_input(dev, devc->trg_buf_16, devc->trg_bytes_16,\r\ndevc->trg_intrflag_16);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\ness_audio_output_block(dev, devc->trg_buf_16, devc->trg_bytes_16,\r\ndevc->trg_intrflag_16);\r\nbreak;\r\n}\r\n}\r\ndevc->trigger_bits = bits | bits_16;\r\n}\r\nstatic int ess_audio_set_speed(int dev, int speed)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint minspeed, maxspeed, dummydiv;\r\nif (speed > 0) {\r\nminspeed = (devc->duplex ? 6215 : 5000 );\r\nmaxspeed = (devc->duplex ? 44100 : 48000);\r\nif (speed < minspeed) speed = minspeed;\r\nif (speed > maxspeed) speed = maxspeed;\r\ness_common_speed (devc, &speed, &dummydiv);\r\ndevc->speed = speed;\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic unsigned int ess_audio_set_bits(int dev, unsigned int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (bits != 0) {\r\nif (bits == AFMT_U8 || bits == AFMT_S16_LE) {\r\ndevc->bits = bits;\r\n} else {\r\ndevc->bits = AFMT_U8;\r\n}\r\n}\r\nreturn devc->bits;\r\n}\r\nstatic short ess_audio_set_channels(int dev, short channels)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (channels == 1 || channels == 2) devc->channels = channels;\r\nreturn devc->channels;\r\n}\r\nstruct audio_driver *ess_audio_init\r\n(sb_devc *devc, int *audio_flags, int *format_mask)\r\n{\r\n*audio_flags = DMA_AUTOMODE;\r\n*format_mask |= AFMT_S16_LE;\r\nif (devc->duplex) {\r\nint tmp_dma;\r\ntmp_dma = devc->dma16;\r\ndevc->dma16 = devc->dma8;\r\ndevc->dma8 = tmp_dma;\r\n*audio_flags |= DMA_DUPLEX;\r\n}\r\nreturn &ess_audio_driver;\r\n}\r\nstatic void ess_handle_channel\r\n(char *channel, int dev, int intr_active, unsigned char flag, int irq_mode)\r\n{\r\nif (!intr_active || !flag) return;\r\n#ifdef FKS_REG_LOGGING\r\nprintk(KERN_INFO "FKS: ess_handle_channel %s irq_mode=%d\n", channel, irq_mode);\r\n#endif\r\nswitch (irq_mode) {\r\ncase IMODE_OUTPUT:\r\nDMAbuf_outputintr (dev, 1);\r\nbreak;\r\ncase IMODE_INPUT:\r\nDMAbuf_inputintr (dev);\r\nbreak;\r\ncase IMODE_INIT:\r\nbreak;\r\ndefault:;\r\n}\r\n}\r\nvoid ess_intr (sb_devc *devc)\r\n{\r\nint status;\r\nunsigned char src;\r\nif (devc->submodel == SUBMDL_ES1887) {\r\nsrc = ess_getmixer (devc, 0x7f) >> 4;\r\n} else {\r\nsrc = 0xff;\r\n}\r\n#ifdef FKS_REG_LOGGING\r\nprintk(KERN_INFO "FKS: sbintr src=%x\n",(int)src);\r\n#endif\r\ness_handle_channel\r\n( "Audio 1"\r\n, devc->dev, devc->intr_active , src & 0x01, devc->irq_mode );\r\ness_handle_channel\r\n( "Audio 2"\r\n, devc->dev, devc->intr_active_16, src & 0x02, devc->irq_mode_16);\r\nif (devc->submodel == SUBMDL_ES1887 && (src & 0x02)) {\r\ness_chgmixer (devc, 0x7a, 0x80, 0x00);\r\n}\r\nif (src & 0x01) {\r\nstatus = inb(DSP_DATA_AVAIL);\r\n}\r\n}\r\nstatic void ess_extended (sb_devc * devc)\r\n{\r\nsb_dsp_command(devc, 0xc6);\r\n}\r\nstatic int ess_write (sb_devc * devc, unsigned char reg, unsigned char data)\r\n{\r\n#ifdef FKS_REG_LOGGING\r\nprintk(KERN_INFO "FKS: write reg %x: %x\n", reg, data);\r\n#endif\r\nif (!sb_dsp_command(devc, reg))\r\nreturn 0;\r\nreturn sb_dsp_command(devc, data);\r\n}\r\nstatic int ess_read (sb_devc * devc, unsigned char reg)\r\n{\r\nif (!sb_dsp_command(devc, 0xc0)) return -1;\r\nif (!sb_dsp_command(devc, reg )) return -1;\r\nreturn sb_dsp_get_byte(devc);\r\n}\r\nint ess_dsp_reset(sb_devc * devc)\r\n{\r\nint loopc;\r\n#ifdef FKS_REG_LOGGING\r\nprintk(KERN_INFO "FKS: ess_dsp_reset 1\n");\r\ness_show_mixerregs (devc);\r\n#endif\r\nDEB(printk("Entered ess_dsp_reset()\n"));\r\noutb(3, DSP_RESET);\r\nudelay(10);\r\noutb(0, DSP_RESET);\r\nudelay(30);\r\nfor (loopc = 0; loopc < 1000 && !(inb(DSP_DATA_AVAIL) & 0x80); loopc++);\r\nif (inb(DSP_READ) != 0xAA) {\r\nDDB(printk("sb: No response to RESET\n"));\r\nreturn 0;\r\n}\r\ness_extended (devc);\r\nDEB(printk("sb_dsp_reset() OK\n"));\r\n#ifdef FKS_LOGGING\r\nprintk(KERN_INFO "FKS: dsp_reset 2\n");\r\ness_show_mixerregs (devc);\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int ess_irq_bits (int irq)\r\n{\r\nswitch (irq) {\r\ncase 2:\r\ncase 9:\r\nreturn 0;\r\ncase 5:\r\nreturn 1;\r\ncase 7:\r\nreturn 2;\r\ncase 10:\r\nreturn 3;\r\ndefault:\r\nprintk(KERN_ERR "ESS1688: Invalid IRQ %d\n", irq);\r\nreturn -1;\r\n}\r\n}\r\nstatic int ess_common_set_irq_hw (sb_devc * devc)\r\n{\r\nint irq_bits;\r\nif ((irq_bits = ess_irq_bits (devc->irq)) == -1) return 0;\r\nif (!ess_write (devc, 0xb1, 0x50 | (irq_bits << 2))) {\r\nprintk(KERN_ERR "ES1688: Failed to write to IRQ config register\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void ess_es1887_set_irq_hw (sb_devc * devc)\r\n{\r\nint irq_bits;\r\nif ((irq_bits = ess_irq_bits (devc->irq)) == -1) return;\r\ness_chgmixer (devc, 0x7f, 0x0f, 0x01 | ((irq_bits + 1) << 1));\r\n}\r\nstatic int ess_set_irq_hw (sb_devc * devc)\r\n{\r\nif (devc->submodel == SUBMDL_ES1887) ess_es1887_set_irq_hw (devc);\r\nreturn ess_common_set_irq_hw (devc);\r\n}\r\nstatic void FKS_test (sb_devc * devc)\r\n{\r\nint val1, val2;\r\nval1 = ess_getmixer (devc, 0x64);\r\ness_setmixer (devc, 0x64, ~val1);\r\nval2 = ess_getmixer (devc, 0x64) ^ ~val1;\r\ness_setmixer (devc, 0x64, val1);\r\nval1 ^= ess_getmixer (devc, 0x64);\r\nprintk (KERN_INFO "FKS: FKS_test %02x, %02x\n", (val1 & 0x0ff), (val2 & 0x0ff));\r\n}\r\nstatic unsigned int ess_identify (sb_devc * devc)\r\n{\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock, flags);\r\noutb(((unsigned char) (0x40 & 0xff)), MIXER_ADDR);\r\nudelay(20);\r\nval = inb(MIXER_DATA) << 8;\r\nudelay(20);\r\nval |= inb(MIXER_DATA);\r\nudelay(20);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn val;\r\n}\r\nstatic int ess_probe (sb_devc * devc, int reg, int xorval)\r\n{\r\nint val1, val2, val3;\r\nval1 = ess_getmixer (devc, reg);\r\nval2 = val1 ^ xorval;\r\ness_setmixer (devc, reg, val2);\r\nval3 = ess_getmixer (devc, reg);\r\ness_setmixer (devc, reg, val1);\r\nreturn (val2 == val3);\r\n}\r\nint ess_init(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nunsigned char cfg;\r\nint ess_major = 0, ess_minor = 0;\r\nint i;\r\nstatic char name[100], modelname[10];\r\nsb_dsp_command(devc, 0xe7);\r\nfor (i = 1000; i; i--) {\r\nif (inb(DSP_DATA_AVAIL) & 0x80) {\r\nif (ess_major == 0) {\r\ness_major = inb(DSP_READ);\r\n} else {\r\ness_minor = inb(DSP_READ);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ess_major == 0) return 0;\r\nif (ess_major == 0x48 && (ess_minor & 0xf0) == 0x80) {\r\nsprintf(name, "ESS ES488 AudioDrive (rev %d)",\r\ness_minor & 0x0f);\r\nhw_config->name = name;\r\ndevc->model = MDL_SBPRO;\r\nreturn 1;\r\n}\r\ndevc->model = MDL_ESS;\r\ndevc->submodel = ess_minor & 0x0f;\r\nif (ess_major == 0x68 && (ess_minor & 0xf0) == 0x80) {\r\nchar *chip = NULL;\r\nint submodel = -1;\r\nswitch (devc->sbmo.esstype) {\r\ncase ESSTYPE_DETECT:\r\ncase ESSTYPE_LIKE20:\r\nbreak;\r\ncase 688:\r\nsubmodel = 0x00;\r\nbreak;\r\ncase 1688:\r\nsubmodel = 0x08;\r\nbreak;\r\ncase 1868:\r\nsubmodel = SUBMDL_ES1868;\r\nbreak;\r\ncase 1869:\r\nsubmodel = SUBMDL_ES1869;\r\nbreak;\r\ncase 1788:\r\nsubmodel = SUBMDL_ES1788;\r\nbreak;\r\ncase 1878:\r\nsubmodel = SUBMDL_ES1878;\r\nbreak;\r\ncase 1879:\r\nsubmodel = SUBMDL_ES1879;\r\nbreak;\r\ncase 1887:\r\nsubmodel = SUBMDL_ES1887;\r\nbreak;\r\ncase 1888:\r\nsubmodel = SUBMDL_ES1888;\r\nbreak;\r\ndefault:\r\nprintk (KERN_ERR "Invalid esstype=%d specified\n", devc->sbmo.esstype);\r\nreturn 0;\r\n}\r\nif (submodel != -1) {\r\ndevc->submodel = submodel;\r\nsprintf (modelname, "ES%d", devc->sbmo.esstype);\r\nchip = modelname;\r\n}\r\nif (chip == NULL && (ess_minor & 0x0f) < 8) {\r\nchip = "ES688";\r\n}\r\n#ifdef FKS_TEST\r\nFKS_test (devc);\r\n#endif\r\nif (chip == NULL && devc->sbmo.esstype == ESSTYPE_LIKE20) {\r\nchip = "ES1688";\r\n}\r\nif (chip == NULL) {\r\nint type;\r\ntype = ess_identify (devc);\r\nswitch (type) {\r\ncase 0x1868:\r\nchip = "ES1868";\r\ndevc->submodel = SUBMDL_ES1868;\r\nbreak;\r\ncase 0x1869:\r\nchip = "ES1869";\r\ndevc->submodel = SUBMDL_ES1869;\r\nbreak;\r\ncase 0x1878:\r\nchip = "ES1878";\r\ndevc->submodel = SUBMDL_ES1878;\r\nbreak;\r\ncase 0x1879:\r\nchip = "ES1879";\r\ndevc->submodel = SUBMDL_ES1879;\r\nbreak;\r\ndefault:\r\nif ((type & 0x00ff) != ((type >> 8) & 0x00ff)) {\r\nprintk ("ess_init: Unrecognized %04x\n", type);\r\n}\r\n}\r\n}\r\n#if 0\r\nif (chip == NULL && !ess_probe(devc, 0x64, (1 << 4))) {\r\n#endif\r\nif (chip == NULL && ess_probe(devc, 0x64, (1 << 2))) {\r\nif (ess_probe (devc, 0x70, 0x7f)) {\r\nif (ess_probe (devc, 0x64, (1 << 5))) {\r\nchip = "ES1887";\r\ndevc->submodel = SUBMDL_ES1887;\r\n} else {\r\nchip = "ES1888";\r\ndevc->submodel = SUBMDL_ES1888;\r\n}\r\n} else {\r\nchip = "ES1788";\r\ndevc->submodel = SUBMDL_ES1788;\r\n}\r\n}\r\nif (chip == NULL) {\r\nchip = "ES1688";\r\n}\r\nprintk ( KERN_INFO "ESS chip %s %s%s\n"\r\n, chip\r\n, ( devc->sbmo.esstype == ESSTYPE_DETECT || devc->sbmo.esstype == ESSTYPE_LIKE20\r\n? "detected"\r\n: "specified"\r\n)\r\n, ( devc->sbmo.esstype == ESSTYPE_LIKE20\r\n? " (kernel 2.0 compatible)"\r\n: ""\r\n)\r\n);\r\nsprintf(name,"ESS %s AudioDrive (rev %d)", chip, ess_minor & 0x0f);\r\n} else {\r\nstrcpy(name, "Jazz16");\r\n}\r\nswitch(devc->submodel) {\r\ncase SUBMDL_ES1888:\r\ndevc->caps |= SB_CAP_ES18XX_RATE;\r\nbreak;\r\n}\r\nhw_config->name = name;\r\nsb_dsp_reset(devc);\r\ncfg = ess_getmixer (devc, 0x40);\r\ness_setmixer (devc, 0x40, cfg | 0x03);\r\nif (devc->submodel >= 8) {\r\ndevc->caps |= SB_NO_MIDI;\r\n}\r\nsb_dsp_reset (devc);\r\nreturn ess_set_irq_hw (devc);\r\n}\r\nstatic int ess_set_dma_hw(sb_devc * devc)\r\n{\r\nunsigned char cfg, dma_bits = 0, dma16_bits;\r\nint dma;\r\n#ifdef FKS_LOGGING\r\nprintk(KERN_INFO "ess_set_dma_hw: dma8=%d,dma16=%d,dup=%d\n"\r\n, devc->dma8, devc->dma16, devc->duplex);\r\n#endif\r\ndma = devc->dma8;\r\nif (dma > 3 || dma < 0 || dma == 2) {\r\ndma_bits = 0;\r\nprintk(KERN_ERR "ESS1688: Invalid DMA8 %d\n", dma);\r\nreturn 0;\r\n} else {\r\ncfg = 0x50;\r\nif (dma == 3) {\r\ndma_bits = 3;\r\n} else {\r\ndma_bits = dma + 1;\r\n}\r\n}\r\nif (!ess_write (devc, 0xb2, cfg | (dma_bits << 2))) {\r\nprintk(KERN_ERR "ESS1688: Failed to write to DMA config register\n");\r\nreturn 0;\r\n}\r\nif (devc->duplex) {\r\ndma = devc->dma16;\r\ndma16_bits = 0;\r\nif (dma >= 0) {\r\nswitch (dma) {\r\ncase 0:\r\ndma_bits = 0x04;\r\nbreak;\r\ncase 1:\r\ndma_bits = 0x05;\r\nbreak;\r\ncase 3:\r\ndma_bits = 0x06;\r\nbreak;\r\ncase 5:\r\ndma_bits = 0x07;\r\ndma16_bits = 0x20;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "ESS1887: Invalid DMA16 %d\n", dma);\r\nreturn 0;\r\n}\r\ness_chgmixer (devc, 0x78, 0x20, dma16_bits);\r\ness_chgmixer (devc, 0x7d, 0x07, dma_bits);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint ess_dsp_init (sb_devc *devc, struct address_info *hw_config)\r\n{\r\nif (devc->model != MDL_ESS) {\r\nprintk (KERN_INFO "ess_dsp_init for non ESS chip\n");\r\nreturn 1;\r\n}\r\nif (devc->submodel == SUBMDL_ES1887) {\r\nif (hw_config->dma2 != -1) {\r\ndevc->dma16 = hw_config->dma2;\r\n}\r\nif (devc->dma8 != devc->dma16 && devc->dma16 != -1) {\r\ndevc->duplex = 1;\r\n}\r\n}\r\nif (!ess_set_dma_hw (devc)) {\r\nfree_irq(devc->irq, devc);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ess_has_rec_mixer (int submodel)\r\n{\r\nswitch (submodel) {\r\ncase SUBMDL_ES1887:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void ess_show_mixerregs (sb_devc *devc)\r\n{\r\nint *mp = ess_mixer_mon_regs;\r\nreturn;\r\nwhile (*mp != 0) {\r\nprintk (KERN_INFO "res (%x)=%x\n", *mp, (int)(ess_getmixer (devc, *mp)));\r\nmp++;\r\n}\r\n}\r\nvoid ess_setmixer (sb_devc * devc, unsigned int port, unsigned int value)\r\n{\r\nunsigned long flags;\r\n#ifdef FKS_LOGGING\r\nprintk(KERN_INFO "FKS: write mixer %x: %x\n", port, value);\r\n#endif\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (port >= 0xa0) {\r\ness_write (devc, port, value);\r\n} else {\r\noutb(((unsigned char) (port & 0xff)), MIXER_ADDR);\r\nudelay(20);\r\noutb(((unsigned char) (value & 0xff)), MIXER_DATA);\r\nudelay(20);\r\n}\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nunsigned int ess_getmixer (sb_devc * devc, unsigned int port)\r\n{\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (port >= 0xa0) {\r\nval = ess_read (devc, port);\r\n} else {\r\noutb(((unsigned char) (port & 0xff)), MIXER_ADDR);\r\nudelay(20);\r\nval = inb(MIXER_DATA);\r\nudelay(20);\r\n}\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn val;\r\n}\r\nstatic void ess_chgmixer\r\n(sb_devc * devc, unsigned int reg, unsigned int mask, unsigned int val)\r\n{\r\nint value;\r\nvalue = ess_getmixer (devc, reg);\r\nvalue = (value & ~mask) | (val & mask);\r\ness_setmixer (devc, reg, value);\r\n}\r\nvoid ess_mixer_init (sb_devc * devc)\r\n{\r\ndevc->mixer_caps = SOUND_CAP_EXCL_INPUT;\r\nswitch (devc->submodel) {\r\ncase SUBMDL_ES1887:\r\ndevc->supported_devices = ES1887_MIXER_DEVICES;\r\ndevc->supported_rec_devices = ES1887_RECORDING_DEVICES;\r\n#ifdef FKS_LOGGING\r\nprintk (KERN_INFO "FKS: ess_mixer_init dup = %d\n", devc->duplex);\r\n#endif\r\nif (devc->duplex) {\r\ndevc->iomap = &es1887_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(es1887_mix);\r\n} else {\r\ndevc->iomap = &es_rec_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(es_rec_mix);\r\n}\r\nbreak;\r\ndefault:\r\nif (devc->submodel < 8) {\r\ndevc->supported_devices = ES688_MIXER_DEVICES;\r\ndevc->supported_rec_devices = ES688_RECORDING_DEVICES;\r\ndevc->iomap = &es688_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(es688_mix);\r\n} else {\r\ndevc->supported_devices = ES1688_MIXER_DEVICES;\r\ndevc->supported_rec_devices = ES1688_RECORDING_DEVICES;\r\nif (devc->submodel < 0x10) {\r\ndevc->iomap = &es1688_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(es688_mix);\r\n} else {\r\ndevc->iomap = &es1688later_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(es1688later_mix);\r\n}\r\n}\r\n}\r\n}\r\nint ess_mixer_set(sb_devc *devc, int dev, int left, int right)\r\n{\r\nif (ess_has_rec_mixer (devc->submodel) && (devc->recmask & (1 << dev))) {\r\nsb_common_mixer_set (devc, dev + ES_REC_MIXER_RECDIFF, left, right);\r\n}\r\nreturn sb_common_mixer_set (devc, dev, left, right);\r\n}\r\nvoid ess_mixer_reload (sb_devc *devc, int dev)\r\n{\r\nint left, right, value;\r\nvalue = devc->levels[dev];\r\nleft = value & 0x000000ff;\r\nright = (value & 0x0000ff00) >> 8;\r\nsb_common_mixer_set(devc, dev, left, right);\r\n}\r\nstatic int es_rec_set_recmask(sb_devc * devc, int mask)\r\n{\r\nint i, i_mask, cur_mask, diff_mask;\r\nint value, left, right;\r\n#ifdef FKS_LOGGING\r\nprintk (KERN_INFO "FKS: es_rec_set_recmask mask = %x\n", mask);\r\n#endif\r\ncur_mask = devc->recmask;\r\ndiff_mask = (cur_mask ^ mask);\r\nfor (i = 0; i < 32; i++) {\r\ni_mask = (1 << i);\r\nif (diff_mask & i_mask) {\r\nif (mask & i_mask) {\r\nvalue = devc->levels[i];\r\nleft = value & 0x000000ff;\r\nright = (value & 0x0000ff00) >> 8;\r\n} else {\r\nleft = 0;\r\nright = 0;\r\n}\r\nsb_common_mixer_set(devc, i + ES_REC_MIXER_RECDIFF, left, right);\r\n}\r\n}\r\nreturn mask;\r\n}\r\nint ess_set_recmask(sb_devc * devc, int *mask)\r\n{\r\nif (ess_has_rec_mixer (devc->submodel)) {\r\n*mask = es_rec_set_recmask (devc, *mask);\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nint ess_mixer_reset (sb_devc * devc)\r\n{\r\nif (ess_has_rec_mixer (devc->submodel)) {\r\nswitch (devc->submodel) {\r\ncase SUBMDL_ES1887:\r\ness_chgmixer(devc, 0x7a, 0x18, 0x08);\r\ness_chgmixer(devc, 0x1c, 0x07, 0x07);\r\nbreak;\r\n}\r\ndevc->recmask = devc->supported_rec_devices;\r\nes_rec_set_recmask(devc, 0);\r\ndevc->recmask = 0;\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nint ess_midi_init(sb_devc * devc, struct address_info *hw_config)\r\n{\r\nunsigned char cfg, tmp;\r\ncfg = ess_getmixer (devc, 0x40) & 0x03;\r\nif (devc->submodel < 8) {\r\ness_setmixer (devc, 0x40, cfg | 0x03);\r\nreturn 0;\r\n}\r\ntmp = (hw_config->io_base & 0x0f0) >> 4;\r\nif (tmp > 3) {\r\ness_setmixer (devc, 0x40, cfg);\r\nreturn 0;\r\n}\r\ncfg |= tmp << 3;\r\ntmp = 1;\r\nswitch (abs(hw_config->irq)) {\r\ncase 9:\r\ntmp = 0x4;\r\nbreak;\r\ncase 5:\r\ntmp = 0x5;\r\nbreak;\r\ncase 7:\r\ntmp = 0x6;\r\nbreak;\r\ncase 10:\r\ntmp = 0x7;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ncfg |= tmp << 5;\r\ness_setmixer (devc, 0x40, cfg | 0x03);\r\nreturn 1;\r\n}
