static inline int _hycapi_appCheck(int app_id, int ctrl_no)\r\n{\r\nif ((ctrl_no <= 0) || (ctrl_no > CAPI_MAXCONTR) || (app_id <= 0) ||\r\n(app_id > CAPI_MAXAPPL))\r\n{\r\nprintk(KERN_ERR "HYCAPI: Invalid request app_id %d for controller %d", app_id, ctrl_no);\r\nreturn -1;\r\n}\r\nreturn ((hycapi_applications[app_id - 1].ctrl_mask & (1 << (ctrl_no-1))) != 0);\r\n}\r\nstatic void\r\nhycapi_reset_ctr(struct capi_ctr *ctrl)\r\n{\r\nhycapictrl_info *cinfo = ctrl->driverdata;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "HYCAPI hycapi_reset_ctr\n");\r\n#endif\r\ncapilib_release(&cinfo->ncci_head);\r\ncapi_ctr_down(ctrl);\r\n}\r\nstatic void\r\nhycapi_remove_ctr(struct capi_ctr *ctrl)\r\n{\r\nint i;\r\nhycapictrl_info *cinfo = NULL;\r\nhysdn_card *card = NULL;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "HYCAPI hycapi_remove_ctr\n");\r\n#endif\r\ncinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nif (!cinfo) {\r\nprintk(KERN_ERR "No hycapictrl_info set!");\r\nreturn;\r\n}\r\ncard = cinfo->card;\r\ncapi_ctr_suspend_output(ctrl);\r\nfor (i = 0; i < CAPI_MAXAPPL; i++) {\r\nif (hycapi_applications[i].listen_req[ctrl->cnr - 1]) {\r\nkfree_skb(hycapi_applications[i].listen_req[ctrl->cnr - 1]);\r\nhycapi_applications[i].listen_req[ctrl->cnr - 1] = NULL;\r\n}\r\n}\r\ndetach_capi_ctr(ctrl);\r\nctrl->driverdata = NULL;\r\nkfree(card->hyctrlinfo);\r\ncard->hyctrlinfo = NULL;\r\n}\r\nstatic void\r\nhycapi_sendmsg_internal(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nhysdn_card *card = cinfo->card;\r\nspin_lock_irq(&cinfo->lock);\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_send_message\n");\r\n#endif\r\ncinfo->skbs[cinfo->in_idx++] = skb;\r\nif (cinfo->in_idx >= HYSDN_MAX_CAPI_SKB)\r\ncinfo->in_idx = 0;\r\ncinfo->sk_count++;\r\nif (cinfo->sk_count >= HYSDN_MAX_CAPI_SKB) {\r\nprintk(KERN_ERR "HYSDN Card%d: CAPI-buffer overrun!\n",\r\ncard->myid);\r\ncapi_ctr_suspend_output(ctrl);\r\n}\r\ncinfo->tx_skb = skb;\r\nspin_unlock_irq(&cinfo->lock);\r\nschedule_work(&card->irq_queue);\r\n}\r\nstatic void\r\nhycapi_register_internal(struct capi_ctr *ctrl, __u16 appl,\r\ncapi_register_params *rp)\r\n{\r\nchar ExtFeatureDefaults[] = "49 /0/0/0/0,*/1,*/2,*/3,*/4,*/5,*/6,*/7,*/8,*/9,*";\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nhysdn_card *card = cinfo->card;\r\nstruct sk_buff *skb;\r\n__u16 len;\r\n__u8 _command = 0xa0, _subcommand = 0x80;\r\n__u16 MessageNumber = 0x0000;\r\n__u16 MessageBufferSize = 0;\r\nint slen = strlen(ExtFeatureDefaults);\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_register_appl\n");\r\n#endif\r\nMessageBufferSize = rp->level3cnt * rp->datablkcnt * rp->datablklen;\r\nlen = CAPI_MSG_BASELEN + 8 + slen + 1;\r\nif (!(skb = alloc_skb(len, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HYSDN card%d: memory squeeze in hycapi_register_appl\n",\r\ncard->myid);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));\r\nmemcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &MessageBufferSize, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &(rp->level3cnt), sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &(rp->datablkcnt), sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &(rp->datablklen), sizeof(__u16));\r\nmemcpy(skb_put(skb, slen), ExtFeatureDefaults, slen);\r\nhycapi_applications[appl - 1].ctrl_mask |= (1 << (ctrl->cnr - 1));\r\nhycapi_send_message(ctrl, skb);\r\n}\r\nstatic void hycapi_restart_internal(struct capi_ctr *ctrl)\r\n{\r\nint i;\r\nstruct sk_buff *skb;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_WARNING "HYSDN: hycapi_restart_internal");\r\n#endif\r\nfor (i = 0; i < CAPI_MAXAPPL; i++) {\r\nif (_hycapi_appCheck(i + 1, ctrl->cnr) == 1) {\r\nhycapi_register_internal(ctrl, i + 1,\r\n&hycapi_applications[i].rp);\r\nif (hycapi_applications[i].listen_req[ctrl->cnr - 1]) {\r\nskb = skb_copy(hycapi_applications[i].listen_req[ctrl->cnr - 1], GFP_ATOMIC);\r\nhycapi_sendmsg_internal(ctrl, skb);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nhycapi_register_appl(struct capi_ctr *ctrl, __u16 appl,\r\ncapi_register_params *rp)\r\n{\r\nint MaxLogicalConnections = 0, MaxBDataBlocks = 0, MaxBDataLen = 0;\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nhysdn_card *card = cinfo->card;\r\nint chk = _hycapi_appCheck(appl, ctrl->cnr);\r\nif (chk < 0) {\r\nreturn;\r\n}\r\nif (chk == 1) {\r\nprintk(KERN_INFO "HYSDN: apl %d already registered\n", appl);\r\nreturn;\r\n}\r\nMaxBDataBlocks = rp->datablkcnt > CAPI_MAXDATAWINDOW ? CAPI_MAXDATAWINDOW : rp->datablkcnt;\r\nrp->datablkcnt = MaxBDataBlocks;\r\nMaxBDataLen = rp->datablklen < 1024 ? 1024 : rp->datablklen;\r\nrp->datablklen = MaxBDataLen;\r\nMaxLogicalConnections = rp->level3cnt;\r\nif (MaxLogicalConnections < 0) {\r\nMaxLogicalConnections = card->bchans * -MaxLogicalConnections;\r\n}\r\nif (MaxLogicalConnections == 0) {\r\nMaxLogicalConnections = card->bchans;\r\n}\r\nrp->level3cnt = MaxLogicalConnections;\r\nmemcpy(&hycapi_applications[appl - 1].rp,\r\nrp, sizeof(capi_register_params));\r\n}\r\nstatic void hycapi_release_internal(struct capi_ctr *ctrl, __u16 appl)\r\n{\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nhysdn_card *card = cinfo->card;\r\nstruct sk_buff *skb;\r\n__u16 len;\r\n__u8 _command = 0xa1, _subcommand = 0x80;\r\n__u16 MessageNumber = 0x0000;\r\ncapilib_release_appl(&cinfo->ncci_head, appl);\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_release_appl\n");\r\n#endif\r\nlen = CAPI_MSG_BASELEN;\r\nif (!(skb = alloc_skb(len, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HYSDN card%d: memory squeeze in hycapi_register_appl\n",\r\ncard->myid);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, sizeof(__u16)), &len, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &appl, sizeof(__u16));\r\nmemcpy(skb_put(skb, sizeof(__u8)), &_command, sizeof(_command));\r\nmemcpy(skb_put(skb, sizeof(__u8)), &_subcommand, sizeof(_subcommand));\r\nmemcpy(skb_put(skb, sizeof(__u16)), &MessageNumber, sizeof(__u16));\r\nhycapi_send_message(ctrl, skb);\r\nhycapi_applications[appl - 1].ctrl_mask &= ~(1 << (ctrl->cnr - 1));\r\n}\r\nstatic void\r\nhycapi_release_appl(struct capi_ctr *ctrl, __u16 appl)\r\n{\r\nint chk;\r\nchk = _hycapi_appCheck(appl, ctrl->cnr);\r\nif (chk < 0) {\r\nprintk(KERN_ERR "HYCAPI: Releasing invalid appl %d on controller %d\n", appl, ctrl->cnr);\r\nreturn;\r\n}\r\nif (hycapi_applications[appl - 1].listen_req[ctrl->cnr - 1]) {\r\nkfree_skb(hycapi_applications[appl - 1].listen_req[ctrl->cnr - 1]);\r\nhycapi_applications[appl - 1].listen_req[ctrl->cnr - 1] = NULL;\r\n}\r\nif (chk == 1)\r\n{\r\nhycapi_release_internal(ctrl, appl);\r\n}\r\n}\r\nint hycapi_capi_release(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = card->hyctrlinfo;\r\nstruct capi_ctr *ctrl;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_capi_release\n");\r\n#endif\r\nif (cinfo) {\r\nctrl = &cinfo->capi_ctrl;\r\nhycapi_remove_ctr(ctrl);\r\n}\r\nreturn 0;\r\n}\r\nint hycapi_capi_stop(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = card->hyctrlinfo;\r\nstruct capi_ctr *ctrl;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_capi_stop\n");\r\n#endif\r\nif (cinfo) {\r\nctrl = &cinfo->capi_ctrl;\r\ncapi_ctr_down(ctrl);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 hycapi_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\n__u16 appl_id;\r\nint _len, _len2;\r\n__u8 msghead[64];\r\nhycapictrl_info *cinfo = ctrl->driverdata;\r\nu16 retval = CAPI_NOERROR;\r\nappl_id = CAPIMSG_APPID(skb->data);\r\nswitch (_hycapi_appCheck(appl_id, ctrl->cnr))\r\n{\r\ncase 0:\r\nhycapi_register_internal(ctrl,\r\nappl_id,\r\n&(hycapi_applications[appl_id - 1].rp));\r\nbreak;\r\ncase 1:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "HYCAPI: Controller mixup!\n");\r\nretval = CAPI_ILLAPPNR;\r\ngoto out;\r\n}\r\nswitch (CAPIMSG_CMD(skb->data)) {\r\ncase CAPI_DISCONNECT_B3_RESP:\r\ncapilib_free_ncci(&cinfo->ncci_head, appl_id,\r\nCAPIMSG_NCCI(skb->data));\r\nbreak;\r\ncase CAPI_DATA_B3_REQ:\r\n_len = CAPIMSG_LEN(skb->data);\r\nif (_len > 22) {\r\n_len2 = _len - 22;\r\nskb_copy_from_linear_data(skb, msghead, 22);\r\nskb_copy_to_linear_data_offset(skb, _len2,\r\nmsghead, 22);\r\nskb_pull(skb, _len2);\r\nCAPIMSG_SETLEN(skb->data, 22);\r\nretval = capilib_data_b3_req(&cinfo->ncci_head,\r\nCAPIMSG_APPID(skb->data),\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\n}\r\nbreak;\r\ncase CAPI_LISTEN_REQ:\r\nif (hycapi_applications[appl_id - 1].listen_req[ctrl->cnr - 1])\r\n{\r\nkfree_skb(hycapi_applications[appl_id - 1].listen_req[ctrl->cnr - 1]);\r\nhycapi_applications[appl_id - 1].listen_req[ctrl->cnr - 1] = NULL;\r\n}\r\nif (!(hycapi_applications[appl_id -1].listen_req[ctrl->cnr - 1] = skb_copy(skb, GFP_ATOMIC)))\r\n{\r\nprintk(KERN_ERR "HYSDN: memory squeeze in private_listen\n");\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nif (retval == CAPI_NOERROR)\r\nhycapi_sendmsg_internal(ctrl, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn retval;\r\n}\r\nstatic int hycapi_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctrl = m->private;\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\nhysdn_card *card = cinfo->card;\r\nchar *s;\r\nseq_printf(m, "%-16s %s\n", "name", cinfo->cardname);\r\nseq_printf(m, "%-16s 0x%x\n", "io", card->iobase);\r\nseq_printf(m, "%-16s %d\n", "irq", card->irq);\r\nswitch (card->brdtype) {\r\ncase BD_PCCARD: s = "HYSDN Hycard"; break;\r\ncase BD_ERGO: s = "HYSDN Ergo2"; break;\r\ncase BD_METRO: s = "HYSDN Metro4"; break;\r\ncase BD_CHAMP2: s = "HYSDN Champ2"; break;\r\ncase BD_PLEXUS: s = "HYSDN Plexus30"; break;\r\ndefault: s = "???"; break;\r\n}\r\nseq_printf(m, "%-16s %s\n", "type", s);\r\nif ((s = cinfo->version[VER_DRIVER]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_driver", s);\r\nif ((s = cinfo->version[VER_CARDTYPE]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_cardtype", s);\r\nif ((s = cinfo->version[VER_SERIAL]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_serial", s);\r\nseq_printf(m, "%-16s %s\n", "cardname", cinfo->cardname);\r\nreturn 0;\r\n}\r\nstatic int hycapi_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hycapi_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int hycapi_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\r\n{\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_load_firmware\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic char *hycapi_procinfo(struct capi_ctr *ctrl)\r\n{\r\nhycapictrl_info *cinfo = (hycapictrl_info *)(ctrl->driverdata);\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_proc_info\n");\r\n#endif\r\nif (!cinfo)\r\nreturn "";\r\nsprintf(cinfo->infobuf, "%s %s 0x%x %d %s",\r\ncinfo->cardname[0] ? cinfo->cardname : "-",\r\ncinfo->version[VER_DRIVER] ? cinfo->version[VER_DRIVER] : "-",\r\ncinfo->card ? cinfo->card->iobase : 0x0,\r\ncinfo->card ? cinfo->card->irq : 0,\r\nhycapi_revision\r\n);\r\nreturn cinfo->infobuf;\r\n}\r\nvoid\r\nhycapi_rx_capipkt(hysdn_card *card, unsigned char *buf, unsigned short len)\r\n{\r\nstruct sk_buff *skb;\r\nhycapictrl_info *cinfo = card->hyctrlinfo;\r\nstruct capi_ctr *ctrl;\r\n__u16 ApplId;\r\n__u16 MsgLen, info;\r\n__u16 len2, CapiCmd;\r\n__u32 CP64[2] = {0, 0};\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_rx_capipkt\n");\r\n#endif\r\nif (!cinfo) {\r\nreturn;\r\n}\r\nctrl = &cinfo->capi_ctrl;\r\nif (len < CAPI_MSG_BASELEN) {\r\nprintk(KERN_ERR "HYSDN Card%d: invalid CAPI-message, length %d!\n",\r\ncard->myid, len);\r\nreturn;\r\n}\r\nMsgLen = CAPIMSG_LEN(buf);\r\nApplId = CAPIMSG_APPID(buf);\r\nCapiCmd = CAPIMSG_CMD(buf);\r\nif ((CapiCmd == CAPI_DATA_B3_IND) && (MsgLen < 30)) {\r\nlen2 = len + (30 - MsgLen);\r\nif (!(skb = alloc_skb(len2, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HYSDN Card%d: incoming packet dropped\n",\r\ncard->myid);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, MsgLen), buf, MsgLen);\r\nmemcpy(skb_put(skb, 2 * sizeof(__u32)), CP64, 2 * sizeof(__u32));\r\nmemcpy(skb_put(skb, len - MsgLen), buf + MsgLen,\r\nlen - MsgLen);\r\nCAPIMSG_SETLEN(skb->data, 30);\r\n} else {\r\nif (!(skb = alloc_skb(len, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "HYSDN Card%d: incoming packet dropped\n",\r\ncard->myid);\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, len), buf, len);\r\n}\r\nswitch (CAPIMSG_CMD(skb->data))\r\n{\r\ncase CAPI_CONNECT_B3_CONF:\r\ninfo = CAPIMSG_U16(skb->data, 12);\r\nswitch (info)\r\n{\r\ncase 0:\r\ncapilib_new_ncci(&cinfo->ncci_head, ApplId, CAPIMSG_NCCI(skb->data),\r\nhycapi_applications[ApplId - 1].rp.datablkcnt);\r\nbreak;\r\ncase 0x0001:\r\nprintk(KERN_ERR "HYSDN Card%d: NCPI not supported by current "\r\n"protocol. NCPI ignored.\n", card->myid);\r\nbreak;\r\ncase 0x2001:\r\nprintk(KERN_ERR "HYSDN Card%d: Message not supported in"\r\n" current state\n", card->myid);\r\nbreak;\r\ncase 0x2002:\r\nprintk(KERN_ERR "HYSDN Card%d: invalid PLCI\n", card->myid);\r\nbreak;\r\ncase 0x2004:\r\nprintk(KERN_ERR "HYSDN Card%d: out of NCCI\n", card->myid);\r\nbreak;\r\ncase 0x3008:\r\nprintk(KERN_ERR "HYSDN Card%d: NCPI not supported\n",\r\ncard->myid);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "HYSDN Card%d: Info in CONNECT_B3_CONF: %d\n",\r\ncard->myid, info);\r\nbreak;\r\n}\r\nbreak;\r\ncase CAPI_CONNECT_B3_IND:\r\ncapilib_new_ncci(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nhycapi_applications[ApplId - 1].rp.datablkcnt);\r\nbreak;\r\ncase CAPI_DATA_B3_CONF:\r\ncapilib_data_b3_conf(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nvoid hycapi_tx_capiack(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = card->hyctrlinfo;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_tx_capiack\n");\r\n#endif\r\nif (!cinfo) {\r\nreturn;\r\n}\r\nspin_lock_irq(&cinfo->lock);\r\nkfree_skb(cinfo->skbs[cinfo->out_idx]);\r\ncinfo->skbs[cinfo->out_idx++] = NULL;\r\nif (cinfo->out_idx >= HYSDN_MAX_CAPI_SKB)\r\ncinfo->out_idx = 0;\r\nif (cinfo->sk_count-- == HYSDN_MAX_CAPI_SKB)\r\ncapi_ctr_resume_output(&cinfo->capi_ctrl);\r\nspin_unlock_irq(&cinfo->lock);\r\n}\r\nstruct sk_buff *\r\nhycapi_tx_capiget(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = card->hyctrlinfo;\r\nif (!cinfo) {\r\nreturn (struct sk_buff *)NULL;\r\n}\r\nif (!cinfo->sk_count)\r\nreturn (struct sk_buff *)NULL;\r\nreturn (cinfo->skbs[cinfo->out_idx]);\r\n}\r\nint hycapi_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < CAPI_MAXAPPL; i++) {\r\nmemset(&(hycapi_applications[i]), 0, sizeof(hycapi_appl));\r\n}\r\nreturn (0);\r\n}\r\nvoid\r\nhycapi_cleanup(void)\r\n{\r\n}\r\nstatic void hycapi_fill_profile(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = NULL;\r\nstruct capi_ctr *ctrl = NULL;\r\ncinfo = card->hyctrlinfo;\r\nif (!cinfo) return;\r\nctrl = &cinfo->capi_ctrl;\r\nstrcpy(ctrl->manu, "Hypercope");\r\nctrl->version.majorversion = 2;\r\nctrl->version.minorversion = 0;\r\nctrl->version.majormanuversion = 3;\r\nctrl->version.minormanuversion = 2;\r\nctrl->profile.ncontroller = card->myid;\r\nctrl->profile.nbchannel = card->bchans;\r\nctrl->profile.goptions = GLOBAL_OPTION_INTERNAL_CONTROLLER |\r\nGLOBAL_OPTION_B_CHANNEL_OPERATION;\r\nctrl->profile.support1 = B1_PROT_64KBIT_HDLC |\r\n(card->faxchans ? B1_PROT_T30 : 0) |\r\nB1_PROT_64KBIT_TRANSPARENT;\r\nctrl->profile.support2 = B2_PROT_ISO7776 |\r\n(card->faxchans ? B2_PROT_T30 : 0) |\r\nB2_PROT_TRANSPARENT;\r\nctrl->profile.support3 = B3_PROT_TRANSPARENT |\r\nB3_PROT_T90NL |\r\n(card->faxchans ? B3_PROT_T30 : 0) |\r\n(card->faxchans ? B3_PROT_T30EXT : 0) |\r\nB3_PROT_ISO8208;\r\n}\r\nint\r\nhycapi_capi_create(hysdn_card *card)\r\n{\r\nhycapictrl_info *cinfo = NULL;\r\nstruct capi_ctr *ctrl = NULL;\r\nint retval;\r\n#ifdef HYCAPI_PRINTFNAMES\r\nprintk(KERN_NOTICE "hycapi_capi_create\n");\r\n#endif\r\nif ((hycapi_enable & (1 << card->myid)) == 0) {\r\nreturn 1;\r\n}\r\nif (!card->hyctrlinfo) {\r\ncinfo = kzalloc(sizeof(hycapictrl_info), GFP_ATOMIC);\r\nif (!cinfo) {\r\nprintk(KERN_WARNING "HYSDN: no memory for capi-ctrl.\n");\r\nreturn -ENOMEM;\r\n}\r\ncard->hyctrlinfo = cinfo;\r\ncinfo->card = card;\r\nspin_lock_init(&cinfo->lock);\r\nINIT_LIST_HEAD(&cinfo->ncci_head);\r\nswitch (card->brdtype) {\r\ncase BD_PCCARD: strcpy(cinfo->cardname, "HYSDN Hycard"); break;\r\ncase BD_ERGO: strcpy(cinfo->cardname, "HYSDN Ergo2"); break;\r\ncase BD_METRO: strcpy(cinfo->cardname, "HYSDN Metro4"); break;\r\ncase BD_CHAMP2: strcpy(cinfo->cardname, "HYSDN Champ2"); break;\r\ncase BD_PLEXUS: strcpy(cinfo->cardname, "HYSDN Plexus30"); break;\r\ndefault: strcpy(cinfo->cardname, "HYSDN ???"); break;\r\n}\r\nctrl = &cinfo->capi_ctrl;\r\nctrl->driver_name = "hycapi";\r\nctrl->driverdata = cinfo;\r\nctrl->register_appl = hycapi_register_appl;\r\nctrl->release_appl = hycapi_release_appl;\r\nctrl->send_message = hycapi_send_message;\r\nctrl->load_firmware = hycapi_load_firmware;\r\nctrl->reset_ctr = hycapi_reset_ctr;\r\nctrl->procinfo = hycapi_procinfo;\r\nctrl->proc_fops = &hycapi_proc_fops;\r\nstrcpy(ctrl->name, cinfo->cardname);\r\nctrl->owner = THIS_MODULE;\r\nretval = attach_capi_ctr(ctrl);\r\nif (retval) {\r\nprintk(KERN_ERR "hycapi: attach controller failed.\n");\r\nreturn -EBUSY;\r\n}\r\nhycapi_fill_profile(card);\r\ncapi_ctr_ready(ctrl);\r\n} else {\r\nctrl = &card->hyctrlinfo->capi_ctrl;\r\nhycapi_fill_profile(card);\r\ncapi_ctr_ready(ctrl);\r\nhycapi_restart_internal(ctrl);\r\n}\r\nreturn 0;\r\n}
