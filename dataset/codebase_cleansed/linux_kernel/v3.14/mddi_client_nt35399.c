static void\r\nnt35399_request_vsync(struct msm_panel_data *panel_data,\r\nstruct msmfb_callback *callback)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\npanel->fb_callback = callback;\r\nif (panel->nt35399_got_int) {\r\npanel->nt35399_got_int = 0;\r\nclient_data->activate_link(client_data);\r\n}\r\n}\r\nstatic void nt35399_wait_vsync(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nif (panel->nt35399_got_int) {\r\npanel->nt35399_got_int = 0;\r\nclient_data->activate_link(client_data);\r\n}\r\nif (wait_event_timeout(nt35399_vsync_wait, panel->nt35399_got_int,\r\nHZ/2) == 0)\r\nprintk(KERN_ERR "timeout waiting for VSYNC\n");\r\npanel->nt35399_got_int = 0;\r\n}\r\nstatic int nt35399_suspend(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nint ret;\r\nret = bridge_data->uninit(bridge_data, client_data);\r\nif (ret) {\r\nprintk(KERN_INFO "mddi nt35399 client: non zero return from "\r\n"uninit\n");\r\nreturn ret;\r\n}\r\nclient_data->suspend(client_data);\r\nreturn 0;\r\n}\r\nstatic int nt35399_resume(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nint ret;\r\nclient_data->resume(client_data);\r\nret = bridge_data->init(bridge_data, client_data);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int nt35399_blank(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nreturn bridge_data->blank(bridge_data, client_data);\r\n}\r\nstatic int nt35399_unblank(struct msm_panel_data *panel_data)\r\n{\r\nstruct panel_info *panel = container_of(panel_data, struct panel_info,\r\npanel_data);\r\nstruct msm_mddi_client_data *client_data = panel->client_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nreturn bridge_data->unblank(bridge_data, client_data);\r\n}\r\nirqreturn_t nt35399_vsync_interrupt(int irq, void *data)\r\n{\r\nstruct panel_info *panel = data;\r\npanel->nt35399_got_int = 1;\r\nif (panel->fb_callback) {\r\npanel->fb_callback->func(panel->fb_callback);\r\npanel->fb_callback = NULL;\r\n}\r\nwake_up(&nt35399_vsync_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int setup_vsync(struct panel_info *panel, int init)\r\n{\r\nint ret;\r\nint gpio = 97;\r\nunsigned int irq;\r\nif (!init) {\r\nret = 0;\r\ngoto uninit;\r\n}\r\nret = gpio_request_one(gpio, GPIOF_IN, "vsync");\r\nif (ret)\r\ngoto err_request_gpio_failed;\r\nret = irq = gpio_to_irq(gpio);\r\nif (ret < 0)\r\ngoto err_get_irq_num_failed;\r\nret = request_irq(irq, nt35399_vsync_interrupt, IRQF_TRIGGER_RISING,\r\n"vsync", panel);\r\nif (ret)\r\ngoto err_request_irq_failed;\r\nprintk(KERN_INFO "vsync on gpio %d now %d\n",\r\ngpio, gpio_get_value(gpio));\r\nreturn 0;\r\nuninit:\r\nfree_irq(gpio_to_irq(gpio), panel->client_data);\r\nerr_request_irq_failed:\r\nerr_get_irq_num_failed:\r\ngpio_free(gpio);\r\nerr_request_gpio_failed:\r\nreturn ret;\r\n}\r\nstatic int mddi_nt35399_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_mddi_client_data *client_data = pdev->dev.platform_data;\r\nstruct msm_mddi_bridge_platform_data *bridge_data =\r\nclient_data->private_client_data;\r\nint ret;\r\nstruct panel_info *panel = devm_kzalloc(&pdev->dev,\r\nsizeof(struct panel_info),\r\nGFP_KERNEL);\r\nprintk(KERN_DEBUG "%s: enter.\n", __func__);\r\nif (!panel)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, panel);\r\nret = setup_vsync(panel, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "mddi_nt35399_setup_vsync failed\n");\r\nreturn ret;\r\n}\r\npanel->client_data = client_data;\r\npanel->panel_data.suspend = nt35399_suspend;\r\npanel->panel_data.resume = nt35399_resume;\r\npanel->panel_data.wait_vsync = nt35399_wait_vsync;\r\npanel->panel_data.request_vsync = nt35399_request_vsync;\r\npanel->panel_data.blank = nt35399_blank;\r\npanel->panel_data.unblank = nt35399_unblank;\r\npanel->panel_data.fb_data = &bridge_data->fb_data;\r\npanel->panel_data.caps = 0;\r\npanel->pdev.name = "msm_panel";\r\npanel->pdev.id = pdev->id;\r\npanel->pdev.resource = client_data->fb_resource;\r\npanel->pdev.num_resources = 1;\r\npanel->pdev.dev.platform_data = &panel->panel_data;\r\nif (bridge_data->init)\r\nbridge_data->init(bridge_data, client_data);\r\nplatform_device_register(&panel->pdev);\r\nreturn 0;\r\n}\r\nstatic int mddi_nt35399_remove(struct platform_device *pdev)\r\n{\r\nstruct panel_info *panel = platform_get_drvdata(pdev);\r\nsetup_vsync(panel, 0);\r\nreturn 0;\r\n}\r\nstatic int __init mddi_client_nt35399_init(void)\r\n{\r\nreturn platform_driver_register(&mddi_client_0bda_8a47);\r\n}
