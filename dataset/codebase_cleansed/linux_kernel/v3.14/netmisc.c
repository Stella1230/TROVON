static int\r\ncifs_inet_pton(const int address_family, const char *cp, int len, void *dst)\r\n{\r\nint ret = 0;\r\nif (address_family == AF_INET)\r\nret = in4_pton(cp, len, dst, '\\', NULL);\r\nelse if (address_family == AF_INET6)\r\nret = in6_pton(cp, len, dst , '\\', NULL);\r\ncifs_dbg(NOISY, "address conversion returned %d for %*.*s\n",\r\nret, len, len, cp);\r\nif (ret > 0)\r\nret = 1;\r\nreturn ret;\r\n}\r\nint\r\ncifs_convert_address(struct sockaddr *dst, const char *src, int len)\r\n{\r\nint rc, alen, slen;\r\nconst char *pct;\r\nchar scope_id[13];\r\nstruct sockaddr_in *s4 = (struct sockaddr_in *) dst;\r\nstruct sockaddr_in6 *s6 = (struct sockaddr_in6 *) dst;\r\nif (cifs_inet_pton(AF_INET, src, len, &s4->sin_addr.s_addr)) {\r\ns4->sin_family = AF_INET;\r\nreturn 1;\r\n}\r\npct = memchr(src, '%', len);\r\nalen = pct ? pct - src : len;\r\nrc = cifs_inet_pton(AF_INET6, src, alen, &s6->sin6_addr.s6_addr);\r\nif (!rc)\r\nreturn rc;\r\ns6->sin6_family = AF_INET6;\r\nif (pct) {\r\nslen = len - (alen + 1);\r\nif (slen <= 0 || slen > 12)\r\nreturn 0;\r\nmemcpy(scope_id, pct + 1, slen);\r\nscope_id[slen] = '\0';\r\nrc = kstrtouint(scope_id, 0, &s6->sin6_scope_id);\r\nrc = (rc == 0) ? 1 : 0;\r\n}\r\nreturn rc;\r\n}\r\nvoid\r\ncifs_set_port(struct sockaddr *addr, const unsigned short int port)\r\n{\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)addr)->sin_port = htons(port);\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)addr)->sin6_port = htons(port);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncifs_print_status(__u32 status_code)\r\n{\r\nint idx = 0;\r\nwhile (nt_errs[idx].nt_errstr != NULL) {\r\nif (((nt_errs[idx].nt_errcode) & 0xFFFFFF) ==\r\n(status_code & 0xFFFFFF)) {\r\nprintk(KERN_NOTICE "Status code returned 0x%08x %s\n",\r\nstatus_code, nt_errs[idx].nt_errstr);\r\n}\r\nidx++;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nntstatus_to_dos(__u32 ntstatus, __u8 *eclass, __u16 *ecode)\r\n{\r\nint i;\r\nif (ntstatus == 0) {\r\n*eclass = 0;\r\n*ecode = 0;\r\nreturn;\r\n}\r\nfor (i = 0; ntstatus_to_dos_map[i].ntstatus; i++) {\r\nif (ntstatus == ntstatus_to_dos_map[i].ntstatus) {\r\n*eclass = ntstatus_to_dos_map[i].dos_class;\r\n*ecode = ntstatus_to_dos_map[i].dos_code;\r\nreturn;\r\n}\r\n}\r\n*eclass = ERRHRD;\r\n*ecode = ERRgeneral;\r\n}\r\nint\r\nmap_smb_to_linux_error(char *buf, bool logErr)\r\n{\r\nstruct smb_hdr *smb = (struct smb_hdr *)buf;\r\nunsigned int i;\r\nint rc = -EIO;\r\n__u8 smberrclass;\r\n__u16 smberrcode;\r\nif (smb->Status.CifsError == 0)\r\nreturn 0;\r\nif (smb->Flags2 & SMBFLG2_ERR_STATUS) {\r\n__u32 err = le32_to_cpu(smb->Status.CifsError);\r\nif (logErr && (err != (NT_STATUS_MORE_PROCESSING_REQUIRED)))\r\ncifs_print_status(err);\r\nelse if (cifsFYI & CIFS_RC)\r\ncifs_print_status(err);\r\nntstatus_to_dos(err, &smberrclass, &smberrcode);\r\n} else {\r\nsmberrclass = smb->Status.DosError.ErrorClass;\r\nsmberrcode = le16_to_cpu(smb->Status.DosError.Error);\r\n}\r\nif (smberrclass == ERRDOS) {\r\nfor (i = 0;\r\ni <\r\nsizeof(mapping_table_ERRDOS) /\r\nsizeof(struct smb_to_posix_error); i++) {\r\nif (mapping_table_ERRDOS[i].smb_err == 0)\r\nbreak;\r\nelse if (mapping_table_ERRDOS[i].smb_err ==\r\nsmberrcode) {\r\nrc = mapping_table_ERRDOS[i].posix_code;\r\nbreak;\r\n}\r\n}\r\n} else if (smberrclass == ERRSRV) {\r\nfor (i = 0;\r\ni <\r\nsizeof(mapping_table_ERRSRV) /\r\nsizeof(struct smb_to_posix_error); i++) {\r\nif (mapping_table_ERRSRV[i].smb_err == 0)\r\nbreak;\r\nelse if (mapping_table_ERRSRV[i].smb_err ==\r\nsmberrcode) {\r\nrc = mapping_table_ERRSRV[i].posix_code;\r\nbreak;\r\n}\r\n}\r\n}\r\ncifs_dbg(FYI, "Mapping smb error code 0x%x to POSIX err %d\n",\r\nle32_to_cpu(smb->Status.CifsError), rc);\r\nreturn rc;\r\n}\r\nunsigned int\r\nsmbCalcSize(void *buf)\r\n{\r\nstruct smb_hdr *ptr = (struct smb_hdr *)buf;\r\nreturn (sizeof(struct smb_hdr) + (2 * ptr->WordCount) +\r\n2 + get_bcc(ptr));\r\n}\r\nstruct timespec\r\ncifs_NTtimeToUnix(__le64 ntutc)\r\n{\r\nstruct timespec ts;\r\nu64 t;\r\nt = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;\r\nts.tv_nsec = do_div(t, 10000000) * 100;\r\nts.tv_sec = t;\r\nreturn ts;\r\n}\r\nu64\r\ncifs_UnixTimeToNT(struct timespec t)\r\n{\r\nreturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\r\n}\r\nstruct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)\r\n{\r\nstruct timespec ts;\r\nint sec, min, days, month, year;\r\nu16 date = le16_to_cpu(le_date);\r\nu16 time = le16_to_cpu(le_time);\r\nSMB_TIME *st = (SMB_TIME *)&time;\r\nSMB_DATE *sd = (SMB_DATE *)&date;\r\ncifs_dbg(FYI, "date %d time %d\n", date, time);\r\nsec = 2 * st->TwoSeconds;\r\nmin = st->Minutes;\r\nif ((sec > 59) || (min > 59))\r\ncifs_dbg(VFS, "illegal time min %d sec %d\n", min, sec);\r\nsec += (min * 60);\r\nsec += 60 * 60 * st->Hours;\r\nif (st->Hours > 24)\r\ncifs_dbg(VFS, "illegal hours %d\n", st->Hours);\r\ndays = sd->Day;\r\nmonth = sd->Month;\r\nif ((days > 31) || (month > 12)) {\r\ncifs_dbg(VFS, "illegal date, month %d day: %d\n", month, days);\r\nif (month > 12)\r\nmonth = 12;\r\n}\r\nmonth -= 1;\r\ndays += total_days_of_prev_months[month];\r\ndays += 3652;\r\nyear = sd->Year;\r\ndays += year * 365;\r\ndays += (year/4);\r\nif (year >= 120)\r\ndays = days - 1;\r\nif (year != 120)\r\ndays -= ((year & 0x03) == 0) && (month < 2 ? 1 : 0);\r\nsec += 24 * 60 * 60 * days;\r\nts.tv_sec = sec + offset;\r\nts.tv_nsec = 0;\r\nreturn ts;\r\n}
