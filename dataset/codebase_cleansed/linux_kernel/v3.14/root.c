static int proc_test_super(struct super_block *sb, void *data)\r\n{\r\nreturn sb->s_fs_info == data;\r\n}\r\nstatic int proc_set_super(struct super_block *sb, void *data)\r\n{\r\nint err = set_anon_super(sb, NULL);\r\nif (!err) {\r\nstruct pid_namespace *ns = (struct pid_namespace *)data;\r\nsb->s_fs_info = get_pid_ns(ns);\r\n}\r\nreturn err;\r\n}\r\nstatic int proc_parse_options(char *options, struct pid_namespace *pid)\r\n{\r\nchar *p;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint option;\r\nif (!options)\r\nreturn 1;\r\nwhile ((p = strsep(&options, ",")) != NULL) {\r\nint token;\r\nif (!*p)\r\ncontinue;\r\nargs[0].to = args[0].from = NULL;\r\ntoken = match_token(p, tokens, args);\r\nswitch (token) {\r\ncase Opt_gid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\npid->pid_gid = make_kgid(current_user_ns(), option);\r\nbreak;\r\ncase Opt_hidepid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\nif (option < 0 || option > 2) {\r\npr_err("proc: hidepid value must be between 0 and 2.\n");\r\nreturn 0;\r\n}\r\npid->hide_pid = option;\r\nbreak;\r\ndefault:\r\npr_err("proc: unrecognized mount option \"%s\" "\r\n"or missing value\n", p);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint proc_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nstruct pid_namespace *pid = sb->s_fs_info;\r\nreturn !proc_parse_options(data, pid);\r\n}\r\nstatic struct dentry *proc_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nint err;\r\nstruct super_block *sb;\r\nstruct pid_namespace *ns;\r\nchar *options;\r\nif (flags & MS_KERNMOUNT) {\r\nns = (struct pid_namespace *)data;\r\noptions = NULL;\r\n} else {\r\nns = task_active_pid_ns(current);\r\noptions = data;\r\nif (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))\r\nreturn ERR_PTR(-EPERM);\r\nif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\r\nreturn ERR_PTR(-EPERM);\r\n}\r\nsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\r\nif (IS_ERR(sb))\r\nreturn ERR_CAST(sb);\r\nif (!proc_parse_options(options, ns)) {\r\ndeactivate_locked_super(sb);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!sb->s_root) {\r\nerr = proc_fill_super(sb);\r\nif (err) {\r\ndeactivate_locked_super(sb);\r\nreturn ERR_PTR(err);\r\n}\r\nsb->s_flags |= MS_ACTIVE;\r\n}\r\nreturn dget(sb->s_root);\r\n}\r\nstatic void proc_kill_sb(struct super_block *sb)\r\n{\r\nstruct pid_namespace *ns;\r\nns = (struct pid_namespace *)sb->s_fs_info;\r\nif (ns->proc_self)\r\ndput(ns->proc_self);\r\nkill_anon_super(sb);\r\nput_pid_ns(ns);\r\n}\r\nvoid __init proc_root_init(void)\r\n{\r\nint err;\r\nproc_init_inodecache();\r\nerr = register_filesystem(&proc_fs_type);\r\nif (err)\r\nreturn;\r\nproc_self_init();\r\nproc_symlink("mounts", NULL, "self/mounts");\r\nproc_net_init();\r\n#ifdef CONFIG_SYSVIPC\r\nproc_mkdir("sysvipc", NULL);\r\n#endif\r\nproc_mkdir("fs", NULL);\r\nproc_mkdir("driver", NULL);\r\nproc_mkdir("fs/nfsd", NULL);\r\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\r\nproc_mkdir("openprom", NULL);\r\n#endif\r\nproc_tty_init();\r\n#ifdef CONFIG_PROC_DEVICETREE\r\nproc_device_tree_init();\r\n#endif\r\nproc_mkdir("bus", NULL);\r\nproc_sys_init();\r\n}\r\nstatic int proc_root_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat\r\n)\r\n{\r\ngeneric_fillattr(dentry->d_inode, stat);\r\nstat->nlink = proc_root.nlink + nr_processes();\r\nreturn 0;\r\n}\r\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\r\n{\r\nif (!proc_lookup(dir, dentry, flags))\r\nreturn NULL;\r\nreturn proc_pid_lookup(dir, dentry, flags);\r\n}\r\nstatic int proc_root_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nif (ctx->pos < FIRST_PROCESS_ENTRY) {\r\nint error = proc_readdir(file, ctx);\r\nif (unlikely(error <= 0))\r\nreturn error;\r\nctx->pos = FIRST_PROCESS_ENTRY;\r\n}\r\nreturn proc_pid_readdir(file, ctx);\r\n}\r\nint pid_ns_prepare_proc(struct pid_namespace *ns)\r\n{\r\nstruct vfsmount *mnt;\r\nmnt = kern_mount_data(&proc_fs_type, ns);\r\nif (IS_ERR(mnt))\r\nreturn PTR_ERR(mnt);\r\nns->proc_mnt = mnt;\r\nreturn 0;\r\n}\r\nvoid pid_ns_release_proc(struct pid_namespace *ns)\r\n{\r\nkern_unmount(ns->proc_mnt);\r\n}
