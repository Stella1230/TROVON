void olpc_analog_input(struct snd_ac97 *ac97, int on)\r\n{\r\nint err;\r\nif (!machine_is_olpc())\r\nreturn;\r\nerr = snd_ac97_update_bits(ac97, AC97_AD_TEST2,\r\n1 << AC97_AD_HPFD_SHIFT, on << AC97_AD_HPFD_SHIFT);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "setting High Pass Filter - %d\n", err);\r\nreturn;\r\n}\r\ngpio_set_value(OLPC_GPIO_MIC_AC, on);\r\n}\r\nvoid olpc_mic_bias(struct snd_ac97 *ac97, int on)\r\n{\r\nint err;\r\nif (!machine_is_olpc())\r\nreturn;\r\non = on ? 0 : 1;\r\nerr = snd_ac97_update_bits(ac97, AC97_AD_MISC,\r\n1 << AC97_AD_VREFD_SHIFT, on << AC97_AD_VREFD_SHIFT);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "setting MIC Bias - %d\n", err);\r\n}\r\nstatic int olpc_dc_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int olpc_dc_get(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *v)\r\n{\r\nv->value.integer.value[0] = gpio_get_value(OLPC_GPIO_MIC_AC);\r\nreturn 0;\r\n}\r\nstatic int olpc_dc_put(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *v)\r\n{\r\nstruct cs5535audio *cs5535au = snd_kcontrol_chip(kctl);\r\nolpc_analog_input(cs5535au->ac97, v->value.integer.value[0]);\r\nreturn 1;\r\n}\r\nstatic int olpc_mic_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int olpc_mic_get(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *v)\r\n{\r\nstruct cs5535audio *cs5535au = snd_kcontrol_chip(kctl);\r\nstruct snd_ac97 *ac97 = cs5535au->ac97;\r\nint i;\r\ni = (snd_ac97_read(ac97, AC97_AD_MISC) >> AC97_AD_VREFD_SHIFT) & 0x1;\r\nv->value.integer.value[0] = i ? 0 : 1;\r\nreturn 0;\r\n}\r\nstatic int olpc_mic_put(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *v)\r\n{\r\nstruct cs5535audio *cs5535au = snd_kcontrol_chip(kctl);\r\nolpc_mic_bias(cs5535au->ac97, v->value.integer.value[0]);\r\nreturn 1;\r\n}\r\nvoid olpc_prequirks(struct snd_card *card,\r\nstruct snd_ac97_template *ac97)\r\n{\r\nif (!machine_is_olpc())\r\nreturn;\r\nif (olpc_board_at_least(olpc_board_pre(0xb3)))\r\nac97->scaps |= AC97_SCAP_INV_EAPD;\r\n}\r\nint olpc_quirks(struct snd_card *card, struct snd_ac97 *ac97)\r\n{\r\nstruct snd_ctl_elem_id elem;\r\nint i, err;\r\nif (!machine_is_olpc())\r\nreturn 0;\r\nif (gpio_request(OLPC_GPIO_MIC_AC, DRV_NAME)) {\r\nprintk(KERN_ERR DRV_NAME ": unable to allocate MIC GPIO\n");\r\nreturn -EIO;\r\n}\r\ngpio_direction_output(OLPC_GPIO_MIC_AC, 0);\r\nmemset(&elem, 0, sizeof(elem));\r\nelem.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrlcpy(elem.name, "High Pass Filter Enable", sizeof(elem.name));\r\nsnd_ctl_remove_id(card, &elem);\r\nmemset(&elem, 0, sizeof(elem));\r\nelem.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrlcpy(elem.name, "V_REFOUT Enable", sizeof(elem.name));\r\nsnd_ctl_remove_id(card, &elem);\r\nfor (i = 0; i < ARRAY_SIZE(olpc_cs5535audio_ctls); i++) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&olpc_cs5535audio_ctls[i],\r\nac97->private_data));\r\nif (err < 0) {\r\ngpio_free(OLPC_GPIO_MIC_AC);\r\nreturn err;\r\n}\r\n}\r\nolpc_mic_bias(ac97, 0);\r\nreturn 0;\r\n}\r\nvoid olpc_quirks_cleanup(void)\r\n{\r\ngpio_free(OLPC_GPIO_MIC_AC);\r\n}
