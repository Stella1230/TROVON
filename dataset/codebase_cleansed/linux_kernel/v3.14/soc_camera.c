int soc_camera_power_on(struct device *dev, struct soc_camera_subdev_desc *ssdd,\r\nstruct v4l2_clk *clk)\r\n{\r\nint ret;\r\nbool clock_toggle;\r\nif (clk && (!ssdd->unbalanced_power ||\r\n!test_and_set_bit(0, &ssdd->clock_state))) {\r\nret = v4l2_clk_enable(clk);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nclock_toggle = true;\r\n} else {\r\nclock_toggle = false;\r\n}\r\nret = regulator_bulk_enable(ssdd->sd_pdata.num_regulators,\r\nssdd->sd_pdata.regulators);\r\nif (ret < 0) {\r\ndev_err(dev, "Cannot enable regulators\n");\r\ngoto eregenable;\r\n}\r\nif (ssdd->power) {\r\nret = ssdd->power(dev, 1);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"Platform failed to power-on the camera.\n");\r\ngoto epwron;\r\n}\r\n}\r\nreturn 0;\r\nepwron:\r\nregulator_bulk_disable(ssdd->sd_pdata.num_regulators,\r\nssdd->sd_pdata.regulators);\r\neregenable:\r\nif (clock_toggle)\r\nv4l2_clk_disable(clk);\r\nreturn ret;\r\n}\r\nint soc_camera_power_off(struct device *dev, struct soc_camera_subdev_desc *ssdd,\r\nstruct v4l2_clk *clk)\r\n{\r\nint ret = 0;\r\nint err;\r\nif (ssdd->power) {\r\nerr = ssdd->power(dev, 0);\r\nif (err < 0) {\r\ndev_err(dev,\r\n"Platform failed to power-off the camera.\n");\r\nret = err;\r\n}\r\n}\r\nerr = regulator_bulk_disable(ssdd->sd_pdata.num_regulators,\r\nssdd->sd_pdata.regulators);\r\nif (err < 0) {\r\ndev_err(dev, "Cannot disable regulators\n");\r\nret = ret ? : err;\r\n}\r\nif (clk && (!ssdd->unbalanced_power || test_and_clear_bit(0, &ssdd->clock_state)))\r\nv4l2_clk_disable(clk);\r\nreturn ret;\r\n}\r\nint soc_camera_power_init(struct device *dev, struct soc_camera_subdev_desc *ssdd)\r\n{\r\nreturn devm_regulator_bulk_get(dev, ssdd->sd_pdata.num_regulators,\r\nssdd->sd_pdata.regulators);\r\n}\r\nstatic int __soc_camera_power_on(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nint ret;\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int __soc_camera_power_off(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nint ret;\r\nret = v4l2_subdev_call(sd, core, s_power, 0);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nconst struct soc_camera_format_xlate *soc_camera_xlate_by_fourcc(\r\nstruct soc_camera_device *icd, unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < icd->num_user_formats; i++)\r\nif (icd->user_formats[i].host_fmt->fourcc == fourcc)\r\nreturn icd->user_formats + i;\r\nreturn NULL;\r\n}\r\nunsigned long soc_camera_apply_board_flags(struct soc_camera_subdev_desc *ssdd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nunsigned long f, flags = cfg->flags;\r\nif (ssdd->flags & SOCAM_SENSOR_INVERT_HSYNC) {\r\nf = flags & (V4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_LOW);\r\nif (f == V4L2_MBUS_HSYNC_ACTIVE_HIGH || f == V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nflags ^= V4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif (ssdd->flags & SOCAM_SENSOR_INVERT_VSYNC) {\r\nf = flags & (V4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW);\r\nif (f == V4L2_MBUS_VSYNC_ACTIVE_HIGH || f == V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nflags ^= V4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif (ssdd->flags & SOCAM_SENSOR_INVERT_PCLK) {\r\nf = flags & (V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING);\r\nif (f == V4L2_MBUS_PCLK_SAMPLE_RISING || f == V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nflags ^= V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\nreturn flags;\r\n}\r\nstatic int soc_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\ndev_dbg(icd->pdev, "TRY_FMT(%c%c%c%c, %ux%u)\n",\r\npixfmtstr(pix->pixelformat), pix->width, pix->height);\r\nif (pix->pixelformat != V4L2_PIX_FMT_JPEG &&\r\n!(ici->capabilities & SOCAM_HOST_CAP_STRIDE)) {\r\npix->bytesperline = 0;\r\npix->sizeimage = 0;\r\n}\r\nret = ici->ops->try_fmt(icd, f);\r\nif (ret < 0)\r\nreturn ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate)\r\nreturn -EINVAL;\r\nret = soc_mbus_bytes_per_line(pix->width, xlate->host_fmt);\r\nif (ret < 0)\r\nreturn ret;\r\npix->bytesperline = max_t(u32, pix->bytesperline, ret);\r\nret = soc_mbus_image_size(xlate->host_fmt, pix->bytesperline,\r\npix->height);\r\nif (ret < 0)\r\nreturn ret;\r\npix->sizeimage = max_t(u32, pix->sizeimage, ret);\r\nreturn 0;\r\n}\r\nstatic int soc_camera_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nWARN_ON(priv != file->private_data);\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn soc_camera_try_fmt(icd, f);\r\n}\r\nstatic int soc_camera_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(inp->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int soc_camera_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int soc_camera_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int soc_camera_s_std(struct file *file, void *priv, v4l2_std_id a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, core, s_std, a);\r\n}\r\nstatic int soc_camera_g_std(struct file *file, void *priv, v4l2_std_id *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, core, g_std, a);\r\n}\r\nstatic int soc_camera_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nreturn ici->ops->enum_framesizes(icd, fsize);\r\n}\r\nstatic int soc_camera_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint ret;\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nif (icd->streamer && icd->streamer != file)\r\nreturn -EBUSY;\r\nif (ici->ops->init_videobuf) {\r\nret = videobuf_reqbufs(&icd->vb_vidq, p);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ici->ops->reqbufs(icd, p);\r\n} else {\r\nret = vb2_reqbufs(&icd->vb2_vidq, p);\r\n}\r\nif (!ret && !icd->streamer)\r\nicd->streamer = file;\r\nreturn ret;\r\n}\r\nstatic int soc_camera_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nif (ici->ops->init_videobuf)\r\nreturn videobuf_querybuf(&icd->vb_vidq, p);\r\nelse\r\nreturn vb2_querybuf(&icd->vb2_vidq, p);\r\n}\r\nstatic int soc_camera_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nif (icd->streamer != file)\r\nreturn -EBUSY;\r\nif (ici->ops->init_videobuf)\r\nreturn videobuf_qbuf(&icd->vb_vidq, p);\r\nelse\r\nreturn vb2_qbuf(&icd->vb2_vidq, p);\r\n}\r\nstatic int soc_camera_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nif (icd->streamer != file)\r\nreturn -EBUSY;\r\nif (ici->ops->init_videobuf)\r\nreturn videobuf_dqbuf(&icd->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\nelse\r\nreturn vb2_dqbuf(&icd->vb2_vidq, p, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int soc_camera_create_bufs(struct file *file, void *priv,\r\nstruct v4l2_create_buffers *create)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (ici->ops->init_videobuf)\r\nreturn -EINVAL;\r\nelse\r\nreturn vb2_create_bufs(&icd->vb2_vidq, create);\r\n}\r\nstatic int soc_camera_prepare_buf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (ici->ops->init_videobuf)\r\nreturn -EINVAL;\r\nelse\r\nreturn vb2_prepare_buf(&icd->vb2_vidq, b);\r\n}\r\nstatic int soc_camera_init_user_formats(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nunsigned int i, fmts = 0, raw_fmts = 0;\r\nint ret;\r\nenum v4l2_mbus_pixelcode code;\r\nwhile (!v4l2_subdev_call(sd, video, enum_mbus_fmt, raw_fmts, &code))\r\nraw_fmts++;\r\nif (!ici->ops->get_formats)\r\nfmts = raw_fmts;\r\nelse\r\nfor (i = 0; i < raw_fmts; i++) {\r\nret = ici->ops->get_formats(icd, i, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nfmts += ret;\r\n}\r\nif (!fmts)\r\nreturn -ENXIO;\r\nicd->user_formats =\r\nvmalloc(fmts * sizeof(struct soc_camera_format_xlate));\r\nif (!icd->user_formats)\r\nreturn -ENOMEM;\r\ndev_dbg(icd->pdev, "Found %d supported formats.\n", fmts);\r\nfmts = 0;\r\nfor (i = 0; i < raw_fmts; i++)\r\nif (!ici->ops->get_formats) {\r\nv4l2_subdev_call(sd, video, enum_mbus_fmt, i, &code);\r\nicd->user_formats[fmts].host_fmt =\r\nsoc_mbus_get_fmtdesc(code);\r\nif (icd->user_formats[fmts].host_fmt)\r\nicd->user_formats[fmts++].code = code;\r\n} else {\r\nret = ici->ops->get_formats(icd, i,\r\n&icd->user_formats[fmts]);\r\nif (ret < 0)\r\ngoto egfmt;\r\nfmts += ret;\r\n}\r\nicd->num_user_formats = fmts;\r\nicd->current_fmt = &icd->user_formats[0];\r\nreturn 0;\r\negfmt:\r\nvfree(icd->user_formats);\r\nreturn ret;\r\n}\r\nstatic void soc_camera_free_user_formats(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (ici->ops->put_formats)\r\nici->ops->put_formats(icd);\r\nicd->current_fmt = NULL;\r\nicd->num_user_formats = 0;\r\nvfree(icd->user_formats);\r\nicd->user_formats = NULL;\r\n}\r\nstatic int soc_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\ndev_dbg(icd->pdev, "S_FMT(%c%c%c%c, %ux%u)\n",\r\npixfmtstr(pix->pixelformat), pix->width, pix->height);\r\nret = soc_camera_try_fmt(icd, f);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ici->ops->set_fmt(icd, f);\r\nif (ret < 0) {\r\nreturn ret;\r\n} else if (!icd->current_fmt ||\r\nicd->current_fmt->host_fmt->fourcc != pix->pixelformat) {\r\ndev_err(icd->pdev,\r\n"Host driver hasn't set up current format correctly!\n");\r\nreturn -EINVAL;\r\n}\r\nicd->user_width = pix->width;\r\nicd->user_height = pix->height;\r\nicd->bytesperline = pix->bytesperline;\r\nicd->sizeimage = pix->sizeimage;\r\nicd->colorspace = pix->colorspace;\r\nicd->field = pix->field;\r\nif (ici->ops->init_videobuf)\r\nicd->vb_vidq.field = pix->field;\r\ndev_dbg(icd->pdev, "set width: %d height: %d\n",\r\nicd->user_width, icd->user_height);\r\nreturn ici->ops->set_bus_param(icd);\r\n}\r\nstatic int soc_camera_add_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nint ret;\r\nif (ici->icd)\r\nreturn -EBUSY;\r\nif (!icd->clk) {\r\nmutex_lock(&ici->clk_lock);\r\nret = ici->ops->clock_start(ici);\r\nmutex_unlock(&ici->clk_lock);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (ici->ops->add) {\r\nret = ici->ops->add(icd);\r\nif (ret < 0)\r\ngoto eadd;\r\n}\r\nici->icd = icd;\r\nreturn 0;\r\neadd:\r\nif (!icd->clk) {\r\nmutex_lock(&ici->clk_lock);\r\nici->ops->clock_stop(ici);\r\nmutex_unlock(&ici->clk_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void soc_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (WARN_ON(icd != ici->icd))\r\nreturn;\r\nif (ici->ops->remove)\r\nici->ops->remove(icd);\r\nif (!icd->clk) {\r\nmutex_lock(&ici->clk_lock);\r\nici->ops->clock_stop(ici);\r\nmutex_unlock(&ici->clk_lock);\r\n}\r\nici->icd = NULL;\r\n}\r\nstatic int soc_camera_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct soc_camera_device *icd;\r\nstruct soc_camera_host *ici;\r\nint ret;\r\nif (mutex_lock_interruptible(&list_lock))\r\nreturn -ERESTARTSYS;\r\nif (!vdev || !video_is_registered(vdev)) {\r\nmutex_unlock(&list_lock);\r\nreturn -ENODEV;\r\n}\r\nicd = video_get_drvdata(vdev);\r\nici = to_soc_camera_host(icd->parent);\r\nret = try_module_get(ici->ops->owner) ? 0 : -ENODEV;\r\nmutex_unlock(&list_lock);\r\nif (ret < 0) {\r\ndev_err(icd->pdev, "Couldn't lock capture bus driver.\n");\r\nreturn ret;\r\n}\r\nif (!to_soc_camera_control(icd)) {\r\nret = -ENODEV;\r\ngoto econtrol;\r\n}\r\nif (mutex_lock_interruptible(&ici->host_lock)) {\r\nret = -ERESTARTSYS;\r\ngoto elockhost;\r\n}\r\nicd->use_count++;\r\nif (icd->use_count == 1) {\r\nstruct soc_camera_desc *sdesc = to_soc_camera_desc(icd);\r\nstruct v4l2_format f = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.fmt.pix = {\r\n.width = icd->user_width,\r\n.height = icd->user_height,\r\n.field = icd->field,\r\n.colorspace = icd->colorspace,\r\n.pixelformat =\r\nicd->current_fmt->host_fmt->fourcc,\r\n},\r\n};\r\nif (sdesc->subdev_desc.reset)\r\nsdesc->subdev_desc.reset(icd->pdev);\r\nret = soc_camera_add_device(icd);\r\nif (ret < 0) {\r\ndev_err(icd->pdev, "Couldn't activate the camera: %d\n", ret);\r\ngoto eiciadd;\r\n}\r\nret = __soc_camera_power_on(icd);\r\nif (ret < 0)\r\ngoto epower;\r\npm_runtime_enable(&icd->vdev->dev);\r\nret = pm_runtime_resume(&icd->vdev->dev);\r\nif (ret < 0 && ret != -ENOSYS)\r\ngoto eresume;\r\nret = soc_camera_set_fmt(icd, &f);\r\nif (ret < 0)\r\ngoto esfmt;\r\nif (ici->ops->init_videobuf) {\r\nici->ops->init_videobuf(&icd->vb_vidq, icd);\r\n} else {\r\nret = ici->ops->init_videobuf2(&icd->vb2_vidq, icd);\r\nif (ret < 0)\r\ngoto einitvb;\r\n}\r\nv4l2_ctrl_handler_setup(&icd->ctrl_handler);\r\n}\r\nmutex_unlock(&ici->host_lock);\r\nfile->private_data = icd;\r\ndev_dbg(icd->pdev, "camera device open\n");\r\nreturn 0;\r\neinitvb:\r\nesfmt:\r\npm_runtime_disable(&icd->vdev->dev);\r\neresume:\r\n__soc_camera_power_off(icd);\r\nepower:\r\nsoc_camera_remove_device(icd);\r\neiciadd:\r\nicd->use_count--;\r\nmutex_unlock(&ici->host_lock);\r\nelockhost:\r\necontrol:\r\nmodule_put(ici->ops->owner);\r\nreturn ret;\r\n}\r\nstatic int soc_camera_close(struct file *file)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nmutex_lock(&ici->host_lock);\r\nicd->use_count--;\r\nif (!icd->use_count) {\r\npm_runtime_suspend(&icd->vdev->dev);\r\npm_runtime_disable(&icd->vdev->dev);\r\nif (ici->ops->init_videobuf2)\r\nvb2_queue_release(&icd->vb2_vidq);\r\n__soc_camera_power_off(icd);\r\nsoc_camera_remove_device(icd);\r\n}\r\nif (icd->streamer == file)\r\nicd->streamer = NULL;\r\nmutex_unlock(&ici->host_lock);\r\nmodule_put(ici->ops->owner);\r\ndev_dbg(icd->pdev, "camera device close\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t soc_camera_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\ndev_dbg(icd->pdev, "read called, buf %p\n", buf);\r\nif (ici->ops->init_videobuf2 && icd->vb2_vidq.io_modes & VB2_READ)\r\nreturn vb2_read(&icd->vb2_vidq, buf, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\ndev_err(icd->pdev, "camera device read not implemented\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int soc_camera_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nint err;\r\ndev_dbg(icd->pdev, "mmap called, vma=0x%08lx\n", (unsigned long)vma);\r\nif (icd->streamer != file)\r\nreturn -EBUSY;\r\nif (mutex_lock_interruptible(&ici->host_lock))\r\nreturn -ERESTARTSYS;\r\nif (ici->ops->init_videobuf)\r\nerr = videobuf_mmap_mapper(&icd->vb_vidq, vma);\r\nelse\r\nerr = vb2_mmap(&icd->vb2_vidq, vma);\r\nmutex_unlock(&ici->host_lock);\r\ndev_dbg(icd->pdev, "vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,\r\nerr);\r\nreturn err;\r\n}\r\nstatic unsigned int soc_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nunsigned res = POLLERR;\r\nif (icd->streamer != file)\r\nreturn POLLERR;\r\nmutex_lock(&ici->host_lock);\r\nif (ici->ops->init_videobuf && list_empty(&icd->vb_vidq.stream))\r\ndev_err(icd->pdev, "Trying to poll with no queued buffers!\n");\r\nelse\r\nres = ici->ops->poll(file, pt);\r\nmutex_unlock(&ici->host_lock);\r\nreturn res;\r\n}\r\nvoid soc_camera_lock(struct vb2_queue *vq)\r\n{\r\nstruct soc_camera_device *icd = vb2_get_drv_priv(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nmutex_lock(&ici->host_lock);\r\n}\r\nvoid soc_camera_unlock(struct vb2_queue *vq)\r\n{\r\nstruct soc_camera_device *icd = vb2_get_drv_priv(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nmutex_unlock(&ici->host_lock);\r\n}\r\nstatic int soc_camera_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nint ret;\r\nWARN_ON(priv != file->private_data);\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev_warn(icd->pdev, "Wrong buf-type %d\n", f->type);\r\nreturn -EINVAL;\r\n}\r\nif (icd->streamer && icd->streamer != file)\r\nreturn -EBUSY;\r\nif (is_streaming(to_soc_camera_host(icd->parent), icd)) {\r\ndev_err(icd->pdev, "S_FMT denied: queue initialised\n");\r\nreturn -EBUSY;\r\n}\r\nret = soc_camera_set_fmt(icd, f);\r\nif (!ret && !icd->streamer)\r\nicd->streamer = file;\r\nreturn ret;\r\n}\r\nstatic int soc_camera_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nconst struct soc_mbus_pixelfmt *format;\r\nWARN_ON(priv != file->private_data);\r\nif (f->index >= icd->num_user_formats)\r\nreturn -EINVAL;\r\nformat = icd->user_formats[f->index].host_fmt;\r\nif (format->name)\r\nstrlcpy(f->description, format->name, sizeof(f->description));\r\nf->pixelformat = format->fourcc;\r\nreturn 0;\r\n}\r\nstatic int soc_camera_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nWARN_ON(priv != file->private_data);\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\npix->width = icd->user_width;\r\npix->height = icd->user_height;\r\npix->bytesperline = icd->bytesperline;\r\npix->sizeimage = icd->sizeimage;\r\npix->field = icd->field;\r\npix->pixelformat = icd->current_fmt->host_fmt->fourcc;\r\npix->colorspace = icd->colorspace;\r\ndev_dbg(icd->pdev, "current_fmt->fourcc: 0x%08x\n",\r\nicd->current_fmt->host_fmt->fourcc);\r\nreturn 0;\r\n}\r\nstatic int soc_camera_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nstrlcpy(cap->driver, ici->drv_name, sizeof(cap->driver));\r\nreturn ici->ops->querycap(ici, cap);\r\n}\r\nstatic int soc_camera_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nint ret;\r\nWARN_ON(priv != file->private_data);\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (icd->streamer != file)\r\nreturn -EBUSY;\r\nif (ici->ops->init_videobuf)\r\nret = videobuf_streamon(&icd->vb_vidq);\r\nelse\r\nret = vb2_streamon(&icd->vb2_vidq, i);\r\nif (!ret)\r\nv4l2_subdev_call(sd, video, s_stream, 1);\r\nreturn ret;\r\n}\r\nstatic int soc_camera_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nWARN_ON(priv != file->private_data);\r\nif (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (icd->streamer != file)\r\nreturn -EBUSY;\r\nif (ici->ops->init_videobuf)\r\nvideobuf_streamoff(&icd->vb_vidq);\r\nelse\r\nvb2_streamoff(&icd->vb2_vidq, i);\r\nv4l2_subdev_call(sd, video, s_stream, 0);\r\nreturn 0;\r\n}\r\nstatic int soc_camera_cropcap(struct file *file, void *fh,\r\nstruct v4l2_cropcap *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nreturn ici->ops->cropcap(icd, a);\r\n}\r\nstatic int soc_camera_g_crop(struct file *file, void *fh,\r\nstruct v4l2_crop *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nint ret;\r\nret = ici->ops->get_crop(icd, a);\r\nreturn ret;\r\n}\r\nstatic int soc_camera_s_crop(struct file *file, void *fh,\r\nconst struct v4l2_crop *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nconst struct v4l2_rect *rect = &a->c;\r\nstruct v4l2_crop current_crop;\r\nint ret;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ndev_dbg(icd->pdev, "S_CROP(%ux%u@%u:%u)\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\ncurrent_crop.type = a->type;\r\nret = ici->ops->get_crop(icd, &current_crop);\r\nif (ret < 0) {\r\ndev_err(icd->pdev,\r\n"S_CROP denied: getting current crop failed\n");\r\n} else if ((a->c.width == current_crop.c.width &&\r\na->c.height == current_crop.c.height) ||\r\n!is_streaming(ici, icd)) {\r\nret = ici->ops->set_crop(icd, a);\r\n} else if (ici->ops->set_livecrop) {\r\nret = ici->ops->set_livecrop(icd, a);\r\n} else {\r\ndev_err(icd->pdev,\r\n"S_CROP denied: queue initialised and sizes differ\n");\r\nret = -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int soc_camera_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (!ici->ops->get_selection)\r\nreturn -ENOTTY;\r\nreturn ici->ops->get_selection(icd, s);\r\n}\r\nstatic int soc_camera_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nint ret;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\n(s->target != V4L2_SEL_TGT_COMPOSE &&\r\ns->target != V4L2_SEL_TGT_CROP))\r\nreturn -EINVAL;\r\nif (s->target == V4L2_SEL_TGT_COMPOSE) {\r\nif (is_streaming(ici, icd) &&\r\n(icd->user_width != s->r.width ||\r\nicd->user_height != s->r.height))\r\nreturn -EBUSY;\r\nif (icd->streamer && icd->streamer != file)\r\nreturn -EBUSY;\r\n}\r\nif (!ici->ops->set_selection)\r\nreturn -ENOTTY;\r\nret = ici->ops->set_selection(icd, s);\r\nif (!ret &&\r\ns->target == V4L2_SEL_TGT_COMPOSE) {\r\nicd->user_width = s->r.width;\r\nicd->user_height = s->r.height;\r\nif (!icd->streamer)\r\nicd->streamer = file;\r\n}\r\nreturn ret;\r\n}\r\nstatic int soc_camera_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (ici->ops->get_parm)\r\nreturn ici->ops->get_parm(icd, a);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int soc_camera_s_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nif (ici->ops->set_parm)\r\nreturn ici->ops->set_parm(icd, a);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void scan_add_host(struct soc_camera_host *ici)\r\n{\r\nstruct soc_camera_device *icd;\r\nmutex_lock(&list_lock);\r\nlist_for_each_entry(icd, &devices, list)\r\nif (icd->iface == ici->nr) {\r\nstruct soc_camera_desc *sdesc = to_soc_camera_desc(icd);\r\nstruct soc_camera_subdev_desc *ssdd = &sdesc->subdev_desc;\r\nif (ssdd->reset)\r\nssdd->reset(icd->pdev);\r\nicd->parent = ici->v4l2_dev.dev;\r\nsoc_camera_probe(ici, icd);\r\n}\r\nmutex_unlock(&list_lock);\r\n}\r\nstatic int soc_camera_clk_enable(struct v4l2_clk *clk)\r\n{\r\nstruct soc_camera_device *icd = clk->priv;\r\nstruct soc_camera_host *ici;\r\nint ret;\r\nif (!icd || !icd->parent)\r\nreturn -ENODEV;\r\nici = to_soc_camera_host(icd->parent);\r\nif (!try_module_get(ici->ops->owner))\r\nreturn -ENODEV;\r\nmutex_lock(&ici->clk_lock);\r\nret = ici->ops->clock_start(ici);\r\nmutex_unlock(&ici->clk_lock);\r\nreturn ret;\r\n}\r\nstatic void soc_camera_clk_disable(struct v4l2_clk *clk)\r\n{\r\nstruct soc_camera_device *icd = clk->priv;\r\nstruct soc_camera_host *ici;\r\nif (!icd || !icd->parent)\r\nreturn;\r\nici = to_soc_camera_host(icd->parent);\r\nmutex_lock(&ici->clk_lock);\r\nici->ops->clock_stop(ici);\r\nmutex_unlock(&ici->clk_lock);\r\nmodule_put(ici->ops->owner);\r\n}\r\nstatic int soc_camera_dyn_pdev(struct soc_camera_desc *sdesc,\r\nstruct soc_camera_async_client *sasc)\r\n{\r\nstruct platform_device *pdev;\r\nint ret, i;\r\nmutex_lock(&list_lock);\r\ni = find_first_zero_bit(device_map, MAP_MAX_NUM);\r\nif (i < MAP_MAX_NUM)\r\nset_bit(i, device_map);\r\nmutex_unlock(&list_lock);\r\nif (i >= MAP_MAX_NUM)\r\nreturn -ENOMEM;\r\npdev = platform_device_alloc("soc-camera-pdrv", i);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nret = platform_device_add_data(pdev, sdesc, sizeof(*sdesc));\r\nif (ret < 0) {\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nsasc->pdev = pdev;\r\nreturn 0;\r\n}\r\nstatic struct soc_camera_device *soc_camera_add_pdev(struct soc_camera_async_client *sasc)\r\n{\r\nstruct platform_device *pdev = sasc->pdev;\r\nint ret;\r\nret = platform_device_add(pdev);\r\nif (ret < 0 || !pdev->dev.driver)\r\nreturn NULL;\r\nreturn platform_get_drvdata(pdev);\r\n}\r\nstatic int soc_camera_probe_finish(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nsd->grp_id = soc_camera_grp_id(icd);\r\nv4l2_set_subdev_hostdata(sd, icd);\r\nret = v4l2_ctrl_add_handler(&icd->ctrl_handler, sd->ctrl_handler, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = soc_camera_add_device(icd);\r\nif (ret < 0) {\r\ndev_err(icd->pdev, "Couldn't activate the camera: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = soc_camera_init_user_formats(icd);\r\nif (ret < 0)\r\ngoto eusrfmt;\r\nicd->field = V4L2_FIELD_ANY;\r\nret = soc_camera_video_start(icd);\r\nif (ret < 0)\r\ngoto evidstart;\r\nif (!v4l2_subdev_call(sd, video, g_mbus_fmt, &mf)) {\r\nicd->user_width = mf.width;\r\nicd->user_height = mf.height;\r\nicd->colorspace = mf.colorspace;\r\nicd->field = mf.field;\r\n}\r\nsoc_camera_remove_device(icd);\r\nreturn 0;\r\nevidstart:\r\nsoc_camera_free_user_formats(icd);\r\neusrfmt:\r\nsoc_camera_remove_device(icd);\r\nreturn ret;\r\n}\r\nstatic int soc_camera_i2c_init(struct soc_camera_device *icd,\r\nstruct soc_camera_desc *sdesc)\r\n{\r\nstruct soc_camera_subdev_desc *ssdd;\r\nstruct i2c_client *client;\r\nstruct soc_camera_host *ici;\r\nstruct soc_camera_host_desc *shd = &sdesc->host_desc;\r\nstruct i2c_adapter *adap;\r\nstruct v4l2_subdev *subdev;\r\nchar clk_name[V4L2_SUBDEV_NAME_SIZE];\r\nint ret;\r\nif (icd->sasc) {\r\nreturn -EPROBE_DEFER;\r\n}\r\nici = to_soc_camera_host(icd->parent);\r\nadap = i2c_get_adapter(shd->i2c_adapter_id);\r\nif (!adap) {\r\ndev_err(icd->pdev, "Cannot get I2C adapter #%d. No driver?\n",\r\nshd->i2c_adapter_id);\r\nreturn -ENODEV;\r\n}\r\nssdd = kzalloc(sizeof(*ssdd), GFP_KERNEL);\r\nif (!ssdd) {\r\nret = -ENOMEM;\r\ngoto ealloc;\r\n}\r\nmemcpy(ssdd, &sdesc->subdev_desc, sizeof(*ssdd));\r\nssdd->sd_pdata.num_regulators = 0;\r\nssdd->sd_pdata.regulators = NULL;\r\nshd->board_info->platform_data = ssdd;\r\nsnprintf(clk_name, sizeof(clk_name), "%d-%04x",\r\nshd->i2c_adapter_id, shd->board_info->addr);\r\nicd->clk = v4l2_clk_register(&soc_camera_clk_ops, clk_name, "mclk", icd);\r\nif (IS_ERR(icd->clk)) {\r\nret = PTR_ERR(icd->clk);\r\ngoto eclkreg;\r\n}\r\nsubdev = v4l2_i2c_new_subdev_board(&ici->v4l2_dev, adap,\r\nshd->board_info, NULL);\r\nif (!subdev) {\r\nret = -ENODEV;\r\ngoto ei2cnd;\r\n}\r\nclient = v4l2_get_subdevdata(subdev);\r\nicd->control = &client->dev;\r\nreturn 0;\r\nei2cnd:\r\nv4l2_clk_unregister(icd->clk);\r\nicd->clk = NULL;\r\neclkreg:\r\nkfree(ssdd);\r\nealloc:\r\ni2c_put_adapter(adap);\r\nreturn ret;\r\n}\r\nstatic void soc_camera_i2c_free(struct soc_camera_device *icd)\r\n{\r\nstruct i2c_client *client =\r\nto_i2c_client(to_soc_camera_control(icd));\r\nstruct i2c_adapter *adap;\r\nstruct soc_camera_subdev_desc *ssdd;\r\nicd->control = NULL;\r\nif (icd->sasc)\r\nreturn;\r\nadap = client->adapter;\r\nssdd = client->dev.platform_data;\r\nv4l2_device_unregister_subdev(i2c_get_clientdata(client));\r\ni2c_unregister_device(client);\r\ni2c_put_adapter(adap);\r\nkfree(ssdd);\r\nv4l2_clk_unregister(icd->clk);\r\nicd->clk = NULL;\r\n}\r\nstatic int soc_camera_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct soc_camera_async_client *sasc = container_of(notifier,\r\nstruct soc_camera_async_client, notifier);\r\nstruct soc_camera_device *icd = platform_get_drvdata(sasc->pdev);\r\nif (asd == sasc->sensor && !WARN_ON(icd->control)) {\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (client) {\r\nstruct soc_camera_desc *sdesc = to_soc_camera_desc(icd);\r\nstruct soc_camera_subdev_desc *ssdd =\r\nsoc_camera_i2c_to_desc(client);\r\nif (ssdd) {\r\nmemcpy(&sdesc->subdev_desc, ssdd,\r\nsizeof(sdesc->subdev_desc));\r\nif (ssdd->reset)\r\nssdd->reset(icd->pdev);\r\n}\r\nicd->control = &client->dev;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void soc_camera_async_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *sd,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct soc_camera_async_client *sasc = container_of(notifier,\r\nstruct soc_camera_async_client, notifier);\r\nstruct soc_camera_device *icd = platform_get_drvdata(sasc->pdev);\r\nif (icd->clk) {\r\nv4l2_clk_unregister(icd->clk);\r\nicd->clk = NULL;\r\n}\r\n}\r\nstatic int soc_camera_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct soc_camera_async_client *sasc = container_of(notifier,\r\nstruct soc_camera_async_client, notifier);\r\nstruct soc_camera_device *icd = platform_get_drvdata(sasc->pdev);\r\nif (to_soc_camera_control(icd)) {\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nint ret;\r\nmutex_lock(&list_lock);\r\nret = soc_camera_probe(ici, icd);\r\nmutex_unlock(&list_lock);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_async_group(struct soc_camera_host *ici,\r\nstruct v4l2_async_subdev **asd, unsigned int size)\r\n{\r\nstruct soc_camera_async_subdev *sasd;\r\nstruct soc_camera_async_client *sasc;\r\nstruct soc_camera_device *icd;\r\nstruct soc_camera_desc sdesc = {.host_desc.bus_id = ici->nr,};\r\nchar clk_name[V4L2_SUBDEV_NAME_SIZE];\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < size; i++) {\r\nsasd = container_of(asd[i], struct soc_camera_async_subdev, asd);\r\nif (sasd->role == SOCAM_SUBDEV_DATA_SOURCE)\r\nbreak;\r\n}\r\nif (i >= size || asd[i]->match_type != V4L2_ASYNC_MATCH_I2C) {\r\ndev_err(ici->v4l2_dev.dev, "No I2C data source found!\n");\r\nreturn -ENODEV;\r\n}\r\nsasc = devm_kzalloc(ici->v4l2_dev.dev, sizeof(*sasc), GFP_KERNEL);\r\nif (!sasc)\r\nreturn -ENOMEM;\r\nsdesc.host_desc.board_info = ERR_PTR(-ENODATA);\r\nret = soc_camera_dyn_pdev(&sdesc, sasc);\r\nif (ret < 0)\r\nreturn ret;\r\nsasc->sensor = &sasd->asd;\r\nicd = soc_camera_add_pdev(sasc);\r\nif (!icd) {\r\nplatform_device_put(sasc->pdev);\r\nreturn -ENOMEM;\r\n}\r\nsasc->notifier.subdevs = asd;\r\nsasc->notifier.num_subdevs = size;\r\nsasc->notifier.bound = soc_camera_async_bound;\r\nsasc->notifier.unbind = soc_camera_async_unbind;\r\nsasc->notifier.complete = soc_camera_async_complete;\r\nicd->sasc = sasc;\r\nicd->parent = ici->v4l2_dev.dev;\r\nsnprintf(clk_name, sizeof(clk_name), "%d-%04x",\r\nsasd->asd.match.i2c.adapter_id, sasd->asd.match.i2c.address);\r\nicd->clk = v4l2_clk_register(&soc_camera_clk_ops, clk_name, "mclk", icd);\r\nif (IS_ERR(icd->clk)) {\r\nret = PTR_ERR(icd->clk);\r\ngoto eclkreg;\r\n}\r\nret = v4l2_async_notifier_register(&ici->v4l2_dev, &sasc->notifier);\r\nif (!ret)\r\nreturn 0;\r\nv4l2_clk_unregister(icd->clk);\r\neclkreg:\r\nicd->clk = NULL;\r\nplatform_device_unregister(sasc->pdev);\r\ndev_err(ici->v4l2_dev.dev, "group probe failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void scan_async_host(struct soc_camera_host *ici)\r\n{\r\nstruct v4l2_async_subdev **asd;\r\nint j;\r\nfor (j = 0, asd = ici->asd; ici->asd_sizes[j]; j++) {\r\nscan_async_group(ici, asd, ici->asd_sizes[j]);\r\nasd += ici->asd_sizes[j];\r\n}\r\n}\r\nstatic int soc_camera_probe(struct soc_camera_host *ici,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_desc *sdesc = to_soc_camera_desc(icd);\r\nstruct soc_camera_host_desc *shd = &sdesc->host_desc;\r\nstruct device *control = NULL;\r\nint ret;\r\ndev_info(icd->pdev, "Probing %s\n", dev_name(icd->pdev));\r\nret = v4l2_ctrl_handler_init(&icd->ctrl_handler, 16);\r\nif (ret < 0)\r\nreturn ret;\r\nret = video_dev_create(icd);\r\nif (ret < 0)\r\ngoto evdc;\r\nif (shd->board_info) {\r\nret = soc_camera_i2c_init(icd, sdesc);\r\nif (ret < 0 && ret != -EPROBE_DEFER)\r\ngoto eadd;\r\n} else if (!shd->add_device || !shd->del_device) {\r\nret = -EINVAL;\r\ngoto eadd;\r\n} else {\r\nmutex_lock(&ici->clk_lock);\r\nret = ici->ops->clock_start(ici);\r\nmutex_unlock(&ici->clk_lock);\r\nif (ret < 0)\r\ngoto eadd;\r\nif (shd->module_name)\r\nret = request_module(shd->module_name);\r\nret = shd->add_device(icd);\r\nif (ret < 0)\r\ngoto eadddev;\r\ncontrol = to_soc_camera_control(icd);\r\nif (!control || !control->driver || !dev_get_drvdata(control) ||\r\n!try_module_get(control->driver->owner)) {\r\nshd->del_device(icd);\r\nret = -ENODEV;\r\ngoto enodrv;\r\n}\r\n}\r\nmutex_lock(&ici->host_lock);\r\nret = soc_camera_probe_finish(icd);\r\nmutex_unlock(&ici->host_lock);\r\nif (ret < 0)\r\ngoto efinish;\r\nreturn 0;\r\nefinish:\r\nif (shd->board_info) {\r\nsoc_camera_i2c_free(icd);\r\n} else {\r\nshd->del_device(icd);\r\nmodule_put(control->driver->owner);\r\nenodrv:\r\neadddev:\r\nmutex_lock(&ici->clk_lock);\r\nici->ops->clock_stop(ici);\r\nmutex_unlock(&ici->clk_lock);\r\n}\r\neadd:\r\nvideo_device_release(icd->vdev);\r\nicd->vdev = NULL;\r\nif (icd->vdev) {\r\nvideo_device_release(icd->vdev);\r\nicd->vdev = NULL;\r\n}\r\nevdc:\r\nv4l2_ctrl_handler_free(&icd->ctrl_handler);\r\nreturn ret;\r\n}\r\nstatic int soc_camera_remove(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_desc *sdesc = to_soc_camera_desc(icd);\r\nstruct video_device *vdev = icd->vdev;\r\nv4l2_ctrl_handler_free(&icd->ctrl_handler);\r\nif (vdev) {\r\nvideo_unregister_device(vdev);\r\nicd->vdev = NULL;\r\n}\r\nif (sdesc->host_desc.board_info) {\r\nsoc_camera_i2c_free(icd);\r\n} else {\r\nstruct device *dev = to_soc_camera_control(icd);\r\nstruct device_driver *drv = dev ? dev->driver : NULL;\r\nif (drv) {\r\nsdesc->host_desc.del_device(icd);\r\nmodule_put(drv->owner);\r\n}\r\n}\r\nif (icd->num_user_formats)\r\nsoc_camera_free_user_formats(icd);\r\nif (icd->clk) {\r\nv4l2_clk_unregister(icd->clk);\r\nicd->clk = NULL;\r\n}\r\nif (icd->sasc)\r\nplatform_device_unregister(icd->sasc->pdev);\r\nreturn 0;\r\n}\r\nstatic int default_cropcap(struct soc_camera_device *icd,\r\nstruct v4l2_cropcap *a)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, cropcap, a);\r\n}\r\nstatic int default_g_crop(struct soc_camera_device *icd, struct v4l2_crop *a)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, g_crop, a);\r\n}\r\nstatic int default_s_crop(struct soc_camera_device *icd, const struct v4l2_crop *a)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, s_crop, a);\r\n}\r\nstatic int default_g_parm(struct soc_camera_device *icd,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, g_parm, parm);\r\n}\r\nstatic int default_s_parm(struct soc_camera_device *icd,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, s_parm, parm);\r\n}\r\nstatic int default_enum_framesizes(struct soc_camera_device *icd,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nint ret;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\n__u32 pixfmt = fsize->pixel_format;\r\nstruct v4l2_frmsizeenum fsize_mbus = *fsize;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate)\r\nreturn -EINVAL;\r\nfsize_mbus.pixel_format = xlate->code;\r\nret = v4l2_subdev_call(sd, video, enum_framesizes, &fsize_mbus);\r\nif (ret < 0)\r\nreturn ret;\r\n*fsize = fsize_mbus;\r\nfsize->pixel_format = pixfmt;\r\nreturn 0;\r\n}\r\nint soc_camera_host_register(struct soc_camera_host *ici)\r\n{\r\nstruct soc_camera_host *ix;\r\nint ret;\r\nif (!ici || !ici->ops ||\r\n!ici->ops->try_fmt ||\r\n!ici->ops->set_fmt ||\r\n!ici->ops->set_bus_param ||\r\n!ici->ops->querycap ||\r\n((!ici->ops->init_videobuf ||\r\n!ici->ops->reqbufs) &&\r\n!ici->ops->init_videobuf2) ||\r\n!ici->ops->clock_start ||\r\n!ici->ops->clock_stop ||\r\n!ici->ops->poll ||\r\n!ici->v4l2_dev.dev)\r\nreturn -EINVAL;\r\nif (!ici->ops->set_crop)\r\nici->ops->set_crop = default_s_crop;\r\nif (!ici->ops->get_crop)\r\nici->ops->get_crop = default_g_crop;\r\nif (!ici->ops->cropcap)\r\nici->ops->cropcap = default_cropcap;\r\nif (!ici->ops->set_parm)\r\nici->ops->set_parm = default_s_parm;\r\nif (!ici->ops->get_parm)\r\nici->ops->get_parm = default_g_parm;\r\nif (!ici->ops->enum_framesizes)\r\nici->ops->enum_framesizes = default_enum_framesizes;\r\nmutex_lock(&list_lock);\r\nlist_for_each_entry(ix, &hosts, list) {\r\nif (ix->nr == ici->nr) {\r\nret = -EBUSY;\r\ngoto edevreg;\r\n}\r\n}\r\nret = v4l2_device_register(ici->v4l2_dev.dev, &ici->v4l2_dev);\r\nif (ret < 0)\r\ngoto edevreg;\r\nlist_add_tail(&ici->list, &hosts);\r\nmutex_unlock(&list_lock);\r\nmutex_init(&ici->host_lock);\r\nmutex_init(&ici->clk_lock);\r\nif (ici->asd_sizes)\r\nscan_async_host(ici);\r\nelse\r\nscan_add_host(ici);\r\nreturn 0;\r\nedevreg:\r\nmutex_unlock(&list_lock);\r\nreturn ret;\r\n}\r\nvoid soc_camera_host_unregister(struct soc_camera_host *ici)\r\n{\r\nstruct soc_camera_device *icd, *tmp;\r\nstruct soc_camera_async_client *sasc;\r\nLIST_HEAD(notifiers);\r\nmutex_lock(&list_lock);\r\nlist_del(&ici->list);\r\nlist_for_each_entry(icd, &devices, list)\r\nif (icd->iface == ici->nr && icd->sasc) {\r\nget_device(icd->pdev);\r\nlist_add(&icd->sasc->list, &notifiers);\r\n}\r\nmutex_unlock(&list_lock);\r\nlist_for_each_entry(sasc, &notifiers, list) {\r\nv4l2_async_notifier_unregister(&sasc->notifier);\r\nput_device(&sasc->pdev->dev);\r\n}\r\nmutex_lock(&list_lock);\r\nlist_for_each_entry_safe(icd, tmp, &devices, list)\r\nif (icd->iface == ici->nr)\r\nsoc_camera_remove(icd);\r\nmutex_unlock(&list_lock);\r\nv4l2_device_unregister(&ici->v4l2_dev);\r\n}\r\nstatic int soc_camera_device_register(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_device *ix;\r\nint num = -1, i;\r\nmutex_lock(&list_lock);\r\nfor (i = 0; i < 256 && num < 0; i++) {\r\nnum = i;\r\nlist_for_each_entry(ix, &devices, list) {\r\nif (ix->iface == icd->iface && ix->devnum == i) {\r\nnum = -1;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (num < 0) {\r\nmutex_unlock(&list_lock);\r\nreturn -ENOMEM;\r\n}\r\nicd->devnum = num;\r\nicd->use_count = 0;\r\nicd->host_priv = NULL;\r\ni = to_platform_device(icd->pdev)->id;\r\nif (i < 0)\r\ni = 0;\r\nif (i >= MAP_MAX_NUM) {\r\nmutex_unlock(&list_lock);\r\nreturn -EBUSY;\r\n}\r\nset_bit(i, device_map);\r\nlist_add_tail(&icd->list, &devices);\r\nmutex_unlock(&list_lock);\r\nreturn 0;\r\n}\r\nstatic int video_dev_create(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct video_device *vdev = video_device_alloc();\r\nif (!vdev)\r\nreturn -ENOMEM;\r\nstrlcpy(vdev->name, ici->drv_name, sizeof(vdev->name));\r\nvdev->v4l2_dev = &ici->v4l2_dev;\r\nvdev->fops = &soc_camera_fops;\r\nvdev->ioctl_ops = &soc_camera_ioctl_ops;\r\nvdev->release = video_device_release;\r\nvdev->ctrl_handler = &icd->ctrl_handler;\r\nvdev->lock = &ici->host_lock;\r\nicd->vdev = vdev;\r\nreturn 0;\r\n}\r\nstatic int soc_camera_video_start(struct soc_camera_device *icd)\r\n{\r\nconst struct device_type *type = icd->vdev->dev.type;\r\nint ret;\r\nif (!icd->parent)\r\nreturn -ENODEV;\r\nvideo_set_drvdata(icd->vdev, icd);\r\nret = video_register_device(icd->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\ndev_err(icd->pdev, "video_register_device failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nicd->vdev->dev.type = type;\r\nreturn 0;\r\n}\r\nstatic int soc_camera_pdrv_probe(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_desc *sdesc = pdev->dev.platform_data;\r\nstruct soc_camera_subdev_desc *ssdd = &sdesc->subdev_desc;\r\nstruct soc_camera_device *icd;\r\nint ret;\r\nif (!sdesc)\r\nreturn -EINVAL;\r\nicd = devm_kzalloc(&pdev->dev, sizeof(*icd), GFP_KERNEL);\r\nif (!icd)\r\nreturn -ENOMEM;\r\nret = devm_regulator_bulk_get(&pdev->dev, ssdd->sd_pdata.num_regulators,\r\nssdd->sd_pdata.regulators);\r\nif (ret < 0)\r\nreturn ret;\r\nicd->iface = sdesc->host_desc.bus_id;\r\nicd->sdesc = sdesc;\r\nicd->pdev = &pdev->dev;\r\nplatform_set_drvdata(pdev, icd);\r\nicd->user_width = DEFAULT_WIDTH;\r\nicd->user_height = DEFAULT_HEIGHT;\r\nreturn soc_camera_device_register(icd);\r\n}\r\nstatic int soc_camera_pdrv_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_device *icd = platform_get_drvdata(pdev);\r\nint i;\r\nif (!icd)\r\nreturn -EINVAL;\r\ni = pdev->id;\r\nif (i < 0)\r\ni = 0;\r\nif (test_bit(i, device_map)) {\r\nclear_bit(i, device_map);\r\nlist_del(&icd->list);\r\n}\r\nreturn 0;\r\n}
