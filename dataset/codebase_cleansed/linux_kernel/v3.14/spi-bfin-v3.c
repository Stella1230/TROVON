static void bfin_spi_enable(struct bfin_spi_master *drv_data)\r\n{\r\nbfin_write_or(&drv_data->regs->control, SPI_CTL_EN);\r\n}\r\nstatic void bfin_spi_disable(struct bfin_spi_master *drv_data)\r\n{\r\nbfin_write_and(&drv_data->regs->control, ~SPI_CTL_EN);\r\n}\r\nstatic u32 hz_to_spi_clock(u32 sclk, u32 speed_hz)\r\n{\r\nu32 spi_clock = sclk / speed_hz;\r\nif (spi_clock)\r\nspi_clock--;\r\nreturn spi_clock;\r\n}\r\nstatic int bfin_spi_flush(struct bfin_spi_master *drv_data)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile (!(bfin_read(&drv_data->regs->status) & SPI_STAT_SPIF) && --limit)\r\ncpu_relax();\r\nbfin_write(&drv_data->regs->status, 0xFFFFFFFF);\r\nreturn limit;\r\n}\r\nstatic void bfin_spi_cs_active(struct bfin_spi_master *drv_data, struct bfin_spi_device *chip)\r\n{\r\nif (likely(chip->cs < MAX_CTRL_CS))\r\nbfin_write_and(&drv_data->regs->ssel, ~chip->ssel);\r\nelse\r\ngpio_set_value(chip->cs_gpio, 0);\r\n}\r\nstatic void bfin_spi_cs_deactive(struct bfin_spi_master *drv_data,\r\nstruct bfin_spi_device *chip)\r\n{\r\nif (likely(chip->cs < MAX_CTRL_CS))\r\nbfin_write_or(&drv_data->regs->ssel, chip->ssel);\r\nelse\r\ngpio_set_value(chip->cs_gpio, 1);\r\nif (chip->cs_chg_udelay)\r\nudelay(chip->cs_chg_udelay);\r\n}\r\nstatic inline void bfin_spi_cs_enable(struct bfin_spi_master *drv_data,\r\nstruct bfin_spi_device *chip)\r\n{\r\nif (chip->cs < MAX_CTRL_CS)\r\nbfin_write_or(&drv_data->regs->ssel, chip->ssel >> 8);\r\n}\r\nstatic inline void bfin_spi_cs_disable(struct bfin_spi_master *drv_data,\r\nstruct bfin_spi_device *chip)\r\n{\r\nif (chip->cs < MAX_CTRL_CS)\r\nbfin_write_and(&drv_data->regs->ssel, ~(chip->ssel >> 8));\r\n}\r\nstatic void bfin_spi_restore_state(struct bfin_spi_master *drv_data)\r\n{\r\nstruct bfin_spi_device *chip = drv_data->cur_chip;\r\nbfin_write(&drv_data->regs->status, 0xFFFFFFFF);\r\nbfin_write(&drv_data->regs->rx_control, 0x0);\r\nbfin_write(&drv_data->regs->tx_control, 0x0);\r\nbfin_spi_disable(drv_data);\r\nSSYNC();\r\nbfin_write(&drv_data->regs->control, chip->control);\r\nbfin_write(&drv_data->regs->clock, chip->clock);\r\nbfin_spi_enable(drv_data);\r\ndrv_data->tx_num = drv_data->rx_num = 0;\r\nbfin_write(&drv_data->regs->rx_control, SPI_RXCTL_REN);\r\nbfin_write(&drv_data->regs->tx_control,\r\nSPI_TXCTL_TEN | SPI_TXCTL_TTI);\r\nbfin_spi_cs_active(drv_data, chip);\r\n}\r\nstatic inline void dummy_read(struct bfin_spi_master *drv_data)\r\n{\r\nwhile (!(bfin_read(&drv_data->regs->status) & SPI_STAT_RFE))\r\nbfin_read(&drv_data->regs->rfifo);\r\n}\r\nstatic void bfin_spi_u8_write(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u8 *)(drv_data->tx++)));\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\nbfin_read(&drv_data->regs->rfifo);\r\n}\r\n}\r\nstatic void bfin_spi_u8_read(struct bfin_spi_master *drv_data)\r\n{\r\nu32 tx_val = drv_data->cur_chip->tx_dummy_val;\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, tx_val);\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u8 *)(drv_data->rx++) = bfin_read(&drv_data->regs->rfifo);\r\n}\r\n}\r\nstatic void bfin_spi_u8_duplex(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u8 *)(drv_data->tx++)));\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u8 *)(drv_data->rx++) = bfin_read(&drv_data->regs->rfifo);\r\n}\r\n}\r\nstatic void bfin_spi_u16_write(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u16 *)drv_data->tx));\r\ndrv_data->tx += 2;\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\nbfin_read(&drv_data->regs->rfifo);\r\n}\r\n}\r\nstatic void bfin_spi_u16_read(struct bfin_spi_master *drv_data)\r\n{\r\nu32 tx_val = drv_data->cur_chip->tx_dummy_val;\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, tx_val);\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u16 *)drv_data->rx = bfin_read(&drv_data->regs->rfifo);\r\ndrv_data->rx += 2;\r\n}\r\n}\r\nstatic void bfin_spi_u16_duplex(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u16 *)drv_data->tx));\r\ndrv_data->tx += 2;\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u16 *)drv_data->rx = bfin_read(&drv_data->regs->rfifo);\r\ndrv_data->rx += 2;\r\n}\r\n}\r\nstatic void bfin_spi_u32_write(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u32 *)drv_data->tx));\r\ndrv_data->tx += 4;\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\nbfin_read(&drv_data->regs->rfifo);\r\n}\r\n}\r\nstatic void bfin_spi_u32_read(struct bfin_spi_master *drv_data)\r\n{\r\nu32 tx_val = drv_data->cur_chip->tx_dummy_val;\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, tx_val);\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u32 *)drv_data->rx = bfin_read(&drv_data->regs->rfifo);\r\ndrv_data->rx += 4;\r\n}\r\n}\r\nstatic void bfin_spi_u32_duplex(struct bfin_spi_master *drv_data)\r\n{\r\ndummy_read(drv_data);\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tfifo, (*(u32 *)drv_data->tx));\r\ndrv_data->tx += 4;\r\nwhile (bfin_read(&drv_data->regs->status) & SPI_STAT_RFE)\r\ncpu_relax();\r\n*(u32 *)drv_data->rx = bfin_read(&drv_data->regs->rfifo);\r\ndrv_data->rx += 4;\r\n}\r\n}\r\nstatic void bfin_spi_next_transfer(struct bfin_spi_master *drv)\r\n{\r\nstruct spi_message *msg = drv->cur_msg;\r\nstruct spi_transfer *t = drv->cur_transfer;\r\nif (t->transfer_list.next != &msg->transfers) {\r\ndrv->cur_transfer = list_entry(t->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\ndrv->state = RUNNING_STATE;\r\n} else {\r\ndrv->state = DONE_STATE;\r\ndrv->cur_transfer = NULL;\r\n}\r\n}\r\nstatic void bfin_spi_giveback(struct bfin_spi_master *drv_data)\r\n{\r\nstruct bfin_spi_device *chip = drv_data->cur_chip;\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nspi_finalize_current_message(drv_data->master);\r\n}\r\nstatic int bfin_spi_setup_transfer(struct bfin_spi_master *drv)\r\n{\r\nstruct spi_transfer *t = drv->cur_transfer;\r\nu32 cr, cr_width;\r\nif (t->tx_buf) {\r\ndrv->tx = (void *)t->tx_buf;\r\ndrv->tx_end = drv->tx + t->len;\r\n} else {\r\ndrv->tx = NULL;\r\n}\r\nif (t->rx_buf) {\r\ndrv->rx = t->rx_buf;\r\ndrv->rx_end = drv->rx + t->len;\r\n} else {\r\ndrv->rx = NULL;\r\n}\r\ndrv->transfer_len = t->len;\r\nswitch (t->bits_per_word) {\r\ncase 8:\r\ncr_width = SPI_CTL_SIZE08;\r\ndrv->ops = &bfin_bfin_spi_transfer_ops_u8;\r\nbreak;\r\ncase 16:\r\ncr_width = SPI_CTL_SIZE16;\r\ndrv->ops = &bfin_bfin_spi_transfer_ops_u16;\r\nbreak;\r\ncase 32:\r\ncr_width = SPI_CTL_SIZE32;\r\ndrv->ops = &bfin_bfin_spi_transfer_ops_u32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncr = bfin_read(&drv->regs->control) & ~SPI_CTL_SIZE;\r\ncr |= cr_width;\r\nbfin_write(&drv->regs->control, cr);\r\nbfin_write(&drv->regs->clock,\r\nhz_to_spi_clock(drv->sclk, t->speed_hz));\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_dma_xfer(struct bfin_spi_master *drv_data)\r\n{\r\nstruct spi_transfer *t = drv_data->cur_transfer;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct bfin_spi_device *chip = drv_data->cur_chip;\r\nu32 dma_config;\r\nunsigned long word_count, word_size;\r\nvoid *tx_buf, *rx_buf;\r\nswitch (t->bits_per_word) {\r\ncase 8:\r\ndma_config = WDSIZE_8 | PSIZE_8;\r\nword_count = drv_data->transfer_len;\r\nword_size = 1;\r\nbreak;\r\ncase 16:\r\ndma_config = WDSIZE_16 | PSIZE_16;\r\nword_count = drv_data->transfer_len / 2;\r\nword_size = 2;\r\nbreak;\r\ndefault:\r\ndma_config = WDSIZE_32 | PSIZE_32;\r\nword_count = drv_data->transfer_len / 4;\r\nword_size = 4;\r\nbreak;\r\n}\r\nif (!drv_data->rx) {\r\ntx_buf = drv_data->tx;\r\nrx_buf = &drv_data->dummy_buffer;\r\ndrv_data->tx_dma_size = drv_data->transfer_len;\r\ndrv_data->rx_dma_size = sizeof(drv_data->dummy_buffer);\r\nset_dma_x_modify(drv_data->tx_dma, word_size);\r\nset_dma_x_modify(drv_data->rx_dma, 0);\r\n} else if (!drv_data->tx) {\r\ndrv_data->dummy_buffer = chip->tx_dummy_val;\r\ntx_buf = &drv_data->dummy_buffer;\r\nrx_buf = drv_data->rx;\r\ndrv_data->tx_dma_size = sizeof(drv_data->dummy_buffer);\r\ndrv_data->rx_dma_size = drv_data->transfer_len;\r\nset_dma_x_modify(drv_data->tx_dma, 0);\r\nset_dma_x_modify(drv_data->rx_dma, word_size);\r\n} else {\r\ntx_buf = drv_data->tx;\r\nrx_buf = drv_data->rx;\r\ndrv_data->tx_dma_size = drv_data->rx_dma_size\r\n= drv_data->transfer_len;\r\nset_dma_x_modify(drv_data->tx_dma, word_size);\r\nset_dma_x_modify(drv_data->rx_dma, word_size);\r\n}\r\ndrv_data->tx_dma_addr = dma_map_single(&msg->spi->dev,\r\n(void *)tx_buf,\r\ndrv_data->tx_dma_size,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&msg->spi->dev,\r\ndrv_data->tx_dma_addr))\r\nreturn -ENOMEM;\r\ndrv_data->rx_dma_addr = dma_map_single(&msg->spi->dev,\r\n(void *)rx_buf,\r\ndrv_data->rx_dma_size,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&msg->spi->dev,\r\ndrv_data->rx_dma_addr)) {\r\ndma_unmap_single(&msg->spi->dev,\r\ndrv_data->tx_dma_addr,\r\ndrv_data->tx_dma_size,\r\nDMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\ndummy_read(drv_data);\r\nset_dma_x_count(drv_data->tx_dma, word_count);\r\nset_dma_x_count(drv_data->rx_dma, word_count);\r\nset_dma_start_addr(drv_data->tx_dma, drv_data->tx_dma_addr);\r\nset_dma_start_addr(drv_data->rx_dma, drv_data->rx_dma_addr);\r\ndma_config |= DMAFLOW_STOP | RESTART | DI_EN;\r\nset_dma_config(drv_data->tx_dma, dma_config);\r\nset_dma_config(drv_data->rx_dma, dma_config | WNR);\r\nenable_dma(drv_data->tx_dma);\r\nenable_dma(drv_data->rx_dma);\r\nSSYNC();\r\nbfin_write(&drv_data->regs->rx_control, SPI_RXCTL_REN | SPI_RXCTL_RDR_NE);\r\nSSYNC();\r\nbfin_write(&drv_data->regs->tx_control,\r\nSPI_TXCTL_TEN | SPI_TXCTL_TTI | SPI_TXCTL_TDR_NF);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_pio_xfer(struct bfin_spi_master *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nif (!drv_data->rx) {\r\ndrv_data->ops->write(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\nreturn -EIO;\r\n} else if (!drv_data->tx) {\r\ndrv_data->ops->read(drv_data);\r\nif (drv_data->rx != drv_data->rx_end)\r\nreturn -EIO;\r\n} else {\r\ndrv_data->ops->duplex(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\nreturn -EIO;\r\n}\r\nif (!bfin_spi_flush(drv_data))\r\nreturn -EIO;\r\nmsg->actual_length += drv_data->transfer_len;\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn 0;\r\n}\r\nstatic void bfin_spi_pump_transfers(unsigned long data)\r\n{\r\nstruct bfin_spi_master *drv_data = (struct bfin_spi_master *)data;\r\nstruct spi_message *msg = NULL;\r\nstruct spi_transfer *t = NULL;\r\nstruct bfin_spi_device *chip = NULL;\r\nint ret;\r\nmsg = drv_data->cur_msg;\r\nt = drv_data->cur_transfer;\r\nchip = drv_data->cur_chip;\r\nif (drv_data->state == ERROR_STATE) {\r\nmsg->status = -EIO;\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (drv_data->state == RUNNING_STATE) {\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change)\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nbfin_spi_next_transfer(drv_data);\r\nt = drv_data->cur_transfer;\r\n}\r\nif (drv_data->state == DONE_STATE) {\r\nmsg->status = 0;\r\nbfin_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif ((t->len == 0) || (t->tx_buf == NULL && t->rx_buf == NULL)) {\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn;\r\n}\r\nret = bfin_spi_setup_transfer(drv_data);\r\nif (ret) {\r\nmsg->status = ret;\r\nbfin_spi_giveback(drv_data);\r\n}\r\nbfin_write(&drv_data->regs->status, 0xFFFFFFFF);\r\nbfin_spi_cs_active(drv_data, chip);\r\ndrv_data->state = RUNNING_STATE;\r\nif (chip->enable_dma)\r\nret = bfin_spi_dma_xfer(drv_data);\r\nelse\r\nret = bfin_spi_pio_xfer(drv_data);\r\nif (ret) {\r\nmsg->status = ret;\r\nbfin_spi_giveback(drv_data);\r\n}\r\n}\r\nstatic int bfin_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(master);\r\ndrv_data->cur_msg = m;\r\ndrv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);\r\nbfin_spi_restore_state(drv_data);\r\ndrv_data->state = START_STATE;\r\ndrv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_setup(struct spi_device *spi)\r\n{\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(spi->master);\r\nstruct bfin_spi_device *chip = spi_get_ctldata(spi);\r\nu32 bfin_ctl_reg = SPI_CTL_ODM | SPI_CTL_PSSE;\r\nint ret = -EINVAL;\r\nif (!chip) {\r\nstruct bfin_spi3_chip *chip_info = spi->controller_data;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\ndev_err(&spi->dev, "can not allocate chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nif (chip_info) {\r\nif (chip_info->control & ~bfin_ctl_reg) {\r\ndev_err(&spi->dev,\r\n"do not set bits that the SPI framework manages\n");\r\ngoto error;\r\n}\r\nchip->control = chip_info->control;\r\nchip->cs_chg_udelay = chip_info->cs_chg_udelay;\r\nchip->tx_dummy_val = chip_info->tx_dummy_val;\r\nchip->enable_dma = chip_info->enable_dma;\r\n}\r\nchip->cs = spi->chip_select;\r\nif (chip->cs < MAX_CTRL_CS) {\r\nchip->ssel = (1 << chip->cs) << 8;\r\nret = peripheral_request(ssel[spi->master->bus_num]\r\n[chip->cs-1], dev_name(&spi->dev));\r\nif (ret) {\r\ndev_err(&spi->dev, "peripheral_request() error\n");\r\ngoto error;\r\n}\r\n} else {\r\nchip->cs_gpio = chip->cs - MAX_CTRL_CS;\r\nret = gpio_request_one(chip->cs_gpio, GPIOF_OUT_INIT_HIGH,\r\ndev_name(&spi->dev));\r\nif (ret) {\r\ndev_err(&spi->dev, "gpio_request_one() error\n");\r\ngoto error;\r\n}\r\n}\r\nspi_set_ctldata(spi, chip);\r\n}\r\nchip->control &= bfin_ctl_reg;\r\nif (spi->mode & SPI_CPOL)\r\nchip->control |= SPI_CTL_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nchip->control |= SPI_CTL_CPHA;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nchip->control |= SPI_CTL_LSBF;\r\nchip->control |= SPI_CTL_MSTR;\r\nchip->control &= ~SPI_CTL_ASSEL;\r\nchip->clock = hz_to_spi_clock(drv_data->sclk, spi->max_speed_hz);\r\nbfin_spi_cs_enable(drv_data, chip);\r\nbfin_spi_cs_deactive(drv_data, chip);\r\nreturn 0;\r\nerror:\r\nif (chip) {\r\nkfree(chip);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bfin_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct bfin_spi_device *chip = spi_get_ctldata(spi);\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(spi->master);\r\nif (!chip)\r\nreturn;\r\nif (chip->cs < MAX_CTRL_CS) {\r\nperipheral_free(ssel[spi->master->bus_num]\r\n[chip->cs-1]);\r\nbfin_spi_cs_disable(drv_data, chip);\r\n} else {\r\ngpio_free(chip->cs_gpio);\r\n}\r\nkfree(chip);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nstatic irqreturn_t bfin_spi_tx_dma_isr(int irq, void *dev_id)\r\n{\r\nstruct bfin_spi_master *drv_data = dev_id;\r\nu32 dma_stat = get_dma_curr_irqstat(drv_data->tx_dma);\r\nclear_dma_irqstat(drv_data->tx_dma);\r\nif (dma_stat & DMA_DONE) {\r\ndrv_data->tx_num++;\r\n} else {\r\ndev_err(&drv_data->master->dev,\r\n"spi tx dma error: %d\n", dma_stat);\r\nif (drv_data->tx)\r\ndrv_data->state = ERROR_STATE;\r\n}\r\nbfin_write_and(&drv_data->regs->tx_control, ~SPI_TXCTL_TDR_NF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bfin_spi_rx_dma_isr(int irq, void *dev_id)\r\n{\r\nstruct bfin_spi_master *drv_data = dev_id;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nu32 dma_stat = get_dma_curr_irqstat(drv_data->rx_dma);\r\nclear_dma_irqstat(drv_data->rx_dma);\r\nif (dma_stat & DMA_DONE) {\r\ndrv_data->rx_num++;\r\nif (drv_data->state != ERROR_STATE)\r\nmsg->actual_length += drv_data->transfer_len;\r\n} else {\r\ndrv_data->state = ERROR_STATE;\r\ndev_err(&drv_data->master->dev,\r\n"spi rx dma error: %d\n", dma_stat);\r\n}\r\nbfin_write(&drv_data->regs->tx_control, 0);\r\nbfin_write(&drv_data->regs->rx_control, 0);\r\nif (drv_data->rx_num != drv_data->tx_num)\r\ndev_dbg(&drv_data->master->dev,\r\n"dma interrupt missing: tx=%d,rx=%d\n",\r\ndrv_data->tx_num, drv_data->rx_num);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bfin_spi3_master *info = dev_get_platdata(dev);\r\nstruct spi_master *master;\r\nstruct bfin_spi_master *drv_data;\r\nstruct resource *mem, *res;\r\nunsigned int tx_dma, rx_dma;\r\nunsigned long sclk;\r\nint ret;\r\nif (!info) {\r\ndev_err(dev, "platform data missing!\n");\r\nreturn -ENODEV;\r\n}\r\nsclk = get_sclk1();\r\nif (!sclk) {\r\ndev_err(dev, "can not get sclk1\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(dev, "can not get tx dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ntx_dma = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(dev, "can not get rx dma resource\n");\r\nreturn -ENXIO;\r\n}\r\nrx_dma = res->start;\r\nmaster = spi_alloc_master(dev, sizeof(*drv_data));\r\nif (!master) {\r\ndev_err(dev, "can not alloc spi_master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = info->num_chipselect;\r\nmaster->cleanup = bfin_spi_cleanup;\r\nmaster->setup = bfin_spi_setup;\r\nmaster->transfer_one_message = bfin_spi_transfer_one_message;\r\nmaster->bits_per_word_mask = BIT(32 - 1) | BIT(16 - 1) | BIT(8 - 1);\r\ndrv_data = spi_master_get_devdata(master);\r\ndrv_data->master = master;\r\ndrv_data->tx_dma = tx_dma;\r\ndrv_data->rx_dma = rx_dma;\r\ndrv_data->pin_req = info->pin_req;\r\ndrv_data->sclk = sclk;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrv_data->regs = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(drv_data->regs)) {\r\nret = PTR_ERR(drv_data->regs);\r\ngoto err_put_master;\r\n}\r\nret = request_dma(tx_dma, "SPI_TX_DMA");\r\nif (ret) {\r\ndev_err(dev, "can not request SPI TX DMA channel\n");\r\ngoto err_put_master;\r\n}\r\nset_dma_callback(tx_dma, bfin_spi_tx_dma_isr, drv_data);\r\nret = request_dma(rx_dma, "SPI_RX_DMA");\r\nif (ret) {\r\ndev_err(dev, "can not request SPI RX DMA channel\n");\r\ngoto err_free_tx_dma;\r\n}\r\nset_dma_callback(drv_data->rx_dma, bfin_spi_rx_dma_isr, drv_data);\r\nret = peripheral_request_list(drv_data->pin_req, "bfin-spi3");\r\nif (ret < 0) {\r\ndev_err(dev, "can not request spi pins\n");\r\ngoto err_free_rx_dma;\r\n}\r\nbfin_write(&drv_data->regs->control, SPI_CTL_MSTR | SPI_CTL_CPHA);\r\nbfin_write(&drv_data->regs->ssel, 0x0000FE00);\r\nbfin_write(&drv_data->regs->delay, 0x0);\r\ntasklet_init(&drv_data->pump_transfers,\r\nbfin_spi_pump_transfers, (unsigned long)drv_data);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret) {\r\ndev_err(dev, "can not register spi master\n");\r\ngoto err_free_peripheral;\r\n}\r\nreturn ret;\r\nerr_free_peripheral:\r\nperipheral_free_list(drv_data->pin_req);\r\nerr_free_rx_dma:\r\nfree_dma(rx_dma);\r\nerr_free_tx_dma:\r\nfree_dma(tx_dma);\r\nerr_put_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int bfin_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(master);\r\nbfin_spi_disable(drv_data);\r\nperipheral_free_list(drv_data->pin_req);\r\nfree_dma(drv_data->rx_dma);\r\nfree_dma(drv_data->tx_dma);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\ndrv_data->control = bfin_read(&drv_data->regs->control);\r\ndrv_data->ssel = bfin_read(&drv_data->regs->ssel);\r\nbfin_write(&drv_data->regs->control, SPI_CTL_MSTR | SPI_CTL_CPHA);\r\nbfin_write(&drv_data->regs->ssel, 0x0000FE00);\r\ndma_disable_irq(drv_data->rx_dma);\r\ndma_disable_irq(drv_data->tx_dma);\r\nreturn 0;\r\n}\r\nstatic int bfin_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct bfin_spi_master *drv_data = spi_master_get_devdata(master);\r\nint ret = 0;\r\ndisable_dma(drv_data->rx_dma);\r\ndma_enable_irq(drv_data->rx_dma);\r\ndma_enable_irq(drv_data->tx_dma);\r\nbfin_write(&drv_data->regs->control, drv_data->control);\r\nbfin_write(&drv_data->regs->ssel, drv_data->ssel);\r\nret = spi_master_resume(master);\r\nif (ret) {\r\nfree_dma(drv_data->rx_dma);\r\nfree_dma(drv_data->tx_dma);\r\n}\r\nreturn ret;\r\n}
