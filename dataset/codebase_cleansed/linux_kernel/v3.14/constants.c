static const char * get_sa_name(const struct value_name_pair * arr,\r\nint arr_sz, int service_action)\r\n{\r\nint k;\r\nfor (k = 0; k < arr_sz; ++k, ++arr) {\r\nif (service_action == arr->value)\r\nbreak;\r\n}\r\nreturn (k < arr_sz) ? arr->name : NULL;\r\n}\r\nstatic void print_opcode_name(unsigned char * cdbp, int cdb_len)\r\n{\r\nint sa, len, cdb0;\r\nint fin_name = 0;\r\nconst char * name;\r\ncdb0 = cdbp[0];\r\nswitch(cdb0) {\r\ncase VARIABLE_LENGTH_CMD:\r\nlen = scsi_varlen_cdb_length(cdbp);\r\nif (len < 10) {\r\nprintk("short variable length command, "\r\n"len=%d ext_len=%d", len, cdb_len);\r\nbreak;\r\n}\r\nsa = (cdbp[8] << 8) + cdbp[9];\r\nname = get_sa_name(variable_length_arr, VARIABLE_LENGTH_SZ,\r\nsa);\r\nif (name)\r\nprintk("%s", name);\r\nelse\r\nprintk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);\r\nif ((cdb_len > 0) && (len != cdb_len))\r\nprintk(", in_cdb_len=%d, ext_len=%d", len, cdb_len);\r\nbreak;\r\ncase MAINTENANCE_IN:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(maint_in_arr, MAINT_IN_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase MAINTENANCE_OUT:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(maint_out_arr, MAINT_OUT_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase PERSISTENT_RESERVE_IN:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(pr_in_arr, PR_IN_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase PERSISTENT_RESERVE_OUT:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(pr_out_arr, PR_OUT_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase SERVICE_ACTION_IN_12:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(serv_in12_arr, SERV_IN12_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase SERVICE_ACTION_OUT_12:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(serv_out12_arr, SERV_OUT12_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase SERVICE_ACTION_BIDIRECTIONAL:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(serv_bidi_arr, SERV_BIDI_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase SERVICE_ACTION_IN_16:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(serv_in16_arr, SERV_IN16_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase SERVICE_ACTION_OUT_16:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(serv_out16_arr, SERV_OUT16_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase THIRD_PARTY_COPY_IN:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(tpc_in_arr, TPC_IN_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ncase THIRD_PARTY_COPY_OUT:\r\nsa = cdbp[1] & 0x1f;\r\nname = get_sa_name(tpc_out_arr, TPC_OUT_SZ, sa);\r\nfin_name = 1;\r\nbreak;\r\ndefault:\r\nif (cdb0 < 0xc0) {\r\nname = cdb_byte0_names[cdb0];\r\nif (name)\r\nprintk("%s", name);\r\nelse\r\nprintk("cdb[0]=0x%x (reserved)", cdb0);\r\n} else\r\nprintk("cdb[0]=0x%x (vendor)", cdb0);\r\nbreak;\r\n}\r\nif (fin_name) {\r\nif (name)\r\nprintk("%s", name);\r\nelse\r\nprintk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);\r\n}\r\n}\r\nstatic void print_opcode_name(unsigned char * cdbp, int cdb_len)\r\n{\r\nint sa, len, cdb0;\r\ncdb0 = cdbp[0];\r\nswitch(cdb0) {\r\ncase VARIABLE_LENGTH_CMD:\r\nlen = scsi_varlen_cdb_length(cdbp);\r\nif (len < 10) {\r\nprintk("short opcode=0x%x command, len=%d "\r\n"ext_len=%d", cdb0, len, cdb_len);\r\nbreak;\r\n}\r\nsa = (cdbp[8] << 8) + cdbp[9];\r\nprintk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);\r\nif (len != cdb_len)\r\nprintk(", in_cdb_len=%d, ext_len=%d", len, cdb_len);\r\nbreak;\r\ncase MAINTENANCE_IN:\r\ncase MAINTENANCE_OUT:\r\ncase PERSISTENT_RESERVE_IN:\r\ncase PERSISTENT_RESERVE_OUT:\r\ncase SERVICE_ACTION_IN_12:\r\ncase SERVICE_ACTION_OUT_12:\r\ncase SERVICE_ACTION_BIDIRECTIONAL:\r\ncase SERVICE_ACTION_IN_16:\r\ncase SERVICE_ACTION_OUT_16:\r\ncase THIRD_PARTY_COPY_IN:\r\ncase THIRD_PARTY_COPY_OUT:\r\nsa = cdbp[1] & 0x1f;\r\nprintk("cdb[0]=0x%x, sa=0x%x", cdb0, sa);\r\nbreak;\r\ndefault:\r\nif (cdb0 < 0xc0)\r\nprintk("cdb[0]=0x%x", cdb0);\r\nelse\r\nprintk("cdb[0]=0x%x (vendor)", cdb0);\r\nbreak;\r\n}\r\n}\r\nvoid __scsi_print_command(unsigned char *cdb)\r\n{\r\nint k, len;\r\nprint_opcode_name(cdb, 0);\r\nlen = scsi_command_size(cdb);\r\nfor (k = 0; k < len; ++k)\r\nprintk(" %02x", cdb[k]);\r\nprintk("\n");\r\n}\r\nvoid scsi_print_command(struct scsi_cmnd *cmd)\r\n{\r\nint k;\r\nif (cmd->cmnd == NULL)\r\nreturn;\r\nscmd_printk(KERN_INFO, cmd, "CDB: ");\r\nprint_opcode_name(cmd->cmnd, cmd->cmd_len);\r\nprintk(":");\r\nfor (k = 0; k < cmd->cmd_len; ++k)\r\nprintk(" %02x", cmd->cmnd[k]);\r\nprintk("\n");\r\n}\r\nvoid\r\nscsi_print_status(unsigned char scsi_status) {\r\n#ifdef CONFIG_SCSI_CONSTANTS\r\nconst char * ccp;\r\nswitch (scsi_status) {\r\ncase 0: ccp = "Good"; break;\r\ncase 0x2: ccp = "Check Condition"; break;\r\ncase 0x4: ccp = "Condition Met"; break;\r\ncase 0x8: ccp = "Busy"; break;\r\ncase 0x10: ccp = "Intermediate"; break;\r\ncase 0x14: ccp = "Intermediate-Condition Met"; break;\r\ncase 0x18: ccp = "Reservation Conflict"; break;\r\ncase 0x22: ccp = "Command Terminated"; break;\r\ncase 0x28: ccp = "Task set Full"; break;\r\ncase 0x30: ccp = "ACA Active"; break;\r\ncase 0x40: ccp = "Task Aborted"; break;\r\ndefault: ccp = "Unknown status";\r\n}\r\nprintk(KERN_INFO "%s", ccp);\r\n#else\r\nprintk(KERN_INFO "0x%0x", scsi_status);\r\n#endif\r\n}\r\nconst char *\r\nscsi_sense_key_string(unsigned char key) {\r\n#ifdef CONFIG_SCSI_CONSTANTS\r\nif (key <= 0xE)\r\nreturn snstext[key];\r\n#endif\r\nreturn NULL;\r\n}\r\nconst char *\r\nscsi_extd_sense_format(unsigned char asc, unsigned char ascq) {\r\n#ifdef CONFIG_SCSI_CONSTANTS\r\nint i;\r\nunsigned short code = ((asc << 8) | ascq);\r\nfor (i = 0; additional[i].text; i++)\r\nif (additional[i].code12 == code)\r\nreturn additional[i].text;\r\nfor (i = 0; additional2[i].fmt; i++) {\r\nif (additional2[i].code1 == asc &&\r\nascq >= additional2[i].code2_min &&\r\nascq <= additional2[i].code2_max)\r\nreturn additional2[i].fmt;\r\n}\r\n#endif\r\nreturn NULL;\r\n}\r\nvoid\r\nscsi_show_extd_sense(unsigned char asc, unsigned char ascq)\r\n{\r\nconst char *extd_sense_fmt = scsi_extd_sense_format(asc, ascq);\r\nif (extd_sense_fmt) {\r\nif (strstr(extd_sense_fmt, "%x")) {\r\nprintk("Add. Sense: ");\r\nprintk(extd_sense_fmt, ascq);\r\n} else\r\nprintk("Add. Sense: %s", extd_sense_fmt);\r\n} else {\r\nif (asc >= 0x80)\r\nprintk("<<vendor>> ASC=0x%x ASCQ=0x%x", asc,\r\nascq);\r\nif (ascq >= 0x80)\r\nprintk("ASC=0x%x <<vendor>> ASCQ=0x%x", asc,\r\nascq);\r\nelse\r\nprintk("ASC=0x%x ASCQ=0x%x", asc, ascq);\r\n}\r\nprintk("\n");\r\n}\r\nvoid\r\nscsi_show_sense_hdr(struct scsi_sense_hdr *sshdr)\r\n{\r\nconst char *sense_txt;\r\nsense_txt = scsi_sense_key_string(sshdr->sense_key);\r\nif (sense_txt)\r\nprintk("Sense Key : %s ", sense_txt);\r\nelse\r\nprintk("Sense Key : 0x%x ", sshdr->sense_key);\r\nprintk("%s", scsi_sense_is_deferred(sshdr) ? "[deferred] " :\r\n"[current] ");\r\nif (sshdr->response_code >= 0x72)\r\nprintk("[descriptor]");\r\nprintk("\n");\r\n}\r\nvoid\r\nscsi_print_sense_hdr(const char *name, struct scsi_sense_hdr *sshdr)\r\n{\r\nprintk(KERN_INFO "%s: ", name);\r\nscsi_show_sense_hdr(sshdr);\r\nprintk(KERN_INFO "%s: ", name);\r\nscsi_show_extd_sense(sshdr->asc, sshdr->ascq);\r\n}\r\nvoid\r\nscsi_cmd_print_sense_hdr(struct scsi_cmnd *scmd, const char *desc,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nscmd_printk(KERN_INFO, scmd, "%s: ", desc);\r\nscsi_show_sense_hdr(sshdr);\r\nscmd_printk(KERN_INFO, scmd, "%s: ", desc);\r\nscsi_show_extd_sense(sshdr->asc, sshdr->ascq);\r\n}\r\nstatic void\r\nscsi_decode_sense_buffer(const unsigned char *sense_buffer, int sense_len,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint k, num, res;\r\nres = scsi_normalize_sense(sense_buffer, sense_len, sshdr);\r\nif (0 == res) {\r\nnum = (sense_len < 32) ? sense_len : 32;\r\nprintk("Unrecognized sense data (in hex):");\r\nfor (k = 0; k < num; ++k) {\r\nif (0 == (k % 16)) {\r\nprintk("\n");\r\nprintk(KERN_INFO " ");\r\n}\r\nprintk("%02x ", sense_buffer[k]);\r\n}\r\nprintk("\n");\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nscsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint k, num, res;\r\nif (sshdr->response_code < 0x72)\r\n{\r\nchar buff[80];\r\nint blen, fixed_valid;\r\nunsigned int info;\r\nfixed_valid = sense_buffer[0] & 0x80;\r\ninfo = ((sense_buffer[3] << 24) | (sense_buffer[4] << 16) |\r\n(sense_buffer[5] << 8) | sense_buffer[6]);\r\nres = 0;\r\nmemset(buff, 0, sizeof(buff));\r\nblen = sizeof(buff) - 1;\r\nif (fixed_valid)\r\nres += snprintf(buff + res, blen - res,\r\n"Info fld=0x%x", info);\r\nif (sense_buffer[2] & 0x80) {\r\nif (res > 0)\r\nres += snprintf(buff + res, blen - res, ", ");\r\nres += snprintf(buff + res, blen - res, "FMK");\r\n}\r\nif (sense_buffer[2] & 0x40) {\r\nif (res > 0)\r\nres += snprintf(buff + res, blen - res, ", ");\r\nres += snprintf(buff + res, blen - res, "EOM");\r\n}\r\nif (sense_buffer[2] & 0x20) {\r\nif (res > 0)\r\nres += snprintf(buff + res, blen - res, ", ");\r\nres += snprintf(buff + res, blen - res, "ILI");\r\n}\r\nif (res > 0)\r\nprintk("%s\n", buff);\r\n} else if (sshdr->additional_length > 0) {\r\nnum = 8 + sshdr->additional_length;\r\nnum = (sense_len < num) ? sense_len : num;\r\nprintk("Descriptor sense data with sense descriptors "\r\n"(in hex):");\r\nfor (k = 0; k < num; ++k) {\r\nif (0 == (k % 16)) {\r\nprintk("\n");\r\nprintk(KERN_INFO " ");\r\n}\r\nprintk("%02x ", sense_buffer[k]);\r\n}\r\nprintk("\n");\r\n}\r\n}\r\nvoid __scsi_print_sense(const char *name, const unsigned char *sense_buffer,\r\nint sense_len)\r\n{\r\nstruct scsi_sense_hdr sshdr;\r\nprintk(KERN_INFO "%s: ", name);\r\nscsi_decode_sense_buffer(sense_buffer, sense_len, &sshdr);\r\nscsi_show_sense_hdr(&sshdr);\r\nscsi_decode_sense_extras(sense_buffer, sense_len, &sshdr);\r\nprintk(KERN_INFO "%s: ", name);\r\nscsi_show_extd_sense(sshdr.asc, sshdr.ascq);\r\n}\r\nvoid scsi_print_sense(char *name, struct scsi_cmnd *cmd)\r\n{\r\nstruct scsi_sense_hdr sshdr;\r\nscmd_printk(KERN_INFO, cmd, " ");\r\nscsi_decode_sense_buffer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nscsi_show_sense_hdr(&sshdr);\r\nscsi_decode_sense_extras(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,\r\n&sshdr);\r\nscmd_printk(KERN_INFO, cmd, " ");\r\nscsi_show_extd_sense(sshdr.asc, sshdr.ascq);\r\n}\r\nvoid scsi_show_result(int result)\r\n{\r\nint hb = host_byte(result);\r\nint db = driver_byte(result);\r\nprintk("Result: hostbyte=%s driverbyte=%s\n",\r\n(hb < NUM_HOSTBYTE_STRS ? hostbyte_table[hb] : "invalid"),\r\n(db < NUM_DRIVERBYTE_STRS ? driverbyte_table[db] : "invalid"));\r\n}\r\nvoid scsi_show_result(int result)\r\n{\r\nprintk("Result: hostbyte=0x%02x driverbyte=0x%02x\n",\r\nhost_byte(result), driver_byte(result));\r\n}\r\nvoid scsi_print_result(struct scsi_cmnd *cmd)\r\n{\r\nscmd_printk(KERN_INFO, cmd, " ");\r\nscsi_show_result(cmd->result);\r\n}
