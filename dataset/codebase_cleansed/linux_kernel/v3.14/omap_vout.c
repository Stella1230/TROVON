static int omap_vout_try_format(struct v4l2_pix_format *pix)\r\n{\r\nint ifmt, bpp = 0;\r\npix->height = clamp(pix->height, (u32)VID_MIN_HEIGHT,\r\n(u32)VID_MAX_HEIGHT);\r\npix->width = clamp(pix->width, (u32)VID_MIN_WIDTH, (u32)VID_MAX_WIDTH);\r\nfor (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {\r\nif (pix->pixelformat == omap_formats[ifmt].pixelformat)\r\nbreak;\r\n}\r\nif (ifmt == NUM_OUTPUT_FORMATS)\r\nifmt = 0;\r\npix->pixelformat = omap_formats[ifmt].pixelformat;\r\npix->field = V4L2_FIELD_ANY;\r\npix->priv = 0;\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_UYVY:\r\ndefault:\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\nbpp = YUYV_BPP;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncase V4L2_PIX_FMT_RGB565X:\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nbpp = RGB565_BPP;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nbpp = RGB24_BPP;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\ncase V4L2_PIX_FMT_BGR32:\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nbpp = RGB32_BPP;\r\nbreak;\r\n}\r\npix->bytesperline = pix->width * bpp;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\nreturn bpp;\r\n}\r\nstatic u32 omap_vout_uservirt_to_phys(u32 virtp)\r\n{\r\nunsigned long physp = 0;\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nif (virtp >= PAGE_OFFSET)\r\nreturn virt_to_phys((void *) virtp);\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(mm, virtp);\r\nif (vma && (vma->vm_flags & VM_IO) && vma->vm_pgoff) {\r\nphysp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);\r\nup_read(&current->mm->mmap_sem);\r\n} else {\r\nint res, nr_pages = 1;\r\nstruct page *pages;\r\nres = get_user_pages(current, current->mm, virtp, nr_pages, 1,\r\n0, &pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (res == nr_pages) {\r\nphysp = __pa(page_address(&pages[0]) +\r\n(virtp & ~PAGE_MASK));\r\n} else {\r\nprintk(KERN_WARNING VOUT_NAME\r\n"get_user_pages failed\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn physp;\r\n}\r\nvoid omap_vout_free_buffers(struct omap_vout_device *vout)\r\n{\r\nint i, numbuffers;\r\nnumbuffers = (vout->vid) ? video2_numbuffers : video1_numbuffers;\r\nvout->buffer_size = (vout->vid) ? video2_bufsize : video1_bufsize;\r\nfor (i = 0; i < numbuffers; i++) {\r\nomap_vout_free_buffer(vout->buf_virt_addr[i],\r\nvout->buffer_size);\r\nvout->buf_phy_addr[i] = 0;\r\nvout->buf_virt_addr[i] = 0;\r\n}\r\n}\r\nstatic int v4l2_rot_to_dss_rot(int v4l2_rotation,\r\nenum dss_rotation *rotation, bool mirror)\r\n{\r\nint ret = 0;\r\nswitch (v4l2_rotation) {\r\ncase 90:\r\n*rotation = dss_rotation_90_degree;\r\nbreak;\r\ncase 180:\r\n*rotation = dss_rotation_180_degree;\r\nbreak;\r\ncase 270:\r\n*rotation = dss_rotation_270_degree;\r\nbreak;\r\ncase 0:\r\n*rotation = dss_rotation_0_degree;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_vout_calculate_offset(struct omap_vout_device *vout)\r\n{\r\nstruct omapvideo_info *ovid;\r\nstruct v4l2_rect *crop = &vout->crop;\r\nstruct v4l2_pix_format *pix = &vout->pix;\r\nint *cropped_offset = &vout->cropped_offset;\r\nint ps = 2, line_length = 0;\r\novid = &vout->vid_info;\r\nif (ovid->rotation_type == VOUT_ROT_VRFB) {\r\nomap_vout_calculate_vrfb_offset(vout);\r\n} else {\r\nvout->line_length = line_length = pix->width;\r\nif (V4L2_PIX_FMT_YUYV == pix->pixelformat ||\r\nV4L2_PIX_FMT_UYVY == pix->pixelformat)\r\nps = 2;\r\nelse if (V4L2_PIX_FMT_RGB32 == pix->pixelformat)\r\nps = 4;\r\nelse if (V4L2_PIX_FMT_RGB24 == pix->pixelformat)\r\nps = 3;\r\nvout->ps = ps;\r\n*cropped_offset = (line_length * ps) *\r\ncrop->top + crop->left * ps;\r\n}\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "%s Offset:%x\n",\r\n__func__, vout->cropped_offset);\r\nreturn 0;\r\n}\r\nstatic int video_mode_to_dss_mode(struct omap_vout_device *vout)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct v4l2_pix_format *pix = &vout->pix;\r\nenum omap_color_mode mode;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_YUYV:\r\nmode = OMAP_DSS_COLOR_YUV2;\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\nmode = OMAP_DSS_COLOR_UYVY;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nmode = OMAP_DSS_COLOR_RGB16;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nmode = OMAP_DSS_COLOR_RGB24P;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB32:\r\nmode = (ovl->id == OMAP_DSS_VIDEO1) ?\r\nOMAP_DSS_COLOR_RGB24U : OMAP_DSS_COLOR_ARGB32;\r\nbreak;\r\ncase V4L2_PIX_FMT_BGR32:\r\nmode = OMAP_DSS_COLOR_RGBX32;\r\nbreak;\r\ndefault:\r\nmode = -EINVAL;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic int omapvid_setup_overlay(struct omap_vout_device *vout,\r\nstruct omap_overlay *ovl, int posx, int posy, int outw,\r\nint outh, u32 addr)\r\n{\r\nint ret = 0;\r\nstruct omap_overlay_info info;\r\nint cropheight, cropwidth, pixheight, pixwidth;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0 &&\r\n(outw != vout->pix.width || outh != vout->pix.height)) {\r\nret = -EINVAL;\r\ngoto setup_ovl_err;\r\n}\r\nvout->dss_mode = video_mode_to_dss_mode(vout);\r\nif (vout->dss_mode == -EINVAL) {\r\nret = -EINVAL;\r\ngoto setup_ovl_err;\r\n}\r\nif (is_rotation_90_or_270(vout)) {\r\ncropheight = vout->crop.width;\r\ncropwidth = vout->crop.height;\r\npixheight = vout->pix.width;\r\npixwidth = vout->pix.height;\r\n} else {\r\ncropheight = vout->crop.height;\r\ncropwidth = vout->crop.width;\r\npixheight = vout->pix.height;\r\npixwidth = vout->pix.width;\r\n}\r\novl->get_overlay_info(ovl, &info);\r\ninfo.paddr = addr;\r\ninfo.width = cropwidth;\r\ninfo.height = cropheight;\r\ninfo.color_mode = vout->dss_mode;\r\ninfo.mirror = vout->mirror;\r\ninfo.pos_x = posx;\r\ninfo.pos_y = posy;\r\ninfo.out_width = outw;\r\ninfo.out_height = outh;\r\ninfo.global_alpha = vout->win.global_alpha;\r\nif (!is_rotation_enabled(vout)) {\r\ninfo.rotation = 0;\r\ninfo.rotation_type = OMAP_DSS_ROT_DMA;\r\ninfo.screen_width = pixwidth;\r\n} else {\r\ninfo.rotation = vout->rotation;\r\ninfo.rotation_type = OMAP_DSS_ROT_VRFB;\r\ninfo.screen_width = 2048;\r\n}\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\r\n"%s enable=%d addr=%x width=%d\n height=%d color_mode=%d\n"\r\n"rotation=%d mirror=%d posx=%d posy=%d out_width = %d \n"\r\n"out_height=%d rotation_type=%d screen_width=%d\n",\r\n__func__, ovl->is_enabled(ovl), info.paddr, info.width, info.height,\r\ninfo.color_mode, info.rotation, info.mirror, info.pos_x,\r\ninfo.pos_y, info.out_width, info.out_height, info.rotation_type,\r\ninfo.screen_width);\r\nret = ovl->set_overlay_info(ovl, &info);\r\nif (ret)\r\ngoto setup_ovl_err;\r\nreturn 0;\r\nsetup_ovl_err:\r\nv4l2_warn(&vout->vid_dev->v4l2_dev, "setup_overlay failed\n");\r\nreturn ret;\r\n}\r\nstatic int omapvid_init(struct omap_vout_device *vout, u32 addr)\r\n{\r\nint ret = 0, i;\r\nstruct v4l2_window *win;\r\nstruct omap_overlay *ovl;\r\nint posx, posy, outw, outh, temp;\r\nstruct omap_video_timings *timing;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nwin = &vout->win;\r\nfor (i = 0; i < ovid->num_overlays; i++) {\r\nstruct omap_dss_device *dssdev;\r\novl = ovid->overlays[i];\r\ndssdev = ovl->get_device(ovl);\r\nif (!dssdev)\r\nreturn -EINVAL;\r\ntiming = &dssdev->panel.timings;\r\noutw = win->w.width;\r\nouth = win->w.height;\r\nswitch (vout->rotation) {\r\ncase dss_rotation_90_degree:\r\ntemp = outw;\r\noutw = outh;\r\nouth = temp;\r\nposy = (timing->y_res - win->w.width) - win->w.left;\r\nposx = win->w.top;\r\nbreak;\r\ncase dss_rotation_180_degree:\r\nposx = (timing->x_res - win->w.width) - win->w.left;\r\nposy = (timing->y_res - win->w.height) - win->w.top;\r\nbreak;\r\ncase dss_rotation_270_degree:\r\ntemp = outw;\r\noutw = outh;\r\nouth = temp;\r\nposy = win->w.left;\r\nposx = (timing->x_res - win->w.height) - win->w.top;\r\nbreak;\r\ndefault:\r\nposx = win->w.left;\r\nposy = win->w.top;\r\nbreak;\r\n}\r\nret = omapvid_setup_overlay(vout, ovl, posx, posy,\r\noutw, outh, addr);\r\nif (ret)\r\ngoto omapvid_init_err;\r\n}\r\nreturn 0;\r\nomapvid_init_err:\r\nv4l2_warn(&vout->vid_dev->v4l2_dev, "apply_changes failed\n");\r\nreturn ret;\r\n}\r\nstatic int omapvid_apply_changes(struct omap_vout_device *vout)\r\n{\r\nint i;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nfor (i = 0; i < ovid->num_overlays; i++) {\r\nstruct omap_dss_device *dssdev;\r\novl = ovid->overlays[i];\r\ndssdev = ovl->get_device(ovl);\r\nif (!dssdev)\r\nreturn -EINVAL;\r\novl->manager->apply(ovl->manager);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapvid_handle_interlace_display(struct omap_vout_device *vout,\r\nunsigned int irqstatus, struct timeval timevalue)\r\n{\r\nu32 fid;\r\nif (vout->first_int) {\r\nvout->first_int = 0;\r\ngoto err;\r\n}\r\nif (irqstatus & DISPC_IRQ_EVSYNC_ODD)\r\nfid = 1;\r\nelse if (irqstatus & DISPC_IRQ_EVSYNC_EVEN)\r\nfid = 0;\r\nelse\r\ngoto err;\r\nvout->field_id ^= 1;\r\nif (fid != vout->field_id) {\r\nif (fid == 0)\r\nvout->field_id = fid;\r\n} else if (0 == fid) {\r\nif (vout->cur_frm == vout->next_frm)\r\ngoto err;\r\nvout->cur_frm->ts = timevalue;\r\nvout->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&vout->cur_frm->done);\r\nvout->cur_frm = vout->next_frm;\r\n} else {\r\nif (list_empty(&vout->dma_queue) ||\r\n(vout->cur_frm != vout->next_frm))\r\ngoto err;\r\n}\r\nreturn vout->field_id;\r\nerr:\r\nreturn 0;\r\n}\r\nstatic void omap_vout_isr(void *arg, unsigned int irqstatus)\r\n{\r\nint ret, fid, mgr_id;\r\nu32 addr, irq;\r\nstruct omap_overlay *ovl;\r\nstruct timeval timevalue;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_dss_device *cur_display;\r\nstruct omap_vout_device *vout = (struct omap_vout_device *)arg;\r\nif (!vout->streaming)\r\nreturn;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nmgr_id = ovl->manager->id;\r\ncur_display = ovl->get_device(ovl);\r\nif (!cur_display)\r\nreturn;\r\nspin_lock(&vout->vbq_lock);\r\nv4l2_get_timestamp(&timevalue);\r\nswitch (cur_display->type) {\r\ncase OMAP_DISPLAY_TYPE_DSI:\r\ncase OMAP_DISPLAY_TYPE_DPI:\r\nif (mgr_id == OMAP_DSS_CHANNEL_LCD)\r\nirq = DISPC_IRQ_VSYNC;\r\nelse if (mgr_id == OMAP_DSS_CHANNEL_LCD2)\r\nirq = DISPC_IRQ_VSYNC2;\r\nelse\r\ngoto vout_isr_err;\r\nif (!(irqstatus & irq))\r\ngoto vout_isr_err;\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_VENC:\r\nfid = omapvid_handle_interlace_display(vout, irqstatus,\r\ntimevalue);\r\nif (!fid)\r\ngoto vout_isr_err;\r\nbreak;\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\nif (!(irqstatus & DISPC_IRQ_EVSYNC_EVEN))\r\ngoto vout_isr_err;\r\nbreak;\r\ndefault:\r\ngoto vout_isr_err;\r\n}\r\nif (!vout->first_int && (vout->cur_frm != vout->next_frm)) {\r\nvout->cur_frm->ts = timevalue;\r\nvout->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&vout->cur_frm->done);\r\nvout->cur_frm = vout->next_frm;\r\n}\r\nvout->first_int = 0;\r\nif (list_empty(&vout->dma_queue))\r\ngoto vout_isr_err;\r\nvout->next_frm = list_entry(vout->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&vout->next_frm->queue);\r\nvout->next_frm->state = VIDEOBUF_ACTIVE;\r\naddr = (unsigned long) vout->queued_buf_addr[vout->next_frm->i]\r\n+ vout->cropped_offset;\r\nret = omapvid_init(vout, addr);\r\nif (ret) {\r\nprintk(KERN_ERR VOUT_NAME\r\n"failed to set overlay info\n");\r\ngoto vout_isr_err;\r\n}\r\nret = omapvid_apply_changes(vout);\r\nif (ret)\r\nprintk(KERN_ERR VOUT_NAME "failed to change mode\n");\r\nvout_isr_err:\r\nspin_unlock(&vout->vbq_lock);\r\n}\r\nstatic int omap_vout_buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nint startindex = 0, i, j;\r\nu32 phy_addr = 0, virt_addr = 0;\r\nstruct omap_vout_device *vout = q->priv_data;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nint vid_max_buf_size;\r\nif (!vout)\r\nreturn -EINVAL;\r\nvid_max_buf_size = vout->vid == OMAP_VIDEO1 ? video1_bufsize :\r\nvideo2_bufsize;\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != q->type)\r\nreturn -EINVAL;\r\nstartindex = (vout->vid == OMAP_VIDEO1) ?\r\nvideo1_numbuffers : video2_numbuffers;\r\nif (V4L2_MEMORY_MMAP == vout->memory && *count < startindex)\r\n*count = startindex;\r\nif (ovid->rotation_type == VOUT_ROT_VRFB) {\r\nif (omap_vout_vrfb_buffer_setup(vout, count, startindex))\r\nreturn -ENOMEM;\r\n}\r\nif (V4L2_MEMORY_MMAP != vout->memory)\r\nreturn 0;\r\n*size = PAGE_ALIGN(vout->pix.width * vout->pix.height * vout->bpp);\r\nstartindex = (vout->vid == OMAP_VIDEO1) ?\r\nvideo1_numbuffers : video2_numbuffers;\r\nif (*size > vid_max_buf_size) {\r\nv4l2_err(&vout->vid_dev->v4l2_dev,\r\n"buffer allocation mismatch [%u] [%u]\n",\r\n*size, vout->buffer_size);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = startindex; i < *count; i++) {\r\nvout->buffer_size = *size;\r\nvirt_addr = omap_vout_alloc_buffer(vout->buffer_size,\r\n&phy_addr);\r\nif (!virt_addr) {\r\nif (ovid->rotation_type == VOUT_ROT_NONE) {\r\nbreak;\r\n} else {\r\nif (!is_rotation_enabled(vout))\r\nbreak;\r\nfor (j = i; j < *count; j++) {\r\nomap_vout_free_buffer(\r\nvout->smsshado_virt_addr[j],\r\nvout->smsshado_size);\r\nvout->smsshado_virt_addr[j] = 0;\r\nvout->smsshado_phy_addr[j] = 0;\r\n}\r\n}\r\n}\r\nvout->buf_virt_addr[i] = virt_addr;\r\nvout->buf_phy_addr[i] = phy_addr;\r\n}\r\n*count = vout->buffer_allocated = i;\r\nreturn 0;\r\n}\r\nstatic void omap_vout_free_extra_buffers(struct omap_vout_device *vout)\r\n{\r\nint num_buffers = 0, i;\r\nnum_buffers = (vout->vid == OMAP_VIDEO1) ?\r\nvideo1_numbuffers : video2_numbuffers;\r\nfor (i = num_buffers; i < vout->buffer_allocated; i++) {\r\nif (vout->buf_virt_addr[i])\r\nomap_vout_free_buffer(vout->buf_virt_addr[i],\r\nvout->buffer_size);\r\nvout->buf_virt_addr[i] = 0;\r\nvout->buf_phy_addr[i] = 0;\r\n}\r\nvout->buffer_allocated = num_buffers;\r\n}\r\nstatic int omap_vout_buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct omap_vout_device *vout = q->priv_data;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->width = vout->pix.width;\r\nvb->height = vout->pix.height;\r\nvb->size = vb->width * vb->height * vout->bpp;\r\nvb->field = field;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nif (V4L2_MEMORY_USERPTR == vb->memory) {\r\nif (0 == vb->baddr)\r\nreturn -EINVAL;\r\nvout->queued_buf_addr[vb->i] = (u8 *)\r\nomap_vout_uservirt_to_phys(vb->baddr);\r\n} else {\r\nu32 addr, dma_addr;\r\nunsigned long size;\r\naddr = (unsigned long) vout->buf_virt_addr[vb->i];\r\nsize = (unsigned long) vb->size;\r\ndma_addr = dma_map_single(vout->vid_dev->v4l2_dev.dev, (void *) addr,\r\nsize, DMA_TO_DEVICE);\r\nif (dma_mapping_error(vout->vid_dev->v4l2_dev.dev, dma_addr))\r\nv4l2_err(&vout->vid_dev->v4l2_dev, "dma_map_single failed\n");\r\nvout->queued_buf_addr[vb->i] = (u8 *)vout->buf_phy_addr[vb->i];\r\n}\r\nif (ovid->rotation_type == VOUT_ROT_VRFB)\r\nreturn omap_vout_prepare_vrfb(vout, vb);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void omap_vout_buffer_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct omap_vout_device *vout = q->priv_data;\r\nlist_add_tail(&vb->queue, &vout->dma_queue);\r\nvb->state = VIDEOBUF_QUEUED;\r\n}\r\nstatic void omap_vout_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct omap_vout_device *vout = q->priv_data;\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\nif (V4L2_MEMORY_MMAP != vout->memory)\r\nreturn;\r\n}\r\nstatic unsigned int omap_vout_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct omap_vout_device *vout = file->private_data;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nreturn videobuf_poll_stream(file, q, wait);\r\n}\r\nstatic void omap_vout_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct omap_vout_device *vout = vma->vm_private_data;\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\r\n"vm_open [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);\r\nvout->mmap_count++;\r\n}\r\nstatic void omap_vout_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct omap_vout_device *vout = vma->vm_private_data;\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\r\n"vm_close [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);\r\nvout->mmap_count--;\r\n}\r\nstatic int omap_vout_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nint i;\r\nvoid *pos;\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = (vma->vm_end - vma->vm_start);\r\nstruct omap_vout_device *vout = file->private_data;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\r\n" %s pgoff=0x%lx, start=0x%lx, end=0x%lx\n", __func__,\r\nvma->vm_pgoff, vma->vm_start, vma->vm_end);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nif (V4L2_MEMORY_MMAP != q->bufs[i]->memory)\r\ncontinue;\r\nif (q->bufs[i]->boff == (vma->vm_pgoff << PAGE_SHIFT))\r\nbreak;\r\n}\r\nif (VIDEO_MAX_FRAME == i) {\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev,\r\n"offset invalid [offset=0x%lx]\n",\r\n(vma->vm_pgoff << PAGE_SHIFT));\r\nreturn -EINVAL;\r\n}\r\nif (size > vout->buffer_size) {\r\nv4l2_err(&vout->vid_dev->v4l2_dev,\r\n"insufficient memory [%lu] [%u]\n",\r\nsize, vout->buffer_size);\r\nreturn -ENOMEM;\r\n}\r\nq->bufs[i]->baddr = vma->vm_start;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\r\nvma->vm_ops = &omap_vout_vm_ops;\r\nvma->vm_private_data = (void *) vout;\r\npos = (void *)vout->buf_virt_addr[i];\r\nvma->vm_pgoff = virt_to_phys((void *)pos) >> PAGE_SHIFT;\r\nwhile (size > 0) {\r\nunsigned long pfn;\r\npfn = virt_to_phys((void *) pos) >> PAGE_SHIFT;\r\nif (remap_pfn_range(vma, start, pfn, PAGE_SIZE, PAGE_SHARED))\r\nreturn -EAGAIN;\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvout->mmap_count++;\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "Exiting %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int omap_vout_release(struct file *file)\r\n{\r\nunsigned int ret, i;\r\nstruct videobuf_queue *q;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout = file->private_data;\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "Entering %s\n", __func__);\r\novid = &vout->vid_info;\r\nif (!vout)\r\nreturn 0;\r\nq = &vout->vbq;\r\nfor (i = 0; i < ovid->num_overlays; i++) {\r\nstruct omap_overlay *ovl = ovid->overlays[i];\r\nstruct omap_dss_device *dssdev = ovl->get_device(ovl);\r\nif (dssdev)\r\novl->disable(ovl);\r\n}\r\nret = omapvid_apply_changes(vout);\r\nif (ret)\r\nv4l2_warn(&vout->vid_dev->v4l2_dev,\r\n"Unable to apply changes\n");\r\nomap_vout_free_extra_buffers(vout);\r\nif (ovid->rotation_type == VOUT_ROT_VRFB) {\r\nif (!vout->vrfb_static_allocation)\r\nomap_vout_free_vrfb_buffers(vout);\r\n}\r\nvideobuf_mmap_free(q);\r\nif (vout->streaming) {\r\nu32 mask = 0;\r\nmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN |\r\nDISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_VSYNC2;\r\nomap_dispc_unregister_isr(omap_vout_isr, vout, mask);\r\nvout->streaming = 0;\r\nvideobuf_streamoff(q);\r\nvideobuf_queue_cancel(q);\r\n}\r\nif (vout->mmap_count != 0)\r\nvout->mmap_count = 0;\r\nvout->opened -= 1;\r\nfile->private_data = NULL;\r\nif (vout->buffer_allocated)\r\nvideobuf_mmap_free(q);\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "Exiting %s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int omap_vout_open(struct file *file)\r\n{\r\nstruct videobuf_queue *q;\r\nstruct omap_vout_device *vout = NULL;\r\nvout = video_drvdata(file);\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "Entering %s\n", __func__);\r\nif (vout == NULL)\r\nreturn -ENODEV;\r\nif (vout->opened)\r\nreturn -EBUSY;\r\nvout->opened += 1;\r\nfile->private_data = vout;\r\nvout->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq = &vout->vbq;\r\nvideo_vbq_ops.buf_setup = omap_vout_buffer_setup;\r\nvideo_vbq_ops.buf_prepare = omap_vout_buffer_prepare;\r\nvideo_vbq_ops.buf_release = omap_vout_buffer_release;\r\nvideo_vbq_ops.buf_queue = omap_vout_buffer_queue;\r\nspin_lock_init(&vout->vbq_lock);\r\nvideobuf_queue_dma_contig_init(q, &video_vbq_ops, q->dev,\r\n&vout->vbq_lock, vout->type, V4L2_FIELD_NONE,\r\nsizeof(struct videobuf_buffer), vout, NULL);\r\nv4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "Exiting %s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nstrlcpy(cap->driver, VOUT_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, vout->vfd->name, sizeof(cap->card));\r\ncap->bus_info[0] = '\0';\r\ncap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT |\r\nV4L2_CAP_VIDEO_OUTPUT_OVERLAY;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nint index = fmt->index;\r\nif (index >= NUM_OUTPUT_FORMATS)\r\nreturn -EINVAL;\r\nfmt->flags = omap_formats[index].flags;\r\nstrlcpy(fmt->description, omap_formats[index].description,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = omap_formats[index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nf->fmt.pix = vout->pix;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_video_timings *timing;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_dss_device *dssdev;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\ndssdev = ovl->get_device(ovl);\r\nif (!dssdev)\r\nreturn -EINVAL;\r\ntiming = &dssdev->panel.timings;\r\nvout->fbuf.fmt.height = timing->y_res;\r\nvout->fbuf.fmt.width = timing->x_res;\r\nomap_vout_try_format(&f->fmt.pix);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nint ret, bpp;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_video_timings *timing;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_dss_device *dssdev;\r\nif (vout->streaming)\r\nreturn -EBUSY;\r\nmutex_lock(&vout->lock);\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\ndssdev = ovl->get_device(ovl);\r\nif (!dssdev) {\r\nret = -EINVAL;\r\ngoto s_fmt_vid_out_exit;\r\n}\r\ntiming = &dssdev->panel.timings;\r\nif ((is_rotation_enabled(vout)) &&\r\nf->fmt.pix.pixelformat == V4L2_PIX_FMT_RGB24) {\r\nret = -EINVAL;\r\ngoto s_fmt_vid_out_exit;\r\n}\r\nif (is_rotation_90_or_270(vout)) {\r\nvout->fbuf.fmt.height = timing->x_res;\r\nvout->fbuf.fmt.width = timing->y_res;\r\n} else {\r\nvout->fbuf.fmt.height = timing->y_res;\r\nvout->fbuf.fmt.width = timing->x_res;\r\n}\r\nbpp = omap_vout_try_format(&f->fmt.pix);\r\nf->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height * bpp;\r\nvout->bpp = bpp;\r\nvout->pix = f->fmt.pix;\r\nvout->vrfb_bpp = 1;\r\nif (V4L2_PIX_FMT_YUYV == vout->pix.pixelformat ||\r\nV4L2_PIX_FMT_UYVY == vout->pix.pixelformat)\r\nvout->vrfb_bpp = 2;\r\nomap_vout_new_format(&vout->pix, &vout->fbuf, &vout->crop, &vout->win);\r\nret = 0;\r\ns_fmt_vid_out_exit:\r\nmutex_unlock(&vout->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_try_fmt_vid_overlay(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nint ret = 0;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct v4l2_window *win = &f->fmt.win;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nret = omap_vout_try_window(&vout->fbuf, win);\r\nif (!ret) {\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\r\nwin->global_alpha = 255;\r\nelse\r\nwin->global_alpha = f->fmt.win.global_alpha;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_fmt_vid_overlay(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nint ret = 0;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout = fh;\r\nstruct v4l2_window *win = &f->fmt.win;\r\nmutex_lock(&vout->lock);\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nret = omap_vout_new_window(&vout->crop, &vout->win, &vout->fbuf, win);\r\nif (!ret) {\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\r\nvout->win.global_alpha = 255;\r\nelse\r\nvout->win.global_alpha = f->fmt.win.global_alpha;\r\nvout->win.chromakey = f->fmt.win.chromakey;\r\n}\r\nmutex_unlock(&vout->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_fmt_vid_overlay(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nu32 key_value = 0;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_overlay_manager_info info;\r\nstruct v4l2_window *win = &f->fmt.win;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nwin->w = vout->win.w;\r\nwin->field = vout->win.field;\r\nwin->global_alpha = vout->win.global_alpha;\r\nif (ovl->manager && ovl->manager->get_manager_info) {\r\novl->manager->get_manager_info(ovl->manager, &info);\r\nkey_value = info.trans_key;\r\n}\r\nwin->chromakey = key_value;\r\nreturn 0;\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *fh,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nstruct v4l2_pix_format *pix = &vout->pix;\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\ncropcap->bounds.width = pix->width & ~1;\r\ncropcap->bounds.height = pix->height & ~1;\r\nomap_vout_default_crop(&vout->pix, &vout->fbuf, &cropcap->defrect);\r\ncropcap->pixelaspect.numerator = 1;\r\ncropcap->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\ncrop->c = vout->crop;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_crop(struct file *file, void *fh, const struct v4l2_crop *crop)\r\n{\r\nint ret = -EINVAL;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_overlay *ovl;\r\nstruct omap_video_timings *timing;\r\nstruct omap_dss_device *dssdev;\r\nif (vout->streaming)\r\nreturn -EBUSY;\r\nmutex_lock(&vout->lock);\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\ndssdev = ovl->get_device(ovl);\r\nif (!dssdev) {\r\nret = -EINVAL;\r\ngoto s_crop_err;\r\n}\r\ntiming = &dssdev->panel.timings;\r\nif (is_rotation_90_or_270(vout)) {\r\nvout->fbuf.fmt.height = timing->x_res;\r\nvout->fbuf.fmt.width = timing->y_res;\r\n} else {\r\nvout->fbuf.fmt.height = timing->y_res;\r\nvout->fbuf.fmt.width = timing->x_res;\r\n}\r\nif (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nret = omap_vout_new_crop(&vout->pix, &vout->crop, &vout->win,\r\n&vout->fbuf, &crop->c);\r\ns_crop_err:\r\nmutex_unlock(&vout->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh,\r\nstruct v4l2_queryctrl *ctrl)\r\n{\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ROTATE:\r\nret = v4l2_ctrl_query_fill(ctrl, 0, 270, 90, 0);\r\nbreak;\r\ncase V4L2_CID_BG_COLOR:\r\nret = v4l2_ctrl_query_fill(ctrl, 0, 0xFFFFFF, 1, 0);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nret = v4l2_ctrl_query_fill(ctrl, 0, 1, 1, 0);\r\nbreak;\r\ndefault:\r\nctrl->name[0] = '\0';\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)\r\n{\r\nint ret = 0;\r\nstruct omap_vout_device *vout = fh;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ROTATE:\r\nctrl->value = vout->control[0].value;\r\nbreak;\r\ncase V4L2_CID_BG_COLOR:\r\n{\r\nstruct omap_overlay_manager_info info;\r\nstruct omap_overlay *ovl;\r\novl = vout->vid_info.overlays[0];\r\nif (!ovl->manager || !ovl->manager->get_manager_info) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\novl->manager->get_manager_info(ovl->manager, &info);\r\nctrl->value = info.default_color;\r\nbreak;\r\n}\r\ncase V4L2_CID_VFLIP:\r\nctrl->value = vout->control[2].value;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)\r\n{\r\nint ret = 0;\r\nstruct omap_vout_device *vout = fh;\r\nswitch (a->id) {\r\ncase V4L2_CID_ROTATE:\r\n{\r\nstruct omapvideo_info *ovid;\r\nint rotation = a->value;\r\novid = &vout->vid_info;\r\nmutex_lock(&vout->lock);\r\nif (rotation && ovid->rotation_type == VOUT_ROT_NONE) {\r\nmutex_unlock(&vout->lock);\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nif (rotation && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {\r\nmutex_unlock(&vout->lock);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (v4l2_rot_to_dss_rot(rotation, &vout->rotation,\r\nvout->mirror)) {\r\nmutex_unlock(&vout->lock);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvout->control[0].value = rotation;\r\nmutex_unlock(&vout->lock);\r\nbreak;\r\n}\r\ncase V4L2_CID_BG_COLOR:\r\n{\r\nstruct omap_overlay *ovl;\r\nunsigned int color = a->value;\r\nstruct omap_overlay_manager_info info;\r\novl = vout->vid_info.overlays[0];\r\nmutex_lock(&vout->lock);\r\nif (!ovl->manager || !ovl->manager->get_manager_info) {\r\nmutex_unlock(&vout->lock);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\novl->manager->get_manager_info(ovl->manager, &info);\r\ninfo.default_color = color;\r\nif (ovl->manager->set_manager_info(ovl->manager, &info)) {\r\nmutex_unlock(&vout->lock);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvout->control[1].value = color;\r\nmutex_unlock(&vout->lock);\r\nbreak;\r\n}\r\ncase V4L2_CID_VFLIP:\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nunsigned int mirror = a->value;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nmutex_lock(&vout->lock);\r\nif (mirror && ovid->rotation_type == VOUT_ROT_NONE) {\r\nmutex_unlock(&vout->lock);\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nif (mirror && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {\r\nmutex_unlock(&vout->lock);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvout->mirror = mirror;\r\nvout->control[2].value = mirror;\r\nmutex_unlock(&vout->lock);\r\nbreak;\r\n}\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nint ret = 0;\r\nunsigned int i, num_buffers = 0;\r\nstruct omap_vout_device *vout = fh;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nif ((req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) || (req->count < 0))\r\nreturn -EINVAL;\r\nif ((V4L2_MEMORY_MMAP != req->memory) &&\r\n(V4L2_MEMORY_USERPTR != req->memory))\r\nreturn -EINVAL;\r\nmutex_lock(&vout->lock);\r\nif (vout->streaming) {\r\nret = -EBUSY;\r\ngoto reqbuf_err;\r\n}\r\nif (q->bufs[0] && (V4L2_MEMORY_MMAP == q->bufs[0]->memory)) {\r\nif (vout->mmap_count) {\r\nret = -EBUSY;\r\ngoto reqbuf_err;\r\n}\r\nnum_buffers = (vout->vid == OMAP_VIDEO1) ?\r\nvideo1_numbuffers : video2_numbuffers;\r\nfor (i = num_buffers; i < vout->buffer_allocated; i++) {\r\nomap_vout_free_buffer(vout->buf_virt_addr[i],\r\nvout->buffer_size);\r\nvout->buf_virt_addr[i] = 0;\r\nvout->buf_phy_addr[i] = 0;\r\n}\r\nvout->buffer_allocated = num_buffers;\r\nvideobuf_mmap_free(q);\r\n} else if (q->bufs[0] && (V4L2_MEMORY_USERPTR == q->bufs[0]->memory)) {\r\nif (vout->buffer_allocated) {\r\nvideobuf_mmap_free(q);\r\nfor (i = 0; i < vout->buffer_allocated; i++) {\r\nkfree(q->bufs[i]);\r\nq->bufs[i] = NULL;\r\n}\r\nvout->buffer_allocated = 0;\r\n}\r\n}\r\nvout->memory = req->memory;\r\nINIT_LIST_HEAD(&vout->dma_queue);\r\nret = videobuf_reqbufs(q, req);\r\nif (ret < 0)\r\ngoto reqbuf_err;\r\nvout->buffer_allocated = req->count;\r\nreqbuf_err:\r\nmutex_unlock(&vout->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nreturn videobuf_querybuf(&vout->vbq, b);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *buffer)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nif ((V4L2_BUF_TYPE_VIDEO_OUTPUT != buffer->type) ||\r\n(buffer->index >= vout->buffer_allocated) ||\r\n(q->bufs[buffer->index]->memory != buffer->memory)) {\r\nreturn -EINVAL;\r\n}\r\nif (V4L2_MEMORY_USERPTR == buffer->memory) {\r\nif ((buffer->length < vout->pix.sizeimage) ||\r\n(0 == buffer->m.userptr)) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((is_rotation_enabled(vout)) &&\r\nvout->vrfb_dma_tx.req_status == DMA_CHAN_NOT_ALLOTED) {\r\nv4l2_warn(&vout->vid_dev->v4l2_dev,\r\n"DMA Channel not allocated for Rotation\n");\r\nreturn -EINVAL;\r\n}\r\nreturn videobuf_qbuf(q, buffer);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct omap_vout_device *vout = fh;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nint ret;\r\nu32 addr;\r\nunsigned long size;\r\nstruct videobuf_buffer *vb;\r\nvb = q->bufs[b->index];\r\nif (!vout->streaming)\r\nreturn -EINVAL;\r\nif (file->f_flags & O_NONBLOCK)\r\nret = videobuf_dqbuf(q, (struct v4l2_buffer *)b, 1);\r\nelse\r\nret = videobuf_dqbuf(q, (struct v4l2_buffer *)b, 0);\r\naddr = (unsigned long) vout->buf_phy_addr[vb->i];\r\nsize = (unsigned long) vb->size;\r\ndma_unmap_single(vout->vid_dev->v4l2_dev.dev, addr,\r\nsize, DMA_TO_DEVICE);\r\nreturn ret;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nint ret = 0, j;\r\nu32 addr = 0, mask = 0;\r\nstruct omap_vout_device *vout = fh;\r\nstruct videobuf_queue *q = &vout->vbq;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nmutex_lock(&vout->lock);\r\nif (vout->streaming) {\r\nret = -EBUSY;\r\ngoto streamon_err;\r\n}\r\nret = videobuf_streamon(q);\r\nif (ret)\r\ngoto streamon_err;\r\nif (list_empty(&vout->dma_queue)) {\r\nret = -EIO;\r\ngoto streamon_err1;\r\n}\r\nvout->next_frm = vout->cur_frm = list_entry(vout->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&vout->cur_frm->queue);\r\nvout->cur_frm->state = VIDEOBUF_ACTIVE;\r\nvout->field_id = 0;\r\nvout->streaming = 1;\r\nvout->first_int = 1;\r\nif (omap_vout_calculate_offset(vout)) {\r\nret = -EINVAL;\r\ngoto streamon_err1;\r\n}\r\naddr = (unsigned long) vout->queued_buf_addr[vout->cur_frm->i]\r\n+ vout->cropped_offset;\r\nmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD\r\n| DISPC_IRQ_VSYNC2;\r\nret = omapvid_init(vout, addr);\r\nif (ret) {\r\nv4l2_err(&vout->vid_dev->v4l2_dev,\r\n"failed to set overlay info\n");\r\ngoto streamon_err1;\r\n}\r\nomap_dispc_register_isr(omap_vout_isr, vout, mask);\r\nret = omapvid_apply_changes(vout);\r\nif (ret)\r\nv4l2_err(&vout->vid_dev->v4l2_dev, "failed to change mode\n");\r\nfor (j = 0; j < ovid->num_overlays; j++) {\r\nstruct omap_overlay *ovl = ovid->overlays[j];\r\nstruct omap_dss_device *dssdev = ovl->get_device(ovl);\r\nif (dssdev) {\r\nret = ovl->enable(ovl);\r\nif (ret)\r\ngoto streamon_err1;\r\n}\r\n}\r\nret = 0;\r\nstreamon_err1:\r\nif (ret)\r\nret = videobuf_streamoff(q);\r\nstreamon_err:\r\nmutex_unlock(&vout->lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nu32 mask = 0;\r\nint ret = 0, j;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omapvideo_info *ovid = &vout->vid_info;\r\nif (!vout->streaming)\r\nreturn -EINVAL;\r\nvout->streaming = 0;\r\nmask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD\r\n| DISPC_IRQ_VSYNC2;\r\nomap_dispc_unregister_isr(omap_vout_isr, vout, mask);\r\nfor (j = 0; j < ovid->num_overlays; j++) {\r\nstruct omap_overlay *ovl = ovid->overlays[j];\r\nstruct omap_dss_device *dssdev = ovl->get_device(ovl);\r\nif (dssdev)\r\novl->disable(ovl);\r\n}\r\nret = omapvid_apply_changes(vout);\r\nif (ret)\r\nv4l2_err(&vout->vid_dev->v4l2_dev, "failed to change mode in"\r\n" streamoff\n");\r\nINIT_LIST_HEAD(&vout->dma_queue);\r\nret = videobuf_streamoff(&vout->vbq);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_fbuf(struct file *file, void *fh,\r\nconst struct v4l2_framebuffer *a)\r\n{\r\nint enable = 0;\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_overlay_manager_info info;\r\nenum omap_dss_trans_key_type key_type = OMAP_DSS_COLOR_KEY_GFX_DST;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\nif ((a->flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY) &&\r\n(a->flags & V4L2_FBUF_FLAG_CHROMAKEY))\r\nreturn -EINVAL;\r\nif ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY) &&\r\n(a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA))\r\nreturn -EINVAL;\r\nif ((a->flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY)) {\r\nvout->fbuf.flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;\r\nkey_type = OMAP_DSS_COLOR_KEY_VID_SRC;\r\n} else\r\nvout->fbuf.flags &= ~V4L2_FBUF_FLAG_SRC_CHROMAKEY;\r\nif ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY)) {\r\nvout->fbuf.flags |= V4L2_FBUF_FLAG_CHROMAKEY;\r\nkey_type = OMAP_DSS_COLOR_KEY_GFX_DST;\r\n} else\r\nvout->fbuf.flags &= ~V4L2_FBUF_FLAG_CHROMAKEY;\r\nif (a->flags & (V4L2_FBUF_FLAG_CHROMAKEY |\r\nV4L2_FBUF_FLAG_SRC_CHROMAKEY))\r\nenable = 1;\r\nelse\r\nenable = 0;\r\nif (ovl->manager && ovl->manager->get_manager_info &&\r\novl->manager->set_manager_info) {\r\novl->manager->get_manager_info(ovl->manager, &info);\r\ninfo.trans_enabled = enable;\r\ninfo.trans_key_type = key_type;\r\ninfo.trans_key = vout->win.chromakey;\r\nif (ovl->manager->set_manager_info(ovl->manager, &info))\r\nreturn -EINVAL;\r\n}\r\nif (a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA) {\r\nvout->fbuf.flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\r\nenable = 1;\r\n} else {\r\nvout->fbuf.flags &= ~V4L2_FBUF_FLAG_LOCAL_ALPHA;\r\nenable = 0;\r\n}\r\nif (ovl->manager && ovl->manager->get_manager_info &&\r\novl->manager->set_manager_info) {\r\novl->manager->get_manager_info(ovl->manager, &info);\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\r\ninfo.partial_alpha_enabled = enable;\r\nif (ovl->manager->set_manager_info(ovl->manager, &info))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fbuf(struct file *file, void *fh,\r\nstruct v4l2_framebuffer *a)\r\n{\r\nstruct omap_overlay *ovl;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout = fh;\r\nstruct omap_overlay_manager_info info;\r\novid = &vout->vid_info;\r\novl = ovid->overlays[0];\r\na->flags = V4L2_FBUF_FLAG_OVERLAY;\r\na->capability = V4L2_FBUF_CAP_LOCAL_ALPHA | V4L2_FBUF_CAP_CHROMAKEY\r\n| V4L2_FBUF_CAP_SRC_CHROMAKEY;\r\nif (ovl->manager && ovl->manager->get_manager_info) {\r\novl->manager->get_manager_info(ovl->manager, &info);\r\nif (info.trans_key_type == OMAP_DSS_COLOR_KEY_VID_SRC)\r\na->flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;\r\nif (info.trans_key_type == OMAP_DSS_COLOR_KEY_GFX_DST)\r\na->flags |= V4L2_FBUF_FLAG_CHROMAKEY;\r\n}\r\nif (ovl->manager && ovl->manager->get_manager_info) {\r\novl->manager->get_manager_info(ovl->manager, &info);\r\nif (info.partial_alpha_enabled)\r\na->flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init omap_vout_setup_video_data(struct omap_vout_device *vout)\r\n{\r\nstruct video_device *vfd;\r\nstruct v4l2_pix_format *pix;\r\nstruct v4l2_control *control;\r\nstruct omap_overlay *ovl = vout->vid_info.overlays[0];\r\nstruct omap_dss_device *display = ovl->get_device(ovl);\r\npix = &vout->pix;\r\npix->width = QQVGA_WIDTH;\r\npix->height = QQVGA_HEIGHT;\r\npix->pixelformat = V4L2_PIX_FMT_RGB565;\r\npix->field = V4L2_FIELD_ANY;\r\npix->bytesperline = pix->width * 2;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->priv = 0;\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\nvout->bpp = RGB565_BPP;\r\nvout->fbuf.fmt.width = display->panel.timings.x_res;\r\nvout->fbuf.fmt.height = display->panel.timings.y_res;\r\nvout->win.global_alpha = 255;\r\nvout->fbuf.flags = 0;\r\nvout->fbuf.capability = V4L2_FBUF_CAP_LOCAL_ALPHA |\r\nV4L2_FBUF_CAP_SRC_CHROMAKEY | V4L2_FBUF_CAP_CHROMAKEY;\r\nvout->win.chromakey = 0;\r\nomap_vout_new_format(pix, &vout->fbuf, &vout->crop, &vout->win);\r\ncontrol = vout->control;\r\ncontrol[0].id = V4L2_CID_ROTATE;\r\ncontrol[0].value = 0;\r\nvout->rotation = 0;\r\nvout->mirror = 0;\r\nvout->control[2].id = V4L2_CID_HFLIP;\r\nvout->control[2].value = 0;\r\nif (vout->vid_info.rotation_type == VOUT_ROT_VRFB)\r\nvout->vrfb_bpp = 2;\r\ncontrol[1].id = V4L2_CID_BG_COLOR;\r\ncontrol[1].value = 0;\r\nvfd = vout->vfd = video_device_alloc();\r\nif (!vfd) {\r\nprintk(KERN_ERR VOUT_NAME ": could not allocate"\r\n" video device struct\n");\r\nreturn -ENOMEM;\r\n}\r\nvfd->release = video_device_release;\r\nvfd->ioctl_ops = &vout_ioctl_ops;\r\nstrlcpy(vfd->name, VOUT_NAME, sizeof(vfd->name));\r\nvfd->fops = &omap_vout_fops;\r\nvfd->v4l2_dev = &vout->vid_dev->v4l2_dev;\r\nvfd->vfl_dir = VFL_DIR_TX;\r\nmutex_init(&vout->lock);\r\nvfd->minor = -1;\r\nreturn 0;\r\n}\r\nstatic int __init omap_vout_setup_video_bufs(struct platform_device *pdev,\r\nint vid_num)\r\n{\r\nu32 numbuffers;\r\nint ret = 0, i;\r\nstruct omapvideo_info *ovid;\r\nstruct omap_vout_device *vout;\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct omap2video_device *vid_dev =\r\ncontainer_of(v4l2_dev, struct omap2video_device, v4l2_dev);\r\nvout = vid_dev->vouts[vid_num];\r\novid = &vout->vid_info;\r\nnumbuffers = (vid_num == 0) ? video1_numbuffers : video2_numbuffers;\r\nvout->buffer_size = (vid_num == 0) ? video1_bufsize : video2_bufsize;\r\ndev_info(&pdev->dev, "Buffer Size = %d\n", vout->buffer_size);\r\nfor (i = 0; i < numbuffers; i++) {\r\nvout->buf_virt_addr[i] =\r\nomap_vout_alloc_buffer(vout->buffer_size,\r\n(u32 *) &vout->buf_phy_addr[i]);\r\nif (!vout->buf_virt_addr[i]) {\r\nnumbuffers = i;\r\nret = -ENOMEM;\r\ngoto free_buffers;\r\n}\r\n}\r\nvout->cropped_offset = 0;\r\nif (ovid->rotation_type == VOUT_ROT_VRFB) {\r\nint static_vrfb_allocation = (vid_num == 0) ?\r\nvid1_static_vrfb_alloc : vid2_static_vrfb_alloc;\r\nret = omap_vout_setup_vrfb_bufs(pdev, vid_num,\r\nstatic_vrfb_allocation);\r\n}\r\nreturn ret;\r\nfree_buffers:\r\nfor (i = 0; i < numbuffers; i++) {\r\nomap_vout_free_buffer(vout->buf_virt_addr[i],\r\nvout->buffer_size);\r\nvout->buf_virt_addr[i] = 0;\r\nvout->buf_phy_addr[i] = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init omap_vout_create_video_devices(struct platform_device *pdev)\r\n{\r\nint ret = 0, k;\r\nstruct omap_vout_device *vout;\r\nstruct video_device *vfd = NULL;\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct omap2video_device *vid_dev = container_of(v4l2_dev,\r\nstruct omap2video_device, v4l2_dev);\r\nfor (k = 0; k < pdev->num_resources; k++) {\r\nvout = kzalloc(sizeof(struct omap_vout_device), GFP_KERNEL);\r\nif (!vout) {\r\ndev_err(&pdev->dev, ": could not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvout->vid = k;\r\nvid_dev->vouts[k] = vout;\r\nvout->vid_dev = vid_dev;\r\nif (pdev->num_resources == 1)\r\nvout->vid_info.overlays[0] = vid_dev->overlays[k + 2];\r\nelse\r\nvout->vid_info.overlays[0] = vid_dev->overlays[k + 1];\r\nvout->vid_info.num_overlays = 1;\r\nvout->vid_info.id = k + 1;\r\nif (omap_vout_dss_omap24xx() || omap_vout_dss_omap34xx())\r\nvout->vid_info.rotation_type = VOUT_ROT_VRFB;\r\nif (omap_vout_setup_video_data(vout) != 0) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (omap_vout_setup_video_bufs(pdev, k) != 0) {\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nvfd = vout->vfd;\r\nif (video_register_device(vfd, VFL_TYPE_GRABBER, -1) < 0) {\r\ndev_err(&pdev->dev, ": Could not register "\r\n"Video for Linux device\n");\r\nvfd->minor = -1;\r\nret = -ENODEV;\r\ngoto error2;\r\n}\r\nvideo_set_drvdata(vfd, vout);\r\ndev_info(&pdev->dev, ": registered and initialized"\r\n" video device %d\n", vfd->minor);\r\nif (k == (pdev->num_resources - 1))\r\nreturn 0;\r\ncontinue;\r\nerror2:\r\nif (vout->vid_info.rotation_type == VOUT_ROT_VRFB)\r\nomap_vout_release_vrfb(vout);\r\nomap_vout_free_buffers(vout);\r\nerror1:\r\nvideo_device_release(vfd);\r\nerror:\r\nkfree(vout);\r\nreturn ret;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void omap_vout_cleanup_device(struct omap_vout_device *vout)\r\n{\r\nstruct video_device *vfd;\r\nstruct omapvideo_info *ovid;\r\nif (!vout)\r\nreturn;\r\nvfd = vout->vfd;\r\novid = &vout->vid_info;\r\nif (vfd) {\r\nif (!video_is_registered(vfd)) {\r\nvideo_device_release(vfd);\r\n} else {\r\nvideo_unregister_device(vfd);\r\n}\r\n}\r\nif (ovid->rotation_type == VOUT_ROT_VRFB) {\r\nomap_vout_release_vrfb(vout);\r\nif (vout->vrfb_static_allocation)\r\nomap_vout_free_vrfb_buffers(vout);\r\n}\r\nomap_vout_free_buffers(vout);\r\nkfree(vout);\r\n}\r\nstatic int omap_vout_remove(struct platform_device *pdev)\r\n{\r\nint k;\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct omap2video_device *vid_dev = container_of(v4l2_dev, struct\r\nomap2video_device, v4l2_dev);\r\nv4l2_device_unregister(v4l2_dev);\r\nfor (k = 0; k < pdev->num_resources; k++)\r\nomap_vout_cleanup_device(vid_dev->vouts[k]);\r\nfor (k = 0; k < vid_dev->num_displays; k++) {\r\nif (vid_dev->displays[k]->state != OMAP_DSS_DISPLAY_DISABLED)\r\nvid_dev->displays[k]->driver->disable(vid_dev->displays[k]);\r\nomap_dss_put_device(vid_dev->displays[k]);\r\n}\r\nkfree(vid_dev);\r\nreturn 0;\r\n}\r\nstatic int __init omap_vout_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0, i;\r\nstruct omap_overlay *ovl;\r\nstruct omap_dss_device *dssdev = NULL;\r\nstruct omap_dss_device *def_display;\r\nstruct omap2video_device *vid_dev = NULL;\r\nif (omapdss_is_initialized() == false)\r\nreturn -EPROBE_DEFER;\r\nret = omapdss_compat_init();\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to init dss\n");\r\nreturn ret;\r\n}\r\nif (pdev->num_resources == 0) {\r\ndev_err(&pdev->dev, "probed for an unknown device\n");\r\nret = -ENODEV;\r\ngoto err_dss_init;\r\n}\r\nvid_dev = kzalloc(sizeof(struct omap2video_device), GFP_KERNEL);\r\nif (vid_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto err_dss_init;\r\n}\r\nvid_dev->num_displays = 0;\r\nfor_each_dss_dev(dssdev) {\r\nomap_dss_get_device(dssdev);\r\nif (!dssdev->driver) {\r\ndev_warn(&pdev->dev, "no driver for display: %s\n",\r\ndssdev->name);\r\nomap_dss_put_device(dssdev);\r\ncontinue;\r\n}\r\nvid_dev->displays[vid_dev->num_displays++] = dssdev;\r\n}\r\nif (vid_dev->num_displays == 0) {\r\ndev_err(&pdev->dev, "no displays\n");\r\nret = -EINVAL;\r\ngoto probe_err0;\r\n}\r\nvid_dev->num_overlays = omap_dss_get_num_overlays();\r\nfor (i = 0; i < vid_dev->num_overlays; i++)\r\nvid_dev->overlays[i] = omap_dss_get_overlay(i);\r\nvid_dev->num_managers = omap_dss_get_num_overlay_managers();\r\nfor (i = 0; i < vid_dev->num_managers; i++)\r\nvid_dev->managers[i] = omap_dss_get_overlay_manager(i);\r\nfor (i = 1; i < vid_dev->num_overlays; i++) {\r\novl = omap_dss_get_overlay(i);\r\ndssdev = ovl->get_device(ovl);\r\nif (dssdev) {\r\ndef_display = dssdev;\r\n} else {\r\ndev_warn(&pdev->dev, "cannot find display\n");\r\ndef_display = NULL;\r\n}\r\nif (def_display) {\r\nstruct omap_dss_driver *dssdrv = def_display->driver;\r\nret = dssdrv->enable(def_display);\r\nif (ret) {\r\ndev_warn(&pdev->dev,\r\n"'%s' Display already enabled\n",\r\ndef_display->name);\r\n}\r\n}\r\n}\r\nif (v4l2_device_register(&pdev->dev, &vid_dev->v4l2_dev) < 0) {\r\ndev_err(&pdev->dev, "v4l2_device_register failed\n");\r\nret = -ENODEV;\r\ngoto probe_err1;\r\n}\r\nret = omap_vout_create_video_devices(pdev);\r\nif (ret)\r\ngoto probe_err2;\r\nfor (i = 0; i < vid_dev->num_displays; i++) {\r\nstruct omap_dss_device *display = vid_dev->displays[i];\r\nif (display->driver->update)\r\ndisplay->driver->update(display, 0, 0,\r\ndisplay->panel.timings.x_res,\r\ndisplay->panel.timings.y_res);\r\n}\r\nreturn 0;\r\nprobe_err2:\r\nv4l2_device_unregister(&vid_dev->v4l2_dev);\r\nprobe_err1:\r\nfor (i = 1; i < vid_dev->num_overlays; i++) {\r\ndef_display = NULL;\r\novl = omap_dss_get_overlay(i);\r\ndssdev = ovl->get_device(ovl);\r\nif (dssdev)\r\ndef_display = dssdev;\r\nif (def_display && def_display->driver)\r\ndef_display->driver->disable(def_display);\r\n}\r\nprobe_err0:\r\nkfree(vid_dev);\r\nerr_dss_init:\r\nomapdss_compat_uninit();\r\nreturn ret;\r\n}\r\nstatic int __init omap_vout_init(void)\r\n{\r\nif (platform_driver_probe(&omap_vout_driver, omap_vout_probe) != 0) {\r\nprintk(KERN_ERR VOUT_NAME ":Could not register Video driver\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_vout_cleanup(void)\r\n{\r\nplatform_driver_unregister(&omap_vout_driver);\r\n}
