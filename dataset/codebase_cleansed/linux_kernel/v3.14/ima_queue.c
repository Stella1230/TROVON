static struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value)\r\n{\r\nstruct ima_queue_entry *qe, *ret = NULL;\r\nunsigned int key;\r\nint rc;\r\nkey = ima_hash_key(digest_value);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\r\nrc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\r\nif (rc == 0) {\r\nret = qe;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int ima_add_digest_entry(struct ima_template_entry *entry)\r\n{\r\nstruct ima_queue_entry *qe;\r\nunsigned int key;\r\nqe = kmalloc(sizeof(*qe), GFP_KERNEL);\r\nif (qe == NULL) {\r\npr_err("IMA: OUT OF MEMORY ERROR creating queue entry.\n");\r\nreturn -ENOMEM;\r\n}\r\nqe->entry = entry;\r\nINIT_LIST_HEAD(&qe->later);\r\nlist_add_tail_rcu(&qe->later, &ima_measurements);\r\natomic_long_inc(&ima_htable.len);\r\nkey = ima_hash_key(entry->digest);\r\nhlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\r\nreturn 0;\r\n}\r\nstatic int ima_pcr_extend(const u8 *hash)\r\n{\r\nint result = 0;\r\nif (!ima_used_chip)\r\nreturn result;\r\nresult = tpm_pcr_extend(TPM_ANY_NUM, CONFIG_IMA_MEASURE_PCR_IDX, hash);\r\nif (result != 0)\r\npr_err("IMA: Error Communicating to TPM chip, result: %d\n",\r\nresult);\r\nreturn result;\r\n}\r\nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\r\nconst char *op, struct inode *inode,\r\nconst unsigned char *filename)\r\n{\r\nu8 digest[TPM_DIGEST_SIZE];\r\nconst char *audit_cause = "hash_added";\r\nchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\r\nint audit_info = 1;\r\nint result = 0, tpmresult = 0;\r\nmutex_lock(&ima_extend_list_mutex);\r\nif (!violation) {\r\nmemcpy(digest, entry->digest, sizeof digest);\r\nif (ima_lookup_digest_entry(digest)) {\r\naudit_cause = "hash_exists";\r\nresult = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nresult = ima_add_digest_entry(entry);\r\nif (result < 0) {\r\naudit_cause = "ENOMEM";\r\naudit_info = 0;\r\ngoto out;\r\n}\r\nif (violation)\r\nmemset(digest, 0xff, sizeof digest);\r\ntpmresult = ima_pcr_extend(digest);\r\nif (tpmresult != 0) {\r\nsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, "TPM_error(%d)",\r\ntpmresult);\r\naudit_cause = tpm_audit_cause;\r\naudit_info = 0;\r\n}\r\nout:\r\nmutex_unlock(&ima_extend_list_mutex);\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, audit_cause, result, audit_info);\r\nreturn result;\r\n}
