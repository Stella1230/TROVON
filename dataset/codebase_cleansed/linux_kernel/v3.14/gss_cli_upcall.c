static\r\nint ctx_init_pack_request(struct obd_import *imp,\r\nstruct ptlrpc_request *req,\r\nint lustre_srv,\r\nuid_t uid, gid_t gid,\r\nlong token_size,\r\nchar __user *token)\r\n{\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nstruct gss_sec *gsec;\r\nstruct gss_header *ghdr;\r\nstruct ptlrpc_user_desc *pud;\r\n__u32 *p, size, offset = 2;\r\nrawobj_t obj;\r\nLASSERT(msg->lm_bufcount <= 4);\r\nLASSERT(req->rq_cli_ctx);\r\nLASSERT(req->rq_cli_ctx->cc_sec);\r\nghdr = lustre_msg_buf(msg, 0, sizeof(*ghdr));\r\nghdr->gh_version = PTLRPC_GSS_VERSION;\r\nghdr->gh_sp = (__u8) imp->imp_sec->ps_part;\r\nghdr->gh_flags = 0;\r\nghdr->gh_proc = PTLRPC_GSS_PROC_INIT;\r\nghdr->gh_seq = 0;\r\nghdr->gh_svc = SPTLRPC_SVC_NULL;\r\nghdr->gh_handle.len = 0;\r\nif (req->rq_pack_udesc) {\r\nghdr->gh_flags |= LUSTRE_GSS_PACK_USER;\r\npud = lustre_msg_buf(msg, offset, sizeof(*pud));\r\nLASSERT(pud);\r\npud->pud_uid = pud->pud_fsuid = uid;\r\npud->pud_gid = pud->pud_fsgid = gid;\r\npud->pud_cap = 0;\r\npud->pud_ngroups = 0;\r\noffset++;\r\n}\r\np = lustre_msg_buf(msg, offset, 0);\r\nsize = msg->lm_buflens[offset];\r\nLASSERT(p);\r\nLASSERT(size > 4);\r\n*p++ = cpu_to_le32(lustre_srv);\r\nsize -= 4;\r\nobj.len = strlen(imp->imp_obd->u.cli.cl_target_uuid.uuid) + 1;\r\nobj.data = imp->imp_obd->u.cli.cl_target_uuid.uuid;\r\nif (rawobj_serialize(&obj, &p, &size))\r\nLBUG();\r\ngsec = sec2gsec(req->rq_cli_ctx->cc_sec);\r\nobj.len = sizeof(gsec->gs_rvs_hdl);\r\nobj.data = (__u8 *) &gsec->gs_rvs_hdl;\r\nif (rawobj_serialize(&obj, &p, &size))\r\nLBUG();\r\nLASSERT(size >= (sizeof(__u32) + token_size));\r\n*p++ = cpu_to_le32(((__u32) token_size));\r\nif (copy_from_user(p, token, token_size)) {\r\nCERROR("can't copy token\n");\r\nreturn -EFAULT;\r\n}\r\nsize -= sizeof(__u32) + cfs_size_round4(token_size);\r\nreq->rq_reqdata_len = lustre_shrink_msg(req->rq_reqbuf, offset,\r\nmsg->lm_buflens[offset] - size, 0);\r\nreturn 0;\r\n}\r\nstatic\r\nint ctx_init_parse_reply(struct lustre_msg *msg, int swabbed,\r\nchar __user *outbuf, long outlen)\r\n{\r\nstruct gss_rep_header *ghdr;\r\n__u32 obj_len, round_len;\r\n__u32 status, effective = 0;\r\nif (msg->lm_bufcount != 3) {\r\nCERROR("unexpected bufcount %u\n", msg->lm_bufcount);\r\nreturn -EPROTO;\r\n}\r\nghdr = (struct gss_rep_header *) gss_swab_header(msg, 0, swabbed);\r\nif (ghdr == NULL) {\r\nCERROR("unable to extract gss reply header\n");\r\nreturn -EPROTO;\r\n}\r\nif (ghdr->gh_version != PTLRPC_GSS_VERSION) {\r\nCERROR("invalid gss version %u\n", ghdr->gh_version);\r\nreturn -EPROTO;\r\n}\r\nif (outlen < (4 + 2) * 4 + cfs_size_round4(ghdr->gh_handle.len) +\r\ncfs_size_round4(msg->lm_buflens[2])) {\r\nCERROR("output buffer size %ld too small\n", outlen);\r\nreturn -EFAULT;\r\n}\r\nstatus = 0;\r\neffective = 0;\r\nif (copy_to_user(outbuf, &status, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\nif (copy_to_user(outbuf, &ghdr->gh_major, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\nif (copy_to_user(outbuf, &ghdr->gh_minor, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\nif (copy_to_user(outbuf, &ghdr->gh_seqwin, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\neffective += 4 * 4;\r\nobj_len = ghdr->gh_handle.len;\r\nround_len = (obj_len + 3) & ~ 3;\r\nif (copy_to_user(outbuf, &obj_len, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\nif (copy_to_user(outbuf, (char *) ghdr->gh_handle.data, round_len))\r\nreturn -EFAULT;\r\noutbuf += round_len;\r\neffective += 4 + round_len;\r\nobj_len = msg->lm_buflens[2];\r\nround_len = (obj_len + 3) & ~ 3;\r\nif (copy_to_user(outbuf, &obj_len, 4))\r\nreturn -EFAULT;\r\noutbuf += 4;\r\nif (copy_to_user(outbuf, lustre_msg_buf(msg, 2, 0), round_len))\r\nreturn -EFAULT;\r\noutbuf += round_len;\r\neffective += 4 + round_len;\r\nreturn effective;\r\n}\r\nint gss_do_ctx_init_rpc(__user char *buffer, unsigned long count)\r\n{\r\nstruct obd_import *imp;\r\nstruct ptlrpc_request *req;\r\nstruct lgssd_ioctl_param param;\r\nstruct obd_device *obd;\r\nchar obdname[64];\r\nlong lsize;\r\nint rc;\r\nif (count != sizeof(param)) {\r\nCERROR("ioctl size %lu, expect %lu, please check lgss_keyring "\r\n"version\n", count, (unsigned long) sizeof(param));\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&param, buffer, sizeof(param))) {\r\nCERROR("failed copy data from lgssd\n");\r\nreturn -EFAULT;\r\n}\r\nif (param.version != GSSD_INTERFACE_VERSION) {\r\nCERROR("gssd interface version %d (expect %d)\n",\r\nparam.version, GSSD_INTERFACE_VERSION);\r\nreturn -EINVAL;\r\n}\r\nif (strncpy_from_user(obdname, param.uuid, sizeof(obdname)) <= 0) {\r\nCERROR("Invalid obdname pointer\n");\r\nreturn -EFAULT;\r\n}\r\nobd = class_name2obd(obdname);\r\nif (!obd) {\r\nCERROR("no such obd %s\n", obdname);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!obd->obd_set_up)) {\r\nCERROR("obd %s not setup\n", obdname);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nif (obd->obd_stopping) {\r\nCERROR("obd %s has stopped\n", obdname);\r\nspin_unlock(&obd->obd_dev_lock);\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSC_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_MGC_NAME)) {\r\nCERROR("obd %s is not a client device\n", obdname);\r\nspin_unlock(&obd->obd_dev_lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&obd->obd_dev_lock);\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (obd->u.cli.cl_import == NULL) {\r\nCERROR("obd %s: import has gone\n", obd->obd_name);\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn -EINVAL;\r\n}\r\nimp = class_import_get(obd->u.cli.cl_import);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (imp->imp_deactive) {\r\nCERROR("import has been deactivated\n");\r\nclass_import_put(imp);\r\nreturn -EINVAL;\r\n}\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_SEC_CTX, LUSTRE_OBD_VERSION,\r\nSEC_CTX_INIT);\r\nif (req == NULL) {\r\nparam.status = -ENOMEM;\r\ngoto out_copy;\r\n}\r\nif (req->rq_cli_ctx->cc_sec->ps_id != param.secid) {\r\nCWARN("original secid %d, now has changed to %d, "\r\n"cancel this negotiation\n", param.secid,\r\nreq->rq_cli_ctx->cc_sec->ps_id);\r\nparam.status = -EINVAL;\r\ngoto out_copy;\r\n}\r\nrc = ctx_init_pack_request(imp, req,\r\nparam.lustre_svc,\r\nparam.uid, param.gid,\r\nparam.send_token_size,\r\nparam.send_token);\r\nif (rc) {\r\nparam.status = rc;\r\ngoto out_copy;\r\n}\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc) {\r\nparam.status = rc;\r\nif (rc != -EACCES)\r\nparam.status = -ETIMEDOUT;\r\ngoto out_copy;\r\n}\r\nLASSERT(req->rq_repdata);\r\nlsize = ctx_init_parse_reply(req->rq_repdata,\r\nptlrpc_rep_need_swab(req),\r\nparam.reply_buf, param.reply_buf_size);\r\nif (lsize < 0) {\r\nparam.status = (int) lsize;\r\ngoto out_copy;\r\n}\r\nparam.status = 0;\r\nparam.reply_length = lsize;\r\nout_copy:\r\nif (copy_to_user(buffer, &param, sizeof(param)))\r\nrc = -EFAULT;\r\nelse\r\nrc = 0;\r\nclass_import_put(imp);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint gss_do_ctx_fini_rpc(struct gss_cli_ctx *gctx)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = &gctx->gc_base;\r\nstruct obd_import *imp = ctx->cc_sec->ps_import;\r\nstruct ptlrpc_request *req;\r\nstruct ptlrpc_user_desc *pud;\r\nint rc;\r\nLASSERT(atomic_read(&ctx->cc_refcount) > 0);\r\nif (cli_ctx_is_error(ctx) || !cli_ctx_is_uptodate(ctx)) {\r\nCDEBUG(D_SEC, "ctx %p(%u->%s) not uptodate, "\r\n"don't send destroy rpc\n", ctx,\r\nctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\nreturn 0;\r\n}\r\nmight_sleep();\r\nCWARN("%s ctx %p idx "LPX64" (%u->%s)\n",\r\nsec_is_reverse(ctx->cc_sec) ?\r\n"server finishing reverse" : "client finishing forward",\r\nctx, gss_handle_to_u64(&gctx->gc_handle),\r\nctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\ngctx->gc_proc = PTLRPC_GSS_PROC_DESTROY;\r\nreq = ptlrpc_request_alloc(imp, &RQF_SEC_CTX);\r\nif (req == NULL) {\r\nCWARN("ctx %p(%u): fail to prepare rpc, destroy locally\n",\r\nctx, ctx->cc_vcred.vc_uid);\r\nGOTO(out, rc = -ENOMEM);\r\n}\r\nrc = ptlrpc_request_bufs_pack(req, LUSTRE_OBD_VERSION, SEC_CTX_FINI,\r\nNULL, ctx);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nGOTO(out_ref, rc);\r\n}\r\nif (req->rq_pack_udesc) {\r\npud = lustre_msg_buf(req->rq_reqbuf, 2, sizeof(*pud));\r\nLASSERT(pud);\r\npud->pud_uid = pud->pud_fsuid = ctx->cc_vcred.vc_uid;\r\npud->pud_gid = pud->pud_fsgid = ctx->cc_vcred.vc_gid;\r\npud->pud_cap = 0;\r\npud->pud_ngroups = 0;\r\n}\r\nreq->rq_phase = RQ_PHASE_RPC;\r\nrc = ptl_send_rpc(req, 1);\r\nif (rc)\r\nCWARN("ctx %p(%u->%s): rpc error %d, destroy locally\n", ctx,\r\nctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec), rc);\r\nout_ref:\r\nptlrpc_req_finished(req);\r\nout:\r\nreturn rc;\r\n}\r\nint __init gss_init_cli_upcall(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __exit gss_exit_cli_upcall(void)\r\n{\r\n}
