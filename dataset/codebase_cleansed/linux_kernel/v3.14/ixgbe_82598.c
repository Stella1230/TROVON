static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_adapter *adapter = hw->back;\r\nu32 gcr = IXGBE_READ_REG(hw, IXGBE_GCR);\r\nu16 pcie_devctl2;\r\nif (gcr & IXGBE_GCR_CMPL_TMOUT_MASK)\r\ngoto out;\r\nif (!(gcr & IXGBE_GCR_CAP_VER2)) {\r\ngcr |= IXGBE_GCR_CMPL_TMOUT_10ms;\r\ngoto out;\r\n}\r\npci_read_config_word(adapter->pdev,\r\nIXGBE_PCI_DEVICE_CONTROL2, &pcie_devctl2);\r\npcie_devctl2 |= IXGBE_PCI_DEVICE_CONTROL2_16ms;\r\npci_write_config_word(adapter->pdev,\r\nIXGBE_PCI_DEVICE_CONTROL2, pcie_devctl2);\r\nout:\r\ngcr &= ~IXGBE_GCR_CMPL_TMOUT_RESEND;\r\nIXGBE_WRITE_REG(hw, IXGBE_GCR, gcr);\r\n}\r\nstatic s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nixgbe_identify_phy_generic(hw);\r\nmac->mcft_size = IXGBE_82598_MC_TBL_SIZE;\r\nmac->vft_size = IXGBE_82598_VFT_TBL_SIZE;\r\nmac->num_rar_entries = IXGBE_82598_RAR_ENTRIES;\r\nmac->max_rx_queues = IXGBE_82598_MAX_RX_QUEUES;\r\nmac->max_tx_queues = IXGBE_82598_MAX_TX_QUEUES;\r\nmac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mac_info *mac = &hw->mac;\r\nstruct ixgbe_phy_info *phy = &hw->phy;\r\ns32 ret_val = 0;\r\nu16 list_offset, data_offset;\r\nphy->ops.identify(hw);\r\nif (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {\r\nmac->ops.setup_link = &ixgbe_setup_copper_link_82598;\r\nmac->ops.get_link_capabilities =\r\n&ixgbe_get_copper_link_capabilities_generic;\r\n}\r\nswitch (hw->phy.type) {\r\ncase ixgbe_phy_tn:\r\nphy->ops.setup_link = &ixgbe_setup_phy_link_tnx;\r\nphy->ops.check_link = &ixgbe_check_phy_link_tnx;\r\nphy->ops.get_firmware_version =\r\n&ixgbe_get_phy_firmware_version_tnx;\r\nbreak;\r\ncase ixgbe_phy_nl:\r\nphy->ops.reset = &ixgbe_reset_phy_nl;\r\nret_val = phy->ops.identify_sfp(hw);\r\nif (ret_val != 0)\r\ngoto out;\r\nelse if (hw->phy.sfp_type == ixgbe_sfp_type_unknown) {\r\nret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;\r\ngoto out;\r\n}\r\nret_val = ixgbe_get_sfp_init_sequence_offsets(hw,\r\n&list_offset,\r\n&data_offset);\r\nif (ret_val != 0) {\r\nret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)\r\n{\r\nu32 regval;\r\nu32 i;\r\ns32 ret_val = 0;\r\nret_val = ixgbe_start_hw_generic(hw);\r\nfor (i = 0; ((i < hw->mac.max_tx_queues) &&\r\n(i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {\r\nregval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));\r\nregval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;\r\nIXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(i), regval);\r\n}\r\nfor (i = 0; ((i < hw->mac.max_rx_queues) &&\r\n(i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {\r\nregval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));\r\nregval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |\r\nIXGBE_DCA_RXCTRL_HEAD_WRO_EN);\r\nIXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);\r\n}\r\nhw->mac.rx_pb_size = IXGBE_82598_RX_PB_SIZE;\r\nif (ret_val == 0)\r\nixgbe_set_pcie_completion_timeout(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,\r\nixgbe_link_speed *speed,\r\nbool *autoneg)\r\n{\r\ns32 status = 0;\r\nu32 autoc = 0;\r\nif (hw->mac.orig_link_settings_stored)\r\nautoc = hw->mac.orig_autoc;\r\nelse\r\nautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nswitch (autoc & IXGBE_AUTOC_LMS_MASK) {\r\ncase IXGBE_AUTOC_LMS_1G_LINK_NO_AN:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = false;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_10G_LINK_NO_AN:\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\n*autoneg = false;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_1G_AN:\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_KX4_AN:\r\ncase IXGBE_AUTOC_LMS_KX4_AN_1G_AN:\r\n*speed = IXGBE_LINK_SPEED_UNKNOWN;\r\nif (autoc & IXGBE_AUTOC_KX4_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (autoc & IXGBE_AUTOC_KX_SUPP)\r\n*speed |= IXGBE_LINK_SPEED_1GB_FULL;\r\n*autoneg = true;\r\nbreak;\r\ndefault:\r\nstatus = IXGBE_ERR_LINK_SETUP;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)\r\n{\r\nenum ixgbe_media_type media_type;\r\nswitch (hw->phy.type) {\r\ncase ixgbe_phy_cu_unknown:\r\ncase ixgbe_phy_tn:\r\nmedia_type = ixgbe_media_type_copper;\r\ngoto out;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hw->device_id) {\r\ncase IXGBE_DEV_ID_82598:\r\ncase IXGBE_DEV_ID_82598_BX:\r\nmedia_type = ixgbe_media_type_backplane;\r\nbreak;\r\ncase IXGBE_DEV_ID_82598AF_DUAL_PORT:\r\ncase IXGBE_DEV_ID_82598AF_SINGLE_PORT:\r\ncase IXGBE_DEV_ID_82598_DA_DUAL_PORT:\r\ncase IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:\r\ncase IXGBE_DEV_ID_82598EB_XF_LR:\r\ncase IXGBE_DEV_ID_82598EB_SFP_LOM:\r\nmedia_type = ixgbe_media_type_fiber;\r\nbreak;\r\ncase IXGBE_DEV_ID_82598EB_CX4:\r\ncase IXGBE_DEV_ID_82598_CX4_DUAL_PORT:\r\nmedia_type = ixgbe_media_type_cx4;\r\nbreak;\r\ncase IXGBE_DEV_ID_82598AT:\r\ncase IXGBE_DEV_ID_82598AT2:\r\nmedia_type = ixgbe_media_type_copper;\r\nbreak;\r\ndefault:\r\nmedia_type = ixgbe_media_type_unknown;\r\nbreak;\r\n}\r\nout:\r\nreturn media_type;\r\n}\r\nstatic s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu32 fctrl_reg;\r\nu32 rmcs_reg;\r\nu32 reg;\r\nu32 fcrtl, fcrth;\r\nu32 link_speed = 0;\r\nint i;\r\nbool link_up;\r\nif (!hw->fc.low_water ||\r\n!hw->fc.high_water[0] ||\r\n!hw->fc.pause_time) {\r\nhw_dbg(hw, "Invalid water mark configuration\n");\r\nret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;\r\ngoto out;\r\n}\r\nhw->mac.ops.check_link(hw, &link_speed, &link_up, false);\r\nif (link_up && link_speed == IXGBE_LINK_SPEED_1GB_FULL) {\r\nswitch (hw->fc.requested_mode) {\r\ncase ixgbe_fc_full:\r\nhw->fc.requested_mode = ixgbe_fc_tx_pause;\r\nbreak;\r\ncase ixgbe_fc_rx_pause:\r\nhw->fc.requested_mode = ixgbe_fc_none;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nixgbe_fc_autoneg(hw);\r\nfctrl_reg = IXGBE_READ_REG(hw, IXGBE_FCTRL);\r\nfctrl_reg &= ~(IXGBE_FCTRL_RFCE | IXGBE_FCTRL_RPFCE);\r\nrmcs_reg = IXGBE_READ_REG(hw, IXGBE_RMCS);\r\nrmcs_reg &= ~(IXGBE_RMCS_TFCE_PRIORITY | IXGBE_RMCS_TFCE_802_3X);\r\nswitch (hw->fc.current_mode) {\r\ncase ixgbe_fc_none:\r\nbreak;\r\ncase ixgbe_fc_rx_pause:\r\nfctrl_reg |= IXGBE_FCTRL_RFCE;\r\nbreak;\r\ncase ixgbe_fc_tx_pause:\r\nrmcs_reg |= IXGBE_RMCS_TFCE_802_3X;\r\nbreak;\r\ncase ixgbe_fc_full:\r\nfctrl_reg |= IXGBE_FCTRL_RFCE;\r\nrmcs_reg |= IXGBE_RMCS_TFCE_802_3X;\r\nbreak;\r\ndefault:\r\nhw_dbg(hw, "Flow control param set incorrectly\n");\r\nret_val = IXGBE_ERR_CONFIG;\r\ngoto out;\r\nbreak;\r\n}\r\nfctrl_reg |= IXGBE_FCTRL_DPF;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl_reg);\r\nIXGBE_WRITE_REG(hw, IXGBE_RMCS, rmcs_reg);\r\nfcrtl = (hw->fc.low_water << 10) | IXGBE_FCRTL_XONE;\r\nfor (i = 0; i < MAX_TRAFFIC_CLASS; i++) {\r\nif ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&\r\nhw->fc.high_water[i]) {\r\nfcrth = (hw->fc.high_water[i] << 10) | IXGBE_FCRTH_FCEN;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), fcrtl);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), fcrth);\r\n} else {\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), 0);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), 0);\r\n}\r\n}\r\nreg = hw->fc.pause_time * 0x00010001;\r\nfor (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);\r\nIXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,\r\nbool autoneg_wait_to_complete)\r\n{\r\nu32 autoc_reg;\r\nu32 links_reg;\r\nu32 i;\r\ns32 status = 0;\r\nautoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nautoc_reg |= IXGBE_AUTOC_AN_RESTART;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);\r\nif (autoneg_wait_to_complete) {\r\nif ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\r\nIXGBE_AUTOC_LMS_KX4_AN ||\r\n(autoc_reg & IXGBE_AUTOC_LMS_MASK) ==\r\nIXGBE_AUTOC_LMS_KX4_AN_1G_AN) {\r\nlinks_reg = 0;\r\nfor (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif (links_reg & IXGBE_LINKS_KX_AN_COMP)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {\r\nstatus = IXGBE_ERR_AUTONEG_NOT_COMPLETE;\r\nhw_dbg(hw, "Autonegotiation did not complete.\n");\r\n}\r\n}\r\n}\r\nmsleep(50);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)\r\n{\r\nu32 timeout;\r\nu16 an_reg;\r\nif (hw->device_id != IXGBE_DEV_ID_82598AT2)\r\nreturn 0;\r\nfor (timeout = 0;\r\ntimeout < IXGBE_VALIDATE_LINK_READY_TIMEOUT; timeout++) {\r\nhw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN, &an_reg);\r\nif ((an_reg & MDIO_AN_STAT1_COMPLETE) &&\r\n(an_reg & MDIO_STAT1_LSTATUS))\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (timeout == IXGBE_VALIDATE_LINK_READY_TIMEOUT) {\r\nhw_dbg(hw, "Link was indicated but link is down\n");\r\nreturn IXGBE_ERR_LINK_SETUP;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,\r\nixgbe_link_speed *speed, bool *link_up,\r\nbool link_up_wait_to_complete)\r\n{\r\nu32 links_reg;\r\nu32 i;\r\nu16 link_reg, adapt_comp_reg;\r\nif (hw->phy.type == ixgbe_phy_nl) {\r\nhw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);\r\nhw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);\r\nhw->phy.ops.read_reg(hw, 0xC00C, MDIO_MMD_PMAPMD,\r\n&adapt_comp_reg);\r\nif (link_up_wait_to_complete) {\r\nfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\r\nif ((link_reg & 1) &&\r\n((adapt_comp_reg & 1) == 0)) {\r\n*link_up = true;\r\nbreak;\r\n} else {\r\n*link_up = false;\r\n}\r\nmsleep(100);\r\nhw->phy.ops.read_reg(hw, 0xC79F,\r\nMDIO_MMD_PMAPMD,\r\n&link_reg);\r\nhw->phy.ops.read_reg(hw, 0xC00C,\r\nMDIO_MMD_PMAPMD,\r\n&adapt_comp_reg);\r\n}\r\n} else {\r\nif ((link_reg & 1) && ((adapt_comp_reg & 1) == 0))\r\n*link_up = true;\r\nelse\r\n*link_up = false;\r\n}\r\nif (!*link_up)\r\ngoto out;\r\n}\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nif (link_up_wait_to_complete) {\r\nfor (i = 0; i < IXGBE_LINK_UP_TIME; i++) {\r\nif (links_reg & IXGBE_LINKS_UP) {\r\n*link_up = true;\r\nbreak;\r\n} else {\r\n*link_up = false;\r\n}\r\nmsleep(100);\r\nlinks_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\n}\r\n} else {\r\nif (links_reg & IXGBE_LINKS_UP)\r\n*link_up = true;\r\nelse\r\n*link_up = false;\r\n}\r\nif (links_reg & IXGBE_LINKS_SPEED)\r\n*speed = IXGBE_LINK_SPEED_10GB_FULL;\r\nelse\r\n*speed = IXGBE_LINK_SPEED_1GB_FULL;\r\nif ((hw->device_id == IXGBE_DEV_ID_82598AT2) && *link_up &&\r\n(ixgbe_validate_link_ready(hw) != 0))\r\n*link_up = false;\r\nout:\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\nbool autoneg = false;\r\ns32 status = 0;\r\nixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;\r\nu32 curr_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nu32 autoc = curr_autoc;\r\nu32 link_mode = autoc & IXGBE_AUTOC_LMS_MASK;\r\nixgbe_get_link_capabilities_82598(hw, &link_capabilities, &autoneg);\r\nspeed &= link_capabilities;\r\nif (speed == IXGBE_LINK_SPEED_UNKNOWN)\r\nstatus = IXGBE_ERR_LINK_SETUP;\r\nelse if (link_mode == IXGBE_AUTOC_LMS_KX4_AN ||\r\nlink_mode == IXGBE_AUTOC_LMS_KX4_AN_1G_AN) {\r\nautoc &= ~IXGBE_AUTOC_KX4_KX_SUPP_MASK;\r\nif (speed & IXGBE_LINK_SPEED_10GB_FULL)\r\nautoc |= IXGBE_AUTOC_KX4_SUPP;\r\nif (speed & IXGBE_LINK_SPEED_1GB_FULL)\r\nautoc |= IXGBE_AUTOC_KX_SUPP;\r\nif (autoc != curr_autoc)\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);\r\n}\r\nif (status == 0) {\r\nstatus = ixgbe_start_mac_link_82598(hw,\r\nautoneg_wait_to_complete);\r\n}\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,\r\nixgbe_link_speed speed,\r\nbool autoneg_wait_to_complete)\r\n{\r\ns32 status;\r\nstatus = hw->phy.ops.setup_link_speed(hw, speed,\r\nautoneg_wait_to_complete);\r\nixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)\r\n{\r\ns32 status = 0;\r\ns32 phy_status = 0;\r\nu32 ctrl;\r\nu32 gheccr;\r\nu32 i;\r\nu32 autoc;\r\nu8 analog_val;\r\nstatus = hw->mac.ops.stop_adapter(hw);\r\nif (status != 0)\r\ngoto reset_hw_out;\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &analog_val);\r\nif (analog_val & IXGBE_ATLAS_PDN_TX_REG_EN) {\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,\r\n&analog_val);\r\nanalog_val &= ~IXGBE_ATLAS_PDN_TX_REG_EN;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK,\r\nanalog_val);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,\r\n&analog_val);\r\nanalog_val &= ~IXGBE_ATLAS_PDN_TX_10G_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G,\r\nanalog_val);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,\r\n&analog_val);\r\nanalog_val &= ~IXGBE_ATLAS_PDN_TX_1G_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G,\r\nanalog_val);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,\r\n&analog_val);\r\nanalog_val &= ~IXGBE_ATLAS_PDN_TX_AN_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN,\r\nanalog_val);\r\n}\r\nif (hw->phy.reset_disable == false) {\r\nphy_status = hw->phy.ops.init(hw);\r\nif (phy_status == IXGBE_ERR_SFP_NOT_SUPPORTED)\r\ngoto reset_hw_out;\r\nif (phy_status == IXGBE_ERR_SFP_NOT_PRESENT)\r\ngoto mac_reset_top;\r\nhw->phy.ops.reset(hw);\r\n}\r\nmac_reset_top:\r\nctrl = IXGBE_READ_REG(hw, IXGBE_CTRL) | IXGBE_CTRL_RST;\r\nIXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nfor (i = 0; i < 10; i++) {\r\nudelay(1);\r\nctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nif (!(ctrl & IXGBE_CTRL_RST))\r\nbreak;\r\n}\r\nif (ctrl & IXGBE_CTRL_RST) {\r\nstatus = IXGBE_ERR_RESET_FAILED;\r\nhw_dbg(hw, "Reset polling failed to complete.\n");\r\n}\r\nmsleep(50);\r\nif (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {\r\nhw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;\r\ngoto mac_reset_top;\r\n}\r\ngheccr = IXGBE_READ_REG(hw, IXGBE_GHECCR);\r\ngheccr &= ~((1 << 21) | (1 << 18) | (1 << 9) | (1 << 6));\r\nIXGBE_WRITE_REG(hw, IXGBE_GHECCR, gheccr);\r\nautoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nif (hw->mac.orig_link_settings_stored == false) {\r\nhw->mac.orig_autoc = autoc;\r\nhw->mac.orig_link_settings_stored = true;\r\n} else if (autoc != hw->mac.orig_autoc) {\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, hw->mac.orig_autoc);\r\n}\r\nhw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);\r\nhw->mac.ops.init_rx_addrs(hw);\r\nreset_hw_out:\r\nif (phy_status)\r\nstatus = phy_status;\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\r\n{\r\nu32 rar_high;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (rar >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", rar);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nrar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));\r\nrar_high &= ~IXGBE_RAH_VIND_MASK;\r\nrar_high |= ((vmdq << IXGBE_RAH_VIND_SHIFT) & IXGBE_RAH_VIND_MASK);\r\nIXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)\r\n{\r\nu32 rar_high;\r\nu32 rar_entries = hw->mac.num_rar_entries;\r\nif (rar >= rar_entries) {\r\nhw_dbg(hw, "RAR index %d is out of range.\n", rar);\r\nreturn IXGBE_ERR_INVALID_ARGUMENT;\r\n}\r\nrar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));\r\nif (rar_high & IXGBE_RAH_VIND_MASK) {\r\nrar_high &= ~IXGBE_RAH_VIND_MASK;\r\nIXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,\r\nbool vlan_on)\r\n{\r\nu32 regindex;\r\nu32 bitindex;\r\nu32 bits;\r\nu32 vftabyte;\r\nif (vlan > 4095)\r\nreturn IXGBE_ERR_PARAM;\r\nregindex = (vlan >> 5) & 0x7F;\r\nvftabyte = ((vlan >> 3) & 0x03);\r\nbitindex = (vlan & 0x7) << 2;\r\nbits = IXGBE_READ_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex));\r\nbits &= (~(0x0F << bitindex));\r\nbits |= (vind << bitindex);\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vftabyte, regindex), bits);\r\nbitindex = vlan & 0x1F;\r\nbits = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));\r\nif (vlan_on)\r\nbits |= (1 << bitindex);\r\nelse\r\nbits &= ~(1 << bitindex);\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), bits);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)\r\n{\r\nu32 offset;\r\nu32 vlanbyte;\r\nfor (offset = 0; offset < hw->mac.vft_size; offset++)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);\r\nfor (vlanbyte = 0; vlanbyte < 4; vlanbyte++)\r\nfor (offset = 0; offset < hw->mac.vft_size; offset++)\r\nIXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vlanbyte, offset),\r\n0);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)\r\n{\r\nu32 atlas_ctl;\r\nIXGBE_WRITE_REG(hw, IXGBE_ATLASCTL,\r\nIXGBE_ATLASCTL_WRITE_CMD | (reg << 8));\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(10);\r\natlas_ctl = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);\r\n*val = (u8)atlas_ctl;\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)\r\n{\r\nu32 atlas_ctl;\r\natlas_ctl = (reg << 8) | val;\r\nIXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, atlas_ctl);\r\nIXGBE_WRITE_FLUSH(hw);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,\r\nu8 byte_offset, u8 *eeprom_data)\r\n{\r\ns32 status = 0;\r\nu16 sfp_addr = 0;\r\nu16 sfp_data = 0;\r\nu16 sfp_stat = 0;\r\nu16 gssr;\r\nu32 i;\r\nif (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)\r\ngssr = IXGBE_GSSR_PHY1_SM;\r\nelse\r\ngssr = IXGBE_GSSR_PHY0_SM;\r\nif (hw->mac.ops.acquire_swfw_sync(hw, gssr) != 0)\r\nreturn IXGBE_ERR_SWFW_SYNC;\r\nif (hw->phy.type == ixgbe_phy_nl) {\r\nsfp_addr = (dev_addr << 8) + byte_offset;\r\nsfp_addr = (sfp_addr | IXGBE_I2C_EEPROM_READ_MASK);\r\nhw->phy.ops.write_reg_mdi(hw,\r\nIXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,\r\nMDIO_MMD_PMAPMD,\r\nsfp_addr);\r\nfor (i = 0; i < 100; i++) {\r\nhw->phy.ops.read_reg_mdi(hw,\r\nIXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,\r\nMDIO_MMD_PMAPMD,\r\n&sfp_stat);\r\nsfp_stat = sfp_stat & IXGBE_I2C_EEPROM_STATUS_MASK;\r\nif (sfp_stat != IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS)\r\nbreak;\r\nusleep_range(10000, 20000);\r\n}\r\nif (sfp_stat != IXGBE_I2C_EEPROM_STATUS_PASS) {\r\nhw_dbg(hw, "EEPROM read did not pass.\n");\r\nstatus = IXGBE_ERR_SFP_NOT_PRESENT;\r\ngoto out;\r\n}\r\nhw->phy.ops.read_reg_mdi(hw, IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA,\r\nMDIO_MMD_PMAPMD, &sfp_data);\r\n*eeprom_data = (u8)(sfp_data >> 8);\r\n} else {\r\nstatus = IXGBE_ERR_PHY;\r\n}\r\nout:\r\nhw->mac.ops.release_swfw_sync(hw, gssr);\r\nreturn status;\r\n}\r\nstatic s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 *eeprom_data)\r\n{\r\nreturn ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR,\r\nbyte_offset, eeprom_data);\r\n}\r\nstatic s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset,\r\nu8 *sff8472_data)\r\n{\r\nreturn ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR2,\r\nbyte_offset, sff8472_data);\r\n}\r\nstatic u32 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw)\r\n{\r\nu32 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;\r\nu32 autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nu32 pma_pmd_10g = autoc & IXGBE_AUTOC_10G_PMA_PMD_MASK;\r\nu32 pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;\r\nu16 ext_ability = 0;\r\nhw->phy.ops.identify(hw);\r\nswitch (hw->phy.type) {\r\ncase ixgbe_phy_tn:\r\ncase ixgbe_phy_cu_unknown:\r\nhw->phy.ops.read_reg(hw, MDIO_PMA_EXTABLE,\r\nMDIO_MMD_PMAPMD, &ext_ability);\r\nif (ext_ability & MDIO_PMA_EXTABLE_10GBT)\r\nphysical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;\r\nif (ext_ability & MDIO_PMA_EXTABLE_1000BT)\r\nphysical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;\r\nif (ext_ability & MDIO_PMA_EXTABLE_100BTX)\r\nphysical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;\r\ngoto out;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (autoc & IXGBE_AUTOC_LMS_MASK) {\r\ncase IXGBE_AUTOC_LMS_1G_AN:\r\ncase IXGBE_AUTOC_LMS_1G_LINK_NO_AN:\r\nif (pma_pmd_1g == IXGBE_AUTOC_1G_KX)\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX;\r\nelse\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_BX;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_10G_LINK_NO_AN:\r\nif (pma_pmd_10g == IXGBE_AUTOC_10G_CX4)\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_CX4;\r\nelse if (pma_pmd_10g == IXGBE_AUTOC_10G_KX4)\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4;\r\nelse\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;\r\nbreak;\r\ncase IXGBE_AUTOC_LMS_KX4_AN:\r\ncase IXGBE_AUTOC_LMS_KX4_AN_1G_AN:\r\nif (autoc & IXGBE_AUTOC_KX_SUPP)\r\nphysical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_KX;\r\nif (autoc & IXGBE_AUTOC_KX4_SUPP)\r\nphysical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KX4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hw->phy.type == ixgbe_phy_nl) {\r\nhw->phy.ops.identify_sfp(hw);\r\nswitch (hw->phy.sfp_type) {\r\ncase ixgbe_sfp_type_da_cu:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;\r\nbreak;\r\ncase ixgbe_sfp_type_sr:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;\r\nbreak;\r\ncase ixgbe_sfp_type_lr:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;\r\nbreak;\r\ndefault:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nswitch (hw->device_id) {\r\ncase IXGBE_DEV_ID_82598_DA_DUAL_PORT:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;\r\nbreak;\r\ncase IXGBE_DEV_ID_82598AF_DUAL_PORT:\r\ncase IXGBE_DEV_ID_82598AF_SINGLE_PORT:\r\ncase IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;\r\nbreak;\r\ncase IXGBE_DEV_ID_82598EB_XF_LR:\r\nphysical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn physical_layer;\r\n}\r\nstatic void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_bus_info *bus = &hw->bus;\r\nu16 pci_gen = 0;\r\nu16 pci_ctrl2 = 0;\r\nixgbe_set_lan_id_multi_port_pcie(hw);\r\nhw->eeprom.ops.read(hw, IXGBE_PCIE_GENERAL_PTR, &pci_gen);\r\nif ((pci_gen != 0) && (pci_gen != 0xFFFF)) {\r\nhw->eeprom.ops.read(hw, pci_gen + IXGBE_PCIE_CTRL2, &pci_ctrl2);\r\nif ((pci_ctrl2 & IXGBE_PCIE_CTRL2_LAN_DISABLE) &&\r\n!(pci_ctrl2 & IXGBE_PCIE_CTRL2_DISABLE_SELECT) &&\r\n!(pci_ctrl2 & IXGBE_PCIE_CTRL2_DUMMY_ENABLE)) {\r\nbus->func = 0;\r\n}\r\n}\r\n}\r\nstatic void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb, u32 headroom,\r\nint strategy)\r\n{\r\nu32 rxpktsize = IXGBE_RXPBSIZE_64KB;\r\nu8 i = 0;\r\nif (!num_pb)\r\nreturn;\r\nswitch (strategy) {\r\ncase PBA_STRATEGY_WEIGHTED:\r\nrxpktsize = IXGBE_RXPBSIZE_80KB;\r\nfor (; i < 4; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\r\nrxpktsize = IXGBE_RXPBSIZE_48KB;\r\ncase PBA_STRATEGY_EQUAL:\r\ndefault:\r\nfor (; i < IXGBE_MAX_PACKET_BUFFERS; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);\r\nbreak;\r\n}\r\nfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++)\r\nIXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), IXGBE_TXPBSIZE_40KB);\r\nreturn;\r\n}
