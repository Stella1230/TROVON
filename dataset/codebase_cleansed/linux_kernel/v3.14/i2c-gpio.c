static void i2c_gpio_setsda_dir(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nif (state)\r\ngpio_direction_input(pdata->sda_pin);\r\nelse\r\ngpio_direction_output(pdata->sda_pin, 0);\r\n}\r\nstatic void i2c_gpio_setsda_val(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\ngpio_set_value(pdata->sda_pin, state);\r\n}\r\nstatic void i2c_gpio_setscl_dir(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nif (state)\r\ngpio_direction_input(pdata->scl_pin);\r\nelse\r\ngpio_direction_output(pdata->scl_pin, 0);\r\n}\r\nstatic void i2c_gpio_setscl_val(void *data, int state)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\ngpio_set_value(pdata->scl_pin, state);\r\n}\r\nstatic int i2c_gpio_getsda(void *data)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nreturn gpio_get_value(pdata->sda_pin);\r\n}\r\nstatic int i2c_gpio_getscl(void *data)\r\n{\r\nstruct i2c_gpio_platform_data *pdata = data;\r\nreturn gpio_get_value(pdata->scl_pin);\r\n}\r\nstatic int of_i2c_gpio_get_pins(struct device_node *np,\r\nunsigned int *sda_pin, unsigned int *scl_pin)\r\n{\r\nif (of_gpio_count(np) < 2)\r\nreturn -ENODEV;\r\n*sda_pin = of_get_gpio(np, 0);\r\n*scl_pin = of_get_gpio(np, 1);\r\nif (!gpio_is_valid(*sda_pin) || !gpio_is_valid(*scl_pin)) {\r\npr_err("%s: invalid GPIO pins, sda=%d/scl=%d\n",\r\nnp->full_name, *sda_pin, *scl_pin);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void of_i2c_gpio_get_props(struct device_node *np,\r\nstruct i2c_gpio_platform_data *pdata)\r\n{\r\nu32 reg;\r\nof_property_read_u32(np, "i2c-gpio,delay-us", &pdata->udelay);\r\nif (!of_property_read_u32(np, "i2c-gpio,timeout-ms", &reg))\r\npdata->timeout = msecs_to_jiffies(reg);\r\npdata->sda_is_open_drain =\r\nof_property_read_bool(np, "i2c-gpio,sda-open-drain");\r\npdata->scl_is_open_drain =\r\nof_property_read_bool(np, "i2c-gpio,scl-open-drain");\r\npdata->scl_is_output_only =\r\nof_property_read_bool(np, "i2c-gpio,scl-output-only");\r\n}\r\nstatic int i2c_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_gpio_private_data *priv;\r\nstruct i2c_gpio_platform_data *pdata;\r\nstruct i2c_algo_bit_data *bit_data;\r\nstruct i2c_adapter *adap;\r\nunsigned int sda_pin, scl_pin;\r\nint ret;\r\nif (pdev->dev.of_node) {\r\nret = of_i2c_gpio_get_pins(pdev->dev.of_node,\r\n&sda_pin, &scl_pin);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nif (!dev_get_platdata(&pdev->dev))\r\nreturn -ENXIO;\r\npdata = dev_get_platdata(&pdev->dev);\r\nsda_pin = pdata->sda_pin;\r\nscl_pin = pdata->scl_pin;\r\n}\r\nret = gpio_request(sda_pin, "sda");\r\nif (ret) {\r\nif (ret == -EINVAL)\r\nret = -EPROBE_DEFER;\r\ngoto err_request_sda;\r\n}\r\nret = gpio_request(scl_pin, "scl");\r\nif (ret) {\r\nif (ret == -EINVAL)\r\nret = -EPROBE_DEFER;\r\ngoto err_request_scl;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto err_add_bus;\r\n}\r\nadap = &priv->adap;\r\nbit_data = &priv->bit_data;\r\npdata = &priv->pdata;\r\nif (pdev->dev.of_node) {\r\npdata->sda_pin = sda_pin;\r\npdata->scl_pin = scl_pin;\r\nof_i2c_gpio_get_props(pdev->dev.of_node, pdata);\r\n} else {\r\nmemcpy(pdata, dev_get_platdata(&pdev->dev), sizeof(*pdata));\r\n}\r\nif (pdata->sda_is_open_drain) {\r\ngpio_direction_output(pdata->sda_pin, 1);\r\nbit_data->setsda = i2c_gpio_setsda_val;\r\n} else {\r\ngpio_direction_input(pdata->sda_pin);\r\nbit_data->setsda = i2c_gpio_setsda_dir;\r\n}\r\nif (pdata->scl_is_open_drain || pdata->scl_is_output_only) {\r\ngpio_direction_output(pdata->scl_pin, 1);\r\nbit_data->setscl = i2c_gpio_setscl_val;\r\n} else {\r\ngpio_direction_input(pdata->scl_pin);\r\nbit_data->setscl = i2c_gpio_setscl_dir;\r\n}\r\nif (!pdata->scl_is_output_only)\r\nbit_data->getscl = i2c_gpio_getscl;\r\nbit_data->getsda = i2c_gpio_getsda;\r\nif (pdata->udelay)\r\nbit_data->udelay = pdata->udelay;\r\nelse if (pdata->scl_is_output_only)\r\nbit_data->udelay = 50;\r\nelse\r\nbit_data->udelay = 5;\r\nif (pdata->timeout)\r\nbit_data->timeout = pdata->timeout;\r\nelse\r\nbit_data->timeout = HZ / 10;\r\nbit_data->data = pdata;\r\nadap->owner = THIS_MODULE;\r\nif (pdev->dev.of_node)\r\nstrlcpy(adap->name, dev_name(&pdev->dev), sizeof(adap->name));\r\nelse\r\nsnprintf(adap->name, sizeof(adap->name), "i2c-gpio%d", pdev->id);\r\nadap->algo_data = bit_data;\r\nadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->nr = pdev->id;\r\nret = i2c_bit_add_numbered_bus(adap);\r\nif (ret)\r\ngoto err_add_bus;\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(&pdev->dev, "using pins %u (SDA) and %u (SCL%s)\n",\r\npdata->sda_pin, pdata->scl_pin,\r\npdata->scl_is_output_only\r\n? ", no clock stretching" : "");\r\nreturn 0;\r\nerr_add_bus:\r\ngpio_free(scl_pin);\r\nerr_request_scl:\r\ngpio_free(sda_pin);\r\nerr_request_sda:\r\nreturn ret;\r\n}\r\nstatic int i2c_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_gpio_private_data *priv;\r\nstruct i2c_gpio_platform_data *pdata;\r\nstruct i2c_adapter *adap;\r\npriv = platform_get_drvdata(pdev);\r\nadap = &priv->adap;\r\npdata = &priv->pdata;\r\ni2c_del_adapter(adap);\r\ngpio_free(pdata->scl_pin);\r\ngpio_free(pdata->sda_pin);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_gpio_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&i2c_gpio_driver);\r\nif (ret)\r\nprintk(KERN_ERR "i2c-gpio: probe failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit i2c_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_gpio_driver);\r\n}
