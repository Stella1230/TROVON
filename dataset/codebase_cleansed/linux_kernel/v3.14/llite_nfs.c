__u32 get_uuid2int(const char *name, int len)\r\n{\r\n__u32 key0 = 0x12a3fe2d, key1 = 0x37abe8f9;\r\nwhile (len--) {\r\n__u32 key = key1 + (key0 ^ (*name++ * 7152373));\r\nif (key & 0x80000000) key -= 0x7fffffff;\r\nkey1 = key0;\r\nkey0 = key;\r\n}\r\nreturn (key0 << 1);\r\n}\r\nvoid get_uuid2fsid(const char *name, int len, __kernel_fsid_t *fsid)\r\n{\r\n__u64 key = 0, key0 = 0x12a3fe2d, key1 = 0x37abe8f9;\r\nwhile (len--) {\r\nkey = key1 + (key0 ^ (*name++ * 7152373));\r\nif (key & 0x8000000000000000ULL)\r\nkey -= 0x7fffffffffffffffULL;\r\nkey1 = key0;\r\nkey0 = key;\r\n}\r\nfsid->val[0] = key;\r\nfsid->val[1] = key >> 32;\r\n}\r\nstatic int ll_nfs_test_inode(struct inode *inode, void *opaque)\r\n{\r\nreturn lu_fid_eq(&ll_i2info(inode)->lli_fid,\r\n(struct lu_fid *)opaque);\r\n}\r\nstruct inode *search_inode_for_lustre(struct super_block *sb,\r\nconst struct lu_fid *fid)\r\n{\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct ptlrpc_request *req = NULL;\r\nstruct inode *inode = NULL;\r\nint eadatalen = 0;\r\nunsigned long hash = cl_fid_build_ino(fid,\r\nll_need_32bit_api(sbi));\r\nstruct md_op_data *op_data;\r\nint rc;\r\nCDEBUG(D_INFO, "searching inode for:(%lu,"DFID")\n", hash, PFID(fid));\r\ninode = ilookup5(sb, hash, ll_nfs_test_inode, (void *)fid);\r\nif (inode)\r\nreturn inode;\r\nrc = ll_get_max_mdsize(sbi, &eadatalen);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nOBD_ALLOC_PTR(op_data);\r\nif (op_data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nop_data->op_fid1 = *fid;\r\nop_data->op_mode = eadatalen;\r\nop_data->op_valid = OBD_MD_FLEASIZE;\r\nrc = md_getattr(sbi->ll_md_exp, op_data, &req);\r\nOBD_FREE_PTR(op_data);\r\nif (rc) {\r\nCERROR("can't get object attrs, fid "DFID", rc %d\n",\r\nPFID(fid), rc);\r\nreturn ERR_PTR(rc);\r\n}\r\nrc = ll_prep_inode(&inode, req, sb, NULL);\r\nptlrpc_req_finished(req);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn inode;\r\n}\r\nstatic struct dentry *\r\nll_iget_for_nfs(struct super_block *sb, struct lu_fid *fid, struct lu_fid *parent)\r\n{\r\nstruct inode *inode;\r\nstruct dentry *result;\r\nCDEBUG(D_INFO, "Get dentry for fid: "DFID"\n", PFID(fid));\r\nif (!fid_is_sane(fid))\r\nreturn ERR_PTR(-ESTALE);\r\ninode = search_inode_for_lustre(sb, fid);\r\nif (IS_ERR(inode))\r\nreturn ERR_CAST(inode);\r\nif (is_bad_inode(inode)) {\r\niput(inode);\r\nreturn ERR_PTR(-ESTALE);\r\n}\r\nif (S_ISREG(inode->i_mode) && !ll_i2info(inode)->lli_has_smd &&\r\nparent != NULL) {\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nspin_lock(&lli->lli_lock);\r\nlli->lli_pfid = *parent;\r\nspin_unlock(&lli->lli_lock);\r\n}\r\nresult = d_obtain_alias(inode);\r\nif (IS_ERR(result))\r\nreturn result;\r\nll_dops_init(result, 1, 0);\r\nreturn result;\r\n}\r\nstatic int ll_encode_fh(struct inode *inode, __u32 *fh, int *plen,\r\nstruct inode *parent)\r\n{\r\nstruct lustre_nfs_fid *nfs_fid = (void *)fh;\r\nCDEBUG(D_INFO, "encoding for (%lu,"DFID") maxlen=%d minlen=%d\n",\r\ninode->i_ino, PFID(ll_inode2fid(inode)), *plen,\r\n(int)sizeof(struct lustre_nfs_fid));\r\nif (*plen < sizeof(struct lustre_nfs_fid) / 4)\r\nreturn 255;\r\nnfs_fid->lnf_child = *ll_inode2fid(inode);\r\nnfs_fid->lnf_parent = *ll_inode2fid(parent);\r\n*plen = sizeof(struct lustre_nfs_fid) / 4;\r\nreturn LUSTRE_NFS_FID;\r\n}\r\nstatic int ll_nfs_get_name_filldir(void *cookie, const char *name, int namelen,\r\nloff_t hash, u64 ino, unsigned type)\r\n{\r\nstruct lu_dirent *lde = container_of0(name, struct lu_dirent, lde_name);\r\nstruct ll_getname_data *lgd = cookie;\r\nstruct lu_fid fid;\r\nfid_le_to_cpu(&fid, &lde->lde_fid);\r\nif (lu_fid_eq(&fid, &lgd->lgd_fid)) {\r\nmemcpy(lgd->lgd_name, name, namelen);\r\nlgd->lgd_name[namelen] = 0;\r\nlgd->lgd_found = 1;\r\n}\r\nreturn lgd->lgd_found;\r\n}\r\nstatic int ll_get_name(struct dentry *dentry, char *name,\r\nstruct dentry *child)\r\n{\r\nstruct inode *dir = dentry->d_inode;\r\nint rc;\r\nstruct ll_getname_data lgd = {\r\n.lgd_name = name,\r\n.lgd_fid = ll_i2info(child->d_inode)->lli_fid,\r\n.ctx.actor = ll_nfs_get_name_filldir,\r\n};\r\nif (!dir || !S_ISDIR(dir->i_mode))\r\nGOTO(out, rc = -ENOTDIR);\r\nif (!dir->i_fop)\r\nGOTO(out, rc = -EINVAL);\r\nmutex_lock(&dir->i_mutex);\r\nrc = ll_dir_read(dir, &lgd.ctx);\r\nmutex_unlock(&dir->i_mutex);\r\nif (!rc && !lgd.lgd_found)\r\nrc = -ENOENT;\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct dentry *ll_fh_to_dentry(struct super_block *sb, struct fid *fid,\r\nint fh_len, int fh_type)\r\n{\r\nstruct lustre_nfs_fid *nfs_fid = (struct lustre_nfs_fid *)fid;\r\nif (fh_type != LUSTRE_NFS_FID)\r\nreturn ERR_PTR(-EPROTO);\r\nreturn ll_iget_for_nfs(sb, &nfs_fid->lnf_child, &nfs_fid->lnf_parent);\r\n}\r\nstatic struct dentry *ll_fh_to_parent(struct super_block *sb, struct fid *fid,\r\nint fh_len, int fh_type)\r\n{\r\nstruct lustre_nfs_fid *nfs_fid = (struct lustre_nfs_fid *)fid;\r\nif (fh_type != LUSTRE_NFS_FID)\r\nreturn ERR_PTR(-EPROTO);\r\nreturn ll_iget_for_nfs(sb, &nfs_fid->lnf_parent, NULL);\r\n}\r\nstatic struct dentry *ll_get_parent(struct dentry *dchild)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct inode *dir = dchild->d_inode;\r\nstruct ll_sb_info *sbi;\r\nstruct dentry *result = NULL;\r\nstruct mdt_body *body;\r\nstatic char dotdot[] = "..";\r\nstruct md_op_data *op_data;\r\nint rc;\r\nint lmmsize;\r\nLASSERT(dir && S_ISDIR(dir->i_mode));\r\nsbi = ll_s2sbi(dir->i_sb);\r\nCDEBUG(D_INFO, "getting parent for (%lu,"DFID")\n",\r\ndir->i_ino, PFID(ll_inode2fid(dir)));\r\nrc = ll_get_max_mdsize(sbi, &lmmsize);\r\nif (rc != 0)\r\nreturn ERR_PTR(rc);\r\nop_data = ll_prep_md_op_data(NULL, dir, NULL, dotdot,\r\nstrlen(dotdot), lmmsize,\r\nLUSTRE_OPC_ANY, NULL);\r\nif (IS_ERR(op_data))\r\nreturn (void *)op_data;\r\nrc = md_getattr_name(sbi->ll_md_exp, op_data, &req);\r\nll_finish_md_op_data(op_data);\r\nif (rc) {\r\nCERROR("failure %d inode %lu get parent\n", rc, dir->i_ino);\r\nreturn ERR_PTR(rc);\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(body->valid & OBD_MD_FLID);\r\nCDEBUG(D_INFO, "parent for "DFID" is "DFID"\n",\r\nPFID(ll_inode2fid(dir)), PFID(&body->fid1));\r\nresult = ll_iget_for_nfs(dir->i_sb, &body->fid1, NULL);\r\nptlrpc_req_finished(req);\r\nreturn result;\r\n}
