static void scx200_acb_machine(struct scx200_acb_iface *iface, u8 status)\r\n{\r\nconst char *errmsg;\r\ndev_dbg(&iface->adapter.dev, "state %s, status = 0x%02x\n",\r\nscx200_acb_state_name[iface->state], status);\r\nif (status & ACBST_BER) {\r\nerrmsg = "bus error";\r\ngoto error;\r\n}\r\nif (!(status & ACBST_MASTER)) {\r\nerrmsg = "not master";\r\ngoto error;\r\n}\r\nif (status & ACBST_NEGACK) {\r\ndev_dbg(&iface->adapter.dev, "negative ack in state %s\n",\r\nscx200_acb_state_name[iface->state]);\r\niface->state = state_idle;\r\niface->result = -ENXIO;\r\noutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\r\noutb(ACBST_STASTR | ACBST_NEGACK, ACBST);\r\noutb(0, ACBST);\r\nreturn;\r\n}\r\nswitch (iface->state) {\r\ncase state_idle:\r\ndev_warn(&iface->adapter.dev, "interrupt in idle state\n");\r\nbreak;\r\ncase state_address:\r\noutb(iface->address_byte & ~1, ACBSDA);\r\niface->state = state_command;\r\nbreak;\r\ncase state_command:\r\noutb(iface->command, ACBSDA);\r\nif (iface->address_byte & 1)\r\niface->state = state_repeat_start;\r\nelse\r\niface->state = state_write;\r\nbreak;\r\ncase state_repeat_start:\r\noutb(inb(ACBCTL1) | ACBCTL1_START, ACBCTL1);\r\ncase state_quick:\r\nif (iface->address_byte & 1) {\r\nif (iface->len == 1)\r\noutb(inb(ACBCTL1) | ACBCTL1_ACK, ACBCTL1);\r\nelse\r\noutb(inb(ACBCTL1) & ~ACBCTL1_ACK, ACBCTL1);\r\noutb(iface->address_byte, ACBSDA);\r\niface->state = state_read;\r\n} else {\r\noutb(iface->address_byte, ACBSDA);\r\niface->state = state_write;\r\n}\r\nbreak;\r\ncase state_read:\r\nif (iface->len == 2)\r\noutb(inb(ACBCTL1) | ACBCTL1_ACK, ACBCTL1);\r\nelse\r\noutb(inb(ACBCTL1) & ~ACBCTL1_ACK, ACBCTL1);\r\nif (iface->len == 1) {\r\niface->result = 0;\r\niface->state = state_idle;\r\noutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\r\n}\r\n*iface->ptr++ = inb(ACBSDA);\r\n--iface->len;\r\nbreak;\r\ncase state_write:\r\nif (iface->len == 0) {\r\niface->result = 0;\r\niface->state = state_idle;\r\noutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\r\nbreak;\r\n}\r\noutb(*iface->ptr++, ACBSDA);\r\n--iface->len;\r\nbreak;\r\n}\r\nreturn;\r\nerror:\r\ndev_err(&iface->adapter.dev,\r\n"%s in state %s (addr=0x%02x, len=%d, status=0x%02x)\n", errmsg,\r\nscx200_acb_state_name[iface->state], iface->address_byte,\r\niface->len, status);\r\niface->state = state_idle;\r\niface->result = -EIO;\r\niface->needs_reset = 1;\r\n}\r\nstatic void scx200_acb_poll(struct scx200_acb_iface *iface)\r\n{\r\nu8 status;\r\nunsigned long timeout;\r\ntimeout = jiffies + POLL_TIMEOUT;\r\nwhile (1) {\r\nstatus = inb(ACBST);\r\noutb(0, ACBST);\r\nif ((status & (ACBST_SDAST|ACBST_BER|ACBST_NEGACK)) != 0) {\r\nscx200_acb_machine(iface, status);\r\nreturn;\r\n}\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\ncpu_relax();\r\ncond_resched();\r\n}\r\ndev_err(&iface->adapter.dev, "timeout in state %s\n",\r\nscx200_acb_state_name[iface->state]);\r\niface->state = state_idle;\r\niface->result = -EIO;\r\niface->needs_reset = 1;\r\n}\r\nstatic void scx200_acb_reset(struct scx200_acb_iface *iface)\r\n{\r\noutb(0x70, ACBCTL2);\r\noutb(0, ACBCTL1);\r\noutb(0, ACBADDR);\r\noutb(inb(ACBCTL2) | ACBCTL2_ENABLE, ACBCTL2);\r\noutb(inb(ACBCTL1) & ~(ACBCTL1_STASTRE | ACBCTL1_NMINTE), ACBCTL1);\r\noutb(inb(ACBCTL1) | ACBCTL1_STOP, ACBCTL1);\r\noutb(ACBST_BER | ACBST_NEGACK | ACBST_STASTR, ACBST);\r\noutb(inb(ACBCST) | ACBCST_BB, ACBCST);\r\n}\r\nstatic s32 scx200_acb_smbus_xfer(struct i2c_adapter *adapter,\r\nu16 address, unsigned short flags,\r\nchar rw, u8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nstruct scx200_acb_iface *iface = i2c_get_adapdata(adapter);\r\nint len;\r\nu8 *buffer;\r\nu16 cur_word;\r\nint rc;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nlen = 0;\r\nbuffer = NULL;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nlen = 1;\r\nbuffer = rw ? &data->byte : &command;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nlen = 1;\r\nbuffer = &data->byte;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nlen = 2;\r\ncur_word = cpu_to_le16(data->word);\r\nbuffer = (u8 *)&cur_word;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nlen = data->block[0];\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EINVAL;\r\nbuffer = &data->block[1];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&adapter->dev,\r\n"size=%d, address=0x%x, command=0x%x, len=%d, read=%d\n",\r\nsize, address, command, len, rw);\r\nif (!len && rw == I2C_SMBUS_READ) {\r\ndev_dbg(&adapter->dev, "zero length read\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&iface->mutex);\r\niface->address_byte = (address << 1) | rw;\r\niface->command = command;\r\niface->ptr = buffer;\r\niface->len = len;\r\niface->result = -EINVAL;\r\niface->needs_reset = 0;\r\noutb(inb(ACBCTL1) | ACBCTL1_START, ACBCTL1);\r\nif (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE)\r\niface->state = state_quick;\r\nelse\r\niface->state = state_address;\r\nwhile (iface->state != state_idle)\r\nscx200_acb_poll(iface);\r\nif (iface->needs_reset)\r\nscx200_acb_reset(iface);\r\nrc = iface->result;\r\nmutex_unlock(&iface->mutex);\r\nif (rc == 0 && size == I2C_SMBUS_WORD_DATA && rw == I2C_SMBUS_READ)\r\ndata->word = le16_to_cpu(cur_word);\r\n#ifdef DEBUG\r\ndev_dbg(&adapter->dev, "transfer done, result: %d", rc);\r\nif (buffer) {\r\nint i;\r\nprintk(" data:");\r\nfor (i = 0; i < len; ++i)\r\nprintk(" %02x", buffer[i]);\r\n}\r\nprintk("\n");\r\n#endif\r\nreturn rc;\r\n}\r\nstatic u32 scx200_acb_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic int scx200_acb_probe(struct scx200_acb_iface *iface)\r\n{\r\nu8 val;\r\noutb(0x70, ACBCTL2);\r\nif (inb(ACBCTL2) != 0x70) {\r\npr_debug("ACBCTL2 readback failed\n");\r\nreturn -ENXIO;\r\n}\r\noutb(inb(ACBCTL1) | ACBCTL1_NMINTE, ACBCTL1);\r\nval = inb(ACBCTL1);\r\nif (val) {\r\npr_debug("disabled, but ACBCTL1=0x%02x\n", val);\r\nreturn -ENXIO;\r\n}\r\noutb(inb(ACBCTL2) | ACBCTL2_ENABLE, ACBCTL2);\r\noutb(inb(ACBCTL1) | ACBCTL1_NMINTE, ACBCTL1);\r\nval = inb(ACBCTL1);\r\nif ((val & ACBCTL1_NMINTE) != ACBCTL1_NMINTE) {\r\npr_debug("enabled, but NMINTE won't be set, ACBCTL1=0x%02x\n",\r\nval);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct scx200_acb_iface *scx200_create_iface(const char *text,\r\nstruct device *dev, int index)\r\n{\r\nstruct scx200_acb_iface *iface;\r\nstruct i2c_adapter *adapter;\r\niface = kzalloc(sizeof(*iface), GFP_KERNEL);\r\nif (!iface) {\r\npr_err("can't allocate memory\n");\r\nreturn NULL;\r\n}\r\nadapter = &iface->adapter;\r\ni2c_set_adapdata(adapter, iface);\r\nsnprintf(adapter->name, sizeof(adapter->name), "%s ACB%d", text, index);\r\nadapter->owner = THIS_MODULE;\r\nadapter->algo = &scx200_acb_algorithm;\r\nadapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadapter->dev.parent = dev;\r\nmutex_init(&iface->mutex);\r\nreturn iface;\r\n}\r\nstatic int scx200_acb_create(struct scx200_acb_iface *iface)\r\n{\r\nstruct i2c_adapter *adapter;\r\nint rc;\r\nadapter = &iface->adapter;\r\nrc = scx200_acb_probe(iface);\r\nif (rc) {\r\npr_warn("probe failed\n");\r\nreturn rc;\r\n}\r\nscx200_acb_reset(iface);\r\nif (i2c_add_adapter(adapter) < 0) {\r\npr_err("failed to register\n");\r\nreturn -ENODEV;\r\n}\r\nif (!adapter->dev.parent) {\r\nmutex_lock(&scx200_acb_list_mutex);\r\niface->next = scx200_acb_list;\r\nscx200_acb_list = iface;\r\nmutex_unlock(&scx200_acb_list_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct scx200_acb_iface *scx200_create_dev(const char *text,\r\nunsigned long base, int index, struct device *dev)\r\n{\r\nstruct scx200_acb_iface *iface;\r\nint rc;\r\niface = scx200_create_iface(text, dev, index);\r\nif (iface == NULL)\r\nreturn NULL;\r\nif (!request_region(base, 8, iface->adapter.name)) {\r\npr_err("can't allocate io 0x%lx-0x%lx\n", base, base + 8 - 1);\r\ngoto errout_free;\r\n}\r\niface->base = base;\r\nrc = scx200_acb_create(iface);\r\nif (rc == 0)\r\nreturn iface;\r\nrelease_region(base, 8);\r\nerrout_free:\r\nkfree(iface);\r\nreturn NULL;\r\n}\r\nstatic int scx200_probe(struct platform_device *pdev)\r\n{\r\nstruct scx200_acb_iface *iface;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't fetch device resource info\n");\r\nreturn -ENODEV;\r\n}\r\niface = scx200_create_dev("CS5535", res->start, 0, &pdev->dev);\r\nif (!iface)\r\nreturn -EIO;\r\ndev_info(&pdev->dev, "SCx200 device '%s' registered\n",\r\niface->adapter.name);\r\nplatform_set_drvdata(pdev, iface);\r\nreturn 0;\r\n}\r\nstatic void scx200_cleanup_iface(struct scx200_acb_iface *iface)\r\n{\r\ni2c_del_adapter(&iface->adapter);\r\nrelease_region(iface->base, 8);\r\nkfree(iface);\r\n}\r\nstatic int scx200_remove(struct platform_device *pdev)\r\n{\r\nstruct scx200_acb_iface *iface;\r\niface = platform_get_drvdata(pdev);\r\nscx200_cleanup_iface(iface);\r\nreturn 0;\r\n}\r\nstatic __init void scx200_scan_isa(void)\r\n{\r\nint i;\r\nif (!pci_dev_present(scx200_isa))\r\nreturn;\r\nfor (i = 0; i < MAX_DEVICES; ++i) {\r\nif (base[i] == 0)\r\ncontinue;\r\nscx200_create_dev("SCx200", base[i], i, NULL);\r\n}\r\n}\r\nstatic int __init scx200_acb_init(void)\r\n{\r\npr_debug("NatSemi SCx200 ACCESS.bus Driver\n");\r\nscx200_scan_isa();\r\nif (scx200_acb_list)\r\nreturn 0;\r\nreturn platform_driver_register(&scx200_pci_driver);\r\n}\r\nstatic void __exit scx200_acb_cleanup(void)\r\n{\r\nstruct scx200_acb_iface *iface;\r\nplatform_driver_unregister(&scx200_pci_driver);\r\nmutex_lock(&scx200_acb_list_mutex);\r\nwhile ((iface = scx200_acb_list) != NULL) {\r\nscx200_acb_list = iface->next;\r\nmutex_unlock(&scx200_acb_list_mutex);\r\nscx200_cleanup_iface(iface);\r\nmutex_lock(&scx200_acb_list_mutex);\r\n}\r\nmutex_unlock(&scx200_acb_list_mutex);\r\n}
