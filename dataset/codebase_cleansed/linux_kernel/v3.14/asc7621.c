static inline u8 read_byte(struct i2c_client *client, u8 reg)\r\n{\r\nint res = i2c_smbus_read_byte_data(client, reg);\r\nif (res < 0) {\r\ndev_err(&client->dev,\r\n"Unable to read from register 0x%02x.\n", reg);\r\nreturn 0;\r\n}\r\nreturn res & 0xff;\r\n}\r\nstatic inline int write_byte(struct i2c_client *client, u8 reg, u8 data)\r\n{\r\nint res = i2c_smbus_write_byte_data(client, reg, data);\r\nif (res < 0) {\r\ndev_err(&client->dev,\r\n"Unable to write value 0x%02x to register 0x%02x.\n",\r\ndata, reg);\r\n}\r\nreturn res;\r\n}\r\nstatic ssize_t show_u8(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nreturn sprintf(buf, "%u\n", data->reg[param->msb[0]]);\r\n}\r\nstatic ssize_t store_u8(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval = clamp_val(reqval, 0, 255);\r\nmutex_lock(&data->update_lock);\r\ndata->reg[param->msb[0]] = reqval;\r\nwrite_byte(client, param->msb[0], reqval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_bitmask(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nreturn sprintf(buf, "%u\n",\r\n(data->reg[param->msb[0]] >> param->\r\nshift[0]) & param->mask[0]);\r\n}\r\nstatic ssize_t store_bitmask(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nu8 currval;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval = clamp_val(reqval, 0, param->mask[0]);\r\nreqval = (reqval & param->mask[0]) << param->shift[0];\r\nmutex_lock(&data->update_lock);\r\ncurrval = read_byte(client, param->msb[0]);\r\nreqval |= (currval & ~(param->mask[0] << param->shift[0]));\r\ndata->reg[param->msb[0]] = reqval;\r\nwrite_byte(client, param->msb[0], reqval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan16(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu16 regval;\r\nmutex_lock(&data->update_lock);\r\nregval = (data->reg[param->msb[0]] << 8) | data->reg[param->lsb[0]];\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n",\r\n(regval == 0 ? -1 : (regval) ==\r\n0xffff ? 0 : 5400000 / regval));\r\n}\r\nstatic ssize_t store_fan16(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval =\r\n(reqval <= 0 ? 0xffff : clamp_val(5400000 / reqval, 0, 0xfffe));\r\nmutex_lock(&data->update_lock);\r\ndata->reg[param->msb[0]] = (reqval >> 8) & 0xff;\r\ndata->reg[param->lsb[0]] = reqval & 0xff;\r\nwrite_byte(client, param->msb[0], data->reg[param->msb[0]]);\r\nwrite_byte(client, param->lsb[0], data->reg[param->lsb[0]]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in10(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu16 regval;\r\nu8 nr = sda->index;\r\nmutex_lock(&data->update_lock);\r\nregval = (data->reg[param->msb[0]] << 8) | (data->reg[param->lsb[0]]);\r\nmutex_unlock(&data->update_lock);\r\nregval = (regval >> 6) * asc7621_in_scaling[nr] / (0xc0 << 2);\r\nreturn sprintf(buf, "%u\n", regval);\r\n}\r\nstatic ssize_t show_in8(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 nr = sda->index;\r\nreturn sprintf(buf, "%u\n",\r\n((data->reg[param->msb[0]] *\r\nasc7621_in_scaling[nr]) / 0xc0));\r\n}\r\nstatic ssize_t store_in8(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nu8 nr = sda->index;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval = clamp_val(reqval, 0, 0xffff);\r\nreqval = reqval * 0xc0 / asc7621_in_scaling[nr];\r\nreqval = clamp_val(reqval, 0, 0xff);\r\nmutex_lock(&data->update_lock);\r\ndata->reg[param->msb[0]] = reqval;\r\nwrite_byte(client, param->msb[0], reqval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp8(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nreturn sprintf(buf, "%d\n", ((s8) data->reg[param->msb[0]]) * 1000);\r\n}\r\nstatic ssize_t store_temp8(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\ns8 temp;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval = clamp_val(reqval, -127000, 127000);\r\ntemp = reqval / 1000;\r\nmutex_lock(&data->update_lock);\r\ndata->reg[param->msb[0]] = temp;\r\nwrite_byte(client, param->msb[0], temp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp10(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 msb, lsb;\r\nint temp;\r\nmutex_lock(&data->update_lock);\r\nmsb = data->reg[param->msb[0]];\r\nlsb = (data->reg[param->lsb[0]] >> 6) & 0x03;\r\ntemp = (((s8) msb) * 1000) + (lsb * 250);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t show_temp62(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 regval = data->reg[param->msb[0]];\r\nint temp = ((s8) (regval & 0xfc) * 1000) + ((regval & 0x03) * 250);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t store_temp62(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval, i, f;\r\ns8 temp;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nreqval = clamp_val(reqval, -32000, 31750);\r\ni = reqval / 1000;\r\nf = reqval - (i * 1000);\r\ntemp = i << 2;\r\ntemp |= f / 250;\r\nmutex_lock(&data->update_lock);\r\ndata->reg[param->msb[0]] = temp;\r\nwrite_byte(client, param->msb[0], temp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_ap2_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nlong auto_point1;\r\nu8 regval;\r\nint temp;\r\nmutex_lock(&data->update_lock);\r\nauto_point1 = ((s8) data->reg[param->msb[1]]) * 1000;\r\nregval =\r\n((data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0]);\r\ntemp = auto_point1 + asc7621_range_map[clamp_val(regval, 0, 15)];\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t store_ap2_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval, auto_point1;\r\nint i;\r\nu8 currval, newval = 0;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nauto_point1 = data->reg[param->msb[1]] * 1000;\r\nreqval = clamp_val(reqval, auto_point1 + 2000, auto_point1 + 80000);\r\nfor (i = ARRAY_SIZE(asc7621_range_map) - 1; i >= 0; i--) {\r\nif (reqval >= auto_point1 + asc7621_range_map[i]) {\r\nnewval = i;\r\nbreak;\r\n}\r\n}\r\nnewval = (newval & param->mask[0]) << param->shift[0];\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval |= (currval & ~(param->mask[0] << param->shift[0]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_ac(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 config, altbit, regval;\r\nu8 map[] = {\r\n0x01, 0x02, 0x04, 0x1f, 0x00, 0x06, 0x07, 0x10,\r\n0x08, 0x0f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f\r\n};\r\nmutex_lock(&data->update_lock);\r\nconfig = (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\r\naltbit = (data->reg[param->msb[1]] >> param->shift[1]) & param->mask[1];\r\nregval = config | (altbit << 3);\r\nmutex_unlock(&data->update_lock);\r\nreturn sprintf(buf, "%u\n", map[clamp_val(regval, 0, 15)]);\r\n}\r\nstatic ssize_t store_pwm_ac(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nunsigned long reqval;\r\nu8 currval, config, altbit, newval;\r\nu16 map[] = {\r\n0x04, 0x00, 0x01, 0xff, 0x02, 0xff, 0x05, 0x06,\r\n0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,\r\n0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,\r\n};\r\nif (kstrtoul(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nif (reqval > 31)\r\nreturn -EINVAL;\r\nreqval = map[reqval];\r\nif (reqval == 0xff)\r\nreturn -EINVAL;\r\nconfig = reqval & 0x07;\r\naltbit = (reqval >> 3) & 0x01;\r\nconfig = (config & param->mask[0]) << param->shift[0];\r\naltbit = (altbit & param->mask[1]) << param->shift[1];\r\nmutex_lock(&data->update_lock);\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval = config | (currval & ~(param->mask[0] << param->shift[0]));\r\nnewval = altbit | (newval & ~(param->mask[1] << param->shift[1]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 config, altbit, minoff, val, newval;\r\nmutex_lock(&data->update_lock);\r\nconfig = (data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\r\naltbit = (data->reg[param->msb[1]] >> param->shift[1]) & param->mask[1];\r\nminoff = (data->reg[param->msb[2]] >> param->shift[2]) & param->mask[2];\r\nmutex_unlock(&data->update_lock);\r\nval = config | (altbit << 3);\r\nnewval = 0;\r\nif (val == 3 || val >= 10)\r\nnewval = 255;\r\nelse if (val == 4)\r\nnewval = 0;\r\nelse if (val == 7)\r\nnewval = 1;\r\nelse if (minoff == 1)\r\nnewval = 2;\r\nelse\r\nnewval = 3;\r\nreturn sprintf(buf, "%u\n", newval);\r\n}\r\nstatic ssize_t store_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nu8 currval, config, altbit, newval, minoff = 255;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nswitch (reqval) {\r\ncase 0:\r\nnewval = 0x04;\r\nbreak;\r\ncase 1:\r\nnewval = 0x07;\r\nbreak;\r\ncase 2:\r\nnewval = 0x00;\r\nminoff = 1;\r\nbreak;\r\ncase 3:\r\nnewval = 0x00;\r\nminoff = 0;\r\nbreak;\r\ncase 255:\r\nnewval = 0x03;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nconfig = newval & 0x07;\r\naltbit = (newval >> 3) & 0x01;\r\nmutex_lock(&data->update_lock);\r\nconfig = (config & param->mask[0]) << param->shift[0];\r\naltbit = (altbit & param->mask[1]) << param->shift[1];\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval = config | (currval & ~(param->mask[0] << param->shift[0]));\r\nnewval = altbit | (newval & ~(param->mask[1] << param->shift[1]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nif (minoff < 255) {\r\nminoff = (minoff & param->mask[2]) << param->shift[2];\r\ncurrval = read_byte(client, param->msb[2]);\r\nnewval =\r\nminoff | (currval & ~(param->mask[2] << param->shift[2]));\r\ndata->reg[param->msb[2]] = newval;\r\nwrite_byte(client, param->msb[2], newval);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 regval =\r\n(data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\r\nregval = clamp_val(regval, 0, 15);\r\nreturn sprintf(buf, "%u\n", asc7621_pwm_freq_map[regval]);\r\n}\r\nstatic ssize_t store_pwm_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nunsigned long reqval;\r\nu8 currval, newval = 255;\r\nint i;\r\nif (kstrtoul(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_pwm_freq_map); i++) {\r\nif (reqval == asc7621_pwm_freq_map[i]) {\r\nnewval = i;\r\nbreak;\r\n}\r\n}\r\nif (newval == 255)\r\nreturn -EINVAL;\r\nnewval = (newval & param->mask[0]) << param->shift[0];\r\nmutex_lock(&data->update_lock);\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval |= (currval & ~(param->mask[0] << param->shift[0]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_ast(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 regval =\r\n(data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\r\nregval = clamp_val(regval, 0, 7);\r\nreturn sprintf(buf, "%u\n", asc7621_pwm_auto_spinup_map[regval]);\r\n}\r\nstatic ssize_t store_pwm_ast(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nu8 currval, newval = 255;\r\nu32 i;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_pwm_auto_spinup_map); i++) {\r\nif (reqval == asc7621_pwm_auto_spinup_map[i]) {\r\nnewval = i;\r\nbreak;\r\n}\r\n}\r\nif (newval == 255)\r\nreturn -EINVAL;\r\nnewval = (newval & param->mask[0]) << param->shift[0];\r\nmutex_lock(&data->update_lock);\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval |= (currval & ~(param->mask[0] << param->shift[0]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_st(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nSETUP_SHOW_DATA_PARAM(dev, attr);\r\nu8 regval =\r\n(data->reg[param->msb[0]] >> param->shift[0]) & param->mask[0];\r\nregval = clamp_val(regval, 0, 7);\r\nreturn sprintf(buf, "%u\n", asc7621_temp_smoothing_time_map[regval]);\r\n}\r\nstatic ssize_t store_temp_st(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nSETUP_STORE_DATA_PARAM(dev, attr);\r\nlong reqval;\r\nu8 currval, newval = 255;\r\nu32 i;\r\nif (kstrtol(buf, 10, &reqval))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_temp_smoothing_time_map); i++) {\r\nif (reqval == asc7621_temp_smoothing_time_map[i]) {\r\nnewval = i;\r\nbreak;\r\n}\r\n}\r\nif (newval == 255)\r\nreturn -EINVAL;\r\nnewval = (newval & param->mask[0]) << param->shift[0];\r\nmutex_lock(&data->update_lock);\r\ncurrval = read_byte(client, param->msb[0]);\r\nnewval |= (currval & ~(param->mask[0] << param->shift[0]));\r\ndata->reg[param->msb[0]] = newval;\r\nwrite_byte(client, param->msb[0], newval);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic struct asc7621_data *asc7621_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct asc7621_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_high_reading + INTERVAL_HIGH)) {\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_register_priorities); i++) {\r\nif (asc7621_register_priorities[i] == PRI_HIGH) {\r\ndata->reg[i] =\r\ni2c_smbus_read_byte_data(client, i) & 0xff;\r\n}\r\n}\r\ndata->last_high_reading = jiffies;\r\n}\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_low_reading + INTERVAL_LOW)) {\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\r\nif (asc7621_register_priorities[i] == PRI_LOW) {\r\ndata->reg[i] =\r\ni2c_smbus_read_byte_data(client, i) & 0xff;\r\n}\r\n}\r\ndata->last_low_reading = jiffies;\r\n}\r\ndata->valid = 1;\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic inline int valid_address_for_chip(int chip_type, int address)\r\n{\r\nint i;\r\nfor (i = 0; asc7621_chips[chip_type].addresses[i] != I2C_CLIENT_END;\r\ni++) {\r\nif (asc7621_chips[chip_type].addresses[i] == address)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void asc7621_init_client(struct i2c_client *client)\r\n{\r\nint value;\r\nvalue = read_byte(client, 0x40);\r\nif (value & 0x02) {\r\ndev_err(&client->dev,\r\n"Client (%d,0x%02x) config is locked.\n",\r\ni2c_adapter_id(client->adapter), client->addr);\r\n}\r\nif (!(value & 0x04)) {\r\ndev_err(&client->dev, "Client (%d,0x%02x) is not ready.\n",\r\ni2c_adapter_id(client->adapter), client->addr);\r\n}\r\nvalue = (value & ~0x02) | 0x01;\r\nwrite_byte(client, 0x40, value & 0xff);\r\n}\r\nstatic int\r\nasc7621_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct asc7621_data *data;\r\nint i, err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct asc7621_data),\r\nGFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->valid = 0;\r\nmutex_init(&data->update_lock);\r\nasc7621_init_client(client);\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\r\nerr =\r\ndevice_create_file(&client->dev,\r\n&(asc7621_params[i].sda.dev_attr));\r\nif (err)\r\ngoto exit_remove;\r\n}\r\ndata->class_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->class_dev)) {\r\nerr = PTR_ERR(data->class_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\r\ndevice_remove_file(&client->dev,\r\n&(asc7621_params[i].sda.dev_attr));\r\n}\r\nreturn err;\r\n}\r\nstatic int asc7621_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint company, verstep, chip_index;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nfor (chip_index = FIRST_CHIP; chip_index <= LAST_CHIP; chip_index++) {\r\nif (!valid_address_for_chip(chip_index, client->addr))\r\ncontinue;\r\ncompany = read_byte(client,\r\nasc7621_chips[chip_index].company_reg);\r\nverstep = read_byte(client,\r\nasc7621_chips[chip_index].verstep_reg);\r\nif (company == asc7621_chips[chip_index].company_id &&\r\nverstep == asc7621_chips[chip_index].verstep_id) {\r\nstrlcpy(info->type, asc7621_chips[chip_index].name,\r\nI2C_NAME_SIZE);\r\ndev_info(&adapter->dev, "Matched %s at 0x%02x\n",\r\nasc7621_chips[chip_index].name, client->addr);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int asc7621_remove(struct i2c_client *client)\r\n{\r\nstruct asc7621_data *data = i2c_get_clientdata(client);\r\nint i;\r\nhwmon_device_unregister(data->class_dev);\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\r\ndevice_remove_file(&client->dev,\r\n&(asc7621_params[i].sda.dev_attr));\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sm_asc7621_init(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(asc7621_params); i++) {\r\nfor (j = 0; j < ARRAY_SIZE(asc7621_params[i].msb); j++)\r\nasc7621_register_priorities[asc7621_params[i].msb[j]] =\r\nasc7621_params[i].priority;\r\nfor (j = 0; j < ARRAY_SIZE(asc7621_params[i].lsb); j++)\r\nasc7621_register_priorities[asc7621_params[i].lsb[j]] =\r\nasc7621_params[i].priority;\r\n}\r\nreturn i2c_add_driver(&asc7621_driver);\r\n}\r\nstatic void __exit sm_asc7621_exit(void)\r\n{\r\ni2c_del_driver(&asc7621_driver);\r\n}
