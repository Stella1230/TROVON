static int __init pcie_port_setup(char *str)\r\n{\r\nif (!strncmp(str, "compat", 6)) {\r\npcie_ports_disabled = true;\r\n} else if (!strncmp(str, "native", 6)) {\r\npcie_ports_disabled = false;\r\npcie_ports_auto = false;\r\n} else if (!strncmp(str, "auto", 4)) {\r\npcie_ports_disabled = false;\r\npcie_ports_auto = true;\r\n}\r\nreturn 1;\r\n}\r\nvoid pcie_clear_root_pme_status(struct pci_dev *dev)\r\n{\r\npcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);\r\n}\r\nstatic int pcie_portdrv_restore_config(struct pci_dev *dev)\r\n{\r\nint retval;\r\nretval = pci_enable_device(dev);\r\nif (retval)\r\nreturn retval;\r\npci_set_master(dev);\r\nreturn 0;\r\n}\r\nstatic int pcie_port_resume_noirq(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)\r\npcie_clear_root_pme_status(pdev);\r\nreturn 0;\r\n}\r\nstatic int pci_dev_d3cold_info(struct pci_dev *pdev, void *data)\r\n{\r\nstruct d3cold_info *info = data;\r\ninfo->d3cold_delay = max_t(unsigned int, pdev->d3cold_delay,\r\ninfo->d3cold_delay);\r\nif (pdev->no_d3cold)\r\ninfo->no_d3cold = true;\r\nreturn 0;\r\n}\r\nstatic int pcie_port_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct d3cold_info d3cold_info = {\r\n.no_d3cold = false,\r\n.d3cold_delay = PCI_PM_D3_WAIT,\r\n};\r\npci_walk_bus(pdev->subordinate, pci_dev_d3cold_info, &d3cold_info);\r\npdev->no_d3cold = d3cold_info.no_d3cold;\r\npdev->d3cold_delay = d3cold_info.d3cold_delay;\r\nreturn 0;\r\n}\r\nstatic int pcie_port_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pci_dev_pme_poll(struct pci_dev *pdev, void *data)\r\n{\r\nbool *pme_poll = data;\r\nif (pdev->pme_poll)\r\n*pme_poll = true;\r\nreturn 0;\r\n}\r\nstatic int pcie_port_runtime_idle(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nbool pme_poll = false;\r\npci_walk_bus(pdev->subordinate, pci_dev_pme_poll, &pme_poll);\r\nif (!pme_poll)\r\npm_schedule_suspend(dev, 10);\r\nreturn -EBUSY;\r\n}\r\nstatic int pcie_portdrv_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint status;\r\nif (!pci_is_pcie(dev) ||\r\n((pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT) &&\r\n(pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM) &&\r\n(pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)))\r\nreturn -ENODEV;\r\nif (!dev->irq && dev->pin) {\r\ndev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "\r\n"check vendor BIOS\n", dev->vendor, dev->device);\r\n}\r\nstatus = pcie_port_device_register(dev);\r\nif (status)\r\nreturn status;\r\npci_save_state(dev);\r\ndev->d3cold_allowed = false;\r\nreturn 0;\r\n}\r\nstatic void pcie_portdrv_remove(struct pci_dev *dev)\r\n{\r\npcie_port_device_remove(dev);\r\n}\r\nstatic int error_detected_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\nstruct aer_broadcast_data *result_data;\r\npci_ers_result_t status;\r\nresult_data = (struct aer_broadcast_data *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (!driver ||\r\n!driver->err_handler ||\r\n!driver->err_handler->error_detected)\r\nreturn 0;\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->error_detected(\r\npcie_device->port,\r\nresult_data->state);\r\nresult_data->result =\r\nmerge_result(result_data->result, status);\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,\r\nenum pci_channel_state error)\r\n{\r\nstruct aer_broadcast_data data = {error, PCI_ERS_RESULT_CAN_RECOVER};\r\ndevice_for_each_child(&dev->dev, &data, error_detected_iter);\r\nreturn data.result;\r\n}\r\nstatic int mmio_enabled_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\npci_ers_result_t status, *result;\r\nresult = (pci_ers_result_t *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->mmio_enabled) {\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->mmio_enabled(\r\npcie_device->port);\r\n*result = merge_result(*result, status);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)\r\n{\r\npci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;\r\ndevice_for_each_child(&dev->dev, &status, mmio_enabled_iter);\r\nreturn status;\r\n}\r\nstatic int slot_reset_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\npci_ers_result_t status, *result;\r\nresult = (pci_ers_result_t *) data;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->slot_reset) {\r\npcie_device = to_pcie_device(device);\r\nstatus = driver->err_handler->slot_reset(\r\npcie_device->port);\r\n*result = merge_result(*result, status);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)\r\n{\r\npci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;\r\nif (dev->error_state == pci_channel_io_frozen) {\r\ndev->state_saved = true;\r\npci_restore_state(dev);\r\npcie_portdrv_restore_config(dev);\r\npci_enable_pcie_error_reporting(dev);\r\n}\r\ndevice_for_each_child(&dev->dev, &status, slot_reset_iter);\r\nreturn status;\r\n}\r\nstatic int resume_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device *pcie_device;\r\nstruct pcie_port_service_driver *driver;\r\nif (device->bus == &pcie_port_bus_type && device->driver) {\r\ndriver = to_service_driver(device->driver);\r\nif (driver &&\r\ndriver->err_handler &&\r\ndriver->err_handler->resume) {\r\npcie_device = to_pcie_device(device);\r\ndriver->err_handler->resume(pcie_device->port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_portdrv_err_resume(struct pci_dev *dev)\r\n{\r\ndevice_for_each_child(&dev->dev, NULL, resume_iter);\r\n}\r\nstatic int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)\r\n{\r\npr_notice("%s detected: will not use MSI for PCIe PME signaling\n",\r\nd->ident);\r\npcie_pme_disable_msi();\r\nreturn 0;\r\n}\r\nstatic int __init pcie_portdrv_init(void)\r\n{\r\nint retval;\r\nif (pcie_ports_disabled)\r\nreturn pci_register_driver(&pcie_portdriver);\r\ndmi_check_system(pcie_portdrv_dmi_table);\r\nretval = pcie_port_bus_register();\r\nif (retval) {\r\nprintk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);\r\ngoto out;\r\n}\r\nretval = pci_register_driver(&pcie_portdriver);\r\nif (retval)\r\npcie_port_bus_unregister();\r\nout:\r\nreturn retval;\r\n}
