static ssize_t do_coredump_read(int num, struct spu_context *ctx, void *buffer,\r\nsize_t size, loff_t *off)\r\n{\r\nu64 data;\r\nint ret;\r\nif (spufs_coredump_read[num].read)\r\nreturn spufs_coredump_read[num].read(ctx, buffer, size, off);\r\ndata = spufs_coredump_read[num].get(ctx);\r\nret = snprintf(buffer, size, "0x%.16llx", data);\r\nif (ret >= size)\r\nreturn size;\r\nreturn ++ret;\r\n}\r\nstatic int spufs_ctx_note_size(struct spu_context *ctx, int dfd)\r\n{\r\nint i, sz, total = 0;\r\nchar *name;\r\nchar fullname[80];\r\nfor (i = 0; spufs_coredump_read[i].name != NULL; i++) {\r\nname = spufs_coredump_read[i].name;\r\nsz = spufs_coredump_read[i].size;\r\nsprintf(fullname, "SPU/%d/%s", dfd, name);\r\ntotal += sizeof(struct elf_note);\r\ntotal += roundup(strlen(fullname) + 1, 4);\r\ntotal += roundup(sz, 4);\r\n}\r\nreturn total;\r\n}\r\nstatic int match_context(const void *v, struct file *file, unsigned fd)\r\n{\r\nstruct spu_context *ctx;\r\nif (file->f_op != &spufs_context_fops)\r\nreturn 0;\r\nctx = SPUFS_I(file_inode(file))->i_ctx;\r\nif (ctx->flags & SPU_CREATE_NOSCHED)\r\nreturn 0;\r\nreturn fd + 1;\r\n}\r\nstatic struct spu_context *coredump_next_context(int *fd)\r\n{\r\nstruct file *file;\r\nint n = iterate_fd(current->files, *fd, match_context, NULL);\r\nif (!n)\r\nreturn NULL;\r\n*fd = n - 1;\r\nfile = fcheck(*fd);\r\nreturn SPUFS_I(file_inode(file))->i_ctx;\r\n}\r\nint spufs_coredump_extra_notes_size(void)\r\n{\r\nstruct spu_context *ctx;\r\nint size = 0, rc, fd;\r\nfd = 0;\r\nwhile ((ctx = coredump_next_context(&fd)) != NULL) {\r\nrc = spu_acquire_saved(ctx);\r\nif (rc)\r\nbreak;\r\nrc = spufs_ctx_note_size(ctx, fd);\r\nspu_release_saved(ctx);\r\nif (rc < 0)\r\nbreak;\r\nsize += rc;\r\nfd++;\r\n}\r\nreturn size;\r\n}\r\nstatic int spufs_arch_write_note(struct spu_context *ctx, int i,\r\nstruct coredump_params *cprm, int dfd)\r\n{\r\nloff_t pos = 0;\r\nint sz, rc, total = 0;\r\nconst int bufsz = PAGE_SIZE;\r\nchar *name;\r\nchar fullname[80], *buf;\r\nstruct elf_note en;\r\nbuf = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nname = spufs_coredump_read[i].name;\r\nsz = spufs_coredump_read[i].size;\r\nsprintf(fullname, "SPU/%d/%s", dfd, name);\r\nen.n_namesz = strlen(fullname) + 1;\r\nen.n_descsz = sz;\r\nen.n_type = NT_SPU;\r\nif (!dump_emit(cprm, &en, sizeof(en)))\r\ngoto Eio;\r\nif (!dump_emit(cprm, fullname, en.n_namesz))\r\ngoto Eio;\r\nif (!dump_align(cprm, 4))\r\ngoto Eio;\r\ndo {\r\nrc = do_coredump_read(i, ctx, buf, bufsz, &pos);\r\nif (rc > 0) {\r\nif (!dump_emit(cprm, buf, rc))\r\ngoto Eio;\r\ntotal += rc;\r\n}\r\n} while (rc == bufsz && total < sz);\r\nif (rc < 0)\r\ngoto out;\r\nif (!dump_skip(cprm,\r\nroundup(cprm->written - total + sz, 4) - cprm->written))\r\ngoto Eio;\r\nout:\r\nfree_page((unsigned long)buf);\r\nreturn rc;\r\nEio:\r\nfree_page((unsigned long)buf);\r\nreturn -EIO;\r\n}\r\nint spufs_coredump_extra_notes_write(struct coredump_params *cprm)\r\n{\r\nstruct spu_context *ctx;\r\nint fd, j, rc;\r\nfd = 0;\r\nwhile ((ctx = coredump_next_context(&fd)) != NULL) {\r\nrc = spu_acquire_saved(ctx);\r\nif (rc)\r\nreturn rc;\r\nfor (j = 0; spufs_coredump_read[j].name != NULL; j++) {\r\nrc = spufs_arch_write_note(ctx, j, cprm, fd);\r\nif (rc) {\r\nspu_release_saved(ctx);\r\nreturn rc;\r\n}\r\n}\r\nspu_release_saved(ctx);\r\nfd++;\r\n}\r\nreturn 0;\r\n}
