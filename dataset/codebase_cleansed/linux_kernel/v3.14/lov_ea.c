static int lsm_lmm_verify_common(struct lov_mds_md *lmm, int lmm_bytes,\r\n__u16 stripe_count)\r\n{\r\nif (stripe_count > LOV_V1_INSANE_STRIPE_COUNT) {\r\nCERROR("bad stripe count %d\n", stripe_count);\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lmm_oi_id(&lmm->lmm_oi) == 0) {\r\nCERROR("zero object id\n");\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lov_pattern(le32_to_cpu(lmm->lmm_pattern)) != LOV_PATTERN_RAID0) {\r\nCERROR("bad striping pattern\n");\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (lmm->lmm_stripe_size == 0 ||\r\n(le32_to_cpu(lmm->lmm_stripe_size)&(LOV_MIN_STRIPE_SIZE-1)) != 0) {\r\nCERROR("bad stripe size %u\n",\r\nle32_to_cpu(lmm->lmm_stripe_size));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct lov_stripe_md *lsm_alloc_plain(__u16 stripe_count, int *size)\r\n{\r\nstruct lov_stripe_md *lsm;\r\nstruct lov_oinfo *loi;\r\nint i, oinfo_ptrs_size;\r\nLASSERT(stripe_count <= LOV_MAX_STRIPE_COUNT);\r\noinfo_ptrs_size = sizeof(struct lov_oinfo *) * stripe_count;\r\n*size = sizeof(struct lov_stripe_md) + oinfo_ptrs_size;\r\nOBD_ALLOC_LARGE(lsm, *size);\r\nif (!lsm)\r\nreturn NULL;;\r\nfor (i = 0; i < stripe_count; i++) {\r\nOBD_SLAB_ALLOC_PTR_GFP(loi, lov_oinfo_slab, __GFP_IO);\r\nif (loi == NULL)\r\ngoto err;\r\nlsm->lsm_oinfo[i] = loi;\r\n}\r\nlsm->lsm_stripe_count = stripe_count;\r\nreturn lsm;\r\nerr:\r\nwhile (--i >= 0)\r\nOBD_SLAB_FREE(lsm->lsm_oinfo[i], lov_oinfo_slab, sizeof(*loi));\r\nOBD_FREE_LARGE(lsm, *size);\r\nreturn NULL;\r\n}\r\nvoid lsm_free_plain(struct lov_stripe_md *lsm)\r\n{\r\n__u16 stripe_count = lsm->lsm_stripe_count;\r\nint i;\r\nfor (i = 0; i < stripe_count; i++)\r\nOBD_SLAB_FREE(lsm->lsm_oinfo[i], lov_oinfo_slab,\r\nsizeof(struct lov_oinfo));\r\nOBD_FREE_LARGE(lsm, sizeof(struct lov_stripe_md) +\r\nstripe_count * sizeof(struct lov_oinfo *));\r\n}\r\nstatic void lsm_unpackmd_common(struct lov_stripe_md *lsm,\r\nstruct lov_mds_md *lmm)\r\n{\r\nlmm_oi_le_to_cpu(&lsm->lsm_oi, &lmm->lmm_oi);\r\nlsm->lsm_stripe_size = le32_to_cpu(lmm->lmm_stripe_size);\r\nlsm->lsm_pattern = le32_to_cpu(lmm->lmm_pattern);\r\nlsm->lsm_layout_gen = le16_to_cpu(lmm->lmm_layout_gen);\r\nlsm->lsm_pool_name[0] = '\0';\r\n}\r\nstatic void\r\nlsm_stripe_by_index_plain(struct lov_stripe_md *lsm, int *stripeno,\r\nobd_off *lov_off, obd_off *swidth)\r\n{\r\nif (swidth)\r\n*swidth = (obd_off)lsm->lsm_stripe_size * lsm->lsm_stripe_count;\r\n}\r\nstatic void\r\nlsm_stripe_by_offset_plain(struct lov_stripe_md *lsm, int *stripeno,\r\nobd_off *lov_off, obd_off *swidth)\r\n{\r\nif (swidth)\r\n*swidth = (obd_off)lsm->lsm_stripe_size * lsm->lsm_stripe_count;\r\n}\r\nstatic int lsm_destroy_plain(struct lov_stripe_md *lsm, struct obdo *oa,\r\nstruct obd_export *md_exp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lov_tgt_maxbytes(struct lov_tgt_desc *tgt, __u64 *stripe_maxbytes)\r\n{\r\nstruct obd_import *imp = tgt->ltd_obd->u.cli.cl_import;\r\nif (imp == NULL || !tgt->ltd_active) {\r\n*stripe_maxbytes = LUSTRE_STRIPE_MAXBYTES;\r\nreturn;\r\n}\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_FULL &&\r\n(imp->imp_connect_data.ocd_connect_flags & OBD_CONNECT_MAXBYTES) &&\r\nimp->imp_connect_data.ocd_maxbytes > 0) {\r\nif (*stripe_maxbytes > imp->imp_connect_data.ocd_maxbytes)\r\n*stripe_maxbytes = imp->imp_connect_data.ocd_maxbytes;\r\n} else {\r\n*stripe_maxbytes = LUSTRE_STRIPE_MAXBYTES;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nstatic int lsm_lmm_verify_v1(struct lov_mds_md_v1 *lmm, int lmm_bytes,\r\n__u16 *stripe_count)\r\n{\r\nif (lmm_bytes < sizeof(*lmm)) {\r\nCERROR("lov_mds_md_v1 too small: %d, need at least %d\n",\r\nlmm_bytes, (int)sizeof(*lmm));\r\nreturn -EINVAL;\r\n}\r\n*stripe_count = le16_to_cpu(lmm->lmm_stripe_count);\r\nif (le32_to_cpu(lmm->lmm_pattern) & LOV_PATTERN_F_RELEASED)\r\n*stripe_count = 0;\r\nif (lmm_bytes < lov_mds_md_size(*stripe_count, LOV_MAGIC_V1)) {\r\nCERROR("LOV EA V1 too small: %d, need %d\n",\r\nlmm_bytes, lov_mds_md_size(*stripe_count, LOV_MAGIC_V1));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn lsm_lmm_verify_common(lmm, lmm_bytes, *stripe_count);\r\n}\r\nint lsm_unpackmd_v1(struct lov_obd *lov, struct lov_stripe_md *lsm,\r\nstruct lov_mds_md_v1 *lmm)\r\n{\r\nstruct lov_oinfo *loi;\r\nint i;\r\nint stripe_count;\r\n__u64 stripe_maxbytes = OBD_OBJECT_EOF;\r\nlsm_unpackmd_common(lsm, lmm);\r\nstripe_count = lsm_is_released(lsm) ? 0 : lsm->lsm_stripe_count;\r\nfor (i = 0; i < stripe_count; i++) {\r\nloi = lsm->lsm_oinfo[i];\r\nostid_le_to_cpu(&lmm->lmm_objects[i].l_ost_oi, &loi->loi_oi);\r\nloi->loi_ost_idx = le32_to_cpu(lmm->lmm_objects[i].l_ost_idx);\r\nloi->loi_ost_gen = le32_to_cpu(lmm->lmm_objects[i].l_ost_gen);\r\nif (loi->loi_ost_idx >= lov->desc.ld_tgt_count) {\r\nCERROR("OST index %d more than OST count %d\n",\r\nloi->loi_ost_idx, lov->desc.ld_tgt_count);\r\nlov_dump_lmm_v1(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (!lov->lov_tgts[loi->loi_ost_idx]) {\r\nCERROR("OST index %d missing\n", loi->loi_ost_idx);\r\nlov_dump_lmm_v1(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nlov_tgt_maxbytes(lov->lov_tgts[loi->loi_ost_idx],\r\n&stripe_maxbytes);\r\n}\r\nlsm->lsm_maxbytes = stripe_maxbytes * lsm->lsm_stripe_count;\r\nif (lsm->lsm_stripe_count == 0)\r\nlsm->lsm_maxbytes = stripe_maxbytes * lov->desc.ld_tgt_count;\r\nreturn 0;\r\n}\r\nstatic int lsm_lmm_verify_v3(struct lov_mds_md *lmmv1, int lmm_bytes,\r\n__u16 *stripe_count)\r\n{\r\nstruct lov_mds_md_v3 *lmm;\r\nlmm = (struct lov_mds_md_v3 *)lmmv1;\r\nif (lmm_bytes < sizeof(*lmm)) {\r\nCERROR("lov_mds_md_v3 too small: %d, need at least %d\n",\r\nlmm_bytes, (int)sizeof(*lmm));\r\nreturn -EINVAL;\r\n}\r\n*stripe_count = le16_to_cpu(lmm->lmm_stripe_count);\r\nif (le32_to_cpu(lmm->lmm_pattern) & LOV_PATTERN_F_RELEASED)\r\n*stripe_count = 0;\r\nif (lmm_bytes < lov_mds_md_size(*stripe_count, LOV_MAGIC_V3)) {\r\nCERROR("LOV EA V3 too small: %d, need %d\n",\r\nlmm_bytes, lov_mds_md_size(*stripe_count, LOV_MAGIC_V3));\r\nlov_dump_lmm_common(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nreturn lsm_lmm_verify_common((struct lov_mds_md_v1 *)lmm, lmm_bytes,\r\n*stripe_count);\r\n}\r\nint lsm_unpackmd_v3(struct lov_obd *lov, struct lov_stripe_md *lsm,\r\nstruct lov_mds_md *lmmv1)\r\n{\r\nstruct lov_mds_md_v3 *lmm;\r\nstruct lov_oinfo *loi;\r\nint i;\r\nint stripe_count;\r\n__u64 stripe_maxbytes = OBD_OBJECT_EOF;\r\nint cplen = 0;\r\nlmm = (struct lov_mds_md_v3 *)lmmv1;\r\nlsm_unpackmd_common(lsm, (struct lov_mds_md_v1 *)lmm);\r\nstripe_count = lsm_is_released(lsm) ? 0 : lsm->lsm_stripe_count;\r\ncplen = strlcpy(lsm->lsm_pool_name, lmm->lmm_pool_name,\r\nsizeof(lsm->lsm_pool_name));\r\nif (cplen >= sizeof(lsm->lsm_pool_name))\r\nreturn -E2BIG;\r\nfor (i = 0; i < stripe_count; i++) {\r\nloi = lsm->lsm_oinfo[i];\r\nostid_le_to_cpu(&lmm->lmm_objects[i].l_ost_oi, &loi->loi_oi);\r\nloi->loi_ost_idx = le32_to_cpu(lmm->lmm_objects[i].l_ost_idx);\r\nloi->loi_ost_gen = le32_to_cpu(lmm->lmm_objects[i].l_ost_gen);\r\nif (loi->loi_ost_idx >= lov->desc.ld_tgt_count) {\r\nCERROR("OST index %d more than OST count %d\n",\r\nloi->loi_ost_idx, lov->desc.ld_tgt_count);\r\nlov_dump_lmm_v3(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nif (!lov->lov_tgts[loi->loi_ost_idx]) {\r\nCERROR("OST index %d missing\n", loi->loi_ost_idx);\r\nlov_dump_lmm_v3(D_WARNING, lmm);\r\nreturn -EINVAL;\r\n}\r\nlov_tgt_maxbytes(lov->lov_tgts[loi->loi_ost_idx],\r\n&stripe_maxbytes);\r\n}\r\nlsm->lsm_maxbytes = stripe_maxbytes * lsm->lsm_stripe_count;\r\nif (lsm->lsm_stripe_count == 0)\r\nlsm->lsm_maxbytes = stripe_maxbytes * lov->desc.ld_tgt_count;\r\nreturn 0;\r\n}
