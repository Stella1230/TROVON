static inline u_long pcc_port2addr(unsigned long port, int size) {\r\nu_long addr = 0;\r\nu_long odd;\r\nif (size == 1) {\r\nodd = (port&1) << 11;\r\nport -= port & 1;\r\naddr = CFC_IO_MAPBASE_BYTE - CFC_IOPORT_BASE + odd + port;\r\n} else if (size == 2)\r\naddr = CFC_IO_MAPBASE_WORD - CFC_IOPORT_BASE + port;\r\nreturn addr;\r\n}\r\nstatic inline u_long pcc_port2addr(unsigned long port, int size) {\r\nu_long odd;\r\nu_long addr = ((port - CFC_IOPORT_BASE) & 0xf000) << 8;\r\nif (size == 1) {\r\nodd = port & 1;\r\nport -= odd;\r\nodd <<= 11;\r\naddr = (addr | CFC_IO_MAPBASE_BYTE) + odd + (port & 0xfff);\r\n} else if (size == 2)\r\naddr = (addr | CFC_IO_MAPBASE_WORD) + (port & 0xfff);\r\nreturn addr;\r\n}\r\nvoid pcc_ioread_byte(int sock, unsigned long port, void *buf, size_t size,\r\nsize_t nmemb, int flag)\r\n{\r\nu_long addr;\r\nunsigned char *bp = (unsigned char *)buf;\r\nunsigned long flags;\r\npr_debug("m32r_cfc: pcc_ioread_byte: sock=%d, port=%#lx, buf=%p, "\r\n"size=%u, nmemb=%d, flag=%d\n",\r\nsock, port, buf, size, nmemb, flag);\r\naddr = pcc_port2addr(port, 1);\r\nif (!addr) {\r\nprintk("m32r_cfc:ioread_byte null port :%#lx\n",port);\r\nreturn;\r\n}\r\npr_debug("m32r_cfc: pcc_ioread_byte: addr=%#lx\n", addr);\r\nspin_lock_irqsave(&pcc_lock, flags);\r\nwhile (nmemb--)\r\n*bp++ = readb(addr);\r\nspin_unlock_irqrestore(&pcc_lock, flags);\r\n}\r\nvoid pcc_ioread_word(int sock, unsigned long port, void *buf, size_t size,\r\nsize_t nmemb, int flag)\r\n{\r\nu_long addr;\r\nunsigned short *bp = (unsigned short *)buf;\r\nunsigned long flags;\r\npr_debug("m32r_cfc: pcc_ioread_word: sock=%d, port=%#lx, "\r\n"buf=%p, size=%u, nmemb=%d, flag=%d\n",\r\nsock, port, buf, size, nmemb, flag);\r\nif (size != 2)\r\nprintk("m32r_cfc: ioread_word :illigal size %u : %#lx\n", size,\r\nport);\r\nif (size == 9)\r\nprintk("m32r_cfc: ioread_word :insw \n");\r\naddr = pcc_port2addr(port, 2);\r\nif (!addr) {\r\nprintk("m32r_cfc:ioread_word null port :%#lx\n",port);\r\nreturn;\r\n}\r\npr_debug("m32r_cfc: pcc_ioread_word: addr=%#lx\n", addr);\r\nspin_lock_irqsave(&pcc_lock, flags);\r\nwhile (nmemb--)\r\n*bp++ = readw(addr);\r\nspin_unlock_irqrestore(&pcc_lock, flags);\r\n}\r\nvoid pcc_iowrite_byte(int sock, unsigned long port, void *buf, size_t size,\r\nsize_t nmemb, int flag)\r\n{\r\nu_long addr;\r\nunsigned char *bp = (unsigned char *)buf;\r\nunsigned long flags;\r\npr_debug("m32r_cfc: pcc_iowrite_byte: sock=%d, port=%#lx, "\r\n"buf=%p, size=%u, nmemb=%d, flag=%d\n",\r\nsock, port, buf, size, nmemb, flag);\r\naddr = pcc_port2addr(port, 1);\r\nif (!addr) {\r\nprintk("m32r_cfc:iowrite_byte null port:%#lx\n",port);\r\nreturn;\r\n}\r\npr_debug("m32r_cfc: pcc_iowrite_byte: addr=%#lx\n", addr);\r\nspin_lock_irqsave(&pcc_lock, flags);\r\nwhile (nmemb--)\r\nwriteb(*bp++, addr);\r\nspin_unlock_irqrestore(&pcc_lock, flags);\r\n}\r\nvoid pcc_iowrite_word(int sock, unsigned long port, void *buf, size_t size,\r\nsize_t nmemb, int flag)\r\n{\r\nu_long addr;\r\nunsigned short *bp = (unsigned short *)buf;\r\nunsigned long flags;\r\npr_debug("m32r_cfc: pcc_iowrite_word: sock=%d, port=%#lx, "\r\n"buf=%p, size=%u, nmemb=%d, flag=%d\n",\r\nsock, port, buf, size, nmemb, flag);\r\nif(size != 2)\r\nprintk("m32r_cfc: iowrite_word :illigal size %u : %#lx\n",\r\nsize, port);\r\nif(size == 9)\r\nprintk("m32r_cfc: iowrite_word :outsw \n");\r\naddr = pcc_port2addr(port, 2);\r\nif (!addr) {\r\nprintk("m32r_cfc:iowrite_word null addr :%#lx\n",port);\r\nreturn;\r\n}\r\n#if 1\r\nif (addr & 1) {\r\nprintk("m32r_cfc:iowrite_word port addr (%#lx):%#lx\n", port,\r\naddr);\r\nreturn;\r\n}\r\n#endif\r\npr_debug("m32r_cfc: pcc_iowrite_word: addr=%#lx\n", addr);\r\nspin_lock_irqsave(&pcc_lock, flags);\r\nwhile (nmemb--)\r\nwritew(*bp++, addr);\r\nspin_unlock_irqrestore(&pcc_lock, flags);\r\n}\r\nstatic unsigned int pcc_get(u_short sock, unsigned int reg)\r\n{\r\nunsigned int val = inw(reg);\r\npr_debug("m32r_cfc: pcc_get: reg(0x%08x)=0x%04x\n", reg, val);\r\nreturn val;\r\n}\r\nstatic void pcc_set(u_short sock, unsigned int reg, unsigned int data)\r\n{\r\noutw(data, reg);\r\npr_debug("m32r_cfc: pcc_set: reg(0x%08x)=0x%04x\n", reg, data);\r\n}\r\nstatic int __init is_alive(u_short sock)\r\n{\r\nunsigned int stat;\r\npr_debug("m32r_cfc: is_alive:\n");\r\nprintk("CF: ");\r\nstat = pcc_get(sock, (unsigned int)PLD_CFSTS);\r\nif (!stat)\r\nprintk("No ");\r\nprintk("Card is detected at socket %d : stat = 0x%08x\n", sock, stat);\r\npr_debug("m32r_cfc: is_alive: sock stat is 0x%04x\n", stat);\r\nreturn 0;\r\n}\r\nstatic void add_pcc_socket(ulong base, int irq, ulong mapaddr,\r\nunsigned int ioaddr)\r\n{\r\npcc_socket_t *t = &socket[pcc_sockets];\r\npr_debug("m32r_cfc: add_pcc_socket: base=%#lx, irq=%d, "\r\n"mapaddr=%#lx, ioaddr=%08x\n",\r\nbase, irq, mapaddr, ioaddr);\r\nt->ioaddr = ioaddr;\r\nt->mapaddr = mapaddr;\r\n#if !defined(CONFIG_PLAT_USRV)\r\nt->base = 0;\r\nt->flags = 0;\r\nt->cs_irq1 = irq;\r\nt->cs_irq2 = irq + 1;\r\n#else\r\nt->base = base;\r\nt->flags = 0;\r\nt->cs_irq1 = 0;\r\nt->cs_irq2 = 0;\r\n#endif\r\nif (is_alive(pcc_sockets))\r\nt->flags |= IS_ALIVE;\r\n#if !defined(CONFIG_PLAT_USRV)\r\nrequest_region((unsigned int)PLD_CFRSTCR, 0x20, "m32r_cfc");\r\n#else\r\n{\r\nunsigned int reg_base;\r\nreg_base = (unsigned int)PLD_CFRSTCR;\r\nreg_base |= pcc_sockets << 8;\r\nrequest_region(reg_base, 0x20, "m32r_cfc");\r\n}\r\n#endif\r\nprintk(KERN_INFO " %s ", pcc[pcc_sockets].name);\r\nprintk("pcc at 0x%08lx\n", t->base);\r\nt->socket.features |= (SS_CAP_PCCARD | SS_CAP_STATIC_MAP);\r\nt->socket.map_size = M32R_PCC_MAPSIZE;\r\nt->socket.io_offset = ioaddr;\r\nt->socket.irq_mask = 0;\r\n#if !defined(CONFIG_PLAT_USRV)\r\nt->socket.pci_irq = PLD_IRQ_CFIREQ ;\r\n#else\r\nt->socket.pci_irq = PLD_IRQ_CF0 + pcc_sockets;\r\n#endif\r\n#ifndef CONFIG_PLAT_USRV\r\nrequest_irq(irq, pcc_interrupt, 0, "m32r_cfc", pcc_interrupt);\r\n#ifndef CONFIG_PLAT_MAPPI3\r\nrequest_irq(irq+1, pcc_interrupt, 0, "m32r_cfc", pcc_interrupt);\r\n#endif\r\npr_debug("m32r_cfc: enable CFMSK, RDYSEL\n");\r\npcc_set(pcc_sockets, (unsigned int)PLD_CFIMASK, 0x01);\r\n#endif\r\n#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)\r\npcc_set(pcc_sockets, (unsigned int)PLD_CFCR1, 0x0200);\r\n#endif\r\npcc_sockets++;\r\nreturn;\r\n}\r\nstatic irqreturn_t pcc_interrupt(int irq, void *dev)\r\n{\r\nint i;\r\nu_int events = 0;\r\nint handled = 0;\r\npr_debug("m32r_cfc: pcc_interrupt: irq=%d, dev=%p\n", irq, dev);\r\nfor (i = 0; i < pcc_sockets; i++) {\r\nif (socket[i].cs_irq1 != irq && socket[i].cs_irq2 != irq)\r\ncontinue;\r\nhandled = 1;\r\npr_debug("m32r_cfc: pcc_interrupt: socket %d irq 0x%02x ",\r\ni, irq);\r\nevents |= SS_DETECT;\r\nif (events)\r\npcmcia_parse_events(&socket[i].socket, events);\r\n}\r\npr_debug("m32r_cfc: pcc_interrupt: done\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pcc_interrupt_wrapper(u_long data)\r\n{\r\npr_debug("m32r_cfc: pcc_interrupt_wrapper:\n");\r\npcc_interrupt(0, NULL);\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nstatic int _pcc_get_status(u_short sock, u_int *value)\r\n{\r\nu_int status;\r\npr_debug("m32r_cfc: _pcc_get_status:\n");\r\nstatus = pcc_get(sock, (unsigned int)PLD_CFSTS);\r\n*value = (status) ? SS_DETECT : 0;\r\npr_debug("m32r_cfc: _pcc_get_status: status=0x%08x\n", status);\r\n#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)\r\nif ( status ) {\r\nstatus = inw((unsigned int)PLD_CPCR);\r\nif (!(status & PLD_CPCR_CF)) {\r\npr_debug("m32r_cfc: _pcc_get_status: "\r\n"power on (CPCR=0x%08x)\n", status);\r\nstatus |= PLD_CPCR_CF;\r\noutw(status, (unsigned int)PLD_CPCR);\r\nudelay(100);\r\n}\r\n*value |= SS_POWERON;\r\npcc_set(sock, (unsigned int)PLD_CFBUFCR,0);\r\nudelay(100);\r\n*value |= SS_READY;\r\n*value |= SS_3VCARD;\r\n} else {\r\nstatus = inw((unsigned int)PLD_CPCR);\r\nstatus &= ~PLD_CPCR_CF;\r\noutw(status, (unsigned int)PLD_CPCR);\r\nudelay(100);\r\npr_debug("m32r_cfc: _pcc_get_status: "\r\n"power off (CPCR=0x%08x)\n", status);\r\n}\r\n#elif defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_MAPPI3)\r\nif ( status ) {\r\nstatus = pcc_get(sock, (unsigned int)PLD_CPCR);\r\nif (status == 0) {\r\npcc_set(sock, (unsigned int)PLD_CPCR, 1);\r\npcc_set(sock, (unsigned int)PLD_CFBUFCR,0);\r\nudelay(50);\r\n}\r\n*value |= SS_POWERON;\r\npcc_set(sock, (unsigned int)PLD_CFBUFCR,0);\r\nudelay(50);\r\npcc_set(sock, (unsigned int)PLD_CFRSTCR, 0x0101);\r\nudelay(25);\r\npcc_set(sock, (unsigned int)PLD_CFRSTCR, 0x0100);\r\nmdelay(2);\r\n*value |= SS_READY;\r\n*value |= SS_3VCARD;\r\n} else {\r\npcc_set(sock, (unsigned int)PLD_CPCR, 0);\r\nudelay(100);\r\npr_debug("m32r_cfc: _pcc_get_status: "\r\n"power off (CPCR=0x%08x)\n", status);\r\n}\r\n#else\r\n#error no platform configuration\r\n#endif\r\npr_debug("m32r_cfc: _pcc_get_status: GetStatus(%d) = %#4.4x\n",\r\nsock, *value);\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_socket(u_short sock, socket_state_t *state)\r\n{\r\npr_debug("m32r_cfc: SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "\r\n"io_irq %d, csc_mask %#2.2x)\n", sock, state->flags,\r\nstate->Vcc, state->Vpp, state->io_irq, state->csc_mask);\r\n#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT) || defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_MAPPI3)\r\nif (state->Vcc) {\r\nif ((state->Vcc != 50) && (state->Vcc != 33))\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nif (state->flags & SS_RESET) {\r\npr_debug(":RESET\n");\r\npcc_set(sock,(unsigned int)PLD_CFRSTCR,0x101);\r\n}else{\r\npcc_set(sock,(unsigned int)PLD_CFRSTCR,0x100);\r\n}\r\nif (state->flags & SS_OUTPUT_ENA){\r\npr_debug(":OUTPUT_ENA\n");\r\npcc_set(sock,(unsigned int)PLD_CFBUFCR,0);\r\n} else {\r\npcc_set(sock,(unsigned int)PLD_CFBUFCR,1);\r\n}\r\nif(state->flags & SS_IOCARD){\r\npr_debug(":IOCARD");\r\n}\r\nif (state->flags & SS_PWR_AUTO) {\r\npr_debug(":PWR_AUTO");\r\n}\r\nif (state->csc_mask & SS_DETECT)\r\npr_debug(":csc-SS_DETECT");\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\npr_debug(":STSCHG");\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\npr_debug(":BATDEAD");\r\nif (state->csc_mask & SS_BATWARN)\r\npr_debug(":BATWARN");\r\nif (state->csc_mask & SS_READY)\r\npr_debug(":READY");\r\n}\r\npr_debug("\n");\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_io_map(u_short sock, struct pccard_io_map *io)\r\n{\r\nu_char map;\r\npr_debug("m32r_cfc: SetIOMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx-%#llx)\n", sock, io->map, io->flags,\r\nio->speed, (unsigned long long)io->start,\r\n(unsigned long long)io->stop);\r\nmap = io->map;\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_mem_map(u_short sock, struct pccard_mem_map *mem)\r\n{\r\nu_char map = mem->map;\r\nu_long addr;\r\npcc_socket_t *t = &socket[sock];\r\npr_debug("m32r_cfc: SetMemMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx, %#x)\n", sock, map, mem->flags,\r\nmem->speed, (unsigned long long)mem->static_start,\r\nmem->card_start);\r\nif ((map > MAX_WIN) || (mem->card_start > 0x3ffffff)){\r\nreturn -EINVAL;\r\n}\r\nif ((mem->flags & MAP_ACTIVE) == 0) {\r\nt->current_space = as_none;\r\nreturn 0;\r\n}\r\nif (mem->flags & MAP_ATTRIB) {\r\nt->current_space = as_attr;\r\n} else {\r\nt->current_space = as_comm;\r\n}\r\naddr = t->mapaddr + (mem->card_start & M32R_PCC_MAPMASK);\r\nmem->static_start = addr + mem->card_start;\r\nreturn 0;\r\n}\r\nstatic int pcc_get_status(struct pcmcia_socket *s, u_int *value)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\ndev_dbg(&s->dev, "pcc_get_status: sock(%d) -EINVAL\n", sock);\r\n*value = 0;\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&s->dev, "pcc_get_status: sock(%d)\n", sock);\r\nLOCKED(_pcc_get_status(sock, value));\r\n}\r\nstatic int pcc_set_socket(struct pcmcia_socket *s, socket_state_t *state)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\ndev_dbg(&s->dev, "pcc_set_socket: sock(%d) -EINVAL\n", sock);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&s->dev, "pcc_set_socket: sock(%d)\n", sock);\r\nLOCKED(_pcc_set_socket(sock, state));\r\n}\r\nstatic int pcc_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\ndev_dbg(&s->dev, "pcc_set_io_map: sock(%d) -EINVAL\n", sock);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&s->dev, "pcc_set_io_map: sock(%d)\n", sock);\r\nLOCKED(_pcc_set_io_map(sock, io));\r\n}\r\nstatic int pcc_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\ndev_dbg(&s->dev, "pcc_set_mem_map: sock(%d) -EINVAL\n", sock);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&s->dev, "pcc_set_mem_map: sock(%d)\n", sock);\r\nLOCKED(_pcc_set_mem_map(sock, mem));\r\n}\r\nstatic int pcc_init(struct pcmcia_socket *s)\r\n{\r\ndev_dbg(&s->dev, "pcc_init()\n");\r\nreturn 0;\r\n}\r\nstatic int __init init_m32r_pcc(void)\r\n{\r\nint i, ret;\r\nret = platform_driver_register(&pcc_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_device_register(&pcc_device);\r\nif (ret){\r\nplatform_driver_unregister(&pcc_driver);\r\nreturn ret;\r\n}\r\n#if defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_MAPPI3)\r\npcc_set(0, (unsigned int)PLD_CFCR0, 0x0f0f);\r\npcc_set(0, (unsigned int)PLD_CFCR1, 0x0200);\r\n#endif\r\npcc_sockets = 0;\r\n#if !defined(CONFIG_PLAT_USRV)\r\nadd_pcc_socket(M32R_PCC0_BASE, PLD_IRQ_CFC_INSERT, CFC_ATTR_MAPBASE,\r\nCFC_IOPORT_BASE);\r\n#else\r\n{\r\nulong base, mapaddr;\r\nunsigned int ioaddr;\r\nfor (i = 0 ; i < M32R_MAX_PCC ; i++) {\r\nbase = (ulong)PLD_CFRSTCR;\r\nbase = base | (i << 8);\r\nioaddr = (i + 1) << 12;\r\nmapaddr = CFC_ATTR_MAPBASE | (i << 20);\r\nadd_pcc_socket(base, 0, mapaddr, ioaddr);\r\n}\r\n}\r\n#endif\r\nif (pcc_sockets == 0) {\r\nprintk("socket is not found.\n");\r\nplatform_device_unregister(&pcc_device);\r\nplatform_driver_unregister(&pcc_driver);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0 ; i < pcc_sockets ; i++) {\r\nsocket[i].socket.dev.parent = &pcc_device.dev;\r\nsocket[i].socket.ops = &pcc_operations;\r\nsocket[i].socket.resource_ops = &pccard_static_ops;\r\nsocket[i].socket.owner = THIS_MODULE;\r\nsocket[i].number = i;\r\nret = pcmcia_register_socket(&socket[i].socket);\r\nif (!ret)\r\nsocket[i].flags |= IS_REGISTERED;\r\n#if 0\r\nclass_device_create_file(&socket[i].socket.dev,\r\n&class_device_attr_info);\r\nclass_device_create_file(&socket[i].socket.dev,\r\n&class_device_attr_exca);\r\n#endif\r\n}\r\nif (poll_interval != 0) {\r\npoll_timer.function = pcc_interrupt_wrapper;\r\npoll_timer.data = 0;\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit exit_m32r_pcc(void)\r\n{\r\nint i;\r\nfor (i = 0; i < pcc_sockets; i++)\r\nif (socket[i].flags & IS_REGISTERED)\r\npcmcia_unregister_socket(&socket[i].socket);\r\nplatform_device_unregister(&pcc_device);\r\nif (poll_interval != 0)\r\ndel_timer_sync(&poll_timer);\r\nplatform_driver_unregister(&pcc_driver);\r\n}
