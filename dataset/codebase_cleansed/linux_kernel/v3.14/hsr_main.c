void register_hsr_master(struct hsr_priv *hsr_priv)\r\n{\r\nlist_add_tail_rcu(&hsr_priv->hsr_list, &hsr_list);\r\n}\r\nvoid unregister_hsr_master(struct hsr_priv *hsr_priv)\r\n{\r\nstruct hsr_priv *hsr_priv_it;\r\nlist_for_each_entry(hsr_priv_it, &hsr_list, hsr_list)\r\nif (hsr_priv_it == hsr_priv) {\r\nlist_del_rcu(&hsr_priv_it->hsr_list);\r\nreturn;\r\n}\r\n}\r\nbool is_hsr_slave(struct net_device *dev)\r\n{\r\nstruct hsr_priv *hsr_priv_it;\r\nlist_for_each_entry_rcu(hsr_priv_it, &hsr_list, hsr_list) {\r\nif (dev == hsr_priv_it->slave[0])\r\nreturn true;\r\nif (dev == hsr_priv_it->slave[1])\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct hsr_priv *get_hsr_master(struct net_device *dev)\r\n{\r\nstruct hsr_priv *hsr_priv;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)\r\nif ((dev == hsr_priv->slave[0]) ||\r\n(dev == hsr_priv->slave[1])) {\r\nrcu_read_unlock();\r\nreturn hsr_priv;\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic struct net_device *get_other_slave(struct hsr_priv *hsr_priv,\r\nstruct net_device *dev)\r\n{\r\nif (dev == hsr_priv->slave[0])\r\nreturn hsr_priv->slave[1];\r\nif (dev == hsr_priv->slave[1])\r\nreturn hsr_priv->slave[0];\r\nreturn NULL;\r\n}\r\nstatic int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *slave, *other_slave;\r\nstruct hsr_priv *hsr_priv;\r\nint old_operstate;\r\nint mtu_max;\r\nint res;\r\nstruct net_device *dev;\r\ndev = netdev_notifier_info_to_dev(ptr);\r\nhsr_priv = get_hsr_master(dev);\r\nif (hsr_priv) {\r\nslave = dev;\r\nother_slave = get_other_slave(hsr_priv, slave);\r\n} else {\r\nif (!is_hsr_master(dev))\r\nreturn NOTIFY_DONE;\r\nhsr_priv = netdev_priv(dev);\r\nslave = hsr_priv->slave[0];\r\nother_slave = hsr_priv->slave[1];\r\n}\r\nswitch (event) {\r\ncase NETDEV_UP:\r\ncase NETDEV_DOWN:\r\ncase NETDEV_CHANGE:\r\nold_operstate = hsr_priv->dev->operstate;\r\nhsr_set_carrier(hsr_priv->dev, slave, other_slave);\r\nhsr_set_operstate(hsr_priv->dev, slave, other_slave);\r\nhsr_check_announce(hsr_priv->dev, old_operstate);\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (dev == hsr_priv->dev)\r\nbreak;\r\nif (dev == hsr_priv->slave[0])\r\nmemcpy(hsr_priv->dev->dev_addr,\r\nhsr_priv->slave[0]->dev_addr, ETH_ALEN);\r\nres = hsr_create_self_node(&hsr_priv->self_node_db,\r\nhsr_priv->dev->dev_addr,\r\nhsr_priv->slave[1] ?\r\nhsr_priv->slave[1]->dev_addr :\r\nhsr_priv->dev->dev_addr);\r\nif (res)\r\nnetdev_warn(hsr_priv->dev,\r\n"Could not update HSR node address.\n");\r\nif (dev == hsr_priv->slave[0])\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, hsr_priv->dev);\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (dev == hsr_priv->dev)\r\nbreak;\r\nmtu_max = hsr_get_max_mtu(hsr_priv);\r\nif (hsr_priv->dev->mtu > mtu_max)\r\ndev_set_mtu(hsr_priv->dev, mtu_max);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev == hsr_priv->slave[0])\r\nhsr_priv->slave[0] = NULL;\r\nif (dev == hsr_priv->slave[1])\r\nhsr_priv->slave[1] = NULL;\r\nbreak;\r\ncase NETDEV_PRE_TYPE_CHANGE:\r\nreturn NOTIFY_BAD;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void prune_nodes_all(unsigned long data)\r\n{\r\nstruct hsr_priv *hsr_priv;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)\r\nhsr_prune_nodes(hsr_priv);\r\nrcu_read_unlock();\r\nprune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);\r\nadd_timer(&prune_timer);\r\n}\r\nstatic struct sk_buff *hsr_pull_tag(struct sk_buff *skb)\r\n{\r\nstruct hsr_tag *hsr_tag;\r\nstruct sk_buff *skb2;\r\nskb2 = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2))\r\ngoto err_free;\r\nskb = skb2;\r\nif (unlikely(!pskb_may_pull(skb, HSR_TAGLEN)))\r\ngoto err_free;\r\nhsr_tag = (struct hsr_tag *) skb->data;\r\nskb->protocol = hsr_tag->encap_proto;\r\nskb_pull(skb, HSR_TAGLEN);\r\nreturn skb;\r\nerr_free:\r\nkfree_skb(skb);\r\nreturn NULL;\r\n}\r\nstatic bool is_supervision_frame(struct hsr_priv *hsr_priv, struct sk_buff *skb)\r\n{\r\nstruct hsr_sup_tag *hsr_stag;\r\nif (!ether_addr_equal(eth_hdr(skb)->h_dest,\r\nhsr_priv->sup_multicast_addr))\r\nreturn false;\r\nhsr_stag = (struct hsr_sup_tag *) skb->data;\r\nif (get_hsr_stag_path(hsr_stag) != 0x0f)\r\nreturn false;\r\nif ((hsr_stag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&\r\n(hsr_stag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))\r\nreturn false;\r\nif (hsr_stag->HSR_TLV_Length != 12)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int hsr_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct hsr_priv *hsr_priv;\r\nstruct net_device *other_slave;\r\nstruct node_entry *node;\r\nbool deliver_to_self;\r\nstruct sk_buff *skb_deliver;\r\nenum hsr_dev_idx dev_in_idx, dev_other_idx;\r\nbool dup_out;\r\nint ret;\r\nhsr_priv = get_hsr_master(dev);\r\nif (!hsr_priv) {\r\nkfree_skb(skb);\r\ndev->stats.rx_errors++;\r\nreturn NET_RX_SUCCESS;\r\n}\r\nif (dev == hsr_priv->slave[0]) {\r\ndev_in_idx = HSR_DEV_SLAVE_A;\r\ndev_other_idx = HSR_DEV_SLAVE_B;\r\n} else {\r\ndev_in_idx = HSR_DEV_SLAVE_B;\r\ndev_other_idx = HSR_DEV_SLAVE_A;\r\n}\r\nnode = hsr_find_node(&hsr_priv->self_node_db, skb);\r\nif (node) {\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\ndeliver_to_self = false;\r\nif ((skb->pkt_type == PACKET_HOST) ||\r\n(skb->pkt_type == PACKET_MULTICAST) ||\r\n(skb->pkt_type == PACKET_BROADCAST))\r\ndeliver_to_self = true;\r\nelse if (ether_addr_equal(eth_hdr(skb)->h_dest,\r\nhsr_priv->dev->dev_addr)) {\r\nskb->pkt_type = PACKET_HOST;\r\ndeliver_to_self = true;\r\n}\r\nrcu_read_lock();\r\nnode = hsr_find_node(&hsr_priv->node_db, skb);\r\nif (is_supervision_frame(hsr_priv, skb)) {\r\nskb_pull(skb, sizeof(struct hsr_sup_tag));\r\nnode = hsr_merge_node(hsr_priv, node, skb, dev_in_idx);\r\nif (!node) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nhsr_priv->dev->stats.rx_dropped++;\r\nreturn NET_RX_DROP;\r\n}\r\nskb_push(skb, sizeof(struct hsr_sup_tag));\r\ndeliver_to_self = false;\r\n}\r\nif (!node) {\r\nrcu_read_unlock();\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\ndup_out = hsr_register_frame_out(node, dev_other_idx, skb);\r\nif (!dup_out)\r\nhsr_register_frame_in(node, dev_in_idx);\r\nif (!dup_out && (skb->pkt_type != PACKET_HOST))\r\nother_slave = get_other_slave(hsr_priv, dev);\r\nelse\r\nother_slave = NULL;\r\nif (hsr_register_frame_out(node, HSR_DEV_MASTER, skb))\r\ndeliver_to_self = false;\r\nrcu_read_unlock();\r\nif (!deliver_to_self && !other_slave) {\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nskb_deliver = skb;\r\nif (deliver_to_self && other_slave) {\r\nskb_deliver = pskb_copy(skb, GFP_ATOMIC);\r\nif (!skb_deliver) {\r\ndeliver_to_self = false;\r\nhsr_priv->dev->stats.rx_dropped++;\r\n}\r\n}\r\nif (deliver_to_self) {\r\nbool multicast_frame;\r\nskb_deliver = hsr_pull_tag(skb_deliver);\r\nif (!skb_deliver) {\r\nhsr_priv->dev->stats.rx_dropped++;\r\ngoto forward;\r\n}\r\n#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\r\nmemmove(skb_deliver->data - HSR_TAGLEN, skb_deliver->data,\r\nskb_headlen(skb_deliver));\r\nskb_deliver->data -= HSR_TAGLEN;\r\nskb_deliver->tail -= HSR_TAGLEN;\r\n#endif\r\nskb_deliver->dev = hsr_priv->dev;\r\nhsr_addr_subst_source(hsr_priv, skb_deliver);\r\nmulticast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);\r\nret = netif_rx(skb_deliver);\r\nif (ret == NET_RX_DROP) {\r\nhsr_priv->dev->stats.rx_dropped++;\r\n} else {\r\nhsr_priv->dev->stats.rx_packets++;\r\nhsr_priv->dev->stats.rx_bytes += skb->len;\r\nif (multicast_frame)\r\nhsr_priv->dev->stats.multicast++;\r\n}\r\n}\r\nforward:\r\nif (other_slave) {\r\nskb_push(skb, ETH_HLEN);\r\nskb->dev = other_slave;\r\ndev_queue_xmit(skb);\r\n}\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int __init hsr_init(void)\r\n{\r\nint res;\r\nBUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_TAGLEN);\r\ndev_add_pack(&hsr_pt);\r\ninit_timer(&prune_timer);\r\nprune_timer.function = prune_nodes_all;\r\nprune_timer.data = 0;\r\nprune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);\r\nadd_timer(&prune_timer);\r\nregister_netdevice_notifier(&hsr_nb);\r\nres = hsr_netlink_init();\r\nreturn res;\r\n}\r\nstatic void __exit hsr_exit(void)\r\n{\r\nunregister_netdevice_notifier(&hsr_nb);\r\ndel_timer(&prune_timer);\r\nhsr_netlink_exit();\r\ndev_remove_pack(&hsr_pt);\r\n}
