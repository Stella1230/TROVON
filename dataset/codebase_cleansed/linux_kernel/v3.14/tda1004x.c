static int tda1004x_write_byteI(struct tda1004x_state *state, int reg, int data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\r\ndprintk("%s: reg=0x%x, data=0x%x\n", __func__, reg, data);\r\nmsg.addr = state->config->demod_address;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: error reg=0x%x, data=0x%x, ret=%i\n",\r\n__func__, reg, data, ret);\r\ndprintk("%s: success reg=0x%x, data=0x%x, ret=%i\n", __func__,\r\nreg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int tda1004x_read_byte(struct tda1004x_state *state, int reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {{ .flags = 0, .buf = b0, .len = 1 },\r\n{ .flags = I2C_M_RD, .buf = b1, .len = 1 }};\r\ndprintk("%s: reg=0x%x\n", __func__, reg);\r\nmsg[0].addr = state->config->demod_address;\r\nmsg[1].addr = state->config->demod_address;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\ndprintk("%s: error reg=0x%x, ret=%i\n", __func__, reg,\r\nret);\r\nreturn -EINVAL;\r\n}\r\ndprintk("%s: success reg=0x%x, data=0x%x, ret=%i\n", __func__,\r\nreg, b1[0], ret);\r\nreturn b1[0];\r\n}\r\nstatic int tda1004x_write_mask(struct tda1004x_state *state, int reg, int mask, int data)\r\n{\r\nint val;\r\ndprintk("%s: reg=0x%x, mask=0x%x, data=0x%x\n", __func__, reg,\r\nmask, data);\r\nval = tda1004x_read_byte(state, reg);\r\nif (val < 0)\r\nreturn val;\r\nval = val & ~mask;\r\nval |= data & 0xff;\r\nreturn tda1004x_write_byteI(state, reg, val);\r\n}\r\nstatic int tda1004x_write_buf(struct tda1004x_state *state, int reg, unsigned char *buf, int len)\r\n{\r\nint i;\r\nint result;\r\ndprintk("%s: reg=0x%x, len=0x%x\n", __func__, reg, len);\r\nresult = 0;\r\nfor (i = 0; i < len; i++) {\r\nresult = tda1004x_write_byteI(state, reg + i, buf[i]);\r\nif (result != 0)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int tda1004x_enable_tuner_i2c(struct tda1004x_state *state)\r\n{\r\nint result;\r\ndprintk("%s\n", __func__);\r\nresult = tda1004x_write_mask(state, TDA1004X_CONFC4, 2, 2);\r\nmsleep(20);\r\nreturn result;\r\n}\r\nstatic int tda1004x_disable_tuner_i2c(struct tda1004x_state *state)\r\n{\r\ndprintk("%s\n", __func__);\r\nreturn tda1004x_write_mask(state, TDA1004X_CONFC4, 2, 0);\r\n}\r\nstatic int tda10045h_set_bandwidth(struct tda1004x_state *state,\r\nu32 bandwidth)\r\n{\r\nstatic u8 bandwidth_6mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x60, 0x1e, 0xa7, 0x45, 0x4f };\r\nstatic u8 bandwidth_7mhz[] = { 0x02, 0x00, 0x37, 0x00, 0x4a, 0x2f, 0x6d, 0x76, 0xdb };\r\nstatic u8 bandwidth_8mhz[] = { 0x02, 0x00, 0x3d, 0x00, 0x48, 0x17, 0x89, 0xc7, 0x14 };\r\nswitch (bandwidth) {\r\ncase 6000000:\r\ntda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_6mhz, sizeof(bandwidth_6mhz));\r\nbreak;\r\ncase 7000000:\r\ntda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_7mhz, sizeof(bandwidth_7mhz));\r\nbreak;\r\ncase 8000000:\r\ntda1004x_write_buf(state, TDA10045H_CONFPLL_P, bandwidth_8mhz, sizeof(bandwidth_8mhz));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntda1004x_write_byteI(state, TDA10045H_IOFFSET, 0);\r\nreturn 0;\r\n}\r\nstatic int tda10046h_set_bandwidth(struct tda1004x_state *state,\r\nu32 bandwidth)\r\n{\r\nstatic u8 bandwidth_6mhz_53M[] = { 0x7b, 0x2e, 0x11, 0xf0, 0xd2 };\r\nstatic u8 bandwidth_7mhz_53M[] = { 0x6a, 0x02, 0x6a, 0x43, 0x9f };\r\nstatic u8 bandwidth_8mhz_53M[] = { 0x5c, 0x32, 0xc2, 0x96, 0x6d };\r\nstatic u8 bandwidth_6mhz_48M[] = { 0x70, 0x02, 0x49, 0x24, 0x92 };\r\nstatic u8 bandwidth_7mhz_48M[] = { 0x60, 0x02, 0xaa, 0xaa, 0xab };\r\nstatic u8 bandwidth_8mhz_48M[] = { 0x54, 0x03, 0x0c, 0x30, 0xc3 };\r\nint tda10046_clk53m;\r\nif ((state->config->if_freq == TDA10046_FREQ_045) ||\r\n(state->config->if_freq == TDA10046_FREQ_052))\r\ntda10046_clk53m = 0;\r\nelse\r\ntda10046_clk53m = 1;\r\nswitch (bandwidth) {\r\ncase 6000000:\r\nif (tda10046_clk53m)\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_53M,\r\nsizeof(bandwidth_6mhz_53M));\r\nelse\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_48M,\r\nsizeof(bandwidth_6mhz_48M));\r\nif (state->config->if_freq == TDA10046_FREQ_045) {\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0a);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xab);\r\n}\r\nbreak;\r\ncase 7000000:\r\nif (tda10046_clk53m)\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_53M,\r\nsizeof(bandwidth_7mhz_53M));\r\nelse\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_48M,\r\nsizeof(bandwidth_7mhz_48M));\r\nif (state->config->if_freq == TDA10046_FREQ_045) {\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);\r\n}\r\nbreak;\r\ncase 8000000:\r\nif (tda10046_clk53m)\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_53M,\r\nsizeof(bandwidth_8mhz_53M));\r\nelse\r\ntda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_48M,\r\nsizeof(bandwidth_8mhz_48M));\r\nif (state->config->if_freq == TDA10046_FREQ_045) {\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x55);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda1004x_do_upload(struct tda1004x_state *state,\r\nconst unsigned char *mem, unsigned int len,\r\nu8 dspCodeCounterReg, u8 dspCodeInReg)\r\n{\r\nu8 buf[65];\r\nstruct i2c_msg fw_msg = { .flags = 0, .buf = buf, .len = 0 };\r\nint tx_size;\r\nint pos = 0;\r\ntda1004x_write_byteI(state, dspCodeCounterReg, 0);\r\nfw_msg.addr = state->config->demod_address;\r\ni2c_lock_adapter(state->i2c);\r\nbuf[0] = dspCodeInReg;\r\nwhile (pos != len) {\r\ntx_size = len - pos;\r\nif (tx_size > 0x10)\r\ntx_size = 0x10;\r\nmemcpy(buf + 1, mem + pos, tx_size);\r\nfw_msg.len = tx_size + 1;\r\nif (__i2c_transfer(state->i2c, &fw_msg, 1) != 1) {\r\nprintk(KERN_ERR "tda1004x: Error during firmware upload\n");\r\ni2c_unlock_adapter(state->i2c);\r\nreturn -EIO;\r\n}\r\npos += tx_size;\r\ndprintk("%s: fw_pos=0x%x\n", __func__, pos);\r\n}\r\ni2c_unlock_adapter(state->i2c);\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_check_upload_ok(struct tda1004x_state *state)\r\n{\r\nu8 data1, data2;\r\nunsigned long timeout;\r\nif (state->demod_type == TDA1004X_DEMOD_TDA10046) {\r\ntimeout = jiffies + 2 * HZ;\r\nwhile(!(tda1004x_read_byte(state, TDA1004X_STATUS_CD) & 0x20)) {\r\nif (time_after(jiffies, timeout)) {\r\nprintk(KERN_ERR "tda1004x: timeout waiting for DSP ready\n");\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\n} else\r\nmsleep(100);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 0x10, 0);\r\ntda1004x_write_byteI(state, TDA1004X_DSP_CMD, 0x67);\r\ndata1 = tda1004x_read_byte(state, TDA1004X_DSP_DATA1);\r\ndata2 = tda1004x_read_byte(state, TDA1004X_DSP_DATA2);\r\nif (data1 != 0x67 || data2 < 0x20 || data2 > 0x2e) {\r\nprintk(KERN_INFO "tda1004x: found firmware revision %x -- invalid\n", data2);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO "tda1004x: found firmware revision %x -- ok\n", data2);\r\nreturn 0;\r\n}\r\nstatic int tda10045_fwupload(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint ret;\r\nconst struct firmware *fw;\r\nif (tda1004x_check_upload_ok(state) == 0)\r\nreturn 0;\r\nprintk(KERN_INFO "tda1004x: waiting for firmware upload (%s)...\n", TDA10045_DEFAULT_FIRMWARE);\r\nret = state->config->request_firmware(fe, &fw, TDA10045_DEFAULT_FIRMWARE);\r\nif (ret) {\r\nprintk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");\r\nreturn ret;\r\n}\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 0x10, 0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 8, 0);\r\nmsleep(10);\r\ntda10045h_set_bandwidth(state, 8000000);\r\nret = tda1004x_do_upload(state, fw->data, fw->size, TDA10045H_FWPAGE, TDA10045H_CODE_IN);\r\nrelease_firmware(fw);\r\nif (ret)\r\nreturn ret;\r\nprintk(KERN_INFO "tda1004x: firmware upload complete\n");\r\nmsleep(100);\r\nreturn tda1004x_check_upload_ok(state);\r\n}\r\nstatic void tda10046_init_plls(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tda10046_clk53m;\r\nif ((state->config->if_freq == TDA10046_FREQ_045) ||\r\n(state->config->if_freq == TDA10046_FREQ_052))\r\ntda10046_clk53m = 0;\r\nelse\r\ntda10046_clk53m = 1;\r\ntda1004x_write_byteI(state, TDA10046H_CONFPLL1, 0xf0);\r\nif(tda10046_clk53m) {\r\nprintk(KERN_INFO "tda1004x: setting up plls for 53MHz sampling clock\n");\r\ntda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x08);\r\n} else {\r\nprintk(KERN_INFO "tda1004x: setting up plls for 48MHz sampling clock\n");\r\ntda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x03);\r\n}\r\nif (state->config->xtal_freq == TDA10046_XTAL_4M ) {\r\ndprintk("%s: setting up PLLs for a 4 MHz Xtal\n", __func__);\r\ntda1004x_write_byteI(state, TDA10046H_CONFPLL3, 0);\r\n} else {\r\ndprintk("%s: setting up PLLs for a 16 MHz Xtal\n", __func__);\r\ntda1004x_write_byteI(state, TDA10046H_CONFPLL3, 3);\r\n}\r\nif(tda10046_clk53m)\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x67);\r\nelse\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x72);\r\nswitch (state->config->if_freq) {\r\ncase TDA10046_FREQ_045:\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);\r\nbreak;\r\ncase TDA10046_FREQ_052:\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xc7);\r\nbreak;\r\ncase TDA10046_FREQ_3617:\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x59);\r\nbreak;\r\ncase TDA10046_FREQ_3613:\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);\r\ntda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x3f);\r\nbreak;\r\n}\r\ntda10046h_set_bandwidth(state, 8000000);\r\nmsleep(120);\r\n}\r\nstatic int tda10046_fwupload(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint ret, confc4;\r\nconst struct firmware *fw;\r\nif (state->config->xtal_freq == TDA10046_XTAL_4M) {\r\nconfc4 = 0;\r\n} else {\r\ndprintk("%s: 16MHz Xtal, reducing I2C speed\n", __func__);\r\nconfc4 = 0x80;\r\n}\r\ntda1004x_write_byteI(state, TDA1004X_CONFC4, confc4);\r\ntda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 1, 0);\r\nif (state->config->gpio_config != TDA10046_GPTRI) {\r\ntda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE2, 0x33);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x0f, state->config->gpio_config &0x0f);\r\n}\r\nmsleep(10);\r\ntda10046_init_plls(fe);\r\ntda1004x_write_mask(state, TDA1004X_CONFADC2, 0xc0, 0);\r\nif (tda1004x_check_upload_ok(state) == 0)\r\nreturn 0;\r\nprintk(KERN_INFO "tda1004x: trying to boot from eeprom\n");\r\ntda1004x_write_byteI(state, TDA1004X_CONFC4, 4);\r\nmsleep(300);\r\ntda1004x_write_byteI(state, TDA1004X_CONFC4, confc4);\r\nif (tda1004x_check_upload_ok(state) == 0)\r\nreturn 0;\r\nif (state->config->request_firmware != NULL) {\r\nprintk(KERN_INFO "tda1004x: waiting for firmware upload...\n");\r\nret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);\r\nif (ret) {\r\nret = state->config->request_firmware(fe, &fw, TDA10045_DEFAULT_FIRMWARE);\r\nif (ret) {\r\nprintk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");\r\nreturn ret;\r\n} else {\r\nprintk(KERN_INFO "tda1004x: please rename the firmware file to %s\n",\r\nTDA10046_DEFAULT_FIRMWARE);\r\n}\r\n}\r\n} else {\r\nprintk(KERN_ERR "tda1004x: no request function defined, can't upload from file\n");\r\nreturn -EIO;\r\n}\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8);\r\nret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);\r\nrelease_firmware(fw);\r\nreturn tda1004x_check_upload_ok(state);\r\n}\r\nstatic int tda1004x_encode_fec(int fec)\r\n{\r\nswitch (fec) {\r\ncase FEC_1_2:\r\nreturn 0;\r\ncase FEC_2_3:\r\nreturn 1;\r\ncase FEC_3_4:\r\nreturn 2;\r\ncase FEC_5_6:\r\nreturn 3;\r\ncase FEC_7_8:\r\nreturn 4;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tda1004x_decode_fec(int tdafec)\r\n{\r\nswitch (tdafec) {\r\ncase 0:\r\nreturn FEC_1_2;\r\ncase 1:\r\nreturn FEC_2_3;\r\ncase 2:\r\nreturn FEC_3_4;\r\ncase 3:\r\nreturn FEC_5_6;\r\ncase 4:\r\nreturn FEC_7_8;\r\n}\r\nreturn -1;\r\n}\r\nstatic int tda1004x_write(struct dvb_frontend* fe, const u8 buf[], int len)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nreturn tda1004x_write_byteI(state, buf[0], buf[1]);\r\n}\r\nstatic int tda10045_init(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (tda10045_fwupload(fe)) {\r\nprintk("tda1004x: firmware upload failed\n");\r\nreturn -EIO;\r\n}\r\ntda1004x_write_mask(state, TDA1004X_CONFADC1, 0x10, 0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 0x20, 0);\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 8, 0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC1, 0x40, 0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC1, 0x80, 0x80);\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 0x10, 0x10);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF2, 0xC0, 0x0);\r\ntda1004x_write_byteI(state, TDA1004X_CONF_TS1, 0);\r\ntda1004x_write_byteI(state, TDA1004X_CONF_TS2, 0);\r\ntda1004x_write_mask(state, TDA1004X_VBER_MSB, 0xe0, 0xa0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC1, 0x10, 0);\r\ntda1004x_write_byteI(state, TDA1004X_CONFADC1, 0x2e);\r\ntda1004x_write_mask(state, 0x1f, 0x01, state->config->invert_oclk);\r\nreturn 0;\r\n}\r\nstatic int tda10046_init(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (tda10046_fwupload(fe)) {\r\nprintk("tda1004x: firmware upload failed\n");\r\nreturn -EIO;\r\n}\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 0x20, 0);\r\ntda1004x_write_byteI(state, TDA1004X_AUTO, 0x87);\r\ntda1004x_write_byteI(state, TDA1004X_CONFC1, 0x88);\r\nswitch (state->config->agc_config) {\r\ncase TDA10046_AGC_DEFAULT:\r\ntda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x00);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);\r\nbreak;\r\ncase TDA10046_AGC_IFO_AUTO_NEG:\r\ntda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);\r\nbreak;\r\ncase TDA10046_AGC_IFO_AUTO_POS:\r\ntda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x00);\r\nbreak;\r\ncase TDA10046_AGC_TDA827X:\r\ntda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x02);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_THR, 0x70);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_RENORM, 0x08);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0xf0, 0x60);\r\nbreak;\r\n}\r\nif (state->config->ts_mode == 0) {\r\ntda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 0xc0, 0x40);\r\ntda1004x_write_mask(state, 0x3a, 0x80, state->config->invert_oclk << 7);\r\n} else {\r\ntda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 0xc0, 0x80);\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x10,\r\nstate->config->invert_oclk << 4);\r\n}\r\ntda1004x_write_byteI(state, TDA1004X_CONFADC2, 0x38);\r\ntda1004x_write_mask (state, TDA10046H_CONF_TRISTATE1, 0x3e, 0x38);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_TUN_MIN, 0);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_TUN_MAX, 0xff);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_IF_MIN, 0);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_IF_MAX, 0xff);\r\ntda1004x_write_byteI(state, TDA10046H_AGC_GAINS, 0x12);\r\ntda1004x_write_byteI(state, TDA10046H_CVBER_CTRL, 0x1a);\r\ntda1004x_write_byteI(state, TDA1004X_CONF_TS1, 7);\r\ntda1004x_write_byteI(state, TDA1004X_CONF_TS2, 0xc0);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_set_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tmp;\r\nint inversion;\r\ndprintk("%s\n", __func__);\r\nif (state->demod_type == TDA1004X_DEMOD_TDA10046) {\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 0x10, 0x10);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x80, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF2, 0xC0, 0);\r\ntda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 0);\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (state->demod_type == TDA1004X_DEMOD_TDA10045) {\r\nfe_params->code_rate_HP = FEC_AUTO;\r\nfe_params->guard_interval = GUARD_INTERVAL_AUTO;\r\nfe_params->transmission_mode = TRANSMISSION_MODE_AUTO;\r\n}\r\nif ((fe_params->code_rate_HP == FEC_AUTO) ||\r\n(fe_params->code_rate_LP == FEC_AUTO) ||\r\n(fe_params->modulation == QAM_AUTO) ||\r\n(fe_params->hierarchy == HIERARCHY_AUTO)) {\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 1, 1);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x03, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF2, 0x3f, 0);\r\n} else {\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 1, 0);\r\ntmp = tda1004x_encode_fec(fe_params->code_rate_HP);\r\nif (tmp < 0)\r\nreturn tmp;\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF2, 7, tmp);\r\ntmp = tda1004x_encode_fec(fe_params->code_rate_LP);\r\nif (tmp < 0)\r\nreturn tmp;\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF2, 0x38, tmp << 3);\r\nswitch (fe_params->modulation) {\r\ncase QPSK:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 0);\r\nbreak;\r\ncase QAM_16:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 1);\r\nbreak;\r\ncase QAM_64:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 3, 2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fe_params->hierarchy) {\r\ncase HIERARCHY_NONE:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 0 << 5);\r\nbreak;\r\ncase HIERARCHY_1:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 1 << 5);\r\nbreak;\r\ncase HIERARCHY_2:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 2 << 5);\r\nbreak;\r\ncase HIERARCHY_4:\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 3 << 5);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (state->demod_type) {\r\ncase TDA1004X_DEMOD_TDA10045:\r\ntda10045h_set_bandwidth(state, fe_params->bandwidth_hz);\r\nbreak;\r\ncase TDA1004X_DEMOD_TDA10046:\r\ntda10046h_set_bandwidth(state, fe_params->bandwidth_hz);\r\nbreak;\r\n}\r\ninversion = fe_params->inversion;\r\nif (state->config->invert)\r\ninversion = inversion ? INVERSION_OFF : INVERSION_ON;\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\ntda1004x_write_mask(state, TDA1004X_CONFC1, 0x20, 0);\r\nbreak;\r\ncase INVERSION_ON:\r\ntda1004x_write_mask(state, TDA1004X_CONFC1, 0x20, 0x20);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fe_params->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 0 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 1 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 2 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 2, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 3 << 2);\r\nbreak;\r\ncase GUARD_INTERVAL_AUTO:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 2, 2);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x0c, 0 << 2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fe_params->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 4, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 0 << 4);\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 4, 0);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 1 << 4);\r\nbreak;\r\ncase TRANSMISSION_MODE_AUTO:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 4, 4);\r\ntda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x10, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (state->demod_type) {\r\ncase TDA1004X_DEMOD_TDA10045:\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 8, 0);\r\nbreak;\r\ncase TDA1004X_DEMOD_TDA10046:\r\ntda1004x_write_mask(state, TDA1004X_AUTO, 0x40, 0x40);\r\nmsleep(1);\r\ntda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 1);\r\nbreak;\r\n}\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_get_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nfe_params->inversion = INVERSION_OFF;\r\nif (tda1004x_read_byte(state, TDA1004X_CONFC1) & 0x20)\r\nfe_params->inversion = INVERSION_ON;\r\nif (state->config->invert)\r\nfe_params->inversion = fe_params->inversion ? INVERSION_OFF : INVERSION_ON;\r\nswitch (state->demod_type) {\r\ncase TDA1004X_DEMOD_TDA10045:\r\nswitch (tda1004x_read_byte(state, TDA10045H_WREF_LSB)) {\r\ncase 0x14:\r\nfe_params->bandwidth_hz = 8000000;\r\nbreak;\r\ncase 0xdb:\r\nfe_params->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 0x4f:\r\nfe_params->bandwidth_hz = 6000000;\r\nbreak;\r\n}\r\nbreak;\r\ncase TDA1004X_DEMOD_TDA10046:\r\nswitch (tda1004x_read_byte(state, TDA10046H_TIME_WREF1)) {\r\ncase 0x5c:\r\ncase 0x54:\r\nfe_params->bandwidth_hz = 8000000;\r\nbreak;\r\ncase 0x6a:\r\ncase 0x60:\r\nfe_params->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 0x7b:\r\ncase 0x70:\r\nfe_params->bandwidth_hz = 6000000;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nfe_params->code_rate_HP =\r\ntda1004x_decode_fec(tda1004x_read_byte(state, TDA1004X_OUT_CONF2) & 7);\r\nfe_params->code_rate_LP =\r\ntda1004x_decode_fec((tda1004x_read_byte(state, TDA1004X_OUT_CONF2) >> 3) & 7);\r\nswitch (tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 3) {\r\ncase 0:\r\nfe_params->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nfe_params->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nfe_params->modulation = QAM_64;\r\nbreak;\r\n}\r\nfe_params->transmission_mode = TRANSMISSION_MODE_2K;\r\nif (tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x10)\r\nfe_params->transmission_mode = TRANSMISSION_MODE_8K;\r\nswitch ((tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x0c) >> 2) {\r\ncase 0:\r\nfe_params->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nfe_params->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nfe_params->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nfe_params->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((tda1004x_read_byte(state, TDA1004X_OUT_CONF1) & 0x60) >> 5) {\r\ncase 0:\r\nfe_params->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nfe_params->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nfe_params->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nfe_params->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda1004x_read_status(struct dvb_frontend* fe, fe_status_t * fe_status)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint status;\r\nint cber;\r\nint vber;\r\ndprintk("%s\n", __func__);\r\nstatus = tda1004x_read_byte(state, TDA1004X_STATUS_CD);\r\nif (status == -1)\r\nreturn -EIO;\r\n*fe_status = 0;\r\nif (status & 4)\r\n*fe_status |= FE_HAS_SIGNAL;\r\nif (status & 2)\r\n*fe_status |= FE_HAS_CARRIER;\r\nif (status & 8)\r\n*fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\nif (!(*fe_status & FE_HAS_VITERBI)) {\r\ncber = tda1004x_read_byte(state, TDA1004X_CBER_LSB);\r\nif (cber == -1)\r\nreturn -EIO;\r\nstatus = tda1004x_read_byte(state, TDA1004X_CBER_MSB);\r\nif (status == -1)\r\nreturn -EIO;\r\ncber |= (status << 8);\r\ntda1004x_read_byte(state, TDA1004X_CBER_RESET);\r\nif (cber != 65535)\r\n*fe_status |= FE_HAS_VITERBI;\r\n}\r\nif ((*fe_status & FE_HAS_VITERBI) && (!(*fe_status & FE_HAS_SYNC))) {\r\nvber = tda1004x_read_byte(state, TDA1004X_VBER_LSB);\r\nif (vber == -1)\r\nreturn -EIO;\r\nstatus = tda1004x_read_byte(state, TDA1004X_VBER_MID);\r\nif (status == -1)\r\nreturn -EIO;\r\nvber |= (status << 8);\r\nstatus = tda1004x_read_byte(state, TDA1004X_VBER_MSB);\r\nif (status == -1)\r\nreturn -EIO;\r\nvber |= (status & 0x0f) << 16;\r\ntda1004x_read_byte(state, TDA1004X_CVBER_LUT);\r\nif (vber < 16632)\r\n*fe_status |= FE_HAS_SYNC;\r\n}\r\ndprintk("%s: fe_status=0x%x\n", __func__, *fe_status);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_read_signal_strength(struct dvb_frontend* fe, u16 * signal)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tmp;\r\nint reg = 0;\r\ndprintk("%s\n", __func__);\r\nswitch (state->demod_type) {\r\ncase TDA1004X_DEMOD_TDA10045:\r\nreg = TDA10045H_S_AGC;\r\nbreak;\r\ncase TDA1004X_DEMOD_TDA10046:\r\nreg = TDA10046H_AGC_IF_LEVEL;\r\nbreak;\r\n}\r\ntmp = tda1004x_read_byte(state, reg);\r\nif (tmp < 0)\r\nreturn -EIO;\r\n*signal = (tmp << 8) | tmp;\r\ndprintk("%s: signal=0x%x\n", __func__, *signal);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_read_snr(struct dvb_frontend* fe, u16 * snr)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tmp;\r\ndprintk("%s\n", __func__);\r\ntmp = tda1004x_read_byte(state, TDA1004X_SNR);\r\nif (tmp < 0)\r\nreturn -EIO;\r\ntmp = 255 - tmp;\r\n*snr = ((tmp << 8) | tmp);\r\ndprintk("%s: snr=0x%x\n", __func__, *snr);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tmp;\r\nint tmp2;\r\nint counter;\r\ndprintk("%s\n", __func__);\r\ncounter = 0;\r\ntmp = tda1004x_read_byte(state, TDA1004X_UNCOR);\r\nif (tmp < 0)\r\nreturn -EIO;\r\ntmp &= 0x7f;\r\nwhile (counter++ < 5) {\r\ntda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\r\ntda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\r\ntda1004x_write_mask(state, TDA1004X_UNCOR, 0x80, 0);\r\ntmp2 = tda1004x_read_byte(state, TDA1004X_UNCOR);\r\nif (tmp2 < 0)\r\nreturn -EIO;\r\ntmp2 &= 0x7f;\r\nif ((tmp2 < tmp) || (tmp2 == 0))\r\nbreak;\r\n}\r\nif (tmp != 0x7f)\r\n*ucblocks = tmp;\r\nelse\r\n*ucblocks = 0xffffffff;\r\ndprintk("%s: ucblocks=0x%x\n", __func__, *ucblocks);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint tmp;\r\ndprintk("%s\n", __func__);\r\ntmp = tda1004x_read_byte(state, TDA1004X_CBER_LSB);\r\nif (tmp < 0)\r\nreturn -EIO;\r\n*ber = tmp << 1;\r\ntmp = tda1004x_read_byte(state, TDA1004X_CBER_MSB);\r\nif (tmp < 0)\r\nreturn -EIO;\r\n*ber |= (tmp << 9);\r\ntda1004x_read_byte(state, TDA1004X_CBER_RESET);\r\ndprintk("%s: ber=0x%x\n", __func__, *ber);\r\nreturn 0;\r\n}\r\nstatic int tda1004x_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nint gpio_conf;\r\nswitch (state->demod_type) {\r\ncase TDA1004X_DEMOD_TDA10045:\r\ntda1004x_write_mask(state, TDA1004X_CONFADC1, 0x10, 0x10);\r\nbreak;\r\ncase TDA1004X_DEMOD_TDA10046:\r\ntda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE1, 0xff);\r\ngpio_conf = state->config->gpio_config;\r\nif (gpio_conf >= TDA10046_GP00_I)\r\ntda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x0f,\r\n(gpio_conf & 0x0f) ^ 0x0a);\r\ntda1004x_write_mask(state, TDA1004X_CONFADC2, 0xc0, 0xc0);\r\ntda1004x_write_mask(state, TDA1004X_CONFC4, 1, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda1004x_i2c_gate_ctrl(struct dvb_frontend* fe, int enable)\r\n{\r\nstruct tda1004x_state* state = fe->demodulator_priv;\r\nif (enable) {\r\nreturn tda1004x_enable_tuner_i2c(state);\r\n} else {\r\nreturn tda1004x_disable_tuner_i2c(state);\r\n}\r\n}\r\nstatic int tda1004x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void tda1004x_release(struct dvb_frontend* fe)\r\n{\r\nstruct tda1004x_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* tda10045_attach(const struct tda1004x_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct tda1004x_state *state;\r\nint id;\r\nstate = kzalloc(sizeof(struct tda1004x_state), GFP_KERNEL);\r\nif (!state) {\r\nprintk(KERN_ERR "Can't allocate memory for tda10045 state\n");\r\nreturn NULL;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->demod_type = TDA1004X_DEMOD_TDA10045;\r\nid = tda1004x_read_byte(state, TDA1004X_CHIPID);\r\nif (id < 0) {\r\nprintk(KERN_ERR "tda10045: chip is not answering. Giving up.\n");\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nif (id != 0x25) {\r\nprintk(KERN_ERR "Invalid tda1004x ID = 0x%02x. Can't proceed\n", id);\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nmemcpy(&state->frontend.ops, &tda10045_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\n}\r\nstruct dvb_frontend* tda10046_attach(const struct tda1004x_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct tda1004x_state *state;\r\nint id;\r\nstate = kzalloc(sizeof(struct tda1004x_state), GFP_KERNEL);\r\nif (!state) {\r\nprintk(KERN_ERR "Can't allocate memory for tda10046 state\n");\r\nreturn NULL;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->demod_type = TDA1004X_DEMOD_TDA10046;\r\nid = tda1004x_read_byte(state, TDA1004X_CHIPID);\r\nif (id < 0) {\r\nprintk(KERN_ERR "tda10046: chip is not answering. Giving up.\n");\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nif (id != 0x46) {\r\nprintk(KERN_ERR "Invalid tda1004x ID = 0x%02x. Can't proceed\n", id);\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nmemcpy(&state->frontend.ops, &tda10046_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\n}
