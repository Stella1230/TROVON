static void tifm_sd_read_fifo(struct tifm_sd *host, struct page *pg,\r\nunsigned int off, unsigned int cnt)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned char *buf;\r\nunsigned int pos = 0, val;\r\nbuf = kmap_atomic(pg) + off;\r\nif (host->cmd_flags & DATA_CARRY) {\r\nbuf[pos++] = host->bounce_buf_data[0];\r\nhost->cmd_flags &= ~DATA_CARRY;\r\n}\r\nwhile (pos < cnt) {\r\nval = readl(sock->addr + SOCK_MMCSD_DATA);\r\nbuf[pos++] = val & 0xff;\r\nif (pos == cnt) {\r\nhost->bounce_buf_data[0] = (val >> 8) & 0xff;\r\nhost->cmd_flags |= DATA_CARRY;\r\nbreak;\r\n}\r\nbuf[pos++] = (val >> 8) & 0xff;\r\n}\r\nkunmap_atomic(buf - off);\r\n}\r\nstatic void tifm_sd_write_fifo(struct tifm_sd *host, struct page *pg,\r\nunsigned int off, unsigned int cnt)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned char *buf;\r\nunsigned int pos = 0, val;\r\nbuf = kmap_atomic(pg) + off;\r\nif (host->cmd_flags & DATA_CARRY) {\r\nval = host->bounce_buf_data[0] | ((buf[pos++] << 8) & 0xff00);\r\nwritel(val, sock->addr + SOCK_MMCSD_DATA);\r\nhost->cmd_flags &= ~DATA_CARRY;\r\n}\r\nwhile (pos < cnt) {\r\nval = buf[pos++];\r\nif (pos == cnt) {\r\nhost->bounce_buf_data[0] = val & 0xff;\r\nhost->cmd_flags |= DATA_CARRY;\r\nbreak;\r\n}\r\nval |= (buf[pos++] << 8) & 0xff00;\r\nwritel(val, sock->addr + SOCK_MMCSD_DATA);\r\n}\r\nkunmap_atomic(buf - off);\r\n}\r\nstatic void tifm_sd_transfer_data(struct tifm_sd *host)\r\n{\r\nstruct mmc_data *r_data = host->req->cmd->data;\r\nstruct scatterlist *sg = r_data->sg;\r\nunsigned int off, cnt, t_size = TIFM_MMCSD_FIFO_SIZE * 2;\r\nunsigned int p_off, p_cnt;\r\nstruct page *pg;\r\nif (host->sg_pos == host->sg_len)\r\nreturn;\r\nwhile (t_size) {\r\ncnt = sg[host->sg_pos].length - host->block_pos;\r\nif (!cnt) {\r\nhost->block_pos = 0;\r\nhost->sg_pos++;\r\nif (host->sg_pos == host->sg_len) {\r\nif ((r_data->flags & MMC_DATA_WRITE)\r\n&& (host->cmd_flags & DATA_CARRY))\r\nwritel(host->bounce_buf_data[0],\r\nhost->dev->addr\r\n+ SOCK_MMCSD_DATA);\r\nreturn;\r\n}\r\ncnt = sg[host->sg_pos].length;\r\n}\r\noff = sg[host->sg_pos].offset + host->block_pos;\r\npg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);\r\np_off = offset_in_page(off);\r\np_cnt = PAGE_SIZE - p_off;\r\np_cnt = min(p_cnt, cnt);\r\np_cnt = min(p_cnt, t_size);\r\nif (r_data->flags & MMC_DATA_READ)\r\ntifm_sd_read_fifo(host, pg, p_off, p_cnt);\r\nelse if (r_data->flags & MMC_DATA_WRITE)\r\ntifm_sd_write_fifo(host, pg, p_off, p_cnt);\r\nt_size -= p_cnt;\r\nhost->block_pos += p_cnt;\r\n}\r\n}\r\nstatic void tifm_sd_copy_page(struct page *dst, unsigned int dst_off,\r\nstruct page *src, unsigned int src_off,\r\nunsigned int count)\r\n{\r\nunsigned char *src_buf = kmap_atomic(src) + src_off;\r\nunsigned char *dst_buf = kmap_atomic(dst) + dst_off;\r\nmemcpy(dst_buf, src_buf, count);\r\nkunmap_atomic(dst_buf - dst_off);\r\nkunmap_atomic(src_buf - src_off);\r\n}\r\nstatic void tifm_sd_bounce_block(struct tifm_sd *host, struct mmc_data *r_data)\r\n{\r\nstruct scatterlist *sg = r_data->sg;\r\nunsigned int t_size = r_data->blksz;\r\nunsigned int off, cnt;\r\nunsigned int p_off, p_cnt;\r\nstruct page *pg;\r\ndev_dbg(&host->dev->dev, "bouncing block\n");\r\nwhile (t_size) {\r\ncnt = sg[host->sg_pos].length - host->block_pos;\r\nif (!cnt) {\r\nhost->block_pos = 0;\r\nhost->sg_pos++;\r\nif (host->sg_pos == host->sg_len)\r\nreturn;\r\ncnt = sg[host->sg_pos].length;\r\n}\r\noff = sg[host->sg_pos].offset + host->block_pos;\r\npg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);\r\np_off = offset_in_page(off);\r\np_cnt = PAGE_SIZE - p_off;\r\np_cnt = min(p_cnt, cnt);\r\np_cnt = min(p_cnt, t_size);\r\nif (r_data->flags & MMC_DATA_WRITE)\r\ntifm_sd_copy_page(sg_page(&host->bounce_buf),\r\nr_data->blksz - t_size,\r\npg, p_off, p_cnt);\r\nelse if (r_data->flags & MMC_DATA_READ)\r\ntifm_sd_copy_page(pg, p_off, sg_page(&host->bounce_buf),\r\nr_data->blksz - t_size, p_cnt);\r\nt_size -= p_cnt;\r\nhost->block_pos += p_cnt;\r\n}\r\n}\r\nstatic int tifm_sd_set_dma_data(struct tifm_sd *host, struct mmc_data *r_data)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int t_size = TIFM_DMA_TSIZE * r_data->blksz;\r\nunsigned int dma_len, dma_blk_cnt, dma_off;\r\nstruct scatterlist *sg = NULL;\r\nunsigned long flags;\r\nif (host->sg_pos == host->sg_len)\r\nreturn 1;\r\nif (host->cmd_flags & DATA_CARRY) {\r\nhost->cmd_flags &= ~DATA_CARRY;\r\nlocal_irq_save(flags);\r\ntifm_sd_bounce_block(host, r_data);\r\nlocal_irq_restore(flags);\r\nif (host->sg_pos == host->sg_len)\r\nreturn 1;\r\n}\r\ndma_len = sg_dma_len(&r_data->sg[host->sg_pos]) - host->block_pos;\r\nif (!dma_len) {\r\nhost->block_pos = 0;\r\nhost->sg_pos++;\r\nif (host->sg_pos == host->sg_len)\r\nreturn 1;\r\ndma_len = sg_dma_len(&r_data->sg[host->sg_pos]);\r\n}\r\nif (dma_len < t_size) {\r\ndma_blk_cnt = dma_len / r_data->blksz;\r\ndma_off = host->block_pos;\r\nhost->block_pos += dma_blk_cnt * r_data->blksz;\r\n} else {\r\ndma_blk_cnt = TIFM_DMA_TSIZE;\r\ndma_off = host->block_pos;\r\nhost->block_pos += t_size;\r\n}\r\nif (dma_blk_cnt)\r\nsg = &r_data->sg[host->sg_pos];\r\nelse if (dma_len) {\r\nif (r_data->flags & MMC_DATA_WRITE) {\r\nlocal_irq_save(flags);\r\ntifm_sd_bounce_block(host, r_data);\r\nlocal_irq_restore(flags);\r\n} else\r\nhost->cmd_flags |= DATA_CARRY;\r\nsg = &host->bounce_buf;\r\ndma_off = 0;\r\ndma_blk_cnt = 1;\r\n} else\r\nreturn 1;\r\ndev_dbg(&sock->dev, "setting dma for %d blocks\n", dma_blk_cnt);\r\nwritel(sg_dma_address(sg) + dma_off, sock->addr + SOCK_DMA_ADDRESS);\r\nif (r_data->flags & MMC_DATA_WRITE)\r\nwritel((dma_blk_cnt << 8) | TIFM_DMA_TX | TIFM_DMA_EN,\r\nsock->addr + SOCK_DMA_CONTROL);\r\nelse\r\nwritel((dma_blk_cnt << 8) | TIFM_DMA_EN,\r\nsock->addr + SOCK_DMA_CONTROL);\r\nreturn 0;\r\n}\r\nstatic unsigned int tifm_sd_op_flags(struct mmc_command *cmd)\r\n{\r\nunsigned int rc = 0;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nrc |= TIFM_MMCSD_RSP_R0;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nrc |= TIFM_MMCSD_RSP_BUSY;\r\ncase MMC_RSP_R1:\r\nrc |= TIFM_MMCSD_RSP_R1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nrc |= TIFM_MMCSD_RSP_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nrc |= TIFM_MMCSD_RSP_R3;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nswitch (mmc_cmd_type(cmd)) {\r\ncase MMC_CMD_BC:\r\nrc |= TIFM_MMCSD_CMD_BC;\r\nbreak;\r\ncase MMC_CMD_BCR:\r\nrc |= TIFM_MMCSD_CMD_BCR;\r\nbreak;\r\ncase MMC_CMD_AC:\r\nrc |= TIFM_MMCSD_CMD_AC;\r\nbreak;\r\ncase MMC_CMD_ADTC:\r\nrc |= TIFM_MMCSD_CMD_ADTC;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic void tifm_sd_exec(struct tifm_sd *host, struct mmc_command *cmd)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int cmd_mask = tifm_sd_op_flags(cmd);\r\nif (host->open_drain)\r\ncmd_mask |= TIFM_MMCSD_ODTO;\r\nif (cmd->data && (cmd->data->flags & MMC_DATA_READ))\r\ncmd_mask |= TIFM_MMCSD_READ;\r\ndev_dbg(&sock->dev, "executing opcode 0x%x, arg: 0x%x, mask: 0x%x\n",\r\ncmd->opcode, cmd->arg, cmd_mask);\r\nwritel((cmd->arg >> 16) & 0xffff, sock->addr + SOCK_MMCSD_ARG_HIGH);\r\nwritel(cmd->arg & 0xffff, sock->addr + SOCK_MMCSD_ARG_LOW);\r\nwritel(cmd->opcode | cmd_mask, sock->addr + SOCK_MMCSD_COMMAND);\r\n}\r\nstatic void tifm_sd_fetch_resp(struct mmc_command *cmd, struct tifm_dev *sock)\r\n{\r\ncmd->resp[0] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x1c) << 16)\r\n| readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x18);\r\ncmd->resp[1] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x14) << 16)\r\n| readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x10);\r\ncmd->resp[2] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x0c) << 16)\r\n| readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x08);\r\ncmd->resp[3] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x04) << 16)\r\n| readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x00);\r\n}\r\nstatic void tifm_sd_check_status(struct tifm_sd *host)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nstruct mmc_command *cmd = host->req->cmd;\r\nif (cmd->error)\r\ngoto finish_request;\r\nif (!(host->cmd_flags & CMD_READY))\r\nreturn;\r\nif (cmd->data) {\r\nif (cmd->data->error) {\r\nif ((host->cmd_flags & SCMD_ACTIVE)\r\n&& !(host->cmd_flags & SCMD_READY))\r\nreturn;\r\ngoto finish_request;\r\n}\r\nif (!(host->cmd_flags & BRS_READY))\r\nreturn;\r\nif (!(host->no_dma || (host->cmd_flags & FIFO_READY)))\r\nreturn;\r\nif (cmd->data->flags & MMC_DATA_WRITE) {\r\nif (host->req->stop) {\r\nif (!(host->cmd_flags & SCMD_ACTIVE)) {\r\nhost->cmd_flags |= SCMD_ACTIVE;\r\nwritel(TIFM_MMCSD_EOFB\r\n| readl(sock->addr\r\n+ SOCK_MMCSD_INT_ENABLE),\r\nsock->addr\r\n+ SOCK_MMCSD_INT_ENABLE);\r\ntifm_sd_exec(host, host->req->stop);\r\nreturn;\r\n} else {\r\nif (!(host->cmd_flags & SCMD_READY)\r\n|| (host->cmd_flags & CARD_BUSY))\r\nreturn;\r\nwritel((~TIFM_MMCSD_EOFB)\r\n& readl(sock->addr\r\n+ SOCK_MMCSD_INT_ENABLE),\r\nsock->addr\r\n+ SOCK_MMCSD_INT_ENABLE);\r\n}\r\n} else {\r\nif (host->cmd_flags & CARD_BUSY)\r\nreturn;\r\nwritel((~TIFM_MMCSD_EOFB)\r\n& readl(sock->addr\r\n+ SOCK_MMCSD_INT_ENABLE),\r\nsock->addr + SOCK_MMCSD_INT_ENABLE);\r\n}\r\n} else {\r\nif (host->req->stop) {\r\nif (!(host->cmd_flags & SCMD_ACTIVE)) {\r\nhost->cmd_flags |= SCMD_ACTIVE;\r\ntifm_sd_exec(host, host->req->stop);\r\nreturn;\r\n} else {\r\nif (!(host->cmd_flags & SCMD_READY))\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nfinish_request:\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\nstatic void tifm_sd_data_event(struct tifm_dev *sock)\r\n{\r\nstruct tifm_sd *host;\r\nunsigned int fifo_status = 0;\r\nstruct mmc_data *r_data = NULL;\r\nspin_lock(&sock->lock);\r\nhost = mmc_priv((struct mmc_host*)tifm_get_drvdata(sock));\r\nfifo_status = readl(sock->addr + SOCK_DMA_FIFO_STATUS);\r\ndev_dbg(&sock->dev, "data event: fifo_status %x, flags %x\n",\r\nfifo_status, host->cmd_flags);\r\nif (host->req) {\r\nr_data = host->req->cmd->data;\r\nif (r_data && (fifo_status & TIFM_FIFO_READY)) {\r\nif (tifm_sd_set_dma_data(host, r_data)) {\r\nhost->cmd_flags |= FIFO_READY;\r\ntifm_sd_check_status(host);\r\n}\r\n}\r\n}\r\nwritel(fifo_status, sock->addr + SOCK_DMA_FIFO_STATUS);\r\nspin_unlock(&sock->lock);\r\n}\r\nstatic void tifm_sd_card_event(struct tifm_dev *sock)\r\n{\r\nstruct tifm_sd *host;\r\nunsigned int host_status = 0;\r\nint cmd_error = 0;\r\nstruct mmc_command *cmd = NULL;\r\nunsigned long flags;\r\nspin_lock(&sock->lock);\r\nhost = mmc_priv((struct mmc_host*)tifm_get_drvdata(sock));\r\nhost_status = readl(sock->addr + SOCK_MMCSD_STATUS);\r\ndev_dbg(&sock->dev, "host event: host_status %x, flags %x\n",\r\nhost_status, host->cmd_flags);\r\nif (host->req) {\r\ncmd = host->req->cmd;\r\nif (host_status & TIFM_MMCSD_ERRMASK) {\r\nwritel(host_status & TIFM_MMCSD_ERRMASK,\r\nsock->addr + SOCK_MMCSD_STATUS);\r\nif (host_status & TIFM_MMCSD_CTO)\r\ncmd_error = -ETIMEDOUT;\r\nelse if (host_status & TIFM_MMCSD_CCRC)\r\ncmd_error = -EILSEQ;\r\nif (cmd->data) {\r\nif (host_status & TIFM_MMCSD_DTO)\r\ncmd->data->error = -ETIMEDOUT;\r\nelse if (host_status & TIFM_MMCSD_DCRC)\r\ncmd->data->error = -EILSEQ;\r\n}\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\r\nif (host->req->stop) {\r\nif (host->cmd_flags & SCMD_ACTIVE) {\r\nhost->req->stop->error = cmd_error;\r\nhost->cmd_flags |= SCMD_READY;\r\n} else {\r\ncmd->error = cmd_error;\r\nhost->cmd_flags |= SCMD_ACTIVE;\r\ntifm_sd_exec(host, host->req->stop);\r\ngoto done;\r\n}\r\n} else\r\ncmd->error = cmd_error;\r\n} else {\r\nif (host_status & (TIFM_MMCSD_EOC | TIFM_MMCSD_CERR)) {\r\nif (!(host->cmd_flags & CMD_READY)) {\r\nhost->cmd_flags |= CMD_READY;\r\ntifm_sd_fetch_resp(cmd, sock);\r\n} else if (host->cmd_flags & SCMD_ACTIVE) {\r\nhost->cmd_flags |= SCMD_READY;\r\ntifm_sd_fetch_resp(host->req->stop,\r\nsock);\r\n}\r\n}\r\nif (host_status & TIFM_MMCSD_BRS)\r\nhost->cmd_flags |= BRS_READY;\r\n}\r\nif (host->no_dma && cmd->data) {\r\nif (host_status & TIFM_MMCSD_AE)\r\nwritel(host_status & TIFM_MMCSD_AE,\r\nsock->addr + SOCK_MMCSD_STATUS);\r\nif (host_status & (TIFM_MMCSD_AE | TIFM_MMCSD_AF\r\n| TIFM_MMCSD_BRS)) {\r\nlocal_irq_save(flags);\r\ntifm_sd_transfer_data(host);\r\nlocal_irq_restore(flags);\r\nhost_status &= ~TIFM_MMCSD_AE;\r\n}\r\n}\r\nif (host_status & TIFM_MMCSD_EOFB)\r\nhost->cmd_flags &= ~CARD_BUSY;\r\nelse if (host_status & TIFM_MMCSD_CB)\r\nhost->cmd_flags |= CARD_BUSY;\r\ntifm_sd_check_status(host);\r\n}\r\ndone:\r\nwritel(host_status, sock->addr + SOCK_MMCSD_STATUS);\r\nspin_unlock(&sock->lock);\r\n}\r\nstatic void tifm_sd_set_data_timeout(struct tifm_sd *host,\r\nstruct mmc_data *data)\r\n{\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int data_timeout = data->timeout_clks;\r\nif (fixed_timeout)\r\nreturn;\r\ndata_timeout += data->timeout_ns /\r\n((1000000000UL / host->clk_freq) * host->clk_div);\r\nif (data_timeout < 0xffff) {\r\nwritel(data_timeout, sock->addr + SOCK_MMCSD_DATA_TO);\r\nwritel((~TIFM_MMCSD_DPE)\r\n& readl(sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG),\r\nsock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG);\r\n} else {\r\ndata_timeout = (data_timeout >> 10) + 1;\r\nif (data_timeout > 0xffff)\r\ndata_timeout = 0;\r\nwritel(data_timeout, sock->addr + SOCK_MMCSD_DATA_TO);\r\nwritel(TIFM_MMCSD_DPE\r\n| readl(sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG),\r\nsock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG);\r\n}\r\n}\r\nstatic void tifm_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct tifm_sd *host = mmc_priv(mmc);\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned long flags;\r\nstruct mmc_data *r_data = mrq->cmd->data;\r\nspin_lock_irqsave(&sock->lock, flags);\r\nif (host->eject) {\r\nmrq->cmd->error = -ENOMEDIUM;\r\ngoto err_out;\r\n}\r\nif (host->req) {\r\npr_err("%s : unfinished request detected\n",\r\ndev_name(&sock->dev));\r\nmrq->cmd->error = -ETIMEDOUT;\r\ngoto err_out;\r\n}\r\nhost->cmd_flags = 0;\r\nhost->block_pos = 0;\r\nhost->sg_pos = 0;\r\nif (mrq->data && !is_power_of_2(mrq->data->blksz))\r\nhost->no_dma = 1;\r\nelse\r\nhost->no_dma = no_dma ? 1 : 0;\r\nif (r_data) {\r\ntifm_sd_set_data_timeout(host, r_data);\r\nif ((r_data->flags & MMC_DATA_WRITE) && !mrq->stop)\r\nwritel(TIFM_MMCSD_EOFB\r\n| readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\r\nsock->addr + SOCK_MMCSD_INT_ENABLE);\r\nif (host->no_dma) {\r\nwritel(TIFM_MMCSD_BUFINT\r\n| readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\r\nsock->addr + SOCK_MMCSD_INT_ENABLE);\r\nwritel(((TIFM_MMCSD_FIFO_SIZE - 1) << 8)\r\n| (TIFM_MMCSD_FIFO_SIZE - 1),\r\nsock->addr + SOCK_MMCSD_BUFFER_CONFIG);\r\nhost->sg_len = r_data->sg_len;\r\n} else {\r\nsg_init_one(&host->bounce_buf, host->bounce_buf_data,\r\nr_data->blksz);\r\nif(1 != tifm_map_sg(sock, &host->bounce_buf, 1,\r\nr_data->flags & MMC_DATA_WRITE\r\n? PCI_DMA_TODEVICE\r\n: PCI_DMA_FROMDEVICE)) {\r\npr_err("%s : scatterlist map failed\n",\r\ndev_name(&sock->dev));\r\nmrq->cmd->error = -ENOMEM;\r\ngoto err_out;\r\n}\r\nhost->sg_len = tifm_map_sg(sock, r_data->sg,\r\nr_data->sg_len,\r\nr_data->flags\r\n& MMC_DATA_WRITE\r\n? PCI_DMA_TODEVICE\r\n: PCI_DMA_FROMDEVICE);\r\nif (host->sg_len < 1) {\r\npr_err("%s : scatterlist map failed\n",\r\ndev_name(&sock->dev));\r\ntifm_unmap_sg(sock, &host->bounce_buf, 1,\r\nr_data->flags & MMC_DATA_WRITE\r\n? PCI_DMA_TODEVICE\r\n: PCI_DMA_FROMDEVICE);\r\nmrq->cmd->error = -ENOMEM;\r\ngoto err_out;\r\n}\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(ilog2(r_data->blksz) - 2,\r\nsock->addr + SOCK_FIFO_PAGE_SIZE);\r\nwritel(TIFM_FIFO_ENABLE,\r\nsock->addr + SOCK_FIFO_CONTROL);\r\nwritel(TIFM_FIFO_INTMASK,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\r\nif (r_data->flags & MMC_DATA_WRITE)\r\nwritel(TIFM_MMCSD_TXDE,\r\nsock->addr + SOCK_MMCSD_BUFFER_CONFIG);\r\nelse\r\nwritel(TIFM_MMCSD_RXDE,\r\nsock->addr + SOCK_MMCSD_BUFFER_CONFIG);\r\ntifm_sd_set_dma_data(host, r_data);\r\n}\r\nwritel(r_data->blocks - 1,\r\nsock->addr + SOCK_MMCSD_NUM_BLOCKS);\r\nwritel(r_data->blksz - 1,\r\nsock->addr + SOCK_MMCSD_BLOCK_LEN);\r\n}\r\nhost->req = mrq;\r\nmod_timer(&host->timer, jiffies + host->timeout_jiffies);\r\nwritel(TIFM_CTRL_LED | readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\ntifm_sd_exec(host, mrq->cmd);\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nreturn;\r\nerr_out:\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nmmc_request_done(mmc, mrq);\r\n}\r\nstatic void tifm_sd_end_cmd(unsigned long data)\r\n{\r\nstruct tifm_sd *host = (struct tifm_sd*)data;\r\nstruct tifm_dev *sock = host->dev;\r\nstruct mmc_host *mmc = tifm_get_drvdata(sock);\r\nstruct mmc_request *mrq;\r\nstruct mmc_data *r_data = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sock->lock, flags);\r\ndel_timer(&host->timer);\r\nmrq = host->req;\r\nhost->req = NULL;\r\nif (!mrq) {\r\npr_err(" %s : no request to complete?\n",\r\ndev_name(&sock->dev));\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nreturn;\r\n}\r\nr_data = mrq->cmd->data;\r\nif (r_data) {\r\nif (host->no_dma) {\r\nwritel((~TIFM_MMCSD_BUFINT)\r\n& readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\r\nsock->addr + SOCK_MMCSD_INT_ENABLE);\r\n} else {\r\ntifm_unmap_sg(sock, &host->bounce_buf, 1,\r\n(r_data->flags & MMC_DATA_WRITE)\r\n? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\ntifm_unmap_sg(sock, r_data->sg, r_data->sg_len,\r\n(r_data->flags & MMC_DATA_WRITE)\r\n? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);\r\n}\r\nr_data->bytes_xfered = r_data->blocks\r\n- readl(sock->addr + SOCK_MMCSD_NUM_BLOCKS) - 1;\r\nr_data->bytes_xfered *= r_data->blksz;\r\nr_data->bytes_xfered += r_data->blksz\r\n- readl(sock->addr + SOCK_MMCSD_BLOCK_LEN) + 1;\r\n}\r\nwritel((~TIFM_CTRL_LED) & readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nmmc_request_done(mmc, mrq);\r\n}\r\nstatic void tifm_sd_abort(unsigned long data)\r\n{\r\nstruct tifm_sd *host = (struct tifm_sd*)data;\r\npr_err("%s : card failed to respond for a long period of time "\r\n"(%x, %x)\n",\r\ndev_name(&host->dev->dev), host->req->cmd->opcode, host->cmd_flags);\r\ntifm_eject(host->dev);\r\n}\r\nstatic void tifm_sd_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct tifm_sd *host = mmc_priv(mmc);\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned int clk_div1, clk_div2;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sock->lock, flags);\r\ndev_dbg(&sock->dev, "ios: clock = %u, vdd = %x, bus_mode = %x, "\r\n"chip_select = %x, power_mode = %x, bus_width = %x\n",\r\nios->clock, ios->vdd, ios->bus_mode, ios->chip_select,\r\nios->power_mode, ios->bus_width);\r\nif (ios->bus_width == MMC_BUS_WIDTH_4) {\r\nwritel(TIFM_MMCSD_4BBUS | readl(sock->addr + SOCK_MMCSD_CONFIG),\r\nsock->addr + SOCK_MMCSD_CONFIG);\r\n} else {\r\nwritel((~TIFM_MMCSD_4BBUS)\r\n& readl(sock->addr + SOCK_MMCSD_CONFIG),\r\nsock->addr + SOCK_MMCSD_CONFIG);\r\n}\r\nif (ios->clock) {\r\nclk_div1 = 20000000 / ios->clock;\r\nif (!clk_div1)\r\nclk_div1 = 1;\r\nclk_div2 = 24000000 / ios->clock;\r\nif (!clk_div2)\r\nclk_div2 = 1;\r\nif ((20000000 / clk_div1) > ios->clock)\r\nclk_div1++;\r\nif ((24000000 / clk_div2) > ios->clock)\r\nclk_div2++;\r\nif ((20000000 / clk_div1) > (24000000 / clk_div2)) {\r\nhost->clk_freq = 20000000;\r\nhost->clk_div = clk_div1;\r\nwritel((~TIFM_CTRL_FAST_CLK)\r\n& readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\n} else {\r\nhost->clk_freq = 24000000;\r\nhost->clk_div = clk_div2;\r\nwritel(TIFM_CTRL_FAST_CLK\r\n| readl(sock->addr + SOCK_CONTROL),\r\nsock->addr + SOCK_CONTROL);\r\n}\r\n} else {\r\nhost->clk_div = 0;\r\n}\r\nhost->clk_div &= TIFM_MMCSD_CLKMASK;\r\nwritel(host->clk_div\r\n| ((~TIFM_MMCSD_CLKMASK)\r\n& readl(sock->addr + SOCK_MMCSD_CONFIG)),\r\nsock->addr + SOCK_MMCSD_CONFIG);\r\nhost->open_drain = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN);\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\n}\r\nstatic int tifm_sd_ro(struct mmc_host *mmc)\r\n{\r\nint rc = 0;\r\nstruct tifm_sd *host = mmc_priv(mmc);\r\nstruct tifm_dev *sock = host->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sock->lock, flags);\r\nif (TIFM_MMCSD_CARD_RO & readl(sock->addr + SOCK_PRESENT_STATE))\r\nrc = 1;\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int tifm_sd_initialize_host(struct tifm_sd *host)\r\n{\r\nint rc;\r\nunsigned int host_status = 0;\r\nstruct tifm_dev *sock = host->dev;\r\nwritel(0, sock->addr + SOCK_MMCSD_INT_ENABLE);\r\nmmiowb();\r\nhost->clk_div = 61;\r\nhost->clk_freq = 20000000;\r\nwritel(TIFM_MMCSD_RESET, sock->addr + SOCK_MMCSD_SYSTEM_CONTROL);\r\nwritel(host->clk_div | TIFM_MMCSD_POWER,\r\nsock->addr + SOCK_MMCSD_CONFIG);\r\nfor (rc = 32; rc <= 256; rc <<= 1) {\r\nif (1 & readl(sock->addr + SOCK_MMCSD_SYSTEM_STATUS)) {\r\nrc = 0;\r\nbreak;\r\n}\r\nmsleep(rc);\r\n}\r\nif (rc) {\r\npr_err("%s : controller failed to reset\n",\r\ndev_name(&sock->dev));\r\nreturn -ENODEV;\r\n}\r\nwritel(0, sock->addr + SOCK_MMCSD_NUM_BLOCKS);\r\nwritel(host->clk_div | TIFM_MMCSD_POWER,\r\nsock->addr + SOCK_MMCSD_CONFIG);\r\nwritel(TIFM_MMCSD_RXDE, sock->addr + SOCK_MMCSD_BUFFER_CONFIG);\r\nwritel(64, sock->addr + SOCK_MMCSD_COMMAND_TO);\r\nwritel(TIFM_MMCSD_INAB, sock->addr + SOCK_MMCSD_COMMAND);\r\nfor (rc = 16; rc <= 64; rc <<= 1) {\r\nhost_status = readl(sock->addr + SOCK_MMCSD_STATUS);\r\nwritel(host_status, sock->addr + SOCK_MMCSD_STATUS);\r\nif (!(host_status & TIFM_MMCSD_ERRMASK)\r\n&& (host_status & TIFM_MMCSD_EOC)) {\r\nrc = 0;\r\nbreak;\r\n}\r\nmsleep(rc);\r\n}\r\nif (rc) {\r\npr_err("%s : card not ready - probe failed on initialization\n",\r\ndev_name(&sock->dev));\r\nreturn -ENODEV;\r\n}\r\nwritel(TIFM_MMCSD_CERR | TIFM_MMCSD_BRS | TIFM_MMCSD_EOC\r\n| TIFM_MMCSD_ERRMASK,\r\nsock->addr + SOCK_MMCSD_INT_ENABLE);\r\nmmiowb();\r\nreturn 0;\r\n}\r\nstatic int tifm_sd_probe(struct tifm_dev *sock)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct tifm_sd *host;\r\nint rc = -EIO;\r\nif (!(TIFM_SOCK_STATE_OCCUPIED\r\n& readl(sock->addr + SOCK_PRESENT_STATE))) {\r\npr_warning("%s : card gone, unexpectedly\n",\r\ndev_name(&sock->dev));\r\nreturn rc;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct tifm_sd), &sock->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\ntifm_set_drvdata(sock, mmc);\r\nhost->dev = sock;\r\nhost->timeout_jiffies = msecs_to_jiffies(1000);\r\ntasklet_init(&host->finish_tasklet, tifm_sd_end_cmd,\r\n(unsigned long)host);\r\nsetup_timer(&host->timer, tifm_sd_abort, (unsigned long)host);\r\nmmc->ops = &tifm_sd_ops;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nmmc->f_min = 20000000 / 60;\r\nmmc->f_max = 24000000;\r\nmmc->max_blk_count = 2048;\r\nmmc->max_segs = mmc->max_blk_count;\r\nmmc->max_blk_size = min(TIFM_MMCSD_MAX_BLOCK_SIZE, PAGE_SIZE);\r\nmmc->max_seg_size = mmc->max_blk_count * mmc->max_blk_size;\r\nmmc->max_req_size = mmc->max_seg_size;\r\nsock->card_event = tifm_sd_card_event;\r\nsock->data_event = tifm_sd_data_event;\r\nrc = tifm_sd_initialize_host(host);\r\nif (!rc)\r\nrc = mmc_add_host(mmc);\r\nif (!rc)\r\nreturn 0;\r\nmmc_free_host(mmc);\r\nreturn rc;\r\n}\r\nstatic void tifm_sd_remove(struct tifm_dev *sock)\r\n{\r\nstruct mmc_host *mmc = tifm_get_drvdata(sock);\r\nstruct tifm_sd *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sock->lock, flags);\r\nhost->eject = 1;\r\nwritel(0, sock->addr + SOCK_MMCSD_INT_ENABLE);\r\nmmiowb();\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\ntasklet_kill(&host->finish_tasklet);\r\nspin_lock_irqsave(&sock->lock, flags);\r\nif (host->req) {\r\nwritel(TIFM_FIFO_INT_SETALL,\r\nsock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\r\nwritel(0, sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\r\nhost->req->cmd->error = -ENOMEDIUM;\r\nif (host->req->stop)\r\nhost->req->stop->error = -ENOMEDIUM;\r\ntasklet_schedule(&host->finish_tasklet);\r\n}\r\nspin_unlock_irqrestore(&sock->lock, flags);\r\nmmc_remove_host(mmc);\r\ndev_dbg(&sock->dev, "after remove\n");\r\nmmc_free_host(mmc);\r\n}\r\nstatic int tifm_sd_suspend(struct tifm_dev *sock, pm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tifm_sd_resume(struct tifm_dev *sock)\r\n{\r\nstruct mmc_host *mmc = tifm_get_drvdata(sock);\r\nstruct tifm_sd *host = mmc_priv(mmc);\r\nint rc;\r\nrc = tifm_sd_initialize_host(host);\r\ndev_dbg(&sock->dev, "resume initialize %d\n", rc);\r\nif (rc)\r\nhost->eject = 1;\r\nreturn rc;\r\n}\r\nstatic int __init tifm_sd_init(void)\r\n{\r\nreturn tifm_register_driver(&tifm_sd_driver);\r\n}\r\nstatic void __exit tifm_sd_exit(void)\r\n{\r\ntifm_unregister_driver(&tifm_sd_driver);\r\n}
