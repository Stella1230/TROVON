static int notrace bl_powerdown_finisher(unsigned long arg)\r\n{\r\nunsigned int mpidr = read_cpuid_mpidr();\r\nunsigned int cluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nunsigned int cpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\nmcpm_set_entry_vector(cpu, cluster, cpu_resume);\r\nmcpm_cpu_suspend(0);\r\nreturn 1;\r\n}\r\nstatic int bl_enter_powerdown(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int idx)\r\n{\r\ncpu_pm_enter();\r\ncpu_suspend(0, bl_powerdown_finisher);\r\nmcpm_cpu_powered_up();\r\ncpu_pm_exit();\r\nreturn idx;\r\n}\r\nstatic int __init bl_idle_driver_init(struct cpuidle_driver *drv, int cpu_id)\r\n{\r\nstruct cpuinfo_arm *cpu_info;\r\nstruct cpumask *cpumask;\r\nunsigned long cpuid;\r\nint cpu;\r\ncpumask = kzalloc(cpumask_size(), GFP_KERNEL);\r\nif (!cpumask)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(cpu) {\r\ncpu_info = &per_cpu(cpu_data, cpu);\r\ncpuid = is_smp() ? cpu_info->cpuid : read_cpuid_id();\r\nif ((cpuid & 0xFFF0) == cpu_id)\r\ncpumask_set_cpu(cpu, cpumask);\r\n}\r\ndrv->cpumask = cpumask;\r\nreturn 0;\r\n}\r\nstatic int __init bl_idle_init(void)\r\n{\r\nint ret;\r\nif (!of_machine_is_compatible("arm,vexpress,v2p-ca15_a7"))\r\nreturn -ENODEV;\r\nret = bl_idle_driver_init(&bl_idle_little_driver,\r\nARM_CPU_PART_CORTEX_A7);\r\nif (ret)\r\nreturn ret;\r\nret = bl_idle_driver_init(&bl_idle_big_driver, ARM_CPU_PART_CORTEX_A15);\r\nif (ret)\r\ngoto out_uninit_little;\r\nret = cpuidle_register(&bl_idle_little_driver, NULL);\r\nif (ret)\r\ngoto out_uninit_big;\r\nret = cpuidle_register(&bl_idle_big_driver, NULL);\r\nif (ret)\r\ngoto out_unregister_little;\r\nreturn 0;\r\nout_unregister_little:\r\ncpuidle_unregister(&bl_idle_little_driver);\r\nout_uninit_big:\r\nkfree(bl_idle_big_driver.cpumask);\r\nout_uninit_little:\r\nkfree(bl_idle_little_driver.cpumask);\r\nreturn ret;\r\n}
