static int mv_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 rtc_reg;\r\nrtc_reg = (bin2bcd(tm->tm_sec) << RTC_SECONDS_OFFS) |\r\n(bin2bcd(tm->tm_min) << RTC_MINUTES_OFFS) |\r\n(bin2bcd(tm->tm_hour) << RTC_HOURS_OFFS) |\r\n(bin2bcd(tm->tm_wday) << RTC_WDAY_OFFS);\r\nwritel(rtc_reg, ioaddr + RTC_TIME_REG_OFFS);\r\nrtc_reg = (bin2bcd(tm->tm_mday) << RTC_MDAY_OFFS) |\r\n(bin2bcd(tm->tm_mon + 1) << RTC_MONTH_OFFS) |\r\n(bin2bcd(tm->tm_year % 100) << RTC_YEAR_OFFS);\r\nwritel(rtc_reg, ioaddr + RTC_DATE_REG_OFFS);\r\nreturn 0;\r\n}\r\nstatic int mv_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 rtc_time, rtc_date;\r\nunsigned int year, month, day, hour, minute, second, wday;\r\nrtc_time = readl(ioaddr + RTC_TIME_REG_OFFS);\r\nrtc_date = readl(ioaddr + RTC_DATE_REG_OFFS);\r\nsecond = rtc_time & 0x7f;\r\nminute = (rtc_time >> RTC_MINUTES_OFFS) & 0x7f;\r\nhour = (rtc_time >> RTC_HOURS_OFFS) & 0x3f;\r\nwday = (rtc_time >> RTC_WDAY_OFFS) & 0x7;\r\nday = rtc_date & 0x3f;\r\nmonth = (rtc_date >> RTC_MONTH_OFFS) & 0x3f;\r\nyear = (rtc_date >> RTC_YEAR_OFFS) & 0xff;\r\ntm->tm_sec = bcd2bin(second);\r\ntm->tm_min = bcd2bin(minute);\r\ntm->tm_hour = bcd2bin(hour);\r\ntm->tm_mday = bcd2bin(day);\r\ntm->tm_wday = bcd2bin(wday);\r\ntm->tm_mon = bcd2bin(month) - 1;\r\ntm->tm_year = bcd2bin(year) + 100;\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int mv_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 rtc_time, rtc_date;\r\nunsigned int year, month, day, hour, minute, second, wday;\r\nrtc_time = readl(ioaddr + RTC_ALARM_TIME_REG_OFFS);\r\nrtc_date = readl(ioaddr + RTC_ALARM_DATE_REG_OFFS);\r\nsecond = rtc_time & 0x7f;\r\nminute = (rtc_time >> RTC_MINUTES_OFFS) & 0x7f;\r\nhour = (rtc_time >> RTC_HOURS_OFFS) & 0x3f;\r\nwday = (rtc_time >> RTC_WDAY_OFFS) & 0x7;\r\nday = rtc_date & 0x3f;\r\nmonth = (rtc_date >> RTC_MONTH_OFFS) & 0x3f;\r\nyear = (rtc_date >> RTC_YEAR_OFFS) & 0xff;\r\nalm->time.tm_sec = bcd2bin(second);\r\nalm->time.tm_min = bcd2bin(minute);\r\nalm->time.tm_hour = bcd2bin(hour);\r\nalm->time.tm_mday = bcd2bin(day);\r\nalm->time.tm_wday = bcd2bin(wday);\r\nalm->time.tm_mon = bcd2bin(month) - 1;\r\nalm->time.tm_year = bcd2bin(year) + 100;\r\nif (rtc_valid_tm(&alm->time) < 0) {\r\ndev_err(dev, "retrieved alarm date/time is not valid.\n");\r\nrtc_time_to_tm(0, &alm->time);\r\n}\r\nalm->enabled = !!readl(ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\r\nreturn 0;\r\n}\r\nstatic int mv_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct rtc_plat_data *pdata = dev_get_drvdata(dev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nu32 rtc_reg = 0;\r\nif (alm->time.tm_sec >= 0)\r\nrtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_sec))\r\n<< RTC_SECONDS_OFFS;\r\nif (alm->time.tm_min >= 0)\r\nrtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_min))\r\n<< RTC_MINUTES_OFFS;\r\nif (alm->time.tm_hour >= 0)\r\nrtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_hour))\r\n<< RTC_HOURS_OFFS;\r\nwritel(rtc_reg, ioaddr + RTC_ALARM_TIME_REG_OFFS);\r\nif (alm->time.tm_mday >= 0)\r\nrtc_reg = (RTC_ALARM_VALID | bin2bcd(alm->time.tm_mday))\r\n<< RTC_MDAY_OFFS;\r\nelse\r\nrtc_reg = 0;\r\nif (alm->time.tm_mon >= 0)\r\nrtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_mon + 1))\r\n<< RTC_MONTH_OFFS;\r\nif (alm->time.tm_year >= 0)\r\nrtc_reg |= (RTC_ALARM_VALID | bin2bcd(alm->time.tm_year % 100))\r\n<< RTC_YEAR_OFFS;\r\nwritel(rtc_reg, ioaddr + RTC_ALARM_DATE_REG_OFFS);\r\nwritel(0, ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS);\r\nwritel(alm->enabled ? 1 : 0,\r\nioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\r\nreturn 0;\r\n}\r\nstatic int mv_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nif (pdata->irq < 0)\r\nreturn -EINVAL;\r\nif (enabled)\r\nwritel(1, ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\r\nelse\r\nwritel(0, ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mv_rtc_interrupt(int irq, void *data)\r\n{\r\nstruct rtc_plat_data *pdata = data;\r\nvoid __iomem *ioaddr = pdata->ioaddr;\r\nif (!readl(ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS))\r\nreturn IRQ_NONE;\r\nwritel(0, ioaddr + RTC_ALARM_INTERRUPT_CASUE_REG_OFFS);\r\nrtc_update_irq(pdata->rtc, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init mv_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct rtc_plat_data *pdata;\r\nu32 rtc_time;\r\nint ret = 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdata->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdata->ioaddr))\r\nreturn PTR_ERR(pdata->ioaddr);\r\npdata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(pdata->clk))\r\nclk_prepare_enable(pdata->clk);\r\nrtc_time = readl(pdata->ioaddr + RTC_TIME_REG_OFFS);\r\nif (rtc_time & RTC_HOURS_12H_MODE) {\r\ndev_err(&pdev->dev, "24 Hours mode not supported.\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (rtc_time == 0x01000000) {\r\nssleep(1);\r\nrtc_time = readl(pdata->ioaddr + RTC_TIME_REG_OFFS);\r\nif (rtc_time == 0x01000000) {\r\ndev_err(&pdev->dev, "internal RTC not ticking\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\npdata->irq = platform_get_irq(pdev, 0);\r\nplatform_set_drvdata(pdev, pdata);\r\nif (pdata->irq >= 0) {\r\ndevice_init_wakeup(&pdev->dev, 1);\r\npdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&mv_rtc_alarm_ops,\r\nTHIS_MODULE);\r\n} else {\r\npdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&mv_rtc_ops, THIS_MODULE);\r\n}\r\nif (IS_ERR(pdata->rtc)) {\r\nret = PTR_ERR(pdata->rtc);\r\ngoto out;\r\n}\r\nif (pdata->irq >= 0) {\r\nwritel(0, pdata->ioaddr + RTC_ALARM_INTERRUPT_MASK_REG_OFFS);\r\nif (devm_request_irq(&pdev->dev, pdata->irq, mv_rtc_interrupt,\r\nIRQF_SHARED,\r\npdev->name, pdata) < 0) {\r\ndev_warn(&pdev->dev, "interrupt not available.\n");\r\npdata->irq = -1;\r\n}\r\n}\r\nreturn 0;\r\nout:\r\nif (!IS_ERR(pdata->clk))\r\nclk_disable_unprepare(pdata->clk);\r\nreturn ret;\r\n}\r\nstatic int __exit mv_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_plat_data *pdata = platform_get_drvdata(pdev);\r\nif (pdata->irq >= 0)\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nif (!IS_ERR(pdata->clk))\r\nclk_disable_unprepare(pdata->clk);\r\nreturn 0;\r\n}
