static ssize_t dgap_driver_version_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", DG_PART);\r\n}\r\nstatic ssize_t dgap_driver_boards_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", dgap_NumBoards);\r\n}\r\nstatic ssize_t dgap_driver_maxboards_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", MAXBOARDS);\r\n}\r\nstatic ssize_t dgap_driver_pollcounter_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", dgap_poll_counter);\r\n}\r\nstatic ssize_t dgap_driver_state_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", dgap_driver_state_text[dgap_driver_state]);\r\n}\r\nstatic ssize_t dgap_driver_debug_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", dgap_debug);\r\n}\r\nstatic ssize_t dgap_driver_debug_store(struct device_driver *ddp, const char *buf, size_t count)\r\n{\r\nsscanf(buf, "0x%x\n", &dgap_debug);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_driver_rawreadok_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "0x%x\n", dgap_rawreadok);\r\n}\r\nstatic ssize_t dgap_driver_rawreadok_store(struct device_driver *ddp, const char *buf, size_t count)\r\n{\r\nsscanf(buf, "0x%x\n", &dgap_rawreadok);\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_driver_pollrate_show(struct device_driver *ddp, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%dms\n", dgap_poll_tick);\r\n}\r\nstatic ssize_t dgap_driver_pollrate_store(struct device_driver *ddp, const char *buf, size_t count)\r\n{\r\nsscanf(buf, "%d\n", &dgap_poll_tick);\r\nreturn count;\r\n}\r\nvoid dgap_create_driver_sysfiles(struct pci_driver *dgap_driver)\r\n{\r\nint rc = 0;\r\nstruct device_driver *driverfs = &dgap_driver->driver;\r\nrc |= driver_create_file(driverfs, &driver_attr_version);\r\nrc |= driver_create_file(driverfs, &driver_attr_boards);\r\nrc |= driver_create_file(driverfs, &driver_attr_maxboards);\r\nrc |= driver_create_file(driverfs, &driver_attr_debug);\r\nrc |= driver_create_file(driverfs, &driver_attr_rawreadok);\r\nrc |= driver_create_file(driverfs, &driver_attr_pollrate);\r\nrc |= driver_create_file(driverfs, &driver_attr_pollcounter);\r\nrc |= driver_create_file(driverfs, &driver_attr_state);\r\nif (rc) {\r\nprintk(KERN_ERR "DGAP: sysfs driver_create_file failed!\n");\r\n}\r\n}\r\nvoid dgap_remove_driver_sysfiles(struct pci_driver *dgap_driver)\r\n{\r\nstruct device_driver *driverfs = &dgap_driver->driver;\r\ndriver_remove_file(driverfs, &driver_attr_version);\r\ndriver_remove_file(driverfs, &driver_attr_boards);\r\ndriver_remove_file(driverfs, &driver_attr_maxboards);\r\ndriver_remove_file(driverfs, &driver_attr_debug);\r\ndriver_remove_file(driverfs, &driver_attr_rawreadok);\r\ndriver_remove_file(driverfs, &driver_attr_pollrate);\r\ndriver_remove_file(driverfs, &driver_attr_pollcounter);\r\ndriver_remove_file(driverfs, &driver_attr_state);\r\n}\r\nstatic ssize_t dgap_ports_baud_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d %d\n", bd->channels[i]->ch_portnum, bd->channels[i]->ch_baud_info);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_msignals_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\nif (bd->channels[i]->ch_open_count) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d %s %s %s %s %s %s\n", bd->channels[i]->ch_portnum,\r\n(bd->channels[i]->ch_mostat & UART_MCR_RTS) ? "RTS" : "",\r\n(bd->channels[i]->ch_mistat & UART_MSR_CTS) ? "CTS" : "",\r\n(bd->channels[i]->ch_mostat & UART_MCR_DTR) ? "DTR" : "",\r\n(bd->channels[i]->ch_mistat & UART_MSR_DSR) ? "DSR" : "",\r\n(bd->channels[i]->ch_mistat & UART_MSR_DCD) ? "DCD" : "",\r\n(bd->channels[i]->ch_mistat & UART_MSR_RI) ? "RI" : "");\r\n} else {\r\ncount += snprintf(buf + count, PAGE_SIZE - count,\r\n"%d\n", bd->channels[i]->ch_portnum);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_iflag_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_c_iflag);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_cflag_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_c_cflag);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_oflag_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_c_oflag);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_lflag_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_c_lflag);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_digi_flag_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %x\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_digi.digi_flags);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_rxcount_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %ld\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_rxcount);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t dgap_ports_txcount_show(struct device *p, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nint count = 0;\r\nint i = 0;\r\nDGAP_VERIFY_BOARD(p, bd);\r\nfor (i = 0; i < bd->nasync; i++) {\r\ncount += snprintf(buf + count, PAGE_SIZE - count, "%d %ld\n",\r\nbd->channels[i]->ch_portnum, bd->channels[i]->ch_txcount);\r\n}\r\nreturn count;\r\n}\r\nvoid dgap_create_ports_sysfiles(struct board_t *bd)\r\n{\r\nint rc = 0;\r\ndev_set_drvdata(&bd->pdev->dev, bd);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_state);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_baud);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_msignals);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_iflag);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_cflag);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_oflag);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_lflag);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_digi_flag);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_rxcount);\r\nrc |= device_create_file(&(bd->pdev->dev), &dev_attr_ports_txcount);\r\nif (rc) {\r\nprintk(KERN_ERR "DGAP: sysfs device_create_file failed!\n");\r\n}\r\n}\r\nvoid dgap_remove_ports_sysfiles(struct board_t *bd)\r\n{\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_state);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_baud);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_msignals);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_iflag);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_cflag);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_oflag);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_lflag);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_digi_flag);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_rxcount);\r\ndevice_remove_file(&(bd->pdev->dev), &dev_attr_ports_txcount);\r\n}\r\nstatic ssize_t dgap_tty_state_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%s", un->un_open_count ? "Open" : "Closed");\r\n}\r\nstatic ssize_t dgap_tty_baud_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ch->ch_baud_info);\r\n}\r\nstatic ssize_t dgap_tty_msignals_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nif (ch->ch_open_count) {\r\nreturn snprintf(buf, PAGE_SIZE, "%s %s %s %s %s %s\n",\r\n(ch->ch_mostat & UART_MCR_RTS) ? "RTS" : "",\r\n(ch->ch_mistat & UART_MSR_CTS) ? "CTS" : "",\r\n(ch->ch_mostat & UART_MCR_DTR) ? "DTR" : "",\r\n(ch->ch_mistat & UART_MSR_DSR) ? "DSR" : "",\r\n(ch->ch_mistat & UART_MSR_DCD) ? "DCD" : "",\r\n(ch->ch_mistat & UART_MSR_RI) ? "RI" : "");\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t dgap_tty_iflag_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_iflag);\r\n}\r\nstatic ssize_t dgap_tty_cflag_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_cflag);\r\n}\r\nstatic ssize_t dgap_tty_oflag_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_oflag);\r\n}\r\nstatic ssize_t dgap_tty_lflag_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_c_lflag);\r\n}\r\nstatic ssize_t dgap_tty_digi_flag_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ch->ch_digi.digi_flags);\r\n}\r\nstatic ssize_t dgap_tty_rxcount_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", ch->ch_rxcount);\r\n}\r\nstatic ssize_t dgap_tty_txcount_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", ch->ch_txcount);\r\n}\r\nstatic ssize_t dgap_tty_name_show(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct board_t *bd;\r\nstruct channel_t *ch;\r\nstruct un_t *un;\r\nint cn;\r\nint bn;\r\nstruct cnode *cptr = NULL;\r\nint found = FALSE;\r\nint ncount = 0;\r\nint starto = 0;\r\nint i = 0;\r\nif (!d)\r\nreturn (0);\r\nun = dev_get_drvdata(d);\r\nif (!un || un->magic != DGAP_UNIT_MAGIC)\r\nreturn (0);\r\nch = un->un_ch;\r\nif (!ch || ch->magic != DGAP_CHANNEL_MAGIC)\r\nreturn (0);\r\nbd = ch->ch_bd;\r\nif (!bd || bd->magic != DGAP_BOARD_MAGIC)\r\nreturn (0);\r\nif (bd->state != BOARD_READY)\r\nreturn (0);\r\nbn = bd->boardnum;\r\ncn = ch->ch_portnum;\r\nfor (cptr = bd->bd_config; cptr; cptr = cptr->next) {\r\nif ((cptr->type == BNODE) &&\r\n((cptr->u.board.type == APORT2_920P) || (cptr->u.board.type == APORT4_920P) ||\r\n(cptr->u.board.type == APORT8_920P) || (cptr->u.board.type == PAPORT4) ||\r\n(cptr->u.board.type == PAPORT8))) {\r\nfound = TRUE;\r\nif (cptr->u.board.v_start)\r\nstarto = cptr->u.board.start;\r\nelse\r\nstarto = 1;\r\n}\r\nif (cptr->type == TNODE && found == TRUE) {\r\nchar *ptr1;\r\nif (strstr(cptr->u.ttyname, "tty")) {\r\nptr1 = cptr->u.ttyname;\r\nptr1 += 3;\r\n}\r\nelse {\r\nptr1 = cptr->u.ttyname;\r\n}\r\nfor (i = 0; i < dgap_config_get_number_of_ports(bd); i++) {\r\nif (cn == i) {\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02d\n",\r\n(un->un_type == DGAP_PRINT) ? "pr" : "tty",\r\nptr1, i + starto);\r\n}\r\n}\r\n}\r\nif (cptr->type == CNODE) {\r\nfor (i = 0; i < cptr->u.conc.nport; i++) {\r\nif (cn == (i + ncount)) {\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02d\n",\r\n(un->un_type == DGAP_PRINT) ? "pr" : "tty",\r\ncptr->u.conc.id,\r\ni + (cptr->u.conc.v_start ? cptr->u.conc.start : 1));\r\n}\r\n}\r\nncount += cptr->u.conc.nport;\r\n}\r\nif (cptr->type == MNODE) {\r\nfor (i = 0; i < cptr->u.module.nport; i++) {\r\nif (cn == (i + ncount)) {\r\nreturn snprintf(buf, PAGE_SIZE, "%s%s%02d\n",\r\n(un->un_type == DGAP_PRINT) ? "pr" : "tty",\r\ncptr->u.module.id,\r\ni + (cptr->u.module.v_start ? cptr->u.module.start : 1));\r\n}\r\n}\r\nncount += cptr->u.module.nport;\r\n}\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s_dgap_%d_%d\n",\r\n(un->un_type == DGAP_PRINT) ? "pr" : "tty", bn, cn);\r\n}\r\nvoid dgap_create_tty_sysfs(struct un_t *un, struct device *c)\r\n{\r\nint ret;\r\nret = sysfs_create_group(&c->kobj, &dgap_tty_attribute_group);\r\nif (ret) {\r\nprintk(KERN_ERR "dgap: failed to create sysfs tty device attributes.\n");\r\nsysfs_remove_group(&c->kobj, &dgap_tty_attribute_group);\r\nreturn;\r\n}\r\ndev_set_drvdata(c, un);\r\n}\r\nvoid dgap_remove_tty_sysfs(struct device *c)\r\n{\r\nsysfs_remove_group(&c->kobj, &dgap_tty_attribute_group);\r\n}
