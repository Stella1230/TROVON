static int rtl2832_wr(struct rtl2832_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (1 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2832_rd(struct rtl2832_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg.i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2832_wr_regs(struct rtl2832_priv *priv, u8 reg, u8 page, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nif (page != priv->page) {\r\nret = rtl2832_wr(priv, 0x00, &page, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->page = page;\r\n}\r\nreturn rtl2832_wr(priv, reg, val, len);\r\n}\r\nstatic int rtl2832_rd_regs(struct rtl2832_priv *priv, u8 reg, u8 page, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nif (page != priv->page) {\r\nret = rtl2832_wr(priv, 0x00, &page, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->page = page;\r\n}\r\nreturn rtl2832_rd(priv, reg, val, len);\r\n}\r\nstatic int rtl2832_rd_reg(struct rtl2832_priv *priv, u8 reg, u8 page, u8 *val)\r\n{\r\nreturn rtl2832_rd_regs(priv, reg, page, val, 1);\r\n}\r\nstatic int rtl2832_rd_demod_reg(struct rtl2832_priv *priv, int reg, u32 *val)\r\n{\r\nint ret;\r\nu8 reg_start_addr;\r\nu8 msb, lsb;\r\nu8 page;\r\nu8 reading[4];\r\nu32 reading_tmp;\r\nint i;\r\nu8 len;\r\nu32 mask;\r\nreg_start_addr = registers[reg].start_address;\r\nmsb = registers[reg].msb;\r\nlsb = registers[reg].lsb;\r\npage = registers[reg].page;\r\nlen = (msb >> 3) + 1;\r\nmask = REG_MASK(msb - lsb);\r\nret = rtl2832_rd_regs(priv, reg_start_addr, page, &reading[0], len);\r\nif (ret)\r\ngoto err;\r\nreading_tmp = 0;\r\nfor (i = 0; i < len; i++)\r\nreading_tmp |= reading[i] << ((len - 1 - i) * 8);\r\n*val = (reading_tmp >> lsb) & mask;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_wr_demod_reg(struct rtl2832_priv *priv, int reg, u32 val)\r\n{\r\nint ret, i;\r\nu8 len;\r\nu8 reg_start_addr;\r\nu8 msb, lsb;\r\nu8 page;\r\nu32 mask;\r\nu8 reading[4];\r\nu8 writing[4];\r\nu32 reading_tmp;\r\nu32 writing_tmp;\r\nreg_start_addr = registers[reg].start_address;\r\nmsb = registers[reg].msb;\r\nlsb = registers[reg].lsb;\r\npage = registers[reg].page;\r\nlen = (msb >> 3) + 1;\r\nmask = REG_MASK(msb - lsb);\r\nret = rtl2832_rd_regs(priv, reg_start_addr, page, &reading[0], len);\r\nif (ret)\r\ngoto err;\r\nreading_tmp = 0;\r\nfor (i = 0; i < len; i++)\r\nreading_tmp |= reading[i] << ((len - 1 - i) * 8);\r\nwriting_tmp = reading_tmp & ~(mask << lsb);\r\nwriting_tmp |= ((val & mask) << lsb);\r\nfor (i = 0; i < len; i++)\r\nwriting[i] = (writing_tmp >> ((len - 1 - i) * 8)) & 0xff;\r\nret = rtl2832_wr_regs(priv, reg_start_addr, page, &writing[0], len);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nint ret;\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s: enable=%d\n", __func__, enable);\r\nif (priv->i2c_gate_state == enable)\r\nreturn 0;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_IIC_REPEAT, (enable ? 0x1 : 0x0));\r\nif (ret)\r\ngoto err;\r\npriv->i2c_gate_state = enable;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_set_if(struct dvb_frontend *fe, u32 if_freq)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu64 pset_iffreq;\r\nu8 en_bbin = (if_freq == 0 ? 0x1 : 0x0);\r\npset_iffreq = if_freq % priv->cfg.xtal;\r\npset_iffreq *= 0x400000;\r\npset_iffreq = div_u64(pset_iffreq, priv->cfg.xtal);\r\npset_iffreq = -pset_iffreq;\r\npset_iffreq = pset_iffreq & 0x3fffff;\r\ndev_dbg(&priv->i2c->dev, "%s: if_frequency=%d pset_iffreq=%08x\n",\r\n__func__, if_freq, (unsigned)pset_iffreq);\r\nret = rtl2832_wr_demod_reg(priv, DVBT_EN_BBIN, en_bbin);\r\nif (ret)\r\nreturn ret;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_PSET_IFFREQ, pset_iffreq);\r\nreturn (ret);\r\n}\r\nstatic int rtl2832_init(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nconst struct rtl2832_reg_value *init;\r\nint i, ret, len;\r\nstruct rtl2832_reg_value rtl2832_initial_regs[] = {\r\n{DVBT_AD_EN_REG, 0x1},\r\n{DVBT_AD_EN_REG1, 0x1},\r\n{DVBT_RSD_BER_FAIL_VAL, 0x2800},\r\n{DVBT_MGD_THD0, 0x10},\r\n{DVBT_MGD_THD1, 0x20},\r\n{DVBT_MGD_THD2, 0x20},\r\n{DVBT_MGD_THD3, 0x40},\r\n{DVBT_MGD_THD4, 0x22},\r\n{DVBT_MGD_THD5, 0x32},\r\n{DVBT_MGD_THD6, 0x37},\r\n{DVBT_MGD_THD7, 0x39},\r\n{DVBT_EN_BK_TRK, 0x0},\r\n{DVBT_EN_CACQ_NOTCH, 0x0},\r\n{DVBT_AD_AV_REF, 0x2a},\r\n{DVBT_REG_PI, 0x6},\r\n{DVBT_PIP_ON, 0x0},\r\n{DVBT_CDIV_PH0, 0x8},\r\n{DVBT_CDIV_PH1, 0x8},\r\n{DVBT_SCALE1_B92, 0x4},\r\n{DVBT_SCALE1_B93, 0xb0},\r\n{DVBT_SCALE1_BA7, 0x78},\r\n{DVBT_SCALE1_BA9, 0x28},\r\n{DVBT_SCALE1_BAA, 0x59},\r\n{DVBT_SCALE1_BAB, 0x83},\r\n{DVBT_SCALE1_BAC, 0xd4},\r\n{DVBT_SCALE1_BB0, 0x65},\r\n{DVBT_SCALE1_BB1, 0x43},\r\n{DVBT_KB_P1, 0x1},\r\n{DVBT_KB_P2, 0x4},\r\n{DVBT_KB_P3, 0x7},\r\n{DVBT_K1_CR_STEP12, 0xa},\r\n{DVBT_REG_GPE, 0x1},\r\n{DVBT_SERIAL, 0x0},\r\n{DVBT_CDIV_PH0, 0x9},\r\n{DVBT_CDIV_PH1, 0x9},\r\n{DVBT_MPEG_IO_OPT_2_2, 0x0},\r\n{DVBT_MPEG_IO_OPT_1_0, 0x0},\r\n{DVBT_TRK_KS_P2, 0x4},\r\n{DVBT_TRK_KS_I2, 0x7},\r\n{DVBT_TR_THD_SET2, 0x6},\r\n{DVBT_TRK_KC_I2, 0x5},\r\n{DVBT_CR_THD_SET2, 0x1},\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(rtl2832_initial_regs); i++) {\r\nret = rtl2832_wr_demod_reg(priv, rtl2832_initial_regs[i].reg,\r\nrtl2832_initial_regs[i].value);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: load settings for tuner=%02x\n",\r\n__func__, priv->cfg.tuner);\r\nswitch (priv->cfg.tuner) {\r\ncase RTL2832_TUNER_FC0012:\r\ncase RTL2832_TUNER_FC0013:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_fc0012);\r\ninit = rtl2832_tuner_init_fc0012;\r\nbreak;\r\ncase RTL2832_TUNER_TUA9001:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_tua9001);\r\ninit = rtl2832_tuner_init_tua9001;\r\nbreak;\r\ncase RTL2832_TUNER_E4000:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_e4000);\r\ninit = rtl2832_tuner_init_e4000;\r\nbreak;\r\ncase RTL2832_TUNER_R820T:\r\ncase RTL2832_TUNER_R828D:\r\nlen = ARRAY_SIZE(rtl2832_tuner_init_r820t);\r\ninit = rtl2832_tuner_init_r820t;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nret = rtl2832_wr_demod_reg(priv, init[i].reg, init[i].value);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (!fe->ops.tuner_ops.get_if_frequency) {\r\nret = rtl2832_set_if(fe, priv->cfg.if_dvbt);\r\nif (ret)\r\ngoto err;\r\n}\r\n#if 1\r\nret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x0);\r\nif (ret)\r\ngoto err;\r\n#endif\r\npriv->sleeping = false;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\npriv->sleeping = true;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\ns->min_delay_ms = 1000;\r\ns->step_size = fe->ops.info.frequency_stepsize * 2;\r\ns->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, j;\r\nu64 bw_mode, num, num2;\r\nu32 resamp_ratio, cfreq_off_ratio;\r\nstatic u8 bw_params[3][32] = {\r\n{\r\n0xf5, 0xff, 0x15, 0x38, 0x5d, 0x6d, 0x52, 0x07, 0xfa, 0x2f,\r\n0x53, 0xf5, 0x3f, 0xca, 0x0b, 0x91, 0xea, 0x30, 0x63, 0xb2,\r\n0x13, 0xda, 0x0b, 0xc4, 0x18, 0x7e, 0x16, 0x66, 0x08, 0x67,\r\n0x19, 0xe0,\r\n},\r\n{\r\n0xe7, 0xcc, 0xb5, 0xba, 0xe8, 0x2f, 0x67, 0x61, 0x00, 0xaf,\r\n0x86, 0xf2, 0xbf, 0x59, 0x04, 0x11, 0xb6, 0x33, 0xa4, 0x30,\r\n0x15, 0x10, 0x0a, 0x42, 0x18, 0xf8, 0x17, 0xd9, 0x07, 0x22,\r\n0x19, 0x10,\r\n},\r\n{\r\n0x09, 0xf6, 0xd2, 0xa7, 0x9a, 0xc9, 0x27, 0x77, 0x06, 0xbf,\r\n0xec, 0xf4, 0x4f, 0x0b, 0xfc, 0x01, 0x63, 0x35, 0x54, 0xa7,\r\n0x16, 0x66, 0x08, 0xb4, 0x19, 0x6e, 0x19, 0x65, 0x05, 0xc8,\r\n0x19, 0xe0,\r\n},\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s: frequency=%d bandwidth_hz=%d " \\r\n"inversion=%d\n", __func__, c->frequency,\r\nc->bandwidth_hz, c->inversion);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nu32 if_freq;\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_set_if(fe, if_freq);\r\nif (ret)\r\ngoto err;\r\n}\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\ni = 0;\r\nbw_mode = 48000000;\r\nbreak;\r\ncase 7000000:\r\ni = 1;\r\nbw_mode = 56000000;\r\nbreak;\r\ncase 8000000:\r\ni = 2;\r\nbw_mode = 64000000;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid bandwidth\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfor (j = 0; j < sizeof(bw_params[0]); j++) {\r\nret = rtl2832_wr_regs(priv, 0x1c+j, 1, &bw_params[i][j], 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nnum = priv->cfg.xtal * 7;\r\nnum *= 0x400000;\r\nnum = div_u64(num, bw_mode);\r\nresamp_ratio = num & 0x3ffffff;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_RSAMP_RATIO, resamp_ratio);\r\nif (ret)\r\ngoto err;\r\nnum = bw_mode << 20;\r\nnum2 = priv->cfg.xtal * 7;\r\nnum = div_u64(num, num2);\r\nnum = -num;\r\ncfreq_off_ratio = num & 0xfffff;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_CFREQ_OFF_RATIO, cfreq_off_ratio);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_wr_demod_reg(priv, DVBT_SOFT_RST, 0x0);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 buf[3];\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2832_rd_regs(priv, 0x3c, 3, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_rd_reg(priv, 0x51, 3, &buf[2]);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: TPS=%*ph\n", __func__, 3, buf);\r\nswitch ((buf[0] >> 2) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 2) & 1) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\n}\r\nswitch ((buf[2] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 4) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 3) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu32 tmp;\r\n*status = 0;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (priv->sleeping)\r\nreturn 0;\r\nret = rtl2832_rd_demod_reg(priv, DVBT_FSM_STAGE, &tmp);\r\nif (ret)\r\ngoto err;\r\nif (tmp == 11) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nint ret, hierarchy, constellation;\r\nu8 buf[2], tmp;\r\nu16 tmp16;\r\n#define CONSTELLATION_NUM 3\r\n#define HIERARCHY_NUM 4\r\nstatic const u32 snr_constant[CONSTELLATION_NUM][HIERARCHY_NUM] = {\r\n{ 85387325, 85387325, 85387325, 85387325 },\r\n{ 86676178, 86676178, 87167949, 87795660 },\r\n{ 87659938, 87659938, 87885178, 88241743 },\r\n};\r\nret = rtl2832_rd_reg(priv, 0x3c, 3, &tmp);\r\nif (ret)\r\ngoto err;\r\nconstellation = (tmp >> 2) & 0x03;\r\nif (constellation > CONSTELLATION_NUM - 1)\r\ngoto err;\r\nhierarchy = (tmp >> 4) & 0x07;\r\nif (hierarchy > HIERARCHY_NUM - 1)\r\ngoto err;\r\nret = rtl2832_rd_regs(priv, 0x0c, 4, buf, 2);\r\nif (ret)\r\ngoto err;\r\ntmp16 = buf[0] << 8 | buf[1];\r\nif (tmp16)\r\n*snr = (snr_constant[constellation][hierarchy] -\r\nintlog10(tmp16)) / ((1 << 24) / 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nret = rtl2832_rd_regs(priv, 0x4e, 3, buf, 2);\r\nif (ret)\r\ngoto err;\r\n*ber = buf[0] << 8 | buf[1];\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void rtl2832_release(struct dvb_frontend *fe)\r\n{\r\nstruct rtl2832_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nkfree(priv);\r\n}\r\nstruct dvb_frontend *rtl2832_attach(const struct rtl2832_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct rtl2832_priv *priv = NULL;\r\nint ret = 0;\r\nu8 tmp;\r\ndev_dbg(&i2c->dev, "%s:\n", __func__);\r\npriv = kzalloc(sizeof(struct rtl2832_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto err;\r\npriv->i2c = i2c;\r\npriv->tuner = cfg->tuner;\r\nmemcpy(&priv->cfg, cfg, sizeof(struct rtl2832_config));\r\nret = rtl2832_rd_reg(priv, 0x00, 0x0, &tmp);\r\nif (ret)\r\ngoto err;\r\nmemcpy(&priv->fe.ops, &rtl2832_ops, sizeof(struct dvb_frontend_ops));\r\npriv->fe.demodulator_priv = priv;\r\npriv->sleeping = true;\r\nreturn &priv->fe;\r\nerr:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
