static handle_t *ext4_get_nojournal(void)\r\n{\r\nhandle_t *handle = current->journal_info;\r\nunsigned long ref_cnt = (unsigned long)handle;\r\nBUG_ON(ref_cnt >= EXT4_NOJOURNAL_MAX_REF_COUNT);\r\nref_cnt++;\r\nhandle = (handle_t *)ref_cnt;\r\ncurrent->journal_info = handle;\r\nreturn handle;\r\n}\r\nstatic void ext4_put_nojournal(handle_t *handle)\r\n{\r\nunsigned long ref_cnt = (unsigned long)handle;\r\nBUG_ON(ref_cnt == 0);\r\nref_cnt--;\r\nhandle = (handle_t *)ref_cnt;\r\ncurrent->journal_info = handle;\r\n}\r\nstatic int ext4_journal_check_start(struct super_block *sb)\r\n{\r\njournal_t *journal;\r\nmight_sleep();\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn -EROFS;\r\nWARN_ON(sb->s_writers.frozen == SB_FREEZE_COMPLETE);\r\njournal = EXT4_SB(sb)->s_journal;\r\nif (journal && is_journal_aborted(journal)) {\r\next4_abort(sb, "Detected aborted journal");\r\nreturn -EROFS;\r\n}\r\nreturn 0;\r\n}\r\nhandle_t *__ext4_journal_start_sb(struct super_block *sb, unsigned int line,\r\nint type, int blocks, int rsv_blocks)\r\n{\r\njournal_t *journal;\r\nint err;\r\ntrace_ext4_journal_start(sb, blocks, rsv_blocks, _RET_IP_);\r\nerr = ext4_journal_check_start(sb);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\njournal = EXT4_SB(sb)->s_journal;\r\nif (!journal)\r\nreturn ext4_get_nojournal();\r\nreturn jbd2__journal_start(journal, blocks, rsv_blocks, GFP_NOFS,\r\ntype, line);\r\n}\r\nint __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\r\n{\r\nstruct super_block *sb;\r\nint err;\r\nint rc;\r\nif (!ext4_handle_valid(handle)) {\r\next4_put_nojournal(handle);\r\nreturn 0;\r\n}\r\nsb = handle->h_transaction->t_journal->j_private;\r\nerr = handle->h_err;\r\nrc = jbd2_journal_stop(handle);\r\nif (!err)\r\nerr = rc;\r\nif (err)\r\n__ext4_std_error(sb, where, line, err);\r\nreturn err;\r\n}\r\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\r\nint type)\r\n{\r\nstruct super_block *sb;\r\nint err;\r\nif (!ext4_handle_valid(handle))\r\nreturn ext4_get_nojournal();\r\nsb = handle->h_journal->j_private;\r\ntrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\r\n_RET_IP_);\r\nerr = ext4_journal_check_start(sb);\r\nif (err < 0) {\r\njbd2_journal_free_reserved(handle);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = jbd2_journal_start_reserved(handle, type, line);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn handle;\r\n}\r\nvoid ext4_journal_abort_handle(const char *caller, unsigned int line,\r\nconst char *err_fn, struct buffer_head *bh,\r\nhandle_t *handle, int err)\r\n{\r\nchar nbuf[16];\r\nconst char *errstr = ext4_decode_error(NULL, err, nbuf);\r\nBUG_ON(!ext4_handle_valid(handle));\r\nif (bh)\r\nBUFFER_TRACE(bh, "abort");\r\nif (!handle->h_err)\r\nhandle->h_err = err;\r\nif (is_handle_aborted(handle))\r\nreturn;\r\nprintk(KERN_ERR "EXT4-fs: %s:%d: aborting transaction: %s in %s\n",\r\ncaller, line, errstr, err_fn);\r\njbd2_journal_abort_handle(handle);\r\n}\r\nint __ext4_journal_get_write_access(const char *where, unsigned int line,\r\nhandle_t *handle, struct buffer_head *bh)\r\n{\r\nint err = 0;\r\nmight_sleep();\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_get_write_access(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__, bh,\r\nhandle, err);\r\n}\r\nreturn err;\r\n}\r\nint __ext4_forget(const char *where, unsigned int line, handle_t *handle,\r\nint is_metadata, struct inode *inode,\r\nstruct buffer_head *bh, ext4_fsblk_t blocknr)\r\n{\r\nint err;\r\nmight_sleep();\r\ntrace_ext4_forget(inode, is_metadata, blocknr);\r\nBUFFER_TRACE(bh, "enter");\r\njbd_debug(4, "forgetting bh %p: is_metadata = %d, mode %o, "\r\n"data mode %x\n",\r\nbh, is_metadata, inode->i_mode,\r\ntest_opt(inode->i_sb, DATA_FLAGS));\r\nif (!ext4_handle_valid(handle)) {\r\nbforget(bh);\r\nreturn 0;\r\n}\r\nif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA ||\r\n(!is_metadata && !ext4_should_journal_data(inode))) {\r\nif (bh) {\r\nBUFFER_TRACE(bh, "call jbd2_journal_forget");\r\nerr = jbd2_journal_forget(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nBUFFER_TRACE(bh, "call jbd2_journal_revoke");\r\nerr = jbd2_journal_revoke(handle, blocknr, bh);\r\nif (err) {\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n__ext4_abort(inode->i_sb, where, line,\r\n"error %d when attempting revoke", err);\r\n}\r\nBUFFER_TRACE(bh, "exit");\r\nreturn err;\r\n}\r\nint __ext4_journal_get_create_access(const char *where, unsigned int line,\r\nhandle_t *handle, struct buffer_head *bh)\r\n{\r\nint err = 0;\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_get_create_access(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n}\r\nreturn err;\r\n}\r\nint __ext4_handle_dirty_metadata(const char *where, unsigned int line,\r\nhandle_t *handle, struct inode *inode,\r\nstruct buffer_head *bh)\r\n{\r\nint err = 0;\r\nmight_sleep();\r\nset_buffer_meta(bh);\r\nset_buffer_prio(bh);\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_dirty_metadata(handle, bh);\r\nif (WARN_ON_ONCE(err)) {\r\next4_journal_abort_handle(where, line, __func__, bh,\r\nhandle, err);\r\next4_error_inode(inode, where, line,\r\nbh->b_blocknr,\r\n"journal_dirty_metadata failed: "\r\n"handle type %u started at line %u, "\r\n"credits %u/%u, errcode %d",\r\nhandle->h_type,\r\nhandle->h_line_no,\r\nhandle->h_requested_credits,\r\nhandle->h_buffer_credits, err);\r\n}\r\n} else {\r\nif (inode)\r\nmark_buffer_dirty_inode(bh, inode);\r\nelse\r\nmark_buffer_dirty(bh);\r\nif (inode && inode_needs_sync(inode)) {\r\nsync_dirty_buffer(bh);\r\nif (buffer_req(bh) && !buffer_uptodate(bh)) {\r\nstruct ext4_super_block *es;\r\nes = EXT4_SB(inode->i_sb)->s_es;\r\nes->s_last_error_block =\r\ncpu_to_le64(bh->b_blocknr);\r\next4_error_inode(inode, where, line,\r\nbh->b_blocknr,\r\n"IO error syncing itable block");\r\nerr = -EIO;\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nint __ext4_handle_dirty_super(const char *where, unsigned int line,\r\nhandle_t *handle, struct super_block *sb)\r\n{\r\nstruct buffer_head *bh = EXT4_SB(sb)->s_sbh;\r\nint err = 0;\r\next4_superblock_csum_set(sb);\r\nif (ext4_handle_valid(handle)) {\r\nerr = jbd2_journal_dirty_metadata(handle, bh);\r\nif (err)\r\next4_journal_abort_handle(where, line, __func__,\r\nbh, handle, err);\r\n} else\r\nmark_buffer_dirty(bh);\r\nreturn err;\r\n}
