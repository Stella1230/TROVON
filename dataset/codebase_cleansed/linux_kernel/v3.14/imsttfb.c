static inline u32 read_reg_le32(volatile u32 __iomem *base, int regindex)\r\n{\r\n#ifdef __powerpc__\r\nreturn in_le32(base + regindex);\r\n#else\r\nreturn readl(base + regindex);\r\n#endif\r\n}\r\nstatic inline void write_reg_le32(volatile u32 __iomem *base, int regindex, u32 val)\r\n{\r\n#ifdef __powerpc__\r\nout_le32(base + regindex, val);\r\n#else\r\nwritel(val, base + regindex);\r\n#endif\r\n}\r\nstatic __u32\r\ngetclkMHz(struct imstt_par *par)\r\n{\r\n__u32 clk_m, clk_n, clk_p;\r\nclk_m = par->init.pclk_m;\r\nclk_n = par->init.pclk_n;\r\nclk_p = par->init.pclk_p;\r\nreturn 20 * (clk_m + 1) / ((clk_n + 1) * (clk_p ? 2 * clk_p : 1));\r\n}\r\nstatic void\r\nsetclkMHz(struct imstt_par *par, __u32 MHz)\r\n{\r\n__u32 clk_m, clk_n, x, stage, spilled;\r\nclk_m = clk_n = 0;\r\nstage = spilled = 0;\r\nfor (;;) {\r\nswitch (stage) {\r\ncase 0:\r\nclk_m++;\r\nbreak;\r\ncase 1:\r\nclk_n++;\r\nbreak;\r\n}\r\nx = 20 * (clk_m + 1) / (clk_n + 1);\r\nif (x == MHz)\r\nbreak;\r\nif (x > MHz) {\r\nspilled = 1;\r\nstage = 1;\r\n} else if (spilled && x < MHz) {\r\nstage = 0;\r\n}\r\n}\r\npar->init.pclk_m = clk_m;\r\npar->init.pclk_n = clk_n;\r\npar->init.pclk_p = 0;\r\n}\r\nstatic struct imstt_regvals *\r\ncompute_imstt_regvals_ibm(struct imstt_par *par, int xres, int yres)\r\n{\r\nstruct imstt_regvals *init = &par->init;\r\n__u32 MHz, hes, heb, veb, htp, vtp;\r\nswitch (xres) {\r\ncase 640:\r\nhes = 0x0008; heb = 0x0012; veb = 0x002a; htp = 10; vtp = 2;\r\nMHz = 30 ;\r\nbreak;\r\ncase 832:\r\nhes = 0x0005; heb = 0x0020; veb = 0x0028; htp = 8; vtp = 3;\r\nMHz = 57 ;\r\nbreak;\r\ncase 1024:\r\nhes = 0x000a; heb = 0x001c; veb = 0x0020; htp = 8; vtp = 3;\r\nMHz = 80;\r\nbreak;\r\ncase 1152:\r\nhes = 0x0012; heb = 0x0022; veb = 0x0031; htp = 4; vtp = 3;\r\nMHz = 101 ;\r\nbreak;\r\ncase 1280:\r\nhes = 0x0012; heb = 0x002f; veb = 0x0029; htp = 4; vtp = 1;\r\nMHz = yres == 960 ? 126 : 135;\r\nbreak;\r\ncase 1600:\r\nhes = 0x0018; heb = 0x0040; veb = 0x002a; htp = 4; vtp = 3;\r\nMHz = 200;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nsetclkMHz(par, MHz);\r\ninit->hes = hes;\r\ninit->heb = heb;\r\ninit->hsb = init->heb + (xres >> 3);\r\ninit->ht = init->hsb + htp;\r\ninit->ves = 0x0003;\r\ninit->veb = veb;\r\ninit->vsb = init->veb + yres;\r\ninit->vt = init->vsb + vtp;\r\ninit->vil = init->vsb;\r\ninit->pitch = xres;\r\nreturn init;\r\n}\r\nstatic struct imstt_regvals *\r\ncompute_imstt_regvals_tvp(struct imstt_par *par, int xres, int yres)\r\n{\r\nstruct imstt_regvals *init;\r\nswitch (xres) {\r\ncase 512:\r\ninit = &tvp_reg_init_2;\r\nbreak;\r\ncase 640:\r\ninit = &tvp_reg_init_6;\r\nbreak;\r\ncase 800:\r\ninit = &tvp_reg_init_12;\r\nbreak;\r\ncase 832:\r\ninit = &tvp_reg_init_13;\r\nbreak;\r\ncase 1024:\r\ninit = &tvp_reg_init_17;\r\nbreak;\r\ncase 1152:\r\ninit = &tvp_reg_init_18;\r\nbreak;\r\ncase 1280:\r\ninit = yres == 960 ? &tvp_reg_init_19 : &tvp_reg_init_20;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\npar->init = *init;\r\nreturn init;\r\n}\r\nstatic struct imstt_regvals *\r\ncompute_imstt_regvals (struct imstt_par *par, u_int xres, u_int yres)\r\n{\r\nif (par->ramdac == IBM)\r\nreturn compute_imstt_regvals_ibm(par, xres, yres);\r\nelse\r\nreturn compute_imstt_regvals_tvp(par, xres, yres);\r\n}\r\nstatic void\r\nset_imstt_regvals_ibm (struct imstt_par *par, u_int bpp)\r\n{\r\nstruct imstt_regvals *init = &par->init;\r\n__u8 pformat = (bpp >> 3) + 2;\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = PIXM0; eieio();\r\npar->cmap_regs[PIDXDATA] = init->pclk_m;eieio();\r\npar->cmap_regs[PIDXLO] = PIXN0; eieio();\r\npar->cmap_regs[PIDXDATA] = init->pclk_n;eieio();\r\npar->cmap_regs[PIDXLO] = PIXP0; eieio();\r\npar->cmap_regs[PIDXDATA] = init->pclk_p;eieio();\r\npar->cmap_regs[PIDXLO] = PIXC0; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x02; eieio();\r\npar->cmap_regs[PIDXLO] = PIXFMT; eieio();\r\npar->cmap_regs[PIDXDATA] = pformat; eieio();\r\n}\r\nstatic void\r\nset_imstt_regvals_tvp (struct imstt_par *par, u_int bpp)\r\n{\r\nstruct imstt_regvals *init = &par->init;\r\n__u8 tcc, mxc, lckl_n, mic;\r\n__u8 mlc, lckl_p;\r\nswitch (bpp) {\r\ndefault:\r\ncase 8:\r\ntcc = 0x80;\r\nmxc = 0x4d;\r\nlckl_n = 0xc1;\r\nmlc = init->mlc[0];\r\nlckl_p = init->lckl_p[0];\r\nbreak;\r\ncase 16:\r\ntcc = 0x44;\r\nmxc = 0x55;\r\nlckl_n = 0xe1;\r\nmlc = init->mlc[1];\r\nlckl_p = init->lckl_p[1];\r\nbreak;\r\ncase 24:\r\ntcc = 0x5e;\r\nmxc = 0x5d;\r\nlckl_n = 0xf1;\r\nmlc = init->mlc[2];\r\nlckl_p = init->lckl_p[2];\r\nbreak;\r\ncase 32:\r\ntcc = 0x46;\r\nmxc = 0x5d;\r\nlckl_n = 0xf1;\r\nmlc = init->mlc[2];\r\nlckl_p = init->lckl_p[2];\r\nbreak;\r\n}\r\nmic = 0x08;\r\npar->cmap_regs[TVPADDRW] = TVPIRPLA; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x00; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPPD; eieio();\r\npar->cmap_regs[TVPIDATA] = init->pclk_m; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPPD; eieio();\r\npar->cmap_regs[TVPIDATA] = init->pclk_n; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPPD; eieio();\r\npar->cmap_regs[TVPIDATA] = init->pclk_p; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRTCC; eieio();\r\npar->cmap_regs[TVPIDATA] = tcc; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRMXC; eieio();\r\npar->cmap_regs[TVPIDATA] = mxc; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRMIC; eieio();\r\npar->cmap_regs[TVPIDATA] = mic; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPLA; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x00; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRLPD; eieio();\r\npar->cmap_regs[TVPIDATA] = lckl_n; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPLA; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x15; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRMLC; eieio();\r\npar->cmap_regs[TVPIDATA] = mlc; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRPLA; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x2a; eieio();\r\npar->cmap_regs[TVPADDRW] = TVPIRLPD; eieio();\r\npar->cmap_regs[TVPIDATA] = lckl_p; eieio();\r\n}\r\nstatic void\r\nset_imstt_regvals (struct fb_info *info, u_int bpp)\r\n{\r\nstruct imstt_par *par = info->par;\r\nstruct imstt_regvals *init = &par->init;\r\n__u32 ctl, pitch, byteswap, scr;\r\nif (par->ramdac == IBM)\r\nset_imstt_regvals_ibm(par, bpp);\r\nelse\r\nset_imstt_regvals_tvp(par, bpp);\r\nswitch (bpp) {\r\ndefault:\r\ncase 8:\r\nctl = 0x17b1;\r\npitch = init->pitch >> 2;\r\nbyteswap = 0x000;\r\nbreak;\r\ncase 16:\r\nctl = 0x17b3;\r\npitch = init->pitch >> 1;\r\nbyteswap = 0x100;\r\nbreak;\r\ncase 24:\r\nctl = 0x17b9;\r\npitch = init->pitch - (init->pitch >> 2);\r\nbyteswap = 0x200;\r\nbreak;\r\ncase 32:\r\nctl = 0x17b5;\r\npitch = init->pitch;\r\nbyteswap = 0x300;\r\nbreak;\r\n}\r\nif (par->ramdac == TVP)\r\nctl -= 0x30;\r\nwrite_reg_le32(par->dc_regs, HES, init->hes);\r\nwrite_reg_le32(par->dc_regs, HEB, init->heb);\r\nwrite_reg_le32(par->dc_regs, HSB, init->hsb);\r\nwrite_reg_le32(par->dc_regs, HT, init->ht);\r\nwrite_reg_le32(par->dc_regs, VES, init->ves);\r\nwrite_reg_le32(par->dc_regs, VEB, init->veb);\r\nwrite_reg_le32(par->dc_regs, VSB, init->vsb);\r\nwrite_reg_le32(par->dc_regs, VT, init->vt);\r\nwrite_reg_le32(par->dc_regs, VIL, init->vil);\r\nwrite_reg_le32(par->dc_regs, HCIV, 1);\r\nwrite_reg_le32(par->dc_regs, VCIV, 1);\r\nwrite_reg_le32(par->dc_regs, TCDR, 4);\r\nwrite_reg_le32(par->dc_regs, RRCIV, 1);\r\nwrite_reg_le32(par->dc_regs, RRSC, 0x980);\r\nwrite_reg_le32(par->dc_regs, RRCR, 0x11);\r\nif (par->ramdac == IBM) {\r\nwrite_reg_le32(par->dc_regs, HRIR, 0x0100);\r\nwrite_reg_le32(par->dc_regs, CMR, 0x00ff);\r\nwrite_reg_le32(par->dc_regs, SRGCTL, 0x0073);\r\n} else {\r\nwrite_reg_le32(par->dc_regs, HRIR, 0x0200);\r\nwrite_reg_le32(par->dc_regs, CMR, 0x01ff);\r\nwrite_reg_le32(par->dc_regs, SRGCTL, 0x0003);\r\n}\r\nswitch (info->fix.smem_len) {\r\ncase 0x200000:\r\nscr = 0x059d | byteswap;\r\nbreak;\r\ndefault:\r\npitch >>= 1;\r\nscr = 0x150dd | byteswap;\r\nbreak;\r\n}\r\nwrite_reg_le32(par->dc_regs, SCR, scr);\r\nwrite_reg_le32(par->dc_regs, SPR, pitch);\r\nwrite_reg_le32(par->dc_regs, STGCTL, ctl);\r\n}\r\nstatic inline void\r\nset_offset (struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct imstt_par *par = info->par;\r\n__u32 off = var->yoffset * (info->fix.line_length >> 3)\r\n+ ((var->xoffset * (info->var.bits_per_pixel >> 3)) >> 3);\r\nwrite_reg_le32(par->dc_regs, SSR, off);\r\n}\r\nstatic inline void\r\nset_555 (struct imstt_par *par)\r\n{\r\nif (par->ramdac == IBM) {\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = BPP16; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x01; eieio();\r\n} else {\r\npar->cmap_regs[TVPADDRW] = TVPIRTCC; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x44; eieio();\r\n}\r\n}\r\nstatic inline void\r\nset_565 (struct imstt_par *par)\r\n{\r\nif (par->ramdac == IBM) {\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = BPP16; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x03; eieio();\r\n} else {\r\npar->cmap_regs[TVPADDRW] = TVPIRTCC; eieio();\r\npar->cmap_regs[TVPIDATA] = 0x45; eieio();\r\n}\r\n}\r\nstatic int\r\nimsttfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif ((var->bits_per_pixel != 8 && var->bits_per_pixel != 16\r\n&& var->bits_per_pixel != 24 && var->bits_per_pixel != 32)\r\n|| var->xres_virtual < var->xres || var->yres_virtual < var->yres\r\n|| var->nonstd\r\n|| (var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)\r\nreturn -EINVAL;\r\nif ((var->xres * var->yres) * (var->bits_per_pixel >> 3) > info->fix.smem_len\r\n|| (var->xres_virtual * var->yres_virtual) * (var->bits_per_pixel >> 3) > info->fix.smem_len)\r\nreturn -EINVAL;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nif (var->green.length != 6)\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nif (var->green.length != 6)\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nbreak;\r\n}\r\nif (var->yres == var->yres_virtual) {\r\n__u32 vram = (info->fix.smem_len - (PAGE_SIZE << 2));\r\nvar->yres_virtual = ((vram << 3) / var->bits_per_pixel) / var->xres_virtual;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->left_margin = var->right_margin = 16;\r\nvar->upper_margin = var->lower_margin = 16;\r\nvar->hsync_len = var->vsync_len = 8;\r\nreturn 0;\r\n}\r\nstatic int\r\nimsttfb_set_par(struct fb_info *info)\r\n{\r\nstruct imstt_par *par = info->par;\r\nif (!compute_imstt_regvals(par, info->var.xres, info->var.yres))\r\nreturn -EINVAL;\r\nif (info->var.green.length == 6)\r\nset_565(par);\r\nelse\r\nset_555(par);\r\nset_imstt_regvals(info, info->var.bits_per_pixel);\r\ninfo->var.pixclock = 1000000 / getclkMHz(par);\r\nreturn 0;\r\n}\r\nstatic int\r\nimsttfb_setcolreg (u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct imstt_par *par = info->par;\r\nu_int bpp = info->var.bits_per_pixel;\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (0 && bpp == 16)\r\npar->cmap_regs[PADDRW] = regno << 3;\r\nelse\r\npar->cmap_regs[PADDRW] = regno;\r\neieio();\r\npar->cmap_regs[PDATA] = red; eieio();\r\npar->cmap_regs[PDATA] = green; eieio();\r\npar->cmap_regs[PDATA] = blue; eieio();\r\nif (regno < 16)\r\nswitch (bpp) {\r\ncase 16:\r\npar->palette[regno] =\r\n(regno << (info->var.green.length ==\r\n5 ? 10 : 11)) | (regno << 5) | regno;\r\nbreak;\r\ncase 24:\r\npar->palette[regno] =\r\n(regno << 16) | (regno << 8) | regno;\r\nbreak;\r\ncase 32: {\r\nint i = (regno << 8) | regno;\r\npar->palette[regno] = (i << 16) |i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nimsttfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual\r\n|| var->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nset_offset(var, info);\r\nreturn 0;\r\n}\r\nstatic int\r\nimsttfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct imstt_par *par = info->par;\r\n__u32 ctrl;\r\nctrl = read_reg_le32(par->dc_regs, STGCTL);\r\nif (blank > 0) {\r\nswitch (blank) {\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_POWERDOWN:\r\nctrl &= ~0x00000380;\r\nif (par->ramdac == IBM) {\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = MISCTL2; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x55; eieio();\r\npar->cmap_regs[PIDXLO] = MISCTL1; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x11; eieio();\r\npar->cmap_regs[PIDXLO] = SYNCCTL; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x0f; eieio();\r\npar->cmap_regs[PIDXLO] = PWRMNGMT; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x1f; eieio();\r\npar->cmap_regs[PIDXLO] = CLKCTL; eieio();\r\npar->cmap_regs[PIDXDATA] = 0xc0;\r\n}\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nctrl &= ~0x00000020;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nctrl &= ~0x00000010;\r\nbreak;\r\n}\r\n} else {\r\nif (par->ramdac == IBM) {\r\nctrl |= 0x000017b0;\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = CLKCTL; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x01; eieio();\r\npar->cmap_regs[PIDXLO] = PWRMNGMT; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x00; eieio();\r\npar->cmap_regs[PIDXLO] = SYNCCTL; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x00; eieio();\r\npar->cmap_regs[PIDXLO] = MISCTL1; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x01; eieio();\r\npar->cmap_regs[PIDXLO] = MISCTL2; eieio();\r\npar->cmap_regs[PIDXDATA] = 0x45; eieio();\r\n} else\r\nctrl |= 0x00001780;\r\n}\r\nwrite_reg_le32(par->dc_regs, STGCTL, ctrl);\r\nreturn 0;\r\n}\r\nstatic void\r\nimsttfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct imstt_par *par = info->par;\r\n__u32 Bpp, line_pitch, bgc, dx, dy, width, height;\r\nbgc = rect->color;\r\nbgc |= (bgc << 8);\r\nbgc |= (bgc << 16);\r\nBpp = info->var.bits_per_pixel >> 3,\r\nline_pitch = info->fix.line_length;\r\ndy = rect->dy * line_pitch;\r\ndx = rect->dx * Bpp;\r\nheight = rect->height;\r\nheight--;\r\nwidth = rect->width * Bpp;\r\nwidth--;\r\nif (rect->rop == ROP_COPY) {\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwrite_reg_le32(par->dc_regs, DSA, dy + dx);\r\nwrite_reg_le32(par->dc_regs, CNT, (height << 16) | width);\r\nwrite_reg_le32(par->dc_regs, DP_OCTL, line_pitch);\r\nwrite_reg_le32(par->dc_regs, BI, 0xffffffff);\r\nwrite_reg_le32(par->dc_regs, MBC, 0xffffffff);\r\nwrite_reg_le32(par->dc_regs, CLR, bgc);\r\nwrite_reg_le32(par->dc_regs, BLTCTL, 0x840);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\r\n} else {\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwrite_reg_le32(par->dc_regs, DSA, dy + dx);\r\nwrite_reg_le32(par->dc_regs, S1SA, dy + dx);\r\nwrite_reg_le32(par->dc_regs, CNT, (height << 16) | width);\r\nwrite_reg_le32(par->dc_regs, DP_OCTL, line_pitch);\r\nwrite_reg_le32(par->dc_regs, SP, line_pitch);\r\nwrite_reg_le32(par->dc_regs, BLTCTL, 0x40005);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\r\n}\r\n}\r\nstatic void\r\nimsttfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct imstt_par *par = info->par;\r\n__u32 Bpp, line_pitch, fb_offset_old, fb_offset_new, sp, dp_octl;\r\n__u32 cnt, bltctl, sx, sy, dx, dy, height, width;\r\nBpp = info->var.bits_per_pixel >> 3,\r\nsx = area->sx * Bpp;\r\nsy = area->sy;\r\ndx = area->dx * Bpp;\r\ndy = area->dy;\r\nheight = area->height;\r\nheight--;\r\nwidth = area->width * Bpp;\r\nwidth--;\r\nline_pitch = info->fix.line_length;\r\nbltctl = 0x05;\r\nsp = line_pitch << 16;\r\ncnt = height << 16;\r\nif (sy < dy) {\r\nsy += height;\r\ndy += height;\r\nsp |= -(line_pitch) & 0xffff;\r\ndp_octl = -(line_pitch) & 0xffff;\r\n} else {\r\nsp |= line_pitch;\r\ndp_octl = line_pitch;\r\n}\r\nif (sx < dx) {\r\nsx += width;\r\ndx += width;\r\nbltctl |= 0x80;\r\ncnt |= -(width) & 0xffff;\r\n} else {\r\ncnt |= width;\r\n}\r\nfb_offset_old = sy * line_pitch + sx;\r\nfb_offset_new = dy * line_pitch + dx;\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwrite_reg_le32(par->dc_regs, S1SA, fb_offset_old);\r\nwrite_reg_le32(par->dc_regs, SP, sp);\r\nwrite_reg_le32(par->dc_regs, DSA, fb_offset_new);\r\nwrite_reg_le32(par->dc_regs, CNT, cnt);\r\nwrite_reg_le32(par->dc_regs, DP_OCTL, dp_octl);\r\nwrite_reg_le32(par->dc_regs, BLTCTL, bltctl);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x80);\r\nwhile(read_reg_le32(par->dc_regs, SSTATUS) & 0x40);\r\n}\r\nstatic int\r\nimsttfb_ioctl(struct fb_info *info, u_int cmd, u_long arg)\r\n{\r\nstruct imstt_par *par = info->par;\r\nvoid __user *argp = (void __user *)arg;\r\n__u32 reg[2];\r\n__u8 idx[2];\r\nswitch (cmd) {\r\ncase FBIMSTT_SETREG:\r\nif (copy_from_user(reg, argp, 8) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\r\nreturn -EFAULT;\r\nwrite_reg_le32(par->dc_regs, reg[0], reg[1]);\r\nreturn 0;\r\ncase FBIMSTT_GETREG:\r\nif (copy_from_user(reg, argp, 4) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\r\nreturn -EFAULT;\r\nreg[1] = read_reg_le32(par->dc_regs, reg[0]);\r\nif (copy_to_user((void __user *)(arg + 4), &reg[1], 4))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FBIMSTT_SETCMAPREG:\r\nif (copy_from_user(reg, argp, 8) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\r\nreturn -EFAULT;\r\nwrite_reg_le32(((u_int __iomem *)par->cmap_regs), reg[0], reg[1]);\r\nreturn 0;\r\ncase FBIMSTT_GETCMAPREG:\r\nif (copy_from_user(reg, argp, 4) || reg[0] > (0x1000 - sizeof(reg[0])) / sizeof(reg[0]))\r\nreturn -EFAULT;\r\nreg[1] = read_reg_le32(((u_int __iomem *)par->cmap_regs), reg[0]);\r\nif (copy_to_user((void __user *)(arg + 4), &reg[1], 4))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase FBIMSTT_SETIDXREG:\r\nif (copy_from_user(idx, argp, 2))\r\nreturn -EFAULT;\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = idx[0]; eieio();\r\npar->cmap_regs[PIDXDATA] = idx[1]; eieio();\r\nreturn 0;\r\ncase FBIMSTT_GETIDXREG:\r\nif (copy_from_user(idx, argp, 1))\r\nreturn -EFAULT;\r\npar->cmap_regs[PIDXHI] = 0; eieio();\r\npar->cmap_regs[PIDXLO] = idx[0]; eieio();\r\nidx[1] = par->cmap_regs[PIDXDATA];\r\nif (copy_to_user((void __user *)(arg + 1), &idx[1], 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void init_imstt(struct fb_info *info)\r\n{\r\nstruct imstt_par *par = info->par;\r\n__u32 i, tmp, *ip, *end;\r\ntmp = read_reg_le32(par->dc_regs, PRC);\r\nif (par->ramdac == IBM)\r\ninfo->fix.smem_len = (tmp & 0x0004) ? 0x400000 : 0x200000;\r\nelse\r\ninfo->fix.smem_len = 0x800000;\r\nip = (__u32 *)info->screen_base;\r\nend = (__u32 *)(info->screen_base + info->fix.smem_len);\r\nwhile (ip < end)\r\n*ip++ = 0;\r\ntmp = read_reg_le32(par->dc_regs, STGCTL);\r\nwrite_reg_le32(par->dc_regs, STGCTL, tmp & ~0x1);\r\nwrite_reg_le32(par->dc_regs, SSR, 0);\r\nif (par->ramdac == IBM) {\r\npar->cmap_regs[PPMASK] = 0xff;\r\neieio();\r\npar->cmap_regs[PIDXHI] = 0;\r\neieio();\r\nfor (i = 0; i < ARRAY_SIZE(ibm_initregs); i++) {\r\npar->cmap_regs[PIDXLO] = ibm_initregs[i].addr;\r\neieio();\r\npar->cmap_regs[PIDXDATA] = ibm_initregs[i].value;\r\neieio();\r\n}\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(tvp_initregs); i++) {\r\npar->cmap_regs[TVPADDRW] = tvp_initregs[i].addr;\r\neieio();\r\npar->cmap_regs[TVPIDATA] = tvp_initregs[i].value;\r\neieio();\r\n}\r\n}\r\n#if USE_NV_MODES && defined(CONFIG_PPC32)\r\n{\r\nint vmode = init_vmode, cmode = init_cmode;\r\nif (vmode == -1) {\r\nvmode = nvram_read_byte(NV_VMODE);\r\nif (vmode <= 0 || vmode > VMODE_MAX)\r\nvmode = VMODE_640_480_67;\r\n}\r\nif (cmode == -1) {\r\ncmode = nvram_read_byte(NV_CMODE);\r\nif (cmode < CMODE_8 || cmode > CMODE_32)\r\ncmode = CMODE_8;\r\n}\r\nif (mac_vmode_to_var(vmode, cmode, &info->var)) {\r\ninfo->var.xres = info->var.xres_virtual = INIT_XRES;\r\ninfo->var.yres = info->var.yres_virtual = INIT_YRES;\r\ninfo->var.bits_per_pixel = INIT_BPP;\r\n}\r\n}\r\n#else\r\ninfo->var.xres = info->var.xres_virtual = INIT_XRES;\r\ninfo->var.yres = info->var.yres_virtual = INIT_YRES;\r\ninfo->var.bits_per_pixel = INIT_BPP;\r\n#endif\r\nif ((info->var.xres * info->var.yres) * (info->var.bits_per_pixel >> 3) > info->fix.smem_len\r\n|| !(compute_imstt_regvals(par, info->var.xres, info->var.yres))) {\r\nprintk("imsttfb: %ux%ux%u not supported\n", info->var.xres, info->var.yres, info->var.bits_per_pixel);\r\nframebuffer_release(info);\r\nreturn;\r\n}\r\nsprintf(info->fix.id, "IMS TT (%s)", par->ramdac == IBM ? "IBM" : "TVP");\r\ninfo->fix.mmio_len = 0x1000;\r\ninfo->fix.accel = FB_ACCEL_IMS_TWINTURBO;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = info->var.bits_per_pixel == 8 ? FB_VISUAL_PSEUDOCOLOR\r\n: FB_VISUAL_DIRECTCOLOR;\r\ninfo->fix.line_length = info->var.xres * (info->var.bits_per_pixel >> 3);\r\ninfo->fix.xpanstep = 8;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->var.accel_flags = FB_ACCELF_TEXT;\r\nif (info->var.green.length == 6)\r\nset_565(par);\r\nelse\r\nset_555(par);\r\nset_imstt_regvals(info, info->var.bits_per_pixel);\r\ninfo->var.pixclock = 1000000 / getclkMHz(par);\r\ninfo->fbops = &imsttfb_ops;\r\ninfo->flags = FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_YPAN;\r\nfb_alloc_cmap(&info->cmap, 0, 0);\r\nif (register_framebuffer(info) < 0) {\r\nframebuffer_release(info);\r\nreturn;\r\n}\r\ntmp = (read_reg_le32(par->dc_regs, SSTATUS) & 0x0f00) >> 8;\r\nfb_info(info, "%s frame buffer; %uMB vram; chip version %u\n",\r\ninfo->fix.id, info->fix.smem_len >> 20, tmp);\r\n}\r\nstatic int imsttfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned long addr, size;\r\nstruct imstt_par *par;\r\nstruct fb_info *info;\r\n#ifdef CONFIG_PPC_OF\r\nstruct device_node *dp;\r\ndp = pci_device_to_OF_node(pdev);\r\nif(dp)\r\nprintk(KERN_INFO "%s: OF name %s\n",__func__, dp->name);\r\nelse\r\nprintk(KERN_ERR "imsttfb: no OF node for pci device\n");\r\n#endif\r\ninfo = framebuffer_alloc(sizeof(struct imstt_par), &pdev->dev);\r\nif (!info) {\r\nprintk(KERN_ERR "imsttfb: Can't allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\naddr = pci_resource_start (pdev, 0);\r\nsize = pci_resource_len (pdev, 0);\r\nif (!request_mem_region(addr, size, "imsttfb")) {\r\nprintk(KERN_ERR "imsttfb: Can't reserve memory region\n");\r\nframebuffer_release(info);\r\nreturn -ENODEV;\r\n}\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_IMS_TT128:\r\npar->ramdac = IBM;\r\n#ifdef CONFIG_PPC_OF\r\nif (dp && ((strcmp(dp->name, "IMS,tt128mb8") == 0) ||\r\n(strcmp(dp->name, "IMS,tt128mb8A") == 0)))\r\npar->ramdac = TVP;\r\n#endif\r\nbreak;\r\ncase PCI_DEVICE_ID_IMS_TT3D:\r\npar->ramdac = TVP;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "imsttfb: Device 0x%x unknown, "\r\n"contact maintainer.\n", pdev->device);\r\nrelease_mem_region(addr, size);\r\nframebuffer_release(info);\r\nreturn -ENODEV;\r\n}\r\ninfo->fix.smem_start = addr;\r\ninfo->screen_base = (__u8 *)ioremap(addr, par->ramdac == IBM ?\r\n0x400000 : 0x800000);\r\ninfo->fix.mmio_start = addr + 0x800000;\r\npar->dc_regs = ioremap(addr + 0x800000, 0x1000);\r\npar->cmap_regs_phys = addr + 0x840000;\r\npar->cmap_regs = (__u8 *)ioremap(addr + 0x840000, 0x1000);\r\ninfo->pseudo_palette = par->palette;\r\ninit_imstt(info);\r\npci_set_drvdata(pdev, info);\r\nreturn 0;\r\n}\r\nstatic void imsttfb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct imstt_par *par = info->par;\r\nint size = pci_resource_len(pdev, 0);\r\nunregister_framebuffer(info);\r\niounmap(par->cmap_regs);\r\niounmap(par->dc_regs);\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->fix.smem_start, size);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init\r\nimsttfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "font:", 5)) {\r\nchar *p;\r\nint i;\r\np = this_opt + 5;\r\nfor (i = 0; i < sizeof(fontname) - 1; i++)\r\nif (!*p || *p == ' ' || *p == ',')\r\nbreak;\r\nmemcpy(fontname, this_opt + 5, i);\r\nfontname[i] = 0;\r\n} else if (!strncmp(this_opt, "inverse", 7)) {\r\ninverse = 1;\r\nfb_invert_cmaps();\r\n}\r\n#if defined(CONFIG_PPC)\r\nelse if (!strncmp(this_opt, "vmode:", 6)) {\r\nint vmode = simple_strtoul(this_opt+6, NULL, 0);\r\nif (vmode > 0 && vmode <= VMODE_MAX)\r\ninit_vmode = vmode;\r\n} else if (!strncmp(this_opt, "cmode:", 6)) {\r\nint cmode = simple_strtoul(this_opt+6, NULL, 0);\r\nswitch (cmode) {\r\ncase CMODE_8:\r\ncase 8:\r\ninit_cmode = CMODE_8;\r\nbreak;\r\ncase CMODE_16:\r\ncase 15:\r\ncase 16:\r\ninit_cmode = CMODE_16;\r\nbreak;\r\ncase CMODE_32:\r\ncase 24:\r\ncase 32:\r\ninit_cmode = CMODE_32;\r\nbreak;\r\n}\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init imsttfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("imsttfb", &option))\r\nreturn -ENODEV;\r\nimsttfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&imsttfb_pci_driver);\r\n}\r\nstatic void __exit imsttfb_exit(void)\r\n{\r\npci_unregister_driver(&imsttfb_pci_driver);\r\n}
