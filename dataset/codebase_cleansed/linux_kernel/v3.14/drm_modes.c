void drm_mode_debug_printmodeline(const struct drm_display_mode *mode)\r\n{\r\nDRM_DEBUG_KMS("Modeline %d:\"%s\" %d %d %d %d %d %d %d %d %d %d "\r\n"0x%x 0x%x\n",\r\nmode->base.id, mode->name, mode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal, mode->type, mode->flags);\r\n}\r\nstruct drm_display_mode *drm_cvt_mode(struct drm_device *dev, int hdisplay,\r\nint vdisplay, int vrefresh,\r\nbool reduced, bool interlaced, bool margins)\r\n{\r\n#define CVT_MARGIN_PERCENTAGE 18\r\n#define CVT_H_GRANULARITY 8\r\n#define CVT_MIN_V_PORCH 3\r\n#define CVT_MIN_V_BPORCH 6\r\n#define CVT_CLOCK_STEP 250\r\nstruct drm_display_mode *drm_mode;\r\nunsigned int vfieldrate, hperiod;\r\nint hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;\r\nint interlace;\r\ndrm_mode = drm_mode_create(dev);\r\nif (!drm_mode)\r\nreturn NULL;\r\nif (!vrefresh)\r\nvrefresh = 60;\r\nif (interlaced)\r\nvfieldrate = vrefresh * 2;\r\nelse\r\nvfieldrate = vrefresh;\r\nhdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);\r\nhmargin = 0;\r\nif (margins) {\r\nhmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;\r\nhmargin -= hmargin % CVT_H_GRANULARITY;\r\n}\r\ndrm_mode->hdisplay = hdisplay_rnd + 2 * hmargin;\r\nif (interlaced)\r\nvdisplay_rnd = vdisplay / 2;\r\nelse\r\nvdisplay_rnd = vdisplay;\r\nvmargin = 0;\r\nif (margins)\r\nvmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;\r\ndrm_mode->vdisplay = vdisplay + 2 * vmargin;\r\nif (interlaced)\r\ninterlace = 1;\r\nelse\r\ninterlace = 0;\r\nif (!(vdisplay % 3) && ((vdisplay * 4 / 3) == hdisplay))\r\nvsync = 4;\r\nelse if (!(vdisplay % 9) && ((vdisplay * 16 / 9) == hdisplay))\r\nvsync = 5;\r\nelse if (!(vdisplay % 10) && ((vdisplay * 16 / 10) == hdisplay))\r\nvsync = 6;\r\nelse if (!(vdisplay % 4) && ((vdisplay * 5 / 4) == hdisplay))\r\nvsync = 7;\r\nelse if (!(vdisplay % 9) && ((vdisplay * 15 / 9) == hdisplay))\r\nvsync = 7;\r\nelse\r\nvsync = 10;\r\nif (!reduced) {\r\nint tmp1, tmp2;\r\n#define CVT_MIN_VSYNC_BP 550\r\n#define CVT_HSYNC_PERCENTAGE 8\r\nunsigned int hblank_percentage;\r\nint vsyncandback_porch, vback_porch, hblank;\r\ntmp1 = HV_FACTOR * 1000000 -\r\nCVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;\r\ntmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +\r\ninterlace;\r\nhperiod = tmp1 * 2 / (tmp2 * vfieldrate);\r\ntmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;\r\nif (tmp1 < (vsync + CVT_MIN_V_PORCH))\r\nvsyncandback_porch = vsync + CVT_MIN_V_PORCH;\r\nelse\r\nvsyncandback_porch = tmp1;\r\nvback_porch = vsyncandback_porch - vsync;\r\ndrm_mode->vtotal = vdisplay_rnd + 2 * vmargin +\r\nvsyncandback_porch + CVT_MIN_V_PORCH;\r\n#define CVT_M_FACTOR 600\r\n#define CVT_C_FACTOR 40\r\n#define CVT_K_FACTOR 128\r\n#define CVT_J_FACTOR 20\r\n#define CVT_M_PRIME (CVT_M_FACTOR * CVT_K_FACTOR / 256)\r\n#define CVT_C_PRIME ((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \\r\nCVT_J_FACTOR)\r\nhblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *\r\nhperiod / 1000;\r\nif (hblank_percentage < 20 * HV_FACTOR)\r\nhblank_percentage = 20 * HV_FACTOR;\r\nhblank = drm_mode->hdisplay * hblank_percentage /\r\n(100 * HV_FACTOR - hblank_percentage);\r\nhblank -= hblank % (2 * CVT_H_GRANULARITY);\r\ndrm_mode->htotal = drm_mode->hdisplay + hblank;\r\ndrm_mode->hsync_end = drm_mode->hdisplay + hblank / 2;\r\ndrm_mode->hsync_start = drm_mode->hsync_end -\r\n(drm_mode->htotal * CVT_HSYNC_PERCENTAGE) / 100;\r\ndrm_mode->hsync_start += CVT_H_GRANULARITY -\r\ndrm_mode->hsync_start % CVT_H_GRANULARITY;\r\ndrm_mode->vsync_start = drm_mode->vdisplay + CVT_MIN_V_PORCH;\r\ndrm_mode->vsync_end = drm_mode->vsync_start + vsync;\r\n} else {\r\n#define CVT_RB_MIN_VBLANK 460\r\n#define CVT_RB_H_SYNC 32\r\n#define CVT_RB_H_BLANK 160\r\n#define CVT_RB_VFPORCH 3\r\nint vbilines;\r\nint tmp1, tmp2;\r\ntmp1 = HV_FACTOR * 1000000 -\r\nCVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;\r\ntmp2 = vdisplay_rnd + 2 * vmargin;\r\nhperiod = tmp1 / (tmp2 * vfieldrate);\r\nvbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;\r\nif (vbilines < (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))\r\nvbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;\r\ndrm_mode->vtotal = vdisplay_rnd + 2 * vmargin + vbilines;\r\ndrm_mode->htotal = drm_mode->hdisplay + CVT_RB_H_BLANK;\r\ndrm_mode->hsync_end = drm_mode->hdisplay + CVT_RB_H_BLANK / 2;\r\ndrm_mode->hsync_start = drm_mode->hsync_end - CVT_RB_H_SYNC;\r\ndrm_mode->vsync_start = drm_mode->vdisplay + CVT_RB_VFPORCH;\r\ndrm_mode->vsync_end = drm_mode->vsync_start + vsync;\r\n}\r\ndrm_mode->clock = drm_mode->htotal * HV_FACTOR * 1000 / hperiod;\r\ndrm_mode->clock -= drm_mode->clock % CVT_CLOCK_STEP;\r\nif (interlaced) {\r\ndrm_mode->vtotal *= 2;\r\ndrm_mode->flags |= DRM_MODE_FLAG_INTERLACE;\r\n}\r\ndrm_mode_set_name(drm_mode);\r\nif (reduced)\r\ndrm_mode->flags |= (DRM_MODE_FLAG_PHSYNC |\r\nDRM_MODE_FLAG_NVSYNC);\r\nelse\r\ndrm_mode->flags |= (DRM_MODE_FLAG_PVSYNC |\r\nDRM_MODE_FLAG_NHSYNC);\r\nreturn drm_mode;\r\n}\r\nstruct drm_display_mode *\r\ndrm_gtf_mode_complex(struct drm_device *dev, int hdisplay, int vdisplay,\r\nint vrefresh, bool interlaced, int margins,\r\nint GTF_M, int GTF_2C, int GTF_K, int GTF_2J)\r\n{\r\n#define GTF_MARGIN_PERCENTAGE 18\r\n#define GTF_CELL_GRAN 8\r\n#define GTF_MIN_V_PORCH 1\r\n#define V_SYNC_RQD 3\r\n#define H_SYNC_PERCENT 8\r\n#define MIN_VSYNC_PLUS_BP 550\r\n#define GTF_C_PRIME ((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)\r\n#define GTF_M_PRIME (GTF_K * GTF_M / 256)\r\nstruct drm_display_mode *drm_mode;\r\nunsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;\r\nint top_margin, bottom_margin;\r\nint interlace;\r\nunsigned int hfreq_est;\r\nint vsync_plus_bp, vback_porch;\r\nunsigned int vtotal_lines, vfieldrate_est, hperiod;\r\nunsigned int vfield_rate, vframe_rate;\r\nint left_margin, right_margin;\r\nunsigned int total_active_pixels, ideal_duty_cycle;\r\nunsigned int hblank, total_pixels, pixel_freq;\r\nint hsync, hfront_porch, vodd_front_porch_lines;\r\nunsigned int tmp1, tmp2;\r\ndrm_mode = drm_mode_create(dev);\r\nif (!drm_mode)\r\nreturn NULL;\r\nhdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;\r\nhdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;\r\nif (interlaced)\r\nvdisplay_rnd = vdisplay / 2;\r\nelse\r\nvdisplay_rnd = vdisplay;\r\nif (interlaced)\r\nvfieldrate_rqd = vrefresh * 2;\r\nelse\r\nvfieldrate_rqd = vrefresh;\r\ntop_margin = 0;\r\nif (margins)\r\ntop_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /\r\n1000;\r\nbottom_margin = top_margin;\r\nif (interlaced)\r\ninterlace = 1;\r\nelse\r\ninterlace = 0;\r\n{\r\ntmp1 = (1000000 - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;\r\ntmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *\r\n2 + interlace;\r\nhfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;\r\n}\r\nvsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;\r\nvsync_plus_bp = (vsync_plus_bp + 500) / 1000;\r\nvback_porch = vsync_plus_bp - V_SYNC_RQD;\r\nvtotal_lines = vdisplay_rnd + top_margin + bottom_margin +\r\nvsync_plus_bp + GTF_MIN_V_PORCH;\r\nvfieldrate_est = hfreq_est / vtotal_lines;\r\nhperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);\r\nvfield_rate = hfreq_est / vtotal_lines;\r\nif (interlaced)\r\nvframe_rate = vfield_rate / 2;\r\nelse\r\nvframe_rate = vfield_rate;\r\nif (margins)\r\nleft_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /\r\n1000;\r\nelse\r\nleft_margin = 0;\r\nright_margin = left_margin;\r\ntotal_active_pixels = hdisplay_rnd + left_margin + right_margin;\r\nideal_duty_cycle = GTF_C_PRIME * 1000 -\r\n(GTF_M_PRIME * 1000000 / hfreq_est);\r\nhblank = total_active_pixels * ideal_duty_cycle /\r\n(100000 - ideal_duty_cycle);\r\nhblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);\r\nhblank = hblank * 2 * GTF_CELL_GRAN;\r\ntotal_pixels = total_active_pixels + hblank;\r\npixel_freq = total_pixels * hfreq_est / 1000;\r\nhsync = H_SYNC_PERCENT * total_pixels / 100;\r\nhsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;\r\nhsync = hsync * GTF_CELL_GRAN;\r\nhfront_porch = hblank / 2 - hsync;\r\nvodd_front_porch_lines = GTF_MIN_V_PORCH ;\r\ndrm_mode->hdisplay = hdisplay_rnd;\r\ndrm_mode->hsync_start = hdisplay_rnd + hfront_porch;\r\ndrm_mode->hsync_end = drm_mode->hsync_start + hsync;\r\ndrm_mode->htotal = total_pixels;\r\ndrm_mode->vdisplay = vdisplay_rnd;\r\ndrm_mode->vsync_start = vdisplay_rnd + vodd_front_porch_lines;\r\ndrm_mode->vsync_end = drm_mode->vsync_start + V_SYNC_RQD;\r\ndrm_mode->vtotal = vtotal_lines;\r\ndrm_mode->clock = pixel_freq;\r\nif (interlaced) {\r\ndrm_mode->vtotal *= 2;\r\ndrm_mode->flags |= DRM_MODE_FLAG_INTERLACE;\r\n}\r\ndrm_mode_set_name(drm_mode);\r\nif (GTF_M == 600 && GTF_2C == 80 && GTF_K == 128 && GTF_2J == 40)\r\ndrm_mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;\r\nelse\r\ndrm_mode->flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;\r\nreturn drm_mode;\r\n}\r\nstruct drm_display_mode *\r\ndrm_gtf_mode(struct drm_device *dev, int hdisplay, int vdisplay, int vrefresh,\r\nbool lace, int margins)\r\n{\r\nreturn drm_gtf_mode_complex(dev, hdisplay, vdisplay, vrefresh, lace,\r\nmargins, 600, 40 * 2, 128, 20 * 2);\r\n}\r\nint drm_display_mode_from_videomode(const struct videomode *vm,\r\nstruct drm_display_mode *dmode)\r\n{\r\ndmode->hdisplay = vm->hactive;\r\ndmode->hsync_start = dmode->hdisplay + vm->hfront_porch;\r\ndmode->hsync_end = dmode->hsync_start + vm->hsync_len;\r\ndmode->htotal = dmode->hsync_end + vm->hback_porch;\r\ndmode->vdisplay = vm->vactive;\r\ndmode->vsync_start = dmode->vdisplay + vm->vfront_porch;\r\ndmode->vsync_end = dmode->vsync_start + vm->vsync_len;\r\ndmode->vtotal = dmode->vsync_end + vm->vback_porch;\r\ndmode->clock = vm->pixelclock / 1000;\r\ndmode->flags = 0;\r\nif (vm->flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\ndmode->flags |= DRM_MODE_FLAG_PHSYNC;\r\nelse if (vm->flags & DISPLAY_FLAGS_HSYNC_LOW)\r\ndmode->flags |= DRM_MODE_FLAG_NHSYNC;\r\nif (vm->flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\ndmode->flags |= DRM_MODE_FLAG_PVSYNC;\r\nelse if (vm->flags & DISPLAY_FLAGS_VSYNC_LOW)\r\ndmode->flags |= DRM_MODE_FLAG_NVSYNC;\r\nif (vm->flags & DISPLAY_FLAGS_INTERLACED)\r\ndmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (vm->flags & DISPLAY_FLAGS_DOUBLESCAN)\r\ndmode->flags |= DRM_MODE_FLAG_DBLSCAN;\r\nif (vm->flags & DISPLAY_FLAGS_DOUBLECLK)\r\ndmode->flags |= DRM_MODE_FLAG_DBLCLK;\r\ndrm_mode_set_name(dmode);\r\nreturn 0;\r\n}\r\nint of_get_drm_display_mode(struct device_node *np,\r\nstruct drm_display_mode *dmode, int index)\r\n{\r\nstruct videomode vm;\r\nint ret;\r\nret = of_get_videomode(np, &vm, index);\r\nif (ret)\r\nreturn ret;\r\ndrm_display_mode_from_videomode(&vm, dmode);\r\npr_debug("%s: got %dx%d display mode from %s\n",\r\nof_node_full_name(np), vm.hactive, vm.vactive, np->name);\r\ndrm_mode_debug_printmodeline(dmode);\r\nreturn 0;\r\n}\r\nvoid drm_mode_set_name(struct drm_display_mode *mode)\r\n{\r\nbool interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\r\nsnprintf(mode->name, DRM_DISPLAY_MODE_LEN, "%dx%d%s",\r\nmode->hdisplay, mode->vdisplay,\r\ninterlaced ? "i" : "");\r\n}\r\nint drm_mode_width(const struct drm_display_mode *mode)\r\n{\r\nreturn mode->hdisplay;\r\n}\r\nint drm_mode_height(const struct drm_display_mode *mode)\r\n{\r\nreturn mode->vdisplay;\r\n}\r\nint drm_mode_hsync(const struct drm_display_mode *mode)\r\n{\r\nunsigned int calc_val;\r\nif (mode->hsync)\r\nreturn mode->hsync;\r\nif (mode->htotal < 0)\r\nreturn 0;\r\ncalc_val = (mode->clock * 1000) / mode->htotal;\r\ncalc_val += 500;\r\ncalc_val /= 1000;\r\nreturn calc_val;\r\n}\r\nint drm_mode_vrefresh(const struct drm_display_mode *mode)\r\n{\r\nint refresh = 0;\r\nunsigned int calc_val;\r\nif (mode->vrefresh > 0)\r\nrefresh = mode->vrefresh;\r\nelse if (mode->htotal > 0 && mode->vtotal > 0) {\r\nint vtotal;\r\nvtotal = mode->vtotal;\r\ncalc_val = (mode->clock * 1000);\r\ncalc_val /= mode->htotal;\r\nrefresh = (calc_val + vtotal / 2) / vtotal;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nrefresh *= 2;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nrefresh /= 2;\r\nif (mode->vscan > 1)\r\nrefresh /= mode->vscan;\r\n}\r\nreturn refresh;\r\n}\r\nvoid drm_mode_set_crtcinfo(struct drm_display_mode *p, int adjust_flags)\r\n{\r\nif ((p == NULL) || ((p->type & DRM_MODE_TYPE_CRTC_C) == DRM_MODE_TYPE_BUILTIN))\r\nreturn;\r\np->crtc_clock = p->clock;\r\np->crtc_hdisplay = p->hdisplay;\r\np->crtc_hsync_start = p->hsync_start;\r\np->crtc_hsync_end = p->hsync_end;\r\np->crtc_htotal = p->htotal;\r\np->crtc_hskew = p->hskew;\r\np->crtc_vdisplay = p->vdisplay;\r\np->crtc_vsync_start = p->vsync_start;\r\np->crtc_vsync_end = p->vsync_end;\r\np->crtc_vtotal = p->vtotal;\r\nif (p->flags & DRM_MODE_FLAG_INTERLACE) {\r\nif (adjust_flags & CRTC_INTERLACE_HALVE_V) {\r\np->crtc_vdisplay /= 2;\r\np->crtc_vsync_start /= 2;\r\np->crtc_vsync_end /= 2;\r\np->crtc_vtotal /= 2;\r\n}\r\n}\r\nif (p->flags & DRM_MODE_FLAG_DBLSCAN) {\r\np->crtc_vdisplay *= 2;\r\np->crtc_vsync_start *= 2;\r\np->crtc_vsync_end *= 2;\r\np->crtc_vtotal *= 2;\r\n}\r\nif (p->vscan > 1) {\r\np->crtc_vdisplay *= p->vscan;\r\np->crtc_vsync_start *= p->vscan;\r\np->crtc_vsync_end *= p->vscan;\r\np->crtc_vtotal *= p->vscan;\r\n}\r\nif (adjust_flags & CRTC_STEREO_DOUBLE) {\r\nunsigned int layout = p->flags & DRM_MODE_FLAG_3D_MASK;\r\nswitch (layout) {\r\ncase DRM_MODE_FLAG_3D_FRAME_PACKING:\r\np->crtc_clock *= 2;\r\np->crtc_vdisplay += p->crtc_vtotal;\r\np->crtc_vsync_start += p->crtc_vtotal;\r\np->crtc_vsync_end += p->crtc_vtotal;\r\np->crtc_vtotal += p->crtc_vtotal;\r\nbreak;\r\n}\r\n}\r\np->crtc_vblank_start = min(p->crtc_vsync_start, p->crtc_vdisplay);\r\np->crtc_vblank_end = max(p->crtc_vsync_end, p->crtc_vtotal);\r\np->crtc_hblank_start = min(p->crtc_hsync_start, p->crtc_hdisplay);\r\np->crtc_hblank_end = max(p->crtc_hsync_end, p->crtc_htotal);\r\n}\r\nvoid drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src)\r\n{\r\nint id = dst->base.id;\r\nstruct list_head head = dst->head;\r\n*dst = *src;\r\ndst->base.id = id;\r\ndst->head = head;\r\n}\r\nstruct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct drm_display_mode *nmode;\r\nnmode = drm_mode_create(dev);\r\nif (!nmode)\r\nreturn NULL;\r\ndrm_mode_copy(nmode, mode);\r\nreturn nmode;\r\n}\r\nbool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2)\r\n{\r\nif (mode1->clock && mode2->clock) {\r\nif (KHZ2PICOS(mode1->clock) != KHZ2PICOS(mode2->clock))\r\nreturn false;\r\n} else if (mode1->clock != mode2->clock)\r\nreturn false;\r\nif ((mode1->flags & DRM_MODE_FLAG_3D_MASK) !=\r\n(mode2->flags & DRM_MODE_FLAG_3D_MASK))\r\nreturn false;\r\nreturn drm_mode_equal_no_clocks_no_stereo(mode1, mode2);\r\n}\r\nbool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1,\r\nconst struct drm_display_mode *mode2)\r\n{\r\nif (mode1->hdisplay == mode2->hdisplay &&\r\nmode1->hsync_start == mode2->hsync_start &&\r\nmode1->hsync_end == mode2->hsync_end &&\r\nmode1->htotal == mode2->htotal &&\r\nmode1->hskew == mode2->hskew &&\r\nmode1->vdisplay == mode2->vdisplay &&\r\nmode1->vsync_start == mode2->vsync_start &&\r\nmode1->vsync_end == mode2->vsync_end &&\r\nmode1->vtotal == mode2->vtotal &&\r\nmode1->vscan == mode2->vscan &&\r\n(mode1->flags & ~DRM_MODE_FLAG_3D_MASK) ==\r\n(mode2->flags & ~DRM_MODE_FLAG_3D_MASK))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid drm_mode_validate_size(struct drm_device *dev,\r\nstruct list_head *mode_list,\r\nint maxX, int maxY, int maxPitch)\r\n{\r\nstruct drm_display_mode *mode;\r\nlist_for_each_entry(mode, mode_list, head) {\r\nif (maxPitch > 0 && mode->hdisplay > maxPitch)\r\nmode->status = MODE_BAD_WIDTH;\r\nif (maxX > 0 && mode->hdisplay > maxX)\r\nmode->status = MODE_VIRTUAL_X;\r\nif (maxY > 0 && mode->vdisplay > maxY)\r\nmode->status = MODE_VIRTUAL_Y;\r\n}\r\n}\r\nvoid drm_mode_prune_invalid(struct drm_device *dev,\r\nstruct list_head *mode_list, bool verbose)\r\n{\r\nstruct drm_display_mode *mode, *t;\r\nlist_for_each_entry_safe(mode, t, mode_list, head) {\r\nif (mode->status != MODE_OK) {\r\nlist_del(&mode->head);\r\nif (verbose) {\r\ndrm_mode_debug_printmodeline(mode);\r\nDRM_DEBUG_KMS("Not using %s mode %d\n",\r\nmode->name, mode->status);\r\n}\r\ndrm_mode_destroy(dev, mode);\r\n}\r\n}\r\n}\r\nstatic int drm_mode_compare(void *priv, struct list_head *lh_a, struct list_head *lh_b)\r\n{\r\nstruct drm_display_mode *a = list_entry(lh_a, struct drm_display_mode, head);\r\nstruct drm_display_mode *b = list_entry(lh_b, struct drm_display_mode, head);\r\nint diff;\r\ndiff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -\r\n((a->type & DRM_MODE_TYPE_PREFERRED) != 0);\r\nif (diff)\r\nreturn diff;\r\ndiff = b->hdisplay * b->vdisplay - a->hdisplay * a->vdisplay;\r\nif (diff)\r\nreturn diff;\r\ndiff = b->vrefresh - a->vrefresh;\r\nif (diff)\r\nreturn diff;\r\ndiff = b->clock - a->clock;\r\nreturn diff;\r\n}\r\nvoid drm_mode_sort(struct list_head *mode_list)\r\n{\r\nlist_sort(NULL, mode_list, drm_mode_compare);\r\n}\r\nvoid drm_mode_connector_list_update(struct drm_connector *connector)\r\n{\r\nstruct drm_display_mode *mode;\r\nstruct drm_display_mode *pmode, *pt;\r\nint found_it;\r\nlist_for_each_entry_safe(pmode, pt, &connector->probed_modes,\r\nhead) {\r\nfound_it = 0;\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nif (drm_mode_equal(pmode, mode)) {\r\nfound_it = 1;\r\nmode->status = pmode->status;\r\nmode->type |= pmode->type;\r\nlist_del(&pmode->head);\r\ndrm_mode_destroy(connector->dev, pmode);\r\nbreak;\r\n}\r\n}\r\nif (!found_it) {\r\nlist_move_tail(&pmode->head, &connector->modes);\r\n}\r\n}\r\n}\r\nbool drm_mode_parse_command_line_for_connector(const char *mode_option,\r\nstruct drm_connector *connector,\r\nstruct drm_cmdline_mode *mode)\r\n{\r\nconst char *name;\r\nunsigned int namelen;\r\nbool res_specified = false, bpp_specified = false, refresh_specified = false;\r\nunsigned int xres = 0, yres = 0, bpp = 32, refresh = 0;\r\nbool yres_specified = false, cvt = false, rb = false;\r\nbool interlace = false, margins = false, was_digit = false;\r\nint i;\r\nenum drm_connector_force force = DRM_FORCE_UNSPECIFIED;\r\n#ifdef CONFIG_FB\r\nif (!mode_option)\r\nmode_option = fb_mode_option;\r\n#endif\r\nif (!mode_option) {\r\nmode->specified = false;\r\nreturn false;\r\n}\r\nname = mode_option;\r\nnamelen = strlen(name);\r\nfor (i = namelen-1; i >= 0; i--) {\r\nswitch (name[i]) {\r\ncase '@':\r\nif (!refresh_specified && !bpp_specified &&\r\n!yres_specified && !cvt && !rb && was_digit) {\r\nrefresh = simple_strtol(&name[i+1], NULL, 10);\r\nrefresh_specified = true;\r\nwas_digit = false;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase '-':\r\nif (!bpp_specified && !yres_specified && !cvt &&\r\n!rb && was_digit) {\r\nbpp = simple_strtol(&name[i+1], NULL, 10);\r\nbpp_specified = true;\r\nwas_digit = false;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase 'x':\r\nif (!yres_specified && was_digit) {\r\nyres = simple_strtol(&name[i+1], NULL, 10);\r\nyres_specified = true;\r\nwas_digit = false;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase '0' ... '9':\r\nwas_digit = true;\r\nbreak;\r\ncase 'M':\r\nif (yres_specified || cvt || was_digit)\r\ngoto done;\r\ncvt = true;\r\nbreak;\r\ncase 'R':\r\nif (yres_specified || cvt || rb || was_digit)\r\ngoto done;\r\nrb = true;\r\nbreak;\r\ncase 'm':\r\nif (cvt || yres_specified || was_digit)\r\ngoto done;\r\nmargins = true;\r\nbreak;\r\ncase 'i':\r\nif (cvt || yres_specified || was_digit)\r\ngoto done;\r\ninterlace = true;\r\nbreak;\r\ncase 'e':\r\nif (yres_specified || bpp_specified || refresh_specified ||\r\nwas_digit || (force != DRM_FORCE_UNSPECIFIED))\r\ngoto done;\r\nforce = DRM_FORCE_ON;\r\nbreak;\r\ncase 'D':\r\nif (yres_specified || bpp_specified || refresh_specified ||\r\nwas_digit || (force != DRM_FORCE_UNSPECIFIED))\r\ngoto done;\r\nif ((connector->connector_type != DRM_MODE_CONNECTOR_DVII) &&\r\n(connector->connector_type != DRM_MODE_CONNECTOR_HDMIB))\r\nforce = DRM_FORCE_ON;\r\nelse\r\nforce = DRM_FORCE_ON_DIGITAL;\r\nbreak;\r\ncase 'd':\r\nif (yres_specified || bpp_specified || refresh_specified ||\r\nwas_digit || (force != DRM_FORCE_UNSPECIFIED))\r\ngoto done;\r\nforce = DRM_FORCE_OFF;\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\n}\r\nif (i < 0 && yres_specified) {\r\nchar *ch;\r\nxres = simple_strtol(name, &ch, 10);\r\nif ((ch != NULL) && (*ch == 'x'))\r\nres_specified = true;\r\nelse\r\ni = ch - name;\r\n} else if (!yres_specified && was_digit) {\r\ni = 0;\r\n}\r\ndone:\r\nif (i >= 0) {\r\nprintk(KERN_WARNING\r\n"parse error at position %i in video mode '%s'\n",\r\ni, name);\r\nmode->specified = false;\r\nreturn false;\r\n}\r\nif (res_specified) {\r\nmode->specified = true;\r\nmode->xres = xres;\r\nmode->yres = yres;\r\n}\r\nif (refresh_specified) {\r\nmode->refresh_specified = true;\r\nmode->refresh = refresh;\r\n}\r\nif (bpp_specified) {\r\nmode->bpp_specified = true;\r\nmode->bpp = bpp;\r\n}\r\nmode->rb = rb;\r\nmode->cvt = cvt;\r\nmode->interlace = interlace;\r\nmode->margins = margins;\r\nmode->force = force;\r\nreturn true;\r\n}\r\nstruct drm_display_mode *\r\ndrm_mode_create_from_cmdline_mode(struct drm_device *dev,\r\nstruct drm_cmdline_mode *cmd)\r\n{\r\nstruct drm_display_mode *mode;\r\nif (cmd->cvt)\r\nmode = drm_cvt_mode(dev,\r\ncmd->xres, cmd->yres,\r\ncmd->refresh_specified ? cmd->refresh : 60,\r\ncmd->rb, cmd->interlace,\r\ncmd->margins);\r\nelse\r\nmode = drm_gtf_mode(dev,\r\ncmd->xres, cmd->yres,\r\ncmd->refresh_specified ? cmd->refresh : 60,\r\ncmd->interlace,\r\ncmd->margins);\r\nif (!mode)\r\nreturn NULL;\r\ndrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\r\nreturn mode;\r\n}
