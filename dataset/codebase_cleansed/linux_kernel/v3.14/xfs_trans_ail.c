STATIC void\r\nxfs_ail_check(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nxfs_log_item_t *prev_lip;\r\nif (list_empty(&ailp->xa_ail))\r\nreturn;\r\nASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\r\nprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\r\nif (&prev_lip->li_ail != &ailp->xa_ail)\r\nASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\r\nprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\r\nif (&prev_lip->li_ail != &ailp->xa_ail)\r\nASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\r\n}\r\nstatic xfs_log_item_t *\r\nxfs_ail_max(\r\nstruct xfs_ail *ailp)\r\n{\r\nif (list_empty(&ailp->xa_ail))\r\nreturn NULL;\r\nreturn list_entry(ailp->xa_ail.prev, xfs_log_item_t, li_ail);\r\n}\r\nstatic xfs_log_item_t *\r\nxfs_ail_next(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nif (lip->li_ail.next == &ailp->xa_ail)\r\nreturn NULL;\r\nreturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\r\n}\r\nxfs_lsn_t\r\nxfs_ail_min_lsn(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t lsn = 0;\r\nxfs_log_item_t *lip;\r\nspin_lock(&ailp->xa_lock);\r\nlip = xfs_ail_min(ailp);\r\nif (lip)\r\nlsn = lip->li_lsn;\r\nspin_unlock(&ailp->xa_lock);\r\nreturn lsn;\r\n}\r\nstatic xfs_lsn_t\r\nxfs_ail_max_lsn(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t lsn = 0;\r\nxfs_log_item_t *lip;\r\nspin_lock(&ailp->xa_lock);\r\nlip = xfs_ail_max(ailp);\r\nif (lip)\r\nlsn = lip->li_lsn;\r\nspin_unlock(&ailp->xa_lock);\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_trans_ail_cursor_init(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\ncur->item = NULL;\r\nlist_add_tail(&cur->list, &ailp->xa_cursors);\r\n}\r\nstruct xfs_log_item *\r\nxfs_trans_ail_cursor_next(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\nstruct xfs_log_item *lip = cur->item;\r\nif ((__psint_t)lip & 1)\r\nlip = xfs_ail_min(ailp);\r\nif (lip)\r\ncur->item = xfs_ail_next(ailp, lip);\r\nreturn lip;\r\n}\r\nvoid\r\nxfs_trans_ail_cursor_done(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur)\r\n{\r\ncur->item = NULL;\r\nlist_del_init(&cur->list);\r\n}\r\nSTATIC void\r\nxfs_trans_ail_cursor_clear(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_ail_cursor *cur;\r\nlist_for_each_entry(cur, &ailp->xa_cursors, list) {\r\nif (cur->item == lip)\r\ncur->item = (struct xfs_log_item *)\r\n((__psint_t)cur->item | 1);\r\n}\r\n}\r\nxfs_log_item_t *\r\nxfs_trans_ail_cursor_first(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nxfs_trans_ail_cursor_init(ailp, cur);\r\nif (lsn == 0) {\r\nlip = xfs_ail_min(ailp);\r\ngoto out;\r\n}\r\nlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\r\nif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\r\ngoto out;\r\n}\r\nreturn NULL;\r\nout:\r\nif (lip)\r\ncur->item = xfs_ail_next(ailp, lip);\r\nreturn lip;\r\n}\r\nstatic struct xfs_log_item *\r\n__xfs_trans_ail_cursor_last(\r\nstruct xfs_ail *ailp,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\r\nif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\r\nreturn lip;\r\n}\r\nreturn NULL;\r\n}\r\nstruct xfs_log_item *\r\nxfs_trans_ail_cursor_last(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nxfs_lsn_t lsn)\r\n{\r\nxfs_trans_ail_cursor_init(ailp, cur);\r\ncur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\r\nreturn cur->item;\r\n}\r\nstatic void\r\nxfs_ail_splice(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nstruct list_head *list,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_log_item *lip;\r\nASSERT(!list_empty(list));\r\nlip = cur ? cur->item : NULL;\r\nif (!lip || (__psint_t) lip & 1)\r\nlip = __xfs_trans_ail_cursor_last(ailp, lsn);\r\nif (cur)\r\ncur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\r\nif (lip)\r\nlist_splice(list, &lip->li_ail);\r\nelse\r\nlist_splice(list, &ailp->xa_ail);\r\n}\r\nstatic void\r\nxfs_ail_delete(\r\nstruct xfs_ail *ailp,\r\nxfs_log_item_t *lip)\r\n{\r\nxfs_ail_check(ailp, lip);\r\nlist_del(&lip->li_ail);\r\nxfs_trans_ail_cursor_clear(ailp, lip);\r\n}\r\nstatic long\r\nxfsaild_push(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_mount_t *mp = ailp->xa_mount;\r\nstruct xfs_ail_cursor cur;\r\nxfs_log_item_t *lip;\r\nxfs_lsn_t lsn;\r\nxfs_lsn_t target;\r\nlong tout;\r\nint stuck = 0;\r\nint flushing = 0;\r\nint count = 0;\r\nif (ailp->xa_log_flush && ailp->xa_last_pushed_lsn == 0 &&\r\n(!list_empty_careful(&ailp->xa_buf_list) ||\r\nxfs_ail_min_lsn(ailp))) {\r\nailp->xa_log_flush = 0;\r\nXFS_STATS_INC(xs_push_ail_flush);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\n}\r\nspin_lock(&ailp->xa_lock);\r\nsmp_rmb();\r\ntarget = ailp->xa_target;\r\nailp->xa_target_prev = target;\r\nlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\r\nif (!lip) {\r\nxfs_trans_ail_cursor_done(ailp, &cur);\r\nspin_unlock(&ailp->xa_lock);\r\ngoto out_done;\r\n}\r\nXFS_STATS_INC(xs_push_ail);\r\nlsn = lip->li_lsn;\r\nwhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\r\nint lock_result;\r\nlock_result = lip->li_ops->iop_push(lip, &ailp->xa_buf_list);\r\nswitch (lock_result) {\r\ncase XFS_ITEM_SUCCESS:\r\nXFS_STATS_INC(xs_push_ail_success);\r\ntrace_xfs_ail_push(lip);\r\nailp->xa_last_pushed_lsn = lsn;\r\nbreak;\r\ncase XFS_ITEM_FLUSHING:\r\nXFS_STATS_INC(xs_push_ail_flushing);\r\ntrace_xfs_ail_flushing(lip);\r\nflushing++;\r\nailp->xa_last_pushed_lsn = lsn;\r\nbreak;\r\ncase XFS_ITEM_PINNED:\r\nXFS_STATS_INC(xs_push_ail_pinned);\r\ntrace_xfs_ail_pinned(lip);\r\nstuck++;\r\nailp->xa_log_flush++;\r\nbreak;\r\ncase XFS_ITEM_LOCKED:\r\nXFS_STATS_INC(xs_push_ail_locked);\r\ntrace_xfs_ail_locked(lip);\r\nstuck++;\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nbreak;\r\n}\r\ncount++;\r\nif (stuck > 100)\r\nbreak;\r\nlip = xfs_trans_ail_cursor_next(ailp, &cur);\r\nif (lip == NULL)\r\nbreak;\r\nlsn = lip->li_lsn;\r\n}\r\nxfs_trans_ail_cursor_done(ailp, &cur);\r\nspin_unlock(&ailp->xa_lock);\r\nif (xfs_buf_delwri_submit_nowait(&ailp->xa_buf_list))\r\nailp->xa_log_flush++;\r\nif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\r\nout_done:\r\ntout = 50;\r\nailp->xa_last_pushed_lsn = 0;\r\n} else if (((stuck + flushing) * 100) / count > 90) {\r\ntout = 20;\r\nailp->xa_last_pushed_lsn = 0;\r\n} else {\r\ntout = 10;\r\n}\r\nreturn tout;\r\n}\r\nstatic int\r\nxfsaild(\r\nvoid *data)\r\n{\r\nstruct xfs_ail *ailp = data;\r\nlong tout = 0;\r\ncurrent->flags |= PF_MEMALLOC;\r\nwhile (!kthread_should_stop()) {\r\nif (tout && tout <= 20)\r\n__set_current_state(TASK_KILLABLE);\r\nelse\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock(&ailp->xa_lock);\r\nsmp_rmb();\r\nif (!xfs_ail_min(ailp) &&\r\nailp->xa_target == ailp->xa_target_prev) {\r\nspin_unlock(&ailp->xa_lock);\r\nschedule();\r\ntout = 0;\r\ncontinue;\r\n}\r\nspin_unlock(&ailp->xa_lock);\r\nif (tout)\r\nschedule_timeout(msecs_to_jiffies(tout));\r\n__set_current_state(TASK_RUNNING);\r\ntry_to_freeze();\r\ntout = xfsaild_push(ailp);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_ail_push(\r\nstruct xfs_ail *ailp,\r\nxfs_lsn_t threshold_lsn)\r\n{\r\nxfs_log_item_t *lip;\r\nlip = xfs_ail_min(ailp);\r\nif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\r\nXFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\r\nreturn;\r\nsmp_wmb();\r\nxfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\r\nsmp_wmb();\r\nwake_up_process(ailp->xa_task);\r\n}\r\nvoid\r\nxfs_ail_push_all(\r\nstruct xfs_ail *ailp)\r\n{\r\nxfs_lsn_t threshold_lsn = xfs_ail_max_lsn(ailp);\r\nif (threshold_lsn)\r\nxfs_ail_push(ailp, threshold_lsn);\r\n}\r\nvoid\r\nxfs_ail_push_all_sync(\r\nstruct xfs_ail *ailp)\r\n{\r\nstruct xfs_log_item *lip;\r\nDEFINE_WAIT(wait);\r\nspin_lock(&ailp->xa_lock);\r\nwhile ((lip = xfs_ail_max(ailp)) != NULL) {\r\nprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\r\nailp->xa_target = lip->li_lsn;\r\nwake_up_process(ailp->xa_task);\r\nspin_unlock(&ailp->xa_lock);\r\nschedule();\r\nspin_lock(&ailp->xa_lock);\r\n}\r\nspin_unlock(&ailp->xa_lock);\r\nfinish_wait(&ailp->xa_empty, &wait);\r\n}\r\nvoid\r\nxfs_trans_ail_update_bulk(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_ail_cursor *cur,\r\nstruct xfs_log_item **log_items,\r\nint nr_items,\r\nxfs_lsn_t lsn) __releases(ailp->xa_lock)\r\n{\r\nxfs_log_item_t *mlip;\r\nint mlip_changed = 0;\r\nint i;\r\nLIST_HEAD(tmp);\r\nASSERT(nr_items > 0);\r\nmlip = xfs_ail_min(ailp);\r\nfor (i = 0; i < nr_items; i++) {\r\nstruct xfs_log_item *lip = log_items[i];\r\nif (lip->li_flags & XFS_LI_IN_AIL) {\r\nif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\r\ncontinue;\r\ntrace_xfs_ail_move(lip, lip->li_lsn, lsn);\r\nxfs_ail_delete(ailp, lip);\r\nif (mlip == lip)\r\nmlip_changed = 1;\r\n} else {\r\nlip->li_flags |= XFS_LI_IN_AIL;\r\ntrace_xfs_ail_insert(lip, 0, lsn);\r\n}\r\nlip->li_lsn = lsn;\r\nlist_add(&lip->li_ail, &tmp);\r\n}\r\nif (!list_empty(&tmp))\r\nxfs_ail_splice(ailp, cur, &tmp, lsn);\r\nif (mlip_changed) {\r\nif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\r\nxlog_assign_tail_lsn_locked(ailp->xa_mount);\r\nspin_unlock(&ailp->xa_lock);\r\nxfs_log_space_wake(ailp->xa_mount);\r\n} else {\r\nspin_unlock(&ailp->xa_lock);\r\n}\r\n}\r\nvoid\r\nxfs_trans_ail_delete_bulk(\r\nstruct xfs_ail *ailp,\r\nstruct xfs_log_item **log_items,\r\nint nr_items,\r\nint shutdown_type) __releases(ailp->xa_lock)\r\n{\r\nxfs_log_item_t *mlip;\r\nint mlip_changed = 0;\r\nint i;\r\nmlip = xfs_ail_min(ailp);\r\nfor (i = 0; i < nr_items; i++) {\r\nstruct xfs_log_item *lip = log_items[i];\r\nif (!(lip->li_flags & XFS_LI_IN_AIL)) {\r\nstruct xfs_mount *mp = ailp->xa_mount;\r\nspin_unlock(&ailp->xa_lock);\r\nif (!XFS_FORCED_SHUTDOWN(mp)) {\r\nxfs_alert_tag(mp, XFS_PTAG_AILDELETE,\r\n"%s: attempting to delete a log item that is not in the AIL",\r\n__func__);\r\nxfs_force_shutdown(mp, shutdown_type);\r\n}\r\nreturn;\r\n}\r\ntrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\r\nxfs_ail_delete(ailp, lip);\r\nlip->li_flags &= ~XFS_LI_IN_AIL;\r\nlip->li_lsn = 0;\r\nif (mlip == lip)\r\nmlip_changed = 1;\r\n}\r\nif (mlip_changed) {\r\nif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\r\nxlog_assign_tail_lsn_locked(ailp->xa_mount);\r\nif (list_empty(&ailp->xa_ail))\r\nwake_up_all(&ailp->xa_empty);\r\nspin_unlock(&ailp->xa_lock);\r\nxfs_log_space_wake(ailp->xa_mount);\r\n} else {\r\nspin_unlock(&ailp->xa_lock);\r\n}\r\n}\r\nint\r\nxfs_trans_ail_init(\r\nxfs_mount_t *mp)\r\n{\r\nstruct xfs_ail *ailp;\r\nailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\r\nif (!ailp)\r\nreturn ENOMEM;\r\nailp->xa_mount = mp;\r\nINIT_LIST_HEAD(&ailp->xa_ail);\r\nINIT_LIST_HEAD(&ailp->xa_cursors);\r\nspin_lock_init(&ailp->xa_lock);\r\nINIT_LIST_HEAD(&ailp->xa_buf_list);\r\ninit_waitqueue_head(&ailp->xa_empty);\r\nailp->xa_task = kthread_run(xfsaild, ailp, "xfsaild/%s",\r\nailp->xa_mount->m_fsname);\r\nif (IS_ERR(ailp->xa_task))\r\ngoto out_free_ailp;\r\nmp->m_ail = ailp;\r\nreturn 0;\r\nout_free_ailp:\r\nkmem_free(ailp);\r\nreturn ENOMEM;\r\n}\r\nvoid\r\nxfs_trans_ail_destroy(\r\nxfs_mount_t *mp)\r\n{\r\nstruct xfs_ail *ailp = mp->m_ail;\r\nkthread_stop(ailp->xa_task);\r\nkmem_free(ailp);\r\n}
