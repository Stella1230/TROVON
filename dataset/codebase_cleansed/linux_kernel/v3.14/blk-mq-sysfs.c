static void blk_mq_sysfs_release(struct kobject *kobj)\r\n{\r\n}\r\nstatic ssize_t blk_mq_sysfs_show(struct kobject *kobj, struct attribute *attr,\r\nchar *page)\r\n{\r\nstruct blk_mq_ctx_sysfs_entry *entry;\r\nstruct blk_mq_ctx *ctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_ctx_sysfs_entry, attr);\r\nctx = container_of(kobj, struct blk_mq_ctx, kobj);\r\nq = ctx->queue;\r\nif (!entry->show)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->show(ctx, page);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_sysfs_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *page, size_t length)\r\n{\r\nstruct blk_mq_ctx_sysfs_entry *entry;\r\nstruct blk_mq_ctx *ctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_ctx_sysfs_entry, attr);\r\nctx = container_of(kobj, struct blk_mq_ctx, kobj);\r\nq = ctx->queue;\r\nif (!entry->store)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->store(ctx, page, length);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_show(struct kobject *kobj,\r\nstruct attribute *attr, char *page)\r\n{\r\nstruct blk_mq_hw_ctx_sysfs_entry *entry;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_hw_ctx_sysfs_entry, attr);\r\nhctx = container_of(kobj, struct blk_mq_hw_ctx, kobj);\r\nq = hctx->queue;\r\nif (!entry->show)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->show(hctx, page);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *page,\r\nsize_t length)\r\n{\r\nstruct blk_mq_hw_ctx_sysfs_entry *entry;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct request_queue *q;\r\nssize_t res;\r\nentry = container_of(attr, struct blk_mq_hw_ctx_sysfs_entry, attr);\r\nhctx = container_of(kobj, struct blk_mq_hw_ctx, kobj);\r\nq = hctx->queue;\r\nif (!entry->store)\r\nreturn -EIO;\r\nres = -ENOENT;\r\nmutex_lock(&q->sysfs_lock);\r\nif (!blk_queue_dying(q))\r\nres = entry->store(hctx, page, length);\r\nmutex_unlock(&q->sysfs_lock);\r\nreturn res;\r\n}\r\nstatic ssize_t blk_mq_sysfs_dispatched_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu %lu\n", ctx->rq_dispatched[1],\r\nctx->rq_dispatched[0]);\r\n}\r\nstatic ssize_t blk_mq_sysfs_merged_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu\n", ctx->rq_merged);\r\n}\r\nstatic ssize_t blk_mq_sysfs_completed_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu %lu\n", ctx->rq_completed[1],\r\nctx->rq_completed[0]);\r\n}\r\nstatic ssize_t sysfs_list_show(char *page, struct list_head *list, char *msg)\r\n{\r\nchar *start_page = page;\r\nstruct request *rq;\r\npage += sprintf(page, "%s:\n", msg);\r\nlist_for_each_entry(rq, list, queuelist)\r\npage += sprintf(page, "\t%p\n", rq);\r\nreturn page - start_page;\r\n}\r\nstatic ssize_t blk_mq_sysfs_rq_list_show(struct blk_mq_ctx *ctx, char *page)\r\n{\r\nssize_t ret;\r\nspin_lock(&ctx->lock);\r\nret = sysfs_list_show(page, &ctx->rq_list, "CTX pending");\r\nspin_unlock(&ctx->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_queued_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nreturn sprintf(page, "%lu\n", hctx->queued);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_run_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn sprintf(page, "%lu\n", hctx->run);\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_dispatched_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nchar *start_page = page;\r\nint i;\r\npage += sprintf(page, "%8u\t%lu\n", 0U, hctx->dispatched[0]);\r\nfor (i = 1; i < BLK_MQ_MAX_DISPATCH_ORDER; i++) {\r\nunsigned long d = 1U << (i - 1);\r\npage += sprintf(page, "%8lu\t%lu\n", d, hctx->dispatched[i]);\r\n}\r\nreturn page - start_page;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_rq_list_show(struct blk_mq_hw_ctx *hctx,\r\nchar *page)\r\n{\r\nssize_t ret;\r\nspin_lock(&hctx->lock);\r\nret = sysfs_list_show(page, &hctx->dispatch, "HCTX pending");\r\nspin_unlock(&hctx->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_ipi_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nssize_t ret;\r\nspin_lock(&hctx->lock);\r\nret = sprintf(page, "%u\n", !!(hctx->flags & BLK_MQ_F_SHOULD_IPI));\r\nspin_unlock(&hctx->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_ipi_store(struct blk_mq_hw_ctx *hctx,\r\nconst char *page, size_t len)\r\n{\r\nstruct blk_mq_ctx *ctx;\r\nunsigned long ret;\r\nunsigned int i;\r\nif (kstrtoul(page, 10, &ret)) {\r\npr_err("blk-mq-sysfs: invalid input '%s'\n", page);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&hctx->lock);\r\nif (ret)\r\nhctx->flags |= BLK_MQ_F_SHOULD_IPI;\r\nelse\r\nhctx->flags &= ~BLK_MQ_F_SHOULD_IPI;\r\nspin_unlock(&hctx->lock);\r\nhctx_for_each_ctx(hctx, ctx, i)\r\nctx->ipi_redirect = !!ret;\r\nreturn len;\r\n}\r\nstatic ssize_t blk_mq_hw_sysfs_tags_show(struct blk_mq_hw_ctx *hctx, char *page)\r\n{\r\nreturn blk_mq_tag_sysfs_show(hctx->tags, page);\r\n}\r\nvoid blk_mq_unregister_disk(struct gendisk *disk)\r\n{\r\nstruct request_queue *q = disk->queue;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct blk_mq_ctx *ctx;\r\nint i, j;\r\nqueue_for_each_hw_ctx(q, hctx, i) {\r\nhctx_for_each_ctx(hctx, ctx, j) {\r\nkobject_del(&ctx->kobj);\r\nkobject_put(&ctx->kobj);\r\n}\r\nkobject_del(&hctx->kobj);\r\nkobject_put(&hctx->kobj);\r\n}\r\nkobject_uevent(&q->mq_kobj, KOBJ_REMOVE);\r\nkobject_del(&q->mq_kobj);\r\nkobject_put(&q->mq_kobj);\r\nkobject_put(&disk_to_dev(disk)->kobj);\r\n}\r\nint blk_mq_register_disk(struct gendisk *disk)\r\n{\r\nstruct device *dev = disk_to_dev(disk);\r\nstruct request_queue *q = disk->queue;\r\nstruct blk_mq_hw_ctx *hctx;\r\nstruct blk_mq_ctx *ctx;\r\nint ret, i, j;\r\nkobject_init(&q->mq_kobj, &blk_mq_ktype);\r\nret = kobject_add(&q->mq_kobj, kobject_get(&dev->kobj), "%s", "mq");\r\nif (ret < 0)\r\nreturn ret;\r\nkobject_uevent(&q->mq_kobj, KOBJ_ADD);\r\nqueue_for_each_hw_ctx(q, hctx, i) {\r\nkobject_init(&hctx->kobj, &blk_mq_hw_ktype);\r\nret = kobject_add(&hctx->kobj, &q->mq_kobj, "%u", i);\r\nif (ret)\r\nbreak;\r\nif (!hctx->nr_ctx)\r\ncontinue;\r\nhctx_for_each_ctx(hctx, ctx, j) {\r\nkobject_init(&ctx->kobj, &blk_mq_ctx_ktype);\r\nret = kobject_add(&ctx->kobj, &hctx->kobj, "cpu%u", ctx->cpu);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nif (ret) {\r\nblk_mq_unregister_disk(disk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
