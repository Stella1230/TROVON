static int param_set_axis(const char *val, const struct kernel_param *kp)\r\n{\r\nint ret = param_set_int(val, kp);\r\nif (!ret) {\r\nint val = *(int *)kp->arg;\r\nif (val < 0)\r\nval = -val;\r\nif (!val || val > 3)\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic s16 lis3lv02d_read_8(struct lis3lv02d *lis3, int reg)\r\n{\r\ns8 lo;\r\nif (lis3->read(lis3, reg, &lo) < 0)\r\nreturn 0;\r\nreturn lo;\r\n}\r\nstatic s16 lis3lv02d_read_12(struct lis3lv02d *lis3, int reg)\r\n{\r\nu8 lo, hi;\r\nlis3->read(lis3, reg - 1, &lo);\r\nlis3->read(lis3, reg, &hi);\r\nreturn (s16)((hi << 8) | lo);\r\n}\r\nstatic s16 lis331dlh_read_data(struct lis3lv02d *lis3, int reg)\r\n{\r\nu8 lo, hi;\r\nint v;\r\nlis3->read(lis3, reg - 1, &lo);\r\nlis3->read(lis3, reg, &hi);\r\nv = (int) ((hi << 8) | lo);\r\nreturn (s16) v >> lis3->shift_adj;\r\n}\r\nstatic inline int lis3lv02d_get_axis(s8 axis, int hw_values[3])\r\n{\r\nif (axis > 0)\r\nreturn hw_values[axis - 1];\r\nelse\r\nreturn -hw_values[-axis - 1];\r\n}\r\nstatic void lis3lv02d_get_xyz(struct lis3lv02d *lis3, int *x, int *y, int *z)\r\n{\r\nint position[3];\r\nint i;\r\nif (lis3->blkread) {\r\nif (lis3->whoami == WAI_12B) {\r\nu16 data[3];\r\nlis3->blkread(lis3, OUTX_L, 6, (u8 *)data);\r\nfor (i = 0; i < 3; i++)\r\nposition[i] = (s16)le16_to_cpu(data[i]);\r\n} else {\r\nu8 data[5];\r\nlis3->blkread(lis3, OUTX, 5, data);\r\nfor (i = 0; i < 3; i++)\r\nposition[i] = (s8)data[i * 2];\r\n}\r\n} else {\r\nposition[0] = lis3->read_data(lis3, OUTX);\r\nposition[1] = lis3->read_data(lis3, OUTY);\r\nposition[2] = lis3->read_data(lis3, OUTZ);\r\n}\r\nfor (i = 0; i < 3; i++)\r\nposition[i] = (position[i] * lis3->scale) / LIS3_ACCURACY;\r\n*x = lis3lv02d_get_axis(lis3->ac.x, position);\r\n*y = lis3lv02d_get_axis(lis3->ac.y, position);\r\n*z = lis3lv02d_get_axis(lis3->ac.z, position);\r\n}\r\nstatic int lis3lv02d_get_odr(struct lis3lv02d *lis3)\r\n{\r\nu8 ctrl;\r\nint shift;\r\nlis3->read(lis3, CTRL_REG1, &ctrl);\r\nctrl &= lis3->odr_mask;\r\nshift = ffs(lis3->odr_mask) - 1;\r\nreturn lis3->odrs[(ctrl >> shift)];\r\n}\r\nstatic int lis3lv02d_get_pwron_wait(struct lis3lv02d *lis3)\r\n{\r\nint div = lis3lv02d_get_odr(lis3);\r\nif (WARN_ONCE(div == 0, "device returned spurious data"))\r\nreturn -ENXIO;\r\nmsleep(lis3->pwron_delay / div);\r\nreturn 0;\r\n}\r\nstatic int lis3lv02d_set_odr(struct lis3lv02d *lis3, int rate)\r\n{\r\nu8 ctrl;\r\nint i, len, shift;\r\nif (!rate)\r\nreturn -EINVAL;\r\nlis3->read(lis3, CTRL_REG1, &ctrl);\r\nctrl &= ~lis3->odr_mask;\r\nlen = 1 << hweight_long(lis3->odr_mask);\r\nshift = ffs(lis3->odr_mask) - 1;\r\nfor (i = 0; i < len; i++)\r\nif (lis3->odrs[i] == rate) {\r\nlis3->write(lis3, CTRL_REG1,\r\nctrl | (i << shift));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int lis3lv02d_selftest(struct lis3lv02d *lis3, s16 results[3])\r\n{\r\nu8 ctlreg, reg;\r\ns16 x, y, z;\r\nu8 selftest;\r\nint ret;\r\nu8 ctrl_reg_data;\r\nunsigned char irq_cfg;\r\nmutex_lock(&lis3->mutex);\r\nirq_cfg = lis3->irq_cfg;\r\nif (lis3->whoami == WAI_8B) {\r\nlis3->data_ready_count[IRQ_LINE0] = 0;\r\nlis3->data_ready_count[IRQ_LINE1] = 0;\r\natomic_inc(&lis3->wake_thread);\r\nlis3->irq_cfg = LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY;\r\nlis3->read(lis3, CTRL_REG3, &ctrl_reg_data);\r\nlis3->write(lis3, CTRL_REG3, (ctrl_reg_data &\r\n~(LIS3_IRQ1_MASK | LIS3_IRQ2_MASK)) |\r\n(LIS3_IRQ1_DATA_READY | LIS3_IRQ2_DATA_READY));\r\n}\r\nif ((lis3->whoami == WAI_3DC) || (lis3->whoami == WAI_3DLH)) {\r\nctlreg = CTRL_REG4;\r\nselftest = CTRL4_ST0;\r\n} else {\r\nctlreg = CTRL_REG1;\r\nif (lis3->whoami == WAI_12B)\r\nselftest = CTRL1_ST;\r\nelse\r\nselftest = CTRL1_STP;\r\n}\r\nlis3->read(lis3, ctlreg, &reg);\r\nlis3->write(lis3, ctlreg, (reg | selftest));\r\nret = lis3lv02d_get_pwron_wait(lis3);\r\nif (ret)\r\ngoto fail;\r\nx = lis3->read_data(lis3, OUTX);\r\ny = lis3->read_data(lis3, OUTY);\r\nz = lis3->read_data(lis3, OUTZ);\r\nlis3->write(lis3, ctlreg, reg);\r\nret = lis3lv02d_get_pwron_wait(lis3);\r\nif (ret)\r\ngoto fail;\r\nresults[0] = x - lis3->read_data(lis3, OUTX);\r\nresults[1] = y - lis3->read_data(lis3, OUTY);\r\nresults[2] = z - lis3->read_data(lis3, OUTZ);\r\nret = 0;\r\nif (lis3->whoami == WAI_8B) {\r\natomic_dec(&lis3->wake_thread);\r\nlis3->write(lis3, CTRL_REG3, ctrl_reg_data);\r\nlis3->irq_cfg = irq_cfg;\r\nif ((irq_cfg & LIS3_IRQ1_MASK) &&\r\nlis3->data_ready_count[IRQ_LINE0] < 2) {\r\nret = SELFTEST_IRQ;\r\ngoto fail;\r\n}\r\nif ((irq_cfg & LIS3_IRQ2_MASK) &&\r\nlis3->data_ready_count[IRQ_LINE1] < 2) {\r\nret = SELFTEST_IRQ;\r\ngoto fail;\r\n}\r\n}\r\nif (lis3->pdata) {\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nif ((results[i] < lis3->pdata->st_min_limits[i]) ||\r\n(results[i] > lis3->pdata->st_max_limits[i])) {\r\nret = SELFTEST_FAIL;\r\ngoto fail;\r\n}\r\n}\r\n}\r\nfail:\r\nmutex_unlock(&lis3->mutex);\r\nreturn ret;\r\n}\r\nstatic inline void lis3_context_save(struct lis3lv02d *lis3)\r\n{\r\nint i;\r\nfor (i = 0; i < lis3->regs_size; i++)\r\nlis3->read(lis3, lis3->regs[i], &lis3->reg_cache[i]);\r\nlis3->regs_stored = true;\r\n}\r\nstatic inline void lis3_context_restore(struct lis3lv02d *lis3)\r\n{\r\nint i;\r\nif (lis3->regs_stored)\r\nfor (i = 0; i < lis3->regs_size; i++)\r\nlis3->write(lis3, lis3->regs[i], lis3->reg_cache[i]);\r\n}\r\nvoid lis3lv02d_poweroff(struct lis3lv02d *lis3)\r\n{\r\nif (lis3->reg_ctrl)\r\nlis3_context_save(lis3);\r\nlis3->write(lis3, CTRL_REG1, 0x00);\r\nif (lis3->reg_ctrl)\r\nlis3->reg_ctrl(lis3, LIS3_REG_OFF);\r\n}\r\nint lis3lv02d_poweron(struct lis3lv02d *lis3)\r\n{\r\nint err;\r\nu8 reg;\r\nlis3->init(lis3);\r\nif (lis3->pdata) {\r\nlis3->read(lis3, CTRL_REG2, &reg);\r\nif (lis3->whoami == WAI_12B)\r\nreg |= CTRL2_BDU | CTRL2_BOOT;\r\nelse if (lis3->whoami == WAI_3DLH)\r\nreg |= CTRL2_BOOT_3DLH;\r\nelse\r\nreg |= CTRL2_BOOT_8B;\r\nlis3->write(lis3, CTRL_REG2, reg);\r\nif (lis3->whoami == WAI_3DLH) {\r\nlis3->read(lis3, CTRL_REG4, &reg);\r\nreg |= CTRL4_BDU;\r\nlis3->write(lis3, CTRL_REG4, reg);\r\n}\r\n}\r\nerr = lis3lv02d_get_pwron_wait(lis3);\r\nif (err)\r\nreturn err;\r\nif (lis3->reg_ctrl)\r\nlis3_context_restore(lis3);\r\nreturn 0;\r\n}\r\nstatic void lis3lv02d_joystick_poll(struct input_polled_dev *pidev)\r\n{\r\nstruct lis3lv02d *lis3 = pidev->private;\r\nint x, y, z;\r\nmutex_lock(&lis3->mutex);\r\nlis3lv02d_get_xyz(lis3, &x, &y, &z);\r\ninput_report_abs(pidev->input, ABS_X, x);\r\ninput_report_abs(pidev->input, ABS_Y, y);\r\ninput_report_abs(pidev->input, ABS_Z, z);\r\ninput_sync(pidev->input);\r\nmutex_unlock(&lis3->mutex);\r\n}\r\nstatic void lis3lv02d_joystick_open(struct input_polled_dev *pidev)\r\n{\r\nstruct lis3lv02d *lis3 = pidev->private;\r\nif (lis3->pm_dev)\r\npm_runtime_get_sync(lis3->pm_dev);\r\nif (lis3->pdata && lis3->whoami == WAI_8B && lis3->idev)\r\natomic_set(&lis3->wake_thread, 1);\r\nlis3lv02d_joystick_poll(pidev);\r\n}\r\nstatic void lis3lv02d_joystick_close(struct input_polled_dev *pidev)\r\n{\r\nstruct lis3lv02d *lis3 = pidev->private;\r\natomic_set(&lis3->wake_thread, 0);\r\nif (lis3->pm_dev)\r\npm_runtime_put(lis3->pm_dev);\r\n}\r\nstatic irqreturn_t lis302dl_interrupt(int irq, void *data)\r\n{\r\nstruct lis3lv02d *lis3 = data;\r\nif (!test_bit(0, &lis3->misc_opened))\r\ngoto out;\r\natomic_inc(&lis3->count);\r\nwake_up_interruptible(&lis3->misc_wait);\r\nkill_fasync(&lis3->async_queue, SIGIO, POLL_IN);\r\nout:\r\nif (atomic_read(&lis3->wake_thread))\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void lis302dl_interrupt_handle_click(struct lis3lv02d *lis3)\r\n{\r\nstruct input_dev *dev = lis3->idev->input;\r\nu8 click_src;\r\nmutex_lock(&lis3->mutex);\r\nlis3->read(lis3, CLICK_SRC, &click_src);\r\nif (click_src & CLICK_SINGLE_X) {\r\ninput_report_key(dev, lis3->mapped_btns[0], 1);\r\ninput_report_key(dev, lis3->mapped_btns[0], 0);\r\n}\r\nif (click_src & CLICK_SINGLE_Y) {\r\ninput_report_key(dev, lis3->mapped_btns[1], 1);\r\ninput_report_key(dev, lis3->mapped_btns[1], 0);\r\n}\r\nif (click_src & CLICK_SINGLE_Z) {\r\ninput_report_key(dev, lis3->mapped_btns[2], 1);\r\ninput_report_key(dev, lis3->mapped_btns[2], 0);\r\n}\r\ninput_sync(dev);\r\nmutex_unlock(&lis3->mutex);\r\n}\r\nstatic inline void lis302dl_data_ready(struct lis3lv02d *lis3, int index)\r\n{\r\nint dummy;\r\nlis3lv02d_get_xyz(lis3, &dummy, &dummy, &dummy);\r\nlis3->data_ready_count[index]++;\r\n}\r\nstatic irqreturn_t lis302dl_interrupt_thread1_8b(int irq, void *data)\r\n{\r\nstruct lis3lv02d *lis3 = data;\r\nu8 irq_cfg = lis3->irq_cfg & LIS3_IRQ1_MASK;\r\nif (irq_cfg == LIS3_IRQ1_CLICK)\r\nlis302dl_interrupt_handle_click(lis3);\r\nelse if (unlikely(irq_cfg == LIS3_IRQ1_DATA_READY))\r\nlis302dl_data_ready(lis3, IRQ_LINE0);\r\nelse\r\nlis3lv02d_joystick_poll(lis3->idev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lis302dl_interrupt_thread2_8b(int irq, void *data)\r\n{\r\nstruct lis3lv02d *lis3 = data;\r\nu8 irq_cfg = lis3->irq_cfg & LIS3_IRQ2_MASK;\r\nif (irq_cfg == LIS3_IRQ2_CLICK)\r\nlis302dl_interrupt_handle_click(lis3);\r\nelse if (unlikely(irq_cfg == LIS3_IRQ2_DATA_READY))\r\nlis302dl_data_ready(lis3, IRQ_LINE1);\r\nelse\r\nlis3lv02d_joystick_poll(lis3->idev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lis3lv02d_misc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct lis3lv02d *lis3 = container_of(file->private_data,\r\nstruct lis3lv02d, miscdev);\r\nif (test_and_set_bit(0, &lis3->misc_opened))\r\nreturn -EBUSY;\r\nif (lis3->pm_dev)\r\npm_runtime_get_sync(lis3->pm_dev);\r\natomic_set(&lis3->count, 0);\r\nreturn 0;\r\n}\r\nstatic int lis3lv02d_misc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct lis3lv02d *lis3 = container_of(file->private_data,\r\nstruct lis3lv02d, miscdev);\r\nclear_bit(0, &lis3->misc_opened);\r\nif (lis3->pm_dev)\r\npm_runtime_put(lis3->pm_dev);\r\nreturn 0;\r\n}\r\nstatic ssize_t lis3lv02d_misc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct lis3lv02d *lis3 = container_of(file->private_data,\r\nstruct lis3lv02d, miscdev);\r\nDECLARE_WAITQUEUE(wait, current);\r\nu32 data;\r\nunsigned char byte_data;\r\nssize_t retval = 1;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nadd_wait_queue(&lis3->misc_wait, &wait);\r\nwhile (true) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ndata = atomic_xchg(&lis3->count, 0);\r\nif (data)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\ngoto out;\r\n}\r\nschedule();\r\n}\r\nif (data < 255)\r\nbyte_data = data;\r\nelse\r\nbyte_data = 255;\r\nset_current_state(TASK_RUNNING);\r\nif (copy_to_user(buf, &byte_data, sizeof(byte_data)))\r\nretval = -EFAULT;\r\nout:\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&lis3->misc_wait, &wait);\r\nreturn retval;\r\n}\r\nstatic unsigned int lis3lv02d_misc_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct lis3lv02d *lis3 = container_of(file->private_data,\r\nstruct lis3lv02d, miscdev);\r\npoll_wait(file, &lis3->misc_wait, wait);\r\nif (atomic_read(&lis3->count))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int lis3lv02d_misc_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct lis3lv02d *lis3 = container_of(file->private_data,\r\nstruct lis3lv02d, miscdev);\r\nreturn fasync_helper(fd, file, on, &lis3->async_queue);\r\n}\r\nint lis3lv02d_joystick_enable(struct lis3lv02d *lis3)\r\n{\r\nstruct input_dev *input_dev;\r\nint err;\r\nint max_val, fuzz, flat;\r\nint btns[] = {BTN_X, BTN_Y, BTN_Z};\r\nif (lis3->idev)\r\nreturn -EINVAL;\r\nlis3->idev = input_allocate_polled_device();\r\nif (!lis3->idev)\r\nreturn -ENOMEM;\r\nlis3->idev->poll = lis3lv02d_joystick_poll;\r\nlis3->idev->open = lis3lv02d_joystick_open;\r\nlis3->idev->close = lis3lv02d_joystick_close;\r\nlis3->idev->poll_interval = MDPS_POLL_INTERVAL;\r\nlis3->idev->poll_interval_min = MDPS_POLL_MIN;\r\nlis3->idev->poll_interval_max = MDPS_POLL_MAX;\r\nlis3->idev->private = lis3;\r\ninput_dev = lis3->idev->input;\r\ninput_dev->name = "ST LIS3LV02DL Accelerometer";\r\ninput_dev->phys = DRIVER_NAME "/input0";\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->id.vendor = 0;\r\ninput_dev->dev.parent = &lis3->pdev->dev;\r\nset_bit(EV_ABS, input_dev->evbit);\r\nmax_val = (lis3->mdps_max_val * lis3->scale) / LIS3_ACCURACY;\r\nif (lis3->whoami == WAI_12B) {\r\nfuzz = LIS3_DEFAULT_FUZZ_12B;\r\nflat = LIS3_DEFAULT_FLAT_12B;\r\n} else {\r\nfuzz = LIS3_DEFAULT_FUZZ_8B;\r\nflat = LIS3_DEFAULT_FLAT_8B;\r\n}\r\nfuzz = (fuzz * lis3->scale) / LIS3_ACCURACY;\r\nflat = (flat * lis3->scale) / LIS3_ACCURACY;\r\ninput_set_abs_params(input_dev, ABS_X, -max_val, max_val, fuzz, flat);\r\ninput_set_abs_params(input_dev, ABS_Y, -max_val, max_val, fuzz, flat);\r\ninput_set_abs_params(input_dev, ABS_Z, -max_val, max_val, fuzz, flat);\r\nlis3->mapped_btns[0] = lis3lv02d_get_axis(abs(lis3->ac.x), btns);\r\nlis3->mapped_btns[1] = lis3lv02d_get_axis(abs(lis3->ac.y), btns);\r\nlis3->mapped_btns[2] = lis3lv02d_get_axis(abs(lis3->ac.z), btns);\r\nerr = input_register_polled_device(lis3->idev);\r\nif (err) {\r\ninput_free_polled_device(lis3->idev);\r\nlis3->idev = NULL;\r\n}\r\nreturn err;\r\n}\r\nvoid lis3lv02d_joystick_disable(struct lis3lv02d *lis3)\r\n{\r\nif (lis3->irq)\r\nfree_irq(lis3->irq, lis3);\r\nif (lis3->pdata && lis3->pdata->irq2)\r\nfree_irq(lis3->pdata->irq2, lis3);\r\nif (!lis3->idev)\r\nreturn;\r\nif (lis3->irq)\r\nmisc_deregister(&lis3->miscdev);\r\ninput_unregister_polled_device(lis3->idev);\r\ninput_free_polled_device(lis3->idev);\r\nlis3->idev = NULL;\r\n}\r\nstatic void lis3lv02d_sysfs_poweron(struct lis3lv02d *lis3)\r\n{\r\nif (lis3->pm_dev) {\r\npm_runtime_get_sync(lis3->pm_dev);\r\npm_runtime_put_noidle(lis3->pm_dev);\r\npm_schedule_suspend(lis3->pm_dev, LIS3_SYSFS_POWERDOWN_DELAY);\r\n}\r\n}\r\nstatic ssize_t lis3lv02d_selftest_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\r\ns16 values[3];\r\nstatic const char ok[] = "OK";\r\nstatic const char fail[] = "FAIL";\r\nstatic const char irq[] = "FAIL_IRQ";\r\nconst char *res;\r\nlis3lv02d_sysfs_poweron(lis3);\r\nswitch (lis3lv02d_selftest(lis3, values)) {\r\ncase SELFTEST_FAIL:\r\nres = fail;\r\nbreak;\r\ncase SELFTEST_IRQ:\r\nres = irq;\r\nbreak;\r\ncase SELFTEST_OK:\r\ndefault:\r\nres = ok;\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s %d %d %d\n", res,\r\nvalues[0], values[1], values[2]);\r\n}\r\nstatic ssize_t lis3lv02d_position_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\r\nint x, y, z;\r\nlis3lv02d_sysfs_poweron(lis3);\r\nmutex_lock(&lis3->mutex);\r\nlis3lv02d_get_xyz(lis3, &x, &y, &z);\r\nmutex_unlock(&lis3->mutex);\r\nreturn sprintf(buf, "(%d,%d,%d)\n", x, y, z);\r\n}\r\nstatic ssize_t lis3lv02d_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\r\nlis3lv02d_sysfs_poweron(lis3);\r\nreturn sprintf(buf, "%d\n", lis3lv02d_get_odr(lis3));\r\n}\r\nstatic ssize_t lis3lv02d_rate_set(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct lis3lv02d *lis3 = dev_get_drvdata(dev);\r\nunsigned long rate;\r\nint ret;\r\nret = kstrtoul(buf, 0, &rate);\r\nif (ret)\r\nreturn ret;\r\nlis3lv02d_sysfs_poweron(lis3);\r\nif (lis3lv02d_set_odr(lis3, rate))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int lis3lv02d_add_fs(struct lis3lv02d *lis3)\r\n{\r\nlis3->pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);\r\nif (IS_ERR(lis3->pdev))\r\nreturn PTR_ERR(lis3->pdev);\r\nplatform_set_drvdata(lis3->pdev, lis3);\r\nreturn sysfs_create_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);\r\n}\r\nint lis3lv02d_remove_fs(struct lis3lv02d *lis3)\r\n{\r\nsysfs_remove_group(&lis3->pdev->dev.kobj, &lis3lv02d_attribute_group);\r\nplatform_device_unregister(lis3->pdev);\r\nif (lis3->pm_dev) {\r\npm_runtime_barrier(lis3->pm_dev);\r\nif (!pm_runtime_suspended(lis3->pm_dev))\r\nlis3lv02d_poweroff(lis3);\r\npm_runtime_disable(lis3->pm_dev);\r\npm_runtime_set_suspended(lis3->pm_dev);\r\n}\r\nkfree(lis3->reg_cache);\r\nreturn 0;\r\n}\r\nstatic void lis3lv02d_8b_configure(struct lis3lv02d *lis3,\r\nstruct lis3lv02d_platform_data *p)\r\n{\r\nint err;\r\nint ctrl2 = p->hipass_ctrl;\r\nif (p->click_flags) {\r\nlis3->write(lis3, CLICK_CFG, p->click_flags);\r\nlis3->write(lis3, CLICK_TIMELIMIT, p->click_time_limit);\r\nlis3->write(lis3, CLICK_LATENCY, p->click_latency);\r\nlis3->write(lis3, CLICK_WINDOW, p->click_window);\r\nlis3->write(lis3, CLICK_THSZ, p->click_thresh_z & 0xf);\r\nlis3->write(lis3, CLICK_THSY_X,\r\n(p->click_thresh_x & 0xf) |\r\n(p->click_thresh_y << 4));\r\nif (lis3->idev) {\r\nstruct input_dev *input_dev = lis3->idev->input;\r\ninput_set_capability(input_dev, EV_KEY, BTN_X);\r\ninput_set_capability(input_dev, EV_KEY, BTN_Y);\r\ninput_set_capability(input_dev, EV_KEY, BTN_Z);\r\n}\r\n}\r\nif (p->wakeup_flags) {\r\nlis3->write(lis3, FF_WU_CFG_1, p->wakeup_flags);\r\nlis3->write(lis3, FF_WU_THS_1, p->wakeup_thresh & 0x7f);\r\nlis3->write(lis3, FF_WU_DURATION_1, p->duration1 + 1);\r\nctrl2 ^= HP_FF_WU1;\r\n}\r\nif (p->wakeup_flags2) {\r\nlis3->write(lis3, FF_WU_CFG_2, p->wakeup_flags2);\r\nlis3->write(lis3, FF_WU_THS_2, p->wakeup_thresh2 & 0x7f);\r\nlis3->write(lis3, FF_WU_DURATION_2, p->duration2 + 1);\r\nctrl2 ^= HP_FF_WU2;\r\n}\r\nlis3->write(lis3, CTRL_REG2, ctrl2);\r\nif (p->irq2) {\r\nerr = request_threaded_irq(p->irq2,\r\nNULL,\r\nlis302dl_interrupt_thread2_8b,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT |\r\n(p->irq_flags2 & IRQF_TRIGGER_MASK),\r\nDRIVER_NAME, lis3);\r\nif (err < 0)\r\npr_err("No second IRQ. Limited functionality\n");\r\n}\r\n}\r\nint lis3lv02d_init_dt(struct lis3lv02d *lis3)\r\n{\r\nstruct lis3lv02d_platform_data *pdata;\r\nstruct device_node *np = lis3->of_node;\r\nu32 val;\r\nif (!lis3->of_node)\r\nreturn 0;\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "st,click-single-x", NULL))\r\npdata->click_flags |= LIS3_CLICK_SINGLE_X;\r\nif (of_get_property(np, "st,click-double-x", NULL))\r\npdata->click_flags |= LIS3_CLICK_DOUBLE_X;\r\nif (of_get_property(np, "st,click-single-y", NULL))\r\npdata->click_flags |= LIS3_CLICK_SINGLE_Y;\r\nif (of_get_property(np, "st,click-double-y", NULL))\r\npdata->click_flags |= LIS3_CLICK_DOUBLE_Y;\r\nif (of_get_property(np, "st,click-single-z", NULL))\r\npdata->click_flags |= LIS3_CLICK_SINGLE_Z;\r\nif (of_get_property(np, "st,click-double-z", NULL))\r\npdata->click_flags |= LIS3_CLICK_DOUBLE_Z;\r\nif (!of_property_read_u32(np, "st,click-threshold-x", &val))\r\npdata->click_thresh_x = val;\r\nif (!of_property_read_u32(np, "st,click-threshold-y", &val))\r\npdata->click_thresh_y = val;\r\nif (!of_property_read_u32(np, "st,click-threshold-z", &val))\r\npdata->click_thresh_z = val;\r\nif (!of_property_read_u32(np, "st,click-time-limit", &val))\r\npdata->click_time_limit = val;\r\nif (!of_property_read_u32(np, "st,click-latency", &val))\r\npdata->click_latency = val;\r\nif (!of_property_read_u32(np, "st,click-window", &val))\r\npdata->click_window = val;\r\nif (of_get_property(np, "st,irq1-disable", NULL))\r\npdata->irq_cfg |= LIS3_IRQ1_DISABLE;\r\nif (of_get_property(np, "st,irq1-ff-wu-1", NULL))\r\npdata->irq_cfg |= LIS3_IRQ1_FF_WU_1;\r\nif (of_get_property(np, "st,irq1-ff-wu-2", NULL))\r\npdata->irq_cfg |= LIS3_IRQ1_FF_WU_2;\r\nif (of_get_property(np, "st,irq1-data-ready", NULL))\r\npdata->irq_cfg |= LIS3_IRQ1_DATA_READY;\r\nif (of_get_property(np, "st,irq1-click", NULL))\r\npdata->irq_cfg |= LIS3_IRQ1_CLICK;\r\nif (of_get_property(np, "st,irq2-disable", NULL))\r\npdata->irq_cfg |= LIS3_IRQ2_DISABLE;\r\nif (of_get_property(np, "st,irq2-ff-wu-1", NULL))\r\npdata->irq_cfg |= LIS3_IRQ2_FF_WU_1;\r\nif (of_get_property(np, "st,irq2-ff-wu-2", NULL))\r\npdata->irq_cfg |= LIS3_IRQ2_FF_WU_2;\r\nif (of_get_property(np, "st,irq2-data-ready", NULL))\r\npdata->irq_cfg |= LIS3_IRQ2_DATA_READY;\r\nif (of_get_property(np, "st,irq2-click", NULL))\r\npdata->irq_cfg |= LIS3_IRQ2_CLICK;\r\nif (of_get_property(np, "st,irq-open-drain", NULL))\r\npdata->irq_cfg |= LIS3_IRQ_OPEN_DRAIN;\r\nif (of_get_property(np, "st,irq-active-low", NULL))\r\npdata->irq_cfg |= LIS3_IRQ_ACTIVE_LOW;\r\nif (!of_property_read_u32(np, "st,wu-duration-1", &val))\r\npdata->duration1 = val;\r\nif (!of_property_read_u32(np, "st,wu-duration-2", &val))\r\npdata->duration2 = val;\r\nif (of_get_property(np, "st,wakeup-x-lo", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_X_LO;\r\nif (of_get_property(np, "st,wakeup-x-hi", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_X_HI;\r\nif (of_get_property(np, "st,wakeup-y-lo", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_Y_LO;\r\nif (of_get_property(np, "st,wakeup-y-hi", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_Y_HI;\r\nif (of_get_property(np, "st,wakeup-z-lo", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_Z_LO;\r\nif (of_get_property(np, "st,wakeup-z-hi", NULL))\r\npdata->wakeup_flags |= LIS3_WAKEUP_Z_HI;\r\nif (!of_property_read_u32(np, "st,highpass-cutoff-hz", &val)) {\r\nswitch (val) {\r\ncase 1:\r\npdata->hipass_ctrl = LIS3_HIPASS_CUTFF_1HZ;\r\nbreak;\r\ncase 2:\r\npdata->hipass_ctrl = LIS3_HIPASS_CUTFF_2HZ;\r\nbreak;\r\ncase 4:\r\npdata->hipass_ctrl = LIS3_HIPASS_CUTFF_4HZ;\r\nbreak;\r\ncase 8:\r\npdata->hipass_ctrl = LIS3_HIPASS_CUTFF_8HZ;\r\nbreak;\r\n}\r\n}\r\nif (of_get_property(np, "st,hipass1-disable", NULL))\r\npdata->hipass_ctrl |= LIS3_HIPASS1_DISABLE;\r\nif (of_get_property(np, "st,hipass2-disable", NULL))\r\npdata->hipass_ctrl |= LIS3_HIPASS2_DISABLE;\r\nif (of_get_property(np, "st,axis-x", &val))\r\npdata->axis_x = val;\r\nif (of_get_property(np, "st,axis-y", &val))\r\npdata->axis_y = val;\r\nif (of_get_property(np, "st,axis-z", &val))\r\npdata->axis_z = val;\r\nif (of_get_property(np, "st,default-rate", NULL))\r\npdata->default_rate = val;\r\nif (of_get_property(np, "st,min-limit-x", &val))\r\npdata->st_min_limits[0] = val;\r\nif (of_get_property(np, "st,min-limit-y", &val))\r\npdata->st_min_limits[1] = val;\r\nif (of_get_property(np, "st,min-limit-z", &val))\r\npdata->st_min_limits[2] = val;\r\nif (of_get_property(np, "st,max-limit-x", &val))\r\npdata->st_max_limits[0] = val;\r\nif (of_get_property(np, "st,max-limit-y", &val))\r\npdata->st_max_limits[1] = val;\r\nif (of_get_property(np, "st,max-limit-z", &val))\r\npdata->st_max_limits[2] = val;\r\nlis3->pdata = pdata;\r\nreturn 0;\r\n}\r\nint lis3lv02d_init_dt(struct lis3lv02d *lis3)\r\n{\r\nreturn 0;\r\n}\r\nint lis3lv02d_init_device(struct lis3lv02d *lis3)\r\n{\r\nint err;\r\nirq_handler_t thread_fn;\r\nint irq_flags = 0;\r\nlis3->whoami = lis3lv02d_read_8(lis3, WHO_AM_I);\r\nswitch (lis3->whoami) {\r\ncase WAI_12B:\r\npr_info("12 bits sensor found\n");\r\nlis3->read_data = lis3lv02d_read_12;\r\nlis3->mdps_max_val = 2048;\r\nlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_12B;\r\nlis3->odrs = lis3_12_rates;\r\nlis3->odr_mask = CTRL1_DF0 | CTRL1_DF1;\r\nlis3->scale = LIS3_SENSITIVITY_12B;\r\nlis3->regs = lis3_wai12_regs;\r\nlis3->regs_size = ARRAY_SIZE(lis3_wai12_regs);\r\nbreak;\r\ncase WAI_8B:\r\npr_info("8 bits sensor found\n");\r\nlis3->read_data = lis3lv02d_read_8;\r\nlis3->mdps_max_val = 128;\r\nlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\r\nlis3->odrs = lis3_8_rates;\r\nlis3->odr_mask = CTRL1_DR;\r\nlis3->scale = LIS3_SENSITIVITY_8B;\r\nlis3->regs = lis3_wai8_regs;\r\nlis3->regs_size = ARRAY_SIZE(lis3_wai8_regs);\r\nbreak;\r\ncase WAI_3DC:\r\npr_info("8 bits 3DC sensor found\n");\r\nlis3->read_data = lis3lv02d_read_8;\r\nlis3->mdps_max_val = 128;\r\nlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\r\nlis3->odrs = lis3_3dc_rates;\r\nlis3->odr_mask = CTRL1_ODR0|CTRL1_ODR1|CTRL1_ODR2|CTRL1_ODR3;\r\nlis3->scale = LIS3_SENSITIVITY_8B;\r\nbreak;\r\ncase WAI_3DLH:\r\npr_info("16 bits lis331dlh sensor found\n");\r\nlis3->read_data = lis331dlh_read_data;\r\nlis3->mdps_max_val = 2048;\r\nlis3->shift_adj = SHIFT_ADJ_2G;\r\nlis3->pwron_delay = LIS3_PWRON_DELAY_WAI_8B;\r\nlis3->odrs = lis3_3dlh_rates;\r\nlis3->odr_mask = CTRL1_DR0 | CTRL1_DR1;\r\nlis3->scale = LIS3DLH_SENSITIVITY_2G;\r\nbreak;\r\ndefault:\r\npr_err("unknown sensor type 0x%X\n", lis3->whoami);\r\nreturn -EINVAL;\r\n}\r\nlis3->reg_cache = kzalloc(max(sizeof(lis3_wai8_regs),\r\nsizeof(lis3_wai12_regs)), GFP_KERNEL);\r\nif (lis3->reg_cache == NULL) {\r\nprintk(KERN_ERR DRIVER_NAME "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&lis3->mutex);\r\natomic_set(&lis3->wake_thread, 0);\r\nlis3lv02d_add_fs(lis3);\r\nerr = lis3lv02d_poweron(lis3);\r\nif (err) {\r\nlis3lv02d_remove_fs(lis3);\r\nreturn err;\r\n}\r\nif (lis3->pm_dev) {\r\npm_runtime_set_active(lis3->pm_dev);\r\npm_runtime_enable(lis3->pm_dev);\r\n}\r\nif (lis3lv02d_joystick_enable(lis3))\r\npr_err("joystick initialization failed\n");\r\nif (lis3->pdata) {\r\nstruct lis3lv02d_platform_data *p = lis3->pdata;\r\nif (lis3->whoami == WAI_8B)\r\nlis3lv02d_8b_configure(lis3, p);\r\nirq_flags = p->irq_flags1 & IRQF_TRIGGER_MASK;\r\nlis3->irq_cfg = p->irq_cfg;\r\nif (p->irq_cfg)\r\nlis3->write(lis3, CTRL_REG3, p->irq_cfg);\r\nif (p->default_rate)\r\nlis3lv02d_set_odr(lis3, p->default_rate);\r\n}\r\nif (!lis3->irq) {\r\npr_debug("No IRQ. Disabling /dev/freefall\n");\r\ngoto out;\r\n}\r\nif (lis3->pdata && lis3->whoami == WAI_8B)\r\nthread_fn = lis302dl_interrupt_thread1_8b;\r\nelse\r\nthread_fn = NULL;\r\nerr = request_threaded_irq(lis3->irq, lis302dl_interrupt,\r\nthread_fn,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT |\r\nirq_flags,\r\nDRIVER_NAME, lis3);\r\nif (err < 0) {\r\npr_err("Cannot get IRQ\n");\r\ngoto out;\r\n}\r\nlis3->miscdev.minor = MISC_DYNAMIC_MINOR;\r\nlis3->miscdev.name = "freefall";\r\nlis3->miscdev.fops = &lis3lv02d_misc_fops;\r\nif (misc_register(&lis3->miscdev))\r\npr_err("misc_register failed\n");\r\nout:\r\nreturn 0;\r\n}
