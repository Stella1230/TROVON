static inline void __sc1200wdt_read_data(unsigned char index,\r\nunsigned char *data)\r\n{\r\noutb_p(index, PMIR);\r\n*data = inb(PMDR);\r\n}\r\nstatic void sc1200wdt_read_data(unsigned char index, unsigned char *data)\r\n{\r\nspin_lock(&sc1200wdt_lock);\r\n__sc1200wdt_read_data(index, data);\r\nspin_unlock(&sc1200wdt_lock);\r\n}\r\nstatic inline void __sc1200wdt_write_data(unsigned char index,\r\nunsigned char data)\r\n{\r\noutb_p(index, PMIR);\r\noutb(data, PMDR);\r\n}\r\nstatic inline void sc1200wdt_write_data(unsigned char index,\r\nunsigned char data)\r\n{\r\nspin_lock(&sc1200wdt_lock);\r\n__sc1200wdt_write_data(index, data);\r\nspin_unlock(&sc1200wdt_lock);\r\n}\r\nstatic void sc1200wdt_start(void)\r\n{\r\nunsigned char reg;\r\nspin_lock(&sc1200wdt_lock);\r\n__sc1200wdt_read_data(WDCF, &reg);\r\nreg |= (KBC_IRQ | MSE_IRQ | UART1_IRQ | UART2_IRQ);\r\n__sc1200wdt_write_data(WDCF, reg);\r\n__sc1200wdt_write_data(WDTO, timeout);\r\nspin_unlock(&sc1200wdt_lock);\r\n}\r\nstatic void sc1200wdt_stop(void)\r\n{\r\nsc1200wdt_write_data(WDTO, 0);\r\n}\r\nstatic inline int sc1200wdt_status(void)\r\n{\r\nunsigned char ret;\r\nsc1200wdt_read_data(WDST, &ret);\r\nreturn (ret & 0x01) ? 0 : WDIOF_KEEPALIVEPING;\r\n}\r\nstatic int sc1200wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &open_flag))\r\nreturn -EBUSY;\r\nif (timeout > MAX_TIMEOUT)\r\ntimeout = MAX_TIMEOUT;\r\nsc1200wdt_start();\r\npr_info("Watchdog enabled, timeout = %d min(s)", timeout);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic long sc1200wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint new_timeout;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 0,\r\n.identity = "PC87307/PC97307",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase WDIOC_GETSTATUS:\r\nreturn put_user(sc1200wdt_status(), p);\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint options, retval = -EINVAL;\r\nif (get_user(options, p))\r\nreturn -EFAULT;\r\nif (options & WDIOS_DISABLECARD) {\r\nsc1200wdt_stop();\r\nretval = 0;\r\n}\r\nif (options & WDIOS_ENABLECARD) {\r\nsc1200wdt_start();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nsc1200wdt_write_data(WDTO, timeout);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nnew_timeout /= 60;\r\nif (new_timeout < 0 || new_timeout > MAX_TIMEOUT)\r\nreturn -EINVAL;\r\ntimeout = new_timeout;\r\nsc1200wdt_write_data(WDTO, timeout);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout * 60, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int sc1200wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42) {\r\nsc1200wdt_stop();\r\npr_info("Watchdog disabled\n");\r\n} else {\r\nsc1200wdt_write_data(WDTO, timeout);\r\npr_crit("Unexpected close!, timeout = %d min(s)\n", timeout);\r\n}\r\nclear_bit(0, &open_flag);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t sc1200wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nsc1200wdt_write_data(WDTO, timeout);\r\nreturn len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sc1200wdt_notify_sys(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nsc1200wdt_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init sc1200wdt_probe(void)\r\n{\r\nunsigned char reg;\r\nsc1200wdt_read_data(PMC3, &reg);\r\nreg &= 0x0f;\r\nreturn (reg == 0x0e) ? 0 : -ENODEV;\r\n}\r\nstatic int scl200wdt_pnp_probe(struct pnp_dev *dev,\r\nconst struct pnp_device_id *dev_id)\r\n{\r\nif (wdt_dev || !isapnp)\r\nreturn -EBUSY;\r\nwdt_dev = dev;\r\nio = pnp_port_start(wdt_dev, 0);\r\nio_len = pnp_port_len(wdt_dev, 0);\r\nif (!request_region(io, io_len, SC1200_MODULE_NAME)) {\r\npr_err("Unable to register IO port %#x\n", io);\r\nreturn -EBUSY;\r\n}\r\npr_info("PnP device found at io port %#x/%d\n", io, io_len);\r\nreturn 0;\r\n}\r\nstatic void scl200wdt_pnp_remove(struct pnp_dev *dev)\r\n{\r\nif (wdt_dev) {\r\nrelease_region(io, io_len);\r\nwdt_dev = NULL;\r\n}\r\n}\r\nstatic int __init sc1200wdt_init(void)\r\n{\r\nint ret;\r\npr_info("%s\n", SC1200_MODULE_VER);\r\n#if defined CONFIG_PNP\r\nif (isapnp) {\r\nret = pnp_register_driver(&scl200wdt_pnp_driver);\r\nif (ret)\r\ngoto out_clean;\r\n}\r\n#endif\r\nif (io == -1) {\r\npr_err("io parameter must be specified\n");\r\nret = -EINVAL;\r\ngoto out_pnp;\r\n}\r\n#if defined CONFIG_PNP\r\nif (isapnp)\r\npnp_unregister_driver(&scl200wdt_pnp_driver);\r\nisapnp = 0;\r\n#endif\r\nif (!request_region(io, io_len, SC1200_MODULE_NAME)) {\r\npr_err("Unable to register IO port %#x\n", io);\r\nret = -EBUSY;\r\ngoto out_pnp;\r\n}\r\nret = sc1200wdt_probe();\r\nif (ret)\r\ngoto out_io;\r\nret = register_reboot_notifier(&sc1200wdt_notifier);\r\nif (ret) {\r\npr_err("Unable to register reboot notifier err = %d\n", ret);\r\ngoto out_io;\r\n}\r\nret = misc_register(&sc1200wdt_miscdev);\r\nif (ret) {\r\npr_err("Unable to register miscdev on minor %d\n",\r\nWATCHDOG_MINOR);\r\ngoto out_rbt;\r\n}\r\nout_clean:\r\nreturn ret;\r\nout_rbt:\r\nunregister_reboot_notifier(&sc1200wdt_notifier);\r\nout_io:\r\nrelease_region(io, io_len);\r\nout_pnp:\r\n#if defined CONFIG_PNP\r\nif (isapnp)\r\npnp_unregister_driver(&scl200wdt_pnp_driver);\r\n#endif\r\ngoto out_clean;\r\n}\r\nstatic void __exit sc1200wdt_exit(void)\r\n{\r\nmisc_deregister(&sc1200wdt_miscdev);\r\nunregister_reboot_notifier(&sc1200wdt_notifier);\r\n#if defined CONFIG_PNP\r\nif (isapnp)\r\npnp_unregister_driver(&scl200wdt_pnp_driver);\r\nelse\r\n#endif\r\nrelease_region(io, io_len);\r\n}
