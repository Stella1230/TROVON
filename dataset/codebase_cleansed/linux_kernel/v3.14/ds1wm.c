static inline void ds1wm_write_register(struct ds1wm_data *ds1wm_data, u32 reg,\r\nu8 val)\r\n{\r\n__raw_writeb(val, ds1wm_data->map + (reg << ds1wm_data->bus_shift));\r\n}\r\nstatic inline u8 ds1wm_read_register(struct ds1wm_data *ds1wm_data, u32 reg)\r\n{\r\nreturn __raw_readb(ds1wm_data->map + (reg << ds1wm_data->bus_shift));\r\n}\r\nstatic irqreturn_t ds1wm_isr(int isr, void *data)\r\n{\r\nstruct ds1wm_data *ds1wm_data = data;\r\nu8 intr;\r\nu8 inten = ds1wm_read_register(ds1wm_data, DS1WM_INT_EN);\r\nif (!(inten & DS1WM_INTEN_NOT_IAS))\r\nreturn IRQ_NONE;\r\nds1wm_write_register(ds1wm_data,\r\nDS1WM_INT_EN, ds1wm_data->int_en_reg_none);\r\nintr = ds1wm_read_register(ds1wm_data, DS1WM_INT);\r\nds1wm_data->slave_present = (intr & DS1WM_INT_PDR) ? 0 : 1;\r\nif ((intr & DS1WM_INT_TSRE) && ds1wm_data->write_complete) {\r\ninten &= ~DS1WM_INTEN_ETMT;\r\ncomplete(ds1wm_data->write_complete);\r\n}\r\nif (intr & DS1WM_INT_RBF) {\r\nds1wm_data->read_byte = ds1wm_read_register(ds1wm_data,\r\nDS1WM_DATA);\r\ninten &= ~DS1WM_INTEN_ERBF;\r\nif (ds1wm_data->read_complete)\r\ncomplete(ds1wm_data->read_complete);\r\n}\r\nif ((intr & DS1WM_INT_PD) && ds1wm_data->reset_complete) {\r\ninten &= ~DS1WM_INTEN_EPD;\r\ncomplete(ds1wm_data->reset_complete);\r\n}\r\nds1wm_write_register(ds1wm_data, DS1WM_INT_EN, inten);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ds1wm_reset(struct ds1wm_data *ds1wm_data)\r\n{\r\nunsigned long timeleft;\r\nDECLARE_COMPLETION_ONSTACK(reset_done);\r\nds1wm_data->reset_complete = &reset_done;\r\nds1wm_write_register(ds1wm_data, DS1WM_INT_EN, DS1WM_INTEN_EPD |\r\nds1wm_data->int_en_reg_none);\r\nds1wm_write_register(ds1wm_data, DS1WM_CMD, DS1WM_CMD_1W_RESET);\r\ntimeleft = wait_for_completion_timeout(&reset_done, DS1WM_TIMEOUT);\r\nds1wm_data->reset_complete = NULL;\r\nif (!timeleft) {\r\ndev_err(&ds1wm_data->pdev->dev, "reset failed, timed out\n");\r\nreturn 1;\r\n}\r\nif (!ds1wm_data->slave_present) {\r\ndev_dbg(&ds1wm_data->pdev->dev, "reset: no devices found\n");\r\nreturn 1;\r\n}\r\nif (ds1wm_data->reset_recover_delay)\r\nmsleep(ds1wm_data->reset_recover_delay);\r\nreturn 0;\r\n}\r\nstatic int ds1wm_write(struct ds1wm_data *ds1wm_data, u8 data)\r\n{\r\nunsigned long timeleft;\r\nDECLARE_COMPLETION_ONSTACK(write_done);\r\nds1wm_data->write_complete = &write_done;\r\nds1wm_write_register(ds1wm_data, DS1WM_INT_EN,\r\nds1wm_data->int_en_reg_none | DS1WM_INTEN_ETMT);\r\nds1wm_write_register(ds1wm_data, DS1WM_DATA, data);\r\ntimeleft = wait_for_completion_timeout(&write_done, DS1WM_TIMEOUT);\r\nds1wm_data->write_complete = NULL;\r\nif (!timeleft) {\r\ndev_err(&ds1wm_data->pdev->dev, "write failed, timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 ds1wm_read(struct ds1wm_data *ds1wm_data, unsigned char write_data)\r\n{\r\nunsigned long timeleft;\r\nu8 intEnable = DS1WM_INTEN_ERBF | ds1wm_data->int_en_reg_none;\r\nDECLARE_COMPLETION_ONSTACK(read_done);\r\nds1wm_read_register(ds1wm_data, DS1WM_DATA);\r\nds1wm_data->read_complete = &read_done;\r\nds1wm_write_register(ds1wm_data, DS1WM_INT_EN, intEnable);\r\nds1wm_write_register(ds1wm_data, DS1WM_DATA, write_data);\r\ntimeleft = wait_for_completion_timeout(&read_done, DS1WM_TIMEOUT);\r\nds1wm_data->read_complete = NULL;\r\nif (!timeleft) {\r\ndev_err(&ds1wm_data->pdev->dev, "read failed, timed out\n");\r\nds1wm_data->read_error = -ETIMEDOUT;\r\nreturn 0xFF;\r\n}\r\nds1wm_data->read_error = 0;\r\nreturn ds1wm_data->read_byte;\r\n}\r\nstatic int ds1wm_find_divisor(int gclk)\r\n{\r\nint i;\r\nfor (i = ARRAY_SIZE(freq)-1; i >= 0; --i)\r\nif (gclk >= freq[i].freq)\r\nreturn freq[i].divisor;\r\nreturn 0;\r\n}\r\nstatic void ds1wm_up(struct ds1wm_data *ds1wm_data)\r\n{\r\nint divisor;\r\nstruct device *dev = &ds1wm_data->pdev->dev;\r\nstruct ds1wm_driver_data *plat = dev_get_platdata(dev);\r\nif (ds1wm_data->cell->enable)\r\nds1wm_data->cell->enable(ds1wm_data->pdev);\r\ndivisor = ds1wm_find_divisor(plat->clock_rate);\r\ndev_dbg(dev, "found divisor 0x%x for clock %d\n",\r\ndivisor, plat->clock_rate);\r\nif (divisor == 0) {\r\ndev_err(dev, "no suitable divisor for %dHz clock\n",\r\nplat->clock_rate);\r\nreturn;\r\n}\r\nds1wm_write_register(ds1wm_data, DS1WM_CLKDIV, divisor);\r\nmsleep(1);\r\nds1wm_reset(ds1wm_data);\r\n}\r\nstatic void ds1wm_down(struct ds1wm_data *ds1wm_data)\r\n{\r\nds1wm_reset(ds1wm_data);\r\nds1wm_write_register(ds1wm_data, DS1WM_INT_EN,\r\nds1wm_data->int_en_reg_none);\r\nif (ds1wm_data->cell->disable)\r\nds1wm_data->cell->disable(ds1wm_data->pdev);\r\n}\r\nstatic u8 ds1wm_read_byte(void *data)\r\n{\r\nstruct ds1wm_data *ds1wm_data = data;\r\nreturn ds1wm_read(ds1wm_data, 0xff);\r\n}\r\nstatic void ds1wm_write_byte(void *data, u8 byte)\r\n{\r\nstruct ds1wm_data *ds1wm_data = data;\r\nds1wm_write(ds1wm_data, byte);\r\n}\r\nstatic u8 ds1wm_reset_bus(void *data)\r\n{\r\nstruct ds1wm_data *ds1wm_data = data;\r\nds1wm_reset(ds1wm_data);\r\nreturn 0;\r\n}\r\nstatic void ds1wm_search(void *data, struct w1_master *master_dev,\r\nu8 search_type, w1_slave_found_callback slave_found)\r\n{\r\nstruct ds1wm_data *ds1wm_data = data;\r\nint i;\r\nint ms_discrep_bit = -1;\r\nu64 r = 0;\r\nu64 r_prime, d;\r\nunsigned slaves_found = 0;\r\nunsigned int pass = 0;\r\ndev_dbg(&ds1wm_data->pdev->dev, "search begin\n");\r\nwhile (true) {\r\n++pass;\r\nif (pass > 100) {\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"too many attempts (100), search aborted\n");\r\nreturn;\r\n}\r\nmutex_lock(&master_dev->bus_mutex);\r\nif (ds1wm_reset(ds1wm_data)) {\r\nmutex_unlock(&master_dev->bus_mutex);\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d reset error (or no slaves)\n", pass);\r\nbreak;\r\n}\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d r : %0#18llx writing SEARCH_ROM\n", pass, r);\r\nds1wm_write(ds1wm_data, search_type);\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d entering ASM\n", pass);\r\nds1wm_write_register(ds1wm_data, DS1WM_CMD, DS1WM_CMD_SRA);\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d beginning nibble loop\n", pass);\r\nr_prime = 0;\r\nd = 0;\r\nfor (i = 0; i < 16; i++) {\r\nunsigned char resp, _r, _r_prime, _d;\r\n_r = (r >> (4*i)) & 0xf;\r\n_r = ((_r & 0x1) << 1) |\r\n((_r & 0x2) << 2) |\r\n((_r & 0x4) << 3) |\r\n((_r & 0x8) << 4);\r\nresp = ds1wm_read(ds1wm_data, _r);\r\nif (ds1wm_data->read_error) {\r\ndev_err(&ds1wm_data->pdev->dev,\r\n"pass: %d nibble: %d read error\n", pass, i);\r\nbreak;\r\n}\r\n_r_prime = ((resp & 0x02) >> 1) |\r\n((resp & 0x08) >> 2) |\r\n((resp & 0x20) >> 3) |\r\n((resp & 0x80) >> 4);\r\n_d = ((resp & 0x01) >> 0) |\r\n((resp & 0x04) >> 1) |\r\n((resp & 0x10) >> 2) |\r\n((resp & 0x40) >> 3);\r\nr_prime |= (unsigned long long) _r_prime << (i * 4);\r\nd |= (unsigned long long) _d << (i * 4);\r\n}\r\nif (ds1wm_data->read_error) {\r\nmutex_unlock(&master_dev->bus_mutex);\r\ndev_err(&ds1wm_data->pdev->dev,\r\n"pass: %d read error, retrying\n", pass);\r\nbreak;\r\n}\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d r\': %0#18llx d:%0#18llx\n",\r\npass, r_prime, d);\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d nibble loop complete, exiting ASM\n", pass);\r\nds1wm_write_register(ds1wm_data, DS1WM_CMD, ~DS1WM_CMD_SRA);\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d resetting bus\n", pass);\r\nds1wm_reset(ds1wm_data);\r\nmutex_unlock(&master_dev->bus_mutex);\r\nif ((r_prime & ((u64)1 << 63)) && (d & ((u64)1 << 63))) {\r\ndev_err(&ds1wm_data->pdev->dev,\r\n"pass: %d bus error, retrying\n", pass);\r\ncontinue;\r\n}\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d found %0#18llx\n", pass, r_prime);\r\nslave_found(master_dev, r_prime);\r\n++slaves_found;\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d complete, preparing next pass\n", pass);\r\nd &= ~r;\r\nms_discrep_bit = fls64(d) - 1;\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d new d:%0#18llx MS discrep bit:%d\n",\r\npass, d, ms_discrep_bit);\r\nif (ms_discrep_bit == -1)\r\nbreak;\r\nr = (r & ~(~0ull << (ms_discrep_bit))) | 1 << ms_discrep_bit;\r\n}\r\ndev_dbg(&ds1wm_data->pdev->dev,\r\n"pass: %d total: %d search done ms d bit pos: %d\n", pass,\r\nslaves_found, ms_discrep_bit);\r\n}\r\nstatic int ds1wm_probe(struct platform_device *pdev)\r\n{\r\nstruct ds1wm_data *ds1wm_data;\r\nstruct ds1wm_driver_data *plat;\r\nstruct resource *res;\r\nint ret;\r\nif (!pdev)\r\nreturn -ENODEV;\r\nds1wm_data = devm_kzalloc(&pdev->dev, sizeof(*ds1wm_data), GFP_KERNEL);\r\nif (!ds1wm_data)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ds1wm_data);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nds1wm_data->map = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!ds1wm_data->map)\r\nreturn -ENOMEM;\r\nds1wm_data->bus_shift = resource_size(res) >> 3;\r\nds1wm_data->pdev = pdev;\r\nds1wm_data->cell = mfd_get_cell(pdev);\r\nif (!ds1wm_data->cell)\r\nreturn -ENODEV;\r\nplat = dev_get_platdata(&pdev->dev);\r\nif (!plat)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nds1wm_data->irq = res->start;\r\nds1wm_data->int_en_reg_none = (plat->active_high ? DS1WM_INTEN_IAS : 0);\r\nds1wm_data->reset_recover_delay = plat->reset_recover_delay;\r\nif (res->flags & IORESOURCE_IRQ_HIGHEDGE)\r\nirq_set_irq_type(ds1wm_data->irq, IRQ_TYPE_EDGE_RISING);\r\nif (res->flags & IORESOURCE_IRQ_LOWEDGE)\r\nirq_set_irq_type(ds1wm_data->irq, IRQ_TYPE_EDGE_FALLING);\r\nret = devm_request_irq(&pdev->dev, ds1wm_data->irq, ds1wm_isr,\r\nIRQF_SHARED, "ds1wm", ds1wm_data);\r\nif (ret)\r\nreturn ret;\r\nds1wm_up(ds1wm_data);\r\nds1wm_master.data = (void *)ds1wm_data;\r\nret = w1_add_master_device(&ds1wm_master);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nds1wm_down(ds1wm_data);\r\nreturn ret;\r\n}\r\nstatic int ds1wm_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct ds1wm_data *ds1wm_data = platform_get_drvdata(pdev);\r\nds1wm_down(ds1wm_data);\r\nreturn 0;\r\n}\r\nstatic int ds1wm_resume(struct platform_device *pdev)\r\n{\r\nstruct ds1wm_data *ds1wm_data = platform_get_drvdata(pdev);\r\nds1wm_up(ds1wm_data);\r\nreturn 0;\r\n}\r\nstatic int ds1wm_remove(struct platform_device *pdev)\r\n{\r\nstruct ds1wm_data *ds1wm_data = platform_get_drvdata(pdev);\r\nw1_remove_master_device(&ds1wm_master);\r\nds1wm_down(ds1wm_data);\r\nreturn 0;\r\n}\r\nstatic int __init ds1wm_init(void)\r\n{\r\nprintk("DS1WM w1 busmaster driver - (c) 2004 Szabolcs Gyurko\n");\r\nreturn platform_driver_register(&ds1wm_driver);\r\n}\r\nstatic void __exit ds1wm_exit(void)\r\n{\r\nplatform_driver_unregister(&ds1wm_driver);\r\n}
