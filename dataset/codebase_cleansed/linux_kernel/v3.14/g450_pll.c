static inline unsigned int g450_vco2f(unsigned char p, unsigned int fvco) {\r\nreturn (p & 0x40) ? fvco : fvco >> ((p & 3) + 1);\r\n}\r\nstatic inline unsigned int g450_f2vco(unsigned char p, unsigned int fin) {\r\nreturn (p & 0x40) ? fin : fin << ((p & 3) + 1);\r\n}\r\nstatic unsigned int g450_mnp2vco(const struct matrox_fb_info *minfo,\r\nunsigned int mnp)\r\n{\r\nunsigned int m, n;\r\nm = ((mnp >> 16) & 0x0FF) + 1;\r\nn = ((mnp >> 7) & 0x1FE) + 4;\r\nreturn (minfo->features.pll.ref_freq * n + (m >> 1)) / m;\r\n}\r\nunsigned int g450_mnp2f(const struct matrox_fb_info *minfo, unsigned int mnp)\r\n{\r\nreturn g450_vco2f(mnp, g450_mnp2vco(minfo, mnp));\r\n}\r\nstatic inline unsigned int pll_freq_delta(unsigned int f1, unsigned int f2) {\r\nif (f2 < f1) {\r\nf2 = f1 - f2;\r\n} else {\r\nf2 = f2 - f1;\r\n}\r\nreturn f2;\r\n}\r\nstatic unsigned int g450_nextpll(const struct matrox_fb_info *minfo,\r\nconst struct matrox_pll_limits *pi,\r\nunsigned int *fvco, unsigned int mnp)\r\n{\r\nunsigned int m, n, p;\r\nunsigned int tvco = *fvco;\r\nm = (mnp >> 16) & 0xFF;\r\np = mnp & 0xFF;\r\ndo {\r\nif (m == 0 || m == 0xFF) {\r\nif (m == 0) {\r\nif (p & 0x40) {\r\nreturn NO_MORE_MNP;\r\n}\r\nif (p & 3) {\r\np--;\r\n} else {\r\np = 0x40;\r\n}\r\ntvco >>= 1;\r\nif (tvco < pi->vcomin) {\r\nreturn NO_MORE_MNP;\r\n}\r\n*fvco = tvco;\r\n}\r\np &= 0x43;\r\nif (tvco < 550000) {\r\n} else if (tvco < 700000) {\r\np |= 0x08;\r\n} else if (tvco < 1000000) {\r\np |= 0x10;\r\n} else if (tvco < 1150000) {\r\np |= 0x18;\r\n} else {\r\np |= 0x20;\r\n}\r\nm = 9;\r\n} else {\r\nm--;\r\n}\r\nn = ((tvco * (m+1) + minfo->features.pll.ref_freq) / (minfo->features.pll.ref_freq * 2)) - 2;\r\n} while (n < 0x03 || n > 0x7A);\r\nreturn (m << 16) | (n << 8) | p;\r\n}\r\nstatic unsigned int g450_firstpll(const struct matrox_fb_info *minfo,\r\nconst struct matrox_pll_limits *pi,\r\nunsigned int *vco, unsigned int fout)\r\n{\r\nunsigned int p;\r\nunsigned int vcomax;\r\nvcomax = pi->vcomax;\r\nif (fout > (vcomax / 2)) {\r\nif (fout > vcomax) {\r\n*vco = vcomax;\r\n} else {\r\n*vco = fout;\r\n}\r\np = 0x40;\r\n} else {\r\nunsigned int tvco;\r\np = 3;\r\ntvco = g450_f2vco(p, fout);\r\nwhile (p && (tvco > vcomax)) {\r\np--;\r\ntvco >>= 1;\r\n}\r\nif (tvco < pi->vcomin) {\r\ntvco = pi->vcomin;\r\n}\r\n*vco = tvco;\r\n}\r\nreturn g450_nextpll(minfo, pi, vco, 0xFF0000 | p);\r\n}\r\nstatic inline unsigned int g450_setpll(const struct matrox_fb_info *minfo,\r\nunsigned int mnp, unsigned int pll)\r\n{\r\nswitch (pll) {\r\ncase M_PIXEL_PLL_A:\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLAM, mnp >> 16);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLAN, mnp >> 8);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLAP, mnp);\r\nreturn M1064_XPIXPLLSTAT;\r\ncase M_PIXEL_PLL_B:\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLBM, mnp >> 16);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLBN, mnp >> 8);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLBP, mnp);\r\nreturn M1064_XPIXPLLSTAT;\r\ncase M_PIXEL_PLL_C:\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLCM, mnp >> 16);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLCN, mnp >> 8);\r\nmatroxfb_DAC_out(minfo, M1064_XPIXPLLCP, mnp);\r\nreturn M1064_XPIXPLLSTAT;\r\ncase M_SYSTEM_PLL:\r\nmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLM, mnp >> 16);\r\nmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLN, mnp >> 8);\r\nmatroxfb_DAC_out(minfo, DAC1064_XSYSPLLP, mnp);\r\nreturn DAC1064_XSYSPLLSTAT;\r\ncase M_VIDEO_PLL:\r\nmatroxfb_DAC_out(minfo, M1064_XVIDPLLM, mnp >> 16);\r\nmatroxfb_DAC_out(minfo, M1064_XVIDPLLN, mnp >> 8);\r\nmatroxfb_DAC_out(minfo, M1064_XVIDPLLP, mnp);\r\nreturn M1064_XVIDPLLSTAT;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int g450_cmppll(const struct matrox_fb_info *minfo,\r\nunsigned int mnp, unsigned int pll)\r\n{\r\nunsigned char m = mnp >> 16;\r\nunsigned char n = mnp >> 8;\r\nunsigned char p = mnp;\r\nswitch (pll) {\r\ncase M_PIXEL_PLL_A:\r\nreturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLAM) != m ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLAN) != n ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLAP) != p);\r\ncase M_PIXEL_PLL_B:\r\nreturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLBM) != m ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLBN) != n ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLBP) != p);\r\ncase M_PIXEL_PLL_C:\r\nreturn (matroxfb_DAC_in(minfo, M1064_XPIXPLLCM) != m ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLCN) != n ||\r\nmatroxfb_DAC_in(minfo, M1064_XPIXPLLCP) != p);\r\ncase M_SYSTEM_PLL:\r\nreturn (matroxfb_DAC_in(minfo, DAC1064_XSYSPLLM) != m ||\r\nmatroxfb_DAC_in(minfo, DAC1064_XSYSPLLN) != n ||\r\nmatroxfb_DAC_in(minfo, DAC1064_XSYSPLLP) != p);\r\ncase M_VIDEO_PLL:\r\nreturn (matroxfb_DAC_in(minfo, M1064_XVIDPLLM) != m ||\r\nmatroxfb_DAC_in(minfo, M1064_XVIDPLLN) != n ||\r\nmatroxfb_DAC_in(minfo, M1064_XVIDPLLP) != p);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int g450_isplllocked(const struct matrox_fb_info *minfo,\r\nunsigned int regidx)\r\n{\r\nunsigned int j;\r\nfor (j = 0; j < 1000; j++) {\r\nif (matroxfb_DAC_in(minfo, regidx) & 0x40) {\r\nunsigned int r = 0;\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nr += matroxfb_DAC_in(minfo, regidx) & 0x40;\r\n}\r\nreturn r >= (90 * 0x40);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int g450_testpll(const struct matrox_fb_info *minfo, unsigned int mnp,\r\nunsigned int pll)\r\n{\r\nreturn g450_isplllocked(minfo, g450_setpll(minfo, mnp, pll));\r\n}\r\nstatic void updatehwstate_clk(struct matrox_hw_state* hw, unsigned int mnp, unsigned int pll) {\r\nswitch (pll) {\r\ncase M_SYSTEM_PLL:\r\nhw->DACclk[3] = mnp >> 16;\r\nhw->DACclk[4] = mnp >> 8;\r\nhw->DACclk[5] = mnp;\r\nbreak;\r\n}\r\n}\r\nvoid matroxfb_g450_setpll_cond(struct matrox_fb_info *minfo, unsigned int mnp,\r\nunsigned int pll)\r\n{\r\nif (g450_cmppll(minfo, mnp, pll)) {\r\ng450_setpll(minfo, mnp, pll);\r\n}\r\n}\r\nstatic inline unsigned int g450_findworkingpll(struct matrox_fb_info *minfo,\r\nunsigned int pll,\r\nunsigned int *mnparray,\r\nunsigned int mnpcount)\r\n{\r\nunsigned int found = 0;\r\nunsigned int idx;\r\nunsigned int mnpfound = mnparray[0];\r\nfor (idx = 0; idx < mnpcount; idx++) {\r\nunsigned int sarray[3];\r\nunsigned int *sptr;\r\n{\r\nunsigned int mnp;\r\nsptr = sarray;\r\nmnp = mnparray[idx];\r\nif (mnp & 0x38) {\r\n*sptr++ = mnp - 8;\r\n}\r\nif ((mnp & 0x38) != 0x38) {\r\n*sptr++ = mnp + 8;\r\n}\r\n*sptr = mnp;\r\n}\r\nwhile (sptr >= sarray) {\r\nunsigned int mnp = *sptr--;\r\nif (g450_testpll(minfo, mnp - 0x0300, pll) &&\r\ng450_testpll(minfo, mnp + 0x0300, pll) &&\r\ng450_testpll(minfo, mnp - 0x0200, pll) &&\r\ng450_testpll(minfo, mnp + 0x0200, pll) &&\r\ng450_testpll(minfo, mnp - 0x0100, pll) &&\r\ng450_testpll(minfo, mnp + 0x0100, pll)) {\r\nif (g450_testpll(minfo, mnp, pll)) {\r\nreturn mnp;\r\n}\r\n} else if (!found && g450_testpll(minfo, mnp, pll)) {\r\nmnpfound = mnp;\r\nfound = 1;\r\n}\r\n}\r\n}\r\ng450_setpll(minfo, mnpfound, pll);\r\nreturn mnpfound;\r\n}\r\nstatic void g450_addcache(struct matrox_pll_cache* ci, unsigned int mnp_key, unsigned int mnp_value) {\r\nif (++ci->valid > ARRAY_SIZE(ci->data)) {\r\nci->valid = ARRAY_SIZE(ci->data);\r\n}\r\nmemmove(ci->data + 1, ci->data, (ci->valid - 1) * sizeof(*ci->data));\r\nci->data[0].mnp_key = mnp_key & G450_MNP_FREQBITS;\r\nci->data[0].mnp_value = mnp_value;\r\n}\r\nstatic int g450_checkcache(struct matrox_fb_info *minfo,\r\nstruct matrox_pll_cache *ci, unsigned int mnp_key)\r\n{\r\nunsigned int i;\r\nmnp_key &= G450_MNP_FREQBITS;\r\nfor (i = 0; i < ci->valid; i++) {\r\nif (ci->data[i].mnp_key == mnp_key) {\r\nunsigned int mnp;\r\nmnp = ci->data[i].mnp_value;\r\nif (i) {\r\nmemmove(ci->data + 1, ci->data, i * sizeof(*ci->data));\r\nci->data[0].mnp_key = mnp_key;\r\nci->data[0].mnp_value = mnp;\r\n}\r\nreturn mnp;\r\n}\r\n}\r\nreturn NO_MORE_MNP;\r\n}\r\nstatic int __g450_setclk(struct matrox_fb_info *minfo, unsigned int fout,\r\nunsigned int pll, unsigned int *mnparray,\r\nunsigned int *deltaarray)\r\n{\r\nunsigned int mnpcount;\r\nunsigned int pixel_vco;\r\nconst struct matrox_pll_limits* pi;\r\nstruct matrox_pll_cache* ci;\r\npixel_vco = 0;\r\nswitch (pll) {\r\ncase M_PIXEL_PLL_A:\r\ncase M_PIXEL_PLL_B:\r\ncase M_PIXEL_PLL_C:\r\n{\r\nu_int8_t tmp, xpwrctrl;\r\nunsigned long flags;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nxpwrctrl = matroxfb_DAC_in(minfo, M1064_XPWRCTRL);\r\nmatroxfb_DAC_out(minfo, M1064_XPWRCTRL, xpwrctrl & ~M1064_XPWRCTRL_PANELPDN);\r\nmga_outb(M_SEQ_INDEX, M_SEQ1);\r\nmga_outb(M_SEQ_DATA, mga_inb(M_SEQ_DATA) | M_SEQ1_SCROFF);\r\ntmp = matroxfb_DAC_in(minfo, M1064_XPIXCLKCTRL);\r\ntmp |= M1064_XPIXCLKCTRL_DIS;\r\nif (!(tmp & M1064_XPIXCLKCTRL_PLL_UP)) {\r\ntmp |= M1064_XPIXCLKCTRL_PLL_UP;\r\n}\r\nmatroxfb_DAC_out(minfo, M1064_XPIXCLKCTRL, tmp);\r\nif (fout >= minfo->max_pixel_clock_panellink)\r\ntmp = 0;\r\nelse tmp =\r\nM1064_XDVICLKCTRL_DVIDATAPATHSEL |\r\nM1064_XDVICLKCTRL_C1DVICLKSEL |\r\nM1064_XDVICLKCTRL_C1DVICLKEN |\r\nM1064_XDVICLKCTRL_DVILOOPCTL |\r\nM1064_XDVICLKCTRL_P1LOOPBWDTCTL;\r\nmatroxfb_DAC_out(minfo, M1064_XPWRCTRL,\r\nxpwrctrl);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\n{\r\nu_int8_t misc;\r\nmisc = mga_inb(M_MISC_REG_READ) & ~0x0C;\r\nswitch (pll) {\r\ncase M_PIXEL_PLL_A:\r\nbreak;\r\ncase M_PIXEL_PLL_B:\r\nmisc |= 0x04;\r\nbreak;\r\ndefault:\r\nmisc |= 0x0C;\r\nbreak;\r\n}\r\nmga_outb(M_MISC_REG, misc);\r\n}\r\npi = &minfo->limits.pixel;\r\nci = &minfo->cache.pixel;\r\nbreak;\r\ncase M_SYSTEM_PLL:\r\n{\r\nu_int32_t opt;\r\npci_read_config_dword(minfo->pcidev, PCI_OPTION_REG, &opt);\r\nif (!(opt & 0x20)) {\r\npci_write_config_dword(minfo->pcidev, PCI_OPTION_REG, opt | 0x20);\r\n}\r\n}\r\npi = &minfo->limits.system;\r\nci = &minfo->cache.system;\r\nbreak;\r\ncase M_VIDEO_PLL:\r\n{\r\nu_int8_t tmp;\r\nunsigned int mnp;\r\nunsigned long flags;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\ntmp = matroxfb_DAC_in(minfo, M1064_XPWRCTRL);\r\nif (!(tmp & 2)) {\r\nmatroxfb_DAC_out(minfo, M1064_XPWRCTRL, tmp | 2);\r\n}\r\nmnp = matroxfb_DAC_in(minfo, M1064_XPIXPLLCM) << 16;\r\nmnp |= matroxfb_DAC_in(minfo, M1064_XPIXPLLCN) << 8;\r\npixel_vco = g450_mnp2vco(minfo, mnp);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\n}\r\npi = &minfo->limits.video;\r\nci = &minfo->cache.video;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmnpcount = 0;\r\n{\r\nunsigned int mnp;\r\nunsigned int xvco;\r\nfor (mnp = g450_firstpll(minfo, pi, &xvco, fout); mnp != NO_MORE_MNP; mnp = g450_nextpll(minfo, pi, &xvco, mnp)) {\r\nunsigned int idx;\r\nunsigned int vco;\r\nunsigned int delta;\r\nvco = g450_mnp2vco(minfo, mnp);\r\n#if 0\r\nif (pll == M_VIDEO_PLL) {\r\nunsigned int big, small;\r\nif (vco < pixel_vco) {\r\nsmall = vco;\r\nbig = pixel_vco;\r\n} else {\r\nsmall = pixel_vco;\r\nbig = vco;\r\n}\r\nwhile (big > small) {\r\nbig >>= 1;\r\n}\r\nif (big == small) {\r\ncontinue;\r\n}\r\n}\r\n#endif\r\ndelta = pll_freq_delta(fout, g450_vco2f(mnp, vco));\r\nfor (idx = mnpcount; idx > 0; idx--) {\r\nif (delta <= deltaarray[idx-1]) {\r\nif (delta == deltaarray[idx-1]\r\n&& vco != g450_mnp2vco(minfo, mnparray[idx-1])\r\n&& vco < (pi->vcomin * 17 / 16)) {\r\nbreak;\r\n}\r\nmnparray[idx] = mnparray[idx-1];\r\ndeltaarray[idx] = deltaarray[idx-1];\r\n} else {\r\nbreak;\r\n}\r\n}\r\nmnparray[idx] = mnp;\r\ndeltaarray[idx] = delta;\r\nmnpcount++;\r\n}\r\n}\r\nif (!mnpcount) {\r\nreturn -EBUSY;\r\n}\r\n{\r\nunsigned long flags;\r\nunsigned int mnp;\r\nmatroxfb_DAC_lock_irqsave(flags);\r\nmnp = g450_checkcache(minfo, ci, mnparray[0]);\r\nif (mnp != NO_MORE_MNP) {\r\nmatroxfb_g450_setpll_cond(minfo, mnp, pll);\r\n} else {\r\nmnp = g450_findworkingpll(minfo, pll, mnparray, mnpcount);\r\ng450_addcache(ci, mnparray[0], mnp);\r\n}\r\nupdatehwstate_clk(&minfo->hw, mnp, pll);\r\nmatroxfb_DAC_unlock_irqrestore(flags);\r\nreturn mnp;\r\n}\r\n}\r\nint matroxfb_g450_setclk(struct matrox_fb_info *minfo, unsigned int fout,\r\nunsigned int pll)\r\n{\r\nunsigned int* arr;\r\narr = kmalloc(sizeof(*arr) * MNP_TABLE_SIZE * 2, GFP_KERNEL);\r\nif (arr) {\r\nint r;\r\nr = __g450_setclk(minfo, fout, pll, arr, arr + MNP_TABLE_SIZE);\r\nkfree(arr);\r\nreturn r;\r\n}\r\nreturn -ENOMEM;\r\n}
