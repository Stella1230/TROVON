static inline int cl_io_type_is_valid(enum cl_io_type type)\r\n{\r\nreturn CIT_READ <= type && type < CIT_OP_NR;\r\n}\r\nstatic inline int cl_io_is_loopable(const struct cl_io *io)\r\n{\r\nreturn cl_io_type_is_valid(io->ci_type) && io->ci_type != CIT_MISC;\r\n}\r\nint cl_io_is_going(const struct lu_env *env)\r\n{\r\nreturn cl_env_info(env)->clt_current_io != NULL;\r\n}\r\nstatic int cl_io_invariant(const struct cl_io *io)\r\n{\r\nstruct cl_io *up;\r\nup = io->ci_parent;\r\nreturn\r\nergo(io->ci_owned_nr > 0, io->ci_state == CIS_IO_GOING ||\r\n(io->ci_state == CIS_LOCKED && up != NULL));\r\n}\r\nvoid cl_io_fini(const struct lu_env *env, struct cl_io *io)\r\n{\r\nstruct cl_io_slice *slice;\r\nstruct cl_thread_info *info;\r\nLINVRNT(cl_io_type_is_valid(io->ci_type));\r\nLINVRNT(cl_io_invariant(io));\r\nwhile (!list_empty(&io->ci_layers)) {\r\nslice = container_of(io->ci_layers.prev, struct cl_io_slice,\r\ncis_linkage);\r\nlist_del_init(&slice->cis_linkage);\r\nif (slice->cis_iop->op[io->ci_type].cio_fini != NULL)\r\nslice->cis_iop->op[io->ci_type].cio_fini(env, slice);\r\nslice->cis_io = NULL;\r\n}\r\nio->ci_state = CIS_FINI;\r\ninfo = cl_env_info(env);\r\nif (info->clt_current_io == io)\r\ninfo->clt_current_io = NULL;\r\nswitch(io->ci_type) {\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\nbreak;\r\ncase CIT_FAULT:\r\ncase CIT_FSYNC:\r\nLASSERT(!io->ci_need_restart);\r\nbreak;\r\ncase CIT_SETATTR:\r\ncase CIT_MISC:\r\nLASSERT(ergo(io->ci_ignore_layout || !io->ci_verify_layout,\r\n!io->ci_need_restart));\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nstatic int cl_io_init0(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_object *scan;\r\nint result;\r\nLINVRNT(io->ci_state == CIS_ZERO || io->ci_state == CIS_FINI);\r\nLINVRNT(cl_io_type_is_valid(iot));\r\nLINVRNT(cl_io_invariant(io));\r\nio->ci_type = iot;\r\nINIT_LIST_HEAD(&io->ci_lockset.cls_todo);\r\nINIT_LIST_HEAD(&io->ci_lockset.cls_curr);\r\nINIT_LIST_HEAD(&io->ci_lockset.cls_done);\r\nINIT_LIST_HEAD(&io->ci_layers);\r\nresult = 0;\r\ncl_object_for_each(scan, obj) {\r\nif (scan->co_ops->coo_io_init != NULL) {\r\nresult = scan->co_ops->coo_io_init(env, scan, io);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nif (result == 0)\r\nio->ci_state = CIS_INIT;\r\nreturn result;\r\n}\r\nint cl_io_sub_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_thread_info *info = cl_env_info(env);\r\nLASSERT(obj != cl_object_top(obj));\r\nif (info->clt_current_io == NULL)\r\ninfo->clt_current_io = io;\r\nreturn cl_io_init0(env, io, iot, obj);\r\n}\r\nint cl_io_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_thread_info *info = cl_env_info(env);\r\nLASSERT(obj == cl_object_top(obj));\r\nLASSERT(info->clt_current_io == NULL);\r\ninfo->clt_current_io = io;\r\nreturn cl_io_init0(env, io, iot, obj);\r\n}\r\nint cl_io_rw_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, loff_t pos, size_t count)\r\n{\r\nLINVRNT(iot == CIT_READ || iot == CIT_WRITE);\r\nLINVRNT(io->ci_obj != NULL);\r\nLU_OBJECT_HEADER(D_VFSTRACE, env, &io->ci_obj->co_lu,\r\n"io range: %u ["LPU64", "LPU64") %u %u\n",\r\niot, (__u64)pos, (__u64)pos + count,\r\nio->u.ci_rw.crw_nonblock, io->u.ci_wr.wr_append);\r\nio->u.ci_rw.crw_pos = pos;\r\nio->u.ci_rw.crw_count = count;\r\nreturn cl_io_init(env, io, iot, io->ci_obj);\r\n}\r\nstatic inline const struct lu_fid *\r\ncl_lock_descr_fid(const struct cl_lock_descr *descr)\r\n{\r\nreturn lu_object_fid(&descr->cld_obj->co_lu);\r\n}\r\nstatic int cl_lock_descr_sort(const struct cl_lock_descr *d0,\r\nconst struct cl_lock_descr *d1)\r\n{\r\nreturn lu_fid_cmp(cl_lock_descr_fid(d0), cl_lock_descr_fid(d1)) ?:\r\n__diff_normalize(d0->cld_start, d1->cld_start);\r\n}\r\nstatic int cl_lock_descr_cmp(const struct cl_lock_descr *d0,\r\nconst struct cl_lock_descr *d1)\r\n{\r\nint ret;\r\nret = lu_fid_cmp(cl_lock_descr_fid(d0), cl_lock_descr_fid(d1));\r\nif (ret)\r\nreturn ret;\r\nif (d0->cld_end < d1->cld_start)\r\nreturn -1;\r\nif (d0->cld_start > d0->cld_end)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void cl_lock_descr_merge(struct cl_lock_descr *d0,\r\nconst struct cl_lock_descr *d1)\r\n{\r\nd0->cld_start = min(d0->cld_start, d1->cld_start);\r\nd0->cld_end = max(d0->cld_end, d1->cld_end);\r\nif (d1->cld_mode == CLM_WRITE && d0->cld_mode != CLM_WRITE)\r\nd0->cld_mode = CLM_WRITE;\r\nif (d1->cld_mode == CLM_GROUP && d0->cld_mode != CLM_GROUP)\r\nd0->cld_mode = CLM_GROUP;\r\n}\r\nstatic void cl_io_locks_sort(struct cl_io *io)\r\n{\r\nint done = 0;\r\ndo {\r\nstruct cl_io_lock_link *curr;\r\nstruct cl_io_lock_link *prev;\r\nstruct cl_io_lock_link *temp;\r\ndone = 1;\r\nprev = NULL;\r\nlist_for_each_entry_safe(curr, temp,\r\n&io->ci_lockset.cls_todo,\r\ncill_linkage) {\r\nif (prev != NULL) {\r\nswitch (cl_lock_descr_sort(&prev->cill_descr,\r\n&curr->cill_descr)) {\r\ncase 0:\r\ndefault:\r\nLBUG();\r\ncase +1:\r\nlist_move_tail(&curr->cill_linkage,\r\n&prev->cill_linkage);\r\ndone = 0;\r\ncontinue;\r\ncase -1:\r\nbreak;\r\n}\r\n}\r\nprev = curr;\r\n}\r\n} while (!done);\r\n}\r\nint cl_queue_match(const struct list_head *queue,\r\nconst struct cl_lock_descr *need)\r\n{\r\nstruct cl_io_lock_link *scan;\r\nlist_for_each_entry(scan, queue, cill_linkage) {\r\nif (cl_lock_descr_match(&scan->cill_descr, need))\r\nreturn +1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cl_queue_merge(const struct list_head *queue,\r\nconst struct cl_lock_descr *need)\r\n{\r\nstruct cl_io_lock_link *scan;\r\nlist_for_each_entry(scan, queue, cill_linkage) {\r\nif (cl_lock_descr_cmp(&scan->cill_descr, need))\r\ncontinue;\r\ncl_lock_descr_merge(&scan->cill_descr, need);\r\nCDEBUG(D_VFSTRACE, "lock: %d: [%lu, %lu]\n",\r\nscan->cill_descr.cld_mode, scan->cill_descr.cld_start,\r\nscan->cill_descr.cld_end);\r\nreturn +1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cl_lockset_match(const struct cl_lockset *set,\r\nconst struct cl_lock_descr *need)\r\n{\r\nreturn cl_queue_match(&set->cls_curr, need) ||\r\ncl_queue_match(&set->cls_done, need);\r\n}\r\nstatic int cl_lockset_merge(const struct cl_lockset *set,\r\nconst struct cl_lock_descr *need)\r\n{\r\nreturn cl_queue_merge(&set->cls_todo, need) ||\r\ncl_lockset_match(set, need);\r\n}\r\nstatic int cl_lockset_lock_one(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_lockset *set,\r\nstruct cl_io_lock_link *link)\r\n{\r\nstruct cl_lock *lock;\r\nint result;\r\nlock = cl_lock_request(env, io, &link->cill_descr, "io", io);\r\nif (!IS_ERR(lock)) {\r\nlink->cill_lock = lock;\r\nlist_move(&link->cill_linkage, &set->cls_curr);\r\nif (!(link->cill_descr.cld_enq_flags & CEF_ASYNC)) {\r\nresult = cl_wait(env, lock);\r\nif (result == 0)\r\nlist_move(&link->cill_linkage,\r\n&set->cls_done);\r\n} else\r\nresult = 0;\r\n} else\r\nresult = PTR_ERR(lock);\r\nreturn result;\r\n}\r\nstatic void cl_lock_link_fini(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_io_lock_link *link)\r\n{\r\nstruct cl_lock *lock = link->cill_lock;\r\nlist_del_init(&link->cill_linkage);\r\nif (lock != NULL) {\r\ncl_lock_release(env, lock, "io", io);\r\nlink->cill_lock = NULL;\r\n}\r\nif (link->cill_fini != NULL)\r\nlink->cill_fini(env, link);\r\n}\r\nstatic int cl_lockset_lock(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lockset *set)\r\n{\r\nstruct cl_io_lock_link *link;\r\nstruct cl_io_lock_link *temp;\r\nstruct cl_lock *lock;\r\nint result;\r\nresult = 0;\r\nlist_for_each_entry_safe(link, temp, &set->cls_todo, cill_linkage) {\r\nif (!cl_lockset_match(set, &link->cill_descr)) {\r\nresult = cl_lockset_lock_one(env, io, set, link);\r\nif (result != 0)\r\nbreak;\r\n} else\r\ncl_lock_link_fini(env, io, link);\r\n}\r\nif (result == 0) {\r\nlist_for_each_entry_safe(link, temp,\r\n&set->cls_curr, cill_linkage) {\r\nlock = link->cill_lock;\r\nresult = cl_wait(env, lock);\r\nif (result == 0)\r\nlist_move(&link->cill_linkage,\r\n&set->cls_done);\r\nelse\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint cl_io_lock(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_IT_STARTED);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_lock == NULL)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_lock(env, scan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result == 0) {\r\ncl_io_locks_sort(io);\r\nresult = cl_lockset_lock(env, io, &io->ci_lockset);\r\n}\r\nif (result != 0)\r\ncl_io_unlock(env, io);\r\nelse\r\nio->ci_state = CIS_LOCKED;\r\nreturn result;\r\n}\r\nvoid cl_io_unlock(const struct lu_env *env, struct cl_io *io)\r\n{\r\nstruct cl_lockset *set;\r\nstruct cl_io_lock_link *link;\r\nstruct cl_io_lock_link *temp;\r\nconst struct cl_io_slice *scan;\r\nLASSERT(cl_io_is_loopable(io));\r\nLASSERT(CIS_IT_STARTED <= io->ci_state && io->ci_state < CIS_UNLOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nset = &io->ci_lockset;\r\nlist_for_each_entry_safe(link, temp, &set->cls_todo, cill_linkage)\r\ncl_lock_link_fini(env, io, link);\r\nlist_for_each_entry_safe(link, temp, &set->cls_curr, cill_linkage)\r\ncl_lock_link_fini(env, io, link);\r\nlist_for_each_entry_safe(link, temp, &set->cls_done, cill_linkage) {\r\ncl_unuse(env, link->cill_lock);\r\ncl_lock_link_fini(env, io, link);\r\n}\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_unlock != NULL)\r\nscan->cis_iop->op[io->ci_type].cio_unlock(env, scan);\r\n}\r\nio->ci_state = CIS_UNLOCKED;\r\nLASSERT(!cl_env_info(env)->clt_counters[CNL_TOP].ctc_nr_locks_acquired);\r\n}\r\nint cl_io_iter_init(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_INIT || io->ci_state == CIS_IT_ENDED);\r\nLINVRNT(cl_io_invariant(io));\r\nresult = 0;\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_iter_init == NULL)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_iter_init(env,\r\nscan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result == 0)\r\nio->ci_state = CIS_IT_STARTED;\r\nreturn result;\r\n}\r\nvoid cl_io_iter_fini(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_UNLOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_iter_fini != NULL)\r\nscan->cis_iop->op[io->ci_type].cio_iter_fini(env, scan);\r\n}\r\nio->ci_state = CIS_IT_ENDED;\r\n}\r\nvoid cl_io_rw_advance(const struct lu_env *env, struct cl_io *io, size_t nob)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE ||\r\nnob == 0);\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(cl_io_invariant(io));\r\nio->u.ci_rw.crw_pos += nob;\r\nio->u.ci_rw.crw_count -= nob;\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_advance != NULL)\r\nscan->cis_iop->op[io->ci_type].cio_advance(env, scan,\r\nnob);\r\n}\r\n}\r\nint cl_io_lock_add(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_io_lock_link *link)\r\n{\r\nint result;\r\nif (cl_lockset_merge(&io->ci_lockset, &link->cill_descr))\r\nresult = +1;\r\nelse {\r\nlist_add(&link->cill_linkage, &io->ci_lockset.cls_todo);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void cl_free_io_lock_link(const struct lu_env *env,\r\nstruct cl_io_lock_link *link)\r\n{\r\nOBD_FREE_PTR(link);\r\n}\r\nint cl_io_lock_alloc_add(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lock_descr *descr)\r\n{\r\nstruct cl_io_lock_link *link;\r\nint result;\r\nOBD_ALLOC_PTR(link);\r\nif (link != NULL) {\r\nlink->cill_descr = *descr;\r\nlink->cill_fini = cl_free_io_lock_link;\r\nresult = cl_io_lock_add(env, io, link);\r\nif (result)\r\nlink->cill_fini(env, link);\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\nint cl_io_start(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nio->ci_state = CIS_IO_GOING;\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_start == NULL)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_start(env, scan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result >= 0)\r\nresult = 0;\r\nreturn result;\r\n}\r\nvoid cl_io_end(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_IO_GOING);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_end != NULL)\r\nscan->cis_iop->op[io->ci_type].cio_end(env, scan);\r\n}\r\nio->ci_state = CIS_IO_FINISHED;\r\n}\r\nstatic const struct cl_page_slice *\r\ncl_io_slice_page(const struct cl_io_slice *ios, struct cl_page *page)\r\n{\r\nconst struct cl_page_slice *slice;\r\nslice = cl_page_at(page, ios->cis_obj->co_lu.lo_dev->ld_type);\r\nLINVRNT(slice != NULL);\r\nreturn slice;\r\n}\r\nstatic int cl_page_in_io(const struct cl_page *page, const struct cl_io *io)\r\n{\r\nint result = 1;\r\nloff_t start;\r\nloff_t end;\r\npgoff_t idx;\r\nidx = page->cp_index;\r\nswitch (io->ci_type) {\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\nif (!cl_io_is_append(io)) {\r\nconst struct cl_io_rw_common *crw = &(io->u.ci_rw);\r\nstart = cl_offset(page->cp_obj, idx);\r\nend = cl_offset(page->cp_obj, idx + 1);\r\nresult = crw->crw_pos < end &&\r\nstart < crw->crw_pos + crw->crw_count;\r\n}\r\nbreak;\r\ncase CIT_FAULT:\r\nresult = io->u.ci_fault.ft_index == idx;\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nreturn result;\r\n}\r\nint cl_io_read_page(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *page)\r\n{\r\nconst struct cl_io_slice *scan;\r\nstruct cl_2queue *queue;\r\nint result = 0;\r\nLINVRNT(io->ci_type == CIT_READ || io->ci_type == CIT_FAULT);\r\nLINVRNT(cl_page_is_owned(page, io));\r\nLINVRNT(io->ci_state == CIS_IO_GOING || io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_page_in_io(page, io));\r\nLINVRNT(cl_io_invariant(io));\r\nqueue = &io->ci_queue;\r\ncl_2queue_init(queue);\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->cio_read_page != NULL) {\r\nconst struct cl_page_slice *slice;\r\nslice = cl_io_slice_page(scan, page);\r\nLINVRNT(slice != NULL);\r\nresult = scan->cis_iop->cio_read_page(env, scan, slice);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nif (result == 0)\r\nresult = cl_io_submit_rw(env, io, CRT_READ, queue);\r\ncl_page_list_disown(env, io, &queue->c2_qin);\r\ncl_2queue_fini(env, queue);\r\nreturn result;\r\n}\r\nint cl_io_prepare_write(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *page, unsigned from, unsigned to)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(io->ci_type == CIT_WRITE);\r\nLINVRNT(cl_page_is_owned(page, io));\r\nLINVRNT(io->ci_state == CIS_IO_GOING || io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nLASSERT(cl_page_in_io(page, io));\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->cio_prepare_write != NULL) {\r\nconst struct cl_page_slice *slice;\r\nslice = cl_io_slice_page(scan, page);\r\nresult = scan->cis_iop->cio_prepare_write(env, scan,\r\nslice,\r\nfrom, to);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint cl_io_commit_write(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *page, unsigned from, unsigned to)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(io->ci_type == CIT_WRITE);\r\nLINVRNT(io->ci_state == CIS_IO_GOING || io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nLASSERT(cl_page_is_owned(page, io) || page->cp_parent != NULL);\r\nLASSERT(cl_page_in_io(page, io));\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->cio_commit_write != NULL) {\r\nconst struct cl_page_slice *slice;\r\nslice = cl_io_slice_page(scan, page);\r\nresult = scan->cis_iop->cio_commit_write(env, scan,\r\nslice,\r\nfrom, to);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nLINVRNT(result <= 0);\r\nreturn result;\r\n}\r\nint cl_io_submit_rw(const struct lu_env *env, struct cl_io *io,\r\nenum cl_req_type crt, struct cl_2queue *queue)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(crt < ARRAY_SIZE(scan->cis_iop->req_op));\r\ncl_io_for_each(scan, io) {\r\nif (scan->cis_iop->req_op[crt].cio_submit == NULL)\r\ncontinue;\r\nresult = scan->cis_iop->req_op[crt].cio_submit(env, scan, crt,\r\nqueue);\r\nif (result != 0)\r\nbreak;\r\n}\r\nLASSERT(ergo(result != 0, list_empty(&queue->c2_qout.pl_pages)));\r\nreturn result;\r\n}\r\nint cl_io_submit_sync(const struct lu_env *env, struct cl_io *io,\r\nenum cl_req_type iot, struct cl_2queue *queue,\r\nlong timeout)\r\n{\r\nstruct cl_sync_io *anchor = &cl_env_info(env)->clt_anchor;\r\nstruct cl_page *pg;\r\nint rc;\r\ncl_page_list_for_each(pg, &queue->c2_qin) {\r\nLASSERT(pg->cp_sync_io == NULL);\r\npg->cp_sync_io = anchor;\r\n}\r\ncl_sync_io_init(anchor, queue->c2_qin.pl_nr);\r\nrc = cl_io_submit_rw(env, io, iot, queue);\r\nif (rc == 0) {\r\ncl_page_list_for_each(pg, &queue->c2_qin) {\r\npg->cp_sync_io = NULL;\r\ncl_sync_io_note(anchor, +1);\r\n}\r\nrc = cl_sync_io_wait(env, io, &queue->c2_qout,\r\nanchor, timeout);\r\n} else {\r\nLASSERT(list_empty(&queue->c2_qout.pl_pages));\r\ncl_page_list_for_each(pg, &queue->c2_qin)\r\npg->cp_sync_io = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint cl_io_cancel(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *queue)\r\n{\r\nstruct cl_page *page;\r\nint result = 0;\r\nCERROR("Canceling ongoing page trasmission\n");\r\ncl_page_list_for_each(page, queue) {\r\nint rc;\r\nLINVRNT(cl_page_in_io(page, io));\r\nrc = cl_page_cancel(env, page);\r\nresult = result ?: rc;\r\n}\r\nreturn result;\r\n}\r\nint cl_io_loop(const struct lu_env *env, struct cl_io *io)\r\n{\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\ndo {\r\nsize_t nob;\r\nio->ci_continue = 0;\r\nresult = cl_io_iter_init(env, io);\r\nif (result == 0) {\r\nnob = io->ci_nob;\r\nresult = cl_io_lock(env, io);\r\nif (result == 0) {\r\nresult = cl_io_start(env, io);\r\ncl_io_end(env, io);\r\ncl_io_unlock(env, io);\r\ncl_io_rw_advance(env, io, io->ci_nob - nob);\r\n}\r\n}\r\ncl_io_iter_fini(env, io);\r\n} while (result == 0 && io->ci_continue);\r\nif (result == 0)\r\nresult = io->ci_result;\r\nreturn result < 0 ? result : 0;\r\n}\r\nvoid cl_io_slice_add(struct cl_io *io, struct cl_io_slice *slice,\r\nstruct cl_object *obj,\r\nconst struct cl_io_operations *ops)\r\n{\r\nstruct list_head *linkage = &slice->cis_linkage;\r\nLASSERT((linkage->prev == NULL && linkage->next == NULL) ||\r\nlist_empty(linkage));\r\nlist_add_tail(linkage, &io->ci_layers);\r\nslice->cis_io = io;\r\nslice->cis_obj = obj;\r\nslice->cis_iop = ops;\r\n}\r\nvoid cl_page_list_init(struct cl_page_list *plist)\r\n{\r\nplist->pl_nr = 0;\r\nINIT_LIST_HEAD(&plist->pl_pages);\r\nplist->pl_owner = current;\r\n}\r\nvoid cl_page_list_add(struct cl_page_list *plist, struct cl_page *page)\r\n{\r\nLASSERT(page->cp_owner != NULL);\r\nLINVRNT(plist->pl_owner == current);\r\nlockdep_off();\r\nmutex_lock(&page->cp_mutex);\r\nlockdep_on();\r\nLASSERT(list_empty(&page->cp_batch));\r\nlist_add_tail(&page->cp_batch, &plist->pl_pages);\r\n++plist->pl_nr;\r\nlu_ref_add_at(&page->cp_reference, &page->cp_queue_ref, "queue", plist);\r\ncl_page_get(page);\r\n}\r\nvoid cl_page_list_del(const struct lu_env *env,\r\nstruct cl_page_list *plist, struct cl_page *page)\r\n{\r\nLASSERT(plist->pl_nr > 0);\r\nLINVRNT(plist->pl_owner == current);\r\nlist_del_init(&page->cp_batch);\r\nlockdep_off();\r\nmutex_unlock(&page->cp_mutex);\r\nlockdep_on();\r\n--plist->pl_nr;\r\nlu_ref_del_at(&page->cp_reference, &page->cp_queue_ref, "queue", plist);\r\ncl_page_put(env, page);\r\n}\r\nvoid cl_page_list_move(struct cl_page_list *dst, struct cl_page_list *src,\r\nstruct cl_page *page)\r\n{\r\nLASSERT(src->pl_nr > 0);\r\nLINVRNT(dst->pl_owner == current);\r\nLINVRNT(src->pl_owner == current);\r\nlist_move_tail(&page->cp_batch, &dst->pl_pages);\r\n--src->pl_nr;\r\n++dst->pl_nr;\r\nlu_ref_set_at(&page->cp_reference, &page->cp_queue_ref, "queue",\r\nsrc, dst);\r\n}\r\nvoid cl_page_list_splice(struct cl_page_list *list, struct cl_page_list *head)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *tmp;\r\nLINVRNT(list->pl_owner == current);\r\nLINVRNT(head->pl_owner == current);\r\ncl_page_list_for_each_safe(page, tmp, list)\r\ncl_page_list_move(head, list, page);\r\n}\r\nvoid cl_page_list_disown(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *temp;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each_safe(page, temp, plist) {\r\nLASSERT(plist->pl_nr > 0);\r\nlist_del_init(&page->cp_batch);\r\nlockdep_off();\r\nmutex_unlock(&page->cp_mutex);\r\nlockdep_on();\r\n--plist->pl_nr;\r\ncl_page_disown0(env, io, page);\r\nlu_ref_del_at(&page->cp_reference, &page->cp_queue_ref, "queue",\r\nplist);\r\ncl_page_put(env, page);\r\n}\r\n}\r\nvoid cl_page_list_fini(const struct lu_env *env, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *temp;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each_safe(page, temp, plist)\r\ncl_page_list_del(env, plist, page);\r\nLASSERT(plist->pl_nr == 0);\r\n}\r\nint cl_page_list_own(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *temp;\r\npgoff_t index = 0;\r\nint result;\r\nLINVRNT(plist->pl_owner == current);\r\nresult = 0;\r\ncl_page_list_for_each_safe(page, temp, plist) {\r\nLASSERT(index <= page->cp_index);\r\nindex = page->cp_index;\r\nif (cl_page_own(env, io, page) == 0)\r\nresult = result ?: page->cp_error;\r\nelse\r\ncl_page_list_del(env, plist, page);\r\n}\r\nreturn result;\r\n}\r\nvoid cl_page_list_assume(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each(page, plist)\r\ncl_page_assume(env, io, page);\r\n}\r\nvoid cl_page_list_discard(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each(page, plist)\r\ncl_page_discard(env, io, page);\r\n}\r\nint cl_page_list_unmap(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nint result;\r\nLINVRNT(plist->pl_owner == current);\r\nresult = 0;\r\ncl_page_list_for_each(page, plist) {\r\nresult = cl_page_unmap(env, io, page);\r\nif (result != 0)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nvoid cl_2queue_init(struct cl_2queue *queue)\r\n{\r\ncl_page_list_init(&queue->c2_qin);\r\ncl_page_list_init(&queue->c2_qout);\r\n}\r\nvoid cl_2queue_add(struct cl_2queue *queue, struct cl_page *page)\r\n{\r\ncl_page_list_add(&queue->c2_qin, page);\r\n}\r\nvoid cl_2queue_disown(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_2queue *queue)\r\n{\r\ncl_page_list_disown(env, io, &queue->c2_qin);\r\ncl_page_list_disown(env, io, &queue->c2_qout);\r\n}\r\nvoid cl_2queue_discard(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_2queue *queue)\r\n{\r\ncl_page_list_discard(env, io, &queue->c2_qin);\r\ncl_page_list_discard(env, io, &queue->c2_qout);\r\n}\r\nvoid cl_2queue_assume(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_2queue *queue)\r\n{\r\ncl_page_list_assume(env, io, &queue->c2_qin);\r\ncl_page_list_assume(env, io, &queue->c2_qout);\r\n}\r\nvoid cl_2queue_fini(const struct lu_env *env, struct cl_2queue *queue)\r\n{\r\ncl_page_list_fini(env, &queue->c2_qout);\r\ncl_page_list_fini(env, &queue->c2_qin);\r\n}\r\nvoid cl_2queue_init_page(struct cl_2queue *queue, struct cl_page *page)\r\n{\r\ncl_2queue_init(queue);\r\ncl_2queue_add(queue, page);\r\n}\r\nstruct cl_io *cl_io_top(struct cl_io *io)\r\n{\r\nwhile (io->ci_parent != NULL)\r\nio = io->ci_parent;\r\nreturn io;\r\n}\r\nvoid cl_io_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t printer, const struct cl_io *io)\r\n{\r\n}\r\nvoid cl_req_slice_add(struct cl_req *req, struct cl_req_slice *slice,\r\nstruct cl_device *dev,\r\nconst struct cl_req_operations *ops)\r\n{\r\nlist_add_tail(&slice->crs_linkage, &req->crq_layers);\r\nslice->crs_dev = dev;\r\nslice->crs_ops = ops;\r\nslice->crs_req = req;\r\n}\r\nstatic void cl_req_free(const struct lu_env *env, struct cl_req *req)\r\n{\r\nunsigned i;\r\nLASSERT(list_empty(&req->crq_pages));\r\nLASSERT(req->crq_nrpages == 0);\r\nLINVRNT(list_empty(&req->crq_layers));\r\nLINVRNT(equi(req->crq_nrobjs > 0, req->crq_o != NULL));\r\nif (req->crq_o != NULL) {\r\nfor (i = 0; i < req->crq_nrobjs; ++i) {\r\nstruct cl_object *obj = req->crq_o[i].ro_obj;\r\nif (obj != NULL) {\r\nlu_object_ref_del_at(&obj->co_lu,\r\n&req->crq_o[i].ro_obj_ref,\r\n"cl_req", req);\r\ncl_object_put(env, obj);\r\n}\r\n}\r\nOBD_FREE(req->crq_o, req->crq_nrobjs * sizeof(req->crq_o[0]));\r\n}\r\nOBD_FREE_PTR(req);\r\n}\r\nstatic int cl_req_init(const struct lu_env *env, struct cl_req *req,\r\nstruct cl_page *page)\r\n{\r\nstruct cl_device *dev;\r\nstruct cl_page_slice *slice;\r\nint result;\r\nresult = 0;\r\npage = cl_page_top(page);\r\ndo {\r\nlist_for_each_entry(slice, &page->cp_layers, cpl_linkage) {\r\ndev = lu2cl_dev(slice->cpl_obj->co_lu.lo_dev);\r\nif (dev->cd_ops->cdo_req_init != NULL) {\r\nresult = dev->cd_ops->cdo_req_init(env,\r\ndev, req);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\npage = page->cp_child;\r\n} while (page != NULL && result == 0);\r\nreturn result;\r\n}\r\nvoid cl_req_completion(const struct lu_env *env, struct cl_req *req, int rc)\r\n{\r\nstruct cl_req_slice *slice;\r\nwhile (!list_empty(&req->crq_layers)) {\r\nslice = list_entry(req->crq_layers.prev,\r\nstruct cl_req_slice, crs_linkage);\r\nlist_del_init(&slice->crs_linkage);\r\nif (slice->crs_ops->cro_completion != NULL)\r\nslice->crs_ops->cro_completion(env, slice, rc);\r\n}\r\ncl_req_free(env, req);\r\n}\r\nstruct cl_req *cl_req_alloc(const struct lu_env *env, struct cl_page *page,\r\nenum cl_req_type crt, int nr_objects)\r\n{\r\nstruct cl_req *req;\r\nLINVRNT(nr_objects > 0);\r\nOBD_ALLOC_PTR(req);\r\nif (req != NULL) {\r\nint result;\r\nOBD_ALLOC(req->crq_o, nr_objects * sizeof(req->crq_o[0]));\r\nif (req->crq_o != NULL) {\r\nreq->crq_nrobjs = nr_objects;\r\nreq->crq_type = crt;\r\nINIT_LIST_HEAD(&req->crq_pages);\r\nINIT_LIST_HEAD(&req->crq_layers);\r\nresult = cl_req_init(env, req, page);\r\n} else\r\nresult = -ENOMEM;\r\nif (result != 0) {\r\ncl_req_completion(env, req, result);\r\nreq = ERR_PTR(result);\r\n}\r\n} else\r\nreq = ERR_PTR(-ENOMEM);\r\nreturn req;\r\n}\r\nvoid cl_req_page_add(const struct lu_env *env,\r\nstruct cl_req *req, struct cl_page *page)\r\n{\r\nstruct cl_object *obj;\r\nstruct cl_req_obj *rqo;\r\nint i;\r\npage = cl_page_top(page);\r\nLASSERT(list_empty(&page->cp_flight));\r\nLASSERT(page->cp_req == NULL);\r\nCL_PAGE_DEBUG(D_PAGE, env, page, "req %p, %d, %u\n",\r\nreq, req->crq_type, req->crq_nrpages);\r\nlist_add_tail(&page->cp_flight, &req->crq_pages);\r\n++req->crq_nrpages;\r\npage->cp_req = req;\r\nobj = cl_object_top(page->cp_obj);\r\nfor (i = 0, rqo = req->crq_o; obj != rqo->ro_obj; ++i, ++rqo) {\r\nif (rqo->ro_obj == NULL) {\r\nrqo->ro_obj = obj;\r\ncl_object_get(obj);\r\nlu_object_ref_add_at(&obj->co_lu, &rqo->ro_obj_ref,\r\n"cl_req", req);\r\nbreak;\r\n}\r\n}\r\nLASSERT(i < req->crq_nrobjs);\r\n}\r\nvoid cl_req_page_done(const struct lu_env *env, struct cl_page *page)\r\n{\r\nstruct cl_req *req = page->cp_req;\r\npage = cl_page_top(page);\r\nLASSERT(!list_empty(&page->cp_flight));\r\nLASSERT(req->crq_nrpages > 0);\r\nlist_del_init(&page->cp_flight);\r\n--req->crq_nrpages;\r\npage->cp_req = NULL;\r\n}\r\nint cl_req_prep(const struct lu_env *env, struct cl_req *req)\r\n{\r\nint i;\r\nint result;\r\nconst struct cl_req_slice *slice;\r\nfor (i = 0; i < req->crq_nrobjs; ++i)\r\nLASSERT(req->crq_o[i].ro_obj != NULL);\r\nresult = 0;\r\nlist_for_each_entry(slice, &req->crq_layers, crs_linkage) {\r\nif (slice->crs_ops->cro_prep != NULL) {\r\nresult = slice->crs_ops->cro_prep(env, slice);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nvoid cl_req_attr_set(const struct lu_env *env, struct cl_req *req,\r\nstruct cl_req_attr *attr, obd_valid flags)\r\n{\r\nconst struct cl_req_slice *slice;\r\nstruct cl_page *page;\r\nint i;\r\nLASSERT(!list_empty(&req->crq_pages));\r\npage = list_entry(req->crq_pages.next, struct cl_page, cp_flight);\r\nfor (i = 0; i < req->crq_nrobjs; ++i) {\r\nlist_for_each_entry(slice, &req->crq_layers, crs_linkage) {\r\nconst struct cl_page_slice *scan;\r\nconst struct cl_object *obj;\r\nscan = cl_page_at(page,\r\nslice->crs_dev->cd_lu_dev.ld_type);\r\nLASSERT(scan != NULL);\r\nobj = scan->cpl_obj;\r\nif (slice->crs_ops->cro_attr_set != NULL)\r\nslice->crs_ops->cro_attr_set(env, slice, obj,\r\nattr + i, flags);\r\n}\r\n}\r\n}\r\nvoid cl_sync_io_init(struct cl_sync_io *anchor, int nrpages)\r\n{\r\ninit_waitqueue_head(&anchor->csi_waitq);\r\natomic_set(&anchor->csi_sync_nr, nrpages);\r\natomic_set(&anchor->csi_barrier, nrpages > 0);\r\nanchor->csi_sync_rc = 0;\r\n}\r\nint cl_sync_io_wait(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *queue, struct cl_sync_io *anchor,\r\nlong timeout)\r\n{\r\nstruct l_wait_info lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(timeout),\r\nNULL, NULL, NULL);\r\nint rc;\r\nLASSERT(timeout >= 0);\r\nrc = l_wait_event(anchor->csi_waitq,\r\natomic_read(&anchor->csi_sync_nr) == 0,\r\n&lwi);\r\nif (rc < 0) {\r\nCERROR("SYNC IO failed with error: %d, try to cancel "\r\n"%d remaining pages\n",\r\nrc, atomic_read(&anchor->csi_sync_nr));\r\n(void)cl_io_cancel(env, io, queue);\r\nlwi = (struct l_wait_info) { 0 };\r\n(void)l_wait_event(anchor->csi_waitq,\r\natomic_read(&anchor->csi_sync_nr) == 0,\r\n&lwi);\r\n} else {\r\nrc = anchor->csi_sync_rc;\r\n}\r\nLASSERT(atomic_read(&anchor->csi_sync_nr) == 0);\r\ncl_page_list_assume(env, io, queue);\r\nwhile (unlikely(atomic_read(&anchor->csi_barrier) != 0)) {\r\ncpu_relax();\r\n}\r\nPOISON(anchor, 0x5a, sizeof(*anchor));\r\nreturn rc;\r\n}\r\nvoid cl_sync_io_note(struct cl_sync_io *anchor, int ioret)\r\n{\r\nif (anchor->csi_sync_rc == 0 && ioret < 0)\r\nanchor->csi_sync_rc = ioret;\r\nLASSERT(atomic_read(&anchor->csi_sync_nr) > 0);\r\nif (atomic_dec_and_test(&anchor->csi_sync_nr)) {\r\nwake_up_all(&anchor->csi_waitq);\r\natomic_set(&anchor->csi_barrier, 0);\r\n}\r\n}
