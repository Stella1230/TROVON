static inline unsigned int labpc_inb(unsigned long address)\r\n{\r\nreturn inb(address);\r\n}\r\nstatic inline void labpc_outb(unsigned int byte, unsigned long address)\r\n{\r\noutb(byte, address);\r\n}\r\nstatic inline unsigned int labpc_readb(unsigned long address)\r\n{\r\nreturn readb((void __iomem *)address);\r\n}\r\nstatic inline void labpc_writeb(unsigned int byte, unsigned long address)\r\n{\r\nwriteb(byte, (void __iomem *)address);\r\n}\r\nstatic int labpc_counter_load(struct comedi_device *dev,\r\nunsigned long base_address,\r\nunsigned int counter_number,\r\nunsigned int count, unsigned int mode)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nif (board->has_mmio)\r\nreturn i8254_mm_load((void __iomem *)base_address, 0,\r\ncounter_number, count, mode);\r\nelse\r\nreturn i8254_load(base_address, 0, counter_number, count, mode);\r\n}\r\nstatic int labpc_counter_set_mode(struct comedi_device *dev,\r\nunsigned long base_address,\r\nunsigned int counter_number,\r\nunsigned int mode)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nif (board->has_mmio)\r\nreturn i8254_mm_set_mode((void __iomem *)base_address, 0,\r\ncounter_number, mode);\r\nelse\r\nreturn i8254_set_mode(base_address, 0, counter_number, mode);\r\n}\r\nstatic int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\r\ndevpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->cmd3 = 0;\r\ndevpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);\r\nreturn 0;\r\n}\r\nstatic void labpc_ai_set_chan_and_gain(struct comedi_device *dev,\r\nenum scan_mode mode,\r\nunsigned int chan,\r\nunsigned int range,\r\nunsigned int aref)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nif (board->is_labpc1200) {\r\nrange += (range > 0) + (range > 7);\r\n}\r\nif ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&\r\naref == AREF_DIFF)\r\nchan *= 2;\r\ndevpriv->cmd1 = CMD1_MA(chan);\r\ndevpriv->cmd1 |= CMD1_GAIN(range);\r\ndevpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);\r\n}\r\nstatic void labpc_setup_cmd6_reg(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nenum scan_mode mode,\r\nenum transfer_type xfer,\r\nunsigned int range,\r\nunsigned int aref,\r\nbool ena_intr)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nif (!board->is_labpc1200)\r\nreturn;\r\nif (aref != AREF_GROUND)\r\ndevpriv->cmd6 |= CMD6_NRSE;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_NRSE;\r\nif (comedi_range_is_unipolar(s, range))\r\ndevpriv->cmd6 |= CMD6_ADCUNI;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_ADCUNI;\r\nif (xfer == fifo_half_full_transfer)\r\ndevpriv->cmd6 |= CMD6_HFINTEN;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_HFINTEN;\r\nif (ena_intr)\r\ndevpriv->cmd6 |= CMD6_DQINTEN;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_DQINTEN;\r\nif (mode == MODE_MULT_CHAN_UP)\r\ndevpriv->cmd6 |= CMD6_SCANUP;\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_SCANUP;\r\ndevpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);\r\n}\r\nstatic unsigned int labpc_read_adc_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int lsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\nunsigned int msb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\nreturn (msb << 8) | lsb;\r\n}\r\nstatic void labpc_clear_adc_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);\r\nlabpc_read_adc_fifo(dev);\r\n}\r\nstatic int labpc_ai_wait_for_data(struct comedi_device *dev,\r\nint timeout)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\ndevpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);\r\nif (devpriv->stat1 & STAT1_DAVAIL)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int labpc_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nint ret;\r\nint i;\r\nlabpc_cancel(dev, s);\r\nlabpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);\r\nlabpc_setup_cmd6_reg(dev, s, MODE_SINGLE_CHAN, fifo_not_empty_transfer,\r\nrange, aref, false);\r\ndevpriv->cmd4 = 0;\r\ndevpriv->cmd4 |= CMD4_ECLKRCV;\r\nif (aref == AREF_DIFF)\r\ndevpriv->cmd4 |= CMD4_SEDIFF;\r\ndevpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);\r\nret = labpc_counter_set_mode(dev, dev->iobase + COUNTER_A_BASE_REG,\r\n0, I8254_MODE2);\r\nif (ret)\r\nreturn ret;\r\nlabpc_clear_adc_fifo(dev);\r\nfor (i = 0; i < insn->n; i++) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_START_CONVERT_REG);\r\nret = labpc_ai_wait_for_data(dev, LABPC_ADC_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = labpc_read_adc_fifo(dev);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (mode == MODE_SINGLE_CHAN || cmd->scan_begin_src == TRIG_FOLLOW)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN && cmd->scan_begin_src == TRIG_TIMER)\r\nreturn cmd->scan_begin_arg;\r\nreturn cmd->convert_arg;\r\n}\r\nstatic void labpc_set_ai_convert_period(struct comedi_cmd *cmd,\r\nenum scan_mode mode, unsigned int ns)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn;\r\nif (mode == MODE_SINGLE_CHAN &&\r\ncmd->scan_begin_src == TRIG_TIMER) {\r\ncmd->scan_begin_arg = ns;\r\nif (cmd->convert_arg > cmd->scan_begin_arg)\r\ncmd->convert_arg = cmd->scan_begin_arg;\r\n} else\r\ncmd->convert_arg = ns;\r\n}\r\nstatic unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\r\nreturn 0;\r\nreturn cmd->scan_begin_arg;\r\n}\r\nstatic void labpc_set_ai_scan_period(struct comedi_cmd *cmd,\r\nenum scan_mode mode, unsigned int ns)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn;\r\nif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\r\nreturn;\r\ncmd->scan_begin_arg = ns;\r\n}\r\nstatic void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nconst int max_counter_value = 0x10000;\r\nconst int min_counter_value = 2;\r\nunsigned int base_period;\r\nunsigned int scan_period;\r\nunsigned int convert_period;\r\nconvert_period = labpc_ai_convert_period(cmd, mode);\r\nscan_period = labpc_ai_scan_period(cmd, mode);\r\nif (convert_period && scan_period) {\r\ndevpriv->divisor_b0 = (scan_period - 1) /\r\n(I8254_OSC_BASE_2MHZ * max_counter_value) + 1;\r\nif (devpriv->divisor_b0 < min_counter_value)\r\ndevpriv->divisor_b0 = min_counter_value;\r\nif (devpriv->divisor_b0 > max_counter_value)\r\ndevpriv->divisor_b0 = max_counter_value;\r\nbase_period = I8254_OSC_BASE_2MHZ * devpriv->divisor_b0;\r\nswitch (cmd->flags & TRIG_ROUND_MASK) {\r\ndefault:\r\ncase TRIG_ROUND_NEAREST:\r\ndevpriv->divisor_a0 =\r\n(convert_period + (base_period / 2)) / base_period;\r\ndevpriv->divisor_b1 =\r\n(scan_period + (base_period / 2)) / base_period;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndevpriv->divisor_a0 =\r\n(convert_period + (base_period - 1)) / base_period;\r\ndevpriv->divisor_b1 =\r\n(scan_period + (base_period - 1)) / base_period;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndevpriv->divisor_a0 = convert_period / base_period;\r\ndevpriv->divisor_b1 = scan_period / base_period;\r\nbreak;\r\n}\r\nif (devpriv->divisor_a0 < min_counter_value)\r\ndevpriv->divisor_a0 = min_counter_value;\r\nif (devpriv->divisor_a0 > max_counter_value)\r\ndevpriv->divisor_a0 = max_counter_value;\r\nif (devpriv->divisor_b1 < min_counter_value)\r\ndevpriv->divisor_b1 = min_counter_value;\r\nif (devpriv->divisor_b1 > max_counter_value)\r\ndevpriv->divisor_b1 = max_counter_value;\r\nlabpc_set_ai_convert_period(cmd, mode,\r\nbase_period * devpriv->divisor_a0);\r\nlabpc_set_ai_scan_period(cmd, mode,\r\nbase_period * devpriv->divisor_b1);\r\n} else if (scan_period) {\r\ni8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,\r\n&devpriv->divisor_b1,\r\n&devpriv->divisor_b0,\r\n&scan_period, cmd->flags);\r\nlabpc_set_ai_scan_period(cmd, mode, scan_period);\r\n} else if (convert_period) {\r\ni8253_cascade_ns_to_timer(I8254_OSC_BASE_2MHZ,\r\n&devpriv->divisor_a0,\r\n&devpriv->divisor_b0,\r\n&convert_period, cmd->flags);\r\nlabpc_set_ai_convert_period(cmd, mode, convert_period);\r\n}\r\n}\r\nstatic enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)\r\n{\r\nif (cmd->chanlist_len == 1)\r\nreturn MODE_SINGLE_CHAN;\r\nif (cmd->chanlist == NULL)\r\nreturn MODE_MULT_CHAN_UP;\r\nif (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_SINGLE_CHAN_INTERVAL;\r\nif (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_MULT_CHAN_UP;\r\nif (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_MULT_CHAN_DOWN;\r\npr_err("ni_labpc: bug! cannot determine AI scan mode\n");\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_chanlist_invalid(const struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd,\r\nenum scan_mode mode)\r\n{\r\nint channel, range, aref, i;\r\nif (cmd->chanlist == NULL)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN_INTERVAL) {\r\nif (cmd->chanlist_len > 0xff) {\r\ncomedi_error(dev,\r\n"ni_labpc: chanlist too long for single channel interval mode\n");\r\nreturn 1;\r\n}\r\n}\r\nchannel = CR_CHAN(cmd->chanlist[0]);\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\naref = CR_AREF(cmd->chanlist[0]);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nswitch (mode) {\r\ncase MODE_SINGLE_CHAN_INTERVAL:\r\nif (CR_CHAN(cmd->chanlist[i]) != channel) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_UP:\r\nif (CR_CHAN(cmd->chanlist[i]) != i) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_DOWN:\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\ncmd->chanlist_len - i - 1) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev,\r\n"ni_labpc: bug! in chanlist check\n");\r\nreturn 1;\r\nbreak;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != range) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same range\n");\r\nreturn 1;\r\n}\r\nif (CR_AREF(cmd->chanlist[i]) != aref) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same reference\n");\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nint err = 0;\r\nint tmp, tmp2;\r\nunsigned int stop_mask;\r\nenum scan_mode mode;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nstop_mask = TRIG_COUNT | TRIG_NONE;\r\nif (board->is_labpc1200)\r\nstop_mask |= TRIG_EXT;\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, stop_mask);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg == TRIG_NOW)\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (!cmd->chanlist_len)\r\nerr |= -EINVAL;\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,\r\ncmd->convert_arg * cmd->chanlist_len);\r\nerr |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ai_speed * cmd->chanlist_len);\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\ntmp = cmd->convert_arg;\r\ntmp2 = cmd->scan_begin_arg;\r\nmode = labpc_ai_scan_mode(cmd);\r\nlabpc_adc_timing(dev, cmd, mode);\r\nif (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)\r\nerr++;\r\nif (err)\r\nreturn 4;\r\nif (labpc_ai_chanlist_invalid(dev, cmd, mode))\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nenum scan_mode mode = labpc_ai_scan_mode(cmd);\r\nunsigned int chanspec = (mode == MODE_MULT_CHAN_UP)\r\n? cmd->chanlist[cmd->chanlist_len - 1]\r\n: cmd->chanlist[0];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nenum transfer_type xfer;\r\nunsigned long flags;\r\nint ret;\r\nlabpc_cancel(dev, s);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count = cmd->stop_arg * cmd->chanlist_len;\r\nif (cmd->stop_src == TRIG_EXT) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,\r\n1, 3, I8254_MODE0);\r\n} else {\r\nret = labpc_counter_set_mode(dev,\r\ndev->iobase + COUNTER_A_BASE_REG,\r\n1, I8254_MODE0);\r\n}\r\nif (ret) {\r\ncomedi_error(dev, "error loading counter a1");\r\nreturn ret;\r\n}\r\nif (labpc_have_dma_chan(dev) &&\r\n(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0)\r\nxfer = isa_dma_transfer;\r\nelse if (\r\nboard->is_labpc1200 &&\r\n(cmd->flags & TRIG_WAKE_EOS) == 0 &&\r\n(cmd->stop_src != TRIG_COUNT || devpriv->count > 256))\r\nxfer = fifo_half_full_transfer;\r\nelse\r\nxfer = fifo_not_empty_transfer;\r\ndevpriv->current_transfer = xfer;\r\nlabpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);\r\nlabpc_setup_cmd6_reg(dev, s, mode, xfer, range, aref,\r\n(cmd->stop_src == TRIG_EXT));\r\nif (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {\r\ndevpriv->cmd1 |= CMD1_SCANEN;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);\r\n}\r\ndevpriv->write_byte(cmd->chanlist_len,\r\ndev->iobase + INTERVAL_COUNT_REG);\r\ndevpriv->write_byte(0x1, dev->iobase + INTERVAL_STROBE_REG);\r\nif (cmd->convert_src == TRIG_TIMER ||\r\ncmd->scan_begin_src == TRIG_TIMER) {\r\nlabpc_adc_timing(dev, cmd, mode);\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,\r\n0, devpriv->divisor_b0, I8254_MODE3);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter b0");\r\nreturn -1;\r\n}\r\n}\r\nif (labpc_ai_convert_period(cmd, mode)) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,\r\n0, devpriv->divisor_a0, I8254_MODE2);\r\n} else {\r\nret = labpc_counter_set_mode(dev,\r\ndev->iobase + COUNTER_A_BASE_REG,\r\n0, I8254_MODE2);\r\n}\r\nif (ret) {\r\ncomedi_error(dev, "error loading counter a0");\r\nreturn ret;\r\n}\r\nif (labpc_ai_scan_period(cmd, mode)) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,\r\n1, devpriv->divisor_b1, I8254_MODE2);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter b1");\r\nreturn -1;\r\n}\r\n}\r\nlabpc_clear_adc_fifo(dev);\r\nif (xfer == isa_dma_transfer)\r\nlabpc_setup_dma(dev, s);\r\ndevpriv->cmd3 |= CMD3_ERRINTEN;\r\nif (xfer == fifo_not_empty_transfer)\r\ndevpriv->cmd3 |= CMD3_FIFOINTEN;\r\ndevpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);\r\ndevpriv->cmd4 = 0;\r\nif (cmd->convert_src != TRIG_EXT)\r\ndevpriv->cmd4 |= CMD4_ECLKRCV;\r\nif (!labpc_use_continuous_mode(cmd, mode)) {\r\ndevpriv->cmd4 |= CMD4_INTSCAN;\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ndevpriv->cmd4 |= CMD4_EOIRCV;\r\n}\r\nif (aref == AREF_DIFF)\r\ndevpriv->cmd4 |= CMD4_SEDIFF;\r\ndevpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 |= CMD2_TBSEL;\r\ndevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\r\nif (cmd->start_src == TRIG_EXT)\r\ndevpriv->cmd2 |= CMD2_HWTRIG;\r\nelse\r\ndevpriv->cmd2 |= CMD2_SWTRIG;\r\nif (cmd->stop_src == TRIG_EXT)\r\ndevpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);\r\ndevpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int labpc_drain_fifo(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned short data;\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nconst int timeout = 10000;\r\nunsigned int i;\r\ndevpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);\r\nfor (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;\r\ni++) {\r\nif (async->cmd.stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0)\r\nbreak;\r\ndevpriv->count--;\r\n}\r\ndata = labpc_read_adc_fifo(dev);\r\ncfc_write_to_buffer(dev->read_subdev, data);\r\ndevpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "ai timeout, fifo never empties");\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void labpc_drain_dregs(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nif (devpriv->current_transfer == isa_dma_transfer)\r\nlabpc_drain_dma(dev);\r\nlabpc_drain_fifo(dev);\r\n}\r\nstatic irqreturn_t labpc_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nif (!dev->attached) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nasync = s->async;\r\ncmd = &async->cmd;\r\nasync->events = 0;\r\ndevpriv->stat1 = devpriv->read_byte(dev->iobase + STAT1_REG);\r\nif (board->is_labpc1200)\r\ndevpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);\r\nif ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |\r\nSTAT1_OVERRUN | STAT1_DAVAIL)) == 0\r\n&& (devpriv->stat2 & STAT2_OUTA1) == 0\r\n&& (devpriv->stat2 & STAT2_FIFONHF)) {\r\nreturn IRQ_NONE;\r\n}\r\nif (devpriv->stat1 & STAT1_OVERRUN) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\ncomedi_error(dev, "overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->current_transfer == isa_dma_transfer)\r\nlabpc_handle_dma_status(dev);\r\nelse\r\nlabpc_drain_fifo(dev);\r\nif (devpriv->stat1 & STAT1_CNTINT) {\r\ncomedi_error(dev, "handled timer interrupt?");\r\ndevpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);\r\n}\r\nif (devpriv->stat1 & STAT1_OVERFLOW) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_FIFO_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\ncomedi_error(dev, "overflow");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cmd->stop_src == TRIG_EXT) {\r\nif (devpriv->stat2 & STAT2_OUTA1) {\r\nlabpc_drain_dregs(dev);\r\nlabpc_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0) {\r\nlabpc_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int labpc_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nint channel, range;\r\nunsigned long flags;\r\nint lsb, msb;\r\nchannel = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->cmd2 &= ~CMD2_LDAC(channel);\r\ndevpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (board->is_labpc1200) {\r\nrange = CR_RANGE(insn->chanspec);\r\nif (comedi_range_is_unipolar(s, range))\r\ndevpriv->cmd6 |= CMD6_DACUNI(channel);\r\nelse\r\ndevpriv->cmd6 &= ~CMD6_DACUNI(channel);\r\ndevpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);\r\n}\r\nlsb = data[0] & 0xff;\r\nmsb = (data[0] >> 8) & 0xff;\r\ndevpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));\r\ndevpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));\r\ndevpriv->ao_value[channel] = data[0];\r\nreturn 1;\r\n}\r\nstatic int labpc_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\ndata[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int labpc_8255_mmio(int dir, int port, int data, unsigned long iobase)\r\n{\r\nif (dir) {\r\nwriteb(data, (void __iomem *)(iobase + port));\r\nreturn 0;\r\n} else {\r\nreturn readb((void __iomem *)(iobase + port));\r\n}\r\n}\r\nstatic void labpc_serial_out(struct comedi_device *dev, unsigned int value,\r\nunsigned int value_width)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->cmd5 &= ~CMD5_SCLK;\r\nif (value & (1 << (value_width - i)))\r\ndevpriv->cmd5 |= CMD5_SDATA;\r\nelse\r\ndevpriv->cmd5 &= ~CMD5_SDATA;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 |= CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\n}\r\n}\r\nstatic unsigned int labpc_serial_in(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value = 0;\r\nint i;\r\nconst int value_width = 8;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->cmd5 |= CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 &= ~CMD5_SCLK;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nudelay(1);\r\ndevpriv->stat2 = devpriv->read_byte(dev->iobase + STAT2_REG);\r\nif (devpriv->stat2 & STAT2_PROMOUT)\r\nvalue |= 1 << (value_width - i);\r\n}\r\nreturn value;\r\n}\r\nstatic unsigned int labpc_eeprom_read(struct comedi_device *dev,\r\nunsigned int address)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value;\r\nconst int read_instruction = 0x3;\r\nconst int write_length = 8;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nlabpc_serial_out(dev, read_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nreturn value;\r\n}\r\nstatic unsigned int labpc_eeprom_read_status(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int value;\r\nconst int read_status_instruction = 0x5;\r\nconst int write_length = 8;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nlabpc_serial_out(dev, read_status_instruction, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nreturn value;\r\n}\r\nstatic int labpc_eeprom_write(struct comedi_device *dev,\r\nunsigned int address, unsigned int value)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nconst int write_enable_instruction = 0x6;\r\nconst int write_instruction = 0x2;\r\nconst int write_length = 8;\r\nconst int write_in_progress_bit = 0x1;\r\nconst int timeout = 10000;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nif ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==\r\n0)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "eeprom write timed out");\r\nreturn -ETIME;\r\n}\r\ndevpriv->eeprom_data[address] = value;\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nlabpc_serial_out(dev, write_enable_instruction, write_length);\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 |= CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nlabpc_serial_out(dev, write_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nlabpc_serial_out(dev, value, write_length);\r\ndevpriv->cmd5 &= ~CMD5_EEPROMCS;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nreturn 0;\r\n}\r\nstatic void write_caldac(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nif (value == devpriv->caldac[channel])\r\nreturn;\r\ndevpriv->caldac[channel] = value;\r\ndevpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\nlabpc_serial_out(dev, channel, 4);\r\nlabpc_serial_out(dev, value, 8);\r\ndevpriv->cmd5 |= CMD5_CALDACLD;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->cmd5 &= ~CMD5_CALDACLD;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\n}\r\nstatic int labpc_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n > 0)\r\nwrite_caldac(dev, chan, data[insn->n - 1]);\r\nreturn insn->n;\r\n}\r\nstatic int labpc_calib_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->caldac[chan];\r\nreturn insn->n;\r\n}\r\nstatic int labpc_eeprom_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret;\r\nif (chan < 16 || chan > 127)\r\nreturn -EINVAL;\r\nif (insn->n > 0) {\r\nret = labpc_eeprom_write(dev, chan, data[insn->n - 1]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int labpc_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->eeprom_data[chan];\r\nreturn insn->n;\r\n}\r\nint labpc_common_attach(struct comedi_device *dev,\r\nunsigned int irq, unsigned long isr_flags)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nif (board->has_mmio) {\r\ndevpriv->read_byte = labpc_readb;\r\ndevpriv->write_byte = labpc_writeb;\r\n} else {\r\ndevpriv->read_byte = labpc_inb;\r\ndevpriv->write_byte = labpc_outb;\r\n}\r\ndevpriv->write_byte(devpriv->cmd1, dev->iobase + CMD1_REG);\r\ndevpriv->write_byte(devpriv->cmd2, dev->iobase + CMD2_REG);\r\ndevpriv->write_byte(devpriv->cmd3, dev->iobase + CMD3_REG);\r\ndevpriv->write_byte(devpriv->cmd4, dev->iobase + CMD4_REG);\r\nif (board->is_labpc1200) {\r\ndevpriv->write_byte(devpriv->cmd5, dev->iobase + CMD5_REG);\r\ndevpriv->write_byte(devpriv->cmd6, dev->iobase + CMD6_REG);\r\n}\r\nif (irq) {\r\nret = request_irq(irq, labpc_interrupt, isr_flags,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = irq;\r\n}\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->maxdata = 0x0fff;\r\ns->range_table = board->is_labpc1200\r\n? &range_labpc_1200_ai : &range_labpc_plus_ai;\r\ns->insn_read = labpc_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->do_cmd = labpc_ai_cmd;\r\ns->do_cmdtest = labpc_ai_cmdtest;\r\ns->cancel = labpc_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = NUM_AO_CHAN;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &range_labpc_ao;\r\ns->insn_read = labpc_ao_insn_read;\r\ns->insn_write = labpc_ao_insn_write;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nshort lsb, msb;\r\ndevpriv->ao_value[i] = s->maxdata / 2;\r\nlsb = devpriv->ao_value[i] & 0xff;\r\nmsb = (devpriv->ao_value[i] >> 8) & 0xff;\r\ndevpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));\r\ndevpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nret = subdev_8255_init(dev, s,\r\n(board->has_mmio) ? labpc_8255_mmio : NULL,\r\ndev->iobase + DIO_BASE_REG);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[3];\r\nif (board->is_labpc1200) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 16;\r\ns->maxdata = 0xff;\r\ns->insn_read = labpc_calib_insn_read;\r\ns->insn_write = labpc_calib_insn_write;\r\nfor (i = 0; i < s->n_chan; i++)\r\nwrite_caldac(dev, i, s->maxdata / 2);\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = &dev->subdevices[4];\r\nif (board->is_labpc1200) {\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = EEPROM_SIZE;\r\ns->maxdata = 0xff;\r\ns->insn_read = labpc_eeprom_insn_read;\r\ns->insn_write = labpc_eeprom_insn_write;\r\nfor (i = 0; i < s->n_chan; i++)\r\ndevpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\nreturn 0;\r\n}\r\nstatic int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct labpc_private *devpriv;\r\nunsigned int irq = it->options[1];\r\nunsigned int dma_chan = it->options[2];\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0], LABPC_SIZE);\r\nif (ret)\r\nreturn ret;\r\nret = labpc_common_attach(dev, irq, 0);\r\nif (ret)\r\nreturn ret;\r\nif (dev->irq)\r\nlabpc_init_dma_chan(dev, dma_chan);\r\nreturn 0;\r\n}\r\nstatic void labpc_detach(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nif (devpriv)\r\nlabpc_free_dma_chan(dev);\r\ncomedi_legacy_detach(dev);\r\n}\r\nstatic int __init labpc_common_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit labpc_common_exit(void)\r\n{\r\n}
