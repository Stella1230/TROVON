acpi_status acpi_tb_verify_table(struct acpi_table_desc *table_desc)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(tb_verify_table);\r\nif (!table_desc->pointer) {\r\nif ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==\r\nACPI_TABLE_ORIGIN_MAPPED) {\r\ntable_desc->pointer =\r\nacpi_os_map_memory(table_desc->address,\r\ntable_desc->length);\r\n}\r\nif (!table_desc->pointer) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\n}\r\nstatus =\r\nacpi_tb_verify_checksum(table_desc->pointer, table_desc->length);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_tb_add_table(struct acpi_table_desc *table_desc, u32 *table_index)\r\n{\r\nu32 i;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(tb_add_table);\r\nif (!table_desc->pointer) {\r\nstatus = acpi_tb_verify_table(table_desc);\r\nif (ACPI_FAILURE(status) || !table_desc->pointer) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\nif ((table_desc->pointer->signature[0] != 0x00) &&\r\n(!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))\r\n&& (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Table has invalid signature [%4.4s] (0x%8.8X), "\r\n"must be SSDT or OEMx",\r\nacpi_ut_valid_acpi_name(table_desc->pointer->\r\nsignature) ?\r\ntable_desc->pointer->signature : "????",\r\n*(u32 *)table_desc->pointer->signature));\r\nreturn_ACPI_STATUS(AE_BAD_SIGNATURE);\r\n}\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\nstatus =\r\nacpi_tb_verify_table(&acpi_gbl_root_table_list.\r\ntables[i]);\r\nif (ACPI_FAILURE(status)\r\n|| !acpi_gbl_root_table_list.tables[i].pointer) {\r\ncontinue;\r\n}\r\n}\r\nif (table_desc->length !=\r\nacpi_gbl_root_table_list.tables[i].length) {\r\ncontinue;\r\n}\r\nif (ACPI_MEMCMP(table_desc->pointer,\r\nacpi_gbl_root_table_list.tables[i].pointer,\r\nacpi_gbl_root_table_list.tables[i].length)) {\r\ncontinue;\r\n}\r\nacpi_tb_delete_table(table_desc);\r\n*table_index = i;\r\nif (acpi_gbl_root_table_list.tables[i].\r\nflags & ACPI_TABLE_IS_LOADED) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto release;\r\n} else {\r\ntable_desc->pointer =\r\nacpi_gbl_root_table_list.tables[i].pointer;\r\ntable_desc->address =\r\nacpi_gbl_root_table_list.tables[i].address;\r\nstatus = AE_OK;\r\ngoto print_header;\r\n}\r\n}\r\n(void)acpi_tb_table_override(table_desc->pointer, table_desc);\r\nstatus = acpi_tb_store_table(table_desc->address, table_desc->pointer,\r\ntable_desc->length, table_desc->flags,\r\ntable_index);\r\nif (ACPI_FAILURE(status)) {\r\ngoto release;\r\n}\r\nprint_header:\r\nacpi_tb_print_table_header(table_desc->address, table_desc->pointer);\r\nrelease:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstruct acpi_table_header *acpi_tb_table_override(struct acpi_table_header\r\n*table_header,\r\nstruct acpi_table_desc\r\n*table_desc)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_header *new_table = NULL;\r\nacpi_physical_address new_address = 0;\r\nu32 new_table_length = 0;\r\nu8 new_flags;\r\nchar *override_type;\r\nstatus = acpi_os_table_override(table_header, &new_table);\r\nif (ACPI_SUCCESS(status) && new_table) {\r\nnew_address = ACPI_PTR_TO_PHYSADDR(new_table);\r\nnew_table_length = new_table->length;\r\nnew_flags = ACPI_TABLE_ORIGIN_OVERRIDE;\r\noverride_type = "Logical";\r\ngoto finish_override;\r\n}\r\nstatus = acpi_os_physical_table_override(table_header,\r\n&new_address,\r\n&new_table_length);\r\nif (ACPI_SUCCESS(status) && new_address && new_table_length) {\r\nnew_table = acpi_os_map_memory(new_address, new_table_length);\r\nif (!new_table) {\r\nACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,\r\n"%4.4s %p Attempted physical table override failed",\r\ntable_header->signature,\r\nACPI_CAST_PTR(void,\r\ntable_desc->address)));\r\nreturn (NULL);\r\n}\r\noverride_type = "Physical";\r\nnew_flags = ACPI_TABLE_ORIGIN_MAPPED;\r\ngoto finish_override;\r\n}\r\nreturn (NULL);\r\nfinish_override:\r\nACPI_INFO((AE_INFO,\r\n"%4.4s %p %s table override, new table: %p",\r\ntable_header->signature,\r\nACPI_CAST_PTR(void, table_desc->address),\r\noverride_type, new_table));\r\nacpi_tb_delete_table(table_desc);\r\ntable_desc->address = new_address;\r\ntable_desc->pointer = new_table;\r\ntable_desc->length = new_table_length;\r\ntable_desc->flags = new_flags;\r\nreturn (new_table);\r\n}\r\nacpi_status acpi_tb_resize_root_table_list(void)\r\n{\r\nstruct acpi_table_desc *tables;\r\nu32 table_count;\r\nACPI_FUNCTION_TRACE(tb_resize_root_table_list);\r\nif (!(acpi_gbl_root_table_list.flags & ACPI_ROOT_ALLOW_RESIZE)) {\r\nACPI_ERROR((AE_INFO,\r\n"Resize of Root Table Array is not allowed"));\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\ntable_count = acpi_gbl_root_table_list.max_table_count;\r\n} else {\r\ntable_count = acpi_gbl_root_table_list.current_table_count;\r\n}\r\ntables = ACPI_ALLOCATE_ZEROED(((acpi_size) table_count +\r\nACPI_ROOT_TABLE_SIZE_INCREMENT) *\r\nsizeof(struct acpi_table_desc));\r\nif (!tables) {\r\nACPI_ERROR((AE_INFO,\r\n"Could not allocate new root table array"));\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\nif (acpi_gbl_root_table_list.tables) {\r\nACPI_MEMCPY(tables, acpi_gbl_root_table_list.tables,\r\n(acpi_size) table_count *\r\nsizeof(struct acpi_table_desc));\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\n}\r\nacpi_gbl_root_table_list.tables = tables;\r\nacpi_gbl_root_table_list.max_table_count =\r\ntable_count + ACPI_ROOT_TABLE_SIZE_INCREMENT;\r\nacpi_gbl_root_table_list.flags |= ACPI_ROOT_ORIGIN_ALLOCATED;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_tb_store_table(acpi_physical_address address,\r\nstruct acpi_table_header *table,\r\nu32 length, u8 flags, u32 *table_index)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_desc *new_table;\r\nif (acpi_gbl_root_table_list.current_table_count >=\r\nacpi_gbl_root_table_list.max_table_count) {\r\nstatus = acpi_tb_resize_root_table_list();\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\nnew_table =\r\n&acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.\r\ncurrent_table_count];\r\nnew_table->address = address;\r\nnew_table->pointer = table;\r\nnew_table->length = length;\r\nnew_table->owner_id = 0;\r\nnew_table->flags = flags;\r\nACPI_MOVE_32_TO_32(&new_table->signature, table->signature);\r\n*table_index = acpi_gbl_root_table_list.current_table_count;\r\nacpi_gbl_root_table_list.current_table_count++;\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_tb_delete_table(struct acpi_table_desc *table_desc)\r\n{\r\nif (!table_desc->pointer) {\r\nreturn;\r\n}\r\nswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_MAPPED:\r\nacpi_os_unmap_memory(table_desc->pointer, table_desc->length);\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_ALLOCATED:\r\nACPI_FREE(table_desc->pointer);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ntable_desc->pointer = NULL;\r\n}\r\nvoid acpi_tb_terminate(void)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_TRACE(tb_terminate);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\nacpi_tb_delete_table(&acpi_gbl_root_table_list.tables[i]);\r\n}\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nACPI_FREE(acpi_gbl_root_table_list.tables);\r\n}\r\nacpi_gbl_root_table_list.tables = NULL;\r\nacpi_gbl_root_table_list.flags = 0;\r\nacpi_gbl_root_table_list.current_table_count = 0;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "ACPI Tables freed\n"));\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_VOID;\r\n}\r\nacpi_status acpi_tb_delete_namespace_by_owner(u32 table_index)\r\n{\r\nacpi_owner_id owner_id;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_delete_namespace_by_owner);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nowner_id = acpi_gbl_root_table_list.tables[table_index].owner_id;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_INTERPRETER);\r\nstatus = acpi_ut_acquire_write_lock(&acpi_gbl_namespace_rw_lock);\r\nacpi_ns_delete_namespace_by_owner(owner_id);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_ut_release_write_lock(&acpi_gbl_namespace_rw_lock);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_INTERPRETER);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_allocate_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_allocate_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nstatus = acpi_ut_allocate_owner_id\r\n(&(acpi_gbl_root_table_list.tables[table_index].owner_id));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_release_owner_id(u32 table_index)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_release_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nacpi_ut_release_owner_id(&\r\n(acpi_gbl_root_table_list.\r\ntables[table_index].owner_id));\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_tb_get_owner_id(u32 table_index, acpi_owner_id *owner_id)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nACPI_FUNCTION_TRACE(tb_get_owner_id);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\n*owner_id =\r\nacpi_gbl_root_table_list.tables[table_index].owner_id;\r\nstatus = AE_OK;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nu8 acpi_tb_is_table_loaded(u32 table_index)\r\n{\r\nu8 is_loaded = FALSE;\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nis_loaded = (u8)\r\n(acpi_gbl_root_table_list.tables[table_index].flags &\r\nACPI_TABLE_IS_LOADED);\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn (is_loaded);\r\n}\r\nvoid acpi_tb_set_table_loaded_flag(u32 table_index, u8 is_loaded)\r\n{\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index < acpi_gbl_root_table_list.current_table_count) {\r\nif (is_loaded) {\r\nacpi_gbl_root_table_list.tables[table_index].flags |=\r\nACPI_TABLE_IS_LOADED;\r\n} else {\r\nacpi_gbl_root_table_list.tables[table_index].flags &=\r\n~ACPI_TABLE_IS_LOADED;\r\n}\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\n}
