static u32 emulate_ioc3_cfg(int where, int size)\r\n{\r\nif (size == 1 && where == 0x3d)\r\nreturn 0x01;\r\nelse if (size == 2 && where == 0x3c)\r\nreturn 0x0100;\r\nelse if (size == 4 && where == 0x3c)\r\nreturn 0x00000100;\r\nreturn 0;\r\n}\r\nstatic int pci_conf0_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 * value)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(bus);\r\nbridge_t *bridge = bc->base;\r\nint slot = PCI_SLOT(devfn);\r\nint fn = PCI_FUNC(devfn);\r\nvolatile void *addr;\r\nu32 cf, shift, mask;\r\nint res;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].c[PCI_VENDOR_ID];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))\r\ngoto oh_my_gawd;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].c[where ^ (4 - size)];\r\nif (size == 1)\r\nres = get_dbe(*value, (u8 *) addr);\r\nelse if (size == 2)\r\nres = get_dbe(*value, (u16 *) addr);\r\nelse\r\nres = get_dbe(*value, (u32 *) addr);\r\nreturn res ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\noh_my_gawd:\r\nif ((where >= 0x14 && where < 0x40) || (where >= 0x48)) {\r\n*value = emulate_ioc3_cfg(where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nshift = ((where & 3) << 3);\r\nmask = (0xffffffffU >> ((4 - size) << 3));\r\n*value = (cf >> shift) & mask;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_conf1_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 * value)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(bus);\r\nbridge_t *bridge = bc->base;\r\nint busno = bus->number;\r\nint slot = PCI_SLOT(devfn);\r\nint fn = PCI_FUNC(devfn);\r\nvolatile void *addr;\r\nu32 cf, shift, mask;\r\nint res;\r\nbridge->b_pci_cfg = (busno << 16) | (slot << 11);\r\naddr = &bridge->b_type1_cfg.c[(fn << 8) | PCI_VENDOR_ID];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))\r\ngoto oh_my_gawd;\r\nbridge->b_pci_cfg = (busno << 16) | (slot << 11);\r\naddr = &bridge->b_type1_cfg.c[(fn << 8) | (where ^ (4 - size))];\r\nif (size == 1)\r\nres = get_dbe(*value, (u8 *) addr);\r\nelse if (size == 2)\r\nres = get_dbe(*value, (u16 *) addr);\r\nelse\r\nres = get_dbe(*value, (u32 *) addr);\r\nreturn res ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\noh_my_gawd:\r\nif ((where >= 0x14 && where < 0x40) || (where >= 0x48)) {\r\n*value = emulate_ioc3_cfg(where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nbridge->b_pci_cfg = (busno << 16) | (slot << 11);\r\naddr = &bridge->b_type1_cfg.c[(fn << 8) | where];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nshift = ((where & 3) << 3);\r\nmask = (0xffffffffU >> ((4 - size) << 3));\r\n*value = (cf >> shift) & mask;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 * value)\r\n{\r\nif (bus->number > 0)\r\nreturn pci_conf1_read_config(bus, devfn, where, size, value);\r\nreturn pci_conf0_read_config(bus, devfn, where, size, value);\r\n}\r\nstatic int pci_conf0_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(bus);\r\nbridge_t *bridge = bc->base;\r\nint slot = PCI_SLOT(devfn);\r\nint fn = PCI_FUNC(devfn);\r\nvolatile void *addr;\r\nu32 cf, shift, mask, smask;\r\nint res;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].c[PCI_VENDOR_ID];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))\r\ngoto oh_my_gawd;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].c[where ^ (4 - size)];\r\nif (size == 1) {\r\nres = put_dbe(value, (u8 *) addr);\r\n} else if (size == 2) {\r\nres = put_dbe(value, (u16 *) addr);\r\n} else {\r\nres = put_dbe(value, (u32 *) addr);\r\n}\r\nif (res)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\noh_my_gawd:\r\nif ((where >= 0x14 && where < 0x40) || (where >= 0x48))\r\nreturn PCIBIOS_SUCCESSFUL;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nshift = ((where & 3) << 3);\r\nmask = (0xffffffffU >> ((4 - size) << 3));\r\nsmask = mask << shift;\r\ncf = (cf & ~smask) | ((value & mask) << shift);\r\nif (put_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_conf1_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct bridge_controller *bc = BRIDGE_CONTROLLER(bus);\r\nbridge_t *bridge = bc->base;\r\nint slot = PCI_SLOT(devfn);\r\nint fn = PCI_FUNC(devfn);\r\nint busno = bus->number;\r\nvolatile void *addr;\r\nu32 cf, shift, mask, smask;\r\nint res;\r\nbridge->b_pci_cfg = (busno << 16) | (slot << 11);\r\naddr = &bridge->b_type1_cfg.c[(fn << 8) | PCI_VENDOR_ID];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (cf == (PCI_VENDOR_ID_SGI | (PCI_DEVICE_ID_SGI_IOC3 << 16)))\r\ngoto oh_my_gawd;\r\naddr = &bridge->b_type1_cfg.c[(fn << 8) | (where ^ (4 - size))];\r\nif (size == 1) {\r\nres = put_dbe(value, (u8 *) addr);\r\n} else if (size == 2) {\r\nres = put_dbe(value, (u16 *) addr);\r\n} else {\r\nres = put_dbe(value, (u32 *) addr);\r\n}\r\nif (res)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\noh_my_gawd:\r\nif ((where >= 0x14 && where < 0x40) || (where >= 0x48))\r\nreturn PCIBIOS_SUCCESSFUL;\r\naddr = &bridge->b_type0_cfg_dev[slot].f[fn].l[where >> 2];\r\nif (get_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nshift = ((where & 3) << 3);\r\nmask = (0xffffffffU >> ((4 - size) << 3));\r\nsmask = mask << shift;\r\ncf = (cf & ~smask) | ((value & mask) << shift);\r\nif (put_dbe(cf, (u32 *) addr))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nif (bus->number > 0)\r\nreturn pci_conf1_write_config(bus, devfn, where, size, value);\r\nreturn pci_conf0_write_config(bus, devfn, where, size, value);\r\n}
