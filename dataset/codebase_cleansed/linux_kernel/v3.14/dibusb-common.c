int dibusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.fifo_ctrl != NULL)\r\nif (st->ops.fifo_ctrl(adap->fe_adap[0].fe, onoff)) {\r\nerr("error while controlling the fifo of the demod.");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.pid_ctrl != NULL)\r\nst->ops.pid_ctrl(adap->fe_adap[0].fe,\r\nindex, pid, onoff);\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.pid_parse != NULL)\r\nif (st->ops.pid_parse(adap->fe_adap[0].fe, onoff) < 0)\r\nerr("could not handle pid_parser");\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 b[3];\r\nint ret;\r\nb[0] = DIBUSB_REQ_SET_IOCTL;\r\nb[1] = DIBUSB_IOCTL_CMD_POWER_MODE;\r\nb[2] = onoff ? DIBUSB_IOCTL_POWER_WAKEUP : DIBUSB_IOCTL_POWER_SLEEP;\r\nret = dvb_usb_generic_write(d,b,3);\r\nmsleep(10);\r\nreturn ret;\r\n}\r\nint dibusb2_0_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nu8 b[3] = { 0 };\r\nint ret;\r\nif ((ret = dibusb_streaming_ctrl(adap,onoff)) < 0)\r\nreturn ret;\r\nif (onoff) {\r\nb[0] = DIBUSB_REQ_SET_STREAMING_MODE;\r\nb[1] = 0x00;\r\nif ((ret = dvb_usb_generic_write(adap->dev,b,2)) < 0)\r\nreturn ret;\r\n}\r\nb[0] = DIBUSB_REQ_SET_IOCTL;\r\nb[1] = onoff ? DIBUSB_IOCTL_CMD_ENABLE_STREAM : DIBUSB_IOCTL_CMD_DISABLE_STREAM;\r\nreturn dvb_usb_generic_write(adap->dev,b,3);\r\n}\r\nint dibusb2_0_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nif (onoff) {\r\nu8 b[3] = { DIBUSB_REQ_SET_IOCTL, DIBUSB_IOCTL_CMD_POWER_MODE, DIBUSB_IOCTL_POWER_WAKEUP };\r\nreturn dvb_usb_generic_write(d,b,3);\r\n} else\r\nreturn 0;\r\n}\r\nstatic int dibusb_i2c_msg(struct dvb_usb_device *d, u8 addr,\r\nu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\r\n{\r\nu8 sndbuf[MAX_XFER_SIZE];\r\nint wo = (rbuf == NULL || rlen == 0),\r\nlen = 2 + wlen + (wo ? 0 : 2);\r\nif (4 + wlen > sizeof(sndbuf)) {\r\nwarn("i2c wr: len=%d is too big!\n", wlen);\r\nreturn -EOPNOTSUPP;\r\n}\r\nsndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;\r\nsndbuf[1] = (addr << 1) | (wo ? 0 : 1);\r\nmemcpy(&sndbuf[2],wbuf,wlen);\r\nif (!wo) {\r\nsndbuf[wlen+2] = (rlen >> 8) & 0xff;\r\nsndbuf[wlen+3] = rlen & 0xff;\r\n}\r\nreturn dvb_usb_generic_rw(d,sndbuf,len,rbuf,rlen,0);\r\n}\r\nstatic int dibusb_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (i+1 < num && (msg[i].flags & I2C_M_RD) == 0\r\n&& (msg[i+1].flags & I2C_M_RD)) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,\r\nmsg[i+1].buf,msg[i+1].len) < 0)\r\nbreak;\r\ni++;\r\n} else if ((msg[i].flags & I2C_M_RD) == 0) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,NULL,0) < 0)\r\nbreak;\r\n} else if (msg[i].addr != 0x50) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, NULL, 0, msg[i].buf, msg[i].len) < 0)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 dibusb_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)\r\n{\r\nu8 wbuf[1] = { offs };\r\nreturn dibusb_i2c_msg(d, 0x50, wbuf, 1, val, 1);\r\n}\r\nint dibusb_dib3000mc_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (adap->dev->udev->descriptor.idVendor == USB_VID_LITEON &&\r\nadap->dev->udev->descriptor.idProduct ==\r\nUSB_PID_LITEON_DVB_T_WARM) {\r\nmsleep(1000);\r\n}\r\nadap->fe_adap[0].fe = dvb_attach(dib3000mc_attach,\r\n&adap->dev->i2c_adap,\r\nDEFAULT_DIB3000P_I2C_ADDRESS,\r\n&mod3000p_dib3000p_config);\r\nif ((adap->fe_adap[0].fe) == NULL)\r\nadap->fe_adap[0].fe = dvb_attach(dib3000mc_attach,\r\n&adap->dev->i2c_adap,\r\nDEFAULT_DIB3000MC_I2C_ADDRESS,\r\n&mod3000p_dib3000p_config);\r\nif ((adap->fe_adap[0].fe) != NULL) {\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nst->ops.pid_parse = dib3000mc_pid_parse;\r\nst->ops.pid_ctrl = dib3000mc_pid_control;\r\n}\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint dibusb_dib3000mc_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dibusb_state *st = adap->priv;\r\nu8 a,b;\r\nu16 if1 = 1220;\r\nstruct i2c_adapter *tun_i2c;\r\nif (adap->dev->udev->descriptor.idVendor == USB_VID_LITEON &&\r\nadap->dev->udev->descriptor.idProduct == USB_PID_LITEON_DVB_T_WARM) {\r\ndibusb_read_eeprom_byte(adap->dev,0x7E,&a);\r\ndibusb_read_eeprom_byte(adap->dev,0x7F,&b);\r\nif (a == 0x00)\r\nif1 += b;\r\nelse if (a == 0x80)\r\nif1 -= b;\r\nelse\r\nwarn("LITE-ON DVB-T: Strange IF1 calibration :%2X %2X\n", a, b);\r\n} else if (adap->dev->udev->descriptor.idVendor == USB_VID_DIBCOM &&\r\nadap->dev->udev->descriptor.idProduct == USB_PID_DIBCOM_MOD3001_WARM) {\r\nu8 desc;\r\ndibusb_read_eeprom_byte(adap->dev, 7, &desc);\r\nif (desc == 2) {\r\na = 127;\r\ndo {\r\ndibusb_read_eeprom_byte(adap->dev, a, &desc);\r\na--;\r\n} while (a > 7 && (desc == 0xff || desc == 0x00));\r\nif (desc & 0x80)\r\nif1 -= (0xff - desc);\r\nelse\r\nif1 += desc;\r\n}\r\n}\r\ntun_i2c = dib3000mc_get_tuner_i2c_master(adap->fe_adap[0].fe, 1);\r\nif (dvb_attach(mt2060_attach, adap->fe_adap[0].fe, tun_i2c, &stk3000p_mt2060_config, if1) == NULL) {\r\nif (dvb_attach(dvb_pll_attach, adap->fe_adap[0].fe, 0x60, tun_i2c, DVB_PLL_ENV57H1XD5) == NULL)\r\nreturn -ENOMEM;\r\n} else {\r\nst->mt2060_present = 1;\r\ndib3000mc_set_config(adap->fe_adap[0].fe, &stk3000p_dib3000p_config);\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nu8 key[5],cmd = DIBUSB_REQ_POLL_REMOTE;\r\ndvb_usb_generic_rw(d,&cmd,1,key,5,0);\r\ndvb_usb_nec_rc_key_to_event(d,key,event,state);\r\nif (key[0] != 0)\r\ndeb_info("key: %*ph\n", 5, key);\r\nreturn 0;\r\n}
