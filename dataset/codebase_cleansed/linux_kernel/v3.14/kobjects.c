static ssize_t chars_chartab_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nint i;\r\nint len = 0;\r\nchar *cp;\r\nchar *buf_pointer = buf;\r\nsize_t bufsize = PAGE_SIZE;\r\nunsigned long flags;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\n*buf_pointer = '\0';\r\nfor (i = 0; i < 256; i++) {\r\nif (bufsize <= 1)\r\nbreak;\r\nif (strcmp("characters", attr->attr.name) == 0) {\r\nlen = scnprintf(buf_pointer, bufsize, "%d\t%s\n",\r\ni, spk_characters[i]);\r\n} else {\r\nif (IS_TYPE(i, B_CTL))\r\ncp = "B_CTL";\r\nelse if (IS_TYPE(i, WDLM))\r\ncp = "WDLM";\r\nelse if (IS_TYPE(i, A_PUNC))\r\ncp = "A_PUNC";\r\nelse if (IS_TYPE(i, PUNC))\r\ncp = "PUNC";\r\nelse if (IS_TYPE(i, NUM))\r\ncp = "NUM";\r\nelse if (IS_TYPE(i, A_CAP))\r\ncp = "A_CAP";\r\nelse if (IS_TYPE(i, ALPHA))\r\ncp = "ALPHA";\r\nelse if (IS_TYPE(i, B_CAPSYM))\r\ncp = "B_CAPSYM";\r\nelse if (IS_TYPE(i, B_SYM))\r\ncp = "B_SYM";\r\nelse\r\ncp = "0";\r\nlen =\r\nscnprintf(buf_pointer, bufsize, "%d\t%s\n", i, cp);\r\n}\r\nbufsize -= len;\r\nbuf_pointer += len;\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn buf_pointer - buf;\r\n}\r\nstatic void report_char_chartab_status(int reset, int received, int used,\r\nint rejected, int do_characters)\r\n{\r\nchar *object_type[] = {\r\n"character class entries",\r\n"character descriptions",\r\n};\r\nint len;\r\nchar buf[80];\r\nif (reset) {\r\npr_info("%s reset to defaults\n", object_type[do_characters]);\r\n} else if (received) {\r\nlen = snprintf(buf, sizeof(buf),\r\n" updated %d of %d %s\n",\r\nused, received, object_type[do_characters]);\r\nif (rejected)\r\nsnprintf(buf + (len - 1), sizeof(buf) - (len - 1),\r\n" with %d reject%s\n",\r\nrejected, rejected > 1 ? "s" : "");\r\nprintk(buf);\r\n}\r\n}\r\nstatic ssize_t chars_chartab_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr, const char *buf, size_t count)\r\n{\r\nchar *cp = (char *) buf;\r\nchar *end = cp + count;\r\nchar *linefeed = NULL;\r\nchar keyword[MAX_DESC_LEN + 1];\r\nchar *outptr = NULL;\r\nchar *temp = NULL;\r\nchar *desc = NULL;\r\nssize_t retval = count;\r\nunsigned long flags;\r\nunsigned long index = 0;\r\nint charclass = 0;\r\nint received = 0;\r\nint used = 0;\r\nint rejected = 0;\r\nint reset = 0;\r\nint do_characters = !strcmp(attr->attr.name, "characters");\r\nsize_t desc_length = 0;\r\nint i;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nwhile (cp < end) {\r\nwhile ((cp < end) && (*cp == ' ' || *cp == '\t'))\r\ncp++;\r\nif (cp == end)\r\nbreak;\r\nif ((*cp == '\n') || strchr("dDrR", *cp)) {\r\nreset = 1;\r\nbreak;\r\n}\r\nreceived++;\r\nlinefeed = strchr(cp, '\n');\r\nif (!linefeed) {\r\nrejected++;\r\nbreak;\r\n}\r\nif (!isdigit(*cp)) {\r\nrejected++;\r\ncp = linefeed + 1;\r\ncontinue;\r\n}\r\nindex = simple_strtoul(cp, &temp, 10);\r\nif (index > 255) {\r\nrejected++;\r\ncp = linefeed + 1;\r\ncontinue;\r\n}\r\nwhile ((temp < linefeed) && (*temp == ' ' || *temp == '\t'))\r\ntemp++;\r\ndesc_length = linefeed - temp;\r\nif (desc_length > MAX_DESC_LEN) {\r\nrejected++;\r\ncp = linefeed + 1;\r\ncontinue;\r\n}\r\nif (do_characters) {\r\ndesc = kmalloc(desc_length + 1, GFP_ATOMIC);\r\nif (!desc) {\r\nretval = -ENOMEM;\r\nreset = 1;\r\nbreak;\r\n}\r\noutptr = desc;\r\n} else {\r\noutptr = keyword;\r\n}\r\nfor (i = 0; i < desc_length; i++)\r\noutptr[i] = temp[i];\r\noutptr[desc_length] = '\0';\r\nif (do_characters) {\r\nif (spk_characters[index] != spk_default_chars[index])\r\nkfree(spk_characters[index]);\r\nspk_characters[index] = desc;\r\nused++;\r\n} else {\r\ncharclass = spk_chartab_get_value(keyword);\r\nif (charclass == 0) {\r\nrejected++;\r\ncp = linefeed + 1;\r\ncontinue;\r\n}\r\nif (charclass != spk_chartab[index]) {\r\nspk_chartab[index] = charclass;\r\nused++;\r\n}\r\n}\r\ncp = linefeed + 1;\r\n}\r\nif (reset) {\r\nif (do_characters)\r\nspk_reset_default_chars();\r\nelse\r\nspk_reset_default_chartab();\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreport_char_chartab_status(reset, received, used, rejected,\r\ndo_characters);\r\nreturn retval;\r\n}\r\nstatic ssize_t keymap_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nchar *cp = buf;\r\nint i;\r\nint n;\r\nint num_keys;\r\nint nstates;\r\nu_char *cp1;\r\nu_char ch;\r\nunsigned long flags;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\ncp1 = spk_key_buf + SHIFT_TBL_SIZE;\r\nnum_keys = (int)(*cp1);\r\nnstates = (int)cp1[1];\r\ncp += sprintf(cp, "%d, %d, %d,\n", KEY_MAP_VER, num_keys, nstates);\r\ncp1 += 2;\r\nfor (n = 0; n <= num_keys; n++) {\r\nfor (i = 0; i <= nstates; i++) {\r\nch = *cp1++;\r\ncp += sprintf(cp, "%d,", (int)ch);\r\n*cp++ = (i < nstates) ? SPACE : '\n';\r\n}\r\n}\r\ncp += sprintf(cp, "0, %d\n", KEY_MAP_VER);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn (int)(cp-buf);\r\n}\r\nstatic ssize_t keymap_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nssize_t ret = count;\r\nchar *in_buff = NULL;\r\nchar *cp;\r\nu_char *cp1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nin_buff = kmemdup(buf, count + 1, GFP_ATOMIC);\r\nif (!in_buff) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn -ENOMEM;\r\n}\r\nif (strchr("dDrR", *in_buff)) {\r\nspk_set_key_info(spk_key_defaults, spk_key_buf);\r\npr_info("keymap set to default values\n");\r\nkfree(in_buff);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn count;\r\n}\r\nif (in_buff[count - 1] == '\n')\r\nin_buff[count - 1] = '\0';\r\ncp = in_buff;\r\ncp1 = (u_char *)in_buff;\r\nfor (i = 0; i < 3; i++) {\r\ncp = spk_s2uchar(cp, cp1);\r\ncp1++;\r\n}\r\ni = (int)cp1[-2]+1;\r\ni *= (int)cp1[-1]+1;\r\ni += 2;\r\nif (cp1[-3] != KEY_MAP_VER || cp1[-1] > 10 ||\r\ni+SHIFT_TBL_SIZE+4 >= sizeof(spk_key_buf)) {\r\npr_warn("i %d %d %d %d\n", i,\r\n(int)cp1[-3], (int)cp1[-2], (int)cp1[-1]);\r\nkfree(in_buff);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn -EINVAL;\r\n}\r\nwhile (--i >= 0) {\r\ncp = spk_s2uchar(cp, cp1);\r\ncp1++;\r\nif (!(*cp))\r\nbreak;\r\n}\r\nif (i != 0 || cp1[-1] != KEY_MAP_VER || cp1[-2] != 0) {\r\nret = -EINVAL;\r\npr_warn("end %d %d %d %d\n", i,\r\n(int)cp1[-3], (int)cp1[-2], (int)cp1[-1]);\r\n} else {\r\nif (spk_set_key_info(in_buff, spk_key_buf)) {\r\nspk_set_key_info(spk_key_defaults, spk_key_buf);\r\nret = -EINVAL;\r\npr_warn("set key failed\n");\r\n}\r\n}\r\nkfree(in_buff);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t silent_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint len;\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nchar ch = 0;\r\nchar shut;\r\nunsigned long flags;\r\nlen = strlen(buf);\r\nif (len > 0 && len < 3) {\r\nch = buf[0];\r\nif (ch == '\n')\r\nch = '0';\r\n}\r\nif (ch < '0' || ch > '7') {\r\npr_warn("silent value '%c' not in range (0,7)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (ch&2) {\r\nshut = 1;\r\nspk_do_flush();\r\n} else {\r\nshut = 0;\r\n}\r\nif (ch&4)\r\nshut |= 0x40;\r\nif (ch&1)\r\nspk_shut_up |= shut;\r\nelse\r\nspk_shut_up &= ~shut;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t synth_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nint rv;\r\nif (synth == NULL)\r\nrv = sprintf(buf, "%s\n", "none");\r\nelse\r\nrv = sprintf(buf, "%s\n", synth->name);\r\nreturn rv;\r\n}\r\nstatic ssize_t synth_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint len;\r\nchar new_synth_name[10];\r\nlen = strlen(buf);\r\nif (len < 2 || len > 9)\r\nreturn -EINVAL;\r\nstrncpy(new_synth_name, buf, len);\r\nif (new_synth_name[len - 1] == '\n')\r\nlen--;\r\nnew_synth_name[len] = '\0';\r\nspk_strlwr(new_synth_name);\r\nif ((synth != NULL) && (!strcmp(new_synth_name, synth->name))) {\r\npr_warn("%s already in use\n", new_synth_name);\r\n} else if (synth_init(new_synth_name) != 0) {\r\npr_warn("failed to init synth %s\n", new_synth_name);\r\nreturn -ENODEV;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t synth_direct_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr, const char *buf, size_t count)\r\n{\r\nu_char tmp[256];\r\nint len;\r\nint bytes;\r\nconst char *ptr = buf;\r\nif (!synth)\r\nreturn -EPERM;\r\nlen = strlen(buf);\r\nwhile (len > 0) {\r\nbytes = min_t(size_t, len, 250);\r\nstrncpy(tmp, ptr, bytes);\r\ntmp[bytes] = '\0';\r\nstring_unescape_any_inplace(tmp);\r\nsynth_printf("%s", tmp);\r\nptr += bytes;\r\nlen -= bytes;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t version_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nchar *cp;\r\ncp = buf;\r\ncp += sprintf(cp, "Speakup version %s\n", SPEAKUP_VERSION);\r\nif (synth)\r\ncp += sprintf(cp, "%s synthesizer driver version %s\n",\r\nsynth->name, synth->version);\r\nreturn cp - buf;\r\n}\r\nstatic ssize_t punc_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nint i;\r\nchar *cp = buf;\r\nstruct st_var_header *p_header;\r\nstruct punc_var_t *var;\r\nstruct st_bits_data *pb;\r\nshort mask;\r\nunsigned long flags;\r\np_header = spk_var_header_by_name(attr->attr.name);\r\nif (p_header == NULL) {\r\npr_warn("p_header is null, attr->attr.name is %s\n",\r\nattr->attr.name);\r\nreturn -EINVAL;\r\n}\r\nvar = spk_get_punc_var(p_header->var_id);\r\nif (var == NULL) {\r\npr_warn("var is null, p_header->var_id is %i\n",\r\np_header->var_id);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\npb = (struct st_bits_data *) &spk_punc_info[var->value];\r\nmask = pb->mask;\r\nfor (i = 33; i < 128; i++) {\r\nif (!(spk_chartab[i]&mask))\r\ncontinue;\r\n*cp++ = (char)i;\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn cp-buf;\r\n}\r\nstatic ssize_t punc_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint x;\r\nstruct st_var_header *p_header;\r\nstruct punc_var_t *var;\r\nchar punc_buf[100];\r\nunsigned long flags;\r\nx = strlen(buf);\r\nif (x < 1 || x > 99)\r\nreturn -EINVAL;\r\np_header = spk_var_header_by_name(attr->attr.name);\r\nif (p_header == NULL) {\r\npr_warn("p_header is null, attr->attr.name is %s\n",\r\nattr->attr.name);\r\nreturn -EINVAL;\r\n}\r\nvar = spk_get_punc_var(p_header->var_id);\r\nif (var == NULL) {\r\npr_warn("var is null, p_header->var_id is %i\n",\r\np_header->var_id);\r\nreturn -EINVAL;\r\n}\r\nstrncpy(punc_buf, buf, x);\r\nwhile (x && punc_buf[x - 1] == '\n')\r\nx--;\r\npunc_buf[x] = '\0';\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (*punc_buf == 'd' || *punc_buf == 'r')\r\nx = spk_set_mask_bits(NULL, var->value, 3);\r\nelse\r\nx = spk_set_mask_bits(punc_buf, var->value, 3);\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn count;\r\n}\r\nssize_t spk_var_show(struct kobject *kobj, struct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nint rv = 0;\r\nstruct st_var_header *param;\r\nstruct var_t *var;\r\nchar *cp1;\r\nchar *cp;\r\nchar ch;\r\nunsigned long flags;\r\nparam = spk_var_header_by_name(attr->attr.name);\r\nif (param == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nvar = (struct var_t *) param->data;\r\nswitch (param->var_type) {\r\ncase VAR_NUM:\r\ncase VAR_TIME:\r\nif (var)\r\nrv = sprintf(buf, "%i\n", var->u.n.value);\r\nelse\r\nrv = sprintf(buf, "0\n");\r\nbreak;\r\ncase VAR_STRING:\r\nif (var) {\r\ncp1 = buf;\r\n*cp1++ = '"';\r\nfor (cp = (char *)param->p_val; (ch = *cp); cp++) {\r\nif (ch >= ' ' && ch < '~')\r\n*cp1++ = ch;\r\nelse\r\ncp1 += sprintf(cp1, "\\""x%02x", ch);\r\n}\r\n*cp1++ = '"';\r\n*cp1++ = '\n';\r\n*cp1 = '\0';\r\nrv = cp1-buf;\r\n} else {\r\nrv = sprintf(buf, "\"\"\n");\r\n}\r\nbreak;\r\ndefault:\r\nrv = sprintf(buf, "Bad parameter %s, type %i\n",\r\nparam->name, param->var_type);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nreturn rv;\r\n}\r\nEXPORT_SYMBOL_GPL(spk_var_show);\r\n/*\r\n* Used to reset either default_pitch or default_vol.\r\n*/\r\nstatic inline void spk_reset_default_value(char *header_name,\r\nint *synth_default_value, int idx)\r\n{\r\nstruct st_var_header *param;\r\nif (synth && synth_default_value) {\r\nparam = spk_var_header_by_name(header_name);\r\nif (param) {\r\nspk_set_num_var(synth_default_value[idx],\r\nparam, E_NEW_DEFAULT);\r\nspk_set_num_var(0, param, E_DEFAULT);\r\npr_info("%s reset to default value\n", param->name);\r\n}\r\n}\r\n}\r\n/*\r\n* This function is called when a user echos a value to one of the\r\n* variable parameters.\r\n*/\r\nssize_t spk_var_store(struct kobject *kobj, struct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct st_var_header *param;\r\nint ret;\r\nint len;\r\nchar *cp;\r\nstruct var_t *var_data;\r\nlong value;\r\nunsigned long flags;\r\nparam = spk_var_header_by_name(attr->attr.name);\r\nif (param == NULL)\r\nreturn -EINVAL;\r\nif (param->data == NULL)\r\nreturn 0;\r\nret = 0;\r\ncp = (char *)buf;\r\nstring_unescape_any_inplace(cp);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nswitch (param->var_type) {\r\ncase VAR_NUM:\r\ncase VAR_TIME:\r\nif (*cp == 'd' || *cp == 'r' || *cp == '\0')\r\nlen = E_DEFAULT;\r\nelse if (*cp == '+' || *cp == '-')\r\nlen = E_INC;\r\nelse\r\nlen = E_SET;\r\nif (kstrtol(cp, 10, &value) == 0)\r\nret = spk_set_num_var(value, param, len);\r\nelse\r\npr_warn("overflow or parsing error has occured");\r\nif (ret == -ERANGE) {\r\nvar_data = param->data;\r\npr_warn("value for %s out of range, expect %d to %d\n",\r\nparam->name,\r\nvar_data->u.n.low, var_data->u.n.high);\r\n}\r\n/*\r\n* If voice was just changed, we might need to reset our default\r\n* pitch and volume.\r\n*/\r\nif (param->var_id == VOICE && synth &&\r\n(ret == 0 || ret == -ERESTART)) {\r\nvar_data = param->data;\r\nvalue = var_data->u.n.value;\r\nspk_reset_default_value("pitch", synth->default_pitch,\r\nvalue);\r\nspk_reset_default_value("vol", synth->default_vol,\r\nvalue);\r\n}\r\nbreak;\r\ncase VAR_STRING:\r\nlen = strlen(cp);\r\nif ((len >= 1) && (cp[len - 1] == '\n'))\r\n--len;\r\nif ((len >= 2) && (cp[0] == '"') && (cp[len - 1] == '"')) {\r\n++cp;\r\nlen -= 2;\r\n}\r\ncp[len] = '\0';\r\nret = spk_set_string_var(cp, param, len);\r\nif (ret == -E2BIG)\r\npr_warn("value too long for %s\n",\r\nparam->name);\r\nbreak;\r\ndefault:\r\npr_warn("%s unknown type %d\n",\r\nparam->name, (int)param->var_type);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ret == -ERESTART)\r\npr_info("%s reset to default value\n", param->name);\r\nreturn count;\r\n}\r\nEXPORT_SYMBOL_GPL(spk_var_store);\r\n/*\r\n* Functions for reading and writing lists of i18n messages. Incomplete.\r\n*/\r\nstatic ssize_t message_show_helper(char *buf, enum msg_index_t first,\r\nenum msg_index_t last)\r\n{\r\nsize_t bufsize = PAGE_SIZE;\r\nchar *buf_pointer = buf;\r\nint printed;\r\nenum msg_index_t cursor;\r\nint index = 0;\r\n*buf_pointer = '\0'; /* buf_pointer always looking at a NUL byte. */\r\nfor (cursor = first; cursor <= last; cursor++, index++) {\r\nif (bufsize <= 1)\r\nbreak;\r\nprinted = scnprintf(buf_pointer, bufsize, "%d\t%s\n",\r\nindex, spk_msg_get(cursor));\r\nbuf_pointer += printed;\r\nbufsize -= printed;\r\n}\r\nreturn buf_pointer - buf;\r\n}\r\nstatic void report_msg_status(int reset, int received, int used,\r\nint rejected, char *groupname)\r\n{\r\nint len;\r\nchar buf[160];\r\nif (reset) {\r\npr_info("i18n messages from group %s reset to defaults\n",\r\ngroupname);\r\n} else if (received) {\r\nlen = snprintf(buf, sizeof(buf),\r\n" updated %d of %d i18n messages from group %s\n",\r\nused, received, groupname);\r\nif (rejected)\r\nsnprintf(buf + (len - 1), sizeof(buf) - (len - 1),\r\n" with %d reject%s\n",\r\nrejected, rejected > 1 ? "s" : "");\r\nprintk(buf);\r\n}\r\n}\r\nstatic ssize_t message_store_helper(const char *buf, size_t count,\r\nstruct msg_group_t *group)\r\n{\r\nchar *cp = (char *) buf;\r\nchar *end = cp + count;\r\nchar *linefeed = NULL;\r\nchar *temp = NULL;\r\nssize_t msg_stored = 0;\r\nssize_t retval = count;\r\nsize_t desc_length = 0;\r\nunsigned long index = 0;\r\nint received = 0;\r\nint used = 0;\r\nint rejected = 0;\r\nint reset = 0;\r\nenum msg_index_t firstmessage = group->start;\r\nenum msg_index_t lastmessage = group->end;\r\nenum msg_index_t curmessage;\r\nwhile (cp < end) {\r\nwhile ((cp < end) && (*cp == ' ' || *cp == '\t'))\r\ncp++;\r\nif (cp == end)\r\nbreak;\r\nif (strchr("dDrR", *cp)) {\r\nreset = 1;\r\nbreak;\r\n}\r\nreceived++;\r\nlinefeed = strchr(cp, '\n');\r\nif (!linefeed) {\r\nrejected++;\r\nbreak;\r\n}\r\nif (!isdigit(*cp)) {\r\nrejected++;\r\ncp = linefeed + 1;\r\ncontinue;\r\n}\r\nindex = simple_strtoul(cp, &temp, 10);\r\nwhile ((temp < linefeed) && (*temp == ' ' || *temp == '\t'
