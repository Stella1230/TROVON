static unsigned long read_hbreg(unsigned long addr)\r\n{\r\nunsigned long ret;\r\n__asm__ __volatile__("ldxa [%1] %2, %0"\r\n: "=&r" (ret)\r\n: "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E));\r\nreturn ret;\r\n}\r\nstatic void write_hbreg(unsigned long addr, unsigned long val)\r\n{\r\n__asm__ __volatile__("stxa %0, [%1] %2\n\t"\r\n"membar #Sync"\r\n:\r\n: "r" (val), "r" (addr), "i" (ASI_PHYS_BYPASS_EC_E)\r\n: "memory");\r\nif (addr == HBIRD_ESTAR_MODE_ADDR) {\r\nudelay(1);\r\n}\r\n}\r\nstatic void self_refresh_ctl(int enable)\r\n{\r\nunsigned long mctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\r\nif (enable)\r\nmctrl |= MCTRL0_SREFRESH_ENAB;\r\nelse\r\nmctrl &= ~MCTRL0_SREFRESH_ENAB;\r\nwrite_hbreg(HBIRD_MEM_CNTL0_ADDR, mctrl);\r\n(void) read_hbreg(HBIRD_MEM_CNTL0_ADDR);\r\n}\r\nstatic void frob_mem_refresh(int cpu_slowing_down,\r\nunsigned long clock_tick,\r\nunsigned long old_divisor, unsigned long divisor)\r\n{\r\nunsigned long old_refr_count, refr_count, mctrl;\r\nrefr_count = (clock_tick * MCTRL0_REFR_INTERVAL);\r\nrefr_count /= (MCTRL0_REFR_CLKS_P_CNT * divisor * 1000000000UL);\r\nmctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\r\nold_refr_count = (mctrl & MCTRL0_REFR_COUNT_MASK)\r\n>> MCTRL0_REFR_COUNT_SHIFT;\r\nmctrl &= ~MCTRL0_REFR_COUNT_MASK;\r\nmctrl |= refr_count << MCTRL0_REFR_COUNT_SHIFT;\r\nwrite_hbreg(HBIRD_MEM_CNTL0_ADDR, mctrl);\r\nmctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\r\nif (cpu_slowing_down && !(mctrl & MCTRL0_SREFRESH_ENAB)) {\r\nunsigned long usecs;\r\nusecs = (MCTRL0_REFR_CLKS_P_CNT *\r\n(refr_count + old_refr_count) *\r\n1000000UL *\r\nold_divisor) / clock_tick;\r\nudelay(usecs + 1UL);\r\n}\r\n}\r\nstatic void us2e_transition(unsigned long estar, unsigned long new_bits,\r\nunsigned long clock_tick,\r\nunsigned long old_divisor, unsigned long divisor)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nestar &= ~ESTAR_MODE_DIV_MASK;\r\nif (old_divisor == 2 && divisor == 1) {\r\nself_refresh_ctl(0);\r\nwrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\r\nfrob_mem_refresh(0, clock_tick, old_divisor, divisor);\r\n} else if (old_divisor == 1 && divisor == 2) {\r\nfrob_mem_refresh(1, clock_tick, old_divisor, divisor);\r\nwrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\r\nself_refresh_ctl(1);\r\n} else if (old_divisor == 1 && divisor > 2) {\r\nus2e_transition(estar, ESTAR_MODE_DIV_2, clock_tick,\r\n1, 2);\r\nus2e_transition(estar, new_bits, clock_tick,\r\n2, divisor);\r\n} else if (old_divisor > 2 && divisor == 1) {\r\nus2e_transition(estar, ESTAR_MODE_DIV_2, clock_tick,\r\nold_divisor, 2);\r\nus2e_transition(estar, new_bits, clock_tick,\r\n2, divisor);\r\n} else if (old_divisor < divisor) {\r\nfrob_mem_refresh(0, clock_tick, old_divisor, divisor);\r\nwrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\r\n} else if (old_divisor > divisor) {\r\nwrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\r\nfrob_mem_refresh(1, clock_tick, old_divisor, divisor);\r\n} else {\r\nBUG();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic unsigned long index_to_estar_mode(unsigned int index)\r\n{\r\nswitch (index) {\r\ncase 0:\r\nreturn ESTAR_MODE_DIV_1;\r\ncase 1:\r\nreturn ESTAR_MODE_DIV_2;\r\ncase 2:\r\nreturn ESTAR_MODE_DIV_4;\r\ncase 3:\r\nreturn ESTAR_MODE_DIV_6;\r\ncase 4:\r\nreturn ESTAR_MODE_DIV_8;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic unsigned long index_to_divisor(unsigned int index)\r\n{\r\nswitch (index) {\r\ncase 0:\r\nreturn 1;\r\ncase 1:\r\nreturn 2;\r\ncase 2:\r\nreturn 4;\r\ncase 3:\r\nreturn 6;\r\ncase 4:\r\nreturn 8;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic unsigned long estar_to_divisor(unsigned long estar)\r\n{\r\nunsigned long ret;\r\nswitch (estar & ESTAR_MODE_DIV_MASK) {\r\ncase ESTAR_MODE_DIV_1:\r\nret = 1;\r\nbreak;\r\ncase ESTAR_MODE_DIV_2:\r\nret = 2;\r\nbreak;\r\ncase ESTAR_MODE_DIV_4:\r\nret = 4;\r\nbreak;\r\ncase ESTAR_MODE_DIV_6:\r\nret = 6;\r\nbreak;\r\ncase ESTAR_MODE_DIV_8:\r\nret = 8;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int us2e_freq_get(unsigned int cpu)\r\n{\r\ncpumask_t cpus_allowed;\r\nunsigned long clock_tick, estar;\r\ncpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nclock_tick = sparc64_get_clock_tick(cpu) / 1000;\r\nestar = read_hbreg(HBIRD_ESTAR_MODE_ADDR);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nreturn clock_tick / estar_to_divisor(estar);\r\n}\r\nstatic int us2e_freq_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nunsigned long new_bits, new_freq;\r\nunsigned long clock_tick, divisor, old_divisor, estar;\r\ncpumask_t cpus_allowed;\r\ncpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nnew_freq = clock_tick = sparc64_get_clock_tick(cpu) / 1000;\r\nnew_bits = index_to_estar_mode(index);\r\ndivisor = index_to_divisor(index);\r\nnew_freq /= divisor;\r\nestar = read_hbreg(HBIRD_ESTAR_MODE_ADDR);\r\nold_divisor = estar_to_divisor(estar);\r\nif (old_divisor != divisor)\r\nus2e_transition(estar, new_bits, clock_tick * 1000,\r\nold_divisor, divisor);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nreturn 0;\r\n}\r\nstatic int __init us2e_freq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nunsigned long clock_tick = sparc64_get_clock_tick(cpu) / 1000;\r\nstruct cpufreq_frequency_table *table =\r\n&us2e_freq_table[cpu].table[0];\r\ntable[0].driver_data = 0;\r\ntable[0].frequency = clock_tick / 1;\r\ntable[1].driver_data = 1;\r\ntable[1].frequency = clock_tick / 2;\r\ntable[2].driver_data = 2;\r\ntable[2].frequency = clock_tick / 4;\r\ntable[2].driver_data = 3;\r\ntable[2].frequency = clock_tick / 6;\r\ntable[2].driver_data = 4;\r\ntable[2].frequency = clock_tick / 8;\r\ntable[2].driver_data = 5;\r\ntable[3].frequency = CPUFREQ_TABLE_END;\r\npolicy->cpuinfo.transition_latency = 0;\r\npolicy->cur = clock_tick;\r\nreturn cpufreq_table_validate_and_show(policy, table);\r\n}\r\nstatic int us2e_freq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nif (cpufreq_us2e_driver) {\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nus2e_freq_target(policy, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init us2e_freq_init(void)\r\n{\r\nunsigned long manuf, impl, ver;\r\nint ret;\r\nif (tlb_type != spitfire)\r\nreturn -ENODEV;\r\n__asm__("rdpr %%ver, %0" : "=r" (ver));\r\nmanuf = ((ver >> 48) & 0xffff);\r\nimpl = ((ver >> 32) & 0xffff);\r\nif (manuf == 0x17 && impl == 0x13) {\r\nstruct cpufreq_driver *driver;\r\nret = -ENOMEM;\r\ndriver = kzalloc(sizeof(*driver), GFP_KERNEL);\r\nif (!driver)\r\ngoto err_out;\r\nus2e_freq_table = kzalloc((NR_CPUS * sizeof(*us2e_freq_table)),\r\nGFP_KERNEL);\r\nif (!us2e_freq_table)\r\ngoto err_out;\r\ndriver->init = us2e_freq_cpu_init;\r\ndriver->verify = cpufreq_generic_frequency_table_verify;\r\ndriver->target_index = us2e_freq_target;\r\ndriver->get = us2e_freq_get;\r\ndriver->exit = us2e_freq_cpu_exit;\r\nstrcpy(driver->name, "UltraSPARC-IIe");\r\ncpufreq_us2e_driver = driver;\r\nret = cpufreq_register_driver(driver);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nif (driver) {\r\nkfree(driver);\r\ncpufreq_us2e_driver = NULL;\r\n}\r\nkfree(us2e_freq_table);\r\nus2e_freq_table = NULL;\r\nreturn ret;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit us2e_freq_exit(void)\r\n{\r\nif (cpufreq_us2e_driver) {\r\ncpufreq_unregister_driver(cpufreq_us2e_driver);\r\nkfree(cpufreq_us2e_driver);\r\ncpufreq_us2e_driver = NULL;\r\nkfree(us2e_freq_table);\r\nus2e_freq_table = NULL;\r\n}\r\n}
