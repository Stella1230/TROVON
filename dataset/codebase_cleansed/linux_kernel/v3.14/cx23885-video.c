static struct cx23885_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nprintk(KERN_ERR "%s(%c%c%c%c) NOT FOUND\n", __func__,\r\n(fourcc & 0xff),\r\n((fourcc >> 8) & 0xff),\r\n((fourcc >> 16) & 0xff),\r\n((fourcc >> 24) & 0xff)\r\n);\r\nreturn NULL;\r\n}\r\nvoid cx23885_video_wakeup(struct cx23885_dev *dev,\r\nstruct cx23885_dmaqueue *q, u32 count)\r\n{\r\nstruct cx23885_buffer *buf;\r\nint bc;\r\nfor (bc = 0;; bc++) {\r\nif (list_empty(&q->active))\r\nbreak;\r\nbuf = list_entry(q->active.next,\r\nstruct cx23885_buffer, vb.queue);\r\nif ((s16) (count - buf->count) < 0)\r\nbreak;\r\nv4l2_get_timestamp(&buf->vb.ts);\r\ndprintk(2, "[%p/%d] wakeup reg=%d buf=%d\n", buf, buf->vb.i,\r\ncount, buf->count);\r\nbuf->vb.state = VIDEOBUF_DONE;\r\nlist_del(&buf->vb.queue);\r\nwake_up(&buf->vb.done);\r\n}\r\nif (list_empty(&q->active))\r\ndel_timer(&q->timeout);\r\nelse\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\nif (bc != 1)\r\nprintk(KERN_ERR "%s: %d buffers handled (should be 1)\n",\r\n__func__, bc);\r\n}\r\nint cx23885_set_tvnorm(struct cx23885_dev *dev, v4l2_std_id norm)\r\n{\r\ndprintk(1, "%s(norm = 0x%08x) name: [%s]\n",\r\n__func__,\r\n(unsigned int)norm,\r\nv4l2_norm_to_name(norm));\r\ndev->tvnorm = norm;\r\ncall_all(dev, core, s_std, norm);\r\nreturn 0;\r\n}\r\nstatic struct video_device *cx23885_vdev_init(struct cx23885_dev *dev,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s (%s)",\r\ncx23885_boards[dev->board].name, type);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nstatic int cx23885_ctrl_query(struct v4l2_queryctrl *qctrl)\r\n{\r\nint i;\r\nif (qctrl->id < V4L2_CID_BASE ||\r\nqctrl->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nfor (i = 0; i < CX23885_CTLS; i++)\r\nif (cx23885_ctls[i].v.id == qctrl->id)\r\nbreak;\r\nif (i == CX23885_CTLS) {\r\n*qctrl = no_ctl;\r\nreturn 0;\r\n}\r\n*qctrl = cx23885_ctls[i].v;\r\nreturn 0;\r\n}\r\nstatic int res_get(struct cx23885_dev *dev, struct cx23885_fh *fh,\r\nunsigned int bit)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (fh->resources & bit)\r\nreturn 1;\r\nmutex_lock(&dev->lock);\r\nif (dev->resources & bit) {\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->resources |= bit;\r\ndprintk(1, "res: get %d\n", bit);\r\nmutex_unlock(&dev->lock);\r\nreturn 1;\r\n}\r\nstatic int res_check(struct cx23885_fh *fh, unsigned int bit)\r\n{\r\nreturn fh->resources & bit;\r\n}\r\nstatic int res_locked(struct cx23885_dev *dev, unsigned int bit)\r\n{\r\nreturn dev->resources & bit;\r\n}\r\nstatic void res_free(struct cx23885_dev *dev, struct cx23885_fh *fh,\r\nunsigned int bits)\r\n{\r\nBUG_ON((fh->resources & bits) != bits);\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&dev->lock);\r\nfh->resources &= ~bits;\r\ndev->resources &= ~bits;\r\ndprintk(1, "res: put %d\n", bits);\r\nmutex_unlock(&dev->lock);\r\n}\r\nint cx23885_flatiron_write(struct cx23885_dev *dev, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = 0x98 >> 1,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nreturn i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);\r\n}\r\nu8 cx23885_flatiron_read(struct cx23885_dev *dev, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = 0x98 >> 1, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = 0x98 >> 1, .flags = I2C_M_RD, .buf = b1, .len = 1 }\r\n};\r\nret = i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg[0], 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s() error\n", __func__);\r\nreturn b1[0];\r\n}\r\nstatic void cx23885_flatiron_dump(struct cx23885_dev *dev)\r\n{\r\nint i;\r\ndprintk(1, "Flatiron dump\n");\r\nfor (i = 0; i < 0x24; i++) {\r\ndprintk(1, "FI[%02x] = %02x\n", i,\r\ncx23885_flatiron_read(dev, i));\r\n}\r\n}\r\nstatic int cx23885_flatiron_mux(struct cx23885_dev *dev, int input)\r\n{\r\nu8 val;\r\ndprintk(1, "%s(input = %d)\n", __func__, input);\r\nif (input == 1)\r\nval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) & ~FLD_CH_SEL;\r\nelse if (input == 2)\r\nval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) | FLD_CH_SEL;\r\nelse\r\nreturn -EINVAL;\r\nval |= 0x20;\r\ncx23885_flatiron_write(dev, CH_PWR_CTRL1, val);\r\ncx23885_flatiron_write(dev, CH_PWR_CTRL2, 0);\r\nif (video_debug)\r\ncx23885_flatiron_dump(dev);\r\nreturn 0;\r\n}\r\nstatic int cx23885_video_mux(struct cx23885_dev *dev, unsigned int input)\r\n{\r\ndprintk(1, "%s() video_mux: %d [vmux=%d, gpio=0x%x,0x%x,0x%x,0x%x]\n",\r\n__func__,\r\ninput, INPUT(input)->vmux,\r\nINPUT(input)->gpio0, INPUT(input)->gpio1,\r\nINPUT(input)->gpio2, INPUT(input)->gpio3);\r\ndev->input = input;\r\nif (dev->board == CX23885_BOARD_MYGICA_X8506 ||\r\ndev->board == CX23885_BOARD_MAGICPRO_PROHDTVE2 ||\r\ndev->board == CX23885_BOARD_MYGICA_X8507) {\r\nif (INPUT(input)->type == CX23885_VMUX_TELEVISION)\r\ncx23885_gpio_clear(dev, GPIO_0);\r\n}\r\nv4l2_subdev_call(dev->sd_cx25840, video, s_routing,\r\nINPUT(input)->vmux, 0, 0);\r\nif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1800) ||\r\n(dev->board == CX23885_BOARD_MPX885) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1250) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\r\n(dev->board == CX23885_BOARD_MYGICA_X8507) ||\r\n(dev->board == CX23885_BOARD_AVERMEDIA_HC81R)) {\r\nv4l2_subdev_call(dev->sd_cx25840, audio, s_routing,\r\nINPUT(input)->amux, 0, 0);\r\nif (INPUT(input)->amux == CX25840_AUDIO7)\r\ncx23885_flatiron_mux(dev, 1);\r\nelse if (INPUT(input)->amux == CX25840_AUDIO6)\r\ncx23885_flatiron_mux(dev, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23885_audio_mux(struct cx23885_dev *dev, unsigned int input)\r\n{\r\ndprintk(1, "%s(input=%d)\n", __func__, input);\r\nif (INPUT(input)->amux == CX25840_AUDIO7)\r\ncx23885_flatiron_mux(dev, 1);\r\nelse if (INPUT(input)->amux == CX25840_AUDIO6)\r\ncx23885_flatiron_mux(dev, 2);\r\nelse {\r\ncx23885_flatiron_mux(dev, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23885_start_video_dma(struct cx23885_dev *dev,\r\nstruct cx23885_dmaqueue *q,\r\nstruct cx23885_buffer *buf)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx_clear(VID_A_DMA_CTL, 0x11);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],\r\nbuf->bpl, buf->risc.dma);\r\ncx_write(VID_A_GPCNT_CTL, 3);\r\nq->count = 1;\r\ncx23885_irq_add_enable(dev, 0x01);\r\ncx_set(VID_A_INT_MSK, 0x000011);\r\ncx_set(DEV_CNTRL2, (1<<5));\r\ncx_set(VID_A_DMA_CTL, 0x11);\r\nreturn 0;\r\n}\r\nstatic int cx23885_restart_video_queue(struct cx23885_dev *dev,\r\nstruct cx23885_dmaqueue *q)\r\n{\r\nstruct cx23885_buffer *buf, *prev;\r\nstruct list_head *item;\r\ndprintk(1, "%s()\n", __func__);\r\nif (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next, struct cx23885_buffer,\r\nvb.queue);\r\ndprintk(2, "restart_queue [%p/%d]: restart dma\n",\r\nbuf, buf->vb.i);\r\ncx23885_start_video_dma(dev, q, buf);\r\nlist_for_each(item, &q->active) {\r\nbuf = list_entry(item, struct cx23885_buffer,\r\nvb.queue);\r\nbuf->count = q->count++;\r\n}\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nprev = NULL;\r\nfor (;;) {\r\nif (list_empty(&q->queued))\r\nreturn 0;\r\nbuf = list_entry(q->queued.next, struct cx23885_buffer,\r\nvb.queue);\r\nif (NULL == prev) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\ncx23885_start_video_dma(dev, q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] restart_queue - first active\n",\r\nbuf, buf->vb.i);\r\n} else if (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_move_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "[%p/%d] restart_queue - move to active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nreturn 0;\r\n}\r\nprev = buf;\r\n}\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *q, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct cx23885_fh *fh = q->priv_data;\r\n*size = fh->fmt->depth*fh->width*fh->height >> 3;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct cx23885_fh *fh = q->priv_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx23885_buffer *buf =\r\ncontainer_of(vb, struct cx23885_buffer, vb);\r\nint rc, init_buffer = 0;\r\nu32 line0_offset, line1_offset;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nint field_tff;\r\nBUG_ON(NULL == fh->fmt);\r\nif (fh->width < 48 || fh->width > norm_maxw(dev->tvnorm) ||\r\nfh->height < 32 || fh->height > norm_maxh(dev->tvnorm))\r\nreturn -EINVAL;\r\nbuf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\nif (buf->fmt != fh->fmt ||\r\nbuf->vb.width != fh->width ||\r\nbuf->vb.height != fh->height ||\r\nbuf->vb.field != field) {\r\nbuf->fmt = fh->fmt;\r\nbuf->vb.width = fh->width;\r\nbuf->vb.height = fh->height;\r\nbuf->vb.field = field;\r\ninit_buffer = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\ninit_buffer = 1;\r\nrc = videobuf_iolock(q, &buf->vb, NULL);\r\nif (0 != rc)\r\ngoto fail;\r\n}\r\nif (init_buffer) {\r\nbuf->bpl = buf->vb.width * buf->fmt->depth >> 3;\r\nswitch (buf->vb.field) {\r\ncase V4L2_FIELD_TOP:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, 0, UNSET,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, UNSET, 0,\r\nbuf->bpl, 0, buf->vb.height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nif (dev->tvnorm & V4L2_STD_NTSC)\r\nfield_tff = 1;\r\nelse\r\nfield_tff = 0;\r\nif (cx23885_boards[dev->board].force_bff)\r\nfield_tff = 0;\r\nif (field_tff) {\r\ndprintk(1, "%s() Creating TFF/NTSC risc\n",\r\n__func__);\r\nline0_offset = buf->bpl;\r\nline1_offset = 0;\r\n} else {\r\ndprintk(1, "%s() Creating BFF/PAL/SECAM risc\n",\r\n__func__);\r\nline0_offset = 0;\r\nline1_offset = buf->bpl;\r\n}\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist, line0_offset,\r\nline1_offset,\r\nbuf->bpl, buf->bpl,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\n0, buf->bpl * (buf->vb.height >> 1),\r\nbuf->bpl, 0,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\ndma->sglist,\r\nbuf->bpl * (buf->vb.height >> 1), 0,\r\nbuf->bpl, 0,\r\nbuf->vb.height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\ndprintk(2, "[%p/%d] buffer_prep - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.i,\r\nfh->width, fh->height, fh->fmt->depth, fh->fmt->name,\r\n(unsigned long)buf->risc.dma);\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\ncx23885_free_buffer(q, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\nstruct cx23885_buffer *prev;\r\nstruct cx23885_fh *fh = vq->priv_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nstruct cx23885_dmaqueue *q = &dev->vidq;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_IRQ1 | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(q->stopper.dma);\r\nbuf->risc.jmp[2] = cpu_to_le32(0);\r\nif (!list_empty(&q->queued)) {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - append to queued\n",\r\nbuf, buf->vb.i);\r\n} else if (list_empty(&q->active)) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\ncx23885_start_video_dma(dev, q, buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nmod_timer(&q->timeout, jiffies+BUFFER_TIMEOUT);\r\ndprintk(2, "[%p/%d] buffer_queue - first active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nprev = list_entry(q->active.prev, struct cx23885_buffer,\r\nvb.queue);\r\nif (prev->vb.width == buf->vb.width &&\r\nprev->vb.height == buf->vb.height &&\r\nprev->fmt == buf->fmt) {\r\nlist_add_tail(&buf->vb.queue, &q->active);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->count = q->count++;\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nprev->risc.jmp[2] = cpu_to_le32(0);\r\ndprintk(2, "[%p/%d] buffer_queue - append to active\n",\r\nbuf, buf->vb.i);\r\n} else {\r\nlist_add_tail(&buf->vb.queue, &q->queued);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\ndprintk(2, "[%p/%d] buffer_queue - first queued\n",\r\nbuf, buf->vb.i);\r\n}\r\n}\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\ncx23885_free_buffer(q, buf);\r\n}\r\nstatic struct videobuf_queue *get_queue(struct cx23885_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &fh->vidq;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn &fh->vbiq;\r\ndefault:\r\nBUG();\r\nreturn NULL;\r\n}\r\n}\r\nstatic int get_resource(struct cx23885_fh *fh)\r\n{\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn RESOURCE_VIDEO;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn RESOURCE_VBI;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic int video_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct cx23885_fh *fh;\r\nenum v4l2_buf_type type = 0;\r\nint radio = 0;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\ntype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ntype = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nradio = 1;\r\nbreak;\r\n}\r\ndprintk(1, "open dev=%s radio=%d type=%s\n",\r\nvideo_device_node_name(vdev), radio, v4l2_type_names[type]);\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nfh->radio = radio;\r\nfh->type = type;\r\nfh->width = 320;\r\nfh->height = 240;\r\nfh->fmt = format_by_fourcc(V4L2_PIX_FMT_YUYV);\r\nvideobuf_queue_sg_init(&fh->vidq, &cx23885_video_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct cx23885_buffer),\r\nfh, NULL);\r\nvideobuf_queue_sg_init(&fh->vbiq, &cx23885_vbi_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct cx23885_buffer),\r\nfh, NULL);\r\ndprintk(1, "post videobuf_queue_init()\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t video_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nswitch (fh->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (res_locked(fh->dev, RESOURCE_VIDEO))\r\nreturn -EBUSY;\r\nreturn videobuf_read_one(&fh->vidq, data, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (!res_get(fh->dev, fh, RESOURCE_VBI))\r\nreturn -EBUSY;\r\nreturn videobuf_read_stream(&fh->vbiq, data, count, ppos, 1,\r\nfile->f_flags & O_NONBLOCK);\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned int video_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_buffer *buf;\r\nunsigned int rc = POLLERR;\r\nif (V4L2_BUF_TYPE_VBI_CAPTURE == fh->type) {\r\nif (!res_get(fh->dev, fh, RESOURCE_VBI))\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(file, &fh->vbiq, wait);\r\n}\r\nmutex_lock(&fh->vidq.vb_lock);\r\nif (res_check(fh, RESOURCE_VIDEO)) {\r\nif (list_empty(&fh->vidq.stream))\r\ngoto done;\r\nbuf = list_entry(fh->vidq.stream.next,\r\nstruct cx23885_buffer, vb.stream);\r\n} else {\r\nbuf = (struct cx23885_buffer *)fh->vidq.read_buf;\r\nif (NULL == buf)\r\ngoto done;\r\n}\r\npoll_wait(file, &buf->vb.done, wait);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nrc = POLLIN|POLLRDNORM;\r\nelse\r\nrc = 0;\r\ndone:\r\nmutex_unlock(&fh->vidq.vb_lock);\r\nreturn rc;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (res_check(fh, RESOURCE_OVERLAY)) {\r\nres_free(dev, fh, RESOURCE_OVERLAY);\r\n}\r\nif (res_check(fh, RESOURCE_VIDEO)) {\r\nvideobuf_queue_cancel(&fh->vidq);\r\nres_free(dev, fh, RESOURCE_VIDEO);\r\n}\r\nif (fh->vidq.read_buf) {\r\nbuffer_release(&fh->vidq, fh->vidq.read_buf);\r\nkfree(fh->vidq.read_buf);\r\n}\r\nif (res_check(fh, RESOURCE_VBI)) {\r\nif (fh->vbiq.streaming)\r\nvideobuf_streamoff(&fh->vbiq);\r\nif (fh->vbiq.reading)\r\nvideobuf_read_stop(&fh->vbiq);\r\nres_free(dev, fh, RESOURCE_VBI);\r\n}\r\nvideobuf_mmap_free(&fh->vidq);\r\nvideobuf_mmap_free(&fh->vbiq);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int video_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx23885_fh *fh = file->private_data;\r\nreturn videobuf_mmap_mapper(get_queue(fh), vma);\r\n}\r\nint cx23885_get_control(struct cx23885_dev *dev,\r\nstruct v4l2_control *ctl)\r\n{\r\ndprintk(1, "%s() calling cx25840(VIDIOC_G_CTRL)\n", __func__);\r\ncall_all(dev, core, g_ctrl, ctl);\r\nreturn 0;\r\n}\r\nint cx23885_set_control(struct cx23885_dev *dev,\r\nstruct v4l2_control *ctl)\r\n{\r\ndprintk(1, "%s() calling cx25840(VIDIOC_S_CTRL)\n", __func__);\r\ncall_all(dev, core, s_ctrl, ctl);\r\nreturn 0;\r\n}\r\nstatic void init_controls(struct cx23885_dev *dev)\r\n{\r\nstruct v4l2_control ctrl;\r\nint i;\r\nfor (i = 0; i < CX23885_CTLS; i++) {\r\nctrl.id = cx23885_ctls[i].v.id;\r\nctrl.value = cx23885_ctls[i].v.default_value;\r\ncx23885_set_control(dev, &ctrl);\r\n}\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nf->fmt.pix.width = fh->width;\r\nf->fmt.pix.height = fh->height;\r\nf->fmt.pix.field = fh->vidq.field;\r\nf->fmt.pix.pixelformat = fh->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fh->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nstruct cx23885_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = norm_maxw(dev->tvnorm);\r\nmaxh = norm_maxh(dev->tvnorm);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nf->fmt.pix.field = field;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\r\n&f->fmt.pix.height, 32, maxh, 0, 0);\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint err;\r\ndprintk(2, "%s()\n", __func__);\r\nerr = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\nfh->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nfh->width = f->fmt.pix.width;\r\nfh->height = f->fmt.pix.height;\r\nfh->vidq.field = f->fmt.pix.field;\r\ndprintk(2, "%s() width=%d height=%d field=%d\n", __func__,\r\nfh->width, fh->height, fh->vidq.field);\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\ncall_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nstrcpy(cap->driver, "cx23885");\r\nstrlcpy(cap->card, cx23885_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCIe:%s", pci_name(dev->pci));\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING |\r\nV4L2_CAP_VBI_CAPTURE;\r\nif (UNSET != dev->tuner_type)\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nreturn videobuf_reqbufs(get_queue(fh), p);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nreturn videobuf_querybuf(get_queue(fh), p);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nreturn videobuf_qbuf(get_queue(fh), p);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nreturn videobuf_dqbuf(get_queue(fh), p,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nif ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(fh->type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (unlikely(i != fh->type))\r\nreturn -EINVAL;\r\nif (unlikely(!res_get(dev, fh, get_resource(fh))))\r\nreturn -EBUSY;\r\nif ((fh->type == V4L2_BUF_TYPE_VBI_CAPTURE) &&\r\n((cx_read(VID_A_DMA_CTL) & 0x11) == 0))\r\nreturn -EINVAL;\r\nreturn videobuf_streamon(get_queue(fh));\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nint err, res;\r\ndprintk(1, "%s()\n", __func__);\r\nif ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(fh->type != V4L2_BUF_TYPE_VBI_CAPTURE))\r\nreturn -EINVAL;\r\nif (i != fh->type)\r\nreturn -EINVAL;\r\nres = get_resource(fh);\r\nerr = videobuf_streamoff(get_queue(fh));\r\nif (err < 0)\r\nreturn err;\r\nres_free(dev, fh, res);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\ndprintk(1, "%s()\n", __func__);\r\n*id = dev->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id tvnorms)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&dev->lock);\r\ncx23885_set_tvnorm(dev, tvnorms);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nint cx23885_enum_input(struct cx23885_dev *dev, struct v4l2_input *i)\r\n{\r\nstatic const char *iname[] = {\r\n[CX23885_VMUX_COMPOSITE1] = "Composite1",\r\n[CX23885_VMUX_COMPOSITE2] = "Composite2",\r\n[CX23885_VMUX_COMPOSITE3] = "Composite3",\r\n[CX23885_VMUX_COMPOSITE4] = "Composite4",\r\n[CX23885_VMUX_SVIDEO] = "S-Video",\r\n[CX23885_VMUX_COMPONENT] = "Component",\r\n[CX23885_VMUX_TELEVISION] = "Television",\r\n[CX23885_VMUX_CABLE] = "Cable TV",\r\n[CX23885_VMUX_DVB] = "DVB",\r\n[CX23885_VMUX_DEBUG] = "for debug only",\r\n};\r\nunsigned int n;\r\ndprintk(1, "%s()\n", __func__);\r\nn = i->index;\r\nif (n >= MAX_CX23885_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\nif ((CX23885_VMUX_TELEVISION == INPUT(n)->type) ||\r\n(CX23885_VMUX_CABLE == INPUT(n)->type)) {\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = CX23885_NORMS;\r\n}\r\nif (INPUT(n)->type != CX23885_VMUX_TELEVISION)\r\ni->audioset = 0x3;\r\nif (dev->input == n) {\r\ncall_all(dev, video, g_input_status, &i->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nreturn cx23885_enum_input(dev, i);\r\n}\r\nint cx23885_get_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\n*i = dev->input;\r\ndprintk(1, "%s() returns %d\n", __func__, *i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nreturn cx23885_get_input(file, priv, i);\r\n}\r\nint cx23885_set_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\ndprintk(1, "%s(%d)\n", __func__, i);\r\nif (i >= MAX_CX23885_INPUT) {\r\ndprintk(1, "%s() -EINVAL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (INPUT(i)->type == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\ncx23885_video_mux(dev, i);\r\ncx23885_audio_mux(dev, i);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn cx23885_set_input(file, priv, i);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nprintk(KERN_INFO\r\n"%s/0: ============ START LOG STATUS ============\n",\r\ndev->name);\r\ncall_all(dev, core, log_status);\r\nprintk(KERN_INFO\r\n"%s/0: ============= END LOG STATUS =============\n",\r\ndev->name);\r\nreturn 0;\r\n}\r\nstatic int cx23885_query_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nstatic const char *iname[] = {\r\n[0] = "Baseband L/R 1",\r\n[1] = "Baseband L/R 2",\r\n};\r\nunsigned int n;\r\ndprintk(1, "%s()\n", __func__);\r\nn = i->index;\r\nif (n >= 2)\r\nreturn -EINVAL;\r\nmemset(i, 0, sizeof(*i));\r\ni->index = n;\r\nstrcpy(i->name, iname[n]);\r\ni->capability = V4L2_AUDCAP_STEREO;\r\ni->mode = V4L2_AUDMODE_AVL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nreturn cx23885_query_audinput(file, priv, i);\r\n}\r\nstatic int vidioc_g_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\ni->index = dev->audinput;\r\ndprintk(1, "%s(input=%d)\n", __func__, i->index);\r\nreturn cx23885_query_audinput(file, priv, i);\r\n}\r\nstatic int vidioc_s_audinput(struct file *file, void *priv,\r\nconst struct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nif (i->index >= 2)\r\nreturn -EINVAL;\r\ndprintk(1, "%s(%d)\n", __func__, i->index);\r\ndev->audinput = i->index;\r\ncx23885_flatiron_mux(dev, dev->audinput + 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qctrl)\r\n{\r\nqctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);\r\nif (unlikely(qctrl->id == 0))\r\nreturn -EINVAL;\r\nreturn cx23885_ctrl_query(qctrl);\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nreturn cx23885_get_control(dev, ctl);\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nreturn cx23885_set_control(dev, ctl);\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\ncall_all(dev, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = ((struct cx23885_fh *)priv)->dev;\r\nif (UNSET == dev->tuner_type)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nf->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->freq;\r\ncall_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int cx23885_set_freq(struct cx23885_dev *dev, const struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_control ctrl;\r\nif (unlikely(UNSET == dev->tuner_type))\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\ndev->freq = f->frequency;\r\nctrl.id = V4L2_CID_AUDIO_MUTE;\r\nctrl.value = 1;\r\ncx23885_set_control(dev, &ctrl);\r\ncall_all(dev, tuner, s_frequency, f);\r\nmsleep(100);\r\nctrl.value = 0;\r\ncx23885_set_control(dev, &ctrl);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int cx23885_set_freq_via_ops(struct cx23885_dev *dev,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_control ctrl;\r\nstruct videobuf_dvb_frontend *vfe;\r\nstruct dvb_frontend *fe;\r\nstruct analog_parameters params = {\r\n.mode = V4L2_TUNER_ANALOG_TV,\r\n.audmode = V4L2_TUNER_MODE_STEREO,\r\n.std = dev->tvnorm,\r\n.frequency = f->frequency\r\n};\r\nmutex_lock(&dev->lock);\r\ndev->freq = f->frequency;\r\nctrl.id = V4L2_CID_AUDIO_MUTE;\r\nctrl.value = 1;\r\ncx23885_set_control(dev, &ctrl);\r\ndprintk(1, "%s() frequency=%d tuner=%d std=0x%llx\n", __func__,\r\nparams.frequency, f->tuner, params.std);\r\nvfe = videobuf_dvb_get_frontend(&dev->ts2.frontends, 1);\r\nif (!vfe) {\r\nmutex_unlock(&dev->lock);\r\nreturn -EINVAL;\r\n}\r\nfe = vfe->dvb.frontend;\r\nif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111))\r\nfe = &dev->ts1.analog_fe;\r\nif (fe && fe->ops.tuner_ops.set_analog_params) {\r\ncall_all(dev, core, s_std, dev->tvnorm);\r\nfe->ops.tuner_ops.set_analog_params(fe, &params);\r\n}\r\nelse\r\nprintk(KERN_ERR "%s() No analog tuner, aborting\n", __func__);\r\nmsleep(100);\r\nctrl.value = 0;\r\ncx23885_set_control(dev, &ctrl);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nint cx23885_set_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx23885_fh *fh = priv;\r\nstruct cx23885_dev *dev = fh->dev;\r\nint ret;\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255_22111:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1850:\r\nret = cx23885_set_freq_via_ops(dev, f);\r\nbreak;\r\ndefault:\r\nret = cx23885_set_freq(dev, f);\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nreturn cx23885_set_frequency(file, priv, f);\r\n}\r\nstatic void cx23885_vid_timeout(unsigned long data)\r\n{\r\nstruct cx23885_dev *dev = (struct cx23885_dev *)data;\r\nstruct cx23885_dmaqueue *q = &dev->vidq;\r\nstruct cx23885_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&q->active)) {\r\nbuf = list_entry(q->active.next,\r\nstruct cx23885_buffer, vb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\nprintk(KERN_ERR "%s: [%p/%d] timeout - dma=0x%08lx\n",\r\ndev->name, buf, buf->vb.i,\r\n(unsigned long)buf->risc.dma);\r\n}\r\ncx23885_restart_video_queue(dev, q);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nint cx23885_video_irq(struct cx23885_dev *dev, u32 status)\r\n{\r\nu32 mask, count;\r\nint handled = 0;\r\nmask = cx_read(VID_A_INT_MSK);\r\nif (0 == (status & mask))\r\nreturn handled;\r\ncx_write(VID_A_INT_STAT, status);\r\nif ((status & VID_BC_MSK_OPC_ERR) ||\r\n(status & VID_BC_MSK_SYNC) ||\r\n(status & VID_BC_MSK_OF)) {\r\nif (status & VID_BC_MSK_OPC_ERR) {\r\ndprintk(7, " (VID_BC_MSK_OPC_ERR 0x%08x)\n",\r\nVID_BC_MSK_OPC_ERR);\r\nprintk(KERN_WARNING "%s: video risc op code error\n",\r\ndev->name);\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[SRAM_CH01]);\r\n}\r\nif (status & VID_BC_MSK_SYNC)\r\ndprintk(7, " (VID_BC_MSK_SYNC 0x%08x) "\r\n"video lines miss-match\n",\r\nVID_BC_MSK_SYNC);\r\nif (status & VID_BC_MSK_OF)\r\ndprintk(7, " (VID_BC_MSK_OF 0x%08x) fifo overflow\n",\r\nVID_BC_MSK_OF);\r\n}\r\nif (status & VID_BC_MSK_RISCI1) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(VID_A_GPCNT);\r\ncx23885_video_wakeup(dev, &dev->vidq, count);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nif (status & VID_BC_MSK_RISCI2) {\r\ndprintk(2, "stopper video\n");\r\nspin_lock(&dev->slock);\r\ncx23885_restart_video_queue(dev, &dev->vidq);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nhandled += cx23885_vbi_irq(dev, status);\r\nreturn handled;\r\n}\r\nvoid cx23885_video_unregister(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx23885_irq_remove(dev, 0x01);\r\nif (dev->vbi_dev) {\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\nbtcx_riscmem_free(dev->pci, &dev->vbiq.stopper);\r\n}\r\nif (dev->video_dev) {\r\nif (video_is_registered(dev->video_dev))\r\nvideo_unregister_device(dev->video_dev);\r\nelse\r\nvideo_device_release(dev->video_dev);\r\ndev->video_dev = NULL;\r\nbtcx_riscmem_free(dev->pci, &dev->vidq.stopper);\r\n}\r\nif (dev->audio_dev)\r\ncx23885_audio_unregister(dev);\r\n}\r\nint cx23885_video_register(struct cx23885_dev *dev)\r\n{\r\nint err;\r\ndprintk(1, "%s()\n", __func__);\r\nspin_lock_init(&dev->slock);\r\ncx23885_vbi_template = cx23885_video_template;\r\nstrcpy(cx23885_vbi_template.name, "cx23885-vbi");\r\ndev->tvnorm = V4L2_STD_NTSC_M;\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vidq.queued);\r\ndev->vidq.timeout.function = cx23885_vid_timeout;\r\ndev->vidq.timeout.data = (unsigned long)dev;\r\ninit_timer(&dev->vidq.timeout);\r\ncx23885_risc_stopper(dev->pci, &dev->vidq.stopper,\r\nVID_A_DMA_CTL, 0x11, 0x00);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.queued);\r\ndev->vbiq.timeout.function = cx23885_vbi_timeout;\r\ndev->vbiq.timeout.data = (unsigned long)dev;\r\ninit_timer(&dev->vbiq.timeout);\r\ncx23885_risc_stopper(dev->pci, &dev->vbiq.stopper,\r\nVID_A_DMA_CTL, 0x22, 0x00);\r\ncx23885_irq_add_enable(dev, 0x01);\r\nif ((TUNER_ABSENT != dev->tuner_type) &&\r\n((dev->tuner_bus == 0) || (dev->tuner_bus == 1))) {\r\nstruct v4l2_subdev *sd = NULL;\r\nif (dev->tuner_addr)\r\nsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[dev->tuner_bus].i2c_adap,\r\n"tuner", dev->tuner_addr, NULL);\r\nelse\r\nsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[dev->tuner_bus].i2c_adap,\r\n"tuner", 0, v4l2_i2c_tuner_addrs(ADDRS_TV));\r\nif (sd) {\r\nstruct tuner_setup tun_setup;\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\ntun_setup.mode_mask = T_ANALOG_TV;\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = v4l2_i2c_subdev_addr(sd);\r\ntun_setup.tuner_callback = cx23885_tuner_callback;\r\nv4l2_subdev_call(sd, tuner, s_type_addr, &tun_setup);\r\nif ((dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXTV1200) ||\r\n(dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200)) {\r\nstruct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl\r\n};\r\nv4l2_subdev_call(sd, tuner, s_config, &cfg);\r\n}\r\nif (dev->board == CX23885_BOARD_AVERMEDIA_HC81R) {\r\nstruct xc2028_ctrl ctrl = {\r\n.fname = "xc3028L-v36.fw",\r\n.max_len = 64\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl\r\n};\r\nv4l2_subdev_call(sd, tuner, s_config, &cfg);\r\n}\r\n}\r\n}\r\ndev->video_dev = cx23885_vdev_init(dev, dev->pci,\r\n&cx23885_video_template, "video");\r\nerr = video_register_device(dev->video_dev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [v4l2]\n",\r\ndev->name, video_device_node_name(dev->video_dev));\r\ndev->vbi_dev = cx23885_vdev_init(dev, dev->pci,\r\n&cx23885_vbi_template, "vbi");\r\nerr = video_register_device(dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register vbi device\n",\r\ndev->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->vbi_dev));\r\ndev->audio_dev = cx23885_audio_register(dev);\r\nmutex_lock(&dev->lock);\r\ncx23885_set_tvnorm(dev, dev->tvnorm);\r\ninit_controls(dev);\r\ncx23885_video_mux(dev, 0);\r\ncx23885_audio_mux(dev, 0);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\nfail_unreg:\r\ncx23885_video_unregister(dev);\r\nreturn err;\r\n}
