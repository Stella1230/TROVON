static inline int ll_sa_entry_unhashed(struct ll_sa_entry *entry)\r\n{\r\nreturn list_empty(&entry->se_hash);\r\n}\r\nstatic inline int ll_sa_entry_stated(struct ll_sa_entry *entry)\r\n{\r\nsmp_rmb();\r\nreturn (entry->se_stat != SA_ENTRY_INIT);\r\n}\r\nstatic inline int ll_sa_entry_hash(int val)\r\n{\r\nreturn val & LL_SA_CACHE_MASK;\r\n}\r\nstatic inline void\r\nll_sa_entry_enhash(struct ll_statahead_info *sai, struct ll_sa_entry *entry)\r\n{\r\nint i = ll_sa_entry_hash(entry->se_qstr.hash);\r\nspin_lock(&sai->sai_cache_lock[i]);\r\nlist_add_tail(&entry->se_hash, &sai->sai_cache[i]);\r\nspin_unlock(&sai->sai_cache_lock[i]);\r\n}\r\nstatic inline void\r\nll_sa_entry_unhash(struct ll_statahead_info *sai, struct ll_sa_entry *entry)\r\n{\r\nint i = ll_sa_entry_hash(entry->se_qstr.hash);\r\nspin_lock(&sai->sai_cache_lock[i]);\r\nlist_del_init(&entry->se_hash);\r\nspin_unlock(&sai->sai_cache_lock[i]);\r\n}\r\nstatic inline int agl_should_run(struct ll_statahead_info *sai,\r\nstruct inode *inode)\r\n{\r\nreturn (inode != NULL && S_ISREG(inode->i_mode) && sai->sai_agl_valid);\r\n}\r\nstatic inline struct ll_sa_entry *\r\nsa_first_received_entry(struct ll_statahead_info *sai)\r\n{\r\nreturn list_entry(sai->sai_entries_received.next,\r\nstruct ll_sa_entry, se_list);\r\n}\r\nstatic inline struct ll_inode_info *\r\nagl_first_entry(struct ll_statahead_info *sai)\r\n{\r\nreturn list_entry(sai->sai_entries_agl.next,\r\nstruct ll_inode_info, lli_agl_list);\r\n}\r\nstatic inline int sa_sent_full(struct ll_statahead_info *sai)\r\n{\r\nreturn atomic_read(&sai->sai_cache_count) >= sai->sai_max;\r\n}\r\nstatic inline int sa_received_empty(struct ll_statahead_info *sai)\r\n{\r\nreturn list_empty(&sai->sai_entries_received);\r\n}\r\nstatic inline int agl_list_empty(struct ll_statahead_info *sai)\r\n{\r\nreturn list_empty(&sai->sai_entries_agl);\r\n}\r\nstatic inline int sa_low_hit(struct ll_statahead_info *sai)\r\n{\r\nreturn ((sai->sai_hit > 7 && sai->sai_hit < 4 * sai->sai_miss) ||\r\n(sai->sai_consecutive_miss > 8));\r\n}\r\nstatic inline int is_omitted_entry(struct ll_statahead_info *sai, __u64 index)\r\n{\r\nreturn ((__u64)sai->sai_max + index + SA_OMITTED_ENTRY_MAX <\r\nsai->sai_index);\r\n}\r\nstatic struct ll_sa_entry *\r\nll_sa_entry_alloc(struct ll_statahead_info *sai, __u64 index,\r\nconst char *name, int len)\r\n{\r\nstruct ll_inode_info *lli;\r\nstruct ll_sa_entry *entry;\r\nint entry_size;\r\nchar *dname;\r\nentry_size = sizeof(struct ll_sa_entry) + (len & ~3) + 4;\r\nOBD_ALLOC(entry, entry_size);\r\nif (unlikely(entry == NULL))\r\nreturn ERR_PTR(-ENOMEM);\r\nCDEBUG(D_READA, "alloc sa entry %.*s(%p) index "LPU64"\n",\r\nlen, name, entry, index);\r\nentry->se_index = index;\r\natomic_set(&entry->se_refcount, 2);\r\nentry->se_stat = SA_ENTRY_INIT;\r\nentry->se_size = entry_size;\r\ndname = (char *)entry + sizeof(struct ll_sa_entry);\r\nmemcpy(dname, name, len);\r\ndname[len] = 0;\r\nentry->se_qstr.hash = full_name_hash(name, len);\r\nentry->se_qstr.len = len;\r\nentry->se_qstr.name = dname;\r\nlli = ll_i2info(sai->sai_inode);\r\nspin_lock(&lli->lli_sa_lock);\r\nlist_add_tail(&entry->se_link, &sai->sai_entries);\r\nINIT_LIST_HEAD(&entry->se_list);\r\nll_sa_entry_enhash(sai, entry);\r\nspin_unlock(&lli->lli_sa_lock);\r\natomic_inc(&sai->sai_cache_count);\r\nreturn entry;\r\n}\r\nstatic struct ll_sa_entry *\r\nll_sa_entry_get_byname(struct ll_statahead_info *sai, const struct qstr *qstr)\r\n{\r\nstruct ll_sa_entry *entry;\r\nint i = ll_sa_entry_hash(qstr->hash);\r\nlist_for_each_entry(entry, &sai->sai_cache[i], se_hash) {\r\nif (entry->se_qstr.hash == qstr->hash &&\r\nentry->se_qstr.len == qstr->len &&\r\nmemcmp(entry->se_qstr.name, qstr->name, qstr->len) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ll_sa_entry *\r\nll_sa_entry_get_byindex(struct ll_statahead_info *sai, __u64 index)\r\n{\r\nstruct ll_sa_entry *entry;\r\nlist_for_each_entry(entry, &sai->sai_entries, se_link) {\r\nif (entry->se_index == index) {\r\nLASSERT(atomic_read(&entry->se_refcount) > 0);\r\natomic_inc(&entry->se_refcount);\r\nreturn entry;\r\n}\r\nif (entry->se_index > index)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ll_sa_entry_cleanup(struct ll_statahead_info *sai,\r\nstruct ll_sa_entry *entry)\r\n{\r\nstruct md_enqueue_info *minfo = entry->se_minfo;\r\nstruct ptlrpc_request *req = entry->se_req;\r\nif (minfo) {\r\nentry->se_minfo = NULL;\r\nll_intent_release(&minfo->mi_it);\r\niput(minfo->mi_dir);\r\nOBD_FREE_PTR(minfo);\r\n}\r\nif (req) {\r\nentry->se_req = NULL;\r\nptlrpc_req_finished(req);\r\n}\r\n}\r\nstatic void ll_sa_entry_put(struct ll_statahead_info *sai,\r\nstruct ll_sa_entry *entry)\r\n{\r\nif (atomic_dec_and_test(&entry->se_refcount)) {\r\nCDEBUG(D_READA, "free sa entry %.*s(%p) index "LPU64"\n",\r\nentry->se_qstr.len, entry->se_qstr.name, entry,\r\nentry->se_index);\r\nLASSERT(list_empty(&entry->se_link));\r\nLASSERT(list_empty(&entry->se_list));\r\nLASSERT(ll_sa_entry_unhashed(entry));\r\nll_sa_entry_cleanup(sai, entry);\r\nif (entry->se_inode)\r\niput(entry->se_inode);\r\nOBD_FREE(entry, entry->se_size);\r\natomic_dec(&sai->sai_cache_count);\r\n}\r\n}\r\nstatic inline void\r\ndo_sa_entry_fini(struct ll_statahead_info *sai, struct ll_sa_entry *entry)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_inode);\r\nLASSERT(!ll_sa_entry_unhashed(entry));\r\nLASSERT(!list_empty(&entry->se_link));\r\nll_sa_entry_unhash(sai, entry);\r\nspin_lock(&lli->lli_sa_lock);\r\nentry->se_stat = SA_ENTRY_DEST;\r\nlist_del_init(&entry->se_link);\r\nif (likely(!list_empty(&entry->se_list)))\r\nlist_del_init(&entry->se_list);\r\nspin_unlock(&lli->lli_sa_lock);\r\nll_sa_entry_put(sai, entry);\r\n}\r\nstatic void\r\nll_sa_entry_fini(struct ll_statahead_info *sai, struct ll_sa_entry *entry)\r\n{\r\nstruct ll_sa_entry *pos, *next;\r\nif (entry)\r\ndo_sa_entry_fini(sai, entry);\r\nlist_for_each_entry_safe(pos, next, &sai->sai_entries, se_link) {\r\nif (!is_omitted_entry(sai, pos->se_index))\r\nbreak;\r\ndo_sa_entry_fini(sai, pos);\r\n}\r\n}\r\nstatic void\r\ndo_sa_entry_to_stated(struct ll_statahead_info *sai,\r\nstruct ll_sa_entry *entry, se_stat_t stat)\r\n{\r\nstruct ll_sa_entry *se;\r\nstruct list_head *pos = &sai->sai_entries_stated;\r\nif (!list_empty(&entry->se_list))\r\nlist_del_init(&entry->se_list);\r\nlist_for_each_entry_reverse(se, &sai->sai_entries_stated, se_list) {\r\nif (se->se_index < entry->se_index) {\r\npos = &se->se_list;\r\nbreak;\r\n}\r\n}\r\nlist_add(&entry->se_list, pos);\r\nentry->se_stat = stat;\r\n}\r\nstatic int\r\nll_sa_entry_to_stated(struct ll_statahead_info *sai,\r\nstruct ll_sa_entry *entry, se_stat_t stat)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_inode);\r\nint ret = 1;\r\nll_sa_entry_cleanup(sai, entry);\r\nspin_lock(&lli->lli_sa_lock);\r\nif (likely(entry->se_stat != SA_ENTRY_DEST)) {\r\ndo_sa_entry_to_stated(sai, entry, stat);\r\nret = 0;\r\n}\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn ret;\r\n}\r\nstatic void ll_agl_add(struct ll_statahead_info *sai,\r\nstruct inode *inode, int index)\r\n{\r\nstruct ll_inode_info *child = ll_i2info(inode);\r\nstruct ll_inode_info *parent = ll_i2info(sai->sai_inode);\r\nint added = 0;\r\nspin_lock(&child->lli_agl_lock);\r\nif (child->lli_agl_index == 0) {\r\nchild->lli_agl_index = index;\r\nspin_unlock(&child->lli_agl_lock);\r\nLASSERT(list_empty(&child->lli_agl_list));\r\nigrab(inode);\r\nspin_lock(&parent->lli_agl_lock);\r\nif (agl_list_empty(sai))\r\nadded = 1;\r\nlist_add_tail(&child->lli_agl_list, &sai->sai_entries_agl);\r\nspin_unlock(&parent->lli_agl_lock);\r\n} else {\r\nspin_unlock(&child->lli_agl_lock);\r\n}\r\nif (added > 0)\r\nwake_up(&sai->sai_agl_thread.t_ctl_waitq);\r\n}\r\nstatic struct ll_statahead_info *ll_sai_alloc(void)\r\n{\r\nstruct ll_statahead_info *sai;\r\nint i;\r\nOBD_ALLOC_PTR(sai);\r\nif (!sai)\r\nreturn NULL;\r\natomic_set(&sai->sai_refcount, 1);\r\nspin_lock(&sai_generation_lock);\r\nsai->sai_generation = ++sai_generation;\r\nif (unlikely(sai_generation == 0))\r\nsai->sai_generation = ++sai_generation;\r\nspin_unlock(&sai_generation_lock);\r\nsai->sai_max = LL_SA_RPC_MIN;\r\nsai->sai_index = 1;\r\ninit_waitqueue_head(&sai->sai_waitq);\r\ninit_waitqueue_head(&sai->sai_thread.t_ctl_waitq);\r\ninit_waitqueue_head(&sai->sai_agl_thread.t_ctl_waitq);\r\nINIT_LIST_HEAD(&sai->sai_entries);\r\nINIT_LIST_HEAD(&sai->sai_entries_received);\r\nINIT_LIST_HEAD(&sai->sai_entries_stated);\r\nINIT_LIST_HEAD(&sai->sai_entries_agl);\r\nfor (i = 0; i < LL_SA_CACHE_SIZE; i++) {\r\nINIT_LIST_HEAD(&sai->sai_cache[i]);\r\nspin_lock_init(&sai->sai_cache_lock[i]);\r\n}\r\natomic_set(&sai->sai_cache_count, 0);\r\nreturn sai;\r\n}\r\nstatic inline struct ll_statahead_info *\r\nll_sai_get(struct ll_statahead_info *sai)\r\n{\r\natomic_inc(&sai->sai_refcount);\r\nreturn sai;\r\n}\r\nstatic void ll_sai_put(struct ll_statahead_info *sai)\r\n{\r\nstruct inode *inode = sai->sai_inode;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nif (atomic_dec_and_lock(&sai->sai_refcount, &lli->lli_sa_lock)) {\r\nstruct ll_sa_entry *entry, *next;\r\nif (unlikely(atomic_read(&sai->sai_refcount) > 0)) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn;\r\n}\r\nLASSERT(lli->lli_opendir_key == NULL);\r\nLASSERT(thread_is_stopped(&sai->sai_thread));\r\nLASSERT(thread_is_stopped(&sai->sai_agl_thread));\r\nlli->lli_sai = NULL;\r\nlli->lli_opendir_pid = 0;\r\nspin_unlock(&lli->lli_sa_lock);\r\nif (sai->sai_sent > sai->sai_replied)\r\nCDEBUG(D_READA,"statahead for dir "DFID" does not "\r\n"finish: [sent:"LPU64"] [replied:"LPU64"]\n",\r\nPFID(&lli->lli_fid),\r\nsai->sai_sent, sai->sai_replied);\r\nlist_for_each_entry_safe(entry, next,\r\n&sai->sai_entries, se_link)\r\ndo_sa_entry_fini(sai, entry);\r\nLASSERT(list_empty(&sai->sai_entries));\r\nLASSERT(sa_received_empty(sai));\r\nLASSERT(list_empty(&sai->sai_entries_stated));\r\nLASSERT(atomic_read(&sai->sai_cache_count) == 0);\r\nLASSERT(agl_list_empty(sai));\r\niput(inode);\r\nOBD_FREE_PTR(sai);\r\n}\r\n}\r\nstatic void ll_agl_trigger(struct inode *inode, struct ll_statahead_info *sai)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\n__u64 index = lli->lli_agl_index;\r\nint rc;\r\nLASSERT(list_empty(&lli->lli_agl_list));\r\nif (is_omitted_entry(sai, index + 1)) {\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nrc = down_write_trylock(&lli->lli_glimpse_sem);\r\nif (rc == 0) {\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nif (lli->lli_glimpse_time != 0 &&\r\ncfs_time_before(cfs_time_shift(-1), lli->lli_glimpse_time)) {\r\nup_write(&lli->lli_glimpse_sem);\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nCDEBUG(D_READA, "Handling (init) async glimpse: inode = "\r\nDFID", idx = "LPU64"\n", PFID(&lli->lli_fid), index);\r\ncl_agl(inode);\r\nlli->lli_agl_index = 0;\r\nlli->lli_glimpse_time = cfs_time_current();\r\nup_write(&lli->lli_glimpse_sem);\r\nCDEBUG(D_READA, "Handled (init) async glimpse: inode= "\r\nDFID", idx = "LPU64", rc = %d\n",\r\nPFID(&lli->lli_fid), index, rc);\r\niput(inode);\r\n}\r\nstatic void ll_post_statahead(struct ll_statahead_info *sai)\r\n{\r\nstruct inode *dir = sai->sai_inode;\r\nstruct inode *child;\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_sa_entry *entry;\r\nstruct md_enqueue_info *minfo;\r\nstruct lookup_intent *it;\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc = 0;\r\nspin_lock(&lli->lli_sa_lock);\r\nif (unlikely(sa_received_empty(sai))) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn;\r\n}\r\nentry = sa_first_received_entry(sai);\r\natomic_inc(&entry->se_refcount);\r\nlist_del_init(&entry->se_list);\r\nspin_unlock(&lli->lli_sa_lock);\r\nLASSERT(entry->se_handle != 0);\r\nminfo = entry->se_minfo;\r\nit = &minfo->mi_it;\r\nreq = entry->se_req;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nGOTO(out, rc = -EFAULT);\r\nchild = entry->se_inode;\r\nif (child == NULL) {\r\nLASSERT(fid_is_zero(&minfo->mi_data.op_fid2));\r\nif (body->valid & OBD_MD_MDS)\r\nGOTO(out, rc = -EAGAIN);\r\n} else {\r\nif (unlikely(!lu_fid_eq(&minfo->mi_data.op_fid2, &body->fid1))){\r\nentry->se_inode = NULL;\r\niput(child);\r\nchild = NULL;\r\n}\r\n}\r\nit->d.lustre.it_lock_handle = entry->se_handle;\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), it, ll_inode2fid(dir), NULL);\r\nif (rc != 1)\r\nGOTO(out, rc = -EAGAIN);\r\nrc = ll_prep_inode(&child, req, dir->i_sb, it);\r\nif (rc)\r\nGOTO(out, rc);\r\nCDEBUG(D_DLMTRACE, "setting l_data to inode %p (%lu/%u)\n",\r\nchild, child->i_ino, child->i_generation);\r\nll_set_lock_data(ll_i2sbi(dir)->ll_md_exp, child, it, NULL);\r\nentry->se_inode = child;\r\nif (agl_should_run(sai, child))\r\nll_agl_add(sai, child, entry->se_index);\r\nout:\r\nrc = ll_sa_entry_to_stated(sai, entry,\r\nrc < 0 ? SA_ENTRY_INVA : SA_ENTRY_SUCC);\r\nif (rc == 0 && entry->se_index == sai->sai_index_wait)\r\nwake_up(&sai->sai_waitq);\r\nll_sa_entry_put(sai, entry);\r\n}\r\nstatic int ll_statahead_interpret(struct ptlrpc_request *req,\r\nstruct md_enqueue_info *minfo, int rc)\r\n{\r\nstruct lookup_intent *it = &minfo->mi_it;\r\nstruct inode *dir = minfo->mi_dir;\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = NULL;\r\nstruct ll_sa_entry *entry;\r\nint wakeup;\r\nif (it_disposition(it, DISP_LOOKUP_NEG))\r\nrc = -ENOENT;\r\nspin_lock(&lli->lli_sa_lock);\r\nif (unlikely(lli->lli_sai == NULL ||\r\nlli->lli_sai->sai_generation != minfo->mi_generation)) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nGOTO(out, rc = -ESTALE);\r\n} else {\r\nsai = ll_sai_get(lli->lli_sai);\r\nif (unlikely(!thread_is_running(&sai->sai_thread))) {\r\nsai->sai_replied++;\r\nspin_unlock(&lli->lli_sa_lock);\r\nGOTO(out, rc = -EBADFD);\r\n}\r\nentry = ll_sa_entry_get_byindex(sai, minfo->mi_cbdata);\r\nif (entry == NULL) {\r\nsai->sai_replied++;\r\nspin_unlock(&lli->lli_sa_lock);\r\nGOTO(out, rc = -EIDRM);\r\n}\r\nif (rc != 0) {\r\ndo_sa_entry_to_stated(sai, entry, SA_ENTRY_INVA);\r\nwakeup = (entry->se_index == sai->sai_index_wait);\r\n} else {\r\nentry->se_minfo = minfo;\r\nentry->se_req = ptlrpc_request_addref(req);\r\nentry->se_handle = it->d.lustre.it_lock_handle;\r\nll_intent_drop_lock(it);\r\nwakeup = sa_received_empty(sai);\r\nlist_add_tail(&entry->se_list,\r\n&sai->sai_entries_received);\r\n}\r\nsai->sai_replied++;\r\nspin_unlock(&lli->lli_sa_lock);\r\nll_sa_entry_put(sai, entry);\r\nif (wakeup)\r\nwake_up(&sai->sai_thread.t_ctl_waitq);\r\n}\r\nout:\r\nif (rc != 0) {\r\nll_intent_release(it);\r\niput(dir);\r\nOBD_FREE_PTR(minfo);\r\n}\r\nif (sai != NULL)\r\nll_sai_put(sai);\r\nreturn rc;\r\n}\r\nstatic void sa_args_fini(struct md_enqueue_info *minfo,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\nLASSERT(minfo && einfo);\r\niput(minfo->mi_dir);\r\ncapa_put(minfo->mi_data.op_capa1);\r\ncapa_put(minfo->mi_data.op_capa2);\r\nOBD_FREE_PTR(minfo);\r\nOBD_FREE_PTR(einfo);\r\n}\r\nstatic int sa_args_init(struct inode *dir, struct inode *child,\r\nstruct ll_sa_entry *entry, struct md_enqueue_info **pmi,\r\nstruct ldlm_enqueue_info **pei,\r\nstruct obd_capa **pcapa)\r\n{\r\nstruct qstr *qstr = &entry->se_qstr;\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct md_enqueue_info *minfo;\r\nstruct ldlm_enqueue_info *einfo;\r\nstruct md_op_data *op_data;\r\nOBD_ALLOC_PTR(einfo);\r\nif (einfo == NULL)\r\nreturn -ENOMEM;\r\nOBD_ALLOC_PTR(minfo);\r\nif (minfo == NULL) {\r\nOBD_FREE_PTR(einfo);\r\nreturn -ENOMEM;\r\n}\r\nop_data = ll_prep_md_op_data(&minfo->mi_data, dir, child, qstr->name,\r\nqstr->len, 0, LUSTRE_OPC_ANY, NULL);\r\nif (IS_ERR(op_data)) {\r\nOBD_FREE_PTR(einfo);\r\nOBD_FREE_PTR(minfo);\r\nreturn PTR_ERR(op_data);\r\n}\r\nminfo->mi_it.it_op = IT_GETATTR;\r\nminfo->mi_dir = igrab(dir);\r\nminfo->mi_cb = ll_statahead_interpret;\r\nminfo->mi_generation = lli->lli_sai->sai_generation;\r\nminfo->mi_cbdata = entry->se_index;\r\neinfo->ei_type = LDLM_IBITS;\r\neinfo->ei_mode = it_to_lock_mode(&minfo->mi_it);\r\neinfo->ei_cb_bl = ll_md_blocking_ast;\r\neinfo->ei_cb_cp = ldlm_completion_ast;\r\neinfo->ei_cb_gl = NULL;\r\neinfo->ei_cbdata = NULL;\r\n*pmi = minfo;\r\n*pei = einfo;\r\npcapa[0] = op_data->op_capa1;\r\npcapa[1] = op_data->op_capa2;\r\nreturn 0;\r\n}\r\nstatic int do_sa_lookup(struct inode *dir, struct ll_sa_entry *entry)\r\n{\r\nstruct md_enqueue_info *minfo;\r\nstruct ldlm_enqueue_info *einfo;\r\nstruct obd_capa *capas[2];\r\nint rc;\r\nrc = sa_args_init(dir, NULL, entry, &minfo, &einfo, capas);\r\nif (rc)\r\nreturn rc;\r\nrc = md_intent_getattr_async(ll_i2mdexp(dir), minfo, einfo);\r\nif (!rc) {\r\ncapa_put(capas[0]);\r\ncapa_put(capas[1]);\r\n} else {\r\nsa_args_fini(minfo, einfo);\r\n}\r\nreturn rc;\r\n}\r\nstatic int do_sa_revalidate(struct inode *dir, struct ll_sa_entry *entry,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct lookup_intent it = { .it_op = IT_GETATTR,\r\n.d.lustre.it_lock_handle = 0 };\r\nstruct md_enqueue_info *minfo;\r\nstruct ldlm_enqueue_info *einfo;\r\nstruct obd_capa *capas[2];\r\nint rc;\r\nif (unlikely(inode == NULL))\r\nreturn 1;\r\nif (d_mountpoint(dentry))\r\nreturn 1;\r\nif (unlikely(dentry == dentry->d_sb->s_root))\r\nreturn 1;\r\nentry->se_inode = igrab(inode);\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), &it, ll_inode2fid(inode),NULL);\r\nif (rc == 1) {\r\nentry->se_handle = it.d.lustre.it_lock_handle;\r\nll_intent_release(&it);\r\nreturn 1;\r\n}\r\nrc = sa_args_init(dir, inode, entry, &minfo, &einfo, capas);\r\nif (rc) {\r\nentry->se_inode = NULL;\r\niput(inode);\r\nreturn rc;\r\n}\r\nrc = md_intent_getattr_async(ll_i2mdexp(dir), minfo, einfo);\r\nif (!rc) {\r\ncapa_put(capas[0]);\r\ncapa_put(capas[1]);\r\n} else {\r\nentry->se_inode = NULL;\r\niput(inode);\r\nsa_args_fini(minfo, einfo);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ll_statahead_one(struct dentry *parent, const char* entry_name,\r\nint entry_name_len)\r\n{\r\nstruct inode *dir = parent->d_inode;\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = lli->lli_sai;\r\nstruct dentry *dentry = NULL;\r\nstruct ll_sa_entry *entry;\r\nint rc;\r\nint rc1;\r\nentry = ll_sa_entry_alloc(sai, sai->sai_index, entry_name,\r\nentry_name_len);\r\nif (IS_ERR(entry))\r\nreturn;\r\ndentry = d_lookup(parent, &entry->se_qstr);\r\nif (!dentry) {\r\nrc = do_sa_lookup(dir, entry);\r\n} else {\r\nrc = do_sa_revalidate(dir, entry, dentry);\r\nif (rc == 1 && agl_should_run(sai, dentry->d_inode))\r\nll_agl_add(sai, dentry->d_inode, entry->se_index);\r\n}\r\nif (dentry != NULL)\r\ndput(dentry);\r\nif (rc) {\r\nrc1 = ll_sa_entry_to_stated(sai, entry,\r\nrc < 0 ? SA_ENTRY_INVA : SA_ENTRY_SUCC);\r\nif (rc1 == 0 && entry->se_index == sai->sai_index_wait)\r\nwake_up(&sai->sai_waitq);\r\n} else {\r\nsai->sai_sent++;\r\n}\r\nsai->sai_index++;\r\nll_sa_entry_put(sai, entry);\r\n}\r\nstatic int ll_agl_thread(void *arg)\r\n{\r\nstruct dentry *parent = (struct dentry *)arg;\r\nstruct inode *dir = parent->d_inode;\r\nstruct ll_inode_info *plli = ll_i2info(dir);\r\nstruct ll_inode_info *clli;\r\nstruct ll_sb_info *sbi = ll_i2sbi(dir);\r\nstruct ll_statahead_info *sai = ll_sai_get(plli->lli_sai);\r\nstruct ptlrpc_thread *thread = &sai->sai_agl_thread;\r\nstruct l_wait_info lwi = { 0 };\r\nCDEBUG(D_READA, "agl thread started: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\natomic_inc(&sbi->ll_agl_total);\r\nspin_lock(&plli->lli_agl_lock);\r\nsai->sai_agl_valid = 1;\r\nthread_set_flags(thread, SVC_RUNNING);\r\nspin_unlock(&plli->lli_agl_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nwhile (1) {\r\nl_wait_event(thread->t_ctl_waitq,\r\n!agl_list_empty(sai) ||\r\n!thread_is_running(thread),\r\n&lwi);\r\nif (!thread_is_running(thread))\r\nbreak;\r\nspin_lock(&plli->lli_agl_lock);\r\nif (!agl_list_empty(sai)) {\r\nclli = agl_first_entry(sai);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nll_agl_trigger(&clli->lli_vfs_inode, sai);\r\n} else {\r\nspin_unlock(&plli->lli_agl_lock);\r\n}\r\n}\r\nspin_lock(&plli->lli_agl_lock);\r\nsai->sai_agl_valid = 0;\r\nwhile (!agl_list_empty(sai)) {\r\nclli = agl_first_entry(sai);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nclli->lli_agl_index = 0;\r\niput(&clli->lli_vfs_inode);\r\nspin_lock(&plli->lli_agl_lock);\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nspin_unlock(&plli->lli_agl_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nll_sai_put(sai);\r\nCDEBUG(D_READA, "agl thread stopped: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\nreturn 0;\r\n}\r\nstatic void ll_start_agl(struct dentry *parent, struct ll_statahead_info *sai)\r\n{\r\nstruct ptlrpc_thread *thread = &sai->sai_agl_thread;\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ll_inode_info *plli;\r\nstruct task_struct *task;\r\nCDEBUG(D_READA, "start agl thread: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\nplli = ll_i2info(parent->d_inode);\r\ntask = kthread_run(ll_agl_thread, parent,\r\n"ll_agl_%u", plli->lli_opendir_pid);\r\nif (IS_ERR(task)) {\r\nCERROR("can't start ll_agl thread, rc: %ld\n", PTR_ERR(task));\r\nthread_set_flags(thread, SVC_STOPPED);\r\nreturn;\r\n}\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_running(thread) || thread_is_stopped(thread),\r\n&lwi);\r\n}\r\nstatic int ll_statahead_thread(void *arg)\r\n{\r\nstruct dentry *parent = (struct dentry *)arg;\r\nstruct inode *dir = parent->d_inode;\r\nstruct ll_inode_info *plli = ll_i2info(dir);\r\nstruct ll_inode_info *clli;\r\nstruct ll_sb_info *sbi = ll_i2sbi(dir);\r\nstruct ll_statahead_info *sai = ll_sai_get(plli->lli_sai);\r\nstruct ptlrpc_thread *thread = &sai->sai_thread;\r\nstruct ptlrpc_thread *agl_thread = &sai->sai_agl_thread;\r\nstruct page *page;\r\n__u64 pos = 0;\r\nint first = 0;\r\nint rc = 0;\r\nstruct ll_dir_chain chain;\r\nstruct l_wait_info lwi = { 0 };\r\nCDEBUG(D_READA, "statahead thread started: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\nif (sbi->ll_flags & LL_SBI_AGL_ENABLED)\r\nll_start_agl(parent, sai);\r\natomic_inc(&sbi->ll_sa_total);\r\nspin_lock(&plli->lli_sa_lock);\r\nthread_set_flags(thread, SVC_RUNNING);\r\nspin_unlock(&plli->lli_sa_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nll_dir_chain_init(&chain);\r\npage = ll_get_dir_page(dir, pos, &chain);\r\nwhile (1) {\r\nstruct lu_dirpage *dp;\r\nstruct lu_dirent *ent;\r\nif (IS_ERR(page)) {\r\nrc = PTR_ERR(page);\r\nCDEBUG(D_READA, "error reading dir "DFID" at "LPU64\r\n"/"LPU64": [rc %d] [parent %u]\n",\r\nPFID(ll_inode2fid(dir)), pos, sai->sai_index,\r\nrc, plli->lli_opendir_pid);\r\nGOTO(out, rc);\r\n}\r\ndp = page_address(page);\r\nfor (ent = lu_dirent_start(dp); ent != NULL;\r\nent = lu_dirent_next(ent)) {\r\n__u64 hash;\r\nint namelen;\r\nchar *name;\r\nhash = le64_to_cpu(ent->lde_hash);\r\nif (unlikely(hash < pos))\r\ncontinue;\r\nnamelen = le16_to_cpu(ent->lde_namelen);\r\nif (unlikely(namelen == 0))\r\ncontinue;\r\nname = ent->lde_name;\r\nif (name[0] == '.') {\r\nif (namelen == 1) {\r\ncontinue;\r\n} else if (name[1] == '.' && namelen == 2) {\r\ncontinue;\r\n} else if (!sai->sai_ls_all) {\r\nsai->sai_skip_hidden++;\r\ncontinue;\r\n}\r\n}\r\nif (unlikely(++first == 1))\r\ncontinue;\r\nkeep_it:\r\nl_wait_event(thread->t_ctl_waitq,\r\n!sa_sent_full(sai) ||\r\n!sa_received_empty(sai) ||\r\n!agl_list_empty(sai) ||\r\n!thread_is_running(thread),\r\n&lwi);\r\ninterpret_it:\r\nwhile (!sa_received_empty(sai))\r\nll_post_statahead(sai);\r\nif (unlikely(!thread_is_running(thread))) {\r\nll_release_page(page, 0);\r\nGOTO(out, rc = 0);\r\n}\r\nif (sa_sent_full(sai)) {\r\nspin_lock(&plli->lli_agl_lock);\r\nwhile (!agl_list_empty(sai)) {\r\nclli = agl_first_entry(sai);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nll_agl_trigger(&clli->lli_vfs_inode,\r\nsai);\r\nif (!sa_received_empty(sai))\r\ngoto interpret_it;\r\nif (unlikely(\r\n!thread_is_running(thread))) {\r\nll_release_page(page, 0);\r\nGOTO(out, rc = 0);\r\n}\r\nif (!sa_sent_full(sai))\r\ngoto do_it;\r\nspin_lock(&plli->lli_agl_lock);\r\n}\r\nspin_unlock(&plli->lli_agl_lock);\r\ngoto keep_it;\r\n}\r\ndo_it:\r\nll_statahead_one(parent, name, namelen);\r\n}\r\npos = le64_to_cpu(dp->ldp_hash_end);\r\nif (pos == MDS_DIR_END_OFF) {\r\nll_release_page(page, 0);\r\nwhile (1) {\r\nl_wait_event(thread->t_ctl_waitq,\r\n!sa_received_empty(sai) ||\r\nsai->sai_sent == sai->sai_replied||\r\n!thread_is_running(thread),\r\n&lwi);\r\nwhile (!sa_received_empty(sai))\r\nll_post_statahead(sai);\r\nif (unlikely(!thread_is_running(thread)))\r\nGOTO(out, rc = 0);\r\nif (sai->sai_sent == sai->sai_replied &&\r\nsa_received_empty(sai))\r\nbreak;\r\n}\r\nspin_lock(&plli->lli_agl_lock);\r\nwhile (!agl_list_empty(sai) &&\r\nthread_is_running(thread)) {\r\nclli = agl_first_entry(sai);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nll_agl_trigger(&clli->lli_vfs_inode, sai);\r\nspin_lock(&plli->lli_agl_lock);\r\n}\r\nspin_unlock(&plli->lli_agl_lock);\r\nGOTO(out, rc = 0);\r\n} else if (1) {\r\nll_release_page(page, le32_to_cpu(dp->ldp_flags) &\r\nLDF_COLLIDE);\r\nsai->sai_in_readpage = 1;\r\npage = ll_get_dir_page(dir, pos, &chain);\r\nsai->sai_in_readpage = 0;\r\n} else {\r\nLASSERT(le32_to_cpu(dp->ldp_flags) & LDF_COLLIDE);\r\nll_release_page(page, 1);\r\n}\r\n}\r\nout:\r\nif (sai->sai_agl_valid) {\r\nspin_lock(&plli->lli_agl_lock);\r\nthread_set_flags(agl_thread, SVC_STOPPING);\r\nspin_unlock(&plli->lli_agl_lock);\r\nwake_up(&agl_thread->t_ctl_waitq);\r\nCDEBUG(D_READA, "stop agl thread: [pid %d]\n",\r\ncurrent_pid());\r\nl_wait_event(agl_thread->t_ctl_waitq,\r\nthread_is_stopped(agl_thread),\r\n&lwi);\r\n} else {\r\nthread_set_flags(&sai->sai_agl_thread, SVC_STOPPED);\r\n}\r\nll_dir_chain_fini(&chain);\r\nspin_lock(&plli->lli_sa_lock);\r\nif (!sa_received_empty(sai)) {\r\nthread_set_flags(thread, SVC_STOPPING);\r\nspin_unlock(&plli->lli_sa_lock);\r\nwhile (!sa_received_empty(sai))\r\nll_post_statahead(sai);\r\nspin_lock(&plli->lli_sa_lock);\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nspin_unlock(&plli->lli_sa_lock);\r\nwake_up(&sai->sai_waitq);\r\nwake_up(&thread->t_ctl_waitq);\r\nll_sai_put(sai);\r\ndput(parent);\r\nCDEBUG(D_READA, "statahead thread stopped: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\nreturn rc;\r\n}\r\nvoid ll_stop_statahead(struct inode *dir, void *key)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nif (unlikely(key == NULL))\r\nreturn;\r\nspin_lock(&lli->lli_sa_lock);\r\nif (lli->lli_opendir_key != key || lli->lli_opendir_pid == 0) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn;\r\n}\r\nlli->lli_opendir_key = NULL;\r\nif (lli->lli_sai) {\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ptlrpc_thread *thread = &lli->lli_sai->sai_thread;\r\nif (!thread_is_stopped(thread)) {\r\nthread_set_flags(thread, SVC_STOPPING);\r\nspin_unlock(&lli->lli_sa_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_READA, "stop statahead thread: [pid %d]\n",\r\ncurrent_pid());\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopped(thread),\r\n&lwi);\r\n} else {\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\nll_sai_put(lli->lli_sai);\r\n} else {\r\nlli->lli_opendir_pid = 0;\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\n}\r\nstatic int is_first_dirent(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct ll_dir_chain chain;\r\nstruct qstr *target = &dentry->d_name;\r\nstruct page *page;\r\n__u64 pos = 0;\r\nint dot_de;\r\nint rc = LS_NONE_FIRST_DE;\r\nll_dir_chain_init(&chain);\r\npage = ll_get_dir_page(dir, pos, &chain);\r\nwhile (1) {\r\nstruct lu_dirpage *dp;\r\nstruct lu_dirent *ent;\r\nif (IS_ERR(page)) {\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nrc = PTR_ERR(page);\r\nCERROR("error reading dir "DFID" at "LPU64": "\r\n"[rc %d] [parent %u]\n",\r\nPFID(ll_inode2fid(dir)), pos,\r\nrc, lli->lli_opendir_pid);\r\nbreak;\r\n}\r\ndp = page_address(page);\r\nfor (ent = lu_dirent_start(dp); ent != NULL;\r\nent = lu_dirent_next(ent)) {\r\n__u64 hash;\r\nint namelen;\r\nchar *name;\r\nhash = le64_to_cpu(ent->lde_hash);\r\nif (unlikely(hash < pos))\r\ncontinue;\r\nnamelen = le16_to_cpu(ent->lde_namelen);\r\nif (unlikely(namelen == 0))\r\ncontinue;\r\nname = ent->lde_name;\r\nif (name[0] == '.') {\r\nif (namelen == 1)\r\ncontinue;\r\nelse if (name[1] == '.' && namelen == 2)\r\ncontinue;\r\nelse\r\ndot_de = 1;\r\n} else {\r\ndot_de = 0;\r\n}\r\nif (dot_de && target->name[0] != '.') {\r\nCDEBUG(D_READA, "%.*s skip hidden file %.*s\n",\r\ntarget->len, target->name,\r\nnamelen, name);\r\ncontinue;\r\n}\r\nif (target->len != namelen ||\r\nmemcmp(target->name, name, namelen) != 0)\r\nrc = LS_NONE_FIRST_DE;\r\nelse if (!dot_de)\r\nrc = LS_FIRST_DE;\r\nelse\r\nrc = LS_FIRST_DOT_DE;\r\nll_release_page(page, 0);\r\nGOTO(out, rc);\r\n}\r\npos = le64_to_cpu(dp->ldp_hash_end);\r\nif (pos == MDS_DIR_END_OFF) {\r\nll_release_page(page, 0);\r\nbreak;\r\n} else if (1) {\r\nll_release_page(page, le32_to_cpu(dp->ldp_flags) &\r\nLDF_COLLIDE);\r\npage = ll_get_dir_page(dir, pos, &chain);\r\n} else {\r\nLASSERT(le32_to_cpu(dp->ldp_flags) & LDF_COLLIDE);\r\nll_release_page(page, 1);\r\n}\r\n}\r\nout:\r\nll_dir_chain_fini(&chain);\r\nreturn rc;\r\n}\r\nstatic void\r\nll_sai_unplug(struct ll_statahead_info *sai, struct ll_sa_entry *entry)\r\n{\r\nstruct ptlrpc_thread *thread = &sai->sai_thread;\r\nstruct ll_sb_info *sbi = ll_i2sbi(sai->sai_inode);\r\nint hit;\r\nif (entry != NULL && entry->se_stat == SA_ENTRY_SUCC)\r\nhit = 1;\r\nelse\r\nhit = 0;\r\nll_sa_entry_fini(sai, entry);\r\nif (hit) {\r\nsai->sai_hit++;\r\nsai->sai_consecutive_miss = 0;\r\nsai->sai_max = min(2 * sai->sai_max, sbi->ll_sa_max);\r\n} else {\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_inode);\r\nsai->sai_miss++;\r\nsai->sai_consecutive_miss++;\r\nif (sa_low_hit(sai) && thread_is_running(thread)) {\r\natomic_inc(&sbi->ll_sa_wrong);\r\nCDEBUG(D_READA, "Statahead for dir "DFID" hit "\r\n"ratio too low: hit/miss "LPU64"/"LPU64\r\n", sent/replied "LPU64"/"LPU64", stopping "\r\n"statahead thread: pid %d\n",\r\nPFID(&lli->lli_fid), sai->sai_hit,\r\nsai->sai_miss, sai->sai_sent,\r\nsai->sai_replied, current_pid());\r\nspin_lock(&lli->lli_sa_lock);\r\nif (!thread_is_stopped(thread))\r\nthread_set_flags(thread, SVC_STOPPING);\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\n}\r\nif (!thread_is_stopped(thread))\r\nwake_up(&thread->t_ctl_waitq);\r\n}\r\nint do_statahead_enter(struct inode *dir, struct dentry **dentryp,\r\nint only_unplug)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = lli->lli_sai;\r\nstruct dentry *parent;\r\nstruct ll_sa_entry *entry;\r\nstruct ptlrpc_thread *thread;\r\nstruct l_wait_info lwi = { 0 };\r\nint rc = 0;\r\nstruct ll_inode_info *plli;\r\nLASSERT(lli->lli_opendir_pid == current_pid());\r\nif (sai) {\r\nthread = &sai->sai_thread;\r\nif (unlikely(thread_is_stopped(thread) &&\r\nlist_empty(&sai->sai_entries_stated))) {\r\nll_stop_statahead(dir, lli->lli_opendir_key);\r\nreturn -EAGAIN;\r\n}\r\nif ((*dentryp)->d_name.name[0] == '.') {\r\nif (sai->sai_ls_all ||\r\nsai->sai_miss_hidden >= sai->sai_skip_hidden) {\r\n} else {\r\nif (!sai->sai_ls_all)\r\nsai->sai_ls_all = 1;\r\nsai->sai_miss_hidden++;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nentry = ll_sa_entry_get_byname(sai, &(*dentryp)->d_name);\r\nif (entry == NULL || only_unplug) {\r\nll_sai_unplug(sai, entry);\r\nreturn entry ? 1 : -EAGAIN;\r\n}\r\nwhile (!ll_sa_entry_stated(entry) &&\r\nsai->sai_in_readpage &&\r\n!sa_received_empty(sai))\r\nll_post_statahead(sai);\r\nif (!ll_sa_entry_stated(entry)) {\r\nsai->sai_index_wait = entry->se_index;\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(30), NULL,\r\nLWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(sai->sai_waitq,\r\nll_sa_entry_stated(entry) ||\r\nthread_is_stopped(thread),\r\n&lwi);\r\nif (rc < 0) {\r\nll_sai_unplug(sai, entry);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nif (entry->se_stat == SA_ENTRY_SUCC &&\r\nentry->se_inode != NULL) {\r\nstruct inode *inode = entry->se_inode;\r\nstruct lookup_intent it = { .it_op = IT_GETATTR,\r\n.d.lustre.it_lock_handle =\r\nentry->se_handle };\r\n__u64 bits;\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), &it,\r\nll_inode2fid(inode), &bits);\r\nif (rc == 1) {\r\nif ((*dentryp)->d_inode == NULL) {\r\n*dentryp = ll_splice_alias(inode,\r\n*dentryp);\r\n} else if ((*dentryp)->d_inode != inode) {\r\nCDEBUG(D_READA,\r\n"stale dentry %.*s inode %lu/%u, "\r\n"statahead inode %lu/%u\n",\r\n(*dentryp)->d_name.len,\r\n(*dentryp)->d_name.name,\r\n(*dentryp)->d_inode->i_ino,\r\n(*dentryp)->d_inode->i_generation,\r\ninode->i_ino,\r\ninode->i_generation);\r\nll_sai_unplug(sai, entry);\r\nreturn -ESTALE;\r\n} else {\r\niput(inode);\r\n}\r\nentry->se_inode = NULL;\r\nif ((bits & MDS_INODELOCK_LOOKUP) &&\r\nd_lustre_invalid(*dentryp))\r\nd_lustre_revalidate(*dentryp);\r\nll_intent_release(&it);\r\n}\r\n}\r\nll_sai_unplug(sai, entry);\r\nreturn rc;\r\n}\r\nrc = is_first_dirent(dir, *dentryp);\r\nif (rc == LS_NONE_FIRST_DE)\r\nGOTO(out, rc = -EAGAIN);\r\nsai = ll_sai_alloc();\r\nif (sai == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nsai->sai_ls_all = (rc == LS_FIRST_DOT_DE);\r\nsai->sai_inode = igrab(dir);\r\nif (unlikely(sai->sai_inode == NULL)) {\r\nCWARN("Do not start stat ahead on dying inode "DFID"\n",\r\nPFID(&lli->lli_fid));\r\nGOTO(out, rc = -ESTALE);\r\n}\r\nparent = dget((*dentryp)->d_parent);\r\nif (unlikely(sai->sai_inode != parent->d_inode)) {\r\nstruct ll_inode_info *nlli = ll_i2info(parent->d_inode);\r\nCWARN("Race condition, someone changed %.*s just now: "\r\n"old parent "DFID", new parent "DFID"\n",\r\n(*dentryp)->d_name.len, (*dentryp)->d_name.name,\r\nPFID(&lli->lli_fid), PFID(&nlli->lli_fid));\r\ndput(parent);\r\niput(sai->sai_inode);\r\nGOTO(out, rc = -EAGAIN);\r\n}\r\nCDEBUG(D_READA, "start statahead thread: [pid %d] [parent %.*s]\n",\r\ncurrent_pid(), parent->d_name.len, parent->d_name.name);\r\nlli->lli_sai = sai;\r\nplli = ll_i2info(parent->d_inode);\r\nrc = PTR_ERR(kthread_run(ll_statahead_thread, parent,\r\n"ll_sa_%u", plli->lli_opendir_pid));\r\nthread = &sai->sai_thread;\r\nif (IS_ERR_VALUE(rc)) {\r\nCERROR("can't start ll_sa thread, rc: %d\n", rc);\r\ndput(parent);\r\nlli->lli_opendir_key = NULL;\r\nthread_set_flags(thread, SVC_STOPPED);\r\nthread_set_flags(&sai->sai_agl_thread, SVC_STOPPED);\r\nll_sai_put(sai);\r\nLASSERT(lli->lli_sai == NULL);\r\nreturn -EAGAIN;\r\n}\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_running(thread) || thread_is_stopped(thread),\r\n&lwi);\r\nreturn -EAGAIN;\r\nout:\r\nif (sai != NULL)\r\nOBD_FREE_PTR(sai);\r\nspin_lock(&lli->lli_sa_lock);\r\nlli->lli_opendir_key = NULL;\r\nlli->lli_opendir_pid = 0;\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn rc;\r\n}
