static void vegas_enable(struct sock *sk)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nstruct vegas *vegas = inet_csk_ca(sk);\r\nvegas->doing_vegas_now = 1;\r\nvegas->beg_snd_nxt = tp->snd_nxt;\r\nvegas->cntRTT = 0;\r\nvegas->minRTT = 0x7fffffff;\r\n}\r\nstatic inline void vegas_disable(struct sock *sk)\r\n{\r\nstruct vegas *vegas = inet_csk_ca(sk);\r\nvegas->doing_vegas_now = 0;\r\n}\r\nvoid tcp_vegas_init(struct sock *sk)\r\n{\r\nstruct vegas *vegas = inet_csk_ca(sk);\r\nvegas->baseRTT = 0x7fffffff;\r\nvegas_enable(sk);\r\n}\r\nvoid tcp_vegas_pkts_acked(struct sock *sk, u32 cnt, s32 rtt_us)\r\n{\r\nstruct vegas *vegas = inet_csk_ca(sk);\r\nu32 vrtt;\r\nif (rtt_us < 0)\r\nreturn;\r\nvrtt = rtt_us + 1;\r\nif (vrtt < vegas->baseRTT)\r\nvegas->baseRTT = vrtt;\r\nvegas->minRTT = min(vegas->minRTT, vrtt);\r\nvegas->cntRTT++;\r\n}\r\nvoid tcp_vegas_state(struct sock *sk, u8 ca_state)\r\n{\r\nif (ca_state == TCP_CA_Open)\r\nvegas_enable(sk);\r\nelse\r\nvegas_disable(sk);\r\n}\r\nvoid tcp_vegas_cwnd_event(struct sock *sk, enum tcp_ca_event event)\r\n{\r\nif (event == CA_EVENT_CWND_RESTART ||\r\nevent == CA_EVENT_TX_START)\r\ntcp_vegas_init(sk);\r\n}\r\nstatic inline u32 tcp_vegas_ssthresh(struct tcp_sock *tp)\r\n{\r\nreturn min(tp->snd_ssthresh, tp->snd_cwnd-1);\r\n}\r\nstatic void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 acked,\r\nu32 in_flight)\r\n{\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct vegas *vegas = inet_csk_ca(sk);\r\nif (!vegas->doing_vegas_now) {\r\ntcp_reno_cong_avoid(sk, ack, acked, in_flight);\r\nreturn;\r\n}\r\nif (after(ack, vegas->beg_snd_nxt)) {\r\nvegas->beg_snd_nxt = tp->snd_nxt;\r\nif (vegas->cntRTT <= 2) {\r\ntcp_reno_cong_avoid(sk, ack, acked, in_flight);\r\n} else {\r\nu32 rtt, diff;\r\nu64 target_cwnd;\r\nrtt = vegas->minRTT;\r\ntarget_cwnd = tp->snd_cwnd * vegas->baseRTT / rtt;\r\ndiff = tp->snd_cwnd * (rtt-vegas->baseRTT) / vegas->baseRTT;\r\nif (diff > gamma && tp->snd_cwnd <= tp->snd_ssthresh) {\r\ntp->snd_cwnd = min(tp->snd_cwnd, (u32)target_cwnd+1);\r\ntp->snd_ssthresh = tcp_vegas_ssthresh(tp);\r\n} else if (tp->snd_cwnd <= tp->snd_ssthresh) {\r\ntcp_slow_start(tp, acked);\r\n} else {\r\nif (diff > beta) {\r\ntp->snd_cwnd--;\r\ntp->snd_ssthresh\r\n= tcp_vegas_ssthresh(tp);\r\n} else if (diff < alpha) {\r\ntp->snd_cwnd++;\r\n} else {\r\n}\r\n}\r\nif (tp->snd_cwnd < 2)\r\ntp->snd_cwnd = 2;\r\nelse if (tp->snd_cwnd > tp->snd_cwnd_clamp)\r\ntp->snd_cwnd = tp->snd_cwnd_clamp;\r\ntp->snd_ssthresh = tcp_current_ssthresh(sk);\r\n}\r\nvegas->cntRTT = 0;\r\nvegas->minRTT = 0x7fffffff;\r\n}\r\nelse if (tp->snd_cwnd <= tp->snd_ssthresh)\r\ntcp_slow_start(tp, acked);\r\n}\r\nvoid tcp_vegas_get_info(struct sock *sk, u32 ext, struct sk_buff *skb)\r\n{\r\nconst struct vegas *ca = inet_csk_ca(sk);\r\nif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\r\nstruct tcpvegas_info info = {\r\n.tcpv_enabled = ca->doing_vegas_now,\r\n.tcpv_rttcnt = ca->cntRTT,\r\n.tcpv_rtt = ca->baseRTT,\r\n.tcpv_minrtt = ca->minRTT,\r\n};\r\nnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\r\n}\r\n}\r\nstatic int __init tcp_vegas_register(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct vegas) > ICSK_CA_PRIV_SIZE);\r\ntcp_register_congestion_control(&tcp_vegas);\r\nreturn 0;\r\n}\r\nstatic void __exit tcp_vegas_unregister(void)\r\n{\r\ntcp_unregister_congestion_control(&tcp_vegas);\r\n}
