static inline void *\r\nfind_pa(unsigned long *vptb, void *ptr)\r\n{\r\nunsigned long address = (unsigned long) ptr;\r\nunsigned long result;\r\nresult = vptb[address >> 13];\r\nresult >>= 32;\r\nresult <<= 13;\r\nresult |= address & 0x1fff;\r\nreturn (void *) result;\r\n}\r\nvoid\r\npal_init(void)\r\n{\r\nunsigned long i, rev;\r\nstruct percpu_struct * percpu;\r\nstruct pcb_struct * pcb_pa;\r\npcb_va->ksp = 0;\r\npcb_va->usp = 0;\r\npcb_va->ptbr = L1[1] >> 32;\r\npcb_va->asn = 0;\r\npcb_va->pcc = 0;\r\npcb_va->unique = 0;\r\npcb_va->flags = 1;\r\npcb_va->res1 = 0;\r\npcb_va->res2 = 0;\r\npcb_pa = find_pa(VPTB, pcb_va);\r\nsrm_printk("Switching to OSF PAL-code .. ");\r\ni = switch_to_osf_pal(2, pcb_va, pcb_pa, VPTB);\r\nif (i) {\r\nsrm_printk("failed, code %ld\n", i);\r\n__halt();\r\n}\r\npercpu = (struct percpu_struct *)\r\n(INIT_HWRPB->processor_offset + (unsigned long) INIT_HWRPB);\r\nrev = percpu->pal_revision = percpu->palcode_avail[2];\r\nsrm_printk("Ok (rev %lx)\n", rev);\r\ntbia();\r\n}\r\nstatic inline void\r\nload(unsigned long dst, unsigned long src, unsigned long count)\r\n{\r\nmemcpy((void *)dst, (void *)src, count);\r\n}\r\nstatic inline void\r\nrunkernel(void)\r\n{\r\n__asm__ __volatile__(\r\n"bis %0,%0,$27\n\t"\r\n"jmp ($27)"\r\n:\r\n: "r" (START_ADDR));\r\n}\r\nvoid\r\nstart_kernel(void)\r\n{\r\nstatic long nbytes;\r\nstatic char envval[256] __attribute__((aligned(8)));\r\nstatic unsigned long initrd_start;\r\nsrm_printk("Linux/AXP bootp loader for Linux " UTS_RELEASE "\n");\r\nif (INIT_HWRPB->pagesize != 8192) {\r\nsrm_printk("Expected 8kB pages, got %ldkB\n",\r\nINIT_HWRPB->pagesize >> 10);\r\nreturn;\r\n}\r\nif (INIT_HWRPB->vptb != (unsigned long) VPTB) {\r\nsrm_printk("Expected vptb at %p, got %p\n",\r\nVPTB, (void *)INIT_HWRPB->vptb);\r\nreturn;\r\n}\r\npal_init();\r\ninitrd_start = ((START_ADDR + 5*KERNEL_SIZE + PAGE_SIZE) |\r\n(PAGE_SIZE-1)) + 1;\r\n#ifdef INITRD_IMAGE_SIZE\r\nsrm_printk("Initrd positioned at %#lx\n", initrd_start);\r\n#endif\r\nmove_stack(initrd_start - PAGE_SIZE);\r\nnbytes = callback_getenv(ENV_BOOTED_OSFLAGS, envval, sizeof(envval));\r\nif (nbytes < 0 || nbytes >= sizeof(envval)) {\r\nnbytes = 0;\r\n}\r\nenvval[nbytes] = '\0';\r\nsrm_printk("Loading the kernel...'%s'\n", envval);\r\n#ifdef INITRD_IMAGE_SIZE\r\nload(initrd_start, KERNEL_ORIGIN+KERNEL_SIZE, INITRD_IMAGE_SIZE);\r\n#endif\r\nload(START_ADDR+(4*KERNEL_SIZE), KERNEL_ORIGIN, KERNEL_SIZE);\r\nload(START_ADDR, START_ADDR+(4*KERNEL_SIZE), KERNEL_SIZE);\r\nmemset((char*)ZERO_PGE, 0, PAGE_SIZE);\r\nstrcpy((char*)ZERO_PGE, envval);\r\n#ifdef INITRD_IMAGE_SIZE\r\n((long *)(ZERO_PGE+256))[0] = initrd_start;\r\n((long *)(ZERO_PGE+256))[1] = INITRD_IMAGE_SIZE;\r\n#endif\r\nrunkernel();\r\n}
