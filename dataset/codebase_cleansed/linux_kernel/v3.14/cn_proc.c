static inline struct cn_msg *buffer_to_cn_msg(__u8 *buffer)\r\n{\r\nBUILD_BUG_ON(sizeof(struct cn_msg) != 20);\r\nreturn (struct cn_msg *)(buffer + 4);\r\n}\r\nstatic inline void get_seq(__u32 *ts, int *cpu)\r\n{\r\npreempt_disable();\r\n*ts = __this_cpu_inc_return(proc_event_counts) - 1;\r\n*cpu = smp_processor_id();\r\npreempt_enable();\r\n}\r\nvoid proc_fork_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nstruct timespec ts;\r\nstruct task_struct *parent;\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_FORK;\r\nrcu_read_lock();\r\nparent = rcu_dereference(task->real_parent);\r\nev->event_data.fork.parent_pid = parent->pid;\r\nev->event_data.fork.parent_tgid = parent->tgid;\r\nrcu_read_unlock();\r\nev->event_data.fork.child_pid = task->pid;\r\nev->event_data.fork.child_tgid = task->tgid;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_exec_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\nstruct timespec ts;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_EXEC;\r\nev->event_data.exec.process_pid = task->pid;\r\nev->event_data.exec.process_tgid = task->tgid;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_id_connector(struct task_struct *task, int which_id)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nstruct timespec ts;\r\nconst struct cred *cred;\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nev->what = which_id;\r\nev->event_data.id.process_pid = task->pid;\r\nev->event_data.id.process_tgid = task->tgid;\r\nrcu_read_lock();\r\ncred = __task_cred(task);\r\nif (which_id == PROC_EVENT_UID) {\r\nev->event_data.id.r.ruid = from_kuid_munged(&init_user_ns, cred->uid);\r\nev->event_data.id.e.euid = from_kuid_munged(&init_user_ns, cred->euid);\r\n} else if (which_id == PROC_EVENT_GID) {\r\nev->event_data.id.r.rgid = from_kgid_munged(&init_user_ns, cred->gid);\r\nev->event_data.id.e.egid = from_kgid_munged(&init_user_ns, cred->egid);\r\n} else {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_sid_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\nstruct timespec ts;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_SID;\r\nev->event_data.sid.process_pid = task->pid;\r\nev->event_data.sid.process_tgid = task->tgid;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_ptrace_connector(struct task_struct *task, int ptrace_id)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\nstruct timespec ts;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_PTRACE;\r\nev->event_data.ptrace.process_pid = task->pid;\r\nev->event_data.ptrace.process_tgid = task->tgid;\r\nif (ptrace_id == PTRACE_ATTACH) {\r\nev->event_data.ptrace.tracer_pid = current->pid;\r\nev->event_data.ptrace.tracer_tgid = current->tgid;\r\n} else if (ptrace_id == PTRACE_DETACH) {\r\nev->event_data.ptrace.tracer_pid = 0;\r\nev->event_data.ptrace.tracer_tgid = 0;\r\n} else\r\nreturn;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_comm_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\nstruct timespec ts;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_COMM;\r\nev->event_data.comm.process_pid = task->pid;\r\nev->event_data.comm.process_tgid = task->tgid;\r\nget_task_comm(ev->event_data.comm.comm, task);\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_coredump_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nstruct timespec ts;\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_COREDUMP;\r\nev->event_data.coredump.process_pid = task->pid;\r\nev->event_data.coredump.process_tgid = task->tgid;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nvoid proc_exit_connector(struct task_struct *task)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nstruct timespec ts;\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nget_seq(&msg->seq, &ev->cpu);\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->what = PROC_EVENT_EXIT;\r\nev->event_data.exit.process_pid = task->pid;\r\nev->event_data.exit.process_tgid = task->tgid;\r\nev->event_data.exit.exit_code = task->exit_code;\r\nev->event_data.exit.exit_signal = task->exit_signal;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = 0;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nstatic void cn_proc_ack(int err, int rcvd_seq, int rcvd_ack)\r\n{\r\nstruct cn_msg *msg;\r\nstruct proc_event *ev;\r\n__u8 buffer[CN_PROC_MSG_SIZE] __aligned(8);\r\nstruct timespec ts;\r\nif (atomic_read(&proc_event_num_listeners) < 1)\r\nreturn;\r\nmsg = buffer_to_cn_msg(buffer);\r\nev = (struct proc_event *)msg->data;\r\nmemset(&ev->event_data, 0, sizeof(ev->event_data));\r\nmsg->seq = rcvd_seq;\r\nktime_get_ts(&ts);\r\nev->timestamp_ns = timespec_to_ns(&ts);\r\nev->cpu = -1;\r\nev->what = PROC_EVENT_NONE;\r\nev->event_data.ack.err = err;\r\nmemcpy(&msg->id, &cn_proc_event_id, sizeof(msg->id));\r\nmsg->ack = rcvd_ack + 1;\r\nmsg->len = sizeof(*ev);\r\nmsg->flags = 0;\r\ncn_netlink_send(msg, CN_IDX_PROC, GFP_KERNEL);\r\n}\r\nstatic void cn_proc_mcast_ctl(struct cn_msg *msg,\r\nstruct netlink_skb_parms *nsp)\r\n{\r\nenum proc_cn_mcast_op *mc_op = NULL;\r\nint err = 0;\r\nif (msg->len != sizeof(*mc_op))\r\nreturn;\r\nif ((current_user_ns() != &init_user_ns) ||\r\n(task_active_pid_ns(current) != &init_pid_ns))\r\nreturn;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerr = EPERM;\r\ngoto out;\r\n}\r\nmc_op = (enum proc_cn_mcast_op *)msg->data;\r\nswitch (*mc_op) {\r\ncase PROC_CN_MCAST_LISTEN:\r\natomic_inc(&proc_event_num_listeners);\r\nbreak;\r\ncase PROC_CN_MCAST_IGNORE:\r\natomic_dec(&proc_event_num_listeners);\r\nbreak;\r\ndefault:\r\nerr = EINVAL;\r\nbreak;\r\n}\r\nout:\r\ncn_proc_ack(err, msg->seq, msg->ack);\r\n}\r\nstatic int __init cn_proc_init(void)\r\n{\r\nint err = cn_add_callback(&cn_proc_event_id,\r\n"cn_proc",\r\n&cn_proc_mcast_ctl);\r\nif (err) {\r\npr_warn("cn_proc failed to register\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
