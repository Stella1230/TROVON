static inline void *drm_vmalloc_dma(unsigned long size)\r\n{\r\n#if defined(__powerpc__) && defined(CONFIG_NOT_COHERENT_CACHE)\r\nreturn __vmalloc(size, GFP_KERNEL, PAGE_KERNEL | _PAGE_NO_CACHE);\r\n#else\r\nreturn vmalloc_32(size);\r\n#endif\r\n}\r\nstatic void drm_sg_cleanup(struct drm_sg_mem * entry)\r\n{\r\nstruct page *page;\r\nint i;\r\nfor (i = 0; i < entry->pages; i++) {\r\npage = entry->pagelist[i];\r\nif (page)\r\nClearPageReserved(page);\r\n}\r\nvfree(entry->virtual);\r\nkfree(entry->busaddr);\r\nkfree(entry->pagelist);\r\nkfree(entry);\r\n}\r\nvoid drm_legacy_sg_cleanup(struct drm_device *dev)\r\n{\r\nif (drm_core_check_feature(dev, DRIVER_SG) && dev->sg &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET)) {\r\ndrm_sg_cleanup(dev->sg);\r\ndev->sg = NULL;\r\n}\r\n}\r\nint drm_sg_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_scatter_gather *request = data;\r\nstruct drm_sg_mem *entry;\r\nunsigned long pages, i, j;\r\nDRM_DEBUG("\n");\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\nif (!drm_core_check_feature(dev, DRIVER_SG))\r\nreturn -EINVAL;\r\nif (dev->sg)\r\nreturn -EINVAL;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\npages = (request->size + PAGE_SIZE - 1) / PAGE_SIZE;\r\nDRM_DEBUG("size=%ld pages=%ld\n", request->size, pages);\r\nentry->pages = pages;\r\nentry->pagelist = kcalloc(pages, sizeof(*entry->pagelist), GFP_KERNEL);\r\nif (!entry->pagelist) {\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nentry->busaddr = kcalloc(pages, sizeof(*entry->busaddr), GFP_KERNEL);\r\nif (!entry->busaddr) {\r\nkfree(entry->pagelist);\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nentry->virtual = drm_vmalloc_dma(pages << PAGE_SHIFT);\r\nif (!entry->virtual) {\r\nkfree(entry->busaddr);\r\nkfree(entry->pagelist);\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nmemset(entry->virtual, 0, pages << PAGE_SHIFT);\r\nentry->handle = ScatterHandle((unsigned long)entry->virtual);\r\nDRM_DEBUG("handle = %08lx\n", entry->handle);\r\nDRM_DEBUG("virtual = %p\n", entry->virtual);\r\nfor (i = (unsigned long)entry->virtual, j = 0; j < pages;\r\ni += PAGE_SIZE, j++) {\r\nentry->pagelist[j] = vmalloc_to_page((void *)i);\r\nif (!entry->pagelist[j])\r\ngoto failed;\r\nSetPageReserved(entry->pagelist[j]);\r\n}\r\nrequest->handle = entry->handle;\r\ndev->sg = entry;\r\n#if DEBUG_SCATTER\r\n{\r\nint error = 0;\r\nfor (i = 0; i < pages; i++) {\r\nunsigned long *tmp;\r\ntmp = page_address(entry->pagelist[i]);\r\nfor (j = 0;\r\nj < PAGE_SIZE / sizeof(unsigned long);\r\nj++, tmp++) {\r\n*tmp = 0xcafebabe;\r\n}\r\ntmp = (unsigned long *)((u8 *) entry->virtual +\r\n(PAGE_SIZE * i));\r\nfor (j = 0;\r\nj < PAGE_SIZE / sizeof(unsigned long);\r\nj++, tmp++) {\r\nif (*tmp != 0xcafebabe && error == 0) {\r\nerror = 1;\r\nDRM_ERROR("Scatter allocation error, "\r\n"pagelist does not match "\r\n"virtual mapping\n");\r\n}\r\n}\r\ntmp = page_address(entry->pagelist[i]);\r\nfor (j = 0;\r\nj < PAGE_SIZE / sizeof(unsigned long);\r\nj++, tmp++) {\r\n*tmp = 0;\r\n}\r\n}\r\nif (error == 0)\r\nDRM_ERROR("Scatter allocation matches pagelist\n");\r\n}\r\n#endif\r\nreturn 0;\r\nfailed:\r\ndrm_sg_cleanup(entry);\r\nreturn -ENOMEM;\r\n}\r\nint drm_sg_free(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_scatter_gather *request = data;\r\nstruct drm_sg_mem *entry;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\nif (!drm_core_check_feature(dev, DRIVER_SG))\r\nreturn -EINVAL;\r\nentry = dev->sg;\r\ndev->sg = NULL;\r\nif (!entry || entry->handle != request->handle)\r\nreturn -EINVAL;\r\nDRM_DEBUG("virtual = %p\n", entry->virtual);\r\ndrm_sg_cleanup(entry);\r\nreturn 0;\r\n}
