int via_agp_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_agp_t *agp = data;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_mm_init(&dev_priv->agp_mm, 0, agp->size >> VIA_MM_ALIGN_SHIFT);\r\ndev_priv->agp_initialized = 1;\r\ndev_priv->agp_offset = agp->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %u, size = %u\n", agp->offset, agp->size);\r\nreturn 0;\r\n}\r\nint via_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_fb_t *fb = data;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_mm_init(&dev_priv->vram_mm, 0, fb->size >> VIA_MM_ALIGN_SHIFT);\r\ndev_priv->vram_initialized = 1;\r\ndev_priv->vram_offset = fb->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %u, size = %u\n", fb->offset, fb->size);\r\nreturn 0;\r\n}\r\nint via_final_context(struct drm_device *dev, int context)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nvia_release_futex(dev_priv, context);\r\nif (list_is_singular(&dev->ctxlist) && dev->dev_private) {\r\nDRM_DEBUG("Last Context\n");\r\ndrm_irq_uninstall(dev);\r\nvia_cleanup_futex(dev_priv);\r\nvia_do_cleanup_map(dev);\r\n}\r\nreturn 1;\r\n}\r\nvoid via_lastclose(struct drm_device *dev)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nif (!dev_priv)\r\nreturn;\r\nmutex_lock(&dev->struct_mutex);\r\nif (dev_priv->vram_initialized) {\r\ndrm_mm_takedown(&dev_priv->vram_mm);\r\ndev_priv->vram_initialized = 0;\r\n}\r\nif (dev_priv->agp_initialized) {\r\ndrm_mm_takedown(&dev_priv->agp_mm);\r\ndev_priv->agp_initialized = 0;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nint via_mem_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\ndrm_via_mem_t *mem = data;\r\nint retval = 0, user_key;\r\nstruct via_memblock *item;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nstruct via_file_private *file_priv = file->driver_priv;\r\nunsigned long tmpSize;\r\nif (mem->type > VIA_MEM_AGP) {\r\nDRM_ERROR("Unknown memory type allocation\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (0 == ((mem->type == VIA_MEM_VIDEO) ? dev_priv->vram_initialized :\r\ndev_priv->agp_initialized)) {\r\nDRM_ERROR\r\n("Attempt to allocate from uninitialized memory manager.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nitem = kzalloc(sizeof(*item), GFP_KERNEL);\r\nif (!item) {\r\nretval = -ENOMEM;\r\ngoto fail_alloc;\r\n}\r\ntmpSize = (mem->size + VIA_MM_ALIGN_MASK) >> VIA_MM_ALIGN_SHIFT;\r\nif (mem->type == VIA_MEM_AGP)\r\nretval = drm_mm_insert_node(&dev_priv->agp_mm,\r\n&item->mm_node,\r\ntmpSize, 0, DRM_MM_SEARCH_DEFAULT);\r\nelse\r\nretval = drm_mm_insert_node(&dev_priv->vram_mm,\r\n&item->mm_node,\r\ntmpSize, 0, DRM_MM_SEARCH_DEFAULT);\r\nif (retval)\r\ngoto fail_alloc;\r\nretval = idr_alloc(&dev_priv->object_idr, item, 1, 0, GFP_KERNEL);\r\nif (retval < 0)\r\ngoto fail_idr;\r\nuser_key = retval;\r\nlist_add(&item->owner_list, &file_priv->obj_list);\r\nmutex_unlock(&dev->struct_mutex);\r\nmem->offset = ((mem->type == VIA_MEM_VIDEO) ?\r\ndev_priv->vram_offset : dev_priv->agp_offset) +\r\n((item->mm_node.start) << VIA_MM_ALIGN_SHIFT);\r\nmem->index = user_key;\r\nreturn 0;\r\nfail_idr:\r\ndrm_mm_remove_node(&item->mm_node);\r\nfail_alloc:\r\nkfree(item);\r\nmutex_unlock(&dev->struct_mutex);\r\nmem->offset = 0;\r\nmem->size = 0;\r\nmem->index = 0;\r\nDRM_DEBUG("Video memory allocation failed\n");\r\nreturn retval;\r\n}\r\nint via_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\ndrm_via_mem_t *mem = data;\r\nstruct via_memblock *obj;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = idr_find(&dev_priv->object_idr, mem->index);\r\nif (obj == NULL) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nidr_remove(&dev_priv->object_idr, mem->index);\r\nlist_del(&obj->owner_list);\r\ndrm_mm_remove_node(&obj->mm_node);\r\nkfree(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("free = 0x%lx\n", mem->index);\r\nreturn 0;\r\n}\r\nvoid via_reclaim_buffers_locked(struct drm_device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct via_file_private *file_priv = file->driver_priv;\r\nstruct via_memblock *entry, *next;\r\nif (!(file->minor->master && file->master->lock.hw_lock))\r\nreturn;\r\ndrm_idlelock_take(&file->master->lock);\r\nmutex_lock(&dev->struct_mutex);\r\nif (list_empty(&file_priv->obj_list)) {\r\nmutex_unlock(&dev->struct_mutex);\r\ndrm_idlelock_release(&file->master->lock);\r\nreturn;\r\n}\r\nvia_driver_dma_quiescent(dev);\r\nlist_for_each_entry_safe(entry, next, &file_priv->obj_list,\r\nowner_list) {\r\nlist_del(&entry->owner_list);\r\ndrm_mm_remove_node(&entry->mm_node);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\ndrm_idlelock_release(&file->master->lock);\r\nreturn;\r\n}
