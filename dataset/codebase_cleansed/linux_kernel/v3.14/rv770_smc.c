static int rv770_set_smc_sram_address(struct radeon_device *rdev,\r\nu16 smc_address, u16 limit)\r\n{\r\nu32 addr;\r\nif (smc_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_address + 3) > limit)\r\nreturn -EINVAL;\r\naddr = smc_address;\r\naddr |= SMC_SRAM_AUTO_INC_DIS;\r\nWREG32(SMC_SRAM_ADDR, addr);\r\nreturn 0;\r\n}\r\nint rv770_copy_bytes_to_smc(struct radeon_device *rdev,\r\nu16 smc_start_address, const u8 *src,\r\nu16 byte_count, u16 limit)\r\n{\r\nunsigned long flags;\r\nu32 data, original_data, extra_shift;\r\nu16 addr;\r\nint ret = 0;\r\nif (smc_start_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_start_address + byte_count) > limit)\r\nreturn -EINVAL;\r\naddr = smc_start_address;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nwhile (byte_count >= 4) {\r\ndata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\r\nret = rv770_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(SMC_SRAM_DATA, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (byte_count > 0) {\r\ndata = 0;\r\nret = rv770_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\noriginal_data = RREG32(SMC_SRAM_DATA);\r\nextra_shift = 8 * (4 - byte_count);\r\nwhile (byte_count > 0) {\r\ndata = (data << 8) + *src++;\r\nbyte_count--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (original_data & ~((~0UL) << extra_shift));\r\nret = rv770_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\ngoto done;\r\nWREG32(SMC_SRAM_DATA, data);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int rv770_program_interrupt_vectors(struct radeon_device *rdev,\r\nu32 smc_first_vector, const u8 *src,\r\nu32 byte_count)\r\n{\r\nu32 tmp, i;\r\nif (byte_count % 4)\r\nreturn -EINVAL;\r\nif (smc_first_vector < FIRST_SMC_INT_VECT_REG) {\r\ntmp = FIRST_SMC_INT_VECT_REG - smc_first_vector;\r\nif (tmp > byte_count)\r\nreturn 0;\r\nbyte_count -= tmp;\r\nsrc += tmp;\r\nsmc_first_vector = FIRST_SMC_INT_VECT_REG;\r\n}\r\nfor (i = 0; i < byte_count; i += 4) {\r\ntmp = (src[i] << 24) | (src[i + 1] << 16) | (src[i + 2] << 8) | src[i + 3];\r\nWREG32(SMC_ISR_FFD8_FFDB + i, tmp);\r\n}\r\nreturn 0;\r\n}\r\nvoid rv770_start_smc(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SMC_IO, SMC_RST_N, ~SMC_RST_N);\r\n}\r\nvoid rv770_reset_smc(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SMC_IO, 0, ~SMC_RST_N);\r\n}\r\nvoid rv770_stop_smc_clock(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SMC_IO, 0, ~SMC_CLK_EN);\r\n}\r\nvoid rv770_start_smc_clock(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SMC_IO, SMC_CLK_EN, ~SMC_CLK_EN);\r\n}\r\nbool rv770_is_smc_running(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32(SMC_IO);\r\nif ((tmp & SMC_RST_N) && (tmp & SMC_CLK_EN))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nPPSMC_Result rv770_send_msg_to_smc(struct radeon_device *rdev, PPSMC_Msg msg)\r\n{\r\nu32 tmp;\r\nint i;\r\nPPSMC_Result result;\r\nif (!rv770_is_smc_running(rdev))\r\nreturn PPSMC_Result_Failed;\r\nWREG32_P(SMC_MSG, HOST_SMC_MSG(msg), ~HOST_SMC_MSG_MASK);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32(SMC_MSG) & HOST_SMC_RESP_MASK;\r\ntmp >>= HOST_SMC_RESP_SHIFT;\r\nif (tmp != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ntmp = RREG32(SMC_MSG) & HOST_SMC_RESP_MASK;\r\ntmp >>= HOST_SMC_RESP_SHIFT;\r\nresult = (PPSMC_Result)tmp;\r\nreturn result;\r\n}\r\nPPSMC_Result rv770_wait_for_smc_inactive(struct radeon_device *rdev)\r\n{\r\nint i;\r\nPPSMC_Result result = PPSMC_Result_OK;\r\nif (!rv770_is_smc_running(rdev))\r\nreturn result;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(SMC_IO) & SMC_STOP_MODE)\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn result;\r\n}\r\nstatic void rv770_clear_smc_sram(struct radeon_device *rdev, u16 limit)\r\n{\r\nunsigned long flags;\r\nu16 i;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nfor (i = 0; i < limit; i += 4) {\r\nrv770_set_smc_sram_address(rdev, i, limit);\r\nWREG32(SMC_SRAM_DATA, 0);\r\n}\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\n}\r\nint rv770_load_smc_ucode(struct radeon_device *rdev,\r\nu16 limit)\r\n{\r\nint ret;\r\nconst u8 *int_vect;\r\nu16 int_vect_start_address;\r\nu16 int_vect_size;\r\nconst u8 *ucode_data;\r\nu16 ucode_start_address;\r\nu16 ucode_size;\r\nif (!rdev->smc_fw)\r\nreturn -EINVAL;\r\nrv770_clear_smc_sram(rdev, limit);\r\nswitch (rdev->family) {\r\ncase CHIP_RV770:\r\nucode_start_address = RV770_SMC_UCODE_START;\r\nucode_size = RV770_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&rv770_smc_int_vectors;\r\nint_vect_start_address = RV770_SMC_INT_VECTOR_START;\r\nint_vect_size = RV770_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_RV730:\r\nucode_start_address = RV730_SMC_UCODE_START;\r\nucode_size = RV730_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&rv730_smc_int_vectors;\r\nint_vect_start_address = RV730_SMC_INT_VECTOR_START;\r\nint_vect_size = RV730_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_RV710:\r\nucode_start_address = RV710_SMC_UCODE_START;\r\nucode_size = RV710_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&rv710_smc_int_vectors;\r\nint_vect_start_address = RV710_SMC_INT_VECTOR_START;\r\nint_vect_size = RV710_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_RV740:\r\nucode_start_address = RV740_SMC_UCODE_START;\r\nucode_size = RV740_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&rv740_smc_int_vectors;\r\nint_vect_start_address = RV740_SMC_INT_VECTOR_START;\r\nint_vect_size = RV740_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_CEDAR:\r\nucode_start_address = CEDAR_SMC_UCODE_START;\r\nucode_size = CEDAR_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&cedar_smc_int_vectors;\r\nint_vect_start_address = CEDAR_SMC_INT_VECTOR_START;\r\nint_vect_size = CEDAR_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_REDWOOD:\r\nucode_start_address = REDWOOD_SMC_UCODE_START;\r\nucode_size = REDWOOD_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&redwood_smc_int_vectors;\r\nint_vect_start_address = REDWOOD_SMC_INT_VECTOR_START;\r\nint_vect_size = REDWOOD_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_JUNIPER:\r\nucode_start_address = JUNIPER_SMC_UCODE_START;\r\nucode_size = JUNIPER_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&juniper_smc_int_vectors;\r\nint_vect_start_address = JUNIPER_SMC_INT_VECTOR_START;\r\nint_vect_size = JUNIPER_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_CYPRESS:\r\ncase CHIP_HEMLOCK:\r\nucode_start_address = CYPRESS_SMC_UCODE_START;\r\nucode_size = CYPRESS_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&cypress_smc_int_vectors;\r\nint_vect_start_address = CYPRESS_SMC_INT_VECTOR_START;\r\nint_vect_size = CYPRESS_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_BARTS:\r\nucode_start_address = BARTS_SMC_UCODE_START;\r\nucode_size = BARTS_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&barts_smc_int_vectors;\r\nint_vect_start_address = BARTS_SMC_INT_VECTOR_START;\r\nint_vect_size = BARTS_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_TURKS:\r\nucode_start_address = TURKS_SMC_UCODE_START;\r\nucode_size = TURKS_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&turks_smc_int_vectors;\r\nint_vect_start_address = TURKS_SMC_INT_VECTOR_START;\r\nint_vect_size = TURKS_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_CAICOS:\r\nucode_start_address = CAICOS_SMC_UCODE_START;\r\nucode_size = CAICOS_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&caicos_smc_int_vectors;\r\nint_vect_start_address = CAICOS_SMC_INT_VECTOR_START;\r\nint_vect_size = CAICOS_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ncase CHIP_CAYMAN:\r\nucode_start_address = CAYMAN_SMC_UCODE_START;\r\nucode_size = CAYMAN_SMC_UCODE_SIZE;\r\nint_vect = (const u8 *)&cayman_smc_int_vectors;\r\nint_vect_start_address = CAYMAN_SMC_INT_VECTOR_START;\r\nint_vect_size = CAYMAN_SMC_INT_VECTOR_SIZE;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown asic in smc ucode loader\n");\r\nBUG();\r\n}\r\nucode_data = (const u8 *)rdev->smc_fw->data;\r\nret = rv770_copy_bytes_to_smc(rdev, ucode_start_address,\r\nucode_data, ucode_size, limit);\r\nif (ret)\r\nreturn ret;\r\nret = rv770_program_interrupt_vectors(rdev, int_vect_start_address,\r\nint_vect, int_vect_size);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint rv770_read_smc_sram_dword(struct radeon_device *rdev,\r\nu16 smc_address, u32 *value, u16 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nret = rv770_set_smc_sram_address(rdev, smc_address, limit);\r\nif (ret == 0)\r\n*value = RREG32(SMC_SRAM_DATA);\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}\r\nint rv770_write_smc_sram_dword(struct radeon_device *rdev,\r\nu16 smc_address, u32 value, u16 limit)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rdev->smc_idx_lock, flags);\r\nret = rv770_set_smc_sram_address(rdev, smc_address, limit);\r\nif (ret == 0)\r\nWREG32(SMC_SRAM_DATA, value);\r\nspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\r\nreturn ret;\r\n}
