void vexpress_flags_set(u32 data)\r\n{\r\nwritel(~0, vexpress_sysreg_base + SYS_FLAGSCLR);\r\nwritel(data, vexpress_sysreg_base + SYS_FLAGSSET);\r\n}\r\nu32 vexpress_get_procid(int site)\r\n{\r\nif (site == VEXPRESS_SITE_MASTER)\r\nsite = vexpress_master_site;\r\nreturn readl(vexpress_sysreg_base + (site == VEXPRESS_SITE_DB1 ?\r\nSYS_PROCID0 : SYS_PROCID1));\r\n}\r\nu32 vexpress_get_hbi(int site)\r\n{\r\nu32 id;\r\nswitch (site) {\r\ncase VEXPRESS_SITE_MB:\r\nid = readl(vexpress_sysreg_base + SYS_ID);\r\nreturn (id >> SYS_ID_HBI_SHIFT) & SYS_HBI_MASK;\r\ncase VEXPRESS_SITE_MASTER:\r\ncase VEXPRESS_SITE_DB1:\r\ncase VEXPRESS_SITE_DB2:\r\nid = vexpress_get_procid(site);\r\nreturn (id >> SYS_PROCIDx_HBI_SHIFT) & SYS_HBI_MASK;\r\n}\r\nreturn ~0;\r\n}\r\nvoid __iomem *vexpress_get_24mhz_clock_base(void)\r\n{\r\nreturn vexpress_sysreg_base + SYS_24MHZ;\r\n}\r\nstatic void vexpress_sysreg_find_prop(struct device_node *node,\r\nconst char *name, u32 *val)\r\n{\r\nof_node_get(node);\r\nwhile (node) {\r\nif (of_property_read_u32(node, name, val) == 0) {\r\nof_node_put(node);\r\nreturn;\r\n}\r\nnode = of_get_next_parent(node);\r\n}\r\n}\r\nunsigned __vexpress_get_site(struct device *dev, struct device_node *node)\r\n{\r\nu32 site = 0;\r\nWARN_ON(dev && node && dev->of_node != node);\r\nif (dev && !node)\r\nnode = dev->of_node;\r\nif (node) {\r\nvexpress_sysreg_find_prop(node, "arm,vexpress,site", &site);\r\n} else if (dev && dev->bus == &platform_bus_type) {\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdev->num_resources == 1 &&\r\npdev->resource[0].flags == IORESOURCE_BUS)\r\nsite = pdev->resource[0].start;\r\n} else if (dev && strncmp(dev_name(dev), "ct:", 3) == 0) {\r\nsite = VEXPRESS_SITE_MASTER;\r\n}\r\nif (site == VEXPRESS_SITE_MASTER)\r\nsite = vexpress_master_site;\r\nreturn site;\r\n}\r\nstatic void *vexpress_sysreg_config_func_get(struct device *dev,\r\nstruct device_node *node)\r\n{\r\nstruct vexpress_sysreg_config_func *config_func;\r\nu32 site;\r\nu32 position = 0;\r\nu32 dcc = 0;\r\nu32 func_device[2];\r\nint err = -EFAULT;\r\nif (node) {\r\nof_node_get(node);\r\nvexpress_sysreg_find_prop(node, "arm,vexpress,site", &site);\r\nvexpress_sysreg_find_prop(node, "arm,vexpress,position",\r\n&position);\r\nvexpress_sysreg_find_prop(node, "arm,vexpress,dcc", &dcc);\r\nerr = of_property_read_u32_array(node,\r\n"arm,vexpress-sysreg,func", func_device,\r\nARRAY_SIZE(func_device));\r\nof_node_put(node);\r\n} else if (dev && dev->bus == &platform_bus_type) {\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdev->num_resources == 1 &&\r\npdev->resource[0].flags == IORESOURCE_BUS) {\r\nsite = pdev->resource[0].start;\r\nfunc_device[0] = pdev->resource[0].end;\r\nfunc_device[1] = pdev->id;\r\nerr = 0;\r\n}\r\n}\r\nif (err)\r\nreturn NULL;\r\nconfig_func = kzalloc(sizeof(*config_func), GFP_KERNEL);\r\nif (!config_func)\r\nreturn NULL;\r\nconfig_func->template = SYS_CFGCTRL_DCC(dcc);\r\nconfig_func->template |= SYS_CFGCTRL_FUNC(func_device[0]);\r\nconfig_func->template |= SYS_CFGCTRL_SITE(site == VEXPRESS_SITE_MASTER ?\r\nvexpress_master_site : site);\r\nconfig_func->template |= SYS_CFGCTRL_POSITION(position);\r\nconfig_func->device |= func_device[1];\r\ndev_dbg(vexpress_sysreg_dev, "func 0x%p = 0x%x, %d\n", config_func,\r\nconfig_func->template, config_func->device);\r\nreturn config_func;\r\n}\r\nstatic void vexpress_sysreg_config_func_put(void *func)\r\n{\r\nkfree(func);\r\n}\r\nstatic int vexpress_sysreg_config_func_exec(void *func, int offset,\r\nbool write, u32 *data)\r\n{\r\nint status;\r\nstruct vexpress_sysreg_config_func *config_func = func;\r\nu32 command;\r\nif (WARN_ON(!vexpress_sysreg_base))\r\nreturn -ENOENT;\r\ncommand = readl(vexpress_sysreg_base + SYS_CFGCTRL);\r\nif (WARN_ON(command & SYS_CFGCTRL_START))\r\nreturn -EBUSY;\r\ncommand = SYS_CFGCTRL_START;\r\ncommand |= write ? SYS_CFGCTRL_WRITE : 0;\r\ncommand |= config_func->template;\r\ncommand |= SYS_CFGCTRL_DEVICE(config_func->device + offset);\r\nif (!write)\r\n*data = 0xdeadbeef;\r\ndev_dbg(vexpress_sysreg_dev, "command %x, data %x\n",\r\ncommand, *data);\r\nwritel(*data, vexpress_sysreg_base + SYS_CFGDATA);\r\nwritel(0, vexpress_sysreg_base + SYS_CFGSTAT);\r\nwritel(command, vexpress_sysreg_base + SYS_CFGCTRL);\r\nmb();\r\nif (vexpress_sysreg_dev) {\r\nif (!write)\r\nvexpress_sysreg_config_data = data;\r\nvexpress_sysreg_config_tries = 100;\r\nmod_timer(&vexpress_sysreg_config_timer,\r\njiffies + usecs_to_jiffies(100));\r\nstatus = VEXPRESS_CONFIG_STATUS_WAIT;\r\n} else {\r\nu32 cfgstat;\r\ndo {\r\ncpu_relax();\r\ncfgstat = readl(vexpress_sysreg_base + SYS_CFGSTAT);\r\n} while (!cfgstat);\r\nif (!write && (cfgstat & SYS_CFGSTAT_COMPLETE))\r\n*data = readl(vexpress_sysreg_base + SYS_CFGDATA);\r\nstatus = VEXPRESS_CONFIG_STATUS_DONE;\r\nif (cfgstat & SYS_CFGSTAT_ERR)\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic void vexpress_sysreg_config_complete(unsigned long data)\r\n{\r\nint status = VEXPRESS_CONFIG_STATUS_DONE;\r\nu32 cfgstat = readl(vexpress_sysreg_base + SYS_CFGSTAT);\r\nif (cfgstat & SYS_CFGSTAT_ERR)\r\nstatus = -EINVAL;\r\nif (!vexpress_sysreg_config_tries--)\r\nstatus = -ETIMEDOUT;\r\nif (status < 0) {\r\ndev_err(vexpress_sysreg_dev, "error %d\n", status);\r\n} else if (!(cfgstat & SYS_CFGSTAT_COMPLETE)) {\r\nmod_timer(&vexpress_sysreg_config_timer,\r\njiffies + usecs_to_jiffies(50));\r\nreturn;\r\n}\r\nif (vexpress_sysreg_config_data) {\r\n*vexpress_sysreg_config_data = readl(vexpress_sysreg_base +\r\nSYS_CFGDATA);\r\ndev_dbg(vexpress_sysreg_dev, "read data %x\n",\r\n*vexpress_sysreg_config_data);\r\nvexpress_sysreg_config_data = NULL;\r\n}\r\nvexpress_config_complete(vexpress_sysreg_config_bridge, status);\r\n}\r\nvoid vexpress_sysreg_setup(struct device_node *node)\r\n{\r\nif (WARN_ON(!vexpress_sysreg_base))\r\nreturn;\r\nif (readl(vexpress_sysreg_base + SYS_MISC) & SYS_MISC_MASTERSITE)\r\nvexpress_master_site = VEXPRESS_SITE_DB2;\r\nelse\r\nvexpress_master_site = VEXPRESS_SITE_DB1;\r\nvexpress_sysreg_config_bridge = vexpress_config_bridge_register(\r\nnode, &vexpress_sysreg_config_bridge_info);\r\nWARN_ON(!vexpress_sysreg_config_bridge);\r\n}\r\nvoid __init vexpress_sysreg_early_init(void __iomem *base)\r\n{\r\nvexpress_sysreg_base = base;\r\nvexpress_sysreg_setup(NULL);\r\n}\r\nvoid __init vexpress_sysreg_of_early_init(void)\r\n{\r\nstruct device_node *node;\r\nif (vexpress_sysreg_base)\r\nreturn;\r\nnode = of_find_compatible_node(NULL, NULL, "arm,vexpress-sysreg");\r\nif (node) {\r\nvexpress_sysreg_base = of_iomap(node, 0);\r\nvexpress_sysreg_setup(node);\r\n}\r\n}\r\nstatic int vexpress_sysreg_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vexpress_sysreg_gpio_get(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct vexpress_sysreg_gpio *gpio = &vexpress_sysreg_gpios[offset];\r\nu32 reg_value = readl(vexpress_sysreg_base + gpio->reg);\r\nreturn !!(reg_value & gpio->value);\r\n}\r\nstatic void vexpress_sysreg_gpio_set(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct vexpress_sysreg_gpio *gpio = &vexpress_sysreg_gpios[offset];\r\nu32 reg_value = readl(vexpress_sysreg_base + gpio->reg);\r\nif (value)\r\nreg_value |= gpio->value;\r\nelse\r\nreg_value &= ~gpio->value;\r\nwritel(reg_value, vexpress_sysreg_base + gpio->reg);\r\n}\r\nstatic int vexpress_sysreg_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nvexpress_sysreg_gpio_set(chip, offset, value);\r\nreturn 0;\r\n}\r\nstatic ssize_t vexpress_sysreg_sys_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%08x\n", readl(vexpress_sysreg_base + SYS_ID));\r\n}\r\nstatic int vexpress_sysreg_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct resource *res = platform_get_resource(pdev,\r\nIORESOURCE_MEM, 0);\r\nif (!devm_request_mem_region(&pdev->dev, res->start,\r\nresource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "Failed to request memory region!\n");\r\nreturn -EBUSY;\r\n}\r\nif (!vexpress_sysreg_base) {\r\nvexpress_sysreg_base = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nvexpress_sysreg_setup(pdev->dev.of_node);\r\n}\r\nif (!vexpress_sysreg_base) {\r\ndev_err(&pdev->dev, "Failed to obtain base address!\n");\r\nreturn -EFAULT;\r\n}\r\nsetup_timer(&vexpress_sysreg_config_timer,\r\nvexpress_sysreg_config_complete, 0);\r\nvexpress_sysreg_dev = &pdev->dev;\r\n#ifdef CONFIG_GPIOLIB\r\nvexpress_sysreg_gpio_chip.dev = &pdev->dev;\r\nerr = gpiochip_add(&vexpress_sysreg_gpio_chip);\r\nif (err) {\r\nvexpress_config_bridge_unregister(\r\nvexpress_sysreg_config_bridge);\r\ndev_err(&pdev->dev, "Failed to register GPIO chip! (%d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nplatform_device_register_data(vexpress_sysreg_dev, "leds-gpio",\r\nPLATFORM_DEVID_AUTO, &vexpress_sysreg_leds_pdata,\r\nsizeof(vexpress_sysreg_leds_pdata));\r\n#endif\r\ndevice_create_file(vexpress_sysreg_dev, &dev_attr_sys_id);\r\nreturn 0;\r\n}\r\nstatic int __init vexpress_sysreg_init(void)\r\n{\r\nvexpress_sysreg_of_early_init();\r\nreturn platform_driver_register(&vexpress_sysreg_driver);\r\n}
