static inline void mq_init(struct capilib_ncci *np)\r\n{\r\nu_int i;\r\nnp->msgidqueue = NULL;\r\nnp->msgidlast = NULL;\r\nnp->nmsg = 0;\r\nmemset(np->msgidpool, 0, sizeof(np->msgidpool));\r\nnp->msgidfree = &np->msgidpool[0];\r\nfor (i = 1; i < np->winsize; i++) {\r\nnp->msgidpool[i].next = np->msgidfree;\r\nnp->msgidfree = &np->msgidpool[i];\r\n}\r\n}\r\nstatic inline int mq_enqueue(struct capilib_ncci *np, u16 msgid)\r\n{\r\nstruct capilib_msgidqueue *mq;\r\nif ((mq = np->msgidfree) == NULL)\r\nreturn 0;\r\nnp->msgidfree = mq->next;\r\nmq->msgid = msgid;\r\nmq->next = NULL;\r\nif (np->msgidlast)\r\nnp->msgidlast->next = mq;\r\nnp->msgidlast = mq;\r\nif (!np->msgidqueue)\r\nnp->msgidqueue = mq;\r\nnp->nmsg++;\r\nreturn 1;\r\n}\r\nstatic inline int mq_dequeue(struct capilib_ncci *np, u16 msgid)\r\n{\r\nstruct capilib_msgidqueue **pp;\r\nfor (pp = &np->msgidqueue; *pp; pp = &(*pp)->next) {\r\nif ((*pp)->msgid == msgid) {\r\nstruct capilib_msgidqueue *mq = *pp;\r\n*pp = mq->next;\r\nif (mq == np->msgidlast)\r\nnp->msgidlast = NULL;\r\nmq->next = np->msgidfree;\r\nnp->msgidfree = mq;\r\nnp->nmsg--;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid capilib_new_ncci(struct list_head *head, u16 applid, u32 ncci, u32 winsize)\r\n{\r\nstruct capilib_ncci *np;\r\nnp = kmalloc(sizeof(*np), GFP_ATOMIC);\r\nif (!np) {\r\nprintk(KERN_WARNING "capilib_new_ncci: no memory.\n");\r\nreturn;\r\n}\r\nif (winsize > CAPI_MAXDATAWINDOW) {\r\nprintk(KERN_ERR "capi_new_ncci: winsize %d too big\n",\r\nwinsize);\r\nwinsize = CAPI_MAXDATAWINDOW;\r\n}\r\nnp->applid = applid;\r\nnp->ncci = ncci;\r\nnp->winsize = winsize;\r\nmq_init(np);\r\nlist_add_tail(&np->list, head);\r\nDBG("kcapi: appl %d ncci 0x%x up", applid, ncci);\r\n}\r\nvoid capilib_free_ncci(struct list_head *head, u16 applid, u32 ncci)\r\n{\r\nstruct list_head *l;\r\nstruct capilib_ncci *np;\r\nlist_for_each(l, head) {\r\nnp = list_entry(l, struct capilib_ncci, list);\r\nif (np->applid != applid)\r\ncontinue;\r\nif (np->ncci != ncci)\r\ncontinue;\r\nprintk(KERN_INFO "kcapi: appl %d ncci 0x%x down\n", applid, ncci);\r\nlist_del(&np->list);\r\nkfree(np);\r\nreturn;\r\n}\r\nprintk(KERN_ERR "capilib_free_ncci: ncci 0x%x not found\n", ncci);\r\n}\r\nvoid capilib_release_appl(struct list_head *head, u16 applid)\r\n{\r\nstruct list_head *l, *n;\r\nstruct capilib_ncci *np;\r\nlist_for_each_safe(l, n, head) {\r\nnp = list_entry(l, struct capilib_ncci, list);\r\nif (np->applid != applid)\r\ncontinue;\r\nprintk(KERN_INFO "kcapi: appl %d ncci 0x%x forced down\n", applid, np->ncci);\r\nlist_del(&np->list);\r\nkfree(np);\r\n}\r\n}\r\nvoid capilib_release(struct list_head *head)\r\n{\r\nstruct list_head *l, *n;\r\nstruct capilib_ncci *np;\r\nlist_for_each_safe(l, n, head) {\r\nnp = list_entry(l, struct capilib_ncci, list);\r\nprintk(KERN_INFO "kcapi: appl %d ncci 0x%x forced down\n", np->applid, np->ncci);\r\nlist_del(&np->list);\r\nkfree(np);\r\n}\r\n}\r\nu16 capilib_data_b3_req(struct list_head *head, u16 applid, u32 ncci, u16 msgid)\r\n{\r\nstruct list_head *l;\r\nstruct capilib_ncci *np;\r\nlist_for_each(l, head) {\r\nnp = list_entry(l, struct capilib_ncci, list);\r\nif (np->applid != applid)\r\ncontinue;\r\nif (np->ncci != ncci)\r\ncontinue;\r\nif (mq_enqueue(np, msgid) == 0)\r\nreturn CAPI_SENDQUEUEFULL;\r\nreturn CAPI_NOERROR;\r\n}\r\nprintk(KERN_ERR "capilib_data_b3_req: ncci 0x%x not found\n", ncci);\r\nreturn CAPI_NOERROR;\r\n}\r\nvoid capilib_data_b3_conf(struct list_head *head, u16 applid, u32 ncci, u16 msgid)\r\n{\r\nstruct list_head *l;\r\nstruct capilib_ncci *np;\r\nlist_for_each(l, head) {\r\nnp = list_entry(l, struct capilib_ncci, list);\r\nif (np->applid != applid)\r\ncontinue;\r\nif (np->ncci != ncci)\r\ncontinue;\r\nif (mq_dequeue(np, msgid) == 0) {\r\nprintk(KERN_ERR "kcapi: msgid %hu ncci 0x%x not on queue\n",\r\nmsgid, ncci);\r\n}\r\nreturn;\r\n}\r\nprintk(KERN_ERR "capilib_data_b3_conf: ncci 0x%x not found\n", ncci);\r\n}
