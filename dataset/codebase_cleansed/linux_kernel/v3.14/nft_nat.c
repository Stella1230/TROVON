static void nft_nat_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(pkt->skb, &ctinfo);\r\nstruct nf_nat_range range;\r\nmemset(&range, 0, sizeof(range));\r\nif (priv->sreg_addr_min) {\r\nif (priv->family == AF_INET) {\r\nrange.min_addr.ip = (__force __be32)\r\ndata[priv->sreg_addr_min].data[0];\r\nrange.max_addr.ip = (__force __be32)\r\ndata[priv->sreg_addr_max].data[0];\r\n} else {\r\nmemcpy(range.min_addr.ip6,\r\ndata[priv->sreg_addr_min].data,\r\nsizeof(struct nft_data));\r\nmemcpy(range.max_addr.ip6,\r\ndata[priv->sreg_addr_max].data,\r\nsizeof(struct nft_data));\r\n}\r\nrange.flags |= NF_NAT_RANGE_MAP_IPS;\r\n}\r\nif (priv->sreg_proto_min) {\r\nrange.min_proto.all = (__force __be16)\r\ndata[priv->sreg_proto_min].data[0];\r\nrange.max_proto.all = (__force __be16)\r\ndata[priv->sreg_proto_max].data[0];\r\nrange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\r\n}\r\ndata[NFT_REG_VERDICT].verdict =\r\nnf_nat_setup_info(ct, &range, priv->type);\r\n}\r\nstatic int nft_nat_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_nat *priv = nft_expr_priv(expr);\r\nint err;\r\nif (tb[NFTA_NAT_TYPE] == NULL)\r\nreturn -EINVAL;\r\nswitch (ntohl(nla_get_be32(tb[NFTA_NAT_TYPE]))) {\r\ncase NFT_NAT_SNAT:\r\npriv->type = NF_NAT_MANIP_SRC;\r\nbreak;\r\ncase NFT_NAT_DNAT:\r\npriv->type = NF_NAT_MANIP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (tb[NFTA_NAT_FAMILY] == NULL)\r\nreturn -EINVAL;\r\npriv->family = ntohl(nla_get_be32(tb[NFTA_NAT_FAMILY]));\r\nif (priv->family != AF_INET && priv->family != AF_INET6)\r\nreturn -EINVAL;\r\nif (tb[NFTA_NAT_REG_ADDR_MIN]) {\r\npriv->sreg_addr_min = ntohl(nla_get_be32(\r\ntb[NFTA_NAT_REG_ADDR_MIN]));\r\nerr = nft_validate_input_register(priv->sreg_addr_min);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (tb[NFTA_NAT_REG_ADDR_MAX]) {\r\npriv->sreg_addr_max = ntohl(nla_get_be32(\r\ntb[NFTA_NAT_REG_ADDR_MAX]));\r\nerr = nft_validate_input_register(priv->sreg_addr_max);\r\nif (err < 0)\r\nreturn err;\r\n} else\r\npriv->sreg_addr_max = priv->sreg_addr_min;\r\nif (tb[NFTA_NAT_REG_PROTO_MIN]) {\r\npriv->sreg_proto_min = ntohl(nla_get_be32(\r\ntb[NFTA_NAT_REG_PROTO_MIN]));\r\nerr = nft_validate_input_register(priv->sreg_proto_min);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (tb[NFTA_NAT_REG_PROTO_MAX]) {\r\npriv->sreg_proto_max = ntohl(nla_get_be32(\r\ntb[NFTA_NAT_REG_PROTO_MAX]));\r\nerr = nft_validate_input_register(priv->sreg_proto_max);\r\nif (err < 0)\r\nreturn err;\r\n} else\r\npriv->sreg_proto_max = priv->sreg_proto_min;\r\nreturn 0;\r\n}\r\nstatic int nft_nat_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nswitch (priv->type) {\r\ncase NF_NAT_MANIP_SRC:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_SNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase NF_NAT_MANIP_DST:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_DNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nif (nla_put_be32(skb, NFTA_NAT_FAMILY, htonl(priv->family)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb,\r\nNFTA_NAT_REG_ADDR_MIN, htonl(priv->sreg_addr_min)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb,\r\nNFTA_NAT_REG_ADDR_MAX, htonl(priv->sreg_addr_max)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb,\r\nNFTA_NAT_REG_PROTO_MIN, htonl(priv->sreg_proto_min)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb,\r\nNFTA_NAT_REG_PROTO_MAX, htonl(priv->sreg_proto_max)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_nat_module_init(void)\r\n{\r\nint err;\r\nerr = nft_register_expr(&nft_nat_type);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit nft_nat_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_nat_type);\r\n}
