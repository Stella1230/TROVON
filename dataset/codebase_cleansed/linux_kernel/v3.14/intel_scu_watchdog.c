static void watchdog_fire(void)\r\n{\r\nif (force_boot) {\r\npr_crit("Initiating system reboot\n");\r\nemergency_restart();\r\npr_crit("Reboot didn't ?????\n");\r\n}\r\nelse {\r\npr_crit("Immediate Reboot Disabled\n");\r\npr_crit("System will reset when watchdog timer times out!\n");\r\n}\r\n}\r\nstatic int check_timer_margin(int new_margin)\r\n{\r\nif ((new_margin < MIN_TIME_CYCLE) ||\r\n(new_margin > MAX_TIME - timer_set)) {\r\npr_debug("value of new_margin %d is out of the range %d to %d\n",\r\nnew_margin, MIN_TIME_CYCLE, MAX_TIME - timer_set);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int watchdog_set_ipc(int soft_threshold, int threshold)\r\n{\r\nu32 *ipc_wbuf;\r\nu8 cbuf[16] = { '\0' };\r\nint ipc_ret = 0;\r\nipc_wbuf = (u32 *)&cbuf;\r\nipc_wbuf[0] = soft_threshold;\r\nipc_wbuf[1] = threshold;\r\nipc_ret = intel_scu_ipc_command(\r\nIPC_SET_WATCHDOG_TIMER,\r\n0,\r\nipc_wbuf,\r\n2,\r\nNULL,\r\n0);\r\nif (ipc_ret != 0)\r\npr_err("Error setting SCU watchdog timer: %x\n", ipc_ret);\r\nreturn ipc_ret;\r\n}\r\nstatic irqreturn_t watchdog_timer_interrupt(int irq, void *dev_id)\r\n{\r\nint int_status;\r\nint_status = ioread32(watchdog_device.timer_interrupt_status_addr);\r\npr_debug("irq, int_status: %x\n", int_status);\r\nif (int_status != 0)\r\nreturn IRQ_NONE;\r\nif (watchdog_device.timer_started == 0) {\r\npr_debug("spurious interrupt received\n");\r\nreturn IRQ_HANDLED;\r\n}\r\niowrite32(0x00000002, watchdog_device.timer_control_addr);\r\niowrite32(watchdog_device.threshold,\r\nwatchdog_device.timer_load_count_addr);\r\niowrite32(0x00000003, watchdog_device.timer_control_addr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int intel_scu_keepalive(void)\r\n{\r\nioread32(watchdog_device.timer_clear_interrupt_addr);\r\niowrite32(0x00000002, watchdog_device.timer_control_addr);\r\niowrite32(watchdog_device.soft_threshold,\r\nwatchdog_device.timer_load_count_addr);\r\niowrite32(0x00000003, watchdog_device.timer_control_addr);\r\nreturn 0;\r\n}\r\nstatic int intel_scu_stop(void)\r\n{\r\niowrite32(0, watchdog_device.timer_control_addr);\r\nreturn 0;\r\n}\r\nstatic int intel_scu_set_heartbeat(u32 t)\r\n{\r\nint ipc_ret;\r\nint retry_count;\r\nu32 soft_value;\r\nu32 hw_pre_value;\r\nu32 hw_value;\r\nwatchdog_device.timer_set = t;\r\nwatchdog_device.threshold =\r\ntimer_margin * watchdog_device.timer_tbl_ptr->freq_hz;\r\nwatchdog_device.soft_threshold =\r\n(watchdog_device.timer_set - timer_margin)\r\n* watchdog_device.timer_tbl_ptr->freq_hz;\r\npr_debug("set_heartbeat: timer freq is %d\n",\r\nwatchdog_device.timer_tbl_ptr->freq_hz);\r\npr_debug("set_heartbeat: timer_set is %x (hex)\n",\r\nwatchdog_device.timer_set);\r\npr_debug("set_hearbeat: timer_margin is %x (hex)\n", timer_margin);\r\npr_debug("set_heartbeat: threshold is %x (hex)\n",\r\nwatchdog_device.threshold);\r\npr_debug("set_heartbeat: soft_threshold is %x (hex)\n",\r\nwatchdog_device.soft_threshold);\r\nwatchdog_device.threshold =\r\nwatchdog_device.threshold / FREQ_ADJUSTMENT;\r\nwatchdog_device.soft_threshold =\r\nwatchdog_device.soft_threshold / FREQ_ADJUSTMENT;\r\niowrite32(0x00000002, watchdog_device.timer_control_addr);\r\nipc_ret = watchdog_set_ipc(watchdog_device.soft_threshold,\r\nwatchdog_device.threshold);\r\nif (ipc_ret != 0) {\r\nintel_scu_stop();\r\nreturn ipc_ret;\r\n}\r\nretry_count = 0;\r\nsoft_value = watchdog_device.soft_threshold & 0xFFFF0000;\r\ndo {\r\nintel_scu_stop();\r\nif (MAX_RETRY < retry_count++) {\r\npr_err("Unable to set timer\n");\r\nreturn -ENODEV;\r\n}\r\niowrite32(watchdog_device.soft_threshold,\r\nwatchdog_device.timer_load_count_addr);\r\nhw_pre_value = ioread32(watchdog_device.timer_load_count_addr);\r\nhw_pre_value = hw_pre_value & 0xFFFF0000;\r\niowrite32(0x00000003, watchdog_device.timer_control_addr);\r\nhw_value = ioread32(watchdog_device.timer_load_count_addr);\r\nhw_value = hw_value & 0xFFFF0000;\r\n} while (soft_value != hw_value);\r\nwatchdog_device.timer_started = 1;\r\nreturn 0;\r\n}\r\nstatic int intel_scu_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &watchdog_device.driver_open))\r\nreturn -EBUSY;\r\nif (watchdog_device.driver_closed)\r\nreturn -EPERM;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int intel_scu_release(struct inode *inode, struct file *file)\r\n{\r\nif (!test_and_clear_bit(0, &watchdog_device.driver_open)) {\r\npr_debug("intel_scu_release, without open\n");\r\nreturn -ENOTTY;\r\n}\r\nif (!watchdog_device.timer_started) {\r\npr_debug("closed, without starting timer\n");\r\nreturn 0;\r\n}\r\npr_crit("Unexpected close of /dev/watchdog!\n");\r\nwatchdog_device.driver_closed = 1;\r\nintel_scu_keepalive();\r\nwatchdog_fire();\r\nreturn 0;\r\n}\r\nstatic ssize_t intel_scu_write(struct file *file,\r\nchar const *data,\r\nsize_t len,\r\nloff_t *ppos)\r\n{\r\nif (watchdog_device.timer_started)\r\nintel_scu_keepalive();\r\nelse\r\nintel_scu_set_heartbeat(watchdog_device.timer_set);\r\nreturn len;\r\n}\r\nstatic long intel_scu_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nu32 __user *p = argp;\r\nu32 new_margin;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_SETTIMEOUT\r\n| WDIOF_KEEPALIVEPING,\r\n.firmware_version = 0,\r\n.identity = "Intel_SCU IOH Watchdog"\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp,\r\n&ident,\r\nsizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nintel_scu_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, p))\r\nreturn -EFAULT;\r\nif (check_timer_margin(new_margin))\r\nreturn -EINVAL;\r\nif (intel_scu_set_heartbeat(new_margin))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(watchdog_device.soft_threshold, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int intel_scu_notify_sys(struct notifier_block *this,\r\nunsigned long code,\r\nvoid *another_unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nintel_scu_stop();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init intel_scu_watchdog_init(void)\r\n{\r\nint ret;\r\nu32 __iomem *tmp_addr;\r\nif (!intel_mid_identify_cpu())\r\nreturn -ENODEV;\r\nif ((timer_set < MIN_TIME_CYCLE) ||\r\n(timer_set > MAX_TIME - MIN_TIME_CYCLE)) {\r\npr_err("value of timer_set %x (hex) is out of range from %x to %x (hex)\n",\r\ntimer_set, MIN_TIME_CYCLE, MAX_TIME - MIN_TIME_CYCLE);\r\nreturn -EINVAL;\r\n}\r\nif (check_timer_margin(timer_margin))\r\nreturn -EINVAL;\r\nwatchdog_device.timer_tbl_ptr = sfi_get_mtmr(sfi_mtimer_num-1);\r\nif (watchdog_device.timer_tbl_ptr == NULL) {\r\npr_debug("timer is not available\n");\r\nreturn -ENODEV;\r\n}\r\nif (watchdog_device.timer_tbl_ptr->phys_addr == 0) {\r\npr_debug("timer %d does not have valid physical memory\n",\r\nsfi_mtimer_num);\r\nreturn -ENODEV;\r\n}\r\nif (watchdog_device.timer_tbl_ptr->irq == 0) {\r\npr_debug("timer %d invalid irq\n", sfi_mtimer_num);\r\nreturn -ENODEV;\r\n}\r\ntmp_addr = ioremap_nocache(watchdog_device.timer_tbl_ptr->phys_addr,\r\n20);\r\nif (tmp_addr == NULL) {\r\npr_debug("timer unable to ioremap\n");\r\nreturn -ENOMEM;\r\n}\r\nwatchdog_device.timer_load_count_addr = tmp_addr++;\r\nwatchdog_device.timer_current_value_addr = tmp_addr++;\r\nwatchdog_device.timer_control_addr = tmp_addr++;\r\nwatchdog_device.timer_clear_interrupt_addr = tmp_addr++;\r\nwatchdog_device.timer_interrupt_status_addr = tmp_addr++;\r\nwatchdog_device.timer_set = timer_set;\r\nwatchdog_device.threshold =\r\ntimer_margin * watchdog_device.timer_tbl_ptr->freq_hz;\r\nwatchdog_device.soft_threshold =\r\n(watchdog_device.timer_set - timer_margin)\r\n* watchdog_device.timer_tbl_ptr->freq_hz;\r\nwatchdog_device.intel_scu_notifier.notifier_call =\r\nintel_scu_notify_sys;\r\nret = register_reboot_notifier(&watchdog_device.intel_scu_notifier);\r\nif (ret) {\r\npr_err("cannot register notifier %d)\n", ret);\r\ngoto register_reboot_error;\r\n}\r\nwatchdog_device.miscdev.minor = WATCHDOG_MINOR;\r\nwatchdog_device.miscdev.name = "watchdog";\r\nwatchdog_device.miscdev.fops = &intel_scu_fops;\r\nret = misc_register(&watchdog_device.miscdev);\r\nif (ret) {\r\npr_err("cannot register miscdev %d err =%d\n",\r\nWATCHDOG_MINOR, ret);\r\ngoto misc_register_error;\r\n}\r\nret = request_irq((unsigned int)watchdog_device.timer_tbl_ptr->irq,\r\nwatchdog_timer_interrupt,\r\nIRQF_SHARED, "watchdog",\r\n&watchdog_device.timer_load_count_addr);\r\nif (ret) {\r\npr_err("error requesting irq %d\n", ret);\r\ngoto request_irq_error;\r\n}\r\nintel_scu_stop();\r\nreturn 0;\r\nrequest_irq_error:\r\nmisc_deregister(&watchdog_device.miscdev);\r\nmisc_register_error:\r\nunregister_reboot_notifier(&watchdog_device.intel_scu_notifier);\r\nregister_reboot_error:\r\nintel_scu_stop();\r\niounmap(watchdog_device.timer_load_count_addr);\r\nreturn ret;\r\n}\r\nstatic void __exit intel_scu_watchdog_exit(void)\r\n{\r\nmisc_deregister(&watchdog_device.miscdev);\r\nunregister_reboot_notifier(&watchdog_device.intel_scu_notifier);\r\niowrite32(0x00000002, watchdog_device.timer_control_addr);\r\niounmap(watchdog_device.timer_load_count_addr);\r\n}
