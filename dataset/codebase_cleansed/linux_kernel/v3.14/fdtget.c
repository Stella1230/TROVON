static void report_error(const char *where, int err)\r\n{\r\nfprintf(stderr, "Error at '%s': %s\n", where, fdt_strerror(err));\r\n}\r\nstatic int show_data(struct display_info *disp, const char *data, int len)\r\n{\r\nint i, size;\r\nconst uint8_t *p = (const uint8_t *)data;\r\nconst char *s;\r\nint value;\r\nint is_string;\r\nchar fmt[3];\r\nif (len == 0)\r\nreturn 0;\r\nis_string = (disp->type) == 's' ||\r\n(!disp->type && util_is_printable_string(data, len));\r\nif (is_string) {\r\nif (data[len - 1] != '\0') {\r\nfprintf(stderr, "Unterminated string\n");\r\nreturn -1;\r\n}\r\nfor (s = data; s - data < len; s += strlen(s) + 1) {\r\nif (s != data)\r\nprintf(" ");\r\nprintf("%s", (const char *)s);\r\n}\r\nreturn 0;\r\n}\r\nsize = disp->size;\r\nif (size == -1) {\r\nsize = (len % 4) == 0 ? 4 : 1;\r\n} else if (len % size) {\r\nfprintf(stderr, "Property length must be a multiple of "\r\n"selected data size\n");\r\nreturn -1;\r\n}\r\nfmt[0] = '%';\r\nfmt[1] = disp->type ? disp->type : 'd';\r\nfmt[2] = '\0';\r\nfor (i = 0; i < len; i += size, p += size) {\r\nif (i)\r\nprintf(" ");\r\nvalue = size == 4 ? fdt32_to_cpu(*(const uint32_t *)p) :\r\nsize == 2 ? (*p << 8) | p[1] : *p;\r\nprintf(fmt, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int list_properties(const void *blob, int node)\r\n{\r\nconst struct fdt_property *data;\r\nconst char *name;\r\nint prop;\r\nprop = fdt_first_property_offset(blob, node);\r\ndo {\r\nif (prop < 0)\r\nreturn prop == -FDT_ERR_NOTFOUND ? 0 : prop;\r\ndata = fdt_get_property_by_offset(blob, prop, NULL);\r\nname = fdt_string(blob, fdt32_to_cpu(data->nameoff));\r\nif (name)\r\nputs(name);\r\nprop = fdt_next_property_offset(blob, prop);\r\n} while (1);\r\n}\r\nstatic int list_subnodes(const void *blob, int node)\r\n{\r\nint nextoffset;\r\nuint32_t tag;\r\nint level = 0;\r\nconst char *pathp;\r\nint depth = 1;\r\nwhile (level >= 0) {\r\ntag = fdt_next_tag(blob, node, &nextoffset);\r\nswitch (tag) {\r\ncase FDT_BEGIN_NODE:\r\npathp = fdt_get_name(blob, node, NULL);\r\nif (level <= depth) {\r\nif (pathp == NULL)\r\npathp = "/* NULL pointer error */";\r\nif (*pathp == '\0')\r\npathp = "/";\r\nif (level == 1)\r\nputs(pathp);\r\n}\r\nlevel++;\r\nif (level >= MAX_LEVEL) {\r\nprintf("Nested too deep, aborting.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase FDT_END_NODE:\r\nlevel--;\r\nif (level == 0)\r\nlevel = -1;\r\nbreak;\r\ncase FDT_END:\r\nreturn 1;\r\ncase FDT_PROP:\r\nbreak;\r\ndefault:\r\nif (level <= depth)\r\nprintf("Unknown tag 0x%08X\n", tag);\r\nreturn 1;\r\n}\r\nnode = nextoffset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int show_data_for_item(const void *blob, struct display_info *disp,\r\nint node, const char *property)\r\n{\r\nconst void *value = NULL;\r\nint len, err = 0;\r\nswitch (disp->mode) {\r\ncase MODE_LIST_PROPS:\r\nerr = list_properties(blob, node);\r\nbreak;\r\ncase MODE_LIST_SUBNODES:\r\nerr = list_subnodes(blob, node);\r\nbreak;\r\ndefault:\r\nassert(property);\r\nvalue = fdt_getprop(blob, node, property, &len);\r\nif (value) {\r\nif (show_data(disp, value, len))\r\nerr = -1;\r\nelse\r\nprintf("\n");\r\n} else if (disp->default_val) {\r\nputs(disp->default_val);\r\n} else {\r\nreport_error(property, len);\r\nerr = -1;\r\n}\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int do_fdtget(struct display_info *disp, const char *filename,\r\nchar **arg, int arg_count, int args_per_step)\r\n{\r\nchar *blob;\r\nconst char *prop;\r\nint i, node;\r\nblob = utilfdt_read(filename);\r\nif (!blob)\r\nreturn -1;\r\nfor (i = 0; i + args_per_step <= arg_count; i += args_per_step) {\r\nnode = fdt_path_offset(blob, arg[i]);\r\nif (node < 0) {\r\nif (disp->default_val) {\r\nputs(disp->default_val);\r\ncontinue;\r\n} else {\r\nreport_error(arg[i], node);\r\nreturn -1;\r\n}\r\n}\r\nprop = args_per_step == 1 ? NULL : arg[i + 1];\r\nif (show_data_for_item(blob, disp, node, prop))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void usage(const char *msg)\r\n{\r\nif (msg)\r\nfprintf(stderr, "Error: %s\n\n", msg);\r\nfprintf(stderr, "%s", usage_msg);\r\nexit(2);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nchar *filename = NULL;\r\nstruct display_info disp;\r\nint args_per_step = 2;\r\nmemset(&disp, '\0', sizeof(disp));\r\ndisp.size = -1;\r\ndisp.mode = MODE_SHOW_VALUE;\r\nfor (;;) {\r\nint c = getopt(argc, argv, "d:hlpt:");\r\nif (c == -1)\r\nbreak;\r\nswitch (c) {\r\ncase 'h':\r\ncase '?':\r\nusage(NULL);\r\ncase 't':\r\nif (utilfdt_decode_type(optarg, &disp.type,\r\n&disp.size))\r\nusage("Invalid type string");\r\nbreak;\r\ncase 'p':\r\ndisp.mode = MODE_LIST_PROPS;\r\nargs_per_step = 1;\r\nbreak;\r\ncase 'l':\r\ndisp.mode = MODE_LIST_SUBNODES;\r\nargs_per_step = 1;\r\nbreak;\r\ncase 'd':\r\ndisp.default_val = optarg;\r\nbreak;\r\n}\r\n}\r\nif (optind < argc)\r\nfilename = argv[optind++];\r\nif (!filename)\r\nusage("Missing filename");\r\nargv += optind;\r\nargc -= optind;\r\nif (!argc)\r\nreturn 0;\r\nif (args_per_step == 2 && (argc % 2))\r\nusage("Must have an even number of arguments");\r\nif (do_fdtget(&disp, filename, argv, argc, args_per_step))\r\nreturn 1;\r\nreturn 0;\r\n}
