static inline u32 ti_abb_rmw(u32 mask, u32 value, u32 offset,\r\nvoid __iomem *base)\r\n{\r\nu32 val;\r\nval = readl(base + offset);\r\nval &= ~mask;\r\nval |= (value << __ffs(mask)) & mask;\r\nwritel(val, base + offset);\r\nreturn val;\r\n}\r\nstatic inline bool ti_abb_check_txdone(const struct ti_abb *abb)\r\n{\r\nreturn !!(readl(abb->int_base) & abb->txdone_mask);\r\n}\r\nstatic inline void ti_abb_clear_txdone(const struct ti_abb *abb)\r\n{\r\nwritel(abb->txdone_mask, abb->int_base);\r\n}\r\nstatic int ti_abb_wait_txdone(struct device *dev, struct ti_abb *abb)\r\n{\r\nint timeout = 0;\r\nbool status;\r\nwhile (timeout++ <= abb->settling_time) {\r\nstatus = ti_abb_check_txdone(abb);\r\nif (status)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout > abb->settling_time) {\r\ndev_warn_ratelimited(dev,\r\n"%s:TRANXDONE timeout(%duS) int=0x%08x\n",\r\n__func__, timeout, readl(abb->int_base));\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_abb_clear_all_txdone(struct device *dev, const struct ti_abb *abb)\r\n{\r\nint timeout = 0;\r\nbool status;\r\nwhile (timeout++ <= abb->settling_time) {\r\nti_abb_clear_txdone(abb);\r\nstatus = ti_abb_check_txdone(abb);\r\nif (!status)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout > abb->settling_time) {\r\ndev_warn_ratelimited(dev,\r\n"%s:TRANXDONE timeout(%duS) int=0x%08x\n",\r\n__func__, timeout, readl(abb->int_base));\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ti_abb_program_ldovbb(struct device *dev, const struct ti_abb *abb,\r\nstruct ti_abb_info *info)\r\n{\r\nu32 val;\r\nval = readl(abb->ldo_base);\r\nval &= ~(abb->ldovbb_override_mask | abb->ldovbb_vset_mask);\r\nswitch (info->opp_sel) {\r\ncase TI_ABB_SLOW_OPP:\r\ncase TI_ABB_FAST_OPP:\r\nval |= abb->ldovbb_override_mask;\r\nval |= info->vset << __ffs(abb->ldovbb_vset_mask);\r\nbreak;\r\n}\r\nwritel(val, abb->ldo_base);\r\n}\r\nstatic int ti_abb_set_opp(struct regulator_dev *rdev, struct ti_abb *abb,\r\nstruct ti_abb_info *info)\r\n{\r\nconst struct ti_abb_reg *regs = abb->regs;\r\nstruct device *dev = &rdev->dev;\r\nint ret;\r\nret = ti_abb_clear_all_txdone(dev, abb);\r\nif (ret)\r\ngoto out;\r\nti_abb_rmw(regs->fbb_sel_mask | regs->rbb_sel_mask, 0, regs->setup_reg,\r\nabb->base);\r\nswitch (info->opp_sel) {\r\ncase TI_ABB_SLOW_OPP:\r\nti_abb_rmw(regs->rbb_sel_mask, 1, regs->setup_reg, abb->base);\r\nbreak;\r\ncase TI_ABB_FAST_OPP:\r\nti_abb_rmw(regs->fbb_sel_mask, 1, regs->setup_reg, abb->base);\r\nbreak;\r\n}\r\nti_abb_rmw(regs->opp_sel_mask, info->opp_sel, regs->control_reg,\r\nabb->base);\r\nif (abb->ldo_base && info->opp_sel != TI_ABB_NOMINAL_OPP)\r\nti_abb_program_ldovbb(dev, abb, info);\r\nti_abb_rmw(regs->opp_change_mask, 1, regs->control_reg, abb->base);\r\nret = ti_abb_wait_txdone(dev, abb);\r\nif (ret)\r\ngoto out;\r\nret = ti_abb_clear_all_txdone(dev, abb);\r\nif (ret)\r\ngoto out;\r\nif (abb->ldo_base && info->opp_sel == TI_ABB_NOMINAL_OPP)\r\nti_abb_program_ldovbb(dev, abb, info);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ti_abb_set_voltage_sel(struct regulator_dev *rdev, unsigned sel)\r\n{\r\nconst struct regulator_desc *desc = rdev->desc;\r\nstruct ti_abb *abb = rdev_get_drvdata(rdev);\r\nstruct device *dev = &rdev->dev;\r\nstruct ti_abb_info *info, *oinfo;\r\nint ret = 0;\r\nif (!abb) {\r\ndev_err_ratelimited(dev, "%s: No regulator drvdata\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nif (!desc->n_voltages || !abb->info) {\r\ndev_err_ratelimited(dev,\r\n"%s: No valid voltage table entries?\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (sel >= desc->n_voltages) {\r\ndev_err(dev, "%s: sel idx(%d) >= n_voltages(%d)\n", __func__,\r\nsel, desc->n_voltages);\r\nreturn -EINVAL;\r\n}\r\nif (sel == abb->current_info_idx) {\r\ndev_dbg(dev, "%s: Already at sel=%d\n", __func__, sel);\r\nreturn ret;\r\n}\r\ninfo = &abb->info[sel];\r\noinfo = &abb->info[abb->current_info_idx];\r\nif (!memcmp(info, oinfo, sizeof(*info))) {\r\ndev_dbg(dev, "%s: Same data new idx=%d, old idx=%d\n", __func__,\r\nsel, abb->current_info_idx);\r\ngoto out;\r\n}\r\nret = ti_abb_set_opp(rdev, abb, info);\r\nout:\r\nif (!ret)\r\nabb->current_info_idx = sel;\r\nelse\r\ndev_err_ratelimited(dev,\r\n"%s: Volt[%d] idx[%d] mode[%d] Fail(%d)\n",\r\n__func__, desc->volt_table[sel], sel,\r\ninfo->opp_sel, ret);\r\nreturn ret;\r\n}\r\nstatic int ti_abb_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nconst struct regulator_desc *desc = rdev->desc;\r\nstruct ti_abb *abb = rdev_get_drvdata(rdev);\r\nstruct device *dev = &rdev->dev;\r\nif (!abb) {\r\ndev_err_ratelimited(dev, "%s: No regulator drvdata\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nif (!desc->n_voltages || !abb->info) {\r\ndev_err_ratelimited(dev,\r\n"%s: No valid voltage table entries?\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (abb->current_info_idx >= (int)desc->n_voltages) {\r\ndev_err(dev, "%s: Corrupted data? idx(%d) >= n_voltages(%d)\n",\r\n__func__, abb->current_info_idx, desc->n_voltages);\r\nreturn -EINVAL;\r\n}\r\nreturn abb->current_info_idx;\r\n}\r\nstatic int ti_abb_init_timings(struct device *dev, struct ti_abb *abb)\r\n{\r\nu32 clock_cycles;\r\nu32 clk_rate, sr2_wt_cnt_val, cycle_rate;\r\nconst struct ti_abb_reg *regs = abb->regs;\r\nint ret;\r\nchar *pname = "ti,settling-time";\r\nret = of_property_read_u32(dev->of_node, pname, &abb->settling_time);\r\nif (ret) {\r\ndev_err(dev, "Unable to get property '%s'(%d)\n", pname, ret);\r\nreturn ret;\r\n}\r\nif (!abb->settling_time) {\r\ndev_err(dev, "Invalid property:'%s' set as 0!\n", pname);\r\nreturn -EINVAL;\r\n}\r\npname = "ti,clock-cycles";\r\nret = of_property_read_u32(dev->of_node, pname, &clock_cycles);\r\nif (ret) {\r\ndev_err(dev, "Unable to get property '%s'(%d)\n", pname, ret);\r\nreturn ret;\r\n}\r\nif (!clock_cycles) {\r\ndev_err(dev, "Invalid property:'%s' set as 0!\n", pname);\r\nreturn -EINVAL;\r\n}\r\nabb->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(abb->clk)) {\r\nret = PTR_ERR(abb->clk);\r\ndev_err(dev, "%s: Unable to get clk(%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nclk_rate = DIV_ROUND_CLOSEST(clk_get_rate(abb->clk), 1000000);\r\ncycle_rate = DIV_ROUND_CLOSEST(clock_cycles * 10, clk_rate);\r\nsr2_wt_cnt_val = DIV_ROUND_CLOSEST(abb->settling_time * 10, cycle_rate);\r\ndev_dbg(dev, "%s: Clk_rate=%ld, sr2_cnt=0x%08x\n", __func__,\r\nclk_get_rate(abb->clk), sr2_wt_cnt_val);\r\nti_abb_rmw(regs->sr2_wtcnt_value_mask, sr2_wt_cnt_val, regs->setup_reg,\r\nabb->base);\r\nreturn 0;\r\n}\r\nstatic int ti_abb_init_table(struct device *dev, struct ti_abb *abb,\r\nstruct regulator_init_data *rinit_data)\r\n{\r\nstruct ti_abb_info *info;\r\nconst struct property *prop;\r\nconst __be32 *abb_info;\r\nconst u32 num_values = 6;\r\nchar *pname = "ti,abb_info";\r\nu32 num_entries, i;\r\nunsigned int *volt_table;\r\nint min_uV = INT_MAX, max_uV = 0;\r\nstruct regulation_constraints *c = &rinit_data->constraints;\r\nprop = of_find_property(dev->of_node, pname, NULL);\r\nif (!prop) {\r\ndev_err(dev, "No '%s' property?\n", pname);\r\nreturn -ENODEV;\r\n}\r\nif (!prop->value) {\r\ndev_err(dev, "Empty '%s' property?\n", pname);\r\nreturn -ENODATA;\r\n}\r\nnum_entries = prop->length / sizeof(u32);\r\nif (!num_entries || (num_entries % num_values)) {\r\ndev_err(dev, "All '%s' list entries need %d vals\n", pname,\r\nnum_values);\r\nreturn -EINVAL;\r\n}\r\nnum_entries /= num_values;\r\ninfo = devm_kzalloc(dev, sizeof(*info) * num_entries, GFP_KERNEL);\r\nif (!info) {\r\ndev_err(dev, "Can't allocate info table for '%s' property\n",\r\npname);\r\nreturn -ENOMEM;\r\n}\r\nabb->info = info;\r\nvolt_table = devm_kzalloc(dev, sizeof(unsigned int) * num_entries,\r\nGFP_KERNEL);\r\nif (!volt_table) {\r\ndev_err(dev, "Can't allocate voltage table for '%s' property\n",\r\npname);\r\nreturn -ENOMEM;\r\n}\r\nabb->rdesc.n_voltages = num_entries;\r\nabb->rdesc.volt_table = volt_table;\r\nabb->current_info_idx = -EINVAL;\r\nabb_info = prop->value;\r\nfor (i = 0; i < num_entries; i++, info++, volt_table++) {\r\nu32 efuse_offset, rbb_mask, fbb_mask, vset_mask;\r\nu32 efuse_val;\r\n*volt_table = be32_to_cpup(abb_info++);\r\ninfo->opp_sel = be32_to_cpup(abb_info++);\r\nefuse_offset = be32_to_cpup(abb_info++);\r\nrbb_mask = be32_to_cpup(abb_info++);\r\nfbb_mask = be32_to_cpup(abb_info++);\r\nvset_mask = be32_to_cpup(abb_info++);\r\ndev_dbg(dev,\r\n"[%d]v=%d ABB=%d ef=0x%x rbb=0x%x fbb=0x%x vset=0x%x\n",\r\ni, *volt_table, info->opp_sel, efuse_offset, rbb_mask,\r\nfbb_mask, vset_mask);\r\nif (min_uV > *volt_table)\r\nmin_uV = *volt_table;\r\nif (max_uV < *volt_table)\r\nmax_uV = *volt_table;\r\nif (!abb->efuse_base) {\r\nif (efuse_offset || rbb_mask || fbb_mask || vset_mask)\r\ndev_err(dev, "prop '%s': v=%d,bad efuse/mask\n",\r\npname, *volt_table);\r\ngoto check_abb;\r\n}\r\nefuse_val = readl(abb->efuse_base + efuse_offset);\r\nif (efuse_val & rbb_mask)\r\ninfo->opp_sel = TI_ABB_SLOW_OPP;\r\nelse if (efuse_val & fbb_mask)\r\ninfo->opp_sel = TI_ABB_FAST_OPP;\r\nelse if (rbb_mask || fbb_mask)\r\ninfo->opp_sel = TI_ABB_NOMINAL_OPP;\r\ndev_dbg(dev,\r\n"[%d]v=%d efusev=0x%x final ABB=%d\n",\r\ni, *volt_table, efuse_val, info->opp_sel);\r\nif (!abb->ldo_base) {\r\nif (vset_mask)\r\ndev_err(dev, "prop'%s':v=%d vst=%x LDO base?\n",\r\npname, *volt_table, vset_mask);\r\ncontinue;\r\n}\r\ninfo->vset = (efuse_val & vset_mask) >> __ffs(vset_mask);\r\ndev_dbg(dev, "[%d]v=%d vset=%x\n", i, *volt_table, info->vset);\r\ncheck_abb:\r\nswitch (info->opp_sel) {\r\ncase TI_ABB_NOMINAL_OPP:\r\ncase TI_ABB_FAST_OPP:\r\ncase TI_ABB_SLOW_OPP:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s:[%d]v=%d, ABB=%d is invalid! Abort!\n",\r\n__func__, i, *volt_table, info->opp_sel);\r\nreturn -EINVAL;\r\n}\r\n}\r\nc->min_uV = min_uV;\r\nc->max_uV = max_uV;\r\nreturn 0;\r\n}\r\nstatic int ti_abb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct ti_abb *abb;\r\nstruct regulator_init_data *initdata = NULL;\r\nstruct regulator_dev *rdev = NULL;\r\nstruct regulator_desc *desc;\r\nstruct regulation_constraints *c;\r\nstruct regulator_config config = { };\r\nchar *pname;\r\nint ret = 0;\r\nmatch = of_match_device(ti_abb_of_match, dev);\r\nif (!match) {\r\ndev_err(dev, "%s: Unable to match device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!match->data) {\r\ndev_err(dev, "%s: Bad data in match\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nabb = devm_kzalloc(dev, sizeof(struct ti_abb), GFP_KERNEL);\r\nif (!abb)\r\nreturn -ENOMEM;\r\nabb->regs = match->data;\r\npname = "base-address";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\r\nabb->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(abb->base))\r\nreturn PTR_ERR(abb->base);\r\npname = "int-address";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\r\nif (!res) {\r\ndev_err(dev, "Missing '%s' IO resource\n", pname);\r\nreturn -ENODEV;\r\n}\r\nabb->int_base = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nif (!abb->int_base) {\r\ndev_err(dev, "Unable to map '%s'\n", pname);\r\nreturn -ENOMEM;\r\n}\r\npname = "efuse-address";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\r\nif (!res) {\r\ndev_dbg(dev, "Missing '%s' IO resource\n", pname);\r\nret = -ENODEV;\r\ngoto skip_opt;\r\n}\r\nabb->efuse_base = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nif (!abb->efuse_base) {\r\ndev_err(dev, "Unable to map '%s'\n", pname);\r\nreturn -ENOMEM;\r\n}\r\npname = "ldo-address";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, pname);\r\nif (!res) {\r\ndev_dbg(dev, "Missing '%s' IO resource\n", pname);\r\nret = -ENODEV;\r\ngoto skip_opt;\r\n}\r\nabb->ldo_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(abb->ldo_base))\r\nreturn PTR_ERR(abb->ldo_base);\r\npname = "ti,ldovbb-override-mask";\r\nret =\r\nof_property_read_u32(pdev->dev.of_node, pname,\r\n&abb->ldovbb_override_mask);\r\nif (ret) {\r\ndev_err(dev, "Missing '%s' (%d)\n", pname, ret);\r\nreturn ret;\r\n}\r\nif (!abb->ldovbb_override_mask) {\r\ndev_err(dev, "Invalid property:'%s' set as 0!\n", pname);\r\nreturn -EINVAL;\r\n}\r\npname = "ti,ldovbb-vset-mask";\r\nret =\r\nof_property_read_u32(pdev->dev.of_node, pname,\r\n&abb->ldovbb_vset_mask);\r\nif (ret) {\r\ndev_err(dev, "Missing '%s' (%d)\n", pname, ret);\r\nreturn ret;\r\n}\r\nif (!abb->ldovbb_vset_mask) {\r\ndev_err(dev, "Invalid property:'%s' set as 0!\n", pname);\r\nreturn -EINVAL;\r\n}\r\nskip_opt:\r\npname = "ti,tranxdone-status-mask";\r\nret =\r\nof_property_read_u32(pdev->dev.of_node, pname,\r\n&abb->txdone_mask);\r\nif (ret) {\r\ndev_err(dev, "Missing '%s' (%d)\n", pname, ret);\r\nreturn ret;\r\n}\r\nif (!abb->txdone_mask) {\r\ndev_err(dev, "Invalid property:'%s' set as 0!\n", pname);\r\nreturn -EINVAL;\r\n}\r\ninitdata = of_get_regulator_init_data(dev, pdev->dev.of_node);\r\nif (!initdata) {\r\ndev_err(dev, "%s: Unable to alloc regulator init data\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nret = ti_abb_init_table(dev, abb, initdata);\r\nif (ret)\r\nreturn ret;\r\nret = ti_abb_init_timings(dev, abb);\r\nif (ret)\r\nreturn ret;\r\ndesc = &abb->rdesc;\r\ndesc->name = dev_name(dev);\r\ndesc->owner = THIS_MODULE;\r\ndesc->type = REGULATOR_VOLTAGE;\r\ndesc->ops = &ti_abb_reg_ops;\r\nc = &initdata->constraints;\r\nif (desc->n_voltages > 1)\r\nc->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;\r\nc->always_on = true;\r\nconfig.dev = dev;\r\nconfig.init_data = initdata;\r\nconfig.driver_data = abb;\r\nconfig.of_node = pdev->dev.of_node;\r\nrdev = devm_regulator_register(dev, desc, &config);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(dev, "%s: failed to register regulator(%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, rdev);\r\nti_abb_rmw(abb->regs->sr2_en_mask, 1, abb->regs->setup_reg, abb->base);\r\nreturn 0;\r\n}
