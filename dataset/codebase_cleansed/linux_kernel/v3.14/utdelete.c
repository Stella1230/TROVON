static void acpi_ut_delete_internal_obj(union acpi_operand_object *object)\r\n{\r\nvoid *obj_pointer = NULL;\r\nunion acpi_operand_object *handler_desc;\r\nunion acpi_operand_object *second_desc;\r\nunion acpi_operand_object *next_desc;\r\nunion acpi_operand_object **last_obj_ptr;\r\nACPI_FUNCTION_TRACE_PTR(ut_delete_internal_obj, object);\r\nif (!object) {\r\nreturn_VOID;\r\n}\r\nswitch (object->common.type) {\r\ncase ACPI_TYPE_STRING:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"**** String %p, ptr %p\n", object,\r\nobject->string.pointer));\r\nif (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {\r\nobj_pointer = object->string.pointer;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"**** Buffer %p, ptr %p\n", object,\r\nobject->buffer.pointer));\r\nif (!(object->common.flags & AOPOBJ_STATIC_POINTER)) {\r\nobj_pointer = object->buffer.pointer;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n" **** Package of count %X\n",\r\nobject->package.count));\r\nobj_pointer = object->package.elements;\r\nbreak;\r\ncase ACPI_TYPE_DEVICE:\r\nif (object->device.gpe_block) {\r\n(void)acpi_ev_delete_gpe_block(object->device.\r\ngpe_block);\r\n}\r\ncase ACPI_TYPE_PROCESSOR:\r\ncase ACPI_TYPE_THERMAL:\r\nhandler_desc = object->common_notify.handler;\r\nwhile (handler_desc) {\r\nnext_desc = handler_desc->address_space.next;\r\nacpi_ut_remove_reference(handler_desc);\r\nhandler_desc = next_desc;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_MUTEX:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Mutex %p, OS Mutex %p\n",\r\nobject, object->mutex.os_mutex));\r\nif (object == acpi_gbl_global_lock_mutex) {\r\n(void)\r\nacpi_os_delete_semaphore\r\n(acpi_gbl_global_lock_semaphore);\r\nacpi_gbl_global_lock_semaphore = NULL;\r\nacpi_os_delete_mutex(object->mutex.os_mutex);\r\nacpi_gbl_global_lock_mutex = NULL;\r\n} else {\r\nacpi_ex_unlink_mutex(object);\r\nacpi_os_delete_mutex(object->mutex.os_mutex);\r\n}\r\nbreak;\r\ncase ACPI_TYPE_EVENT:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Event %p, OS Semaphore %p\n",\r\nobject, object->event.os_semaphore));\r\n(void)acpi_os_delete_semaphore(object->event.os_semaphore);\r\nobject->event.os_semaphore = NULL;\r\nbreak;\r\ncase ACPI_TYPE_METHOD:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Method %p\n", object));\r\nif (object->method.mutex) {\r\nacpi_os_delete_mutex(object->method.mutex->mutex.\r\nos_mutex);\r\nacpi_ut_delete_object_desc(object->method.mutex);\r\nobject->method.mutex = NULL;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_REGION:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Region %p\n", object));\r\nif (!(object->region.node->flags & ANOBJ_TEMPORARY)) {\r\nacpi_ut_remove_address_range(object->region.space_id,\r\nobject->region.node);\r\n}\r\nsecond_desc = acpi_ns_get_secondary_object(object);\r\nif (second_desc) {\r\nhandler_desc = object->region.handler;\r\nif (handler_desc) {\r\nnext_desc =\r\nhandler_desc->address_space.region_list;\r\nlast_obj_ptr =\r\n&handler_desc->address_space.region_list;\r\nwhile (next_desc) {\r\nif (next_desc == object) {\r\n*last_obj_ptr =\r\nnext_desc->region.next;\r\nbreak;\r\n}\r\nlast_obj_ptr = &next_desc->region.next;\r\nnext_desc = next_desc->region.next;\r\n}\r\nif (handler_desc->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {\r\nif (handler_desc->address_space.setup) {\r\n(void)handler_desc->\r\naddress_space.setup(object,\r\nACPI_REGION_DEACTIVATE,\r\nhandler_desc->\r\naddress_space.\r\ncontext,\r\n&second_desc->\r\nextra.\r\nregion_context);\r\n}\r\n}\r\nacpi_ut_remove_reference(handler_desc);\r\n}\r\nacpi_ut_delete_object_desc(second_desc);\r\n}\r\nbreak;\r\ncase ACPI_TYPE_BUFFER_FIELD:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Buffer Field %p\n", object));\r\nsecond_desc = acpi_ns_get_secondary_object(object);\r\nif (second_desc) {\r\nacpi_ut_delete_object_desc(second_desc);\r\n}\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_BANK_FIELD:\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"***** Bank Field %p\n", object));\r\nsecond_desc = acpi_ns_get_secondary_object(object);\r\nif (second_desc) {\r\nacpi_ut_delete_object_desc(second_desc);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (obj_pointer) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Deleting Object Subptr %p\n", obj_pointer));\r\nACPI_FREE(obj_pointer);\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Deleting Object %p [%s]\n",\r\nobject, acpi_ut_get_object_type_name(object)));\r\nacpi_ut_delete_object_desc(object);\r\nreturn_VOID;\r\n}\r\nvoid acpi_ut_delete_internal_object_list(union acpi_operand_object **obj_list)\r\n{\r\nunion acpi_operand_object **internal_obj;\r\nACPI_FUNCTION_ENTRY();\r\nfor (internal_obj = obj_list; *internal_obj; internal_obj++) {\r\nacpi_ut_remove_reference(*internal_obj);\r\n}\r\nACPI_FREE(obj_list);\r\nreturn;\r\n}\r\nstatic void\r\nacpi_ut_update_ref_count(union acpi_operand_object *object, u32 action)\r\n{\r\nu16 original_count;\r\nu16 new_count = 0;\r\nacpi_cpu_flags lock_flags;\r\nACPI_FUNCTION_NAME(ut_update_ref_count);\r\nif (!object) {\r\nreturn;\r\n}\r\nlock_flags = acpi_os_acquire_lock(acpi_gbl_reference_count_lock);\r\noriginal_count = object->common.reference_count;\r\nswitch (action) {\r\ncase REF_INCREMENT:\r\nnew_count = original_count + 1;\r\nobject->common.reference_count = new_count;\r\nacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\r\nif (!original_count) {\r\nACPI_WARNING((AE_INFO,\r\n"Obj %p, Reference Count was zero before increment\n",\r\nobject));\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Obj %p Type %.2X Refs %.2X [Incremented]\n",\r\nobject, object->common.type, new_count));\r\nbreak;\r\ncase REF_DECREMENT:\r\nif (original_count) {\r\nnew_count = original_count - 1;\r\nobject->common.reference_count = new_count;\r\n}\r\nacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\r\nif (!original_count) {\r\nACPI_WARNING((AE_INFO,\r\n"Obj %p, Reference Count is already zero, cannot decrement\n",\r\nobject));\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Obj %p Type %.2X Refs %.2X [Decremented]\n",\r\nobject, object->common.type, new_count));\r\nif (new_count == 0) {\r\nacpi_ut_delete_internal_obj(object);\r\n}\r\nbreak;\r\ndefault:\r\nacpi_os_release_lock(acpi_gbl_reference_count_lock, lock_flags);\r\nACPI_ERROR((AE_INFO, "Unknown Reference Count action (0x%X)",\r\naction));\r\nreturn;\r\n}\r\nif (new_count > ACPI_MAX_REFERENCE_COUNT) {\r\nACPI_WARNING((AE_INFO,\r\n"Large Reference Count (0x%X) in object %p, Type=0x%.2X",\r\nnew_count, object, object->common.type));\r\n}\r\n}\r\nacpi_status\r\nacpi_ut_update_object_reference(union acpi_operand_object *object, u16 action)\r\n{\r\nacpi_status status = AE_OK;\r\nunion acpi_generic_state *state_list = NULL;\r\nunion acpi_operand_object *next_object = NULL;\r\nunion acpi_operand_object *prev_object;\r\nunion acpi_generic_state *state;\r\nu32 i;\r\nACPI_FUNCTION_NAME(ut_update_object_reference);\r\nwhile (object) {\r\nif (ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED) {\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Object %p is NS handle\n", object));\r\nreturn (AE_OK);\r\n}\r\nswitch (object->common.type) {\r\ncase ACPI_TYPE_DEVICE:\r\ncase ACPI_TYPE_PROCESSOR:\r\ncase ACPI_TYPE_POWER:\r\ncase ACPI_TYPE_THERMAL:\r\nfor (i = 0; i < ACPI_NUM_NOTIFY_TYPES; i++) {\r\nprev_object =\r\nobject->common_notify.notify_list[i];\r\nwhile (prev_object) {\r\nnext_object =\r\nprev_object->notify.next[i];\r\nacpi_ut_update_ref_count(prev_object,\r\naction);\r\nprev_object = next_object;\r\n}\r\n}\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\nfor (i = 0; i < object->package.count; i++) {\r\nnext_object = object->package.elements[i];\r\nif (!next_object) {\r\ncontinue;\r\n}\r\nswitch (next_object->common.type) {\r\ncase ACPI_TYPE_INTEGER:\r\ncase ACPI_TYPE_STRING:\r\ncase ACPI_TYPE_BUFFER:\r\nacpi_ut_update_ref_count(next_object,\r\naction);\r\nbreak;\r\ndefault:\r\nstatus =\r\nacpi_ut_create_update_state_and_push\r\n(next_object, action, &state_list);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nbreak;\r\n}\r\n}\r\nnext_object = NULL;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER_FIELD:\r\nnext_object = object->buffer_field.buffer_obj;\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_REGION_FIELD:\r\nnext_object = object->field.region_obj;\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_BANK_FIELD:\r\nnext_object = object->bank_field.bank_obj;\r\nstatus =\r\nacpi_ut_create_update_state_and_push(object->\r\nbank_field.\r\nregion_obj,\r\naction,\r\n&state_list);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_INDEX_FIELD:\r\nnext_object = object->index_field.index_obj;\r\nstatus =\r\nacpi_ut_create_update_state_and_push(object->\r\nindex_field.\r\ndata_obj,\r\naction,\r\n&state_list);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\nif ((object->reference.class == ACPI_REFCLASS_INDEX) ||\r\n(object->reference.class == ACPI_REFCLASS_NAME)) {\r\nnext_object = object->reference.object;\r\n}\r\nbreak;\r\ncase ACPI_TYPE_REGION:\r\ndefault:\r\nbreak;\r\n}\r\nacpi_ut_update_ref_count(object, action);\r\nobject = NULL;\r\nif (next_object) {\r\nobject = next_object;\r\nnext_object = NULL;\r\n} else if (state_list) {\r\nstate = acpi_ut_pop_generic_state(&state_list);\r\nobject = state->update.object;\r\nacpi_ut_delete_generic_state(state);\r\n}\r\n}\r\nreturn (AE_OK);\r\nerror_exit:\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Could not update object reference count"));\r\nwhile (state_list) {\r\nstate = acpi_ut_pop_generic_state(&state_list);\r\nacpi_ut_delete_generic_state(state);\r\n}\r\nreturn (status);\r\n}\r\nvoid acpi_ut_add_reference(union acpi_operand_object *object)\r\n{\r\nACPI_FUNCTION_NAME(ut_add_reference);\r\nif (!acpi_ut_valid_internal_object(object)) {\r\nreturn;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Obj %p Current Refs=%X [To Be Incremented]\n",\r\nobject, object->common.reference_count));\r\n(void)acpi_ut_update_object_reference(object, REF_INCREMENT);\r\nreturn;\r\n}\r\nvoid acpi_ut_remove_reference(union acpi_operand_object *object)\r\n{\r\nACPI_FUNCTION_NAME(ut_remove_reference);\r\nif (!object ||\r\n(ACPI_GET_DESCRIPTOR_TYPE(object) == ACPI_DESC_TYPE_NAMED)) {\r\nreturn;\r\n}\r\nif (!acpi_ut_valid_internal_object(object)) {\r\nreturn;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,\r\n"Obj %p Current Refs=%X [To Be Decremented]\n",\r\nobject, object->common.reference_count));\r\n(void)acpi_ut_update_object_reference(object, REF_DECREMENT);\r\nreturn;\r\n}
