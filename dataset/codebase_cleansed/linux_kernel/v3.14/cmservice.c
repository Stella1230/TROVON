bool afs_cm_incoming_call(struct afs_call *call)\r\n{\r\nu32 operation_id = ntohl(call->operation_ID);\r\n_enter("{CB.OP %u}", operation_id);\r\nswitch (operation_id) {\r\ncase CBCallBack:\r\ncall->type = &afs_SRXCBCallBack;\r\nreturn true;\r\ncase CBInitCallBackState:\r\ncall->type = &afs_SRXCBInitCallBackState;\r\nreturn true;\r\ncase CBInitCallBackState3:\r\ncall->type = &afs_SRXCBInitCallBackState3;\r\nreturn true;\r\ncase CBProbe:\r\ncall->type = &afs_SRXCBProbe;\r\nreturn true;\r\ncase CBTellMeAboutYourself:\r\ncall->type = &afs_SRXCBTellMeAboutYourself;\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void afs_cm_destructor(struct afs_call *call)\r\n{\r\n_enter("");\r\nafs_put_server(call->server);\r\ncall->server = NULL;\r\nkfree(call->buffer);\r\ncall->buffer = NULL;\r\n}\r\nstatic void SRXAFSCB_CallBack(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("");\r\nafs_send_empty_reply(call);\r\nafs_break_callbacks(call->server, call->count, call->request);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_callback(struct afs_call *call, struct sk_buff *skb,\r\nbool last)\r\n{\r\nstruct afs_callback *cb;\r\nstruct afs_server *server;\r\nstruct in_addr addr;\r\n__be32 *bp;\r\nu32 tmp;\r\nint ret, loop;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract FID count");\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ncall->count = ntohl(call->tmp);\r\n_debug("FID count: %u", call->count);\r\nif (call->count > AFSCBMAX)\r\nreturn -EBADMSG;\r\ncall->buffer = kmalloc(call->count * 3 * 4, GFP_KERNEL);\r\nif (!call->buffer)\r\nreturn -ENOMEM;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\n_debug("extract FID array");\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\ncall->count * 3 * 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n_debug("unmarshall FID array");\r\ncall->request = kcalloc(call->count,\r\nsizeof(struct afs_callback),\r\nGFP_KERNEL);\r\nif (!call->request)\r\nreturn -ENOMEM;\r\ncb = call->request;\r\nbp = call->buffer;\r\nfor (loop = call->count; loop > 0; loop--, cb++) {\r\ncb->fid.vid = ntohl(*bp++);\r\ncb->fid.vnode = ntohl(*bp++);\r\ncb->fid.unique = ntohl(*bp++);\r\ncb->type = AFSCM_CB_UNTYPED;\r\n}\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 3:\r\n_debug("extract CB count");\r\nret = afs_extract_data(call, skb, last, &call->tmp, 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\ntmp = ntohl(call->tmp);\r\n_debug("CB count: %u", tmp);\r\nif (tmp != call->count && tmp != 0)\r\nreturn -EBADMSG;\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\nif (tmp == 0)\r\ngoto empty_cb_array;\r\ncase 4:\r\n_debug("extract CB array");\r\nret = afs_extract_data(call, skb, last, call->request,\r\ncall->count * 3 * 4);\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n_debug("unmarshall CB array");\r\ncb = call->request;\r\nbp = call->buffer;\r\nfor (loop = call->count; loop > 0; loop--, cb++) {\r\ncb->version = ntohl(*bp++);\r\ncb->expiry = ntohl(*bp++);\r\ncb->type = ntohl(*bp++);\r\n}\r\nempty_cb_array:\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 5:\r\n_debug("trailer");\r\nif (skb->len != 0)\r\nreturn -EBADMSG;\r\nbreak;\r\n}\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\r\nserver = afs_find_server(&addr);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nINIT_WORK(&call->work, SRXAFSCB_CallBack);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}\r\nstatic void SRXAFSCB_InitCallBackState(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("{%p}", call->server);\r\nafs_init_callback_state(call->server);\r\nafs_send_empty_reply(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_init_call_back_state(struct afs_call *call,\r\nstruct sk_buff *skb,\r\nbool last)\r\n{\r\nstruct afs_server *server;\r\nstruct in_addr addr;\r\n_enter(",{%u},%d", skb->len, last);\r\nif (skb->len > 0)\r\nreturn -EBADMSG;\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\r\nserver = afs_find_server(&addr);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}\r\nstatic int afs_deliver_cb_init_call_back_state3(struct afs_call *call,\r\nstruct sk_buff *skb,\r\nbool last)\r\n{\r\nstruct afs_server *server;\r\nstruct in_addr addr;\r\n_enter(",{%u},%d", skb->len, last);\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nmemcpy(&addr, &ip_hdr(skb)->saddr, 4);\r\nserver = afs_find_server(&addr);\r\nif (!server)\r\nreturn -ENOTCONN;\r\ncall->server = server;\r\nINIT_WORK(&call->work, SRXAFSCB_InitCallBackState);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}\r\nstatic void SRXAFSCB_Probe(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\n_enter("");\r\nafs_send_empty_reply(call);\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_probe(struct afs_call *call, struct sk_buff *skb,\r\nbool last)\r\n{\r\n_enter(",{%u},%d", skb->len, last);\r\nif (skb->len > 0)\r\nreturn -EBADMSG;\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nINIT_WORK(&call->work, SRXAFSCB_Probe);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}\r\nstatic void SRXAFSCB_ProbeUuid(struct work_struct *work)\r\n{\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\nstruct afs_uuid *r = call->request;\r\nstruct {\r\n__be32 match;\r\n} reply;\r\n_enter("");\r\nif (memcmp(r, &afs_uuid, sizeof(afs_uuid)) == 0)\r\nreply.match = htonl(0);\r\nelse\r\nreply.match = htonl(1);\r\nafs_send_simple_reply(call, &reply, sizeof(reply));\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_probe_uuid(struct afs_call *call, struct sk_buff *skb,\r\nbool last)\r\n{\r\nstruct afs_uuid *r;\r\nunsigned loop;\r\n__be32 *b;\r\nint ret;\r\n_enter("{%u},{%u},%d", call->unmarshall, skb->len, last);\r\nif (skb->len > 0)\r\nreturn -EBADMSG;\r\nif (!last)\r\nreturn 0;\r\nswitch (call->unmarshall) {\r\ncase 0:\r\ncall->offset = 0;\r\ncall->buffer = kmalloc(11 * sizeof(__be32), GFP_KERNEL);\r\nif (!call->buffer)\r\nreturn -ENOMEM;\r\ncall->unmarshall++;\r\ncase 1:\r\n_debug("extract UUID");\r\nret = afs_extract_data(call, skb, last, call->buffer,\r\n11 * sizeof(__be32));\r\nswitch (ret) {\r\ncase 0: break;\r\ncase -EAGAIN: return 0;\r\ndefault: return ret;\r\n}\r\n_debug("unmarshall UUID");\r\ncall->request = kmalloc(sizeof(struct afs_uuid), GFP_KERNEL);\r\nif (!call->request)\r\nreturn -ENOMEM;\r\nb = call->buffer;\r\nr = call->request;\r\nr->time_low = ntohl(b[0]);\r\nr->time_mid = ntohl(b[1]);\r\nr->time_hi_and_version = ntohl(b[2]);\r\nr->clock_seq_hi_and_reserved = ntohl(b[3]);\r\nr->clock_seq_low = ntohl(b[4]);\r\nfor (loop = 0; loop < 6; loop++)\r\nr->node[loop] = ntohl(b[loop + 5]);\r\ncall->offset = 0;\r\ncall->unmarshall++;\r\ncase 2:\r\n_debug("trailer");\r\nif (skb->len != 0)\r\nreturn -EBADMSG;\r\nbreak;\r\n}\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nINIT_WORK(&call->work, SRXAFSCB_ProbeUuid);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}\r\nstatic void SRXAFSCB_TellMeAboutYourself(struct work_struct *work)\r\n{\r\nstruct afs_interface *ifs;\r\nstruct afs_call *call = container_of(work, struct afs_call, work);\r\nint loop, nifs;\r\nstruct {\r\nstruct {\r\n__be32 nifs;\r\n__be32 uuid[11];\r\n__be32 ifaddr[32];\r\n__be32 netmask[32];\r\n__be32 mtu[32];\r\n} ia;\r\nstruct {\r\n__be32 capcount;\r\n__be32 caps[1];\r\n} cap;\r\n} reply;\r\n_enter("");\r\nnifs = 0;\r\nifs = kcalloc(32, sizeof(*ifs), GFP_KERNEL);\r\nif (ifs) {\r\nnifs = afs_get_ipv4_interfaces(ifs, 32, false);\r\nif (nifs < 0) {\r\nkfree(ifs);\r\nifs = NULL;\r\nnifs = 0;\r\n}\r\n}\r\nmemset(&reply, 0, sizeof(reply));\r\nreply.ia.nifs = htonl(nifs);\r\nreply.ia.uuid[0] = htonl(afs_uuid.time_low);\r\nreply.ia.uuid[1] = htonl(afs_uuid.time_mid);\r\nreply.ia.uuid[2] = htonl(afs_uuid.time_hi_and_version);\r\nreply.ia.uuid[3] = htonl((s8) afs_uuid.clock_seq_hi_and_reserved);\r\nreply.ia.uuid[4] = htonl((s8) afs_uuid.clock_seq_low);\r\nfor (loop = 0; loop < 6; loop++)\r\nreply.ia.uuid[loop + 5] = htonl((s8) afs_uuid.node[loop]);\r\nif (ifs) {\r\nfor (loop = 0; loop < nifs; loop++) {\r\nreply.ia.ifaddr[loop] = ifs[loop].address.s_addr;\r\nreply.ia.netmask[loop] = ifs[loop].netmask.s_addr;\r\nreply.ia.mtu[loop] = htonl(ifs[loop].mtu);\r\n}\r\nkfree(ifs);\r\n}\r\nreply.cap.capcount = htonl(1);\r\nreply.cap.caps[0] = htonl(AFS_CAP_ERROR_TRANSLATION);\r\nafs_send_simple_reply(call, &reply, sizeof(reply));\r\n_leave("");\r\n}\r\nstatic int afs_deliver_cb_tell_me_about_yourself(struct afs_call *call,\r\nstruct sk_buff *skb, bool last)\r\n{\r\n_enter(",{%u},%d", skb->len, last);\r\nif (skb->len > 0)\r\nreturn -EBADMSG;\r\nif (!last)\r\nreturn 0;\r\ncall->state = AFS_CALL_REPLYING;\r\nINIT_WORK(&call->work, SRXAFSCB_TellMeAboutYourself);\r\nqueue_work(afs_wq, &call->work);\r\nreturn 0;\r\n}
