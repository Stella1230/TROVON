static int of_flash_remove(struct platform_device *dev)\r\n{\r\nstruct of_flash *info;\r\nint i;\r\ninfo = dev_get_drvdata(&dev->dev);\r\nif (!info)\r\nreturn 0;\r\ndev_set_drvdata(&dev->dev, NULL);\r\nif (info->cmtd != info->list[0].mtd) {\r\nmtd_device_unregister(info->cmtd);\r\nmtd_concat_destroy(info->cmtd);\r\n}\r\nif (info->cmtd)\r\nmtd_device_unregister(info->cmtd);\r\nfor (i = 0; i < info->list_size; i++) {\r\nif (info->list[i].mtd)\r\nmap_destroy(info->list[i].mtd);\r\nif (info->list[i].map.virt)\r\niounmap(info->list[i].map.virt);\r\nif (info->list[i].res) {\r\nrelease_resource(info->list[i].res);\r\nkfree(info->list[i].res);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mtd_info *obsolete_probe(struct platform_device *dev,\r\nstruct map_info *map)\r\n{\r\nstruct device_node *dp = dev->dev.of_node;\r\nconst char *of_probe;\r\nstruct mtd_info *mtd;\r\nint i;\r\ndev_warn(&dev->dev, "Device tree uses obsolete \"direct-mapped\" "\r\n"flash binding\n");\r\nof_probe = of_get_property(dp, "probe-type", NULL);\r\nif (!of_probe) {\r\nfor (i = 0; i < ARRAY_SIZE(rom_probe_types); i++) {\r\nmtd = do_map_probe(rom_probe_types[i], map);\r\nif (mtd)\r\nreturn mtd;\r\n}\r\nreturn NULL;\r\n} else if (strcmp(of_probe, "CFI") == 0) {\r\nreturn do_map_probe("cfi_probe", map);\r\n} else if (strcmp(of_probe, "JEDEC") == 0) {\r\nreturn do_map_probe("jedec_probe", map);\r\n} else {\r\nif (strcmp(of_probe, "ROM") != 0)\r\ndev_warn(&dev->dev, "obsolete_probe: don't know probe "\r\n"type '%s', mapping as rom\n", of_probe);\r\nreturn do_map_probe("mtd_rom", map);\r\n}\r\n}\r\nstatic const char * const *of_get_probes(struct device_node *dp)\r\n{\r\nconst char *cp;\r\nint cplen;\r\nunsigned int l;\r\nunsigned int count;\r\nconst char **res;\r\ncp = of_get_property(dp, "linux,part-probe", &cplen);\r\nif (cp == NULL)\r\nreturn part_probe_types_def;\r\ncount = 0;\r\nfor (l = 0; l != cplen; l++)\r\nif (cp[l] == 0)\r\ncount++;\r\nres = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);\r\ncount = 0;\r\nwhile (cplen > 0) {\r\nres[count] = cp;\r\nl = strlen(cp) + 1;\r\ncp += l;\r\ncplen -= l;\r\ncount++;\r\n}\r\nreturn res;\r\n}\r\nstatic void of_free_probes(const char * const *probes)\r\n{\r\nif (probes != part_probe_types_def)\r\nkfree(probes);\r\n}\r\nstatic int of_flash_probe(struct platform_device *dev)\r\n{\r\nconst char * const *part_probe_types;\r\nconst struct of_device_id *match;\r\nstruct device_node *dp = dev->dev.of_node;\r\nstruct resource res;\r\nstruct of_flash *info;\r\nconst char *probe_type;\r\nconst __be32 *width;\r\nint err;\r\nint i;\r\nint count;\r\nconst __be32 *p;\r\nint reg_tuple_size;\r\nstruct mtd_info **mtd_list = NULL;\r\nresource_size_t res_size;\r\nstruct mtd_part_parser_data ppdata;\r\nbool map_indirect;\r\nconst char *mtd_name = NULL;\r\nmatch = of_match_device(of_flash_match, &dev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nprobe_type = match->data;\r\nreg_tuple_size = (of_n_addr_cells(dp) + of_n_size_cells(dp)) * sizeof(u32);\r\nof_property_read_string(dp, "linux,mtd-name", &mtd_name);\r\np = of_get_property(dp, "reg", &count);\r\nif (count % reg_tuple_size != 0) {\r\ndev_err(&dev->dev, "Malformed reg property on %s\n",\r\ndev->dev.of_node->full_name);\r\nerr = -EINVAL;\r\ngoto err_flash_remove;\r\n}\r\ncount /= reg_tuple_size;\r\nmap_indirect = of_property_read_bool(dp, "no-unaligned-direct-access");\r\nerr = -ENOMEM;\r\ninfo = devm_kzalloc(&dev->dev,\r\nsizeof(struct of_flash) +\r\nsizeof(struct of_flash_list) * count, GFP_KERNEL);\r\nif (!info)\r\ngoto err_flash_remove;\r\ndev_set_drvdata(&dev->dev, info);\r\nmtd_list = kzalloc(sizeof(*mtd_list) * count, GFP_KERNEL);\r\nif (!mtd_list)\r\ngoto err_flash_remove;\r\nfor (i = 0; i < count; i++) {\r\nerr = -ENXIO;\r\nif (of_address_to_resource(dp, i, &res)) {\r\ncontinue;\r\n}\r\ndev_dbg(&dev->dev, "of_flash device: %pR\n", &res);\r\nerr = -EBUSY;\r\nres_size = resource_size(&res);\r\ninfo->list[i].res = request_mem_region(res.start, res_size,\r\ndev_name(&dev->dev));\r\nif (!info->list[i].res)\r\ngoto err_out;\r\nerr = -ENXIO;\r\nwidth = of_get_property(dp, "bank-width", NULL);\r\nif (!width) {\r\ndev_err(&dev->dev, "Can't get bank width from device"\r\n" tree\n");\r\ngoto err_out;\r\n}\r\ninfo->list[i].map.name = mtd_name ?: dev_name(&dev->dev);\r\ninfo->list[i].map.phys = res.start;\r\ninfo->list[i].map.size = res_size;\r\ninfo->list[i].map.bankwidth = be32_to_cpup(width);\r\ninfo->list[i].map.device_node = dp;\r\nerr = -ENOMEM;\r\ninfo->list[i].map.virt = ioremap(info->list[i].map.phys,\r\ninfo->list[i].map.size);\r\nif (!info->list[i].map.virt) {\r\ndev_err(&dev->dev, "Failed to ioremap() flash"\r\n" region\n");\r\ngoto err_out;\r\n}\r\nsimple_map_init(&info->list[i].map);\r\nif (map_indirect)\r\ninfo->list[i].map.phys = NO_XIP;\r\nif (probe_type) {\r\ninfo->list[i].mtd = do_map_probe(probe_type,\r\n&info->list[i].map);\r\n} else {\r\ninfo->list[i].mtd = obsolete_probe(dev,\r\n&info->list[i].map);\r\n}\r\nmtd_list[i] = info->list[i].mtd;\r\nerr = -ENXIO;\r\nif (!info->list[i].mtd) {\r\ndev_err(&dev->dev, "do_map_probe() failed\n");\r\ngoto err_out;\r\n} else {\r\ninfo->list_size++;\r\n}\r\ninfo->list[i].mtd->owner = THIS_MODULE;\r\ninfo->list[i].mtd->dev.parent = &dev->dev;\r\n}\r\nerr = 0;\r\ninfo->cmtd = NULL;\r\nif (info->list_size == 1) {\r\ninfo->cmtd = info->list[0].mtd;\r\n} else if (info->list_size > 1) {\r\ninfo->cmtd = mtd_concat_create(mtd_list, info->list_size,\r\ndev_name(&dev->dev));\r\n}\r\nif (info->cmtd == NULL)\r\nerr = -ENXIO;\r\nif (err)\r\ngoto err_out;\r\nppdata.of_node = dp;\r\npart_probe_types = of_get_probes(dp);\r\nmtd_device_parse_register(info->cmtd, part_probe_types, &ppdata,\r\nNULL, 0);\r\nof_free_probes(part_probe_types);\r\nkfree(mtd_list);\r\nreturn 0;\r\nerr_out:\r\nkfree(mtd_list);\r\nerr_flash_remove:\r\nof_flash_remove(dev);\r\nreturn err;\r\n}
