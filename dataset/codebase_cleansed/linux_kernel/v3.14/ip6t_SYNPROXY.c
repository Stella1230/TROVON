static struct ipv6hdr *\r\nsynproxy_build_ip(struct sk_buff *skb, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nstruct ipv6hdr *iph;\r\nskb_reset_network_header(skb);\r\niph = (struct ipv6hdr *)skb_put(skb, sizeof(*iph));\r\nip6_flow_hdr(iph, 0, 0);\r\niph->hop_limit = 64;\r\niph->nexthdr = IPPROTO_TCP;\r\niph->saddr = *saddr;\r\niph->daddr = *daddr;\r\nreturn iph;\r\n}\r\nstatic void\r\nsynproxy_send_tcp(const struct sk_buff *skb, struct sk_buff *nskb,\r\nstruct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,\r\nstruct ipv6hdr *niph, struct tcphdr *nth,\r\nunsigned int tcp_hdr_size)\r\n{\r\nstruct net *net = nf_ct_net((struct nf_conn *)nfct);\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nnth->check = ~tcp_v6_check(tcp_hdr_size, &niph->saddr, &niph->daddr, 0);\r\nnskb->ip_summed = CHECKSUM_PARTIAL;\r\nnskb->csum_start = (unsigned char *)nth - nskb->head;\r\nnskb->csum_offset = offsetof(struct tcphdr, check);\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_TCP;\r\nfl6.saddr = niph->saddr;\r\nfl6.daddr = niph->daddr;\r\nfl6.fl6_sport = nth->source;\r\nfl6.fl6_dport = nth->dest;\r\nsecurity_skb_classify_flow((struct sk_buff *)skb, flowi6_to_flowi(&fl6));\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst == NULL || dst->error) {\r\ndst_release(dst);\r\ngoto free_nskb;\r\n}\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst))\r\ngoto free_nskb;\r\nskb_dst_set(nskb, dst);\r\nif (nfct) {\r\nnskb->nfct = nfct;\r\nnskb->nfctinfo = ctinfo;\r\nnf_conntrack_get(nfct);\r\n}\r\nip6_local_out(nskb);\r\nreturn;\r\nfree_nskb:\r\nkfree_skb(nskb);\r\n}\r\nstatic void\r\nsynproxy_send_client_synack(const struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct ipv6hdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\nu16 mss = opts->mss;\r\niph = ipv6_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, &iph->daddr, &iph->saddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->dest;\r\nnth->dest = th->source;\r\nnth->seq = htonl(__cookie_v6_init_sequence(iph, th, &mss));\r\nnth->ack_seq = htonl(ntohl(th->seq) + 1);\r\ntcp_flag_word(nth) = TCP_FLAG_SYN | TCP_FLAG_ACK;\r\nif (opts->options & XT_SYNPROXY_OPT_ECN)\r\ntcp_flag_word(nth) |= TCP_FLAG_ECE;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = 0;\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(skb, nskb, skb->nfct, IP_CT_ESTABLISHED_REPLY,\r\nniph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_server_syn(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts, u32 recv_seq)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct ipv6hdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ipv6_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, &iph->saddr, &iph->daddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->source;\r\nnth->dest = th->dest;\r\nnth->seq = htonl(recv_seq - 1);\r\nnth->ack_seq = htonl(ntohl(th->ack_seq) - 1);\r\ntcp_flag_word(nth) = TCP_FLAG_SYN;\r\nif (opts->options & XT_SYNPROXY_OPT_ECN)\r\ntcp_flag_word(nth) |= TCP_FLAG_ECE | TCP_FLAG_CWR;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = th->window;\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(skb, nskb, &snet->tmpl->ct_general, IP_CT_NEW,\r\nniph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_server_ack(const struct synproxy_net *snet,\r\nconst struct ip_ct_tcp *state,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct ipv6hdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ipv6_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, &iph->daddr, &iph->saddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->dest;\r\nnth->dest = th->source;\r\nnth->seq = htonl(ntohl(th->ack_seq));\r\nnth->ack_seq = htonl(ntohl(th->seq) + 1);\r\ntcp_flag_word(nth) = TCP_FLAG_ACK;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = htons(state->seen[IP_CT_DIR_ORIGINAL].td_maxwin);\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);\r\n}\r\nstatic void\r\nsynproxy_send_client_ack(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nconst struct synproxy_options *opts)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct ipv6hdr *iph, *niph;\r\nstruct tcphdr *nth;\r\nunsigned int tcp_hdr_size;\r\niph = ipv6_hdr(skb);\r\ntcp_hdr_size = sizeof(*nth) + synproxy_options_size(opts);\r\nnskb = alloc_skb(sizeof(*niph) + tcp_hdr_size + MAX_TCP_HEADER,\r\nGFP_ATOMIC);\r\nif (nskb == NULL)\r\nreturn;\r\nskb_reserve(nskb, MAX_TCP_HEADER);\r\nniph = synproxy_build_ip(nskb, &iph->saddr, &iph->daddr);\r\nskb_reset_transport_header(nskb);\r\nnth = (struct tcphdr *)skb_put(nskb, tcp_hdr_size);\r\nnth->source = th->source;\r\nnth->dest = th->dest;\r\nnth->seq = htonl(ntohl(th->seq) + 1);\r\nnth->ack_seq = th->ack_seq;\r\ntcp_flag_word(nth) = TCP_FLAG_ACK;\r\nnth->doff = tcp_hdr_size / 4;\r\nnth->window = ntohs(htons(th->window) >> opts->wscale);\r\nnth->check = 0;\r\nnth->urg_ptr = 0;\r\nsynproxy_build_options(nth, opts);\r\nsynproxy_send_tcp(skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);\r\n}\r\nstatic bool\r\nsynproxy_recv_client_ack(const struct synproxy_net *snet,\r\nconst struct sk_buff *skb, const struct tcphdr *th,\r\nstruct synproxy_options *opts, u32 recv_seq)\r\n{\r\nint mss;\r\nmss = __cookie_v6_check(ipv6_hdr(skb), th, ntohl(th->ack_seq) - 1);\r\nif (mss == 0) {\r\nthis_cpu_inc(snet->stats->cookie_invalid);\r\nreturn false;\r\n}\r\nthis_cpu_inc(snet->stats->cookie_valid);\r\nopts->mss = mss;\r\nopts->options |= XT_SYNPROXY_OPT_MSS;\r\nif (opts->options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy_check_timestamp_cookie(opts);\r\nsynproxy_send_server_syn(snet, skb, th, opts, recv_seq);\r\nreturn true;\r\n}\r\nstatic unsigned int\r\nsynproxy_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_synproxy_info *info = par->targinfo;\r\nstruct synproxy_net *snet = synproxy_pernet(dev_net(par->in));\r\nstruct synproxy_options opts = {};\r\nstruct tcphdr *th, _th;\r\nif (nf_ip6_checksum(skb, par->hooknum, par->thoff, IPPROTO_TCP))\r\nreturn NF_DROP;\r\nth = skb_header_pointer(skb, par->thoff, sizeof(_th), &_th);\r\nif (th == NULL)\r\nreturn NF_DROP;\r\nif (!synproxy_parse_options(skb, par->thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (th->syn && !(th->ack || th->fin || th->rst)) {\r\nthis_cpu_inc(snet->stats->syn_received);\r\nif (th->ece && th->cwr)\r\nopts.options |= XT_SYNPROXY_OPT_ECN;\r\nopts.options &= info->options;\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy_init_timestamp_cookie(info, &opts);\r\nelse\r\nopts.options &= ~(XT_SYNPROXY_OPT_WSCALE |\r\nXT_SYNPROXY_OPT_SACK_PERM |\r\nXT_SYNPROXY_OPT_ECN);\r\nsynproxy_send_client_synack(skb, th, &opts);\r\nreturn NF_DROP;\r\n} else if (th->ack && !(th->fin || th->rst || th->syn)) {\r\nsynproxy_recv_client_ack(snet, skb, th, &opts, ntohl(th->seq));\r\nreturn NF_DROP;\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic unsigned int ipv6_synproxy_hook(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(dev_net(in ? : out));\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\nstruct nf_conn_synproxy *synproxy;\r\nstruct synproxy_options opts = {};\r\nconst struct ip_ct_tcp *state;\r\nstruct tcphdr *th, _th;\r\n__be16 frag_off;\r\nu8 nexthdr;\r\nint thoff;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn NF_ACCEPT;\r\nsynproxy = nfct_synproxy(ct);\r\nif (synproxy == NULL)\r\nreturn NF_ACCEPT;\r\nif (nf_is_loopback_packet(skb))\r\nreturn NF_ACCEPT;\r\nnexthdr = ipv6_hdr(skb)->nexthdr;\r\nthoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,\r\n&frag_off);\r\nif (thoff < 0)\r\nreturn NF_ACCEPT;\r\nth = skb_header_pointer(skb, thoff, sizeof(_th), &_th);\r\nif (th == NULL)\r\nreturn NF_DROP;\r\nstate = &ct->proto.tcp;\r\nswitch (state->state) {\r\ncase TCP_CONNTRACK_CLOSE:\r\nif (th->rst && !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nnf_ct_seqadj_init(ct, ctinfo, synproxy->isn -\r\nntohl(th->seq) + 1);\r\nbreak;\r\n}\r\nif (!th->syn || th->ack ||\r\nCTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\r\nbreak;\r\nnf_ct_seqadj_init(ct, ctinfo, 0);\r\nsynproxy->tsoff = 0;\r\nthis_cpu_inc(snet->stats->conn_reopened);\r\ncase TCP_CONNTRACK_SYN_SENT:\r\nif (!synproxy_parse_options(skb, thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (!th->syn && th->ack &&\r\nCTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) {\r\nif (synproxy_recv_client_ack(snet, skb, th, &opts,\r\nntohl(th->seq) + 1))\r\nthis_cpu_inc(snet->stats->cookie_retrans);\r\nreturn NF_DROP;\r\n}\r\nsynproxy->isn = ntohl(th->ack_seq);\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy->its = opts.tsecr;\r\nbreak;\r\ncase TCP_CONNTRACK_SYN_RECV:\r\nif (!th->syn || !th->ack)\r\nbreak;\r\nif (!synproxy_parse_options(skb, thoff, th, &opts))\r\nreturn NF_DROP;\r\nif (opts.options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsynproxy->tsoff = opts.tsval - synproxy->its;\r\nopts.options &= ~(XT_SYNPROXY_OPT_MSS |\r\nXT_SYNPROXY_OPT_WSCALE |\r\nXT_SYNPROXY_OPT_SACK_PERM);\r\nswap(opts.tsval, opts.tsecr);\r\nsynproxy_send_server_ack(snet, state, skb, th, &opts);\r\nnf_ct_seqadj_init(ct, ctinfo, synproxy->isn - ntohl(th->seq));\r\nswap(opts.tsval, opts.tsecr);\r\nsynproxy_send_client_ack(snet, skb, th, &opts);\r\nconsume_skb(skb);\r\nreturn NF_STOLEN;\r\ndefault:\r\nbreak;\r\n}\r\nsynproxy_tstamp_adjust(skb, thoff, th, ct, ctinfo, synproxy);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int synproxy_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nif (!(e->ipv6.flags & IP6T_F_PROTO) ||\r\ne->ipv6.proto != IPPROTO_TCP ||\r\ne->ipv6.invflags & XT_INV_PROTO)\r\nreturn -EINVAL;\r\nreturn nf_ct_l3proto_try_module_get(par->family);\r\n}\r\nstatic void synproxy_tg6_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic int __init synproxy_tg6_init(void)\r\n{\r\nint err;\r\nerr = nf_register_hooks(ipv6_synproxy_ops,\r\nARRAY_SIZE(ipv6_synproxy_ops));\r\nif (err < 0)\r\ngoto err1;\r\nerr = xt_register_target(&synproxy_tg6_reg);\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_unregister_hooks(ipv6_synproxy_ops, ARRAY_SIZE(ipv6_synproxy_ops));\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit synproxy_tg6_exit(void)\r\n{\r\nxt_unregister_target(&synproxy_tg6_reg);\r\nnf_unregister_hooks(ipv6_synproxy_ops, ARRAY_SIZE(ipv6_synproxy_ops));\r\n}
