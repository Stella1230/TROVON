static void drop_pagecache_sb(struct super_block *sb, void *unused)\r\n{\r\nstruct inode *inode, *toput_inode = NULL;\r\nspin_lock(&inode_sb_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&inode->i_lock);\r\nif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\r\n(inode->i_mapping->nrpages == 0)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\n__iget(inode);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&inode_sb_list_lock);\r\ninvalidate_mapping_pages(inode->i_mapping, 0, -1);\r\niput(toput_inode);\r\ntoput_inode = inode;\r\nspin_lock(&inode_sb_list_lock);\r\n}\r\nspin_unlock(&inode_sb_list_lock);\r\niput(toput_inode);\r\n}\r\nstatic void drop_slab(void)\r\n{\r\nint nr_objects;\r\nstruct shrink_control shrink = {\r\n.gfp_mask = GFP_KERNEL,\r\n};\r\nnodes_setall(shrink.nodes_to_scan);\r\ndo {\r\nnr_objects = shrink_slab(&shrink, 1000, 1000);\r\n} while (nr_objects > 10);\r\n}\r\nint drop_caches_sysctl_handler(ctl_table *table, int write,\r\nvoid __user *buffer, size_t *length, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_dointvec_minmax(table, write, buffer, length, ppos);\r\nif (ret)\r\nreturn ret;\r\nif (write) {\r\nif (sysctl_drop_caches & 1)\r\niterate_supers(drop_pagecache_sb, NULL);\r\nif (sysctl_drop_caches & 2)\r\ndrop_slab();\r\n}\r\nreturn 0;\r\n}
