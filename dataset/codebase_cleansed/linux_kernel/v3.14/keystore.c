static int process_request_key_err(long err_code)\r\n{\r\nint rc = 0;\r\nswitch (err_code) {\r\ncase -ENOKEY:\r\necryptfs_printk(KERN_WARNING, "No key\n");\r\nrc = -ENOENT;\r\nbreak;\r\ncase -EKEYEXPIRED:\r\necryptfs_printk(KERN_WARNING, "Key expired\n");\r\nrc = -ETIME;\r\nbreak;\r\ncase -EKEYREVOKED:\r\necryptfs_printk(KERN_WARNING, "Key revoked\n");\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\necryptfs_printk(KERN_WARNING, "Unknown error code: "\r\n"[0x%.16lx]\n", err_code);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int process_find_global_auth_tok_for_sig_err(int err_code)\r\n{\r\nint rc = err_code;\r\nswitch (err_code) {\r\ncase -ENOENT:\r\necryptfs_printk(KERN_WARNING, "Missing auth tok\n");\r\nbreak;\r\ncase -EINVAL:\r\necryptfs_printk(KERN_WARNING, "Invalid auth tok\n");\r\nbreak;\r\ndefault:\r\nrc = process_request_key_err(err_code);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\r\nsize_t *length_size)\r\n{\r\nint rc = 0;\r\n(*length_size) = 0;\r\n(*size) = 0;\r\nif (data[0] < 192) {\r\n(*size) = (unsigned char)data[0];\r\n(*length_size) = 1;\r\n} else if (data[0] < 224) {\r\n(*size) = (((unsigned char)(data[0]) - 192) * 256);\r\n(*size) += ((unsigned char)(data[1]) + 192);\r\n(*length_size) = 2;\r\n} else if (data[0] == 255) {\r\necryptfs_printk(KERN_ERR, "Five-byte packet length not "\r\n"supported\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n} else {\r\necryptfs_printk(KERN_ERR, "Error parsing packet length\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_write_packet_length(char *dest, size_t size,\r\nsize_t *packet_size_length)\r\n{\r\nint rc = 0;\r\nif (size < 192) {\r\ndest[0] = size;\r\n(*packet_size_length) = 1;\r\n} else if (size < 65536) {\r\ndest[0] = (((size - 192) / 256) + 192);\r\ndest[1] = ((size - 192) % 256);\r\n(*packet_size_length) = 2;\r\n} else {\r\nrc = -EINVAL;\r\necryptfs_printk(KERN_WARNING,\r\n"Unsupported packet size: [%zd]\n", size);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\r\nchar **packet, size_t *packet_len)\r\n{\r\nsize_t i = 0;\r\nsize_t data_len;\r\nsize_t packet_size_len;\r\nchar *message;\r\nint rc;\r\ndata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\r\n+ session_key->encrypted_key_size);\r\n*packet = kmalloc(data_len, GFP_KERNEL);\r\nmessage = *packet;\r\nif (!message) {\r\necryptfs_printk(KERN_ERR, "Unable to allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\r\n&packet_size_len);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 64 packet "\r\n"header; cannot generate packet length\n");\r\ngoto out;\r\n}\r\ni += packet_size_len;\r\nmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\r\ni += ECRYPTFS_SIG_SIZE_HEX;\r\nrc = ecryptfs_write_packet_length(&message[i],\r\nsession_key->encrypted_key_size,\r\n&packet_size_len);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 64 packet "\r\n"header; cannot generate packet length\n");\r\ngoto out;\r\n}\r\ni += packet_size_len;\r\nmemcpy(&message[i], session_key->encrypted_key,\r\nsession_key->encrypted_key_size);\r\ni += session_key->encrypted_key_size;\r\n*packet_len = i;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\r\nstruct ecryptfs_message *msg)\r\n{\r\nsize_t i = 0;\r\nchar *data;\r\nsize_t data_len;\r\nsize_t m_size;\r\nsize_t message_len;\r\nu16 checksum = 0;\r\nu16 expected_checksum = 0;\r\nint rc;\r\nmessage_len = msg->data_len;\r\ndata = msg->data;\r\nif (message_len < 4) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\r\necryptfs_printk(KERN_ERR, "Type should be ECRYPTFS_TAG_65\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (data[i++]) {\r\necryptfs_printk(KERN_ERR, "Status indicator has non-zero value "\r\n"[%d]\n", data[i-1]);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nrc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error parsing packet length; "\r\n"rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\ni += data_len;\r\nif (message_len < (i + m_size)) {\r\necryptfs_printk(KERN_ERR, "The message received from ecryptfsd "\r\n"is shorter than expected\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (m_size < 3) {\r\necryptfs_printk(KERN_ERR,\r\n"The decrypted key is not long enough to "\r\n"include a cipher code and checksum\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\n*cipher_code = data[i++];\r\nsession_key->decrypted_key_size = m_size - 3;\r\nif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\r\necryptfs_printk(KERN_ERR, "key_size [%d] larger than "\r\n"the maximum key size [%d]\n",\r\nsession_key->decrypted_key_size,\r\nECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(session_key->decrypted_key, &data[i],\r\nsession_key->decrypted_key_size);\r\ni += session_key->decrypted_key_size;\r\nexpected_checksum += (unsigned char)(data[i++]) << 8;\r\nexpected_checksum += (unsigned char)(data[i++]);\r\nfor (i = 0; i < session_key->decrypted_key_size; i++)\r\nchecksum += session_key->decrypted_key[i];\r\nif (expected_checksum != checksum) {\r\necryptfs_printk(KERN_ERR, "Invalid checksum for file "\r\n"encryption key; expected [%x]; calculated "\r\n"[%x]\n", expected_checksum, checksum);\r\nrc = -EIO;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_tag_66_packet(char *signature, u8 cipher_code,\r\nstruct ecryptfs_crypt_stat *crypt_stat, char **packet,\r\nsize_t *packet_len)\r\n{\r\nsize_t i = 0;\r\nsize_t j;\r\nsize_t data_len;\r\nsize_t checksum = 0;\r\nsize_t packet_size_len;\r\nchar *message;\r\nint rc;\r\ndata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\r\n*packet = kmalloc(data_len, GFP_KERNEL);\r\nmessage = *packet;\r\nif (!message) {\r\necryptfs_printk(KERN_ERR, "Unable to allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\r\n&packet_size_len);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 66 packet "\r\n"header; cannot generate packet length\n");\r\ngoto out;\r\n}\r\ni += packet_size_len;\r\nmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\r\ni += ECRYPTFS_SIG_SIZE_HEX;\r\nrc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\r\n&packet_size_len);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 66 packet "\r\n"header; cannot generate packet length\n");\r\ngoto out;\r\n}\r\ni += packet_size_len;\r\nmessage[i++] = cipher_code;\r\nmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\r\ni += crypt_stat->key_size;\r\nfor (j = 0; j < crypt_stat->key_size; j++)\r\nchecksum += crypt_stat->key[j];\r\nmessage[i++] = (checksum / 256) % 256;\r\nmessage[i++] = (checksum % 256);\r\n*packet_len = i;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\r\nstruct ecryptfs_message *msg)\r\n{\r\nsize_t i = 0;\r\nchar *data;\r\nsize_t data_len;\r\nsize_t message_len;\r\nint rc;\r\nmessage_len = msg->data_len;\r\ndata = msg->data;\r\nif (message_len < 4) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: message_len is [%zd]; minimum acceptable "\r\n"message length is [%d]\n", __func__, message_len, 4);\r\ngoto out;\r\n}\r\nif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: Type should be ECRYPTFS_TAG_67\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (data[i++]) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: Status indicator has non zero "\r\n"value [%d]\n", __func__, data[i-1]);\r\ngoto out;\r\n}\r\nrc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\r\n&data_len);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error parsing packet length; "\r\n"rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\ni += data_len;\r\nif (message_len < (i + key_rec->enc_key_size)) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: message_len [%zd]; max len is [%zd]\n",\r\n__func__, message_len, (i + key_rec->enc_key_size));\r\ngoto out;\r\n}\r\nif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\r\nrc = -EIO;\r\nprintk(KERN_ERR "%s: Encrypted key_size [%zd] larger than "\r\n"the maximum key size [%d]\n", __func__,\r\nkey_rec->enc_key_size,\r\nECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\r\ngoto out;\r\n}\r\nmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ecryptfs_verify_version(u16 version)\r\n{\r\nint rc = 0;\r\nunsigned char major;\r\nunsigned char minor;\r\nmajor = ((version >> 8) & 0xFF);\r\nminor = (version & 0xFF);\r\nif (major != ECRYPTFS_VERSION_MAJOR) {\r\necryptfs_printk(KERN_ERR, "Major version number mismatch. "\r\n"Expected [%d]; got [%d]\n",\r\nECRYPTFS_VERSION_MAJOR, major);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (minor != ECRYPTFS_VERSION_MINOR) {\r\necryptfs_printk(KERN_ERR, "Minor version number mismatch. "\r\n"Expected [%d]; got [%d]\n",\r\nECRYPTFS_VERSION_MINOR, minor);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\r\nstruct ecryptfs_auth_tok **auth_tok)\r\n{\r\nint rc = 0;\r\n(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\r\nif (ecryptfs_verify_version((*auth_tok)->version)) {\r\nprintk(KERN_ERR "Data structure version mismatch. Userspace "\r\n"tools must match eCryptfs kernel module with major "\r\n"version [%d] and minor version [%d]\n",\r\nECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\r\n&& (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\r\nprintk(KERN_ERR "Invalid auth_tok structure "\r\n"returned from key query\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_find_global_auth_tok_for_sig(\r\nstruct key **auth_tok_key,\r\nstruct ecryptfs_auth_tok **auth_tok,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\r\n{\r\nstruct ecryptfs_global_auth_tok *walker;\r\nint rc = 0;\r\n(*auth_tok_key) = NULL;\r\n(*auth_tok) = NULL;\r\nmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nlist_for_each_entry(walker,\r\n&mount_crypt_stat->global_auth_tok_list,\r\nmount_crypt_stat_list) {\r\nif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\r\ncontinue;\r\nif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = key_validate(walker->global_auth_tok_key);\r\nif (rc) {\r\nif (rc == -EKEYEXPIRED)\r\ngoto out;\r\ngoto out_invalid_auth_tok;\r\n}\r\ndown_write(&(walker->global_auth_tok_key->sem));\r\nrc = ecryptfs_verify_auth_tok_from_key(\r\nwalker->global_auth_tok_key, auth_tok);\r\nif (rc)\r\ngoto out_invalid_auth_tok_unlock;\r\n(*auth_tok_key) = walker->global_auth_tok_key;\r\nkey_get(*auth_tok_key);\r\ngoto out;\r\n}\r\nrc = -ENOENT;\r\ngoto out;\r\nout_invalid_auth_tok_unlock:\r\nup_write(&(walker->global_auth_tok_key->sem));\r\nout_invalid_auth_tok:\r\nprintk(KERN_WARNING "Invalidating auth tok with sig = [%s]\n", sig);\r\nwalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\r\nkey_put(walker->global_auth_tok_key);\r\nwalker->global_auth_tok_key = NULL;\r\nout:\r\nmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_find_auth_tok_for_sig(\r\nstruct key **auth_tok_key,\r\nstruct ecryptfs_auth_tok **auth_tok,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\r\nchar *sig)\r\n{\r\nint rc = 0;\r\nrc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\r\nmount_crypt_stat, sig);\r\nif (rc == -ENOENT) {\r\nif (mount_crypt_stat->flags\r\n& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\r\nreturn -EINVAL;\r\nrc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\r\nsig);\r\n}\r\nreturn rc;\r\n}\r\nint\r\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\r\nsize_t *packet_size,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\r\nchar *filename, size_t filename_size)\r\n{\r\nstruct ecryptfs_write_tag_70_packet_silly_stack *s;\r\nstruct key *auth_tok_key = NULL;\r\nint rc = 0;\r\ns = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s) {\r\nprintk(KERN_ERR "%s: Out of memory whilst trying to kmalloc "\r\n"[%zd] bytes of kernel memory\n", __func__, sizeof(*s));\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ns->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\n(*packet_size) = 0;\r\nrc = ecryptfs_find_auth_tok_for_sig(\r\n&auth_tok_key,\r\n&s->auth_tok, mount_crypt_stat,\r\nmount_crypt_stat->global_default_fnek_sig);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to find auth tok for "\r\n"fnek sig [%s]; rc = [%d]\n", __func__,\r\nmount_crypt_stat->global_default_fnek_sig, rc);\r\ngoto out;\r\n}\r\nrc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\r\n&s->desc.tfm,\r\n&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "Internal error whilst attempting to get "\r\n"tfm and mutex for cipher name [%s]; rc = [%d]\n",\r\nmount_crypt_stat->global_default_fn_cipher_name, rc);\r\ngoto out;\r\n}\r\nmutex_lock(s->tfm_mutex);\r\ns->block_size = crypto_blkcipher_blocksize(s->desc.tfm);\r\ns->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\r\ns->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\r\nif ((s->block_aligned_filename_size % s->block_size) != 0) {\r\ns->num_rand_bytes += (s->block_size\r\n- (s->block_aligned_filename_size\r\n% s->block_size));\r\ns->block_aligned_filename_size = (s->num_rand_bytes\r\n+ filename_size);\r\n}\r\ns->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\r\n+ s->block_aligned_filename_size);\r\nif (dest == NULL) {\r\n(*packet_size) = s->max_packet_size;\r\ngoto out_unlock;\r\n}\r\nif (s->max_packet_size > (*remaining_bytes)) {\r\nprintk(KERN_WARNING "%s: Require [%zd] bytes to write; only "\r\n"[%zd] available\n", __func__, s->max_packet_size,\r\n(*remaining_bytes));\r\nrc = -EINVAL;\r\ngoto out_unlock;\r\n}\r\ns->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\r\nGFP_KERNEL);\r\nif (!s->block_aligned_filename) {\r\nprintk(KERN_ERR "%s: Out of kernel memory whilst attempting to "\r\n"kzalloc [%zd] bytes\n", __func__,\r\ns->block_aligned_filename_size);\r\nrc = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\ns->i = 0;\r\ndest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&dest[s->i],\r\n(ECRYPTFS_SIG_SIZE\r\n+ 1\r\n+ s->block_aligned_filename_size),\r\n&s->packet_size_len);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error generating tag 70 packet "\r\n"header; cannot generate packet length; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_free_unlock;\r\n}\r\ns->i += s->packet_size_len;\r\necryptfs_from_hex(&dest[s->i],\r\nmount_crypt_stat->global_default_fnek_sig,\r\nECRYPTFS_SIG_SIZE);\r\ns->i += ECRYPTFS_SIG_SIZE;\r\ns->cipher_code = ecryptfs_code_for_cipher_string(\r\nmount_crypt_stat->global_default_fn_cipher_name,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\nif (s->cipher_code == 0) {\r\nprintk(KERN_WARNING "%s: Unable to generate code for "\r\n"cipher [%s] with key bytes [%zd]\n", __func__,\r\nmount_crypt_stat->global_default_fn_cipher_name,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\nrc = -EINVAL;\r\ngoto out_free_unlock;\r\n}\r\ndest[s->i++] = s->cipher_code;\r\nif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\r\nrc = -EOPNOTSUPP;\r\nprintk(KERN_INFO "%s: Filename encryption only supports "\r\n"password tokens\n", __func__);\r\ngoto out_free_unlock;\r\n}\r\nsg_init_one(\r\n&s->hash_sg,\r\n(u8 *)s->auth_tok->token.password.session_key_encryption_key,\r\ns->auth_tok->token.password.session_key_encryption_key_bytes);\r\ns->hash_desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\ns->hash_desc.tfm = crypto_alloc_hash(ECRYPTFS_TAG_70_DIGEST, 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(s->hash_desc.tfm)) {\r\nrc = PTR_ERR(s->hash_desc.tfm);\r\nprintk(KERN_ERR "%s: Error attempting to "\r\n"allocate hash crypto context; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_free_unlock;\r\n}\r\nrc = crypto_hash_init(&s->hash_desc);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error initializing crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = crypto_hash_update(\r\n&s->hash_desc, &s->hash_sg,\r\ns->auth_tok->token.password.session_key_encryption_key_bytes);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error updating crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = crypto_hash_final(&s->hash_desc, s->hash);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error finalizing crypto hash; rc = [%d]\n",\r\n__func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\r\ns->block_aligned_filename[s->j] =\r\ns->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\r\nif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\r\n== (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\r\nsg_init_one(&s->hash_sg, (u8 *)s->hash,\r\nECRYPTFS_TAG_70_DIGEST_SIZE);\r\nrc = crypto_hash_init(&s->hash_desc);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error initializing crypto hash; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = crypto_hash_update(&s->hash_desc, &s->hash_sg,\r\nECRYPTFS_TAG_70_DIGEST_SIZE);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error updating crypto hash; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = crypto_hash_final(&s->hash_desc, s->tmp_hash);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"%s: Error finalizing crypto hash; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\nmemcpy(s->hash, s->tmp_hash,\r\nECRYPTFS_TAG_70_DIGEST_SIZE);\r\n}\r\nif (s->block_aligned_filename[s->j] == '\0')\r\ns->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\r\n}\r\nmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\r\nfilename_size);\r\nrc = virt_to_scatterlist(s->block_aligned_filename,\r\ns->block_aligned_filename_size, s->src_sg, 2);\r\nif (rc < 1) {\r\nprintk(KERN_ERR "%s: Internal error whilst attempting to "\r\n"convert filename memory to scatterlist; rc = [%d]. "\r\n"block_aligned_filename_size = [%zd]\n", __func__, rc,\r\ns->block_aligned_filename_size);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\r\ns->dst_sg, 2);\r\nif (rc < 1) {\r\nprintk(KERN_ERR "%s: Internal error whilst attempting to "\r\n"convert encrypted filename memory to scatterlist; "\r\n"rc = [%d]. block_aligned_filename_size = [%zd]\n",\r\n__func__, rc, s->block_aligned_filename_size);\r\ngoto out_release_free_unlock;\r\n}\r\nmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\r\ns->desc.info = s->iv;\r\nrc = crypto_blkcipher_setkey(\r\ns->desc.tfm,\r\ns->auth_tok->token.password.session_key_encryption_key,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%s: Error setting key for crypto context; "\r\n"rc = [%d]. s->auth_tok->token.password.session_key_"\r\n"encryption_key = [0x%p]; mount_crypt_stat->"\r\n"global_default_fn_cipher_key_bytes = [%zd]\n", __func__,\r\nrc,\r\ns->auth_tok->token.password.session_key_encryption_key,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\ngoto out_release_free_unlock;\r\n}\r\nrc = crypto_blkcipher_encrypt_iv(&s->desc, s->dst_sg, s->src_sg,\r\ns->block_aligned_filename_size);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to encrypt filename; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_release_free_unlock;\r\n}\r\ns->i += s->block_aligned_filename_size;\r\n(*packet_size) = s->i;\r\n(*remaining_bytes) -= (*packet_size);\r\nout_release_free_unlock:\r\ncrypto_free_hash(s->hash_desc.tfm);\r\nout_free_unlock:\r\nkzfree(s->block_aligned_filename);\r\nout_unlock:\r\nmutex_unlock(s->tfm_mutex);\r\nout:\r\nif (auth_tok_key) {\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\n}\r\nkfree(s);\r\nreturn rc;\r\n}\r\nint\r\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\r\nsize_t *packet_size,\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\r\nchar *data, size_t max_packet_size)\r\n{\r\nstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\r\nstruct key *auth_tok_key = NULL;\r\nint rc = 0;\r\n(*packet_size) = 0;\r\n(*filename_size) = 0;\r\n(*filename) = NULL;\r\ns = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s) {\r\nprintk(KERN_ERR "%s: Out of memory whilst trying to kmalloc "\r\n"[%zd] bytes of kernel memory\n", __func__, sizeof(*s));\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ns->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\r\nprintk(KERN_WARNING "%s: max_packet_size is [%zd]; it must be "\r\n"at least [%d]\n", __func__, max_packet_size,\r\nECRYPTFS_TAG_70_MIN_METADATA_SIZE);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\r\nprintk(KERN_WARNING "%s: Invalid packet tag [0x%.2x]; must be "\r\n"tag [0x%.2x]\n", __func__,\r\ndata[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = ecryptfs_parse_packet_length(&data[(*packet_size)],\r\n&s->parsed_tag_70_packet_size,\r\n&s->packet_size_len);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s: Error parsing packet length; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out;\r\n}\r\ns->block_aligned_filename_size = (s->parsed_tag_70_packet_size\r\n- ECRYPTFS_SIG_SIZE - 1);\r\nif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\r\n> max_packet_size) {\r\nprintk(KERN_WARNING "%s: max_packet_size is [%zd]; real packet "\r\n"size is [%zd]\n", __func__, max_packet_size,\r\n(1 + s->packet_size_len + 1\r\n+ s->block_aligned_filename_size));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n(*packet_size) += s->packet_size_len;\r\necryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\r\nECRYPTFS_SIG_SIZE);\r\ns->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\0';\r\n(*packet_size) += ECRYPTFS_SIG_SIZE;\r\ns->cipher_code = data[(*packet_size)++];\r\nrc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\r\nif (rc) {\r\nprintk(KERN_WARNING "%s: Cipher code [%d] is invalid\n",\r\n__func__, s->cipher_code);\r\ngoto out;\r\n}\r\nrc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\r\n&s->auth_tok, mount_crypt_stat,\r\ns->fnek_sig_hex);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to find auth tok for "\r\n"fnek sig [%s]; rc = [%d]\n", __func__, s->fnek_sig_hex,\r\nrc);\r\ngoto out;\r\n}\r\nrc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,\r\n&s->tfm_mutex,\r\ns->cipher_string);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "Internal error whilst attempting to get "\r\n"tfm and mutex for cipher name [%s]; rc = [%d]\n",\r\ns->cipher_string, rc);\r\ngoto out;\r\n}\r\nmutex_lock(s->tfm_mutex);\r\nrc = virt_to_scatterlist(&data[(*packet_size)],\r\ns->block_aligned_filename_size, s->src_sg, 2);\r\nif (rc < 1) {\r\nprintk(KERN_ERR "%s: Internal error whilst attempting to "\r\n"convert encrypted filename memory to scatterlist; "\r\n"rc = [%d]. block_aligned_filename_size = [%zd]\n",\r\n__func__, rc, s->block_aligned_filename_size);\r\ngoto out_unlock;\r\n}\r\n(*packet_size) += s->block_aligned_filename_size;\r\ns->decrypted_filename = kmalloc(s->block_aligned_filename_size,\r\nGFP_KERNEL);\r\nif (!s->decrypted_filename) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting to "\r\n"kmalloc [%zd] bytes\n", __func__,\r\ns->block_aligned_filename_size);\r\nrc = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nrc = virt_to_scatterlist(s->decrypted_filename,\r\ns->block_aligned_filename_size, s->dst_sg, 2);\r\nif (rc < 1) {\r\nprintk(KERN_ERR "%s: Internal error whilst attempting to "\r\n"convert decrypted filename memory to scatterlist; "\r\n"rc = [%d]. block_aligned_filename_size = [%zd]\n",\r\n__func__, rc, s->block_aligned_filename_size);\r\ngoto out_free_unlock;\r\n}\r\nmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\r\ns->desc.info = s->iv;\r\nif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\r\nrc = -EOPNOTSUPP;\r\nprintk(KERN_INFO "%s: Filename encryption only supports "\r\n"password tokens\n", __func__);\r\ngoto out_free_unlock;\r\n}\r\nrc = crypto_blkcipher_setkey(\r\ns->desc.tfm,\r\ns->auth_tok->token.password.session_key_encryption_key,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "%s: Error setting key for crypto context; "\r\n"rc = [%d]. s->auth_tok->token.password.session_key_"\r\n"encryption_key = [0x%p]; mount_crypt_stat->"\r\n"global_default_fn_cipher_key_bytes = [%zd]\n", __func__,\r\nrc,\r\ns->auth_tok->token.password.session_key_encryption_key,\r\nmount_crypt_stat->global_default_fn_cipher_key_bytes);\r\ngoto out_free_unlock;\r\n}\r\nrc = crypto_blkcipher_decrypt_iv(&s->desc, s->dst_sg, s->src_sg,\r\ns->block_aligned_filename_size);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: Error attempting to decrypt filename; "\r\n"rc = [%d]\n", __func__, rc);\r\ngoto out_free_unlock;\r\n}\r\ns->i = 0;\r\nwhile (s->decrypted_filename[s->i] != '\0'\r\n&& s->i < s->block_aligned_filename_size)\r\ns->i++;\r\nif (s->i == s->block_aligned_filename_size) {\r\nprintk(KERN_WARNING "%s: Invalid tag 70 packet; could not "\r\n"find valid separator between random characters and "\r\n"the filename\n", __func__);\r\nrc = -EINVAL;\r\ngoto out_free_unlock;\r\n}\r\ns->i++;\r\n(*filename_size) = (s->block_aligned_filename_size - s->i);\r\nif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\r\nprintk(KERN_WARNING "%s: Filename size is [%zd], which is "\r\n"invalid\n", __func__, (*filename_size));\r\nrc = -EINVAL;\r\ngoto out_free_unlock;\r\n}\r\n(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\r\nif (!(*filename)) {\r\nprintk(KERN_ERR "%s: Out of memory whilst attempting to "\r\n"kmalloc [%zd] bytes\n", __func__,\r\n((*filename_size) + 1));\r\nrc = -ENOMEM;\r\ngoto out_free_unlock;\r\n}\r\nmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\r\n(*filename)[(*filename_size)] = '\0';\r\nout_free_unlock:\r\nkfree(s->decrypted_filename);\r\nout_unlock:\r\nmutex_unlock(s->tfm_mutex);\r\nout:\r\nif (rc) {\r\n(*packet_size) = 0;\r\n(*filename_size) = 0;\r\n(*filename) = NULL;\r\n}\r\nif (auth_tok_key) {\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\n}\r\nkfree(s);\r\nreturn rc;\r\n}\r\nstatic int\r\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\r\n{\r\nint rc = 0;\r\n(*sig) = NULL;\r\nswitch (auth_tok->token_type) {\r\ncase ECRYPTFS_PASSWORD:\r\n(*sig) = auth_tok->token.password.signature;\r\nbreak;\r\ncase ECRYPTFS_PRIVATE_KEY:\r\n(*sig) = auth_tok->token.private_key.signature;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Cannot get sig for auth_tok of type [%d]\n",\r\nauth_tok->token_type);\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\r\nstruct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nu8 cipher_code = 0;\r\nstruct ecryptfs_msg_ctx *msg_ctx;\r\nstruct ecryptfs_message *msg = NULL;\r\nchar *auth_tok_sig;\r\nchar *payload = NULL;\r\nsize_t payload_len = 0;\r\nint rc;\r\nrc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\r\nif (rc) {\r\nprintk(KERN_ERR "Unrecognized auth tok type: [%d]\n",\r\nauth_tok->token_type);\r\ngoto out;\r\n}\r\nrc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\r\n&payload, &payload_len);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Failed to write tag 64 packet\n");\r\ngoto out;\r\n}\r\nrc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error sending message to "\r\n"ecryptfsd: %d\n", rc);\r\ngoto out;\r\n}\r\nrc = ecryptfs_wait_for_response(msg_ctx, &msg);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Failed to receive tag 65 packet "\r\n"from the user space daemon\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nrc = parse_tag_65_packet(&(auth_tok->session_key),\r\n&cipher_code, msg);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to parse tag 65 packet; rc = [%d]\n",\r\nrc);\r\ngoto out;\r\n}\r\nauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\r\nmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\r\nauth_tok->session_key.decrypted_key_size);\r\ncrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\r\nrc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Cipher code [%d] is invalid\n",\r\ncipher_code)\r\ngoto out;\r\n}\r\ncrypt_stat->flags |= ECRYPTFS_KEY_VALID;\r\nif (ecryptfs_verbosity > 0) {\r\necryptfs_printk(KERN_DEBUG, "Decrypted session key:\n");\r\necryptfs_dump_hex(crypt_stat->key,\r\ncrypt_stat->key_size);\r\n}\r\nout:\r\nkfree(msg);\r\nkfree(payload);\r\nreturn rc;\r\n}\r\nstatic void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\r\n{\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\r\nlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\r\nauth_tok_list_head, list) {\r\nlist_del(&auth_tok_list_item->list);\r\nkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\r\nauth_tok_list_item);\r\n}\r\n}\r\nstatic int\r\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\r\nunsigned char *data, struct list_head *auth_tok_list,\r\nstruct ecryptfs_auth_tok **new_auth_tok,\r\nsize_t *packet_size, size_t max_packet_size)\r\n{\r\nsize_t body_size;\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\r\nsize_t length_size;\r\nint rc = 0;\r\n(*packet_size) = 0;\r\n(*new_auth_tok) = NULL;\r\nif (unlikely(max_packet_size < 12)) {\r\nprintk(KERN_ERR "Invalid max packet size; must be >=12\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\r\nprintk(KERN_ERR "Enter w/ first byte != 0x%.2x\n",\r\nECRYPTFS_TAG_1_PACKET_TYPE);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nauth_tok_list_item =\r\nkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\r\nGFP_KERNEL);\r\nif (!auth_tok_list_item) {\r\nprintk(KERN_ERR "Unable to allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n(*new_auth_tok) = &auth_tok_list_item->auth_tok;\r\nrc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\r\n&length_size);\r\nif (rc) {\r\nprintk(KERN_WARNING "Error parsing packet length; "\r\n"rc = [%d]\n", rc);\r\ngoto out_free;\r\n}\r\nif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\r\nprintk(KERN_WARNING "Invalid body size ([%td])\n", body_size);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\n(*packet_size) += length_size;\r\nif (unlikely((*packet_size) + body_size > max_packet_size)) {\r\nprintk(KERN_WARNING "Packet size exceeds max\n");\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (unlikely(data[(*packet_size)++] != 0x03)) {\r\nprintk(KERN_WARNING "Unknown version number [%d]\n",\r\ndata[(*packet_size) - 1]);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\necryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\r\n&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\r\n*packet_size += ECRYPTFS_SIG_SIZE;\r\n(*packet_size)++;\r\n(*new_auth_tok)->session_key.encrypted_key_size =\r\nbody_size - (ECRYPTFS_SIG_SIZE + 2);\r\nif ((*new_auth_tok)->session_key.encrypted_key_size\r\n> ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\r\nprintk(KERN_WARNING "Tag 1 packet contains key larger "\r\n"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy((*new_auth_tok)->session_key.encrypted_key,\r\n&data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\r\n(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\r\n(*new_auth_tok)->session_key.flags &=\r\n~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\r\n(*new_auth_tok)->session_key.flags |=\r\nECRYPTFS_CONTAINS_ENCRYPTED_KEY;\r\n(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\r\n(*new_auth_tok)->flags = 0;\r\n(*new_auth_tok)->session_key.flags &=\r\n~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\r\n(*new_auth_tok)->session_key.flags &=\r\n~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\r\nlist_add(&auth_tok_list_item->list, auth_tok_list);\r\ngoto out;\r\nout_free:\r\n(*new_auth_tok) = NULL;\r\nmemset(auth_tok_list_item, 0,\r\nsizeof(struct ecryptfs_auth_tok_list_item));\r\nkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\r\nauth_tok_list_item);\r\nout:\r\nif (rc)\r\n(*packet_size) = 0;\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\r\nunsigned char *data, struct list_head *auth_tok_list,\r\nstruct ecryptfs_auth_tok **new_auth_tok,\r\nsize_t *packet_size, size_t max_packet_size)\r\n{\r\nsize_t body_size;\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\r\nsize_t length_size;\r\nint rc = 0;\r\n(*packet_size) = 0;\r\n(*new_auth_tok) = NULL;\r\nif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\r\nprintk(KERN_ERR "Max packet size too large\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\r\nprintk(KERN_ERR "First byte != 0x%.2x; invalid packet\n",\r\nECRYPTFS_TAG_3_PACKET_TYPE);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nauth_tok_list_item =\r\nkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\r\nif (!auth_tok_list_item) {\r\nprintk(KERN_ERR "Unable to allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n(*new_auth_tok) = &auth_tok_list_item->auth_tok;\r\nrc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\r\n&length_size);\r\nif (rc) {\r\nprintk(KERN_WARNING "Error parsing packet length; rc = [%d]\n",\r\nrc);\r\ngoto out_free;\r\n}\r\nif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\r\nprintk(KERN_WARNING "Invalid body size ([%td])\n", body_size);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\n(*packet_size) += length_size;\r\nif (unlikely((*packet_size) + body_size > max_packet_size)) {\r\nprintk(KERN_ERR "Packet size exceeds max\n");\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\n(*new_auth_tok)->session_key.encrypted_key_size =\r\n(body_size - (ECRYPTFS_SALT_SIZE + 5));\r\nif ((*new_auth_tok)->session_key.encrypted_key_size\r\n> ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\r\nprintk(KERN_WARNING "Tag 3 packet contains key larger "\r\n"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\n");\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nif (unlikely(data[(*packet_size)++] != 0x04)) {\r\nprintk(KERN_WARNING "Unknown version number [%d]\n",\r\ndata[(*packet_size) - 1]);\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nrc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\r\n(u16)data[(*packet_size)]);\r\nif (rc)\r\ngoto out_free;\r\nswitch(data[(*packet_size)++]) {\r\ncase RFC2440_CIPHER_AES_192:\r\ncrypt_stat->key_size = 24;\r\nbreak;\r\ndefault:\r\ncrypt_stat->key_size =\r\n(*new_auth_tok)->session_key.encrypted_key_size;\r\n}\r\nrc = ecryptfs_init_crypt_ctx(crypt_stat);\r\nif (rc)\r\ngoto out_free;\r\nif (unlikely(data[(*packet_size)++] != 0x03)) {\r\nprintk(KERN_WARNING "Only S2K ID 3 is currently supported\n");\r\nrc = -ENOSYS;\r\ngoto out_free;\r\n}\r\nswitch (data[(*packet_size)++]) {\r\ncase 0x01:\r\nmemcpy((*new_auth_tok)->token.password.salt,\r\n&data[(*packet_size)], ECRYPTFS_SALT_SIZE);\r\n(*packet_size) += ECRYPTFS_SALT_SIZE;\r\n(*new_auth_tok)->token.password.hash_iterations =\r\n((u32) 16 + (data[(*packet_size)] & 15))\r\n<< ((data[(*packet_size)] >> 4) + 6);\r\n(*packet_size)++;\r\nmemcpy((*new_auth_tok)->session_key.encrypted_key,\r\n&data[(*packet_size)],\r\n(*new_auth_tok)->session_key.encrypted_key_size);\r\n(*packet_size) +=\r\n(*new_auth_tok)->session_key.encrypted_key_size;\r\n(*new_auth_tok)->session_key.flags &=\r\n~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\r\n(*new_auth_tok)->session_key.flags |=\r\nECRYPTFS_CONTAINS_ENCRYPTED_KEY;\r\n(*new_auth_tok)->token.password.hash_algo = 0x01;\r\nbreak;\r\ndefault:\r\necryptfs_printk(KERN_ERR, "Unsupported hash algorithm: "\r\n"[%d]\n", data[(*packet_size) - 1]);\r\nrc = -ENOSYS;\r\ngoto out_free;\r\n}\r\n(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\r\n(*new_auth_tok)->session_key.flags &=\r\n~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\r\n(*new_auth_tok)->session_key.flags &=\r\n~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\r\nlist_add(&auth_tok_list_item->list, auth_tok_list);\r\ngoto out;\r\nout_free:\r\n(*new_auth_tok) = NULL;\r\nmemset(auth_tok_list_item, 0,\r\nsizeof(struct ecryptfs_auth_tok_list_item));\r\nkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\r\nauth_tok_list_item);\r\nout:\r\nif (rc)\r\n(*packet_size) = 0;\r\nreturn rc;\r\n}\r\nstatic int\r\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\r\nsize_t max_contents_bytes, size_t *tag_11_contents_size,\r\nsize_t *packet_size, size_t max_packet_size)\r\n{\r\nsize_t body_size;\r\nsize_t length_size;\r\nint rc = 0;\r\n(*packet_size) = 0;\r\n(*tag_11_contents_size) = 0;\r\nif (max_packet_size < 16) {\r\nprintk(KERN_ERR "Maximum packet size too small\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\r\nprintk(KERN_WARNING "Invalid tag 11 packet format\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\r\n&length_size);\r\nif (rc) {\r\nprintk(KERN_WARNING "Invalid tag 11 packet format\n");\r\ngoto out;\r\n}\r\nif (body_size < 14) {\r\nprintk(KERN_WARNING "Invalid body size ([%td])\n", body_size);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n(*packet_size) += length_size;\r\n(*tag_11_contents_size) = (body_size - 14);\r\nif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\r\nprintk(KERN_ERR "Packet size exceeds max\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\r\nprintk(KERN_ERR "Literal data section in tag 11 packet exceeds "\r\n"expected size\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != 0x62) {\r\nprintk(KERN_WARNING "Unrecognizable packet\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (data[(*packet_size)++] != 0x08) {\r\nprintk(KERN_WARNING "Unrecognizable packet\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n(*packet_size) += 12;\r\nmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\r\n(*packet_size) += (*tag_11_contents_size);\r\nout:\r\nif (rc) {\r\n(*packet_size) = 0;\r\n(*tag_11_contents_size) = 0;\r\n}\r\nreturn rc;\r\n}\r\nint ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\r\nstruct ecryptfs_auth_tok **auth_tok,\r\nchar *sig)\r\n{\r\nint rc = 0;\r\n(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\r\nif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\r\n(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\r\nif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\r\nprintk(KERN_ERR "Could not find key with description: [%s]\n",\r\nsig);\r\nrc = process_request_key_err(PTR_ERR(*auth_tok_key));\r\n(*auth_tok_key) = NULL;\r\ngoto out;\r\n}\r\n}\r\ndown_write(&(*auth_tok_key)->sem);\r\nrc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\r\nif (rc) {\r\nup_write(&(*auth_tok_key)->sem);\r\nkey_put(*auth_tok_key);\r\n(*auth_tok_key) = NULL;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\r\nstruct ecryptfs_crypt_stat *crypt_stat)\r\n{\r\nstruct scatterlist dst_sg[2];\r\nstruct scatterlist src_sg[2];\r\nstruct mutex *tfm_mutex;\r\nstruct blkcipher_desc desc = {\r\n.flags = CRYPTO_TFM_REQ_MAY_SLEEP\r\n};\r\nint rc = 0;\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(\r\nKERN_DEBUG, "Session key encryption key (size [%d]):\n",\r\nauth_tok->token.password.session_key_encryption_key_bytes);\r\necryptfs_dump_hex(\r\nauth_tok->token.password.session_key_encryption_key,\r\nauth_tok->token.password.session_key_encryption_key_bytes);\r\n}\r\nrc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\r\ncrypt_stat->cipher);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "Internal error whilst attempting to get "\r\n"tfm and mutex for cipher name [%s]; rc = [%d]\n",\r\ncrypt_stat->cipher, rc);\r\ngoto out;\r\n}\r\nrc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\r\nauth_tok->session_key.encrypted_key_size,\r\nsrc_sg, 2);\r\nif (rc < 1 || rc > 2) {\r\nprintk(KERN_ERR "Internal error whilst attempting to convert "\r\n"auth_tok->session_key.encrypted_key to scatterlist; "\r\n"expected rc = 1; got rc = [%d]. "\r\n"auth_tok->session_key.encrypted_key_size = [%d]\n", rc,\r\nauth_tok->session_key.encrypted_key_size);\r\ngoto out;\r\n}\r\nauth_tok->session_key.decrypted_key_size =\r\nauth_tok->session_key.encrypted_key_size;\r\nrc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\r\nauth_tok->session_key.decrypted_key_size,\r\ndst_sg, 2);\r\nif (rc < 1 || rc > 2) {\r\nprintk(KERN_ERR "Internal error whilst attempting to convert "\r\n"auth_tok->session_key.decrypted_key to scatterlist; "\r\n"expected rc = 1; got rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\nmutex_lock(tfm_mutex);\r\nrc = crypto_blkcipher_setkey(\r\ndesc.tfm, auth_tok->token.password.session_key_encryption_key,\r\ncrypt_stat->key_size);\r\nif (unlikely(rc < 0)) {\r\nmutex_unlock(tfm_mutex);\r\nprintk(KERN_ERR "Error setting key for crypto context\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,\r\nauth_tok->session_key.encrypted_key_size);\r\nmutex_unlock(tfm_mutex);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "Error decrypting; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\nauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\r\nmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\r\nauth_tok->session_key.decrypted_key_size);\r\ncrypt_stat->flags |= ECRYPTFS_KEY_VALID;\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "FEK of size [%zd]:\n",\r\ncrypt_stat->key_size);\r\necryptfs_dump_hex(crypt_stat->key,\r\ncrypt_stat->key_size);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\r\nunsigned char *src,\r\nstruct dentry *ecryptfs_dentry)\r\n{\r\nsize_t i = 0;\r\nsize_t found_auth_tok;\r\nsize_t next_packet_is_auth_tok_packet;\r\nstruct list_head auth_tok_list;\r\nstruct ecryptfs_auth_tok *matching_auth_tok;\r\nstruct ecryptfs_auth_tok *candidate_auth_tok;\r\nchar *candidate_auth_tok_sig;\r\nsize_t packet_size;\r\nstruct ecryptfs_auth_tok *new_auth_tok;\r\nunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\r\nsize_t tag_11_contents_size;\r\nsize_t tag_11_packet_size;\r\nstruct key *auth_tok_key = NULL;\r\nint rc = 0;\r\nINIT_LIST_HEAD(&auth_tok_list);\r\nnext_packet_is_auth_tok_packet = 1;\r\nwhile (next_packet_is_auth_tok_packet) {\r\nsize_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);\r\nswitch (src[i]) {\r\ncase ECRYPTFS_TAG_3_PACKET_TYPE:\r\nrc = parse_tag_3_packet(crypt_stat,\r\n(unsigned char *)&src[i],\r\n&auth_tok_list, &new_auth_tok,\r\n&packet_size, max_packet_size);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error parsing "\r\n"tag 3 packet\n");\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\n}\r\ni += packet_size;\r\nrc = parse_tag_11_packet((unsigned char *)&src[i],\r\nsig_tmp_space,\r\nECRYPTFS_SIG_SIZE,\r\n&tag_11_contents_size,\r\n&tag_11_packet_size,\r\nmax_packet_size);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "No valid "\r\n"(ecryptfs-specific) literal "\r\n"packet containing "\r\n"authentication token "\r\n"signature found after "\r\n"tag 3 packet\n");\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\n}\r\ni += tag_11_packet_size;\r\nif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\r\necryptfs_printk(KERN_ERR, "Expected "\r\n"signature of size [%d]; "\r\n"read size [%zd]\n",\r\nECRYPTFS_SIG_SIZE,\r\ntag_11_contents_size);\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\n}\r\necryptfs_to_hex(new_auth_tok->token.password.signature,\r\nsig_tmp_space, tag_11_contents_size);\r\nnew_auth_tok->token.password.signature[\r\nECRYPTFS_PASSWORD_SIG_SIZE] = '\0';\r\ncrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\r\nbreak;\r\ncase ECRYPTFS_TAG_1_PACKET_TYPE:\r\nrc = parse_tag_1_packet(crypt_stat,\r\n(unsigned char *)&src[i],\r\n&auth_tok_list, &new_auth_tok,\r\n&packet_size, max_packet_size);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error parsing "\r\n"tag 1 packet\n");\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\n}\r\ni += packet_size;\r\ncrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\r\nbreak;\r\ncase ECRYPTFS_TAG_11_PACKET_TYPE:\r\necryptfs_printk(KERN_WARNING, "Invalid packet set "\r\n"(Tag 11 not allowed by itself)\n");\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\nbreak;\r\ndefault:\r\necryptfs_printk(KERN_DEBUG, "No packet at offset [%zd] "\r\n"of the file header; hex value of "\r\n"character is [0x%.2x]\n", i, src[i]);\r\nnext_packet_is_auth_tok_packet = 0;\r\n}\r\n}\r\nif (list_empty(&auth_tok_list)) {\r\nprintk(KERN_ERR "The lower file appears to be a non-encrypted "\r\n"eCryptfs file; this is not supported in this version "\r\n"of the eCryptfs kernel module\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfind_next_matching_auth_tok:\r\nfound_auth_tok = 0;\r\nlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\r\ncandidate_auth_tok = &auth_tok_list_item->auth_tok;\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG,\r\n"Considering cadidate auth tok:\n");\r\necryptfs_dump_auth_tok(candidate_auth_tok);\r\n}\r\nrc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\r\ncandidate_auth_tok);\r\nif (rc) {\r\nprintk(KERN_ERR\r\n"Unrecognized candidate auth tok type: [%d]\n",\r\ncandidate_auth_tok->token_type);\r\nrc = -EINVAL;\r\ngoto out_wipe_list;\r\n}\r\nrc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\r\n&matching_auth_tok,\r\ncrypt_stat->mount_crypt_stat,\r\ncandidate_auth_tok_sig);\r\nif (!rc) {\r\nfound_auth_tok = 1;\r\ngoto found_matching_auth_tok;\r\n}\r\n}\r\nif (!found_auth_tok) {\r\necryptfs_printk(KERN_ERR, "Could not find a usable "\r\n"authentication token\n");\r\nrc = -EIO;\r\ngoto out_wipe_list;\r\n}\r\nfound_matching_auth_tok:\r\nif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\r\nmemcpy(&(candidate_auth_tok->token.private_key),\r\n&(matching_auth_tok->token.private_key),\r\nsizeof(struct ecryptfs_private_key));\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\nrc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\r\ncrypt_stat);\r\n} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\r\nmemcpy(&(candidate_auth_tok->token.password),\r\n&(matching_auth_tok->token.password),\r\nsizeof(struct ecryptfs_password));\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\nrc = decrypt_passphrase_encrypted_session_key(\r\ncandidate_auth_tok, crypt_stat);\r\n} else {\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\nrc = -EINVAL;\r\n}\r\nif (rc) {\r\nstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\r\necryptfs_printk(KERN_WARNING, "Error decrypting the "\r\n"session key for authentication token with sig "\r\n"[%.*s]; rc = [%d]. Removing auth tok "\r\n"candidate from the list and searching for "\r\n"the next match.\n", ECRYPTFS_SIG_SIZE_HEX,\r\ncandidate_auth_tok_sig, rc);\r\nlist_for_each_entry_safe(auth_tok_list_item,\r\nauth_tok_list_item_tmp,\r\n&auth_tok_list, list) {\r\nif (candidate_auth_tok\r\n== &auth_tok_list_item->auth_tok) {\r\nlist_del(&auth_tok_list_item->list);\r\nkmem_cache_free(\r\necryptfs_auth_tok_list_item_cache,\r\nauth_tok_list_item);\r\ngoto find_next_matching_auth_tok;\r\n}\r\n}\r\nBUG();\r\n}\r\nrc = ecryptfs_compute_root_iv(crypt_stat);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error computing "\r\n"the root IV\n");\r\ngoto out_wipe_list;\r\n}\r\nrc = ecryptfs_init_crypt_ctx(crypt_stat);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error initializing crypto "\r\n"context for cipher [%s]; rc = [%d]\n",\r\ncrypt_stat->cipher, rc);\r\n}\r\nout_wipe_list:\r\nwipe_auth_tok_list(&auth_tok_list);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\npki_encrypt_session_key(struct key *auth_tok_key,\r\nstruct ecryptfs_auth_tok *auth_tok,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_key_record *key_rec)\r\n{\r\nstruct ecryptfs_msg_ctx *msg_ctx = NULL;\r\nchar *payload = NULL;\r\nsize_t payload_len = 0;\r\nstruct ecryptfs_message *msg;\r\nint rc;\r\nrc = write_tag_66_packet(auth_tok->token.private_key.signature,\r\necryptfs_code_for_cipher_string(\r\ncrypt_stat->cipher,\r\ncrypt_stat->key_size),\r\ncrypt_stat, &payload, &payload_len);\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 66 packet\n");\r\ngoto out;\r\n}\r\nrc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error sending message to "\r\n"ecryptfsd: %d\n", rc);\r\ngoto out;\r\n}\r\nrc = ecryptfs_wait_for_response(msg_ctx, &msg);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Failed to receive tag 67 packet "\r\n"from the user space daemon\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nrc = parse_tag_67_packet(key_rec, msg);\r\nif (rc)\r\necryptfs_printk(KERN_ERR, "Error parsing tag 67 packet\n");\r\nkfree(msg);\r\nout:\r\nkfree(payload);\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\r\nstruct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_key_record *key_rec, size_t *packet_size)\r\n{\r\nsize_t i;\r\nsize_t encrypted_session_key_valid = 0;\r\nsize_t packet_size_length;\r\nsize_t max_packet_size;\r\nint rc = 0;\r\n(*packet_size) = 0;\r\necryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\r\nECRYPTFS_SIG_SIZE);\r\nencrypted_session_key_valid = 0;\r\nfor (i = 0; i < crypt_stat->key_size; i++)\r\nencrypted_session_key_valid |=\r\nauth_tok->session_key.encrypted_key[i];\r\nif (encrypted_session_key_valid) {\r\nmemcpy(key_rec->enc_key,\r\nauth_tok->session_key.encrypted_key,\r\nauth_tok->session_key.encrypted_key_size);\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\ngoto encrypted_session_key_set;\r\n}\r\nif (auth_tok->session_key.encrypted_key_size == 0)\r\nauth_tok->session_key.encrypted_key_size =\r\nauth_tok->token.private_key.key_size;\r\nrc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\r\nkey_rec);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to encrypt session key via a key "\r\n"module; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\nif (ecryptfs_verbosity > 0) {\r\necryptfs_printk(KERN_DEBUG, "Encrypted key:\n");\r\necryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\r\n}\r\nencrypted_session_key_set:\r\nmax_packet_size = (1\r\n+ 3\r\n+ 1\r\n+ ECRYPTFS_SIG_SIZE\r\n+ 1\r\n+ key_rec->enc_key_size);\r\nif (max_packet_size > (*remaining_bytes)) {\r\nprintk(KERN_ERR "Packet length larger than maximum allowable; "\r\n"need up to [%td] bytes, but there are only [%td] "\r\n"available\n", max_packet_size, (*remaining_bytes));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&dest[(*packet_size)],\r\n(max_packet_size - 4),\r\n&packet_size_length);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error generating tag 1 packet "\r\n"header; cannot generate packet length\n");\r\ngoto out;\r\n}\r\n(*packet_size) += packet_size_length;\r\ndest[(*packet_size)++] = 0x03;\r\nmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\r\n(*packet_size) += ECRYPTFS_SIG_SIZE;\r\ndest[(*packet_size)++] = RFC2440_CIPHER_RSA;\r\nmemcpy(&dest[(*packet_size)], key_rec->enc_key,\r\nkey_rec->enc_key_size);\r\n(*packet_size) += key_rec->enc_key_size;\r\nout:\r\nif (rc)\r\n(*packet_size) = 0;\r\nelse\r\n(*remaining_bytes) -= (*packet_size);\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\r\nsize_t contents_length, size_t *packet_length)\r\n{\r\nsize_t packet_size_length;\r\nsize_t max_packet_size;\r\nint rc = 0;\r\n(*packet_length) = 0;\r\nmax_packet_size = (1\r\n+ 3\r\n+ 1\r\n+ 1\r\n+ 8\r\n+ 4\r\n+ contents_length);\r\nif (max_packet_size > (*remaining_bytes)) {\r\nprintk(KERN_ERR "Packet length larger than maximum allowable; "\r\n"need up to [%td] bytes, but there are only [%td] "\r\n"available\n", max_packet_size, (*remaining_bytes));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&dest[(*packet_length)],\r\n(max_packet_size - 4),\r\n&packet_size_length);\r\nif (rc) {\r\nprintk(KERN_ERR "Error generating tag 11 packet header; cannot "\r\n"generate packet length. rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\n(*packet_length) += packet_size_length;\r\ndest[(*packet_length)++] = 0x62;\r\ndest[(*packet_length)++] = 8;\r\nmemcpy(&dest[(*packet_length)], "_CONSOLE", 8);\r\n(*packet_length) += 8;\r\nmemset(&dest[(*packet_length)], 0x00, 4);\r\n(*packet_length) += 4;\r\nmemcpy(&dest[(*packet_length)], contents, contents_length);\r\n(*packet_length) += contents_length;\r\nout:\r\nif (rc)\r\n(*packet_length) = 0;\r\nelse\r\n(*remaining_bytes) -= (*packet_length);\r\nreturn rc;\r\n}\r\nstatic int\r\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\r\nstruct ecryptfs_auth_tok *auth_tok,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct ecryptfs_key_record *key_rec, size_t *packet_size)\r\n{\r\nsize_t i;\r\nsize_t encrypted_session_key_valid = 0;\r\nchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\r\nstruct scatterlist dst_sg[2];\r\nstruct scatterlist src_sg[2];\r\nstruct mutex *tfm_mutex = NULL;\r\nu8 cipher_code;\r\nsize_t packet_size_length;\r\nsize_t max_packet_size;\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\r\ncrypt_stat->mount_crypt_stat;\r\nstruct blkcipher_desc desc = {\r\n.tfm = NULL,\r\n.flags = CRYPTO_TFM_REQ_MAY_SLEEP\r\n};\r\nint rc = 0;\r\n(*packet_size) = 0;\r\necryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\r\nECRYPTFS_SIG_SIZE);\r\nrc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\r\ncrypt_stat->cipher);\r\nif (unlikely(rc)) {\r\nprintk(KERN_ERR "Internal error whilst attempting to get "\r\n"tfm and mutex for cipher name [%s]; rc = [%d]\n",\r\ncrypt_stat->cipher, rc);\r\ngoto out;\r\n}\r\nif (mount_crypt_stat->global_default_cipher_key_size == 0) {\r\nstruct blkcipher_alg *alg = crypto_blkcipher_alg(desc.tfm);\r\nprintk(KERN_WARNING "No key size specified at mount; "\r\n"defaulting to [%d]\n", alg->max_keysize);\r\nmount_crypt_stat->global_default_cipher_key_size =\r\nalg->max_keysize;\r\n}\r\nif (crypt_stat->key_size == 0)\r\ncrypt_stat->key_size =\r\nmount_crypt_stat->global_default_cipher_key_size;\r\nif (auth_tok->session_key.encrypted_key_size == 0)\r\nauth_tok->session_key.encrypted_key_size =\r\ncrypt_stat->key_size;\r\nif (crypt_stat->key_size == 24\r\n&& strcmp("aes", crypt_stat->cipher) == 0) {\r\nmemset((crypt_stat->key + 24), 0, 8);\r\nauth_tok->session_key.encrypted_key_size = 32;\r\n} else\r\nauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\r\nkey_rec->enc_key_size =\r\nauth_tok->session_key.encrypted_key_size;\r\nencrypted_session_key_valid = 0;\r\nfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\r\nencrypted_session_key_valid |=\r\nauth_tok->session_key.encrypted_key[i];\r\nif (encrypted_session_key_valid) {\r\necryptfs_printk(KERN_DEBUG, "encrypted_session_key_valid != 0; "\r\n"using auth_tok->session_key.encrypted_key, "\r\n"where key_rec->enc_key_size = [%zd]\n",\r\nkey_rec->enc_key_size);\r\nmemcpy(key_rec->enc_key,\r\nauth_tok->session_key.encrypted_key,\r\nkey_rec->enc_key_size);\r\ngoto encrypted_session_key_set;\r\n}\r\nif (auth_tok->token.password.flags &\r\nECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\r\necryptfs_printk(KERN_DEBUG, "Using previously generated "\r\n"session key encryption key of size [%d]\n",\r\nauth_tok->token.password.\r\nsession_key_encryption_key_bytes);\r\nmemcpy(session_key_encryption_key,\r\nauth_tok->token.password.session_key_encryption_key,\r\ncrypt_stat->key_size);\r\necryptfs_printk(KERN_DEBUG,\r\n"Cached session key encryption key:\n");\r\nif (ecryptfs_verbosity > 0)\r\necryptfs_dump_hex(session_key_encryption_key, 16);\r\n}\r\nif (unlikely(ecryptfs_verbosity > 0)) {\r\necryptfs_printk(KERN_DEBUG, "Session key encryption key:\n");\r\necryptfs_dump_hex(session_key_encryption_key, 16);\r\n}\r\nrc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\r\nsrc_sg, 2);\r\nif (rc < 1 || rc > 2) {\r\necryptfs_printk(KERN_ERR, "Error generating scatterlist "\r\n"for crypt_stat session key; expected rc = 1; "\r\n"got rc = [%d]. key_rec->enc_key_size = [%zd]\n",\r\nrc, key_rec->enc_key_size);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\r\ndst_sg, 2);\r\nif (rc < 1 || rc > 2) {\r\necryptfs_printk(KERN_ERR, "Error generating scatterlist "\r\n"for crypt_stat encrypted session key; "\r\n"expected rc = 1; got rc = [%d]. "\r\n"key_rec->enc_key_size = [%zd]\n", rc,\r\nkey_rec->enc_key_size);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmutex_lock(tfm_mutex);\r\nrc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,\r\ncrypt_stat->key_size);\r\nif (rc < 0) {\r\nmutex_unlock(tfm_mutex);\r\necryptfs_printk(KERN_ERR, "Error setting key for crypto "\r\n"context; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\nrc = 0;\r\necryptfs_printk(KERN_DEBUG, "Encrypting [%zd] bytes of the key\n",\r\ncrypt_stat->key_size);\r\nrc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,\r\n(*key_rec).enc_key_size);\r\nmutex_unlock(tfm_mutex);\r\nif (rc) {\r\nprintk(KERN_ERR "Error encrypting; rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\necryptfs_printk(KERN_DEBUG, "This should be the encrypted key:\n");\r\nif (ecryptfs_verbosity > 0) {\r\necryptfs_printk(KERN_DEBUG, "EFEK of size [%zd]:\n",\r\nkey_rec->enc_key_size);\r\necryptfs_dump_hex(key_rec->enc_key,\r\nkey_rec->enc_key_size);\r\n}\r\nencrypted_session_key_set:\r\nmax_packet_size = (1\r\n+ 3\r\n+ 1\r\n+ 1\r\n+ 1\r\n+ 1\r\n+ ECRYPTFS_SALT_SIZE\r\n+ 1\r\n+ key_rec->enc_key_size);\r\nif (max_packet_size > (*remaining_bytes)) {\r\nprintk(KERN_ERR "Packet too large; need up to [%td] bytes, but "\r\n"there are only [%td] available\n", max_packet_size,\r\n(*remaining_bytes));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\r\nrc = ecryptfs_write_packet_length(&dest[(*packet_size)],\r\n(max_packet_size - 4),\r\n&packet_size_length);\r\nif (rc) {\r\nprintk(KERN_ERR "Error generating tag 3 packet header; cannot "\r\n"generate packet length. rc = [%d]\n", rc);\r\ngoto out;\r\n}\r\n(*packet_size) += packet_size_length;\r\ndest[(*packet_size)++] = 0x04;\r\ncipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\r\ncrypt_stat->key_size);\r\nif (cipher_code == 0) {\r\necryptfs_printk(KERN_WARNING, "Unable to generate code for "\r\n"cipher [%s]\n", crypt_stat->cipher);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndest[(*packet_size)++] = cipher_code;\r\ndest[(*packet_size)++] = 0x03;\r\ndest[(*packet_size)++] = 0x01;\r\nmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\r\nECRYPTFS_SALT_SIZE);\r\n(*packet_size) += ECRYPTFS_SALT_SIZE;\r\ndest[(*packet_size)++] = 0x60;\r\nmemcpy(&dest[(*packet_size)], key_rec->enc_key,\r\nkey_rec->enc_key_size);\r\n(*packet_size) += key_rec->enc_key_size;\r\nout:\r\nif (rc)\r\n(*packet_size) = 0;\r\nelse\r\n(*remaining_bytes) -= (*packet_size);\r\nreturn rc;\r\n}\r\nint\r\necryptfs_generate_key_packet_set(char *dest_base,\r\nstruct ecryptfs_crypt_stat *crypt_stat,\r\nstruct dentry *ecryptfs_dentry, size_t *len,\r\nsize_t max)\r\n{\r\nstruct ecryptfs_auth_tok *auth_tok;\r\nstruct key *auth_tok_key = NULL;\r\nstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\r\n&ecryptfs_superblock_to_private(\r\necryptfs_dentry->d_sb)->mount_crypt_stat;\r\nsize_t written;\r\nstruct ecryptfs_key_record *key_rec;\r\nstruct ecryptfs_key_sig *key_sig;\r\nint rc = 0;\r\n(*len) = 0;\r\nmutex_lock(&crypt_stat->keysig_list_mutex);\r\nkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\r\nif (!key_rec) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\r\ncrypt_stat_list) {\r\nmemset(key_rec, 0, sizeof(*key_rec));\r\nrc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\r\n&auth_tok,\r\nmount_crypt_stat,\r\nkey_sig->keysig);\r\nif (rc) {\r\nprintk(KERN_WARNING "Unable to retrieve auth tok with "\r\n"sig = [%s]\n", key_sig->keysig);\r\nrc = process_find_global_auth_tok_for_sig_err(rc);\r\ngoto out_free;\r\n}\r\nif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\r\nrc = write_tag_3_packet((dest_base + (*len)),\r\n&max, auth_tok,\r\ncrypt_stat, key_rec,\r\n&written);\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error "\r\n"writing tag 3 packet\n");\r\ngoto out_free;\r\n}\r\n(*len) += written;\r\nrc = write_tag_11_packet((dest_base + (*len)), &max,\r\nkey_rec->sig,\r\nECRYPTFS_SIG_SIZE, &written);\r\nif (rc) {\r\necryptfs_printk(KERN_ERR, "Error writing "\r\n"auth tok signature packet\n");\r\ngoto out_free;\r\n}\r\n(*len) += written;\r\n} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\r\nrc = write_tag_1_packet(dest_base + (*len), &max,\r\nauth_tok_key, auth_tok,\r\ncrypt_stat, key_rec, &written);\r\nif (rc) {\r\necryptfs_printk(KERN_WARNING, "Error "\r\n"writing tag 1 packet\n");\r\ngoto out_free;\r\n}\r\n(*len) += written;\r\n} else {\r\nup_write(&(auth_tok_key->sem));\r\nkey_put(auth_tok_key);\r\necryptfs_printk(KERN_WARNING, "Unsupported "\r\n"authentication token type\n");\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nif (likely(max > 0)) {\r\ndest_base[(*len)] = 0x00;\r\n} else {\r\necryptfs_printk(KERN_ERR, "Error writing boundary byte\n");\r\nrc = -EIO;\r\n}\r\nout_free:\r\nkmem_cache_free(ecryptfs_key_record_cache, key_rec);\r\nout:\r\nif (rc)\r\n(*len) = 0;\r\nmutex_unlock(&crypt_stat->keysig_list_mutex);\r\nreturn rc;\r\n}\r\nint ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\r\n{\r\nstruct ecryptfs_key_sig *new_key_sig;\r\nnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\r\nif (!new_key_sig) {\r\nprintk(KERN_ERR\r\n"Error allocating from ecryptfs_key_sig_cache\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\r\nnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\0';\r\nlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\r\nreturn 0;\r\n}\r\nint\r\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\r\nchar *sig, u32 global_auth_tok_flags)\r\n{\r\nstruct ecryptfs_global_auth_tok *new_auth_tok;\r\nint rc = 0;\r\nnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\r\nGFP_KERNEL);\r\nif (!new_auth_tok) {\r\nrc = -ENOMEM;\r\nprintk(KERN_ERR "Error allocating from "\r\n"ecryptfs_global_auth_tok_cache\n");\r\ngoto out;\r\n}\r\nmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\r\nnew_auth_tok->flags = global_auth_tok_flags;\r\nnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\0';\r\nmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nlist_add(&new_auth_tok->mount_crypt_stat_list,\r\n&mount_crypt_stat->global_auth_tok_list);\r\nmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\r\nout:\r\nreturn rc;\r\n}
