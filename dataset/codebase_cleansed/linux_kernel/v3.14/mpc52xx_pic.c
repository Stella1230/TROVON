static inline void io_be_setbit(u32 __iomem *addr, int bitno)\r\n{\r\nout_be32(addr, in_be32(addr) | (1 << bitno));\r\n}\r\nstatic inline void io_be_clrbit(u32 __iomem *addr, int bitno)\r\n{\r\nout_be32(addr, in_be32(addr) & ~(1 << bitno));\r\n}\r\nstatic void mpc52xx_extirq_mask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_clrbit(&intr->ctrl, 11 - l2irq);\r\n}\r\nstatic void mpc52xx_extirq_unmask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_setbit(&intr->ctrl, 11 - l2irq);\r\n}\r\nstatic void mpc52xx_extirq_ack(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_setbit(&intr->ctrl, 27-l2irq);\r\n}\r\nstatic int mpc52xx_extirq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nu32 ctrl_reg, type;\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nvoid *handler = handle_level_irq;\r\npr_debug("%s: irq=%x. l2=%d flow_type=%d\n", __func__,\r\n(int) irqd_to_hwirq(d), l2irq, flow_type);\r\nswitch (flow_type) {\r\ncase IRQF_TRIGGER_HIGH: type = 0; break;\r\ncase IRQF_TRIGGER_RISING: type = 1; handler = handle_edge_irq; break;\r\ncase IRQF_TRIGGER_FALLING: type = 2; handler = handle_edge_irq; break;\r\ncase IRQF_TRIGGER_LOW: type = 3; break;\r\ndefault:\r\ntype = 0;\r\n}\r\nctrl_reg = in_be32(&intr->ctrl);\r\nctrl_reg &= ~(0x3 << (22 - (l2irq * 2)));\r\nctrl_reg |= (type << (22 - (l2irq * 2)));\r\nout_be32(&intr->ctrl, ctrl_reg);\r\n__irq_set_handler_locked(d->irq, handler);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_null_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_main_mask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_setbit(&intr->main_mask, 16 - l2irq);\r\n}\r\nstatic void mpc52xx_main_unmask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_clrbit(&intr->main_mask, 16 - l2irq);\r\n}\r\nstatic void mpc52xx_periph_mask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_setbit(&intr->per_mask, 31 - l2irq);\r\n}\r\nstatic void mpc52xx_periph_unmask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_clrbit(&intr->per_mask, 31 - l2irq);\r\n}\r\nstatic void mpc52xx_sdma_mask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_setbit(&sdma->IntMask, l2irq);\r\n}\r\nstatic void mpc52xx_sdma_unmask(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nio_be_clrbit(&sdma->IntMask, l2irq);\r\n}\r\nstatic void mpc52xx_sdma_ack(struct irq_data *d)\r\n{\r\nint l2irq = irqd_to_hwirq(d) & MPC52xx_IRQ_L2_MASK;\r\nout_be32(&sdma->IntPend, 1 << l2irq);\r\n}\r\nstatic int mpc52xx_is_extirq(int l1, int l2)\r\n{\r\nreturn ((l1 == 0) && (l2 == 0)) ||\r\n((l1 == 1) && (l2 >= 1) && (l2 <= 3));\r\n}\r\nstatic int mpc52xx_irqhost_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_flags)\r\n{\r\nint intrvect_l1;\r\nint intrvect_l2;\r\nint intrvect_type;\r\nint intrvect_linux;\r\nif (intsize != 3)\r\nreturn -1;\r\nintrvect_l1 = (int)intspec[0];\r\nintrvect_l2 = (int)intspec[1];\r\nintrvect_type = (int)intspec[2] & 0x3;\r\nintrvect_linux = (intrvect_l1 << MPC52xx_IRQ_L1_OFFSET) &\r\nMPC52xx_IRQ_L1_MASK;\r\nintrvect_linux |= intrvect_l2 & MPC52xx_IRQ_L2_MASK;\r\n*out_hwirq = intrvect_linux;\r\n*out_flags = IRQ_TYPE_LEVEL_LOW;\r\nif (mpc52xx_is_extirq(intrvect_l1, intrvect_l2))\r\n*out_flags = mpc52xx_map_senses[intrvect_type];\r\npr_debug("return %x, l1=%d, l2=%d\n", intrvect_linux, intrvect_l1,\r\nintrvect_l2);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_irqhost_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t irq)\r\n{\r\nint l1irq;\r\nint l2irq;\r\nstruct irq_chip *uninitialized_var(irqchip);\r\nvoid *hndlr;\r\nint type;\r\nu32 reg;\r\nl1irq = (irq & MPC52xx_IRQ_L1_MASK) >> MPC52xx_IRQ_L1_OFFSET;\r\nl2irq = irq & MPC52xx_IRQ_L2_MASK;\r\nif (mpc52xx_is_extirq(l1irq, l2irq)) {\r\nreg = in_be32(&intr->ctrl);\r\ntype = mpc52xx_map_senses[(reg >> (22 - l2irq * 2)) & 0x3];\r\nif ((type == IRQ_TYPE_EDGE_FALLING) ||\r\n(type == IRQ_TYPE_EDGE_RISING))\r\nhndlr = handle_edge_irq;\r\nelse\r\nhndlr = handle_level_irq;\r\nirq_set_chip_and_handler(virq, &mpc52xx_extirq_irqchip, hndlr);\r\npr_debug("%s: External IRQ%i virq=%x, hw=%x. type=%x\n",\r\n__func__, l2irq, virq, (int)irq, type);\r\nreturn 0;\r\n}\r\nswitch (l1irq) {\r\ncase MPC52xx_IRQ_L1_MAIN: irqchip = &mpc52xx_main_irqchip; break;\r\ncase MPC52xx_IRQ_L1_PERP: irqchip = &mpc52xx_periph_irqchip; break;\r\ncase MPC52xx_IRQ_L1_SDMA: irqchip = &mpc52xx_sdma_irqchip; break;\r\ncase MPC52xx_IRQ_L1_CRIT:\r\npr_warn("%s: Critical IRQ #%d is unsupported! Nopping it.\n",\r\n__func__, l2irq);\r\nirq_set_chip(virq, &no_irq_chip);\r\nreturn 0;\r\n}\r\nirq_set_chip_and_handler(virq, irqchip, handle_level_irq);\r\npr_debug("%s: virq=%x, l1=%i, l2=%i\n", __func__, virq, l1irq, l2irq);\r\nreturn 0;\r\n}\r\nvoid __init mpc52xx_init_irq(void)\r\n{\r\nu32 intr_ctrl;\r\nstruct device_node *picnode;\r\nstruct device_node *np;\r\npicnode = of_find_matching_node(NULL, mpc52xx_pic_ids);\r\nintr = of_iomap(picnode, 0);\r\nif (!intr)\r\npanic(__FILE__ ": find_and_map failed on 'mpc5200-pic'. "\r\n"Check node !");\r\nnp = of_find_matching_node(NULL, mpc52xx_sdma_ids);\r\nsdma = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!sdma)\r\npanic(__FILE__ ": find_and_map failed on 'mpc5200-bestcomm'. "\r\n"Check node !");\r\npr_debug("MPC5200 IRQ controller mapped to 0x%p\n", intr);\r\nout_be32(&sdma->IntPend, 0xffffffff);\r\nout_be32(&sdma->IntMask, 0xffffffff);\r\nout_be32(&intr->per_mask, 0x7ffffc00);\r\nout_be32(&intr->main_mask, 0x00010fff);\r\nintr_ctrl = in_be32(&intr->ctrl);\r\nintr_ctrl &= 0x00ff0000;\r\nintr_ctrl |= 0x0f000000 |\r\n0x00001000 |\r\n0x00000000 |\r\n0x00000001;\r\nout_be32(&intr->ctrl, intr_ctrl);\r\nout_be32(&intr->per_pri1, 0);\r\nout_be32(&intr->per_pri2, 0);\r\nout_be32(&intr->per_pri3, 0);\r\nout_be32(&intr->main_pri1, 0);\r\nout_be32(&intr->main_pri2, 0);\r\nmpc52xx_irqhost = irq_domain_add_linear(picnode,\r\nMPC52xx_IRQ_HIGHTESTHWIRQ,\r\n&mpc52xx_irqhost_ops, NULL);\r\nif (!mpc52xx_irqhost)\r\npanic(__FILE__ ": Cannot allocate the IRQ host\n");\r\nirq_set_default_host(mpc52xx_irqhost);\r\npr_info("MPC52xx PIC is up and running!\n");\r\n}\r\nunsigned int mpc52xx_get_irq(void)\r\n{\r\nu32 status;\r\nint irq;\r\nstatus = in_be32(&intr->enc_status);\r\nif (status & 0x00000400) {\r\nirq = (status >> 8) & 0x3;\r\nif (irq == 2)\r\ngoto peripheral;\r\nirq |= (MPC52xx_IRQ_L1_CRIT << MPC52xx_IRQ_L1_OFFSET);\r\n} else if (status & 0x00200000) {\r\nirq = (status >> 16) & 0x1f;\r\nif (irq == 4)\r\ngoto peripheral;\r\nirq |= (MPC52xx_IRQ_L1_MAIN << MPC52xx_IRQ_L1_OFFSET);\r\n} else if (status & 0x20000000) {\r\nperipheral:\r\nirq = (status >> 24) & 0x1f;\r\nif (irq == 0) {\r\nstatus = in_be32(&sdma->IntPend);\r\nirq = ffs(status) - 1;\r\nirq |= (MPC52xx_IRQ_L1_SDMA << MPC52xx_IRQ_L1_OFFSET);\r\n} else {\r\nirq |= (MPC52xx_IRQ_L1_PERP << MPC52xx_IRQ_L1_OFFSET);\r\n}\r\n} else {\r\nreturn NO_IRQ;\r\n}\r\nreturn irq_linear_revmap(mpc52xx_irqhost, irq);\r\n}
