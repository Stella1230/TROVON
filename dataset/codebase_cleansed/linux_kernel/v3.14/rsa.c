static int RSAVP1(const struct public_key *key, MPI s, MPI *_m)\r\n{\r\nMPI m;\r\nint ret;\r\nif (mpi_cmp_ui(s, 0) < 0) {\r\nkleave(" = -EBADMSG [s < 0]");\r\nreturn -EBADMSG;\r\n}\r\nif (mpi_cmp(s, key->rsa.n) >= 0) {\r\nkleave(" = -EBADMSG [s >= n]");\r\nreturn -EBADMSG;\r\n}\r\nm = mpi_alloc(0);\r\nif (!m)\r\nreturn -ENOMEM;\r\nret = mpi_powm(m, s, key->rsa.e, key->rsa.n);\r\nif (ret < 0) {\r\nmpi_free(m);\r\nreturn ret;\r\n}\r\n*_m = m;\r\nreturn 0;\r\n}\r\nstatic int RSA_I2OSP(MPI x, size_t xLen, u8 **_X)\r\n{\r\nunsigned X_size, x_size;\r\nint X_sign;\r\nu8 *X;\r\nx_size = mpi_get_nbits(x);\r\npr_devel("size(x)=%u xLen*8=%zu\n", x_size, xLen * 8);\r\nif (x_size != xLen * 8 - 15)\r\nreturn -ERANGE;\r\nX = mpi_get_buffer(x, &X_size, &X_sign);\r\nif (!X)\r\nreturn -ENOMEM;\r\nif (X_sign < 0) {\r\nkfree(X);\r\nreturn -EBADMSG;\r\n}\r\nif (X_size != xLen - 1) {\r\nkfree(X);\r\nreturn -EBADMSG;\r\n}\r\n*_X = X;\r\nreturn 0;\r\n}\r\nstatic int RSA_verify(const u8 *H, const u8 *EM, size_t k, size_t hash_size,\r\nconst u8 *asn1_template, size_t asn1_size)\r\n{\r\nunsigned PS_end, T_offset, i;\r\nkenter(",,%zu,%zu,%zu", k, hash_size, asn1_size);\r\nif (k < 2 + 1 + asn1_size + hash_size)\r\nreturn -EBADMSG;\r\nif (EM[1] != 0x01) {\r\nkleave(" = -EBADMSG [EM[1] == %02u]", EM[1]);\r\nreturn -EBADMSG;\r\n}\r\nT_offset = k - (asn1_size + hash_size);\r\nPS_end = T_offset - 1;\r\nif (EM[PS_end] != 0x00) {\r\nkleave(" = -EBADMSG [EM[T-1] == %02u]", EM[PS_end]);\r\nreturn -EBADMSG;\r\n}\r\nfor (i = 2; i < PS_end; i++) {\r\nif (EM[i] != 0xff) {\r\nkleave(" = -EBADMSG [EM[PS%x] == %02u]", i - 2, EM[i]);\r\nreturn -EBADMSG;\r\n}\r\n}\r\nif (crypto_memneq(asn1_template, EM + T_offset, asn1_size) != 0) {\r\nkleave(" = -EBADMSG [EM[T] ASN.1 mismatch]");\r\nreturn -EBADMSG;\r\n}\r\nif (crypto_memneq(H, EM + T_offset + asn1_size, hash_size) != 0) {\r\nkleave(" = -EKEYREJECTED [EM[T] hash mismatch]");\r\nreturn -EKEYREJECTED;\r\n}\r\nkleave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int RSA_verify_signature(const struct public_key *key,\r\nconst struct public_key_signature *sig)\r\n{\r\nsize_t tsize;\r\nint ret;\r\nconst u8 *H = sig->digest;\r\nu8 *EM = NULL;\r\nMPI m = NULL;\r\nsize_t k;\r\nkenter("");\r\nif (!RSA_ASN1_templates[sig->pkey_hash_algo].data)\r\nreturn -ENOTSUPP;\r\nk = mpi_get_nbits(key->rsa.n);\r\ntsize = mpi_get_nbits(sig->rsa.s);\r\npr_devel("step 1: k=%zu size(S)=%zu\n", k, tsize);\r\nif (k < tsize) {\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nk = (k + 7) / 8;\r\nret = RSAVP1(key, sig->rsa.s, &m);\r\nif (ret < 0)\r\ngoto error;\r\nret = RSA_I2OSP(m, k, &EM);\r\nif (ret < 0)\r\ngoto error;\r\nret = RSA_verify(H, EM - 1, k, sig->digest_size,\r\nRSA_ASN1_templates[sig->pkey_hash_algo].data,\r\nRSA_ASN1_templates[sig->pkey_hash_algo].size);\r\nerror:\r\nkfree(EM);\r\nmpi_free(m);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}
