static int at803x_set_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *ndev = phydev->attached_dev;\r\nconst u8 *mac;\r\nint ret;\r\nu32 value;\r\nunsigned int i, offsets[] = {\r\nAT803X_LOC_MAC_ADDR_32_47_OFFSET,\r\nAT803X_LOC_MAC_ADDR_16_31_OFFSET,\r\nAT803X_LOC_MAC_ADDR_0_15_OFFSET,\r\n};\r\nif (!ndev)\r\nreturn -ENODEV;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nmac = (const u8 *) ndev->dev_addr;\r\nif (!is_valid_ether_addr(mac))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 3; i++) {\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_DEVICE_ADDR);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\noffsets[i]);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_FUNC_DATA);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\nmac[(i * 2) + 1] | (mac[(i * 2)] << 8));\r\n}\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue |= AT803X_WOL_ENABLE;\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n} else {\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue &= (~AT803X_WOL_ENABLE);\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n}\r\nreturn ret;\r\n}\r\nstatic void at803x_get_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nu32 value;\r\nwol->supported = WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nif (value & AT803X_WOL_ENABLE)\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int at803x_suspend(struct phy_device *phydev)\r\n{\r\nint value;\r\nint wol_enabled;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nwol_enabled = value & AT803X_WOL_ENABLE;\r\nvalue = phy_read(phydev, MII_BMCR);\r\nif (wol_enabled)\r\nvalue |= BMCR_ISOLATE;\r\nelse\r\nvalue |= BMCR_PDOWN;\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_resume(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nvalue &= ~(BMCR_PDOWN | BMCR_ISOLATE);\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_config_init(struct phy_device *phydev)\r\n{\r\nint val;\r\nint ret;\r\nu32 features;\r\nfeatures = SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_AUI |\r\nSUPPORTED_FIBRE | SUPPORTED_BNC;\r\nval = phy_read(phydev, MII_BMSR);\r\nif (val < 0)\r\nreturn val;\r\nif (val & BMSR_ANEGCAPABLE)\r\nfeatures |= SUPPORTED_Autoneg;\r\nif (val & BMSR_100FULL)\r\nfeatures |= SUPPORTED_100baseT_Full;\r\nif (val & BMSR_100HALF)\r\nfeatures |= SUPPORTED_100baseT_Half;\r\nif (val & BMSR_10FULL)\r\nfeatures |= SUPPORTED_10baseT_Full;\r\nif (val & BMSR_10HALF)\r\nfeatures |= SUPPORTED_10baseT_Half;\r\nif (val & BMSR_ESTATEN) {\r\nval = phy_read(phydev, MII_ESTATUS);\r\nif (val < 0)\r\nreturn val;\r\nif (val & ESTATUS_1000_TFULL)\r\nfeatures |= SUPPORTED_1000baseT_Full;\r\nif (val & ESTATUS_1000_THALF)\r\nfeatures |= SUPPORTED_1000baseT_Half;\r\n}\r\nphydev->supported = features;\r\nphydev->advertising = features;\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {\r\nret = phy_write(phydev, AT803X_DEBUG_ADDR,\r\nAT803X_DEBUG_SYSTEM_MODE_CTRL);\r\nif (ret)\r\nreturn ret;\r\nret = phy_write(phydev, AT803X_DEBUG_DATA,\r\nAT803X_DEBUG_RGMII_TX_CLK_DLY);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init atheros_init(void)\r\n{\r\nreturn phy_drivers_register(at803x_driver,\r\nARRAY_SIZE(at803x_driver));\r\n}\r\nstatic void __exit atheros_exit(void)\r\n{\r\nreturn phy_drivers_unregister(at803x_driver,\r\nARRAY_SIZE(at803x_driver));\r\n}
