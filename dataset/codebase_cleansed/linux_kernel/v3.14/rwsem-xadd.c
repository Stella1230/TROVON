void __init_rwsem(struct rw_semaphore *sem, const char *name,\r\nstruct lock_class_key *key)\r\n{\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\ndebug_check_no_locks_freed((void *)sem, sizeof(*sem));\r\nlockdep_init_map(&sem->dep_map, name, key, 0);\r\n#endif\r\nsem->count = RWSEM_UNLOCKED_VALUE;\r\nraw_spin_lock_init(&sem->wait_lock);\r\nINIT_LIST_HEAD(&sem->wait_list);\r\n}\r\nstatic struct rw_semaphore *\r\n__rwsem_do_wake(struct rw_semaphore *sem, enum rwsem_wake_type wake_type)\r\n{\r\nstruct rwsem_waiter *waiter;\r\nstruct task_struct *tsk;\r\nstruct list_head *next;\r\nlong oldcount, woken, loop, adjustment;\r\nwaiter = list_entry(sem->wait_list.next, struct rwsem_waiter, list);\r\nif (waiter->type == RWSEM_WAITING_FOR_WRITE) {\r\nif (wake_type == RWSEM_WAKE_ANY)\r\nwake_up_process(waiter->task);\r\ngoto out;\r\n}\r\nadjustment = 0;\r\nif (wake_type != RWSEM_WAKE_READ_OWNED) {\r\nadjustment = RWSEM_ACTIVE_READ_BIAS;\r\ntry_reader_grant:\r\noldcount = rwsem_atomic_update(adjustment, sem) - adjustment;\r\nif (unlikely(oldcount < RWSEM_WAITING_BIAS)) {\r\nif (rwsem_atomic_update(-adjustment, sem) &\r\nRWSEM_ACTIVE_MASK)\r\ngoto out;\r\ngoto try_reader_grant;\r\n}\r\n}\r\nwoken = 0;\r\ndo {\r\nwoken++;\r\nif (waiter->list.next == &sem->wait_list)\r\nbreak;\r\nwaiter = list_entry(waiter->list.next,\r\nstruct rwsem_waiter, list);\r\n} while (waiter->type != RWSEM_WAITING_FOR_WRITE);\r\nadjustment = woken * RWSEM_ACTIVE_READ_BIAS - adjustment;\r\nif (waiter->type != RWSEM_WAITING_FOR_WRITE)\r\nadjustment -= RWSEM_WAITING_BIAS;\r\nif (adjustment)\r\nrwsem_atomic_add(adjustment, sem);\r\nnext = sem->wait_list.next;\r\nloop = woken;\r\ndo {\r\nwaiter = list_entry(next, struct rwsem_waiter, list);\r\nnext = waiter->list.next;\r\ntsk = waiter->task;\r\nsmp_mb();\r\nwaiter->task = NULL;\r\nwake_up_process(tsk);\r\nput_task_struct(tsk);\r\n} while (--loop);\r\nsem->wait_list.next = next;\r\nnext->prev = &sem->wait_list;\r\nout:\r\nreturn sem;\r\n}\r\nstruct rw_semaphore __sched *rwsem_down_read_failed(struct rw_semaphore *sem)\r\n{\r\nlong count, adjustment = -RWSEM_ACTIVE_READ_BIAS;\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk = current;\r\nwaiter.task = tsk;\r\nwaiter.type = RWSEM_WAITING_FOR_READ;\r\nget_task_struct(tsk);\r\nraw_spin_lock_irq(&sem->wait_lock);\r\nif (list_empty(&sem->wait_list))\r\nadjustment += RWSEM_WAITING_BIAS;\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\ncount = rwsem_atomic_update(adjustment, sem);\r\nif (count == RWSEM_WAITING_BIAS ||\r\n(count > RWSEM_WAITING_BIAS &&\r\nadjustment != -RWSEM_ACTIVE_READ_BIAS))\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_ANY);\r\nraw_spin_unlock_irq(&sem->wait_lock);\r\nwhile (true) {\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nif (!waiter.task)\r\nbreak;\r\nschedule();\r\n}\r\ntsk->state = TASK_RUNNING;\r\nreturn sem;\r\n}\r\nstruct rw_semaphore __sched *rwsem_down_write_failed(struct rw_semaphore *sem)\r\n{\r\nlong count, adjustment = -RWSEM_ACTIVE_WRITE_BIAS;\r\nstruct rwsem_waiter waiter;\r\nstruct task_struct *tsk = current;\r\nwaiter.task = tsk;\r\nwaiter.type = RWSEM_WAITING_FOR_WRITE;\r\nraw_spin_lock_irq(&sem->wait_lock);\r\nif (list_empty(&sem->wait_list))\r\nadjustment += RWSEM_WAITING_BIAS;\r\nlist_add_tail(&waiter.list, &sem->wait_list);\r\ncount = rwsem_atomic_update(adjustment, sem);\r\nif (count > RWSEM_WAITING_BIAS &&\r\nadjustment == -RWSEM_ACTIVE_WRITE_BIAS)\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_READERS);\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\nwhile (true) {\r\nif (!(count & RWSEM_ACTIVE_MASK)) {\r\ncount = RWSEM_ACTIVE_WRITE_BIAS;\r\nif (!list_is_singular(&sem->wait_list))\r\ncount += RWSEM_WAITING_BIAS;\r\nif (sem->count == RWSEM_WAITING_BIAS &&\r\ncmpxchg(&sem->count, RWSEM_WAITING_BIAS, count) ==\r\nRWSEM_WAITING_BIAS)\r\nbreak;\r\n}\r\nraw_spin_unlock_irq(&sem->wait_lock);\r\ndo {\r\nschedule();\r\nset_task_state(tsk, TASK_UNINTERRUPTIBLE);\r\n} while ((count = sem->count) & RWSEM_ACTIVE_MASK);\r\nraw_spin_lock_irq(&sem->wait_lock);\r\n}\r\nlist_del(&waiter.list);\r\nraw_spin_unlock_irq(&sem->wait_lock);\r\ntsk->state = TASK_RUNNING;\r\nreturn sem;\r\n}\r\nstruct rw_semaphore *rwsem_wake(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_ANY);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn sem;\r\n}\r\nstruct rw_semaphore *rwsem_downgrade_wake(struct rw_semaphore *sem)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&sem->wait_lock, flags);\r\nif (!list_empty(&sem->wait_list))\r\nsem = __rwsem_do_wake(sem, RWSEM_WAKE_READ_OWNED);\r\nraw_spin_unlock_irqrestore(&sem->wait_lock, flags);\r\nreturn sem;\r\n}
