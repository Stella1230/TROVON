static bool vidi_display_is_connected(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nreturn ctx->connected ? true : false;\r\n}\r\nstatic struct edid *vidi_get_edid(struct device *dev,\r\nstruct drm_connector *connector)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct edid *edid;\r\nif (!ctx->raw_edid) {\r\nDRM_DEBUG_KMS("raw_edid is null.\n");\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nedid = drm_edid_duplicate(ctx->raw_edid);\r\nif (!edid) {\r\nDRM_DEBUG_KMS("failed to allocate edid\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn edid;\r\n}\r\nstatic void *vidi_get_panel(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int vidi_check_mode(struct device *dev, struct drm_display_mode *mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vidi_display_power_on(struct device *dev, int mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vidi_dpms(struct device *subdrv_dev, int mode)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(subdrv_dev);\r\nDRM_DEBUG_KMS("%d\n", mode);\r\nmutex_lock(&ctx->lock);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("unspecified mode %d\n", mode);\r\nbreak;\r\n}\r\nmutex_unlock(&ctx->lock);\r\n}\r\nstatic void vidi_apply(struct device *subdrv_dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(subdrv_dev);\r\nstruct exynos_drm_manager *mgr = ctx->subdrv.manager;\r\nstruct exynos_drm_manager_ops *mgr_ops = mgr->ops;\r\nstruct exynos_drm_overlay_ops *ovl_ops = mgr->overlay_ops;\r\nstruct vidi_win_data *win_data;\r\nint i;\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nwin_data = &ctx->win_data[i];\r\nif (win_data->enabled && (ovl_ops && ovl_ops->commit))\r\novl_ops->commit(subdrv_dev, i);\r\n}\r\nif (mgr_ops && mgr_ops->commit)\r\nmgr_ops->commit(subdrv_dev);\r\n}\r\nstatic void vidi_commit(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nif (ctx->suspended)\r\nreturn;\r\n}\r\nstatic int vidi_enable_vblank(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = true;\r\nctx->direct_vblank = true;\r\nschedule_work(&ctx->work);\r\nreturn 0;\r\n}\r\nstatic void vidi_disable_vblank(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = false;\r\n}\r\nstatic void vidi_win_mode_set(struct device *dev,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win;\r\nunsigned long offset;\r\nif (!overlay) {\r\ndev_err(dev, "overlay is NULL\n");\r\nreturn;\r\n}\r\nwin = overlay->zpos;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win >= WINDOWS_NR)\r\nreturn;\r\noffset = overlay->fb_x * (overlay->bpp >> 3);\r\noffset += overlay->fb_y * overlay->pitch;\r\nDRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);\r\nwin_data = &ctx->win_data[win];\r\nwin_data->offset_x = overlay->crtc_x;\r\nwin_data->offset_y = overlay->crtc_y;\r\nwin_data->ovl_width = overlay->crtc_width;\r\nwin_data->ovl_height = overlay->crtc_height;\r\nwin_data->fb_width = overlay->fb_width;\r\nwin_data->fb_height = overlay->fb_height;\r\nwin_data->dma_addr = overlay->dma_addr[0] + offset;\r\nwin_data->bpp = overlay->bpp;\r\nwin_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *\r\n(overlay->bpp >> 3);\r\nwin_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);\r\nDRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",\r\nwin_data->offset_x, win_data->offset_y);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nwin_data->ovl_width, win_data->ovl_height);\r\nDRM_DEBUG_KMS("paddr = 0x%lx\n", (unsigned long)win_data->dma_addr);\r\nDRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",\r\noverlay->fb_width, overlay->crtc_width);\r\n}\r\nstatic void vidi_win_commit(struct device *dev, int zpos)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win = zpos;\r\nif (ctx->suspended)\r\nreturn;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win >= WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nwin_data->enabled = true;\r\nDRM_DEBUG_KMS("dma_addr = 0x%x\n", win_data->dma_addr);\r\nif (ctx->vblank_on)\r\nschedule_work(&ctx->work);\r\n}\r\nstatic void vidi_win_disable(struct device *dev, int zpos)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win = zpos;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win >= WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nwin_data->enabled = false;\r\n}\r\nstatic void vidi_fake_vblank_handler(struct work_struct *work)\r\n{\r\nstruct vidi_context *ctx = container_of(work, struct vidi_context,\r\nwork);\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct exynos_drm_manager *manager = subdrv->manager;\r\nif (manager->pipe < 0)\r\nreturn;\r\nusleep_range(16000, 20000);\r\nmutex_lock(&ctx->lock);\r\nif (ctx->direct_vblank) {\r\ndrm_handle_vblank(subdrv->drm_dev, manager->pipe);\r\nctx->direct_vblank = false;\r\nmutex_unlock(&ctx->lock);\r\nreturn;\r\n}\r\nmutex_unlock(&ctx->lock);\r\nexynos_drm_crtc_finish_pageflip(subdrv->drm_dev, manager->pipe);\r\n}\r\nstatic int vidi_subdrv_probe(struct drm_device *drm_dev, struct device *dev)\r\n{\r\ndrm_dev->irq_enabled = true;\r\ndrm_dev->vblank_disable_allowed = true;\r\nreturn 0;\r\n}\r\nstatic void vidi_subdrv_remove(struct drm_device *drm_dev, struct device *dev)\r\n{\r\n}\r\nstatic int vidi_power_on(struct vidi_context *ctx, bool enable)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct device *dev = subdrv->dev;\r\nif (enable) {\r\nctx->suspended = false;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nvidi_enable_vblank(dev);\r\nvidi_apply(dev);\r\n} else {\r\nctx->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidi_show_connection(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint rc;\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nmutex_lock(&ctx->lock);\r\nrc = sprintf(buf, "%d\n", ctx->connected);\r\nmutex_unlock(&ctx->lock);\r\nreturn rc;\r\n}\r\nstatic int vidi_store_connection(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nint ret;\r\nret = kstrtoint(buf, 0, &ctx->connected);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->connected > 1)\r\nreturn -EINVAL;\r\nif (!ctx->raw_edid)\r\nctx->raw_edid = (struct edid *)fake_edid_info;\r\nif (ctx->raw_edid != (struct edid *)fake_edid_info) {\r\nDRM_DEBUG_KMS("edid data is not fake data.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("requested connection.\n");\r\ndrm_helper_hpd_irq_event(ctx->subdrv.drm_dev);\r\nreturn len;\r\n}\r\nint vidi_connection_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vidi_context *ctx = NULL;\r\nstruct drm_encoder *encoder;\r\nstruct exynos_drm_manager *manager;\r\nstruct exynos_drm_display_ops *display_ops;\r\nstruct drm_exynos_vidi_connection *vidi = data;\r\nif (!vidi) {\r\nDRM_DEBUG_KMS("user data for vidi is null.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection > 1) {\r\nDRM_DEBUG_KMS("connection should be 0 or 1.\n");\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(encoder, &drm_dev->mode_config.encoder_list,\r\nhead) {\r\nmanager = exynos_drm_get_manager(encoder);\r\ndisplay_ops = manager->display_ops;\r\nif (display_ops->type == EXYNOS_DISPLAY_TYPE_VIDI) {\r\nctx = get_vidi_context(manager->dev);\r\nbreak;\r\n}\r\n}\r\nif (!ctx) {\r\nDRM_DEBUG_KMS("not found virtual device type encoder.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ctx->connected == vidi->connection) {\r\nDRM_DEBUG_KMS("same connection request.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection) {\r\nstruct edid *raw_edid = (struct edid *)(uint32_t)vidi->edid;\r\nif (!drm_edid_is_valid(raw_edid)) {\r\nDRM_DEBUG_KMS("edid data is invalid.\n");\r\nreturn -EINVAL;\r\n}\r\nctx->raw_edid = drm_edid_duplicate(raw_edid);\r\nif (!ctx->raw_edid) {\r\nDRM_DEBUG_KMS("failed to allocate raw_edid.\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nif (ctx->raw_edid && ctx->raw_edid !=\r\n(struct edid *)fake_edid_info) {\r\nkfree(ctx->raw_edid);\r\nctx->raw_edid = NULL;\r\n}\r\n}\r\nctx->connected = vidi->connection;\r\ndrm_helper_hpd_irq_event(ctx->subdrv.drm_dev);\r\nreturn 0;\r\n}\r\nstatic int vidi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct vidi_context *ctx;\r\nstruct exynos_drm_subdrv *subdrv;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->default_win = 0;\r\nINIT_WORK(&ctx->work, vidi_fake_vblank_handler);\r\nsubdrv = &ctx->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->manager = &vidi_manager;\r\nsubdrv->probe = vidi_subdrv_probe;\r\nsubdrv->remove = vidi_subdrv_remove;\r\nmutex_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\nret = device_create_file(dev, &dev_attr_connection);\r\nif (ret < 0)\r\nDRM_INFO("failed to create connection sysfs.\n");\r\nexynos_drm_subdrv_register(subdrv);\r\nreturn 0;\r\n}\r\nstatic int vidi_remove(struct platform_device *pdev)\r\n{\r\nstruct vidi_context *ctx = platform_get_drvdata(pdev);\r\nexynos_drm_subdrv_unregister(&ctx->subdrv);\r\nif (ctx->raw_edid != (struct edid *)fake_edid_info) {\r\nkfree(ctx->raw_edid);\r\nctx->raw_edid = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidi_suspend(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nreturn vidi_power_on(ctx, false);\r\n}\r\nstatic int vidi_resume(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nreturn vidi_power_on(ctx, true);\r\n}
