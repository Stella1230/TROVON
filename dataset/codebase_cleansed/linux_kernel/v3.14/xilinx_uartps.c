static irqreturn_t xuartps_isr(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = (struct uart_port *)dev_id;\r\nunsigned long flags;\r\nunsigned int isrstatus, numbytes;\r\nunsigned int data;\r\nchar status = TTY_NORMAL;\r\nspin_lock_irqsave(&port->lock, flags);\r\nisrstatus = xuartps_readl(XUARTPS_ISR_OFFSET);\r\nif (isrstatus & XUARTPS_IXR_FRAMING) {\r\nwhile (!(xuartps_readl(XUARTPS_SR_OFFSET) &\r\nXUARTPS_SR_RXEMPTY)) {\r\nif (!xuartps_readl(XUARTPS_FIFO_OFFSET)) {\r\nport->read_status_mask |= XUARTPS_IXR_BRK;\r\nisrstatus &= ~XUARTPS_IXR_FRAMING;\r\n}\r\n}\r\nxuartps_writel(XUARTPS_IXR_FRAMING, XUARTPS_ISR_OFFSET);\r\n}\r\nif (isrstatus & port->ignore_status_mask & XUARTPS_IXR_PARITY)\r\nisrstatus &= ~(XUARTPS_IXR_RXTRIG | XUARTPS_IXR_TOUT);\r\nisrstatus &= port->read_status_mask;\r\nisrstatus &= ~port->ignore_status_mask;\r\nif ((isrstatus & XUARTPS_IXR_TOUT) ||\r\n(isrstatus & XUARTPS_IXR_RXTRIG)) {\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) &\r\nXUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {\r\ndata = xuartps_readl(XUARTPS_FIFO_OFFSET);\r\nif (data && (port->read_status_mask &\r\nXUARTPS_IXR_BRK)) {\r\nport->read_status_mask &= ~XUARTPS_IXR_BRK;\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\n#ifdef SUPPORT_SYSRQ\r\nif (port->sysrq) {\r\nspin_unlock(&port->lock);\r\nif (uart_handle_sysrq_char(port,\r\n(unsigned char)data)) {\r\nspin_lock(&port->lock);\r\ncontinue;\r\n}\r\nspin_lock(&port->lock);\r\n}\r\n#endif\r\nport->icount.rx++;\r\nif (isrstatus & XUARTPS_IXR_PARITY) {\r\nport->icount.parity++;\r\nstatus = TTY_PARITY;\r\n} else if (isrstatus & XUARTPS_IXR_FRAMING) {\r\nport->icount.frame++;\r\nstatus = TTY_FRAME;\r\n} else if (isrstatus & XUARTPS_IXR_OVERRUN)\r\nport->icount.overrun++;\r\nuart_insert_char(port, isrstatus, XUARTPS_IXR_OVERRUN,\r\ndata, status);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(&port->state->port);\r\nspin_lock(&port->lock);\r\n}\r\nif ((isrstatus & XUARTPS_IXR_TXEMPTY) == XUARTPS_IXR_TXEMPTY) {\r\nif (uart_circ_empty(&port->state->xmit)) {\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY,\r\nXUARTPS_IDR_OFFSET);\r\n} else {\r\nnumbytes = port->fifosize;\r\nwhile (numbytes--) {\r\nif (uart_circ_empty(&port->state->xmit))\r\nbreak;\r\nxuartps_writel(\r\nport->state->xmit.buf[port->state->xmit.\r\ntail], XUARTPS_FIFO_OFFSET);\r\nport->icount.tx++;\r\nport->state->xmit.tail =\r\n(port->state->xmit.tail + 1) & \\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nif (uart_circ_chars_pending(\r\n&port->state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\n}\r\nxuartps_writel(isrstatus, XUARTPS_ISR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int xuartps_calc_baud_divs(unsigned int clk, unsigned int baud,\r\nu32 *rbdiv, u32 *rcd, int *div8)\r\n{\r\nu32 cd, bdiv;\r\nunsigned int calc_baud;\r\nunsigned int bestbaud = 0;\r\nunsigned int bauderror;\r\nunsigned int besterror = ~0;\r\nif (baud < clk / ((XUARTPS_BDIV_MAX + 1) * XUARTPS_CD_MAX)) {\r\n*div8 = 1;\r\nclk /= 8;\r\n} else {\r\n*div8 = 0;\r\n}\r\nfor (bdiv = XUARTPS_BDIV_MIN; bdiv <= XUARTPS_BDIV_MAX; bdiv++) {\r\ncd = DIV_ROUND_CLOSEST(clk, baud * (bdiv + 1));\r\nif (cd < 1 || cd > XUARTPS_CD_MAX)\r\ncontinue;\r\ncalc_baud = clk / (cd * (bdiv + 1));\r\nif (baud > calc_baud)\r\nbauderror = baud - calc_baud;\r\nelse\r\nbauderror = calc_baud - baud;\r\nif (besterror > bauderror) {\r\n*rbdiv = bdiv;\r\n*rcd = cd;\r\nbestbaud = calc_baud;\r\nbesterror = bauderror;\r\n}\r\n}\r\nif (((besterror * 100) / baud) < 3)\r\nbestbaud = baud;\r\nreturn bestbaud;\r\n}\r\nstatic unsigned int xuartps_set_baud_rate(struct uart_port *port,\r\nunsigned int baud)\r\n{\r\nunsigned int calc_baud;\r\nu32 cd = 0, bdiv = 0;\r\nu32 mreg;\r\nint div8;\r\nstruct xuartps *xuartps = port->private_data;\r\ncalc_baud = xuartps_calc_baud_divs(port->uartclk, baud, &bdiv, &cd,\r\n&div8);\r\nmreg = xuartps_readl(XUARTPS_MR_OFFSET);\r\nif (div8)\r\nmreg |= XUARTPS_MR_CLKSEL;\r\nelse\r\nmreg &= ~XUARTPS_MR_CLKSEL;\r\nxuartps_writel(mreg, XUARTPS_MR_OFFSET);\r\nxuartps_writel(cd, XUARTPS_BAUDGEN_OFFSET);\r\nxuartps_writel(bdiv, XUARTPS_BAUDDIV_OFFSET);\r\nxuartps->baud = baud;\r\nreturn calc_baud;\r\n}\r\nstatic int xuartps_clk_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nu32 ctrl_reg;\r\nstruct uart_port *port;\r\nint locked = 0;\r\nstruct clk_notifier_data *ndata = data;\r\nunsigned long flags = 0;\r\nstruct xuartps *xuartps = to_xuartps(nb);\r\nport = xuartps->port;\r\nif (port->suspended)\r\nreturn NOTIFY_OK;\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\n{\r\nu32 bdiv;\r\nu32 cd;\r\nint div8;\r\nif (!xuartps_calc_baud_divs(ndata->new_rate, xuartps->baud,\r\n&bdiv, &cd, &div8))\r\nreturn NOTIFY_BAD;\r\nspin_lock_irqsave(&xuartps->port->lock, flags);\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS),\r\nXUARTPS_CR_OFFSET);\r\nspin_unlock_irqrestore(&xuartps->port->lock, flags);\r\nreturn NOTIFY_OK;\r\n}\r\ncase POST_RATE_CHANGE:\r\nspin_lock_irqsave(&xuartps->port->lock, flags);\r\nlocked = 1;\r\nport->uartclk = ndata->new_rate;\r\nxuartps->baud = xuartps_set_baud_rate(xuartps->port,\r\nxuartps->baud);\r\ncase ABORT_RATE_CHANGE:\r\nif (!locked)\r\nspin_lock_irqsave(&xuartps->port->lock, flags);\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST),\r\nXUARTPS_CR_OFFSET);\r\nwhile (xuartps_readl(XUARTPS_CR_OFFSET) &\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST))\r\ncpu_relax();\r\nxuartps_writel(rx_timeout, XUARTPS_RXTOUT_OFFSET);\r\nctrl_reg = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel(\r\n(ctrl_reg & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS)) |\r\n(XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN),\r\nXUARTPS_CR_OFFSET);\r\nspin_unlock_irqrestore(&xuartps->port->lock, flags);\r\nreturn NOTIFY_OK;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic void xuartps_start_tx(struct uart_port *port)\r\n{\r\nunsigned int status, numbytes = port->fifosize;\r\nif (uart_circ_empty(&port->state->xmit) || uart_tx_stopped(port))\r\nreturn;\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel((status & ~XUARTPS_CR_TX_DIS) | XUARTPS_CR_TX_EN,\r\nXUARTPS_CR_OFFSET);\r\nwhile (numbytes-- && ((xuartps_readl(XUARTPS_SR_OFFSET)\r\n& XUARTPS_SR_TXFULL)) != XUARTPS_SR_TXFULL) {\r\nif (uart_circ_empty(&port->state->xmit))\r\nbreak;\r\nxuartps_writel(\r\nport->state->xmit.buf[port->state->xmit.tail],\r\nXUARTPS_FIFO_OFFSET);\r\nport->icount.tx++;\r\nport->state->xmit.tail = (port->state->xmit.tail + 1) &\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY, XUARTPS_ISR_OFFSET);\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY, XUARTPS_IER_OFFSET);\r\nif (uart_circ_chars_pending(&port->state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void xuartps_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nregval = xuartps_readl(XUARTPS_CR_OFFSET);\r\nregval |= XUARTPS_CR_TX_DIS;\r\nxuartps_writel(regval, XUARTPS_CR_OFFSET);\r\n}\r\nstatic void xuartps_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int regval;\r\nregval = xuartps_readl(XUARTPS_CR_OFFSET);\r\nregval |= XUARTPS_CR_RX_DIS;\r\nxuartps_writel(regval, XUARTPS_CR_OFFSET);\r\n}\r\nstatic unsigned int xuartps_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nstatus = xuartps_readl(XUARTPS_ISR_OFFSET) & XUARTPS_IXR_TXEMPTY;\r\nreturn status ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void xuartps_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nunsigned int status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nif (ctl == -1)\r\nxuartps_writel(XUARTPS_CR_STARTBRK | status,\r\nXUARTPS_CR_OFFSET);\r\nelse {\r\nif ((status & XUARTPS_CR_STOPBRK) == 0)\r\nxuartps_writel(XUARTPS_CR_STOPBRK | status,\r\nXUARTPS_CR_OFFSET);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void xuartps_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nunsigned int cval = 0;\r\nunsigned int baud, minbaud, maxbaud;\r\nunsigned long flags;\r\nunsigned int ctrl_reg, mode_reg;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) &\r\nXUARTPS_SR_RXEMPTY) != XUARTPS_SR_RXEMPTY) {\r\nxuartps_readl(XUARTPS_FIFO_OFFSET);\r\n}\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS),\r\nXUARTPS_CR_OFFSET);\r\nminbaud = port->uartclk / ((XUARTPS_BDIV_MAX + 1) * XUARTPS_CD_MAX * 8);\r\nmaxbaud = port->uartclk / (XUARTPS_BDIV_MIN + 1);\r\nbaud = uart_get_baud_rate(port, termios, old, minbaud, maxbaud);\r\nbaud = xuartps_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST),\r\nXUARTPS_CR_OFFSET);\r\nctrl_reg = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel(\r\n(ctrl_reg & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS))\r\n| (XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN),\r\nXUARTPS_CR_OFFSET);\r\nxuartps_writel(rx_timeout, XUARTPS_RXTOUT_OFFSET);\r\nport->read_status_mask = XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_RXTRIG |\r\nXUARTPS_IXR_OVERRUN | XUARTPS_IXR_TOUT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= XUARTPS_IXR_RXTRIG |\r\nXUARTPS_IXR_TOUT | XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN;\r\nmode_reg = xuartps_readl(XUARTPS_MR_OFFSET);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS6:\r\ncval |= XUARTPS_MR_CHARLEN_6_BIT;\r\nbreak;\r\ncase CS7:\r\ncval |= XUARTPS_MR_CHARLEN_7_BIT;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval |= XUARTPS_MR_CHARLEN_8_BIT;\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= XUARTPS_MR_STOPMODE_2_BIT;\r\nelse\r\ncval |= XUARTPS_MR_STOPMODE_1_BIT;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\ncval |= XUARTPS_MR_PARITY_MARK;\r\nelse\r\ncval |= XUARTPS_MR_PARITY_SPACE;\r\n} else {\r\nif (termios->c_cflag & PARODD)\r\ncval |= XUARTPS_MR_PARITY_ODD;\r\nelse\r\ncval |= XUARTPS_MR_PARITY_EVEN;\r\n}\r\n} else {\r\ncval |= XUARTPS_MR_PARITY_NONE;\r\n}\r\ncval |= mode_reg & 1;\r\nxuartps_writel(cval, XUARTPS_MR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int xuartps_startup(struct uart_port *port)\r\n{\r\nunsigned int retval = 0, status = 0;\r\nretval = request_irq(port->irq, xuartps_isr, 0, XUARTPS_NAME,\r\n(void *)port);\r\nif (retval)\r\nreturn retval;\r\nxuartps_writel(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS,\r\nXUARTPS_CR_OFFSET);\r\nxuartps_writel(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST,\r\nXUARTPS_CR_OFFSET);\r\nstatus = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel((status & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS))\r\n| (XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN |\r\nXUARTPS_CR_STOPBRK), XUARTPS_CR_OFFSET);\r\nxuartps_writel(XUARTPS_MR_CHMODE_NORM | XUARTPS_MR_STOPMODE_1_BIT\r\n| XUARTPS_MR_PARITY_NONE | XUARTPS_MR_CHARLEN_8_BIT,\r\nXUARTPS_MR_OFFSET);\r\nxuartps_writel(rx_trigger_level, XUARTPS_RXWM_OFFSET);\r\nxuartps_writel(rx_timeout, XUARTPS_RXTOUT_OFFSET);\r\nxuartps_writel(xuartps_readl(XUARTPS_ISR_OFFSET), XUARTPS_ISR_OFFSET);\r\nxuartps_writel(XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_PARITY |\r\nXUARTPS_IXR_FRAMING | XUARTPS_IXR_OVERRUN |\r\nXUARTPS_IXR_RXTRIG | XUARTPS_IXR_TOUT, XUARTPS_IER_OFFSET);\r\nreturn retval;\r\n}\r\nstatic void xuartps_shutdown(struct uart_port *port)\r\n{\r\nint status;\r\nstatus = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(status, XUARTPS_IDR_OFFSET);\r\nxuartps_writel(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS,\r\nXUARTPS_CR_OFFSET);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic const char *xuartps_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_XUARTPS ? XUARTPS_NAME : NULL;\r\n}\r\nstatic int xuartps_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_XUARTPS)\r\nreturn -EINVAL;\r\nif (port->irq != ser->irq)\r\nreturn -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nreturn -EINVAL;\r\nif (port->iobase != ser->port)\r\nreturn -EINVAL;\r\nif (ser->hub6 != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xuartps_request_port(struct uart_port *port)\r\n{\r\nif (!request_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE,\r\nXUARTPS_NAME)) {\r\nreturn -ENOMEM;\r\n}\r\nport->membase = ioremap(port->mapbase, XUARTPS_REGISTER_SPACE);\r\nif (!port->membase) {\r\ndev_err(port->dev, "Unable to map registers\n");\r\nrelease_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xuartps_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, XUARTPS_REGISTER_SPACE);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic void xuartps_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE && xuartps_request_port(port) == 0)\r\nport->type = PORT_XUARTPS;\r\n}\r\nstatic unsigned int xuartps_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void xuartps_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void xuartps_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic int xuartps_poll_get_char(struct uart_port *port)\r\n{\r\nu32 imr;\r\nint c;\r\nimr = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IDR_OFFSET);\r\nif (xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_RXEMPTY)\r\nc = NO_POLL_CHAR;\r\nelse\r\nc = (unsigned char) xuartps_readl(XUARTPS_FIFO_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IER_OFFSET);\r\nreturn c;\r\n}\r\nstatic void xuartps_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nu32 imr;\r\nimr = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IDR_OFFSET);\r\nwhile (!(xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_TXEMPTY))\r\ncpu_relax();\r\nxuartps_writel(c, XUARTPS_FIFO_OFFSET);\r\nwhile (!(xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_TXEMPTY))\r\ncpu_relax();\r\nxuartps_writel(imr, XUARTPS_IER_OFFSET);\r\nreturn;\r\n}\r\nstatic struct uart_port *xuartps_get_port(void)\r\n{\r\nstruct uart_port *port;\r\nint id;\r\nfor (id = 0; id < XUARTPS_NR_PORTS; id++)\r\nif (xuartps_port[id].mapbase == 0)\r\nbreak;\r\nif (id >= XUARTPS_NR_PORTS)\r\nreturn NULL;\r\nport = &xuartps_port[id];\r\nspin_lock_init(&port->lock);\r\nport->membase = NULL;\r\nport->iobase = 1;\r\nport->irq = 0;\r\nport->type = PORT_UNKNOWN;\r\nport->iotype = UPIO_MEM32;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &xuartps_ops;\r\nport->fifosize = XUARTPS_FIFO_SIZE;\r\nport->line = id;\r\nport->dev = NULL;\r\nreturn port;\r\n}\r\nstatic void xuartps_console_wait_tx(struct uart_port *port)\r\n{\r\nwhile ((xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_TXEMPTY)\r\n!= XUARTPS_SR_TXEMPTY)\r\nbarrier();\r\n}\r\nstatic void xuartps_console_putchar(struct uart_port *port, int ch)\r\n{\r\nxuartps_console_wait_tx(port);\r\nxuartps_writel(ch, XUARTPS_FIFO_OFFSET);\r\n}\r\nstatic void xuartps_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &xuartps_port[co->index];\r\nunsigned long flags;\r\nunsigned int imr, ctrl;\r\nint locked = 1;\r\nif (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nimr = xuartps_readl(XUARTPS_IMR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IDR_OFFSET);\r\nctrl = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel((ctrl & ~XUARTPS_CR_TX_DIS) | XUARTPS_CR_TX_EN,\r\nXUARTPS_CR_OFFSET);\r\nuart_console_write(port, s, count, xuartps_console_putchar);\r\nxuartps_console_wait_tx(port);\r\nxuartps_writel(ctrl, XUARTPS_CR_OFFSET);\r\nxuartps_writel(~imr, XUARTPS_IDR_OFFSET);\r\nxuartps_writel(imr, XUARTPS_IER_OFFSET);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int __init xuartps_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &xuartps_port[co->index];\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= XUARTPS_NR_PORTS)\r\nreturn -EINVAL;\r\nif (!port->mapbase) {\r\npr_debug("console on ttyPS%i not present\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init xuartps_console_init(void)\r\n{\r\nregister_console(&xuartps_console);\r\nreturn 0;\r\n}\r\nstatic int xuartps_suspend(struct device *device)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(device);\r\nstruct tty_struct *tty;\r\nstruct device *tty_dev;\r\nint may_wake = 0;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (tty) {\r\ntty_dev = tty->dev;\r\nmay_wake = device_may_wakeup(tty_dev);\r\ntty_kref_put(tty);\r\n}\r\nuart_suspend_port(&xuartps_uart_driver, port);\r\nif (console_suspend_enabled && !may_wake) {\r\nstruct xuartps *xuartps = port->private_data;\r\nclk_disable(xuartps->refclk);\r\nclk_disable(xuartps->aperclk);\r\n} else {\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (!(xuartps_readl(XUARTPS_SR_OFFSET) & XUARTPS_SR_RXEMPTY))\r\nxuartps_readl(XUARTPS_FIFO_OFFSET);\r\nxuartps_writel(1, XUARTPS_RXWM_OFFSET);\r\nxuartps_writel(XUARTPS_IXR_TOUT, XUARTPS_IDR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xuartps_resume(struct device *device)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(device);\r\nunsigned long flags = 0;\r\nu32 ctrl_reg;\r\nstruct tty_struct *tty;\r\nstruct device *tty_dev;\r\nint may_wake = 0;\r\ntty = tty_port_tty_get(&port->state->port);\r\nif (tty) {\r\ntty_dev = tty->dev;\r\nmay_wake = device_may_wakeup(tty_dev);\r\ntty_kref_put(tty);\r\n}\r\nif (console_suspend_enabled && !may_wake) {\r\nstruct xuartps *xuartps = port->private_data;\r\nclk_enable(xuartps->aperclk);\r\nclk_enable(xuartps->refclk);\r\nspin_lock_irqsave(&port->lock, flags);\r\nxuartps_writel(xuartps_readl(XUARTPS_CR_OFFSET) |\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST),\r\nXUARTPS_CR_OFFSET);\r\nwhile (xuartps_readl(XUARTPS_CR_OFFSET) &\r\n(XUARTPS_CR_TXRST | XUARTPS_CR_RXRST))\r\ncpu_relax();\r\nxuartps_writel(rx_timeout, XUARTPS_RXTOUT_OFFSET);\r\nctrl_reg = xuartps_readl(XUARTPS_CR_OFFSET);\r\nxuartps_writel(\r\n(ctrl_reg & ~(XUARTPS_CR_TX_DIS | XUARTPS_CR_RX_DIS)) |\r\n(XUARTPS_CR_TX_EN | XUARTPS_CR_RX_EN),\r\nXUARTPS_CR_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n} else {\r\nspin_lock_irqsave(&port->lock, flags);\r\nxuartps_writel(rx_trigger_level, XUARTPS_RXWM_OFFSET);\r\nxuartps_writel(XUARTPS_IXR_TOUT, XUARTPS_IER_OFFSET);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn uart_resume_port(&xuartps_uart_driver, port);\r\n}\r\nstatic int xuartps_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nstruct uart_port *port;\r\nstruct resource *res, *res2;\r\nstruct xuartps *xuartps_data;\r\nxuartps_data = devm_kzalloc(&pdev->dev, sizeof(*xuartps_data),\r\nGFP_KERNEL);\r\nif (!xuartps_data)\r\nreturn -ENOMEM;\r\nxuartps_data->aperclk = devm_clk_get(&pdev->dev, "aper_clk");\r\nif (IS_ERR(xuartps_data->aperclk)) {\r\ndev_err(&pdev->dev, "aper_clk clock not found.\n");\r\nreturn PTR_ERR(xuartps_data->aperclk);\r\n}\r\nxuartps_data->refclk = devm_clk_get(&pdev->dev, "ref_clk");\r\nif (IS_ERR(xuartps_data->refclk)) {\r\ndev_err(&pdev->dev, "ref_clk clock not found.\n");\r\nreturn PTR_ERR(xuartps_data->refclk);\r\n}\r\nrc = clk_prepare_enable(xuartps_data->aperclk);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Unable to enable APER clock.\n");\r\nreturn rc;\r\n}\r\nrc = clk_prepare_enable(xuartps_data->refclk);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Unable to enable device clock.\n");\r\ngoto err_out_clk_dis_aper;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nrc = -ENODEV;\r\ngoto err_out_clk_disable;\r\n}\r\nres2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res2) {\r\nrc = -ENODEV;\r\ngoto err_out_clk_disable;\r\n}\r\n#ifdef CONFIG_COMMON_CLK\r\nxuartps_data->clk_rate_change_nb.notifier_call =\r\nxuartps_clk_notifier_cb;\r\nif (clk_notifier_register(xuartps_data->refclk,\r\n&xuartps_data->clk_rate_change_nb))\r\ndev_warn(&pdev->dev, "Unable to register clock notifier.\n");\r\n#endif\r\nport = xuartps_get_port();\r\nif (!port) {\r\ndev_err(&pdev->dev, "Cannot get uart_port structure\n");\r\nrc = -ENODEV;\r\ngoto err_out_notif_unreg;\r\n} else {\r\nport->mapbase = res->start;\r\nport->irq = res2->start;\r\nport->dev = &pdev->dev;\r\nport->uartclk = clk_get_rate(xuartps_data->refclk);\r\nport->private_data = xuartps_data;\r\nxuartps_data->port = port;\r\nplatform_set_drvdata(pdev, port);\r\nrc = uart_add_one_port(&xuartps_uart_driver, port);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"uart_add_one_port() failed; err=%i\n", rc);\r\ngoto err_out_notif_unreg;\r\n}\r\nreturn 0;\r\n}\r\nerr_out_notif_unreg:\r\n#ifdef CONFIG_COMMON_CLK\r\nclk_notifier_unregister(xuartps_data->refclk,\r\n&xuartps_data->clk_rate_change_nb);\r\n#endif\r\nerr_out_clk_disable:\r\nclk_disable_unprepare(xuartps_data->refclk);\r\nerr_out_clk_dis_aper:\r\nclk_disable_unprepare(xuartps_data->aperclk);\r\nreturn rc;\r\n}\r\nstatic int xuartps_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct xuartps *xuartps_data = port->private_data;\r\nint rc;\r\n#ifdef CONFIG_COMMON_CLK\r\nclk_notifier_unregister(xuartps_data->refclk,\r\n&xuartps_data->clk_rate_change_nb);\r\n#endif\r\nrc = uart_remove_one_port(&xuartps_uart_driver, port);\r\nport->mapbase = 0;\r\nclk_disable_unprepare(xuartps_data->refclk);\r\nclk_disable_unprepare(xuartps_data->aperclk);\r\nreturn rc;\r\n}\r\nstatic int __init xuartps_init(void)\r\n{\r\nint retval = 0;\r\nretval = uart_register_driver(&xuartps_uart_driver);\r\nif (retval)\r\nreturn retval;\r\nretval = platform_driver_register(&xuartps_platform_driver);\r\nif (retval)\r\nuart_unregister_driver(&xuartps_uart_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit xuartps_exit(void)\r\n{\r\nplatform_driver_unregister(&xuartps_platform_driver);\r\nuart_unregister_driver(&xuartps_uart_driver);\r\n}
