static inline int\r\nget_ext_path(struct inode *inode, ext4_lblk_t lblock,\r\nstruct ext4_ext_path **orig_path)\r\n{\r\nint ret = 0;\r\nstruct ext4_ext_path *path;\r\npath = ext4_ext_find_extent(inode, lblock, *orig_path, EXT4_EX_NOCACHE);\r\nif (IS_ERR(path))\r\nret = PTR_ERR(path);\r\nelse if (path[ext_depth(inode)].p_ext == NULL)\r\nret = -ENODATA;\r\nelse\r\n*orig_path = path;\r\nreturn ret;\r\n}\r\nstatic void\r\ncopy_extent_status(struct ext4_extent *src, struct ext4_extent *dest)\r\n{\r\nif (ext4_ext_is_uninitialized(src))\r\next4_ext_mark_uninitialized(dest);\r\nelse\r\ndest->ee_len = cpu_to_le16(ext4_ext_get_actual_len(dest));\r\n}\r\nstatic int\r\nmext_next_extent(struct inode *inode, struct ext4_ext_path *path,\r\nstruct ext4_extent **extent)\r\n{\r\nstruct ext4_extent_header *eh;\r\nint ppos, leaf_ppos = path->p_depth;\r\nppos = leaf_ppos;\r\nif (EXT_LAST_EXTENT(path[ppos].p_hdr) > path[ppos].p_ext) {\r\n*extent = ++path[ppos].p_ext;\r\npath[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);\r\nreturn 0;\r\n}\r\nwhile (--ppos >= 0) {\r\nif (EXT_LAST_INDEX(path[ppos].p_hdr) >\r\npath[ppos].p_idx) {\r\nint cur_ppos = ppos;\r\npath[ppos].p_idx++;\r\npath[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);\r\nif (path[ppos+1].p_bh)\r\nbrelse(path[ppos+1].p_bh);\r\npath[ppos+1].p_bh =\r\nsb_bread(inode->i_sb, path[ppos].p_block);\r\nif (!path[ppos+1].p_bh)\r\nreturn -EIO;\r\npath[ppos+1].p_hdr =\r\next_block_hdr(path[ppos+1].p_bh);\r\nwhile (++cur_ppos < leaf_ppos) {\r\npath[cur_ppos].p_idx =\r\nEXT_FIRST_INDEX(path[cur_ppos].p_hdr);\r\npath[cur_ppos].p_block =\r\next4_idx_pblock(path[cur_ppos].p_idx);\r\nif (path[cur_ppos+1].p_bh)\r\nbrelse(path[cur_ppos+1].p_bh);\r\npath[cur_ppos+1].p_bh = sb_bread(inode->i_sb,\r\npath[cur_ppos].p_block);\r\nif (!path[cur_ppos+1].p_bh)\r\nreturn -EIO;\r\npath[cur_ppos+1].p_hdr =\r\next_block_hdr(path[cur_ppos+1].p_bh);\r\n}\r\npath[leaf_ppos].p_ext = *extent = NULL;\r\neh = path[leaf_ppos].p_hdr;\r\nif (le16_to_cpu(eh->eh_entries) == 0)\r\nreturn -ENODATA;\r\npath[leaf_ppos].p_ext = *extent =\r\nEXT_FIRST_EXTENT(path[leaf_ppos].p_hdr);\r\npath[leaf_ppos].p_block =\r\next4_ext_pblock(path[leaf_ppos].p_ext);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\next4_double_down_write_data_sem(struct inode *first, struct inode *second)\r\n{\r\nif (first < second) {\r\ndown_write(&EXT4_I(first)->i_data_sem);\r\ndown_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);\r\n} else {\r\ndown_write(&EXT4_I(second)->i_data_sem);\r\ndown_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);\r\n}\r\n}\r\nvoid\r\next4_double_up_write_data_sem(struct inode *orig_inode,\r\nstruct inode *donor_inode)\r\n{\r\nup_write(&EXT4_I(orig_inode)->i_data_sem);\r\nup_write(&EXT4_I(donor_inode)->i_data_sem);\r\n}\r\nstatic int\r\nmext_insert_across_blocks(handle_t *handle, struct inode *orig_inode,\r\nstruct ext4_extent *o_start, struct ext4_extent *o_end,\r\nstruct ext4_extent *start_ext, struct ext4_extent *new_ext,\r\nstruct ext4_extent *end_ext)\r\n{\r\nstruct ext4_ext_path *orig_path = NULL;\r\next4_lblk_t eblock = 0;\r\nint new_flag = 0;\r\nint end_flag = 0;\r\nint err = 0;\r\nif (start_ext->ee_len && new_ext->ee_len && end_ext->ee_len) {\r\nif (o_start == o_end) {\r\nend_flag = 1;\r\n} else {\r\no_end->ee_block = end_ext->ee_block;\r\no_end->ee_len = end_ext->ee_len;\r\next4_ext_store_pblock(o_end, ext4_ext_pblock(end_ext));\r\n}\r\no_start->ee_len = start_ext->ee_len;\r\neblock = le32_to_cpu(start_ext->ee_block);\r\nnew_flag = 1;\r\n} else if (start_ext->ee_len && new_ext->ee_len &&\r\n!end_ext->ee_len && o_start == o_end) {\r\no_start->ee_len = start_ext->ee_len;\r\neblock = le32_to_cpu(start_ext->ee_block);\r\nnew_flag = 1;\r\n} else if (!start_ext->ee_len && new_ext->ee_len &&\r\nend_ext->ee_len && o_start == o_end) {\r\no_end->ee_block = end_ext->ee_block;\r\no_end->ee_len = end_ext->ee_len;\r\next4_ext_store_pblock(o_end, ext4_ext_pblock(end_ext));\r\nif (new_ext->ee_block)\r\neblock = le32_to_cpu(new_ext->ee_block);\r\nnew_flag = 1;\r\n} else {\r\next4_debug("ext4 move extent: Unexpected insert case\n");\r\nreturn -EIO;\r\n}\r\nif (new_flag) {\r\nerr = get_ext_path(orig_inode, eblock, &orig_path);\r\nif (err)\r\ngoto out;\r\nif (ext4_ext_insert_extent(handle, orig_inode,\r\norig_path, new_ext, 0))\r\ngoto out;\r\n}\r\nif (end_flag) {\r\nerr = get_ext_path(orig_inode,\r\nle32_to_cpu(end_ext->ee_block) - 1, &orig_path);\r\nif (err)\r\ngoto out;\r\nif (ext4_ext_insert_extent(handle, orig_inode,\r\norig_path, end_ext, 0))\r\ngoto out;\r\n}\r\nout:\r\nif (orig_path) {\r\next4_ext_drop_refs(orig_path);\r\nkfree(orig_path);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nmext_insert_inside_block(struct ext4_extent *o_start,\r\nstruct ext4_extent *o_end,\r\nstruct ext4_extent *start_ext,\r\nstruct ext4_extent *new_ext,\r\nstruct ext4_extent *end_ext,\r\nstruct ext4_extent_header *eh,\r\nint range_to_move)\r\n{\r\nint i = 0;\r\nunsigned long len;\r\nif (range_to_move && o_end < EXT_LAST_EXTENT(eh)) {\r\nlen = (unsigned long)(EXT_LAST_EXTENT(eh) + 1) -\r\n(unsigned long)(o_end + 1);\r\nmemmove(o_end + 1 + range_to_move, o_end + 1, len);\r\n}\r\nif (start_ext->ee_len)\r\no_start[i++].ee_len = start_ext->ee_len;\r\nif (new_ext->ee_len) {\r\no_start[i] = *new_ext;\r\next4_ext_store_pblock(&o_start[i++], ext4_ext_pblock(new_ext));\r\n}\r\nif (end_ext->ee_len)\r\no_start[i] = *end_ext;\r\nle16_add_cpu(&eh->eh_entries, range_to_move);\r\n}\r\nstatic int\r\nmext_insert_extents(handle_t *handle, struct inode *orig_inode,\r\nstruct ext4_ext_path *orig_path,\r\nstruct ext4_extent *o_start,\r\nstruct ext4_extent *o_end,\r\nstruct ext4_extent *start_ext,\r\nstruct ext4_extent *new_ext,\r\nstruct ext4_extent *end_ext)\r\n{\r\nstruct ext4_extent_header *eh;\r\nunsigned long need_slots, slots_range;\r\nint range_to_move, depth, ret;\r\nneed_slots = (start_ext->ee_len ? 1 : 0) + (end_ext->ee_len ? 1 : 0) +\r\n(new_ext->ee_len ? 1 : 0);\r\nslots_range = ((unsigned long)(o_end + 1) - (unsigned long)o_start + 1)\r\n/ sizeof(struct ext4_extent);\r\nrange_to_move = need_slots - slots_range;\r\ndepth = orig_path->p_depth;\r\norig_path += depth;\r\neh = orig_path->p_hdr;\r\nif (depth) {\r\nret = ext4_journal_get_write_access(handle, orig_path->p_bh);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (range_to_move > 0 &&\r\n(range_to_move > le16_to_cpu(eh->eh_max)\r\n- le16_to_cpu(eh->eh_entries))) {\r\nret = mext_insert_across_blocks(handle, orig_inode, o_start,\r\no_end, start_ext, new_ext, end_ext);\r\nif (ret < 0)\r\nreturn ret;\r\n} else\r\nmext_insert_inside_block(o_start, o_end, start_ext, new_ext,\r\nend_ext, eh, range_to_move);\r\nreturn ext4_ext_dirty(handle, orig_inode, orig_path);\r\n}\r\nstatic int\r\nmext_leaf_block(handle_t *handle, struct inode *orig_inode,\r\nstruct ext4_ext_path *orig_path, struct ext4_extent *dext,\r\next4_lblk_t *from)\r\n{\r\nstruct ext4_extent *oext, *o_start, *o_end, *prev_ext;\r\nstruct ext4_extent new_ext, start_ext, end_ext;\r\next4_lblk_t new_ext_end;\r\nint oext_alen, new_ext_alen, end_ext_alen;\r\nint depth = ext_depth(orig_inode);\r\nint ret;\r\nstart_ext.ee_block = end_ext.ee_block = 0;\r\no_start = o_end = oext = orig_path[depth].p_ext;\r\noext_alen = ext4_ext_get_actual_len(oext);\r\nstart_ext.ee_len = end_ext.ee_len = 0;\r\nnew_ext.ee_block = cpu_to_le32(*from);\r\next4_ext_store_pblock(&new_ext, ext4_ext_pblock(dext));\r\nnew_ext.ee_len = dext->ee_len;\r\nnew_ext_alen = ext4_ext_get_actual_len(&new_ext);\r\nnew_ext_end = le32_to_cpu(new_ext.ee_block) + new_ext_alen - 1;\r\nif (le32_to_cpu(oext->ee_block) < le32_to_cpu(new_ext.ee_block) &&\r\nle32_to_cpu(new_ext.ee_block) <\r\nle32_to_cpu(oext->ee_block) + oext_alen) {\r\nstart_ext.ee_len = cpu_to_le16(le32_to_cpu(new_ext.ee_block) -\r\nle32_to_cpu(oext->ee_block));\r\nstart_ext.ee_block = oext->ee_block;\r\ncopy_extent_status(oext, &start_ext);\r\n} else if (oext > EXT_FIRST_EXTENT(orig_path[depth].p_hdr)) {\r\nprev_ext = oext - 1;\r\nif (ext4_can_extents_be_merged(orig_inode, prev_ext,\r\n&new_ext)) {\r\no_start = prev_ext;\r\nstart_ext.ee_len = cpu_to_le16(\r\next4_ext_get_actual_len(prev_ext) +\r\nnew_ext_alen);\r\nstart_ext.ee_block = oext->ee_block;\r\ncopy_extent_status(prev_ext, &start_ext);\r\nnew_ext.ee_len = 0;\r\n}\r\n}\r\nif (le32_to_cpu(oext->ee_block) + oext_alen - 1 < new_ext_end) {\r\nEXT4_ERROR_INODE(orig_inode,\r\n"new_ext_end(%u) should be less than or equal to "\r\n"oext->ee_block(%u) + oext_alen(%d) - 1",\r\nnew_ext_end, le32_to_cpu(oext->ee_block),\r\noext_alen);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (le32_to_cpu(oext->ee_block) <= new_ext_end &&\r\nnew_ext_end < le32_to_cpu(oext->ee_block) + oext_alen - 1) {\r\nend_ext.ee_len =\r\ncpu_to_le16(le32_to_cpu(oext->ee_block) +\r\noext_alen - 1 - new_ext_end);\r\ncopy_extent_status(oext, &end_ext);\r\nend_ext_alen = ext4_ext_get_actual_len(&end_ext);\r\next4_ext_store_pblock(&end_ext,\r\n(ext4_ext_pblock(o_end) + oext_alen - end_ext_alen));\r\nend_ext.ee_block =\r\ncpu_to_le32(le32_to_cpu(o_end->ee_block) +\r\noext_alen - end_ext_alen);\r\n}\r\nret = mext_insert_extents(handle, orig_inode, orig_path, o_start,\r\no_end, &start_ext, &new_ext, &end_ext);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nmext_calc_swap_extents(struct ext4_extent *tmp_dext,\r\nstruct ext4_extent *tmp_oext,\r\next4_lblk_t orig_off, ext4_lblk_t donor_off,\r\next4_lblk_t max_count)\r\n{\r\next4_lblk_t diff, orig_diff;\r\nstruct ext4_extent dext_old, oext_old;\r\nBUG_ON(orig_off != donor_off);\r\nif (orig_off < le32_to_cpu(tmp_oext->ee_block) ||\r\nle32_to_cpu(tmp_oext->ee_block) +\r\next4_ext_get_actual_len(tmp_oext) - 1 < orig_off)\r\nreturn -ENODATA;\r\nif (orig_off < le32_to_cpu(tmp_dext->ee_block) ||\r\nle32_to_cpu(tmp_dext->ee_block) +\r\next4_ext_get_actual_len(tmp_dext) - 1 < orig_off)\r\nreturn -ENODATA;\r\ndext_old = *tmp_dext;\r\noext_old = *tmp_oext;\r\ndiff = donor_off - le32_to_cpu(tmp_dext->ee_block);\r\next4_ext_store_pblock(tmp_dext, ext4_ext_pblock(tmp_dext) + diff);\r\nle32_add_cpu(&tmp_dext->ee_block, diff);\r\nle16_add_cpu(&tmp_dext->ee_len, -diff);\r\nif (max_count < ext4_ext_get_actual_len(tmp_dext))\r\ntmp_dext->ee_len = cpu_to_le16(max_count);\r\norig_diff = orig_off - le32_to_cpu(tmp_oext->ee_block);\r\next4_ext_store_pblock(tmp_oext, ext4_ext_pblock(tmp_oext) + orig_diff);\r\nif (ext4_ext_get_actual_len(tmp_dext) >\r\next4_ext_get_actual_len(tmp_oext) - orig_diff)\r\ntmp_dext->ee_len = cpu_to_le16(le16_to_cpu(tmp_oext->ee_len) -\r\norig_diff);\r\ntmp_oext->ee_len = cpu_to_le16(ext4_ext_get_actual_len(tmp_dext));\r\ncopy_extent_status(&oext_old, tmp_dext);\r\ncopy_extent_status(&dext_old, tmp_oext);\r\nreturn 0;\r\n}\r\nstatic int\r\nmext_check_coverage(struct inode *inode, ext4_lblk_t from, ext4_lblk_t count,\r\nint uninit, int *err)\r\n{\r\nstruct ext4_ext_path *path = NULL;\r\nstruct ext4_extent *ext;\r\nint ret = 0;\r\next4_lblk_t last = from + count;\r\nwhile (from < last) {\r\n*err = get_ext_path(inode, from, &path);\r\nif (*err)\r\ngoto out;\r\next = path[ext_depth(inode)].p_ext;\r\nif (uninit != ext4_ext_is_uninitialized(ext))\r\ngoto out;\r\nfrom += ext4_ext_get_actual_len(ext);\r\next4_ext_drop_refs(path);\r\n}\r\nret = 1;\r\nout:\r\nif (path) {\r\next4_ext_drop_refs(path);\r\nkfree(path);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nmext_replace_branches(handle_t *handle, struct inode *orig_inode,\r\nstruct inode *donor_inode, ext4_lblk_t from,\r\next4_lblk_t count, int *err)\r\n{\r\nstruct ext4_ext_path *orig_path = NULL;\r\nstruct ext4_ext_path *donor_path = NULL;\r\nstruct ext4_extent *oext, *dext;\r\nstruct ext4_extent tmp_dext, tmp_oext;\r\next4_lblk_t orig_off = from, donor_off = from;\r\nint depth;\r\nint replaced_count = 0;\r\nint dext_alen;\r\n*err = ext4_es_remove_extent(orig_inode, from, count);\r\nif (*err)\r\ngoto out;\r\n*err = ext4_es_remove_extent(donor_inode, from, count);\r\nif (*err)\r\ngoto out;\r\n*err = get_ext_path(orig_inode, orig_off, &orig_path);\r\nif (*err)\r\ngoto out;\r\n*err = get_ext_path(donor_inode, donor_off, &donor_path);\r\nif (*err)\r\ngoto out;\r\ndepth = ext_depth(orig_inode);\r\noext = orig_path[depth].p_ext;\r\ntmp_oext = *oext;\r\ndepth = ext_depth(donor_inode);\r\ndext = donor_path[depth].p_ext;\r\nif (unlikely(!dext))\r\ngoto missing_donor_extent;\r\ntmp_dext = *dext;\r\n*err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,\r\ndonor_off, count);\r\nif (*err)\r\ngoto out;\r\nwhile (1) {\r\nif (unlikely(!dext)) {\r\nmissing_donor_extent:\r\nEXT4_ERROR_INODE(donor_inode,\r\n"The extent for donor must be found");\r\n*err = -EIO;\r\ngoto out;\r\n} else if (donor_off != le32_to_cpu(tmp_dext.ee_block)) {\r\nEXT4_ERROR_INODE(donor_inode,\r\n"Donor offset(%u) and the first block of donor "\r\n"extent(%u) should be equal",\r\ndonor_off,\r\nle32_to_cpu(tmp_dext.ee_block));\r\n*err = -EIO;\r\ngoto out;\r\n}\r\n*err = mext_leaf_block(handle, orig_inode,\r\norig_path, &tmp_dext, &orig_off);\r\nif (*err)\r\ngoto out;\r\n*err = mext_leaf_block(handle, donor_inode,\r\ndonor_path, &tmp_oext, &donor_off);\r\nif (*err)\r\ngoto out;\r\ndext_alen = ext4_ext_get_actual_len(&tmp_dext);\r\nreplaced_count += dext_alen;\r\ndonor_off += dext_alen;\r\norig_off += dext_alen;\r\nBUG_ON(replaced_count > count);\r\nif (replaced_count >= count)\r\nbreak;\r\nif (orig_path)\r\next4_ext_drop_refs(orig_path);\r\n*err = get_ext_path(orig_inode, orig_off, &orig_path);\r\nif (*err)\r\ngoto out;\r\ndepth = ext_depth(orig_inode);\r\noext = orig_path[depth].p_ext;\r\ntmp_oext = *oext;\r\nif (donor_path)\r\next4_ext_drop_refs(donor_path);\r\n*err = get_ext_path(donor_inode, donor_off, &donor_path);\r\nif (*err)\r\ngoto out;\r\ndepth = ext_depth(donor_inode);\r\ndext = donor_path[depth].p_ext;\r\ntmp_dext = *dext;\r\n*err = mext_calc_swap_extents(&tmp_dext, &tmp_oext, orig_off,\r\ndonor_off, count - replaced_count);\r\nif (*err)\r\ngoto out;\r\n}\r\nout:\r\nif (orig_path) {\r\next4_ext_drop_refs(orig_path);\r\nkfree(orig_path);\r\n}\r\nif (donor_path) {\r\next4_ext_drop_refs(donor_path);\r\nkfree(donor_path);\r\n}\r\nreturn replaced_count;\r\n}\r\nstatic int\r\nmext_page_double_lock(struct inode *inode1, struct inode *inode2,\r\npgoff_t index, struct page *page[2])\r\n{\r\nstruct address_space *mapping[2];\r\nunsigned fl = AOP_FLAG_NOFS;\r\nBUG_ON(!inode1 || !inode2);\r\nif (inode1 < inode2) {\r\nmapping[0] = inode1->i_mapping;\r\nmapping[1] = inode2->i_mapping;\r\n} else {\r\nmapping[0] = inode2->i_mapping;\r\nmapping[1] = inode1->i_mapping;\r\n}\r\npage[0] = grab_cache_page_write_begin(mapping[0], index, fl);\r\nif (!page[0])\r\nreturn -ENOMEM;\r\npage[1] = grab_cache_page_write_begin(mapping[1], index, fl);\r\nif (!page[1]) {\r\nunlock_page(page[0]);\r\npage_cache_release(page[0]);\r\nreturn -ENOMEM;\r\n}\r\nwait_on_page_writeback(page[0]);\r\nwait_on_page_writeback(page[1]);\r\nif (inode1 > inode2) {\r\nstruct page *tmp;\r\ntmp = page[0];\r\npage[0] = page[1];\r\npage[1] = tmp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmext_page_mkuptodate(struct page *page, unsigned from, unsigned to)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nsector_t block;\r\nstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\r\nunsigned int blocksize, block_start, block_end;\r\nint i, err, nr = 0, partial = 0;\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(PageWriteback(page));\r\nif (PageUptodate(page))\r\nreturn 0;\r\nblocksize = 1 << inode->i_blkbits;\r\nif (!page_has_buffers(page))\r\ncreate_empty_buffers(page, blocksize, 0);\r\nhead = page_buffers(page);\r\nblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\r\nfor (bh = head, block_start = 0; bh != head || !block_start;\r\nblock++, block_start = block_end, bh = bh->b_this_page) {\r\nblock_end = block_start + blocksize;\r\nif (block_end <= from || block_start >= to) {\r\nif (!buffer_uptodate(bh))\r\npartial = 1;\r\ncontinue;\r\n}\r\nif (buffer_uptodate(bh))\r\ncontinue;\r\nif (!buffer_mapped(bh)) {\r\nerr = ext4_get_block(inode, block, bh, 0);\r\nif (err) {\r\nSetPageError(page);\r\nreturn err;\r\n}\r\nif (!buffer_mapped(bh)) {\r\nzero_user(page, block_start, blocksize);\r\nif (!err)\r\nset_buffer_uptodate(bh);\r\ncontinue;\r\n}\r\n}\r\nBUG_ON(nr >= MAX_BUF_PER_PAGE);\r\narr[nr++] = bh;\r\n}\r\nif (!nr)\r\ngoto out;\r\nfor (i = 0; i < nr; i++) {\r\nbh = arr[i];\r\nif (!bh_uptodate_or_lock(bh)) {\r\nerr = bh_submit_read(bh);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nout:\r\nif (!partial)\r\nSetPageUptodate(page);\r\nreturn 0;\r\n}\r\nstatic int\r\nmove_extent_per_page(struct file *o_filp, struct inode *donor_inode,\r\npgoff_t orig_page_offset, int data_offset_in_page,\r\nint block_len_in_page, int uninit, int *err)\r\n{\r\nstruct inode *orig_inode = file_inode(o_filp);\r\nstruct page *pagep[2] = {NULL, NULL};\r\nhandle_t *handle;\r\next4_lblk_t orig_blk_offset;\r\nunsigned long blocksize = orig_inode->i_sb->s_blocksize;\r\nunsigned int w_flags = 0;\r\nunsigned int tmp_data_size, data_size, replaced_size;\r\nint err2, jblocks, retries = 0;\r\nint replaced_count = 0;\r\nint from = data_offset_in_page << orig_inode->i_blkbits;\r\nint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\r\nagain:\r\n*err = 0;\r\njblocks = ext4_writepage_trans_blocks(orig_inode) * 2;\r\nhandle = ext4_journal_start(orig_inode, EXT4_HT_MOVE_EXTENTS, jblocks);\r\nif (IS_ERR(handle)) {\r\n*err = PTR_ERR(handle);\r\nreturn 0;\r\n}\r\nif (segment_eq(get_fs(), KERNEL_DS))\r\nw_flags |= AOP_FLAG_UNINTERRUPTIBLE;\r\norig_blk_offset = orig_page_offset * blocks_per_page +\r\ndata_offset_in_page;\r\nif ((orig_blk_offset + block_len_in_page - 1) ==\r\n((orig_inode->i_size - 1) >> orig_inode->i_blkbits)) {\r\ntmp_data_size = orig_inode->i_size & (blocksize - 1);\r\nif (tmp_data_size == 0)\r\ntmp_data_size = blocksize;\r\ndata_size = tmp_data_size +\r\n((block_len_in_page - 1) << orig_inode->i_blkbits);\r\n} else\r\ndata_size = block_len_in_page << orig_inode->i_blkbits;\r\nreplaced_size = data_size;\r\n*err = mext_page_double_lock(orig_inode, donor_inode, orig_page_offset,\r\npagep);\r\nif (unlikely(*err < 0))\r\ngoto stop_journal;\r\nif (uninit) {\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nuninit = mext_check_coverage(orig_inode, orig_blk_offset,\r\nblock_len_in_page, 1, err);\r\nif (*err)\r\ngoto drop_data_sem;\r\nuninit &= mext_check_coverage(donor_inode, orig_blk_offset,\r\nblock_len_in_page, 1, err);\r\nif (*err)\r\ngoto drop_data_sem;\r\nif (!uninit) {\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\ngoto data_copy;\r\n}\r\nif ((page_has_private(pagep[0]) &&\r\n!try_to_release_page(pagep[0], 0)) ||\r\n(page_has_private(pagep[1]) &&\r\n!try_to_release_page(pagep[1], 0))) {\r\n*err = -EBUSY;\r\ngoto drop_data_sem;\r\n}\r\nreplaced_count = mext_replace_branches(handle, orig_inode,\r\ndonor_inode, orig_blk_offset,\r\nblock_len_in_page, err);\r\ndrop_data_sem:\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\ngoto unlock_pages;\r\n}\r\ndata_copy:\r\n*err = mext_page_mkuptodate(pagep[0], from, from + replaced_size);\r\nif (*err)\r\ngoto unlock_pages;\r\nif ((page_has_private(pagep[0]) && !try_to_release_page(pagep[0], 0)) ||\r\n(page_has_private(pagep[1]) && !try_to_release_page(pagep[1], 0))) {\r\n*err = -EBUSY;\r\ngoto unlock_pages;\r\n}\r\nreplaced_count = mext_replace_branches(handle, orig_inode, donor_inode,\r\norig_blk_offset,\r\nblock_len_in_page, err);\r\nif (*err) {\r\nif (replaced_count) {\r\nblock_len_in_page = replaced_count;\r\nreplaced_size =\r\nblock_len_in_page << orig_inode->i_blkbits;\r\n} else\r\ngoto unlock_pages;\r\n}\r\n*err = __block_write_begin(pagep[0], from, replaced_size,\r\next4_get_block);\r\nif (!*err)\r\n*err = block_commit_write(pagep[0], from, from + replaced_size);\r\nif (unlikely(*err < 0))\r\ngoto repair_branches;\r\n*err = ext4_jbd2_file_inode(handle, orig_inode);\r\nunlock_pages:\r\nunlock_page(pagep[0]);\r\npage_cache_release(pagep[0]);\r\nunlock_page(pagep[1]);\r\npage_cache_release(pagep[1]);\r\nstop_journal:\r\next4_journal_stop(handle);\r\nif (*err == -EBUSY && ext4_should_retry_alloc(orig_inode->i_sb,\r\n&retries))\r\ngoto again;\r\nreturn replaced_count;\r\nrepair_branches:\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nreplaced_count = mext_replace_branches(handle, donor_inode, orig_inode,\r\norig_blk_offset,\r\nblock_len_in_page, &err2);\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\nif (replaced_count != block_len_in_page) {\r\nEXT4_ERROR_INODE_BLOCK(orig_inode, (sector_t)(orig_blk_offset),\r\n"Unable to copy data block,"\r\n" data will be lost.");\r\n*err = -EIO;\r\n}\r\nreplaced_count = 0;\r\ngoto unlock_pages;\r\n}\r\nstatic int\r\nmext_check_arguments(struct inode *orig_inode,\r\nstruct inode *donor_inode, __u64 orig_start,\r\n__u64 donor_start, __u64 *len)\r\n{\r\next4_lblk_t orig_blocks, donor_blocks;\r\nunsigned int blkbits = orig_inode->i_blkbits;\r\nunsigned int blocksize = 1 << blkbits;\r\nif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\r\next4_debug("ext4 move extent: suid or sgid is set"\r\n" to donor file [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\r\nreturn -EPERM;\r\nif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\r\next4_debug("ext4 move extent: The argument files should "\r\n"not be swapfile [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\r\next4_debug("ext4 move extent: orig file is not extents "\r\n"based file [ino:orig %lu]\n", orig_inode->i_ino);\r\nreturn -EOPNOTSUPP;\r\n} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\r\next4_debug("ext4 move extent: donor file is not extents "\r\n"based file [ino:donor %lu]\n", donor_inode->i_ino);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\r\next4_debug("ext4 move extent: File size is 0 byte\n");\r\nreturn -EINVAL;\r\n}\r\nif (orig_start != donor_start) {\r\next4_debug("ext4 move extent: orig and donor's start "\r\n"offset are not same [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif ((orig_start >= EXT_MAX_BLOCKS) ||\r\n(*len > EXT_MAX_BLOCKS) ||\r\n(orig_start + *len >= EXT_MAX_BLOCKS)) {\r\next4_debug("ext4 move extent: Can't handle over [%u] blocks "\r\n"[ino:orig %lu, donor %lu]\n", EXT_MAX_BLOCKS,\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_inode->i_size > donor_inode->i_size) {\r\ndonor_blocks = (donor_inode->i_size + blocksize - 1) >> blkbits;\r\nif (orig_start >= donor_blocks) {\r\next4_debug("ext4 move extent: orig start offset "\r\n"[%llu] should be less than donor file blocks "\r\n"[%u] [ino:orig %lu, donor %lu]\n",\r\norig_start, donor_blocks,\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_start + *len > donor_blocks) {\r\next4_debug("ext4 move extent: End offset [%llu] should "\r\n"be less than donor file blocks [%u]."\r\n"So adjust length from %llu to %llu "\r\n"[ino:orig %lu, donor %lu]\n",\r\norig_start + *len, donor_blocks,\r\n*len, donor_blocks - orig_start,\r\norig_inode->i_ino, donor_inode->i_ino);\r\n*len = donor_blocks - orig_start;\r\n}\r\n} else {\r\norig_blocks = (orig_inode->i_size + blocksize - 1) >> blkbits;\r\nif (orig_start >= orig_blocks) {\r\next4_debug("ext4 move extent: start offset [%llu] "\r\n"should be less than original file blocks "\r\n"[%u] [ino:orig %lu, donor %lu]\n",\r\norig_start, orig_blocks,\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_start + *len > orig_blocks) {\r\next4_debug("ext4 move extent: Adjust length "\r\n"from %llu to %llu. Because it should be "\r\n"less than original file blocks "\r\n"[ino:orig %lu, donor %lu]\n",\r\n*len, orig_blocks - orig_start,\r\norig_inode->i_ino, donor_inode->i_ino);\r\n*len = orig_blocks - orig_start;\r\n}\r\n}\r\nif (!*len) {\r\next4_debug("ext4 move extent: len should not be 0 "\r\n"[ino:orig %lu, donor %lu]\n", orig_inode->i_ino,\r\ndonor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\next4_move_extents(struct file *o_filp, struct file *d_filp,\r\n__u64 orig_start, __u64 donor_start, __u64 len,\r\n__u64 *moved_len)\r\n{\r\nstruct inode *orig_inode = file_inode(o_filp);\r\nstruct inode *donor_inode = file_inode(d_filp);\r\nstruct ext4_ext_path *orig_path = NULL, *holecheck_path = NULL;\r\nstruct ext4_extent *ext_prev, *ext_cur, *ext_dummy;\r\next4_lblk_t block_start = orig_start;\r\next4_lblk_t block_end, seq_start, add_blocks, file_end, seq_blocks = 0;\r\next4_lblk_t rest_blocks;\r\npgoff_t orig_page_offset = 0, seq_end_page;\r\nint ret, depth, last_extent = 0;\r\nint blocks_per_page = PAGE_CACHE_SIZE >> orig_inode->i_blkbits;\r\nint data_offset_in_page;\r\nint block_len_in_page;\r\nint uninit;\r\nif (orig_inode->i_sb != donor_inode->i_sb) {\r\next4_debug("ext4 move extent: The argument files "\r\n"should be in same FS [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (orig_inode == donor_inode) {\r\next4_debug("ext4 move extent: The argument files should not "\r\n"be same inode [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (!S_ISREG(orig_inode->i_mode) || !S_ISREG(donor_inode->i_mode)) {\r\next4_debug("ext4 move extent: The argument files should be "\r\n"regular file [ino:orig %lu, donor %lu]\n",\r\norig_inode->i_ino, donor_inode->i_ino);\r\nreturn -EINVAL;\r\n}\r\nif (ext4_should_journal_data(orig_inode) ||\r\next4_should_journal_data(donor_inode)) {\r\nreturn -EINVAL;\r\n}\r\nlock_two_nondirectories(orig_inode, donor_inode);\r\next4_inode_block_unlocked_dio(orig_inode);\r\next4_inode_block_unlocked_dio(donor_inode);\r\ninode_dio_wait(orig_inode);\r\ninode_dio_wait(donor_inode);\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nret = mext_check_arguments(orig_inode, donor_inode, orig_start,\r\ndonor_start, &len);\r\nif (ret)\r\ngoto out;\r\nfile_end = (i_size_read(orig_inode) - 1) >> orig_inode->i_blkbits;\r\nblock_end = block_start + len - 1;\r\nif (file_end < block_end)\r\nlen -= block_end - file_end;\r\nret = get_ext_path(orig_inode, block_start, &orig_path);\r\nif (ret)\r\ngoto out;\r\nret = get_ext_path(orig_inode, block_start, &holecheck_path);\r\nif (ret)\r\ngoto out;\r\ndepth = ext_depth(orig_inode);\r\next_cur = holecheck_path[depth].p_ext;\r\nif (le32_to_cpu(ext_cur->ee_block) +\r\next4_ext_get_actual_len(ext_cur) - 1 < block_start) {\r\nlast_extent = mext_next_extent(orig_inode,\r\nholecheck_path, &ext_cur);\r\nif (last_extent < 0) {\r\nret = last_extent;\r\ngoto out;\r\n}\r\nlast_extent = mext_next_extent(orig_inode, orig_path,\r\n&ext_dummy);\r\nif (last_extent < 0) {\r\nret = last_extent;\r\ngoto out;\r\n}\r\nseq_start = le32_to_cpu(ext_cur->ee_block);\r\n} else if (le32_to_cpu(ext_cur->ee_block) > block_start)\r\nseq_start = le32_to_cpu(ext_cur->ee_block);\r\nelse\r\nseq_start = block_start;\r\nif (le32_to_cpu(ext_cur->ee_block) > block_end) {\r\next4_debug("ext4 move extent: The specified range of file "\r\n"may be the hole\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nadd_blocks = min(le32_to_cpu(ext_cur->ee_block) +\r\next4_ext_get_actual_len(ext_cur), block_end + 1) -\r\nmax(le32_to_cpu(ext_cur->ee_block), block_start);\r\nwhile (!last_extent && le32_to_cpu(ext_cur->ee_block) <= block_end) {\r\nseq_blocks += add_blocks;\r\nif (seq_start + seq_blocks - 1 > block_end)\r\nseq_blocks = block_end - seq_start + 1;\r\next_prev = ext_cur;\r\nlast_extent = mext_next_extent(orig_inode, holecheck_path,\r\n&ext_cur);\r\nif (last_extent < 0) {\r\nret = last_extent;\r\nbreak;\r\n}\r\nadd_blocks = ext4_ext_get_actual_len(ext_cur);\r\nif (ext4_can_extents_be_merged(orig_inode,\r\next_prev, ext_cur) &&\r\nblock_end >= le32_to_cpu(ext_cur->ee_block) &&\r\n!last_extent)\r\ncontinue;\r\nuninit = ext4_ext_is_uninitialized(ext_prev);\r\ndata_offset_in_page = seq_start % blocks_per_page;\r\nif (data_offset_in_page + seq_blocks > blocks_per_page) {\r\nblock_len_in_page =\r\nblocks_per_page - data_offset_in_page;\r\n} else {\r\nblock_len_in_page = seq_blocks;\r\n}\r\norig_page_offset = seq_start >>\r\n(PAGE_CACHE_SHIFT - orig_inode->i_blkbits);\r\nseq_end_page = (seq_start + seq_blocks - 1) >>\r\n(PAGE_CACHE_SHIFT - orig_inode->i_blkbits);\r\nseq_start = le32_to_cpu(ext_cur->ee_block);\r\nrest_blocks = seq_blocks;\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\nwhile (orig_page_offset <= seq_end_page) {\r\nblock_len_in_page = move_extent_per_page(\r\no_filp, donor_inode,\r\norig_page_offset,\r\ndata_offset_in_page,\r\nblock_len_in_page, uninit,\r\n&ret);\r\n*moved_len += block_len_in_page;\r\nif (ret < 0)\r\nbreak;\r\nif (*moved_len > len) {\r\nEXT4_ERROR_INODE(orig_inode,\r\n"We replaced blocks too much! "\r\n"sum of replaced: %llu requested: %llu",\r\n*moved_len, len);\r\nret = -EIO;\r\nbreak;\r\n}\r\norig_page_offset++;\r\ndata_offset_in_page = 0;\r\nrest_blocks -= block_len_in_page;\r\nif (rest_blocks > blocks_per_page)\r\nblock_len_in_page = blocks_per_page;\r\nelse\r\nblock_len_in_page = rest_blocks;\r\n}\r\next4_double_down_write_data_sem(orig_inode, donor_inode);\r\nif (ret < 0)\r\nbreak;\r\nif (holecheck_path)\r\next4_ext_drop_refs(holecheck_path);\r\nret = get_ext_path(orig_inode, seq_start, &holecheck_path);\r\nif (ret)\r\nbreak;\r\ndepth = holecheck_path->p_depth;\r\nif (orig_path)\r\next4_ext_drop_refs(orig_path);\r\nret = get_ext_path(orig_inode, seq_start, &orig_path);\r\nif (ret)\r\nbreak;\r\next_cur = holecheck_path[depth].p_ext;\r\nadd_blocks = ext4_ext_get_actual_len(ext_cur);\r\nseq_blocks = 0;\r\n}\r\nout:\r\nif (*moved_len) {\r\next4_discard_preallocations(orig_inode);\r\next4_discard_preallocations(donor_inode);\r\n}\r\nif (orig_path) {\r\next4_ext_drop_refs(orig_path);\r\nkfree(orig_path);\r\n}\r\nif (holecheck_path) {\r\next4_ext_drop_refs(holecheck_path);\r\nkfree(holecheck_path);\r\n}\r\next4_double_up_write_data_sem(orig_inode, donor_inode);\r\next4_inode_resume_unlocked_dio(orig_inode);\r\next4_inode_resume_unlocked_dio(donor_inode);\r\nunlock_two_nondirectories(orig_inode, donor_inode);\r\nreturn ret;\r\n}
