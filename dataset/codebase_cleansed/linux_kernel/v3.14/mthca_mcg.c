static int find_mgm(struct mthca_dev *dev,\r\nu8 *gid, struct mthca_mailbox *mgm_mailbox,\r\nu16 *hash, int *prev, int *index)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nstruct mthca_mgm *mgm = mgm_mailbox->buf;\r\nu8 *mgid;\r\nint err;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn -ENOMEM;\r\nmgid = mailbox->buf;\r\nmemcpy(mgid, gid, 16);\r\nerr = mthca_MGID_HASH(dev, mailbox, hash);\r\nif (err) {\r\nmthca_err(dev, "MGID_HASH failed (%d)\n", err);\r\ngoto out;\r\n}\r\nif (0)\r\nmthca_dbg(dev, "Hash for %pI6 is %04x\n", gid, *hash);\r\n*index = *hash;\r\n*prev = -1;\r\ndo {\r\nerr = mthca_READ_MGM(dev, *index, mgm_mailbox);\r\nif (err) {\r\nmthca_err(dev, "READ_MGM failed (%d)\n", err);\r\ngoto out;\r\n}\r\nif (!memcmp(mgm->gid, zero_gid, 16)) {\r\nif (*index != *hash) {\r\nmthca_err(dev, "Found zero MGID in AMGM.\n");\r\nerr = -EINVAL;\r\n}\r\ngoto out;\r\n}\r\nif (!memcmp(mgm->gid, gid, 16))\r\ngoto out;\r\n*prev = *index;\r\n*index = be32_to_cpu(mgm->next_gid_index) >> 6;\r\n} while (*index);\r\n*index = -1;\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nstruct mthca_dev *dev = to_mdev(ibqp->device);\r\nstruct mthca_mailbox *mailbox;\r\nstruct mthca_mgm *mgm;\r\nu16 hash;\r\nint index, prev;\r\nint link = 0;\r\nint i;\r\nint err;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmgm = mailbox->buf;\r\nmutex_lock(&dev->mcg_table.mutex);\r\nerr = find_mgm(dev, gid->raw, mailbox, &hash, &prev, &index);\r\nif (err)\r\ngoto out;\r\nif (index != -1) {\r\nif (!memcmp(mgm->gid, zero_gid, 16))\r\nmemcpy(mgm->gid, gid->raw, 16);\r\n} else {\r\nlink = 1;\r\nindex = mthca_alloc(&dev->mcg_table.alloc);\r\nif (index == -1) {\r\nmthca_err(dev, "No AMGM entries left\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = mthca_READ_MGM(dev, index, mailbox);\r\nif (err) {\r\nmthca_err(dev, "READ_MGM failed (%d)\n", err);\r\ngoto out;\r\n}\r\nmemset(mgm, 0, sizeof *mgm);\r\nmemcpy(mgm->gid, gid->raw, 16);\r\n}\r\nfor (i = 0; i < MTHCA_QP_PER_MGM; ++i)\r\nif (mgm->qp[i] == cpu_to_be32(ibqp->qp_num | (1 << 31))) {\r\nmthca_dbg(dev, "QP %06x already a member of MGM\n",\r\nibqp->qp_num);\r\nerr = 0;\r\ngoto out;\r\n} else if (!(mgm->qp[i] & cpu_to_be32(1 << 31))) {\r\nmgm->qp[i] = cpu_to_be32(ibqp->qp_num | (1 << 31));\r\nbreak;\r\n}\r\nif (i == MTHCA_QP_PER_MGM) {\r\nmthca_err(dev, "MGM at index %x is full.\n", index);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = mthca_WRITE_MGM(dev, index, mailbox);\r\nif (err) {\r\nmthca_err(dev, "WRITE_MGM failed %d\n", err);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!link)\r\ngoto out;\r\nerr = mthca_READ_MGM(dev, prev, mailbox);\r\nif (err) {\r\nmthca_err(dev, "READ_MGM failed %d\n", err);\r\ngoto out;\r\n}\r\nmgm->next_gid_index = cpu_to_be32(index << 6);\r\nerr = mthca_WRITE_MGM(dev, prev, mailbox);\r\nif (err)\r\nmthca_err(dev, "WRITE_MGM returned %d\n", err);\r\nout:\r\nif (err && link && index != -1) {\r\nBUG_ON(index < dev->limits.num_mgms);\r\nmthca_free(&dev->mcg_table.alloc, index);\r\n}\r\nmutex_unlock(&dev->mcg_table.mutex);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\nstruct mthca_dev *dev = to_mdev(ibqp->device);\r\nstruct mthca_mailbox *mailbox;\r\nstruct mthca_mgm *mgm;\r\nu16 hash;\r\nint prev, index;\r\nint i, loc;\r\nint err;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmgm = mailbox->buf;\r\nmutex_lock(&dev->mcg_table.mutex);\r\nerr = find_mgm(dev, gid->raw, mailbox, &hash, &prev, &index);\r\nif (err)\r\ngoto out;\r\nif (index == -1) {\r\nmthca_err(dev, "MGID %pI6 not found\n", gid->raw);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor (loc = -1, i = 0; i < MTHCA_QP_PER_MGM; ++i) {\r\nif (mgm->qp[i] == cpu_to_be32(ibqp->qp_num | (1 << 31)))\r\nloc = i;\r\nif (!(mgm->qp[i] & cpu_to_be32(1 << 31)))\r\nbreak;\r\n}\r\nif (loc == -1) {\r\nmthca_err(dev, "QP %06x not found in MGM\n", ibqp->qp_num);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmgm->qp[loc] = mgm->qp[i - 1];\r\nmgm->qp[i - 1] = 0;\r\nerr = mthca_WRITE_MGM(dev, index, mailbox);\r\nif (err) {\r\nmthca_err(dev, "WRITE_MGM returned %d\n", err);\r\ngoto out;\r\n}\r\nif (i != 1)\r\ngoto out;\r\nif (prev == -1) {\r\nint amgm_index_to_free = be32_to_cpu(mgm->next_gid_index) >> 6;\r\nif (amgm_index_to_free) {\r\nerr = mthca_READ_MGM(dev, amgm_index_to_free,\r\nmailbox);\r\nif (err) {\r\nmthca_err(dev, "READ_MGM returned %d\n", err);\r\ngoto out;\r\n}\r\n} else\r\nmemset(mgm->gid, 0, 16);\r\nerr = mthca_WRITE_MGM(dev, index, mailbox);\r\nif (err) {\r\nmthca_err(dev, "WRITE_MGM returned %d\n", err);\r\ngoto out;\r\n}\r\nif (amgm_index_to_free) {\r\nBUG_ON(amgm_index_to_free < dev->limits.num_mgms);\r\nmthca_free(&dev->mcg_table.alloc, amgm_index_to_free);\r\n}\r\n} else {\r\nint curr_next_index = be32_to_cpu(mgm->next_gid_index) >> 6;\r\nerr = mthca_READ_MGM(dev, prev, mailbox);\r\nif (err) {\r\nmthca_err(dev, "READ_MGM returned %d\n", err);\r\ngoto out;\r\n}\r\nmgm->next_gid_index = cpu_to_be32(curr_next_index << 6);\r\nerr = mthca_WRITE_MGM(dev, prev, mailbox);\r\nif (err) {\r\nmthca_err(dev, "WRITE_MGM returned %d\n", err);\r\ngoto out;\r\n}\r\nBUG_ON(index < dev->limits.num_mgms);\r\nmthca_free(&dev->mcg_table.alloc, index);\r\n}\r\nout:\r\nmutex_unlock(&dev->mcg_table.mutex);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_init_mcg_table(struct mthca_dev *dev)\r\n{\r\nint err;\r\nint table_size = dev->limits.num_mgms + dev->limits.num_amgms;\r\nerr = mthca_alloc_init(&dev->mcg_table.alloc,\r\ntable_size,\r\ntable_size - 1,\r\ndev->limits.num_mgms);\r\nif (err)\r\nreturn err;\r\nmutex_init(&dev->mcg_table.mutex);\r\nreturn 0;\r\n}\r\nvoid mthca_cleanup_mcg_table(struct mthca_dev *dev)\r\n{\r\nmthca_alloc_cleanup(&dev->mcg_table.alloc);\r\n}
