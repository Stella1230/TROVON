int net_ratelimit(void)\r\n{\r\nreturn __ratelimit(&net_ratelimit_state);\r\n}\r\n__be32 in_aton(const char *str)\r\n{\r\nunsigned long l;\r\nunsigned int val;\r\nint i;\r\nl = 0;\r\nfor (i = 0; i < 4; i++) {\r\nl <<= 8;\r\nif (*str != '\0') {\r\nval = 0;\r\nwhile (*str != '\0' && *str != '.' && *str != '\n') {\r\nval *= 10;\r\nval += *str - '0';\r\nstr++;\r\n}\r\nl |= val;\r\nif (*str != '\0')\r\nstr++;\r\n}\r\n}\r\nreturn htonl(l);\r\n}\r\nstatic inline int xdigit2bin(char c, int delim)\r\n{\r\nint val;\r\nif (c == delim || c == '\0')\r\nreturn IN6PTON_DELIM;\r\nif (c == ':')\r\nreturn IN6PTON_COLON_MASK;\r\nif (c == '.')\r\nreturn IN6PTON_DOT;\r\nval = hex_to_bin(c);\r\nif (val >= 0)\r\nreturn val | IN6PTON_XDIGIT | (val < 10 ? IN6PTON_DIGIT : 0);\r\nif (delim == -1)\r\nreturn IN6PTON_DELIM;\r\nreturn IN6PTON_UNKNOWN;\r\n}\r\nint in4_pton(const char *src, int srclen,\r\nu8 *dst,\r\nint delim, const char **end)\r\n{\r\nconst char *s;\r\nu8 *d;\r\nu8 dbuf[4];\r\nint ret = 0;\r\nint i;\r\nint w = 0;\r\nif (srclen < 0)\r\nsrclen = strlen(src);\r\ns = src;\r\nd = dbuf;\r\ni = 0;\r\nwhile(1) {\r\nint c;\r\nc = xdigit2bin(srclen > 0 ? *s : '\0', delim);\r\nif (!(c & (IN6PTON_DIGIT | IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK))) {\r\ngoto out;\r\n}\r\nif (c & (IN6PTON_DOT | IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (w == 0)\r\ngoto out;\r\n*d++ = w & 0xff;\r\nw = 0;\r\ni++;\r\nif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (i != 4)\r\ngoto out;\r\nbreak;\r\n}\r\ngoto cont;\r\n}\r\nw = (w * 10) + c;\r\nif ((w & 0xffff) > 255) {\r\ngoto out;\r\n}\r\ncont:\r\nif (i >= 4)\r\ngoto out;\r\ns++;\r\nsrclen--;\r\n}\r\nret = 1;\r\nmemcpy(dst, dbuf, sizeof(dbuf));\r\nout:\r\nif (end)\r\n*end = s;\r\nreturn ret;\r\n}\r\nint in6_pton(const char *src, int srclen,\r\nu8 *dst,\r\nint delim, const char **end)\r\n{\r\nconst char *s, *tok = NULL;\r\nu8 *d, *dc = NULL;\r\nu8 dbuf[16];\r\nint ret = 0;\r\nint i;\r\nint state = IN6PTON_COLON_1_2 | IN6PTON_XDIGIT | IN6PTON_NULL;\r\nint w = 0;\r\nmemset(dbuf, 0, sizeof(dbuf));\r\ns = src;\r\nd = dbuf;\r\nif (srclen < 0)\r\nsrclen = strlen(src);\r\nwhile (1) {\r\nint c;\r\nc = xdigit2bin(srclen > 0 ? *s : '\0', delim);\r\nif (!(c & state))\r\ngoto out;\r\nif (c & (IN6PTON_DELIM | IN6PTON_COLON_MASK)) {\r\nif (!(state & IN6PTON_NULL)) {\r\n*d++ = (w >> 8) & 0xff;\r\n*d++ = w & 0xff;\r\n}\r\nw = 0;\r\nif (c & IN6PTON_DELIM) {\r\nbreak;\r\n}\r\nswitch (state & IN6PTON_COLON_MASK) {\r\ncase IN6PTON_COLON_2:\r\ndc = d;\r\nstate = IN6PTON_XDIGIT | IN6PTON_DELIM;\r\nif (dc - dbuf >= sizeof(dbuf))\r\nstate |= IN6PTON_NULL;\r\nbreak;\r\ncase IN6PTON_COLON_1|IN6PTON_COLON_1_2:\r\nstate = IN6PTON_XDIGIT | IN6PTON_COLON_2;\r\nbreak;\r\ncase IN6PTON_COLON_1:\r\nstate = IN6PTON_XDIGIT;\r\nbreak;\r\ncase IN6PTON_COLON_1_2:\r\nstate = IN6PTON_COLON_2;\r\nbreak;\r\ndefault:\r\nstate = 0;\r\n}\r\ntok = s + 1;\r\ngoto cont;\r\n}\r\nif (c & IN6PTON_DOT) {\r\nret = in4_pton(tok ? tok : s, srclen + (int)(s - tok), d, delim, &s);\r\nif (ret > 0) {\r\nd += 4;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nw = (w << 4) | (0xff & c);\r\nstate = IN6PTON_COLON_1 | IN6PTON_DELIM;\r\nif (!(w & 0xf000)) {\r\nstate |= IN6PTON_XDIGIT;\r\n}\r\nif (!dc && d + 2 < dbuf + sizeof(dbuf)) {\r\nstate |= IN6PTON_COLON_1_2;\r\nstate &= ~IN6PTON_DELIM;\r\n}\r\nif (d + 2 >= dbuf + sizeof(dbuf)) {\r\nstate &= ~(IN6PTON_COLON_1|IN6PTON_COLON_1_2);\r\n}\r\ncont:\r\nif ((dc && d + 4 < dbuf + sizeof(dbuf)) ||\r\nd + 4 == dbuf + sizeof(dbuf)) {\r\nstate |= IN6PTON_DOT;\r\n}\r\nif (d >= dbuf + sizeof(dbuf)) {\r\nstate &= ~(IN6PTON_XDIGIT|IN6PTON_COLON_MASK);\r\n}\r\ns++;\r\nsrclen--;\r\n}\r\ni = 15; d--;\r\nif (dc) {\r\nwhile(d >= dc)\r\ndst[i--] = *d--;\r\nwhile(i >= dc - dbuf)\r\ndst[i--] = 0;\r\nwhile(i >= 0)\r\ndst[i--] = *d--;\r\n} else\r\nmemcpy(dst, dbuf, sizeof(dbuf));\r\nret = 1;\r\nout:\r\nif (end)\r\n*end = s;\r\nreturn ret;\r\n}\r\nvoid inet_proto_csum_replace4(__sum16 *sum, struct sk_buff *skb,\r\n__be32 from, __be32 to, int pseudohdr)\r\n{\r\n__be32 diff[] = { ~from, to };\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\n*sum = csum_fold(csum_partial(diff, sizeof(diff),\r\n~csum_unfold(*sum)));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\r\nskb->csum = ~csum_partial(diff, sizeof(diff),\r\n~skb->csum);\r\n} else if (pseudohdr)\r\n*sum = ~csum_fold(csum_partial(diff, sizeof(diff),\r\ncsum_unfold(*sum)));\r\n}\r\nvoid inet_proto_csum_replace16(__sum16 *sum, struct sk_buff *skb,\r\nconst __be32 *from, const __be32 *to,\r\nint pseudohdr)\r\n{\r\n__be32 diff[] = {\r\n~from[0], ~from[1], ~from[2], ~from[3],\r\nto[0], to[1], to[2], to[3],\r\n};\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\n*sum = csum_fold(csum_partial(diff, sizeof(diff),\r\n~csum_unfold(*sum)));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE && pseudohdr)\r\nskb->csum = ~csum_partial(diff, sizeof(diff),\r\n~skb->csum);\r\n} else if (pseudohdr)\r\n*sum = ~csum_fold(csum_partial(diff, sizeof(diff),\r\ncsum_unfold(*sum)));\r\n}\r\nstatic void __net_random_once_deferred(struct work_struct *w)\r\n{\r\nstruct __net_random_once_work *work =\r\ncontainer_of(w, struct __net_random_once_work, work);\r\nif (!static_key_enabled(work->key))\r\nstatic_key_slow_inc(work->key);\r\nkfree(work);\r\n}\r\nstatic void __net_random_once_disable_jump(struct static_key *key)\r\n{\r\nstruct __net_random_once_work *w;\r\nw = kmalloc(sizeof(*w), GFP_ATOMIC);\r\nif (!w)\r\nreturn;\r\nINIT_WORK(&w->work, __net_random_once_deferred);\r\nw->key = key;\r\nschedule_work(&w->work);\r\n}\r\nbool __net_get_random_once(void *buf, int nbytes, bool *done,\r\nstruct static_key *done_key)\r\n{\r\nstatic DEFINE_SPINLOCK(lock);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\nif (*done) {\r\nspin_unlock_irqrestore(&lock, flags);\r\nreturn false;\r\n}\r\nget_random_bytes(buf, nbytes);\r\n*done = true;\r\nspin_unlock_irqrestore(&lock, flags);\r\n__net_random_once_disable_jump(done_key);\r\nreturn true;\r\n}
