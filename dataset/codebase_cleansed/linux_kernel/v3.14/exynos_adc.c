static inline unsigned int exynos_adc_get_version(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_adc_match, pdev->dev.of_node);\r\nreturn (unsigned int)match->data;\r\n}\r\nstatic int exynos_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nunsigned long timeout;\r\nu32 con1, con2;\r\nif (mask != IIO_CHAN_INFO_RAW)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nif (info->version == ADC_V2) {\r\ncon2 = readl(ADC_V2_CON2(info->regs));\r\ncon2 &= ~ADC_V2_CON2_ACH_MASK;\r\ncon2 |= ADC_V2_CON2_ACH_SEL(chan->address);\r\nwritel(con2, ADC_V2_CON2(info->regs));\r\ncon1 = readl(ADC_V2_CON1(info->regs));\r\nwritel(con1 | ADC_CON_EN_START,\r\nADC_V2_CON1(info->regs));\r\n} else {\r\nwritel(chan->address, ADC_V1_MUX(info->regs));\r\ncon1 = readl(ADC_V1_CON(info->regs));\r\nwritel(con1 | ADC_CON_EN_START,\r\nADC_V1_CON(info->regs));\r\n}\r\ntimeout = wait_for_completion_interruptible_timeout\r\n(&info->completion, EXYNOS_ADC_TIMEOUT);\r\n*val = info->value;\r\nmutex_unlock(&indio_dev->mlock);\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic irqreturn_t exynos_adc_isr(int irq, void *dev_id)\r\n{\r\nstruct exynos_adc *info = (struct exynos_adc *)dev_id;\r\ninfo->value = readl(ADC_V1_DATX(info->regs)) &\r\nADC_DATX_MASK;\r\nif (info->version == ADC_V2)\r\nwritel(1, ADC_V2_INT_ST(info->regs));\r\nelse\r\nwritel(1, ADC_V1_INTCLR(info->regs));\r\ncomplete(&info->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nif (readval == NULL)\r\nreturn -EINVAL;\r\n*readval = readl(info->regs + reg);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_remove_devices(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic void exynos_adc_hw_init(struct exynos_adc *info)\r\n{\r\nu32 con1, con2;\r\nif (info->version == ADC_V2) {\r\ncon1 = ADC_V2_CON1_SOFT_RESET;\r\nwritel(con1, ADC_V2_CON1(info->regs));\r\ncon2 = ADC_V2_CON2_OSEL | ADC_V2_CON2_ESEL |\r\nADC_V2_CON2_HIGHF | ADC_V2_CON2_C_TIME(0);\r\nwritel(con2, ADC_V2_CON2(info->regs));\r\nwritel(1, ADC_V2_INT_EN(info->regs));\r\n} else {\r\ncon1 = ADC_V1_CON_PRSCLV(49) | ADC_V1_CON_PRSCEN;\r\ncon1 |= ADC_V1_CON_RES;\r\nwritel(con1, ADC_V1_CON(info->regs));\r\n}\r\n}\r\nstatic int exynos_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_adc *info = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct iio_dev *indio_dev = NULL;\r\nstruct resource *mem;\r\nint ret = -ENODEV;\r\nint irq;\r\nif (!np)\r\nreturn ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct exynos_adc));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ninfo->enable_reg = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->enable_reg))\r\nreturn PTR_ERR(info->enable_reg);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\ninfo->irq = irq;\r\ninit_completion(&info->completion);\r\nret = request_irq(info->irq, exynos_adc_isr,\r\n0, dev_name(&pdev->dev), info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed requesting irq, irq = %d\n",\r\ninfo->irq);\r\nreturn ret;\r\n}\r\nwritel(1, info->enable_reg);\r\ninfo->clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed getting clock, err = %ld\n",\r\nPTR_ERR(info->clk));\r\nret = PTR_ERR(info->clk);\r\ngoto err_irq;\r\n}\r\ninfo->vdd = devm_regulator_get(&pdev->dev, "vdd");\r\nif (IS_ERR(info->vdd)) {\r\ndev_err(&pdev->dev, "failed getting regulator, err = %ld\n",\r\nPTR_ERR(info->vdd));\r\nret = PTR_ERR(info->vdd);\r\ngoto err_irq;\r\n}\r\ninfo->version = exynos_adc_get_version(pdev);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &exynos_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = exynos_adc_iio_channels;\r\nif (info->version == ADC_V1)\r\nindio_dev->num_channels = MAX_ADC_V1_CHANNELS;\r\nelse\r\nindio_dev->num_channels = MAX_ADC_V2_CHANNELS;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto err_irq;\r\nret = regulator_enable(info->vdd);\r\nif (ret)\r\ngoto err_iio_dev;\r\nclk_prepare_enable(info->clk);\r\nexynos_adc_hw_init(info);\r\nret = of_platform_populate(np, exynos_adc_match, NULL, &pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed adding child nodes\n");\r\ngoto err_of_populate;\r\n}\r\nreturn 0;\r\nerr_of_populate:\r\ndevice_for_each_child(&pdev->dev, NULL,\r\nexynos_adc_remove_devices);\r\nregulator_disable(info->vdd);\r\nclk_disable_unprepare(info->clk);\r\nerr_iio_dev:\r\niio_device_unregister(indio_dev);\r\nerr_irq:\r\nfree_irq(info->irq, info);\r\nreturn ret;\r\n}\r\nstatic int exynos_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\ndevice_for_each_child(&pdev->dev, NULL,\r\nexynos_adc_remove_devices);\r\nregulator_disable(info->vdd);\r\nclk_disable_unprepare(info->clk);\r\nwritel(0, info->enable_reg);\r\niio_device_unregister(indio_dev);\r\nfree_irq(info->irq, info);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nu32 con;\r\nif (info->version == ADC_V2) {\r\ncon = readl(ADC_V2_CON1(info->regs));\r\ncon &= ~ADC_CON_EN_START;\r\nwritel(con, ADC_V2_CON1(info->regs));\r\n} else {\r\ncon = readl(ADC_V1_CON(info->regs));\r\ncon |= ADC_V1_CON_STANDBY;\r\nwritel(con, ADC_V1_CON(info->regs));\r\n}\r\nclk_disable_unprepare(info->clk);\r\nwritel(0, info->enable_reg);\r\nregulator_disable(info->vdd);\r\nreturn 0;\r\n}\r\nstatic int exynos_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct exynos_adc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vdd);\r\nif (ret)\r\nreturn ret;\r\nwritel(1, info->enable_reg);\r\nclk_prepare_enable(info->clk);\r\nexynos_adc_hw_init(info);\r\nreturn 0;\r\n}
