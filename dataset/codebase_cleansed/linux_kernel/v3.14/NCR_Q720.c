static irqreturn_t\r\nNCR_Q720_intr(int irq, void *data)\r\n{\r\nstruct NCR_Q720_private *p = (struct NCR_Q720_private *)data;\r\n__u8 sir = (readb(p->mem_base + 0x0d) & 0xf0) >> 4;\r\n__u8 siop;\r\nsir |= ~p->irq_enable;\r\nif(sir == 0xff)\r\nreturn IRQ_NONE;\r\nwhile((siop = ffz(sir)) < p->siops) {\r\nsir |= 1<<siop;\r\nncr53c8xx_intr(irq, p->hosts[siop]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init\r\nNCR_Q720_probe_one(struct NCR_Q720_private *p, int siop,\r\nint irq, int slot, __u32 paddr, void __iomem *vaddr)\r\n{\r\nstruct ncr_device device;\r\n__u8 scsi_id;\r\nstatic int unit = 0;\r\n__u8 scsr1 = readb(vaddr + NCR_Q720_SCSR_OFFSET + 1);\r\n__u8 differential = readb(vaddr + NCR_Q720_SCSR_OFFSET) & 0x20;\r\n__u8 version;\r\nint error;\r\nscsi_id = scsr1 >> 4;\r\nscsr1 |= 0x02;\r\nscsr1 |= 0x04;\r\nwriteb(scsr1, vaddr + NCR_Q720_SCSR_OFFSET + 1);\r\nudelay(10);\r\nversion = readb(vaddr + 0x18) >> 4;\r\nmemset(&device, 0, sizeof(struct ncr_device));\r\ndevice.chip = q720_chip;\r\ndevice.chip.revision_id = version;\r\ndevice.host_id = scsi_id;\r\ndevice.dev = p->dev;\r\ndevice.slot.base = paddr;\r\ndevice.slot.base_c = paddr;\r\ndevice.slot.base_v = vaddr;\r\ndevice.slot.irq = irq;\r\ndevice.differential = differential ? 2 : 0;\r\nprintk("Q720 probe unit %d (siop%d) at 0x%lx, diff = %d, vers = %d\n", unit, siop,\r\n(unsigned long)paddr, differential, version);\r\np->hosts[siop] = ncr_attach(&NCR_Q720_tpnt, unit++, &device);\r\nif (!p->hosts[siop])\r\ngoto fail;\r\np->irq_enable |= (1<<siop);\r\nscsr1 = readb(vaddr + NCR_Q720_SCSR_OFFSET + 1);\r\nscsr1 &= ~0x01;\r\nwriteb(scsr1, vaddr + NCR_Q720_SCSR_OFFSET + 1);\r\nerror = scsi_add_host(p->hosts[siop], p->dev);\r\nif (error)\r\nncr53c8xx_release(p->hosts[siop]);\r\nelse\r\nscsi_scan_host(p->hosts[siop]);\r\nreturn error;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int __init\r\nNCR_Q720_probe(struct device *dev)\r\n{\r\nstruct NCR_Q720_private *p;\r\nstatic int banner = 1;\r\nstruct mca_device *mca_dev = to_mca_device(dev);\r\nint slot = mca_dev->slot;\r\nint found = 0;\r\nint irq, i, siops;\r\n__u8 pos2, pos4, asr2, asr9, asr10;\r\n__u16 io_base;\r\n__u32 base_addr, mem_size;\r\nvoid __iomem *mem_base;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\npos2 = mca_device_read_pos(mca_dev, 2);\r\npos2 |= NCR_Q720_POS2_BOARD_ENABLE | NCR_Q720_POS2_INTERRUPT_ENABLE;\r\nmca_device_write_pos(mca_dev, 2, pos2);\r\nio_base = (pos2 & NCR_Q720_POS2_IO_MASK) << NCR_Q720_POS2_IO_SHIFT;\r\nif(banner) {\r\nprintk(KERN_NOTICE "NCR Q720: Driver Version " NCR_Q720_VERSION "\n"\r\n"NCR Q720: Copyright (c) 2003 by James.Bottomley@HansenPartnership.com\n"\r\n"NCR Q720:\n");\r\nbanner = 0;\r\n}\r\nio_base = mca_device_transform_ioport(mca_dev, io_base);\r\ni = inb(io_base) | (inb(io_base+1)<<8);\r\nif(i != NCR_Q720_MCA_ID) {\r\nprintk(KERN_ERR "NCR_Q720, adapter failed to I/O map registers correctly at 0x%x(0x%x)\n", io_base, i);\r\nkfree(p);\r\nreturn -ENODEV;\r\n}\r\npos4 = inb(io_base + 4);\r\npos4 |= 0x01;\r\noutb(pos4, io_base + 4);\r\nbase_addr = (pos4 & 0x7e) << 20;\r\nbase_addr += (pos4 & 0x80) << 23;\r\nasr10 = inb(io_base + 0x12);\r\nbase_addr += (asr10 & 0x80) << 24;\r\nbase_addr += (asr10 & 0x70) << 23;\r\nasr9 = inb(io_base + 0x11);\r\ni = (asr9 & 0xc0) >> 6;\r\nif(i == 0)\r\nmem_size = 1024;\r\nelse\r\nmem_size = 1 << (19 + i);\r\nasr9 |= 0x20;\r\nasr9 &= ~0x10;\r\noutb(asr9, io_base + 0x11);\r\nif(!request_mem_region(base_addr, mem_size, "NCR_Q720")) {\r\nprintk(KERN_ERR "NCR_Q720: Failed to claim memory region 0x%lx\n-0x%lx",\r\n(unsigned long)base_addr,\r\n(unsigned long)(base_addr + mem_size));\r\ngoto out_free;\r\n}\r\nif (dma_declare_coherent_memory(dev, base_addr, base_addr,\r\nmem_size, DMA_MEMORY_MAP)\r\n!= DMA_MEMORY_MAP) {\r\nprintk(KERN_ERR "NCR_Q720: DMA declare memory failed\n");\r\ngoto out_release_region;\r\n}\r\nmem_base = dma_mark_declared_memory_occupied(dev, base_addr,\r\n1024);\r\nif (IS_ERR(mem_base)) {\r\nprintk("NCR_Q720 failed to reserve memory mapped region\n");\r\ngoto out_release;\r\n}\r\nasr2 = inb(io_base + 0x0a);\r\nasr2 |= 0x01;\r\noutb(asr2, io_base + 0x0a);\r\nsiops = ((asr2 & 0xe0) >> 5) + 1;\r\ni = readw(mem_base);\r\nif(i != NCR_Q720_MCA_ID) {\r\nprintk(KERN_ERR "NCR_Q720, adapter failed to memory map registers correctly at 0x%lx(0x%x)\n", (unsigned long)base_addr, i);\r\ngoto out_release;\r\n}\r\nirq = readb(mem_base + 5) & 0x0f;\r\nirq = mca_device_transform_irq(mca_dev, irq);\r\nprintk(KERN_NOTICE "NCR Q720: found in slot %d irq = %d mem base = 0x%lx siops = %d\n", slot, irq, (unsigned long)base_addr, siops);\r\nprintk(KERN_NOTICE "NCR Q720: On board ram %dk\n", mem_size/1024);\r\np->dev = dev;\r\np->mem_base = mem_base;\r\np->phys_mem_base = base_addr;\r\np->mem_size = mem_size;\r\np->irq = irq;\r\np->siops = siops;\r\nif (request_irq(irq, NCR_Q720_intr, IRQF_SHARED, "NCR_Q720", p)) {\r\nprintk(KERN_ERR "NCR_Q720: request irq %d failed\n", irq);\r\ngoto out_release;\r\n}\r\nfor(i = 0; i < siops; i++) {\r\nvoid __iomem *reg_scsr1 = mem_base + NCR_Q720_CHIP_REGISTER_OFFSET\r\n+ i*NCR_Q720_SIOP_SHIFT + NCR_Q720_SCSR_OFFSET + 1;\r\n__u8 scsr1 = readb(reg_scsr1);\r\nscsr1 |= 0x01;\r\nwriteb(scsr1, reg_scsr1);\r\n}\r\nfor (i = 0; i < siops; i++) {\r\nvoid __iomem *siop_v_base = mem_base + NCR_Q720_CHIP_REGISTER_OFFSET\r\n+ i*NCR_Q720_SIOP_SHIFT;\r\n__u32 siop_p_base = base_addr + NCR_Q720_CHIP_REGISTER_OFFSET\r\n+ i*NCR_Q720_SIOP_SHIFT;\r\n__u16 port = io_base + NCR_Q720_CHIP_REGISTER_OFFSET\r\n+ i*NCR_Q720_SIOP_SHIFT;\r\nint err;\r\noutb(0xff, port + 0x40);\r\noutb(0x07, port + 0x41);\r\nif ((err = NCR_Q720_probe_one(p, i, irq, slot,\r\nsiop_p_base, siop_v_base)) != 0)\r\nprintk("Q720: SIOP%d: probe failed, error = %d\n",\r\ni, err);\r\nelse\r\nfound++;\r\n}\r\nif (!found) {\r\nkfree(p);\r\nreturn -ENODEV;\r\n}\r\nmca_device_set_claim(mca_dev, 1);\r\nmca_device_set_name(mca_dev, "NCR_Q720");\r\ndev_set_drvdata(dev, p);\r\nreturn 0;\r\nout_release:\r\ndma_release_declared_memory(dev);\r\nout_release_region:\r\nrelease_mem_region(base_addr, mem_size);\r\nout_free:\r\nkfree(p);\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit\r\nNCR_Q720_remove_one(struct Scsi_Host *host)\r\n{\r\nscsi_remove_host(host);\r\nncr53c8xx_release(host);\r\n}\r\nstatic int __exit\r\nNCR_Q720_remove(struct device *dev)\r\n{\r\nstruct NCR_Q720_private *p = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < p->siops; i++)\r\nif(p->hosts[i])\r\nNCR_Q720_remove_one(p->hosts[i]);\r\ndma_release_declared_memory(dev);\r\nrelease_mem_region(p->phys_mem_base, p->mem_size);\r\nfree_irq(p->irq, p);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nNCR_Q720_init(void)\r\n{\r\nint ret = ncr53c8xx_init();\r\nif (!ret)\r\nret = mca_register_driver(&NCR_Q720_driver);\r\nif (ret)\r\nncr53c8xx_exit();\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nNCR_Q720_exit(void)\r\n{\r\nmca_unregister_driver(&NCR_Q720_driver);\r\nncr53c8xx_exit();\r\n}
