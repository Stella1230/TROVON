static inline void tz1090_gpio_write(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs, u32 data)\r\n{\r\niowrite32(data, bank->reg + reg_offs);\r\n}\r\nstatic inline u32 tz1090_gpio_read(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs)\r\n{\r\nreturn ioread32(bank->reg + reg_offs);\r\n}\r\nstatic inline void _tz1090_gpio_clear_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset)\r\n{\r\nu32 value;\r\nvalue = tz1090_gpio_read(bank, reg_offs);\r\nvalue &= ~BIT(offset);\r\ntz1090_gpio_write(bank, reg_offs, value);\r\n}\r\nstatic void tz1090_gpio_clear_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset)\r\n{\r\nint lstat;\r\n__global_lock2(lstat);\r\n_tz1090_gpio_clear_bit(bank, reg_offs, offset);\r\n__global_unlock2(lstat);\r\n}\r\nstatic inline void _tz1090_gpio_set_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset)\r\n{\r\nu32 value;\r\nvalue = tz1090_gpio_read(bank, reg_offs);\r\nvalue |= BIT(offset);\r\ntz1090_gpio_write(bank, reg_offs, value);\r\n}\r\nstatic void tz1090_gpio_set_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset)\r\n{\r\nint lstat;\r\n__global_lock2(lstat);\r\n_tz1090_gpio_set_bit(bank, reg_offs, offset);\r\n__global_unlock2(lstat);\r\n}\r\nstatic inline void _tz1090_gpio_mod_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset,\r\nbool val)\r\n{\r\nu32 value;\r\nvalue = tz1090_gpio_read(bank, reg_offs);\r\nvalue &= ~BIT(offset);\r\nif (val)\r\nvalue |= BIT(offset);\r\ntz1090_gpio_write(bank, reg_offs, value);\r\n}\r\nstatic void tz1090_gpio_mod_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset,\r\nbool val)\r\n{\r\nint lstat;\r\n__global_lock2(lstat);\r\n_tz1090_gpio_mod_bit(bank, reg_offs, offset, val);\r\n__global_unlock2(lstat);\r\n}\r\nstatic inline int tz1090_gpio_read_bit(struct tz1090_gpio_bank *bank,\r\nunsigned int reg_offs,\r\nunsigned int offset)\r\n{\r\nreturn tz1090_gpio_read(bank, reg_offs) & BIT(offset);\r\n}\r\nstatic int tz1090_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned int offset)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\ntz1090_gpio_set_bit(bank, REG_GPIO_DIR, offset);\r\nreturn 0;\r\n}\r\nstatic int tz1090_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned int offset, int output_value)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\nint lstat;\r\n__global_lock2(lstat);\r\n_tz1090_gpio_mod_bit(bank, REG_GPIO_DOUT, offset, output_value);\r\n_tz1090_gpio_clear_bit(bank, REG_GPIO_DIR, offset);\r\n__global_unlock2(lstat);\r\nreturn 0;\r\n}\r\nstatic int tz1090_gpio_get(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\nreturn tz1090_gpio_read_bit(bank, REG_GPIO_DIN, offset);\r\n}\r\nstatic void tz1090_gpio_set(struct gpio_chip *chip, unsigned int offset,\r\nint output_value)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\ntz1090_gpio_mod_bit(bank, REG_GPIO_DOUT, offset, output_value);\r\n}\r\nstatic int tz1090_gpio_request(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\nint ret;\r\nret = pinctrl_request_gpio(chip->base + offset);\r\nif (ret)\r\nreturn ret;\r\ntz1090_gpio_set_bit(bank, REG_GPIO_DIR, offset);\r\ntz1090_gpio_set_bit(bank, REG_GPIO_BIT_EN, offset);\r\nreturn 0;\r\n}\r\nstatic void tz1090_gpio_free(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\npinctrl_free_gpio(chip->base + offset);\r\ntz1090_gpio_clear_bit(bank, REG_GPIO_BIT_EN, offset);\r\n}\r\nstatic int tz1090_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct tz1090_gpio_bank *bank = to_bank(chip);\r\nif (!bank->domain)\r\nreturn -EINVAL;\r\nreturn irq_create_mapping(bank->domain, offset);\r\n}\r\nstatic inline struct tz1090_gpio_bank *irqd_to_gpio_bank(struct irq_data *data)\r\n{\r\nreturn (struct tz1090_gpio_bank *)data->domain->host_data;\r\n}\r\nstatic void tz1090_gpio_irq_polarity(struct tz1090_gpio_bank *bank,\r\nunsigned int offset, unsigned int polarity)\r\n{\r\ntz1090_gpio_mod_bit(bank, REG_GPIO_IRQ_PLRT, offset, polarity);\r\n}\r\nstatic void tz1090_gpio_irq_type(struct tz1090_gpio_bank *bank,\r\nunsigned int offset, unsigned int type)\r\n{\r\ntz1090_gpio_mod_bit(bank, REG_GPIO_IRQ_TYPE, offset, type);\r\n}\r\nstatic void tz1090_gpio_irq_next_edge(struct tz1090_gpio_bank *bank,\r\nunsigned int offset)\r\n{\r\nunsigned int value_p, value_i;\r\nint lstat;\r\n__global_lock2(lstat);\r\nvalue_i = ~tz1090_gpio_read(bank, REG_GPIO_DIN);\r\nvalue_p = tz1090_gpio_read(bank, REG_GPIO_IRQ_PLRT);\r\nvalue_p &= ~BIT(offset);\r\nvalue_p |= value_i & BIT(offset);\r\ntz1090_gpio_write(bank, REG_GPIO_IRQ_PLRT, value_p);\r\n__global_unlock2(lstat);\r\n}\r\nstatic unsigned int gpio_startup_irq(struct irq_data *data)\r\n{\r\nWARN(irqd_get_trigger_type(data) == IRQ_TYPE_NONE,\r\n"irq type not set before enabling gpio irq %d", data->irq);\r\nirq_gc_ack_clr_bit(data);\r\nirq_gc_mask_set_bit(data);\r\nreturn 0;\r\n}\r\nstatic int gpio_set_irq_type(struct irq_data *data, unsigned int flow_type)\r\n{\r\nstruct tz1090_gpio_bank *bank = irqd_to_gpio_bank(data);\r\nunsigned int type;\r\nunsigned int polarity;\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ntype = REG_GPIO_IRQ_TYPE_EDGE;\r\npolarity = REG_GPIO_IRQ_PLRT_LOW;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntype = REG_GPIO_IRQ_TYPE_EDGE;\r\npolarity = REG_GPIO_IRQ_PLRT_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntype = REG_GPIO_IRQ_TYPE_EDGE;\r\npolarity = REG_GPIO_IRQ_PLRT_LOW;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntype = REG_GPIO_IRQ_TYPE_LEVEL;\r\npolarity = REG_GPIO_IRQ_PLRT_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntype = REG_GPIO_IRQ_TYPE_LEVEL;\r\npolarity = REG_GPIO_IRQ_PLRT_LOW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntz1090_gpio_irq_type(bank, data->hwirq, type);\r\nirq_setup_alt_chip(data, flow_type);\r\nif (flow_type == IRQ_TYPE_EDGE_BOTH)\r\ntz1090_gpio_irq_next_edge(bank, data->hwirq);\r\nelse\r\ntz1090_gpio_irq_polarity(bank, data->hwirq, polarity);\r\nreturn 0;\r\n}\r\nstatic int gpio_set_irq_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct tz1090_gpio_bank *bank = irqd_to_gpio_bank(data);\r\n#ifdef CONFIG_PM_DEBUG\r\npr_info("irq_wake irq%d state:%d\n", data->irq, on);\r\n#endif\r\nreturn irq_set_irq_wake(bank->irq, on);\r\n}\r\nstatic void tz1090_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nirq_hw_number_t hw;\r\nunsigned int irq_stat, irq_no;\r\nstruct tz1090_gpio_bank *bank;\r\nstruct irq_desc *child_desc;\r\nbank = (struct tz1090_gpio_bank *)irq_desc_get_handler_data(desc);\r\nirq_stat = tz1090_gpio_read(bank, REG_GPIO_DIR) &\r\ntz1090_gpio_read(bank, REG_GPIO_IRQ_STS) &\r\ntz1090_gpio_read(bank, REG_GPIO_IRQ_EN) &\r\n0x3FFFFFFF;\r\nfor (hw = 0; irq_stat; irq_stat >>= 1, ++hw) {\r\nif (!(irq_stat & 1))\r\ncontinue;\r\nirq_no = irq_linear_revmap(bank->domain, hw);\r\nchild_desc = irq_to_desc(irq_no);\r\nif (irqd_get_trigger_type(&child_desc->irq_data)\r\n== IRQ_TYPE_EDGE_BOTH)\r\ntz1090_gpio_irq_next_edge(bank, hw);\r\ngeneric_handle_irq_desc(irq_no, child_desc);\r\n}\r\n}\r\nstatic int tz1090_gpio_bank_probe(struct tz1090_gpio_bank_info *info)\r\n{\r\nstruct device_node *np = info->node;\r\nstruct device *dev = info->priv->dev;\r\nstruct tz1090_gpio_bank *bank;\r\nstruct irq_chip_generic *gc;\r\nint err;\r\nbank = devm_kzalloc(dev, sizeof(*bank), GFP_KERNEL);\r\nif (!bank) {\r\ndev_err(dev, "unable to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nbank->reg = info->priv->reg + info->index * 4;\r\nsnprintf(bank->label, sizeof(bank->label), "tz1090-gpio-%u",\r\ninfo->index);\r\nbank->chip.label = bank->label;\r\nbank->chip.dev = dev;\r\nbank->chip.direction_input = tz1090_gpio_direction_input;\r\nbank->chip.direction_output = tz1090_gpio_direction_output;\r\nbank->chip.get = tz1090_gpio_get;\r\nbank->chip.set = tz1090_gpio_set;\r\nbank->chip.free = tz1090_gpio_free;\r\nbank->chip.request = tz1090_gpio_request;\r\nbank->chip.to_irq = tz1090_gpio_to_irq;\r\nbank->chip.of_node = np;\r\nbank->chip.base = info->index * 30;\r\nbank->chip.ngpio = 30;\r\ngpiochip_add(&bank->chip);\r\nbank->irq = irq_of_parse_and_map(np, 0);\r\nif (bank->irq < 0) {\r\ndev_info(dev, "IRQ not provided for bank %u, IRQs disabled\n",\r\ninfo->index);\r\nreturn 0;\r\n}\r\ndev_info(dev, "Setting up IRQs for GPIO bank %u\n",\r\ninfo->index);\r\ntz1090_gpio_write(bank, REG_GPIO_IRQ_EN, 0);\r\nbank->domain = irq_domain_add_linear(np,\r\nbank->chip.ngpio,\r\n&irq_generic_chip_ops,\r\nbank);\r\nerr = irq_alloc_domain_generic_chips(bank->domain, bank->chip.ngpio, 2,\r\nbank->label, handle_bad_irq, 0, 0,\r\nIRQ_GC_INIT_NESTED_LOCK);\r\nif (err) {\r\ndev_info(dev,\r\n"irq_alloc_domain_generic_chips failed for bank %u, IRQs disabled\n",\r\ninfo->index);\r\nirq_domain_remove(bank->domain);\r\nreturn 0;\r\n}\r\ngc = irq_get_domain_generic_chip(bank->domain, 0);\r\ngc->reg_base = bank->reg;\r\ngc->chip_types[0].type = IRQ_TYPE_LEVEL_MASK;\r\ngc->chip_types[0].handler = handle_level_irq;\r\ngc->chip_types[0].regs.ack = REG_GPIO_IRQ_STS;\r\ngc->chip_types[0].regs.mask = REG_GPIO_IRQ_EN;\r\ngc->chip_types[0].chip.irq_startup = gpio_startup_irq,\r\ngc->chip_types[0].chip.irq_ack = irq_gc_ack_clr_bit,\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_clr_bit,\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_mask_set_bit,\r\ngc->chip_types[0].chip.irq_set_type = gpio_set_irq_type,\r\ngc->chip_types[0].chip.irq_set_wake = gpio_set_irq_wake,\r\ngc->chip_types[0].chip.flags = IRQCHIP_MASK_ON_SUSPEND,\r\ngc->chip_types[1].type = IRQ_TYPE_EDGE_BOTH;\r\ngc->chip_types[1].handler = handle_edge_irq;\r\ngc->chip_types[1].regs.ack = REG_GPIO_IRQ_STS;\r\ngc->chip_types[1].regs.mask = REG_GPIO_IRQ_EN;\r\ngc->chip_types[1].chip.irq_startup = gpio_startup_irq,\r\ngc->chip_types[1].chip.irq_ack = irq_gc_ack_clr_bit,\r\ngc->chip_types[1].chip.irq_mask = irq_gc_mask_clr_bit,\r\ngc->chip_types[1].chip.irq_unmask = irq_gc_mask_set_bit,\r\ngc->chip_types[1].chip.irq_set_type = gpio_set_irq_type,\r\ngc->chip_types[1].chip.irq_set_wake = gpio_set_irq_wake,\r\ngc->chip_types[1].chip.flags = IRQCHIP_MASK_ON_SUSPEND,\r\nirq_set_handler_data(bank->irq, bank);\r\nirq_set_chained_handler(bank->irq, tz1090_gpio_irq_handler);\r\nreturn 0;\r\n}\r\nstatic void tz1090_gpio_register_banks(struct tz1090_gpio *priv)\r\n{\r\nstruct device_node *np = priv->dev->of_node;\r\nstruct device_node *node;\r\nfor_each_available_child_of_node(np, node) {\r\nstruct tz1090_gpio_bank_info info;\r\nu32 addr;\r\nint ret;\r\nret = of_property_read_u32(node, "reg", &addr);\r\nif (ret) {\r\ndev_err(priv->dev, "invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\nif (addr >= 3) {\r\ndev_err(priv->dev, "index %u in %s out of range\n",\r\naddr, node->full_name);\r\ncontinue;\r\n}\r\ninfo.index = addr;\r\ninfo.node = of_node_get(node);\r\ninfo.priv = priv;\r\nret = tz1090_gpio_bank_probe(&info);\r\nif (ret) {\r\ndev_err(priv->dev, "failure registering %s\n",\r\nnode->full_name);\r\nof_node_put(node);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic int tz1090_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res_regs;\r\nstruct tz1090_gpio priv;\r\nif (!np) {\r\ndev_err(&pdev->dev, "must be instantiated via devicetree\n");\r\nreturn -ENOENT;\r\n}\r\nres_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_regs) {\r\ndev_err(&pdev->dev, "cannot find registers resource\n");\r\nreturn -ENOENT;\r\n}\r\npriv.dev = &pdev->dev;\r\npriv.reg = devm_ioremap(&pdev->dev, res_regs->start,\r\nres_regs->end - res_regs->start);\r\nif (!priv.reg) {\r\ndev_err(&pdev->dev, "unable to ioremap registers\n");\r\nreturn -ENOMEM;\r\n}\r\ntz1090_gpio_register_banks(&priv);\r\nreturn 0;\r\n}\r\nstatic int __init tz1090_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&tz1090_gpio_driver);\r\n}
