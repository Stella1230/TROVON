static int count_idrs(int id, void *p, void *data)\r\n{\r\nint *countp = data;\r\n*countp = *countp + 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t debugfs_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct c4iw_debugfs_data *d = file->private_data;\r\nreturn simple_read_from_buffer(buf, count, ppos, d->buf, d->pos);\r\n}\r\nstatic int dump_qp(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nstruct c4iw_debugfs_data *qpd = data;\r\nint space;\r\nint cc;\r\nif (id != qp->wq.sq.qid)\r\nreturn 0;\r\nspace = qpd->bufsize - qpd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (qp->ep) {\r\nif (qp->ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&qp->ep->com.local_addr;\r\nstruct sockaddr_in *rsin = (struct sockaddr_in *)\r\n&qp->ep->com.remote_addr;\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"rc qp sq id %u rq id %u state %u "\r\n"onchip %u ep tid %u state %u "\r\n"%pI4:%u->%pI4:%u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP,\r\nqp->ep->hwtid, (int)qp->ep->com.state,\r\n&lsin->sin_addr, ntohs(lsin->sin_port),\r\n&rsin->sin_addr, ntohs(rsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&qp->ep->com.local_addr;\r\nstruct sockaddr_in6 *rsin6 = (struct sockaddr_in6 *)\r\n&qp->ep->com.remote_addr;\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"rc qp sq id %u rq id %u state %u "\r\n"onchip %u ep tid %u state %u "\r\n"%pI6:%u->%pI6:%u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP,\r\nqp->ep->hwtid, (int)qp->ep->com.state,\r\n&lsin6->sin6_addr,\r\nntohs(lsin6->sin6_port),\r\n&rsin6->sin6_addr,\r\nntohs(rsin6->sin6_port));\r\n}\r\n} else\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"qp sq id %u rq id %u state %u onchip %u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP);\r\nif (cc < space)\r\nqpd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int qp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd = file->private_data;\r\nif (!qpd) {\r\nprintk(KERN_INFO "%s null qpd?\n", __func__);\r\nreturn 0;\r\n}\r\nvfree(qpd->buf);\r\nkfree(qpd);\r\nreturn 0;\r\n}\r\nstatic int qp_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd;\r\nint ret = 0;\r\nint count = 1;\r\nqpd = kmalloc(sizeof *qpd, GFP_KERNEL);\r\nif (!qpd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nqpd->devp = inode->i_private;\r\nqpd->pos = 0;\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, count_idrs, &count);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->bufsize = count * 128;\r\nqpd->buf = vmalloc(qpd->bufsize);\r\nif (!qpd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, dump_qp, qpd);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->buf[qpd->pos++] = 0;\r\nfile->private_data = qpd;\r\ngoto out;\r\nerr1:\r\nkfree(qpd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dump_stag(int id, void *p, void *data)\r\n{\r\nstruct c4iw_debugfs_data *stagd = data;\r\nint space;\r\nint cc;\r\nspace = stagd->bufsize - stagd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\ncc = snprintf(stagd->buf + stagd->pos, space, "0x%x\n", id<<8);\r\nif (cc < space)\r\nstagd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int stag_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd = file->private_data;\r\nif (!stagd) {\r\nprintk(KERN_INFO "%s null stagd?\n", __func__);\r\nreturn 0;\r\n}\r\nkfree(stagd->buf);\r\nkfree(stagd);\r\nreturn 0;\r\n}\r\nstatic int stag_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd;\r\nint ret = 0;\r\nint count = 1;\r\nstagd = kmalloc(sizeof *stagd, GFP_KERNEL);\r\nif (!stagd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstagd->devp = inode->i_private;\r\nstagd->pos = 0;\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, count_idrs, &count);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->bufsize = count * sizeof("0x12345678\n");\r\nstagd->buf = kmalloc(stagd->bufsize, GFP_KERNEL);\r\nif (!stagd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, dump_stag, stagd);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->buf[stagd->pos++] = 0;\r\nfile->private_data = stagd;\r\ngoto out;\r\nerr1:\r\nkfree(stagd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int stats_show(struct seq_file *seq, void *v)\r\n{\r\nstruct c4iw_dev *dev = seq->private;\r\nseq_printf(seq, " Object: %10s %10s %10s %10s\n", "Total", "Current",\r\n"Max", "Fail");\r\nseq_printf(seq, " PDID: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.pd.total, dev->rdev.stats.pd.cur,\r\ndev->rdev.stats.pd.max, dev->rdev.stats.pd.fail);\r\nseq_printf(seq, " QID: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.qid.total, dev->rdev.stats.qid.cur,\r\ndev->rdev.stats.qid.max, dev->rdev.stats.qid.fail);\r\nseq_printf(seq, " TPTMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.stag.total, dev->rdev.stats.stag.cur,\r\ndev->rdev.stats.stag.max, dev->rdev.stats.stag.fail);\r\nseq_printf(seq, " PBLMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.pbl.total, dev->rdev.stats.pbl.cur,\r\ndev->rdev.stats.pbl.max, dev->rdev.stats.pbl.fail);\r\nseq_printf(seq, " RQTMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.rqt.total, dev->rdev.stats.rqt.cur,\r\ndev->rdev.stats.rqt.max, dev->rdev.stats.rqt.fail);\r\nseq_printf(seq, " OCQPMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.ocqp.total, dev->rdev.stats.ocqp.cur,\r\ndev->rdev.stats.ocqp.max, dev->rdev.stats.ocqp.fail);\r\nseq_printf(seq, " DB FULL: %10llu\n", dev->rdev.stats.db_full);\r\nseq_printf(seq, " DB EMPTY: %10llu\n", dev->rdev.stats.db_empty);\r\nseq_printf(seq, " DB DROP: %10llu\n", dev->rdev.stats.db_drop);\r\nseq_printf(seq, " DB State: %s Transitions %llu\n",\r\ndb_state_str[dev->db_state],\r\ndev->rdev.stats.db_state_transitions);\r\nseq_printf(seq, "TCAM_FULL: %10llu\n", dev->rdev.stats.tcam_full);\r\nseq_printf(seq, "ACT_OFLD_CONN_FAILS: %10llu\n",\r\ndev->rdev.stats.act_ofld_conn_fails);\r\nseq_printf(seq, "PAS_OFLD_CONN_FAILS: %10llu\n",\r\ndev->rdev.stats.pas_ofld_conn_fails);\r\nreturn 0;\r\n}\r\nstatic int stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, stats_show, inode->i_private);\r\n}\r\nstatic ssize_t stats_clear(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct c4iw_dev *dev = ((struct seq_file *)file->private_data)->private;\r\nmutex_lock(&dev->rdev.stats.lock);\r\ndev->rdev.stats.pd.max = 0;\r\ndev->rdev.stats.pd.fail = 0;\r\ndev->rdev.stats.qid.max = 0;\r\ndev->rdev.stats.qid.fail = 0;\r\ndev->rdev.stats.stag.max = 0;\r\ndev->rdev.stats.stag.fail = 0;\r\ndev->rdev.stats.pbl.max = 0;\r\ndev->rdev.stats.pbl.fail = 0;\r\ndev->rdev.stats.rqt.max = 0;\r\ndev->rdev.stats.rqt.fail = 0;\r\ndev->rdev.stats.ocqp.max = 0;\r\ndev->rdev.stats.ocqp.fail = 0;\r\ndev->rdev.stats.db_full = 0;\r\ndev->rdev.stats.db_empty = 0;\r\ndev->rdev.stats.db_drop = 0;\r\ndev->rdev.stats.db_state_transitions = 0;\r\ndev->rdev.stats.tcam_full = 0;\r\ndev->rdev.stats.act_ofld_conn_fails = 0;\r\ndev->rdev.stats.pas_ofld_conn_fails = 0;\r\nmutex_unlock(&dev->rdev.stats.lock);\r\nreturn count;\r\n}\r\nstatic int dump_ep(int id, void *p, void *data)\r\n{\r\nstruct c4iw_ep *ep = p;\r\nstruct c4iw_debugfs_data *epd = data;\r\nint space;\r\nint cc;\r\nspace = epd->bufsize - epd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in *rsin = (struct sockaddr_in *)\r\n&ep->com.remote_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p qp %p state %d flags 0x%lx "\r\n"history 0x%lx hwtid %d atid %d "\r\n"%pI4:%d <-> %pI4:%d\n",\r\nep, ep->com.cm_id, ep->com.qp,\r\n(int)ep->com.state, ep->com.flags,\r\nep->com.history, ep->hwtid, ep->atid,\r\n&lsin->sin_addr, ntohs(lsin->sin_port),\r\n&rsin->sin_addr, ntohs(rsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in6 *rsin6 = (struct sockaddr_in6 *)\r\n&ep->com.remote_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p qp %p state %d flags 0x%lx "\r\n"history 0x%lx hwtid %d atid %d "\r\n"%pI6:%d <-> %pI6:%d\n",\r\nep, ep->com.cm_id, ep->com.qp,\r\n(int)ep->com.state, ep->com.flags,\r\nep->com.history, ep->hwtid, ep->atid,\r\n&lsin6->sin6_addr, ntohs(lsin6->sin6_port),\r\n&rsin6->sin6_addr, ntohs(rsin6->sin6_port));\r\n}\r\nif (cc < space)\r\nepd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int dump_listen_ep(int id, void *p, void *data)\r\n{\r\nstruct c4iw_listen_ep *ep = p;\r\nstruct c4iw_debugfs_data *epd = data;\r\nint space;\r\nint cc;\r\nspace = epd->bufsize - epd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&ep->com.local_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p state %d flags 0x%lx stid %d "\r\n"backlog %d %pI4:%d\n",\r\nep, ep->com.cm_id, (int)ep->com.state,\r\nep->com.flags, ep->stid, ep->backlog,\r\n&lsin->sin_addr, ntohs(lsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.local_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p state %d flags 0x%lx stid %d "\r\n"backlog %d %pI6:%d\n",\r\nep, ep->com.cm_id, (int)ep->com.state,\r\nep->com.flags, ep->stid, ep->backlog,\r\n&lsin6->sin6_addr, ntohs(lsin6->sin6_port));\r\n}\r\nif (cc < space)\r\nepd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int ep_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *epd = file->private_data;\r\nif (!epd) {\r\npr_info("%s null qpd?\n", __func__);\r\nreturn 0;\r\n}\r\nvfree(epd->buf);\r\nkfree(epd);\r\nreturn 0;\r\n}\r\nstatic int ep_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *epd;\r\nint ret = 0;\r\nint count = 1;\r\nepd = kmalloc(sizeof(*epd), GFP_KERNEL);\r\nif (!epd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nepd->devp = inode->i_private;\r\nepd->pos = 0;\r\nspin_lock_irq(&epd->devp->lock);\r\nidr_for_each(&epd->devp->hwtid_idr, count_idrs, &count);\r\nidr_for_each(&epd->devp->atid_idr, count_idrs, &count);\r\nidr_for_each(&epd->devp->stid_idr, count_idrs, &count);\r\nspin_unlock_irq(&epd->devp->lock);\r\nepd->bufsize = count * 160;\r\nepd->buf = vmalloc(epd->bufsize);\r\nif (!epd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&epd->devp->lock);\r\nidr_for_each(&epd->devp->hwtid_idr, dump_ep, epd);\r\nidr_for_each(&epd->devp->atid_idr, dump_ep, epd);\r\nidr_for_each(&epd->devp->stid_idr, dump_listen_ep, epd);\r\nspin_unlock_irq(&epd->devp->lock);\r\nfile->private_data = epd;\r\ngoto out;\r\nerr1:\r\nkfree(epd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int setup_debugfs(struct c4iw_dev *devp)\r\n{\r\nstruct dentry *de;\r\nif (!devp->debugfs_root)\r\nreturn -1;\r\nde = debugfs_create_file("qps", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &qp_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nde = debugfs_create_file("stags", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &stag_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nde = debugfs_create_file("stats", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &stats_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nde = debugfs_create_file("eps", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &ep_debugfs_fops);\r\nif (de && de->d_inode)\r\nde->d_inode->i_size = 4096;\r\nreturn 0;\r\n}\r\nvoid c4iw_release_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nstruct list_head *pos, *nxt;\r\nstruct c4iw_qid_list *entry;\r\nmutex_lock(&uctx->lock);\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nif (!(entry->qid & rdev->qpmask)) {\r\nc4iw_put_resource(&rdev->resource.qid_table,\r\nentry->qid);\r\nmutex_lock(&rdev->stats.lock);\r\nrdev->stats.qid.cur -= rdev->qpmask + 1;\r\nmutex_unlock(&rdev->stats.lock);\r\n}\r\nkfree(entry);\r\n}\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&uctx->lock);\r\n}\r\nvoid c4iw_init_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nINIT_LIST_HEAD(&uctx->qpids);\r\nINIT_LIST_HEAD(&uctx->cqids);\r\nmutex_init(&uctx->lock);\r\n}\r\nstatic int c4iw_rdev_open(struct c4iw_rdev *rdev)\r\n{\r\nint err;\r\nc4iw_init_dev_ucontext(rdev, &rdev->uctx);\r\nrdev->qpshift = PAGE_SHIFT - ilog2(rdev->lldi.udb_density);\r\nrdev->qpmask = rdev->lldi.udb_density - 1;\r\nrdev->cqshift = PAGE_SHIFT - ilog2(rdev->lldi.ucq_density);\r\nrdev->cqmask = rdev->lldi.ucq_density - 1;\r\nPDBG("%s dev %s stag start 0x%0x size 0x%0x num stags %d "\r\n"pbl start 0x%0x size 0x%0x rq start 0x%0x size 0x%0x "\r\n"qp qid start %u size %u cq qid start %u size %u\n",\r\n__func__, pci_name(rdev->lldi.pdev), rdev->lldi.vr->stag.start,\r\nrdev->lldi.vr->stag.size, c4iw_num_stags(rdev),\r\nrdev->lldi.vr->pbl.start,\r\nrdev->lldi.vr->pbl.size, rdev->lldi.vr->rq.start,\r\nrdev->lldi.vr->rq.size,\r\nrdev->lldi.vr->qp.start,\r\nrdev->lldi.vr->qp.size,\r\nrdev->lldi.vr->cq.start,\r\nrdev->lldi.vr->cq.size);\r\nPDBG("udb len 0x%x udb base %llx db_reg %p gts_reg %p qpshift %lu "\r\n"qpmask 0x%x cqshift %lu cqmask 0x%x\n",\r\n(unsigned)pci_resource_len(rdev->lldi.pdev, 2),\r\n(u64)pci_resource_start(rdev->lldi.pdev, 2),\r\nrdev->lldi.db_reg,\r\nrdev->lldi.gts_reg,\r\nrdev->qpshift, rdev->qpmask,\r\nrdev->cqshift, rdev->cqmask);\r\nif (c4iw_num_stags(rdev) == 0) {\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nrdev->stats.pd.total = T4_MAX_NUM_PD;\r\nrdev->stats.stag.total = rdev->lldi.vr->stag.size;\r\nrdev->stats.pbl.total = rdev->lldi.vr->pbl.size;\r\nrdev->stats.rqt.total = rdev->lldi.vr->rq.size;\r\nrdev->stats.ocqp.total = rdev->lldi.vr->ocq.size;\r\nrdev->stats.qid.total = rdev->lldi.vr->qp.size;\r\nerr = c4iw_init_resource(rdev, c4iw_num_stags(rdev), T4_MAX_NUM_PD);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing resources\n", err);\r\ngoto err1;\r\n}\r\nerr = c4iw_pblpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing pbl pool\n", err);\r\ngoto err2;\r\n}\r\nerr = c4iw_rqtpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing rqt pool\n", err);\r\ngoto err3;\r\n}\r\nerr = c4iw_ocqp_pool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing ocqp pool\n", err);\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nc4iw_rqtpool_destroy(rdev);\r\nerr3:\r\nc4iw_pblpool_destroy(rdev);\r\nerr2:\r\nc4iw_destroy_resource(&rdev->resource);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void c4iw_rdev_close(struct c4iw_rdev *rdev)\r\n{\r\nc4iw_pblpool_destroy(rdev);\r\nc4iw_rqtpool_destroy(rdev);\r\nc4iw_destroy_resource(&rdev->resource);\r\n}\r\nstatic void c4iw_dealloc(struct uld_ctx *ctx)\r\n{\r\nc4iw_rdev_close(&ctx->dev->rdev);\r\nidr_destroy(&ctx->dev->cqidr);\r\nidr_destroy(&ctx->dev->qpidr);\r\nidr_destroy(&ctx->dev->mmidr);\r\nidr_destroy(&ctx->dev->hwtid_idr);\r\nidr_destroy(&ctx->dev->stid_idr);\r\nidr_destroy(&ctx->dev->atid_idr);\r\niounmap(ctx->dev->rdev.oc_mw_kva);\r\nib_dealloc_device(&ctx->dev->ibdev);\r\nctx->dev = NULL;\r\n}\r\nstatic void c4iw_remove(struct uld_ctx *ctx)\r\n{\r\nPDBG("%s c4iw_dev %p\n", __func__, ctx->dev);\r\nc4iw_unregister_device(ctx->dev);\r\nc4iw_dealloc(ctx);\r\n}\r\nstatic int rdma_supported(const struct cxgb4_lld_info *infop)\r\n{\r\nreturn infop->vr->stag.size > 0 && infop->vr->pbl.size > 0 &&\r\ninfop->vr->rq.size > 0 && infop->vr->qp.size > 0 &&\r\ninfop->vr->cq.size > 0;\r\n}\r\nstatic struct c4iw_dev *c4iw_alloc(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct c4iw_dev *devp;\r\nint ret;\r\nif (!rdma_supported(infop)) {\r\nprintk(KERN_INFO MOD "%s: RDMA not supported on this device.\n",\r\npci_name(infop->pdev));\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nif (!ocqp_supported(infop))\r\npr_info("%s: On-Chip Queues not supported on this device.\n",\r\npci_name(infop->pdev));\r\nif (!is_t4(infop->adapter_type)) {\r\nif (!allow_db_fc_on_t5) {\r\ndb_fc_threshold = 100000;\r\npr_info("DB Flow Control Disabled.\n");\r\n}\r\nif (!allow_db_coalescing_on_t5) {\r\ndb_coalescing_threshold = -1;\r\npr_info("DB Coalescing Disabled.\n");\r\n}\r\n}\r\ndevp = (struct c4iw_dev *)ib_alloc_device(sizeof(*devp));\r\nif (!devp) {\r\nprintk(KERN_ERR MOD "Cannot allocate ib device\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndevp->rdev.lldi = *infop;\r\ndevp->rdev.oc_mw_pa = pci_resource_start(devp->rdev.lldi.pdev, 2) +\r\n(pci_resource_len(devp->rdev.lldi.pdev, 2) -\r\nroundup_pow_of_two(devp->rdev.lldi.vr->ocq.size));\r\ndevp->rdev.oc_mw_kva = ioremap_wc(devp->rdev.oc_mw_pa,\r\ndevp->rdev.lldi.vr->ocq.size);\r\nPDBG(KERN_INFO MOD "ocq memory: "\r\n"hw_start 0x%x size %u mw_pa 0x%lx mw_kva %p\n",\r\ndevp->rdev.lldi.vr->ocq.start, devp->rdev.lldi.vr->ocq.size,\r\ndevp->rdev.oc_mw_pa, devp->rdev.oc_mw_kva);\r\nret = c4iw_rdev_open(&devp->rdev);\r\nif (ret) {\r\nprintk(KERN_ERR MOD "Unable to open CXIO rdev err %d\n", ret);\r\nib_dealloc_device(&devp->ibdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nidr_init(&devp->cqidr);\r\nidr_init(&devp->qpidr);\r\nidr_init(&devp->mmidr);\r\nidr_init(&devp->hwtid_idr);\r\nidr_init(&devp->stid_idr);\r\nidr_init(&devp->atid_idr);\r\nspin_lock_init(&devp->lock);\r\nmutex_init(&devp->rdev.stats.lock);\r\nmutex_init(&devp->db_mutex);\r\nif (c4iw_debugfs_root) {\r\ndevp->debugfs_root = debugfs_create_dir(\r\npci_name(devp->rdev.lldi.pdev),\r\nc4iw_debugfs_root);\r\nsetup_debugfs(devp);\r\n}\r\nreturn devp;\r\n}\r\nstatic void *c4iw_uld_add(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct uld_ctx *ctx;\r\nstatic int vers_printed;\r\nint i;\r\nif (!vers_printed++)\r\npr_info("Chelsio T4/T5 RDMA Driver - version %s\n",\r\nDRV_VERSION);\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx) {\r\nctx = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nctx->lldi = *infop;\r\nPDBG("%s found device %s nchan %u nrxq %u ntxq %u nports %u\n",\r\n__func__, pci_name(ctx->lldi.pdev),\r\nctx->lldi.nchan, ctx->lldi.nrxq,\r\nctx->lldi.ntxq, ctx->lldi.nports);\r\nmutex_lock(&dev_mutex);\r\nlist_add_tail(&ctx->entry, &uld_ctx_list);\r\nmutex_unlock(&dev_mutex);\r\nfor (i = 0; i < ctx->lldi.nrxq; i++)\r\nPDBG("rxqid[%u] %u\n", i, ctx->lldi.rxq_ids[i]);\r\nout:\r\nreturn ctx;\r\n}\r\nstatic inline struct sk_buff *copy_gl_to_skb_pkt(const struct pkt_gl *gl,\r\nconst __be64 *rsp,\r\nu32 pktshift)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header) - pktshift, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\n__skb_put(skb, gl->tot_len + sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header) - pktshift);\r\nskb_copy_to_linear_data(skb, rsp, sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header));\r\nskb_copy_to_linear_data_offset(skb, sizeof(struct rss_header) +\r\nsizeof(struct cpl_pass_accept_req),\r\ngl->va + pktshift,\r\ngl->tot_len - pktshift);\r\nreturn skb;\r\n}\r\nstatic inline int recv_rx_pkt(struct c4iw_dev *dev, const struct pkt_gl *gl,\r\nconst __be64 *rsp)\r\n{\r\nunsigned int opcode = *(u8 *)rsp;\r\nstruct sk_buff *skb;\r\nif (opcode != CPL_RX_PKT)\r\ngoto out;\r\nskb = copy_gl_to_skb_pkt(gl , rsp, dev->rdev.lldi.sge_pktshift);\r\nif (skb == NULL)\r\ngoto out;\r\nif (c4iw_handlers[opcode] == NULL) {\r\npr_info("%s no handler opcode 0x%x...\n", __func__,\r\nopcode);\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nc4iw_handlers[opcode](dev, skb);\r\nreturn 1;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int c4iw_uld_rx_handler(void *handle, const __be64 *rsp,\r\nconst struct pkt_gl *gl)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nstruct c4iw_dev *dev = ctx->dev;\r\nstruct sk_buff *skb;\r\nu8 opcode;\r\nif (gl == NULL) {\r\nunsigned int len = 64 - sizeof(struct rsp_ctrl) - 8;\r\nskb = alloc_skb(256, GFP_ATOMIC);\r\nif (!skb)\r\ngoto nomem;\r\n__skb_put(skb, len);\r\nskb_copy_to_linear_data(skb, &rsp[1], len);\r\n} else if (gl == CXGB4_MSG_AN) {\r\nconst struct rsp_ctrl *rc = (void *)rsp;\r\nu32 qid = be32_to_cpu(rc->pldbuflen_qid);\r\nc4iw_ev_handler(dev, qid);\r\nreturn 0;\r\n} else if (unlikely(*(u8 *)rsp != *(u8 *)gl->va)) {\r\nif (recv_rx_pkt(dev, gl, rsp))\r\nreturn 0;\r\npr_info("%s: unexpected FL contents at %p, " \\r\n"RSS %#llx, FL %#llx, len %u\n",\r\npci_name(ctx->lldi.pdev), gl->va,\r\n(unsigned long long)be64_to_cpu(*rsp),\r\n(unsigned long long)be64_to_cpu(\r\n*(__force __be64 *)gl->va),\r\ngl->tot_len);\r\nreturn 0;\r\n} else {\r\nskb = cxgb4_pktgl_to_skb(gl, 128, 128);\r\nif (unlikely(!skb))\r\ngoto nomem;\r\n}\r\nopcode = *(u8 *)rsp;\r\nif (c4iw_handlers[opcode])\r\nc4iw_handlers[opcode](dev, skb);\r\nelse\r\npr_info("%s no handler opcode 0x%x...\n", __func__,\r\nopcode);\r\nreturn 0;\r\nnomem:\r\nreturn -1;\r\n}\r\nstatic int c4iw_uld_state_change(void *handle, enum cxgb4_state new_state)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nPDBG("%s new_state %u\n", __func__, new_state);\r\nswitch (new_state) {\r\ncase CXGB4_STATE_UP:\r\nprintk(KERN_INFO MOD "%s: Up\n", pci_name(ctx->lldi.pdev));\r\nif (!ctx->dev) {\r\nint ret;\r\nctx->dev = c4iw_alloc(&ctx->lldi);\r\nif (IS_ERR(ctx->dev)) {\r\nprintk(KERN_ERR MOD\r\n"%s: initialization failed: %ld\n",\r\npci_name(ctx->lldi.pdev),\r\nPTR_ERR(ctx->dev));\r\nctx->dev = NULL;\r\nbreak;\r\n}\r\nret = c4iw_register_device(ctx->dev);\r\nif (ret) {\r\nprintk(KERN_ERR MOD\r\n"%s: RDMA registration failed: %d\n",\r\npci_name(ctx->lldi.pdev), ret);\r\nc4iw_dealloc(ctx);\r\n}\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DOWN:\r\nprintk(KERN_INFO MOD "%s: Down\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\ncase CXGB4_STATE_START_RECOVERY:\r\nprintk(KERN_INFO MOD "%s: Fatal Error\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev) {\r\nstruct ib_event event;\r\nctx->dev->rdev.flags |= T4_FATAL_ERROR;\r\nmemset(&event, 0, sizeof event);\r\nevent.event = IB_EVENT_DEVICE_FATAL;\r\nevent.device = &ctx->dev->ibdev;\r\nib_dispatch_event(&event);\r\nc4iw_remove(ctx);\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DETACH:\r\nprintk(KERN_INFO MOD "%s: Detach\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int disable_qp_db(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nt4_disable_wq_db(&qp->wq);\r\nreturn 0;\r\n}\r\nstatic void stop_queues(struct uld_ctx *ctx)\r\n{\r\nspin_lock_irq(&ctx->dev->lock);\r\nif (ctx->dev->db_state == NORMAL) {\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nctx->dev->db_state = FLOW_CONTROL;\r\nidr_for_each(&ctx->dev->qpidr, disable_qp_db, NULL);\r\n}\r\nspin_unlock_irq(&ctx->dev->lock);\r\n}\r\nstatic int enable_qp_db(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nt4_enable_wq_db(&qp->wq);\r\nreturn 0;\r\n}\r\nstatic void resume_queues(struct uld_ctx *ctx)\r\n{\r\nspin_lock_irq(&ctx->dev->lock);\r\nif (ctx->dev->qpcnt <= db_fc_threshold &&\r\nctx->dev->db_state == FLOW_CONTROL) {\r\nctx->dev->db_state = NORMAL;\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nidr_for_each(&ctx->dev->qpidr, enable_qp_db, NULL);\r\n}\r\nspin_unlock_irq(&ctx->dev->lock);\r\n}\r\nstatic int add_and_ref_qp(int id, void *p, void *data)\r\n{\r\nstruct qp_list *qp_listp = data;\r\nstruct c4iw_qp *qp = p;\r\nc4iw_qp_add_ref(&qp->ibqp);\r\nqp_listp->qps[qp_listp->idx++] = qp;\r\nreturn 0;\r\n}\r\nstatic int count_qps(int id, void *p, void *data)\r\n{\r\nunsigned *countp = data;\r\n(*countp)++;\r\nreturn 0;\r\n}\r\nstatic void deref_qps(struct qp_list qp_list)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < qp_list.idx; idx++)\r\nc4iw_qp_rem_ref(&qp_list.qps[idx]->ibqp);\r\n}\r\nstatic void recover_lost_dbs(struct uld_ctx *ctx, struct qp_list *qp_list)\r\n{\r\nint idx;\r\nint ret;\r\nfor (idx = 0; idx < qp_list->idx; idx++) {\r\nstruct c4iw_qp *qp = qp_list->qps[idx];\r\nret = cxgb4_sync_txq_pidx(qp->rhp->rdev.lldi.ports[0],\r\nqp->wq.sq.qid,\r\nt4_sq_host_wq_pidx(&qp->wq),\r\nt4_sq_wq_size(&qp->wq));\r\nif (ret) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - "\r\n"DB overflow recovery failed - "\r\n"error syncing SQ qid %u\n",\r\npci_name(ctx->lldi.pdev), qp->wq.sq.qid);\r\nreturn;\r\n}\r\nret = cxgb4_sync_txq_pidx(qp->rhp->rdev.lldi.ports[0],\r\nqp->wq.rq.qid,\r\nt4_rq_host_wq_pidx(&qp->wq),\r\nt4_rq_wq_size(&qp->wq));\r\nif (ret) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - "\r\n"DB overflow recovery failed - "\r\n"error syncing RQ qid %u\n",\r\npci_name(ctx->lldi.pdev), qp->wq.rq.qid);\r\nreturn;\r\n}\r\nwhile (cxgb4_dbfifo_count(qp->rhp->rdev.lldi.ports[0], 1) > 0) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(10));\r\n}\r\n}\r\n}\r\nstatic void recover_queues(struct uld_ctx *ctx)\r\n{\r\nint count = 0;\r\nstruct qp_list qp_list;\r\nint ret;\r\nmutex_lock(&ctx->dev->db_mutex);\r\nspin_lock_irq(&ctx->dev->lock);\r\nctx->dev->db_state = RECOVERY;\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nidr_for_each(&ctx->dev->qpidr, disable_qp_db, NULL);\r\nspin_unlock_irq(&ctx->dev->lock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(1000));\r\nwhile (cxgb4_dbfifo_count(ctx->dev->rdev.lldi.ports[0], 1) > 0) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(10));\r\n}\r\nret = cxgb4_flush_eq_cache(ctx->dev->rdev.lldi.ports[0]);\r\nif (ret) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - DB overflow recovery failed\n",\r\npci_name(ctx->lldi.pdev));\r\ngoto out;\r\n}\r\nspin_lock_irq(&ctx->dev->lock);\r\nidr_for_each(&ctx->dev->qpidr, count_qps, &count);\r\nqp_list.qps = kzalloc(count * sizeof *qp_list.qps, GFP_ATOMIC);\r\nif (!qp_list.qps) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - DB overflow recovery failed\n",\r\npci_name(ctx->lldi.pdev));\r\nspin_unlock_irq(&ctx->dev->lock);\r\ngoto out;\r\n}\r\nqp_list.idx = 0;\r\nidr_for_each(&ctx->dev->qpidr, add_and_ref_qp, &qp_list);\r\nspin_unlock_irq(&ctx->dev->lock);\r\nrecover_lost_dbs(ctx, &qp_list);\r\nderef_qps(qp_list);\r\nkfree(qp_list.qps);\r\nwhile (cxgb4_dbfifo_count(ctx->dev->rdev.lldi.ports[0], 1) > 0) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(10));\r\n}\r\nspin_lock_irq(&ctx->dev->lock);\r\nif (ctx->dev->qpcnt > db_fc_threshold)\r\nctx->dev->db_state = FLOW_CONTROL;\r\nelse {\r\nctx->dev->db_state = NORMAL;\r\nidr_for_each(&ctx->dev->qpidr, enable_qp_db, NULL);\r\n}\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nspin_unlock_irq(&ctx->dev->lock);\r\nout:\r\nmutex_unlock(&ctx->dev->db_mutex);\r\n}\r\nstatic int c4iw_uld_control(void *handle, enum cxgb4_control control, ...)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nswitch (control) {\r\ncase CXGB4_CONTROL_DB_FULL:\r\nstop_queues(ctx);\r\nmutex_lock(&ctx->dev->rdev.stats.lock);\r\nctx->dev->rdev.stats.db_full++;\r\nmutex_unlock(&ctx->dev->rdev.stats.lock);\r\nbreak;\r\ncase CXGB4_CONTROL_DB_EMPTY:\r\nresume_queues(ctx);\r\nmutex_lock(&ctx->dev->rdev.stats.lock);\r\nctx->dev->rdev.stats.db_empty++;\r\nmutex_unlock(&ctx->dev->rdev.stats.lock);\r\nbreak;\r\ncase CXGB4_CONTROL_DB_DROP:\r\nrecover_queues(ctx);\r\nmutex_lock(&ctx->dev->rdev.stats.lock);\r\nctx->dev->rdev.stats.db_drop++;\r\nmutex_unlock(&ctx->dev->rdev.stats.lock);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING MOD "%s: unknown control cmd %u\n",\r\npci_name(ctx->lldi.pdev), control);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init c4iw_init_module(void)\r\n{\r\nint err;\r\nerr = c4iw_cm_init();\r\nif (err)\r\nreturn err;\r\nc4iw_debugfs_root = debugfs_create_dir(DRV_NAME, NULL);\r\nif (!c4iw_debugfs_root)\r\nprintk(KERN_WARNING MOD\r\n"could not create debugfs entry, continuing\n");\r\ncxgb4_register_uld(CXGB4_ULD_RDMA, &c4iw_uld_info);\r\nreturn 0;\r\n}\r\nstatic void __exit c4iw_exit_module(void)\r\n{\r\nstruct uld_ctx *ctx, *tmp;\r\nmutex_lock(&dev_mutex);\r\nlist_for_each_entry_safe(ctx, tmp, &uld_ctx_list, entry) {\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nkfree(ctx);\r\n}\r\nmutex_unlock(&dev_mutex);\r\ncxgb4_unregister_uld(CXGB4_ULD_RDMA);\r\nc4iw_cm_term();\r\ndebugfs_remove_recursive(c4iw_debugfs_root);\r\n}
