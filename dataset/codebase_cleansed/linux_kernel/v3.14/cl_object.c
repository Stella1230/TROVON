int cl_object_header_init(struct cl_object_header *h)\r\n{\r\nint result;\r\nresult = lu_object_header_init(&h->coh_lu);\r\nif (result == 0) {\r\nspin_lock_init(&h->coh_page_guard);\r\nspin_lock_init(&h->coh_lock_guard);\r\nspin_lock_init(&h->coh_attr_guard);\r\nlockdep_set_class(&h->coh_page_guard, &cl_page_guard_class);\r\nlockdep_set_class(&h->coh_lock_guard, &cl_lock_guard_class);\r\nlockdep_set_class(&h->coh_attr_guard, &cl_attr_guard_class);\r\nh->coh_pages = 0;\r\nINIT_RADIX_TREE(&h->coh_tree, GFP_ATOMIC);\r\nINIT_LIST_HEAD(&h->coh_locks);\r\nh->coh_page_bufsize = ALIGN(sizeof(struct cl_page), 8);\r\n}\r\nreturn result;\r\n}\r\nvoid cl_object_header_fini(struct cl_object_header *h)\r\n{\r\nLASSERT(list_empty(&h->coh_locks));\r\nlu_object_header_fini(&h->coh_lu);\r\n}\r\nstruct cl_object *cl_object_find(const struct lu_env *env,\r\nstruct cl_device *cd, const struct lu_fid *fid,\r\nconst struct cl_object_conf *c)\r\n{\r\nmight_sleep();\r\nreturn lu2cl(lu_object_find_slice(env, cl2lu_dev(cd), fid, &c->coc_lu));\r\n}\r\nvoid cl_object_put(const struct lu_env *env, struct cl_object *o)\r\n{\r\nlu_object_put(env, &o->co_lu);\r\n}\r\nvoid cl_object_get(struct cl_object *o)\r\n{\r\nlu_object_get(&o->co_lu);\r\n}\r\nstruct cl_object *cl_object_top(struct cl_object *o)\r\n{\r\nstruct cl_object_header *hdr = cl_object_header(o);\r\nstruct cl_object *top;\r\nwhile (hdr->coh_parent != NULL)\r\nhdr = hdr->coh_parent;\r\ntop = lu2cl(lu_object_top(&hdr->coh_lu));\r\nCDEBUG(D_TRACE, "%p -> %p\n", o, top);\r\nreturn top;\r\n}\r\nstatic spinlock_t *cl_object_attr_guard(struct cl_object *o)\r\n{\r\nreturn &cl_object_header(cl_object_top(o))->coh_attr_guard;\r\n}\r\nvoid cl_object_attr_lock(struct cl_object *o)\r\n{\r\nspin_lock(cl_object_attr_guard(o));\r\n}\r\nvoid cl_object_attr_unlock(struct cl_object *o)\r\n{\r\nspin_unlock(cl_object_attr_guard(o));\r\n}\r\nint cl_object_attr_get(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nstruct lu_object_header *top;\r\nint result;\r\nLASSERT(spin_is_locked(cl_object_attr_guard(obj)));\r\ntop = obj->co_lu.lo_header;\r\nresult = 0;\r\nlist_for_each_entry(obj, &top->loh_layers, co_lu.lo_linkage) {\r\nif (obj->co_ops->coo_attr_get != NULL) {\r\nresult = obj->co_ops->coo_attr_get(env, obj, attr);\r\nif (result != 0) {\r\nif (result > 0)\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nint cl_object_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned v)\r\n{\r\nstruct lu_object_header *top;\r\nint result;\r\nLASSERT(spin_is_locked(cl_object_attr_guard(obj)));\r\ntop = obj->co_lu.lo_header;\r\nresult = 0;\r\nlist_for_each_entry_reverse(obj, &top->loh_layers,\r\nco_lu.lo_linkage) {\r\nif (obj->co_ops->coo_attr_set != NULL) {\r\nresult = obj->co_ops->coo_attr_set(env, obj, attr, v);\r\nif (result != 0) {\r\nif (result > 0)\r\nresult = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nint cl_object_glimpse(const struct lu_env *env, struct cl_object *obj,\r\nstruct ost_lvb *lvb)\r\n{\r\nstruct lu_object_header *top;\r\nint result;\r\ntop = obj->co_lu.lo_header;\r\nresult = 0;\r\nlist_for_each_entry_reverse(obj, &top->loh_layers,\r\nco_lu.lo_linkage) {\r\nif (obj->co_ops->coo_glimpse != NULL) {\r\nresult = obj->co_ops->coo_glimpse(env, obj, lvb);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nLU_OBJECT_HEADER(D_DLMTRACE, env, lu_object_top(top),\r\n"size: "LPU64" mtime: "LPU64" atime: "LPU64" "\r\n"ctime: "LPU64" blocks: "LPU64"\n",\r\nlvb->lvb_size, lvb->lvb_mtime, lvb->lvb_atime,\r\nlvb->lvb_ctime, lvb->lvb_blocks);\r\nreturn result;\r\n}\r\nint cl_conf_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_object_conf *conf)\r\n{\r\nstruct lu_object_header *top;\r\nint result;\r\ntop = obj->co_lu.lo_header;\r\nresult = 0;\r\nlist_for_each_entry(obj, &top->loh_layers, co_lu.lo_linkage) {\r\nif (obj->co_ops->coo_conf_set != NULL) {\r\nresult = obj->co_ops->coo_conf_set(env, obj, conf);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nvoid cl_object_kill(const struct lu_env *env, struct cl_object *obj)\r\n{\r\nstruct cl_object_header *hdr;\r\nhdr = cl_object_header(obj);\r\nLASSERT(hdr->coh_tree.rnode == NULL);\r\nLASSERT(hdr->coh_pages == 0);\r\nset_bit(LU_OBJECT_HEARD_BANSHEE, &hdr->coh_lu.loh_flags);\r\ncl_locks_prune(env, obj, 0);\r\n}\r\nvoid cl_object_prune(const struct lu_env *env, struct cl_object *obj)\r\n{\r\ncl_pages_prune(env, obj);\r\ncl_locks_prune(env, obj, 1);\r\n}\r\nint cl_object_has_locks(struct cl_object *obj)\r\n{\r\nstruct cl_object_header *head = cl_object_header(obj);\r\nint has;\r\nspin_lock(&head->coh_lock_guard);\r\nhas = list_empty(&head->coh_locks);\r\nspin_unlock(&head->coh_lock_guard);\r\nreturn (has == 0);\r\n}\r\nvoid cache_stats_init(struct cache_stats *cs, const char *name)\r\n{\r\nint i;\r\ncs->cs_name = name;\r\nfor (i = 0; i < CS_NR; i++)\r\natomic_set(&cs->cs_stats[i], 0);\r\n}\r\nint cache_stats_print(const struct cache_stats *cs, struct seq_file *m, int h)\r\n{\r\nint i;\r\nif (h) {\r\nconst char *names[CS_NR] = CS_NAMES;\r\nseq_printf(m, "%6s", " ");\r\nfor (i = 0; i < CS_NR; i++)\r\nseq_printf(m, "%8s", names[i]);\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "%5.5s:", cs->cs_name);\r\nfor (i = 0; i < CS_NR; i++)\r\nseq_printf(m, "%8u", atomic_read(&cs->cs_stats[i]));\r\nreturn 0;\r\n}\r\nint cl_site_init(struct cl_site *s, struct cl_device *d)\r\n{\r\nint i;\r\nint result;\r\nresult = lu_site_init(&s->cs_lu, &d->cd_lu_dev);\r\nif (result == 0) {\r\ncache_stats_init(&s->cs_pages, "pages");\r\ncache_stats_init(&s->cs_locks, "locks");\r\nfor (i = 0; i < ARRAY_SIZE(s->cs_pages_state); ++i)\r\natomic_set(&s->cs_pages_state[0], 0);\r\nfor (i = 0; i < ARRAY_SIZE(s->cs_locks_state); ++i)\r\natomic_set(&s->cs_locks_state[i], 0);\r\n}\r\nreturn result;\r\n}\r\nvoid cl_site_fini(struct cl_site *s)\r\n{\r\nlu_site_fini(&s->cs_lu);\r\n}\r\nint cl_site_stats_print(const struct cl_site *site, struct seq_file *m)\r\n{\r\nint i;\r\nstatic const char *pstate[] = {\r\n[CPS_CACHED] = "c",\r\n[CPS_OWNED] = "o",\r\n[CPS_PAGEOUT] = "w",\r\n[CPS_PAGEIN] = "r",\r\n[CPS_FREEING] = "f"\r\n};\r\nstatic const char *lstate[] = {\r\n[CLS_NEW] = "n",\r\n[CLS_QUEUING] = "q",\r\n[CLS_ENQUEUED] = "e",\r\n[CLS_HELD] = "h",\r\n[CLS_INTRANSIT] = "t",\r\n[CLS_CACHED] = "c",\r\n[CLS_FREEING] = "f"\r\n};\r\nlu_site_stats_print(&site->cs_lu, m);\r\ncache_stats_print(&site->cs_pages, m, 1);\r\nseq_printf(m, " [");\r\nfor (i = 0; i < ARRAY_SIZE(site->cs_pages_state); ++i)\r\nseq_printf(m, "%s: %u ", pstate[i],\r\natomic_read(&site->cs_pages_state[i]));\r\nseq_printf(m, "]\n");\r\ncache_stats_print(&site->cs_locks, m, 0);\r\nseq_printf(m, " [");\r\nfor (i = 0; i < ARRAY_SIZE(site->cs_locks_state); ++i)\r\nseq_printf(m, "%s: %u ", lstate[i],\r\natomic_read(&site->cs_locks_state[i]));\r\nseq_printf(m, "]\n");\r\ncache_stats_print(&cl_env_stats, m, 0);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic void cl_env_init0(struct cl_env *cle, void *debug)\r\n{\r\nLASSERT(cle->ce_ref == 0);\r\nLASSERT(cle->ce_magic == &cl_env_init0);\r\nLASSERT(cle->ce_debug == NULL && cle->ce_owner == NULL);\r\ncle->ce_ref = 1;\r\ncle->ce_debug = debug;\r\nCL_ENV_INC(busy);\r\n}\r\nstatic unsigned cl_env_hops_hash(struct cfs_hash *lh,\r\nconst void *key, unsigned mask)\r\n{\r\n#if BITS_PER_LONG == 64\r\nreturn cfs_hash_u64_hash((__u64)key, mask);\r\n#else\r\nreturn cfs_hash_u32_hash((__u32)key, mask);\r\n#endif\r\n}\r\nstatic void *cl_env_hops_obj(struct hlist_node *hn)\r\n{\r\nstruct cl_env *cle = hlist_entry(hn, struct cl_env, ce_node);\r\nLASSERT(cle->ce_magic == &cl_env_init0);\r\nreturn (void *)cle;\r\n}\r\nstatic int cl_env_hops_keycmp(const void *key, struct hlist_node *hn)\r\n{\r\nstruct cl_env *cle = cl_env_hops_obj(hn);\r\nLASSERT(cle->ce_owner != NULL);\r\nreturn (key == cle->ce_owner);\r\n}\r\nstatic void cl_env_hops_noop(struct cfs_hash *hs, struct hlist_node *hn)\r\n{\r\nstruct cl_env *cle = hlist_entry(hn, struct cl_env, ce_node);\r\nLASSERT(cle->ce_magic == &cl_env_init0);\r\n}\r\nstatic inline struct cl_env *cl_env_fetch(void)\r\n{\r\nstruct cl_env *cle;\r\ncle = cfs_hash_lookup(cl_env_hash, (void *) (long) current->pid);\r\nLASSERT(ergo(cle, cle->ce_magic == &cl_env_init0));\r\nreturn cle;\r\n}\r\nstatic inline void cl_env_attach(struct cl_env *cle)\r\n{\r\nif (cle) {\r\nint rc;\r\nLASSERT(cle->ce_owner == NULL);\r\ncle->ce_owner = (void *) (long) current->pid;\r\nrc = cfs_hash_add_unique(cl_env_hash, cle->ce_owner,\r\n&cle->ce_node);\r\nLASSERT(rc == 0);\r\n}\r\n}\r\nstatic inline void cl_env_do_detach(struct cl_env *cle)\r\n{\r\nvoid *cookie;\r\nLASSERT(cle->ce_owner == (void *) (long) current->pid);\r\ncookie = cfs_hash_del(cl_env_hash, cle->ce_owner,\r\n&cle->ce_node);\r\nLASSERT(cookie == cle);\r\ncle->ce_owner = NULL;\r\n}\r\nstatic int cl_env_store_init(void) {\r\ncl_env_hash = cfs_hash_create("cl_env",\r\nHASH_CL_ENV_BITS, HASH_CL_ENV_BITS,\r\nHASH_CL_ENV_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&cl_env_hops,\r\nCFS_HASH_RW_BKTLOCK);\r\nreturn cl_env_hash != NULL ? 0 :-ENOMEM;\r\n}\r\nstatic void cl_env_store_fini(void) {\r\ncfs_hash_putref(cl_env_hash);\r\n}\r\nstatic inline struct cl_env *cl_env_detach(struct cl_env *cle)\r\n{\r\nif (cle == NULL)\r\ncle = cl_env_fetch();\r\nif (cle && cle->ce_owner)\r\ncl_env_do_detach(cle);\r\nreturn cle;\r\n}\r\nstatic struct lu_env *cl_env_new(__u32 ctx_tags, __u32 ses_tags, void *debug)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_env *cle;\r\nOBD_SLAB_ALLOC_PTR_GFP(cle, cl_env_kmem, __GFP_IO);\r\nif (cle != NULL) {\r\nint rc;\r\nINIT_LIST_HEAD(&cle->ce_linkage);\r\ncle->ce_magic = &cl_env_init0;\r\nenv = &cle->ce_lu;\r\nrc = lu_env_init(env, LCT_CL_THREAD|ctx_tags);\r\nif (rc == 0) {\r\nrc = lu_context_init(&cle->ce_ses,\r\nLCT_SESSION | ses_tags);\r\nif (rc == 0) {\r\nlu_context_enter(&cle->ce_ses);\r\nenv->le_ses = &cle->ce_ses;\r\ncl_env_init0(cle, debug);\r\n} else\r\nlu_env_fini(env);\r\n}\r\nif (rc != 0) {\r\nOBD_SLAB_FREE_PTR(cle, cl_env_kmem);\r\nenv = ERR_PTR(rc);\r\n} else {\r\nCL_ENV_INC(create);\r\nCL_ENV_INC(total);\r\n}\r\n} else\r\nenv = ERR_PTR(-ENOMEM);\r\nreturn env;\r\n}\r\nstatic void cl_env_fini(struct cl_env *cle)\r\n{\r\nCL_ENV_DEC(total);\r\nlu_context_fini(&cle->ce_lu.le_ctx);\r\nlu_context_fini(&cle->ce_ses);\r\nOBD_SLAB_FREE_PTR(cle, cl_env_kmem);\r\n}\r\nstatic inline struct cl_env *cl_env_container(struct lu_env *env)\r\n{\r\nreturn container_of(env, struct cl_env, ce_lu);\r\n}\r\nstruct lu_env *cl_env_peek(int *refcheck)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_env *cle;\r\nCL_ENV_INC(lookup);\r\nCLASSERT(offsetof(struct cl_env, ce_magic) == 0);\r\nenv = NULL;\r\ncle = cl_env_fetch();\r\nif (cle != NULL) {\r\nCL_ENV_INC(hit);\r\nenv = &cle->ce_lu;\r\n*refcheck = ++cle->ce_ref;\r\n}\r\nCDEBUG(D_OTHER, "%d@%p\n", cle ? cle->ce_ref : 0, cle);\r\nreturn env;\r\n}\r\nstruct lu_env *cl_env_get(int *refcheck)\r\n{\r\nstruct lu_env *env;\r\nenv = cl_env_peek(refcheck);\r\nif (env == NULL) {\r\nenv = cl_env_new(lu_context_tags_default,\r\nlu_session_tags_default,\r\n__builtin_return_address(0));\r\nif (!IS_ERR(env)) {\r\nstruct cl_env *cle;\r\ncle = cl_env_container(env);\r\ncl_env_attach(cle);\r\n*refcheck = cle->ce_ref;\r\nCDEBUG(D_OTHER, "%d@%p\n", cle->ce_ref, cle);\r\n}\r\n}\r\nreturn env;\r\n}\r\nstruct lu_env *cl_env_alloc(int *refcheck, __u32 tags)\r\n{\r\nstruct lu_env *env;\r\nLASSERT(cl_env_peek(refcheck) == NULL);\r\nenv = cl_env_new(tags, tags, __builtin_return_address(0));\r\nif (!IS_ERR(env)) {\r\nstruct cl_env *cle;\r\ncle = cl_env_container(env);\r\n*refcheck = cle->ce_ref;\r\nCDEBUG(D_OTHER, "%d@%p\n", cle->ce_ref, cle);\r\n}\r\nreturn env;\r\n}\r\nstatic void cl_env_exit(struct cl_env *cle)\r\n{\r\nLASSERT(cle->ce_owner == NULL);\r\nlu_context_exit(&cle->ce_lu.le_ctx);\r\nlu_context_exit(&cle->ce_ses);\r\n}\r\nvoid cl_env_put(struct lu_env *env, int *refcheck)\r\n{\r\nstruct cl_env *cle;\r\ncle = cl_env_container(env);\r\nLASSERT(cle->ce_ref > 0);\r\nLASSERT(ergo(refcheck != NULL, cle->ce_ref == *refcheck));\r\nCDEBUG(D_OTHER, "%d@%p\n", cle->ce_ref, cle);\r\nif (--cle->ce_ref == 0) {\r\nCL_ENV_DEC(busy);\r\ncl_env_detach(cle);\r\ncle->ce_debug = NULL;\r\ncl_env_exit(cle);\r\ncl_env_fini(cle);\r\n}\r\n}\r\nvoid *cl_env_reenter(void)\r\n{\r\nreturn cl_env_detach(NULL);\r\n}\r\nvoid cl_env_reexit(void *cookie)\r\n{\r\ncl_env_detach(NULL);\r\ncl_env_attach(cookie);\r\n}\r\nvoid cl_env_implant(struct lu_env *env, int *refcheck)\r\n{\r\nstruct cl_env *cle = cl_env_container(env);\r\nLASSERT(cle->ce_ref > 0);\r\ncl_env_attach(cle);\r\ncl_env_get(refcheck);\r\nCDEBUG(D_OTHER, "%d@%p\n", cle->ce_ref, cle);\r\n}\r\nvoid cl_env_unplant(struct lu_env *env, int *refcheck)\r\n{\r\nstruct cl_env *cle = cl_env_container(env);\r\nLASSERT(cle->ce_ref > 1);\r\nCDEBUG(D_OTHER, "%d@%p\n", cle->ce_ref, cle);\r\ncl_env_detach(cle);\r\ncl_env_put(env, refcheck);\r\n}\r\nstruct lu_env *cl_env_nested_get(struct cl_env_nest *nest)\r\n{\r\nstruct lu_env *env;\r\nnest->cen_cookie = NULL;\r\nenv = cl_env_peek(&nest->cen_refcheck);\r\nif (env != NULL) {\r\nif (!cl_io_is_going(env))\r\nreturn env;\r\nelse {\r\ncl_env_put(env, &nest->cen_refcheck);\r\nnest->cen_cookie = cl_env_reenter();\r\n}\r\n}\r\nenv = cl_env_get(&nest->cen_refcheck);\r\nif (IS_ERR(env)) {\r\ncl_env_reexit(nest->cen_cookie);\r\nreturn env;\r\n}\r\nLASSERT(!cl_io_is_going(env));\r\nreturn env;\r\n}\r\nvoid cl_env_nested_put(struct cl_env_nest *nest, struct lu_env *env)\r\n{\r\ncl_env_put(env, &nest->cen_refcheck);\r\ncl_env_reexit(nest->cen_cookie);\r\n}\r\nvoid cl_attr2lvb(struct ost_lvb *lvb, const struct cl_attr *attr)\r\n{\r\nlvb->lvb_size = attr->cat_size;\r\nlvb->lvb_mtime = attr->cat_mtime;\r\nlvb->lvb_atime = attr->cat_atime;\r\nlvb->lvb_ctime = attr->cat_ctime;\r\nlvb->lvb_blocks = attr->cat_blocks;\r\n}\r\nvoid cl_lvb2attr(struct cl_attr *attr, const struct ost_lvb *lvb)\r\n{\r\nattr->cat_size = lvb->lvb_size;\r\nattr->cat_mtime = lvb->lvb_mtime;\r\nattr->cat_atime = lvb->lvb_atime;\r\nattr->cat_ctime = lvb->lvb_ctime;\r\nattr->cat_blocks = lvb->lvb_blocks;\r\n}\r\nstruct cl_device *cl_type_setup(const struct lu_env *env, struct lu_site *site,\r\nstruct lu_device_type *ldt,\r\nstruct lu_device *next)\r\n{\r\nconst char *typename;\r\nstruct lu_device *d;\r\nLASSERT(ldt != NULL);\r\ntypename = ldt->ldt_name;\r\nd = ldt->ldt_ops->ldto_device_alloc(env, ldt, NULL);\r\nif (!IS_ERR(d)) {\r\nint rc;\r\nif (site != NULL)\r\nd->ld_site = site;\r\nrc = ldt->ldt_ops->ldto_device_init(env, d, typename, next);\r\nif (rc == 0) {\r\nlu_device_get(d);\r\nlu_ref_add(&d->ld_reference,\r\n"lu-stack", &lu_site_init);\r\n} else {\r\nldt->ldt_ops->ldto_device_free(env, d);\r\nCERROR("can't init device '%s', %d\n", typename, rc);\r\nd = ERR_PTR(rc);\r\n}\r\n} else\r\nCERROR("Cannot allocate device: '%s'\n", typename);\r\nreturn lu2cl_dev(d);\r\n}\r\nvoid cl_stack_fini(const struct lu_env *env, struct cl_device *cl)\r\n{\r\nlu_stack_fini(env, cl2lu_dev(cl));\r\n}\r\nstruct cl_thread_info *cl_env_info(const struct lu_env *env)\r\n{\r\nreturn lu_context_key_get(&env->le_ctx, &cl_key);\r\n}\r\nstatic void *cl_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct cl_thread_info *info;\r\ninfo = cl0_key_init(ctx, key);\r\nif (!IS_ERR(info)) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(info->clt_counters); ++i)\r\nlu_ref_init(&info->clt_counters[i].ctc_locks_locked);\r\n}\r\nreturn info;\r\n}\r\nstatic void cl_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct cl_thread_info *info;\r\nint i;\r\ninfo = data;\r\nfor (i = 0; i < ARRAY_SIZE(info->clt_counters); ++i)\r\nlu_ref_fini(&info->clt_counters[i].ctc_locks_locked);\r\ncl0_key_fini(ctx, key, data);\r\n}\r\nstatic void cl_key_exit(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct cl_thread_info *info = data;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(info->clt_counters); ++i) {\r\nLASSERT(info->clt_counters[i].ctc_nr_held == 0);\r\nLASSERT(info->clt_counters[i].ctc_nr_used == 0);\r\nLASSERT(info->clt_counters[i].ctc_nr_locks_acquired == 0);\r\nLASSERT(info->clt_counters[i].ctc_nr_locks_locked == 0);\r\nlu_ref_fini(&info->clt_counters[i].ctc_locks_locked);\r\nlu_ref_init(&info->clt_counters[i].ctc_locks_locked);\r\n}\r\n}\r\nint cl_global_init(void)\r\n{\r\nint result;\r\nresult = cl_env_store_init();\r\nif (result)\r\nreturn result;\r\nresult = lu_kmem_init(cl_object_caches);\r\nif (result)\r\ngoto out_store;\r\nLU_CONTEXT_KEY_INIT(&cl_key);\r\nresult = lu_context_key_register(&cl_key);\r\nif (result)\r\ngoto out_kmem;\r\nresult = cl_lock_init();\r\nif (result)\r\ngoto out_context;\r\nresult = cl_page_init();\r\nif (result)\r\ngoto out_lock;\r\nreturn 0;\r\nout_lock:\r\ncl_lock_fini();\r\nout_context:\r\nlu_context_key_degister(&cl_key);\r\nout_kmem:\r\nlu_kmem_fini(cl_object_caches);\r\nout_store:\r\ncl_env_store_fini();\r\nreturn result;\r\n}\r\nvoid cl_global_fini(void)\r\n{\r\ncl_lock_fini();\r\ncl_page_fini();\r\nlu_context_key_degister(&cl_key);\r\nlu_kmem_fini(cl_object_caches);\r\ncl_env_store_fini();\r\n}
