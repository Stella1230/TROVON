static void set_safe_settings(void)\r\n{\r\nif (use_safe_settings)\r\n{\r\nint i;\r\ndprintkl(KERN_INFO, "Using safe settings.\n");\r\nfor (i = 0; i < CFG_NUM; i++)\r\n{\r\ncfg_data[i].value = cfg_data[i].safe;\r\n}\r\n}\r\n}\r\nstatic void fix_settings(void)\r\n{\r\nint i;\r\ndprintkdbg(DBG_1,\r\n"setup: AdapterId=%08x MaxSpeed=%08x DevMode=%08x "\r\n"AdapterMode=%08x Tags=%08x ResetDelay=%08x\n",\r\ncfg_data[CFG_ADAPTER_ID].value,\r\ncfg_data[CFG_MAX_SPEED].value,\r\ncfg_data[CFG_DEV_MODE].value,\r\ncfg_data[CFG_ADAPTER_MODE].value,\r\ncfg_data[CFG_TAGS].value,\r\ncfg_data[CFG_RESET_DELAY].value);\r\nfor (i = 0; i < CFG_NUM; i++)\r\n{\r\nif (cfg_data[i].value < cfg_data[i].min\r\n|| cfg_data[i].value > cfg_data[i].max)\r\ncfg_data[i].value = cfg_data[i].def;\r\n}\r\n}\r\nstatic void eeprom_index_to_delay(struct NvRamType *eeprom)\r\n{\r\neeprom->delay_time = eeprom_index_to_delay_map[eeprom->delay_time];\r\n}\r\nstatic int delay_to_eeprom_index(int delay)\r\n{\r\nu8 idx = 0;\r\nwhile (idx < 7 && eeprom_index_to_delay_map[idx] < delay)\r\nidx++;\r\nreturn idx;\r\n}\r\nstatic void eeprom_override(struct NvRamType *eeprom)\r\n{\r\nu8 id;\r\nif (cfg_data[CFG_ADAPTER_ID].value != CFG_PARAM_UNSET)\r\neeprom->scsi_id = (u8)cfg_data[CFG_ADAPTER_ID].value;\r\nif (cfg_data[CFG_ADAPTER_MODE].value != CFG_PARAM_UNSET)\r\neeprom->channel_cfg = (u8)cfg_data[CFG_ADAPTER_MODE].value;\r\nif (cfg_data[CFG_RESET_DELAY].value != CFG_PARAM_UNSET)\r\neeprom->delay_time = delay_to_eeprom_index(\r\ncfg_data[CFG_RESET_DELAY].value);\r\nif (cfg_data[CFG_TAGS].value != CFG_PARAM_UNSET)\r\neeprom->max_tag = (u8)cfg_data[CFG_TAGS].value;\r\nfor (id = 0; id < DC395x_MAX_SCSI_ID; id++) {\r\nif (cfg_data[CFG_DEV_MODE].value != CFG_PARAM_UNSET)\r\neeprom->target[id].cfg0 =\r\n(u8)cfg_data[CFG_DEV_MODE].value;\r\nif (cfg_data[CFG_MAX_SPEED].value != CFG_PARAM_UNSET)\r\neeprom->target[id].period =\r\n(u8)cfg_data[CFG_MAX_SPEED].value;\r\n}\r\n}\r\nstatic unsigned int list_size(struct list_head *head)\r\n{\r\nunsigned int count = 0;\r\nstruct list_head *pos;\r\nlist_for_each(pos, head)\r\ncount++;\r\nreturn count;\r\n}\r\nstatic struct DeviceCtlBlk *dcb_get_next(struct list_head *head,\r\nstruct DeviceCtlBlk *pos)\r\n{\r\nint use_next = 0;\r\nstruct DeviceCtlBlk* next = NULL;\r\nstruct DeviceCtlBlk* i;\r\nif (list_empty(head))\r\nreturn NULL;\r\nlist_for_each_entry(i, head, list)\r\nif (use_next) {\r\nnext = i;\r\nbreak;\r\n} else if (i == pos) {\r\nuse_next = 1;\r\n}\r\nif (!next)\r\nlist_for_each_entry(i, head, list) {\r\nnext = i;\r\nbreak;\r\n}\r\nreturn next;\r\n}\r\nstatic void free_tag(struct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\r\n{\r\nif (srb->tag_number < 255) {\r\ndcb->tag_mask &= ~(1 << srb->tag_number);\r\nsrb->tag_number = 255;\r\n}\r\n}\r\nstatic inline struct ScsiReqBlk *find_cmd(struct scsi_cmnd *cmd,\r\nstruct list_head *head)\r\n{\r\nstruct ScsiReqBlk *i;\r\nlist_for_each_entry(i, head, list)\r\nif (i->cmd == cmd)\r\nreturn i;\r\nreturn NULL;\r\n}\r\nstatic struct ScsiReqBlk *srb_get_free(struct AdapterCtlBlk *acb)\r\n{\r\nstruct list_head *head = &acb->srb_free_list;\r\nstruct ScsiReqBlk *srb = NULL;\r\nif (!list_empty(head)) {\r\nsrb = list_entry(head->next, struct ScsiReqBlk, list);\r\nlist_del(head->next);\r\ndprintkdbg(DBG_0, "srb_get_free: srb=%p\n", srb);\r\n}\r\nreturn srb;\r\n}\r\nstatic void srb_free_insert(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0, "srb_free_insert: srb=%p\n", srb);\r\nlist_add_tail(&srb->list, &acb->srb_free_list);\r\n}\r\nstatic void srb_waiting_insert(struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0, "srb_waiting_insert: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_add(&srb->list, &dcb->srb_waiting_list);\r\n}\r\nstatic void srb_waiting_append(struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0, "srb_waiting_append: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_add_tail(&srb->list, &dcb->srb_waiting_list);\r\n}\r\nstatic void srb_going_append(struct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0, "srb_going_append: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_add_tail(&srb->list, &dcb->srb_going_list);\r\n}\r\nstatic void srb_going_remove(struct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\r\n{\r\nstruct ScsiReqBlk *i;\r\nstruct ScsiReqBlk *tmp;\r\ndprintkdbg(DBG_0, "srb_going_remove: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_for_each_entry_safe(i, tmp, &dcb->srb_going_list, list)\r\nif (i == srb) {\r\nlist_del(&srb->list);\r\nbreak;\r\n}\r\n}\r\nstatic void srb_waiting_remove(struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nstruct ScsiReqBlk *i;\r\nstruct ScsiReqBlk *tmp;\r\ndprintkdbg(DBG_0, "srb_waiting_remove: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_for_each_entry_safe(i, tmp, &dcb->srb_waiting_list, list)\r\nif (i == srb) {\r\nlist_del(&srb->list);\r\nbreak;\r\n}\r\n}\r\nstatic void srb_going_to_waiting_move(struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0,\r\n"srb_going_to_waiting_move: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_move(&srb->list, &dcb->srb_waiting_list);\r\n}\r\nstatic void srb_waiting_to_going_move(struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\ndprintkdbg(DBG_0,\r\n"srb_waiting_to_going_move: (0x%p) <%02i-%i> srb=%p\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun, srb);\r\nlist_move(&srb->list, &dcb->srb_going_list);\r\n}\r\nstatic void waiting_set_timer(struct AdapterCtlBlk *acb, unsigned long to)\r\n{\r\nif (timer_pending(&acb->waiting_timer))\r\nreturn;\r\ninit_timer(&acb->waiting_timer);\r\nacb->waiting_timer.function = waiting_timeout;\r\nacb->waiting_timer.data = (unsigned long) acb;\r\nif (time_before(jiffies + to, acb->last_reset - HZ / 2))\r\nacb->waiting_timer.expires =\r\nacb->last_reset - HZ / 2 + 1;\r\nelse\r\nacb->waiting_timer.expires = jiffies + to + 1;\r\nadd_timer(&acb->waiting_timer);\r\n}\r\nstatic void waiting_process_next(struct AdapterCtlBlk *acb)\r\n{\r\nstruct DeviceCtlBlk *start = NULL;\r\nstruct DeviceCtlBlk *pos;\r\nstruct DeviceCtlBlk *dcb;\r\nstruct ScsiReqBlk *srb;\r\nstruct list_head *dcb_list_head = &acb->dcb_list;\r\nif (acb->active_dcb\r\n|| (acb->acb_flag & (RESET_DETECT + RESET_DONE + RESET_DEV)))\r\nreturn;\r\nif (timer_pending(&acb->waiting_timer))\r\ndel_timer(&acb->waiting_timer);\r\nif (list_empty(dcb_list_head))\r\nreturn;\r\nlist_for_each_entry(dcb, dcb_list_head, list)\r\nif (dcb == acb->dcb_run_robin) {\r\nstart = dcb;\r\nbreak;\r\n}\r\nif (!start) {\r\nstart = list_entry(dcb_list_head->next, typeof(*start), list);\r\nacb->dcb_run_robin = start;\r\n}\r\npos = start;\r\ndo {\r\nstruct list_head *waiting_list_head = &pos->srb_waiting_list;\r\nacb->dcb_run_robin = dcb_get_next(dcb_list_head,\r\nacb->dcb_run_robin);\r\nif (list_empty(waiting_list_head) ||\r\npos->max_command <= list_size(&pos->srb_going_list)) {\r\npos = dcb_get_next(dcb_list_head, pos);\r\n} else {\r\nsrb = list_entry(waiting_list_head->next,\r\nstruct ScsiReqBlk, list);\r\nif (!start_scsi(acb, pos, srb))\r\nsrb_waiting_to_going_move(pos, srb);\r\nelse\r\nwaiting_set_timer(acb, HZ/50);\r\nbreak;\r\n}\r\n} while (pos != start);\r\n}\r\nstatic void waiting_timeout(unsigned long ptr)\r\n{\r\nunsigned long flags;\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)ptr;\r\ndprintkdbg(DBG_1,\r\n"waiting_timeout: Queue woken up by timer. acb=%p\n", acb);\r\nDC395x_LOCK_IO(acb->scsi_host, flags);\r\nwaiting_process_next(acb);\r\nDC395x_UNLOCK_IO(acb->scsi_host, flags);\r\n}\r\nstatic struct DeviceCtlBlk *find_dcb(struct AdapterCtlBlk *acb, u8 id, u8 lun)\r\n{\r\nreturn acb->children[id][lun];\r\n}\r\nstatic void send_srb(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\nif (dcb->max_command <= list_size(&dcb->srb_going_list) ||\r\nacb->active_dcb ||\r\n(acb->acb_flag & (RESET_DETECT + RESET_DONE + RESET_DEV))) {\r\nsrb_waiting_append(dcb, srb);\r\nwaiting_process_next(acb);\r\nreturn;\r\n}\r\nif (!start_scsi(acb, dcb, srb))\r\nsrb_going_append(dcb, srb);\r\nelse {\r\nsrb_waiting_insert(dcb, srb);\r\nwaiting_set_timer(acb, HZ / 50);\r\n}\r\n}\r\nstatic void build_srb(struct scsi_cmnd *cmd, struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nint nseg;\r\nenum dma_data_direction dir = cmd->sc_data_direction;\r\ndprintkdbg(DBG_0, "build_srb: (0x%p) <%02i-%i>\n",\r\ncmd, dcb->target_id, dcb->target_lun);\r\nsrb->dcb = dcb;\r\nsrb->cmd = cmd;\r\nsrb->sg_count = 0;\r\nsrb->total_xfer_length = 0;\r\nsrb->sg_bus_addr = 0;\r\nsrb->sg_index = 0;\r\nsrb->adapter_status = 0;\r\nsrb->target_status = 0;\r\nsrb->msg_count = 0;\r\nsrb->status = 0;\r\nsrb->flag = 0;\r\nsrb->state = 0;\r\nsrb->retry_count = 0;\r\nsrb->tag_number = TAG_NONE;\r\nsrb->scsi_phase = PH_BUS_FREE;\r\nsrb->end_message = 0;\r\nnseg = scsi_dma_map(cmd);\r\nBUG_ON(nseg < 0);\r\nif (dir == PCI_DMA_NONE || !nseg) {\r\ndprintkdbg(DBG_0,\r\n"build_srb: [0] len=%d buf=%p use_sg=%d !MAP=%08x\n",\r\ncmd->bufflen, scsi_sglist(cmd), scsi_sg_count(cmd),\r\nsrb->segment_x[0].address);\r\n} else {\r\nint i;\r\nu32 reqlen = scsi_bufflen(cmd);\r\nstruct scatterlist *sg;\r\nstruct SGentry *sgp = srb->segment_x;\r\nsrb->sg_count = nseg;\r\ndprintkdbg(DBG_0,\r\n"build_srb: [n] len=%d buf=%p use_sg=%d segs=%d\n",\r\nreqlen, scsi_sglist(cmd), scsi_sg_count(cmd),\r\nsrb->sg_count);\r\nscsi_for_each_sg(cmd, sg, srb->sg_count, i) {\r\nu32 busaddr = (u32)sg_dma_address(sg);\r\nu32 seglen = (u32)sg->length;\r\nsgp[i].address = busaddr;\r\nsgp[i].length = seglen;\r\nsrb->total_xfer_length += seglen;\r\n}\r\nsgp += srb->sg_count - 1;\r\nif (srb->total_xfer_length > reqlen) {\r\nsgp->length -= (srb->total_xfer_length - reqlen);\r\nsrb->total_xfer_length = reqlen;\r\n}\r\nif (dcb->sync_period & WIDE_SYNC &&\r\nsrb->total_xfer_length % 2) {\r\nsrb->total_xfer_length++;\r\nsgp->length++;\r\n}\r\nsrb->sg_bus_addr = pci_map_single(dcb->acb->dev,\r\nsrb->segment_x,\r\nSEGMENTX_LEN,\r\nPCI_DMA_TODEVICE);\r\ndprintkdbg(DBG_SG, "build_srb: [n] map sg %p->%08x(%05x)\n",\r\nsrb->segment_x, srb->sg_bus_addr, SEGMENTX_LEN);\r\n}\r\nsrb->request_length = srb->total_xfer_length;\r\n}\r\nstatic int dc395x_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\nstruct ScsiReqBlk *srb;\r\nstruct AdapterCtlBlk *acb =\r\n(struct AdapterCtlBlk *)cmd->device->host->hostdata;\r\ndprintkdbg(DBG_0, "queue_command: (0x%p) <%02i-%i> cmnd=0x%02x\n",\r\ncmd, cmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\ncmd->result = DID_BAD_TARGET << 16;\r\nif (cmd->device->id >= acb->scsi_host->max_id ||\r\ncmd->device->lun >= acb->scsi_host->max_lun ||\r\ncmd->device->lun >31) {\r\ngoto complete;\r\n}\r\nif (!(acb->dcb_map[cmd->device->id] & (1 << cmd->device->lun))) {\r\ndprintkl(KERN_INFO, "queue_command: Ignore target <%02i-%i>\n",\r\ncmd->device->id, cmd->device->lun);\r\ngoto complete;\r\n}\r\ndcb = find_dcb(acb, cmd->device->id, cmd->device->lun);\r\nif (!dcb) {\r\ndprintkl(KERN_ERR, "queue_command: No such device <%02i-%i>",\r\ncmd->device->id, cmd->device->lun);\r\ngoto complete;\r\n}\r\ncmd->scsi_done = done;\r\ncmd->result = 0;\r\nsrb = srb_get_free(acb);\r\nif (!srb)\r\n{\r\ndprintkdbg(DBG_0, "queue_command: No free srb's\n");\r\nreturn 1;\r\n}\r\nbuild_srb(cmd, dcb, srb);\r\nif (!list_empty(&dcb->srb_waiting_list)) {\r\nsrb_waiting_append(dcb, srb);\r\nwaiting_process_next(acb);\r\n} else {\r\nsend_srb(acb, srb);\r\n}\r\ndprintkdbg(DBG_1, "queue_command: (0x%p) done\n", cmd);\r\nreturn 0;\r\ncomplete:\r\ndone(cmd);\r\nreturn 0;\r\n}\r\nvoid dump_register_info(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb, struct ScsiReqBlk *srb)\r\n{\r\nu16 pstat;\r\nstruct pci_dev *dev = acb->dev;\r\npci_read_config_word(dev, PCI_STATUS, &pstat);\r\nif (!dcb)\r\ndcb = acb->active_dcb;\r\nif (!srb && dcb)\r\nsrb = dcb->active_srb;\r\nif (srb) {\r\nif (!srb->cmd)\r\ndprintkl(KERN_INFO, "dump: srb=%p cmd=%p OOOPS!\n",\r\nsrb, srb->cmd);\r\nelse\r\ndprintkl(KERN_INFO, "dump: srb=%p cmd=%p "\r\n"cmnd=0x%02x <%02i-%i>\n",\r\nsrb, srb->cmd,\r\nsrb->cmd->cmnd[0], srb->cmd->device->id,\r\nsrb->cmd->device->lun);\r\nprintk(" sglist=%p cnt=%i idx=%i len=%zu\n",\r\nsrb->segment_x, srb->sg_count, srb->sg_index,\r\nsrb->total_xfer_length);\r\nprintk(" state=0x%04x status=0x%02x phase=0x%02x (%sconn.)\n",\r\nsrb->state, srb->status, srb->scsi_phase,\r\n(acb->active_dcb) ? "" : "not");\r\n}\r\ndprintkl(KERN_INFO, "dump: SCSI{status=0x%04x fifocnt=0x%02x "\r\n"signals=0x%02x irqstat=0x%02x sync=0x%02x target=0x%02x "\r\n"rselid=0x%02x ctr=0x%08x irqen=0x%02x config=0x%04x "\r\n"config2=0x%02x cmd=0x%02x selto=0x%02x}\n",\r\nDC395x_read16(acb, TRM_S1040_SCSI_STATUS),\r\nDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\r\nDC395x_read8(acb, TRM_S1040_SCSI_SIGNAL),\r\nDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS),\r\nDC395x_read8(acb, TRM_S1040_SCSI_SYNC),\r\nDC395x_read8(acb, TRM_S1040_SCSI_TARGETID),\r\nDC395x_read8(acb, TRM_S1040_SCSI_IDMSG),\r\nDC395x_read32(acb, TRM_S1040_SCSI_COUNTER),\r\nDC395x_read8(acb, TRM_S1040_SCSI_INTEN),\r\nDC395x_read16(acb, TRM_S1040_SCSI_CONFIG0),\r\nDC395x_read8(acb, TRM_S1040_SCSI_CONFIG2),\r\nDC395x_read8(acb, TRM_S1040_SCSI_COMMAND),\r\nDC395x_read8(acb, TRM_S1040_SCSI_TIMEOUT));\r\ndprintkl(KERN_INFO, "dump: DMA{cmd=0x%04x fifocnt=0x%02x fstat=0x%02x "\r\n"irqstat=0x%02x irqen=0x%02x cfg=0x%04x tctr=0x%08x "\r\n"ctctr=0x%08x addr=0x%08x:0x%08x}\n",\r\nDC395x_read16(acb, TRM_S1040_DMA_COMMAND),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\r\nDC395x_read8(acb, TRM_S1040_DMA_STATUS),\r\nDC395x_read8(acb, TRM_S1040_DMA_INTEN),\r\nDC395x_read16(acb, TRM_S1040_DMA_CONFIG),\r\nDC395x_read32(acb, TRM_S1040_DMA_XCNT),\r\nDC395x_read32(acb, TRM_S1040_DMA_CXCNT),\r\nDC395x_read32(acb, TRM_S1040_DMA_XHIGHADDR),\r\nDC395x_read32(acb, TRM_S1040_DMA_XLOWADDR));\r\ndprintkl(KERN_INFO, "dump: gen{gctrl=0x%02x gstat=0x%02x gtmr=0x%02x} "\r\n"pci{status=0x%04x}\n",\r\nDC395x_read8(acb, TRM_S1040_GEN_CONTROL),\r\nDC395x_read8(acb, TRM_S1040_GEN_STATUS),\r\nDC395x_read8(acb, TRM_S1040_GEN_TIMER),\r\npstat);\r\n}\r\nstatic inline void clear_fifo(struct AdapterCtlBlk *acb, char *txt)\r\n{\r\n#if debug_enabled(DBG_FIFO)\r\nu8 lines = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\r\nu8 fifocnt = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\r\nif (!(fifocnt & 0x40))\r\ndprintkdbg(DBG_FIFO,\r\n"clear_fifo: (%i bytes) on phase %02x in %s\n",\r\nfifocnt & 0x3f, lines, txt);\r\n#endif\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_CLRFIFO);\r\n}\r\nstatic void reset_dev_param(struct AdapterCtlBlk *acb)\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\nstruct NvRamType *eeprom = &acb->eeprom;\r\ndprintkdbg(DBG_0, "reset_dev_param: acb=%p\n", acb);\r\nlist_for_each_entry(dcb, &acb->dcb_list, list) {\r\nu8 period_index;\r\ndcb->sync_mode &= ~(SYNC_NEGO_DONE + WIDE_NEGO_DONE);\r\ndcb->sync_period = 0;\r\ndcb->sync_offset = 0;\r\ndcb->dev_mode = eeprom->target[dcb->target_id].cfg0;\r\nperiod_index = eeprom->target[dcb->target_id].period & 0x07;\r\ndcb->min_nego_period = clock_period[period_index];\r\nif (!(dcb->dev_mode & NTC_DO_WIDE_NEGO)\r\n|| !(acb->config & HCC_WIDE_CARD))\r\ndcb->sync_mode &= ~WIDE_NEGO_ENABLE;\r\n}\r\n}\r\nstatic int __dc395x_eh_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct AdapterCtlBlk *acb =\r\n(struct AdapterCtlBlk *)cmd->device->host->hostdata;\r\ndprintkl(KERN_INFO,\r\n"eh_bus_reset: (0%p) target=<%02i-%i> cmd=%p\n",\r\ncmd, cmd->device->id, cmd->device->lun, cmd);\r\nif (timer_pending(&acb->waiting_timer))\r\ndel_timer(&acb->waiting_timer);\r\nDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0x00);\r\nDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x00);\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\r\nreset_scsi_bus(acb);\r\nudelay(500);\r\nacb->last_reset =\r\njiffies + 3 * HZ / 2 +\r\nHZ * acb->eeprom.delay_time;\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\r\nclear_fifo(acb, "eh_bus_reset");\r\nDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\r\nset_basic_config(acb);\r\nreset_dev_param(acb);\r\ndoing_srb_done(acb, DID_RESET, cmd, 0);\r\nacb->active_dcb = NULL;\r\nacb->acb_flag = 0;\r\nwaiting_process_next(acb);\r\nreturn SUCCESS;\r\n}\r\nstatic int dc395x_eh_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nint rc;\r\nspin_lock_irq(cmd->device->host->host_lock);\r\nrc = __dc395x_eh_bus_reset(cmd);\r\nspin_unlock_irq(cmd->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int dc395x_eh_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct AdapterCtlBlk *acb =\r\n(struct AdapterCtlBlk *)cmd->device->host->hostdata;\r\nstruct DeviceCtlBlk *dcb;\r\nstruct ScsiReqBlk *srb;\r\ndprintkl(KERN_INFO, "eh_abort: (0x%p) target=<%02i-%i> cmd=%p\n",\r\ncmd, cmd->device->id, cmd->device->lun, cmd);\r\ndcb = find_dcb(acb, cmd->device->id, cmd->device->lun);\r\nif (!dcb) {\r\ndprintkl(KERN_DEBUG, "eh_abort: No such device\n");\r\nreturn FAILED;\r\n}\r\nsrb = find_cmd(cmd, &dcb->srb_waiting_list);\r\nif (srb) {\r\nsrb_waiting_remove(dcb, srb);\r\npci_unmap_srb_sense(acb, srb);\r\npci_unmap_srb(acb, srb);\r\nfree_tag(dcb, srb);\r\nsrb_free_insert(acb, srb);\r\ndprintkl(KERN_DEBUG, "eh_abort: Command was waiting\n");\r\ncmd->result = DID_ABORT << 16;\r\nreturn SUCCESS;\r\n}\r\nsrb = find_cmd(cmd, &dcb->srb_going_list);\r\nif (srb) {\r\ndprintkl(KERN_DEBUG, "eh_abort: Command in progress\n");\r\n} else {\r\ndprintkl(KERN_DEBUG, "eh_abort: Command not found\n");\r\n}\r\nreturn FAILED;\r\n}\r\nstatic void build_sdtr(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nu8 *ptr = srb->msgout_buf + srb->msg_count;\r\nif (srb->msg_count > 1) {\r\ndprintkl(KERN_INFO,\r\n"build_sdtr: msgout_buf BUSY (%i: %02x %02x)\n",\r\nsrb->msg_count, srb->msgout_buf[0],\r\nsrb->msgout_buf[1]);\r\nreturn;\r\n}\r\nif (!(dcb->dev_mode & NTC_DO_SYNC_NEGO)) {\r\ndcb->sync_offset = 0;\r\ndcb->min_nego_period = 200 >> 2;\r\n} else if (dcb->sync_offset == 0)\r\ndcb->sync_offset = SYNC_NEGO_OFFSET;\r\n*ptr++ = MSG_EXTENDED;\r\n*ptr++ = 3;\r\n*ptr++ = EXTENDED_SDTR;\r\n*ptr++ = dcb->min_nego_period;\r\n*ptr++ = dcb->sync_offset;\r\nsrb->msg_count += 5;\r\nsrb->state |= SRB_DO_SYNC_NEGO;\r\n}\r\nstatic void build_wdtr(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nu8 wide = ((dcb->dev_mode & NTC_DO_WIDE_NEGO) &\r\n(acb->config & HCC_WIDE_CARD)) ? 1 : 0;\r\nu8 *ptr = srb->msgout_buf + srb->msg_count;\r\nif (srb->msg_count > 1) {\r\ndprintkl(KERN_INFO,\r\n"build_wdtr: msgout_buf BUSY (%i: %02x %02x)\n",\r\nsrb->msg_count, srb->msgout_buf[0],\r\nsrb->msgout_buf[1]);\r\nreturn;\r\n}\r\n*ptr++ = MSG_EXTENDED;\r\n*ptr++ = 2;\r\n*ptr++ = EXTENDED_WDTR;\r\n*ptr++ = wide;\r\nsrb->msg_count += 4;\r\nsrb->state |= SRB_DO_WIDE_NEGO;\r\n}\r\nstatic u8 start_scsi(struct AdapterCtlBlk* acb, struct DeviceCtlBlk* dcb,\r\nstruct ScsiReqBlk* srb)\r\n{\r\nu16 s_stat2, return_code;\r\nu8 s_stat, scsicommand, i, identify_message;\r\nu8 *ptr;\r\ndprintkdbg(DBG_0, "start_scsi: (0x%p) <%02i-%i> srb=%p\n",\r\ndcb->target_id, dcb->target_lun, srb);\r\nsrb->tag_number = TAG_NONE;\r\ns_stat = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\r\ns_stat2 = 0;\r\ns_stat2 = DC395x_read16(acb, TRM_S1040_SCSI_STATUS);\r\n#if 1\r\nif (s_stat & 0x20 ) {\r\ndprintkdbg(DBG_KG, "start_scsi: (0x%p) BUSY %02x %04x\n",\r\ns_stat, s_stat2);\r\nreturn 1;\r\n}\r\n#endif\r\nif (acb->active_dcb) {\r\ndprintkl(KERN_DEBUG, "start_scsi: (0x%p) Attempt to start a"\r\n"command while another command (0x%p) is active.",\r\nsrb->cmd,\r\nacb->active_dcb->active_srb ?\r\nacb->active_dcb->active_srb->cmd : 0);\r\nreturn 1;\r\n}\r\nif (DC395x_read16(acb, TRM_S1040_SCSI_STATUS) & SCSIINTERRUPT) {\r\ndprintkdbg(DBG_KG, "start_scsi: (0x%p) Failed (busy)\n", srb->cmd);\r\nreturn 1;\r\n}\r\nif (time_before(jiffies, acb->last_reset - HZ / 2)) {\r\ndprintkdbg(DBG_KG, "start_scsi: Refuse cmds (reset wait)\n");\r\nreturn 1;\r\n}\r\nclear_fifo(acb, "start_scsi");\r\nDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\r\nDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\r\nsrb->scsi_phase = PH_BUS_FREE;\r\nidentify_message = dcb->identify_msg;\r\nif (srb->flag & AUTO_REQSENSE)\r\nidentify_message &= 0xBF;\r\nif (((srb->cmd->cmnd[0] == INQUIRY)\r\n|| (srb->cmd->cmnd[0] == REQUEST_SENSE)\r\n|| (srb->flag & AUTO_REQSENSE))\r\n&& (((dcb->sync_mode & WIDE_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & WIDE_NEGO_DONE))\r\n|| ((dcb->sync_mode & SYNC_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & SYNC_NEGO_DONE)))\r\n&& (dcb->target_lun == 0)) {\r\nsrb->msgout_buf[0] = identify_message;\r\nsrb->msg_count = 1;\r\nscsicommand = SCMD_SEL_ATNSTOP;\r\nsrb->state = SRB_MSGOUT;\r\n#ifndef SYNC_FIRST\r\nif (dcb->sync_mode & WIDE_NEGO_ENABLE\r\n&& dcb->inquiry7 & SCSI_INQ_WBUS16) {\r\nbuild_wdtr(acb, dcb, srb);\r\ngoto no_cmd;\r\n}\r\n#endif\r\nif (dcb->sync_mode & SYNC_NEGO_ENABLE\r\n&& dcb->inquiry7 & SCSI_INQ_SYNC) {\r\nbuild_sdtr(acb, dcb, srb);\r\ngoto no_cmd;\r\n}\r\nif (dcb->sync_mode & WIDE_NEGO_ENABLE\r\n&& dcb->inquiry7 & SCSI_INQ_WBUS16) {\r\nbuild_wdtr(acb, dcb, srb);\r\ngoto no_cmd;\r\n}\r\nsrb->msg_count = 0;\r\n}\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, identify_message);\r\nscsicommand = SCMD_SEL_ATN;\r\nsrb->state = SRB_START_;\r\n#ifndef DC395x_NO_TAGQ\r\nif ((dcb->sync_mode & EN_TAG_QUEUEING)\r\n&& (identify_message & 0xC0)) {\r\nu32 tag_mask = 1;\r\nu8 tag_number = 0;\r\nwhile (tag_mask & dcb->tag_mask\r\n&& tag_number < dcb->max_command) {\r\ntag_mask = tag_mask << 1;\r\ntag_number++;\r\n}\r\nif (tag_number >= dcb->max_command) {\r\ndprintkl(KERN_WARNING, "start_scsi: (0x%p) "\r\n"Out of tags target=<%02i-%i>)\n",\r\nsrb->cmd, srb->cmd->device->id,\r\nsrb->cmd->device->lun);\r\nsrb->state = SRB_READY;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\r\nDO_HWRESELECT);\r\nreturn 1;\r\n}\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, MSG_SIMPLE_QTAG);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, tag_number);\r\ndcb->tag_mask |= tag_mask;\r\nsrb->tag_number = tag_number;\r\nscsicommand = SCMD_SEL_ATN3;\r\nsrb->state = SRB_START_;\r\n}\r\n#endif\r\ndprintkdbg(DBG_KG, "start_scsi: (0x%p) <%02i-%i> cmnd=0x%02x tag=%i\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun,\r\nsrb->cmd->cmnd[0], srb->tag_number);\r\nif (srb->flag & AUTO_REQSENSE) {\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, REQUEST_SENSE);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, (dcb->target_lun << 5));\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, SCSI_SENSE_BUFFERSIZE);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\n} else {\r\nptr = (u8 *)srb->cmd->cmnd;\r\nfor (i = 0; i < srb->cmd->cmd_len; i++)\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr++);\r\n}\r\nno_cmd:\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\r\nDO_HWRESELECT | DO_DATALATCH);\r\nif (DC395x_read16(acb, TRM_S1040_SCSI_STATUS) & SCSIINTERRUPT) {\r\ndprintkdbg(DBG_0, "start_scsi: (0x%p) <%02i-%i> Failed - busy\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun);\r\nsrb->state = SRB_READY;\r\nfree_tag(dcb, srb);\r\nsrb->msg_count = 0;\r\nreturn_code = 1;\r\n} else {\r\nsrb->scsi_phase = PH_BUS_FREE;\r\ndcb->active_srb = srb;\r\nacb->active_dcb = dcb;\r\nreturn_code = 0;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\r\nDO_DATALATCH | DO_HWRESELECT);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, scsicommand);\r\n}\r\nreturn return_code;\r\n}\r\nstatic inline void enable_msgout_abort(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nsrb->msgout_buf[0] = ABORT;\r\nsrb->msg_count = 1;\r\nDC395x_ENABLE_MSGOUT;\r\nsrb->state &= ~SRB_MSGIN;\r\nsrb->state |= SRB_MSGOUT;\r\n}\r\nstatic void dc395x_handle_interrupt(struct AdapterCtlBlk *acb,\r\nu16 scsi_status)\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\nstruct ScsiReqBlk *srb;\r\nu16 phase;\r\nu8 scsi_intstatus;\r\nunsigned long flags;\r\nvoid (*dc395x_statev)(struct AdapterCtlBlk *, struct ScsiReqBlk *,\r\nu16 *);\r\nDC395x_LOCK_IO(acb->scsi_host, flags);\r\nscsi_intstatus = DC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\r\nif ((scsi_status & 0x2007) == 0x2002)\r\ndprintkl(KERN_DEBUG,\r\n"COP after COP completed? %04x\n", scsi_status);\r\nif (debug_enabled(DBG_KG)) {\r\nif (scsi_intstatus & INT_SELTIMEOUT)\r\ndprintkdbg(DBG_KG, "handle_interrupt: Selection timeout\n");\r\n}\r\nif (timer_pending(&acb->selto_timer))\r\ndel_timer(&acb->selto_timer);\r\nif (scsi_intstatus & (INT_SELTIMEOUT | INT_DISCONNECT)) {\r\ndisconnect(acb);\r\ngoto out_unlock;\r\n}\r\nif (scsi_intstatus & INT_RESELECTED) {\r\nreselect(acb);\r\ngoto out_unlock;\r\n}\r\nif (scsi_intstatus & INT_SELECT) {\r\ndprintkl(KERN_INFO, "Host does not support target mode!\n");\r\ngoto out_unlock;\r\n}\r\nif (scsi_intstatus & INT_SCSIRESET) {\r\nscsi_reset_detect(acb);\r\ngoto out_unlock;\r\n}\r\nif (scsi_intstatus & (INT_BUSSERVICE | INT_CMDDONE)) {\r\ndcb = acb->active_dcb;\r\nif (!dcb) {\r\ndprintkl(KERN_DEBUG,\r\n"Oops: BusService (%04x %02x) w/o ActiveDCB!\n",\r\nscsi_status, scsi_intstatus);\r\ngoto out_unlock;\r\n}\r\nsrb = dcb->active_srb;\r\nif (dcb->flag & ABORT_DEV_) {\r\ndprintkdbg(DBG_0, "MsgOut Abort Device.....\n");\r\nenable_msgout_abort(acb, srb);\r\n}\r\nphase = (u16)srb->scsi_phase;\r\ndc395x_statev = dc395x_scsi_phase0[phase];\r\ndc395x_statev(acb, srb, &scsi_status);\r\nsrb->scsi_phase = scsi_status & PHASEMASK;\r\nphase = (u16)scsi_status & PHASEMASK;\r\ndc395x_statev = dc395x_scsi_phase1[phase];\r\ndc395x_statev(acb, srb, &scsi_status);\r\n}\r\nout_unlock:\r\nDC395x_UNLOCK_IO(acb->scsi_host, flags);\r\n}\r\nstatic irqreturn_t dc395x_interrupt(int irq, void *dev_id)\r\n{\r\nstruct AdapterCtlBlk *acb = dev_id;\r\nu16 scsi_status;\r\nu8 dma_status;\r\nirqreturn_t handled = IRQ_NONE;\r\nscsi_status = DC395x_read16(acb, TRM_S1040_SCSI_STATUS);\r\ndma_status = DC395x_read8(acb, TRM_S1040_DMA_STATUS);\r\nif (scsi_status & SCSIINTERRUPT) {\r\ndc395x_handle_interrupt(acb, scsi_status);\r\nhandled = IRQ_HANDLED;\r\n}\r\nelse if (dma_status & 0x20) {\r\ndprintkl(KERN_INFO, "Interrupt from DMA engine: 0x%02x!\n", dma_status);\r\n#if 0\r\ndprintkl(KERN_INFO, "This means DMA error! Try to handle ...\n");\r\nif (acb->active_dcb) {\r\nacb->active_dcb-> flag |= ABORT_DEV_;\r\nif (acb->active_dcb->active_srb)\r\nenable_msgout_abort(acb, acb->active_dcb->active_srb);\r\n}\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, ABORTXFER | CLRXFIFO);\r\n#else\r\ndprintkl(KERN_INFO, "Ignoring DMA error (probably a bad thing) ...\n");\r\nacb = NULL;\r\n#endif\r\nhandled = IRQ_HANDLED;\r\n}\r\nreturn handled;\r\n}\r\nstatic void msgout_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "msgout_phase0: (0x%p)\n", srb->cmd);\r\nif (srb->state & (SRB_UNEXPECT_RESEL + SRB_ABORT_SENT))\r\n*pscsi_status = PH_BUS_FREE;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nsrb->state &= ~SRB_MSGOUT;\r\n}\r\nstatic void msgout_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\nu16 i;\r\nu8 *ptr;\r\ndprintkdbg(DBG_0, "msgout_phase1: (0x%p)\n", srb->cmd);\r\nclear_fifo(acb, "msgout_phase1");\r\nif (!(srb->state & SRB_MSGOUT)) {\r\nsrb->state |= SRB_MSGOUT;\r\ndprintkl(KERN_DEBUG,\r\n"msgout_phase1: (0x%p) Phase unexpected\n",\r\nsrb->cmd);\r\n}\r\nif (!srb->msg_count) {\r\ndprintkdbg(DBG_0, "msgout_phase1: (0x%p) NOP msg\n",\r\nsrb->cmd);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, MSG_NOP);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\r\nreturn;\r\n}\r\nptr = (u8 *)srb->msgout_buf;\r\nfor (i = 0; i < srb->msg_count; i++)\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr++);\r\nsrb->msg_count = 0;\r\nif (srb->msgout_buf[0] == MSG_ABORT)\r\nsrb->state = SRB_ABORT_SENT;\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\r\n}\r\nstatic void command_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "command_phase0: (0x%p)\n", srb->cmd);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\n}\r\nstatic void command_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\nu8 *ptr;\r\nu16 i;\r\ndprintkdbg(DBG_0, "command_phase1: (0x%p)\n", srb->cmd);\r\nclear_fifo(acb, "command_phase1");\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_CLRATN);\r\nif (!(srb->flag & AUTO_REQSENSE)) {\r\nptr = (u8 *)srb->cmd->cmnd;\r\nfor (i = 0; i < srb->cmd->cmd_len; i++) {\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *ptr);\r\nptr++;\r\n}\r\n} else {\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, REQUEST_SENSE);\r\ndcb = acb->active_dcb;\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, (dcb->target_lun << 5));\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, SCSI_SENSE_BUFFERSIZE);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\n}\r\nsrb->state |= SRB_COMMAND;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_OUT);\r\n}\r\nstatic void sg_verify_length(struct ScsiReqBlk *srb)\r\n{\r\nif (debug_enabled(DBG_SG)) {\r\nunsigned len = 0;\r\nunsigned idx = srb->sg_index;\r\nstruct SGentry *psge = srb->segment_x + idx;\r\nfor (; idx < srb->sg_count; psge++, idx++)\r\nlen += psge->length;\r\nif (len != srb->total_xfer_length)\r\ndprintkdbg(DBG_SG,\r\n"Inconsistent SRB S/G lengths (Tot=%i, Count=%i) !!\n",\r\nsrb->total_xfer_length, len);\r\n}\r\n}\r\nstatic void sg_update_list(struct ScsiReqBlk *srb, u32 left)\r\n{\r\nu8 idx;\r\nu32 xferred = srb->total_xfer_length - left;\r\nstruct SGentry *psge = srb->segment_x + srb->sg_index;\r\ndprintkdbg(DBG_0,\r\n"sg_update_list: Transferred %i of %i bytes, %i remain\n",\r\nxferred, srb->total_xfer_length, left);\r\nif (xferred == 0) {\r\nreturn;\r\n}\r\nsg_verify_length(srb);\r\nsrb->total_xfer_length = left;\r\nfor (idx = srb->sg_index; idx < srb->sg_count; idx++) {\r\nif (xferred >= psge->length) {\r\nxferred -= psge->length;\r\n} else {\r\npsge->length -= xferred;\r\npsge->address += xferred;\r\nsrb->sg_index = idx;\r\npci_dma_sync_single_for_device(srb->dcb->\r\nacb->dev,\r\nsrb->sg_bus_addr,\r\nSEGMENTX_LEN,\r\nPCI_DMA_TODEVICE);\r\nbreak;\r\n}\r\npsge++;\r\n}\r\nsg_verify_length(srb);\r\n}\r\nstatic void sg_subtract_one(struct ScsiReqBlk *srb)\r\n{\r\nsg_update_list(srb, srb->total_xfer_length - 1);\r\n}\r\nstatic void cleanup_after_transfer(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nif (DC395x_read16(acb, TRM_S1040_DMA_COMMAND) & 0x0001) {\r\nif (!(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) & 0x40))\r\nclear_fifo(acb, "cleanup/in");\r\nif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80))\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\r\n} else {\r\nif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80))\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\r\nif (!(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) & 0x40))\r\nclear_fifo(acb, "cleanup/out");\r\n}\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\n}\r\nstatic void data_out_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\nu16 scsi_status = *pscsi_status;\r\nu32 d_left_counter = 0;\r\ndprintkdbg(DBG_0, "data_out_phase0: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\ndprintkdbg(DBG_PIO, "data_out_phase0: "\r\n"DMA{fifocnt=0x%02x fifostat=0x%02x} "\r\n"SCSI{fifocnt=0x%02x cnt=0x%06x status=0x%04x} total=0x%06x\n",\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\r\nDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\r\nDC395x_read32(acb, TRM_S1040_SCSI_COUNTER), scsi_status,\r\nsrb->total_xfer_length);\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, STOPDMAXFER | CLRXFIFO);\r\nif (!(srb->state & SRB_XFERPAD)) {\r\nif (scsi_status & PARITYERROR)\r\nsrb->status |= PARITY_ERROR;\r\nif (!(scsi_status & SCSIXFERDONE)) {\r\nd_left_counter =\r\n(u32)(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) &\r\n0x1F);\r\nif (dcb->sync_period & WIDE_SYNC)\r\nd_left_counter <<= 1;\r\ndprintkdbg(DBG_KG, "data_out_phase0: FIFO contains %i %s\n"\r\n"SCSI{fifocnt=0x%02x cnt=0x%08x} "\r\n"DMA{fifocnt=0x%04x cnt=0x%02x ctr=0x%08x}\n",\r\nDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\r\n(dcb->sync_period & WIDE_SYNC) ? "words" : "bytes",\r\nDC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT),\r\nDC395x_read32(acb, TRM_S1040_SCSI_COUNTER),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\r\nDC395x_read32(acb, TRM_S1040_DMA_CXCNT));\r\n}\r\nif (srb->total_xfer_length > DC395x_LASTPIO)\r\nd_left_counter +=\r\nDC395x_read32(acb, TRM_S1040_SCSI_COUNTER);\r\nif (d_left_counter == 1 && dcb->sync_period & WIDE_SYNC\r\n&& scsi_bufflen(srb->cmd) % 2) {\r\nd_left_counter = 0;\r\ndprintkl(KERN_INFO,\r\n"data_out_phase0: Discard 1 byte (0x%02x)\n",\r\nscsi_status);\r\n}\r\nif (d_left_counter == 0) {\r\nsrb->total_xfer_length = 0;\r\n} else {\r\nlong oldxferred =\r\nsrb->total_xfer_length - d_left_counter;\r\nconst int diff =\r\n(dcb->sync_period & WIDE_SYNC) ? 2 : 1;\r\nsg_update_list(srb, d_left_counter);\r\nif ((srb->segment_x[srb->sg_index].length ==\r\ndiff && scsi_sg_count(srb->cmd))\r\n|| ((oldxferred & ~PAGE_MASK) ==\r\n(PAGE_SIZE - diff))\r\n) {\r\ndprintkl(KERN_INFO, "data_out_phase0: "\r\n"Work around chip bug (%i)?\n", diff);\r\nd_left_counter =\r\nsrb->total_xfer_length - diff;\r\nsg_update_list(srb, d_left_counter);\r\n}\r\n}\r\n}\r\nif ((*pscsi_status & PHASEMASK) != PH_DATA_OUT) {\r\ncleanup_after_transfer(acb, srb);\r\n}\r\n}\r\nstatic void data_out_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "data_out_phase1: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\nclear_fifo(acb, "data_out_phase1");\r\ndata_io_transfer(acb, srb, XFERDATAOUT);\r\n}\r\nstatic void data_in_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\nu16 scsi_status = *pscsi_status;\r\ndprintkdbg(DBG_0, "data_in_phase0: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\nif (!(srb->state & SRB_XFERPAD)) {\r\nu32 d_left_counter;\r\nunsigned int sc, fc;\r\nif (scsi_status & PARITYERROR) {\r\ndprintkl(KERN_INFO, "data_in_phase0: (0x%p) "\r\n"Parity Error\n", srb->cmd);\r\nsrb->status |= PARITY_ERROR;\r\n}\r\nif (!(DC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT) & 0x80)) {\r\n#if 0\r\nint ctr = 6000000;\r\ndprintkl(KERN_DEBUG,\r\n"DIP0: Wait for DMA FIFO to flush ...\n");\r\nwhile (!\r\n(DC395x_read16(acb, TRM_S1040_DMA_FIFOSTAT) &\r\n0x80) && --ctr);\r\nif (ctr < 6000000 - 1)\r\ndprintkl(KERN_DEBUG\r\n"DIP0: Had to wait for DMA ...\n");\r\nif (!ctr)\r\ndprintkl(KERN_ERR,\r\n"Deadlock in DIP0 waiting for DMA FIFO empty!!\n");\r\n#endif\r\ndprintkdbg(DBG_KG, "data_in_phase0: "\r\n"DMA{fifocnt=0x%02x fifostat=0x%02x}\n",\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOCNT),\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT));\r\n}\r\nsc = DC395x_read32(acb, TRM_S1040_SCSI_COUNTER);\r\nfc = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\r\nd_left_counter = sc + ((fc & 0x1f)\r\n<< ((srb->dcb->sync_period & WIDE_SYNC) ? 1 :\r\n0));\r\ndprintkdbg(DBG_KG, "data_in_phase0: "\r\n"SCSI{fifocnt=0x%02x%s ctr=0x%08x} "\r\n"DMA{fifocnt=0x%02x fifostat=0x%02x ctr=0x%08x} "\r\n"Remain{totxfer=%i scsi_fifo+ctr=%i}\n",\r\nfc,\r\n(srb->dcb->sync_period & WIDE_SYNC) ? "words" : "bytes",\r\nsc,\r\nfc,\r\nDC395x_read8(acb, TRM_S1040_DMA_FIFOSTAT),\r\nDC395x_read32(acb, TRM_S1040_DMA_CXCNT),\r\nsrb->total_xfer_length, d_left_counter);\r\n#if DC395x_LASTPIO\r\nif (d_left_counter\r\n&& srb->total_xfer_length <= DC395x_LASTPIO) {\r\nsize_t left_io = srb->total_xfer_length;\r\ndprintkdbg(DBG_PIO, "data_in_phase0: PIO (%i %s) "\r\n"for remaining %i bytes:",\r\nfc & 0x1f,\r\n(srb->dcb->sync_period & WIDE_SYNC) ?\r\n"words" : "bytes",\r\nsrb->total_xfer_length);\r\nif (srb->dcb->sync_period & WIDE_SYNC)\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\r\nCFG2_WIDEFIFO);\r\nwhile (left_io) {\r\nunsigned char *virt, *base = NULL;\r\nunsigned long flags = 0;\r\nsize_t len = left_io;\r\nsize_t offset = srb->request_length - left_io;\r\nlocal_irq_save(flags);\r\nbase = scsi_kmap_atomic_sg(scsi_sglist(srb->cmd),\r\nsrb->sg_count, &offset, &len);\r\nvirt = base + offset;\r\nleft_io -= len;\r\nwhile (len) {\r\nu8 byte;\r\nbyte = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\n*virt++ = byte;\r\nif (debug_enabled(DBG_PIO))\r\nprintk(" %02x", byte);\r\nd_left_counter--;\r\nsg_subtract_one(srb);\r\nlen--;\r\nfc = DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT);\r\nif (fc == 0x40) {\r\nleft_io = 0;\r\nbreak;\r\n}\r\n}\r\nWARN_ON((fc != 0x40) == !d_left_counter);\r\nif (fc == 0x40 && (srb->dcb->sync_period & WIDE_SYNC)) {\r\nif (srb->total_xfer_length > 0) {\r\nu8 byte = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\n*virt++ = byte;\r\nsrb->total_xfer_length--;\r\nif (debug_enabled(DBG_PIO))\r\nprintk(" %02x", byte);\r\n}\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\r\n}\r\nscsi_kunmap_atomic_sg(base);\r\nlocal_irq_restore(flags);\r\n}\r\nif (debug_enabled(DBG_PIO))\r\nprintk("\n");\r\n}\r\n#endif\r\n#if 0\r\nif (!(scsi_status & SCSIXFERDONE)) {\r\nd_left_counter =\r\n(u32)(DC395x_read8(acb, TRM_S1040_SCSI_FIFOCNT) &\r\n0x1F);\r\nif (srb->dcb->sync_period & WIDE_SYNC)\r\nd_left_counter <<= 1;\r\n}\r\n#endif\r\nif (d_left_counter == 0\r\n|| (scsi_status & SCSIXFERCNT_2_ZERO)) {\r\n#if 0\r\nint ctr = 6000000;\r\nu8 TempDMAstatus;\r\ndo {\r\nTempDMAstatus =\r\nDC395x_read8(acb, TRM_S1040_DMA_STATUS);\r\n} while (!(TempDMAstatus & DMAXFERCOMP) && --ctr);\r\nif (!ctr)\r\ndprintkl(KERN_ERR,\r\n"Deadlock in DataInPhase0 waiting for DMA!!\n");\r\nsrb->total_xfer_length = 0;\r\n#endif\r\nsrb->total_xfer_length = d_left_counter;\r\n} else {\r\nsg_update_list(srb, d_left_counter);\r\n}\r\n}\r\nif ((*pscsi_status & PHASEMASK) != PH_DATA_IN) {\r\ncleanup_after_transfer(acb, srb);\r\n}\r\n}\r\nstatic void data_in_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "data_in_phase1: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\ndata_io_transfer(acb, srb, XFERDATAIN);\r\n}\r\nstatic void data_io_transfer(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb, u16 io_dir)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\nu8 bval;\r\ndprintkdbg(DBG_0,\r\n"data_io_transfer: (0x%p) <%02i-%i> %c len=%i, sg=(%i/%i)\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun,\r\n((io_dir & DMACMD_DIR) ? 'r' : 'w'),\r\nsrb->total_xfer_length, srb->sg_index, srb->sg_count);\r\nif (srb == acb->tmp_srb)\r\ndprintkl(KERN_ERR, "data_io_transfer: Using tmp_srb!\n");\r\nif (srb->sg_index >= srb->sg_count) {\r\nreturn;\r\n}\r\nif (srb->total_xfer_length > DC395x_LASTPIO) {\r\nu8 dma_status = DC395x_read8(acb, TRM_S1040_DMA_STATUS);\r\nif (dma_status & XFERPENDING) {\r\ndprintkl(KERN_DEBUG, "data_io_transfer: Xfer pending! "\r\n"Expect trouble!\n");\r\ndump_register_info(acb, dcb, srb);\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, CLRXFIFO);\r\n}\r\nsrb->state |= SRB_DATA_XFER;\r\nDC395x_write32(acb, TRM_S1040_DMA_XHIGHADDR, 0);\r\nif (scsi_sg_count(srb->cmd)) {\r\nio_dir |= DMACMD_SG;\r\nDC395x_write32(acb, TRM_S1040_DMA_XLOWADDR,\r\nsrb->sg_bus_addr +\r\nsizeof(struct SGentry) *\r\nsrb->sg_index);\r\nDC395x_write32(acb, TRM_S1040_DMA_XCNT,\r\n((u32)(srb->sg_count -\r\nsrb->sg_index) << 3));\r\n} else {\r\nio_dir &= ~DMACMD_SG;\r\nDC395x_write32(acb, TRM_S1040_DMA_XLOWADDR,\r\nsrb->segment_x[0].address);\r\nDC395x_write32(acb, TRM_S1040_DMA_XCNT,\r\nsrb->segment_x[0].length);\r\n}\r\nDC395x_write32(acb, TRM_S1040_SCSI_COUNTER,\r\nsrb->total_xfer_length);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nif (io_dir & DMACMD_DIR) {\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\r\nSCMD_DMA_IN);\r\nDC395x_write16(acb, TRM_S1040_DMA_COMMAND, io_dir);\r\n} else {\r\nDC395x_write16(acb, TRM_S1040_DMA_COMMAND, io_dir);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\r\nSCMD_DMA_OUT);\r\n}\r\n}\r\n#if DC395x_LASTPIO\r\nelse if (srb->total_xfer_length > 0) {\r\nsrb->state |= SRB_DATA_XFER;\r\nDC395x_write32(acb, TRM_S1040_SCSI_COUNTER,\r\nsrb->total_xfer_length);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nif (io_dir & DMACMD_DIR) {\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\r\nSCMD_FIFO_IN);\r\n} else {\r\nint ln = srb->total_xfer_length;\r\nsize_t left_io = srb->total_xfer_length;\r\nif (srb->dcb->sync_period & WIDE_SYNC)\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\r\nCFG2_WIDEFIFO);\r\nwhile (left_io) {\r\nunsigned char *virt, *base = NULL;\r\nunsigned long flags = 0;\r\nsize_t len = left_io;\r\nsize_t offset = srb->request_length - left_io;\r\nlocal_irq_save(flags);\r\nbase = scsi_kmap_atomic_sg(scsi_sglist(srb->cmd),\r\nsrb->sg_count, &offset, &len);\r\nvirt = base + offset;\r\nleft_io -= len;\r\nwhile (len--) {\r\nif (debug_enabled(DBG_PIO))\r\nprintk(" %02x", *virt);\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, *virt++);\r\nsg_subtract_one(srb);\r\n}\r\nscsi_kunmap_atomic_sg(base);\r\nlocal_irq_restore(flags);\r\n}\r\nif (srb->dcb->sync_period & WIDE_SYNC) {\r\nif (ln % 2) {\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 0);\r\nif (debug_enabled(DBG_PIO))\r\nprintk(" |00");\r\n}\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\r\n}\r\nif (debug_enabled(DBG_PIO))\r\nprintk("\n");\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND,\r\nSCMD_FIFO_OUT);\r\n}\r\n}\r\n#endif\r\nelse {\r\nu8 data = 0, data2 = 0;\r\nif (srb->sg_count) {\r\nsrb->adapter_status = H_OVER_UNDER_RUN;\r\nsrb->status |= OVER_RUN;\r\n}\r\nif (dcb->sync_period & WIDE_SYNC) {\r\nDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 2);\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2,\r\nCFG2_WIDEFIFO);\r\nif (io_dir & DMACMD_DIR) {\r\ndata = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\ndata2 = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\n} else {\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'K');\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'G');\r\n}\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG2, 0);\r\n} else {\r\nDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 1);\r\nif (io_dir & DMACMD_DIR)\r\ndata = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\nelse\r\nDC395x_write8(acb, TRM_S1040_SCSI_FIFO, 'K');\r\n}\r\nsrb->state |= SRB_XFERPAD;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nbval = (io_dir & DMACMD_DIR) ? SCMD_FIFO_IN : SCMD_FIFO_OUT;\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, bval);\r\n}\r\n}\r\nstatic void status_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "status_phase0: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\nsrb->target_status = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\nsrb->end_message = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\nsrb->state = SRB_COMPLETED;\r\n*pscsi_status = PH_BUS_FREE;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\r\n}\r\nstatic void status_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "status_phase1: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->cmd->device->id, srb->cmd->device->lun);\r\nsrb->state = SRB_STATUS;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_COMP);\r\n}\r\nstatic inline u8 msgin_completed(u8 * msgbuf, u32 len)\r\n{\r\nif (*msgbuf == EXTENDED_MESSAGE) {\r\nif (len < 2)\r\nreturn 0;\r\nif (len < msgbuf[1] + 2)\r\nreturn 0;\r\n} else if (*msgbuf >= 0x20 && *msgbuf <= 0x2f)\r\nif (len < 2)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline void msgin_reject(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nsrb->msgout_buf[0] = MESSAGE_REJECT;\r\nsrb->msg_count = 1;\r\nDC395x_ENABLE_MSGOUT;\r\nsrb->state &= ~SRB_MSGIN;\r\nsrb->state |= SRB_MSGOUT;\r\ndprintkl(KERN_INFO, "msgin_reject: 0x%02x <%02i-%i>\n",\r\nsrb->msgin_buf[0],\r\nsrb->dcb->target_id, srb->dcb->target_lun);\r\n}\r\nstatic struct ScsiReqBlk *msgin_qtag(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb, u8 tag)\r\n{\r\nstruct ScsiReqBlk *srb = NULL;\r\nstruct ScsiReqBlk *i;\r\ndprintkdbg(DBG_0, "msgin_qtag: (0x%p) tag=%i srb=%p\n",\r\nsrb->cmd, tag, srb);\r\nif (!(dcb->tag_mask & (1 << tag)))\r\ndprintkl(KERN_DEBUG,\r\n"msgin_qtag: tag_mask=0x%08x does not reserve tag %i!\n",\r\ndcb->tag_mask, tag);\r\nif (list_empty(&dcb->srb_going_list))\r\ngoto mingx0;\r\nlist_for_each_entry(i, &dcb->srb_going_list, list) {\r\nif (i->tag_number == tag) {\r\nsrb = i;\r\nbreak;\r\n}\r\n}\r\nif (!srb)\r\ngoto mingx0;\r\ndprintkdbg(DBG_0, "msgin_qtag: (0x%p) <%02i-%i>\n",\r\nsrb->cmd, srb->dcb->target_id, srb->dcb->target_lun);\r\nif (dcb->flag & ABORT_DEV_) {\r\nenable_msgout_abort(acb, srb);\r\n}\r\nif (!(srb->state & SRB_DISCONNECT))\r\ngoto mingx0;\r\nmemcpy(srb->msgin_buf, dcb->active_srb->msgin_buf, acb->msg_len);\r\nsrb->state |= dcb->active_srb->state;\r\nsrb->state |= SRB_DATA_XFER;\r\ndcb->active_srb = srb;\r\nreturn srb;\r\nmingx0:\r\nsrb = acb->tmp_srb;\r\nsrb->state = SRB_UNEXPECT_RESEL;\r\ndcb->active_srb = srb;\r\nsrb->msgout_buf[0] = MSG_ABORT_TAG;\r\nsrb->msg_count = 1;\r\nDC395x_ENABLE_MSGOUT;\r\ndprintkl(KERN_DEBUG, "msgin_qtag: Unknown tag %i - abort\n", tag);\r\nreturn srb;\r\n}\r\nstatic inline void reprogram_regs(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb)\r\n{\r\nDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\r\nDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\r\nset_xfer_rate(acb, dcb);\r\n}\r\nstatic void msgin_set_async(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\ndprintkl(KERN_DEBUG, "msgin_set_async: No sync transfers <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\ndcb->sync_mode &= ~(SYNC_NEGO_ENABLE);\r\ndcb->sync_mode |= SYNC_NEGO_DONE;\r\ndcb->sync_offset = 0;\r\ndcb->min_nego_period = 200 >> 2;\r\nsrb->state &= ~SRB_DO_SYNC_NEGO;\r\nreprogram_regs(acb, dcb);\r\nif ((dcb->sync_mode & WIDE_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & WIDE_NEGO_DONE)) {\r\nbuild_wdtr(acb, dcb, srb);\r\nDC395x_ENABLE_MSGOUT;\r\ndprintkdbg(DBG_0, "msgin_set_async(rej): Try WDTR anyway\n");\r\n}\r\n}\r\nstatic void msgin_set_sync(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\nu8 bval;\r\nint fact;\r\ndprintkdbg(DBG_1, "msgin_set_sync: <%02i> Sync: %ins "\r\n"(%02i.%01i MHz) Offset %i\n",\r\ndcb->target_id, srb->msgin_buf[3] << 2,\r\n(250 / srb->msgin_buf[3]),\r\n((250 % srb->msgin_buf[3]) * 10) / srb->msgin_buf[3],\r\nsrb->msgin_buf[4]);\r\nif (srb->msgin_buf[4] > 15)\r\nsrb->msgin_buf[4] = 15;\r\nif (!(dcb->dev_mode & NTC_DO_SYNC_NEGO))\r\ndcb->sync_offset = 0;\r\nelse if (dcb->sync_offset == 0)\r\ndcb->sync_offset = srb->msgin_buf[4];\r\nif (srb->msgin_buf[4] > dcb->sync_offset)\r\nsrb->msgin_buf[4] = dcb->sync_offset;\r\nelse\r\ndcb->sync_offset = srb->msgin_buf[4];\r\nbval = 0;\r\nwhile (bval < 7 && (srb->msgin_buf[3] > clock_period[bval]\r\n|| dcb->min_nego_period >\r\nclock_period[bval]))\r\nbval++;\r\nif (srb->msgin_buf[3] < clock_period[bval])\r\ndprintkl(KERN_INFO,\r\n"msgin_set_sync: Increase sync nego period to %ins\n",\r\nclock_period[bval] << 2);\r\nsrb->msgin_buf[3] = clock_period[bval];\r\ndcb->sync_period &= 0xf0;\r\ndcb->sync_period |= ALT_SYNC | bval;\r\ndcb->min_nego_period = srb->msgin_buf[3];\r\nif (dcb->sync_period & WIDE_SYNC)\r\nfact = 500;\r\nelse\r\nfact = 250;\r\ndprintkl(KERN_INFO,\r\n"Target %02i: %s Sync: %ins Offset %i (%02i.%01i MB/s)\n",\r\ndcb->target_id, (fact == 500) ? "Wide16" : "",\r\ndcb->min_nego_period << 2, dcb->sync_offset,\r\n(fact / dcb->min_nego_period),\r\n((fact % dcb->min_nego_period) * 10 +\r\ndcb->min_nego_period / 2) / dcb->min_nego_period);\r\nif (!(srb->state & SRB_DO_SYNC_NEGO)) {\r\ndprintkl(KERN_DEBUG, "msgin_set_sync: answer w/%ins %i\n",\r\nsrb->msgin_buf[3] << 2, srb->msgin_buf[4]);\r\nmemcpy(srb->msgout_buf, srb->msgin_buf, 5);\r\nsrb->msg_count = 5;\r\nDC395x_ENABLE_MSGOUT;\r\ndcb->sync_mode |= SYNC_NEGO_DONE;\r\n} else {\r\nif ((dcb->sync_mode & WIDE_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & WIDE_NEGO_DONE)) {\r\nbuild_wdtr(acb, dcb, srb);\r\nDC395x_ENABLE_MSGOUT;\r\ndprintkdbg(DBG_0, "msgin_set_sync: Also try WDTR\n");\r\n}\r\n}\r\nsrb->state &= ~SRB_DO_SYNC_NEGO;\r\ndcb->sync_mode |= SYNC_NEGO_DONE | SYNC_NEGO_ENABLE;\r\nreprogram_regs(acb, dcb);\r\n}\r\nstatic inline void msgin_set_nowide(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\ndprintkdbg(DBG_1, "msgin_set_nowide: <%02i>\n", dcb->target_id);\r\ndcb->sync_period &= ~WIDE_SYNC;\r\ndcb->sync_mode &= ~(WIDE_NEGO_ENABLE);\r\ndcb->sync_mode |= WIDE_NEGO_DONE;\r\nsrb->state &= ~SRB_DO_WIDE_NEGO;\r\nreprogram_regs(acb, dcb);\r\nif ((dcb->sync_mode & SYNC_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & SYNC_NEGO_DONE)) {\r\nbuild_sdtr(acb, dcb, srb);\r\nDC395x_ENABLE_MSGOUT;\r\ndprintkdbg(DBG_0, "msgin_set_nowide: Rejected. Try SDTR anyway\n");\r\n}\r\n}\r\nstatic void msgin_set_wide(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\nstruct DeviceCtlBlk *dcb = srb->dcb;\r\nu8 wide = (dcb->dev_mode & NTC_DO_WIDE_NEGO\r\n&& acb->config & HCC_WIDE_CARD) ? 1 : 0;\r\ndprintkdbg(DBG_1, "msgin_set_wide: <%02i>\n", dcb->target_id);\r\nif (srb->msgin_buf[3] > wide)\r\nsrb->msgin_buf[3] = wide;\r\nif (!(srb->state & SRB_DO_WIDE_NEGO)) {\r\ndprintkl(KERN_DEBUG,\r\n"msgin_set_wide: Wide nego initiated <%02i>\n",\r\ndcb->target_id);\r\nmemcpy(srb->msgout_buf, srb->msgin_buf, 4);\r\nsrb->msg_count = 4;\r\nsrb->state |= SRB_DO_WIDE_NEGO;\r\nDC395x_ENABLE_MSGOUT;\r\n}\r\ndcb->sync_mode |= (WIDE_NEGO_ENABLE | WIDE_NEGO_DONE);\r\nif (srb->msgin_buf[3] > 0)\r\ndcb->sync_period |= WIDE_SYNC;\r\nelse\r\ndcb->sync_period &= ~WIDE_SYNC;\r\nsrb->state &= ~SRB_DO_WIDE_NEGO;\r\ndprintkdbg(DBG_1,\r\n"msgin_set_wide: Wide (%i bit) negotiated <%02i>\n",\r\n(8 << srb->msgin_buf[3]), dcb->target_id);\r\nreprogram_regs(acb, dcb);\r\nif ((dcb->sync_mode & SYNC_NEGO_ENABLE)\r\n&& !(dcb->sync_mode & SYNC_NEGO_DONE)) {\r\nbuild_sdtr(acb, dcb, srb);\r\nDC395x_ENABLE_MSGOUT;\r\ndprintkdbg(DBG_0, "msgin_set_wide: Also try SDTR.\n");\r\n}\r\n}\r\nstatic void msgin_phase0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\nstruct DeviceCtlBlk *dcb = acb->active_dcb;\r\ndprintkdbg(DBG_0, "msgin_phase0: (0x%p)\n", srb->cmd);\r\nsrb->msgin_buf[acb->msg_len++] = DC395x_read8(acb, TRM_S1040_SCSI_FIFO);\r\nif (msgin_completed(srb->msgin_buf, acb->msg_len)) {\r\nswitch (srb->msgin_buf[0]) {\r\ncase DISCONNECT:\r\nsrb->state = SRB_DISCONNECT;\r\nbreak;\r\ncase SIMPLE_QUEUE_TAG:\r\ncase HEAD_OF_QUEUE_TAG:\r\ncase ORDERED_QUEUE_TAG:\r\nsrb =\r\nmsgin_qtag(acb, dcb,\r\nsrb->msgin_buf[1]);\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL,\r\nDO_CLRATN | DO_DATALATCH);\r\nif (srb->state & SRB_DO_SYNC_NEGO) {\r\nmsgin_set_async(acb, srb);\r\nbreak;\r\n}\r\nif (srb->state & SRB_DO_WIDE_NEGO) {\r\nmsgin_set_nowide(acb, srb);\r\nbreak;\r\n}\r\nenable_msgout_abort(acb, srb);\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nif (srb->msgin_buf[1] == 3\r\n&& srb->msgin_buf[2] == EXTENDED_SDTR) {\r\nmsgin_set_sync(acb, srb);\r\nbreak;\r\n}\r\nif (srb->msgin_buf[1] == 2\r\n&& srb->msgin_buf[2] == EXTENDED_WDTR\r\n&& srb->msgin_buf[3] <= 2) {\r\nmsgin_set_wide(acb, srb);\r\nbreak;\r\n}\r\nmsgin_reject(acb, srb);\r\nbreak;\r\ncase MSG_IGNOREWIDE:\r\ndprintkdbg(DBG_0, "msgin_phase0: Ignore Wide Residual!\n");\r\nbreak;\r\ncase COMMAND_COMPLETE:\r\nbreak;\r\ncase SAVE_POINTERS:\r\ndprintkdbg(DBG_0, "msgin_phase0: (0x%p) "\r\n"SAVE POINTER rem=%i Ignore\n",\r\nsrb->cmd, srb->total_xfer_length);\r\nbreak;\r\ncase RESTORE_POINTERS:\r\ndprintkdbg(DBG_0, "msgin_phase0: RESTORE POINTER. Ignore\n");\r\nbreak;\r\ncase ABORT:\r\ndprintkdbg(DBG_0, "msgin_phase0: (0x%p) "\r\n"<%02i-%i> ABORT msg\n",\r\nsrb->cmd, dcb->target_id,\r\ndcb->target_lun);\r\ndcb->flag |= ABORT_DEV_;\r\nenable_msgout_abort(acb, srb);\r\nbreak;\r\ndefault:\r\nif (srb->msgin_buf[0] & IDENTIFY_BASE) {\r\ndprintkdbg(DBG_0, "msgin_phase0: Identify msg\n");\r\nsrb->msg_count = 1;\r\nsrb->msgout_buf[0] = dcb->identify_msg;\r\nDC395x_ENABLE_MSGOUT;\r\nsrb->state |= SRB_MSGOUT;\r\n}\r\nmsgin_reject(acb, srb);\r\n}\r\nsrb->state &= ~SRB_MSGIN;\r\nacb->msg_len = 0;\r\n}\r\n*pscsi_status = PH_BUS_FREE;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\r\n}\r\nstatic void msgin_phase1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\ndprintkdbg(DBG_0, "msgin_phase1: (0x%p)\n", srb->cmd);\r\nclear_fifo(acb, "msgin_phase1");\r\nDC395x_write32(acb, TRM_S1040_SCSI_COUNTER, 1);\r\nif (!(srb->state & SRB_MSGIN)) {\r\nsrb->state &= ~SRB_DISCONNECT;\r\nsrb->state |= SRB_MSGIN;\r\n}\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_FIFO_IN);\r\n}\r\nstatic void nop0(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\n}\r\nstatic void nop1(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb,\r\nu16 *pscsi_status)\r\n{\r\n}\r\nstatic void set_xfer_rate(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb)\r\n{\r\nstruct DeviceCtlBlk *i;\r\nif (dcb->identify_msg & 0x07)\r\nreturn;\r\nif (acb->scan_devices) {\r\ncurrent_sync_offset = dcb->sync_offset;\r\nreturn;\r\n}\r\nlist_for_each_entry(i, &acb->dcb_list, list)\r\nif (i->target_id == dcb->target_id) {\r\ni->sync_period = dcb->sync_period;\r\ni->sync_offset = dcb->sync_offset;\r\ni->sync_mode = dcb->sync_mode;\r\ni->min_nego_period = dcb->min_nego_period;\r\n}\r\n}\r\nstatic void disconnect(struct AdapterCtlBlk *acb)\r\n{\r\nstruct DeviceCtlBlk *dcb = acb->active_dcb;\r\nstruct ScsiReqBlk *srb;\r\nif (!dcb) {\r\ndprintkl(KERN_ERR, "disconnect: No such device\n");\r\nudelay(500);\r\nacb->last_reset =\r\njiffies + HZ / 2 +\r\nHZ * acb->eeprom.delay_time;\r\nclear_fifo(acb, "disconnectEx");\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT);\r\nreturn;\r\n}\r\nsrb = dcb->active_srb;\r\nacb->active_dcb = NULL;\r\ndprintkdbg(DBG_0, "disconnect: (0x%p)\n", srb->cmd);\r\nsrb->scsi_phase = PH_BUS_FREE;\r\nclear_fifo(acb, "disconnect");\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_HWRESELECT);\r\nif (srb->state & SRB_UNEXPECT_RESEL) {\r\ndprintkl(KERN_ERR,\r\n"disconnect: Unexpected reselection <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\nsrb->state = 0;\r\nwaiting_process_next(acb);\r\n} else if (srb->state & SRB_ABORT_SENT) {\r\ndcb->flag &= ~ABORT_DEV_;\r\nacb->last_reset = jiffies + HZ / 2 + 1;\r\ndprintkl(KERN_ERR, "disconnect: SRB_ABORT_SENT\n");\r\ndoing_srb_done(acb, DID_ABORT, srb->cmd, 1);\r\nwaiting_process_next(acb);\r\n} else {\r\nif ((srb->state & (SRB_START_ + SRB_MSGOUT))\r\n|| !(srb->\r\nstate & (SRB_DISCONNECT + SRB_COMPLETED))) {\r\nif (srb->state != SRB_START_\r\n&& srb->state != SRB_MSGOUT) {\r\nsrb->state = SRB_READY;\r\ndprintkl(KERN_DEBUG,\r\n"disconnect: (0x%p) Unexpected\n",\r\nsrb->cmd);\r\nsrb->target_status = SCSI_STAT_SEL_TIMEOUT;\r\ngoto disc1;\r\n} else {\r\ndprintkdbg(DBG_KG, "disconnect: (0x%p) "\r\n"<%02i-%i> SelTO\n", srb->cmd,\r\ndcb->target_id, dcb->target_lun);\r\nif (srb->retry_count++ > DC395x_MAX_RETRIES\r\n|| acb->scan_devices) {\r\nsrb->target_status =\r\nSCSI_STAT_SEL_TIMEOUT;\r\ngoto disc1;\r\n}\r\nfree_tag(dcb, srb);\r\nsrb_going_to_waiting_move(dcb, srb);\r\ndprintkdbg(DBG_KG,\r\n"disconnect: (0x%p) Retry\n",\r\nsrb->cmd);\r\nwaiting_set_timer(acb, HZ / 20);\r\n}\r\n} else if (srb->state & SRB_DISCONNECT) {\r\nu8 bval = DC395x_read8(acb, TRM_S1040_SCSI_SIGNAL);\r\nif (bval & 0x40) {\r\ndprintkdbg(DBG_0, "disconnect: SCSI bus stat "\r\n" 0x%02x: ACK set! Other controllers?\n",\r\nbval);\r\n} else\r\nwaiting_process_next(acb);\r\n} else if (srb->state & SRB_COMPLETED) {\r\ndisc1:\r\nfree_tag(dcb, srb);\r\ndcb->active_srb = NULL;\r\nsrb->state = SRB_FREE;\r\nsrb_done(acb, dcb, srb);\r\n}\r\n}\r\n}\r\nstatic void reselect(struct AdapterCtlBlk *acb)\r\n{\r\nstruct DeviceCtlBlk *dcb = acb->active_dcb;\r\nstruct ScsiReqBlk *srb = NULL;\r\nu16 rsel_tar_lun_id;\r\nu8 id, lun;\r\nu8 arblostflag = 0;\r\ndprintkdbg(DBG_0, "reselect: acb=%p\n", acb);\r\nclear_fifo(acb, "reselect");\r\nrsel_tar_lun_id = DC395x_read16(acb, TRM_S1040_SCSI_TARGETID);\r\nif (dcb) {\r\nsrb = dcb->active_srb;\r\nif (!srb) {\r\ndprintkl(KERN_DEBUG, "reselect: Arb lost Resel won, "\r\n"but active_srb == NULL\n");\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nreturn;\r\n}\r\nif (!acb->scan_devices) {\r\ndprintkdbg(DBG_KG, "reselect: (0x%p) <%02i-%i> "\r\n"Arb lost but Resel win rsel=%i stat=0x%04x\n",\r\nsrb->cmd, dcb->target_id,\r\ndcb->target_lun, rsel_tar_lun_id,\r\nDC395x_read16(acb, TRM_S1040_SCSI_STATUS));\r\narblostflag = 1;\r\nsrb->state = SRB_READY;\r\nfree_tag(dcb, srb);\r\nsrb_going_to_waiting_move(dcb, srb);\r\nwaiting_set_timer(acb, HZ / 20);\r\n}\r\n}\r\nif (!(rsel_tar_lun_id & (IDENTIFY_BASE << 8)))\r\ndprintkl(KERN_DEBUG, "reselect: Expects identify msg. "\r\n"Got %i!\n", rsel_tar_lun_id);\r\nid = rsel_tar_lun_id & 0xff;\r\nlun = (rsel_tar_lun_id >> 8) & 7;\r\ndcb = find_dcb(acb, id, lun);\r\nif (!dcb) {\r\ndprintkl(KERN_ERR, "reselect: From non existent device "\r\n"<%02i-%i>\n", id, lun);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nreturn;\r\n}\r\nacb->active_dcb = dcb;\r\nif (!(dcb->dev_mode & NTC_DO_DISCONNECT))\r\ndprintkl(KERN_DEBUG, "reselect: in spite of forbidden "\r\n"disconnection? <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\nif (dcb->sync_mode & EN_TAG_QUEUEING ) {\r\nsrb = acb->tmp_srb;\r\ndcb->active_srb = srb;\r\n} else {\r\nsrb = dcb->active_srb;\r\nif (!srb || !(srb->state & SRB_DISCONNECT)) {\r\ndprintkl(KERN_DEBUG,\r\n"reselect: w/o disconnected cmds <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\nsrb = acb->tmp_srb;\r\nsrb->state = SRB_UNEXPECT_RESEL;\r\ndcb->active_srb = srb;\r\nenable_msgout_abort(acb, srb);\r\n} else {\r\nif (dcb->flag & ABORT_DEV_) {\r\nenable_msgout_abort(acb, srb);\r\n} else\r\nsrb->state = SRB_DATA_XFER;\r\n}\r\n}\r\nsrb->scsi_phase = PH_BUS_FREE;\r\ndprintkdbg(DBG_0, "reselect: select <%i>\n", dcb->target_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_TARGETID, dcb->target_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, dcb->sync_offset);\r\nDC395x_write8(acb, TRM_S1040_SCSI_SYNC, dcb->sync_period);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_DATALATCH);\r\nDC395x_write8(acb, TRM_S1040_SCSI_COMMAND, SCMD_MSGACCEPT);\r\n}\r\nstatic inline u8 tagq_blacklist(char *name)\r\n{\r\n#ifndef DC395x_NO_TAGQ\r\n#if 0\r\nu8 i;\r\nfor (i = 0; i < BADDEVCNT; i++)\r\nif (memcmp(name, DC395x_baddevname1[i], 28) == 0)\r\nreturn 1;\r\n#endif\r\nreturn 0;\r\n#else\r\nreturn 1;\r\n#endif\r\n}\r\nstatic void disc_tagq_set(struct DeviceCtlBlk *dcb, struct ScsiInqData *ptr)\r\n{\r\nif ((ptr->Vers & 0x07) >= 2 || (ptr->RDF & 0x0F) == 2) {\r\nif ((ptr->Flags & SCSI_INQ_CMDQUEUE)\r\n&& (dcb->dev_mode & NTC_DO_TAG_QUEUEING) &&\r\n!tagq_blacklist(((char *)ptr) + 8)) {\r\nif (dcb->max_command == 1)\r\ndcb->max_command =\r\ndcb->acb->tag_max_num;\r\ndcb->sync_mode |= EN_TAG_QUEUEING;\r\n} else\r\ndcb->max_command = 1;\r\n}\r\n}\r\nstatic void add_dev(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\r\nstruct ScsiInqData *ptr)\r\n{\r\nu8 bval1 = ptr->DevType & SCSI_DEVTYPE;\r\ndcb->dev_type = bval1;\r\ndisc_tagq_set(dcb, ptr);\r\n}\r\nstatic void pci_unmap_srb(struct AdapterCtlBlk *acb, struct ScsiReqBlk *srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nenum dma_data_direction dir = cmd->sc_data_direction;\r\nif (scsi_sg_count(cmd) && dir != PCI_DMA_NONE) {\r\ndprintkdbg(DBG_SG, "pci_unmap_srb: list=%08x(%05x)\n",\r\nsrb->sg_bus_addr, SEGMENTX_LEN);\r\npci_unmap_single(acb->dev, srb->sg_bus_addr,\r\nSEGMENTX_LEN,\r\nPCI_DMA_TODEVICE);\r\ndprintkdbg(DBG_SG, "pci_unmap_srb: segs=%i buffer=%p\n",\r\nscsi_sg_count(cmd), scsi_bufflen(cmd));\r\nscsi_dma_unmap(cmd);\r\n}\r\n}\r\nstatic void pci_unmap_srb_sense(struct AdapterCtlBlk *acb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nif (!(srb->flag & AUTO_REQSENSE))\r\nreturn;\r\ndprintkdbg(DBG_SG, "pci_unmap_srb_sense: buffer=%08x\n",\r\nsrb->segment_x[0].address);\r\npci_unmap_single(acb->dev, srb->segment_x[0].address,\r\nsrb->segment_x[0].length, PCI_DMA_FROMDEVICE);\r\nsrb->total_xfer_length = srb->xferred;\r\nsrb->segment_x[0].address =\r\nsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].address;\r\nsrb->segment_x[0].length =\r\nsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].length;\r\n}\r\nstatic void srb_done(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nu8 tempcnt, status;\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\nenum dma_data_direction dir = cmd->sc_data_direction;\r\nint ckc_only = 1;\r\ndprintkdbg(DBG_1, "srb_done: (0x%p) <%02i-%i>\n", srb->cmd,\r\nsrb->cmd->device->id, srb->cmd->device->lun);\r\ndprintkdbg(DBG_SG, "srb_done: srb=%p sg=%i(%i/%i) buf=%p\n",\r\nsrb, scsi_sg_count(cmd), srb->sg_index, srb->sg_count,\r\nscsi_sgtalbe(cmd));\r\nstatus = srb->target_status;\r\nif (srb->flag & AUTO_REQSENSE) {\r\ndprintkdbg(DBG_0, "srb_done: AUTO_REQSENSE1\n");\r\npci_unmap_srb_sense(acb, srb);\r\nsrb->flag &= ~AUTO_REQSENSE;\r\nsrb->adapter_status = 0;\r\nsrb->target_status = CHECK_CONDITION << 1;\r\nif (debug_enabled(DBG_1)) {\r\nswitch (cmd->sense_buffer[2] & 0x0f) {\r\ncase NOT_READY:\r\ndprintkl(KERN_DEBUG,\r\n"ReqSense: NOT_READY cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",\r\ncmd->cmnd[0], dcb->target_id,\r\ndcb->target_lun, status, acb->scan_devices);\r\nbreak;\r\ncase UNIT_ATTENTION:\r\ndprintkl(KERN_DEBUG,\r\n"ReqSense: UNIT_ATTENTION cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",\r\ncmd->cmnd[0], dcb->target_id,\r\ndcb->target_lun, status, acb->scan_devices);\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\ndprintkl(KERN_DEBUG,\r\n"ReqSense: ILLEGAL_REQUEST cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",\r\ncmd->cmnd[0], dcb->target_id,\r\ndcb->target_lun, status, acb->scan_devices);\r\nbreak;\r\ncase MEDIUM_ERROR:\r\ndprintkl(KERN_DEBUG,\r\n"ReqSense: MEDIUM_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",\r\ncmd->cmnd[0], dcb->target_id,\r\ndcb->target_lun, status, acb->scan_devices);\r\nbreak;\r\ncase HARDWARE_ERROR:\r\ndprintkl(KERN_DEBUG,\r\n"ReqSense: HARDWARE_ERROR cmnd=0x%02x <%02i-%i> stat=%i scan=%i ",\r\ncmd->cmnd[0], dcb->target_id,\r\ndcb->target_lun, status, acb->scan_devices);\r\nbreak;\r\n}\r\nif (cmd->sense_buffer[7] >= 6)\r\nprintk("sense=0x%02x ASC=0x%02x ASCQ=0x%02x "\r\n"(0x%08x 0x%08x)\n",\r\ncmd->sense_buffer[2], cmd->sense_buffer[12],\r\ncmd->sense_buffer[13],\r\n*((unsigned int *)(cmd->sense_buffer + 3)),\r\n*((unsigned int *)(cmd->sense_buffer + 8)));\r\nelse\r\nprintk("sense=0x%02x No ASC/ASCQ (0x%08x)\n",\r\ncmd->sense_buffer[2],\r\n*((unsigned int *)(cmd->sense_buffer + 3)));\r\n}\r\nif (status == (CHECK_CONDITION << 1)) {\r\ncmd->result = DID_BAD_TARGET << 16;\r\ngoto ckc_e;\r\n}\r\ndprintkdbg(DBG_0, "srb_done: AUTO_REQSENSE2\n");\r\nif (srb->total_xfer_length\r\n&& srb->total_xfer_length >= cmd->underflow)\r\ncmd->result =\r\nMK_RES_LNX(DRIVER_SENSE, DID_OK,\r\nsrb->end_message, CHECK_CONDITION);\r\nelse\r\ncmd->result =\r\nMK_RES_LNX(DRIVER_SENSE, DID_OK,\r\nsrb->end_message, CHECK_CONDITION);\r\ngoto ckc_e;\r\n}\r\nif (status) {\r\nif (status_byte(status) == CHECK_CONDITION) {\r\nrequest_sense(acb, dcb, srb);\r\nreturn;\r\n} else if (status_byte(status) == QUEUE_FULL) {\r\ntempcnt = (u8)list_size(&dcb->srb_going_list);\r\ndprintkl(KERN_INFO, "QUEUE_FULL for dev <%02i-%i> with %i cmnds\n",\r\ndcb->target_id, dcb->target_lun, tempcnt);\r\nif (tempcnt > 1)\r\ntempcnt--;\r\ndcb->max_command = tempcnt;\r\nfree_tag(dcb, srb);\r\nsrb_going_to_waiting_move(dcb, srb);\r\nwaiting_set_timer(acb, HZ / 20);\r\nsrb->adapter_status = 0;\r\nsrb->target_status = 0;\r\nreturn;\r\n} else if (status == SCSI_STAT_SEL_TIMEOUT) {\r\nsrb->adapter_status = H_SEL_TIMEOUT;\r\nsrb->target_status = 0;\r\ncmd->result = DID_NO_CONNECT << 16;\r\n} else {\r\nsrb->adapter_status = 0;\r\nSET_RES_DID(cmd->result, DID_ERROR);\r\nSET_RES_MSG(cmd->result, srb->end_message);\r\nSET_RES_TARGET(cmd->result, status);\r\n}\r\n} else {\r\nstatus = srb->adapter_status;\r\nif (status & H_OVER_UNDER_RUN) {\r\nsrb->target_status = 0;\r\nSET_RES_DID(cmd->result, DID_OK);\r\nSET_RES_MSG(cmd->result, srb->end_message);\r\n} else if (srb->status & PARITY_ERROR) {\r\nSET_RES_DID(cmd->result, DID_PARITY);\r\nSET_RES_MSG(cmd->result, srb->end_message);\r\n} else {\r\nsrb->adapter_status = 0;\r\nsrb->target_status = 0;\r\nSET_RES_DID(cmd->result, DID_OK);\r\n}\r\n}\r\nif (dir != PCI_DMA_NONE && scsi_sg_count(cmd))\r\npci_dma_sync_sg_for_cpu(acb->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), dir);\r\nckc_only = 0;\r\nckc_e:\r\nif (cmd->cmnd[0] == INQUIRY) {\r\nunsigned char *base = NULL;\r\nstruct ScsiInqData *ptr;\r\nunsigned long flags = 0;\r\nstruct scatterlist* sg = scsi_sglist(cmd);\r\nsize_t offset = 0, len = sizeof(struct ScsiInqData);\r\nlocal_irq_save(flags);\r\nbase = scsi_kmap_atomic_sg(sg, scsi_sg_count(cmd), &offset, &len);\r\nptr = (struct ScsiInqData *)(base + offset);\r\nif (!ckc_only && (cmd->result & RES_DID) == 0\r\n&& cmd->cmnd[2] == 0 && scsi_bufflen(cmd) >= 8\r\n&& dir != PCI_DMA_NONE && ptr && (ptr->Vers & 0x07) >= 2)\r\ndcb->inquiry7 = ptr->Flags;\r\nif ((cmd->result == (DID_OK << 16)\r\n|| status_byte(cmd->result) &\r\nCHECK_CONDITION)) {\r\nif (!dcb->init_tcq_flag) {\r\nadd_dev(acb, dcb, ptr);\r\ndcb->init_tcq_flag = 1;\r\n}\r\n}\r\nscsi_kunmap_atomic_sg(base);\r\nlocal_irq_restore(flags);\r\n}\r\nscsi_set_resid(cmd, srb->total_xfer_length);\r\ncmd->SCp.this_residual = srb->total_xfer_length;\r\ncmd->SCp.buffers_residual = 0;\r\nif (debug_enabled(DBG_KG)) {\r\nif (srb->total_xfer_length)\r\ndprintkdbg(DBG_KG, "srb_done: (0x%p) <%02i-%i> "\r\n"cmnd=0x%02x Missed %i bytes\n",\r\ncmd, cmd->device->id, cmd->device->lun,\r\ncmd->cmnd[0], srb->total_xfer_length);\r\n}\r\nsrb_going_remove(dcb, srb);\r\nif (srb == acb->tmp_srb)\r\ndprintkl(KERN_ERR, "srb_done: ERROR! Completed cmd with tmp_srb\n");\r\nelse {\r\ndprintkdbg(DBG_0, "srb_done: (0x%p) done result=0x%08x\n",\r\ncmd, cmd->result);\r\nsrb_free_insert(acb, srb);\r\n}\r\npci_unmap_srb(acb, srb);\r\ncmd->scsi_done(cmd);\r\nwaiting_process_next(acb);\r\n}\r\nstatic void doing_srb_done(struct AdapterCtlBlk *acb, u8 did_flag,\r\nstruct scsi_cmnd *cmd, u8 force)\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\ndprintkl(KERN_INFO, "doing_srb_done: pids ");\r\nlist_for_each_entry(dcb, &acb->dcb_list, list) {\r\nstruct ScsiReqBlk *srb;\r\nstruct ScsiReqBlk *tmp;\r\nstruct scsi_cmnd *p;\r\nlist_for_each_entry_safe(srb, tmp, &dcb->srb_going_list, list) {\r\nenum dma_data_direction dir;\r\nint result;\r\np = srb->cmd;\r\ndir = p->sc_data_direction;\r\nresult = MK_RES(0, did_flag, 0, 0);\r\nprintk("G:%p(%02i-%i) ", p,\r\np->device->id, p->device->lun);\r\nsrb_going_remove(dcb, srb);\r\nfree_tag(dcb, srb);\r\nsrb_free_insert(acb, srb);\r\np->result = result;\r\npci_unmap_srb_sense(acb, srb);\r\npci_unmap_srb(acb, srb);\r\nif (force) {\r\np->scsi_done(p);\r\n}\r\n}\r\nif (!list_empty(&dcb->srb_going_list))\r\ndprintkl(KERN_DEBUG,\r\n"How could the ML send cmnds to the Going queue? <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\nif (dcb->tag_mask)\r\ndprintkl(KERN_DEBUG,\r\n"tag_mask for <%02i-%i> should be empty, is %08x!\n",\r\ndcb->target_id, dcb->target_lun,\r\ndcb->tag_mask);\r\nlist_for_each_entry_safe(srb, tmp, &dcb->srb_waiting_list, list) {\r\nint result;\r\np = srb->cmd;\r\nresult = MK_RES(0, did_flag, 0, 0);\r\nprintk("W:%p<%02i-%i>", p, p->device->id,\r\np->device->lun);\r\nsrb_waiting_remove(dcb, srb);\r\nsrb_free_insert(acb, srb);\r\np->result = result;\r\npci_unmap_srb_sense(acb, srb);\r\npci_unmap_srb(acb, srb);\r\nif (force) {\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\nif (!list_empty(&dcb->srb_waiting_list))\r\ndprintkl(KERN_DEBUG, "ML queued %i cmnds again to <%02i-%i>\n",\r\nlist_size(&dcb->srb_waiting_list), dcb->target_id,\r\ndcb->target_lun);\r\ndcb->flag &= ~ABORT_DEV_;\r\n}\r\nprintk("\n");\r\n}\r\nstatic void reset_scsi_bus(struct AdapterCtlBlk *acb)\r\n{\r\ndprintkdbg(DBG_0, "reset_scsi_bus: acb=%p\n", acb);\r\nacb->acb_flag |= RESET_DEV;\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_RSTSCSI);\r\nwhile (!(DC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS) & INT_SCSIRESET))\r\n;\r\n}\r\nstatic void set_basic_config(struct AdapterCtlBlk *acb)\r\n{\r\nu8 bval;\r\nu16 wval;\r\nDC395x_write8(acb, TRM_S1040_SCSI_TIMEOUT, acb->sel_timeout);\r\nif (acb->config & HCC_PARITY)\r\nbval = PHASELATCH | INITIATOR | BLOCKRST | PARITYCHECK;\r\nelse\r\nbval = PHASELATCH | INITIATOR | BLOCKRST;\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG0, bval);\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONFIG1, 0x03);\r\nDC395x_write8(acb, TRM_S1040_SCSI_HOSTID, acb->scsi_host->this_id);\r\nDC395x_write8(acb, TRM_S1040_SCSI_OFFSET, 0x00);\r\nwval = DC395x_read16(acb, TRM_S1040_GEN_CONTROL) & 0x7F;\r\nDC395x_write16(acb, TRM_S1040_GEN_CONTROL, wval);\r\nwval = DC395x_read16(acb, TRM_S1040_DMA_CONFIG) & ~DMA_FIFO_CTRL;\r\nwval |=\r\nDMA_FIFO_HALF_HALF | DMA_ENHANCE ;\r\nDC395x_write16(acb, TRM_S1040_DMA_CONFIG, wval);\r\nDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\r\nDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x7F);\r\nDC395x_write8(acb, TRM_S1040_DMA_INTEN, EN_SCSIINTR | EN_DMAXFERERROR\r\n);\r\n}\r\nstatic void scsi_reset_detect(struct AdapterCtlBlk *acb)\r\n{\r\ndprintkl(KERN_INFO, "scsi_reset_detect: acb=%p\n", acb);\r\nif (timer_pending(&acb->waiting_timer))\r\ndel_timer(&acb->waiting_timer);\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\r\nudelay(500);\r\nacb->last_reset =\r\njiffies + 5 * HZ / 2 +\r\nHZ * acb->eeprom.delay_time;\r\nclear_fifo(acb, "scsi_reset_detect");\r\nset_basic_config(acb);\r\nif (acb->acb_flag & RESET_DEV) {\r\nacb->acb_flag |= RESET_DONE;\r\n} else {\r\nacb->acb_flag |= RESET_DETECT;\r\nreset_dev_param(acb);\r\ndoing_srb_done(acb, DID_RESET, NULL, 1);\r\nacb->active_dcb = NULL;\r\nacb->acb_flag = 0;\r\nwaiting_process_next(acb);\r\n}\r\n}\r\nstatic void request_sense(struct AdapterCtlBlk *acb, struct DeviceCtlBlk *dcb,\r\nstruct ScsiReqBlk *srb)\r\n{\r\nstruct scsi_cmnd *cmd = srb->cmd;\r\ndprintkdbg(DBG_1, "request_sense: (0x%p) <%02i-%i>\n",\r\ncmd, cmd->device->id, cmd->device->lun);\r\nsrb->flag |= AUTO_REQSENSE;\r\nsrb->adapter_status = 0;\r\nsrb->target_status = 0;\r\nmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].address =\r\nsrb->segment_x[0].address;\r\nsrb->segment_x[DC395x_MAX_SG_LISTENTRY - 1].length =\r\nsrb->segment_x[0].length;\r\nsrb->xferred = srb->total_xfer_length;\r\nsrb->total_xfer_length = SCSI_SENSE_BUFFERSIZE;\r\nsrb->segment_x[0].length = SCSI_SENSE_BUFFERSIZE;\r\nsrb->segment_x[0].address =\r\npci_map_single(acb->dev, cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, PCI_DMA_FROMDEVICE);\r\ndprintkdbg(DBG_SG, "request_sense: map buffer %p->%08x(%05x)\n",\r\ncmd->sense_buffer, srb->segment_x[0].address,\r\nSCSI_SENSE_BUFFERSIZE);\r\nsrb->sg_count = 1;\r\nsrb->sg_index = 0;\r\nif (start_scsi(acb, dcb, srb)) {\r\ndprintkl(KERN_DEBUG,\r\n"request_sense: (0x%p) failed <%02i-%i>\n",\r\nsrb->cmd, dcb->target_id, dcb->target_lun);\r\nsrb_going_to_waiting_move(dcb, srb);\r\nwaiting_set_timer(acb, HZ / 100);\r\n}\r\n}\r\nstatic struct DeviceCtlBlk *device_alloc(struct AdapterCtlBlk *acb,\r\nu8 target, u8 lun)\r\n{\r\nstruct NvRamType *eeprom = &acb->eeprom;\r\nu8 period_index = eeprom->target[target].period & 0x07;\r\nstruct DeviceCtlBlk *dcb;\r\ndcb = kmalloc(sizeof(struct DeviceCtlBlk), GFP_ATOMIC);\r\ndprintkdbg(DBG_0, "device_alloc: <%02i-%i>\n", target, lun);\r\nif (!dcb)\r\nreturn NULL;\r\ndcb->acb = NULL;\r\nINIT_LIST_HEAD(&dcb->srb_going_list);\r\nINIT_LIST_HEAD(&dcb->srb_waiting_list);\r\ndcb->active_srb = NULL;\r\ndcb->tag_mask = 0;\r\ndcb->max_command = 1;\r\ndcb->target_id = target;\r\ndcb->target_lun = lun;\r\ndcb->dev_mode = eeprom->target[target].cfg0;\r\n#ifndef DC395x_NO_DISCONNECT\r\ndcb->identify_msg =\r\nIDENTIFY(dcb->dev_mode & NTC_DO_DISCONNECT, lun);\r\n#else\r\ndcb->identify_msg = IDENTIFY(0, lun);\r\n#endif\r\ndcb->inquiry7 = 0;\r\ndcb->sync_mode = 0;\r\ndcb->min_nego_period = clock_period[period_index];\r\ndcb->sync_period = 0;\r\ndcb->sync_offset = 0;\r\ndcb->flag = 0;\r\n#ifndef DC395x_NO_WIDE\r\nif ((dcb->dev_mode & NTC_DO_WIDE_NEGO)\r\n&& (acb->config & HCC_WIDE_CARD))\r\ndcb->sync_mode |= WIDE_NEGO_ENABLE;\r\n#endif\r\n#ifndef DC395x_NO_SYNC\r\nif (dcb->dev_mode & NTC_DO_SYNC_NEGO)\r\nif (!(lun) || current_sync_offset)\r\ndcb->sync_mode |= SYNC_NEGO_ENABLE;\r\n#endif\r\nif (dcb->target_lun != 0) {\r\nstruct DeviceCtlBlk *p;\r\nlist_for_each_entry(p, &acb->dcb_list, list)\r\nif (p->target_id == dcb->target_id)\r\nbreak;\r\ndprintkdbg(DBG_1,\r\n"device_alloc: <%02i-%i> copy from <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun,\r\np->target_id, p->target_lun);\r\ndcb->sync_mode = p->sync_mode;\r\ndcb->sync_period = p->sync_period;\r\ndcb->min_nego_period = p->min_nego_period;\r\ndcb->sync_offset = p->sync_offset;\r\ndcb->inquiry7 = p->inquiry7;\r\n}\r\nreturn dcb;\r\n}\r\nstatic void adapter_add_device(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb)\r\n{\r\ndcb->acb = acb;\r\nif (list_empty(&acb->dcb_list))\r\nacb->dcb_run_robin = dcb;\r\nlist_add_tail(&dcb->list, &acb->dcb_list);\r\nacb->dcb_map[dcb->target_id] |= (1 << dcb->target_lun);\r\nacb->children[dcb->target_id][dcb->target_lun] = dcb;\r\n}\r\nstatic void adapter_remove_device(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb)\r\n{\r\nstruct DeviceCtlBlk *i;\r\nstruct DeviceCtlBlk *tmp;\r\ndprintkdbg(DBG_0, "adapter_remove_device: <%02i-%i>\n",\r\ndcb->target_id, dcb->target_lun);\r\nif (acb->active_dcb == dcb)\r\nacb->active_dcb = NULL;\r\nif (acb->dcb_run_robin == dcb)\r\nacb->dcb_run_robin = dcb_get_next(&acb->dcb_list, dcb);\r\nlist_for_each_entry_safe(i, tmp, &acb->dcb_list, list)\r\nif (dcb == i) {\r\nlist_del(&i->list);\r\nbreak;\r\n}\r\nacb->dcb_map[dcb->target_id] &= ~(1 << dcb->target_lun);\r\nacb->children[dcb->target_id][dcb->target_lun] = NULL;\r\ndcb->acb = NULL;\r\n}\r\nstatic void adapter_remove_and_free_device(struct AdapterCtlBlk *acb,\r\nstruct DeviceCtlBlk *dcb)\r\n{\r\nif (list_size(&dcb->srb_going_list) > 1) {\r\ndprintkdbg(DBG_1, "adapter_remove_and_free_device: <%02i-%i> "\r\n"Won't remove because of %i active requests.\n",\r\ndcb->target_id, dcb->target_lun,\r\nlist_size(&dcb->srb_going_list));\r\nreturn;\r\n}\r\nadapter_remove_device(acb, dcb);\r\nkfree(dcb);\r\n}\r\nstatic void adapter_remove_and_free_all_devices(struct AdapterCtlBlk* acb)\r\n{\r\nstruct DeviceCtlBlk *dcb;\r\nstruct DeviceCtlBlk *tmp;\r\ndprintkdbg(DBG_1, "adapter_remove_and_free_all_devices: num=%i\n",\r\nlist_size(&acb->dcb_list));\r\nlist_for_each_entry_safe(dcb, tmp, &acb->dcb_list, list)\r\nadapter_remove_and_free_device(acb, dcb);\r\n}\r\nstatic int dc395x_slave_alloc(struct scsi_device *scsi_device)\r\n{\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;\r\nstruct DeviceCtlBlk *dcb;\r\ndcb = device_alloc(acb, scsi_device->id, scsi_device->lun);\r\nif (!dcb)\r\nreturn -ENOMEM;\r\nadapter_add_device(acb, dcb);\r\nreturn 0;\r\n}\r\nstatic void dc395x_slave_destroy(struct scsi_device *scsi_device)\r\n{\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)scsi_device->host->hostdata;\r\nstruct DeviceCtlBlk *dcb = find_dcb(acb, scsi_device->id, scsi_device->lun);\r\nif (dcb)\r\nadapter_remove_and_free_device(acb, dcb);\r\n}\r\nstatic void trms1040_wait_30us(unsigned long io_port)\r\n{\r\noutb(5, io_port + TRM_S1040_GEN_TIMER);\r\nwhile (!(inb(io_port + TRM_S1040_GEN_STATUS) & GTIMEOUT))\r\n;\r\n}\r\nstatic void trms1040_write_cmd(unsigned long io_port, u8 cmd, u8 addr)\r\n{\r\nint i;\r\nu8 send_data;\r\nfor (i = 0; i < 3; i++, cmd <<= 1) {\r\nsend_data = NVR_SELECT;\r\nif (cmd & 0x04)\r\nsend_data |= NVR_BITOUT;\r\noutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb((send_data | NVR_CLOCK),\r\nio_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\n}\r\nfor (i = 0; i < 7; i++, addr <<= 1) {\r\nsend_data = NVR_SELECT;\r\nif (addr & 0x40)\r\nsend_data |= NVR_BITOUT;\r\noutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb((send_data | NVR_CLOCK),\r\nio_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\n}\r\noutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\n}\r\nstatic void trms1040_set_data(unsigned long io_port, u8 addr, u8 byte)\r\n{\r\nint i;\r\nu8 send_data;\r\ntrms1040_write_cmd(io_port, 0x05, addr);\r\nfor (i = 0; i < 8; i++, byte <<= 1) {\r\nsend_data = NVR_SELECT;\r\nif (byte & 0x80)\r\nsend_data |= NVR_BITOUT;\r\noutb(send_data, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb((send_data | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\n}\r\noutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb(0, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\nwhile (1) {\r\noutb((NVR_SELECT | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\nif (inb(io_port + TRM_S1040_GEN_NVRAM) & NVR_BITIN)\r\nbreak;\r\n}\r\noutb(0, io_port + TRM_S1040_GEN_NVRAM);\r\n}\r\nstatic void trms1040_write_all(struct NvRamType *eeprom, unsigned long io_port)\r\n{\r\nu8 *b_eeprom = (u8 *)eeprom;\r\nu8 addr;\r\noutb((inb(io_port + TRM_S1040_GEN_CONTROL) | EN_EEPROM),\r\nio_port + TRM_S1040_GEN_CONTROL);\r\ntrms1040_write_cmd(io_port, 0x04, 0xFF);\r\noutb(0, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\nfor (addr = 0; addr < 128; addr++, b_eeprom++)\r\ntrms1040_set_data(io_port, addr, *b_eeprom);\r\ntrms1040_write_cmd(io_port, 0x04, 0x00);\r\noutb(0, io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb((inb(io_port + TRM_S1040_GEN_CONTROL) & ~EN_EEPROM),\r\nio_port + TRM_S1040_GEN_CONTROL);\r\n}\r\nstatic u8 trms1040_get_data(unsigned long io_port, u8 addr)\r\n{\r\nint i;\r\nu8 read_byte;\r\nu8 result = 0;\r\ntrms1040_write_cmd(io_port, 0x06, addr);\r\nfor (i = 0; i < 8; i++) {\r\noutb((NVR_SELECT | NVR_CLOCK), io_port + TRM_S1040_GEN_NVRAM);\r\ntrms1040_wait_30us(io_port);\r\noutb(NVR_SELECT, io_port + TRM_S1040_GEN_NVRAM);\r\nread_byte = inb(io_port + TRM_S1040_GEN_NVRAM);\r\nresult <<= 1;\r\nif (read_byte & NVR_BITIN)\r\nresult |= 1;\r\ntrms1040_wait_30us(io_port);\r\n}\r\noutb(0, io_port + TRM_S1040_GEN_NVRAM);\r\nreturn result;\r\n}\r\nstatic void trms1040_read_all(struct NvRamType *eeprom, unsigned long io_port)\r\n{\r\nu8 *b_eeprom = (u8 *)eeprom;\r\nu8 addr;\r\noutb((inb(io_port + TRM_S1040_GEN_CONTROL) | EN_EEPROM),\r\nio_port + TRM_S1040_GEN_CONTROL);\r\nfor (addr = 0; addr < 128; addr++, b_eeprom++)\r\n*b_eeprom = trms1040_get_data(io_port, addr);\r\noutb((inb(io_port + TRM_S1040_GEN_CONTROL) & ~EN_EEPROM),\r\nio_port + TRM_S1040_GEN_CONTROL);\r\n}\r\nstatic void check_eeprom(struct NvRamType *eeprom, unsigned long io_port)\r\n{\r\nu16 *w_eeprom = (u16 *)eeprom;\r\nu16 w_addr;\r\nu16 cksum;\r\nu32 d_addr;\r\nu32 *d_eeprom;\r\ntrms1040_read_all(eeprom, io_port);\r\ncksum = 0;\r\nfor (w_addr = 0, w_eeprom = (u16 *)eeprom; w_addr < 64;\r\nw_addr++, w_eeprom++)\r\ncksum += *w_eeprom;\r\nif (cksum != 0x1234) {\r\ndprintkl(KERN_WARNING,\r\n"EEProm checksum error: using default values and options.\n");\r\neeprom->sub_vendor_id[0] = (u8)PCI_VENDOR_ID_TEKRAM;\r\neeprom->sub_vendor_id[1] = (u8)(PCI_VENDOR_ID_TEKRAM >> 8);\r\neeprom->sub_sys_id[0] = (u8)PCI_DEVICE_ID_TEKRAM_TRMS1040;\r\neeprom->sub_sys_id[1] =\r\n(u8)(PCI_DEVICE_ID_TEKRAM_TRMS1040 >> 8);\r\neeprom->sub_class = 0x00;\r\neeprom->vendor_id[0] = (u8)PCI_VENDOR_ID_TEKRAM;\r\neeprom->vendor_id[1] = (u8)(PCI_VENDOR_ID_TEKRAM >> 8);\r\neeprom->device_id[0] = (u8)PCI_DEVICE_ID_TEKRAM_TRMS1040;\r\neeprom->device_id[1] =\r\n(u8)(PCI_DEVICE_ID_TEKRAM_TRMS1040 >> 8);\r\neeprom->reserved = 0x00;\r\nfor (d_addr = 0, d_eeprom = (u32 *)eeprom->target;\r\nd_addr < 16; d_addr++, d_eeprom++)\r\n*d_eeprom = 0x00000077;\r\n*d_eeprom++ = 0x04000F07;\r\n*d_eeprom++ = 0x00000015;\r\nfor (d_addr = 0; d_addr < 12; d_addr++, d_eeprom++)\r\n*d_eeprom = 0x00;\r\nset_safe_settings();\r\nfix_settings();\r\neeprom_override(eeprom);\r\neeprom->cksum = 0x00;\r\nfor (w_addr = 0, cksum = 0, w_eeprom = (u16 *)eeprom;\r\nw_addr < 63; w_addr++, w_eeprom++)\r\ncksum += *w_eeprom;\r\n*w_eeprom = 0x1234 - cksum;\r\ntrms1040_write_all(eeprom, io_port);\r\neeprom->delay_time = cfg_data[CFG_RESET_DELAY].value;\r\n} else {\r\nset_safe_settings();\r\neeprom_index_to_delay(eeprom);\r\neeprom_override(eeprom);\r\n}\r\n}\r\nstatic void print_eeprom_settings(struct NvRamType *eeprom)\r\n{\r\ndprintkl(KERN_INFO, "Used settings: AdapterID=%02i, Speed=%i(%02i.%01iMHz), dev_mode=0x%02x\n",\r\neeprom->scsi_id,\r\neeprom->target[0].period,\r\nclock_speed[eeprom->target[0].period] / 10,\r\nclock_speed[eeprom->target[0].period] % 10,\r\neeprom->target[0].cfg0);\r\ndprintkl(KERN_INFO, " AdaptMode=0x%02x, Tags=%i(%02i), DelayReset=%is\n",\r\neeprom->channel_cfg, eeprom->max_tag,\r\n1 << eeprom->max_tag, eeprom->delay_time);\r\n}\r\nstatic void adapter_sg_tables_free(struct AdapterCtlBlk *acb)\r\n{\r\nint i;\r\nconst unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;\r\nfor (i = 0; i < DC395x_MAX_SRB_CNT; i += srbs_per_page)\r\nkfree(acb->srb_array[i].segment_x);\r\n}\r\nstatic int adapter_sg_tables_alloc(struct AdapterCtlBlk *acb)\r\n{\r\nconst unsigned mem_needed = (DC395x_MAX_SRB_CNT+1)\r\n*SEGMENTX_LEN;\r\nint pages = (mem_needed+(PAGE_SIZE-1))/PAGE_SIZE;\r\nconst unsigned srbs_per_page = PAGE_SIZE/SEGMENTX_LEN;\r\nint srb_idx = 0;\r\nunsigned i = 0;\r\nstruct SGentry *uninitialized_var(ptr);\r\nfor (i = 0; i < DC395x_MAX_SRB_CNT; i++)\r\nacb->srb_array[i].segment_x = NULL;\r\ndprintkdbg(DBG_1, "Allocate %i pages for SG tables\n", pages);\r\nwhile (pages--) {\r\nptr = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!ptr) {\r\nadapter_sg_tables_free(acb);\r\nreturn 1;\r\n}\r\ndprintkdbg(DBG_1, "Allocate %li bytes at %p for SG segments %i\n",\r\nPAGE_SIZE, ptr, srb_idx);\r\ni = 0;\r\nwhile (i < srbs_per_page && srb_idx < DC395x_MAX_SRB_CNT)\r\nacb->srb_array[srb_idx++].segment_x =\r\nptr + (i++ * DC395x_MAX_SG_LISTENTRY);\r\n}\r\nif (i < srbs_per_page)\r\nacb->srb.segment_x =\r\nptr + (i * DC395x_MAX_SG_LISTENTRY);\r\nelse\r\ndprintkl(KERN_DEBUG, "No space for tmsrb SG table reserved?!\n");\r\nreturn 0;\r\n}\r\nstatic void adapter_print_config(struct AdapterCtlBlk *acb)\r\n{\r\nu8 bval;\r\nbval = DC395x_read8(acb, TRM_S1040_GEN_STATUS);\r\ndprintkl(KERN_INFO, "%sConnectors: ",\r\n((bval & WIDESCSI) ? "(Wide) " : ""));\r\nif (!(bval & CON5068))\r\nprintk("ext%s ", !(bval & EXT68HIGH) ? "68" : "50");\r\nif (!(bval & CON68))\r\nprintk("int68%s ", !(bval & INT68HIGH) ? "" : "(50)");\r\nif (!(bval & CON50))\r\nprintk("int50 ");\r\nif ((bval & (CON5068 | CON50 | CON68)) ==\r\n0 )\r\nprintk(" Oops! (All 3?) ");\r\nbval = DC395x_read8(acb, TRM_S1040_GEN_CONTROL);\r\nprintk(" Termination: ");\r\nif (bval & DIS_TERM)\r\nprintk("Disabled\n");\r\nelse {\r\nif (bval & AUTOTERM)\r\nprintk("Auto ");\r\nif (bval & LOW8TERM)\r\nprintk("Low ");\r\nif (bval & UP8TERM)\r\nprintk("High ");\r\nprintk("\n");\r\n}\r\n}\r\nstatic void adapter_init_params(struct AdapterCtlBlk *acb)\r\n{\r\nstruct NvRamType *eeprom = &acb->eeprom;\r\nint i;\r\nINIT_LIST_HEAD(&acb->dcb_list);\r\nacb->dcb_run_robin = NULL;\r\nacb->active_dcb = NULL;\r\nINIT_LIST_HEAD(&acb->srb_free_list);\r\nacb->tmp_srb = &acb->srb;\r\ninit_timer(&acb->waiting_timer);\r\ninit_timer(&acb->selto_timer);\r\nacb->srb_count = DC395x_MAX_SRB_CNT;\r\nacb->sel_timeout = DC395x_SEL_TIMEOUT;\r\nacb->tag_max_num = 1 << eeprom->max_tag;\r\nif (acb->tag_max_num > 30)\r\nacb->tag_max_num = 30;\r\nacb->acb_flag = 0;\r\nacb->gmode2 = eeprom->channel_cfg;\r\nacb->config = 0;\r\nif (eeprom->channel_cfg & NAC_SCANLUN)\r\nacb->lun_chk = 1;\r\nacb->scan_devices = 1;\r\nacb->scsi_host->this_id = eeprom->scsi_id;\r\nacb->hostid_bit = (1 << acb->scsi_host->this_id);\r\nfor (i = 0; i < DC395x_MAX_SCSI_ID; i++)\r\nacb->dcb_map[i] = 0;\r\nacb->msg_len = 0;\r\nfor (i = 0; i < acb->srb_count - 1; i++)\r\nsrb_free_insert(acb, &acb->srb_array[i]);\r\n}\r\nstatic void adapter_init_scsi_host(struct Scsi_Host *host)\r\n{\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;\r\nstruct NvRamType *eeprom = &acb->eeprom;\r\nhost->max_cmd_len = 24;\r\nhost->can_queue = DC395x_MAX_CMD_QUEUE;\r\nhost->cmd_per_lun = DC395x_MAX_CMD_PER_LUN;\r\nhost->this_id = (int)eeprom->scsi_id;\r\nhost->io_port = acb->io_port_base;\r\nhost->n_io_port = acb->io_port_len;\r\nhost->dma_channel = -1;\r\nhost->unique_id = acb->io_port_base;\r\nhost->irq = acb->irq_level;\r\nacb->last_reset = jiffies;\r\nhost->max_id = 16;\r\nif (host->max_id - 1 == eeprom->scsi_id)\r\nhost->max_id--;\r\n#ifdef CONFIG_SCSI_MULTI_LUN\r\nif (eeprom->channel_cfg & NAC_SCANLUN)\r\nhost->max_lun = 8;\r\nelse\r\nhost->max_lun = 1;\r\n#else\r\nhost->max_lun = 1;\r\n#endif\r\n}\r\nstatic void adapter_init_chip(struct AdapterCtlBlk *acb)\r\n{\r\nstruct NvRamType *eeprom = &acb->eeprom;\r\nDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0x00);\r\nDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0x00);\r\nDC395x_write16(acb, TRM_S1040_SCSI_CONTROL, DO_RSTMODULE);\r\nDC395x_write8(acb, TRM_S1040_DMA_CONTROL, DMARESETMODULE);\r\nudelay(20);\r\nacb->config = HCC_AUTOTERM | HCC_PARITY;\r\nif (DC395x_read8(acb, TRM_S1040_GEN_STATUS) & WIDESCSI)\r\nacb->config |= HCC_WIDE_CARD;\r\nif (eeprom->channel_cfg & NAC_POWERON_SCSI_RESET)\r\nacb->config |= HCC_SCSI_RESET;\r\nif (acb->config & HCC_SCSI_RESET) {\r\ndprintkl(KERN_INFO, "Performing initial SCSI bus reset\n");\r\nDC395x_write8(acb, TRM_S1040_SCSI_CONTROL, DO_RSTSCSI);\r\nudelay(500);\r\nacb->last_reset =\r\njiffies + HZ / 2 +\r\nHZ * acb->eeprom.delay_time;\r\n}\r\n}\r\nstatic int adapter_init(struct AdapterCtlBlk *acb, unsigned long io_port,\r\nu32 io_port_len, unsigned int irq)\r\n{\r\nif (!request_region(io_port, io_port_len, DC395X_NAME)) {\r\ndprintkl(KERN_ERR, "Failed to reserve IO region 0x%lx\n", io_port);\r\ngoto failed;\r\n}\r\nacb->io_port_base = io_port;\r\nacb->io_port_len = io_port_len;\r\nif (request_irq(irq, dc395x_interrupt, IRQF_SHARED, DC395X_NAME, acb)) {\r\ndprintkl(KERN_INFO, "Failed to register IRQ\n");\r\ngoto failed;\r\n}\r\nacb->irq_level = irq;\r\ncheck_eeprom(&acb->eeprom, io_port);\r\nprint_eeprom_settings(&acb->eeprom);\r\nadapter_init_params(acb);\r\nadapter_print_config(acb);\r\nif (adapter_sg_tables_alloc(acb)) {\r\ndprintkl(KERN_DEBUG, "Memory allocation for SG tables failed\n");\r\ngoto failed;\r\n}\r\nadapter_init_scsi_host(acb->scsi_host);\r\nadapter_init_chip(acb);\r\nset_basic_config(acb);\r\ndprintkdbg(DBG_0,\r\n"adapter_init: acb=%p, pdcb_map=%p psrb_array=%p "\r\n"size{acb=0x%04x dcb=0x%04x srb=0x%04x}\n",\r\nacb, acb->dcb_map, acb->srb_array, sizeof(struct AdapterCtlBlk),\r\nsizeof(struct DeviceCtlBlk), sizeof(struct ScsiReqBlk));\r\nreturn 0;\r\nfailed:\r\nif (acb->irq_level)\r\nfree_irq(acb->irq_level, acb);\r\nif (acb->io_port_base)\r\nrelease_region(acb->io_port_base, acb->io_port_len);\r\nadapter_sg_tables_free(acb);\r\nreturn 1;\r\n}\r\nstatic void adapter_uninit_chip(struct AdapterCtlBlk *acb)\r\n{\r\nDC395x_write8(acb, TRM_S1040_DMA_INTEN, 0);\r\nDC395x_write8(acb, TRM_S1040_SCSI_INTEN, 0);\r\nif (acb->config & HCC_SCSI_RESET)\r\nreset_scsi_bus(acb);\r\nDC395x_read8(acb, TRM_S1040_SCSI_INTSTATUS);\r\n}\r\nstatic void adapter_uninit(struct AdapterCtlBlk *acb)\r\n{\r\nunsigned long flags;\r\nDC395x_LOCK_IO(acb->scsi_host, flags);\r\nif (timer_pending(&acb->waiting_timer))\r\ndel_timer(&acb->waiting_timer);\r\nif (timer_pending(&acb->selto_timer))\r\ndel_timer(&acb->selto_timer);\r\nadapter_uninit_chip(acb);\r\nadapter_remove_and_free_all_devices(acb);\r\nDC395x_UNLOCK_IO(acb->scsi_host, flags);\r\nif (acb->irq_level)\r\nfree_irq(acb->irq_level, acb);\r\nif (acb->io_port_base)\r\nrelease_region(acb->io_port_base, acb->io_port_len);\r\nadapter_sg_tables_free(acb);\r\n}\r\nstatic int dc395x_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)host->hostdata;\r\nint spd, spd1;\r\nstruct DeviceCtlBlk *dcb;\r\nunsigned long flags;\r\nint dev;\r\nSPRINTF(DC395X_BANNER " PCI SCSI Host Adapter\n");\r\nSPRINTF(" Driver Version " DC395X_VERSION "\n");\r\nDC395x_LOCK_IO(acb->scsi_host, flags);\r\nSPRINTF("SCSI Host Nr %i, ", host->host_no);\r\nSPRINTF("DC395U/UW/F DC315/U %s\n",\r\n(acb->config & HCC_WIDE_CARD) ? "Wide" : "");\r\nSPRINTF("io_port_base 0x%04lx, ", acb->io_port_base);\r\nSPRINTF("irq_level 0x%04x, ", acb->irq_level);\r\nSPRINTF(" SelTimeout %ims\n", (1638 * acb->sel_timeout) / 1000);\r\nSPRINTF("MaxID %i, MaxLUN %i, ", host->max_id, host->max_lun);\r\nSPRINTF("AdapterID %i\n", host->this_id);\r\nSPRINTF("tag_max_num %i", acb->tag_max_num);\r\nSPRINTF(", FilterCfg 0x%02x",\r\nDC395x_read8(acb, TRM_S1040_SCSI_CONFIG1));\r\nSPRINTF(", DelayReset %is\n", acb->eeprom.delay_time);\r\nSPRINTF("Nr of DCBs: %i\n", list_size(&acb->dcb_list));\r\nSPRINTF\r\n("Map of attached LUNs: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nacb->dcb_map[0], acb->dcb_map[1], acb->dcb_map[2],\r\nacb->dcb_map[3], acb->dcb_map[4], acb->dcb_map[5],\r\nacb->dcb_map[6], acb->dcb_map[7]);\r\nSPRINTF\r\n(" %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nacb->dcb_map[8], acb->dcb_map[9], acb->dcb_map[10],\r\nacb->dcb_map[11], acb->dcb_map[12], acb->dcb_map[13],\r\nacb->dcb_map[14], acb->dcb_map[15]);\r\nSPRINTF\r\n("Un ID LUN Prty Sync Wide DsCn SndS TagQ nego_period SyncFreq SyncOffs MaxCmd\n");\r\ndev = 0;\r\nlist_for_each_entry(dcb, &acb->dcb_list, list) {\r\nint nego_period;\r\nSPRINTF("%02i %02i %02i ", dev, dcb->target_id,\r\ndcb->target_lun);\r\nYESNO(dcb->dev_mode & NTC_DO_PARITY_CHK);\r\nYESNO(dcb->sync_offset);\r\nYESNO(dcb->sync_period & WIDE_SYNC);\r\nYESNO(dcb->dev_mode & NTC_DO_DISCONNECT);\r\nYESNO(dcb->dev_mode & NTC_DO_SEND_START);\r\nYESNO(dcb->sync_mode & EN_TAG_QUEUEING);\r\nnego_period = clock_period[dcb->sync_period & 0x07] << 2;\r\nif (dcb->sync_offset)\r\nSPRINTF(" %03i ns ", nego_period);\r\nelse\r\nSPRINTF(" (%03i ns)", (dcb->min_nego_period << 2));\r\nif (dcb->sync_offset & 0x0f) {\r\nspd = 1000 / (nego_period);\r\nspd1 = 1000 % (nego_period);\r\nspd1 = (spd1 * 10 + nego_period / 2) / (nego_period);\r\nSPRINTF(" %2i.%1i M %02i ", spd, spd1,\r\n(dcb->sync_offset & 0x0f));\r\n} else\r\nSPRINTF(" ");\r\nSPRINTF(" %02i\n", dcb->max_command);\r\ndev++;\r\n}\r\nif (timer_pending(&acb->waiting_timer))\r\nSPRINTF("Waiting queue timer running\n");\r\nelse\r\nSPRINTF("\n");\r\nlist_for_each_entry(dcb, &acb->dcb_list, list) {\r\nstruct ScsiReqBlk *srb;\r\nif (!list_empty(&dcb->srb_waiting_list))\r\nSPRINTF("DCB (%02i-%i): Waiting: %i:",\r\ndcb->target_id, dcb->target_lun,\r\nlist_size(&dcb->srb_waiting_list));\r\nlist_for_each_entry(srb, &dcb->srb_waiting_list, list)\r\nSPRINTF(" %p", srb->cmd);\r\nif (!list_empty(&dcb->srb_going_list))\r\nSPRINTF("\nDCB (%02i-%i): Going : %i:",\r\ndcb->target_id, dcb->target_lun,\r\nlist_size(&dcb->srb_going_list));\r\nlist_for_each_entry(srb, &dcb->srb_going_list, list)\r\nSPRINTF(" %p", srb->cmd);\r\nif (!list_empty(&dcb->srb_waiting_list) || !list_empty(&dcb->srb_going_list))\r\nSPRINTF("\n");\r\n}\r\nif (debug_enabled(DBG_1)) {\r\nSPRINTF("DCB list for ACB %p:\n", acb);\r\nlist_for_each_entry(dcb, &acb->dcb_list, list) {\r\nSPRINTF("%p -> ", dcb);\r\n}\r\nSPRINTF("END\n");\r\n}\r\nDC395x_UNLOCK_IO(acb->scsi_host, flags);\r\nreturn 0;\r\n}\r\nstatic void banner_display(void)\r\n{\r\nstatic int banner_done = 0;\r\nif (!banner_done)\r\n{\r\ndprintkl(KERN_INFO, "%s %s\n", DC395X_BANNER, DC395X_VERSION);\r\nbanner_done = 1;\r\n}\r\n}\r\nstatic int dc395x_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *scsi_host = NULL;\r\nstruct AdapterCtlBlk *acb = NULL;\r\nunsigned long io_port_base;\r\nunsigned int io_port_len;\r\nunsigned int irq;\r\ndprintkdbg(DBG_0, "Init one instance (%s)\n", pci_name(dev));\r\nbanner_display();\r\nif (pci_enable_device(dev))\r\n{\r\ndprintkl(KERN_INFO, "PCI Enable device failed.\n");\r\nreturn -ENODEV;\r\n}\r\nio_port_base = pci_resource_start(dev, 0) & PCI_BASE_ADDRESS_IO_MASK;\r\nio_port_len = pci_resource_len(dev, 0);\r\nirq = dev->irq;\r\ndprintkdbg(DBG_0, "IO_PORT=0x%04lx, IRQ=0x%x\n", io_port_base, dev->irq);\r\nscsi_host = scsi_host_alloc(&dc395x_driver_template,\r\nsizeof(struct AdapterCtlBlk));\r\nif (!scsi_host) {\r\ndprintkl(KERN_INFO, "scsi_host_alloc failed\n");\r\ngoto fail;\r\n}\r\nacb = (struct AdapterCtlBlk*)scsi_host->hostdata;\r\nacb->scsi_host = scsi_host;\r\nacb->dev = dev;\r\nif (adapter_init(acb, io_port_base, io_port_len, irq)) {\r\ndprintkl(KERN_INFO, "adapter init failed\n");\r\ngoto fail;\r\n}\r\npci_set_master(dev);\r\nif (scsi_add_host(scsi_host, &dev->dev)) {\r\ndprintkl(KERN_ERR, "scsi_add_host failed\n");\r\ngoto fail;\r\n}\r\npci_set_drvdata(dev, scsi_host);\r\nscsi_scan_host(scsi_host);\r\nreturn 0;\r\nfail:\r\nif (acb != NULL)\r\nadapter_uninit(acb);\r\nif (scsi_host != NULL)\r\nscsi_host_put(scsi_host);\r\npci_disable_device(dev);\r\nreturn -ENODEV;\r\n}\r\nstatic void dc395x_remove_one(struct pci_dev *dev)\r\n{\r\nstruct Scsi_Host *scsi_host = pci_get_drvdata(dev);\r\nstruct AdapterCtlBlk *acb = (struct AdapterCtlBlk *)(scsi_host->hostdata);\r\ndprintkdbg(DBG_0, "dc395x_remove_one: acb=%p\n", acb);\r\nscsi_remove_host(scsi_host);\r\nadapter_uninit(acb);\r\npci_disable_device(dev);\r\nscsi_host_put(scsi_host);\r\n}\r\nstatic int __init dc395x_module_init(void)\r\n{\r\nreturn pci_register_driver(&dc395x_driver);\r\n}\r\nstatic void __exit dc395x_module_exit(void)\r\n{\r\npci_unregister_driver(&dc395x_driver);\r\n}
