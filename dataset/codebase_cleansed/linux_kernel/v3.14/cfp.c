u8 *mwifiex_11d_code_2_region(u8 code)\r\n{\r\nu8 i;\r\nu8 size = sizeof(region_code_mapping_t)/\r\nsizeof(struct region_code_mapping);\r\nfor (i = 0; i < size; i++)\r\nif (region_code_mapping_t[i].code == code)\r\nreturn region_code_mapping_t[i].region;\r\nreturn NULL;\r\n}\r\nu32 mwifiex_index_to_acs_data_rate(struct mwifiex_private *priv,\r\nu8 index, u8 ht_info)\r\n{\r\nu16 mcs_rate[4][16] = {\r\n{ 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,\r\n0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },\r\n{ 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,\r\n0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },\r\n{ 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,\r\n0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },\r\n{ 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,\r\n0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }\r\n};\r\nu16 ac_mcs_rate_nss1[8][10] = {\r\n{ 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,\r\n0x492, 0x57C, 0x618 },\r\n{ 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,\r\n0x514, 0x618, 0x6C6 },\r\n{ 0x3B, 0x75, 0xB0, 0xEA, 0x15F, 0x1D4, 0x20F,\r\n0x249, 0x2BE, 0x30C },\r\n{ 0x41, 0x82, 0xC3, 0x104, 0x186, 0x208, 0x249,\r\n0x28A, 0x30C, 0x363 },\r\n{ 0x1B, 0x36, 0x51, 0x6C, 0xA2, 0xD8, 0xF3,\r\n0x10E, 0x144, 0x168 },\r\n{ 0x1E, 0x3C, 0x5A, 0x78, 0xB4, 0xF0, 0x10E,\r\n0x12C, 0x168, 0x190 },\r\n{ 0xD, 0x1A, 0x27, 0x34, 0x4E, 0x68, 0x75, 0x82, 0x9C, 0x00 },\r\n{ 0xF, 0x1D, 0x2C, 0x3A, 0x57, 0x74, 0x82, 0x91, 0xAE, 0x00 },\r\n};\r\nu16 ac_mcs_rate_nss2[8][10] = {\r\n{ 0xEA, 0x1D4, 0x2BE, 0x3A8, 0x57C, 0x750, 0x83A,\r\n0x924, 0xAF8, 0xC30 },\r\n{ 0x104, 0x208, 0x30C, 0x410, 0x618, 0x820, 0x924,\r\n0xA28, 0xC30, 0xD8B },\r\n{ 0x75, 0xEA, 0x15F, 0x1D4, 0x2BE, 0x3A8, 0x41D,\r\n0x492, 0x57C, 0x618 },\r\n{ 0x82, 0x104, 0x186, 0x208, 0x30C, 0x410, 0x492,\r\n0x514, 0x618, 0x6C6 },\r\n{ 0x36, 0x6C, 0xA2, 0xD8, 0x144, 0x1B0, 0x1E6,\r\n0x21C, 0x288, 0x2D0 },\r\n{ 0x3C, 0x78, 0xB4, 0xF0, 0x168, 0x1E0, 0x21C,\r\n0x258, 0x2D0, 0x320 },\r\n{ 0x1A, 0x34, 0x4A, 0x68, 0x9C, 0xD0, 0xEA, 0x104,\r\n0x138, 0x00 },\r\n{ 0x1D, 0x3A, 0x57, 0x74, 0xAE, 0xE6, 0x104, 0x121,\r\n0x15B, 0x00 },\r\n};\r\nu32 rate = 0;\r\nu8 mcs_index = 0;\r\nu8 bw = 0;\r\nu8 gi = 0;\r\nif ((ht_info & 0x3) == MWIFIEX_RATE_FORMAT_VHT) {\r\nmcs_index = min(index & 0xF, 9);\r\nbw = (ht_info & 0xC) >> 2;\r\ngi = (ht_info & 0x10) >> 4;\r\nif ((index >> 4) == 1)\r\nrate = ac_mcs_rate_nss2[2 * (3 - bw) + gi][mcs_index];\r\nelse\r\nrate = ac_mcs_rate_nss1[2 * (3 - bw) + gi][mcs_index];\r\n} else if ((ht_info & 0x3) == MWIFIEX_RATE_FORMAT_HT) {\r\nbw = (ht_info & 0xC) >> 2;\r\ngi = (ht_info & 0x10) >> 4;\r\nif (index == MWIFIEX_RATE_BITMAP_MCS0) {\r\nif (gi == 1)\r\nrate = 0x0D;\r\nelse\r\nrate = 0x0C;\r\n} else if (index < 16) {\r\nif ((bw == 1) || (bw == 0))\r\nrate = mcs_rate[2 * (1 - bw) + gi][index];\r\nelse\r\nrate = mwifiex_data_rates[0];\r\n} else {\r\nrate = mwifiex_data_rates[0];\r\n}\r\n} else {\r\nif (index >= MWIFIEX_SUPPORTED_RATES_EXT)\r\nindex = 0;\r\nrate = mwifiex_data_rates[index];\r\n}\r\nreturn rate;\r\n}\r\nu32 mwifiex_index_to_data_rate(struct mwifiex_private *priv,\r\nu8 index, u8 ht_info)\r\n{\r\nu16 mcs_rate[4][16] = {\r\n{ 0x1b, 0x36, 0x51, 0x6c, 0xa2, 0xd8, 0xf3, 0x10e,\r\n0x36, 0x6c, 0xa2, 0xd8, 0x144, 0x1b0, 0x1e6, 0x21c },\r\n{ 0x1e, 0x3c, 0x5a, 0x78, 0xb4, 0xf0, 0x10e, 0x12c,\r\n0x3c, 0x78, 0xb4, 0xf0, 0x168, 0x1e0, 0x21c, 0x258 },\r\n{ 0x0d, 0x1a, 0x27, 0x34, 0x4e, 0x68, 0x75, 0x82,\r\n0x1a, 0x34, 0x4e, 0x68, 0x9c, 0xd0, 0xea, 0x104 },\r\n{ 0x0e, 0x1c, 0x2b, 0x39, 0x56, 0x73, 0x82, 0x90,\r\n0x1c, 0x39, 0x56, 0x73, 0xad, 0xe7, 0x104, 0x120 }\r\n};\r\nu32 mcs_num_supp =\r\n(priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2) ? 16 : 8;\r\nu32 rate;\r\nif (priv->adapter->is_hw_11ac_capable)\r\nreturn mwifiex_index_to_acs_data_rate(priv, index, ht_info);\r\nif (ht_info & BIT(0)) {\r\nif (index == MWIFIEX_RATE_BITMAP_MCS0) {\r\nif (ht_info & BIT(2))\r\nrate = 0x0D;\r\nelse\r\nrate = 0x0C;\r\n} else if (index < mcs_num_supp) {\r\nif (ht_info & BIT(1)) {\r\nif (ht_info & BIT(2))\r\nrate = mcs_rate[1][index];\r\nelse\r\nrate = mcs_rate[0][index];\r\n} else {\r\nif (ht_info & BIT(2))\r\nrate = mcs_rate[3][index];\r\nelse\r\nrate = mcs_rate[2][index];\r\n}\r\n} else\r\nrate = mwifiex_data_rates[0];\r\n} else {\r\nif (index >= MWIFIEX_SUPPORTED_RATES_EXT)\r\nindex = 0;\r\nrate = mwifiex_data_rates[index];\r\n}\r\nreturn rate;\r\n}\r\nu32 mwifiex_get_active_data_rates(struct mwifiex_private *priv, u8 *rates)\r\n{\r\nif (!priv->media_connected)\r\nreturn mwifiex_get_supported_rates(priv, rates);\r\nelse\r\nreturn mwifiex_copy_rates(rates, 0,\r\npriv->curr_bss_params.data_rates,\r\npriv->curr_bss_params.num_of_rates);\r\n}\r\nstruct mwifiex_chan_freq_power *\r\nmwifiex_get_cfp(struct mwifiex_private *priv, u8 band, u16 channel, u32 freq)\r\n{\r\nstruct mwifiex_chan_freq_power *cfp = NULL;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch = NULL;\r\nint i;\r\nif (!channel && !freq)\r\nreturn cfp;\r\nif (mwifiex_band_to_radio_type(band) == HostCmd_SCAN_RADIO_TYPE_BG)\r\nsband = priv->wdev->wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nsband = priv->wdev->wiphy->bands[IEEE80211_BAND_5GHZ];\r\nif (!sband) {\r\ndev_err(priv->adapter->dev, "%s: cannot find cfp by band %d\n",\r\n__func__, band);\r\nreturn cfp;\r\n}\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nch = &sband->channels[i];\r\nif (ch->flags & IEEE80211_CHAN_DISABLED)\r\ncontinue;\r\nif (freq) {\r\nif (ch->center_freq == freq)\r\nbreak;\r\n} else {\r\nif (ch->hw_value == channel ||\r\nchannel == FIRST_VALID_CHANNEL)\r\nbreak;\r\n}\r\n}\r\nif (i == sband->n_channels) {\r\ndev_err(priv->adapter->dev, "%s: cannot find cfp by band %d"\r\n" & channel=%d freq=%d\n", __func__, band, channel,\r\nfreq);\r\n} else {\r\nif (!ch)\r\nreturn cfp;\r\npriv->cfp.channel = ch->hw_value;\r\npriv->cfp.freq = ch->center_freq;\r\npriv->cfp.max_tx_power = ch->max_power;\r\ncfp = &priv->cfp;\r\n}\r\nreturn cfp;\r\n}\r\nu8\r\nmwifiex_is_rate_auto(struct mwifiex_private *priv)\r\n{\r\nu32 i;\r\nint rate_num = 0;\r\nfor (i = 0; i < ARRAY_SIZE(priv->bitmap_rates); i++)\r\nif (priv->bitmap_rates[i])\r\nrate_num++;\r\nif (rate_num > 1)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nu32 mwifiex_get_rates_from_cfg80211(struct mwifiex_private *priv,\r\nu8 *rates, u8 radio_type)\r\n{\r\nstruct wiphy *wiphy = priv->adapter->wiphy;\r\nstruct cfg80211_scan_request *request = priv->scan_request;\r\nu32 num_rates, rate_mask;\r\nstruct ieee80211_supported_band *sband;\r\nint i;\r\nif (radio_type) {\r\nsband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nif (WARN_ON_ONCE(!sband))\r\nreturn 0;\r\nrate_mask = request->rates[IEEE80211_BAND_5GHZ];\r\n} else {\r\nsband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (WARN_ON_ONCE(!sband))\r\nreturn 0;\r\nrate_mask = request->rates[IEEE80211_BAND_2GHZ];\r\n}\r\nnum_rates = 0;\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif ((BIT(i) & rate_mask) == 0)\r\ncontinue;\r\nrates[num_rates++] = (u8)(sband->bitrates[i].bitrate / 5);\r\n}\r\nreturn num_rates;\r\n}\r\nu32 mwifiex_get_supported_rates(struct mwifiex_private *priv, u8 *rates)\r\n{\r\nu32 k = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nif (priv->bss_mode == NL80211_IFTYPE_STATION ||\r\npriv->bss_mode == NL80211_IFTYPE_P2P_CLIENT) {\r\nswitch (adapter->config_bands) {\r\ncase BAND_B:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_b\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_b,\r\nsizeof(supported_rates_b));\r\nbreak;\r\ncase BAND_G:\r\ncase BAND_G | BAND_GN:\r\ncase BAND_G | BAND_GN | BAND_GAC:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_g\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_g,\r\nsizeof(supported_rates_g));\r\nbreak;\r\ncase BAND_B | BAND_G:\r\ncase BAND_A | BAND_B | BAND_G:\r\ncase BAND_A | BAND_B:\r\ncase BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN:\r\ncase BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC:\r\ncase BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN |\r\nBAND_AAC | BAND_GAC:\r\ncase BAND_B | BAND_G | BAND_GN:\r\ncase BAND_B | BAND_G | BAND_GN | BAND_GAC:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_bg\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_bg,\r\nsizeof(supported_rates_bg));\r\nbreak;\r\ncase BAND_A:\r\ncase BAND_A | BAND_G:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_a\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_a,\r\nsizeof(supported_rates_a));\r\nbreak;\r\ncase BAND_AN:\r\ncase BAND_A | BAND_AN:\r\ncase BAND_A | BAND_AN | BAND_AAC:\r\ncase BAND_A | BAND_G | BAND_AN | BAND_GN:\r\ncase BAND_A | BAND_G | BAND_AN | BAND_GN | BAND_AAC:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_a\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_a,\r\nsizeof(supported_rates_a));\r\nbreak;\r\ncase BAND_GN:\r\ncase BAND_GN | BAND_GAC:\r\ndev_dbg(adapter->dev, "info: infra band=%d "\r\n"supported_rates_n\n", adapter->config_bands);\r\nk = mwifiex_copy_rates(rates, k, supported_rates_n,\r\nsizeof(supported_rates_n));\r\nbreak;\r\n}\r\n} else {\r\nswitch (adapter->adhoc_start_band) {\r\ncase BAND_B:\r\ndev_dbg(adapter->dev, "info: adhoc B\n");\r\nk = mwifiex_copy_rates(rates, k, adhoc_rates_b,\r\nsizeof(adhoc_rates_b));\r\nbreak;\r\ncase BAND_G:\r\ncase BAND_G | BAND_GN:\r\ndev_dbg(adapter->dev, "info: adhoc G only\n");\r\nk = mwifiex_copy_rates(rates, k, adhoc_rates_g,\r\nsizeof(adhoc_rates_g));\r\nbreak;\r\ncase BAND_B | BAND_G:\r\ncase BAND_B | BAND_G | BAND_GN:\r\ndev_dbg(adapter->dev, "info: adhoc BG\n");\r\nk = mwifiex_copy_rates(rates, k, adhoc_rates_bg,\r\nsizeof(adhoc_rates_bg));\r\nbreak;\r\ncase BAND_A:\r\ncase BAND_A | BAND_AN:\r\ndev_dbg(adapter->dev, "info: adhoc A\n");\r\nk = mwifiex_copy_rates(rates, k, adhoc_rates_a,\r\nsizeof(adhoc_rates_a));\r\nbreak;\r\n}\r\n}\r\nreturn k;\r\n}
