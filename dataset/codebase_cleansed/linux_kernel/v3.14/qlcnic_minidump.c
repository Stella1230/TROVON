static u32 qlcnic_dump_crb(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i;\r\nu32 addr, data;\r\nstruct __crb *crb = &entry->region.crb;\r\naddr = crb->addr;\r\nfor (i = 0; i < crb->no_ops; i++) {\r\ndata = qlcnic_ind_rd(adapter, addr);\r\n*buffer++ = cpu_to_le32(addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += crb->stride;\r\n}\r\nreturn crb->no_ops * 2 * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_dump_ctrl(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i, k, timeout = 0;\r\nu32 addr, data;\r\nu8 no_ops;\r\nstruct __ctrl *ctr = &entry->region.ctrl;\r\nstruct qlcnic_dump_template_hdr *t_hdr = adapter->ahw->fw_dump.tmpl_hdr;\r\naddr = ctr->addr;\r\nno_ops = ctr->no_ops;\r\nfor (i = 0; i < no_ops; i++) {\r\nk = 0;\r\nfor (k = 0; k < 8; k++) {\r\nif (!(ctr->opcode & (1 << k)))\r\ncontinue;\r\nswitch (1 << k) {\r\ncase QLCNIC_DUMP_WCRB:\r\nqlcnic_ind_wr(adapter, addr, ctr->val1);\r\nbreak;\r\ncase QLCNIC_DUMP_RWCRB:\r\ndata = qlcnic_ind_rd(adapter, addr);\r\nqlcnic_ind_wr(adapter, addr, data);\r\nbreak;\r\ncase QLCNIC_DUMP_ANDCRB:\r\ndata = qlcnic_ind_rd(adapter, addr);\r\nqlcnic_ind_wr(adapter, addr,\r\n(data & ctr->val2));\r\nbreak;\r\ncase QLCNIC_DUMP_ORCRB:\r\ndata = qlcnic_ind_rd(adapter, addr);\r\nqlcnic_ind_wr(adapter, addr,\r\n(data | ctr->val3));\r\nbreak;\r\ncase QLCNIC_DUMP_POLLCRB:\r\nwhile (timeout <= ctr->timeout) {\r\ndata = qlcnic_ind_rd(adapter, addr);\r\nif ((data & ctr->val2) == ctr->val1)\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntimeout++;\r\n}\r\nif (timeout > ctr->timeout) {\r\ndev_info(&adapter->pdev->dev,\r\n"Timed out, aborting poll CRB\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase QLCNIC_DUMP_RD_SAVE:\r\nif (ctr->index_a)\r\naddr = t_hdr->saved_state[ctr->index_a];\r\ndata = qlcnic_ind_rd(adapter, addr);\r\nt_hdr->saved_state[ctr->index_v] = data;\r\nbreak;\r\ncase QLCNIC_DUMP_WRT_SAVED:\r\nif (ctr->index_v)\r\ndata = t_hdr->saved_state[ctr->index_v];\r\nelse\r\ndata = ctr->val1;\r\nif (ctr->index_a)\r\naddr = t_hdr->saved_state[ctr->index_a];\r\nqlcnic_ind_wr(adapter, addr, data);\r\nbreak;\r\ncase QLCNIC_DUMP_MOD_SAVE_ST:\r\ndata = t_hdr->saved_state[ctr->index_v];\r\ndata <<= ctr->shl_val;\r\ndata >>= ctr->shr_val;\r\nif (ctr->val2)\r\ndata &= ctr->val2;\r\ndata |= ctr->val3;\r\ndata += ctr->val1;\r\nt_hdr->saved_state[ctr->index_v] = data;\r\nbreak;\r\ndefault:\r\ndev_info(&adapter->pdev->dev,\r\n"Unknown opcode\n");\r\nbreak;\r\n}\r\n}\r\naddr += ctr->stride;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 qlcnic_dump_mux(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint loop;\r\nu32 val, data = 0;\r\nstruct __mux *mux = &entry->region.mux;\r\nval = mux->val;\r\nfor (loop = 0; loop < mux->no_ops; loop++) {\r\nqlcnic_ind_wr(adapter, mux->addr, val);\r\ndata = qlcnic_ind_rd(adapter, mux->read_addr);\r\n*buffer++ = cpu_to_le32(val);\r\n*buffer++ = cpu_to_le32(data);\r\nval += mux->val_stride;\r\n}\r\nreturn 2 * mux->no_ops * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_dump_que(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i, loop;\r\nu32 cnt, addr, data, que_id = 0;\r\nstruct __queue *que = &entry->region.que;\r\naddr = que->read_addr;\r\ncnt = que->read_addr_cnt;\r\nfor (loop = 0; loop < que->no_ops; loop++) {\r\nqlcnic_ind_wr(adapter, que->sel_addr, que_id);\r\naddr = que->read_addr;\r\nfor (i = 0; i < cnt; i++) {\r\ndata = qlcnic_ind_rd(adapter, addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += que->read_addr_stride;\r\n}\r\nque_id += que->stride;\r\n}\r\nreturn que->no_ops * cnt * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_dump_ocm(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i;\r\nu32 data;\r\nvoid __iomem *addr;\r\nstruct __ocm *ocm = &entry->region.ocm;\r\naddr = adapter->ahw->pci_base0 + ocm->read_addr;\r\nfor (i = 0; i < ocm->no_ops; i++) {\r\ndata = readl(addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += ocm->read_addr_stride;\r\n}\r\nreturn ocm->no_ops * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_read_rom(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i, count = 0;\r\nu32 fl_addr, size, val, lck_val, addr;\r\nstruct __mem *rom = &entry->region.mem;\r\nfl_addr = rom->addr;\r\nsize = rom->size / 4;\r\nlock_try:\r\nlck_val = QLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_LOCK);\r\nif (!lck_val && count < MAX_CTL_CHECK) {\r\nusleep_range(10000, 11000);\r\ncount++;\r\ngoto lock_try;\r\n}\r\nQLC_SHARED_REG_WR32(adapter, QLCNIC_FLASH_LOCK_OWNER,\r\nadapter->ahw->pci_func);\r\nfor (i = 0; i < size; i++) {\r\naddr = fl_addr & 0xFFFF0000;\r\nqlcnic_ind_wr(adapter, FLASH_ROM_WINDOW, addr);\r\naddr = LSW(fl_addr) + FLASH_ROM_DATA;\r\nval = qlcnic_ind_rd(adapter, addr);\r\nfl_addr += 4;\r\n*buffer++ = cpu_to_le32(val);\r\n}\r\nQLC_SHARED_REG_RD32(adapter, QLCNIC_FLASH_UNLOCK);\r\nreturn rom->size;\r\n}\r\nstatic u32 qlcnic_dump_l1_cache(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i;\r\nu32 cnt, val, data, addr;\r\nstruct __cache *l1 = &entry->region.cache;\r\nval = l1->init_tag_val;\r\nfor (i = 0; i < l1->no_ops; i++) {\r\nqlcnic_ind_wr(adapter, l1->addr, val);\r\nqlcnic_ind_wr(adapter, l1->ctrl_addr, LSW(l1->ctrl_val));\r\naddr = l1->read_addr;\r\ncnt = l1->read_addr_num;\r\nwhile (cnt) {\r\ndata = qlcnic_ind_rd(adapter, addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += l1->read_addr_stride;\r\ncnt--;\r\n}\r\nval += l1->stride;\r\n}\r\nreturn l1->no_ops * l1->read_addr_num * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_dump_l2_cache(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nint i;\r\nu32 cnt, val, data, addr;\r\nu8 poll_mask, poll_to, time_out = 0;\r\nstruct __cache *l2 = &entry->region.cache;\r\nval = l2->init_tag_val;\r\npoll_mask = LSB(MSW(l2->ctrl_val));\r\npoll_to = MSB(MSW(l2->ctrl_val));\r\nfor (i = 0; i < l2->no_ops; i++) {\r\nqlcnic_ind_wr(adapter, l2->addr, val);\r\nif (LSW(l2->ctrl_val))\r\nqlcnic_ind_wr(adapter, l2->ctrl_addr,\r\nLSW(l2->ctrl_val));\r\nif (!poll_mask)\r\ngoto skip_poll;\r\ndo {\r\ndata = qlcnic_ind_rd(adapter, l2->ctrl_addr);\r\nif (!(data & poll_mask))\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntime_out++;\r\n} while (time_out <= poll_to);\r\nif (time_out > poll_to) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout exceeded in %s, aborting dump\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nskip_poll:\r\naddr = l2->read_addr;\r\ncnt = l2->read_addr_num;\r\nwhile (cnt) {\r\ndata = qlcnic_ind_rd(adapter, addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += l2->read_addr_stride;\r\ncnt--;\r\n}\r\nval += l2->stride;\r\n}\r\nreturn l2->no_ops * l2->read_addr_num * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_read_memory_test_agent(struct qlcnic_adapter *adapter,\r\nstruct __mem *mem, __le32 *buffer,\r\nint *ret)\r\n{\r\nu32 addr, data, test;\r\nint i, reg_read;\r\nreg_read = mem->size;\r\naddr = mem->addr;\r\nif ((addr & 0xf) || (reg_read%16)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Unaligned memory addr:0x%x size:0x%x\n",\r\naddr, reg_read);\r\n*ret = -EINVAL;\r\nreturn 0;\r\n}\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwhile (reg_read != 0) {\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_LO, addr);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_ADDR_HI, 0);\r\nqlcnic_ind_wr(adapter, QLCNIC_MS_CTRL, QLCNIC_TA_START_ENABLE);\r\nfor (i = 0; i < MAX_CTL_CHECK; i++) {\r\ntest = qlcnic_ind_rd(adapter, QLCNIC_MS_CTRL);\r\nif (!(test & TA_CTL_BUSY))\r\nbreak;\r\n}\r\nif (i == MAX_CTL_CHECK) {\r\nif (printk_ratelimit()) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\n*ret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ndata = qlcnic_ind_rd(adapter, qlcnic_ms_read_data[i]);\r\n*buffer++ = cpu_to_le32(data);\r\n}\r\naddr += 16;\r\nreg_read -= 16;\r\nret += 16;\r\n}\r\nout:\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn mem->size;\r\n}\r\nstatic int qlcnic_start_pex_dma(struct qlcnic_adapter *adapter,\r\nstruct __mem *mem)\r\n{\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr;\r\nstruct device *dev = &adapter->pdev->dev;\r\nu32 dma_no, dma_base_addr, temp_addr;\r\nint i, ret, dma_sts;\r\ntmpl_hdr = adapter->ahw->fw_dump.tmpl_hdr;\r\ndma_no = tmpl_hdr->saved_state[QLC_83XX_DMA_ENGINE_INDEX];\r\ndma_base_addr = QLC_DMA_REG_BASE_ADDR(dma_no);\r\ntemp_addr = dma_base_addr + QLC_DMA_CMD_BUFF_ADDR_LOW;\r\nret = qlcnic_83xx_wrt_reg_indirect(adapter, temp_addr,\r\nmem->desc_card_addr);\r\nif (ret)\r\nreturn ret;\r\ntemp_addr = dma_base_addr + QLC_DMA_CMD_BUFF_ADDR_HI;\r\nret = qlcnic_83xx_wrt_reg_indirect(adapter, temp_addr, 0);\r\nif (ret)\r\nreturn ret;\r\ntemp_addr = dma_base_addr + QLC_DMA_CMD_STATUS_CTRL;\r\nret = qlcnic_83xx_wrt_reg_indirect(adapter, temp_addr,\r\nmem->start_dma_cmd);\r\nif (ret)\r\nreturn ret;\r\ntemp_addr = dma_base_addr + QLC_DMA_CMD_STATUS_CTRL;\r\nfor (i = 0; i < 400; i++) {\r\ndma_sts = qlcnic_ind_rd(adapter, temp_addr);\r\nif (dma_sts & BIT_1)\r\nusleep_range(250, 500);\r\nelse\r\nbreak;\r\n}\r\nif (i >= 400) {\r\ndev_info(dev, "PEX DMA operation timed out");\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 qlcnic_read_memory_pexdma(struct qlcnic_adapter *adapter,\r\nstruct __mem *mem,\r\n__le32 *buffer, int *ret)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nu32 temp, dma_base_addr, size = 0, read_size = 0;\r\nstruct qlcnic_pex_dma_descriptor *dma_descr;\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr;\r\nstruct device *dev = &adapter->pdev->dev;\r\ndma_addr_t dma_phys_addr;\r\nvoid *dma_buffer;\r\ntmpl_hdr = fw_dump->tmpl_hdr;\r\ntemp = tmpl_hdr->saved_state[QLC_83XX_DMA_ENGINE_INDEX];\r\ndma_base_addr = QLC_DMA_REG_BASE_ADDR(temp);\r\ntemp = qlcnic_ind_rd(adapter,\r\ndma_base_addr + QLC_DMA_CMD_STATUS_CTRL);\r\nif (!(temp & BIT_31)) {\r\ndev_info(dev, "%s: DMA engine is not available\n", __func__);\r\n*ret = -EIO;\r\nreturn 0;\r\n}\r\ndma_descr = kzalloc(sizeof(struct qlcnic_pex_dma_descriptor),\r\nGFP_KERNEL);\r\nif (!dma_descr) {\r\n*ret = -ENOMEM;\r\nreturn 0;\r\n}\r\ndma_phys_addr = fw_dump->phys_addr;\r\ndma_buffer = fw_dump->dma_buffer;\r\ntemp = 0;\r\ntemp = mem->dma_desc_cmd & 0xff0f;\r\ntemp |= (adapter->ahw->pci_func & 0xf) << 4;\r\ndma_descr->dma_desc_cmd = (temp << 16) & 0xffff0000;\r\ndma_descr->dma_bus_addr_low = LSD(dma_phys_addr);\r\ndma_descr->dma_bus_addr_high = MSD(dma_phys_addr);\r\ndma_descr->src_addr_high = 0;\r\nwhile (read_size < mem->size) {\r\nif (mem->size - read_size >= QLC_PEX_DMA_READ_SIZE)\r\nsize = QLC_PEX_DMA_READ_SIZE;\r\nelse\r\nsize = mem->size - read_size;\r\ndma_descr->src_addr_low = mem->addr + read_size;\r\ndma_descr->read_data_size = size;\r\ntemp = sizeof(struct qlcnic_pex_dma_descriptor) / 16;\r\n*ret = qlcnic_83xx_ms_mem_write128(adapter, mem->desc_card_addr,\r\n(u32 *)dma_descr, temp);\r\nif (*ret) {\r\ndev_info(dev, "Failed to write DMA descriptor to MS memory at address 0x%x\n",\r\nmem->desc_card_addr);\r\ngoto free_dma_descr;\r\n}\r\n*ret = qlcnic_start_pex_dma(adapter, mem);\r\nif (*ret) {\r\ndev_info(dev, "Failed to start PEX DMA operation\n");\r\ngoto free_dma_descr;\r\n}\r\nmemcpy(buffer, dma_buffer, size);\r\nbuffer += size / 4;\r\nread_size += size;\r\n}\r\nfree_dma_descr:\r\nkfree(dma_descr);\r\nreturn read_size;\r\n}\r\nstatic u32 qlcnic_read_memory(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct __mem *mem = &entry->region.mem;\r\nu32 data_size;\r\nint ret = 0;\r\nif (fw_dump->use_pex_dma) {\r\ndata_size = qlcnic_read_memory_pexdma(adapter, mem, buffer,\r\n&ret);\r\nif (ret)\r\ndev_info(dev,\r\n"Failed to read memory dump using PEX DMA: mask[0x%x]\n",\r\nentry->hdr.mask);\r\nelse\r\nreturn data_size;\r\n}\r\ndata_size = qlcnic_read_memory_test_agent(adapter, mem, buffer, &ret);\r\nif (ret) {\r\ndev_info(dev,\r\n"Failed to read memory dump using test agent method: mask[0x%x]\n",\r\nentry->hdr.mask);\r\nreturn 0;\r\n} else {\r\nreturn data_size;\r\n}\r\n}\r\nstatic u32 qlcnic_dump_nop(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_valid_dump_entry(struct device *dev,\r\nstruct qlcnic_dump_entry *entry, u32 size)\r\n{\r\nint ret = 1;\r\nif (size != entry->hdr.cap_size) {\r\ndev_err(dev,\r\n"Invalid entry, Type:%d\tMask:%d\tSize:%dCap_size:%d\n",\r\nentry->hdr.type, entry->hdr.mask, size,\r\nentry->hdr.cap_size);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 qlcnic_read_pollrdmwr(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry,\r\n__le32 *buffer)\r\n{\r\nstruct __pollrdmwr *poll = &entry->region.pollrdmwr;\r\nu32 data, wait_count, poll_wait, temp;\r\npoll_wait = poll->poll_wait;\r\nqlcnic_ind_wr(adapter, poll->addr1, poll->val1);\r\nwait_count = 0;\r\nwhile (wait_count < poll_wait) {\r\ndata = qlcnic_ind_rd(adapter, poll->addr1);\r\nif ((data & poll->poll_mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll_wait) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout exceeded in %s, aborting dump\n",\r\n__func__);\r\nreturn 0;\r\n}\r\ndata = qlcnic_ind_rd(adapter, poll->addr2) & poll->mod_mask;\r\nqlcnic_ind_wr(adapter, poll->addr2, data);\r\nqlcnic_ind_wr(adapter, poll->addr1, poll->val2);\r\nwait_count = 0;\r\nwhile (wait_count < poll_wait) {\r\ntemp = qlcnic_ind_rd(adapter, poll->addr1);\r\nif ((temp & poll->poll_mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\n*buffer++ = cpu_to_le32(poll->addr2);\r\n*buffer++ = cpu_to_le32(data);\r\nreturn 2 * sizeof(u32);\r\n}\r\nstatic u32 qlcnic_read_pollrd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nstruct __pollrd *pollrd = &entry->region.pollrd;\r\nu32 data, wait_count, poll_wait, sel_val;\r\nint i;\r\npoll_wait = pollrd->poll_wait;\r\nsel_val = pollrd->sel_val;\r\nfor (i = 0; i < pollrd->no_ops; i++) {\r\nqlcnic_ind_wr(adapter, pollrd->sel_addr, sel_val);\r\nwait_count = 0;\r\nwhile (wait_count < poll_wait) {\r\ndata = qlcnic_ind_rd(adapter, pollrd->sel_addr);\r\nif ((data & pollrd->poll_mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll_wait) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout exceeded in %s, aborting dump\n",\r\n__func__);\r\nreturn 0;\r\n}\r\ndata = qlcnic_ind_rd(adapter, pollrd->read_addr);\r\n*buffer++ = cpu_to_le32(sel_val);\r\n*buffer++ = cpu_to_le32(data);\r\nsel_val += pollrd->sel_val_stride;\r\n}\r\nreturn pollrd->no_ops * (2 * sizeof(u32));\r\n}\r\nstatic u32 qlcnic_read_mux2(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nstruct __mux2 *mux2 = &entry->region.mux2;\r\nu32 data;\r\nu32 t_sel_val, sel_val1, sel_val2;\r\nint i;\r\nsel_val1 = mux2->sel_val1;\r\nsel_val2 = mux2->sel_val2;\r\nfor (i = 0; i < mux2->no_ops; i++) {\r\nqlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val1);\r\nt_sel_val = sel_val1 & mux2->sel_val_mask;\r\nqlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);\r\ndata = qlcnic_ind_rd(adapter, mux2->read_addr);\r\n*buffer++ = cpu_to_le32(t_sel_val);\r\n*buffer++ = cpu_to_le32(data);\r\nqlcnic_ind_wr(adapter, mux2->sel_addr1, sel_val2);\r\nt_sel_val = sel_val2 & mux2->sel_val_mask;\r\nqlcnic_ind_wr(adapter, mux2->sel_addr2, t_sel_val);\r\ndata = qlcnic_ind_rd(adapter, mux2->read_addr);\r\n*buffer++ = cpu_to_le32(t_sel_val);\r\n*buffer++ = cpu_to_le32(data);\r\nsel_val1 += mux2->sel_val_stride;\r\nsel_val2 += mux2->sel_val_stride;\r\n}\r\nreturn mux2->no_ops * (4 * sizeof(u32));\r\n}\r\nstatic u32 qlcnic_83xx_dump_rom(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, __le32 *buffer)\r\n{\r\nu32 fl_addr, size;\r\nstruct __mem *rom = &entry->region.mem;\r\nfl_addr = rom->addr;\r\nsize = rom->size / 4;\r\nif (!qlcnic_83xx_lockless_flash_read32(adapter, fl_addr,\r\n(u8 *)buffer, size))\r\nreturn rom->size;\r\nreturn 0;\r\n}\r\nstatic uint32_t qlcnic_temp_checksum(uint32_t *temp_buffer, u32 temp_size)\r\n{\r\nuint64_t sum = 0;\r\nint count = temp_size / sizeof(uint32_t);\r\nwhile (count-- > 0)\r\nsum += *temp_buffer++;\r\nwhile (sum >> 32)\r\nsum = (sum & 0xFFFFFFFF) + (sum >> 32);\r\nreturn ~sum;\r\n}\r\nstatic int qlcnic_fw_flash_get_minidump_temp(struct qlcnic_adapter *adapter,\r\nu8 *buffer, u32 size)\r\n{\r\nint ret = 0;\r\nif (qlcnic_82xx_check(adapter))\r\nreturn -EIO;\r\nif (qlcnic_83xx_lock_flash(adapter))\r\nreturn -EIO;\r\nret = qlcnic_83xx_lockless_flash_read32(adapter,\r\nQLC_83XX_MINIDUMP_FLASH,\r\nbuffer, size / sizeof(u32));\r\nqlcnic_83xx_unlock_flash(adapter);\r\nreturn ret;\r\n}\r\nstatic int\r\nqlcnic_fw_flash_get_minidump_temp_size(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_dump_template_hdr tmp_hdr;\r\nu32 size = sizeof(struct qlcnic_dump_template_hdr) / sizeof(u32);\r\nint ret = 0;\r\nif (qlcnic_82xx_check(adapter))\r\nreturn -EIO;\r\nif (qlcnic_83xx_lock_flash(adapter))\r\nreturn -EIO;\r\nret = qlcnic_83xx_lockless_flash_read32(adapter,\r\nQLC_83XX_MINIDUMP_FLASH,\r\n(u8 *)&tmp_hdr, size);\r\nqlcnic_83xx_unlock_flash(adapter);\r\ncmd->rsp.arg[2] = tmp_hdr.size;\r\ncmd->rsp.arg[3] = tmp_hdr.version;\r\nreturn ret;\r\n}\r\nstatic int qlcnic_fw_get_minidump_temp_size(struct qlcnic_adapter *adapter,\r\nu32 *version, u32 *temp_size,\r\nu8 *use_flash_temp)\r\n{\r\nint err = 0;\r\nstruct qlcnic_cmd_args cmd;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_TEMP_SIZE))\r\nreturn -ENOMEM;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\nif (qlcnic_fw_flash_get_minidump_temp_size(adapter, &cmd)) {\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn -EIO;\r\n}\r\n*use_flash_temp = 1;\r\n}\r\n*temp_size = cmd.rsp.arg[2];\r\n*version = cmd.rsp.arg[3];\r\nqlcnic_free_mbx_args(&cmd);\r\nif (!(*temp_size))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int __qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter,\r\nu32 *buffer, u32 temp_size)\r\n{\r\nint err = 0, i;\r\nvoid *tmp_addr;\r\n__le32 *tmp_buf;\r\nstruct qlcnic_cmd_args cmd;\r\ndma_addr_t tmp_addr_t = 0;\r\ntmp_addr = dma_alloc_coherent(&adapter->pdev->dev, temp_size,\r\n&tmp_addr_t, GFP_KERNEL);\r\nif (!tmp_addr)\r\nreturn -ENOMEM;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_TEMP_HDR)) {\r\nerr = -ENOMEM;\r\ngoto free_mem;\r\n}\r\ncmd.req.arg[1] = LSD(tmp_addr_t);\r\ncmd.req.arg[2] = MSD(tmp_addr_t);\r\ncmd.req.arg[3] = temp_size;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\ntmp_buf = tmp_addr;\r\nif (err == QLCNIC_RCODE_SUCCESS) {\r\nfor (i = 0; i < temp_size / sizeof(u32); i++)\r\n*buffer++ = __le32_to_cpu(*tmp_buf++);\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nfree_mem:\r\ndma_free_coherent(&adapter->pdev->dev, temp_size, tmp_addr, tmp_addr_t);\r\nreturn err;\r\n}\r\nint qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter)\r\n{\r\nint err;\r\nu32 temp_size = 0;\r\nu32 version, csum, *tmp_buf;\r\nstruct qlcnic_hardware_context *ahw;\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr;\r\nu8 use_flash_temp = 0;\r\nahw = adapter->ahw;\r\nerr = qlcnic_fw_get_minidump_temp_size(adapter, &version, &temp_size,\r\n&use_flash_temp);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Can't get template size %d\n", err);\r\nreturn -EIO;\r\n}\r\nahw->fw_dump.tmpl_hdr = vzalloc(temp_size);\r\nif (!ahw->fw_dump.tmpl_hdr)\r\nreturn -ENOMEM;\r\ntmp_buf = (u32 *)ahw->fw_dump.tmpl_hdr;\r\nif (use_flash_temp)\r\ngoto flash_temp;\r\nerr = __qlcnic_fw_cmd_get_minidump_temp(adapter, tmp_buf, temp_size);\r\nif (err) {\r\nflash_temp:\r\nerr = qlcnic_fw_flash_get_minidump_temp(adapter, (u8 *)tmp_buf,\r\ntemp_size);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get minidump template header %d\n",\r\nerr);\r\nvfree(ahw->fw_dump.tmpl_hdr);\r\nahw->fw_dump.tmpl_hdr = NULL;\r\nreturn -EIO;\r\n}\r\n}\r\ncsum = qlcnic_temp_checksum((uint32_t *)tmp_buf, temp_size);\r\nif (csum) {\r\ndev_err(&adapter->pdev->dev,\r\n"Template header checksum validation failed\n");\r\nvfree(ahw->fw_dump.tmpl_hdr);\r\nahw->fw_dump.tmpl_hdr = NULL;\r\nreturn -EIO;\r\n}\r\ntmpl_hdr = ahw->fw_dump.tmpl_hdr;\r\ntmpl_hdr->drv_cap_mask = tmpl_hdr->cap_mask;\r\ndev_info(&adapter->pdev->dev,\r\n"Default minidump capture mask 0x%x\n",\r\ntmpl_hdr->cap_mask);\r\nif ((tmpl_hdr->version & 0xfffff) >= 0x20001)\r\nahw->fw_dump.use_pex_dma = true;\r\nelse\r\nahw->fw_dump.use_pex_dma = false;\r\nqlcnic_enable_fw_dump_state(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_dump_fw(struct qlcnic_adapter *adapter)\r\n{\r\n__le32 *buffer;\r\nu32 ocm_window;\r\nchar mesg[64];\r\nchar *msg[] = {mesg, NULL};\r\nint i, k, ops_cnt, ops_index, dump_size = 0;\r\nu32 entry_offset, dump, no_entries, buf_offset = 0;\r\nstruct qlcnic_dump_entry *entry;\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr = fw_dump->tmpl_hdr;\r\nstatic const struct qlcnic_dump_operations *fw_dump_ops;\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct qlcnic_hardware_context *ahw;\r\nvoid *temp_buffer;\r\nahw = adapter->ahw;\r\nif (!tmpl_hdr)\r\nreturn -EIO;\r\nif (!qlcnic_check_fw_dump_state(adapter)) {\r\ndev_info(&adapter->pdev->dev, "Dump not enabled\n");\r\nreturn -EIO;\r\n}\r\nif (fw_dump->clr) {\r\ndev_info(&adapter->pdev->dev,\r\n"Previous dump not cleared, not capturing dump\n");\r\nreturn -EIO;\r\n}\r\nnetif_info(adapter->ahw, drv, adapter->netdev, "Take FW dump\n");\r\nfor (i = 2, k = 1; (i & QLCNIC_DUMP_MASK_MAX); i <<= 1, k++)\r\nif (i & tmpl_hdr->drv_cap_mask)\r\ndump_size += tmpl_hdr->cap_sizes[k];\r\nif (!dump_size)\r\nreturn -EIO;\r\nfw_dump->data = vzalloc(dump_size);\r\nif (!fw_dump->data)\r\nreturn -ENOMEM;\r\nbuffer = fw_dump->data;\r\nfw_dump->size = dump_size;\r\nno_entries = tmpl_hdr->num_entries;\r\nentry_offset = tmpl_hdr->offset;\r\ntmpl_hdr->sys_info[0] = QLCNIC_DRIVER_VERSION;\r\ntmpl_hdr->sys_info[1] = adapter->fw_version;\r\nif (fw_dump->use_pex_dma) {\r\ntemp_buffer = dma_alloc_coherent(dev, QLC_PEX_DMA_READ_SIZE,\r\n&fw_dump->phys_addr,\r\nGFP_KERNEL);\r\nif (!temp_buffer)\r\nfw_dump->use_pex_dma = false;\r\nelse\r\nfw_dump->dma_buffer = temp_buffer;\r\n}\r\nif (qlcnic_82xx_check(adapter)) {\r\nops_cnt = ARRAY_SIZE(qlcnic_fw_dump_ops);\r\nfw_dump_ops = qlcnic_fw_dump_ops;\r\n} else {\r\nops_cnt = ARRAY_SIZE(qlcnic_83xx_fw_dump_ops);\r\nfw_dump_ops = qlcnic_83xx_fw_dump_ops;\r\nocm_window = tmpl_hdr->ocm_wnd_reg[adapter->ahw->pci_func];\r\ntmpl_hdr->saved_state[QLC_83XX_OCM_INDEX] = ocm_window;\r\ntmpl_hdr->saved_state[QLC_83XX_PCI_INDEX] = ahw->pci_func;\r\n}\r\nfor (i = 0; i < no_entries; i++) {\r\nentry = (void *)tmpl_hdr + entry_offset;\r\nif (!(entry->hdr.mask & tmpl_hdr->drv_cap_mask)) {\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nentry_offset += entry->hdr.offset;\r\ncontinue;\r\n}\r\nops_index = 0;\r\nwhile (ops_index < ops_cnt) {\r\nif (entry->hdr.type == fw_dump_ops[ops_index].opcode)\r\nbreak;\r\nops_index++;\r\n}\r\nif (ops_index == ops_cnt) {\r\ndev_info(dev, "Skipping unknown entry opcode %d\n",\r\nentry->hdr.type);\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nentry_offset += entry->hdr.offset;\r\ncontinue;\r\n}\r\ndump = fw_dump_ops[ops_index].handler(adapter, entry, buffer);\r\nif (!qlcnic_valid_dump_entry(dev, entry, dump)) {\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nentry_offset += entry->hdr.offset;\r\ncontinue;\r\n}\r\nbuf_offset += entry->hdr.cap_size;\r\nentry_offset += entry->hdr.offset;\r\nbuffer = fw_dump->data + buf_offset;\r\n}\r\nfw_dump->clr = 1;\r\nsnprintf(mesg, sizeof(mesg), "FW_DUMP=%s", adapter->netdev->name);\r\ndev_info(dev, "%s: Dump data %d bytes captured, template header size %d bytes\n",\r\nadapter->netdev->name, fw_dump->size, tmpl_hdr->size);\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, msg);\r\nif (fw_dump->use_pex_dma)\r\ndma_free_coherent(dev, QLC_PEX_DMA_READ_SIZE,\r\nfw_dump->dma_buffer, fw_dump->phys_addr);\r\nreturn 0;\r\n}\r\nvoid qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter)\r\n{\r\nu32 prev_version, current_version;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_fw_dump *fw_dump = &ahw->fw_dump;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nprev_version = adapter->fw_version;\r\ncurrent_version = qlcnic_83xx_get_fw_version(adapter);\r\nif (fw_dump->tmpl_hdr == NULL || current_version > prev_version) {\r\nif (fw_dump->tmpl_hdr)\r\nvfree(fw_dump->tmpl_hdr);\r\nif (!qlcnic_fw_cmd_get_minidump_temp(adapter))\r\ndev_info(&pdev->dev, "Supports FW dump capability\n");\r\n}\r\n}
