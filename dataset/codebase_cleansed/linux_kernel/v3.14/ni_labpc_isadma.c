static unsigned int labpc_suggest_transfer_size(const struct comedi_cmd *cmd)\r\n{\r\nunsigned int size;\r\nunsigned int freq;\r\nif (cmd->convert_src == TRIG_TIMER)\r\nfreq = 1000000000 / cmd->convert_arg;\r\nelse\r\nfreq = 0xffffffff;\r\nsize = (freq / 3) * sample_size;\r\nif (size > dma_buffer_size)\r\nsize = dma_buffer_size - dma_buffer_size % sample_size;\r\nelse if (size < sample_size)\r\nsize = sample_size;\r\nreturn size;\r\n}\r\nvoid labpc_setup_dma(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long irq_flags;\r\nirq_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\nset_dma_addr(devpriv->dma_chan, devpriv->dma_addr);\r\ndevpriv->dma_transfer_size = labpc_suggest_transfer_size(cmd);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ndevpriv->count * sample_size < devpriv->dma_transfer_size)\r\ndevpriv->dma_transfer_size = devpriv->count * sample_size;\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\nrelease_dma_lock(irq_flags);\r\ndevpriv->cmd3 |= (CMD3_DMAEN | CMD3_DMATCINTEN);\r\n}\r\nvoid labpc_drain_dma(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nint status;\r\nunsigned long flags;\r\nunsigned int max_points, num_points, residue, leftover;\r\nint i;\r\nstatus = devpriv->stat1;\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\nmax_points = devpriv->dma_transfer_size / sample_size;\r\nresidue = get_dma_residue(devpriv->dma_chan) / sample_size;\r\nnum_points = max_points - residue;\r\nif (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)\r\nnum_points = devpriv->count;\r\nleftover = 0;\r\nif (async->cmd.stop_src != TRIG_COUNT) {\r\nleftover = devpriv->dma_transfer_size / sample_size;\r\n} else if (devpriv->count > num_points) {\r\nleftover = devpriv->count - num_points;\r\nif (leftover > max_points)\r\nleftover = max_points;\r\n}\r\nfor (i = 0; i < num_points; i++)\r\ncfc_write_to_buffer(s, devpriv->dma_buffer[i]);\r\nif (async->cmd.stop_src == TRIG_COUNT)\r\ndevpriv->count -= num_points;\r\nset_dma_addr(devpriv->dma_chan, devpriv->dma_addr);\r\nset_dma_count(devpriv->dma_chan, leftover * sample_size);\r\nrelease_dma_lock(flags);\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\nstatic void handle_isa_dma(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nlabpc_drain_dma(dev);\r\nenable_dma(devpriv->dma_chan);\r\ndevpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);\r\n}\r\nvoid labpc_handle_dma_status(struct comedi_device *dev)\r\n{\r\nconst struct labpc_boardinfo *board = comedi_board(dev);\r\nstruct labpc_private *devpriv = dev->private;\r\nif (devpriv->stat1 & STAT1_GATA0 ||\r\n(board->is_labpc1200 && devpriv->stat2 & STAT2_OUTA1))\r\nhandle_isa_dma(dev);\r\n}\r\nint labpc_init_dma_chan(struct comedi_device *dev, unsigned int dma_chan)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nvoid *dma_buffer;\r\nunsigned long dma_flags;\r\nint ret;\r\nif (dma_chan != 1 && dma_chan != 3)\r\nreturn -EINVAL;\r\ndma_buffer = kmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);\r\nif (!dma_buffer)\r\nreturn -ENOMEM;\r\nret = request_dma(dma_chan, dev->board_name);\r\nif (ret) {\r\nkfree(dma_buffer);\r\nreturn ret;\r\n}\r\ndevpriv->dma_buffer = dma_buffer;\r\ndevpriv->dma_chan = dma_chan;\r\ndevpriv->dma_addr = virt_to_bus(devpriv->dma_buffer);\r\ndma_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nset_dma_mode(devpriv->dma_chan, DMA_MODE_READ);\r\nrelease_dma_lock(dma_flags);\r\nreturn 0;\r\n}\r\nvoid labpc_free_dma_chan(struct comedi_device *dev)\r\n{\r\nstruct labpc_private *devpriv = dev->private;\r\nkfree(devpriv->dma_buffer);\r\ndevpriv->dma_buffer = NULL;\r\nif (devpriv->dma_chan) {\r\nfree_dma(devpriv->dma_chan);\r\ndevpriv->dma_chan = 0;\r\n}\r\n}\r\nstatic int __init ni_labpc_isadma_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ni_labpc_isadma_cleanup_module(void)\r\n{\r\n}
