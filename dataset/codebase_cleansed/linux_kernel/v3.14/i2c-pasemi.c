static inline void reg_write(struct pasemi_smbus *smbus, int reg, int val)\r\n{\r\ndev_dbg(&smbus->dev->dev, "smbus write reg %lx val %08x\n",\r\nsmbus->base + reg, val);\r\noutl(val, smbus->base + reg);\r\n}\r\nstatic inline int reg_read(struct pasemi_smbus *smbus, int reg)\r\n{\r\nint ret;\r\nret = inl(smbus->base + reg);\r\ndev_dbg(&smbus->dev->dev, "smbus read reg %lx val %08x\n",\r\nsmbus->base + reg, ret);\r\nreturn ret;\r\n}\r\nstatic void pasemi_smb_clear(struct pasemi_smbus *smbus)\r\n{\r\nunsigned int status;\r\nstatus = reg_read(smbus, REG_SMSTA);\r\nreg_write(smbus, REG_SMSTA, status);\r\n}\r\nstatic int pasemi_smb_waitready(struct pasemi_smbus *smbus)\r\n{\r\nint timeout = 10;\r\nunsigned int status;\r\nstatus = reg_read(smbus, REG_SMSTA);\r\nwhile (!(status & SMSTA_XEN) && timeout--) {\r\nmsleep(1);\r\nstatus = reg_read(smbus, REG_SMSTA);\r\n}\r\nif (status & SMSTA_MTN)\r\nreturn -ENXIO;\r\nif (timeout < 0) {\r\ndev_warn(&smbus->dev->dev, "Timeout, status 0x%08x\n", status);\r\nreg_write(smbus, REG_SMSTA, status);\r\nreturn -ETIME;\r\n}\r\nreg_write(smbus, REG_SMSTA, SMSTA_XEN);\r\nreturn 0;\r\n}\r\nstatic int pasemi_i2c_xfer_msg(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msg, int stop)\r\n{\r\nstruct pasemi_smbus *smbus = adapter->algo_data;\r\nint read, i, err;\r\nu32 rd;\r\nread = msg->flags & I2C_M_RD ? 1 : 0;\r\nTXFIFO_WR(smbus, MTXFIFO_START | (msg->addr << 1) | read);\r\nif (read) {\r\nTXFIFO_WR(smbus, msg->len | MTXFIFO_READ |\r\n(stop ? MTXFIFO_STOP : 0));\r\nerr = pasemi_smb_waitready(smbus);\r\nif (err)\r\ngoto reset_out;\r\nfor (i = 0; i < msg->len; i++) {\r\nrd = RXFIFO_RD(smbus);\r\nif (rd & MRXFIFO_EMPTY) {\r\nerr = -ENODATA;\r\ngoto reset_out;\r\n}\r\nmsg->buf[i] = rd & MRXFIFO_DATA_M;\r\n}\r\n} else {\r\nfor (i = 0; i < msg->len - 1; i++)\r\nTXFIFO_WR(smbus, msg->buf[i]);\r\nTXFIFO_WR(smbus, msg->buf[msg->len-1] |\r\n(stop ? MTXFIFO_STOP : 0));\r\n}\r\nreturn 0;\r\nreset_out:\r\nreg_write(smbus, REG_CTL, (CTL_MTR | CTL_MRR |\r\n(CLK_100K_DIV & CTL_CLK_M)));\r\nreturn err;\r\n}\r\nstatic int pasemi_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct pasemi_smbus *smbus = adapter->algo_data;\r\nint ret, i;\r\npasemi_smb_clear(smbus);\r\nret = 0;\r\nfor (i = 0; i < num && !ret; i++)\r\nret = pasemi_i2c_xfer_msg(adapter, &msgs[i], (i == (num - 1)));\r\nreturn ret ? ret : num;\r\n}\r\nstatic int pasemi_smb_xfer(struct i2c_adapter *adapter,\r\nu16 addr, unsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct pasemi_smbus *smbus = adapter->algo_data;\r\nunsigned int rd;\r\nint read_flag, err;\r\nint len = 0, i;\r\naddr <<= 1;\r\nread_flag = read_write == I2C_SMBUS_READ;\r\npasemi_smb_clear(smbus);\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nTXFIFO_WR(smbus, addr | read_flag | MTXFIFO_START |\r\nMTXFIFO_STOP);\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nTXFIFO_WR(smbus, addr | read_flag | MTXFIFO_START);\r\nif (read_write)\r\nTXFIFO_WR(smbus, 1 | MTXFIFO_STOP | MTXFIFO_READ);\r\nelse\r\nTXFIFO_WR(smbus, MTXFIFO_STOP | command);\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nTXFIFO_WR(smbus, addr | MTXFIFO_START);\r\nTXFIFO_WR(smbus, command);\r\nif (read_write) {\r\nTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\r\nTXFIFO_WR(smbus, 1 | MTXFIFO_READ | MTXFIFO_STOP);\r\n} else {\r\nTXFIFO_WR(smbus, MTXFIFO_STOP | data->byte);\r\n}\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nTXFIFO_WR(smbus, addr | MTXFIFO_START);\r\nTXFIFO_WR(smbus, command);\r\nif (read_write) {\r\nTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\r\nTXFIFO_WR(smbus, 2 | MTXFIFO_READ | MTXFIFO_STOP);\r\n} else {\r\nTXFIFO_WR(smbus, data->word & MTXFIFO_DATA_M);\r\nTXFIFO_WR(smbus, MTXFIFO_STOP | (data->word >> 8));\r\n}\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nTXFIFO_WR(smbus, addr | MTXFIFO_START);\r\nTXFIFO_WR(smbus, command);\r\nif (read_write) {\r\nTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\r\nTXFIFO_WR(smbus, 1 | MTXFIFO_READ);\r\nrd = RXFIFO_RD(smbus);\r\nlen = min_t(u8, (rd & MRXFIFO_DATA_M),\r\nI2C_SMBUS_BLOCK_MAX);\r\nTXFIFO_WR(smbus, len | MTXFIFO_READ |\r\nMTXFIFO_STOP);\r\n} else {\r\nlen = min_t(u8, data->block[0], I2C_SMBUS_BLOCK_MAX);\r\nTXFIFO_WR(smbus, len);\r\nfor (i = 1; i < len; i++)\r\nTXFIFO_WR(smbus, data->block[i]);\r\nTXFIFO_WR(smbus, data->block[len] | MTXFIFO_STOP);\r\n}\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\nread_write = I2C_SMBUS_READ;\r\nTXFIFO_WR(smbus, addr | MTXFIFO_START);\r\nTXFIFO_WR(smbus, command);\r\nTXFIFO_WR(smbus, data->word & MTXFIFO_DATA_M);\r\nTXFIFO_WR(smbus, (data->word >> 8) & MTXFIFO_DATA_M);\r\nTXFIFO_WR(smbus, addr | I2C_SMBUS_READ | MTXFIFO_START);\r\nTXFIFO_WR(smbus, 2 | MTXFIFO_STOP | MTXFIFO_READ);\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nlen = min_t(u8, data->block[0], I2C_SMBUS_BLOCK_MAX - 1);\r\nread_write = I2C_SMBUS_READ;\r\nTXFIFO_WR(smbus, addr | MTXFIFO_START);\r\nTXFIFO_WR(smbus, command);\r\nTXFIFO_WR(smbus, len);\r\nfor (i = 1; i <= len; i++)\r\nTXFIFO_WR(smbus, data->block[i]);\r\nTXFIFO_WR(smbus, addr | I2C_SMBUS_READ);\r\nTXFIFO_WR(smbus, MTXFIFO_READ | 1);\r\nrd = RXFIFO_RD(smbus);\r\nlen = min_t(u8, (rd & MRXFIFO_DATA_M),\r\nI2C_SMBUS_BLOCK_MAX - len);\r\nTXFIFO_WR(smbus, len | MTXFIFO_READ | MTXFIFO_STOP);\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->dev, "Unsupported transaction %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nerr = pasemi_smb_waitready(smbus);\r\nif (err)\r\ngoto reset_out;\r\nif (read_write == I2C_SMBUS_WRITE)\r\nreturn 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\nrd = RXFIFO_RD(smbus);\r\nif (rd & MRXFIFO_EMPTY) {\r\nerr = -ENODATA;\r\ngoto reset_out;\r\n}\r\ndata->byte = rd & MRXFIFO_DATA_M;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\nrd = RXFIFO_RD(smbus);\r\nif (rd & MRXFIFO_EMPTY) {\r\nerr = -ENODATA;\r\ngoto reset_out;\r\n}\r\ndata->word = rd & MRXFIFO_DATA_M;\r\nrd = RXFIFO_RD(smbus);\r\nif (rd & MRXFIFO_EMPTY) {\r\nerr = -ENODATA;\r\ngoto reset_out;\r\n}\r\ndata->word |= (rd & MRXFIFO_DATA_M) << 8;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\ndata->block[0] = len;\r\nfor (i = 1; i <= len; i ++) {\r\nrd = RXFIFO_RD(smbus);\r\nif (rd & MRXFIFO_EMPTY) {\r\nerr = -ENODATA;\r\ngoto reset_out;\r\n}\r\ndata->block[i] = rd & MRXFIFO_DATA_M;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\nreset_out:\r\nreg_write(smbus, REG_CTL, (CTL_MTR | CTL_MRR |\r\n(CLK_100K_DIV & CTL_CLK_M)));\r\nreturn err;\r\n}\r\nstatic u32 pasemi_smb_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_SMBUS_BLOCK_PROC_CALL | I2C_FUNC_I2C;\r\n}\r\nstatic int pasemi_smb_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct pasemi_smbus *smbus;\r\nint error;\r\nif (!(pci_resource_flags(dev, 0) & IORESOURCE_IO))\r\nreturn -ENODEV;\r\nsmbus = kzalloc(sizeof(struct pasemi_smbus), GFP_KERNEL);\r\nif (!smbus)\r\nreturn -ENOMEM;\r\nsmbus->dev = dev;\r\nsmbus->base = pci_resource_start(dev, 0);\r\nsmbus->size = pci_resource_len(dev, 0);\r\nif (!request_region(smbus->base, smbus->size,\r\npasemi_smb_driver.name)) {\r\nerror = -EBUSY;\r\ngoto out_kfree;\r\n}\r\nsmbus->adapter.owner = THIS_MODULE;\r\nsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\r\n"PA Semi SMBus adapter at 0x%lx", smbus->base);\r\nsmbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nsmbus->adapter.algo = &smbus_algorithm;\r\nsmbus->adapter.algo_data = smbus;\r\nsmbus->adapter.nr = PCI_FUNC(dev->devfn);\r\nsmbus->adapter.dev.parent = &dev->dev;\r\nreg_write(smbus, REG_CTL, (CTL_MTR | CTL_MRR |\r\n(CLK_100K_DIV & CTL_CLK_M)));\r\nerror = i2c_add_numbered_adapter(&smbus->adapter);\r\nif (error)\r\ngoto out_release_region;\r\npci_set_drvdata(dev, smbus);\r\nreturn 0;\r\nout_release_region:\r\nrelease_region(smbus->base, smbus->size);\r\nout_kfree:\r\nkfree(smbus);\r\nreturn error;\r\n}\r\nstatic void pasemi_smb_remove(struct pci_dev *dev)\r\n{\r\nstruct pasemi_smbus *smbus = pci_get_drvdata(dev);\r\ni2c_del_adapter(&smbus->adapter);\r\nrelease_region(smbus->base, smbus->size);\r\nkfree(smbus);\r\n}
