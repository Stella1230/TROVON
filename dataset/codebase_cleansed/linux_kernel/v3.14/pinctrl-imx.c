static const inline struct imx_pin_group *imx_pinctrl_find_group_by_name(\r\nconst struct imx_pinctrl_soc_info *info,\r\nconst char *name)\r\n{\r\nconst struct imx_pin_group *grp = NULL;\r\nint i;\r\nfor (i = 0; i < info->ngroups; i++) {\r\nif (!strcmp(info->groups[i].name, name)) {\r\ngrp = &info->groups[i];\r\nbreak;\r\n}\r\n}\r\nreturn grp;\r\n}\r\nstatic int imx_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->ngroups;\r\n}\r\nstatic const char *imx_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->groups[selector].name;\r\n}\r\nstatic int imx_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *npins)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nif (selector >= info->ngroups)\r\nreturn -EINVAL;\r\n*pins = info->groups[selector].pin_ids;\r\n*npins = info->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic void imx_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", dev_name(pctldev->dev));\r\n}\r\nstatic int imx_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_group *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num = 1;\r\nint i, j;\r\ngrp = imx_pinctrl_find_group_by_name(info, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < grp->npins; i++) {\r\nif (!(grp->pins[i].config & IMX_NO_PAD_CTL))\r\nmap_num++;\r\n}\r\nnew_map = kmalloc(sizeof(struct pinctrl_map) * map_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\n*map = new_map;\r\n*num_maps = map_num;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\nkfree(new_map);\r\nreturn -EINVAL;\r\n}\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = j = 0; i < grp->npins; i++) {\r\nif (!(grp->pins[i].config & IMX_NO_PAD_CTL)) {\r\nnew_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[j].data.configs.group_or_pin =\r\npin_get_name(pctldev, grp->pins[i].pin);\r\nnew_map[j].data.configs.configs = &grp->pins[i].config;\r\nnew_map[j].data.configs.num_configs = 1;\r\nj++;\r\n}\r\n}\r\ndev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, (*map)->data.mux.group, map_num);\r\nreturn 0;\r\n}\r\nstatic void imx_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic int imx_pmx_enable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg;\r\nunsigned int npins, pin_id;\r\nint i;\r\nstruct imx_pin_group *grp;\r\ngrp = &info->groups[group];\r\nnpins = grp->npins;\r\ndev_dbg(ipctl->dev, "enable function %s group %s\n",\r\ninfo->functions[selector].name, grp->name);\r\nfor (i = 0; i < npins; i++) {\r\nstruct imx_pin *pin = &grp->pins[i];\r\npin_id = pin->pin;\r\npin_reg = &info->pin_regs[pin_id];\r\nif (!(info->flags & ZERO_OFFSET_VALID) && !pin_reg->mux_reg) {\r\ndev_err(ipctl->dev, "Pin(%s) does not support mux function\n",\r\ninfo->pins[pin_id].name);\r\nreturn -EINVAL;\r\n}\r\nif (info->flags & SHARE_MUX_CONF_REG) {\r\nu32 reg;\r\nreg = readl(ipctl->base + pin_reg->mux_reg);\r\nreg &= ~(0x7 << 20);\r\nreg |= (pin->mux_mode << 20);\r\nwritel(reg, ipctl->base + pin_reg->mux_reg);\r\n} else {\r\nwritel(pin->mux_mode, ipctl->base + pin_reg->mux_reg);\r\n}\r\ndev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",\r\npin_reg->mux_reg, pin->mux_mode);\r\nif (pin->input_val >> 24 == 0xff) {\r\nu32 val = pin->input_val;\r\nu8 select = val & 0xff;\r\nu8 width = (val >> 8) & 0xff;\r\nu8 shift = (val >> 16) & 0xff;\r\nu32 mask = ((1 << width) - 1) << shift;\r\nval = readl(ipctl->base + pin->input_reg);\r\nval &= ~mask;\r\nval |= select << shift;\r\nwritel(val, ipctl->base + pin->input_reg);\r\n} else if (pin->input_reg) {\r\nwritel(pin->input_val, ipctl->base + pin->input_reg);\r\ndev_dbg(ipctl->dev,\r\n"==>select_input: offset 0x%x val 0x%x\n",\r\npin->input_reg, pin->input_val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->nfunctions;\r\n}\r\nstatic const char *imx_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nreturn info->functions[selector].name;\r\n}\r\nstatic int imx_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\n*groups = info->functions[selector].groups;\r\n*num_groups = info->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int imx_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *config)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nif (!(info->flags & ZERO_OFFSET_VALID) && !pin_reg->conf_reg) {\r\ndev_err(info->dev, "Pin(%s) does not support config function\n",\r\ninfo->pins[pin_id].name);\r\nreturn -EINVAL;\r\n}\r\n*config = readl(ipctl->base + pin_reg->conf_reg);\r\nif (info->flags & SHARE_MUX_CONF_REG)\r\n*config &= 0xffff;\r\nreturn 0;\r\n}\r\nstatic int imx_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nint i;\r\nif (!(info->flags & ZERO_OFFSET_VALID) && !pin_reg->conf_reg) {\r\ndev_err(info->dev, "Pin(%s) does not support config function\n",\r\ninfo->pins[pin_id].name);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(ipctl->dev, "pinconf set pin %s\n",\r\ninfo->pins[pin_id].name);\r\nfor (i = 0; i < num_configs; i++) {\r\nif (info->flags & SHARE_MUX_CONF_REG) {\r\nu32 reg;\r\nreg = readl(ipctl->base + pin_reg->conf_reg);\r\nreg &= ~0xffff;\r\nreg |= configs[i];\r\nwritel(reg, ipctl->base + pin_reg->conf_reg);\r\n} else {\r\nwritel(configs[i], ipctl->base + pin_reg->conf_reg);\r\n}\r\ndev_dbg(ipctl->dev, "write: offset 0x%x val 0x%lx\n",\r\npin_reg->conf_reg, configs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void imx_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nunsigned long config;\r\nif (!pin_reg || !pin_reg->conf_reg) {\r\nseq_printf(s, "N/A");\r\nreturn;\r\n}\r\nconfig = readl(ipctl->base + pin_reg->conf_reg);\r\nseq_printf(s, "0x%lx", config);\r\n}\r\nstatic void imx_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct imx_pinctrl_soc_info *info = ipctl->info;\r\nstruct imx_pin_group *grp;\r\nunsigned long config;\r\nconst char *name;\r\nint i, ret;\r\nif (group > info->ngroups)\r\nreturn;\r\nseq_printf(s, "\n");\r\ngrp = &info->groups[group];\r\nfor (i = 0; i < grp->npins; i++) {\r\nstruct imx_pin *pin = &grp->pins[i];\r\nname = pin_get_name(pctldev, pin->pin);\r\nret = imx_pinconf_get(pctldev, pin->pin, &config);\r\nif (ret)\r\nreturn;\r\nseq_printf(s, "%s: 0x%lx", name, config);\r\n}\r\n}\r\nstatic int imx_pinctrl_parse_groups(struct device_node *np,\r\nstruct imx_pin_group *grp,\r\nstruct imx_pinctrl_soc_info *info,\r\nu32 index)\r\n{\r\nint size, pin_size;\r\nconst __be32 *list;\r\nint i;\r\nu32 config;\r\ndev_dbg(info->dev, "group(%d): %s\n", index, np->name);\r\nif (info->flags & SHARE_MUX_CONF_REG)\r\npin_size = SHARE_FSL_PIN_SIZE;\r\nelse\r\npin_size = FSL_PIN_SIZE;\r\ngrp->name = np->name;\r\nlist = of_get_property(np, "fsl,pins", &size);\r\nif (!list) {\r\ndev_err(info->dev, "no fsl,pins property in node %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (!size || size % pin_size) {\r\ndev_err(info->dev, "Invalid fsl,pins property in node %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\ngrp->npins = size / pin_size;\r\ngrp->pins = devm_kzalloc(info->dev, grp->npins * sizeof(struct imx_pin),\r\nGFP_KERNEL);\r\ngrp->pin_ids = devm_kzalloc(info->dev, grp->npins * sizeof(unsigned int),\r\nGFP_KERNEL);\r\nif (!grp->pins || ! grp->pin_ids)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < grp->npins; i++) {\r\nu32 mux_reg = be32_to_cpu(*list++);\r\nu32 conf_reg;\r\nunsigned int pin_id;\r\nstruct imx_pin_reg *pin_reg;\r\nstruct imx_pin *pin = &grp->pins[i];\r\nif (info->flags & SHARE_MUX_CONF_REG)\r\nconf_reg = mux_reg;\r\nelse\r\nconf_reg = be32_to_cpu(*list++);\r\npin_id = mux_reg ? mux_reg / 4 : conf_reg / 4;\r\npin_reg = &info->pin_regs[pin_id];\r\npin->pin = pin_id;\r\ngrp->pin_ids[i] = pin_id;\r\npin_reg->mux_reg = mux_reg;\r\npin_reg->conf_reg = conf_reg;\r\npin->input_reg = be32_to_cpu(*list++);\r\npin->mux_mode = be32_to_cpu(*list++);\r\npin->input_val = be32_to_cpu(*list++);\r\nconfig = be32_to_cpu(*list++);\r\nif (config & IMX_PAD_SION)\r\npin->mux_mode |= IOMUXC_CONFIG_SION;\r\npin->config = config & ~IMX_PAD_SION;\r\ndev_dbg(info->dev, "%s: %d 0x%08lx", info->pins[i].name,\r\npin->mux_mode, pin->config);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pinctrl_parse_functions(struct device_node *np,\r\nstruct imx_pinctrl_soc_info *info,\r\nu32 index)\r\n{\r\nstruct device_node *child;\r\nstruct imx_pmx_func *func;\r\nstruct imx_pin_group *grp;\r\nstatic u32 grp_index;\r\nu32 i = 0;\r\ndev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);\r\nfunc = &info->functions[index];\r\nfunc->name = np->name;\r\nfunc->num_groups = of_get_child_count(np);\r\nif (func->num_groups <= 0) {\r\ndev_err(info->dev, "no groups defined in %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nfunc->groups = devm_kzalloc(info->dev,\r\nfunc->num_groups * sizeof(char *), GFP_KERNEL);\r\nfor_each_child_of_node(np, child) {\r\nfunc->groups[i] = child->name;\r\ngrp = &info->groups[grp_index++];\r\nimx_pinctrl_parse_groups(child, grp, info, i++);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pinctrl_probe_dt(struct platform_device *pdev,\r\nstruct imx_pinctrl_soc_info *info)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nu32 nfuncs = 0;\r\nu32 i = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nnfuncs = of_get_child_count(np);\r\nif (nfuncs <= 0) {\r\ndev_err(&pdev->dev, "no functions defined\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->nfunctions = nfuncs;\r\ninfo->functions = devm_kzalloc(&pdev->dev, nfuncs * sizeof(struct imx_pmx_func),\r\nGFP_KERNEL);\r\nif (!info->functions)\r\nreturn -ENOMEM;\r\ninfo->ngroups = 0;\r\nfor_each_child_of_node(np, child)\r\ninfo->ngroups += of_get_child_count(child);\r\ninfo->groups = devm_kzalloc(&pdev->dev, info->ngroups * sizeof(struct imx_pin_group),\r\nGFP_KERNEL);\r\nif (!info->groups)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np, child)\r\nimx_pinctrl_parse_functions(child, info, i++);\r\nreturn 0;\r\n}\r\nint imx_pinctrl_probe(struct platform_device *pdev,\r\nstruct imx_pinctrl_soc_info *info)\r\n{\r\nstruct imx_pinctrl *ipctl;\r\nstruct resource *res;\r\nint ret;\r\nif (!info || !info->pins || !info->npins) {\r\ndev_err(&pdev->dev, "wrong pinctrl info\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->dev = &pdev->dev;\r\nipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\r\nif (!ipctl)\r\nreturn -ENOMEM;\r\ninfo->pin_regs = devm_kzalloc(&pdev->dev, sizeof(*info->pin_regs) *\r\ninfo->npins, GFP_KERNEL);\r\nif (!info->pin_regs)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nipctl->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ipctl->base))\r\nreturn PTR_ERR(ipctl->base);\r\nimx_pinctrl_desc.name = dev_name(&pdev->dev);\r\nimx_pinctrl_desc.pins = info->pins;\r\nimx_pinctrl_desc.npins = info->npins;\r\nret = imx_pinctrl_probe_dt(pdev, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "fail to probe dt properties\n");\r\nreturn ret;\r\n}\r\nipctl->info = info;\r\nipctl->dev = info->dev;\r\nplatform_set_drvdata(pdev, ipctl);\r\nipctl->pctl = pinctrl_register(&imx_pinctrl_desc, &pdev->dev, ipctl);\r\nif (!ipctl->pctl) {\r\ndev_err(&pdev->dev, "could not register IMX pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(&pdev->dev, "initialized IMX pinctrl driver\n");\r\nreturn 0;\r\n}\r\nint imx_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_pinctrl *ipctl = platform_get_drvdata(pdev);\r\npinctrl_unregister(ipctl->pctl);\r\nreturn 0;\r\n}
