static int megaraid_change_queue_depth(struct scsi_device *sdev, int qdepth,\r\nint reason)\r\n{\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (qdepth > MBOX_MAX_SCSI_CMDS)\r\nqdepth = MBOX_MAX_SCSI_CMDS;\r\nscsi_adjust_queue_depth(sdev, 0, qdepth);\r\nreturn sdev->queue_depth;\r\n}\r\nstatic int __init\r\nmegaraid_init(void)\r\n{\r\nint rval;\r\ncon_log(CL_ANN, (KERN_INFO "megaraid: %s %s\n", MEGARAID_VERSION,\r\nMEGARAID_EXT_VERSION));\r\nif (megaraid_cmd_per_lun > MBOX_MAX_SCSI_CMDS) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mailbox: max commands per lun reset to %d\n",\r\nMBOX_MAX_SCSI_CMDS));\r\nmegaraid_cmd_per_lun = MBOX_MAX_SCSI_CMDS;\r\n}\r\nrval = pci_register_driver(&megaraid_pci_driver);\r\nif (rval < 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: could not register hotplug support.\n"));\r\n}\r\nreturn rval;\r\n}\r\nstatic void __exit\r\nmegaraid_exit(void)\r\n{\r\ncon_log(CL_DLEVEL1, (KERN_NOTICE "megaraid: unloading framework\n"));\r\npci_unregister_driver(&megaraid_pci_driver);\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nadapter_t *adapter;\r\ncon_log(CL_ANN, (KERN_INFO\r\n"megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device));\r\ncon_log(CL_ANN, ("bus %d:slot %d:func %d\n", pdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)));\r\nif (pci_enable_device(pdev)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: pci_enable_device failed\n"));\r\nreturn -ENODEV;\r\n}\r\npci_set_master(pdev);\r\nadapter = kzalloc(sizeof(adapter_t), GFP_KERNEL);\r\nif (adapter == NULL) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d.\n", __func__, __LINE__));\r\ngoto out_probe_one;\r\n}\r\nadapter->unique_id = pdev->bus->number << 8 | pdev->devfn;\r\nadapter->irq = pdev->irq;\r\nadapter->pdev = pdev;\r\natomic_set(&adapter->being_detached, 0);\r\nif (pci_set_dma_mask(adapter->pdev, DMA_BIT_MASK(32)) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: pci_set_dma_mask failed:%d\n", __LINE__));\r\ngoto out_free_adapter;\r\n}\r\nspin_lock_init(&adapter->lock);\r\nINIT_LIST_HEAD(&adapter->kscb_pool);\r\nspin_lock_init(SCSI_FREE_LIST_LOCK(adapter));\r\nINIT_LIST_HEAD(&adapter->pend_list);\r\nspin_lock_init(PENDING_LIST_LOCK(adapter));\r\nINIT_LIST_HEAD(&adapter->completed_list);\r\nspin_lock_init(COMPLETED_LIST_LOCK(adapter));\r\nif (megaraid_init_mbox(adapter) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: maibox adapter did not initialize\n"));\r\ngoto out_free_adapter;\r\n}\r\nif (megaraid_cmm_register(adapter) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: could not register with management module\n"));\r\ngoto out_fini_mbox;\r\n}\r\npci_set_drvdata(pdev, adapter);\r\nif (megaraid_io_attach(adapter) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid: io attach failed\n"));\r\ngoto out_cmm_unreg;\r\n}\r\nreturn 0;\r\nout_cmm_unreg:\r\nmegaraid_cmm_unregister(adapter);\r\nout_fini_mbox:\r\nmegaraid_fini_mbox(adapter);\r\nout_free_adapter:\r\nkfree(adapter);\r\nout_probe_one:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\nmegaraid_detach_one(struct pci_dev *pdev)\r\n{\r\nadapter_t *adapter;\r\nstruct Scsi_Host *host;\r\nadapter = pci_get_drvdata(pdev);\r\nif (!adapter) {\r\ncon_log(CL_ANN, (KERN_CRIT\r\n"megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device));\r\nreturn;\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device));\r\n}\r\nhost = adapter->host;\r\natomic_set(&adapter->being_detached, 1);\r\nmegaraid_io_detach(adapter);\r\nmegaraid_cmm_unregister(adapter);\r\nmegaraid_fini_mbox(adapter);\r\nkfree(adapter);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_shutdown(struct pci_dev *pdev)\r\n{\r\nadapter_t *adapter = pci_get_drvdata(pdev);\r\nstatic int counter;\r\nif (!adapter) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: null device in shutdown\n"));\r\nreturn;\r\n}\r\ncon_log(CL_ANN, (KERN_INFO "megaraid: flushing adapter %d...",\r\ncounter++));\r\nmegaraid_mbox_flush_cache(adapter);\r\ncon_log(CL_ANN, ("done\n"));\r\n}\r\nstatic int\r\nmegaraid_io_attach(adapter_t *adapter)\r\n{\r\nstruct Scsi_Host *host;\r\nhost = scsi_host_alloc(&megaraid_template_g, 8);\r\nif (!host) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mbox: scsi_register failed\n"));\r\nreturn -1;\r\n}\r\nSCSIHOST2ADAP(host) = (caddr_t)adapter;\r\nadapter->host = host;\r\nhost->irq = adapter->irq;\r\nhost->unique_id = adapter->unique_id;\r\nhost->can_queue = adapter->max_cmds;\r\nhost->this_id = adapter->init_id;\r\nhost->sg_tablesize = adapter->sglen;\r\nhost->max_sectors = adapter->max_sectors;\r\nhost->cmd_per_lun = adapter->cmd_per_lun;\r\nhost->max_channel = adapter->max_channel;\r\nhost->max_id = adapter->max_target;\r\nhost->max_lun = adapter->max_lun;\r\nif (scsi_add_host(host, &adapter->pdev->dev)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mbox: scsi_add_host failed\n"));\r\nscsi_host_put(host);\r\nreturn -1;\r\n}\r\nscsi_scan_host(host);\r\nreturn 0;\r\n}\r\nstatic void\r\nmegaraid_io_detach(adapter_t *adapter)\r\n{\r\nstruct Scsi_Host *host;\r\ncon_log(CL_DLEVEL1, (KERN_INFO "megaraid: io detach\n"));\r\nhost = adapter->host;\r\nscsi_remove_host(host);\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_init_mbox(adapter_t *adapter)\r\n{\r\nstruct pci_dev *pdev;\r\nmraid_device_t *raid_dev;\r\nint i;\r\nuint32_t magic64;\r\nadapter->ito = MBOX_TIMEOUT;\r\npdev = adapter->pdev;\r\nraid_dev = kzalloc(sizeof(mraid_device_t), GFP_KERNEL);\r\nif (raid_dev == NULL) return -1;\r\nadapter->raid_device = (caddr_t)raid_dev;\r\nraid_dev->fast_load = megaraid_fast_load;\r\nraid_dev->baseport = pci_resource_start(pdev, 0);\r\nif (pci_request_regions(pdev, "MegaRAID: LSI Logic Corporation") != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: mem region busy\n"));\r\ngoto out_free_raid_dev;\r\n}\r\nraid_dev->baseaddr = ioremap_nocache(raid_dev->baseport, 128);\r\nif (!raid_dev->baseaddr) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: could not map hba memory\n") );\r\ngoto out_release_regions;\r\n}\r\nspin_lock_init(&raid_dev->mailbox_lock);\r\nif (megaraid_alloc_cmd_packets(adapter) != 0)\r\ngoto out_iounmap;\r\nif (megaraid_mbox_fire_sync_cmd(adapter))\r\ncon_log(CL_ANN, ("megaraid: sync cmd failed\n"));\r\nif (request_irq(adapter->irq, megaraid_isr, IRQF_SHARED, "megaraid",\r\nadapter)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: Couldn't register IRQ %d!\n", adapter->irq));\r\ngoto out_alloc_cmds;\r\n}\r\nif (megaraid_mbox_product_info(adapter) != 0)\r\ngoto out_free_irq;\r\nadapter->max_cdb_sz = 10;\r\nif (megaraid_mbox_extended_cdb(adapter) == 0) {\r\nadapter->max_cdb_sz = 16;\r\n}\r\nadapter->ha = 0;\r\nadapter->init_id = -1;\r\nif (megaraid_mbox_support_ha(adapter, &adapter->init_id) == 0) {\r\nadapter->ha = 1;\r\n}\r\nmegaraid_mbox_setup_device_map(adapter);\r\nif (megaraid_mbox_support_random_del(adapter)) {\r\nfor (i = 0; i <= MAX_LOGICAL_DRIVES_40LD; i++) {\r\nadapter->device_ids[adapter->max_channel][i] += 0x80;\r\n}\r\nadapter->device_ids[adapter->max_channel][adapter->init_id] =\r\n0xFF;\r\nraid_dev->random_del_supported = 1;\r\n}\r\nadapter->sglen = megaraid_mbox_get_max_sg(adapter);\r\nmegaraid_mbox_enum_raid_scsi(adapter);\r\nadapter->max_sectors = megaraid_max_sectors;\r\nadapter->cmd_per_lun = megaraid_cmd_per_lun;\r\nif (megaraid_sysfs_alloc_resources(adapter) != 0)\r\ngoto out_free_irq;\r\npci_read_config_dword(adapter->pdev, PCI_CONF_AMISIG64, &magic64);\r\nif (((magic64 == HBA_SIGNATURE_64_BIT) &&\r\n((adapter->pdev->subsystem_device !=\r\nPCI_SUBSYS_ID_MEGARAID_SATA_150_6) &&\r\n(adapter->pdev->subsystem_device !=\r\nPCI_SUBSYS_ID_MEGARAID_SATA_150_4))) ||\r\n(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\r\nadapter->pdev->device == PCI_DEVICE_ID_VERDE) ||\r\n(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\r\nadapter->pdev->device == PCI_DEVICE_ID_DOBSON) ||\r\n(adapter->pdev->vendor == PCI_VENDOR_ID_LSI_LOGIC &&\r\nadapter->pdev->device == PCI_DEVICE_ID_LINDSAY) ||\r\n(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&\r\nadapter->pdev->device == PCI_DEVICE_ID_PERC4_DI_EVERGLADES) ||\r\n(adapter->pdev->vendor == PCI_VENDOR_ID_DELL &&\r\nadapter->pdev->device == PCI_DEVICE_ID_PERC4E_DI_KOBUK)) {\r\nif (pci_set_dma_mask(adapter->pdev, DMA_BIT_MASK(64))) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: DMA mask for 64-bit failed\n"));\r\nif (pci_set_dma_mask (adapter->pdev, DMA_BIT_MASK(32))) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: 32-bit DMA mask failed\n"));\r\ngoto out_free_sysfs_res;\r\n}\r\n}\r\n}\r\ntasklet_init(&adapter->dpc_h, megaraid_mbox_dpc,\r\n(unsigned long)adapter);\r\ncon_log(CL_DLEVEL1, (KERN_INFO\r\n"megaraid mbox hba successfully initialized\n"));\r\nreturn 0;\r\nout_free_sysfs_res:\r\nmegaraid_sysfs_free_resources(adapter);\r\nout_free_irq:\r\nfree_irq(adapter->irq, adapter);\r\nout_alloc_cmds:\r\nmegaraid_free_cmd_packets(adapter);\r\nout_iounmap:\r\niounmap(raid_dev->baseaddr);\r\nout_release_regions:\r\npci_release_regions(pdev);\r\nout_free_raid_dev:\r\nkfree(raid_dev);\r\nreturn -1;\r\n}\r\nstatic void\r\nmegaraid_fini_mbox(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmegaraid_mbox_flush_cache(adapter);\r\ntasklet_kill(&adapter->dpc_h);\r\nmegaraid_sysfs_free_resources(adapter);\r\nmegaraid_free_cmd_packets(adapter);\r\nfree_irq(adapter->irq, adapter);\r\niounmap(raid_dev->baseaddr);\r\npci_release_regions(adapter->pdev);\r\nkfree(raid_dev);\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_alloc_cmd_packets(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nstruct pci_dev *pdev;\r\nunsigned long align;\r\nscb_t *scb;\r\nmbox_ccb_t *ccb;\r\nstruct mraid_pci_blk *epthru_pci_blk;\r\nstruct mraid_pci_blk *sg_pci_blk;\r\nstruct mraid_pci_blk *mbox_pci_blk;\r\nint i;\r\npdev = adapter->pdev;\r\nraid_dev->una_mbox64 = pci_alloc_consistent(adapter->pdev,\r\nsizeof(mbox64_t), &raid_dev->una_mbox64_dma);\r\nif (!raid_dev->una_mbox64) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\nreturn -1;\r\n}\r\nmemset(raid_dev->una_mbox64, 0, sizeof(mbox64_t));\r\nraid_dev->mbox = &raid_dev->una_mbox64->mbox32;\r\nraid_dev->mbox = (mbox_t *)((((unsigned long)raid_dev->mbox) + 15) &\r\n(~0UL ^ 0xFUL));\r\nraid_dev->mbox64 = (mbox64_t *)(((unsigned long)raid_dev->mbox) - 8);\r\nalign = ((void *)raid_dev->mbox -\r\n((void *)&raid_dev->una_mbox64->mbox32));\r\nraid_dev->mbox_dma = (unsigned long)raid_dev->una_mbox64_dma + 8 +\r\nalign;\r\nadapter->ibuf = pci_alloc_consistent(pdev, MBOX_IBUF_SIZE,\r\n&adapter->ibuf_dma_h);\r\nif (!adapter->ibuf) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\ngoto out_free_common_mbox;\r\n}\r\nmemset(adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nadapter->kscb_list = kcalloc(MBOX_MAX_SCSI_CMDS, sizeof(scb_t), GFP_KERNEL);\r\nif (adapter->kscb_list == NULL) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\ngoto out_free_ibuf;\r\n}\r\nif (megaraid_mbox_setup_dma_pools(adapter) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\ngoto out_free_scb_list;\r\n}\r\nepthru_pci_blk = raid_dev->epthru_pool;\r\nsg_pci_blk = raid_dev->sg_pool;\r\nmbox_pci_blk = raid_dev->mbox_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\r\nscb = adapter->kscb_list + i;\r\nccb = raid_dev->ccb_list + i;\r\nccb->mbox = (mbox_t *)(mbox_pci_blk[i].vaddr + 16);\r\nccb->raw_mbox = (uint8_t *)ccb->mbox;\r\nccb->mbox64 = (mbox64_t *)(mbox_pci_blk[i].vaddr + 8);\r\nccb->mbox_dma_h = (unsigned long)mbox_pci_blk[i].dma_addr + 16;\r\nif (ccb->mbox_dma_h & 0x0F) {\r\ncon_log(CL_ANN, (KERN_CRIT\r\n"megaraid mbox: not aligned on 16-bytes\n"));\r\ngoto out_teardown_dma_pools;\r\n}\r\nccb->epthru = (mraid_epassthru_t *)\r\nepthru_pci_blk[i].vaddr;\r\nccb->epthru_dma_h = epthru_pci_blk[i].dma_addr;\r\nccb->pthru = (mraid_passthru_t *)ccb->epthru;\r\nccb->pthru_dma_h = ccb->epthru_dma_h;\r\nccb->sgl64 = (mbox_sgl64 *)sg_pci_blk[i].vaddr;\r\nccb->sgl_dma_h = sg_pci_blk[i].dma_addr;\r\nccb->sgl32 = (mbox_sgl32 *)ccb->sgl64;\r\nscb->ccb = (caddr_t)ccb;\r\nscb->gp = 0;\r\nscb->sno = i;\r\nscb->scp = NULL;\r\nscb->state = SCB_FREE;\r\nscb->dma_direction = PCI_DMA_NONE;\r\nscb->dma_type = MRAID_DMA_NONE;\r\nscb->dev_channel = -1;\r\nscb->dev_target = -1;\r\nlist_add_tail(&scb->list, &adapter->kscb_pool);\r\n}\r\nreturn 0;\r\nout_teardown_dma_pools:\r\nmegaraid_mbox_teardown_dma_pools(adapter);\r\nout_free_scb_list:\r\nkfree(adapter->kscb_list);\r\nout_free_ibuf:\r\npci_free_consistent(pdev, MBOX_IBUF_SIZE, (void *)adapter->ibuf,\r\nadapter->ibuf_dma_h);\r\nout_free_common_mbox:\r\npci_free_consistent(adapter->pdev, sizeof(mbox64_t),\r\n(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);\r\nreturn -1;\r\n}\r\nstatic void\r\nmegaraid_free_cmd_packets(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmegaraid_mbox_teardown_dma_pools(adapter);\r\nkfree(adapter->kscb_list);\r\npci_free_consistent(adapter->pdev, MBOX_IBUF_SIZE,\r\n(void *)adapter->ibuf, adapter->ibuf_dma_h);\r\npci_free_consistent(adapter->pdev, sizeof(mbox64_t),\r\n(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_mbox_setup_dma_pools(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nstruct mraid_pci_blk *epthru_pci_blk;\r\nstruct mraid_pci_blk *sg_pci_blk;\r\nstruct mraid_pci_blk *mbox_pci_blk;\r\nint i;\r\nraid_dev->mbox_pool_handle = pci_pool_create("megaraid mbox pool",\r\nadapter->pdev,\r\nsizeof(mbox64_t) + 16,\r\n16, 0);\r\nif (raid_dev->mbox_pool_handle == NULL) {\r\ngoto fail_setup_dma_pool;\r\n}\r\nmbox_pci_blk = raid_dev->mbox_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\r\nmbox_pci_blk[i].vaddr = pci_pool_alloc(\r\nraid_dev->mbox_pool_handle,\r\nGFP_KERNEL,\r\n&mbox_pci_blk[i].dma_addr);\r\nif (!mbox_pci_blk[i].vaddr) {\r\ngoto fail_setup_dma_pool;\r\n}\r\n}\r\nraid_dev->epthru_pool_handle = pci_pool_create("megaraid mbox pthru",\r\nadapter->pdev, sizeof(mraid_epassthru_t), 128, 0);\r\nif (raid_dev->epthru_pool_handle == NULL) {\r\ngoto fail_setup_dma_pool;\r\n}\r\nepthru_pci_blk = raid_dev->epthru_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\r\nepthru_pci_blk[i].vaddr = pci_pool_alloc(\r\nraid_dev->epthru_pool_handle,\r\nGFP_KERNEL,\r\n&epthru_pci_blk[i].dma_addr);\r\nif (!epthru_pci_blk[i].vaddr) {\r\ngoto fail_setup_dma_pool;\r\n}\r\n}\r\nraid_dev->sg_pool_handle = pci_pool_create("megaraid mbox sg",\r\nadapter->pdev,\r\nsizeof(mbox_sgl64) * MBOX_MAX_SG_SIZE,\r\n512, 0);\r\nif (raid_dev->sg_pool_handle == NULL) {\r\ngoto fail_setup_dma_pool;\r\n}\r\nsg_pci_blk = raid_dev->sg_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\r\nsg_pci_blk[i].vaddr = pci_pool_alloc(\r\nraid_dev->sg_pool_handle,\r\nGFP_KERNEL,\r\n&sg_pci_blk[i].dma_addr);\r\nif (!sg_pci_blk[i].vaddr) {\r\ngoto fail_setup_dma_pool;\r\n}\r\n}\r\nreturn 0;\r\nfail_setup_dma_pool:\r\nmegaraid_mbox_teardown_dma_pools(adapter);\r\nreturn -1;\r\n}\r\nstatic void\r\nmegaraid_mbox_teardown_dma_pools(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nstruct mraid_pci_blk *epthru_pci_blk;\r\nstruct mraid_pci_blk *sg_pci_blk;\r\nstruct mraid_pci_blk *mbox_pci_blk;\r\nint i;\r\nsg_pci_blk = raid_dev->sg_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS && sg_pci_blk[i].vaddr; i++) {\r\npci_pool_free(raid_dev->sg_pool_handle, sg_pci_blk[i].vaddr,\r\nsg_pci_blk[i].dma_addr);\r\n}\r\nif (raid_dev->sg_pool_handle)\r\npci_pool_destroy(raid_dev->sg_pool_handle);\r\nepthru_pci_blk = raid_dev->epthru_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS && epthru_pci_blk[i].vaddr; i++) {\r\npci_pool_free(raid_dev->epthru_pool_handle,\r\nepthru_pci_blk[i].vaddr, epthru_pci_blk[i].dma_addr);\r\n}\r\nif (raid_dev->epthru_pool_handle)\r\npci_pool_destroy(raid_dev->epthru_pool_handle);\r\nmbox_pci_blk = raid_dev->mbox_pool;\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS && mbox_pci_blk[i].vaddr; i++) {\r\npci_pool_free(raid_dev->mbox_pool_handle,\r\nmbox_pci_blk[i].vaddr, mbox_pci_blk[i].dma_addr);\r\n}\r\nif (raid_dev->mbox_pool_handle)\r\npci_pool_destroy(raid_dev->mbox_pool_handle);\r\nreturn;\r\n}\r\nstatic scb_t *\r\nmegaraid_alloc_scb(adapter_t *adapter, struct scsi_cmnd *scp)\r\n{\r\nstruct list_head *head = &adapter->kscb_pool;\r\nscb_t *scb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(SCSI_FREE_LIST_LOCK(adapter), flags);\r\nif (list_empty(head)) {\r\nspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\r\nreturn NULL;\r\n}\r\nscb = list_entry(head->next, scb_t, list);\r\nlist_del_init(&scb->list);\r\nspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\r\nscb->state = SCB_ACTIVE;\r\nscb->scp = scp;\r\nscb->dma_type = MRAID_DMA_NONE;\r\nreturn scb;\r\n}\r\nstatic inline void\r\nmegaraid_dealloc_scb(adapter_t *adapter, scb_t *scb)\r\n{\r\nunsigned long flags;\r\nscb->state = SCB_FREE;\r\nscb->scp = NULL;\r\nspin_lock_irqsave(SCSI_FREE_LIST_LOCK(adapter), flags);\r\nlist_add(&scb->list, &adapter->kscb_pool);\r\nspin_unlock_irqrestore(SCSI_FREE_LIST_LOCK(adapter), flags);\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_mbox_mksgl(adapter_t *adapter, scb_t *scb)\r\n{\r\nstruct scatterlist *sgl;\r\nmbox_ccb_t *ccb;\r\nstruct scsi_cmnd *scp;\r\nint sgcnt;\r\nint i;\r\nscp = scb->scp;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nsgcnt = scsi_dma_map(scp);\r\nBUG_ON(sgcnt < 0 || sgcnt > adapter->sglen);\r\nif (!sgcnt)\r\nreturn 0;\r\nscb->dma_type = MRAID_DMA_WSG;\r\nscsi_for_each_sg(scp, sgl, sgcnt, i) {\r\nccb->sgl64[i].address = sg_dma_address(sgl);\r\nccb->sgl64[i].length = sg_dma_len(sgl);\r\n}\r\nreturn sgcnt;\r\n}\r\nstatic int\r\nmbox_post_cmd(adapter_t *adapter, scb_t *scb)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox64_t *mbox64;\r\nmbox_t *mbox;\r\nmbox_ccb_t *ccb;\r\nunsigned long flags;\r\nunsigned int i = 0;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nmbox = raid_dev->mbox;\r\nmbox64 = raid_dev->mbox64;\r\nspin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);\r\nif (unlikely(mbox->busy)) {\r\ndo {\r\nudelay(1);\r\ni++;\r\nrmb();\r\n} while(mbox->busy && (i < max_mbox_busy_wait));\r\nif (mbox->busy) {\r\nspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\r\nreturn -1;\r\n}\r\n}\r\nmemcpy((caddr_t)mbox64, (caddr_t)ccb->mbox64, 22);\r\nmbox->cmdid = scb->sno;\r\nadapter->outstanding_cmds++;\r\nif (scb->dma_direction == PCI_DMA_TODEVICE)\r\npci_dma_sync_sg_for_device(adapter->pdev,\r\nscsi_sglist(scb->scp),\r\nscsi_sg_count(scb->scp),\r\nPCI_DMA_TODEVICE);\r\nmbox->busy = 1;\r\nmbox->poll = 0;\r\nmbox->ack = 0;\r\nwmb();\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\r\nspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegaraid_queue_command_lck(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *))\r\n{\r\nadapter_t *adapter;\r\nscb_t *scb;\r\nint if_busy;\r\nadapter = SCP2ADAPTER(scp);\r\nscp->scsi_done = done;\r\nscp->result = 0;\r\nif_busy = 0;\r\nscb = megaraid_mbox_build_cmd(adapter, scp, &if_busy);\r\nif (!scb) {\r\ndone(scp);\r\nreturn 0;\r\n}\r\nmegaraid_mbox_runpendq(adapter, scb);\r\nreturn if_busy;\r\n}\r\nvoid\r\nmegaraid_mbox_runpendq(adapter_t *adapter, scb_t *scb_q)\r\n{\r\nscb_t *scb;\r\nunsigned long flags;\r\nspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\r\nif (scb_q) {\r\nscb_q->state = SCB_PENDQ;\r\nlist_add_tail(&scb_q->list, &adapter->pend_list);\r\n}\r\nif (adapter->quiescent) {\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\r\nreturn;\r\n}\r\nwhile (!list_empty(&adapter->pend_list)) {\r\nassert_spin_locked(PENDING_LIST_LOCK(adapter));\r\nscb = list_entry(adapter->pend_list.next, scb_t, list);\r\nlist_del_init(&scb->list);\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\r\nscb->state = SCB_ISSUED;\r\nif (mbox_post_cmd(adapter, scb) != 0) {\r\nspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\r\nscb->state = SCB_PENDQ;\r\nlist_add(&scb->list, &adapter->pend_list);\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),\r\nflags);\r\nreturn;\r\n}\r\nspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\r\n}\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_prepare_pthru(adapter_t *adapter, scb_t *scb,\r\nstruct scsi_cmnd *scp)\r\n{\r\nmbox_ccb_t *ccb;\r\nmraid_passthru_t *pthru;\r\nuint8_t channel;\r\nuint8_t target;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\npthru = ccb->pthru;\r\nchannel = scb->dev_channel;\r\ntarget = scb->dev_target;\r\npthru->timeout = 4;\r\npthru->ars = 1;\r\npthru->islogical = 0;\r\npthru->channel = 0;\r\npthru->target = (channel << 4) | target;\r\npthru->logdrv = SCP2LUN(scp);\r\npthru->reqsenselen = 14;\r\npthru->cdblen = scp->cmd_len;\r\nmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\r\nif (scsi_bufflen(scp)) {\r\npthru->dataxferlen = scsi_bufflen(scp);\r\npthru->dataxferaddr = ccb->sgl_dma_h;\r\npthru->numsge = megaraid_mbox_mksgl(adapter, scb);\r\n}\r\nelse {\r\npthru->dataxferaddr = 0;\r\npthru->dataxferlen = 0;\r\npthru->numsge = 0;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_prepare_epthru(adapter_t *adapter, scb_t *scb,\r\nstruct scsi_cmnd *scp)\r\n{\r\nmbox_ccb_t *ccb;\r\nmraid_epassthru_t *epthru;\r\nuint8_t channel;\r\nuint8_t target;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nepthru = ccb->epthru;\r\nchannel = scb->dev_channel;\r\ntarget = scb->dev_target;\r\nepthru->timeout = 4;\r\nepthru->ars = 1;\r\nepthru->islogical = 0;\r\nepthru->channel = 0;\r\nepthru->target = (channel << 4) | target;\r\nepthru->logdrv = SCP2LUN(scp);\r\nepthru->reqsenselen = 14;\r\nepthru->cdblen = scp->cmd_len;\r\nmemcpy(epthru->cdb, scp->cmnd, scp->cmd_len);\r\nif (scsi_bufflen(scp)) {\r\nepthru->dataxferlen = scsi_bufflen(scp);\r\nepthru->dataxferaddr = ccb->sgl_dma_h;\r\nepthru->numsge = megaraid_mbox_mksgl(adapter, scb);\r\n}\r\nelse {\r\nepthru->dataxferaddr = 0;\r\nepthru->dataxferlen = 0;\r\nepthru->numsge = 0;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_ack_sequence(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox_t *mbox;\r\nscb_t *scb;\r\nuint8_t nstatus;\r\nuint8_t completed[MBOX_MAX_FIRMWARE_STATUS];\r\nstruct list_head clist;\r\nint handled;\r\nuint32_t dword;\r\nunsigned long flags;\r\nint i, j;\r\nmbox = raid_dev->mbox;\r\nINIT_LIST_HEAD(&clist);\r\nhandled = 0;\r\nspin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);\r\ndo {\r\ndword = RDOUTDOOR(raid_dev);\r\nif (dword != 0x10001234) break;\r\nhandled = 1;\r\nWROUTDOOR(raid_dev, 0x10001234);\r\nnstatus = 0;\r\nfor (i = 0; i < 0xFFFFF; i++) {\r\nif (mbox->numstatus != 0xFF) {\r\nnstatus = mbox->numstatus;\r\nbreak;\r\n}\r\nrmb();\r\n}\r\nmbox->numstatus = 0xFF;\r\nadapter->outstanding_cmds -= nstatus;\r\nfor (i = 0; i < nstatus; i++) {\r\nfor (j = 0; j < 0xFFFFF; j++) {\r\nif (mbox->completed[i] != 0xFF) break;\r\nrmb();\r\n}\r\ncompleted[i] = mbox->completed[i];\r\nmbox->completed[i] = 0xFF;\r\nif (completed[i] == 0xFF) {\r\ncon_log(CL_ANN, (KERN_CRIT\r\n"megaraid: command posting timed out\n"));\r\nBUG();\r\ncontinue;\r\n}\r\nif (completed[i] >= MBOX_MAX_SCSI_CMDS) {\r\nscb = adapter->uscb_list + (completed[i] -\r\nMBOX_MAX_SCSI_CMDS);\r\n}\r\nelse {\r\nscb = adapter->kscb_list + completed[i];\r\n}\r\nscb->status = mbox->status;\r\nlist_add_tail(&scb->list, &clist);\r\n}\r\nWRINDOOR(raid_dev, 0x02);\r\n} while(1);\r\nspin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);\r\nspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\r\nlist_splice(&clist, &adapter->completed_list);\r\nspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\r\nif (handled)\r\ntasklet_schedule(&adapter->dpc_h);\r\nreturn handled;\r\n}\r\nstatic irqreturn_t\r\nmegaraid_isr(int irq, void *devp)\r\n{\r\nadapter_t *adapter = devp;\r\nint handled;\r\nhandled = megaraid_ack_sequence(adapter);\r\nif (!adapter->quiescent) {\r\nmegaraid_mbox_runpendq(adapter, NULL);\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void\r\nmegaraid_mbox_sync_scb(adapter_t *adapter, scb_t *scb)\r\n{\r\nmbox_ccb_t *ccb;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nif (scb->dma_direction == PCI_DMA_FROMDEVICE)\r\npci_dma_sync_sg_for_cpu(adapter->pdev,\r\nscsi_sglist(scb->scp),\r\nscsi_sg_count(scb->scp),\r\nPCI_DMA_FROMDEVICE);\r\nscsi_dma_unmap(scb->scp);\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_dpc(unsigned long devp)\r\n{\r\nadapter_t *adapter = (adapter_t *)devp;\r\nmraid_device_t *raid_dev;\r\nstruct list_head clist;\r\nstruct scatterlist *sgl;\r\nscb_t *scb;\r\nscb_t *tmp;\r\nstruct scsi_cmnd *scp;\r\nmraid_passthru_t *pthru;\r\nmraid_epassthru_t *epthru;\r\nmbox_ccb_t *ccb;\r\nint islogical;\r\nint pdev_index;\r\nint pdev_state;\r\nmbox_t *mbox;\r\nunsigned long flags;\r\nuint8_t c;\r\nint status;\r\nuioc_t *kioc;\r\nif (!adapter) return;\r\nraid_dev = ADAP2RAIDDEV(adapter);\r\nINIT_LIST_HEAD(&clist);\r\nspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\r\nlist_splice_init(&adapter->completed_list, &clist);\r\nspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\r\nlist_for_each_entry_safe(scb, tmp, &clist, list) {\r\nstatus = scb->status;\r\nscp = scb->scp;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\npthru = ccb->pthru;\r\nepthru = ccb->epthru;\r\nmbox = ccb->mbox;\r\nif (scb->state != SCB_ISSUED) {\r\ncon_log(CL_ANN, (KERN_CRIT\r\n"megaraid critical err: invalid command %d:%d:%p\n",\r\nscb->sno, scb->state, scp));\r\nBUG();\r\ncontinue;\r\n}\r\nif (scb->sno >= MBOX_MAX_SCSI_CMDS) {\r\nscb->state = SCB_FREE;\r\nscb->status = status;\r\nlist_del_init(&scb->list);\r\nkioc = (uioc_t *)scb->gp;\r\nkioc->status = 0;\r\nmegaraid_mbox_mm_done(adapter, scb);\r\ncontinue;\r\n}\r\nif (scb->state & SCB_ABORT) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: aborted cmd [%x] completed\n",\r\nscb->sno));\r\n}\r\nislogical = MRAID_IS_LOGICAL(adapter, scp);\r\nif (scp->cmnd[0] == INQUIRY && status == 0 && islogical == 0\r\n&& IS_RAID_CH(raid_dev, scb->dev_channel)) {\r\nsgl = scsi_sglist(scp);\r\nif (sg_page(sgl)) {\r\nc = *(unsigned char *) sg_virt(&sgl[0]);\r\n} else {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mailbox: invalid sg:%d\n",\r\n__LINE__));\r\nc = 0;\r\n}\r\nif ((c & 0x1F ) == TYPE_DISK) {\r\npdev_index = (scb->dev_channel * 16) +\r\nscb->dev_target;\r\npdev_state =\r\nraid_dev->pdrv_state[pdev_index] & 0x0F;\r\nif (pdev_state == PDRV_ONLINE ||\r\npdev_state == PDRV_FAILED ||\r\npdev_state == PDRV_RBLD ||\r\npdev_state == PDRV_HOTSPARE ||\r\nmegaraid_expose_unconf_disks == 0) {\r\nstatus = 0xF0;\r\n}\r\n}\r\n}\r\nswitch (status) {\r\ncase 0x00:\r\nscp->result = (DID_OK << 16);\r\nbreak;\r\ncase 0x02:\r\nif (mbox->cmd == MBOXCMD_PASSTHRU ||\r\nmbox->cmd == MBOXCMD_PASSTHRU64) {\r\nmemcpy(scp->sense_buffer, pthru->reqsensearea,\r\n14);\r\nscp->result = DRIVER_SENSE << 24 |\r\nDID_OK << 16 | CHECK_CONDITION << 1;\r\n}\r\nelse {\r\nif (mbox->cmd == MBOXCMD_EXTPTHRU) {\r\nmemcpy(scp->sense_buffer,\r\nepthru->reqsensearea, 14);\r\nscp->result = DRIVER_SENSE << 24 |\r\nDID_OK << 16 |\r\nCHECK_CONDITION << 1;\r\n} else {\r\nscp->sense_buffer[0] = 0x70;\r\nscp->sense_buffer[2] = ABORTED_COMMAND;\r\nscp->result = CHECK_CONDITION << 1;\r\n}\r\n}\r\nbreak;\r\ncase 0x08:\r\nscp->result = DID_BUS_BUSY << 16 | status;\r\nbreak;\r\ndefault:\r\nif (scp->cmnd[0] == TEST_UNIT_READY) {\r\nscp->result = DID_ERROR << 16 |\r\nRESERVATION_CONFLICT << 1;\r\n}\r\nelse\r\nif (status == 1 && (scp->cmnd[0] == RESERVE ||\r\nscp->cmnd[0] == RELEASE)) {\r\nscp->result = DID_ERROR << 16 |\r\nRESERVATION_CONFLICT << 1;\r\n}\r\nelse {\r\nscp->result = DID_BAD_TARGET << 16 | status;\r\n}\r\n}\r\nif (status) {\r\nmegaraid_mbox_display_scb(adapter, scb);\r\n}\r\nmegaraid_mbox_sync_scb(adapter, scb);\r\nlist_del_init(&scb->list);\r\nmegaraid_dealloc_scb(adapter, scb);\r\nscp->scsi_done(scp);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_abort_handler(struct scsi_cmnd *scp)\r\n{\r\nadapter_t *adapter;\r\nmraid_device_t *raid_dev;\r\nscb_t *scb;\r\nscb_t *tmp;\r\nint found;\r\nunsigned long flags;\r\nint i;\r\nadapter = SCP2ADAPTER(scp);\r\nraid_dev = ADAP2RAIDDEV(adapter);\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: aborting cmd=%x <c=%d t=%d l=%d>\n",\r\nscp->cmnd[0], SCP2CHANNEL(scp),\r\nSCP2TARGET(scp), SCP2LUN(scp)));\r\nif (raid_dev->hw_error) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: hw error, not aborting\n"));\r\nreturn FAILED;\r\n}\r\nscb = NULL;\r\nspin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);\r\nlist_for_each_entry_safe(scb, tmp, &adapter->completed_list, list) {\r\nif (scb->scp == scp) {\r\nlist_del_init(&scb->list);\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: %d[%d:%d], abort from completed list\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\nscp->result = (DID_ABORT << 16);\r\nscp->scsi_done(scp);\r\nmegaraid_dealloc_scb(adapter, scb);\r\nspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter),\r\nflags);\r\nreturn SUCCESS;\r\n}\r\n}\r\nspin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);\r\nspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\r\nlist_for_each_entry_safe(scb, tmp, &adapter->pend_list, list) {\r\nif (scb->scp == scp) {\r\nlist_del_init(&scb->list);\r\nASSERT(!(scb->state & SCB_ISSUED));\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid abort: [%d:%d], driver owner\n",\r\nscb->dev_channel, scb->dev_target));\r\nscp->result = (DID_ABORT << 16);\r\nscp->scsi_done(scp);\r\nmegaraid_dealloc_scb(adapter, scb);\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),\r\nflags);\r\nreturn SUCCESS;\r\n}\r\n}\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\r\nfound = 0;\r\nspin_lock_irq(&adapter->lock);\r\nfor (i = 0; i < MBOX_MAX_SCSI_CMDS; i++) {\r\nscb = adapter->kscb_list + i;\r\nif (scb->scp == scp) {\r\nfound = 1;\r\nif (!(scb->state & SCB_ISSUED)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid abort: %d[%d:%d], invalid state\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\nBUG();\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid abort: %d[%d:%d], fw owner\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&adapter->lock);\r\nif (!found) {\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid abort: do now own\n"));\r\nreturn SUCCESS;\r\n}\r\nreturn FAILED;\r\n}\r\nstatic int\r\nmegaraid_reset_handler(struct scsi_cmnd *scp)\r\n{\r\nadapter_t *adapter;\r\nscb_t *scb;\r\nscb_t *tmp;\r\nmraid_device_t *raid_dev;\r\nunsigned long flags;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nint rval;\r\nint recovery_window;\r\nint recovering;\r\nint i;\r\nuioc_t *kioc;\r\nadapter = SCP2ADAPTER(scp);\r\nraid_dev = ADAP2RAIDDEV(adapter);\r\nif (raid_dev->hw_error) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: hw error, cannot reset\n"));\r\nreturn FAILED;\r\n}\r\nspin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);\r\nlist_for_each_entry_safe(scb, tmp, &adapter->pend_list, list) {\r\nlist_del_init(&scb->list);\r\nif (scb->sno >= MBOX_MAX_SCSI_CMDS) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: IOCTL packet with %d[%d:%d] being reset\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\nscb->status = -1;\r\nkioc = (uioc_t *)scb->gp;\r\nkioc->status = -EFAULT;\r\nmegaraid_mbox_mm_done(adapter, scb);\r\n} else {\r\nif (scb->scp == scp) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: %d[%d:%d], reset from pending list\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\n} else {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: IO packet with %d[%d:%d] being reset\n",\r\nscb->sno, scb->dev_channel, scb->dev_target));\r\n}\r\nscb->scp->result = (DID_RESET << 16);\r\nscb->scp->scsi_done(scb->scp);\r\nmegaraid_dealloc_scb(adapter, scb);\r\n}\r\n}\r\nspin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);\r\nif (adapter->outstanding_cmds) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: %d outstanding commands. Max wait %d sec\n",\r\nadapter->outstanding_cmds,\r\n(MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT)));\r\n}\r\nrecovery_window = MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT;\r\nrecovering = adapter->outstanding_cmds;\r\nfor (i = 0; i < recovery_window; i++) {\r\nmegaraid_ack_sequence(adapter);\r\nif (!(i % 5)) {\r\ncon_log(CL_ANN, (\r\n"megaraid mbox: Wait for %d commands to complete:%d\n",\r\nadapter->outstanding_cmds,\r\n(MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT) - i));\r\n}\r\nif (adapter->outstanding_cmds == 0) {\r\nbreak;\r\n}\r\nmsleep(1000);\r\n}\r\nspin_lock(&adapter->lock);\r\nif (adapter->outstanding_cmds) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mbox: critical hardware error!\n"));\r\nraid_dev->hw_error = 1;\r\nrval = FAILED;\r\ngoto out;\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid mbox: reset sequence completed successfully\n"));\r\n}\r\nif (!adapter->ha) {\r\nrval = SUCCESS;\r\ngoto out;\r\n}\r\nraw_mbox[0] = CLUSTER_CMD;\r\nraw_mbox[2] = RESET_RESERVATIONS;\r\nrval = SUCCESS;\r\nif (mbox_post_sync_cmd_fast(adapter, raw_mbox) == 0) {\r\ncon_log(CL_ANN,\r\n(KERN_INFO "megaraid: reservation reset\n"));\r\n}\r\nelse {\r\nrval = FAILED;\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: reservation reset failed\n"));\r\n}\r\nout:\r\nspin_unlock(&adapter->lock);\r\nreturn rval;\r\n}\r\nstatic int\r\nmbox_post_sync_cmd(adapter_t *adapter, uint8_t raw_mbox[])\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox64_t *mbox64;\r\nmbox_t *mbox;\r\nuint8_t status;\r\nint i;\r\nmbox64 = raid_dev->mbox64;\r\nmbox = raid_dev->mbox;\r\nif (megaraid_busywait_mbox(raid_dev) != 0)\r\ngoto blocked_mailbox;\r\nmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);\r\nmbox->cmdid = 0xFE;\r\nmbox->busy = 1;\r\nmbox->poll = 0;\r\nmbox->ack = 0;\r\nmbox->numstatus = 0xFF;\r\nmbox->status = 0xFF;\r\nwmb();\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\r\nif (mbox->numstatus == 0xFF) {\r\nudelay(25);\r\nfor (i = 0; mbox->numstatus == 0xFF && i < 1000; i++) {\r\nrmb();\r\nmsleep(1);\r\n}\r\nif (i == 1000) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid mailbox: wait for FW to boot "));\r\nfor (i = 0; (mbox->numstatus == 0xFF) &&\r\n(i < MBOX_RESET_WAIT); i++) {\r\nrmb();\r\ncon_log(CL_ANN, ("\b\b\b\b\b[%03d]",\r\nMBOX_RESET_WAIT - i));\r\nmsleep(1000);\r\n}\r\nif (i == MBOX_RESET_WAIT) {\r\ncon_log(CL_ANN, (\r\n"\nmegaraid mailbox: status not available\n"));\r\nreturn -1;\r\n}\r\ncon_log(CL_ANN, ("\b\b\b\b\b[ok] \n"));\r\n}\r\n}\r\nif (mbox->poll != 0x77) {\r\nudelay(25);\r\nfor (i = 0; (mbox->poll != 0x77) && (i < 1000); i++) {\r\nrmb();\r\nmsleep(1);\r\n}\r\nif (i == 1000) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mailbox: could not get poll semaphore\n"));\r\nreturn -1;\r\n}\r\n}\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);\r\nwmb();\r\nif (RDINDOOR(raid_dev) & 0x2) {\r\nudelay(25);\r\nfor (i = 0; (RDINDOOR(raid_dev) & 0x2) && (i < 1000); i++) {\r\nrmb();\r\nmsleep(1);\r\n}\r\nif (i == 1000) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mailbox: could not acknowledge\n"));\r\nreturn -1;\r\n}\r\n}\r\nmbox->poll = 0;\r\nmbox->ack = 0x77;\r\nstatus = mbox->status;\r\nmbox->numstatus = 0xFF;\r\nmbox->status = 0xFF;\r\nfor (i = 0; i < MBOX_MAX_FIRMWARE_STATUS; i++) {\r\nmbox->completed[i] = 0xFF;\r\n}\r\nreturn status;\r\nblocked_mailbox:\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid: blocked mailbox\n") );\r\nreturn -1;\r\n}\r\nstatic int\r\nmbox_post_sync_cmd_fast(adapter_t *adapter, uint8_t raw_mbox[])\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox_t *mbox;\r\nlong i;\r\nmbox = raid_dev->mbox;\r\nif (mbox->busy) return -1;\r\nmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 14);\r\nmbox->cmdid = 0xFE;\r\nmbox->busy = 1;\r\nmbox->poll = 0;\r\nmbox->ack = 0;\r\nmbox->numstatus = 0xFF;\r\nmbox->status = 0xFF;\r\nwmb();\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\r\nfor (i = 0; i < MBOX_SYNC_WAIT_CNT; i++) {\r\nif (mbox->numstatus != 0xFF) break;\r\nrmb();\r\nudelay(MBOX_SYNC_DELAY_200);\r\n}\r\nif (i == MBOX_SYNC_WAIT_CNT) {\r\ncon_log(CL_ANN, (KERN_CRIT\r\n"megaraid: fast sync command timed out\n"));\r\n}\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);\r\nwmb();\r\nreturn mbox->status;\r\n}\r\nstatic int\r\nmegaraid_busywait_mbox(mraid_device_t *raid_dev)\r\n{\r\nmbox_t *mbox = raid_dev->mbox;\r\nint i = 0;\r\nif (mbox->busy) {\r\nudelay(25);\r\nfor (i = 0; mbox->busy && i < 1000; i++)\r\nmsleep(1);\r\n}\r\nif (i < 1000) return 0;\r\nelse return -1;\r\n}\r\nstatic int\r\nmegaraid_mbox_product_info(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nmraid_pinfo_t *pinfo;\r\ndma_addr_t pinfo_dma_h;\r\nmraid_inquiry3_t *mraid_inq3;\r\nint i;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\r\nmbox = (mbox_t *)raw_mbox;\r\npinfo = pci_alloc_consistent(adapter->pdev, sizeof(mraid_pinfo_t),\r\n&pinfo_dma_h);\r\nif (pinfo == NULL) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\nreturn -1;\r\n}\r\nmemset(pinfo, 0, sizeof(mraid_pinfo_t));\r\nmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\r\nmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nraw_mbox[0] = FC_NEW_CONFIG;\r\nraw_mbox[2] = NC_SUBOP_ENQUIRY3;\r\nraw_mbox[3] = ENQ3_GET_SOLICITED_FULL;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid: Inquiry3 failed\n"));\r\npci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t),\r\npinfo, pinfo_dma_h);\r\nreturn -1;\r\n}\r\nmraid_inq3 = (mraid_inquiry3_t *)adapter->ibuf;\r\nfor (i = 0; i < MBOX_MAX_PHYSICAL_DRIVES; i++) {\r\nraid_dev->pdrv_state[i] = mraid_inq3->pdrv_state[i];\r\n}\r\nmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\r\nmbox->xferaddr = (uint32_t)pinfo_dma_h;\r\nraw_mbox[0] = FC_NEW_CONFIG;\r\nraw_mbox[2] = NC_SUBOP_PRODUCT_INFO;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: product info failed\n"));\r\npci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t),\r\npinfo, pinfo_dma_h);\r\nreturn -1;\r\n}\r\nadapter->max_channel = pinfo->nchannels;\r\nadapter->max_target = MAX_LOGICAL_DRIVES_40LD + 1;\r\nadapter->max_lun = 8;\r\nadapter->max_cmds = MBOX_MAX_SCSI_CMDS;\r\nmemset(adapter->fw_version, 0, VERSION_SIZE);\r\nmemset(adapter->bios_version, 0, VERSION_SIZE);\r\nmemcpy(adapter->fw_version, pinfo->fw_version, 4);\r\nadapter->fw_version[4] = 0;\r\nmemcpy(adapter->bios_version, pinfo->bios_version, 4);\r\nadapter->bios_version[4] = 0;\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: fw version:[%s] bios version:[%s]\n",\r\nadapter->fw_version, adapter->bios_version));\r\npci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t), pinfo,\r\npinfo_dma_h);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegaraid_mbox_extended_cdb(adapter_t *adapter)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nint rval;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\r\nmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\r\nmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nraw_mbox[0] = MAIN_MISC_OPCODE;\r\nraw_mbox[2] = SUPPORT_EXT_CDB;\r\nrval = 0;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\r\nrval = -1;\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_mbox_support_ha(adapter_t *adapter, uint16_t *init_id)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nint rval;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(raw_mbox));\r\nmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\r\nmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nraw_mbox[0] = GET_TARGET_ID;\r\n*init_id = 7;\r\nrval = -1;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\r\n*init_id = *(uint8_t *)adapter->ibuf;\r\ncon_log(CL_ANN, (KERN_INFO\r\n"megaraid: cluster firmware, initiator ID: %d\n",\r\n*init_id));\r\nrval = 0;\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_mbox_support_random_del(adapter_t *adapter)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nint rval;\r\nif (adapter->pdev->vendor == PCI_VENDOR_ID_AMI &&\r\nadapter->pdev->device == PCI_DEVICE_ID_AMI_MEGARAID3 &&\r\nadapter->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&\r\nadapter->pdev->subsystem_device == PCI_SUBSYS_ID_CERC_ATA100_4CH &&\r\n(adapter->fw_version[0] > '6' ||\r\n(adapter->fw_version[0] == '6' &&\r\nadapter->fw_version[2] > '6') ||\r\n(adapter->fw_version[0] == '6'\r\n&& adapter->fw_version[2] == '6'\r\n&& adapter->fw_version[3] > '1'))) {\r\ncon_log(CL_DLEVEL1, ("megaraid: disable random deletion\n"));\r\nreturn 0;\r\n}\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\r\nraw_mbox[0] = FC_DEL_LOGDRV;\r\nraw_mbox[2] = OP_SUP_DEL_LOGDRV;\r\nrval = 0;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\r\ncon_log(CL_DLEVEL1, ("megaraid: supports random deletion\n"));\r\nrval = 1;\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_mbox_get_max_sg(adapter_t *adapter)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nint nsg;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\r\nmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\r\nmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nraw_mbox[0] = MAIN_MISC_OPCODE;\r\nraw_mbox[2] = GET_MAX_SG_SUPPORT;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\r\nnsg = *(uint8_t *)adapter->ibuf;\r\n}\r\nelse {\r\nnsg = MBOX_DEFAULT_SG_SIZE;\r\n}\r\nif (nsg > MBOX_MAX_SG_SIZE) nsg = MBOX_MAX_SG_SIZE;\r\nreturn nsg;\r\n}\r\nstatic void\r\nmegaraid_mbox_enum_raid_scsi(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\r\nmbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;\r\nmemset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);\r\nraw_mbox[0] = CHNL_CLASS;\r\nraw_mbox[2] = GET_CHNL_CLASS;\r\nraid_dev->channel_class = 0xFF;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) == 0) {\r\nraid_dev->channel_class = *(uint8_t *)adapter->ibuf;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_flush_cache(adapter_t *adapter)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\r\nraw_mbox[0] = FLUSH_ADAPTER;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\r\ncon_log(CL_ANN, ("megaraid: flush adapter failed\n"));\r\n}\r\nraw_mbox[0] = FLUSH_SYSTEM;\r\nif (mbox_post_sync_cmd(adapter, raw_mbox) != 0) {\r\ncon_log(CL_ANN, ("megaraid: flush disks cache failed\n"));\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nmegaraid_mbox_fire_sync_cmd(adapter_t *adapter)\r\n{\r\nmbox_t *mbox;\r\nuint8_t raw_mbox[sizeof(mbox_t)];\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmbox64_t *mbox64;\r\nint status = 0;\r\nint i;\r\nuint32_t dword;\r\nmbox = (mbox_t *)raw_mbox;\r\nmemset((caddr_t)raw_mbox, 0, sizeof(mbox_t));\r\nraw_mbox[0] = 0xFF;\r\nmbox64 = raid_dev->mbox64;\r\nmbox = raid_dev->mbox;\r\nif (megaraid_busywait_mbox(raid_dev) != 0) {\r\nstatus = 1;\r\ngoto blocked_mailbox;\r\n}\r\nmemcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);\r\nmbox->cmdid = 0xFE;\r\nmbox->busy = 1;\r\nmbox->poll = 0;\r\nmbox->ack = 0;\r\nmbox->numstatus = 0;\r\nmbox->status = 0;\r\nwmb();\r\nWRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);\r\ni = 0;\r\nstatus = 0;\r\nwhile (!mbox->numstatus && mbox->cmd == 0xFF) {\r\nrmb();\r\nmsleep(1);\r\ni++;\r\nif (i > 1000 * 60) {\r\nstatus = 1;\r\nbreak;\r\n}\r\n}\r\nif (mbox->numstatus == 1)\r\nstatus = 1;\r\ndword = RDOUTDOOR(raid_dev);\r\nWROUTDOOR(raid_dev, dword);\r\nWRINDOOR(raid_dev,2);\r\nreturn status;\r\nblocked_mailbox:\r\ncon_log(CL_ANN, (KERN_WARNING "megaraid: blocked mailbox\n"));\r\nreturn status;\r\n}\r\nstatic void\r\nmegaraid_mbox_display_scb(adapter_t *adapter, scb_t *scb)\r\n{\r\nmbox_ccb_t *ccb;\r\nstruct scsi_cmnd *scp;\r\nmbox_t *mbox;\r\nint level;\r\nint i;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nscp = scb->scp;\r\nmbox = ccb->mbox;\r\nlevel = CL_DLEVEL3;\r\ncon_log(level, (KERN_NOTICE\r\n"megaraid mailbox: status:%#x cmd:%#x id:%#x ", scb->status,\r\nmbox->cmd, scb->sno));\r\ncon_log(level, ("sec:%#x lba:%#x addr:%#x ld:%d sg:%d\n",\r\nmbox->numsectors, mbox->lba, mbox->xferaddr, mbox->logdrv,\r\nmbox->numsge));\r\nif (!scp) return;\r\ncon_log(level, (KERN_NOTICE "scsi cmnd: "));\r\nfor (i = 0; i < scp->cmd_len; i++) {\r\ncon_log(level, ("%#2.02x ", scp->cmnd[i]));\r\n}\r\ncon_log(level, ("\n"));\r\nreturn;\r\n}\r\nstatic void\r\nmegaraid_mbox_setup_device_map(adapter_t *adapter)\r\n{\r\nuint8_t c;\r\nuint8_t t;\r\nfor (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)\r\nadapter->device_ids[adapter->max_channel][t] =\r\n(t < adapter->init_id) ? t : t - 1;\r\nadapter->device_ids[adapter->max_channel][adapter->init_id] = 0xFF;\r\nfor (c = 0; c < adapter->max_channel; c++)\r\nfor (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)\r\nadapter->device_ids[c][t] = (c << 8) | t;\r\n}\r\nstatic int\r\nmegaraid_cmm_register(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nmraid_mmadp_t adp;\r\nscb_t *scb;\r\nmbox_ccb_t *ccb;\r\nint rval;\r\nint i;\r\nadapter->uscb_list = kcalloc(MBOX_MAX_USER_CMDS, sizeof(scb_t), GFP_KERNEL);\r\nif (adapter->uscb_list == NULL) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\nreturn -1;\r\n}\r\nINIT_LIST_HEAD(&adapter->uscb_pool);\r\nspin_lock_init(USER_FREE_LIST_LOCK(adapter));\r\nfor (i = 0; i < MBOX_MAX_USER_CMDS; i++) {\r\nscb = adapter->uscb_list + i;\r\nccb = raid_dev->uccb_list + i;\r\nscb->ccb = (caddr_t)ccb;\r\nccb->mbox64 = raid_dev->umbox64 + i;\r\nccb->mbox = &ccb->mbox64->mbox32;\r\nccb->raw_mbox = (uint8_t *)ccb->mbox;\r\nscb->gp = 0;\r\nscb->sno = i + MBOX_MAX_SCSI_CMDS;\r\nscb->scp = NULL;\r\nscb->state = SCB_FREE;\r\nscb->dma_direction = PCI_DMA_NONE;\r\nscb->dma_type = MRAID_DMA_NONE;\r\nscb->dev_channel = -1;\r\nscb->dev_target = -1;\r\nlist_add_tail(&scb->list, &adapter->uscb_pool);\r\n}\r\nadp.unique_id = adapter->unique_id;\r\nadp.drvr_type = DRVRTYPE_MBOX;\r\nadp.drvr_data = (unsigned long)adapter;\r\nadp.pdev = adapter->pdev;\r\nadp.issue_uioc = megaraid_mbox_mm_handler;\r\nadp.timeout = MBOX_RESET_WAIT + MBOX_RESET_EXT_WAIT;\r\nadp.max_kioc = MBOX_MAX_USER_CMDS;\r\nif ((rval = mraid_mm_register_adp(&adp)) != 0) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mbox: did not register with CMM\n"));\r\nkfree(adapter->uscb_list);\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nmegaraid_cmm_unregister(adapter_t *adapter)\r\n{\r\nkfree(adapter->uscb_list);\r\nmraid_mm_unregister_adp(adapter->unique_id);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegaraid_mbox_mm_handler(unsigned long drvr_data, uioc_t *kioc, uint32_t action)\r\n{\r\nadapter_t *adapter;\r\nif (action != IOCTL_ISSUE) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: unsupported management action:%#2x\n",\r\naction));\r\nreturn (-ENOTSUPP);\r\n}\r\nadapter = (adapter_t *)drvr_data;\r\nif (atomic_read(&adapter->being_detached)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: reject management request, detaching\n"));\r\nreturn (-ENODEV);\r\n}\r\nswitch (kioc->opcode) {\r\ncase GET_ADAP_INFO:\r\nkioc->status = gather_hbainfo(adapter, (mraid_hba_info_t *)\r\n(unsigned long)kioc->buf_vaddr);\r\nkioc->done(kioc);\r\nreturn kioc->status;\r\ncase MBOX_CMD:\r\nreturn megaraid_mbox_mm_command(adapter, kioc);\r\ndefault:\r\nkioc->status = (-EINVAL);\r\nkioc->done(kioc);\r\nreturn (-EINVAL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegaraid_mbox_mm_command(adapter_t *adapter, uioc_t *kioc)\r\n{\r\nstruct list_head *head = &adapter->uscb_pool;\r\nmbox64_t *mbox64;\r\nuint8_t *raw_mbox;\r\nscb_t *scb;\r\nmbox_ccb_t *ccb;\r\nunsigned long flags;\r\nspin_lock_irqsave(USER_FREE_LIST_LOCK(adapter), flags);\r\nif (list_empty(head)) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid mbox: bug in cmm handler, lost resources\n"));\r\nspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\r\nreturn (-EINVAL);\r\n}\r\nscb = list_entry(head->next, scb_t, list);\r\nlist_del_init(&scb->list);\r\nspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\r\nscb->state = SCB_ACTIVE;\r\nscb->dma_type = MRAID_DMA_NONE;\r\nscb->dma_direction = PCI_DMA_NONE;\r\nccb = (mbox_ccb_t *)scb->ccb;\r\nmbox64 = (mbox64_t *)(unsigned long)kioc->cmdbuf;\r\nraw_mbox = (uint8_t *)&mbox64->mbox32;\r\nmemcpy(ccb->mbox64, mbox64, sizeof(mbox64_t));\r\nscb->gp = (unsigned long)kioc;\r\nif (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {\r\nif (wait_till_fw_empty(adapter)) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid mbox: LD delete, timed out\n"));\r\nkioc->status = -ETIME;\r\nscb->status = -1;\r\nmegaraid_mbox_mm_done(adapter, scb);\r\nreturn (-ETIME);\r\n}\r\nINIT_LIST_HEAD(&scb->list);\r\nscb->state = SCB_ISSUED;\r\nif (mbox_post_cmd(adapter, scb) != 0) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid mbox: LD delete, mailbox busy\n"));\r\nkioc->status = -EBUSY;\r\nscb->status = -1;\r\nmegaraid_mbox_mm_done(adapter, scb);\r\nreturn (-EBUSY);\r\n}\r\nreturn 0;\r\n}\r\nmegaraid_mbox_runpendq(adapter, scb);\r\nreturn 0;\r\n}\r\nstatic int\r\nwait_till_fw_empty(adapter_t *adapter)\r\n{\r\nunsigned long flags = 0;\r\nint i;\r\nspin_lock_irqsave(&adapter->lock, flags);\r\nadapter->quiescent++;\r\nspin_unlock_irqrestore(&adapter->lock, flags);\r\nfor (i = 0; i < 60 && adapter->outstanding_cmds; i++) {\r\ncon_log(CL_DLEVEL1, (KERN_INFO\r\n"megaraid: FW has %d pending commands\n",\r\nadapter->outstanding_cmds));\r\nmsleep(1000);\r\n}\r\nreturn adapter->outstanding_cmds;\r\n}\r\nstatic void\r\nmegaraid_mbox_mm_done(adapter_t *adapter, scb_t *scb)\r\n{\r\nuioc_t *kioc;\r\nmbox64_t *mbox64;\r\nuint8_t *raw_mbox;\r\nunsigned long flags;\r\nkioc = (uioc_t *)scb->gp;\r\nmbox64 = (mbox64_t *)(unsigned long)kioc->cmdbuf;\r\nmbox64->mbox32.status = scb->status;\r\nraw_mbox = (uint8_t *)&mbox64->mbox32;\r\nscb->state = SCB_FREE;\r\nscb->scp = NULL;\r\nspin_lock_irqsave(USER_FREE_LIST_LOCK(adapter), flags);\r\nlist_add(&scb->list, &adapter->uscb_pool);\r\nspin_unlock_irqrestore(USER_FREE_LIST_LOCK(adapter), flags);\r\nif (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {\r\nadapter->quiescent--;\r\nmegaraid_mbox_runpendq(adapter, NULL);\r\n}\r\nkioc->done(kioc);\r\nreturn;\r\n}\r\nstatic int\r\ngather_hbainfo(adapter_t *adapter, mraid_hba_info_t *hinfo)\r\n{\r\nuint8_t dmajor;\r\ndmajor = megaraid_mbox_version[0];\r\nhinfo->pci_vendor_id = adapter->pdev->vendor;\r\nhinfo->pci_device_id = adapter->pdev->device;\r\nhinfo->subsys_vendor_id = adapter->pdev->subsystem_vendor;\r\nhinfo->subsys_device_id = adapter->pdev->subsystem_device;\r\nhinfo->pci_bus = adapter->pdev->bus->number;\r\nhinfo->pci_dev_fn = adapter->pdev->devfn;\r\nhinfo->pci_slot = PCI_SLOT(adapter->pdev->devfn);\r\nhinfo->irq = adapter->host->irq;\r\nhinfo->baseport = ADAP2RAIDDEV(adapter)->baseport;\r\nhinfo->unique_id = (hinfo->pci_bus << 8) | adapter->pdev->devfn;\r\nhinfo->host_no = adapter->host->host_no;\r\nreturn 0;\r\n}\r\nstatic int\r\nmegaraid_sysfs_alloc_resources(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nint rval = 0;\r\nraid_dev->sysfs_uioc = kmalloc(sizeof(uioc_t), GFP_KERNEL);\r\nraid_dev->sysfs_mbox64 = kmalloc(sizeof(mbox64_t), GFP_KERNEL);\r\nraid_dev->sysfs_buffer = pci_alloc_consistent(adapter->pdev,\r\nPAGE_SIZE, &raid_dev->sysfs_buffer_dma);\r\nif (!raid_dev->sysfs_uioc || !raid_dev->sysfs_mbox64 ||\r\n!raid_dev->sysfs_buffer) {\r\ncon_log(CL_ANN, (KERN_WARNING\r\n"megaraid: out of memory, %s %d\n", __func__,\r\n__LINE__));\r\nrval = -ENOMEM;\r\nmegaraid_sysfs_free_resources(adapter);\r\n}\r\nmutex_init(&raid_dev->sysfs_mtx);\r\ninit_waitqueue_head(&raid_dev->sysfs_wait_q);\r\nreturn rval;\r\n}\r\nstatic void\r\nmegaraid_sysfs_free_resources(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nkfree(raid_dev->sysfs_uioc);\r\nkfree(raid_dev->sysfs_mbox64);\r\nif (raid_dev->sysfs_buffer) {\r\npci_free_consistent(adapter->pdev, PAGE_SIZE,\r\nraid_dev->sysfs_buffer, raid_dev->sysfs_buffer_dma);\r\n}\r\n}\r\nstatic void\r\nmegaraid_sysfs_get_ldmap_done(uioc_t *uioc)\r\n{\r\nadapter_t *adapter = (adapter_t *)uioc->buf_vaddr;\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nuioc->status = 0;\r\nwake_up(&raid_dev->sysfs_wait_q);\r\n}\r\nstatic void\r\nmegaraid_sysfs_get_ldmap_timeout(unsigned long data)\r\n{\r\nuioc_t *uioc = (uioc_t *)data;\r\nadapter_t *adapter = (adapter_t *)uioc->buf_vaddr;\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nuioc->status = -ETIME;\r\nwake_up(&raid_dev->sysfs_wait_q);\r\n}\r\nstatic int\r\nmegaraid_sysfs_get_ldmap(adapter_t *adapter)\r\n{\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nuioc_t *uioc;\r\nmbox64_t *mbox64;\r\nmbox_t *mbox;\r\nchar *raw_mbox;\r\nstruct timer_list sysfs_timer;\r\nstruct timer_list *timerp;\r\ncaddr_t ldmap;\r\nint rval = 0;\r\nmutex_lock(&raid_dev->sysfs_mtx);\r\nuioc = raid_dev->sysfs_uioc;\r\nmbox64 = raid_dev->sysfs_mbox64;\r\nldmap = raid_dev->sysfs_buffer;\r\nmemset(uioc, 0, sizeof(uioc_t));\r\nmemset(mbox64, 0, sizeof(mbox64_t));\r\nmemset(ldmap, 0, sizeof(raid_dev->curr_ldmap));\r\nmbox = &mbox64->mbox32;\r\nraw_mbox = (char *)mbox;\r\nuioc->cmdbuf = (uint64_t)(unsigned long)mbox64;\r\nuioc->buf_vaddr = (caddr_t)adapter;\r\nuioc->status = -ENODATA;\r\nuioc->done = megaraid_sysfs_get_ldmap_done;\r\nmbox->xferaddr = (uint32_t)raid_dev->sysfs_buffer_dma;\r\nraw_mbox[0] = FC_DEL_LOGDRV;\r\nraw_mbox[2] = OP_GET_LDID_MAP;\r\ntimerp = &sysfs_timer;\r\ninit_timer(timerp);\r\ntimerp->function = megaraid_sysfs_get_ldmap_timeout;\r\ntimerp->data = (unsigned long)uioc;\r\ntimerp->expires = jiffies + 60 * HZ;\r\nadd_timer(timerp);\r\nrval = megaraid_mbox_mm_command(adapter, uioc);\r\nif (rval == 0) {\r\nwait_event(raid_dev->sysfs_wait_q, (uioc->status != -ENODATA));\r\nif (uioc->status == -ETIME) {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: sysfs get ld map timed out\n"));\r\nrval = -ETIME;\r\n}\r\nelse {\r\nrval = mbox->status;\r\n}\r\nif (rval == 0) {\r\nmemcpy(raid_dev->curr_ldmap, ldmap,\r\nsizeof(raid_dev->curr_ldmap));\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: get ld map failed with %x\n", rval));\r\n}\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: could not issue ldmap command:%x\n", rval));\r\n}\r\ndel_timer_sync(timerp);\r\nmutex_unlock(&raid_dev->sysfs_mtx);\r\nreturn rval;\r\n}\r\nstatic ssize_t\r\nmegaraid_sysfs_show_app_hndl(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nadapter_t *adapter = (adapter_t *)SCSIHOST2ADAP(shost);\r\nuint32_t app_hndl;\r\napp_hndl = mraid_mm_adapter_app_handle(adapter->unique_id);\r\nreturn snprintf(buf, 8, "%u\n", app_hndl);\r\n}\r\nstatic ssize_t\r\nmegaraid_sysfs_show_ldnum(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nadapter_t *adapter = (adapter_t *)SCSIHOST2ADAP(sdev->host);\r\nmraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);\r\nint scsi_id = -1;\r\nint logical_drv = -1;\r\nint ldid_map = -1;\r\nuint32_t app_hndl = 0;\r\nint mapped_sdev_id;\r\nint rval;\r\nint i;\r\nif (raid_dev->random_del_supported &&\r\nMRAID_IS_LOGICAL_SDEV(adapter, sdev)) {\r\nrval = megaraid_sysfs_get_ldmap(adapter);\r\nif (rval == 0) {\r\nfor (i = 0; i < MAX_LOGICAL_DRIVES_40LD; i++) {\r\nmapped_sdev_id = sdev->id;\r\nif (sdev->id > adapter->init_id) {\r\nmapped_sdev_id -= 1;\r\n}\r\nif (raid_dev->curr_ldmap[i] == mapped_sdev_id) {\r\nscsi_id = sdev->id;\r\nlogical_drv = i;\r\nldid_map = raid_dev->curr_ldmap[i];\r\napp_hndl = mraid_mm_adapter_app_handle(\r\nadapter->unique_id);\r\nbreak;\r\n}\r\n}\r\n}\r\nelse {\r\ncon_log(CL_ANN, (KERN_NOTICE\r\n"megaraid: sysfs get ld map failed: %x\n",\r\nrval));\r\n}\r\n}\r\nreturn snprintf(buf, 36, "%d %d %d %d\n", scsi_id, logical_drv,\r\nldid_map, app_hndl);\r\n}
