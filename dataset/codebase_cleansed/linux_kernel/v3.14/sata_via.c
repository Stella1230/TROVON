static int svia_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\n*val = ioread32(link->ap->ioaddr.scr_addr + (4 * sc_reg));\r\nreturn 0;\r\n}\r\nstatic int svia_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\r\n{\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\niowrite32(val, link->ap->ioaddr.scr_addr + (4 * sc_reg));\r\nreturn 0;\r\n}\r\nstatic int vt8251_scr_read(struct ata_link *link, unsigned int scr, u32 *val)\r\n{\r\nstatic const u8 ipm_tbl[] = { 1, 2, 6, 0 };\r\nstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\r\nint slot = 2 * link->ap->port_no + link->pmp;\r\nu32 v = 0;\r\nu8 raw;\r\nswitch (scr) {\r\ncase SCR_STATUS:\r\npci_read_config_byte(pdev, 0xA0 + slot, &raw);\r\nv |= raw & 0x03;\r\nif (raw & (1 << 4))\r\nv |= 0x02 << 4;\r\nelse\r\nv |= 0x01 << 4;\r\nv |= ipm_tbl[(raw >> 2) & 0x3];\r\nbreak;\r\ncase SCR_ERROR:\r\nWARN_ON(pdev->device != 0x5287);\r\npci_read_config_dword(pdev, 0xB0 + slot * 4, &v);\r\nbreak;\r\ncase SCR_CONTROL:\r\npci_read_config_byte(pdev, 0xA4 + slot, &raw);\r\nv |= ((raw & 0x02) << 1) | (raw & 0x01);\r\nv |= ((raw >> 2) & 0x03) << 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*val = v;\r\nreturn 0;\r\n}\r\nstatic int vt8251_scr_write(struct ata_link *link, unsigned int scr, u32 val)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\r\nint slot = 2 * link->ap->port_no + link->pmp;\r\nu32 v = 0;\r\nswitch (scr) {\r\ncase SCR_ERROR:\r\nWARN_ON(pdev->device != 0x5287);\r\npci_write_config_dword(pdev, 0xB0 + slot * 4, val);\r\nreturn 0;\r\ncase SCR_CONTROL:\r\nv |= ((val & 0x4) >> 1) | (val & 0x1);\r\nv |= ((val >> 8) & 0x3) << 2;\r\npci_write_config_byte(pdev, 0xA4 + slot, v);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void svia_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nstruct ata_taskfile ttf;\r\nif (tf->ctl != ap->last_ctl) {\r\nttf = *tf;\r\nttf.flags |= ATA_TFLAG_DEVICE;\r\ntf = &ttf;\r\n}\r\nata_sff_tf_load(ap, tf);\r\n}\r\nstatic void svia_noop_freeze(struct ata_port *ap)\r\n{\r\nap->ops->sff_check_status(ap);\r\nata_bmdma_irq_clear(ap);\r\n}\r\nstatic int vt6420_prereset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_eh_context *ehc = &ap->link.eh_context;\r\nunsigned long timeout = jiffies + (HZ * 5);\r\nu32 sstatus, scontrol;\r\nint online;\r\nif (!(ap->pflags & ATA_PFLAG_LOADING))\r\ngoto skip_scr;\r\nsvia_scr_write(link, SCR_CONTROL, 0x300);\r\nsvia_scr_read(link, SCR_CONTROL, &scontrol);\r\ndo {\r\nata_msleep(link->ap, 200);\r\nsvia_scr_read(link, SCR_STATUS, &sstatus);\r\nif ((sstatus & 0xf) != 1)\r\nbreak;\r\n} while (time_before(jiffies, timeout));\r\nsvia_scr_read(link, SCR_STATUS, &sstatus);\r\nsvia_scr_read(link, SCR_CONTROL, &scontrol);\r\nonline = (sstatus & 0xf) == 0x3;\r\nata_port_info(ap,\r\n"SATA link %s 1.5 Gbps (SStatus %X SControl %X)\n",\r\nonline ? "up" : "down", sstatus, scontrol);\r\nsvia_scr_read(link, SCR_STATUS, &sstatus);\r\nif (!online) {\r\nehc->i.action &= ~ATA_EH_RESET;\r\nreturn 0;\r\n}\r\nskip_scr:\r\nata_sff_wait_ready(link, deadline);\r\nreturn 0;\r\n}\r\nstatic void vt6420_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nif ((qc->tf.command == ATA_CMD_PACKET) &&\r\n(qc->scsicmd->sc_data_direction == DMA_TO_DEVICE)) {\r\nata_sff_pause(ap);\r\n}\r\nata_bmdma_start(qc);\r\n}\r\nstatic int vt6421_pata_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu8 tmp;\r\npci_read_config_byte(pdev, PATA_UDMA_TIMING, &tmp);\r\nif (tmp & 0x10)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void vt6421_set_pio_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const u8 pio_bits[] = { 0xA8, 0x65, 0x65, 0x31, 0x20 };\r\npci_write_config_byte(pdev, PATA_PIO_TIMING - adev->devno,\r\npio_bits[adev->pio_mode - XFER_PIO_0]);\r\n}\r\nstatic void vt6421_set_dma_mode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const u8 udma_bits[] = { 0xEE, 0xE8, 0xE6, 0xE4, 0xE2, 0xE1, 0xE0, 0xE0 };\r\npci_write_config_byte(pdev, PATA_UDMA_TIMING - adev->devno,\r\nudma_bits[adev->dma_mode - XFER_UDMA_0]);\r\n}\r\nstatic void __iomem *svia_scr_addr(void __iomem *addr, unsigned int port)\r\n{\r\nreturn addr + (port * 128);\r\n}\r\nstatic void __iomem *vt6421_scr_addr(void __iomem *addr, unsigned int port)\r\n{\r\nreturn addr + (port * 64);\r\n}\r\nstatic void vt6421_init_addrs(struct ata_port *ap)\r\n{\r\nvoid __iomem * const * iomap = ap->host->iomap;\r\nvoid __iomem *reg_addr = iomap[ap->port_no];\r\nvoid __iomem *bmdma_addr = iomap[4] + (ap->port_no * 8);\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nioaddr->cmd_addr = reg_addr;\r\nioaddr->altstatus_addr =\r\nioaddr->ctl_addr = (void __iomem *)\r\n((unsigned long)(reg_addr + 8) | ATA_PCI_CTL_OFS);\r\nioaddr->bmdma_addr = bmdma_addr;\r\nioaddr->scr_addr = vt6421_scr_addr(iomap[5], ap->port_no);\r\nata_sff_std_ports(ioaddr);\r\nata_port_pbar_desc(ap, ap->port_no, -1, "port");\r\nata_port_pbar_desc(ap, 4, ap->port_no * 8, "bmdma");\r\n}\r\nstatic int vt6420_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\r\n{\r\nconst struct ata_port_info *ppi[] = { &vt6420_port_info, NULL };\r\nstruct ata_host *host;\r\nint rc;\r\nrc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\r\nif (rc)\r\nreturn rc;\r\n*r_host = host;\r\nrc = pcim_iomap_regions(pdev, 1 << 5, DRV_NAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to iomap PCI BAR 5\n");\r\nreturn rc;\r\n}\r\nhost->ports[0]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 0);\r\nhost->ports[1]->ioaddr.scr_addr = svia_scr_addr(host->iomap[5], 1);\r\nreturn 0;\r\n}\r\nstatic int vt6421_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\r\n{\r\nconst struct ata_port_info *ppi[] =\r\n{ &vt6421_sport_info, &vt6421_sport_info, &vt6421_pport_info };\r\nstruct ata_host *host;\r\nint i, rc;\r\n*r_host = host = ata_host_alloc_pinfo(&pdev->dev, ppi, ARRAY_SIZE(ppi));\r\nif (!host) {\r\ndev_err(&pdev->dev, "failed to allocate host\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = pcim_iomap_regions(pdev, 0x3f, DRV_NAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to request/iomap PCI BARs (errno=%d)\n",\r\nrc);\r\nreturn rc;\r\n}\r\nhost->iomap = pcim_iomap_table(pdev);\r\nfor (i = 0; i < host->n_ports; i++)\r\nvt6421_init_addrs(host->ports[i]);\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int vt8251_prepare_host(struct pci_dev *pdev, struct ata_host **r_host)\r\n{\r\nconst struct ata_port_info *ppi[] = { &vt8251_port_info, NULL };\r\nstruct ata_host *host;\r\nint i, rc;\r\nrc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\r\nif (rc)\r\nreturn rc;\r\n*r_host = host;\r\nrc = pcim_iomap_regions(pdev, 1 << 5, DRV_NAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to iomap PCI BAR 5\n");\r\nreturn rc;\r\n}\r\nfor (i = 0; i < host->n_ports; i++)\r\nata_slave_link_init(host->ports[i]);\r\nreturn 0;\r\n}\r\nstatic void svia_configure(struct pci_dev *pdev, int board_id)\r\n{\r\nu8 tmp8;\r\npci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &tmp8);\r\ndev_info(&pdev->dev, "routed to hard irq line %d\n",\r\n(int) (tmp8 & 0xf0) == 0xf0 ? 0 : tmp8 & 0x0f);\r\npci_read_config_byte(pdev, SATA_CHAN_ENAB, &tmp8);\r\nif ((tmp8 & ALL_PORTS) != ALL_PORTS) {\r\ndev_dbg(&pdev->dev, "enabling SATA channels (0x%x)\n",\r\n(int)tmp8);\r\ntmp8 |= ALL_PORTS;\r\npci_write_config_byte(pdev, SATA_CHAN_ENAB, tmp8);\r\n}\r\npci_read_config_byte(pdev, SATA_INT_GATE, &tmp8);\r\nif ((tmp8 & ALL_PORTS) != ALL_PORTS) {\r\ndev_dbg(&pdev->dev, "enabling SATA channel interrupts (0x%x)\n",\r\n(int) tmp8);\r\ntmp8 |= ALL_PORTS;\r\npci_write_config_byte(pdev, SATA_INT_GATE, tmp8);\r\n}\r\npci_read_config_byte(pdev, SATA_NATIVE_MODE, &tmp8);\r\nif ((tmp8 & NATIVE_MODE_ALL) != NATIVE_MODE_ALL) {\r\ndev_dbg(&pdev->dev,\r\n"enabling SATA channel native mode (0x%x)\n",\r\n(int) tmp8);\r\ntmp8 |= NATIVE_MODE_ALL;\r\npci_write_config_byte(pdev, SATA_NATIVE_MODE, tmp8);\r\n}\r\nif (board_id == vt6420 || board_id == vt6421) {\r\npci_read_config_byte(pdev, 0x52, &tmp8);\r\ntmp8 |= 1 << 2;\r\npci_write_config_byte(pdev, 0x52, tmp8);\r\n}\r\n}\r\nstatic int svia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int i;\r\nint rc;\r\nstruct ata_host *host = NULL;\r\nint board_id = (int) ent->driver_data;\r\nconst unsigned *bar_sizes;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (board_id == vt6421)\r\nbar_sizes = &vt6421_bar_sizes[0];\r\nelse\r\nbar_sizes = &svia_bar_sizes[0];\r\nfor (i = 0; i < ARRAY_SIZE(svia_bar_sizes); i++)\r\nif ((pci_resource_start(pdev, i) == 0) ||\r\n(pci_resource_len(pdev, i) < bar_sizes[i])) {\r\ndev_err(&pdev->dev,\r\n"invalid PCI BAR %u (sz 0x%llx, val 0x%llx)\n",\r\ni,\r\n(unsigned long long)pci_resource_start(pdev, i),\r\n(unsigned long long)pci_resource_len(pdev, i));\r\nreturn -ENODEV;\r\n}\r\nswitch (board_id) {\r\ncase vt6420:\r\nrc = vt6420_prepare_host(pdev, &host);\r\nbreak;\r\ncase vt6421:\r\nrc = vt6421_prepare_host(pdev, &host);\r\nbreak;\r\ncase vt8251:\r\nrc = vt8251_prepare_host(pdev, &host);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nif (rc)\r\nreturn rc;\r\nsvia_configure(pdev, board_id);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &svia_sht);\r\n}
