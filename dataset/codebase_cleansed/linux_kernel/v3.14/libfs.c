static inline int simple_positive(struct dentry *dentry)\r\n{\r\nreturn dentry->d_inode && !d_unhashed(dentry);\r\n}\r\nint simple_getattr(struct vfsmount *mnt, struct dentry *dentry,\r\nstruct kstat *stat)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\ngeneric_fillattr(inode, stat);\r\nstat->blocks = inode->i_mapping->nrpages << (PAGE_CACHE_SHIFT - 9);\r\nreturn 0;\r\n}\r\nint simple_statfs(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nbuf->f_type = dentry->d_sb->s_magic;\r\nbuf->f_bsize = PAGE_CACHE_SIZE;\r\nbuf->f_namelen = NAME_MAX;\r\nreturn 0;\r\n}\r\nint always_delete_dentry(const struct dentry *dentry)\r\n{\r\nreturn 1;\r\n}\r\nstruct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nif (dentry->d_name.len > NAME_MAX)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nif (!dentry->d_sb->s_d_op)\r\nd_set_d_op(dentry, &simple_dentry_operations);\r\nd_add(dentry, NULL);\r\nreturn NULL;\r\n}\r\nint dcache_dir_open(struct inode *inode, struct file *file)\r\n{\r\nstatic struct qstr cursor_name = QSTR_INIT(".", 1);\r\nfile->private_data = d_alloc(file->f_path.dentry, &cursor_name);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nint dcache_dir_close(struct inode *inode, struct file *file)\r\n{\r\ndput(file->private_data);\r\nreturn 0;\r\n}\r\nloff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nswitch (whence) {\r\ncase 1:\r\noffset += file->f_pos;\r\ncase 0:\r\nif (offset >= 0)\r\nbreak;\r\ndefault:\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nreturn -EINVAL;\r\n}\r\nif (offset != file->f_pos) {\r\nfile->f_pos = offset;\r\nif (file->f_pos >= 2) {\r\nstruct list_head *p;\r\nstruct dentry *cursor = file->private_data;\r\nloff_t n = file->f_pos - 2;\r\nspin_lock(&dentry->d_lock);\r\nlist_del(&cursor->d_u.d_child);\r\np = dentry->d_subdirs.next;\r\nwhile (n && p != &dentry->d_subdirs) {\r\nstruct dentry *next;\r\nnext = list_entry(p, struct dentry, d_u.d_child);\r\nspin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (simple_positive(next))\r\nn--;\r\nspin_unlock(&next->d_lock);\r\np = p->next;\r\n}\r\nlist_add_tail(&cursor->d_u.d_child, p);\r\nspin_unlock(&dentry->d_lock);\r\n}\r\n}\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nreturn offset;\r\n}\r\nstatic inline unsigned char dt_type(struct inode *inode)\r\n{\r\nreturn (inode->i_mode >> 12) & 15;\r\n}\r\nint dcache_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct dentry *cursor = file->private_data;\r\nstruct list_head *p, *q = &cursor->d_u.d_child;\r\nif (!dir_emit_dots(file, ctx))\r\nreturn 0;\r\nspin_lock(&dentry->d_lock);\r\nif (ctx->pos == 2)\r\nlist_move(q, &dentry->d_subdirs);\r\nfor (p = q->next; p != &dentry->d_subdirs; p = p->next) {\r\nstruct dentry *next = list_entry(p, struct dentry, d_u.d_child);\r\nspin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (!simple_positive(next)) {\r\nspin_unlock(&next->d_lock);\r\ncontinue;\r\n}\r\nspin_unlock(&next->d_lock);\r\nspin_unlock(&dentry->d_lock);\r\nif (!dir_emit(ctx, next->d_name.name, next->d_name.len,\r\nnext->d_inode->i_ino, dt_type(next->d_inode)))\r\nreturn 0;\r\nspin_lock(&dentry->d_lock);\r\nspin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);\r\nlist_move(q, p);\r\nspin_unlock(&next->d_lock);\r\np = q;\r\nctx->pos++;\r\n}\r\nspin_unlock(&dentry->d_lock);\r\nreturn 0;\r\n}\r\nssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)\r\n{\r\nreturn -EISDIR;\r\n}\r\nstruct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\r\nconst struct super_operations *ops,\r\nconst struct dentry_operations *dops, unsigned long magic)\r\n{\r\nstruct super_block *s;\r\nstruct dentry *dentry;\r\nstruct inode *root;\r\nstruct qstr d_name = QSTR_INIT(name, strlen(name));\r\ns = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\r\nif (IS_ERR(s))\r\nreturn ERR_CAST(s);\r\ns->s_maxbytes = MAX_LFS_FILESIZE;\r\ns->s_blocksize = PAGE_SIZE;\r\ns->s_blocksize_bits = PAGE_SHIFT;\r\ns->s_magic = magic;\r\ns->s_op = ops ? ops : &simple_super_operations;\r\ns->s_time_gran = 1;\r\nroot = new_inode(s);\r\nif (!root)\r\ngoto Enomem;\r\nroot->i_ino = 1;\r\nroot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\r\nroot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\r\ndentry = __d_alloc(s, &d_name);\r\nif (!dentry) {\r\niput(root);\r\ngoto Enomem;\r\n}\r\nd_instantiate(dentry, root);\r\ns->s_root = dentry;\r\ns->s_d_op = dops;\r\ns->s_flags |= MS_ACTIVE;\r\nreturn dget(s->s_root);\r\nEnomem:\r\ndeactivate_locked_super(s);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nint simple_open(struct inode *inode, struct file *file)\r\n{\r\nif (inode->i_private)\r\nfile->private_data = inode->i_private;\r\nreturn 0;\r\n}\r\nint simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = old_dentry->d_inode;\r\ninode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\r\ninc_nlink(inode);\r\nihold(inode);\r\ndget(dentry);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\n}\r\nint simple_empty(struct dentry *dentry)\r\n{\r\nstruct dentry *child;\r\nint ret = 0;\r\nspin_lock(&dentry->d_lock);\r\nlist_for_each_entry(child, &dentry->d_subdirs, d_u.d_child) {\r\nspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\r\nif (simple_positive(child)) {\r\nspin_unlock(&child->d_lock);\r\ngoto out;\r\n}\r\nspin_unlock(&child->d_lock);\r\n}\r\nret = 1;\r\nout:\r\nspin_unlock(&dentry->d_lock);\r\nreturn ret;\r\n}\r\nint simple_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\ninode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;\r\ndrop_nlink(inode);\r\ndput(dentry);\r\nreturn 0;\r\n}\r\nint simple_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nif (!simple_empty(dentry))\r\nreturn -ENOTEMPTY;\r\ndrop_nlink(dentry->d_inode);\r\nsimple_unlink(dir, dentry);\r\ndrop_nlink(dir);\r\nreturn 0;\r\n}\r\nint simple_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry)\r\n{\r\nstruct inode *inode = old_dentry->d_inode;\r\nint they_are_dirs = S_ISDIR(old_dentry->d_inode->i_mode);\r\nif (!simple_empty(new_dentry))\r\nreturn -ENOTEMPTY;\r\nif (new_dentry->d_inode) {\r\nsimple_unlink(new_dir, new_dentry);\r\nif (they_are_dirs) {\r\ndrop_nlink(new_dentry->d_inode);\r\ndrop_nlink(old_dir);\r\n}\r\n} else if (they_are_dirs) {\r\ndrop_nlink(old_dir);\r\ninc_nlink(new_dir);\r\n}\r\nold_dir->i_ctime = old_dir->i_mtime = new_dir->i_ctime =\r\nnew_dir->i_mtime = inode->i_ctime = CURRENT_TIME;\r\nreturn 0;\r\n}\r\nint simple_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nerror = inode_change_ok(inode, iattr);\r\nif (error)\r\nreturn error;\r\nif (iattr->ia_valid & ATTR_SIZE)\r\ntruncate_setsize(inode, iattr->ia_size);\r\nsetattr_copy(inode, iattr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nint simple_readpage(struct file *file, struct page *page)\r\n{\r\nclear_highpage(page);\r\nflush_dcache_page(page);\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\nreturn 0;\r\n}\r\nint simple_write_begin(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nstruct page *page;\r\npgoff_t index;\r\nindex = pos >> PAGE_CACHE_SHIFT;\r\npage = grab_cache_page_write_begin(mapping, index, flags);\r\nif (!page)\r\nreturn -ENOMEM;\r\n*pagep = page;\r\nif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\r\nunsigned from = pos & (PAGE_CACHE_SIZE - 1);\r\nzero_user_segments(page, 0, from, from + len, PAGE_CACHE_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nint simple_write_end(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nloff_t last_pos = pos + copied;\r\nif (copied < len) {\r\nunsigned from = pos & (PAGE_CACHE_SIZE - 1);\r\nzero_user(page, from + copied, len - copied);\r\n}\r\nif (!PageUptodate(page))\r\nSetPageUptodate(page);\r\nif (last_pos > inode->i_size)\r\ni_size_write(inode, last_pos);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\npage_cache_release(page);\r\nreturn copied;\r\n}\r\nint simple_fill_super(struct super_block *s, unsigned long magic,\r\nstruct tree_descr *files)\r\n{\r\nstruct inode *inode;\r\nstruct dentry *root;\r\nstruct dentry *dentry;\r\nint i;\r\ns->s_blocksize = PAGE_CACHE_SIZE;\r\ns->s_blocksize_bits = PAGE_CACHE_SHIFT;\r\ns->s_magic = magic;\r\ns->s_op = &simple_super_operations;\r\ns->s_time_gran = 1;\r\ninode = new_inode(s);\r\nif (!inode)\r\nreturn -ENOMEM;\r\ninode->i_ino = 1;\r\ninode->i_mode = S_IFDIR | 0755;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_op = &simple_dir_inode_operations;\r\ninode->i_fop = &simple_dir_operations;\r\nset_nlink(inode, 2);\r\nroot = d_make_root(inode);\r\nif (!root)\r\nreturn -ENOMEM;\r\nfor (i = 0; !files->name || files->name[0]; i++, files++) {\r\nif (!files->name)\r\ncontinue;\r\nif (unlikely(i == 1))\r\nprintk(KERN_WARNING "%s: %s passed in a files array"\r\n"with an index of 1!\n", __func__,\r\ns->s_type->name);\r\ndentry = d_alloc_name(root, files->name);\r\nif (!dentry)\r\ngoto out;\r\ninode = new_inode(s);\r\nif (!inode) {\r\ndput(dentry);\r\ngoto out;\r\n}\r\ninode->i_mode = S_IFREG | files->mode;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_fop = files->ops;\r\ninode->i_ino = i;\r\nd_add(dentry, inode);\r\n}\r\ns->s_root = root;\r\nreturn 0;\r\nout:\r\nd_genocide(root);\r\nshrink_dcache_parent(root);\r\ndput(root);\r\nreturn -ENOMEM;\r\n}\r\nint simple_pin_fs(struct file_system_type *type, struct vfsmount **mount, int *count)\r\n{\r\nstruct vfsmount *mnt = NULL;\r\nspin_lock(&pin_fs_lock);\r\nif (unlikely(!*mount)) {\r\nspin_unlock(&pin_fs_lock);\r\nmnt = vfs_kern_mount(type, MS_KERNMOUNT, type->name, NULL);\r\nif (IS_ERR(mnt))\r\nreturn PTR_ERR(mnt);\r\nspin_lock(&pin_fs_lock);\r\nif (!*mount)\r\n*mount = mnt;\r\n}\r\nmntget(*mount);\r\n++*count;\r\nspin_unlock(&pin_fs_lock);\r\nmntput(mnt);\r\nreturn 0;\r\n}\r\nvoid simple_release_fs(struct vfsmount **mount, int *count)\r\n{\r\nstruct vfsmount *mnt;\r\nspin_lock(&pin_fs_lock);\r\nmnt = *mount;\r\nif (!--*count)\r\n*mount = NULL;\r\nspin_unlock(&pin_fs_lock);\r\nmntput(mnt);\r\n}\r\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\r\nconst void *from, size_t available)\r\n{\r\nloff_t pos = *ppos;\r\nsize_t ret;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available || !count)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nret = copy_to_user(to, from + pos, count);\r\nif (ret == count)\r\nreturn -EFAULT;\r\ncount -= ret;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,\r\nconst void __user *from, size_t count)\r\n{\r\nloff_t pos = *ppos;\r\nsize_t res;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available || !count)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nres = copy_from_user(to + pos, from, count);\r\nif (res == count)\r\nreturn -EFAULT;\r\ncount -= res;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,\r\nconst void *from, size_t available)\r\n{\r\nloff_t pos = *ppos;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= available)\r\nreturn 0;\r\nif (count > available - pos)\r\ncount = available - pos;\r\nmemcpy(to, from + pos, count);\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nvoid simple_transaction_set(struct file *file, size_t n)\r\n{\r\nstruct simple_transaction_argresp *ar = file->private_data;\r\nBUG_ON(n > SIMPLE_TRANSACTION_LIMIT);\r\nsmp_mb();\r\nar->size = n;\r\n}\r\nchar *simple_transaction_get(struct file *file, const char __user *buf, size_t size)\r\n{\r\nstruct simple_transaction_argresp *ar;\r\nstatic DEFINE_SPINLOCK(simple_transaction_lock);\r\nif (size > SIMPLE_TRANSACTION_LIMIT - 1)\r\nreturn ERR_PTR(-EFBIG);\r\nar = (struct simple_transaction_argresp *)get_zeroed_page(GFP_KERNEL);\r\nif (!ar)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock(&simple_transaction_lock);\r\nif (file->private_data) {\r\nspin_unlock(&simple_transaction_lock);\r\nfree_page((unsigned long)ar);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nfile->private_data = ar;\r\nspin_unlock(&simple_transaction_lock);\r\nif (copy_from_user(ar->data, buf, size))\r\nreturn ERR_PTR(-EFAULT);\r\nreturn ar->data;\r\n}\r\nssize_t simple_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\r\n{\r\nstruct simple_transaction_argresp *ar = file->private_data;\r\nif (!ar)\r\nreturn 0;\r\nreturn simple_read_from_buffer(buf, size, pos, ar->data, ar->size);\r\n}\r\nint simple_transaction_release(struct inode *inode, struct file *file)\r\n{\r\nfree_page((unsigned long)file->private_data);\r\nreturn 0;\r\n}\r\nint simple_attr_open(struct inode *inode, struct file *file,\r\nint (*get)(void *, u64 *), int (*set)(void *, u64),\r\nconst char *fmt)\r\n{\r\nstruct simple_attr *attr;\r\nattr = kmalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nattr->get = get;\r\nattr->set = set;\r\nattr->data = inode->i_private;\r\nattr->fmt = fmt;\r\nmutex_init(&attr->mutex);\r\nfile->private_data = attr;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nint simple_attr_release(struct inode *inode, struct file *file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nssize_t simple_attr_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct simple_attr *attr;\r\nsize_t size;\r\nssize_t ret;\r\nattr = file->private_data;\r\nif (!attr->get)\r\nreturn -EACCES;\r\nret = mutex_lock_interruptible(&attr->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (*ppos) {\r\nsize = strlen(attr->get_buf);\r\n} else {\r\nu64 val;\r\nret = attr->get(attr->data, &val);\r\nif (ret)\r\ngoto out;\r\nsize = scnprintf(attr->get_buf, sizeof(attr->get_buf),\r\nattr->fmt, (unsigned long long)val);\r\n}\r\nret = simple_read_from_buffer(buf, len, ppos, attr->get_buf, size);\r\nout:\r\nmutex_unlock(&attr->mutex);\r\nreturn ret;\r\n}\r\nssize_t simple_attr_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct simple_attr *attr;\r\nu64 val;\r\nsize_t size;\r\nssize_t ret;\r\nattr = file->private_data;\r\nif (!attr->set)\r\nreturn -EACCES;\r\nret = mutex_lock_interruptible(&attr->mutex);\r\nif (ret)\r\nreturn ret;\r\nret = -EFAULT;\r\nsize = min(sizeof(attr->set_buf) - 1, len);\r\nif (copy_from_user(attr->set_buf, buf, size))\r\ngoto out;\r\nattr->set_buf[size] = '\0';\r\nval = simple_strtoll(attr->set_buf, NULL, 0);\r\nret = attr->set(attr->data, val);\r\nif (ret == 0)\r\nret = len;\r\nout:\r\nmutex_unlock(&attr->mutex);\r\nreturn ret;\r\n}\r\nint generic_file_fsync(struct file *file, loff_t start, loff_t end,\r\nint datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nint err;\r\nint ret;\r\nerr = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&inode->i_mutex);\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (!(inode->i_state & I_DIRTY))\r\ngoto out;\r\nif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\r\ngoto out;\r\nerr = sync_inode_metadata(inode, 1);\r\nif (ret == 0)\r\nret = err;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn ret;\r\n}\r\nint generic_check_addressable(unsigned blocksize_bits, u64 num_blocks)\r\n{\r\nu64 last_fs_block = num_blocks - 1;\r\nu64 last_fs_page =\r\nlast_fs_block >> (PAGE_CACHE_SHIFT - blocksize_bits);\r\nif (unlikely(num_blocks == 0))\r\nreturn 0;\r\nif ((blocksize_bits < 9) || (blocksize_bits > PAGE_CACHE_SHIFT))\r\nreturn -EINVAL;\r\nif ((last_fs_block > (sector_t)(~0ULL) >> (blocksize_bits - 9)) ||\r\n(last_fs_page > (pgoff_t)(~0ULL))) {\r\nreturn -EFBIG;\r\n}\r\nreturn 0;\r\n}\r\nint noop_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nreturn 0;\r\n}\r\nvoid kfree_put_link(struct dentry *dentry, struct nameidata *nd,\r\nvoid *cookie)\r\n{\r\nchar *s = nd_get_link(nd);\r\nif (!IS_ERR(s))\r\nkfree(s);\r\n}\r\nstatic int anon_set_page_dirty(struct page *page)\r\n{\r\nreturn 0;\r\n}\r\nstruct inode *alloc_anon_inode(struct super_block *s)\r\n{\r\nstatic const struct address_space_operations anon_aops = {\r\n.set_page_dirty = anon_set_page_dirty,\r\n};\r\nstruct inode *inode = new_inode_pseudo(s);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\ninode->i_ino = get_next_ino();\r\ninode->i_mapping->a_ops = &anon_aops;\r\ninode->i_state = I_DIRTY;\r\ninode->i_mode = S_IRUSR | S_IWUSR;\r\ninode->i_uid = current_fsuid();\r\ninode->i_gid = current_fsgid();\r\ninode->i_flags |= S_PRIVATE;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\nreturn inode;\r\n}
