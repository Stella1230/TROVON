int SearchSfid(struct bcm_mini_adapter *Adapter, UINT uiSfid)\r\n{\r\nint i;\r\nfor (i = (NO_OF_QUEUES-1); i >= 0; i--)\r\nif (Adapter->PackInfo[i].ulSFID == uiSfid)\r\nreturn i;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic int SearchFreeSfid(struct bcm_mini_adapter *Adapter)\r\n{\r\nint i;\r\nfor (i = 0; i < (NO_OF_QUEUES-1); i++)\r\nif (Adapter->PackInfo[i].ulSFID == 0)\r\nreturn i;\r\nreturn NO_OF_QUEUES+1;\r\n}\r\nstatic int SearchClsid(struct bcm_mini_adapter *Adapter, ULONG ulSFID, B_UINT16 uiClassifierID)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif ((Adapter->astClassifierTable[i].bUsed) &&\r\n(Adapter->astClassifierTable[i].uiClassifierRuleIndex == uiClassifierID) &&\r\n(Adapter->astClassifierTable[i].ulSFID == ulSFID))\r\nreturn i;\r\n}\r\nreturn MAX_CLASSIFIERS+1;\r\n}\r\nstatic int SearchFreeClsid(struct bcm_mini_adapter *Adapter )\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif (!Adapter->astClassifierTable[i].bUsed)\r\nreturn i;\r\n}\r\nreturn MAX_CLASSIFIERS+1;\r\n}\r\nstatic VOID deleteSFBySfid(struct bcm_mini_adapter *Adapter, UINT uiSearchRuleIndex)\r\n{\r\nflush_queue(Adapter, uiSearchRuleIndex);\r\nDeleteAllClassifiersForSF(Adapter, uiSearchRuleIndex);\r\nmemset((PVOID)&Adapter->PackInfo[uiSearchRuleIndex], 0, sizeof(struct bcm_mibs_table));\r\n}\r\nstatic inline VOID\r\nCopyIpAddrToClassifier(struct bcm_classifier_rule *pstClassifierEntry,\r\nB_UINT8 u8IpAddressLen, B_UINT8 *pu8IpAddressMaskSrc,\r\nbool bIpVersion6, enum bcm_ipaddr_context eIpAddrContext)\r\n{\r\nint i = 0;\r\nUINT nSizeOfIPAddressInBytes = IP_LENGTH_OF_ADDRESS;\r\nUCHAR *ptrClassifierIpAddress = NULL;\r\nUCHAR *ptrClassifierIpMask = NULL;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nif (bIpVersion6)\r\nnSizeOfIPAddressInBytes = IPV6_ADDRESS_SIZEINBYTES;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Ip Address Range Length:0x%X ", u8IpAddressLen);\r\nif ((bIpVersion6 ? (IPV6_ADDRESS_SIZEINBYTES * MAX_IP_RANGE_LENGTH * 2) :\r\n(TOTAL_MASKED_ADDRESS_IN_BYTES)) >= u8IpAddressLen) {\r\nif (eIpAddrContext == eDestIpAddress) {\r\npstClassifierEntry->ucIPDestinationAddressLength = u8IpAddressLen/(nSizeOfIPAddressInBytes * 2);\r\nif (bIpVersion6) {\r\nptrClassifierIpAddress = pstClassifierEntry->stDestIpAddress.ucIpv6Address;\r\nptrClassifierIpMask = pstClassifierEntry->stDestIpAddress.ucIpv6Mask;\r\n} else {\r\nptrClassifierIpAddress = pstClassifierEntry->stDestIpAddress.ucIpv4Address;\r\nptrClassifierIpMask = pstClassifierEntry->stDestIpAddress.ucIpv4Mask;\r\n}\r\n} else if (eIpAddrContext == eSrcIpAddress) {\r\npstClassifierEntry->ucIPSourceAddressLength = u8IpAddressLen/(nSizeOfIPAddressInBytes * 2);\r\nif (bIpVersion6) {\r\nptrClassifierIpAddress = pstClassifierEntry->stSrcIpAddress.ucIpv6Address;\r\nptrClassifierIpMask = pstClassifierEntry->stSrcIpAddress.ucIpv6Mask;\r\n} else {\r\nptrClassifierIpAddress = pstClassifierEntry->stSrcIpAddress.ucIpv4Address;\r\nptrClassifierIpMask = pstClassifierEntry->stSrcIpAddress.ucIpv4Mask;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Address Length:0x%X\n", pstClassifierEntry->ucIPDestinationAddressLength);\r\nwhile ((u8IpAddressLen >= nSizeOfIPAddressInBytes) && (i < MAX_IP_RANGE_LENGTH)) {\r\nmemcpy(ptrClassifierIpAddress +\r\n(i * nSizeOfIPAddressInBytes),\r\n(pu8IpAddressMaskSrc+(i*nSizeOfIPAddressInBytes*2)),\r\nnSizeOfIPAddressInBytes);\r\nif (!bIpVersion6) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\npstClassifierEntry->stSrcIpAddress.ulIpv4Addr[i] = ntohl(pstClassifierEntry->stSrcIpAddress.ulIpv4Addr[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Src Ip Address:0x%luX ",\r\npstClassifierEntry->stSrcIpAddress.ulIpv4Addr[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\npstClassifierEntry->stDestIpAddress.ulIpv4Addr[i] = ntohl(pstClassifierEntry->stDestIpAddress.ulIpv4Addr[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Dest Ip Address:0x%luX ",\r\npstClassifierEntry->stDestIpAddress.ulIpv4Addr[i]);\r\n}\r\n}\r\nu8IpAddressLen -= nSizeOfIPAddressInBytes;\r\nif (u8IpAddressLen >= nSizeOfIPAddressInBytes) {\r\nmemcpy(ptrClassifierIpMask +\r\n(i * nSizeOfIPAddressInBytes),\r\n(pu8IpAddressMaskSrc+nSizeOfIPAddressInBytes +\r\n(i*nSizeOfIPAddressInBytes*2)),\r\nnSizeOfIPAddressInBytes);\r\nif (!bIpVersion6) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\npstClassifierEntry->stSrcIpAddress.ulIpv4Mask[i] =\r\nntohl(pstClassifierEntry->stSrcIpAddress.ulIpv4Mask[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Src Ip Mask Address:0x%luX ",\r\npstClassifierEntry->stSrcIpAddress.ulIpv4Mask[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\npstClassifierEntry->stDestIpAddress.ulIpv4Mask[i] =\r\nntohl(pstClassifierEntry->stDestIpAddress.ulIpv4Mask[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Dest Ip Mask Address:0x%luX ",\r\npstClassifierEntry->stDestIpAddress.ulIpv4Mask[i]);\r\n}\r\n}\r\nu8IpAddressLen -= nSizeOfIPAddressInBytes;\r\n}\r\nif (u8IpAddressLen == 0)\r\npstClassifierEntry->bDestIpValid = TRUE;\r\ni++;\r\n}\r\nif (bIpVersion6) {\r\nfor (i = 0; i < MAX_IP_RANGE_LENGTH * 4; i++) {\r\nif (eIpAddrContext == eSrcIpAddress) {\r\npstClassifierEntry->stSrcIpAddress.ulIpv6Addr[i] = ntohl(pstClassifierEntry->stSrcIpAddress.ulIpv6Addr[i]);\r\npstClassifierEntry->stSrcIpAddress.ulIpv6Mask[i] = ntohl(pstClassifierEntry->stSrcIpAddress.ulIpv6Mask[i]);\r\n} else if (eIpAddrContext == eDestIpAddress) {\r\npstClassifierEntry->stDestIpAddress.ulIpv6Addr[i] = ntohl(pstClassifierEntry->stDestIpAddress.ulIpv6Addr[i]);\r\npstClassifierEntry->stDestIpAddress.ulIpv6Mask[i] = ntohl(pstClassifierEntry->stDestIpAddress.ulIpv6Mask[i]);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid ClearTargetDSXBuffer(struct bcm_mini_adapter *Adapter, B_UINT16 TID, bool bFreeAll)\r\n{\r\nint i;\r\nfor (i = 0; i < Adapter->ulTotalTargetBuffersAvailable; i++) {\r\nif (Adapter->astTargetDsxBuffer[i].valid)\r\ncontinue;\r\nif ((bFreeAll) || (Adapter->astTargetDsxBuffer[i].tid == TID)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "ClearTargetDSXBuffer: found tid %d buffer cleared %lx\n",\r\nTID, Adapter->astTargetDsxBuffer[i].ulTargetDsxBuffer);\r\nAdapter->astTargetDsxBuffer[i].valid = 1;\r\nAdapter->astTargetDsxBuffer[i].tid = 0;\r\nAdapter->ulFreeTargetBufferCnt++;\r\n}\r\n}\r\n}\r\nstatic inline VOID CopyClassifierRuleToSF(struct bcm_mini_adapter *Adapter, struct bcm_convergence_types *psfCSType, UINT uiSearchRuleIndex, UINT nClassifierIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nint i;\r\nif (Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value == 0 ||\r\nnClassifierIndex > (MAX_CLASSIFIERS-1))\r\nreturn;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Storing Classifier Rule Index : %X",\r\nntohs(psfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex));\r\nif (nClassifierIndex > MAX_CLASSIFIERS-1)\r\nreturn;\r\npstClassifierEntry = &Adapter->astClassifierTable[nClassifierIndex];\r\nif (pstClassifierEntry) {\r\npstClassifierEntry->bIpv6Protocol = (Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ? TRUE : false;\r\npstClassifierEntry->ucDestPortRangeLength = psfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength / 4;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Destination Port Range Length:0x%X ", pstClassifierEntry->ucDestPortRangeLength);\r\nif (psfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength <= MAX_PORT_RANGE) {\r\nfor (i = 0; i < (pstClassifierEntry->ucDestPortRangeLength); i++) {\r\npstClassifierEntry->usDestPortRangeLo[i] = *((PUSHORT)(psfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange+i));\r\npstClassifierEntry->usDestPortRangeHi[i] =\r\n*((PUSHORT)(psfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange+2+i));\r\npstClassifierEntry->usDestPortRangeLo[i] = ntohs(pstClassifierEntry->usDestPortRangeLo[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Destination Port Range Lo:0x%X ",\r\npstClassifierEntry->usDestPortRangeLo[i]);\r\npstClassifierEntry->usDestPortRangeHi[i] = ntohs(pstClassifierEntry->usDestPortRangeHi[i]);\r\n}\r\n} else {\r\npstClassifierEntry->ucDestPortRangeLength = 0;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Source Port Range Length:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nif (psfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength <= MAX_PORT_RANGE) {\r\npstClassifierEntry->ucSrcPortRangeLength = psfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength/4;\r\nfor (i = 0; i < (pstClassifierEntry->ucSrcPortRangeLength); i++) {\r\npstClassifierEntry->usSrcPortRangeLo[i] =\r\n*((PUSHORT)(psfCSType->cCPacketClassificationRule.\r\nu8ProtocolSourcePortRange+i));\r\npstClassifierEntry->usSrcPortRangeHi[i] =\r\n*((PUSHORT)(psfCSType->cCPacketClassificationRule.\r\nu8ProtocolSourcePortRange+2+i));\r\npstClassifierEntry->usSrcPortRangeLo[i] =\r\nntohs(pstClassifierEntry->usSrcPortRangeLo[i]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Source Port Range Lo:0x%X ",\r\npstClassifierEntry->usSrcPortRangeLo[i]);\r\npstClassifierEntry->usSrcPortRangeHi[i] = ntohs(pstClassifierEntry->usSrcPortRangeHi[i]);\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Ip Destination Parameters : ");\r\nCopyIpAddrToClassifier(pstClassifierEntry,\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength,\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress,\r\n(Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ?\r\nTRUE : false, eDestIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Ip Source Parameters : ");\r\nCopyIpAddrToClassifier(pstClassifierEntry,\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength,\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress,\r\n(Adapter->PackInfo[uiSearchRuleIndex].ucIpVersion == IPV6) ? TRUE : false,\r\neSrcIpAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "TOS Length:0x%X ", psfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nif (psfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength == 3) {\r\npstClassifierEntry->ucIPTypeOfServiceLength = psfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength;\r\npstClassifierEntry->ucTosLow = psfCSType->cCPacketClassificationRule.u8IPTypeOfService[0];\r\npstClassifierEntry->ucTosHigh = psfCSType->cCPacketClassificationRule.u8IPTypeOfService[1];\r\npstClassifierEntry->ucTosMask = psfCSType->cCPacketClassificationRule.u8IPTypeOfService[2];\r\npstClassifierEntry->bTOSValid = TRUE;\r\n}\r\nif (psfCSType->cCPacketClassificationRule.u8Protocol == 0) {\r\npstClassifierEntry->ucProtocolLength = 0;\r\n} else {\r\npstClassifierEntry->ucProtocolLength = 1;\r\n}\r\npstClassifierEntry->ucProtocol[0] = psfCSType->cCPacketClassificationRule.u8Protocol;\r\npstClassifierEntry->u8ClassifierRulePriority = psfCSType->cCPacketClassificationRule.u8ClassifierRulePriority;\r\npstClassifierEntry->ucDirection = Adapter->PackInfo[uiSearchRuleIndex].ucDirection;\r\npstClassifierEntry->uiClassifierRuleIndex = ntohs(psfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\npstClassifierEntry->usVCID_Value = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\npstClassifierEntry->ulSFID = Adapter->PackInfo[uiSearchRuleIndex].ulSFID;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Search Index %d Dir: %d, Index: %d, Vcid: %d\n",\r\nuiSearchRuleIndex, pstClassifierEntry->ucDirection,\r\npstClassifierEntry->uiClassifierRuleIndex,\r\npstClassifierEntry->usVCID_Value);\r\nif (psfCSType->cCPacketClassificationRule.u8AssociatedPHSI)\r\npstClassifierEntry->u8AssociatedPHSI = psfCSType->cCPacketClassificationRule.u8AssociatedPHSI;\r\npstClassifierEntry->ucEthCSSrcMACLen = (psfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddressLength);\r\nmemcpy(pstClassifierEntry->au8EThCSSrcMAC, psfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress, MAC_ADDRESS_SIZE);\r\nmemcpy(pstClassifierEntry->au8EThCSSrcMACMask, psfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress + MAC_ADDRESS_SIZE, MAC_ADDRESS_SIZE);\r\npstClassifierEntry->ucEthCSDestMACLen = (psfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nmemcpy(pstClassifierEntry->au8EThCSDestMAC, psfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress, MAC_ADDRESS_SIZE);\r\nmemcpy(pstClassifierEntry->au8EThCSDestMACMask, psfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress + MAC_ADDRESS_SIZE, MAC_ADDRESS_SIZE);\r\npstClassifierEntry->ucEtherTypeLen = (psfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nmemcpy(pstClassifierEntry->au8EthCSEtherType, psfCSType->cCPacketClassificationRule.u8Ethertype, NUM_ETHERTYPE_BYTES);\r\nmemcpy(pstClassifierEntry->usUserPriority, &psfCSType->cCPacketClassificationRule.u16UserPriority, 2);\r\npstClassifierEntry->usVLANID = ntohs(psfCSType->cCPacketClassificationRule.u16VLANID);\r\npstClassifierEntry->usValidityBitMap = ntohs(psfCSType->cCPacketClassificationRule.u16ValidityBitMap);\r\npstClassifierEntry->bUsed = TRUE;\r\n}\r\n}\r\nstatic inline VOID DeleteClassifierRuleFromSF(struct bcm_mini_adapter *Adapter, UINT uiSearchRuleIndex, UINT nClassifierIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nB_UINT16 u16PacketClassificationRuleIndex;\r\nUSHORT usVCID;\r\nusVCID = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\nif (nClassifierIndex > MAX_CLASSIFIERS-1)\r\nreturn;\r\nif (usVCID == 0)\r\nreturn;\r\nu16PacketClassificationRuleIndex = Adapter->astClassifierTable[nClassifierIndex].uiClassifierRuleIndex;\r\npstClassifierEntry = &Adapter->astClassifierTable[nClassifierIndex];\r\nif (pstClassifierEntry) {\r\npstClassifierEntry->bUsed = false;\r\npstClassifierEntry->uiClassifierRuleIndex = 0;\r\nmemset(pstClassifierEntry, 0, sizeof(struct bcm_classifier_rule));\r\nPhsDeleteClassifierRule(&Adapter->stBCMPhsContext, usVCID, u16PacketClassificationRuleIndex);\r\n}\r\n}\r\nVOID DeleteAllClassifiersForSF(struct bcm_mini_adapter *Adapter, UINT uiSearchRuleIndex)\r\n{\r\nstruct bcm_classifier_rule *pstClassifierEntry = NULL;\r\nint i;\r\nUSHORT ulVCID;\r\nulVCID = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\nif (ulVCID == 0)\r\nreturn;\r\nfor (i = 0; i < MAX_CLASSIFIERS; i++) {\r\nif (Adapter->astClassifierTable[i].usVCID_Value == ulVCID) {\r\npstClassifierEntry = &Adapter->astClassifierTable[i];\r\nif (pstClassifierEntry->bUsed)\r\nDeleteClassifierRuleFromSF(Adapter, uiSearchRuleIndex, i);\r\n}\r\n}\r\nPhsDeleteSFRules(&Adapter->stBCMPhsContext, ulVCID);\r\n}\r\nstatic VOID CopyToAdapter(register struct bcm_mini_adapter *Adapter,\r\nregister struct bcm_connect_mgr_params *psfLocalSet,\r\nregister UINT uiSearchRuleIndex,\r\nregister UCHAR ucDsxType,\r\nstruct bcm_add_indication_alt *pstAddIndication) {\r\nULONG ulSFID;\r\nUINT nClassifierIndex = 0;\r\nenum E_CLASSIFIER_ACTION eClassifierAction = eInvalidClassifierAction;\r\nB_UINT16 u16PacketClassificationRuleIndex = 0;\r\nint i;\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\nstruct bcm_phs_rule sPhsRule;\r\nUSHORT uVCID = Adapter->PackInfo[uiSearchRuleIndex].usVCID_Value;\r\nUINT UGIValue = 0;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = TRUE;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Search Rule Index = %d\n", uiSearchRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "%s: SFID= %x ", __func__, ntohl(psfLocalSet->u32SFID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Updating Queue %d", uiSearchRuleIndex);\r\nulSFID = ntohl(psfLocalSet->u32SFID);\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = 0;\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport = 0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "CopyToAdapter : u8CSSpecification : %X\n", psfLocalSet->u8CSSpecification);\r\nswitch (psfLocalSet->u8CSSpecification) {\r\ncase eCSPacketIPV4:\r\n{\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = IPV4_CS;\r\nbreak;\r\n}\r\ncase eCSPacketIPV6:\r\n{\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = IPV6_CS;\r\nbreak;\r\n}\r\ncase eCS802_3PacketEthernet:\r\ncase eCS802_1QPacketVLAN:\r\n{\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\n}\r\ncase eCSPacketIPV4Over802_1QVLAN:\r\ncase eCSPacketIPV4Over802_3Ethernet:\r\n{\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = IPV4_CS;\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\n}\r\ncase eCSPacketIPV6Over802_1QVLAN:\r\ncase eCSPacketIPV6Over802_3Ethernet:\r\n{\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = IPV6_CS;\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport = ETH_CS_802_3;\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Error in value of CS Classification.. setting default to IP CS\n");\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport = IPV4_CS;\r\nbreak;\r\n}\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "CopyToAdapter : Queue No : %X ETH CS Support : %X , IP CS Support : %X\n",\r\nuiSearchRuleIndex,\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport,\r\nAdapter->PackInfo[uiSearchRuleIndex].bIPCSSupport);\r\nif (Adapter->PackInfo[uiSearchRuleIndex].bIPCSSupport == IPV6_CS)\r\nAdapter->PackInfo[uiSearchRuleIndex].ucIpVersion = IPV6;\r\nelse\r\nAdapter->PackInfo[uiSearchRuleIndex].ucIpVersion = IPV4;\r\nif (!Adapter->bETHCSEnabled)\r\nAdapter->PackInfo[uiSearchRuleIndex].bEthCSSupport = 0;\r\nif (psfLocalSet->u8ServiceClassNameLength > 0 && psfLocalSet->u8ServiceClassNameLength < 32)\r\nmemcpy(Adapter->PackInfo[uiSearchRuleIndex].ucServiceClassName, psfLocalSet->u8ServiceClassName, psfLocalSet->u8ServiceClassNameLength);\r\nAdapter->PackInfo[uiSearchRuleIndex].u8QueueType = psfLocalSet->u8ServiceFlowSchedulingType;\r\nif (Adapter->PackInfo[uiSearchRuleIndex].u8QueueType == BE && Adapter->PackInfo[uiSearchRuleIndex].ucDirection)\r\nAdapter->usBestEffortQueueIndex = uiSearchRuleIndex;\r\nAdapter->PackInfo[uiSearchRuleIndex].ulSFID = ntohl(psfLocalSet->u32SFID);\r\nAdapter->PackInfo[uiSearchRuleIndex].u8TrafficPriority = psfLocalSet->u8TrafficPriority;\r\nfor (i = 0; i < psfLocalSet->u8TotalClassifiers; i++) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Classifier index =%d", i);\r\npsfCSType = &psfLocalSet->cConvergenceSLTypes[i];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Classifier index =%d", i);\r\nif (psfCSType->cCPacketClassificationRule.u8ClassifierRulePriority)\r\nAdapter->PackInfo[uiSearchRuleIndex].bClassifierPriority = TRUE;\r\nif (psfCSType->cCPacketClassificationRule.u8ClassifierRulePriority)\r\nAdapter->PackInfo[uiSearchRuleIndex].bClassifierPriority = TRUE;\r\nif (ucDsxType == DSA_ACK) {\r\neClassifierAction = eAddClassifier;\r\n} else if (ucDsxType == DSC_ACK) {\r\nswitch (psfCSType->u8ClassfierDSCAction) {\r\ncase 0:\r\n{\r\neClassifierAction = eAddClassifier;\r\n}\r\nbreak;\r\ncase 1:\r\n{\r\neClassifierAction = eReplaceClassifier;\r\n}\r\nbreak;\r\ncase 2:\r\n{\r\neClassifierAction = eDeleteClassifier;\r\n}\r\nbreak;\r\ndefault:\r\n{\r\neClassifierAction = eInvalidClassifierAction;\r\n}\r\n}\r\n}\r\nu16PacketClassificationRuleIndex = ntohs(psfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nswitch (eClassifierAction) {\r\ncase eAddClassifier:\r\n{\r\nnClassifierIndex = SearchClsid(Adapter, ulSFID, u16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nnClassifierIndex = SearchFreeClsid(Adapter);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Error Failed To get a free Classifier Entry");\r\nbreak;\r\n}\r\nCopyClassifierRuleToSF(Adapter, psfCSType, uiSearchRuleIndex, nClassifierIndex);\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"CopyToAdapter: Error The Specified Classifier Already Exists and attempted To Add Classifier with Same PCRI : 0x%x\n",\r\nu16PacketClassificationRuleIndex);\r\n}\r\n}\r\nbreak;\r\ncase eReplaceClassifier:\r\n{\r\nnClassifierIndex = SearchClsid(Adapter, ulSFID, u16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Error Search for Classifier To be replaced failed");\r\nbreak;\r\n}\r\nCopyClassifierRuleToSF(Adapter, psfCSType, uiSearchRuleIndex, nClassifierIndex);\r\n}\r\nbreak;\r\ncase eDeleteClassifier:\r\n{\r\nnClassifierIndex = SearchClsid(Adapter, ulSFID, u16PacketClassificationRuleIndex);\r\nif (nClassifierIndex > MAX_CLASSIFIERS) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Error Search for Classifier To be deleted failed");\r\nbreak;\r\n}\r\nDeleteClassifierRuleFromSF(Adapter, uiSearchRuleIndex, nClassifierIndex);\r\n}\r\nbreak;\r\ndefault:\r\n{\r\nbreak;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < psfLocalSet->u8TotalClassifiers; i++) {\r\npsfCSType = &psfLocalSet->cConvergenceSLTypes[i];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "psfCSType->u8PhsDSCAction : 0x%x\n", psfCSType->u8PhsDSCAction);\r\nswitch (psfCSType->u8PhsDSCAction) {\r\ncase eDeleteAllPHSRules:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Deleting All PHS Rules For VCID: 0x%X\n", uVCID);\r\nPhsDeleteSFRules(&Adapter->stBCMPhsContext, uVCID);\r\nbreak;\r\n}\r\ncase eDeletePHSRule:\r\n{\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "PHS DSC Action = Delete PHS Rule\n");\r\nif (psfCSType->cPhsRule.u8PHSI)\r\nPhsDeletePHSRule(&Adapter->stBCMPhsContext, uVCID, psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nbreak;\r\n}\r\ndefault:\r\n{\r\nif (ucDsxType == DSC_ACK) {\r\nbreak;\r\n}\r\n}\r\ncase eAddPHSRule:\r\ncase eSetPHSRule:\r\n{\r\nif (psfCSType->cPhsRule.u8PHSI) {\r\nunsigned int uiClassifierIndex = 0;\r\nif (pstAddIndication->u8Direction == UPLINK_DIR) {\r\nfor (uiClassifierIndex = 0; uiClassifierIndex < MAX_CLASSIFIERS; uiClassifierIndex++) {\r\nif ((Adapter->astClassifierTable[uiClassifierIndex].bUsed) &&\r\n(Adapter->astClassifierTable[uiClassifierIndex].ulSFID == Adapter->PackInfo[uiSearchRuleIndex].ulSFID) &&\r\n(Adapter->astClassifierTable[uiClassifierIndex].u8AssociatedPHSI == psfCSType->cPhsRule.u8PHSI)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL,\r\n"Adding PHS Rule For Classifier: 0x%x cPhsRule.u8PHSI: 0x%x\n",\r\nAdapter->astClassifierTable[uiClassifierIndex].uiClassifierRuleIndex,\r\npsfCSType->cPhsRule.u8PHSI);\r\nsPhsRule.u8PHSI = psfCSType->cPhsRule.u8PHSI;\r\nsPhsRule.u8PHSFLength = psfCSType->cPhsRule.u8PHSFLength;\r\nsPhsRule.u8PHSMLength = psfCSType->cPhsRule.u8PHSMLength;\r\nsPhsRule.u8PHSS = psfCSType->cPhsRule.u8PHSS;\r\nsPhsRule.u8PHSV = psfCSType->cPhsRule.u8PHSV;\r\nmemcpy(sPhsRule.u8PHSF, psfCSType->cPhsRule.u8PHSF, MAX_PHS_LENGTHS);\r\nmemcpy(sPhsRule.u8PHSM, psfCSType->cPhsRule.u8PHSM, MAX_PHS_LENGTHS);\r\nsPhsRule.u8RefCnt = 0;\r\nsPhsRule.bUnclassifiedPHSRule = false;\r\nsPhsRule.PHSModifiedBytes = 0;\r\nsPhsRule.PHSModifiedNumPackets = 0;\r\nsPhsRule.PHSErrorNumPackets = 0;\r\nPhsUpdateClassifierRule(\r\n&Adapter->stBCMPhsContext,\r\nuVCID,\r\nAdapter->astClassifierTable[uiClassifierIndex].uiClassifierRuleIndex,\r\n&sPhsRule,\r\nAdapter->astClassifierTable[uiClassifierIndex].u8AssociatedPHSI);\r\nif (sPhsRule.u8PHSI) {\r\nAdapter->astClassifierTable[uiClassifierIndex].u32PHSRuleID = sPhsRule.u8PHSI;\r\nmemcpy(&Adapter->astClassifierTable[uiClassifierIndex].sPhsRule, &sPhsRule, sizeof(struct bcm_phs_rule));\r\n}\r\n}\r\n}\r\n} else {\r\nsPhsRule.u8PHSI = psfCSType->cPhsRule.u8PHSI;\r\nsPhsRule.u8PHSFLength = psfCSType->cPhsRule.u8PHSFLength;\r\nsPhsRule.u8PHSMLength = psfCSType->cPhsRule.u8PHSMLength;\r\nsPhsRule.u8PHSS = psfCSType->cPhsRule.u8PHSS;\r\nsPhsRule.u8PHSV = psfCSType->cPhsRule.u8PHSV;\r\nmemcpy(sPhsRule.u8PHSF, psfCSType->cPhsRule.u8PHSF, MAX_PHS_LENGTHS);\r\nmemcpy(sPhsRule.u8PHSM, psfCSType->cPhsRule.u8PHSM, MAX_PHS_LENGTHS);\r\nsPhsRule.u8RefCnt = 0;\r\nsPhsRule.bUnclassifiedPHSRule = TRUE;\r\nsPhsRule.PHSModifiedBytes = 0;\r\nsPhsRule.PHSModifiedNumPackets = 0;\r\nsPhsRule.PHSErrorNumPackets = 0;\r\nPhsUpdateClassifierRule(\r\n&Adapter->stBCMPhsContext,\r\nuVCID,\r\nsPhsRule.u8PHSI,\r\n&sPhsRule,\r\nsPhsRule.u8PHSI);\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nif (psfLocalSet->u32MaxSustainedTrafficRate == 0) {\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate = WIMAX_MAX_ALLOWED_RATE;\r\n} else if (ntohl(psfLocalSet->u32MaxSustainedTrafficRate) > WIMAX_MAX_ALLOWED_RATE) {\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate = WIMAX_MAX_ALLOWED_RATE;\r\n} else {\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate = ntohl(psfLocalSet->u32MaxSustainedTrafficRate);\r\n}\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxLatency = ntohl(psfLocalSet->u32MaximumLatency);\r\nif (Adapter->PackInfo[uiSearchRuleIndex].uiMaxLatency == 0)\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxLatency = MAX_LATENCY_ALLOWED;\r\nif ((Adapter->PackInfo[uiSearchRuleIndex].u8QueueType == ERTPS ||\r\nAdapter->PackInfo[uiSearchRuleIndex].u8QueueType == UGS))\r\nUGIValue = ntohs(psfLocalSet->u16UnsolicitedGrantInterval);\r\nif (UGIValue == 0)\r\nUGIValue = DEFAULT_UG_INTERVAL;\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize =\r\n(DEFAULT_UGI_FACTOR*Adapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate*UGIValue)/1000;\r\nif (Adapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize < WIMAX_MAX_MTU*8) {\r\nUINT UGIFactor = 0;\r\nUGIFactor = (Adapter->PackInfo[uiSearchRuleIndex].uiMaxLatency/UGIValue + 1);\r\nif (UGIFactor > DEFAULT_UGI_FACTOR)\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize =\r\n(UGIFactor*Adapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate*UGIValue)/1000;\r\nif (Adapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize > WIMAX_MAX_MTU*8)\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize = WIMAX_MAX_MTU*8;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "LAT: %d, UGI: %d\n", Adapter->PackInfo[uiSearchRuleIndex].uiMaxLatency, UGIValue);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "uiMaxAllowedRate: 0x%x, u32MaxSustainedTrafficRate: 0x%x ,uiMaxBucketSize: 0x%x",\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxAllowedRate,\r\nntohl(psfLocalSet->u32MaxSustainedTrafficRate),\r\nAdapter->PackInfo[uiSearchRuleIndex].uiMaxBucketSize);\r\nCopyMIBSExtendedSFParameters(Adapter, psfLocalSet, uiSearchRuleIndex);\r\nAdapter->PackInfo[uiSearchRuleIndex].bHeaderSuppressionEnabled =\r\n!(psfLocalSet->u8RequesttransmissionPolicy &\r\nMASK_DISABLE_HEADER_SUPPRESSION);\r\nkfree(Adapter->PackInfo[uiSearchRuleIndex].pstSFIndication);\r\nAdapter->PackInfo[uiSearchRuleIndex].pstSFIndication = pstAddIndication;\r\nSortPackInfo(Adapter);\r\nSortClassifiers(Adapter);\r\nDumpPhsRules(&Adapter->stBCMPhsContext);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "%s <=====", __func__);\r\n}\r\nstatic VOID DumpCmControlPacket(PVOID pvBuffer)\r\n{\r\nint uiLoopIndex;\r\nint nIndex;\r\nstruct bcm_add_indication_alt *pstAddIndication;\r\nUINT nCurClassifierCnt;\r\nstruct bcm_mini_adapter *Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\npstAddIndication = pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "======>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Type: 0x%X", pstAddIndication->u8Type);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Direction: 0x%X", pstAddIndication->u8Direction);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TID: 0x%X", ntohs(pstAddIndication->u16TID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", ntohs(pstAddIndication->u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VCID: 0x%X", ntohs(pstAddIndication->u16VCID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " AuthorizedSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", htonl(pstAddIndication->sfAuthorizedSet.u32SFID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", htons(pstAddIndication->sfAuthorizedSet.u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassName: 0x%X ,0x%X , 0x%X, 0x%X, 0x%X, 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[0],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[1],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[2],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[3],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[4],\r\npstAddIndication->sfAuthorizedSet.u8ServiceClassName[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%X", pstAddIndication->sfAuthorizedSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%X", pstAddIndication->sfAuthorizedSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%X, %p",\r\npstAddIndication->sfAuthorizedSet.u8TrafficPriority, &pstAddIndication->sfAuthorizedSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxSustainedTrafficRate: 0x%X 0x%p",\r\npstAddIndication->sfAuthorizedSet.u32MaxSustainedTrafficRate,\r\n&pstAddIndication->sfAuthorizedSet.u32MaxSustainedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfAuthorizedSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate : 0x%X",\r\npstAddIndication->sfAuthorizedSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfAuthorizedSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfAuthorizedSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%X", pstAddIndication->sfAuthorizedSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TargetSAID: 0x%X", pstAddIndication->sfAuthorizedSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQEnable: 0x%X", pstAddIndication->sfAuthorizedSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQWindowSize: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQDeliverInOrder: 0x%X", pstAddIndication->sfAuthorizedSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockSize: 0x%X", pstAddIndication->sfAuthorizedSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8CSSpecification: 0x%X", pstAddIndication->sfAuthorizedSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TypeOfDataDeliveryService: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfAuthorizedSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TimeBase: 0x%X", pstAddIndication->sfAuthorizedSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8PagingPreference: 0x%X", pstAddIndication->sfAuthorizedSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UnsolicitedPollingInterval: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u16UnsolicitedPollingInterval);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "sfAuthorizedSet.u8HARQChannelMapping %x %x %x ",\r\n*(unsigned int *)pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping,\r\n*(unsigned int *)&pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping[4],\r\n*(USHORT *)&pstAddIndication->sfAuthorizedSet.u8HARQChannelMapping[8]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficIndicationPreference: 0x%X",\r\npstAddIndication->sfAuthorizedSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfAuthorizedSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfAuthorizedSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "pstAddIndication->sfAuthorizedSet.bValid %d", pstAddIndication->sfAuthorizedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "pstAddIndication->sfAuthorizedSet.u16MacOverhead %x", pstAddIndication->sfAuthorizedSet.u16MacOverhead);\r\nif (!pstAddIndication->sfAuthorizedSet.bValid)\r\npstAddIndication->sfAuthorizedSet.bValid = 1;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\npsfCSType = &pstAddIndication->sfAuthorizedSet.cConvergenceSLTypes[nIndex];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "psfCSType = %p", psfCSType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ClassifierRulePriority: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfServiceLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfService[3]: 0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[0],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[1],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[2]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Protocol: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRangeLength:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRange[4]: 0x%02X ,0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRange[4]: 0x%02X ,0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetDestMacAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetDestMacAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetDestMacAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetSourceMACAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetSourceMACAddress[6]: "\r\n"%pM", psfCSType->cCPacketClassificationRule.\r\nu8EthernetSourceMACAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthertypeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Ethertype[3]: 0x%02X ,0x%02X ,0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[0],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[1],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[2]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UserPriority: 0x%X ", psfCSType->cCPacketClassificationRule.u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VLANID: 0x%X ", psfCSType->cCPacketClassificationRule.u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8AssociatedPHSI: 0x%02X ", psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16PacketClassificationRuleIndex: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParamLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParam[1]: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPv6FlowLableLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPv6FlowLable[6]: 0x%*ph ",\r\n6, psfCSType->cCPacketClassificationRule.\r\nu8IPv6FlowLable);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "bValid: 0x%02X", pstAddIndication->sfAuthorizedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "AdmittedSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", pstAddIndication->sfAdmittedSet.u32SFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", pstAddIndication->sfAdmittedSet.u16CID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X",\r\npstAddIndication->sfAdmittedSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,\r\n"u8ServiceClassName: 0x%*ph",\r\n6, pstAddIndication->sfAdmittedSet.u8ServiceClassName);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%02X", pstAddIndication->sfAdmittedSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%02X", pstAddIndication->sfAdmittedSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%02X", pstAddIndication->sfAdmittedSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfAdmittedSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate: 0x%X",\r\npstAddIndication->sfAdmittedSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfAdmittedSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfAdmittedSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%02X", pstAddIndication->sfAdmittedSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TargetSAID: 0x%02X", pstAddIndication->sfAdmittedSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQEnable: 0x%02X", pstAddIndication->sfAdmittedSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQWindowSize: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ARQDeliverInOrder: 0x%02X", pstAddIndication->sfAdmittedSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16ARQBlockSize: 0x%X", pstAddIndication->sfAdmittedSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8CSSpecification: 0x%02X", pstAddIndication->sfAdmittedSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TypeOfDataDeliveryService: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfAdmittedSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16TimeBase: 0x%X", pstAddIndication->sfAdmittedSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8PagingPreference: 0x%X", pstAddIndication->sfAdmittedSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficIndicationPreference: 0x%02X",\r\npstAddIndication->sfAdmittedSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfAdmittedSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfAdmittedSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\npsfCSType = &pstAddIndication->sfAdmittedSet.cConvergenceSLTypes[nIndex];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ClassifierRulePriority: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPTypeOfServiceLength: 0x%02X",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPTypeOfService[3]: 0x%*ph",\r\n3, psfCSType->cCPacketClassificationRule.\r\nu8IPTypeOfService);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8Protocol: 0x%02X ", psfCSType->cCPacketClassificationRule.u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddress[32]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolSourcePortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8ProtocolSourcePortRange[4]: "\r\n"0x%*ph ", 4, psfCSType->\r\ncCPacketClassificationRule.\r\nu8ProtocolSourcePortRange);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ProtocolDestPortRangeLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8ProtocolDestPortRange[4]: "\r\n"0x%*ph ", 4, psfCSType->\r\ncCPacketClassificationRule.\r\nu8ProtocolDestPortRange);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetDestMacAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetDestMacAddress[6]: %pM",\r\npsfCSType->cCPacketClassificationRule.\r\nu8EthernetDestMacAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetSourceMACAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8EthernetSourceMACAddress[6]: "\r\n"%pM", psfCSType->cCPacketClassificationRule.\r\nu8EthernetSourceMACAddress);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthertypeLength: 0x%02X ", psfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8Ethertype[3]: 0x%*ph",\r\n3, psfCSType->cCPacketClassificationRule.\r\nu8Ethertype);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16UserPriority: 0x%X ", psfCSType->cCPacketClassificationRule.u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16VLANID: 0x%X ", psfCSType->cCPacketClassificationRule.u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8AssociatedPHSI: 0x%02X ", psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16PacketClassificationRuleIndex: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParamLength: 0x%02X",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificClassifierParam[1]: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPv6FlowLableLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL,\r\nDBG_LVL_ALL, "u8IPv6FlowLable[6]: 0x%*ph ",\r\n6, psfCSType->cCPacketClassificationRule.\r\nu8IPv6FlowLable);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "bValid: 0x%X", pstAddIndication->sfAdmittedSet.bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " ActiveSet--->");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32SFID: 0x%X", pstAddIndication->sfActiveSet.u32SFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u16CID: 0x%X", pstAddIndication->sfActiveSet.u16CID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceClassNameLength: 0x%X", pstAddIndication->sfActiveSet.u8ServiceClassNameLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL,\r\n"u8ServiceClassName: 0x%*ph",\r\n6, pstAddIndication->sfActiveSet.u8ServiceClassName);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8MBSService: 0x%02X", pstAddIndication->sfActiveSet.u8MBSService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8QosParamSet: 0x%02X", pstAddIndication->sfActiveSet.u8QosParamSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8TrafficPriority: 0x%02X", pstAddIndication->sfActiveSet.u8TrafficPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaxTrafficBurst: 0x%X", pstAddIndication->sfActiveSet.u32MaxTrafficBurst);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MinReservedTrafficRate: 0x%X",\r\npstAddIndication->sfActiveSet.u32MinReservedTrafficRate);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParamLength: 0x%02X",\r\npstAddIndication->sfActiveSet.u8VendorSpecificQoSParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8VendorSpecificQoSParam: 0x%02X",\r\npstAddIndication->sfActiveSet.u8VendorSpecificQoSParam[0]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8ServiceFlowSchedulingType: 0x%02X",\r\npstAddIndication->sfActiveSet.u8ServiceFlowSchedulingType);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32ToleratedJitter: 0x%X", pstAddIndication->sfActiveSet.u32ToleratedJitter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u32MaximumLatency: 0x%X", pstAddIndication->sfActiveSet.u32MaximumLatency);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8FixedLengthVSVariableLengthSDUIndicator: 0x%02X",\r\npstAddIndication->sfActiveSet.u8FixedLengthVSVariableLengthSDUIndicator);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8SDUSize: 0x%X", pstAddIndication->sfActiveSet.u8SDUSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16TargetSAID: 0x%X", pstAddIndication->sfActiveSet.u16TargetSAID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ARQEnable: 0x%X", pstAddIndication->sfActiveSet.u8ARQEnable);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQWindowSize: 0x%X", pstAddIndication->sfActiveSet.u16ARQWindowSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRetryTxTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRetryTxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRetryRxTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRetryRxTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQBlockLifeTime: 0x%X", pstAddIndication->sfActiveSet.u16ARQBlockLifeTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQSyncLossTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQSyncLossTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ARQDeliverInOrder: 0x%X", pstAddIndication->sfActiveSet.u8ARQDeliverInOrder);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQRxPurgeTimeOut: 0x%X", pstAddIndication->sfActiveSet.u16ARQRxPurgeTimeOut);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16ARQBlockSize: 0x%X", pstAddIndication->sfActiveSet.u16ARQBlockSize);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8CSSpecification: 0x%X", pstAddIndication->sfActiveSet.u8CSSpecification);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8TypeOfDataDeliveryService: 0x%X",\r\npstAddIndication->sfActiveSet.u8TypeOfDataDeliveryService);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16SDUInterArrivalTime: 0x%X", pstAddIndication->sfActiveSet.u16SDUInterArrivalTime);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16TimeBase: 0x%X", pstAddIndication->sfActiveSet.u16TimeBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8PagingPreference: 0x%X", pstAddIndication->sfActiveSet.u8PagingPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8TrafficIndicationPreference: 0x%X",\r\npstAddIndication->sfActiveSet.u8TrafficIndicationPreference);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " Total Classifiers Received: 0x%X", pstAddIndication->sfActiveSet.u8TotalClassifiers);\r\nnCurClassifierCnt = pstAddIndication->sfActiveSet.u8TotalClassifiers;\r\nif (nCurClassifierCnt > MAX_CLASSIFIERS_IN_SF)\r\nnCurClassifierCnt = MAX_CLASSIFIERS_IN_SF;\r\nfor (nIndex = 0; nIndex < nCurClassifierCnt; nIndex++) {\r\nstruct bcm_convergence_types *psfCSType = NULL;\r\npsfCSType = &pstAddIndication->sfActiveSet.cConvergenceSLTypes[nIndex];\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " CCPacketClassificationRuleSI====>");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ClassifierRulePriority: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ClassifierRulePriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8IPTypeOfServiceLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfServiceLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8IPTypeOfService[3]: 0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[0],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[1],\r\npsfCSType->cCPacketClassificationRule.u8IPTypeOfService[2]);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 1; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8Protocol: 0x%X ", psfCSType->cCPacketClassificationRule.u8Protocol);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPMaskedSourceAddress[32]: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPMaskedSourceAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8IPDestinationAddressLength: 0x%02X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddressLength);\r\nfor (uiLoopIndex = 0; uiLoopIndex < 32; uiLoopIndex++)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8IPDestinationAddress[32]:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPDestinationAddress[uiLoopIndex]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ProtocolSourcePortRangeLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ProtocolSourcePortRange[4]: 0x%X ,0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolSourcePortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ProtocolDestPortRangeLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRangeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8ProtocolDestPortRange[4]: 0x%X ,0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[0],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[1],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[2],\r\npsfCSType->cCPacketClassificationRule.u8ProtocolDestPortRange[3]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8EthernetDestMacAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8EthernetDestMacAddress[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[0],\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[1],\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[2],\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[3],\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[4],\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddress[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8EthernetSourceMACAddressLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8EthernetDestMacAddressLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, "u8EthernetSourceMACAddress[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X",\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[0],\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[1],\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[2],\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[3],\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[4],\r\npsfCSType->cCPacketClassificationRule.u8EthernetSourceMACAddress[5]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8EthertypeLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8EthertypeLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8Ethertype[3]: 0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[0],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[1],\r\npsfCSType->cCPacketClassificationRule.u8Ethertype[2]);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16UserPriority: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16UserPriority);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16VLANID: 0x%X ", psfCSType->cCPacketClassificationRule.u16VLANID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8AssociatedPHSI: 0x%X ", psfCSType->cCPacketClassificationRule.u8AssociatedPHSI);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u16PacketClassificationRuleIndex:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u16PacketClassificationRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8VendorSpecificClassifierParamLength:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParamLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8VendorSpecificClassifierParam[1]:0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8VendorSpecificClassifierParam[0]);\r\n#ifdef VERSION_D5\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8IPv6FlowLableLength: 0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLableLength);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " u8IPv6FlowLable[6]: 0x%X ,0x%X ,0x%X ,0x%X ,0x%X ,0x%X ",\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[0],\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[1],\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[2],\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[3],\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[4],\r\npsfCSType->cCPacketClassificationRule.u8IPv6FlowLable[5]);\r\n#endif\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, DUMP_CONTROL, DBG_LVL_ALL, " bValid: 0x%X", pstAddIndication->sfActiveSet.bValid);\r\n}\r\nstatic inline ULONG RestoreSFParam(struct bcm_mini_adapter *Adapter, ULONG ulAddrSFParamSet, PUCHAR pucDestBuffer)\r\n{\r\nUINT nBytesToRead = sizeof(struct bcm_connect_mgr_params);\r\nif (ulAddrSFParamSet == 0 || NULL == pucDestBuffer) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Got Param address as 0!!");\r\nreturn 0;\r\n}\r\nulAddrSFParamSet = ntohl(ulAddrSFParamSet);\r\nif (rdm(Adapter, ulAddrSFParamSet, (PUCHAR)pucDestBuffer, nBytesToRead) < 0)\r\nreturn STATUS_FAILURE;\r\nreturn 1;\r\n}\r\nstatic ULONG StoreSFParam(struct bcm_mini_adapter *Adapter, PUCHAR pucSrcBuffer, ULONG ulAddrSFParamSet)\r\n{\r\nUINT nBytesToWrite = sizeof(struct bcm_connect_mgr_params);\r\nint ret = 0;\r\nif (ulAddrSFParamSet == 0 || NULL == pucSrcBuffer)\r\nreturn 0;\r\nret = wrm(Adapter, ulAddrSFParamSet, (u8 *)pucSrcBuffer, nBytesToWrite);\r\nif (ret < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "%s:%d WRM failed", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nULONG StoreCmControlResponseMessage(struct bcm_mini_adapter *Adapter, PVOID pvBuffer, UINT *puBufferLength)\r\n{\r\nstruct bcm_add_indication_alt *pstAddIndicationAlt = NULL;\r\nstruct bcm_add_indication *pstAddIndication = NULL;\r\nstruct bcm_del_request *pstDeletionRequest;\r\nUINT uiSearchRuleIndex;\r\nULONG ulSFID;\r\npstAddIndicationAlt = pvBuffer;\r\nif (pstAddIndicationAlt->u8Type == DSD_REQ) {\r\npstDeletionRequest = pvBuffer;\r\nulSFID = ntohl(pstDeletionRequest->u32SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nAdapter->u32TotalDSD++;\r\n}\r\nreturn 1;\r\n}\r\nif ((pstAddIndicationAlt->u8Type == DSD_RSP) ||\r\n(pstAddIndicationAlt->u8Type == DSD_ACK)) {\r\nreturn 1;\r\n}\r\npstAddIndication = kmalloc(sizeof(struct bcm_add_indication), GFP_KERNEL);\r\nif (pstAddIndication == NULL)\r\nreturn 0;\r\npstAddIndication->psfAuthorizedSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter, pstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfAuthorizedSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfAuthorizedSet,\r\n(ULONG)pstAddIndication->psfAuthorizedSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfAuthorizedSet = (struct bcm_connect_mgr_params *)ntohl((ULONG)pstAddIndication->psfAuthorizedSet);\r\nif (pstAddIndicationAlt->u8Type == DSA_REQ) {\r\nstruct bcm_add_request AddRequest;\r\nAddRequest.u8Type = pstAddIndicationAlt->u8Type;\r\nAddRequest.eConnectionDir = pstAddIndicationAlt->u8Direction;\r\nAddRequest.u16TID = pstAddIndicationAlt->u16TID;\r\nAddRequest.u16CID = pstAddIndicationAlt->u16CID;\r\nAddRequest.u16VCID = pstAddIndicationAlt->u16VCID;\r\nAddRequest.psfParameterSet = pstAddIndication->psfAuthorizedSet;\r\n(*puBufferLength) = sizeof(struct bcm_add_request);\r\nmemcpy(pvBuffer, &AddRequest, sizeof(struct bcm_add_request));\r\nkfree(pstAddIndication);\r\nreturn 1;\r\n}\r\npstAddIndication->u8Type = pstAddIndicationAlt->u8Type;\r\npstAddIndication->eConnectionDir = pstAddIndicationAlt->u8Direction;\r\npstAddIndication->u16TID = pstAddIndicationAlt->u16TID;\r\npstAddIndication->u16CID = pstAddIndicationAlt->u16CID;\r\npstAddIndication->u16VCID = pstAddIndicationAlt->u16VCID;\r\npstAddIndication->u8CC = pstAddIndicationAlt->u8CC;\r\npstAddIndication->psfAdmittedSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter, pstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfAdmittedSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfAdmittedSet, (ULONG)pstAddIndication->psfAdmittedSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfAdmittedSet = (struct bcm_connect_mgr_params *)ntohl((ULONG)pstAddIndication->psfAdmittedSet);\r\npstAddIndication->psfActiveSet = (struct bcm_connect_mgr_params *)\r\nGetNextTargetBufferLocation(Adapter, pstAddIndicationAlt->u16TID);\r\nif (!pstAddIndication->psfActiveSet) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\nif (StoreSFParam(Adapter, (PUCHAR)&pstAddIndicationAlt->sfActiveSet, (ULONG)pstAddIndication->psfActiveSet) != 1) {\r\nkfree(pstAddIndication);\r\nreturn 0;\r\n}\r\npstAddIndication->psfActiveSet = (struct bcm_connect_mgr_params *)ntohl((ULONG)pstAddIndication->psfActiveSet);\r\n(*puBufferLength) = sizeof(struct bcm_add_indication);\r\n*(struct bcm_add_indication *)pvBuffer = *pstAddIndication;\r\nkfree(pstAddIndication);\r\nreturn 1;\r\n}\r\nstatic inline struct bcm_add_indication_alt\r\n*RestoreCmControlResponseMessage(register struct bcm_mini_adapter *Adapter, register PVOID pvBuffer)\r\n{\r\nULONG ulStatus = 0;\r\nstruct bcm_add_indication *pstAddIndication = NULL;\r\nstruct bcm_add_indication_alt *pstAddIndicationDest = NULL;\r\npstAddIndication = pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "=====>");\r\nif ((pstAddIndication->u8Type == DSD_REQ) ||\r\n(pstAddIndication->u8Type == DSD_RSP) ||\r\n(pstAddIndication->u8Type == DSD_ACK))\r\nreturn pvBuffer;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Inside RestoreCmControlResponseMessage ");\r\npstAddIndicationDest = kmalloc(sizeof(struct bcm_add_indication_alt), GFP_KERNEL);\r\nif (pstAddIndicationDest) {\r\nmemset(pstAddIndicationDest, 0, sizeof(struct bcm_add_indication_alt));\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Failed to allocate memory for SF Add Indication Structure ");\r\nreturn NULL;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-u8Type : 0x%X", pstAddIndication->u8Type);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-u8Direction : 0x%X", pstAddIndication->eConnectionDir);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-u8TID : 0x%X", ntohs(pstAddIndication->u16TID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-u8CID : 0x%X", ntohs(pstAddIndication->u16CID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-u16VCID : 0x%X", ntohs(pstAddIndication->u16VCID));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-autorized set loc : %p", pstAddIndication->psfAuthorizedSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-admitted set loc : %p", pstAddIndication->psfAdmittedSet);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "AddIndication-Active set loc : %p", pstAddIndication->psfActiveSet);\r\npstAddIndicationDest->u8Type = pstAddIndication->u8Type;\r\npstAddIndicationDest->u8Direction = pstAddIndication->eConnectionDir;\r\npstAddIndicationDest->u16TID = pstAddIndication->u16TID;\r\npstAddIndicationDest->u16CID = pstAddIndication->u16CID;\r\npstAddIndicationDest->u16VCID = pstAddIndication->u16VCID;\r\npstAddIndicationDest->u8CC = pstAddIndication->u8CC;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Restoring Active Set ");\r\nulStatus = RestoreSFParam(Adapter, (ULONG)pstAddIndication->psfActiveSet, (PUCHAR)&pstAddIndicationDest->sfActiveSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfActiveSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfActiveSet.u8TotalClassifiers = MAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Restoring Admitted Set ");\r\nulStatus = RestoreSFParam(Adapter, (ULONG)pstAddIndication->psfAdmittedSet, (PUCHAR)&pstAddIndicationDest->sfAdmittedSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfAdmittedSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfAdmittedSet.u8TotalClassifiers = MAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Restoring Authorized Set ");\r\nulStatus = RestoreSFParam(Adapter, (ULONG)pstAddIndication->psfAuthorizedSet, (PUCHAR)&pstAddIndicationDest->sfAuthorizedSet);\r\nif (ulStatus != 1)\r\ngoto failed_restore_sf_param;\r\nif (pstAddIndicationDest->sfAuthorizedSet.u8TotalClassifiers > MAX_CLASSIFIERS_IN_SF)\r\npstAddIndicationDest->sfAuthorizedSet.u8TotalClassifiers = MAX_CLASSIFIERS_IN_SF;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Dumping the whole raw packet");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "============================================================");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " pstAddIndicationDest->sfActiveSet size %zx %p", sizeof(*pstAddIndicationDest), pstAddIndicationDest);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "============================================================");\r\nreturn pstAddIndicationDest;\r\nfailed_restore_sf_param:\r\nkfree(pstAddIndicationDest);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "<=====");\r\nreturn NULL;\r\n}\r\nULONG SetUpTargetDsxBuffers(struct bcm_mini_adapter *Adapter)\r\n{\r\nULONG ulTargetDsxBuffersBase = 0;\r\nULONG ulCntTargetBuffers;\r\nULONG i;\r\nint Status;\r\nif (!Adapter) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Adapter was NULL!!!");\r\nreturn 0;\r\n}\r\nif (Adapter->astTargetDsxBuffer[0].ulTargetDsxBuffer)\r\nreturn 1;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Size of Each DSX Buffer(Also size of connection manager parameters): %zx ", sizeof(struct bcm_connect_mgr_params));\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Reading DSX buffer From Target location %x ", DSX_MESSAGE_EXCHANGE_BUFFER);\r\nStatus = rdmalt(Adapter, DSX_MESSAGE_EXCHANGE_BUFFER, (PUINT)&ulTargetDsxBuffersBase, sizeof(UINT));\r\nif (Status < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "RDM failed!!");\r\nreturn 0;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Base Address Of DSX Target Buffer : 0x%lx", ulTargetDsxBuffersBase);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Tgt Buffer is Now %lx :", ulTargetDsxBuffersBase);\r\nulCntTargetBuffers = DSX_MESSAGE_EXCHANGE_BUFFER_SIZE / sizeof(struct bcm_connect_mgr_params);\r\nAdapter->ulTotalTargetBuffersAvailable =\r\nulCntTargetBuffers > MAX_TARGET_DSX_BUFFERS ?\r\nMAX_TARGET_DSX_BUFFERS : ulCntTargetBuffers;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " Total Target DSX Buffer setup %lx ", Adapter->ulTotalTargetBuffersAvailable);\r\nfor (i = 0; i < Adapter->ulTotalTargetBuffersAvailable; i++) {\r\nAdapter->astTargetDsxBuffer[i].ulTargetDsxBuffer = ulTargetDsxBuffersBase;\r\nAdapter->astTargetDsxBuffer[i].valid = 1;\r\nAdapter->astTargetDsxBuffer[i].tid = 0;\r\nulTargetDsxBuffersBase += sizeof(struct bcm_connect_mgr_params);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " Target DSX Buffer %lx setup at 0x%lx",\r\ni, Adapter->astTargetDsxBuffer[i].ulTargetDsxBuffer);\r\n}\r\nAdapter->ulCurrentTargetBuffer = 0;\r\nAdapter->ulFreeTargetBufferCnt = Adapter->ulTotalTargetBuffersAvailable;\r\nreturn 1;\r\n}\r\nstatic ULONG GetNextTargetBufferLocation(struct bcm_mini_adapter *Adapter, B_UINT16 tid)\r\n{\r\nULONG dsx_buf;\r\nULONG idx, max_try;\r\nif ((Adapter->ulTotalTargetBuffersAvailable == 0) || (Adapter->ulFreeTargetBufferCnt == 0)) {\r\nClearTargetDSXBuffer(Adapter, tid, false);\r\nreturn 0;\r\n}\r\nidx = Adapter->ulCurrentTargetBuffer;\r\nmax_try = Adapter->ulTotalTargetBuffersAvailable;\r\nwhile ((max_try) && (Adapter->astTargetDsxBuffer[idx].valid != 1)) {\r\nidx = (idx+1) % Adapter->ulTotalTargetBuffersAvailable;\r\nmax_try--;\r\n}\r\nif (max_try == 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "\n GetNextTargetBufferLocation : Error No Free Target DSX Buffers FreeCnt : %lx ", Adapter->ulFreeTargetBufferCnt);\r\nClearTargetDSXBuffer(Adapter, tid, false);\r\nreturn 0;\r\n}\r\ndsx_buf = Adapter->astTargetDsxBuffer[idx].ulTargetDsxBuffer;\r\nAdapter->astTargetDsxBuffer[idx].valid = 0;\r\nAdapter->astTargetDsxBuffer[idx].tid = tid;\r\nAdapter->ulFreeTargetBufferCnt--;\r\nidx = (idx+1)%Adapter->ulTotalTargetBuffersAvailable;\r\nAdapter->ulCurrentTargetBuffer = idx;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "GetNextTargetBufferLocation :Returning address %lx tid %d\n", dsx_buf, tid);\r\nreturn dsx_buf;\r\n}\r\nint AllocAdapterDsxBuffer(struct bcm_mini_adapter *Adapter)\r\n{\r\nAdapter->caDsxReqResp = kmalloc(sizeof(struct bcm_add_indication_alt)+LEADER_SIZE, GFP_KERNEL);\r\nif (!Adapter->caDsxReqResp)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint FreeAdapterDsxBuffer(struct bcm_mini_adapter *Adapter)\r\n{\r\nkfree(Adapter->caDsxReqResp);\r\nreturn 0;\r\n}\r\nbool CmControlResponseMessage(struct bcm_mini_adapter *Adapter,\r\nPVOID pvBuffer )\r\n{\r\nstruct bcm_connect_mgr_params *psfLocalSet = NULL;\r\nstruct bcm_add_indication_alt *pstAddIndication = NULL;\r\nstruct bcm_change_indication *pstChangeIndication = NULL;\r\nstruct bcm_leader *pLeader = NULL;\r\npstAddIndication = RestoreCmControlResponseMessage(Adapter, pvBuffer);\r\nif (pstAddIndication == NULL) {\r\nClearTargetDSXBuffer(Adapter, ((struct bcm_add_indication *)pvBuffer)->u16TID, false);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "Error in restoring Service Flow param structure from DSx message");\r\nreturn false;\r\n}\r\nDumpCmControlPacket(pstAddIndication);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "====>");\r\npLeader = (struct bcm_leader *)Adapter->caDsxReqResp;\r\npLeader->Status = CM_CONTROL_NEWDSX_MULTICLASSIFIER_REQ;\r\npLeader->Vcid = 0;\r\nClearTargetDSXBuffer(Adapter, pstAddIndication->u16TID, false);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "### TID RECEIVED %d\n", pstAddIndication->u16TID);\r\nswitch (pstAddIndication->u8Type) {\r\ncase DSA_REQ:\r\n{\r\npLeader->PLength = sizeof(struct bcm_add_indication_alt);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Sending DSA Response....\n");\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSA RESPONSE TO MAC %d", pLeader->PLength);\r\n*((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))\r\n= *pstAddIndication;\r\n((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSA_RSP;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, " VCID = %x", ntohs(pstAddIndication->u16VCID));\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\nkfree(pstAddIndication);\r\n}\r\nbreak;\r\ncase DSA_RSP:\r\n{\r\npLeader->PLength = sizeof(struct bcm_add_indication_alt);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSA ACK TO MAC %d",\r\npLeader->PLength);\r\n*((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))\r\n= *pstAddIndication;\r\n((struct bcm_add_indication_alt *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSA_ACK;\r\n}\r\ncase DSA_ACK:\r\n{\r\nUINT uiSearchRuleIndex = 0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "VCID:0x%X",\r\nntohs(pstAddIndication->u16VCID));\r\nuiSearchRuleIndex = SearchFreeSfid(Adapter);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "uiSearchRuleIndex:0x%X ",\r\nuiSearchRuleIndex);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Direction:0x%X ",\r\npstAddIndication->u8Direction);\r\nif ((uiSearchRuleIndex < NO_OF_QUEUES)) {\r\nAdapter->PackInfo[uiSearchRuleIndex].ucDirection =\r\npstAddIndication->u8Direction;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "bValid:0x%X ",\r\npstAddIndication->sfActiveSet.bValid);\r\nif (pstAddIndication->sfActiveSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bActiveSet = TRUE;\r\nif (pstAddIndication->sfAuthorizedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAuthorizedSet = TRUE;\r\nif (pstAddIndication->sfAdmittedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAdmittedSet = TRUE;\r\nif (pstAddIndication->sfActiveSet.bValid == false) {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActivateRequestSent = false;\r\nif (pstAddIndication->sfAdmittedSet.bValid)\r\npsfLocalSet = &pstAddIndication->sfAdmittedSet;\r\nelse if (pstAddIndication->sfAuthorizedSet.bValid)\r\npsfLocalSet = &pstAddIndication->sfAuthorizedSet;\r\n} else {\r\npsfLocalSet = &pstAddIndication->sfActiveSet;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = TRUE;\r\n}\r\nif (!psfLocalSet) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "No set is valid\n");\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n} else if (psfLocalSet->bValid && (pstAddIndication->u8CC == 0)) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSA ACK");\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = ntohs(pstAddIndication->u16VCID);\r\nAdapter->PackInfo[uiSearchRuleIndex].usCID = ntohs(pstAddIndication->u16CID);\r\nif (UPLINK_DIR == pstAddIndication->u8Direction)\r\natomic_set(&Adapter->PackInfo[uiSearchRuleIndex].uiPerSFTxResourceCount, DEFAULT_PERSFCOUNT);\r\nCopyToAdapter(Adapter, psfLocalSet, uiSearchRuleIndex, DSA_ACK, pstAddIndication);\r\nmemcpy((((PUCHAR)pvBuffer)+1), &psfLocalSet->u32SFID, 4);\r\nif (pstAddIndication->sfActiveSet.bValid == TRUE) {\r\nif (UPLINK_DIR == pstAddIndication->u8Direction) {\r\nif (!Adapter->LinkUpStatus) {\r\nnetif_carrier_on(Adapter->dev);\r\nnetif_start_queue(Adapter->dev);\r\nAdapter->LinkUpStatus = 1;\r\nif (netif_msg_link(Adapter))\r\npr_info(PFX "%s: link up\n", Adapter->dev->name);\r\natomic_set(&Adapter->TxPktAvail, 1);\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\nAdapter->liTimeSinceLastNetEntry = get_seconds();\r\n}\r\n}\r\n}\r\n} else {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n}\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "DSA ACK did not get valid SFID");\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\n}\r\nbreak;\r\ncase DSC_REQ:\r\n{\r\npLeader->PLength = sizeof(struct bcm_change_indication);\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSC RESPONSE TO MAC %d", pLeader->PLength);\r\n*((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *pstChangeIndication;\r\n((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSC_RSP;\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\nkfree(pstAddIndication);\r\n}\r\nbreak;\r\ncase DSC_RSP:\r\n{\r\npLeader->PLength = sizeof(struct bcm_change_indication);\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSC ACK TO MAC %d", pLeader->PLength);\r\n*((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *pstChangeIndication;\r\n((struct bcm_change_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSC_ACK;\r\n}\r\ncase DSC_ACK:\r\n{\r\nUINT uiSearchRuleIndex = 0;\r\npstChangeIndication = (struct bcm_change_indication *)pstAddIndication;\r\nuiSearchRuleIndex = SearchSfid(Adapter, ntohl(pstChangeIndication->sfActiveSet.u32SFID));\r\nif (uiSearchRuleIndex > NO_OF_QUEUES-1)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "SF doesn't exist for which DSC_ACK is received");\r\nif ((uiSearchRuleIndex < NO_OF_QUEUES)) {\r\nAdapter->PackInfo[uiSearchRuleIndex].ucDirection = pstChangeIndication->u8Direction;\r\nif (pstChangeIndication->sfActiveSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bActiveSet = TRUE;\r\nif (pstChangeIndication->sfAuthorizedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAuthorizedSet = TRUE;\r\nif (pstChangeIndication->sfAdmittedSet.bValid == TRUE)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAdmittedSet = TRUE;\r\nif (pstChangeIndication->sfActiveSet.bValid == false) {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActivateRequestSent = false;\r\nif (pstChangeIndication->sfAdmittedSet.bValid)\r\npsfLocalSet = &pstChangeIndication->sfAdmittedSet;\r\nelse if (pstChangeIndication->sfAuthorizedSet.bValid)\r\npsfLocalSet = &pstChangeIndication->sfAuthorizedSet;\r\n} else {\r\npsfLocalSet = &pstChangeIndication->sfActiveSet;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = TRUE;\r\n}\r\nif (!psfLocalSet) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "No set is valid\n");\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].bValid = false;\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = 0;\r\nkfree(pstAddIndication);\r\n} else if (psfLocalSet->bValid && (pstChangeIndication->u8CC == 0)) {\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = ntohs(pstChangeIndication->u16VCID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "CC field is %d bvalid = %d\n",\r\npstChangeIndication->u8CC, psfLocalSet->bValid);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "VCID= %d\n", ntohs(pstChangeIndication->u16VCID));\r\nAdapter->PackInfo[uiSearchRuleIndex].usCID = ntohs(pstChangeIndication->u16CID);\r\nCopyToAdapter(Adapter, psfLocalSet, uiSearchRuleIndex, DSC_ACK, pstAddIndication);\r\n*(PULONG)(((PUCHAR)pvBuffer)+1) = psfLocalSet->u32SFID;\r\n} else if (pstChangeIndication->u8CC == 6) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nkfree(pstAddIndication);\r\n}\r\n} else {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "DSC ACK did not get valid SFID");\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\n}\r\nbreak;\r\ncase DSD_REQ:\r\n{\r\nUINT uiSearchRuleIndex;\r\nULONG ulSFID;\r\npLeader->PLength = sizeof(struct bcm_del_indication);\r\n*((struct bcm_del_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE])) = *((struct bcm_del_indication *)pstAddIndication);\r\nulSFID = ntohl(((struct bcm_del_indication *)pstAddIndication)->u32SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSD - Removing connection %x", uiSearchRuleIndex);\r\nif (uiSearchRuleIndex < NO_OF_QUEUES) {\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\nAdapter->u32TotalDSD++;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SENDING DSD RESPONSE TO MAC");\r\n((struct bcm_del_indication *)&(Adapter->caDsxReqResp[LEADER_SIZE]))->u8Type = DSD_RSP;\r\nCopyBufferToControlPacket(Adapter, (PVOID)Adapter->caDsxReqResp);\r\n}\r\ncase DSD_RSP:\r\n{\r\n}\r\nbreak;\r\ncase DSD_ACK:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "DSD ACK Rcd, let App handle it\n");\r\nbreak;\r\ndefault:\r\nkfree(pstAddIndication);\r\nreturn false;\r\n}\r\nreturn TRUE;\r\n}\r\nint get_dsx_sf_data_to_application(struct bcm_mini_adapter *Adapter, UINT uiSFId, void __user *user_buffer)\r\n{\r\nint status = 0;\r\nstruct bcm_packet_info *psSfInfo = NULL;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "status =%d", status);\r\nstatus = SearchSfid(Adapter, uiSFId);\r\nif (status >= NO_OF_QUEUES) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SFID %d not present in queue !!!", uiSFId);\r\nreturn -EINVAL;\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "status =%d", status);\r\npsSfInfo = &Adapter->PackInfo[status];\r\nif (psSfInfo->pstSFIndication && copy_to_user(user_buffer,\r\npsSfInfo->pstSFIndication, sizeof(struct bcm_add_indication_alt))) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, "copy to user failed SFID %d, present in queue !!!", uiSFId);\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nVOID OverrideServiceFlowParams(struct bcm_mini_adapter *Adapter, PUINT puiBuffer)\r\n{\r\nB_UINT32 u32NumofSFsinMsg = ntohl(*(puiBuffer + 1));\r\nstruct bcm_stim_sfhostnotify *pHostInfo = NULL;\r\nUINT uiSearchRuleIndex = 0;\r\nULONG ulSFID = 0;\r\npuiBuffer += 2;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "u32NumofSFsinMsg: 0x%x\n", u32NumofSFsinMsg);\r\nwhile (u32NumofSFsinMsg != 0 && u32NumofSFsinMsg < NO_OF_QUEUES) {\r\nu32NumofSFsinMsg--;\r\npHostInfo = (struct bcm_stim_sfhostnotify *)puiBuffer;\r\npuiBuffer = (PUINT)(pHostInfo + 1);\r\nulSFID = ntohl(pHostInfo->SFID);\r\nuiSearchRuleIndex = SearchSfid(Adapter, ulSFID);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "SFID: 0x%lx\n", ulSFID);\r\nif (uiSearchRuleIndex >= NO_OF_QUEUES || uiSearchRuleIndex == HiPriority) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "The SFID <%lx> doesn't exist in host entry or is Invalid\n", ulSFID);\r\ncontinue;\r\n}\r\nif (pHostInfo->RetainSF == false) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "Going to Delete SF");\r\ndeleteSFBySfid(Adapter, uiSearchRuleIndex);\r\n} else {\r\nAdapter->PackInfo[uiSearchRuleIndex].usVCID_Value = ntohs(pHostInfo->VCID);\r\nAdapter->PackInfo[uiSearchRuleIndex].usCID = ntohs(pHostInfo->newCID);\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = false;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CONN_MSG, DBG_LVL_ALL, "pHostInfo->QoSParamSet: 0x%x\n", pHostInfo->QoSParamSet);\r\nif (pHostInfo->QoSParamSet & 0x1)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAuthorizedSet = TRUE;\r\nif (pHostInfo->QoSParamSet & 0x2)\r\nAdapter->PackInfo[uiSearchRuleIndex].bAdmittedSet = TRUE;\r\nif (pHostInfo->QoSParamSet & 0x4) {\r\nAdapter->PackInfo[uiSearchRuleIndex].bActiveSet = TRUE;\r\nAdapter->PackInfo[uiSearchRuleIndex].bActive = TRUE;\r\n}\r\n}\r\n}\r\n}
