int tcp_init_cgroup(struct mem_cgroup *memcg, struct cgroup_subsys *ss)\r\n{\r\nstruct res_counter *res_parent = NULL;\r\nstruct cg_proto *cg_proto, *parent_cg;\r\nstruct mem_cgroup *parent = parent_mem_cgroup(memcg);\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn 0;\r\ncg_proto->sysctl_mem[0] = sysctl_tcp_mem[0];\r\ncg_proto->sysctl_mem[1] = sysctl_tcp_mem[1];\r\ncg_proto->sysctl_mem[2] = sysctl_tcp_mem[2];\r\ncg_proto->memory_pressure = 0;\r\ncg_proto->memcg = memcg;\r\nparent_cg = tcp_prot.proto_cgroup(parent);\r\nif (parent_cg)\r\nres_parent = &parent_cg->memory_allocated;\r\nres_counter_init(&cg_proto->memory_allocated, res_parent);\r\npercpu_counter_init(&cg_proto->sockets_allocated, 0);\r\nreturn 0;\r\n}\r\nvoid tcp_destroy_cgroup(struct mem_cgroup *memcg)\r\n{\r\nstruct cg_proto *cg_proto;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn;\r\npercpu_counter_destroy(&cg_proto->sockets_allocated);\r\n}\r\nstatic int tcp_update_limit(struct mem_cgroup *memcg, u64 val)\r\n{\r\nstruct cg_proto *cg_proto;\r\nint i;\r\nint ret;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn -EINVAL;\r\nif (val > RES_COUNTER_MAX)\r\nval = RES_COUNTER_MAX;\r\nret = res_counter_set_limit(&cg_proto->memory_allocated, val);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 3; i++)\r\ncg_proto->sysctl_mem[i] = min_t(long, val >> PAGE_SHIFT,\r\nsysctl_tcp_mem[i]);\r\nif (val == RES_COUNTER_MAX)\r\nclear_bit(MEMCG_SOCK_ACTIVE, &cg_proto->flags);\r\nelse if (val != RES_COUNTER_MAX) {\r\nif (!test_and_set_bit(MEMCG_SOCK_ACTIVATED, &cg_proto->flags))\r\nstatic_key_slow_inc(&memcg_socket_limit_enabled);\r\nset_bit(MEMCG_SOCK_ACTIVE, &cg_proto->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcp_cgroup_write(struct cgroup_subsys_state *css, struct cftype *cft,\r\nconst char *buffer)\r\n{\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\r\nunsigned long long val;\r\nint ret = 0;\r\nswitch (cft->private) {\r\ncase RES_LIMIT:\r\nret = res_counter_memparse_write_strategy(buffer, &val);\r\nif (ret)\r\nbreak;\r\nret = tcp_update_limit(memcg, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u64 tcp_read_stat(struct mem_cgroup *memcg, int type, u64 default_val)\r\n{\r\nstruct cg_proto *cg_proto;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn default_val;\r\nreturn res_counter_read_u64(&cg_proto->memory_allocated, type);\r\n}\r\nstatic u64 tcp_read_usage(struct mem_cgroup *memcg)\r\n{\r\nstruct cg_proto *cg_proto;\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn atomic_long_read(&tcp_memory_allocated) << PAGE_SHIFT;\r\nreturn res_counter_read_u64(&cg_proto->memory_allocated, RES_USAGE);\r\n}\r\nstatic u64 tcp_cgroup_read(struct cgroup_subsys_state *css, struct cftype *cft)\r\n{\r\nstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\r\nu64 val;\r\nswitch (cft->private) {\r\ncase RES_LIMIT:\r\nval = tcp_read_stat(memcg, RES_LIMIT, RES_COUNTER_MAX);\r\nbreak;\r\ncase RES_USAGE:\r\nval = tcp_read_usage(memcg);\r\nbreak;\r\ncase RES_FAILCNT:\r\ncase RES_MAX_USAGE:\r\nval = tcp_read_stat(memcg, cft->private, 0);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn val;\r\n}\r\nstatic int tcp_cgroup_reset(struct cgroup_subsys_state *css, unsigned int event)\r\n{\r\nstruct mem_cgroup *memcg;\r\nstruct cg_proto *cg_proto;\r\nmemcg = mem_cgroup_from_css(css);\r\ncg_proto = tcp_prot.proto_cgroup(memcg);\r\nif (!cg_proto)\r\nreturn 0;\r\nswitch (event) {\r\ncase RES_MAX_USAGE:\r\nres_counter_reset_max(&cg_proto->memory_allocated);\r\nbreak;\r\ncase RES_FAILCNT:\r\nres_counter_reset_failcnt(&cg_proto->memory_allocated);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init tcp_memcontrol_init(void)\r\n{\r\nWARN_ON(cgroup_add_cftypes(&mem_cgroup_subsys, tcp_files));\r\nreturn 0;\r\n}
