int dgnc_init_module(void)\r\n{\r\nint rc = 0;\r\nAPR(("%s, Digi International Part Number %s\n", DG_NAME, DG_PART));\r\nrc = dgnc_start();\r\nif (rc < 0) {\r\nreturn rc;\r\n}\r\nrc = dgnc_init_pci();\r\nif (rc < 0) {\r\nif (dgnc_NumBoards)\r\npci_unregister_driver(&dgnc_driver);\r\nelse\r\nprintk("WARNING: dgnc driver load failed. No Digi Neo or Classic boards found.\n");\r\ndgnc_cleanup_module();\r\n}\r\nelse {\r\ndgnc_create_driver_sysfiles(&dgnc_driver);\r\n}\r\nDPR_INIT(("Finished init_module. Returning %d\n", rc));\r\nreturn rc;\r\n}\r\nstatic int dgnc_start(void)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nif (dgnc_driver_start == FALSE) {\r\ndgnc_driver_start = TRUE;\r\ndgnc_init_globals();\r\ndgnc_NumBoards = 0;\r\nAPR(("For the tools package or updated drivers please visit http://www.digi.com\n"));\r\nif (!dgnc_Major_Control_Registered) {\r\nrc = register_chrdev(0, "dgnc", &dgnc_BoardFops);\r\nif (rc <= 0) {\r\nAPR(("Can't register dgnc driver device (%d)\n", rc));\r\nrc = -ENXIO;\r\nreturn rc;\r\n}\r\ndgnc_Major = rc;\r\ndgnc_class = class_create(THIS_MODULE, "dgnc_mgmt");\r\ndevice_create(dgnc_class, NULL,\r\nMKDEV(dgnc_Major, 0),\r\nNULL, "dgnc_mgmt");\r\ndgnc_Major_Control_Registered = TRUE;\r\n}\r\nrc = dgnc_tty_preinit();\r\nif (rc < 0) {\r\nAPR(("tty preinit - not enough memory (%d)\n", rc));\r\nreturn rc;\r\n}\r\nDGNC_LOCK(dgnc_poll_lock, flags);\r\ninit_timer(&dgnc_poll_timer);\r\ndgnc_poll_timer.function = dgnc_poll_handler;\r\ndgnc_poll_timer.data = 0;\r\ndgnc_poll_time = jiffies + dgnc_jiffies_from_ms(dgnc_poll_tick);\r\ndgnc_poll_timer.expires = dgnc_poll_time;\r\nDGNC_UNLOCK(dgnc_poll_lock, flags);\r\nadd_timer(&dgnc_poll_timer);\r\ndgnc_driver_state = DRIVER_READY;\r\n}\r\nreturn rc;\r\n}\r\nstatic int dgnc_init_pci(void)\r\n{\r\nreturn pci_register_driver(&dgnc_driver);\r\n}\r\nstatic int dgnc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint rc;\r\nrc = pci_enable_device(pdev);\r\nif (rc < 0) {\r\nrc = -EIO;\r\n} else {\r\nrc = dgnc_probe1(pdev, ent->driver_data);\r\nif (rc == 0) {\r\ndgnc_NumBoards++;\r\nDPR_INIT(("Incrementing numboards to %d\n", dgnc_NumBoards));\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int dgnc_probe1(struct pci_dev *pdev, int card_type)\r\n{\r\nreturn dgnc_found_board(pdev, card_type);\r\n}\r\nstatic void dgnc_remove_one(struct pci_dev *dev)\r\n{\r\n}\r\nvoid dgnc_cleanup_module(void)\r\n{\r\nint i;\r\nulong lock_flags;\r\nDGNC_LOCK(dgnc_poll_lock, lock_flags);\r\ndgnc_poll_stop = 1;\r\nDGNC_UNLOCK(dgnc_poll_lock, lock_flags);\r\ndel_timer_sync(&dgnc_poll_timer);\r\ndgnc_remove_driver_sysfiles(&dgnc_driver);\r\nif (dgnc_Major_Control_Registered) {\r\ndevice_destroy(dgnc_class, MKDEV(dgnc_Major, 0));\r\nclass_destroy(dgnc_class);\r\nunregister_chrdev(dgnc_Major, "dgnc");\r\n}\r\nfor (i = 0; i < dgnc_NumBoards; ++i) {\r\ndgnc_remove_ports_sysfiles(dgnc_Board[i]);\r\ndgnc_tty_uninit(dgnc_Board[i]);\r\ndgnc_cleanup_board(dgnc_Board[i]);\r\n}\r\ndgnc_tty_post_uninit();\r\n#if defined(DGNC_TRACER)\r\ndgnc_tracer_free();\r\n#endif\r\nif (dgnc_NumBoards)\r\npci_unregister_driver(&dgnc_driver);\r\n}\r\nstatic void dgnc_cleanup_board(struct dgnc_board *brd)\r\n{\r\nint i = 0;\r\nif(!brd || brd->magic != DGNC_BOARD_MAGIC)\r\nreturn;\r\nswitch (brd->device) {\r\ncase PCI_DEVICE_CLASSIC_4_DID:\r\ncase PCI_DEVICE_CLASSIC_8_DID:\r\ncase PCI_DEVICE_CLASSIC_4_422_DID:\r\ncase PCI_DEVICE_CLASSIC_8_422_DID:\r\noutb(0, brd->iobase + 0x4c);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (brd->irq)\r\nfree_irq(brd->irq, brd);\r\ntasklet_kill(&brd->helper_tasklet);\r\nif (brd->re_map_membase) {\r\niounmap(brd->re_map_membase);\r\nbrd->re_map_membase = NULL;\r\n}\r\nif (brd->msgbuf_head) {\r\nunsigned long flags;\r\nDGNC_LOCK(dgnc_global_lock, flags);\r\nbrd->msgbuf = NULL;\r\nprintk("%s", brd->msgbuf_head);\r\nkfree(brd->msgbuf_head);\r\nbrd->msgbuf_head = NULL;\r\nDGNC_UNLOCK(dgnc_global_lock, flags);\r\n}\r\nfor (i = 0; i < MAXPORTS ; i++) {\r\nif (brd->channels[i]) {\r\nif (brd->channels[i]->ch_rqueue)\r\nkfree(brd->channels[i]->ch_rqueue);\r\nif (brd->channels[i]->ch_equeue)\r\nkfree(brd->channels[i]->ch_equeue);\r\nif (brd->channels[i]->ch_wqueue)\r\nkfree(brd->channels[i]->ch_wqueue);\r\nkfree(brd->channels[i]);\r\nbrd->channels[i] = NULL;\r\n}\r\n}\r\nif (brd->flipbuf)\r\nkfree(brd->flipbuf);\r\ndgnc_Board[brd->boardnum] = NULL;\r\nkfree(brd);\r\n}\r\nstatic int dgnc_found_board(struct pci_dev *pdev, int id)\r\n{\r\nstruct dgnc_board *brd;\r\nunsigned int pci_irq;\r\nint i = 0;\r\nint rc = 0;\r\nunsigned long flags;\r\nbrd = dgnc_Board[dgnc_NumBoards] =\r\nkzalloc(sizeof(*brd), GFP_KERNEL);\r\nif (!brd)\r\nreturn -ENOMEM;\r\nbrd->msgbuf = brd->msgbuf_head =\r\nkzalloc(sizeof(u8) * 8192, GFP_KERNEL);\r\nif (!brd->msgbuf) {\r\nkfree(brd);\r\nreturn -ENOMEM;\r\n}\r\nbrd->magic = DGNC_BOARD_MAGIC;\r\nbrd->boardnum = dgnc_NumBoards;\r\nbrd->vendor = dgnc_pci_tbl[id].vendor;\r\nbrd->device = dgnc_pci_tbl[id].device;\r\nbrd->pdev = pdev;\r\nbrd->pci_bus = pdev->bus->number;\r\nbrd->pci_slot = PCI_SLOT(pdev->devfn);\r\nbrd->name = dgnc_Ids[id].name;\r\nbrd->maxports = dgnc_Ids[id].maxports;\r\nif (dgnc_Ids[i].is_pci_express)\r\nbrd->bd_flags |= BD_IS_PCI_EXPRESS;\r\nbrd->dpastatus = BD_NOFEP;\r\ninit_waitqueue_head(&brd->state_wait);\r\nDGNC_SPINLOCK_INIT(brd->bd_lock);\r\nDGNC_SPINLOCK_INIT(brd->bd_intr_lock);\r\nbrd->state = BOARD_FOUND;\r\nfor (i = 0; i < MAXPORTS; i++) {\r\nbrd->channels[i] = NULL;\r\n}\r\npci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &brd->subvendor);\r\npci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &brd->subdevice);\r\npci_read_config_byte(pdev, PCI_REVISION_ID, &brd->rev);\r\npci_irq = pdev->irq;\r\nbrd->irq = pci_irq;\r\nswitch(brd->device) {\r\ncase PCI_DEVICE_CLASSIC_4_DID:\r\ncase PCI_DEVICE_CLASSIC_8_DID:\r\ncase PCI_DEVICE_CLASSIC_4_422_DID:\r\ncase PCI_DEVICE_CLASSIC_8_422_DID:\r\nbrd->dpatype = T_CLASSIC | T_PCIBUS;\r\nDPR_INIT(("dgnc_found_board - Classic.\n"));\r\nbrd->membase = pci_resource_start(pdev, 4);\r\nif (!brd->membase) {\r\nAPR(("card has no PCI IO resources, failing board.\n"));\r\nreturn -ENODEV;\r\n}\r\nbrd->membase_end = pci_resource_end(pdev, 4);\r\nif (brd->membase & 1)\r\nbrd->membase &= ~3;\r\nelse\r\nbrd->membase &= ~15;\r\nbrd->iobase = pci_resource_start(pdev, 1);\r\nbrd->iobase_end = pci_resource_end(pdev, 1);\r\nbrd->iobase = ((unsigned int) (brd->iobase)) & 0xFFFE;\r\nbrd->bd_ops = &dgnc_cls_ops;\r\nbrd->bd_uart_offset = 0x8;\r\nbrd->bd_dividend = 921600;\r\ndgnc_do_remap(brd);\r\nbrd->bd_ops->vpd(brd);\r\noutb(0x43, brd->iobase + 0x4c);\r\nbreak;\r\ncase PCI_DEVICE_NEO_4_DID:\r\ncase PCI_DEVICE_NEO_8_DID:\r\ncase PCI_DEVICE_NEO_2DB9_DID:\r\ncase PCI_DEVICE_NEO_2DB9PRI_DID:\r\ncase PCI_DEVICE_NEO_2RJ45_DID:\r\ncase PCI_DEVICE_NEO_2RJ45PRI_DID:\r\ncase PCI_DEVICE_NEO_1_422_DID:\r\ncase PCI_DEVICE_NEO_1_422_485_DID:\r\ncase PCI_DEVICE_NEO_2_422_485_DID:\r\ncase PCI_DEVICE_NEO_EXPRESS_8_DID:\r\ncase PCI_DEVICE_NEO_EXPRESS_4_DID:\r\ncase PCI_DEVICE_NEO_EXPRESS_4RJ45_DID:\r\ncase PCI_DEVICE_NEO_EXPRESS_8RJ45_DID:\r\nif (brd->bd_flags & BD_IS_PCI_EXPRESS)\r\nbrd->dpatype = T_NEO_EXPRESS | T_PCIBUS;\r\nelse\r\nbrd->dpatype = T_NEO | T_PCIBUS;\r\nDPR_INIT(("dgnc_found_board - NEO.\n"));\r\nbrd->membase = pci_resource_start(pdev, 0);\r\nbrd->membase_end = pci_resource_end(pdev, 0);\r\nif (brd->membase & 1)\r\nbrd->membase &= ~3;\r\nelse\r\nbrd->membase &= ~15;\r\nbrd->bd_ops = &dgnc_neo_ops;\r\nbrd->bd_uart_offset = 0x200;\r\nbrd->bd_dividend = 921600;\r\ndgnc_do_remap(brd);\r\nif (brd->re_map_membase) {\r\nbrd->dvid = readb(brd->re_map_membase + 0x8D);\r\nbrd->bd_ops->vpd(brd);\r\n}\r\nbreak;\r\ndefault:\r\nAPR(("Did not find any compatible Neo or Classic PCI boards in system.\n"));\r\nreturn -ENXIO;\r\n}\r\nrc = dgnc_tty_register(brd);\r\nif (rc < 0) {\r\ndgnc_tty_uninit(brd);\r\nAPR(("Can't register tty devices (%d)\n", rc));\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\ngoto failed;\r\n}\r\nrc = dgnc_finalize_board_init(brd);\r\nif (rc < 0) {\r\nAPR(("Can't finalize board init (%d)\n", rc));\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\ngoto failed;\r\n}\r\nrc = dgnc_tty_init(brd);\r\nif (rc < 0) {\r\ndgnc_tty_uninit(brd);\r\nAPR(("Can't init tty devices (%d)\n", rc));\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\ngoto failed;\r\n}\r\nbrd->state = BOARD_READY;\r\nbrd->dpastatus = BD_RUNNING;\r\ndgnc_create_ports_sysfiles(brd);\r\ntasklet_init(&brd->helper_tasklet, brd->bd_ops->tasklet, (unsigned long) brd);\r\nDPR_INIT(("dgnc_scan(%d) - printing out the msgbuf\n", i));\r\nDGNC_LOCK(dgnc_global_lock, flags);\r\nbrd->msgbuf = NULL;\r\nprintk("%s", brd->msgbuf_head);\r\nkfree(brd->msgbuf_head);\r\nbrd->msgbuf_head = NULL;\r\nDGNC_UNLOCK(dgnc_global_lock, flags);\r\nbrd->flipbuf = kzalloc(MYFLIPLEN, GFP_KERNEL);\r\nwake_up_interruptible(&brd->state_wait);\r\nreturn 0;\r\nfailed:\r\nreturn -ENXIO;\r\n}\r\nstatic int dgnc_finalize_board_init(struct dgnc_board *brd) {\r\nint rc = 0;\r\nDPR_INIT(("dgnc_finalize_board_init() - start\n"));\r\nif (!brd || brd->magic != DGNC_BOARD_MAGIC)\r\nreturn -ENODEV;\r\nDPR_INIT(("dgnc_finalize_board_init() - start #2\n"));\r\nif (brd->irq) {\r\nrc = request_irq(brd->irq, brd->bd_ops->intr, IRQF_SHARED, "DGNC", brd);\r\nif (rc) {\r\nprintk("Failed to hook IRQ %d\n",brd->irq);\r\nbrd->state = BOARD_FAILED;\r\nbrd->dpastatus = BD_NOFEP;\r\nrc = -ENODEV;\r\n} else {\r\nDPR_INIT(("Requested and received usage of IRQ %d\n", brd->irq));\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void dgnc_do_remap(struct dgnc_board *brd)\r\n{\r\nif (!brd || brd->magic != DGNC_BOARD_MAGIC)\r\nreturn;\r\nbrd->re_map_membase = ioremap(brd->membase, 0x1000);\r\nDPR_INIT(("remapped mem: 0x%p\n", brd->re_map_membase));\r\n}\r\nstatic void dgnc_poll_handler(ulong dummy)\r\n{\r\nstruct dgnc_board *brd;\r\nunsigned long lock_flags;\r\nint i;\r\nunsigned long new_time;\r\ndgnc_poll_counter++;\r\nif (dgnc_driver_state != DRIVER_READY) {\r\ngoto schedule_poller;\r\n}\r\nfor (i = 0; i < dgnc_NumBoards; i++) {\r\nbrd = dgnc_Board[i];\r\nDGNC_LOCK(brd->bd_lock, lock_flags);\r\nif (brd->state == BOARD_FAILED) {\r\nDGNC_UNLOCK(brd->bd_lock, lock_flags);\r\ncontinue;\r\n}\r\ntasklet_schedule(&brd->helper_tasklet);\r\nDGNC_UNLOCK(brd->bd_lock, lock_flags);\r\n}\r\nschedule_poller:\r\nDGNC_LOCK(dgnc_poll_lock, lock_flags);\r\ndgnc_poll_time += dgnc_jiffies_from_ms(dgnc_poll_tick);\r\nnew_time = dgnc_poll_time - jiffies;\r\nif ((ulong) new_time >= 2 * dgnc_poll_tick) {\r\ndgnc_poll_time = jiffies + dgnc_jiffies_from_ms(dgnc_poll_tick);\r\n}\r\ninit_timer(&dgnc_poll_timer);\r\ndgnc_poll_timer.function = dgnc_poll_handler;\r\ndgnc_poll_timer.data = 0;\r\ndgnc_poll_timer.expires = dgnc_poll_time;\r\nDGNC_UNLOCK(dgnc_poll_lock, lock_flags);\r\nif (!dgnc_poll_stop)\r\nadd_timer(&dgnc_poll_timer);\r\n}\r\nstatic void dgnc_init_globals(void)\r\n{\r\nint i = 0;\r\ndgnc_rawreadok = rawreadok;\r\ndgnc_trcbuf_size = trcbuf_size;\r\ndgnc_debug = debug;\r\nfor (i = 0; i < MAXBOARDS; i++) {\r\ndgnc_Board[i] = NULL;\r\n}\r\ninit_timer(&dgnc_poll_timer);\r\n}\r\nint dgnc_ms_sleep(ulong ms)\r\n{\r\ncurrent->state = TASK_INTERRUPTIBLE;\r\nschedule_timeout((ms * HZ) / 1000);\r\nreturn signal_pending(current);\r\n}\r\nchar *dgnc_ioctl_name(int cmd)\r\n{\r\nswitch(cmd) {\r\ncase TCGETA: return "TCGETA";\r\ncase TCGETS: return "TCGETS";\r\ncase TCSETA: return "TCSETA";\r\ncase TCSETS: return "TCSETS";\r\ncase TCSETAW: return "TCSETAW";\r\ncase TCSETSW: return "TCSETSW";\r\ncase TCSETAF: return "TCSETAF";\r\ncase TCSETSF: return "TCSETSF";\r\ncase TCSBRK: return "TCSBRK";\r\ncase TCXONC: return "TCXONC";\r\ncase TCFLSH: return "TCFLSH";\r\ncase TIOCGSID: return "TIOCGSID";\r\ncase TIOCGETD: return "TIOCGETD";\r\ncase TIOCSETD: return "TIOCSETD";\r\ncase TIOCGWINSZ: return "TIOCGWINSZ";\r\ncase TIOCSWINSZ: return "TIOCSWINSZ";\r\ncase TIOCMGET: return "TIOCMGET";\r\ncase TIOCMSET: return "TIOCMSET";\r\ncase TIOCMBIS: return "TIOCMBIS";\r\ncase TIOCMBIC: return "TIOCMBIC";\r\ncase DIGI_SETA: return "DIGI_SETA";\r\ncase DIGI_SETAW: return "DIGI_SETAW";\r\ncase DIGI_SETAF: return "DIGI_SETAF";\r\ncase DIGI_SETFLOW: return "DIGI_SETFLOW";\r\ncase DIGI_SETAFLOW: return "DIGI_SETAFLOW";\r\ncase DIGI_GETFLOW: return "DIGI_GETFLOW";\r\ncase DIGI_GETAFLOW: return "DIGI_GETAFLOW";\r\ncase DIGI_GETA: return "DIGI_GETA";\r\ncase DIGI_GEDELAY: return "DIGI_GEDELAY";\r\ncase DIGI_SEDELAY: return "DIGI_SEDELAY";\r\ncase DIGI_GETCUSTOMBAUD: return "DIGI_GETCUSTOMBAUD";\r\ncase DIGI_SETCUSTOMBAUD: return "DIGI_SETCUSTOMBAUD";\r\ncase TIOCMODG: return "TIOCMODG";\r\ncase TIOCMODS: return "TIOCMODS";\r\ncase TIOCSDTR: return "TIOCSDTR";\r\ncase TIOCCDTR: return "TIOCCDTR";\r\ndefault: return "unknown";\r\n}\r\n}
