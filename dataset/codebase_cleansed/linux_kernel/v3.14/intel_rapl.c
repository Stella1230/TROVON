static struct rapl_package *find_package_by_id(int id)\r\n{\r\nstruct rapl_package *rp;\r\nlist_for_each_entry(rp, &rapl_packages, plist) {\r\nif (rp->id == id)\r\nreturn rp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_active_cpu_on_package(int package_id)\r\n{\r\nint i;\r\nfor_each_online_cpu(i) {\r\nif (topology_physical_package_id(i) == package_id)\r\nreturn i;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void rapl_cleanup_data(void)\r\n{\r\nstruct rapl_package *p, *tmp;\r\nlist_for_each_entry_safe(p, tmp, &rapl_packages, plist) {\r\nkfree(p->domains);\r\nlist_del(&p->plist);\r\nkfree(p);\r\n}\r\n}\r\nstatic int get_energy_counter(struct powercap_zone *power_zone, u64 *energy_raw)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 energy_now;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nif (!rapl_read_data_raw(rd, ENERGY_COUNTER, true, &energy_now)) {\r\n*energy_raw = energy_now;\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nput_online_cpus();\r\nreturn -EIO;\r\n}\r\nstatic int get_max_energy_counter(struct powercap_zone *pcd_dev, u64 *energy)\r\n{\r\n*energy = rapl_unit_xlate(0, ENERGY_UNIT, ENERGY_STATUS_MASK, 0);\r\nreturn 0;\r\n}\r\nstatic int release_zone(struct powercap_zone *power_zone)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nstruct rapl_package *rp;\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrp = find_package_by_id(rd->package_id);\r\nif (!rp) {\r\ndev_warn(&power_zone->dev, "no package id %s\n",\r\nrd->name);\r\nreturn -ENODEV;\r\n}\r\nkfree(rd);\r\nrp->domains = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int find_nr_power_limit(struct rapl_domain *rd)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_POWER_LIMITS; i++) {\r\nif (rd->rpl[i].name == NULL)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int set_domain_enable(struct powercap_zone *power_zone, bool mode)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nint nr_powerlimit;\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED)\r\nreturn -EACCES;\r\nget_online_cpus();\r\nnr_powerlimit = find_nr_power_limit(rd);\r\nrapl_write_data_raw(rd, PL1_ENABLE, mode);\r\nrapl_write_data_raw(rd, PL1_CLAMP, mode);\r\nif (nr_powerlimit > 1) {\r\nrapl_write_data_raw(rd, PL2_ENABLE, mode);\r\nrapl_write_data_raw(rd, PL2_CLAMP, mode);\r\n}\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic int get_domain_enable(struct powercap_zone *power_zone, bool *mode)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nu64 val;\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED) {\r\n*mode = false;\r\nreturn 0;\r\n}\r\nget_online_cpus();\r\nif (rapl_read_data_raw(rd, PL1_ENABLE, true, &val)) {\r\nput_online_cpus();\r\nreturn -EIO;\r\n}\r\n*mode = val;\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic int set_power_limit(struct powercap_zone *power_zone, int id,\r\nu64 power_limit)\r\n{\r\nstruct rapl_domain *rd;\r\nstruct rapl_package *rp;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nrp = find_package_by_id(rd->package_id);\r\nif (!rp) {\r\nret = -ENODEV;\r\ngoto set_exit;\r\n}\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED) {\r\ndev_warn(&power_zone->dev, "%s locked by BIOS, monitoring only\n",\r\nrd->name);\r\nret = -EACCES;\r\ngoto set_exit;\r\n}\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nrapl_write_data_raw(rd, POWER_LIMIT1, power_limit);\r\nbreak;\r\ncase PL2_ENABLE:\r\nrapl_write_data_raw(rd, POWER_LIMIT2, power_limit);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\npackage_power_limit_irq_save(rd->package_id);\r\nset_exit:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int get_current_power_limit(struct powercap_zone *power_zone, int id,\r\nu64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint prim;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nprim = POWER_LIMIT1;\r\nbreak;\r\ncase PL2_ENABLE:\r\nprim = POWER_LIMIT2;\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (rapl_read_data_raw(rd, prim, true, &val))\r\nret = -EIO;\r\nelse\r\n*data = val;\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int set_time_window(struct powercap_zone *power_zone, int id,\r\nu64 window)\r\n{\r\nstruct rapl_domain *rd;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nrapl_write_data_raw(rd, TIME_WINDOW1, window);\r\nbreak;\r\ncase PL2_ENABLE:\r\nrapl_write_data_raw(rd, TIME_WINDOW2, window);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int get_time_window(struct powercap_zone *power_zone, int id, u64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nret = rapl_read_data_raw(rd, TIME_WINDOW1, true, &val);\r\nbreak;\r\ncase PL2_ENABLE:\r\nret = rapl_read_data_raw(rd, TIME_WINDOW2, true, &val);\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (!ret)\r\n*data = val;\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic const char *get_constraint_name(struct powercap_zone *power_zone, int id)\r\n{\r\nstruct rapl_power_limit *rpl;\r\nstruct rapl_domain *rd;\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nrpl = (struct rapl_power_limit *) &rd->rpl[id];\r\nreturn rpl->name;\r\n}\r\nstatic int get_max_power(struct powercap_zone *power_zone, int id,\r\nu64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint prim;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nprim = THERMAL_SPEC_POWER;\r\nbreak;\r\ncase PL2_ENABLE:\r\nprim = MAX_POWER;\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (rapl_read_data_raw(rd, prim, true, &val))\r\nret = -EIO;\r\nelse\r\n*data = val;\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic void rapl_init_domains(struct rapl_package *rp)\r\n{\r\nint i;\r\nstruct rapl_domain *rd = rp->domains;\r\nfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\r\nunsigned int mask = rp->domain_map & (1 << i);\r\nswitch (mask) {\r\ncase BIT(RAPL_DOMAIN_PACKAGE):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PACKAGE];\r\nrd->id = RAPL_DOMAIN_PACKAGE;\r\nrd->msrs[0] = MSR_PKG_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PKG_ENERGY_STATUS;\r\nrd->msrs[2] = MSR_PKG_PERF_STATUS;\r\nrd->msrs[3] = 0;\r\nrd->msrs[4] = MSR_PKG_POWER_INFO;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nrd->rpl[1].prim_id = PL2_ENABLE;\r\nrd->rpl[1].name = pl2_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_PP0):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PP0];\r\nrd->id = RAPL_DOMAIN_PP0;\r\nrd->msrs[0] = MSR_PP0_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PP0_ENERGY_STATUS;\r\nrd->msrs[2] = 0;\r\nrd->msrs[3] = MSR_PP0_POLICY;\r\nrd->msrs[4] = 0;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_PP1):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PP1];\r\nrd->id = RAPL_DOMAIN_PP1;\r\nrd->msrs[0] = MSR_PP1_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PP1_ENERGY_STATUS;\r\nrd->msrs[2] = 0;\r\nrd->msrs[3] = MSR_PP1_POLICY;\r\nrd->msrs[4] = 0;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_DRAM):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_DRAM];\r\nrd->id = RAPL_DOMAIN_DRAM;\r\nrd->msrs[0] = MSR_DRAM_POWER_LIMIT;\r\nrd->msrs[1] = MSR_DRAM_ENERGY_STATUS;\r\nrd->msrs[2] = MSR_DRAM_PERF_STATUS;\r\nrd->msrs[3] = 0;\r\nrd->msrs[4] = MSR_DRAM_POWER_INFO;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nbreak;\r\n}\r\nif (mask) {\r\nrd->package_id = rp->id;\r\nrd++;\r\n}\r\n}\r\n}\r\nstatic u64 rapl_unit_xlate(int package, enum unit_type type, u64 value,\r\nint to_raw)\r\n{\r\nu64 divisor = 1;\r\nint scale = 1;\r\nu64 f, y;\r\nstruct rapl_package *rp;\r\nrp = find_package_by_id(package);\r\nif (!rp)\r\nreturn value;\r\nswitch (type) {\r\ncase POWER_UNIT:\r\ndivisor = rp->power_unit_divisor;\r\nscale = POWER_UNIT_SCALE;\r\nbreak;\r\ncase ENERGY_UNIT:\r\nscale = ENERGY_UNIT_SCALE;\r\ndivisor = rp->energy_unit_divisor;\r\nbreak;\r\ncase TIME_UNIT:\r\ndivisor = rp->time_unit_divisor;\r\nscale = TIME_UNIT_SCALE;\r\nif (!to_raw) {\r\nf = (value & 0x60) >> 5;\r\ny = value & 0x1f;\r\nvalue = (1 << y) * (4 + f) * scale / 4;\r\nreturn div64_u64(value, divisor);\r\n} else {\r\ndo_div(value, scale);\r\nvalue *= divisor;\r\ny = ilog2(value);\r\nf = div64_u64(4 * (value - (1 << y)), 1 << y);\r\nvalue = (y & 0x1f) | ((f & 0x3) << 5);\r\nreturn value;\r\n}\r\nbreak;\r\ncase ARBITRARY_UNIT:\r\ndefault:\r\nreturn value;\r\n};\r\nif (to_raw)\r\nreturn div64_u64(value * divisor, scale);\r\nelse\r\nreturn div64_u64(value * scale, divisor);\r\n}\r\nstatic int rapl_read_data_raw(struct rapl_domain *rd,\r\nenum rapl_primitives prim,\r\nbool xlate, u64 *data)\r\n{\r\nu64 value, final;\r\nu32 msr;\r\nstruct rapl_primitive_info *rp = &rpi[prim];\r\nint cpu;\r\nif (!rp->name || rp->flag & RAPL_PRIMITIVE_DUMMY)\r\nreturn -EINVAL;\r\nmsr = rd->msrs[rp->id];\r\nif (!msr)\r\nreturn -EINVAL;\r\ncpu = find_active_cpu_on_package(rd->package_id);\r\nif (cpu < 0)\r\nreturn cpu;\r\nif (prim == FW_LOCK && rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrp->mask = POWER_PACKAGE_LOCK;\r\nrp->shift = 63;\r\n}\r\nif (rp->flag & RAPL_PRIMITIVE_DERIVED) {\r\n*data = rd->rdd.primitives[prim];\r\nreturn 0;\r\n}\r\nif (rdmsrl_safe_on_cpu(cpu, msr, &value)) {\r\npr_debug("failed to read msr 0x%x on cpu %d\n", msr, cpu);\r\nreturn -EIO;\r\n}\r\nfinal = value & rp->mask;\r\nfinal = final >> rp->shift;\r\nif (xlate)\r\n*data = rapl_unit_xlate(rd->package_id, rp->unit, final, 0);\r\nelse\r\n*data = final;\r\nreturn 0;\r\n}\r\nstatic int rapl_write_data_raw(struct rapl_domain *rd,\r\nenum rapl_primitives prim,\r\nunsigned long long value)\r\n{\r\nu64 msr_val;\r\nu32 msr;\r\nstruct rapl_primitive_info *rp = &rpi[prim];\r\nint cpu;\r\ncpu = find_active_cpu_on_package(rd->package_id);\r\nif (cpu < 0)\r\nreturn cpu;\r\nmsr = rd->msrs[rp->id];\r\nif (rdmsrl_safe_on_cpu(cpu, msr, &msr_val)) {\r\ndev_dbg(&rd->power_zone.dev,\r\n"failed to read msr 0x%x on cpu %d\n", msr, cpu);\r\nreturn -EIO;\r\n}\r\nvalue = rapl_unit_xlate(rd->package_id, rp->unit, value, 1);\r\nmsr_val &= ~rp->mask;\r\nmsr_val |= value << rp->shift;\r\nif (wrmsrl_safe_on_cpu(cpu, msr, msr_val)) {\r\ndev_dbg(&rd->power_zone.dev,\r\n"failed to write msr 0x%x on cpu %d\n", msr, cpu);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rapl_check_unit(struct rapl_package *rp, int cpu)\r\n{\r\nu64 msr_val;\r\nu32 value;\r\nif (rdmsrl_safe_on_cpu(cpu, MSR_RAPL_POWER_UNIT, &msr_val)) {\r\npr_err("Failed to read power unit MSR 0x%x on CPU %d, exit.\n",\r\nMSR_RAPL_POWER_UNIT, cpu);\r\nreturn -ENODEV;\r\n}\r\nvalue = (msr_val & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;\r\nif (x86_match_cpu(energy_unit_quirk_ids))\r\nrp->energy_unit_divisor = 1000000 / (1 << value);\r\nelse\r\nrp->energy_unit_divisor = 1 << value;\r\nvalue = (msr_val & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;\r\nrp->power_unit_divisor = 1 << value;\r\nvalue = (msr_val & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;\r\nrp->time_unit_divisor = 1 << value;\r\npr_debug("Physical package %d units: energy=%d, time=%d, power=%d\n",\r\nrp->id,\r\nrp->energy_unit_divisor,\r\nrp->time_unit_divisor,\r\nrp->power_unit_divisor);\r\nreturn 0;\r\n}\r\nstatic void package_power_limit_irq_save(int package_id)\r\n{\r\nu32 l, h = 0;\r\nint cpu;\r\nstruct rapl_package *rp;\r\nrp = find_package_by_id(package_id);\r\nif (!rp)\r\nreturn;\r\nif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\r\nreturn;\r\ncpu = find_active_cpu_on_package(package_id);\r\nif (cpu < 0)\r\nreturn;\r\nrdmsr_safe_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\r\nif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED)) {\r\nrp->power_limit_irq = l & PACKAGE_THERM_INT_PLN_ENABLE;\r\nrp->power_limit_irq |= PACKAGE_PLN_INT_SAVED;\r\n}\r\nl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\r\nwrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic void package_power_limit_irq_restore(int package_id)\r\n{\r\nu32 l, h;\r\nint cpu;\r\nstruct rapl_package *rp;\r\nrp = find_package_by_id(package_id);\r\nif (!rp)\r\nreturn;\r\nif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\r\nreturn;\r\ncpu = find_active_cpu_on_package(package_id);\r\nif (cpu < 0)\r\nreturn;\r\nif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED))\r\nreturn;\r\nrdmsr_safe_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\r\nif (rp->power_limit_irq & PACKAGE_THERM_INT_PLN_ENABLE)\r\nl |= PACKAGE_THERM_INT_PLN_ENABLE;\r\nelse\r\nl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\r\nwrmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic void rapl_update_domain_data(void)\r\n{\r\nint dmn, prim;\r\nu64 val;\r\nstruct rapl_package *rp;\r\nlist_for_each_entry(rp, &rapl_packages, plist) {\r\nfor (dmn = 0; dmn < rp->nr_domains; dmn++) {\r\npr_debug("update package %d domain %s data\n", rp->id,\r\nrp->domains[dmn].name);\r\nfor (prim = 0; prim < NR_RAW_PRIMITIVES; prim++)\r\nif (!rapl_read_data_raw(&rp->domains[dmn], prim,\r\nrpi[prim].unit,\r\n&val))\r\nrp->domains[dmn].rdd.primitives[prim] =\r\nval;\r\n}\r\n}\r\n}\r\nstatic int rapl_unregister_powercap(void)\r\n{\r\nstruct rapl_package *rp;\r\nstruct rapl_domain *rd, *rd_package = NULL;\r\nlist_for_each_entry(rp, &rapl_packages, plist) {\r\npackage_power_limit_irq_restore(rp->id);\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains;\r\nrd++) {\r\npr_debug("remove package, undo power limit on %d: %s\n",\r\nrp->id, rd->name);\r\nrapl_write_data_raw(rd, PL1_ENABLE, 0);\r\nrapl_write_data_raw(rd, PL2_ENABLE, 0);\r\nrapl_write_data_raw(rd, PL1_CLAMP, 0);\r\nrapl_write_data_raw(rd, PL2_CLAMP, 0);\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrd_package = rd;\r\ncontinue;\r\n}\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\nif (rd_package)\r\npowercap_unregister_zone(control_type,\r\n&rd_package->power_zone);\r\n}\r\npowercap_unregister_control_type(control_type);\r\nreturn 0;\r\n}\r\nstatic int rapl_package_register_powercap(struct rapl_package *rp)\r\n{\r\nstruct rapl_domain *rd;\r\nint ret = 0;\r\nchar dev_name[17];\r\nstruct powercap_zone *power_zone = NULL;\r\nint nr_pl;\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nnr_pl = find_nr_power_limit(rd);\r\npr_debug("register socket %d package domain %s\n",\r\nrp->id, rd->name);\r\nmemset(dev_name, 0, sizeof(dev_name));\r\nsnprintf(dev_name, sizeof(dev_name), "%s-%d",\r\nrd->name, rp->id);\r\npower_zone = powercap_register_zone(&rd->power_zone,\r\ncontrol_type,\r\ndev_name, NULL,\r\n&zone_ops[rd->id],\r\nnr_pl,\r\n&constraint_ops);\r\nif (IS_ERR(power_zone)) {\r\npr_debug("failed to register package, %d\n",\r\nrp->id);\r\nret = PTR_ERR(power_zone);\r\ngoto exit_package;\r\n}\r\nrp->power_zone = power_zone;\r\nbreak;\r\n}\r\n}\r\nif (!power_zone) {\r\npr_err("no package domain found, unknown topology!\n");\r\nret = -ENODEV;\r\ngoto exit_package;\r\n}\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rd->id == RAPL_DOMAIN_PACKAGE)\r\ncontinue;\r\nnr_pl = find_nr_power_limit(rd);\r\npower_zone = powercap_register_zone(&rd->power_zone,\r\ncontrol_type, rd->name,\r\nrp->power_zone,\r\n&zone_ops[rd->id], nr_pl,\r\n&constraint_ops);\r\nif (IS_ERR(power_zone)) {\r\npr_debug("failed to register power_zone, %d:%s:%s\n",\r\nrp->id, rd->name, dev_name);\r\nret = PTR_ERR(power_zone);\r\ngoto err_cleanup;\r\n}\r\n}\r\nexit_package:\r\nreturn ret;\r\nerr_cleanup:\r\nwhile (--rd >= rp->domains) {\r\npr_debug("unregister package %d domain %s\n", rp->id, rd->name);\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rapl_register_powercap(void)\r\n{\r\nstruct rapl_domain *rd;\r\nstruct rapl_package *rp;\r\nint ret = 0;\r\ncontrol_type = powercap_register_control_type(NULL, "intel-rapl", NULL);\r\nif (IS_ERR(control_type)) {\r\npr_debug("failed to register powercap control_type.\n");\r\nreturn PTR_ERR(control_type);\r\n}\r\nrapl_update_domain_data();\r\nlist_for_each_entry(rp, &rapl_packages, plist)\r\nif (rapl_package_register_powercap(rp))\r\ngoto err_cleanup_package;\r\nreturn ret;\r\nerr_cleanup_package:\r\nlist_for_each_entry_continue_reverse(rp, &rapl_packages, plist) {\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains;\r\nrd++) {\r\npr_debug("unregister zone/package %d, %s domain\n",\r\nrp->id, rd->name);\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int rapl_check_domain(int cpu, int domain)\r\n{\r\nunsigned msr;\r\nu64 val1, val2 = 0;\r\nint retry = 0;\r\nswitch (domain) {\r\ncase RAPL_DOMAIN_PACKAGE:\r\nmsr = MSR_PKG_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_PP0:\r\nmsr = MSR_PP0_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_PP1:\r\nmsr = MSR_PP1_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_DRAM:\r\nmsr = MSR_DRAM_ENERGY_STATUS;\r\nbreak;\r\ndefault:\r\npr_err("invalid domain id %d\n", domain);\r\nreturn -EINVAL;\r\n}\r\nif (rdmsrl_safe_on_cpu(cpu, msr, &val1))\r\nreturn -ENODEV;\r\nwhile (++retry < 10) {\r\nusleep_range(10000, 15000);\r\nrdmsrl_safe_on_cpu(cpu, msr, &val2);\r\nif ((val1 & ENERGY_STATUS_MASK) != (val2 & ENERGY_STATUS_MASK))\r\nreturn 0;\r\n}\r\npr_info("domain %s energy ctr %llu:%llu not working, skip\n",\r\nrapl_domain_names[domain], val1, val2);\r\nreturn -ENODEV;\r\n}\r\nstatic int rapl_detect_domains(struct rapl_package *rp, int cpu)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct rapl_domain *rd;\r\nu64 locked;\r\nfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\r\nif (!rapl_check_domain(cpu, i))\r\nrp->domain_map |= 1 << i;\r\n}\r\nrp->nr_domains = bitmap_weight(&rp->domain_map, RAPL_DOMAIN_MAX);\r\nif (!rp->nr_domains) {\r\npr_err("no valid rapl domains found in package %d\n", rp->id);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\npr_debug("found %d domains on package %d\n", rp->nr_domains, rp->id);\r\nrp->domains = kcalloc(rp->nr_domains + 1, sizeof(struct rapl_domain),\r\nGFP_KERNEL);\r\nif (!rp->domains) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nrapl_init_domains(rp);\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rapl_read_data_raw(rd, FW_LOCK, false, &locked)) {\r\npr_info("RAPL package %d domain %s locked by BIOS\n",\r\nrp->id, rd->name);\r\nrd->state |= DOMAIN_STATE_BIOS_LOCKED;\r\n}\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic bool is_package_new(int package)\r\n{\r\nstruct rapl_package *rp;\r\nlist_for_each_entry(rp, &rapl_packages, plist)\r\nif (package == rp->id)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int rapl_detect_topology(void)\r\n{\r\nint i;\r\nint phy_package_id;\r\nstruct rapl_package *new_package, *rp;\r\nfor_each_online_cpu(i) {\r\nphy_package_id = topology_physical_package_id(i);\r\nif (is_package_new(phy_package_id)) {\r\nnew_package = kzalloc(sizeof(*rp), GFP_KERNEL);\r\nif (!new_package) {\r\nrapl_cleanup_data();\r\nreturn -ENOMEM;\r\n}\r\nnew_package->id = phy_package_id;\r\nnew_package->nr_cpus = 1;\r\nif (rapl_detect_domains(new_package, i) ||\r\nrapl_check_unit(new_package, i)) {\r\nkfree(new_package->domains);\r\nkfree(new_package);\r\nrapl_cleanup_data();\r\nreturn -ENODEV;\r\n}\r\nINIT_LIST_HEAD(&new_package->plist);\r\nlist_add(&new_package->plist, &rapl_packages);\r\n} else {\r\nrp = find_package_by_id(phy_package_id);\r\nif (rp)\r\n++rp->nr_cpus;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rapl_remove_package(struct rapl_package *rp)\r\n{\r\nstruct rapl_domain *rd, *rd_package = NULL;\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrd_package = rd;\r\ncontinue;\r\n}\r\npr_debug("remove package %d, %s domain\n", rp->id, rd->name);\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\npowercap_unregister_zone(control_type, &rd_package->power_zone);\r\nlist_del(&rp->plist);\r\nkfree(rp);\r\n}\r\nstatic int rapl_add_package(int cpu)\r\n{\r\nint ret = 0;\r\nint phy_package_id;\r\nstruct rapl_package *rp;\r\nphy_package_id = topology_physical_package_id(cpu);\r\nrp = kzalloc(sizeof(struct rapl_package), GFP_KERNEL);\r\nif (!rp)\r\nreturn -ENOMEM;\r\nrp->id = phy_package_id;\r\nrp->nr_cpus = 1;\r\nif (rapl_detect_domains(rp, cpu) ||\r\nrapl_check_unit(rp, cpu)) {\r\nret = -ENODEV;\r\ngoto err_free_package;\r\n}\r\nif (!rapl_package_register_powercap(rp)) {\r\nINIT_LIST_HEAD(&rp->plist);\r\nlist_add(&rp->plist, &rapl_packages);\r\nreturn ret;\r\n}\r\nerr_free_package:\r\nkfree(rp->domains);\r\nkfree(rp);\r\nreturn ret;\r\n}\r\nstatic int rapl_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned long cpu = (unsigned long)hcpu;\r\nint phy_package_id;\r\nstruct rapl_package *rp;\r\nphy_package_id = topology_physical_package_id(cpu);\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\ncase CPU_DOWN_FAILED:\r\ncase CPU_DOWN_FAILED_FROZEN:\r\nrp = find_package_by_id(phy_package_id);\r\nif (rp)\r\n++rp->nr_cpus;\r\nelse\r\nrapl_add_package(cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\ncase CPU_DOWN_PREPARE_FROZEN:\r\nrp = find_package_by_id(phy_package_id);\r\nif (!rp)\r\nbreak;\r\nif (--rp->nr_cpus == 0)\r\nrapl_remove_package(rp);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init rapl_init(void)\r\n{\r\nint ret = 0;\r\nif (!x86_match_cpu(rapl_ids)) {\r\npr_err("driver does not support CPU family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nget_online_cpus();\r\nret = rapl_detect_topology();\r\nif (ret)\r\ngoto done;\r\nif (rapl_register_powercap()) {\r\nrapl_cleanup_data();\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nregister_hotcpu_notifier(&rapl_cpu_notifier);\r\ndone:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic void __exit rapl_exit(void)\r\n{\r\nget_online_cpus();\r\nunregister_hotcpu_notifier(&rapl_cpu_notifier);\r\nrapl_unregister_powercap();\r\nrapl_cleanup_data();\r\nput_online_cpus();\r\n}
