static uint32_t axi_clkgen_lookup_filter(unsigned int m)\r\n{\r\nswitch (m) {\r\ncase 0:\r\nreturn 0x01001990;\r\ncase 1:\r\nreturn 0x01001190;\r\ncase 2:\r\nreturn 0x01009890;\r\ncase 3:\r\nreturn 0x01001890;\r\ncase 4:\r\nreturn 0x01008890;\r\ncase 5 ... 8:\r\nreturn 0x01009090;\r\ncase 9 ... 11:\r\nreturn 0x01000890;\r\ncase 12:\r\nreturn 0x08009090;\r\ncase 13 ... 22:\r\nreturn 0x01001090;\r\ncase 23 ... 36:\r\nreturn 0x01008090;\r\ncase 37 ... 46:\r\nreturn 0x08001090;\r\ndefault:\r\nreturn 0x08008090;\r\n}\r\n}\r\nstatic uint32_t axi_clkgen_lookup_lock(unsigned int m)\r\n{\r\nif (m < ARRAY_SIZE(axi_clkgen_lock_table))\r\nreturn axi_clkgen_lock_table[m];\r\nreturn 0x1f1f00fa;\r\n}\r\nstatic void axi_clkgen_calc_params(unsigned long fin, unsigned long fout,\r\nunsigned int *best_d, unsigned int *best_m, unsigned int *best_dout)\r\n{\r\nunsigned long d, d_min, d_max, _d_min, _d_max;\r\nunsigned long m, m_min, m_max;\r\nunsigned long f, dout, best_f, fvco;\r\nfin /= 1000;\r\nfout /= 1000;\r\nbest_f = ULONG_MAX;\r\n*best_d = 0;\r\n*best_m = 0;\r\n*best_dout = 0;\r\nd_min = max_t(unsigned long, DIV_ROUND_UP(fin, fpfd_max), 1);\r\nd_max = min_t(unsigned long, fin / fpfd_min, 80);\r\nm_min = max_t(unsigned long, DIV_ROUND_UP(fvco_min, fin) * d_min, 1);\r\nm_max = min_t(unsigned long, fvco_max * d_max / fin, 64);\r\nfor (m = m_min; m <= m_max; m++) {\r\n_d_min = max(d_min, DIV_ROUND_UP(fin * m, fvco_max));\r\n_d_max = min(d_max, fin * m / fvco_min);\r\nfor (d = _d_min; d <= _d_max; d++) {\r\nfvco = fin * m / d;\r\ndout = DIV_ROUND_CLOSEST(fvco, fout);\r\ndout = clamp_t(unsigned long, dout, 1, 128);\r\nf = fvco / dout;\r\nif (abs(f - fout) < abs(best_f - fout)) {\r\nbest_f = f;\r\n*best_d = d;\r\n*best_m = m;\r\n*best_dout = dout;\r\nif (best_f == fout)\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void axi_clkgen_calc_clk_params(unsigned int divider, unsigned int *low,\r\nunsigned int *high, unsigned int *edge, unsigned int *nocount)\r\n{\r\nif (divider == 1)\r\n*nocount = 1;\r\nelse\r\n*nocount = 0;\r\n*high = divider / 2;\r\n*edge = divider % 2;\r\n*low = divider - *high;\r\n}\r\nstatic void axi_clkgen_write(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int val)\r\n{\r\nwritel(val, axi_clkgen->base + reg);\r\n}\r\nstatic void axi_clkgen_read(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int *val)\r\n{\r\n*val = readl(axi_clkgen->base + reg);\r\n}\r\nstatic struct axi_clkgen *clk_hw_to_axi_clkgen(struct clk_hw *clk_hw)\r\n{\r\nreturn container_of(clk_hw, struct axi_clkgen, clk_hw);\r\n}\r\nstatic int axi_clkgen_set_rate(struct clk_hw *clk_hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\nunsigned int d, m, dout;\r\nunsigned int nocount;\r\nunsigned int high;\r\nunsigned int edge;\r\nunsigned int low;\r\nuint32_t filter;\r\nuint32_t lock;\r\nif (parent_rate == 0 || rate == 0)\r\nreturn -EINVAL;\r\naxi_clkgen_calc_params(parent_rate, rate, &d, &m, &dout);\r\nif (d == 0 || dout == 0 || m == 0)\r\nreturn -EINVAL;\r\nfilter = axi_clkgen_lookup_filter(m - 1);\r\nlock = axi_clkgen_lookup_lock(m - 1);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_UPDATE_ENABLE, 0);\r\naxi_clkgen_calc_clk_params(dout, &low, &high, &edge, &nocount);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_CLK_OUT1,\r\n(high << 6) | low);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_CLK_OUT2,\r\n(edge << 7) | (nocount << 6));\r\naxi_clkgen_calc_clk_params(d, &low, &high, &edge, &nocount);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_CLK_DIV,\r\n(edge << 13) | (nocount << 12) | (high << 6) | low);\r\naxi_clkgen_calc_clk_params(m, &low, &high, &edge, &nocount);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_CLK_FB1,\r\n(high << 6) | low);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_CLK_FB2,\r\n(edge << 7) | (nocount << 6));\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_LOCK1, lock & 0x3ff);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_LOCK2,\r\n(((lock >> 16) & 0x1f) << 10) | 0x1);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_LOCK3,\r\n(((lock >> 24) & 0x1f) << 10) | 0x3e9);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_FILTER1, filter >> 16);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_FILTER2, filter);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_REG_UPDATE_ENABLE, 1);\r\nreturn 0;\r\n}\r\nstatic long axi_clkgen_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int d, m, dout;\r\naxi_clkgen_calc_params(*parent_rate, rate, &d, &m, &dout);\r\nif (d == 0 || dout == 0 || m == 0)\r\nreturn -EINVAL;\r\nreturn *parent_rate / d * m / dout;\r\n}\r\nstatic unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\nunsigned int d, m, dout;\r\nunsigned int reg;\r\nunsigned long long tmp;\r\naxi_clkgen_read(axi_clkgen, AXI_CLKGEN_REG_CLK_OUT1, &reg);\r\ndout = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\naxi_clkgen_read(axi_clkgen, AXI_CLKGEN_REG_CLK_DIV, &reg);\r\nd = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\naxi_clkgen_read(axi_clkgen, AXI_CLKGEN_REG_CLK_FB1, &reg);\r\nm = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\nif (d == 0 || dout == 0)\r\nreturn 0;\r\ntmp = (unsigned long long)(parent_rate / d) * m;\r\ndo_div(tmp, dout);\r\nif (tmp > ULONG_MAX)\r\nreturn ULONG_MAX;\r\nreturn tmp;\r\n}\r\nstatic int axi_clkgen_probe(struct platform_device *pdev)\r\n{\r\nstruct axi_clkgen *axi_clkgen;\r\nstruct clk_init_data init;\r\nconst char *parent_name;\r\nconst char *clk_name;\r\nstruct resource *mem;\r\nstruct clk *clk;\r\naxi_clkgen = devm_kzalloc(&pdev->dev, sizeof(*axi_clkgen), GFP_KERNEL);\r\nif (!axi_clkgen)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naxi_clkgen->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(axi_clkgen->base))\r\nreturn PTR_ERR(axi_clkgen->base);\r\nparent_name = of_clk_get_parent_name(pdev->dev.of_node, 0);\r\nif (!parent_name)\r\nreturn -EINVAL;\r\nclk_name = pdev->dev.of_node->name;\r\nof_property_read_string(pdev->dev.of_node, "clock-output-names",\r\n&clk_name);\r\ninit.name = clk_name;\r\ninit.ops = &axi_clkgen_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\naxi_clkgen->clk_hw.init = &init;\r\nclk = devm_clk_register(&pdev->dev, &axi_clkgen->clk_hw);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nreturn of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get,\r\nclk);\r\n}\r\nstatic int axi_clkgen_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
