static u8 gx1_read_conf_reg(u8 reg)\r\n{\r\nu8 val, ccr3;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gx1_conf_reg_lock, flags);\r\noutb(CONFIG_CCR3, 0x22);\r\nccr3 = inb(0x23);\r\noutb(CONFIG_CCR3, 0x22);\r\noutb(ccr3 | CONFIG_CCR3_MAPEN, 0x23);\r\noutb(reg, 0x22);\r\nval = inb(0x23);\r\noutb(CONFIG_CCR3, 0x22);\r\noutb(ccr3, 0x23);\r\nspin_unlock_irqrestore(&gx1_conf_reg_lock, flags);\r\nreturn val;\r\n}\r\nunsigned gx1_gx_base(void)\r\n{\r\nreturn (gx1_read_conf_reg(CONFIG_GCR) & 0x03) << 30;\r\n}\r\nint gx1_frame_buffer_size(void)\r\n{\r\nvoid __iomem *mc_regs;\r\nu32 bank_cfg;\r\nint d;\r\nunsigned dram_size = 0, fb_base;\r\nmc_regs = ioremap(gx1_gx_base() + 0x8400, 0x100);\r\nif (!mc_regs)\r\nreturn -ENOMEM;\r\nbank_cfg = readl(mc_regs + MC_BANK_CFG);\r\nfor (d = 0; d < 2; d++) {\r\nif ((bank_cfg & MC_BCFG_DIMM0_PG_SZ_MASK) != MC_BCFG_DIMM0_PG_SZ_NO_DIMM)\r\ndram_size += 0x400000 << ((bank_cfg & MC_BCFG_DIMM0_SZ_MASK) >> 8);\r\nbank_cfg >>= 16;\r\n}\r\nfb_base = (readl(mc_regs + MC_GBASE_ADD) & MC_GADD_GBADD_MASK) << 19;\r\niounmap(mc_regs);\r\nreturn dram_size - fb_base;\r\n}\r\nstatic void gx1_set_mode(struct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nu32 gcfg, tcfg, ocfg, dclk_div, val;\r\nint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\r\nint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\r\nreadl(par->dc_regs + DC_UNLOCK);\r\nwritel(DC_UNLOCK_CODE, par->dc_regs + DC_UNLOCK);\r\ngcfg = readl(par->dc_regs + DC_GENERAL_CFG);\r\ntcfg = readl(par->dc_regs + DC_TIMING_CFG);\r\ntcfg &= ~(DC_TCFG_BLKE | DC_TCFG_TGEN);\r\nwritel(tcfg, par->dc_regs + DC_TIMING_CFG);\r\nudelay(100);\r\ngcfg &= ~(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);\r\nwritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\r\ngcfg &= ~DC_GCFG_DCLK_MASK;\r\nwritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\r\npar->vid_ops->set_dclk(info);\r\ndclk_div = DC_GCFG_DCLK_DIV_1;\r\ngcfg |= dclk_div;\r\nwritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\r\nudelay(1000);\r\ngcfg = DC_GCFG_VRDY | dclk_div;\r\ngcfg |= (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;\r\nwritel(0, par->dc_regs + DC_FB_ST_OFFSET);\r\nwritel(info->fix.line_length >> 2, par->dc_regs + DC_LINE_DELTA);\r\nwritel(((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2,\r\npar->dc_regs + DC_BUF_SIZE);\r\nocfg = DC_OCFG_PCKE | DC_OCFG_PDEL | DC_OCFG_PDEH;\r\nif (info->var.bits_per_pixel == 8) ocfg |= DC_OCFG_8BPP;\r\ntcfg = DC_TCFG_FPPE | DC_TCFG_HSYE | DC_TCFG_VSYE | DC_TCFG_BLKE\r\n| DC_TCFG_TGEN;\r\nhactive = info->var.xres;\r\nhblankstart = hactive;\r\nhsyncstart = hblankstart + info->var.right_margin;\r\nhsyncend = hsyncstart + info->var.hsync_len;\r\nhblankend = hsyncend + info->var.left_margin;\r\nhtotal = hblankend;\r\nvactive = info->var.yres;\r\nvblankstart = vactive;\r\nvsyncstart = vblankstart + info->var.lower_margin;\r\nvsyncend = vsyncstart + info->var.vsync_len;\r\nvblankend = vsyncend + info->var.upper_margin;\r\nvtotal = vblankend;\r\nval = (hactive - 1) | ((htotal - 1) << 16);\r\nwritel(val, par->dc_regs + DC_H_TIMING_1);\r\nval = (hblankstart - 1) | ((hblankend - 1) << 16);\r\nwritel(val, par->dc_regs + DC_H_TIMING_2);\r\nval = (hsyncstart - 1) | ((hsyncend - 1) << 16);\r\nwritel(val, par->dc_regs + DC_H_TIMING_3);\r\nwritel(val, par->dc_regs + DC_FP_H_TIMING);\r\nval = (vactive - 1) | ((vtotal - 1) << 16);\r\nwritel(val, par->dc_regs + DC_V_TIMING_1);\r\nval = (vblankstart - 1) | ((vblankend - 1) << 16);\r\nwritel(val, par->dc_regs + DC_V_TIMING_2);\r\nval = (vsyncstart - 1) | ((vsyncend - 1) << 16);\r\nwritel(val, par->dc_regs + DC_V_TIMING_3);\r\nval = (vsyncstart - 2) | ((vsyncend - 2) << 16);\r\nwritel(val, par->dc_regs + DC_FP_V_TIMING);\r\nwritel(ocfg, par->dc_regs + DC_OUTPUT_CFG);\r\nwritel(tcfg, par->dc_regs + DC_TIMING_CFG);\r\nudelay(1000);\r\nwritel(gcfg, par->dc_regs + DC_GENERAL_CFG);\r\npar->vid_ops->configure_display(info);\r\nwritel(0, par->dc_regs + DC_UNLOCK);\r\n}\r\nstatic void gx1_set_hw_palette_reg(struct fb_info *info, unsigned regno,\r\nunsigned red, unsigned green, unsigned blue)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nint val;\r\nval = (red << 2) & 0x3f000;\r\nval |= (green >> 4) & 0x00fc0;\r\nval |= (blue >> 10) & 0x0003f;\r\nwritel(regno, par->dc_regs + DC_PAL_ADDRESS);\r\nwritel(val, par->dc_regs + DC_PAL_DATA);\r\n}
