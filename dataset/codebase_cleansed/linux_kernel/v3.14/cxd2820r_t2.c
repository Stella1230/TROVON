int cxd2820r_set_frontend_t2(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, bw_i;\r\nu32 if_freq, if_ctl;\r\nu64 num;\r\nu8 buf[3], bw_param;\r\nu8 bw_params1[][5] = {\r\n{ 0x1c, 0xb3, 0x33, 0x33, 0x33 },\r\n{ 0x17, 0xea, 0xaa, 0xaa, 0xaa },\r\n{ 0x14, 0x80, 0x00, 0x00, 0x00 },\r\n{ 0x11, 0xf0, 0x00, 0x00, 0x00 },\r\n};\r\nstruct reg_val_mask tab[] = {\r\n{ 0x00080, 0x02, 0xff },\r\n{ 0x00081, 0x20, 0xff },\r\n{ 0x00085, 0x07, 0xff },\r\n{ 0x00088, 0x01, 0xff },\r\n{ 0x02069, 0x01, 0xff },\r\n{ 0x0207f, 0x2a, 0xff },\r\n{ 0x02082, 0x0a, 0xff },\r\n{ 0x02083, 0x0a, 0xff },\r\n{ 0x020cb, priv->cfg.if_agc_polarity << 6, 0x40 },\r\n{ 0x02070, priv->cfg.ts_mode, 0xff },\r\n{ 0x020b5, priv->cfg.spec_inv << 4, 0x10 },\r\n{ 0x02567, 0x07, 0x0f },\r\n{ 0x02569, 0x03, 0x03 },\r\n{ 0x02595, 0x1a, 0xff },\r\n{ 0x02596, 0x50, 0xff },\r\n{ 0x02a8c, 0x00, 0xff },\r\n{ 0x02a8d, 0x34, 0xff },\r\n{ 0x02a45, 0x06, 0x07 },\r\n{ 0x03f10, 0x0d, 0xff },\r\n{ 0x03f11, 0x02, 0xff },\r\n{ 0x03f12, 0x01, 0xff },\r\n{ 0x03f23, 0x2c, 0xff },\r\n{ 0x03f51, 0x13, 0xff },\r\n{ 0x03f52, 0x01, 0xff },\r\n{ 0x03f53, 0x00, 0xff },\r\n{ 0x027e6, 0x14, 0xff },\r\n{ 0x02786, 0x02, 0x07 },\r\n{ 0x02787, 0x40, 0xe0 },\r\n{ 0x027ef, 0x10, 0x18 },\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s: frequency=%d bandwidth_hz=%d\n", __func__,\r\nc->frequency, c->bandwidth_hz);\r\nswitch (c->bandwidth_hz) {\r\ncase 5000000:\r\nbw_i = 0;\r\nbw_param = 3;\r\nbreak;\r\ncase 6000000:\r\nbw_i = 1;\r\nbw_param = 2;\r\nbreak;\r\ncase 7000000:\r\nbw_i = 2;\r\nbw_param = 1;\r\nbreak;\r\ncase 8000000:\r\nbw_i = 3;\r\nbw_param = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (priv->delivery_system != SYS_DVBT2) {\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = cxd2820r_wr_reg_mask(priv, tab[i].reg,\r\ntab[i].val, tab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\n}\r\npriv->delivery_system = SYS_DVBT2;\r\nif (fe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_freq);\r\nif (ret)\r\ngoto error;\r\n} else\r\nif_freq = 0;\r\ndev_dbg(&priv->i2c->dev, "%s: if_freq=%d\n", __func__, if_freq);\r\nnum = if_freq / 1000;\r\nnum *= 0x1000000;\r\nif_ctl = cxd2820r_div_u64_round_closest(num, 41000);\r\nbuf[0] = ((if_ctl >> 16) & 0xff);\r\nbuf[1] = ((if_ctl >> 8) & 0xff);\r\nbuf[2] = ((if_ctl >> 0) & 0xff);\r\nif (c->stream_id > 255) {\r\ndev_dbg(&priv->i2c->dev, "%s: Disable PLP filtering\n", __func__);\r\nret = cxd2820r_wr_reg(priv, 0x023ad , 0);\r\nif (ret)\r\ngoto error;\r\n} else {\r\ndev_dbg(&priv->i2c->dev, "%s: Enable PLP filtering = %d\n", __func__,\r\nc->stream_id);\r\nret = cxd2820r_wr_reg(priv, 0x023af , c->stream_id & 0xFF);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg(priv, 0x023ad , 1);\r\nif (ret)\r\ngoto error;\r\n}\r\nret = cxd2820r_wr_regs(priv, 0x020b6, buf, 3);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_regs(priv, 0x0209f, bw_params1[bw_i], 5);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg_mask(priv, 0x020d7, bw_param << 6, 0xc0);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg(priv, 0x000ff, 0x08);\r\nif (ret)\r\ngoto error;\r\nret = cxd2820r_wr_reg(priv, 0x000fe, 0x01);\r\nif (ret)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_get_frontend_t2(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 buf[2];\r\nret = cxd2820r_rd_regs(priv, 0x0205c, buf, 2);\r\nif (ret)\r\ngoto error;\r\nswitch ((buf[0] >> 0) & 0x07) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\ncase 2:\r\nc->transmission_mode = TRANSMISSION_MODE_4K;\r\nbreak;\r\ncase 3:\r\nc->transmission_mode = TRANSMISSION_MODE_1K;\r\nbreak;\r\ncase 4:\r\nc->transmission_mode = TRANSMISSION_MODE_16K;\r\nbreak;\r\ncase 5:\r\nc->transmission_mode = TRANSMISSION_MODE_32K;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 4) & 0x07) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ncase 4:\r\nc->guard_interval = GUARD_INTERVAL_1_128;\r\nbreak;\r\ncase 5:\r\nc->guard_interval = GUARD_INTERVAL_19_128;\r\nbreak;\r\ncase 6:\r\nc->guard_interval = GUARD_INTERVAL_19_256;\r\nbreak;\r\n}\r\nret = cxd2820r_rd_regs(priv, 0x0225b, buf, 2);\r\nif (ret)\r\ngoto error;\r\nswitch ((buf[0] >> 0) & 0x07) {\r\ncase 0:\r\nc->fec_inner = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->fec_inner = FEC_3_5;\r\nbreak;\r\ncase 2:\r\nc->fec_inner = FEC_2_3;\r\nbreak;\r\ncase 3:\r\nc->fec_inner = FEC_3_4;\r\nbreak;\r\ncase 4:\r\nc->fec_inner = FEC_4_5;\r\nbreak;\r\ncase 5:\r\nc->fec_inner = FEC_5_6;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 0x07) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\ncase 3:\r\nc->modulation = QAM_256;\r\nbreak;\r\n}\r\nret = cxd2820r_rd_reg(priv, 0x020b5, &buf[0]);\r\nif (ret)\r\ngoto error;\r\nswitch ((buf[0] >> 4) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_status_t2(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[1];\r\n*status = 0;\r\nret = cxd2820r_rd_reg(priv, 0x02010 , &buf[0]);\r\nif (ret)\r\ngoto error;\r\nif ((buf[0] & 0x07) == 6) {\r\nif (((buf[0] >> 5) & 0x01) == 1) {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n} else {\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC;\r\n}\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: lock=%02x\n", __func__, buf[0]);\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_ber_t2(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[4];\r\nunsigned int errbits;\r\n*ber = 0;\r\nret = cxd2820r_rd_regs(priv, 0x02039, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\nif ((buf[0] >> 4) & 0x01) {\r\nerrbits = (buf[0] & 0x0f) << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3];\r\nif (errbits)\r\n*ber = errbits * 64 / 16588800;\r\n}\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_signal_strength_t2(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nu16 tmp;\r\nret = cxd2820r_rd_regs(priv, 0x02026, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\ntmp = (buf[0] & 0x0f) << 8 | buf[1];\r\ntmp = ~tmp & 0x0fff;\r\n*strength = tmp * 0xffff / 0x0fff;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_snr_t2(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nu16 tmp;\r\nret = cxd2820r_rd_regs(priv, 0x02028, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\ntmp = (buf[0] & 0x0f) << 8 | buf[1];\r\n#define CXD2820R_LOG10_8_24 15151336\r\nif (tmp)\r\n*snr = (intlog10(tmp) - CXD2820R_LOG10_8_24) / ((1 << 24)\r\n/ 100);\r\nelse\r\n*snr = 0;\r\ndev_dbg(&priv->i2c->dev, "%s: dBx10=%d val=%04x\n", __func__, *snr,\r\ntmp);\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_read_ucblocks_t2(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nint cxd2820r_sleep_t2(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2820r_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x000ff, 0x1f, 0xff },\r\n{ 0x00085, 0x00, 0xff },\r\n{ 0x00088, 0x01, 0xff },\r\n{ 0x02069, 0x00, 0xff },\r\n{ 0x00081, 0x00, 0xff },\r\n{ 0x00080, 0x00, 0xff },\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = cxd2820r_wr_reg_mask(priv, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret)\r\ngoto error;\r\n}\r\npriv->delivery_system = SYS_UNDEFINED;\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint cxd2820r_get_tune_settings_t2(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 1500;\r\ns->step_size = fe->ops.info.frequency_stepsize * 2;\r\ns->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;\r\nreturn 0;\r\n}
