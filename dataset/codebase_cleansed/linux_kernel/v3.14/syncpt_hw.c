static void syncpt_restore(struct host1x_syncpt *sp)\r\n{\r\nstruct host1x *host = sp->host;\r\nint min = host1x_syncpt_read_min(sp);\r\nhost1x_sync_writel(host, min, HOST1X_SYNC_SYNCPT(sp->id));\r\n}\r\nstatic void syncpt_restore_wait_base(struct host1x_syncpt *sp)\r\n{\r\nstruct host1x *host = sp->host;\r\nhost1x_sync_writel(host, sp->base_val,\r\nHOST1X_SYNC_SYNCPT_BASE(sp->id));\r\n}\r\nstatic void syncpt_read_wait_base(struct host1x_syncpt *sp)\r\n{\r\nstruct host1x *host = sp->host;\r\nsp->base_val =\r\nhost1x_sync_readl(host, HOST1X_SYNC_SYNCPT_BASE(sp->id));\r\n}\r\nstatic u32 syncpt_load(struct host1x_syncpt *sp)\r\n{\r\nstruct host1x *host = sp->host;\r\nu32 old, live;\r\ndo {\r\nold = host1x_syncpt_read_min(sp);\r\nlive = host1x_sync_readl(host, HOST1X_SYNC_SYNCPT(sp->id));\r\n} while ((u32)atomic_cmpxchg(&sp->min_val, old, live) != old);\r\nif (!host1x_syncpt_check_max(sp, live))\r\ndev_err(host->dev, "%s failed: id=%u, min=%d, max=%d\n",\r\n__func__, sp->id, host1x_syncpt_read_min(sp),\r\nhost1x_syncpt_read_max(sp));\r\nreturn live;\r\n}\r\nstatic int syncpt_cpu_incr(struct host1x_syncpt *sp)\r\n{\r\nstruct host1x *host = sp->host;\r\nu32 reg_offset = sp->id / 32;\r\nif (!host1x_syncpt_client_managed(sp) &&\r\nhost1x_syncpt_idle(sp))\r\nreturn -EINVAL;\r\nhost1x_sync_writel(host, BIT_MASK(sp->id),\r\nHOST1X_SYNC_SYNCPT_CPU_INCR(reg_offset));\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int syncpt_patch_wait(struct host1x_syncpt *sp, void *patch_addr)\r\n{\r\nu32 override = host1x_class_host_wait_syncpt(\r\nHOST1X_SYNCPT_RESERVED, 0);\r\n*((u32 *)patch_addr) = override;\r\nreturn 0;\r\n}
