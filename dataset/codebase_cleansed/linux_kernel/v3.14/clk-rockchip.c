static void __init rk2928_gate_clk_init(struct device_node *node,\r\nvoid *data)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nconst char *clk_parent;\r\nconst char *clk_name;\r\nvoid __iomem *reg;\r\nvoid __iomem *reg_idx;\r\nint flags;\r\nint qty;\r\nint reg_bit;\r\nint clkflags = CLK_SET_RATE_PARENT;\r\nint i;\r\nqty = of_property_count_strings(node, "clock-output-names");\r\nif (qty < 0) {\r\npr_err("%s: error in clock-output-names %d\n", __func__, qty);\r\nreturn;\r\n}\r\nif (qty == 0) {\r\npr_info("%s: nothing to do\n", __func__);\r\nreturn;\r\n}\r\nreg = of_iomap(node, 0);\r\nclk_data = kzalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clks = kzalloc(qty * sizeof(struct clk *), GFP_KERNEL);\r\nif (!clk_data->clks) {\r\nkfree(clk_data);\r\nreturn;\r\n}\r\nflags = CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE;\r\nfor (i = 0; i < qty; i++) {\r\nof_property_read_string_index(node, "clock-output-names",\r\ni, &clk_name);\r\nif (!strcmp("reserved", clk_name))\r\ncontinue;\r\nclk_parent = of_clk_get_parent_name(node, i);\r\nclkflags |= CLK_IGNORE_UNUSED;\r\nreg_idx = reg + (4 * (i / 16));\r\nreg_bit = (i % 16);\r\nclk_data->clks[i] = clk_register_gate(NULL, clk_name,\r\nclk_parent, clkflags,\r\nreg_idx, reg_bit,\r\nflags,\r\n&clk_lock);\r\nWARN_ON(IS_ERR(clk_data->clks[i]));\r\n}\r\nclk_data->clk_num = qty;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\n}
