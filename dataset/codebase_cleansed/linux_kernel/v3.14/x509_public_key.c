int x509_get_sig_params(struct x509_certificate *cert)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nvoid *digest;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (cert->sig.rsa.s)\r\nreturn 0;\r\ncert->sig.rsa.s = mpi_read_raw_data(cert->raw_sig, cert->raw_sig_size);\r\nif (!cert->sig.rsa.s)\r\nreturn -ENOMEM;\r\ncert->sig.nr_mpi = 1;\r\ntfm = crypto_alloc_shash(hash_algo_name[cert->sig.pkey_hash_algo], 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndigest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\ndigest = kzalloc(digest_size + desc_size, GFP_KERNEL);\r\nif (!digest)\r\ngoto error;\r\ncert->sig.digest = digest;\r\ncert->sig.digest_size = digest_size;\r\ndesc = digest + digest_size;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nmight_sleep();\r\nret = crypto_shash_finup(desc, cert->tbs, cert->tbs_size, digest);\r\nerror:\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint x509_check_signature(const struct public_key *pub,\r\nstruct x509_certificate *cert)\r\n{\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nret = x509_get_sig_params(cert);\r\nif (ret < 0)\r\nreturn ret;\r\nret = public_key_verify_signature(pub, &cert->sig);\r\npr_debug("Cert Verification: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int x509_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct x509_certificate *cert;\r\nsize_t srlen, sulen;\r\nchar *desc = NULL;\r\nint ret;\r\ncert = x509_cert_parse(prep->data, prep->datalen);\r\nif (IS_ERR(cert))\r\nreturn PTR_ERR(cert);\r\npr_devel("Cert Issuer: %s\n", cert->issuer);\r\npr_devel("Cert Subject: %s\n", cert->subject);\r\nif (cert->pub->pkey_algo >= PKEY_ALGO__LAST ||\r\ncert->sig.pkey_algo >= PKEY_ALGO__LAST ||\r\ncert->sig.pkey_hash_algo >= PKEY_HASH__LAST ||\r\n!pkey_algo[cert->pub->pkey_algo] ||\r\n!pkey_algo[cert->sig.pkey_algo] ||\r\n!hash_algo_name[cert->sig.pkey_hash_algo]) {\r\nret = -ENOPKG;\r\ngoto error_free_cert;\r\n}\r\npr_devel("Cert Key Algo: %s\n", pkey_algo_name[cert->pub->pkey_algo]);\r\npr_devel("Cert Valid From: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_from.tm_year + 1900, cert->valid_from.tm_mon + 1,\r\ncert->valid_from.tm_mday, cert->valid_from.tm_hour,\r\ncert->valid_from.tm_min, cert->valid_from.tm_sec);\r\npr_devel("Cert Valid To: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_to.tm_year + 1900, cert->valid_to.tm_mon + 1,\r\ncert->valid_to.tm_mday, cert->valid_to.tm_hour,\r\ncert->valid_to.tm_min, cert->valid_to.tm_sec);\r\npr_devel("Cert Signature: %s + %s\n",\r\npkey_algo_name[cert->sig.pkey_algo],\r\nhash_algo_name[cert->sig.pkey_hash_algo]);\r\nif (!cert->fingerprint) {\r\npr_warn("Cert for '%s' must have a SubjKeyId extension\n",\r\ncert->subject);\r\nret = -EKEYREJECTED;\r\ngoto error_free_cert;\r\n}\r\ncert->pub->algo = pkey_algo[cert->pub->pkey_algo];\r\ncert->pub->id_type = PKEY_ID_X509;\r\nif (!cert->authority ||\r\nstrcmp(cert->fingerprint, cert->authority) == 0) {\r\nret = x509_check_signature(cert->pub, cert);\r\nif (ret < 0)\r\ngoto error_free_cert;\r\n}\r\nsulen = strlen(cert->subject);\r\nsrlen = strlen(cert->fingerprint);\r\nret = -ENOMEM;\r\ndesc = kmalloc(sulen + 2 + srlen + 1, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_free_cert;\r\nmemcpy(desc, cert->subject, sulen);\r\ndesc[sulen] = ':';\r\ndesc[sulen + 1] = ' ';\r\nmemcpy(desc + sulen + 2, cert->fingerprint, srlen);\r\ndesc[sulen + 2 + srlen] = 0;\r\n__module_get(public_key_subtype.owner);\r\nprep->type_data[0] = &public_key_subtype;\r\nprep->type_data[1] = cert->fingerprint;\r\nprep->payload = cert->pub;\r\nprep->description = desc;\r\nprep->quotalen = 100;\r\ncert->pub = NULL;\r\ncert->fingerprint = NULL;\r\ndesc = NULL;\r\nret = 0;\r\nerror_free_cert:\r\nx509_free_certificate(cert);\r\nreturn ret;\r\n}\r\nstatic int __init x509_key_init(void)\r\n{\r\nreturn register_asymmetric_key_parser(&x509_key_parser);\r\n}\r\nstatic void __exit x509_key_exit(void)\r\n{\r\nunregister_asymmetric_key_parser(&x509_key_parser);\r\n}
