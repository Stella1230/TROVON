static int set_lcd_level(int level)\r\n{\r\nu8 buf[2];\r\nif (level < 0 || level >= MSI_LCD_LEVEL_MAX)\r\nreturn -EINVAL;\r\nbuf[0] = 0x80;\r\nbuf[1] = (u8) (level*31);\r\nreturn ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, buf, sizeof(buf),\r\nNULL, 0);\r\n}\r\nstatic int get_lcd_level(void)\r\n{\r\nu8 wdata = 0, rdata;\r\nint result;\r\nresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, &wdata, 1,\r\n&rdata, 1);\r\nif (result < 0)\r\nreturn result;\r\nreturn (int) rdata / 31;\r\n}\r\nstatic int get_auto_brightness(void)\r\n{\r\nu8 wdata = 4, rdata;\r\nint result;\r\nresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, &wdata, 1,\r\n&rdata, 1);\r\nif (result < 0)\r\nreturn result;\r\nreturn !!(rdata & 8);\r\n}\r\nstatic int set_auto_brightness(int enable)\r\n{\r\nu8 wdata[2], rdata;\r\nint result;\r\nwdata[0] = 4;\r\nresult = ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, wdata, 1,\r\n&rdata, 1);\r\nif (result < 0)\r\nreturn result;\r\nwdata[0] = 0x84;\r\nwdata[1] = (rdata & 0xF7) | (enable ? 8 : 0);\r\nreturn ec_transaction(MSI_EC_COMMAND_LCD_LEVEL, wdata, 2,\r\nNULL, 0);\r\n}\r\nstatic ssize_t set_device_state(const char *buf, size_t count, u8 mask)\r\n{\r\nint status;\r\nu8 wdata = 0, rdata;\r\nint result;\r\nif (sscanf(buf, "%i", &status) != 1 || (status < 0 || status > 1))\r\nreturn -EINVAL;\r\nif (quirks->ec_read_only)\r\nreturn -EOPNOTSUPP;\r\nresult = ec_read(MSI_STANDARD_EC_COMMAND_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nif (!!(rdata & mask) != status) {\r\nif (rdata & mask)\r\nwdata = rdata & ~mask;\r\nelse\r\nwdata = rdata | mask;\r\nresult = ec_write(MSI_STANDARD_EC_COMMAND_ADDRESS, wdata);\r\nif (result < 0)\r\nreturn result;\r\n}\r\nreturn count;\r\n}\r\nstatic int get_wireless_state(int *wlan, int *bluetooth)\r\n{\r\nu8 wdata = 0, rdata;\r\nint result;\r\nresult = ec_transaction(MSI_EC_COMMAND_WIRELESS, &wdata, 1, &rdata, 1);\r\nif (result < 0)\r\nreturn result;\r\nif (wlan)\r\n*wlan = !!(rdata & 8);\r\nif (bluetooth)\r\n*bluetooth = !!(rdata & 128);\r\nreturn 0;\r\n}\r\nstatic int get_wireless_state_ec_standard(void)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_COMMAND_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nwlan_s = !!(rdata & MSI_STANDARD_EC_WLAN_MASK);\r\nbluetooth_s = !!(rdata & MSI_STANDARD_EC_BLUETOOTH_MASK);\r\nthreeg_s = !!(rdata & MSI_STANDARD_EC_3G_MASK);\r\nreturn 0;\r\n}\r\nstatic int get_threeg_exists(void)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_DEVICES_EXISTS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nthreeg_exists = !!(rdata & MSI_STANDARD_EC_3G_MASK);\r\nreturn 0;\r\n}\r\nstatic int bl_get_brightness(struct backlight_device *b)\r\n{\r\nreturn get_lcd_level();\r\n}\r\nstatic int bl_update_status(struct backlight_device *b)\r\n{\r\nreturn set_lcd_level(b->props.brightness);\r\n}\r\nstatic ssize_t show_wlan(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret, enabled = 0;\r\nif (quirks->old_ec_model) {\r\nret = get_wireless_state(&enabled, NULL);\r\n} else {\r\nret = get_wireless_state_ec_standard();\r\nenabled = wlan_s;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", enabled);\r\n}\r\nstatic ssize_t store_wlan(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn set_device_state(buf, count, MSI_STANDARD_EC_WLAN_MASK);\r\n}\r\nstatic ssize_t show_bluetooth(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret, enabled = 0;\r\nif (quirks->old_ec_model) {\r\nret = get_wireless_state(NULL, &enabled);\r\n} else {\r\nret = get_wireless_state_ec_standard();\r\nenabled = bluetooth_s;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", enabled);\r\n}\r\nstatic ssize_t store_bluetooth(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn set_device_state(buf, count, MSI_STANDARD_EC_BLUETOOTH_MASK);\r\n}\r\nstatic ssize_t show_threeg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nif (quirks->old_ec_model)\r\nreturn -ENODEV;\r\nret = get_wireless_state_ec_standard();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", threeg_s);\r\n}\r\nstatic ssize_t store_threeg(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nreturn set_device_state(buf, count, MSI_STANDARD_EC_3G_MASK);\r\n}\r\nstatic ssize_t show_lcd_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nret = get_lcd_level();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t store_lcd_level(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint level, ret;\r\nif (sscanf(buf, "%i", &level) != 1 ||\r\n(level < 0 || level >= MSI_LCD_LEVEL_MAX))\r\nreturn -EINVAL;\r\nret = set_lcd_level(level);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_brightness(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nret = get_auto_brightness();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%i\n", ret);\r\n}\r\nstatic ssize_t store_auto_brightness(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint enable, ret;\r\nif (sscanf(buf, "%i", &enable) != 1 || (enable != (enable & 1)))\r\nreturn -EINVAL;\r\nret = set_auto_brightness(enable);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_touchpad(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nreturn sprintf(buf, "%i\n", !!(rdata & MSI_STANDARD_EC_TOUCHPAD_MASK));\r\n}\r\nstatic ssize_t show_turbo(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nreturn sprintf(buf, "%i\n", !!(rdata & MSI_STANDARD_EC_TURBO_MASK));\r\n}\r\nstatic ssize_t show_eco(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nreturn sprintf(buf, "%i\n", !!(rdata & MSI_STANDARD_EC_ECO_MASK));\r\n}\r\nstatic ssize_t show_turbo_cooldown(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nreturn sprintf(buf, "%i\n", (!!(rdata & MSI_STANDARD_EC_TURBO_MASK)) |\r\n(!!(rdata & MSI_STANDARD_EC_TURBO_COOLDOWN_MASK) << 1));\r\n}\r\nstatic ssize_t show_auto_fan(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FAN_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn result;\r\nreturn sprintf(buf, "%i\n", !!(rdata & MSI_STANDARD_EC_AUTOFAN_MASK));\r\n}\r\nstatic ssize_t store_auto_fan(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint enable, result;\r\nif (sscanf(buf, "%i", &enable) != 1 || (enable != (enable & 1)))\r\nreturn -EINVAL;\r\nresult = ec_write(MSI_STANDARD_EC_FAN_ADDRESS, enable);\r\nif (result < 0)\r\nreturn result;\r\nreturn count;\r\n}\r\nstatic int dmi_check_cb(const struct dmi_system_id *dmi)\r\n{\r\npr_info("Identified laptop model '%s'\n", dmi->ident);\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic int rfkill_bluetooth_set(void *data, bool blocked)\r\n{\r\nint result = set_device_state(blocked ? "0" : "1", 0,\r\nMSI_STANDARD_EC_BLUETOOTH_MASK);\r\nreturn min(result, 0);\r\n}\r\nstatic int rfkill_wlan_set(void *data, bool blocked)\r\n{\r\nint result = set_device_state(blocked ? "0" : "1", 0,\r\nMSI_STANDARD_EC_WLAN_MASK);\r\nreturn min(result, 0);\r\n}\r\nstatic int rfkill_threeg_set(void *data, bool blocked)\r\n{\r\nint result = set_device_state(blocked ? "0" : "1", 0,\r\nMSI_STANDARD_EC_3G_MASK);\r\nreturn min(result, 0);\r\n}\r\nstatic void rfkill_cleanup(void)\r\n{\r\nif (rfk_bluetooth) {\r\nrfkill_unregister(rfk_bluetooth);\r\nrfkill_destroy(rfk_bluetooth);\r\n}\r\nif (rfk_threeg) {\r\nrfkill_unregister(rfk_threeg);\r\nrfkill_destroy(rfk_threeg);\r\n}\r\nif (rfk_wlan) {\r\nrfkill_unregister(rfk_wlan);\r\nrfkill_destroy(rfk_wlan);\r\n}\r\n}\r\nstatic bool msi_rfkill_set_state(struct rfkill *rfkill, bool blocked)\r\n{\r\nif (quirks->ec_read_only)\r\nreturn rfkill_set_hw_state(rfkill, blocked);\r\nelse\r\nreturn rfkill_set_sw_state(rfkill, blocked);\r\n}\r\nstatic void msi_update_rfkill(struct work_struct *ignored)\r\n{\r\nget_wireless_state_ec_standard();\r\nif (rfk_wlan)\r\nmsi_rfkill_set_state(rfk_wlan, !wlan_s);\r\nif (rfk_bluetooth)\r\nmsi_rfkill_set_state(rfk_bluetooth, !bluetooth_s);\r\nif (rfk_threeg)\r\nmsi_rfkill_set_state(rfk_threeg, !threeg_s);\r\n}\r\nstatic void msi_send_touchpad_key(struct work_struct *ignored)\r\n{\r\nu8 rdata;\r\nint result;\r\nresult = ec_read(MSI_STANDARD_EC_FUNCTIONS_ADDRESS, &rdata);\r\nif (result < 0)\r\nreturn;\r\nsparse_keymap_report_event(msi_laptop_input_dev,\r\n(rdata & MSI_STANDARD_EC_TOUCHPAD_MASK) ?\r\nKEY_TOUCHPAD_ON : KEY_TOUCHPAD_OFF, 1, true);\r\n}\r\nstatic bool msi_laptop_i8042_filter(unsigned char data, unsigned char str,\r\nstruct serio *port)\r\n{\r\nstatic bool extended;\r\nif (str & 0x20)\r\nreturn false;\r\nif (unlikely(data == 0xe0)) {\r\nextended = true;\r\nreturn false;\r\n} else if (unlikely(extended)) {\r\nextended = false;\r\nswitch (data) {\r\ncase 0xE4:\r\nif (quirks->ec_delay) {\r\nschedule_delayed_work(&msi_touchpad_dwork,\r\nround_jiffies_relative(0.5 * HZ));\r\n} else\r\nschedule_work(&msi_touchpad_work);\r\nbreak;\r\ncase 0x54:\r\ncase 0x62:\r\ncase 0x76:\r\nif (quirks->ec_delay) {\r\nschedule_delayed_work(&msi_rfkill_dwork,\r\nround_jiffies_relative(0.5 * HZ));\r\n} else\r\nschedule_work(&msi_rfkill_work);\r\nbreak;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void msi_init_rfkill(struct work_struct *ignored)\r\n{\r\nif (rfk_wlan) {\r\nrfkill_set_sw_state(rfk_wlan, !wlan_s);\r\nrfkill_wlan_set(NULL, !wlan_s);\r\n}\r\nif (rfk_bluetooth) {\r\nrfkill_set_sw_state(rfk_bluetooth, !bluetooth_s);\r\nrfkill_bluetooth_set(NULL, !bluetooth_s);\r\n}\r\nif (rfk_threeg) {\r\nrfkill_set_sw_state(rfk_threeg, !threeg_s);\r\nrfkill_threeg_set(NULL, !threeg_s);\r\n}\r\n}\r\nstatic int rfkill_init(struct platform_device *sdev)\r\n{\r\nint retval;\r\nget_wireless_state_ec_standard();\r\nrfk_bluetooth = rfkill_alloc("msi-bluetooth", &sdev->dev,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&rfkill_bluetooth_ops, NULL);\r\nif (!rfk_bluetooth) {\r\nretval = -ENOMEM;\r\ngoto err_bluetooth;\r\n}\r\nretval = rfkill_register(rfk_bluetooth);\r\nif (retval)\r\ngoto err_bluetooth;\r\nrfk_wlan = rfkill_alloc("msi-wlan", &sdev->dev, RFKILL_TYPE_WLAN,\r\n&rfkill_wlan_ops, NULL);\r\nif (!rfk_wlan) {\r\nretval = -ENOMEM;\r\ngoto err_wlan;\r\n}\r\nretval = rfkill_register(rfk_wlan);\r\nif (retval)\r\ngoto err_wlan;\r\nif (threeg_exists) {\r\nrfk_threeg = rfkill_alloc("msi-threeg", &sdev->dev,\r\nRFKILL_TYPE_WWAN, &rfkill_threeg_ops, NULL);\r\nif (!rfk_threeg) {\r\nretval = -ENOMEM;\r\ngoto err_threeg;\r\n}\r\nretval = rfkill_register(rfk_threeg);\r\nif (retval)\r\ngoto err_threeg;\r\n}\r\nif (quirks->ec_delay) {\r\nschedule_delayed_work(&msi_rfkill_init,\r\nround_jiffies_relative(1 * HZ));\r\n} else\r\nschedule_work(&msi_rfkill_work);\r\nreturn 0;\r\nerr_threeg:\r\nrfkill_destroy(rfk_threeg);\r\nif (rfk_wlan)\r\nrfkill_unregister(rfk_wlan);\r\nerr_wlan:\r\nrfkill_destroy(rfk_wlan);\r\nif (rfk_bluetooth)\r\nrfkill_unregister(rfk_bluetooth);\r\nerr_bluetooth:\r\nrfkill_destroy(rfk_bluetooth);\r\nreturn retval;\r\n}\r\nstatic int msi_laptop_resume(struct device *device)\r\n{\r\nu8 data;\r\nint result;\r\nif (!quirks->load_scm_model)\r\nreturn 0;\r\nresult = ec_read(MSI_STANDARD_EC_SCM_LOAD_ADDRESS, &data);\r\nif (result < 0)\r\nreturn result;\r\nresult = ec_write(MSI_STANDARD_EC_SCM_LOAD_ADDRESS,\r\ndata | MSI_STANDARD_EC_SCM_LOAD_MASK);\r\nif (result < 0)\r\nreturn result;\r\nreturn 0;\r\n}\r\nstatic int __init msi_laptop_input_setup(void)\r\n{\r\nint err;\r\nmsi_laptop_input_dev = input_allocate_device();\r\nif (!msi_laptop_input_dev)\r\nreturn -ENOMEM;\r\nmsi_laptop_input_dev->name = "MSI Laptop hotkeys";\r\nmsi_laptop_input_dev->phys = "msi-laptop/input0";\r\nmsi_laptop_input_dev->id.bustype = BUS_HOST;\r\nerr = sparse_keymap_setup(msi_laptop_input_dev,\r\nmsi_laptop_keymap, NULL);\r\nif (err)\r\ngoto err_free_dev;\r\nerr = input_register_device(msi_laptop_input_dev);\r\nif (err)\r\ngoto err_free_keymap;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(msi_laptop_input_dev);\r\nerr_free_dev:\r\ninput_free_device(msi_laptop_input_dev);\r\nreturn err;\r\n}\r\nstatic void msi_laptop_input_destroy(void)\r\n{\r\nsparse_keymap_free(msi_laptop_input_dev);\r\ninput_unregister_device(msi_laptop_input_dev);\r\n}\r\nstatic int __init load_scm_model_init(struct platform_device *sdev)\r\n{\r\nu8 data;\r\nint result;\r\nif (!quirks->ec_read_only) {\r\ndev_attr_bluetooth.store = store_bluetooth;\r\ndev_attr_wlan.store = store_wlan;\r\ndev_attr_threeg.store = store_threeg;\r\ndev_attr_bluetooth.attr.mode |= S_IWUSR;\r\ndev_attr_wlan.attr.mode |= S_IWUSR;\r\ndev_attr_threeg.attr.mode |= S_IWUSR;\r\n}\r\nresult = ec_read(MSI_STANDARD_EC_SCM_LOAD_ADDRESS, &data);\r\nif (result < 0)\r\nreturn result;\r\nresult = ec_write(MSI_STANDARD_EC_SCM_LOAD_ADDRESS,\r\ndata | MSI_STANDARD_EC_SCM_LOAD_MASK);\r\nif (result < 0)\r\nreturn result;\r\nresult = rfkill_init(sdev);\r\nif (result < 0)\r\ngoto fail_rfkill;\r\nresult = msi_laptop_input_setup();\r\nif (result)\r\ngoto fail_input;\r\nresult = i8042_install_filter(msi_laptop_i8042_filter);\r\nif (result) {\r\npr_err("Unable to install key filter\n");\r\ngoto fail_filter;\r\n}\r\nreturn 0;\r\nfail_filter:\r\nmsi_laptop_input_destroy();\r\nfail_input:\r\nrfkill_cleanup();\r\nfail_rfkill:\r\nreturn result;\r\n}\r\nstatic int __init msi_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\ndmi_check_system(msi_dmi_table);\r\nif (!quirks)\r\nquirks = &quirk_load_scm_model;\r\nif (force)\r\nquirks = &quirk_old_ec_model;\r\nif (!quirks->old_ec_model)\r\nget_threeg_exists();\r\nif (auto_brightness < 0 || auto_brightness > 2)\r\nreturn -EINVAL;\r\nif (!quirks->old_ec_model || acpi_video_backlight_support()) {\r\npr_info("Brightness ignored, must be controlled by ACPI video driver\n");\r\n} else {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = MSI_LCD_LEVEL_MAX - 1;\r\nmsibl_device = backlight_device_register("msi-laptop-bl", NULL,\r\nNULL, &msibl_ops,\r\n&props);\r\nif (IS_ERR(msibl_device))\r\nreturn PTR_ERR(msibl_device);\r\n}\r\nret = platform_driver_register(&msipf_driver);\r\nif (ret)\r\ngoto fail_backlight;\r\nmsipf_device = platform_device_alloc("msi-laptop-pf", -1);\r\nif (!msipf_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_driver;\r\n}\r\nret = platform_device_add(msipf_device);\r\nif (ret)\r\ngoto fail_device_add;\r\nif (quirks->load_scm_model && (load_scm_model_init(msipf_device) < 0)) {\r\nret = -EINVAL;\r\ngoto fail_scm_model_init;\r\n}\r\nret = sysfs_create_group(&msipf_device->dev.kobj,\r\n&msipf_attribute_group);\r\nif (ret)\r\ngoto fail_create_group;\r\nif (!quirks->old_ec_model) {\r\nif (threeg_exists)\r\nret = device_create_file(&msipf_device->dev,\r\n&dev_attr_threeg);\r\nif (ret)\r\ngoto fail_create_attr;\r\n} else {\r\nret = sysfs_create_group(&msipf_device->dev.kobj,\r\n&msipf_old_attribute_group);\r\nif (ret)\r\ngoto fail_create_attr;\r\nif (auto_brightness != 2)\r\nset_auto_brightness(auto_brightness);\r\n}\r\npr_info("driver " MSI_DRIVER_VERSION " successfully loaded\n");\r\nreturn 0;\r\nfail_create_attr:\r\nsysfs_remove_group(&msipf_device->dev.kobj, &msipf_attribute_group);\r\nfail_create_group:\r\nif (quirks->load_scm_model) {\r\ni8042_remove_filter(msi_laptop_i8042_filter);\r\ncancel_delayed_work_sync(&msi_rfkill_dwork);\r\ncancel_work_sync(&msi_rfkill_work);\r\nrfkill_cleanup();\r\n}\r\nfail_scm_model_init:\r\nplatform_device_del(msipf_device);\r\nfail_device_add:\r\nplatform_device_put(msipf_device);\r\nfail_platform_driver:\r\nplatform_driver_unregister(&msipf_driver);\r\nfail_backlight:\r\nbacklight_device_unregister(msibl_device);\r\nreturn ret;\r\n}\r\nstatic void __exit msi_cleanup(void)\r\n{\r\nif (quirks->load_scm_model) {\r\ni8042_remove_filter(msi_laptop_i8042_filter);\r\nmsi_laptop_input_destroy();\r\ncancel_delayed_work_sync(&msi_rfkill_dwork);\r\ncancel_work_sync(&msi_rfkill_work);\r\nrfkill_cleanup();\r\n}\r\nsysfs_remove_group(&msipf_device->dev.kobj, &msipf_attribute_group);\r\nif (!quirks->old_ec_model && threeg_exists)\r\ndevice_remove_file(&msipf_device->dev, &dev_attr_threeg);\r\nplatform_device_unregister(msipf_device);\r\nplatform_driver_unregister(&msipf_driver);\r\nbacklight_device_unregister(msibl_device);\r\nif (quirks->old_ec_model) {\r\nif (auto_brightness != 2)\r\nset_auto_brightness(1);\r\n}\r\npr_info("driver unloaded\n");\r\n}
