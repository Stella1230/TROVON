static int __init dma_fn(char *str)\r\n{\r\ng_cs89x0_dma = simple_strtol(str, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic int __init media_fn(char *str)\r\n{\r\nif (!strcmp(str, "rj45"))\r\ng_cs89x0_media__force = FORCE_RJ45;\r\nelse if (!strcmp(str, "aui"))\r\ng_cs89x0_media__force = FORCE_AUI;\r\nelse if (!strcmp(str, "bnc"))\r\ng_cs89x0_media__force = FORCE_BNC;\r\nreturn 1;\r\n}\r\nstatic void readwords(struct net_local *lp, int portno, void *buf, int length)\r\n{\r\nu8 *buf8 = (u8 *)buf;\r\ndo {\r\nu16 tmp16;\r\ntmp16 = ioread16(lp->virt_addr + portno);\r\n*buf8++ = (u8)tmp16;\r\n*buf8++ = (u8)(tmp16 >> 8);\r\n} while (--length);\r\n}\r\nstatic void writewords(struct net_local *lp, int portno, void *buf, int length)\r\n{\r\nu8 *buf8 = (u8 *)buf;\r\ndo {\r\nu16 tmp16;\r\ntmp16 = *buf8++;\r\ntmp16 |= (*buf8++) << 8;\r\niowrite16(tmp16, lp->virt_addr + portno);\r\n} while (--length);\r\n}\r\nstatic u16\r\nreadreg(struct net_device *dev, u16 regno)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\niowrite16(regno, lp->virt_addr + ADD_PORT);\r\nreturn ioread16(lp->virt_addr + DATA_PORT);\r\n}\r\nstatic void\r\nwritereg(struct net_device *dev, u16 regno, u16 value)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\niowrite16(regno, lp->virt_addr + ADD_PORT);\r\niowrite16(value, lp->virt_addr + DATA_PORT);\r\n}\r\nstatic int __init\r\nwait_eeprom_ready(struct net_device *dev)\r\n{\r\nint timeout = jiffies;\r\nwhile (readreg(dev, PP_SelfST) & SI_BUSY)\r\nif (jiffies - timeout >= 40)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nget_eeprom_data(struct net_device *dev, int off, int len, int *buffer)\r\n{\r\nint i;\r\ncs89_dbg(3, info, "EEPROM data from %x for %x:", off, len);\r\nfor (i = 0; i < len; i++) {\r\nif (wait_eeprom_ready(dev) < 0)\r\nreturn -1;\r\nwritereg(dev, PP_EECMD, (off + i) | EEPROM_READ_CMD);\r\nif (wait_eeprom_ready(dev) < 0)\r\nreturn -1;\r\nbuffer[i] = readreg(dev, PP_EEData);\r\ncs89_dbg(3, cont, " %04x", buffer[i]);\r\n}\r\ncs89_dbg(3, cont, "\n");\r\nreturn 0;\r\n}\r\nstatic int __init\r\nget_eeprom_cksum(int off, int len, int *buffer)\r\n{\r\nint i, cksum;\r\ncksum = 0;\r\nfor (i = 0; i < len; i++)\r\ncksum += buffer[i];\r\ncksum &= 0xffff;\r\nif (cksum == 0)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nstatic void\r\nwrite_irq(struct net_device *dev, int chip_type, int irq)\r\n{\r\nint i;\r\nif (chip_type == CS8900) {\r\n#ifndef CONFIG_CS89x0_PLATFORM\r\nfor (i = 0; i != ARRAY_SIZE(cs8900_irq_map); i++)\r\nif (cs8900_irq_map[i] == irq)\r\nbreak;\r\nif (i == ARRAY_SIZE(cs8900_irq_map))\r\ni = 3;\r\n#else\r\ni = 0;\r\n#endif\r\nwritereg(dev, PP_CS8900_ISAINT, i);\r\n} else {\r\nwritereg(dev, PP_CS8920_ISAINT, irq);\r\n}\r\n}\r\nstatic void\r\ncount_rx_errors(int status, struct net_device *dev)\r\n{\r\ndev->stats.rx_errors++;\r\nif (status & RX_RUNT)\r\ndev->stats.rx_length_errors++;\r\nif (status & RX_EXTRA_DATA)\r\ndev->stats.rx_length_errors++;\r\nif ((status & RX_CRC_ERROR) && !(status & (RX_EXTRA_DATA | RX_RUNT)))\r\ndev->stats.rx_crc_errors++;\r\nif (status & RX_DRIBBLE)\r\ndev->stats.rx_frame_errors++;\r\n}\r\nstatic void\r\nget_dma_channel(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->dma) {\r\ndev->dma = lp->dma;\r\nlp->isa_config |= ISA_RxDMA;\r\n} else {\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0)\r\nreturn;\r\ndev->dma = lp->isa_config & DMA_NO_MASK;\r\nif (lp->chip_type == CS8900)\r\ndev->dma += 5;\r\nif (dev->dma < 5 || dev->dma > 7) {\r\nlp->isa_config &= ~ANY_ISA_DMA;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\nwrite_dma(struct net_device *dev, int chip_type, int dma)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0)\r\nreturn;\r\nif (chip_type == CS8900)\r\nwritereg(dev, PP_CS8900_ISADMA, dma - 5);\r\nelse\r\nwritereg(dev, PP_CS8920_ISADMA, dma);\r\n}\r\nstatic void\r\nset_dma_cfg(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma) {\r\nif ((lp->isa_config & ANY_ISA_DMA) == 0) {\r\ncs89_dbg(3, err, "set_dma_cfg(): no DMA\n");\r\nreturn;\r\n}\r\nif (lp->isa_config & ISA_RxDMA) {\r\nlp->curr_rx_cfg |= RX_DMA_ONLY;\r\ncs89_dbg(3, info, "set_dma_cfg(): RX_DMA_ONLY\n");\r\n} else {\r\nlp->curr_rx_cfg |= AUTO_RX_DMA;\r\ncs89_dbg(3, info, "set_dma_cfg(): AUTO_RX_DMA\n");\r\n}\r\n}\r\n}\r\nstatic int\r\ndma_bufcfg(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma)\r\nreturn (lp->isa_config & ANY_ISA_DMA) ? RX_DMA_ENBL : 0;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\ndma_busctl(struct net_device *dev)\r\n{\r\nint retval = 0;\r\nstruct net_local *lp = netdev_priv(dev);\r\nif (lp->use_dma) {\r\nif (lp->isa_config & ANY_ISA_DMA)\r\nretval |= RESET_RX_DMA;\r\nif (lp->isa_config & DMA_BURST)\r\nretval |= DMA_BURST_MODE;\r\nif (lp->dmasize == 64)\r\nretval |= RX_DMA_SIZE_64K;\r\nretval |= MEMORY_ON;\r\n}\r\nreturn retval;\r\n}\r\nstatic void\r\ndma_rx(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint status, length;\r\nunsigned char *bp = lp->rx_dma_ptr;\r\nstatus = bp[0] + (bp[1] << 8);\r\nlength = bp[2] + (bp[3] << 8);\r\nbp += 4;\r\ncs89_dbg(5, debug, "%s: receiving DMA packet at %lx, status %x, length %x\n",\r\ndev->name, (unsigned long)bp, status, length);\r\nif ((status & RX_OK) == 0) {\r\ncount_rx_errors(status, dev);\r\ngoto skip_this_frame;\r\n}\r\nskb = netdev_alloc_skb(dev, length + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nskip_this_frame:\r\nbp += (length + 3) & ~3;\r\nif (bp >= lp->end_dma_buff)\r\nbp -= lp->dmasize * 1024;\r\nlp->rx_dma_ptr = bp;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nif (bp + length > lp->end_dma_buff) {\r\nint semi_cnt = lp->end_dma_buff - bp;\r\nmemcpy(skb_put(skb, semi_cnt), bp, semi_cnt);\r\nmemcpy(skb_put(skb, length - semi_cnt), lp->dma_buff,\r\nlength - semi_cnt);\r\n} else {\r\nmemcpy(skb_put(skb, length), bp, length);\r\n}\r\nbp += (length + 3) & ~3;\r\nif (bp >= lp->end_dma_buff)\r\nbp -= lp->dmasize*1024;\r\nlp->rx_dma_ptr = bp;\r\ncs89_dbg(3, info, "%s: received %d byte DMA packet of type %x\n",\r\ndev->name, length,\r\n((skb->data[ETH_ALEN + ETH_ALEN] << 8) |\r\nskb->data[ETH_ALEN + ETH_ALEN + 1]));\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\nstatic void release_dma_buff(struct net_local *lp)\r\n{\r\nif (lp->dma_buff) {\r\nfree_pages((unsigned long)(lp->dma_buff),\r\nget_order(lp->dmasize * 1024));\r\nlp->dma_buff = NULL;\r\n}\r\n}\r\nstatic void\r\ncontrol_dc_dc(struct net_device *dev, int on_not_off)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned int selfcontrol;\r\nint timenow = jiffies;\r\nselfcontrol = HCB1_ENBL;\r\nif (((lp->adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)\r\nselfcontrol |= HCB1;\r\nelse\r\nselfcontrol &= ~HCB1;\r\nwritereg(dev, PP_SelfCTL, selfcontrol);\r\nwhile (jiffies - timenow < HZ)\r\n;\r\n}\r\nstatic int\r\nsend_test_pkt(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nchar test_packet[] = {\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 46,\r\n0, 0,\r\n0xf3, 0\r\n};\r\nlong timenow = jiffies;\r\nwritereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_TX_ON);\r\nmemcpy(test_packet, dev->dev_addr, ETH_ALEN);\r\nmemcpy(test_packet + ETH_ALEN, dev->dev_addr, ETH_ALEN);\r\niowrite16(TX_AFTER_ALL, lp->virt_addr + TX_CMD_PORT);\r\niowrite16(ETH_ZLEN, lp->virt_addr + TX_LEN_PORT);\r\nwhile (jiffies - timenow < 5)\r\nif (readreg(dev, PP_BusST) & READY_FOR_TX_NOW)\r\nbreak;\r\nif (jiffies - timenow >= 5)\r\nreturn 0;\r\nwritewords(lp, TX_FRAME_PORT, test_packet, (ETH_ZLEN + 1) >> 1);\r\ncs89_dbg(1, debug, "Sending test packet ");\r\nfor (timenow = jiffies; jiffies - timenow < 3;)\r\n;\r\nif ((readreg(dev, PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {\r\ncs89_dbg(1, cont, "succeeded\n");\r\nreturn 1;\r\n}\r\ncs89_dbg(1, cont, "failed\n");\r\nreturn 0;\r\n}\r\nstatic int\r\ndetect_tp(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint timenow = jiffies;\r\nint fdx;\r\ncs89_dbg(1, debug, "%s: Attempting TP\n", dev->name);\r\nwritereg(dev, PP_LineCTL, lp->linectl & ~AUI_ONLY);\r\ncontrol_dc_dc(dev, 0);\r\nfor (timenow = jiffies; jiffies - timenow < 15;)\r\n;\r\nif ((readreg(dev, PP_LineST) & LINK_OK) == 0)\r\nreturn DETECTED_NONE;\r\nif (lp->chip_type == CS8900) {\r\nswitch (lp->force & 0xf0) {\r\n#if 0\r\ncase FORCE_AUTO:\r\npr_info("%s: cs8900 doesn't autonegotiate\n",\r\ndev->name);\r\nreturn DETECTED_NONE;\r\n#endif\r\ncase FORCE_AUTO:\r\nlp->force &= ~FORCE_AUTO;\r\nlp->force |= FORCE_HALF;\r\nbreak;\r\ncase FORCE_HALF:\r\nbreak;\r\ncase FORCE_FULL:\r\nwritereg(dev, PP_TestCTL,\r\nreadreg(dev, PP_TestCTL) | FDX_8900);\r\nbreak;\r\n}\r\nfdx = readreg(dev, PP_TestCTL) & FDX_8900;\r\n} else {\r\nswitch (lp->force & 0xf0) {\r\ncase FORCE_AUTO:\r\nlp->auto_neg_cnf = AUTO_NEG_ENABLE;\r\nbreak;\r\ncase FORCE_HALF:\r\nlp->auto_neg_cnf = 0;\r\nbreak;\r\ncase FORCE_FULL:\r\nlp->auto_neg_cnf = RE_NEG_NOW | ALLOW_FDX;\r\nbreak;\r\n}\r\nwritereg(dev, PP_AutoNegCTL, lp->auto_neg_cnf & AUTO_NEG_MASK);\r\nif ((lp->auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {\r\npr_info("%s: negotiating duplex...\n", dev->name);\r\nwhile (readreg(dev, PP_AutoNegST) & AUTO_NEG_BUSY) {\r\nif (jiffies - timenow > 4000) {\r\npr_err("**** Full / half duplex auto-negotiation timed out ****\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nfdx = readreg(dev, PP_AutoNegST) & FDX_ACTIVE;\r\n}\r\nif (fdx)\r\nreturn DETECTED_RJ45F;\r\nelse\r\nreturn DETECTED_RJ45H;\r\n}\r\nstatic int\r\ndetect_bnc(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\ncs89_dbg(1, debug, "%s: Attempting BNC\n", dev->name);\r\ncontrol_dc_dc(dev, 1);\r\nwritereg(dev, PP_LineCTL, (lp->linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);\r\nif (send_test_pkt(dev))\r\nreturn DETECTED_BNC;\r\nelse\r\nreturn DETECTED_NONE;\r\n}\r\nstatic int\r\ndetect_aui(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\ncs89_dbg(1, debug, "%s: Attempting AUI\n", dev->name);\r\ncontrol_dc_dc(dev, 0);\r\nwritereg(dev, PP_LineCTL, (lp->linectl & ~AUTO_AUI_10BASET) | AUI_ONLY);\r\nif (send_test_pkt(dev))\r\nreturn DETECTED_AUI;\r\nelse\r\nreturn DETECTED_NONE;\r\n}\r\nstatic void\r\nnet_rx(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint status, length;\r\nstatus = ioread16(lp->virt_addr + RX_FRAME_PORT);\r\nlength = ioread16(lp->virt_addr + RX_FRAME_PORT);\r\nif ((status & RX_OK) == 0) {\r\ncount_rx_errors(status, dev);\r\nreturn;\r\n}\r\nskb = netdev_alloc_skb(dev, length + 2);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nreadwords(lp, RX_FRAME_PORT, skb_put(skb, length), length >> 1);\r\nif (length & 1)\r\nskb->data[length-1] = ioread16(lp->virt_addr + RX_FRAME_PORT);\r\ncs89_dbg(3, debug, "%s: received %d byte packet of type %x\n",\r\ndev->name, length,\r\n(skb->data[ETH_ALEN + ETH_ALEN] << 8) |\r\nskb->data[ETH_ALEN + ETH_ALEN + 1]);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += length;\r\n}\r\nstatic irqreturn_t net_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_local *lp;\r\nint status;\r\nint handled = 0;\r\nlp = netdev_priv(dev);\r\nwhile ((status = ioread16(lp->virt_addr + ISQ_PORT))) {\r\ncs89_dbg(4, debug, "%s: event=%04x\n", dev->name, status);\r\nhandled = 1;\r\nswitch (status & ISQ_EVENT_MASK) {\r\ncase ISQ_RECEIVER_EVENT:\r\nnet_rx(dev);\r\nbreak;\r\ncase ISQ_TRANSMITTER_EVENT:\r\ndev->stats.tx_packets++;\r\nnetif_wake_queue(dev);\r\nif ((status & (TX_OK |\r\nTX_LOST_CRS |\r\nTX_SQE_ERROR |\r\nTX_LATE_COL |\r\nTX_16_COL)) != TX_OK) {\r\nif ((status & TX_OK) == 0)\r\ndev->stats.tx_errors++;\r\nif (status & TX_LOST_CRS)\r\ndev->stats.tx_carrier_errors++;\r\nif (status & TX_SQE_ERROR)\r\ndev->stats.tx_heartbeat_errors++;\r\nif (status & TX_LATE_COL)\r\ndev->stats.tx_window_errors++;\r\nif (status & TX_16_COL)\r\ndev->stats.tx_aborted_errors++;\r\n}\r\nbreak;\r\ncase ISQ_BUFFER_EVENT:\r\nif (status & READY_FOR_TX) {\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & TX_UNDERRUN) {\r\ncs89_dbg(0, err, "%s: transmit underrun\n",\r\ndev->name);\r\nlp->send_underrun++;\r\nif (lp->send_underrun == 3)\r\nlp->send_cmd = TX_AFTER_381;\r\nelse if (lp->send_underrun == 6)\r\nlp->send_cmd = TX_AFTER_ALL;\r\nnetif_wake_queue(dev);\r\n}\r\n#if ALLOW_DMA\r\nif (lp->use_dma && (status & RX_DMA)) {\r\nint count = readreg(dev, PP_DmaFrameCnt);\r\nwhile (count) {\r\ncs89_dbg(5, debug,\r\n"%s: receiving %d DMA frames\n",\r\ndev->name, count);\r\nif (count > 1)\r\ncs89_dbg(2, debug,\r\n"%s: receiving %d DMA frames\n",\r\ndev->name, count);\r\ndma_rx(dev);\r\nif (--count == 0)\r\ncount = readreg(dev, PP_DmaFrameCnt);\r\nif (count > 0)\r\ncs89_dbg(2, debug,\r\n"%s: continuing with %d DMA frames\n",\r\ndev->name, count);\r\n}\r\n}\r\n#endif\r\nbreak;\r\ncase ISQ_RX_MISS_EVENT:\r\ndev->stats.rx_missed_errors += (status >> 6);\r\nbreak;\r\ncase ISQ_TX_COL_EVENT:\r\ndev->stats.collisions += (status >> 6);\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int\r\nnet_open(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint result = 0;\r\nint i;\r\nint ret;\r\nif (dev->irq < 2) {\r\n#if 0\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL) | ENABLE_IRQ);\r\n#endif\r\nwritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\r\nfor (i = 2; i < CS8920_NO_INTS; i++) {\r\nif ((1 << i) & lp->irq_map) {\r\nif (request_irq(i, net_interrupt, 0, dev->name,\r\ndev) == 0) {\r\ndev->irq = i;\r\nwrite_irq(dev, lp->chip_type, i);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i >= CS8920_NO_INTS) {\r\nwritereg(dev, PP_BusCTL, 0);\r\npr_err("can't get an interrupt\n");\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\n} else {\r\n#if !defined(CONFIG_CS89x0_PLATFORM)\r\nif (((1 << dev->irq) & lp->irq_map) == 0) {\r\npr_err("%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",\r\ndev->name, dev->irq, lp->irq_map);\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\n#endif\r\nwritereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ);\r\n#if 0\r\nwritereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);\r\n#endif\r\nwrite_irq(dev, lp->chip_type, dev->irq);\r\nret = request_irq(dev->irq, net_interrupt, 0, dev->name, dev);\r\nif (ret) {\r\npr_err("request_irq(%d) failed\n", dev->irq);\r\ngoto bad_out;\r\n}\r\n}\r\n#if ALLOW_DMA\r\nif (lp->use_dma && (lp->isa_config & ANY_ISA_DMA)) {\r\nunsigned long flags;\r\nlp->dma_buff = (unsigned char *)__get_dma_pages(GFP_KERNEL,\r\nget_order(lp->dmasize * 1024));\r\nif (!lp->dma_buff) {\r\npr_err("%s: cannot get %dK memory for DMA\n",\r\ndev->name, lp->dmasize);\r\ngoto release_irq;\r\n}\r\ncs89_dbg(1, debug, "%s: dma %lx %lx\n",\r\ndev->name,\r\n(unsigned long)lp->dma_buff,\r\n(unsigned long)isa_virt_to_bus(lp->dma_buff));\r\nif ((unsigned long)lp->dma_buff >= MAX_DMA_ADDRESS ||\r\n!dma_page_eq(lp->dma_buff,\r\nlp->dma_buff + lp->dmasize * 1024 - 1)) {\r\npr_err("%s: not usable as DMA buffer\n", dev->name);\r\ngoto release_irq;\r\n}\r\nmemset(lp->dma_buff, 0, lp->dmasize * 1024);\r\nif (request_dma(dev->dma, dev->name)) {\r\npr_err("%s: cannot get dma channel %d\n",\r\ndev->name, dev->dma);\r\ngoto release_irq;\r\n}\r\nwrite_dma(dev, lp->chip_type, dev->dma);\r\nlp->rx_dma_ptr = lp->dma_buff;\r\nlp->end_dma_buff = lp->dma_buff + lp->dmasize * 1024;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndisable_dma(dev->dma);\r\nclear_dma_ff(dev->dma);\r\nset_dma_mode(dev->dma, DMA_RX_MODE);\r\nset_dma_addr(dev->dma, isa_virt_to_bus(lp->dma_buff));\r\nset_dma_count(dev->dma, lp->dmasize * 1024);\r\nenable_dma(dev->dma);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\n#endif\r\nfor (i = 0; i < ETH_ALEN / 2; i++)\r\nwritereg(dev, PP_IA + i * 2,\r\n(dev->dev_addr[i * 2] |\r\n(dev->dev_addr[i * 2 + 1] << 8)));\r\nwritereg(dev, PP_BusCTL, MEMORY_ON);\r\nif ((lp->adapter_cnf & A_CNF_EXTND_10B_2) &&\r\n(lp->adapter_cnf & A_CNF_LOW_RX_SQUELCH))\r\nlp->linectl = LOW_RX_SQUELCH;\r\nelse\r\nlp->linectl = 0;\r\nswitch (lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\r\ncase A_CNF_MEDIA_10B_T:\r\nresult = lp->adapter_cnf & A_CNF_10B_T;\r\nbreak;\r\ncase A_CNF_MEDIA_AUI:\r\nresult = lp->adapter_cnf & A_CNF_AUI;\r\nbreak;\r\ncase A_CNF_MEDIA_10B_2:\r\nresult = lp->adapter_cnf & A_CNF_10B_2;\r\nbreak;\r\ndefault:\r\nresult = lp->adapter_cnf & (A_CNF_10B_T |\r\nA_CNF_AUI |\r\nA_CNF_10B_2);\r\n}\r\nif (!result) {\r\npr_err("%s: EEPROM is configured for unavailable media\n",\r\ndev->name);\r\nrelease_dma:\r\n#if ALLOW_DMA\r\nfree_dma(dev->dma);\r\nrelease_irq:\r\nrelease_dma_buff(lp);\r\n#endif\r\nwritereg(dev, PP_LineCTL,\r\nreadreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));\r\nfree_irq(dev->irq, dev);\r\nret = -EAGAIN;\r\ngoto bad_out;\r\n}\r\nswitch (lp->adapter_cnf & A_CNF_MEDIA_TYPE) {\r\ncase A_CNF_MEDIA_10B_T:\r\nresult = detect_tp(dev);\r\nif (result == DETECTED_NONE) {\r\npr_warn("%s: 10Base-T (RJ-45) has no cable\n",\r\ndev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_RJ45H;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_AUI:\r\nresult = detect_aui(dev);\r\nif (result == DETECTED_NONE) {\r\npr_warn("%s: 10Base-5 (AUI) has no cable\n", dev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_AUI;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_10B_2:\r\nresult = detect_bnc(dev);\r\nif (result == DETECTED_NONE) {\r\npr_warn("%s: 10Base-2 (BNC) has no cable\n", dev->name);\r\nif (lp->auto_neg_cnf & IMM_BIT)\r\nresult = DETECTED_BNC;\r\n}\r\nbreak;\r\ncase A_CNF_MEDIA_AUTO:\r\nwritereg(dev, PP_LineCTL, lp->linectl | AUTO_AUI_10BASET);\r\nif (lp->adapter_cnf & A_CNF_10B_T) {\r\nresult = detect_tp(dev);\r\nif (result != DETECTED_NONE)\r\nbreak;\r\n}\r\nif (lp->adapter_cnf & A_CNF_AUI) {\r\nresult = detect_aui(dev);\r\nif (result != DETECTED_NONE)\r\nbreak;\r\n}\r\nif (lp->adapter_cnf & A_CNF_10B_2) {\r\nresult = detect_bnc(dev);\r\nif (result != DETECTED_NONE)\r\nbreak;\r\n}\r\npr_err("%s: no media detected\n", dev->name);\r\ngoto release_dma;\r\n}\r\nswitch (result) {\r\ncase DETECTED_NONE:\r\npr_err("%s: no network cable attached to configured media\n",\r\ndev->name);\r\ngoto release_dma;\r\ncase DETECTED_RJ45H:\r\npr_info("%s: using half-duplex 10Base-T (RJ-45)\n", dev->name);\r\nbreak;\r\ncase DETECTED_RJ45F:\r\npr_info("%s: using full-duplex 10Base-T (RJ-45)\n", dev->name);\r\nbreak;\r\ncase DETECTED_AUI:\r\npr_info("%s: using 10Base-5 (AUI)\n", dev->name);\r\nbreak;\r\ncase DETECTED_BNC:\r\npr_info("%s: using 10Base-2 (BNC)\n", dev->name);\r\nbreak;\r\n}\r\nwritereg(dev, PP_LineCTL,\r\nreadreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT);\r\nlp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;\r\nif (lp->isa_config & STREAM_TRANSFER)\r\nlp->curr_rx_cfg |= RX_STREAM_ENBL;\r\n#if ALLOW_DMA\r\nset_dma_cfg(dev);\r\n#endif\r\nwritereg(dev, PP_RxCFG, lp->curr_rx_cfg);\r\nwritereg(dev, PP_TxCFG, (TX_LOST_CRS_ENBL |\r\nTX_SQE_ERROR_ENBL |\r\nTX_OK_ENBL |\r\nTX_LATE_COL_ENBL |\r\nTX_JBR_ENBL |\r\nTX_ANY_COL_ENBL |\r\nTX_16_COL_ENBL));\r\nwritereg(dev, PP_BufCFG, (READY_FOR_TX_ENBL |\r\nRX_MISS_COUNT_OVRFLOW_ENBL |\r\n#if ALLOW_DMA\r\ndma_bufcfg(dev) |\r\n#endif\r\nTX_COL_COUNT_OVRFLOW_ENBL |\r\nTX_UNDERRUN_ENBL));\r\nwritereg(dev, PP_BusCTL, (ENABLE_IRQ\r\n| (dev->mem_start ? MEMORY_ON : 0)\r\n#if ALLOW_DMA\r\n| dma_busctl(dev)\r\n#endif\r\n));\r\nnetif_start_queue(dev);\r\ncs89_dbg(1, debug, "net_open() succeeded\n");\r\nreturn 0;\r\nbad_out:\r\nreturn ret;\r\n}\r\nstatic int\r\nnet_close(struct net_device *dev)\r\n{\r\n#if ALLOW_DMA\r\nstruct net_local *lp = netdev_priv(dev);\r\n#endif\r\nnetif_stop_queue(dev);\r\nwritereg(dev, PP_RxCFG, 0);\r\nwritereg(dev, PP_TxCFG, 0);\r\nwritereg(dev, PP_BufCFG, 0);\r\nwritereg(dev, PP_BusCTL, 0);\r\nfree_irq(dev->irq, dev);\r\n#if ALLOW_DMA\r\nif (lp->use_dma && lp->dma) {\r\nfree_dma(dev->dma);\r\nrelease_dma_buff(lp);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\nnet_get_stats(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ndev->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);\r\ndev->stats.collisions += (readreg(dev, PP_TxCol) >> 6);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void net_timeout(struct net_device *dev)\r\n{\r\ncs89_dbg(0, err, "%s: transmit timed out, %s?\n",\r\ndev->name,\r\ntx_done(dev) ? "IRQ conflict" : "network cable problem");\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t net_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\ncs89_dbg(3, debug, "%s: sent %d byte packet of type %x\n",\r\ndev->name, skb->len,\r\n((skb->data[ETH_ALEN + ETH_ALEN] << 8) |\r\nskb->data[ETH_ALEN + ETH_ALEN + 1]));\r\nspin_lock_irqsave(&lp->lock, flags);\r\nnetif_stop_queue(dev);\r\niowrite16(lp->send_cmd, lp->virt_addr + TX_CMD_PORT);\r\niowrite16(skb->len, lp->virt_addr + TX_LEN_PORT);\r\nif ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ncs89_dbg(0, err, "Tx buffer not free!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nwritewords(lp, TX_FRAME_PORT, skb->data, (skb->len + 1) >> 1);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev->stats.tx_bytes += skb->len;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nu16 cfg;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (dev->flags & IFF_PROMISC)\r\nlp->rx_mode = RX_ALL_ACCEPT;\r\nelse if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))\r\nlp->rx_mode = RX_MULTCAST_ACCEPT;\r\nelse\r\nlp->rx_mode = 0;\r\nwritereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);\r\ncfg = lp->curr_rx_cfg;\r\nif (lp->rx_mode == RX_ALL_ACCEPT)\r\ncfg |= RX_CRC_ERROR_ENBL | RX_RUNT_ENBL | RX_EXTRA_DATA_ENBL;\r\nwritereg(dev, PP_RxCFG, cfg);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int set_mac_address(struct net_device *dev, void *p)\r\n{\r\nint i;\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\ncs89_dbg(0, debug, "%s: Setting MAC address to %pM\n",\r\ndev->name, dev->dev_addr);\r\nfor (i = 0; i < ETH_ALEN / 2; i++)\r\nwritereg(dev, PP_IA + i * 2,\r\n(dev->dev_addr[i * 2] |\r\n(dev->dev_addr[i * 2 + 1] << 8)));\r\nreturn 0;\r\n}\r\nstatic void net_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nnet_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void __init reset_chip(struct net_device *dev)\r\n{\r\n#if !defined(CONFIG_MACH_MX31ADS)\r\nstruct net_local *lp = netdev_priv(dev);\r\nint reset_start_time;\r\nwritereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);\r\nmsleep(30);\r\nif (lp->chip_type != CS8900) {\r\niowrite16(PP_CS8920_ISAINT, lp->virt_addr + ADD_PORT);\r\niowrite8(dev->irq, lp->virt_addr + DATA_PORT);\r\niowrite8(0, lp->virt_addr + DATA_PORT + 1);\r\niowrite16(PP_CS8920_ISAMemB, lp->virt_addr + ADD_PORT);\r\niowrite8((dev->mem_start >> 16) & 0xff,\r\nlp->virt_addr + DATA_PORT);\r\niowrite8((dev->mem_start >> 8) & 0xff,\r\nlp->virt_addr + DATA_PORT + 1);\r\n}\r\nreset_start_time = jiffies;\r\nwhile ((readreg(dev, PP_SelfST) & INIT_DONE) == 0 &&\r\njiffies - reset_start_time < 2)\r\n;\r\n#endif\r\n}\r\nstatic int __init\r\ncs89x0_probe1(struct net_device *dev, void __iomem *ioaddr, int modular)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint i;\r\nint tmp;\r\nunsigned rev_type = 0;\r\nint eeprom_buff[CHKSUM_LEN];\r\nint retval;\r\nif (!modular) {\r\nmemset(lp, 0, sizeof(*lp));\r\nspin_lock_init(&lp->lock);\r\n#ifndef MODULE\r\n#if ALLOW_DMA\r\nif (g_cs89x0_dma) {\r\nlp->use_dma = 1;\r\nlp->dma = g_cs89x0_dma;\r\nlp->dmasize = 16;\r\n}\r\n#endif\r\nlp->force = g_cs89x0_media__force;\r\n#endif\r\n}\r\npr_debug("PP_addr at %p[%x]: 0x%x\n",\r\nioaddr, ADD_PORT, ioread16(ioaddr + ADD_PORT));\r\niowrite16(PP_ChipID, ioaddr + ADD_PORT);\r\ntmp = ioread16(ioaddr + DATA_PORT);\r\nif (tmp != CHIP_EISA_ID_SIG) {\r\npr_debug("%s: incorrect signature at %p[%x]: 0x%x!="\r\nCHIP_EISA_ID_SIG_STR "\n",\r\ndev->name, ioaddr, DATA_PORT, tmp);\r\nretval = -ENODEV;\r\ngoto out1;\r\n}\r\nlp->virt_addr = ioaddr;\r\nrev_type = readreg(dev, PRODUCT_ID_ADD);\r\nlp->chip_type = rev_type & ~REVISON_BITS;\r\nlp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';\r\nlp->send_cmd = TX_AFTER_381;\r\nif (lp->chip_type == CS8900 && lp->chip_revision >= 'F')\r\nlp->send_cmd = TX_NOW;\r\nif (lp->chip_type != CS8900 && lp->chip_revision >= 'C')\r\nlp->send_cmd = TX_NOW;\r\npr_info_once("%s\n", version);\r\npr_info("%s: cs89%c0%s rev %c found at %p ",\r\ndev->name,\r\nlp->chip_type == CS8900 ? '0' : '2',\r\nlp->chip_type == CS8920M ? "M" : "",\r\nlp->chip_revision,\r\nlp->virt_addr);\r\nreset_chip(dev);\r\nif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==\r\n(EEPROM_OK | EEPROM_PRESENT)) {\r\nfor (i = 0; i < ETH_ALEN / 2; i++) {\r\nunsigned int Addr;\r\nAddr = readreg(dev, PP_IA + i * 2);\r\ndev->dev_addr[i * 2] = Addr & 0xFF;\r\ndev->dev_addr[i * 2 + 1] = Addr >> 8;\r\n}\r\nlp->adapter_cnf = 0;\r\ni = readreg(dev, PP_LineCTL);\r\nif ((i & (HCB1 | HCB1_ENBL)) == (HCB1 | HCB1_ENBL))\r\nlp->adapter_cnf |= A_CNF_DC_DC_POLARITY;\r\nif ((i & LOW_RX_SQUELCH) == LOW_RX_SQUELCH)\r\nlp->adapter_cnf |= A_CNF_EXTND_10B_2 | A_CNF_LOW_RX_SQUELCH;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == 0)\r\nlp->adapter_cnf |= A_CNF_10B_T | A_CNF_MEDIA_10B_T;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUI_ONLY)\r\nlp->adapter_cnf |= A_CNF_AUI | A_CNF_MEDIA_AUI;\r\nif ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUTO_AUI_10BASET)\r\nlp->adapter_cnf |= A_CNF_AUI | A_CNF_10B_T |\r\nA_CNF_MEDIA_AUI | A_CNF_MEDIA_10B_T | A_CNF_MEDIA_AUTO;\r\ncs89_dbg(1, info, "%s: PP_LineCTL=0x%x, adapter_cnf=0x%x\n",\r\ndev->name, i, lp->adapter_cnf);\r\nif (lp->chip_type == CS8900)\r\nlp->isa_config = readreg(dev, PP_CS8900_ISAINT) & INT_NO_MASK;\r\npr_cont("[Cirrus EEPROM] ");\r\n}\r\npr_cont("\n");\r\nif ((readreg(dev, PP_SelfST) & EEPROM_PRESENT) == 0)\r\npr_warn("No EEPROM, relying on command line....\n");\r\nelse if (get_eeprom_data(dev, START_EEPROM_DATA, CHKSUM_LEN, eeprom_buff) < 0) {\r\npr_warn("EEPROM read failed, relying on command line\n");\r\n} else if (get_eeprom_cksum(START_EEPROM_DATA, CHKSUM_LEN, eeprom_buff) < 0) {\r\nif ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) !=\r\n(EEPROM_OK | EEPROM_PRESENT))\r\npr_warn("Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line\n");\r\n} else {\r\nif (!lp->auto_neg_cnf)\r\nlp->auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET / 2];\r\nif (!lp->adapter_cnf)\r\nlp->adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET / 2];\r\nlp->isa_config = eeprom_buff[ISA_CNF_OFFSET / 2];\r\ndev->mem_start = eeprom_buff[PACKET_PAGE_OFFSET / 2] << 8;\r\nfor (i = 0; i < ETH_ALEN / 2; i++) {\r\ndev->dev_addr[i * 2] = eeprom_buff[i];\r\ndev->dev_addr[i * 2 + 1] = eeprom_buff[i] >> 8;\r\n}\r\ncs89_dbg(1, debug, "%s: new adapter_cnf: 0x%x\n",\r\ndev->name, lp->adapter_cnf);\r\n}\r\n{\r\nint count = 0;\r\nif (lp->force & FORCE_RJ45) {\r\nlp->adapter_cnf |= A_CNF_10B_T;\r\ncount++;\r\n}\r\nif (lp->force & FORCE_AUI) {\r\nlp->adapter_cnf |= A_CNF_AUI;\r\ncount++;\r\n}\r\nif (lp->force & FORCE_BNC) {\r\nlp->adapter_cnf |= A_CNF_10B_2;\r\ncount++;\r\n}\r\nif (count > 1)\r\nlp->adapter_cnf |= A_CNF_MEDIA_AUTO;\r\nelse if (lp->force & FORCE_RJ45)\r\nlp->adapter_cnf |= A_CNF_MEDIA_10B_T;\r\nelse if (lp->force & FORCE_AUI)\r\nlp->adapter_cnf |= A_CNF_MEDIA_AUI;\r\nelse if (lp->force & FORCE_BNC)\r\nlp->adapter_cnf |= A_CNF_MEDIA_10B_2;\r\n}\r\ncs89_dbg(1, debug, "%s: after force 0x%x, adapter_cnf=0x%x\n",\r\ndev->name, lp->force, lp->adapter_cnf);\r\npr_info("media %s%s%s",\r\n(lp->adapter_cnf & A_CNF_10B_T) ? "RJ-45," : "",\r\n(lp->adapter_cnf & A_CNF_AUI) ? "AUI," : "",\r\n(lp->adapter_cnf & A_CNF_10B_2) ? "BNC," : "");\r\nlp->irq_map = 0xffff;\r\nif (lp->chip_type != CS8900 &&\r\n(i = readreg(dev, PP_CS8920_ISAINT) & 0xff,\r\n(i != 0 && i < CS8920_NO_INTS))) {\r\nif (!dev->irq)\r\ndev->irq = i;\r\n} else {\r\ni = lp->isa_config & INT_NO_MASK;\r\n#ifndef CONFIG_CS89x0_PLATFORM\r\nif (lp->chip_type == CS8900) {\r\nif (i >= ARRAY_SIZE(cs8900_irq_map))\r\npr_err("invalid ISA interrupt number %d\n", i);\r\nelse\r\ni = cs8900_irq_map[i];\r\nlp->irq_map = CS8900_IRQ_MAP;\r\n} else {\r\nint irq_map_buff[IRQ_MAP_LEN/2];\r\nif (get_eeprom_data(dev, IRQ_MAP_EEPROM_DATA,\r\nIRQ_MAP_LEN / 2,\r\nirq_map_buff) >= 0) {\r\nif ((irq_map_buff[0] & 0xff) == PNP_IRQ_FRMT)\r\nlp->irq_map = ((irq_map_buff[0] >> 8) |\r\n(irq_map_buff[1] << 8));\r\n}\r\n}\r\n#endif\r\nif (!dev->irq)\r\ndev->irq = i;\r\n}\r\npr_cont(" IRQ %d", dev->irq);\r\n#if ALLOW_DMA\r\nif (lp->use_dma) {\r\nget_dma_channel(dev);\r\npr_cont(", DMA %d", dev->dma);\r\n} else\r\n#endif\r\npr_cont(", programmed I/O");\r\npr_cont(", MAC %pM\n", dev->dev_addr);\r\ndev->netdev_ops = &net_ops;\r\ndev->watchdog_timeo = HZ;\r\ncs89_dbg(0, info, "cs89x0_probe1() successful\n");\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out2;\r\nreturn 0;\r\nout2:\r\niowrite16(PP_ChipID, lp->virt_addr + ADD_PORT);\r\nout1:\r\nreturn retval;\r\n}\r\nstatic int __init\r\ncs89x0_ioport_probe(struct net_device *dev, unsigned long ioport, int modular)\r\n{\r\nstruct net_local *lp = netdev_priv(dev);\r\nint ret;\r\nvoid __iomem *io_mem;\r\nif (!lp)\r\nreturn -ENOMEM;\r\ndev->base_addr = ioport;\r\nif (!request_region(ioport, NETCARD_IO_EXTENT, DRV_NAME)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nio_mem = ioport_map(ioport & ~3, NETCARD_IO_EXTENT);\r\nif (!io_mem) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nif (ioport & 1) {\r\ncs89_dbg(1, info, "%s: odd ioaddr 0x%lx\n", dev->name, ioport);\r\nif ((ioport & 2) != 2) {\r\nif ((ioread16(io_mem + ADD_PORT) & ADD_MASK) !=\r\nADD_SIG) {\r\npr_err("%s: bad signature 0x%x\n",\r\ndev->name, ioread16(io_mem + ADD_PORT));\r\nret = -ENODEV;\r\ngoto unmap;\r\n}\r\n}\r\n}\r\nret = cs89x0_probe1(dev, io_mem, modular);\r\nif (!ret)\r\ngoto out;\r\nunmap:\r\nioport_unmap(io_mem);\r\nrelease:\r\nrelease_region(ioport, NETCARD_IO_EXTENT);\r\nout:\r\nreturn ret;\r\n}\r\nstruct net_device * __init cs89x0_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nunsigned *port;\r\nint err = 0;\r\nint irq;\r\nint io;\r\nif (!dev)\r\nreturn ERR_PTR(-ENODEV);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nio = dev->base_addr;\r\nirq = dev->irq;\r\ncs89_dbg(0, info, "cs89x0_probe(0x%x)\n", io);\r\nif (io > 0x1ff) {\r\nerr = cs89x0_ioport_probe(dev, io, 0);\r\n} else if (io != 0) {\r\nerr = -ENXIO;\r\n} else {\r\nfor (port = netcard_portlist; *port; port++) {\r\nif (cs89x0_ioport_probe(dev, *port, 0) == 0)\r\nbreak;\r\ndev->irq = irq;\r\n}\r\nif (!*port)\r\nerr = -ENODEV;\r\n}\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\npr_warn("no cs8900 or cs8920 detected. Be sure to disable PnP with SETUP\n");\r\nreturn ERR_PTR(err);\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nstruct net_local *lp;\r\nint ret = 0;\r\n#if DEBUGGING\r\nnet_debug = debug;\r\n#else\r\ndebug = 0;\r\n#endif\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = irq;\r\ndev->base_addr = io;\r\nlp = netdev_priv(dev);\r\n#if ALLOW_DMA\r\nif (use_dma) {\r\nlp->use_dma = use_dma;\r\nlp->dma = dma;\r\nlp->dmasize = dmasize;\r\n}\r\n#endif\r\nspin_lock_init(&lp->lock);\r\nif (!strcmp(media, "rj45"))\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\r\nelse if (!strcmp(media, "aui"))\r\nlp->adapter_cnf = A_CNF_MEDIA_AUI | A_CNF_AUI;\r\nelse if (!strcmp(media, "bnc"))\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_2 | A_CNF_10B_2;\r\nelse\r\nlp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;\r\nif (duplex == -1)\r\nlp->auto_neg_cnf = AUTO_NEG_ENABLE;\r\nif (io == 0) {\r\npr_err("Module autoprobing not allowed\n");\r\npr_err("Append io=0xNNN\n");\r\nret = -EPERM;\r\ngoto out;\r\n} else if (io <= 0x1ff) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\n#if ALLOW_DMA\r\nif (use_dma && dmasize != 16 && dmasize != 64) {\r\npr_err("dma size must be either 16K or 64K, not %dK\n",\r\ndmasize);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\n#endif\r\nret = cs89x0_ioport_probe(dev, io, 1);\r\nif (ret)\r\ngoto out;\r\ndev_cs89x0 = dev;\r\nreturn 0;\r\nout:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nstruct net_local *lp = netdev_priv(dev_cs89x0);\r\nunregister_netdev(dev_cs89x0);\r\niowrite16(PP_ChipID, lp->virt_addr + ADD_PORT);\r\nioport_unmap(lp->virt_addr);\r\nrelease_region(dev_cs89x0->base_addr, NETCARD_IO_EXTENT);\r\nfree_netdev(dev_cs89x0);\r\n}\r\nstatic int __init cs89x0_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = alloc_etherdev(sizeof(struct net_local));\r\nstruct net_local *lp;\r\nstruct resource *mem_res;\r\nvoid __iomem *virt_addr;\r\nint err;\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (mem_res == NULL || dev->irq <= 0) {\r\ndev_warn(&dev->dev, "memory/interrupt resource missing\n");\r\nerr = -ENXIO;\r\ngoto free;\r\n}\r\nlp->size = resource_size(mem_res);\r\nif (!request_mem_region(mem_res->start, lp->size, DRV_NAME)) {\r\ndev_warn(&dev->dev, "request_mem_region() failed\n");\r\nerr = -EBUSY;\r\ngoto free;\r\n}\r\nvirt_addr = ioremap(mem_res->start, lp->size);\r\nif (!virt_addr) {\r\ndev_warn(&dev->dev, "ioremap() failed\n");\r\nerr = -ENOMEM;\r\ngoto release;\r\n}\r\nerr = cs89x0_probe1(dev, virt_addr, 0);\r\nif (err) {\r\ndev_warn(&dev->dev, "no cs8900 or cs8920 detected\n");\r\ngoto unmap;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nreturn 0;\r\nunmap:\r\niounmap(virt_addr);\r\nrelease:\r\nrelease_mem_region(mem_res->start, lp->size);\r\nfree:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int cs89x0_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct net_local *lp = netdev_priv(dev);\r\nstruct resource *mem_res;\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nunregister_netdev(dev);\r\niounmap(lp->virt_addr);\r\nrelease_mem_region(mem_res->start, lp->size);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
