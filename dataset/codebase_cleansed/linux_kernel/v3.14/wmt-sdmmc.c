static void wmt_set_sd_power(struct wmt_mci_priv *priv, int enable)\r\n{\r\nu32 reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nif (enable ^ priv->power_inverted)\r\nreg_tmp &= ~BM_SD_OFF;\r\nelse\r\nreg_tmp |= BM_SD_OFF;\r\nwriteb(reg_tmp, priv->sdmmc_base + SDMMC_BUSMODE);\r\n}\r\nstatic void wmt_mci_read_response(struct mmc_host *mmc)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nint idx1, idx2;\r\nu8 tmp_resp;\r\nu32 response;\r\npriv = mmc_priv(mmc);\r\nfor (idx1 = 0; idx1 < 4; idx1++) {\r\nresponse = 0;\r\nfor (idx2 = 0; idx2 < 4; idx2++) {\r\nif ((idx1 == 3) && (idx2 == 3))\r\ntmp_resp = readb(priv->sdmmc_base + SDMMC_RSP);\r\nelse\r\ntmp_resp = readb(priv->sdmmc_base + SDMMC_RSP +\r\n(idx1*4) + idx2 + 1);\r\nresponse |= (tmp_resp << (idx2 * 8));\r\n}\r\npriv->cmd->resp[idx1] = cpu_to_be32(response);\r\n}\r\n}\r\nstatic void wmt_mci_start_command(struct wmt_mci_priv *priv)\r\n{\r\nu32 reg_tmp;\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\r\nwriteb(reg_tmp | CTLR_CMD_START, priv->sdmmc_base + SDMMC_CTLR);\r\n}\r\nstatic int wmt_mci_send_command(struct mmc_host *mmc, u8 command, u8 cmdtype,\r\nu32 arg, u8 rsptype)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nu32 reg_tmp;\r\npriv = mmc_priv(mmc);\r\nwriteb(command, priv->sdmmc_base + SDMMC_CMD);\r\nwritel(arg, priv->sdmmc_base + SDMMC_ARG);\r\nwriteb(rsptype, priv->sdmmc_base + SDMMC_RSPTYPE);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\r\nwriteb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);\r\nwmt_set_sd_power(priv, WMT_SD_POWER_ON);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS2);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS3);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\r\nwriteb((reg_tmp & 0x0F) | (cmdtype << 4),\r\npriv->sdmmc_base + SDMMC_CTLR);\r\nreturn 0;\r\n}\r\nstatic void wmt_mci_disable_dma(struct wmt_mci_priv *priv)\r\n{\r\nwritel(DMA_ISR_INT_STS, priv->sdmmc_base + SDDMA_ISR);\r\nwritel(0, priv->sdmmc_base + SDDMA_IER);\r\n}\r\nstatic void wmt_complete_data_request(struct wmt_mci_priv *priv)\r\n{\r\nstruct mmc_request *req;\r\nreq = priv->req;\r\nreq->data->bytes_xfered = req->data->blksz * req->data->blocks;\r\nif (req->data->flags & MMC_DATA_WRITE)\r\ndma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,\r\nreq->data->sg_len, DMA_TO_DEVICE);\r\nelse\r\ndma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,\r\nreq->data->sg_len, DMA_FROM_DEVICE);\r\nif ((req->cmd->error) || (req->data->error))\r\nmmc_request_done(priv->mmc, req);\r\nelse {\r\nwmt_mci_read_response(priv->mmc);\r\nif (!req->data->stop) {\r\nmmc_request_done(priv->mmc, req);\r\n} else {\r\npriv->comp_cmd = &priv->cmdcomp;\r\ninit_completion(priv->comp_cmd);\r\npriv->cmd = req->data->stop;\r\nwmt_mci_send_command(priv->mmc, req->data->stop->opcode,\r\n7, req->data->stop->arg, 9);\r\nwmt_mci_start_command(priv);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t wmt_mci_dma_isr(int irq_num, void *data)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nint status;\r\npriv = (struct wmt_mci_priv *)data;\r\nstatus = readl(priv->sdmmc_base + SDDMA_CCR) & 0x0F;\r\nif (status != DMA_CCR_EVT_SUCCESS) {\r\ndev_err(priv->dev, "DMA Error: Status = %d\n", status);\r\npriv->req->data->error = -ETIMEDOUT;\r\ncomplete(priv->comp_dma);\r\nreturn IRQ_HANDLED;\r\n}\r\npriv->req->data->error = 0;\r\nwmt_mci_disable_dma(priv);\r\ncomplete(priv->comp_dma);\r\nif (priv->comp_cmd) {\r\nif (completion_done(priv->comp_cmd)) {\r\nwmt_complete_data_request(priv);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wmt_mci_regular_isr(int irq_num, void *data)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nu32 status0;\r\nu32 status1;\r\nu32 status2;\r\nu32 reg_tmp;\r\nint cmd_done;\r\npriv = (struct wmt_mci_priv *)data;\r\ncmd_done = 0;\r\nstatus0 = readb(priv->sdmmc_base + SDMMC_STS0);\r\nstatus1 = readb(priv->sdmmc_base + SDMMC_STS1);\r\nstatus2 = readb(priv->sdmmc_base + SDMMC_STS2);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);\r\nif ((reg_tmp & INT0_DI_INT_EN) && (status0 & STS0_DEVICE_INS)) {\r\nmmc_detect_change(priv->mmc, 0);\r\nif (priv->cmd)\r\npriv->cmd->error = -ETIMEDOUT;\r\nif (priv->comp_cmd)\r\ncomplete(priv->comp_cmd);\r\nif (priv->comp_dma) {\r\nwmt_mci_disable_dma(priv);\r\ncomplete(priv->comp_dma);\r\n}\r\nwriteb(STS0_DEVICE_INS, priv->sdmmc_base + SDMMC_STS0);\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((!priv->req->data) ||\r\n((priv->req->data->stop) && (priv->cmd == priv->req->data->stop))) {\r\nif (status1 & STS1_CMDRSP_DONE) {\r\npriv->cmd->error = 0;\r\ncmd_done = 1;\r\n} else if ((status1 & STS1_RSP_TIMEOUT) ||\r\n(status1 & STS1_DATA_TIMEOUT)) {\r\npriv->cmd->error = -ETIMEDOUT;\r\ncmd_done = 1;\r\n}\r\nif (cmd_done) {\r\npriv->comp_cmd = NULL;\r\nif (!priv->cmd->error)\r\nwmt_mci_read_response(priv->mmc);\r\npriv->cmd = NULL;\r\nmmc_request_done(priv->mmc, priv->req);\r\n}\r\n} else {\r\nif (status1 & STS1_CMDRSP_DONE) {\r\nif (priv->cmd)\r\npriv->cmd->error = 0;\r\nif (priv->comp_cmd)\r\ncomplete(priv->comp_cmd);\r\n}\r\nif ((status1 & STS1_RSP_TIMEOUT) ||\r\n(status1 & STS1_DATA_TIMEOUT)) {\r\nif (priv->cmd)\r\npriv->cmd->error = -ETIMEDOUT;\r\nif (priv->comp_cmd)\r\ncomplete(priv->comp_cmd);\r\nif (priv->comp_dma) {\r\nwmt_mci_disable_dma(priv);\r\ncomplete(priv->comp_dma);\r\n}\r\n}\r\nif (priv->comp_dma) {\r\nif (completion_done(priv->comp_dma))\r\nwmt_complete_data_request(priv);\r\n}\r\n}\r\nwriteb(status0, priv->sdmmc_base + SDMMC_STS0);\r\nwriteb(status1, priv->sdmmc_base + SDMMC_STS1);\r\nwriteb(status2, priv->sdmmc_base + SDMMC_STS2);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wmt_reset_hardware(struct mmc_host *mmc)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nu32 reg_tmp;\r\npriv = mmc_priv(mmc);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\r\nwriteb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);\r\nwritew(BLKL_INT_ENABLE | BLKL_GPI_CD, priv->sdmmc_base + SDMMC_BLKLEN);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\r\nwriteb(INT0_CD_INT_EN | INT0_DI_INT_EN, priv->sdmmc_base +\r\nSDMMC_INTMASK0);\r\nwriteb(INT1_DATA_TOUT_INT_EN | INT1_CMD_RES_TRAN_DONE_INT_EN |\r\nINT1_CMD_RES_TOUT_INT_EN, priv->sdmmc_base + SDMMC_INTMASK1);\r\nwritew(8191, priv->sdmmc_base + SDMMC_DMATIMEOUT);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_STS2);\r\nwriteb(reg_tmp | STS2_DIS_FORCECLK, priv->sdmmc_base + SDMMC_STS2);\r\nclk_set_rate(priv->clk_sdmmc, 400000);\r\n}\r\nstatic int wmt_dma_init(struct mmc_host *mmc)\r\n{\r\nstruct wmt_mci_priv *priv;\r\npriv = mmc_priv(mmc);\r\nwritel(DMA_GCR_SOFT_RESET, priv->sdmmc_base + SDDMA_GCR);\r\nwritel(DMA_GCR_DMA_EN, priv->sdmmc_base + SDDMA_GCR);\r\nif ((readl(priv->sdmmc_base + SDDMA_GCR) & DMA_GCR_DMA_EN) != 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void wmt_dma_init_descriptor(struct wmt_dma_descriptor *desc,\r\nu16 req_count, u32 buffer_addr, u32 branch_addr, int end)\r\n{\r\ndesc->flags = 0x40000000 | req_count;\r\nif (end)\r\ndesc->flags |= 0x80000000;\r\ndesc->data_buffer_addr = buffer_addr;\r\ndesc->branch_addr = branch_addr;\r\n}\r\nstatic void wmt_dma_config(struct mmc_host *mmc, u32 descaddr, u8 dir)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nu32 reg_tmp;\r\npriv = mmc_priv(mmc);\r\nwritel(DMA_IER_INT_EN, priv->sdmmc_base + SDDMA_IER);\r\nwritel(descaddr, priv->sdmmc_base + SDDMA_DESPR);\r\nwritel(0x00, priv->sdmmc_base + SDDMA_CCR);\r\nif (dir == PDMA_WRITE) {\r\nreg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\r\nwritel(reg_tmp & DMA_CCR_IF_TO_PERIPHERAL, priv->sdmmc_base +\r\nSDDMA_CCR);\r\n} else {\r\nreg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\r\nwritel(reg_tmp | DMA_CCR_PERIPHERAL_TO_IF, priv->sdmmc_base +\r\nSDDMA_CCR);\r\n}\r\n}\r\nstatic void wmt_dma_start(struct wmt_mci_priv *priv)\r\n{\r\nu32 reg_tmp;\r\nreg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\r\nwritel(reg_tmp | DMA_CCR_RUN, priv->sdmmc_base + SDDMA_CCR);\r\n}\r\nstatic void wmt_mci_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nstruct wmt_dma_descriptor *desc;\r\nu8 command;\r\nu8 cmdtype;\r\nu32 arg;\r\nu8 rsptype;\r\nu32 reg_tmp;\r\nstruct scatterlist *sg;\r\nint i;\r\nint sg_cnt;\r\nint offset;\r\nu32 dma_address;\r\nint desc_cnt;\r\npriv = mmc_priv(mmc);\r\npriv->req = req;\r\npriv->cmd = req->cmd;\r\ncommand = req->cmd->opcode;\r\narg = req->cmd->arg;\r\nrsptype = mmc_resp_type(req->cmd);\r\ncmdtype = 0;\r\nif (rsptype == 7)\r\nrsptype = 2;\r\nif (rsptype == 21)\r\nrsptype = 9;\r\nif (!req->data) {\r\nwmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);\r\nwmt_mci_start_command(priv);\r\n}\r\nif (req->data) {\r\npriv->comp_cmd = &priv->cmdcomp;\r\ninit_completion(priv->comp_cmd);\r\nwmt_dma_init(mmc);\r\nreg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\r\nwritew((reg_tmp & 0xF800) | (req->data->blksz - 1),\r\npriv->sdmmc_base + SDMMC_BLKLEN);\r\nwritew(req->data->blocks, priv->sdmmc_base + SDMMC_BLKCNT);\r\ndesc = (struct wmt_dma_descriptor *)priv->dma_desc_buffer;\r\nif (req->data->flags & MMC_DATA_WRITE) {\r\nsg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,\r\nreq->data->sg_len, DMA_TO_DEVICE);\r\ncmdtype = 1;\r\nif (req->data->blocks > 1)\r\ncmdtype = 3;\r\n} else {\r\nsg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,\r\nreq->data->sg_len, DMA_FROM_DEVICE);\r\ncmdtype = 2;\r\nif (req->data->blocks > 1)\r\ncmdtype = 4;\r\n}\r\ndma_address = priv->dma_desc_device_addr + 16;\r\ndesc_cnt = 0;\r\nfor_each_sg(req->data->sg, sg, sg_cnt, i) {\r\noffset = 0;\r\nwhile (offset < sg_dma_len(sg)) {\r\nwmt_dma_init_descriptor(desc, req->data->blksz,\r\nsg_dma_address(sg)+offset,\r\ndma_address, 0);\r\ndesc++;\r\ndesc_cnt++;\r\noffset += req->data->blksz;\r\ndma_address += 16;\r\nif (desc_cnt == req->data->blocks)\r\nbreak;\r\n}\r\n}\r\ndesc--;\r\ndesc->flags |= 0x80000000;\r\nif (req->data->flags & MMC_DATA_WRITE)\r\nwmt_dma_config(mmc, priv->dma_desc_device_addr,\r\nPDMA_WRITE);\r\nelse\r\nwmt_dma_config(mmc, priv->dma_desc_device_addr,\r\nPDMA_READ);\r\nwmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);\r\npriv->comp_dma = &priv->datacomp;\r\ninit_completion(priv->comp_dma);\r\nwmt_dma_start(priv);\r\nwmt_mci_start_command(priv);\r\n}\r\n}\r\nstatic void wmt_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct wmt_mci_priv *priv;\r\nu32 reg_tmp;\r\npriv = mmc_priv(mmc);\r\nif (ios->power_mode == MMC_POWER_UP) {\r\nwmt_reset_hardware(mmc);\r\nwmt_set_sd_power(priv, WMT_SD_POWER_ON);\r\n}\r\nif (ios->power_mode == MMC_POWER_OFF)\r\nwmt_set_sd_power(priv, WMT_SD_POWER_OFF);\r\nif (ios->clock != 0)\r\nclk_set_rate(priv->clk_sdmmc, ios->clock);\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_8:\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);\r\nwriteb(reg_tmp | 0x04, priv->sdmmc_base + SDMMC_EXTCTRL);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwriteb(reg_tmp | BM_FOURBIT_MODE, priv->sdmmc_base +\r\nSDMMC_BUSMODE);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);\r\nwriteb(reg_tmp & 0xFB, priv->sdmmc_base + SDMMC_EXTCTRL);\r\nbreak;\r\ncase MMC_BUS_WIDTH_1:\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwriteb(reg_tmp & BM_ONEBIT_MASK, priv->sdmmc_base +\r\nSDMMC_BUSMODE);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_EXTCTRL);\r\nwriteb(reg_tmp & 0xFB, priv->sdmmc_base + SDMMC_EXTCTRL);\r\nbreak;\r\n}\r\n}\r\nstatic int wmt_mci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct wmt_mci_priv *priv = mmc_priv(mmc);\r\nreturn !(readb(priv->sdmmc_base + SDMMC_STS0) & STS0_WRITE_PROTECT);\r\n}\r\nstatic int wmt_mci_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct wmt_mci_priv *priv = mmc_priv(mmc);\r\nu32 cd = (readb(priv->sdmmc_base + SDMMC_STS0) & STS0_CD_GPI) >> 3;\r\nreturn !(cd ^ priv->cd_inverted);\r\n}\r\nstatic int wmt_mci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct wmt_mci_priv *priv;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(wmt_mci_dt_ids, &pdev->dev);\r\nconst struct wmt_mci_caps *wmt_caps = of_id->data;\r\nint ret;\r\nint regular_irq, dma_irq;\r\nif (!of_id || !of_id->data) {\r\ndev_err(&pdev->dev, "Controller capabilities data missing\n");\r\nreturn -EFAULT;\r\n}\r\nif (!np) {\r\ndev_err(&pdev->dev, "Missing SDMMC description in devicetree\n");\r\nreturn -EFAULT;\r\n}\r\nregular_irq = irq_of_parse_and_map(np, 0);\r\ndma_irq = irq_of_parse_and_map(np, 1);\r\nif (!regular_irq || !dma_irq) {\r\ndev_err(&pdev->dev, "Getting IRQs failed!\n");\r\nret = -ENXIO;\r\ngoto fail1;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct wmt_mci_priv), &pdev->dev);\r\nif (!mmc) {\r\ndev_err(&pdev->dev, "Failed to allocate mmc_host\n");\r\nret = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmmc->ops = &wmt_mci_ops;\r\nmmc->f_min = wmt_caps->f_min;\r\nmmc->f_max = wmt_caps->f_max;\r\nmmc->ocr_avail = wmt_caps->ocr_avail;\r\nmmc->caps = wmt_caps->caps;\r\nmmc->max_seg_size = wmt_caps->max_seg_size;\r\nmmc->max_segs = wmt_caps->max_segs;\r\nmmc->max_blk_size = wmt_caps->max_blk_size;\r\nmmc->max_req_size = (16*512*mmc->max_segs);\r\nmmc->max_blk_count = mmc->max_req_size / 512;\r\npriv = mmc_priv(mmc);\r\npriv->mmc = mmc;\r\npriv->dev = &pdev->dev;\r\npriv->power_inverted = 0;\r\npriv->cd_inverted = 0;\r\nif (of_get_property(np, "sdon-inverted", NULL))\r\npriv->power_inverted = 1;\r\nif (of_get_property(np, "cd-inverted", NULL))\r\npriv->cd_inverted = 1;\r\npriv->sdmmc_base = of_iomap(np, 0);\r\nif (!priv->sdmmc_base) {\r\ndev_err(&pdev->dev, "Failed to map IO space\n");\r\nret = -ENOMEM;\r\ngoto fail2;\r\n}\r\npriv->irq_regular = regular_irq;\r\npriv->irq_dma = dma_irq;\r\nret = request_irq(regular_irq, wmt_mci_regular_isr, 0, "sdmmc", priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Register regular IRQ fail\n");\r\ngoto fail3;\r\n}\r\nret = request_irq(dma_irq, wmt_mci_dma_isr, 32, "sdmmc", priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Register DMA IRQ fail\n");\r\ngoto fail4;\r\n}\r\npriv->dma_desc_buffer = dma_alloc_coherent(&pdev->dev,\r\nmmc->max_blk_count * 16,\r\n&priv->dma_desc_device_addr,\r\n208);\r\nif (!priv->dma_desc_buffer) {\r\ndev_err(&pdev->dev, "DMA alloc fail\n");\r\nret = -EPERM;\r\ngoto fail5;\r\n}\r\nplatform_set_drvdata(pdev, mmc);\r\npriv->clk_sdmmc = of_clk_get(np, 0);\r\nif (IS_ERR(priv->clk_sdmmc)) {\r\ndev_err(&pdev->dev, "Error getting clock\n");\r\nret = PTR_ERR(priv->clk_sdmmc);\r\ngoto fail5;\r\n}\r\nclk_prepare_enable(priv->clk_sdmmc);\r\nwmt_reset_hardware(mmc);\r\nmmc_add_host(mmc);\r\ndev_info(&pdev->dev, "WMT SDHC Controller initialized\n");\r\nreturn 0;\r\nfail5:\r\nfree_irq(dma_irq, priv);\r\nfail4:\r\nfree_irq(regular_irq, priv);\r\nfail3:\r\niounmap(priv->sdmmc_base);\r\nfail2:\r\nmmc_free_host(mmc);\r\nfail1:\r\nreturn ret;\r\n}\r\nstatic int wmt_mci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct wmt_mci_priv *priv;\r\nstruct resource *res;\r\nu32 reg_tmp;\r\nmmc = platform_get_drvdata(pdev);\r\npriv = mmc_priv(mmc);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwritel(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);\r\nreg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\r\nwritew(reg_tmp & ~(0xA000), priv->sdmmc_base + SDMMC_BLKLEN);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\r\ndma_free_coherent(&pdev->dev, priv->mmc->max_blk_count * 16,\r\npriv->dma_desc_buffer, priv->dma_desc_device_addr);\r\nmmc_remove_host(mmc);\r\nfree_irq(priv->irq_regular, priv);\r\nfree_irq(priv->irq_dma, priv);\r\niounmap(priv->sdmmc_base);\r\nclk_disable_unprepare(priv->clk_sdmmc);\r\nclk_put(priv->clk_sdmmc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nmmc_free_host(mmc);\r\ndev_info(&pdev->dev, "WMT MCI device removed\n");\r\nreturn 0;\r\n}\r\nstatic int wmt_mci_suspend(struct device *dev)\r\n{\r\nu32 reg_tmp;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct wmt_mci_priv *priv;\r\nif (!mmc)\r\nreturn 0;\r\npriv = mmc_priv(mmc);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base +\r\nSDMMC_BUSMODE);\r\nreg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\r\nwritew(reg_tmp & 0x5FFF, priv->sdmmc_base + SDMMC_BLKLEN);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\r\nwriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\r\nclk_disable(priv->clk_sdmmc);\r\nreturn 0;\r\n}\r\nstatic int wmt_mci_resume(struct device *dev)\r\n{\r\nu32 reg_tmp;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct wmt_mci_priv *priv;\r\nif (mmc) {\r\npriv = mmc_priv(mmc);\r\nclk_enable(priv->clk_sdmmc);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\r\nwriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base +\r\nSDMMC_BUSMODE);\r\nreg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\r\nwritew(reg_tmp | (BLKL_GPI_CD | BLKL_INT_ENABLE),\r\npriv->sdmmc_base + SDMMC_BLKLEN);\r\nreg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);\r\nwriteb(reg_tmp | INT0_DI_INT_EN, priv->sdmmc_base +\r\nSDMMC_INTMASK0);\r\n}\r\nreturn 0;\r\n}
