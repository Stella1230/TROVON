void mdfldWaitForPipeDisable(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint count, temp;\r\nswitch (pipe) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal Pipe Number.\n");\r\nreturn;\r\n}\r\ngma_wait_for_vblank(dev);\r\nreturn;\r\nfor (count = 0; count < COUNT_MAX; count++) {\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_PIPE_STATE) == 0)\r\nbreak;\r\n}\r\n}\r\nvoid mdfldWaitForPipeEnable(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint count, temp;\r\nswitch (pipe) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal Pipe Number.\n");\r\nreturn;\r\n}\r\ngma_wait_for_vblank(dev);\r\nreturn;\r\nfor (count = 0; count < COUNT_MAX; count++) {\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_PIPE_STATE) == 1)\r\nbreak;\r\n}\r\n}\r\nstatic int psb_intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn (pfit_control >> 29) & 0x3;\r\n}\r\nvoid mdfld__intel_plane_set_alpha(int enable)\r\n{\r\nstruct drm_device *dev = &globle_dev;\r\nint dspcntr_reg = DSPACNTR;\r\nu32 dspcntr;\r\ndspcntr = REG_READ(dspcntr_reg);\r\nif (enable) {\r\ndspcntr &= ~DISPPLANE_32BPP_NO_ALPHA;\r\ndspcntr |= DISPPLANE_32BPP;\r\n} else {\r\ndspcntr &= ~DISPPLANE_32BPP;\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\n}\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\n}\r\nstatic int check_fb(struct drm_framebuffer *fb)\r\n{\r\nif (!fb)\r\nreturn 0;\r\nswitch (fb->bits_per_pixel) {\r\ncase 8:\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("Unknown color depth\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mdfld__intel_pipe_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct psb_framebuffer *psbfb = to_psb_fb(crtc->fb);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nunsigned long start, offset;\r\nu32 dspcntr;\r\nint ret;\r\nmemcpy(&globle_dev, dev, sizeof(struct drm_device));\r\ndev_dbg(dev->dev, "pipe = 0x%x.\n", pipe);\r\nif (!crtc->fb) {\r\ndev_dbg(dev->dev, "No FB bound\n");\r\nreturn 0;\r\n}\r\nret = check_fb(crtc->fb);\r\nif (ret)\r\nreturn ret;\r\nif (pipe > 2) {\r\nDRM_ERROR("Illegal Pipe Number.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nstart = psbfb->gtt->offset;\r\noffset = y * crtc->fb->pitches[0] + x * (crtc->fb->bits_per_pixel / 8);\r\nREG_WRITE(map->stride, crtc->fb->pitches[0]);\r\ndspcntr = REG_READ(map->cntr);\r\ndspcntr &= ~DISPPLANE_PIXFORMAT_MASK;\r\nswitch (crtc->fb->bits_per_pixel) {\r\ncase 8:\r\ndspcntr |= DISPPLANE_8BPP;\r\nbreak;\r\ncase 16:\r\nif (crtc->fb->depth == 15)\r\ndspcntr |= DISPPLANE_15_16BPP;\r\nelse\r\ndspcntr |= DISPPLANE_16BPP;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndspcntr |= DISPPLANE_32BPP_NO_ALPHA;\r\nbreak;\r\n}\r\nREG_WRITE(map->cntr, dspcntr);\r\ndev_dbg(dev->dev, "Writing base %08lX %08lX %d %d\n",\r\nstart, offset, x, y);\r\nREG_WRITE(map->linoff, offset);\r\nREG_READ(map->linoff);\r\nREG_WRITE(map->surf, start);\r\nREG_READ(map->surf);\r\ngma_power_end(dev);\r\nreturn 0;\r\n}\r\nvoid mdfld_disable_crtc(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 temp;\r\ndev_dbg(dev->dev, "pipe = %d\n", pipe);\r\nif (pipe != 1)\r\nmdfld_dsi_gen_fifo_ready(dev, MIPI_GEN_FIFO_STAT_REG(pipe),\r\nHS_CTRL_FIFO_EMPTY | HS_DATA_FIFO_EMPTY);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_READ(map->base);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\ntemp &= ~PIPEACONF_ENABLE;\r\ntemp |= PIPECONF_PLANE_OFF | PIPECONF_CURSOR_OFF;\r\nREG_WRITE(map->conf, temp);\r\nREG_READ(map->conf);\r\nmdfldWaitForPipeDisable(dev, pipe);\r\n}\r\ntemp = REG_READ(map->dpll);\r\nif (temp & DPLL_VCO_ENABLE) {\r\nif ((pipe != 1 &&\r\n!((REG_READ(PIPEACONF) | REG_READ(PIPECCONF))\r\n& PIPEACONF_ENABLE)) || pipe == 1) {\r\ntemp &= ~(DPLL_VCO_ENABLE);\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(500);\r\nif (!(temp & MDFLD_PWR_GATE_EN)) {\r\nREG_WRITE(map->dpll, temp | MDFLD_PWR_GATE_EN);\r\nudelay(5000);\r\n}\r\n}\r\n}\r\n}\r\nstatic void mdfld_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 pipeconf = dev_priv->pipeconf[pipe];\r\nu32 temp;\r\nint timeout = 0;\r\ndev_dbg(dev->dev, "mode = %d, pipe = %d\n", mode, pipe);\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ntemp = REG_READ(map->dpll);\r\nif ((temp & DPLL_VCO_ENABLE) == 0) {\r\nif (temp & MDFLD_PWR_GATE_EN) {\r\ntemp &= ~MDFLD_PWR_GATE_EN;\r\nREG_WRITE(map->dpll, temp);\r\nudelay(500);\r\n}\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(500);\r\nREG_WRITE(map->dpll, temp | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nwhile ((pipe != 2) && (timeout < 20000) &&\r\n!(REG_READ(map->conf) & PIPECONF_DSIPLL_LOCK)) {\r\nudelay(150);\r\ntimeout++;\r\n}\r\n}\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) == 0) {\r\nREG_WRITE(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) == 0) {\r\nREG_WRITE(map->conf, pipeconf);\r\nmdfldWaitForPipeEnable(dev, pipe);\r\n}\r\nif (pipe == 0 || pipe == 2) {\r\nREG_WRITE(map->status, REG_READ(map->status));\r\nmsleep(100);\r\nif (PIPE_VBLANK_STATUS & REG_READ(map->status))\r\ndev_dbg(dev->dev, "OK");\r\nelse {\r\ndev_dbg(dev->dev, "STUCK!!!!");\r\ntemp = REG_READ(map->cntr);\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_WRITE(0xb048, 1);\r\nmsleep(100);\r\ntemp = REG_READ(map->conf);\r\ntemp &= ~PIPEACONF_ENABLE;\r\nREG_WRITE(map->conf, temp);\r\nmsleep(100);\r\nREG_WRITE(MIPI_DEVICE_READY_REG(pipe), 0);\r\nmsleep(100);\r\nREG_WRITE(0xb004, REG_READ(0xb004));\r\nREG_WRITE(MIPI_DEVICE_READY_REG(pipe), 1);\r\ntemp = REG_READ(map->cntr);\r\nREG_WRITE(map->cntr,\r\ntemp | DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_WRITE(0xb048, 2);\r\nmsleep(100);\r\ntemp = REG_READ(map->conf);\r\ntemp |= PIPEACONF_ENABLE;\r\nREG_WRITE(map->conf, temp);\r\n}\r\n}\r\ngma_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nif (pipe != 1)\r\nmdfld_dsi_gen_fifo_ready(dev,\r\nMIPI_GEN_FIFO_STAT_REG(pipe),\r\nHS_CTRL_FIFO_EMPTY | HS_DATA_FIFO_EMPTY);\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\ntemp = REG_READ(map->cntr);\r\nif ((temp & DISPLAY_PLANE_ENABLE) != 0) {\r\nREG_WRITE(map->cntr,\r\ntemp & ~DISPLAY_PLANE_ENABLE);\r\nREG_WRITE(map->base, REG_READ(map->base));\r\nREG_READ(map->base);\r\n}\r\ntemp = REG_READ(map->conf);\r\nif ((temp & PIPEACONF_ENABLE) != 0) {\r\ntemp &= ~PIPEACONF_ENABLE;\r\ntemp |= PIPECONF_PLANE_OFF | PIPECONF_CURSOR_OFF;\r\nREG_WRITE(map->conf, temp);\r\nREG_READ(map->conf);\r\nmdfldWaitForPipeDisable(dev, pipe);\r\n}\r\ntemp = REG_READ(map->dpll);\r\nif (temp & DPLL_VCO_ENABLE) {\r\nif ((pipe != 1 && !((REG_READ(PIPEACONF)\r\n| REG_READ(PIPECCONF)) & PIPEACONF_ENABLE))\r\n|| pipe == 1) {\r\ntemp &= ~(DPLL_VCO_ENABLE);\r\nREG_WRITE(map->dpll, temp);\r\nREG_READ(map->dpll);\r\nudelay(500);\r\n}\r\n}\r\nbreak;\r\n}\r\ngma_power_end(dev);\r\n}\r\nstatic const struct mrst_limit_t *mdfld_limit(struct drm_crtc *crtc)\r\n{\r\nconst struct mrst_limit_t *limit = NULL;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_MIPI)\r\n|| gma_pipe_has_type(crtc, INTEL_OUTPUT_MIPI2)) {\r\nif ((ksel == KSEL_CRYSTAL_19) || (ksel == KSEL_BYPASS_19))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DSIPLL_19];\r\nelse if (ksel == KSEL_BYPASS_25)\r\nlimit = &mdfld_limits[MDFLD_LIMT_DSIPLL_25];\r\nelse if ((ksel == KSEL_BYPASS_83_100) &&\r\n(dev_priv->core_freq == 166))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DSIPLL_83];\r\nelse if ((ksel == KSEL_BYPASS_83_100) &&\r\n(dev_priv->core_freq == 100 ||\r\ndev_priv->core_freq == 200))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DSIPLL_100];\r\n} else if (gma_pipe_has_type(crtc, INTEL_OUTPUT_HDMI)) {\r\nif ((ksel == KSEL_CRYSTAL_19) || (ksel == KSEL_BYPASS_19))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DPLL_19];\r\nelse if (ksel == KSEL_BYPASS_25)\r\nlimit = &mdfld_limits[MDFLD_LIMT_DPLL_25];\r\nelse if ((ksel == KSEL_BYPASS_83_100) &&\r\n(dev_priv->core_freq == 166))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DPLL_83];\r\nelse if ((ksel == KSEL_BYPASS_83_100) &&\r\n(dev_priv->core_freq == 100 ||\r\ndev_priv->core_freq == 200))\r\nlimit = &mdfld_limits[MDFLD_LIMT_DPLL_100];\r\n} else {\r\nlimit = NULL;\r\ndev_dbg(dev->dev, "mdfld_limit Wrong display type.\n");\r\n}\r\nreturn limit;\r\n}\r\nstatic void mdfld_clock(int refclk, struct mrst_clock_t *clock)\r\n{\r\nclock->dot = (refclk * clock->m) / clock->p1;\r\n}\r\nstatic bool\r\nmdfldFindBestPLL(struct drm_crtc *crtc, int target, int refclk,\r\nstruct mrst_clock_t *best_clock)\r\n{\r\nstruct mrst_clock_t clock;\r\nconst struct mrst_limit_t *limit = mdfld_limit(crtc);\r\nint err = target;\r\nmemset(best_clock, 0, sizeof(*best_clock));\r\nfor (clock.m = limit->m.min; clock.m <= limit->m.max; clock.m++) {\r\nfor (clock.p1 = limit->p1.min; clock.p1 <= limit->p1.max;\r\nclock.p1++) {\r\nint this_err;\r\nmdfld_clock(refclk, &clock);\r\nthis_err = abs(clock.dot - target);\r\nif (this_err < err) {\r\n*best_clock = clock;\r\nerr = this_err;\r\n}\r\n}\r\n}\r\nreturn err != target;\r\n}\r\nstatic int mdfld_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk = 0;\r\nint clk_n = 0, clk_p2 = 0, clk_byte = 1, clk = 0, m_conv = 0,\r\nclk_tmp = 0;\r\nstruct mrst_clock_t clock;\r\nbool ok;\r\nu32 dpll = 0, fp = 0;\r\nbool is_mipi = false, is_mipi2 = false, is_hdmi = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct gma_encoder *gma_encoder = NULL;\r\nuint64_t scalingType = DRM_MODE_SCALE_FULLSCREEN;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nint timeout = 0;\r\nint ret;\r\ndev_dbg(dev->dev, "pipe = 0x%x\n", pipe);\r\n#if 0\r\nif (pipe == 1) {\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nandroid_hdmi_crtc_mode_set(crtc, mode, adjusted_mode,\r\nx, y, old_fb);\r\ngoto mrst_crtc_mode_set_exit;\r\n}\r\n#endif\r\nret = check_fb(crtc->fb);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(dev->dev, "adjusted_hdisplay = %d\n",\r\nadjusted_mode->hdisplay);\r\ndev_dbg(dev->dev, "adjusted_vdisplay = %d\n",\r\nadjusted_mode->vdisplay);\r\ndev_dbg(dev->dev, "adjusted_hsync_start = %d\n",\r\nadjusted_mode->hsync_start);\r\ndev_dbg(dev->dev, "adjusted_hsync_end = %d\n",\r\nadjusted_mode->hsync_end);\r\ndev_dbg(dev->dev, "adjusted_htotal = %d\n",\r\nadjusted_mode->htotal);\r\ndev_dbg(dev->dev, "adjusted_vsync_start = %d\n",\r\nadjusted_mode->vsync_start);\r\ndev_dbg(dev->dev, "adjusted_vsync_end = %d\n",\r\nadjusted_mode->vsync_end);\r\ndev_dbg(dev->dev, "adjusted_vtotal = %d\n",\r\nadjusted_mode->vtotal);\r\ndev_dbg(dev->dev, "adjusted_clock = %d\n",\r\nadjusted_mode->clock);\r\ndev_dbg(dev->dev, "hdisplay = %d\n",\r\nmode->hdisplay);\r\ndev_dbg(dev->dev, "vdisplay = %d\n",\r\nmode->vdisplay);\r\nif (!gma_power_begin(dev, true))\r\nreturn 0;\r\nmemcpy(&gma_crtc->saved_mode, mode,\r\nsizeof(struct drm_display_mode));\r\nmemcpy(&gma_crtc->saved_adjusted_mode, adjusted_mode,\r\nsizeof(struct drm_display_mode));\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nif (!connector)\r\ncontinue;\r\nencoder = connector->encoder;\r\nif (!encoder)\r\ncontinue;\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\ngma_encoder = gma_attached_encoder(connector);\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_MIPI:\r\nis_mipi = true;\r\nbreak;\r\ncase INTEL_OUTPUT_MIPI2:\r\nis_mipi2 = true;\r\nbreak;\r\ncase INTEL_OUTPUT_HDMI:\r\nis_hdmi = true;\r\nbreak;\r\n}\r\n}\r\nREG_WRITE(VGACNTRL, VGA_DISP_DISABLE);\r\nif (psb_intel_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nif (pipe == 1) {\r\nREG_WRITE(map->size, ((min(mode->crtc_vdisplay, adjusted_mode->crtc_vdisplay) - 1) << 16)\r\n| (min(mode->crtc_hdisplay, adjusted_mode->crtc_hdisplay) - 1));\r\nREG_WRITE(map->src, ((mode->crtc_hdisplay - 1) << 16)\r\n| (mode->crtc_vdisplay - 1));\r\n} else {\r\nREG_WRITE(map->size,\r\n((mode->crtc_vdisplay - 1) << 16) |\r\n(mode->crtc_hdisplay - 1));\r\nREG_WRITE(map->src,\r\n((mode->crtc_hdisplay - 1) << 16) |\r\n(mode->crtc_vdisplay - 1));\r\n}\r\nREG_WRITE(map->pos, 0);\r\nif (gma_encoder)\r\ndrm_object_property_get_value(&connector->base,\r\ndev->mode_config.scaling_mode_property, &scalingType);\r\nif (scalingType == DRM_MODE_SCALE_NO_SCALE) {\r\nint offsetX = 0, offsetY = 0;\r\noffsetX = (adjusted_mode->crtc_hdisplay -\r\nmode->crtc_hdisplay) / 2;\r\noffsetY = (adjusted_mode->crtc_vdisplay -\r\nmode->crtc_vdisplay) / 2;\r\nREG_WRITE(map->htotal, (mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->vtotal, (mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start -\r\noffsetX - 1) |\r\n((adjusted_mode->crtc_hblank_end - offsetX - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start -\r\noffsetX - 1) |\r\n((adjusted_mode->crtc_hsync_end - offsetX - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start -\r\noffsetY - 1) |\r\n((adjusted_mode->crtc_vblank_end - offsetY - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start -\r\noffsetY - 1) |\r\n((adjusted_mode->crtc_vsync_end - offsetY - 1) << 16));\r\n} else {\r\nREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\n}\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs =\r\ncrtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\ndev_priv->pipeconf[pipe] = PIPEACONF_ENABLE;\r\ndev_priv->dspcntr[pipe] = REG_READ(map->cntr);\r\ndev_priv->dspcntr[pipe] |= pipe << DISPPLANE_SEL_PIPE_POS;\r\ndev_priv->dspcntr[pipe] |= DISPLAY_PLANE_ENABLE;\r\nif (is_mipi2)\r\ngoto mrst_crtc_mode_set_exit;\r\nclk = adjusted_mode->clock;\r\nif (is_hdmi) {\r\nif ((ksel == KSEL_CRYSTAL_19) || (ksel == KSEL_BYPASS_19)) {\r\nrefclk = 19200;\r\nif (is_mipi || is_mipi2)\r\nclk_n = 1, clk_p2 = 8;\r\nelse if (is_hdmi)\r\nclk_n = 1, clk_p2 = 10;\r\n} else if (ksel == KSEL_BYPASS_25) {\r\nrefclk = 25000;\r\nif (is_mipi || is_mipi2)\r\nclk_n = 1, clk_p2 = 8;\r\nelse if (is_hdmi)\r\nclk_n = 1, clk_p2 = 10;\r\n} else if ((ksel == KSEL_BYPASS_83_100) &&\r\ndev_priv->core_freq == 166) {\r\nrefclk = 83000;\r\nif (is_mipi || is_mipi2)\r\nclk_n = 4, clk_p2 = 8;\r\nelse if (is_hdmi)\r\nclk_n = 4, clk_p2 = 10;\r\n} else if ((ksel == KSEL_BYPASS_83_100) &&\r\n(dev_priv->core_freq == 100 ||\r\ndev_priv->core_freq == 200)) {\r\nrefclk = 100000;\r\nif (is_mipi || is_mipi2)\r\nclk_n = 4, clk_p2 = 8;\r\nelse if (is_hdmi)\r\nclk_n = 4, clk_p2 = 10;\r\n}\r\nif (is_mipi)\r\nclk_byte = dev_priv->bpp / 8;\r\nelse if (is_mipi2)\r\nclk_byte = dev_priv->bpp2 / 8;\r\nclk_tmp = clk * clk_n * clk_p2 * clk_byte;\r\ndev_dbg(dev->dev, "clk = %d, clk_n = %d, clk_p2 = %d.\n",\r\nclk, clk_n, clk_p2);\r\ndev_dbg(dev->dev, "adjusted_mode->clock = %d, clk_tmp = %d.\n",\r\nadjusted_mode->clock, clk_tmp);\r\nok = mdfldFindBestPLL(crtc, clk_tmp, refclk, &clock);\r\nif (!ok) {\r\nDRM_ERROR\r\n("mdfldFindBestPLL fail in mdfld_crtc_mode_set.\n");\r\n} else {\r\nm_conv = mdfld_m_converts[(clock.m - MDFLD_M_MIN)];\r\ndev_dbg(dev->dev, "dot clock = %d,"\r\n"m = %d, p1 = %d, m_conv = %d.\n",\r\nclock.dot, clock.m,\r\nclock.p1, m_conv);\r\n}\r\ndpll = REG_READ(map->dpll);\r\nif (dpll & DPLL_VCO_ENABLE) {\r\ndpll &= ~DPLL_VCO_ENABLE;\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(500);\r\nREG_WRITE(map->fp0, 0);\r\ndpll &= ~MDFLD_P1_MASK;\r\nREG_WRITE(map->dpll, dpll);\r\nudelay(500);\r\n}\r\nif (dpll & MDFLD_PWR_GATE_EN) {\r\ndpll &= ~MDFLD_PWR_GATE_EN;\r\nREG_WRITE(map->dpll, dpll);\r\nudelay(500);\r\n}\r\ndpll = 0;\r\n#if 0\r\nif (ksel == KSEL_CRYSTAL_19 || ksel == KSEL_BYPASS_19 ||\r\nksel == KSEL_BYPASS_25)\r\ndpll &= ~MDFLD_INPUT_REF_SEL;\r\nelse if (ksel == KSEL_BYPASS_83_100)\r\ndpll |= MDFLD_INPUT_REF_SEL;\r\n#endif\r\nif (is_hdmi)\r\ndpll |= MDFLD_VCO_SEL;\r\nfp = (clk_n / 2) << 16;\r\nfp |= m_conv;\r\ndpll |= (1 << (clock.p1 - 2)) << 17;\r\n#if 0\r\ndpll = 0x00050000;\r\nfp = 0x000001be;\r\n#endif\r\n#if 0\r\ndpll = 0x02010000;\r\nfp = 0x000000d2;\r\n#endif\r\n} else {\r\n#if 0\r\ndpll = 0x00020000;\r\nfp = 0x00000156;\r\n#endif\r\ndpll = 0x00800000;\r\nfp = 0x000000c1;\r\n}\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll);\r\nudelay(500);\r\ndpll |= DPLL_VCO_ENABLE;\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nwhile (timeout < 20000 &&\r\n!(REG_READ(map->conf) & PIPECONF_DSIPLL_LOCK)) {\r\nudelay(150);\r\ntimeout++;\r\n}\r\nif (is_mipi)\r\ngoto mrst_crtc_mode_set_exit;\r\ndev_dbg(dev->dev, "is_mipi = 0x%x\n", is_mipi);\r\nREG_WRITE(map->conf, dev_priv->pipeconf[pipe]);\r\nREG_READ(map->conf);\r\nREG_WRITE(map->cntr, dev_priv->dspcntr[pipe]);\r\ngma_wait_for_vblank(dev);\r\nmrst_crtc_mode_set_exit:\r\ngma_power_end(dev);\r\nreturn 0;\r\n}
