static int\r\nsctp_conn_schedule(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct net *net;\r\nstruct ip_vs_service *svc;\r\nstruct netns_ipvs *ipvs;\r\nsctp_chunkhdr_t _schunkh, *sch;\r\nsctp_sctphdr_t *sh, _sctph;\r\nsh = skb_header_pointer(skb, iph->len, sizeof(_sctph), &_sctph);\r\nif (sh == NULL) {\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\nsch = skb_header_pointer(skb, iph->len + sizeof(sctp_sctphdr_t),\r\nsizeof(_schunkh), &_schunkh);\r\nif (sch == NULL) {\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\nnet = skb_net(skb);\r\nipvs = net_ipvs(net);\r\nrcu_read_lock();\r\nif ((sch->type == SCTP_CID_INIT || sysctl_sloppy_sctp(ipvs)) &&\r\n(svc = ip_vs_service_find(net, af, skb->mark, iph->protocol,\r\n&iph->daddr, sh->dest))) {\r\nint ignored;\r\nif (ip_vs_todrop(ipvs)) {\r\nrcu_read_unlock();\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\n*cpp = ip_vs_schedule(svc, skb, pd, &ignored, iph);\r\nif (!*cpp && ignored <= 0) {\r\nif (!ignored)\r\n*verdict = ip_vs_leave(svc, skb, pd, iph);\r\nelse\r\n*verdict = NF_DROP;\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\nstatic void sctp_nat_csum(struct sk_buff *skb, sctp_sctphdr_t *sctph,\r\nunsigned int sctphoff)\r\n{\r\nsctph->checksum = sctp_compute_cksum(skb, sctphoff);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nstatic int\r\nsctp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\r\n{\r\nsctp_sctphdr_t *sctph;\r\nunsigned int sctphoff = iph->len;\r\nbool payload_csum = false;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6 && iph->fragoffs)\r\nreturn 1;\r\n#endif\r\nif (!skb_make_writable(skb, sctphoff + sizeof(*sctph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nret = ip_vs_app_pkt_out(cp, skb);\r\nif (ret == 0)\r\nreturn 0;\r\nif (ret == 2)\r\npayload_csum = true;\r\n}\r\nsctph = (void *) skb_network_header(skb) + sctphoff;\r\nif (sctph->source != cp->vport || payload_csum ||\r\nskb->ip_summed == CHECKSUM_PARTIAL) {\r\nsctph->source = cp->vport;\r\nsctp_nat_csum(skb, sctph, sctphoff);\r\n} else {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nsctp_dnat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\r\n{\r\nsctp_sctphdr_t *sctph;\r\nunsigned int sctphoff = iph->len;\r\nbool payload_csum = false;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6 && iph->fragoffs)\r\nreturn 1;\r\n#endif\r\nif (!skb_make_writable(skb, sctphoff + sizeof(*sctph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nret = ip_vs_app_pkt_in(cp, skb);\r\nif (ret == 0)\r\nreturn 0;\r\nif (ret == 2)\r\npayload_csum = true;\r\n}\r\nsctph = (void *) skb_network_header(skb) + sctphoff;\r\nif (sctph->dest != cp->dport || payload_csum ||\r\n(skb->ip_summed == CHECKSUM_PARTIAL &&\r\n!(skb_dst(skb)->dev->features & NETIF_F_SCTP_CSUM))) {\r\nsctph->dest = cp->dport;\r\nsctp_nat_csum(skb, sctph, sctphoff);\r\n} else if (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nsctp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\r\n{\r\nunsigned int sctphoff;\r\nstruct sctphdr *sh, _sctph;\r\n__le32 cmp, val;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nsctphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\nsctphoff = ip_hdrlen(skb);\r\nsh = skb_header_pointer(skb, sctphoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\nreturn 0;\r\ncmp = sh->checksum;\r\nval = sctp_compute_cksum(skb, sctphoff);\r\nif (val != cmp) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic const char *sctp_state_name(int state)\r\n{\r\nif (state >= IP_VS_SCTP_S_LAST)\r\nreturn "ERR!";\r\nif (sctp_state_name_table[state])\r\nreturn sctp_state_name_table[state];\r\nreturn "?";\r\n}\r\nstatic inline void\r\nset_sctp_state(struct ip_vs_proto_data *pd, struct ip_vs_conn *cp,\r\nint direction, const struct sk_buff *skb)\r\n{\r\nsctp_chunkhdr_t _sctpch, *sch;\r\nunsigned char chunk_type;\r\nint event, next_state;\r\nint ihl, cofs;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nihl = cp->af == AF_INET ? ip_hdrlen(skb) : sizeof(struct ipv6hdr);\r\n#else\r\nihl = ip_hdrlen(skb);\r\n#endif\r\ncofs = ihl + sizeof(sctp_sctphdr_t);\r\nsch = skb_header_pointer(skb, cofs, sizeof(_sctpch), &_sctpch);\r\nif (sch == NULL)\r\nreturn;\r\nchunk_type = sch->type;\r\nif ((sch->type == SCTP_CID_COOKIE_ECHO) ||\r\n(sch->type == SCTP_CID_COOKIE_ACK)) {\r\nint clen = ntohs(sch->length);\r\nif (clen >= sizeof(sctp_chunkhdr_t)) {\r\nsch = skb_header_pointer(skb, cofs + ALIGN(clen, 4),\r\nsizeof(_sctpch), &_sctpch);\r\nif (sch && sch->type == SCTP_CID_ABORT)\r\nchunk_type = sch->type;\r\n}\r\n}\r\nevent = (chunk_type < sizeof(sctp_events)) ?\r\nsctp_events[chunk_type] : IP_VS_SCTP_DATA;\r\nif (cp->flags & IP_VS_CONN_F_NOOUTPUT) {\r\nif (direction == IP_VS_DIR_OUTPUT)\r\ncp->flags &= ~IP_VS_CONN_F_NOOUTPUT;\r\nelse\r\ndirection = IP_VS_DIR_INPUT_ONLY;\r\n}\r\nnext_state = sctp_states[direction][event][cp->state];\r\nif (next_state != cp->state) {\r\nstruct ip_vs_dest *dest = cp->dest;\r\nIP_VS_DBG_BUF(8, "%s %s %s:%d->"\r\n"%s:%d state: %s->%s conn->refcnt:%d\n",\r\npd->pp->name,\r\n((direction == IP_VS_DIR_OUTPUT) ?\r\n"output " : "input "),\r\nIP_VS_DBG_ADDR(cp->af, &cp->daddr),\r\nntohs(cp->dport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nsctp_state_name(cp->state),\r\nsctp_state_name(next_state),\r\natomic_read(&cp->refcnt));\r\nif (dest) {\r\nif (!(cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(next_state != IP_VS_SCTP_S_ESTABLISHED)) {\r\natomic_dec(&dest->activeconns);\r\natomic_inc(&dest->inactconns);\r\ncp->flags |= IP_VS_CONN_F_INACTIVE;\r\n} else if ((cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(next_state == IP_VS_SCTP_S_ESTABLISHED)) {\r\natomic_inc(&dest->activeconns);\r\natomic_dec(&dest->inactconns);\r\ncp->flags &= ~IP_VS_CONN_F_INACTIVE;\r\n}\r\n}\r\n}\r\nif (likely(pd))\r\ncp->timeout = pd->timeout_table[cp->state = next_state];\r\nelse\r\ncp->timeout = sctp_timeouts[cp->state = next_state];\r\n}\r\nstatic void\r\nsctp_state_transition(struct ip_vs_conn *cp, int direction,\r\nconst struct sk_buff *skb, struct ip_vs_proto_data *pd)\r\n{\r\nspin_lock_bh(&cp->lock);\r\nset_sctp_state(pd, cp, direction, skb);\r\nspin_unlock_bh(&cp->lock);\r\n}\r\nstatic inline __u16 sctp_app_hashkey(__be16 port)\r\n{\r\nreturn (((__force u16)port >> SCTP_APP_TAB_BITS) ^ (__force u16)port)\r\n& SCTP_APP_TAB_MASK;\r\n}\r\nstatic int sctp_register_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_app *i;\r\n__u16 hash;\r\n__be16 port = inc->port;\r\nint ret = 0;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_SCTP);\r\nhash = sctp_app_hashkey(port);\r\nlist_for_each_entry(i, &ipvs->sctp_apps[hash], p_list) {\r\nif (i->port == port) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add_rcu(&inc->p_list, &ipvs->sctp_apps[hash]);\r\natomic_inc(&pd->appcnt);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void sctp_unregister_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_SCTP);\r\natomic_dec(&pd->appcnt);\r\nlist_del_rcu(&inc->p_list);\r\n}\r\nstatic int sctp_app_conn_bind(struct ip_vs_conn *cp)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(cp));\r\nint hash;\r\nstruct ip_vs_app *inc;\r\nint result = 0;\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\r\nreturn 0;\r\nhash = sctp_app_hashkey(cp->vport);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(inc, &ipvs->sctp_apps[hash], p_list) {\r\nif (inc->port == cp->vport) {\r\nif (unlikely(!ip_vs_app_inc_get(inc)))\r\nbreak;\r\nrcu_read_unlock();\r\nIP_VS_DBG_BUF(9, "%s: Binding conn %s:%u->"\r\n"%s:%u to app %s on port %u\n",\r\n__func__,\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr),\r\nntohs(cp->vport),\r\ninc->name, ntohs(inc->port));\r\ncp->app = inc;\r\nif (inc->init_conn)\r\nresult = inc->init_conn(inc, cp);\r\ngoto out;\r\n}\r\n}\r\nrcu_read_unlock();\r\nout:\r\nreturn result;\r\n}\r\nstatic int __ip_vs_sctp_init(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nip_vs_init_hash_table(ipvs->sctp_apps, SCTP_APP_TAB_SIZE);\r\npd->timeout_table = ip_vs_create_timeout_table((int *)sctp_timeouts,\r\nsizeof(sctp_timeouts));\r\nif (!pd->timeout_table)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __ip_vs_sctp_exit(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nkfree(pd->timeout_table);\r\n}
