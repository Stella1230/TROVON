static irqreturn_t wm831x_ldo_uv_irq(int irq, void *data)\r\n{\r\nstruct wm831x_ldo *ldo = data;\r\nregulator_notifier_call_chain(ldo->regulator,\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm831x_gp_ldo_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint sel, reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;\r\nsel = regulator_map_voltage_linear_range(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_LDO1_ON_VSEL_MASK, sel);\r\n}\r\nstatic unsigned int wm831x_gp_ldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint ctrl_reg = ldo->base + WM831X_LDO_CONTROL;\r\nint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, on_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & WM831X_LDO1_ON_MODE))\r\nreturn REGULATOR_MODE_NORMAL;\r\nret = wm831x_reg_read(wm831x, ctrl_reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & WM831X_LDO1_LP_MODE)\r\nreturn REGULATOR_MODE_STANDBY;\r\nelse\r\nreturn REGULATOR_MODE_IDLE;\r\n}\r\nstatic int wm831x_gp_ldo_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint ctrl_reg = ldo->base + WM831X_LDO_CONTROL;\r\nint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nint ret;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nret = wm831x_set_bits(wm831x, on_reg,\r\nWM831X_LDO1_ON_MODE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nret = wm831x_set_bits(wm831x, ctrl_reg,\r\nWM831X_LDO1_LP_MODE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm831x_set_bits(wm831x, on_reg,\r\nWM831X_LDO1_ON_MODE,\r\nWM831X_LDO1_ON_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nret = wm831x_set_bits(wm831x, ctrl_reg,\r\nWM831X_LDO1_LP_MODE,\r\nWM831X_LDO1_LP_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = wm831x_set_bits(wm831x, on_reg,\r\nWM831X_LDO1_ON_MODE,\r\nWM831X_LDO1_ON_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm831x_gp_ldo_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & mask))\r\nreturn REGULATOR_STATUS_OFF;\r\nret = wm831x_reg_read(wm831x, WM831X_LDO_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & mask)\r\nreturn REGULATOR_STATUS_ERROR;\r\nret = wm831x_gp_ldo_get_mode(rdev);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn regulator_mode_to_status(ret);\r\n}\r\nstatic unsigned int wm831x_gp_ldo_get_optimum_mode(struct regulator_dev *rdev,\r\nint input_uV,\r\nint output_uV, int load_uA)\r\n{\r\nif (load_uA < 20000)\r\nreturn REGULATOR_MODE_STANDBY;\r\nif (load_uA < 50000)\r\nreturn REGULATOR_MODE_IDLE;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int wm831x_gp_ldo_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id;\r\nstruct wm831x_ldo *ldo;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);\r\nldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\r\nif (ldo == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nldo->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nldo->base = res->start;\r\nsnprintf(ldo->name, sizeof(ldo->name), "LDO%d", id + 1);\r\nldo->desc.name = ldo->name;\r\nsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\r\n"LDO%dVDD", id + 1);\r\nldo->desc.supply_name = ldo->supply_name;\r\nldo->desc.id = id;\r\nldo->desc.type = REGULATOR_VOLTAGE;\r\nldo->desc.n_voltages = 32;\r\nldo->desc.ops = &wm831x_gp_ldo_ops;\r\nldo->desc.owner = THIS_MODULE;\r\nldo->desc.vsel_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nldo->desc.vsel_mask = WM831X_LDO1_ON_VSEL_MASK;\r\nldo->desc.enable_reg = WM831X_LDO_ENABLE;\r\nldo->desc.enable_mask = 1 << id;\r\nldo->desc.bypass_reg = ldo->base;\r\nldo->desc.bypass_mask = WM831X_LDO1_SWI;\r\nldo->desc.linear_ranges = wm831x_gp_ldo_ranges;\r\nldo->desc.n_linear_ranges = ARRAY_SIZE(wm831x_gp_ldo_ranges);\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->ldo[id];\r\nconfig.driver_data = ldo;\r\nconfig.regmap = wm831x->regmap;\r\nldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\r\n&config);\r\nif (IS_ERR(ldo->regulator)) {\r\nret = PTR_ERR(ldo->regulator);\r\ndev_err(wm831x->dev, "Failed to register LDO%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "UV"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_ldo_uv_irq,\r\nIRQF_TRIGGER_RISING, ldo->name,\r\nldo);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, ldo);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm831x_aldo_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint sel, reg = ldo->base + WM831X_LDO_SLEEP_CONTROL;\r\nsel = regulator_map_voltage_linear_range(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_LDO7_ON_VSEL_MASK, sel);\r\n}\r\nstatic unsigned int wm831x_aldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nint ret;\r\nret = wm831x_reg_read(wm831x, on_reg);\r\nif (ret < 0)\r\nreturn 0;\r\nif (ret & WM831X_LDO7_ON_MODE)\r\nreturn REGULATOR_MODE_IDLE;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int wm831x_aldo_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint on_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nint ret;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nret = wm831x_set_bits(wm831x, on_reg, WM831X_LDO7_ON_MODE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nret = wm831x_set_bits(wm831x, on_reg, WM831X_LDO7_ON_MODE,\r\nWM831X_LDO7_ON_MODE);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm831x_aldo_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & mask))\r\nreturn REGULATOR_STATUS_OFF;\r\nret = wm831x_reg_read(wm831x, WM831X_LDO_UV_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & mask)\r\nreturn REGULATOR_STATUS_ERROR;\r\nret = wm831x_aldo_get_mode(rdev);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn regulator_mode_to_status(ret);\r\n}\r\nstatic int wm831x_aldo_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id;\r\nstruct wm831x_ldo *ldo;\r\nstruct resource *res;\r\nint ret, irq;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);\r\nldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\r\nif (ldo == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nldo->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nldo->base = res->start;\r\nsnprintf(ldo->name, sizeof(ldo->name), "LDO%d", id + 1);\r\nldo->desc.name = ldo->name;\r\nsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\r\n"LDO%dVDD", id + 1);\r\nldo->desc.supply_name = ldo->supply_name;\r\nldo->desc.id = id;\r\nldo->desc.type = REGULATOR_VOLTAGE;\r\nldo->desc.n_voltages = 32;\r\nldo->desc.linear_ranges = wm831x_aldo_ranges;\r\nldo->desc.n_linear_ranges = ARRAY_SIZE(wm831x_aldo_ranges);\r\nldo->desc.ops = &wm831x_aldo_ops;\r\nldo->desc.owner = THIS_MODULE;\r\nldo->desc.vsel_reg = ldo->base + WM831X_LDO_ON_CONTROL;\r\nldo->desc.vsel_mask = WM831X_LDO7_ON_VSEL_MASK;\r\nldo->desc.enable_reg = WM831X_LDO_ENABLE;\r\nldo->desc.enable_mask = 1 << id;\r\nldo->desc.bypass_reg = ldo->base;\r\nldo->desc.bypass_mask = WM831X_LDO7_SWI;\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->ldo[id];\r\nconfig.driver_data = ldo;\r\nconfig.regmap = wm831x->regmap;\r\nldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\r\n&config);\r\nif (IS_ERR(ldo->regulator)) {\r\nret = PTR_ERR(ldo->regulator);\r\ndev_err(wm831x->dev, "Failed to register LDO%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nirq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "UV"));\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nwm831x_ldo_uv_irq,\r\nIRQF_TRIGGER_RISING, ldo->name, ldo);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request UV IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, ldo);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm831x_alive_ldo_set_suspend_voltage(struct regulator_dev *rdev,\r\nint uV)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint sel, reg = ldo->base + WM831X_ALIVE_LDO_SLEEP_CONTROL;\r\nsel = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nreturn wm831x_set_bits(wm831x, reg, WM831X_LDO11_ON_VSEL_MASK, sel);\r\n}\r\nstatic int wm831x_alive_ldo_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct wm831x_ldo *ldo = rdev_get_drvdata(rdev);\r\nstruct wm831x *wm831x = ldo->wm831x;\r\nint mask = 1 << rdev_get_id(rdev);\r\nint ret;\r\nret = wm831x_reg_read(wm831x, WM831X_LDO_STATUS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & mask)\r\nreturn REGULATOR_STATUS_ON;\r\nelse\r\nreturn REGULATOR_STATUS_OFF;\r\n}\r\nstatic int wm831x_alive_ldo_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *pdata = dev_get_platdata(wm831x->dev);\r\nstruct regulator_config config = { };\r\nint id;\r\nstruct wm831x_ldo *ldo;\r\nstruct resource *res;\r\nint ret;\r\nif (pdata && pdata->wm831x_num)\r\nid = (pdata->wm831x_num * 10) + 1;\r\nelse\r\nid = 0;\r\nid = pdev->id - id;\r\ndev_dbg(&pdev->dev, "Probing LDO%d\n", id + 1);\r\nldo = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_ldo), GFP_KERNEL);\r\nif (ldo == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nldo->wm831x = wm831x;\r\nres = platform_get_resource(pdev, IORESOURCE_REG, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No REG resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nldo->base = res->start;\r\nsnprintf(ldo->name, sizeof(ldo->name), "LDO%d", id + 1);\r\nldo->desc.name = ldo->name;\r\nsnprintf(ldo->supply_name, sizeof(ldo->supply_name),\r\n"LDO%dVDD", id + 1);\r\nldo->desc.supply_name = ldo->supply_name;\r\nldo->desc.id = id;\r\nldo->desc.type = REGULATOR_VOLTAGE;\r\nldo->desc.n_voltages = WM831X_ALIVE_LDO_MAX_SELECTOR + 1;\r\nldo->desc.ops = &wm831x_alive_ldo_ops;\r\nldo->desc.owner = THIS_MODULE;\r\nldo->desc.vsel_reg = ldo->base + WM831X_ALIVE_LDO_ON_CONTROL;\r\nldo->desc.vsel_mask = WM831X_LDO11_ON_VSEL_MASK;\r\nldo->desc.enable_reg = WM831X_LDO_ENABLE;\r\nldo->desc.enable_mask = 1 << id;\r\nldo->desc.min_uV = 800000;\r\nldo->desc.uV_step = 50000;\r\nldo->desc.enable_time = 1000;\r\nconfig.dev = pdev->dev.parent;\r\nif (pdata)\r\nconfig.init_data = pdata->ldo[id];\r\nconfig.driver_data = ldo;\r\nconfig.regmap = wm831x->regmap;\r\nldo->regulator = devm_regulator_register(&pdev->dev, &ldo->desc,\r\n&config);\r\nif (IS_ERR(ldo->regulator)) {\r\nret = PTR_ERR(ldo->regulator);\r\ndev_err(wm831x->dev, "Failed to register LDO%d: %d\n",\r\nid + 1, ret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, ldo);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __init wm831x_ldo_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&wm831x_gp_ldo_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x GP LDO driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_aldo_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x ALDO driver: %d\n", ret);\r\nret = platform_driver_register(&wm831x_alive_ldo_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM831x alive LDO driver: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nstatic void __exit wm831x_ldo_exit(void)\r\n{\r\nplatform_driver_unregister(&wm831x_alive_ldo_driver);\r\nplatform_driver_unregister(&wm831x_aldo_driver);\r\nplatform_driver_unregister(&wm831x_gp_ldo_driver);\r\n}
