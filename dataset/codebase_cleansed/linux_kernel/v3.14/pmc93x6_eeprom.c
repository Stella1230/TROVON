static void\r\nBuildByteReverse (void)\r\n{\r\nlong half;\r\nint i;\r\nByteReverse[0] = 0;\r\nfor (half = 1; half < sizeof (ByteReverse); half <<= 1)\r\nfor (i = 0; i < half; i++)\r\nByteReverse[half + i] = (char) (ByteReverse[i] | (0x80 / half));\r\nByteReverseBuilt = TRUE;\r\n}\r\nstatic void\r\neeprom_delay (void)\r\n{\r\nint timeout;\r\nfor (timeout = 20; timeout; --timeout)\r\n{\r\nOS_uwait_dummy ();\r\n}\r\n}\r\nvoid\r\neeprom_put_byte (long addr, long data, int count)\r\n{\r\nu_int32_t output;\r\nwhile (--count >= 0)\r\n{\r\noutput = (data & EPROM_ACTIVE_OUT_BIT) ? 1 : 0;\r\noutput |= EPROM_ENCS;\r\ndata >>= 1;\r\neeprom_delay ();\r\npci_write_32 ((u_int32_t *) addr, output);\r\n}\r\n}\r\nu_int32_t\r\neeprom_get_byte (long addr)\r\n{\r\nu_int32_t input;\r\nu_int32_t data;\r\nint count;\r\ninput = pci_read_32 ((u_int32_t *) addr);\r\ndata = 0;\r\ncount = NUM_OF_BITS;\r\nwhile (--count >= 0)\r\n{\r\neeprom_delay ();\r\ninput = pci_read_32 ((u_int32_t *) addr);\r\ndata <<= 1;\r\ndata |= (input & EPROM_ACTIVE_IN_BIT) ? 1 : 0;\r\n}\r\nreturn data;\r\n}\r\nstatic void\r\ndisable_pmc_eeprom (long addr)\r\n{\r\neeprom_put_byte (addr, EPROM_EWDS, SIZE_ADDR_OP);\r\npci_write_32 ((u_int32_t *) addr, 0);\r\n}\r\nstatic void\r\nenable_pmc_eeprom (long addr)\r\n{\r\neeprom_put_byte (addr, EPROM_EWEN, SIZE_ADDR_OP);\r\npci_write_32 ((u_int32_t *) addr, 0);\r\n}\r\nu_int32_t\r\npmc_eeprom_read (long addr, long mem_offset)\r\n{\r\nu_int32_t data;\r\nif (!ByteReverseBuilt)\r\nBuildByteReverse ();\r\nmem_offset = ByteReverse[0x7F & mem_offset];\r\nmem_offset <<= 2;\r\nmem_offset |= EPROM_READ;\r\neeprom_put_byte (addr, mem_offset, SIZE_ADDR_OP);\r\ndata = eeprom_get_byte (addr);\r\npci_write_32 ((u_int32_t *) addr, 0);\r\nreturn (data & 0x000000FF);\r\n}\r\nint\r\npmc_eeprom_write (long addr, long mem_offset, u_int32_t data)\r\n{\r\nvolatile u_int32_t temp;\r\nint count;\r\nif (!ByteReverseBuilt)\r\nBuildByteReverse ();\r\nmem_offset = ByteReverse[0x7F & mem_offset];\r\nmem_offset <<= 2;\r\nmem_offset |= EPROM_WRITE;\r\neeprom_put_byte (addr, mem_offset, SIZE_ADDR_OP);\r\ndata = ByteReverse[0xFF & data];\r\neeprom_put_byte (addr, data, NUM_OF_BITS);\r\npci_write_32 ((u_int32_t *) addr, 0);\r\npci_write_32 ((u_int32_t *) addr, EPROM_ENCS);\r\ntemp = pci_read_32 ((u_int32_t *) addr);\r\ntemp = pci_read_32 ((u_int32_t *) addr);\r\nif (temp & EPROM_ACTIVE_IN_BIT)\r\n{\r\ntemp = pci_read_32 ((u_int32_t *) addr);\r\nif (temp & EPROM_ACTIVE_IN_BIT)\r\n{\r\npci_write_32 ((u_int32_t *) addr, 0);\r\nreturn (1);\r\n}\r\n}\r\ncount = 1000;\r\nwhile (count--)\r\n{\r\nfor (temp = 0; temp < 0x10; temp++)\r\nOS_uwait_dummy ();\r\nif (pci_read_32 ((u_int32_t *) addr) & EPROM_ACTIVE_IN_BIT)\r\nbreak;\r\n}\r\nif (count == -1)\r\nreturn (2);\r\nreturn (0);\r\n}\r\nlong\r\npmcGetBuffValue (char *ptr, int size)\r\n{\r\nlong value = 0;\r\nint index;\r\nfor (index = 0; index < size; ++index)\r\n{\r\nvalue <<= 8;\r\nvalue |= ptr[index] & 0xFF;\r\n}\r\nreturn value;\r\n}\r\nvoid\r\npmcSetBuffValue (char *ptr, long value, int size)\r\n{\r\nint index = size;\r\nwhile (--index >= 0)\r\n{\r\nptr[index] = (char) (value & 0xFF);\r\nvalue >>= 8;\r\n}\r\n}\r\nvoid\r\npmc_eeprom_read_buffer (long addr, long mem_offset, char *dest_ptr, int size)\r\n{\r\nwhile (--size >= 0)\r\n*dest_ptr++ = (char) pmc_eeprom_read (addr, mem_offset++);\r\n}\r\nvoid\r\npmc_eeprom_write_buffer (long addr, long mem_offset, char *dest_ptr, int size)\r\n{\r\nenable_pmc_eeprom (addr);\r\nwhile (--size >= 0)\r\npmc_eeprom_write (addr, mem_offset++, *dest_ptr++);\r\ndisable_pmc_eeprom (addr);\r\n}\r\nu_int32_t\r\npmcCalcCrc_T01 (void *bufp)\r\n{\r\nFLD_TYPE2 *buf = bufp;\r\nu_int32_t crc;\r\nsbeCrc (\r\n(u_int8_t *) &buf->type,\r\n(u_int32_t) STRUCT_OFFSET (FLD_TYPE1, Crc32),\r\n(u_int32_t) 0,\r\n(u_int32_t *) &crc);\r\n#ifdef EEPROM_TYPE_DEBUG\r\npr_info("sbeCrc: crc 1 calculated as %08x\n", crc);\r\n#endif\r\nreturn ~crc;\r\n}\r\nu_int32_t\r\npmcCalcCrc_T02 (void *bufp)\r\n{\r\nFLD_TYPE2 *buf = bufp;\r\nu_int32_t crc;\r\nsbeCrc (\r\n(u_int8_t *) &buf->type,\r\n(u_int32_t) STRUCT_OFFSET (FLD_TYPE2, Crc32),\r\n(u_int32_t) 0,\r\n(u_int32_t *) &crc);\r\nsbeCrc (\r\n(u_int8_t *) &buf->Id[0],\r\n(u_int32_t) (sizeof (FLD_TYPE2) - STRUCT_OFFSET (FLD_TYPE2, Id)),\r\n(u_int32_t) crc,\r\n(u_int32_t *) &crc);\r\n#ifdef EEPROM_TYPE_DEBUG\r\npr_info("sbeCrc: crc 2 calculated as %08x\n", crc);\r\n#endif\r\nreturn crc;\r\n}\r\nvoid\r\npmc_init_seeprom (u_int32_t addr, u_int32_t serialNum)\r\n{\r\nPROMFORMAT buffer;\r\nu_int32_t crc;\r\ntime_t createTime;\r\nint i;\r\ncreateTime = get_seconds ();\r\nfor (i = 0; i < sizeof (FLD_TYPE2); ++i)\r\nbuffer.bytes[i] = mfg_template[i];\r\npmcSetBuffValue (&buffer.fldType2.Serial[3], serialNum, 3);\r\npmcSetBuffValue (&buffer.fldType2.CreateTime[0], createTime, 4);\r\ncrc = pmcCalcCrc_T02 (&buffer);\r\npmcSetBuffValue (&buffer.fldType2.Crc32[0], crc, 4);\r\n#ifdef DEBUG\r\nfor (i = 0; i < sizeof (FLD_TYPE2); ++i)\r\npr_info("[%02X] = %02X\n", i, buffer.bytes[i] & 0xFF);\r\n#endif\r\npmc_eeprom_write_buffer (addr, EE_MFG, (char *) &buffer, sizeof (FLD_TYPE2));\r\n}\r\nchar\r\npmc_verify_cksum (void *bufp)\r\n{\r\nFLD_TYPE1 *buf1 = bufp;\r\nFLD_TYPE2 *buf2 = bufp;\r\nu_int32_t crc1, crc2;\r\ncrc1 = pmcGetBuffValue (&buf1->Crc32[0], sizeof (buf1->Crc32));\r\n#ifdef EEPROM_TYPE_DEBUG\r\npr_info("EEPROM: chksum 1 reads as %08x\n", crc1);\r\n#endif\r\nif ((buf1->type == PROM_FORMAT_TYPE1) &&\r\n(pmcCalcCrc_T01 ((void *) buf1) == crc1))\r\nreturn PROM_FORMAT_TYPE1;\r\ncrc2 = pmcGetBuffValue (&buf2->Crc32[0], sizeof (buf2->Crc32));\r\n#ifdef EEPROM_TYPE_DEBUG\r\npr_info("EEPROM: chksum 2 reads as %08x\n", crc2);\r\n#endif\r\nif ((buf2->type == PROM_FORMAT_TYPE2) &&\r\n(pmcCalcCrc_T02 ((void *) buf2) == crc2))\r\nreturn PROM_FORMAT_TYPE2;\r\nreturn PROM_FORMAT_Unk;\r\n}
