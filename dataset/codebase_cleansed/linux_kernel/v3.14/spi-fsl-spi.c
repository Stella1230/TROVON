static int fsl_spi_get_type(struct device *dev)\r\n{\r\nconst struct of_device_id *match;\r\nif (dev->of_node) {\r\nmatch = of_match_node(of_fsl_spi_match, dev->of_node);\r\nif (match && match->data)\r\nreturn ((struct fsl_spi_match_data *)match->data)->type;\r\n}\r\nreturn TYPE_FSL;\r\n}\r\nstatic void fsl_spi_change_mode(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\n__be32 __iomem *mode = &reg_base->mode;\r\nunsigned long flags;\r\nif (cs->hw_mode == mpc8xxx_spi_read_reg(mode))\r\nreturn;\r\nlocal_irq_save(flags);\r\nmpc8xxx_spi_write_reg(mode, cs->hw_mode & ~SPMODE_ENABLE);\r\nif (mspi->flags & SPI_CPM_MODE) {\r\nfsl_spi_cpm_reinit_txrx(mspi);\r\n}\r\nmpc8xxx_spi_write_reg(mode, cs->hw_mode);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void fsl_spi_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_spi_platform_data *pdata;\r\nbool pol = spi->mode & SPI_CS_HIGH;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\npdata = spi->dev.parent->parent->platform_data;\r\nif (value == BITBANG_CS_INACTIVE) {\r\nif (pdata->cs_control)\r\npdata->cs_control(spi, !pol);\r\n}\r\nif (value == BITBANG_CS_ACTIVE) {\r\nmpc8xxx_spi->rx_shift = cs->rx_shift;\r\nmpc8xxx_spi->tx_shift = cs->tx_shift;\r\nmpc8xxx_spi->get_rx = cs->get_rx;\r\nmpc8xxx_spi->get_tx = cs->get_tx;\r\nfsl_spi_change_mode(spi);\r\nif (pdata->cs_control)\r\npdata->cs_control(spi, pol);\r\n}\r\n}\r\nstatic void fsl_spi_qe_cpu_set_shifts(u32 *rx_shift, u32 *tx_shift,\r\nint bits_per_word, int msb_first)\r\n{\r\n*rx_shift = 0;\r\n*tx_shift = 0;\r\nif (msb_first) {\r\nif (bits_per_word <= 8) {\r\n*rx_shift = 16;\r\n*tx_shift = 24;\r\n} else if (bits_per_word <= 16) {\r\n*rx_shift = 16;\r\n*tx_shift = 16;\r\n}\r\n} else {\r\nif (bits_per_word <= 8)\r\n*rx_shift = 8;\r\n}\r\n}\r\nstatic void fsl_spi_grlib_set_shifts(u32 *rx_shift, u32 *tx_shift,\r\nint bits_per_word, int msb_first)\r\n{\r\n*rx_shift = 0;\r\n*tx_shift = 0;\r\nif (bits_per_word <= 16) {\r\nif (msb_first) {\r\n*rx_shift = 16;\r\n*tx_shift = 32 - bits_per_word;\r\n} else {\r\n*rx_shift = 16 - bits_per_word;\r\n}\r\n}\r\n}\r\nstatic int mspi_apply_cpu_mode_quirks(struct spi_mpc8xxx_cs *cs,\r\nstruct spi_device *spi,\r\nstruct mpc8xxx_spi *mpc8xxx_spi,\r\nint bits_per_word)\r\n{\r\ncs->rx_shift = 0;\r\ncs->tx_shift = 0;\r\nif (bits_per_word <= 8) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u8;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u8;\r\n} else if (bits_per_word <= 16) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u16;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u16;\r\n} else if (bits_per_word <= 32) {\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u32;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u32;\r\n} else\r\nreturn -EINVAL;\r\nif (mpc8xxx_spi->set_shifts)\r\nmpc8xxx_spi->set_shifts(&cs->rx_shift, &cs->tx_shift,\r\nbits_per_word,\r\n!(spi->mode & SPI_LSB_FIRST));\r\nmpc8xxx_spi->rx_shift = cs->rx_shift;\r\nmpc8xxx_spi->tx_shift = cs->tx_shift;\r\nmpc8xxx_spi->get_rx = cs->get_rx;\r\nmpc8xxx_spi->get_tx = cs->get_tx;\r\nreturn bits_per_word;\r\n}\r\nstatic int mspi_apply_qe_mode_quirks(struct spi_mpc8xxx_cs *cs,\r\nstruct spi_device *spi,\r\nint bits_per_word)\r\n{\r\nif (spi->mode & SPI_LSB_FIRST &&\r\nbits_per_word > 8)\r\nreturn -EINVAL;\r\nif (bits_per_word > 8)\r\nreturn 8;\r\nreturn bits_per_word;\r\n}\r\nstatic int fsl_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nint bits_per_word = 0;\r\nu8 pm;\r\nu32 hz = 0;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nmpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif ((bits_per_word < 4)\r\n|| ((bits_per_word > 16) && (bits_per_word != 32))\r\n|| (bits_per_word > mpc8xxx_spi->max_bits_per_word))\r\nreturn -EINVAL;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nif (!(mpc8xxx_spi->flags & SPI_CPM_MODE))\r\nbits_per_word = mspi_apply_cpu_mode_quirks(cs, spi,\r\nmpc8xxx_spi,\r\nbits_per_word);\r\nelse if (mpc8xxx_spi->flags & SPI_QE)\r\nbits_per_word = mspi_apply_qe_mode_quirks(cs, spi,\r\nbits_per_word);\r\nif (bits_per_word < 0)\r\nreturn bits_per_word;\r\nif (bits_per_word == 32)\r\nbits_per_word = 0;\r\nelse\r\nbits_per_word = bits_per_word - 1;\r\ncs->hw_mode &= ~(SPMODE_LEN(0xF) | SPMODE_DIV16\r\n| SPMODE_PM(0xF));\r\ncs->hw_mode |= SPMODE_LEN(bits_per_word);\r\nif ((mpc8xxx_spi->spibrg / hz) > 64) {\r\ncs->hw_mode |= SPMODE_DIV16;\r\npm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;\r\nWARN_ONCE(pm > 16, "%s: Requested speed is too low: %d Hz. "\r\n"Will use %d Hz instead.\n", dev_name(&spi->dev),\r\nhz, mpc8xxx_spi->spibrg / 1024);\r\nif (pm > 16)\r\npm = 16;\r\n} else {\r\npm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;\r\n}\r\nif (pm)\r\npm--;\r\ncs->hw_mode |= SPMODE_PM(pm);\r\nfsl_spi_change_mode(spi);\r\nreturn 0;\r\n}\r\nstatic int fsl_spi_cpu_bufs(struct mpc8xxx_spi *mspi,\r\nstruct spi_transfer *t, unsigned int len)\r\n{\r\nu32 word;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nmspi->count = len;\r\nmpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);\r\nword = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\nreturn 0;\r\n}\r\nstatic int fsl_spi_bufs(struct spi_device *spi, struct spi_transfer *t,\r\nbool is_dma_mapped)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_spi_reg *reg_base;\r\nunsigned int len = t->len;\r\nu8 bits_per_word;\r\nint ret;\r\nreg_base = mpc8xxx_spi->reg_base;\r\nbits_per_word = spi->bits_per_word;\r\nif (t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nif (bits_per_word > 8) {\r\nif (len & 1)\r\nreturn -EINVAL;\r\nlen /= 2;\r\n}\r\nif (bits_per_word > 16) {\r\nif (len & 1)\r\nreturn -EINVAL;\r\nlen /= 2;\r\n}\r\nmpc8xxx_spi->tx = t->tx_buf;\r\nmpc8xxx_spi->rx = t->rx_buf;\r\nreinit_completion(&mpc8xxx_spi->done);\r\nif (mpc8xxx_spi->flags & SPI_CPM_MODE)\r\nret = fsl_spi_cpm_bufs(mpc8xxx_spi, t, is_dma_mapped);\r\nelse\r\nret = fsl_spi_cpu_bufs(mpc8xxx_spi, t, len);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&mpc8xxx_spi->done);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nif (mpc8xxx_spi->flags & SPI_CPM_MODE)\r\nfsl_spi_cpm_bufs_complete(mpc8xxx_spi);\r\nreturn mpc8xxx_spi->count;\r\n}\r\nstatic void fsl_spi_do_one_msg(struct spi_message *m)\r\n{\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nunsigned int cs_change;\r\nconst int nsecs = 50;\r\nint status;\r\ncs_change = 1;\r\nstatus = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->bits_per_word || t->speed_hz) {\r\nstatus = -EINVAL;\r\nif (cs_change)\r\nstatus = fsl_spi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (cs_change) {\r\nfsl_spi_chipselect(spi, BITBANG_CS_ACTIVE);\r\nndelay(nsecs);\r\n}\r\ncs_change = t->cs_change;\r\nif (t->len)\r\nstatus = fsl_spi_bufs(spi, t, m->is_dma_mapped);\r\nif (status) {\r\nstatus = -EMSGSIZE;\r\nbreak;\r\n}\r\nm->actual_length += t->len;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (cs_change) {\r\nndelay(nsecs);\r\nfsl_spi_chipselect(spi, BITBANG_CS_INACTIVE);\r\nndelay(nsecs);\r\n}\r\n}\r\nm->status = status;\r\nm->complete(m->context);\r\nif (status || !cs_change) {\r\nndelay(nsecs);\r\nfsl_spi_chipselect(spi, BITBANG_CS_INACTIVE);\r\n}\r\nfsl_spi_setup_transfer(spi, NULL);\r\n}\r\nstatic int fsl_spi_setup(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_spi_reg *reg_base;\r\nint retval;\r\nu32 hw_mode;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\nmpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nreg_base = mpc8xxx_spi->reg_base;\r\nhw_mode = cs->hw_mode;\r\ncs->hw_mode = mpc8xxx_spi_read_reg(&reg_base->mode);\r\ncs->hw_mode &= ~(SPMODE_CP_BEGIN_EDGECLK | SPMODE_CI_INACTIVEHIGH\r\n| SPMODE_REV | SPMODE_LOOP);\r\nif (spi->mode & SPI_CPHA)\r\ncs->hw_mode |= SPMODE_CP_BEGIN_EDGECLK;\r\nif (spi->mode & SPI_CPOL)\r\ncs->hw_mode |= SPMODE_CI_INACTIVEHIGH;\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\ncs->hw_mode |= SPMODE_REV;\r\nif (spi->mode & SPI_LOOP)\r\ncs->hw_mode |= SPMODE_LOOP;\r\nretval = fsl_spi_setup_transfer(spi, NULL);\r\nif (retval < 0) {\r\ncs->hw_mode = hw_mode;\r\nreturn retval;\r\n}\r\nif (mpc8xxx_spi->type == TYPE_GRLIB) {\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nint desel;\r\nretval = gpio_request(spi->cs_gpio,\r\ndev_name(&spi->dev));\r\nif (retval)\r\nreturn retval;\r\ndesel = !(spi->mode & SPI_CS_HIGH);\r\nretval = gpio_direction_output(spi->cs_gpio, desel);\r\nif (retval) {\r\ngpio_free(spi->cs_gpio);\r\nreturn retval;\r\n}\r\n} else if (spi->cs_gpio != -ENOENT) {\r\nif (spi->cs_gpio < 0)\r\nreturn spi->cs_gpio;\r\nreturn -EINVAL;\r\n}\r\n}\r\nfsl_spi_chipselect(spi, BITBANG_CS_INACTIVE);\r\nreturn 0;\r\n}\r\nstatic void fsl_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nif (mpc8xxx_spi->type == TYPE_GRLIB && gpio_is_valid(spi->cs_gpio))\r\ngpio_free(spi->cs_gpio);\r\n}\r\nstatic void fsl_spi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)\r\n{\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nif (events & SPIE_NE) {\r\nu32 rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);\r\nif (mspi->rx)\r\nmspi->get_rx(rx_data, mspi);\r\n}\r\nif ((events & SPIE_NF) == 0)\r\nwhile (((events =\r\nmpc8xxx_spi_read_reg(&reg_base->event)) &\r\nSPIE_NF) == 0)\r\ncpu_relax();\r\nmpc8xxx_spi_write_reg(&reg_base->event, events);\r\nmspi->count -= 1;\r\nif (mspi->count) {\r\nu32 word = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\n} else {\r\ncomplete(&mspi->done);\r\n}\r\n}\r\nstatic irqreturn_t fsl_spi_irq(s32 irq, void *context_data)\r\n{\r\nstruct mpc8xxx_spi *mspi = context_data;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 events;\r\nstruct fsl_spi_reg *reg_base = mspi->reg_base;\r\nevents = mpc8xxx_spi_read_reg(&reg_base->event);\r\nif (events)\r\nret = IRQ_HANDLED;\r\ndev_dbg(mspi->dev, "%s: events %x\n", __func__, events);\r\nif (mspi->flags & SPI_CPM_MODE)\r\nfsl_spi_cpm_irq(mspi, events);\r\nelse\r\nfsl_spi_cpu_irq(mspi, events);\r\nreturn ret;\r\n}\r\nstatic void fsl_spi_remove(struct mpc8xxx_spi *mspi)\r\n{\r\niounmap(mspi->reg_base);\r\nfsl_spi_cpm_free(mspi);\r\n}\r\nstatic void fsl_spi_grlib_cs_control(struct spi_device *spi, bool on)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;\r\nu32 slvsel;\r\nu16 cs = spi->chip_select;\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\ngpio_set_value(spi->cs_gpio, on);\r\n} else if (cs < mpc8xxx_spi->native_chipselects) {\r\nslvsel = mpc8xxx_spi_read_reg(&reg_base->slvsel);\r\nslvsel = on ? (slvsel | (1 << cs)) : (slvsel & ~(1 << cs));\r\nmpc8xxx_spi_write_reg(&reg_base->slvsel, slvsel);\r\n}\r\n}\r\nstatic void fsl_spi_grlib_probe(struct device *dev)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);\r\nstruct fsl_spi_reg *reg_base = mpc8xxx_spi->reg_base;\r\nint mbits;\r\nu32 capabilities;\r\ncapabilities = mpc8xxx_spi_read_reg(&reg_base->cap);\r\nmpc8xxx_spi->set_shifts = fsl_spi_grlib_set_shifts;\r\nmbits = SPCAP_MAXWLEN(capabilities);\r\nif (mbits)\r\nmpc8xxx_spi->max_bits_per_word = mbits + 1;\r\nmpc8xxx_spi->native_chipselects = 0;\r\nif (SPCAP_SSEN(capabilities)) {\r\nmpc8xxx_spi->native_chipselects = SPCAP_SSSZ(capabilities);\r\nmpc8xxx_spi_write_reg(&reg_base->slvsel, 0xffffffff);\r\n}\r\nmaster->num_chipselect = mpc8xxx_spi->native_chipselects;\r\npdata->cs_control = fsl_spi_grlib_cs_control;\r\n}\r\nstatic struct spi_master * fsl_spi_probe(struct device *dev,\r\nstruct resource *mem, unsigned int irq)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct spi_master *master;\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_spi_reg *reg_base;\r\nu32 regval;\r\nint ret = 0;\r\nmaster = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));\r\nif (master == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(dev, master);\r\nret = mpc8xxx_spi_probe(dev, mem, irq);\r\nif (ret)\r\ngoto err_probe;\r\nmaster->setup = fsl_spi_setup;\r\nmaster->cleanup = fsl_spi_cleanup;\r\nmpc8xxx_spi = spi_master_get_devdata(master);\r\nmpc8xxx_spi->spi_do_one_msg = fsl_spi_do_one_msg;\r\nmpc8xxx_spi->spi_remove = fsl_spi_remove;\r\nmpc8xxx_spi->max_bits_per_word = 32;\r\nmpc8xxx_spi->type = fsl_spi_get_type(dev);\r\nret = fsl_spi_cpm_init(mpc8xxx_spi);\r\nif (ret)\r\ngoto err_cpm_init;\r\nmpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));\r\nif (mpc8xxx_spi->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nif (mpc8xxx_spi->type == TYPE_GRLIB)\r\nfsl_spi_grlib_probe(dev);\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)\r\nmpc8xxx_spi->set_shifts = fsl_spi_qe_cpu_set_shifts;\r\nif (mpc8xxx_spi->set_shifts)\r\nmpc8xxx_spi->set_shifts(&mpc8xxx_spi->rx_shift,\r\n&mpc8xxx_spi->tx_shift, 8, 1);\r\nret = request_irq(mpc8xxx_spi->irq, fsl_spi_irq,\r\n0, "fsl_spi", mpc8xxx_spi);\r\nif (ret != 0)\r\ngoto free_irq;\r\nreg_base = mpc8xxx_spi->reg_base;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->command, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);\r\nregval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;\r\nif (mpc8xxx_spi->max_bits_per_word < 8) {\r\nregval &= ~SPMODE_LEN(0xF);\r\nregval |= SPMODE_LEN(mpc8xxx_spi->max_bits_per_word - 1);\r\n}\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE)\r\nregval |= SPMODE_OP;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, regval);\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto unreg_master;\r\ndev_info(dev, "at 0x%p (irq = %d), %s mode\n", reg_base,\r\nmpc8xxx_spi->irq, mpc8xxx_spi_strmode(mpc8xxx_spi->flags));\r\nreturn master;\r\nunreg_master:\r\nfree_irq(mpc8xxx_spi->irq, mpc8xxx_spi);\r\nfree_irq:\r\niounmap(mpc8xxx_spi->reg_base);\r\nerr_ioremap:\r\nfsl_spi_cpm_free(mpc8xxx_spi);\r\nerr_cpm_init:\r\nerr_probe:\r\nspi_master_put(master);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void fsl_spi_cs_control(struct spi_device *spi, bool on)\r\n{\r\nstruct device *dev = spi->dev.parent->parent;\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\r\nu16 cs = spi->chip_select;\r\nint gpio = pinfo->gpios[cs];\r\nbool alow = pinfo->alow_flags[cs];\r\ngpio_set_value(gpio, on ^ alow);\r\n}\r\nstatic int of_fsl_spi_get_chipselects(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\r\nint ngpios;\r\nint i = 0;\r\nint ret;\r\nngpios = of_gpio_count(np);\r\nif (ngpios <= 0) {\r\npdata->max_chipselect = 1;\r\nreturn 0;\r\n}\r\npinfo->gpios = kmalloc(ngpios * sizeof(*pinfo->gpios), GFP_KERNEL);\r\nif (!pinfo->gpios)\r\nreturn -ENOMEM;\r\nmemset(pinfo->gpios, -1, ngpios * sizeof(*pinfo->gpios));\r\npinfo->alow_flags = kzalloc(ngpios * sizeof(*pinfo->alow_flags),\r\nGFP_KERNEL);\r\nif (!pinfo->alow_flags) {\r\nret = -ENOMEM;\r\ngoto err_alloc_flags;\r\n}\r\nfor (; i < ngpios; i++) {\r\nint gpio;\r\nenum of_gpio_flags flags;\r\ngpio = of_get_gpio_flags(np, i, &flags);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(dev, "invalid gpio #%d: %d\n", i, gpio);\r\nret = gpio;\r\ngoto err_loop;\r\n}\r\nret = gpio_request(gpio, dev_name(dev));\r\nif (ret) {\r\ndev_err(dev, "can't request gpio #%d: %d\n", i, ret);\r\ngoto err_loop;\r\n}\r\npinfo->gpios[i] = gpio;\r\npinfo->alow_flags[i] = flags & OF_GPIO_ACTIVE_LOW;\r\nret = gpio_direction_output(pinfo->gpios[i],\r\npinfo->alow_flags[i]);\r\nif (ret) {\r\ndev_err(dev, "can't set output direction for gpio "\r\n"#%d: %d\n", i, ret);\r\ngoto err_loop;\r\n}\r\n}\r\npdata->max_chipselect = ngpios;\r\npdata->cs_control = fsl_spi_cs_control;\r\nreturn 0;\r\nerr_loop:\r\nwhile (i >= 0) {\r\nif (gpio_is_valid(pinfo->gpios[i]))\r\ngpio_free(pinfo->gpios[i]);\r\ni--;\r\n}\r\nkfree(pinfo->alow_flags);\r\npinfo->alow_flags = NULL;\r\nerr_alloc_flags:\r\nkfree(pinfo->gpios);\r\npinfo->gpios = NULL;\r\nreturn ret;\r\n}\r\nstatic int of_fsl_spi_free_chipselects(struct device *dev)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mpc8xxx_spi_probe_info *pinfo = to_of_pinfo(pdata);\r\nint i;\r\nif (!pinfo->gpios)\r\nreturn 0;\r\nfor (i = 0; i < pdata->max_chipselect; i++) {\r\nif (gpio_is_valid(pinfo->gpios[i]))\r\ngpio_free(pinfo->gpios[i]);\r\n}\r\nkfree(pinfo->gpios);\r\nkfree(pinfo->alow_flags);\r\nreturn 0;\r\n}\r\nstatic int of_fsl_spi_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct resource mem;\r\nint irq, type;\r\nint ret = -ENOMEM;\r\nret = of_mpc8xxx_spi_probe(ofdev);\r\nif (ret)\r\nreturn ret;\r\ntype = fsl_spi_get_type(&ofdev->dev);\r\nif (type == TYPE_FSL) {\r\nret = of_fsl_spi_get_chipselects(dev);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = of_address_to_resource(np, 0, &mem);\r\nif (ret)\r\ngoto err;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmaster = fsl_spi_probe(dev, &mem, irq);\r\nif (IS_ERR(master)) {\r\nret = PTR_ERR(master);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nif (type == TYPE_FSL)\r\nof_fsl_spi_free_chipselects(dev);\r\nreturn ret;\r\n}\r\nstatic int of_fsl_spi_remove(struct platform_device *ofdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(ofdev);\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);\r\nint ret;\r\nret = mpc8xxx_spi_remove(&ofdev->dev);\r\nif (ret)\r\nreturn ret;\r\nif (mpc8xxx_spi->type == TYPE_FSL)\r\nof_fsl_spi_free_chipselects(&ofdev->dev);\r\nreturn 0;\r\n}\r\nstatic int plat_mpc8xxx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint irq;\r\nstruct spi_master *master;\r\nif (!dev_get_platdata(&pdev->dev))\r\nreturn -EINVAL;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -EINVAL;\r\nmaster = fsl_spi_probe(&pdev->dev, mem, irq);\r\nreturn PTR_ERR_OR_ZERO(master);\r\n}\r\nstatic int plat_mpc8xxx_spi_remove(struct platform_device *pdev)\r\n{\r\nreturn mpc8xxx_spi_remove(&pdev->dev);\r\n}\r\nstatic void __init legacy_driver_register(void)\r\n{\r\nlegacy_driver_failed = platform_driver_register(&mpc8xxx_spi_driver);\r\n}\r\nstatic void __exit legacy_driver_unregister(void)\r\n{\r\nif (legacy_driver_failed)\r\nreturn;\r\nplatform_driver_unregister(&mpc8xxx_spi_driver);\r\n}\r\nstatic void __init legacy_driver_register(void) {}\r\nstatic void __exit legacy_driver_unregister(void) {}\r\nstatic int __init fsl_spi_init(void)\r\n{\r\nlegacy_driver_register();\r\nreturn platform_driver_register(&of_fsl_spi_driver);\r\n}\r\nstatic void __exit fsl_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&of_fsl_spi_driver);\r\nlegacy_driver_unregister();\r\n}
