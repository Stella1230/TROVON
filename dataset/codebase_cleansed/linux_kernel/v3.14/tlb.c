void flush_tlb_all(void)\r\n{\r\nint i;\r\nunsigned long num_tlb_sets;\r\nnum_tlb_sets = NUM_ITLB_SETS;\r\nfor (i = 0; i < num_tlb_sets; i++) {\r\nmtspr_off(SPR_DTLBMR_BASE(0), i, 0);\r\nmtspr_off(SPR_ITLBMR_BASE(0), i, 0);\r\n}\r\n}\r\nvoid flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)\r\n{\r\nif (have_dtlbeir)\r\nflush_dtlb_page_eir(addr);\r\nelse\r\nflush_dtlb_page_no_eir(addr);\r\nif (have_itlbeir)\r\nflush_itlb_page_eir(addr);\r\nelse\r\nflush_itlb_page_no_eir(addr);\r\n}\r\nvoid flush_tlb_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nint addr;\r\nbool dtlbeir;\r\nbool itlbeir;\r\ndtlbeir = have_dtlbeir;\r\nitlbeir = have_itlbeir;\r\nfor (addr = start; addr < end; addr += PAGE_SIZE) {\r\nif (dtlbeir)\r\nflush_dtlb_page_eir(addr);\r\nelse\r\nflush_dtlb_page_no_eir(addr);\r\nif (itlbeir)\r\nflush_itlb_page_eir(addr);\r\nelse\r\nflush_itlb_page_no_eir(addr);\r\n}\r\n}\r\nvoid flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nflush_tlb_all();\r\n}\r\nvoid switch_mm(struct mm_struct *prev, struct mm_struct *next,\r\nstruct task_struct *next_tsk)\r\n{\r\ncurrent_pgd = next->pgd;\r\nif (prev != next)\r\nflush_tlb_mm(prev);\r\n}\r\nint init_new_context(struct task_struct *tsk, struct mm_struct *mm)\r\n{\r\nmm->context = NO_CONTEXT;\r\nreturn 0;\r\n}\r\nvoid destroy_context(struct mm_struct *mm)\r\n{\r\nflush_tlb_mm(mm);\r\n}\r\nvoid __init tlb_init(void)\r\n{\r\n}
