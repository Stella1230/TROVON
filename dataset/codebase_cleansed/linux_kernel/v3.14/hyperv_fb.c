static inline int synthvid_send(struct hv_device *hdev,\r\nstruct synthvid_msg *msg)\r\n{\r\nstatic atomic64_t request_id = ATOMIC64_INIT(0);\r\nint ret;\r\nmsg->pipe_hdr.type = PIPE_MSG_DATA;\r\nmsg->pipe_hdr.size = msg->vid_hdr.size;\r\nret = vmbus_sendpacket(hdev->channel, msg,\r\nmsg->vid_hdr.size + sizeof(struct pipe_msg_hdr),\r\natomic64_inc_return(&request_id),\r\nVM_PKT_DATA_INBAND, 0);\r\nif (ret)\r\npr_err("Unable to send packet via vmbus\n");\r\nreturn ret;\r\n}\r\nstatic int synthvid_send_situ(struct hv_device *hdev)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct synthvid_msg msg;\r\nif (!info)\r\nreturn -ENODEV;\r\nmemset(&msg, 0, sizeof(struct synthvid_msg));\r\nmsg.vid_hdr.type = SYNTHVID_SITUATION_UPDATE;\r\nmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_situation_update);\r\nmsg.situ.user_ctx = 0;\r\nmsg.situ.video_output_count = 1;\r\nmsg.situ.video_output[0].active = 1;\r\nmsg.situ.video_output[0].vram_offset = 0;\r\nmsg.situ.video_output[0].depth_bits = info->var.bits_per_pixel;\r\nmsg.situ.video_output[0].width_pixels = info->var.xres;\r\nmsg.situ.video_output[0].height_pixels = info->var.yres;\r\nmsg.situ.video_output[0].pitch_bytes = info->fix.line_length;\r\nsynthvid_send(hdev, &msg);\r\nreturn 0;\r\n}\r\nstatic int synthvid_send_ptr(struct hv_device *hdev)\r\n{\r\nstruct synthvid_msg msg;\r\nmemset(&msg, 0, sizeof(struct synthvid_msg));\r\nmsg.vid_hdr.type = SYNTHVID_POINTER_POSITION;\r\nmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_pointer_position);\r\nmsg.ptr_pos.is_visible = 1;\r\nmsg.ptr_pos.video_output = 0;\r\nmsg.ptr_pos.image_x = 0;\r\nmsg.ptr_pos.image_y = 0;\r\nsynthvid_send(hdev, &msg);\r\nmemset(&msg, 0, sizeof(struct synthvid_msg));\r\nmsg.vid_hdr.type = SYNTHVID_POINTER_SHAPE;\r\nmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_pointer_shape);\r\nmsg.ptr_shape.part_idx = CURSOR_COMPLETE;\r\nmsg.ptr_shape.is_argb = 1;\r\nmsg.ptr_shape.width = 1;\r\nmsg.ptr_shape.height = 1;\r\nmsg.ptr_shape.hot_x = 0;\r\nmsg.ptr_shape.hot_y = 0;\r\nmsg.ptr_shape.data[0] = 0;\r\nmsg.ptr_shape.data[1] = 1;\r\nmsg.ptr_shape.data[2] = 1;\r\nmsg.ptr_shape.data[3] = 1;\r\nsynthvid_send(hdev, &msg);\r\nreturn 0;\r\n}\r\nstatic int synthvid_update(struct fb_info *info)\r\n{\r\nstruct hv_device *hdev = device_to_hv_device(info->device);\r\nstruct synthvid_msg msg;\r\nmemset(&msg, 0, sizeof(struct synthvid_msg));\r\nmsg.vid_hdr.type = SYNTHVID_DIRT;\r\nmsg.vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_dirt);\r\nmsg.dirt.video_output = 0;\r\nmsg.dirt.dirt_count = 1;\r\nmsg.dirt.rect[0].x1 = 0;\r\nmsg.dirt.rect[0].y1 = 0;\r\nmsg.dirt.rect[0].x2 = info->var.xres;\r\nmsg.dirt.rect[0].y2 = info->var.yres;\r\nsynthvid_send(hdev, &msg);\r\nreturn 0;\r\n}\r\nstatic void synthvid_recv_sub(struct hv_device *hdev)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par;\r\nstruct synthvid_msg *msg;\r\nif (!info)\r\nreturn;\r\npar = info->par;\r\nmsg = (struct synthvid_msg *)par->recv_buf;\r\nif (msg->vid_hdr.type == SYNTHVID_VERSION_RESPONSE ||\r\nmsg->vid_hdr.type == SYNTHVID_VRAM_LOCATION_ACK) {\r\nmemcpy(par->init_buf, msg, MAX_VMBUS_PKT_SIZE);\r\ncomplete(&par->wait);\r\nreturn;\r\n}\r\nif (msg->vid_hdr.type == SYNTHVID_FEATURE_CHANGE) {\r\nif (par->fb_ready) {\r\nsynthvid_send_ptr(hdev);\r\nsynthvid_send_situ(hdev);\r\n}\r\npar->update = msg->feature_chg.is_dirt_needed;\r\nif (par->update)\r\nschedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);\r\n}\r\n}\r\nstatic void synthvid_receive(void *ctx)\r\n{\r\nstruct hv_device *hdev = ctx;\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par;\r\nstruct synthvid_msg *recv_buf;\r\nu32 bytes_recvd;\r\nu64 req_id;\r\nint ret;\r\nif (!info)\r\nreturn;\r\npar = info->par;\r\nrecv_buf = (struct synthvid_msg *)par->recv_buf;\r\ndo {\r\nret = vmbus_recvpacket(hdev->channel, recv_buf,\r\nMAX_VMBUS_PKT_SIZE,\r\n&bytes_recvd, &req_id);\r\nif (bytes_recvd > 0 &&\r\nrecv_buf->pipe_hdr.type == PIPE_MSG_DATA)\r\nsynthvid_recv_sub(hdev);\r\n} while (bytes_recvd > 0 && ret == 0);\r\n}\r\nstatic int synthvid_negotiate_ver(struct hv_device *hdev, u32 ver)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par = info->par;\r\nstruct synthvid_msg *msg = (struct synthvid_msg *)par->init_buf;\r\nint t, ret = 0;\r\nmemset(msg, 0, sizeof(struct synthvid_msg));\r\nmsg->vid_hdr.type = SYNTHVID_VERSION_REQUEST;\r\nmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_version_req);\r\nmsg->ver_req.version = ver;\r\nsynthvid_send(hdev, msg);\r\nt = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);\r\nif (!t) {\r\npr_err("Time out on waiting version response\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (!msg->ver_resp.is_accepted) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npar->synthvid_version = ver;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int synthvid_connect_vsp(struct hv_device *hdev)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par = info->par;\r\nint ret;\r\nret = vmbus_open(hdev->channel, RING_BUFSIZE, RING_BUFSIZE,\r\nNULL, 0, synthvid_receive, hdev);\r\nif (ret) {\r\npr_err("Unable to open vmbus channel\n");\r\nreturn ret;\r\n}\r\nif (vmbus_proto_version == VERSION_WS2008 ||\r\nvmbus_proto_version == VERSION_WIN7)\r\nret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN7);\r\nelse\r\nret = synthvid_negotiate_ver(hdev, SYNTHVID_VERSION_WIN8);\r\nif (ret) {\r\npr_err("Synthetic video device version not accepted\n");\r\ngoto error;\r\n}\r\nif (par->synthvid_version == SYNTHVID_VERSION_WIN7) {\r\nscreen_depth = SYNTHVID_DEPTH_WIN7;\r\nscreen_fb_size = SYNTHVID_FB_SIZE_WIN7;\r\n} else {\r\nscreen_depth = SYNTHVID_DEPTH_WIN8;\r\nscreen_fb_size = SYNTHVID_FB_SIZE_WIN8;\r\n}\r\nreturn 0;\r\nerror:\r\nvmbus_close(hdev->channel);\r\nreturn ret;\r\n}\r\nstatic int synthvid_send_config(struct hv_device *hdev)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par = info->par;\r\nstruct synthvid_msg *msg = (struct synthvid_msg *)par->init_buf;\r\nint t, ret = 0;\r\nmemset(msg, 0, sizeof(struct synthvid_msg));\r\nmsg->vid_hdr.type = SYNTHVID_VRAM_LOCATION;\r\nmsg->vid_hdr.size = sizeof(struct synthvid_msg_hdr) +\r\nsizeof(struct synthvid_vram_location);\r\nmsg->vram.user_ctx = msg->vram.vram_gpa = info->fix.smem_start;\r\nmsg->vram.is_vram_gpa_specified = 1;\r\nsynthvid_send(hdev, msg);\r\nt = wait_for_completion_timeout(&par->wait, VSP_TIMEOUT);\r\nif (!t) {\r\npr_err("Time out on waiting vram location ack\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (msg->vram_ack.user_ctx != info->fix.smem_start) {\r\npr_err("Unable to set VRAM location\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsynthvid_send_ptr(hdev);\r\nsynthvid_send_situ(hdev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void hvfb_update_work(struct work_struct *w)\r\n{\r\nstruct hvfb_par *par = container_of(w, struct hvfb_par, dwork.work);\r\nstruct fb_info *info = par->info;\r\nif (par->fb_ready)\r\nsynthvid_update(info);\r\nif (par->update)\r\nschedule_delayed_work(&par->dwork, HVFB_UPDATE_DELAY);\r\n}\r\nstatic int hvfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xres < HVFB_WIDTH_MIN || var->yres < HVFB_HEIGHT_MIN ||\r\nvar->xres > screen_width || var->yres > screen_height ||\r\nvar->bits_per_pixel != screen_depth)\r\nreturn -EINVAL;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nreturn 0;\r\n}\r\nstatic int hvfb_set_par(struct fb_info *info)\r\n{\r\nstruct hv_device *hdev = device_to_hv_device(info->device);\r\nreturn synthvid_send_situ(hdev);\r\n}\r\nstatic inline u32 chan_to_field(u32 chan, struct fb_bitfield *bf)\r\n{\r\nreturn ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;\r\n}\r\nstatic int hvfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nu32 *pal = info->pseudo_palette;\r\nif (regno > 15)\r\nreturn -EINVAL;\r\npal[regno] = chan_to_field(red, &info->var.red)\r\n| chan_to_field(green, &info->var.green)\r\n| chan_to_field(blue, &info->var.blue)\r\n| chan_to_field(transp, &info->var.transp);\r\nreturn 0;\r\n}\r\nstatic int hvfb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 1;\r\n}\r\nstatic void hvfb_get_option(struct fb_info *info)\r\n{\r\nstruct hvfb_par *par = info->par;\r\nchar *opt = NULL, *p;\r\nuint x = 0, y = 0;\r\nif (fb_get_options(KBUILD_MODNAME, &opt) || !opt || !*opt)\r\nreturn;\r\np = strsep(&opt, "x");\r\nif (!*p || kstrtouint(p, 0, &x) ||\r\n!opt || !*opt || kstrtouint(opt, 0, &y)) {\r\npr_err("Screen option is invalid: skipped\n");\r\nreturn;\r\n}\r\nif (x < HVFB_WIDTH_MIN || y < HVFB_HEIGHT_MIN ||\r\n(par->synthvid_version == SYNTHVID_VERSION_WIN8 &&\r\nx * y * screen_depth / 8 > SYNTHVID_FB_SIZE_WIN8) ||\r\n(par->synthvid_version == SYNTHVID_VERSION_WIN7 &&\r\n(x > SYNTHVID_WIDTH_MAX_WIN7 || y > SYNTHVID_HEIGHT_MAX_WIN7))) {\r\npr_err("Screen resolution option is out of range: skipped\n");\r\nreturn;\r\n}\r\nscreen_width = x;\r\nscreen_height = y;\r\nreturn;\r\n}\r\nstatic int hvfb_getmem(struct fb_info *info)\r\n{\r\nstruct pci_dev *pdev;\r\nulong fb_phys;\r\nvoid __iomem *fb_virt;\r\npdev = pci_get_device(PCI_VENDOR_ID_MICROSOFT,\r\nPCI_DEVICE_ID_HYPERV_VIDEO, NULL);\r\nif (!pdev) {\r\npr_err("Unable to find PCI Hyper-V video\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM) ||\r\npci_resource_len(pdev, 0) < screen_fb_size)\r\ngoto err1;\r\nfb_phys = pci_resource_end(pdev, 0) - screen_fb_size + 1;\r\nif (!request_mem_region(fb_phys, screen_fb_size, KBUILD_MODNAME))\r\ngoto err1;\r\nfb_virt = ioremap(fb_phys, screen_fb_size);\r\nif (!fb_virt)\r\ngoto err2;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures)\r\ngoto err3;\r\ninfo->apertures->ranges[0].base = pci_resource_start(pdev, 0);\r\ninfo->apertures->ranges[0].size = pci_resource_len(pdev, 0);\r\ninfo->fix.smem_start = fb_phys;\r\ninfo->fix.smem_len = screen_fb_size;\r\ninfo->screen_base = fb_virt;\r\ninfo->screen_size = screen_fb_size;\r\npci_dev_put(pdev);\r\nreturn 0;\r\nerr3:\r\niounmap(fb_virt);\r\nerr2:\r\nrelease_mem_region(fb_phys, screen_fb_size);\r\nerr1:\r\npci_dev_put(pdev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void hvfb_putmem(struct fb_info *info)\r\n{\r\niounmap(info->screen_base);\r\nrelease_mem_region(info->fix.smem_start, screen_fb_size);\r\n}\r\nstatic int hvfb_probe(struct hv_device *hdev,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nstruct fb_info *info;\r\nstruct hvfb_par *par;\r\nint ret;\r\ninfo = framebuffer_alloc(sizeof(struct hvfb_par), &hdev->device);\r\nif (!info) {\r\npr_err("No memory for framebuffer info\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\npar->info = info;\r\npar->fb_ready = false;\r\ninit_completion(&par->wait);\r\nINIT_DELAYED_WORK(&par->dwork, hvfb_update_work);\r\nhv_set_drvdata(hdev, info);\r\nret = synthvid_connect_vsp(hdev);\r\nif (ret) {\r\npr_err("Unable to connect to VSP\n");\r\ngoto error1;\r\n}\r\nret = hvfb_getmem(info);\r\nif (ret) {\r\npr_err("No memory for framebuffer\n");\r\ngoto error2;\r\n}\r\nhvfb_get_option(info);\r\npr_info("Screen resolution: %dx%d, Color depth: %d\n",\r\nscreen_width, screen_height, screen_depth);\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->var.xres_virtual = info->var.xres = screen_width;\r\ninfo->var.yres_virtual = info->var.yres = screen_height;\r\ninfo->var.bits_per_pixel = screen_depth;\r\nif (info->var.bits_per_pixel == 16) {\r\ninfo->var.red = (struct fb_bitfield){11, 5, 0};\r\ninfo->var.green = (struct fb_bitfield){5, 6, 0};\r\ninfo->var.blue = (struct fb_bitfield){0, 5, 0};\r\ninfo->var.transp = (struct fb_bitfield){0, 0, 0};\r\n} else {\r\ninfo->var.red = (struct fb_bitfield){16, 8, 0};\r\ninfo->var.green = (struct fb_bitfield){8, 8, 0};\r\ninfo->var.blue = (struct fb_bitfield){0, 8, 0};\r\ninfo->var.transp = (struct fb_bitfield){24, 8, 0};\r\n}\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nstrcpy(info->fix.id, KBUILD_MODNAME);\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = screen_width * screen_depth / 8;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fbops = &hvfb_ops;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nret = synthvid_send_config(hdev);\r\nif (ret)\r\ngoto error;\r\nret = register_framebuffer(info);\r\nif (ret) {\r\npr_err("Unable to register framebuffer\n");\r\ngoto error;\r\n}\r\npar->fb_ready = true;\r\nreturn 0;\r\nerror:\r\nhvfb_putmem(info);\r\nerror2:\r\nvmbus_close(hdev->channel);\r\nerror1:\r\ncancel_delayed_work_sync(&par->dwork);\r\nhv_set_drvdata(hdev, NULL);\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int hvfb_remove(struct hv_device *hdev)\r\n{\r\nstruct fb_info *info = hv_get_drvdata(hdev);\r\nstruct hvfb_par *par = info->par;\r\npar->update = false;\r\npar->fb_ready = false;\r\nunregister_framebuffer(info);\r\ncancel_delayed_work_sync(&par->dwork);\r\nvmbus_close(hdev->channel);\r\nhv_set_drvdata(hdev, NULL);\r\nhvfb_putmem(info);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int hvfb_pci_stub_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn 0;\r\n}\r\nstatic void hvfb_pci_stub_remove(struct pci_dev *pdev)\r\n{\r\n}\r\nstatic int __init hvfb_drv_init(void)\r\n{\r\nint ret;\r\nret = vmbus_driver_register(&hvfb_drv);\r\nif (ret != 0)\r\nreturn ret;\r\nret = pci_register_driver(&hvfb_pci_stub_driver);\r\nif (ret != 0) {\r\nvmbus_driver_unregister(&hvfb_drv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hvfb_drv_exit(void)\r\n{\r\npci_unregister_driver(&hvfb_pci_stub_driver);\r\nvmbus_driver_unregister(&hvfb_drv);\r\n}
