static struct intel_tv *enc_to_tv(struct intel_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct intel_tv, base);\r\n}\r\nstatic struct intel_tv *intel_attached_tv(struct drm_connector *connector)\r\n{\r\nreturn enc_to_tv(intel_attached_encoder(connector));\r\n}\r\nstatic bool\r\nintel_tv_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 tmp = I915_READ(TV_CTL);\r\nif (!(tmp & TV_ENC_ENABLE))\r\nreturn false;\r\n*pipe = PORT_TO_PIPE(tmp);\r\nreturn true;\r\n}\r\nstatic void\r\nintel_enable_tv(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nI915_WRITE(TV_CTL, I915_READ(TV_CTL) | TV_ENC_ENABLE);\r\n}\r\nstatic void\r\nintel_disable_tv(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nI915_WRITE(TV_CTL, I915_READ(TV_CTL) & ~TV_ENC_ENABLE);\r\n}\r\nstatic const struct tv_mode *\r\nintel_tv_mode_lookup(const char *tv_format)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\r\nconst struct tv_mode *tv_mode = &tv_modes[i];\r\nif (!strcmp(tv_format, tv_mode->name))\r\nreturn tv_mode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct tv_mode *\r\nintel_tv_mode_find(struct intel_tv *intel_tv)\r\n{\r\nreturn intel_tv_mode_lookup(intel_tv->tv_format);\r\n}\r\nstatic enum drm_mode_status\r\nintel_tv_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nif (tv_mode && abs(tv_mode->refresh - drm_mode_vrefresh(mode) * 1000)\r\n< 1000)\r\nreturn MODE_OK;\r\nreturn MODE_CLOCK_RANGE;\r\n}\r\nstatic void\r\nintel_tv_get_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\npipe_config->adjusted_mode.crtc_clock = pipe_config->port_clock;\r\n}\r\nstatic bool\r\nintel_tv_compute_config(struct intel_encoder *encoder,\r\nstruct intel_crtc_config *pipe_config)\r\n{\r\nstruct intel_tv *intel_tv = enc_to_tv(encoder);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nif (!tv_mode)\r\nreturn false;\r\npipe_config->adjusted_mode.crtc_clock = tv_mode->clock;\r\nDRM_DEBUG_KMS("forcing bpc to 8 for TV\n");\r\npipe_config->pipe_bpp = 8*3;\r\npipe_config->adjusted_mode.flags = 0;\r\nreturn true;\r\n}\r\nstatic void intel_tv_mode_set(struct intel_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);\r\nstruct intel_tv *intel_tv = enc_to_tv(encoder);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nu32 tv_ctl;\r\nu32 hctl1, hctl2, hctl3;\r\nu32 vctl1, vctl2, vctl3, vctl4, vctl5, vctl6, vctl7;\r\nu32 scctl1, scctl2, scctl3;\r\nint i, j;\r\nconst struct video_levels *video_levels;\r\nconst struct color_conversion *color_conversion;\r\nbool burst_ena;\r\nint pipe = intel_crtc->pipe;\r\nif (!tv_mode)\r\nreturn;\r\ntv_ctl = I915_READ(TV_CTL);\r\ntv_ctl &= TV_CTL_SAVE;\r\nswitch (intel_tv->type) {\r\ndefault:\r\ncase DRM_MODE_CONNECTOR_Unknown:\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ntv_ctl |= TV_ENC_OUTPUT_COMPOSITE;\r\nvideo_levels = tv_mode->composite_levels;\r\ncolor_conversion = tv_mode->composite_color;\r\nburst_ena = tv_mode->burst_ena;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Component:\r\ntv_ctl |= TV_ENC_OUTPUT_COMPONENT;\r\nvideo_levels = &component_levels;\r\nif (tv_mode->burst_ena)\r\ncolor_conversion = &sdtv_csc_yprpb;\r\nelse\r\ncolor_conversion = &hdtv_csc_yprpb;\r\nburst_ena = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ntv_ctl |= TV_ENC_OUTPUT_SVIDEO;\r\nvideo_levels = tv_mode->svideo_levels;\r\ncolor_conversion = tv_mode->svideo_color;\r\nburst_ena = tv_mode->burst_ena;\r\nbreak;\r\n}\r\nhctl1 = (tv_mode->hsync_end << TV_HSYNC_END_SHIFT) |\r\n(tv_mode->htotal << TV_HTOTAL_SHIFT);\r\nhctl2 = (tv_mode->hburst_start << 16) |\r\n(tv_mode->hburst_len << TV_HBURST_LEN_SHIFT);\r\nif (burst_ena)\r\nhctl2 |= TV_BURST_ENA;\r\nhctl3 = (tv_mode->hblank_start << TV_HBLANK_START_SHIFT) |\r\n(tv_mode->hblank_end << TV_HBLANK_END_SHIFT);\r\nvctl1 = (tv_mode->nbr_end << TV_NBR_END_SHIFT) |\r\n(tv_mode->vi_end_f1 << TV_VI_END_F1_SHIFT) |\r\n(tv_mode->vi_end_f2 << TV_VI_END_F2_SHIFT);\r\nvctl2 = (tv_mode->vsync_len << TV_VSYNC_LEN_SHIFT) |\r\n(tv_mode->vsync_start_f1 << TV_VSYNC_START_F1_SHIFT) |\r\n(tv_mode->vsync_start_f2 << TV_VSYNC_START_F2_SHIFT);\r\nvctl3 = (tv_mode->veq_len << TV_VEQ_LEN_SHIFT) |\r\n(tv_mode->veq_start_f1 << TV_VEQ_START_F1_SHIFT) |\r\n(tv_mode->veq_start_f2 << TV_VEQ_START_F2_SHIFT);\r\nif (tv_mode->veq_ena)\r\nvctl3 |= TV_EQUAL_ENA;\r\nvctl4 = (tv_mode->vburst_start_f1 << TV_VBURST_START_F1_SHIFT) |\r\n(tv_mode->vburst_end_f1 << TV_VBURST_END_F1_SHIFT);\r\nvctl5 = (tv_mode->vburst_start_f2 << TV_VBURST_START_F2_SHIFT) |\r\n(tv_mode->vburst_end_f2 << TV_VBURST_END_F2_SHIFT);\r\nvctl6 = (tv_mode->vburst_start_f3 << TV_VBURST_START_F3_SHIFT) |\r\n(tv_mode->vburst_end_f3 << TV_VBURST_END_F3_SHIFT);\r\nvctl7 = (tv_mode->vburst_start_f4 << TV_VBURST_START_F4_SHIFT) |\r\n(tv_mode->vburst_end_f4 << TV_VBURST_END_F4_SHIFT);\r\nif (intel_crtc->pipe == 1)\r\ntv_ctl |= TV_ENC_PIPEB_SELECT;\r\ntv_ctl |= tv_mode->oversample;\r\nif (tv_mode->progressive)\r\ntv_ctl |= TV_PROGRESSIVE;\r\nif (tv_mode->trilevel_sync)\r\ntv_ctl |= TV_TRILEVEL_SYNC;\r\nif (tv_mode->pal_burst)\r\ntv_ctl |= TV_PAL_BURST;\r\nscctl1 = 0;\r\nif (tv_mode->dda1_inc)\r\nscctl1 |= TV_SC_DDA1_EN;\r\nif (tv_mode->dda2_inc)\r\nscctl1 |= TV_SC_DDA2_EN;\r\nif (tv_mode->dda3_inc)\r\nscctl1 |= TV_SC_DDA3_EN;\r\nscctl1 |= tv_mode->sc_reset;\r\nif (video_levels)\r\nscctl1 |= video_levels->burst << TV_BURST_LEVEL_SHIFT;\r\nscctl1 |= tv_mode->dda1_inc << TV_SCDDA1_INC_SHIFT;\r\nscctl2 = tv_mode->dda2_size << TV_SCDDA2_SIZE_SHIFT |\r\ntv_mode->dda2_inc << TV_SCDDA2_INC_SHIFT;\r\nscctl3 = tv_mode->dda3_size << TV_SCDDA3_SIZE_SHIFT |\r\ntv_mode->dda3_inc << TV_SCDDA3_INC_SHIFT;\r\nif (dev->pdev->device < 0x2772)\r\ntv_ctl |= TV_ENC_C0_FIX | TV_ENC_SDP_FIX;\r\nI915_WRITE(TV_H_CTL_1, hctl1);\r\nI915_WRITE(TV_H_CTL_2, hctl2);\r\nI915_WRITE(TV_H_CTL_3, hctl3);\r\nI915_WRITE(TV_V_CTL_1, vctl1);\r\nI915_WRITE(TV_V_CTL_2, vctl2);\r\nI915_WRITE(TV_V_CTL_3, vctl3);\r\nI915_WRITE(TV_V_CTL_4, vctl4);\r\nI915_WRITE(TV_V_CTL_5, vctl5);\r\nI915_WRITE(TV_V_CTL_6, vctl6);\r\nI915_WRITE(TV_V_CTL_7, vctl7);\r\nI915_WRITE(TV_SC_CTL_1, scctl1);\r\nI915_WRITE(TV_SC_CTL_2, scctl2);\r\nI915_WRITE(TV_SC_CTL_3, scctl3);\r\nif (color_conversion) {\r\nI915_WRITE(TV_CSC_Y, (color_conversion->ry << 16) |\r\ncolor_conversion->gy);\r\nI915_WRITE(TV_CSC_Y2, (color_conversion->by << 16) |\r\ncolor_conversion->ay);\r\nI915_WRITE(TV_CSC_U, (color_conversion->ru << 16) |\r\ncolor_conversion->gu);\r\nI915_WRITE(TV_CSC_U2, (color_conversion->bu << 16) |\r\ncolor_conversion->au);\r\nI915_WRITE(TV_CSC_V, (color_conversion->rv << 16) |\r\ncolor_conversion->gv);\r\nI915_WRITE(TV_CSC_V2, (color_conversion->bv << 16) |\r\ncolor_conversion->av);\r\n}\r\nif (INTEL_INFO(dev)->gen >= 4)\r\nI915_WRITE(TV_CLR_KNOBS, 0x00404000);\r\nelse\r\nI915_WRITE(TV_CLR_KNOBS, 0x00606000);\r\nif (video_levels)\r\nI915_WRITE(TV_CLR_LEVEL,\r\n((video_levels->black << TV_BLACK_LEVEL_SHIFT) |\r\n(video_levels->blank << TV_BLANK_LEVEL_SHIFT)));\r\n{\r\nint pipeconf_reg = PIPECONF(pipe);\r\nint dspcntr_reg = DSPCNTR(intel_crtc->plane);\r\nint pipeconf = I915_READ(pipeconf_reg);\r\nint dspcntr = I915_READ(dspcntr_reg);\r\nint xpos = 0x0, ypos = 0x0;\r\nunsigned int xsize, ysize;\r\nI915_WRITE(dspcntr_reg, dspcntr & ~DISPLAY_PLANE_ENABLE);\r\nintel_flush_primary_plane(dev_priv, intel_crtc->plane);\r\nif (IS_GEN2(dev))\r\nintel_wait_for_vblank(dev, intel_crtc->pipe);\r\nI915_WRITE(pipeconf_reg, pipeconf & ~PIPECONF_ENABLE);\r\nintel_wait_for_pipe_off(dev, intel_crtc->pipe);\r\nI915_WRITE(TV_FILTER_CTL_1, TV_AUTO_SCALE);\r\nxsize = tv_mode->hblank_start - tv_mode->hblank_end;\r\nif (tv_mode->progressive)\r\nysize = tv_mode->nbr_end + 1;\r\nelse\r\nysize = 2*tv_mode->nbr_end + 1;\r\nxpos += intel_tv->margin[TV_MARGIN_LEFT];\r\nypos += intel_tv->margin[TV_MARGIN_TOP];\r\nxsize -= (intel_tv->margin[TV_MARGIN_LEFT] +\r\nintel_tv->margin[TV_MARGIN_RIGHT]);\r\nysize -= (intel_tv->margin[TV_MARGIN_TOP] +\r\nintel_tv->margin[TV_MARGIN_BOTTOM]);\r\nI915_WRITE(TV_WIN_POS, (xpos<<16)|ypos);\r\nI915_WRITE(TV_WIN_SIZE, (xsize<<16)|ysize);\r\nI915_WRITE(pipeconf_reg, pipeconf);\r\nI915_WRITE(dspcntr_reg, dspcntr);\r\nintel_flush_primary_plane(dev_priv, intel_crtc->plane);\r\n}\r\nj = 0;\r\nfor (i = 0; i < 60; i++)\r\nI915_WRITE(TV_H_LUMA_0 + (i<<2), tv_mode->filter_table[j++]);\r\nfor (i = 0; i < 60; i++)\r\nI915_WRITE(TV_H_CHROMA_0 + (i<<2), tv_mode->filter_table[j++]);\r\nfor (i = 0; i < 43; i++)\r\nI915_WRITE(TV_V_LUMA_0 + (i<<2), tv_mode->filter_table[j++]);\r\nfor (i = 0; i < 43; i++)\r\nI915_WRITE(TV_V_CHROMA_0 + (i<<2), tv_mode->filter_table[j++]);\r\nI915_WRITE(TV_DAC, I915_READ(TV_DAC) & TV_DAC_SAVE);\r\nI915_WRITE(TV_CTL, tv_ctl);\r\n}\r\nstatic int\r\nintel_tv_detect_type(struct intel_tv *intel_tv,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder = &intel_tv->base.base;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(crtc);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nunsigned long irqflags;\r\nu32 tv_ctl, save_tv_ctl;\r\nu32 tv_dac, save_tv_dac;\r\nint type;\r\nif (connector->polled & DRM_CONNECTOR_POLL_HPD) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\r\ni915_disable_pipestat(dev_priv, 0,\r\nPIPE_HOTPLUG_INTERRUPT_ENABLE |\r\nPIPE_HOTPLUG_TV_INTERRUPT_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\r\n}\r\nsave_tv_dac = tv_dac = I915_READ(TV_DAC);\r\nsave_tv_ctl = tv_ctl = I915_READ(TV_CTL);\r\ntv_ctl &= ~(TV_ENC_ENABLE | TV_TEST_MODE_MASK);\r\ntv_ctl |= TV_TEST_MODE_MONITOR_DETECT;\r\nif (intel_crtc->pipe == 1)\r\ntv_ctl |= TV_ENC_PIPEB_SELECT;\r\nelse\r\ntv_ctl &= ~TV_ENC_PIPEB_SELECT;\r\ntv_dac &= ~(TVDAC_SENSE_MASK | DAC_A_MASK | DAC_B_MASK | DAC_C_MASK);\r\ntv_dac |= (TVDAC_STATE_CHG_EN |\r\nTVDAC_A_SENSE_CTL |\r\nTVDAC_B_SENSE_CTL |\r\nTVDAC_C_SENSE_CTL |\r\nDAC_CTL_OVERRIDE |\r\nDAC_A_0_7_V |\r\nDAC_B_0_7_V |\r\nDAC_C_0_7_V);\r\nif (IS_GM45(dev))\r\ntv_dac &= ~(TVDAC_STATE_CHG_EN | TVDAC_A_SENSE_CTL |\r\nTVDAC_B_SENSE_CTL | TVDAC_C_SENSE_CTL);\r\nI915_WRITE(TV_CTL, tv_ctl);\r\nI915_WRITE(TV_DAC, tv_dac);\r\nPOSTING_READ(TV_DAC);\r\nintel_wait_for_vblank(intel_tv->base.base.dev,\r\nto_intel_crtc(intel_tv->base.base.crtc)->pipe);\r\ntype = -1;\r\ntv_dac = I915_READ(TV_DAC);\r\nDRM_DEBUG_KMS("TV detected: %x, %x\n", tv_ctl, tv_dac);\r\nif ((tv_dac & TVDAC_SENSE_MASK) == (TVDAC_B_SENSE | TVDAC_C_SENSE)) {\r\nDRM_DEBUG_KMS("Detected Composite TV connection\n");\r\ntype = DRM_MODE_CONNECTOR_Composite;\r\n} else if ((tv_dac & (TVDAC_A_SENSE|TVDAC_B_SENSE)) == TVDAC_A_SENSE) {\r\nDRM_DEBUG_KMS("Detected S-Video TV connection\n");\r\ntype = DRM_MODE_CONNECTOR_SVIDEO;\r\n} else if ((tv_dac & TVDAC_SENSE_MASK) == 0) {\r\nDRM_DEBUG_KMS("Detected Component TV connection\n");\r\ntype = DRM_MODE_CONNECTOR_Component;\r\n} else {\r\nDRM_DEBUG_KMS("Unrecognised TV connection\n");\r\ntype = -1;\r\n}\r\nI915_WRITE(TV_DAC, save_tv_dac & ~TVDAC_STATE_CHG_EN);\r\nI915_WRITE(TV_CTL, save_tv_ctl);\r\nPOSTING_READ(TV_CTL);\r\nintel_wait_for_vblank(intel_tv->base.base.dev,\r\nto_intel_crtc(intel_tv->base.base.crtc)->pipe);\r\nif (connector->polled & DRM_CONNECTOR_POLL_HPD) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irqflags);\r\ni915_enable_pipestat(dev_priv, 0,\r\nPIPE_HOTPLUG_INTERRUPT_ENABLE |\r\nPIPE_HOTPLUG_TV_INTERRUPT_ENABLE);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);\r\n}\r\nreturn type;\r\n}\r\nstatic void intel_tv_find_better_format(struct drm_connector *connector)\r\n{\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nint i;\r\nif ((intel_tv->type == DRM_MODE_CONNECTOR_Component) ==\r\ntv_mode->component_only)\r\nreturn;\r\nfor (i = 0; i < sizeof(tv_modes) / sizeof(*tv_modes); i++) {\r\ntv_mode = tv_modes + i;\r\nif ((intel_tv->type == DRM_MODE_CONNECTOR_Component) ==\r\ntv_mode->component_only)\r\nbreak;\r\n}\r\nintel_tv->tv_format = tv_mode->name;\r\ndrm_object_property_set_value(&connector->base,\r\nconnector->dev->mode_config.tv_mode_property, i);\r\n}\r\nstatic enum drm_connector_status\r\nintel_tv_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_display_mode mode;\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nint type;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] force=%d\n",\r\nconnector->base.id, drm_get_connector_name(connector),\r\nforce);\r\nmode = reported_modes[0];\r\nif (force) {\r\nstruct intel_load_detect_pipe tmp;\r\nif (intel_get_load_detect_pipe(connector, &mode, &tmp)) {\r\ntype = intel_tv_detect_type(intel_tv, connector);\r\nintel_release_load_detect_pipe(connector, &tmp);\r\n} else\r\nreturn connector_status_unknown;\r\n} else\r\nreturn connector->status;\r\nif (type < 0)\r\nreturn connector_status_disconnected;\r\nintel_tv->type = type;\r\nintel_tv_find_better_format(connector);\r\nreturn connector_status_connected;\r\n}\r\nstatic void\r\nintel_tv_chose_preferred_modes(struct drm_connector *connector,\r\nstruct drm_display_mode *mode_ptr)\r\n{\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nif (tv_mode->nbr_end < 480 && mode_ptr->vdisplay == 480)\r\nmode_ptr->type |= DRM_MODE_TYPE_PREFERRED;\r\nelse if (tv_mode->nbr_end > 480) {\r\nif (tv_mode->progressive == true && tv_mode->nbr_end < 720) {\r\nif (mode_ptr->vdisplay == 720)\r\nmode_ptr->type |= DRM_MODE_TYPE_PREFERRED;\r\n} else if (mode_ptr->vdisplay == 1080)\r\nmode_ptr->type |= DRM_MODE_TYPE_PREFERRED;\r\n}\r\n}\r\nstatic int\r\nintel_tv_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_display_mode *mode_ptr;\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nconst struct tv_mode *tv_mode = intel_tv_mode_find(intel_tv);\r\nint j, count = 0;\r\nu64 tmp;\r\nfor (j = 0; j < ARRAY_SIZE(input_res_table);\r\nj++) {\r\nconst struct input_res *input = &input_res_table[j];\r\nunsigned int hactive_s = input->w;\r\nunsigned int vactive_s = input->h;\r\nif (tv_mode->max_srcw && input->w > tv_mode->max_srcw)\r\ncontinue;\r\nif (input->w > 1024 && (!tv_mode->progressive\r\n&& !tv_mode->component_only))\r\ncontinue;\r\nmode_ptr = drm_mode_create(connector->dev);\r\nif (!mode_ptr)\r\ncontinue;\r\nstrncpy(mode_ptr->name, input->name, DRM_DISPLAY_MODE_LEN);\r\nmode_ptr->hdisplay = hactive_s;\r\nmode_ptr->hsync_start = hactive_s + 1;\r\nmode_ptr->hsync_end = hactive_s + 64;\r\nif (mode_ptr->hsync_end <= mode_ptr->hsync_start)\r\nmode_ptr->hsync_end = mode_ptr->hsync_start + 1;\r\nmode_ptr->htotal = hactive_s + 96;\r\nmode_ptr->vdisplay = vactive_s;\r\nmode_ptr->vsync_start = vactive_s + 1;\r\nmode_ptr->vsync_end = vactive_s + 32;\r\nif (mode_ptr->vsync_end <= mode_ptr->vsync_start)\r\nmode_ptr->vsync_end = mode_ptr->vsync_start + 1;\r\nmode_ptr->vtotal = vactive_s + 33;\r\ntmp = (u64) tv_mode->refresh * mode_ptr->vtotal;\r\ntmp *= mode_ptr->htotal;\r\ntmp = div_u64(tmp, 1000000);\r\nmode_ptr->clock = (int) tmp;\r\nmode_ptr->type = DRM_MODE_TYPE_DRIVER;\r\nintel_tv_chose_preferred_modes(connector, mode_ptr);\r\ndrm_mode_probed_add(connector, mode_ptr);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void\r\nintel_tv_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int\r\nintel_tv_set_property(struct drm_connector *connector, struct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct intel_tv *intel_tv = intel_attached_tv(connector);\r\nstruct drm_crtc *crtc = intel_tv->base.base.crtc;\r\nint ret = 0;\r\nbool changed = false;\r\nret = drm_object_property_set_value(&connector->base, property, val);\r\nif (ret < 0)\r\ngoto out;\r\nif (property == dev->mode_config.tv_left_margin_property &&\r\nintel_tv->margin[TV_MARGIN_LEFT] != val) {\r\nintel_tv->margin[TV_MARGIN_LEFT] = val;\r\nchanged = true;\r\n} else if (property == dev->mode_config.tv_right_margin_property &&\r\nintel_tv->margin[TV_MARGIN_RIGHT] != val) {\r\nintel_tv->margin[TV_MARGIN_RIGHT] = val;\r\nchanged = true;\r\n} else if (property == dev->mode_config.tv_top_margin_property &&\r\nintel_tv->margin[TV_MARGIN_TOP] != val) {\r\nintel_tv->margin[TV_MARGIN_TOP] = val;\r\nchanged = true;\r\n} else if (property == dev->mode_config.tv_bottom_margin_property &&\r\nintel_tv->margin[TV_MARGIN_BOTTOM] != val) {\r\nintel_tv->margin[TV_MARGIN_BOTTOM] = val;\r\nchanged = true;\r\n} else if (property == dev->mode_config.tv_mode_property) {\r\nif (val >= ARRAY_SIZE(tv_modes)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!strcmp(intel_tv->tv_format, tv_modes[val].name))\r\ngoto out;\r\nintel_tv->tv_format = tv_modes[val].name;\r\nchanged = true;\r\n} else {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (changed && crtc)\r\nintel_crtc_restore_mode(crtc);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int tv_is_present_in_vbt(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nunion child_device_config *p_child;\r\nint i, ret;\r\nif (!dev_priv->vbt.child_dev_num)\r\nreturn 1;\r\nret = 0;\r\nfor (i = 0; i < dev_priv->vbt.child_dev_num; i++) {\r\np_child = dev_priv->vbt.child_dev + i;\r\nif (p_child->old.device_type != DEVICE_TYPE_INT_TV &&\r\np_child->old.device_type != DEVICE_TYPE_TV)\r\ncontinue;\r\nif (p_child->old.addin_offset) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nintel_tv_init(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct intel_tv *intel_tv;\r\nstruct intel_encoder *intel_encoder;\r\nstruct intel_connector *intel_connector;\r\nu32 tv_dac_on, tv_dac_off, save_tv_dac;\r\nchar *tv_format_names[ARRAY_SIZE(tv_modes)];\r\nint i, initial_mode = 0;\r\nif ((I915_READ(TV_CTL) & TV_FUSE_STATE_MASK) == TV_FUSE_STATE_DISABLED)\r\nreturn;\r\nif (!tv_is_present_in_vbt(dev)) {\r\nDRM_DEBUG_KMS("Integrated TV is not present.\n");\r\nreturn;\r\n}\r\nif (!dev_priv->vbt.int_tv_support)\r\nreturn;\r\nsave_tv_dac = I915_READ(TV_DAC);\r\nI915_WRITE(TV_DAC, save_tv_dac | TVDAC_STATE_CHG_EN);\r\ntv_dac_on = I915_READ(TV_DAC);\r\nI915_WRITE(TV_DAC, save_tv_dac & ~TVDAC_STATE_CHG_EN);\r\ntv_dac_off = I915_READ(TV_DAC);\r\nI915_WRITE(TV_DAC, save_tv_dac);\r\nif ((tv_dac_on & TVDAC_STATE_CHG_EN) == 0 ||\r\n(tv_dac_off & TVDAC_STATE_CHG_EN) != 0)\r\nreturn;\r\nintel_tv = kzalloc(sizeof(*intel_tv), GFP_KERNEL);\r\nif (!intel_tv) {\r\nreturn;\r\n}\r\nintel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);\r\nif (!intel_connector) {\r\nkfree(intel_tv);\r\nreturn;\r\n}\r\nintel_encoder = &intel_tv->base;\r\nconnector = &intel_connector->base;\r\nintel_connector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\ndrm_connector_init(dev, connector, &intel_tv_connector_funcs,\r\nDRM_MODE_CONNECTOR_SVIDEO);\r\ndrm_encoder_init(dev, &intel_encoder->base, &intel_tv_enc_funcs,\r\nDRM_MODE_ENCODER_TVDAC);\r\nintel_encoder->compute_config = intel_tv_compute_config;\r\nintel_encoder->get_config = intel_tv_get_config;\r\nintel_encoder->mode_set = intel_tv_mode_set;\r\nintel_encoder->enable = intel_enable_tv;\r\nintel_encoder->disable = intel_disable_tv;\r\nintel_encoder->get_hw_state = intel_tv_get_hw_state;\r\nintel_connector->get_hw_state = intel_connector_get_hw_state;\r\nintel_connector_attach_encoder(intel_connector, intel_encoder);\r\nintel_encoder->type = INTEL_OUTPUT_TVOUT;\r\nintel_encoder->crtc_mask = (1 << 0) | (1 << 1);\r\nintel_encoder->cloneable = false;\r\nintel_encoder->base.possible_crtcs = ((1 << 0) | (1 << 1));\r\nintel_encoder->base.possible_clones = (1 << INTEL_OUTPUT_TVOUT);\r\nintel_tv->type = DRM_MODE_CONNECTOR_Unknown;\r\nintel_tv->margin[TV_MARGIN_LEFT] = 54;\r\nintel_tv->margin[TV_MARGIN_TOP] = 36;\r\nintel_tv->margin[TV_MARGIN_RIGHT] = 46;\r\nintel_tv->margin[TV_MARGIN_BOTTOM] = 37;\r\nintel_tv->tv_format = tv_modes[initial_mode].name;\r\ndrm_connector_helper_add(connector, &intel_tv_connector_helper_funcs);\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nfor (i = 0; i < ARRAY_SIZE(tv_modes); i++)\r\ntv_format_names[i] = (char *)tv_modes[i].name;\r\ndrm_mode_create_tv_properties(dev,\r\nARRAY_SIZE(tv_modes),\r\ntv_format_names);\r\ndrm_object_attach_property(&connector->base, dev->mode_config.tv_mode_property,\r\ninitial_mode);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.tv_left_margin_property,\r\nintel_tv->margin[TV_MARGIN_LEFT]);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.tv_top_margin_property,\r\nintel_tv->margin[TV_MARGIN_TOP]);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.tv_right_margin_property,\r\nintel_tv->margin[TV_MARGIN_RIGHT]);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.tv_bottom_margin_property,\r\nintel_tv->margin[TV_MARGIN_BOTTOM]);\r\ndrm_sysfs_connector_add(connector);\r\n}
