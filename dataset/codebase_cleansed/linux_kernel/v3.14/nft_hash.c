static unsigned int nft_hash_data(const struct nft_data *data,\r\nunsigned int hsize, unsigned int len)\r\n{\r\nunsigned int h;\r\nh = jhash(data->data, len, nft_hash_rnd);\r\nreturn ((u64)h * hsize) >> 32;\r\n}\r\nstatic bool nft_hash_lookup(const struct nft_set *set,\r\nconst struct nft_data *key,\r\nstruct nft_data *data)\r\n{\r\nconst struct nft_hash *priv = nft_set_priv(set);\r\nconst struct nft_hash_elem *he;\r\nunsigned int h;\r\nh = nft_hash_data(key, priv->hsize, set->klen);\r\nhlist_for_each_entry(he, &priv->hash[h], hnode) {\r\nif (nft_data_cmp(&he->key, key, set->klen))\r\ncontinue;\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(data, he->data);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void nft_hash_elem_destroy(const struct nft_set *set,\r\nstruct nft_hash_elem *he)\r\n{\r\nnft_data_uninit(&he->key, NFT_DATA_VALUE);\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_uninit(he->data, set->dtype);\r\nkfree(he);\r\n}\r\nstatic int nft_hash_insert(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nunsigned int size, h;\r\nif (elem->flags != 0)\r\nreturn -EINVAL;\r\nsize = sizeof(*he);\r\nif (set->flags & NFT_SET_MAP)\r\nsize += sizeof(he->data[0]);\r\nhe = kzalloc(size, GFP_KERNEL);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\nnft_data_copy(&he->key, &elem->key);\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(he->data, &elem->data);\r\nh = nft_hash_data(&he->key, priv->hsize, set->klen);\r\nhlist_add_head_rcu(&he->hnode, &priv->hash[h]);\r\nreturn 0;\r\n}\r\nstatic void nft_hash_remove(const struct nft_set *set,\r\nconst struct nft_set_elem *elem)\r\n{\r\nstruct nft_hash_elem *he = elem->cookie;\r\nhlist_del_rcu(&he->hnode);\r\nkfree(he);\r\n}\r\nstatic int nft_hash_get(const struct nft_set *set, struct nft_set_elem *elem)\r\n{\r\nconst struct nft_hash *priv = nft_set_priv(set);\r\nstruct nft_hash_elem *he;\r\nunsigned int h;\r\nh = nft_hash_data(&elem->key, priv->hsize, set->klen);\r\nhlist_for_each_entry(he, &priv->hash[h], hnode) {\r\nif (nft_data_cmp(&he->key, &elem->key, set->klen))\r\ncontinue;\r\nelem->cookie = he;\r\nelem->flags = 0;\r\nif (set->flags & NFT_SET_MAP)\r\nnft_data_copy(&elem->data, he->data);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void nft_hash_walk(const struct nft_ctx *ctx, const struct nft_set *set,\r\nstruct nft_set_iter *iter)\r\n{\r\nconst struct nft_hash *priv = nft_set_priv(set);\r\nconst struct nft_hash_elem *he;\r\nstruct nft_set_elem elem;\r\nunsigned int i;\r\nfor (i = 0; i < priv->hsize; i++) {\r\nhlist_for_each_entry(he, &priv->hash[i], hnode) {\r\nif (iter->count < iter->skip)\r\ngoto cont;\r\nmemcpy(&elem.key, &he->key, sizeof(elem.key));\r\nif (set->flags & NFT_SET_MAP)\r\nmemcpy(&elem.data, he->data, sizeof(elem.data));\r\nelem.flags = 0;\r\niter->err = iter->fn(ctx, set, iter, &elem);\r\nif (iter->err < 0)\r\nreturn;\r\ncont:\r\niter->count++;\r\n}\r\n}\r\n}\r\nstatic unsigned int nft_hash_privsize(const struct nlattr * const nla[])\r\n{\r\nreturn sizeof(struct nft_hash);\r\n}\r\nstatic int nft_hash_init(const struct nft_set *set,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_hash *priv = nft_set_priv(set);\r\nunsigned int cnt, i;\r\nif (unlikely(!nft_hash_rnd_initted)) {\r\nget_random_bytes(&nft_hash_rnd, 4);\r\nnft_hash_rnd_initted = true;\r\n}\r\ncnt = 100;\r\ncnt = cnt * 4 / 3;\r\npriv->hash = kcalloc(cnt, sizeof(struct hlist_head), GFP_KERNEL);\r\nif (priv->hash == NULL)\r\nreturn -ENOMEM;\r\npriv->hsize = cnt;\r\nfor (i = 0; i < cnt; i++)\r\nINIT_HLIST_HEAD(&priv->hash[i]);\r\nreturn 0;\r\n}\r\nstatic void nft_hash_destroy(const struct nft_set *set)\r\n{\r\nconst struct nft_hash *priv = nft_set_priv(set);\r\nconst struct hlist_node *next;\r\nstruct nft_hash_elem *elem;\r\nunsigned int i;\r\nfor (i = 0; i < priv->hsize; i++) {\r\nhlist_for_each_entry_safe(elem, next, &priv->hash[i], hnode) {\r\nhlist_del(&elem->hnode);\r\nnft_hash_elem_destroy(set, elem);\r\n}\r\n}\r\nkfree(priv->hash);\r\n}\r\nstatic int __init nft_hash_module_init(void)\r\n{\r\nreturn nft_register_set(&nft_hash_ops);\r\n}\r\nstatic void __exit nft_hash_module_exit(void)\r\n{\r\nnft_unregister_set(&nft_hash_ops);\r\n}
