static int mpc52xx_psc_spi_transfer_setup(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\r\ncs->speed_hz = (t && t->speed_hz)\r\n? t->speed_hz : spi->max_speed_hz;\r\ncs->bits_per_word = (t && t->bits_per_word)\r\n? t->bits_per_word : spi->bits_per_word;\r\ncs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_psc_spi_activate_cs(struct spi_device *spi)\r\n{\r\nstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\r\nstruct mpc52xx_psc __iomem *psc = mps->psc;\r\nu32 sicr;\r\nu16 ccr;\r\nsicr = in_be32(&psc->sicr);\r\nif (spi->mode & SPI_CPHA)\r\nsicr |= 0x00001000;\r\nelse\r\nsicr &= ~0x00001000;\r\nif (spi->mode & SPI_CPOL)\r\nsicr |= 0x00002000;\r\nelse\r\nsicr &= ~0x00002000;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nsicr |= 0x10000000;\r\nelse\r\nsicr &= ~0x10000000;\r\nout_be32(&psc->sicr, sicr);\r\nccr = in_be16((u16 __iomem *)&psc->ccr);\r\nccr &= 0xFF00;\r\nif (cs->speed_hz)\r\nccr |= (MCLK / cs->speed_hz - 1) & 0xFF;\r\nelse\r\nccr |= (MCLK / 1000000 - 1) & 0xFF;\r\nout_be16((u16 __iomem *)&psc->ccr, ccr);\r\nmps->bits_per_word = cs->bits_per_word;\r\nif (mps->cs_control)\r\nmps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 1 : 0);\r\n}\r\nstatic void mpc52xx_psc_spi_deactivate_cs(struct spi_device *spi)\r\n{\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\r\nif (mps->cs_control)\r\nmps->cs_control(spi, (spi->mode & SPI_CS_HIGH) ? 0 : 1);\r\n}\r\nstatic int mpc52xx_psc_spi_transfer_rxtx(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\r\nstruct mpc52xx_psc __iomem *psc = mps->psc;\r\nstruct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;\r\nunsigned rb = 0;\r\nunsigned sb = 0;\r\nunsigned char *rx_buf = (unsigned char *)t->rx_buf;\r\nunsigned char *tx_buf = (unsigned char *)t->tx_buf;\r\nunsigned rfalarm;\r\nunsigned send_at_once = MPC52xx_PSC_BUFSIZE;\r\nunsigned recv_at_once;\r\nint last_block = 0;\r\nif (!t->tx_buf && !t->rx_buf && t->len)\r\nreturn -EINVAL;\r\nout_8(&psc->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\r\nwhile (rb < t->len) {\r\nif (t->len - rb > MPC52xx_PSC_BUFSIZE) {\r\nrfalarm = MPC52xx_PSC_RFALARM;\r\nlast_block = 0;\r\n} else {\r\nsend_at_once = t->len - sb;\r\nrfalarm = MPC52xx_PSC_BUFSIZE - (t->len - rb);\r\nlast_block = 1;\r\n}\r\ndev_dbg(&spi->dev, "send %d bytes...\n", send_at_once);\r\nfor (; send_at_once; sb++, send_at_once--) {\r\nif (send_at_once == 1 && last_block)\r\nout_8(&psc->ircr2, 0x01);\r\nif (tx_buf)\r\nout_8(&psc->mpc52xx_psc_buffer_8, tx_buf[sb]);\r\nelse\r\nout_8(&psc->mpc52xx_psc_buffer_8, 0);\r\n}\r\nout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\r\nif (t->len - rb == 1) {\r\nout_8(&psc->mode, 0);\r\n} else {\r\nout_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);\r\nout_be16(&fifo->rfalarm, rfalarm);\r\n}\r\nout_be16(&psc->mpc52xx_psc_imr, MPC52xx_PSC_IMR_RXRDY);\r\nwait_for_completion(&mps->done);\r\nrecv_at_once = in_be16(&fifo->rfnum);\r\ndev_dbg(&spi->dev, "%d bytes received\n", recv_at_once);\r\nsend_at_once = recv_at_once;\r\nif (rx_buf) {\r\nfor (; recv_at_once; rb++, recv_at_once--)\r\nrx_buf[rb] = in_8(&psc->mpc52xx_psc_buffer_8);\r\n} else {\r\nfor (; recv_at_once; rb++, recv_at_once--)\r\nin_8(&psc->mpc52xx_psc_buffer_8);\r\n}\r\n}\r\nout_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_psc_spi_work(struct work_struct *work)\r\n{\r\nstruct mpc52xx_psc_spi *mps =\r\ncontainer_of(work, struct mpc52xx_psc_spi, work);\r\nspin_lock_irq(&mps->lock);\r\nmps->busy = 1;\r\nwhile (!list_empty(&mps->queue)) {\r\nstruct spi_message *m;\r\nstruct spi_device *spi;\r\nstruct spi_transfer *t = NULL;\r\nunsigned cs_change;\r\nint status;\r\nm = container_of(mps->queue.next, struct spi_message, queue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irq(&mps->lock);\r\nspi = m->spi;\r\ncs_change = 1;\r\nstatus = 0;\r\nlist_for_each_entry (t, &m->transfers, transfer_list) {\r\nif (t->bits_per_word || t->speed_hz) {\r\nstatus = mpc52xx_psc_spi_transfer_setup(spi, t);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (cs_change)\r\nmpc52xx_psc_spi_activate_cs(spi);\r\ncs_change = t->cs_change;\r\nstatus = mpc52xx_psc_spi_transfer_rxtx(spi, t);\r\nif (status)\r\nbreak;\r\nm->actual_length += t->len;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (cs_change)\r\nmpc52xx_psc_spi_deactivate_cs(spi);\r\n}\r\nm->status = status;\r\nm->complete(m->context);\r\nif (status || !cs_change)\r\nmpc52xx_psc_spi_deactivate_cs(spi);\r\nmpc52xx_psc_spi_transfer_setup(spi, NULL);\r\nspin_lock_irq(&mps->lock);\r\n}\r\nmps->busy = 0;\r\nspin_unlock_irq(&mps->lock);\r\n}\r\nstatic int mpc52xx_psc_spi_setup(struct spi_device *spi)\r\n{\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\r\nstruct mpc52xx_psc_spi_cs *cs = spi->controller_state;\r\nunsigned long flags;\r\nif (spi->bits_per_word%8)\r\nreturn -EINVAL;\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\ncs->bits_per_word = spi->bits_per_word;\r\ncs->speed_hz = spi->max_speed_hz;\r\nspin_lock_irqsave(&mps->lock, flags);\r\nif (!mps->busy)\r\nmpc52xx_psc_spi_deactivate_cs(spi);\r\nspin_unlock_irqrestore(&mps->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_psc_spi_transfer(struct spi_device *spi,\r\nstruct spi_message *m)\r\n{\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nm->actual_length = 0;\r\nm->status = -EINPROGRESS;\r\nspin_lock_irqsave(&mps->lock, flags);\r\nlist_add_tail(&m->queue, &mps->queue);\r\nqueue_work(mps->workqueue, &mps->work);\r\nspin_unlock_irqrestore(&mps->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_psc_spi_cleanup(struct spi_device *spi)\r\n{\r\nkfree(spi->controller_state);\r\n}\r\nstatic int mpc52xx_psc_spi_port_config(int psc_id, struct mpc52xx_psc_spi *mps)\r\n{\r\nstruct mpc52xx_psc __iomem *psc = mps->psc;\r\nstruct mpc52xx_psc_fifo __iomem *fifo = mps->fifo;\r\nu32 mclken_div;\r\nint ret;\r\nmclken_div = (mps->sysclk ? mps->sysclk : 512000000) / MCLK;\r\nret = mpc52xx_set_psc_clkdiv(psc_id, mclken_div);\r\nif (ret)\r\nreturn ret;\r\nout_8(&psc->command, MPC52xx_PSC_RST_RX);\r\nout_8(&psc->command, MPC52xx_PSC_RST_TX);\r\nout_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);\r\nout_be16(&psc->mpc52xx_psc_imr, 0);\r\nout_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);\r\nout_8(&fifo->rfcntl, 0);\r\nout_8(&psc->mode, MPC52xx_PSC_MODE_FFULL);\r\nout_be32(&psc->sicr, 0x0180C800);\r\nout_be16((u16 __iomem *)&psc->ccr, 0x070F);\r\nout_8(&psc->ctur, 0x00);\r\nout_8(&psc->ctlr, 0x84);\r\nmps->bits_per_word = 8;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mpc52xx_psc_spi_isr(int irq, void *dev_id)\r\n{\r\nstruct mpc52xx_psc_spi *mps = (struct mpc52xx_psc_spi *)dev_id;\r\nstruct mpc52xx_psc __iomem *psc = mps->psc;\r\nif (in_be16(&psc->mpc52xx_psc_isr) & MPC52xx_PSC_IMR_RXRDY) {\r\nout_be16(&psc->mpc52xx_psc_imr, 0);\r\ncomplete(&mps->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,\r\nu32 size, unsigned int irq, s16 bus_num)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev_get_platdata(dev);\r\nstruct mpc52xx_psc_spi *mps;\r\nstruct spi_master *master;\r\nint ret;\r\nmaster = spi_alloc_master(dev, sizeof *mps);\r\nif (master == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, master);\r\nmps = spi_master_get_devdata(master);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\r\nmps->irq = irq;\r\nif (pdata == NULL) {\r\ndev_warn(dev,\r\n"probe called without platform data, no cs_control function will be called\n");\r\nmps->cs_control = NULL;\r\nmps->sysclk = 0;\r\nmaster->bus_num = bus_num;\r\nmaster->num_chipselect = 255;\r\n} else {\r\nmps->cs_control = pdata->cs_control;\r\nmps->sysclk = pdata->sysclk;\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->max_chipselect;\r\n}\r\nmaster->setup = mpc52xx_psc_spi_setup;\r\nmaster->transfer = mpc52xx_psc_spi_transfer;\r\nmaster->cleanup = mpc52xx_psc_spi_cleanup;\r\nmaster->dev.of_node = dev->of_node;\r\nmps->psc = ioremap(regaddr, size);\r\nif (!mps->psc) {\r\ndev_err(dev, "could not ioremap I/O port range\n");\r\nret = -EFAULT;\r\ngoto free_master;\r\n}\r\nmps->fifo = ((void __iomem *)mps->psc) + sizeof(struct mpc52xx_psc);\r\nret = request_irq(mps->irq, mpc52xx_psc_spi_isr, 0, "mpc52xx-psc-spi",\r\nmps);\r\nif (ret)\r\ngoto free_master;\r\nret = mpc52xx_psc_spi_port_config(master->bus_num, mps);\r\nif (ret < 0) {\r\ndev_err(dev, "can't configure PSC! Is it capable of SPI?\n");\r\ngoto free_irq;\r\n}\r\nspin_lock_init(&mps->lock);\r\ninit_completion(&mps->done);\r\nINIT_WORK(&mps->work, mpc52xx_psc_spi_work);\r\nINIT_LIST_HEAD(&mps->queue);\r\nmps->workqueue = create_singlethread_workqueue(\r\ndev_name(master->dev.parent));\r\nif (mps->workqueue == NULL) {\r\nret = -EBUSY;\r\ngoto free_irq;\r\n}\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto unreg_master;\r\nreturn ret;\r\nunreg_master:\r\ndestroy_workqueue(mps->workqueue);\r\nfree_irq:\r\nfree_irq(mps->irq, mps);\r\nfree_master:\r\nif (mps->psc)\r\niounmap(mps->psc);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int mpc52xx_psc_spi_of_probe(struct platform_device *op)\r\n{\r\nconst u32 *regaddr_p;\r\nu64 regaddr64, size64;\r\ns16 id = -1;\r\nregaddr_p = of_get_address(op->dev.of_node, 0, &size64, NULL);\r\nif (!regaddr_p) {\r\ndev_err(&op->dev, "Invalid PSC address\n");\r\nreturn -EINVAL;\r\n}\r\nregaddr64 = of_translate_address(op->dev.of_node, regaddr_p);\r\nif (op->dev.platform_data == NULL) {\r\nconst u32 *psc_nump;\r\npsc_nump = of_get_property(op->dev.of_node, "cell-index", NULL);\r\nif (!psc_nump || *psc_nump > 5) {\r\ndev_err(&op->dev, "Invalid cell-index property\n");\r\nreturn -EINVAL;\r\n}\r\nid = *psc_nump + 1;\r\n}\r\nreturn mpc52xx_psc_spi_do_probe(&op->dev, (u32)regaddr64, (u32)size64,\r\nirq_of_parse_and_map(op->dev.of_node, 0), id);\r\n}\r\nstatic int mpc52xx_psc_spi_of_remove(struct platform_device *op)\r\n{\r\nstruct spi_master *master = spi_master_get(platform_get_drvdata(op));\r\nstruct mpc52xx_psc_spi *mps = spi_master_get_devdata(master);\r\nflush_workqueue(mps->workqueue);\r\ndestroy_workqueue(mps->workqueue);\r\nspi_unregister_master(master);\r\nfree_irq(mps->irq, mps);\r\nif (mps->psc)\r\niounmap(mps->psc);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
