static unsigned long\r\n__show_trace(unsigned long sp, unsigned long low, unsigned long high)\r\n{\r\nstruct stack_frame *sf;\r\nstruct pt_regs *regs;\r\nunsigned long addr;\r\nwhile (1) {\r\nsp = sp & PSW_ADDR_INSN;\r\nif (sp < low || sp > high - sizeof(*sf))\r\nreturn sp;\r\nsf = (struct stack_frame *) sp;\r\naddr = sf->gprs[8] & PSW_ADDR_INSN;\r\nprintk("([<%016lx>] %pSR)\n", addr, (void *)addr);\r\nwhile (1) {\r\nlow = sp;\r\nsp = sf->back_chain & PSW_ADDR_INSN;\r\nif (!sp)\r\nbreak;\r\nif (sp <= low || sp > high - sizeof(*sf))\r\nreturn sp;\r\nsf = (struct stack_frame *) sp;\r\naddr = sf->gprs[8] & PSW_ADDR_INSN;\r\nprintk(" [<%016lx>] %pSR\n", addr, (void *)addr);\r\n}\r\nsp = (unsigned long) (sf + 1);\r\nif (sp <= low || sp > high - sizeof(*regs))\r\nreturn sp;\r\nregs = (struct pt_regs *) sp;\r\naddr = regs->psw.addr & PSW_ADDR_INSN;\r\nprintk(" [<%016lx>] %pSR\n", addr, (void *)addr);\r\nlow = sp;\r\nsp = regs->gprs[15];\r\n}\r\n}\r\nstatic void show_trace(struct task_struct *task, unsigned long *stack)\r\n{\r\nconst unsigned long frame_size =\r\nSTACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\r\nregister unsigned long __r15 asm ("15");\r\nunsigned long sp;\r\nsp = (unsigned long) stack;\r\nif (!sp)\r\nsp = task ? task->thread.ksp : __r15;\r\nprintk("Call Trace:\n");\r\n#ifdef CONFIG_CHECK_STACK\r\nsp = __show_trace(sp,\r\nS390_lowcore.panic_stack + frame_size - 4096,\r\nS390_lowcore.panic_stack + frame_size);\r\n#endif\r\nsp = __show_trace(sp,\r\nS390_lowcore.async_stack + frame_size - ASYNC_SIZE,\r\nS390_lowcore.async_stack + frame_size);\r\nif (task)\r\n__show_trace(sp, (unsigned long) task_stack_page(task),\r\n(unsigned long) task_stack_page(task) + THREAD_SIZE);\r\nelse\r\n__show_trace(sp, S390_lowcore.thread_info,\r\nS390_lowcore.thread_info + THREAD_SIZE);\r\nif (!task)\r\ntask = current;\r\ndebug_show_held_locks(task);\r\n}\r\nvoid show_stack(struct task_struct *task, unsigned long *sp)\r\n{\r\nregister unsigned long *__r15 asm ("15");\r\nunsigned long *stack;\r\nint i;\r\nif (!sp)\r\nstack = task ? (unsigned long *) task->thread.ksp : __r15;\r\nelse\r\nstack = sp;\r\nfor (i = 0; i < kstack_depth_to_print; i++) {\r\nif (((addr_t) stack & (THREAD_SIZE-1)) == 0)\r\nbreak;\r\nif ((i * sizeof(long) % 32) == 0)\r\nprintk("%s ", i == 0 ? "" : "\n");\r\nprintk(LONG, *stack++);\r\n}\r\nprintk("\n");\r\nshow_trace(task, sp);\r\n}\r\nstatic void show_last_breaking_event(struct pt_regs *regs)\r\n{\r\n#ifdef CONFIG_64BIT\r\nprintk("Last Breaking-Event-Address:\n");\r\nprintk(" [<%016lx>] %pSR\n", regs->args[0], (void *)regs->args[0]);\r\n#endif\r\n}\r\nstatic inline int mask_bits(struct pt_regs *regs, unsigned long bits)\r\n{\r\nreturn (regs->psw.mask & bits) / ((~bits + 1) & bits);\r\n}\r\nvoid show_registers(struct pt_regs *regs)\r\n{\r\nchar *mode;\r\nmode = user_mode(regs) ? "User" : "Krnl";\r\nprintk("%s PSW : %p %p (%pSR)\n",\r\nmode, (void *) regs->psw.mask,\r\n(void *) regs->psw.addr,\r\n(void *) regs->psw.addr);\r\nprintk(" R:%x T:%x IO:%x EX:%x Key:%x M:%x W:%x "\r\n"P:%x AS:%x CC:%x PM:%x", mask_bits(regs, PSW_MASK_PER),\r\nmask_bits(regs, PSW_MASK_DAT), mask_bits(regs, PSW_MASK_IO),\r\nmask_bits(regs, PSW_MASK_EXT), mask_bits(regs, PSW_MASK_KEY),\r\nmask_bits(regs, PSW_MASK_MCHECK), mask_bits(regs, PSW_MASK_WAIT),\r\nmask_bits(regs, PSW_MASK_PSTATE), mask_bits(regs, PSW_MASK_ASC),\r\nmask_bits(regs, PSW_MASK_CC), mask_bits(regs, PSW_MASK_PM));\r\n#ifdef CONFIG_64BIT\r\nprintk(" EA:%x", mask_bits(regs, PSW_MASK_EA | PSW_MASK_BA));\r\n#endif\r\nprintk("\n%s GPRS: " FOURLONG, mode,\r\nregs->gprs[0], regs->gprs[1], regs->gprs[2], regs->gprs[3]);\r\nprintk(" " FOURLONG,\r\nregs->gprs[4], regs->gprs[5], regs->gprs[6], regs->gprs[7]);\r\nprintk(" " FOURLONG,\r\nregs->gprs[8], regs->gprs[9], regs->gprs[10], regs->gprs[11]);\r\nprintk(" " FOURLONG,\r\nregs->gprs[12], regs->gprs[13], regs->gprs[14], regs->gprs[15]);\r\nshow_code(regs);\r\n}\r\nvoid show_regs(struct pt_regs *regs)\r\n{\r\nshow_regs_print_info(KERN_DEFAULT);\r\nshow_registers(regs);\r\nif (!user_mode(regs))\r\nshow_trace(NULL, (unsigned long *) regs->gprs[15]);\r\nshow_last_breaking_event(regs);\r\n}\r\nvoid die(struct pt_regs *regs, const char *str)\r\n{\r\nstatic int die_counter;\r\noops_enter();\r\nlgr_info_log();\r\ndebug_stop_all();\r\nconsole_verbose();\r\nspin_lock_irq(&die_lock);\r\nbust_spinlocks(1);\r\nprintk("%s: %04x [#%d] ", str, regs->int_code & 0xffff, ++die_counter);\r\n#ifdef CONFIG_PREEMPT\r\nprintk("PREEMPT ");\r\n#endif\r\n#ifdef CONFIG_SMP\r\nprintk("SMP ");\r\n#endif\r\n#ifdef CONFIG_DEBUG_PAGEALLOC\r\nprintk("DEBUG_PAGEALLOC");\r\n#endif\r\nprintk("\n");\r\nnotify_die(DIE_OOPS, str, regs, 0, regs->int_code & 0xffff, SIGSEGV);\r\nprint_modules();\r\nshow_regs(regs);\r\nbust_spinlocks(0);\r\nadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\r\nspin_unlock_irq(&die_lock);\r\nif (in_interrupt())\r\npanic("Fatal exception in interrupt");\r\nif (panic_on_oops)\r\npanic("Fatal exception: panic_on_oops");\r\noops_exit();\r\ndo_exit(SIGSEGV);\r\n}
