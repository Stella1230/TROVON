static inline u32\r\nip_to_id(const struct bitmap_ipmac *m, u32 ip)\r\n{\r\nreturn ip - m->first_ip;\r\n}\r\nstatic inline struct bitmap_ipmac_elem *\r\nget_elem(void *extensions, u16 id, size_t dsize)\r\n{\r\nreturn (struct bitmap_ipmac_elem *)(extensions + id * dsize);\r\n}\r\nstatic inline int\r\nbitmap_ipmac_do_test(const struct bitmap_ipmac_adt_elem *e,\r\nconst struct bitmap_ipmac *map, size_t dsize)\r\n{\r\nconst struct bitmap_ipmac_elem *elem;\r\nif (!test_bit(e->id, map->members))\r\nreturn 0;\r\nelem = get_elem(map->extensions, e->id, dsize);\r\nif (elem->filled == MAC_FILLED)\r\nreturn e->ether == NULL ||\r\nether_addr_equal(e->ether, elem->ether);\r\nreturn -EAGAIN;\r\n}\r\nstatic inline int\r\nbitmap_ipmac_gc_test(u16 id, const struct bitmap_ipmac *map, size_t dsize)\r\n{\r\nconst struct bitmap_ipmac_elem *elem;\r\nif (!test_bit(id, map->members))\r\nreturn 0;\r\nelem = get_elem(map->extensions, id, dsize);\r\nreturn elem->filled == MAC_FILLED;\r\n}\r\nstatic inline int\r\nbitmap_ipmac_is_filled(const struct bitmap_ipmac_elem *elem)\r\n{\r\nreturn elem->filled == MAC_FILLED;\r\n}\r\nstatic inline int\r\nbitmap_ipmac_add_timeout(unsigned long *timeout,\r\nconst struct bitmap_ipmac_adt_elem *e,\r\nconst struct ip_set_ext *ext, struct ip_set *set,\r\nstruct bitmap_ipmac *map, int mode)\r\n{\r\nu32 t = ext->timeout;\r\nif (mode == IPSET_ADD_START_STORED_TIMEOUT) {\r\nif (t == set->timeout)\r\nt = *timeout;\r\nip_set_timeout_set(timeout, t);\r\n} else {\r\nif (e->ether)\r\nip_set_timeout_set(timeout, t);\r\nelse\r\n*timeout = t;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nbitmap_ipmac_do_add(const struct bitmap_ipmac_adt_elem *e,\r\nstruct bitmap_ipmac *map, u32 flags, size_t dsize)\r\n{\r\nstruct bitmap_ipmac_elem *elem;\r\nelem = get_elem(map->extensions, e->id, dsize);\r\nif (test_and_set_bit(e->id, map->members)) {\r\nif (elem->filled == MAC_FILLED) {\r\nif (e->ether && (flags & IPSET_FLAG_EXIST))\r\nmemcpy(elem->ether, e->ether, ETH_ALEN);\r\nreturn IPSET_ADD_FAILED;\r\n} else if (!e->ether)\r\nreturn IPSET_ADD_FAILED;\r\nmemcpy(elem->ether, e->ether, ETH_ALEN);\r\nelem->filled = MAC_FILLED;\r\nreturn IPSET_ADD_START_STORED_TIMEOUT;\r\n} else if (e->ether) {\r\nmemcpy(elem->ether, e->ether, ETH_ALEN);\r\nelem->filled = MAC_FILLED;\r\nreturn 0;\r\n} else {\r\nelem->filled = MAC_UNSET;\r\nreturn IPSET_ADD_STORE_PLAIN_TIMEOUT;\r\n}\r\n}\r\nstatic inline int\r\nbitmap_ipmac_do_del(const struct bitmap_ipmac_adt_elem *e,\r\nstruct bitmap_ipmac *map)\r\n{\r\nreturn !test_and_clear_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_ipmac_do_list(struct sk_buff *skb, const struct bitmap_ipmac *map,\r\nu32 id, size_t dsize)\r\n{\r\nconst struct bitmap_ipmac_elem *elem =\r\nget_elem(map->extensions, id, dsize);\r\nreturn nla_put_ipaddr4(skb, IPSET_ATTR_IP,\r\nhtonl(map->first_ip + id)) ||\r\n(elem->filled == MAC_FILLED &&\r\nnla_put(skb, IPSET_ATTR_ETHER, ETH_ALEN, elem->ether));\r\n}\r\nstatic inline int\r\nbitmap_ipmac_do_head(struct sk_buff *skb, const struct bitmap_ipmac *map)\r\n{\r\nreturn nla_put_ipaddr4(skb, IPSET_ATTR_IP, htonl(map->first_ip)) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP_TO, htonl(map->last_ip));\r\n}\r\nstatic int\r\nbitmap_ipmac_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_ipmac *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct bitmap_ipmac_adt_elem e = {};\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\nu32 ip;\r\nif (!(opt->flags & IPSET_DIM_TWO_SRC))\r\nreturn 0;\r\nip = ntohl(ip4addr(skb, opt->flags & IPSET_DIM_ONE_SRC));\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nif (skb_mac_header(skb) < skb->head ||\r\n(skb_mac_header(skb) + ETH_HLEN) > skb->data)\r\nreturn -EINVAL;\r\ne.id = ip_to_id(map, ip);\r\ne.ether = eth_hdr(skb)->h_source;\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_ipmac_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct bitmap_ipmac *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct bitmap_ipmac_adt_elem e = {};\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nu32 ip = 0;\r\nint ret = 0;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip) ||\r\nip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nif (ip < map->first_ip || ip > map->last_ip)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\ne.id = ip_to_id(map, ip);\r\nif (tb[IPSET_ATTR_ETHER])\r\ne.ether = nla_data(tb[IPSET_ATTR_ETHER]);\r\nelse\r\ne.ether = NULL;\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nreturn ip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic bool\r\nbitmap_ipmac_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_ipmac *x = a->data;\r\nconst struct bitmap_ipmac *y = b->data;\r\nreturn x->first_ip == y->first_ip &&\r\nx->last_ip == y->last_ip &&\r\na->timeout == b->timeout &&\r\na->extensions == b->extensions;\r\n}\r\nstatic bool\r\ninit_map_ipmac(struct ip_set *set, struct bitmap_ipmac *map,\r\nu32 first_ip, u32 last_ip, u32 elements)\r\n{\r\nmap->members = ip_set_alloc(map->memsize);\r\nif (!map->members)\r\nreturn false;\r\nif (set->dsize) {\r\nmap->extensions = ip_set_alloc(set->dsize * elements);\r\nif (!map->extensions) {\r\nkfree(map->members);\r\nreturn false;\r\n}\r\n}\r\nmap->first_ip = first_ip;\r\nmap->last_ip = last_ip;\r\nmap->elements = elements;\r\nset->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = NFPROTO_IPV4;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_ipmac_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nu32 first_ip = 0, last_ip = 0;\r\nu64 elements;\r\nstruct bitmap_ipmac *map;\r\nint ret;\r\nif (unlikely(!tb[IPSET_ATTR_IP] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &first_ip);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &last_ip);\r\nif (ret)\r\nreturn ret;\r\nif (first_ip > last_ip) {\r\nu32 tmp = first_ip;\r\nfirst_ip = last_ip;\r\nlast_ip = tmp;\r\n}\r\n} else if (tb[IPSET_ATTR_CIDR]) {\r\nu8 cidr = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (cidr >= 32)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\nip_set_mask_from_to(first_ip, last_ip, cidr);\r\n} else\r\nreturn -IPSET_ERR_PROTOCOL;\r\nelements = (u64)last_ip - first_ip + 1;\r\nif (elements > IPSET_BITMAP_MAX_RANGE + 1)\r\nreturn -IPSET_ERR_BITMAP_RANGE_SIZE;\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nmap->memsize = bitmap_bytes(0, elements - 1);\r\nset->variant = &bitmap_ipmac;\r\nset->dsize = ip_set_elem_len(set, tb,\r\nsizeof(struct bitmap_ipmac_elem));\r\nif (!init_map_ipmac(set, map, first_ip, last_ip, elements)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nbitmap_ipmac_gc_init(set, bitmap_ipmac_gc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_ipmac_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_ipmac_type);\r\n}\r\nstatic void __exit\r\nbitmap_ipmac_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_ipmac_type);\r\n}
