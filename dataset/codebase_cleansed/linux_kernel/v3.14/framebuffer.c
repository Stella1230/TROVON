static int psbfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct psb_fbdev *fbdev = info->par;\r\nstruct drm_framebuffer *fb = fbdev->psb_fb_helper.fb;\r\nuint32_t v;\r\nif (!fb)\r\nreturn -ENOMEM;\r\nif (regno > 255)\r\nreturn 1;\r\nred = CMAP_TOHW(red, info->var.red.length);\r\nblue = CMAP_TOHW(blue, info->var.blue.length);\r\ngreen = CMAP_TOHW(green, info->var.green.length);\r\ntransp = CMAP_TOHW(transp, info->var.transp.length);\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nif (regno < 16) {\r\nswitch (fb->bits_per_pixel) {\r\ncase 16:\r\n((uint32_t *) info->pseudo_palette)[regno] = v;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\n((uint32_t *) info->pseudo_palette)[regno] = v;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int psbfb_pan(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct psb_fbdev *fbdev = info->par;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nstruct drm_device *dev = psbfb->base.dev;\r\nif (psbfb->gtt->npage) {\r\nint pages = info->fix.line_length >> 12;\r\npsb_gtt_roll(dev, psbfb->gtt, var->yoffset * pages);\r\n}\r\nreturn 0;\r\n}\r\nstatic int psbfb_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct psb_framebuffer *psbfb = vma->vm_private_data;\r\nstruct drm_device *dev = psbfb->base.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint page_num;\r\nint i;\r\nunsigned long address;\r\nint ret;\r\nunsigned long pfn;\r\nunsigned long phys_addr = (unsigned long)dev_priv->stolen_base +\r\npsbfb->gtt->offset;\r\npage_num = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\naddress = (unsigned long)vmf->virtual_address - (vmf->pgoff << PAGE_SHIFT);\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nfor (i = 0; i < page_num; i++) {\r\npfn = (phys_addr >> PAGE_SHIFT);\r\nret = vm_insert_mixed(vma, address, pfn);\r\nif (unlikely((ret == -EBUSY) || (ret != 0 && i > 0)))\r\nbreak;\r\nelse if (unlikely(ret != 0)) {\r\nret = (ret == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;\r\nreturn ret;\r\n}\r\naddress += PAGE_SIZE;\r\nphys_addr += PAGE_SIZE;\r\n}\r\nreturn VM_FAULT_NOPAGE;\r\n}\r\nstatic void psbfb_vm_open(struct vm_area_struct *vma)\r\n{\r\n}\r\nstatic void psbfb_vm_close(struct vm_area_struct *vma)\r\n{\r\n}\r\nstatic int psbfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct psb_fbdev *fbdev = info->par;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nif (vma->vm_pgoff != 0)\r\nreturn -EINVAL;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\nif (!psbfb->addr_space)\r\npsbfb->addr_space = vma->vm_file->f_mapping;\r\nvma->vm_ops = &psbfb_vm_ops;\r\nvma->vm_private_data = (void *)psbfb;\r\nvma->vm_flags |= VM_IO | VM_MIXEDMAP | VM_DONTEXPAND | VM_DONTDUMP;\r\nreturn 0;\r\n}\r\nstatic int psbfb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn -ENOTTY;\r\n}\r\nstatic int psb_framebuffer_init(struct drm_device *dev,\r\nstruct psb_framebuffer *fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct gtt_range *gt)\r\n{\r\nu32 bpp, depth;\r\nint ret;\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &depth, &bpp);\r\nif (mode_cmd->pitches[0] & 63)\r\nreturn -EINVAL;\r\nswitch (bpp) {\r\ncase 8:\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndrm_helper_mode_fill_fb_struct(&fb->base, mode_cmd);\r\nfb->gtt = gt;\r\nret = drm_framebuffer_init(dev, &fb->base, &psb_fb_funcs);\r\nif (ret) {\r\ndev_err(dev->dev, "framebuffer init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *psb_framebuffer_create\r\n(struct drm_device *dev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct gtt_range *gt)\r\n{\r\nstruct psb_framebuffer *fb;\r\nint ret;\r\nfb = kzalloc(sizeof(*fb), GFP_KERNEL);\r\nif (!fb)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = psb_framebuffer_init(dev, fb, mode_cmd, gt);\r\nif (ret) {\r\nkfree(fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &fb->base;\r\n}\r\nstatic struct gtt_range *psbfb_alloc(struct drm_device *dev, int aligned_size)\r\n{\r\nstruct gtt_range *backing;\r\nbacking = psb_gtt_alloc_range(dev, aligned_size, "fb", 1);\r\nif (backing) {\r\ndrm_gem_private_object_init(dev, &backing->gem, aligned_size);\r\nreturn backing;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int psbfb_create(struct psb_fbdev *fbdev,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct drm_device *dev = fbdev->psb_fb_helper.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct device *device = &dev->pdev->dev;\r\nint size;\r\nint ret;\r\nstruct gtt_range *backing;\r\nu32 bpp, depth;\r\nint gtt_roll = 0;\r\nint pitch_lines = 0;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nbpp = sizes->surface_bpp;\r\ndepth = sizes->surface_depth;\r\nif (bpp == 24)\r\nbpp = 32;\r\ndo {\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.width * ((bpp + 7) / 8), 4096 >> pitch_lines);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = ALIGN(size, PAGE_SIZE);\r\nbacking = psbfb_alloc(dev, size);\r\nif (pitch_lines)\r\npitch_lines *= 2;\r\nelse\r\npitch_lines = 1;\r\ngtt_roll++;\r\n} while (backing == NULL && pitch_lines <= 16);\r\npitch_lines /= 2;\r\nif (backing == NULL) {\r\ngtt_roll = 0;\r\npitch_lines = 64;\r\nmode_cmd.pitches[0] = ALIGN(mode_cmd.width * ((bpp + 7) / 8), 64);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = ALIGN(size, PAGE_SIZE);\r\nbacking = psbfb_alloc(dev, size);\r\nif (backing == NULL)\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev_priv->vram_addr + backing->offset, 0, size);\r\nmutex_lock(&dev->struct_mutex);\r\ninfo = framebuffer_alloc(0, device);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_err1;\r\n}\r\ninfo->par = fbdev;\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);\r\nret = psb_framebuffer_init(dev, psbfb, &mode_cmd, backing);\r\nif (ret)\r\ngoto out_unref;\r\nfb = &psbfb->base;\r\npsbfb->fbdev = info;\r\nfbdev->psb_fb_helper.fb = fb;\r\nfbdev->psb_fb_helper.fbdev = info;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\nstrcpy(info->fix.id, "psbdrmfb");\r\ninfo->flags = FBINFO_DEFAULT;\r\nif (dev_priv->ops->accel_2d && pitch_lines > 8)\r\ninfo->fbops = &psbfb_ops;\r\nelse if (gtt_roll) {\r\ninfo->fbops = &psbfb_roll_ops;\r\ninfo->flags |= FBINFO_HWACCEL_YPAN;\r\n} else\r\ninfo->fbops = &psbfb_unaccel_ops;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->fix.smem_start = dev->mode_config.fb_base;\r\ninfo->fix.smem_len = size;\r\ninfo->fix.ywrapstep = gtt_roll;\r\ninfo->fix.ypanstep = 0;\r\ninfo->screen_base = dev_priv->vram_addr + backing->offset;\r\ninfo->screen_size = size;\r\nif (dev_priv->gtt.stolen_size) {\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out_unref;\r\n}\r\ninfo->apertures->ranges[0].base = dev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size = dev_priv->gtt.stolen_size;\r\n}\r\ndrm_fb_helper_fill_var(info, &fbdev->psb_fb_helper,\r\nsizes->fb_width, sizes->fb_height);\r\ninfo->fix.mmio_start = pci_resource_start(dev->pdev, 0);\r\ninfo->fix.mmio_len = pci_resource_len(dev->pdev, 0);\r\ndev_dbg(dev->dev, "allocated %dx%d fb\n",\r\npsbfb->base.width, psbfb->base.height);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\nout_unref:\r\nif (backing->stolen)\r\npsb_gtt_free_range(dev, backing);\r\nelse\r\ndrm_gem_object_unreference(&backing->gem);\r\nout_err1:\r\nmutex_unlock(&dev->struct_mutex);\r\npsb_gtt_free_range(dev, backing);\r\nreturn ret;\r\n}\r\nstatic struct drm_framebuffer *psb_user_framebuffer_create\r\n(struct drm_device *dev, struct drm_file *filp,\r\nstruct drm_mode_fb_cmd2 *cmd)\r\n{\r\nstruct gtt_range *r;\r\nstruct drm_gem_object *obj;\r\nobj = drm_gem_object_lookup(dev, filp, cmd->handles[0]);\r\nif (obj == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\nr = container_of(obj, struct gtt_range, gem);\r\nreturn psb_framebuffer_create(dev, cmd, r);\r\n}\r\nstatic void psbfb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\ngma_crtc->lut_r[regno] = red >> 8;\r\ngma_crtc->lut_g[regno] = green >> 8;\r\ngma_crtc->lut_b[regno] = blue >> 8;\r\n}\r\nstatic void psbfb_gamma_get(struct drm_crtc *crtc, u16 *red,\r\nu16 *green, u16 *blue, int regno)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\n*red = gma_crtc->lut_r[regno] << 8;\r\n*green = gma_crtc->lut_g[regno] << 8;\r\n*blue = gma_crtc->lut_b[regno] << 8;\r\n}\r\nstatic int psbfb_probe(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct psb_fbdev *psb_fbdev = (struct psb_fbdev *)helper;\r\nstruct drm_device *dev = psb_fbdev->psb_fb_helper.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint bytespp;\r\nbytespp = sizes->surface_bpp / 8;\r\nif (bytespp == 3)\r\nbytespp = 4;\r\nif (ALIGN(sizes->fb_width * bytespp, 64) * sizes->fb_height >\r\ndev_priv->vram_stolen_size) {\r\nsizes->surface_bpp = 16;\r\nsizes->surface_depth = 16;\r\n}\r\nreturn psbfb_create(psb_fbdev, sizes);\r\n}\r\nstatic int psb_fbdev_destroy(struct drm_device *dev, struct psb_fbdev *fbdev)\r\n{\r\nstruct fb_info *info;\r\nstruct psb_framebuffer *psbfb = &fbdev->pfb;\r\nif (fbdev->psb_fb_helper.fbdev) {\r\ninfo = fbdev->psb_fb_helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\ndrm_fb_helper_fini(&fbdev->psb_fb_helper);\r\ndrm_framebuffer_unregister_private(&psbfb->base);\r\ndrm_framebuffer_cleanup(&psbfb->base);\r\nif (psbfb->gtt)\r\ndrm_gem_object_unreference(&psbfb->gtt->gem);\r\nreturn 0;\r\n}\r\nint psb_fbdev_init(struct drm_device *dev)\r\n{\r\nstruct psb_fbdev *fbdev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nfbdev = kzalloc(sizeof(struct psb_fbdev), GFP_KERNEL);\r\nif (!fbdev) {\r\ndev_err(dev->dev, "no memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_priv->fbdev = fbdev;\r\nfbdev->psb_fb_helper.funcs = &psb_fb_helper_funcs;\r\ndrm_fb_helper_init(dev, &fbdev->psb_fb_helper, dev_priv->ops->crtcs,\r\nINTELFB_CONN_LIMIT);\r\ndrm_fb_helper_single_add_all_connectors(&fbdev->psb_fb_helper);\r\ndrm_helper_disable_unused_functions(dev);\r\ndrm_fb_helper_initial_config(&fbdev->psb_fb_helper, 32);\r\nreturn 0;\r\n}\r\nstatic void psb_fbdev_fini(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!dev_priv->fbdev)\r\nreturn;\r\npsb_fbdev_destroy(dev, dev_priv->fbdev);\r\nkfree(dev_priv->fbdev);\r\ndev_priv->fbdev = NULL;\r\n}\r\nstatic void psbfb_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_fbdev *fbdev = (struct psb_fbdev *)dev_priv->fbdev;\r\ndrm_fb_helper_hotplug_event(&fbdev->psb_fb_helper);\r\n}\r\nstatic int psb_user_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct psb_framebuffer *psbfb = to_psb_fb(fb);\r\nstruct gtt_range *r = psbfb->gtt;\r\nreturn drm_gem_handle_create(file_priv, &r->gem, handle);\r\n}\r\nstatic void psb_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct psb_framebuffer *psbfb = to_psb_fb(fb);\r\nstruct gtt_range *r = psbfb->gtt;\r\ndrm_framebuffer_cleanup(fb);\r\ndrm_gem_object_unreference_unlocked(&r->gem);\r\nkfree(fb);\r\n}\r\nstatic int psb_create_backlight_property(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_property *backlight;\r\nif (dev_priv->backlight_property)\r\nreturn 0;\r\nbacklight = drm_property_create_range(dev, 0, "backlight", 0, 100);\r\ndev_priv->backlight_property = backlight;\r\nreturn 0;\r\n}\r\nstatic void psb_setup_outputs(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_connector *connector;\r\ndrm_mode_create_scaling_mode_property(dev);\r\npsb_create_backlight_property(dev);\r\ndev_priv->ops->output_init(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nstruct drm_encoder *encoder = &gma_encoder->base;\r\nint crtc_mask = 0, clone_mask = 0;\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_ANALOG:\r\ncrtc_mask = (1 << 0);\r\nclone_mask = (1 << INTEL_OUTPUT_ANALOG);\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\ncrtc_mask = dev_priv->ops->sdvo_mask;\r\nclone_mask = (1 << INTEL_OUTPUT_SDVO);\r\nbreak;\r\ncase INTEL_OUTPUT_LVDS:\r\ncrtc_mask = dev_priv->ops->lvds_mask;\r\nclone_mask = (1 << INTEL_OUTPUT_LVDS);\r\nbreak;\r\ncase INTEL_OUTPUT_MIPI:\r\ncrtc_mask = (1 << 0);\r\nclone_mask = (1 << INTEL_OUTPUT_MIPI);\r\nbreak;\r\ncase INTEL_OUTPUT_MIPI2:\r\ncrtc_mask = (1 << 2);\r\nclone_mask = (1 << INTEL_OUTPUT_MIPI2);\r\nbreak;\r\ncase INTEL_OUTPUT_HDMI:\r\ncrtc_mask = dev_priv->ops->hdmi_mask;\r\nclone_mask = (1 << INTEL_OUTPUT_HDMI);\r\nbreak;\r\ncase INTEL_OUTPUT_DISPLAYPORT:\r\ncrtc_mask = (1 << 0) | (1 << 1);\r\nclone_mask = (1 << INTEL_OUTPUT_DISPLAYPORT);\r\nbreak;\r\ncase INTEL_OUTPUT_EDP:\r\ncrtc_mask = (1 << 1);\r\nclone_mask = (1 << INTEL_OUTPUT_EDP);\r\n}\r\nencoder->possible_crtcs = crtc_mask;\r\nencoder->possible_clones =\r\ngma_connector_clones(dev, clone_mask);\r\n}\r\n}\r\nvoid psb_modeset_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\r\nint i;\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.min_width = 0;\r\ndev->mode_config.min_height = 0;\r\ndev->mode_config.funcs = &psb_mode_funcs;\r\npci_read_config_dword(dev->pdev, PSB_BSM, (u32 *)\r\n&(dev->mode_config.fb_base));\r\nfor (i = 0; i < dev_priv->num_pipe; i++)\r\npsb_intel_crtc_init(dev, i, mode_dev);\r\ndev->mode_config.max_width = 4096;\r\ndev->mode_config.max_height = 4096;\r\npsb_setup_outputs(dev);\r\nif (dev_priv->ops->errata)\r\ndev_priv->ops->errata(dev);\r\ndev_priv->modeset = true;\r\n}\r\nvoid psb_modeset_cleanup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv->modeset) {\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_kms_helper_poll_fini(dev);\r\npsb_fbdev_fini(dev);\r\ndrm_mode_config_cleanup(dev);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\n}
