static int zd1201_fw_upload(struct usb_device *dev, int apfw)\r\n{\r\nconst struct firmware *fw_entry;\r\nconst char *data;\r\nunsigned long len;\r\nint err;\r\nunsigned char ret;\r\nchar *buf;\r\nchar *fwfile;\r\nif (apfw)\r\nfwfile = "zd1201-ap.fw";\r\nelse\r\nfwfile = "zd1201.fw";\r\nerr = request_firmware(&fw_entry, fwfile, &dev->dev);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to load %s firmware file!\n", fwfile);\r\ndev_err(&dev->dev, "Make sure the hotplug firmware loader is installed.\n");\r\ndev_err(&dev->dev, "Goto http://linux-lc100020.sourceforge.net for more info.\n");\r\nreturn err;\r\n}\r\ndata = fw_entry->data;\r\nlen = fw_entry->size;\r\nbuf = kmalloc(1024, GFP_ATOMIC);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nwhile (len > 0) {\r\nint translen = (len > 1024) ? 1024 : len;\r\nmemcpy(buf, data, translen);\r\nerr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), 0,\r\nUSB_DIR_OUT | 0x40, 0, 0, buf, translen,\r\nZD1201_FW_TIMEOUT);\r\nif (err < 0)\r\ngoto exit;\r\nlen -= translen;\r\ndata += translen;\r\n}\r\nerr = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), 0x2,\r\nUSB_DIR_OUT | 0x40, 0, 0, NULL, 0, ZD1201_FW_TIMEOUT);\r\nif (err < 0)\r\ngoto exit;\r\nerr = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), 0x4,\r\nUSB_DIR_IN | 0x40, 0, 0, buf, sizeof(ret), ZD1201_FW_TIMEOUT);\r\nif (err < 0)\r\ngoto exit;\r\nmemcpy(&ret, buf, sizeof(ret));\r\nif (ret & 0x80) {\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nerr = 0;\r\nexit:\r\nkfree(buf);\r\nrelease_firmware(fw_entry);\r\nreturn err;\r\n}\r\nstatic void zd1201_usbfree(struct urb *urb)\r\n{\r\nstruct zd1201 *zd = urb->context;\r\nswitch(urb->status) {\r\ncase -EILSEQ:\r\ncase -ENODEV:\r\ncase -ETIME:\r\ncase -ENOENT:\r\ncase -EPIPE:\r\ncase -EOVERFLOW:\r\ncase -ESHUTDOWN:\r\ndev_warn(&zd->usb->dev, "%s: urb failed: %d\n",\r\nzd->dev->name, urb->status);\r\n}\r\nkfree(urb->transfer_buffer);\r\nusb_free_urb(urb);\r\n}\r\nstatic int zd1201_docmd(struct zd1201 *zd, int cmd, int parm0,\r\nint parm1, int parm2)\r\n{\r\nunsigned char *command;\r\nint ret;\r\nstruct urb *urb;\r\ncommand = kmalloc(16, GFP_ATOMIC);\r\nif (!command)\r\nreturn -ENOMEM;\r\n*((__le32*)command) = cpu_to_le32(ZD1201_USB_CMDREQ);\r\n*((__le16*)&command[4]) = cpu_to_le16(cmd);\r\n*((__le16*)&command[6]) = cpu_to_le16(parm0);\r\n*((__le16*)&command[8]) = cpu_to_le16(parm1);\r\n*((__le16*)&command[10])= cpu_to_le16(parm2);\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nkfree(command);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out2),\r\ncommand, 16, zd1201_usbfree, zd);\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret) {\r\nkfree(command);\r\nusb_free_urb(urb);\r\n}\r\nreturn ret;\r\n}\r\nstatic void zd1201_usbtx(struct urb *urb)\r\n{\r\nstruct zd1201 *zd = urb->context;\r\nnetif_wake_queue(zd->dev);\r\n}\r\nstatic void zd1201_usbrx(struct urb *urb)\r\n{\r\nstruct zd1201 *zd = urb->context;\r\nint free = 0;\r\nunsigned char *data = urb->transfer_buffer;\r\nstruct sk_buff *skb;\r\nunsigned char type;\r\nif (!zd)\r\nreturn;\r\nswitch(urb->status) {\r\ncase -EILSEQ:\r\ncase -ENODEV:\r\ncase -ETIME:\r\ncase -ENOENT:\r\ncase -EPIPE:\r\ncase -EOVERFLOW:\r\ncase -ESHUTDOWN:\r\ndev_warn(&zd->usb->dev, "%s: rx urb failed: %d\n",\r\nzd->dev->name, urb->status);\r\nfree = 1;\r\ngoto exit;\r\n}\r\nif (urb->status != 0 || urb->actual_length == 0)\r\ngoto resubmit;\r\ntype = data[0];\r\nif (type == ZD1201_PACKET_EVENTSTAT || type == ZD1201_PACKET_RESOURCE) {\r\nmemcpy(zd->rxdata, data, urb->actual_length);\r\nzd->rxlen = urb->actual_length;\r\nzd->rxdatas = 1;\r\nwake_up(&zd->rxdataq);\r\n}\r\nif (type == ZD1201_PACKET_INQUIRE) {\r\nint i = 0;\r\nunsigned short infotype, framelen, copylen;\r\nframelen = le16_to_cpu(*(__le16*)&data[4]);\r\ninfotype = le16_to_cpu(*(__le16*)&data[6]);\r\nif (infotype == ZD1201_INF_LINKSTATUS) {\r\nshort linkstatus;\r\nlinkstatus = le16_to_cpu(*(__le16*)&data[8]);\r\nswitch(linkstatus) {\r\ncase 1:\r\nnetif_carrier_on(zd->dev);\r\nbreak;\r\ncase 2:\r\nnetif_carrier_off(zd->dev);\r\nbreak;\r\ncase 3:\r\nnetif_carrier_off(zd->dev);\r\nbreak;\r\ncase 4:\r\nnetif_carrier_on(zd->dev);\r\nbreak;\r\ndefault:\r\nnetif_carrier_off(zd->dev);\r\n}\r\ngoto resubmit;\r\n}\r\nif (infotype == ZD1201_INF_ASSOCSTATUS) {\r\nshort status = le16_to_cpu(*(__le16*)(data+8));\r\nint event;\r\nunion iwreq_data wrqu;\r\nswitch (status) {\r\ncase ZD1201_ASSOCSTATUS_STAASSOC:\r\ncase ZD1201_ASSOCSTATUS_REASSOC:\r\nevent = IWEVREGISTERED;\r\nbreak;\r\ncase ZD1201_ASSOCSTATUS_DISASSOC:\r\ncase ZD1201_ASSOCSTATUS_ASSOCFAIL:\r\ncase ZD1201_ASSOCSTATUS_AUTHFAIL:\r\ndefault:\r\nevent = IWEVEXPIRED;\r\n}\r\nmemcpy(wrqu.addr.sa_data, data+10, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(zd->dev, event, &wrqu, NULL);\r\ngoto resubmit;\r\n}\r\nif (infotype == ZD1201_INF_AUTHREQ) {\r\nunion iwreq_data wrqu;\r\nmemcpy(wrqu.addr.sa_data, data+8, ETH_ALEN);\r\nwrqu.addr.sa_family = ARPHRD_ETHER;\r\nwireless_send_event(zd->dev, IWEVEXPIRED, &wrqu, NULL);\r\ngoto resubmit;\r\n}\r\nzd->rxlen = 0;\r\nwhile (i < urb->actual_length) {\r\ncopylen = le16_to_cpu(*(__le16*)&data[i+2]);\r\nif (copylen+zd->rxlen > sizeof(zd->rxdata))\r\nbreak;\r\nmemcpy(zd->rxdata+zd->rxlen, data+i+4, copylen);\r\nzd->rxlen += copylen;\r\ni += 64;\r\n}\r\nif (i >= urb->actual_length) {\r\nzd->rxdatas = 1;\r\nwake_up(&zd->rxdataq);\r\n}\r\ngoto resubmit;\r\n}\r\nif (data[urb->actual_length-1] == ZD1201_PACKET_RXDATA) {\r\nint datalen = urb->actual_length-1;\r\nunsigned short len, fc, seq;\r\nlen = ntohs(*(__be16 *)&data[datalen-2]);\r\nif (len>datalen)\r\nlen=datalen;\r\nfc = le16_to_cpu(*(__le16 *)&data[datalen-16]);\r\nseq = le16_to_cpu(*(__le16 *)&data[datalen-24]);\r\nif (zd->monitor) {\r\nif (datalen < 24)\r\ngoto resubmit;\r\nif (!(skb = dev_alloc_skb(datalen+24)))\r\ngoto resubmit;\r\nmemcpy(skb_put(skb, 2), &data[datalen-16], 2);\r\nmemcpy(skb_put(skb, 2), &data[datalen-2], 2);\r\nmemcpy(skb_put(skb, 6), &data[datalen-14], 6);\r\nmemcpy(skb_put(skb, 6), &data[datalen-22], 6);\r\nmemcpy(skb_put(skb, 6), &data[datalen-8], 6);\r\nmemcpy(skb_put(skb, 2), &data[datalen-24], 2);\r\nmemcpy(skb_put(skb, len), data, len);\r\nskb->protocol = eth_type_trans(skb, zd->dev);\r\nzd->dev->stats.rx_packets++;\r\nzd->dev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\ngoto resubmit;\r\n}\r\nif ((seq & IEEE80211_SCTL_FRAG) ||\r\n(fc & IEEE80211_FCTL_MOREFRAGS)) {\r\nstruct zd1201_frag *frag = NULL;\r\nchar *ptr;\r\nif (datalen<14)\r\ngoto resubmit;\r\nif ((seq & IEEE80211_SCTL_FRAG) == 0) {\r\nfrag = kmalloc(sizeof(*frag), GFP_ATOMIC);\r\nif (!frag)\r\ngoto resubmit;\r\nskb = dev_alloc_skb(IEEE80211_MAX_DATA_LEN +14+2);\r\nif (!skb) {\r\nkfree(frag);\r\ngoto resubmit;\r\n}\r\nfrag->skb = skb;\r\nfrag->seq = seq & IEEE80211_SCTL_SEQ;\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, 12), &data[datalen-14], 12);\r\nmemcpy(skb_put(skb, 2), &data[6], 2);\r\nmemcpy(skb_put(skb, len), data+8, len);\r\nhlist_add_head(&frag->fnode, &zd->fraglist);\r\ngoto resubmit;\r\n}\r\nhlist_for_each_entry(frag, &zd->fraglist, fnode)\r\nif (frag->seq == (seq&IEEE80211_SCTL_SEQ))\r\nbreak;\r\nif (!frag)\r\ngoto resubmit;\r\nskb = frag->skb;\r\nptr = skb_put(skb, len);\r\nif (ptr)\r\nmemcpy(ptr, data+8, len);\r\nif (fc & IEEE80211_FCTL_MOREFRAGS)\r\ngoto resubmit;\r\nhlist_del_init(&frag->fnode);\r\nkfree(frag);\r\n} else {\r\nif (datalen<14)\r\ngoto resubmit;\r\nskb = dev_alloc_skb(len + 14 + 2);\r\nif (!skb)\r\ngoto resubmit;\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, 12), &data[datalen-14], 12);\r\nmemcpy(skb_put(skb, 2), &data[6], 2);\r\nmemcpy(skb_put(skb, len), data+8, len);\r\n}\r\nskb->protocol = eth_type_trans(skb, zd->dev);\r\nzd->dev->stats.rx_packets++;\r\nzd->dev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\nresubmit:\r\nmemset(data, 0, ZD1201_RXSIZE);\r\nurb->status = 0;\r\nurb->dev = zd->usb;\r\nif(usb_submit_urb(urb, GFP_ATOMIC))\r\nfree = 1;\r\nexit:\r\nif (free) {\r\nzd->rxlen = 0;\r\nzd->rxdatas = 1;\r\nwake_up(&zd->rxdataq);\r\nkfree(urb->transfer_buffer);\r\n}\r\n}\r\nstatic int zd1201_getconfig(struct zd1201 *zd, int rid, void *riddata,\r\nunsigned int riddatalen)\r\n{\r\nint err;\r\nint i = 0;\r\nint code;\r\nint rid_fid;\r\nint length;\r\nunsigned char *pdata;\r\nzd->rxdatas = 0;\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_ACCESS, rid, 0, 0);\r\nif (err)\r\nreturn err;\r\nwait_event_interruptible(zd->rxdataq, zd->rxdatas);\r\nif (!zd->rxlen)\r\nreturn -EIO;\r\ncode = le16_to_cpu(*(__le16*)(&zd->rxdata[4]));\r\nrid_fid = le16_to_cpu(*(__le16*)(&zd->rxdata[6]));\r\nlength = le16_to_cpu(*(__le16*)(&zd->rxdata[8]));\r\nif (length > zd->rxlen)\r\nlength = zd->rxlen-6;\r\nif ((code & ZD1201_ACCESSBIT) != ZD1201_ACCESSBIT || rid_fid != rid )\r\nreturn -EINVAL;\r\nif (riddatalen != (length - 4)) {\r\ndev_dbg(&zd->usb->dev, "riddatalen mismatches, expected=%u, (packet=%u) length=%u, rid=0x%04X, rid_fid=0x%04X\n",\r\nriddatalen, zd->rxlen, length, rid, rid_fid);\r\nreturn -ENODATA;\r\n}\r\nzd->rxdatas = 0;\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_SETRXRID, rid, 0, length);\r\nif (err)\r\nreturn err;\r\nwait_event_interruptible(zd->rxdataq, zd->rxdatas);\r\nif (!zd->rxlen)\r\nreturn -EIO;\r\nif (zd->rxdata[zd->rxlen - 1] != ZD1201_PACKET_RESOURCE) {\r\ndev_dbg(&zd->usb->dev, "Packet type mismatch: 0x%x not 0x3\n",\r\nzd->rxdata[zd->rxlen-1]);\r\nreturn -EINVAL;\r\n}\r\npdata = zd->rxdata;\r\nlength = zd->rxlen;\r\ndo {\r\nint actual_length;\r\nactual_length = (length > 64) ? 64 : length;\r\nif (pdata[0] != 0x3) {\r\ndev_dbg(&zd->usb->dev, "Rx Resource packet type error: %02X\n",\r\npdata[0]);\r\nreturn -EINVAL;\r\n}\r\nif (actual_length != 64) {\r\nactual_length--;\r\n}\r\nif (i == 0) {\r\npdata += 8;\r\nactual_length -= 8;\r\n} else {\r\npdata += 4;\r\nactual_length -= 4;\r\n}\r\nmemcpy(riddata, pdata, actual_length);\r\nriddata += actual_length;\r\npdata += actual_length;\r\nlength -= 64;\r\ni++;\r\n} while (length > 0);\r\nreturn 0;\r\n}\r\nstatic int zd1201_setconfig(struct zd1201 *zd, int rid, void *buf, int len, int wait)\r\n{\r\nint err;\r\nunsigned char *request;\r\nint reqlen;\r\nchar seq=0;\r\nstruct urb *urb;\r\ngfp_t gfp_mask = wait ? GFP_NOIO : GFP_ATOMIC;\r\nlen += 4;\r\nzd->rxdatas = 0;\r\nzd->rxlen = 0;\r\nfor (seq=0; len > 0; seq++) {\r\nrequest = kmalloc(16, gfp_mask);\r\nif (!request)\r\nreturn -ENOMEM;\r\nurb = usb_alloc_urb(0, gfp_mask);\r\nif (!urb) {\r\nkfree(request);\r\nreturn -ENOMEM;\r\n}\r\nmemset(request, 0, 16);\r\nreqlen = len>12 ? 12 : len;\r\nrequest[0] = ZD1201_USB_RESREQ;\r\nrequest[1] = seq;\r\nrequest[2] = 0;\r\nrequest[3] = 0;\r\nif (request[1] == 0) {\r\n*(__le16*)&request[4] = cpu_to_le16((len-2+1)/2);\r\n*(__le16*)&request[6] = cpu_to_le16(rid);\r\nmemcpy(request+8, buf, reqlen-4);\r\nbuf += reqlen-4;\r\n} else {\r\nmemcpy(request+4, buf, reqlen);\r\nbuf += reqlen;\r\n}\r\nlen -= reqlen;\r\nusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb,\r\nzd->endp_out2), request, 16, zd1201_usbfree, zd);\r\nerr = usb_submit_urb(urb, gfp_mask);\r\nif (err)\r\ngoto err;\r\n}\r\nrequest = kmalloc(16, gfp_mask);\r\nif (!request)\r\nreturn -ENOMEM;\r\nurb = usb_alloc_urb(0, gfp_mask);\r\nif (!urb) {\r\nkfree(request);\r\nreturn -ENOMEM;\r\n}\r\n*((__le32*)request) = cpu_to_le32(ZD1201_USB_CMDREQ);\r\n*((__le16*)&request[4]) =\r\ncpu_to_le16(ZD1201_CMDCODE_ACCESS|ZD1201_ACCESSBIT);\r\n*((__le16*)&request[6]) = cpu_to_le16(rid);\r\n*((__le16*)&request[8]) = cpu_to_le16(0);\r\n*((__le16*)&request[10]) = cpu_to_le16(0);\r\nusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out2),\r\nrequest, 16, zd1201_usbfree, zd);\r\nerr = usb_submit_urb(urb, gfp_mask);\r\nif (err)\r\ngoto err;\r\nif (wait) {\r\nwait_event_interruptible(zd->rxdataq, zd->rxdatas);\r\nif (!zd->rxlen || le16_to_cpu(*(__le16*)&zd->rxdata[6]) != rid) {\r\ndev_dbg(&zd->usb->dev, "wrong or no RID received\n");\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nkfree(request);\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nstatic inline int zd1201_getconfig16(struct zd1201 *zd, int rid, short *val)\r\n{\r\nint err;\r\n__le16 zdval;\r\nerr = zd1201_getconfig(zd, rid, &zdval, sizeof(__le16));\r\nif (err)\r\nreturn err;\r\n*val = le16_to_cpu(zdval);\r\nreturn 0;\r\n}\r\nstatic inline int zd1201_setconfig16(struct zd1201 *zd, int rid, short val)\r\n{\r\n__le16 zdval = cpu_to_le16(val);\r\nreturn (zd1201_setconfig(zd, rid, &zdval, sizeof(__le16), 1));\r\n}\r\nstatic int zd1201_drvr_start(struct zd1201 *zd)\r\n{\r\nint err, i;\r\nshort max;\r\n__le16 zdmax;\r\nunsigned char *buffer;\r\nbuffer = kzalloc(ZD1201_RXSIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(zd->rx_urb, zd->usb,\r\nusb_rcvbulkpipe(zd->usb, zd->endp_in), buffer, ZD1201_RXSIZE,\r\nzd1201_usbrx, zd);\r\nerr = usb_submit_urb(zd->rx_urb, GFP_KERNEL);\r\nif (err)\r\ngoto err_buffer;\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_INIT, 0, 0, 0);\r\nif (err)\r\ngoto err_urb;\r\nerr = zd1201_getconfig(zd, ZD1201_RID_CNFMAXTXBUFFERNUMBER, &zdmax,\r\nsizeof(__le16));\r\nif (err)\r\ngoto err_urb;\r\nmax = le16_to_cpu(zdmax);\r\nfor (i=0; i<max; i++) {\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_ALLOC, 1514, 0, 0);\r\nif (err)\r\ngoto err_urb;\r\n}\r\nreturn 0;\r\nerr_urb:\r\nusb_kill_urb(zd->rx_urb);\r\nreturn err;\r\nerr_buffer:\r\nkfree(buffer);\r\nreturn err;\r\n}\r\nstatic int zd1201_enable(struct zd1201 *zd)\r\n{\r\nint err;\r\nif (zd->mac_enabled)\r\nreturn 0;\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_ENABLE, 0, 0, 0);\r\nif (!err)\r\nzd->mac_enabled = 1;\r\nif (zd->monitor)\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 1);\r\nreturn err;\r\n}\r\nstatic int zd1201_disable(struct zd1201 *zd)\r\n{\r\nint err;\r\nif (!zd->mac_enabled)\r\nreturn 0;\r\nif (zd->monitor) {\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_DISABLE, 0, 0, 0);\r\nif (!err)\r\nzd->mac_enabled = 0;\r\nreturn err;\r\n}\r\nstatic int zd1201_mac_reset(struct zd1201 *zd)\r\n{\r\nif (!zd->mac_enabled)\r\nreturn 0;\r\nzd1201_disable(zd);\r\nreturn zd1201_enable(zd);\r\n}\r\nstatic int zd1201_join(struct zd1201 *zd, char *essid, int essidlen)\r\n{\r\nint err, val;\r\nchar buf[IW_ESSID_MAX_SIZE+2];\r\nerr = zd1201_disable(zd);\r\nif (err)\r\nreturn err;\r\nval = ZD1201_CNFAUTHENTICATION_OPENSYSTEM;\r\nval |= ZD1201_CNFAUTHENTICATION_SHAREDKEY;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFAUTHENTICATION, val);\r\nif (err)\r\nreturn err;\r\n*(__le16 *)buf = cpu_to_le16(essidlen);\r\nmemcpy(buf+2, essid, essidlen);\r\nif (!zd->ap) {\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID, buf,\r\nIW_ESSID_MAX_SIZE+2, 1);\r\nif (err)\r\nreturn err;\r\n} else {\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNSSID, buf,\r\nIW_ESSID_MAX_SIZE+2, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNMACADDR,\r\nzd->dev->dev_addr, zd->dev->addr_len, 1);\r\nif (err)\r\nreturn err;\r\nerr = zd1201_enable(zd);\r\nif (err)\r\nreturn err;\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int zd1201_net_open(struct net_device *dev)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nif (!zd->mac_enabled)\r\nzd1201_join(zd, zd->essid, zd->essidlen);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int zd1201_net_stop(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t zd1201_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nunsigned char *txbuf = zd->txdata;\r\nint txbuflen, pad = 0, err;\r\nstruct urb *urb = zd->tx_urb;\r\nif (!zd->mac_enabled || zd->monitor) {\r\ndev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\ntxbuflen = skb->len + 8 + 1;\r\nif (txbuflen%64 == 0) {\r\npad = 1;\r\ntxbuflen++;\r\n}\r\ntxbuf[0] = 0xAA;\r\ntxbuf[1] = 0xAA;\r\ntxbuf[2] = 0x03;\r\ntxbuf[3] = 0x00;\r\ntxbuf[4] = 0x00;\r\ntxbuf[5] = 0x00;\r\nskb_copy_from_linear_data_offset(skb, 12, txbuf + 6, skb->len - 12);\r\nif (pad)\r\ntxbuf[skb->len-12+6]=0;\r\nskb_copy_from_linear_data(skb, txbuf + skb->len - 12 + 6 + pad, 12);\r\n*(__be16*)&txbuf[skb->len+6+pad] = htons(skb->len-12+6);\r\ntxbuf[txbuflen-1] = 0;\r\nusb_fill_bulk_urb(urb, zd->usb, usb_sndbulkpipe(zd->usb, zd->endp_out),\r\ntxbuf, txbuflen, zd1201_usbtx, zd);\r\nerr = usb_submit_urb(zd->tx_urb, GFP_ATOMIC);\r\nif (err) {\r\ndev->stats.tx_errors++;\r\nnetif_start_queue(dev);\r\n} else {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n}\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void zd1201_tx_timeout(struct net_device *dev)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nif (!zd)\r\nreturn;\r\ndev_warn(&zd->usb->dev, "%s: TX timeout, shooting down urb\n",\r\ndev->name);\r\nusb_unlink_urb(zd->tx_urb);\r\ndev->stats.tx_errors++;\r\ndev->trans_start = jiffies;\r\n}\r\nstatic int zd1201_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nint err;\r\nif (!zd)\r\nreturn -ENODEV;\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFOWNMACADDR,\r\naddr->sa_data, dev->addr_len, 1);\r\nif (err)\r\nreturn err;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic struct iw_statistics *zd1201_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nreturn &zd->iwstats;\r\n}\r\nstatic void zd1201_set_multicast(struct net_device *dev)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nunsigned char reqbuf[ETH_ALEN*ZD1201_MAXMULTI];\r\nint i;\r\nif (netdev_mc_count(dev) > ZD1201_MAXMULTI)\r\nreturn;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy(reqbuf + i++ * ETH_ALEN, ha->addr, ETH_ALEN);\r\nzd1201_setconfig(zd, ZD1201_RID_CNFGROUPADDRESS, reqbuf,\r\nnetdev_mc_count(dev) * ETH_ALEN, 0);\r\n}\r\nstatic int zd1201_config_commit(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *data, char *essid)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic int zd1201_get_name(struct net_device *dev,\r\nstruct iw_request_info *info, char *name, char *extra)\r\n{\r\nstrcpy(name, "IEEE 802.11b");\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_freq *freq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort channel = 0;\r\nint err;\r\nif (freq->e == 0)\r\nchannel = freq->m;\r\nelse {\r\nchannel = ieee80211_freq_to_dsss_chan(freq->m);\r\nif (channel < 0)\r\nchannel = 0;\r\n}\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFOWNCHANNEL, channel);\r\nif (err)\r\nreturn err;\r\nzd1201_mac_reset(zd);\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_freq *freq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort channel;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFOWNCHANNEL, &channel);\r\nif (err)\r\nreturn err;\r\nfreq->e = 0;\r\nfreq->m = channel;\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_mode(struct net_device *dev,\r\nstruct iw_request_info *info, __u32 *mode, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort porttype, monitor = 0;\r\nunsigned char buffer[IW_ESSID_MAX_SIZE+2];\r\nint err;\r\nif (zd->ap) {\r\nif (*mode != IW_MODE_MASTER)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_PROMISCUOUSMODE, 0);\r\nif (err)\r\nreturn err;\r\nzd->dev->type = ARPHRD_ETHER;\r\nswitch(*mode) {\r\ncase IW_MODE_MONITOR:\r\nmonitor = 1;\r\nzd->dev->type = ARPHRD_IEEE80211;\r\nzd1201_join(zd, "\0-*#\0", 5);\r\ncase 8:\r\nporttype = ZD1201_PORTTYPE_PSEUDOIBSS;\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nporttype = ZD1201_PORTTYPE_IBSS;\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nporttype = ZD1201_PORTTYPE_BSS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFPORTTYPE, porttype);\r\nif (err)\r\nreturn err;\r\nif (zd->monitor && !monitor) {\r\nzd1201_disable(zd);\r\n*(__le16 *)buffer = cpu_to_le16(zd->essidlen);\r\nmemcpy(buffer+2, zd->essid, zd->essidlen);\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID,\r\nbuffer, IW_ESSID_MAX_SIZE+2, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nzd->monitor = monitor;\r\nzd1201_mac_reset(zd);\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_mode(struct net_device *dev,\r\nstruct iw_request_info *info, __u32 *mode, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort porttype;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFPORTTYPE, &porttype);\r\nif (err)\r\nreturn err;\r\nswitch(porttype) {\r\ncase ZD1201_PORTTYPE_IBSS:\r\n*mode = IW_MODE_ADHOC;\r\nbreak;\r\ncase ZD1201_PORTTYPE_BSS:\r\n*mode = IW_MODE_INFRA;\r\nbreak;\r\ncase ZD1201_PORTTYPE_WDS:\r\n*mode = IW_MODE_REPEAT;\r\nbreak;\r\ncase ZD1201_PORTTYPE_PSEUDOIBSS:\r\n*mode = 8;\r\nbreak;\r\ncase ZD1201_PORTTYPE_AP:\r\n*mode = IW_MODE_MASTER;\r\nbreak;\r\ndefault:\r\ndev_dbg(&zd->usb->dev, "Unknown porttype: %d\n",\r\nporttype);\r\n*mode = IW_MODE_AUTO;\r\n}\r\nif (zd->monitor)\r\n*mode = IW_MODE_MONITOR;\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_range(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *wrq, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nwrq->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = WIRELESS_EXT;\r\nrange->max_qual.qual = 128;\r\nrange->max_qual.level = 128;\r\nrange->max_qual.noise = 128;\r\nrange->max_qual.updated = 7;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->num_encoding_sizes = 2;\r\nrange->max_encoding_tokens = ZD1201_NUMKEYS;\r\nrange->num_bitrates = 4;\r\nrange->bitrate[0] = 1000000;\r\nrange->bitrate[1] = 2000000;\r\nrange->bitrate[2] = 5500000;\r\nrange->bitrate[3] = 11000000;\r\nrange->min_rts = 0;\r\nrange->min_frag = ZD1201_FRAGMIN;\r\nrange->max_rts = ZD1201_RTSMAX;\r\nrange->min_frag = ZD1201_FRAGMAX;\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info, struct sockaddr *ap_addr, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nunsigned char buffer[6];\r\nif (!zd1201_getconfig(zd, ZD1201_RID_COMMSQUALITY, buffer, 6)) {\r\nzd->iwstats.qual.level = le16_to_cpu(((__le16 *)buffer)[1]);\r\nzd->iwstats.qual.updated = 2;\r\n}\r\nreturn zd1201_getconfig(zd, ZD1201_RID_CURRENTBSSID, ap_addr->sa_data, 6);\r\n}\r\nstatic int zd1201_set_scan(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *srq, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_scan(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *srq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nint err, i, j, enabled_save;\r\nstruct iw_event iwe;\r\nchar *cev = extra;\r\nchar *end_buf = extra + IW_SCAN_MAX_DATA;\r\nif (zd->ap)\r\nreturn -EOPNOTSUPP;\r\nenabled_save = zd->mac_enabled;\r\nzd1201_enable(zd);\r\nzd->rxdatas = 0;\r\nerr = zd1201_docmd(zd, ZD1201_CMDCODE_INQUIRE,\r\nZD1201_INQ_SCANRESULTS, 0, 0);\r\nif (err)\r\nreturn err;\r\nwait_event_interruptible(zd->rxdataq, zd->rxdatas);\r\nif (!zd->rxlen)\r\nreturn -EIO;\r\nif (le16_to_cpu(*(__le16*)&zd->rxdata[2]) != ZD1201_INQ_SCANRESULTS)\r\nreturn -EIO;\r\nfor(i=8; i<zd->rxlen; i+=62) {\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, zd->rxdata+i+6, 6);\r\ncev = iwe_stream_add_event(info, cev, end_buf,\r\n&iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.length = zd->rxdata[i+16];\r\niwe.u.data.flags = 1;\r\ncev = iwe_stream_add_point(info, cev, end_buf,\r\n&iwe, zd->rxdata+i+18);\r\niwe.cmd = SIOCGIWMODE;\r\nif (zd->rxdata[i+14]&0x01)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\ncev = iwe_stream_add_event(info, cev, end_buf,\r\n&iwe, IW_EV_UINT_LEN);\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = zd->rxdata[i+0];\r\niwe.u.freq.e = 0;\r\ncev = iwe_stream_add_event(info, cev, end_buf,\r\n&iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = 0;\r\niwe.u.bitrate.disabled = 0;\r\nfor (j=0; j<10; j++) if (zd->rxdata[i+50+j]) {\r\niwe.u.bitrate.value = (zd->rxdata[i+50+j]&0x7f)*500000;\r\ncev = iwe_stream_add_event(info, cev, end_buf,\r\n&iwe, IW_EV_PARAM_LEN);\r\n}\r\niwe.cmd = SIOCGIWENCODE;\r\niwe.u.data.length = 0;\r\nif (zd->rxdata[i+14]&0x10)\r\niwe.u.data.flags = IW_ENCODE_ENABLED;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\ncev = iwe_stream_add_point(info, cev, end_buf, &iwe, NULL);\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.qual = zd->rxdata[i+4];\r\niwe.u.qual.noise= zd->rxdata[i+2]/10-100;\r\niwe.u.qual.level = (256+zd->rxdata[i+4]*100)/255-100;\r\niwe.u.qual.updated = 7;\r\ncev = iwe_stream_add_event(info, cev, end_buf,\r\n&iwe, IW_EV_QUAL_LEN);\r\n}\r\nif (!enabled_save)\r\nzd1201_disable(zd);\r\nsrq->length = cev - extra;\r\nsrq->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_essid(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *data, char *essid)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nif (data->length > IW_ESSID_MAX_SIZE)\r\nreturn -EINVAL;\r\nif (data->length < 1)\r\ndata->length = 1;\r\nzd->essidlen = data->length;\r\nmemset(zd->essid, 0, IW_ESSID_MAX_SIZE+1);\r\nmemcpy(zd->essid, essid, data->length);\r\nreturn zd1201_join(zd, zd->essid, zd->essidlen);\r\n}\r\nstatic int zd1201_get_essid(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *data, char *essid)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nmemcpy(essid, zd->essid, zd->essidlen);\r\ndata->flags = 1;\r\ndata->length = zd->essidlen;\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_nick(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_point *data, char *nick)\r\n{\r\nstrcpy(nick, "zd1201");\r\ndata->flags = 1;\r\ndata->length = strlen(nick);\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort rate;\r\nint err;\r\nswitch (rrq->value) {\r\ncase 1000000:\r\nrate = ZD1201_RATEB1;\r\nbreak;\r\ncase 2000000:\r\nrate = ZD1201_RATEB2;\r\nbreak;\r\ncase 5500000:\r\nrate = ZD1201_RATEB5;\r\nbreak;\r\ncase 11000000:\r\ndefault:\r\nrate = ZD1201_RATEB11;\r\nbreak;\r\n}\r\nif (!rrq->fixed) {\r\nrate |= rate-1;\r\n}\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_TXRATECNTL, rate);\r\nif (err)\r\nreturn err;\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic int zd1201_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort rate;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CURRENTTXRATE, &rate);\r\nif (err)\r\nreturn err;\r\nswitch(rate) {\r\ncase 1:\r\nrrq->value = 1000000;\r\nbreak;\r\ncase 2:\r\nrrq->value = 2000000;\r\nbreak;\r\ncase 5:\r\nrrq->value = 5500000;\r\nbreak;\r\ncase 11:\r\nrrq->value = 11000000;\r\nbreak;\r\ndefault:\r\nrrq->value = 0;\r\n}\r\nrrq->fixed = 0;\r\nrrq->disabled = 0;\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_rts(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nint err;\r\nshort val = rts->value;\r\nif (rts->disabled || !rts->fixed)\r\nval = ZD1201_RTSMAX;\r\nif (val > ZD1201_RTSMAX)\r\nreturn -EINVAL;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFRTSTHRESHOLD, val);\r\nif (err)\r\nreturn err;\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic int zd1201_get_rts(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_param *rts, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort rtst;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFRTSTHRESHOLD, &rtst);\r\nif (err)\r\nreturn err;\r\nrts->value = rtst;\r\nrts->disabled = (rts->value == ZD1201_RTSMAX);\r\nrts->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_frag(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_param *frag, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nint err;\r\nshort val = frag->value;\r\nif (frag->disabled || !frag->fixed)\r\nval = ZD1201_FRAGMAX;\r\nif (val > ZD1201_FRAGMAX)\r\nreturn -EINVAL;\r\nif (val < ZD1201_FRAGMIN)\r\nreturn -EINVAL;\r\nif (val & 1)\r\nreturn -EINVAL;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFFRAGTHRESHOLD, val);\r\nif (err)\r\nreturn err;\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic int zd1201_get_frag(struct net_device *dev, struct iw_request_info *info,\r\nstruct iw_param *frag, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort fragt;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFFRAGTHRESHOLD, &fragt);\r\nif (err)\r\nreturn err;\r\nfrag->value = fragt;\r\nfrag->disabled = (frag->value == ZD1201_FRAGMAX);\r\nfrag->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_encode(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *erq, char *key)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort i;\r\nint err, rid;\r\nif (erq->length > ZD1201_MAXKEYLEN)\r\nreturn -EINVAL;\r\ni = (erq->flags & IW_ENCODE_INDEX)-1;\r\nif (i == -1) {\r\nerr = zd1201_getconfig16(zd,ZD1201_RID_CNFDEFAULTKEYID,&i);\r\nif (err)\r\nreturn err;\r\n} else {\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFDEFAULTKEYID, i);\r\nif (err)\r\nreturn err;\r\n}\r\nif (i < 0 || i >= ZD1201_NUMKEYS)\r\nreturn -EINVAL;\r\nrid = ZD1201_RID_CNFDEFAULTKEY0 + i;\r\nerr = zd1201_setconfig(zd, rid, key, erq->length, 1);\r\nif (err)\r\nreturn err;\r\nzd->encode_keylen[i] = erq->length;\r\nmemcpy(zd->encode_keys[i], key, erq->length);\r\ni=0;\r\nif (!(erq->flags & IW_ENCODE_DISABLED & IW_ENCODE_MODE)) {\r\ni |= 0x01;\r\nzd->encode_enabled = 1;\r\n} else\r\nzd->encode_enabled = 0;\r\nif (erq->flags & IW_ENCODE_RESTRICTED & IW_ENCODE_MODE) {\r\ni |= 0x02;\r\nzd->encode_restricted = 1;\r\n} else\r\nzd->encode_restricted = 0;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFWEBFLAGS, i);\r\nif (err)\r\nreturn err;\r\nif (zd->encode_enabled)\r\ni = ZD1201_CNFAUTHENTICATION_SHAREDKEY;\r\nelse\r\ni = ZD1201_CNFAUTHENTICATION_OPENSYSTEM;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFAUTHENTICATION, i);\r\nif (err)\r\nreturn err;\r\nreturn zd1201_mac_reset(zd);\r\n}\r\nstatic int zd1201_get_encode(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_point *erq, char *key)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort i;\r\nint err;\r\nif (zd->encode_enabled)\r\nerq->flags = IW_ENCODE_ENABLED;\r\nelse\r\nerq->flags = IW_ENCODE_DISABLED;\r\nif (zd->encode_restricted)\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nelse\r\nerq->flags |= IW_ENCODE_OPEN;\r\ni = (erq->flags & IW_ENCODE_INDEX) -1;\r\nif (i == -1) {\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFDEFAULTKEYID, &i);\r\nif (err)\r\nreturn err;\r\n}\r\nif (i<0 || i>= ZD1201_NUMKEYS)\r\nreturn -EINVAL;\r\nerq->flags |= i+1;\r\nerq->length = zd->encode_keylen[i];\r\nmemcpy(key, zd->encode_keys[i], erq->length);\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_power(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *vwrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort enabled, duration, level;\r\nint err;\r\nenabled = vwrq->disabled ? 0 : 1;\r\nif (enabled) {\r\nif (vwrq->flags & IW_POWER_PERIOD) {\r\nduration = vwrq->value;\r\nerr = zd1201_setconfig16(zd,\r\nZD1201_RID_CNFMAXSLEEPDURATION, duration);\r\nif (err)\r\nreturn err;\r\ngoto out;\r\n}\r\nif (vwrq->flags & IW_POWER_TIMEOUT) {\r\nerr = zd1201_getconfig16(zd,\r\nZD1201_RID_CNFMAXSLEEPDURATION, &duration);\r\nif (err)\r\nreturn err;\r\nlevel = vwrq->value * 4 / duration;\r\nif (level > 4)\r\nlevel = 4;\r\nif (level < 0)\r\nlevel = 0;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFPMEPS,\r\nlevel);\r\nif (err)\r\nreturn err;\r\ngoto out;\r\n}\r\nreturn -EINVAL;\r\n}\r\nout:\r\nreturn zd1201_setconfig16(zd, ZD1201_RID_CNFPMENABLED, enabled);\r\n}\r\nstatic int zd1201_get_power(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *vwrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort enabled, level, duration;\r\nint err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFPMENABLED, &enabled);\r\nif (err)\r\nreturn err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFPMEPS, &level);\r\nif (err)\r\nreturn err;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFMAXSLEEPDURATION, &duration);\r\nif (err)\r\nreturn err;\r\nvwrq->disabled = enabled ? 0 : 1;\r\nif (vwrq->flags & IW_POWER_TYPE) {\r\nif (vwrq->flags & IW_POWER_PERIOD) {\r\nvwrq->value = duration;\r\nvwrq->flags = IW_POWER_PERIOD;\r\n} else {\r\nvwrq->value = duration * level / 4;\r\nvwrq->flags = IW_POWER_TIMEOUT;\r\n}\r\n}\r\nif (vwrq->flags & IW_POWER_MODE) {\r\nif (enabled && level)\r\nvwrq->flags = IW_POWER_UNICAST_R;\r\nelse\r\nvwrq->flags = IW_POWER_ALL_R;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zd1201_set_hostauth(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nif (!zd->ap)\r\nreturn -EOPNOTSUPP;\r\nreturn zd1201_setconfig16(zd, ZD1201_RID_CNFHOSTAUTH, rrq->value);\r\n}\r\nstatic int zd1201_get_hostauth(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort hostauth;\r\nint err;\r\nif (!zd->ap)\r\nreturn -EOPNOTSUPP;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFHOSTAUTH, &hostauth);\r\nif (err)\r\nreturn err;\r\nrrq->value = hostauth;\r\nrrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int zd1201_auth_sta(struct net_device *dev,\r\nstruct iw_request_info *info, struct sockaddr *sta, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nunsigned char buffer[10];\r\nif (!zd->ap)\r\nreturn -EOPNOTSUPP;\r\nmemcpy(buffer, sta->sa_data, ETH_ALEN);\r\n*(short*)(buffer+6) = 0;\r\n*(short*)(buffer+8) = 0;\r\nreturn zd1201_setconfig(zd, ZD1201_RID_AUTHENTICATESTA, buffer, 10, 1);\r\n}\r\nstatic int zd1201_set_maxassoc(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nint err;\r\nif (!zd->ap)\r\nreturn -EOPNOTSUPP;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFMAXASSOCSTATIONS, rrq->value);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int zd1201_get_maxassoc(struct net_device *dev,\r\nstruct iw_request_info *info, struct iw_param *rrq, char *extra)\r\n{\r\nstruct zd1201 *zd = netdev_priv(dev);\r\nshort maxassoc;\r\nint err;\r\nif (!zd->ap)\r\nreturn -EOPNOTSUPP;\r\nerr = zd1201_getconfig16(zd, ZD1201_RID_CNFMAXASSOCSTATIONS, &maxassoc);\r\nif (err)\r\nreturn err;\r\nrrq->value = maxassoc;\r\nrrq->fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int zd1201_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct zd1201 *zd;\r\nstruct net_device *dev;\r\nstruct usb_device *usb;\r\nint err;\r\nshort porttype;\r\nchar buf[IW_ESSID_MAX_SIZE+2];\r\nusb = interface_to_usbdev(interface);\r\ndev = alloc_etherdev(sizeof(*zd));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nzd = netdev_priv(dev);\r\nzd->dev = dev;\r\nzd->ap = ap;\r\nzd->usb = usb;\r\nzd->removed = 0;\r\ninit_waitqueue_head(&zd->rxdataq);\r\nINIT_HLIST_HEAD(&zd->fraglist);\r\nerr = zd1201_fw_upload(usb, zd->ap);\r\nif (err) {\r\ndev_err(&usb->dev, "zd1201 firmware upload failed: %d\n", err);\r\ngoto err_zd;\r\n}\r\nzd->endp_in = 1;\r\nzd->endp_out = 1;\r\nzd->endp_out2 = 2;\r\nzd->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nzd->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!zd->rx_urb || !zd->tx_urb) {\r\nerr = -ENOMEM;\r\ngoto err_zd;\r\n}\r\nmdelay(100);\r\nerr = zd1201_drvr_start(zd);\r\nif (err)\r\ngoto err_zd;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFMAXDATALEN, 2312);\r\nif (err)\r\ngoto err_start;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_TXRATECNTL,\r\nZD1201_RATEB1 | ZD1201_RATEB2 | ZD1201_RATEB5 | ZD1201_RATEB11);\r\nif (err)\r\ngoto err_start;\r\ndev->netdev_ops = &zd1201_netdev_ops;\r\ndev->wireless_handlers = &zd1201_iw_handlers;\r\ndev->watchdog_timeo = ZD1201_TX_TIMEOUT;\r\nstrcpy(dev->name, "wlan%d");\r\nerr = zd1201_getconfig(zd, ZD1201_RID_CNFOWNMACADDR,\r\ndev->dev_addr, dev->addr_len);\r\nif (err)\r\ngoto err_start;\r\n*(__le16 *)buf = cpu_to_le16(0);\r\nerr = zd1201_setconfig(zd, ZD1201_RID_CNFDESIREDSSID, buf,\r\nIW_ESSID_MAX_SIZE+2, 1);\r\nif (err)\r\ngoto err_start;\r\nif (zd->ap)\r\nporttype = ZD1201_PORTTYPE_AP;\r\nelse\r\nporttype = ZD1201_PORTTYPE_BSS;\r\nerr = zd1201_setconfig16(zd, ZD1201_RID_CNFPORTTYPE, porttype);\r\nif (err)\r\ngoto err_start;\r\nSET_NETDEV_DEV(dev, &usb->dev);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto err_start;\r\ndev_info(&usb->dev, "%s: ZD1201 USB Wireless interface\n",\r\ndev->name);\r\nusb_set_intfdata(interface, zd);\r\nzd1201_enable(zd);\r\nzd1201_disable(zd);\r\nreturn 0;\r\nerr_start:\r\nzd1201_docmd(zd, ZD1201_CMDCODE_INIT, 0, 0, 0);\r\nerr_zd:\r\nusb_free_urb(zd->tx_urb);\r\nusb_free_urb(zd->rx_urb);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void zd1201_disconnect(struct usb_interface *interface)\r\n{\r\nstruct zd1201 *zd = usb_get_intfdata(interface);\r\nstruct hlist_node *node2;\r\nstruct zd1201_frag *frag;\r\nif (!zd)\r\nreturn;\r\nusb_set_intfdata(interface, NULL);\r\nhlist_for_each_entry_safe(frag, node2, &zd->fraglist, fnode) {\r\nhlist_del_init(&frag->fnode);\r\nkfree_skb(frag->skb);\r\nkfree(frag);\r\n}\r\nif (zd->tx_urb) {\r\nusb_kill_urb(zd->tx_urb);\r\nusb_free_urb(zd->tx_urb);\r\n}\r\nif (zd->rx_urb) {\r\nusb_kill_urb(zd->rx_urb);\r\nusb_free_urb(zd->rx_urb);\r\n}\r\nif (zd->dev) {\r\nunregister_netdev(zd->dev);\r\nfree_netdev(zd->dev);\r\n}\r\n}\r\nstatic int zd1201_suspend(struct usb_interface *interface,\r\npm_message_t message)\r\n{\r\nstruct zd1201 *zd = usb_get_intfdata(interface);\r\nnetif_device_detach(zd->dev);\r\nzd->was_enabled = zd->mac_enabled;\r\nif (zd->was_enabled)\r\nreturn zd1201_disable(zd);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int zd1201_resume(struct usb_interface *interface)\r\n{\r\nstruct zd1201 *zd = usb_get_intfdata(interface);\r\nif (!zd || !zd->dev)\r\nreturn -ENODEV;\r\nnetif_device_attach(zd->dev);\r\nif (zd->was_enabled)\r\nreturn zd1201_enable(zd);\r\nelse\r\nreturn 0;\r\n}
