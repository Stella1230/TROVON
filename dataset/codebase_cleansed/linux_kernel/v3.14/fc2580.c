static int fc2580_wr_regs(struct fc2580_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (1 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fc2580_rd_regs(struct fc2580_priv *priv, u8 reg, u8 *val, int len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fc2580_wr_reg(struct fc2580_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn fc2580_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int fc2580_rd_reg(struct fc2580_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn fc2580_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int fc2580_wr_reg_ff(struct fc2580_priv *priv, u8 reg, u8 val)\r\n{\r\nif (val == 0xff)\r\nreturn 0;\r\nelse\r\nreturn fc2580_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int fc2580_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct fc2580_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret = 0, i;\r\nunsigned int r_val, n_val, k_val, k_val_reg, f_ref;\r\nu8 tmp_val, r18_val;\r\nu64 f_vco;\r\ndev_dbg(&priv->i2c->dev, "%s: delivery_system=%d frequency=%d " \\r\n"bandwidth_hz=%d\n", __func__,\r\nc->delivery_system, c->frequency, c->bandwidth_hz);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_pll_lut); i++) {\r\nif (c->frequency <= fc2580_pll_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_pll_lut))\r\ngoto err;\r\nf_vco = c->frequency;\r\nf_vco *= fc2580_pll_lut[i].div;\r\nif (f_vco >= 2600000000UL)\r\ntmp_val = 0x0e | fc2580_pll_lut[i].band;\r\nelse\r\ntmp_val = 0x06 | fc2580_pll_lut[i].band;\r\nret = fc2580_wr_reg(priv, 0x02, tmp_val);\r\nif (ret < 0)\r\ngoto err;\r\nif (f_vco >= 2UL * 76 * priv->cfg->clock) {\r\nr_val = 1;\r\nr18_val = 0x00;\r\n} else if (f_vco >= 1UL * 76 * priv->cfg->clock) {\r\nr_val = 2;\r\nr18_val = 0x10;\r\n} else {\r\nr_val = 4;\r\nr18_val = 0x20;\r\n}\r\nf_ref = 2UL * priv->cfg->clock / r_val;\r\nn_val = div_u64_rem(f_vco, f_ref, &k_val);\r\nk_val_reg = 1UL * k_val * (1 << 20) / f_ref;\r\nret = fc2580_wr_reg(priv, 0x18, r18_val | ((k_val_reg >> 16) & 0xff));\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x1a, (k_val_reg >> 8) & 0xff);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x1b, (k_val_reg >> 0) & 0xff);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x1c, n_val);\r\nif (ret < 0)\r\ngoto err;\r\nif (priv->cfg->clock >= 28000000) {\r\nret = fc2580_wr_reg(priv, 0x4b, 0x22);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (fc2580_pll_lut[i].band == 0x00) {\r\nif (c->frequency <= 794000000)\r\ntmp_val = 0x9f;\r\nelse\r\ntmp_val = 0x8f;\r\nret = fc2580_wr_reg(priv, 0x2d, tmp_val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_freq_regs_lut); i++) {\r\nif (c->frequency <= fc2580_freq_regs_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_freq_regs_lut))\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x25, fc2580_freq_regs_lut[i].r25_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x27, fc2580_freq_regs_lut[i].r27_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x28, fc2580_freq_regs_lut[i].r28_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x29, fc2580_freq_regs_lut[i].r29_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x2b, fc2580_freq_regs_lut[i].r2b_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x2c, fc2580_freq_regs_lut[i].r2c_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x2d, fc2580_freq_regs_lut[i].r2d_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x30, fc2580_freq_regs_lut[i].r30_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x44, fc2580_freq_regs_lut[i].r44_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x50, fc2580_freq_regs_lut[i].r50_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x53, fc2580_freq_regs_lut[i].r53_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x5f, fc2580_freq_regs_lut[i].r5f_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x61, fc2580_freq_regs_lut[i].r61_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x62, fc2580_freq_regs_lut[i].r62_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x63, fc2580_freq_regs_lut[i].r63_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x67, fc2580_freq_regs_lut[i].r67_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x68, fc2580_freq_regs_lut[i].r68_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x69, fc2580_freq_regs_lut[i].r69_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6a, fc2580_freq_regs_lut[i].r6a_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6b, fc2580_freq_regs_lut[i].r6b_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6c, fc2580_freq_regs_lut[i].r6c_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6d, fc2580_freq_regs_lut[i].r6d_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6e, fc2580_freq_regs_lut[i].r6e_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(priv, 0x6f, fc2580_freq_regs_lut[i].r6f_val);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_if_filter_lut); i++) {\r\nif (c->bandwidth_hz <= fc2580_if_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_if_filter_lut))\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x36, fc2580_if_filter_lut[i].r36_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x37, 1UL * priv->cfg->clock * \\r\nfc2580_if_filter_lut[i].mul / 1000000000);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x39, fc2580_if_filter_lut[i].r39_val);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x2e, 0x09);\r\nif (ret < 0)\r\ngoto err;\r\nfor (i = 0; i < 5; i++) {\r\nret = fc2580_rd_reg(priv, 0x2f, &tmp_val);\r\nif (ret < 0)\r\ngoto err;\r\nif ((tmp_val & 0xc0) == 0xc0)\r\nbreak;\r\nret = fc2580_wr_reg(priv, 0x2e, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = fc2580_wr_reg(priv, 0x2e, 0x09);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(5000, 25000);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%i\n", __func__, i);\r\nret = fc2580_wr_reg(priv, 0x2e, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_init(struct dvb_frontend *fe)\r\n{\r\nstruct fc2580_priv *priv = fe->tuner_priv;\r\nint ret, i;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_init_reg_vals); i++) {\r\nret = fc2580_wr_reg(priv, fc2580_init_reg_vals[i].reg,\r\nfc2580_init_reg_vals[i].val);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct fc2580_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fc2580_wr_reg(priv, 0x02, 0x0a);\r\nif (ret < 0)\r\ngoto err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct fc2580_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int fc2580_release(struct dvb_frontend *fe)\r\n{\r\nstruct fc2580_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nkfree(fe->tuner_priv);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *fc2580_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, const struct fc2580_config *cfg)\r\n{\r\nstruct fc2580_priv *priv;\r\nint ret;\r\nu8 chip_id;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\npriv = kzalloc(sizeof(struct fc2580_priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ndev_err(&i2c->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\ngoto err;\r\n}\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nret = fc2580_rd_reg(priv, 0x01, &chip_id);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: chip_id=%02x\n", __func__, chip_id);\r\nswitch (chip_id) {\r\ncase 0x56:\r\ncase 0x5a:\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\ndev_info(&priv->i2c->dev,\r\n"%s: FCI FC2580 successfully identified\n",\r\nKBUILD_MODNAME);\r\nfe->tuner_priv = priv;\r\nmemcpy(&fe->ops.tuner_ops, &fc2580_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn fe;\r\nerr:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
