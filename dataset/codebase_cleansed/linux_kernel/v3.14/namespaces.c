static char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nconst struct proc_ns_operations *ns_ops = PROC_I(inode)->ns.ns_ops;\r\nreturn dynamic_dname(dentry, buffer, buflen, "%s:[%lu]",\r\nns_ops->name, inode->i_ino);\r\n}\r\nstatic struct dentry *proc_ns_get_dentry(struct super_block *sb,\r\nstruct task_struct *task, const struct proc_ns_operations *ns_ops)\r\n{\r\nstruct dentry *dentry, *result;\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\nstruct qstr qname = { .name = "", };\r\nvoid *ns;\r\nns = ns_ops->get(task);\r\nif (!ns)\r\nreturn ERR_PTR(-ENOENT);\r\ndentry = d_alloc_pseudo(sb, &qname);\r\nif (!dentry) {\r\nns_ops->put(ns);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninode = iget_locked(sb, ns_ops->inum(ns));\r\nif (!inode) {\r\ndput(dentry);\r\nns_ops->put(ns);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nei = PROC_I(inode);\r\nif (inode->i_state & I_NEW) {\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_op = &ns_inode_operations;\r\ninode->i_mode = S_IFREG | S_IRUGO;\r\ninode->i_fop = &ns_file_operations;\r\nei->ns.ns_ops = ns_ops;\r\nei->ns.ns = ns;\r\nunlock_new_inode(inode);\r\n} else {\r\nns_ops->put(ns);\r\n}\r\nd_set_d_op(dentry, &ns_dentry_operations);\r\nresult = d_instantiate_unique(dentry, inode);\r\nif (result) {\r\ndput(dentry);\r\ndentry = result;\r\n}\r\nreturn dentry;\r\n}\r\nstatic void *proc_ns_follow_link(struct dentry *dentry, struct nameidata *nd)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct proc_inode *ei = PROC_I(inode);\r\nstruct task_struct *task;\r\nstruct path ns_path;\r\nvoid *error = ERR_PTR(-EACCES);\r\ntask = get_proc_task(inode);\r\nif (!task)\r\ngoto out;\r\nif (!ptrace_may_access(task, PTRACE_MODE_READ))\r\ngoto out_put_task;\r\nns_path.dentry = proc_ns_get_dentry(sb, task, ei->ns.ns_ops);\r\nif (IS_ERR(ns_path.dentry)) {\r\nerror = ERR_CAST(ns_path.dentry);\r\ngoto out_put_task;\r\n}\r\nns_path.mnt = mntget(nd->path.mnt);\r\nnd_jump_link(nd, &ns_path);\r\nerror = NULL;\r\nout_put_task:\r\nput_task_struct(task);\r\nout:\r\nreturn error;\r\n}\r\nstatic int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int buflen)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct proc_inode *ei = PROC_I(inode);\r\nconst struct proc_ns_operations *ns_ops = ei->ns.ns_ops;\r\nstruct task_struct *task;\r\nvoid *ns;\r\nchar name[50];\r\nint len = -EACCES;\r\ntask = get_proc_task(inode);\r\nif (!task)\r\ngoto out;\r\nif (!ptrace_may_access(task, PTRACE_MODE_READ))\r\ngoto out_put_task;\r\nlen = -ENOENT;\r\nns = ns_ops->get(task);\r\nif (!ns)\r\ngoto out_put_task;\r\nsnprintf(name, sizeof(name), "%s:[%u]", ns_ops->name, ns_ops->inum(ns));\r\nlen = strlen(name);\r\nif (len > buflen)\r\nlen = buflen;\r\nif (copy_to_user(buffer, name, len))\r\nlen = -EFAULT;\r\nns_ops->put(ns);\r\nout_put_task:\r\nput_task_struct(task);\r\nout:\r\nreturn len;\r\n}\r\nstatic int proc_ns_instantiate(struct inode *dir,\r\nstruct dentry *dentry, struct task_struct *task, const void *ptr)\r\n{\r\nconst struct proc_ns_operations *ns_ops = ptr;\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\ninode = proc_pid_make_inode(dir->i_sb, task);\r\nif (!inode)\r\ngoto out;\r\nei = PROC_I(inode);\r\ninode->i_mode = S_IFLNK|S_IRWXUGO;\r\ninode->i_op = &proc_ns_link_inode_operations;\r\nei->ns.ns_ops = ns_ops;\r\nd_set_d_op(dentry, &pid_dentry_operations);\r\nd_add(dentry, inode);\r\nif (pid_revalidate(dentry, 0))\r\nreturn 0;\r\nout:\r\nreturn -ENOENT;\r\n}\r\nstatic int proc_ns_dir_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct task_struct *task = get_proc_task(file_inode(file));\r\nconst struct proc_ns_operations **entry, **last;\r\nif (!task)\r\nreturn -ENOENT;\r\nif (!dir_emit_dots(file, ctx))\r\ngoto out;\r\nif (ctx->pos >= 2 + ARRAY_SIZE(ns_entries))\r\ngoto out;\r\nentry = ns_entries + (ctx->pos - 2);\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\r\nwhile (entry <= last) {\r\nconst struct proc_ns_operations *ops = *entry;\r\nif (!proc_fill_cache(file, ctx, ops->name, strlen(ops->name),\r\nproc_ns_instantiate, task, ops))\r\nbreak;\r\nctx->pos++;\r\nentry++;\r\n}\r\nout:\r\nput_task_struct(task);\r\nreturn 0;\r\n}\r\nstatic struct dentry *proc_ns_dir_lookup(struct inode *dir,\r\nstruct dentry *dentry, unsigned int flags)\r\n{\r\nint error;\r\nstruct task_struct *task = get_proc_task(dir);\r\nconst struct proc_ns_operations **entry, **last;\r\nunsigned int len = dentry->d_name.len;\r\nerror = -ENOENT;\r\nif (!task)\r\ngoto out_no_task;\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries)];\r\nfor (entry = ns_entries; entry < last; entry++) {\r\nif (strlen((*entry)->name) != len)\r\ncontinue;\r\nif (!memcmp(dentry->d_name.name, (*entry)->name, len))\r\nbreak;\r\n}\r\nif (entry == last)\r\ngoto out;\r\nerror = proc_ns_instantiate(dir, dentry, task, *entry);\r\nout:\r\nput_task_struct(task);\r\nout_no_task:\r\nreturn ERR_PTR(error);\r\n}\r\nstruct file *proc_ns_fget(int fd)\r\n{\r\nstruct file *file;\r\nfile = fget(fd);\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nif (file->f_op != &ns_file_operations)\r\ngoto out_invalid;\r\nreturn file;\r\nout_invalid:\r\nfput(file);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstruct proc_ns *get_proc_ns(struct inode *inode)\r\n{\r\nreturn &PROC_I(inode)->ns;\r\n}\r\nbool proc_ns_inode(struct inode *inode)\r\n{\r\nreturn inode->i_fop == &ns_file_operations;\r\n}
