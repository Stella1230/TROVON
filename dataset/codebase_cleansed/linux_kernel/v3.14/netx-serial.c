static void netx_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = readl(port->membase + UART_CR);\r\nwritel(val & ~CR_TIE, port->membase + UART_CR);\r\n}\r\nstatic void netx_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = readl(port->membase + UART_CR);\r\nwritel(val & ~CR_RIE, port->membase + UART_CR);\r\n}\r\nstatic void netx_enable_ms(struct uart_port *port)\r\n{\r\nunsigned int val;\r\nval = readl(port->membase + UART_CR);\r\nwritel(val | CR_MSIE, port->membase + UART_CR);\r\n}\r\nstatic inline void netx_transmit_buffer(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nwritel(port->x_char, port->membase + UART_DR);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_tx_stopped(port) || uart_circ_empty(xmit)) {\r\nnetx_stop_tx(port);\r\nreturn;\r\n}\r\ndo {\r\nwritel(xmit->buf[xmit->tail], port->membase + UART_DR);\r\nxmit->tail = (xmit->tail + 1) &\r\n(UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (!(readl(port->membase + UART_FR) & FR_TXFF));\r\nif (uart_circ_empty(xmit))\r\nnetx_stop_tx(port);\r\n}\r\nstatic void netx_start_tx(struct uart_port *port)\r\n{\r\nwritel(\r\nreadl(port->membase + UART_CR) | CR_TIE, port->membase + UART_CR);\r\nif (!(readl(port->membase + UART_FR) & FR_TXFF))\r\nnetx_transmit_buffer(port);\r\n}\r\nstatic unsigned int netx_tx_empty(struct uart_port *port)\r\n{\r\nreturn readl(port->membase + UART_FR) & FR_BUSY ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic void netx_txint(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nnetx_stop_tx(port);\r\nreturn;\r\n}\r\nnetx_transmit_buffer(port);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void netx_rxint(struct uart_port *port, unsigned long *flags)\r\n{\r\nunsigned char rx, flg, status;\r\nwhile (!(readl(port->membase + UART_FR) & FR_RXFE)) {\r\nrx = readl(port->membase + UART_DR);\r\nflg = TTY_NORMAL;\r\nport->icount.rx++;\r\nstatus = readl(port->membase + UART_SR);\r\nif (status & SR_BE) {\r\nwritel(0, port->membase + UART_SR);\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (unlikely(status & (SR_FE | SR_PE | SR_OE))) {\r\nif (status & SR_PE)\r\nport->icount.parity++;\r\nelse if (status & SR_FE)\r\nport->icount.frame++;\r\nif (status & SR_OE)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & SR_BE)\r\nflg = TTY_BREAK;\r\nelse if (status & SR_PE)\r\nflg = TTY_PARITY;\r\nelse if (status & SR_FE)\r\nflg = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, rx))\r\ncontinue;\r\nuart_insert_char(port, status, SR_OE, rx, flg);\r\n}\r\nspin_unlock_irqrestore(&port->lock, *flags);\r\ntty_flip_buffer_push(&port->state->port);\r\nspin_lock_irqsave(&port->lock, *flags);\r\n}\r\nstatic irqreturn_t netx_int(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned long flags;\r\nunsigned char status;\r\nspin_lock_irqsave(&port->lock,flags);\r\nstatus = readl(port->membase + UART_IIR) & IIR_MASK;\r\nwhile (status) {\r\nif (status & IIR_RIS)\r\nnetx_rxint(port, &flags);\r\nif (status & IIR_TIS)\r\nnetx_txint(port);\r\nif (status & IIR_MIS) {\r\nif (readl(port->membase + UART_FR) & FR_CTS)\r\nuart_handle_cts_change(port, 1);\r\nelse\r\nuart_handle_cts_change(port, 0);\r\n}\r\nwritel(0, port->membase + UART_IIR);\r\nstatus = readl(port->membase + UART_IIR) & IIR_MASK;\r\n}\r\nspin_unlock_irqrestore(&port->lock,flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int netx_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int ret = TIOCM_DSR | TIOCM_CAR;\r\nif (readl(port->membase + UART_FR) & FR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void netx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned int val;\r\nif (mctrl & TIOCM_RTS) {\r\nval = readl(port->membase + UART_RTS_CR);\r\nwritel(val | RTS_CR_RTS, port->membase + UART_RTS_CR);\r\n}\r\n}\r\nstatic void netx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nunsigned int line_cr;\r\nspin_lock_irq(&port->lock);\r\nline_cr = readl(port->membase + UART_LINE_CR);\r\nif (break_state != 0)\r\nline_cr |= LINE_CR_BRK;\r\nelse\r\nline_cr &= ~LINE_CR_BRK;\r\nwritel(line_cr, port->membase + UART_LINE_CR);\r\nspin_unlock_irq(&port->lock);\r\n}\r\nstatic int netx_startup(struct uart_port *port)\r\n{\r\nint ret;\r\nret = request_irq(port->irq, netx_int, 0,\r\nDRIVER_NAME, port);\r\nif (ret) {\r\ndev_err(port->dev, "unable to grab irq%d\n",port->irq);\r\ngoto exit;\r\n}\r\nwritel(readl(port->membase + UART_LINE_CR) | LINE_CR_FEN,\r\nport->membase + UART_LINE_CR);\r\nwritel(CR_MSIE | CR_RIE | CR_TIE | CR_RTIE | CR_UART_EN,\r\nport->membase + UART_CR);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void netx_shutdown(struct uart_port *port)\r\n{\r\nwritel(0, port->membase + UART_CR) ;\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void\r\nnetx_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud, quot;\r\nunsigned char old_cr;\r\nunsigned char line_cr = LINE_CR_FEN;\r\nunsigned char rts_cr = 0;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nline_cr |= LINE_CR_5BIT;\r\nbreak;\r\ncase CS6:\r\nline_cr |= LINE_CR_6BIT;\r\nbreak;\r\ncase CS7:\r\nline_cr |= LINE_CR_7BIT;\r\nbreak;\r\ncase CS8:\r\nline_cr |= LINE_CR_8BIT;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nline_cr |= LINE_CR_STP2;\r\nif (termios->c_cflag & PARENB) {\r\nline_cr |= LINE_CR_PEN;\r\nif (!(termios->c_cflag & PARODD))\r\nline_cr |= LINE_CR_EPS;\r\n}\r\nif (termios->c_cflag & CRTSCTS)\r\nrts_cr = RTS_CR_AUTO | RTS_CR_CTS_CTR | RTS_CR_RTS_POL;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = baud * 4096;\r\nquot /= 1000;\r\nquot *= 256;\r\nquot /= 100000;\r\nspin_lock_irq(&port->lock);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nold_cr = readl(port->membase + UART_CR);\r\nwritel(old_cr & ~(CR_MSIE | CR_RIE | CR_TIE | CR_RTIE),\r\nport->membase + UART_CR);\r\nwhile (readl(port->membase + UART_FR) & FR_BUSY);\r\nwritel(old_cr & ~CR_UART_EN, port->membase + UART_CR);\r\nold_cr &= ~CR_MSIE;\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\nold_cr |= CR_MSIE;\r\nwritel((quot>>8) & 0xff, port->membase + UART_BAUDDIV_MSB);\r\nwritel(quot & 0xff, port->membase + UART_BAUDDIV_LSB);\r\nwritel(line_cr, port->membase + UART_LINE_CR);\r\nwritel(rts_cr, port->membase + UART_RTS_CR);\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= SR_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= SR_BE;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= SR_PE;\r\n}\r\nport->read_status_mask = 0;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= SR_BE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= SR_PE | SR_FE;\r\nwritel(old_cr, port->membase + UART_CR);\r\nspin_unlock_irq(&port->lock);\r\n}\r\nstatic const char *netx_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_NETX ? "NETX" : NULL;\r\n}\r\nstatic void netx_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, UART_PORT_SIZE);\r\n}\r\nstatic int netx_request_port(struct uart_port *port)\r\n{\r\nreturn request_mem_region(port->mapbase, UART_PORT_SIZE,\r\nDRIVER_NAME) != NULL ? 0 : -EBUSY;\r\n}\r\nstatic void netx_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE && netx_request_port(port) == 0)\r\nport->type = PORT_NETX;\r\n}\r\nstatic int\r\nnetx_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_NETX)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void netx_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (readl(port->membase + UART_FR) & FR_BUSY);\r\nwritel(ch, port->membase + UART_DR);\r\n}\r\nstatic void\r\nnetx_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_port *port = &netx_ports[co->index].port;\r\nunsigned char cr_save;\r\ncr_save = readl(port->membase + UART_CR);\r\nwritel(cr_save | CR_UART_EN, port->membase + UART_CR);\r\nuart_console_write(port, s, count, netx_console_putchar);\r\nwhile (readl(port->membase + UART_FR) & FR_BUSY);\r\nwritel(cr_save, port->membase + UART_CR);\r\n}\r\nstatic void __init\r\nnetx_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits, int *flow)\r\n{\r\nunsigned char line_cr;\r\n*baud = (readl(port->membase + UART_BAUDDIV_MSB) << 8) |\r\nreadl(port->membase + UART_BAUDDIV_LSB);\r\n*baud *= 1000;\r\n*baud /= 4096;\r\n*baud *= 1000;\r\n*baud /= 256;\r\n*baud *= 100;\r\nline_cr = readl(port->membase + UART_LINE_CR);\r\n*parity = 'n';\r\nif (line_cr & LINE_CR_PEN) {\r\nif (line_cr & LINE_CR_EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\nswitch (line_cr & LINE_CR_BITS_MASK) {\r\ncase LINE_CR_8BIT:\r\n*bits = 8;\r\nbreak;\r\ncase LINE_CR_7BIT:\r\n*bits = 7;\r\nbreak;\r\ncase LINE_CR_6BIT:\r\n*bits = 6;\r\nbreak;\r\ncase LINE_CR_5BIT:\r\n*bits = 5;\r\nbreak;\r\n}\r\nif (readl(port->membase + UART_RTS_CR) & RTS_CR_AUTO)\r\n*flow = 'r';\r\n}\r\nstatic int __init\r\nnetx_console_setup(struct console *co, char *options)\r\n{\r\nstruct netx_port *sport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(netx_ports))\r\nco->index = 0;\r\nsport = &netx_ports[co->index];\r\nif (options) {\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\n} else {\r\nif (readl(sport->port.membase + UART_CR) & CR_UART_EN) {\r\nnetx_console_get_options(&sport->port, &baud,\r\n&parity, &bits, &flow);\r\n}\r\n}\r\nreturn uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init netx_console_init(void)\r\n{\r\nregister_console(&netx_console);\r\nreturn 0;\r\n}\r\nstatic int serial_netx_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct netx_port *sport = platform_get_drvdata(pdev);\r\nif (sport)\r\nuart_suspend_port(&netx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_netx_resume(struct platform_device *pdev)\r\n{\r\nstruct netx_port *sport = platform_get_drvdata(pdev);\r\nif (sport)\r\nuart_resume_port(&netx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_netx_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = &netx_ports[pdev->id].port;\r\ndev_info(&pdev->dev, "initialising\n");\r\nport->dev = &pdev->dev;\r\nwritel(1, port->membase + UART_RXFIFO_IRQLEVEL);\r\nuart_add_one_port(&netx_reg, &netx_ports[pdev->id].port);\r\nplatform_set_drvdata(pdev, &netx_ports[pdev->id]);\r\nreturn 0;\r\n}\r\nstatic int serial_netx_remove(struct platform_device *pdev)\r\n{\r\nstruct netx_port *sport = platform_get_drvdata(pdev);\r\nif (sport)\r\nuart_remove_one_port(&netx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int __init netx_serial_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Serial: NetX driver\n");\r\nret = uart_register_driver(&netx_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&serial_netx_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&netx_reg);\r\nreturn 0;\r\n}\r\nstatic void __exit netx_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_netx_driver);\r\nuart_unregister_driver(&netx_reg);\r\n}
