static inline int lin11_to_val(int data)\r\n{\r\ns16 e = ((s16)data) >> 11;\r\ns32 m = (((s16)(data << 5)) >> 5);\r\ne += 6;\r\nreturn (e < 0 ? m >> -e : m << e);\r\n}\r\nstatic int ltc2978_read_word_data_common(struct i2c_client *client, int page,\r\nint reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_VIN_MAX:\r\nret = pmbus_read_word_data(client, page, LTC2978_MFR_VIN_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret) > lin11_to_val(data->vin_max))\r\ndata->vin_max = ret;\r\nret = data->vin_max;\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_VOUT_MAX:\r\nret = pmbus_read_word_data(client, page, LTC2978_MFR_VOUT_PEAK);\r\nif (ret >= 0) {\r\nif (ret > data->vout_max[page])\r\ndata->vout_max[page] = ret;\r\nret = data->vout_max[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP_MAX:\r\nret = pmbus_read_word_data(client, page,\r\nLTC2978_MFR_TEMPERATURE_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n> lin11_to_val(data->temp_max[page]))\r\ndata->temp_max[page] = ret;\r\nret = data->temp_max[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VOUT_HISTORY:\r\ncase PMBUS_VIRT_RESET_VIN_HISTORY:\r\ncase PMBUS_VIRT_RESET_TEMP_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_VIN_MIN:\r\nret = pmbus_read_word_data(client, page, LTC2978_MFR_VIN_MIN);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret) < lin11_to_val(data->vin_min))\r\ndata->vin_min = ret;\r\nret = data->vin_min;\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_VOUT_MIN:\r\nret = pmbus_read_word_data(client, page, LTC2978_MFR_VOUT_MIN);\r\nif (ret >= 0) {\r\nif (data->vout_max[page] && ret > data->vout_max[page])\r\nret = data->vout_max[page];\r\nif (ret < data->vout_min[page])\r\ndata->vout_min[page] = ret;\r\nret = data->vout_min[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP_MIN:\r\nret = pmbus_read_word_data(client, page,\r\nLTC2978_MFR_TEMPERATURE_MIN);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n< lin11_to_val(data->temp_min[page]))\r\ndata->temp_min[page] = ret;\r\nret = data->temp_min[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ncase PMBUS_VIRT_READ_TEMP2_MAX:\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\nret = -ENXIO;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data_common(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2974_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\nret = pmbus_read_word_data(client, page, LTC2974_MFR_IOUT_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n> lin11_to_val(data->iout_max[page]))\r\ndata->iout_max[page] = ret;\r\nret = data->iout_max[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_IOUT_MIN:\r\nret = pmbus_read_word_data(client, page, LTC2974_MFR_IOUT_MIN);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n< lin11_to_val(data->iout_min[page]))\r\ndata->iout_min[page] = ret;\r\nret = data->iout_min[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc3880_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\nret = pmbus_read_word_data(client, page, LTC3880_MFR_IOUT_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n> lin11_to_val(data->iout_max[page]))\r\ndata->iout_max[page] = ret;\r\nret = data->iout_max[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP2_MAX:\r\nret = pmbus_read_word_data(client, page,\r\nLTC3880_MFR_TEMPERATURE2_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret) > lin11_to_val(data->temp2_max))\r\ndata->temp2_max = ret;\r\nret = data->temp2_max;\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_VIN_MIN:\r\ncase PMBUS_VIRT_READ_VOUT_MIN:\r\ncase PMBUS_VIRT_READ_TEMP_MIN:\r\nret = -ENXIO;\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data_common(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc3883_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IIN_MAX:\r\nret = pmbus_read_word_data(client, page, LTC3883_MFR_IIN_PEAK);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret)\r\n> lin11_to_val(data->iin_max))\r\ndata->iin_max = ret;\r\nret = data->iin_max;\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IIN_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc3880_read_word_data(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_clear_peaks(struct i2c_client *client, int page,\r\nenum chips id)\r\n{\r\nint ret;\r\nif (id == ltc3880 || id == ltc3883)\r\nret = pmbus_write_byte(client, 0, LTC3880_MFR_CLEAR_PEAKS);\r\nelse\r\nret = pmbus_write_byte(client, page, PMBUS_CLEAR_FAULTS);\r\nreturn ret;\r\n}\r\nstatic int ltc2978_write_word_data(struct i2c_client *client, int page,\r\nint reg, u16 word)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_RESET_IIN_HISTORY:\r\ndata->iin_max = 0x7c00;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ndata->iout_max[page] = 0x7c00;\r\ndata->iout_min[page] = 0xfbff;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\ndata->temp2_max = 0x7c00;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VOUT_HISTORY:\r\ndata->vout_min[page] = 0xffff;\r\ndata->vout_max[page] = 0;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VIN_HISTORY:\r\ndata->vin_min = 0x7bff;\r\ndata->vin_max = 0x7c00;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_TEMP_HISTORY:\r\ndata->temp_min[page] = 0x7bff;\r\ndata->temp_max[page] = 0x7c00;\r\nret = ltc2978_clear_peaks(client, page, data->id);\r\nbreak;\r\ndefault:\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint chip_id, i;\r\nstruct ltc2978_data *data;\r\nstruct pmbus_driver_info *info;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct ltc2978_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nchip_id = i2c_smbus_read_word_data(client, LTC2978_MFR_SPECIAL_ID);\r\nif (chip_id < 0)\r\nreturn chip_id;\r\nif (chip_id == LTC2974_ID) {\r\ndata->id = ltc2974;\r\n} else if (chip_id == LTC2977_ID) {\r\ndata->id = ltc2977;\r\n} else if (chip_id == LTC2978_ID_REV1 || chip_id == LTC2978_ID_REV2 ||\r\nchip_id == LTC2978A_ID) {\r\ndata->id = ltc2978;\r\n} else if ((chip_id & LTC3880_ID_MASK) == LTC3880_ID) {\r\ndata->id = ltc3880;\r\n} else if ((chip_id & LTC3883_ID_MASK) == LTC3883_ID) {\r\ndata->id = ltc3883;\r\n} else {\r\ndev_err(&client->dev, "Unsupported chip ID 0x%x\n", chip_id);\r\nreturn -ENODEV;\r\n}\r\nif (data->id != id->driver_data)\r\ndev_warn(&client->dev,\r\n"Device mismatch: Configured %s, detected %s\n",\r\nid->name,\r\nltc2978_id[data->id].name);\r\ninfo = &data->info;\r\ninfo->write_word_data = ltc2978_write_word_data;\r\ndata->vin_min = 0x7bff;\r\ndata->vin_max = 0x7c00;\r\nfor (i = 0; i < ARRAY_SIZE(data->vout_min); i++)\r\ndata->vout_min[i] = 0xffff;\r\nfor (i = 0; i < ARRAY_SIZE(data->iout_min); i++)\r\ndata->iout_min[i] = 0xfbff;\r\nfor (i = 0; i < ARRAY_SIZE(data->iout_max); i++)\r\ndata->iout_max[i] = 0x7c00;\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_min); i++)\r\ndata->temp_min[i] = 0x7bff;\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_max); i++)\r\ndata->temp_max[i] = 0x7c00;\r\ndata->temp2_max = 0x7c00;\r\nswitch (data->id) {\r\ncase ltc2974:\r\ninfo->read_word_data = ltc2974_read_word_data;\r\ninfo->pages = LTC2974_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_TEMP2;\r\nfor (i = 0; i < info->pages; i++) {\r\ninfo->func[i] |= PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\r\n}\r\nbreak;\r\ncase ltc2977:\r\ncase ltc2978:\r\ninfo->read_word_data = ltc2978_read_word_data;\r\ninfo->pages = LTC2978_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nfor (i = 1; i < LTC2978_NUM_PAGES; i++) {\r\ninfo->func[i] = PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT;\r\n}\r\nbreak;\r\ncase ltc3880:\r\ninfo->read_word_data = ltc3880_read_word_data;\r\ninfo->pages = LTC3880_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\ninfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ncase ltc3883:\r\ninfo->read_word_data = ltc3883_read_word_data;\r\ninfo->pages = LTC3883_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_PIN | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn pmbus_do_probe(client, id, info);\r\n}
