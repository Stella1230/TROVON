int mlx4_ib_db_map_user(struct mlx4_ib_ucontext *context, unsigned long virt,\r\nstruct mlx4_db *db)\r\n{\r\nstruct mlx4_ib_user_db_page *page;\r\nstruct ib_umem_chunk *chunk;\r\nint err = 0;\r\nmutex_lock(&context->db_page_mutex);\r\nlist_for_each_entry(page, &context->db_page_list, list)\r\nif (page->user_virt == (virt & PAGE_MASK))\r\ngoto found;\r\npage = kmalloc(sizeof *page, GFP_KERNEL);\r\nif (!page) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npage->user_virt = (virt & PAGE_MASK);\r\npage->refcnt = 0;\r\npage->umem = ib_umem_get(&context->ibucontext, virt & PAGE_MASK,\r\nPAGE_SIZE, 0, 0);\r\nif (IS_ERR(page->umem)) {\r\nerr = PTR_ERR(page->umem);\r\nkfree(page);\r\ngoto out;\r\n}\r\nlist_add(&page->list, &context->db_page_list);\r\nfound:\r\nchunk = list_entry(page->umem->chunk_list.next, struct ib_umem_chunk, list);\r\ndb->dma = sg_dma_address(chunk->page_list) + (virt & ~PAGE_MASK);\r\ndb->u.user_page = page;\r\n++page->refcnt;\r\nout:\r\nmutex_unlock(&context->db_page_mutex);\r\nreturn err;\r\n}\r\nvoid mlx4_ib_db_unmap_user(struct mlx4_ib_ucontext *context, struct mlx4_db *db)\r\n{\r\nmutex_lock(&context->db_page_mutex);\r\nif (!--db->u.user_page->refcnt) {\r\nlist_del(&db->u.user_page->list);\r\nib_umem_release(db->u.user_page->umem);\r\nkfree(db->u.user_page);\r\n}\r\nmutex_unlock(&context->db_page_mutex);\r\n}
