static inline u32 is_plgpio_set(void __iomem *base, u32 pin, u32 reg)\r\n{\r\nu32 offset = PIN_OFFSET(pin);\r\nvoid __iomem *reg_off = REG_OFFSET(base, reg, pin);\r\nu32 val = readl_relaxed(reg_off);\r\nreturn !!(val & (1 << offset));\r\n}\r\nstatic inline void plgpio_reg_set(void __iomem *base, u32 pin, u32 reg)\r\n{\r\nu32 offset = PIN_OFFSET(pin);\r\nvoid __iomem *reg_off = REG_OFFSET(base, reg, pin);\r\nu32 val = readl_relaxed(reg_off);\r\nwritel_relaxed(val | (1 << offset), reg_off);\r\n}\r\nstatic inline void plgpio_reg_reset(void __iomem *base, u32 pin, u32 reg)\r\n{\r\nu32 offset = PIN_OFFSET(pin);\r\nvoid __iomem *reg_off = REG_OFFSET(base, reg, pin);\r\nu32 val = readl_relaxed(reg_off);\r\nwritel_relaxed(val & ~(1 << offset), reg_off);\r\n}\r\nstatic int plgpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nunsigned long flags;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_DIR_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nplgpio_reg_set(plgpio->base, offset, plgpio->regs.dir);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int plgpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nunsigned long flags;\r\nunsigned dir_offset = offset, wdata_offset = offset, tmp;\r\nif (plgpio->p2o && (plgpio->p2o_regs & (PTO_DIR_REG | PTO_WDATA_REG))) {\r\ntmp = plgpio->p2o(offset);\r\nif (tmp == -1)\r\nreturn -EINVAL;\r\nif (plgpio->p2o_regs & PTO_DIR_REG)\r\ndir_offset = tmp;\r\nif (plgpio->p2o_regs & PTO_WDATA_REG)\r\nwdata_offset = tmp;\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nif (value)\r\nplgpio_reg_set(plgpio->base, wdata_offset,\r\nplgpio->regs.wdata);\r\nelse\r\nplgpio_reg_reset(plgpio->base, wdata_offset,\r\nplgpio->regs.wdata);\r\nplgpio_reg_reset(plgpio->base, dir_offset, plgpio->regs.dir);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int plgpio_get_value(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nif (offset >= chip->ngpio)\r\nreturn -EINVAL;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_RDATA_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn -EINVAL;\r\n}\r\nreturn is_plgpio_set(plgpio->base, offset, plgpio->regs.rdata);\r\n}\r\nstatic void plgpio_set_value(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nif (offset >= chip->ngpio)\r\nreturn;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_WDATA_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn;\r\n}\r\nif (value)\r\nplgpio_reg_set(plgpio->base, offset, plgpio->regs.wdata);\r\nelse\r\nplgpio_reg_reset(plgpio->base, offset, plgpio->regs.wdata);\r\n}\r\nstatic int plgpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nint gpio = chip->base + offset;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (offset >= chip->ngpio)\r\nreturn -EINVAL;\r\nret = pinctrl_request_gpio(gpio);\r\nif (ret)\r\nreturn ret;\r\nif (!IS_ERR(plgpio->clk)) {\r\nret = clk_enable(plgpio->clk);\r\nif (ret)\r\ngoto err0;\r\n}\r\nif (plgpio->regs.enb == -1)\r\nreturn 0;\r\nret = plgpio_direction_input(chip, offset);\r\nif (ret)\r\ngoto err1;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1) {\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nplgpio_reg_set(plgpio->base, offset, plgpio->regs.enb);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\nreturn 0;\r\nerr1:\r\nif (!IS_ERR(plgpio->clk))\r\nclk_disable(plgpio->clk);\r\nerr0:\r\npinctrl_free_gpio(gpio);\r\nreturn ret;\r\n}\r\nstatic void plgpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nint gpio = chip->base + offset;\r\nunsigned long flags;\r\nif (offset >= chip->ngpio)\r\nreturn;\r\nif (plgpio->regs.enb == -1)\r\ngoto disable_clk;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn;\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nplgpio_reg_reset(plgpio->base, offset, plgpio->regs.enb);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\ndisable_clk:\r\nif (!IS_ERR(plgpio->clk))\r\nclk_disable(plgpio->clk);\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int plgpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct plgpio *plgpio = container_of(chip, struct plgpio, chip);\r\nif (IS_ERR_VALUE(plgpio->irq_base))\r\nreturn -EINVAL;\r\nreturn irq_find_mapping(plgpio->irq_domain, offset);\r\n}\r\nstatic void plgpio_irq_disable(struct irq_data *d)\r\n{\r\nstruct plgpio *plgpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - plgpio->irq_base;\r\nunsigned long flags;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn;\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nplgpio_reg_set(plgpio->base, offset, plgpio->regs.ie);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\n}\r\nstatic void plgpio_irq_enable(struct irq_data *d)\r\n{\r\nstruct plgpio *plgpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - plgpio->irq_base;\r\nunsigned long flags;\r\nif (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {\r\noffset = plgpio->p2o(offset);\r\nif (offset == -1)\r\nreturn;\r\n}\r\nspin_lock_irqsave(&plgpio->lock, flags);\r\nplgpio_reg_reset(plgpio->base, offset, plgpio->regs.ie);\r\nspin_unlock_irqrestore(&plgpio->lock, flags);\r\n}\r\nstatic int plgpio_irq_set_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct plgpio *plgpio = irq_data_get_irq_chip_data(d);\r\nint offset = d->irq - plgpio->irq_base;\r\nvoid __iomem *reg_off;\r\nunsigned int supported_type = 0, val;\r\nif (offset >= plgpio->chip.ngpio)\r\nreturn -EINVAL;\r\nif (plgpio->regs.eit == -1)\r\nsupported_type = IRQ_TYPE_LEVEL_HIGH;\r\nelse\r\nsupported_type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\nif (!(trigger & supported_type))\r\nreturn -EINVAL;\r\nif (plgpio->regs.eit == -1)\r\nreturn 0;\r\nreg_off = REG_OFFSET(plgpio->base, plgpio->regs.eit, offset);\r\nval = readl_relaxed(reg_off);\r\noffset = PIN_OFFSET(offset);\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nwritel_relaxed(val | (1 << offset), reg_off);\r\nelse\r\nwritel_relaxed(val & ~(1 << offset), reg_off);\r\nreturn 0;\r\n}\r\nstatic void plgpio_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct plgpio *plgpio = irq_get_handler_data(irq);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nint regs_count, count, pin, offset, i = 0;\r\nunsigned long pending;\r\ncount = plgpio->chip.ngpio;\r\nregs_count = DIV_ROUND_UP(count, MAX_GPIO_PER_REG);\r\nchained_irq_enter(irqchip, desc);\r\nfor (; i < regs_count; i++) {\r\npending = readl_relaxed(plgpio->base + plgpio->regs.mis +\r\ni * sizeof(int *));\r\nif (!pending)\r\ncontinue;\r\nwritel_relaxed(~pending, plgpio->base + plgpio->regs.mis +\r\ni * sizeof(int *));\r\ncount = count - i * MAX_GPIO_PER_REG;\r\nif (count < MAX_GPIO_PER_REG)\r\npending &= (1 << count) - 1;\r\nfor_each_set_bit(offset, &pending, MAX_GPIO_PER_REG) {\r\nif (plgpio->o2p && (plgpio->p2o_regs & PTO_MIS_REG)) {\r\npin = plgpio->o2p(offset);\r\nif (pin == -1)\r\ncontinue;\r\n} else\r\npin = offset;\r\npin = i * MAX_GPIO_PER_REG + pin;\r\ngeneric_handle_irq(plgpio_to_irq(&plgpio->chip, pin));\r\n}\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic int spear310_p2o(int pin)\r\n{\r\nint offset = pin;\r\nif (pin <= 27)\r\noffset += 4;\r\nelse if (pin <= 33)\r\noffset = -1;\r\nelse if (pin <= 97)\r\noffset -= 2;\r\nelse if (pin <= 101)\r\noffset = 101 - pin;\r\nelse\r\noffset = -1;\r\nreturn offset;\r\n}\r\nstatic int spear310_o2p(int offset)\r\n{\r\nif (offset <= 3)\r\nreturn 101 - offset;\r\nelse if (offset <= 31)\r\nreturn offset - 4;\r\nelse\r\nreturn offset + 2;\r\n}\r\nstatic int plgpio_probe_dt(struct platform_device *pdev, struct plgpio *plgpio)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret = -EINVAL;\r\nu32 val;\r\nif (of_machine_is_compatible("st,spear310")) {\r\nplgpio->p2o = spear310_p2o;\r\nplgpio->o2p = spear310_o2p;\r\nplgpio->p2o_regs = PTO_WDATA_REG | PTO_DIR_REG | PTO_IE_REG |\r\nPTO_RDATA_REG | PTO_MIS_REG;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,ngpio", &val)) {\r\nplgpio->chip.ngpio = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid ngpio field\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,enb-reg", &val))\r\nplgpio->regs.enb = val;\r\nelse\r\nplgpio->regs.enb = -1;\r\nif (!of_property_read_u32(np, "st-plgpio,wdata-reg", &val)) {\r\nplgpio->regs.wdata = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid wdata reg\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,dir-reg", &val)) {\r\nplgpio->regs.dir = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid dir reg\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,ie-reg", &val)) {\r\nplgpio->regs.ie = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid ie reg\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,rdata-reg", &val)) {\r\nplgpio->regs.rdata = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid rdata reg\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,mis-reg", &val)) {\r\nplgpio->regs.mis = val;\r\n} else {\r\ndev_err(&pdev->dev, "DT: Invalid mis reg\n");\r\ngoto end;\r\n}\r\nif (!of_property_read_u32(np, "st-plgpio,eit-reg", &val))\r\nplgpio->regs.eit = val;\r\nelse\r\nplgpio->regs.eit = -1;\r\nreturn 0;\r\nend:\r\nreturn ret;\r\n}\r\nstatic int plgpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct plgpio *plgpio;\r\nstruct resource *res;\r\nint ret, irq, i;\r\nplgpio = devm_kzalloc(&pdev->dev, sizeof(*plgpio), GFP_KERNEL);\r\nif (!plgpio) {\r\ndev_err(&pdev->dev, "memory allocation fail\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nplgpio->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(plgpio->base))\r\nreturn PTR_ERR(plgpio->base);\r\nret = plgpio_probe_dt(pdev, plgpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "DT probe failed\n");\r\nreturn ret;\r\n}\r\nplgpio->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(plgpio->clk))\r\ndev_warn(&pdev->dev, "clk_get() failed, work without it\n");\r\n#ifdef CONFIG_PM_SLEEP\r\nplgpio->csave_regs = devm_kzalloc(&pdev->dev,\r\nsizeof(*plgpio->csave_regs) *\r\nDIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG),\r\nGFP_KERNEL);\r\nif (!plgpio->csave_regs) {\r\ndev_err(&pdev->dev, "csave registers memory allocation fail\n");\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nplatform_set_drvdata(pdev, plgpio);\r\nspin_lock_init(&plgpio->lock);\r\nplgpio->irq_base = -1;\r\nplgpio->chip.base = -1;\r\nplgpio->chip.request = plgpio_request;\r\nplgpio->chip.free = plgpio_free;\r\nplgpio->chip.direction_input = plgpio_direction_input;\r\nplgpio->chip.direction_output = plgpio_direction_output;\r\nplgpio->chip.get = plgpio_get_value;\r\nplgpio->chip.set = plgpio_set_value;\r\nplgpio->chip.to_irq = plgpio_to_irq;\r\nplgpio->chip.label = dev_name(&pdev->dev);\r\nplgpio->chip.dev = &pdev->dev;\r\nplgpio->chip.owner = THIS_MODULE;\r\nif (!IS_ERR(plgpio->clk)) {\r\nret = clk_prepare(plgpio->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk prepare failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = gpiochip_add(&plgpio->chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to add gpio chip\n");\r\ngoto unprepare_clk;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_info(&pdev->dev, "irqs not supported\n");\r\nreturn 0;\r\n}\r\nplgpio->irq_base = irq_alloc_descs(-1, 0, plgpio->chip.ngpio, 0);\r\nif (IS_ERR_VALUE(plgpio->irq_base)) {\r\ndev_warn(&pdev->dev, "couldn't allocate irq base\n");\r\nreturn 0;\r\n}\r\nplgpio->irq_domain = irq_domain_add_legacy(np, plgpio->chip.ngpio,\r\nplgpio->irq_base, 0, &irq_domain_simple_ops, NULL);\r\nif (WARN_ON(!plgpio->irq_domain)) {\r\ndev_err(&pdev->dev, "irq domain init failed\n");\r\nirq_free_descs(plgpio->irq_base, plgpio->chip.ngpio);\r\nret = -ENXIO;\r\ngoto remove_gpiochip;\r\n}\r\nirq_set_chained_handler(irq, plgpio_irq_handler);\r\nfor (i = 0; i < plgpio->chip.ngpio; i++) {\r\nirq_set_chip_and_handler(i + plgpio->irq_base, &plgpio_irqchip,\r\nhandle_simple_irq);\r\nset_irq_flags(i + plgpio->irq_base, IRQF_VALID);\r\nirq_set_chip_data(i + plgpio->irq_base, plgpio);\r\n}\r\nirq_set_handler_data(irq, plgpio);\r\ndev_info(&pdev->dev, "PLGPIO registered with IRQs\n");\r\nreturn 0;\r\nremove_gpiochip:\r\ndev_info(&pdev->dev, "Remove gpiochip\n");\r\nif (gpiochip_remove(&plgpio->chip))\r\ndev_err(&pdev->dev, "unable to remove gpiochip\n");\r\nunprepare_clk:\r\nif (!IS_ERR(plgpio->clk))\r\nclk_unprepare(plgpio->clk);\r\nreturn ret;\r\n}\r\nstatic int plgpio_suspend(struct device *dev)\r\n{\r\nstruct plgpio *plgpio = dev_get_drvdata(dev);\r\nint i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);\r\nvoid __iomem *off;\r\nfor (i = 0; i < reg_count; i++) {\r\noff = plgpio->base + i * sizeof(int *);\r\nif (plgpio->regs.enb != -1)\r\nplgpio->csave_regs[i].enb =\r\nreadl_relaxed(plgpio->regs.enb + off);\r\nif (plgpio->regs.eit != -1)\r\nplgpio->csave_regs[i].eit =\r\nreadl_relaxed(plgpio->regs.eit + off);\r\nplgpio->csave_regs[i].wdata = readl_relaxed(plgpio->regs.wdata +\r\noff);\r\nplgpio->csave_regs[i].dir = readl_relaxed(plgpio->regs.dir +\r\noff);\r\nplgpio->csave_regs[i].ie = readl_relaxed(plgpio->regs.ie + off);\r\n}\r\nreturn 0;\r\n}\r\nstatic int plgpio_resume(struct device *dev)\r\n{\r\nstruct plgpio *plgpio = dev_get_drvdata(dev);\r\nint i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);\r\nvoid __iomem *off;\r\nu32 mask, tmp;\r\nfor (i = 0; i < reg_count; i++) {\r\noff = plgpio->base + i * sizeof(int *);\r\nif (i == reg_count - 1) {\r\nmask = (1 << (plgpio->chip.ngpio - i *\r\nMAX_GPIO_PER_REG)) - 1;\r\nif (plgpio->regs.enb != -1)\r\nplgpio_prepare_reg(enb, off, mask, tmp);\r\nif (plgpio->regs.eit != -1)\r\nplgpio_prepare_reg(eit, off, mask, tmp);\r\nplgpio_prepare_reg(wdata, off, mask, tmp);\r\nplgpio_prepare_reg(dir, off, mask, tmp);\r\nplgpio_prepare_reg(ie, off, mask, tmp);\r\n}\r\nwritel_relaxed(plgpio->csave_regs[i].wdata, plgpio->regs.wdata +\r\noff);\r\nwritel_relaxed(plgpio->csave_regs[i].dir, plgpio->regs.dir +\r\noff);\r\nif (plgpio->regs.eit != -1)\r\nwritel_relaxed(plgpio->csave_regs[i].eit,\r\nplgpio->regs.eit + off);\r\nwritel_relaxed(plgpio->csave_regs[i].ie, plgpio->regs.ie + off);\r\nif (plgpio->regs.enb != -1)\r\nwritel_relaxed(plgpio->csave_regs[i].enb,\r\nplgpio->regs.enb + off);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init plgpio_init(void)\r\n{\r\nreturn platform_driver_register(&plgpio_driver);\r\n}
