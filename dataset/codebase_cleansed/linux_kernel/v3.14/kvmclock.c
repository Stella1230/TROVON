static int parse_no_kvmclock(char *arg)\r\n{\r\nkvmclock = 0;\r\nreturn 0;\r\n}\r\nstatic void kvm_get_wallclock(struct timespec *now)\r\n{\r\nstruct pvclock_vcpu_time_info *vcpu_time;\r\nint low, high;\r\nint cpu;\r\nlow = (int)__pa_symbol(&wall_clock);\r\nhigh = ((u64)__pa_symbol(&wall_clock) >> 32);\r\nnative_write_msr(msr_kvm_wall_clock, low, high);\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nvcpu_time = &hv_clock[cpu].pvti;\r\npvclock_read_wallclock(&wall_clock, vcpu_time, now);\r\npreempt_enable();\r\n}\r\nstatic int kvm_set_wallclock(const struct timespec *now)\r\n{\r\nreturn -1;\r\n}\r\nstatic cycle_t kvm_clock_read(void)\r\n{\r\nstruct pvclock_vcpu_time_info *src;\r\ncycle_t ret;\r\nint cpu;\r\npreempt_disable_notrace();\r\ncpu = smp_processor_id();\r\nsrc = &hv_clock[cpu].pvti;\r\nret = pvclock_clocksource_read(src);\r\npreempt_enable_notrace();\r\nreturn ret;\r\n}\r\nstatic cycle_t kvm_clock_get_cycles(struct clocksource *cs)\r\n{\r\nreturn kvm_clock_read();\r\n}\r\nstatic unsigned long kvm_get_tsc_khz(void)\r\n{\r\nstruct pvclock_vcpu_time_info *src;\r\nint cpu;\r\nunsigned long tsc_khz;\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nsrc = &hv_clock[cpu].pvti;\r\ntsc_khz = pvclock_tsc_khz(src);\r\npreempt_enable();\r\nreturn tsc_khz;\r\n}\r\nstatic void kvm_get_preset_lpj(void)\r\n{\r\nunsigned long khz;\r\nu64 lpj;\r\nkhz = kvm_get_tsc_khz();\r\nlpj = ((u64)khz * 1000);\r\ndo_div(lpj, HZ);\r\npreset_lpj = lpj;\r\n}\r\nbool kvm_check_and_clear_guest_paused(void)\r\n{\r\nbool ret = false;\r\nstruct pvclock_vcpu_time_info *src;\r\nint cpu = smp_processor_id();\r\nif (!hv_clock)\r\nreturn ret;\r\nsrc = &hv_clock[cpu].pvti;\r\nif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\r\nsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\r\npvclock_touch_watchdogs();\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nint kvm_register_clock(char *txt)\r\n{\r\nint cpu = smp_processor_id();\r\nint low, high, ret;\r\nstruct pvclock_vcpu_time_info *src;\r\nif (!hv_clock)\r\nreturn 0;\r\nsrc = &hv_clock[cpu].pvti;\r\nlow = (int)slow_virt_to_phys(src) | 1;\r\nhigh = ((u64)slow_virt_to_phys(src) >> 32);\r\nret = native_write_msr_safe(msr_kvm_system_time, low, high);\r\nprintk(KERN_INFO "kvm-clock: cpu %d, msr %x:%x, %s\n",\r\ncpu, high, low, txt);\r\nreturn ret;\r\n}\r\nstatic void kvm_save_sched_clock_state(void)\r\n{\r\n}\r\nstatic void kvm_restore_sched_clock_state(void)\r\n{\r\nkvm_register_clock("primary cpu clock, resume");\r\n}\r\nstatic void kvm_setup_secondary_clock(void)\r\n{\r\nWARN_ON(kvm_register_clock("secondary cpu clock"));\r\n}\r\nstatic void kvm_crash_shutdown(struct pt_regs *regs)\r\n{\r\nnative_write_msr(msr_kvm_system_time, 0, 0);\r\nkvm_disable_steal_time();\r\nnative_machine_crash_shutdown(regs);\r\n}\r\nstatic void kvm_shutdown(void)\r\n{\r\nnative_write_msr(msr_kvm_system_time, 0, 0);\r\nkvm_disable_steal_time();\r\nnative_machine_shutdown();\r\n}\r\nvoid __init kvmclock_init(void)\r\n{\r\nunsigned long mem;\r\nint size;\r\nsize = PAGE_ALIGN(sizeof(struct pvclock_vsyscall_time_info)*NR_CPUS);\r\nif (!kvm_para_available())\r\nreturn;\r\nif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\r\nmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\r\nmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\r\n} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\r\nreturn;\r\nprintk(KERN_INFO "kvm-clock: Using msrs %x and %x",\r\nmsr_kvm_system_time, msr_kvm_wall_clock);\r\nmem = memblock_alloc(size, PAGE_SIZE);\r\nif (!mem)\r\nreturn;\r\nhv_clock = __va(mem);\r\nmemset(hv_clock, 0, size);\r\nif (kvm_register_clock("boot clock")) {\r\nhv_clock = NULL;\r\nmemblock_free(mem, size);\r\nreturn;\r\n}\r\npv_time_ops.sched_clock = kvm_clock_read;\r\nx86_platform.calibrate_tsc = kvm_get_tsc_khz;\r\nx86_platform.get_wallclock = kvm_get_wallclock;\r\nx86_platform.set_wallclock = kvm_set_wallclock;\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nx86_cpuinit.early_percpu_clock_init =\r\nkvm_setup_secondary_clock;\r\n#endif\r\nx86_platform.save_sched_clock_state = kvm_save_sched_clock_state;\r\nx86_platform.restore_sched_clock_state = kvm_restore_sched_clock_state;\r\nmachine_ops.shutdown = kvm_shutdown;\r\n#ifdef CONFIG_KEXEC\r\nmachine_ops.crash_shutdown = kvm_crash_shutdown;\r\n#endif\r\nkvm_get_preset_lpj();\r\nclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\r\npv_info.paravirt_enabled = 1;\r\npv_info.name = "KVM";\r\nif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\r\npvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\r\n}\r\nint __init kvm_setup_vsyscall_timeinfo(void)\r\n{\r\n#ifdef CONFIG_X86_64\r\nint cpu;\r\nint ret;\r\nu8 flags;\r\nstruct pvclock_vcpu_time_info *vcpu_time;\r\nunsigned int size;\r\nif (!hv_clock)\r\nreturn 0;\r\nsize = PAGE_ALIGN(sizeof(struct pvclock_vsyscall_time_info)*NR_CPUS);\r\npreempt_disable();\r\ncpu = smp_processor_id();\r\nvcpu_time = &hv_clock[cpu].pvti;\r\nflags = pvclock_read_flags(vcpu_time);\r\nif (!(flags & PVCLOCK_TSC_STABLE_BIT)) {\r\npreempt_enable();\r\nreturn 1;\r\n}\r\nif ((ret = pvclock_init_vsyscall(hv_clock, size))) {\r\npreempt_enable();\r\nreturn ret;\r\n}\r\npreempt_enable();\r\nkvm_clock.archdata.vclock_mode = VCLOCK_PVCLOCK;\r\n#endif\r\nreturn 0;\r\n}
