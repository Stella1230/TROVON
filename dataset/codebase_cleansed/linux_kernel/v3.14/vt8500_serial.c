static inline void vt8500_write(struct uart_port *port, unsigned int val,\r\nunsigned int off)\r\n{\r\nwritel(val, port->membase + off);\r\n}\r\nstatic inline unsigned int vt8500_read(struct uart_port *port, unsigned int off)\r\n{\r\nreturn readl(port->membase + off);\r\n}\r\nstatic void vt8500_stop_tx(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port = container_of(port,\r\nstruct vt8500_port,\r\nuart);\r\nvt8500_port->ier &= ~TX_FIFO_INTS;\r\nvt8500_write(port, vt8500_port->ier, VT8500_URIER);\r\n}\r\nstatic void vt8500_stop_rx(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port = container_of(port,\r\nstruct vt8500_port,\r\nuart);\r\nvt8500_port->ier &= ~RX_FIFO_INTS;\r\nvt8500_write(port, vt8500_port->ier, VT8500_URIER);\r\n}\r\nstatic void vt8500_enable_ms(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port = container_of(port,\r\nstruct vt8500_port,\r\nuart);\r\nvt8500_port->ier |= TCTS;\r\nvt8500_write(port, vt8500_port->ier, VT8500_URIER);\r\n}\r\nstatic void handle_rx(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nif ((vt8500_read(port, VT8500_URISR) & RXOVER)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\n}\r\nwhile (vt8500_read(port, VT8500_URFIDX) & 0x1f00) {\r\nunsigned int c;\r\nchar flag = TTY_NORMAL;\r\nc = readw(port->membase + VT8500_RXFIFO) & 0x3ff;\r\nc &= ~port->read_status_mask;\r\nif (c & FER) {\r\nport->icount.frame++;\r\nflag = TTY_FRAME;\r\n} else if (c & PER) {\r\nport->icount.parity++;\r\nflag = TTY_PARITY;\r\n}\r\nport->icount.rx++;\r\nif (!uart_handle_sysrq_char(port, c))\r\ntty_insert_flip_char(tport, c, flag);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void handle_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nwriteb(port->x_char, port->membase + VT8500_TXFIFO);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nvt8500_stop_tx(port);\r\nreturn;\r\n}\r\nwhile ((vt8500_read(port, VT8500_URFIDX) & 0x1f) < 16) {\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nwriteb(xmit->buf[xmit->tail], port->membase + VT8500_TXFIFO);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nvt8500_stop_tx(port);\r\n}\r\nstatic void vt8500_start_tx(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port = container_of(port,\r\nstruct vt8500_port,\r\nuart);\r\nvt8500_port->ier &= ~TX_FIFO_INTS;\r\nvt8500_write(port, vt8500_port->ier, VT8500_URIER);\r\nhandle_tx(port);\r\nvt8500_port->ier |= TX_FIFO_INTS;\r\nvt8500_write(port, vt8500_port->ier, VT8500_URIER);\r\n}\r\nstatic void handle_delta_cts(struct uart_port *port)\r\n{\r\nport->icount.cts++;\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t vt8500_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned long isr;\r\nspin_lock(&port->lock);\r\nisr = vt8500_read(port, VT8500_URISR);\r\nvt8500_write(port, isr, VT8500_URISR);\r\nif (isr & RX_FIFO_INTS)\r\nhandle_rx(port);\r\nif (isr & TX_FIFO_INTS)\r\nhandle_tx(port);\r\nif (isr & TCTS)\r\nhandle_delta_cts(port);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int vt8500_tx_empty(struct uart_port *port)\r\n{\r\nreturn (vt8500_read(port, VT8500_URFIDX) & 0x1f) < 16 ?\r\nTIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int vt8500_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int usr;\r\nusr = vt8500_read(port, VT8500_URUSR);\r\nif (usr & (1 << 4))\r\nreturn TIOCM_CTS;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void vt8500_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void vt8500_break_ctl(struct uart_port *port, int break_ctl)\r\n{\r\nif (break_ctl)\r\nvt8500_write(port, vt8500_read(port, VT8500_URLCR) | (1 << 9),\r\nVT8500_URLCR);\r\n}\r\nstatic int vt8500_set_baud_rate(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned long div;\r\nunsigned int loops = 1000;\r\ndiv = vt8500_read(port, VT8500_URDIV) & ~(0x3ff);\r\nif (unlikely((baud < 900) || (baud > 921600)))\r\ndiv |= 7;\r\nelse\r\ndiv |= (921600 / baud) - 1;\r\nwhile ((vt8500_read(port, VT8500_URUSR) & (1 << 5)) && --loops)\r\ncpu_relax();\r\nvt8500_write(port, div, VT8500_URDIV);\r\nreturn baud;\r\n}\r\nstatic int vt8500_startup(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port =\r\ncontainer_of(port, struct vt8500_port, uart);\r\nint ret;\r\nsnprintf(vt8500_port->name, sizeof(vt8500_port->name),\r\n"vt8500_serial%d", port->line);\r\nret = request_irq(port->irq, vt8500_irq, IRQF_TRIGGER_HIGH,\r\nvt8500_port->name, port);\r\nif (unlikely(ret))\r\nreturn ret;\r\nvt8500_write(port, 0x03, VT8500_URLCR);\r\nreturn 0;\r\n}\r\nstatic void vt8500_shutdown(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port =\r\ncontainer_of(port, struct vt8500_port, uart);\r\nvt8500_port->ier = 0;\r\nvt8500_write(&vt8500_port->uart, 0, VT8500_URIER);\r\nvt8500_write(&vt8500_port->uart, 0x880, VT8500_URFCR);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void vt8500_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct vt8500_port *vt8500_port =\r\ncontainer_of(port, struct vt8500_port, uart);\r\nunsigned long flags;\r\nunsigned int baud, lcr;\r\nunsigned int loops = 1000;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbaud = uart_get_baud_rate(port, termios, old, 900, 921600);\r\nbaud = vt8500_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nlcr = vt8500_read(&vt8500_port->uart, VT8500_URLCR);\r\nlcr &= ~((1 << 5) | (1 << 4));\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= (1 << 4);\r\ntermios->c_cflag &= ~CMSPAR;\r\nif (termios->c_cflag & PARODD)\r\nlcr |= (1 << 5);\r\n}\r\nlcr &= ~(1 << 2);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS7:\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr |= (1 << 2);\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\nbreak;\r\n}\r\nlcr &= ~(1 << 3);\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= (1 << 3);\r\nvt8500_write(&vt8500_port->uart, lcr, VT8500_URLCR);\r\nport->read_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->read_status_mask = FER | PER;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nvt8500_write(&vt8500_port->uart, 0x88c, VT8500_URFCR);\r\nwhile ((vt8500_read(&vt8500_port->uart, VT8500_URFCR) & 0xc)\r\n&& --loops)\r\ncpu_relax();\r\nvt8500_port->ier = RX_FIFO_INTS | TX_FIFO_INTS;\r\nif (UART_ENABLE_MS(&vt8500_port->uart, termios->c_cflag))\r\nvt8500_port->ier |= TCTS;\r\nvt8500_write(&vt8500_port->uart, 0x881, VT8500_URFCR);\r\nvt8500_write(&vt8500_port->uart, vt8500_port->ier, VT8500_URIER);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *vt8500_type(struct uart_port *port)\r\n{\r\nstruct vt8500_port *vt8500_port =\r\ncontainer_of(port, struct vt8500_port, uart);\r\nreturn vt8500_port->name;\r\n}\r\nstatic void vt8500_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int vt8500_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vt8500_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_VT8500;\r\n}\r\nstatic int vt8500_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_VT8500))\r\nreturn -EINVAL;\r\nif (unlikely(port->irq != ser->irq))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_port *port)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = vt8500_read(port, VT8500_URFIDX);\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while (status & 0x10);\r\n}\r\nstatic void vt8500_console_putchar(struct uart_port *port, int c)\r\n{\r\nwait_for_xmitr(port);\r\nwriteb(c, port->membase + VT8500_TXFIFO);\r\n}\r\nstatic void vt8500_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct vt8500_port *vt8500_port = vt8500_uart_ports[co->index];\r\nunsigned long ier;\r\nBUG_ON(co->index < 0 || co->index >= vt8500_uart_driver.nr);\r\nier = vt8500_read(&vt8500_port->uart, VT8500_URIER);\r\nvt8500_write(&vt8500_port->uart, VT8500_URIER, 0);\r\nuart_console_write(&vt8500_port->uart, s, count,\r\nvt8500_console_putchar);\r\nwait_for_xmitr(&vt8500_port->uart);\r\nvt8500_write(&vt8500_port->uart, VT8500_URIER, ier);\r\n}\r\nstatic int __init vt8500_console_setup(struct console *co, char *options)\r\n{\r\nstruct vt8500_port *vt8500_port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (unlikely(co->index >= vt8500_uart_driver.nr || co->index < 0))\r\nreturn -ENXIO;\r\nvt8500_port = vt8500_uart_ports[co->index];\r\nif (!vt8500_port)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&vt8500_port->uart,\r\nco, baud, parity, bits, flow);\r\n}\r\nstatic int vt8500_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct vt8500_port *vt8500_port;\r\nstruct resource *mmres, *irqres;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nint port;\r\nmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirqres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!mmres || !irqres)\r\nreturn -ENODEV;\r\nif (np) {\r\nport = of_alias_get_id(np, "serial");\r\nif (port >= VT8500_MAX_PORTS)\r\nport = -1;\r\n} else {\r\nport = -1;\r\n}\r\nif (port < 0) {\r\nport = find_first_zero_bit(&vt8500_ports_in_use,\r\nsizeof(vt8500_ports_in_use));\r\n}\r\nif (port >= VT8500_MAX_PORTS)\r\nreturn -ENODEV;\r\nif (test_and_set_bit(port, &vt8500_ports_in_use)) {\r\nreturn -EBUSY;\r\n}\r\nvt8500_port = devm_kzalloc(&pdev->dev, sizeof(struct vt8500_port),\r\nGFP_KERNEL);\r\nif (!vt8500_port)\r\nreturn -ENOMEM;\r\nvt8500_port->uart.membase = devm_ioremap_resource(&pdev->dev, mmres);\r\nif (IS_ERR(vt8500_port->uart.membase))\r\nreturn PTR_ERR(vt8500_port->uart.membase);\r\nvt8500_port->clk = of_clk_get(pdev->dev.of_node, 0);\r\nif (IS_ERR(vt8500_port->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn -EINVAL;\r\n}\r\nret = clk_prepare_enable(vt8500_port->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nvt8500_port->uart.type = PORT_VT8500;\r\nvt8500_port->uart.iotype = UPIO_MEM;\r\nvt8500_port->uart.mapbase = mmres->start;\r\nvt8500_port->uart.irq = irqres->start;\r\nvt8500_port->uart.fifosize = 16;\r\nvt8500_port->uart.ops = &vt8500_uart_pops;\r\nvt8500_port->uart.line = port;\r\nvt8500_port->uart.dev = &pdev->dev;\r\nvt8500_port->uart.flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\r\nvt8500_port->uart.uartclk = clk_get_rate(vt8500_port->clk);\r\nsnprintf(vt8500_port->name, sizeof(vt8500_port->name),\r\n"VT8500 UART%d", pdev->id);\r\nvt8500_uart_ports[port] = vt8500_port;\r\nuart_add_one_port(&vt8500_uart_driver, &vt8500_port->uart);\r\nplatform_set_drvdata(pdev, vt8500_port);\r\nreturn 0;\r\n}\r\nstatic int vt8500_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct vt8500_port *vt8500_port = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(vt8500_port->clk);\r\nuart_remove_one_port(&vt8500_uart_driver, &vt8500_port->uart);\r\nreturn 0;\r\n}\r\nstatic int __init vt8500_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&vt8500_uart_driver);\r\nif (unlikely(ret))\r\nreturn ret;\r\nret = platform_driver_register(&vt8500_platform_driver);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&vt8500_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit vt8500_serial_exit(void)\r\n{\r\n#ifdef CONFIG_SERIAL_VT8500_CONSOLE\r\nunregister_console(&vt8500_console);\r\n#endif\r\nplatform_driver_unregister(&vt8500_platform_driver);\r\nuart_unregister_driver(&vt8500_uart_driver);\r\n}
