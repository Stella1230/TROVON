static void\r\nnouveau_fbcon_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct nouveau_fbdev *fbcon = info->par;\r\nstruct nouveau_drm *drm = nouveau_drm(fbcon->dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&drm->client.mutex)) {\r\nif (device->card_type < NV_50)\r\nret = nv04_fbcon_fillrect(info, rect);\r\nelse\r\nif (device->card_type < NV_C0)\r\nret = nv50_fbcon_fillrect(info, rect);\r\nelse\r\nret = nvc0_fbcon_fillrect(info, rect);\r\nmutex_unlock(&drm->client.mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_fillrect(info, rect);\r\n}\r\nstatic void\r\nnouveau_fbcon_copyarea(struct fb_info *info, const struct fb_copyarea *image)\r\n{\r\nstruct nouveau_fbdev *fbcon = info->par;\r\nstruct nouveau_drm *drm = nouveau_drm(fbcon->dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&drm->client.mutex)) {\r\nif (device->card_type < NV_50)\r\nret = nv04_fbcon_copyarea(info, image);\r\nelse\r\nif (device->card_type < NV_C0)\r\nret = nv50_fbcon_copyarea(info, image);\r\nelse\r\nret = nvc0_fbcon_copyarea(info, image);\r\nmutex_unlock(&drm->client.mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_copyarea(info, image);\r\n}\r\nstatic void\r\nnouveau_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct nouveau_fbdev *fbcon = info->par;\r\nstruct nouveau_drm *drm = nouveau_drm(fbcon->dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nint ret;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nret = -ENODEV;\r\nif (!in_interrupt() && !(info->flags & FBINFO_HWACCEL_DISABLED) &&\r\nmutex_trylock(&drm->client.mutex)) {\r\nif (device->card_type < NV_50)\r\nret = nv04_fbcon_imageblit(info, image);\r\nelse\r\nif (device->card_type < NV_C0)\r\nret = nv50_fbcon_imageblit(info, image);\r\nelse\r\nret = nvc0_fbcon_imageblit(info, image);\r\nmutex_unlock(&drm->client.mutex);\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret != -ENODEV)\r\nnouveau_fbcon_gpu_lockup(info);\r\ncfb_imageblit(info, image);\r\n}\r\nstatic int\r\nnouveau_fbcon_sync(struct fb_info *info)\r\n{\r\nstruct nouveau_fbdev *fbcon = info->par;\r\nstruct nouveau_drm *drm = nouveau_drm(fbcon->dev);\r\nstruct nouveau_channel *chan = drm->channel;\r\nint ret;\r\nif (!chan || !chan->accel_done || in_interrupt() ||\r\ninfo->state != FBINFO_STATE_RUNNING ||\r\ninfo->flags & FBINFO_HWACCEL_DISABLED)\r\nreturn 0;\r\nif (!mutex_trylock(&drm->client.mutex))\r\nreturn 0;\r\nret = nouveau_channel_idle(chan);\r\nmutex_unlock(&drm->client.mutex);\r\nif (ret) {\r\nnouveau_fbcon_gpu_lockup(info);\r\nreturn 0;\r\n}\r\nchan->accel_done = false;\r\nreturn 0;\r\n}\r\nstatic void nouveau_fbcon_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnv_crtc->lut.r[regno] = red;\r\nnv_crtc->lut.g[regno] = green;\r\nnv_crtc->lut.b[regno] = blue;\r\n}\r\nstatic void nouveau_fbcon_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\n*red = nv_crtc->lut.r[regno];\r\n*green = nv_crtc->lut.g[regno];\r\n*blue = nv_crtc->lut.b[regno];\r\n}\r\nstatic void\r\nnouveau_fbcon_zfill(struct drm_device *dev, struct nouveau_fbdev *fbcon)\r\n{\r\nstruct fb_info *info = fbcon->helper.fbdev;\r\nstruct fb_fillrect rect;\r\nrect.dx = rect.dy = 0;\r\nrect.width = info->var.xres_virtual;\r\nrect.height = info->var.yres_virtual;\r\nrect.color = 0;\r\nrect.rop = ROP_COPY;\r\ninfo->fbops->fb_fillrect(info, &rect);\r\n}\r\nstatic int\r\nnouveau_fbcon_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct nouveau_fbdev *fbcon = (struct nouveau_fbdev *)helper;\r\nstruct drm_device *dev = fbcon->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct nouveau_framebuffer *nouveau_fb;\r\nstruct nouveau_channel *chan;\r\nstruct nouveau_bo *nvbo;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct pci_dev *pdev = dev->pdev;\r\nint size, ret;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * (sizes->surface_bpp >> 3);\r\nmode_cmd.pitches[0] = roundup(mode_cmd.pitches[0], 256);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nsize = roundup(size, PAGE_SIZE);\r\nret = nouveau_gem_new(dev, size, 0, NOUVEAU_GEM_DOMAIN_VRAM,\r\n0, 0x0000, &nvbo);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to allocate framebuffer\n");\r\ngoto out;\r\n}\r\nret = nouveau_bo_pin(nvbo, TTM_PL_FLAG_VRAM);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to pin fb: %d\n", ret);\r\ngoto out_unref;\r\n}\r\nret = nouveau_bo_map(nvbo);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to map fb: %d\n", ret);\r\ngoto out_unpin;\r\n}\r\nchan = nouveau_nofbaccel ? NULL : drm->channel;\r\nif (chan && device->card_type >= NV_50) {\r\nret = nouveau_bo_vma_add(nvbo, nv_client(chan->cli)->vm,\r\n&fbcon->nouveau_fb.vma);\r\nif (ret) {\r\nNV_ERROR(drm, "failed to map fb into chan: %d\n", ret);\r\nchan = NULL;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\ninfo = framebuffer_alloc(0, &pdev->dev);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nret = -ENOMEM;\r\nframebuffer_release(info);\r\ngoto out_unlock;\r\n}\r\ninfo->par = fbcon;\r\nnouveau_framebuffer_init(dev, &fbcon->nouveau_fb, &mode_cmd, nvbo);\r\nnouveau_fb = &fbcon->nouveau_fb;\r\nfb = &nouveau_fb->base;\r\nfbcon->helper.fb = fb;\r\nfbcon->helper.fbdev = info;\r\nstrcpy(info->fix.id, "nouveaufb");\r\nif (!chan)\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_DISABLED;\r\nelse\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\ninfo->flags |= FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &nouveau_fbcon_sw_ops;\r\ninfo->fix.smem_start = nvbo->bo.mem.bus.base +\r\nnvbo->bo.mem.bus.offset;\r\ninfo->fix.smem_len = size;\r\ninfo->screen_base = nvbo_kmap_obj_iovirtual(nouveau_fb->nvbo);\r\ninfo->screen_size = size;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &fbcon->helper, sizes->fb_width, sizes->fb_height);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (chan) {\r\nret = -ENODEV;\r\nif (device->card_type < NV_50)\r\nret = nv04_fbcon_accel_init(info);\r\nelse\r\nif (device->card_type < NV_C0)\r\nret = nv50_fbcon_accel_init(info);\r\nelse\r\nret = nvc0_fbcon_accel_init(info);\r\nif (ret == 0)\r\ninfo->fbops = &nouveau_fbcon_ops;\r\n}\r\nnouveau_fbcon_zfill(dev, fbcon);\r\nNV_INFO(drm, "allocated %dx%d fb: 0x%lx, bo %p\n",\r\nnouveau_fb->base.width, nouveau_fb->base.height,\r\nnvbo->bo.offset, nvbo);\r\nvga_switcheroo_client_fb_set(dev->pdev, info);\r\nreturn 0;\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nif (chan)\r\nnouveau_bo_vma_del(nvbo, &fbcon->nouveau_fb.vma);\r\nnouveau_bo_unmap(nvbo);\r\nout_unpin:\r\nnouveau_bo_unpin(nvbo);\r\nout_unref:\r\nnouveau_bo_ref(NULL, &nvbo);\r\nout:\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_fbcon_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->fbcon)\r\ndrm_fb_helper_hotplug_event(&drm->fbcon->helper);\r\n}\r\nstatic int\r\nnouveau_fbcon_destroy(struct drm_device *dev, struct nouveau_fbdev *fbcon)\r\n{\r\nstruct nouveau_framebuffer *nouveau_fb = &fbcon->nouveau_fb;\r\nstruct fb_info *info;\r\nif (fbcon->helper.fbdev) {\r\ninfo = fbcon->helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nif (nouveau_fb->nvbo) {\r\nnouveau_bo_unmap(nouveau_fb->nvbo);\r\nnouveau_bo_vma_del(nouveau_fb->nvbo, &nouveau_fb->vma);\r\nnouveau_bo_unpin(nouveau_fb->nvbo);\r\ndrm_gem_object_unreference_unlocked(&nouveau_fb->nvbo->gem);\r\nnouveau_fb->nvbo = NULL;\r\n}\r\ndrm_fb_helper_fini(&fbcon->helper);\r\ndrm_framebuffer_unregister_private(&nouveau_fb->base);\r\ndrm_framebuffer_cleanup(&nouveau_fb->base);\r\nreturn 0;\r\n}\r\nvoid nouveau_fbcon_gpu_lockup(struct fb_info *info)\r\n{\r\nstruct nouveau_fbdev *fbcon = info->par;\r\nstruct nouveau_drm *drm = nouveau_drm(fbcon->dev);\r\nNV_ERROR(drm, "GPU lockup - switching to software fbcon\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\nint\r\nnouveau_fbcon_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(drm->device);\r\nstruct nouveau_fbdev *fbcon;\r\nint preferred_bpp;\r\nint ret;\r\nif (!dev->mode_config.num_crtc ||\r\n(dev->pdev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\r\nreturn 0;\r\nfbcon = kzalloc(sizeof(struct nouveau_fbdev), GFP_KERNEL);\r\nif (!fbcon)\r\nreturn -ENOMEM;\r\nfbcon->dev = dev;\r\ndrm->fbcon = fbcon;\r\nfbcon->helper.funcs = &nouveau_fbcon_helper_funcs;\r\nret = drm_fb_helper_init(dev, &fbcon->helper,\r\ndev->mode_config.num_crtc, 4);\r\nif (ret) {\r\nkfree(fbcon);\r\nreturn ret;\r\n}\r\ndrm_fb_helper_single_add_all_connectors(&fbcon->helper);\r\nif (pfb->ram->size <= 32 * 1024 * 1024)\r\npreferred_bpp = 8;\r\nelse\r\nif (pfb->ram->size <= 64 * 1024 * 1024)\r\npreferred_bpp = 16;\r\nelse\r\npreferred_bpp = 32;\r\ndrm_helper_disable_unused_functions(dev);\r\ndrm_fb_helper_initial_config(&fbcon->helper, preferred_bpp);\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_fbcon_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (!drm->fbcon)\r\nreturn;\r\nnouveau_fbcon_destroy(dev, drm->fbcon);\r\nkfree(drm->fbcon);\r\ndrm->fbcon = NULL;\r\n}\r\nvoid\r\nnouveau_fbcon_save_disable_accel(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->fbcon) {\r\ndrm->fbcon->saved_flags = drm->fbcon->helper.fbdev->flags;\r\ndrm->fbcon->helper.fbdev->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\n}\r\nvoid\r\nnouveau_fbcon_restore_accel(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->fbcon) {\r\ndrm->fbcon->helper.fbdev->flags = drm->fbcon->saved_flags;\r\n}\r\n}\r\nvoid\r\nnouveau_fbcon_set_suspend(struct drm_device *dev, int state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->fbcon) {\r\nconsole_lock();\r\nif (state == 0)\r\nnouveau_fbcon_save_disable_accel(dev);\r\nfb_set_suspend(drm->fbcon->helper.fbdev, state);\r\nif (state == 1)\r\nnouveau_fbcon_restore_accel(dev);\r\nconsole_unlock();\r\n}\r\n}\r\nvoid\r\nnouveau_fbcon_zfill_all(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->fbcon) {\r\nnouveau_fbcon_zfill(dev, drm->fbcon);\r\n}\r\n}
