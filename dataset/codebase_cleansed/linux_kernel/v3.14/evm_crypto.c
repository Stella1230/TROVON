static struct shash_desc *init_desc(char type)\r\n{\r\nlong rc;\r\nchar *algo;\r\nstruct crypto_shash **tfm;\r\nstruct shash_desc *desc;\r\nif (type == EVM_XATTR_HMAC) {\r\ntfm = &hmac_tfm;\r\nalgo = evm_hmac;\r\n} else {\r\ntfm = &hash_tfm;\r\nalgo = evm_hash;\r\n}\r\nif (*tfm == NULL) {\r\nmutex_lock(&mutex);\r\nif (*tfm)\r\ngoto out;\r\n*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(*tfm)) {\r\nrc = PTR_ERR(*tfm);\r\npr_err("Can not allocate %s (reason: %ld)\n", algo, rc);\r\n*tfm = NULL;\r\nmutex_unlock(&mutex);\r\nreturn ERR_PTR(rc);\r\n}\r\nif (type == EVM_XATTR_HMAC) {\r\nrc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\r\nif (rc) {\r\ncrypto_free_shash(*tfm);\r\n*tfm = NULL;\r\nmutex_unlock(&mutex);\r\nreturn ERR_PTR(rc);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mutex);\r\n}\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\r\nGFP_KERNEL);\r\nif (!desc)\r\nreturn ERR_PTR(-ENOMEM);\r\ndesc->tfm = *tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nrc = crypto_shash_init(desc);\r\nif (rc) {\r\nkfree(desc);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn desc;\r\n}\r\nstatic void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\r\nchar *digest)\r\n{\r\nstruct h_misc {\r\nunsigned long ino;\r\n__u32 generation;\r\nuid_t uid;\r\ngid_t gid;\r\numode_t mode;\r\n} hmac_misc;\r\nmemset(&hmac_misc, 0, sizeof hmac_misc);\r\nhmac_misc.ino = inode->i_ino;\r\nhmac_misc.generation = inode->i_generation;\r\nhmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\r\nhmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\r\nhmac_misc.mode = inode->i_mode;\r\ncrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof hmac_misc);\r\nif (evm_hmac_version > 1)\r\ncrypto_shash_update(desc, inode->i_sb->s_uuid,\r\nsizeof(inode->i_sb->s_uuid));\r\ncrypto_shash_final(desc, digest);\r\n}\r\nstatic int evm_calc_hmac_or_hash(struct dentry *dentry,\r\nconst char *req_xattr_name,\r\nconst char *req_xattr_value,\r\nsize_t req_xattr_value_len,\r\nchar type, char *digest)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct shash_desc *desc;\r\nchar **xattrname;\r\nsize_t xattr_size = 0;\r\nchar *xattr_value = NULL;\r\nint error;\r\nint size;\r\nif (!inode->i_op || !inode->i_op->getxattr)\r\nreturn -EOPNOTSUPP;\r\ndesc = init_desc(type);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\nerror = -ENODATA;\r\nfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\r\nif ((req_xattr_name && req_xattr_value)\r\n&& !strcmp(*xattrname, req_xattr_name)) {\r\nerror = 0;\r\ncrypto_shash_update(desc, (const u8 *)req_xattr_value,\r\nreq_xattr_value_len);\r\ncontinue;\r\n}\r\nsize = vfs_getxattr_alloc(dentry, *xattrname,\r\n&xattr_value, xattr_size, GFP_NOFS);\r\nif (size == -ENOMEM) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nif (size < 0)\r\ncontinue;\r\nerror = 0;\r\nxattr_size = size;\r\ncrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\r\n}\r\nhmac_add_misc(desc, inode, digest);\r\nout:\r\nkfree(xattr_value);\r\nkfree(desc);\r\nreturn error;\r\n}\r\nint evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\r\nconst char *req_xattr_value, size_t req_xattr_value_len,\r\nchar *digest)\r\n{\r\nreturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\r\nreq_xattr_value_len, EVM_XATTR_HMAC, digest);\r\n}\r\nint evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\r\nconst char *req_xattr_value, size_t req_xattr_value_len,\r\nchar *digest)\r\n{\r\nreturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\r\nreq_xattr_value_len, IMA_XATTR_DIGEST, digest);\r\n}\r\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\r\nconst char *xattr_value, size_t xattr_value_len)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct evm_ima_xattr_data xattr_data;\r\nint rc = 0;\r\nrc = evm_calc_hmac(dentry, xattr_name, xattr_value,\r\nxattr_value_len, xattr_data.digest);\r\nif (rc == 0) {\r\nxattr_data.type = EVM_XATTR_HMAC;\r\nrc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\r\n&xattr_data,\r\nsizeof(xattr_data), 0);\r\n} else if (rc == -ENODATA && inode->i_op->removexattr) {\r\nrc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\r\n}\r\nreturn rc;\r\n}\r\nint evm_init_hmac(struct inode *inode, const struct xattr *lsm_xattr,\r\nchar *hmac_val)\r\n{\r\nstruct shash_desc *desc;\r\ndesc = init_desc(EVM_XATTR_HMAC);\r\nif (IS_ERR(desc)) {\r\nprintk(KERN_INFO "init_desc failed\n");\r\nreturn PTR_ERR(desc);\r\n}\r\ncrypto_shash_update(desc, lsm_xattr->value, lsm_xattr->value_len);\r\nhmac_add_misc(desc, inode, hmac_val);\r\nkfree(desc);\r\nreturn 0;\r\n}\r\nint evm_init_key(void)\r\n{\r\nstruct key *evm_key;\r\nstruct encrypted_key_payload *ekp;\r\nint rc = 0;\r\nevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\r\nif (IS_ERR(evm_key))\r\nreturn -ENOENT;\r\ndown_read(&evm_key->sem);\r\nekp = evm_key->payload.data;\r\nif (ekp->decrypted_datalen > MAX_KEY_SIZE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(evmkey, ekp->decrypted_data, ekp->decrypted_datalen);\r\nout:\r\nmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\r\nup_read(&evm_key->sem);\r\nkey_put(evm_key);\r\nreturn rc;\r\n}
