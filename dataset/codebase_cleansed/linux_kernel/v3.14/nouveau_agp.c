static unsigned long\r\nget_agp_mode(struct nouveau_drm *drm, const struct drm_agp_info *info)\r\n{\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_agpmode_quirk *quirk = nouveau_agpmode_quirk_list;\r\nint agpmode = nouveau_agpmode;\r\nunsigned long mode = info->mode;\r\nif (device->chipset == 0x18)\r\nmode &= ~PCI_AGP_COMMAND_FW;\r\nwhile (agpmode == -1 && quirk->hostbridge_vendor) {\r\nif (info->id_vendor == quirk->hostbridge_vendor &&\r\ninfo->id_device == quirk->hostbridge_device &&\r\ndevice->pdev->vendor == quirk->chip_vendor &&\r\ndevice->pdev->device == quirk->chip_device) {\r\nagpmode = quirk->mode;\r\nnv_info(device, "Forcing agp mode to %dX. Use agpmode to override.\n",\r\nagpmode);\r\nbreak;\r\n}\r\n++quirk;\r\n}\r\nif (agpmode > 0) {\r\nbool agpv3 = mode & 0x8;\r\nint rate = agpv3 ? agpmode / 4 : agpmode;\r\nmode = (mode & ~0x7) | (rate & 0x7);\r\n}\r\nreturn mode;\r\n}\r\nstatic bool\r\nnouveau_agp_enabled(struct nouveau_drm *drm)\r\n{\r\nstruct drm_device *dev = drm->dev;\r\nif (!drm_pci_device_is_agp(dev) || !dev->agp)\r\nreturn false;\r\nif (drm->agp.stat == UNKNOWN) {\r\nif (!nouveau_agpmode)\r\nreturn false;\r\n#ifdef __powerpc__\r\nif (nouveau_agpmode == -1)\r\nreturn false;\r\n#endif\r\nreturn true;\r\n}\r\nreturn (drm->agp.stat == ENABLED);\r\n}\r\nvoid\r\nnouveau_agp_reset(struct nouveau_drm *drm)\r\n{\r\n#if __OS_HAS_AGP\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct drm_device *dev = drm->dev;\r\nu32 save[2];\r\nint ret;\r\nif (!nouveau_agp_enabled(drm))\r\nreturn;\r\nif ((nv_rd32(device, NV04_PBUS_PCI_NV_19) |\r\ndev->agp->mode) & PCI_AGP_COMMAND_FW) {\r\nstruct drm_agp_info info;\r\nstruct drm_agp_mode mode;\r\nret = drm_agp_info(dev, &info);\r\nif (ret)\r\nreturn;\r\nmode.mode = get_agp_mode(drm, &info);\r\nmode.mode &= ~PCI_AGP_COMMAND_FW;\r\nret = drm_agp_enable(dev, mode);\r\nif (ret)\r\nreturn;\r\n}\r\nsave[0] = nv_mask(device, NV04_PBUS_PCI_NV_1, 0x00000004, 0x00000000);\r\nnv_wr32(device, NV04_PBUS_PCI_NV_19, 0);\r\nsave[1] = nv_mask(device, 0x000200, 0x00011100, 0x00000000);\r\nnv_mask(device, 0x000200, 0x00011100, save[1]);\r\nnv_wr32(device, NV04_PBUS_PCI_NV_1, save[0]);\r\n#endif\r\n}\r\nvoid\r\nnouveau_agp_init(struct nouveau_drm *drm)\r\n{\r\n#if __OS_HAS_AGP\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct drm_device *dev = drm->dev;\r\nstruct drm_agp_info info;\r\nstruct drm_agp_mode mode;\r\nint ret;\r\nif (!nouveau_agp_enabled(drm))\r\nreturn;\r\ndrm->agp.stat = DISABLE;\r\nret = drm_agp_acquire(dev);\r\nif (ret) {\r\nnv_error(device, "unable to acquire AGP: %d\n", ret);\r\nreturn;\r\n}\r\nret = drm_agp_info(dev, &info);\r\nif (ret) {\r\nnv_error(device, "unable to get AGP info: %d\n", ret);\r\nreturn;\r\n}\r\nmode.mode = get_agp_mode(drm, &info);\r\nret = drm_agp_enable(dev, mode);\r\nif (ret) {\r\nnv_error(device, "unable to enable AGP: %d\n", ret);\r\nreturn;\r\n}\r\ndrm->agp.stat = ENABLED;\r\ndrm->agp.base = info.aperture_base;\r\ndrm->agp.size = info.aperture_size;\r\n#endif\r\n}\r\nvoid\r\nnouveau_agp_fini(struct nouveau_drm *drm)\r\n{\r\n#if __OS_HAS_AGP\r\nstruct drm_device *dev = drm->dev;\r\nif (dev->agp && dev->agp->acquired)\r\ndrm_agp_release(dev);\r\n#endif\r\n}
