static void psb_lastclose(struct drm_device *dev)\r\n{\r\nint ret;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_fbdev *fbdev = dev_priv->fbdev;\r\ndrm_modeset_lock_all(dev);\r\nret = drm_fb_helper_restore_fbdev_mode(&fbdev->psb_fb_helper);\r\nif (ret)\r\nDRM_DEBUG("failed to restore crtc mode\n");\r\ndrm_modeset_unlock_all(dev);\r\nreturn;\r\n}\r\nstatic int psb_do_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_gtt *pg = &dev_priv->gtt;\r\nuint32_t stolen_gtt;\r\nint ret = -ENOMEM;\r\nif (pg->mmu_gatt_start & 0x0FFFFFFF) {\r\ndev_err(dev->dev, "Gatt must be 256M aligned. This is a bug.\n");\r\nret = -EINVAL;\r\ngoto out_err;\r\n}\r\nstolen_gtt = (pg->stolen_size >> PAGE_SHIFT) * 4;\r\nstolen_gtt = (stolen_gtt + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstolen_gtt =\r\n(stolen_gtt < pg->gtt_pages) ? stolen_gtt : pg->gtt_pages;\r\ndev_priv->gatt_free_offset = pg->mmu_gatt_start +\r\n(stolen_gtt << PAGE_SHIFT) * 1024;\r\nspin_lock_init(&dev_priv->irqmask_lock);\r\nspin_lock_init(&dev_priv->lock_2d);\r\nPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK0);\r\nPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK1);\r\nPSB_RSGX32(PSB_CR_BIF_BANK1);\r\nPSB_WSGX32(PSB_RSGX32(PSB_CR_BIF_CTRL) | _PSB_MMU_ER_MASK,\r\nPSB_CR_BIF_CTRL);\r\npsb_spank(dev_priv);\r\nPSB_WSGX32(pg->gatt_start, PSB_CR_BIF_TWOD_REQ_BASE);\r\nreturn 0;\r\nout_err:\r\nreturn ret;\r\n}\r\nstatic int psb_driver_unload(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv) {\r\nif (dev_priv->backlight_device)\r\ngma_backlight_exit(dev);\r\npsb_modeset_cleanup(dev);\r\nif (dev_priv->ops->chip_teardown)\r\ndev_priv->ops->chip_teardown(dev);\r\npsb_intel_opregion_fini(dev);\r\nif (dev_priv->pf_pd) {\r\npsb_mmu_free_pagedir(dev_priv->pf_pd);\r\ndev_priv->pf_pd = NULL;\r\n}\r\nif (dev_priv->mmu) {\r\nstruct psb_gtt *pg = &dev_priv->gtt;\r\ndown_read(&pg->sem);\r\npsb_mmu_remove_pfn_sequence(\r\npsb_mmu_get_default_pd\r\n(dev_priv->mmu),\r\npg->mmu_gatt_start,\r\ndev_priv->vram_stolen_size >> PAGE_SHIFT);\r\nup_read(&pg->sem);\r\npsb_mmu_driver_takedown(dev_priv->mmu);\r\ndev_priv->mmu = NULL;\r\n}\r\npsb_gtt_takedown(dev);\r\nif (dev_priv->scratch_page) {\r\nset_pages_wb(dev_priv->scratch_page, 1);\r\n__free_page(dev_priv->scratch_page);\r\ndev_priv->scratch_page = NULL;\r\n}\r\nif (dev_priv->vdc_reg) {\r\niounmap(dev_priv->vdc_reg);\r\ndev_priv->vdc_reg = NULL;\r\n}\r\nif (dev_priv->sgx_reg) {\r\niounmap(dev_priv->sgx_reg);\r\ndev_priv->sgx_reg = NULL;\r\n}\r\nif (dev_priv->aux_reg) {\r\niounmap(dev_priv->aux_reg);\r\ndev_priv->aux_reg = NULL;\r\n}\r\nif (dev_priv->aux_pdev)\r\npci_dev_put(dev_priv->aux_pdev);\r\npsb_intel_destroy_bios(dev);\r\nkfree(dev_priv);\r\ndev->dev_private = NULL;\r\n}\r\ngma_power_uninit(dev);\r\nreturn 0;\r\n}\r\nstatic int psb_driver_load(struct drm_device *dev, unsigned long chipset)\r\n{\r\nstruct drm_psb_private *dev_priv;\r\nunsigned long resource_start, resource_len;\r\nunsigned long irqflags;\r\nint ret = -ENOMEM;\r\nstruct drm_connector *connector;\r\nstruct gma_encoder *gma_encoder;\r\ndev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);\r\nif (dev_priv == NULL)\r\nreturn -ENOMEM;\r\ndev_priv->ops = (struct psb_ops *)chipset;\r\ndev_priv->dev = dev;\r\ndev->dev_private = (void *) dev_priv;\r\npci_set_master(dev->pdev);\r\ndev_priv->num_pipe = dev_priv->ops->pipes;\r\nresource_start = pci_resource_start(dev->pdev, PSB_MMIO_RESOURCE);\r\ndev_priv->vdc_reg =\r\nioremap(resource_start + PSB_VDC_OFFSET, PSB_VDC_SIZE);\r\nif (!dev_priv->vdc_reg)\r\ngoto out_err;\r\ndev_priv->sgx_reg = ioremap(resource_start + dev_priv->ops->sgx_offset,\r\nPSB_SGX_SIZE);\r\nif (!dev_priv->sgx_reg)\r\ngoto out_err;\r\nif (IS_MRST(dev)) {\r\ndev_priv->aux_pdev = pci_get_bus_and_slot(0, PCI_DEVFN(3, 0));\r\nif (dev_priv->aux_pdev) {\r\nresource_start = pci_resource_start(dev_priv->aux_pdev,\r\nPSB_AUX_RESOURCE);\r\nresource_len = pci_resource_len(dev_priv->aux_pdev,\r\nPSB_AUX_RESOURCE);\r\ndev_priv->aux_reg = ioremap_nocache(resource_start,\r\nresource_len);\r\nif (!dev_priv->aux_reg)\r\ngoto out_err;\r\nDRM_DEBUG_KMS("Found aux vdc");\r\n} else {\r\ndev_priv->aux_reg = dev_priv->vdc_reg;\r\nDRM_DEBUG_KMS("Couldn't find aux pci device");\r\n}\r\ndev_priv->gmbus_reg = dev_priv->aux_reg;\r\n} else {\r\ndev_priv->gmbus_reg = dev_priv->vdc_reg;\r\n}\r\npsb_intel_opregion_setup(dev);\r\nret = dev_priv->ops->chip_setup(dev);\r\nif (ret)\r\ngoto out_err;\r\ngma_power_init(dev);\r\nret = -ENOMEM;\r\ndev_priv->scratch_page = alloc_page(GFP_DMA32 | __GFP_ZERO);\r\nif (!dev_priv->scratch_page)\r\ngoto out_err;\r\nset_pages_uc(dev_priv->scratch_page, 1);\r\nret = psb_gtt_init(dev, 0);\r\nif (ret)\r\ngoto out_err;\r\ndev_priv->mmu = psb_mmu_driver_init((void *)0,\r\ndrm_psb_trap_pagefaults, 0,\r\ndev_priv);\r\nif (!dev_priv->mmu)\r\ngoto out_err;\r\ndev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);\r\nif (!dev_priv->pf_pd)\r\ngoto out_err;\r\npsb_mmu_set_pd_context(psb_mmu_get_default_pd(dev_priv->mmu), 0);\r\npsb_mmu_set_pd_context(dev_priv->pf_pd, 1);\r\nret = psb_do_init(dev);\r\nif (ret)\r\nreturn ret;\r\nPSB_WSGX32(0x20000000, PSB_CR_PDS_EXEC_BASE);\r\nPSB_WSGX32(0x30000000, PSB_CR_BIF_3D_REQ_BASE);\r\nacpi_video_register();\r\nret = drm_vblank_init(dev, dev_priv->num_pipe);\r\nif (ret)\r\ngoto out_err;\r\ndev_priv->vdc_irq_mask = 0;\r\ndev_priv->pipestat[0] = 0;\r\ndev_priv->pipestat[1] = 0;\r\ndev_priv->pipestat[2] = 0;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\r\nPSB_WVDC32(0x00000000, PSB_INT_ENABLE_R);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_INT_MASK_R);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\ndrm_irq_install(dev);\r\ndev->vblank_disable_allowed = true;\r\ndev->max_vblank_count = 0xffffff;\r\ndev->driver->get_vblank_counter = psb_get_vblank_counter;\r\npsb_modeset_init(dev);\r\npsb_fbdev_init(dev);\r\ndrm_kms_helper_poll_init(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\ngma_encoder = gma_attached_encoder(connector);\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\ncase INTEL_OUTPUT_MIPI:\r\nret = gma_backlight_init(dev);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nreturn ret;\r\npsb_intel_opregion_enable_asle(dev);\r\n#if 0\r\npm_runtime_enable(&dev->pdev->dev);\r\npm_runtime_set_active(&dev->pdev->dev);\r\n#endif\r\nreturn 0;\r\nout_err:\r\npsb_driver_unload(dev);\r\nreturn ret;\r\n}\r\nstatic int psb_driver_device_is_agp(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void get_brightness(struct backlight_device *bd)\r\n{\r\n#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE\r\nif (bd) {\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nbacklight_update_status(bd);\r\n}\r\n#endif\r\n}\r\nstatic int psb_dpst_bl_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_psb_private *dev_priv = psb_priv(dev);\r\nuint32_t *arg = data;\r\ndev_priv->blc_adj2 = *arg;\r\nget_brightness(dev_priv->backlight_device);\r\nreturn 0;\r\n}\r\nstatic int psb_adb_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_psb_private *dev_priv = psb_priv(dev);\r\nuint32_t *arg = data;\r\ndev_priv->blc_adj1 = *arg;\r\nget_brightness(dev_priv->backlight_device);\r\nreturn 0;\r\n}\r\nstatic int psb_gamma_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_psb_dpst_lut_arg *lut_arg = data;\r\nstruct drm_mode_object *obj;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector *connector;\r\nstruct gma_crtc *gma_crtc;\r\nint i = 0;\r\nint32_t obj_id;\r\nobj_id = lut_arg->output_id;\r\nobj = drm_mode_object_find(dev, obj_id, DRM_MODE_OBJECT_CONNECTOR);\r\nif (!obj) {\r\ndev_dbg(dev->dev, "Invalid Connector object.\n");\r\nreturn -ENOENT;\r\n}\r\nconnector = obj_to_connector(obj);\r\ncrtc = connector->encoder->crtc;\r\ngma_crtc = to_gma_crtc(crtc);\r\nfor (i = 0; i < 256; i++)\r\ngma_crtc->lut_adj[i] = lut_arg->lut[i];\r\ngma_crtc_load_lut(crtc);\r\nreturn 0;\r\n}\r\nstatic int psb_mode_operation_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nuint32_t obj_id;\r\nuint16_t op;\r\nstruct drm_mode_modeinfo *umode;\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_psb_mode_operation_arg *arg;\r\nstruct drm_mode_object *obj;\r\nstruct drm_connector *connector;\r\nstruct drm_connector_helper_funcs *connector_funcs;\r\nint ret = 0;\r\nint resp = MODE_OK;\r\narg = (struct drm_psb_mode_operation_arg *)data;\r\nobj_id = arg->obj_id;\r\nop = arg->operation;\r\nswitch (op) {\r\ncase PSB_MODE_OPERATION_MODE_VALID:\r\numode = &arg->mode;\r\ndrm_modeset_lock_all(dev);\r\nobj = drm_mode_object_find(dev, obj_id,\r\nDRM_MODE_OBJECT_CONNECTOR);\r\nif (!obj) {\r\nret = -ENOENT;\r\ngoto mode_op_out;\r\n}\r\nconnector = obj_to_connector(obj);\r\nmode = drm_mode_create(dev);\r\nif (!mode) {\r\nret = -ENOMEM;\r\ngoto mode_op_out;\r\n}\r\n{\r\nmode->clock = umode->clock;\r\nmode->hdisplay = umode->hdisplay;\r\nmode->hsync_start = umode->hsync_start;\r\nmode->hsync_end = umode->hsync_end;\r\nmode->htotal = umode->htotal;\r\nmode->hskew = umode->hskew;\r\nmode->vdisplay = umode->vdisplay;\r\nmode->vsync_start = umode->vsync_start;\r\nmode->vsync_end = umode->vsync_end;\r\nmode->vtotal = umode->vtotal;\r\nmode->vscan = umode->vscan;\r\nmode->vrefresh = umode->vrefresh;\r\nmode->flags = umode->flags;\r\nmode->type = umode->type;\r\nstrncpy(mode->name, umode->name, DRM_DISPLAY_MODE_LEN);\r\nmode->name[DRM_DISPLAY_MODE_LEN-1] = 0;\r\n}\r\nconnector_funcs = (struct drm_connector_helper_funcs *)\r\nconnector->helper_private;\r\nif (connector_funcs->mode_valid) {\r\nresp = connector_funcs->mode_valid(connector, mode);\r\narg->data = resp;\r\n}\r\nif (mode)\r\ndrm_mode_destroy(dev, mode);\r\nmode_op_out:\r\ndrm_modeset_unlock_all(dev);\r\nreturn ret;\r\ndefault:\r\ndev_dbg(dev->dev, "Unsupported psb mode operation\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int psb_stolen_memory_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_psb_private *dev_priv = psb_priv(dev);\r\nstruct drm_psb_stolen_memory_arg *arg = data;\r\narg->base = dev_priv->stolen_base;\r\narg->size = dev_priv->vram_stolen_size;\r\nreturn 0;\r\n}\r\nstatic int psb_driver_open(struct drm_device *dev, struct drm_file *priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic void psb_driver_close(struct drm_device *dev, struct drm_file *priv)\r\n{\r\n}\r\nstatic long psb_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstatic unsigned int runtime_allowed;\r\nif (runtime_allowed == 1 && dev_priv->is_lvds_on) {\r\nruntime_allowed++;\r\npm_runtime_allow(&dev->pdev->dev);\r\ndev_priv->rpm_enabled = 1;\r\n}\r\nreturn drm_ioctl(filp, cmd, arg);\r\n}\r\nstatic void psb_driver_preclose(struct drm_device *dev, struct drm_file *priv)\r\n{\r\n}\r\nstatic void psb_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\ndrm_put_dev(dev);\r\n}\r\nstatic int psb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nreturn drm_get_pci_dev(pdev, ent, &driver);\r\n}\r\nstatic int __init psb_init(void)\r\n{\r\nreturn drm_pci_init(&driver, &psb_pci_driver);\r\n}\r\nstatic void __exit psb_exit(void)\r\n{\r\ndrm_pci_exit(&driver, &psb_pci_driver);\r\n}
