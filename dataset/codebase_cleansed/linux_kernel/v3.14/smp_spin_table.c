static void write_pen_release(u64 val)\r\n{\r\nvoid *start = (void *)&secondary_holding_pen_release;\r\nunsigned long size = sizeof(secondary_holding_pen_release);\r\nsecondary_holding_pen_release = val;\r\n__flush_dcache_area(start, size);\r\n}\r\nstatic int smp_spin_table_cpu_init(struct device_node *dn, unsigned int cpu)\r\n{\r\nif (of_property_read_u64(dn, "cpu-release-addr",\r\n&cpu_release_addr[cpu])) {\r\npr_err("CPU %d: missing or invalid cpu-release-addr property\n",\r\ncpu);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smp_spin_table_cpu_prepare(unsigned int cpu)\r\n{\r\nvoid **release_addr;\r\nif (!cpu_release_addr[cpu])\r\nreturn -ENODEV;\r\nrelease_addr = __va(cpu_release_addr[cpu]);\r\nrelease_addr[0] = (void *) cpu_to_le64(__pa(secondary_holding_pen));\r\n__flush_dcache_area(release_addr, sizeof(release_addr[0]));\r\nsev();\r\nreturn 0;\r\n}\r\nstatic int smp_spin_table_cpu_boot(unsigned int cpu)\r\n{\r\nunsigned long timeout;\r\nraw_spin_lock(&boot_lock);\r\nwrite_pen_release(cpu_logical_map(cpu));\r\nsev();\r\ntimeout = jiffies + (1 * HZ);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (secondary_holding_pen_release == INVALID_HWID)\r\nbreak;\r\nudelay(10);\r\n}\r\nraw_spin_unlock(&boot_lock);\r\nreturn secondary_holding_pen_release != INVALID_HWID ? -ENOSYS : 0;\r\n}\r\nvoid smp_spin_table_cpu_postboot(void)\r\n{\r\nwrite_pen_release(INVALID_HWID);\r\nraw_spin_lock(&boot_lock);\r\nraw_spin_unlock(&boot_lock);\r\n}
