static u8 max310x_port_read(struct uart_port *port, u8 reg)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\nunsigned int val = 0;\r\nregmap_read(s->regmap, port->iobase + reg, &val);\r\nreturn val;\r\n}\r\nstatic void max310x_port_write(struct uart_port *port, u8 reg, u8 val)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\nregmap_write(s->regmap, port->iobase + reg, val);\r\n}\r\nstatic void max310x_port_update(struct uart_port *port, u8 reg, u8 mask, u8 val)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\nregmap_update_bits(s->regmap, port->iobase + reg, mask, val);\r\n}\r\nstatic int max3107_detect(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nunsigned int val = 0;\r\nint ret;\r\nret = regmap_read(s->regmap, MAX310X_REVID_REG, &val);\r\nif (ret)\r\nreturn ret;\r\nif (((val & MAX310x_REV_MASK) != MAX3107_REV_ID)) {\r\ndev_err(dev,\r\n"%s ID 0x%02x does not match\n", s->devtype->name, val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max3108_detect(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nunsigned int val = 0;\r\nint ret;\r\nret = regmap_read(s->regmap, MAX310X_CLKSRC_REG, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != (MAX310X_CLKSRC_EXTCLK_BIT | MAX310X_CLKSRC_PLLBYP_BIT)) {\r\ndev_err(dev, "%s not present\n", s->devtype->name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max3109_detect(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nunsigned int val = 0;\r\nint ret;\r\nret = regmap_read(s->regmap, MAX310X_REVID_REG, &val);\r\nif (ret)\r\nreturn ret;\r\nif (((val & MAX310x_REV_MASK) != MAX3109_REV_ID)) {\r\ndev_err(dev,\r\n"%s ID 0x%02x does not match\n", s->devtype->name, val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max310x_power(struct uart_port *port, int on)\r\n{\r\nmax310x_port_update(port, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_FORCESLEEP_BIT,\r\non ? 0 : MAX310X_MODE1_FORCESLEEP_BIT);\r\nif (on)\r\nmsleep(50);\r\n}\r\nstatic int max14830_detect(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nunsigned int val = 0;\r\nint ret;\r\nret = regmap_write(s->regmap, MAX310X_GLOBALCMD_REG,\r\nMAX310X_EXTREG_ENBL);\r\nif (ret)\r\nreturn ret;\r\nregmap_read(s->regmap, MAX310X_REVID_EXTREG, &val);\r\nregmap_write(s->regmap, MAX310X_GLOBALCMD_REG, MAX310X_EXTREG_DSBL);\r\nif (((val & MAX310x_REV_MASK) != MAX14830_REV_ID)) {\r\ndev_err(dev,\r\n"%s ID 0x%02x does not match\n", s->devtype->name, val);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void max14830_power(struct uart_port *port, int on)\r\n{\r\nmax310x_port_update(port, MAX310X_BRGCFG_REG,\r\nMAX14830_BRGCFG_CLKDIS_BIT,\r\non ? 0 : MAX14830_BRGCFG_CLKDIS_BIT);\r\nif (on)\r\nmsleep(50);\r\n}\r\nstatic bool max310x_reg_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg & 0x1f) {\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_LSR_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\ncase MAX310X_TXFIFOLVL_REG:\r\ncase MAX310X_RXFIFOLVL_REG:\r\nreturn false;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\n}\r\nstatic bool max310x_reg_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg & 0x1f) {\r\ncase MAX310X_RHR_REG:\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_LSR_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\ncase MAX310X_TXFIFOLVL_REG:\r\ncase MAX310X_RXFIFOLVL_REG:\r\ncase MAX310X_GPIODATA_REG:\r\ncase MAX310X_BRGDIVLSB_REG:\r\ncase MAX310X_REG_05:\r\ncase MAX310X_REG_1F:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool max310x_reg_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg & 0x1f) {\r\ncase MAX310X_RHR_REG:\r\ncase MAX310X_IRQSTS_REG:\r\ncase MAX310X_SPCHR_IRQSTS_REG:\r\ncase MAX310X_STS_IRQSTS_REG:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic void max310x_set_baud(struct uart_port *port, int baud)\r\n{\r\nunsigned int mode = 0, div = port->uartclk / baud;\r\nif (!(div / 16)) {\r\nmode = MAX310X_BRGCFG_2XMODE_BIT;\r\ndiv = (port->uartclk * 2) / baud;\r\n}\r\nif (!(div / 16)) {\r\nmode = MAX310X_BRGCFG_4XMODE_BIT;\r\ndiv = (port->uartclk * 4) / baud;\r\n}\r\nmax310x_port_write(port, MAX310X_BRGDIVMSB_REG, (div / 16) >> 8);\r\nmax310x_port_write(port, MAX310X_BRGDIVLSB_REG, div / 16);\r\nmax310x_port_write(port, MAX310X_BRGCFG_REG, (div % 16) | mode);\r\n}\r\nstatic int max310x_update_best_err(unsigned long f, long *besterr)\r\n{\r\nlong err = f % (115200 * 16);\r\nif ((*besterr < 0) || (*besterr > err)) {\r\n*besterr = err;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int max310x_set_ref_clk(struct max310x_port *s)\r\n{\r\nunsigned int div, clksrc, pllcfg = 0;\r\nlong besterr = -1;\r\nunsigned long fdiv, fmul, bestfreq = s->pdata->frequency;\r\nmax310x_update_best_err(s->pdata->frequency, &besterr);\r\nfor (div = 1; (div <= 63) && besterr; div++) {\r\nfdiv = DIV_ROUND_CLOSEST(s->pdata->frequency, div);\r\nfmul = fdiv * 6;\r\nif ((fdiv >= 500000) && (fdiv <= 800000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (0 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 48;\r\nif ((fdiv >= 850000) && (fdiv <= 1200000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (1 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 96;\r\nif ((fdiv >= 425000) && (fdiv <= 1000000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (2 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\nfmul = fdiv * 144;\r\nif ((fdiv >= 390000) && (fdiv <= 667000))\r\nif (!max310x_update_best_err(fmul, &besterr)) {\r\npllcfg = (3 << 6) | div;\r\nbestfreq = fmul;\r\n}\r\n}\r\nif (s->pdata->driver_flags & MAX310X_EXT_CLK)\r\nclksrc = MAX310X_CLKSRC_EXTCLK_BIT;\r\nelse\r\nclksrc = MAX310X_CLKSRC_CRYST_BIT;\r\nif (pllcfg) {\r\nclksrc |= MAX310X_CLKSRC_PLL_BIT;\r\nregmap_write(s->regmap, MAX310X_PLLCFG_REG, pllcfg);\r\n} else\r\nclksrc |= MAX310X_CLKSRC_PLLBYP_BIT;\r\nregmap_write(s->regmap, MAX310X_CLKSRC_REG, clksrc);\r\nif (pllcfg && !(s->pdata->driver_flags & MAX310X_EXT_CLK))\r\nmsleep(10);\r\nreturn (int)bestfreq;\r\n}\r\nstatic void max310x_handle_rx(struct uart_port *port, unsigned int rxlen)\r\n{\r\nunsigned int sts, ch, flag;\r\nif (unlikely(rxlen >= port->fifosize)) {\r\ndev_warn_ratelimited(port->dev,\r\n"Port %i: Possible RX FIFO overrun\n",\r\nport->line);\r\nport->icount.buf_overrun++;\r\nrxlen = port->fifosize;\r\n}\r\nwhile (rxlen--) {\r\nch = max310x_port_read(port, MAX310X_RHR_REG);\r\nsts = max310x_port_read(port, MAX310X_LSR_IRQSTS_REG);\r\nsts &= MAX310X_LSR_RXPAR_BIT | MAX310X_LSR_FRERR_BIT |\r\nMAX310X_LSR_RXOVR_BIT | MAX310X_LSR_RXBRK_BIT;\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\nif (unlikely(sts)) {\r\nif (sts & MAX310X_LSR_RXBRK_BIT) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sts & MAX310X_LSR_RXPAR_BIT)\r\nport->icount.parity++;\r\nelse if (sts & MAX310X_LSR_FRERR_BIT)\r\nport->icount.frame++;\r\nelse if (sts & MAX310X_LSR_RXOVR_BIT)\r\nport->icount.overrun++;\r\nsts &= port->read_status_mask;\r\nif (sts & MAX310X_LSR_RXBRK_BIT)\r\nflag = TTY_BREAK;\r\nelse if (sts & MAX310X_LSR_RXPAR_BIT)\r\nflag = TTY_PARITY;\r\nelse if (sts & MAX310X_LSR_FRERR_BIT)\r\nflag = TTY_FRAME;\r\nelse if (sts & MAX310X_LSR_RXOVR_BIT)\r\nflag = TTY_OVERRUN;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (sts & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, sts, MAX310X_LSR_RXOVR_BIT, ch, flag);\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void max310x_handle_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int txlen, to_send;\r\nif (unlikely(port->x_char)) {\r\nmax310x_port_write(port, MAX310X_THR_REG, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nto_send = uart_circ_chars_pending(xmit);\r\nif (likely(to_send)) {\r\ntxlen = max310x_port_read(port, MAX310X_TXFIFOLVL_REG);\r\ntxlen = port->fifosize - txlen;\r\nto_send = (to_send > txlen) ? txlen : to_send;\r\nport->icount.tx += to_send;\r\nwhile (to_send--) {\r\nmax310x_port_write(port, MAX310X_THR_REG,\r\nxmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n}\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void max310x_port_irq(struct max310x_port *s, int portno)\r\n{\r\nstruct uart_port *port = &s->p[portno].port;\r\ndo {\r\nunsigned int ists, lsr, rxlen;\r\nists = max310x_port_read(port, MAX310X_IRQSTS_REG);\r\nrxlen = max310x_port_read(port, MAX310X_RXFIFOLVL_REG);\r\nif (!ists && !rxlen)\r\nbreak;\r\nif (ists & MAX310X_IRQ_CTS_BIT) {\r\nlsr = max310x_port_read(port, MAX310X_LSR_IRQSTS_REG);\r\nuart_handle_cts_change(port,\r\n!!(lsr & MAX310X_LSR_CTS_BIT));\r\n}\r\nif (rxlen)\r\nmax310x_handle_rx(port, rxlen);\r\nif (ists & MAX310X_IRQ_TXEMPTY_BIT) {\r\nmutex_lock(&s->mutex);\r\nmax310x_handle_tx(port);\r\nmutex_unlock(&s->mutex);\r\n}\r\n} while (1);\r\n}\r\nstatic irqreturn_t max310x_ist(int irq, void *dev_id)\r\n{\r\nstruct max310x_port *s = (struct max310x_port *)dev_id;\r\nif (s->uart.nr > 1) {\r\ndo {\r\nunsigned int val = ~0;\r\nWARN_ON_ONCE(regmap_read(s->regmap,\r\nMAX310X_GLOBALIRQ_REG, &val));\r\nval = ((1 << s->uart.nr) - 1) & ~val;\r\nif (!val)\r\nbreak;\r\nmax310x_port_irq(s, fls(val) - 1);\r\n} while (1);\r\n} else\r\nmax310x_port_irq(s, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max310x_wq_proc(struct work_struct *ws)\r\n{\r\nstruct max310x_one *one = container_of(ws, struct max310x_one, tx_work);\r\nstruct max310x_port *s = dev_get_drvdata(one->port.dev);\r\nmutex_lock(&s->mutex);\r\nmax310x_handle_tx(&one->port);\r\nmutex_unlock(&s->mutex);\r\n}\r\nstatic void max310x_start_tx(struct uart_port *port)\r\n{\r\nstruct max310x_one *one = container_of(port, struct max310x_one, port);\r\nif (!work_pending(&one->tx_work))\r\nschedule_work(&one->tx_work);\r\n}\r\nstatic unsigned int max310x_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int lvl, sts;\r\nlvl = max310x_port_read(port, MAX310X_TXFIFOLVL_REG);\r\nsts = max310x_port_read(port, MAX310X_IRQSTS_REG);\r\nreturn ((sts & MAX310X_IRQ_TXEMPTY_BIT) && !lvl) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int max310x_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void max310x_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void max310x_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nmax310x_port_update(port, MAX310X_LCR_REG,\r\nMAX310X_LCR_TXBREAK_BIT,\r\nbreak_state ? MAX310X_LCR_TXBREAK_BIT : 0);\r\n}\r\nstatic void max310x_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int lcr, flow = 0;\r\nint baud;\r\ntermios->c_cflag &= ~CMSPAR;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr = MAX310X_LCR_WORD_LEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr = MAX310X_LCR_WORD_LEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr = MAX310X_LCR_WORD_LEN_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nlcr = MAX310X_LCR_WORD_LEN_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= MAX310X_LCR_PARITY_BIT;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr |= MAX310X_LCR_EVENPARITY_BIT;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= MAX310X_LCR_STOPLEN_BIT;\r\nmax310x_port_write(port, MAX310X_LCR_REG, lcr);\r\nport->read_status_mask = MAX310X_LSR_RXOVR_BIT;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= MAX310X_LSR_RXPAR_BIT |\r\nMAX310X_LSR_FRERR_BIT;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= MAX310X_LSR_RXBRK_BIT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= MAX310X_LSR_RXBRK_BIT;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= MAX310X_LSR_RXPAR_BIT |\r\nMAX310X_LSR_RXOVR_BIT |\r\nMAX310X_LSR_FRERR_BIT |\r\nMAX310X_LSR_RXBRK_BIT;\r\nmax310x_port_write(port, MAX310X_XON1_REG, termios->c_cc[VSTART]);\r\nmax310x_port_write(port, MAX310X_XOFF1_REG, termios->c_cc[VSTOP]);\r\nif (termios->c_cflag & CRTSCTS)\r\nflow |= MAX310X_FLOWCTRL_AUTOCTS_BIT |\r\nMAX310X_FLOWCTRL_AUTORTS_BIT;\r\nif (termios->c_iflag & IXON)\r\nflow |= MAX310X_FLOWCTRL_SWFLOW3_BIT |\r\nMAX310X_FLOWCTRL_SWFLOWEN_BIT;\r\nif (termios->c_iflag & IXOFF)\r\nflow |= MAX310X_FLOWCTRL_SWFLOW1_BIT |\r\nMAX310X_FLOWCTRL_SWFLOWEN_BIT;\r\nmax310x_port_write(port, MAX310X_FLOWCTRL_REG, flow);\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / 16 / 0xffff,\r\nport->uartclk / 4);\r\nmax310x_set_baud(port, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\n}\r\nstatic int max310x_startup(struct uart_port *port)\r\n{\r\nunsigned int val, line = port->line;\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\ns->devtype->power(port, 1);\r\nmax310x_set_baud(port, 9600);\r\nmax310x_port_write(port, MAX310X_LCR_REG, MAX310X_LCR_WORD_LEN_8);\r\nmax310x_port_update(port, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_TRNSCVCTRL_BIT,\r\n(s->pdata->uart_flags[line] & MAX310X_AUTO_DIR_CTRL)\r\n? MAX310X_MODE1_TRNSCVCTRL_BIT : 0);\r\nval = MAX310X_MODE2_RXEMPTINV_BIT;\r\nif (s->pdata->uart_flags[line] & MAX310X_LOOPBACK)\r\nval |= MAX310X_MODE2_LOOPBACK_BIT;\r\nif (s->pdata->uart_flags[line] & MAX310X_ECHO_SUPRESS)\r\nval |= MAX310X_MODE2_ECHOSUPR_BIT;\r\nval |= MAX310X_MODE2_FIFORST_BIT;\r\nmax310x_port_write(port, MAX310X_MODE2_REG, val);\r\nmax310x_port_update(port, MAX310X_MODE2_REG,\r\nMAX310X_MODE2_FIFORST_BIT, 0);\r\nmax310x_port_write(port, MAX310X_FLOWLVL_REG,\r\nMAX310X_FLOWLVL_RES(48) | MAX310X_FLOWLVL_HALT(96));\r\nmax310x_port_read(port, MAX310X_IRQSTS_REG);\r\nval = MAX310X_IRQ_RXEMPTY_BIT | MAX310X_IRQ_TXEMPTY_BIT;\r\nmax310x_port_write(port, MAX310X_IRQEN_REG, val | MAX310X_IRQ_CTS_BIT);\r\nreturn 0;\r\n}\r\nstatic void max310x_shutdown(struct uart_port *port)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\nmax310x_port_write(port, MAX310X_IRQEN_REG, 0);\r\ns->devtype->power(port, 0);\r\n}\r\nstatic const char *max310x_type(struct uart_port *port)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(port->dev);\r\nreturn (port->type == PORT_MAX310X) ? s->devtype->name : NULL;\r\n}\r\nstatic int max310x_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void max310x_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_MAX310X;\r\n}\r\nstatic int max310x_verify_port(struct uart_port *port, struct serial_struct *s)\r\n{\r\nif ((s->type != PORT_UNKNOWN) && (s->type != PORT_MAX310X))\r\nreturn -EINVAL;\r\nif (s->irq != port->irq)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void max310x_null_void(struct uart_port *port)\r\n{\r\n}\r\nstatic int __maybe_unused max310x_suspend(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < s->uart.nr; i++) {\r\nuart_suspend_port(&s->uart, &s->p[i].port);\r\ns->devtype->power(&s->p[i].port, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused max310x_resume(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < s->uart.nr; i++) {\r\ns->devtype->power(&s->p[i].port, 1);\r\nuart_resume_port(&s->uart, &s->p[i].port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max310x_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned int val;\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nstruct uart_port *port = &s->p[offset / 4].port;\r\nval = max310x_port_read(port, MAX310X_GPIODATA_REG);\r\nreturn !!((val >> 4) & (1 << (offset % 4)));\r\n}\r\nstatic void max310x_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nstruct uart_port *port = &s->p[offset / 4].port;\r\nmax310x_port_update(port, MAX310X_GPIODATA_REG, 1 << (offset % 4),\r\nvalue ? 1 << (offset % 4) : 0);\r\n}\r\nstatic int max310x_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nstruct uart_port *port = &s->p[offset / 4].port;\r\nmax310x_port_update(port, MAX310X_GPIOCFG_REG, 1 << (offset % 4), 0);\r\nreturn 0;\r\n}\r\nstatic int max310x_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct max310x_port *s = container_of(chip, struct max310x_port, gpio);\r\nstruct uart_port *port = &s->p[offset / 4].port;\r\nmax310x_port_update(port, MAX310X_GPIODATA_REG, 1 << (offset % 4),\r\nvalue ? 1 << (offset % 4) : 0);\r\nmax310x_port_update(port, MAX310X_GPIOCFG_REG, 1 << (offset % 4),\r\n1 << (offset % 4));\r\nreturn 0;\r\n}\r\nstatic int max310x_probe(struct device *dev, int is_spi,\r\nstruct max310x_devtype *devtype, int irq)\r\n{\r\nstruct max310x_port *s;\r\nstruct max310x_pdata *pdata = dev_get_platdata(dev);\r\nint i, ret, uartclk;\r\nif (irq <= 0) {\r\ndev_err(dev, "No IRQ specified\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (!pdata) {\r\ndev_err(dev, "No platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\ns = devm_kzalloc(dev, sizeof(*s) +\r\nsizeof(struct max310x_one) * devtype->nr, GFP_KERNEL);\r\nif (!s) {\r\ndev_err(dev, "Error allocating port structure\n");\r\nreturn -ENOMEM;\r\n}\r\nif ((pdata->driver_flags & MAX310X_EXT_CLK) &&\r\n((pdata->frequency < 500000) || (pdata->frequency > 35000000)))\r\ngoto err_freq;\r\nif (!(pdata->driver_flags & MAX310X_EXT_CLK) &&\r\n((pdata->frequency < 1000000) || (pdata->frequency > 4000000)))\r\ngoto err_freq;\r\ns->pdata = pdata;\r\ns->devtype = devtype;\r\ndev_set_drvdata(dev, s);\r\nmutex_init(&s->mutex);\r\ns->regcfg.reg_bits = 8;\r\ns->regcfg.val_bits = 8;\r\ns->regcfg.read_flag_mask = 0x00;\r\ns->regcfg.write_flag_mask = 0x80;\r\ns->regcfg.cache_type = REGCACHE_RBTREE;\r\ns->regcfg.writeable_reg = max310x_reg_writeable;\r\ns->regcfg.volatile_reg = max310x_reg_volatile;\r\ns->regcfg.precious_reg = max310x_reg_precious;\r\ns->regcfg.max_register = devtype->nr * 0x20 - 1;\r\nif (IS_ENABLED(CONFIG_SPI_MASTER) && is_spi) {\r\nstruct spi_device *spi = to_spi_device(dev);\r\ns->regmap = devm_regmap_init_spi(spi, &s->regcfg);\r\n} else\r\nreturn -ENOTSUPP;\r\nif (IS_ERR(s->regmap)) {\r\ndev_err(dev, "Failed to initialize register map\n");\r\nreturn PTR_ERR(s->regmap);\r\n}\r\nif (s->pdata->init)\r\ns->pdata->init();\r\nret = devtype->detect(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < devtype->nr; i++) {\r\nunsigned int offs = i << 5;\r\nregmap_write(s->regmap, MAX310X_MODE2_REG + offs,\r\nMAX310X_MODE2_RST_BIT);\r\nregmap_write(s->regmap, MAX310X_MODE2_REG + offs, 0);\r\ndo {\r\nregmap_read(s->regmap,\r\nMAX310X_BRGDIVLSB_REG + offs, &ret);\r\n} while (ret != 0x01);\r\nregmap_update_bits(s->regmap, MAX310X_MODE1_REG + offs,\r\nMAX310X_MODE1_AUTOSLEEP_BIT,\r\nMAX310X_MODE1_AUTOSLEEP_BIT);\r\n}\r\nuartclk = max310x_set_ref_clk(s);\r\ndev_dbg(dev, "Reference clock set to %i Hz\n", uartclk);\r\ns->uart.owner = THIS_MODULE;\r\ns->uart.dev_name = "ttyMAX";\r\ns->uart.major = MAX310X_MAJOR;\r\ns->uart.minor = MAX310X_MINOR;\r\ns->uart.nr = devtype->nr;\r\nret = uart_register_driver(&s->uart);\r\nif (ret) {\r\ndev_err(dev, "Registering UART driver failed\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < devtype->nr; i++) {\r\ns->p[i].port.line = i;\r\ns->p[i].port.dev = dev;\r\ns->p[i].port.irq = irq;\r\ns->p[i].port.type = PORT_MAX310X;\r\ns->p[i].port.fifosize = MAX310X_FIFO_SIZE;\r\ns->p[i].port.flags = UPF_SKIP_TEST | UPF_FIXED_TYPE |\r\nUPF_LOW_LATENCY;\r\ns->p[i].port.iotype = UPIO_PORT;\r\ns->p[i].port.iobase = i * 0x20;\r\ns->p[i].port.membase = (void __iomem *)~0;\r\ns->p[i].port.uartclk = uartclk;\r\ns->p[i].port.ops = &max310x_ops;\r\nmax310x_port_write(&s->p[i].port, MAX310X_IRQEN_REG, 0);\r\nmax310x_port_read(&s->p[i].port, MAX310X_IRQSTS_REG);\r\nmax310x_port_update(&s->p[i].port, MAX310X_MODE1_REG,\r\nMAX310X_MODE1_IRQSEL_BIT,\r\nMAX310X_MODE1_IRQSEL_BIT);\r\nINIT_WORK(&s->p[i].tx_work, max310x_wq_proc);\r\nuart_add_one_port(&s->uart, &s->p[i].port);\r\ndevtype->power(&s->p[i].port, 0);\r\n}\r\n#ifdef CONFIG_GPIOLIB\r\nif (s->pdata->gpio_base) {\r\ns->gpio.owner = THIS_MODULE;\r\ns->gpio.dev = dev;\r\ns->gpio.label = dev_name(dev);\r\ns->gpio.direction_input = max310x_gpio_direction_input;\r\ns->gpio.get = max310x_gpio_get;\r\ns->gpio.direction_output= max310x_gpio_direction_output;\r\ns->gpio.set = max310x_gpio_set;\r\ns->gpio.base = s->pdata->gpio_base;\r\ns->gpio.ngpio = devtype->nr * 4;\r\ns->gpio.can_sleep = 1;\r\nif (!gpiochip_add(&s->gpio))\r\ns->gpio_used = 1;\r\n} else\r\ndev_info(dev, "GPIO support not enabled\n");\r\n#endif\r\nret = devm_request_threaded_irq(dev, irq, NULL, max310x_ist,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(dev), s);\r\nif (ret) {\r\ndev_err(dev, "Unable to reguest IRQ %i\n", irq);\r\n#ifdef CONFIG_GPIOLIB\r\nif (s->gpio_used)\r\nWARN_ON(gpiochip_remove(&s->gpio));\r\n#endif\r\n}\r\nreturn ret;\r\nerr_freq:\r\ndev_err(dev, "Frequency parameter incorrect\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int max310x_remove(struct device *dev)\r\n{\r\nstruct max310x_port *s = dev_get_drvdata(dev);\r\nint i, ret = 0;\r\nfor (i = 0; i < s->uart.nr; i++) {\r\ncancel_work_sync(&s->p[i].tx_work);\r\nuart_remove_one_port(&s->uart, &s->p[i].port);\r\ns->devtype->power(&s->p[i].port, 0);\r\n}\r\nuart_unregister_driver(&s->uart);\r\n#ifdef CONFIG_GPIOLIB\r\nif (s->gpio_used)\r\nret = gpiochip_remove(&s->gpio);\r\n#endif\r\nif (s->pdata->exit)\r\ns->pdata->exit();\r\nreturn ret;\r\n}\r\nstatic int max310x_spi_probe(struct spi_device *spi)\r\n{\r\nstruct max310x_devtype *devtype =\r\n(struct max310x_devtype *)spi_get_device_id(spi)->driver_data;\r\nint ret;\r\nspi->bits_per_word = 8;\r\nspi->mode = spi->mode ? : SPI_MODE_0;\r\nspi->max_speed_hz = spi->max_speed_hz ? : 26000000;\r\nret = spi_setup(spi);\r\nif (ret) {\r\ndev_err(&spi->dev, "SPI setup failed\n");\r\nreturn ret;\r\n}\r\nreturn max310x_probe(&spi->dev, 1, devtype, spi->irq);\r\n}\r\nstatic int max310x_spi_remove(struct spi_device *spi)\r\n{\r\nreturn max310x_remove(&spi->dev);\r\n}
