void drm_flip_work_queue(struct drm_flip_work *work, void *val)\r\n{\r\nif (kfifo_put(&work->fifo, val)) {\r\natomic_inc(&work->pending);\r\n} else {\r\nDRM_ERROR("%s fifo full!\n", work->name);\r\nwork->func(work, val);\r\n}\r\n}\r\nvoid drm_flip_work_commit(struct drm_flip_work *work,\r\nstruct workqueue_struct *wq)\r\n{\r\nuint32_t pending = atomic_read(&work->pending);\r\natomic_add(pending, &work->count);\r\natomic_sub(pending, &work->pending);\r\nqueue_work(wq, &work->worker);\r\n}\r\nstatic void flip_worker(struct work_struct *w)\r\n{\r\nstruct drm_flip_work *work = container_of(w, struct drm_flip_work, worker);\r\nuint32_t count = atomic_read(&work->count);\r\nvoid *val = NULL;\r\natomic_sub(count, &work->count);\r\nwhile(count--)\r\nif (!WARN_ON(!kfifo_get(&work->fifo, &val)))\r\nwork->func(work, val);\r\n}\r\nint drm_flip_work_init(struct drm_flip_work *work, int size,\r\nconst char *name, drm_flip_func_t func)\r\n{\r\nint ret;\r\nwork->name = name;\r\natomic_set(&work->count, 0);\r\natomic_set(&work->pending, 0);\r\nwork->func = func;\r\nret = kfifo_alloc(&work->fifo, size, GFP_KERNEL);\r\nif (ret) {\r\nDRM_ERROR("could not allocate %s fifo\n", name);\r\nreturn ret;\r\n}\r\nINIT_WORK(&work->worker, flip_worker);\r\nreturn 0;\r\n}\r\nvoid drm_flip_work_cleanup(struct drm_flip_work *work)\r\n{\r\nWARN_ON(!kfifo_is_empty(&work->fifo));\r\nkfifo_free(&work->fifo);\r\n}
