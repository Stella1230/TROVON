static int seq_client_rpc(struct lu_client_seq *seq,\r\nstruct lu_seq_range *output, __u32 opc,\r\nconst char *opcname)\r\n{\r\nstruct obd_export *exp = seq->lcs_exp;\r\nstruct ptlrpc_request *req;\r\nstruct lu_seq_range *out, *in;\r\n__u32 *op;\r\nunsigned int debug_mask;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp), &RQF_SEQ_QUERY,\r\nLUSTRE_MDS_VERSION, SEQ_QUERY);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nop = req_capsule_client_get(&req->rq_pill, &RMF_SEQ_OPC);\r\n*op = opc;\r\nin = req_capsule_client_get(&req->rq_pill, &RMF_SEQ_RANGE);\r\nrange_init(in);\r\nptlrpc_request_set_replen(req);\r\nin->lsr_index = seq->lcs_space.lsr_index;\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nfld_range_set_mdt(in);\r\nelse\r\nfld_range_set_ost(in);\r\nif (opc == SEQ_ALLOC_SUPER) {\r\nreq->rq_request_portal = SEQ_CONTROLLER_PORTAL;\r\nreq->rq_reply_portal = MDC_REPLY_PORTAL;\r\nif (seq->lcs_type == LUSTRE_SEQ_DATA)\r\nreq->rq_no_delay = req->rq_no_resend = 1;\r\ndebug_mask = D_CONSOLE;\r\n} else {\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nreq->rq_request_portal = SEQ_METADATA_PORTAL;\r\nelse\r\nreq->rq_request_portal = SEQ_DATA_PORTAL;\r\ndebug_mask = D_INFO;\r\n}\r\nptlrpc_at_set_req_timeout(req);\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nmdc_get_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nmdc_put_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nif (rc)\r\nGOTO(out_req, rc);\r\nout = req_capsule_server_get(&req->rq_pill, &RMF_SEQ_RANGE);\r\n*output = *out;\r\nif (!range_is_sane(output)) {\r\nCERROR("%s: Invalid range received from server: "\r\nDRANGE"\n", seq->lcs_name, PRANGE(output));\r\nGOTO(out_req, rc = -EINVAL);\r\n}\r\nif (range_is_exhausted(output)) {\r\nCERROR("%s: Range received from server is exhausted: "\r\nDRANGE"]\n", seq->lcs_name, PRANGE(output));\r\nGOTO(out_req, rc = -EINVAL);\r\n}\r\nCDEBUG_LIMIT(debug_mask, "%s: Allocated %s-sequence "DRANGE"]\n",\r\nseq->lcs_name, opcname, PRANGE(output));\r\nout_req:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint seq_client_alloc_super(struct lu_client_seq *seq,\r\nconst struct lu_env *env)\r\n{\r\nint rc;\r\nmutex_lock(&seq->lcs_mutex);\r\nif (seq->lcs_srv) {\r\nrc = 0;\r\n} else {\r\nif (seq->lcs_exp == NULL) {\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn -EINPROGRESS;\r\n}\r\nrc = seq_client_rpc(seq, &seq->lcs_space,\r\nSEQ_ALLOC_SUPER, "super");\r\n}\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn rc;\r\n}\r\nstatic int seq_client_alloc_meta(const struct lu_env *env,\r\nstruct lu_client_seq *seq)\r\n{\r\nint rc;\r\nif (seq->lcs_srv) {\r\nrc = 0;\r\n} else {\r\ndo {\r\nrc = seq_client_rpc(seq, &seq->lcs_space,\r\nSEQ_ALLOC_META, "meta");\r\n} while (rc == -EINPROGRESS || rc == -EAGAIN);\r\n}\r\nreturn rc;\r\n}\r\nstatic int seq_client_alloc_seq(const struct lu_env *env,\r\nstruct lu_client_seq *seq, seqno_t *seqnr)\r\n{\r\nint rc;\r\nLASSERT(range_is_sane(&seq->lcs_space));\r\nif (range_is_exhausted(&seq->lcs_space)) {\r\nrc = seq_client_alloc_meta(env, seq);\r\nif (rc) {\r\nCERROR("%s: Can't allocate new meta-sequence,"\r\n"rc %d\n", seq->lcs_name, rc);\r\nreturn rc;\r\n} else {\r\nCDEBUG(D_INFO, "%s: New range - "DRANGE"\n",\r\nseq->lcs_name, PRANGE(&seq->lcs_space));\r\n}\r\n} else {\r\nrc = 0;\r\n}\r\nLASSERT(!range_is_exhausted(&seq->lcs_space));\r\n*seqnr = seq->lcs_space.lsr_start;\r\nseq->lcs_space.lsr_start += 1;\r\nCDEBUG(D_INFO, "%s: Allocated sequence ["LPX64"]\n", seq->lcs_name,\r\n*seqnr);\r\nreturn rc;\r\n}\r\nstatic int seq_fid_alloc_prep(struct lu_client_seq *seq,\r\nwait_queue_t *link)\r\n{\r\nif (seq->lcs_update) {\r\nadd_wait_queue(&seq->lcs_waitq, link);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nmutex_unlock(&seq->lcs_mutex);\r\nwaitq_wait(link, TASK_UNINTERRUPTIBLE);\r\nmutex_lock(&seq->lcs_mutex);\r\nremove_wait_queue(&seq->lcs_waitq, link);\r\nset_current_state(TASK_RUNNING);\r\nreturn -EAGAIN;\r\n}\r\n++seq->lcs_update;\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn 0;\r\n}\r\nstatic void seq_fid_alloc_fini(struct lu_client_seq *seq)\r\n{\r\nLASSERT(seq->lcs_update == 1);\r\nmutex_lock(&seq->lcs_mutex);\r\n--seq->lcs_update;\r\nwake_up(&seq->lcs_waitq);\r\n}\r\nint seq_client_get_seq(const struct lu_env *env,\r\nstruct lu_client_seq *seq, seqno_t *seqnr)\r\n{\r\nwait_queue_t link;\r\nint rc;\r\nLASSERT(seqnr != NULL);\r\nmutex_lock(&seq->lcs_mutex);\r\ninit_waitqueue_entry_current(&link);\r\nwhile (1) {\r\nrc = seq_fid_alloc_prep(seq, &link);\r\nif (rc == 0)\r\nbreak;\r\n}\r\nrc = seq_client_alloc_seq(env, seq, seqnr);\r\nif (rc) {\r\nCERROR("%s: Can't allocate new sequence, "\r\n"rc %d\n", seq->lcs_name, rc);\r\nseq_fid_alloc_fini(seq);\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn rc;\r\n}\r\nCDEBUG(D_INFO, "%s: allocate sequence "\r\n"[0x%16.16"LPF64"x]\n", seq->lcs_name, *seqnr);\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nseq->lcs_fid.f_oid = LUSTRE_METADATA_SEQ_MAX_WIDTH;\r\nelse\r\nseq->lcs_fid.f_oid = LUSTRE_DATA_SEQ_MAX_WIDTH;\r\nseq->lcs_fid.f_seq = *seqnr;\r\nseq->lcs_fid.f_ver = 0;\r\nseq_fid_alloc_fini(seq);\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn rc;\r\n}\r\nint seq_client_alloc_fid(const struct lu_env *env,\r\nstruct lu_client_seq *seq, struct lu_fid *fid)\r\n{\r\nwait_queue_t link;\r\nint rc;\r\nLASSERT(seq != NULL);\r\nLASSERT(fid != NULL);\r\ninit_waitqueue_entry_current(&link);\r\nmutex_lock(&seq->lcs_mutex);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_SEQ_EXHAUST))\r\nseq->lcs_fid.f_oid = seq->lcs_width;\r\nwhile (1) {\r\nseqno_t seqnr;\r\nif (!fid_is_zero(&seq->lcs_fid) &&\r\nfid_oid(&seq->lcs_fid) < seq->lcs_width) {\r\nseq->lcs_fid.f_oid += 1;\r\nrc = 0;\r\nbreak;\r\n}\r\nrc = seq_fid_alloc_prep(seq, &link);\r\nif (rc)\r\ncontinue;\r\nrc = seq_client_alloc_seq(env, seq, &seqnr);\r\nif (rc) {\r\nCERROR("%s: Can't allocate new sequence, "\r\n"rc %d\n", seq->lcs_name, rc);\r\nseq_fid_alloc_fini(seq);\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn rc;\r\n}\r\nCDEBUG(D_INFO, "%s: Switch to sequence "\r\n"[0x%16.16"LPF64"x]\n", seq->lcs_name, seqnr);\r\nseq->lcs_fid.f_oid = LUSTRE_FID_INIT_OID;\r\nseq->lcs_fid.f_seq = seqnr;\r\nseq->lcs_fid.f_ver = 0;\r\nrc = 1;\r\nseq_fid_alloc_fini(seq);\r\nbreak;\r\n}\r\n*fid = seq->lcs_fid;\r\nmutex_unlock(&seq->lcs_mutex);\r\nCDEBUG(D_INFO, "%s: Allocated FID "DFID"\n", seq->lcs_name, PFID(fid));\r\nreturn rc;\r\n}\r\nvoid seq_client_flush(struct lu_client_seq *seq)\r\n{\r\nwait_queue_t link;\r\nLASSERT(seq != NULL);\r\ninit_waitqueue_entry_current(&link);\r\nmutex_lock(&seq->lcs_mutex);\r\nwhile (seq->lcs_update) {\r\nadd_wait_queue(&seq->lcs_waitq, &link);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nmutex_unlock(&seq->lcs_mutex);\r\nwaitq_wait(&link, TASK_UNINTERRUPTIBLE);\r\nmutex_lock(&seq->lcs_mutex);\r\nremove_wait_queue(&seq->lcs_waitq, &link);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nfid_zero(&seq->lcs_fid);\r\nseq->lcs_space.lsr_index = -1;\r\nrange_init(&seq->lcs_space);\r\nmutex_unlock(&seq->lcs_mutex);\r\n}\r\nstatic void seq_client_proc_fini(struct lu_client_seq *seq)\r\n{\r\n#ifdef LPROCFS\r\nif (seq->lcs_proc_dir) {\r\nif (!IS_ERR(seq->lcs_proc_dir))\r\nlprocfs_remove(&seq->lcs_proc_dir);\r\nseq->lcs_proc_dir = NULL;\r\n}\r\n#endif\r\n}\r\nstatic int seq_client_proc_init(struct lu_client_seq *seq)\r\n{\r\n#ifdef LPROCFS\r\nint rc;\r\nseq->lcs_proc_dir = lprocfs_register(seq->lcs_name,\r\nseq_type_proc_dir,\r\nNULL, NULL);\r\nif (IS_ERR(seq->lcs_proc_dir)) {\r\nCERROR("%s: LProcFS failed in seq-init\n",\r\nseq->lcs_name);\r\nrc = PTR_ERR(seq->lcs_proc_dir);\r\nreturn rc;\r\n}\r\nrc = lprocfs_add_vars(seq->lcs_proc_dir,\r\nseq_client_proc_list, seq);\r\nif (rc) {\r\nCERROR("%s: Can't init sequence manager "\r\n"proc, rc %d\n", seq->lcs_name, rc);\r\nGOTO(out_cleanup, rc);\r\n}\r\nreturn 0;\r\nout_cleanup:\r\nseq_client_proc_fini(seq);\r\nreturn rc;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint seq_client_init(struct lu_client_seq *seq,\r\nstruct obd_export *exp,\r\nenum lu_cli_type type,\r\nconst char *prefix,\r\nstruct lu_server_seq *srv)\r\n{\r\nint rc;\r\nLASSERT(seq != NULL);\r\nLASSERT(prefix != NULL);\r\nseq->lcs_srv = srv;\r\nseq->lcs_type = type;\r\nmutex_init(&seq->lcs_mutex);\r\nif (type == LUSTRE_SEQ_METADATA)\r\nseq->lcs_width = LUSTRE_METADATA_SEQ_MAX_WIDTH;\r\nelse\r\nseq->lcs_width = LUSTRE_DATA_SEQ_MAX_WIDTH;\r\ninit_waitqueue_head(&seq->lcs_waitq);\r\nseq_client_flush(seq);\r\nif (exp != NULL)\r\nseq->lcs_exp = class_export_get(exp);\r\nelse if (type == LUSTRE_SEQ_METADATA)\r\nLASSERT(seq->lcs_srv != NULL);\r\nsnprintf(seq->lcs_name, sizeof(seq->lcs_name),\r\n"cli-%s", prefix);\r\nrc = seq_client_proc_init(seq);\r\nif (rc)\r\nseq_client_fini(seq);\r\nreturn rc;\r\n}\r\nvoid seq_client_fini(struct lu_client_seq *seq)\r\n{\r\nseq_client_proc_fini(seq);\r\nif (seq->lcs_exp != NULL) {\r\nclass_export_put(seq->lcs_exp);\r\nseq->lcs_exp = NULL;\r\n}\r\nseq->lcs_srv = NULL;\r\n}\r\nint client_fid_init(struct obd_device *obd,\r\nstruct obd_export *exp, enum lu_cli_type type)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nchar *prefix;\r\nint rc;\r\nOBD_ALLOC_PTR(cli->cl_seq);\r\nif (cli->cl_seq == NULL)\r\nreturn -ENOMEM;\r\nOBD_ALLOC(prefix, MAX_OBD_NAME + 5);\r\nif (prefix == NULL)\r\nGOTO(out_free_seq, rc = -ENOMEM);\r\nsnprintf(prefix, MAX_OBD_NAME + 5, "cli-%s", obd->obd_name);\r\nrc = seq_client_init(cli->cl_seq, exp, type, prefix, NULL);\r\nOBD_FREE(prefix, MAX_OBD_NAME + 5);\r\nif (rc)\r\nGOTO(out_free_seq, rc);\r\nreturn rc;\r\nout_free_seq:\r\nOBD_FREE_PTR(cli->cl_seq);\r\ncli->cl_seq = NULL;\r\nreturn rc;\r\n}\r\nint client_fid_fini(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_seq != NULL) {\r\nseq_client_fini(cli->cl_seq);\r\nOBD_FREE_PTR(cli->cl_seq);\r\ncli->cl_seq = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fid_mod_init(void)\r\n{\r\nseq_type_proc_dir = lprocfs_register(LUSTRE_SEQ_NAME,\r\nproc_lustre_root,\r\nNULL, NULL);\r\nreturn PTR_ERR_OR_ZERO(seq_type_proc_dir);\r\n}\r\nstatic void __exit fid_mod_exit(void)\r\n{\r\nif (seq_type_proc_dir != NULL && !IS_ERR(seq_type_proc_dir)) {\r\nlprocfs_remove(&seq_type_proc_dir);\r\nseq_type_proc_dir = NULL;\r\n}\r\n}
