static int gpio_backlight_update_status(struct backlight_device *bl)\r\n{\r\nstruct gpio_backlight *gbl = bl_get_data(bl);\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.fb_blank != FB_BLANK_UNBLANK ||\r\nbl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\ngpio_set_value(gbl->gpio, brightness ? gbl->active : !gbl->active);\r\nreturn 0;\r\n}\r\nstatic int gpio_backlight_get_brightness(struct backlight_device *bl)\r\n{\r\nreturn bl->props.brightness;\r\n}\r\nstatic int gpio_backlight_check_fb(struct backlight_device *bl,\r\nstruct fb_info *info)\r\n{\r\nstruct gpio_backlight *gbl = bl_get_data(bl);\r\nreturn gbl->fbdev == NULL || gbl->fbdev == info->dev;\r\n}\r\nstatic int gpio_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_backlight_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nstruct gpio_backlight *gbl;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "failed to find platform data\n");\r\nreturn -ENODEV;\r\n}\r\ngbl = devm_kzalloc(&pdev->dev, sizeof(*gbl), GFP_KERNEL);\r\nif (gbl == NULL)\r\nreturn -ENOMEM;\r\ngbl->dev = &pdev->dev;\r\ngbl->fbdev = pdata->fbdev;\r\ngbl->gpio = pdata->gpio;\r\ngbl->active = pdata->active_low ? 0 : 1;\r\nret = devm_gpio_request_one(gbl->dev, gbl->gpio, GPIOF_DIR_OUT |\r\n(gbl->active ? GPIOF_INIT_LOW\r\n: GPIOF_INIT_HIGH),\r\npdata->name);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to request GPIO\n");\r\nreturn ret;\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 1;\r\nbl = devm_backlight_device_register(&pdev->dev, dev_name(&pdev->dev),\r\n&pdev->dev, gbl, &gpio_backlight_ops,\r\n&props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\nbl->props.brightness = pdata->def_value;\r\nbacklight_update_status(bl);\r\nplatform_set_drvdata(pdev, bl);\r\nreturn 0;\r\n}
