static inline struct samsung_pin_bank *gc_to_pin_bank(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct samsung_pin_bank, gpio_chip);\r\n}\r\nstatic int samsung_get_group_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->nr_groups;\r\n}\r\nstatic const char *samsung_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->pin_groups[selector].name;\r\n}\r\nstatic int samsung_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector, const unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = drvdata->pin_groups[selector].pins;\r\n*num_pins = drvdata->pin_groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic int samsung_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np, struct pinctrl_map **maps,\r\nunsigned *nmaps)\r\n{\r\nstruct device *dev = pctldev->dev;\r\nstruct pinctrl_map *map;\r\nunsigned long *cfg = NULL;\r\nchar *gname, *fname;\r\nint cfg_cnt = 0, map_cnt = 0, idx = 0;\r\nfor (idx = 0; idx < ARRAY_SIZE(pcfgs); idx++) {\r\nif (of_find_property(np, pcfgs[idx].prop_cfg, NULL))\r\ncfg_cnt++;\r\n}\r\nif (cfg_cnt)\r\nmap_cnt = 1;\r\nif (of_find_property(np, "samsung,pin-function", NULL))\r\nmap_cnt++;\r\nif (!map_cnt) {\r\ndev_err(dev, "node %s does not have either config or function "\r\n"configurations\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nmap = kzalloc(sizeof(*map) * map_cnt, GFP_KERNEL);\r\nif (!map) {\r\ndev_err(dev, "could not alloc memory for pin-maps\n");\r\nreturn -ENOMEM;\r\n}\r\n*nmaps = 0;\r\ngname = kzalloc(strlen(np->name) + GSUFFIX_LEN, GFP_KERNEL);\r\nif (!gname) {\r\ndev_err(dev, "failed to alloc memory for group name\n");\r\ngoto free_map;\r\n}\r\nsprintf(gname, "%s%s", np->name, GROUP_SUFFIX);\r\nif (!cfg_cnt)\r\ngoto skip_cfgs;\r\ncfg = kzalloc(sizeof(*cfg) * cfg_cnt, GFP_KERNEL);\r\nif (!cfg) {\r\ndev_err(dev, "failed to alloc memory for configs\n");\r\ngoto free_gname;\r\n}\r\nfor (idx = 0, cfg_cnt = 0; idx < ARRAY_SIZE(pcfgs); idx++) {\r\nu32 value;\r\nif (!of_property_read_u32(np, pcfgs[idx].prop_cfg, &value))\r\ncfg[cfg_cnt++] =\r\nPINCFG_PACK(pcfgs[idx].cfg_type, value);\r\n}\r\nmap[*nmaps].data.configs.group_or_pin = gname;\r\nmap[*nmaps].data.configs.configs = cfg;\r\nmap[*nmaps].data.configs.num_configs = cfg_cnt;\r\nmap[*nmaps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n*nmaps += 1;\r\nskip_cfgs:\r\nif (of_find_property(np, "samsung,pin-function", NULL)) {\r\nfname = kzalloc(strlen(np->name) + FSUFFIX_LEN, GFP_KERNEL);\r\nif (!fname) {\r\ndev_err(dev, "failed to alloc memory for func name\n");\r\ngoto free_cfg;\r\n}\r\nsprintf(fname, "%s%s", np->name, FUNCTION_SUFFIX);\r\nmap[*nmaps].data.mux.group = gname;\r\nmap[*nmaps].data.mux.function = fname;\r\nmap[*nmaps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n*nmaps += 1;\r\n}\r\n*maps = map;\r\nreturn 0;\r\nfree_cfg:\r\nkfree(cfg);\r\nfree_gname:\r\nkfree(gname);\r\nfree_map:\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nstatic void samsung_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < num_maps; idx++) {\r\nif (map[idx].type == PIN_MAP_TYPE_MUX_GROUP) {\r\nkfree(map[idx].data.mux.function);\r\nif (!idx)\r\nkfree(map[idx].data.mux.group);\r\n} else if (map->type == PIN_MAP_TYPE_CONFIGS_GROUP) {\r\nkfree(map[idx].data.configs.configs);\r\nif (!idx)\r\nkfree(map[idx].data.configs.group_or_pin);\r\n}\r\n};\r\nkfree(map);\r\n}\r\nstatic int samsung_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->nr_functions;\r\n}\r\nstatic const char *samsung_pinmux_get_fname(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->pmx_functions[selector].name;\r\n}\r\nstatic int samsung_pinmux_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = drvdata->pmx_functions[selector].groups;\r\n*num_groups = drvdata->pmx_functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic void pin_to_reg_bank(struct samsung_pinctrl_drv_data *drvdata,\r\nunsigned pin, void __iomem **reg, u32 *offset,\r\nstruct samsung_pin_bank **bank)\r\n{\r\nstruct samsung_pin_bank *b;\r\nb = drvdata->ctrl->pin_banks;\r\nwhile ((pin >= b->pin_base) &&\r\n((b->pin_base + b->nr_pins - 1) < pin))\r\nb++;\r\n*reg = drvdata->virt_base + b->pctl_offset;\r\n*offset = pin - b->pin_base;\r\nif (bank)\r\n*bank = b;\r\n}\r\nstatic void samsung_pinmux_setup(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group, bool enable)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst unsigned int *pins;\r\nstruct samsung_pin_bank *bank;\r\nvoid __iomem *reg;\r\nu32 mask, shift, data, pin_offset, cnt;\r\nunsigned long flags;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npins = drvdata->pin_groups[group].pins;\r\nfor (cnt = 0; cnt < drvdata->pin_groups[group].num_pins; cnt++) {\r\nstruct samsung_pin_bank_type *type;\r\npin_to_reg_bank(drvdata, pins[cnt] - drvdata->ctrl->base,\r\n&reg, &pin_offset, &bank);\r\ntype = bank->type;\r\nmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nshift = pin_offset * type->fld_width[PINCFG_TYPE_FUNC];\r\nif (shift >= 32) {\r\nshift -= 32;\r\nreg += 4;\r\n}\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_FUNC]);\r\ndata &= ~(mask << shift);\r\nif (enable)\r\ndata |= drvdata->pin_groups[group].func << shift;\r\nwritel(data, reg + type->reg_offset[PINCFG_TYPE_FUNC]);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\n}\r\nstatic int samsung_pinmux_enable(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nsamsung_pinmux_setup(pctldev, selector, group, true);\r\nreturn 0;\r\n}\r\nstatic void samsung_pinmux_disable(struct pinctrl_dev *pctldev,\r\nunsigned selector, unsigned group)\r\n{\r\nsamsung_pinmux_setup(pctldev, selector, group, false);\r\n}\r\nstatic int samsung_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool input)\r\n{\r\nstruct samsung_pin_bank_type *type;\r\nstruct samsung_pin_bank *bank;\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nvoid __iomem *reg;\r\nu32 data, pin_offset, mask, shift;\r\nunsigned long flags;\r\nbank = gc_to_pin_bank(range->gc);\r\ntype = bank->type;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npin_offset = offset - bank->pin_base;\r\nreg = drvdata->virt_base + bank->pctl_offset +\r\ntype->reg_offset[PINCFG_TYPE_FUNC];\r\nmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nshift = pin_offset * type->fld_width[PINCFG_TYPE_FUNC];\r\nif (shift >= 32) {\r\nshift -= 32;\r\nreg += 4;\r\n}\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg);\r\ndata &= ~(mask << shift);\r\nif (!input)\r\ndata |= FUNC_OUTPUT << shift;\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_rw(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config, bool set)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nstruct samsung_pin_bank_type *type;\r\nstruct samsung_pin_bank *bank;\r\nvoid __iomem *reg_base;\r\nenum pincfg_type cfg_type = PINCFG_UNPACK_TYPE(*config);\r\nu32 data, width, pin_offset, mask, shift;\r\nu32 cfg_value, cfg_reg;\r\nunsigned long flags;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npin_to_reg_bank(drvdata, pin - drvdata->ctrl->base, &reg_base,\r\n&pin_offset, &bank);\r\ntype = bank->type;\r\nif (cfg_type >= PINCFG_TYPE_NUM || !type->fld_width[cfg_type])\r\nreturn -EINVAL;\r\nwidth = type->fld_width[cfg_type];\r\ncfg_reg = type->reg_offset[cfg_type];\r\nspin_lock_irqsave(&bank->slock, flags);\r\nmask = (1 << width) - 1;\r\nshift = pin_offset * width;\r\ndata = readl(reg_base + cfg_reg);\r\nif (set) {\r\ncfg_value = PINCFG_UNPACK_VALUE(*config);\r\ndata &= ~(mask << shift);\r\ndata |= (cfg_value << shift);\r\nwritel(data, reg_base + cfg_reg);\r\n} else {\r\ndata >>= shift;\r\ndata &= mask;\r\n*config = PINCFG_PACK(cfg_type, data);\r\n}\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nret = samsung_pinconf_rw(pctldev, pin, &configs[i], true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nreturn samsung_pinconf_rw(pctldev, pin, config, false);\r\n}\r\nstatic int samsung_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst unsigned int *pins;\r\nunsigned int cnt;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npins = drvdata->pin_groups[group].pins;\r\nfor (cnt = 0; cnt < drvdata->pin_groups[group].num_pins; cnt++)\r\nsamsung_pinconf_set(pctldev, pins[cnt], configs, num_configs);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *config)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst unsigned int *pins;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npins = drvdata->pin_groups[group].pins;\r\nsamsung_pinconf_get(pctldev, pins[0], config);\r\nreturn 0;\r\n}\r\nstatic void samsung_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nstruct samsung_pin_bank_type *type = bank->type;\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 data;\r\nreg = bank->drvdata->virt_base + bank->pctl_offset;\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\ndata &= ~(1 << offset);\r\nif (value)\r\ndata |= 1 << offset;\r\nwritel(data, reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic int samsung_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nvoid __iomem *reg;\r\nu32 data;\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nstruct samsung_pin_bank_type *type = bank->type;\r\nreg = bank->drvdata->virt_base + bank->pctl_offset;\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\ndata >>= offset;\r\ndata &= 1;\r\nreturn data;\r\n}\r\nstatic int samsung_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(gc->base + offset);\r\n}\r\nstatic int samsung_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nsamsung_gpio_set(gc, offset, value);\r\nreturn pinctrl_gpio_direction_output(gc->base + offset);\r\n}\r\nstatic int samsung_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nunsigned int virq;\r\nif (!bank->irq_domain)\r\nreturn -ENXIO;\r\nvirq = irq_create_mapping(bank->irq_domain, offset);\r\nreturn (virq) ? : -ENXIO;\r\n}\r\nstatic int samsung_pinctrl_parse_dt_pins(struct platform_device *pdev,\r\nstruct device_node *cfg_np,\r\nstruct pinctrl_desc *pctl,\r\nunsigned int **pin_list,\r\nunsigned int *npins)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct property *prop;\r\nstruct pinctrl_pin_desc const *pdesc = pctl->pins;\r\nunsigned int idx = 0, cnt;\r\nconst char *pin_name;\r\n*npins = of_property_count_strings(cfg_np, "samsung,pins");\r\nif (IS_ERR_VALUE(*npins)) {\r\ndev_err(dev, "invalid pin list in %s node", cfg_np->name);\r\nreturn -EINVAL;\r\n}\r\n*pin_list = devm_kzalloc(dev, *npins * sizeof(**pin_list), GFP_KERNEL);\r\nif (!*pin_list) {\r\ndev_err(dev, "failed to allocate memory for pin list\n");\r\nreturn -ENOMEM;\r\n}\r\nof_property_for_each_string(cfg_np, "samsung,pins", prop, pin_name) {\r\nfor (cnt = 0; cnt < pctl->npins; cnt++) {\r\nif (pdesc[cnt].name) {\r\nif (!strcmp(pin_name, pdesc[cnt].name)) {\r\n(*pin_list)[idx++] = pdesc[cnt].number;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (cnt == pctl->npins) {\r\ndev_err(dev, "pin %s not valid in %s node\n",\r\npin_name, cfg_np->name);\r\ndevm_kfree(dev, *pin_list);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_pinctrl_parse_dt(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dev_np = dev->of_node;\r\nstruct device_node *cfg_np;\r\nstruct samsung_pin_group *groups, *grp;\r\nstruct samsung_pmx_func *functions, *func;\r\nunsigned *pin_list;\r\nunsigned int npins, grp_cnt, func_idx = 0;\r\nchar *gname, *fname;\r\nint ret;\r\ngrp_cnt = of_get_child_count(dev_np);\r\nif (!grp_cnt)\r\nreturn -EINVAL;\r\ngroups = devm_kzalloc(dev, grp_cnt * sizeof(*groups), GFP_KERNEL);\r\nif (!groups) {\r\ndev_err(dev, "failed allocate memory for ping group list\n");\r\nreturn -EINVAL;\r\n}\r\ngrp = groups;\r\nfunctions = devm_kzalloc(dev, grp_cnt * sizeof(*functions), GFP_KERNEL);\r\nif (!functions) {\r\ndev_err(dev, "failed to allocate memory for function list\n");\r\nreturn -EINVAL;\r\n}\r\nfunc = functions;\r\nfor_each_child_of_node(dev_np, cfg_np) {\r\nu32 function;\r\nif (!of_find_property(cfg_np, "samsung,pins", NULL))\r\ncontinue;\r\nret = samsung_pinctrl_parse_dt_pins(pdev, cfg_np,\r\n&drvdata->pctl, &pin_list, &npins);\r\nif (ret)\r\nreturn ret;\r\ngname = devm_kzalloc(dev, strlen(cfg_np->name) + GSUFFIX_LEN,\r\nGFP_KERNEL);\r\nif (!gname) {\r\ndev_err(dev, "failed to alloc memory for group name\n");\r\nreturn -ENOMEM;\r\n}\r\nsprintf(gname, "%s%s", cfg_np->name, GROUP_SUFFIX);\r\ngrp->name = gname;\r\ngrp->pins = pin_list;\r\ngrp->num_pins = npins;\r\nof_property_read_u32(cfg_np, "samsung,pin-function", &function);\r\ngrp->func = function;\r\ngrp++;\r\nif (!of_find_property(cfg_np, "samsung,pin-function", NULL))\r\ncontinue;\r\nfname = devm_kzalloc(dev, strlen(cfg_np->name) + FSUFFIX_LEN,\r\nGFP_KERNEL);\r\nif (!fname) {\r\ndev_err(dev, "failed to alloc memory for func name\n");\r\nreturn -ENOMEM;\r\n}\r\nsprintf(fname, "%s%s", cfg_np->name, FUNCTION_SUFFIX);\r\nfunc->name = fname;\r\nfunc->groups = devm_kzalloc(dev, sizeof(char *), GFP_KERNEL);\r\nif (!func->groups) {\r\ndev_err(dev, "failed to alloc memory for group list "\r\n"in pin function");\r\nreturn -ENOMEM;\r\n}\r\nfunc->groups[0] = gname;\r\nfunc->num_groups = 1;\r\nfunc++;\r\nfunc_idx++;\r\n}\r\ndrvdata->pin_groups = groups;\r\ndrvdata->nr_groups = grp_cnt;\r\ndrvdata->pmx_functions = functions;\r\ndrvdata->nr_functions = func_idx;\r\nreturn 0;\r\n}\r\nstatic int samsung_pinctrl_register(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct pinctrl_desc *ctrldesc = &drvdata->pctl;\r\nstruct pinctrl_pin_desc *pindesc, *pdesc;\r\nstruct samsung_pin_bank *pin_bank;\r\nchar *pin_names;\r\nint pin, bank, ret;\r\nctrldesc->name = "samsung-pinctrl";\r\nctrldesc->owner = THIS_MODULE;\r\nctrldesc->pctlops = &samsung_pctrl_ops;\r\nctrldesc->pmxops = &samsung_pinmux_ops;\r\nctrldesc->confops = &samsung_pinconf_ops;\r\npindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *\r\ndrvdata->ctrl->nr_pins, GFP_KERNEL);\r\nif (!pindesc) {\r\ndev_err(&pdev->dev, "mem alloc for pin descriptors failed\n");\r\nreturn -ENOMEM;\r\n}\r\nctrldesc->pins = pindesc;\r\nctrldesc->npins = drvdata->ctrl->nr_pins;\r\nfor (pin = 0, pdesc = pindesc; pin < ctrldesc->npins; pin++, pdesc++)\r\npdesc->number = pin + drvdata->ctrl->base;\r\npin_names = devm_kzalloc(&pdev->dev, sizeof(char) * PIN_NAME_LENGTH *\r\ndrvdata->ctrl->nr_pins, GFP_KERNEL);\r\nif (!pin_names) {\r\ndev_err(&pdev->dev, "mem alloc for pin names failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (bank = 0; bank < drvdata->ctrl->nr_banks; bank++) {\r\npin_bank = &drvdata->ctrl->pin_banks[bank];\r\nfor (pin = 0; pin < pin_bank->nr_pins; pin++) {\r\nsprintf(pin_names, "%s-%d", pin_bank->name, pin);\r\npdesc = pindesc + pin_bank->pin_base + pin;\r\npdesc->name = pin_names;\r\npin_names += PIN_NAME_LENGTH;\r\n}\r\n}\r\nret = samsung_pinctrl_parse_dt(pdev, drvdata);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->pctl_dev = pinctrl_register(ctrldesc, &pdev->dev, drvdata);\r\nif (!drvdata->pctl_dev) {\r\ndev_err(&pdev->dev, "could not register pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\nfor (bank = 0; bank < drvdata->ctrl->nr_banks; ++bank) {\r\npin_bank = &drvdata->ctrl->pin_banks[bank];\r\npin_bank->grange.name = pin_bank->name;\r\npin_bank->grange.id = bank;\r\npin_bank->grange.pin_base = pin_bank->pin_base;\r\npin_bank->grange.base = pin_bank->gpio_chip.base;\r\npin_bank->grange.npins = pin_bank->gpio_chip.ngpio;\r\npin_bank->grange.gc = &pin_bank->gpio_chip;\r\npinctrl_add_gpio_range(drvdata->pctl_dev, &pin_bank->grange);\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_gpiolib_register(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_ctrl *ctrl = drvdata->ctrl;\r\nstruct samsung_pin_bank *bank = ctrl->pin_banks;\r\nstruct gpio_chip *gc;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nbank->gpio_chip = samsung_gpiolib_chip;\r\ngc = &bank->gpio_chip;\r\ngc->base = ctrl->base + bank->pin_base;\r\ngc->ngpio = bank->nr_pins;\r\ngc->dev = &pdev->dev;\r\ngc->of_node = bank->of_node;\r\ngc->label = bank->name;\r\nret = gpiochip_add(gc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register gpio_chip %s, error code: %d\n",\r\ngc->label, ret);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nfor (--i, --bank; i >= 0; --i, --bank)\r\nif (gpiochip_remove(&bank->gpio_chip))\r\ndev_err(&pdev->dev, "gpio chip %s remove failed\n",\r\nbank->gpio_chip.label);\r\nreturn ret;\r\n}\r\nstatic int samsung_gpiolib_unregister(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_ctrl *ctrl = drvdata->ctrl;\r\nstruct samsung_pin_bank *bank = ctrl->pin_banks;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; !ret && i < ctrl->nr_banks; ++i, ++bank)\r\nret = gpiochip_remove(&bank->gpio_chip);\r\nif (ret)\r\ndev_err(&pdev->dev, "gpio chip remove failed\n");\r\nreturn ret;\r\n}\r\nstatic struct samsung_pin_ctrl *samsung_pinctrl_get_soc_data(\r\nstruct samsung_pinctrl_drv_data *d,\r\nstruct platform_device *pdev)\r\n{\r\nint id;\r\nconst struct of_device_id *match;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *np;\r\nstruct samsung_pin_ctrl *ctrl;\r\nstruct samsung_pin_bank *bank;\r\nint i;\r\nid = of_alias_get_id(node, "pinctrl");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id\n");\r\nreturn NULL;\r\n}\r\nmatch = of_match_node(samsung_pinctrl_dt_match, node);\r\nctrl = (struct samsung_pin_ctrl *)match->data + id;\r\nbank = ctrl->pin_banks;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nspin_lock_init(&bank->slock);\r\nbank->drvdata = d;\r\nbank->pin_base = ctrl->nr_pins;\r\nctrl->nr_pins += bank->nr_pins;\r\n}\r\nfor_each_child_of_node(node, np) {\r\nif (!of_find_property(np, "gpio-controller", NULL))\r\ncontinue;\r\nbank = ctrl->pin_banks;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\r\nif (!strcmp(bank->name, np->name)) {\r\nbank->of_node = np;\r\nbreak;\r\n}\r\n}\r\n}\r\nctrl->base = pin_base;\r\npin_base += ctrl->nr_pins;\r\nreturn ctrl;\r\n}\r\nstatic int samsung_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct samsung_pin_ctrl *ctrl;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device tree node not found\n");\r\nreturn -ENODEV;\r\n}\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata) {\r\ndev_err(dev, "failed to allocate memory for driver's "\r\n"private data\n");\r\nreturn -ENOMEM;\r\n}\r\nctrl = samsung_pinctrl_get_soc_data(drvdata, pdev);\r\nif (!ctrl) {\r\ndev_err(&pdev->dev, "driver data not available\n");\r\nreturn -EINVAL;\r\n}\r\ndrvdata->ctrl = ctrl;\r\ndrvdata->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrvdata->virt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(drvdata->virt_base))\r\nreturn PTR_ERR(drvdata->virt_base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res)\r\ndrvdata->irq = res->start;\r\nret = samsung_gpiolib_register(pdev, drvdata);\r\nif (ret)\r\nreturn ret;\r\nret = samsung_pinctrl_register(pdev, drvdata);\r\nif (ret) {\r\nsamsung_gpiolib_unregister(pdev, drvdata);\r\nreturn ret;\r\n}\r\nif (ctrl->eint_gpio_init)\r\nctrl->eint_gpio_init(drvdata);\r\nif (ctrl->eint_wkup_init)\r\nctrl->eint_wkup_init(drvdata);\r\nplatform_set_drvdata(pdev, drvdata);\r\nlist_add_tail(&drvdata->node, &drvdata_list);\r\nreturn 0;\r\n}\r\nstatic void samsung_pinctrl_suspend_dev(\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_ctrl *ctrl = drvdata->ctrl;\r\nvoid __iomem *virt_base = drvdata->virt_base;\r\nint i;\r\nfor (i = 0; i < ctrl->nr_banks; i++) {\r\nstruct samsung_pin_bank *bank = &ctrl->pin_banks[i];\r\nvoid __iomem *reg = virt_base + bank->pctl_offset;\r\nu8 *offs = bank->type->reg_offset;\r\nu8 *widths = bank->type->fld_width;\r\nenum pincfg_type type;\r\nif (!widths[PINCFG_TYPE_CON_PDN])\r\ncontinue;\r\nfor (type = 0; type < PINCFG_TYPE_NUM; type++)\r\nif (widths[type])\r\nbank->pm_save[type] = readl(reg + offs[type]);\r\nif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\r\nbank->pm_save[PINCFG_TYPE_NUM] =\r\nreadl(reg + offs[PINCFG_TYPE_FUNC] + 4);\r\npr_debug("Save %s @ %p (con %#010x %08x)\n",\r\nbank->name, reg,\r\nbank->pm_save[PINCFG_TYPE_FUNC],\r\nbank->pm_save[PINCFG_TYPE_NUM]);\r\n} else {\r\npr_debug("Save %s @ %p (con %#010x)\n", bank->name,\r\nreg, bank->pm_save[PINCFG_TYPE_FUNC]);\r\n}\r\n}\r\nif (ctrl->suspend)\r\nctrl->suspend(drvdata);\r\n}\r\nstatic void samsung_pinctrl_resume_dev(struct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_ctrl *ctrl = drvdata->ctrl;\r\nvoid __iomem *virt_base = drvdata->virt_base;\r\nint i;\r\nif (ctrl->resume)\r\nctrl->resume(drvdata);\r\nfor (i = 0; i < ctrl->nr_banks; i++) {\r\nstruct samsung_pin_bank *bank = &ctrl->pin_banks[i];\r\nvoid __iomem *reg = virt_base + bank->pctl_offset;\r\nu8 *offs = bank->type->reg_offset;\r\nu8 *widths = bank->type->fld_width;\r\nenum pincfg_type type;\r\nif (!widths[PINCFG_TYPE_CON_PDN])\r\ncontinue;\r\nif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\r\npr_debug("%s @ %p (con %#010x %08x => %#010x %08x)\n",\r\nbank->name, reg,\r\nreadl(reg + offs[PINCFG_TYPE_FUNC]),\r\nreadl(reg + offs[PINCFG_TYPE_FUNC] + 4),\r\nbank->pm_save[PINCFG_TYPE_FUNC],\r\nbank->pm_save[PINCFG_TYPE_NUM]);\r\nwritel(bank->pm_save[PINCFG_TYPE_NUM],\r\nreg + offs[PINCFG_TYPE_FUNC] + 4);\r\n} else {\r\npr_debug("%s @ %p (con %#010x => %#010x)\n", bank->name,\r\nreg, readl(reg + offs[PINCFG_TYPE_FUNC]),\r\nbank->pm_save[PINCFG_TYPE_FUNC]);\r\n}\r\nfor (type = 0; type < PINCFG_TYPE_NUM; type++)\r\nif (widths[type])\r\nwritel(bank->pm_save[type], reg + offs[type]);\r\n}\r\n}\r\nstatic int samsung_pinctrl_suspend(void)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nlist_for_each_entry(drvdata, &drvdata_list, node) {\r\nsamsung_pinctrl_suspend_dev(drvdata);\r\n}\r\nreturn 0;\r\n}\r\nstatic void samsung_pinctrl_resume(void)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nlist_for_each_entry_reverse(drvdata, &drvdata_list, node) {\r\nsamsung_pinctrl_resume_dev(drvdata);\r\n}\r\n}\r\nstatic int __init samsung_pinctrl_drv_register(void)\r\n{\r\nregister_syscore_ops(&samsung_pinctrl_syscore_ops);\r\nreturn platform_driver_register(&samsung_pinctrl_driver);\r\n}\r\nstatic void __exit samsung_pinctrl_drv_unregister(void)\r\n{\r\nplatform_driver_unregister(&samsung_pinctrl_driver);\r\n}
