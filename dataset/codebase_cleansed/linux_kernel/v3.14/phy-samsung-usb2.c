static int samsung_usbphy_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\nif (!otg->host)\r\notg->host = host;\r\nreturn 0;\r\n}\r\nstatic bool exynos5_phyhost_is_on(void __iomem *regs)\r\n{\r\nu32 reg;\r\nreg = readl(regs + EXYNOS5_PHY_HOST_CTRL0);\r\nreturn !(reg & HOST_CTRL0_SIDDQ);\r\n}\r\nstatic void samsung_exynos5_usb2phy_enable(struct samsung_usbphy *sphy)\r\n{\r\nvoid __iomem *regs = sphy->regs;\r\nu32 phyclk = sphy->ref_clk_freq;\r\nu32 phyhost;\r\nu32 phyotg;\r\nu32 phyhsic;\r\nu32 ehcictrl;\r\nu32 ohcictrl;\r\natomic_inc(&sphy->phy_usage);\r\nif (exynos5_phyhost_is_on(regs)) {\r\ndev_info(sphy->dev, "Already power on PHY\n");\r\nreturn;\r\n}\r\nphyhost = readl(regs + EXYNOS5_PHY_HOST_CTRL0);\r\nphyhost &= ~HOST_CTRL0_FSEL_MASK;\r\nphyhost |= HOST_CTRL0_FSEL(phyclk);\r\nphyhost &= ~(HOST_CTRL0_PHYSWRST |\r\nHOST_CTRL0_PHYSWRSTALL |\r\nHOST_CTRL0_SIDDQ |\r\nHOST_CTRL0_FORCESUSPEND |\r\nHOST_CTRL0_FORCESLEEP);\r\nphyhost |= (HOST_CTRL0_LINKSWRST |\r\nHOST_CTRL0_UTMISWRST |\r\nHOST_CTRL0_COMMONON_N);\r\nwritel(phyhost, regs + EXYNOS5_PHY_HOST_CTRL0);\r\nudelay(10);\r\nphyhost &= ~(HOST_CTRL0_LINKSWRST |\r\nHOST_CTRL0_UTMISWRST);\r\nwritel(phyhost, regs + EXYNOS5_PHY_HOST_CTRL0);\r\nphyotg = readl(regs + EXYNOS5_PHY_OTG_SYS);\r\nphyotg &= ~OTG_SYS_FSEL_MASK;\r\nphyotg |= OTG_SYS_FSEL(phyclk);\r\nphyotg &= ~(OTG_SYS_FORCESUSPEND |\r\nOTG_SYS_SIDDQ_UOTG |\r\nOTG_SYS_FORCESLEEP |\r\nOTG_SYS_REFCLKSEL_MASK |\r\nOTG_SYS_COMMON_ON);\r\nphyotg |= (OTG_SYS_PHY0_SWRST |\r\nOTG_SYS_LINKSWRST_UOTG |\r\nOTG_SYS_PHYLINK_SWRESET |\r\nOTG_SYS_OTGDISABLE |\r\nOTG_SYS_REFCLKSEL_CLKCORE);\r\nwritel(phyotg, regs + EXYNOS5_PHY_OTG_SYS);\r\nudelay(10);\r\nphyotg &= ~(OTG_SYS_PHY0_SWRST |\r\nOTG_SYS_LINKSWRST_UOTG |\r\nOTG_SYS_PHYLINK_SWRESET);\r\nwritel(phyotg, regs + EXYNOS5_PHY_OTG_SYS);\r\nphyhsic = (HSIC_CTRL_REFCLKDIV_12 |\r\nHSIC_CTRL_REFCLKSEL |\r\nHSIC_CTRL_PHYSWRST);\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL1);\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL2);\r\nudelay(10);\r\nphyhsic &= ~HSIC_CTRL_PHYSWRST;\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL1);\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL2);\r\nudelay(80);\r\nehcictrl = readl(regs + EXYNOS5_PHY_HOST_EHCICTRL);\r\nehcictrl |= (HOST_EHCICTRL_ENAINCRXALIGN |\r\nHOST_EHCICTRL_ENAINCR4 |\r\nHOST_EHCICTRL_ENAINCR8 |\r\nHOST_EHCICTRL_ENAINCR16);\r\nwritel(ehcictrl, regs + EXYNOS5_PHY_HOST_EHCICTRL);\r\nohcictrl = readl(regs + EXYNOS5_PHY_HOST_OHCICTRL);\r\nohcictrl |= HOST_OHCICTRL_SUSPLGCY;\r\nwritel(ohcictrl, regs + EXYNOS5_PHY_HOST_OHCICTRL);\r\n}\r\nstatic void samsung_usb2phy_enable(struct samsung_usbphy *sphy)\r\n{\r\nvoid __iomem *regs = sphy->regs;\r\nu32 phypwr;\r\nu32 phyclk;\r\nu32 rstcon;\r\nphyclk = sphy->ref_clk_freq;\r\nphypwr = readl(regs + SAMSUNG_PHYPWR);\r\nrstcon = readl(regs + SAMSUNG_RSTCON);\r\nswitch (sphy->drv_data->cpu_type) {\r\ncase TYPE_S3C64XX:\r\nphyclk &= ~PHYCLK_COMMON_ON_N;\r\nphypwr &= ~PHYPWR_NORMAL_MASK;\r\nrstcon |= RSTCON_SWRST;\r\nbreak;\r\ncase TYPE_EXYNOS4X12:\r\nphypwr &= ~(PHYPWR_NORMAL_MASK_HSIC0 |\r\nPHYPWR_NORMAL_MASK_HSIC1 |\r\nPHYPWR_NORMAL_MASK_PHY1);\r\nrstcon |= RSTCON_HOSTPHY_SWRST;\r\ncase TYPE_EXYNOS4210:\r\nphypwr &= ~PHYPWR_NORMAL_MASK_PHY0;\r\nrstcon |= RSTCON_SWRST;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(phyclk, regs + SAMSUNG_PHYCLK);\r\nwritel(phypwr, regs + SAMSUNG_PHYPWR);\r\nwritel(rstcon, regs + SAMSUNG_RSTCON);\r\nudelay(10);\r\nif (sphy->drv_data->cpu_type == TYPE_EXYNOS4X12)\r\nrstcon &= ~RSTCON_HOSTPHY_SWRST;\r\nrstcon &= ~RSTCON_SWRST;\r\nwritel(rstcon, regs + SAMSUNG_RSTCON);\r\n}\r\nstatic void samsung_exynos5_usb2phy_disable(struct samsung_usbphy *sphy)\r\n{\r\nvoid __iomem *regs = sphy->regs;\r\nu32 phyhost;\r\nu32 phyotg;\r\nu32 phyhsic;\r\nif (atomic_dec_return(&sphy->phy_usage) > 0) {\r\ndev_info(sphy->dev, "still being used\n");\r\nreturn;\r\n}\r\nphyhsic = (HSIC_CTRL_REFCLKDIV_12 |\r\nHSIC_CTRL_REFCLKSEL |\r\nHSIC_CTRL_SIDDQ |\r\nHSIC_CTRL_FORCESLEEP |\r\nHSIC_CTRL_FORCESUSPEND);\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL1);\r\nwritel(phyhsic, regs + EXYNOS5_PHY_HSIC_CTRL2);\r\nphyhost = readl(regs + EXYNOS5_PHY_HOST_CTRL0);\r\nphyhost |= (HOST_CTRL0_SIDDQ |\r\nHOST_CTRL0_FORCESUSPEND |\r\nHOST_CTRL0_FORCESLEEP |\r\nHOST_CTRL0_PHYSWRST |\r\nHOST_CTRL0_PHYSWRSTALL);\r\nwritel(phyhost, regs + EXYNOS5_PHY_HOST_CTRL0);\r\nphyotg = readl(regs + EXYNOS5_PHY_OTG_SYS);\r\nphyotg |= (OTG_SYS_FORCESUSPEND |\r\nOTG_SYS_SIDDQ_UOTG |\r\nOTG_SYS_FORCESLEEP);\r\nwritel(phyotg, regs + EXYNOS5_PHY_OTG_SYS);\r\n}\r\nstatic void samsung_usb2phy_disable(struct samsung_usbphy *sphy)\r\n{\r\nvoid __iomem *regs = sphy->regs;\r\nu32 phypwr;\r\nphypwr = readl(regs + SAMSUNG_PHYPWR);\r\nswitch (sphy->drv_data->cpu_type) {\r\ncase TYPE_S3C64XX:\r\nphypwr |= PHYPWR_NORMAL_MASK;\r\nbreak;\r\ncase TYPE_EXYNOS4X12:\r\nphypwr |= (PHYPWR_NORMAL_MASK_HSIC0 |\r\nPHYPWR_NORMAL_MASK_HSIC1 |\r\nPHYPWR_NORMAL_MASK_PHY1);\r\ncase TYPE_EXYNOS4210:\r\nphypwr |= PHYPWR_NORMAL_MASK_PHY0;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(phypwr, regs + SAMSUNG_PHYPWR);\r\n}\r\nstatic int samsung_usb2phy_init(struct usb_phy *phy)\r\n{\r\nstruct samsung_usbphy *sphy;\r\nstruct usb_bus *host = NULL;\r\nunsigned long flags;\r\nint ret = 0;\r\nsphy = phy_to_sphy(phy);\r\nhost = phy->otg->host;\r\nret = clk_prepare_enable(sphy->clk);\r\nif (ret) {\r\ndev_err(sphy->dev, "%s: clk_prepare_enable failed\n", __func__);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&sphy->lock, flags);\r\nif (host) {\r\nif (!strstr(dev_name(host->controller), "ehci") ||\r\n!strstr(dev_name(host->controller), "ohci"))\r\nsamsung_usbphy_set_type(&sphy->phy, USB_PHY_TYPE_HOST);\r\n} else {\r\nsamsung_usbphy_set_type(&sphy->phy, USB_PHY_TYPE_DEVICE);\r\n}\r\nif (sphy->plat && sphy->plat->pmu_isolation)\r\nsphy->plat->pmu_isolation(false);\r\nelse if (sphy->drv_data->set_isolation)\r\nsphy->drv_data->set_isolation(sphy, false);\r\nsamsung_usbphy_cfg_sel(sphy);\r\nsphy->drv_data->phy_enable(sphy);\r\nspin_unlock_irqrestore(&sphy->lock, flags);\r\nclk_disable_unprepare(sphy->clk);\r\nreturn ret;\r\n}\r\nstatic void samsung_usb2phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct samsung_usbphy *sphy;\r\nstruct usb_bus *host = NULL;\r\nunsigned long flags;\r\nsphy = phy_to_sphy(phy);\r\nhost = phy->otg->host;\r\nif (clk_prepare_enable(sphy->clk)) {\r\ndev_err(sphy->dev, "%s: clk_prepare_enable failed\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&sphy->lock, flags);\r\nif (host) {\r\nif (!strstr(dev_name(host->controller), "ehci") ||\r\n!strstr(dev_name(host->controller), "ohci"))\r\nsamsung_usbphy_set_type(&sphy->phy, USB_PHY_TYPE_HOST);\r\n} else {\r\nsamsung_usbphy_set_type(&sphy->phy, USB_PHY_TYPE_DEVICE);\r\n}\r\nsphy->drv_data->phy_disable(sphy);\r\nif (sphy->plat && sphy->plat->pmu_isolation)\r\nsphy->plat->pmu_isolation(true);\r\nelse if (sphy->drv_data->set_isolation)\r\nsphy->drv_data->set_isolation(sphy, true);\r\nspin_unlock_irqrestore(&sphy->lock, flags);\r\nclk_disable_unprepare(sphy->clk);\r\n}\r\nstatic int samsung_usb2phy_probe(struct platform_device *pdev)\r\n{\r\nstruct samsung_usbphy *sphy;\r\nstruct usb_otg *otg;\r\nstruct samsung_usbphy_data *pdata = dev_get_platdata(&pdev->dev);\r\nconst struct samsung_usbphy_drvdata *drv_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *phy_mem;\r\nvoid __iomem *phy_base;\r\nstruct clk *clk;\r\nint ret;\r\nphy_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphy_base = devm_ioremap_resource(dev, phy_mem);\r\nif (IS_ERR(phy_base))\r\nreturn PTR_ERR(phy_base);\r\nsphy = devm_kzalloc(dev, sizeof(*sphy), GFP_KERNEL);\r\nif (!sphy)\r\nreturn -ENOMEM;\r\notg = devm_kzalloc(dev, sizeof(*otg), GFP_KERNEL);\r\nif (!otg)\r\nreturn -ENOMEM;\r\ndrv_data = samsung_usbphy_get_driver_data(pdev);\r\nif (drv_data->cpu_type == TYPE_EXYNOS5250)\r\nclk = devm_clk_get(dev, "usbhost");\r\nelse\r\nclk = devm_clk_get(dev, "otg");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "Failed to get usbhost/otg clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nsphy->dev = dev;\r\nif (dev->of_node) {\r\nret = samsung_usbphy_parse_dt(sphy);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nif (!pdata) {\r\ndev_err(dev, "no platform data specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nsphy->plat = pdata;\r\nsphy->regs = phy_base;\r\nsphy->clk = clk;\r\nsphy->drv_data = drv_data;\r\nsphy->phy.dev = sphy->dev;\r\nsphy->phy.label = "samsung-usb2phy";\r\nsphy->phy.type = USB_PHY_TYPE_USB2;\r\nsphy->phy.init = samsung_usb2phy_init;\r\nsphy->phy.shutdown = samsung_usb2phy_shutdown;\r\nsphy->ref_clk_freq = samsung_usbphy_get_refclk_freq(sphy);\r\nif (sphy->ref_clk_freq < 0)\r\nreturn -EINVAL;\r\nsphy->phy.otg = otg;\r\nsphy->phy.otg->phy = &sphy->phy;\r\nsphy->phy.otg->set_host = samsung_usbphy_set_host;\r\nspin_lock_init(&sphy->lock);\r\nplatform_set_drvdata(pdev, sphy);\r\nreturn usb_add_phy_dev(&sphy->phy);\r\n}\r\nstatic int samsung_usb2phy_remove(struct platform_device *pdev)\r\n{\r\nstruct samsung_usbphy *sphy = platform_get_drvdata(pdev);\r\nusb_remove_phy(&sphy->phy);\r\nif (sphy->pmuregs)\r\niounmap(sphy->pmuregs);\r\nif (sphy->sysreg)\r\niounmap(sphy->sysreg);\r\nreturn 0;\r\n}
