static void arcfour_init(struct arc4context *parc4ctx, u8 *key, u32 key_len)\r\n{\r\nu32 t, u;\r\nu32 keyindex;\r\nu32 stateindex;\r\nu8 *state;\r\nu32 counter;\r\n_func_enter_;\r\nstate = parc4ctx->state;\r\nparc4ctx->x = 0;\r\nparc4ctx->y = 0;\r\nfor (counter = 0; counter < 256; counter++)\r\nstate[counter] = (u8)counter;\r\nkeyindex = 0;\r\nstateindex = 0;\r\nfor (counter = 0; counter < 256; counter++) {\r\nt = state[counter];\r\nstateindex = (stateindex + key[keyindex] + t) & 0xff;\r\nu = state[stateindex];\r\nstate[stateindex] = (u8)t;\r\nstate[counter] = (u8)u;\r\nif (++keyindex >= key_len)\r\nkeyindex = 0;\r\n}\r\n_func_exit_;\r\n}\r\nstatic u32 arcfour_byte(struct arc4context *parc4ctx)\r\n{\r\nu32 x;\r\nu32 y;\r\nu32 sx, sy;\r\nu8 *state;\r\n_func_enter_;\r\nstate = parc4ctx->state;\r\nx = (parc4ctx->x + 1) & 0xff;\r\nsx = state[x];\r\ny = (sx + parc4ctx->y) & 0xff;\r\nsy = state[y];\r\nparc4ctx->x = x;\r\nparc4ctx->y = y;\r\nstate[y] = (u8)sx;\r\nstate[x] = (u8)sy;\r\n_func_exit_;\r\nreturn state[(sx + sy) & 0xff];\r\n}\r\nstatic void arcfour_encrypt(struct arc4context *parc4ctx, u8 *dest, u8 *src, u32 len)\r\n{\r\nu32 i;\r\n_func_enter_;\r\nfor (i = 0; i < len; i++)\r\ndest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);\r\n_func_exit_;\r\n}\r\nstatic u8 crc32_reverseBit(u8 data)\r\n{\r\nreturn (u8)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) |\r\n((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) |\r\n((data>>5)&0x02) | ((data>>7)&0x01);\r\n}\r\nstatic void crc32_init(void)\r\n{\r\n_func_enter_;\r\nif (bcrc32initialized == 1) {\r\ngoto exit;\r\n} else {\r\nint i, j;\r\nu32 c;\r\nu8 *p = (u8 *)&c, *p1;\r\nu8 k;\r\nc = 0x12340000;\r\nfor (i = 0; i < 256; ++i) {\r\nk = crc32_reverseBit((u8)i);\r\nfor (c = ((u32)k) << 24, j = 8; j > 0; --j)\r\nc = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);\r\np1 = (u8 *)&crc32_table[i];\r\np1[0] = crc32_reverseBit(p[3]);\r\np1[1] = crc32_reverseBit(p[2]);\r\np1[2] = crc32_reverseBit(p[1]);\r\np1[3] = crc32_reverseBit(p[0]);\r\n}\r\nbcrc32initialized = 1;\r\n}\r\nexit:\r\n_func_exit_;\r\n}\r\nstatic __le32 getcrc32(u8 *buf, int len)\r\n{\r\nu8 *p;\r\nu32 crc;\r\n_func_enter_;\r\nif (bcrc32initialized == 0)\r\ncrc32_init();\r\ncrc = 0xffffffff;\r\nfor (p = buf; len > 0; ++p, --len)\r\ncrc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);\r\n_func_exit_;\r\nreturn cpu_to_le32(~crc);\r\n}\r\nvoid rtw_wep_encrypt(struct adapter *padapter, u8 *pxmitframe)\r\n{\r\nunsigned char crc[4];\r\nstruct arc4context mycontext;\r\nint curfragnum, length;\r\nu32 keylength;\r\nu8 *pframe, *payload, *iv;\r\nu8 wepkey[16];\r\nu8 hw_hdr_offset = 0;\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\n_func_enter_;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn;\r\nhw_hdr_offset = TXDESC_SIZE +\r\n(((struct xmit_frame *)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr + hw_hdr_offset;\r\nif ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {\r\nkeylength = psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\niv = pframe+pattrib->hdrlen;\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0], keylength);\r\npayload = pframe+pattrib->iv_len+pattrib->hdrlen;\r\nif ((curfragnum+1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len;\r\n*((__le32 *)crc) = getcrc32(payload, length);\r\narcfour_init(&mycontext, wepkey, 3+keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload+length, crc, 4);\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len;\r\n*((__le32 *)crc) = getcrc32(payload, length);\r\narcfour_init(&mycontext, wepkey, 3+keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload+length, crc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((size_t)(pframe));\r\n}\r\n}\r\n}\r\n_func_exit_;\r\n}\r\nvoid rtw_wep_decrypt(struct adapter *padapter, u8 *precvframe)\r\n{\r\nu8 crc[4];\r\nstruct arc4context mycontext;\r\nint length;\r\nu32 keylength;\r\nu8 *pframe, *payload, *iv, wepkey[16];\r\nu8 keyindex;\r\nstruct rx_pkt_attrib *prxattrib = &(((union recv_frame *)precvframe)->u.hdr.attrib);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\n_func_enter_;\r\npframe = (unsigned char *)((union recv_frame *)precvframe)->u.hdr.rx_data;\r\nif ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt == _WEP104_)) {\r\niv = pframe+prxattrib->hdrlen;\r\nkeyindex = prxattrib->key_index;\r\nkeylength = psecuritypriv->dot11DefKeylen[keyindex];\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->dot11DefKey[keyindex].skey[0], keylength);\r\nlength = ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;\r\npayload = pframe+prxattrib->iv_len+prxattrib->hdrlen;\r\narcfour_init(&mycontext, wepkey, 3+keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\n*((__le32 *)crc) = getcrc32(payload, length - 4);\r\nif (crc[3] != payload[length-1] ||\r\ncrc[2] != payload[length-2] ||\r\ncrc[1] != payload[length-3] ||\r\ncrc[0] != payload[length-4]) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n("rtw_wep_decrypt:icv error crc (%4ph)!=payload (%4ph)\n",\r\n&crc, &payload[length-4]));\r\n}\r\n}\r\n_func_exit_;\r\nreturn;\r\n}\r\nstatic u32 secmicgetuint32(u8 *p)\r\n{\r\ns32 i;\r\nu32 res = 0;\r\n_func_enter_;\r\nfor (i = 0; i < 4; i++)\r\nres |= ((u32)(*p++)) << (8*i);\r\n_func_exit_;\r\nreturn res;\r\n}\r\nstatic void secmicputuint32(u8 *p, u32 val)\r\n{\r\nlong i;\r\n_func_enter_;\r\nfor (i = 0; i < 4; i++) {\r\n*p++ = (u8) (val & 0xff);\r\nval >>= 8;\r\n}\r\n_func_exit_;\r\n}\r\nstatic void secmicclear(struct mic_data *pmicdata)\r\n{\r\n_func_enter_;\r\npmicdata->L = pmicdata->K0;\r\npmicdata->R = pmicdata->K1;\r\npmicdata->nBytesInM = 0;\r\npmicdata->M = 0;\r\n_func_exit_;\r\n}\r\nvoid rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key)\r\n{\r\n_func_enter_;\r\npmicdata->K0 = secmicgetuint32(key);\r\npmicdata->K1 = secmicgetuint32(key + 4);\r\nsecmicclear(pmicdata);\r\n_func_exit_;\r\n}\r\nvoid rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b)\r\n{\r\n_func_enter_;\r\npmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);\r\npmicdata->nBytesInM++;\r\nif (pmicdata->nBytesInM >= 4) {\r\npmicdata->L ^= pmicdata->M;\r\npmicdata->R ^= ROL32(pmicdata->L, 17);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROL32(pmicdata->L, 3);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROR32(pmicdata->L, 2);\r\npmicdata->L += pmicdata->R;\r\npmicdata->M = 0;\r\npmicdata->nBytesInM = 0;\r\n}\r\n_func_exit_;\r\n}\r\nvoid rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes)\r\n{\r\n_func_enter_;\r\nwhile (nbytes > 0) {\r\nrtw_secmicappendbyte(pmicdata, *src++);\r\nnbytes--;\r\n}\r\n_func_exit_;\r\n}\r\nvoid rtw_secgetmic(struct mic_data *pmicdata, u8 *dst)\r\n{\r\n_func_enter_;\r\nrtw_secmicappendbyte(pmicdata, 0x5a);\r\nrtw_secmicappendbyte(pmicdata, 0);\r\nrtw_secmicappendbyte(pmicdata, 0);\r\nrtw_secmicappendbyte(pmicdata, 0);\r\nrtw_secmicappendbyte(pmicdata, 0);\r\nwhile (pmicdata->nBytesInM != 0)\r\nrtw_secmicappendbyte(pmicdata, 0);\r\nsecmicputuint32(dst, pmicdata->L);\r\nsecmicputuint32(dst+4, pmicdata->R);\r\nsecmicclear(pmicdata);\r\n_func_exit_;\r\n}\r\nvoid rtw_seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code, u8 pri)\r\n{\r\nstruct mic_data micdata;\r\nu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\r\n_func_enter_;\r\nrtw_secmicsetkey(&micdata, key);\r\npriority[0] = pri;\r\nif (header[1]&1) {\r\nrtw_secmicappend(&micdata, &header[16], 6);\r\nif (header[1]&2)\r\nrtw_secmicappend(&micdata, &header[24], 6);\r\nelse\r\nrtw_secmicappend(&micdata, &header[10], 6);\r\n} else {\r\nrtw_secmicappend(&micdata, &header[4], 6);\r\nif (header[1]&2)\r\nrtw_secmicappend(&micdata, &header[16], 6);\r\nelse\r\nrtw_secmicappend(&micdata, &header[10], 6);\r\n}\r\nrtw_secmicappend(&micdata, &priority[0], 4);\r\nrtw_secmicappend(&micdata, data, data_len);\r\nrtw_secgetmic(&micdata, mic_code);\r\n_func_exit_;\r\n}\r\nstatic void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)\r\n{\r\nint i;\r\n_func_enter_;\r\np1k[0] = Lo16(iv32);\r\np1k[1] = Hi16(iv32);\r\np1k[2] = Mk16(ta[1], ta[0]);\r\np1k[3] = Mk16(ta[3], ta[2]);\r\np1k[4] = Mk16(ta[5], ta[4]);\r\nfor (i = 0; i < PHASE1_LOOP_CNT; i++) {\r\np1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));\r\np1k[1] += _S_(p1k[0] ^ TK16((i&1)+2));\r\np1k[2] += _S_(p1k[1] ^ TK16((i&1)+4));\r\np1k[3] += _S_(p1k[2] ^ TK16((i&1)+6));\r\np1k[4] += _S_(p1k[3] ^ TK16((i&1)+0));\r\np1k[4] += (unsigned short)i;\r\n}\r\n_func_exit_;\r\n}\r\nstatic void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)\r\n{\r\nint i;\r\nu16 PPK[6];\r\n_func_enter_;\r\nfor (i = 0; i < 5; i++)\r\nPPK[i] = p1k[i];\r\nPPK[5] = p1k[4] + iv16;\r\nPPK[0] += _S_(PPK[5] ^ TK16(0));\r\nPPK[1] += _S_(PPK[0] ^ TK16(1));\r\nPPK[2] += _S_(PPK[1] ^ TK16(2));\r\nPPK[3] += _S_(PPK[2] ^ TK16(3));\r\nPPK[4] += _S_(PPK[3] ^ TK16(4));\r\nPPK[5] += _S_(PPK[4] ^ TK16(5));\r\nPPK[0] += RotR1(PPK[5] ^ TK16(6));\r\nPPK[1] += RotR1(PPK[0] ^ TK16(7));\r\nPPK[2] += RotR1(PPK[1]);\r\nPPK[3] += RotR1(PPK[2]);\r\nPPK[4] += RotR1(PPK[3]);\r\nPPK[5] += RotR1(PPK[4]);\r\nrc4key[0] = Hi8(iv16);\r\nrc4key[1] = (Hi8(iv16) | 0x20) & 0x7F;\r\nrc4key[2] = Lo8(iv16);\r\nrc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);\r\nfor (i = 0; i < 6; i++) {\r\nrc4key[4+2*i] = Lo8(PPK[i]);\r\nrc4key[5+2*i] = Hi8(PPK[i]);\r\n}\r\n_func_exit_;\r\n}\r\nu32 rtw_tkip_encrypt(struct adapter *padapter, u8 *pxmitframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\nu8 crc[4];\r\nu8 hw_hdr_offset = 0;\r\nstruct arc4context mycontext;\r\nint curfragnum, length;\r\nu8 *pframe, *payload, *iv, *prwskey;\r\nunion pn48 dot11txpn;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu32 res = _SUCCESS;\r\n_func_enter_;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn _FAIL;\r\nhw_hdr_offset = TXDESC_SIZE +\r\n(((struct xmit_frame *)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr + hw_hdr_offset;\r\nif (pattrib->encrypt == _TKIP_) {\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);\r\nif (stainfo != NULL) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_tkip_encrypt: stainfo!= NULL!!!\n"));\r\nif (IS_MCAST(pattrib->ra))\r\nprwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;\r\nelse\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\niv = pframe+pattrib->hdrlen;\r\npayload = pframe+pattrib->iv_len+pattrib->hdrlen;\r\nGET_TKIP_PN(iv, dot11txpn);\r\npnl = (u16)(dot11txpn.val);\r\npnh = (u32)(dot11txpn.val>>16);\r\nphase1((u16 *)&ttkey[0], prwskey, &pattrib->ta[0], pnh);\r\nphase2(&rc4key[0], prwskey, (u16 *)&ttkey[0], pnl);\r\nif ((curfragnum+1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_info_,\r\n("pattrib->iv_len=%x, pattrib->icv_len=%x\n",\r\npattrib->iv_len, pattrib->icv_len));\r\n*((__le32 *)crc) = getcrc32(payload, length);\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload+length, crc, 4);\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;\r\n*((__le32 *)crc) = getcrc32(payload, length);\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\narcfour_encrypt(&mycontext, payload+length, crc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((size_t)(pframe));\r\n}\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_tkip_encrypt: stainfo==NULL!!!\n"));\r\nres = _FAIL;\r\n}\r\n}\r\n_func_exit_;\r\nreturn res;\r\n}\r\nu32 rtw_tkip_decrypt(struct adapter *padapter, u8 *precvframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\nu8 crc[4];\r\nstruct arc4context mycontext;\r\nint length;\r\nu8 *pframe, *payload, *iv, *prwskey;\r\nunion pn48 dot11txpn;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nu32 res = _SUCCESS;\r\n_func_enter_;\r\npframe = (unsigned char *)((union recv_frame *)precvframe)->u.hdr.rx_data;\r\nif (prxattrib->encrypt == _TKIP_) {\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, &prxattrib->ta[0]);\r\nif (stainfo != NULL) {\r\nif (IS_MCAST(prxattrib->ra)) {\r\nif (!psecuritypriv->binstallGrpkey) {\r\nres = _FAIL;\r\nDBG_88E("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n", __func__);\r\ngoto exit;\r\n}\r\nprwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;\r\n} else {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_tkip_decrypt: stainfo!= NULL!!!\n"));\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\n}\r\niv = pframe+prxattrib->hdrlen;\r\npayload = pframe+prxattrib->iv_len+prxattrib->hdrlen;\r\nlength = ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;\r\nGET_TKIP_PN(iv, dot11txpn);\r\npnl = (u16)(dot11txpn.val);\r\npnh = (u32)(dot11txpn.val>>16);\r\nphase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0], pnh);\r\nphase2(&rc4key[0], prwskey, (unsigned short *)&ttkey[0], pnl);\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\n*((__le32 *)crc) = getcrc32(payload, length-4);\r\nif (crc[3] != payload[length-1] ||\r\ncrc[2] != payload[length-2] ||\r\ncrc[1] != payload[length-3] ||\r\ncrc[0] != payload[length-4]) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n("rtw_wep_decrypt:icv error crc (%4ph)!=payload (%4ph)\n",\r\n&crc, &payload[length-4]));\r\nres = _FAIL;\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_tkip_decrypt: stainfo==NULL!!!\n"));\r\nres = _FAIL;\r\n}\r\n}\r\n_func_exit_;\r\nexit:\r\nreturn res;\r\n}\r\nstatic void xor_128(u8 *a, u8 *b, u8 *out)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = a[i] ^ b[i];\r\n_func_exit_;\r\n}\r\nstatic void xor_32(u8 *a, u8 *b, u8 *out)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 4; i++)\r\nout[i] = a[i] ^ b[i];\r\n_func_exit_;\r\n}\r\nstatic u8 sbox(u8 a)\r\n{\r\nreturn sbox_table[(int)a];\r\n}\r\nstatic void next_key(u8 *key, int round)\r\n{\r\nu8 rcon;\r\nu8 sbox_key[4];\r\nu8 rcon_table[12] = {\r\n0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\r\n0x1b, 0x36, 0x36, 0x36\r\n};\r\n_func_enter_;\r\nsbox_key[0] = sbox(key[13]);\r\nsbox_key[1] = sbox(key[14]);\r\nsbox_key[2] = sbox(key[15]);\r\nsbox_key[3] = sbox(key[12]);\r\nrcon = rcon_table[round];\r\nxor_32(&key[0], sbox_key, &key[0]);\r\nkey[0] = key[0] ^ rcon;\r\nxor_32(&key[4], &key[0], &key[4]);\r\nxor_32(&key[8], &key[4], &key[8]);\r\nxor_32(&key[12], &key[8], &key[12]);\r\n_func_exit_;\r\n}\r\nstatic void byte_sub(u8 *in, u8 *out)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = sbox(in[i]);\r\n_func_exit_;\r\n}\r\nstatic void shift_row(u8 *in, u8 *out)\r\n{\r\n_func_enter_;\r\nout[0] = in[0];\r\nout[1] = in[5];\r\nout[2] = in[10];\r\nout[3] = in[15];\r\nout[4] = in[4];\r\nout[5] = in[9];\r\nout[6] = in[14];\r\nout[7] = in[3];\r\nout[8] = in[8];\r\nout[9] = in[13];\r\nout[10] = in[2];\r\nout[11] = in[7];\r\nout[12] = in[12];\r\nout[13] = in[1];\r\nout[14] = in[6];\r\nout[15] = in[11];\r\n_func_exit_;\r\n}\r\nstatic void mix_column(u8 *in, u8 *out)\r\n{\r\nint i;\r\nu8 add1b[4];\r\nu8 add1bf7[4];\r\nu8 rotl[4];\r\nu8 swap_halfs[4];\r\nu8 andf7[4];\r\nu8 rotr[4];\r\nu8 temp[4];\r\nu8 tempb[4];\r\n_func_enter_;\r\nfor (i = 0 ; i < 4; i++) {\r\nif ((in[i] & 0x80) == 0x80)\r\nadd1b[i] = 0x1b;\r\nelse\r\nadd1b[i] = 0x00;\r\n}\r\nswap_halfs[0] = in[2];\r\nswap_halfs[1] = in[3];\r\nswap_halfs[2] = in[0];\r\nswap_halfs[3] = in[1];\r\nrotl[0] = in[3];\r\nrotl[1] = in[0];\r\nrotl[2] = in[1];\r\nrotl[3] = in[2];\r\nandf7[0] = in[0] & 0x7f;\r\nandf7[1] = in[1] & 0x7f;\r\nandf7[2] = in[2] & 0x7f;\r\nandf7[3] = in[3] & 0x7f;\r\nfor (i = 3; i > 0; i--) {\r\nandf7[i] = andf7[i] << 1;\r\nif ((andf7[i-1] & 0x80) == 0x80)\r\nandf7[i] = (andf7[i] | 0x01);\r\n}\r\nandf7[0] = andf7[0] << 1;\r\nandf7[0] = andf7[0] & 0xfe;\r\nxor_32(add1b, andf7, add1bf7);\r\nxor_32(in, add1bf7, rotr);\r\ntemp[0] = rotr[0];\r\nrotr[0] = rotr[1];\r\nrotr[1] = rotr[2];\r\nrotr[2] = rotr[3];\r\nrotr[3] = temp[0];\r\nxor_32(add1bf7, rotr, temp);\r\nxor_32(swap_halfs, rotl, tempb);\r\nxor_32(temp, tempb, out);\r\n_func_exit_;\r\n}\r\nstatic void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)\r\n{\r\nint round;\r\nint i;\r\nu8 intermediatea[16];\r\nu8 intermediateb[16];\r\nu8 round_key[16];\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nround_key[i] = key[i];\r\nfor (round = 0; round < 11; round++) {\r\nif (round == 0) {\r\nxor_128(round_key, data, ciphertext);\r\nnext_key(round_key, round);\r\n} else if (round == 10) {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nxor_128(intermediateb, round_key, ciphertext);\r\n} else {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nmix_column(&intermediateb[0], &intermediatea[0]);\r\nmix_column(&intermediateb[4], &intermediatea[4]);\r\nmix_column(&intermediateb[8], &intermediatea[8]);\r\nmix_column(&intermediateb[12], &intermediatea[12]);\r\nxor_128(intermediatea, round_key, ciphertext);\r\nnext_key(round_key, round);\r\n}\r\n}\r\n_func_exit_;\r\n}\r\nstatic void construct_mic_iv(u8 *mic_iv, int qc_exists, int a4_exists, u8 *mpdu,\r\nuint payload_length, u8 *pn_vector)\r\n{\r\nint i;\r\n_func_enter_;\r\nmic_iv[0] = 0x59;\r\nif (qc_exists && a4_exists)\r\nmic_iv[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nmic_iv[1] = mpdu[24] & 0x0f;\r\nif (!qc_exists)\r\nmic_iv[1] = 0x00;\r\nfor (i = 2; i < 8; i++)\r\nmic_iv[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nmic_iv[i] = pn_vector[13 - i];\r\nmic_iv[14] = (unsigned char) (payload_length / 256);\r\nmic_iv[15] = (unsigned char) (payload_length % 256);\r\n_func_exit_;\r\n}\r\nstatic void construct_mic_header1(u8 *mic_header1, int header_length, u8 *mpdu)\r\n{\r\n_func_enter_;\r\nmic_header1[0] = (u8)((header_length - 2) / 256);\r\nmic_header1[1] = (u8)((header_length - 2) % 256);\r\nmic_header1[2] = mpdu[0] & 0xcf;\r\nmic_header1[3] = mpdu[1] & 0xc7;\r\nmic_header1[4] = mpdu[4];\r\nmic_header1[5] = mpdu[5];\r\nmic_header1[6] = mpdu[6];\r\nmic_header1[7] = mpdu[7];\r\nmic_header1[8] = mpdu[8];\r\nmic_header1[9] = mpdu[9];\r\nmic_header1[10] = mpdu[10];\r\nmic_header1[11] = mpdu[11];\r\nmic_header1[12] = mpdu[12];\r\nmic_header1[13] = mpdu[13];\r\nmic_header1[14] = mpdu[14];\r\nmic_header1[15] = mpdu[15];\r\n_func_exit_;\r\n}\r\nstatic void construct_mic_header2(u8 *mic_header2, u8 *mpdu, int a4_exists, int qc_exists)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nmic_header2[i] = 0x00;\r\nmic_header2[0] = mpdu[16];\r\nmic_header2[1] = mpdu[17];\r\nmic_header2[2] = mpdu[18];\r\nmic_header2[3] = mpdu[19];\r\nmic_header2[4] = mpdu[20];\r\nmic_header2[5] = mpdu[21];\r\nmic_header2[6] = 0x00;\r\nmic_header2[7] = 0x00;\r\nif (!qc_exists && a4_exists) {\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8+i] = mpdu[24+i];\r\n}\r\nif (qc_exists && !a4_exists) {\r\nmic_header2[8] = mpdu[24] & 0x0f;\r\nmic_header2[9] = mpdu[25] & 0x00;\r\n}\r\nif (qc_exists && a4_exists) {\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8+i] = mpdu[24+i];\r\nmic_header2[14] = mpdu[30] & 0x0f;\r\nmic_header2[15] = mpdu[31] & 0x00;\r\n}\r\n_func_exit_;\r\n}\r\nstatic void construct_ctr_preload(u8 *ctr_preload, int a4_exists, int qc_exists, u8 *mpdu, u8 *pn_vector, int c)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nctr_preload[i] = 0x00;\r\ni = 0;\r\nctr_preload[0] = 0x01;\r\nif (qc_exists && a4_exists)\r\nctr_preload[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nctr_preload[1] = mpdu[24] & 0x0f;\r\nfor (i = 2; i < 8; i++)\r\nctr_preload[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nctr_preload[i] = pn_vector[13 - i];\r\nctr_preload[14] = (unsigned char) (c / 256);\r\nctr_preload[15] = (unsigned char) (c % 256);\r\n_func_exit_;\r\n}\r\nstatic void bitwise_xor(u8 *ina, u8 *inb, u8 *out)\r\n{\r\nint i;\r\n_func_enter_;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = ina[i] ^ inb[i];\r\n_func_exit_;\r\n}\r\nstatic int aes_cipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)\r\n{\r\nuint qc_exists, a4_exists, i, j, payload_remainder,\r\nnum_blocks, payload_index;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nuint frtype = GetFrameType(pframe);\r\nuint frsubtype = GetFrameSubType(pframe);\r\n_func_enter_;\r\nfrsubtype = frsubtype>>4;\r\n_rtw_memset((void *)mic_iv, 0, 16);\r\n_rtw_memset((void *)mic_header1, 0, 16);\r\n_rtw_memset((void *)mic_header2, 0, 16);\r\n_rtw_memset((void *)ctr_preload, 0, 16);\r\n_rtw_memset((void *)chain_buffer, 0, 16);\r\n_rtw_memset((void *)aes_out, 0, 16);\r\n_rtw_memset((void *)padded_buffer, 0, 16);\r\nif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif ((frtype == WIFI_DATA_CFACK) || (frtype == WIFI_DATA_CFPOLL) || (frtype == WIFI_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\n} else if ((frsubtype == 0x08) || (frsubtype == 0x09) || (frsubtype == 0x0a) || (frsubtype == 0x0b)) {\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else {\r\nqc_exists = 0;\r\n}\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, pframe);\r\nconstruct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);\r\npayload_remainder = plen % 16;\r\nnum_blocks = plen / 16;\r\npayload_index = (hdrlen + 8);\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index+j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe, pn_vector, i+1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index+j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe, pn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = pframe[j+hdrlen+8+plen];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n_func_exit_;\r\nreturn _SUCCESS;\r\n}\r\nu32 rtw_aes_encrypt(struct adapter *padapter, u8 *pxmitframe)\r\n{\r\nint curfragnum, length;\r\nu8 *pframe, *prwskey;\r\nu8 hw_hdr_offset = 0;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu32 res = _SUCCESS;\r\n_func_enter_;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn _FAIL;\r\nhw_hdr_offset = TXDESC_SIZE +\r\n(((struct xmit_frame *)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr + hw_hdr_offset;\r\nif ((pattrib->encrypt == _AES_)) {\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);\r\nif (stainfo != NULL) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_aes_encrypt: stainfo!= NULL!!!\n"));\r\nif (IS_MCAST(pattrib->ra))\r\nprwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;\r\nelse\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {\r\nif ((curfragnum+1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len;\r\naes_cipher(prwskey, pattrib->hdrlen, pframe, length);\r\n} else{\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;\r\naes_cipher(prwskey, pattrib->hdrlen, pframe, length);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((size_t)(pframe));\r\n}\r\n}\r\n} else{\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_aes_encrypt: stainfo==NULL!!!\n"));\r\nres = _FAIL;\r\n}\r\n}\r\n_func_exit_;\r\nreturn res;\r\n}\r\nstatic int aes_decipher(u8 *key, uint hdrlen,\r\nu8 *pframe, uint plen)\r\n{\r\nstatic u8 message[MAX_MSG_SIZE];\r\nuint qc_exists, a4_exists, i, j, payload_remainder,\r\nnum_blocks, payload_index;\r\nint res = _SUCCESS;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nuint frtype = GetFrameType(pframe);\r\nuint frsubtype = GetFrameSubType(pframe);\r\n_func_enter_;\r\nfrsubtype = frsubtype>>4;\r\n_rtw_memset((void *)mic_iv, 0, 16);\r\n_rtw_memset((void *)mic_header1, 0, 16);\r\n_rtw_memset((void *)mic_header2, 0, 16);\r\n_rtw_memset((void *)ctr_preload, 0, 16);\r\n_rtw_memset((void *)chain_buffer, 0, 16);\r\n_rtw_memset((void *)aes_out, 0, 16);\r\n_rtw_memset((void *)padded_buffer, 0, 16);\r\nnum_blocks = (plen-8) / 16;\r\npayload_remainder = (plen-8) % 16;\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif ((frtype == WIFI_DATA_CFACK) || (frtype == WIFI_DATA_CFPOLL) ||\r\n(frtype == WIFI_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\n} else if ((frsubtype == 0x08) || (frsubtype == 0x09) ||\r\n(frsubtype == 0x0a) || (frsubtype == 0x0b)) {\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else {\r\nqc_exists = 0;\r\n}\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe, pn_vector, i+1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index+j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif ((hdrlen+plen+8) <= MAX_MSG_SIZE)\r\nmemcpy(message, pframe, (hdrlen + plen+8));\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, message, plen-8, pn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, message);\r\nconstruct_mic_header2(mic_header2, message, a4_exists, qc_exists);\r\npayload_remainder = (plen-8) % 16;\r\nnum_blocks = (plen-8) / 16;\r\npayload_index = (hdrlen + 8);\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0 ; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index+j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message, pn_vector, i+1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index+j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message, pn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = message[j+hdrlen+8+plen-8];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\nfor (i = 0; i < 8; i++) {\r\nif (pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i]) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_,\r\n("aes_decipher:mic check error mic[%d]: pframe(%x)!=message(%x)\n",\r\ni, pframe[hdrlen+8+plen-8+i], message[hdrlen+8+plen-8+i]));\r\nDBG_88E("aes_decipher:mic check error mic[%d]: pframe(%x)!=message(%x)\n",\r\ni, pframe[hdrlen+8+plen-8+i], message[hdrlen+8+plen-8+i]);\r\nres = _FAIL;\r\n}\r\n}\r\n_func_exit_;\r\nreturn res;\r\n}\r\nu32 rtw_aes_decrypt(struct adapter *padapter, u8 *precvframe)\r\n{\r\nint length;\r\nu8 *pframe, *prwskey;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nu32 res = _SUCCESS;\r\n_func_enter_;\r\npframe = (unsigned char *)((union recv_frame *)precvframe)->u.hdr.rx_data;\r\nif ((prxattrib->encrypt == _AES_)) {\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, &prxattrib->ta[0]);\r\nif (stainfo != NULL) {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_aes_decrypt: stainfo!= NULL!!!\n"));\r\nif (IS_MCAST(prxattrib->ra)) {\r\nif (!psecuritypriv->binstallGrpkey) {\r\nres = _FAIL;\r\nDBG_88E("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n", __func__);\r\ngoto exit;\r\n}\r\nprwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;\r\nif (psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index) {\r\nDBG_88E("not match packet_index=%d, install_index=%d\n",\r\nprxattrib->key_index, psecuritypriv->dot118021XGrpKeyid);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\n} else {\r\nprwskey = &stainfo->dot118021x_UncstKey.skey[0];\r\n}\r\nlength = ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;\r\nres = aes_decipher(prwskey, prxattrib->hdrlen, pframe, length);\r\n} else {\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("rtw_aes_encrypt: stainfo==NULL!!!\n"));\r\nres = _FAIL;\r\n}\r\n}\r\n_func_exit_;\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtw_use_tkipkey_handler(void *FunctionContext)\r\n{\r\nstruct adapter *padapter = (struct adapter *)FunctionContext;\r\n_func_enter_;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("^^^rtw_use_tkipkey_handler ^^^\n"));\r\npadapter->securitypriv.busetkipkey = true;\r\nRT_TRACE(_module_rtl871x_security_c_, _drv_err_, ("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n", padapter->securitypriv.busetkipkey));\r\n_func_exit_;\r\n}
