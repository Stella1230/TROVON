static void init_journal_hash(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nmemset(journal->j_hash_table, 0,\r\nJOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\r\n}\r\nstatic int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\r\n{\r\nif (bh) {\r\nclear_buffer_dirty(bh);\r\nclear_buffer_journal_test(bh);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct reiserfs_bitmap_node *allocate_bitmap_node(struct super_block\r\n*sb)\r\n{\r\nstruct reiserfs_bitmap_node *bn;\r\nstatic int id;\r\nbn = kmalloc(sizeof(struct reiserfs_bitmap_node), GFP_NOFS);\r\nif (!bn) {\r\nreturn NULL;\r\n}\r\nbn->data = kzalloc(sb->s_blocksize, GFP_NOFS);\r\nif (!bn->data) {\r\nkfree(bn);\r\nreturn NULL;\r\n}\r\nbn->id = id++;\r\nINIT_LIST_HEAD(&bn->list);\r\nreturn bn;\r\n}\r\nstatic struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_bitmap_node *bn = NULL;\r\nstruct list_head *entry = journal->j_bitmap_nodes.next;\r\njournal->j_used_bitmap_nodes++;\r\nrepeat:\r\nif (entry != &journal->j_bitmap_nodes) {\r\nbn = list_entry(entry, struct reiserfs_bitmap_node, list);\r\nlist_del(entry);\r\nmemset(bn->data, 0, sb->s_blocksize);\r\njournal->j_free_bitmap_nodes--;\r\nreturn bn;\r\n}\r\nbn = allocate_bitmap_node(sb);\r\nif (!bn) {\r\nyield();\r\ngoto repeat;\r\n}\r\nreturn bn;\r\n}\r\nstatic inline void free_bitmap_node(struct super_block *sb,\r\nstruct reiserfs_bitmap_node *bn)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\njournal->j_used_bitmap_nodes--;\r\nif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\r\nkfree(bn->data);\r\nkfree(bn);\r\n} else {\r\nlist_add(&bn->list, &journal->j_bitmap_nodes);\r\njournal->j_free_bitmap_nodes++;\r\n}\r\n}\r\nstatic void allocate_bitmap_nodes(struct super_block *sb)\r\n{\r\nint i;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_bitmap_node *bn = NULL;\r\nfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\r\nbn = allocate_bitmap_node(sb);\r\nif (bn) {\r\nlist_add(&bn->list, &journal->j_bitmap_nodes);\r\njournal->j_free_bitmap_nodes++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int set_bit_in_list_bitmap(struct super_block *sb,\r\nb_blocknr_t block,\r\nstruct reiserfs_list_bitmap *jb)\r\n{\r\nunsigned int bmap_nr = block / (sb->s_blocksize << 3);\r\nunsigned int bit_nr = block % (sb->s_blocksize << 3);\r\nif (!jb->bitmaps[bmap_nr]) {\r\njb->bitmaps[bmap_nr] = get_bitmap_node(sb);\r\n}\r\nset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\r\nreturn 0;\r\n}\r\nstatic void cleanup_bitmap_list(struct super_block *sb,\r\nstruct reiserfs_list_bitmap *jb)\r\n{\r\nint i;\r\nif (jb->bitmaps == NULL)\r\nreturn;\r\nfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\r\nif (jb->bitmaps[i]) {\r\nfree_bitmap_node(sb, jb->bitmaps[i]);\r\njb->bitmaps[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int free_list_bitmaps(struct super_block *sb,\r\nstruct reiserfs_list_bitmap *jb_array)\r\n{\r\nint i;\r\nstruct reiserfs_list_bitmap *jb;\r\nfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\r\njb = jb_array + i;\r\njb->journal_list = NULL;\r\ncleanup_bitmap_list(sb, jb);\r\nvfree(jb->bitmaps);\r\njb->bitmaps = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int free_bitmap_nodes(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct list_head *next = journal->j_bitmap_nodes.next;\r\nstruct reiserfs_bitmap_node *bn;\r\nwhile (next != &journal->j_bitmap_nodes) {\r\nbn = list_entry(next, struct reiserfs_bitmap_node, list);\r\nlist_del(next);\r\nkfree(bn->data);\r\nkfree(bn);\r\nnext = journal->j_bitmap_nodes.next;\r\njournal->j_free_bitmap_nodes--;\r\n}\r\nreturn 0;\r\n}\r\nint reiserfs_allocate_list_bitmaps(struct super_block *sb,\r\nstruct reiserfs_list_bitmap *jb_array,\r\nunsigned int bmap_nr)\r\n{\r\nint i;\r\nint failed = 0;\r\nstruct reiserfs_list_bitmap *jb;\r\nint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\r\nfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\r\njb = jb_array + i;\r\njb->journal_list = NULL;\r\njb->bitmaps = vzalloc(mem);\r\nif (!jb->bitmaps) {\r\nreiserfs_warning(sb, "clm-2000", "unable to "\r\n"allocate bitmaps for journal lists");\r\nfailed = 1;\r\nbreak;\r\n}\r\n}\r\nif (failed) {\r\nfree_list_bitmaps(sb, jb_array);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\r\nstruct reiserfs_journal_list\r\n*jl)\r\n{\r\nint i, j;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_list_bitmap *jb = NULL;\r\nfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\r\ni = journal->j_list_bitmap_index;\r\njournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\r\njb = journal->j_list_bitmap + i;\r\nif (journal->j_list_bitmap[i].journal_list) {\r\nflush_commit_list(sb,\r\njournal->j_list_bitmap[i].\r\njournal_list, 1);\r\nif (!journal->j_list_bitmap[i].journal_list) {\r\nbreak;\r\n}\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (jb->journal_list)\r\nreturn NULL;\r\njb->journal_list = jl;\r\nreturn jb;\r\n}\r\nstatic struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\r\n{\r\nstruct reiserfs_journal_cnode *head;\r\nint i;\r\nif (num_cnodes <= 0) {\r\nreturn NULL;\r\n}\r\nhead = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));\r\nif (!head) {\r\nreturn NULL;\r\n}\r\nhead[0].prev = NULL;\r\nhead[0].next = head + 1;\r\nfor (i = 1; i < num_cnodes; i++) {\r\nhead[i].prev = head + (i - 1);\r\nhead[i].next = head + (i + 1);\r\n}\r\nhead[num_cnodes - 1].next = NULL;\r\nreturn head;\r\n}\r\nstatic struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal_cnode *cn;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nreiserfs_check_lock_depth(sb, "get_cnode");\r\nif (journal->j_cnode_free <= 0) {\r\nreturn NULL;\r\n}\r\njournal->j_cnode_used++;\r\njournal->j_cnode_free--;\r\ncn = journal->j_cnode_free_list;\r\nif (!cn) {\r\nreturn cn;\r\n}\r\nif (cn->next) {\r\ncn->next->prev = NULL;\r\n}\r\njournal->j_cnode_free_list = cn->next;\r\nmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\r\nreturn cn;\r\n}\r\nstatic void free_cnode(struct super_block *sb,\r\nstruct reiserfs_journal_cnode *cn)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nreiserfs_check_lock_depth(sb, "free_cnode");\r\njournal->j_cnode_used--;\r\njournal->j_cnode_free++;\r\ncn->next = journal->j_cnode_free_list;\r\nif (journal->j_cnode_free_list) {\r\njournal->j_cnode_free_list->prev = cn;\r\n}\r\ncn->prev = NULL;\r\njournal->j_cnode_free_list = cn;\r\n}\r\nstatic void clear_prepared_bits(struct buffer_head *bh)\r\n{\r\nclear_buffer_journal_prepared(bh);\r\nclear_buffer_journal_restore_dirty(bh);\r\n}\r\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\r\nsuper_block\r\n*sb,\r\nstruct\r\nreiserfs_journal_cnode\r\n**table,\r\nlong bl)\r\n{\r\nstruct reiserfs_journal_cnode *cn;\r\ncn = journal_hash(table, sb, bl);\r\nwhile (cn) {\r\nif (cn->blocknr == bl && cn->sb == sb)\r\nreturn cn;\r\ncn = cn->hnext;\r\n}\r\nreturn (struct reiserfs_journal_cnode *)0;\r\n}\r\nint reiserfs_in_journal(struct super_block *sb,\r\nunsigned int bmap_nr, int bit_nr, int search_all,\r\nb_blocknr_t * next_zero_bit)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_cnode *cn;\r\nstruct reiserfs_list_bitmap *jb;\r\nint i;\r\nunsigned long bl;\r\n*next_zero_bit = 0;\r\nPROC_INFO_INC(sb, journal.in_journal);\r\nif (search_all) {\r\nfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\r\nPROC_INFO_INC(sb, journal.in_journal_bitmap);\r\njb = journal->j_list_bitmap + i;\r\nif (jb->journal_list && jb->bitmaps[bmap_nr] &&\r\ntest_bit(bit_nr,\r\n(unsigned long *)jb->bitmaps[bmap_nr]->\r\ndata)) {\r\n*next_zero_bit =\r\nfind_next_zero_bit((unsigned long *)\r\n(jb->bitmaps[bmap_nr]->\r\ndata),\r\nsb->s_blocksize << 3,\r\nbit_nr + 1);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\r\nif (search_all\r\n&& (cn =\r\nget_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\r\nreturn 1;\r\n}\r\nif ((cn = get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\r\nBUG();\r\nreturn 1;\r\n}\r\nPROC_INFO_INC(sb, journal.in_journal_reusable);\r\nreturn 0;\r\n}\r\nstatic inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\r\nstruct reiserfs_journal_cnode *cn)\r\n{\r\nstruct reiserfs_journal_cnode *cn_orig;\r\ncn_orig = journal_hash(table, cn->sb, cn->blocknr);\r\ncn->hnext = cn_orig;\r\ncn->hprev = NULL;\r\nif (cn_orig) {\r\ncn_orig->hprev = cn;\r\n}\r\njournal_hash(table, cn->sb, cn->blocknr) = cn;\r\n}\r\nstatic inline void lock_journal(struct super_block *sb)\r\n{\r\nPROC_INFO_INC(sb, journal.lock_journal);\r\nreiserfs_mutex_lock_safe(&SB_JOURNAL(sb)->j_mutex, sb);\r\n}\r\nstatic inline void unlock_journal(struct super_block *sb)\r\n{\r\nmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\r\n}\r\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\r\n{\r\njl->j_refcount++;\r\n}\r\nstatic inline void put_journal_list(struct super_block *s,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nif (jl->j_refcount < 1) {\r\nreiserfs_panic(s, "journal-2", "trans id %u, refcount at %d",\r\njl->j_trans_id, jl->j_refcount);\r\n}\r\nif (--jl->j_refcount == 0)\r\nkfree(jl);\r\n}\r\nstatic void cleanup_freed_for_journal_list(struct super_block *sb,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\r\nif (jb) {\r\ncleanup_bitmap_list(sb, jb);\r\n}\r\njl->j_list_bitmap->journal_list = NULL;\r\njl->j_list_bitmap = NULL;\r\n}\r\nstatic int journal_list_still_alive(struct super_block *s,\r\nunsigned int trans_id)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nstruct list_head *entry = &journal->j_journal_list;\r\nstruct reiserfs_journal_list *jl;\r\nif (!list_empty(entry)) {\r\njl = JOURNAL_LIST_ENTRY(entry->next);\r\nif (jl->j_trans_id <= trans_id) {\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_buffer_page(struct buffer_head *bh)\r\n{\r\nstruct page *page = bh->b_page;\r\nif (!page->mapping && trylock_page(page)) {\r\nget_page(page);\r\nput_bh(bh);\r\nif (!page->mapping)\r\ntry_to_free_buffers(page);\r\nunlock_page(page);\r\nput_page(page);\r\n} else {\r\nput_bh(bh);\r\n}\r\n}\r\nstatic void reiserfs_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\r\n{\r\nif (buffer_journaled(bh)) {\r\nreiserfs_warning(NULL, "clm-2084",\r\n"pinned buffer %lu:%pg sent to disk",\r\nbh->b_blocknr, bh->b_bdev);\r\n}\r\nif (uptodate)\r\nset_buffer_uptodate(bh);\r\nelse\r\nclear_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nrelease_buffer_page(bh);\r\n}\r\nstatic void reiserfs_end_ordered_io(struct buffer_head *bh, int uptodate)\r\n{\r\nif (uptodate)\r\nset_buffer_uptodate(bh);\r\nelse\r\nclear_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nput_bh(bh);\r\n}\r\nstatic void submit_logged_buffer(struct buffer_head *bh)\r\n{\r\nget_bh(bh);\r\nbh->b_end_io = reiserfs_end_buffer_io_sync;\r\nclear_buffer_journal_new(bh);\r\nclear_buffer_dirty(bh);\r\nif (!test_clear_buffer_journal_test(bh))\r\nBUG();\r\nif (!buffer_uptodate(bh))\r\nBUG();\r\nsubmit_bh(REQ_OP_WRITE, 0, bh);\r\n}\r\nstatic void submit_ordered_buffer(struct buffer_head *bh)\r\n{\r\nget_bh(bh);\r\nbh->b_end_io = reiserfs_end_ordered_io;\r\nclear_buffer_dirty(bh);\r\nif (!buffer_uptodate(bh))\r\nBUG();\r\nsubmit_bh(REQ_OP_WRITE, 0, bh);\r\n}\r\nstatic void write_chunk(struct buffer_chunk *chunk)\r\n{\r\nint i;\r\nfor (i = 0; i < chunk->nr; i++) {\r\nsubmit_logged_buffer(chunk->bh[i]);\r\n}\r\nchunk->nr = 0;\r\n}\r\nstatic void write_ordered_chunk(struct buffer_chunk *chunk)\r\n{\r\nint i;\r\nfor (i = 0; i < chunk->nr; i++) {\r\nsubmit_ordered_buffer(chunk->bh[i]);\r\n}\r\nchunk->nr = 0;\r\n}\r\nstatic int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\r\nspinlock_t * lock, void (fn) (struct buffer_chunk *))\r\n{\r\nint ret = 0;\r\nBUG_ON(chunk->nr >= CHUNK_SIZE);\r\nchunk->bh[chunk->nr++] = bh;\r\nif (chunk->nr >= CHUNK_SIZE) {\r\nret = 1;\r\nif (lock) {\r\nspin_unlock(lock);\r\nfn(chunk);\r\nspin_lock(lock);\r\n} else {\r\nfn(chunk);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic struct reiserfs_jh *alloc_jh(void)\r\n{\r\nstruct reiserfs_jh *jh;\r\nwhile (1) {\r\njh = kmalloc(sizeof(*jh), GFP_NOFS);\r\nif (jh) {\r\natomic_inc(&nr_reiserfs_jh);\r\nreturn jh;\r\n}\r\nyield();\r\n}\r\n}\r\nvoid reiserfs_free_jh(struct buffer_head *bh)\r\n{\r\nstruct reiserfs_jh *jh;\r\njh = bh->b_private;\r\nif (jh) {\r\nbh->b_private = NULL;\r\njh->bh = NULL;\r\nlist_del_init(&jh->list);\r\nkfree(jh);\r\nif (atomic_read(&nr_reiserfs_jh) <= 0)\r\nBUG();\r\natomic_dec(&nr_reiserfs_jh);\r\nput_bh(bh);\r\n}\r\n}\r\nstatic inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\r\nint tail)\r\n{\r\nstruct reiserfs_jh *jh;\r\nif (bh->b_private) {\r\nspin_lock(&j->j_dirty_buffers_lock);\r\nif (!bh->b_private) {\r\nspin_unlock(&j->j_dirty_buffers_lock);\r\ngoto no_jh;\r\n}\r\njh = bh->b_private;\r\nlist_del_init(&jh->list);\r\n} else {\r\nno_jh:\r\nget_bh(bh);\r\njh = alloc_jh();\r\nspin_lock(&j->j_dirty_buffers_lock);\r\nBUG_ON(bh->b_private);\r\njh->bh = bh;\r\nbh->b_private = jh;\r\n}\r\njh->jl = j->j_current_jl;\r\nif (tail)\r\nlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\r\nelse {\r\nlist_add_tail(&jh->list, &jh->jl->j_bh_list);\r\n}\r\nspin_unlock(&j->j_dirty_buffers_lock);\r\nreturn 0;\r\n}\r\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\r\n{\r\nreturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\r\n}\r\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\r\n{\r\nreturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\r\n}\r\nstatic int write_ordered_buffers(spinlock_t * lock,\r\nstruct reiserfs_journal *j,\r\nstruct reiserfs_journal_list *jl,\r\nstruct list_head *list)\r\n{\r\nstruct buffer_head *bh;\r\nstruct reiserfs_jh *jh;\r\nint ret = j->j_errno;\r\nstruct buffer_chunk chunk;\r\nstruct list_head tmp;\r\nINIT_LIST_HEAD(&tmp);\r\nchunk.nr = 0;\r\nspin_lock(lock);\r\nwhile (!list_empty(list)) {\r\njh = JH_ENTRY(list->next);\r\nbh = jh->bh;\r\nget_bh(bh);\r\nif (!trylock_buffer(bh)) {\r\nif (!buffer_dirty(bh)) {\r\nlist_move(&jh->list, &tmp);\r\ngoto loop_next;\r\n}\r\nspin_unlock(lock);\r\nif (chunk.nr)\r\nwrite_ordered_chunk(&chunk);\r\nwait_on_buffer(bh);\r\ncond_resched();\r\nspin_lock(lock);\r\ngoto loop_next;\r\n}\r\nif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\r\nclear_buffer_dirty(bh);\r\nret = -EIO;\r\n}\r\nif (buffer_dirty(bh)) {\r\nlist_move(&jh->list, &tmp);\r\nadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\r\n} else {\r\nreiserfs_free_jh(bh);\r\nunlock_buffer(bh);\r\n}\r\nloop_next:\r\nput_bh(bh);\r\ncond_resched_lock(lock);\r\n}\r\nif (chunk.nr) {\r\nspin_unlock(lock);\r\nwrite_ordered_chunk(&chunk);\r\nspin_lock(lock);\r\n}\r\nwhile (!list_empty(&tmp)) {\r\njh = JH_ENTRY(tmp.prev);\r\nbh = jh->bh;\r\nget_bh(bh);\r\nreiserfs_free_jh(bh);\r\nif (buffer_locked(bh)) {\r\nspin_unlock(lock);\r\nwait_on_buffer(bh);\r\nspin_lock(lock);\r\n}\r\nif (!buffer_uptodate(bh)) {\r\nret = -EIO;\r\n}\r\nif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\r\nspin_unlock(lock);\r\nll_rw_block(REQ_OP_WRITE, 0, 1, &bh);\r\nspin_lock(lock);\r\n}\r\nput_bh(bh);\r\ncond_resched_lock(lock);\r\n}\r\nspin_unlock(lock);\r\nreturn ret;\r\n}\r\nstatic int flush_older_commits(struct super_block *s,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nstruct reiserfs_journal_list *other_jl;\r\nstruct reiserfs_journal_list *first_jl;\r\nstruct list_head *entry;\r\nunsigned int trans_id = jl->j_trans_id;\r\nunsigned int other_trans_id;\r\nunsigned int first_trans_id;\r\nfind_first:\r\nfirst_jl = jl;\r\nentry = jl->j_list.prev;\r\nwhile (1) {\r\nother_jl = JOURNAL_LIST_ENTRY(entry);\r\nif (entry == &journal->j_journal_list ||\r\natomic_read(&other_jl->j_older_commits_done))\r\nbreak;\r\nfirst_jl = other_jl;\r\nentry = other_jl->j_list.prev;\r\n}\r\nif (first_jl == jl) {\r\nreturn 0;\r\n}\r\nfirst_trans_id = first_jl->j_trans_id;\r\nentry = &first_jl->j_list;\r\nwhile (1) {\r\nother_jl = JOURNAL_LIST_ENTRY(entry);\r\nother_trans_id = other_jl->j_trans_id;\r\nif (other_trans_id < trans_id) {\r\nif (atomic_read(&other_jl->j_commit_left) != 0) {\r\nflush_commit_list(s, other_jl, 0);\r\nif (!journal_list_still_alive(s, trans_id))\r\nreturn 1;\r\nif (!journal_list_still_alive\r\n(s, other_trans_id)) {\r\ngoto find_first;\r\n}\r\n}\r\nentry = entry->next;\r\nif (entry == &journal->j_journal_list)\r\nreturn 0;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int reiserfs_async_progress_wait(struct super_block *s)\r\n{\r\nstruct reiserfs_journal *j = SB_JOURNAL(s);\r\nif (atomic_read(&j->j_async_throttle)) {\r\nint depth;\r\ndepth = reiserfs_write_unlock_nested(s);\r\ncongestion_wait(BLK_RW_ASYNC, HZ / 10);\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\nreturn 0;\r\n}\r\nstatic int flush_commit_list(struct super_block *s,\r\nstruct reiserfs_journal_list *jl, int flushall)\r\n{\r\nint i;\r\nb_blocknr_t bn;\r\nstruct buffer_head *tbh = NULL;\r\nunsigned int trans_id = jl->j_trans_id;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nint retval = 0;\r\nint write_len;\r\nint depth;\r\nreiserfs_check_lock_depth(s, "flush_commit_list");\r\nif (atomic_read(&jl->j_older_commits_done)) {\r\nreturn 0;\r\n}\r\nBUG_ON(jl->j_len <= 0);\r\nBUG_ON(trans_id == journal->j_trans_id);\r\nget_journal_list(jl);\r\nif (flushall) {\r\nif (flush_older_commits(s, jl) == 1) {\r\ngoto put_jl;\r\n}\r\n}\r\nreiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\r\nif (!journal_list_still_alive(s, trans_id)) {\r\nmutex_unlock(&jl->j_commit_mutex);\r\ngoto put_jl;\r\n}\r\nBUG_ON(jl->j_trans_id == 0);\r\nif (atomic_read(&jl->j_commit_left) <= 0) {\r\nif (flushall) {\r\natomic_set(&jl->j_older_commits_done, 1);\r\n}\r\nmutex_unlock(&jl->j_commit_mutex);\r\ngoto put_jl;\r\n}\r\nif (!list_empty(&jl->j_bh_list)) {\r\nint ret;\r\ndepth = reiserfs_write_unlock_nested(s);\r\nret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\r\njournal, jl, &jl->j_bh_list);\r\nif (ret < 0 && retval == 0)\r\nretval = ret;\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\nBUG_ON(!list_empty(&jl->j_bh_list));\r\natomic_inc(&journal->j_async_throttle);\r\nwrite_len = jl->j_len + 1;\r\nif (write_len < 256)\r\nwrite_len = 256;\r\nfor (i = 0 ; i < write_len ; i++) {\r\nbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\r\nSB_ONDISK_JOURNAL_SIZE(s);\r\ntbh = journal_find_get_block(s, bn);\r\nif (tbh) {\r\nif (buffer_dirty(tbh)) {\r\ndepth = reiserfs_write_unlock_nested(s);\r\nll_rw_block(REQ_OP_WRITE, 0, 1, &tbh);\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\nput_bh(tbh) ;\r\n}\r\n}\r\natomic_dec(&journal->j_async_throttle);\r\nfor (i = 0; i < (jl->j_len + 1); i++) {\r\nbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\r\n(jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\r\ntbh = journal_find_get_block(s, bn);\r\ndepth = reiserfs_write_unlock_nested(s);\r\n__wait_on_buffer(tbh);\r\nreiserfs_write_lock_nested(s, depth);\r\nif (buffer_dirty(tbh)) {\r\ndepth = reiserfs_write_unlock_nested(s);\r\nsync_dirty_buffer(tbh);\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\nif (unlikely(!buffer_uptodate(tbh))) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nreiserfs_warning(s, "journal-601",\r\n"buffer write failed");\r\n#endif\r\nretval = -EIO;\r\n}\r\nput_bh(tbh);\r\nput_bh(tbh);\r\natomic_dec(&jl->j_commit_left);\r\n}\r\nBUG_ON(atomic_read(&jl->j_commit_left) != 1);\r\nif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\r\nif (buffer_dirty(jl->j_commit_bh))\r\nBUG();\r\nmark_buffer_dirty(jl->j_commit_bh) ;\r\ndepth = reiserfs_write_unlock_nested(s);\r\nif (reiserfs_barrier_flush(s))\r\n__sync_dirty_buffer(jl->j_commit_bh,\r\nREQ_PREFLUSH | REQ_FUA);\r\nelse\r\nsync_dirty_buffer(jl->j_commit_bh);\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\nif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nreiserfs_warning(s, "journal-615", "buffer write failed");\r\n#endif\r\nretval = -EIO;\r\n}\r\nbforget(jl->j_commit_bh);\r\nif (journal->j_last_commit_id != 0 &&\r\n(jl->j_trans_id - journal->j_last_commit_id) != 1) {\r\nreiserfs_warning(s, "clm-2200", "last commit %lu, current %lu",\r\njournal->j_last_commit_id, jl->j_trans_id);\r\n}\r\njournal->j_last_commit_id = jl->j_trans_id;\r\ncleanup_freed_for_journal_list(s, jl);\r\nretval = retval ? retval : journal->j_errno;\r\nif (!retval)\r\ndirty_one_transaction(s, jl);\r\natomic_dec(&jl->j_commit_left);\r\nif (flushall) {\r\natomic_set(&jl->j_older_commits_done, 1);\r\n}\r\nmutex_unlock(&jl->j_commit_mutex);\r\nput_jl:\r\nput_journal_list(s, jl);\r\nif (retval)\r\nreiserfs_abort(s, retval, "Journal write error in %s",\r\n__func__);\r\nreturn retval;\r\n}\r\nstatic struct reiserfs_journal_list *find_newer_jl_for_cn(struct\r\nreiserfs_journal_cnode\r\n*cn)\r\n{\r\nstruct super_block *sb = cn->sb;\r\nb_blocknr_t blocknr = cn->blocknr;\r\ncn = cn->hprev;\r\nwhile (cn) {\r\nif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\r\nreturn cn->jlist;\r\n}\r\ncn = cn->hprev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void remove_all_from_journal_list(struct super_block *sb,\r\nstruct reiserfs_journal_list *jl,\r\nint debug)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_cnode *cn, *last;\r\ncn = jl->j_realblock;\r\nwhile (cn) {\r\nif (cn->blocknr != 0) {\r\nif (debug) {\r\nreiserfs_warning(sb, "reiserfs-2201",\r\n"block %u, bh is %d, state %ld",\r\ncn->blocknr, cn->bh ? 1 : 0,\r\ncn->state);\r\n}\r\ncn->state = 0;\r\nremove_journal_hash(sb, journal->j_list_hash_table,\r\njl, cn->blocknr, 1);\r\n}\r\nlast = cn;\r\ncn = cn->next;\r\nfree_cnode(sb, last);\r\n}\r\njl->j_realblock = NULL;\r\n}\r\nstatic int _update_journal_header_block(struct super_block *sb,\r\nunsigned long offset,\r\nunsigned int trans_id)\r\n{\r\nstruct reiserfs_journal_header *jh;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nint depth;\r\nif (reiserfs_is_journal_aborted(journal))\r\nreturn -EIO;\r\nif (trans_id >= journal->j_last_flush_trans_id) {\r\nif (buffer_locked((journal->j_header_bh))) {\r\ndepth = reiserfs_write_unlock_nested(sb);\r\n__wait_on_buffer(journal->j_header_bh);\r\nreiserfs_write_lock_nested(sb, depth);\r\nif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nreiserfs_warning(sb, "journal-699",\r\n"buffer write failed");\r\n#endif\r\nreturn -EIO;\r\n}\r\n}\r\njournal->j_last_flush_trans_id = trans_id;\r\njournal->j_first_unflushed_offset = offset;\r\njh = (struct reiserfs_journal_header *)(journal->j_header_bh->\r\nb_data);\r\njh->j_last_flush_trans_id = cpu_to_le32(trans_id);\r\njh->j_first_unflushed_offset = cpu_to_le32(offset);\r\njh->j_mount_id = cpu_to_le32(journal->j_mount_id);\r\nset_buffer_dirty(journal->j_header_bh);\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nif (reiserfs_barrier_flush(sb))\r\n__sync_dirty_buffer(journal->j_header_bh,\r\nREQ_PREFLUSH | REQ_FUA);\r\nelse\r\nsync_dirty_buffer(journal->j_header_bh);\r\nreiserfs_write_lock_nested(sb, depth);\r\nif (!buffer_uptodate(journal->j_header_bh)) {\r\nreiserfs_warning(sb, "journal-837",\r\n"IO error during journal replay");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int update_journal_header_block(struct super_block *sb,\r\nunsigned long offset,\r\nunsigned int trans_id)\r\n{\r\nreturn _update_journal_header_block(sb, offset, trans_id);\r\n}\r\nstatic int flush_older_journal_lists(struct super_block *sb,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct list_head *entry;\r\nstruct reiserfs_journal_list *other_jl;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nunsigned int trans_id = jl->j_trans_id;\r\nrestart:\r\nentry = journal->j_journal_list.next;\r\nif (entry == &journal->j_journal_list)\r\nreturn 0;\r\nother_jl = JOURNAL_LIST_ENTRY(entry);\r\nif (other_jl->j_trans_id < trans_id) {\r\nBUG_ON(other_jl->j_refcount <= 0);\r\nflush_journal_list(sb, other_jl, 0);\r\ngoto restart;\r\n}\r\nreturn 0;\r\n}\r\nstatic void del_from_work_list(struct super_block *s,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nif (!list_empty(&jl->j_working_list)) {\r\nlist_del_init(&jl->j_working_list);\r\njournal->j_num_work_lists--;\r\n}\r\n}\r\nstatic int flush_journal_list(struct super_block *s,\r\nstruct reiserfs_journal_list *jl, int flushall)\r\n{\r\nstruct reiserfs_journal_list *pjl;\r\nstruct reiserfs_journal_cnode *cn, *last;\r\nint count;\r\nint was_jwait = 0;\r\nint was_dirty = 0;\r\nstruct buffer_head *saved_bh;\r\nunsigned long j_len_saved = jl->j_len;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nint err = 0;\r\nint depth;\r\nBUG_ON(j_len_saved <= 0);\r\nif (atomic_read(&journal->j_wcount) != 0) {\r\nreiserfs_warning(s, "clm-2048", "called with wcount %d",\r\natomic_read(&journal->j_wcount));\r\n}\r\nif (flushall) {\r\nreiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\r\n} else if (mutex_trylock(&journal->j_flush_mutex)) {\r\nBUG();\r\n}\r\ncount = 0;\r\nif (j_len_saved > journal->j_trans_max) {\r\nreiserfs_panic(s, "journal-715", "length is %lu, trans id %lu",\r\nj_len_saved, jl->j_trans_id);\r\nreturn 0;\r\n}\r\nif (atomic_read(&jl->j_nonzerolen) <= 0 &&\r\natomic_read(&jl->j_commit_left) <= 0) {\r\ngoto flush_older_and_return;\r\n}\r\nflush_commit_list(s, jl, 1);\r\nif (!(jl->j_state & LIST_DIRTY)\r\n&& !reiserfs_is_journal_aborted(journal))\r\nBUG();\r\nif (atomic_read(&jl->j_nonzerolen) <= 0 &&\r\natomic_read(&jl->j_commit_left) <= 0) {\r\ngoto flush_older_and_return;\r\n}\r\nif (atomic_read(&journal->j_wcount) != 0) {\r\nreiserfs_panic(s, "journal-844", "journal list is flushing, "\r\n"wcount is not 0");\r\n}\r\ncn = jl->j_realblock;\r\nwhile (cn) {\r\nwas_jwait = 0;\r\nwas_dirty = 0;\r\nsaved_bh = NULL;\r\nif (cn->blocknr == 0) {\r\ngoto free_cnode;\r\n}\r\nif (!(jl->j_state & LIST_DIRTY))\r\ngoto free_cnode;\r\npjl = find_newer_jl_for_cn(cn);\r\nif (!pjl && cn->bh) {\r\nsaved_bh = cn->bh;\r\nget_bh(saved_bh);\r\nif (buffer_journal_dirty(saved_bh)) {\r\nBUG_ON(!can_dirty(cn));\r\nwas_jwait = 1;\r\nwas_dirty = 1;\r\n} else if (can_dirty(cn)) {\r\nBUG();\r\n}\r\n}\r\nif (pjl) {\r\nif (atomic_read(&pjl->j_commit_left))\r\nflush_commit_list(s, pjl, 1);\r\ngoto free_cnode;\r\n}\r\nif (saved_bh == NULL) {\r\ngoto free_cnode;\r\n}\r\nif ((!was_jwait) && !buffer_locked(saved_bh)) {\r\nreiserfs_warning(s, "journal-813",\r\n"BAD! buffer %llu %cdirty %cjwait, "\r\n"not in a newer tranasction",\r\n(unsigned long long)saved_bh->\r\nb_blocknr, was_dirty ? ' ' : '!',\r\nwas_jwait ? ' ' : '!');\r\n}\r\nif (was_dirty) {\r\nget_bh(saved_bh);\r\nset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\r\nlock_buffer(saved_bh);\r\nBUG_ON(cn->blocknr != saved_bh->b_blocknr);\r\nif (buffer_dirty(saved_bh))\r\nsubmit_logged_buffer(saved_bh);\r\nelse\r\nunlock_buffer(saved_bh);\r\ncount++;\r\n} else {\r\nreiserfs_warning(s, "clm-2082",\r\n"Unable to flush buffer %llu in %s",\r\n(unsigned long long)saved_bh->\r\nb_blocknr, __func__);\r\n}\r\nfree_cnode:\r\nlast = cn;\r\ncn = cn->next;\r\nif (saved_bh) {\r\nput_bh(saved_bh);\r\nif (atomic_read(&saved_bh->b_count) < 0) {\r\nreiserfs_warning(s, "journal-945",\r\n"saved_bh->b_count < 0");\r\n}\r\n}\r\n}\r\nif (count > 0) {\r\ncn = jl->j_realblock;\r\nwhile (cn) {\r\nif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\r\nif (!cn->bh) {\r\nreiserfs_panic(s, "journal-1011",\r\n"cn->bh is NULL");\r\n}\r\ndepth = reiserfs_write_unlock_nested(s);\r\n__wait_on_buffer(cn->bh);\r\nreiserfs_write_lock_nested(s, depth);\r\nif (!cn->bh) {\r\nreiserfs_panic(s, "journal-1012",\r\n"cn->bh is NULL");\r\n}\r\nif (unlikely(!buffer_uptodate(cn->bh))) {\r\n#ifdef CONFIG_REISERFS_CHECK\r\nreiserfs_warning(s, "journal-949",\r\n"buffer write failed");\r\n#endif\r\nerr = -EIO;\r\n}\r\nBUG_ON(!test_clear_buffer_journal_dirty\r\n(cn->bh));\r\nput_bh(cn->bh);\r\nrelease_buffer_page(cn->bh);\r\n}\r\ncn = cn->next;\r\n}\r\n}\r\nif (err)\r\nreiserfs_abort(s, -EIO,\r\n"Write error while pushing transaction to disk in %s",\r\n__func__);\r\nflush_older_and_return:\r\nif (flushall) {\r\nflush_older_journal_lists(s, jl);\r\n}\r\nerr = journal->j_errno;\r\nif (!err && flushall) {\r\nerr =\r\nupdate_journal_header_block(s,\r\n(jl->j_start + jl->j_len +\r\n2) % SB_ONDISK_JOURNAL_SIZE(s),\r\njl->j_trans_id);\r\nif (err)\r\nreiserfs_abort(s, -EIO,\r\n"Write error while updating journal header in %s",\r\n__func__);\r\n}\r\nremove_all_from_journal_list(s, jl, 0);\r\nlist_del_init(&jl->j_list);\r\njournal->j_num_lists--;\r\ndel_from_work_list(s, jl);\r\nif (journal->j_last_flush_id != 0 &&\r\n(jl->j_trans_id - journal->j_last_flush_id) != 1) {\r\nreiserfs_warning(s, "clm-2201", "last flush %lu, current %lu",\r\njournal->j_last_flush_id, jl->j_trans_id);\r\n}\r\njournal->j_last_flush_id = jl->j_trans_id;\r\njl->j_len = 0;\r\natomic_set(&jl->j_nonzerolen, 0);\r\njl->j_start = 0;\r\njl->j_realblock = NULL;\r\njl->j_commit_bh = NULL;\r\njl->j_trans_id = 0;\r\njl->j_state = 0;\r\nput_journal_list(s, jl);\r\nif (flushall)\r\nmutex_unlock(&journal->j_flush_mutex);\r\nreturn err;\r\n}\r\nstatic int write_one_transaction(struct super_block *s,\r\nstruct reiserfs_journal_list *jl,\r\nstruct buffer_chunk *chunk)\r\n{\r\nstruct reiserfs_journal_cnode *cn;\r\nint ret = 0;\r\njl->j_state |= LIST_TOUCHED;\r\ndel_from_work_list(s, jl);\r\nif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\r\nreturn 0;\r\n}\r\ncn = jl->j_realblock;\r\nwhile (cn) {\r\nif (cn->blocknr == 0) {\r\ngoto next;\r\n}\r\nif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\r\nstruct buffer_head *tmp_bh;\r\ntmp_bh = cn->bh;\r\nget_bh(tmp_bh);\r\nlock_buffer(tmp_bh);\r\nif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\r\nif (!buffer_journal_dirty(tmp_bh) ||\r\nbuffer_journal_prepared(tmp_bh))\r\nBUG();\r\nadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\r\nret++;\r\n} else {\r\nunlock_buffer(tmp_bh);\r\n}\r\nput_bh(tmp_bh);\r\n}\r\nnext:\r\ncn = cn->next;\r\ncond_resched();\r\n}\r\nreturn ret;\r\n}\r\nstatic int dirty_one_transaction(struct super_block *s,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct reiserfs_journal_cnode *cn;\r\nstruct reiserfs_journal_list *pjl;\r\nint ret = 0;\r\njl->j_state |= LIST_DIRTY;\r\ncn = jl->j_realblock;\r\nwhile (cn) {\r\npjl = find_newer_jl_for_cn(cn);\r\nif (!pjl && cn->blocknr && cn->bh\r\n&& buffer_journal_dirty(cn->bh)) {\r\nBUG_ON(!can_dirty(cn));\r\nclear_buffer_journal_new(cn->bh);\r\nif (buffer_journal_prepared(cn->bh)) {\r\nset_buffer_journal_restore_dirty(cn->bh);\r\n} else {\r\nset_buffer_journal_test(cn->bh);\r\nmark_buffer_dirty(cn->bh);\r\n}\r\n}\r\ncn = cn->next;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kupdate_transactions(struct super_block *s,\r\nstruct reiserfs_journal_list *jl,\r\nstruct reiserfs_journal_list **next_jl,\r\nunsigned int *next_trans_id,\r\nint num_blocks, int num_trans)\r\n{\r\nint ret = 0;\r\nint written = 0;\r\nint transactions_flushed = 0;\r\nunsigned int orig_trans_id = jl->j_trans_id;\r\nstruct buffer_chunk chunk;\r\nstruct list_head *entry;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nchunk.nr = 0;\r\nreiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\r\nif (!journal_list_still_alive(s, orig_trans_id)) {\r\ngoto done;\r\n}\r\nwhile ((num_trans && transactions_flushed < num_trans) ||\r\n(!num_trans && written < num_blocks)) {\r\nif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\r\natomic_read(&jl->j_commit_left)\r\n|| !(jl->j_state & LIST_DIRTY)) {\r\ndel_from_work_list(s, jl);\r\nbreak;\r\n}\r\nret = write_one_transaction(s, jl, &chunk);\r\nif (ret < 0)\r\ngoto done;\r\ntransactions_flushed++;\r\nwritten += ret;\r\nentry = jl->j_list.next;\r\nif (entry == &journal->j_journal_list) {\r\nbreak;\r\n}\r\njl = JOURNAL_LIST_ENTRY(entry);\r\nif (jl->j_trans_id <= orig_trans_id)\r\nbreak;\r\n}\r\nif (chunk.nr) {\r\nwrite_chunk(&chunk);\r\n}\r\ndone:\r\nmutex_unlock(&journal->j_flush_mutex);\r\nreturn ret;\r\n}\r\nstatic int flush_used_journal_lists(struct super_block *s,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nunsigned long len = 0;\r\nunsigned long cur_len;\r\nint ret;\r\nint i;\r\nint limit = 256;\r\nstruct reiserfs_journal_list *tjl;\r\nstruct reiserfs_journal_list *flush_jl;\r\nunsigned int trans_id;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nflush_jl = tjl = jl;\r\nif (reiserfs_data_log(s))\r\nlimit = 1024;\r\nfor (i = 0; i < 256 && len < limit; i++) {\r\nif (atomic_read(&tjl->j_commit_left) ||\r\ntjl->j_trans_id < jl->j_trans_id) {\r\nbreak;\r\n}\r\ncur_len = atomic_read(&tjl->j_nonzerolen);\r\nif (cur_len > 0) {\r\ntjl->j_state &= ~LIST_TOUCHED;\r\n}\r\nlen += cur_len;\r\nflush_jl = tjl;\r\nif (tjl->j_list.next == &journal->j_journal_list)\r\nbreak;\r\ntjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\r\n}\r\nget_journal_list(jl);\r\nget_journal_list(flush_jl);\r\nif (flush_jl != jl) {\r\nret = kupdate_transactions(s, jl, &tjl, &trans_id, len, i);\r\n}\r\nflush_journal_list(s, flush_jl, 1);\r\nput_journal_list(s, flush_jl);\r\nput_journal_list(s, jl);\r\nreturn 0;\r\n}\r\nvoid remove_journal_hash(struct super_block *sb,\r\nstruct reiserfs_journal_cnode **table,\r\nstruct reiserfs_journal_list *jl,\r\nunsigned long block, int remove_freed)\r\n{\r\nstruct reiserfs_journal_cnode *cur;\r\nstruct reiserfs_journal_cnode **head;\r\nhead = &(journal_hash(table, sb, block));\r\nif (!head) {\r\nreturn;\r\n}\r\ncur = *head;\r\nwhile (cur) {\r\nif (cur->blocknr == block && cur->sb == sb\r\n&& (jl == NULL || jl == cur->jlist)\r\n&& (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\r\nif (cur->hnext) {\r\ncur->hnext->hprev = cur->hprev;\r\n}\r\nif (cur->hprev) {\r\ncur->hprev->hnext = cur->hnext;\r\n} else {\r\n*head = cur->hnext;\r\n}\r\ncur->blocknr = 0;\r\ncur->sb = NULL;\r\ncur->state = 0;\r\nif (cur->bh && cur->jlist)\r\natomic_dec(&cur->jlist->j_nonzerolen);\r\ncur->bh = NULL;\r\ncur->jlist = NULL;\r\n}\r\ncur = cur->hnext;\r\n}\r\n}\r\nstatic void free_journal_ram(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nkfree(journal->j_current_jl);\r\njournal->j_num_lists--;\r\nvfree(journal->j_cnode_free_orig);\r\nfree_list_bitmaps(sb, journal->j_list_bitmap);\r\nfree_bitmap_nodes(sb);\r\nif (journal->j_header_bh) {\r\nbrelse(journal->j_header_bh);\r\n}\r\nrelease_journal_dev(sb, journal);\r\nvfree(journal);\r\n}\r\nstatic int do_journal_release(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb, int error)\r\n{\r\nstruct reiserfs_transaction_handle myth;\r\nint flushed = 0;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nif (!error && !(sb->s_flags & MS_RDONLY)) {\r\nBUG_ON(!th->t_trans_id);\r\ndo_journal_end(th, FLUSH_ALL);\r\nif (!journal_join(&myth, sb)) {\r\nreiserfs_prepare_for_journal(sb,\r\nSB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\r\ndo_journal_end(&myth, FLUSH_ALL);\r\nflushed = 1;\r\n}\r\n}\r\nif (!error && reiserfs_is_journal_aborted(journal)) {\r\nmemset(&myth, 0, sizeof(myth));\r\nif (!journal_join_abort(&myth, sb)) {\r\nreiserfs_prepare_for_journal(sb,\r\nSB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\r\ndo_journal_end(&myth, FLUSH_ALL);\r\n}\r\n}\r\nreiserfs_write_unlock(sb);\r\ncancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\r\ncancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\r\nfree_journal_ram(sb);\r\nreiserfs_write_lock(sb);\r\nreturn 0;\r\n}\r\nint journal_release(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb)\r\n{\r\nreturn do_journal_release(th, sb, 0);\r\n}\r\nint journal_release_error(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb)\r\n{\r\nreturn do_journal_release(th, sb, 1);\r\n}\r\nstatic int journal_compare_desc_commit(struct super_block *sb,\r\nstruct reiserfs_journal_desc *desc,\r\nstruct reiserfs_journal_commit *commit)\r\n{\r\nif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\r\nget_commit_trans_len(commit) != get_desc_trans_len(desc) ||\r\nget_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\r\nget_commit_trans_len(commit) <= 0) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int journal_transaction_is_valid(struct super_block *sb,\r\nstruct buffer_head *d_bh,\r\nunsigned int *oldest_invalid_trans_id,\r\nunsigned long *newest_mount_id)\r\n{\r\nstruct reiserfs_journal_desc *desc;\r\nstruct reiserfs_journal_commit *commit;\r\nstruct buffer_head *c_bh;\r\nunsigned long offset;\r\nif (!d_bh)\r\nreturn 0;\r\ndesc = (struct reiserfs_journal_desc *)d_bh->b_data;\r\nif (get_desc_trans_len(desc) > 0\r\n&& !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\r\nif (oldest_invalid_trans_id && *oldest_invalid_trans_id\r\n&& get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-986: transaction "\r\n"is valid returning because trans_id %d is greater than "\r\n"oldest_invalid %lu",\r\nget_desc_trans_id(desc),\r\n*oldest_invalid_trans_id);\r\nreturn 0;\r\n}\r\nif (newest_mount_id\r\n&& *newest_mount_id > get_desc_mount_id(desc)) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1087: transaction "\r\n"is valid returning because mount_id %d is less than "\r\n"newest_mount_id %lu",\r\nget_desc_mount_id(desc),\r\n*newest_mount_id);\r\nreturn -1;\r\n}\r\nif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\r\nreiserfs_warning(sb, "journal-2018",\r\n"Bad transaction length %d "\r\n"encountered, ignoring transaction",\r\nget_desc_trans_len(desc));\r\nreturn -1;\r\n}\r\noffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\r\nc_bh =\r\njournal_bread(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n((offset + get_desc_trans_len(desc) +\r\n1) % SB_ONDISK_JOURNAL_SIZE(sb)));\r\nif (!c_bh)\r\nreturn 0;\r\ncommit = (struct reiserfs_journal_commit *)c_bh->b_data;\r\nif (journal_compare_desc_commit(sb, desc, commit)) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal_transaction_is_valid, commit offset %ld had bad "\r\n"time %d or length %d",\r\nc_bh->b_blocknr -\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\nget_commit_trans_id(commit),\r\nget_commit_trans_len(commit));\r\nbrelse(c_bh);\r\nif (oldest_invalid_trans_id) {\r\n*oldest_invalid_trans_id =\r\nget_desc_trans_id(desc);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1004: "\r\n"transaction_is_valid setting oldest invalid trans_id "\r\n"to %d",\r\nget_desc_trans_id(desc));\r\n}\r\nreturn -1;\r\n}\r\nbrelse(c_bh);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1006: found valid "\r\n"transaction start offset %llu, len %d id %d",\r\nd_bh->b_blocknr -\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\nget_desc_trans_len(desc),\r\nget_desc_trans_id(desc));\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void brelse_array(struct buffer_head **heads, int num)\r\n{\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nbrelse(heads[i]);\r\n}\r\n}\r\nstatic int journal_read_transaction(struct super_block *sb,\r\nunsigned long cur_dblock,\r\nunsigned long oldest_start,\r\nunsigned int oldest_trans_id,\r\nunsigned long newest_mount_id)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_desc *desc;\r\nstruct reiserfs_journal_commit *commit;\r\nunsigned int trans_id = 0;\r\nstruct buffer_head *c_bh;\r\nstruct buffer_head *d_bh;\r\nstruct buffer_head **log_blocks = NULL;\r\nstruct buffer_head **real_blocks = NULL;\r\nunsigned int trans_offset;\r\nint i;\r\nint trans_half;\r\nd_bh = journal_bread(sb, cur_dblock);\r\nif (!d_bh)\r\nreturn 1;\r\ndesc = (struct reiserfs_journal_desc *)d_bh->b_data;\r\ntrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE, "journal-1037: "\r\n"journal_read_transaction, offset %llu, len %d mount_id %d",\r\nd_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\nget_desc_trans_len(desc), get_desc_mount_id(desc));\r\nif (get_desc_trans_id(desc) < oldest_trans_id) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE, "journal-1039: "\r\n"journal_read_trans skipping because %lu is too old",\r\ncur_dblock -\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb));\r\nbrelse(d_bh);\r\nreturn 1;\r\n}\r\nif (get_desc_mount_id(desc) != newest_mount_id) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE, "journal-1146: "\r\n"journal_read_trans skipping because %d is != "\r\n"newest_mount_id %lu", get_desc_mount_id(desc),\r\nnewest_mount_id);\r\nbrelse(d_bh);\r\nreturn 1;\r\n}\r\nc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n((trans_offset + get_desc_trans_len(desc) + 1) %\r\nSB_ONDISK_JOURNAL_SIZE(sb)));\r\nif (!c_bh) {\r\nbrelse(d_bh);\r\nreturn 1;\r\n}\r\ncommit = (struct reiserfs_journal_commit *)c_bh->b_data;\r\nif (journal_compare_desc_commit(sb, desc, commit)) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal_read_transaction, "\r\n"commit offset %llu had bad time %d or length %d",\r\nc_bh->b_blocknr -\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\nget_commit_trans_id(commit),\r\nget_commit_trans_len(commit));\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nreturn 1;\r\n}\r\nif (bdev_read_only(sb->s_bdev)) {\r\nreiserfs_warning(sb, "clm-2076",\r\n"device is readonly, unable to replay log");\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nreturn -EROFS;\r\n}\r\ntrans_id = get_desc_trans_id(desc);\r\nlog_blocks = kmalloc(get_desc_trans_len(desc) *\r\nsizeof(struct buffer_head *), GFP_NOFS);\r\nreal_blocks = kmalloc(get_desc_trans_len(desc) *\r\nsizeof(struct buffer_head *), GFP_NOFS);\r\nif (!log_blocks || !real_blocks) {\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nkfree(log_blocks);\r\nkfree(real_blocks);\r\nreiserfs_warning(sb, "journal-1169",\r\n"kmalloc failed, unable to mount FS");\r\nreturn -1;\r\n}\r\ntrans_half = journal_trans_half(sb->s_blocksize);\r\nfor (i = 0; i < get_desc_trans_len(desc); i++) {\r\nlog_blocks[i] =\r\njournal_getblk(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n(trans_offset + 1 +\r\ni) % SB_ONDISK_JOURNAL_SIZE(sb));\r\nif (i < trans_half) {\r\nreal_blocks[i] =\r\nsb_getblk(sb,\r\nle32_to_cpu(desc->j_realblock[i]));\r\n} else {\r\nreal_blocks[i] =\r\nsb_getblk(sb,\r\nle32_to_cpu(commit->\r\nj_realblock[i - trans_half]));\r\n}\r\nif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\r\nreiserfs_warning(sb, "journal-1207",\r\n"REPLAY FAILURE fsck required! "\r\n"Block to replay is outside of "\r\n"filesystem");\r\ngoto abort_replay;\r\n}\r\nif (is_block_in_log_or_reserved_area\r\n(sb, real_blocks[i]->b_blocknr)) {\r\nreiserfs_warning(sb, "journal-1204",\r\n"REPLAY FAILURE fsck required! "\r\n"Trying to replay onto a log block");\r\nabort_replay:\r\nbrelse_array(log_blocks, i);\r\nbrelse_array(real_blocks, i);\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nkfree(log_blocks);\r\nkfree(real_blocks);\r\nreturn -1;\r\n}\r\n}\r\nll_rw_block(REQ_OP_READ, 0, get_desc_trans_len(desc), log_blocks);\r\nfor (i = 0; i < get_desc_trans_len(desc); i++) {\r\nwait_on_buffer(log_blocks[i]);\r\nif (!buffer_uptodate(log_blocks[i])) {\r\nreiserfs_warning(sb, "journal-1212",\r\n"REPLAY FAILURE fsck required! "\r\n"buffer write failed");\r\nbrelse_array(log_blocks + i,\r\nget_desc_trans_len(desc) - i);\r\nbrelse_array(real_blocks, get_desc_trans_len(desc));\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nkfree(log_blocks);\r\nkfree(real_blocks);\r\nreturn -1;\r\n}\r\nmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\r\nreal_blocks[i]->b_size);\r\nset_buffer_uptodate(real_blocks[i]);\r\nbrelse(log_blocks[i]);\r\n}\r\nfor (i = 0; i < get_desc_trans_len(desc); i++) {\r\nset_buffer_dirty(real_blocks[i]);\r\nwrite_dirty_buffer(real_blocks[i], 0);\r\n}\r\nfor (i = 0; i < get_desc_trans_len(desc); i++) {\r\nwait_on_buffer(real_blocks[i]);\r\nif (!buffer_uptodate(real_blocks[i])) {\r\nreiserfs_warning(sb, "journal-1226",\r\n"REPLAY FAILURE, fsck required! "\r\n"buffer write failed");\r\nbrelse_array(real_blocks + i,\r\nget_desc_trans_len(desc) - i);\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nkfree(log_blocks);\r\nkfree(real_blocks);\r\nreturn -1;\r\n}\r\nbrelse(real_blocks[i]);\r\n}\r\ncur_dblock =\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n((trans_offset + get_desc_trans_len(desc) +\r\n2) % SB_ONDISK_JOURNAL_SIZE(sb));\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1095: setting journal " "start to offset %ld",\r\ncur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\r\njournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\r\njournal->j_last_flush_trans_id = trans_id;\r\njournal->j_trans_id = trans_id + 1;\r\nif (journal->j_trans_id == 0)\r\njournal->j_trans_id = 10;\r\nbrelse(c_bh);\r\nbrelse(d_bh);\r\nkfree(log_blocks);\r\nkfree(real_blocks);\r\nreturn 0;\r\n}\r\nstatic struct buffer_head *reiserfs_breada(struct block_device *dev,\r\nb_blocknr_t block, int bufsize,\r\nb_blocknr_t max_block)\r\n{\r\nstruct buffer_head *bhlist[BUFNR];\r\nunsigned int blocks = BUFNR;\r\nstruct buffer_head *bh;\r\nint i, j;\r\nbh = __getblk(dev, block, bufsize);\r\nif (buffer_uptodate(bh))\r\nreturn (bh);\r\nif (block + BUFNR > max_block) {\r\nblocks = max_block - block;\r\n}\r\nbhlist[0] = bh;\r\nj = 1;\r\nfor (i = 1; i < blocks; i++) {\r\nbh = __getblk(dev, block + i, bufsize);\r\nif (buffer_uptodate(bh)) {\r\nbrelse(bh);\r\nbreak;\r\n} else\r\nbhlist[j++] = bh;\r\n}\r\nll_rw_block(REQ_OP_READ, 0, j, bhlist);\r\nfor (i = 1; i < j; i++)\r\nbrelse(bhlist[i]);\r\nbh = bhlist[0];\r\nwait_on_buffer(bh);\r\nif (buffer_uptodate(bh))\r\nreturn bh;\r\nbrelse(bh);\r\nreturn NULL;\r\n}\r\nstatic int journal_read(struct super_block *sb)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_desc *desc;\r\nunsigned int oldest_trans_id = 0;\r\nunsigned int oldest_invalid_trans_id = 0;\r\ntime_t start;\r\nunsigned long oldest_start = 0;\r\nunsigned long cur_dblock = 0;\r\nunsigned long newest_mount_id = 9;\r\nstruct buffer_head *d_bh;\r\nstruct reiserfs_journal_header *jh;\r\nint valid_journal_header = 0;\r\nint replay_count = 0;\r\nint continue_replay = 1;\r\nint ret;\r\ncur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\r\nreiserfs_info(sb, "checking transaction log (%pg)\n",\r\njournal->j_dev_bd);\r\nstart = get_seconds();\r\njournal->j_header_bh = journal_bread(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb)\r\n+ SB_ONDISK_JOURNAL_SIZE(sb));\r\nif (!journal->j_header_bh) {\r\nreturn 1;\r\n}\r\njh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\r\nif (le32_to_cpu(jh->j_first_unflushed_offset) <\r\nSB_ONDISK_JOURNAL_SIZE(sb)\r\n&& le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\r\noldest_start =\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\nle32_to_cpu(jh->j_first_unflushed_offset);\r\noldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\r\nnewest_mount_id = le32_to_cpu(jh->j_mount_id);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1153: found in "\r\n"header: first_unflushed_offset %d, last_flushed_trans_id "\r\n"%lu", le32_to_cpu(jh->j_first_unflushed_offset),\r\nle32_to_cpu(jh->j_last_flush_trans_id));\r\nvalid_journal_header = 1;\r\nd_bh =\r\njournal_bread(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\nle32_to_cpu(jh->j_first_unflushed_offset));\r\nret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\r\nif (!ret) {\r\ncontinue_replay = 0;\r\n}\r\nbrelse(d_bh);\r\ngoto start_log_replay;\r\n}\r\nwhile (continue_replay\r\n&& cur_dblock <\r\n(SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\nSB_ONDISK_JOURNAL_SIZE(sb))) {\r\nd_bh =\r\nreiserfs_breada(journal->j_dev_bd, cur_dblock,\r\nsb->s_blocksize,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\nSB_ONDISK_JOURNAL_SIZE(sb));\r\nret =\r\njournal_transaction_is_valid(sb, d_bh,\r\n&oldest_invalid_trans_id,\r\n&newest_mount_id);\r\nif (ret == 1) {\r\ndesc = (struct reiserfs_journal_desc *)d_bh->b_data;\r\nif (oldest_start == 0) {\r\noldest_trans_id = get_desc_trans_id(desc);\r\noldest_start = d_bh->b_blocknr;\r\nnewest_mount_id = get_desc_mount_id(desc);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1179: Setting "\r\n"oldest_start to offset %llu, trans_id %lu",\r\noldest_start -\r\nSB_ONDISK_JOURNAL_1st_BLOCK\r\n(sb), oldest_trans_id);\r\n} else if (oldest_trans_id > get_desc_trans_id(desc)) {\r\noldest_trans_id = get_desc_trans_id(desc);\r\noldest_start = d_bh->b_blocknr;\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1180: Resetting "\r\n"oldest_start to offset %lu, trans_id %lu",\r\noldest_start -\r\nSB_ONDISK_JOURNAL_1st_BLOCK\r\n(sb), oldest_trans_id);\r\n}\r\nif (newest_mount_id < get_desc_mount_id(desc)) {\r\nnewest_mount_id = get_desc_mount_id(desc);\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1299: Setting "\r\n"newest_mount_id to %d",\r\nget_desc_mount_id(desc));\r\n}\r\ncur_dblock += get_desc_trans_len(desc) + 2;\r\n} else {\r\ncur_dblock++;\r\n}\r\nbrelse(d_bh);\r\n}\r\nstart_log_replay:\r\ncur_dblock = oldest_start;\r\nif (oldest_trans_id) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1206: Starting replay "\r\n"from offset %llu, trans_id %lu",\r\ncur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\noldest_trans_id);\r\n}\r\nreplay_count = 0;\r\nwhile (continue_replay && oldest_trans_id > 0) {\r\nret =\r\njournal_read_transaction(sb, cur_dblock, oldest_start,\r\noldest_trans_id, newest_mount_id);\r\nif (ret < 0) {\r\nreturn ret;\r\n} else if (ret != 0) {\r\nbreak;\r\n}\r\ncur_dblock =\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\r\nreplay_count++;\r\nif (cur_dblock == oldest_start)\r\nbreak;\r\n}\r\nif (oldest_trans_id == 0) {\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE,\r\n"journal-1225: No valid " "transactions found");\r\n}\r\nif (valid_journal_header && replay_count == 0) {\r\njournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\r\njournal->j_trans_id =\r\nle32_to_cpu(jh->j_last_flush_trans_id) + 1;\r\nif (journal->j_trans_id == 0)\r\njournal->j_trans_id = 10;\r\njournal->j_last_flush_trans_id =\r\nle32_to_cpu(jh->j_last_flush_trans_id);\r\njournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\r\n} else {\r\njournal->j_mount_id = newest_mount_id + 1;\r\n}\r\nreiserfs_debug(sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "\r\n"newest_mount_id to %lu", journal->j_mount_id);\r\njournal->j_first_unflushed_offset = journal->j_start;\r\nif (replay_count > 0) {\r\nreiserfs_info(sb,\r\n"replayed %d transactions in %lu seconds\n",\r\nreplay_count, get_seconds() - start);\r\n}\r\nreiserfs_write_lock(sb);\r\nif (!bdev_read_only(sb->s_bdev) &&\r\n_update_journal_header_block(sb, journal->j_start,\r\njournal->j_last_flush_trans_id)) {\r\nreiserfs_write_unlock(sb);\r\nreturn -1;\r\n}\r\nreiserfs_write_unlock(sb);\r\nreturn 0;\r\n}\r\nstatic struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\r\n{\r\nstruct reiserfs_journal_list *jl;\r\njl = kzalloc(sizeof(struct reiserfs_journal_list),\r\nGFP_NOFS | __GFP_NOFAIL);\r\nINIT_LIST_HEAD(&jl->j_list);\r\nINIT_LIST_HEAD(&jl->j_working_list);\r\nINIT_LIST_HEAD(&jl->j_tail_bh_list);\r\nINIT_LIST_HEAD(&jl->j_bh_list);\r\nmutex_init(&jl->j_commit_mutex);\r\nSB_JOURNAL(s)->j_num_lists++;\r\nget_journal_list(jl);\r\nreturn jl;\r\n}\r\nstatic void journal_list_init(struct super_block *sb)\r\n{\r\nSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\r\n}\r\nstatic void release_journal_dev(struct super_block *super,\r\nstruct reiserfs_journal *journal)\r\n{\r\nif (journal->j_dev_bd != NULL) {\r\nblkdev_put(journal->j_dev_bd, journal->j_dev_mode);\r\njournal->j_dev_bd = NULL;\r\n}\r\n}\r\nstatic int journal_init_dev(struct super_block *super,\r\nstruct reiserfs_journal *journal,\r\nconst char *jdev_name)\r\n{\r\nint result;\r\ndev_t jdev;\r\nfmode_t blkdev_mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\r\nchar b[BDEVNAME_SIZE];\r\nresult = 0;\r\njournal->j_dev_bd = NULL;\r\njdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\r\nnew_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\r\nif (bdev_read_only(super->s_bdev))\r\nblkdev_mode = FMODE_READ;\r\nif ((!jdev_name || !jdev_name[0])) {\r\nif (jdev == super->s_dev)\r\nblkdev_mode &= ~FMODE_EXCL;\r\njournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode,\r\njournal);\r\njournal->j_dev_mode = blkdev_mode;\r\nif (IS_ERR(journal->j_dev_bd)) {\r\nresult = PTR_ERR(journal->j_dev_bd);\r\njournal->j_dev_bd = NULL;\r\nreiserfs_warning(super, "sh-458",\r\n"cannot init journal device '%s': %i",\r\n__bdevname(jdev, b), result);\r\nreturn result;\r\n} else if (jdev != super->s_dev)\r\nset_blocksize(journal->j_dev_bd, super->s_blocksize);\r\nreturn 0;\r\n}\r\njournal->j_dev_mode = blkdev_mode;\r\njournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, journal);\r\nif (IS_ERR(journal->j_dev_bd)) {\r\nresult = PTR_ERR(journal->j_dev_bd);\r\njournal->j_dev_bd = NULL;\r\nreiserfs_warning(super,\r\n"journal_init_dev: Cannot open '%s': %i",\r\njdev_name, result);\r\nreturn result;\r\n}\r\nset_blocksize(journal->j_dev_bd, super->s_blocksize);\r\nreiserfs_info(super,\r\n"journal_init_dev: journal device: %pg\n",\r\njournal->j_dev_bd);\r\nreturn 0;\r\n}\r\nstatic int check_advise_trans_params(struct super_block *sb,\r\nstruct reiserfs_journal *journal)\r\n{\r\nif (journal->j_trans_max) {\r\nint ratio = 1;\r\nif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\r\nratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\r\nif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\r\njournal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\r\nSB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\r\nJOURNAL_MIN_RATIO) {\r\nreiserfs_warning(sb, "sh-462",\r\n"bad transaction max size (%u). "\r\n"FSCK?", journal->j_trans_max);\r\nreturn 1;\r\n}\r\nif (journal->j_max_batch != (journal->j_trans_max) *\r\nJOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\r\nreiserfs_warning(sb, "sh-463",\r\n"bad transaction max batch (%u). "\r\n"FSCK?", journal->j_max_batch);\r\nreturn 1;\r\n}\r\n} else {\r\nif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\r\nreiserfs_warning(sb, "sh-464", "bad blocksize (%u)",\r\nsb->s_blocksize);\r\nreturn 1;\r\n}\r\njournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\r\njournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\r\njournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\r\n}\r\nreturn 0;\r\n}\r\nint journal_init(struct super_block *sb, const char *j_dev_name,\r\nint old_format, unsigned int commit_max_age)\r\n{\r\nint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\r\nstruct buffer_head *bhjh;\r\nstruct reiserfs_super_block *rs;\r\nstruct reiserfs_journal_header *jh;\r\nstruct reiserfs_journal *journal;\r\nstruct reiserfs_journal_list *jl;\r\nint ret;\r\njournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\r\nif (!journal) {\r\nreiserfs_warning(sb, "journal-1256",\r\n"unable to get memory for journal structure");\r\nreturn 1;\r\n}\r\nINIT_LIST_HEAD(&journal->j_bitmap_nodes);\r\nINIT_LIST_HEAD(&journal->j_prealloc_list);\r\nINIT_LIST_HEAD(&journal->j_working_list);\r\nINIT_LIST_HEAD(&journal->j_journal_list);\r\njournal->j_persistent_trans = 0;\r\nif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\r\nreiserfs_bmap_count(sb)))\r\ngoto free_and_return;\r\nallocate_bitmap_nodes(sb);\r\nSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\r\nREISERFS_OLD_DISK_OFFSET_IN_BYTES\r\n/ sb->s_blocksize +\r\nreiserfs_bmap_count(sb) +\r\n1 :\r\nREISERFS_DISK_OFFSET_IN_BYTES /\r\nsb->s_blocksize + 2);\r\nif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\r\n(SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\r\nSB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\r\nreiserfs_warning(sb, "journal-1393",\r\n"journal does not fit for area addressed "\r\n"by first of bitmap blocks. It starts at "\r\n"%u and its size is %u. Block size %ld",\r\nSB_JOURNAL_1st_RESERVED_BLOCK(sb),\r\nSB_ONDISK_JOURNAL_SIZE(sb),\r\nsb->s_blocksize);\r\ngoto free_and_return;\r\n}\r\nif (journal_init_dev(sb, journal, j_dev_name) != 0) {\r\nreiserfs_warning(sb, "sh-462",\r\n"unable to initialize journal device");\r\ngoto free_and_return;\r\n}\r\nrs = SB_DISK_SUPER_BLOCK(sb);\r\nbhjh = journal_bread(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\nSB_ONDISK_JOURNAL_SIZE(sb));\r\nif (!bhjh) {\r\nreiserfs_warning(sb, "sh-459",\r\n"unable to read journal header");\r\ngoto free_and_return;\r\n}\r\njh = (struct reiserfs_journal_header *)(bhjh->b_data);\r\nif (is_reiserfs_jr(rs)\r\n&& (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\r\nsb_jp_journal_magic(rs))) {\r\nreiserfs_warning(sb, "sh-460",\r\n"journal header magic %x (device %pg) does "\r\n"not match to magic found in super block %x",\r\njh->jh_journal.jp_journal_magic,\r\njournal->j_dev_bd,\r\nsb_jp_journal_magic(rs));\r\nbrelse(bhjh);\r\ngoto free_and_return;\r\n}\r\njournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\r\njournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\r\njournal->j_max_commit_age =\r\nle32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\r\njournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\r\nif (check_advise_trans_params(sb, journal) != 0)\r\ngoto free_and_return;\r\njournal->j_default_max_commit_age = journal->j_max_commit_age;\r\nif (commit_max_age != 0) {\r\njournal->j_max_commit_age = commit_max_age;\r\njournal->j_max_trans_age = commit_max_age;\r\n}\r\nreiserfs_info(sb, "journal params: device %pg, size %u, "\r\n"journal first block %u, max trans len %u, max batch %u, "\r\n"max commit age %u, max trans age %u\n",\r\njournal->j_dev_bd,\r\nSB_ONDISK_JOURNAL_SIZE(sb),\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb),\r\njournal->j_trans_max,\r\njournal->j_max_batch,\r\njournal->j_max_commit_age, journal->j_max_trans_age);\r\nbrelse(bhjh);\r\njournal->j_list_bitmap_index = 0;\r\njournal_list_init(sb);\r\nmemset(journal->j_list_hash_table, 0,\r\nJOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\r\nINIT_LIST_HEAD(&journal->j_dirty_buffers);\r\nspin_lock_init(&journal->j_dirty_buffers_lock);\r\njournal->j_start = 0;\r\njournal->j_len = 0;\r\njournal->j_len_alloc = 0;\r\natomic_set(&journal->j_wcount, 0);\r\natomic_set(&journal->j_async_throttle, 0);\r\njournal->j_bcount = 0;\r\njournal->j_trans_start_time = 0;\r\njournal->j_last = NULL;\r\njournal->j_first = NULL;\r\ninit_waitqueue_head(&journal->j_join_wait);\r\nmutex_init(&journal->j_mutex);\r\nmutex_init(&journal->j_flush_mutex);\r\njournal->j_trans_id = 10;\r\njournal->j_mount_id = 10;\r\njournal->j_state = 0;\r\natomic_set(&journal->j_jlock, 0);\r\njournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\r\njournal->j_cnode_free_orig = journal->j_cnode_free_list;\r\njournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\r\njournal->j_cnode_used = 0;\r\njournal->j_must_wait = 0;\r\nif (journal->j_cnode_free == 0) {\r\nreiserfs_warning(sb, "journal-2004", "Journal cnode memory "\r\n"allocation failed (%ld bytes). Journal is "\r\n"too large for available memory. Usually "\r\n"this is due to a journal that is too large.",\r\nsizeof (struct reiserfs_journal_cnode) * num_cnodes);\r\ngoto free_and_return;\r\n}\r\ninit_journal_hash(sb);\r\njl = journal->j_current_jl;\r\nreiserfs_write_lock(sb);\r\njl->j_list_bitmap = get_list_bitmap(sb, jl);\r\nreiserfs_write_unlock(sb);\r\nif (!jl->j_list_bitmap) {\r\nreiserfs_warning(sb, "journal-2005",\r\n"get_list_bitmap failed for journal list 0");\r\ngoto free_and_return;\r\n}\r\nret = journal_read(sb);\r\nif (ret < 0) {\r\nreiserfs_warning(sb, "reiserfs-2006",\r\n"Replay Failure, unable to mount");\r\ngoto free_and_return;\r\n}\r\nINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\r\njournal->j_work_sb = sb;\r\nreturn 0;\r\nfree_and_return:\r\nfree_journal_ram(sb);\r\nreturn 1;\r\n}\r\nint journal_transaction_should_end(struct reiserfs_transaction_handle *th,\r\nint new_alloc)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\r\ntime_t now = get_seconds();\r\nBUG_ON(!th->t_trans_id);\r\nif (th->t_refcount > 1)\r\nreturn 0;\r\nif (journal->j_must_wait > 0 ||\r\n(journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\r\natomic_read(&journal->j_jlock) ||\r\n(now - journal->j_trans_start_time) > journal->j_max_trans_age ||\r\njournal->j_cnode_free < (journal->j_trans_max * 3)) {\r\nreturn 1;\r\n}\r\njournal->j_len_alloc += new_alloc;\r\nth->t_blocks_allocated += new_alloc ;\r\nreturn 0;\r\n}\r\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\r\nBUG_ON(!th->t_trans_id);\r\njournal->j_must_wait = 1;\r\nset_bit(J_WRITERS_BLOCKED, &journal->j_state);\r\nreturn;\r\n}\r\nvoid reiserfs_allow_writes(struct super_block *s)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\r\nwake_up(&journal->j_join_wait);\r\n}\r\nvoid reiserfs_wait_on_write_block(struct super_block *s)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nwait_event(journal->j_join_wait,\r\n!test_bit(J_WRITERS_BLOCKED, &journal->j_state));\r\n}\r\nstatic void queue_log_writer(struct super_block *s)\r\n{\r\nwait_queue_t wait;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nset_bit(J_WRITERS_QUEUED, &journal->j_state);\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&journal->j_join_wait, &wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\r\nint depth = reiserfs_write_unlock_nested(s);\r\nschedule();\r\nreiserfs_write_lock_nested(s, depth);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&journal->j_join_wait, &wait);\r\n}\r\nstatic void wake_queued_writers(struct super_block *s)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(s);\r\nif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\r\nwake_up(&journal->j_join_wait);\r\n}\r\nstatic void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nunsigned long bcount = journal->j_bcount;\r\nwhile (1) {\r\nint depth;\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nschedule_timeout_uninterruptible(1);\r\nreiserfs_write_lock_nested(sb, depth);\r\njournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\r\nwhile ((atomic_read(&journal->j_wcount) > 0 ||\r\natomic_read(&journal->j_jlock)) &&\r\njournal->j_trans_id == trans_id) {\r\nqueue_log_writer(sb);\r\n}\r\nif (journal->j_trans_id != trans_id)\r\nbreak;\r\nif (bcount == journal->j_bcount)\r\nbreak;\r\nbcount = journal->j_bcount;\r\n}\r\n}\r\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb, unsigned long nblocks,\r\nint join)\r\n{\r\ntime_t now = get_seconds();\r\nunsigned int old_trans_id;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_transaction_handle myth;\r\nint sched_count = 0;\r\nint retval;\r\nint depth;\r\nreiserfs_check_lock_depth(sb, "journal_begin");\r\nBUG_ON(nblocks > journal->j_trans_max);\r\nPROC_INFO_INC(sb, journal.journal_being);\r\nth->t_refcount = 1;\r\nth->t_super = sb;\r\nrelock:\r\nlock_journal(sb);\r\nif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\r\nunlock_journal(sb);\r\nretval = journal->j_errno;\r\ngoto out_fail;\r\n}\r\njournal->j_bcount++;\r\nif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\r\nunlock_journal(sb);\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nreiserfs_wait_on_write_block(sb);\r\nreiserfs_write_lock_nested(sb, depth);\r\nPROC_INFO_INC(sb, journal.journal_relock_writers);\r\ngoto relock;\r\n}\r\nnow = get_seconds();\r\nif ((!join && journal->j_must_wait > 0) ||\r\n(!join\r\n&& (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\r\n|| (!join && atomic_read(&journal->j_wcount) > 0\r\n&& journal->j_trans_start_time > 0\r\n&& (now - journal->j_trans_start_time) >\r\njournal->j_max_trans_age) || (!join\r\n&& atomic_read(&journal->j_jlock))\r\n|| (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\r\nold_trans_id = journal->j_trans_id;\r\nunlock_journal(sb);\r\nif (!join && (journal->j_len_alloc + nblocks + 2) >=\r\njournal->j_max_batch &&\r\n((journal->j_len + nblocks + 2) * 100) <\r\n(journal->j_len_alloc * 75)) {\r\nif (atomic_read(&journal->j_wcount) > 10) {\r\nsched_count++;\r\nqueue_log_writer(sb);\r\ngoto relock;\r\n}\r\n}\r\nif (atomic_read(&journal->j_jlock)) {\r\nwhile (journal->j_trans_id == old_trans_id &&\r\natomic_read(&journal->j_jlock)) {\r\nqueue_log_writer(sb);\r\n}\r\ngoto relock;\r\n}\r\nretval = journal_join(&myth, sb);\r\nif (retval)\r\ngoto out_fail;\r\nif (old_trans_id != journal->j_trans_id) {\r\nretval = do_journal_end(&myth, 0);\r\n} else {\r\nretval = do_journal_end(&myth, COMMIT_NOW);\r\n}\r\nif (retval)\r\ngoto out_fail;\r\nPROC_INFO_INC(sb, journal.journal_relock_wcount);\r\ngoto relock;\r\n}\r\nif (journal->j_trans_start_time == 0) {\r\njournal->j_trans_start_time = get_seconds();\r\n}\r\natomic_inc(&journal->j_wcount);\r\njournal->j_len_alloc += nblocks;\r\nth->t_blocks_logged = 0;\r\nth->t_blocks_allocated = nblocks;\r\nth->t_trans_id = journal->j_trans_id;\r\nunlock_journal(sb);\r\nINIT_LIST_HEAD(&th->t_list);\r\nreturn 0;\r\nout_fail:\r\nmemset(th, 0, sizeof(*th));\r\nth->t_super = sb;\r\nreturn retval;\r\n}\r\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\r\nsuper_block\r\n*s,\r\nint nblocks)\r\n{\r\nint ret;\r\nstruct reiserfs_transaction_handle *th;\r\nif (reiserfs_transaction_running(s)) {\r\nth = current->journal_info;\r\nth->t_refcount++;\r\nBUG_ON(th->t_refcount < 2);\r\nreturn th;\r\n}\r\nth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\r\nif (!th)\r\nreturn NULL;\r\nret = journal_begin(th, s, nblocks);\r\nif (ret) {\r\nkfree(th);\r\nreturn NULL;\r\n}\r\nSB_JOURNAL(s)->j_persistent_trans++;\r\nreturn th;\r\n}\r\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\r\n{\r\nstruct super_block *s = th->t_super;\r\nint ret = 0;\r\nif (th->t_trans_id)\r\nret = journal_end(th);\r\nelse\r\nret = -EIO;\r\nif (th->t_refcount == 0) {\r\nSB_JOURNAL(s)->j_persistent_trans--;\r\nkfree(th);\r\n}\r\nreturn ret;\r\n}\r\nstatic int journal_join(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb)\r\n{\r\nstruct reiserfs_transaction_handle *cur_th = current->journal_info;\r\nth->t_handle_save = cur_th;\r\nBUG_ON(cur_th && cur_th->t_refcount > 1);\r\nreturn do_journal_begin_r(th, sb, 1, JBEGIN_JOIN);\r\n}\r\nint journal_join_abort(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb)\r\n{\r\nstruct reiserfs_transaction_handle *cur_th = current->journal_info;\r\nth->t_handle_save = cur_th;\r\nBUG_ON(cur_th && cur_th->t_refcount > 1);\r\nreturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\r\n}\r\nint journal_begin(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb, unsigned long nblocks)\r\n{\r\nstruct reiserfs_transaction_handle *cur_th = current->journal_info;\r\nint ret;\r\nth->t_handle_save = NULL;\r\nif (cur_th) {\r\nif (cur_th->t_super == sb) {\r\nBUG_ON(!cur_th->t_refcount);\r\ncur_th->t_refcount++;\r\nmemcpy(th, cur_th, sizeof(*th));\r\nif (th->t_refcount <= 1)\r\nreiserfs_warning(sb, "reiserfs-2005",\r\n"BAD: refcount <= 1, but "\r\n"journal_info != 0");\r\nreturn 0;\r\n} else {\r\nreiserfs_warning(sb, "clm-2100",\r\n"nesting info a different FS");\r\nth->t_handle_save = current->journal_info;\r\ncurrent->journal_info = th;\r\n}\r\n} else {\r\ncurrent->journal_info = th;\r\n}\r\nret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\r\nBUG_ON(current->journal_info != th);\r\nif (ret)\r\ncurrent->journal_info = th->t_handle_save;\r\nelse\r\nBUG_ON(!th->t_refcount);\r\nreturn ret;\r\n}\r\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\r\nstruct buffer_head *bh)\r\n{\r\nstruct super_block *sb = th->t_super;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_cnode *cn = NULL;\r\nint count_already_incd = 0;\r\nint prepared = 0;\r\nBUG_ON(!th->t_trans_id);\r\nPROC_INFO_INC(sb, journal.mark_dirty);\r\nif (th->t_trans_id != journal->j_trans_id) {\r\nreiserfs_panic(th->t_super, "journal-1577",\r\n"handle trans id %ld != current trans id %ld",\r\nth->t_trans_id, journal->j_trans_id);\r\n}\r\nprepared = test_clear_buffer_journal_prepared(bh);\r\nclear_buffer_journal_restore_dirty(bh);\r\nif (buffer_journaled(bh)) {\r\nPROC_INFO_INC(sb, journal.mark_dirty_already);\r\nreturn 0;\r\n}\r\nif (!prepared || buffer_dirty(bh)) {\r\nreiserfs_warning(sb, "journal-1777",\r\n"buffer %llu bad state "\r\n"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT",\r\n(unsigned long long)bh->b_blocknr,\r\nprepared ? ' ' : '!',\r\nbuffer_locked(bh) ? ' ' : '!',\r\nbuffer_dirty(bh) ? ' ' : '!',\r\nbuffer_journal_dirty(bh) ? ' ' : '!');\r\n}\r\nif (atomic_read(&journal->j_wcount) <= 0) {\r\nreiserfs_warning(sb, "journal-1409",\r\n"returning because j_wcount was %d",\r\natomic_read(&journal->j_wcount));\r\nreturn 1;\r\n}\r\nif (journal->j_len >= journal->j_trans_max) {\r\nreiserfs_panic(th->t_super, "journal-1413",\r\n"j_len (%lu) is too big",\r\njournal->j_len);\r\n}\r\nif (buffer_journal_dirty(bh)) {\r\ncount_already_incd = 1;\r\nPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\r\nclear_buffer_journal_dirty(bh);\r\n}\r\nif (journal->j_len > journal->j_len_alloc) {\r\njournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\r\n}\r\nset_buffer_journaled(bh);\r\nif (!cn) {\r\ncn = get_cnode(sb);\r\nif (!cn) {\r\nreiserfs_panic(sb, "journal-4", "get_cnode failed!");\r\n}\r\nif (th->t_blocks_logged == th->t_blocks_allocated) {\r\nth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\r\njournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\r\n}\r\nth->t_blocks_logged++;\r\njournal->j_len++;\r\ncn->bh = bh;\r\ncn->blocknr = bh->b_blocknr;\r\ncn->sb = sb;\r\ncn->jlist = NULL;\r\ninsert_journal_hash(journal->j_hash_table, cn);\r\nif (!count_already_incd) {\r\nget_bh(bh);\r\n}\r\n}\r\ncn->next = NULL;\r\ncn->prev = journal->j_last;\r\ncn->bh = bh;\r\nif (journal->j_last) {\r\njournal->j_last->next = cn;\r\njournal->j_last = cn;\r\n} else {\r\njournal->j_first = cn;\r\njournal->j_last = cn;\r\n}\r\nreiserfs_schedule_old_flush(sb);\r\nreturn 0;\r\n}\r\nint journal_end(struct reiserfs_transaction_handle *th)\r\n{\r\nstruct super_block *sb = th->t_super;\r\nif (!current->journal_info && th->t_refcount > 1)\r\nreiserfs_warning(sb, "REISER-NESTING",\r\n"th NULL, refcount %d", th->t_refcount);\r\nif (!th->t_trans_id) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nth->t_refcount--;\r\nif (th->t_refcount > 0) {\r\nstruct reiserfs_transaction_handle *cur_th =\r\ncurrent->journal_info;\r\nBUG_ON(cur_th->t_super != th->t_super);\r\nif (th != cur_th) {\r\nmemcpy(current->journal_info, th, sizeof(*th));\r\nth->t_trans_id = 0;\r\n}\r\nreturn 0;\r\n} else {\r\nreturn do_journal_end(th, 0);\r\n}\r\n}\r\nstatic int remove_from_transaction(struct super_block *sb,\r\nb_blocknr_t blocknr, int already_cleaned)\r\n{\r\nstruct buffer_head *bh;\r\nstruct reiserfs_journal_cnode *cn;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nint ret = 0;\r\ncn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\r\nif (!cn || !cn->bh) {\r\nreturn ret;\r\n}\r\nbh = cn->bh;\r\nif (cn->prev) {\r\ncn->prev->next = cn->next;\r\n}\r\nif (cn->next) {\r\ncn->next->prev = cn->prev;\r\n}\r\nif (cn == journal->j_first) {\r\njournal->j_first = cn->next;\r\n}\r\nif (cn == journal->j_last) {\r\njournal->j_last = cn->prev;\r\n}\r\nif (bh)\r\nremove_journal_hash(sb, journal->j_hash_table, NULL,\r\nbh->b_blocknr, 0);\r\nclear_buffer_journaled(bh);\r\nif (!already_cleaned) {\r\nclear_buffer_journal_dirty(bh);\r\nclear_buffer_dirty(bh);\r\nclear_buffer_journal_test(bh);\r\nput_bh(bh);\r\nif (atomic_read(&bh->b_count) < 0) {\r\nreiserfs_warning(sb, "journal-1752",\r\n"b_count < 0");\r\n}\r\nret = 1;\r\n}\r\njournal->j_len--;\r\njournal->j_len_alloc--;\r\nfree_cnode(sb, cn);\r\nreturn ret;\r\n}\r\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\r\n{\r\nstruct super_block *sb = cn->sb;\r\nb_blocknr_t blocknr = cn->blocknr;\r\nstruct reiserfs_journal_cnode *cur = cn->hprev;\r\nint can_dirty = 1;\r\nwhile (cur && can_dirty) {\r\nif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\r\ncur->blocknr == blocknr) {\r\ncan_dirty = 0;\r\n}\r\ncur = cur->hprev;\r\n}\r\ncur = cn->hnext;\r\nwhile (cur && can_dirty) {\r\nif (cur->jlist && cur->jlist->j_len > 0 &&\r\natomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\r\ncur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\r\ncan_dirty = 0;\r\n}\r\ncur = cur->hnext;\r\n}\r\nreturn can_dirty;\r\n}\r\nint journal_end_sync(struct reiserfs_transaction_handle *th)\r\n{\r\nstruct super_block *sb = th->t_super;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nBUG_ON(!th->t_trans_id);\r\nBUG_ON(th->t_refcount > 1);\r\nif (journal->j_len == 0) {\r\nreiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\r\n}\r\nreturn do_journal_end(th, COMMIT_NOW | WAIT);\r\n}\r\nstatic void flush_async_commits(struct work_struct *work)\r\n{\r\nstruct reiserfs_journal *journal =\r\ncontainer_of(work, struct reiserfs_journal, j_work.work);\r\nstruct super_block *sb = journal->j_work_sb;\r\nstruct reiserfs_journal_list *jl;\r\nstruct list_head *entry;\r\nreiserfs_write_lock(sb);\r\nif (!list_empty(&journal->j_journal_list)) {\r\nentry = journal->j_journal_list.prev;\r\njl = JOURNAL_LIST_ENTRY(entry);\r\nflush_commit_list(sb, jl, 1);\r\n}\r\nreiserfs_write_unlock(sb);\r\n}\r\nvoid reiserfs_flush_old_commits(struct super_block *sb)\r\n{\r\ntime_t now;\r\nstruct reiserfs_transaction_handle th;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nnow = get_seconds();\r\nif (list_empty(&journal->j_journal_list))\r\nreturn;\r\nif (atomic_read(&journal->j_wcount) <= 0 &&\r\njournal->j_trans_start_time > 0 &&\r\njournal->j_len > 0 &&\r\n(now - journal->j_trans_start_time) > journal->j_max_trans_age) {\r\nif (!journal_join(&th, sb)) {\r\nreiserfs_prepare_for_journal(sb,\r\nSB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\r\ndo_journal_end(&th, COMMIT_NOW | WAIT);\r\n}\r\n}\r\n}\r\nstatic int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\r\n{\r\ntime_t now;\r\nint flush = flags & FLUSH_ALL;\r\nint commit_now = flags & COMMIT_NOW;\r\nint wait_on_commit = flags & WAIT;\r\nstruct reiserfs_journal_list *jl;\r\nstruct super_block *sb = th->t_super;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nBUG_ON(!th->t_trans_id);\r\nif (th->t_trans_id != journal->j_trans_id) {\r\nreiserfs_panic(th->t_super, "journal-1577",\r\n"handle trans id %ld != current trans id %ld",\r\nth->t_trans_id, journal->j_trans_id);\r\n}\r\njournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\r\nif (atomic_read(&journal->j_wcount) > 0)\r\natomic_dec(&journal->j_wcount);\r\nBUG_ON(journal->j_len == 0);\r\nif (atomic_read(&journal->j_wcount) > 0) {\r\nif (flush || commit_now) {\r\nunsigned trans_id;\r\njl = journal->j_current_jl;\r\ntrans_id = jl->j_trans_id;\r\nif (wait_on_commit)\r\njl->j_state |= LIST_COMMIT_PENDING;\r\natomic_set(&journal->j_jlock, 1);\r\nif (flush) {\r\njournal->j_next_full_flush = 1;\r\n}\r\nunlock_journal(sb);\r\nwhile (journal->j_trans_id == trans_id) {\r\nif (atomic_read(&journal->j_jlock)) {\r\nqueue_log_writer(sb);\r\n} else {\r\nlock_journal(sb);\r\nif (journal->j_trans_id == trans_id) {\r\natomic_set(&journal->j_jlock,\r\n1);\r\n}\r\nunlock_journal(sb);\r\n}\r\n}\r\nBUG_ON(journal->j_trans_id == trans_id);\r\nif (commit_now\r\n&& journal_list_still_alive(sb, trans_id)\r\n&& wait_on_commit) {\r\nflush_commit_list(sb, jl, 1);\r\n}\r\nreturn 0;\r\n}\r\nunlock_journal(sb);\r\nreturn 0;\r\n}\r\nnow = get_seconds();\r\nif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\r\ncommit_now = 1;\r\njournal->j_next_async_flush = 1;\r\n}\r\nif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\r\n&& !flush && !commit_now && (journal->j_len < journal->j_max_batch)\r\n&& journal->j_len_alloc < journal->j_max_batch\r\n&& journal->j_cnode_free > (journal->j_trans_max * 3)) {\r\njournal->j_bcount++;\r\nunlock_journal(sb);\r\nreturn 0;\r\n}\r\nif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\r\nreiserfs_panic(sb, "journal-003",\r\n"j_start (%ld) is too high",\r\njournal->j_start);\r\n}\r\nreturn 1;\r\n}\r\nint journal_mark_freed(struct reiserfs_transaction_handle *th,\r\nstruct super_block *sb, b_blocknr_t blocknr)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_cnode *cn = NULL;\r\nstruct buffer_head *bh = NULL;\r\nstruct reiserfs_list_bitmap *jb = NULL;\r\nint cleaned = 0;\r\nBUG_ON(!th->t_trans_id);\r\ncn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\r\nif (cn && cn->bh) {\r\nbh = cn->bh;\r\nget_bh(bh);\r\n}\r\nif (bh && buffer_journal_new(bh)) {\r\nclear_buffer_journal_new(bh);\r\nclear_prepared_bits(bh);\r\nreiserfs_clean_and_file_buffer(bh);\r\ncleaned = remove_from_transaction(sb, blocknr, cleaned);\r\n} else {\r\njb = journal->j_current_jl->j_list_bitmap;\r\nif (!jb) {\r\nreiserfs_panic(sb, "journal-1702",\r\n"journal_list_bitmap is NULL");\r\n}\r\nset_bit_in_list_bitmap(sb, blocknr, jb);\r\nif (bh) {\r\nclear_prepared_bits(bh);\r\nreiserfs_clean_and_file_buffer(bh);\r\n}\r\ncleaned = remove_from_transaction(sb, blocknr, cleaned);\r\ncn = get_journal_hash_dev(sb, journal->j_list_hash_table,\r\nblocknr);\r\nwhile (cn) {\r\nif (sb == cn->sb && blocknr == cn->blocknr) {\r\nset_bit(BLOCK_FREED, &cn->state);\r\nif (cn->bh) {\r\nif (!cleaned) {\r\nclear_buffer_journal_dirty(cn->\r\nbh);\r\nclear_buffer_dirty(cn->bh);\r\nclear_buffer_journal_test(cn->\r\nbh);\r\ncleaned = 1;\r\nput_bh(cn->bh);\r\nif (atomic_read\r\n(&cn->bh->b_count) < 0) {\r\nreiserfs_warning(sb,\r\n"journal-2138",\r\n"cn->bh->b_count < 0");\r\n}\r\n}\r\nif (cn->jlist) {\r\natomic_dec(&cn->jlist->\r\nj_nonzerolen);\r\n}\r\ncn->bh = NULL;\r\n}\r\n}\r\ncn = cn->hnext;\r\n}\r\n}\r\nif (bh)\r\nrelease_buffer_page(bh);\r\nreturn 0;\r\n}\r\nvoid reiserfs_update_inode_transaction(struct inode *inode)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\r\nREISERFS_I(inode)->i_jl = journal->j_current_jl;\r\nREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\r\n}\r\nstatic int __commit_trans_jl(struct inode *inode, unsigned long id,\r\nstruct reiserfs_journal_list *jl)\r\n{\r\nstruct reiserfs_transaction_handle th;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nint ret = 0;\r\nif (id == journal->j_trans_id) {\r\njl = journal->j_current_jl;\r\nlet_transaction_grow(sb, id);\r\nif (journal->j_trans_id != id) {\r\ngoto flush_commit_only;\r\n}\r\nret = journal_begin(&th, sb, 1);\r\nif (ret)\r\nreturn ret;\r\nif (journal->j_trans_id != id) {\r\nreiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\r\nret = journal_end(&th);\r\ngoto flush_commit_only;\r\n}\r\nret = journal_end_sync(&th);\r\nif (!ret)\r\nret = 1;\r\n} else {\r\nflush_commit_only:\r\nif (journal_list_still_alive(inode->i_sb, id)) {\r\nif (atomic_read(&jl->j_commit_left) > 1)\r\nret = 1;\r\nflush_commit_list(sb, jl, 1);\r\nif (journal->j_errno)\r\nret = journal->j_errno;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint reiserfs_commit_for_inode(struct inode *inode)\r\n{\r\nunsigned int id = REISERFS_I(inode)->i_trans_id;\r\nstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\r\nif (!id || !jl) {\r\nreiserfs_update_inode_transaction(inode);\r\nid = REISERFS_I(inode)->i_trans_id;\r\n}\r\nreturn __commit_trans_jl(inode, id, jl);\r\n}\r\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\r\nstruct buffer_head *bh)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nPROC_INFO_INC(sb, journal.restore_prepared);\r\nif (!bh) {\r\nreturn;\r\n}\r\nif (test_clear_buffer_journal_restore_dirty(bh) &&\r\nbuffer_journal_dirty(bh)) {\r\nstruct reiserfs_journal_cnode *cn;\r\nreiserfs_write_lock(sb);\r\ncn = get_journal_hash_dev(sb,\r\njournal->j_list_hash_table,\r\nbh->b_blocknr);\r\nif (cn && can_dirty(cn)) {\r\nset_buffer_journal_test(bh);\r\nmark_buffer_dirty(bh);\r\n}\r\nreiserfs_write_unlock(sb);\r\n}\r\nclear_buffer_journal_prepared(bh);\r\n}\r\nint reiserfs_prepare_for_journal(struct super_block *sb,\r\nstruct buffer_head *bh, int wait)\r\n{\r\nPROC_INFO_INC(sb, journal.prepare);\r\nif (!trylock_buffer(bh)) {\r\nif (!wait)\r\nreturn 0;\r\nlock_buffer(bh);\r\n}\r\nset_buffer_journal_prepared(bh);\r\nif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\r\nclear_buffer_journal_test(bh);\r\nset_buffer_journal_restore_dirty(bh);\r\n}\r\nunlock_buffer(bh);\r\nreturn 1;\r\n}\r\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\r\n{\r\nstruct super_block *sb = th->t_super;\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\r\nstruct reiserfs_journal_cnode *last_cn = NULL;\r\nstruct reiserfs_journal_desc *desc;\r\nstruct reiserfs_journal_commit *commit;\r\nstruct buffer_head *c_bh;\r\nstruct buffer_head *d_bh;\r\nint cur_write_start = 0;\r\nint old_start;\r\nint i;\r\nint flush;\r\nint wait_on_commit;\r\nstruct reiserfs_journal_list *jl, *temp_jl;\r\nstruct list_head *entry, *safe;\r\nunsigned long jindex;\r\nunsigned int commit_trans_id;\r\nint trans_half;\r\nint depth;\r\nBUG_ON(th->t_refcount > 1);\r\nBUG_ON(!th->t_trans_id);\r\nBUG_ON(!th->t_super);\r\nif (th->t_trans_id == ~0U)\r\nflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\r\nflush = flags & FLUSH_ALL;\r\nwait_on_commit = flags & WAIT;\r\ncurrent->journal_info = th->t_handle_save;\r\nreiserfs_check_lock_depth(sb, "journal end");\r\nif (journal->j_len == 0) {\r\nreiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\r\n1);\r\njournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\r\n}\r\nlock_journal(sb);\r\nif (journal->j_next_full_flush) {\r\nflags |= FLUSH_ALL;\r\nflush = 1;\r\n}\r\nif (journal->j_next_async_flush) {\r\nflags |= COMMIT_NOW | WAIT;\r\nwait_on_commit = 1;\r\n}\r\nif (!check_journal_end(th, flags)) {\r\nreiserfs_schedule_old_flush(sb);\r\nwake_queued_writers(sb);\r\nreiserfs_async_progress_wait(sb);\r\ngoto out;\r\n}\r\nif (journal->j_next_full_flush) {\r\nflush = 1;\r\n}\r\nif (journal->j_must_wait > 0) {\r\nflush = 1;\r\n}\r\n#ifdef REISERFS_PREALLOCATE\r\ncurrent->journal_info = th;\r\nth->t_refcount++;\r\nreiserfs_discard_all_prealloc(th);\r\nth->t_refcount--;\r\ncurrent->journal_info = th->t_handle_save;\r\n#endif\r\nd_bh =\r\njournal_getblk(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\njournal->j_start);\r\nset_buffer_uptodate(d_bh);\r\ndesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\r\nmemset(d_bh->b_data, 0, d_bh->b_size);\r\nmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\r\nset_desc_trans_id(desc, journal->j_trans_id);\r\nc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n((journal->j_start + journal->j_len +\r\n1) % SB_ONDISK_JOURNAL_SIZE(sb)));\r\ncommit = (struct reiserfs_journal_commit *)c_bh->b_data;\r\nmemset(c_bh->b_data, 0, c_bh->b_size);\r\nset_commit_trans_id(commit, journal->j_trans_id);\r\nset_buffer_uptodate(c_bh);\r\njl = journal->j_current_jl;\r\nreiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\r\ncommit_trans_id = jl->j_trans_id;\r\natomic_set(&jl->j_older_commits_done, 0);\r\njl->j_trans_id = journal->j_trans_id;\r\njl->j_timestamp = journal->j_trans_start_time;\r\njl->j_commit_bh = c_bh;\r\njl->j_start = journal->j_start;\r\njl->j_len = journal->j_len;\r\natomic_set(&jl->j_nonzerolen, journal->j_len);\r\natomic_set(&jl->j_commit_left, journal->j_len + 2);\r\njl->j_realblock = NULL;\r\ntrans_half = journal_trans_half(sb->s_blocksize);\r\nfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\r\nif (buffer_journaled(cn->bh)) {\r\njl_cn = get_cnode(sb);\r\nif (!jl_cn) {\r\nreiserfs_panic(sb, "journal-1676",\r\n"get_cnode returned NULL");\r\n}\r\nif (i == 0) {\r\njl->j_realblock = jl_cn;\r\n}\r\njl_cn->prev = last_cn;\r\njl_cn->next = NULL;\r\nif (last_cn) {\r\nlast_cn->next = jl_cn;\r\n}\r\nlast_cn = jl_cn;\r\nif (is_block_in_log_or_reserved_area\r\n(sb, cn->bh->b_blocknr)) {\r\nreiserfs_panic(sb, "journal-2332",\r\n"Trying to log block %lu, "\r\n"which is a log block",\r\ncn->bh->b_blocknr);\r\n}\r\njl_cn->blocknr = cn->bh->b_blocknr;\r\njl_cn->state = 0;\r\njl_cn->sb = sb;\r\njl_cn->bh = cn->bh;\r\njl_cn->jlist = jl;\r\ninsert_journal_hash(journal->j_list_hash_table, jl_cn);\r\nif (i < trans_half) {\r\ndesc->j_realblock[i] =\r\ncpu_to_le32(cn->bh->b_blocknr);\r\n} else {\r\ncommit->j_realblock[i - trans_half] =\r\ncpu_to_le32(cn->bh->b_blocknr);\r\n}\r\n} else {\r\ni--;\r\n}\r\n}\r\nset_desc_trans_len(desc, journal->j_len);\r\nset_desc_mount_id(desc, journal->j_mount_id);\r\nset_desc_trans_id(desc, journal->j_trans_id);\r\nset_commit_trans_len(commit, journal->j_len);\r\nBUG_ON(journal->j_len == 0);\r\nmark_buffer_dirty(d_bh);\r\ncur_write_start = journal->j_start;\r\ncn = journal->j_first;\r\njindex = 1;\r\nwhile (cn) {\r\nclear_buffer_journal_new(cn->bh);\r\nif (buffer_journaled(cn->bh)) {\r\nstruct buffer_head *tmp_bh;\r\nchar *addr;\r\nstruct page *page;\r\ntmp_bh =\r\njournal_getblk(sb,\r\nSB_ONDISK_JOURNAL_1st_BLOCK(sb) +\r\n((cur_write_start +\r\njindex) %\r\nSB_ONDISK_JOURNAL_SIZE(sb)));\r\nset_buffer_uptodate(tmp_bh);\r\npage = cn->bh->b_page;\r\naddr = kmap(page);\r\nmemcpy(tmp_bh->b_data,\r\naddr + offset_in_page(cn->bh->b_data),\r\ncn->bh->b_size);\r\nkunmap(page);\r\nmark_buffer_dirty(tmp_bh);\r\njindex++;\r\nset_buffer_journal_dirty(cn->bh);\r\nclear_buffer_journaled(cn->bh);\r\n} else {\r\nreiserfs_warning(sb, "journal-2048",\r\n"BAD, buffer in journal hash, "\r\n"but not JDirty!");\r\nbrelse(cn->bh);\r\n}\r\nnext = cn->next;\r\nfree_cnode(sb, cn);\r\ncn = next;\r\nreiserfs_cond_resched(sb);\r\n}\r\njournal->j_current_jl = alloc_journal_list(sb);\r\nlist_add_tail(&jl->j_list, &journal->j_journal_list);\r\nlist_add_tail(&jl->j_working_list, &journal->j_working_list);\r\njournal->j_num_work_lists++;\r\nold_start = journal->j_start;\r\njournal->j_start =\r\n(journal->j_start + journal->j_len +\r\n2) % SB_ONDISK_JOURNAL_SIZE(sb);\r\natomic_set(&journal->j_wcount, 0);\r\njournal->j_bcount = 0;\r\njournal->j_last = NULL;\r\njournal->j_first = NULL;\r\njournal->j_len = 0;\r\njournal->j_trans_start_time = 0;\r\nif (++journal->j_trans_id == 0)\r\njournal->j_trans_id = 10;\r\njournal->j_current_jl->j_trans_id = journal->j_trans_id;\r\njournal->j_must_wait = 0;\r\njournal->j_len_alloc = 0;\r\njournal->j_next_full_flush = 0;\r\njournal->j_next_async_flush = 0;\r\ninit_journal_hash(sb);\r\nsmp_mb();\r\nif (!list_empty(&jl->j_tail_bh_list)) {\r\ndepth = reiserfs_write_unlock_nested(sb);\r\nwrite_ordered_buffers(&journal->j_dirty_buffers_lock,\r\njournal, jl, &jl->j_tail_bh_list);\r\nreiserfs_write_lock_nested(sb, depth);\r\n}\r\nBUG_ON(!list_empty(&jl->j_tail_bh_list));\r\nmutex_unlock(&jl->j_commit_mutex);\r\nif (flush) {\r\nflush_commit_list(sb, jl, 1);\r\nflush_journal_list(sb, jl, 1);\r\n} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\r\nif (sb->s_flags & MS_ACTIVE)\r\nqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\r\n&journal->j_work, HZ / 10);\r\n}\r\nfirst_jl:\r\nlist_for_each_safe(entry, safe, &journal->j_journal_list) {\r\ntemp_jl = JOURNAL_LIST_ENTRY(entry);\r\nif (journal->j_start <= temp_jl->j_start) {\r\nif ((journal->j_start + journal->j_trans_max + 1) >=\r\ntemp_jl->j_start) {\r\nflush_used_journal_lists(sb, temp_jl);\r\ngoto first_jl;\r\n} else if ((journal->j_start +\r\njournal->j_trans_max + 1) <\r\nSB_ONDISK_JOURNAL_SIZE(sb)) {\r\nbreak;\r\n}\r\n} else if ((journal->j_start +\r\njournal->j_trans_max + 1) >\r\nSB_ONDISK_JOURNAL_SIZE(sb)) {\r\nif (((journal->j_start + journal->j_trans_max + 1) %\r\nSB_ONDISK_JOURNAL_SIZE(sb)) >=\r\ntemp_jl->j_start) {\r\nflush_used_journal_lists(sb, temp_jl);\r\ngoto first_jl;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\njournal->j_current_jl->j_list_bitmap =\r\nget_list_bitmap(sb, journal->j_current_jl);\r\nif (!(journal->j_current_jl->j_list_bitmap)) {\r\nreiserfs_panic(sb, "journal-1996",\r\n"could not get a list bitmap");\r\n}\r\natomic_set(&journal->j_jlock, 0);\r\nunlock_journal(sb);\r\nclear_bit(J_WRITERS_QUEUED, &journal->j_state);\r\nwake_up(&journal->j_join_wait);\r\nif (!flush && wait_on_commit &&\r\njournal_list_still_alive(sb, commit_trans_id)) {\r\nflush_commit_list(sb, jl, 1);\r\n}\r\nout:\r\nreiserfs_check_lock_depth(sb, "journal end2");\r\nmemset(th, 0, sizeof(*th));\r\nth->t_super = sb;\r\nreturn journal->j_errno;\r\n}\r\nvoid reiserfs_abort_journal(struct super_block *sb, int errno)\r\n{\r\nstruct reiserfs_journal *journal = SB_JOURNAL(sb);\r\nif (test_bit(J_ABORTED, &journal->j_state))\r\nreturn;\r\nif (!journal->j_errno)\r\njournal->j_errno = errno;\r\nsb->s_flags |= MS_RDONLY;\r\nset_bit(J_ABORTED, &journal->j_state);\r\n#ifdef CONFIG_REISERFS_CHECK\r\ndump_stack();\r\n#endif\r\n}
