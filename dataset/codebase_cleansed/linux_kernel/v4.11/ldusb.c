static void ld_usb_abort_transfers(struct ld_usb *dev)\r\n{\r\nif (dev->interrupt_in_running) {\r\ndev->interrupt_in_running = 0;\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_in_urb);\r\n}\r\nif (dev->interrupt_out_busy)\r\nif (dev->intf)\r\nusb_kill_urb(dev->interrupt_out_urb);\r\n}\r\nstatic void ld_usb_delete(struct ld_usb *dev)\r\n{\r\nld_usb_abort_transfers(dev);\r\nusb_free_urb(dev->interrupt_in_urb);\r\nusb_free_urb(dev->interrupt_out_urb);\r\nkfree(dev->ring_buffer);\r\nkfree(dev->interrupt_in_buffer);\r\nkfree(dev->interrupt_out_buffer);\r\nkfree(dev);\r\n}\r\nstatic void ld_usb_interrupt_in_callback(struct urb *urb)\r\n{\r\nstruct ld_usb *dev = urb->context;\r\nsize_t *actual_buffer;\r\nunsigned int next_ring_head;\r\nint status = urb->status;\r\nint retval;\r\nif (status) {\r\nif (status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -ESHUTDOWN) {\r\ngoto exit;\r\n} else {\r\ndev_dbg(&dev->intf->dev,\r\n"%s: nonzero status received: %d\n", __func__,\r\nstatus);\r\nspin_lock(&dev->rbsl);\r\ngoto resubmit;\r\n}\r\n}\r\nspin_lock(&dev->rbsl);\r\nif (urb->actual_length > 0) {\r\nnext_ring_head = (dev->ring_head+1) % ring_buffer_size;\r\nif (next_ring_head != dev->ring_tail) {\r\nactual_buffer = (size_t*)(dev->ring_buffer + dev->ring_head*(sizeof(size_t)+dev->interrupt_in_endpoint_size));\r\n*actual_buffer = urb->actual_length;\r\nmemcpy(actual_buffer+1, dev->interrupt_in_buffer, urb->actual_length);\r\ndev->ring_head = next_ring_head;\r\ndev_dbg(&dev->intf->dev, "%s: received %d bytes\n",\r\n__func__, urb->actual_length);\r\n} else {\r\ndev_warn(&dev->intf->dev,\r\n"Ring buffer overflow, %d bytes dropped\n",\r\nurb->actual_length);\r\ndev->buffer_overflow = 1;\r\n}\r\n}\r\nresubmit:\r\nif (dev->interrupt_in_running && !dev->buffer_overflow && dev->intf) {\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_err(&dev->intf->dev,\r\n"usb_submit_urb failed (%d)\n", retval);\r\ndev->buffer_overflow = 1;\r\n}\r\n}\r\nspin_unlock(&dev->rbsl);\r\nexit:\r\ndev->interrupt_in_done = 1;\r\nwake_up_interruptible(&dev->read_wait);\r\n}\r\nstatic void ld_usb_interrupt_out_callback(struct urb *urb)\r\n{\r\nstruct ld_usb *dev = urb->context;\r\nint status = urb->status;\r\nif (status && !(status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -ESHUTDOWN))\r\ndev_dbg(&dev->intf->dev,\r\n"%s - nonzero write interrupt status received: %d\n",\r\n__func__, status);\r\ndev->interrupt_out_busy = 0;\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic int ld_usb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ld_usb *dev;\r\nint subminor;\r\nint retval;\r\nstruct usb_interface *interface;\r\nnonseekable_open(inode, file);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&ld_usb_driver, subminor);\r\nif (!interface) {\r\nprintk(KERN_ERR "%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nreturn -ENODEV;\r\n}\r\ndev = usb_get_intfdata(interface);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&dev->mutex))\r\nreturn -ERESTARTSYS;\r\nif (dev->open_count) {\r\nretval = -EBUSY;\r\ngoto unlock_exit;\r\n}\r\ndev->open_count = 1;\r\ndev->ring_head = 0;\r\ndev->ring_tail = 0;\r\ndev->buffer_overflow = 0;\r\nusb_fill_int_urb(dev->interrupt_in_urb,\r\ninterface_to_usbdev(interface),\r\nusb_rcvintpipe(interface_to_usbdev(interface),\r\ndev->interrupt_in_endpoint->bEndpointAddress),\r\ndev->interrupt_in_buffer,\r\ndev->interrupt_in_endpoint_size,\r\nld_usb_interrupt_in_callback,\r\ndev,\r\ndev->interrupt_in_interval);\r\ndev->interrupt_in_running = 1;\r\ndev->interrupt_in_done = 0;\r\nretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&interface->dev, "Couldn't submit interrupt_in_urb %d\n", retval);\r\ndev->interrupt_in_running = 0;\r\ndev->open_count = 0;\r\ngoto unlock_exit;\r\n}\r\nfile->private_data = dev;\r\nunlock_exit:\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nstatic int ld_usb_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ld_usb *dev;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->mutex)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->open_count != 1) {\r\nretval = -ENODEV;\r\ngoto unlock_exit;\r\n}\r\nif (dev->intf == NULL) {\r\nmutex_unlock(&dev->mutex);\r\nld_usb_delete(dev);\r\ngoto exit;\r\n}\r\nif (dev->interrupt_out_busy)\r\nwait_event_interruptible_timeout(dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);\r\nld_usb_abort_transfers(dev);\r\ndev->open_count = 0;\r\nunlock_exit:\r\nmutex_unlock(&dev->mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic unsigned int ld_usb_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct ld_usb *dev;\r\nunsigned int mask = 0;\r\ndev = file->private_data;\r\nif (!dev->intf)\r\nreturn POLLERR | POLLHUP;\r\npoll_wait(file, &dev->read_wait, wait);\r\npoll_wait(file, &dev->write_wait, wait);\r\nif (dev->ring_head != dev->ring_tail)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (!dev->interrupt_out_busy)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct ld_usb *dev;\r\nsize_t *actual_buffer;\r\nsize_t bytes_to_read;\r\nint retval = 0;\r\nint rv;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mutex)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\nprintk(KERN_ERR "ldusb: No device or device unplugged %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nspin_lock_irq(&dev->rbsl);\r\nif (dev->ring_head == dev->ring_tail) {\r\ndev->interrupt_in_done = 0;\r\nspin_unlock_irq(&dev->rbsl);\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval = wait_event_interruptible(dev->read_wait, dev->interrupt_in_done);\r\nif (retval < 0)\r\ngoto unlock_exit;\r\n} else {\r\nspin_unlock_irq(&dev->rbsl);\r\n}\r\nactual_buffer = (size_t*)(dev->ring_buffer + dev->ring_tail*(sizeof(size_t)+dev->interrupt_in_endpoint_size));\r\nbytes_to_read = min(count, *actual_buffer);\r\nif (bytes_to_read < *actual_buffer)\r\ndev_warn(&dev->intf->dev, "Read buffer overflow, %zd bytes dropped\n",\r\n*actual_buffer-bytes_to_read);\r\nif (copy_to_user(buffer, actual_buffer+1, bytes_to_read)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\ndev->ring_tail = (dev->ring_tail+1) % ring_buffer_size;\r\nretval = bytes_to_read;\r\nspin_lock_irq(&dev->rbsl);\r\nif (dev->buffer_overflow) {\r\ndev->buffer_overflow = 0;\r\nspin_unlock_irq(&dev->rbsl);\r\nrv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\r\nif (rv < 0)\r\ndev->buffer_overflow = 1;\r\n} else {\r\nspin_unlock_irq(&dev->rbsl);\r\n}\r\nunlock_exit:\r\nmutex_unlock(&dev->mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic ssize_t ld_usb_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ld_usb *dev;\r\nsize_t bytes_to_write;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nif (mutex_lock_interruptible(&dev->mutex)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->intf == NULL) {\r\nretval = -ENODEV;\r\nprintk(KERN_ERR "ldusb: No device or device unplugged %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_busy) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval = wait_event_interruptible(dev->write_wait, !dev->interrupt_out_busy);\r\nif (retval < 0) {\r\ngoto unlock_exit;\r\n}\r\n}\r\nbytes_to_write = min(count, write_buffer_size*dev->interrupt_out_endpoint_size);\r\nif (bytes_to_write < count)\r\ndev_warn(&dev->intf->dev, "Write buffer overflow, %zd bytes dropped\n",count-bytes_to_write);\r\ndev_dbg(&dev->intf->dev, "%s: count = %zd, bytes_to_write = %zd\n",\r\n__func__, count, bytes_to_write);\r\nif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL) {\r\nretval = usb_control_msg(interface_to_usbdev(dev->intf),\r\nusb_sndctrlpipe(interface_to_usbdev(dev->intf), 0),\r\n9,\r\nUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\r\n1 << 8, 0,\r\ndev->interrupt_out_buffer,\r\nbytes_to_write,\r\nUSB_CTRL_SET_TIMEOUT * HZ);\r\nif (retval < 0)\r\ndev_err(&dev->intf->dev,\r\n"Couldn't submit HID_REQ_SET_REPORT %d\n",\r\nretval);\r\ngoto unlock_exit;\r\n}\r\nusb_fill_int_urb(dev->interrupt_out_urb,\r\ninterface_to_usbdev(dev->intf),\r\nusb_sndintpipe(interface_to_usbdev(dev->intf),\r\ndev->interrupt_out_endpoint->bEndpointAddress),\r\ndev->interrupt_out_buffer,\r\nbytes_to_write,\r\nld_usb_interrupt_out_callback,\r\ndev,\r\ndev->interrupt_out_interval);\r\ndev->interrupt_out_busy = 1;\r\nwmb();\r\nretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev->interrupt_out_busy = 0;\r\ndev_err(&dev->intf->dev,\r\n"Couldn't submit interrupt_out_urb %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nretval = bytes_to_write;\r\nunlock_exit:\r\nmutex_unlock(&dev->mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int ld_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct ld_usb *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nchar *buffer;\r\nint i;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\ngoto exit;\r\nmutex_init(&dev->mutex);\r\nspin_lock_init(&dev->rbsl);\r\ndev->intf = intf;\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VENDOR_ID_LD) &&\r\n((le16_to_cpu(udev->descriptor.idProduct) == USB_DEVICE_ID_LD_CASSY) ||\r\n(le16_to_cpu(udev->descriptor.idProduct) == USB_DEVICE_ID_LD_COM3LAB)) &&\r\n(le16_to_cpu(udev->descriptor.bcdDevice) <= 0x103)) {\r\nbuffer = kmalloc(256, GFP_KERNEL);\r\nif (!buffer)\r\ngoto error;\r\nusb_string(udev, 255, buffer, 256);\r\nkfree(buffer);\r\n}\r\niface_desc = intf->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint))\r\ndev->interrupt_in_endpoint = endpoint;\r\nif (usb_endpoint_is_int_out(endpoint))\r\ndev->interrupt_out_endpoint = endpoint;\r\n}\r\nif (dev->interrupt_in_endpoint == NULL) {\r\ndev_err(&intf->dev, "Interrupt in endpoint not found\n");\r\ngoto error;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL)\r\ndev_warn(&intf->dev, "Interrupt out endpoint not found (using control endpoint instead)\n");\r\ndev->interrupt_in_endpoint_size = usb_endpoint_maxp(dev->interrupt_in_endpoint);\r\ndev->ring_buffer = kmalloc(ring_buffer_size*(sizeof(size_t)+dev->interrupt_in_endpoint_size), GFP_KERNEL);\r\nif (!dev->ring_buffer)\r\ngoto error;\r\ndev->interrupt_in_buffer = kmalloc(dev->interrupt_in_endpoint_size, GFP_KERNEL);\r\nif (!dev->interrupt_in_buffer)\r\ngoto error;\r\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_in_urb)\r\ngoto error;\r\ndev->interrupt_out_endpoint_size = dev->interrupt_out_endpoint ? usb_endpoint_maxp(dev->interrupt_out_endpoint) :\r\nudev->descriptor.bMaxPacketSize0;\r\ndev->interrupt_out_buffer = kmalloc(write_buffer_size*dev->interrupt_out_endpoint_size, GFP_KERNEL);\r\nif (!dev->interrupt_out_buffer)\r\ngoto error;\r\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_out_urb)\r\ngoto error;\r\ndev->interrupt_in_interval = min_interrupt_in_interval > dev->interrupt_in_endpoint->bInterval ? min_interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\r\nif (dev->interrupt_out_endpoint)\r\ndev->interrupt_out_interval = min_interrupt_out_interval > dev->interrupt_out_endpoint->bInterval ? min_interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\r\nusb_set_intfdata(intf, dev);\r\nretval = usb_register_dev(intf, &ld_usb_class);\r\nif (retval) {\r\ndev_err(&intf->dev, "Not able to get a minor for this device.\n");\r\nusb_set_intfdata(intf, NULL);\r\ngoto error;\r\n}\r\ndev_info(&intf->dev, "LD USB Device #%d now attached to major %d minor %d\n",\r\n(intf->minor - USB_LD_MINOR_BASE), USB_MAJOR, intf->minor);\r\nexit:\r\nreturn retval;\r\nerror:\r\nld_usb_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void ld_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ld_usb *dev;\r\nint minor;\r\ndev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nminor = intf->minor;\r\nusb_deregister_dev(intf, &ld_usb_class);\r\nmutex_lock(&dev->mutex);\r\nif (!dev->open_count) {\r\nmutex_unlock(&dev->mutex);\r\nld_usb_delete(dev);\r\n} else {\r\ndev->intf = NULL;\r\nwake_up_interruptible_all(&dev->read_wait);\r\nwake_up_interruptible_all(&dev->write_wait);\r\nmutex_unlock(&dev->mutex);\r\n}\r\ndev_info(&intf->dev, "LD USB Device #%d now disconnected\n",\r\n(minor - USB_LD_MINOR_BASE));\r\n}
