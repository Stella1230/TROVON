static void rcar_i2c_write(struct rcar_i2c_priv *priv, int reg, u32 val)\r\n{\r\nwritel(val, priv->io + reg);\r\n}\r\nstatic u32 rcar_i2c_read(struct rcar_i2c_priv *priv, int reg)\r\n{\r\nreturn readl(priv->io + reg);\r\n}\r\nstatic void rcar_i2c_init(struct rcar_i2c_priv *priv)\r\n{\r\nrcar_i2c_write(priv, ICMIER, 0);\r\nrcar_i2c_write(priv, ICMCR, MDBS);\r\nrcar_i2c_write(priv, ICMSR, 0);\r\nrcar_i2c_write(priv, ICCCR, priv->icccr);\r\n}\r\nstatic int rcar_i2c_bus_barrier(struct rcar_i2c_priv *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < LOOP_TIMEOUT; i++) {\r\nif (!(rcar_i2c_read(priv, ICMCR) & FSDA))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int rcar_i2c_clock_calculate(struct rcar_i2c_priv *priv, struct i2c_timings *t)\r\n{\r\nu32 scgd, cdf, round, ick, sum, scl, cdf_width;\r\nunsigned long rate;\r\nstruct device *dev = rcar_i2c_priv_to_dev(priv);\r\nt->bus_freq_hz = t->bus_freq_hz ?: 100000;\r\nt->scl_fall_ns = t->scl_fall_ns ?: 35;\r\nt->scl_rise_ns = t->scl_rise_ns ?: 200;\r\nt->scl_int_delay_ns = t->scl_int_delay_ns ?: 50;\r\nswitch (priv->devtype) {\r\ncase I2C_RCAR_GEN1:\r\ncdf_width = 2;\r\nbreak;\r\ncase I2C_RCAR_GEN2:\r\ncase I2C_RCAR_GEN3:\r\ncdf_width = 3;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "device type error\n");\r\nreturn -EIO;\r\n}\r\nrate = clk_get_rate(priv->clk);\r\ncdf = rate / 20000000;\r\nif (cdf >= 1U << cdf_width) {\r\ndev_err(dev, "Input clock %lu too high\n", rate);\r\nreturn -EIO;\r\n}\r\nick = rate / (cdf + 1);\r\nsum = t->scl_fall_ns + t->scl_rise_ns + t->scl_int_delay_ns;\r\nround = (ick + 500000) / 1000000 * sum;\r\nround = (round + 500) / 1000;\r\nfor (scgd = 0; scgd < 0x40; scgd++) {\r\nscl = ick / (20 + (scgd * 8) + round);\r\nif (scl <= t->bus_freq_hz)\r\ngoto scgd_find;\r\n}\r\ndev_err(dev, "it is impossible to calculate best SCL\n");\r\nreturn -EIO;\r\nscgd_find:\r\ndev_dbg(dev, "clk %d/%d(%lu), round %u, CDF:0x%x, SCGD: 0x%x\n",\r\nscl, t->bus_freq_hz, clk_get_rate(priv->clk), round, cdf, scgd);\r\npriv->icccr = scgd << cdf_width | cdf;\r\nreturn 0;\r\n}\r\nstatic void rcar_i2c_prepare_msg(struct rcar_i2c_priv *priv)\r\n{\r\nint read = !!rcar_i2c_is_recv(priv);\r\npriv->pos = 0;\r\nif (priv->msgs_left == 1)\r\npriv->flags |= ID_LAST_MSG;\r\nrcar_i2c_write(priv, ICMAR, (priv->msg->addr << 1) | read);\r\nif (priv->flags & ID_FIRST_MSG) {\r\nrcar_i2c_write(priv, ICMSR, 0);\r\nrcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_START);\r\n} else {\r\nrcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_START);\r\nrcar_i2c_write(priv, ICMSR, 0);\r\n}\r\nrcar_i2c_write(priv, ICMIER, read ? RCAR_IRQ_RECV : RCAR_IRQ_SEND);\r\n}\r\nstatic void rcar_i2c_next_msg(struct rcar_i2c_priv *priv)\r\n{\r\npriv->msg++;\r\npriv->msgs_left--;\r\npriv->flags &= ID_P_MASK;\r\nrcar_i2c_prepare_msg(priv);\r\n}\r\nstatic void rcar_i2c_dma_unmap(struct rcar_i2c_priv *priv)\r\n{\r\nstruct dma_chan *chan = priv->dma_direction == DMA_FROM_DEVICE\r\n? priv->dma_rx : priv->dma_tx;\r\nrcar_i2c_write(priv, ICDMAER, 0);\r\nrcar_i2c_write(priv, ICFBSCR, TCYC06);\r\ndma_unmap_single(chan->device->dev, sg_dma_address(&priv->sg),\r\npriv->msg->len, priv->dma_direction);\r\npriv->dma_direction = DMA_NONE;\r\n}\r\nstatic void rcar_i2c_cleanup_dma(struct rcar_i2c_priv *priv)\r\n{\r\nif (priv->dma_direction == DMA_NONE)\r\nreturn;\r\nelse if (priv->dma_direction == DMA_FROM_DEVICE)\r\ndmaengine_terminate_all(priv->dma_rx);\r\nelse if (priv->dma_direction == DMA_TO_DEVICE)\r\ndmaengine_terminate_all(priv->dma_tx);\r\nrcar_i2c_dma_unmap(priv);\r\n}\r\nstatic void rcar_i2c_dma_callback(void *data)\r\n{\r\nstruct rcar_i2c_priv *priv = data;\r\npriv->pos += sg_dma_len(&priv->sg);\r\nrcar_i2c_dma_unmap(priv);\r\n}\r\nstatic void rcar_i2c_dma(struct rcar_i2c_priv *priv)\r\n{\r\nstruct device *dev = rcar_i2c_priv_to_dev(priv);\r\nstruct i2c_msg *msg = priv->msg;\r\nbool read = msg->flags & I2C_M_RD;\r\nenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nstruct dma_chan *chan = read ? priv->dma_rx : priv->dma_tx;\r\nstruct dma_async_tx_descriptor *txdesc;\r\ndma_addr_t dma_addr;\r\ndma_cookie_t cookie;\r\nunsigned char *buf;\r\nint len;\r\nif (IS_ERR(chan) || msg->len < 8)\r\nreturn;\r\nif (read) {\r\nbuf = priv->msg->buf;\r\nlen = priv->msg->len - 2;\r\n} else {\r\nbuf = priv->msg->buf + 1;\r\nlen = priv->msg->len - 1;\r\n}\r\ndma_addr = dma_map_single(chan->device->dev, buf, len, dir);\r\nif (dma_mapping_error(chan->device->dev, dma_addr)) {\r\ndev_dbg(dev, "dma map failed, using PIO\n");\r\nreturn;\r\n}\r\nsg_dma_len(&priv->sg) = len;\r\nsg_dma_address(&priv->sg) = dma_addr;\r\npriv->dma_direction = dir;\r\ntxdesc = dmaengine_prep_slave_sg(chan, &priv->sg, 1,\r\nread ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc) {\r\ndev_dbg(dev, "dma prep slave sg failed, using PIO\n");\r\nrcar_i2c_cleanup_dma(priv);\r\nreturn;\r\n}\r\ntxdesc->callback = rcar_i2c_dma_callback;\r\ntxdesc->callback_param = priv;\r\ncookie = dmaengine_submit(txdesc);\r\nif (dma_submit_error(cookie)) {\r\ndev_dbg(dev, "submitting dma failed, using PIO\n");\r\nrcar_i2c_cleanup_dma(priv);\r\nreturn;\r\n}\r\nrcar_i2c_write(priv, ICFBSCR, TCYC17);\r\nif (read)\r\nrcar_i2c_write(priv, ICDMAER, RMDMAE);\r\nelse\r\nrcar_i2c_write(priv, ICDMAER, TMDMAE);\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void rcar_i2c_irq_send(struct rcar_i2c_priv *priv, u32 msr)\r\n{\r\nstruct i2c_msg *msg = priv->msg;\r\nif (!(msr & MDE))\r\nreturn;\r\nif (priv->pos < msg->len) {\r\nrcar_i2c_write(priv, ICRXTX, msg->buf[priv->pos]);\r\npriv->pos++;\r\nif (msr & MAT)\r\nrcar_i2c_dma(priv);\r\n} else {\r\nif (priv->flags & ID_LAST_MSG) {\r\nrcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_STOP);\r\n} else {\r\nrcar_i2c_next_msg(priv);\r\nreturn;\r\n}\r\n}\r\nrcar_i2c_write(priv, ICMSR, RCAR_IRQ_ACK_SEND);\r\n}\r\nstatic void rcar_i2c_irq_recv(struct rcar_i2c_priv *priv, u32 msr)\r\n{\r\nstruct i2c_msg *msg = priv->msg;\r\nif (!(msr & MDR))\r\nreturn;\r\nif (msr & MAT) {\r\nrcar_i2c_dma(priv);\r\n} else if (priv->pos < msg->len) {\r\nmsg->buf[priv->pos] = rcar_i2c_read(priv, ICRXTX);\r\npriv->pos++;\r\n}\r\nif (priv->pos + 1 >= msg->len)\r\nrcar_i2c_write(priv, ICMCR, RCAR_BUS_PHASE_STOP);\r\nif (priv->pos == msg->len && !(priv->flags & ID_LAST_MSG))\r\nrcar_i2c_next_msg(priv);\r\nelse\r\nrcar_i2c_write(priv, ICMSR, RCAR_IRQ_ACK_RECV);\r\n}\r\nstatic bool rcar_i2c_slave_irq(struct rcar_i2c_priv *priv)\r\n{\r\nu32 ssr_raw, ssr_filtered;\r\nu8 value;\r\nssr_raw = rcar_i2c_read(priv, ICSSR) & 0xff;\r\nssr_filtered = ssr_raw & rcar_i2c_read(priv, ICSIER);\r\nif (!ssr_filtered)\r\nreturn false;\r\nif (ssr_filtered & SAR) {\r\nif (ssr_raw & STM) {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_READ_REQUESTED, &value);\r\nrcar_i2c_write(priv, ICRXTX, value);\r\nrcar_i2c_write(priv, ICSIER, SDE | SSR | SAR);\r\n} else {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_WRITE_REQUESTED, &value);\r\nrcar_i2c_read(priv, ICRXTX);\r\nrcar_i2c_write(priv, ICSIER, SDR | SSR | SAR);\r\n}\r\nrcar_i2c_write(priv, ICSSR, ~SAR & 0xff);\r\n}\r\nif (ssr_filtered & SSR) {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_STOP, &value);\r\nrcar_i2c_write(priv, ICSIER, SAR | SSR);\r\nrcar_i2c_write(priv, ICSSR, ~SSR & 0xff);\r\n}\r\nif (ssr_filtered & SDR) {\r\nint ret;\r\nvalue = rcar_i2c_read(priv, ICRXTX);\r\nret = i2c_slave_event(priv->slave, I2C_SLAVE_WRITE_RECEIVED, &value);\r\nrcar_i2c_write(priv, ICSCR, SIE | SDBS | (ret < 0 ? FNA : 0));\r\nrcar_i2c_write(priv, ICSSR, ~SDR & 0xff);\r\n}\r\nif (ssr_filtered & SDE) {\r\ni2c_slave_event(priv->slave, I2C_SLAVE_READ_PROCESSED, &value);\r\nrcar_i2c_write(priv, ICRXTX, value);\r\nrcar_i2c_write(priv, ICSSR, ~SDE & 0xff);\r\n}\r\nreturn true;\r\n}\r\nstatic irqreturn_t rcar_i2c_irq(int irq, void *ptr)\r\n{\r\nstruct rcar_i2c_priv *priv = ptr;\r\nu32 msr, val;\r\nval = rcar_i2c_read(priv, ICMCR);\r\nrcar_i2c_write(priv, ICMCR, val & RCAR_BUS_MASK_DATA);\r\nmsr = rcar_i2c_read(priv, ICMSR);\r\nmsr &= rcar_i2c_read(priv, ICMIER);\r\nif (!msr) {\r\nif (rcar_i2c_slave_irq(priv))\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nif (msr & MAL) {\r\npriv->flags |= ID_DONE | ID_ARBLOST;\r\ngoto out;\r\n}\r\nif (msr & MNR) {\r\nrcar_i2c_write(priv, ICMIER, RCAR_IRQ_STOP);\r\npriv->flags |= ID_NACK;\r\ngoto out;\r\n}\r\nif (msr & MST) {\r\npriv->msgs_left--;\r\npriv->flags |= ID_DONE;\r\ngoto out;\r\n}\r\nif (rcar_i2c_is_recv(priv))\r\nrcar_i2c_irq_recv(priv, msr);\r\nelse\r\nrcar_i2c_irq_send(priv, msr);\r\nout:\r\nif (priv->flags & ID_DONE) {\r\nrcar_i2c_write(priv, ICMIER, 0);\r\nrcar_i2c_write(priv, ICMSR, 0);\r\nwake_up(&priv->wait);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct dma_chan *rcar_i2c_request_dma_chan(struct device *dev,\r\nenum dma_transfer_direction dir,\r\ndma_addr_t port_addr)\r\n{\r\nstruct dma_chan *chan;\r\nstruct dma_slave_config cfg;\r\nchar *chan_name = dir == DMA_MEM_TO_DEV ? "tx" : "rx";\r\nint ret;\r\nchan = dma_request_chan(dev, chan_name);\r\nif (IS_ERR(chan)) {\r\nret = PTR_ERR(chan);\r\ndev_dbg(dev, "request_channel failed for %s (%d)\n",\r\nchan_name, ret);\r\nreturn chan;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.direction = dir;\r\nif (dir == DMA_MEM_TO_DEV) {\r\ncfg.dst_addr = port_addr;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n} else {\r\ncfg.src_addr = port_addr;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n}\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret) {\r\ndev_dbg(dev, "slave_config failed for %s (%d)\n",\r\nchan_name, ret);\r\ndma_release_channel(chan);\r\nreturn ERR_PTR(ret);\r\n}\r\ndev_dbg(dev, "got DMA channel for %s\n", chan_name);\r\nreturn chan;\r\n}\r\nstatic void rcar_i2c_request_dma(struct rcar_i2c_priv *priv,\r\nstruct i2c_msg *msg)\r\n{\r\nstruct device *dev = rcar_i2c_priv_to_dev(priv);\r\nbool read;\r\nstruct dma_chan *chan;\r\nenum dma_transfer_direction dir;\r\nread = msg->flags & I2C_M_RD;\r\nchan = read ? priv->dma_rx : priv->dma_tx;\r\nif (PTR_ERR(chan) != -EPROBE_DEFER)\r\nreturn;\r\ndir = read ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\r\nchan = rcar_i2c_request_dma_chan(dev, dir, priv->res->start + ICRXTX);\r\nif (read)\r\npriv->dma_rx = chan;\r\nelse\r\npriv->dma_tx = chan;\r\n}\r\nstatic void rcar_i2c_release_dma(struct rcar_i2c_priv *priv)\r\n{\r\nif (!IS_ERR(priv->dma_tx)) {\r\ndma_release_channel(priv->dma_tx);\r\npriv->dma_tx = ERR_PTR(-EPROBE_DEFER);\r\n}\r\nif (!IS_ERR(priv->dma_rx)) {\r\ndma_release_channel(priv->dma_rx);\r\npriv->dma_rx = ERR_PTR(-EPROBE_DEFER);\r\n}\r\n}\r\nstatic int rcar_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct rcar_i2c_priv *priv = i2c_get_adapdata(adap);\r\nstruct device *dev = rcar_i2c_priv_to_dev(priv);\r\nint i, ret;\r\nlong time_left;\r\npm_runtime_get_sync(dev);\r\nret = rcar_i2c_bus_barrier(priv);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < num; i++) {\r\nif (msgs[i].len == 0) {\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrcar_i2c_request_dma(priv, msgs + i);\r\n}\r\npriv->msg = msgs;\r\npriv->msgs_left = num;\r\npriv->flags = (priv->flags & ID_P_MASK) | ID_FIRST_MSG;\r\nrcar_i2c_prepare_msg(priv);\r\ntime_left = wait_event_timeout(priv->wait, priv->flags & ID_DONE,\r\nnum * adap->timeout);\r\nif (!time_left) {\r\nrcar_i2c_cleanup_dma(priv);\r\nrcar_i2c_init(priv);\r\nret = -ETIMEDOUT;\r\n} else if (priv->flags & ID_NACK) {\r\nret = -ENXIO;\r\n} else if (priv->flags & ID_ARBLOST) {\r\nret = -EAGAIN;\r\n} else {\r\nret = num - priv->msgs_left;\r\n}\r\nout:\r\npm_runtime_put(dev);\r\nif (ret < 0 && ret != -ENXIO)\r\ndev_err(dev, "error %d : %x\n", ret, priv->flags);\r\nreturn ret;\r\n}\r\nstatic int rcar_reg_slave(struct i2c_client *slave)\r\n{\r\nstruct rcar_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\r\nif (priv->slave)\r\nreturn -EBUSY;\r\nif (slave->flags & I2C_CLIENT_TEN)\r\nreturn -EAFNOSUPPORT;\r\npm_runtime_get_sync(rcar_i2c_priv_to_dev(priv));\r\npriv->slave = slave;\r\nrcar_i2c_write(priv, ICSAR, slave->addr);\r\nrcar_i2c_write(priv, ICSSR, 0);\r\nrcar_i2c_write(priv, ICSIER, SAR | SSR);\r\nrcar_i2c_write(priv, ICSCR, SIE | SDBS);\r\nreturn 0;\r\n}\r\nstatic int rcar_unreg_slave(struct i2c_client *slave)\r\n{\r\nstruct rcar_i2c_priv *priv = i2c_get_adapdata(slave->adapter);\r\nWARN_ON(!priv->slave);\r\nrcar_i2c_write(priv, ICSIER, 0);\r\nrcar_i2c_write(priv, ICSCR, 0);\r\npriv->slave = NULL;\r\npm_runtime_put(rcar_i2c_priv_to_dev(priv));\r\nreturn 0;\r\n}\r\nstatic u32 rcar_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SLAVE |\r\n(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic int rcar_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_i2c_priv *priv;\r\nstruct i2c_adapter *adap;\r\nstruct device *dev = &pdev->dev;\r\nstruct i2c_timings i2c_t;\r\nint irq, ret;\r\npriv = devm_kzalloc(dev, sizeof(struct rcar_i2c_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "cannot get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\npriv->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->io = devm_ioremap_resource(dev, priv->res);\r\nif (IS_ERR(priv->io))\r\nreturn PTR_ERR(priv->io);\r\npriv->devtype = (enum rcar_i2c_type)of_device_get_match_data(dev);\r\ninit_waitqueue_head(&priv->wait);\r\nadap = &priv->adap;\r\nadap->nr = pdev->id;\r\nadap->algo = &rcar_i2c_algo;\r\nadap->class = I2C_CLASS_DEPRECATED;\r\nadap->retries = 3;\r\nadap->dev.parent = dev;\r\nadap->dev.of_node = dev->of_node;\r\ni2c_set_adapdata(adap, priv);\r\nstrlcpy(adap->name, pdev->name, sizeof(adap->name));\r\ni2c_parse_fw_timings(dev, &i2c_t, false);\r\nsg_init_table(&priv->sg, 1);\r\npriv->dma_direction = DMA_NONE;\r\npriv->dma_rx = priv->dma_tx = ERR_PTR(-EPROBE_DEFER);\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nret = rcar_i2c_clock_calculate(priv, &i2c_t);\r\nif (ret < 0)\r\ngoto out_pm_put;\r\nrcar_i2c_init(priv);\r\nif (of_property_read_bool(dev->of_node, "multi-master"))\r\npriv->flags |= ID_P_PM_BLOCKED;\r\nelse\r\npm_runtime_put(dev);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(dev, irq, rcar_i2c_irq, 0, dev_name(dev), priv);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot get irq %d\n", irq);\r\ngoto out_pm_disable;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret < 0)\r\ngoto out_pm_disable;\r\ndev_info(dev, "probed\n");\r\nreturn 0;\r\nout_pm_put:\r\npm_runtime_put(dev);\r\nout_pm_disable:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int rcar_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_i2c_priv *priv = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\ni2c_del_adapter(&priv->adap);\r\nrcar_i2c_release_dma(priv);\r\nif (priv->flags & ID_P_PM_BLOCKED)\r\npm_runtime_put(dev);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}
