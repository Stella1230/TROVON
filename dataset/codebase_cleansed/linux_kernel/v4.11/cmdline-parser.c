static int parse_subpart(struct cmdline_subpart **subpart, char *partdef)\r\n{\r\nint ret = 0;\r\nstruct cmdline_subpart *new_subpart;\r\n*subpart = NULL;\r\nnew_subpart = kzalloc(sizeof(struct cmdline_subpart), GFP_KERNEL);\r\nif (!new_subpart)\r\nreturn -ENOMEM;\r\nif (*partdef == '-') {\r\nnew_subpart->size = (sector_t)(~0ULL);\r\npartdef++;\r\n} else {\r\nnew_subpart->size = (sector_t)memparse(partdef, &partdef);\r\nif (new_subpart->size < (sector_t)PAGE_SIZE) {\r\npr_warn("cmdline partition size is invalid.");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\n}\r\nif (*partdef == '@') {\r\npartdef++;\r\nnew_subpart->from = (sector_t)memparse(partdef, &partdef);\r\n} else {\r\nnew_subpart->from = (sector_t)(~0ULL);\r\n}\r\nif (*partdef == '(') {\r\nint length;\r\nchar *next = strchr(++partdef, ')');\r\nif (!next) {\r\npr_warn("cmdline partition format is invalid.");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nlength = min_t(int, next - partdef,\r\nsizeof(new_subpart->name) - 1);\r\nstrncpy(new_subpart->name, partdef, length);\r\nnew_subpart->name[length] = '\0';\r\npartdef = ++next;\r\n} else\r\nnew_subpart->name[0] = '\0';\r\nnew_subpart->flags = 0;\r\nif (!strncmp(partdef, "ro", 2)) {\r\nnew_subpart->flags |= PF_RDONLY;\r\npartdef += 2;\r\n}\r\nif (!strncmp(partdef, "lk", 2)) {\r\nnew_subpart->flags |= PF_POWERUP_LOCK;\r\npartdef += 2;\r\n}\r\n*subpart = new_subpart;\r\nreturn 0;\r\nfail:\r\nkfree(new_subpart);\r\nreturn ret;\r\n}\r\nstatic void free_subpart(struct cmdline_parts *parts)\r\n{\r\nstruct cmdline_subpart *subpart;\r\nwhile (parts->subpart) {\r\nsubpart = parts->subpart;\r\nparts->subpart = subpart->next_subpart;\r\nkfree(subpart);\r\n}\r\n}\r\nstatic int parse_parts(struct cmdline_parts **parts, const char *bdevdef)\r\n{\r\nint ret = -EINVAL;\r\nchar *next;\r\nint length;\r\nstruct cmdline_subpart **next_subpart;\r\nstruct cmdline_parts *newparts;\r\nchar buf[BDEVNAME_SIZE + 32 + 4];\r\n*parts = NULL;\r\nnewparts = kzalloc(sizeof(struct cmdline_parts), GFP_KERNEL);\r\nif (!newparts)\r\nreturn -ENOMEM;\r\nnext = strchr(bdevdef, ':');\r\nif (!next) {\r\npr_warn("cmdline partition has no block device.");\r\ngoto fail;\r\n}\r\nlength = min_t(int, next - bdevdef, sizeof(newparts->name) - 1);\r\nstrncpy(newparts->name, bdevdef, length);\r\nnewparts->name[length] = '\0';\r\nnewparts->nr_subparts = 0;\r\nnext_subpart = &newparts->subpart;\r\nwhile (next && *(++next)) {\r\nbdevdef = next;\r\nnext = strchr(bdevdef, ',');\r\nlength = (!next) ? (sizeof(buf) - 1) :\r\nmin_t(int, next - bdevdef, sizeof(buf) - 1);\r\nstrncpy(buf, bdevdef, length);\r\nbuf[length] = '\0';\r\nret = parse_subpart(next_subpart, buf);\r\nif (ret)\r\ngoto fail;\r\nnewparts->nr_subparts++;\r\nnext_subpart = &(*next_subpart)->next_subpart;\r\n}\r\nif (!newparts->subpart) {\r\npr_warn("cmdline partition has no valid partition.");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\n*parts = newparts;\r\nreturn 0;\r\nfail:\r\nfree_subpart(newparts);\r\nkfree(newparts);\r\nreturn ret;\r\n}\r\nvoid cmdline_parts_free(struct cmdline_parts **parts)\r\n{\r\nstruct cmdline_parts *next_parts;\r\nwhile (*parts) {\r\nnext_parts = (*parts)->next_parts;\r\nfree_subpart(*parts);\r\nkfree(*parts);\r\n*parts = next_parts;\r\n}\r\n}\r\nint cmdline_parts_parse(struct cmdline_parts **parts, const char *cmdline)\r\n{\r\nint ret;\r\nchar *buf;\r\nchar *pbuf;\r\nchar *next;\r\nstruct cmdline_parts **next_parts;\r\n*parts = NULL;\r\nnext = pbuf = buf = kstrdup(cmdline, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nnext_parts = parts;\r\nwhile (next && *pbuf) {\r\nnext = strchr(pbuf, ';');\r\nif (next)\r\n*next = '\0';\r\nret = parse_parts(next_parts, pbuf);\r\nif (ret)\r\ngoto fail;\r\nif (next)\r\npbuf = ++next;\r\nnext_parts = &(*next_parts)->next_parts;\r\n}\r\nif (!*parts) {\r\npr_warn("cmdline partition has no valid partition.");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nret = 0;\r\ndone:\r\nkfree(buf);\r\nreturn ret;\r\nfail:\r\ncmdline_parts_free(parts);\r\ngoto done;\r\n}\r\nstruct cmdline_parts *cmdline_parts_find(struct cmdline_parts *parts,\r\nconst char *bdev)\r\n{\r\nwhile (parts && strncmp(bdev, parts->name, sizeof(parts->name)))\r\nparts = parts->next_parts;\r\nreturn parts;\r\n}\r\nint cmdline_parts_set(struct cmdline_parts *parts, sector_t disk_size,\r\nint slot,\r\nint (*add_part)(int, struct cmdline_subpart *, void *),\r\nvoid *param)\r\n{\r\nsector_t from = 0;\r\nstruct cmdline_subpart *subpart;\r\nfor (subpart = parts->subpart; subpart;\r\nsubpart = subpart->next_subpart, slot++) {\r\nif (subpart->from == (sector_t)(~0ULL))\r\nsubpart->from = from;\r\nelse\r\nfrom = subpart->from;\r\nif (from >= disk_size)\r\nbreak;\r\nif (subpart->size > (disk_size - from))\r\nsubpart->size = disk_size - from;\r\nfrom += subpart->size;\r\nif (add_part(slot, subpart, param))\r\nbreak;\r\n}\r\nreturn slot;\r\n}
