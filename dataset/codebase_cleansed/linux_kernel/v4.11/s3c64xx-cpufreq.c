static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct s3c64xx_dvfs *dvfs;\r\nunsigned int old_freq, new_freq;\r\nint ret;\r\nold_freq = clk_get_rate(policy->clk) / 1000;\r\nnew_freq = s3c64xx_freq_table[index].frequency;\r\ndvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[index].driver_data];\r\n#ifdef CONFIG_REGULATOR\r\nif (vddarm && new_freq > old_freq) {\r\nret = regulator_set_voltage(vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0) {\r\npr_err("Failed to set VDDARM for %dkHz: %d\n",\r\nnew_freq, ret);\r\nreturn ret;\r\n}\r\n}\r\n#endif\r\nret = clk_set_rate(policy->clk, new_freq * 1000);\r\nif (ret < 0) {\r\npr_err("Failed to set rate %dkHz: %d\n",\r\nnew_freq, ret);\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_REGULATOR\r\nif (vddarm && new_freq < old_freq) {\r\nret = regulator_set_voltage(vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0) {\r\npr_err("Failed to set VDDARM for %dkHz: %d\n",\r\nnew_freq, ret);\r\nif (clk_set_rate(policy->clk, old_freq * 1000) < 0)\r\npr_err("Failed to restore original clock rate\n");\r\nreturn ret;\r\n}\r\n}\r\n#endif\r\npr_debug("Set actual frequency %lukHz\n",\r\nclk_get_rate(policy->clk) / 1000);\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_cpufreq_config_regulator(void)\r\n{\r\nint count, v, i, found;\r\nstruct cpufreq_frequency_table *freq;\r\nstruct s3c64xx_dvfs *dvfs;\r\ncount = regulator_count_voltages(vddarm);\r\nif (count < 0) {\r\npr_err("Unable to check supported voltages\n");\r\n}\r\nif (!count)\r\ngoto out;\r\ncpufreq_for_each_valid_entry(freq, s3c64xx_freq_table) {\r\ndvfs = &s3c64xx_dvfs_table[freq->driver_data];\r\nfound = 0;\r\nfor (i = 0; i < count; i++) {\r\nv = regulator_list_voltage(vddarm, i);\r\nif (v >= dvfs->vddarm_min && v <= dvfs->vddarm_max)\r\nfound = 1;\r\n}\r\nif (!found) {\r\npr_debug("%dkHz unsupported by regulator\n",\r\nfreq->frequency);\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\n}\r\nout:\r\nregulator_latency = 1 * 1000 * 1000;\r\n}\r\nstatic int s3c64xx_cpufreq_driver_init(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\nstruct cpufreq_frequency_table *freq;\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\nif (s3c64xx_freq_table == NULL) {\r\npr_err("No frequency information for this CPU\n");\r\nreturn -ENODEV;\r\n}\r\npolicy->clk = clk_get(NULL, "armclk");\r\nif (IS_ERR(policy->clk)) {\r\npr_err("Unable to obtain ARMCLK: %ld\n",\r\nPTR_ERR(policy->clk));\r\nreturn PTR_ERR(policy->clk);\r\n}\r\n#ifdef CONFIG_REGULATOR\r\nvddarm = regulator_get(NULL, "vddarm");\r\nif (IS_ERR(vddarm)) {\r\nret = PTR_ERR(vddarm);\r\npr_err("Failed to obtain VDDARM: %d\n", ret);\r\npr_err("Only frequency scaling available\n");\r\nvddarm = NULL;\r\n} else {\r\ns3c64xx_cpufreq_config_regulator();\r\n}\r\n#endif\r\ncpufreq_for_each_entry(freq, s3c64xx_freq_table) {\r\nunsigned long r;\r\nr = clk_round_rate(policy->clk, freq->frequency * 1000);\r\nr /= 1000;\r\nif (r != freq->frequency) {\r\npr_debug("%dkHz unsupported by clock\n",\r\nfreq->frequency);\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nif (!vddarm && freq->frequency > clk_get_rate(policy->clk) / 1000)\r\nfreq->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nret = cpufreq_generic_init(policy, s3c64xx_freq_table,\r\n(500 * 1000) + regulator_latency);\r\nif (ret != 0) {\r\npr_err("Failed to configure frequency table: %d\n",\r\nret);\r\nregulator_put(vddarm);\r\nclk_put(policy->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init s3c64xx_cpufreq_init(void)\r\n{\r\nreturn cpufreq_register_driver(&s3c64xx_cpufreq_driver);\r\n}
