static inline int node_is_left_child(struct interval_node *node)\r\n{\r\nreturn node == node->in_parent->in_left;\r\n}\r\nstatic inline int node_is_right_child(struct interval_node *node)\r\n{\r\nreturn node == node->in_parent->in_right;\r\n}\r\nstatic inline int node_is_red(struct interval_node *node)\r\n{\r\nreturn node->in_color == INTERVAL_RED;\r\n}\r\nstatic inline int node_is_black(struct interval_node *node)\r\n{\r\nreturn node->in_color == INTERVAL_BLACK;\r\n}\r\nstatic inline int extent_compare(struct interval_node_extent *e1,\r\nstruct interval_node_extent *e2)\r\n{\r\nint rc;\r\nif (e1->start == e2->start) {\r\nif (e1->end < e2->end)\r\nrc = -1;\r\nelse if (e1->end > e2->end)\r\nrc = 1;\r\nelse\r\nrc = 0;\r\n} else {\r\nif (e1->start < e2->start)\r\nrc = -1;\r\nelse\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline int extent_equal(struct interval_node_extent *e1,\r\nstruct interval_node_extent *e2)\r\n{\r\nreturn (e1->start == e2->start) && (e1->end == e2->end);\r\n}\r\nstatic inline int extent_overlapped(struct interval_node_extent *e1,\r\nstruct interval_node_extent *e2)\r\n{\r\nreturn (e1->start <= e2->end) && (e2->start <= e1->end);\r\n}\r\nstatic inline int node_equal(struct interval_node *n1, struct interval_node *n2)\r\n{\r\nreturn extent_equal(&n1->in_extent, &n2->in_extent);\r\n}\r\nstatic inline __u64 max_u64(__u64 x, __u64 y)\r\n{\r\nreturn x > y ? x : y;\r\n}\r\nstatic struct interval_node *interval_first(struct interval_node *node)\r\n{\r\nif (!node)\r\nreturn NULL;\r\nwhile (node->in_left)\r\nnode = node->in_left;\r\nreturn node;\r\n}\r\nstatic struct interval_node *interval_next(struct interval_node *node)\r\n{\r\nif (!node)\r\nreturn NULL;\r\nif (node->in_right)\r\nreturn interval_first(node->in_right);\r\nwhile (node->in_parent && node_is_right_child(node))\r\nnode = node->in_parent;\r\nreturn node->in_parent;\r\n}\r\nstatic void __rotate_change_maxhigh(struct interval_node *node,\r\nstruct interval_node *rotate)\r\n{\r\n__u64 left_max, right_max;\r\nrotate->in_max_high = node->in_max_high;\r\nleft_max = node->in_left ? node->in_left->in_max_high : 0;\r\nright_max = node->in_right ? node->in_right->in_max_high : 0;\r\nnode->in_max_high = max_u64(interval_high(node),\r\nmax_u64(left_max, right_max));\r\n}\r\nstatic void __rotate_left(struct interval_node *node,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node *right = node->in_right;\r\nstruct interval_node *parent = node->in_parent;\r\nnode->in_right = right->in_left;\r\nif (node->in_right)\r\nright->in_left->in_parent = node;\r\nright->in_left = node;\r\nright->in_parent = parent;\r\nif (parent) {\r\nif (node_is_left_child(node))\r\nparent->in_left = right;\r\nelse\r\nparent->in_right = right;\r\n} else {\r\n*root = right;\r\n}\r\nnode->in_parent = right;\r\n__rotate_change_maxhigh(node, right);\r\n}\r\nstatic void __rotate_right(struct interval_node *node,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node *left = node->in_left;\r\nstruct interval_node *parent = node->in_parent;\r\nnode->in_left = left->in_right;\r\nif (node->in_left)\r\nleft->in_right->in_parent = node;\r\nleft->in_right = node;\r\nleft->in_parent = parent;\r\nif (parent) {\r\nif (node_is_right_child(node))\r\nparent->in_right = left;\r\nelse\r\nparent->in_left = left;\r\n} else {\r\n*root = left;\r\n}\r\nnode->in_parent = left;\r\n__rotate_change_maxhigh(node, left);\r\n}\r\nstatic void interval_insert_color(struct interval_node *node,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node *parent, *gparent;\r\nwhile ((parent = node->in_parent) && node_is_red(parent)) {\r\ngparent = parent->in_parent;\r\nif (node_is_left_child(parent)) {\r\nstruct interval_node *uncle;\r\nuncle = gparent->in_right;\r\nif (uncle && node_is_red(uncle)) {\r\nuncle->in_color = INTERVAL_BLACK;\r\nparent->in_color = INTERVAL_BLACK;\r\ngparent->in_color = INTERVAL_RED;\r\nnode = gparent;\r\ncontinue;\r\n}\r\nif (parent->in_right == node) {\r\n__rotate_left(parent, root);\r\ninterval_swap(node, parent);\r\n}\r\nparent->in_color = INTERVAL_BLACK;\r\ngparent->in_color = INTERVAL_RED;\r\n__rotate_right(gparent, root);\r\n} else {\r\nstruct interval_node *uncle;\r\nuncle = gparent->in_left;\r\nif (uncle && node_is_red(uncle)) {\r\nuncle->in_color = INTERVAL_BLACK;\r\nparent->in_color = INTERVAL_BLACK;\r\ngparent->in_color = INTERVAL_RED;\r\nnode = gparent;\r\ncontinue;\r\n}\r\nif (node_is_left_child(node)) {\r\n__rotate_right(parent, root);\r\ninterval_swap(node, parent);\r\n}\r\nparent->in_color = INTERVAL_BLACK;\r\ngparent->in_color = INTERVAL_RED;\r\n__rotate_left(gparent, root);\r\n}\r\n}\r\n(*root)->in_color = INTERVAL_BLACK;\r\n}\r\nstruct interval_node *interval_insert(struct interval_node *node,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node **p, *parent = NULL;\r\nLASSERT(!interval_is_intree(node));\r\np = root;\r\nwhile (*p) {\r\nparent = *p;\r\nif (node_equal(parent, node))\r\nreturn parent;\r\nif (parent->in_max_high < interval_high(node))\r\nparent->in_max_high = interval_high(node);\r\nif (extent_compare(&node->in_extent, &parent->in_extent) < 0)\r\np = &parent->in_left;\r\nelse\r\np = &parent->in_right;\r\n}\r\nnode->in_parent = parent;\r\nnode->in_color = INTERVAL_RED;\r\nnode->in_left = NULL;\r\nnode->in_right = NULL;\r\n*p = node;\r\ninterval_insert_color(node, root);\r\nnode->in_intree = 1;\r\nreturn NULL;\r\n}\r\nstatic inline int node_is_black_or_0(struct interval_node *node)\r\n{\r\nreturn !node || node_is_black(node);\r\n}\r\nstatic void interval_erase_color(struct interval_node *node,\r\nstruct interval_node *parent,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node *tmp;\r\nwhile (node_is_black_or_0(node) && node != *root) {\r\nif (parent->in_left == node) {\r\ntmp = parent->in_right;\r\nif (node_is_red(tmp)) {\r\ntmp->in_color = INTERVAL_BLACK;\r\nparent->in_color = INTERVAL_RED;\r\n__rotate_left(parent, root);\r\ntmp = parent->in_right;\r\n}\r\nif (node_is_black_or_0(tmp->in_left) &&\r\nnode_is_black_or_0(tmp->in_right)) {\r\ntmp->in_color = INTERVAL_RED;\r\nnode = parent;\r\nparent = node->in_parent;\r\n} else {\r\nif (node_is_black_or_0(tmp->in_right)) {\r\nstruct interval_node *o_left;\r\no_left = tmp->in_left;\r\nif (o_left)\r\no_left->in_color = INTERVAL_BLACK;\r\ntmp->in_color = INTERVAL_RED;\r\n__rotate_right(tmp, root);\r\ntmp = parent->in_right;\r\n}\r\ntmp->in_color = parent->in_color;\r\nparent->in_color = INTERVAL_BLACK;\r\nif (tmp->in_right)\r\ntmp->in_right->in_color = INTERVAL_BLACK;\r\n__rotate_left(parent, root);\r\nnode = *root;\r\nbreak;\r\n}\r\n} else {\r\ntmp = parent->in_left;\r\nif (node_is_red(tmp)) {\r\ntmp->in_color = INTERVAL_BLACK;\r\nparent->in_color = INTERVAL_RED;\r\n__rotate_right(parent, root);\r\ntmp = parent->in_left;\r\n}\r\nif (node_is_black_or_0(tmp->in_left) &&\r\nnode_is_black_or_0(tmp->in_right)) {\r\ntmp->in_color = INTERVAL_RED;\r\nnode = parent;\r\nparent = node->in_parent;\r\n} else {\r\nif (node_is_black_or_0(tmp->in_left)) {\r\nstruct interval_node *o_right;\r\no_right = tmp->in_right;\r\nif (o_right)\r\no_right->in_color = INTERVAL_BLACK;\r\ntmp->in_color = INTERVAL_RED;\r\n__rotate_left(tmp, root);\r\ntmp = parent->in_left;\r\n}\r\ntmp->in_color = parent->in_color;\r\nparent->in_color = INTERVAL_BLACK;\r\nif (tmp->in_left)\r\ntmp->in_left->in_color = INTERVAL_BLACK;\r\n__rotate_right(parent, root);\r\nnode = *root;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (node)\r\nnode->in_color = INTERVAL_BLACK;\r\n}\r\nstatic void update_maxhigh(struct interval_node *node,\r\n__u64 old_maxhigh)\r\n{\r\n__u64 left_max, right_max;\r\nwhile (node) {\r\nleft_max = node->in_left ? node->in_left->in_max_high : 0;\r\nright_max = node->in_right ? node->in_right->in_max_high : 0;\r\nnode->in_max_high = max_u64(interval_high(node),\r\nmax_u64(left_max, right_max));\r\nif (node->in_max_high >= old_maxhigh)\r\nbreak;\r\nnode = node->in_parent;\r\n}\r\n}\r\nvoid interval_erase(struct interval_node *node,\r\nstruct interval_node **root)\r\n{\r\nstruct interval_node *child, *parent;\r\nint color;\r\nLASSERT(interval_is_intree(node));\r\nnode->in_intree = 0;\r\nif (!node->in_left) {\r\nchild = node->in_right;\r\n} else if (!node->in_right) {\r\nchild = node->in_left;\r\n} else {\r\nstruct interval_node *old = node;\r\nnode = interval_next(node);\r\nchild = node->in_right;\r\nparent = node->in_parent;\r\ncolor = node->in_color;\r\nif (child)\r\nchild->in_parent = parent;\r\nif (parent == old)\r\nparent->in_right = child;\r\nelse\r\nparent->in_left = child;\r\nnode->in_color = old->in_color;\r\nnode->in_right = old->in_right;\r\nnode->in_left = old->in_left;\r\nnode->in_parent = old->in_parent;\r\nif (old->in_parent) {\r\nif (node_is_left_child(old))\r\nold->in_parent->in_left = node;\r\nelse\r\nold->in_parent->in_right = node;\r\n} else {\r\n*root = node;\r\n}\r\nold->in_left->in_parent = node;\r\nif (old->in_right)\r\nold->in_right->in_parent = node;\r\nupdate_maxhigh(child ? : parent, node->in_max_high);\r\nupdate_maxhigh(node, old->in_max_high);\r\nif (parent == old)\r\nparent = node;\r\ngoto color;\r\n}\r\nparent = node->in_parent;\r\ncolor = node->in_color;\r\nif (child)\r\nchild->in_parent = parent;\r\nif (parent) {\r\nif (node_is_left_child(node))\r\nparent->in_left = child;\r\nelse\r\nparent->in_right = child;\r\n} else {\r\n*root = child;\r\n}\r\nupdate_maxhigh(child ? : parent, node->in_max_high);\r\ncolor:\r\nif (color == INTERVAL_BLACK)\r\ninterval_erase_color(child, parent, root);\r\n}\r\nstatic inline int interval_may_overlap(struct interval_node *node,\r\nstruct interval_node_extent *ext)\r\n{\r\nreturn (ext->start <= node->in_max_high &&\r\next->end >= interval_low(node));\r\n}\r\nenum interval_iter interval_search(struct interval_node *node,\r\nstruct interval_node_extent *ext,\r\ninterval_callback_t func,\r\nvoid *data)\r\n{\r\nenum interval_iter rc = INTERVAL_ITER_CONT;\r\nstruct interval_node *parent;\r\nLASSERT(ext);\r\nLASSERT(func);\r\nwhile (node) {\r\nif (ext->end < interval_low(node)) {\r\nif (node->in_left) {\r\nnode = node->in_left;\r\ncontinue;\r\n}\r\n} else if (interval_may_overlap(node, ext)) {\r\nif (extent_overlapped(ext, &node->in_extent)) {\r\nrc = func(node, data);\r\nif (rc == INTERVAL_ITER_STOP)\r\nbreak;\r\n}\r\nif (node->in_left) {\r\nnode = node->in_left;\r\ncontinue;\r\n}\r\nif (node->in_right) {\r\nnode = node->in_right;\r\ncontinue;\r\n}\r\n}\r\nparent = node->in_parent;\r\nwhile (parent) {\r\nif (node_is_left_child(node) &&\r\nparent->in_right) {\r\nnode = parent->in_right;\r\nbreak;\r\n}\r\nnode = parent;\r\nparent = parent->in_parent;\r\n}\r\nif (!parent || !interval_may_overlap(parent, ext))\r\nbreak;\r\n}\r\nreturn rc;\r\n}
