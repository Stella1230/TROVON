static int snd_usbtv_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nchip->snd_substream = substream;\r\nruntime->hw = snd_usbtv_digital_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_usbtv_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nif (atomic_read(&chip->snd_stream)) {\r\natomic_set(&chip->snd_stream, 0);\r\nschedule_work(&chip->snd_trigger);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usbtv_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint rv;\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nrv = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (rv < 0) {\r\ndev_warn(chip->dev, "pcm audio buffer allocation failure %i\n",\r\nrv);\r\nreturn rv;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usbtv_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_usbtv_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nchip->snd_buffer_pos = 0;\r\nchip->snd_period_pos = 0;\r\nreturn 0;\r\n}\r\nstatic void usbtv_audio_urb_received(struct urb *urb)\r\n{\r\nstruct usbtv *chip = urb->context;\r\nstruct snd_pcm_substream *substream = chip->snd_substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsize_t i, frame_bytes, chunk_length, buffer_pos, period_pos;\r\nint period_elapsed;\r\nvoid *urb_current;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ENOENT:\r\ncase -EPROTO:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_warn(chip->dev, "unknown audio urb status %i\n",\r\nurb->status);\r\n}\r\nif (!atomic_read(&chip->snd_stream))\r\nreturn;\r\nframe_bytes = runtime->frame_bits >> 3;\r\nchunk_length = USBTV_CHUNK / frame_bytes;\r\nbuffer_pos = chip->snd_buffer_pos;\r\nperiod_pos = chip->snd_period_pos;\r\nperiod_elapsed = 0;\r\nfor (i = 0; i < urb->actual_length; i += USBTV_CHUNK_SIZE) {\r\nurb_current = urb->transfer_buffer + i + USBTV_AUDIO_HDRSIZE;\r\nif (buffer_pos + chunk_length >= runtime->buffer_size) {\r\nsize_t cnt = (runtime->buffer_size - buffer_pos) *\r\nframe_bytes;\r\nmemcpy(runtime->dma_area + buffer_pos * frame_bytes,\r\nurb_current, cnt);\r\nmemcpy(runtime->dma_area, urb_current + cnt,\r\nchunk_length * frame_bytes - cnt);\r\n} else {\r\nmemcpy(runtime->dma_area + buffer_pos * frame_bytes,\r\nurb_current, chunk_length * frame_bytes);\r\n}\r\nbuffer_pos += chunk_length;\r\nperiod_pos += chunk_length;\r\nif (buffer_pos >= runtime->buffer_size)\r\nbuffer_pos -= runtime->buffer_size;\r\nif (period_pos >= runtime->period_size) {\r\nperiod_pos -= runtime->period_size;\r\nperiod_elapsed = 1;\r\n}\r\n}\r\nsnd_pcm_stream_lock(substream);\r\nchip->snd_buffer_pos = buffer_pos;\r\nchip->snd_period_pos = period_pos;\r\nsnd_pcm_stream_unlock(substream);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(substream);\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int usbtv_audio_start(struct usbtv *chip)\r\n{\r\nunsigned int pipe;\r\nstatic const u16 setup[][2] = {\r\n{ USBTV_BASE + 0x0008, 0x0001 },\r\n{ USBTV_BASE + 0x01d0, 0x00ff },\r\n{ USBTV_BASE + 0x01d9, 0x0002 },\r\n{ USBTV_BASE + 0x01da, 0x0013 },\r\n{ USBTV_BASE + 0x01db, 0x0012 },\r\n{ USBTV_BASE + 0x01e9, 0x0002 },\r\n{ USBTV_BASE + 0x01ec, 0x006c },\r\n{ USBTV_BASE + 0x0294, 0x0020 },\r\n{ USBTV_BASE + 0x0255, 0x00cf },\r\n{ USBTV_BASE + 0x0256, 0x0020 },\r\n{ USBTV_BASE + 0x01eb, 0x0030 },\r\n{ USBTV_BASE + 0x027d, 0x00a6 },\r\n{ USBTV_BASE + 0x0280, 0x0011 },\r\n{ USBTV_BASE + 0x0281, 0x0040 },\r\n{ USBTV_BASE + 0x0282, 0x0011 },\r\n{ USBTV_BASE + 0x0283, 0x0040 },\r\n{ 0xf891, 0x0010 },\r\n{ USBTV_BASE + 0x0284, 0x00aa },\r\n};\r\nchip->snd_bulk_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (chip->snd_bulk_urb == NULL)\r\ngoto err_alloc_urb;\r\npipe = usb_rcvbulkpipe(chip->udev, USBTV_AUDIO_ENDP);\r\nchip->snd_bulk_urb->transfer_buffer = kzalloc(\r\nUSBTV_AUDIO_URBSIZE, GFP_KERNEL);\r\nif (chip->snd_bulk_urb->transfer_buffer == NULL)\r\ngoto err_transfer_buffer;\r\nusb_fill_bulk_urb(chip->snd_bulk_urb, chip->udev, pipe,\r\nchip->snd_bulk_urb->transfer_buffer, USBTV_AUDIO_URBSIZE,\r\nusbtv_audio_urb_received, chip);\r\nusbtv_set_regs(chip, setup, ARRAY_SIZE(setup));\r\nusb_clear_halt(chip->udev, pipe);\r\nusb_submit_urb(chip->snd_bulk_urb, GFP_ATOMIC);\r\nreturn 0;\r\nerr_transfer_buffer:\r\nusb_free_urb(chip->snd_bulk_urb);\r\nchip->snd_bulk_urb = NULL;\r\nerr_alloc_urb:\r\nreturn -ENOMEM;\r\n}\r\nstatic int usbtv_audio_stop(struct usbtv *chip)\r\n{\r\nstatic const u16 setup[][2] = {\r\n{ USBTV_BASE + 0x027d, 0x0000 },\r\n{ USBTV_BASE + 0x0280, 0x0010 },\r\n{ USBTV_BASE + 0x0282, 0x0010 },\r\n};\r\nif (chip->snd_bulk_urb) {\r\nusb_kill_urb(chip->snd_bulk_urb);\r\nkfree(chip->snd_bulk_urb->transfer_buffer);\r\nusb_free_urb(chip->snd_bulk_urb);\r\nchip->snd_bulk_urb = NULL;\r\n}\r\nusbtv_set_regs(chip, setup, ARRAY_SIZE(setup));\r\nreturn 0;\r\n}\r\nvoid usbtv_audio_suspend(struct usbtv *usbtv)\r\n{\r\nif (atomic_read(&usbtv->snd_stream) && usbtv->snd_bulk_urb)\r\nusb_kill_urb(usbtv->snd_bulk_urb);\r\n}\r\nvoid usbtv_audio_resume(struct usbtv *usbtv)\r\n{\r\nif (atomic_read(&usbtv->snd_stream) && usbtv->snd_bulk_urb)\r\nusb_submit_urb(usbtv->snd_bulk_urb, GFP_ATOMIC);\r\n}\r\nstatic void snd_usbtv_trigger(struct work_struct *work)\r\n{\r\nstruct usbtv *chip = container_of(work, struct usbtv, snd_trigger);\r\nif (!chip->snd)\r\nreturn;\r\nif (atomic_read(&chip->snd_stream))\r\nusbtv_audio_start(chip);\r\nelse\r\nusbtv_audio_stop(chip);\r\n}\r\nstatic int snd_usbtv_card_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\natomic_set(&chip->snd_stream, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\natomic_set(&chip->snd_stream, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nschedule_work(&chip->snd_trigger);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_usbtv_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct usbtv *chip = snd_pcm_substream_chip(substream);\r\nreturn chip->snd_buffer_pos;\r\n}\r\nint usbtv_audio_init(struct usbtv *usbtv)\r\n{\r\nint rv;\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nINIT_WORK(&usbtv->snd_trigger, snd_usbtv_trigger);\r\natomic_set(&usbtv->snd_stream, 0);\r\nrv = snd_card_new(&usbtv->udev->dev, SNDRV_DEFAULT_IDX1, "usbtv",\r\nTHIS_MODULE, 0, &card);\r\nif (rv < 0)\r\nreturn rv;\r\nstrlcpy(card->driver, usbtv->dev->driver->name, sizeof(card->driver));\r\nstrlcpy(card->shortname, "usbtv", sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"USBTV Audio at bus %d device %d", usbtv->udev->bus->busnum,\r\nusbtv->udev->devnum);\r\nsnd_card_set_dev(card, usbtv->dev);\r\nusbtv->snd = card;\r\nrv = snd_pcm_new(card, "USBTV Audio", 0, 0, 1, &pcm);\r\nif (rv < 0)\r\ngoto err;\r\nstrlcpy(pcm->name, "USBTV Audio Input", sizeof(pcm->name));\r\npcm->info_flags = 0;\r\npcm->private_data = usbtv;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usbtv_pcm_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), USBTV_AUDIO_BUFFER,\r\nUSBTV_AUDIO_BUFFER);\r\nrv = snd_card_register(card);\r\nif (rv)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nusbtv->snd = NULL;\r\nsnd_card_free(card);\r\nreturn rv;\r\n}\r\nvoid usbtv_audio_free(struct usbtv *usbtv)\r\n{\r\ncancel_work_sync(&usbtv->snd_trigger);\r\nif (usbtv->snd && usbtv->udev) {\r\nsnd_card_free(usbtv->snd);\r\nusbtv->snd = NULL;\r\n}\r\n}
