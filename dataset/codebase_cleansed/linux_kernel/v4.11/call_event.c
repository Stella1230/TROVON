void __rxrpc_set_timer(struct rxrpc_call *call, enum rxrpc_timer_trace why,\r\nktime_t now)\r\n{\r\nunsigned long t_j, now_j = jiffies;\r\nktime_t t;\r\nbool queue = false;\r\nif (call->state < RXRPC_CALL_COMPLETE) {\r\nt = call->expire_at;\r\nif (!ktime_after(t, now)) {\r\ntrace_rxrpc_timer(call, why, now, now_j);\r\nqueue = true;\r\ngoto out;\r\n}\r\nif (!ktime_after(call->resend_at, now)) {\r\ncall->resend_at = call->expire_at;\r\nif (!test_and_set_bit(RXRPC_CALL_EV_RESEND, &call->events))\r\nqueue = true;\r\n} else if (ktime_before(call->resend_at, t)) {\r\nt = call->resend_at;\r\n}\r\nif (!ktime_after(call->ack_at, now)) {\r\ncall->ack_at = call->expire_at;\r\nif (!test_and_set_bit(RXRPC_CALL_EV_ACK, &call->events))\r\nqueue = true;\r\n} else if (ktime_before(call->ack_at, t)) {\r\nt = call->ack_at;\r\n}\r\nif (!ktime_after(call->ping_at, now)) {\r\ncall->ping_at = call->expire_at;\r\nif (!test_and_set_bit(RXRPC_CALL_EV_PING, &call->events))\r\nqueue = true;\r\n} else if (ktime_before(call->ping_at, t)) {\r\nt = call->ping_at;\r\n}\r\nt_j = nsecs_to_jiffies(ktime_to_ns(ktime_sub(t, now)));\r\nt_j += jiffies;\r\nt_j++;\r\nif (call->timer.expires != t_j || !timer_pending(&call->timer)) {\r\nmod_timer(&call->timer, t_j);\r\ntrace_rxrpc_timer(call, why, now, now_j);\r\n}\r\n}\r\nout:\r\nif (queue)\r\nrxrpc_queue_call(call);\r\n}\r\nvoid rxrpc_set_timer(struct rxrpc_call *call, enum rxrpc_timer_trace why,\r\nktime_t now)\r\n{\r\nread_lock_bh(&call->state_lock);\r\n__rxrpc_set_timer(call, why, now);\r\nread_unlock_bh(&call->state_lock);\r\n}\r\nstatic void rxrpc_propose_ping(struct rxrpc_call *call,\r\nbool immediate, bool background)\r\n{\r\nif (immediate) {\r\nif (background &&\r\n!test_and_set_bit(RXRPC_CALL_EV_PING, &call->events))\r\nrxrpc_queue_call(call);\r\n} else {\r\nktime_t now = ktime_get_real();\r\nktime_t ping_at = ktime_add_ms(now, rxrpc_idle_ack_delay);\r\nif (ktime_before(ping_at, call->ping_at)) {\r\ncall->ping_at = ping_at;\r\nrxrpc_set_timer(call, rxrpc_timer_set_for_ping, now);\r\n}\r\n}\r\n}\r\nstatic void __rxrpc_propose_ACK(struct rxrpc_call *call, u8 ack_reason,\r\nu16 skew, u32 serial, bool immediate,\r\nbool background,\r\nenum rxrpc_propose_ack_trace why)\r\n{\r\nenum rxrpc_propose_ack_outcome outcome = rxrpc_propose_ack_use;\r\nunsigned int expiry = rxrpc_soft_ack_delay;\r\nktime_t now, ack_at;\r\ns8 prior = rxrpc_ack_priority[ack_reason];\r\nif (ack_reason == RXRPC_ACK_PING) {\r\nrxrpc_propose_ping(call, immediate, background);\r\ngoto trace;\r\n}\r\n_debug("prior %u %u vs %u %u",\r\nack_reason, prior,\r\ncall->ackr_reason, rxrpc_ack_priority[call->ackr_reason]);\r\nif (ack_reason == call->ackr_reason) {\r\nif (RXRPC_ACK_UPDATEABLE & (1 << ack_reason)) {\r\noutcome = rxrpc_propose_ack_update;\r\ncall->ackr_serial = serial;\r\ncall->ackr_skew = skew;\r\n}\r\nif (!immediate)\r\ngoto trace;\r\n} else if (prior > rxrpc_ack_priority[call->ackr_reason]) {\r\ncall->ackr_reason = ack_reason;\r\ncall->ackr_serial = serial;\r\ncall->ackr_skew = skew;\r\n} else {\r\noutcome = rxrpc_propose_ack_subsume;\r\n}\r\nswitch (ack_reason) {\r\ncase RXRPC_ACK_REQUESTED:\r\nif (rxrpc_requested_ack_delay < expiry)\r\nexpiry = rxrpc_requested_ack_delay;\r\nif (serial == 1)\r\nimmediate = false;\r\nbreak;\r\ncase RXRPC_ACK_DELAY:\r\nif (rxrpc_soft_ack_delay < expiry)\r\nexpiry = rxrpc_soft_ack_delay;\r\nbreak;\r\ncase RXRPC_ACK_IDLE:\r\nif (rxrpc_idle_ack_delay < expiry)\r\nexpiry = rxrpc_idle_ack_delay;\r\nbreak;\r\ndefault:\r\nimmediate = true;\r\nbreak;\r\n}\r\nif (test_bit(RXRPC_CALL_EV_ACK, &call->events)) {\r\n_debug("already scheduled");\r\n} else if (immediate || expiry == 0) {\r\n_debug("immediate ACK %lx", call->events);\r\nif (!test_and_set_bit(RXRPC_CALL_EV_ACK, &call->events) &&\r\nbackground)\r\nrxrpc_queue_call(call);\r\n} else {\r\nnow = ktime_get_real();\r\nack_at = ktime_add_ms(now, expiry);\r\nif (ktime_before(ack_at, call->ack_at)) {\r\ncall->ack_at = ack_at;\r\nrxrpc_set_timer(call, rxrpc_timer_set_for_ack, now);\r\n}\r\n}\r\ntrace:\r\ntrace_rxrpc_propose_ack(call, why, ack_reason, serial, immediate,\r\nbackground, outcome);\r\n}\r\nvoid rxrpc_propose_ACK(struct rxrpc_call *call, u8 ack_reason,\r\nu16 skew, u32 serial, bool immediate, bool background,\r\nenum rxrpc_propose_ack_trace why)\r\n{\r\nspin_lock_bh(&call->lock);\r\n__rxrpc_propose_ACK(call, ack_reason, skew, serial,\r\nimmediate, background, why);\r\nspin_unlock_bh(&call->lock);\r\n}\r\nstatic void rxrpc_congestion_timeout(struct rxrpc_call *call)\r\n{\r\nset_bit(RXRPC_CALL_RETRANS_TIMEOUT, &call->flags);\r\n}\r\nstatic void rxrpc_resend(struct rxrpc_call *call, ktime_t now)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nstruct sk_buff *skb;\r\nrxrpc_seq_t cursor, seq, top;\r\nktime_t max_age, oldest, ack_ts;\r\nint ix;\r\nu8 annotation, anno_type, retrans = 0, unacked = 0;\r\n_enter("{%d,%d}", call->tx_hard_ack, call->tx_top);\r\nmax_age = ktime_sub_ms(now, rxrpc_resend_timeout);\r\nspin_lock_bh(&call->lock);\r\ncursor = call->tx_hard_ack;\r\ntop = call->tx_top;\r\nASSERT(before_eq(cursor, top));\r\nif (cursor == top)\r\ngoto out_unlock;\r\noldest = now;\r\nfor (seq = cursor + 1; before_eq(seq, top); seq++) {\r\nix = seq & RXRPC_RXTX_BUFF_MASK;\r\nannotation = call->rxtx_annotations[ix];\r\nanno_type = annotation & RXRPC_TX_ANNO_MASK;\r\nannotation &= ~RXRPC_TX_ANNO_MASK;\r\nif (anno_type == RXRPC_TX_ANNO_ACK)\r\ncontinue;\r\nskb = call->rxtx_buffer[ix];\r\nrxrpc_see_skb(skb, rxrpc_skb_tx_seen);\r\nsp = rxrpc_skb(skb);\r\nif (anno_type == RXRPC_TX_ANNO_UNACK) {\r\nif (ktime_after(skb->tstamp, max_age)) {\r\nif (ktime_before(skb->tstamp, oldest))\r\noldest = skb->tstamp;\r\ncontinue;\r\n}\r\nif (!(annotation & RXRPC_TX_ANNO_RESENT))\r\nunacked++;\r\n}\r\ncall->rxtx_annotations[ix] = RXRPC_TX_ANNO_RETRANS | annotation;\r\nretrans++;\r\ntrace_rxrpc_retransmit(call, seq, annotation | anno_type,\r\nktime_to_ns(ktime_sub(skb->tstamp, max_age)));\r\n}\r\ncall->resend_at = ktime_add_ms(oldest, rxrpc_resend_timeout);\r\nif (unacked)\r\nrxrpc_congestion_timeout(call);\r\nif (!retrans) {\r\nrxrpc_set_timer(call, rxrpc_timer_set_for_resend, now);\r\nspin_unlock_bh(&call->lock);\r\nack_ts = ktime_sub(now, call->acks_latest_ts);\r\nif (ktime_to_ns(ack_ts) < call->peer->rtt)\r\ngoto out;\r\nrxrpc_propose_ACK(call, RXRPC_ACK_PING, 0, 0, true, false,\r\nrxrpc_propose_ack_ping_for_lost_ack);\r\nrxrpc_send_ack_packet(call, true);\r\ngoto out;\r\n}\r\nfor (seq = cursor + 1; before_eq(seq, top); seq++) {\r\nix = seq & RXRPC_RXTX_BUFF_MASK;\r\nannotation = call->rxtx_annotations[ix];\r\nanno_type = annotation & RXRPC_TX_ANNO_MASK;\r\nif (anno_type != RXRPC_TX_ANNO_RETRANS)\r\ncontinue;\r\nskb = call->rxtx_buffer[ix];\r\nrxrpc_get_skb(skb, rxrpc_skb_tx_got);\r\nspin_unlock_bh(&call->lock);\r\nif (rxrpc_send_data_packet(call, skb, true) < 0) {\r\nrxrpc_free_skb(skb, rxrpc_skb_tx_freed);\r\nreturn;\r\n}\r\nif (rxrpc_is_client_call(call))\r\nrxrpc_expose_client_call(call);\r\nrxrpc_free_skb(skb, rxrpc_skb_tx_freed);\r\nspin_lock_bh(&call->lock);\r\nif (after(seq, call->tx_hard_ack)) {\r\nannotation = call->rxtx_annotations[ix];\r\nanno_type = annotation & RXRPC_TX_ANNO_MASK;\r\nif (anno_type == RXRPC_TX_ANNO_RETRANS ||\r\nanno_type == RXRPC_TX_ANNO_NAK) {\r\nannotation &= ~RXRPC_TX_ANNO_MASK;\r\nannotation |= RXRPC_TX_ANNO_UNACK;\r\n}\r\nannotation |= RXRPC_TX_ANNO_RESENT;\r\ncall->rxtx_annotations[ix] = annotation;\r\n}\r\nif (after(call->tx_hard_ack, seq))\r\nseq = call->tx_hard_ack;\r\n}\r\nout_unlock:\r\nspin_unlock_bh(&call->lock);\r\nout:\r\n_leave("");\r\n}\r\nvoid rxrpc_process_call(struct work_struct *work)\r\n{\r\nstruct rxrpc_call *call =\r\ncontainer_of(work, struct rxrpc_call, processor);\r\nktime_t now;\r\nrxrpc_see_call(call);\r\n_enter("{%d,%s,%lx}",\r\ncall->debug_id, rxrpc_call_states[call->state], call->events);\r\nrecheck_state:\r\nif (test_and_clear_bit(RXRPC_CALL_EV_ABORT, &call->events)) {\r\nrxrpc_send_abort_packet(call);\r\ngoto recheck_state;\r\n}\r\nif (call->state == RXRPC_CALL_COMPLETE) {\r\ndel_timer_sync(&call->timer);\r\nrxrpc_notify_socket(call);\r\ngoto out_put;\r\n}\r\nnow = ktime_get_real();\r\nif (ktime_before(call->expire_at, now)) {\r\nrxrpc_abort_call("EXP", call, 0, RX_CALL_TIMEOUT, ETIME);\r\nset_bit(RXRPC_CALL_EV_ABORT, &call->events);\r\ngoto recheck_state;\r\n}\r\nif (test_and_clear_bit(RXRPC_CALL_EV_ACK, &call->events)) {\r\nif (call->ackr_reason) {\r\nrxrpc_send_ack_packet(call, false);\r\ngoto recheck_state;\r\n}\r\n}\r\nif (test_and_clear_bit(RXRPC_CALL_EV_PING, &call->events)) {\r\nrxrpc_send_ack_packet(call, true);\r\ngoto recheck_state;\r\n}\r\nif (test_and_clear_bit(RXRPC_CALL_EV_RESEND, &call->events)) {\r\nrxrpc_resend(call, now);\r\ngoto recheck_state;\r\n}\r\nrxrpc_set_timer(call, rxrpc_timer_set_for_resend, now);\r\nif (call->events && call->state < RXRPC_CALL_COMPLETE) {\r\n__rxrpc_queue_call(call);\r\ngoto out;\r\n}\r\nout_put:\r\nrxrpc_put_call(call, rxrpc_call_put);\r\nout:\r\n_leave("");\r\n}
