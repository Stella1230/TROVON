static char *print_lockmode(int mode)\r\n{\r\nswitch (mode) {\r\ncase DLM_LOCK_IV:\r\nreturn "--";\r\ncase DLM_LOCK_NL:\r\nreturn "NL";\r\ncase DLM_LOCK_CR:\r\nreturn "CR";\r\ncase DLM_LOCK_CW:\r\nreturn "CW";\r\ncase DLM_LOCK_PR:\r\nreturn "PR";\r\ncase DLM_LOCK_PW:\r\nreturn "PW";\r\ncase DLM_LOCK_EX:\r\nreturn "EX";\r\ndefault:\r\nreturn "??";\r\n}\r\n}\r\nstatic void print_format1_lock(struct seq_file *s, struct dlm_lkb *lkb,\r\nstruct dlm_rsb *res)\r\n{\r\nseq_printf(s, "%08x %s", lkb->lkb_id, print_lockmode(lkb->lkb_grmode));\r\nif (lkb->lkb_status == DLM_LKSTS_CONVERT ||\r\nlkb->lkb_status == DLM_LKSTS_WAITING)\r\nseq_printf(s, " (%s)", print_lockmode(lkb->lkb_rqmode));\r\nif (lkb->lkb_nodeid) {\r\nif (lkb->lkb_nodeid != res->res_nodeid)\r\nseq_printf(s, " Remote: %3d %08x", lkb->lkb_nodeid,\r\nlkb->lkb_remid);\r\nelse\r\nseq_printf(s, " Master: %08x", lkb->lkb_remid);\r\n}\r\nif (lkb->lkb_wait_type)\r\nseq_printf(s, " wait_type: %d", lkb->lkb_wait_type);\r\nseq_puts(s, "\n");\r\n}\r\nstatic void print_format1(struct dlm_rsb *res, struct seq_file *s)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint i, lvblen = res->res_ls->ls_lvblen, recover_list, root_list;\r\nlock_rsb(res);\r\nseq_printf(s, "\nResource %p Name (len=%d) \"", res, res->res_length);\r\nfor (i = 0; i < res->res_length; i++) {\r\nif (isprint(res->res_name[i]))\r\nseq_printf(s, "%c", res->res_name[i]);\r\nelse\r\nseq_printf(s, "%c", '.');\r\n}\r\nif (res->res_nodeid > 0)\r\nseq_printf(s, "\"\nLocal Copy, Master is node %d\n",\r\nres->res_nodeid);\r\nelse if (res->res_nodeid == 0)\r\nseq_puts(s, "\"\nMaster Copy\n");\r\nelse if (res->res_nodeid == -1)\r\nseq_printf(s, "\"\nLooking up master (lkid %x)\n",\r\nres->res_first_lkid);\r\nelse\r\nseq_printf(s, "\"\nInvalid master %d\n", res->res_nodeid);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\nif (res->res_lvbptr) {\r\nseq_puts(s, "LVB: ");\r\nfor (i = 0; i < lvblen; i++) {\r\nif (i == lvblen / 2)\r\nseq_puts(s, "\n ");\r\nseq_printf(s, "%02x ",\r\n(unsigned char) res->res_lvbptr[i]);\r\n}\r\nif (rsb_flag(res, RSB_VALNOTVALID))\r\nseq_puts(s, " (INVALID)");\r\nseq_puts(s, "\n");\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nroot_list = !list_empty(&res->res_root_list);\r\nrecover_list = !list_empty(&res->res_recover_list);\r\nif (root_list || recover_list) {\r\nseq_printf(s, "Recovery: root %d recover %d flags %lx count %d\n",\r\nroot_list, recover_list,\r\nres->res_flags, res->res_recover_locks_count);\r\n}\r\nseq_puts(s, "Granted Queue\n");\r\nlist_for_each_entry(lkb, &res->res_grantqueue, lkb_statequeue) {\r\nprint_format1_lock(s, lkb, res);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nseq_puts(s, "Conversion Queue\n");\r\nlist_for_each_entry(lkb, &res->res_convertqueue, lkb_statequeue) {\r\nprint_format1_lock(s, lkb, res);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nseq_puts(s, "Waiting Queue\n");\r\nlist_for_each_entry(lkb, &res->res_waitqueue, lkb_statequeue) {\r\nprint_format1_lock(s, lkb, res);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nif (list_empty(&res->res_lookup))\r\ngoto out;\r\nseq_puts(s, "Lookup Queue\n");\r\nlist_for_each_entry(lkb, &res->res_lookup, lkb_rsb_lookup) {\r\nseq_printf(s, "%08x %s",\r\nlkb->lkb_id, print_lockmode(lkb->lkb_rqmode));\r\nif (lkb->lkb_wait_type)\r\nseq_printf(s, " wait_type: %d", lkb->lkb_wait_type);\r\nseq_puts(s, "\n");\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nout:\r\nunlock_rsb(res);\r\n}\r\nstatic void print_format2_lock(struct seq_file *s, struct dlm_lkb *lkb,\r\nstruct dlm_rsb *r)\r\n{\r\nu64 xid = 0;\r\nu64 us;\r\nif (lkb->lkb_flags & DLM_IFL_USER) {\r\nif (lkb->lkb_ua)\r\nxid = lkb->lkb_ua->xid;\r\n}\r\nus = ktime_to_us(ktime_sub(ktime_get(), lkb->lkb_timestamp));\r\nseq_printf(s, "%x %d %x %u %llu %x %x %d %d %d %llu %u %d \"%s\"\n",\r\nlkb->lkb_id,\r\nlkb->lkb_nodeid,\r\nlkb->lkb_remid,\r\nlkb->lkb_ownpid,\r\n(unsigned long long)xid,\r\nlkb->lkb_exflags,\r\nlkb->lkb_flags,\r\nlkb->lkb_status,\r\nlkb->lkb_grmode,\r\nlkb->lkb_rqmode,\r\n(unsigned long long)us,\r\nr->res_nodeid,\r\nr->res_length,\r\nr->res_name);\r\n}\r\nstatic void print_format2(struct dlm_rsb *r, struct seq_file *s)\r\n{\r\nstruct dlm_lkb *lkb;\r\nlock_rsb(r);\r\nlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\r\nprint_format2_lock(s, lkb, r);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\r\nprint_format2_lock(s, lkb, r);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\r\nprint_format2_lock(s, lkb, r);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nout:\r\nunlock_rsb(r);\r\n}\r\nstatic void print_format3_lock(struct seq_file *s, struct dlm_lkb *lkb,\r\nint rsb_lookup)\r\n{\r\nu64 xid = 0;\r\nif (lkb->lkb_flags & DLM_IFL_USER) {\r\nif (lkb->lkb_ua)\r\nxid = lkb->lkb_ua->xid;\r\n}\r\nseq_printf(s, "lkb %x %d %x %u %llu %x %x %d %d %d %d %d %d %u %llu %llu\n",\r\nlkb->lkb_id,\r\nlkb->lkb_nodeid,\r\nlkb->lkb_remid,\r\nlkb->lkb_ownpid,\r\n(unsigned long long)xid,\r\nlkb->lkb_exflags,\r\nlkb->lkb_flags,\r\nlkb->lkb_status,\r\nlkb->lkb_grmode,\r\nlkb->lkb_rqmode,\r\nlkb->lkb_last_bast.mode,\r\nrsb_lookup,\r\nlkb->lkb_wait_type,\r\nlkb->lkb_lvbseq,\r\n(unsigned long long)ktime_to_ns(lkb->lkb_timestamp),\r\n(unsigned long long)ktime_to_ns(lkb->lkb_last_bast_time));\r\n}\r\nstatic void print_format3(struct dlm_rsb *r, struct seq_file *s)\r\n{\r\nstruct dlm_lkb *lkb;\r\nint i, lvblen = r->res_ls->ls_lvblen;\r\nint print_name = 1;\r\nlock_rsb(r);\r\nseq_printf(s, "rsb %p %d %x %lx %d %d %u %d ",\r\nr,\r\nr->res_nodeid,\r\nr->res_first_lkid,\r\nr->res_flags,\r\n!list_empty(&r->res_root_list),\r\n!list_empty(&r->res_recover_list),\r\nr->res_recover_locks_count,\r\nr->res_length);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\nfor (i = 0; i < r->res_length; i++) {\r\nif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\r\nprint_name = 0;\r\n}\r\nseq_puts(s, print_name ? "str " : "hex");\r\nfor (i = 0; i < r->res_length; i++) {\r\nif (print_name)\r\nseq_printf(s, "%c", r->res_name[i]);\r\nelse\r\nseq_printf(s, " %02x", (unsigned char)r->res_name[i]);\r\n}\r\nseq_puts(s, "\n");\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\nif (!r->res_lvbptr)\r\ngoto do_locks;\r\nseq_printf(s, "lvb %u %d", r->res_lvbseq, lvblen);\r\nfor (i = 0; i < lvblen; i++)\r\nseq_printf(s, " %02x", (unsigned char)r->res_lvbptr[i]);\r\nseq_puts(s, "\n");\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\ndo_locks:\r\nlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\r\nprint_format3_lock(s, lkb, 0);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\r\nprint_format3_lock(s, lkb, 0);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue) {\r\nprint_format3_lock(s, lkb, 0);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup) {\r\nprint_format3_lock(s, lkb, 1);\r\nif (seq_has_overflowed(s))\r\ngoto out;\r\n}\r\nout:\r\nunlock_rsb(r);\r\n}\r\nstatic void print_format4(struct dlm_rsb *r, struct seq_file *s)\r\n{\r\nint our_nodeid = dlm_our_nodeid();\r\nint print_name = 1;\r\nint i;\r\nlock_rsb(r);\r\nseq_printf(s, "rsb %p %d %d %d %d %lu %lx %d ",\r\nr,\r\nr->res_nodeid,\r\nr->res_master_nodeid,\r\nr->res_dir_nodeid,\r\nour_nodeid,\r\nr->res_toss_time,\r\nr->res_flags,\r\nr->res_length);\r\nfor (i = 0; i < r->res_length; i++) {\r\nif (!isascii(r->res_name[i]) || !isprint(r->res_name[i]))\r\nprint_name = 0;\r\n}\r\nseq_puts(s, print_name ? "str " : "hex");\r\nfor (i = 0; i < r->res_length; i++) {\r\nif (print_name)\r\nseq_printf(s, "%c", r->res_name[i]);\r\nelse\r\nseq_printf(s, " %02x", (unsigned char)r->res_name[i]);\r\n}\r\nseq_puts(s, "\n");\r\nunlock_rsb(r);\r\n}\r\nstatic int table_seq_show(struct seq_file *seq, void *iter_ptr)\r\n{\r\nstruct rsbtbl_iter *ri = iter_ptr;\r\nswitch (ri->format) {\r\ncase 1:\r\nprint_format1(ri->rsb, seq);\r\nbreak;\r\ncase 2:\r\nif (ri->header) {\r\nseq_puts(seq, "id nodeid remid pid xid exflags flags sts grmode rqmode time_ms r_nodeid r_len r_name\n");\r\nri->header = 0;\r\n}\r\nprint_format2(ri->rsb, seq);\r\nbreak;\r\ncase 3:\r\nif (ri->header) {\r\nseq_puts(seq, "version rsb 1.1 lvb 1.1 lkb 1.1\n");\r\nri->header = 0;\r\n}\r\nprint_format3(ri->rsb, seq);\r\nbreak;\r\ncase 4:\r\nif (ri->header) {\r\nseq_puts(seq, "version 4 rsb 2\n");\r\nri->header = 0;\r\n}\r\nprint_format4(ri->rsb, seq);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *table_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct rb_root *tree;\r\nstruct rb_node *node;\r\nstruct dlm_ls *ls = seq->private;\r\nstruct rsbtbl_iter *ri;\r\nstruct dlm_rsb *r;\r\nloff_t n = *pos;\r\nunsigned bucket, entry;\r\nint toss = (seq->op == &format4_seq_ops);\r\nbucket = n >> 32;\r\nentry = n & ((1LL << 32) - 1);\r\nif (bucket >= ls->ls_rsbtbl_size)\r\nreturn NULL;\r\nri = kzalloc(sizeof(struct rsbtbl_iter), GFP_NOFS);\r\nif (!ri)\r\nreturn NULL;\r\nif (n == 0)\r\nri->header = 1;\r\nif (seq->op == &format1_seq_ops)\r\nri->format = 1;\r\nif (seq->op == &format2_seq_ops)\r\nri->format = 2;\r\nif (seq->op == &format3_seq_ops)\r\nri->format = 3;\r\nif (seq->op == &format4_seq_ops)\r\nri->format = 4;\r\ntree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nif (!RB_EMPTY_ROOT(tree)) {\r\nfor (node = rb_first(tree); node; node = rb_next(node)) {\r\nr = rb_entry(node, struct dlm_rsb, res_hashnode);\r\nif (!entry--) {\r\ndlm_hold_rsb(r);\r\nri->rsb = r;\r\nri->bucket = bucket;\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\nreturn ri;\r\n}\r\n}\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\nn &= ~((1LL << 32) - 1);\r\nwhile (1) {\r\nbucket++;\r\nn += 1LL << 32;\r\nif (bucket >= ls->ls_rsbtbl_size) {\r\nkfree(ri);\r\nreturn NULL;\r\n}\r\ntree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nif (!RB_EMPTY_ROOT(tree)) {\r\nnode = rb_first(tree);\r\nr = rb_entry(node, struct dlm_rsb, res_hashnode);\r\ndlm_hold_rsb(r);\r\nri->rsb = r;\r\nri->bucket = bucket;\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\n*pos = n;\r\nreturn ri;\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\n}\r\n}\r\nstatic void *table_seq_next(struct seq_file *seq, void *iter_ptr, loff_t *pos)\r\n{\r\nstruct dlm_ls *ls = seq->private;\r\nstruct rsbtbl_iter *ri = iter_ptr;\r\nstruct rb_root *tree;\r\nstruct rb_node *next;\r\nstruct dlm_rsb *r, *rp;\r\nloff_t n = *pos;\r\nunsigned bucket;\r\nint toss = (seq->op == &format4_seq_ops);\r\nbucket = n >> 32;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nrp = ri->rsb;\r\nnext = rb_next(&rp->res_hashnode);\r\nif (next) {\r\nr = rb_entry(next, struct dlm_rsb, res_hashnode);\r\ndlm_hold_rsb(r);\r\nri->rsb = r;\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\ndlm_put_rsb(rp);\r\n++*pos;\r\nreturn ri;\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\ndlm_put_rsb(rp);\r\nn &= ~((1LL << 32) - 1);\r\nwhile (1) {\r\nbucket++;\r\nn += 1LL << 32;\r\nif (bucket >= ls->ls_rsbtbl_size) {\r\nkfree(ri);\r\nreturn NULL;\r\n}\r\ntree = toss ? &ls->ls_rsbtbl[bucket].toss : &ls->ls_rsbtbl[bucket].keep;\r\nspin_lock(&ls->ls_rsbtbl[bucket].lock);\r\nif (!RB_EMPTY_ROOT(tree)) {\r\nnext = rb_first(tree);\r\nr = rb_entry(next, struct dlm_rsb, res_hashnode);\r\ndlm_hold_rsb(r);\r\nri->rsb = r;\r\nri->bucket = bucket;\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\n*pos = n;\r\nreturn ri;\r\n}\r\nspin_unlock(&ls->ls_rsbtbl[bucket].lock);\r\n}\r\n}\r\nstatic void table_seq_stop(struct seq_file *seq, void *iter_ptr)\r\n{\r\nstruct rsbtbl_iter *ri = iter_ptr;\r\nif (ri) {\r\ndlm_put_rsb(ri->rsb);\r\nkfree(ri);\r\n}\r\n}\r\nstatic int table_open1(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint ret;\r\nret = seq_open(file, &format1_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int table_open2(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint ret;\r\nret = seq_open(file, &format2_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int table_open3(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint ret;\r\nret = seq_open(file, &format3_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic int table_open4(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint ret;\r\nret = seq_open(file, &format4_seq_ops);\r\nif (ret)\r\nreturn ret;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nstatic ssize_t waiters_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct dlm_ls *ls = file->private_data;\r\nstruct dlm_lkb *lkb;\r\nsize_t len = DLM_DEBUG_BUF_LEN, pos = 0, ret, rv;\r\nmutex_lock(&debug_buf_lock);\r\nmutex_lock(&ls->ls_waiters_mutex);\r\nmemset(debug_buf, 0, sizeof(debug_buf));\r\nlist_for_each_entry(lkb, &ls->ls_waiters, lkb_wait_reply) {\r\nret = snprintf(debug_buf + pos, len - pos, "%x %d %d %s\n",\r\nlkb->lkb_id, lkb->lkb_wait_type,\r\nlkb->lkb_nodeid, lkb->lkb_resource->res_name);\r\nif (ret >= len - pos)\r\nbreak;\r\npos += ret;\r\n}\r\nmutex_unlock(&ls->ls_waiters_mutex);\r\nrv = simple_read_from_buffer(userbuf, count, ppos, debug_buf, pos);\r\nmutex_unlock(&debug_buf_lock);\r\nreturn rv;\r\n}\r\nvoid dlm_delete_debug_file(struct dlm_ls *ls)\r\n{\r\ndebugfs_remove(ls->ls_debug_rsb_dentry);\r\ndebugfs_remove(ls->ls_debug_waiters_dentry);\r\ndebugfs_remove(ls->ls_debug_locks_dentry);\r\ndebugfs_remove(ls->ls_debug_all_dentry);\r\ndebugfs_remove(ls->ls_debug_toss_dentry);\r\n}\r\nint dlm_create_debug_file(struct dlm_ls *ls)\r\n{\r\nchar name[DLM_LOCKSPACE_LEN+8];\r\nls->ls_debug_rsb_dentry = debugfs_create_file(ls->ls_name,\r\nS_IFREG | S_IRUGO,\r\ndlm_root,\r\nls,\r\n&format1_fops);\r\nif (!ls->ls_debug_rsb_dentry)\r\ngoto fail;\r\nmemset(name, 0, sizeof(name));\r\nsnprintf(name, DLM_LOCKSPACE_LEN+8, "%s_locks", ls->ls_name);\r\nls->ls_debug_locks_dentry = debugfs_create_file(name,\r\nS_IFREG | S_IRUGO,\r\ndlm_root,\r\nls,\r\n&format2_fops);\r\nif (!ls->ls_debug_locks_dentry)\r\ngoto fail;\r\nmemset(name, 0, sizeof(name));\r\nsnprintf(name, DLM_LOCKSPACE_LEN+8, "%s_all", ls->ls_name);\r\nls->ls_debug_all_dentry = debugfs_create_file(name,\r\nS_IFREG | S_IRUGO,\r\ndlm_root,\r\nls,\r\n&format3_fops);\r\nif (!ls->ls_debug_all_dentry)\r\ngoto fail;\r\nmemset(name, 0, sizeof(name));\r\nsnprintf(name, DLM_LOCKSPACE_LEN+8, "%s_toss", ls->ls_name);\r\nls->ls_debug_toss_dentry = debugfs_create_file(name,\r\nS_IFREG | S_IRUGO,\r\ndlm_root,\r\nls,\r\n&format4_fops);\r\nif (!ls->ls_debug_toss_dentry)\r\ngoto fail;\r\nmemset(name, 0, sizeof(name));\r\nsnprintf(name, DLM_LOCKSPACE_LEN+8, "%s_waiters", ls->ls_name);\r\nls->ls_debug_waiters_dentry = debugfs_create_file(name,\r\nS_IFREG | S_IRUGO,\r\ndlm_root,\r\nls,\r\n&waiters_fops);\r\nif (!ls->ls_debug_waiters_dentry)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\ndlm_delete_debug_file(ls);\r\nreturn -ENOMEM;\r\n}\r\nint __init dlm_register_debugfs(void)\r\n{\r\nmutex_init(&debug_buf_lock);\r\ndlm_root = debugfs_create_dir("dlm", NULL);\r\nreturn dlm_root ? 0 : -ENOMEM;\r\n}\r\nvoid dlm_unregister_debugfs(void)\r\n{\r\ndebugfs_remove(dlm_root);\r\n}
