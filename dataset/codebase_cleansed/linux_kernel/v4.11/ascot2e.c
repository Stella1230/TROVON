static void ascot2e_i2c_debug(struct ascot2e_priv *priv,\r\nu8 reg, u8 write, const u8 *data, u32 len)\r\n{\r\ndev_dbg(&priv->i2c->dev, "ascot2e: I2C %s reg 0x%02x size %d\n",\r\n(write == 0 ? "read" : "write"), reg, len);\r\nprint_hex_dump_bytes("ascot2e: I2C data: ",\r\nDUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic int ascot2e_write_regs(struct ascot2e_priv *priv,\r\nu8 reg, const u8 *data, u32 len)\r\n{\r\nint ret;\r\nu8 buf[MAX_WRITE_REGSIZE + 1];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (len + 1 > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,"wr reg=%04x: len=%d is too big!\n",\r\nreg, len + 1);\r\nreturn -E2BIG;\r\n}\r\nascot2e_i2c_debug(priv, reg, 1, data, len);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], data, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ascot2e_write_reg(struct ascot2e_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn ascot2e_write_regs(priv, reg, &val, 1);\r\n}\r\nstatic int ascot2e_read_regs(struct ascot2e_priv *priv,\r\nu8 reg, u8 *val, u32 len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, &msg[0], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: I2C rw failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, priv->i2c_address, reg);\r\nreturn ret;\r\n}\r\nret = i2c_transfer(priv->i2c, &msg[1], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EREMOTEIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, priv->i2c_address, reg);\r\nreturn ret;\r\n}\r\nascot2e_i2c_debug(priv, reg, 0, val, len);\r\nreturn 0;\r\n}\r\nstatic int ascot2e_read_reg(struct ascot2e_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn ascot2e_read_regs(priv, reg, val, 1);\r\n}\r\nstatic int ascot2e_set_reg_bits(struct ascot2e_priv *priv,\r\nu8 reg, u8 data, u8 mask)\r\n{\r\nint res;\r\nu8 rdata;\r\nif (mask != 0xff) {\r\nres = ascot2e_read_reg(priv, reg, &rdata);\r\nif (res != 0)\r\nreturn res;\r\ndata = ((data & mask) | (rdata & (mask ^ 0xFF)));\r\n}\r\nreturn ascot2e_write_reg(priv, reg, data);\r\n}\r\nstatic int ascot2e_enter_power_save(struct ascot2e_priv *priv)\r\n{\r\nu8 data[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_SLEEP)\r\nreturn 0;\r\ndata[0] = 0x00;\r\ndata[1] = 0x04;\r\nascot2e_write_regs(priv, 0x14, data, 2);\r\nascot2e_write_reg(priv, 0x50, 0x01);\r\npriv->state = STATE_SLEEP;\r\nreturn 0;\r\n}\r\nstatic int ascot2e_leave_power_save(struct ascot2e_priv *priv)\r\n{\r\nu8 data[2] = { 0xFB, 0x0F };\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE)\r\nreturn 0;\r\nascot2e_write_regs(priv, 0x14, data, 2);\r\nascot2e_write_reg(priv, 0x50, 0x00);\r\npriv->state = STATE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int ascot2e_init(struct dvb_frontend *fe)\r\n{\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn ascot2e_leave_power_save(priv);\r\n}\r\nstatic void ascot2e_release(struct dvb_frontend *fe)\r\n{\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int ascot2e_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nascot2e_enter_power_save(priv);\r\nreturn 0;\r\n}\r\nstatic enum ascot2e_tv_system_t ascot2e_get_tv_system(struct dvb_frontend *fe)\r\n{\r\nenum ascot2e_tv_system_t system = ASCOT2E_DTV_UNKNOWN;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\nif (p->delivery_system == SYS_DVBT) {\r\nif (p->bandwidth_hz <= 5000000)\r\nsystem = ASCOT2E_DTV_DVBT_5;\r\nelse if (p->bandwidth_hz <= 6000000)\r\nsystem = ASCOT2E_DTV_DVBT_6;\r\nelse if (p->bandwidth_hz <= 7000000)\r\nsystem = ASCOT2E_DTV_DVBT_7;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = ASCOT2E_DTV_DVBT_8;\r\nelse {\r\nsystem = ASCOT2E_DTV_DVBT_8;\r\np->bandwidth_hz = 8000000;\r\n}\r\n} else if (p->delivery_system == SYS_DVBT2) {\r\nif (p->bandwidth_hz <= 5000000)\r\nsystem = ASCOT2E_DTV_DVBT2_5;\r\nelse if (p->bandwidth_hz <= 6000000)\r\nsystem = ASCOT2E_DTV_DVBT2_6;\r\nelse if (p->bandwidth_hz <= 7000000)\r\nsystem = ASCOT2E_DTV_DVBT2_7;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = ASCOT2E_DTV_DVBT2_8;\r\nelse {\r\nsystem = ASCOT2E_DTV_DVBT2_8;\r\np->bandwidth_hz = 8000000;\r\n}\r\n} else if (p->delivery_system == SYS_DVBC_ANNEX_A) {\r\nif (p->bandwidth_hz <= 6000000)\r\nsystem = ASCOT2E_DTV_DVBC_6;\r\nelse if (p->bandwidth_hz <= 8000000)\r\nsystem = ASCOT2E_DTV_DVBC_8;\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): ASCOT2E DTV system %d (delsys %d, bandwidth %d)\n",\r\n__func__, (int)system, p->delivery_system, p->bandwidth_hz);\r\nreturn system;\r\n}\r\nstatic int ascot2e_set_params(struct dvb_frontend *fe)\r\n{\r\nu8 data[10];\r\nu32 frequency;\r\nenum ascot2e_tv_system_t tv_system;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): tune frequency %dkHz\n",\r\n__func__, p->frequency / 1000);\r\ntv_system = ascot2e_get_tv_system(fe);\r\nif (tv_system == ASCOT2E_DTV_UNKNOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): unknown DTV system\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (priv->set_tuner)\r\npriv->set_tuner(priv->set_tuner_data, 1);\r\nfrequency = roundup(p->frequency / 1000, 25);\r\nif (priv->state == STATE_SLEEP)\r\nascot2e_leave_power_save(priv);\r\ndata[0] = 0x00;\r\nif (ascot2e_sett[tv_system].agc_sel != ASCOT2E_AUTO) {\r\ndata[0] |= (u8)(\r\n(ascot2e_sett[tv_system].agc_sel & 0x03) << 3);\r\n}\r\nif (ascot2e_sett[tv_system].if_out_sel != ASCOT2E_AUTO) {\r\ndata[0] |= (u8)(\r\n(ascot2e_sett[tv_system].if_out_sel & 0x01) << 2);\r\n}\r\nascot2e_set_reg_bits(priv, 0x05, data[0], 0x1c);\r\nif (tv_system == ASCOT2E_DTV_DVBC_6 ||\r\ntv_system == ASCOT2E_DTV_DVBC_8) {\r\ndata[0] = (frequency > 500000) ? 16 : 32;\r\n} else {\r\ndata[0] = (frequency > 500000) ? 2 : 4;\r\n}\r\ndata[1] = 0x04;\r\nif (tv_system == ASCOT2E_DTV_DVBC_6 ||\r\ntv_system == ASCOT2E_DTV_DVBC_8) {\r\ndata[2] = 18;\r\ndata[3] = 120;\r\ndata[4] = 20;\r\n} else {\r\ndata[2] = 48;\r\ndata[3] = 10;\r\ndata[4] = 30;\r\n}\r\nif (tv_system == ASCOT2E_DTV_DVBC_6 ||\r\ntv_system == ASCOT2E_DTV_DVBC_8)\r\ndata[5] = (frequency > 500000) ? 0x08 : 0x0c;\r\nelse\r\ndata[5] = (frequency > 500000) ? 0x30 : 0x38;\r\ndata[6] = ascot2e_sett[tv_system].mix_oll;\r\nif (ascot2e_sett[tv_system].rf_gain == ASCOT2E_AUTO) {\r\nascot2e_write_reg(priv, 0x4E, 0x01);\r\ndata[7] = 0x00;\r\n} else {\r\nascot2e_write_reg(priv, 0x4E, 0x00);\r\ndata[7] = ascot2e_sett[tv_system].rf_gain;\r\n}\r\ndata[8] = (u8)((ascot2e_sett[tv_system].fif_offset << 3) |\r\n(ascot2e_sett[tv_system].if_bpf_gc & 0x07));\r\ndata[9] = ascot2e_sett[tv_system].bw_offset;\r\nascot2e_write_regs(priv, 0x06, data, 10);\r\nif (tv_system == ASCOT2E_DTV_DVBC_6 ||\r\ntv_system == ASCOT2E_DTV_DVBC_8) {\r\ndata[0] = 0x0F;\r\ndata[1] = 0x00;\r\ndata[2] = 0x01;\r\n} else {\r\ndata[0] = 0x0F;\r\ndata[1] = 0x00;\r\ndata[2] = 0x03;\r\n}\r\nascot2e_write_regs(priv, 0x45, data, 3);\r\ndata[0] = ascot2e_sett[tv_system].rf_oldet;\r\ndata[1] = ascot2e_sett[tv_system].if_bpf_f0;\r\nascot2e_write_regs(priv, 0x49, data, 2);\r\nascot2e_set_reg_bits(priv, 0x0c, 0x90, 0xb0);\r\ndata[0] = 0xc4;\r\ndata[1] = 0x40;\r\nascot2e_write_regs(priv, 0x03, data, 2);\r\ndata[0] = (u8)(frequency & 0xFF);\r\ndata[1] = (u8)((frequency >> 8) & 0xFF);\r\ndata[2] = (u8)((frequency >> 16) & 0x0F);\r\ndata[2] |= (u8)(ascot2e_sett[tv_system].bw << 4);\r\ndata[3] = 0xFF;\r\ndata[4] = 0xFF;\r\nascot2e_write_regs(priv, 0x10, data, 5);\r\nmsleep(50);\r\nascot2e_write_reg(priv, 0x04, 0x00);\r\nascot2e_write_reg(priv, 0x03, 0xC0);\r\nascot2e_set_reg_bits(priv, 0x0C, 0x00, 0x30);\r\npriv->frequency = frequency;\r\nreturn 0;\r\n}\r\nstatic int ascot2e_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct ascot2e_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency * 1000;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *ascot2e_attach(struct dvb_frontend *fe,\r\nconst struct ascot2e_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nu8 data[4];\r\nstruct ascot2e_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct ascot2e_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = (config->i2c_address >> 1);\r\npriv->i2c = i2c;\r\npriv->set_tuner_data = config->set_tuner_priv;\r\npriv->set_tuner = config->set_tuner_callback;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\ndata[0] = 16;\r\ndata[1] = 0x06;\r\ndata[2] = 0xC4;\r\ndata[3] = 0x40;\r\nascot2e_write_regs(priv, 0x01, data, 4);\r\ndata[0] = 0x10;\r\ndata[1] = 0x3F;\r\ndata[2] = 0x25;\r\nascot2e_write_regs(priv, 0x22, data, 3);\r\nascot2e_write_reg(priv, 0x28, 0x1e);\r\nascot2e_write_reg(priv, 0x59, 0x04);\r\nmsleep(80);\r\nascot2e_write_reg(priv, 0x4c, 0x01);\r\nascot2e_write_reg(priv, 0x07, 0x04);\r\nascot2e_write_reg(priv, 0x04, 0x00);\r\nascot2e_write_reg(priv, 0x03, 0xc0);\r\ndata[0] = 0x00;\r\ndata[1] = 0x04;\r\nascot2e_write_regs(priv, 0x14, data, 2);\r\nascot2e_write_reg(priv, 0x50, 0x01);\r\npriv->state = STATE_SLEEP;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nmemcpy(&fe->ops.tuner_ops, &ascot2e_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"Sony ASCOT2E attached on addr=%x at I2C adapter %p\n",\r\npriv->i2c_address, priv->i2c);\r\nreturn fe;\r\n}
