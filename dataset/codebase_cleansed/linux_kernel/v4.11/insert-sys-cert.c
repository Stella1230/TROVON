static unsigned char endianness(void)\r\n{\r\nuint16_t two_byte = 0x00FF;\r\nuint8_t low_address = *((uint8_t *)&two_byte);\r\nif (low_address == 0)\r\nreturn ELFDATA2MSB;\r\nelse\r\nreturn ELFDATA2LSB;\r\n}\r\nstatic unsigned long get_offset_from_address(Elf_Ehdr *hdr, unsigned long addr)\r\n{\r\nElf_Shdr *x;\r\nunsigned int i, num_sections;\r\nx = (void *)hdr + hdr->e_shoff;\r\nif (hdr->e_shnum == SHN_UNDEF)\r\nnum_sections = x[0].sh_size;\r\nelse\r\nnum_sections = hdr->e_shnum;\r\nfor (i = 1; i < num_sections; i++) {\r\nunsigned long start = x[i].sh_addr;\r\nunsigned long end = start + x[i].sh_size;\r\nunsigned long offset = x[i].sh_offset;\r\nif (addr >= start && addr <= end)\r\nreturn addr - start + offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic void get_symbol_from_map(Elf_Ehdr *hdr, FILE *f, char *name,\r\nstruct sym *s)\r\n{\r\nchar l[LINE_SIZE];\r\nchar *w, *p, *n;\r\ns->size = 0;\r\ns->address = 0;\r\ns->offset = 0;\r\nif (fseek(f, 0, SEEK_SET) != 0) {\r\nperror("File seek failed");\r\nexit(EXIT_FAILURE);\r\n}\r\nwhile (fgets(l, LINE_SIZE, f)) {\r\np = strchr(l, '\n');\r\nif (!p) {\r\nerr("Missing line ending.\n");\r\nreturn;\r\n}\r\nn = strstr(l, name);\r\nif (n)\r\nbreak;\r\n}\r\nif (!n) {\r\nerr("Unable to find symbol: %s\n", name);\r\nreturn;\r\n}\r\nw = strchr(l, ' ');\r\nif (!w)\r\nreturn;\r\n*w = '\0';\r\ns->address = strtoul(l, NULL, 16);\r\nif (s->address == 0)\r\nreturn;\r\ns->offset = get_offset_from_address(hdr, s->address);\r\ns->name = name;\r\ns->content = (void *)hdr + s->offset;\r\n}\r\nstatic Elf_Sym *find_elf_symbol(Elf_Ehdr *hdr, Elf_Shdr *symtab, char *name)\r\n{\r\nElf_Sym *sym, *symtab_start;\r\nchar *strtab, *symname;\r\nunsigned int link;\r\nElf_Shdr *x;\r\nint i, n;\r\nx = (void *)hdr + hdr->e_shoff;\r\nlink = symtab->sh_link;\r\nsymtab_start = (void *)hdr + symtab->sh_offset;\r\nn = symtab->sh_size / symtab->sh_entsize;\r\nstrtab = (void *)hdr + x[link].sh_offset;\r\nfor (i = 0; i < n; i++) {\r\nsym = &symtab_start[i];\r\nsymname = strtab + sym->st_name;\r\nif (strcmp(symname, name) == 0)\r\nreturn sym;\r\n}\r\nerr("Unable to find symbol: %s\n", name);\r\nreturn NULL;\r\n}\r\nstatic void get_symbol_from_table(Elf_Ehdr *hdr, Elf_Shdr *symtab,\r\nchar *name, struct sym *s)\r\n{\r\nElf_Shdr *sec;\r\nint secndx;\r\nElf_Sym *elf_sym;\r\nElf_Shdr *x;\r\nx = (void *)hdr + hdr->e_shoff;\r\ns->size = 0;\r\ns->address = 0;\r\ns->offset = 0;\r\nelf_sym = find_elf_symbol(hdr, symtab, name);\r\nif (!elf_sym)\r\nreturn;\r\nsecndx = elf_sym->st_shndx;\r\nif (!secndx)\r\nreturn;\r\nsec = &x[secndx];\r\ns->size = elf_sym->st_size;\r\ns->address = elf_sym->st_value;\r\ns->offset = s->address - sec->sh_addr\r\n+ sec->sh_offset;\r\ns->name = name;\r\ns->content = (void *)hdr + s->offset;\r\n}\r\nstatic Elf_Shdr *get_symbol_table(Elf_Ehdr *hdr)\r\n{\r\nElf_Shdr *x;\r\nunsigned int i, num_sections;\r\nx = (void *)hdr + hdr->e_shoff;\r\nif (hdr->e_shnum == SHN_UNDEF)\r\nnum_sections = x[0].sh_size;\r\nelse\r\nnum_sections = hdr->e_shnum;\r\nfor (i = 1; i < num_sections; i++)\r\nif (x[i].sh_type == SHT_SYMTAB)\r\nreturn &x[i];\r\nreturn NULL;\r\n}\r\nstatic void *map_file(char *file_name, int *size)\r\n{\r\nstruct stat st;\r\nvoid *map;\r\nint fd;\r\nfd = open(file_name, O_RDWR);\r\nif (fd < 0) {\r\nperror(file_name);\r\nreturn NULL;\r\n}\r\nif (fstat(fd, &st)) {\r\nperror("Could not determine file size");\r\nclose(fd);\r\nreturn NULL;\r\n}\r\n*size = st.st_size;\r\nmap = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\r\nif (map == MAP_FAILED) {\r\nperror("Mapping to memory failed");\r\nclose(fd);\r\nreturn NULL;\r\n}\r\nclose(fd);\r\nreturn map;\r\n}\r\nstatic char *read_file(char *file_name, int *size)\r\n{\r\nstruct stat st;\r\nchar *buf;\r\nint fd;\r\nfd = open(file_name, O_RDONLY);\r\nif (fd < 0) {\r\nperror(file_name);\r\nreturn NULL;\r\n}\r\nif (fstat(fd, &st)) {\r\nperror("Could not determine file size");\r\nclose(fd);\r\nreturn NULL;\r\n}\r\n*size = st.st_size;\r\nbuf = malloc(*size);\r\nif (!buf) {\r\nperror("Allocating memory failed");\r\nclose(fd);\r\nreturn NULL;\r\n}\r\nif (read(fd, buf, *size) != *size) {\r\nperror("File read failed");\r\nclose(fd);\r\nreturn NULL;\r\n}\r\nclose(fd);\r\nreturn buf;\r\n}\r\nstatic void print_sym(Elf_Ehdr *hdr, struct sym *s)\r\n{\r\ninfo("sym: %s\n", s->name);\r\ninfo("addr: 0x%lx\n", s->address);\r\ninfo("size: %d\n", s->size);\r\ninfo("offset: 0x%lx\n", (unsigned long)s->offset);\r\n}\r\nstatic void print_usage(char *e)\r\n{\r\nprintf("Usage %s [-s <System.map>] -b <vmlinux> -c <certfile>\n", e);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nchar *system_map_file = NULL;\r\nchar *vmlinux_file = NULL;\r\nchar *cert_file = NULL;\r\nint vmlinux_size;\r\nint cert_size;\r\nElf_Ehdr *hdr;\r\nchar *cert;\r\nFILE *system_map;\r\nunsigned long *lsize;\r\nint *used;\r\nint opt;\r\nElf_Shdr *symtab = NULL;\r\nstruct sym cert_sym, lsize_sym, used_sym;\r\nwhile ((opt = getopt(argc, argv, "b:c:s:")) != -1) {\r\nswitch (opt) {\r\ncase 's':\r\nsystem_map_file = optarg;\r\nbreak;\r\ncase 'b':\r\nvmlinux_file = optarg;\r\nbreak;\r\ncase 'c':\r\ncert_file = optarg;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (!vmlinux_file || !cert_file) {\r\nprint_usage(argv[0]);\r\nexit(EXIT_FAILURE);\r\n}\r\ncert = read_file(cert_file, &cert_size);\r\nif (!cert)\r\nexit(EXIT_FAILURE);\r\nhdr = map_file(vmlinux_file, &vmlinux_size);\r\nif (!hdr)\r\nexit(EXIT_FAILURE);\r\nif (vmlinux_size < sizeof(*hdr)) {\r\nerr("Invalid ELF file.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nif ((hdr->e_ident[EI_MAG0] != ELFMAG0) ||\r\n(hdr->e_ident[EI_MAG1] != ELFMAG1) ||\r\n(hdr->e_ident[EI_MAG2] != ELFMAG2) ||\r\n(hdr->e_ident[EI_MAG3] != ELFMAG3)) {\r\nerr("Invalid ELF magic.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nif (hdr->e_ident[EI_CLASS] != CURRENT_ELFCLASS) {\r\nerr("ELF class mismatch.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nif (hdr->e_ident[EI_DATA] != endianness()) {\r\nerr("ELF endian mismatch.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nif (hdr->e_shoff > vmlinux_size) {\r\nerr("Could not find section header.\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nsymtab = get_symbol_table(hdr);\r\nif (!symtab) {\r\nwarn("Could not find the symbol table.\n");\r\nif (!system_map_file) {\r\nerr("Please provide a System.map file.\n");\r\nprint_usage(argv[0]);\r\nexit(EXIT_FAILURE);\r\n}\r\nsystem_map = fopen(system_map_file, "r");\r\nif (!system_map) {\r\nperror(system_map_file);\r\nexit(EXIT_FAILURE);\r\n}\r\nget_symbol_from_map(hdr, system_map, CERT_SYM, &cert_sym);\r\nget_symbol_from_map(hdr, system_map, USED_SYM, &used_sym);\r\nget_symbol_from_map(hdr, system_map, LSIZE_SYM, &lsize_sym);\r\ncert_sym.size = used_sym.address - cert_sym.address;\r\n} else {\r\ninfo("Symbol table found.\n");\r\nif (system_map_file)\r\nwarn("System.map is ignored.\n");\r\nget_symbol_from_table(hdr, symtab, CERT_SYM, &cert_sym);\r\nget_symbol_from_table(hdr, symtab, USED_SYM, &used_sym);\r\nget_symbol_from_table(hdr, symtab, LSIZE_SYM, &lsize_sym);\r\n}\r\nif (!cert_sym.offset || !lsize_sym.offset || !used_sym.offset)\r\nexit(EXIT_FAILURE);\r\nprint_sym(hdr, &cert_sym);\r\nprint_sym(hdr, &used_sym);\r\nprint_sym(hdr, &lsize_sym);\r\nlsize = (unsigned long *)lsize_sym.content;\r\nused = (int *)used_sym.content;\r\nif (cert_sym.size < cert_size) {\r\nerr("Certificate is larger than the reserved area!\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nif (cert_size == *used &&\r\nstrncmp(cert_sym.content, cert, cert_size) == 0) {\r\nwarn("Certificate was already inserted.\n");\r\nexit(EXIT_SUCCESS);\r\n}\r\nif (*used > 0)\r\nwarn("Replacing previously inserted certificate.\n");\r\nmemcpy(cert_sym.content, cert, cert_size);\r\nif (cert_size < cert_sym.size)\r\nmemset(cert_sym.content + cert_size,\r\n0, cert_sym.size - cert_size);\r\n*lsize = *lsize + cert_size - *used;\r\n*used = cert_size;\r\ninfo("Inserted the contents of %s into %lx.\n", cert_file,\r\ncert_sym.address);\r\ninfo("Used %d bytes out of %d bytes reserved.\n", *used,\r\ncert_sym.size);\r\nexit(EXIT_SUCCESS);\r\n}
