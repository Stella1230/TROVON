static unsigned long chip_11_errata(unsigned long memsize)\r\n{\r\nunsigned long pvr;\r\npvr = mfpvr();\r\nswitch (pvr & 0xf0000ff0) {\r\ncase 0x40000850:\r\ncase 0x400008d0:\r\ncase 0x200008d0:\r\nmemsize -= 4096;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn memsize;\r\n}\r\nvoid ibm4xx_sdram_fixup_memsize(void)\r\n{\r\nint i;\r\nunsigned long memsize, bank_config;\r\nmemsize = 0;\r\nfor (i = 0; i < ARRAY_SIZE(sdram_bxcr); i++) {\r\nbank_config = SDRAM0_READ(sdram_bxcr[i]);\r\nif (bank_config & SDRAM_CONFIG_BANK_ENABLE)\r\nmemsize += SDRAM_CONFIG_BANK_SIZE(bank_config);\r\n}\r\nmemsize = chip_11_errata(memsize);\r\ndt_fixup_memory(0, memsize);\r\n}\r\nstatic u64 ibm440spe_decode_bas(u32 bas)\r\n{\r\nu64 base = ((u64)(bas & 0xFFE00000u)) << 2;\r\nswitch ((bas >> 4) & 0xFFF) {\r\ncase 0:\r\nreturn 0;\r\ncase 0xffc:\r\nreturn base + 0x000800000ull;\r\ncase 0xff8:\r\nreturn base + 0x001000000ull;\r\ncase 0xff0:\r\nreturn base + 0x002000000ull;\r\ncase 0xfe0:\r\nreturn base + 0x004000000ull;\r\ncase 0xfc0:\r\nreturn base + 0x008000000ull;\r\ncase 0xf80:\r\nreturn base + 0x010000000ull;\r\ncase 0xf00:\r\nreturn base + 0x020000000ull;\r\ncase 0xe00:\r\nreturn base + 0x040000000ull;\r\ncase 0xc00:\r\nreturn base + 0x080000000ull;\r\ncase 0x800:\r\nreturn base + 0x100000000ull;\r\n}\r\nprintf("Memory BAS value 0x%08x unsupported !\n", bas);\r\nreturn 0;\r\n}\r\nvoid ibm440spe_fixup_memsize(void)\r\n{\r\nu64 banktop, memsize = 0;\r\nbanktop = ibm440spe_decode_bas(mfdcr(DCRN_MQ0_B0BAS));\r\nif (banktop > memsize)\r\nmemsize = banktop;\r\nbanktop = ibm440spe_decode_bas(mfdcr(DCRN_MQ0_B1BAS));\r\nif (banktop > memsize)\r\nmemsize = banktop;\r\nbanktop = ibm440spe_decode_bas(mfdcr(DCRN_MQ0_B2BAS));\r\nif (banktop > memsize)\r\nmemsize = banktop;\r\nbanktop = ibm440spe_decode_bas(mfdcr(DCRN_MQ0_B3BAS));\r\nif (banktop > memsize)\r\nmemsize = banktop;\r\ndt_fixup_memory(0, memsize);\r\n}\r\nstatic inline u32 ibm4xx_denali_get_cs(void)\r\n{\r\nvoid *devp;\r\nchar model[64];\r\nu32 val, cs;\r\ndevp = finddevice("/");\r\nif (!devp)\r\ngoto read_cs;\r\nif (getprop(devp, "model", model, sizeof(model)) <= 0)\r\ngoto read_cs;\r\nmodel[sizeof(model)-1] = 0;\r\nif (!strcmp(model, "amcc,sequoia") ||\r\n!strcmp(model, "amcc,rainier"))\r\nreturn 1;\r\nread_cs:\r\nval = SDRAM0_READ(DDR0_10);\r\nval = DDR_GET_VAL(val, DDR_CS_MAP, DDR_CS_MAP_SHIFT);\r\ncs = 0;\r\nwhile (val) {\r\nif (val & 0x1)\r\ncs++;\r\nval = val >> 1;\r\n}\r\nreturn cs;\r\n}\r\nvoid ibm4xx_denali_fixup_memsize(void)\r\n{\r\nu32 val, max_cs, max_col, max_row;\r\nu32 cs, col, row, bank, dpath;\r\nunsigned long memsize;\r\nval = SDRAM0_READ(DDR0_02);\r\nif (!DDR_GET_VAL(val, DDR_START, DDR_START_SHIFT))\r\nfatal("DDR controller is not initialized\n");\r\nmax_cs = DDR_GET_VAL(val, DDR_MAX_CS_REG, DDR_MAX_CS_REG_SHIFT);\r\nmax_col = DDR_GET_VAL(val, DDR_MAX_COL_REG, DDR_MAX_COL_REG_SHIFT);\r\nmax_row = DDR_GET_VAL(val, DDR_MAX_ROW_REG, DDR_MAX_ROW_REG_SHIFT);\r\ncs = ibm4xx_denali_get_cs();\r\nif (!cs)\r\nfatal("No memory installed\n");\r\nif (cs > max_cs)\r\nfatal("DDR wrong CS configuration\n");\r\nval = SDRAM0_READ(DDR0_14);\r\nif (DDR_GET_VAL(val, DDR_REDUC, DDR_REDUC_SHIFT))\r\ndpath = 4;\r\nelse\r\ndpath = 8;\r\nval = SDRAM0_READ(DDR0_42);\r\nrow = DDR_GET_VAL(val, DDR_APIN, DDR_APIN_SHIFT);\r\nif (row > max_row)\r\nfatal("DDR wrong APIN configuration\n");\r\nrow = max_row - row;\r\nval = SDRAM0_READ(DDR0_43);\r\ncol = DDR_GET_VAL(val, DDR_COL_SZ, DDR_COL_SZ_SHIFT);\r\nif (col > max_col)\r\nfatal("DDR wrong COL configuration\n");\r\ncol = max_col - col;\r\nif (DDR_GET_VAL(val, DDR_BANK8, DDR_BANK8_SHIFT))\r\nbank = 8;\r\nelse\r\nbank = 4;\r\nmemsize = cs * (1 << (col+row)) * bank * dpath;\r\nmemsize = chip_11_errata(memsize);\r\ndt_fixup_memory(0, memsize);\r\n}\r\nvoid ibm44x_dbcr_reset(void)\r\n{\r\nunsigned long tmp;\r\nasm volatile (\r\n"mfspr %0,%1\n"\r\n"oris %0,%0,%2@h\n"\r\n"mtspr %1,%0"\r\n: "=&r"(tmp) : "i"(SPRN_DBCR0_44X), "i"(DBCR0_RST_SYSTEM)\r\n);\r\n}\r\nvoid ibm40x_dbcr_reset(void)\r\n{\r\nunsigned long tmp;\r\nasm volatile (\r\n"mfspr %0,%1\n"\r\n"oris %0,%0,%2@h\n"\r\n"mtspr %1,%0"\r\n: "=&r"(tmp) : "i"(SPRN_DBCR0_40X), "i"(DBCR0_RST_SYSTEM)\r\n);\r\n}\r\nvoid ibm4xx_quiesce_eth(u32 *emac0, u32 *emac1)\r\n{\r\nif (emac0)\r\n*emac0 = EMAC_RESET;\r\nif (emac1)\r\n*emac1 = EMAC_RESET;\r\nmtdcr(DCRN_MAL0_CFG, MAL_RESET);\r\nwhile (mfdcr(DCRN_MAL0_CFG) & MAL_RESET)\r\n;\r\n}\r\nvoid ibm4xx_fixup_ebc_ranges(const char *ebc)\r\n{\r\nvoid *devp;\r\nu32 bxcr;\r\nu32 ranges[EBC_NUM_BANKS*4];\r\nu32 *p = ranges;\r\nint i;\r\nfor (i = 0; i < EBC_NUM_BANKS; i++) {\r\nmtdcr(DCRN_EBC0_CFGADDR, EBC_BXCR(i));\r\nbxcr = mfdcr(DCRN_EBC0_CFGDATA);\r\nif ((bxcr & EBC_BXCR_BU) != EBC_BXCR_BU_OFF) {\r\n*p++ = i;\r\n*p++ = 0;\r\n*p++ = bxcr & EBC_BXCR_BAS;\r\n*p++ = EBC_BXCR_BANK_SIZE(bxcr);\r\n}\r\n}\r\ndevp = finddevice(ebc);\r\nif (! devp)\r\nfatal("Couldn't locate EBC node %s\n\r", ebc);\r\nsetprop(devp, "ranges", ranges, (p - ranges) * sizeof(u32));\r\n}\r\nvoid ibm440gp_fixup_clocks(unsigned int sys_clk, unsigned int ser_clk)\r\n{\r\nu32 sys0 = mfdcr(DCRN_CPC0_SYS0);\r\nu32 cr0 = mfdcr(DCRN_CPC0_CR0);\r\nu32 cpu, plb, opb, ebc, tb, uart0, uart1, m;\r\nu32 opdv = CPC0_SYS0_OPDV(sys0);\r\nu32 epdv = CPC0_SYS0_EPDV(sys0);\r\nif (sys0 & CPC0_SYS0_BYPASS) {\r\ncpu = plb = sys_clk;\r\n} else {\r\nif (sys0 & CPC0_SYS0_EXTSL)\r\nm = CPC0_SYS0_FWDVB(sys0) * opdv * epdv;\r\nelse\r\nm = CPC0_SYS0_FBDV(sys0) * CPC0_SYS0_FWDVA(sys0);\r\ncpu = sys_clk * m / CPC0_SYS0_FWDVA(sys0);\r\nplb = sys_clk * m / CPC0_SYS0_FWDVB(sys0);\r\n}\r\nopb = plb / opdv;\r\nebc = opb / epdv;\r\nif ((mfpvr() & 0xf0000fff) == 0x40000440)\r\ntb = sys_clk;\r\nelse\r\ntb = cpu;\r\nif (cr0 & CPC0_CR0_U0EC)\r\nuart0 = ser_clk;\r\nelse\r\nuart0 = plb / CPC0_CR0_UDIV(cr0);\r\nif (cr0 & CPC0_CR0_U1EC)\r\nuart1 = ser_clk;\r\nelse\r\nuart1 = plb / CPC0_CR0_UDIV(cr0);\r\nprintf("PPC440GP: SysClk = %dMHz (%x)\n\r",\r\n(sys_clk + 500000) / 1000000, sys_clk);\r\ndt_fixup_cpu_clocks(cpu, tb, 0);\r\ndt_fixup_clock("/plb", plb);\r\ndt_fixup_clock("/plb/opb", opb);\r\ndt_fixup_clock("/plb/opb/ebc", ebc);\r\ndt_fixup_clock("/plb/opb/serial@40000200", uart0);\r\ndt_fixup_clock("/plb/opb/serial@40000300", uart1);\r\n}\r\nstatic inline u32 __fix_zero(u32 v, u32 def)\r\n{\r\nreturn v ? v : def;\r\n}\r\nstatic unsigned int __ibm440eplike_fixup_clocks(unsigned int sys_clk,\r\nunsigned int tmr_clk,\r\nint per_clk_from_opb)\r\n{\r\nu32 pllc = CPR0_READ(DCRN_CPR0_PLLC);\r\nu32 plld = CPR0_READ(DCRN_CPR0_PLLD);\r\nu32 fbdv = __fix_zero((plld >> 24) & 0x1f, 32);\r\nu32 fwdva = __fix_zero((plld >> 16) & 0xf, 16);\r\nu32 fwdvb = __fix_zero((plld >> 8) & 7, 8);\r\nu32 lfbdv = __fix_zero(plld & 0x3f, 64);\r\nu32 pradv0 = __fix_zero((CPR0_READ(DCRN_CPR0_PRIMAD) >> 24) & 7, 8);\r\nu32 prbdv0 = __fix_zero((CPR0_READ(DCRN_CPR0_PRIMBD) >> 24) & 7, 8);\r\nu32 opbdv0 = __fix_zero((CPR0_READ(DCRN_CPR0_OPBD) >> 24) & 3, 4);\r\nu32 perdv0 = __fix_zero((CPR0_READ(DCRN_CPR0_PERD) >> 24) & 3, 4);\r\nu32 clk_a, clk_b;\r\nu32 cpu, plb, opb, ebc, vco;\r\nu32 ccr1, tb = tmr_clk;\r\nif (pllc & 0x40000000) {\r\nu32 m;\r\nswitch ((pllc >> 24) & 7) {\r\ncase 0:\r\nm = ((pllc & 0x20000000) ? fwdvb : fwdva) * lfbdv;\r\nbreak;\r\ncase 1:\r\nm = fwdva * pradv0;\r\nbreak;\r\ncase 5:\r\nm = fwdvb * prbdv0 * opbdv0 * perdv0;\r\nbreak;\r\ndefault:\r\nprintf("WARNING ! Invalid PLL feedback source !\n");\r\ngoto bypass;\r\n}\r\nm *= fbdv;\r\nvco = sys_clk * m;\r\nclk_a = vco / fwdva;\r\nclk_b = vco / fwdvb;\r\n} else {\r\nbypass:\r\nvco = 0;\r\nclk_a = clk_b = sys_clk;\r\n}\r\ncpu = clk_a / pradv0;\r\nplb = clk_b / prbdv0;\r\nopb = plb / opbdv0;\r\nebc = (per_clk_from_opb ? opb : plb) / perdv0;\r\nccr1 = mfspr(SPRN_CCR1);\r\nif (tb == 0) {\r\nccr1 &= ~0x80u;\r\nmtspr(SPRN_CCR1, ccr1);\r\n}\r\nif ((ccr1 & 0x0080) == 0)\r\ntb = cpu;\r\ndt_fixup_cpu_clocks(cpu, tb, 0);\r\ndt_fixup_clock("/plb", plb);\r\ndt_fixup_clock("/plb/opb", opb);\r\ndt_fixup_clock("/plb/opb/ebc", ebc);\r\nreturn plb;\r\n}\r\nstatic void eplike_fixup_uart_clk(int index, const char *path,\r\nunsigned int ser_clk,\r\nunsigned int plb_clk)\r\n{\r\nunsigned int sdr;\r\nunsigned int clock;\r\nswitch (index) {\r\ncase 0:\r\nsdr = SDR0_READ(DCRN_SDR0_UART0);\r\nbreak;\r\ncase 1:\r\nsdr = SDR0_READ(DCRN_SDR0_UART1);\r\nbreak;\r\ncase 2:\r\nsdr = SDR0_READ(DCRN_SDR0_UART2);\r\nbreak;\r\ncase 3:\r\nsdr = SDR0_READ(DCRN_SDR0_UART3);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (sdr & 0x00800000u)\r\nclock = ser_clk;\r\nelse\r\nclock = plb_clk / __fix_zero(sdr & 0xff, 256);\r\ndt_fixup_clock(path, clock);\r\n}\r\nvoid ibm440ep_fixup_clocks(unsigned int sys_clk,\r\nunsigned int ser_clk,\r\nunsigned int tmr_clk)\r\n{\r\nunsigned int plb_clk = __ibm440eplike_fixup_clocks(sys_clk, tmr_clk, 0);\r\neplike_fixup_uart_clk(0, "/plb/opb/serial@ef600300", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(1, "/plb/opb/serial@ef600400", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(2, "/plb/opb/serial@ef600500", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(3, "/plb/opb/serial@ef600600", ser_clk, plb_clk);\r\n}\r\nvoid ibm440gx_fixup_clocks(unsigned int sys_clk,\r\nunsigned int ser_clk,\r\nunsigned int tmr_clk)\r\n{\r\nunsigned int plb_clk = __ibm440eplike_fixup_clocks(sys_clk, tmr_clk, 1);\r\neplike_fixup_uart_clk(0, "/plb/opb/serial@40000200", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(1, "/plb/opb/serial@40000300", ser_clk, plb_clk);\r\n}\r\nvoid ibm440spe_fixup_clocks(unsigned int sys_clk,\r\nunsigned int ser_clk,\r\nunsigned int tmr_clk)\r\n{\r\nunsigned int plb_clk = __ibm440eplike_fixup_clocks(sys_clk, tmr_clk, 1);\r\neplike_fixup_uart_clk(0, "/plb/opb/serial@f0000200", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(1, "/plb/opb/serial@f0000300", ser_clk, plb_clk);\r\neplike_fixup_uart_clk(2, "/plb/opb/serial@f0000600", ser_clk, plb_clk);\r\n}\r\nvoid ibm405gp_fixup_clocks(unsigned int sys_clk, unsigned int ser_clk)\r\n{\r\nu32 pllmr = mfdcr(DCRN_CPC0_PLLMR);\r\nu32 cpc0_cr0 = mfdcr(DCRN_405_CPC0_CR0);\r\nu32 cpc0_cr1 = mfdcr(DCRN_405_CPC0_CR1);\r\nu32 psr = mfdcr(DCRN_405_CPC0_PSR);\r\nu32 cpu, plb, opb, ebc, tb, uart0, uart1, m;\r\nu32 fwdv, fwdvb, fbdv, cbdv, opdv, epdv, ppdv, udiv;\r\nfwdv = (8 - ((pllmr & 0xe0000000) >> 29));\r\nfbdv = (pllmr & 0x1e000000) >> 25;\r\nif (fbdv == 0)\r\nfbdv = 16;\r\ncbdv = ((pllmr & 0x00060000) >> 17) + 1;\r\nopdv = ((pllmr & 0x00018000) >> 15) + 1;\r\nppdv = ((pllmr & 0x00001800) >> 13) + 1;\r\nepdv = ((pllmr & 0x00001800) >> 11) + 2;\r\nudiv = ((cpc0_cr0 & 0x3e) >> 1) + 1;\r\nif ((mfpvr() & 0xfffffff0) == (0x50910951 & 0xfffffff0)) {\r\nfwdvb = 8 - (pllmr & 0x00000007);\r\nif (!(psr & 0x00001000))\r\nif (psr & 0x00000020)\r\nm = fwdvb * 2 * ppdv;\r\nelse\r\nm = fwdvb * cbdv * ppdv;\r\nelse if (psr & 0x00000020)\r\nif (psr & 0x00000800)\r\nm = fwdvb * 2 * epdv;\r\nelse\r\nm = fbdv * fwdv;\r\nelse if (epdv == fbdv)\r\nm = fbdv * cbdv * epdv;\r\nelse\r\nm = fbdv * fwdvb * cbdv;\r\ncpu = sys_clk * m / fwdv;\r\nplb = sys_clk * m / (fwdvb * cbdv);\r\n} else {\r\nm = fwdv * fbdv * cbdv;\r\ncpu = sys_clk * m / fwdv;\r\nplb = cpu / cbdv;\r\n}\r\nopb = plb / opdv;\r\nebc = plb / epdv;\r\nif (cpc0_cr0 & 0x80)\r\nuart0 = ser_clk;\r\nelse\r\nuart0 = cpu / udiv;\r\nif (cpc0_cr0 & 0x40)\r\nuart1 = ser_clk;\r\nelse\r\nuart1 = cpu / udiv;\r\ncpc0_cr1 = cpc0_cr1 & ~0x00800000;\r\nmtdcr(DCRN_405_CPC0_CR1, cpc0_cr1);\r\ntb = cpu;\r\ndt_fixup_cpu_clocks(cpu, tb, 0);\r\ndt_fixup_clock("/plb", plb);\r\ndt_fixup_clock("/plb/opb", opb);\r\ndt_fixup_clock("/plb/ebc", ebc);\r\ndt_fixup_clock("/plb/opb/serial@ef600300", uart0);\r\ndt_fixup_clock("/plb/opb/serial@ef600400", uart1);\r\n}\r\nvoid ibm405ep_fixup_clocks(unsigned int sys_clk)\r\n{\r\nu32 pllmr0 = mfdcr(DCRN_CPC0_PLLMR0);\r\nu32 pllmr1 = mfdcr(DCRN_CPC0_PLLMR1);\r\nu32 cpc0_ucr = mfdcr(DCRN_CPC0_UCR);\r\nu32 cpu, plb, opb, ebc, uart0, uart1;\r\nu32 fwdva, fwdvb, fbdv, cbdv, opdv, epdv;\r\nu32 pllmr0_ccdv, tb, m;\r\nfwdva = 8 - ((pllmr1 & 0x00070000) >> 16);\r\nfwdvb = 8 - ((pllmr1 & 0x00007000) >> 12);\r\nfbdv = (pllmr1 & 0x00f00000) >> 20;\r\nif (fbdv == 0)\r\nfbdv = 16;\r\ncbdv = ((pllmr0 & 0x00030000) >> 16) + 1;\r\nepdv = ((pllmr0 & 0x00000300) >> 8) + 2;\r\nopdv = ((pllmr0 & 0x00003000) >> 12) + 1;\r\nm = fbdv * fwdvb;\r\npllmr0_ccdv = ((pllmr0 & 0x00300000) >> 20) + 1;\r\nif (pllmr1 & 0x80000000)\r\ncpu = sys_clk * m / (fwdva * pllmr0_ccdv);\r\nelse\r\ncpu = sys_clk / pllmr0_ccdv;\r\nplb = cpu / cbdv;\r\nopb = plb / opdv;\r\nebc = plb / epdv;\r\ntb = cpu;\r\nuart0 = cpu / (cpc0_ucr & 0x0000007f);\r\nuart1 = cpu / ((cpc0_ucr & 0x00007f00) >> 8);\r\ndt_fixup_cpu_clocks(cpu, tb, 0);\r\ndt_fixup_clock("/plb", plb);\r\ndt_fixup_clock("/plb/opb", opb);\r\ndt_fixup_clock("/plb/ebc", ebc);\r\ndt_fixup_clock("/plb/opb/serial@ef600300", uart0);\r\ndt_fixup_clock("/plb/opb/serial@ef600400", uart1);\r\n}\r\nu32 ibm405ex_get_fwdva(unsigned long cpr_fwdv)\r\n{\r\nu32 index;\r\nfor (index = 0; index < ARRAY_SIZE(ibm405ex_fwdv_multi_bits); index++)\r\nif (cpr_fwdv == (u32)ibm405ex_fwdv_multi_bits[index])\r\nreturn index + 1;\r\nreturn 0;\r\n}\r\nu32 ibm405ex_get_fbdv(unsigned long cpr_fbdv)\r\n{\r\nu32 index;\r\nfor (index = 0; index < ARRAY_SIZE(ibm405ex_fbdv_multi_bits); index++)\r\nif (cpr_fbdv == (u32)ibm405ex_fbdv_multi_bits[index])\r\nreturn index + 1;\r\nreturn 0;\r\n}\r\nvoid ibm405ex_fixup_clocks(unsigned int sys_clk, unsigned int uart_clk)\r\n{\r\nu32 pllc = CPR0_READ(DCRN_CPR0_PLLC);\r\nu32 plld = CPR0_READ(DCRN_CPR0_PLLD);\r\nu32 cpud = CPR0_READ(DCRN_CPR0_PRIMAD);\r\nu32 plbd = CPR0_READ(DCRN_CPR0_PRIMBD);\r\nu32 opbd = CPR0_READ(DCRN_CPR0_OPBD);\r\nu32 perd = CPR0_READ(DCRN_CPR0_PERD);\r\nu32 fbdv = ibm405ex_get_fbdv(__fix_zero((plld >> 24) & 0xff, 1));\r\nu32 fwdva = ibm405ex_get_fwdva(__fix_zero((plld >> 16) & 0x0f, 1));\r\nu32 cpudv0 = __fix_zero((cpud >> 24) & 7, 8);\r\nu32 plbdv0 = 2;\r\nu32 plb2xdv0 = __fix_zero((plbd >> 16) & 7, 8);\r\nu32 opbdv0 = __fix_zero((opbd >> 24) & 3, 4);\r\nu32 perdv0 = __fix_zero((perd >> 24) & 3, 4);\r\nu32 cpu, plb, opb, ebc, vco, tb, uart0, uart1;\r\nif (pllc & 0x40000000) {\r\nu32 m;\r\nswitch ((pllc >> 24) & 7) {\r\ncase 0:\r\nm = fbdv;\r\nbreak;\r\ncase 1:\r\nm = fbdv * fwdva * cpudv0;\r\nbreak;\r\ncase 5:\r\nm = fbdv * fwdva * plb2xdv0 * plbdv0 * opbdv0 * perdv0;\r\nbreak;\r\ndefault:\r\nprintf("WARNING ! Invalid PLL feedback source !\n");\r\ngoto bypass;\r\n}\r\nvco = (unsigned int)(sys_clk * m);\r\n} else {\r\nbypass:\r\nvco = 0;\r\n}\r\ncpu = vco / (fwdva * cpudv0);\r\nplb = vco / (fwdva * plb2xdv0 * plbdv0);\r\nopb = plb / opbdv0;\r\nebc = opb / perdv0;\r\ntb = cpu;\r\nuart0 = uart1 = uart_clk;\r\ndt_fixup_cpu_clocks(cpu, tb, 0);\r\ndt_fixup_clock("/plb", plb);\r\ndt_fixup_clock("/plb/opb", opb);\r\ndt_fixup_clock("/plb/opb/ebc", ebc);\r\ndt_fixup_clock("/plb/opb/serial@ef600200", uart0);\r\ndt_fixup_clock("/plb/opb/serial@ef600300", uart1);\r\n}
