int arizona_clk32k_enable(struct arizona *arizona)\r\n{\r\nint ret = 0;\r\nmutex_lock(&arizona->clk_lock);\r\narizona->clk32k_ref++;\r\nif (arizona->clk32k_ref == 1) {\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\nret = pm_runtime_get_sync(arizona->dev);\r\nif (ret != 0)\r\ngoto err_ref;\r\nret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK1]);\r\nif (ret != 0)\r\ngoto err_pm;\r\nbreak;\r\ncase ARIZONA_32KZ_MCLK2:\r\nret = clk_prepare_enable(arizona->mclk[ARIZONA_MCLK2]);\r\nif (ret != 0)\r\ngoto err_ref;\r\nbreak;\r\n}\r\nret = regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_ENA,\r\nARIZONA_CLK_32K_ENA);\r\n}\r\nerr_pm:\r\npm_runtime_put_sync(arizona->dev);\r\nerr_ref:\r\nif (ret != 0)\r\narizona->clk32k_ref--;\r\nmutex_unlock(&arizona->clk_lock);\r\nreturn ret;\r\n}\r\nint arizona_clk32k_disable(struct arizona *arizona)\r\n{\r\nmutex_lock(&arizona->clk_lock);\r\nBUG_ON(arizona->clk32k_ref <= 0);\r\narizona->clk32k_ref--;\r\nif (arizona->clk32k_ref == 0) {\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_ENA, 0);\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\npm_runtime_put_sync(arizona->dev);\r\nclk_disable_unprepare(arizona->mclk[ARIZONA_MCLK1]);\r\nbreak;\r\ncase ARIZONA_32KZ_MCLK2:\r\nclk_disable_unprepare(arizona->mclk[ARIZONA_MCLK2]);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&arizona->clk_lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t arizona_clkgen_err(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\ndev_err(arizona->dev, "CLKGEN error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_underclocked(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_8,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read underclock status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nif (val & ARIZONA_AIF3_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF3 underclocked\n");\r\nif (val & ARIZONA_AIF2_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF2 underclocked\n");\r\nif (val & ARIZONA_AIF1_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF1 underclocked\n");\r\nif (val & ARIZONA_ISRC3_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC3 underclocked\n");\r\nif (val & ARIZONA_ISRC2_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC2 underclocked\n");\r\nif (val & ARIZONA_ISRC1_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC1 underclocked\n");\r\nif (val & ARIZONA_FX_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "FX underclocked\n");\r\nif (val & ARIZONA_ASRC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC underclocked\n");\r\nif (val & ARIZONA_DAC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC underclocked\n");\r\nif (val & ARIZONA_ADC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ADC underclocked\n");\r\nif (val & ARIZONA_MIXER_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "Mixer dropped sample\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_overclocked(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val[3];\r\nint ret;\r\nret = regmap_bulk_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_6,\r\n&val[0], 3);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read overclock status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nswitch (arizona->type) {\r\ncase WM8998:\r\ncase WM1814:\r\nval[0] = ((val[0] & 0x60e0) >> 1) |\r\n((val[0] & 0x1e00) >> 2) |\r\n(val[0] & 0x000f);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (val[0] & ARIZONA_PWM_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "PWM overclocked\n");\r\nif (val[0] & ARIZONA_FX_CORE_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "FX core overclocked\n");\r\nif (val[0] & ARIZONA_DAC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC SYS overclocked\n");\r\nif (val[0] & ARIZONA_DAC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC WARP overclocked\n");\r\nif (val[0] & ARIZONA_ADC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ADC overclocked\n");\r\nif (val[0] & ARIZONA_MIXER_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Mixer overclocked\n");\r\nif (val[0] & ARIZONA_AIF3_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF3 overclocked\n");\r\nif (val[0] & ARIZONA_AIF2_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF2 overclocked\n");\r\nif (val[0] & ARIZONA_AIF1_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF1 overclocked\n");\r\nif (val[0] & ARIZONA_PAD_CTRL_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Pad control overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_SUBSYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus subsystem overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_ASYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus async overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus sync overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_ASYNC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC async system overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_ASYNC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC async WARP overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_SYNC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC sync system overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_SYNC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC sync WARP overclocked\n");\r\nif (val[1] & ARIZONA_ADSP2_1_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DSP1 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC3_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC3 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC2_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC2 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC1_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC1 overclocked\n");\r\nif (val[2] & ARIZONA_SPDIF_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "SPDIF overclocked\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arizona_poll_reg(struct arizona *arizona,\r\nint timeout, unsigned int reg,\r\nunsigned int mask, unsigned int target)\r\n{\r\nunsigned int val = 0;\r\nint ret, i;\r\nfor (i = 0; i < timeout; i++) {\r\nret = regmap_read(arizona->regmap, reg, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read reg %u: %d\n",\r\nreg, ret);\r\ncontinue;\r\n}\r\nif ((val & mask) == target)\r\nreturn 0;\r\nusleep_range(1000, 5000);\r\n}\r\ndev_err(arizona->dev, "Polling reg %u timed out: %x\n", reg, val);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int arizona_wait_for_boot(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = arizona_poll_reg(arizona, 5, ARIZONA_INTERRUPT_RAW_STATUS_5,\r\nARIZONA_BOOT_DONE_STS, ARIZONA_BOOT_DONE_STS);\r\nif (!ret)\r\nregmap_write(arizona->regmap, ARIZONA_INTERRUPT_STATUS_5,\r\nARIZONA_BOOT_DONE_STS);\r\npm_runtime_mark_last_busy(arizona->dev);\r\nreturn ret;\r\n}\r\nstatic inline void arizona_enable_reset(struct arizona *arizona)\r\n{\r\nif (arizona->pdata.reset)\r\ngpio_set_value_cansleep(arizona->pdata.reset, 0);\r\n}\r\nstatic void arizona_disable_reset(struct arizona *arizona)\r\n{\r\nif (arizona->pdata.reset) {\r\nswitch (arizona->type) {\r\ncase WM5110:\r\ncase WM8280:\r\nusleep_range(5000, 10000);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngpio_set_value_cansleep(arizona->pdata.reset, 1);\r\nusleep_range(1000, 5000);\r\n}\r\n}\r\nstatic int arizona_enable_freerun_sysclk(struct arizona *arizona,\r\nstruct arizona_sysclk_state *state)\r\n{\r\nint ret, err;\r\nret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &state->fll);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to cache FLL settings: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1,\r\n&state->sysclk);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to cache SYSCLK settings: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1,\r\nARIZONA_FLL1_ENA | ARIZONA_FLL1_FREERUN);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to start FLL in freerunning mode: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,\r\nARIZONA_FLL1_CLOCK_OK_STS,\r\nARIZONA_FLL1_CLOCK_OK_STS);\r\nif (ret) {\r\nret = -ETIMEDOUT;\r\ngoto err_fll;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, 0x0144);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to start SYSCLK: %d\n", ret);\r\ngoto err_fll;\r\n}\r\nreturn 0;\r\nerr_fll:\r\nerr = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, state->fll);\r\nif (err)\r\ndev_err(arizona->dev,\r\n"Failed to re-apply old FLL settings: %d\n", err);\r\nreturn ret;\r\n}\r\nstatic int arizona_disable_freerun_sysclk(struct arizona *arizona,\r\nstruct arizona_sysclk_state *state)\r\n{\r\nint ret;\r\nret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1,\r\nstate->sysclk);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to re-apply old SYSCLK settings: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, state->fll);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to re-apply old FLL settings: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm5102_apply_hardware_patch(struct arizona *arizona)\r\n{\r\nstruct arizona_sysclk_state state;\r\nint err, ret;\r\nret = arizona_enable_freerun_sysclk(arizona, &state);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,\r\nARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to start write sequencer: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,\r\nARIZONA_WSEQ_BUSY, 0);\r\nif (ret) {\r\nregmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,\r\nARIZONA_WSEQ_ABORT);\r\nret = -ETIMEDOUT;\r\n}\r\nerr:\r\nerr = arizona_disable_freerun_sysclk(arizona, &state);\r\nreturn ret ?: err;\r\n}\r\nstatic int wm5110_apply_sleep_patch(struct arizona *arizona)\r\n{\r\nstruct arizona_sysclk_state state;\r\nint err, ret;\r\nret = arizona_enable_freerun_sysclk(arizona, &state);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_multi_reg_write_bypassed(arizona->regmap,\r\nwm5110_sleep_patch,\r\nARRAY_SIZE(wm5110_sleep_patch));\r\nerr = arizona_disable_freerun_sysclk(arizona, &state);\r\nreturn ret ?: err;\r\n}\r\nstatic int wm5102_clear_write_sequencer(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_3,\r\n0x0);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to clear write sequencer state: %d\n", ret);\r\nreturn ret;\r\n}\r\narizona_enable_reset(arizona);\r\nregulator_disable(arizona->dcvdd);\r\nmsleep(20);\r\nret = regulator_enable(arizona->dcvdd);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to re-enable DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\narizona_disable_reset(arizona);\r\nreturn 0;\r\n}\r\nstatic int arizona_isolate_dcvdd(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ISOLATION_CONTROL,\r\nARIZONA_ISOLATE_DCVDD1,\r\nARIZONA_ISOLATE_DCVDD1);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Failed to isolate DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int arizona_connect_dcvdd(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ISOLATION_CONTROL,\r\nARIZONA_ISOLATE_DCVDD1, 0);\r\nif (ret != 0)\r\ndev_err(arizona->dev, "Failed to connect DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int arizona_is_jack_det_active(struct arizona *arizona)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_JACK_DETECT_ANALOGUE, &val);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to check jack det status: %d\n", ret);\r\nreturn ret;\r\n} else if (val & ARIZONA_JD1_ENA) {\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int arizona_runtime_resume(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(arizona->dev, "Leaving AoD mode\n");\r\nif (arizona->has_fully_powered_off) {\r\ndev_dbg(arizona->dev, "Re-enabling core supplies\n");\r\nret = regulator_bulk_enable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nret = regulator_enable(arizona->dcvdd);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to enable DCVDD: %d\n", ret);\r\nif (arizona->has_fully_powered_off)\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nreturn ret;\r\n}\r\nif (arizona->has_fully_powered_off) {\r\narizona_disable_reset(arizona);\r\nenable_irq(arizona->irq);\r\narizona->has_fully_powered_off = false;\r\n}\r\nregcache_cache_only(arizona->regmap, false);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nif (arizona->external_dcvdd) {\r\nret = arizona_connect_dcvdd(arizona);\r\nif (ret != 0)\r\ngoto err;\r\n}\r\nret = wm5102_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to apply patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = wm5102_apply_hardware_patch(arizona);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to apply hardware patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nbreak;\r\ncase WM5110:\r\ncase WM8280:\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret)\r\ngoto err;\r\nif (arizona->external_dcvdd) {\r\nret = arizona_connect_dcvdd(arizona);\r\nif (ret != 0)\r\ngoto err;\r\n} else {\r\nret = regulator_set_voltage(arizona->dcvdd,\r\n1200000, 1200000);\r\nif (ret < 0) {\r\ndev_err(arizona->dev,\r\n"Failed to set resume voltage: %d\n",\r\nret);\r\ngoto err;\r\n}\r\n}\r\nret = wm5110_apply_sleep_patch(arizona);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to re-apply sleep patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nbreak;\r\ncase WM1831:\r\ncase CS47L24:\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret != 0)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret != 0)\r\ngoto err;\r\nif (arizona->external_dcvdd) {\r\nret = arizona_connect_dcvdd(arizona);\r\nif (ret != 0)\r\ngoto err;\r\n}\r\nbreak;\r\n}\r\nret = regcache_sync(arizona->regmap);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to restore register cache\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nregcache_cache_only(arizona->regmap, true);\r\nregulator_disable(arizona->dcvdd);\r\nreturn ret;\r\n}\r\nstatic int arizona_runtime_suspend(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\nint jd_active = 0;\r\nint ret;\r\ndev_dbg(arizona->dev, "Entering AoD mode\n");\r\nswitch (arizona->type) {\r\ncase WM5110:\r\ncase WM8280:\r\njd_active = arizona_is_jack_det_active(arizona);\r\nif (jd_active < 0)\r\nreturn jd_active;\r\nif (arizona->external_dcvdd) {\r\nret = arizona_isolate_dcvdd(arizona);\r\nif (ret != 0)\r\nreturn ret;\r\n} else {\r\nret = regulator_set_voltage(arizona->dcvdd,\r\n1175000, 1175000);\r\nif (ret < 0) {\r\ndev_err(arizona->dev,\r\n"Failed to set suspend voltage: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase WM5102:\r\njd_active = arizona_is_jack_det_active(arizona);\r\nif (jd_active < 0)\r\nreturn jd_active;\r\nif (arizona->external_dcvdd) {\r\nret = arizona_isolate_dcvdd(arizona);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nif (!jd_active) {\r\nret = regmap_write(arizona->regmap,\r\nARIZONA_WRITE_SEQUENCER_CTRL_3, 0x0);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to clear write sequencer: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase WM1831:\r\ncase CS47L24:\r\nbreak;\r\ndefault:\r\njd_active = arizona_is_jack_det_active(arizona);\r\nif (jd_active < 0)\r\nreturn jd_active;\r\nif (arizona->external_dcvdd) {\r\nret = arizona_isolate_dcvdd(arizona);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nregcache_cache_only(arizona->regmap, true);\r\nregcache_mark_dirty(arizona->regmap);\r\nregulator_disable(arizona->dcvdd);\r\nif (!jd_active) {\r\ndev_dbg(arizona->dev, "Fully powering off\n");\r\narizona->has_fully_powered_off = true;\r\ndisable_irq_nosync(arizona->irq);\r\narizona_enable_reset(arizona);\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\n}\r\nreturn 0;\r\n}\r\nstatic int arizona_suspend(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Suspend, disabling IRQ\n");\r\ndisable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_suspend_noirq(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Late suspend, reenabling IRQ\n");\r\nenable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_resume_noirq(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Early resume, disabling IRQ\n");\r\ndisable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_resume(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Resume, reenabling IRQ\n");\r\nenable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nunsigned long arizona_of_get_type(struct device *dev)\r\n{\r\nconst struct of_device_id *id = of_match_device(arizona_of_match, dev);\r\nif (id)\r\nreturn (unsigned long)id->data;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int arizona_of_get_core_pdata(struct arizona *arizona)\r\n{\r\nstruct arizona_pdata *pdata = &arizona->pdata;\r\nstruct property *prop;\r\nconst __be32 *cur;\r\nu32 val;\r\nu32 pdm_val[ARIZONA_MAX_PDM_SPK];\r\nint ret, i;\r\nint count = 0;\r\npdata->reset = of_get_named_gpio(arizona->dev->of_node, "wlf,reset", 0);\r\nif (pdata->reset == -EPROBE_DEFER) {\r\nreturn pdata->reset;\r\n} else if (pdata->reset < 0) {\r\ndev_err(arizona->dev, "Reset GPIO missing/malformed: %d\n",\r\npdata->reset);\r\npdata->reset = 0;\r\n}\r\nret = of_property_read_u32_array(arizona->dev->of_node,\r\n"wlf,gpio-defaults",\r\npdata->gpio_defaults,\r\nARRAY_SIZE(pdata->gpio_defaults));\r\nif (ret >= 0) {\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {\r\nif (pdata->gpio_defaults[i] > 0xffff)\r\npdata->gpio_defaults[i] = 0;\r\nelse if (pdata->gpio_defaults[i] == 0)\r\npdata->gpio_defaults[i] = 0x10000;\r\n}\r\n} else {\r\ndev_err(arizona->dev, "Failed to parse GPIO defaults: %d\n",\r\nret);\r\n}\r\nof_property_for_each_u32(arizona->dev->of_node, "wlf,inmode", prop,\r\ncur, val) {\r\nif (count == ARRAY_SIZE(pdata->inmode))\r\nbreak;\r\npdata->inmode[count] = val;\r\ncount++;\r\n}\r\ncount = 0;\r\nof_property_for_each_u32(arizona->dev->of_node, "wlf,dmic-ref", prop,\r\ncur, val) {\r\nif (count == ARRAY_SIZE(pdata->dmic_ref))\r\nbreak;\r\npdata->dmic_ref[count] = val;\r\ncount++;\r\n}\r\ncount = 0;\r\nof_property_for_each_u32(arizona->dev->of_node, "wlf,out-mono", prop,\r\ncur, val) {\r\nif (count == ARRAY_SIZE(pdata->out_mono))\r\nbreak;\r\npdata->out_mono[count] = !!val;\r\ncount++;\r\n}\r\ncount = 0;\r\nof_property_for_each_u32(arizona->dev->of_node,\r\n"wlf,max-channels-clocked",\r\nprop, cur, val) {\r\nif (count == ARRAY_SIZE(pdata->max_channels_clocked))\r\nbreak;\r\npdata->max_channels_clocked[count] = val;\r\ncount++;\r\n}\r\nret = of_property_read_u32_array(arizona->dev->of_node,\r\n"wlf,spk-fmt",\r\npdm_val,\r\nARRAY_SIZE(pdm_val));\r\nif (ret >= 0)\r\nfor (count = 0; count < ARRAY_SIZE(pdata->spk_fmt); ++count)\r\npdata->spk_fmt[count] = pdm_val[count];\r\nret = of_property_read_u32_array(arizona->dev->of_node,\r\n"wlf,spk-mute",\r\npdm_val,\r\nARRAY_SIZE(pdm_val));\r\nif (ret >= 0)\r\nfor (count = 0; count < ARRAY_SIZE(pdata->spk_mute); ++count)\r\npdata->spk_mute[count] = pdm_val[count];\r\nreturn 0;\r\n}\r\nstatic inline int arizona_of_get_core_pdata(struct arizona *arizona)\r\n{\r\nreturn 0;\r\n}\r\nint arizona_dev_init(struct arizona *arizona)\r\n{\r\nconst char * const mclk_name[] = { "mclk1", "mclk2" };\r\nstruct device *dev = arizona->dev;\r\nconst char *type_name = NULL;\r\nunsigned int reg, val, mask;\r\nint (*apply_patch)(struct arizona *) = NULL;\r\nconst struct mfd_cell *subdevs = NULL;\r\nint n_subdevs, ret, i;\r\ndev_set_drvdata(arizona->dev, arizona);\r\nmutex_init(&arizona->clk_lock);\r\nif (dev_get_platdata(arizona->dev)) {\r\nmemcpy(&arizona->pdata, dev_get_platdata(arizona->dev),\r\nsizeof(arizona->pdata));\r\n} else {\r\nret = arizona_of_get_core_pdata(arizona);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nBUILD_BUG_ON(ARRAY_SIZE(arizona->mclk) != ARRAY_SIZE(mclk_name));\r\nfor (i = 0; i < ARRAY_SIZE(arizona->mclk); i++) {\r\narizona->mclk[i] = devm_clk_get(arizona->dev, mclk_name[i]);\r\nif (IS_ERR(arizona->mclk[i])) {\r\ndev_info(arizona->dev, "Failed to get %s: %ld\n",\r\nmclk_name[i], PTR_ERR(arizona->mclk[i]));\r\narizona->mclk[i] = NULL;\r\n}\r\n}\r\nregcache_cache_only(arizona->regmap, true);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\ncase WM5110:\r\ncase WM8280:\r\ncase WM8997:\r\ncase WM8998:\r\ncase WM1814:\r\ncase WM1831:\r\ncase CS47L24:\r\nfor (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)\r\narizona->core_supplies[i].supply\r\n= wm5102_core_supplies[i];\r\narizona->num_core_supplies = ARRAY_SIZE(wm5102_core_supplies);\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device type %d\n",\r\narizona->type);\r\nreturn -ENODEV;\r\n}\r\narizona->external_dcvdd = true;\r\nswitch (arizona->type) {\r\ncase WM1831:\r\ncase CS47L24:\r\nbreak;\r\ndefault:\r\nret = mfd_add_devices(arizona->dev, -1, early_devs,\r\nARRAY_SIZE(early_devs), NULL, 0, NULL);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to add early children: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nret = devm_regulator_bulk_get(dev, arizona->num_core_supplies,\r\narizona->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request core supplies: %d\n",\r\nret);\r\ngoto err_early;\r\n}\r\narizona->dcvdd = regulator_get(arizona->dev, "DCVDD");\r\nif (IS_ERR(arizona->dcvdd)) {\r\nret = PTR_ERR(arizona->dcvdd);\r\ndev_err(dev, "Failed to request DCVDD: %d\n", ret);\r\ngoto err_early;\r\n}\r\nif (arizona->pdata.reset) {\r\nret = devm_gpio_request_one(arizona->dev, arizona->pdata.reset,\r\nGPIOF_DIR_OUT | GPIOF_INIT_LOW,\r\n"arizona /RESET");\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request /RESET: %d\n", ret);\r\ngoto err_dcvdd;\r\n}\r\n}\r\nret = regulator_bulk_enable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable core supplies: %d\n",\r\nret);\r\ngoto err_dcvdd;\r\n}\r\nret = regulator_enable(arizona->dcvdd);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable DCVDD: %d\n", ret);\r\ngoto err_enable;\r\n}\r\narizona_disable_reset(arizona);\r\nregcache_cache_only(arizona->regmap, false);\r\nret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nswitch (reg) {\r\ncase 0x5102:\r\ncase 0x5110:\r\ncase 0x6349:\r\ncase 0x6363:\r\ncase 0x8997:\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device ID: %x\n", reg);\r\nret = -ENODEV;\r\ngoto err_reset;\r\n}\r\nif (!arizona->pdata.reset) {\r\nret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nusleep_range(1000, 5000);\r\n}\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nret = regmap_read(arizona->regmap,\r\nARIZONA_WRITE_SEQUENCER_CTRL_3, &val);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to check write sequencer state: %d\n",\r\nret);\r\n} else if (val & 0x01) {\r\nret = wm5102_clear_write_sequencer(arizona);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret) {\r\ndev_err(arizona->dev, "Device failed initial boot: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,\r\n&arizona->rev);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read revision register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\narizona->rev &= ARIZONA_DEVICE_REVISION_MASK;\r\nswitch (reg) {\r\ncase 0x5102:\r\nif (IS_ENABLED(CONFIG_MFD_WM5102)) {\r\ntype_name = "WM5102";\r\nif (arizona->type != WM5102) {\r\ndev_warn(arizona->dev,\r\n"WM5102 registered as %d\n",\r\narizona->type);\r\narizona->type = WM5102;\r\n}\r\napply_patch = wm5102_patch;\r\narizona->rev &= 0x7;\r\nsubdevs = wm5102_devs;\r\nn_subdevs = ARRAY_SIZE(wm5102_devs);\r\n}\r\nbreak;\r\ncase 0x5110:\r\nif (IS_ENABLED(CONFIG_MFD_WM5110)) {\r\nswitch (arizona->type) {\r\ncase WM5110:\r\ntype_name = "WM5110";\r\nbreak;\r\ncase WM8280:\r\ntype_name = "WM8280";\r\nbreak;\r\ndefault:\r\ntype_name = "WM5110";\r\ndev_warn(arizona->dev,\r\n"WM5110 registered as %d\n",\r\narizona->type);\r\narizona->type = WM5110;\r\nbreak;\r\n}\r\napply_patch = wm5110_patch;\r\nsubdevs = wm5110_devs;\r\nn_subdevs = ARRAY_SIZE(wm5110_devs);\r\n}\r\nbreak;\r\ncase 0x6363:\r\nif (IS_ENABLED(CONFIG_MFD_CS47L24)) {\r\nswitch (arizona->type) {\r\ncase CS47L24:\r\ntype_name = "CS47L24";\r\nbreak;\r\ncase WM1831:\r\ntype_name = "WM1831";\r\nbreak;\r\ndefault:\r\ndev_warn(arizona->dev,\r\n"CS47L24 registered as %d\n",\r\narizona->type);\r\narizona->type = CS47L24;\r\nbreak;\r\n}\r\napply_patch = cs47l24_patch;\r\nsubdevs = cs47l24_devs;\r\nn_subdevs = ARRAY_SIZE(cs47l24_devs);\r\n}\r\nbreak;\r\ncase 0x8997:\r\nif (IS_ENABLED(CONFIG_MFD_WM8997)) {\r\ntype_name = "WM8997";\r\nif (arizona->type != WM8997) {\r\ndev_warn(arizona->dev,\r\n"WM8997 registered as %d\n",\r\narizona->type);\r\narizona->type = WM8997;\r\n}\r\napply_patch = wm8997_patch;\r\nsubdevs = wm8997_devs;\r\nn_subdevs = ARRAY_SIZE(wm8997_devs);\r\n}\r\nbreak;\r\ncase 0x6349:\r\nif (IS_ENABLED(CONFIG_MFD_WM8998)) {\r\nswitch (arizona->type) {\r\ncase WM8998:\r\ntype_name = "WM8998";\r\nbreak;\r\ncase WM1814:\r\ntype_name = "WM1814";\r\nbreak;\r\ndefault:\r\ntype_name = "WM8998";\r\ndev_warn(arizona->dev,\r\n"WM8998 registered as %d\n",\r\narizona->type);\r\narizona->type = WM8998;\r\n}\r\napply_patch = wm8998_patch;\r\nsubdevs = wm8998_devs;\r\nn_subdevs = ARRAY_SIZE(wm8998_devs);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device ID %x\n", reg);\r\nret = -ENODEV;\r\ngoto err_reset;\r\n}\r\nif (!subdevs) {\r\ndev_err(arizona->dev,\r\n"No kernel support for device ID %x\n", reg);\r\nret = -ENODEV;\r\ngoto err_reset;\r\n}\r\ndev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');\r\nif (apply_patch) {\r\nret = apply_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to apply patch: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nret = wm5102_apply_hardware_patch(arizona);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to apply hardware patch: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nbreak;\r\ncase WM5110:\r\ncase WM8280:\r\nret = wm5110_apply_sleep_patch(arizona);\r\nif (ret) {\r\ndev_err(arizona->dev,\r\n"Failed to apply sleep patch: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {\r\nif (!arizona->pdata.gpio_defaults[i])\r\ncontinue;\r\nregmap_write(arizona->regmap, ARIZONA_GPIO1_CTRL + i,\r\narizona->pdata.gpio_defaults[i]);\r\n}\r\nif (!arizona->pdata.clk32k_src)\r\narizona->pdata.clk32k_src = ARIZONA_32KZ_MCLK2;\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\ncase ARIZONA_32KZ_MCLK2:\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_SRC_MASK,\r\narizona->pdata.clk32k_src - 1);\r\narizona_clk32k_enable(arizona);\r\nbreak;\r\ncase ARIZONA_32KZ_NONE:\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_SRC_MASK, 2);\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Invalid 32kHz clock source: %d\n",\r\narizona->pdata.clk32k_src);\r\nret = -EINVAL;\r\ngoto err_reset;\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_MICBIAS; i++) {\r\nif (!arizona->pdata.micbias[i].mV &&\r\n!arizona->pdata.micbias[i].bypass)\r\ncontinue;\r\nif (!arizona->pdata.micbias[i].mV)\r\narizona->pdata.micbias[i].mV = 2800;\r\nval = (arizona->pdata.micbias[i].mV - 1500) / 100;\r\nval <<= ARIZONA_MICB1_LVL_SHIFT;\r\nif (arizona->pdata.micbias[i].ext_cap)\r\nval |= ARIZONA_MICB1_EXT_CAP;\r\nif (arizona->pdata.micbias[i].discharge)\r\nval |= ARIZONA_MICB1_DISCH;\r\nif (arizona->pdata.micbias[i].soft_start)\r\nval |= ARIZONA_MICB1_RATE;\r\nif (arizona->pdata.micbias[i].bypass)\r\nval |= ARIZONA_MICB1_BYPASS;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_MIC_BIAS_CTRL_1 + i,\r\nARIZONA_MICB1_LVL_MASK |\r\nARIZONA_MICB1_EXT_CAP |\r\nARIZONA_MICB1_DISCH |\r\nARIZONA_MICB1_BYPASS |\r\nARIZONA_MICB1_RATE, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_INPUT; i++) {\r\nval = arizona->pdata.dmic_ref[i]\r\n<< ARIZONA_IN1_DMIC_SUP_SHIFT;\r\nif (arizona->pdata.inmode[i] & ARIZONA_INMODE_DMIC)\r\nval |= 1 << ARIZONA_IN1_MODE_SHIFT;\r\nswitch (arizona->type) {\r\ncase WM8998:\r\ncase WM1814:\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ADC_DIGITAL_VOLUME_1L + (i * 8),\r\nARIZONA_IN1L_SRC_SE_MASK,\r\n(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)\r\n<< ARIZONA_IN1L_SRC_SE_SHIFT);\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_ADC_DIGITAL_VOLUME_1R + (i * 8),\r\nARIZONA_IN1R_SRC_SE_MASK,\r\n(arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)\r\n<< ARIZONA_IN1R_SRC_SE_SHIFT);\r\nmask = ARIZONA_IN1_DMIC_SUP_MASK |\r\nARIZONA_IN1_MODE_MASK;\r\nbreak;\r\ndefault:\r\nif (arizona->pdata.inmode[i] & ARIZONA_INMODE_SE)\r\nval |= 1 << ARIZONA_IN1_SINGLE_ENDED_SHIFT;\r\nmask = ARIZONA_IN1_DMIC_SUP_MASK |\r\nARIZONA_IN1_MODE_MASK |\r\nARIZONA_IN1_SINGLE_ENDED_MASK;\r\nbreak;\r\n}\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_IN1L_CONTROL + (i * 8),\r\nmask, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {\r\nif (arizona->pdata.out_mono[i])\r\nval = ARIZONA_OUT1_MONO;\r\nelse\r\nval = 0;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_PATH_CONFIG_1L + (i * 8),\r\nARIZONA_OUT1_MONO, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_PDM_SPK; i++) {\r\nif (arizona->pdata.spk_mute[i])\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_PDM_SPK1_CTRL_1 + (i * 2),\r\nARIZONA_SPK1_MUTE_ENDIAN_MASK |\r\nARIZONA_SPK1_MUTE_SEQ1_MASK,\r\narizona->pdata.spk_mute[i]);\r\nif (arizona->pdata.spk_fmt[i])\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_PDM_SPK1_CTRL_2 + (i * 2),\r\nARIZONA_SPK1_FMT_MASK,\r\narizona->pdata.spk_fmt[i]);\r\n}\r\npm_runtime_set_active(arizona->dev);\r\npm_runtime_enable(arizona->dev);\r\nret = arizona_irq_init(arizona);\r\nif (ret != 0)\r\ngoto err_pm;\r\npm_runtime_set_autosuspend_delay(arizona->dev, 100);\r\npm_runtime_use_autosuspend(arizona->dev);\r\narizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, "CLKGEN error",\r\narizona_clkgen_err, arizona);\r\narizona_request_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, "Overclocked",\r\narizona_overclocked, arizona);\r\narizona_request_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, "Underclocked",\r\narizona_underclocked, arizona);\r\nret = mfd_add_devices(arizona->dev, PLATFORM_DEVID_NONE,\r\nsubdevs, n_subdevs, NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(arizona->dev, "Failed to add subdevices: %d\n", ret);\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\narizona_irq_exit(arizona);\r\nerr_pm:\r\npm_runtime_disable(arizona->dev);\r\nerr_reset:\r\narizona_enable_reset(arizona);\r\nregulator_disable(arizona->dcvdd);\r\nerr_enable:\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nerr_dcvdd:\r\nregulator_put(arizona->dcvdd);\r\nerr_early:\r\nmfd_remove_devices(dev);\r\nreturn ret;\r\n}\r\nint arizona_dev_exit(struct arizona *arizona)\r\n{\r\ndisable_irq(arizona->irq);\r\npm_runtime_disable(arizona->dev);\r\nregulator_disable(arizona->dcvdd);\r\nregulator_put(arizona->dcvdd);\r\nmfd_remove_devices(arizona->dev);\r\narizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);\r\narizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);\r\narizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);\r\narizona_irq_exit(arizona);\r\narizona_enable_reset(arizona);\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nreturn 0;\r\n}
