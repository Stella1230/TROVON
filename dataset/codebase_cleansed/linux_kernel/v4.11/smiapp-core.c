static int smiapp_read_frame_fmt(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nu32 fmt_model_type, fmt_model_subtype, ncol_desc, nrow_desc;\r\nunsigned int i;\r\nint pixel_count = 0;\r\nint line_count = 0;\r\nint rval;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_FRAME_FORMAT_MODEL_TYPE,\r\n&fmt_model_type);\r\nif (rval)\r\nreturn rval;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_FRAME_FORMAT_MODEL_SUBTYPE,\r\n&fmt_model_subtype);\r\nif (rval)\r\nreturn rval;\r\nncol_desc = (fmt_model_subtype\r\n& SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NCOLS_MASK)\r\n>> SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NCOLS_SHIFT;\r\nnrow_desc = fmt_model_subtype\r\n& SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NROWS_MASK;\r\ndev_dbg(&client->dev, "format_model_type %s\n",\r\nfmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_2BYTE\r\n? "2 byte" :\r\nfmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_4BYTE\r\n? "4 byte" : "is simply bad");\r\nfor (i = 0; i < ncol_desc + nrow_desc; i++) {\r\nu32 desc;\r\nu32 pixelcode;\r\nu32 pixels;\r\nchar *which;\r\nchar *what;\r\nu32 reg;\r\nif (fmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_2BYTE) {\r\nreg = SMIAPP_REG_U16_FRAME_FORMAT_DESCRIPTOR_2(i);\r\nrval = smiapp_read(sensor, reg, &desc);\r\nif (rval)\r\nreturn rval;\r\npixelcode =\r\n(desc\r\n& SMIAPP_FRAME_FORMAT_DESC_2_PIXELCODE_MASK)\r\n>> SMIAPP_FRAME_FORMAT_DESC_2_PIXELCODE_SHIFT;\r\npixels = desc & SMIAPP_FRAME_FORMAT_DESC_2_PIXELS_MASK;\r\n} else if (fmt_model_type\r\n== SMIAPP_FRAME_FORMAT_MODEL_TYPE_4BYTE) {\r\nreg = SMIAPP_REG_U32_FRAME_FORMAT_DESCRIPTOR_4(i);\r\nrval = smiapp_read(sensor, reg, &desc);\r\nif (rval)\r\nreturn rval;\r\npixelcode =\r\n(desc\r\n& SMIAPP_FRAME_FORMAT_DESC_4_PIXELCODE_MASK)\r\n>> SMIAPP_FRAME_FORMAT_DESC_4_PIXELCODE_SHIFT;\r\npixels = desc & SMIAPP_FRAME_FORMAT_DESC_4_PIXELS_MASK;\r\n} else {\r\ndev_dbg(&client->dev,\r\n"invalid frame format model type %d\n",\r\nfmt_model_type);\r\nreturn -EINVAL;\r\n}\r\nif (i < ncol_desc)\r\nwhich = "columns";\r\nelse\r\nwhich = "rows";\r\nswitch (pixelcode) {\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_EMBEDDED:\r\nwhat = "embedded";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_DUMMY:\r\nwhat = "dummy";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_BLACK:\r\nwhat = "black";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_DARK:\r\nwhat = "dark";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_VISIBLE:\r\nwhat = "visible";\r\nbreak;\r\ndefault:\r\nwhat = "invalid";\r\nbreak;\r\n}\r\ndev_dbg(&client->dev,\r\n"0x%8.8x %s pixels: %d %s (pixelcode %u)\n", reg,\r\nwhat, pixels, which, pixelcode);\r\nif (i < ncol_desc) {\r\nif (pixelcode ==\r\nSMIAPP_FRAME_FORMAT_DESC_PIXELCODE_VISIBLE)\r\nsensor->visible_pixel_start = pixel_count;\r\npixel_count += pixels;\r\ncontinue;\r\n}\r\nswitch (pixelcode) {\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_EMBEDDED:\r\nif (sensor->embedded_end)\r\nbreak;\r\nsensor->embedded_start = line_count;\r\nsensor->embedded_end = line_count + pixels;\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_VISIBLE:\r\nsensor->image_start = line_count;\r\nbreak;\r\n}\r\nline_count += pixels;\r\n}\r\nif (sensor->embedded_end > sensor->image_start) {\r\ndev_dbg(&client->dev,\r\n"adjusting image start line to %u (was %u)\n",\r\nsensor->embedded_end, sensor->image_start);\r\nsensor->image_start = sensor->embedded_end;\r\n}\r\ndev_dbg(&client->dev, "embedded data from lines %d to %d\n",\r\nsensor->embedded_start, sensor->embedded_end);\r\ndev_dbg(&client->dev, "image data starts at line %d\n",\r\nsensor->image_start);\r\nreturn 0;\r\n}\r\nstatic int smiapp_pll_configure(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nint rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_VT_PIX_CLK_DIV, pll->vt.pix_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_VT_SYS_CLK_DIV, pll->vt.sys_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_PRE_PLL_CLK_DIV, pll->pre_pll_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_PLL_MULTIPLIER, pll->pll_multiplier);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U32_REQUESTED_LINK_BIT_RATE_MBPS,\r\nDIV_ROUND_UP(pll->op.sys_clk_freq_hz, 1000000 / 256 / 256));\r\nif (rval < 0 || sensor->minfo.smiapp_profile == SMIAPP_PROFILE_0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_OP_PIX_CLK_DIV, pll->op.pix_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_OP_SYS_CLK_DIV, pll->op.sys_clk_div);\r\n}\r\nstatic int smiapp_pll_try(struct smiapp_sensor *sensor,\r\nstruct smiapp_pll *pll)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct smiapp_pll_limits lim = {\r\n.min_pre_pll_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_PRE_PLL_CLK_DIV],\r\n.max_pre_pll_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_PRE_PLL_CLK_DIV],\r\n.min_pll_ip_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_PLL_IP_FREQ_HZ],\r\n.max_pll_ip_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_PLL_IP_FREQ_HZ],\r\n.min_pll_multiplier = sensor->limits[SMIAPP_LIMIT_MIN_PLL_MULTIPLIER],\r\n.max_pll_multiplier = sensor->limits[SMIAPP_LIMIT_MAX_PLL_MULTIPLIER],\r\n.min_pll_op_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_PLL_OP_FREQ_HZ],\r\n.max_pll_op_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_PLL_OP_FREQ_HZ],\r\n.op.min_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_DIV],\r\n.op.max_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_DIV],\r\n.op.min_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_DIV],\r\n.op.max_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_DIV],\r\n.op.min_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_FREQ_HZ],\r\n.op.max_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_FREQ_HZ],\r\n.op.min_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_FREQ_HZ],\r\n.op.max_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_FREQ_HZ],\r\n.vt.min_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_VT_SYS_CLK_DIV],\r\n.vt.max_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_VT_SYS_CLK_DIV],\r\n.vt.min_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_VT_PIX_CLK_DIV],\r\n.vt.max_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_VT_PIX_CLK_DIV],\r\n.vt.min_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_VT_SYS_CLK_FREQ_HZ],\r\n.vt.max_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_VT_SYS_CLK_FREQ_HZ],\r\n.vt.min_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_VT_PIX_CLK_FREQ_HZ],\r\n.vt.max_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_VT_PIX_CLK_FREQ_HZ],\r\n.min_line_length_pck_bin = sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN],\r\n.min_line_length_pck = sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK],\r\n};\r\nreturn smiapp_pll_calculate(&client->dev, &lim, pll);\r\n}\r\nstatic int smiapp_pll_update(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nint rval;\r\npll->binning_horizontal = sensor->binning_horizontal;\r\npll->binning_vertical = sensor->binning_vertical;\r\npll->link_freq =\r\nsensor->link_freq->qmenu_int[sensor->link_freq->val];\r\npll->scale_m = sensor->scale_m;\r\npll->bits_per_pixel = sensor->csi_format->compressed;\r\nrval = smiapp_pll_try(sensor, pll);\r\nif (rval < 0)\r\nreturn rval;\r\n__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate_parray,\r\npll->pixel_rate_pixel_array);\r\n__v4l2_ctrl_s_ctrl_int64(sensor->pixel_rate_csi, pll->pixel_rate_csi);\r\nreturn 0;\r\n}\r\nstatic void __smiapp_update_exposure_limits(struct smiapp_sensor *sensor)\r\n{\r\nstruct v4l2_ctrl *ctrl = sensor->exposure;\r\nint max;\r\nmax = sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ sensor->vblank->val\r\n- sensor->limits[SMIAPP_LIMIT_COARSE_INTEGRATION_TIME_MAX_MARGIN];\r\n__v4l2_ctrl_modify_range(ctrl, ctrl->minimum, max, ctrl->step, max);\r\n}\r\nstatic u32 smiapp_pixel_order(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint flip = 0;\r\nif (sensor->hflip) {\r\nif (sensor->hflip->val)\r\nflip |= SMIAPP_IMAGE_ORIENTATION_HFLIP;\r\nif (sensor->vflip->val)\r\nflip |= SMIAPP_IMAGE_ORIENTATION_VFLIP;\r\n}\r\nflip ^= sensor->hvflip_inv_mask;\r\ndev_dbg(&client->dev, "flip %d\n", flip);\r\nreturn sensor->default_pixel_order ^ flip;\r\n}\r\nstatic void smiapp_update_mbus_formats(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int csi_format_idx =\r\nto_csi_format_idx(sensor->csi_format) & ~3;\r\nunsigned int internal_csi_format_idx =\r\nto_csi_format_idx(sensor->internal_csi_format) & ~3;\r\nunsigned int pixel_order = smiapp_pixel_order(sensor);\r\nsensor->mbus_frame_fmts =\r\nsensor->default_mbus_frame_fmts << pixel_order;\r\nsensor->csi_format =\r\n&smiapp_csi_data_formats[csi_format_idx + pixel_order];\r\nsensor->internal_csi_format =\r\n&smiapp_csi_data_formats[internal_csi_format_idx\r\n+ pixel_order];\r\nBUG_ON(max(internal_csi_format_idx, csi_format_idx) + pixel_order\r\n>= ARRAY_SIZE(smiapp_csi_data_formats));\r\ndev_dbg(&client->dev, "new pixel order %s\n",\r\npixel_order_str[pixel_order]);\r\n}\r\nstatic int smiapp_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct smiapp_sensor *sensor =\r\ncontainer_of(ctrl->handler, struct smiapp_subdev, ctrl_handler)\r\n->sensor;\r\nu32 orient = 0;\r\nint exposure;\r\nint rval;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ANALOGUE_GAIN:\r\nreturn smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U16_ANALOGUE_GAIN_CODE_GLOBAL, ctrl->val);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U16_COARSE_INTEGRATION_TIME, ctrl->val);\r\ncase V4L2_CID_HFLIP:\r\ncase V4L2_CID_VFLIP:\r\nif (sensor->streaming)\r\nreturn -EBUSY;\r\nif (sensor->hflip->val)\r\norient |= SMIAPP_IMAGE_ORIENTATION_HFLIP;\r\nif (sensor->vflip->val)\r\norient |= SMIAPP_IMAGE_ORIENTATION_VFLIP;\r\norient ^= sensor->hvflip_inv_mask;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_IMAGE_ORIENTATION,\r\norient);\r\nif (rval < 0)\r\nreturn rval;\r\nsmiapp_update_mbus_formats(sensor);\r\nreturn 0;\r\ncase V4L2_CID_VBLANK:\r\nexposure = sensor->exposure->val;\r\n__smiapp_update_exposure_limits(sensor);\r\nif (exposure > sensor->exposure->maximum) {\r\nsensor->exposure->val = sensor->exposure->maximum;\r\nrval = smiapp_set_ctrl(sensor->exposure);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_FRAME_LENGTH_LINES,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ ctrl->val);\r\ncase V4L2_CID_HBLANK:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_LINE_LENGTH_PCK,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width\r\n+ ctrl->val);\r\ncase V4L2_CID_LINK_FREQ:\r\nif (sensor->streaming)\r\nreturn -EBUSY;\r\nreturn smiapp_pll_update(sensor);\r\ncase V4L2_CID_TEST_PATTERN: {\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++)\r\nv4l2_ctrl_activate(\r\nsensor->test_data[i],\r\nctrl->val ==\r\nV4L2_SMIAPP_TEST_PATTERN_MODE_SOLID_COLOUR);\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_TEST_PATTERN_MODE, ctrl->val);\r\n}\r\ncase V4L2_CID_TEST_PATTERN_RED:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_TEST_DATA_RED, ctrl->val);\r\ncase V4L2_CID_TEST_PATTERN_GREENR:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_TEST_DATA_GREENR, ctrl->val);\r\ncase V4L2_CID_TEST_PATTERN_BLUE:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_TEST_DATA_BLUE, ctrl->val);\r\ncase V4L2_CID_TEST_PATTERN_GREENB:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_TEST_DATA_GREENB, ctrl->val);\r\ncase V4L2_CID_PIXEL_RATE:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int smiapp_init_controls(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nrval = v4l2_ctrl_handler_init(&sensor->pixel_array->ctrl_handler, 12);\r\nif (rval)\r\nreturn rval;\r\nsensor->pixel_array->ctrl_handler.lock = &sensor->mutex;\r\nsensor->analog_gain = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_ANALOGUE_GAIN,\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MIN],\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MAX],\r\nmax(sensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_STEP], 1U),\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MIN]);\r\nsensor->exposure = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 0, 1, 0);\r\nsensor->hflip = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsensor->vflip = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nsensor->vblank = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_VBLANK, 0, 1, 1, 0);\r\nif (sensor->vblank)\r\nsensor->vblank->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nsensor->hblank = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_HBLANK, 0, 1, 1, 0);\r\nif (sensor->hblank)\r\nsensor->hblank->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nsensor->pixel_rate_parray = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\r\nv4l2_ctrl_new_std_menu_items(&sensor->pixel_array->ctrl_handler,\r\n&smiapp_ctrl_ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(smiapp_test_patterns) - 1,\r\n0, 0, smiapp_test_patterns);\r\nif (sensor->pixel_array->ctrl_handler.error) {\r\ndev_err(&client->dev,\r\n"pixel array controls initialization failed (%d)\n",\r\nsensor->pixel_array->ctrl_handler.error);\r\nreturn sensor->pixel_array->ctrl_handler.error;\r\n}\r\nsensor->pixel_array->sd.ctrl_handler =\r\n&sensor->pixel_array->ctrl_handler;\r\nv4l2_ctrl_cluster(2, &sensor->hflip);\r\nrval = v4l2_ctrl_handler_init(&sensor->src->ctrl_handler, 0);\r\nif (rval)\r\nreturn rval;\r\nsensor->src->ctrl_handler.lock = &sensor->mutex;\r\nsensor->pixel_rate_csi = v4l2_ctrl_new_std(\r\n&sensor->src->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 1, INT_MAX, 1, 1);\r\nif (sensor->src->ctrl_handler.error) {\r\ndev_err(&client->dev,\r\n"src controls initialization failed (%d)\n",\r\nsensor->src->ctrl_handler.error);\r\nreturn sensor->src->ctrl_handler.error;\r\n}\r\nsensor->src->sd.ctrl_handler = &sensor->src->ctrl_handler;\r\nreturn 0;\r\n}\r\nstatic int smiapp_init_late_controls(struct smiapp_sensor *sensor)\r\n{\r\nunsigned long *valid_link_freqs = &sensor->valid_link_freqs[\r\nsensor->csi_format->compressed - sensor->compressed_min_bpp];\r\nunsigned int max, i;\r\nfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++) {\r\nint max_value = (1 << sensor->csi_format->width) - 1;\r\nsensor->test_data[i] = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler,\r\n&smiapp_ctrl_ops, V4L2_CID_TEST_PATTERN_RED + i,\r\n0, max_value, 1, max_value);\r\n}\r\nfor (max = 0; sensor->hwcfg->op_sys_clock[max + 1]; max++);\r\nsensor->link_freq = v4l2_ctrl_new_int_menu(\r\n&sensor->src->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_LINK_FREQ, __fls(*valid_link_freqs),\r\n__ffs(*valid_link_freqs), sensor->hwcfg->op_sys_clock);\r\nreturn sensor->src->ctrl_handler.error;\r\n}\r\nstatic void smiapp_free_controls(struct smiapp_sensor *sensor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sensor->ssds_used; i++)\r\nv4l2_ctrl_handler_free(&sensor->ssds[i].ctrl_handler);\r\n}\r\nstatic int smiapp_get_limits(struct smiapp_sensor *sensor, int const *limit,\r\nunsigned int n)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int i;\r\nu32 val;\r\nint rval;\r\nfor (i = 0; i < n; i++) {\r\nrval = smiapp_read(\r\nsensor, smiapp_reg_limits[limit[i]].addr, &val);\r\nif (rval)\r\nreturn rval;\r\nsensor->limits[limit[i]] = val;\r\ndev_dbg(&client->dev, "0x%8.8x \"%s\" = %u, 0x%x\n",\r\nsmiapp_reg_limits[limit[i]].addr,\r\nsmiapp_reg_limits[limit[i]].what, val, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_all_limits(struct smiapp_sensor *sensor)\r\n{\r\nunsigned int i;\r\nint rval;\r\nfor (i = 0; i < SMIAPP_LIMIT_LAST; i++) {\r\nrval = smiapp_get_limits(sensor, &i, 1);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] == 0)\r\nsmiapp_replace_limit(sensor, SMIAPP_LIMIT_SCALER_N_MIN, 16);\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_limits_binning(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstatic u32 const limits[] = {\r\nSMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN,\r\nSMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES_BIN,\r\nSMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN,\r\nSMIAPP_LIMIT_MAX_LINE_LENGTH_PCK_BIN,\r\nSMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MIN_BIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MAX_MARGIN_BIN,\r\n};\r\nstatic u32 const limits_replace[] = {\r\nSMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES,\r\nSMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES,\r\nSMIAPP_LIMIT_MIN_LINE_LENGTH_PCK,\r\nSMIAPP_LIMIT_MAX_LINE_LENGTH_PCK,\r\nSMIAPP_LIMIT_MIN_LINE_BLANKING_PCK,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MAX_MARGIN,\r\n};\r\nunsigned int i;\r\nint rval;\r\nif (sensor->limits[SMIAPP_LIMIT_BINNING_CAPABILITY] ==\r\nSMIAPP_BINNING_CAPABILITY_NO) {\r\nfor (i = 0; i < ARRAY_SIZE(limits); i++)\r\nsensor->limits[limits[i]] =\r\nsensor->limits[limits_replace[i]];\r\nreturn 0;\r\n}\r\nrval = smiapp_get_limits(sensor, limits, ARRAY_SIZE(limits));\r\nif (rval < 0)\r\nreturn rval;\r\nif (sensor->limits[SMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN]\r\n&& sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN]\r\n&& sensor->limits[SMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN])\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(limits); i++) {\r\ndev_dbg(&client->dev,\r\n"replace limit 0x%8.8x \"%s\" = %d, 0x%x\n",\r\nsmiapp_reg_limits[limits[i]].addr,\r\nsmiapp_reg_limits[limits[i]].what,\r\nsensor->limits[limits_replace[i]],\r\nsensor->limits[limits_replace[i]]);\r\nsensor->limits[limits[i]] =\r\nsensor->limits[limits_replace[i]];\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_mbus_formats(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nu8 compressed_max_bpp = 0;\r\nunsigned int type, n;\r\nunsigned int i, pixel_order;\r\nint rval;\r\nrval = smiapp_read(\r\nsensor, SMIAPP_REG_U8_DATA_FORMAT_MODEL_TYPE, &type);\r\nif (rval)\r\nreturn rval;\r\ndev_dbg(&client->dev, "data_format_model_type %d\n", type);\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_PIXEL_ORDER,\r\n&pixel_order);\r\nif (rval)\r\nreturn rval;\r\nif (pixel_order >= ARRAY_SIZE(pixel_order_str)) {\r\ndev_dbg(&client->dev, "bad pixel order %d\n", pixel_order);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&client->dev, "pixel order %d (%s)\n", pixel_order,\r\npixel_order_str[pixel_order]);\r\nswitch (type) {\r\ncase SMIAPP_DATA_FORMAT_MODEL_TYPE_NORMAL:\r\nn = SMIAPP_DATA_FORMAT_MODEL_TYPE_NORMAL_N;\r\nbreak;\r\ncase SMIAPP_DATA_FORMAT_MODEL_TYPE_EXTENDED:\r\nn = SMIAPP_DATA_FORMAT_MODEL_TYPE_EXTENDED_N;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsensor->default_pixel_order = pixel_order;\r\nsensor->mbus_frame_fmts = 0;\r\nfor (i = 0; i < n; i++) {\r\nunsigned int fmt, j;\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U16_DATA_FORMAT_DESCRIPTOR(i), &fmt);\r\nif (rval)\r\nreturn rval;\r\ndev_dbg(&client->dev, "%u: bpp %u, compressed %u\n",\r\ni, fmt >> 8, (u8)fmt);\r\nfor (j = 0; j < ARRAY_SIZE(smiapp_csi_data_formats); j++) {\r\nconst struct smiapp_csi_data_format *f =\r\n&smiapp_csi_data_formats[j];\r\nif (f->pixel_order != SMIAPP_PIXEL_ORDER_GRBG)\r\ncontinue;\r\nif (f->width != fmt >> 8 || f->compressed != (u8)fmt)\r\ncontinue;\r\ndev_dbg(&client->dev, "jolly good! %d\n", j);\r\nsensor->default_mbus_frame_fmts |= 1 << j;\r\n}\r\n}\r\npll->binning_horizontal = 1;\r\npll->binning_vertical = 1;\r\npll->scale_m = sensor->scale_m;\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nsensor->compressed_min_bpp =\r\nmin(smiapp_csi_data_formats[i].compressed,\r\nsensor->compressed_min_bpp);\r\ncompressed_max_bpp =\r\nmax(smiapp_csi_data_formats[i].compressed,\r\ncompressed_max_bpp);\r\n}\r\nsensor->valid_link_freqs = devm_kcalloc(\r\n&client->dev,\r\ncompressed_max_bpp - sensor->compressed_min_bpp + 1,\r\nsizeof(*sensor->valid_link_freqs), GFP_KERNEL);\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nconst struct smiapp_csi_data_format *f =\r\n&smiapp_csi_data_formats[i];\r\nunsigned long *valid_link_freqs =\r\n&sensor->valid_link_freqs[\r\nf->compressed - sensor->compressed_min_bpp];\r\nunsigned int j;\r\nif (!(sensor->default_mbus_frame_fmts & 1 << i))\r\ncontinue;\r\npll->bits_per_pixel = f->compressed;\r\nfor (j = 0; sensor->hwcfg->op_sys_clock[j]; j++) {\r\npll->link_freq = sensor->hwcfg->op_sys_clock[j];\r\nrval = smiapp_pll_try(sensor, pll);\r\ndev_dbg(&client->dev, "link freq %u Hz, bpp %u %s\n",\r\npll->link_freq, pll->bits_per_pixel,\r\nrval ? "not ok" : "ok");\r\nif (rval)\r\ncontinue;\r\nset_bit(j, valid_link_freqs);\r\n}\r\nif (!*valid_link_freqs) {\r\ndev_info(&client->dev,\r\n"no valid link frequencies for %u bpp\n",\r\nf->compressed);\r\nsensor->default_mbus_frame_fmts &= ~BIT(i);\r\ncontinue;\r\n}\r\nif (!sensor->csi_format\r\n|| f->width > sensor->csi_format->width\r\n|| (f->width == sensor->csi_format->width\r\n&& f->compressed > sensor->csi_format->compressed)) {\r\nsensor->csi_format = f;\r\nsensor->internal_csi_format = f;\r\n}\r\n}\r\nif (!sensor->csi_format) {\r\ndev_err(&client->dev, "no supported mbus code found\n");\r\nreturn -EINVAL;\r\n}\r\nsmiapp_update_mbus_formats(sensor);\r\nreturn 0;\r\n}\r\nstatic void smiapp_update_blanking(struct smiapp_sensor *sensor)\r\n{\r\nstruct v4l2_ctrl *vblank = sensor->vblank;\r\nstruct v4l2_ctrl *hblank = sensor->hblank;\r\nint min, max;\r\nmin = max_t(int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_FRAME_BLANKING_LINES],\r\nsensor->limits[SMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height);\r\nmax = sensor->limits[SMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height;\r\n__v4l2_ctrl_modify_range(vblank, min, max, vblank->step, min);\r\nmin = max_t(int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width,\r\nsensor->limits[SMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN]);\r\nmax = sensor->limits[SMIAPP_LIMIT_MAX_LINE_LENGTH_PCK_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width;\r\n__v4l2_ctrl_modify_range(hblank, min, max, hblank->step, min);\r\n__smiapp_update_exposure_limits(sensor);\r\n}\r\nstatic int smiapp_update_mode(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int binning_mode;\r\nint rval;\r\nif (sensor->binning_horizontal == 1 &&\r\nsensor->binning_vertical == 1) {\r\nbinning_mode = 0;\r\n} else {\r\nu8 binning_type =\r\n(sensor->binning_horizontal << 4)\r\n| sensor->binning_vertical;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U8_BINNING_TYPE, binning_type);\r\nif (rval < 0)\r\nreturn rval;\r\nbinning_mode = 1;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_BINNING_MODE, binning_mode);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_get_limits_binning(sensor);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_pll_update(sensor);\r\nif (rval < 0)\r\nreturn rval;\r\nsmiapp_update_blanking(sensor);\r\ndev_dbg(&client->dev, "vblank\t\t%d\n", sensor->vblank->val);\r\ndev_dbg(&client->dev, "hblank\t\t%d\n", sensor->hblank->val);\r\ndev_dbg(&client->dev, "real timeperframe\t100/%d\n",\r\nsensor->pll.pixel_rate_pixel_array /\r\n((sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width\r\n+ sensor->hblank->val) *\r\n(sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ sensor->vblank->val) / 100));\r\nreturn 0;\r\n}\r\nstatic int smiapp_read_nvm(struct smiapp_sensor *sensor,\r\nunsigned char *nvm)\r\n{\r\nu32 i, s, p, np, v;\r\nint rval = 0, rval2;\r\nnp = sensor->nvm_size / SMIAPP_NVM_PAGE_SIZE;\r\nfor (p = 0; p < np; p++) {\r\nrval = smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_PAGE_SELECT, p);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_write(sensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_CTRL,\r\nSMIAPP_DATA_TRANSFER_IF_1_CTRL_EN |\r\nSMIAPP_DATA_TRANSFER_IF_1_CTRL_RD_EN);\r\nif (rval)\r\ngoto out;\r\nfor (i = 0; i < 1000; i++) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_STATUS, &s);\r\nif (rval)\r\ngoto out;\r\nif (s & SMIAPP_DATA_TRANSFER_IF_1_STATUS_RD_READY)\r\nbreak;\r\nif (--i == 0) {\r\nrval = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < SMIAPP_NVM_PAGE_SIZE; i++) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_DATA_0 + i,\r\n&v);\r\nif (rval)\r\ngoto out;\r\n*nvm++ = v;\r\n}\r\n}\r\nout:\r\nrval2 = smiapp_write(sensor, SMIAPP_REG_U8_DATA_TRANSFER_IF_1_CTRL, 0);\r\nif (rval < 0)\r\nreturn rval;\r\nelse\r\nreturn rval2;\r\n}\r\nstatic int smiapp_change_cci_addr(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nu32 val;\r\nclient->addr = sensor->hwcfg->i2c_addr_dfl;\r\nrval = smiapp_write(sensor,\r\nSMIAPP_REG_U8_CCI_ADDRESS_CONTROL,\r\nsensor->hwcfg->i2c_addr_alt << 1);\r\nif (rval)\r\nreturn rval;\r\nclient->addr = sensor->hwcfg->i2c_addr_alt;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_CCI_ADDRESS_CONTROL, &val);\r\nif (rval)\r\nreturn rval;\r\nif (val != sensor->hwcfg->i2c_addr_alt << 1)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int smiapp_setup_flash_strobe(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_flash_strobe_parms *strobe_setup;\r\nunsigned int ext_freq = sensor->hwcfg->ext_clk;\r\nu32 tmp;\r\nu32 strobe_adjustment;\r\nu32 strobe_width_high_rs;\r\nint rval;\r\nstrobe_setup = sensor->hwcfg->strobe_setup;\r\ntmp = div_u64(1000000ULL * ((1 << 16) - 1) * ((1 << 8) - 1) -\r\n1000000 + 1, ext_freq);\r\nstrobe_setup->strobe_width_high_us =\r\nclamp_t(u32, strobe_setup->strobe_width_high_us, 1, tmp);\r\ntmp = div_u64(((u64)strobe_setup->strobe_width_high_us * (u64)ext_freq +\r\n1000000 - 1), 1000000ULL);\r\nstrobe_adjustment = (tmp + (1 << 16) - 1 - 1) / ((1 << 16) - 1);\r\nstrobe_width_high_rs = (tmp + strobe_adjustment - 1) /\r\nstrobe_adjustment;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_MODE_RS,\r\nstrobe_setup->mode);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_STROBE_ADJUSTMENT,\r\nstrobe_adjustment);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_TFLASH_STROBE_WIDTH_HIGH_RS_CTRL,\r\nstrobe_width_high_rs);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_TFLASH_STROBE_DELAY_RS_CTRL,\r\nstrobe_setup->strobe_delay);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_FLASH_STROBE_START_POINT,\r\nstrobe_setup->stobe_start_point);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_TRIGGER_RS,\r\nstrobe_setup->trigger);\r\nout:\r\nsensor->hwcfg->strobe_setup->trigger = 0;\r\nreturn rval;\r\n}\r\nstatic int smiapp_power_on(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct smiapp_sensor *sensor =\r\ncontainer_of(ssd, struct smiapp_sensor, ssds[0]);\r\nunsigned int sleep;\r\nint rval;\r\nrval = regulator_enable(sensor->vana);\r\nif (rval) {\r\ndev_err(&client->dev, "failed to enable vana regulator\n");\r\nreturn rval;\r\n}\r\nusleep_range(1000, 1000);\r\nrval = clk_prepare_enable(sensor->ext_clk);\r\nif (rval < 0) {\r\ndev_dbg(&client->dev, "failed to enable xclk\n");\r\ngoto out_xclk_fail;\r\n}\r\nusleep_range(1000, 1000);\r\ngpiod_set_value(sensor->xshutdown, 1);\r\nsleep = SMIAPP_RESET_DELAY(sensor->hwcfg->ext_clk);\r\nusleep_range(sleep, sleep);\r\nif (sensor->hwcfg->i2c_addr_alt) {\r\nrval = smiapp_change_cci_addr(sensor);\r\nif (rval) {\r\ndev_err(&client->dev, "cci address change error\n");\r\ngoto out_cci_addr_fail;\r\n}\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_SOFTWARE_RESET,\r\nSMIAPP_SOFTWARE_RESET);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "software reset failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nif (sensor->hwcfg->i2c_addr_alt) {\r\nrval = smiapp_change_cci_addr(sensor);\r\nif (rval) {\r\ndev_err(&client->dev, "cci address change error\n");\r\ngoto out_cci_addr_fail;\r\n}\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_COMPRESSION_MODE,\r\nSMIAPP_COMPRESSION_MODE_SIMPLE_PREDICTOR);\r\nif (rval) {\r\ndev_err(&client->dev, "compression mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_EXTCLK_FREQUENCY_MHZ,\r\nsensor->hwcfg->ext_clk / (1000000 / (1 << 8)));\r\nif (rval) {\r\ndev_err(&client->dev, "extclk frequency set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_CSI_LANE_MODE,\r\nsensor->hwcfg->lanes - 1);\r\nif (rval) {\r\ndev_err(&client->dev, "csi lane mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FAST_STANDBY_CTRL,\r\nSMIAPP_FAST_STANDBY_CTRL_IMMEDIATE);\r\nif (rval) {\r\ndev_err(&client->dev, "fast standby set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_CSI_SIGNALLING_MODE,\r\nsensor->hwcfg->csi_signalling_mode);\r\nif (rval) {\r\ndev_err(&client->dev, "csi signalling mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_DPHY_CTRL,\r\nSMIAPP_DPHY_CTRL_UI);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_call_quirk(sensor, post_poweron);\r\nif (rval) {\r\ndev_err(&client->dev, "post_poweron quirks failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nif (!sensor->pixel_array)\r\nreturn 0;\r\nrval = v4l2_ctrl_handler_setup(&sensor->pixel_array->ctrl_handler);\r\nif (rval)\r\ngoto out_cci_addr_fail;\r\nrval = v4l2_ctrl_handler_setup(&sensor->src->ctrl_handler);\r\nif (rval)\r\ngoto out_cci_addr_fail;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_update_mode(sensor);\r\nmutex_unlock(&sensor->mutex);\r\nif (rval < 0)\r\ngoto out_cci_addr_fail;\r\nreturn 0;\r\nout_cci_addr_fail:\r\ngpiod_set_value(sensor->xshutdown, 0);\r\nclk_disable_unprepare(sensor->ext_clk);\r\nout_xclk_fail:\r\nregulator_disable(sensor->vana);\r\nreturn rval;\r\n}\r\nstatic int smiapp_power_off(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct smiapp_sensor *sensor =\r\ncontainer_of(ssd, struct smiapp_sensor, ssds[0]);\r\nif (sensor->hwcfg->i2c_addr_alt)\r\nsmiapp_write(sensor,\r\nSMIAPP_REG_U8_SOFTWARE_RESET,\r\nSMIAPP_SOFTWARE_RESET);\r\ngpiod_set_value(sensor->xshutdown, 0);\r\nclk_disable_unprepare(sensor->ext_clk);\r\nusleep_range(5000, 5000);\r\nregulator_disable(sensor->vana);\r\nsensor->streaming = false;\r\nreturn 0;\r\n}\r\nstatic int smiapp_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nint rval;\r\nif (!on) {\r\npm_runtime_mark_last_busy(subdev->dev);\r\npm_runtime_put_autosuspend(subdev->dev);\r\nreturn 0;\r\n}\r\nrval = pm_runtime_get_sync(subdev->dev);\r\nif (rval >= 0)\r\nreturn 0;\r\nif (rval != -EBUSY && rval != -EAGAIN)\r\npm_runtime_set_active(subdev->dev);\r\npm_runtime_put(subdev->dev);\r\nreturn rval;\r\n}\r\nstatic int smiapp_start_streaming(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_CSI_DATA_FORMAT,\r\n(sensor->csi_format->width << 8) |\r\nsensor->csi_format->compressed);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_pll_configure(sensor);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_X_ADDR_START,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].left);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_Y_ADDR_START,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].top);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_X_ADDR_END,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].left\r\n+ sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width - 1);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_Y_ADDR_END,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].top\r\n+ sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height - 1);\r\nif (rval < 0)\r\ngoto out;\r\nif (sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_X_OFFSET,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].left);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_Y_OFFSET,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].top);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_IMAGE_WIDTH,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].width);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_IMAGE_HEIGHT,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].height);\r\nif (rval < 0)\r\ngoto out;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE) {\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_SCALING_MODE,\r\nsensor->scaling_mode);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_SCALE_M,\r\nsensor->scale_m);\r\nif (rval < 0)\r\ngoto out;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_X_OUTPUT_SIZE,\r\nsensor->src->crop[SMIAPP_PAD_SRC].width);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_Y_OUTPUT_SIZE,\r\nsensor->src->crop[SMIAPP_PAD_SRC].height);\r\nif (rval < 0)\r\ngoto out;\r\nif ((sensor->limits[SMIAPP_LIMIT_FLASH_MODE_CAPABILITY] &\r\n(SMIAPP_FLASH_MODE_CAPABILITY_SINGLE_STROBE |\r\nSMIAPP_FLASH_MODE_CAPABILITY_MULTIPLE_STROBE)) &&\r\nsensor->hwcfg->strobe_setup != NULL &&\r\nsensor->hwcfg->strobe_setup->trigger != 0) {\r\nrval = smiapp_setup_flash_strobe(sensor);\r\nif (rval)\r\ngoto out;\r\n}\r\nrval = smiapp_call_quirk(sensor, pre_streamon);\r\nif (rval) {\r\ndev_err(&client->dev, "pre_streamon quirks failed\n");\r\ngoto out;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_MODE_SELECT,\r\nSMIAPP_MODE_SELECT_STREAMING);\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_stop_streaming(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_MODE_SELECT,\r\nSMIAPP_MODE_SELECT_SOFTWARE_STANDBY);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_call_quirk(sensor, post_streamoff);\r\nif (rval)\r\ndev_err(&client->dev, "post_streamoff quirks failed\n");\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_set_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nif (sensor->streaming == enable)\r\nreturn 0;\r\nif (enable) {\r\nsensor->streaming = true;\r\nrval = smiapp_start_streaming(sensor);\r\nif (rval < 0)\r\nsensor->streaming = false;\r\n} else {\r\nrval = smiapp_stop_streaming(sensor);\r\nsensor->streaming = false;\r\n}\r\nreturn rval;\r\n}\r\nstatic int smiapp_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nint idx = -1;\r\nint rval = -EINVAL;\r\nmutex_lock(&sensor->mutex);\r\ndev_err(&client->dev, "subdev %s, pad %d, index %d\n",\r\nsubdev->name, code->pad, code->index);\r\nif (subdev != &sensor->src->sd || code->pad != SMIAPP_PAD_SRC) {\r\nif (code->index)\r\ngoto out;\r\ncode->code = sensor->internal_csi_format->code;\r\nrval = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nif (sensor->mbus_frame_fmts & (1 << i))\r\nidx++;\r\nif (idx == code->index) {\r\ncode->code = smiapp_csi_data_formats[i].code;\r\ndev_err(&client->dev, "found index %d, i %d, code %x\n",\r\ncode->index, i, code->code);\r\nrval = 0;\r\nbreak;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic u32 __smiapp_get_mbus_code(struct v4l2_subdev *subdev,\r\nunsigned int pad)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nif (subdev == &sensor->src->sd && pad == SMIAPP_PAD_SRC)\r\nreturn sensor->csi_format->code;\r\nelse\r\nreturn sensor->internal_csi_format->code;\r\n}\r\nstatic int __smiapp_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nfmt->format = *v4l2_subdev_get_try_format(subdev, cfg,\r\nfmt->pad);\r\n} else {\r\nstruct v4l2_rect *r;\r\nif (fmt->pad == ssd->source_pad)\r\nr = &ssd->crop[ssd->source_pad];\r\nelse\r\nr = &ssd->sink_fmt;\r\nfmt->format.code = __smiapp_get_mbus_code(subdev, fmt->pad);\r\nfmt->format.width = r->width;\r\nfmt->format.height = r->height;\r\nfmt->format.field = V4L2_FIELD_NONE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = __smiapp_get_format(subdev, cfg, fmt);\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic void smiapp_get_crop_compose(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect **comps, int which)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nunsigned int i;\r\nif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (crops)\r\nfor (i = 0; i < subdev->entity.num_pads; i++)\r\ncrops[i] = &ssd->crop[i];\r\nif (comps)\r\n*comps = &ssd->compose;\r\n} else {\r\nif (crops) {\r\nfor (i = 0; i < subdev->entity.num_pads; i++) {\r\ncrops[i] = v4l2_subdev_get_try_crop(subdev, cfg, i);\r\nBUG_ON(!crops[i]);\r\n}\r\n}\r\nif (comps) {\r\n*comps = v4l2_subdev_get_try_compose(subdev, cfg,\r\nSMIAPP_PAD_SINK);\r\nBUG_ON(!*comps);\r\n}\r\n}\r\n}\r\nstatic void smiapp_propagate(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg, int which,\r\nint target)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nsmiapp_get_crop_compose(subdev, cfg, crops, &comp, which);\r\nswitch (target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncomp->width = crops[SMIAPP_PAD_SINK]->width;\r\ncomp->height = crops[SMIAPP_PAD_SINK]->height;\r\nif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (ssd == sensor->scaler) {\r\nsensor->scale_m =\r\nsensor->limits[\r\nSMIAPP_LIMIT_SCALER_N_MIN];\r\nsensor->scaling_mode =\r\nSMIAPP_SCALING_MODE_NONE;\r\n} else if (ssd == sensor->binner) {\r\nsensor->binning_horizontal = 1;\r\nsensor->binning_vertical = 1;\r\n}\r\n}\r\ncase V4L2_SEL_TGT_COMPOSE:\r\n*crops[SMIAPP_PAD_SRC] = *comp;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic const struct smiapp_csi_data_format\r\n*smiapp_validate_csi_data_format(struct smiapp_sensor *sensor, u32 code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nif (sensor->mbus_frame_fmts & (1 << i)\r\n&& smiapp_csi_data_formats[i].code == code)\r\nreturn &smiapp_csi_data_formats[i];\r\n}\r\nreturn sensor->csi_format;\r\n}\r\nstatic int smiapp_set_format_source(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nconst struct smiapp_csi_data_format *csi_format,\r\n*old_csi_format = sensor->csi_format;\r\nunsigned long *valid_link_freqs;\r\nu32 code = fmt->format.code;\r\nunsigned int i;\r\nint rval;\r\nrval = __smiapp_get_format(subdev, cfg, fmt);\r\nif (rval)\r\nreturn rval;\r\nif (subdev != &sensor->src->sd)\r\nreturn 0;\r\ncsi_format = smiapp_validate_csi_data_format(sensor, code);\r\nfmt->format.code = csi_format->code;\r\nif (fmt->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn 0;\r\nsensor->csi_format = csi_format;\r\nif (csi_format->width != old_csi_format->width)\r\nfor (i = 0; i < ARRAY_SIZE(sensor->test_data); i++)\r\n__v4l2_ctrl_modify_range(\r\nsensor->test_data[i], 0,\r\n(1 << csi_format->width) - 1, 1, 0);\r\nif (csi_format->compressed == old_csi_format->compressed)\r\nreturn 0;\r\nvalid_link_freqs =\r\n&sensor->valid_link_freqs[sensor->csi_format->compressed\r\n- sensor->compressed_min_bpp];\r\n__v4l2_ctrl_modify_range(\r\nsensor->link_freq, 0,\r\n__fls(*valid_link_freqs), ~*valid_link_freqs,\r\n__ffs(*valid_link_freqs));\r\nreturn smiapp_pll_update(sensor);\r\n}\r\nstatic int smiapp_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *crops[SMIAPP_PADS];\r\nmutex_lock(&sensor->mutex);\r\nif (fmt->pad == ssd->source_pad) {\r\nint rval;\r\nrval = smiapp_set_format_source(subdev, cfg, fmt);\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nfmt->format.code = __smiapp_get_mbus_code(subdev, fmt->pad);\r\nfmt->format.width &= ~1;\r\nfmt->format.height &= ~1;\r\nfmt->format.field = V4L2_FIELD_NONE;\r\nfmt->format.width =\r\nclamp(fmt->format.width,\r\nsensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE],\r\nsensor->limits[SMIAPP_LIMIT_MAX_X_OUTPUT_SIZE]);\r\nfmt->format.height =\r\nclamp(fmt->format.height,\r\nsensor->limits[SMIAPP_LIMIT_MIN_Y_OUTPUT_SIZE],\r\nsensor->limits[SMIAPP_LIMIT_MAX_Y_OUTPUT_SIZE]);\r\nsmiapp_get_crop_compose(subdev, cfg, crops, NULL, fmt->which);\r\ncrops[ssd->sink_pad]->left = 0;\r\ncrops[ssd->sink_pad]->top = 0;\r\ncrops[ssd->sink_pad]->width = fmt->format.width;\r\ncrops[ssd->sink_pad]->height = fmt->format.height;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nssd->sink_fmt = *crops[ssd->sink_pad];\r\nsmiapp_propagate(subdev, cfg, fmt->which,\r\nV4L2_SEL_TGT_CROP);\r\nmutex_unlock(&sensor->mutex);\r\nreturn 0;\r\n}\r\nstatic int scaling_goodness(struct v4l2_subdev *subdev, int w, int ask_w,\r\nint h, int ask_h, u32 flags)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nint val = 0;\r\nw &= ~1;\r\nask_w &= ~1;\r\nh &= ~1;\r\nask_h &= ~1;\r\nif (flags & V4L2_SEL_FLAG_GE) {\r\nif (w < ask_w)\r\nval -= SCALING_GOODNESS;\r\nif (h < ask_h)\r\nval -= SCALING_GOODNESS;\r\n}\r\nif (flags & V4L2_SEL_FLAG_LE) {\r\nif (w > ask_w)\r\nval -= SCALING_GOODNESS;\r\nif (h > ask_h)\r\nval -= SCALING_GOODNESS;\r\n}\r\nval -= abs(w - ask_w);\r\nval -= abs(h - ask_h);\r\nif (w < sensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE])\r\nval -= SCALING_GOODNESS_EXTREME;\r\ndev_dbg(&client->dev, "w %d ask_w %d h %d ask_h %d goodness %d\n",\r\nw, ask_h, h, ask_h, val);\r\nreturn val;\r\n}\r\nstatic void smiapp_set_compose_binner(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect *comp)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nunsigned int binh = 1, binv = 1;\r\nint best = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width, sel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height, sel->r.height, sel->flags);\r\nfor (i = 0; i < sensor->nbinning_subtypes; i++) {\r\nint this = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width\r\n/ sensor->binning_subtypes[i].horizontal,\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height\r\n/ sensor->binning_subtypes[i].vertical,\r\nsel->r.height, sel->flags);\r\nif (this > best) {\r\nbinh = sensor->binning_subtypes[i].horizontal;\r\nbinv = sensor->binning_subtypes[i].vertical;\r\nbest = this;\r\n}\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsensor->binning_vertical = binv;\r\nsensor->binning_horizontal = binh;\r\n}\r\nsel->r.width = (crops[SMIAPP_PAD_SINK]->width / binh) & ~1;\r\nsel->r.height = (crops[SMIAPP_PAD_SINK]->height / binv) & ~1;\r\n}\r\nstatic void smiapp_set_compose_scaler(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect *comp)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nu32 min, max, a, b, max_m;\r\nu32 scale_m = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nint mode = SMIAPP_SCALING_MODE_HORIZONTAL;\r\nu32 try[4];\r\nu32 ntry = 0;\r\nunsigned int i;\r\nint best = INT_MIN;\r\nsel->r.width = min_t(unsigned int, sel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->width);\r\nsel->r.height = min_t(unsigned int, sel->r.height,\r\ncrops[SMIAPP_PAD_SINK]->height);\r\na = crops[SMIAPP_PAD_SINK]->width\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] / sel->r.width;\r\nb = crops[SMIAPP_PAD_SINK]->height\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] / sel->r.height;\r\nmax_m = crops[SMIAPP_PAD_SINK]->width\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN]\r\n/ sensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE];\r\na = clamp(a, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN],\r\nsensor->limits[SMIAPP_LIMIT_SCALER_M_MAX]);\r\nb = clamp(b, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN],\r\nsensor->limits[SMIAPP_LIMIT_SCALER_M_MAX]);\r\nmax_m = clamp(max_m, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN],\r\nsensor->limits[SMIAPP_LIMIT_SCALER_M_MAX]);\r\ndev_dbg(&client->dev, "scaling: a %d b %d max_m %d\n", a, b, max_m);\r\nmin = min(max_m, min(a, b));\r\nmax = min(max_m, max(a, b));\r\ntry[ntry] = min;\r\nntry++;\r\nif (min != max) {\r\ntry[ntry] = max;\r\nntry++;\r\n}\r\nif (max != max_m) {\r\ntry[ntry] = min + 1;\r\nntry++;\r\nif (min != max) {\r\ntry[ntry] = max + 1;\r\nntry++;\r\n}\r\n}\r\nfor (i = 0; i < ntry; i++) {\r\nint this = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height,\r\nsel->r.height,\r\nsel->flags);\r\ndev_dbg(&client->dev, "trying factor %d (%d)\n", try[i], i);\r\nif (this > best) {\r\nscale_m = try[i];\r\nmode = SMIAPP_SCALING_MODE_HORIZONTAL;\r\nbest = this;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n== SMIAPP_SCALING_CAPABILITY_HORIZONTAL)\r\ncontinue;\r\nthis = scaling_goodness(\r\nsubdev, crops[SMIAPP_PAD_SINK]->width\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.height,\r\nsel->flags);\r\nif (this > best) {\r\nscale_m = try[i];\r\nmode = SMIAPP_SCALING_MODE_BOTH;\r\nbest = this;\r\n}\r\n}\r\nsel->r.width =\r\n(crops[SMIAPP_PAD_SINK]->width\r\n/ scale_m\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN]) & ~1;\r\nif (mode == SMIAPP_SCALING_MODE_BOTH)\r\nsel->r.height =\r\n(crops[SMIAPP_PAD_SINK]->height\r\n/ scale_m\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN])\r\n& ~1;\r\nelse\r\nsel->r.height = crops[SMIAPP_PAD_SINK]->height;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsensor->scale_m = scale_m;\r\nsensor->scaling_mode = mode;\r\n}\r\n}\r\nstatic int smiapp_set_compose(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nsmiapp_get_crop_compose(subdev, cfg, crops, &comp, sel->which);\r\nsel->r.top = 0;\r\nsel->r.left = 0;\r\nif (ssd == sensor->binner)\r\nsmiapp_set_compose_binner(subdev, cfg, sel, crops, comp);\r\nelse\r\nsmiapp_set_compose_scaler(subdev, cfg, sel, crops, comp);\r\n*comp = sel->r;\r\nsmiapp_propagate(subdev, cfg, sel->which, V4L2_SEL_TGT_COMPOSE);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn smiapp_update_mode(sensor);\r\nreturn 0;\r\n}\r\nstatic int __smiapp_sel_supported(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nif (ssd == sensor->pixel_array\r\n&& sel->pad == SMIAPP_PA_PAD_SRC)\r\nreturn 0;\r\nif (ssd == sensor->src\r\n&& sel->pad == SMIAPP_PAD_SRC)\r\nreturn 0;\r\nif (ssd == sensor->scaler\r\n&& sel->pad == SMIAPP_PAD_SINK\r\n&& sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP)\r\nreturn 0;\r\nreturn -EINVAL;\r\ncase V4L2_SEL_TGT_NATIVE_SIZE:\r\nif (ssd == sensor->pixel_array\r\n&& sel->pad == SMIAPP_PA_PAD_SRC)\r\nreturn 0;\r\nreturn -EINVAL;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nif (sel->pad == ssd->source_pad)\r\nreturn -EINVAL;\r\nif (ssd == sensor->binner)\r\nreturn 0;\r\nif (ssd == sensor->scaler\r\n&& sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE)\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int smiapp_set_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *src_size, *crops[SMIAPP_PADS];\r\nstruct v4l2_rect _r;\r\nsmiapp_get_crop_compose(subdev, cfg, crops, NULL, sel->which);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (sel->pad == ssd->sink_pad)\r\nsrc_size = &ssd->sink_fmt;\r\nelse\r\nsrc_size = &ssd->compose;\r\n} else {\r\nif (sel->pad == ssd->sink_pad) {\r\n_r.left = 0;\r\n_r.top = 0;\r\n_r.width = v4l2_subdev_get_try_format(subdev, cfg, sel->pad)\r\n->width;\r\n_r.height = v4l2_subdev_get_try_format(subdev, cfg, sel->pad)\r\n->height;\r\nsrc_size = &_r;\r\n} else {\r\nsrc_size = v4l2_subdev_get_try_compose(\r\nsubdev, cfg, ssd->sink_pad);\r\n}\r\n}\r\nif (ssd == sensor->src && sel->pad == SMIAPP_PAD_SRC) {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\n}\r\nsel->r.width = min(sel->r.width, src_size->width);\r\nsel->r.height = min(sel->r.height, src_size->height);\r\nsel->r.left = min_t(int, sel->r.left, src_size->width - sel->r.width);\r\nsel->r.top = min_t(int, sel->r.top, src_size->height - sel->r.height);\r\n*crops[sel->pad] = sel->r;\r\nif (ssd != sensor->pixel_array && sel->pad == SMIAPP_PAD_SINK)\r\nsmiapp_propagate(subdev, cfg, sel->which,\r\nV4L2_SEL_TGT_CROP);\r\nreturn 0;\r\n}\r\nstatic void smiapp_get_native_size(struct smiapp_subdev *ssd,\r\nstruct v4l2_rect *r)\r\n{\r\nr->top = 0;\r\nr->left = 0;\r\nr->width = ssd->sensor->limits[SMIAPP_LIMIT_X_ADDR_MAX] + 1;\r\nr->height = ssd->sensor->limits[SMIAPP_LIMIT_Y_ADDR_MAX] + 1;\r\n}\r\nstatic int __smiapp_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nstruct v4l2_rect sink_fmt;\r\nint ret;\r\nret = __smiapp_sel_supported(subdev, sel);\r\nif (ret)\r\nreturn ret;\r\nsmiapp_get_crop_compose(subdev, cfg, crops, &comp, sel->which);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsink_fmt = ssd->sink_fmt;\r\n} else {\r\nstruct v4l2_mbus_framefmt *fmt =\r\nv4l2_subdev_get_try_format(subdev, cfg, ssd->sink_pad);\r\nsink_fmt.left = 0;\r\nsink_fmt.top = 0;\r\nsink_fmt.width = fmt->width;\r\nsink_fmt.height = fmt->height;\r\n}\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_NATIVE_SIZE:\r\nif (ssd == sensor->pixel_array)\r\nsmiapp_get_native_size(ssd, &sel->r);\r\nelse if (sel->pad == ssd->sink_pad)\r\nsel->r = sink_fmt;\r\nelse\r\nsel->r = *comp;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nsel->r = *crops[sel->pad];\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = *comp;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = __smiapp_get_selection(subdev, cfg, sel);\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint ret;\r\nret = __smiapp_sel_supported(subdev, sel);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&sensor->mutex);\r\nsel->r.left = max(0, sel->r.left & ~1);\r\nsel->r.top = max(0, sel->r.top & ~1);\r\nsel->r.width = SMIAPP_ALIGN_DIM(sel->r.width, sel->flags);\r\nsel->r.height = SMIAPP_ALIGN_DIM(sel->r.height, sel->flags);\r\nsel->r.width = max_t(unsigned int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE],\r\nsel->r.width);\r\nsel->r.height = max_t(unsigned int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_Y_OUTPUT_SIZE],\r\nsel->r.height);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nret = smiapp_set_crop(subdev, cfg, sel);\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nret = smiapp_set_compose(subdev, cfg, sel);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&sensor->mutex);\r\nreturn ret;\r\n}\r\nstatic int smiapp_get_skip_frames(struct v4l2_subdev *subdev, u32 *frames)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\n*frames = sensor->frame_skip;\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_skip_top_lines(struct v4l2_subdev *subdev, u32 *lines)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\n*lines = sensor->image_start;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsmiapp_sysfs_nvm_read(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int nbytes;\r\nif (!sensor->dev_init_done)\r\nreturn -EBUSY;\r\nif (!sensor->nvm_size) {\r\nint rval;\r\nsensor->nvm_size = sensor->hwcfg->nvm_size;\r\nrval = pm_runtime_get_sync(&client->dev);\r\nif (rval < 0) {\r\nif (rval != -EBUSY && rval != -EAGAIN)\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_put(&client->dev);\r\nreturn -ENODEV;\r\n}\r\nif (smiapp_read_nvm(sensor, sensor->nvm)) {\r\ndev_err(&client->dev, "nvm read failed\n");\r\nreturn -ENODEV;\r\n}\r\npm_runtime_mark_last_busy(&client->dev);\r\npm_runtime_put_autosuspend(&client->dev);\r\n}\r\nnbytes = min_t(unsigned int, sensor->nvm_size, PAGE_SIZE);\r\nmemcpy(buf, sensor->nvm, nbytes);\r\nreturn nbytes;\r\n}\r\nstatic ssize_t\r\nsmiapp_sysfs_ident_read(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_module_info *minfo = &sensor->minfo;\r\nreturn snprintf(buf, PAGE_SIZE, "%2.2x%4.4x%2.2x\n",\r\nminfo->manufacturer_id, minfo->model_id,\r\nminfo->revision_number_major) + 1;\r\n}\r\nstatic int smiapp_identify_module(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct smiapp_module_info *minfo = &sensor->minfo;\r\nunsigned int i;\r\nint rval = 0;\r\nminfo->name = SMIAPP_NAME;\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_MANUFACTURER_ID,\r\n&minfo->manufacturer_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U16_MODEL_ID,\r\n&minfo->model_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_REVISION_NUMBER_MAJOR,\r\n&minfo->revision_number_major);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_REVISION_NUMBER_MINOR,\r\n&minfo->revision_number_minor);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_MODULE_DATE_YEAR,\r\n&minfo->module_year);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_MODULE_DATE_MONTH,\r\n&minfo->module_month);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_MODULE_DATE_DAY,\r\n&minfo->module_day);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_MANUFACTURER_ID,\r\n&minfo->sensor_manufacturer_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U16_SENSOR_MODEL_ID,\r\n&minfo->sensor_model_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_REVISION_NUMBER,\r\n&minfo->sensor_revision_number);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_FIRMWARE_VERSION,\r\n&minfo->sensor_firmware_version);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_SMIA_VERSION,\r\n&minfo->smia_version);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_SMIAPP_VERSION,\r\n&minfo->smiapp_version);\r\nif (rval) {\r\ndev_err(&client->dev, "sensor detection failed\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&client->dev, "module 0x%2.2x-0x%4.4x\n",\r\nminfo->manufacturer_id, minfo->model_id);\r\ndev_dbg(&client->dev,\r\n"module revision 0x%2.2x-0x%2.2x date %2.2d-%2.2d-%2.2d\n",\r\nminfo->revision_number_major, minfo->revision_number_minor,\r\nminfo->module_year, minfo->module_month, minfo->module_day);\r\ndev_dbg(&client->dev, "sensor 0x%2.2x-0x%4.4x\n",\r\nminfo->sensor_manufacturer_id, minfo->sensor_model_id);\r\ndev_dbg(&client->dev,\r\n"sensor revision 0x%2.2x firmware version 0x%2.2x\n",\r\nminfo->sensor_revision_number, minfo->sensor_firmware_version);\r\ndev_dbg(&client->dev, "smia version %2.2d smiapp version %2.2d\n",\r\nminfo->smia_version, minfo->smiapp_version);\r\nif (!minfo->manufacturer_id && !minfo->model_id) {\r\nminfo->manufacturer_id = minfo->sensor_manufacturer_id;\r\nminfo->model_id = minfo->sensor_model_id;\r\nminfo->revision_number_major = minfo->sensor_revision_number;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_module_idents); i++) {\r\nif (smiapp_module_idents[i].manufacturer_id\r\n!= minfo->manufacturer_id)\r\ncontinue;\r\nif (smiapp_module_idents[i].model_id != minfo->model_id)\r\ncontinue;\r\nif (smiapp_module_idents[i].flags\r\n& SMIAPP_MODULE_IDENT_FLAG_REV_LE) {\r\nif (smiapp_module_idents[i].revision_number_major\r\n< minfo->revision_number_major)\r\ncontinue;\r\n} else {\r\nif (smiapp_module_idents[i].revision_number_major\r\n!= minfo->revision_number_major)\r\ncontinue;\r\n}\r\nminfo->name = smiapp_module_idents[i].name;\r\nminfo->quirk = smiapp_module_idents[i].quirk;\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(smiapp_module_idents))\r\ndev_warn(&client->dev,\r\n"no quirks for this module; let's hope it's fully compliant\n");\r\ndev_dbg(&client->dev, "the sensor is called %s, ident %2.2x%4.4x%2.2x\n",\r\nminfo->name, minfo->manufacturer_id, minfo->model_id,\r\nminfo->revision_number_major);\r\nreturn 0;\r\n}\r\nstatic int smiapp_register_subdev(struct smiapp_sensor *sensor,\r\nstruct smiapp_subdev *ssd,\r\nstruct smiapp_subdev *sink_ssd,\r\nu16 source_pad, u16 sink_pad, u32 link_flags)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nif (!sink_ssd)\r\nreturn 0;\r\nrval = media_entity_pads_init(&ssd->sd.entity,\r\nssd->npads, ssd->pads);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"media_entity_pads_init failed\n");\r\nreturn rval;\r\n}\r\nrval = v4l2_device_register_subdev(sensor->src->sd.v4l2_dev,\r\n&ssd->sd);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"v4l2_device_register_subdev failed\n");\r\nreturn rval;\r\n}\r\nrval = media_create_pad_link(&ssd->sd.entity, source_pad,\r\n&sink_ssd->sd.entity, sink_pad,\r\nlink_flags);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"media_create_pad_link failed\n");\r\nv4l2_device_unregister_subdev(&ssd->sd);\r\nreturn rval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void smiapp_unregistered(struct v4l2_subdev *subdev)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nfor (i = 1; i < sensor->ssds_used; i++)\r\nv4l2_device_unregister_subdev(&sensor->ssds[i].sd);\r\n}\r\nstatic int smiapp_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nif (sensor->scaler) {\r\nrval = smiapp_register_subdev(\r\nsensor, sensor->binner, sensor->scaler,\r\nSMIAPP_PAD_SRC, SMIAPP_PAD_SINK,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nrval = smiapp_register_subdev(\r\nsensor, sensor->pixel_array, sensor->binner,\r\nSMIAPP_PA_PAD_SRC, SMIAPP_PAD_SINK,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (rval)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nsmiapp_unregistered(subdev);\r\nreturn rval;\r\n}\r\nstatic void smiapp_cleanup(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\ndevice_remove_file(&client->dev, &dev_attr_nvm);\r\ndevice_remove_file(&client->dev, &dev_attr_ident);\r\nsmiapp_free_controls(sensor);\r\n}\r\nstatic void smiapp_create_subdev(struct smiapp_sensor *sensor,\r\nstruct smiapp_subdev *ssd, const char *name,\r\nunsigned short num_pads)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nif (!ssd)\r\nreturn;\r\nif (ssd != sensor->src)\r\nv4l2_subdev_init(&ssd->sd, &smiapp_ops);\r\nssd->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nssd->sensor = sensor;\r\nssd->npads = num_pads;\r\nssd->source_pad = num_pads - 1;\r\nsnprintf(ssd->sd.name,\r\nsizeof(ssd->sd.name), "%s %s %d-%4.4x", sensor->minfo.name,\r\nname, i2c_adapter_id(client->adapter), client->addr);\r\nsmiapp_get_native_size(ssd, &ssd->sink_fmt);\r\nssd->compose.width = ssd->sink_fmt.width;\r\nssd->compose.height = ssd->sink_fmt.height;\r\nssd->crop[ssd->source_pad] = ssd->compose;\r\nssd->pads[ssd->source_pad].flags = MEDIA_PAD_FL_SOURCE;\r\nif (ssd != sensor->pixel_array) {\r\nssd->crop[ssd->sink_pad] = ssd->compose;\r\nssd->pads[ssd->sink_pad].flags = MEDIA_PAD_FL_SINK;\r\n}\r\nssd->sd.entity.ops = &smiapp_entity_ops;\r\nif (ssd == sensor->src)\r\nreturn;\r\nssd->sd.internal_ops = &smiapp_internal_ops;\r\nssd->sd.owner = THIS_MODULE;\r\nssd->sd.dev = &client->dev;\r\nv4l2_set_subdevdata(&ssd->sd, client);\r\n}\r\nstatic int smiapp_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(sd);\r\nstruct smiapp_sensor *sensor = ssd->sensor;\r\nunsigned int i;\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nfor (i = 0; i < ssd->npads; i++) {\r\nstruct v4l2_mbus_framefmt *try_fmt =\r\nv4l2_subdev_get_try_format(sd, fh->pad, i);\r\nstruct v4l2_rect *try_crop =\r\nv4l2_subdev_get_try_crop(sd, fh->pad, i);\r\nstruct v4l2_rect *try_comp;\r\nsmiapp_get_native_size(ssd, try_crop);\r\ntry_fmt->width = try_crop->width;\r\ntry_fmt->height = try_crop->height;\r\ntry_fmt->code = sensor->internal_csi_format->code;\r\ntry_fmt->field = V4L2_FIELD_NONE;\r\nif (ssd != sensor->pixel_array)\r\ncontinue;\r\ntry_comp = v4l2_subdev_get_try_compose(sd, fh->pad, i);\r\n*try_comp = *try_crop;\r\n}\r\nmutex_unlock(&sensor->mutex);\r\nrval = pm_runtime_get_sync(sd->dev);\r\nif (rval >= 0)\r\nreturn 0;\r\nif (rval != -EBUSY && rval != -EAGAIN)\r\npm_runtime_set_active(sd->dev);\r\npm_runtime_put(sd->dev);\r\nreturn rval;\r\n}\r\nstatic int smiapp_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\npm_runtime_mark_last_busy(sd->dev);\r\npm_runtime_put_autosuspend(sd->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused smiapp_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nbool streaming = sensor->streaming;\r\nint rval;\r\nrval = pm_runtime_get_sync(dev);\r\nif (rval < 0) {\r\nif (rval != -EBUSY && rval != -EAGAIN)\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_put(dev);\r\nreturn -EAGAIN;\r\n}\r\nif (sensor->streaming)\r\nsmiapp_stop_streaming(sensor);\r\nsensor->streaming = streaming;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused smiapp_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval = 0;\r\npm_runtime_put(dev);\r\nif (sensor->streaming)\r\nrval = smiapp_start_streaming(sensor);\r\nreturn rval;\r\n}\r\nstatic struct smiapp_hwconfig *smiapp_get_hwconfig(struct device *dev)\r\n{\r\nstruct smiapp_hwconfig *hwcfg;\r\nstruct v4l2_of_endpoint *bus_cfg;\r\nstruct device_node *ep;\r\nint i;\r\nint rval;\r\nif (!dev->of_node)\r\nreturn dev->platform_data;\r\nep = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (!ep)\r\nreturn NULL;\r\nbus_cfg = v4l2_of_alloc_parse_endpoint(ep);\r\nif (IS_ERR(bus_cfg))\r\ngoto out_err;\r\nhwcfg = devm_kzalloc(dev, sizeof(*hwcfg), GFP_KERNEL);\r\nif (!hwcfg)\r\ngoto out_err;\r\nswitch (bus_cfg->bus_type) {\r\ncase V4L2_MBUS_CSI2:\r\nhwcfg->csi_signalling_mode = SMIAPP_CSI_SIGNALLING_MODE_CSI2;\r\nbreak;\r\ndefault:\r\ngoto out_err;\r\n}\r\nhwcfg->lanes = bus_cfg->bus.mipi_csi2.num_data_lanes;\r\ndev_dbg(dev, "lanes %u\n", hwcfg->lanes);\r\nof_property_read_u32(dev->of_node, "nokia,nvm-size",\r\n&hwcfg->nvm_size);\r\nrval = of_property_read_u32(dev->of_node, "clock-frequency",\r\n&hwcfg->ext_clk);\r\nif (rval) {\r\ndev_warn(dev, "can't get clock-frequency\n");\r\ngoto out_err;\r\n}\r\ndev_dbg(dev, "nvm %d, clk %d, csi %d\n", hwcfg->nvm_size,\r\nhwcfg->ext_clk, hwcfg->csi_signalling_mode);\r\nif (!bus_cfg->nr_of_link_frequencies) {\r\ndev_warn(dev, "no link frequencies defined\n");\r\ngoto out_err;\r\n}\r\nhwcfg->op_sys_clock = devm_kcalloc(\r\ndev, bus_cfg->nr_of_link_frequencies + 1 ,\r\nsizeof(*hwcfg->op_sys_clock), GFP_KERNEL);\r\nif (!hwcfg->op_sys_clock)\r\ngoto out_err;\r\nfor (i = 0; i < bus_cfg->nr_of_link_frequencies; i++) {\r\nhwcfg->op_sys_clock[i] = bus_cfg->link_frequencies[i];\r\ndev_dbg(dev, "freq %d: %lld\n", i, hwcfg->op_sys_clock[i]);\r\n}\r\nv4l2_of_free_endpoint(bus_cfg);\r\nof_node_put(ep);\r\nreturn hwcfg;\r\nout_err:\r\nv4l2_of_free_endpoint(bus_cfg);\r\nof_node_put(ep);\r\nreturn NULL;\r\n}\r\nstatic int smiapp_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct smiapp_sensor *sensor;\r\nstruct smiapp_hwconfig *hwcfg = smiapp_get_hwconfig(&client->dev);\r\nunsigned int i;\r\nint rval;\r\nif (hwcfg == NULL)\r\nreturn -ENODEV;\r\nsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\r\nif (sensor == NULL)\r\nreturn -ENOMEM;\r\nsensor->hwcfg = hwcfg;\r\nmutex_init(&sensor->mutex);\r\nsensor->src = &sensor->ssds[sensor->ssds_used];\r\nv4l2_i2c_subdev_init(&sensor->src->sd, client, &smiapp_ops);\r\nsensor->src->sd.internal_ops = &smiapp_internal_src_ops;\r\nsensor->vana = devm_regulator_get(&client->dev, "vana");\r\nif (IS_ERR(sensor->vana)) {\r\ndev_err(&client->dev, "could not get regulator for vana\n");\r\nreturn PTR_ERR(sensor->vana);\r\n}\r\nsensor->ext_clk = devm_clk_get(&client->dev, NULL);\r\nif (IS_ERR(sensor->ext_clk)) {\r\ndev_err(&client->dev, "could not get clock (%ld)\n",\r\nPTR_ERR(sensor->ext_clk));\r\nreturn -EPROBE_DEFER;\r\n}\r\nrval = clk_set_rate(sensor->ext_clk, sensor->hwcfg->ext_clk);\r\nif (rval < 0) {\r\ndev_err(&client->dev,\r\n"unable to set clock freq to %u\n",\r\nsensor->hwcfg->ext_clk);\r\nreturn rval;\r\n}\r\nsensor->xshutdown = devm_gpiod_get_optional(&client->dev, "xshutdown",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(sensor->xshutdown))\r\nreturn PTR_ERR(sensor->xshutdown);\r\nrval = smiapp_power_on(&client->dev);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_identify_module(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nrval = smiapp_get_all_limits(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nrval = smiapp_read_frame_fmt(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nif (sensor->hwcfg->module_board_orient ==\r\nSMIAPP_MODULE_BOARD_ORIENT_180)\r\nsensor->hvflip_inv_mask = SMIAPP_IMAGE_ORIENTATION_HFLIP |\r\nSMIAPP_IMAGE_ORIENTATION_VFLIP;\r\nrval = smiapp_call_quirk(sensor, limits);\r\nif (rval) {\r\ndev_err(&client->dev, "limits quirks failed\n");\r\ngoto out_power_off;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_BINNING_CAPABILITY]) {\r\nu32 val;\r\nrval = smiapp_read(sensor,\r\nSMIAPP_REG_U8_BINNING_SUBTYPES, &val);\r\nif (rval < 0) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nsensor->nbinning_subtypes = min_t(u8, val,\r\nSMIAPP_BINNING_SUBTYPES);\r\nfor (i = 0; i < sensor->nbinning_subtypes; i++) {\r\nrval = smiapp_read(\r\nsensor, SMIAPP_REG_U8_BINNING_TYPE_n(i), &val);\r\nif (rval < 0) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nsensor->binning_subtypes[i] =\r\n*(struct smiapp_binning_subtype *)&val;\r\ndev_dbg(&client->dev, "binning %xx%x\n",\r\nsensor->binning_subtypes[i].horizontal,\r\nsensor->binning_subtypes[i].vertical);\r\n}\r\n}\r\nsensor->binning_horizontal = 1;\r\nsensor->binning_vertical = 1;\r\nif (device_create_file(&client->dev, &dev_attr_ident) != 0) {\r\ndev_err(&client->dev, "sysfs ident entry creation failed\n");\r\nrval = -ENOENT;\r\ngoto out_power_off;\r\n}\r\nif (sensor->minfo.smiapp_version && sensor->hwcfg->nvm_size) {\r\nsensor->nvm = devm_kzalloc(&client->dev,\r\nsensor->hwcfg->nvm_size, GFP_KERNEL);\r\nif (sensor->nvm == NULL) {\r\nrval = -ENOMEM;\r\ngoto out_cleanup;\r\n}\r\nif (device_create_file(&client->dev, &dev_attr_nvm) != 0) {\r\ndev_err(&client->dev, "sysfs nvm entry failed\n");\r\nrval = -EBUSY;\r\ngoto out_cleanup;\r\n}\r\n}\r\nif (!sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_DIV]) {\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_0;\r\n} else if (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE) {\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n== SMIAPP_SCALING_CAPABILITY_HORIZONTAL)\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_1;\r\nelse\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_2;\r\nsensor->scaler = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\n} else if (sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\r\nsensor->scaler = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\n}\r\nsensor->binner = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\nsensor->pixel_array = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\nsensor->scale_m = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nsensor->pll.bus_type = SMIAPP_PLL_BUS_TYPE_CSI2;\r\nsensor->pll.csi2.lanes = sensor->hwcfg->lanes;\r\nsensor->pll.ext_clk_freq_hz = sensor->hwcfg->ext_clk;\r\nsensor->pll.scale_n = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nif (sensor->minfo.smiapp_profile == SMIAPP_PROFILE_0)\r\nsensor->pll.flags |= SMIAPP_PLL_FLAG_NO_OP_CLOCKS;\r\nsmiapp_create_subdev(sensor, sensor->scaler, "scaler", 2);\r\nsmiapp_create_subdev(sensor, sensor->binner, "binner", 2);\r\nsmiapp_create_subdev(sensor, sensor->pixel_array, "pixel_array", 1);\r\ndev_dbg(&client->dev, "profile %d\n", sensor->minfo.smiapp_profile);\r\nsensor->pixel_array->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;\r\nrval = smiapp_init_controls(sensor);\r\nif (rval < 0)\r\ngoto out_cleanup;\r\nrval = smiapp_call_quirk(sensor, init);\r\nif (rval)\r\ngoto out_cleanup;\r\nrval = smiapp_get_mbus_formats(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_cleanup;\r\n}\r\nrval = smiapp_init_late_controls(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_cleanup;\r\n}\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_update_mode(sensor);\r\nmutex_unlock(&sensor->mutex);\r\nif (rval) {\r\ndev_err(&client->dev, "update mode failed\n");\r\ngoto out_cleanup;\r\n}\r\nsensor->streaming = false;\r\nsensor->dev_init_done = true;\r\nrval = media_entity_pads_init(&sensor->src->sd.entity, 2,\r\nsensor->src->pads);\r\nif (rval < 0)\r\ngoto out_media_entity_cleanup;\r\nrval = v4l2_async_register_subdev(&sensor->src->sd);\r\nif (rval < 0)\r\ngoto out_media_entity_cleanup;\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_get_noresume(&client->dev);\r\npm_runtime_enable(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, 1000);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_put_autosuspend(&client->dev);\r\nreturn 0;\r\nout_media_entity_cleanup:\r\nmedia_entity_cleanup(&sensor->src->sd.entity);\r\nout_cleanup:\r\nsmiapp_cleanup(sensor);\r\nout_power_off:\r\nsmiapp_power_off(&client->dev);\r\nreturn rval;\r\n}\r\nstatic int smiapp_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nv4l2_async_unregister_subdev(subdev);\r\npm_runtime_disable(&client->dev);\r\nif (!pm_runtime_status_suspended(&client->dev))\r\nsmiapp_power_off(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\nfor (i = 0; i < sensor->ssds_used; i++) {\r\nv4l2_device_unregister_subdev(&sensor->ssds[i].sd);\r\nmedia_entity_cleanup(&sensor->ssds[i].sd.entity);\r\n}\r\nsmiapp_cleanup(sensor);\r\nreturn 0;\r\n}
