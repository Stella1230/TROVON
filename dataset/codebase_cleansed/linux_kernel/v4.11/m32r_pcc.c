void pcc_iorw(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int wr, int flag)\r\n{\r\nu_long addr;\r\nu_long flags;\r\nint need_ex;\r\n#ifdef PCC_DEBUG_DBEX\r\nint _dbex;\r\n#endif\r\npcc_socket_t *t = &socket[sock];\r\n#ifdef CHAOS_PCC_DEBUG\r\nint map_changed = 0;\r\n#endif\r\nspin_lock_irqsave(&pcc_lock, flags);\r\nneed_ex = (size > 1 && flag == 0) ? PCMOD_DBEX : 0;\r\n#ifdef PCC_DEBUG_DBEX\r\n_dbex = need_ex;\r\nneed_ex = 0;\r\n#endif\r\naddr = t->mapaddr + port - t->ioaddr + KSEG1;\r\nif (t->current_space != as_io || t->last_iodbex != need_ex) {\r\nu_long cbsz;\r\npcc_set(sock, PCCR, 0);\r\ncbsz = (t->flags & MAP_16BIT) ? 0 : PCMOD_CBSZ;\r\npcc_set(sock, PCMOD, PCMOD_AS_IO | cbsz | need_ex);\r\npcc_set(sock, PCADR, addr & 0x1ff00000);\r\npcc_set(sock, PCCR, 1);\r\n#ifdef CHAOS_PCC_DEBUG\r\n#if 0\r\nmap_changed = (t->current_space == as_attr && size == 2);\r\n#else\r\nmap_changed = 1;\r\n#endif\r\n#endif\r\nt->current_space = as_io;\r\n}\r\nif (size == 1) {\r\nunsigned char *bp = (unsigned char *)buf;\r\n#ifdef CHAOS_DEBUG\r\nif (map_changed) {\r\ndummy_readbuf = readb(addr);\r\n}\r\n#endif\r\nif (wr) {\r\nwhile (nmemb--) {\r\nwriteb(*bp++, addr);\r\n}\r\n} else {\r\nwhile (nmemb--) {\r\n*bp++ = readb(addr);\r\n}\r\n}\r\n} else {\r\nunsigned short *bp = (unsigned short *)buf;\r\n#ifdef CHAOS_PCC_DEBUG\r\nif (map_changed) {\r\ndummy_readbuf = readw(addr);\r\n}\r\n#endif\r\nif (wr) {\r\nwhile (nmemb--) {\r\n#ifdef PCC_DEBUG_DBEX\r\nif (_dbex) {\r\nunsigned char *cp = (unsigned char *)bp;\r\nunsigned short tmp;\r\ntmp = cp[1] << 8 | cp[0];\r\nwritew(tmp, addr);\r\nbp++;\r\n} else\r\n#endif\r\nwritew(*bp++, addr);\r\n}\r\n} else {\r\nwhile (nmemb--) {\r\n#ifdef PCC_DEBUG_DBEX\r\nif (_dbex) {\r\nunsigned char *cp = (unsigned char *)bp;\r\nunsigned short tmp;\r\ntmp = readw(addr);\r\ncp[0] = tmp & 0xff;\r\ncp[1] = (tmp >> 8) & 0xff;\r\nbp++;\r\n} else\r\n#endif\r\n*bp++ = readw(addr);\r\n}\r\n}\r\n}\r\n#if 1\r\nif ((addr = pcc_get(sock, PCIRC)) & PCIRC_BWERR) {\r\nprintk("m32r_pcc: BWERR detected : port 0x%04lx : iosize %dbit\n",\r\nport, size * 8);\r\npcc_set(sock, PCIRC, addr);\r\n}\r\n#endif\r\nt->last_iosize = size;\r\nt->last_iodbex = need_ex;\r\nspin_unlock_irqrestore(&pcc_lock,flags);\r\nreturn;\r\n}\r\nvoid pcc_ioread(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {\r\npcc_iorw(sock, port, buf, size, nmemb, 0, flag);\r\n}\r\nvoid pcc_iowrite(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {\r\npcc_iorw(sock, port, buf, size, nmemb, 1, flag);\r\n}\r\nstatic unsigned int pcc_get(u_short sock, unsigned int reg)\r\n{\r\nreturn inl(socket[sock].base + reg);\r\n}\r\nstatic void pcc_set(u_short sock, unsigned int reg, unsigned int data)\r\n{\r\noutl(data, socket[sock].base + reg);\r\n}\r\nstatic int __init is_alive(u_short sock)\r\n{\r\nunsigned int stat;\r\nunsigned int f;\r\nstat = pcc_get(sock, PCIRC);\r\nf = (stat & (PCIRC_CDIN1 | PCIRC_CDIN2)) >> 16;\r\nif(!f){\r\nprintk("m32r_pcc: No Card is detected at socket %d : stat = 0x%08x\n",stat,sock);\r\nreturn 0;\r\n}\r\nif(f!=3)\r\nprintk("m32r_pcc: Insertion fail (%.8x) at socket %d\n",stat,sock);\r\nelse\r\nprintk("m32r_pcc: Card is Inserted at socket %d(%.8x)\n",sock,stat);\r\nreturn 0;\r\n}\r\nstatic int add_pcc_socket(ulong base, int irq, ulong mapaddr,\r\nunsigned int ioaddr)\r\n{\r\npcc_socket_t *t = &socket[pcc_sockets];\r\nint err;\r\nt->ioaddr = ioaddr;\r\nt->mapaddr = mapaddr;\r\nt->base = base;\r\n#ifdef CHAOS_PCC_DEBUG\r\nt->flags = MAP_16BIT;\r\n#else\r\nt->flags = 0;\r\n#endif\r\nif (is_alive(pcc_sockets))\r\nt->flags |= IS_ALIVE;\r\nif (t->base > 0) {\r\nrequest_region(t->base, 0x20, "m32r-pcc");\r\n}\r\nprintk(KERN_INFO " %s ", pcc[pcc_sockets].name);\r\nprintk("pcc at 0x%08lx\n", t->base);\r\nt->socket.features |= (SS_CAP_PCCARD | SS_CAP_STATIC_MAP);\r\nt->socket.map_size = M32R_PCC_MAPSIZE;\r\nt->socket.io_offset = ioaddr;\r\nt->socket.irq_mask = 0;\r\nt->socket.pci_irq = 2 + pcc_sockets;\r\nerr = request_irq(irq, pcc_interrupt, 0, "m32r-pcc", pcc_interrupt);\r\nif (err) {\r\nif (t->base > 0)\r\nrelease_region(t->base, 0x20);\r\nreturn err;\r\n}\r\npcc_sockets++;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pcc_interrupt(int irq, void *dev)\r\n{\r\nint i, j, irc;\r\nu_int events, active;\r\nint handled = 0;\r\npr_debug("m32r_pcc: pcc_interrupt(%d)\n", irq);\r\nfor (j = 0; j < 20; j++) {\r\nactive = 0;\r\nfor (i = 0; i < pcc_sockets; i++) {\r\nif ((socket[i].cs_irq != irq) &&\r\n(socket[i].socket.pci_irq != irq))\r\ncontinue;\r\nhandled = 1;\r\nirc = pcc_get(i, PCIRC);\r\nirc >>=16;\r\npr_debug("m32r_pcc: interrupt: socket %d pcirc 0x%02x ",\r\ni, irc);\r\nif (!irc)\r\ncontinue;\r\nevents = (irc) ? SS_DETECT : 0;\r\nevents |= (pcc_get(i,PCCR) & PCCR_PCEN) ? SS_READY : 0;\r\npr_debug("m32r_pcc: event 0x%02x\n", events);\r\nif (events)\r\npcmcia_parse_events(&socket[i].socket, events);\r\nactive |= events;\r\nactive = 0;\r\n}\r\nif (!active) break;\r\n}\r\nif (j == 20)\r\nprintk(KERN_NOTICE "m32r-pcc: infinite loop in interrupt handler\n");\r\npr_debug("m32r_pcc: interrupt done\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pcc_interrupt_wrapper(u_long data)\r\n{\r\npcc_interrupt(0, NULL);\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nstatic int _pcc_get_status(u_short sock, u_int *value)\r\n{\r\nu_int status;\r\nstatus = pcc_get(sock,PCIRC);\r\n*value = ((status & PCIRC_CDIN1) && (status & PCIRC_CDIN2))\r\n? SS_DETECT : 0;\r\nstatus = pcc_get(sock,PCCR);\r\n#if 0\r\n*value |= (status & PCCR_PCEN) ? SS_READY : 0;\r\n#else\r\n*value |= SS_READY;\r\n#endif\r\nstatus = pcc_get(sock,PCCSIGCR);\r\n*value |= (status & PCCSIGCR_VEN) ? SS_POWERON : 0;\r\npr_debug("m32r_pcc: GetStatus(%d) = %#4.4x\n", sock, *value);\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_socket(u_short sock, socket_state_t *state)\r\n{\r\nu_long reg = 0;\r\npr_debug("m32r_pcc: SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "\r\n"io_irq %d, csc_mask %#2.2x)", sock, state->flags,\r\nstate->Vcc, state->Vpp, state->io_irq, state->csc_mask);\r\nif (state->Vcc) {\r\nif (state->Vcc == 50) {\r\nreg |= PCCSIGCR_VEN;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (state->flags & SS_RESET) {\r\npr_debug("m32r_pcc: :RESET\n");\r\nreg |= PCCSIGCR_CRST;\r\n}\r\nif (state->flags & SS_OUTPUT_ENA){\r\npr_debug("m32r_pcc: :OUTPUT_ENA\n");\r\n} else {\r\nreg |= PCCSIGCR_SEN;\r\n}\r\npcc_set(sock,PCCSIGCR,reg);\r\nif(state->flags & SS_IOCARD){\r\npr_debug("m32r_pcc: :IOCARD");\r\n}\r\nif (state->flags & SS_PWR_AUTO) {\r\npr_debug("m32r_pcc: :PWR_AUTO");\r\n}\r\nif (state->csc_mask & SS_DETECT)\r\npr_debug("m32r_pcc: :csc-SS_DETECT");\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\npr_debug("m32r_pcc: :STSCHG");\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\npr_debug("m32r_pcc: :BATDEAD");\r\nif (state->csc_mask & SS_BATWARN)\r\npr_debug("m32r_pcc: :BATWARN");\r\nif (state->csc_mask & SS_READY)\r\npr_debug("m32r_pcc: :READY");\r\n}\r\npr_debug("m32r_pcc: \n");\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_io_map(u_short sock, struct pccard_io_map *io)\r\n{\r\nu_char map;\r\npr_debug("m32r_pcc: SetIOMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx-%#llx)\n", sock, io->map, io->flags,\r\nio->speed, (unsigned long long)io->start,\r\n(unsigned long long)io->stop);\r\nmap = io->map;\r\nreturn 0;\r\n}\r\nstatic int _pcc_set_mem_map(u_short sock, struct pccard_mem_map *mem)\r\n{\r\nu_char map = mem->map;\r\nu_long mode;\r\nu_long addr;\r\npcc_socket_t *t = &socket[sock];\r\n#ifdef CHAOS_PCC_DEBUG\r\n#if 0\r\npcc_as_t last = t->current_space;\r\n#endif\r\n#endif\r\npr_debug("m32r_pcc: SetMemMap(%d, %d, %#2.2x, %d ns, "\r\n"%#llx, %#x)\n", sock, map, mem->flags,\r\nmem->speed, (unsigned long long)mem->static_start,\r\nmem->card_start);\r\nif ((map > MAX_WIN) || (mem->card_start > 0x3ffffff)){\r\nreturn -EINVAL;\r\n}\r\nif ((mem->flags & MAP_ACTIVE) == 0) {\r\nt->current_space = as_none;\r\nreturn 0;\r\n}\r\npcc_set(sock, PCCR, 0);\r\nif (mem->flags & MAP_ATTRIB) {\r\nmode = PCMOD_AS_ATTRIB | PCMOD_CBSZ;\r\nt->current_space = as_attr;\r\n} else {\r\nmode = 0;\r\nt->current_space = as_comm;\r\n}\r\npcc_set(sock, PCMOD, mode);\r\naddr = t->mapaddr + (mem->card_start & M32R_PCC_MAPMASK);\r\npcc_set(sock, PCADR, addr);\r\nmem->static_start = addr + mem->card_start;\r\npcc_set(sock, PCCR, 1);\r\n#ifdef CHAOS_PCC_DEBUG\r\n#if 0\r\nif (last != as_attr) {\r\n#else\r\nif (1) {\r\n#endif\r\ndummy_readbuf = *(u_char *)(addr + KSEG1);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pcc_get_status(struct pcmcia_socket *s, u_int *value)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE) {\r\n*value = 0;\r\nreturn -EINVAL;\r\n}\r\nLOCKED(_pcc_get_status(sock, value));\r\n}\r\nstatic int pcc_set_socket(struct pcmcia_socket *s, socket_state_t *state)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(_pcc_set_socket(sock, state));\r\n}\r\nstatic int pcc_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(_pcc_set_io_map(sock, io));\r\n}\r\nstatic int pcc_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)\r\n{\r\nunsigned int sock = container_of(s, struct pcc_socket, socket)->number;\r\nif (socket[sock].flags & IS_ALIVE)\r\nreturn -EINVAL;\r\nLOCKED(_pcc_set_mem_map(sock, mem));\r\n}\r\nstatic int pcc_init(struct pcmcia_socket *s)\r\n{\r\npr_debug("m32r_pcc: init call\n");\r\nreturn 0;\r\n}\r\nstatic int __init init_m32r_pcc(void)\r\n{\r\nint i, ret;\r\nret = platform_driver_register(&pcc_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_device_register(&pcc_device);\r\nif (ret)\r\ngoto unreg_driv;\r\nprintk(KERN_INFO "m32r PCC probe:\n");\r\npcc_sockets = 0;\r\nret = add_pcc_socket(M32R_PCC0_BASE, PCC0_IRQ, M32R_PCC0_MAPBASE,\r\n0x1000);\r\nif (ret)\r\ngoto unreg_dev;\r\n#ifdef CONFIG_M32RPCC_SLOT2\r\nret = add_pcc_socket(M32R_PCC1_BASE, PCC1_IRQ, M32R_PCC1_MAPBASE,\r\n0x2000);\r\nif (ret)\r\ngoto unreg_dev;\r\n#endif\r\nif (pcc_sockets == 0) {\r\nprintk("socket is not found.\n");\r\nret = -ENODEV;\r\ngoto unreg_dev;\r\n}\r\nfor (i = 0 ; i < pcc_sockets ; i++) {\r\nsocket[i].socket.dev.parent = &pcc_device.dev;\r\nsocket[i].socket.ops = &pcc_operations;\r\nsocket[i].socket.resource_ops = &pccard_static_ops;\r\nsocket[i].socket.owner = THIS_MODULE;\r\nsocket[i].number = i;\r\nret = pcmcia_register_socket(&socket[i].socket);\r\nif (!ret)\r\nsocket[i].flags |= IS_REGISTERED;\r\n}\r\nif (poll_interval != 0) {\r\npoll_timer.function = pcc_interrupt_wrapper;\r\npoll_timer.data = 0;\r\ninit_timer(&poll_timer);\r\npoll_timer.expires = jiffies + poll_interval;\r\nadd_timer(&poll_timer);\r\n}\r\nreturn 0;\r\nunreg_dev:\r\nplatform_device_unregister(&pcc_device);\r\nunreg_driv:\r\nplatform_driver_unregister(&pcc_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit exit_m32r_pcc(void)\r\n{\r\nint i;\r\nfor (i = 0; i < pcc_sockets; i++)\r\nif (socket[i].flags & IS_REGISTERED)\r\npcmcia_unregister_socket(&socket[i].socket);\r\nplatform_device_unregister(&pcc_device);\r\nif (poll_interval != 0)\r\ndel_timer_sync(&poll_timer);\r\nplatform_driver_unregister(&pcc_driver);\r\n}
