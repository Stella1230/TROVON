static __always_inline void count_tx(u32 protocol)\r\n{\r\nu64 *rxcnt_count;\r\nrxcnt_count = bpf_map_lookup_elem(&rxcnt, &protocol);\r\nif (rxcnt_count)\r\n*rxcnt_count += 1;\r\n}\r\nstatic __always_inline int get_dport(void *trans_data, void *data_end,\r\nu8 protocol)\r\n{\r\nstruct tcphdr *th;\r\nstruct udphdr *uh;\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nth = (struct tcphdr *)trans_data;\r\nif (th + 1 > data_end)\r\nreturn -1;\r\nreturn th->dest;\r\ncase IPPROTO_UDP:\r\nuh = (struct udphdr *)trans_data;\r\nif (uh + 1 > data_end)\r\nreturn -1;\r\nreturn uh->dest;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic __always_inline void set_ethhdr(struct ethhdr *new_eth,\r\nconst struct ethhdr *old_eth,\r\nconst struct iptnl_info *tnl,\r\n__be16 h_proto)\r\n{\r\nmemcpy(new_eth->h_source, old_eth->h_dest, sizeof(new_eth->h_source));\r\nmemcpy(new_eth->h_dest, tnl->dmac, sizeof(new_eth->h_dest));\r\nnew_eth->h_proto = h_proto;\r\n}\r\nstatic __always_inline int handle_ipv4(struct xdp_md *xdp)\r\n{\r\nvoid *data_end = (void *)(long)xdp->data_end;\r\nvoid *data = (void *)(long)xdp->data;\r\nstruct iptnl_info *tnl;\r\nstruct ethhdr *new_eth;\r\nstruct ethhdr *old_eth;\r\nstruct iphdr *iph = data + sizeof(struct ethhdr);\r\nu16 *next_iph_u16;\r\nu16 payload_len;\r\nstruct vip vip = {};\r\nint dport;\r\nu32 csum = 0;\r\nint i;\r\nif (iph + 1 > data_end)\r\nreturn XDP_DROP;\r\ndport = get_dport(iph + 1, data_end, iph->protocol);\r\nif (dport == -1)\r\nreturn XDP_DROP;\r\nvip.protocol = iph->protocol;\r\nvip.family = AF_INET;\r\nvip.daddr.v4 = iph->daddr;\r\nvip.dport = dport;\r\npayload_len = ntohs(iph->tot_len);\r\ntnl = bpf_map_lookup_elem(&vip2tnl, &vip);\r\nif (!tnl || tnl->family != AF_INET)\r\nreturn XDP_PASS;\r\nif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct iphdr)))\r\nreturn XDP_DROP;\r\ndata = (void *)(long)xdp->data;\r\ndata_end = (void *)(long)xdp->data_end;\r\nnew_eth = data;\r\niph = data + sizeof(*new_eth);\r\nold_eth = data + sizeof(*iph);\r\nif (new_eth + 1 > data_end ||\r\nold_eth + 1 > data_end ||\r\niph + 1 > data_end)\r\nreturn XDP_DROP;\r\nset_ethhdr(new_eth, old_eth, tnl, htons(ETH_P_IP));\r\niph->version = 4;\r\niph->ihl = sizeof(*iph) >> 2;\r\niph->frag_off = 0;\r\niph->protocol = IPPROTO_IPIP;\r\niph->check = 0;\r\niph->tos = 0;\r\niph->tot_len = htons(payload_len + sizeof(*iph));\r\niph->daddr = tnl->daddr.v4;\r\niph->saddr = tnl->saddr.v4;\r\niph->ttl = 8;\r\nnext_iph_u16 = (u16 *)iph;\r\n#pragma clang loop unroll(full)\r\nfor (i = 0; i < sizeof(*iph) >> 1; i++)\r\ncsum += *next_iph_u16++;\r\niph->check = ~((csum & 0xffff) + (csum >> 16));\r\ncount_tx(vip.protocol);\r\nreturn XDP_TX;\r\n}\r\nstatic __always_inline int handle_ipv6(struct xdp_md *xdp)\r\n{\r\nvoid *data_end = (void *)(long)xdp->data_end;\r\nvoid *data = (void *)(long)xdp->data;\r\nstruct iptnl_info *tnl;\r\nstruct ethhdr *new_eth;\r\nstruct ethhdr *old_eth;\r\nstruct ipv6hdr *ip6h = data + sizeof(struct ethhdr);\r\n__u16 payload_len;\r\nstruct vip vip = {};\r\nint dport;\r\nif (ip6h + 1 > data_end)\r\nreturn XDP_DROP;\r\ndport = get_dport(ip6h + 1, data_end, ip6h->nexthdr);\r\nif (dport == -1)\r\nreturn XDP_DROP;\r\nvip.protocol = ip6h->nexthdr;\r\nvip.family = AF_INET6;\r\nmemcpy(vip.daddr.v6, ip6h->daddr.s6_addr32, sizeof(vip.daddr));\r\nvip.dport = dport;\r\npayload_len = ip6h->payload_len;\r\ntnl = bpf_map_lookup_elem(&vip2tnl, &vip);\r\nif (!tnl || tnl->family != AF_INET6)\r\nreturn XDP_PASS;\r\nif (bpf_xdp_adjust_head(xdp, 0 - (int)sizeof(struct ipv6hdr)))\r\nreturn XDP_DROP;\r\ndata = (void *)(long)xdp->data;\r\ndata_end = (void *)(long)xdp->data_end;\r\nnew_eth = data;\r\nip6h = data + sizeof(*new_eth);\r\nold_eth = data + sizeof(*ip6h);\r\nif (new_eth + 1 > data_end ||\r\nold_eth + 1 > data_end ||\r\nip6h + 1 > data_end)\r\nreturn XDP_DROP;\r\nset_ethhdr(new_eth, old_eth, tnl, htons(ETH_P_IPV6));\r\nip6h->version = 6;\r\nip6h->priority = 0;\r\nmemset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\r\nip6h->payload_len = htons(ntohs(payload_len) + sizeof(*ip6h));\r\nip6h->nexthdr = IPPROTO_IPV6;\r\nip6h->hop_limit = 8;\r\nmemcpy(ip6h->saddr.s6_addr32, tnl->saddr.v6, sizeof(tnl->saddr.v6));\r\nmemcpy(ip6h->daddr.s6_addr32, tnl->daddr.v6, sizeof(tnl->daddr.v6));\r\ncount_tx(vip.protocol);\r\nreturn XDP_TX;\r\n}\r\nint _xdp_tx_iptunnel(struct xdp_md *xdp)\r\n{\r\nvoid *data_end = (void *)(long)xdp->data_end;\r\nvoid *data = (void *)(long)xdp->data;\r\nstruct ethhdr *eth = data;\r\n__u16 h_proto;\r\nif (eth + 1 > data_end)\r\nreturn XDP_DROP;\r\nh_proto = eth->h_proto;\r\nif (h_proto == htons(ETH_P_IP))\r\nreturn handle_ipv4(xdp);\r\nelse if (h_proto == htons(ETH_P_IPV6))\r\nreturn handle_ipv6(xdp);\r\nelse\r\nreturn XDP_PASS;\r\n}
