static ssize_t mlxcpld_hotplug_attr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mlxcpld_hotplug_priv_data *priv = platform_get_drvdata(pdev);\r\nint index = to_sensor_dev_attr_2(attr)->index;\r\nint nr = to_sensor_dev_attr_2(attr)->nr;\r\nu8 reg_val = 0;\r\nswitch (nr) {\r\ncase MLXCPLD_HOTPLUG_ATTR_TYPE_PSU:\r\nreg_val = !!!(inb(priv->plat->psu_reg_offset) & BIT(index));\r\nbreak;\r\ncase MLXCPLD_HOTPLUG_ATTR_TYPE_PWR:\r\nreg_val = !!(inb(priv->plat->pwr_reg_offset) & BIT(index %\r\npriv->plat->pwr_count));\r\nbreak;\r\ncase MLXCPLD_HOTPLUG_ATTR_TYPE_FAN:\r\nreg_val = !!!(inb(priv->plat->fan_reg_offset) & BIT(index %\r\npriv->plat->fan_count));\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", reg_val);\r\n}\r\nstatic int mlxcpld_hotplug_attr_init(struct mlxcpld_hotplug_priv_data *priv)\r\n{\r\nint num_attrs = priv->plat->psu_count + priv->plat->pwr_count +\r\npriv->plat->fan_count;\r\nint i;\r\npriv->group.attrs = devm_kzalloc(&priv->pdev->dev, num_attrs *\r\nsizeof(struct attribute *),\r\nGFP_KERNEL);\r\nif (!priv->group.attrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_attrs; i++) {\r\nPRIV_ATTR(i) = &PRIV_DEV_ATTR(i).dev_attr.attr;\r\nif (i < priv->plat->psu_count) {\r\nPRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,\r\nGFP_KERNEL, "psu%u", i + 1);\r\nPRIV_DEV_ATTR(i).nr = MLXCPLD_HOTPLUG_ATTR_TYPE_PSU;\r\n} else if (i < priv->plat->psu_count + priv->plat->pwr_count) {\r\nPRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,\r\nGFP_KERNEL, "pwr%u", i %\r\npriv->plat->pwr_count + 1);\r\nPRIV_DEV_ATTR(i).nr = MLXCPLD_HOTPLUG_ATTR_TYPE_PWR;\r\n} else {\r\nPRIV_ATTR(i)->name = devm_kasprintf(&priv->pdev->dev,\r\nGFP_KERNEL, "fan%u", i %\r\npriv->plat->fan_count + 1);\r\nPRIV_DEV_ATTR(i).nr = MLXCPLD_HOTPLUG_ATTR_TYPE_FAN;\r\n}\r\nif (!PRIV_ATTR(i)->name) {\r\ndev_err(&priv->pdev->dev, "Memory allocation failed for sysfs attribute %d.\n",\r\ni + 1);\r\nreturn -ENOMEM;\r\n}\r\nPRIV_DEV_ATTR(i).dev_attr.attr.name = PRIV_ATTR(i)->name;\r\nPRIV_DEV_ATTR(i).dev_attr.attr.mode = S_IRUGO;\r\nPRIV_DEV_ATTR(i).dev_attr.show = mlxcpld_hotplug_attr_show;\r\nPRIV_DEV_ATTR(i).index = i;\r\nsysfs_attr_init(&PRIV_DEV_ATTR(i).dev_attr.attr);\r\n}\r\npriv->group.attrs = priv->mlxcpld_hotplug_attr;\r\npriv->groups[0] = &priv->group;\r\npriv->groups[1] = NULL;\r\nreturn 0;\r\n}\r\nstatic int mlxcpld_hotplug_device_create(struct device *dev,\r\nstruct mlxcpld_hotplug_device *item)\r\n{\r\nitem->adapter = i2c_get_adapter(item->bus);\r\nif (!item->adapter) {\r\ndev_err(dev, "Failed to get adapter for bus %d\n",\r\nitem->bus);\r\nreturn -EFAULT;\r\n}\r\nitem->client = i2c_new_device(item->adapter, &item->brdinfo);\r\nif (!item->client) {\r\ndev_err(dev, "Failed to create client %s at bus %d at addr 0x%02x\n",\r\nitem->brdinfo.type, item->bus, item->brdinfo.addr);\r\ni2c_put_adapter(item->adapter);\r\nitem->adapter = NULL;\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mlxcpld_hotplug_device_destroy(struct mlxcpld_hotplug_device *item)\r\n{\r\nif (item->client) {\r\ni2c_unregister_device(item->client);\r\nitem->client = NULL;\r\n}\r\nif (item->adapter) {\r\ni2c_put_adapter(item->adapter);\r\nitem->adapter = NULL;\r\n}\r\n}\r\nstatic inline void\r\nmlxcpld_hotplug_work_helper(struct device *dev,\r\nstruct mlxcpld_hotplug_device *item, u8 is_inverse,\r\nu16 offset, u8 mask, u8 *cache)\r\n{\r\nu8 val, asserted;\r\nint bit;\r\noutb(0, offset + MLXCPLD_HOTPLUG_MASK_OFF);\r\nval = inb(offset) & mask;\r\nasserted = *cache ^ val;\r\n*cache = val;\r\nif (unlikely(!item)) {\r\ndev_err(dev, "False signal is received: register at offset 0x%02x, mask 0x%02x.\n",\r\noffset, mask);\r\nreturn;\r\n}\r\nfor_each_set_bit(bit, (unsigned long *)&asserted, 8) {\r\nif (val & BIT(bit)) {\r\nif (is_inverse)\r\nmlxcpld_hotplug_device_destroy(item + bit);\r\nelse\r\nmlxcpld_hotplug_device_create(dev, item + bit);\r\n} else {\r\nif (is_inverse)\r\nmlxcpld_hotplug_device_create(dev, item + bit);\r\nelse\r\nmlxcpld_hotplug_device_destroy(item + bit);\r\n}\r\n}\r\noutb(0, offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\noutb(mask, offset + MLXCPLD_HOTPLUG_MASK_OFF);\r\n}\r\nstatic void mlxcpld_hotplug_work_handler(struct work_struct *work)\r\n{\r\nstruct mlxcpld_hotplug_priv_data *priv = container_of(work,\r\nstruct mlxcpld_hotplug_priv_data, dwork.work);\r\nu8 val, aggr_asserted;\r\nunsigned long flags;\r\noutb(0, priv->plat->top_aggr_offset + MLXCPLD_HOTPLUG_AGGR_MASK_OFF);\r\nval = inb(priv->plat->top_aggr_offset) & priv->plat->top_aggr_mask;\r\naggr_asserted = priv->aggr_cache ^ val;\r\npriv->aggr_cache = val;\r\nif (aggr_asserted & priv->plat->top_aggr_psu_mask)\r\nmlxcpld_hotplug_work_helper(&priv->pdev->dev, priv->plat->psu,\r\n1, priv->plat->psu_reg_offset,\r\npriv->plat->psu_mask,\r\n&priv->psu_cache);\r\nif (aggr_asserted & priv->plat->top_aggr_pwr_mask)\r\nmlxcpld_hotplug_work_helper(&priv->pdev->dev, priv->plat->pwr,\r\n0, priv->plat->pwr_reg_offset,\r\npriv->plat->pwr_mask,\r\n&priv->pwr_cache);\r\nif (aggr_asserted & priv->plat->top_aggr_fan_mask)\r\nmlxcpld_hotplug_work_helper(&priv->pdev->dev, priv->plat->fan,\r\n1, priv->plat->fan_reg_offset,\r\npriv->plat->fan_mask,\r\n&priv->fan_cache);\r\nif (aggr_asserted) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncancel_delayed_work(&priv->dwork);\r\nschedule_delayed_work(&priv->dwork, 0);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\noutb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +\r\nMLXCPLD_HOTPLUG_AGGR_MASK_OFF);\r\n}\r\nstatic void mlxcpld_hotplug_set_irq(struct mlxcpld_hotplug_priv_data *priv)\r\n{\r\noutb(0, priv->plat->psu_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\npriv->psu_cache = priv->plat->psu_mask;\r\noutb(priv->plat->psu_mask, priv->plat->psu_reg_offset +\r\nMLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(0, priv->plat->pwr_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\noutb(priv->plat->pwr_mask, priv->plat->pwr_reg_offset +\r\nMLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(0, priv->plat->fan_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\npriv->fan_cache = priv->plat->fan_mask;\r\noutb(priv->plat->fan_mask, priv->plat->fan_reg_offset +\r\nMLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(priv->plat->top_aggr_mask, priv->plat->top_aggr_offset +\r\nMLXCPLD_HOTPLUG_AGGR_MASK_OFF);\r\nmlxcpld_hotplug_work_handler(&priv->dwork.work);\r\nenable_irq(priv->irq);\r\n}\r\nstatic void mlxcpld_hotplug_unset_irq(struct mlxcpld_hotplug_priv_data *priv)\r\n{\r\nint i;\r\ndisable_irq(priv->irq);\r\ncancel_delayed_work_sync(&priv->dwork);\r\noutb(0, priv->plat->top_aggr_offset + MLXCPLD_HOTPLUG_AGGR_MASK_OFF);\r\noutb(0, priv->plat->psu_reg_offset + MLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(0, priv->plat->psu_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\noutb(0, priv->plat->pwr_reg_offset + MLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(0, priv->plat->pwr_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\noutb(0, priv->plat->fan_reg_offset + MLXCPLD_HOTPLUG_MASK_OFF);\r\noutb(0, priv->plat->fan_reg_offset + MLXCPLD_HOTPLUG_EVENT_OFF);\r\nfor (i = 0; i < priv->plat->psu_count; i++)\r\nmlxcpld_hotplug_device_destroy(priv->plat->psu + i);\r\nfor (i = 0; i < priv->plat->pwr_count; i++)\r\nmlxcpld_hotplug_device_destroy(priv->plat->pwr + i);\r\nfor (i = 0; i < priv->plat->fan_count; i++)\r\nmlxcpld_hotplug_device_destroy(priv->plat->fan + i);\r\n}\r\nstatic irqreturn_t mlxcpld_hotplug_irq_handler(int irq, void *dev)\r\n{\r\nstruct mlxcpld_hotplug_priv_data *priv =\r\n(struct mlxcpld_hotplug_priv_data *)dev;\r\nschedule_delayed_work(&priv->dwork, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mlxcpld_hotplug_probe(struct platform_device *pdev)\r\n{\r\nstruct mlxcpld_hotplug_platform_data *pdata;\r\nstruct mlxcpld_hotplug_priv_data *priv;\r\nint err;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Failed to get platform data.\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->pdev = pdev;\r\npriv->plat = pdata;\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get platform irq: %d\n",\r\npriv->irq);\r\nreturn priv->irq;\r\n}\r\nerr = devm_request_irq(&pdev->dev, priv->irq,\r\nmlxcpld_hotplug_irq_handler, 0, pdev->name,\r\npriv);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", err);\r\nreturn err;\r\n}\r\ndisable_irq(priv->irq);\r\nINIT_DELAYED_WORK(&priv->dwork, mlxcpld_hotplug_work_handler);\r\nspin_lock_init(&priv->lock);\r\nerr = mlxcpld_hotplug_attr_init(priv);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to allocate attributes: %d\n", err);\r\nreturn err;\r\n}\r\npriv->hwmon = devm_hwmon_device_register_with_groups(&pdev->dev,\r\n"mlxcpld_hotplug", priv, priv->groups);\r\nif (IS_ERR(priv->hwmon)) {\r\ndev_err(&pdev->dev, "Failed to register hwmon device %ld\n",\r\nPTR_ERR(priv->hwmon));\r\nreturn PTR_ERR(priv->hwmon);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nmlxcpld_hotplug_set_irq(priv);\r\nreturn 0;\r\n}\r\nstatic int mlxcpld_hotplug_remove(struct platform_device *pdev)\r\n{\r\nstruct mlxcpld_hotplug_priv_data *priv = platform_get_drvdata(pdev);\r\nmlxcpld_hotplug_unset_irq(priv);\r\nreturn 0;\r\n}
