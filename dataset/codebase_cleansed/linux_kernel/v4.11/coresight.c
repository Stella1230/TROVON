static int coresight_id_match(struct device *dev, void *data)\r\n{\r\nint trace_id, i_trace_id;\r\nstruct coresight_device *csdev, *i_csdev;\r\ncsdev = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (i_csdev == csdev || !i_csdev->enable ||\r\ni_csdev->type != CORESIGHT_DEV_TYPE_SOURCE)\r\nreturn 0;\r\ntrace_id = source_ops(csdev)->trace_id(csdev);\r\ni_trace_id = source_ops(i_csdev)->trace_id(i_csdev);\r\nif (trace_id == i_trace_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int coresight_source_is_unique(struct coresight_device *csdev)\r\n{\r\nint trace_id = source_ops(csdev)->trace_id(csdev);\r\nif (trace_id < 0)\r\nreturn 0;\r\nreturn !bus_for_each_dev(&coresight_bustype, NULL,\r\ncsdev, coresight_id_match);\r\n}\r\nstatic int coresight_find_link_inport(struct coresight_device *csdev,\r\nstruct coresight_device *parent)\r\n{\r\nint i;\r\nstruct coresight_connection *conn;\r\nfor (i = 0; i < parent->nr_outport; i++) {\r\nconn = &parent->conns[i];\r\nif (conn->child_dev == csdev)\r\nreturn conn->child_port;\r\n}\r\ndev_err(&csdev->dev, "couldn't find inport, parent: %s, child: %s\n",\r\ndev_name(&parent->dev), dev_name(&csdev->dev));\r\nreturn 0;\r\n}\r\nstatic int coresight_find_link_outport(struct coresight_device *csdev,\r\nstruct coresight_device *child)\r\n{\r\nint i;\r\nstruct coresight_connection *conn;\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconn = &csdev->conns[i];\r\nif (conn->child_dev == child)\r\nreturn conn->outport;\r\n}\r\ndev_err(&csdev->dev, "couldn't find outport, parent: %s, child: %s\n",\r\ndev_name(&csdev->dev), dev_name(&child->dev));\r\nreturn 0;\r\n}\r\nstatic int coresight_enable_sink(struct coresight_device *csdev, u32 mode)\r\n{\r\nint ret;\r\nif (!csdev->enable) {\r\nif (sink_ops(csdev)->enable) {\r\nret = sink_ops(csdev)->enable(csdev, mode);\r\nif (ret)\r\nreturn ret;\r\n}\r\ncsdev->enable = true;\r\n}\r\natomic_inc(csdev->refcnt);\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_sink(struct coresight_device *csdev)\r\n{\r\nif (atomic_dec_return(csdev->refcnt) == 0) {\r\nif (sink_ops(csdev)->disable) {\r\nsink_ops(csdev)->disable(csdev);\r\ncsdev->enable = false;\r\n}\r\n}\r\n}\r\nstatic int coresight_enable_link(struct coresight_device *csdev,\r\nstruct coresight_device *parent,\r\nstruct coresight_device *child)\r\n{\r\nint ret;\r\nint link_subtype;\r\nint refport, inport, outport;\r\nif (!parent || !child)\r\nreturn -EINVAL;\r\ninport = coresight_find_link_inport(csdev, parent);\r\noutport = coresight_find_link_outport(csdev, child);\r\nlink_subtype = csdev->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG)\r\nrefport = inport;\r\nelse if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT)\r\nrefport = outport;\r\nelse\r\nrefport = 0;\r\nif (atomic_inc_return(&csdev->refcnt[refport]) == 1) {\r\nif (link_ops(csdev)->enable) {\r\nret = link_ops(csdev)->enable(csdev, inport, outport);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\ncsdev->enable = true;\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_link(struct coresight_device *csdev,\r\nstruct coresight_device *parent,\r\nstruct coresight_device *child)\r\n{\r\nint i, nr_conns;\r\nint link_subtype;\r\nint refport, inport, outport;\r\nif (!parent || !child)\r\nreturn;\r\ninport = coresight_find_link_inport(csdev, parent);\r\noutport = coresight_find_link_outport(csdev, child);\r\nlink_subtype = csdev->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG) {\r\nrefport = inport;\r\nnr_conns = csdev->nr_inport;\r\n} else if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT) {\r\nrefport = outport;\r\nnr_conns = csdev->nr_outport;\r\n} else {\r\nrefport = 0;\r\nnr_conns = 1;\r\n}\r\nif (atomic_dec_return(&csdev->refcnt[refport]) == 0) {\r\nif (link_ops(csdev)->disable)\r\nlink_ops(csdev)->disable(csdev, inport, outport);\r\n}\r\nfor (i = 0; i < nr_conns; i++)\r\nif (atomic_read(&csdev->refcnt[i]) != 0)\r\nreturn;\r\ncsdev->enable = false;\r\n}\r\nstatic int coresight_enable_source(struct coresight_device *csdev, u32 mode)\r\n{\r\nint ret;\r\nif (!coresight_source_is_unique(csdev)) {\r\ndev_warn(&csdev->dev, "traceID %d not unique\n",\r\nsource_ops(csdev)->trace_id(csdev));\r\nreturn -EINVAL;\r\n}\r\nif (!csdev->enable) {\r\nif (source_ops(csdev)->enable) {\r\nret = source_ops(csdev)->enable(csdev, NULL, mode);\r\nif (ret)\r\nreturn ret;\r\n}\r\ncsdev->enable = true;\r\n}\r\natomic_inc(csdev->refcnt);\r\nreturn 0;\r\n}\r\nstatic void coresight_disable_source(struct coresight_device *csdev)\r\n{\r\nif (atomic_dec_return(csdev->refcnt) == 0) {\r\nif (source_ops(csdev)->disable) {\r\nsource_ops(csdev)->disable(csdev, NULL);\r\ncsdev->enable = false;\r\n}\r\n}\r\n}\r\nvoid coresight_disable_path(struct list_head *path)\r\n{\r\nu32 type;\r\nstruct coresight_node *nd;\r\nstruct coresight_device *csdev, *parent, *child;\r\nlist_for_each_entry(nd, path, link) {\r\ncsdev = nd->csdev;\r\ntype = csdev->type;\r\nif (type == CORESIGHT_DEV_TYPE_LINKSINK)\r\ntype = (csdev == coresight_get_sink(path)) ?\r\nCORESIGHT_DEV_TYPE_SINK :\r\nCORESIGHT_DEV_TYPE_LINK;\r\nswitch (type) {\r\ncase CORESIGHT_DEV_TYPE_SINK:\r\ncoresight_disable_sink(csdev);\r\nbreak;\r\ncase CORESIGHT_DEV_TYPE_SOURCE:\r\nbreak;\r\ncase CORESIGHT_DEV_TYPE_LINK:\r\nparent = list_prev_entry(nd, link)->csdev;\r\nchild = list_next_entry(nd, link)->csdev;\r\ncoresight_disable_link(csdev, parent, child);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nint coresight_enable_path(struct list_head *path, u32 mode)\r\n{\r\nint ret = 0;\r\nu32 type;\r\nstruct coresight_node *nd;\r\nstruct coresight_device *csdev, *parent, *child;\r\nlist_for_each_entry_reverse(nd, path, link) {\r\ncsdev = nd->csdev;\r\ntype = csdev->type;\r\nif (type == CORESIGHT_DEV_TYPE_LINKSINK)\r\ntype = (csdev == coresight_get_sink(path)) ?\r\nCORESIGHT_DEV_TYPE_SINK :\r\nCORESIGHT_DEV_TYPE_LINK;\r\nswitch (type) {\r\ncase CORESIGHT_DEV_TYPE_SINK:\r\nret = coresight_enable_sink(csdev, mode);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase CORESIGHT_DEV_TYPE_SOURCE:\r\nbreak;\r\ncase CORESIGHT_DEV_TYPE_LINK:\r\nparent = list_prev_entry(nd, link)->csdev;\r\nchild = list_next_entry(nd, link)->csdev;\r\nret = coresight_enable_link(csdev, parent, child);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\nerr:\r\ncoresight_disable_path(path);\r\ngoto out;\r\n}\r\nstruct coresight_device *coresight_get_sink(struct list_head *path)\r\n{\r\nstruct coresight_device *csdev;\r\nif (!path)\r\nreturn NULL;\r\ncsdev = list_last_entry(path, struct coresight_node, link)->csdev;\r\nif (csdev->type != CORESIGHT_DEV_TYPE_SINK &&\r\ncsdev->type != CORESIGHT_DEV_TYPE_LINKSINK)\r\nreturn NULL;\r\nreturn csdev;\r\n}\r\nstatic int coresight_enabled_sink(struct device *dev, void *data)\r\n{\r\nbool *reset = data;\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nif ((csdev->type == CORESIGHT_DEV_TYPE_SINK ||\r\ncsdev->type == CORESIGHT_DEV_TYPE_LINKSINK) &&\r\ncsdev->activated) {\r\nif (*reset)\r\ncsdev->activated = false;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstruct coresight_device *coresight_get_enabled_sink(bool deactivate)\r\n{\r\nstruct device *dev = NULL;\r\ndev = bus_find_device(&coresight_bustype, NULL, &deactivate,\r\ncoresight_enabled_sink);\r\nreturn dev ? to_coresight_device(dev) : NULL;\r\n}\r\nstatic int _coresight_build_path(struct coresight_device *csdev,\r\nstruct coresight_device *sink,\r\nstruct list_head *path)\r\n{\r\nint i;\r\nbool found = false;\r\nstruct coresight_node *node;\r\nif (csdev == sink)\r\ngoto out;\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nstruct coresight_device *child_dev = csdev->conns[i].child_dev;\r\nif (child_dev &&\r\n_coresight_build_path(child_dev, sink, path) == 0) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn -ENODEV;\r\nout:\r\nnode = kzalloc(sizeof(struct coresight_node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->csdev = csdev;\r\nlist_add(&node->link, path);\r\npm_runtime_get_sync(csdev->dev.parent);\r\nreturn 0;\r\n}\r\nstruct list_head *coresight_build_path(struct coresight_device *source,\r\nstruct coresight_device *sink)\r\n{\r\nstruct list_head *path;\r\nint rc;\r\nif (!sink)\r\nreturn ERR_PTR(-EINVAL);\r\npath = kzalloc(sizeof(struct list_head), GFP_KERNEL);\r\nif (!path)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(path);\r\nrc = _coresight_build_path(source, sink, path);\r\nif (rc) {\r\nkfree(path);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn path;\r\n}\r\nvoid coresight_release_path(struct list_head *path)\r\n{\r\nstruct coresight_device *csdev;\r\nstruct coresight_node *nd, *next;\r\nlist_for_each_entry_safe(nd, next, path, link) {\r\ncsdev = nd->csdev;\r\npm_runtime_put_sync(csdev->dev.parent);\r\nlist_del(&nd->link);\r\nkfree(nd);\r\n}\r\nkfree(path);\r\npath = NULL;\r\n}\r\nstatic int coresight_validate_source(struct coresight_device *csdev,\r\nconst char *function)\r\n{\r\nu32 type, subtype;\r\ntype = csdev->type;\r\nsubtype = csdev->subtype.source_subtype;\r\nif (type != CORESIGHT_DEV_TYPE_SOURCE) {\r\ndev_err(&csdev->dev, "wrong device type in %s\n", function);\r\nreturn -EINVAL;\r\n}\r\nif (subtype != CORESIGHT_DEV_SUBTYPE_SOURCE_PROC &&\r\nsubtype != CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE) {\r\ndev_err(&csdev->dev, "wrong device subtype in %s\n", function);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint coresight_enable(struct coresight_device *csdev)\r\n{\r\nint cpu, ret = 0;\r\nstruct coresight_device *sink;\r\nstruct list_head *path;\r\nmutex_lock(&coresight_mutex);\r\nret = coresight_validate_source(csdev, __func__);\r\nif (ret)\r\ngoto out;\r\nif (csdev->enable)\r\ngoto out;\r\nsink = coresight_get_enabled_sink(false);\r\nif (!sink) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npath = coresight_build_path(csdev, sink);\r\nif (IS_ERR(path)) {\r\npr_err("building path(s) failed\n");\r\nret = PTR_ERR(path);\r\ngoto out;\r\n}\r\nret = coresight_enable_path(path, CS_MODE_SYSFS);\r\nif (ret)\r\ngoto err_path;\r\nret = coresight_enable_source(csdev, CS_MODE_SYSFS);\r\nif (ret)\r\ngoto err_source;\r\nswitch (csdev->subtype.source_subtype) {\r\ncase CORESIGHT_DEV_SUBTYPE_SOURCE_PROC:\r\ncpu = source_ops(csdev)->cpu_id(csdev);\r\nper_cpu(tracer_path, cpu) = path;\r\nbreak;\r\ncase CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE:\r\nstm_path = path;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&coresight_mutex);\r\nreturn ret;\r\nerr_source:\r\ncoresight_disable_path(path);\r\nerr_path:\r\ncoresight_release_path(path);\r\ngoto out;\r\n}\r\nvoid coresight_disable(struct coresight_device *csdev)\r\n{\r\nint cpu, ret;\r\nstruct list_head *path = NULL;\r\nmutex_lock(&coresight_mutex);\r\nret = coresight_validate_source(csdev, __func__);\r\nif (ret)\r\ngoto out;\r\nif (!csdev->enable)\r\ngoto out;\r\nswitch (csdev->subtype.source_subtype) {\r\ncase CORESIGHT_DEV_SUBTYPE_SOURCE_PROC:\r\ncpu = source_ops(csdev)->cpu_id(csdev);\r\npath = per_cpu(tracer_path, cpu);\r\nper_cpu(tracer_path, cpu) = NULL;\r\nbreak;\r\ncase CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE:\r\npath = stm_path;\r\nstm_path = NULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncoresight_disable_source(csdev);\r\ncoresight_disable_path(path);\r\ncoresight_release_path(path);\r\nout:\r\nmutex_unlock(&coresight_mutex);\r\n}\r\nstatic ssize_t enable_sink_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", csdev->activated);\r\n}\r\nstatic ssize_t enable_sink_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val)\r\ncsdev->activated = true;\r\nelse\r\ncsdev->activated = false;\r\nreturn size;\r\n}\r\nstatic ssize_t enable_source_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", csdev->enable);\r\n}\r\nstatic ssize_t enable_source_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret = 0;\r\nunsigned long val;\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val) {\r\nret = coresight_enable(csdev);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ncoresight_disable(csdev);\r\n}\r\nreturn size;\r\n}\r\nstatic void coresight_device_release(struct device *dev)\r\n{\r\nstruct coresight_device *csdev = to_coresight_device(dev);\r\nkfree(csdev->conns);\r\nkfree(csdev->refcnt);\r\nkfree(csdev);\r\n}\r\nstatic int coresight_orphan_match(struct device *dev, void *data)\r\n{\r\nint i;\r\nbool still_orphan = false;\r\nstruct coresight_device *csdev, *i_csdev;\r\nstruct coresight_connection *conn;\r\ncsdev = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (csdev == i_csdev)\r\nreturn 0;\r\nif (!i_csdev->orphan)\r\nreturn 0;\r\nfor (i = 0; i < i_csdev->nr_outport; i++) {\r\nconn = &i_csdev->conns[i];\r\nif (conn->child_dev == NULL) {\r\nif (conn->child_name &&\r\n!strcmp(dev_name(&csdev->dev), conn->child_name)) {\r\nconn->child_dev = csdev;\r\n} else {\r\nstill_orphan = true;\r\n}\r\n}\r\n}\r\ni_csdev->orphan = still_orphan;\r\nreturn 0;\r\n}\r\nstatic void coresight_fixup_orphan_conns(struct coresight_device *csdev)\r\n{\r\nbus_for_each_dev(&coresight_bustype, NULL,\r\ncsdev, coresight_orphan_match);\r\n}\r\nstatic int coresight_name_match(struct device *dev, void *data)\r\n{\r\nchar *to_match;\r\nstruct coresight_device *i_csdev;\r\nto_match = data;\r\ni_csdev = to_coresight_device(dev);\r\nif (to_match && !strcmp(to_match, dev_name(&i_csdev->dev)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void coresight_fixup_device_conns(struct coresight_device *csdev)\r\n{\r\nint i;\r\nstruct device *dev = NULL;\r\nstruct coresight_connection *conn;\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconn = &csdev->conns[i];\r\ndev = bus_find_device(&coresight_bustype, NULL,\r\n(void *)conn->child_name,\r\ncoresight_name_match);\r\nif (dev) {\r\nconn->child_dev = to_coresight_device(dev);\r\nput_device(dev);\r\n} else {\r\ncsdev->orphan = true;\r\nconn->child_dev = NULL;\r\n}\r\n}\r\n}\r\nstatic int coresight_remove_match(struct device *dev, void *data)\r\n{\r\nint i;\r\nstruct coresight_device *csdev, *iterator;\r\nstruct coresight_connection *conn;\r\ncsdev = data;\r\niterator = to_coresight_device(dev);\r\nif (csdev == iterator)\r\nreturn 0;\r\nfor (i = 0; i < iterator->nr_outport; i++) {\r\nconn = &iterator->conns[i];\r\nif (conn->child_dev == NULL)\r\ncontinue;\r\nif (!strcmp(dev_name(&csdev->dev), conn->child_name)) {\r\niterator->orphan = true;\r\nconn->child_dev = NULL;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void coresight_remove_conns(struct coresight_device *csdev)\r\n{\r\nbus_for_each_dev(&coresight_bustype, NULL,\r\ncsdev, coresight_remove_match);\r\n}\r\nint coresight_timeout(void __iomem *addr, u32 offset, int position, int value)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = TIMEOUT_US; i > 0; i--) {\r\nval = __raw_readl(addr + offset);\r\nif (value) {\r\nif (val & BIT(position))\r\nreturn 0;\r\n} else {\r\nif (!(val & BIT(position)))\r\nreturn 0;\r\n}\r\nif (i - 1)\r\nudelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int __init coresight_init(void)\r\n{\r\nreturn bus_register(&coresight_bustype);\r\n}\r\nstruct coresight_device *coresight_register(struct coresight_desc *desc)\r\n{\r\nint i;\r\nint ret;\r\nint link_subtype;\r\nint nr_refcnts = 1;\r\natomic_t *refcnts = NULL;\r\nstruct coresight_device *csdev;\r\nstruct coresight_connection *conns = NULL;\r\ncsdev = kzalloc(sizeof(*csdev), GFP_KERNEL);\r\nif (!csdev) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_csdev;\r\n}\r\nif (desc->type == CORESIGHT_DEV_TYPE_LINK ||\r\ndesc->type == CORESIGHT_DEV_TYPE_LINKSINK) {\r\nlink_subtype = desc->subtype.link_subtype;\r\nif (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_MERG)\r\nnr_refcnts = desc->pdata->nr_inport;\r\nelse if (link_subtype == CORESIGHT_DEV_SUBTYPE_LINK_SPLIT)\r\nnr_refcnts = desc->pdata->nr_outport;\r\n}\r\nrefcnts = kcalloc(nr_refcnts, sizeof(*refcnts), GFP_KERNEL);\r\nif (!refcnts) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_refcnts;\r\n}\r\ncsdev->refcnt = refcnts;\r\ncsdev->nr_inport = desc->pdata->nr_inport;\r\ncsdev->nr_outport = desc->pdata->nr_outport;\r\nif (csdev->nr_outport) {\r\nconns = kcalloc(csdev->nr_outport, sizeof(*conns), GFP_KERNEL);\r\nif (!conns) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc_conns;\r\n}\r\nfor (i = 0; i < csdev->nr_outport; i++) {\r\nconns[i].outport = desc->pdata->outports[i];\r\nconns[i].child_name = desc->pdata->child_names[i];\r\nconns[i].child_port = desc->pdata->child_ports[i];\r\n}\r\n}\r\ncsdev->conns = conns;\r\ncsdev->type = desc->type;\r\ncsdev->subtype = desc->subtype;\r\ncsdev->ops = desc->ops;\r\ncsdev->orphan = false;\r\ncsdev->dev.type = &coresight_dev_type[desc->type];\r\ncsdev->dev.groups = desc->groups;\r\ncsdev->dev.parent = desc->dev;\r\ncsdev->dev.release = coresight_device_release;\r\ncsdev->dev.bus = &coresight_bustype;\r\ndev_set_name(&csdev->dev, "%s", desc->pdata->name);\r\nret = device_register(&csdev->dev);\r\nif (ret)\r\ngoto err_device_register;\r\nmutex_lock(&coresight_mutex);\r\ncoresight_fixup_device_conns(csdev);\r\ncoresight_fixup_orphan_conns(csdev);\r\nmutex_unlock(&coresight_mutex);\r\nreturn csdev;\r\nerr_device_register:\r\nkfree(conns);\r\nerr_kzalloc_conns:\r\nkfree(refcnts);\r\nerr_kzalloc_refcnts:\r\nkfree(csdev);\r\nerr_kzalloc_csdev:\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid coresight_unregister(struct coresight_device *csdev)\r\n{\r\ncoresight_remove_conns(csdev);\r\ndevice_unregister(&csdev->dev);\r\n}
