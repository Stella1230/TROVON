static int ceph_x_is_authenticated(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nceph_x_validate_tickets(ac, &need);\r\ndout("ceph_x_is_authenticated want=%d need=%d have=%d\n",\r\nac->want_keys, need, xi->have_keys);\r\nreturn (ac->want_keys & xi->have_keys) == ac->want_keys;\r\n}\r\nstatic int ceph_x_should_authenticate(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nceph_x_validate_tickets(ac, &need);\r\ndout("ceph_x_should_authenticate want=%d need=%d have=%d\n",\r\nac->want_keys, need, xi->have_keys);\r\nreturn need != 0;\r\n}\r\nstatic int ceph_x_encrypt_offset(void)\r\n{\r\nreturn sizeof(u32) + sizeof(struct ceph_x_encrypt_header);\r\n}\r\nstatic int ceph_x_encrypt_buflen(int ilen)\r\n{\r\nreturn ceph_x_encrypt_offset() + ilen + 16;\r\n}\r\nstatic int ceph_x_encrypt(struct ceph_crypto_key *secret, void *buf,\r\nint buf_len, int plaintext_len)\r\n{\r\nstruct ceph_x_encrypt_header *hdr = buf + sizeof(u32);\r\nint ciphertext_len;\r\nint ret;\r\nhdr->struct_v = 1;\r\nhdr->magic = cpu_to_le64(CEPHX_ENC_MAGIC);\r\nret = ceph_crypt(secret, true, buf + sizeof(u32), buf_len - sizeof(u32),\r\nplaintext_len + sizeof(struct ceph_x_encrypt_header),\r\n&ciphertext_len);\r\nif (ret)\r\nreturn ret;\r\nceph_encode_32(&buf, ciphertext_len);\r\nreturn sizeof(u32) + ciphertext_len;\r\n}\r\nstatic int ceph_x_decrypt(struct ceph_crypto_key *secret, void **p, void *end)\r\n{\r\nstruct ceph_x_encrypt_header *hdr = *p + sizeof(u32);\r\nint ciphertext_len, plaintext_len;\r\nint ret;\r\nceph_decode_32_safe(p, end, ciphertext_len, e_inval);\r\nceph_decode_need(p, end, ciphertext_len, e_inval);\r\nret = ceph_crypt(secret, false, *p, end - *p, ciphertext_len,\r\n&plaintext_len);\r\nif (ret)\r\nreturn ret;\r\nif (hdr->struct_v != 1 || le64_to_cpu(hdr->magic) != CEPHX_ENC_MAGIC)\r\nreturn -EPERM;\r\n*p += ciphertext_len;\r\nreturn plaintext_len - sizeof(struct ceph_x_encrypt_header);\r\ne_inval:\r\nreturn -EINVAL;\r\n}\r\nstatic struct ceph_x_ticket_handler *\r\nget_ticket_handler(struct ceph_auth_client *ac, int service)\r\n{\r\nstruct ceph_x_ticket_handler *th;\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct rb_node *parent = NULL, **p = &xi->ticket_handlers.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nth = rb_entry(parent, struct ceph_x_ticket_handler, node);\r\nif (service < th->service)\r\np = &(*p)->rb_left;\r\nelse if (service > th->service)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn th;\r\n}\r\nth = kzalloc(sizeof(*th), GFP_NOFS);\r\nif (!th)\r\nreturn ERR_PTR(-ENOMEM);\r\nth->service = service;\r\nrb_link_node(&th->node, parent, p);\r\nrb_insert_color(&th->node, &xi->ticket_handlers);\r\nreturn th;\r\n}\r\nstatic void remove_ticket_handler(struct ceph_auth_client *ac,\r\nstruct ceph_x_ticket_handler *th)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\ndout("remove_ticket_handler %p %d\n", th, th->service);\r\nrb_erase(&th->node, &xi->ticket_handlers);\r\nceph_crypto_key_destroy(&th->session_key);\r\nif (th->ticket_blob)\r\nceph_buffer_put(th->ticket_blob);\r\nkfree(th);\r\n}\r\nstatic int process_one_ticket(struct ceph_auth_client *ac,\r\nstruct ceph_crypto_key *secret,\r\nvoid **p, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint type;\r\nu8 tkt_struct_v, blob_struct_v;\r\nstruct ceph_x_ticket_handler *th;\r\nvoid *dp, *dend;\r\nint dlen;\r\nchar is_enc;\r\nstruct timespec validity;\r\nvoid *tp, *tpend;\r\nvoid **ptp;\r\nstruct ceph_crypto_key new_session_key;\r\nstruct ceph_buffer *new_ticket_blob;\r\nunsigned long new_expires, new_renew_after;\r\nu64 new_secret_id;\r\nint ret;\r\nceph_decode_need(p, end, sizeof(u32) + 1, bad);\r\ntype = ceph_decode_32(p);\r\ndout(" ticket type %d %s\n", type, ceph_entity_type_name(type));\r\ntkt_struct_v = ceph_decode_8(p);\r\nif (tkt_struct_v != 1)\r\ngoto bad;\r\nth = get_ticket_handler(ac, type);\r\nif (IS_ERR(th)) {\r\nret = PTR_ERR(th);\r\ngoto out;\r\n}\r\ndp = *p + ceph_x_encrypt_offset();\r\nret = ceph_x_decrypt(secret, p, end);\r\nif (ret < 0)\r\ngoto out;\r\ndout(" decrypted %d bytes\n", ret);\r\ndend = dp + ret;\r\ntkt_struct_v = ceph_decode_8(&dp);\r\nif (tkt_struct_v != 1)\r\ngoto bad;\r\nret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\r\nif (ret)\r\ngoto out;\r\nceph_decode_timespec(&validity, dp);\r\ndp += sizeof(struct ceph_timespec);\r\nnew_expires = get_seconds() + validity.tv_sec;\r\nnew_renew_after = new_expires - (validity.tv_sec / 4);\r\ndout(" expires=%lu renew_after=%lu\n", new_expires,\r\nnew_renew_after);\r\nceph_decode_8_safe(p, end, is_enc, bad);\r\nif (is_enc) {\r\ntp = *p + ceph_x_encrypt_offset();\r\nret = ceph_x_decrypt(&th->session_key, p, end);\r\nif (ret < 0)\r\ngoto out;\r\ndout(" encrypted ticket, decrypted %d bytes\n", ret);\r\nptp = &tp;\r\ntpend = tp + ret;\r\n} else {\r\nptp = p;\r\ntpend = end;\r\n}\r\nceph_decode_32_safe(ptp, tpend, dlen, bad);\r\ndout(" ticket blob is %d bytes\n", dlen);\r\nceph_decode_need(ptp, tpend, 1 + sizeof(u64), bad);\r\nblob_struct_v = ceph_decode_8(ptp);\r\nnew_secret_id = ceph_decode_64(ptp);\r\nret = ceph_decode_buffer(&new_ticket_blob, ptp, tpend);\r\nif (ret)\r\ngoto out;\r\nceph_crypto_key_destroy(&th->session_key);\r\nif (th->ticket_blob)\r\nceph_buffer_put(th->ticket_blob);\r\nth->session_key = new_session_key;\r\nth->ticket_blob = new_ticket_blob;\r\nth->secret_id = new_secret_id;\r\nth->expires = new_expires;\r\nth->renew_after = new_renew_after;\r\nth->have_key = true;\r\ndout(" got ticket service %d (%s) secret_id %lld len %d\n",\r\ntype, ceph_entity_type_name(type), th->secret_id,\r\n(int)th->ticket_blob->vec.iov_len);\r\nxi->have_keys |= th->service;\r\nout:\r\nreturn ret;\r\nbad:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstatic int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\r\nstruct ceph_crypto_key *secret,\r\nvoid *buf, void *end)\r\n{\r\nvoid *p = buf;\r\nu8 reply_struct_v;\r\nu32 num;\r\nint ret;\r\nceph_decode_8_safe(&p, end, reply_struct_v, bad);\r\nif (reply_struct_v != 1)\r\nreturn -EINVAL;\r\nceph_decode_32_safe(&p, end, num, bad);\r\ndout("%d tickets\n", num);\r\nwhile (num--) {\r\nret = process_one_ticket(ac, secret, &p, end);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\nbad:\r\nreturn -EINVAL;\r\n}\r\nstatic void ceph_x_authorizer_cleanup(struct ceph_x_authorizer *au)\r\n{\r\nceph_crypto_key_destroy(&au->session_key);\r\nif (au->buf) {\r\nceph_buffer_put(au->buf);\r\nau->buf = NULL;\r\n}\r\n}\r\nstatic int ceph_x_build_authorizer(struct ceph_auth_client *ac,\r\nstruct ceph_x_ticket_handler *th,\r\nstruct ceph_x_authorizer *au)\r\n{\r\nint maxlen;\r\nstruct ceph_x_authorize_a *msg_a;\r\nstruct ceph_x_authorize_b *msg_b;\r\nvoid *p, *end;\r\nint ret;\r\nint ticket_blob_len =\r\n(th->ticket_blob ? th->ticket_blob->vec.iov_len : 0);\r\ndout("build_authorizer for %s %p\n",\r\nceph_entity_type_name(th->service), au);\r\nceph_crypto_key_destroy(&au->session_key);\r\nret = ceph_crypto_key_clone(&au->session_key, &th->session_key);\r\nif (ret)\r\ngoto out_au;\r\nmaxlen = sizeof(*msg_a) + ticket_blob_len +\r\nceph_x_encrypt_buflen(sizeof(*msg_b));\r\ndout(" need len %d\n", maxlen);\r\nif (au->buf && au->buf->alloc_len < maxlen) {\r\nceph_buffer_put(au->buf);\r\nau->buf = NULL;\r\n}\r\nif (!au->buf) {\r\nau->buf = ceph_buffer_new(maxlen, GFP_NOFS);\r\nif (!au->buf) {\r\nret = -ENOMEM;\r\ngoto out_au;\r\n}\r\n}\r\nau->service = th->service;\r\nau->secret_id = th->secret_id;\r\nmsg_a = au->buf->vec.iov_base;\r\nmsg_a->struct_v = 1;\r\nmsg_a->global_id = cpu_to_le64(ac->global_id);\r\nmsg_a->service_id = cpu_to_le32(th->service);\r\nmsg_a->ticket_blob.struct_v = 1;\r\nmsg_a->ticket_blob.secret_id = cpu_to_le64(th->secret_id);\r\nmsg_a->ticket_blob.blob_len = cpu_to_le32(ticket_blob_len);\r\nif (ticket_blob_len) {\r\nmemcpy(msg_a->ticket_blob.blob, th->ticket_blob->vec.iov_base,\r\nth->ticket_blob->vec.iov_len);\r\n}\r\ndout(" th %p secret_id %lld %lld\n", th, th->secret_id,\r\nle64_to_cpu(msg_a->ticket_blob.secret_id));\r\np = msg_a + 1;\r\np += ticket_blob_len;\r\nend = au->buf->vec.iov_base + au->buf->vec.iov_len;\r\nmsg_b = p + ceph_x_encrypt_offset();\r\nmsg_b->struct_v = 1;\r\nget_random_bytes(&au->nonce, sizeof(au->nonce));\r\nmsg_b->nonce = cpu_to_le64(au->nonce);\r\nret = ceph_x_encrypt(&au->session_key, p, end - p, sizeof(*msg_b));\r\nif (ret < 0)\r\ngoto out_au;\r\np += ret;\r\nWARN_ON(p > end);\r\nau->buf->vec.iov_len = p - au->buf->vec.iov_base;\r\ndout(" built authorizer nonce %llx len %d\n", au->nonce,\r\n(int)au->buf->vec.iov_len);\r\nreturn 0;\r\nout_au:\r\nceph_x_authorizer_cleanup(au);\r\nreturn ret;\r\n}\r\nstatic int ceph_x_encode_ticket(struct ceph_x_ticket_handler *th,\r\nvoid **p, void *end)\r\n{\r\nceph_decode_need(p, end, 1 + sizeof(u64), bad);\r\nceph_encode_8(p, 1);\r\nceph_encode_64(p, th->secret_id);\r\nif (th->ticket_blob) {\r\nconst char *buf = th->ticket_blob->vec.iov_base;\r\nu32 len = th->ticket_blob->vec.iov_len;\r\nceph_encode_32_safe(p, end, len, bad);\r\nceph_encode_copy_safe(p, end, buf, len, bad);\r\n} else {\r\nceph_encode_32_safe(p, end, 0, bad);\r\n}\r\nreturn 0;\r\nbad:\r\nreturn -ERANGE;\r\n}\r\nstatic bool need_key(struct ceph_x_ticket_handler *th)\r\n{\r\nif (!th->have_key)\r\nreturn true;\r\nreturn get_seconds() >= th->renew_after;\r\n}\r\nstatic bool have_key(struct ceph_x_ticket_handler *th)\r\n{\r\nif (th->have_key) {\r\nif (get_seconds() >= th->expires)\r\nth->have_key = false;\r\n}\r\nreturn th->have_key;\r\n}\r\nstatic void ceph_x_validate_tickets(struct ceph_auth_client *ac, int *pneed)\r\n{\r\nint want = ac->want_keys;\r\nstruct ceph_x_info *xi = ac->private;\r\nint service;\r\n*pneed = ac->want_keys & ~(xi->have_keys);\r\nfor (service = 1; service <= want; service <<= 1) {\r\nstruct ceph_x_ticket_handler *th;\r\nif (!(ac->want_keys & service))\r\ncontinue;\r\nif (*pneed & service)\r\ncontinue;\r\nth = get_ticket_handler(ac, service);\r\nif (IS_ERR(th)) {\r\n*pneed |= service;\r\ncontinue;\r\n}\r\nif (need_key(th))\r\n*pneed |= service;\r\nif (!have_key(th))\r\nxi->have_keys &= ~service;\r\n}\r\n}\r\nstatic int ceph_x_build_request(struct ceph_auth_client *ac,\r\nvoid *buf, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nint need;\r\nstruct ceph_x_request_header *head = buf;\r\nint ret;\r\nstruct ceph_x_ticket_handler *th =\r\nget_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nceph_x_validate_tickets(ac, &need);\r\ndout("build_request want %x have %x need %x\n",\r\nac->want_keys, xi->have_keys, need);\r\nif (need & CEPH_ENTITY_TYPE_AUTH) {\r\nstruct ceph_x_authenticate *auth = (void *)(head + 1);\r\nvoid *p = auth + 1;\r\nvoid *enc_buf = xi->auth_authorizer.enc_buf;\r\nstruct ceph_x_challenge_blob *blob = enc_buf +\r\nceph_x_encrypt_offset();\r\nu64 *u;\r\nif (p > end)\r\nreturn -ERANGE;\r\ndout(" get_auth_session_key\n");\r\nhead->op = cpu_to_le16(CEPHX_GET_AUTH_SESSION_KEY);\r\nget_random_bytes(&auth->client_challenge, sizeof(u64));\r\nblob->client_challenge = auth->client_challenge;\r\nblob->server_challenge = cpu_to_le64(xi->server_challenge);\r\nret = ceph_x_encrypt(&xi->secret, enc_buf, CEPHX_AU_ENC_BUF_LEN,\r\nsizeof(*blob));\r\nif (ret < 0)\r\nreturn ret;\r\nauth->struct_v = 1;\r\nauth->key = 0;\r\nfor (u = (u64 *)enc_buf; u + 1 <= (u64 *)(enc_buf + ret); u++)\r\nauth->key ^= *(__le64 *)u;\r\ndout(" server_challenge %llx client_challenge %llx key %llx\n",\r\nxi->server_challenge, le64_to_cpu(auth->client_challenge),\r\nle64_to_cpu(auth->key));\r\nret = ceph_x_encode_ticket(th, &p, end);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn p - buf;\r\n}\r\nif (need) {\r\nvoid *p = head + 1;\r\nstruct ceph_x_service_ticket_request *req;\r\nif (p > end)\r\nreturn -ERANGE;\r\nhead->op = cpu_to_le16(CEPHX_GET_PRINCIPAL_SESSION_KEY);\r\nret = ceph_x_build_authorizer(ac, th, &xi->auth_authorizer);\r\nif (ret)\r\nreturn ret;\r\nceph_encode_copy(&p, xi->auth_authorizer.buf->vec.iov_base,\r\nxi->auth_authorizer.buf->vec.iov_len);\r\nreq = p;\r\nreq->keys = cpu_to_le32(need);\r\np += sizeof(*req);\r\nreturn p - buf;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ceph_x_handle_reply(struct ceph_auth_client *ac, int result,\r\nvoid *buf, void *end)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct ceph_x_reply_header *head = buf;\r\nstruct ceph_x_ticket_handler *th;\r\nint len = end - buf;\r\nint op;\r\nint ret;\r\nif (result)\r\nreturn result;\r\nif (xi->starting) {\r\nstruct ceph_x_server_challenge *sc = buf;\r\nif (len != sizeof(*sc))\r\nreturn -EINVAL;\r\nxi->server_challenge = le64_to_cpu(sc->server_challenge);\r\ndout("handle_reply got server challenge %llx\n",\r\nxi->server_challenge);\r\nxi->starting = false;\r\nxi->have_keys &= ~CEPH_ENTITY_TYPE_AUTH;\r\nreturn -EAGAIN;\r\n}\r\nop = le16_to_cpu(head->op);\r\nresult = le32_to_cpu(head->result);\r\ndout("handle_reply op %d result %d\n", op, result);\r\nswitch (op) {\r\ncase CEPHX_GET_AUTH_SESSION_KEY:\r\nret = ceph_x_proc_ticket_reply(ac, &xi->secret,\r\nbuf + sizeof(*head), end);\r\nbreak;\r\ncase CEPHX_GET_PRINCIPAL_SESSION_KEY:\r\nth = get_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nret = ceph_x_proc_ticket_reply(ac, &th->session_key,\r\nbuf + sizeof(*head), end);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nif (ac->want_keys == xi->have_keys)\r\nreturn 0;\r\nreturn -EAGAIN;\r\n}\r\nstatic void ceph_x_destroy_authorizer(struct ceph_authorizer *a)\r\n{\r\nstruct ceph_x_authorizer *au = (void *)a;\r\nceph_x_authorizer_cleanup(au);\r\nkfree(au);\r\n}\r\nstatic int ceph_x_create_authorizer(\r\nstruct ceph_auth_client *ac, int peer_type,\r\nstruct ceph_auth_handshake *auth)\r\n{\r\nstruct ceph_x_authorizer *au;\r\nstruct ceph_x_ticket_handler *th;\r\nint ret;\r\nth = get_ticket_handler(ac, peer_type);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nau = kzalloc(sizeof(*au), GFP_NOFS);\r\nif (!au)\r\nreturn -ENOMEM;\r\nau->base.destroy = ceph_x_destroy_authorizer;\r\nret = ceph_x_build_authorizer(ac, th, au);\r\nif (ret) {\r\nkfree(au);\r\nreturn ret;\r\n}\r\nauth->authorizer = (struct ceph_authorizer *) au;\r\nauth->authorizer_buf = au->buf->vec.iov_base;\r\nauth->authorizer_buf_len = au->buf->vec.iov_len;\r\nauth->authorizer_reply_buf = au->enc_buf;\r\nauth->authorizer_reply_buf_len = CEPHX_AU_ENC_BUF_LEN;\r\nauth->sign_message = ac->ops->sign_message;\r\nauth->check_message_signature = ac->ops->check_message_signature;\r\nreturn 0;\r\n}\r\nstatic int ceph_x_update_authorizer(\r\nstruct ceph_auth_client *ac, int peer_type,\r\nstruct ceph_auth_handshake *auth)\r\n{\r\nstruct ceph_x_authorizer *au;\r\nstruct ceph_x_ticket_handler *th;\r\nth = get_ticket_handler(ac, peer_type);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nau = (struct ceph_x_authorizer *)auth->authorizer;\r\nif (au->secret_id < th->secret_id) {\r\ndout("ceph_x_update_authorizer service %u secret %llu < %llu\n",\r\nau->service, au->secret_id, th->secret_id);\r\nreturn ceph_x_build_authorizer(ac, th, au);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\r\nstruct ceph_authorizer *a)\r\n{\r\nstruct ceph_x_authorizer *au = (void *)a;\r\nvoid *p = au->enc_buf;\r\nstruct ceph_x_authorize_reply *reply = p + ceph_x_encrypt_offset();\r\nint ret;\r\nret = ceph_x_decrypt(&au->session_key, &p, p + CEPHX_AU_ENC_BUF_LEN);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != sizeof(*reply))\r\nreturn -EPERM;\r\nif (au->nonce + 1 != le64_to_cpu(reply->nonce_plus_one))\r\nret = -EPERM;\r\nelse\r\nret = 0;\r\ndout("verify_authorizer_reply nonce %llx got %llx ret %d\n",\r\nau->nonce, le64_to_cpu(reply->nonce_plus_one), ret);\r\nreturn ret;\r\n}\r\nstatic void ceph_x_reset(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\ndout("reset\n");\r\nxi->starting = true;\r\nxi->server_challenge = 0;\r\n}\r\nstatic void ceph_x_destroy(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi = ac->private;\r\nstruct rb_node *p;\r\ndout("ceph_x_destroy %p\n", ac);\r\nceph_crypto_key_destroy(&xi->secret);\r\nwhile ((p = rb_first(&xi->ticket_handlers)) != NULL) {\r\nstruct ceph_x_ticket_handler *th =\r\nrb_entry(p, struct ceph_x_ticket_handler, node);\r\nremove_ticket_handler(ac, th);\r\n}\r\nceph_x_authorizer_cleanup(&xi->auth_authorizer);\r\nkfree(ac->private);\r\nac->private = NULL;\r\n}\r\nstatic void invalidate_ticket(struct ceph_auth_client *ac, int peer_type)\r\n{\r\nstruct ceph_x_ticket_handler *th;\r\nth = get_ticket_handler(ac, peer_type);\r\nif (!IS_ERR(th))\r\nth->have_key = false;\r\n}\r\nstatic void ceph_x_invalidate_authorizer(struct ceph_auth_client *ac,\r\nint peer_type)\r\n{\r\ninvalidate_ticket(ac, peer_type);\r\ninvalidate_ticket(ac, CEPH_ENTITY_TYPE_AUTH);\r\n}\r\nstatic int calc_signature(struct ceph_x_authorizer *au, struct ceph_msg *msg,\r\n__le64 *psig)\r\n{\r\nvoid *enc_buf = au->enc_buf;\r\nstruct {\r\n__le32 len;\r\n__le32 header_crc;\r\n__le32 front_crc;\r\n__le32 middle_crc;\r\n__le32 data_crc;\r\n} __packed *sigblock = enc_buf + ceph_x_encrypt_offset();\r\nint ret;\r\nsigblock->len = cpu_to_le32(4*sizeof(u32));\r\nsigblock->header_crc = msg->hdr.crc;\r\nsigblock->front_crc = msg->footer.front_crc;\r\nsigblock->middle_crc = msg->footer.middle_crc;\r\nsigblock->data_crc = msg->footer.data_crc;\r\nret = ceph_x_encrypt(&au->session_key, enc_buf, CEPHX_AU_ENC_BUF_LEN,\r\nsizeof(*sigblock));\r\nif (ret < 0)\r\nreturn ret;\r\n*psig = *(__le64 *)(enc_buf + sizeof(u32));\r\nreturn 0;\r\n}\r\nstatic int ceph_x_sign_message(struct ceph_auth_handshake *auth,\r\nstruct ceph_msg *msg)\r\n{\r\n__le64 sig;\r\nint ret;\r\nif (ceph_test_opt(from_msgr(msg->con->msgr), NOMSGSIGN))\r\nreturn 0;\r\nret = calc_signature((struct ceph_x_authorizer *)auth->authorizer,\r\nmsg, &sig);\r\nif (ret)\r\nreturn ret;\r\nmsg->footer.sig = sig;\r\nmsg->footer.flags |= CEPH_MSG_FOOTER_SIGNED;\r\nreturn 0;\r\n}\r\nstatic int ceph_x_check_message_signature(struct ceph_auth_handshake *auth,\r\nstruct ceph_msg *msg)\r\n{\r\n__le64 sig_check;\r\nint ret;\r\nif (ceph_test_opt(from_msgr(msg->con->msgr), NOMSGSIGN))\r\nreturn 0;\r\nret = calc_signature((struct ceph_x_authorizer *)auth->authorizer,\r\nmsg, &sig_check);\r\nif (ret)\r\nreturn ret;\r\nif (sig_check == msg->footer.sig)\r\nreturn 0;\r\nif (msg->footer.flags & CEPH_MSG_FOOTER_SIGNED)\r\ndout("ceph_x_check_message_signature %p has signature %llx "\r\n"expect %llx\n", msg, msg->footer.sig, sig_check);\r\nelse\r\ndout("ceph_x_check_message_signature %p sender did not set "\r\n"CEPH_MSG_FOOTER_SIGNED\n", msg);\r\nreturn -EBADMSG;\r\n}\r\nint ceph_x_init(struct ceph_auth_client *ac)\r\n{\r\nstruct ceph_x_info *xi;\r\nint ret;\r\ndout("ceph_x_init %p\n", ac);\r\nret = -ENOMEM;\r\nxi = kzalloc(sizeof(*xi), GFP_NOFS);\r\nif (!xi)\r\ngoto out;\r\nret = -EINVAL;\r\nif (!ac->key) {\r\npr_err("no secret set (for auth_x protocol)\n");\r\ngoto out_nomem;\r\n}\r\nret = ceph_crypto_key_clone(&xi->secret, ac->key);\r\nif (ret < 0) {\r\npr_err("cannot clone key: %d\n", ret);\r\ngoto out_nomem;\r\n}\r\nxi->starting = true;\r\nxi->ticket_handlers = RB_ROOT;\r\nac->protocol = CEPH_AUTH_CEPHX;\r\nac->private = xi;\r\nac->ops = &ceph_x_ops;\r\nreturn 0;\r\nout_nomem:\r\nkfree(xi);\r\nout:\r\nreturn ret;\r\n}
