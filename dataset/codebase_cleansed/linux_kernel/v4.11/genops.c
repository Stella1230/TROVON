static struct obd_device *obd_device_alloc(void)\r\n{\r\nstruct obd_device *obd;\r\nobd = kmem_cache_zalloc(obd_device_cachep, GFP_NOFS);\r\nif (obd)\r\nobd->obd_magic = OBD_DEVICE_MAGIC;\r\nreturn obd;\r\n}\r\nstatic void obd_device_free(struct obd_device *obd)\r\n{\r\nLASSERTF(obd->obd_magic == OBD_DEVICE_MAGIC, "obd %p obd_magic %08x != %08x\n",\r\nobd, obd->obd_magic, OBD_DEVICE_MAGIC);\r\nif (obd->obd_namespace) {\r\nCERROR("obd %p: namespace %p was not properly cleaned up (obd_force=%d)!\n",\r\nobd, obd->obd_namespace, obd->obd_force);\r\nLBUG();\r\n}\r\nlu_ref_fini(&obd->obd_reference);\r\nkmem_cache_free(obd_device_cachep, obd);\r\n}\r\nstatic struct obd_type *class_search_type(const char *name)\r\n{\r\nstruct list_head *tmp;\r\nstruct obd_type *type;\r\nspin_lock(&obd_types_lock);\r\nlist_for_each(tmp, &obd_types) {\r\ntype = list_entry(tmp, struct obd_type, typ_chain);\r\nif (strcmp(type->typ_name, name) == 0) {\r\nspin_unlock(&obd_types_lock);\r\nreturn type;\r\n}\r\n}\r\nspin_unlock(&obd_types_lock);\r\nreturn NULL;\r\n}\r\nstatic struct obd_type *class_get_type(const char *name)\r\n{\r\nstruct obd_type *type = class_search_type(name);\r\nif (!type) {\r\nconst char *modname = name;\r\nif (!request_module("%s", modname)) {\r\nCDEBUG(D_INFO, "Loaded module '%s'\n", modname);\r\ntype = class_search_type(name);\r\n} else {\r\nLCONSOLE_ERROR_MSG(0x158, "Can't load module '%s'\n",\r\nmodname);\r\n}\r\n}\r\nif (type) {\r\nspin_lock(&type->obd_type_lock);\r\ntype->typ_refcnt++;\r\ntry_module_get(type->typ_dt_ops->owner);\r\nspin_unlock(&type->obd_type_lock);\r\n}\r\nreturn type;\r\n}\r\nvoid class_put_type(struct obd_type *type)\r\n{\r\nLASSERT(type);\r\nspin_lock(&type->obd_type_lock);\r\ntype->typ_refcnt--;\r\nmodule_put(type->typ_dt_ops->owner);\r\nspin_unlock(&type->obd_type_lock);\r\n}\r\nint class_register_type(struct obd_ops *dt_ops, struct md_ops *md_ops,\r\nconst char *name,\r\nstruct lu_device_type *ldt)\r\n{\r\nstruct obd_type *type;\r\nint rc;\r\nLASSERT(strnlen(name, CLASS_MAX_NAME) < CLASS_MAX_NAME);\r\nif (class_search_type(name)) {\r\nCDEBUG(D_IOCTL, "Type %s already registered\n", name);\r\nreturn -EEXIST;\r\n}\r\nrc = -ENOMEM;\r\ntype = kzalloc(sizeof(*type), GFP_NOFS);\r\nif (!type)\r\nreturn rc;\r\ntype->typ_dt_ops = kzalloc(sizeof(*type->typ_dt_ops), GFP_NOFS);\r\ntype->typ_md_ops = kzalloc(sizeof(*type->typ_md_ops), GFP_NOFS);\r\ntype->typ_name = kzalloc(strlen(name) + 1, GFP_NOFS);\r\nif (!type->typ_dt_ops ||\r\n!type->typ_md_ops ||\r\n!type->typ_name)\r\ngoto failed;\r\n*type->typ_dt_ops = *dt_ops;\r\nif (md_ops)\r\n*type->typ_md_ops = *md_ops;\r\nstrcpy(type->typ_name, name);\r\nspin_lock_init(&type->obd_type_lock);\r\ntype->typ_debugfs_entry = ldebugfs_register(type->typ_name,\r\ndebugfs_lustre_root,\r\nNULL, type);\r\nif (IS_ERR_OR_NULL(type->typ_debugfs_entry)) {\r\nrc = type->typ_debugfs_entry ? PTR_ERR(type->typ_debugfs_entry)\r\n: -ENOMEM;\r\ntype->typ_debugfs_entry = NULL;\r\ngoto failed;\r\n}\r\ntype->typ_kobj = kobject_create_and_add(type->typ_name, lustre_kobj);\r\nif (!type->typ_kobj) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (ldt) {\r\ntype->typ_lu = ldt;\r\nrc = lu_device_type_init(ldt);\r\nif (rc != 0)\r\ngoto failed;\r\n}\r\nspin_lock(&obd_types_lock);\r\nlist_add(&type->typ_chain, &obd_types);\r\nspin_unlock(&obd_types_lock);\r\nreturn 0;\r\nfailed:\r\nif (type->typ_kobj)\r\nkobject_put(type->typ_kobj);\r\nkfree(type->typ_name);\r\nkfree(type->typ_md_ops);\r\nkfree(type->typ_dt_ops);\r\nkfree(type);\r\nreturn rc;\r\n}\r\nint class_unregister_type(const char *name)\r\n{\r\nstruct obd_type *type = class_search_type(name);\r\nif (!type) {\r\nCERROR("unknown obd type\n");\r\nreturn -EINVAL;\r\n}\r\nif (type->typ_refcnt) {\r\nCERROR("type %s has refcount (%d)\n", name, type->typ_refcnt);\r\nkfree(type->typ_dt_ops);\r\nkfree(type->typ_md_ops);\r\nreturn -EBUSY;\r\n}\r\nif (type->typ_kobj)\r\nkobject_put(type->typ_kobj);\r\nif (!IS_ERR_OR_NULL(type->typ_debugfs_entry))\r\nldebugfs_remove(&type->typ_debugfs_entry);\r\nif (type->typ_lu)\r\nlu_device_type_fini(type->typ_lu);\r\nspin_lock(&obd_types_lock);\r\nlist_del(&type->typ_chain);\r\nspin_unlock(&obd_types_lock);\r\nkfree(type->typ_name);\r\nkfree(type->typ_dt_ops);\r\nkfree(type->typ_md_ops);\r\nkfree(type);\r\nreturn 0;\r\n}\r\nstruct obd_device *class_newdev(const char *type_name, const char *name)\r\n{\r\nstruct obd_device *result = NULL;\r\nstruct obd_device *newdev;\r\nstruct obd_type *type = NULL;\r\nint i;\r\nint new_obd_minor = 0;\r\nif (strlen(name) >= MAX_OBD_NAME) {\r\nCERROR("name/uuid must be < %u bytes long\n", MAX_OBD_NAME);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntype = class_get_type(type_name);\r\nif (!type) {\r\nCERROR("OBD: unknown type: %s\n", type_name);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nnewdev = obd_device_alloc();\r\nif (!newdev) {\r\nresult = ERR_PTR(-ENOMEM);\r\ngoto out_type;\r\n}\r\nLASSERT(newdev->obd_magic == OBD_DEVICE_MAGIC);\r\nwrite_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (obd && (strcmp(name, obd->obd_name) == 0)) {\r\nCERROR("Device %s already exists at %d, won't add\n",\r\nname, i);\r\nif (result) {\r\nLASSERTF(result->obd_magic == OBD_DEVICE_MAGIC,\r\n"%p obd_magic %08x != %08x\n", result,\r\nresult->obd_magic, OBD_DEVICE_MAGIC);\r\nLASSERTF(result->obd_minor == new_obd_minor,\r\n"%p obd_minor %d != %d\n", result,\r\nresult->obd_minor, new_obd_minor);\r\nobd_devs[result->obd_minor] = NULL;\r\nresult->obd_name[0] = '\0';\r\n}\r\nresult = ERR_PTR(-EEXIST);\r\nbreak;\r\n}\r\nif (!result && !obd) {\r\nresult = newdev;\r\nresult->obd_minor = i;\r\nnew_obd_minor = i;\r\nresult->obd_type = type;\r\nstrncpy(result->obd_name, name,\r\nsizeof(result->obd_name) - 1);\r\nobd_devs[i] = result;\r\n}\r\n}\r\nwrite_unlock(&obd_dev_lock);\r\nif (!result && i >= class_devno_max()) {\r\nCERROR("all %u OBD devices used, increase MAX_OBD_DEVICES\n",\r\nclass_devno_max());\r\nresult = ERR_PTR(-EOVERFLOW);\r\ngoto out;\r\n}\r\nif (IS_ERR(result))\r\ngoto out;\r\nCDEBUG(D_IOCTL, "Adding new device %s (%p)\n",\r\nresult->obd_name, result);\r\nreturn result;\r\nout:\r\nobd_device_free(newdev);\r\nout_type:\r\nclass_put_type(type);\r\nreturn result;\r\n}\r\nvoid class_release_dev(struct obd_device *obd)\r\n{\r\nstruct obd_type *obd_type = obd->obd_type;\r\nLASSERTF(obd->obd_magic == OBD_DEVICE_MAGIC, "%p obd_magic %08x != %08x\n",\r\nobd, obd->obd_magic, OBD_DEVICE_MAGIC);\r\nLASSERTF(obd == obd_devs[obd->obd_minor], "obd %p != obd_devs[%d] %p\n",\r\nobd, obd->obd_minor, obd_devs[obd->obd_minor]);\r\nLASSERT(obd_type);\r\nCDEBUG(D_INFO, "Release obd device %s at %d obd_type name =%s\n",\r\nobd->obd_name, obd->obd_minor, obd->obd_type->typ_name);\r\nwrite_lock(&obd_dev_lock);\r\nobd_devs[obd->obd_minor] = NULL;\r\nwrite_unlock(&obd_dev_lock);\r\nobd_device_free(obd);\r\nclass_put_type(obd_type);\r\n}\r\nint class_name2dev(const char *name)\r\n{\r\nint i;\r\nif (!name)\r\nreturn -1;\r\nread_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (obd && strcmp(name, obd->obd_name) == 0) {\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nif (obd->obd_attached) {\r\nread_unlock(&obd_dev_lock);\r\nreturn i;\r\n}\r\nbreak;\r\n}\r\n}\r\nread_unlock(&obd_dev_lock);\r\nreturn -1;\r\n}\r\nstruct obd_device *class_name2obd(const char *name)\r\n{\r\nint dev = class_name2dev(name);\r\nif (dev < 0 || dev > class_devno_max())\r\nreturn NULL;\r\nreturn class_num2obd(dev);\r\n}\r\nint class_uuid2dev(struct obd_uuid *uuid)\r\n{\r\nint i;\r\nread_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (obd && obd_uuid_equals(uuid, &obd->obd_uuid)) {\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nread_unlock(&obd_dev_lock);\r\nreturn i;\r\n}\r\n}\r\nread_unlock(&obd_dev_lock);\r\nreturn -1;\r\n}\r\nstruct obd_device *class_num2obd(int num)\r\n{\r\nstruct obd_device *obd = NULL;\r\nif (num < class_devno_max()) {\r\nobd = obd_devs[num];\r\nif (!obd)\r\nreturn NULL;\r\nLASSERTF(obd->obd_magic == OBD_DEVICE_MAGIC,\r\n"%p obd_magic %08x != %08x\n",\r\nobd, obd->obd_magic, OBD_DEVICE_MAGIC);\r\nLASSERTF(obd->obd_minor == num,\r\n"%p obd_minor %0d != %0d\n",\r\nobd, obd->obd_minor, num);\r\n}\r\nreturn obd;\r\n}\r\nstruct obd_device *class_find_client_obd(struct obd_uuid *tgt_uuid,\r\nconst char *typ_name,\r\nstruct obd_uuid *grp_uuid)\r\n{\r\nint i;\r\nread_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (!obd)\r\ncontinue;\r\nif ((strncmp(obd->obd_type->typ_name, typ_name,\r\nstrlen(typ_name)) == 0)) {\r\nif (obd_uuid_equals(tgt_uuid,\r\n&obd->u.cli.cl_target_uuid) &&\r\n((grp_uuid) ? obd_uuid_equals(grp_uuid,\r\n&obd->obd_uuid) : 1)) {\r\nread_unlock(&obd_dev_lock);\r\nreturn obd;\r\n}\r\n}\r\n}\r\nread_unlock(&obd_dev_lock);\r\nreturn NULL;\r\n}\r\nstruct obd_device *class_devices_in_group(struct obd_uuid *grp_uuid, int *next)\r\n{\r\nint i;\r\nif (!next)\r\ni = 0;\r\nelse if (*next >= 0 && *next < class_devno_max())\r\ni = *next;\r\nelse\r\nreturn NULL;\r\nread_lock(&obd_dev_lock);\r\nfor (; i < class_devno_max(); i++) {\r\nstruct obd_device *obd = class_num2obd(i);\r\nif (!obd)\r\ncontinue;\r\nif (obd_uuid_equals(grp_uuid, &obd->obd_uuid)) {\r\nif (next)\r\n*next = i + 1;\r\nread_unlock(&obd_dev_lock);\r\nreturn obd;\r\n}\r\n}\r\nread_unlock(&obd_dev_lock);\r\nreturn NULL;\r\n}\r\nint class_notify_sptlrpc_conf(const char *fsname, int namelen)\r\n{\r\nstruct obd_device *obd;\r\nconst char *type;\r\nint i, rc = 0, rc2;\r\nLASSERT(namelen > 0);\r\nread_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nobd = class_num2obd(i);\r\nif (!obd || obd->obd_set_up == 0 || obd->obd_stopping)\r\ncontinue;\r\ntype = obd->obd_type->typ_name;\r\nif (strcmp(type, LUSTRE_MDC_NAME) != 0 &&\r\nstrcmp(type, LUSTRE_OSC_NAME) != 0 &&\r\nstrcmp(type, LUSTRE_MDT_NAME) != 0 &&\r\nstrcmp(type, LUSTRE_OST_NAME) != 0)\r\ncontinue;\r\nif (strncmp(obd->obd_name, fsname, namelen))\r\ncontinue;\r\nclass_incref(obd, __func__, obd);\r\nread_unlock(&obd_dev_lock);\r\nrc2 = obd_set_info_async(NULL, obd->obd_self_export,\r\nsizeof(KEY_SPTLRPC_CONF),\r\nKEY_SPTLRPC_CONF, 0, NULL, NULL);\r\nrc = rc ? rc : rc2;\r\nclass_decref(obd, __func__, obd);\r\nread_lock(&obd_dev_lock);\r\n}\r\nread_unlock(&obd_dev_lock);\r\nreturn rc;\r\n}\r\nvoid obd_cleanup_caches(void)\r\n{\r\nkmem_cache_destroy(obd_device_cachep);\r\nobd_device_cachep = NULL;\r\nkmem_cache_destroy(obdo_cachep);\r\nobdo_cachep = NULL;\r\nkmem_cache_destroy(import_cachep);\r\nimport_cachep = NULL;\r\n}\r\nint obd_init_caches(void)\r\n{\r\nLASSERT(!obd_device_cachep);\r\nobd_device_cachep = kmem_cache_create("ll_obd_dev_cache",\r\nsizeof(struct obd_device),\r\n0, 0, NULL);\r\nif (!obd_device_cachep)\r\ngoto out;\r\nLASSERT(!obdo_cachep);\r\nobdo_cachep = kmem_cache_create("ll_obdo_cache", sizeof(struct obdo),\r\n0, 0, NULL);\r\nif (!obdo_cachep)\r\ngoto out;\r\nLASSERT(!import_cachep);\r\nimport_cachep = kmem_cache_create("ll_import_cache",\r\nsizeof(struct obd_import),\r\n0, 0, NULL);\r\nif (!import_cachep)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nobd_cleanup_caches();\r\nreturn -ENOMEM;\r\n}\r\nstruct obd_export *class_conn2export(struct lustre_handle *conn)\r\n{\r\nstruct obd_export *export;\r\nif (!conn) {\r\nCDEBUG(D_CACHE, "looking for null handle\n");\r\nreturn NULL;\r\n}\r\nif (conn->cookie == -1) {\r\nCDEBUG(D_CACHE, "want a new connection\n");\r\nreturn NULL;\r\n}\r\nCDEBUG(D_INFO, "looking for export cookie %#llx\n", conn->cookie);\r\nexport = class_handle2object(conn->cookie, NULL);\r\nreturn export;\r\n}\r\nstruct obd_device *class_exp2obd(struct obd_export *exp)\r\n{\r\nif (exp)\r\nreturn exp->exp_obd;\r\nreturn NULL;\r\n}\r\nstruct obd_import *class_exp2cliimp(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nif (!obd)\r\nreturn NULL;\r\nreturn obd->u.cli.cl_import;\r\n}\r\nstatic void class_export_destroy(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nLASSERT_ATOMIC_ZERO(&exp->exp_refcount);\r\nLASSERT(obd);\r\nCDEBUG(D_IOCTL, "destroying export %p/%s for %s\n", exp,\r\nexp->exp_client_uuid.uuid, obd->obd_name);\r\nif (exp->exp_connection)\r\nptlrpc_put_connection_superhack(exp->exp_connection);\r\nLASSERT(list_empty(&exp->exp_outstanding_replies));\r\nLASSERT(list_empty(&exp->exp_uncommitted_replies));\r\nLASSERT(list_empty(&exp->exp_req_replay_queue));\r\nLASSERT(list_empty(&exp->exp_hp_rpcs));\r\nobd_destroy_export(exp);\r\nclass_decref(obd, "export", exp);\r\nOBD_FREE_RCU(exp, sizeof(*exp), &exp->exp_handle);\r\n}\r\nstatic void export_handle_addref(void *export)\r\n{\r\nclass_export_get(export);\r\n}\r\nstruct obd_export *class_export_get(struct obd_export *exp)\r\n{\r\natomic_inc(&exp->exp_refcount);\r\nCDEBUG(D_INFO, "GETting export %p : new refcount %d\n", exp,\r\natomic_read(&exp->exp_refcount));\r\nreturn exp;\r\n}\r\nvoid class_export_put(struct obd_export *exp)\r\n{\r\nLASSERT_ATOMIC_GT_LT(&exp->exp_refcount, 0, LI_POISON);\r\nCDEBUG(D_INFO, "PUTting export %p : new refcount %d\n", exp,\r\natomic_read(&exp->exp_refcount) - 1);\r\nif (atomic_dec_and_test(&exp->exp_refcount)) {\r\nLASSERT(!list_empty(&exp->exp_obd_chain));\r\nCDEBUG(D_IOCTL, "final put %p/%s\n",\r\nexp, exp->exp_client_uuid.uuid);\r\nlprocfs_exp_cleanup(exp);\r\nobd_zombie_export_add(exp);\r\n}\r\n}\r\nstruct obd_export *class_new_export(struct obd_device *obd,\r\nstruct obd_uuid *cluuid)\r\n{\r\nstruct obd_export *export;\r\nstruct cfs_hash *hash = NULL;\r\nint rc = 0;\r\nexport = kzalloc(sizeof(*export), GFP_NOFS);\r\nif (!export)\r\nreturn ERR_PTR(-ENOMEM);\r\nexport->exp_conn_cnt = 0;\r\nexport->exp_lock_hash = NULL;\r\nexport->exp_flock_hash = NULL;\r\natomic_set(&export->exp_refcount, 2);\r\natomic_set(&export->exp_rpc_count, 0);\r\natomic_set(&export->exp_cb_count, 0);\r\natomic_set(&export->exp_locks_count, 0);\r\n#if LUSTRE_TRACKS_LOCK_EXP_REFS\r\nINIT_LIST_HEAD(&export->exp_locks_list);\r\nspin_lock_init(&export->exp_locks_list_guard);\r\n#endif\r\natomic_set(&export->exp_replay_count, 0);\r\nexport->exp_obd = obd;\r\nINIT_LIST_HEAD(&export->exp_outstanding_replies);\r\nspin_lock_init(&export->exp_uncommitted_replies_lock);\r\nINIT_LIST_HEAD(&export->exp_uncommitted_replies);\r\nINIT_LIST_HEAD(&export->exp_req_replay_queue);\r\nINIT_LIST_HEAD(&export->exp_handle.h_link);\r\nINIT_LIST_HEAD(&export->exp_hp_rpcs);\r\nclass_handle_hash(&export->exp_handle, &export_handle_ops);\r\nspin_lock_init(&export->exp_lock);\r\nspin_lock_init(&export->exp_rpc_lock);\r\nINIT_HLIST_NODE(&export->exp_uuid_hash);\r\nspin_lock_init(&export->exp_bl_list_lock);\r\nINIT_LIST_HEAD(&export->exp_bl_list);\r\nexport->exp_sp_peer = LUSTRE_SP_ANY;\r\nexport->exp_flvr.sf_rpc = SPTLRPC_FLVR_INVALID;\r\nexport->exp_client_uuid = *cluuid;\r\nobd_init_export(export);\r\nspin_lock(&obd->obd_dev_lock);\r\nif (obd->obd_stopping) {\r\nrc = -ENODEV;\r\ngoto exit_unlock;\r\n}\r\nhash = cfs_hash_getref(obd->obd_uuid_hash);\r\nif (!hash) {\r\nrc = -ENODEV;\r\ngoto exit_unlock;\r\n}\r\nspin_unlock(&obd->obd_dev_lock);\r\nif (!obd_uuid_equals(cluuid, &obd->obd_uuid)) {\r\nrc = cfs_hash_add_unique(hash, cluuid, &export->exp_uuid_hash);\r\nif (rc != 0) {\r\nLCONSOLE_WARN("%s: denying duplicate export for %s, %d\n",\r\nobd->obd_name, cluuid->uuid, rc);\r\nrc = -EALREADY;\r\ngoto exit_err;\r\n}\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nif (obd->obd_stopping) {\r\ncfs_hash_del(hash, cluuid, &export->exp_uuid_hash);\r\nrc = -ENODEV;\r\ngoto exit_unlock;\r\n}\r\nclass_incref(obd, "export", export);\r\nlist_add(&export->exp_obd_chain, &export->exp_obd->obd_exports);\r\nexport->exp_obd->obd_num_exports++;\r\nspin_unlock(&obd->obd_dev_lock);\r\ncfs_hash_putref(hash);\r\nreturn export;\r\nexit_unlock:\r\nspin_unlock(&obd->obd_dev_lock);\r\nexit_err:\r\nif (hash)\r\ncfs_hash_putref(hash);\r\nclass_handle_unhash(&export->exp_handle);\r\nLASSERT(hlist_unhashed(&export->exp_uuid_hash));\r\nobd_destroy_export(export);\r\nkfree(export);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid class_unlink_export(struct obd_export *exp)\r\n{\r\nclass_handle_unhash(&exp->exp_handle);\r\nspin_lock(&exp->exp_obd->obd_dev_lock);\r\nif (!hlist_unhashed(&exp->exp_uuid_hash))\r\ncfs_hash_del(exp->exp_obd->obd_uuid_hash,\r\n&exp->exp_client_uuid,\r\n&exp->exp_uuid_hash);\r\nlist_move(&exp->exp_obd_chain, &exp->exp_obd->obd_unlinked_exports);\r\nexp->exp_obd->obd_num_exports--;\r\nspin_unlock(&exp->exp_obd->obd_dev_lock);\r\nclass_export_put(exp);\r\n}\r\nstatic void class_import_destroy(struct obd_import *imp)\r\n{\r\nCDEBUG(D_IOCTL, "destroying import %p for %s\n", imp,\r\nimp->imp_obd->obd_name);\r\nLASSERT_ATOMIC_ZERO(&imp->imp_refcount);\r\nptlrpc_put_connection_superhack(imp->imp_connection);\r\nwhile (!list_empty(&imp->imp_conn_list)) {\r\nstruct obd_import_conn *imp_conn;\r\nimp_conn = list_entry(imp->imp_conn_list.next,\r\nstruct obd_import_conn, oic_item);\r\nlist_del_init(&imp_conn->oic_item);\r\nptlrpc_put_connection_superhack(imp_conn->oic_conn);\r\nkfree(imp_conn);\r\n}\r\nLASSERT(!imp->imp_sec);\r\nclass_decref(imp->imp_obd, "import", imp);\r\nOBD_FREE_RCU(imp, sizeof(*imp), &imp->imp_handle);\r\n}\r\nstatic void import_handle_addref(void *import)\r\n{\r\nclass_import_get(import);\r\n}\r\nstruct obd_import *class_import_get(struct obd_import *import)\r\n{\r\natomic_inc(&import->imp_refcount);\r\nCDEBUG(D_INFO, "import %p refcount=%d obd=%s\n", import,\r\natomic_read(&import->imp_refcount),\r\nimport->imp_obd->obd_name);\r\nreturn import;\r\n}\r\nvoid class_import_put(struct obd_import *imp)\r\n{\r\nLASSERT(list_empty(&imp->imp_zombie_chain));\r\nLASSERT_ATOMIC_GT_LT(&imp->imp_refcount, 0, LI_POISON);\r\nCDEBUG(D_INFO, "import %p refcount=%d obd=%s\n", imp,\r\natomic_read(&imp->imp_refcount) - 1,\r\nimp->imp_obd->obd_name);\r\nif (atomic_dec_and_test(&imp->imp_refcount)) {\r\nCDEBUG(D_INFO, "final put import %p\n", imp);\r\nobd_zombie_import_add(imp);\r\n}\r\nLASSERT_ATOMIC_GE_LT(&imp->imp_refcount, 0, LI_POISON);\r\n}\r\nstatic void init_imp_at(struct imp_at *at)\r\n{\r\nint i;\r\nat_init(&at->iat_net_latency, 0, 0);\r\nfor (i = 0; i < IMP_AT_MAX_PORTALS; i++) {\r\nat_init(&at->iat_service_estimate[i], INITIAL_CONNECT_TIMEOUT,\r\nAT_FLG_NOHIST);\r\n}\r\n}\r\nstruct obd_import *class_new_import(struct obd_device *obd)\r\n{\r\nstruct obd_import *imp;\r\nimp = kzalloc(sizeof(*imp), GFP_NOFS);\r\nif (!imp)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&imp->imp_pinger_chain);\r\nINIT_LIST_HEAD(&imp->imp_zombie_chain);\r\nINIT_LIST_HEAD(&imp->imp_replay_list);\r\nINIT_LIST_HEAD(&imp->imp_sending_list);\r\nINIT_LIST_HEAD(&imp->imp_delayed_list);\r\nINIT_LIST_HEAD(&imp->imp_committed_list);\r\nINIT_LIST_HEAD(&imp->imp_unreplied_list);\r\nimp->imp_known_replied_xid = 0;\r\nimp->imp_replay_cursor = &imp->imp_committed_list;\r\nspin_lock_init(&imp->imp_lock);\r\nimp->imp_last_success_conn = 0;\r\nimp->imp_state = LUSTRE_IMP_NEW;\r\nimp->imp_obd = class_incref(obd, "import", imp);\r\nmutex_init(&imp->imp_sec_mutex);\r\ninit_waitqueue_head(&imp->imp_recovery_waitq);\r\natomic_set(&imp->imp_refcount, 2);\r\natomic_set(&imp->imp_unregistering, 0);\r\natomic_set(&imp->imp_inflight, 0);\r\natomic_set(&imp->imp_replay_inflight, 0);\r\natomic_set(&imp->imp_inval_count, 0);\r\nINIT_LIST_HEAD(&imp->imp_conn_list);\r\nINIT_LIST_HEAD(&imp->imp_handle.h_link);\r\nclass_handle_hash(&imp->imp_handle, &import_handle_ops);\r\ninit_imp_at(&imp->imp_at);\r\nimp->imp_msg_magic = LUSTRE_MSG_MAGIC_V2;\r\nreturn imp;\r\n}\r\nvoid class_destroy_import(struct obd_import *import)\r\n{\r\nLASSERT(import);\r\nLASSERT(import != LP_POISON);\r\nclass_handle_unhash(&import->imp_handle);\r\nspin_lock(&import->imp_lock);\r\nimport->imp_generation++;\r\nspin_unlock(&import->imp_lock);\r\nclass_import_put(import);\r\n}\r\nvoid __class_export_add_lock_ref(struct obd_export *exp, struct ldlm_lock *lock)\r\n{\r\nspin_lock(&exp->exp_locks_list_guard);\r\nLASSERT(lock->l_exp_refs_nr >= 0);\r\nif (lock->l_exp_refs_target && lock->l_exp_refs_target != exp) {\r\nLCONSOLE_WARN("setting export %p for lock %p which already has export %p\n",\r\nexp, lock, lock->l_exp_refs_target);\r\n}\r\nif ((lock->l_exp_refs_nr++) == 0) {\r\nlist_add(&lock->l_exp_refs_link, &exp->exp_locks_list);\r\nlock->l_exp_refs_target = exp;\r\n}\r\nCDEBUG(D_INFO, "lock = %p, export = %p, refs = %u\n",\r\nlock, exp, lock->l_exp_refs_nr);\r\nspin_unlock(&exp->exp_locks_list_guard);\r\n}\r\nvoid __class_export_del_lock_ref(struct obd_export *exp, struct ldlm_lock *lock)\r\n{\r\nspin_lock(&exp->exp_locks_list_guard);\r\nLASSERT(lock->l_exp_refs_nr > 0);\r\nif (lock->l_exp_refs_target != exp) {\r\nLCONSOLE_WARN("lock %p, mismatching export pointers: %p, %p\n",\r\nlock, lock->l_exp_refs_target, exp);\r\n}\r\nif (-- lock->l_exp_refs_nr == 0) {\r\nlist_del_init(&lock->l_exp_refs_link);\r\nlock->l_exp_refs_target = NULL;\r\n}\r\nCDEBUG(D_INFO, "lock = %p, export = %p, refs = %u\n",\r\nlock, exp, lock->l_exp_refs_nr);\r\nspin_unlock(&exp->exp_locks_list_guard);\r\n}\r\nint class_connect(struct lustre_handle *conn, struct obd_device *obd,\r\nstruct obd_uuid *cluuid)\r\n{\r\nstruct obd_export *export;\r\nLASSERT(conn);\r\nLASSERT(obd);\r\nLASSERT(cluuid);\r\nexport = class_new_export(obd, cluuid);\r\nif (IS_ERR(export))\r\nreturn PTR_ERR(export);\r\nconn->cookie = export->exp_handle.h_cookie;\r\nclass_export_put(export);\r\nCDEBUG(D_IOCTL, "connect: client %s, cookie %#llx\n",\r\ncluuid->uuid, conn->cookie);\r\nreturn 0;\r\n}\r\nint class_disconnect(struct obd_export *export)\r\n{\r\nint already_disconnected;\r\nif (!export) {\r\nCWARN("attempting to free NULL export %p\n", export);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&export->exp_lock);\r\nalready_disconnected = export->exp_disconnected;\r\nexport->exp_disconnected = 1;\r\nspin_unlock(&export->exp_lock);\r\nif (already_disconnected)\r\ngoto no_disconn;\r\nCDEBUG(D_IOCTL, "disconnect: cookie %#llx\n",\r\nexport->exp_handle.h_cookie);\r\nclass_unlink_export(export);\r\nno_disconn:\r\nclass_export_put(export);\r\nreturn 0;\r\n}\r\nvoid class_fail_export(struct obd_export *exp)\r\n{\r\nint rc, already_failed;\r\nspin_lock(&exp->exp_lock);\r\nalready_failed = exp->exp_failed;\r\nexp->exp_failed = 1;\r\nspin_unlock(&exp->exp_lock);\r\nif (already_failed) {\r\nCDEBUG(D_HA, "disconnecting dead export %p/%s; skipping\n",\r\nexp, exp->exp_client_uuid.uuid);\r\nreturn;\r\n}\r\nCDEBUG(D_HA, "disconnecting export %p/%s\n",\r\nexp, exp->exp_client_uuid.uuid);\r\nif (obd_dump_on_timeout)\r\nlibcfs_debug_dumplog();\r\nclass_export_get(exp);\r\nclass_export_get(exp);\r\nrc = obd_disconnect(exp);\r\nif (rc)\r\nCERROR("disconnecting export %p failed: %d\n", exp, rc);\r\nelse\r\nCDEBUG(D_HA, "disconnected export %p/%s\n",\r\nexp, exp->exp_client_uuid.uuid);\r\nclass_export_put(exp);\r\n}\r\nstatic void obd_zombie_impexp_cull(void)\r\n{\r\nstruct obd_import *import;\r\nstruct obd_export *export;\r\ndo {\r\nspin_lock(&obd_zombie_impexp_lock);\r\nimport = NULL;\r\nif (!list_empty(&obd_zombie_imports)) {\r\nimport = list_entry(obd_zombie_imports.next,\r\nstruct obd_import,\r\nimp_zombie_chain);\r\nlist_del_init(&import->imp_zombie_chain);\r\n}\r\nexport = NULL;\r\nif (!list_empty(&obd_zombie_exports)) {\r\nexport = list_entry(obd_zombie_exports.next,\r\nstruct obd_export,\r\nexp_obd_chain);\r\nlist_del_init(&export->exp_obd_chain);\r\n}\r\nspin_unlock(&obd_zombie_impexp_lock);\r\nif (import) {\r\nclass_import_destroy(import);\r\nspin_lock(&obd_zombie_impexp_lock);\r\nzombies_count--;\r\nspin_unlock(&obd_zombie_impexp_lock);\r\n}\r\nif (export) {\r\nclass_export_destroy(export);\r\nspin_lock(&obd_zombie_impexp_lock);\r\nzombies_count--;\r\nspin_unlock(&obd_zombie_impexp_lock);\r\n}\r\ncond_resched();\r\n} while (import || export);\r\n}\r\nstatic int obd_zombie_impexp_check(void *arg)\r\n{\r\nint rc;\r\nspin_lock(&obd_zombie_impexp_lock);\r\nrc = (zombies_count == 0) &&\r\n!test_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags);\r\nspin_unlock(&obd_zombie_impexp_lock);\r\nreturn rc;\r\n}\r\nstatic void obd_zombie_export_add(struct obd_export *exp)\r\n{\r\nspin_lock(&exp->exp_obd->obd_dev_lock);\r\nLASSERT(!list_empty(&exp->exp_obd_chain));\r\nlist_del_init(&exp->exp_obd_chain);\r\nspin_unlock(&exp->exp_obd->obd_dev_lock);\r\nspin_lock(&obd_zombie_impexp_lock);\r\nzombies_count++;\r\nlist_add(&exp->exp_obd_chain, &obd_zombie_exports);\r\nspin_unlock(&obd_zombie_impexp_lock);\r\nobd_zombie_impexp_notify();\r\n}\r\nstatic void obd_zombie_import_add(struct obd_import *imp)\r\n{\r\nLASSERT(!imp->imp_sec);\r\nspin_lock(&obd_zombie_impexp_lock);\r\nLASSERT(list_empty(&imp->imp_zombie_chain));\r\nzombies_count++;\r\nlist_add(&imp->imp_zombie_chain, &obd_zombie_imports);\r\nspin_unlock(&obd_zombie_impexp_lock);\r\nobd_zombie_impexp_notify();\r\n}\r\nstatic void obd_zombie_impexp_notify(void)\r\n{\r\nwake_up_all(&obd_zombie_waitq);\r\n}\r\nstatic int obd_zombie_is_idle(void)\r\n{\r\nint rc;\r\nLASSERT(!test_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags));\r\nspin_lock(&obd_zombie_impexp_lock);\r\nrc = (zombies_count == 0);\r\nspin_unlock(&obd_zombie_impexp_lock);\r\nreturn rc;\r\n}\r\nvoid obd_zombie_barrier(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nif (obd_zombie_pid == current_pid())\r\nreturn;\r\nl_wait_event(obd_zombie_waitq, obd_zombie_is_idle(), &lwi);\r\n}\r\nstatic int obd_zombie_impexp_thread(void *unused)\r\n{\r\nunshare_fs_struct();\r\ncomplete(&obd_zombie_start);\r\nobd_zombie_pid = current_pid();\r\nwhile (!test_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags)) {\r\nstruct l_wait_info lwi = { 0 };\r\nl_wait_event(obd_zombie_waitq,\r\n!obd_zombie_impexp_check(NULL), &lwi);\r\nobd_zombie_impexp_cull();\r\nwake_up(&obd_zombie_waitq);\r\n}\r\ncomplete(&obd_zombie_stop);\r\nreturn 0;\r\n}\r\nint obd_zombie_impexp_init(void)\r\n{\r\nstruct task_struct *task;\r\nINIT_LIST_HEAD(&obd_zombie_imports);\r\nINIT_LIST_HEAD(&obd_zombie_exports);\r\nspin_lock_init(&obd_zombie_impexp_lock);\r\ninit_completion(&obd_zombie_start);\r\ninit_completion(&obd_zombie_stop);\r\ninit_waitqueue_head(&obd_zombie_waitq);\r\nobd_zombie_pid = 0;\r\ntask = kthread_run(obd_zombie_impexp_thread, NULL, "obd_zombid");\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nwait_for_completion(&obd_zombie_start);\r\nreturn 0;\r\n}\r\nvoid obd_zombie_impexp_stop(void)\r\n{\r\nset_bit(OBD_ZOMBIE_STOP, &obd_zombie_flags);\r\nobd_zombie_impexp_notify();\r\nwait_for_completion(&obd_zombie_stop);\r\n}\r\nstatic bool obd_request_slot_avail(struct client_obd *cli,\r\nstruct obd_request_slot_waiter *orsw)\r\n{\r\nbool avail;\r\nspin_lock(&cli->cl_loi_list_lock);\r\navail = !!list_empty(&orsw->orsw_entry);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn avail;\r\n}\r\nint obd_get_request_slot(struct client_obd *cli)\r\n{\r\nstruct obd_request_slot_waiter orsw;\r\nstruct l_wait_info lwi;\r\nint rc;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nif (cli->cl_r_in_flight < cli->cl_max_rpcs_in_flight) {\r\ncli->cl_r_in_flight++;\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn 0;\r\n}\r\ninit_waitqueue_head(&orsw.orsw_waitq);\r\nlist_add_tail(&orsw.orsw_entry, &cli->cl_loi_read_list);\r\norsw.orsw_signaled = false;\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nlwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(orsw.orsw_waitq,\r\nobd_request_slot_avail(cli, &orsw) ||\r\norsw.orsw_signaled,\r\n&lwi);\r\nspin_lock(&cli->cl_loi_list_lock);\r\nif (rc) {\r\nif (!orsw.orsw_signaled) {\r\nif (list_empty(&orsw.orsw_entry))\r\ncli->cl_r_in_flight--;\r\nelse\r\nlist_del(&orsw.orsw_entry);\r\n}\r\n}\r\nif (orsw.orsw_signaled) {\r\nLASSERT(list_empty(&orsw.orsw_entry));\r\nrc = -EINTR;\r\n}\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn rc;\r\n}\r\nvoid obd_put_request_slot(struct client_obd *cli)\r\n{\r\nstruct obd_request_slot_waiter *orsw;\r\nspin_lock(&cli->cl_loi_list_lock);\r\ncli->cl_r_in_flight--;\r\nif (!list_empty(&cli->cl_loi_read_list) &&\r\nlikely(cli->cl_r_in_flight < cli->cl_max_rpcs_in_flight)) {\r\norsw = list_entry(cli->cl_loi_read_list.next,\r\nstruct obd_request_slot_waiter, orsw_entry);\r\nlist_del_init(&orsw->orsw_entry);\r\ncli->cl_r_in_flight++;\r\nwake_up(&orsw->orsw_waitq);\r\n}\r\nspin_unlock(&cli->cl_loi_list_lock);\r\n}\r\n__u32 obd_get_max_rpcs_in_flight(struct client_obd *cli)\r\n{\r\nreturn cli->cl_max_rpcs_in_flight;\r\n}\r\nint obd_set_max_rpcs_in_flight(struct client_obd *cli, __u32 max)\r\n{\r\nstruct obd_request_slot_waiter *orsw;\r\nconst char *typ_name;\r\n__u32 old;\r\nint diff;\r\nint rc;\r\nint i;\r\nif (max > OBD_MAX_RIF_MAX || max < 1)\r\nreturn -ERANGE;\r\ntyp_name = cli->cl_import->imp_obd->obd_type->typ_name;\r\nif (!strcmp(typ_name, LUSTRE_MDC_NAME)) {\r\nif (max < 2) {\r\nCERROR("%s: cannot set max_rpcs_in_flight to 1 because it must be higher than max_mod_rpcs_in_flight value\n",\r\ncli->cl_import->imp_obd->obd_name);\r\nreturn -ERANGE;\r\n}\r\nif (max <= cli->cl_max_mod_rpcs_in_flight) {\r\nrc = obd_set_max_mod_rpcs_in_flight(cli, max - 1);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nspin_lock(&cli->cl_loi_list_lock);\r\nold = cli->cl_max_rpcs_in_flight;\r\ncli->cl_max_rpcs_in_flight = max;\r\ndiff = max - old;\r\nfor (i = 0; i < diff; i++) {\r\nif (list_empty(&cli->cl_loi_read_list))\r\nbreak;\r\norsw = list_entry(cli->cl_loi_read_list.next,\r\nstruct obd_request_slot_waiter, orsw_entry);\r\nlist_del_init(&orsw->orsw_entry);\r\ncli->cl_r_in_flight++;\r\nwake_up(&orsw->orsw_waitq);\r\n}\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn 0;\r\n}\r\nint obd_set_max_mod_rpcs_in_flight(struct client_obd *cli, __u16 max)\r\n{\r\nstruct obd_connect_data *ocd;\r\nu16 maxmodrpcs;\r\nu16 prev;\r\nif (max > OBD_MAX_RIF_MAX || max < 1)\r\nreturn -ERANGE;\r\nif (max >= cli->cl_max_rpcs_in_flight) {\r\nCERROR("%s: can't set max_mod_rpcs_in_flight to a value (%hu) higher or equal to max_rpcs_in_flight value (%u)\n",\r\ncli->cl_import->imp_obd->obd_name,\r\nmax, cli->cl_max_rpcs_in_flight);\r\nreturn -ERANGE;\r\n}\r\nocd = &cli->cl_import->imp_connect_data;\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_MULTIMODRPCS)\r\nmaxmodrpcs = ocd->ocd_maxmodrpcs;\r\nelse\r\nmaxmodrpcs = 1;\r\nif (max > maxmodrpcs) {\r\nCERROR("%s: can't set max_mod_rpcs_in_flight to a value (%hu) higher than max_mod_rpcs_per_client value (%hu) returned by the server at connection\n",\r\ncli->cl_import->imp_obd->obd_name,\r\nmax, maxmodrpcs);\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&cli->cl_mod_rpcs_lock);\r\nprev = cli->cl_max_mod_rpcs_in_flight;\r\ncli->cl_max_mod_rpcs_in_flight = max;\r\nif (cli->cl_max_mod_rpcs_in_flight > prev)\r\nwake_up(&cli->cl_mod_rpcs_waitq);\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nreturn 0;\r\n}\r\nint obd_mod_rpc_stats_seq_show(struct client_obd *cli, struct seq_file *seq)\r\n{\r\nunsigned long mod_tot = 0, mod_cum;\r\nstruct timespec64 now;\r\nint i;\r\nktime_get_real_ts64(&now);\r\nspin_lock(&cli->cl_mod_rpcs_lock);\r\nseq_printf(seq, "snapshot_time: %llu.%9lu (secs.nsecs)\n",\r\n(s64)now.tv_sec, (unsigned long)now.tv_nsec);\r\nseq_printf(seq, "modify_RPCs_in_flight: %hu\n",\r\ncli->cl_mod_rpcs_in_flight);\r\nseq_puts(seq, "\n\t\t\tmodify\n");\r\nseq_puts(seq, "rpcs in flight rpcs %% cum %%\n");\r\nmod_tot = lprocfs_oh_sum(&cli->cl_mod_rpcs_hist);\r\nmod_cum = 0;\r\nfor (i = 0; i < OBD_HIST_MAX; i++) {\r\nunsigned long mod = cli->cl_mod_rpcs_hist.oh_buckets[i];\r\nmod_cum += mod;\r\nseq_printf(seq, "%d:\t\t%10lu %3lu %3lu\n",\r\ni, mod, pct(mod, mod_tot),\r\npct(mod_cum, mod_tot));\r\nif (mod_cum == mod_tot)\r\nbreak;\r\n}\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nreturn 0;\r\n}\r\nstatic inline bool obd_mod_rpc_slot_avail_locked(struct client_obd *cli,\r\nbool close_req)\r\n{\r\nbool avail;\r\navail = cli->cl_mod_rpcs_in_flight < cli->cl_max_mod_rpcs_in_flight ||\r\n(close_req && !cli->cl_close_rpcs_in_flight);\r\nreturn avail;\r\n}\r\nstatic inline bool obd_mod_rpc_slot_avail(struct client_obd *cli,\r\nbool close_req)\r\n{\r\nbool avail;\r\nspin_lock(&cli->cl_mod_rpcs_lock);\r\navail = obd_mod_rpc_slot_avail_locked(cli, close_req);\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nreturn avail;\r\n}\r\nu16 obd_get_mod_rpc_slot(struct client_obd *cli, __u32 opc,\r\nstruct lookup_intent *it)\r\n{\r\nstruct l_wait_info lwi = LWI_INTR(NULL, NULL);\r\nbool close_req = false;\r\nu16 i, max;\r\nif (it && (it->it_op == IT_GETATTR || it->it_op == IT_LOOKUP ||\r\nit->it_op == IT_LAYOUT || it->it_op == IT_READDIR))\r\nreturn 0;\r\nif (opc == MDS_CLOSE)\r\nclose_req = true;\r\ndo {\r\nspin_lock(&cli->cl_mod_rpcs_lock);\r\nmax = cli->cl_max_mod_rpcs_in_flight;\r\nif (obd_mod_rpc_slot_avail_locked(cli, close_req)) {\r\ncli->cl_mod_rpcs_in_flight++;\r\nif (close_req)\r\ncli->cl_close_rpcs_in_flight++;\r\nlprocfs_oh_tally(&cli->cl_mod_rpcs_hist,\r\ncli->cl_mod_rpcs_in_flight);\r\ni = find_first_zero_bit(cli->cl_mod_tag_bitmap,\r\nmax + 1);\r\nLASSERT(i < OBD_MAX_RIF_MAX);\r\nLASSERT(!test_and_set_bit(i, cli->cl_mod_tag_bitmap));\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nreturn i + 1;\r\n}\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nCDEBUG(D_RPCTRACE, "%s: sleeping for a modify RPC slot opc %u, max %hu\n",\r\ncli->cl_import->imp_obd->obd_name, opc, max);\r\nl_wait_event(cli->cl_mod_rpcs_waitq,\r\nobd_mod_rpc_slot_avail(cli, close_req), &lwi);\r\n} while (true);\r\n}\r\nvoid obd_put_mod_rpc_slot(struct client_obd *cli, u32 opc,\r\nstruct lookup_intent *it, u16 tag)\r\n{\r\nbool close_req = false;\r\nif (it && (it->it_op == IT_GETATTR || it->it_op == IT_LOOKUP ||\r\nit->it_op == IT_LAYOUT || it->it_op == IT_READDIR))\r\nreturn;\r\nif (opc == MDS_CLOSE)\r\nclose_req = true;\r\nspin_lock(&cli->cl_mod_rpcs_lock);\r\ncli->cl_mod_rpcs_in_flight--;\r\nif (close_req)\r\ncli->cl_close_rpcs_in_flight--;\r\nLASSERT(tag - 1 < OBD_MAX_RIF_MAX);\r\nLASSERT(test_and_clear_bit(tag - 1, cli->cl_mod_tag_bitmap) != 0);\r\nspin_unlock(&cli->cl_mod_rpcs_lock);\r\nwake_up(&cli->cl_mod_rpcs_waitq);\r\n}
