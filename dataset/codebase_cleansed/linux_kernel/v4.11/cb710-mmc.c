static void cb710_mmc_select_clock_divider(struct mmc_host *mmc, int hz)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nstruct pci_dev *pdev = cb710_slot_to_chip(slot)->pdev;\r\nu32 src_freq_idx;\r\nu32 divider_idx;\r\nint src_hz;\r\npci_read_config_dword(pdev, 0x48, &src_freq_idx);\r\nsrc_freq_idx = (src_freq_idx >> 16) & 0xF;\r\nsrc_hz = cb710_src_freq_mhz[src_freq_idx] * 1000000;\r\nfor (divider_idx = 0; divider_idx < CB710_MAX_DIVIDER_IDX; ++divider_idx) {\r\nif (hz >= src_hz >> cb710_clock_divider_log2[divider_idx])\r\nbreak;\r\n}\r\nif (src_freq_idx)\r\ndivider_idx |= 0x8;\r\nelse if (divider_idx == 0)\r\ndivider_idx = 1;\r\ncb710_pci_update_config_reg(pdev, 0x40, ~0xF0000000, divider_idx << 28);\r\ndev_dbg(cb710_slot_dev(slot),\r\n"clock set to %d Hz, wanted %d Hz; src_freq_idx = %d, divider_idx = %d|%d\n",\r\nsrc_hz >> cb710_clock_divider_log2[divider_idx & 7],\r\nhz, src_freq_idx, divider_idx & 7, divider_idx & 8);\r\n}\r\nstatic void __cb710_mmc_enable_irq(struct cb710_slot *slot,\r\nunsigned short enable, unsigned short mask)\r\n{\r\nmask |= CB710_MMC_IE_IRQ_ENABLE;\r\nenable = (cb710_read_port_16(slot, CB710_MMC_IRQ_ENABLE_PORT)\r\n& ~mask) | enable;\r\nif (enable)\r\nenable |= CB710_MMC_IE_IRQ_ENABLE;\r\ncb710_write_port_16(slot, CB710_MMC_IRQ_ENABLE_PORT, enable);\r\n}\r\nstatic void cb710_mmc_enable_irq(struct cb710_slot *slot,\r\nunsigned short enable, unsigned short mask)\r\n{\r\nstruct cb710_mmc_reader *reader = mmc_priv(cb710_slot_to_mmc(slot));\r\nunsigned long flags;\r\nspin_lock_irqsave(&reader->irq_lock, flags);\r\n__cb710_mmc_enable_irq(slot, enable, mask);\r\nspin_unlock_irqrestore(&reader->irq_lock, flags);\r\n}\r\nstatic void cb710_mmc_reset_events(struct cb710_slot *slot)\r\n{\r\ncb710_write_port_8(slot, CB710_MMC_STATUS0_PORT, 0xFF);\r\ncb710_write_port_8(slot, CB710_MMC_STATUS1_PORT, 0xFF);\r\ncb710_write_port_8(slot, CB710_MMC_STATUS2_PORT, 0xFF);\r\n}\r\nstatic void cb710_mmc_enable_4bit_data(struct cb710_slot *slot, int enable)\r\n{\r\nif (enable)\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT,\r\nCB710_MMC_C1_4BIT_DATA_BUS, 0);\r\nelse\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT,\r\n0, CB710_MMC_C1_4BIT_DATA_BUS);\r\n}\r\nstatic int cb710_check_event(struct cb710_slot *slot, u8 what)\r\n{\r\nu16 status;\r\nstatus = cb710_read_port_16(slot, CB710_MMC_STATUS_PORT);\r\nif (status & CB710_MMC_S0_FIFO_UNDERFLOW) {\r\ndev_dbg(cb710_slot_dev(slot),\r\n"CHECK : ignoring bit 6 in status %04X\n", status);\r\ncb710_write_port_8(slot, CB710_MMC_STATUS0_PORT,\r\nCB710_MMC_S0_FIFO_UNDERFLOW);\r\nstatus &= ~CB710_MMC_S0_FIFO_UNDERFLOW;\r\n}\r\nif (status & CB710_MMC_STATUS_ERROR_EVENTS) {\r\ndev_dbg(cb710_slot_dev(slot),\r\n"CHECK : returning EIO on status %04X\n", status);\r\ncb710_write_port_8(slot, CB710_MMC_STATUS0_PORT, status & 0xFF);\r\ncb710_write_port_8(slot, CB710_MMC_STATUS1_PORT,\r\nCB710_MMC_S1_RESET);\r\nreturn -EIO;\r\n}\r\nif ((status >> 8) & what) {\r\ncb710_write_port_8(slot, CB710_MMC_STATUS1_PORT, what);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cb710_wait_for_event(struct cb710_slot *slot, u8 what)\r\n{\r\nint err = 0;\r\nunsigned limit = 2000000;\r\n#ifdef CONFIG_CB710_DEBUG\r\nu32 e, x;\r\ne = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\r\n#endif\r\nwhile (!(err = cb710_check_event(slot, what))) {\r\nif (!--limit) {\r\ncb710_dump_regs(cb710_slot_to_chip(slot),\r\nCB710_DUMP_REGS_MMC);\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n#ifdef CONFIG_CB710_DEBUG\r\nx = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\r\nlimit = 2000000 - limit;\r\nif (limit > 100)\r\ndev_dbg(cb710_slot_dev(slot),\r\n"WAIT10: waited %d loops, what %d, entry val %08X, exit val %08X\n",\r\nlimit, what, e, x);\r\n#endif\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic int cb710_wait_while_busy(struct cb710_slot *slot, uint8_t mask)\r\n{\r\nunsigned limit = 500000;\r\nint err = 0;\r\n#ifdef CONFIG_CB710_DEBUG\r\nu32 e, x;\r\ne = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\r\n#endif\r\nwhile (cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT) & mask) {\r\nif (!--limit) {\r\ncb710_dump_regs(cb710_slot_to_chip(slot),\r\nCB710_DUMP_REGS_MMC);\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n#ifdef CONFIG_CB710_DEBUG\r\nx = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\r\nlimit = 500000 - limit;\r\nif (limit > 100)\r\ndev_dbg(cb710_slot_dev(slot),\r\n"WAIT12: waited %d loops, mask %02X, entry val %08X, exit val %08X\n",\r\nlimit, mask, e, x);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void cb710_mmc_set_transfer_size(struct cb710_slot *slot,\r\nsize_t count, size_t blocksize)\r\n{\r\ncb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\ncb710_write_port_32(slot, CB710_MMC_TRANSFER_SIZE_PORT,\r\n((count - 1) << 16)|(blocksize - 1));\r\ndev_vdbg(cb710_slot_dev(slot), "set up for %zu block%s of %zu bytes\n",\r\ncount, count == 1 ? "" : "s", blocksize);\r\n}\r\nstatic void cb710_mmc_fifo_hack(struct cb710_slot *slot)\r\n{\r\nu32 r1, r2;\r\nint ok = 0;\r\nr1 = cb710_read_port_32(slot, CB710_MMC_DATA_PORT);\r\nr2 = cb710_read_port_32(slot, CB710_MMC_DATA_PORT);\r\nif (cb710_read_port_8(slot, CB710_MMC_STATUS0_PORT)\r\n& CB710_MMC_S0_FIFO_UNDERFLOW) {\r\ncb710_write_port_8(slot, CB710_MMC_STATUS0_PORT,\r\nCB710_MMC_S0_FIFO_UNDERFLOW);\r\nok = 1;\r\n}\r\ndev_dbg(cb710_slot_dev(slot),\r\n"FIFO-read-hack: expected STATUS0 bit was %s\n",\r\nok ? "set." : "NOT SET!");\r\ndev_dbg(cb710_slot_dev(slot),\r\n"FIFO-read-hack: dwords ignored: %08X %08X - %s\n",\r\nr1, r2, (r1|r2) ? "BAD (NOT ZERO)!" : "ok");\r\n}\r\nstatic int cb710_mmc_receive_pio(struct cb710_slot *slot,\r\nstruct sg_mapping_iter *miter, size_t dw_count)\r\n{\r\nif (!(cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT) & CB710_MMC_S2_FIFO_READY)) {\r\nint err = cb710_wait_for_event(slot,\r\nCB710_MMC_S1_PIO_TRANSFER_DONE);\r\nif (err)\r\nreturn err;\r\n}\r\ncb710_sg_dwiter_write_from_io(miter,\r\nslot->iobase + CB710_MMC_DATA_PORT, dw_count);\r\nreturn 0;\r\n}\r\nstatic bool cb710_is_transfer_size_supported(struct mmc_data *data)\r\n{\r\nreturn !(data->blksz & 15 && (data->blocks != 1 || data->blksz != 8));\r\n}\r\nstatic int cb710_mmc_receive(struct cb710_slot *slot, struct mmc_data *data)\r\n{\r\nstruct sg_mapping_iter miter;\r\nsize_t len, blocks = data->blocks;\r\nint err = 0;\r\nif (unlikely(data->blksz & 15 && (data->blocks != 1 || data->blksz != 8)))\r\nreturn -EINVAL;\r\nsg_miter_start(&miter, data->sg, data->sg_len, SG_MITER_TO_SG);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\r\n15, CB710_MMC_C2_READ_PIO_SIZE_MASK);\r\ncb710_mmc_fifo_hack(slot);\r\nwhile (blocks-- > 0) {\r\nlen = data->blksz;\r\nwhile (len >= 16) {\r\nerr = cb710_mmc_receive_pio(slot, &miter, 4);\r\nif (err)\r\ngoto out;\r\nlen -= 16;\r\n}\r\nif (!len)\r\ncontinue;\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\r\nlen - 1, CB710_MMC_C2_READ_PIO_SIZE_MASK);\r\nlen = (len >= 8) ? 4 : 2;\r\nerr = cb710_mmc_receive_pio(slot, &miter, len);\r\nif (err)\r\ngoto out;\r\n}\r\nout:\r\nsg_miter_stop(&miter);\r\nreturn err;\r\n}\r\nstatic int cb710_mmc_send(struct cb710_slot *slot, struct mmc_data *data)\r\n{\r\nstruct sg_mapping_iter miter;\r\nsize_t len, blocks = data->blocks;\r\nint err = 0;\r\nif (unlikely(data->blocks > 1 && data->blksz & 15))\r\nreturn -EINVAL;\r\nsg_miter_start(&miter, data->sg, data->sg_len, SG_MITER_FROM_SG);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\r\n0, CB710_MMC_C2_READ_PIO_SIZE_MASK);\r\nwhile (blocks-- > 0) {\r\nlen = (data->blksz + 15) >> 4;\r\ndo {\r\nif (!(cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT)\r\n& CB710_MMC_S2_FIFO_EMPTY)) {\r\nerr = cb710_wait_for_event(slot,\r\nCB710_MMC_S1_PIO_TRANSFER_DONE);\r\nif (err)\r\ngoto out;\r\n}\r\ncb710_sg_dwiter_read_to_io(&miter,\r\nslot->iobase + CB710_MMC_DATA_PORT, 4);\r\n} while (--len);\r\n}\r\nout:\r\nsg_miter_stop(&miter);\r\nreturn err;\r\n}\r\nstatic u16 cb710_encode_cmd_flags(struct cb710_mmc_reader *reader,\r\nstruct mmc_command *cmd)\r\n{\r\nunsigned int flags = cmd->flags;\r\nu16 cb_flags = 0;\r\nswitch (flags & MMC_CMD_MASK) {\r\ncase MMC_CMD_AC: cb_flags = CB710_MMC_CMD_AC; break;\r\ncase MMC_CMD_ADTC: cb_flags = CB710_MMC_CMD_ADTC; break;\r\ncase MMC_CMD_BC: cb_flags = CB710_MMC_CMD_BC; break;\r\ncase MMC_CMD_BCR: cb_flags = CB710_MMC_CMD_BCR; break;\r\n}\r\nif (flags & MMC_RSP_BUSY)\r\ncb_flags |= CB710_MMC_RSP_BUSY;\r\ncb_flags |= cmd->opcode << CB710_MMC_CMD_CODE_SHIFT;\r\nif (cmd->data && (cmd->data->flags & MMC_DATA_READ))\r\ncb_flags |= CB710_MMC_DATA_READ;\r\nif (flags & MMC_RSP_PRESENT) {\r\ncb_flags |= CB710_MMC_RSP_PRESENT;\r\nif (flags & MMC_RSP_136)\r\ncb_flags |= CB710_MMC_RSP_136;\r\nif (!(flags & MMC_RSP_CRC))\r\ncb_flags |= CB710_MMC_RSP_NO_CRC;\r\n}\r\nreturn cb_flags;\r\n}\r\nstatic void cb710_receive_response(struct cb710_slot *slot,\r\nstruct mmc_command *cmd)\r\n{\r\nunsigned rsp_opcode, wanted_opcode;\r\nif (cmd->flags & MMC_RSP_136) {\r\nu32 resp[4];\r\nresp[0] = cb710_read_port_32(slot, CB710_MMC_RESPONSE3_PORT);\r\nresp[1] = cb710_read_port_32(slot, CB710_MMC_RESPONSE2_PORT);\r\nresp[2] = cb710_read_port_32(slot, CB710_MMC_RESPONSE1_PORT);\r\nresp[3] = cb710_read_port_32(slot, CB710_MMC_RESPONSE0_PORT);\r\nrsp_opcode = resp[0] >> 24;\r\ncmd->resp[0] = (resp[0] << 8)|(resp[1] >> 24);\r\ncmd->resp[1] = (resp[1] << 8)|(resp[2] >> 24);\r\ncmd->resp[2] = (resp[2] << 8)|(resp[3] >> 24);\r\ncmd->resp[3] = (resp[3] << 8);\r\n} else {\r\nrsp_opcode = cb710_read_port_32(slot, CB710_MMC_RESPONSE1_PORT) & 0x3F;\r\ncmd->resp[0] = cb710_read_port_32(slot, CB710_MMC_RESPONSE0_PORT);\r\n}\r\nwanted_opcode = (cmd->flags & MMC_RSP_OPCODE) ? cmd->opcode : 0x3F;\r\nif (rsp_opcode != wanted_opcode)\r\ncmd->error = -EILSEQ;\r\n}\r\nstatic int cb710_mmc_transfer_data(struct cb710_slot *slot,\r\nstruct mmc_data *data)\r\n{\r\nint error, to;\r\nif (data->flags & MMC_DATA_READ)\r\nerror = cb710_mmc_receive(slot, data);\r\nelse\r\nerror = cb710_mmc_send(slot, data);\r\nto = cb710_wait_for_event(slot, CB710_MMC_S1_DATA_TRANSFER_DONE);\r\nif (!error)\r\nerror = to;\r\nif (!error)\r\ndata->bytes_xfered = data->blksz * data->blocks;\r\nreturn error;\r\n}\r\nstatic int cb710_mmc_command(struct mmc_host *mmc, struct mmc_command *cmd)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\nstruct mmc_data *data = cmd->data;\r\nu16 cb_cmd = cb710_encode_cmd_flags(reader, cmd);\r\ndev_dbg(cb710_slot_dev(slot), "cmd request: 0x%04X\n", cb_cmd);\r\nif (data) {\r\nif (!cb710_is_transfer_size_supported(data)) {\r\ndata->error = -EINVAL;\r\nreturn -1;\r\n}\r\ncb710_mmc_set_transfer_size(slot, data->blocks, data->blksz);\r\n}\r\ncb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20|CB710_MMC_S2_BUSY_10);\r\ncb710_write_port_16(slot, CB710_MMC_CMD_TYPE_PORT, cb_cmd);\r\ncb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\ncb710_write_port_32(slot, CB710_MMC_CMD_PARAM_PORT, cmd->arg);\r\ncb710_mmc_reset_events(slot);\r\ncb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x01, 0);\r\ncmd->error = cb710_wait_for_event(slot, CB710_MMC_S1_COMMAND_SENT);\r\nif (cmd->error)\r\nreturn -1;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\ncb710_receive_response(slot, cmd);\r\nif (cmd->error)\r\nreturn -1;\r\n}\r\nif (data)\r\ndata->error = cb710_mmc_transfer_data(slot, data);\r\nreturn 0;\r\n}\r\nstatic void cb710_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\nWARN_ON(reader->mrq != NULL);\r\nreader->mrq = mrq;\r\ncb710_mmc_enable_irq(slot, CB710_MMC_IE_TEST_MASK, 0);\r\nif (!cb710_mmc_command(mmc, mrq->cmd) && mrq->stop)\r\ncb710_mmc_command(mmc, mrq->stop);\r\ntasklet_schedule(&reader->finish_req_tasklet);\r\n}\r\nstatic int cb710_mmc_powerup(struct cb710_slot *slot)\r\n{\r\n#ifdef CONFIG_CB710_DEBUG\r\nstruct cb710_chip *chip = cb710_slot_to_chip(slot);\r\n#endif\r\nint err;\r\ndev_dbg(cb710_slot_dev(slot), "bus powerup\n");\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nerr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\nif (unlikely(err))\r\nreturn err;\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x80, 0);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0x80, 0);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nmdelay(1);\r\ndev_dbg(cb710_slot_dev(slot), "after delay 1\n");\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nerr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\nif (unlikely(err))\r\nreturn err;\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x09, 0);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nmdelay(1);\r\ndev_dbg(cb710_slot_dev(slot), "after delay 2\n");\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nerr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\nif (unlikely(err))\r\nreturn err;\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0, 0x08);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nmdelay(2);\r\ndev_dbg(cb710_slot_dev(slot), "after delay 3\n");\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x06, 0);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x70, 0);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT, 0x80, 0);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0x03, 0);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\nerr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\r\nif (unlikely(err))\r\nreturn err;\r\ncb710_write_port_16(slot, CB710_MMC_CONFIGB_PORT, 0xFFFF);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x06, 0);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\ndev_dbg(cb710_slot_dev(slot), "bus powerup finished\n");\r\nreturn cb710_check_event(slot, 0);\r\n}\r\nstatic void cb710_mmc_powerdown(struct cb710_slot *slot)\r\n{\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0, 0x81);\r\ncb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0, 0x80);\r\n}\r\nstatic void cb710_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\nint err;\r\ncb710_mmc_select_clock_divider(mmc, ios->clock);\r\nif (ios->power_mode != reader->last_power_mode)\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_ON:\r\nerr = cb710_mmc_powerup(slot);\r\nif (err) {\r\ndev_warn(cb710_slot_dev(slot),\r\n"powerup failed (%d)- retrying\n", err);\r\ncb710_mmc_powerdown(slot);\r\nudelay(1);\r\nerr = cb710_mmc_powerup(slot);\r\nif (err)\r\ndev_warn(cb710_slot_dev(slot),\r\n"powerup retry failed (%d) - expect errors\n",\r\nerr);\r\n}\r\nreader->last_power_mode = MMC_POWER_ON;\r\nbreak;\r\ncase MMC_POWER_OFF:\r\ncb710_mmc_powerdown(slot);\r\nreader->last_power_mode = MMC_POWER_OFF;\r\nbreak;\r\ncase MMC_POWER_UP:\r\ndefault:\r\n;\r\n}\r\ncb710_mmc_enable_4bit_data(slot, ios->bus_width != MMC_BUS_WIDTH_1);\r\ncb710_mmc_enable_irq(slot, CB710_MMC_IE_TEST_MASK, 0);\r\n}\r\nstatic int cb710_mmc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nreturn cb710_read_port_8(slot, CB710_MMC_STATUS3_PORT)\r\n& CB710_MMC_S3_WRITE_PROTECTED;\r\n}\r\nstatic int cb710_mmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\r\nreturn cb710_read_port_8(slot, CB710_MMC_STATUS3_PORT)\r\n& CB710_MMC_S3_CARD_DETECTED;\r\n}\r\nstatic int cb710_mmc_irq_handler(struct cb710_slot *slot)\r\n{\r\nstruct mmc_host *mmc = cb710_slot_to_mmc(slot);\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\nu32 status, config1, config2, irqen;\r\nstatus = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\r\nirqen = cb710_read_port_32(slot, CB710_MMC_IRQ_ENABLE_PORT);\r\nconfig2 = cb710_read_port_32(slot, CB710_MMC_CONFIGB_PORT);\r\nconfig1 = cb710_read_port_32(slot, CB710_MMC_CONFIG_PORT);\r\ndev_dbg(cb710_slot_dev(slot), "interrupt; status: %08X, "\r\n"ie: %08X, c2: %08X, c1: %08X\n",\r\nstatus, irqen, config2, config1);\r\nif (status & (CB710_MMC_S1_CARD_CHANGED << 8)) {\r\ncb710_write_port_8(slot, CB710_MMC_STATUS1_PORT,\r\nCB710_MMC_S1_CARD_CHANGED);\r\nif ((irqen & CB710_MMC_IE_CISTATUS_MASK)\r\n== CB710_MMC_IE_CISTATUS_MASK)\r\nmmc_detect_change(mmc, HZ/5);\r\n} else {\r\ndev_dbg(cb710_slot_dev(slot), "unknown interrupt (test)\n");\r\nspin_lock(&reader->irq_lock);\r\n__cb710_mmc_enable_irq(slot, 0, CB710_MMC_IE_TEST_MASK);\r\nspin_unlock(&reader->irq_lock);\r\n}\r\nreturn 1;\r\n}\r\nstatic void cb710_mmc_finish_request_tasklet(unsigned long data)\r\n{\r\nstruct mmc_host *mmc = (void *)data;\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\nstruct mmc_request *mrq = reader->mrq;\r\nreader->mrq = NULL;\r\nmmc_request_done(mmc, mrq);\r\n}\r\nstatic int cb710_mmc_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\r\ncb710_mmc_enable_irq(slot, 0, ~0);\r\nreturn 0;\r\n}\r\nstatic int cb710_mmc_resume(struct platform_device *pdev)\r\n{\r\nstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\r\ncb710_mmc_enable_irq(slot, 0, ~0);\r\nreturn 0;\r\n}\r\nstatic int cb710_mmc_init(struct platform_device *pdev)\r\n{\r\nstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\r\nstruct cb710_chip *chip = cb710_slot_to_chip(slot);\r\nstruct mmc_host *mmc;\r\nstruct cb710_mmc_reader *reader;\r\nint err;\r\nu32 val;\r\nmmc = mmc_alloc_host(sizeof(*reader), cb710_slot_dev(slot));\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mmc);\r\npci_read_config_dword(chip->pdev, 0x48, &val);\r\nval = cb710_src_freq_mhz[(val >> 16) & 0xF];\r\ndev_dbg(cb710_slot_dev(slot), "source frequency: %dMHz\n", val);\r\nval *= 1000000;\r\nmmc->ops = &cb710_mmc_host;\r\nmmc->f_max = val;\r\nmmc->f_min = val >> cb710_clock_divider_log2[CB710_MAX_DIVIDER_IDX];\r\nmmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nreader = mmc_priv(mmc);\r\ntasklet_init(&reader->finish_req_tasklet,\r\ncb710_mmc_finish_request_tasklet, (unsigned long)mmc);\r\nspin_lock_init(&reader->irq_lock);\r\ncb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\r\ncb710_mmc_enable_irq(slot, 0, ~0);\r\ncb710_set_irq_handler(slot, cb710_mmc_irq_handler);\r\nerr = mmc_add_host(mmc);\r\nif (unlikely(err))\r\ngoto err_free_mmc;\r\ndev_dbg(cb710_slot_dev(slot), "mmc_hostname is %s\n",\r\nmmc_hostname(mmc));\r\ncb710_mmc_enable_irq(slot, CB710_MMC_IE_CARD_INSERTION_STATUS, 0);\r\nreturn 0;\r\nerr_free_mmc:\r\ndev_dbg(cb710_slot_dev(slot), "mmc_add_host() failed: %d\n", err);\r\ncb710_set_irq_handler(slot, NULL);\r\nmmc_free_host(mmc);\r\nreturn err;\r\n}\r\nstatic int cb710_mmc_exit(struct platform_device *pdev)\r\n{\r\nstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\r\nstruct mmc_host *mmc = cb710_slot_to_mmc(slot);\r\nstruct cb710_mmc_reader *reader = mmc_priv(mmc);\r\ncb710_mmc_enable_irq(slot, 0, CB710_MMC_IE_CARD_INSERTION_STATUS);\r\nmmc_remove_host(mmc);\r\ncb710_mmc_enable_irq(slot, 0, ~0);\r\ncb710_set_irq_handler(slot, NULL);\r\ncb710_write_port_32(slot, CB710_MMC_CONFIG_PORT, 0);\r\ncb710_write_port_16(slot, CB710_MMC_CONFIGB_PORT, 0);\r\ntasklet_kill(&reader->finish_req_tasklet);\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}
