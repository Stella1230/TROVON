static void solo_set_time(struct solo_dev *solo_dev)\r\n{\r\nstruct timespec ts;\r\nktime_get_ts(&ts);\r\nsolo_reg_write(solo_dev, SOLO_TIMER_SEC, ts.tv_sec);\r\nsolo_reg_write(solo_dev, SOLO_TIMER_USEC, ts.tv_nsec / NSEC_PER_USEC);\r\n}\r\nstatic void solo_timer_sync(struct solo_dev *solo_dev)\r\n{\r\nu32 sec, usec;\r\nstruct timespec ts;\r\nlong diff;\r\nif (solo_dev->type != SOLO_DEV_6110)\r\nreturn;\r\nif (++solo_dev->time_sync < 60)\r\nreturn;\r\nsolo_dev->time_sync = 0;\r\nsec = solo_reg_read(solo_dev, SOLO_TIMER_SEC);\r\nusec = solo_reg_read(solo_dev, SOLO_TIMER_USEC);\r\nktime_get_ts(&ts);\r\ndiff = (long)ts.tv_sec - (long)sec;\r\ndiff = (diff * 1000000)\r\n+ ((long)(ts.tv_nsec / NSEC_PER_USEC) - (long)usec);\r\nif (diff > 1000 || diff < -1000) {\r\nsolo_set_time(solo_dev);\r\n} else if (diff) {\r\nlong usec_lsb = solo_dev->usec_lsb;\r\nusec_lsb -= diff / 4;\r\nif (usec_lsb < 0)\r\nusec_lsb = 0;\r\nelse if (usec_lsb > 255)\r\nusec_lsb = 255;\r\nsolo_dev->usec_lsb = usec_lsb;\r\nsolo_reg_write(solo_dev, SOLO_TIMER_USEC_LSB,\r\nsolo_dev->usec_lsb);\r\n}\r\n}\r\nstatic irqreturn_t solo_isr(int irq, void *data)\r\n{\r\nstruct solo_dev *solo_dev = data;\r\nu32 status;\r\nint i;\r\nstatus = solo_reg_read(solo_dev, SOLO_IRQ_STAT);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nsolo_reg_write(solo_dev, SOLO_IRQ_STAT, status);\r\nif (status & SOLO_IRQ_PCI_ERR)\r\nsolo_p2m_error_isr(solo_dev);\r\nfor (i = 0; i < SOLO_NR_P2M; i++)\r\nif (status & SOLO_IRQ_P2M(i))\r\nsolo_p2m_isr(solo_dev, i);\r\nif (status & SOLO_IRQ_IIC)\r\nsolo_i2c_isr(solo_dev);\r\nif (status & SOLO_IRQ_VIDEO_IN) {\r\nsolo_video_in_isr(solo_dev);\r\nsolo_timer_sync(solo_dev);\r\n}\r\nif (status & SOLO_IRQ_ENCODER)\r\nsolo_enc_v4l2_isr(solo_dev);\r\nif (status & SOLO_IRQ_G723)\r\nsolo_g723_isr(solo_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void free_solo_dev(struct solo_dev *solo_dev)\r\n{\r\nstruct pci_dev *pdev = solo_dev->pdev;\r\nif (solo_dev->dev.parent)\r\ndevice_unregister(&solo_dev->dev);\r\nif (solo_dev->reg_base) {\r\nsolo_g723_exit(solo_dev);\r\nsolo_enc_v4l2_exit(solo_dev);\r\nsolo_enc_exit(solo_dev);\r\nsolo_v4l2_exit(solo_dev);\r\nsolo_disp_exit(solo_dev);\r\nsolo_gpio_exit(solo_dev);\r\nsolo_p2m_exit(solo_dev);\r\nsolo_i2c_exit(solo_dev);\r\nsolo_irq_off(solo_dev, ~0);\r\nfree_irq(pdev->irq, solo_dev);\r\npci_iounmap(pdev, solo_dev->reg_base);\r\n}\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nv4l2_device_unregister(&solo_dev->v4l2_dev);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(solo_dev);\r\n}\r\nstatic ssize_t eeprom_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nu16 *p = (u16 *)buf;\r\nint i;\r\nif (count & 0x1)\r\ndev_warn(dev, "EEPROM Write not aligned (truncating)\n");\r\nif (!full_eeprom && count > 64) {\r\ndev_warn(dev, "EEPROM Write truncated to 64 bytes\n");\r\ncount = 64;\r\n} else if (full_eeprom && count > 128) {\r\ndev_warn(dev, "EEPROM Write truncated to 128 bytes\n");\r\ncount = 128;\r\n}\r\nsolo_eeprom_ewen(solo_dev, 1);\r\nfor (i = full_eeprom ? 0 : 32; i < min((int)(full_eeprom ? 64 : 32),\r\n(int)(count / 2)); i++)\r\nsolo_eeprom_write(solo_dev, i, cpu_to_be16(p[i]));\r\nsolo_eeprom_ewen(solo_dev, 0);\r\nreturn count;\r\n}\r\nstatic ssize_t eeprom_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nu16 *p = (u16 *)buf;\r\nint count = (full_eeprom ? 128 : 64);\r\nint i;\r\nfor (i = (full_eeprom ? 0 : 32); i < (count / 2); i++)\r\np[i] = be16_to_cpu(solo_eeprom_read(solo_dev, i));\r\nreturn count;\r\n}\r\nstatic ssize_t p2m_timeouts_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nreturn sprintf(buf, "%d\n", solo_dev->p2m_timeouts);\r\n}\r\nstatic ssize_t sdram_size_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nreturn sprintf(buf, "%dMegs\n", solo_dev->sdram_size >> 20);\r\n}\r\nstatic ssize_t tw28xx_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nreturn sprintf(buf, "tw2815[%d] tw2864[%d] tw2865[%d]\n",\r\nhweight32(solo_dev->tw2815),\r\nhweight32(solo_dev->tw2864),\r\nhweight32(solo_dev->tw2865));\r\n}\r\nstatic ssize_t input_map_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nunsigned int val;\r\nchar *out = buf;\r\nval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_0);\r\nout += sprintf(out, "Channel 0 => Input %d\n", val & 0x1f);\r\nout += sprintf(out, "Channel 1 => Input %d\n", (val >> 5) & 0x1f);\r\nout += sprintf(out, "Channel 2 => Input %d\n", (val >> 10) & 0x1f);\r\nout += sprintf(out, "Channel 3 => Input %d\n", (val >> 15) & 0x1f);\r\nout += sprintf(out, "Channel 4 => Input %d\n", (val >> 20) & 0x1f);\r\nout += sprintf(out, "Channel 5 => Input %d\n", (val >> 25) & 0x1f);\r\nval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_1);\r\nout += sprintf(out, "Channel 6 => Input %d\n", val & 0x1f);\r\nout += sprintf(out, "Channel 7 => Input %d\n", (val >> 5) & 0x1f);\r\nout += sprintf(out, "Channel 8 => Input %d\n", (val >> 10) & 0x1f);\r\nout += sprintf(out, "Channel 9 => Input %d\n", (val >> 15) & 0x1f);\r\nout += sprintf(out, "Channel 10 => Input %d\n", (val >> 20) & 0x1f);\r\nout += sprintf(out, "Channel 11 => Input %d\n", (val >> 25) & 0x1f);\r\nval = solo_reg_read(solo_dev, SOLO_VI_CH_SWITCH_2);\r\nout += sprintf(out, "Channel 12 => Input %d\n", val & 0x1f);\r\nout += sprintf(out, "Channel 13 => Input %d\n", (val >> 5) & 0x1f);\r\nout += sprintf(out, "Channel 14 => Input %d\n", (val >> 10) & 0x1f);\r\nout += sprintf(out, "Channel 15 => Input %d\n", (val >> 15) & 0x1f);\r\nout += sprintf(out, "Spot Output => Input %d\n", (val >> 20) & 0x1f);\r\nreturn out - buf;\r\n}\r\nstatic ssize_t p2m_timeout_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nunsigned long ms;\r\nint ret = kstrtoul(buf, 10, &ms);\r\nif (ret < 0 || ms > 200)\r\nreturn -EINVAL;\r\nsolo_dev->p2m_jiffies = msecs_to_jiffies(ms);\r\nreturn count;\r\n}\r\nstatic ssize_t p2m_timeout_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nreturn sprintf(buf, "%ums\n", jiffies_to_msecs(solo_dev->p2m_jiffies));\r\n}\r\nstatic ssize_t intervals_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nchar *out = buf;\r\nint fps = solo_dev->fps;\r\nint i;\r\nfor (i = 0; i < solo_dev->nr_chans; i++) {\r\nout += sprintf(out, "Channel %d: %d/%d (0x%08x)\n",\r\ni, solo_dev->v4l2_enc[i]->interval, fps,\r\nsolo_reg_read(solo_dev, SOLO_CAP_CH_INTV(i)));\r\n}\r\nreturn out - buf;\r\n}\r\nstatic ssize_t sdram_offsets_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nchar *out = buf;\r\nout += sprintf(out, "DISP: 0x%08x @ 0x%08x\n",\r\nSOLO_DISP_EXT_ADDR,\r\nSOLO_DISP_EXT_SIZE);\r\nout += sprintf(out, "EOSD: 0x%08x @ 0x%08x (0x%08x * %d)\n",\r\nSOLO_EOSD_EXT_ADDR,\r\nSOLO_EOSD_EXT_AREA(solo_dev),\r\nSOLO_EOSD_EXT_SIZE(solo_dev),\r\nSOLO_EOSD_EXT_AREA(solo_dev) /\r\nSOLO_EOSD_EXT_SIZE(solo_dev));\r\nout += sprintf(out, "MOTI: 0x%08x @ 0x%08x\n",\r\nSOLO_MOTION_EXT_ADDR(solo_dev),\r\nSOLO_MOTION_EXT_SIZE);\r\nout += sprintf(out, "G723: 0x%08x @ 0x%08x\n",\r\nSOLO_G723_EXT_ADDR(solo_dev),\r\nSOLO_G723_EXT_SIZE);\r\nout += sprintf(out, "CAPT: 0x%08x @ 0x%08x (0x%08x * %d)\n",\r\nSOLO_CAP_EXT_ADDR(solo_dev),\r\nSOLO_CAP_EXT_SIZE(solo_dev),\r\nSOLO_CAP_PAGE_SIZE,\r\nSOLO_CAP_EXT_SIZE(solo_dev) / SOLO_CAP_PAGE_SIZE);\r\nout += sprintf(out, "EREF: 0x%08x @ 0x%08x (0x%08x * %d)\n",\r\nSOLO_EREF_EXT_ADDR(solo_dev),\r\nSOLO_EREF_EXT_AREA(solo_dev),\r\nSOLO_EREF_EXT_SIZE,\r\nSOLO_EREF_EXT_AREA(solo_dev) / SOLO_EREF_EXT_SIZE);\r\nout += sprintf(out, "MPEG: 0x%08x @ 0x%08x\n",\r\nSOLO_MP4E_EXT_ADDR(solo_dev),\r\nSOLO_MP4E_EXT_SIZE(solo_dev));\r\nout += sprintf(out, "JPEG: 0x%08x @ 0x%08x\n",\r\nSOLO_JPEG_EXT_ADDR(solo_dev),\r\nSOLO_JPEG_EXT_SIZE(solo_dev));\r\nreturn out - buf;\r\n}\r\nstatic ssize_t sdram_show(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *a, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct solo_dev *solo_dev =\r\ncontainer_of(dev, struct solo_dev, dev);\r\nconst int size = solo_dev->sdram_size;\r\nif (off >= size)\r\nreturn 0;\r\nif (off + count > size)\r\ncount = size - off;\r\nif (solo_p2m_dma(solo_dev, 0, buf, off, count, 0, 0))\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic void solo_device_release(struct device *dev)\r\n{\r\n}\r\nstatic int solo_sysfs_init(struct solo_dev *solo_dev)\r\n{\r\nstruct bin_attribute *sdram_attr = &solo_dev->sdram_attr;\r\nstruct device *dev = &solo_dev->dev;\r\nconst char *driver;\r\nint i;\r\nif (solo_dev->type == SOLO_DEV_6110)\r\ndriver = "solo6110";\r\nelse\r\ndriver = "solo6010";\r\ndev->release = solo_device_release;\r\ndev->parent = &solo_dev->pdev->dev;\r\nset_dev_node(dev, dev_to_node(&solo_dev->pdev->dev));\r\ndev_set_name(dev, "%s-%d-%d", driver, solo_dev->vfd->num,\r\nsolo_dev->nr_chans);\r\nif (device_register(dev)) {\r\ndev->parent = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(solo_dev_attrs); i++) {\r\nif (device_create_file(dev, &solo_dev_attrs[i])) {\r\ndevice_unregister(dev);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nsysfs_attr_init(&sdram_attr->attr);\r\nsdram_attr->attr.name = "sdram";\r\nsdram_attr->attr.mode = 0440;\r\nsdram_attr->read = sdram_show;\r\nsdram_attr->size = solo_dev->sdram_size;\r\nif (device_create_bin_file(dev, sdram_attr)) {\r\ndevice_unregister(dev);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int solo_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct solo_dev *solo_dev;\r\nint ret;\r\nu8 chip_id;\r\nsolo_dev = kzalloc(sizeof(*solo_dev), GFP_KERNEL);\r\nif (solo_dev == NULL)\r\nreturn -ENOMEM;\r\nif (id->driver_data == SOLO_DEV_6010)\r\ndev_info(&pdev->dev, "Probing Softlogic 6010\n");\r\nelse\r\ndev_info(&pdev->dev, "Probing Softlogic 6110\n");\r\nsolo_dev->type = id->driver_data;\r\nsolo_dev->pdev = pdev;\r\nret = v4l2_device_register(&pdev->dev, &solo_dev->v4l2_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nsolo_dev->p2m_jiffies = msecs_to_jiffies(100);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\ngoto fail_probe;\r\npci_set_master(pdev);\r\npci_write_config_byte(pdev, 0x40, 0x00);\r\npci_write_config_byte(pdev, 0x41, 0x00);\r\nret = pci_request_regions(pdev, SOLO6X10_NAME);\r\nif (ret)\r\ngoto fail_probe;\r\nsolo_dev->reg_base = pci_ioremap_bar(pdev, 0);\r\nif (solo_dev->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto fail_probe;\r\n}\r\nchip_id = solo_reg_read(solo_dev, SOLO_CHIP_OPTION) &\r\nSOLO_CHIP_ID_MASK;\r\nswitch (chip_id) {\r\ncase 7:\r\nsolo_dev->nr_chans = 16;\r\nsolo_dev->nr_ext = 5;\r\nbreak;\r\ncase 6:\r\nsolo_dev->nr_chans = 8;\r\nsolo_dev->nr_ext = 2;\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev, "Invalid chip_id 0x%02x, assuming 4 ch\n",\r\nchip_id);\r\ncase 5:\r\nsolo_dev->nr_chans = 4;\r\nsolo_dev->nr_ext = 1;\r\n}\r\nsolo_irq_off(solo_dev, ~0);\r\nif (solo_dev->type == SOLO_DEV_6010) {\r\nsolo_dev->clock_mhz = 108;\r\nsolo_dev->sys_config = SOLO_SYS_CFG_SDRAM64BIT\r\n| SOLO_SYS_CFG_INPUTDIV(25)\r\n| SOLO_SYS_CFG_FEEDBACKDIV(solo_dev->clock_mhz * 2 - 2)\r\n| SOLO_SYS_CFG_OUTDIV(3);\r\nsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\r\n} else {\r\nu32 divq, divf;\r\nsolo_dev->clock_mhz = 135;\r\nif (solo_dev->clock_mhz < 125) {\r\ndivq = 3;\r\ndivf = (solo_dev->clock_mhz * 4) / 3 - 1;\r\n} else {\r\ndivq = 2;\r\ndivf = (solo_dev->clock_mhz * 2) / 3 - 1;\r\n}\r\nsolo_reg_write(solo_dev, SOLO_PLL_CONFIG,\r\n(1 << 20) |\r\n(8 << 15) |\r\n(divq << 12) |\r\n(divf << 4) |\r\n(1 << 1) );\r\nsolo_dev->sys_config = SOLO_SYS_CFG_SDRAM64BIT;\r\n}\r\nsolo_reg_write(solo_dev, SOLO_SYS_CFG, solo_dev->sys_config);\r\nsolo_reg_write(solo_dev, SOLO_TIMER_CLOCK_NUM,\r\nsolo_dev->clock_mhz - 1);\r\nmdelay(1);\r\nret = request_irq(pdev->irq, solo_isr, IRQF_SHARED, SOLO6X10_NAME,\r\nsolo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nsolo_irq_on(solo_dev, SOLO_IRQ_PCI_ERR);\r\nret = solo_i2c_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nsolo_reg_write(solo_dev, SOLO_DMA_CTRL,\r\nSOLO_DMA_CTRL_REFRESH_CYCLE(1) |\r\nSOLO_DMA_CTRL_SDRAM_SIZE(2) |\r\nSOLO_DMA_CTRL_SDRAM_CLK_INVERT |\r\nSOLO_DMA_CTRL_READ_CLK_SELECT |\r\nSOLO_DMA_CTRL_LATENCY(1));\r\nsolo_reg_write(solo_dev, SOLO_DMA_CTRL1,\r\nsolo_dev->type == SOLO_DEV_6010 ? 0x100 : 0x300);\r\nif (solo_dev->type != SOLO_DEV_6010) {\r\nsolo_dev->usec_lsb = 0x3f;\r\nsolo_set_time(solo_dev);\r\n}\r\nsolo_reg_write(solo_dev, SOLO_WATCHDOG, 0);\r\nret = solo_p2m_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_disp_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_gpio_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_tw28_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_v4l2_init(solo_dev, video_nr);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_enc_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_enc_v4l2_init(solo_dev, video_nr);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_g723_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nret = solo_sysfs_init(solo_dev);\r\nif (ret)\r\ngoto fail_probe;\r\nsolo_dev->p2m_jiffies = msecs_to_jiffies(20);\r\nreturn 0;\r\nfail_probe:\r\nfree_solo_dev(solo_dev);\r\nreturn ret;\r\n}\r\nstatic void solo_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct solo_dev *solo_dev = container_of(v4l2_dev, struct solo_dev, v4l2_dev);\r\nfree_solo_dev(solo_dev);\r\n}
