static u64 pcr_address(struct cmp_connection *c)\r\n{\r\nif (c->direction == CMP_INPUT)\r\nreturn CSR_REGISTER_BASE + CSR_IPCR(c->pcr_index);\r\nelse\r\nreturn CSR_REGISTER_BASE + CSR_OPCR(c->pcr_index);\r\n}\r\nstatic int pcr_modify(struct cmp_connection *c,\r\n__be32 (*modify)(struct cmp_connection *c, __be32 old),\r\nint (*check)(struct cmp_connection *c, __be32 pcr),\r\nenum bus_reset_handling bus_reset_handling)\r\n{\r\n__be32 old_arg, buffer[2];\r\nint err;\r\nbuffer[0] = c->last_pcr_value;\r\nfor (;;) {\r\nold_arg = buffer[0];\r\nbuffer[1] = modify(c, buffer[0]);\r\nerr = snd_fw_transaction(\r\nc->resources.unit, TCODE_LOCK_COMPARE_SWAP,\r\npcr_address(c), buffer, 8,\r\nFW_FIXED_GENERATION | c->resources.generation);\r\nif (err < 0) {\r\nif (err == -EAGAIN &&\r\nbus_reset_handling == SUCCEED_ON_BUS_RESET)\r\nerr = 0;\r\nreturn err;\r\n}\r\nif (buffer[0] == old_arg)\r\nbreak;\r\nif (check) {\r\nerr = check(c, buffer[0]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nc->last_pcr_value = buffer[1];\r\nreturn 0;\r\n}\r\nint cmp_connection_init(struct cmp_connection *c,\r\nstruct fw_unit *unit,\r\nenum cmp_direction direction,\r\nunsigned int pcr_index)\r\n{\r\n__be32 mpr_be;\r\nu32 mpr;\r\nint err;\r\nc->direction = direction;\r\nerr = snd_fw_transaction(unit, TCODE_READ_QUADLET_REQUEST,\r\nmpr_address(c), &mpr_be, 4, 0);\r\nif (err < 0)\r\nreturn err;\r\nmpr = be32_to_cpu(mpr_be);\r\nif (pcr_index >= (mpr & MPR_PLUGS_MASK))\r\nreturn -EINVAL;\r\nerr = fw_iso_resources_init(&c->resources, unit);\r\nif (err < 0)\r\nreturn err;\r\nc->connected = false;\r\nmutex_init(&c->mutex);\r\nc->last_pcr_value = cpu_to_be32(0x80000000);\r\nc->pcr_index = pcr_index;\r\nc->max_speed = (mpr & MPR_SPEED_MASK) >> MPR_SPEED_SHIFT;\r\nif (c->max_speed == SCODE_BETA)\r\nc->max_speed += (mpr & MPR_XSPEED_MASK) >> MPR_XSPEED_SHIFT;\r\nreturn 0;\r\n}\r\nint cmp_connection_check_used(struct cmp_connection *c, bool *used)\r\n{\r\n__be32 pcr;\r\nint err;\r\nerr = snd_fw_transaction(\r\nc->resources.unit, TCODE_READ_QUADLET_REQUEST,\r\npcr_address(c), &pcr, 4, 0);\r\nif (err >= 0)\r\n*used = !!(pcr & cpu_to_be32(PCR_BCAST_CONN |\r\nPCR_P2P_CONN_MASK));\r\nreturn err;\r\n}\r\nvoid cmp_connection_destroy(struct cmp_connection *c)\r\n{\r\nWARN_ON(c->connected);\r\nmutex_destroy(&c->mutex);\r\nfw_iso_resources_destroy(&c->resources);\r\n}\r\nstatic __be32 ipcr_set_modify(struct cmp_connection *c, __be32 ipcr)\r\n{\r\nipcr &= ~cpu_to_be32(PCR_BCAST_CONN |\r\nPCR_P2P_CONN_MASK |\r\nPCR_CHANNEL_MASK);\r\nipcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);\r\nipcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);\r\nreturn ipcr;\r\n}\r\nstatic int get_overhead_id(struct cmp_connection *c)\r\n{\r\nint id;\r\nfor (id = 1; id < 16; id++) {\r\nif (c->resources.bandwidth_overhead < (id << 5))\r\nbreak;\r\n}\r\nif (id == 16)\r\nid = 0;\r\nreturn id;\r\n}\r\nstatic __be32 opcr_set_modify(struct cmp_connection *c, __be32 opcr)\r\n{\r\nunsigned int spd, xspd;\r\nif (c->speed > SCODE_400) {\r\nspd = SCODE_800;\r\nxspd = c->speed - SCODE_800;\r\n} else {\r\nspd = c->speed;\r\nxspd = 0;\r\n}\r\nopcr &= ~cpu_to_be32(PCR_BCAST_CONN |\r\nPCR_P2P_CONN_MASK |\r\nOPCR_XSPEED_MASK |\r\nPCR_CHANNEL_MASK |\r\nOPCR_SPEED_MASK |\r\nOPCR_OVERHEAD_ID_MASK);\r\nopcr |= cpu_to_be32(1 << PCR_P2P_CONN_SHIFT);\r\nopcr |= cpu_to_be32(xspd << OPCR_XSPEED_SHIFT);\r\nopcr |= cpu_to_be32(c->resources.channel << PCR_CHANNEL_SHIFT);\r\nopcr |= cpu_to_be32(spd << OPCR_SPEED_SHIFT);\r\nopcr |= cpu_to_be32(get_overhead_id(c) << OPCR_OVERHEAD_ID_SHIFT);\r\nreturn opcr;\r\n}\r\nstatic int pcr_set_check(struct cmp_connection *c, __be32 pcr)\r\n{\r\nif (pcr & cpu_to_be32(PCR_BCAST_CONN |\r\nPCR_P2P_CONN_MASK)) {\r\ncmp_error(c, "plug is already in use\n");\r\nreturn -EBUSY;\r\n}\r\nif (!(pcr & cpu_to_be32(PCR_ONLINE))) {\r\ncmp_error(c, "plug is not on-line\n");\r\nreturn -ECONNREFUSED;\r\n}\r\nreturn 0;\r\n}\r\nint cmp_connection_establish(struct cmp_connection *c,\r\nunsigned int max_payload_bytes)\r\n{\r\nint err;\r\nif (WARN_ON(c->connected))\r\nreturn -EISCONN;\r\nc->speed = min(c->max_speed,\r\nfw_parent_device(c->resources.unit)->max_speed);\r\nmutex_lock(&c->mutex);\r\nretry_after_bus_reset:\r\nerr = fw_iso_resources_allocate(&c->resources,\r\nmax_payload_bytes, c->speed);\r\nif (err < 0)\r\ngoto err_mutex;\r\nif (c->direction == CMP_OUTPUT)\r\nerr = pcr_modify(c, opcr_set_modify, pcr_set_check,\r\nABORT_ON_BUS_RESET);\r\nelse\r\nerr = pcr_modify(c, ipcr_set_modify, pcr_set_check,\r\nABORT_ON_BUS_RESET);\r\nif (err == -EAGAIN) {\r\nfw_iso_resources_free(&c->resources);\r\ngoto retry_after_bus_reset;\r\n}\r\nif (err < 0)\r\ngoto err_resources;\r\nc->connected = true;\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\nerr_resources:\r\nfw_iso_resources_free(&c->resources);\r\nerr_mutex:\r\nmutex_unlock(&c->mutex);\r\nreturn err;\r\n}\r\nint cmp_connection_update(struct cmp_connection *c)\r\n{\r\nint err;\r\nmutex_lock(&c->mutex);\r\nif (!c->connected) {\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\n}\r\nerr = fw_iso_resources_update(&c->resources);\r\nif (err < 0)\r\ngoto err_unconnect;\r\nif (c->direction == CMP_OUTPUT)\r\nerr = pcr_modify(c, opcr_set_modify, pcr_set_check,\r\nSUCCEED_ON_BUS_RESET);\r\nelse\r\nerr = pcr_modify(c, ipcr_set_modify, pcr_set_check,\r\nSUCCEED_ON_BUS_RESET);\r\nif (err < 0)\r\ngoto err_resources;\r\nmutex_unlock(&c->mutex);\r\nreturn 0;\r\nerr_resources:\r\nfw_iso_resources_free(&c->resources);\r\nerr_unconnect:\r\nc->connected = false;\r\nmutex_unlock(&c->mutex);\r\nreturn err;\r\n}\r\nstatic __be32 pcr_break_modify(struct cmp_connection *c, __be32 pcr)\r\n{\r\nreturn pcr & ~cpu_to_be32(PCR_BCAST_CONN | PCR_P2P_CONN_MASK);\r\n}\r\nvoid cmp_connection_break(struct cmp_connection *c)\r\n{\r\nint err;\r\nmutex_lock(&c->mutex);\r\nif (!c->connected) {\r\nmutex_unlock(&c->mutex);\r\nreturn;\r\n}\r\nerr = pcr_modify(c, pcr_break_modify, NULL, SUCCEED_ON_BUS_RESET);\r\nif (err < 0)\r\ncmp_error(c, "plug is still connected\n");\r\nfw_iso_resources_free(&c->resources);\r\nc->connected = false;\r\nmutex_unlock(&c->mutex);\r\n}
