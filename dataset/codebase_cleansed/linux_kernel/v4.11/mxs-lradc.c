static void mxs_lradc_reg_set(struct mxs_lradc *lradc, u32 val, u32 reg)\r\n{\r\nwritel(val, lradc->base + reg + STMP_OFFSET_REG_SET);\r\n}\r\nstatic void mxs_lradc_reg_clear(struct mxs_lradc *lradc, u32 val, u32 reg)\r\n{\r\nwritel(val, lradc->base + reg + STMP_OFFSET_REG_CLR);\r\n}\r\nstatic void mxs_lradc_reg_wrt(struct mxs_lradc *lradc, u32 val, u32 reg)\r\n{\r\nwritel(val, lradc->base + reg);\r\n}\r\nstatic u32 mxs_lradc_plate_mask(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL0_MX23_PLATE_MASK;\r\nreturn LRADC_CTRL0_MX28_PLATE_MASK;\r\n}\r\nstatic u32 mxs_lradc_irq_mask(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL1_MX23_LRADC_IRQ_MASK;\r\nreturn LRADC_CTRL1_MX28_LRADC_IRQ_MASK;\r\n}\r\nstatic u32 mxs_lradc_touch_detect_bit(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL0_MX23_TOUCH_DETECT_ENABLE;\r\nreturn LRADC_CTRL0_MX28_TOUCH_DETECT_ENABLE;\r\n}\r\nstatic u32 mxs_lradc_drive_x_plate(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL0_MX23_XP | LRADC_CTRL0_MX23_XM;\r\nreturn LRADC_CTRL0_MX28_XPPSW | LRADC_CTRL0_MX28_XNNSW;\r\n}\r\nstatic u32 mxs_lradc_drive_y_plate(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL0_MX23_YP | LRADC_CTRL0_MX23_YM;\r\nreturn LRADC_CTRL0_MX28_YPPSW | LRADC_CTRL0_MX28_YNNSW;\r\n}\r\nstatic u32 mxs_lradc_drive_pressure(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX23_LRADC)\r\nreturn LRADC_CTRL0_MX23_YP | LRADC_CTRL0_MX23_XM;\r\nreturn LRADC_CTRL0_MX28_YPPSW | LRADC_CTRL0_MX28_XNNSW;\r\n}\r\nstatic bool mxs_lradc_check_touch_event(struct mxs_lradc *lradc)\r\n{\r\nreturn !!(readl(lradc->base + LRADC_STATUS) &\r\nLRADC_STATUS_TOUCH_DETECT_RAW);\r\n}\r\nstatic void mxs_lradc_map_channel(struct mxs_lradc *lradc, unsigned vch,\r\nunsigned ch)\r\n{\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL4_LRADCSELECT_MASK(vch),\r\nLRADC_CTRL4);\r\nmxs_lradc_reg_set(lradc, LRADC_CTRL4_LRADCSELECT(vch, ch), LRADC_CTRL4);\r\n}\r\nstatic void mxs_lradc_setup_ts_channel(struct mxs_lradc *lradc, unsigned ch)\r\n{\r\nmxs_lradc_reg_wrt(lradc, LRADC_CH_ACCUMULATE |\r\nLRADC_CH_NUM_SAMPLES(lradc->over_sample_cnt - 1),\r\nLRADC_CH(ch));\r\nmxs_lradc_reg_clear(lradc, LRADC_CH_VALUE_MASK, LRADC_CH(ch));\r\nmxs_lradc_reg_wrt(lradc, LRADC_DELAY_TRIGGER(1 << ch) |\r\nLRADC_DELAY_TRIGGER_DELAYS(0) |\r\nLRADC_DELAY_LOOP(lradc->over_sample_cnt - 1) |\r\nLRADC_DELAY_DELAY(lradc->over_sample_delay - 1),\r\nLRADC_DELAY(3));\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_LRADC_IRQ(ch), LRADC_CTRL1);\r\nmxs_lradc_reg_wrt(\r\nlradc,\r\nLRADC_DELAY_TRIGGER(0) |\r\nLRADC_DELAY_TRIGGER_DELAYS(BIT(3)) |\r\nLRADC_DELAY_KICK |\r\nLRADC_DELAY_DELAY(lradc->settling_delay),\r\nLRADC_DELAY(2));\r\n}\r\nstatic void mxs_lradc_setup_ts_pressure(struct mxs_lradc *lradc, unsigned ch1,\r\nunsigned ch2)\r\n{\r\nu32 reg;\r\nreg = LRADC_CH_ACCUMULATE |\r\nLRADC_CH_NUM_SAMPLES(lradc->over_sample_cnt - 1);\r\nmxs_lradc_reg_wrt(lradc, reg, LRADC_CH(ch1));\r\nmxs_lradc_reg_wrt(lradc, reg, LRADC_CH(ch2));\r\nmxs_lradc_reg_clear(lradc, LRADC_CH_VALUE_MASK, LRADC_CH(ch1));\r\nmxs_lradc_reg_clear(lradc, LRADC_CH_VALUE_MASK, LRADC_CH(ch2));\r\nmxs_lradc_reg_wrt(\r\nlradc,\r\nLRADC_DELAY_TRIGGER(1 << ch1) |\r\nLRADC_DELAY_TRIGGER(1 << ch2) |\r\nLRADC_DELAY_TRIGGER_DELAYS(0) |\r\nLRADC_DELAY_LOOP(lradc->over_sample_cnt - 1) |\r\nLRADC_DELAY_DELAY(lradc->over_sample_delay - 1),\r\nLRADC_DELAY(3));\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_LRADC_IRQ(ch2), LRADC_CTRL1);\r\nmxs_lradc_reg_wrt(\r\nlradc,\r\nLRADC_DELAY_TRIGGER(0) |\r\nLRADC_DELAY_TRIGGER_DELAYS(BIT(3)) |\r\nLRADC_DELAY_KICK |\r\nLRADC_DELAY_DELAY(lradc->settling_delay), LRADC_DELAY(2));\r\n}\r\nstatic unsigned mxs_lradc_read_raw_channel(struct mxs_lradc *lradc,\r\nunsigned channel)\r\n{\r\nu32 reg;\r\nunsigned num_samples, val;\r\nreg = readl(lradc->base + LRADC_CH(channel));\r\nif (reg & LRADC_CH_ACCUMULATE)\r\nnum_samples = lradc->over_sample_cnt;\r\nelse\r\nnum_samples = 1;\r\nval = (reg & LRADC_CH_VALUE_MASK) >> LRADC_CH_VALUE_OFFSET;\r\nreturn val / num_samples;\r\n}\r\nstatic unsigned mxs_lradc_read_ts_pressure(struct mxs_lradc *lradc,\r\nunsigned ch1, unsigned ch2)\r\n{\r\nu32 reg, mask;\r\nunsigned pressure, m1, m2;\r\nmask = LRADC_CTRL1_LRADC_IRQ(ch1) | LRADC_CTRL1_LRADC_IRQ(ch2);\r\nreg = readl(lradc->base + LRADC_CTRL1) & mask;\r\nwhile (reg != mask) {\r\nreg = readl(lradc->base + LRADC_CTRL1) & mask;\r\ndev_dbg(lradc->dev, "One channel is still busy: %X\n", reg);\r\n}\r\nm1 = mxs_lradc_read_raw_channel(lradc, ch1);\r\nm2 = mxs_lradc_read_raw_channel(lradc, ch2);\r\nif (m2 == 0) {\r\ndev_warn(lradc->dev, "Cannot calculate pressure\n");\r\nreturn 1 << (LRADC_RESOLUTION - 1);\r\n}\r\npressure = m1;\r\npressure *= (1 << LRADC_RESOLUTION);\r\npressure /= m2;\r\ndev_dbg(lradc->dev, "Pressure = %u\n", pressure);\r\nreturn pressure;\r\n}\r\nstatic void mxs_lradc_setup_touch_detection(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc, mxs_lradc_plate_mask(lradc), LRADC_CTRL0);\r\nmxs_lradc_reg_set(lradc, mxs_lradc_touch_detect_bit(lradc),\r\nLRADC_CTRL0);\r\n}\r\nstatic void mxs_lradc_prepare_x_pos(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc, mxs_lradc_plate_mask(lradc), LRADC_CTRL0);\r\nmxs_lradc_reg_set(lradc, mxs_lradc_drive_x_plate(lradc), LRADC_CTRL0);\r\nlradc->cur_plate = LRADC_SAMPLE_X;\r\nmxs_lradc_map_channel(lradc, TOUCHSCREEN_VCHANNEL1, TS_CH_YP);\r\nmxs_lradc_setup_ts_channel(lradc, TOUCHSCREEN_VCHANNEL1);\r\n}\r\nstatic void mxs_lradc_prepare_y_pos(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc, mxs_lradc_plate_mask(lradc), LRADC_CTRL0);\r\nmxs_lradc_reg_set(lradc, mxs_lradc_drive_y_plate(lradc), LRADC_CTRL0);\r\nlradc->cur_plate = LRADC_SAMPLE_Y;\r\nmxs_lradc_map_channel(lradc, TOUCHSCREEN_VCHANNEL1, TS_CH_XM);\r\nmxs_lradc_setup_ts_channel(lradc, TOUCHSCREEN_VCHANNEL1);\r\n}\r\nstatic void mxs_lradc_prepare_pressure(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc, mxs_lradc_plate_mask(lradc), LRADC_CTRL0);\r\nmxs_lradc_reg_set(lradc, mxs_lradc_drive_pressure(lradc), LRADC_CTRL0);\r\nlradc->cur_plate = LRADC_SAMPLE_PRESSURE;\r\nmxs_lradc_map_channel(lradc, TOUCHSCREEN_VCHANNEL1, TS_CH_YM);\r\nmxs_lradc_map_channel(lradc, TOUCHSCREEN_VCHANNEL2, TS_CH_XP);\r\nmxs_lradc_setup_ts_pressure(lradc, TOUCHSCREEN_VCHANNEL2,\r\nTOUCHSCREEN_VCHANNEL1);\r\n}\r\nstatic void mxs_lradc_enable_touch_detection(struct mxs_lradc *lradc)\r\n{\r\nif (lradc->soc == IMX28_LRADC) {\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL0_MX28_TOUCH_SCREEN_TYPE,\r\nLRADC_CTRL0);\r\nif (lradc->use_touchscreen == MXS_LRADC_TOUCHSCREEN_5WIRE)\r\nmxs_lradc_reg_set(lradc,\r\nLRADC_CTRL0_MX28_TOUCH_SCREEN_TYPE,\r\nLRADC_CTRL0);\r\n}\r\nmxs_lradc_setup_touch_detection(lradc);\r\nlradc->cur_plate = LRADC_TOUCH;\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_TOUCH_DETECT_IRQ |\r\nLRADC_CTRL1_TOUCH_DETECT_IRQ_EN, LRADC_CTRL1);\r\nmxs_lradc_reg_set(lradc, LRADC_CTRL1_TOUCH_DETECT_IRQ_EN, LRADC_CTRL1);\r\n}\r\nstatic void mxs_lradc_start_touch_event(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc,\r\nLRADC_CTRL1_TOUCH_DETECT_IRQ_EN,\r\nLRADC_CTRL1);\r\nmxs_lradc_reg_set(lradc,\r\nLRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1),\r\nLRADC_CTRL1);\r\nmxs_lradc_prepare_y_pos(lradc);\r\n}\r\nstatic void mxs_lradc_report_ts_event(struct mxs_lradc *lradc)\r\n{\r\ninput_report_abs(lradc->ts_input, ABS_X, lradc->ts_x_pos);\r\ninput_report_abs(lradc->ts_input, ABS_Y, lradc->ts_y_pos);\r\ninput_report_abs(lradc->ts_input, ABS_PRESSURE, lradc->ts_pressure);\r\ninput_report_key(lradc->ts_input, BTN_TOUCH, 1);\r\ninput_sync(lradc->ts_input);\r\n}\r\nstatic void mxs_lradc_complete_touch_event(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_setup_touch_detection(lradc);\r\nlradc->cur_plate = LRADC_SAMPLE_VALID;\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_CH(TOUCHSCREEN_VCHANNEL1));\r\nmxs_lradc_reg_clear(lradc,\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2),\r\nLRADC_CTRL1);\r\nmxs_lradc_reg_wrt(\r\nlradc,\r\nLRADC_DELAY_TRIGGER(1 << TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_DELAY_KICK | LRADC_DELAY_DELAY(10),\r\nLRADC_DELAY(2));\r\n}\r\nstatic void mxs_lradc_finish_touch_event(struct mxs_lradc *lradc, bool valid)\r\n{\r\nif (valid && mxs_lradc_check_touch_event(lradc)) {\r\nlradc->ts_valid = true;\r\nmxs_lradc_report_ts_event(lradc);\r\n}\r\nif (mxs_lradc_check_touch_event(lradc)) {\r\nmxs_lradc_prepare_y_pos(lradc);\r\nreturn;\r\n}\r\nif (lradc->ts_valid) {\r\nlradc->ts_valid = false;\r\ninput_report_key(lradc->ts_input, BTN_TOUCH, 0);\r\ninput_sync(lradc->ts_input);\r\n}\r\nlradc->cur_plate = LRADC_TOUCH;\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(2));\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(3));\r\nmxs_lradc_reg_clear(lradc,\r\nLRADC_CTRL1_TOUCH_DETECT_IRQ |\r\nLRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1),\r\nLRADC_CTRL1);\r\nmxs_lradc_reg_set(lradc, LRADC_CTRL1_TOUCH_DETECT_IRQ_EN, LRADC_CTRL1);\r\n}\r\nstatic void mxs_lradc_handle_touch(struct mxs_lradc *lradc)\r\n{\r\nswitch (lradc->cur_plate) {\r\ncase LRADC_TOUCH:\r\nif (mxs_lradc_check_touch_event(lradc))\r\nmxs_lradc_start_touch_event(lradc);\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_TOUCH_DETECT_IRQ,\r\nLRADC_CTRL1);\r\nreturn;\r\ncase LRADC_SAMPLE_Y:\r\nlradc->ts_y_pos =\r\nmxs_lradc_read_raw_channel(lradc,\r\nTOUCHSCREEN_VCHANNEL1);\r\nmxs_lradc_prepare_x_pos(lradc);\r\nreturn;\r\ncase LRADC_SAMPLE_X:\r\nlradc->ts_x_pos =\r\nmxs_lradc_read_raw_channel(lradc,\r\nTOUCHSCREEN_VCHANNEL1);\r\nmxs_lradc_prepare_pressure(lradc);\r\nreturn;\r\ncase LRADC_SAMPLE_PRESSURE:\r\nlradc->ts_pressure =\r\nmxs_lradc_read_ts_pressure(lradc,\r\nTOUCHSCREEN_VCHANNEL2,\r\nTOUCHSCREEN_VCHANNEL1);\r\nmxs_lradc_complete_touch_event(lradc);\r\nreturn;\r\ncase LRADC_SAMPLE_VALID:\r\nmxs_lradc_finish_touch_event(lradc, 1);\r\nbreak;\r\n}\r\n}\r\nstatic int mxs_lradc_read_single(struct iio_dev *iio_dev, int chan, int *val)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio_dev);\r\nint ret;\r\nret = mutex_trylock(&lradc->lock);\r\nif (!ret)\r\nreturn -EBUSY;\r\nreinit_completion(&lradc->completion);\r\nif (lradc->soc == IMX28_LRADC)\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_LRADC_IRQ_EN(0),\r\nLRADC_CTRL1);\r\nmxs_lradc_reg_clear(lradc, 0x1, LRADC_CTRL0);\r\nif (test_bit(chan, &lradc->is_divided))\r\nmxs_lradc_reg_set(lradc,\r\n1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\r\nLRADC_CTRL2);\r\nelse\r\nmxs_lradc_reg_clear(lradc,\r\n1 << LRADC_CTRL2_DIVIDE_BY_TWO_OFFSET,\r\nLRADC_CTRL2);\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL4_LRADCSELECT_MASK(0),\r\nLRADC_CTRL4);\r\nmxs_lradc_reg_set(lradc, chan, LRADC_CTRL4);\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_CH(0));\r\nmxs_lradc_reg_set(lradc, LRADC_CTRL1_LRADC_IRQ_EN(0), LRADC_CTRL1);\r\nmxs_lradc_reg_set(lradc, BIT(0), LRADC_CTRL0);\r\nret = wait_for_completion_killable_timeout(&lradc->completion, HZ);\r\nif (!ret)\r\nret = -ETIMEDOUT;\r\nif (ret < 0)\r\ngoto err;\r\n*val = readl(lradc->base + LRADC_CH(0)) & LRADC_CH_VALUE_MASK;\r\nret = IIO_VAL_INT;\r\nerr:\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_LRADC_IRQ_EN(0), LRADC_CTRL1);\r\nmutex_unlock(&lradc->lock);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_read_temp(struct iio_dev *iio_dev, int *val)\r\n{\r\nint ret, min, max;\r\nret = mxs_lradc_read_single(iio_dev, 8, &min);\r\nif (ret != IIO_VAL_INT)\r\nreturn ret;\r\nret = mxs_lradc_read_single(iio_dev, 9, &max);\r\nif (ret != IIO_VAL_INT)\r\nreturn ret;\r\n*val = max - min;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int mxs_lradc_read_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2, long m)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio_dev);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_TEMP)\r\nreturn mxs_lradc_read_temp(iio_dev, val);\r\nreturn mxs_lradc_read_single(iio_dev, chan->channel, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_TEMP) {\r\n*val = 0;\r\n*val2 = 253000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\n*val = lradc->vref_mv[chan->channel];\r\n*val2 = chan->scan_type.realbits -\r\ntest_bit(chan->channel, &lradc->is_divided);\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif (chan->type == IIO_TEMP) {\r\n*val = -1079;\r\n*val2 = 644268;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mxs_lradc_write_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint val, int val2, long m)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio_dev);\r\nstruct mxs_lradc_scale *scale_avail =\r\nlradc->scale_avail[chan->channel];\r\nint ret;\r\nret = mutex_trylock(&lradc->lock);\r\nif (!ret)\r\nreturn -EBUSY;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = -EINVAL;\r\nif (val == scale_avail[MXS_LRADC_DIV_DISABLED].integer &&\r\nval2 == scale_avail[MXS_LRADC_DIV_DISABLED].nano) {\r\nclear_bit(chan->channel, &lradc->is_divided);\r\nret = 0;\r\n} else if (val == scale_avail[MXS_LRADC_DIV_ENABLED].integer &&\r\nval2 == scale_avail[MXS_LRADC_DIV_ENABLED].nano) {\r\nset_bit(chan->channel, &lradc->is_divided);\r\nret = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&lradc->lock);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_write_raw_get_fmt(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nlong m)\r\n{\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nstatic ssize_t mxs_lradc_show_scale_available_ch(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf,\r\nint ch)\r\n{\r\nstruct iio_dev *iio = dev_to_iio_dev(dev);\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nint i, len = 0;\r\nfor (i = 0; i < ARRAY_SIZE(lradc->scale_avail[ch]); i++)\r\nlen += sprintf(buf + len, "%u.%09u ",\r\nlradc->scale_avail[ch][i].integer,\r\nlradc->scale_avail[ch][i].nano);\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t mxs_lradc_show_scale_available(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev_attr *iio_attr = to_iio_dev_attr(attr);\r\nreturn mxs_lradc_show_scale_available_ch(dev, attr, buf,\r\niio_attr->address);\r\n}\r\nstatic int mxs_lradc_ts_open(struct input_dev *dev)\r\n{\r\nstruct mxs_lradc *lradc = input_get_drvdata(dev);\r\nmxs_lradc_enable_touch_detection(lradc);\r\nreturn 0;\r\n}\r\nstatic void mxs_lradc_disable_ts(struct mxs_lradc *lradc)\r\n{\r\nmxs_lradc_reg_clear(lradc, LRADC_CTRL1_TOUCH_DETECT_IRQ_EN |\r\nLRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_CTRL1_LRADC_IRQ_EN(TOUCHSCREEN_VCHANNEL2), LRADC_CTRL1);\r\nmxs_lradc_reg_clear(lradc, mxs_lradc_plate_mask(lradc), LRADC_CTRL0);\r\n}\r\nstatic void mxs_lradc_ts_close(struct input_dev *dev)\r\n{\r\nstruct mxs_lradc *lradc = input_get_drvdata(dev);\r\nmxs_lradc_disable_ts(lradc);\r\n}\r\nstatic int mxs_lradc_ts_register(struct mxs_lradc *lradc)\r\n{\r\nstruct input_dev *input;\r\nstruct device *dev = lradc->dev;\r\nif (!lradc->use_touchscreen)\r\nreturn 0;\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = DRIVER_NAME;\r\ninput->id.bustype = BUS_HOST;\r\ninput->open = mxs_lradc_ts_open;\r\ninput->close = mxs_lradc_ts_close;\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(INPUT_PROP_DIRECT, input->propbit);\r\ninput_set_abs_params(input, ABS_X, 0, LRADC_SINGLE_SAMPLE_MASK, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, LRADC_SINGLE_SAMPLE_MASK, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, LRADC_SINGLE_SAMPLE_MASK,\r\n0, 0);\r\nlradc->ts_input = input;\r\ninput_set_drvdata(input, lradc);\r\nreturn input_register_device(input);\r\n}\r\nstatic irqreturn_t mxs_lradc_handle_irq(int irq, void *data)\r\n{\r\nstruct iio_dev *iio = data;\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nunsigned long reg = readl(lradc->base + LRADC_CTRL1);\r\nu32 clr_irq = mxs_lradc_irq_mask(lradc);\r\nconst u32 ts_irq_mask =\r\nLRADC_CTRL1_TOUCH_DETECT_IRQ |\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2);\r\nif (!(reg & mxs_lradc_irq_mask(lradc)))\r\nreturn IRQ_NONE;\r\nif (lradc->use_touchscreen && (reg & ts_irq_mask)) {\r\nmxs_lradc_handle_touch(lradc);\r\nclr_irq &= ~(LRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL1) |\r\nLRADC_CTRL1_LRADC_IRQ(TOUCHSCREEN_VCHANNEL2));\r\n}\r\nif (iio_buffer_enabled(iio)) {\r\nif (reg & lradc->buffer_vchans)\r\niio_trigger_poll(iio->trig);\r\n} else if (reg & LRADC_CTRL1_LRADC_IRQ(0)) {\r\ncomplete(&lradc->completion);\r\n}\r\nmxs_lradc_reg_clear(lradc, reg & clr_irq, LRADC_CTRL1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mxs_lradc_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *iio = pf->indio_dev;\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nconst u32 chan_value = LRADC_CH_ACCUMULATE |\r\n((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\r\nunsigned int i, j = 0;\r\nfor_each_set_bit(i, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\r\nlradc->buffer[j] = readl(lradc->base + LRADC_CH(j));\r\nmxs_lradc_reg_wrt(lradc, chan_value, LRADC_CH(j));\r\nlradc->buffer[j] &= LRADC_CH_VALUE_MASK;\r\nlradc->buffer[j] /= LRADC_DELAY_TIMER_LOOP;\r\nj++;\r\n}\r\niio_push_to_buffers_with_timestamp(iio, lradc->buffer, pf->timestamp);\r\niio_trigger_notify_done(iio->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_lradc_configure_trigger(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_dev *iio = iio_trigger_get_drvdata(trig);\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nconst u32 st = state ? STMP_OFFSET_REG_SET : STMP_OFFSET_REG_CLR;\r\nmxs_lradc_reg_wrt(lradc, LRADC_DELAY_KICK, LRADC_DELAY(0) + st);\r\nreturn 0;\r\n}\r\nstatic int mxs_lradc_trigger_init(struct iio_dev *iio)\r\n{\r\nint ret;\r\nstruct iio_trigger *trig;\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\ntrig = iio_trigger_alloc("%s-dev%i", iio->name, iio->id);\r\nif (!trig)\r\nreturn -ENOMEM;\r\ntrig->dev.parent = lradc->dev;\r\niio_trigger_set_drvdata(trig, iio);\r\ntrig->ops = &mxs_lradc_trigger_ops;\r\nret = iio_trigger_register(trig);\r\nif (ret) {\r\niio_trigger_free(trig);\r\nreturn ret;\r\n}\r\nlradc->trig = trig;\r\nreturn 0;\r\n}\r\nstatic void mxs_lradc_trigger_remove(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\niio_trigger_unregister(lradc->trig);\r\niio_trigger_free(lradc->trig);\r\n}\r\nstatic int mxs_lradc_buffer_preenable(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nint ret = 0, chan, ofs = 0;\r\nunsigned long enable = 0;\r\nu32 ctrl4_set = 0;\r\nu32 ctrl4_clr = 0;\r\nu32 ctrl1_irq = 0;\r\nconst u32 chan_value = LRADC_CH_ACCUMULATE |\r\n((LRADC_DELAY_TIMER_LOOP - 1) << LRADC_CH_NUM_SAMPLES_OFFSET);\r\nconst int len = bitmap_weight(iio->active_scan_mask,\r\nLRADC_MAX_TOTAL_CHANS);\r\nif (!len)\r\nreturn -EINVAL;\r\nret = mutex_trylock(&lradc->lock);\r\nif (!ret)\r\nreturn -EBUSY;\r\nlradc->buffer = kmalloc_array(len, sizeof(*lradc->buffer), GFP_KERNEL);\r\nif (!lradc->buffer) {\r\nret = -ENOMEM;\r\ngoto err_mem;\r\n}\r\nif (lradc->soc == IMX28_LRADC)\r\nmxs_lradc_reg_clear(\r\nlradc,\r\nlradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\r\nLRADC_CTRL1);\r\nmxs_lradc_reg_clear(lradc, lradc->buffer_vchans, LRADC_CTRL0);\r\nfor_each_set_bit(chan, iio->active_scan_mask, LRADC_MAX_TOTAL_CHANS) {\r\nctrl4_set |= chan << LRADC_CTRL4_LRADCSELECT_OFFSET(ofs);\r\nctrl4_clr |= LRADC_CTRL4_LRADCSELECT_MASK(ofs);\r\nctrl1_irq |= LRADC_CTRL1_LRADC_IRQ_EN(ofs);\r\nmxs_lradc_reg_wrt(lradc, chan_value, LRADC_CH(ofs));\r\nbitmap_set(&enable, ofs, 1);\r\nofs++;\r\n}\r\nmxs_lradc_reg_clear(lradc, LRADC_DELAY_TRIGGER_LRADCS_MASK |\r\nLRADC_DELAY_KICK, LRADC_DELAY(0));\r\nmxs_lradc_reg_clear(lradc, ctrl4_clr, LRADC_CTRL4);\r\nmxs_lradc_reg_set(lradc, ctrl4_set, LRADC_CTRL4);\r\nmxs_lradc_reg_set(lradc, ctrl1_irq, LRADC_CTRL1);\r\nmxs_lradc_reg_set(lradc, enable << LRADC_DELAY_TRIGGER_LRADCS_OFFSET,\r\nLRADC_DELAY(0));\r\nreturn 0;\r\nerr_mem:\r\nmutex_unlock(&lradc->lock);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_buffer_postdisable(struct iio_dev *iio)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nmxs_lradc_reg_clear(lradc, LRADC_DELAY_TRIGGER_LRADCS_MASK |\r\nLRADC_DELAY_KICK, LRADC_DELAY(0));\r\nmxs_lradc_reg_clear(lradc, lradc->buffer_vchans, LRADC_CTRL0);\r\nif (lradc->soc == IMX28_LRADC)\r\nmxs_lradc_reg_clear(\r\nlradc,\r\nlradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\r\nLRADC_CTRL1);\r\nkfree(lradc->buffer);\r\nmutex_unlock(&lradc->lock);\r\nreturn 0;\r\n}\r\nstatic bool mxs_lradc_validate_scan_mask(struct iio_dev *iio,\r\nconst unsigned long *mask)\r\n{\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\nconst int map_chans = bitmap_weight(mask, LRADC_MAX_TOTAL_CHANS);\r\nint rsvd_chans = 0;\r\nunsigned long rsvd_mask = 0;\r\nif (lradc->use_touchbutton)\r\nrsvd_mask |= CHAN_MASK_TOUCHBUTTON;\r\nif (lradc->use_touchscreen == MXS_LRADC_TOUCHSCREEN_4WIRE)\r\nrsvd_mask |= CHAN_MASK_TOUCHSCREEN_4WIRE;\r\nif (lradc->use_touchscreen == MXS_LRADC_TOUCHSCREEN_5WIRE)\r\nrsvd_mask |= CHAN_MASK_TOUCHSCREEN_5WIRE;\r\nif (lradc->use_touchbutton)\r\nrsvd_chans++;\r\nif (lradc->use_touchscreen)\r\nrsvd_chans += 2;\r\nif (bitmap_intersects(mask, &rsvd_mask, LRADC_MAX_TOTAL_CHANS))\r\nreturn false;\r\nif (map_chans + rsvd_chans > LRADC_MAX_MAPPED_CHANS)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void mxs_lradc_hw_init(struct mxs_lradc *lradc)\r\n{\r\nconst u32 adc_cfg =\r\n(1 << (LRADC_DELAY_TRIGGER_DELAYS_OFFSET + 0)) |\r\n(LRADC_DELAY_TIMER_PER << LRADC_DELAY_DELAY_OFFSET);\r\nmxs_lradc_reg_wrt(lradc, adc_cfg, LRADC_DELAY(0));\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(1));\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(2));\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(3));\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_CTRL2);\r\n}\r\nstatic void mxs_lradc_hw_stop(struct mxs_lradc *lradc)\r\n{\r\nint i;\r\nmxs_lradc_reg_clear(lradc,\r\nlradc->buffer_vchans << LRADC_CTRL1_LRADC_IRQ_EN_OFFSET,\r\nLRADC_CTRL1);\r\nfor (i = 0; i < LRADC_MAX_DELAY_CHANS; i++)\r\nmxs_lradc_reg_wrt(lradc, 0, LRADC_DELAY(i));\r\n}\r\nstatic int mxs_lradc_probe_touchscreen(struct mxs_lradc *lradc,\r\nstruct device_node *lradc_node)\r\n{\r\nint ret;\r\nu32 ts_wires = 0, adapt;\r\nret = of_property_read_u32(lradc_node, "fsl,lradc-touchscreen-wires",\r\n&ts_wires);\r\nif (ret)\r\nreturn -ENODEV;\r\nswitch (ts_wires) {\r\ncase 4:\r\nlradc->use_touchscreen = MXS_LRADC_TOUCHSCREEN_4WIRE;\r\nbreak;\r\ncase 5:\r\nif (lradc->soc == IMX28_LRADC) {\r\nlradc->use_touchscreen = MXS_LRADC_TOUCHSCREEN_5WIRE;\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(lradc->dev,\r\n"Unsupported number of touchscreen wires (%d)\n",\r\nts_wires);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_u32(lradc_node, "fsl,ave-ctrl", &adapt)) {\r\nlradc->over_sample_cnt = 4;\r\n} else {\r\nif (adapt < 1 || adapt > 32) {\r\ndev_err(lradc->dev, "Invalid sample count (%u)\n",\r\nadapt);\r\nreturn -EINVAL;\r\n}\r\nlradc->over_sample_cnt = adapt;\r\n}\r\nif (of_property_read_u32(lradc_node, "fsl,ave-delay", &adapt)) {\r\nlradc->over_sample_delay = 2;\r\n} else {\r\nif (adapt < 2 || adapt > LRADC_DELAY_DELAY_MASK + 1) {\r\ndev_err(lradc->dev, "Invalid sample delay (%u)\n",\r\nadapt);\r\nreturn -EINVAL;\r\n}\r\nlradc->over_sample_delay = adapt;\r\n}\r\nif (of_property_read_u32(lradc_node, "fsl,settling", &adapt)) {\r\nlradc->settling_delay = 10;\r\n} else {\r\nif (adapt < 1 || adapt > LRADC_DELAY_DELAY_MASK) {\r\ndev_err(lradc->dev, "Invalid settling delay (%u)\n",\r\nadapt);\r\nreturn -EINVAL;\r\n}\r\nlradc->settling_delay = adapt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_lradc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_lradc_dt_ids, &pdev->dev);\r\nconst struct mxs_lradc_of_config *of_cfg =\r\n&mxs_lradc_of_config[(enum mxs_lradc_id)of_id->data];\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct mxs_lradc *lradc;\r\nstruct iio_dev *iio;\r\nstruct resource *iores;\r\nint ret = 0, touch_ret;\r\nint i, s;\r\nu64 scale_uv;\r\niio = devm_iio_device_alloc(dev, sizeof(*lradc));\r\nif (!iio) {\r\ndev_err(dev, "Failed to allocate IIO device\n");\r\nreturn -ENOMEM;\r\n}\r\nlradc = iio_priv(iio);\r\nlradc->soc = (enum mxs_lradc_id)of_id->data;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nlradc->dev = &pdev->dev;\r\nlradc->base = devm_ioremap_resource(dev, iores);\r\nif (IS_ERR(lradc->base))\r\nreturn PTR_ERR(lradc->base);\r\nlradc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(lradc->clk)) {\r\ndev_err(dev, "Failed to get the delay unit clock\n");\r\nreturn PTR_ERR(lradc->clk);\r\n}\r\nret = clk_prepare_enable(lradc->clk);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable the delay unit clock\n");\r\nreturn ret;\r\n}\r\ntouch_ret = mxs_lradc_probe_touchscreen(lradc, node);\r\nif (touch_ret == 0)\r\nlradc->buffer_vchans = BUFFER_VCHANS_LIMITED;\r\nelse\r\nlradc->buffer_vchans = BUFFER_VCHANS_ALL;\r\nfor (i = 0; i < of_cfg->irq_count; i++) {\r\nlradc->irq[i] = platform_get_irq(pdev, i);\r\nif (lradc->irq[i] < 0) {\r\nret = lradc->irq[i];\r\ngoto err_clk;\r\n}\r\nret = devm_request_irq(dev, lradc->irq[i],\r\nmxs_lradc_handle_irq, 0,\r\nof_cfg->irq_name[i], iio);\r\nif (ret)\r\ngoto err_clk;\r\n}\r\nlradc->vref_mv = of_cfg->vref_mv;\r\nplatform_set_drvdata(pdev, iio);\r\ninit_completion(&lradc->completion);\r\nmutex_init(&lradc->lock);\r\niio->name = pdev->name;\r\niio->dev.parent = &pdev->dev;\r\niio->info = &mxs_lradc_iio_info;\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->masklength = LRADC_MAX_TOTAL_CHANS;\r\nif (lradc->soc == IMX23_LRADC) {\r\niio->channels = mx23_lradc_chan_spec;\r\niio->num_channels = ARRAY_SIZE(mx23_lradc_chan_spec);\r\n} else {\r\niio->channels = mx28_lradc_chan_spec;\r\niio->num_channels = ARRAY_SIZE(mx28_lradc_chan_spec);\r\n}\r\nret = iio_triggered_buffer_setup(iio, &iio_pollfunc_store_time,\r\n&mxs_lradc_trigger_handler,\r\n&mxs_lradc_buffer_ops);\r\nif (ret)\r\ngoto err_clk;\r\nret = mxs_lradc_trigger_init(iio);\r\nif (ret)\r\ngoto err_trig;\r\nfor (i = 0; i < LRADC_MAX_TOTAL_CHANS; i++) {\r\nfor (s = 0; s < ARRAY_SIZE(lradc->scale_avail[i]); s++) {\r\nscale_uv = ((u64)lradc->vref_mv[i] * 100000000) >>\r\n(LRADC_RESOLUTION - s);\r\nlradc->scale_avail[i][s].nano =\r\ndo_div(scale_uv, 100000000) * 10;\r\nlradc->scale_avail[i][s].integer = scale_uv;\r\n}\r\n}\r\nret = stmp_reset_block(lradc->base);\r\nif (ret)\r\ngoto err_dev;\r\nmxs_lradc_hw_init(lradc);\r\nif (touch_ret == 0) {\r\nret = mxs_lradc_ts_register(lradc);\r\nif (ret)\r\ngoto err_ts_register;\r\n}\r\nret = iio_device_register(iio);\r\nif (ret) {\r\ndev_err(dev, "Failed to register IIO device\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\nerr_ts_register:\r\nmxs_lradc_hw_stop(lradc);\r\nerr_dev:\r\nmxs_lradc_trigger_remove(iio);\r\nerr_trig:\r\niio_triggered_buffer_cleanup(iio);\r\nerr_clk:\r\nclk_disable_unprepare(lradc->clk);\r\nreturn ret;\r\n}\r\nstatic int mxs_lradc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *iio = platform_get_drvdata(pdev);\r\nstruct mxs_lradc *lradc = iio_priv(iio);\r\niio_device_unregister(iio);\r\nmxs_lradc_hw_stop(lradc);\r\nmxs_lradc_trigger_remove(iio);\r\niio_triggered_buffer_cleanup(iio);\r\nclk_disable_unprepare(lradc->clk);\r\nreturn 0;\r\n}
