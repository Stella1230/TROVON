static void __init axs10x_enable_gpio_intc_wire(void)\r\n{\r\n#define GPIO_INTEN (AXC001_GPIO_INTC + 0x30)\r\n#define GPIO_INTMASK (AXC001_GPIO_INTC + 0x34)\r\n#define GPIO_INTTYPE_LEVEL (AXC001_GPIO_INTC + 0x38)\r\n#define GPIO_INT_POLARITY (AXC001_GPIO_INTC + 0x3c)\r\n#define MB_TO_GPIO_IRQ 12\r\niowrite32(~(1 << MB_TO_GPIO_IRQ), (void __iomem *) GPIO_INTMASK);\r\niowrite32(0, (void __iomem *) GPIO_INTTYPE_LEVEL);\r\niowrite32(~0, (void __iomem *) GPIO_INT_POLARITY);\r\niowrite32(1 << MB_TO_GPIO_IRQ, (void __iomem *) GPIO_INTEN);\r\n}\r\nstatic inline void __init\r\nwrite_cgu_reg(uint32_t value, void __iomem *reg, void __iomem *lock_reg)\r\n{\r\nunsigned int loops = 128 * 1024, ctr;\r\niowrite32(value, reg);\r\nctr = loops;\r\nwhile (((ioread32(lock_reg) & 1) == 1) && ctr--)\r\ncpu_relax();\r\nctr = loops;\r\nwhile (((ioread32(lock_reg) & 1) == 0) && ctr--)\r\ncpu_relax();\r\n}\r\nstatic void __init axs10x_print_board_ver(unsigned int creg, const char *str)\r\n{\r\nunion ver {\r\nstruct {\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nunsigned int pad:11, y:12, m:4, d:5;\r\n#else\r\nunsigned int d:5, m:4, y:12, pad:11;\r\n#endif\r\n};\r\nunsigned int val;\r\n} board;\r\nboard.val = ioread32((void __iomem *)creg);\r\npr_info("AXS: %s FPGA Date: %u-%u-%u\n", str, board.d, board.m,\r\nboard.y);\r\n}\r\nstatic void __init axs10x_early_init(void)\r\n{\r\nint mb_rev;\r\nchar mb[32];\r\nif (ioread32((void __iomem *) CREG_MB_CONFIG) & (1 << 28))\r\nmb_rev = 3;\r\nelse\r\nmb_rev = 2;\r\naxs10x_enable_gpio_intc_wire();\r\nscnprintf(mb, 32, "MainBoard v%d", mb_rev);\r\naxs10x_print_board_ver(CREG_MB_VER, mb);\r\n}\r\nstatic noinline void __init\r\naxs101_set_memmap(void __iomem *base, const struct aperture map[16])\r\n{\r\nunsigned int slave_select, slave_offset;\r\nint i;\r\nslave_select = slave_offset = 0;\r\nfor (i = 0; i < 8; i++) {\r\nslave_select |= map[i].slave_sel << (i << 2);\r\nslave_offset |= map[i].slave_off << (i << 2);\r\n}\r\niowrite32(slave_select, base + 0x0);\r\niowrite32(slave_offset, base + 0x8);\r\nslave_select = slave_offset = 0;\r\nfor (i = 0; i < 8; i++) {\r\nslave_select |= map[i+8].slave_sel << (i << 2);\r\nslave_offset |= map[i+8].slave_off << (i << 2);\r\n}\r\niowrite32(slave_select, base + 0x4);\r\niowrite32(slave_offset, base + 0xC);\r\n}\r\nstatic void __init axs101_early_init(void)\r\n{\r\nint i;\r\naxs101_set_memmap((void __iomem *) CREG_CPU_ADDR_770, axc001_memmap);\r\niowrite32(1, (void __iomem *) CREG_CPU_ADDR_770_UPD);\r\naxs101_set_memmap((void __iomem *) CREG_CPU_ADDR_TUNN,\r\naxc001_axi_tunnel_memmap);\r\niowrite32(1, (void __iomem *) CREG_CPU_ADDR_TUNN_UPD);\r\nfor (i = AXS_MB_MST_TUNNEL_CPU; i <= AXS_MB_MST_USB_OHCI; i++)\r\naxs101_set_memmap((void __iomem *) AXS_MB_CREG + (i << 4),\r\naxs_mb_memmap);\r\niowrite32(0x3ff, (void __iomem *) AXS_MB_CREG + 0x100);\r\niowrite32(0x01, (void __iomem *) CREG_CPU_GPIO_UART_MUX);\r\niowrite32(0x01, (void __iomem *) CREG_MB_IRQ_MUX);\r\niowrite32(0x18, (void __iomem *) CREG_MB_SW_RESET);\r\niowrite32(0x52, (void __iomem *) CREG_CPU_ARC770_IRQ_MUX);\r\naxs10x_early_init();\r\n}\r\nstatic unsigned int __init axs103_get_freq(void)\r\n{\r\nunion pll_reg idiv, fbdiv, odiv;\r\nunsigned int f = 33333333;\r\nidiv.val = ioread32((void __iomem *)AXC003_CGU + 0x80 + 0);\r\nfbdiv.val = ioread32((void __iomem *)AXC003_CGU + 0x80 + 4);\r\nodiv.val = ioread32((void __iomem *)AXC003_CGU + 0x80 + 8);\r\nif (idiv.bypass != 1)\r\nf = f / (idiv.low + idiv.high);\r\nif (fbdiv.bypass != 1)\r\nf = f * (fbdiv.low + fbdiv.high);\r\nif (odiv.bypass != 1)\r\nf = f / (odiv.low + odiv.high);\r\nf = (f + 500000) / 1000000;\r\nreturn f;\r\n}\r\nstatic inline unsigned int __init encode_div(unsigned int id, int upd)\r\n{\r\nunion pll_reg div;\r\ndiv.val = 0;\r\ndiv.noupd = !upd;\r\ndiv.bypass = id == 1 ? 1 : 0;\r\ndiv.edge = (id%2 == 0) ? 0 : 1;\r\ndiv.low = (id%2 == 0) ? id >> 1 : (id >> 1)+1;\r\ndiv.high = id >> 1;\r\nreturn div.val;\r\n}\r\nnoinline static void __init\r\naxs103_set_freq(unsigned int id, unsigned int fd, unsigned int od)\r\n{\r\nwrite_cgu_reg(encode_div(id, 0),\r\n(void __iomem *)AXC003_CGU + 0x80 + 0,\r\n(void __iomem *)AXC003_CGU + 0x110);\r\nwrite_cgu_reg(encode_div(fd, 0),\r\n(void __iomem *)AXC003_CGU + 0x80 + 4,\r\n(void __iomem *)AXC003_CGU + 0x110);\r\nwrite_cgu_reg(encode_div(od, 1),\r\n(void __iomem *)AXC003_CGU + 0x80 + 8,\r\n(void __iomem *)AXC003_CGU + 0x110);\r\n}\r\nstatic void __init axs103_early_init(void)\r\n{\r\nint offset = fdt_path_offset(initial_boot_params, "/cpu_card/core_clk");\r\nconst struct fdt_property *prop = fdt_get_property(initial_boot_params,\r\noffset,\r\n"clock-frequency",\r\nNULL);\r\nu32 freq = be32_to_cpu(*(u32*)(prop->data)) / 1000000, orig = freq;\r\n#ifdef CONFIG_ARC_MCIP\r\nunsigned int num_cores = (read_aux_reg(ARC_REG_MCIP_BCR) >> 16) & 0x3F;\r\nif (num_cores > 2)\r\nfreq = 50;\r\n#endif\r\nswitch (freq) {\r\ncase 33:\r\naxs103_set_freq(1, 1, 1);\r\nbreak;\r\ncase 50:\r\naxs103_set_freq(1, 30, 20);\r\nbreak;\r\ncase 75:\r\naxs103_set_freq(2, 45, 10);\r\nbreak;\r\ncase 90:\r\naxs103_set_freq(2, 54, 10);\r\nbreak;\r\ncase 100:\r\naxs103_set_freq(1, 30, 10);\r\nbreak;\r\ncase 125:\r\naxs103_set_freq(2, 45, 6);\r\nbreak;\r\ndefault:\r\nfreq = axs103_get_freq();\r\nbreak;\r\n}\r\npr_info("Freq is %dMHz\n", freq);\r\nif (freq != orig ) {\r\nfreq = cpu_to_be32(freq * 1000000);\r\nfdt_setprop_inplace(initial_boot_params, offset,\r\n"clock-frequency", &freq, sizeof(freq));\r\n}\r\niowrite32(0x01, (void __iomem *) CREG_CPU_GPIO_UART_MUX);\r\niowrite32((0x00100000U | 0x000C0000U | 0x00003322U),\r\n(void __iomem *) CREG_CPU_TUN_IO_CTRL);\r\niowrite32(12, (void __iomem *) (CREG_CPU_AXI_M0_IRQ_MUX\r\n+ (AXC003_MST_HS38 << 2)));\r\niowrite32(0x01, (void __iomem *) CREG_MB_IRQ_MUX);\r\naxs10x_print_board_ver(AXC003_CREG + 4088, "AXC003 CPU Card");\r\naxs10x_early_init();\r\n}
