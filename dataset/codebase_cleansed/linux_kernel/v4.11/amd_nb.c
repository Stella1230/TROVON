u16 amd_nb_num(void)\r\n{\r\nreturn amd_northbridges.num;\r\n}\r\nbool amd_nb_has_feature(unsigned int feature)\r\n{\r\nreturn ((amd_northbridges.flags & feature) == feature);\r\n}\r\nstruct amd_northbridge *node_to_amd_nb(int node)\r\n{\r\nreturn (node < amd_northbridges.num) ? &amd_northbridges.nb[node] : NULL;\r\n}\r\nstatic struct pci_dev *next_northbridge(struct pci_dev *dev,\r\nconst struct pci_device_id *ids)\r\n{\r\ndo {\r\ndev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev);\r\nif (!dev)\r\nbreak;\r\n} while (!pci_match_id(ids, dev));\r\nreturn dev;\r\n}\r\nstatic int __amd_smn_rw(u16 node, u32 address, u32 *value, bool write)\r\n{\r\nstruct pci_dev *root;\r\nint err = -ENODEV;\r\nif (node >= amd_northbridges.num)\r\ngoto out;\r\nroot = node_to_amd_nb(node)->root;\r\nif (!root)\r\ngoto out;\r\nmutex_lock(&smn_mutex);\r\nerr = pci_write_config_dword(root, 0x60, address);\r\nif (err) {\r\npr_warn("Error programming SMN address 0x%x.\n", address);\r\ngoto out_unlock;\r\n}\r\nerr = (write ? pci_write_config_dword(root, 0x64, *value)\r\n: pci_read_config_dword(root, 0x64, value));\r\nif (err)\r\npr_warn("Error %s SMN address 0x%x.\n",\r\n(write ? "writing to" : "reading from"), address);\r\nout_unlock:\r\nmutex_unlock(&smn_mutex);\r\nout:\r\nreturn err;\r\n}\r\nint amd_smn_read(u16 node, u32 address, u32 *value)\r\n{\r\nreturn __amd_smn_rw(node, address, value, false);\r\n}\r\nint amd_smn_write(u16 node, u32 address, u32 value)\r\n{\r\nreturn __amd_smn_rw(node, address, &value, true);\r\n}\r\nint amd_df_indirect_read(u16 node, u8 func, u16 reg, u8 instance_id, u32 *lo)\r\n{\r\nstruct pci_dev *F4;\r\nu32 ficaa;\r\nint err = -ENODEV;\r\nif (node >= amd_northbridges.num)\r\ngoto out;\r\nF4 = node_to_amd_nb(node)->link;\r\nif (!F4)\r\ngoto out;\r\nficaa = 1;\r\nficaa |= reg & 0x3FC;\r\nficaa |= (func & 0x7) << 11;\r\nficaa |= instance_id << 16;\r\nmutex_lock(&smn_mutex);\r\nerr = pci_write_config_dword(F4, 0x5C, ficaa);\r\nif (err) {\r\npr_warn("Error writing DF Indirect FICAA, FICAA=0x%x\n", ficaa);\r\ngoto out_unlock;\r\n}\r\nerr = pci_read_config_dword(F4, 0x98, lo);\r\nif (err)\r\npr_warn("Error reading DF Indirect FICAD LO, FICAA=0x%x.\n", ficaa);\r\nout_unlock:\r\nmutex_unlock(&smn_mutex);\r\nout:\r\nreturn err;\r\n}\r\nint amd_cache_northbridges(void)\r\n{\r\nu16 i = 0;\r\nstruct amd_northbridge *nb;\r\nstruct pci_dev *root, *misc, *link;\r\nif (amd_northbridges.num)\r\nreturn 0;\r\nmisc = NULL;\r\nwhile ((misc = next_northbridge(misc, amd_nb_misc_ids)) != NULL)\r\ni++;\r\nif (!i)\r\nreturn -ENODEV;\r\nnb = kcalloc(i, sizeof(struct amd_northbridge), GFP_KERNEL);\r\nif (!nb)\r\nreturn -ENOMEM;\r\namd_northbridges.nb = nb;\r\namd_northbridges.num = i;\r\nlink = misc = root = NULL;\r\nfor (i = 0; i != amd_northbridges.num; i++) {\r\nnode_to_amd_nb(i)->root = root =\r\nnext_northbridge(root, amd_root_ids);\r\nnode_to_amd_nb(i)->misc = misc =\r\nnext_northbridge(misc, amd_nb_misc_ids);\r\nnode_to_amd_nb(i)->link = link =\r\nnext_northbridge(link, amd_nb_link_ids);\r\n}\r\nif (amd_gart_present())\r\namd_northbridges.flags |= AMD_NB_GART;\r\nif (!cpuid_edx(0x80000006))\r\nreturn 0;\r\nif (boot_cpu_data.x86 == 0x10 &&\r\nboot_cpu_data.x86_model >= 0x8 &&\r\n(boot_cpu_data.x86_model > 0x9 ||\r\nboot_cpu_data.x86_mask >= 0x1))\r\namd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\r\nif (boot_cpu_data.x86 == 0x15)\r\namd_northbridges.flags |= AMD_NB_L3_INDEX_DISABLE;\r\nif (boot_cpu_data.x86 == 0x15)\r\namd_northbridges.flags |= AMD_NB_L3_PARTITIONING;\r\nreturn 0;\r\n}\r\nbool __init early_is_amd_nb(u32 device)\r\n{\r\nconst struct pci_device_id *id;\r\nu32 vendor = device & 0xffff;\r\ndevice >>= 16;\r\nfor (id = amd_nb_misc_ids; id->vendor; id++)\r\nif (vendor == id->vendor && device == id->device)\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct resource *amd_get_mmconfig_range(struct resource *res)\r\n{\r\nu32 address;\r\nu64 base, msr;\r\nunsigned int segn_busn_bits;\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn NULL;\r\nif (boot_cpu_data.x86 < 0x10)\r\nreturn NULL;\r\naddress = MSR_FAM10H_MMIO_CONF_BASE;\r\nrdmsrl(address, msr);\r\nif (!(msr & FAM10H_MMIO_CONF_ENABLE))\r\nreturn NULL;\r\nbase = msr & (FAM10H_MMIO_CONF_BASE_MASK<<FAM10H_MMIO_CONF_BASE_SHIFT);\r\nsegn_busn_bits = (msr >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) &\r\nFAM10H_MMIO_CONF_BUSRANGE_MASK;\r\nres->flags = IORESOURCE_MEM;\r\nres->start = base;\r\nres->end = base + (1ULL<<(segn_busn_bits + 20)) - 1;\r\nreturn res;\r\n}\r\nint amd_get_subcaches(int cpu)\r\n{\r\nstruct pci_dev *link = node_to_amd_nb(amd_get_nb_id(cpu))->link;\r\nunsigned int mask;\r\nif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING))\r\nreturn 0;\r\npci_read_config_dword(link, 0x1d4, &mask);\r\nreturn (mask >> (4 * cpu_data(cpu).cpu_core_id)) & 0xf;\r\n}\r\nint amd_set_subcaches(int cpu, unsigned long mask)\r\n{\r\nstatic unsigned int reset, ban;\r\nstruct amd_northbridge *nb = node_to_amd_nb(amd_get_nb_id(cpu));\r\nunsigned int reg;\r\nint cuid;\r\nif (!amd_nb_has_feature(AMD_NB_L3_PARTITIONING) || mask > 0xf)\r\nreturn -EINVAL;\r\nif (reset == 0) {\r\npci_read_config_dword(nb->link, 0x1d4, &reset);\r\npci_read_config_dword(nb->misc, 0x1b8, &ban);\r\nban &= 0x180000;\r\n}\r\nif (mask != 0xf) {\r\npci_read_config_dword(nb->misc, 0x1b8, &reg);\r\npci_write_config_dword(nb->misc, 0x1b8, reg & ~0x180000);\r\n}\r\ncuid = cpu_data(cpu).cpu_core_id;\r\nmask <<= 4 * cuid;\r\nmask |= (0xf ^ (1 << cuid)) << 26;\r\npci_write_config_dword(nb->link, 0x1d4, mask);\r\npci_read_config_dword(nb->link, 0x1d4, &reg);\r\nif (reg == reset) {\r\npci_read_config_dword(nb->misc, 0x1b8, &reg);\r\nreg &= ~0x180000;\r\npci_write_config_dword(nb->misc, 0x1b8, reg | ban);\r\n}\r\nreturn 0;\r\n}\r\nstatic void amd_cache_gart(void)\r\n{\r\nu16 i;\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn;\r\nflush_words = kmalloc_array(amd_northbridges.num, sizeof(u32), GFP_KERNEL);\r\nif (!flush_words) {\r\namd_northbridges.flags &= ~AMD_NB_GART;\r\npr_notice("Cannot initialize GART flush words, GART support disabled\n");\r\nreturn;\r\n}\r\nfor (i = 0; i != amd_northbridges.num; i++)\r\npci_read_config_dword(node_to_amd_nb(i)->misc, 0x9c, &flush_words[i]);\r\n}\r\nvoid amd_flush_garts(void)\r\n{\r\nint flushed, i;\r\nunsigned long flags;\r\nstatic DEFINE_SPINLOCK(gart_lock);\r\nif (!amd_nb_has_feature(AMD_NB_GART))\r\nreturn;\r\nspin_lock_irqsave(&gart_lock, flags);\r\nflushed = 0;\r\nfor (i = 0; i < amd_northbridges.num; i++) {\r\npci_write_config_dword(node_to_amd_nb(i)->misc, 0x9c,\r\nflush_words[i] | 1);\r\nflushed++;\r\n}\r\nfor (i = 0; i < amd_northbridges.num; i++) {\r\nu32 w;\r\nfor (;;) {\r\npci_read_config_dword(node_to_amd_nb(i)->misc,\r\n0x9c, &w);\r\nif (!(w & 1))\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nspin_unlock_irqrestore(&gart_lock, flags);\r\nif (!flushed)\r\npr_notice("nothing to flush?\n");\r\n}\r\nstatic __init int init_amd_nbs(void)\r\n{\r\namd_cache_northbridges();\r\namd_cache_gart();\r\nreturn 0;\r\n}
