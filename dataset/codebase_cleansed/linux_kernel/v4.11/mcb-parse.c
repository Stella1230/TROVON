static inline uint32_t get_next_dtype(void __iomem *p)\r\n{\r\nuint32_t dtype;\r\ndtype = readl(p);\r\nreturn dtype >> 28;\r\n}\r\nstatic int chameleon_parse_bdd(struct mcb_bus *bus,\r\nstruct chameleon_bar *cb,\r\nvoid __iomem *base)\r\n{\r\nreturn 0;\r\n}\r\nstatic int chameleon_parse_gdd(struct mcb_bus *bus,\r\nstruct chameleon_bar *cb,\r\nvoid __iomem *base, int bar_count)\r\n{\r\nstruct chameleon_gdd __iomem *gdd =\r\n(struct chameleon_gdd __iomem *) base;\r\nstruct mcb_device *mdev;\r\nu32 dev_mapbase;\r\nu32 offset;\r\nu32 size;\r\nint ret;\r\n__le32 reg1;\r\n__le32 reg2;\r\nmdev = mcb_alloc_dev(bus);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nreg1 = readl(&gdd->reg1);\r\nreg2 = readl(&gdd->reg2);\r\noffset = readl(&gdd->offset);\r\nsize = readl(&gdd->size);\r\nmdev->id = GDD_DEV(reg1);\r\nmdev->rev = GDD_REV(reg1);\r\nmdev->var = GDD_VAR(reg1);\r\nmdev->bar = GDD_BAR(reg2);\r\nmdev->group = GDD_GRP(reg2);\r\nmdev->inst = GDD_INS(reg2);\r\nif (mdev->bar > bar_count - 1) {\r\npr_info("No BAR for 16z%03d\n", mdev->id);\r\nret = 0;\r\ngoto err;\r\n}\r\ndev_mapbase = cb[mdev->bar].addr;\r\nif (!dev_mapbase) {\r\npr_info("BAR not assigned for 16z%03d\n", mdev->id);\r\nret = 0;\r\ngoto err;\r\n}\r\nif (dev_mapbase & 0x01) {\r\npr_info("IO mapped Device (16z%03d) not yet supported\n",\r\nmdev->id);\r\nret = 0;\r\ngoto err;\r\n}\r\npr_debug("Found a 16z%03d\n", mdev->id);\r\nmdev->irq.start = GDD_IRQ(reg1);\r\nmdev->irq.end = GDD_IRQ(reg1);\r\nmdev->irq.flags = IORESOURCE_IRQ;\r\nmdev->mem.start = dev_mapbase + offset;\r\nmdev->mem.end = mdev->mem.start + size - 1;\r\nmdev->mem.flags = IORESOURCE_MEM;\r\nmdev->is_added = false;\r\nret = mcb_device_register(bus, mdev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmcb_free_dev(mdev);\r\nreturn ret;\r\n}\r\nstatic void chameleon_parse_bar(void __iomem *base,\r\nstruct chameleon_bar *cb, int bar_count)\r\n{\r\nchar __iomem *p = base;\r\nint i;\r\np += sizeof(__le32);\r\nfor (i = 0; i < bar_count; i++) {\r\ncb[i].addr = readl(p);\r\ncb[i].size = readl(p + 4);\r\np += sizeof(struct chameleon_bar);\r\n}\r\n}\r\nstatic int chameleon_get_bar(char __iomem **base, phys_addr_t mapbase,\r\nstruct chameleon_bar **cb)\r\n{\r\nstruct chameleon_bar *c;\r\nint bar_count;\r\n__le32 reg;\r\nu32 dtype;\r\ndtype = get_next_dtype(*base);\r\nif (dtype == CHAMELEON_DTYPE_BAR) {\r\nreg = readl(*base);\r\nbar_count = BAR_CNT(reg);\r\nif (bar_count <= 0 || bar_count > CHAMELEON_BAR_MAX)\r\nreturn -ENODEV;\r\nc = kcalloc(bar_count, sizeof(struct chameleon_bar),\r\nGFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\nchameleon_parse_bar(*base, c, bar_count);\r\n*base += BAR_DESC_SIZE(bar_count);\r\n} else {\r\nc = kzalloc(sizeof(struct chameleon_bar), GFP_KERNEL);\r\nif (!c)\r\nreturn -ENOMEM;\r\nbar_count = 1;\r\nc->addr = mapbase;\r\n}\r\n*cb = c;\r\nreturn bar_count;\r\n}\r\nint chameleon_parse_cells(struct mcb_bus *bus, phys_addr_t mapbase,\r\nvoid __iomem *base)\r\n{\r\nstruct chameleon_fpga_header *header;\r\nstruct chameleon_bar *cb;\r\nchar __iomem *p = base;\r\nint num_cells = 0;\r\nuint32_t dtype;\r\nint bar_count;\r\nint ret = 0;\r\nu32 hsize;\r\nhsize = sizeof(struct chameleon_fpga_header);\r\nheader = kzalloc(hsize, GFP_KERNEL);\r\nif (!header)\r\nreturn -ENOMEM;\r\nmemcpy_fromio(header, p, hsize);\r\nheader->magic = le16_to_cpu(header->magic);\r\nif (header->magic != CHAMELEONV2_MAGIC) {\r\npr_err("Unsupported chameleon version 0x%x\n",\r\nheader->magic);\r\nret = -ENODEV;\r\ngoto free_header;\r\n}\r\np += hsize;\r\nbus->revision = header->revision;\r\nbus->model = header->model;\r\nbus->minor = header->minor;\r\nsnprintf(bus->name, CHAMELEON_FILENAME_LEN + 1, "%s",\r\nheader->filename);\r\nbar_count = chameleon_get_bar(&p, mapbase, &cb);\r\nif (bar_count < 0)\r\ngoto free_header;\r\nfor_each_chameleon_cell(dtype, p) {\r\nswitch (dtype) {\r\ncase CHAMELEON_DTYPE_GENERAL:\r\nret = chameleon_parse_gdd(bus, cb, p, bar_count);\r\nif (ret < 0)\r\ngoto free_bar;\r\np += sizeof(struct chameleon_gdd);\r\nbreak;\r\ncase CHAMELEON_DTYPE_BRIDGE:\r\nchameleon_parse_bdd(bus, cb, p);\r\np += sizeof(struct chameleon_bdd);\r\nbreak;\r\ncase CHAMELEON_DTYPE_END:\r\nbreak;\r\ndefault:\r\npr_err("Invalid chameleon descriptor type 0x%x\n",\r\ndtype);\r\nret = -EINVAL;\r\ngoto free_bar;\r\n}\r\nnum_cells++;\r\n}\r\nif (num_cells == 0)\r\nnum_cells = -EINVAL;\r\nkfree(cb);\r\nkfree(header);\r\nreturn num_cells;\r\nfree_bar:\r\nkfree(cb);\r\nfree_header:\r\nkfree(header);\r\nreturn ret;\r\n}
