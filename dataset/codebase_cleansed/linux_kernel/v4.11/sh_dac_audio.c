static void dac_audio_start_timer(struct snd_sh_dac *chip)\r\n{\r\nhrtimer_start(&chip->hrtimer, chip->wakeups_per_second,\r\nHRTIMER_MODE_REL);\r\n}\r\nstatic void dac_audio_stop_timer(struct snd_sh_dac *chip)\r\n{\r\nhrtimer_cancel(&chip->hrtimer);\r\n}\r\nstatic void dac_audio_reset(struct snd_sh_dac *chip)\r\n{\r\ndac_audio_stop_timer(chip);\r\nchip->buffer_begin = chip->buffer_end = chip->data_buffer;\r\nchip->processed = 0;\r\nchip->empty = 1;\r\n}\r\nstatic void dac_audio_set_rate(struct snd_sh_dac *chip)\r\n{\r\nchip->wakeups_per_second = 1000000000 / chip->rate;\r\n}\r\nstatic int snd_sh_dac_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_sh_dac_pcm_hw;\r\nchip->substream = substream;\r\nchip->buffer_begin = chip->buffer_end = chip->data_buffer;\r\nchip->processed = 0;\r\nchip->empty = 1;\r\nchip->pdata->start(chip->pdata);\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nchip->substream = NULL;\r\ndac_audio_stop_timer(chip);\r\nchip->pdata->stop(chip->pdata);\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_sh_dac_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_sh_dac_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = chip->substream->runtime;\r\nchip->buffer_size = runtime->buffer_size;\r\nmemset(chip->data_buffer, 0, chip->pdata->buffer_size);\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndac_audio_start_timer(chip);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nchip->buffer_begin = chip->buffer_end = chip->data_buffer;\r\nchip->processed = 0;\r\nchip->empty = 1;\r\ndac_audio_stop_timer(chip);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_pcm_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nssize_t b_count = frames_to_bytes(runtime , count);\r\nssize_t b_pos = frames_to_bytes(runtime , pos);\r\nif (count < 0)\r\nreturn -EINVAL;\r\nif (!count)\r\nreturn 0;\r\nmemcpy_toio(chip->data_buffer + b_pos, src, b_count);\r\nchip->buffer_end = chip->data_buffer + b_pos + b_count;\r\nif (chip->empty) {\r\nchip->empty = 0;\r\ndac_audio_start_timer(chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_pcm_silence(struct snd_pcm_substream *substream,\r\nint channel, snd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nssize_t b_count = frames_to_bytes(runtime , count);\r\nssize_t b_pos = frames_to_bytes(runtime , pos);\r\nif (count < 0)\r\nreturn -EINVAL;\r\nif (!count)\r\nreturn 0;\r\nmemset_io(chip->data_buffer + b_pos, 0, b_count);\r\nchip->buffer_end = chip->data_buffer + b_pos + b_count;\r\nif (chip->empty) {\r\nchip->empty = 0;\r\ndac_audio_start_timer(chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nsnd_pcm_uframes_t snd_sh_dac_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\r\nint pointer = chip->buffer_begin - chip->data_buffer;\r\nreturn pointer;\r\n}\r\nstatic int snd_sh_dac_pcm(struct snd_sh_dac *chip, int device)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nerr = snd_pcm_new(chip->card, "SH_DAC PCM", device, 1, 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "SH_DAC PCM");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sh_dac_pcm_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n48 * 1024,\r\n48 * 1024);\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_free(struct snd_sh_dac *chip)\r\n{\r\nkfree(chip->data_buffer);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_sh_dac *chip = device->device_data;\r\nreturn snd_sh_dac_free(chip);\r\n}\r\nstatic enum hrtimer_restart sh_dac_audio_timer(struct hrtimer *handle)\r\n{\r\nstruct snd_sh_dac *chip = container_of(handle, struct snd_sh_dac,\r\nhrtimer);\r\nstruct snd_pcm_runtime *runtime = chip->substream->runtime;\r\nssize_t b_ps = frames_to_bytes(runtime, runtime->period_size);\r\nif (!chip->empty) {\r\nsh_dac_output(*chip->buffer_begin, chip->pdata->channel);\r\nchip->buffer_begin++;\r\nchip->processed++;\r\nif (chip->processed >= b_ps) {\r\nchip->processed -= b_ps;\r\nsnd_pcm_period_elapsed(chip->substream);\r\n}\r\nif (chip->buffer_begin == (chip->data_buffer +\r\nchip->buffer_size - 1))\r\nchip->buffer_begin = chip->data_buffer;\r\nif (chip->buffer_begin == chip->buffer_end)\r\nchip->empty = 1;\r\n}\r\nif (!chip->empty)\r\nhrtimer_start(&chip->hrtimer, chip->wakeups_per_second,\r\nHRTIMER_MODE_REL);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int snd_sh_dac_create(struct snd_card *card,\r\nstruct platform_device *devptr,\r\nstruct snd_sh_dac **rchip)\r\n{\r\nstruct snd_sh_dac *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_sh_dac_dev_free,\r\n};\r\n*rchip = NULL;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->card = card;\r\nhrtimer_init(&chip->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nchip->hrtimer.function = sh_dac_audio_timer;\r\ndac_audio_reset(chip);\r\nchip->rate = 8000;\r\ndac_audio_set_rate(chip);\r\nchip->pdata = devptr->dev.platform_data;\r\nchip->data_buffer = kmalloc(chip->pdata->buffer_size, GFP_KERNEL);\r\nif (chip->data_buffer == NULL) {\r\nkfree(chip);\r\nreturn -ENOMEM;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_sh_dac_free(chip);\r\nreturn err;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_sh_dac_probe(struct platform_device *devptr)\r\n{\r\nstruct snd_sh_dac *chip;\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_card_new(&devptr->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "cannot allocate the card\n");\r\nreturn err;\r\n}\r\nerr = snd_sh_dac_create(card, devptr, &chip);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = snd_sh_dac_pcm(chip, 0);\r\nif (err < 0)\r\ngoto probe_error;\r\nstrcpy(card->driver, "snd_sh_dac");\r\nstrcpy(card->shortname, "SuperH DAC audio driver");\r\nprintk(KERN_INFO "%s %s", card->longname, card->shortname);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto probe_error;\r\nsnd_printk("ALSA driver for SuperH DAC audio");\r\nplatform_set_drvdata(devptr, card);\r\nreturn 0;\r\nprobe_error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}
