static void vt6655_remove(struct pci_dev *pcid)\r\n{\r\nstruct vnt_private *priv = pci_get_drvdata(pcid);\r\nif (priv == NULL)\r\nreturn;\r\ndevice_free_info(priv);\r\n}\r\nstatic void device_get_options(struct vnt_private *priv)\r\n{\r\nstruct vnt_options *opts = &priv->opts;\r\nopts->rx_descs0 = RX_DESC_DEF0;\r\nopts->rx_descs1 = RX_DESC_DEF1;\r\nopts->tx_descs[0] = TX_DESC_DEF0;\r\nopts->tx_descs[1] = TX_DESC_DEF1;\r\nopts->int_works = INT_WORKS_DEF;\r\nopts->short_retry = SHORT_RETRY_DEF;\r\nopts->long_retry = LONG_RETRY_DEF;\r\nopts->bbp_type = BBP_TYPE_DEF;\r\n}\r\nstatic void\r\ndevice_set_options(struct vnt_private *priv)\r\n{\r\npriv->byShortRetryLimit = priv->opts.short_retry;\r\npriv->byLongRetryLimit = priv->opts.long_retry;\r\npriv->byBBType = priv->opts.bbp_type;\r\npriv->byPacketType = priv->byBBType;\r\npriv->byAutoFBCtrl = AUTO_FB_0;\r\npriv->bUpdateBBVGA = true;\r\npriv->byPreambleType = 0;\r\npr_debug(" byShortRetryLimit= %d\n", (int)priv->byShortRetryLimit);\r\npr_debug(" byLongRetryLimit= %d\n", (int)priv->byLongRetryLimit);\r\npr_debug(" byPreambleType= %d\n", (int)priv->byPreambleType);\r\npr_debug(" byShortPreamble= %d\n", (int)priv->byShortPreamble);\r\npr_debug(" byBBType= %d\n", (int)priv->byBBType);\r\n}\r\nstatic void device_init_registers(struct vnt_private *priv)\r\n{\r\nunsigned long flags;\r\nunsigned int ii;\r\nunsigned char byValue;\r\nunsigned char byCCKPwrdBm = 0;\r\nunsigned char byOFDMPwrdBm = 0;\r\nMACbShutdown(priv);\r\nBBvSoftwareReset(priv);\r\nMACbSoftwareReset(priv);\r\npriv->bAES = false;\r\npriv->bProtectMode = false;\r\npriv->bNonERPPresent = false;\r\npriv->bBarkerPreambleMd = false;\r\npriv->wCurrentRate = RATE_1M;\r\npriv->byTopOFDMBasicRate = RATE_24M;\r\npriv->byTopCCKBasicRate = RATE_1M;\r\nMACvInitialize(priv);\r\nVNSvInPortB(priv->PortOffset + MAC_REG_LOCALID, &priv->byLocalID);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nSROMvReadAllContents(priv->PortOffset, priv->abyEEPROM);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npriv->byMinChannel = 1;\r\npriv->byMaxChannel = CB_MAX_CHANNEL;\r\nbyValue = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_ANTENNA);\r\nif (byValue & EEP_ANTINV)\r\npriv->bTxRxAntInv = true;\r\nelse\r\npriv->bTxRxAntInv = false;\r\nbyValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byValue == 0)\r\nbyValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\r\npriv->byAntennaCount = 2;\r\npriv->byTxAntennaMode = ANT_B;\r\npriv->dwTxAntennaSel = 1;\r\npriv->dwRxAntennaSel = 1;\r\nif (priv->bTxRxAntInv)\r\npriv->byRxAntennaMode = ANT_A;\r\nelse\r\npriv->byRxAntennaMode = ANT_B;\r\n} else {\r\npriv->byAntennaCount = 1;\r\npriv->dwTxAntennaSel = 0;\r\npriv->dwRxAntennaSel = 0;\r\nif (byValue & EEP_ANTENNA_AUX) {\r\npriv->byTxAntennaMode = ANT_A;\r\nif (priv->bTxRxAntInv)\r\npriv->byRxAntennaMode = ANT_B;\r\nelse\r\npriv->byRxAntennaMode = ANT_A;\r\n} else {\r\npriv->byTxAntennaMode = ANT_B;\r\nif (priv->bTxRxAntInv)\r\npriv->byRxAntennaMode = ANT_A;\r\nelse\r\npriv->byRxAntennaMode = ANT_B;\r\n}\r\n}\r\nBBvSetTxAntennaMode(priv, priv->byTxAntennaMode);\r\nBBvSetRxAntennaMode(priv, priv->byRxAntennaMode);\r\npriv->byOriginalZonetype = priv->abyEEPROM[EEP_OFS_ZONETYPE];\r\nif (!priv->bZoneRegExist)\r\npriv->byZoneType = priv->abyEEPROM[EEP_OFS_ZONETYPE];\r\npr_debug("priv->byZoneType = %x\n", priv->byZoneType);\r\nRFbInit(priv);\r\npriv->byCurPwr = 0xFF;\r\npriv->byCCKPwr = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_CCK);\r\npriv->byOFDMPwrG = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_PWR_OFDMG);\r\nfor (ii = 0; ii < CB_MAX_CHANNEL_24G; ii++) {\r\npriv->abyCCKPwrTbl[ii + 1] =\r\nSROMbyReadEmbedded(priv->PortOffset,\r\n(unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));\r\nif (priv->abyCCKPwrTbl[ii + 1] == 0)\r\npriv->abyCCKPwrTbl[ii + 1] = priv->byCCKPwr;\r\npriv->abyOFDMPwrTbl[ii + 1] =\r\nSROMbyReadEmbedded(priv->PortOffset,\r\n(unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));\r\nif (priv->abyOFDMPwrTbl[ii + 1] == 0)\r\npriv->abyOFDMPwrTbl[ii + 1] = priv->byOFDMPwrG;\r\npriv->abyCCKDefaultPwr[ii + 1] = byCCKPwrdBm;\r\npriv->abyOFDMDefaultPwr[ii + 1] = byOFDMPwrdBm;\r\n}\r\nfor (ii = 11; ii < 14; ii++) {\r\npriv->abyCCKPwrTbl[ii] = priv->abyCCKPwrTbl[10];\r\npriv->abyOFDMPwrTbl[ii] = priv->abyOFDMPwrTbl[10];\r\n}\r\nfor (ii = 0; ii < CB_MAX_CHANNEL_5G; ii++) {\r\npriv->abyOFDMPwrTbl[ii + CB_MAX_CHANNEL_24G + 1] =\r\nSROMbyReadEmbedded(priv->PortOffset,\r\n(unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));\r\npriv->abyOFDMDefaultPwr[ii + CB_MAX_CHANNEL_24G + 1] =\r\nSROMbyReadEmbedded(priv->PortOffset,\r\n(unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));\r\n}\r\nif (priv->byLocalID > REV_ID_VT3253_B1) {\r\nMACvSelectPage1(priv->PortOffset);\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_MSRCTL + 1,\r\n(MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));\r\nMACvSelectPage0(priv->PortOffset);\r\n}\r\nMACvWordRegBitsOn(priv->PortOffset,\r\nMAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));\r\nMACvSetShortRetryLimit(priv, priv->byShortRetryLimit);\r\nMACvSetLongRetryLimit(priv, priv->byLongRetryLimit);\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nBBbVT3253Init(priv);\r\nif (priv->bUpdateBBVGA) {\r\npriv->byBBVGACurrent = priv->abyBBVGA[0];\r\npriv->byBBVGANew = priv->byBBVGACurrent;\r\nBBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);\r\n}\r\nBBvSetRxAntennaMode(priv, priv->byRxAntennaMode);\r\nBBvSetTxAntennaMode(priv, priv->byTxAntennaMode);\r\npriv->wCurrentRate = RATE_54M;\r\npriv->bRadioOff = false;\r\npriv->byRadioCtl = SROMbyReadEmbedded(priv->PortOffset,\r\nEEP_OFS_RADIOCTL);\r\npriv->bHWRadioOff = false;\r\nif (priv->byRadioCtl & EEP_RADIOCTL_ENABLE) {\r\nMACvGPIOIn(priv->PortOffset, &priv->byGPIO);\r\nif (((priv->byGPIO & GPIO0_DATA) &&\r\n!(priv->byRadioCtl & EEP_RADIOCTL_INV)) ||\r\n(!(priv->byGPIO & GPIO0_DATA) &&\r\n(priv->byRadioCtl & EEP_RADIOCTL_INV)))\r\npriv->bHWRadioOff = true;\r\n}\r\nif (priv->bHWRadioOff || priv->bRadioControlOff)\r\nCARDbRadioPowerOff(priv);\r\nSROMvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);\r\npr_debug("Network address = %pM\n", priv->abyCurrentNetAddr);\r\nCARDvSafeResetRx(priv);\r\nCARDvSafeResetTx(priv);\r\nif (priv->byLocalID <= REV_ID_VT3253_A1)\r\nMACvRegBitsOn(priv->PortOffset, MAC_REG_RCR, RCR_WPAERR);\r\nMACvReceive0(priv->PortOffset);\r\nMACvReceive1(priv->PortOffset);\r\nMACvStart(priv->PortOffset);\r\n}\r\nstatic void device_print_info(struct vnt_private *priv)\r\n{\r\ndev_info(&priv->pcid->dev, "MAC=%pM IO=0x%lx Mem=0x%lx IRQ=%d\n",\r\npriv->abyCurrentNetAddr, (unsigned long)priv->ioaddr,\r\n(unsigned long)priv->PortOffset, priv->pcid->irq);\r\n}\r\nstatic void device_free_info(struct vnt_private *priv)\r\n{\r\nif (!priv)\r\nreturn;\r\nif (priv->mac_hw)\r\nieee80211_unregister_hw(priv->hw);\r\nif (priv->PortOffset)\r\niounmap(priv->PortOffset);\r\nif (priv->pcid)\r\npci_release_regions(priv->pcid);\r\nif (priv->hw)\r\nieee80211_free_hw(priv->hw);\r\n}\r\nstatic bool device_init_rings(struct vnt_private *priv)\r\n{\r\nvoid *vir_pool;\r\nvir_pool = dma_zalloc_coherent(&priv->pcid->dev,\r\npriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\r\npriv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\r\n&priv->pool_dma, GFP_ATOMIC);\r\nif (vir_pool == NULL) {\r\ndev_err(&priv->pcid->dev, "allocate desc dma memory failed\n");\r\nreturn false;\r\n}\r\npriv->aRD0Ring = vir_pool;\r\npriv->aRD1Ring = vir_pool +\r\npriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);\r\npriv->rd0_pool_dma = priv->pool_dma;\r\npriv->rd1_pool_dma = priv->rd0_pool_dma +\r\npriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc);\r\npriv->tx0_bufs = dma_zalloc_coherent(&priv->pcid->dev,\r\npriv->opts.tx_descs[0] * PKT_BUF_SZ +\r\npriv->opts.tx_descs[1] * PKT_BUF_SZ +\r\nCB_BEACON_BUF_SIZE +\r\nCB_MAX_BUF_SIZE,\r\n&priv->tx_bufs_dma0,\r\nGFP_ATOMIC);\r\nif (!priv->tx0_bufs) {\r\ndev_err(&priv->pcid->dev, "allocate buf dma memory failed\n");\r\ndma_free_coherent(&priv->pcid->dev,\r\npriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\r\npriv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\r\nvir_pool, priv->pool_dma);\r\nreturn false;\r\n}\r\npriv->td0_pool_dma = priv->rd1_pool_dma +\r\npriv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);\r\npriv->td1_pool_dma = priv->td0_pool_dma +\r\npriv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);\r\npriv->apTD0Rings = vir_pool\r\n+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)\r\n+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc);\r\npriv->apTD1Rings = vir_pool\r\n+ priv->opts.rx_descs0 * sizeof(struct vnt_rx_desc)\r\n+ priv->opts.rx_descs1 * sizeof(struct vnt_rx_desc)\r\n+ priv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc);\r\npriv->tx1_bufs = priv->tx0_bufs +\r\npriv->opts.tx_descs[0] * PKT_BUF_SZ;\r\npriv->tx_beacon_bufs = priv->tx1_bufs +\r\npriv->opts.tx_descs[1] * PKT_BUF_SZ;\r\npriv->pbyTmpBuff = priv->tx_beacon_bufs +\r\nCB_BEACON_BUF_SIZE;\r\npriv->tx_bufs_dma1 = priv->tx_bufs_dma0 +\r\npriv->opts.tx_descs[0] * PKT_BUF_SZ;\r\npriv->tx_beacon_dma = priv->tx_bufs_dma1 +\r\npriv->opts.tx_descs[1] * PKT_BUF_SZ;\r\nreturn true;\r\n}\r\nstatic void device_free_rings(struct vnt_private *priv)\r\n{\r\ndma_free_coherent(&priv->pcid->dev,\r\npriv->opts.rx_descs0 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.rx_descs1 * sizeof(struct vnt_rx_desc) +\r\npriv->opts.tx_descs[0] * sizeof(struct vnt_tx_desc) +\r\npriv->opts.tx_descs[1] * sizeof(struct vnt_tx_desc),\r\npriv->aRD0Ring, priv->pool_dma);\r\nif (priv->tx0_bufs)\r\ndma_free_coherent(&priv->pcid->dev,\r\npriv->opts.tx_descs[0] * PKT_BUF_SZ +\r\npriv->opts.tx_descs[1] * PKT_BUF_SZ +\r\nCB_BEACON_BUF_SIZE +\r\nCB_MAX_BUF_SIZE,\r\npriv->tx0_bufs, priv->tx_bufs_dma0);\r\n}\r\nstatic void device_init_rd0_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\ndma_addr_t curr = priv->rd0_pool_dma;\r\nstruct vnt_rx_desc *desc;\r\nfor (i = 0; i < priv->opts.rx_descs0;\r\ni ++, curr += sizeof(struct vnt_rx_desc)) {\r\ndesc = &priv->aRD0Ring[i];\r\ndesc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);\r\nif (!device_alloc_rx_buf(priv, desc))\r\ndev_err(&priv->pcid->dev, "can not alloc rx bufs\n");\r\ndesc->next = &(priv->aRD0Ring[(i + 1) % priv->opts.rx_descs0]);\r\ndesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));\r\n}\r\nif (i > 0)\r\npriv->aRD0Ring[i-1].next_desc = cpu_to_le32(priv->rd0_pool_dma);\r\npriv->pCurrRD[0] = &priv->aRD0Ring[0];\r\n}\r\nstatic void device_init_rd1_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\ndma_addr_t curr = priv->rd1_pool_dma;\r\nstruct vnt_rx_desc *desc;\r\nfor (i = 0; i < priv->opts.rx_descs1;\r\ni ++, curr += sizeof(struct vnt_rx_desc)) {\r\ndesc = &priv->aRD1Ring[i];\r\ndesc->rd_info = kzalloc(sizeof(*desc->rd_info), GFP_ATOMIC);\r\nif (!device_alloc_rx_buf(priv, desc))\r\ndev_err(&priv->pcid->dev, "can not alloc rx bufs\n");\r\ndesc->next = &(priv->aRD1Ring[(i+1) % priv->opts.rx_descs1]);\r\ndesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_rx_desc));\r\n}\r\nif (i > 0)\r\npriv->aRD1Ring[i-1].next_desc = cpu_to_le32(priv->rd1_pool_dma);\r\npriv->pCurrRD[1] = &priv->aRD1Ring[0];\r\n}\r\nstatic void device_free_rd0_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->opts.rx_descs0; i++) {\r\nstruct vnt_rx_desc *desc = &(priv->aRD0Ring[i]);\r\nstruct vnt_rd_info *rd_info = desc->rd_info;\r\ndma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,\r\npriv->rx_buf_sz, DMA_FROM_DEVICE);\r\ndev_kfree_skb(rd_info->skb);\r\nkfree(desc->rd_info);\r\n}\r\n}\r\nstatic void device_free_rd1_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->opts.rx_descs1; i++) {\r\nstruct vnt_rx_desc *desc = &priv->aRD1Ring[i];\r\nstruct vnt_rd_info *rd_info = desc->rd_info;\r\ndma_unmap_single(&priv->pcid->dev, rd_info->skb_dma,\r\npriv->rx_buf_sz, DMA_FROM_DEVICE);\r\ndev_kfree_skb(rd_info->skb);\r\nkfree(desc->rd_info);\r\n}\r\n}\r\nstatic void device_init_td0_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\ndma_addr_t curr;\r\nstruct vnt_tx_desc *desc;\r\ncurr = priv->td0_pool_dma;\r\nfor (i = 0; i < priv->opts.tx_descs[0];\r\ni++, curr += sizeof(struct vnt_tx_desc)) {\r\ndesc = &priv->apTD0Rings[i];\r\ndesc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);\r\ndesc->td_info->buf = priv->tx0_bufs + i * PKT_BUF_SZ;\r\ndesc->td_info->buf_dma = priv->tx_bufs_dma0 + i * PKT_BUF_SZ;\r\ndesc->next = &(priv->apTD0Rings[(i+1) % priv->opts.tx_descs[0]]);\r\ndesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));\r\n}\r\nif (i > 0)\r\npriv->apTD0Rings[i-1].next_desc = cpu_to_le32(priv->td0_pool_dma);\r\npriv->apTailTD[0] = priv->apCurrTD[0] = &priv->apTD0Rings[0];\r\n}\r\nstatic void device_init_td1_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\ndma_addr_t curr;\r\nstruct vnt_tx_desc *desc;\r\ncurr = priv->td1_pool_dma;\r\nfor (i = 0; i < priv->opts.tx_descs[1];\r\ni++, curr += sizeof(struct vnt_tx_desc)) {\r\ndesc = &priv->apTD1Rings[i];\r\ndesc->td_info = kzalloc(sizeof(*desc->td_info), GFP_ATOMIC);\r\ndesc->td_info->buf = priv->tx1_bufs + i * PKT_BUF_SZ;\r\ndesc->td_info->buf_dma = priv->tx_bufs_dma1 + i * PKT_BUF_SZ;\r\ndesc->next = &(priv->apTD1Rings[(i + 1) % priv->opts.tx_descs[1]]);\r\ndesc->next_desc = cpu_to_le32(curr + sizeof(struct vnt_tx_desc));\r\n}\r\nif (i > 0)\r\npriv->apTD1Rings[i-1].next_desc = cpu_to_le32(priv->td1_pool_dma);\r\npriv->apTailTD[1] = priv->apCurrTD[1] = &priv->apTD1Rings[0];\r\n}\r\nstatic void device_free_td0_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->opts.tx_descs[0]; i++) {\r\nstruct vnt_tx_desc *desc = &priv->apTD0Rings[i];\r\nstruct vnt_td_info *td_info = desc->td_info;\r\ndev_kfree_skb(td_info->skb);\r\nkfree(desc->td_info);\r\n}\r\n}\r\nstatic void device_free_td1_ring(struct vnt_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->opts.tx_descs[1]; i++) {\r\nstruct vnt_tx_desc *desc = &priv->apTD1Rings[i];\r\nstruct vnt_td_info *td_info = desc->td_info;\r\ndev_kfree_skb(td_info->skb);\r\nkfree(desc->td_info);\r\n}\r\n}\r\nstatic int device_rx_srv(struct vnt_private *priv, unsigned int idx)\r\n{\r\nstruct vnt_rx_desc *rd;\r\nint works = 0;\r\nfor (rd = priv->pCurrRD[idx];\r\nrd->rd0.owner == OWNED_BY_HOST;\r\nrd = rd->next) {\r\nif (works++ > 15)\r\nbreak;\r\nif (!rd->rd_info->skb)\r\nbreak;\r\nif (vnt_receive_frame(priv, rd)) {\r\nif (!device_alloc_rx_buf(priv, rd)) {\r\ndev_err(&priv->pcid->dev,\r\n"can not allocate rx buf\n");\r\nbreak;\r\n}\r\n}\r\nrd->rd0.owner = OWNED_BY_NIC;\r\n}\r\npriv->pCurrRD[idx] = rd;\r\nreturn works;\r\n}\r\nstatic bool device_alloc_rx_buf(struct vnt_private *priv,\r\nstruct vnt_rx_desc *rd)\r\n{\r\nstruct vnt_rd_info *rd_info = rd->rd_info;\r\nrd_info->skb = dev_alloc_skb((int)priv->rx_buf_sz);\r\nif (!rd_info->skb)\r\nreturn false;\r\nrd_info->skb_dma =\r\ndma_map_single(&priv->pcid->dev,\r\nskb_put(rd_info->skb, skb_tailroom(rd_info->skb)),\r\npriv->rx_buf_sz, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&priv->pcid->dev, rd_info->skb_dma)) {\r\ndev_kfree_skb(rd_info->skb);\r\nrd_info->skb = NULL;\r\nreturn false;\r\n}\r\n*((unsigned int *)&rd->rd0) = 0;\r\nrd->rd0.res_count = cpu_to_le16(priv->rx_buf_sz);\r\nrd->rd0.owner = OWNED_BY_NIC;\r\nrd->rd1.req_count = cpu_to_le16(priv->rx_buf_sz);\r\nrd->buff_addr = cpu_to_le32(rd_info->skb_dma);\r\nreturn true;\r\n}\r\nstatic int vnt_int_report_rate(struct vnt_private *priv,\r\nstruct vnt_td_info *context, u8 tsr0, u8 tsr1)\r\n{\r\nstruct vnt_tx_fifo_head *fifo_head;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_rate *rate;\r\nu16 fb_option;\r\nu8 tx_retry = (tsr0 & TSR0_NCR);\r\ns8 idx;\r\nif (!context)\r\nreturn -ENOMEM;\r\nif (!context->skb)\r\nreturn -EINVAL;\r\nfifo_head = (struct vnt_tx_fifo_head *)context->buf;\r\nfb_option = (le16_to_cpu(fifo_head->fifo_ctl) &\r\n(FIFOCTL_AUTO_FB_0 | FIFOCTL_AUTO_FB_1));\r\ninfo = IEEE80211_SKB_CB(context->skb);\r\nidx = info->control.rates[0].idx;\r\nif (fb_option && !(tsr1 & TSR1_TERR)) {\r\nu8 tx_rate;\r\nu8 retry = tx_retry;\r\nrate = ieee80211_get_tx_rate(priv->hw, info);\r\ntx_rate = rate->hw_value - RATE_18M;\r\nif (retry > 4)\r\nretry = 4;\r\nif (fb_option & FIFOCTL_AUTO_FB_0)\r\ntx_rate = fallback_rate0[tx_rate][retry];\r\nelse if (fb_option & FIFOCTL_AUTO_FB_1)\r\ntx_rate = fallback_rate1[tx_rate][retry];\r\nif (info->band == NL80211_BAND_5GHZ)\r\nidx = tx_rate - RATE_6M;\r\nelse\r\nidx = tx_rate;\r\n}\r\nieee80211_tx_info_clear_status(info);\r\ninfo->status.rates[0].count = tx_retry;\r\nif (!(tsr1 & TSR1_TERR)) {\r\ninfo->status.rates[0].idx = idx;\r\nif (info->flags & IEEE80211_TX_CTL_NO_ACK)\r\ninfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\r\nelse\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_tx_srv(struct vnt_private *priv, unsigned int idx)\r\n{\r\nstruct vnt_tx_desc *desc;\r\nint works = 0;\r\nunsigned char byTsr0;\r\nunsigned char byTsr1;\r\nfor (desc = priv->apTailTD[idx]; priv->iTDUsed[idx] > 0; desc = desc->next) {\r\nif (desc->td0.owner == OWNED_BY_NIC)\r\nbreak;\r\nif (works++ > 15)\r\nbreak;\r\nbyTsr0 = desc->td0.tsr0;\r\nbyTsr1 = desc->td0.tsr1;\r\nif (desc->td1.tcr & TCR_STP) {\r\nif ((desc->td_info->flags & TD_FLAGS_NETIF_SKB) != 0) {\r\nif (!(byTsr1 & TSR1_TERR)) {\r\nif (byTsr0 != 0) {\r\npr_debug(" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n",\r\n(int)idx, byTsr1,\r\nbyTsr0);\r\n}\r\n} else {\r\npr_debug(" Tx[%d] dropped & tsr1[%02X] tsr0[%02X]\n",\r\n(int)idx, byTsr1, byTsr0);\r\n}\r\n}\r\nif (byTsr1 & TSR1_TERR) {\r\nif ((desc->td_info->flags & TD_FLAGS_PRIV_SKB) != 0) {\r\npr_debug(" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X]\n",\r\n(int)idx, byTsr1, byTsr0);\r\n}\r\n}\r\nvnt_int_report_rate(priv, desc->td_info, byTsr0, byTsr1);\r\ndevice_free_tx_buf(priv, desc);\r\npriv->iTDUsed[idx]--;\r\n}\r\n}\r\npriv->apTailTD[idx] = desc;\r\nreturn works;\r\n}\r\nstatic void device_error(struct vnt_private *priv, unsigned short status)\r\n{\r\nif (status & ISR_FETALERR) {\r\ndev_err(&priv->pcid->dev, "Hardware fatal error\n");\r\nMACbShutdown(priv);\r\nreturn;\r\n}\r\n}\r\nstatic void device_free_tx_buf(struct vnt_private *priv,\r\nstruct vnt_tx_desc *desc)\r\n{\r\nstruct vnt_td_info *td_info = desc->td_info;\r\nstruct sk_buff *skb = td_info->skb;\r\nif (skb)\r\nieee80211_tx_status_irqsafe(priv->hw, skb);\r\ntd_info->skb = NULL;\r\ntd_info->flags = 0;\r\n}\r\nstatic void vnt_check_bb_vga(struct vnt_private *priv)\r\n{\r\nlong dbm;\r\nint i;\r\nif (!priv->bUpdateBBVGA)\r\nreturn;\r\nif (priv->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)\r\nreturn;\r\nif (!(priv->vif->bss_conf.assoc && priv->uCurrRSSI))\r\nreturn;\r\nRFvRSSITodBm(priv, (u8)priv->uCurrRSSI, &dbm);\r\nfor (i = 0; i < BB_VGA_LEVEL; i++) {\r\nif (dbm < priv->ldBmThreshold[i]) {\r\npriv->byBBVGANew = priv->abyBBVGA[i];\r\nbreak;\r\n}\r\n}\r\nif (priv->byBBVGANew == priv->byBBVGACurrent) {\r\npriv->uBBVGADiffCount = 1;\r\nreturn;\r\n}\r\npriv->uBBVGADiffCount++;\r\nif (priv->uBBVGADiffCount == 1) {\r\nBBvSetVGAGainOffset(priv, priv->byBBVGANew);\r\ndev_dbg(&priv->pcid->dev,\r\n"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",\r\n(int)dbm, priv->byBBVGANew,\r\npriv->byBBVGACurrent,\r\n(int)priv->uBBVGADiffCount);\r\n}\r\nif (priv->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {\r\ndev_dbg(&priv->pcid->dev,\r\n"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",\r\n(int)dbm, priv->byBBVGANew,\r\npriv->byBBVGACurrent,\r\n(int)priv->uBBVGADiffCount);\r\nBBvSetVGAGainOffset(priv, priv->byBBVGANew);\r\n}\r\n}\r\nstatic void vnt_interrupt_process(struct vnt_private *priv)\r\n{\r\nstruct ieee80211_low_level_stats *low_stats = &priv->low_stats;\r\nint max_count = 0;\r\nu32 mib_counter;\r\nu32 isr;\r\nunsigned long flags;\r\nMACvReadISR(priv->PortOffset, &isr);\r\nif (isr == 0)\r\nreturn;\r\nif (isr == 0xffffffff) {\r\npr_debug("isr = 0xffff\n");\r\nreturn;\r\n}\r\nMACvIntDisable(priv->PortOffset);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nMACvReadMIBCounter(priv->PortOffset, &mib_counter);\r\nlow_stats->dot11RTSSuccessCount += mib_counter & 0xff;\r\nlow_stats->dot11RTSFailureCount += (mib_counter >> 8) & 0xff;\r\nlow_stats->dot11ACKFailureCount += (mib_counter >> 16) & 0xff;\r\nlow_stats->dot11FCSErrorCount += (mib_counter >> 24) & 0xff;\r\nwhile (isr && priv->vif) {\r\nMACvWriteISR(priv->PortOffset, isr);\r\nif (isr & ISR_FETALERR) {\r\npr_debug(" ISR_FETALERR\n");\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_SOFTPWRCTL, 0);\r\nVNSvOutPortW(priv->PortOffset +\r\nMAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);\r\ndevice_error(priv, isr);\r\n}\r\nif (isr & ISR_TBTT) {\r\nif (priv->op_mode != NL80211_IFTYPE_ADHOC)\r\nvnt_check_bb_vga(priv);\r\npriv->bBeaconSent = false;\r\nif (priv->bEnablePSMode)\r\nPSbIsNextTBTTWakeUp((void *)priv);\r\nif ((priv->op_mode == NL80211_IFTYPE_AP ||\r\npriv->op_mode == NL80211_IFTYPE_ADHOC) &&\r\npriv->vif->bss_conf.enable_beacon) {\r\nMACvOneShotTimer1MicroSec(priv,\r\n(priv->vif->bss_conf.beacon_int - MAKE_BEACON_RESERVED) << 10);\r\n}\r\n}\r\nif (isr & ISR_BNTX) {\r\nif (priv->op_mode == NL80211_IFTYPE_ADHOC) {\r\npriv->bIsBeaconBufReadySet = false;\r\npriv->cbBeaconBufReadySetCnt = 0;\r\n}\r\npriv->bBeaconSent = true;\r\n}\r\nif (isr & ISR_RXDMA0)\r\nmax_count += device_rx_srv(priv, TYPE_RXDMA0);\r\nif (isr & ISR_RXDMA1)\r\nmax_count += device_rx_srv(priv, TYPE_RXDMA1);\r\nif (isr & ISR_TXDMA0)\r\nmax_count += device_tx_srv(priv, TYPE_TXDMA0);\r\nif (isr & ISR_AC0DMA)\r\nmax_count += device_tx_srv(priv, TYPE_AC0DMA);\r\nif (isr & ISR_SOFTTIMER1) {\r\nif (priv->vif->bss_conf.enable_beacon)\r\nvnt_beacon_make(priv, priv->vif);\r\n}\r\nif (AVAIL_TD(priv, TYPE_TXDMA0) &&\r\nAVAIL_TD(priv, TYPE_AC0DMA) &&\r\nieee80211_queue_stopped(priv->hw, 0))\r\nieee80211_wake_queues(priv->hw);\r\nMACvReadISR(priv->PortOffset, &isr);\r\nMACvReceive0(priv->PortOffset);\r\nMACvReceive1(priv->PortOffset);\r\nif (max_count > priv->opts.int_works)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nMACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);\r\n}\r\nstatic void vnt_interrupt_work(struct work_struct *work)\r\n{\r\nstruct vnt_private *priv =\r\ncontainer_of(work, struct vnt_private, interrupt_work);\r\nif (priv->vif)\r\nvnt_interrupt_process(priv);\r\n}\r\nstatic irqreturn_t vnt_interrupt(int irq, void *arg)\r\n{\r\nstruct vnt_private *priv = arg;\r\nif (priv->vif)\r\nschedule_work(&priv->interrupt_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct vnt_tx_desc *head_td;\r\nu32 dma_idx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (ieee80211_is_data(hdr->frame_control))\r\ndma_idx = TYPE_AC0DMA;\r\nelse\r\ndma_idx = TYPE_TXDMA0;\r\nif (AVAIL_TD(priv, dma_idx) < 1) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nieee80211_stop_queues(priv->hw);\r\nreturn -ENOMEM;\r\n}\r\nhead_td = priv->apCurrTD[dma_idx];\r\nhead_td->td1.tcr = 0;\r\nhead_td->td_info->skb = skb;\r\nif (dma_idx == TYPE_AC0DMA)\r\nhead_td->td_info->flags = TD_FLAGS_NETIF_SKB;\r\npriv->apCurrTD[dma_idx] = head_td->next;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nvnt_generate_fifo_header(priv, dma_idx, head_td, skb);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->bPWBitOn = false;\r\nhead_td->td1.tcr |= (TCR_STP | TCR_EDP | EDMSDU);\r\nhead_td->td1.req_count = cpu_to_le16(head_td->td_info->req_count);\r\nhead_td->buff_addr = cpu_to_le32(head_td->td_info->buf_dma);\r\nwmb();\r\nhead_td->td0.owner = OWNED_BY_NIC;\r\nwmb();\r\nif (head_td->td_info->flags & TD_FLAGS_NETIF_SKB)\r\nMACvTransmitAC0(priv->PortOffset);\r\nelse\r\nMACvTransmit0(priv->PortOffset);\r\npriv->iTDUsed[dma_idx]++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void vnt_tx_80211(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nif (vnt_tx_packet(priv, skb))\r\nieee80211_free_txskb(hw, skb);\r\n}\r\nstatic int vnt_start(struct ieee80211_hw *hw)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nint ret;\r\npriv->rx_buf_sz = PKT_BUF_SZ;\r\nif (!device_init_rings(priv))\r\nreturn -ENOMEM;\r\nret = request_irq(priv->pcid->irq, vnt_interrupt,\r\nIRQF_SHARED, "vt6655", priv);\r\nif (ret) {\r\ndev_dbg(&priv->pcid->dev, "failed to start irq\n");\r\nreturn ret;\r\n}\r\ndev_dbg(&priv->pcid->dev, "call device init rd0 ring\n");\r\ndevice_init_rd0_ring(priv);\r\ndevice_init_rd1_ring(priv);\r\ndevice_init_td0_ring(priv);\r\ndevice_init_td1_ring(priv);\r\ndevice_init_registers(priv);\r\ndev_dbg(&priv->pcid->dev, "call MACvIntEnable\n");\r\nMACvIntEnable(priv->PortOffset, IMR_MASK_VALUE);\r\nieee80211_wake_queues(hw);\r\nreturn 0;\r\n}\r\nstatic void vnt_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nieee80211_stop_queues(hw);\r\ncancel_work_sync(&priv->interrupt_work);\r\nMACbShutdown(priv);\r\nMACbSoftwareReset(priv);\r\nCARDbRadioPowerOff(priv);\r\ndevice_free_td0_ring(priv);\r\ndevice_free_td1_ring(priv);\r\ndevice_free_rd0_ring(priv);\r\ndevice_free_rd1_ring(priv);\r\ndevice_free_rings(priv);\r\nfree_irq(priv->pcid->irq, priv);\r\n}\r\nstatic int vnt_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\npriv->vif = vif;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_RCR, RCR_UNICAST);\r\nMACvRegBitsOn(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_ADHOC);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_RCR, RCR_UNICAST);\r\nMACvRegBitsOn(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_AP);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->op_mode = vif->type;\r\nreturn 0;\r\n}\r\nstatic void vnt_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);\r\nMACvRegBitsOff(priv->PortOffset,\r\nMAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_ADHOC);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_TCR, TCR_AUTOBCNTX);\r\nMACvRegBitsOff(priv->PortOffset,\r\nMAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_HOSTCR, HOSTCR_AP);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npriv->op_mode = NL80211_IFTYPE_UNSPECIFIED;\r\n}\r\nstatic int vnt_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nu8 bb_type;\r\nif (changed & IEEE80211_CONF_CHANGE_PS) {\r\nif (conf->flags & IEEE80211_CONF_PS)\r\nPSvEnablePowerSaving(priv, conf->listen_interval);\r\nelse\r\nPSvDisablePowerSaving(priv);\r\n}\r\nif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) ||\r\n(conf->flags & IEEE80211_CONF_OFFCHANNEL)) {\r\nset_channel(priv, conf->chandef.chan);\r\nif (conf->chandef.chan->band == NL80211_BAND_5GHZ)\r\nbb_type = BB_TYPE_11A;\r\nelse\r\nbb_type = BB_TYPE_11G;\r\nif (priv->byBBType != bb_type) {\r\npriv->byBBType = bb_type;\r\nCARDbSetPhyParameter(priv, priv->byBBType);\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\nif (priv->byBBType == BB_TYPE_11B)\r\npriv->wCurrentRate = RATE_1M;\r\nelse\r\npriv->wCurrentRate = RATE_54M;\r\nRFbSetPower(priv, priv->wCurrentRate,\r\nconf->chandef.chan->hw_value);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vnt_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, struct ieee80211_bss_conf *conf,\r\nu32 changed)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\npriv->current_aid = conf->aid;\r\nif (changed & BSS_CHANGED_BSSID && conf->bssid) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nMACvWriteBSSIDAddress(priv->PortOffset, (u8 *)conf->bssid);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\npriv->basic_rates = conf->basic_rates;\r\nCARDvUpdateBasicTopRate(priv);\r\ndev_dbg(&priv->pcid->dev,\r\n"basic rates %x\n", conf->basic_rates);\r\n}\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nif (conf->use_short_preamble) {\r\nMACvEnableBarkerPreambleMd(priv->PortOffset);\r\npriv->byPreambleType = true;\r\n} else {\r\nMACvDisableBarkerPreambleMd(priv->PortOffset);\r\npriv->byPreambleType = false;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_ERP_CTS_PROT) {\r\nif (conf->use_cts_prot)\r\nMACvEnableProtectMD(priv->PortOffset);\r\nelse\r\nMACvDisableProtectMD(priv->PortOffset);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nif (conf->use_short_slot)\r\npriv->bShortSlotTime = true;\r\nelse\r\npriv->bShortSlotTime = false;\r\nCARDbSetPhyParameter(priv, priv->byBBType);\r\nBBvSetVGAGainOffset(priv, priv->abyBBVGA[0]);\r\n}\r\nif (changed & BSS_CHANGED_TXPOWER)\r\nRFbSetPower(priv, priv->wCurrentRate,\r\nconf->chandef.chan->hw_value);\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\ndev_dbg(&priv->pcid->dev,\r\n"Beacon enable %d\n", conf->enable_beacon);\r\nif (conf->enable_beacon) {\r\nvnt_beacon_enable(priv, vif, conf);\r\nMACvRegBitsOn(priv->PortOffset, MAC_REG_TCR,\r\nTCR_AUTOBCNTX);\r\n} else {\r\nMACvRegBitsOff(priv->PortOffset, MAC_REG_TCR,\r\nTCR_AUTOBCNTX);\r\n}\r\n}\r\nif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INFO) &&\r\npriv->op_mode != NL80211_IFTYPE_AP) {\r\nif (conf->assoc && conf->beacon_rate) {\r\nCARDbUpdateTSF(priv, conf->beacon_rate->hw_value,\r\nconf->sync_tsf);\r\nCARDbSetBeaconPeriod(priv, conf->beacon_int);\r\nCARDvSetFirstNextTBTT(priv, conf->beacon_int);\r\n} else {\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL,\r\nTFTCTL_TSFCNTRST);\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL,\r\nTFTCTL_TSFCNTREN);\r\n}\r\n}\r\n}\r\nstatic u64 vnt_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nstruct netdev_hw_addr *ha;\r\nu64 mc_filter = 0;\r\nu32 bit_nr = 0;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter |= 1ULL << (bit_nr & 0x3f);\r\n}\r\npriv->mc_list_count = mc_list->count;\r\nreturn mc_filter;\r\n}\r\nstatic void vnt_configure(struct ieee80211_hw *hw,\r\nunsigned int changed_flags, unsigned int *total_flags, u64 multicast)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nu8 rx_mode = 0;\r\n*total_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC;\r\nVNSvInPortB(priv->PortOffset + MAC_REG_RCR, &rx_mode);\r\ndev_dbg(&priv->pcid->dev, "rx mode in = %x\n", rx_mode);\r\nif (changed_flags & FIF_ALLMULTI) {\r\nif (*total_flags & FIF_ALLMULTI) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->mc_list_count > 2) {\r\nMACvSelectPage1(priv->PortOffset);\r\nVNSvOutPortD(priv->PortOffset +\r\nMAC_REG_MAR0, 0xffffffff);\r\nVNSvOutPortD(priv->PortOffset +\r\nMAC_REG_MAR0 + 4, 0xffffffff);\r\nMACvSelectPage0(priv->PortOffset);\r\n} else {\r\nMACvSelectPage1(priv->PortOffset);\r\nVNSvOutPortD(priv->PortOffset +\r\nMAC_REG_MAR0, (u32)multicast);\r\nVNSvOutPortD(priv->PortOffset +\r\nMAC_REG_MAR0 + 4,\r\n(u32)(multicast >> 32));\r\nMACvSelectPage0(priv->PortOffset);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nrx_mode |= RCR_MULTICAST | RCR_BROADCAST;\r\n} else {\r\nrx_mode &= ~(RCR_MULTICAST | RCR_BROADCAST);\r\n}\r\n}\r\nif (changed_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC)) {\r\nrx_mode |= RCR_MULTICAST | RCR_BROADCAST;\r\nif (*total_flags & (FIF_OTHER_BSS | FIF_BCN_PRBRESP_PROMISC))\r\nrx_mode &= ~RCR_BSSID;\r\nelse\r\nrx_mode |= RCR_BSSID;\r\n}\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_RCR, rx_mode);\r\ndev_dbg(&priv->pcid->dev, "rx mode out= %x\n", rx_mode);\r\n}\r\nstatic int vnt_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nif (vnt_set_keys(hw, sta, vif, key))\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ncase DISABLE_KEY:\r\nif (test_bit(key->hw_key_idx, &priv->key_entry_inuse))\r\nclear_bit(key->hw_key_idx, &priv->key_entry_inuse);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vnt_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nmemcpy(stats, &priv->low_stats, sizeof(*stats));\r\nreturn 0;\r\n}\r\nstatic u64 vnt_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nu64 tsf;\r\nCARDbGetCurrentTSF(priv, &tsf);\r\nreturn tsf;\r\n}\r\nstatic void vnt_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu64 tsf)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nCARDvUpdateNextTBTT(priv, tsf, vif->bss_conf.beacon_int);\r\n}\r\nstatic void vnt_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct vnt_private *priv = hw->priv;\r\nVNSvOutPortB(priv->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);\r\n}\r\nstatic int vnt_init(struct vnt_private *priv)\r\n{\r\nSET_IEEE80211_PERM_ADDR(priv->hw, priv->abyCurrentNetAddr);\r\nvnt_init_bands(priv);\r\nif (ieee80211_register_hw(priv->hw))\r\nreturn -ENODEV;\r\npriv->mac_hw = true;\r\nCARDbRadioPowerOff(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\nvt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)\r\n{\r\nstruct vnt_private *priv;\r\nstruct ieee80211_hw *hw;\r\nstruct wiphy *wiphy;\r\nint rc;\r\ndev_notice(&pcid->dev,\r\n"%s Ver. %s\n", DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\r\ndev_notice(&pcid->dev,\r\n"Copyright (c) 2003 VIA Networking Technologies, Inc.\n");\r\nhw = ieee80211_alloc_hw(sizeof(*priv), &vnt_mac_ops);\r\nif (!hw) {\r\ndev_err(&pcid->dev, "could not register ieee80211_hw\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = hw->priv;\r\npriv->pcid = pcid;\r\nspin_lock_init(&priv->lock);\r\npriv->hw = hw;\r\nSET_IEEE80211_DEV(priv->hw, &pcid->dev);\r\nif (pci_enable_device(pcid)) {\r\ndevice_free_info(priv);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&pcid->dev,\r\n"Before get pci_info memaddr is %x\n", priv->memaddr);\r\npci_set_master(pcid);\r\npriv->memaddr = pci_resource_start(pcid, 0);\r\npriv->ioaddr = pci_resource_start(pcid, 1);\r\npriv->PortOffset = ioremap(priv->memaddr & PCI_BASE_ADDRESS_MEM_MASK,\r\n256);\r\nif (!priv->PortOffset) {\r\ndev_err(&pcid->dev, ": Failed to IO remapping ..\n");\r\ndevice_free_info(priv);\r\nreturn -ENODEV;\r\n}\r\nrc = pci_request_regions(pcid, DEVICE_NAME);\r\nif (rc) {\r\ndev_err(&pcid->dev, ": Failed to find PCI device\n");\r\ndevice_free_info(priv);\r\nreturn -ENODEV;\r\n}\r\nif (dma_set_mask(&pcid->dev, DMA_BIT_MASK(32))) {\r\ndev_err(&pcid->dev, ": Failed to set dma 32 bit mask\n");\r\ndevice_free_info(priv);\r\nreturn -ENODEV;\r\n}\r\nINIT_WORK(&priv->interrupt_work, vnt_interrupt_work);\r\nif (!MACbSoftwareReset(priv)) {\r\ndev_err(&pcid->dev, ": Failed to access MAC hardware..\n");\r\ndevice_free_info(priv);\r\nreturn -ENODEV;\r\n}\r\nMACvInitialize(priv);\r\nMACvReadEtherAddress(priv->PortOffset, priv->abyCurrentNetAddr);\r\npriv->byRFType = SROMbyReadEmbedded(priv->PortOffset, EEP_OFS_RFTYPE);\r\npriv->byRFType &= RF_MASK;\r\ndev_dbg(&pcid->dev, "RF Type = %x\n", priv->byRFType);\r\ndevice_get_options(priv);\r\ndevice_set_options(priv);\r\nwiphy = priv->hw->wiphy;\r\nwiphy->frag_threshold = FRAG_THRESH_DEF;\r\nwiphy->rts_threshold = RTS_THRESH_DEF;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) | BIT(NL80211_IFTYPE_AP);\r\nieee80211_hw_set(priv->hw, TIMING_BEACON_ONLY);\r\nieee80211_hw_set(priv->hw, SIGNAL_DBM);\r\nieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\r\nieee80211_hw_set(priv->hw, REPORTS_TX_ACK_STATUS);\r\nieee80211_hw_set(priv->hw, SUPPORTS_PS);\r\npriv->hw->max_signal = 100;\r\nif (vnt_init(priv))\r\nreturn -ENODEV;\r\ndevice_print_info(priv);\r\npci_set_drvdata(pcid, priv);\r\nreturn 0;\r\n}\r\nstatic int vt6655_suspend(struct pci_dev *pcid, pm_message_t state)\r\n{\r\nstruct vnt_private *priv = pci_get_drvdata(pcid);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npci_save_state(pcid);\r\nMACbShutdown(priv);\r\npci_disable_device(pcid);\r\npci_set_power_state(pcid, pci_choose_state(pcid, state));\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vt6655_resume(struct pci_dev *pcid)\r\n{\r\npci_set_power_state(pcid, PCI_D0);\r\npci_enable_wake(pcid, PCI_D0, 0);\r\npci_restore_state(pcid);\r\nreturn 0;\r\n}
