static void cxd2841er_i2c_debug(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 write,\r\nconst u8 *data, u32 len)\r\n{\r\ndev_dbg(&priv->i2c->dev,\r\n"cxd2841er: I2C %s addr %02x reg 0x%02x size %d\n",\r\n(write == 0 ? "read" : "write"), addr, reg, len);\r\nprint_hex_dump_bytes("cxd2841er: I2C data: ",\r\nDUMP_PREFIX_OFFSET, data, len);\r\n}\r\nstatic int cxd2841er_write_regs(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, const u8 *data, u32 len)\r\n{\r\nint ret;\r\nu8 buf[MAX_WRITE_REGSIZE + 1];\r\nu8 i2c_addr = (addr == I2C_SLVX ?\r\npriv->i2c_addr_slvx : priv->i2c_addr_slvt);\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = i2c_addr,\r\n.flags = 0,\r\n.len = len + 1,\r\n.buf = buf,\r\n}\r\n};\r\nif (len + 1 >= sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev, "wr reg=%04x: len=%d is too big!\n",\r\nreg, len + 1);\r\nreturn -E2BIG;\r\n}\r\ncxd2841er_i2c_debug(priv, i2c_addr, reg, 1, data, len);\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], data, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d addr=%02x reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg, len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_write_reg(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 val)\r\n{\r\nreturn cxd2841er_write_regs(priv, addr, reg, &val, 1);\r\n}\r\nstatic int cxd2841er_read_regs(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 *val, u32 len)\r\n{\r\nint ret;\r\nu8 i2c_addr = (addr == I2C_SLVX ?\r\npriv->i2c_addr_slvx : priv->i2c_addr_slvt);\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = val,\r\n}\r\n};\r\nret = i2c_transfer(priv->i2c, &msg[0], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rw failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg);\r\nreturn ret;\r\n}\r\nret = i2c_transfer(priv->i2c, &msg[1], 1);\r\nif (ret >= 0 && ret != 1)\r\nret = -EIO;\r\nif (ret < 0) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d addr=%02x reg=%02x\n",\r\nKBUILD_MODNAME, ret, i2c_addr, reg);\r\nreturn ret;\r\n}\r\ncxd2841er_i2c_debug(priv, i2c_addr, reg, 0, val, len);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_reg(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 *val)\r\n{\r\nreturn cxd2841er_read_regs(priv, addr, reg, val, 1);\r\n}\r\nstatic int cxd2841er_set_reg_bits(struct cxd2841er_priv *priv,\r\nu8 addr, u8 reg, u8 data, u8 mask)\r\n{\r\nint res;\r\nu8 rdata;\r\nif (mask != 0xff) {\r\nres = cxd2841er_read_reg(priv, addr, reg, &rdata);\r\nif (res)\r\nreturn res;\r\ndata = ((data & mask) | (rdata & (mask ^ 0xFF)));\r\n}\r\nreturn cxd2841er_write_reg(priv, addr, reg, data);\r\n}\r\nstatic int cxd2841er_dvbs2_set_symbol_rate(struct cxd2841er_priv *priv,\r\nu32 symbol_rate)\r\n{\r\nu32 reg_value = 0;\r\nu8 data[3] = {0, 0, 0};\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreg_value = DIV_ROUND_CLOSEST(symbol_rate * 16384, 1000);\r\nif ((reg_value == 0) || (reg_value > 0xFFFFF)) {\r\ndev_err(&priv->i2c->dev,\r\n"%s(): reg_value is out of range\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndata[0] = (u8)((reg_value >> 16) & 0x0F);\r\ndata[1] = (u8)((reg_value >> 8) & 0xFF);\r\ndata[2] = (u8)(reg_value & 0xFF);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x20, data, 3);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_s_to_active_s(struct cxd2841er_priv *priv,\r\nu8 system, u32 symbol_rate)\r\n{\r\nint ret;\r\nu8 data[4] = { 0, 0, 0, 0 };\r\nif (priv->state != STATE_SLEEP_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, (int)priv->state);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBS);\r\nif (system == SYS_DVBS) {\r\ndata[0] = 0x0A;\r\n} else if (system == SYS_DVBS2) {\r\ndata[0] = 0x0B;\r\n} else {\r\ndev_err(&priv->i2c->dev, "%s(): invalid delsys %d\n",\r\n__func__, system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, data[0]);\r\ndata[0] = 0x00;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2d, data[0]);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, data[0]);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa3);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xac, 0x00);\r\ndata[0] = 0x07;\r\ndata[1] = 0x3B;\r\ndata[2] = 0x08;\r\ndata[3] = 0xC5;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xab);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x98, data, 4);\r\ndata[0] = 0x05;\r\ndata[1] = 0x80;\r\ndata[2] = 0x0A;\r\ndata[3] = 0x80;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xa8, data, 4);\r\ndata[0] = 0x0C;\r\ndata[1] = 0xCC;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xc3, data, 2);\r\nret = cxd2841er_dvbs2_set_symbol_rate(priv, symbol_rate);\r\nif (ret != 0)\r\nreturn ret;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x10);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_retune_active(struct cxd2841er_priv *priv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_S &&\r\npriv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\nif (priv->state == STATE_ACTIVE_S)\r\nreturn cxd2841er_dvbs2_set_symbol_rate(\r\npriv, p->symbol_rate / 1000);\r\nelse if (priv->state == STATE_ACTIVE_TC) {\r\nswitch (priv->system) {\r\ncase SYS_DVBT:\r\nreturn cxd2841er_sleep_tc_to_active_t_band(\r\npriv, p->bandwidth_hz);\r\ncase SYS_DVBT2:\r\nreturn cxd2841er_sleep_tc_to_active_t2_band(\r\npriv, p->bandwidth_hz);\r\ncase SYS_DVBC_ANNEX_A:\r\nreturn cxd2841er_sleep_tc_to_active_c_band(\r\npriv, p->bandwidth_hz);\r\ncase SYS_ISDBT:\r\ncxd2841er_active_i_to_sleep_tc(priv);\r\ncxd2841er_sleep_tc_to_shutdown(priv);\r\ncxd2841er_shutdown_to_sleep_tc(priv);\r\nreturn cxd2841er_sleep_tc_to_active_i(\r\npriv, p->bandwidth_hz);\r\n}\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\nstatic int cxd2841er_active_s_to_sleep_s(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x31, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xae);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2d, 0x00);\r\npriv->state = STATE_SLEEP_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_s_to_shutdown(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SLEEP_S) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9c, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\npriv->state = STATE_SHUTDOWN;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_shutdown(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SLEEP_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x15, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\npriv->state = STATE_SHUTDOWN;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_t_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_t2_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x21);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xfb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x00, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_c_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa3, 0x00, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_active_i_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x3f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0xff);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x00);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_shutdown_to_sleep_s(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SHUTDOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\r\nusleep_range(3000, 5000);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\r\nswitch (priv->xtal) {\r\ncase SONY_XTAL_20500:\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x00);\r\nbreak;\r\ncase SONY_XTAL_24000:\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x03);\r\nbreak;\r\ncase SONY_XTAL_41000:\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, 0x01);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod xtal %d\n",\r\n__func__, priv->xtal);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\r\nusleep_range(1000, 2000);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x1F);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9C, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\npriv->state = STATE_SLEEP_S;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_shutdown_to_sleep_tc(struct cxd2841er_priv *priv)\r\n{\r\nu8 data = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_SHUTDOWN) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x02, 0x00);\r\nusleep_range(3000, 5000);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x13, 0x00);\r\nswitch (priv->xtal) {\r\ncase SONY_XTAL_20500:\r\ndata = 0x0;\r\nbreak;\r\ncase SONY_XTAL_24000:\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\r\ndata = 0x3;\r\nbreak;\r\ncase SONY_XTAL_41000:\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x12, 0x00);\r\ndata = 0x1;\r\nbreak;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x14, data);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x10, 0x00);\r\nusleep_range(1000, 2000);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x43, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x0a);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x63, 0x16);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x65, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x69, 0x06);\r\npriv->state = STATE_SLEEP_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_tune_done(struct cxd2841er_priv *priv)\r\n{\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0, 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xfe, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xc3, 0x00);\r\nreturn 0;\r\n}\r\nstatic void cxd2841er_set_ts_clock_mode(struct cxd2841er_priv *priv,\r\nu8 system)\r\n{\r\nu8 serial_ts, ts_rate_ctrl_off, ts_in_off;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xc4, &serial_ts);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xd3, &ts_rate_ctrl_off);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xde, &ts_in_off);\r\ndev_dbg(&priv->i2c->dev, "%s(): ser_ts=0x%02x rate_ctrl_off=0x%02x in_off=0x%02x\n",\r\n__func__, serial_ts, ts_rate_ctrl_off, ts_in_off);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xd9, 0x08);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x00, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x33, 0x00, 0x03);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x32, 0x01, 0x01);\r\nif (system == SYS_DVBT) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\r\n} else if (system == SYS_DVBC_ANNEX_A) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x66, 0x01, 0x01);\r\n}\r\n}\r\nstatic u8 cxd2841er_chip_id(struct cxd2841er_priv *priv)\r\n{\r\nu8 chip_id = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (cxd2841er_write_reg(priv, I2C_SLVT, 0, 0) == 0)\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0xfd, &chip_id);\r\nelse if (cxd2841er_write_reg(priv, I2C_SLVX, 0, 0) == 0)\r\ncxd2841er_read_reg(priv, I2C_SLVX, 0xfd, &chip_id);\r\nreturn chip_id;\r\n}\r\nstatic int cxd2841er_read_status_s(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nu8 reg = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\n*status = 0;\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x11, &reg);\r\nif (reg & 0x04) {\r\n*status = FE_HAS_SIGNAL\r\n| FE_HAS_CARRIER\r\n| FE_HAS_VITERBI\r\n| FE_HAS_SYNC\r\n| FE_HAS_LOCK;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): result 0x%x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_t_t2(struct cxd2841er_priv *priv,\r\nu8 *sync, u8 *tslock, u8 *unlock)\r\n{\r\nu8 data = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC)\r\nreturn -EINVAL;\r\nif (priv->system == SYS_DVBT) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\n} else {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\n}\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\r\nif ((data & 0x07) == 0x07) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid hardware state detected\n", __func__);\r\n*sync = 0;\r\n*tslock = 0;\r\n*unlock = 0;\r\n} else {\r\n*sync = ((data & 0x07) == 0x6 ? 1 : 0);\r\n*tslock = ((data & 0x20) ? 1 : 0);\r\n*unlock = ((data & 0x10) ? 1 : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_c(struct cxd2841er_priv *priv, u8 *tslock)\r\n{\r\nu8 data;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC)\r\nreturn -EINVAL;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x88, &data);\r\nif ((data & 0x01) == 0) {\r\n*tslock = 0;\r\n} else {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\r\n*tslock = ((data & 0x20) ? 1 : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_i(struct cxd2841er_priv *priv,\r\nu8 *sync, u8 *tslock, u8 *unlock)\r\n{\r\nu8 data = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC)\r\nreturn -EINVAL;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data);\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): lock=0x%x\n", __func__, data);\r\n*sync = ((data & 0x02) ? 1 : 0);\r\n*tslock = ((data & 0x01) ? 1 : 0);\r\n*unlock = ((data & 0x10) ? 1 : 0);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_status_tc(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nint ret = 0;\r\nu8 sync = 0;\r\nu8 tslock = 0;\r\nu8 unlock = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\n*status = 0;\r\nif (priv->state == STATE_ACTIVE_TC) {\r\nif (priv->system == SYS_DVBT || priv->system == SYS_DVBT2) {\r\nret = cxd2841er_read_status_t_t2(\r\npriv, &sync, &tslock, &unlock);\r\nif (ret)\r\ngoto done;\r\nif (unlock)\r\ngoto done;\r\nif (sync)\r\n*status = FE_HAS_SIGNAL |\r\nFE_HAS_CARRIER |\r\nFE_HAS_VITERBI |\r\nFE_HAS_SYNC;\r\nif (tslock)\r\n*status |= FE_HAS_LOCK;\r\n} else if (priv->system == SYS_ISDBT) {\r\nret = cxd2841er_read_status_i(\r\npriv, &sync, &tslock, &unlock);\r\nif (ret)\r\ngoto done;\r\nif (unlock)\r\ngoto done;\r\nif (sync)\r\n*status = FE_HAS_SIGNAL |\r\nFE_HAS_CARRIER |\r\nFE_HAS_VITERBI |\r\nFE_HAS_SYNC;\r\nif (tslock)\r\n*status |= FE_HAS_LOCK;\r\n} else if (priv->system == SYS_DVBC_ANNEX_A) {\r\nret = cxd2841er_read_status_c(priv, &tslock);\r\nif (ret)\r\ngoto done;\r\nif (tslock)\r\n*status = FE_HAS_SIGNAL |\r\nFE_HAS_CARRIER |\r\nFE_HAS_VITERBI |\r\nFE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n}\r\n}\r\ndone:\r\ndev_dbg(&priv->i2c->dev, "%s(): status 0x%x\n", __func__, *status);\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_s_s2(struct cxd2841er_priv *priv,\r\nint *offset)\r\n{\r\nu8 data[3];\r\nu8 is_hs_mode;\r\ns32 cfrl_ctrlval;\r\ns32 temp_div, temp_q, temp_r;\r\nif (priv->state != STATE_ACTIVE_S) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, &data[0]);\r\nif (data[0] & 0x01) {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x50, &data[0]);\r\nis_hs_mode = (data[0] & 0x10 ? 1 : 0);\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): unable to detect sampling rate mode\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x45, data, 3);\r\ncfrl_ctrlval = sign_extend32((((u32)data[0] & 0x1F) << 16) |\r\n(((u32)data[1] & 0xFF) << 8) |\r\n((u32)data[2] & 0xFF), 20);\r\ntemp_div = (is_hs_mode ? 1048576 : 1572864);\r\nif (cfrl_ctrlval > 0) {\r\ntemp_q = div_s64_rem(97375LL * cfrl_ctrlval,\r\ntemp_div, &temp_r);\r\n} else {\r\ntemp_q = div_s64_rem(-97375LL * cfrl_ctrlval,\r\ntemp_div, &temp_r);\r\n}\r\nif (temp_r >= temp_div / 2)\r\ntemp_q++;\r\nif (cfrl_ctrlval > 0)\r\ntemp_q *= -1;\r\n*offset = temp_q;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_i(struct cxd2841er_priv *priv,\r\nu32 bandwidth, int *offset)\r\n{\r\nu8 data[4];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_ISDBT) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\r\n*offset = -1 * sign_extend32(\r\n((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |\r\n((u32)data[2] << 8) | (u32)data[3], 29);\r\nswitch (bandwidth) {\r\ncase 6000000:\r\n*offset = -1 * ((*offset) * 8/264);\r\nbreak;\r\ncase 7000000:\r\n*offset = -1 * ((*offset) * 8/231);\r\nbreak;\r\ncase 8000000:\r\n*offset = -1 * ((*offset) * 8/198);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): bandwidth %d offset %d\n",\r\n__func__, bandwidth, *offset);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_t(struct cxd2841er_priv *priv,\r\nu32 bandwidth, int *offset)\r\n{\r\nu8 data[4];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_DVBT) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\r\n*offset = -1 * sign_extend32(\r\n((u32)(data[0] & 0x1F) << 24) | ((u32)data[1] << 16) |\r\n((u32)data[2] << 8) | (u32)data[3], 29);\r\n*offset *= (bandwidth / 1000000);\r\n*offset /= 235;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_t2(struct cxd2841er_priv *priv,\r\nu32 bandwidth, int *offset)\r\n{\r\nu8 data[4];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_DVBT2) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x4c, data, sizeof(data));\r\n*offset = -1 * sign_extend32(\r\n((u32)(data[0] & 0x0F) << 24) | ((u32)data[1] << 16) |\r\n((u32)data[2] << 8) | (u32)data[3], 27);\r\nswitch (bandwidth) {\r\ncase 1712000:\r\n*offset /= 582;\r\nbreak;\r\ncase 5000000:\r\ncase 6000000:\r\ncase 7000000:\r\ncase 8000000:\r\n*offset *= (bandwidth / 1000000);\r\n*offset /= 940;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_carrier_offset_c(struct cxd2841er_priv *priv,\r\nint *offset)\r\n{\r\nu8 data[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\nif (priv->system != SYS_DVBC_ANNEX_A) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x15, data, sizeof(data));\r\n*offset = div_s64(41000LL * sign_extend32((((u32)data[0] & 0x3f) << 8)\r\n| (u32)data[1], 13), 16384);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_c(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[3];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));\r\nif (data[2] & 0x01)\r\n*penum = ((u32)data[0] << 8) | (u32)data[1];\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_t(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[3];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xea, data, sizeof(data));\r\nif (data[2] & 0x01)\r\n*penum = ((u32)data[0] << 8) | (u32)data[1];\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_t2(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[3];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xfd, data, sizeof(data));\r\nif (data[0] & 0x01)\r\n*penum = ((u32)data[1] << 8) | (u32)data[2];\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_packet_errors_i(\r\nstruct cxd2841er_priv *priv, u32 *penum)\r\n{\r\nu8 data[2];\r\n*penum = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xA1, data, 1);\r\nif (!(data[0] & 0x01))\r\nreturn 0;\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xA2, data, sizeof(data));\r\n*penum = ((u32)data[0] << 8) | (u32)data[1];\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xA4, data, sizeof(data));\r\n*penum += ((u32)data[0] << 8) | (u32)data[1];\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0xA6, data, sizeof(data));\r\n*penum += ((u32)data[0] << 8) | (u32)data[1];\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_ber_c(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[3];\r\nu32 bit_err, period_exp;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x62, data, sizeof(data));\r\nif (!(data[0] & 0x80)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nbit_err = ((u32)(data[0] & 0x3f) << 16) |\r\n((u32)data[1] << 8) |\r\n(u32)data[2];\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x60, data);\r\nperiod_exp = data[0] & 0x1f;\r\nif ((period_exp <= 11) && (bit_err > (1 << period_exp) * 204 * 8)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): period_exp(%u) or bit_err(%u) not in range. no valid BER data\n",\r\n__func__, period_exp, bit_err);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): period_exp(%u) or bit_err(%u) count=%d\n",\r\n__func__, period_exp, bit_err,\r\n((1 << period_exp) * 204 * 8));\r\n*bit_error = bit_err;\r\n*bit_count = ((1 << period_exp) * 204 * 8);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_ber_i(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[3];\r\nu8 pktnum[2];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x5B, pktnum, sizeof(pktnum));\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x16, data, sizeof(data));\r\nif (!pktnum[0] && !pktnum[1]) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn -EINVAL;\r\n}\r\n*bit_error = ((u32)(data[0] & 0x7F) << 16) |\r\n((u32)data[1] << 8) | data[2];\r\n*bit_count = ((((u32)pktnum[0] << 8) | pktnum[1]) * 204 * 8);\r\ndev_dbg(&priv->i2c->dev, "%s(): bit_error=%u bit_count=%u\n",\r\n__func__, *bit_error, *bit_count);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_mon_read_ber_s(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[11];\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x35, data, 11);\r\nif (data[0] & 0x01) {\r\n*bit_error = ((u32)(data[1] & 0x3F) << 16) |\r\n((u32)(data[2] & 0xFF) << 8) |\r\n(u32)(data[3] & 0xFF);\r\n*bit_count = ((u32)(data[8] & 0x3F) << 16) |\r\n((u32)(data[9] & 0xFF) << 8) |\r\n(u32)(data[10] & 0xFF);\r\nif ((*bit_count == 0) || (*bit_error > *bit_count)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid bit_error %d, bit_count %d\n",\r\n__func__, *bit_error, *bit_count);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): no data available\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic int cxd2841er_mon_read_ber_s2(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[5];\r\nu32 period;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xb2);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x30, data, 5);\r\nif (data[0] & 0x01) {\r\n*bit_error = ((u32)(data[1] & 0x0F) << 24) |\r\n((u32)(data[2] & 0xFF) << 16) |\r\n((u32)(data[3] & 0xFF) << 8) |\r\n(u32)(data[4] & 0xFF);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x7a, data);\r\nperiod = (u32)(1 << (data[0] & 0x0F));\r\nif (period == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): period is 0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (*bit_error > (period * 64800)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid bit_err 0x%x period 0x%x\n",\r\n__func__, *bit_error, period);\r\nreturn -EINVAL;\r\n}\r\n*bit_count = period * 64800;\r\nreturn 0;\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no data available\n", __func__);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cxd2841er_read_ber_t2(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[4];\r\nu32 period_exp, n_ldpc;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x39, data, sizeof(data));\r\nif (!(data[0] & 0x10)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n*bit_error = ((u32)(data[0] & 0x0f) << 24) |\r\n((u32)data[1] << 16) |\r\n((u32)data[2] << 8) |\r\n(u32)data[3];\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\r\nperiod_exp = data[0] & 0x0f;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x22);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x5e, data);\r\nn_ldpc = ((data[0] & 0x03) == 0 ? 16200 : 64800);\r\nif (*bit_error > ((1U << period_exp) * n_ldpc)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid BER value\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (period_exp >= 4) {\r\n*bit_count = (1U << (period_exp - 4)) * (n_ldpc / 200);\r\n*bit_error *= 3125ULL;\r\n} else {\r\n*bit_count = (1U << period_exp) * (n_ldpc / 200);\r\n*bit_error *= 50000ULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_ber_t(struct cxd2841er_priv *priv,\r\nu32 *bit_error, u32 *bit_count)\r\n{\r\nu8 data[2];\r\nu32 period;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x39, data);\r\nif (!(data[0] & 0x01)) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no valid BER data\n", __func__);\r\nreturn 0;\r\n}\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x22, data, sizeof(data));\r\n*bit_error = ((u32)data[0] << 8) | (u32)data[1];\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x6f, data);\r\nperiod = ((data[0] & 0x07) == 0) ? 256 : (4096 << (data[0] & 0x07));\r\n*bit_count = period / 128;\r\n*bit_error *= 78125ULL;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_freeze_regs(struct cxd2841er_priv *priv)\r\n{\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x01);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_unfreeze_regs(struct cxd2841er_priv *priv)\r\n{\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x01, 0x00);\r\nreturn 0;\r\n}\r\nstatic u32 cxd2841er_dvbs_read_snr(struct cxd2841er_priv *priv,\r\nu8 delsys, u32 *snr)\r\n{\r\nu8 data[3];\r\nu32 res = 0, value;\r\nint min_index, max_index, index;\r\nstatic const struct cxd2841er_cnr_data *cn_data;\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa1);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x10, data, 3);\r\nif (data[0] & 0x01) {\r\nvalue = ((u32)(data[1] & 0x1F) << 8) | (u32)(data[2] & 0xFF);\r\nmin_index = 0;\r\nif (delsys == SYS_DVBS) {\r\ncn_data = s_cn_data;\r\nmax_index = sizeof(s_cn_data) /\r\nsizeof(s_cn_data[0]) - 1;\r\n} else {\r\ncn_data = s2_cn_data;\r\nmax_index = sizeof(s2_cn_data) /\r\nsizeof(s2_cn_data[0]) - 1;\r\n}\r\nif (value >= cn_data[min_index].value) {\r\nres = cn_data[min_index].cnr_x1000;\r\ngoto done;\r\n}\r\nif (value <= cn_data[max_index].value) {\r\nres = cn_data[max_index].cnr_x1000;\r\ngoto done;\r\n}\r\nwhile ((max_index - min_index) > 1) {\r\nindex = (max_index + min_index) / 2;\r\nif (value == cn_data[index].value) {\r\nres = cn_data[index].cnr_x1000;\r\ngoto done;\r\n} else if (value > cn_data[index].value)\r\nmax_index = index;\r\nelse\r\nmin_index = index;\r\nif ((max_index - min_index) <= 1) {\r\nif (value == cn_data[max_index].value) {\r\nres = cn_data[max_index].cnr_x1000;\r\ngoto done;\r\n} else {\r\nres = cn_data[min_index].cnr_x1000;\r\ngoto done;\r\n}\r\n}\r\n}\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): no data available\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn -EINVAL;\r\n}\r\ndone:\r\ncxd2841er_unfreeze_regs(priv);\r\n*snr = res;\r\nreturn 0;\r\n}\r\nstatic uint32_t sony_log(uint32_t x)\r\n{\r\nreturn (((10000>>8)*(intlog2(x)>>16) + LOG2_E_100X/2)/LOG2_E_100X);\r\n}\r\nstatic int cxd2841er_read_snr_c(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\nenum sony_dvbc_constellation_t qam = SONY_DVBC_CONSTELLATION_16QAM;\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x19, data, 1);\r\nqam = (enum sony_dvbc_constellation_t) (data[0] & 0x07);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x4C, data, 2);\r\nreg = ((u32)(data[0]&0x1f) << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nswitch (qam) {\r\ncase SONY_DVBC_CONSTELLATION_16QAM:\r\ncase SONY_DVBC_CONSTELLATION_64QAM:\r\ncase SONY_DVBC_CONSTELLATION_256QAM:\r\nif (reg < 126)\r\nreg = 126;\r\n*snr = -95 * (int32_t)sony_log(reg) + 95941;\r\nbreak;\r\ncase SONY_DVBC_CONSTELLATION_32QAM:\r\ncase SONY_DVBC_CONSTELLATION_128QAM:\r\nif (reg < 69)\r\nreg = 69;\r\n*snr = -88 * (int32_t)sony_log(reg) + 86999;\r\nbreak;\r\ndefault:\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_snr_t(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\r\nreg = ((u32)data[0] << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nif (reg > 4996)\r\nreg = 4996;\r\n*snr = 10000 * ((intlog10(reg) - intlog10(5350 - reg)) >> 24) + 28500;\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_snr_t2(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\r\nreg = ((u32)data[0] << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nif (reg > 10876)\r\nreg = 10876;\r\n*snr = 10000 * ((intlog10(reg) -\r\nintlog10(12600 - reg)) >> 24) + 32000;\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_read_snr_i(struct cxd2841er_priv *priv, u32 *snr)\r\n{\r\nu32 reg;\r\nu8 data[2];\r\n*snr = 0;\r\nif (priv->state != STATE_ACTIVE_TC) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid state %d\n", __func__,\r\npriv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_freeze_regs(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x28, data, sizeof(data));\r\nreg = ((u32)data[0] << 8) | (u32)data[1];\r\nif (reg == 0) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): reg value out of range\n", __func__);\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\n*snr = 10000 * (intlog10(reg) >> 24) - 9031;\r\ncxd2841er_unfreeze_regs(priv);\r\nreturn 0;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_c(struct cxd2841er_priv *priv,\r\nu8 delsys)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(\r\npriv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x49, data, 2);\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): AGC value=%u\n",\r\n__func__, (((u16)data[0] & 0x0F) << 8) |\r\n(u16)(data[1] & 0xFF));\r\nreturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_t_t2(struct cxd2841er_priv *priv,\r\nu8 delsys)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(\r\npriv, I2C_SLVT, 0x00, (delsys == SYS_DVBT ? 0x10 : 0x20));\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): AGC value=%u\n",\r\n__func__, (((u16)data[0] & 0x0F) << 8) |\r\n(u16)(data[1] & 0xFF));\r\nreturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_i(struct cxd2841er_priv *priv,\r\nu8 delsys)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(\r\npriv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x26, data, 2);\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): AGC value=%u\n",\r\n__func__, (((u16)data[0] & 0x0F) << 8) |\r\n(u16)(data[1] & 0xFF));\r\nreturn ((((u16)data[0] & 0x0F) << 8) | (u16)(data[1] & 0xFF)) << 4;\r\n}\r\nstatic u16 cxd2841er_read_agc_gain_s(struct cxd2841er_priv *priv)\r\n{\r\nu8 data[2];\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_read_regs(priv, I2C_SLVT, 0x1f, data, 2);\r\nreturn ((((u16)data[0] & 0x1F) << 8) | (u16)(data[1] & 0xFF)) << 3;\r\n}\r\nstatic void cxd2841er_read_ber(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nu32 ret, bit_error = 0, bit_count = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_B:\r\ncase SYS_DVBC_ANNEX_C:\r\nret = cxd2841er_read_ber_c(priv, &bit_error, &bit_count);\r\nbreak;\r\ncase SYS_ISDBT:\r\nret = cxd2841er_read_ber_i(priv, &bit_error, &bit_count);\r\nbreak;\r\ncase SYS_DVBS:\r\nret = cxd2841er_mon_read_ber_s(priv, &bit_error, &bit_count);\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = cxd2841er_mon_read_ber_s2(priv, &bit_error, &bit_count);\r\nbreak;\r\ncase SYS_DVBT:\r\nret = cxd2841er_read_ber_t(priv, &bit_error, &bit_count);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2841er_read_ber_t2(priv, &bit_error, &bit_count);\r\nbreak;\r\ndefault:\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\nif (!ret) {\r\np->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\np->post_bit_error.stat[0].uvalue += bit_error;\r\np->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\np->post_bit_count.stat[0].uvalue += bit_count;\r\n} else {\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n}\r\nstatic void cxd2841er_read_signal_strength(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ns32 strength;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nstrength = cxd2841er_read_agc_gain_t_t2(priv,\r\np->delivery_system);\r\np->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\np->strength.stat[0].uvalue = strength * 366 / 100 - 89520;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_B:\r\ncase SYS_DVBC_ANNEX_C:\r\nstrength = cxd2841er_read_agc_gain_c(priv,\r\np->delivery_system);\r\np->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\np->strength.stat[0].uvalue = strength * 4045 / 1000 - 85224;\r\nbreak;\r\ncase SYS_ISDBT:\r\nstrength = cxd2841er_read_agc_gain_i(priv, p->delivery_system);\r\np->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\np->strength.stat[0].uvalue = strength * 3775 / 1000 - 90185;\r\nbreak;\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\nstrength = 65535 - cxd2841er_read_agc_gain_s(priv);\r\np->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\np->strength.stat[0].uvalue = strength;\r\nbreak;\r\ndefault:\r\np->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nbreak;\r\n}\r\n}\r\nstatic void cxd2841er_read_snr(struct dvb_frontend *fe)\r\n{\r\nu32 tmp = 0;\r\nint ret = 0;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_B:\r\ncase SYS_DVBC_ANNEX_C:\r\nret = cxd2841er_read_snr_c(priv, &tmp);\r\nbreak;\r\ncase SYS_DVBT:\r\nret = cxd2841er_read_snr_t(priv, &tmp);\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2841er_read_snr_t2(priv, &tmp);\r\nbreak;\r\ncase SYS_ISDBT:\r\nret = cxd2841er_read_snr_i(priv, &tmp);\r\nbreak;\r\ncase SYS_DVBS:\r\ncase SYS_DVBS2:\r\nret = cxd2841er_dvbs_read_snr(priv, p->delivery_system, &tmp);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): unknown delivery system %d\n",\r\n__func__, p->delivery_system);\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): snr=%d\n",\r\n__func__, (int32_t)tmp);\r\nif (!ret) {\r\np->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\np->cnr.stat[0].svalue = tmp;\r\n} else {\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n}\r\nstatic void cxd2841er_read_ucblocks(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nu32 ucblocks = 0;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_B:\r\ncase SYS_DVBC_ANNEX_C:\r\ncxd2841er_read_packet_errors_c(priv, &ucblocks);\r\nbreak;\r\ncase SYS_DVBT:\r\ncxd2841er_read_packet_errors_t(priv, &ucblocks);\r\nbreak;\r\ncase SYS_DVBT2:\r\ncxd2841er_read_packet_errors_t2(priv, &ucblocks);\r\nbreak;\r\ncase SYS_ISDBT:\r\ncxd2841er_read_packet_errors_i(priv, &ucblocks);\r\nbreak;\r\ndefault:\r\np->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s() ucblocks=%u\n", __func__, ucblocks);\r\np->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\np->block_error.stat[0].uvalue = ucblocks;\r\n}\r\nstatic int cxd2841er_dvbt2_set_profile(\r\nstruct cxd2841er_priv *priv, enum cxd2841er_dvbt2_profile_t profile)\r\n{\r\nu8 tune_mode;\r\nu8 seq_not2d_time;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nswitch (profile) {\r\ncase DVBT2_PROFILE_BASE:\r\ntune_mode = 0x01;\r\nseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x0E:0x0C;\r\nbreak;\r\ncase DVBT2_PROFILE_LITE:\r\ntune_mode = 0x05;\r\nseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;\r\nbreak;\r\ncase DVBT2_PROFILE_ANY:\r\ntune_mode = 0x00;\r\nseq_not2d_time = (priv->xtal == SONY_XTAL_24000)?0x2E:0x28;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2e);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x10, tune_mode, 0x07);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9d, seq_not2d_time);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_dvbt2_set_plp_config(struct cxd2841er_priv *priv,\r\nu8 is_auto, u8 plp_id)\r\n{\r\nif (is_auto) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s() using auto PLP selection\n", __func__);\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s() using manual PLP selection, ID %d\n",\r\n__func__, plp_id);\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);\r\nif (!is_auto) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xaf, plp_id);\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xad, (is_auto ? 0x00 : 0x01));\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t2_band(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu32 iffreq;\r\nu8 data[MAX_WRITE_REGSIZE];\r\nconst uint8_t nominalRate8bw[3][5] = {\r\n{0x11, 0xF0, 0x00, 0x00, 0x00},\r\n{0x15, 0x00, 0x00, 0x00, 0x00},\r\n{0x11, 0xF0, 0x00, 0x00, 0x00}\r\n};\r\nconst uint8_t nominalRate7bw[3][5] = {\r\n{0x14, 0x80, 0x00, 0x00, 0x00},\r\n{0x18, 0x00, 0x00, 0x00, 0x00},\r\n{0x14, 0x80, 0x00, 0x00, 0x00}\r\n};\r\nconst uint8_t nominalRate6bw[3][5] = {\r\n{0x17, 0xEA, 0xAA, 0xAA, 0xAA},\r\n{0x1C, 0x00, 0x00, 0x00, 0x00},\r\n{0x17, 0xEA, 0xAA, 0xAA, 0xAA}\r\n};\r\nconst uint8_t nominalRate5bw[3][5] = {\r\n{0x1C, 0xB3, 0x33, 0x33, 0x33},\r\n{0x21, 0x99, 0x99, 0x99, 0x99},\r\n{0x1C, 0xB3, 0x33, 0x33, 0x33}\r\n};\r\nconst uint8_t nominalRate17bw[3][5] = {\r\n{0x58, 0xE2, 0xAF, 0xE0, 0xBC},\r\n{0x68, 0x0F, 0xA2, 0x32, 0xD0},\r\n{0x58, 0xE2, 0xAF, 0xE0, 0xBC}\r\n};\r\nconst uint8_t itbCoef8bw[3][14] = {\r\n{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,\r\n0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8},\r\n{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1,\r\n0x29, 0xA5, 0x2A, 0xAC, 0x29, 0xB5},\r\n{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA,\r\n0x23, 0xA9, 0x1F, 0xA8, 0x2C, 0xC8}\r\n};\r\nconst uint8_t itbCoef7bw[3][14] = {\r\n{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,\r\n0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5},\r\n{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0,\r\n0x29, 0xA2, 0x2B, 0xA6, 0x2B, 0xAD},\r\n{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6,\r\n0x29, 0xB0, 0x26, 0xA9, 0x21, 0xA5}\r\n};\r\nconst uint8_t itbCoef6bw[3][14] = {\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4},\r\n{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,\r\n0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8},\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}\r\n};\r\nconst uint8_t itbCoef5bw[3][14] = {\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4},\r\n{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E,\r\n0x29, 0xA4, 0x29, 0xA2, 0x29, 0xA8},\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4}\r\n};\r\nconst uint8_t itbCoef17bw[3][14] = {\r\n{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,\r\n0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99},\r\n{0x33, 0x8E, 0x2B, 0x97, 0x2D, 0x95, 0x37, 0x8B,\r\n0x30, 0x97, 0x2D, 0x9A, 0x21, 0xA4},\r\n{0x25, 0xA0, 0x36, 0x8D, 0x2E, 0x94, 0x28, 0x9B,\r\n0x32, 0x90, 0x2C, 0x9D, 0x29, 0x99}\r\n};\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate8bw[priv->xtal], 5);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT,\r\n0x7a, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef8bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x00, 0x07);\r\nbreak;\r\ncase 7000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate7bw[priv->xtal], 5);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT,\r\n0x7a, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef7bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x02, 0x07);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate6bw[priv->xtal], 5);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT,\r\n0x7a, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef6bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x04, 0x07);\r\nbreak;\r\ncase 5000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate5bw[priv->xtal], 5);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT,\r\n0x7a, 0x00, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef5bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x06, 0x07);\r\nbreak;\r\ncase 1712000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate17bw[priv->xtal], 5);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT,\r\n0x7a, 0x03, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef17bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.50);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x03, 0x07);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t_band(\r\nstruct cxd2841er_priv *priv, u32 bandwidth)\r\n{\r\nu8 data[MAX_WRITE_REGSIZE];\r\nu32 iffreq;\r\nu8 nominalRate8bw[3][5] = {\r\n{0x11, 0xF0, 0x00, 0x00, 0x00},\r\n{0x15, 0x00, 0x00, 0x00, 0x00},\r\n{0x11, 0xF0, 0x00, 0x00, 0x00}\r\n};\r\nu8 nominalRate7bw[3][5] = {\r\n{0x14, 0x80, 0x00, 0x00, 0x00},\r\n{0x18, 0x00, 0x00, 0x00, 0x00},\r\n{0x14, 0x80, 0x00, 0x00, 0x00}\r\n};\r\nu8 nominalRate6bw[3][5] = {\r\n{0x17, 0xEA, 0xAA, 0xAA, 0xAA},\r\n{0x1C, 0x00, 0x00, 0x00, 0x00},\r\n{0x17, 0xEA, 0xAA, 0xAA, 0xAA}\r\n};\r\nu8 nominalRate5bw[3][5] = {\r\n{0x1C, 0xB3, 0x33, 0x33, 0x33},\r\n{0x21, 0x99, 0x99, 0x99, 0x99},\r\n{0x1C, 0xB3, 0x33, 0x33, 0x33}\r\n};\r\nu8 itbCoef8bw[3][14] = {\r\n{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,\r\n0x1F, 0xA8, 0x2C, 0xC8},\r\n{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29, 0xA5,\r\n0x2A, 0xAC, 0x29, 0xB5},\r\n{0x26, 0xAF, 0x06, 0xCD, 0x13, 0xBB, 0x28, 0xBA, 0x23, 0xA9,\r\n0x1F, 0xA8, 0x2C, 0xC8}\r\n};\r\nu8 itbCoef7bw[3][14] = {\r\n{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,\r\n0x26, 0xA9, 0x21, 0xA5},\r\n{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29, 0xA2,\r\n0x2B, 0xA6, 0x2B, 0xAD},\r\n{0x2C, 0xBD, 0x02, 0xCF, 0x04, 0xF8, 0x23, 0xA6, 0x29, 0xB0,\r\n0x26, 0xA9, 0x21, 0xA5}\r\n};\r\nu8 itbCoef6bw[3][14] = {\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\r\n0x00, 0xE6, 0x23, 0xA4},\r\n{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,\r\n0x29, 0xA2, 0x29, 0xA8},\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\r\n0x00, 0xE6, 0x23, 0xA4}\r\n};\r\nu8 itbCoef5bw[3][14] = {\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\r\n0x00, 0xE6, 0x23, 0xA4},\r\n{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29, 0xA4,\r\n0x29, 0xA2, 0x29, 0xA8},\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00, 0xCF,\r\n0x00, 0xE6, 0x23, 0xA4}\r\n};\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ndata[0] = 0x01;\r\ndata[1] = 0x14;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x9C, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate8bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef8bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.80);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x00, 0x07);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ndata[0] = 0x15;\r\ndata[1] = 0x28;\r\n} else {\r\ndata[0] = 0x01;\r\ndata[1] = 0xE0;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ndata[0] = 0x01;\r\ndata[1] = 0x02;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\r\nbreak;\r\ncase 7000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate7bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef7bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.20);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x02, 0x07);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ndata[0] = 0x1F;\r\ndata[1] = 0xF8;\r\n} else {\r\ndata[0] = 0x12;\r\ndata[1] = 0xF8;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ndata[0] = 0x00;\r\ndata[1] = 0x03;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate6bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef6bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x04, 0x07);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ndata[0] = 0x25;\r\ndata[1] = 0x4C;\r\n} else {\r\ndata[0] = 0x1F;\r\ndata[1] = 0xDC;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ndata[0] = 0x00;\r\ndata[1] = 0x03;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\r\nbreak;\r\ncase 5000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate5bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef5bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.60);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xD7, 0x06, 0x07);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ndata[0] = 0x2C;\r\ndata[1] = 0xC2;\r\n} else {\r\ndata[0] = 0x26;\r\ndata[1] = 0x3C;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ndata[0] = 0x00;\r\ndata[1] = 0x03;\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x17);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x38, data, 2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_i_band(\r\nstruct cxd2841er_priv *priv, u32 bandwidth)\r\n{\r\nu32 iffreq;\r\nu8 data[3];\r\nu8 nominalRate8bw[3][5] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x11, 0xB8, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00}\r\n};\r\nu8 nominalRate7bw[3][5] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x14, 0x40, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00}\r\n};\r\nu8 nominalRate6bw[3][5] = {\r\n{0x14, 0x2E, 0x00, 0x00, 0x00},\r\n{0x17, 0xA0, 0x00, 0x00, 0x00},\r\n{0x14, 0x2E, 0x00, 0x00, 0x00}\r\n};\r\nu8 itbCoef8bw[3][14] = {\r\n{0x00},\r\n{0x2F, 0xBA, 0x28, 0x9B, 0x28, 0x9D, 0x28, 0xA1, 0x29,\r\n0xA5, 0x2A, 0xAC, 0x29, 0xB5},\r\n{0x0},\r\n};\r\nu8 itbCoef7bw[3][14] = {\r\n{0x00},\r\n{0x30, 0xB1, 0x29, 0x9A, 0x28, 0x9C, 0x28, 0xA0, 0x29,\r\n0xA2, 0x2B, 0xA6, 0x2B, 0xAD},\r\n{0x00},\r\n};\r\nu8 itbCoef6bw[3][14] = {\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,\r\n0xCF, 0x00, 0xE6, 0x23, 0xA4},\r\n{0x31, 0xA8, 0x29, 0x9B, 0x27, 0x9C, 0x28, 0x9E, 0x29,\r\n0xA4, 0x29, 0xA2, 0x29, 0xA8},\r\n{0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8, 0x00,\r\n0xCF, 0x00, 0xE6, 0x23, 0xA4},\r\n};\r\ndev_dbg(&priv->i2c->dev, "%s() bandwidth=%u\n", __func__, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\nif (priv->xtal != SONY_XTAL_24000 && bandwidth > 6000000) {\r\ndev_err(&priv->i2c->dev,\r\n"%s(): bandwidth %d supported only for 24MHz xtal\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate8bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef8bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.75);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x0, 0x7);\r\ndata[0] = 0x13;\r\ndata[1] = 0xFC;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x03);\r\nbreak;\r\ncase 7000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate7bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef7bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 4.15);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x02, 0x7);\r\ndata[0] = 0x1A;\r\ndata[1] = 0xFA;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x03, 0x07);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0x9F, nominalRate6bw[priv->xtal], 5);\r\ncxd2841er_write_regs(priv, I2C_SLVT,\r\n0xA6, itbCoef6bw[priv->xtal], 14);\r\niffreq = MAKE_IFFREQ_CONFIG_XTAL(priv->xtal, 3.55);\r\ndata[0] = (u8) ((iffreq >> 16) & 0xff);\r\ndata[1] = (u8)((iffreq >> 8) & 0xff);\r\ndata[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xB6, data, 3);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd7, 0x04, 0x7);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ndata[0] = 0x1F;\r\ndata[1] = 0x79;\r\n} else {\r\ndata[0] = 0x1A;\r\ndata[1] = 0xE2;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x12);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x71, 0x07, 0x07);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xBE, 0x02);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_c_band(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 bw7_8mhz_b10_a6[] = {\r\n0x2D, 0xC7, 0x04, 0xF4, 0x07, 0xC5, 0x2A, 0xB8,\r\n0x27, 0x9E, 0x27, 0xA4, 0x29, 0xAB };\r\nu8 bw6mhz_b10_a6[] = {\r\n0x27, 0xA7, 0x28, 0xB3, 0x02, 0xF0, 0x01, 0xE8,\r\n0x00, 0xCF, 0x00, 0xE6, 0x23, 0xA4 };\r\nu8 b10_b6[3];\r\nu32 iffreq;\r\nif (bandwidth != 6000000 &&\r\nbandwidth != 7000000 &&\r\nbandwidth != 8000000) {\r\ndev_info(&priv->i2c->dev, "%s(): unsupported bandwidth %d. Forcing 8Mhz!\n",\r\n__func__, bandwidth);\r\nbandwidth = 8000000;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s() bw=%d\n", __func__, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncase 7000000:\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xa6,\r\nbw7_8mhz_b10_a6, sizeof(bw7_8mhz_b10_a6));\r\niffreq = MAKE_IFFREQ_CONFIG(4.9);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_write_regs(\r\npriv, I2C_SLVT, 0xa6,\r\nbw6mhz_b10_a6, sizeof(bw6mhz_b10_a6));\r\niffreq = MAKE_IFFREQ_CONFIG(3.7);\r\nbreak;\r\ndefault:\r\ndev_err(&priv->i2c->dev, "%s(): unsupported bandwidth %d\n",\r\n__func__, bandwidth);\r\nreturn -EINVAL;\r\n}\r\nb10_b6[0] = (u8) ((iffreq >> 16) & 0xff);\r\nb10_b6[1] = (u8)((iffreq >> 8) & 0xff);\r\nb10_b6[2] = (u8)(iffreq & 0xff);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xb6, b10_b6, sizeof(b10_b6));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncase 7000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xa3, 0x00, 0x1f);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0xa3, 0x14, 0x1f);\r\nbreak;\r\n}\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\nswitch (bandwidth) {\r\ncase 8000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x0b, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0x3e);\r\nbreak;\r\ncase 7000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0xd6);\r\nbreak;\r\ncase 6000000:\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVT, 0x26, 0x08, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x27, 0x6e);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\nu8 data24m[3] = {0xDC, 0x6C, 0x00};\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBT);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\nif (priv->xtal == SONY_XTAL_41000) {\r\ndata[0] = 0x0A;\r\ndata[1] = 0xD4;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x36, 0x40, 0x07);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xBF, 0x60);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x18);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x24, data24m, 3);\r\n}\r\ncxd2841er_sleep_tc_to_active_t_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_t2(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[MAX_WRITE_REGSIZE];\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBT2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x02);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\nif (priv->xtal == SONY_XTAL_41000) {\r\ndata[0] = 0x0A;\r\ndata[1] = 0xD4;\r\n} else {\r\ndata[0] = 0x09;\r\ndata[1] = 0x54;\r\n}\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x0c, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x8b, 0x3c);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x76, 0x20, 0x70);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x23);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE6, 0x00, 0x03);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x13);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x83, 0x10);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x86, 0x34);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9e, 0x09, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9f, 0xd8);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2a);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x38, 0x04, 0x0f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2b);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x11, 0x20, 0x3f);\r\nif (priv->xtal == SONY_XTAL_24000) {\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ndata[0] = 0xEB;\r\ndata[1] = 0x03;\r\ndata[2] = 0x3B;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x33, data, 3);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x20);\r\ndata[0] = 0x5E;\r\ndata[1] = 0x5E;\r\ndata[2] = 0x47;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x95, data, 3);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x99, 0x18);\r\ndata[0] = 0x3F;\r\ndata[1] = 0xFF;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD9, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x24);\r\ndata[0] = 0x0B;\r\ndata[1] = 0x72;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x34, data, 2);\r\ndata[0] = 0x93;\r\ndata[1] = 0xF3;\r\ndata[2] = 0x00;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xD2, data, 3);\r\ndata[0] = 0x05;\r\ndata[1] = 0xB8;\r\ndata[2] = 0xD8;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xDD, data, 3);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xE0, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x25);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xED, 0x60);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x27);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xFA, 0x34);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2B);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x4B, 0x2F);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x9E, 0x0E);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x2D);\r\ndata[0] = 0x89;\r\ndata[1] = 0x89;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x24, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x5E);\r\ndata[0] = 0x24;\r\ndata[1] = 0x95;\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x8C, data, 2);\r\n}\r\ncxd2841er_sleep_tc_to_active_t2_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_i(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\nu8 data24m[2] = {0x60, 0x00};\r\nu8 data24m2[3] = {0xB7, 0x1B, 0x00};\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBT);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x06);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x30, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x31, 0x00, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x00, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x00, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x69, 0x04, 0x07);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x6B, 0x03, 0x07);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x9D, 0x50, 0xFF);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xD3, 0x06, 0x1F);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xED, 0x00, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xE2, 0xCE, 0x80);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xF2, 0x13, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x2E, 0x3F);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x15);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xDE, 0x02, 0x03);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x1E);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x73, 0x68, 0xFF);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x63);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0x81, 0x00, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xBF, data24m, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x60);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0xA8, data24m2, 3);\r\ncxd2841er_sleep_tc_to_active_i_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc_to_active_c(struct cxd2841er_priv *priv,\r\nu32 bandwidth)\r\n{\r\nu8 data[2] = { 0x09, 0x54 };\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_set_ts_clock_mode(priv, SYS_DVBC_ANNEX_A);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x17, 0x04);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2c, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x59, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x2f, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x30, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x41, 0x1a);\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x43, data, 2);\r\ncxd2841er_write_reg(priv, I2C_SLVX, 0x18, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xd2, 0x09, 0x1f);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x11);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x6a, 0x48);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xa5, 0x01, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x40);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc3, 0x00, 0x04);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xce, 0x01, 0x01);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcf, 0x01, 0x01);\r\ncxd2841er_sleep_tc_to_active_c_band(priv, bandwidth);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x80, 0x28);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x81, 0x00);\r\npriv->state = STATE_ACTIVE_TC;\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nenum fe_status status = 0;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE_S)\r\ncxd2841er_read_status_s(fe, &status);\r\nelse if (priv->state == STATE_ACTIVE_TC)\r\ncxd2841er_read_status_tc(fe, &status);\r\ncxd2841er_read_signal_strength(fe);\r\nif (status & FE_HAS_LOCK) {\r\ncxd2841er_read_snr(fe);\r\ncxd2841er_read_ucblocks(fe);\r\ncxd2841er_read_ber(fe);\r\n} else {\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_set_frontend_s(struct dvb_frontend *fe)\r\n{\r\nint ret = 0, i, timeout, carr_offset;\r\nenum fe_status status;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 symbol_rate = p->symbol_rate/1000;\r\ndev_dbg(&priv->i2c->dev, "%s(): %s frequency=%d symbol_rate=%d xtal=%d\n",\r\n__func__,\r\n(p->delivery_system == SYS_DVBS ? "DVB-S" : "DVB-S2"),\r\np->frequency, symbol_rate, priv->xtal);\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_S:\r\nret = cxd2841er_sleep_s_to_active_s(\r\npriv, p->delivery_system, symbol_rate);\r\nbreak;\r\ncase STATE_ACTIVE_S:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ret) {\r\ndev_dbg(&priv->i2c->dev, "%s(): tune failed\n", __func__);\r\ngoto done;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ncxd2841er_tune_done(priv);\r\ntimeout = ((3000000 + (symbol_rate - 1)) / symbol_rate) + 150;\r\nfor (i = 0; i < timeout / CXD2841ER_DVBS_POLLING_INVL; i++) {\r\nusleep_range(CXD2841ER_DVBS_POLLING_INVL*1000,\r\n(CXD2841ER_DVBS_POLLING_INVL + 2) * 1000);\r\ncxd2841er_read_status_s(fe, &status);\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\n}\r\nif (status & FE_HAS_LOCK) {\r\nif (cxd2841er_get_carrier_offset_s_s2(\r\npriv, &carr_offset)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): carrier_offset=%d\n",\r\n__func__, carr_offset);\r\n}\r\ndone:\r\np->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_set_frontend_tc(struct dvb_frontend *fe)\r\n{\r\nint ret = 0, timeout;\r\nenum fe_status status;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s() delivery_system=%d bandwidth_hz=%d\n",\r\n__func__, p->delivery_system, p->bandwidth_hz);\r\nif (p->delivery_system == SYS_DVBT) {\r\npriv->system = SYS_DVBT;\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_t(\r\npriv, p->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else if (p->delivery_system == SYS_DVBT2) {\r\npriv->system = SYS_DVBT2;\r\ncxd2841er_dvbt2_set_plp_config(priv,\r\n(int)(p->stream_id > 255), p->stream_id);\r\ncxd2841er_dvbt2_set_profile(priv, DVBT2_PROFILE_BASE);\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_t2(priv,\r\np->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else if (p->delivery_system == SYS_ISDBT) {\r\npriv->system = SYS_ISDBT;\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_i(\r\npriv, p->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else if (p->delivery_system == SYS_DVBC_ANNEX_A ||\r\np->delivery_system == SYS_DVBC_ANNEX_C) {\r\npriv->system = SYS_DVBC_ANNEX_A;\r\nif (p->bandwidth_hz != 6000000 &&\r\np->bandwidth_hz != 7000000 &&\r\np->bandwidth_hz != 8000000) {\r\np->bandwidth_hz = 8000000;\r\ndev_dbg(&priv->i2c->dev, "%s(): forcing bandwidth to %d\n",\r\n__func__, p->bandwidth_hz);\r\n}\r\nswitch (priv->state) {\r\ncase STATE_SLEEP_TC:\r\nret = cxd2841er_sleep_tc_to_active_c(\r\npriv, p->bandwidth_hz);\r\nbreak;\r\ncase STATE_ACTIVE_TC:\r\nret = cxd2841er_retune_active(priv, p);\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nret = -EINVAL;\r\n}\r\n} else {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid delivery system %d\n",\r\n__func__, p->delivery_system);\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\ngoto done;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ncxd2841er_tune_done(priv);\r\ntimeout = 2500;\r\nwhile (timeout > 0) {\r\nret = cxd2841er_read_status_tc(fe, &status);\r\nif (ret)\r\ngoto done;\r\nif (status & FE_HAS_LOCK)\r\nbreak;\r\nmsleep(20);\r\ntimeout -= 20;\r\n}\r\nif (timeout < 0)\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): LOCK wait timeout\n", __func__);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int cxd2841er_tune_s(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nint ret, carrier_offset;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s() re_tune=%d\n", __func__, re_tune);\r\nif (re_tune) {\r\nret = cxd2841er_set_frontend_s(fe);\r\nif (ret)\r\nreturn ret;\r\ncxd2841er_read_status_s(fe, status);\r\nif (*status & FE_HAS_LOCK) {\r\nif (cxd2841er_get_carrier_offset_s_s2(\r\npriv, &carrier_offset))\r\nreturn -EINVAL;\r\np->frequency += carrier_offset;\r\nret = cxd2841er_set_frontend_s(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n*delay = HZ / 5;\r\nreturn cxd2841er_read_status_s(fe, status);\r\n}\r\nstatic int cxd2841er_tune_tc(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nenum fe_status *status)\r\n{\r\nint ret, carrier_offset;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s(): re_tune %d bandwidth=%d\n", __func__,\r\nre_tune, p->bandwidth_hz);\r\nif (re_tune) {\r\nret = cxd2841er_set_frontend_tc(fe);\r\nif (ret)\r\nreturn ret;\r\ncxd2841er_read_status_tc(fe, status);\r\nif (*status & FE_HAS_LOCK) {\r\nswitch (priv->system) {\r\ncase SYS_ISDBT:\r\nret = cxd2841er_get_carrier_offset_i(\r\npriv, p->bandwidth_hz,\r\n&carrier_offset);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase SYS_DVBT:\r\nret = cxd2841er_get_carrier_offset_t(\r\npriv, p->bandwidth_hz,\r\n&carrier_offset);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase SYS_DVBT2:\r\nret = cxd2841er_get_carrier_offset_t2(\r\npriv, p->bandwidth_hz,\r\n&carrier_offset);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\nret = cxd2841er_get_carrier_offset_c(\r\npriv, &carrier_offset);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): invalid delivery system %d\n",\r\n__func__, priv->system);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s(): carrier offset %d\n",\r\n__func__, carrier_offset);\r\np->frequency += carrier_offset;\r\nret = cxd2841er_set_frontend_tc(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n*delay = HZ / 5;\r\nreturn cxd2841er_read_status_tc(fe, status);\r\n}\r\nstatic int cxd2841er_sleep_s(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_active_s_to_sleep_s(fe->demodulator_priv);\r\ncxd2841er_sleep_s_to_shutdown(fe->demodulator_priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_sleep_tc(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nif (priv->state == STATE_ACTIVE_TC) {\r\nswitch (priv->system) {\r\ncase SYS_DVBT:\r\ncxd2841er_active_t_to_sleep_tc(priv);\r\nbreak;\r\ncase SYS_DVBT2:\r\ncxd2841er_active_t2_to_sleep_tc(priv);\r\nbreak;\r\ncase SYS_ISDBT:\r\ncxd2841er_active_i_to_sleep_tc(priv);\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ncxd2841er_active_c_to_sleep_tc(priv);\r\nbreak;\r\ndefault:\r\ndev_warn(&priv->i2c->dev,\r\n"%s(): unknown delivery system %d\n",\r\n__func__, priv->system);\r\n}\r\n}\r\nif (priv->state != STATE_SLEEP_TC) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ncxd2841er_sleep_tc_to_shutdown(priv);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nu8 data;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): burst mode %s\n", __func__,\r\n(burst == SEC_MINI_A ? "A" : "B"));\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndata = (burst == SEC_MINI_A ? 0 : 1);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x34, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x35, data);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nu8 data;\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): tone %s\n", __func__,\r\n(tone == SEC_TONE_ON ? "On" : "Off"));\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndata = (tone == SEC_TONE_ON ? 1 : 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x36, data);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nint i;\r\nu8 data[12];\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nif (priv->state != STATE_SLEEP_S &&\r\npriv->state != STATE_ACTIVE_S) {\r\ndev_err(&priv->i2c->dev, "%s(): invalid demod state %d\n",\r\n__func__, priv->state);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): cmd->len %d\n", __func__, cmd->msg_len);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xbb);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x33, 0x01);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x3d, cmd->msg_len);\r\nmemset(data, 0, sizeof(data));\r\nfor (i = 0; i < cmd->msg_len && i < sizeof(data); i++)\r\ndata[i] = cmd->msg[i];\r\ncxd2841er_write_regs(priv, I2C_SLVT, 0x3e, data, sizeof(data));\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x37, 1);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x38, 0);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x32, 0x01);\r\nfor (i = 0; i < 50; i++) {\r\ncxd2841er_read_reg(priv, I2C_SLVT, 0x10, data);\r\nif (!data[0]) {\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): DiSEqC cmd has been sent\n", __func__);\r\nreturn 0;\r\n}\r\nmsleep(20);\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s(): DiSEqC cmd transmit timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void cxd2841er_release(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nkfree(priv);\r\n}\r\nstatic int cxd2841er_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s(): enable=%d\n", __func__, enable);\r\ncxd2841er_set_reg_bits(\r\npriv, I2C_SLVX, 0x8, (enable ? 0x01 : 0x00), 0x01);\r\nreturn 0;\r\n}\r\nstatic enum dvbfe_algo cxd2841er_get_algo(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic void cxd2841er_init_stats(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\np->strength.len = 1;\r\np->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\np->cnr.len = 1;\r\np->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->block_error.len = 1;\r\np->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_error.len = 1;\r\np->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\np->post_bit_count.len = 1;\r\np->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nstatic int cxd2841er_init_s(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nif (priv->state == STATE_SLEEP_S) {\r\ndev_dbg(&priv->i2c->dev, "%s() forcing sleep->shutdown\n",\r\n__func__);\r\ncxd2841er_sleep_s_to_shutdown(priv);\r\n} else if (priv->state == STATE_ACTIVE_S) {\r\ndev_dbg(&priv->i2c->dev, "%s() forcing active->sleep->shutdown\n",\r\n__func__);\r\ncxd2841er_active_s_to_sleep_s(priv);\r\ncxd2841er_sleep_s_to_shutdown(priv);\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s()\n", __func__);\r\ncxd2841er_shutdown_to_sleep_s(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0xa0);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xb9, 0x01, 0x01);\r\ncxd2841er_init_stats(fe);\r\nreturn 0;\r\n}\r\nstatic int cxd2841er_init_tc(struct dvb_frontend *fe)\r\n{\r\nstruct cxd2841er_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndev_dbg(&priv->i2c->dev, "%s() bandwidth_hz=%d\n",\r\n__func__, p->bandwidth_hz);\r\ncxd2841er_shutdown_to_sleep_tc(priv);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x10);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xcb, 0x40, 0x40);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0xcd, 0x50);\r\ncxd2841er_write_reg(priv, I2C_SLVT, 0x00, 0x00);\r\ncxd2841er_set_reg_bits(priv, I2C_SLVT, 0xc4, 0x00, 0x80);\r\ncxd2841er_init_stats(fe);\r\nreturn 0;\r\n}\r\nstatic struct dvb_frontend *cxd2841er_attach(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c,\r\nu8 system)\r\n{\r\nu8 chip_id = 0;\r\nconst char *type;\r\nconst char *name;\r\nstruct cxd2841er_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct cxd2841er_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\npriv->i2c = i2c;\r\npriv->config = cfg;\r\npriv->i2c_addr_slvx = (cfg->i2c_addr + 4) >> 1;\r\npriv->i2c_addr_slvt = (cfg->i2c_addr) >> 1;\r\npriv->xtal = cfg->xtal;\r\npriv->frontend.demodulator_priv = priv;\r\ndev_info(&priv->i2c->dev,\r\n"%s(): I2C adapter %p SLVX addr %x SLVT addr %x\n",\r\n__func__, priv->i2c,\r\npriv->i2c_addr_slvx, priv->i2c_addr_slvt);\r\nchip_id = cxd2841er_chip_id(priv);\r\nswitch (chip_id) {\r\ncase CXD2841ER_CHIP_ID:\r\nsnprintf(cxd2841er_t_c_ops.info.name, 128,\r\n"Sony CXD2841ER DVB-T/T2/C demodulator");\r\nname = "CXD2841ER";\r\nbreak;\r\ncase CXD2854ER_CHIP_ID:\r\nsnprintf(cxd2841er_t_c_ops.info.name, 128,\r\n"Sony CXD2854ER DVB-T/T2/C and ISDB-T demodulator");\r\ncxd2841er_t_c_ops.delsys[3] = SYS_ISDBT;\r\nname = "CXD2854ER";\r\nbreak;\r\ndefault:\r\ndev_err(&priv->i2c->dev, "%s(): invalid chip ID 0x%02x\n",\r\n__func__, chip_id);\r\npriv->frontend.demodulator_priv = NULL;\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nif (system == SYS_DVBS) {\r\nmemcpy(&priv->frontend.ops,\r\n&cxd2841er_dvbs_s2_ops,\r\nsizeof(struct dvb_frontend_ops));\r\ntype = "S/S2";\r\n} else {\r\nmemcpy(&priv->frontend.ops,\r\n&cxd2841er_t_c_ops,\r\nsizeof(struct dvb_frontend_ops));\r\ntype = "T/T2/C/ISDB-T";\r\n}\r\ndev_info(&priv->i2c->dev,\r\n"%s(): attaching %s DVB-%s frontend\n",\r\n__func__, name, type);\r\ndev_info(&priv->i2c->dev, "%s(): chip ID 0x%02x OK.\n",\r\n__func__, chip_id);\r\nreturn &priv->frontend;\r\n}\r\nstruct dvb_frontend *cxd2841er_attach_s(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nreturn cxd2841er_attach(cfg, i2c, SYS_DVBS);\r\n}\r\nstruct dvb_frontend *cxd2841er_attach_t_c(struct cxd2841er_config *cfg,\r\nstruct i2c_adapter *i2c)\r\n{\r\nreturn cxd2841er_attach(cfg, i2c, 0);\r\n}
