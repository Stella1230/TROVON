static u32 mid_pwr_get_state(struct mid_pwr *pwr, int reg)\r\n{\r\nreturn readl(pwr->regs + PM_SSS(reg));\r\n}\r\nstatic void mid_pwr_set_state(struct mid_pwr *pwr, int reg, u32 value)\r\n{\r\nwritel(value, pwr->regs + PM_SSC(reg));\r\n}\r\nstatic void mid_pwr_set_wake(struct mid_pwr *pwr, int reg, u32 value)\r\n{\r\nwritel(value, pwr->regs + PM_WKC(reg));\r\n}\r\nstatic void mid_pwr_interrupt_disable(struct mid_pwr *pwr)\r\n{\r\nwritel(~PM_ICS_IE, pwr->regs + PM_ICS);\r\n}\r\nstatic bool mid_pwr_is_busy(struct mid_pwr *pwr)\r\n{\r\nreturn !!(readl(pwr->regs + PM_STS) & PM_STS_BUSY);\r\n}\r\nstatic int mid_pwr_wait(struct mid_pwr *pwr)\r\n{\r\nunsigned int count = 500000;\r\nbool busy;\r\ndo {\r\nbusy = mid_pwr_is_busy(pwr);\r\nif (!busy)\r\nreturn 0;\r\nudelay(1);\r\n} while (--count);\r\nreturn -EBUSY;\r\n}\r\nstatic int mid_pwr_wait_for_cmd(struct mid_pwr *pwr, u8 cmd)\r\n{\r\nwritel(PM_CMD_CMD(cmd) | PM_CMD_CM_IMMEDIATE, pwr->regs + PM_CMD);\r\nreturn mid_pwr_wait(pwr);\r\n}\r\nstatic int __update_power_state(struct mid_pwr *pwr, int reg, int bit, int new)\r\n{\r\nint curstate;\r\nu32 power;\r\nint ret;\r\npower = mid_pwr_get_state(pwr, reg);\r\ncurstate = (power >> bit) & 3;\r\nif (curstate == new)\r\nreturn 0;\r\nmid_pwr_set_state(pwr, reg, (power & ~(3 << bit)) | (new << bit));\r\nret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);\r\nif (ret)\r\nreturn ret;\r\npower = mid_pwr_get_state(pwr, reg);\r\ncurstate = (power >> bit) & 3;\r\nif (curstate != new)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic pci_power_t __find_weakest_power_state(struct mid_pwr_dev *lss,\r\nstruct pci_dev *pdev,\r\npci_power_t state)\r\n{\r\npci_power_t weakest = PCI_D3hot;\r\nunsigned int j;\r\nfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++) {\r\nif (lss[j].pdev == pdev || !lss[j].pdev)\r\nbreak;\r\n}\r\nif (j < LSS_MAX_SHARED_DEVS) {\r\nlss[j].pdev = pdev;\r\nlss[j].state = state;\r\n} else {\r\ndev_WARN(&pdev->dev, "No room for device in PWRMU LSS cache\n");\r\nweakest = state;\r\n}\r\nfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++) {\r\nif (lss[j].state < weakest)\r\nweakest = lss[j].state;\r\n}\r\nreturn weakest;\r\n}\r\nstatic int __set_power_state(struct mid_pwr *pwr, struct pci_dev *pdev,\r\npci_power_t state, int id, int reg, int bit)\r\n{\r\nconst char *name;\r\nint ret;\r\nstate = __find_weakest_power_state(pwr->lss[id], pdev, state);\r\nname = pci_power_name(state);\r\nret = __update_power_state(pwr, reg, bit, (__force int)state);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "Can't set power state %s: %d\n", name, ret);\r\nreturn ret;\r\n}\r\ndev_vdbg(&pdev->dev, "Set power state %s\n", name);\r\nreturn 0;\r\n}\r\nstatic int mid_pwr_set_power_state(struct mid_pwr *pwr, struct pci_dev *pdev,\r\npci_power_t state)\r\n{\r\nint id, reg, bit;\r\nint ret;\r\nid = intel_mid_pwr_get_lss_id(pdev);\r\nif (id < 0)\r\nreturn id;\r\nreg = (id * LSS_PWS_BITS) / 32;\r\nbit = (id * LSS_PWS_BITS) % 32;\r\nif (state < PCI_D0)\r\nstate = PCI_D0;\r\nif (state > PCI_D3hot)\r\nstate = PCI_D3hot;\r\nmutex_lock(&pwr->lock);\r\nret = __set_power_state(pwr, pdev, state, id, reg, bit);\r\nmutex_unlock(&pwr->lock);\r\nreturn ret;\r\n}\r\nint intel_mid_pci_set_power_state(struct pci_dev *pdev, pci_power_t state)\r\n{\r\nstruct mid_pwr *pwr = midpwr;\r\nint ret = 0;\r\nmight_sleep();\r\nif (pwr && pwr->available)\r\nret = mid_pwr_set_power_state(pwr, pdev, state);\r\ndev_vdbg(&pdev->dev, "set_power_state() returns %d\n", ret);\r\nreturn 0;\r\n}\r\npci_power_t intel_mid_pci_get_power_state(struct pci_dev *pdev)\r\n{\r\nstruct mid_pwr *pwr = midpwr;\r\nint id, reg, bit;\r\nu32 power;\r\nif (!pwr || !pwr->available)\r\nreturn PCI_UNKNOWN;\r\nid = intel_mid_pwr_get_lss_id(pdev);\r\nif (id < 0)\r\nreturn PCI_UNKNOWN;\r\nreg = (id * LSS_PWS_BITS) / 32;\r\nbit = (id * LSS_PWS_BITS) % 32;\r\npower = mid_pwr_get_state(pwr, reg);\r\nreturn (__force pci_power_t)((power >> bit) & 3);\r\n}\r\nvoid intel_mid_pwr_power_off(void)\r\n{\r\nstruct mid_pwr *pwr = midpwr;\r\nu32 cmd = PM_CMD_SYS_STATE_S5 |\r\nPM_CMD_CMD(CMD_SET_CFG) |\r\nPM_CMD_CM_TRIGGER |\r\nPM_CMD_CFG_TRIGGER_NC |\r\nTRIGGER_NC_MSG_2;\r\nwritel(cmd, pwr->regs + PM_CMD);\r\nmid_pwr_wait(pwr);\r\n}\r\nint intel_mid_pwr_get_lss_id(struct pci_dev *pdev)\r\n{\r\nint vndr;\r\nu8 id;\r\nvndr = pci_find_capability(pdev, PCI_CAP_ID_VNDR);\r\nif (!vndr)\r\nreturn -EINVAL;\r\npci_read_config_byte(pdev, vndr + INTEL_MID_PWR_LSS_OFFSET, &id);\r\nif (!(id & INTEL_MID_PWR_LSS_TYPE))\r\nreturn -ENODEV;\r\nid &= ~INTEL_MID_PWR_LSS_TYPE;\r\nif (id >= LSS_MAX_DEVS)\r\nreturn -ERANGE;\r\nreturn id;\r\n}\r\nstatic irqreturn_t mid_pwr_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mid_pwr *pwr = dev_id;\r\nu32 ics;\r\nics = readl(pwr->regs + PM_ICS);\r\nif (!(ics & PM_ICS_IP))\r\nreturn IRQ_NONE;\r\nwritel(ics | PM_ICS_IP, pwr->regs + PM_ICS);\r\ndev_warn(pwr->dev, "Unexpected IRQ: %#x\n", PM_ICS_INT_STATUS(ics));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mid_pwr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct mid_pwr_device_info *info = (void *)id->driver_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct mid_pwr *pwr;\r\nint ret;\r\nret = pcim_enable_device(pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "error: could not enable device\n");\r\nreturn ret;\r\n}\r\nret = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\r\nif (ret) {\r\ndev_err(&pdev->dev, "I/O memory remapping failed\n");\r\nreturn ret;\r\n}\r\npwr = devm_kzalloc(dev, sizeof(*pwr), GFP_KERNEL);\r\nif (!pwr)\r\nreturn -ENOMEM;\r\npwr->dev = dev;\r\npwr->regs = pcim_iomap_table(pdev)[0];\r\npwr->irq = pdev->irq;\r\nmutex_init(&pwr->lock);\r\nmid_pwr_interrupt_disable(pwr);\r\nif (info && info->set_initial_state) {\r\nret = info->set_initial_state(pwr);\r\nif (ret)\r\ndev_warn(dev, "Can't set initial state: %d\n", ret);\r\n}\r\nret = devm_request_irq(dev, pdev->irq, mid_pwr_irq_handler,\r\nIRQF_NO_SUSPEND, pci_name(pdev), pwr);\r\nif (ret)\r\nreturn ret;\r\npwr->available = true;\r\nmidpwr = pwr;\r\npci_set_drvdata(pdev, pwr);\r\nreturn 0;\r\n}\r\nstatic int mid_set_initial_state(struct mid_pwr *pwr, const u32 *states)\r\n{\r\nunsigned int i, j;\r\nint ret;\r\nmid_pwr_set_wake(pwr, 0, 0xffffffff);\r\nmid_pwr_set_wake(pwr, 1, 0xffffffff);\r\nmid_pwr_set_state(pwr, 0, states[0]);\r\nmid_pwr_set_state(pwr, 1, states[1]);\r\nmid_pwr_set_state(pwr, 2, states[2]);\r\nmid_pwr_set_state(pwr, 3, states[3]);\r\nret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < LSS_MAX_DEVS; i++) {\r\nfor (j = 0; j < LSS_MAX_SHARED_DEVS; j++)\r\npwr->lss[i][j].state = PCI_D3hot;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnw_set_initial_state(struct mid_pwr *pwr)\r\n{\r\nconst u32 states[] = {\r\n0xf00fffff,\r\n0xffffffff,\r\n0xffffffff,\r\n0xffffffff,\r\n};\r\nreturn mid_set_initial_state(pwr, states);\r\n}\r\nstatic int tng_set_initial_state(struct mid_pwr *pwr)\r\n{\r\nconst u32 states[] = {\r\n0xffffffff,\r\n0xffffffff,\r\n0xffffffff,\r\n0xffffffff,\r\n};\r\nreturn mid_set_initial_state(pwr, states);\r\n}
