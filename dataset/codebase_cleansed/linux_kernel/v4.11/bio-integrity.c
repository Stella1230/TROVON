void blk_flush_integrity(void)\r\n{\r\nflush_workqueue(kintegrityd_wq);\r\n}\r\nstruct bio_integrity_payload *bio_integrity_alloc(struct bio *bio,\r\ngfp_t gfp_mask,\r\nunsigned int nr_vecs)\r\n{\r\nstruct bio_integrity_payload *bip;\r\nstruct bio_set *bs = bio->bi_pool;\r\nunsigned inline_vecs;\r\nif (!bs || !bs->bio_integrity_pool) {\r\nbip = kmalloc(sizeof(struct bio_integrity_payload) +\r\nsizeof(struct bio_vec) * nr_vecs, gfp_mask);\r\ninline_vecs = nr_vecs;\r\n} else {\r\nbip = mempool_alloc(bs->bio_integrity_pool, gfp_mask);\r\ninline_vecs = BIP_INLINE_VECS;\r\n}\r\nif (unlikely(!bip))\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(bip, 0, sizeof(*bip));\r\nif (nr_vecs > inline_vecs) {\r\nunsigned long idx = 0;\r\nbip->bip_vec = bvec_alloc(gfp_mask, nr_vecs, &idx,\r\nbs->bvec_integrity_pool);\r\nif (!bip->bip_vec)\r\ngoto err;\r\nbip->bip_max_vcnt = bvec_nr_vecs(idx);\r\nbip->bip_slab = idx;\r\n} else {\r\nbip->bip_vec = bip->bip_inline_vecs;\r\nbip->bip_max_vcnt = inline_vecs;\r\n}\r\nbip->bip_bio = bio;\r\nbio->bi_integrity = bip;\r\nbio->bi_opf |= REQ_INTEGRITY;\r\nreturn bip;\r\nerr:\r\nmempool_free(bip, bs->bio_integrity_pool);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid bio_integrity_free(struct bio *bio)\r\n{\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct bio_set *bs = bio->bi_pool;\r\nif (bip->bip_flags & BIP_BLOCK_INTEGRITY)\r\nkfree(page_address(bip->bip_vec->bv_page) +\r\nbip->bip_vec->bv_offset);\r\nif (bs && bs->bio_integrity_pool) {\r\nbvec_free(bs->bvec_integrity_pool, bip->bip_vec, bip->bip_slab);\r\nmempool_free(bip, bs->bio_integrity_pool);\r\n} else {\r\nkfree(bip);\r\n}\r\nbio->bi_integrity = NULL;\r\n}\r\nint bio_integrity_add_page(struct bio *bio, struct page *page,\r\nunsigned int len, unsigned int offset)\r\n{\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct bio_vec *iv;\r\nif (bip->bip_vcnt >= bip->bip_max_vcnt) {\r\nprintk(KERN_ERR "%s: bip_vec full\n", __func__);\r\nreturn 0;\r\n}\r\niv = bip->bip_vec + bip->bip_vcnt;\r\nif (bip->bip_vcnt &&\r\nbvec_gap_to_prev(bdev_get_queue(bio->bi_bdev),\r\n&bip->bip_vec[bip->bip_vcnt - 1], offset))\r\nreturn 0;\r\niv->bv_page = page;\r\niv->bv_len = len;\r\niv->bv_offset = offset;\r\nbip->bip_vcnt++;\r\nreturn len;\r\n}\r\nbool bio_integrity_enabled(struct bio *bio)\r\n{\r\nstruct blk_integrity *bi = bdev_get_integrity(bio->bi_bdev);\r\nif (bio_op(bio) != REQ_OP_READ && bio_op(bio) != REQ_OP_WRITE)\r\nreturn false;\r\nif (bio_integrity(bio))\r\nreturn false;\r\nif (bi == NULL)\r\nreturn false;\r\nif (bio_data_dir(bio) == READ && bi->profile->verify_fn != NULL &&\r\n(bi->flags & BLK_INTEGRITY_VERIFY))\r\nreturn true;\r\nif (bio_data_dir(bio) == WRITE && bi->profile->generate_fn != NULL &&\r\n(bi->flags & BLK_INTEGRITY_GENERATE))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline unsigned int bio_integrity_intervals(struct blk_integrity *bi,\r\nunsigned int sectors)\r\n{\r\nreturn sectors >> (bi->interval_exp - 9);\r\n}\r\nstatic inline unsigned int bio_integrity_bytes(struct blk_integrity *bi,\r\nunsigned int sectors)\r\n{\r\nreturn bio_integrity_intervals(bi, sectors) * bi->tuple_size;\r\n}\r\nstatic int bio_integrity_process(struct bio *bio,\r\nintegrity_processing_fn *proc_fn)\r\n{\r\nstruct blk_integrity *bi = bdev_get_integrity(bio->bi_bdev);\r\nstruct blk_integrity_iter iter;\r\nstruct bvec_iter bviter;\r\nstruct bio_vec bv;\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nunsigned int ret = 0;\r\nvoid *prot_buf = page_address(bip->bip_vec->bv_page) +\r\nbip->bip_vec->bv_offset;\r\niter.disk_name = bio->bi_bdev->bd_disk->disk_name;\r\niter.interval = 1 << bi->interval_exp;\r\niter.seed = bip_get_seed(bip);\r\niter.prot_buf = prot_buf;\r\nbio_for_each_segment(bv, bio, bviter) {\r\nvoid *kaddr = kmap_atomic(bv.bv_page);\r\niter.data_buf = kaddr + bv.bv_offset;\r\niter.data_size = bv.bv_len;\r\nret = proc_fn(&iter);\r\nif (ret) {\r\nkunmap_atomic(kaddr);\r\nreturn ret;\r\n}\r\nkunmap_atomic(kaddr);\r\n}\r\nreturn ret;\r\n}\r\nint bio_integrity_prep(struct bio *bio)\r\n{\r\nstruct bio_integrity_payload *bip;\r\nstruct blk_integrity *bi;\r\nstruct request_queue *q;\r\nvoid *buf;\r\nunsigned long start, end;\r\nunsigned int len, nr_pages;\r\nunsigned int bytes, offset, i;\r\nunsigned int intervals;\r\nbi = bdev_get_integrity(bio->bi_bdev);\r\nq = bdev_get_queue(bio->bi_bdev);\r\nBUG_ON(bi == NULL);\r\nBUG_ON(bio_integrity(bio));\r\nintervals = bio_integrity_intervals(bi, bio_sectors(bio));\r\nlen = intervals * bi->tuple_size;\r\nbuf = kmalloc(len, GFP_NOIO | q->bounce_gfp);\r\nif (unlikely(buf == NULL)) {\r\nprintk(KERN_ERR "could not allocate integrity buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nend = (((unsigned long) buf) + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstart = ((unsigned long) buf) >> PAGE_SHIFT;\r\nnr_pages = end - start;\r\nbip = bio_integrity_alloc(bio, GFP_NOIO, nr_pages);\r\nif (IS_ERR(bip)) {\r\nprintk(KERN_ERR "could not allocate data integrity bioset\n");\r\nkfree(buf);\r\nreturn PTR_ERR(bip);\r\n}\r\nbip->bip_flags |= BIP_BLOCK_INTEGRITY;\r\nbip->bip_iter.bi_size = len;\r\nbip_set_seed(bip, bio->bi_iter.bi_sector);\r\nif (bi->flags & BLK_INTEGRITY_IP_CHECKSUM)\r\nbip->bip_flags |= BIP_IP_CHECKSUM;\r\noffset = offset_in_page(buf);\r\nfor (i = 0 ; i < nr_pages ; i++) {\r\nint ret;\r\nbytes = PAGE_SIZE - offset;\r\nif (len <= 0)\r\nbreak;\r\nif (bytes > len)\r\nbytes = len;\r\nret = bio_integrity_add_page(bio, virt_to_page(buf),\r\nbytes, offset);\r\nif (ret == 0)\r\nreturn 0;\r\nif (ret < bytes)\r\nbreak;\r\nbuf += bytes;\r\nlen -= bytes;\r\noffset = 0;\r\n}\r\nif (bio_data_dir(bio) == READ) {\r\nbip->bip_end_io = bio->bi_end_io;\r\nbio->bi_end_io = bio_integrity_endio;\r\n}\r\nif (bio_data_dir(bio) == WRITE)\r\nbio_integrity_process(bio, bi->profile->generate_fn);\r\nreturn 0;\r\n}\r\nstatic void bio_integrity_verify_fn(struct work_struct *work)\r\n{\r\nstruct bio_integrity_payload *bip =\r\ncontainer_of(work, struct bio_integrity_payload, bip_work);\r\nstruct bio *bio = bip->bip_bio;\r\nstruct blk_integrity *bi = bdev_get_integrity(bio->bi_bdev);\r\nbio->bi_error = bio_integrity_process(bio, bi->profile->verify_fn);\r\nbio->bi_end_io = bip->bip_end_io;\r\nbio_endio(bio);\r\n}\r\nvoid bio_integrity_endio(struct bio *bio)\r\n{\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nBUG_ON(bip->bip_bio != bio);\r\nif (bio->bi_error) {\r\nbio->bi_end_io = bip->bip_end_io;\r\nbio_endio(bio);\r\nreturn;\r\n}\r\nINIT_WORK(&bip->bip_work, bio_integrity_verify_fn);\r\nqueue_work(kintegrityd_wq, &bip->bip_work);\r\n}\r\nvoid bio_integrity_advance(struct bio *bio, unsigned int bytes_done)\r\n{\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct blk_integrity *bi = bdev_get_integrity(bio->bi_bdev);\r\nunsigned bytes = bio_integrity_bytes(bi, bytes_done >> 9);\r\nbvec_iter_advance(bip->bip_vec, &bip->bip_iter, bytes);\r\n}\r\nvoid bio_integrity_trim(struct bio *bio, unsigned int offset,\r\nunsigned int sectors)\r\n{\r\nstruct bio_integrity_payload *bip = bio_integrity(bio);\r\nstruct blk_integrity *bi = bdev_get_integrity(bio->bi_bdev);\r\nbio_integrity_advance(bio, offset << 9);\r\nbip->bip_iter.bi_size = bio_integrity_bytes(bi, sectors);\r\n}\r\nint bio_integrity_clone(struct bio *bio, struct bio *bio_src,\r\ngfp_t gfp_mask)\r\n{\r\nstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\r\nstruct bio_integrity_payload *bip;\r\nBUG_ON(bip_src == NULL);\r\nbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\r\nif (IS_ERR(bip))\r\nreturn PTR_ERR(bip);\r\nmemcpy(bip->bip_vec, bip_src->bip_vec,\r\nbip_src->bip_vcnt * sizeof(struct bio_vec));\r\nbip->bip_vcnt = bip_src->bip_vcnt;\r\nbip->bip_iter = bip_src->bip_iter;\r\nreturn 0;\r\n}\r\nint bioset_integrity_create(struct bio_set *bs, int pool_size)\r\n{\r\nif (bs->bio_integrity_pool)\r\nreturn 0;\r\nbs->bio_integrity_pool = mempool_create_slab_pool(pool_size, bip_slab);\r\nif (!bs->bio_integrity_pool)\r\nreturn -1;\r\nbs->bvec_integrity_pool = biovec_create_pool(pool_size);\r\nif (!bs->bvec_integrity_pool) {\r\nmempool_destroy(bs->bio_integrity_pool);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid bioset_integrity_free(struct bio_set *bs)\r\n{\r\nif (bs->bio_integrity_pool)\r\nmempool_destroy(bs->bio_integrity_pool);\r\nif (bs->bvec_integrity_pool)\r\nmempool_destroy(bs->bvec_integrity_pool);\r\n}\r\nvoid __init bio_integrity_init(void)\r\n{\r\nkintegrityd_wq = alloc_workqueue("kintegrityd", WQ_MEM_RECLAIM |\r\nWQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);\r\nif (!kintegrityd_wq)\r\npanic("Failed to create kintegrityd\n");\r\nbip_slab = kmem_cache_create("bio_integrity_payload",\r\nsizeof(struct bio_integrity_payload) +\r\nsizeof(struct bio_vec) * BIP_INLINE_VECS,\r\n0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\r\n}
