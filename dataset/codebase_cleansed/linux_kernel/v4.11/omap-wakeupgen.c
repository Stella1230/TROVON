static inline u32 wakeupgen_readl(u8 idx, u32 cpu)\r\n{\r\nreturn readl_relaxed(wakeupgen_base + OMAP_WKG_ENB_A_0 +\r\n(cpu * CPU_ENA_OFFSET) + (idx * 4));\r\n}\r\nstatic inline void wakeupgen_writel(u32 val, u8 idx, u32 cpu)\r\n{\r\nwritel_relaxed(val, wakeupgen_base + OMAP_WKG_ENB_A_0 +\r\n(cpu * CPU_ENA_OFFSET) + (idx * 4));\r\n}\r\nstatic inline void sar_writel(u32 val, u32 offset, u8 idx)\r\n{\r\nwritel_relaxed(val, sar_base + offset + (idx * 4));\r\n}\r\nstatic inline int _wakeupgen_get_irq_info(u32 irq, u32 *bit_posn, u8 *reg_index)\r\n{\r\n*reg_index = irq >> 5;\r\n*bit_posn = irq %= 32;\r\nreturn 0;\r\n}\r\nstatic void _wakeupgen_clear(unsigned int irq, unsigned int cpu)\r\n{\r\nu32 val, bit_number;\r\nu8 i;\r\nif (_wakeupgen_get_irq_info(irq, &bit_number, &i))\r\nreturn;\r\nval = wakeupgen_readl(i, cpu);\r\nval &= ~BIT(bit_number);\r\nwakeupgen_writel(val, i, cpu);\r\n}\r\nstatic void _wakeupgen_set(unsigned int irq, unsigned int cpu)\r\n{\r\nu32 val, bit_number;\r\nu8 i;\r\nif (_wakeupgen_get_irq_info(irq, &bit_number, &i))\r\nreturn;\r\nval = wakeupgen_readl(i, cpu);\r\nval |= BIT(bit_number);\r\nwakeupgen_writel(val, i, cpu);\r\n}\r\nstatic void wakeupgen_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\n_wakeupgen_clear(d->hwirq, irq_target_cpu[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void wakeupgen_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\n_wakeupgen_set(d->hwirq, irq_target_cpu[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic void _wakeupgen_save_masks(unsigned int cpu)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nper_cpu(irqmasks, cpu)[i] = wakeupgen_readl(i, cpu);\r\n}\r\nstatic void _wakeupgen_restore_masks(unsigned int cpu)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nwakeupgen_writel(per_cpu(irqmasks, cpu)[i], i, cpu);\r\n}\r\nstatic void _wakeupgen_set_all(unsigned int cpu, unsigned int reg)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nwakeupgen_writel(reg, i, cpu);\r\n}\r\nstatic void wakeupgen_irqmask_all(unsigned int cpu, unsigned int set)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\nif (set) {\r\n_wakeupgen_save_masks(cpu);\r\n_wakeupgen_set_all(cpu, WKG_MASK_ALL);\r\n} else {\r\n_wakeupgen_set_all(cpu, WKG_UNMASK_ALL);\r\n_wakeupgen_restore_masks(cpu);\r\n}\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\n}\r\nstatic inline void omap4_irq_save_context(void)\r\n{\r\nu32 i, val;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn;\r\nfor (i = 0; i < irq_banks; i++) {\r\nval = wakeupgen_readl(i, 0);\r\nsar_writel(val, WAKEUPGENENB_OFFSET_CPU0, i);\r\nval = wakeupgen_readl(i, 1);\r\nsar_writel(val, WAKEUPGENENB_OFFSET_CPU1, i);\r\nsar_writel(0x0, WAKEUPGENENB_SECURE_OFFSET_CPU0, i);\r\nsar_writel(0x0, WAKEUPGENENB_SECURE_OFFSET_CPU1, i);\r\n}\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + AUXCOREBOOT0_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_1);\r\nwritel_relaxed(val, sar_base + AUXCOREBOOT1_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_PTMSYNCREQ_MASK);\r\nwritel_relaxed(val, sar_base + PTMSYNCREQ_MASK_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_PTMSYNCREQ_EN);\r\nwritel_relaxed(val, sar_base + PTMSYNCREQ_EN_OFFSET);\r\nval = readl_relaxed(sar_base + SAR_BACKUP_STATUS_OFFSET);\r\nval |= SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + SAR_BACKUP_STATUS_OFFSET);\r\n}\r\nstatic inline void omap5_irq_save_context(void)\r\n{\r\nu32 i, val;\r\nfor (i = 0; i < irq_banks; i++) {\r\nval = wakeupgen_readl(i, 0);\r\nsar_writel(val, OMAP5_WAKEUPGENENB_OFFSET_CPU0, i);\r\nval = wakeupgen_readl(i, 1);\r\nsar_writel(val, OMAP5_WAKEUPGENENB_OFFSET_CPU1, i);\r\nsar_writel(0x0, OMAP5_WAKEUPGENENB_SECURE_OFFSET_CPU0, i);\r\nsar_writel(0x0, OMAP5_WAKEUPGENENB_SECURE_OFFSET_CPU1, i);\r\n}\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + OMAP5_AUXCOREBOOT0_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + OMAP5_AUXCOREBOOT1_OFFSET);\r\nval = readl_relaxed(sar_base + OMAP5_SAR_BACKUP_STATUS_OFFSET);\r\nval |= SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + OMAP5_SAR_BACKUP_STATUS_OFFSET);\r\n}\r\nstatic void irq_save_context(void)\r\n{\r\nif (soc_is_dra7xx())\r\nreturn;\r\nif (!sar_base)\r\nsar_base = omap4_get_sar_ram_base();\r\nif (soc_is_omap54xx())\r\nomap5_irq_save_context();\r\nelse\r\nomap4_irq_save_context();\r\n}\r\nstatic void irq_sar_clear(void)\r\n{\r\nu32 val;\r\nu32 offset = SAR_BACKUP_STATUS_OFFSET;\r\nif (soc_is_dra7xx())\r\nreturn;\r\nif (soc_is_omap54xx())\r\noffset = OMAP5_SAR_BACKUP_STATUS_OFFSET;\r\nval = readl_relaxed(sar_base + offset);\r\nval &= ~SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + offset);\r\n}\r\nstatic void irq_save_secure_context(void)\r\n{\r\nu32 ret;\r\nret = omap_secure_dispatcher(OMAP4_HAL_SAVEGIC_INDEX,\r\nFLAG_START_CRITICAL,\r\n0, 0, 0, 0, 0);\r\nif (ret != API_HAL_RET_VALUE_OK)\r\npr_err("GIC and Wakeupgen context save failed\n");\r\n}\r\nstatic int omap_wakeupgen_cpu_online(unsigned int cpu)\r\n{\r\nwakeupgen_irqmask_all(cpu, 0);\r\nreturn 0;\r\n}\r\nstatic int omap_wakeupgen_cpu_dead(unsigned int cpu)\r\n{\r\nwakeupgen_irqmask_all(cpu, 1);\r\nreturn 0;\r\n}\r\nstatic void __init irq_hotplug_init(void)\r\n{\r\ncpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, "arm/omap-wake:online",\r\nomap_wakeupgen_cpu_online, NULL);\r\ncpuhp_setup_state_nocalls(CPUHP_ARM_OMAP_WAKE_DEAD,\r\n"arm/omap-wake:dead", NULL,\r\nomap_wakeupgen_cpu_dead);\r\n}\r\nstatic void __init irq_hotplug_init(void)\r\n{}\r\nstatic int irq_notifier(struct notifier_block *self, unsigned long cmd, void *v)\r\n{\r\nswitch (cmd) {\r\ncase CPU_CLUSTER_PM_ENTER:\r\nif (omap_type() == OMAP2_DEVICE_TYPE_GP)\r\nirq_save_context();\r\nelse\r\nirq_save_secure_context();\r\nbreak;\r\ncase CPU_CLUSTER_PM_EXIT:\r\nif (omap_type() == OMAP2_DEVICE_TYPE_GP)\r\nirq_sar_clear();\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init irq_pm_init(void)\r\n{\r\nif (!IS_PM44XX_ERRATUM(PM_OMAP4_CPU_OSWR_DISABLE))\r\ncpu_pm_register_notifier(&irq_notifier_block);\r\n}\r\nstatic void __init irq_pm_init(void)\r\n{}\r\nvoid __iomem *omap_get_wakeupgen_base(void)\r\n{\r\nreturn wakeupgen_base;\r\n}\r\nint omap_secure_apis_support(void)\r\n{\r\nreturn omap_secure_apis;\r\n}\r\nstatic int wakeupgen_domain_translate(struct irq_domain *d,\r\nstruct irq_fwspec *fwspec,\r\nunsigned long *hwirq,\r\nunsigned int *type)\r\n{\r\nif (is_of_node(fwspec->fwnode)) {\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\n*hwirq = fwspec->param[1];\r\n*type = fwspec->param[2];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int wakeupgen_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct irq_fwspec *fwspec = data;\r\nstruct irq_fwspec parent_fwspec;\r\nirq_hw_number_t hwirq;\r\nint i;\r\nif (fwspec->param_count != 3)\r\nreturn -EINVAL;\r\nif (fwspec->param[0] != 0)\r\nreturn -EINVAL;\r\nhwirq = fwspec->param[1];\r\nif (hwirq >= MAX_IRQS)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr_irqs; i++)\r\nirq_domain_set_hwirq_and_chip(domain, virq + i, hwirq + i,\r\n&wakeupgen_chip, NULL);\r\nparent_fwspec = *fwspec;\r\nparent_fwspec.fwnode = domain->parent->fwnode;\r\nreturn irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,\r\n&parent_fwspec);\r\n}\r\nstatic int __init wakeupgen_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct irq_domain *parent_domain, *domain;\r\nint i;\r\nunsigned int boot_cpu = smp_processor_id();\r\nu32 val;\r\nif (!parent) {\r\npr_err("%s: no parent, giving up\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nparent_domain = irq_find_host(parent);\r\nif (!parent_domain) {\r\npr_err("%s: unable to obtain parent domain\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\nif (omap_rev() == OMAP4430_REV_ES1_0) {\r\nWARN(1, "WakeupGen: Not supported on OMAP4430 ES1.0\n");\r\nreturn -EPERM;\r\n}\r\nwakeupgen_base = of_iomap(node, 0);\r\nif (WARN_ON(!wakeupgen_base))\r\nreturn -ENOMEM;\r\nif (cpu_is_omap44xx()) {\r\nirq_banks = OMAP4_NR_BANKS;\r\nmax_irqs = OMAP4_NR_IRQS;\r\nomap_secure_apis = 1;\r\n} else if (soc_is_am43xx()) {\r\nirq_banks = AM43XX_NR_REG_BANKS;\r\nmax_irqs = AM43XX_IRQS;\r\n}\r\ndomain = irq_domain_add_hierarchy(parent_domain, 0, max_irqs,\r\nnode, &wakeupgen_domain_ops,\r\nNULL);\r\nif (!domain) {\r\niounmap(wakeupgen_base);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < irq_banks; i++) {\r\nwakeupgen_writel(0, i, CPU0_ID);\r\nif (!soc_is_am43xx())\r\nwakeupgen_writel(0, i, CPU1_ID);\r\n}\r\nfor (i = 0; i < max_irqs; i++)\r\nirq_target_cpu[i] = boot_cpu;\r\nif (soc_is_omap54xx() || soc_is_dra7xx()) {\r\nval = __raw_readl(wakeupgen_base + OMAP_AMBA_IF_MODE);\r\nval |= BIT(5);\r\nomap_smc1(OMAP5_MON_AMBA_IF_INDEX, val);\r\n}\r\nirq_hotplug_init();\r\nirq_pm_init();\r\nreturn 0;\r\n}
