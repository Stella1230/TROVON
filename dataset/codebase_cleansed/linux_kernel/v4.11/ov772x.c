static struct ov772x_priv *to_ov772x(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ov772x_priv, subdev);\r\n}\r\nstatic inline int ov772x_read(struct i2c_client *client, u8 addr)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, addr);\r\n}\r\nstatic inline int ov772x_write(struct i2c_client *client, u8 addr, u8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, addr, value);\r\n}\r\nstatic int ov772x_mask_set(struct i2c_client *client, u8 command, u8 mask,\r\nu8 set)\r\n{\r\ns32 val = ov772x_read(client, command);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\nreturn ov772x_write(client, command, val);\r\n}\r\nstatic int ov772x_reset(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = ov772x_write(client, COM7, SCCB_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(1);\r\nreturn ov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, SOFT_SLEEP_MODE);\r\n}\r\nstatic int ov772x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov772x_priv *priv = to_ov772x(sd);\r\nif (!enable) {\r\nov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, SOFT_SLEEP_MODE);\r\nreturn 0;\r\n}\r\nov772x_mask_set(client, COM2, SOFT_SLEEP_MODE, 0);\r\ndev_dbg(&client->dev, "format %d, win %s\n",\r\npriv->cfmt->code, priv->win->name);\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov772x_priv *priv = container_of(ctrl->handler,\r\nstruct ov772x_priv, hdl);\r\nstruct v4l2_subdev *sd = &priv->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret = 0;\r\nu8 val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nval = ctrl->val ? VFLIP_IMG : 0x00;\r\npriv->flag_vflip = ctrl->val;\r\nif (priv->info->flags & OV772X_FLAG_VFLIP)\r\nval ^= VFLIP_IMG;\r\nreturn ov772x_mask_set(client, COM3, VFLIP_IMG, val);\r\ncase V4L2_CID_HFLIP:\r\nval = ctrl->val ? HFLIP_IMG : 0x00;\r\npriv->flag_hflip = ctrl->val;\r\nif (priv->info->flags & OV772X_FLAG_HFLIP)\r\nval ^= HFLIP_IMG;\r\nreturn ov772x_mask_set(client, COM3, HFLIP_IMG, val);\r\ncase V4L2_CID_BAND_STOP_FILTER:\r\nif (!ctrl->val) {\r\nret = ov772x_mask_set(client, BDBASE, 0xff, 0xff);\r\nif (!ret)\r\nret = ov772x_mask_set(client, COM8,\r\nBNDF_ON_OFF, 0);\r\n} else {\r\nval = 256 - ctrl->val;\r\nret = ov772x_mask_set(client, COM8,\r\nBNDF_ON_OFF, BNDF_ON_OFF);\r\nif (!ret)\r\nret = ov772x_mask_set(client, BDBASE,\r\n0xff, val);\r\n}\r\nif (!ret)\r\npriv->band_filter = ctrl->val;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov772x_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nreg->size = 1;\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nret = ov772x_read(client, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = (__u64)ret;\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff ||\r\nreg->val > 0xff)\r\nreturn -EINVAL;\r\nreturn ov772x_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov772x_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct ov772x_priv *priv = to_ov772x(sd);\r\nreturn soc_camera_set_power(&client->dev, ssdd, priv->clk, on);\r\n}\r\nstatic const struct ov772x_win_size *ov772x_select_win(u32 width, u32 height)\r\n{\r\nconst struct ov772x_win_size *win = &ov772x_win_sizes[0];\r\nu32 best_diff = UINT_MAX;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(ov772x_win_sizes); ++i) {\r\nu32 diff = abs(width - ov772x_win_sizes[i].rect.width)\r\n+ abs(height - ov772x_win_sizes[i].rect.height);\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nwin = &ov772x_win_sizes[i];\r\n}\r\n}\r\nreturn win;\r\n}\r\nstatic void ov772x_select_params(const struct v4l2_mbus_framefmt *mf,\r\nconst struct ov772x_color_format **cfmt,\r\nconst struct ov772x_win_size **win)\r\n{\r\nunsigned int i;\r\n*cfmt = &ov772x_cfmts[0];\r\nfor (i = 0; i < ARRAY_SIZE(ov772x_cfmts); i++) {\r\nif (mf->code == ov772x_cfmts[i].code) {\r\n*cfmt = &ov772x_cfmts[i];\r\nbreak;\r\n}\r\n}\r\n*win = ov772x_select_win(mf->width, mf->height);\r\n}\r\nstatic int ov772x_set_params(struct ov772x_priv *priv,\r\nconst struct ov772x_color_format *cfmt,\r\nconst struct ov772x_win_size *win)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\r\nint ret;\r\nu8 val;\r\nov772x_reset(client);\r\nif (priv->info->edgectrl.strength & OV772X_MANUAL_EDGE_CTRL) {\r\nret = ov772x_mask_set(client, DSPAUTO, EDGE_ACTRL, 0x00);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_TRSHLD, OV772X_EDGE_THRESHOLD_MASK,\r\npriv->info->edgectrl.threshold);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_STRNGT, OV772X_EDGE_STRENGTH_MASK,\r\npriv->info->edgectrl.strength);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n} else if (priv->info->edgectrl.upper > priv->info->edgectrl.lower) {\r\nret = ov772x_mask_set(client,\r\nEDGE_UPPER, OV772X_EDGE_UPPER_MASK,\r\npriv->info->edgectrl.upper);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_mask_set(client,\r\nEDGE_LOWER, OV772X_EDGE_LOWER_MASK,\r\npriv->info->edgectrl.lower);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nret = ov772x_write(client, HSTART, win->rect.left >> 2);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, HSIZE, win->rect.width >> 2);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, VSTART, win->rect.top >> 1);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, VSIZE, win->rect.height >> 1);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, HOUTSIZE, win->rect.width >> 2);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, VOUTSIZE, win->rect.height >> 1);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, HREF,\r\n((win->rect.top & 1) << HREF_VSTART_SHIFT) |\r\n((win->rect.left & 3) << HREF_HSTART_SHIFT) |\r\n((win->rect.height & 1) << HREF_VSIZE_SHIFT) |\r\n((win->rect.width & 3) << HREF_HSIZE_SHIFT));\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, EXHCH,\r\n((win->rect.height & 1) << EXHCH_VSIZE_SHIFT) |\r\n((win->rect.width & 3) << EXHCH_HSIZE_SHIFT));\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nval = cfmt->dsp3;\r\nif (val) {\r\nret = ov772x_mask_set(client,\r\nDSP_CTRL3, UV_MASK, val);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nif (cfmt->dsp4) {\r\nret = ov772x_write(client, DSP_CTRL4, cfmt->dsp4);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nval = cfmt->com3;\r\nif (priv->info->flags & OV772X_FLAG_VFLIP)\r\nval |= VFLIP_IMG;\r\nif (priv->info->flags & OV772X_FLAG_HFLIP)\r\nval |= HFLIP_IMG;\r\nif (priv->flag_vflip)\r\nval ^= VFLIP_IMG;\r\nif (priv->flag_hflip)\r\nval ^= HFLIP_IMG;\r\nret = ov772x_mask_set(client,\r\nCOM3, SWAP_MASK | IMG_MASK, val);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nret = ov772x_write(client, COM7, win->com7_bit | cfmt->com7);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\nif (priv->band_filter) {\r\nret = ov772x_mask_set(client, COM8, BNDF_ON_OFF, 1);\r\nif (!ret)\r\nret = ov772x_mask_set(client, BDBASE,\r\n0xff, 256 - priv->band_filter);\r\nif (ret < 0)\r\ngoto ov772x_set_fmt_error;\r\n}\r\nreturn ret;\r\nov772x_set_fmt_error:\r\nov772x_reset(client);\r\nreturn ret;\r\n}\r\nstatic int ov772x_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nsel->r.width = OV772X_MAX_WIDTH;\r\nsel->r.height = OV772X_MAX_HEIGHT;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r.width = VGA_WIDTH;\r\nsel->r.height = VGA_HEIGHT;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ov772x_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct ov772x_priv *priv = to_ov772x(sd);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->width = priv->win->rect.width;\r\nmf->height = priv->win->rect.height;\r\nmf->code = priv->cfmt->code;\r\nmf->colorspace = priv->cfmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int ov772x_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct ov772x_priv *priv = to_ov772x(sd);\r\nconst struct ov772x_color_format *cfmt;\r\nconst struct ov772x_win_size *win;\r\nint ret;\r\nov772x_select_params(mf, &cfmt, &win);\r\nret = ov772x_set_params(priv, cfmt, win);\r\nif (ret < 0)\r\nreturn ret;\r\npriv->win = win;\r\npriv->cfmt = cfmt;\r\nmf->code = cfmt->code;\r\nmf->width = win->rect.width;\r\nmf->height = win->rect.height;\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->colorspace = cfmt->colorspace;\r\nreturn 0;\r\n}\r\nstatic int ov772x_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nconst struct ov772x_color_format *cfmt;\r\nconst struct ov772x_win_size *win;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nov772x_select_params(mf, &cfmt, &win);\r\nmf->code = cfmt->code;\r\nmf->width = win->rect.width;\r\nmf->height = win->rect.height;\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->colorspace = cfmt->colorspace;\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn ov772x_s_fmt(sd, mf);\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nstatic int ov772x_video_probe(struct ov772x_priv *priv)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&priv->subdev);\r\nu8 pid, ver;\r\nconst char *devname;\r\nint ret;\r\nret = ov772x_s_power(&priv->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\npid = ov772x_read(client, PID);\r\nver = ov772x_read(client, VER);\r\nswitch (VERSION(pid, ver)) {\r\ncase OV7720:\r\ndevname = "ov7720";\r\nbreak;\r\ncase OV7725:\r\ndevname = "ov7725";\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"Product ID error %x:%x\n", pid, ver);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\ndev_info(&client->dev,\r\n"%s Product ID %0x:%0x Manufacturer ID %x:%x\n",\r\ndevname,\r\npid,\r\nver,\r\nov772x_read(client, MIDH),\r\nov772x_read(client, MIDL));\r\nret = v4l2_ctrl_handler_setup(&priv->hdl);\r\ndone:\r\nov772x_s_power(&priv->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int ov772x_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index >= ARRAY_SIZE(ov772x_cfmts))\r\nreturn -EINVAL;\r\ncode->code = ov772x_cfmts[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int ov772x_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov772x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov772x_priv *priv;\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint ret;\r\nif (!ssdd || !ssdd->drv_priv) {\r\ndev_err(&client->dev, "OV772X: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE_DATA\n");\r\nreturn -EIO;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->info = ssdd->drv_priv;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov772x_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 3);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov772x_ctrl_ops,\r\nV4L2_CID_BAND_STOP_FILTER, 0, 256, 1, 0);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error)\r\nreturn priv->hdl.error;\r\npriv->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ngoto eclkget;\r\n}\r\nret = ov772x_video_probe(priv);\r\nif (ret < 0) {\r\nv4l2_clk_put(priv->clk);\r\neclkget:\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\n} else {\r\npriv->cfmt = &ov772x_cfmts[0];\r\npriv->win = &ov772x_win_sizes[0];\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov772x_remove(struct i2c_client *client)\r\n{\r\nstruct ov772x_priv *priv = to_ov772x(i2c_get_clientdata(client));\r\nv4l2_clk_put(priv->clk);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nreturn 0;\r\n}
