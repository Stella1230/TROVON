bool ip_call_ra_chain(struct sk_buff *skb)\r\n{\r\nstruct ip_ra_chain *ra;\r\nu8 protocol = ip_hdr(skb)->protocol;\r\nstruct sock *last = NULL;\r\nstruct net_device *dev = skb->dev;\r\nstruct net *net = dev_net(dev);\r\nfor (ra = rcu_dereference(ip_ra_chain); ra; ra = rcu_dereference(ra->next)) {\r\nstruct sock *sk = ra->sk;\r\nif (sk && inet_sk(sk)->inet_num == protocol &&\r\n(!sk->sk_bound_dev_if ||\r\nsk->sk_bound_dev_if == dev->ifindex) &&\r\nnet_eq(sock_net(sk), net)) {\r\nif (ip_is_fragment(ip_hdr(skb))) {\r\nif (ip_defrag(net, skb, IP_DEFRAG_CALL_RA_CHAIN))\r\nreturn true;\r\n}\r\nif (last) {\r\nstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (skb2)\r\nraw_rcv(last, skb2);\r\n}\r\nlast = sk;\r\n}\r\n}\r\nif (last) {\r\nraw_rcv(last, skb);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\n__skb_pull(skb, skb_network_header_len(skb));\r\nrcu_read_lock();\r\n{\r\nint protocol = ip_hdr(skb)->protocol;\r\nconst struct net_protocol *ipprot;\r\nint raw;\r\nresubmit:\r\nraw = raw_local_deliver(skb, protocol);\r\nipprot = rcu_dereference(inet_protos[protocol]);\r\nif (ipprot) {\r\nint ret;\r\nif (!ipprot->no_policy) {\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nnf_reset(skb);\r\n}\r\nret = ipprot->handler(skb);\r\nif (ret < 0) {\r\nprotocol = -ret;\r\ngoto resubmit;\r\n}\r\n__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);\r\n} else {\r\nif (!raw) {\r\nif (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\n__IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS);\r\nicmp_send(skb, ICMP_DEST_UNREACH,\r\nICMP_PROT_UNREACH, 0);\r\n}\r\nkfree_skb(skb);\r\n} else {\r\n__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);\r\nconsume_skb(skb);\r\n}\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint ip_local_deliver(struct sk_buff *skb)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nif (ip_is_fragment(ip_hdr(skb))) {\r\nif (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))\r\nreturn 0;\r\n}\r\nreturn NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,\r\nnet, NULL, skb, skb->dev, NULL,\r\nip_local_deliver_finish);\r\n}\r\nstatic inline bool ip_rcv_options(struct sk_buff *skb)\r\n{\r\nstruct ip_options *opt;\r\nconst struct iphdr *iph;\r\nstruct net_device *dev = skb->dev;\r\nif (skb_cow(skb, skb_headroom(skb))) {\r\n__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\niph = ip_hdr(skb);\r\nopt = &(IPCB(skb)->opt);\r\nopt->optlen = iph->ihl*4 - sizeof(struct iphdr);\r\nif (ip_options_compile(dev_net(dev), opt, skb)) {\r\n__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\r\ngoto drop;\r\n}\r\nif (unlikely(opt->srr)) {\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nif (in_dev) {\r\nif (!IN_DEV_SOURCE_ROUTE(in_dev)) {\r\nif (IN_DEV_LOG_MARTIANS(in_dev))\r\nnet_info_ratelimited("source route option %pI4 -> %pI4\n",\r\n&iph->saddr,\r\n&iph->daddr);\r\ngoto drop;\r\n}\r\n}\r\nif (ip_options_rcv_srr(skb))\r\ngoto drop;\r\n}\r\nreturn false;\r\ndrop:\r\nreturn true;\r\n}\r\nstatic int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct rtable *rt;\r\nstruct net_device *dev = skb->dev;\r\nskb = l3mdev_ip_rcv(skb);\r\nif (!skb)\r\nreturn NET_RX_SUCCESS;\r\nif (net->ipv4.sysctl_ip_early_demux &&\r\n!skb_dst(skb) &&\r\n!skb->sk &&\r\n!ip_is_fragment(iph)) {\r\nconst struct net_protocol *ipprot;\r\nint protocol = iph->protocol;\r\nipprot = rcu_dereference(inet_protos[protocol]);\r\nif (ipprot && ipprot->early_demux) {\r\nipprot->early_demux(skb);\r\niph = ip_hdr(skb);\r\n}\r\n}\r\nif (!skb_valid_dst(skb)) {\r\nint err = ip_route_input_noref(skb, iph->daddr, iph->saddr,\r\niph->tos, dev);\r\nif (unlikely(err)) {\r\nif (err == -EXDEV)\r\n__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);\r\ngoto drop;\r\n}\r\n}\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\nif (unlikely(skb_dst(skb)->tclassid)) {\r\nstruct ip_rt_acct *st = this_cpu_ptr(ip_rt_acct);\r\nu32 idx = skb_dst(skb)->tclassid;\r\nst[idx&0xFF].o_packets++;\r\nst[idx&0xFF].o_bytes += skb->len;\r\nst[(idx>>16)&0xFF].i_packets++;\r\nst[(idx>>16)&0xFF].i_bytes += skb->len;\r\n}\r\n#endif\r\nif (iph->ihl > 5 && ip_rcv_options(skb))\r\ngoto drop;\r\nrt = skb_rtable(skb);\r\nif (rt->rt_type == RTN_MULTICAST) {\r\n__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb->len);\r\n} else if (rt->rt_type == RTN_BROADCAST) {\r\n__IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb->len);\r\n} else if (skb->pkt_type == PACKET_BROADCAST ||\r\nskb->pkt_type == PACKET_MULTICAST) {\r\nstruct in_device *in_dev = __in_dev_get_rcu(dev);\r\nif (in_dev &&\r\nIN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))\r\ngoto drop;\r\n}\r\nreturn dst_input(skb);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nconst struct iphdr *iph;\r\nstruct net *net;\r\nu32 len;\r\nif (skb->pkt_type == PACKET_OTHERHOST)\r\ngoto drop;\r\nnet = dev_net(dev);\r\n__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb->len);\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb) {\r\n__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\r\ngoto out;\r\n}\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nif (iph->ihl < 5 || iph->version != 4)\r\ngoto inhdr_error;\r\nBUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1);\r\nBUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0);\r\nBUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE);\r\n__IP_ADD_STATS(net,\r\nIPSTATS_MIB_NOECTPKTS + (iph->tos & INET_ECN_MASK),\r\nmax_t(unsigned short, 1, skb_shinfo(skb)->gso_segs));\r\nif (!pskb_may_pull(skb, iph->ihl*4))\r\ngoto inhdr_error;\r\niph = ip_hdr(skb);\r\nif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\r\ngoto csum_error;\r\nlen = ntohs(iph->tot_len);\r\nif (skb->len < len) {\r\n__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);\r\ngoto drop;\r\n} else if (len < (iph->ihl*4))\r\ngoto inhdr_error;\r\nif (pskb_trim_rcsum(skb, len)) {\r\n__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\r\ngoto drop;\r\n}\r\nskb->transport_header = skb->network_header + iph->ihl*4;\r\nmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\r\nIPCB(skb)->iif = skb->skb_iif;\r\nskb_orphan(skb);\r\nreturn NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\r\nnet, NULL, skb, dev, NULL,\r\nip_rcv_finish);\r\ncsum_error:\r\n__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);\r\ninhdr_error:\r\n__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);\r\ndrop:\r\nkfree_skb(skb);\r\nout:\r\nreturn NET_RX_DROP;\r\n}
