static irqreturn_t gvp11_intr(int irq, void *data)\r\n{\r\nstruct Scsi_Host *instance = data;\r\nstruct gvp11_hostdata *hdata = shost_priv(instance);\r\nunsigned int status = hdata->regs->CNTR;\r\nunsigned long flags;\r\nif (!(status & GVP11_DMAC_INT_PENDING))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nwd33c93_intr(instance);\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid gvp11_setup(char *str, int *ints)\r\n{\r\ngvp11_xfer_mask = ints[1];\r\n}\r\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct gvp11_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct gvp11_scsiregs *regs = hdata->regs;\r\nunsigned short cntr = GVP11_DMAC_INT_ENABLE;\r\nunsigned long addr = virt_to_bus(cmd->SCp.ptr);\r\nint bank_mask;\r\nstatic int scsi_alloc_out_of_range = 0;\r\nif (addr & wh->dma_xfer_mask) {\r\nwh->dma_bounce_len = (cmd->SCp.this_residual + 511) & ~0x1ff;\r\nif (!scsi_alloc_out_of_range) {\r\nwh->dma_bounce_buffer =\r\nkmalloc(wh->dma_bounce_len, GFP_KERNEL);\r\nwh->dma_buffer_pool = BUF_SCSI_ALLOCED;\r\n}\r\nif (scsi_alloc_out_of_range ||\r\n!wh->dma_bounce_buffer) {\r\nwh->dma_bounce_buffer =\r\namiga_chip_alloc(wh->dma_bounce_len,\r\n"GVP II SCSI Bounce Buffer");\r\nif (!wh->dma_bounce_buffer) {\r\nwh->dma_bounce_len = 0;\r\nreturn 1;\r\n}\r\nwh->dma_buffer_pool = BUF_CHIP_ALLOCED;\r\n}\r\naddr = virt_to_bus(wh->dma_bounce_buffer);\r\nif (addr & wh->dma_xfer_mask) {\r\nif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED) {\r\nkfree(wh->dma_bounce_buffer);\r\nscsi_alloc_out_of_range = 1;\r\n} else {\r\namiga_chip_free(wh->dma_bounce_buffer);\r\n}\r\nwh->dma_bounce_buffer =\r\namiga_chip_alloc(wh->dma_bounce_len,\r\n"GVP II SCSI Bounce Buffer");\r\nif (!wh->dma_bounce_buffer) {\r\nwh->dma_bounce_len = 0;\r\nreturn 1;\r\n}\r\naddr = virt_to_bus(wh->dma_bounce_buffer);\r\nwh->dma_buffer_pool = BUF_CHIP_ALLOCED;\r\n}\r\nif (!dir_in) {\r\nmemcpy(wh->dma_bounce_buffer, cmd->SCp.ptr,\r\ncmd->SCp.this_residual);\r\n}\r\n}\r\nif (!dir_in)\r\ncntr |= GVP11_DMAC_DIR_WRITE;\r\nwh->dma_dir = dir_in;\r\nregs->CNTR = cntr;\r\nregs->ACR = addr;\r\nif (dir_in) {\r\ncache_clear(addr, cmd->SCp.this_residual);\r\n} else {\r\ncache_push(addr, cmd->SCp.this_residual);\r\n}\r\nbank_mask = (~wh->dma_xfer_mask >> 18) & 0x01c0;\r\nif (bank_mask)\r\nregs->BANK = bank_mask & (addr >> 18);\r\nregs->ST_DMA = 1;\r\nreturn 0;\r\n}\r\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\r\nint status)\r\n{\r\nstruct gvp11_hostdata *hdata = shost_priv(instance);\r\nstruct WD33C93_hostdata *wh = &hdata->wh;\r\nstruct gvp11_scsiregs *regs = hdata->regs;\r\nregs->SP_DMA = 1;\r\nregs->CNTR = GVP11_DMAC_INT_ENABLE;\r\nif (status && wh->dma_bounce_buffer) {\r\nif (wh->dma_dir && SCpnt)\r\nmemcpy(SCpnt->SCp.ptr, wh->dma_bounce_buffer,\r\nSCpnt->SCp.this_residual);\r\nif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED)\r\nkfree(wh->dma_bounce_buffer);\r\nelse\r\namiga_chip_free(wh->dma_bounce_buffer);\r\nwh->dma_bounce_buffer = NULL;\r\nwh->dma_bounce_len = 0;\r\n}\r\n}\r\nstatic int gvp11_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nspin_lock_irq(instance->host_lock);\r\nwd33c93_host_reset(cmd);\r\nspin_unlock_irq(instance->host_lock);\r\nreturn SUCCESS;\r\n}\r\nstatic int check_wd33c93(struct gvp11_scsiregs *regs)\r\n{\r\n#ifdef CHECK_WD33C93\r\nvolatile unsigned char *sasr_3393, *scmd_3393;\r\nunsigned char save_sasr;\r\nunsigned char q, qq;\r\nsasr_3393 = &regs->SASR;\r\nscmd_3393 = &regs->SCMD;\r\nsave_sasr = *sasr_3393;\r\nq = *sasr_3393;\r\nif (q & 0x08)\r\nreturn -ENODEV;\r\n*sasr_3393 = WD_AUXILIARY_STATUS;\r\nif (*sasr_3393 == WD_AUXILIARY_STATUS) {\r\n*sasr_3393 = save_sasr;\r\nreturn -ENODEV;\r\n}\r\nif (*sasr_3393 != q) {\r\n*sasr_3393 = save_sasr;\r\nreturn -ENODEV;\r\n}\r\nif (*scmd_3393 != q)\r\nreturn -ENODEV;\r\n*sasr_3393 = WD_SCSI_STATUS;\r\nq = *scmd_3393;\r\n*sasr_3393 = WD_SCSI_STATUS;\r\n*scmd_3393 = ~q;\r\n*sasr_3393 = WD_SCSI_STATUS;\r\nqq = *scmd_3393;\r\n*sasr_3393 = WD_SCSI_STATUS;\r\n*scmd_3393 = q;\r\nif (qq != q)\r\nreturn -ENODEV;\r\n*sasr_3393 = 0x1e;\r\nq = *scmd_3393;\r\n*sasr_3393 = 0x1e;\r\n*scmd_3393 = ~q;\r\n*sasr_3393 = 0x1e;\r\nqq = *scmd_3393;\r\n*sasr_3393 = 0x1e;\r\n*scmd_3393 = q;\r\nif (qq != q || qq != 0xff)\r\nreturn -ENODEV;\r\n*sasr_3393 = WD_TIMEOUT_PERIOD;\r\nq = *scmd_3393;\r\n*sasr_3393 = WD_TIMEOUT_PERIOD;\r\n*scmd_3393 = ~q;\r\n*sasr_3393 = WD_TIMEOUT_PERIOD;\r\nqq = *scmd_3393;\r\n*sasr_3393 = WD_TIMEOUT_PERIOD;\r\n*scmd_3393 = q;\r\nif (qq != (~q & 0xff))\r\nreturn -ENODEV;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int gvp11_probe(struct zorro_dev *z, const struct zorro_device_id *ent)\r\n{\r\nstruct Scsi_Host *instance;\r\nunsigned long address;\r\nint error;\r\nunsigned int epc;\r\nunsigned int default_dma_xfer_mask;\r\nstruct gvp11_hostdata *hdata;\r\nstruct gvp11_scsiregs *regs;\r\nwd33c93_regs wdregs;\r\ndefault_dma_xfer_mask = ent->driver_data;\r\nif (zorro_resource_len(z) != 0x10000)\r\nreturn -ENODEV;\r\naddress = z->resource.start;\r\nif (!request_mem_region(address, 256, "wd33c93"))\r\nreturn -EBUSY;\r\nregs = ZTWO_VADDR(address);\r\nerror = check_wd33c93(regs);\r\nif (error)\r\ngoto fail_check_or_alloc;\r\ninstance = scsi_host_alloc(&gvp11_scsi_template,\r\nsizeof(struct gvp11_hostdata));\r\nif (!instance) {\r\nerror = -ENOMEM;\r\ngoto fail_check_or_alloc;\r\n}\r\ninstance->irq = IRQ_AMIGA_PORTS;\r\ninstance->unique_id = z->slotaddr;\r\nregs->secret2 = 1;\r\nregs->secret1 = 0;\r\nregs->secret3 = 15;\r\nwhile (regs->CNTR & GVP11_DMAC_BUSY)\r\n;\r\nregs->CNTR = 0;\r\nregs->BANK = 0;\r\nwdregs.SASR = &regs->SASR;\r\nwdregs.SCMD = &regs->SCMD;\r\nhdata = shost_priv(instance);\r\nif (gvp11_xfer_mask)\r\nhdata->wh.dma_xfer_mask = gvp11_xfer_mask;\r\nelse\r\nhdata->wh.dma_xfer_mask = default_dma_xfer_mask;\r\nhdata->wh.no_sync = 0xff;\r\nhdata->wh.fast = 0;\r\nhdata->wh.dma_mode = CTRL_DMA;\r\nhdata->regs = regs;\r\nepc = *(unsigned short *)(ZTWO_VADDR(address) + 0x8000);\r\nwd33c93_init(instance, wdregs, dma_setup, dma_stop,\r\n(epc & GVP_SCSICLKMASK) ? WD33C93_FS_8_10\r\n: WD33C93_FS_12_15);\r\nerror = request_irq(IRQ_AMIGA_PORTS, gvp11_intr, IRQF_SHARED,\r\n"GVP11 SCSI", instance);\r\nif (error)\r\ngoto fail_irq;\r\nregs->CNTR = GVP11_DMAC_INT_ENABLE;\r\nerror = scsi_add_host(instance, NULL);\r\nif (error)\r\ngoto fail_host;\r\nzorro_set_drvdata(z, instance);\r\nscsi_scan_host(instance);\r\nreturn 0;\r\nfail_host:\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nfail_irq:\r\nscsi_host_put(instance);\r\nfail_check_or_alloc:\r\nrelease_mem_region(address, 256);\r\nreturn error;\r\n}\r\nstatic void gvp11_remove(struct zorro_dev *z)\r\n{\r\nstruct Scsi_Host *instance = zorro_get_drvdata(z);\r\nstruct gvp11_hostdata *hdata = shost_priv(instance);\r\nhdata->regs->CNTR = 0;\r\nscsi_remove_host(instance);\r\nfree_irq(IRQ_AMIGA_PORTS, instance);\r\nscsi_host_put(instance);\r\nrelease_mem_region(z->resource.start, 256);\r\n}\r\nstatic int __init gvp11_init(void)\r\n{\r\nreturn zorro_register_driver(&gvp11_driver);\r\n}\r\nstatic void __exit gvp11_exit(void)\r\n{\r\nzorro_unregister_driver(&gvp11_driver);\r\n}
