static int max1586_v3_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nreturn max1586->v3_curr_sel;\r\n}\r\nstatic int max1586_v3_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = max1586->client;\r\nint ret;\r\nu8 v3_prog;\r\ndev_dbg(&client->dev, "changing voltage v3 to %dmv\n",\r\nregulator_list_voltage_linear(rdev, selector) / 1000);\r\nv3_prog = I2C_V3_SELECT | (u8) selector;\r\nret = i2c_smbus_write_byte(client, v3_prog);\r\nif (ret)\r\nreturn ret;\r\nmax1586->v3_curr_sel = selector;\r\nreturn 0;\r\n}\r\nstatic int max1586_v6_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nreturn max1586->v6_curr_sel;\r\n}\r\nstatic int max1586_v6_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct max1586_data *max1586 = rdev_get_drvdata(rdev);\r\nstruct i2c_client *client = max1586->client;\r\nu8 v6_prog;\r\nint ret;\r\ndev_dbg(&client->dev, "changing voltage v6 to %dmv\n",\r\nrdev->desc->volt_table[selector] / 1000);\r\nv6_prog = I2C_V6_SELECT | (u8) selector;\r\nret = i2c_smbus_write_byte(client, v6_prog);\r\nif (ret)\r\nreturn ret;\r\nmax1586->v6_curr_sel = selector;\r\nreturn 0;\r\n}\r\nstatic int of_get_max1586_platform_data(struct device *dev,\r\nstruct max1586_platform_data *pdata)\r\n{\r\nstruct max1586_subdev_data *sub;\r\nstruct of_regulator_match rmatch[ARRAY_SIZE(max1586_reg)] = { };\r\nstruct device_node *np = dev->of_node;\r\nint i, matched;\r\nif (of_property_read_u32(np, "v3-gain",\r\n&pdata->v3_gain) < 0) {\r\ndev_err(dev, "%s has no 'v3-gain' property\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nnp = of_get_child_by_name(np, "regulators");\r\nif (!np) {\r\ndev_err(dev, "missing 'regulators' subnode in DT\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rmatch); i++)\r\nrmatch[i].name = max1586_reg[i].name;\r\nmatched = of_regulator_match(dev, np, rmatch, ARRAY_SIZE(rmatch));\r\nof_node_put(np);\r\nif (matched <= 0)\r\nreturn matched;\r\npdata->subdevs = devm_kzalloc(dev, sizeof(struct max1586_subdev_data) *\r\nmatched, GFP_KERNEL);\r\nif (!pdata->subdevs)\r\nreturn -ENOMEM;\r\npdata->num_subdevs = matched;\r\nsub = pdata->subdevs;\r\nfor (i = 0; i < matched; i++) {\r\nsub->id = i;\r\nsub->name = rmatch[i].of_node->name;\r\nsub->platform_data = rmatch[i].init_data;\r\nsub++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max1586_pmic_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct max1586_platform_data *pdata, pdata_of;\r\nstruct regulator_config config = { };\r\nstruct max1586_data *max1586;\r\nint i, id, ret;\r\nconst struct of_device_id *match;\r\npdata = dev_get_platdata(&client->dev);\r\nif (client->dev.of_node && !pdata) {\r\nmatch = of_match_device(of_match_ptr(max1586_of_match),\r\n&client->dev);\r\nif (!match) {\r\ndev_err(&client->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_get_max1586_platform_data(&client->dev, &pdata_of);\r\nif (ret < 0)\r\nreturn ret;\r\npdata = &pdata_of;\r\n}\r\nmax1586 = devm_kzalloc(&client->dev, sizeof(struct max1586_data),\r\nGFP_KERNEL);\r\nif (!max1586)\r\nreturn -ENOMEM;\r\nmax1586->client = client;\r\nif (!pdata->v3_gain)\r\nreturn -EINVAL;\r\nmax1586->min_uV = MAX1586_V3_MIN_UV / 1000 * pdata->v3_gain / 1000;\r\nmax1586->max_uV = MAX1586_V3_MAX_UV / 1000 * pdata->v3_gain / 1000;\r\nmax1586->v3_curr_sel = 24;\r\nmax1586->v6_curr_sel = 0;\r\nfor (i = 0; i < pdata->num_subdevs && i <= MAX1586_V6; i++) {\r\nstruct regulator_dev *rdev;\r\nid = pdata->subdevs[i].id;\r\nif (!pdata->subdevs[i].platform_data)\r\ncontinue;\r\nif (id < MAX1586_V3 || id > MAX1586_V6) {\r\ndev_err(&client->dev, "invalid regulator id %d\n", id);\r\nreturn -EINVAL;\r\n}\r\nif (id == MAX1586_V3) {\r\nmax1586_reg[id].min_uV = max1586->min_uV;\r\nmax1586_reg[id].uV_step =\r\n(max1586->max_uV - max1586->min_uV) /\r\nMAX1586_V3_MAX_VSEL;\r\n}\r\nconfig.dev = &client->dev;\r\nconfig.init_data = pdata->subdevs[i].platform_data;\r\nconfig.driver_data = max1586;\r\nrdev = devm_regulator_register(&client->dev,\r\n&max1586_reg[id], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&client->dev, "failed to register %s\n",\r\nmax1586_reg[id].name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\ni2c_set_clientdata(client, max1586);\r\ndev_info(&client->dev, "Maxim 1586 regulator driver loaded\n");\r\nreturn 0;\r\n}\r\nstatic int __init max1586_pmic_init(void)\r\n{\r\nreturn i2c_add_driver(&max1586_pmic_driver);\r\n}\r\nstatic void __exit max1586_pmic_exit(void)\r\n{\r\ni2c_del_driver(&max1586_pmic_driver);\r\n}
