static void rcpm_v1_irq_mask(int cpu)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nsetbits32(&rcpm_v1_regs->cpmimr, mask);\r\nsetbits32(&rcpm_v1_regs->cpmcimr, mask);\r\nsetbits32(&rcpm_v1_regs->cpmmcmr, mask);\r\nsetbits32(&rcpm_v1_regs->cpmnmimr, mask);\r\n}\r\nstatic void rcpm_v2_irq_mask(int cpu)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nsetbits32(&rcpm_v2_regs->tpmimr0, mask);\r\nsetbits32(&rcpm_v2_regs->tpmcimr0, mask);\r\nsetbits32(&rcpm_v2_regs->tpmmcmr0, mask);\r\nsetbits32(&rcpm_v2_regs->tpmnmimr0, mask);\r\n}\r\nstatic void rcpm_v1_irq_unmask(int cpu)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nclrbits32(&rcpm_v1_regs->cpmimr, mask);\r\nclrbits32(&rcpm_v1_regs->cpmcimr, mask);\r\nclrbits32(&rcpm_v1_regs->cpmmcmr, mask);\r\nclrbits32(&rcpm_v1_regs->cpmnmimr, mask);\r\n}\r\nstatic void rcpm_v2_irq_unmask(int cpu)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nclrbits32(&rcpm_v2_regs->tpmimr0, mask);\r\nclrbits32(&rcpm_v2_regs->tpmcimr0, mask);\r\nclrbits32(&rcpm_v2_regs->tpmmcmr0, mask);\r\nclrbits32(&rcpm_v2_regs->tpmnmimr0, mask);\r\n}\r\nstatic void rcpm_v1_set_ip_power(bool enable, u32 mask)\r\n{\r\nif (enable)\r\nsetbits32(&rcpm_v1_regs->ippdexpcr, mask);\r\nelse\r\nclrbits32(&rcpm_v1_regs->ippdexpcr, mask);\r\n}\r\nstatic void rcpm_v2_set_ip_power(bool enable, u32 mask)\r\n{\r\nif (enable)\r\nsetbits32(&rcpm_v2_regs->ippdexpcr[0], mask);\r\nelse\r\nclrbits32(&rcpm_v2_regs->ippdexpcr[0], mask);\r\n}\r\nstatic void rcpm_v1_cpu_enter_state(int cpu, int state)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nswitch (state) {\r\ncase E500_PM_PH10:\r\nsetbits32(&rcpm_v1_regs->cdozcr, mask);\r\nbreak;\r\ncase E500_PM_PH15:\r\nsetbits32(&rcpm_v1_regs->cnapcr, mask);\r\nbreak;\r\ndefault:\r\npr_warn("Unknown cpu PM state (%d)\n", state);\r\nbreak;\r\n}\r\n}\r\nstatic void rcpm_v2_cpu_enter_state(int cpu, int state)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nu32 mask = 1 << cpu_core_index_of_thread(cpu);\r\nswitch (state) {\r\ncase E500_PM_PH10:\r\nsetbits32(&rcpm_v2_regs->tph10setr0, 1 << hw_cpu);\r\nbreak;\r\ncase E500_PM_PH15:\r\nsetbits32(&rcpm_v2_regs->pcph15setr, mask);\r\nbreak;\r\ncase E500_PM_PH20:\r\nsetbits32(&rcpm_v2_regs->pcph20setr, mask);\r\nbreak;\r\ncase E500_PM_PH30:\r\nsetbits32(&rcpm_v2_regs->pcph30setr, mask);\r\nbreak;\r\ndefault:\r\npr_warn("Unknown cpu PM state (%d)\n", state);\r\n}\r\n}\r\nstatic void rcpm_v1_cpu_die(int cpu)\r\n{\r\nrcpm_v1_cpu_enter_state(cpu, E500_PM_PH15);\r\n}\r\nstatic void qoriq_disable_thread(int cpu)\r\n{\r\nint thread = cpu_thread_in_core(cpu);\r\nbook3e_stop_thread(thread);\r\n}\r\nstatic void rcpm_v2_cpu_die(int cpu)\r\n{\r\n#ifdef CONFIG_PPC64\r\nint primary;\r\nif (threads_per_core == 2) {\r\nprimary = cpu_first_thread_sibling(cpu);\r\nif (cpu_is_offline(primary) && cpu_is_offline(primary + 1)) {\r\nrcpm_v2_cpu_enter_state(cpu, E500_PM_PH20);\r\n} else {\r\nqoriq_disable_thread(cpu);\r\n}\r\n}\r\n#endif\r\nif (threads_per_core == 1)\r\nrcpm_v2_cpu_enter_state(cpu, E500_PM_PH20);\r\n}\r\nstatic void rcpm_v1_cpu_exit_state(int cpu, int state)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nunsigned int mask = 1 << hw_cpu;\r\nswitch (state) {\r\ncase E500_PM_PH10:\r\nclrbits32(&rcpm_v1_regs->cdozcr, mask);\r\nbreak;\r\ncase E500_PM_PH15:\r\nclrbits32(&rcpm_v1_regs->cnapcr, mask);\r\nbreak;\r\ndefault:\r\npr_warn("Unknown cpu PM state (%d)\n", state);\r\nbreak;\r\n}\r\n}\r\nstatic void rcpm_v1_cpu_up_prepare(int cpu)\r\n{\r\nrcpm_v1_cpu_exit_state(cpu, E500_PM_PH15);\r\nrcpm_v1_irq_unmask(cpu);\r\n}\r\nstatic void rcpm_v2_cpu_exit_state(int cpu, int state)\r\n{\r\nint hw_cpu = get_hard_smp_processor_id(cpu);\r\nu32 mask = 1 << cpu_core_index_of_thread(cpu);\r\nswitch (state) {\r\ncase E500_PM_PH10:\r\nsetbits32(&rcpm_v2_regs->tph10clrr0, 1 << hw_cpu);\r\nbreak;\r\ncase E500_PM_PH15:\r\nsetbits32(&rcpm_v2_regs->pcph15clrr, mask);\r\nbreak;\r\ncase E500_PM_PH20:\r\nsetbits32(&rcpm_v2_regs->pcph20clrr, mask);\r\nbreak;\r\ncase E500_PM_PH30:\r\nsetbits32(&rcpm_v2_regs->pcph30clrr, mask);\r\nbreak;\r\ndefault:\r\npr_warn("Unknown cpu PM state (%d)\n", state);\r\n}\r\n}\r\nstatic void rcpm_v2_cpu_up_prepare(int cpu)\r\n{\r\nrcpm_v2_cpu_exit_state(cpu, E500_PM_PH20);\r\nrcpm_v2_irq_unmask(cpu);\r\n}\r\nstatic int rcpm_v1_plat_enter_state(int state)\r\n{\r\nu32 *pmcsr_reg = &rcpm_v1_regs->powmgtcsr;\r\nint ret = 0;\r\nint result;\r\nswitch (state) {\r\ncase PLAT_PM_SLEEP:\r\nsetbits32(pmcsr_reg, RCPM_POWMGTCSR_SLP);\r\nresult = spin_event_timeout(\r\n!(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_SLP), 10000, 10);\r\nif (!result) {\r\npr_err("timeout waiting for SLP bit to be cleared\n");\r\nret = -ETIMEDOUT;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Unknown platform PM state (%d)", state);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rcpm_v2_plat_enter_state(int state)\r\n{\r\nu32 *pmcsr_reg = &rcpm_v2_regs->powmgtcsr;\r\nint ret = 0;\r\nint result;\r\nswitch (state) {\r\ncase PLAT_PM_LPM20:\r\nsetbits32(pmcsr_reg, RCPM_POWMGTCSR_P_LPM20_ST);\r\nsetbits32(pmcsr_reg, RCPM_POWMGTCSR_LPM20_RQ);\r\nresult = spin_event_timeout(\r\n!(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_LPM20_ST), 10000, 10);\r\nif (!result) {\r\npr_err("timeout waiting for LPM20 bit to be cleared\n");\r\nret = -ETIMEDOUT;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Unknown platform PM state (%d)\n", state);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rcpm_v1_plat_enter_sleep(void)\r\n{\r\nreturn rcpm_v1_plat_enter_state(PLAT_PM_SLEEP);\r\n}\r\nstatic int rcpm_v2_plat_enter_sleep(void)\r\n{\r\nreturn rcpm_v2_plat_enter_state(PLAT_PM_LPM20);\r\n}\r\nstatic void rcpm_common_freeze_time_base(u32 *tben_reg, int freeze)\r\n{\r\nstatic u32 mask;\r\nif (freeze) {\r\nmask = in_be32(tben_reg);\r\nclrbits32(tben_reg, mask);\r\n} else {\r\nsetbits32(tben_reg, mask);\r\n}\r\nin_be32(tben_reg);\r\n}\r\nstatic void rcpm_v1_freeze_time_base(bool freeze)\r\n{\r\nrcpm_common_freeze_time_base(&rcpm_v1_regs->ctbenr, freeze);\r\n}\r\nstatic void rcpm_v2_freeze_time_base(bool freeze)\r\n{\r\nrcpm_common_freeze_time_base(&rcpm_v2_regs->pctbenr, freeze);\r\n}\r\nstatic unsigned int rcpm_get_pm_modes(void)\r\n{\r\nreturn fsl_supported_pm_modes;\r\n}\r\nint __init fsl_rcpm_init(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nvoid __iomem *base;\r\nnp = of_find_matching_node_and_match(NULL, rcpm_matches, &match);\r\nif (!np)\r\nreturn 0;\r\nbase = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!base) {\r\npr_err("of_iomap() error.\n");\r\nreturn -ENOMEM;\r\n}\r\nrcpm_v1_regs = base;\r\nrcpm_v2_regs = base;\r\nfsl_supported_pm_modes = FSL_PM_SLEEP;\r\nqoriq_pm_ops = match->data;\r\nreturn 0;\r\n}
