static unsigned long sh_cmt_read16(void __iomem *base, unsigned long offs)\r\n{\r\nreturn ioread16(base + (offs << 1));\r\n}\r\nstatic unsigned long sh_cmt_read32(void __iomem *base, unsigned long offs)\r\n{\r\nreturn ioread32(base + (offs << 2));\r\n}\r\nstatic void sh_cmt_write16(void __iomem *base, unsigned long offs,\r\nunsigned long value)\r\n{\r\niowrite16(value, base + (offs << 1));\r\n}\r\nstatic void sh_cmt_write32(void __iomem *base, unsigned long offs,\r\nunsigned long value)\r\n{\r\niowrite32(value, base + (offs << 2));\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmstr(struct sh_cmt_channel *ch)\r\n{\r\nif (ch->iostart)\r\nreturn ch->cmt->info->read_control(ch->iostart, 0);\r\nelse\r\nreturn ch->cmt->info->read_control(ch->cmt->mapbase, 0);\r\n}\r\nstatic inline void sh_cmt_write_cmstr(struct sh_cmt_channel *ch,\r\nunsigned long value)\r\n{\r\nif (ch->iostart)\r\nch->cmt->info->write_control(ch->iostart, 0, value);\r\nelse\r\nch->cmt->info->write_control(ch->cmt->mapbase, 0, value);\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmcsr(struct sh_cmt_channel *ch)\r\n{\r\nreturn ch->cmt->info->read_control(ch->ioctrl, CMCSR);\r\n}\r\nstatic inline void sh_cmt_write_cmcsr(struct sh_cmt_channel *ch,\r\nunsigned long value)\r\n{\r\nch->cmt->info->write_control(ch->ioctrl, CMCSR, value);\r\n}\r\nstatic inline unsigned long sh_cmt_read_cmcnt(struct sh_cmt_channel *ch)\r\n{\r\nreturn ch->cmt->info->read_count(ch->ioctrl, CMCNT);\r\n}\r\nstatic inline void sh_cmt_write_cmcnt(struct sh_cmt_channel *ch,\r\nunsigned long value)\r\n{\r\nch->cmt->info->write_count(ch->ioctrl, CMCNT, value);\r\n}\r\nstatic inline void sh_cmt_write_cmcor(struct sh_cmt_channel *ch,\r\nunsigned long value)\r\n{\r\nch->cmt->info->write_count(ch->ioctrl, CMCOR, value);\r\n}\r\nstatic unsigned long sh_cmt_get_counter(struct sh_cmt_channel *ch,\r\nint *has_wrapped)\r\n{\r\nunsigned long v1, v2, v3;\r\nint o1, o2;\r\no1 = sh_cmt_read_cmcsr(ch) & ch->cmt->info->overflow_bit;\r\ndo {\r\no2 = o1;\r\nv1 = sh_cmt_read_cmcnt(ch);\r\nv2 = sh_cmt_read_cmcnt(ch);\r\nv3 = sh_cmt_read_cmcnt(ch);\r\no1 = sh_cmt_read_cmcsr(ch) & ch->cmt->info->overflow_bit;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\n*has_wrapped = o1;\r\nreturn v2;\r\n}\r\nstatic void sh_cmt_start_stop_ch(struct sh_cmt_channel *ch, int start)\r\n{\r\nunsigned long flags, value;\r\nraw_spin_lock_irqsave(&ch->cmt->lock, flags);\r\nvalue = sh_cmt_read_cmstr(ch);\r\nif (start)\r\nvalue |= 1 << ch->timer_bit;\r\nelse\r\nvalue &= ~(1 << ch->timer_bit);\r\nsh_cmt_write_cmstr(ch, value);\r\nraw_spin_unlock_irqrestore(&ch->cmt->lock, flags);\r\n}\r\nstatic int sh_cmt_enable(struct sh_cmt_channel *ch, unsigned long *rate)\r\n{\r\nint k, ret;\r\npm_runtime_get_sync(&ch->cmt->pdev->dev);\r\ndev_pm_syscore_device(&ch->cmt->pdev->dev, true);\r\nret = clk_enable(ch->cmt->clk);\r\nif (ret) {\r\ndev_err(&ch->cmt->pdev->dev, "ch%u: cannot enable clock\n",\r\nch->index);\r\ngoto err0;\r\n}\r\nsh_cmt_start_stop_ch(ch, 0);\r\nif (ch->cmt->info->width == 16) {\r\n*rate = clk_get_rate(ch->cmt->clk) / 512;\r\nsh_cmt_write_cmcsr(ch, SH_CMT16_CMCSR_CMIE |\r\nSH_CMT16_CMCSR_CKS512);\r\n} else {\r\n*rate = clk_get_rate(ch->cmt->clk) / 8;\r\nsh_cmt_write_cmcsr(ch, SH_CMT32_CMCSR_CMM |\r\nSH_CMT32_CMCSR_CMTOUT_IE |\r\nSH_CMT32_CMCSR_CMR_IRQ |\r\nSH_CMT32_CMCSR_CKS_RCLK8);\r\n}\r\nsh_cmt_write_cmcor(ch, 0xffffffff);\r\nsh_cmt_write_cmcnt(ch, 0);\r\nfor (k = 0; k < 100; k++) {\r\nif (!sh_cmt_read_cmcnt(ch))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (sh_cmt_read_cmcnt(ch)) {\r\ndev_err(&ch->cmt->pdev->dev, "ch%u: cannot clear CMCNT\n",\r\nch->index);\r\nret = -ETIMEDOUT;\r\ngoto err1;\r\n}\r\nsh_cmt_start_stop_ch(ch, 1);\r\nreturn 0;\r\nerr1:\r\nclk_disable(ch->cmt->clk);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_disable(struct sh_cmt_channel *ch)\r\n{\r\nsh_cmt_start_stop_ch(ch, 0);\r\nsh_cmt_write_cmcsr(ch, 0);\r\nclk_disable(ch->cmt->clk);\r\ndev_pm_syscore_device(&ch->cmt->pdev->dev, false);\r\npm_runtime_put(&ch->cmt->pdev->dev);\r\n}\r\nstatic void sh_cmt_clock_event_program_verify(struct sh_cmt_channel *ch,\r\nint absolute)\r\n{\r\nunsigned long new_match;\r\nunsigned long value = ch->next_match_value;\r\nunsigned long delay = 0;\r\nunsigned long now = 0;\r\nint has_wrapped;\r\nnow = sh_cmt_get_counter(ch, &has_wrapped);\r\nch->flags |= FLAG_REPROGRAM;\r\nif (has_wrapped) {\r\nch->flags |= FLAG_SKIPEVENT;\r\nreturn;\r\n}\r\nif (absolute)\r\nnow = 0;\r\ndo {\r\nnew_match = now + value + delay;\r\nif (new_match > ch->max_match_value)\r\nnew_match = ch->max_match_value;\r\nsh_cmt_write_cmcor(ch, new_match);\r\nnow = sh_cmt_get_counter(ch, &has_wrapped);\r\nif (has_wrapped && (new_match > ch->match_value)) {\r\nch->flags |= FLAG_SKIPEVENT;\r\nbreak;\r\n}\r\nif (has_wrapped) {\r\nch->match_value = new_match;\r\nbreak;\r\n}\r\nif (now < new_match) {\r\nch->match_value = new_match;\r\nbreak;\r\n}\r\nif (delay)\r\ndelay <<= 1;\r\nelse\r\ndelay = 1;\r\nif (!delay)\r\ndev_warn(&ch->cmt->pdev->dev, "ch%u: too long delay\n",\r\nch->index);\r\n} while (delay);\r\n}\r\nstatic void __sh_cmt_set_next(struct sh_cmt_channel *ch, unsigned long delta)\r\n{\r\nif (delta > ch->max_match_value)\r\ndev_warn(&ch->cmt->pdev->dev, "ch%u: delta out of range\n",\r\nch->index);\r\nch->next_match_value = delta;\r\nsh_cmt_clock_event_program_verify(ch, 0);\r\n}\r\nstatic void sh_cmt_set_next(struct sh_cmt_channel *ch, unsigned long delta)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ch->lock, flags);\r\n__sh_cmt_set_next(ch, delta);\r\nraw_spin_unlock_irqrestore(&ch->lock, flags);\r\n}\r\nstatic irqreturn_t sh_cmt_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sh_cmt_channel *ch = dev_id;\r\nsh_cmt_write_cmcsr(ch, sh_cmt_read_cmcsr(ch) &\r\nch->cmt->info->clear_bits);\r\nif (ch->flags & FLAG_CLOCKSOURCE)\r\nch->total_cycles += ch->match_value + 1;\r\nif (!(ch->flags & FLAG_REPROGRAM))\r\nch->next_match_value = ch->max_match_value;\r\nch->flags |= FLAG_IRQCONTEXT;\r\nif (ch->flags & FLAG_CLOCKEVENT) {\r\nif (!(ch->flags & FLAG_SKIPEVENT)) {\r\nif (clockevent_state_oneshot(&ch->ced)) {\r\nch->next_match_value = ch->max_match_value;\r\nch->flags |= FLAG_REPROGRAM;\r\n}\r\nch->ced.event_handler(&ch->ced);\r\n}\r\n}\r\nch->flags &= ~FLAG_SKIPEVENT;\r\nif (ch->flags & FLAG_REPROGRAM) {\r\nch->flags &= ~FLAG_REPROGRAM;\r\nsh_cmt_clock_event_program_verify(ch, 1);\r\nif (ch->flags & FLAG_CLOCKEVENT)\r\nif ((clockevent_state_shutdown(&ch->ced))\r\n|| (ch->match_value == ch->next_match_value))\r\nch->flags &= ~FLAG_REPROGRAM;\r\n}\r\nch->flags &= ~FLAG_IRQCONTEXT;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_cmt_start(struct sh_cmt_channel *ch, unsigned long flag)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ch->lock, flags);\r\nif (!(ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE)))\r\nret = sh_cmt_enable(ch, &ch->rate);\r\nif (ret)\r\ngoto out;\r\nch->flags |= flag;\r\nif ((flag == FLAG_CLOCKSOURCE) && (!(ch->flags & FLAG_CLOCKEVENT)))\r\n__sh_cmt_set_next(ch, ch->max_match_value);\r\nout:\r\nraw_spin_unlock_irqrestore(&ch->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_stop(struct sh_cmt_channel *ch, unsigned long flag)\r\n{\r\nunsigned long flags;\r\nunsigned long f;\r\nraw_spin_lock_irqsave(&ch->lock, flags);\r\nf = ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE);\r\nch->flags &= ~flag;\r\nif (f && !(ch->flags & (FLAG_CLOCKEVENT | FLAG_CLOCKSOURCE)))\r\nsh_cmt_disable(ch);\r\nif ((flag == FLAG_CLOCKEVENT) && (ch->flags & FLAG_CLOCKSOURCE))\r\n__sh_cmt_set_next(ch, ch->max_match_value);\r\nraw_spin_unlock_irqrestore(&ch->lock, flags);\r\n}\r\nstatic struct sh_cmt_channel *cs_to_sh_cmt(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct sh_cmt_channel, cs);\r\n}\r\nstatic u64 sh_cmt_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\r\nunsigned long flags, raw;\r\nunsigned long value;\r\nint has_wrapped;\r\nraw_spin_lock_irqsave(&ch->lock, flags);\r\nvalue = ch->total_cycles;\r\nraw = sh_cmt_get_counter(ch, &has_wrapped);\r\nif (unlikely(has_wrapped))\r\nraw += ch->match_value + 1;\r\nraw_spin_unlock_irqrestore(&ch->lock, flags);\r\nreturn value + raw;\r\n}\r\nstatic int sh_cmt_clocksource_enable(struct clocksource *cs)\r\n{\r\nint ret;\r\nstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\r\nWARN_ON(ch->cs_enabled);\r\nch->total_cycles = 0;\r\nret = sh_cmt_start(ch, FLAG_CLOCKSOURCE);\r\nif (!ret) {\r\n__clocksource_update_freq_hz(cs, ch->rate);\r\nch->cs_enabled = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sh_cmt_clocksource_disable(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\r\nWARN_ON(!ch->cs_enabled);\r\nsh_cmt_stop(ch, FLAG_CLOCKSOURCE);\r\nch->cs_enabled = false;\r\n}\r\nstatic void sh_cmt_clocksource_suspend(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\r\nif (!ch->cs_enabled)\r\nreturn;\r\nsh_cmt_stop(ch, FLAG_CLOCKSOURCE);\r\npm_genpd_syscore_poweroff(&ch->cmt->pdev->dev);\r\n}\r\nstatic void sh_cmt_clocksource_resume(struct clocksource *cs)\r\n{\r\nstruct sh_cmt_channel *ch = cs_to_sh_cmt(cs);\r\nif (!ch->cs_enabled)\r\nreturn;\r\npm_genpd_syscore_poweron(&ch->cmt->pdev->dev);\r\nsh_cmt_start(ch, FLAG_CLOCKSOURCE);\r\n}\r\nstatic int sh_cmt_register_clocksource(struct sh_cmt_channel *ch,\r\nconst char *name)\r\n{\r\nstruct clocksource *cs = &ch->cs;\r\ncs->name = name;\r\ncs->rating = 125;\r\ncs->read = sh_cmt_clocksource_read;\r\ncs->enable = sh_cmt_clocksource_enable;\r\ncs->disable = sh_cmt_clocksource_disable;\r\ncs->suspend = sh_cmt_clocksource_suspend;\r\ncs->resume = sh_cmt_clocksource_resume;\r\ncs->mask = CLOCKSOURCE_MASK(sizeof(unsigned long) * 8);\r\ncs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\ndev_info(&ch->cmt->pdev->dev, "ch%u: used as clock source\n",\r\nch->index);\r\nclocksource_register_hz(cs, 1);\r\nreturn 0;\r\n}\r\nstatic struct sh_cmt_channel *ced_to_sh_cmt(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct sh_cmt_channel, ced);\r\n}\r\nstatic void sh_cmt_clock_event_start(struct sh_cmt_channel *ch, int periodic)\r\n{\r\nstruct clock_event_device *ced = &ch->ced;\r\nsh_cmt_start(ch, FLAG_CLOCKEVENT);\r\nced->shift = 32;\r\nced->mult = div_sc(ch->rate, NSEC_PER_SEC, ced->shift);\r\nced->max_delta_ns = clockevent_delta2ns(ch->max_match_value, ced);\r\nced->min_delta_ns = clockevent_delta2ns(0x1f, ced);\r\nif (periodic)\r\nsh_cmt_set_next(ch, ((ch->rate + HZ/2) / HZ) - 1);\r\nelse\r\nsh_cmt_set_next(ch, ch->max_match_value);\r\n}\r\nstatic int sh_cmt_clock_event_shutdown(struct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\r\nsh_cmt_stop(ch, FLAG_CLOCKEVENT);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_clock_event_set_state(struct clock_event_device *ced,\r\nint periodic)\r\n{\r\nstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\r\nif (clockevent_state_oneshot(ced) || clockevent_state_periodic(ced))\r\nsh_cmt_stop(ch, FLAG_CLOCKEVENT);\r\ndev_info(&ch->cmt->pdev->dev, "ch%u: used for %s clock events\n",\r\nch->index, periodic ? "periodic" : "oneshot");\r\nsh_cmt_clock_event_start(ch, periodic);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_clock_event_set_oneshot(struct clock_event_device *ced)\r\n{\r\nreturn sh_cmt_clock_event_set_state(ced, 0);\r\n}\r\nstatic int sh_cmt_clock_event_set_periodic(struct clock_event_device *ced)\r\n{\r\nreturn sh_cmt_clock_event_set_state(ced, 1);\r\n}\r\nstatic int sh_cmt_clock_event_next(unsigned long delta,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\r\nBUG_ON(!clockevent_state_oneshot(ced));\r\nif (likely(ch->flags & FLAG_IRQCONTEXT))\r\nch->next_match_value = delta - 1;\r\nelse\r\nsh_cmt_set_next(ch, delta - 1);\r\nreturn 0;\r\n}\r\nstatic void sh_cmt_clock_event_suspend(struct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\r\npm_genpd_syscore_poweroff(&ch->cmt->pdev->dev);\r\nclk_unprepare(ch->cmt->clk);\r\n}\r\nstatic void sh_cmt_clock_event_resume(struct clock_event_device *ced)\r\n{\r\nstruct sh_cmt_channel *ch = ced_to_sh_cmt(ced);\r\nclk_prepare(ch->cmt->clk);\r\npm_genpd_syscore_poweron(&ch->cmt->pdev->dev);\r\n}\r\nstatic int sh_cmt_register_clockevent(struct sh_cmt_channel *ch,\r\nconst char *name)\r\n{\r\nstruct clock_event_device *ced = &ch->ced;\r\nint irq;\r\nint ret;\r\nirq = platform_get_irq(ch->cmt->pdev, ch->index);\r\nif (irq < 0) {\r\ndev_err(&ch->cmt->pdev->dev, "ch%u: failed to get irq\n",\r\nch->index);\r\nreturn irq;\r\n}\r\nret = request_irq(irq, sh_cmt_interrupt,\r\nIRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\r\ndev_name(&ch->cmt->pdev->dev), ch);\r\nif (ret) {\r\ndev_err(&ch->cmt->pdev->dev, "ch%u: failed to request irq %d\n",\r\nch->index, irq);\r\nreturn ret;\r\n}\r\nced->name = name;\r\nced->features = CLOCK_EVT_FEAT_PERIODIC;\r\nced->features |= CLOCK_EVT_FEAT_ONESHOT;\r\nced->rating = 125;\r\nced->cpumask = cpu_possible_mask;\r\nced->set_next_event = sh_cmt_clock_event_next;\r\nced->set_state_shutdown = sh_cmt_clock_event_shutdown;\r\nced->set_state_periodic = sh_cmt_clock_event_set_periodic;\r\nced->set_state_oneshot = sh_cmt_clock_event_set_oneshot;\r\nced->suspend = sh_cmt_clock_event_suspend;\r\nced->resume = sh_cmt_clock_event_resume;\r\ndev_info(&ch->cmt->pdev->dev, "ch%u: used for clock events\n",\r\nch->index);\r\nclockevents_register_device(ced);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_register(struct sh_cmt_channel *ch, const char *name,\r\nbool clockevent, bool clocksource)\r\n{\r\nint ret;\r\nif (clockevent) {\r\nch->cmt->has_clockevent = true;\r\nret = sh_cmt_register_clockevent(ch, name);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (clocksource) {\r\nch->cmt->has_clocksource = true;\r\nsh_cmt_register_clocksource(ch, name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_setup_channel(struct sh_cmt_channel *ch, unsigned int index,\r\nunsigned int hwidx, bool clockevent,\r\nbool clocksource, struct sh_cmt_device *cmt)\r\n{\r\nint ret;\r\nif (!clockevent && !clocksource)\r\nreturn 0;\r\nch->cmt = cmt;\r\nch->index = index;\r\nch->hwidx = hwidx;\r\nswitch (cmt->info->model) {\r\ncase SH_CMT_16BIT:\r\nch->ioctrl = cmt->mapbase + 2 + ch->hwidx * 6;\r\nbreak;\r\ncase SH_CMT_32BIT:\r\ncase SH_CMT_48BIT:\r\nch->ioctrl = cmt->mapbase + 0x10 + ch->hwidx * 0x10;\r\nbreak;\r\ncase SH_CMT_32BIT_FAST:\r\nch->ioctrl = cmt->mapbase + 0x40;\r\nbreak;\r\ncase SH_CMT_48BIT_GEN2:\r\nch->iostart = cmt->mapbase + ch->hwidx * 0x100;\r\nch->ioctrl = ch->iostart + 0x10;\r\nbreak;\r\n}\r\nif (cmt->info->width == (sizeof(ch->max_match_value) * 8))\r\nch->max_match_value = ~0;\r\nelse\r\nch->max_match_value = (1 << cmt->info->width) - 1;\r\nch->match_value = ch->max_match_value;\r\nraw_spin_lock_init(&ch->lock);\r\nch->timer_bit = cmt->info->model == SH_CMT_48BIT_GEN2 ? 0 : ch->hwidx;\r\nret = sh_cmt_register(ch, dev_name(&cmt->pdev->dev),\r\nclockevent, clocksource);\r\nif (ret) {\r\ndev_err(&cmt->pdev->dev, "ch%u: registration failed\n",\r\nch->index);\r\nreturn ret;\r\n}\r\nch->cs_enabled = false;\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_map_memory(struct sh_cmt_device *cmt)\r\n{\r\nstruct resource *mem;\r\nmem = platform_get_resource(cmt->pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&cmt->pdev->dev, "failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\ncmt->mapbase = ioremap_nocache(mem->start, resource_size(mem));\r\nif (cmt->mapbase == NULL) {\r\ndev_err(&cmt->pdev->dev, "failed to remap I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_parse_dt(struct sh_cmt_device *cmt)\r\n{\r\nstruct device_node *np = cmt->pdev->dev.of_node;\r\nreturn of_property_read_u32(np, "renesas,channels-mask",\r\n&cmt->hw_channels);\r\n}\r\nstatic int sh_cmt_setup(struct sh_cmt_device *cmt, struct platform_device *pdev)\r\n{\r\nunsigned int mask;\r\nunsigned int i;\r\nint ret;\r\ncmt->pdev = pdev;\r\nraw_spin_lock_init(&cmt->lock);\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\r\nconst struct of_device_id *id;\r\nid = of_match_node(sh_cmt_of_table, pdev->dev.of_node);\r\ncmt->info = id->data;\r\nret = sh_cmt_parse_dt(cmt);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (pdev->dev.platform_data) {\r\nstruct sh_timer_config *cfg = pdev->dev.platform_data;\r\nconst struct platform_device_id *id = pdev->id_entry;\r\ncmt->info = (const struct sh_cmt_info *)id->driver_data;\r\ncmt->hw_channels = cfg->channels_mask;\r\n} else {\r\ndev_err(&cmt->pdev->dev, "missing platform data\n");\r\nreturn -ENXIO;\r\n}\r\ncmt->clk = clk_get(&cmt->pdev->dev, "fck");\r\nif (IS_ERR(cmt->clk)) {\r\ndev_err(&cmt->pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(cmt->clk);\r\n}\r\nret = clk_prepare(cmt->clk);\r\nif (ret < 0)\r\ngoto err_clk_put;\r\nret = sh_cmt_map_memory(cmt);\r\nif (ret < 0)\r\ngoto err_clk_unprepare;\r\ncmt->num_channels = hweight8(cmt->hw_channels);\r\ncmt->channels = kzalloc(cmt->num_channels * sizeof(*cmt->channels),\r\nGFP_KERNEL);\r\nif (cmt->channels == NULL) {\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\nfor (i = 0, mask = cmt->hw_channels; i < cmt->num_channels; ++i) {\r\nunsigned int hwidx = ffs(mask) - 1;\r\nbool clocksource = i == 1 || cmt->num_channels == 1;\r\nbool clockevent = i == 0;\r\nret = sh_cmt_setup_channel(&cmt->channels[i], i, hwidx,\r\nclockevent, clocksource, cmt);\r\nif (ret < 0)\r\ngoto err_unmap;\r\nmask &= ~(1 << hwidx);\r\n}\r\nplatform_set_drvdata(pdev, cmt);\r\nreturn 0;\r\nerr_unmap:\r\nkfree(cmt->channels);\r\niounmap(cmt->mapbase);\r\nerr_clk_unprepare:\r\nclk_unprepare(cmt->clk);\r\nerr_clk_put:\r\nclk_put(cmt->clk);\r\nreturn ret;\r\n}\r\nstatic int sh_cmt_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_cmt_device *cmt = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!is_early_platform_device(pdev)) {\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\n}\r\nif (cmt) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\ngoto out;\r\n}\r\ncmt = kzalloc(sizeof(*cmt), GFP_KERNEL);\r\nif (cmt == NULL)\r\nreturn -ENOMEM;\r\nret = sh_cmt_setup(cmt, pdev);\r\nif (ret) {\r\nkfree(cmt);\r\npm_runtime_idle(&pdev->dev);\r\nreturn ret;\r\n}\r\nif (is_early_platform_device(pdev))\r\nreturn 0;\r\nout:\r\nif (cmt->has_clockevent || cmt->has_clocksource)\r\npm_runtime_irq_safe(&pdev->dev);\r\nelse\r\npm_runtime_idle(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_cmt_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init sh_cmt_init(void)\r\n{\r\nreturn platform_driver_register(&sh_cmt_device_driver);\r\n}\r\nstatic void __exit sh_cmt_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_cmt_device_driver);\r\n}
