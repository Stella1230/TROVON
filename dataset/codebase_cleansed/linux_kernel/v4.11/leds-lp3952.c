static int lp3952_register_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret;\r\nstruct lp3952_led_array *priv = i2c_get_clientdata(client);\r\nret = regmap_write(priv->regmap, reg, val);\r\nif (ret)\r\ndev_err(&client->dev, "%s: reg 0x%x, val 0x%x, err %d\n",\r\n__func__, reg, val, ret);\r\nreturn ret;\r\n}\r\nstatic void lp3952_on_off(struct lp3952_led_array *priv,\r\nenum lp3952_leds led_id, bool on)\r\n{\r\nint ret, val;\r\ndev_dbg(&priv->client->dev, "%s LED %d to %d\n", __func__, led_id, on);\r\nval = 1 << led_id;\r\nif (led_id == LP3952_LED_ALL)\r\nval = LP3952_LED_MASK_ALL;\r\nret = regmap_update_bits(priv->regmap, LP3952_REG_LED_CTRL, val,\r\non ? val : 0);\r\nif (ret)\r\ndev_err(&priv->client->dev, "%s, Error %d\n", __func__, ret);\r\n}\r\nstatic int lp3952_set_brightness(struct led_classdev *cdev,\r\nenum led_brightness value)\r\n{\r\nunsigned int reg, shift_val;\r\nstruct lp3952_ctrl_hdl *led = container_of(cdev,\r\nstruct lp3952_ctrl_hdl,\r\ncdev);\r\nstruct lp3952_led_array *priv = (struct lp3952_led_array *)led->priv;\r\ndev_dbg(cdev->dev, "Brightness request: %d on %d\n", value,\r\nled->channel);\r\nif (value == LED_OFF) {\r\nlp3952_on_off(priv, led->channel, false);\r\nreturn 0;\r\n}\r\nif (led->channel > LP3952_RED_1) {\r\ndev_err(cdev->dev, " %s Invalid LED requested", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (led->channel >= LP3952_BLUE_1) {\r\nreg = LP3952_REG_RGB1_MAX_I_CTRL;\r\nshift_val = (led->channel - LP3952_BLUE_1) * 2;\r\n} else {\r\nreg = LP3952_REG_RGB2_MAX_I_CTRL;\r\nshift_val = led->channel * 2;\r\n}\r\nlp3952_on_off(priv, led->channel, true);\r\nreturn regmap_update_bits(priv->regmap, reg, 3 << shift_val,\r\n--value << shift_val);\r\n}\r\nstatic int lp3952_get_label(struct device *dev, const char *label, char *dest)\r\n{\r\nint ret;\r\nconst char *str;\r\nret = device_property_read_string(dev, label, &str);\r\nif (!ret)\r\nstrncpy(dest, str, LP3952_LABEL_MAX_LEN);\r\nreturn ret;\r\n}\r\nstatic int lp3952_register_led_classdev(struct lp3952_led_array *priv)\r\n{\r\nint i, acpi_ret, ret = -ENODEV;\r\nstatic const char *led_name_hdl[LP3952_LED_ALL] = {\r\n"blue2",\r\n"green2",\r\n"red2",\r\n"blue1",\r\n"green1",\r\n"red1"\r\n};\r\nfor (i = 0; i < LP3952_LED_ALL; i++) {\r\nacpi_ret = lp3952_get_label(&priv->client->dev, led_name_hdl[i],\r\npriv->leds[i].name);\r\nif (acpi_ret)\r\ncontinue;\r\npriv->leds[i].cdev.name = priv->leds[i].name;\r\npriv->leds[i].cdev.brightness = LED_OFF;\r\npriv->leds[i].cdev.max_brightness = LP3952_BRIGHT_MAX;\r\npriv->leds[i].cdev.brightness_set_blocking =\r\nlp3952_set_brightness;\r\npriv->leds[i].channel = i;\r\npriv->leds[i].priv = priv;\r\nret = devm_led_classdev_register(&priv->client->dev,\r\n&priv->leds[i].cdev);\r\nif (ret < 0) {\r\ndev_err(&priv->client->dev,\r\n"couldn't register LED %s\n",\r\npriv->leds[i].cdev.name);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int lp3952_set_pattern_gen_cmd(struct lp3952_led_array *priv,\r\nu8 cmd_index, u8 r, u8 g, u8 b,\r\nenum lp3952_tt tt, enum lp3952_cet cet)\r\n{\r\nint ret;\r\nstruct ptrn_gen_cmd line = {\r\n{\r\n{\r\n.r = r,\r\n.g = g,\r\n.b = b,\r\n.cet = cet,\r\n.tt = tt\r\n}\r\n}\r\n};\r\nif (cmd_index >= LP3952_CMD_REG_COUNT)\r\nreturn -EINVAL;\r\nret = lp3952_register_write(priv->client,\r\nLP3952_REG_CMD_0 + cmd_index * 2,\r\nline.bytes.msb);\r\nif (ret)\r\nreturn ret;\r\nreturn lp3952_register_write(priv->client,\r\nLP3952_REG_CMD_0 + cmd_index * 2 + 1,\r\nline.bytes.lsb);\r\n}\r\nstatic int lp3952_configure(struct lp3952_led_array *priv)\r\n{\r\nint ret;\r\nret = lp3952_register_write(priv->client, LP3952_REG_LED_CTRL, 0);\r\nif (ret)\r\nreturn ret;\r\nret = lp3952_register_write(priv->client, LP3952_REG_PAT_GEN_CTRL,\r\nLP3952_PATRN_LOOP | LP3952_PATRN_GEN_EN);\r\nif (ret)\r\nreturn ret;\r\nret = lp3952_register_write(priv->client, LP3952_REG_ENABLES,\r\nLP3952_ACTIVE_MODE | LP3952_INT_B00ST_LDR);\r\nif (ret)\r\nreturn ret;\r\nreturn lp3952_set_pattern_gen_cmd(priv, 0, I46, I71, I100, TT0,\r\nCET197);\r\n}\r\nstatic int lp3952_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint status;\r\nstruct lp3952_led_array *priv;\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->client = client;\r\npriv->enable_gpio = devm_gpiod_get(&client->dev, "nrst",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(priv->enable_gpio)) {\r\nstatus = PTR_ERR(priv->enable_gpio);\r\ndev_err(&client->dev, "Failed to enable gpio: %d\n", status);\r\nreturn status;\r\n}\r\npriv->regmap = devm_regmap_init_i2c(client, &lp3952_regmap);\r\nif (IS_ERR(priv->regmap)) {\r\nint err = PTR_ERR(priv->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\ni2c_set_clientdata(client, priv);\r\nstatus = lp3952_configure(priv);\r\nif (status) {\r\ndev_err(&client->dev, "Probe failed. Device not found (%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\nstatus = lp3952_register_led_classdev(priv);\r\nif (status) {\r\ndev_err(&client->dev, "Unable to register led_classdev: %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp3952_remove(struct i2c_client *client)\r\n{\r\nstruct lp3952_led_array *priv;\r\npriv = i2c_get_clientdata(client);\r\nlp3952_on_off(priv, LP3952_LED_ALL, false);\r\ngpiod_set_value(priv->enable_gpio, 0);\r\nreturn 0;\r\n}
