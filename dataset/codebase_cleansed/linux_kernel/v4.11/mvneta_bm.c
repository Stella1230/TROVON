static void mvneta_bm_write(struct mvneta_bm *priv, u32 offset, u32 data)\r\n{\r\nwritel(data, priv->reg_base + offset);\r\n}\r\nstatic u32 mvneta_bm_read(struct mvneta_bm *priv, u32 offset)\r\n{\r\nreturn readl(priv->reg_base + offset);\r\n}\r\nstatic void mvneta_bm_pool_enable(struct mvneta_bm *priv, int pool_id)\r\n{\r\nu32 val;\r\nval = mvneta_bm_read(priv, MVNETA_BM_POOL_BASE_REG(pool_id));\r\nval |= MVNETA_BM_POOL_ENABLE_MASK;\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(pool_id), val);\r\nmvneta_bm_write(priv, MVNETA_BM_INTR_CAUSE_REG, 0);\r\n}\r\nstatic void mvneta_bm_pool_disable(struct mvneta_bm *priv, int pool_id)\r\n{\r\nu32 val;\r\nval = mvneta_bm_read(priv, MVNETA_BM_POOL_BASE_REG(pool_id));\r\nval &= ~MVNETA_BM_POOL_ENABLE_MASK;\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(pool_id), val);\r\n}\r\nstatic inline void mvneta_bm_config_set(struct mvneta_bm *priv, u32 mask)\r\n{\r\nu32 val;\r\nval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\r\nval |= mask;\r\nmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\r\n}\r\nstatic inline void mvneta_bm_config_clear(struct mvneta_bm *priv, u32 mask)\r\n{\r\nu32 val;\r\nval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\r\nval &= ~mask;\r\nmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\r\n}\r\nstatic void mvneta_bm_pool_target_set(struct mvneta_bm *priv, int pool_id,\r\nu8 target_id, u8 attr)\r\n{\r\nu32 val;\r\nval = mvneta_bm_read(priv, MVNETA_BM_XBAR_POOL_REG(pool_id));\r\nval &= ~MVNETA_BM_TARGET_ID_MASK(pool_id);\r\nval &= ~MVNETA_BM_XBAR_ATTR_MASK(pool_id);\r\nval |= MVNETA_BM_TARGET_ID_VAL(pool_id, target_id);\r\nval |= MVNETA_BM_XBAR_ATTR_VAL(pool_id, attr);\r\nmvneta_bm_write(priv, MVNETA_BM_XBAR_POOL_REG(pool_id), val);\r\n}\r\nint mvneta_bm_construct(struct hwbm_pool *hwbm_pool, void *buf)\r\n{\r\nstruct mvneta_bm_pool *bm_pool =\r\n(struct mvneta_bm_pool *)hwbm_pool->priv;\r\nstruct mvneta_bm *priv = bm_pool->priv;\r\ndma_addr_t phys_addr;\r\n*(u32 *)buf = (u32)buf;\r\nphys_addr = dma_map_single(&priv->pdev->dev, buf, bm_pool->buf_size,\r\nDMA_FROM_DEVICE);\r\nif (unlikely(dma_mapping_error(&priv->pdev->dev, phys_addr)))\r\nreturn -ENOMEM;\r\nmvneta_bm_pool_put_bp(priv, bm_pool, phys_addr);\r\nreturn 0;\r\n}\r\nstatic int mvneta_bm_pool_create(struct mvneta_bm *priv,\r\nstruct mvneta_bm_pool *bm_pool)\r\n{\r\nstruct platform_device *pdev = priv->pdev;\r\nu8 target_id, attr;\r\nint size_bytes, err;\r\nsize_bytes = sizeof(u32) * bm_pool->hwbm_pool.size;\r\nbm_pool->virt_addr = dma_alloc_coherent(&pdev->dev, size_bytes,\r\n&bm_pool->phys_addr,\r\nGFP_KERNEL);\r\nif (!bm_pool->virt_addr)\r\nreturn -ENOMEM;\r\nif (!IS_ALIGNED((u32)bm_pool->virt_addr, MVNETA_BM_POOL_PTR_ALIGN)) {\r\ndma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,\r\nbm_pool->phys_addr);\r\ndev_err(&pdev->dev, "BM pool %d is not %d bytes aligned\n",\r\nbm_pool->id, MVNETA_BM_POOL_PTR_ALIGN);\r\nreturn -ENOMEM;\r\n}\r\nerr = mvebu_mbus_get_dram_win_info(bm_pool->phys_addr, &target_id,\r\n&attr);\r\nif (err < 0) {\r\ndma_free_coherent(&pdev->dev, size_bytes, bm_pool->virt_addr,\r\nbm_pool->phys_addr);\r\nreturn err;\r\n}\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_BASE_REG(bm_pool->id),\r\nbm_pool->phys_addr);\r\nmvneta_bm_pool_target_set(priv, bm_pool->id, target_id, attr);\r\nmvneta_bm_pool_enable(priv, bm_pool->id);\r\nreturn 0;\r\n}\r\nstruct mvneta_bm_pool *mvneta_bm_pool_use(struct mvneta_bm *priv, u8 pool_id,\r\nenum mvneta_bm_type type, u8 port_id,\r\nint pkt_size)\r\n{\r\nstruct mvneta_bm_pool *new_pool = &priv->bm_pools[pool_id];\r\nint num, err;\r\nif (new_pool->type == MVNETA_BM_LONG &&\r\nnew_pool->port_map != 1 << port_id) {\r\ndev_err(&priv->pdev->dev,\r\n"long pool cannot be shared by the ports\n");\r\nreturn NULL;\r\n}\r\nif (new_pool->type == MVNETA_BM_SHORT && new_pool->type != type) {\r\ndev_err(&priv->pdev->dev,\r\n"mixing pools' types between the ports is forbidden\n");\r\nreturn NULL;\r\n}\r\nif (new_pool->pkt_size == 0 || type != MVNETA_BM_SHORT)\r\nnew_pool->pkt_size = pkt_size;\r\nif (new_pool->type == MVNETA_BM_FREE) {\r\nstruct hwbm_pool *hwbm_pool = &new_pool->hwbm_pool;\r\nnew_pool->priv = priv;\r\nnew_pool->type = type;\r\nnew_pool->buf_size = MVNETA_RX_BUF_SIZE(new_pool->pkt_size);\r\nhwbm_pool->frag_size =\r\nSKB_DATA_ALIGN(MVNETA_RX_BUF_SIZE(new_pool->pkt_size)) +\r\nSKB_DATA_ALIGN(sizeof(struct skb_shared_info));\r\nhwbm_pool->construct = mvneta_bm_construct;\r\nhwbm_pool->priv = new_pool;\r\nspin_lock_init(&hwbm_pool->lock);\r\nerr = mvneta_bm_pool_create(priv, new_pool);\r\nif (err) {\r\ndev_err(&priv->pdev->dev, "fail to create pool %d\n",\r\nnew_pool->id);\r\nreturn NULL;\r\n}\r\nnum = hwbm_pool_add(hwbm_pool, hwbm_pool->size, GFP_ATOMIC);\r\nif (num != hwbm_pool->size) {\r\nWARN(1, "pool %d: %d of %d allocated\n",\r\nnew_pool->id, num, hwbm_pool->size);\r\nreturn NULL;\r\n}\r\n}\r\nreturn new_pool;\r\n}\r\nvoid mvneta_bm_bufs_free(struct mvneta_bm *priv, struct mvneta_bm_pool *bm_pool,\r\nu8 port_map)\r\n{\r\nint i;\r\nbm_pool->port_map &= ~port_map;\r\nif (bm_pool->port_map)\r\nreturn;\r\nmvneta_bm_config_set(priv, MVNETA_BM_EMPTY_LIMIT_MASK);\r\nfor (i = 0; i < bm_pool->hwbm_pool.buf_num; i++) {\r\ndma_addr_t buf_phys_addr;\r\nu32 *vaddr;\r\nbuf_phys_addr = mvneta_bm_pool_get_bp(priv, bm_pool);\r\nif (buf_phys_addr == 0)\r\ncontinue;\r\nvaddr = phys_to_virt(buf_phys_addr);\r\nif (!vaddr)\r\nbreak;\r\ndma_unmap_single(&priv->pdev->dev, buf_phys_addr,\r\nbm_pool->buf_size, DMA_FROM_DEVICE);\r\nhwbm_buf_free(&bm_pool->hwbm_pool, vaddr);\r\n}\r\nmvneta_bm_config_clear(priv, MVNETA_BM_EMPTY_LIMIT_MASK);\r\nbm_pool->hwbm_pool.buf_num -= i;\r\n}\r\nvoid mvneta_bm_pool_destroy(struct mvneta_bm *priv,\r\nstruct mvneta_bm_pool *bm_pool, u8 port_map)\r\n{\r\nstruct hwbm_pool *hwbm_pool = &bm_pool->hwbm_pool;\r\nbm_pool->port_map &= ~port_map;\r\nif (bm_pool->port_map)\r\nreturn;\r\nbm_pool->type = MVNETA_BM_FREE;\r\nmvneta_bm_bufs_free(priv, bm_pool, port_map);\r\nif (hwbm_pool->buf_num)\r\nWARN(1, "cannot free all buffers in pool %d\n", bm_pool->id);\r\nif (bm_pool->virt_addr) {\r\ndma_free_coherent(&priv->pdev->dev,\r\nsizeof(u32) * hwbm_pool->size,\r\nbm_pool->virt_addr, bm_pool->phys_addr);\r\nbm_pool->virt_addr = NULL;\r\n}\r\nmvneta_bm_pool_disable(priv, bm_pool->id);\r\n}\r\nstatic void mvneta_bm_pools_init(struct mvneta_bm *priv)\r\n{\r\nstruct device_node *dn = priv->pdev->dev.of_node;\r\nstruct mvneta_bm_pool *bm_pool;\r\nchar prop[15];\r\nu32 size;\r\nint i;\r\nmvneta_bm_write(priv, MVNETA_BM_COMMAND_REG, MVNETA_BM_START_MASK);\r\nfor (i = 0; i < MVNETA_BM_POOLS_NUM; i++) {\r\nbm_pool = &priv->bm_pools[i];\r\nbm_pool->id = i;\r\nbm_pool->type = MVNETA_BM_FREE;\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_READ_PTR_REG(i), 0);\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_WRITE_PTR_REG(i), 0);\r\nsprintf(prop, "pool%d,capacity", i);\r\nif (of_property_read_u32(dn, prop, &size)) {\r\nsize = MVNETA_BM_POOL_CAP_DEF;\r\n} else if (size > MVNETA_BM_POOL_CAP_MAX) {\r\ndev_warn(&priv->pdev->dev,\r\n"Illegal pool %d capacity %d, set to %d\n",\r\ni, size, MVNETA_BM_POOL_CAP_MAX);\r\nsize = MVNETA_BM_POOL_CAP_MAX;\r\n} else if (size < MVNETA_BM_POOL_CAP_MIN) {\r\ndev_warn(&priv->pdev->dev,\r\n"Illegal pool %d capacity %d, set to %d\n",\r\ni, size, MVNETA_BM_POOL_CAP_MIN);\r\nsize = MVNETA_BM_POOL_CAP_MIN;\r\n} else if (!IS_ALIGNED(size, MVNETA_BM_POOL_CAP_ALIGN)) {\r\ndev_warn(&priv->pdev->dev,\r\n"Illegal pool %d capacity %d, round to %d\n",\r\ni, size, ALIGN(size,\r\nMVNETA_BM_POOL_CAP_ALIGN));\r\nsize = ALIGN(size, MVNETA_BM_POOL_CAP_ALIGN);\r\n}\r\nbm_pool->hwbm_pool.size = size;\r\nmvneta_bm_write(priv, MVNETA_BM_POOL_SIZE_REG(i),\r\nbm_pool->hwbm_pool.size);\r\nsprintf(prop, "pool%d,pkt-size", i);\r\nif (of_property_read_u32(dn, prop, &bm_pool->pkt_size))\r\nbm_pool->pkt_size = 0;\r\n}\r\n}\r\nstatic void mvneta_bm_default_set(struct mvneta_bm *priv)\r\n{\r\nu32 val;\r\nmvneta_bm_write(priv, MVNETA_BM_INTR_MASK_REG, 0);\r\nmvneta_bm_write(priv, MVNETA_BM_INTR_CAUSE_REG, 0);\r\nval = mvneta_bm_read(priv, MVNETA_BM_CONFIG_REG);\r\nval &= ~MVNETA_BM_MAX_IN_BURST_SIZE_MASK;\r\nval |= MVNETA_BM_MAX_IN_BURST_SIZE_16BP;\r\nmvneta_bm_write(priv, MVNETA_BM_CONFIG_REG, val);\r\n}\r\nstatic int mvneta_bm_init(struct mvneta_bm *priv)\r\n{\r\nmvneta_bm_default_set(priv);\r\npriv->bm_pools = devm_kcalloc(&priv->pdev->dev, MVNETA_BM_POOLS_NUM,\r\nsizeof(struct mvneta_bm_pool),\r\nGFP_KERNEL);\r\nif (!priv->bm_pools)\r\nreturn -ENOMEM;\r\nmvneta_bm_pools_init(priv);\r\nreturn 0;\r\n}\r\nstatic int mvneta_bm_get_sram(struct device_node *dn,\r\nstruct mvneta_bm *priv)\r\n{\r\npriv->bppi_pool = of_gen_pool_get(dn, "internal-mem", 0);\r\nif (!priv->bppi_pool)\r\nreturn -ENOMEM;\r\npriv->bppi_virt_addr = gen_pool_dma_alloc(priv->bppi_pool,\r\nMVNETA_BM_BPPI_SIZE,\r\n&priv->bppi_phys_addr);\r\nif (!priv->bppi_virt_addr)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void mvneta_bm_put_sram(struct mvneta_bm *priv)\r\n{\r\ngen_pool_free(priv->bppi_pool, priv->bppi_phys_addr,\r\nMVNETA_BM_BPPI_SIZE);\r\n}\r\nstatic int mvneta_bm_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *dn = pdev->dev.of_node;\r\nstruct mvneta_bm *priv;\r\nstruct resource *res;\r\nint err;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct mvneta_bm), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->reg_base))\r\nreturn PTR_ERR(priv->reg_base);\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\nerr = clk_prepare_enable(priv->clk);\r\nif (err < 0)\r\nreturn err;\r\nerr = mvneta_bm_get_sram(dn, priv);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to allocate internal memory\n");\r\ngoto err_clk;\r\n}\r\npriv->pdev = pdev;\r\nerr = mvneta_bm_init(priv);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to initialize controller\n");\r\ngoto err_sram;\r\n}\r\ndn->data = priv;\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(&pdev->dev, "Buffer Manager for network controller enabled\n");\r\nreturn 0;\r\nerr_sram:\r\nmvneta_bm_put_sram(priv);\r\nerr_clk:\r\nclk_disable_unprepare(priv->clk);\r\nreturn err;\r\n}\r\nstatic int mvneta_bm_remove(struct platform_device *pdev)\r\n{\r\nstruct mvneta_bm *priv = platform_get_drvdata(pdev);\r\nu8 all_ports_map = 0xff;\r\nint i = 0;\r\nfor (i = 0; i < MVNETA_BM_POOLS_NUM; i++) {\r\nstruct mvneta_bm_pool *bm_pool = &priv->bm_pools[i];\r\nmvneta_bm_pool_destroy(priv, bm_pool, all_ports_map);\r\n}\r\nmvneta_bm_put_sram(priv);\r\nmvneta_bm_write(priv, MVNETA_BM_COMMAND_REG, MVNETA_BM_STOP_MASK);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
