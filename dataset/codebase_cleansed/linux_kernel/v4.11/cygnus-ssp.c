static struct cygnus_aio_port *cygnus_dai_get_portinfo(struct snd_soc_dai *dai)\r\n{\r\nstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\r\nreturn &cygaud->portinfo[dai->id];\r\n}\r\nstatic int audio_ssp_init_portregs(struct cygnus_aio_port *aio)\r\n{\r\nu32 value, fci_id;\r\nint status = 0;\r\nswitch (aio->port_type) {\r\ncase PORT_TDM:\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nvalue &= ~I2S_STREAM_CFG_MASK;\r\nwritel(aio->portnum,\r\naio->cygaud->audio + aio->regs.bf_sourcech_grp);\r\nvalue |= aio->portnum << I2S_OUT_STREAM_CFG_GROUP_ID;\r\nvalue |= aio->portnum;\r\nvalue |= CH_GRP_STEREO << I2S_OUT_STREAM_CFG_CHANNEL_GROUPING;\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~BIT(BF_SRC_CFGX_NOT_PAUSE_WHEN_EMPTY);\r\nvalue |= BIT(BF_SRC_CFGX_SFIFO_SZ_DOUBLE);\r\nvalue |= BIT(BF_SRC_CFGX_PROCESS_SEQ_ID_VALID);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue = readl(aio->cygaud->i2s_in +\r\naio->regs.i2s_cap_stream_cfg);\r\nvalue &= ~I2S_CAP_STREAM_CFG_MASK;\r\nvalue |= aio->portnum << I2S_IN_STREAM_CFG_0_GROUP_ID;\r\nwritel(value, aio->cygaud->i2s_in +\r\naio->regs.i2s_cap_stream_cfg);\r\nfci_id = CAPTURE_FCI_ID_BASE + aio->portnum;\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\nvalue |= BIT(BF_DST_CFGX_DFIFO_SZ_DOUBLE);\r\nvalue &= ~BIT(BF_DST_CFGX_NOT_PAUSE_WHEN_FULL);\r\nvalue |= (fci_id << BF_DST_CFGX_FCI_ID);\r\nvalue |= BIT(BF_DST_CFGX_PROC_SEQ_ID_VALID);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\nvalue = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nvalue &= ~BIT((aio->portnum * 4) + AUD_MISC_SEROUT_SDAT_OE);\r\nwritel(value, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nbreak;\r\ncase PORT_SPDIF:\r\nwritel(aio->portnum, aio->cygaud->audio + BF_SRC_GRP3_OFFSET);\r\nvalue = readl(aio->cygaud->audio + SPDIF_CTRL_OFFSET);\r\nvalue |= BIT(SPDIF_0_OUT_DITHER_ENA);\r\nwritel(value, aio->cygaud->audio + SPDIF_CTRL_OFFSET);\r\nvalue = readl(aio->cygaud->audio + SPDIF_STREAM_CFG_OFFSET);\r\nvalue &= ~SPDIF_STREAM_CFG_MASK;\r\nvalue |= aio->portnum;\r\nvalue |= BIT(SPDIF_0_OUT_STREAM_ENA);\r\nwritel(value, aio->cygaud->audio + SPDIF_STREAM_CFG_OFFSET);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~BIT(BF_SRC_CFGX_NOT_PAUSE_WHEN_EMPTY);\r\nvalue |= BIT(BF_SRC_CFGX_SFIFO_SZ_DOUBLE);\r\nvalue |= BIT(BF_SRC_CFGX_PROCESS_SEQ_ID_VALID);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nvalue &= ~BIT(AUD_MISC_SEROUT_SPDIF_OE);\r\nwritel(value, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nbreak;\r\ndefault:\r\ndev_err(aio->cygaud->dev, "Port not supported\n");\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic void audio_ssp_in_enable(struct cygnus_aio_port *aio)\r\n{\r\nu32 value;\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\nvalue |= BIT(BF_DST_CFGX_CAP_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\nwritel(0x1, aio->cygaud->audio + aio->regs.bf_destch_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue |= BIT(I2S_OUT_CFGX_CLK_ENA);\r\nvalue |= BIT(I2S_OUT_CFGX_DATA_ENABLE);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\r\nvalue |= BIT(I2S_IN_STREAM_CFG_CAP_ENA);\r\nwritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\r\naio->streams_on |= CAPTURE_STREAM_MASK;\r\n}\r\nstatic void audio_ssp_in_disable(struct cygnus_aio_port *aio)\r\n{\r\nu32 value;\r\nvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\r\nvalue &= ~BIT(I2S_IN_STREAM_CFG_CAP_ENA);\r\nwritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_stream_cfg);\r\naio->streams_on &= ~CAPTURE_STREAM_MASK;\r\nif (!aio->streams_on) {\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue &= ~BIT(I2S_OUT_CFGX_CLK_ENA);\r\nvalue &= ~BIT(I2S_OUT_CFGX_DATA_ENABLE);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\n}\r\nwritel(0x0, aio->cygaud->audio + aio->regs.bf_destch_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\nvalue &= ~BIT(BF_DST_CFGX_CAP_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_destch_cfg);\r\n}\r\nstatic int audio_ssp_out_enable(struct cygnus_aio_port *aio)\r\n{\r\nu32 value;\r\nint status = 0;\r\nswitch (aio->port_type) {\r\ncase PORT_TDM:\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nvalue |= BIT(I2S_OUT_STREAM_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nwritel(1, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue |= BIT(I2S_OUT_CFGX_CLK_ENA);\r\nvalue |= BIT(I2S_OUT_CFGX_DATA_ENABLE);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue |= BIT(BF_SRC_CFGX_SFIFO_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\naio->streams_on |= PLAYBACK_STREAM_MASK;\r\nbreak;\r\ncase PORT_SPDIF:\r\nvalue = readl(aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\r\nvalue |= 0x3;\r\nwritel(value, aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\r\nwritel(1, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue |= BIT(BF_SRC_CFGX_SFIFO_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nbreak;\r\ndefault:\r\ndev_err(aio->cygaud->dev,\r\n"Port not supported %d\n", aio->portnum);\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic int audio_ssp_out_disable(struct cygnus_aio_port *aio)\r\n{\r\nu32 value;\r\nint status = 0;\r\nswitch (aio->port_type) {\r\ncase PORT_TDM:\r\naio->streams_on &= ~PLAYBACK_STREAM_MASK;\r\nif (!aio->streams_on) {\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue &= ~BIT(I2S_OUT_CFGX_CLK_ENA);\r\nvalue &= ~BIT(I2S_OUT_CFGX_DATA_ENABLE);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\n}\r\nvalue = readl(aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\r\nvalue |= BIT(aio->portnum);\r\nwritel(value, aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\r\nwritel(0, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~BIT(BF_SRC_CFGX_SFIFO_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue = readl(aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\r\nvalue &= ~BIT(aio->portnum);\r\nwritel(value, aio->cygaud->audio + BF_SRC_GRP_SYNC_DIS_OFFSET);\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nvalue &= ~BIT(I2S_OUT_STREAM_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_stream_cfg);\r\nvalue = readl(aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\r\nvalue |= BIT(aio->portnum);\r\nwritel(value, aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\r\nvalue &= ~BIT(aio->portnum);\r\nwritel(value, aio->cygaud->i2s_in + IOP_SW_INIT_LOGIC);\r\nbreak;\r\ncase PORT_SPDIF:\r\nvalue = readl(aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\r\nvalue &= ~0x3;\r\nwritel(value, aio->cygaud->audio + SPDIF_FORMAT_CFG_OFFSET);\r\nwritel(0, aio->cygaud->audio + aio->regs.bf_sourcech_ctrl);\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~BIT(BF_SRC_CFGX_SFIFO_ENA);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nbreak;\r\ndefault:\r\ndev_err(aio->cygaud->dev,\r\n"Port not supported %d\n", aio->portnum);\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic int pll_configure_mclk(struct cygnus_audio *cygaud, u32 mclk,\r\nstruct cygnus_aio_port *aio)\r\n{\r\nint i = 0, error;\r\nbool found = false;\r\nconst struct pll_macro_entry *p_entry;\r\nstruct clk *ch_clk;\r\nfor (i = 0; i < ARRAY_SIZE(pll_predef_mclk); i++) {\r\np_entry = &pll_predef_mclk[i];\r\nif (p_entry->mclk == mclk) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_err(cygaud->dev,\r\n"%s No valid mclk freq (%u) found!\n", __func__, mclk);\r\nreturn -EINVAL;\r\n}\r\nch_clk = cygaud->audio_clk[p_entry->pll_ch_num];\r\nif ((aio->clk_trace.cap_en) && (!aio->clk_trace.cap_clk_en)) {\r\nerror = clk_prepare_enable(ch_clk);\r\nif (error) {\r\ndev_err(cygaud->dev, "%s clk_prepare_enable failed %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\naio->clk_trace.cap_clk_en = true;\r\n}\r\nif ((aio->clk_trace.play_en) && (!aio->clk_trace.play_clk_en)) {\r\nerror = clk_prepare_enable(ch_clk);\r\nif (error) {\r\ndev_err(cygaud->dev, "%s clk_prepare_enable failed %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\naio->clk_trace.play_clk_en = true;\r\n}\r\nerror = clk_set_rate(ch_clk, mclk);\r\nif (error) {\r\ndev_err(cygaud->dev, "%s Set MCLK rate failed: %d\n",\r\n__func__, error);\r\nreturn error;\r\n}\r\nreturn p_entry->pll_ch_num;\r\n}\r\nstatic int cygnus_ssp_set_clocks(struct cygnus_aio_port *aio,\r\nstruct cygnus_audio *cygaud)\r\n{\r\nu32 value, i = 0;\r\nu32 mask = 0xf;\r\nu32 sclk;\r\nbool found = false;\r\nconst struct _ssp_clk_coeff *p_entry = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(ssp_clk_coeff); i++) {\r\np_entry = &ssp_clk_coeff[i];\r\nif ((p_entry->rate == aio->lrclk) &&\r\n(p_entry->sclk_rate == aio->bit_per_frame) &&\r\n(p_entry->mclk == aio->mclk)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_err(aio->cygaud->dev,\r\n"No valid match found in ssp_clk_coeff array\n");\r\ndev_err(aio->cygaud->dev, "lrclk = %u, bits/frame = %u, mclk = %u\n",\r\naio->lrclk, aio->bit_per_frame, aio->mclk);\r\nreturn -EINVAL;\r\n}\r\nsclk = aio->bit_per_frame;\r\nif (sclk == 512)\r\nsclk = 0;\r\nsclk /= 32;\r\nswitch (aio->port_type) {\r\ncase PORT_TDM:\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue &= ~(mask << I2S_OUT_CFGX_SCLKS_PER_1FS_DIV32);\r\nvalue |= sclk << I2S_OUT_CFGX_SCLKS_PER_1FS_DIV32;\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\ndev_dbg(aio->cygaud->dev,\r\n"SCLKS_PER_1FS_DIV32 = 0x%x\n", value);\r\nbreak;\r\ncase PORT_SPDIF:\r\nbreak;\r\ndefault:\r\ndev_err(aio->cygaud->dev, "Unknown port type\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\nvalue &= ~(0xf << I2S_OUT_MCLKRATE_SHIFT);\r\nvalue |= (p_entry->mclk_rate << I2S_OUT_MCLKRATE_SHIFT);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\ndev_dbg(aio->cygaud->dev, "mclk cfg reg = 0x%x\n", value);\r\ndev_dbg(aio->cygaud->dev, "bits per frame = %u, mclk = %u Hz, lrclk = %u Hz\n",\r\naio->bit_per_frame, aio->mclk, aio->lrclk);\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\r\nstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\r\nint rate, bitres;\r\nu32 value;\r\nu32 mask = 0x1f;\r\nint ret = 0;\r\ndev_dbg(aio->cygaud->dev, "%s port = %d\n", __func__, aio->portnum);\r\ndev_dbg(aio->cygaud->dev, "params_channels %d\n",\r\nparams_channels(params));\r\ndev_dbg(aio->cygaud->dev, "rate %d\n", params_rate(params));\r\ndev_dbg(aio->cygaud->dev, "format %d\n", params_format(params));\r\nrate = params_rate(params);\r\nswitch (aio->mode) {\r\ncase CYGNUS_SSPMODE_TDM:\r\nif ((rate == 192000) && (params_channels(params) > 4)) {\r\ndev_err(aio->cygaud->dev, "Cannot run %d channels at %dHz\n",\r\nparams_channels(params), rate);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase CYGNUS_SSPMODE_I2S:\r\naio->bit_per_frame = 64;\r\nbreak;\r\ndefault:\r\ndev_err(aio->cygaud->dev,\r\n"%s port running in unknown mode\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~BIT(BF_SRC_CFGX_BUFFER_PAIR_ENABLE);\r\nif (params_channels(params) == 1)\r\nvalue |= BIT(BF_SRC_CFGX_SAMPLE_CH_MODE);\r\nelse\r\nvalue &= ~BIT(BF_SRC_CFGX_SAMPLE_CH_MODE);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nif (aio->port_type == PORT_SPDIF) {\r\ndev_err(aio->cygaud->dev,\r\n"SPDIF does not support 8bit format\n");\r\nreturn -EINVAL;\r\n}\r\nbitres = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbitres = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbitres = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvalue = readl(aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\nvalue &= ~(mask << BF_SRC_CFGX_BIT_RES);\r\nvalue |= (bitres << BF_SRC_CFGX_BIT_RES);\r\nwritel(value, aio->cygaud->audio + aio->regs.bf_sourcech_cfg);\r\n} else {\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nvalue = readl(aio->cygaud->audio +\r\naio->regs.bf_destch_cfg);\r\nvalue |= BIT(BF_DST_CFGX_CAP_MODE);\r\nwritel(value, aio->cygaud->audio +\r\naio->regs.bf_destch_cfg);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nvalue = readl(aio->cygaud->audio +\r\naio->regs.bf_destch_cfg);\r\nvalue &= ~BIT(BF_DST_CFGX_CAP_MODE);\r\nwritel(value, aio->cygaud->audio +\r\naio->regs.bf_destch_cfg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\naio->lrclk = rate;\r\nif (!aio->is_slave)\r\nret = cygnus_ssp_set_clocks(aio, cygaud);\r\nreturn ret;\r\n}\r\nstatic int cygnus_ssp_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nint sel;\r\nu32 value;\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\r\nstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\r\ndev_dbg(aio->cygaud->dev,\r\n"%s Enter port = %d\n", __func__, aio->portnum);\r\nsel = pll_configure_mclk(cygaud, freq, aio);\r\nif (sel < 0) {\r\ndev_err(aio->cygaud->dev,\r\n"%s Setting mclk failed.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\naio->mclk = freq;\r\ndev_dbg(aio->cygaud->dev, "%s Setting MCLKSEL to %d\n", __func__, sel);\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\nvalue &= ~(0xf << I2S_OUT_PLLCLKSEL_SHIFT);\r\nvalue |= (sel << I2S_OUT_PLLCLKSEL_SHIFT);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\r\nsnd_soc_dai_set_dma_data(dai, substream, aio);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naio->clk_trace.play_en = true;\r\nelse\r\naio->clk_trace.cap_en = true;\r\nreturn 0;\r\n}\r\nstatic void cygnus_ssp_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naio->clk_trace.play_en = false;\r\nelse\r\naio->clk_trace.cap_en = false;\r\nif (!aio->is_slave) {\r\nu32 val;\r\nval = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\nval &= CYGNUS_PLLCLKSEL_MASK;\r\nif (val >= ARRAY_SIZE(aio->cygaud->audio_clk)) {\r\ndev_err(aio->cygaud->dev, "Clk index %u is out of bounds\n",\r\nval);\r\nreturn;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (aio->clk_trace.play_clk_en) {\r\nclk_disable_unprepare(aio->cygaud->\r\naudio_clk[val]);\r\naio->clk_trace.play_clk_en = false;\r\n}\r\n} else {\r\nif (aio->clk_trace.cap_clk_en) {\r\nclk_disable_unprepare(aio->cygaud->\r\naudio_clk[val]);\r\naio->clk_trace.cap_clk_en = false;\r\n}\r\n}\r\n}\r\n}\r\nint cygnus_ssp_set_custom_fsync_width(struct snd_soc_dai *cpu_dai, int len)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\r\nif ((len > 0) && (len < 256)) {\r\naio->fsync_width = len;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int cygnus_ssp_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\r\nu32 ssp_curcfg;\r\nu32 ssp_newcfg;\r\nu32 ssp_outcfg;\r\nu32 ssp_incfg;\r\nu32 val;\r\nu32 mask;\r\ndev_dbg(aio->cygaud->dev, "%s Enter fmt: %x\n", __func__, fmt);\r\nif (aio->port_type == PORT_SPDIF)\r\nreturn -EINVAL;\r\nssp_newcfg = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_SLAVE_MODE);\r\naio->is_slave = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nssp_newcfg &= ~BIT(I2S_OUT_CFGX_SLAVE_MODE);\r\naio->is_slave = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_DATA_ALIGNMENT);\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_FSYNC_WIDTH);\r\naio->mode = CYGNUS_SSPMODE_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_TDM_MODE);\r\nif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A)\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_DATA_ALIGNMENT);\r\nif ((aio->fsync_width > 0) && (aio->fsync_width < 256))\r\nssp_newcfg |=\r\n(aio->fsync_width << I2S_OUT_CFGX_FSYNC_WIDTH);\r\nelse\r\nssp_newcfg |= BIT(I2S_OUT_CFGX_FSYNC_WIDTH);\r\naio->mode = CYGNUS_SSPMODE_TDM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssp_curcfg = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nssp_outcfg = (ssp_curcfg & I2S_OUT_CFG_REG_UPDATE_MASK) | ssp_newcfg;\r\nwritel(ssp_outcfg, aio->cygaud->audio + aio->regs.i2s_cfg);\r\nssp_curcfg = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\r\nssp_incfg = (ssp_curcfg & I2S_IN_CFG_REG_UPDATE_MASK) | ssp_newcfg;\r\nwritel(ssp_incfg, aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\r\nval = readl(aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nmask = BIT(AUD_MISC_SEROUT_LRCK_OE)\r\n| BIT(AUD_MISC_SEROUT_SCLK_OE)\r\n| BIT(AUD_MISC_SEROUT_MCLK_OE);\r\nmask = mask << (aio->portnum * 4);\r\nif (aio->is_slave)\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\ndev_dbg(aio->cygaud->dev, "%s Set OE bits 0x%x\n", __func__, val);\r\nwritel(val, aio->cygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(dai);\r\nstruct cygnus_audio *cygaud = snd_soc_dai_get_drvdata(dai);\r\ndev_dbg(aio->cygaud->dev,\r\n"%s cmd %d at port = %d\n", __func__, cmd, aio->portnum);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naudio_ssp_out_enable(aio);\r\nelse\r\naudio_ssp_in_enable(aio);\r\ncygaud->active_ports++;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\naudio_ssp_out_disable(aio);\r\nelse\r\naudio_ssp_in_disable(aio);\r\ncygaud->active_ports--;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cygnus_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\r\nu32 value;\r\nint bits_per_slot = 0;\r\nint frame_bits;\r\nunsigned int active_slots;\r\nbool found = false;\r\nint i;\r\nif (tx_mask != rx_mask) {\r\ndev_err(aio->cygaud->dev,\r\n"%s tx_mask must equal rx_mask\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nactive_slots = hweight32(tx_mask);\r\nif ((active_slots < 0) || (active_slots > 16))\r\nreturn -EINVAL;\r\nif (active_slots % 2)\r\nreturn -EINVAL;\r\nif (active_slots == 16)\r\nactive_slots = 0;\r\nswitch (slot_width) {\r\ncase 16:\r\nbits_per_slot = 1;\r\nbreak;\r\ncase 32:\r\nbits_per_slot = 0;\r\nbreak;\r\ndefault:\r\nbits_per_slot = 0;\r\ndev_warn(aio->cygaud->dev,\r\n"%s Defaulting Slot Width to 32\n", __func__);\r\n}\r\nframe_bits = slots * slot_width;\r\nfor (i = 0; i < ARRAY_SIZE(ssp_valid_tdm_framesize); i++) {\r\nif (ssp_valid_tdm_framesize[i] == frame_bits) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_err(aio->cygaud->dev,\r\n"%s In TDM mode, frame bits INVALID (%d)\n",\r\n__func__, frame_bits);\r\nreturn -EINVAL;\r\n}\r\naio->bit_per_frame = frame_bits;\r\ndev_dbg(aio->cygaud->dev, "%s active_slots %u, bits per frame %d\n",\r\n__func__, active_slots, frame_bits);\r\nvalue = readl(aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\r\nvalue &= ~(0xf << I2S_OUT_CFGX_VALID_SLOT);\r\nvalue |= (active_slots << I2S_OUT_CFGX_VALID_SLOT);\r\nvalue &= ~BIT(I2S_OUT_CFGX_BITS_PER_SLOT);\r\nvalue |= (bits_per_slot << I2S_OUT_CFGX_BITS_PER_SLOT);\r\nwritel(value, aio->cygaud->i2s_in + aio->regs.i2s_cap_cfg);\r\nvalue = readl(aio->cygaud->audio + aio->regs.i2s_cfg);\r\nvalue &= ~(0xf << I2S_OUT_CFGX_VALID_SLOT);\r\nvalue |= (active_slots << I2S_OUT_CFGX_VALID_SLOT);\r\nvalue &= ~BIT(I2S_OUT_CFGX_BITS_PER_SLOT);\r\nvalue |= (bits_per_slot << I2S_OUT_CFGX_BITS_PER_SLOT);\r\nwritel(value, aio->cygaud->audio + aio->regs.i2s_cfg);\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_suspend(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\r\nif (!aio->is_slave) {\r\nu32 val;\r\nval = readl(aio->cygaud->audio + aio->regs.i2s_mclk_cfg);\r\nval &= CYGNUS_PLLCLKSEL_MASK;\r\nif (val >= ARRAY_SIZE(aio->cygaud->audio_clk)) {\r\ndev_err(aio->cygaud->dev, "Clk index %u is out of bounds\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\nif (aio->clk_trace.cap_clk_en)\r\nclk_disable_unprepare(aio->cygaud->audio_clk[val]);\r\nif (aio->clk_trace.play_clk_en)\r\nclk_disable_unprepare(aio->cygaud->audio_clk[val]);\r\naio->pll_clk_num = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_resume(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct cygnus_aio_port *aio = cygnus_dai_get_portinfo(cpu_dai);\r\nint error;\r\nif (!aio->is_slave) {\r\nif (aio->clk_trace.cap_clk_en) {\r\nerror = clk_prepare_enable(aio->cygaud->\r\naudio_clk[aio->pll_clk_num]);\r\nif (error) {\r\ndev_err(aio->cygaud->dev, "%s clk_prepare_enable failed\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (aio->clk_trace.play_clk_en) {\r\nerror = clk_prepare_enable(aio->cygaud->\r\naudio_clk[aio->pll_clk_num]);\r\nif (error) {\r\nif (aio->clk_trace.cap_clk_en)\r\nclk_disable_unprepare(aio->cygaud->\r\naudio_clk[aio->pll_clk_num]);\r\ndev_err(aio->cygaud->dev, "%s clk_prepare_enable failed\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_ssp_child_node(struct platform_device *pdev,\r\nstruct device_node *dn,\r\nstruct cygnus_audio *cygaud,\r\nstruct snd_soc_dai_driver *p_dai)\r\n{\r\nstruct cygnus_aio_port *aio;\r\nstruct cygnus_ssp_regs ssp_regs[3];\r\nu32 rawval;\r\nint portnum = -1;\r\nenum cygnus_audio_port_type port_type;\r\nif (of_property_read_u32(dn, "reg", &rawval)) {\r\ndev_err(&pdev->dev, "Missing reg property\n");\r\nreturn -EINVAL;\r\n}\r\nportnum = rawval;\r\nswitch (rawval) {\r\ncase 0:\r\nssp_regs[0] = INIT_SSP_REGS(0);\r\nport_type = PORT_TDM;\r\nbreak;\r\ncase 1:\r\nssp_regs[1] = INIT_SSP_REGS(1);\r\nport_type = PORT_TDM;\r\nbreak;\r\ncase 2:\r\nssp_regs[2] = INIT_SSP_REGS(2);\r\nport_type = PORT_TDM;\r\nbreak;\r\ncase 3:\r\nport_type = PORT_SPDIF;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Bad value for reg %u\n", rawval);\r\nreturn -EINVAL;\r\n}\r\naio = &cygaud->portinfo[portnum];\r\naio->cygaud = cygaud;\r\naio->portnum = portnum;\r\naio->port_type = port_type;\r\naio->fsync_width = -1;\r\nswitch (port_type) {\r\ncase PORT_TDM:\r\naio->regs = ssp_regs[portnum];\r\n*p_dai = cygnus_ssp_dai_info[portnum];\r\naio->mode = CYGNUS_SSPMODE_UNKNOWN;\r\nbreak;\r\ncase PORT_SPDIF:\r\naio->regs.bf_sourcech_cfg = BF_SRC_CFG3_OFFSET;\r\naio->regs.bf_sourcech_ctrl = BF_SRC_CTRL3_OFFSET;\r\naio->regs.i2s_mclk_cfg = SPDIF_MCLK_CFG_OFFSET;\r\naio->regs.i2s_stream_cfg = SPDIF_STREAM_CFG_OFFSET;\r\n*p_dai = cygnus_spdif_dai_info;\r\naio->mode = CYGNUS_SSPMODE_I2S;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Bad value for port_type %d\n", port_type);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&pdev->dev, "%s portnum = %d\n", __func__, aio->portnum);\r\naio->streams_on = 0;\r\naio->cygaud->dev = &pdev->dev;\r\naio->clk_trace.play_en = false;\r\naio->clk_trace.cap_en = false;\r\naudio_ssp_init_portregs(aio);\r\nreturn 0;\r\n}\r\nstatic int audio_clk_init(struct platform_device *pdev,\r\nstruct cygnus_audio *cygaud)\r\n{\r\nint i;\r\nchar clk_name[PROP_LEN_MAX];\r\nfor (i = 0; i < ARRAY_SIZE(cygaud->audio_clk); i++) {\r\nsnprintf(clk_name, PROP_LEN_MAX, "ch%d_audio", i);\r\ncygaud->audio_clk[i] = devm_clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(cygaud->audio_clk[i]))\r\nreturn PTR_ERR(cygaud->audio_clk[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cygnus_ssp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *child_node;\r\nstruct resource *res = pdev->resource;\r\nstruct cygnus_audio *cygaud;\r\nint err = -EINVAL;\r\nint node_count;\r\nint active_port_count;\r\ncygaud = devm_kzalloc(dev, sizeof(struct cygnus_audio), GFP_KERNEL);\r\nif (!cygaud)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, cygaud);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "aud");\r\ncygaud->audio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cygaud->audio))\r\nreturn PTR_ERR(cygaud->audio);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "i2s_in");\r\ncygaud->i2s_in = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cygaud->i2s_in))\r\nreturn PTR_ERR(cygaud->i2s_in);\r\nwritel(CYGNUS_SSP_TRISTATE_MASK,\r\ncygaud->audio + AUD_MISC_SEROUT_OE_REG_BASE);\r\nnode_count = of_get_child_count(pdev->dev.of_node);\r\nif ((node_count < 1) || (node_count > CYGNUS_MAX_PORTS)) {\r\ndev_err(dev, "child nodes is %d. Must be between 1 and %d\n",\r\nnode_count, CYGNUS_MAX_PORTS);\r\nreturn -EINVAL;\r\n}\r\nactive_port_count = 0;\r\nfor_each_available_child_of_node(pdev->dev.of_node, child_node) {\r\nerr = parse_ssp_child_node(pdev, child_node, cygaud,\r\n&cygnus_ssp_dai[active_port_count]);\r\nif (err < 0)\r\nreturn err;\r\nelse if (!err) {\r\ndev_dbg(dev, "Activating DAI: %s\n",\r\ncygnus_ssp_dai[active_port_count].name);\r\nactive_port_count++;\r\n}\r\n}\r\ncygaud->dev = dev;\r\ncygaud->active_ports = 0;\r\ndev_dbg(dev, "Registering %d DAIs\n", active_port_count);\r\nerr = snd_soc_register_component(dev, &cygnus_ssp_component,\r\ncygnus_ssp_dai, active_port_count);\r\nif (err) {\r\ndev_err(dev, "snd_soc_register_dai failed\n");\r\nreturn err;\r\n}\r\ncygaud->irq_num = platform_get_irq(pdev, 0);\r\nif (cygaud->irq_num <= 0) {\r\ndev_err(dev, "platform_get_irq failed\n");\r\nerr = cygaud->irq_num;\r\ngoto err_irq;\r\n}\r\nerr = audio_clk_init(pdev, cygaud);\r\nif (err) {\r\ndev_err(dev, "audio clock initialization failed\n");\r\ngoto err_irq;\r\n}\r\nerr = cygnus_soc_platform_register(dev, cygaud);\r\nif (err) {\r\ndev_err(dev, "platform reg error %d\n", err);\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\nsnd_soc_unregister_component(dev);\r\nreturn err;\r\n}\r\nstatic int cygnus_ssp_remove(struct platform_device *pdev)\r\n{\r\ncygnus_soc_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nreturn 0;\r\n}
