static int netup_unidvb_tuner_ctrl(void *priv, int is_dvb_tc)\r\n{\r\nu8 reg, mask;\r\nstruct netup_dma *dma = priv;\r\nstruct netup_unidvb_dev *ndev;\r\nif (!priv)\r\nreturn -EINVAL;\r\nndev = dma->ndev;\r\ndev_dbg(&ndev->pci_dev->dev, "%s(): num %d is_dvb_tc %d\n",\r\n__func__, dma->num, is_dvb_tc);\r\nreg = readb(ndev->bmmio0 + GPIO_REG_IO);\r\nmask = (dma->num == 0) ? GPIO_RFA_CTL : GPIO_RFB_CTL;\r\nif (ndev->rev == NETUP_HW_REV_1_4)\r\nis_dvb_tc = !is_dvb_tc;\r\nif (!is_dvb_tc)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\nwriteb(reg, ndev->bmmio0 + GPIO_REG_IO);\r\nreturn 0;\r\n}\r\nstatic void netup_unidvb_dev_enable(struct netup_unidvb_dev *ndev)\r\n{\r\nu16 gpio_reg;\r\nwritel(AVL_IRQ_ENABLE, ndev->bmmio0 + AVL_PCIE_IENR);\r\nwriteb(0x00, ndev->bmmio0 + GPIO_REG_IO);\r\nmsleep(100);\r\ngpio_reg =\r\nGPIO_FEA_RESET | GPIO_FEB_RESET |\r\nGPIO_FEA_TU_RESET | GPIO_FEB_TU_RESET |\r\nGPIO_RFA_CTL | GPIO_RFB_CTL;\r\nwriteb(gpio_reg, ndev->bmmio0 + GPIO_REG_IO);\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): AVL_PCIE_IENR 0x%x GPIO_REG_IO 0x%x\n",\r\n__func__, readl(ndev->bmmio0 + AVL_PCIE_IENR),\r\n(int)readb(ndev->bmmio0 + GPIO_REG_IO));\r\n}\r\nstatic void netup_unidvb_dma_enable(struct netup_dma *dma, int enable)\r\n{\r\nu32 irq_mask = (dma->num == 0 ?\r\nNETUP_UNIDVB_IRQ_DMA1 : NETUP_UNIDVB_IRQ_DMA2);\r\ndev_dbg(&dma->ndev->pci_dev->dev,\r\n"%s(): DMA%d enable %d\n", __func__, dma->num, enable);\r\nif (enable) {\r\nwritel(BIT_DMA_RUN, &dma->regs->ctrlstat_set);\r\nwritew(irq_mask, dma->ndev->bmmio0 + REG_IMASK_SET);\r\n} else {\r\nwritel(BIT_DMA_RUN, &dma->regs->ctrlstat_clear);\r\nwritew(irq_mask, dma->ndev->bmmio0 + REG_IMASK_CLEAR);\r\n}\r\n}\r\nstatic irqreturn_t netup_dma_interrupt(struct netup_dma *dma)\r\n{\r\nu64 addr_curr;\r\nu32 size;\r\nunsigned long flags;\r\nstruct device *dev = &dma->ndev->pci_dev->dev;\r\nspin_lock_irqsave(&dma->lock, flags);\r\naddr_curr = ((u64)readl(&dma->regs->curr_addr_hi) << 32) |\r\n(u64)readl(&dma->regs->curr_addr_lo) | dma->high_addr;\r\nwritel(BIT_DMA_IRQ, &dma->regs->ctrlstat_clear);\r\nif (addr_curr < dma->addr_phys ||\r\naddr_curr > dma->addr_phys + dma->ring_buffer_size) {\r\nif (addr_curr != 0) {\r\ndev_err(dev,\r\n"%s(): addr 0x%llx not from 0x%llx:0x%llx\n",\r\n__func__, addr_curr, (u64)dma->addr_phys,\r\n(u64)(dma->addr_phys + dma->ring_buffer_size));\r\n}\r\ngoto irq_handled;\r\n}\r\nsize = (addr_curr >= dma->addr_last) ?\r\n(u32)(addr_curr - dma->addr_last) :\r\n(u32)(dma->ring_buffer_size - (dma->addr_last - addr_curr));\r\nif (dma->data_size != 0) {\r\nprintk_ratelimited("%s(): lost interrupt, data size %d\n",\r\n__func__, dma->data_size);\r\ndma->data_size += size;\r\n}\r\nif (dma->data_size == 0 || dma->data_size > dma->ring_buffer_size) {\r\ndma->data_size = size;\r\ndma->data_offset = (u32)(dma->addr_last - dma->addr_phys);\r\n}\r\ndma->addr_last = addr_curr;\r\nqueue_work(dma->ndev->wq, &dma->work);\r\nirq_handled:\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t netup_unidvb_isr(int irq, void *dev_id)\r\n{\r\nstruct pci_dev *pci_dev = (struct pci_dev *)dev_id;\r\nstruct netup_unidvb_dev *ndev = pci_get_drvdata(pci_dev);\r\nu32 reg40, reg_isr;\r\nirqreturn_t iret = IRQ_NONE;\r\nwritel(0, ndev->bmmio0 + AVL_PCIE_IENR);\r\nreg40 = readl(ndev->bmmio0 + AVL_PCIE_ISR);\r\nif ((reg40 & AVL_IRQ_ASSERTED) != 0) {\r\nreg_isr = readw(ndev->bmmio0 + REG_ISR);\r\nif (reg_isr & NETUP_UNIDVB_IRQ_I2C0) {\r\niret = netup_i2c_interrupt(&ndev->i2c[0]);\r\n} else if (reg_isr & NETUP_UNIDVB_IRQ_I2C1) {\r\niret = netup_i2c_interrupt(&ndev->i2c[1]);\r\n} else if (reg_isr & NETUP_UNIDVB_IRQ_SPI) {\r\niret = netup_spi_interrupt(ndev->spi);\r\n} else if (reg_isr & NETUP_UNIDVB_IRQ_DMA1) {\r\niret = netup_dma_interrupt(&ndev->dma[0]);\r\n} else if (reg_isr & NETUP_UNIDVB_IRQ_DMA2) {\r\niret = netup_dma_interrupt(&ndev->dma[1]);\r\n} else if (reg_isr & NETUP_UNIDVB_IRQ_CI) {\r\niret = netup_ci_interrupt(ndev);\r\n} else {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unknown interrupt 0x%x\n",\r\n__func__, reg_isr);\r\n}\r\n}\r\nwritel(AVL_IRQ_ENABLE, ndev->bmmio0 + AVL_PCIE_IENR);\r\nreturn iret;\r\n}\r\nstatic int netup_unidvb_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes,\r\nunsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct netup_dma *dma = vb2_get_drv_priv(vq);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s()\n", __func__);\r\n*nplanes = 1;\r\nif (vq->num_buffers + *nbuffers < VIDEO_MAX_FRAME)\r\n*nbuffers = VIDEO_MAX_FRAME - vq->num_buffers;\r\nsizes[0] = PAGE_ALIGN(NETUP_DMA_PACKETS_COUNT * 188);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s() nbuffers=%d sizes[0]=%d\n",\r\n__func__, *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct netup_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct netup_unidvb_buffer *buf = container_of(vbuf,\r\nstruct netup_unidvb_buffer, vb);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s(): buf 0x%p\n", __func__, buf);\r\nbuf->size = 0;\r\nreturn 0;\r\n}\r\nstatic void netup_unidvb_buf_queue(struct vb2_buffer *vb)\r\n{\r\nunsigned long flags;\r\nstruct netup_dma *dma = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct netup_unidvb_buffer *buf = container_of(vbuf,\r\nstruct netup_unidvb_buffer, vb);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s(): %p\n", __func__, buf);\r\nspin_lock_irqsave(&dma->lock, flags);\r\nlist_add_tail(&buf->list, &dma->free_buffers);\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\nmod_timer(&dma->timeout, jiffies + msecs_to_jiffies(1000));\r\n}\r\nstatic int netup_unidvb_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct netup_dma *dma = vb2_get_drv_priv(q);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s()\n", __func__);\r\nnetup_unidvb_dma_enable(dma, 1);\r\nreturn 0;\r\n}\r\nstatic void netup_unidvb_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct netup_dma *dma = vb2_get_drv_priv(q);\r\ndev_dbg(&dma->ndev->pci_dev->dev, "%s()\n", __func__);\r\nnetup_unidvb_dma_enable(dma, 0);\r\nnetup_unidvb_queue_cleanup(dma);\r\n}\r\nstatic int netup_unidvb_queue_init(struct netup_dma *dma,\r\nstruct vb2_queue *vb_queue)\r\n{\r\nint res;\r\nvb_queue->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvb_queue->io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\nvb_queue->drv_priv = dma;\r\nvb_queue->buf_struct_size = sizeof(struct netup_unidvb_buffer);\r\nvb_queue->ops = &dvb_qops;\r\nvb_queue->mem_ops = &vb2_vmalloc_memops;\r\nvb_queue->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nres = vb2_queue_init(vb_queue);\r\nif (res != 0) {\r\ndev_err(&dma->ndev->pci_dev->dev,\r\n"%s(): vb2_queue_init failed (%d)\n", __func__, res);\r\n}\r\nreturn res;\r\n}\r\nstatic int netup_unidvb_dvb_init(struct netup_unidvb_dev *ndev,\r\nint num)\r\n{\r\nint fe_count = 2;\r\nint i = 0;\r\nstruct vb2_dvb_frontend *fes[2];\r\nu8 fe_name[32];\r\nif (ndev->rev == NETUP_HW_REV_1_3)\r\ndemod_config.xtal = SONY_XTAL_20500;\r\nelse\r\ndemod_config.xtal = SONY_XTAL_24000;\r\nif (num < 0 || num > 1) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to init DVB bus %d\n", __func__, num);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&ndev->frontends[num].lock);\r\nINIT_LIST_HEAD(&ndev->frontends[num].felist);\r\nfor (i = 0; i < fe_count; i++) {\r\nif (vb2_dvb_alloc_frontend(&ndev->frontends[num], i+1)\r\n== NULL) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): unable to allocate vb2_dvb_frontend\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < fe_count; i++) {\r\nfes[i] = vb2_dvb_get_frontend(&ndev->frontends[num], i+1);\r\nif (fes[i] == NULL) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): frontends has not been allocated\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < fe_count; i++) {\r\nnetup_unidvb_queue_init(&ndev->dma[num], &fes[i]->dvb.dvbq);\r\nsnprintf(fe_name, sizeof(fe_name), "netup_fe%d", i);\r\nfes[i]->dvb.name = fe_name;\r\n}\r\nfes[0]->dvb.frontend = dvb_attach(cxd2841er_attach_s,\r\n&demod_config, &ndev->i2c[num].adap);\r\nif (fes[0]->dvb.frontend == NULL) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to attach DVB-S/S2 frontend\n",\r\n__func__);\r\ngoto frontend_detach;\r\n}\r\nif (ndev->rev == NETUP_HW_REV_1_3) {\r\nhorus3a_conf.set_tuner_priv = &ndev->dma[num];\r\nif (!dvb_attach(horus3a_attach, fes[0]->dvb.frontend,\r\n&horus3a_conf, &ndev->i2c[num].adap)) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to attach HORUS3A DVB-S/S2 tuner frontend\n",\r\n__func__);\r\ngoto frontend_detach;\r\n}\r\n} else {\r\nhelene_conf.set_tuner_priv = &ndev->dma[num];\r\nif (!dvb_attach(helene_attach_s, fes[0]->dvb.frontend,\r\n&helene_conf, &ndev->i2c[num].adap)) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): unable to attach HELENE DVB-S/S2 tuner frontend\n",\r\n__func__);\r\ngoto frontend_detach;\r\n}\r\n}\r\nif (!dvb_attach(lnbh25_attach, fes[0]->dvb.frontend,\r\n&lnbh25_conf, &ndev->i2c[num].adap)) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to attach SEC frontend\n", __func__);\r\ngoto frontend_detach;\r\n}\r\nfes[1]->dvb.frontend = dvb_attach(cxd2841er_attach_t_c,\r\n&demod_config, &ndev->i2c[num].adap);\r\nif (fes[1]->dvb.frontend == NULL) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to attach Ter frontend\n", __func__);\r\ngoto frontend_detach;\r\n}\r\nfes[1]->dvb.frontend->id = 1;\r\nif (ndev->rev == NETUP_HW_REV_1_3) {\r\nascot2e_conf.set_tuner_priv = &ndev->dma[num];\r\nif (!dvb_attach(ascot2e_attach, fes[1]->dvb.frontend,\r\n&ascot2e_conf, &ndev->i2c[num].adap)) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to attach Ter tuner frontend\n",\r\n__func__);\r\ngoto frontend_detach;\r\n}\r\n} else {\r\nhelene_conf.set_tuner_priv = &ndev->dma[num];\r\nif (!dvb_attach(helene_attach, fes[1]->dvb.frontend,\r\n&helene_conf, &ndev->i2c[num].adap)) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): unable to attach HELENE Ter tuner frontend\n",\r\n__func__);\r\ngoto frontend_detach;\r\n}\r\n}\r\nif (vb2_dvb_register_bus(&ndev->frontends[num],\r\nTHIS_MODULE, NULL,\r\n&ndev->pci_dev->dev, NULL, adapter_nr, 1)) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): unable to register DVB bus %d\n",\r\n__func__, num);\r\ngoto frontend_detach;\r\n}\r\ndev_info(&ndev->pci_dev->dev, "DVB init done, num=%d\n", num);\r\nreturn 0;\r\nfrontend_detach:\r\nvb2_dvb_dealloc_frontends(&ndev->frontends[num]);\r\nreturn -EINVAL;\r\n}\r\nstatic void netup_unidvb_dvb_fini(struct netup_unidvb_dev *ndev, int num)\r\n{\r\nif (num < 0 || num > 1) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): unable to unregister DVB bus %d\n",\r\n__func__, num);\r\nreturn;\r\n}\r\nvb2_dvb_unregister_bus(&ndev->frontends[num]);\r\ndev_info(&ndev->pci_dev->dev,\r\n"%s(): DVB bus %d unregistered\n", __func__, num);\r\n}\r\nstatic int netup_unidvb_dvb_setup(struct netup_unidvb_dev *ndev)\r\n{\r\nint res;\r\nres = netup_unidvb_dvb_init(ndev, 0);\r\nif (res)\r\nreturn res;\r\nres = netup_unidvb_dvb_init(ndev, 1);\r\nif (res) {\r\nnetup_unidvb_dvb_fini(ndev, 0);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_ring_copy(struct netup_dma *dma,\r\nstruct netup_unidvb_buffer *buf)\r\n{\r\nu32 copy_bytes, ring_bytes;\r\nu32 buff_bytes = NETUP_DMA_PACKETS_COUNT * 188 - buf->size;\r\nu8 *p = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nstruct netup_unidvb_dev *ndev = dma->ndev;\r\nif (p == NULL) {\r\ndev_err(&ndev->pci_dev->dev,\r\n"%s(): buffer is NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\np += buf->size;\r\nif (dma->data_offset + dma->data_size > dma->ring_buffer_size) {\r\nring_bytes = dma->ring_buffer_size - dma->data_offset;\r\ncopy_bytes = (ring_bytes > buff_bytes) ?\r\nbuff_bytes : ring_bytes;\r\nmemcpy_fromio(p, (u8 __iomem *)(dma->addr_virt + dma->data_offset), copy_bytes);\r\np += copy_bytes;\r\nbuf->size += copy_bytes;\r\nbuff_bytes -= copy_bytes;\r\ndma->data_size -= copy_bytes;\r\ndma->data_offset += copy_bytes;\r\nif (dma->data_offset == dma->ring_buffer_size)\r\ndma->data_offset = 0;\r\n}\r\nif (buff_bytes > 0) {\r\nring_bytes = dma->data_size;\r\ncopy_bytes = (ring_bytes > buff_bytes) ?\r\nbuff_bytes : ring_bytes;\r\nmemcpy_fromio(p, (u8 __iomem *)(dma->addr_virt + dma->data_offset), copy_bytes);\r\nbuf->size += copy_bytes;\r\ndma->data_size -= copy_bytes;\r\ndma->data_offset += copy_bytes;\r\nif (dma->data_offset == dma->ring_buffer_size)\r\ndma->data_offset = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void netup_unidvb_dma_worker(struct work_struct *work)\r\n{\r\nstruct netup_dma *dma = container_of(work, struct netup_dma, work);\r\nstruct netup_unidvb_dev *ndev = dma->ndev;\r\nstruct netup_unidvb_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dma->lock, flags);\r\nif (dma->data_size == 0) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): data_size == 0\n", __func__);\r\ngoto work_done;\r\n}\r\nwhile (dma->data_size > 0) {\r\nif (list_empty(&dma->free_buffers)) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): no free buffers\n", __func__);\r\ngoto work_done;\r\n}\r\nbuf = list_first_entry(&dma->free_buffers,\r\nstruct netup_unidvb_buffer, list);\r\nif (buf->size >= NETUP_DMA_PACKETS_COUNT * 188) {\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): buffer overflow, size %d\n",\r\n__func__, buf->size);\r\ngoto work_done;\r\n}\r\nif (netup_unidvb_ring_copy(dma, buf))\r\ngoto work_done;\r\nif (buf->size == NETUP_DMA_PACKETS_COUNT * 188) {\r\nlist_del(&buf->list);\r\ndev_dbg(&ndev->pci_dev->dev,\r\n"%s(): buffer %p done, size %d\n",\r\n__func__, buf, buf->size);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, buf->size);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\n}\r\nwork_done:\r\ndma->data_size = 0;\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\n}\r\nstatic void netup_unidvb_queue_cleanup(struct netup_dma *dma)\r\n{\r\nstruct netup_unidvb_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dma->lock, flags);\r\nwhile (!list_empty(&dma->free_buffers)) {\r\nbuf = list_first_entry(&dma->free_buffers,\r\nstruct netup_unidvb_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dma->lock, flags);\r\n}\r\nstatic void netup_unidvb_dma_timeout(unsigned long data)\r\n{\r\nstruct netup_dma *dma = (struct netup_dma *)data;\r\nstruct netup_unidvb_dev *ndev = dma->ndev;\r\ndev_dbg(&ndev->pci_dev->dev, "%s()\n", __func__);\r\nnetup_unidvb_queue_cleanup(dma);\r\n}\r\nstatic int netup_unidvb_dma_init(struct netup_unidvb_dev *ndev, int num)\r\n{\r\nstruct netup_dma *dma;\r\nstruct device *dev = &ndev->pci_dev->dev;\r\nif (num < 0 || num > 1) {\r\ndev_err(dev, "%s(): unable to register DMA%d\n",\r\n__func__, num);\r\nreturn -ENODEV;\r\n}\r\ndma = &ndev->dma[num];\r\ndev_info(dev, "%s(): starting DMA%d\n", __func__, num);\r\ndma->num = num;\r\ndma->ndev = ndev;\r\nspin_lock_init(&dma->lock);\r\nINIT_WORK(&dma->work, netup_unidvb_dma_worker);\r\nINIT_LIST_HEAD(&dma->free_buffers);\r\ndma->timeout.function = netup_unidvb_dma_timeout;\r\ndma->timeout.data = (unsigned long)dma;\r\ninit_timer(&dma->timeout);\r\ndma->ring_buffer_size = ndev->dma_size / 2;\r\ndma->addr_virt = ndev->dma_virt + dma->ring_buffer_size * num;\r\ndma->addr_phys = (dma_addr_t)((u64)ndev->dma_phys +\r\ndma->ring_buffer_size * num);\r\ndev_info(dev, "%s(): DMA%d buffer virt/phys 0x%p/0x%llx size %d\n",\r\n__func__, num, dma->addr_virt,\r\n(unsigned long long)dma->addr_phys,\r\ndma->ring_buffer_size);\r\nmemset_io((u8 __iomem *)dma->addr_virt, 0, dma->ring_buffer_size);\r\ndma->addr_last = dma->addr_phys;\r\ndma->high_addr = (u32)(dma->addr_phys & 0xC0000000);\r\ndma->regs = (struct netup_dma_regs __iomem *)(num == 0 ?\r\nndev->bmmio0 + NETUP_DMA0_ADDR :\r\nndev->bmmio0 + NETUP_DMA1_ADDR);\r\nwritel((NETUP_DMA_BLOCKS_COUNT << 24) |\r\n(NETUP_DMA_PACKETS_COUNT << 8) | 188, &dma->regs->size);\r\nwritel((u32)(dma->addr_phys & 0x3FFFFFFF), &dma->regs->start_addr_lo);\r\nwritel(0, &dma->regs->start_addr_hi);\r\nwritel(dma->high_addr, ndev->bmmio0 + 0x1000);\r\nwritel(375000000, &dma->regs->timeout);\r\nmsleep(1000);\r\nwritel(BIT_DMA_IRQ, &dma->regs->ctrlstat_clear);\r\nreturn 0;\r\n}\r\nstatic void netup_unidvb_dma_fini(struct netup_unidvb_dev *ndev, int num)\r\n{\r\nstruct netup_dma *dma;\r\nif (num < 0 || num > 1)\r\nreturn;\r\ndev_dbg(&ndev->pci_dev->dev, "%s(): num %d\n", __func__, num);\r\ndma = &ndev->dma[num];\r\nnetup_unidvb_dma_enable(dma, 0);\r\nmsleep(50);\r\ncancel_work_sync(&dma->work);\r\ndel_timer(&dma->timeout);\r\n}\r\nstatic int netup_unidvb_dma_setup(struct netup_unidvb_dev *ndev)\r\n{\r\nint res;\r\nres = netup_unidvb_dma_init(ndev, 0);\r\nif (res)\r\nreturn res;\r\nres = netup_unidvb_dma_init(ndev, 1);\r\nif (res) {\r\nnetup_unidvb_dma_fini(ndev, 0);\r\nreturn res;\r\n}\r\nnetup_unidvb_dma_enable(&ndev->dma[0], 0);\r\nnetup_unidvb_dma_enable(&ndev->dma[1], 0);\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_ci_setup(struct netup_unidvb_dev *ndev,\r\nstruct pci_dev *pci_dev)\r\n{\r\nint res;\r\nwritew(NETUP_UNIDVB_IRQ_CI, ndev->bmmio0 + REG_IMASK_SET);\r\nres = netup_unidvb_ci_register(ndev, 0, pci_dev);\r\nif (res)\r\nreturn res;\r\nres = netup_unidvb_ci_register(ndev, 1, pci_dev);\r\nif (res)\r\nnetup_unidvb_ci_unregister(ndev, 0);\r\nreturn res;\r\n}\r\nstatic int netup_unidvb_request_mmio(struct pci_dev *pci_dev)\r\n{\r\nif (!request_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0), NETUP_UNIDVB_NAME)) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to request MMIO bar 0 at 0x%llx\n",\r\n__func__,\r\n(unsigned long long)pci_resource_start(pci_dev, 0));\r\nreturn -EBUSY;\r\n}\r\nif (!request_mem_region(pci_resource_start(pci_dev, 1),\r\npci_resource_len(pci_dev, 1), NETUP_UNIDVB_NAME)) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to request MMIO bar 1 at 0x%llx\n",\r\n__func__,\r\n(unsigned long long)pci_resource_start(pci_dev, 1));\r\nrelease_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_request_modules(struct device *dev)\r\n{\r\nstatic const char * const modules[] = {\r\n"lnbh25", "ascot2e", "horus3a", "cxd2841er", "helene", NULL\r\n};\r\nconst char * const *curr_mod = modules;\r\nint err;\r\nwhile (*curr_mod != NULL) {\r\nerr = request_module(*curr_mod);\r\nif (err) {\r\ndev_warn(dev, "request_module(%s) failed: %d\n",\r\n*curr_mod, err);\r\n}\r\n++curr_mod;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netup_unidvb_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nu8 board_revision;\r\nu16 board_vendor;\r\nstruct netup_unidvb_dev *ndev;\r\nint old_firmware = 0;\r\nnetup_unidvb_request_modules(&pci_dev->dev);\r\nif (pci_dev->revision != NETUP_PCI_DEV_REVISION) {\r\ndev_err(&pci_dev->dev,\r\n"netup_unidvb: expected card revision %d, got %d\n",\r\nNETUP_PCI_DEV_REVISION, pci_dev->revision);\r\ndev_err(&pci_dev->dev,\r\n"Please upgrade firmware!\n");\r\ndev_err(&pci_dev->dev,\r\n"Instructions on http://www.netup.tv\n");\r\nold_firmware = 1;\r\nspi_enable = 1;\r\n}\r\nndev = kzalloc(sizeof(*ndev), GFP_KERNEL);\r\nif (!ndev)\r\ngoto dev_alloc_err;\r\nif (pci_dev->device == NETUP_HW_REV_1_3)\r\nndev->rev = NETUP_HW_REV_1_3;\r\nelse\r\nndev->rev = NETUP_HW_REV_1_4;\r\ndev_info(&pci_dev->dev,\r\n"%s(): board (0x%x) hardware revision 0x%x\n",\r\n__func__, pci_dev->device, ndev->rev);\r\nndev->old_fw = old_firmware;\r\nndev->wq = create_singlethread_workqueue(NETUP_UNIDVB_NAME);\r\nif (!ndev->wq) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to create workqueue\n", __func__);\r\ngoto wq_create_err;\r\n}\r\nndev->pci_dev = pci_dev;\r\nndev->pci_bus = pci_dev->bus->number;\r\nndev->pci_slot = PCI_SLOT(pci_dev->devfn);\r\nndev->pci_func = PCI_FUNC(pci_dev->devfn);\r\nndev->board_num = ndev->pci_bus*10 + ndev->pci_slot;\r\npci_set_drvdata(pci_dev, ndev);\r\ndev_info(&pci_dev->dev, "%s(): PCI device (%d). Bus:0x%x Slot:0x%x\n",\r\n__func__, ndev->board_num, ndev->pci_bus, ndev->pci_slot);\r\nif (pci_enable_device(pci_dev)) {\r\ndev_err(&pci_dev->dev, "%s(): pci_enable_device failed\n",\r\n__func__);\r\ngoto pci_enable_err;\r\n}\r\npci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &board_revision);\r\npci_read_config_word(pci_dev, PCI_VENDOR_ID, &board_vendor);\r\nif (board_vendor != NETUP_VENDOR_ID) {\r\ndev_err(&pci_dev->dev, "%s(): unknown board vendor 0x%x",\r\n__func__, board_vendor);\r\ngoto pci_detect_err;\r\n}\r\ndev_info(&pci_dev->dev,\r\n"%s(): board vendor 0x%x, revision 0x%x\n",\r\n__func__, board_vendor, board_revision);\r\npci_set_master(pci_dev);\r\nif (pci_set_dma_mask(pci_dev, 0xffffffff) < 0) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): 32bit PCI DMA is not supported\n", __func__);\r\ngoto pci_detect_err;\r\n}\r\ndev_info(&pci_dev->dev, "%s(): using 32bit PCI DMA\n", __func__);\r\npcie_capability_clear_and_set_word(pci_dev, PCI_EXP_DEVCTL,\r\nPCI_EXP_DEVCTL_READRQ | PCI_EXP_DEVCTL_RELAX_EN |\r\nPCI_EXP_DEVCTL_NOSNOOP_EN, 0);\r\npcie_capability_clear_and_set_word(pci_dev,\r\nPCI_EXP_DEVCTL2, 0xf, 0x2);\r\nif (netup_unidvb_request_mmio(pci_dev)) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to request MMIO regions\n", __func__);\r\ngoto pci_detect_err;\r\n}\r\nndev->lmmio0 = ioremap(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nif (!ndev->lmmio0) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to remap MMIO bar 0\n", __func__);\r\ngoto pci_bar0_error;\r\n}\r\nndev->lmmio1 = ioremap(pci_resource_start(pci_dev, 1),\r\npci_resource_len(pci_dev, 1));\r\nif (!ndev->lmmio1) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): unable to remap MMIO bar 1\n", __func__);\r\ngoto pci_bar1_error;\r\n}\r\nndev->bmmio0 = (u8 __iomem *)ndev->lmmio0;\r\nndev->bmmio1 = (u8 __iomem *)ndev->lmmio1;\r\ndev_info(&pci_dev->dev,\r\n"%s(): PCI MMIO at 0x%p (%d); 0x%p (%d); IRQ %d",\r\n__func__,\r\nndev->lmmio0, (u32)pci_resource_len(pci_dev, 0),\r\nndev->lmmio1, (u32)pci_resource_len(pci_dev, 1),\r\npci_dev->irq);\r\nif (request_irq(pci_dev->irq, netup_unidvb_isr, IRQF_SHARED,\r\n"netup_unidvb", pci_dev) < 0) {\r\ndev_err(&pci_dev->dev,\r\n"%s(): can't get IRQ %d\n", __func__, pci_dev->irq);\r\ngoto irq_request_err;\r\n}\r\nndev->dma_size = 2 * 188 *\r\nNETUP_DMA_BLOCKS_COUNT * NETUP_DMA_PACKETS_COUNT;\r\nndev->dma_virt = dma_alloc_coherent(&pci_dev->dev,\r\nndev->dma_size, &ndev->dma_phys, GFP_KERNEL);\r\nif (!ndev->dma_virt) {\r\ndev_err(&pci_dev->dev, "%s(): unable to allocate DMA buffer\n",\r\n__func__);\r\ngoto dma_alloc_err;\r\n}\r\nnetup_unidvb_dev_enable(ndev);\r\nif (spi_enable && netup_spi_init(ndev)) {\r\ndev_warn(&pci_dev->dev,\r\n"netup_unidvb: SPI flash setup failed\n");\r\ngoto spi_setup_err;\r\n}\r\nif (old_firmware) {\r\ndev_err(&pci_dev->dev,\r\n"netup_unidvb: card initialization was incomplete\n");\r\nreturn 0;\r\n}\r\nif (netup_i2c_register(ndev)) {\r\ndev_err(&pci_dev->dev, "netup_unidvb: I2C setup failed\n");\r\ngoto i2c_setup_err;\r\n}\r\nwritew(NETUP_UNIDVB_IRQ_I2C0 | NETUP_UNIDVB_IRQ_I2C1,\r\nndev->bmmio0 + REG_IMASK_SET);\r\nusleep_range(5000, 10000);\r\nif (netup_unidvb_dvb_setup(ndev)) {\r\ndev_err(&pci_dev->dev, "netup_unidvb: DVB setup failed\n");\r\ngoto dvb_setup_err;\r\n}\r\nif (netup_unidvb_ci_setup(ndev, pci_dev)) {\r\ndev_err(&pci_dev->dev, "netup_unidvb: CI setup failed\n");\r\ngoto ci_setup_err;\r\n}\r\nif (netup_unidvb_dma_setup(ndev)) {\r\ndev_err(&pci_dev->dev, "netup_unidvb: DMA setup failed\n");\r\ngoto dma_setup_err;\r\n}\r\ndev_info(&pci_dev->dev,\r\n"netup_unidvb: device has been initialized\n");\r\nreturn 0;\r\ndma_setup_err:\r\nnetup_unidvb_ci_unregister(ndev, 0);\r\nnetup_unidvb_ci_unregister(ndev, 1);\r\nci_setup_err:\r\nnetup_unidvb_dvb_fini(ndev, 0);\r\nnetup_unidvb_dvb_fini(ndev, 1);\r\ndvb_setup_err:\r\nnetup_i2c_unregister(ndev);\r\ni2c_setup_err:\r\nif (ndev->spi)\r\nnetup_spi_release(ndev);\r\nspi_setup_err:\r\ndma_free_coherent(&pci_dev->dev, ndev->dma_size,\r\nndev->dma_virt, ndev->dma_phys);\r\ndma_alloc_err:\r\nfree_irq(pci_dev->irq, pci_dev);\r\nirq_request_err:\r\niounmap(ndev->lmmio1);\r\npci_bar1_error:\r\niounmap(ndev->lmmio0);\r\npci_bar0_error:\r\nrelease_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nrelease_mem_region(pci_resource_start(pci_dev, 1),\r\npci_resource_len(pci_dev, 1));\r\npci_detect_err:\r\npci_disable_device(pci_dev);\r\npci_enable_err:\r\npci_set_drvdata(pci_dev, NULL);\r\ndestroy_workqueue(ndev->wq);\r\nwq_create_err:\r\nkfree(ndev);\r\ndev_alloc_err:\r\ndev_err(&pci_dev->dev,\r\n"%s(): failed to initialize device\n", __func__);\r\nreturn -EIO;\r\n}\r\nstatic void netup_unidvb_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct netup_unidvb_dev *ndev = pci_get_drvdata(pci_dev);\r\ndev_info(&pci_dev->dev, "%s(): trying to stop device\n", __func__);\r\nif (!ndev->old_fw) {\r\nnetup_unidvb_dma_fini(ndev, 0);\r\nnetup_unidvb_dma_fini(ndev, 1);\r\nnetup_unidvb_ci_unregister(ndev, 0);\r\nnetup_unidvb_ci_unregister(ndev, 1);\r\nnetup_unidvb_dvb_fini(ndev, 0);\r\nnetup_unidvb_dvb_fini(ndev, 1);\r\nnetup_i2c_unregister(ndev);\r\n}\r\nif (ndev->spi)\r\nnetup_spi_release(ndev);\r\nwritew(0xffff, ndev->bmmio0 + REG_IMASK_CLEAR);\r\ndma_free_coherent(&ndev->pci_dev->dev, ndev->dma_size,\r\nndev->dma_virt, ndev->dma_phys);\r\nfree_irq(pci_dev->irq, pci_dev);\r\niounmap(ndev->lmmio0);\r\niounmap(ndev->lmmio1);\r\nrelease_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nrelease_mem_region(pci_resource_start(pci_dev, 1),\r\npci_resource_len(pci_dev, 1));\r\npci_disable_device(pci_dev);\r\npci_set_drvdata(pci_dev, NULL);\r\ndestroy_workqueue(ndev->wq);\r\nkfree(ndev);\r\ndev_info(&pci_dev->dev,\r\n"%s(): device has been successfully stopped\n", __func__);\r\n}
