static bool max98371_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98371_IRQ_CLEAR1:\r\ncase MAX98371_IRQ_CLEAR2:\r\ncase MAX98371_IRQ_CLEAR3:\r\ncase MAX98371_VERSION:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98371_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98371_SOFT_RESET:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic int max98371_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98371_priv *max98371 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval |= MAX98371_DAI_RIGHT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= MAX98371_DAI_LEFT;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI wrong mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(max98371->regmap, MAX98371_FMT,\r\nMAX98371_FMT_MODE_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int max98371_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98371_priv *max98371 = snd_soc_codec_get_drvdata(codec);\r\nint blr_clk_ratio, ch_size, channels = params_channels(params);\r\nint rate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nregmap_update_bits(max98371->regmap, MAX98371_FMT,\r\nMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_16);\r\nch_size = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nregmap_update_bits(max98371->regmap, MAX98371_FMT,\r\nMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_16);\r\nch_size = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nregmap_update_bits(max98371->regmap, MAX98371_FMT,\r\nMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_32);\r\nch_size = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nregmap_update_bits(max98371->regmap, MAX98371_FMT,\r\nMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_32);\r\nch_size = 32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nblr_clk_ratio = channels * ch_size;\r\nswitch (blr_clk_ratio) {\r\ncase 32:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_DAI_CLK,\r\nMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_32);\r\nbreak;\r\ncase 48:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_DAI_CLK,\r\nMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_48);\r\nbreak;\r\ncase 64:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_DAI_CLK,\r\nMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_64);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (rate) {\r\ncase 32000:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_SPK_SR,\r\nMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_32);\r\nbreak;\r\ncase 44100:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_SPK_SR,\r\nMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_44);\r\nbreak;\r\ncase 48000:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_SPK_SR,\r\nMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_48);\r\nbreak;\r\ncase 88200:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_SPK_SR,\r\nMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_88);\r\nbreak;\r\ncase 96000:\r\nregmap_update_bits(max98371->regmap,\r\nMAX98371_SPK_SR,\r\nMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_96);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(max98371->regmap, MAX98371_MONOMIX_SRC,\r\nMAX98371_MONOMIX_SRC_MASK, MONOMIX_RX_0_1);\r\nregmap_update_bits(max98371->regmap, MAX98371_DAI_CHANNEL,\r\nMAX98371_CHANNEL_MASK, MAX98371_CHANNEL_MASK);\r\nreturn 0;\r\n}\r\nstatic int max98371_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max98371_priv *max98371;\r\nint ret, reg;\r\nmax98371 = devm_kzalloc(&i2c->dev,\r\nsizeof(*max98371), GFP_KERNEL);\r\nif (!max98371)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, max98371);\r\nmax98371->regmap = devm_regmap_init_i2c(i2c, &max98371_regmap);\r\nif (IS_ERR(max98371->regmap)) {\r\nret = PTR_ERR(max98371->regmap);\r\ndev_err(&i2c->dev,\r\n"Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(max98371->regmap, MAX98371_VERSION, &reg);\r\nif (ret < 0) {\r\ndev_info(&i2c->dev, "device error %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_info(&i2c->dev, "device version %x\n", reg);\r\nret = snd_soc_register_codec(&i2c->dev, &max98371_codec,\r\nmax98371_dai, ARRAY_SIZE(max98371_dai));\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int max98371_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
