static inline u64 mlt(u64 a, u64 b)\r\n{\r\nreturn a * b;\r\n}\r\nstatic inline u32 sr(u64 v, u_char n)\r\n{\r\nreturn v >> n;\r\n}\r\nstatic inline u32 and(u32 v, u32 mask)\r\n{\r\nreturn v & mask;\r\n}\r\nint crypto_poly1305_init(struct shash_desc *desc)\r\n{\r\nstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\r\nmemset(dctx->h, 0, sizeof(dctx->h));\r\ndctx->buflen = 0;\r\ndctx->rset = false;\r\ndctx->sset = false;\r\nreturn 0;\r\n}\r\nint crypto_poly1305_setkey(struct crypto_shash *tfm,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void poly1305_setrkey(struct poly1305_desc_ctx *dctx, const u8 *key)\r\n{\r\ndctx->r[0] = (get_unaligned_le32(key + 0) >> 0) & 0x3ffffff;\r\ndctx->r[1] = (get_unaligned_le32(key + 3) >> 2) & 0x3ffff03;\r\ndctx->r[2] = (get_unaligned_le32(key + 6) >> 4) & 0x3ffc0ff;\r\ndctx->r[3] = (get_unaligned_le32(key + 9) >> 6) & 0x3f03fff;\r\ndctx->r[4] = (get_unaligned_le32(key + 12) >> 8) & 0x00fffff;\r\n}\r\nstatic void poly1305_setskey(struct poly1305_desc_ctx *dctx, const u8 *key)\r\n{\r\ndctx->s[0] = get_unaligned_le32(key + 0);\r\ndctx->s[1] = get_unaligned_le32(key + 4);\r\ndctx->s[2] = get_unaligned_le32(key + 8);\r\ndctx->s[3] = get_unaligned_le32(key + 12);\r\n}\r\nunsigned int crypto_poly1305_setdesckey(struct poly1305_desc_ctx *dctx,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nif (!dctx->sset) {\r\nif (!dctx->rset && srclen >= POLY1305_BLOCK_SIZE) {\r\npoly1305_setrkey(dctx, src);\r\nsrc += POLY1305_BLOCK_SIZE;\r\nsrclen -= POLY1305_BLOCK_SIZE;\r\ndctx->rset = true;\r\n}\r\nif (srclen >= POLY1305_BLOCK_SIZE) {\r\npoly1305_setskey(dctx, src);\r\nsrc += POLY1305_BLOCK_SIZE;\r\nsrclen -= POLY1305_BLOCK_SIZE;\r\ndctx->sset = true;\r\n}\r\n}\r\nreturn srclen;\r\n}\r\nstatic unsigned int poly1305_blocks(struct poly1305_desc_ctx *dctx,\r\nconst u8 *src, unsigned int srclen,\r\nu32 hibit)\r\n{\r\nu32 r0, r1, r2, r3, r4;\r\nu32 s1, s2, s3, s4;\r\nu32 h0, h1, h2, h3, h4;\r\nu64 d0, d1, d2, d3, d4;\r\nunsigned int datalen;\r\nif (unlikely(!dctx->sset)) {\r\ndatalen = crypto_poly1305_setdesckey(dctx, src, srclen);\r\nsrc += srclen - datalen;\r\nsrclen = datalen;\r\n}\r\nr0 = dctx->r[0];\r\nr1 = dctx->r[1];\r\nr2 = dctx->r[2];\r\nr3 = dctx->r[3];\r\nr4 = dctx->r[4];\r\ns1 = r1 * 5;\r\ns2 = r2 * 5;\r\ns3 = r3 * 5;\r\ns4 = r4 * 5;\r\nh0 = dctx->h[0];\r\nh1 = dctx->h[1];\r\nh2 = dctx->h[2];\r\nh3 = dctx->h[3];\r\nh4 = dctx->h[4];\r\nwhile (likely(srclen >= POLY1305_BLOCK_SIZE)) {\r\nh0 += (get_unaligned_le32(src + 0) >> 0) & 0x3ffffff;\r\nh1 += (get_unaligned_le32(src + 3) >> 2) & 0x3ffffff;\r\nh2 += (get_unaligned_le32(src + 6) >> 4) & 0x3ffffff;\r\nh3 += (get_unaligned_le32(src + 9) >> 6) & 0x3ffffff;\r\nh4 += (get_unaligned_le32(src + 12) >> 8) | hibit;\r\nd0 = mlt(h0, r0) + mlt(h1, s4) + mlt(h2, s3) +\r\nmlt(h3, s2) + mlt(h4, s1);\r\nd1 = mlt(h0, r1) + mlt(h1, r0) + mlt(h2, s4) +\r\nmlt(h3, s3) + mlt(h4, s2);\r\nd2 = mlt(h0, r2) + mlt(h1, r1) + mlt(h2, r0) +\r\nmlt(h3, s4) + mlt(h4, s3);\r\nd3 = mlt(h0, r3) + mlt(h1, r2) + mlt(h2, r1) +\r\nmlt(h3, r0) + mlt(h4, s4);\r\nd4 = mlt(h0, r4) + mlt(h1, r3) + mlt(h2, r2) +\r\nmlt(h3, r1) + mlt(h4, r0);\r\nd1 += sr(d0, 26); h0 = and(d0, 0x3ffffff);\r\nd2 += sr(d1, 26); h1 = and(d1, 0x3ffffff);\r\nd3 += sr(d2, 26); h2 = and(d2, 0x3ffffff);\r\nd4 += sr(d3, 26); h3 = and(d3, 0x3ffffff);\r\nh0 += sr(d4, 26) * 5; h4 = and(d4, 0x3ffffff);\r\nh1 += h0 >> 26; h0 = h0 & 0x3ffffff;\r\nsrc += POLY1305_BLOCK_SIZE;\r\nsrclen -= POLY1305_BLOCK_SIZE;\r\n}\r\ndctx->h[0] = h0;\r\ndctx->h[1] = h1;\r\ndctx->h[2] = h2;\r\ndctx->h[3] = h3;\r\ndctx->h[4] = h4;\r\nreturn srclen;\r\n}\r\nint crypto_poly1305_update(struct shash_desc *desc,\r\nconst u8 *src, unsigned int srclen)\r\n{\r\nstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\r\nunsigned int bytes;\r\nif (unlikely(dctx->buflen)) {\r\nbytes = min(srclen, POLY1305_BLOCK_SIZE - dctx->buflen);\r\nmemcpy(dctx->buf + dctx->buflen, src, bytes);\r\nsrc += bytes;\r\nsrclen -= bytes;\r\ndctx->buflen += bytes;\r\nif (dctx->buflen == POLY1305_BLOCK_SIZE) {\r\npoly1305_blocks(dctx, dctx->buf,\r\nPOLY1305_BLOCK_SIZE, 1 << 24);\r\ndctx->buflen = 0;\r\n}\r\n}\r\nif (likely(srclen >= POLY1305_BLOCK_SIZE)) {\r\nbytes = poly1305_blocks(dctx, src, srclen, 1 << 24);\r\nsrc += srclen - bytes;\r\nsrclen = bytes;\r\n}\r\nif (unlikely(srclen)) {\r\ndctx->buflen = srclen;\r\nmemcpy(dctx->buf, src, srclen);\r\n}\r\nreturn 0;\r\n}\r\nint crypto_poly1305_final(struct shash_desc *desc, u8 *dst)\r\n{\r\nstruct poly1305_desc_ctx *dctx = shash_desc_ctx(desc);\r\n__le32 *mac = (__le32 *)dst;\r\nu32 h0, h1, h2, h3, h4;\r\nu32 g0, g1, g2, g3, g4;\r\nu32 mask;\r\nu64 f = 0;\r\nif (unlikely(!dctx->sset))\r\nreturn -ENOKEY;\r\nif (unlikely(dctx->buflen)) {\r\ndctx->buf[dctx->buflen++] = 1;\r\nmemset(dctx->buf + dctx->buflen, 0,\r\nPOLY1305_BLOCK_SIZE - dctx->buflen);\r\npoly1305_blocks(dctx, dctx->buf, POLY1305_BLOCK_SIZE, 0);\r\n}\r\nh0 = dctx->h[0];\r\nh1 = dctx->h[1];\r\nh2 = dctx->h[2];\r\nh3 = dctx->h[3];\r\nh4 = dctx->h[4];\r\nh2 += (h1 >> 26); h1 = h1 & 0x3ffffff;\r\nh3 += (h2 >> 26); h2 = h2 & 0x3ffffff;\r\nh4 += (h3 >> 26); h3 = h3 & 0x3ffffff;\r\nh0 += (h4 >> 26) * 5; h4 = h4 & 0x3ffffff;\r\nh1 += (h0 >> 26); h0 = h0 & 0x3ffffff;\r\ng0 = h0 + 5;\r\ng1 = h1 + (g0 >> 26); g0 &= 0x3ffffff;\r\ng2 = h2 + (g1 >> 26); g1 &= 0x3ffffff;\r\ng3 = h3 + (g2 >> 26); g2 &= 0x3ffffff;\r\ng4 = h4 + (g3 >> 26) - (1 << 26); g3 &= 0x3ffffff;\r\nmask = (g4 >> ((sizeof(u32) * 8) - 1)) - 1;\r\ng0 &= mask;\r\ng1 &= mask;\r\ng2 &= mask;\r\ng3 &= mask;\r\ng4 &= mask;\r\nmask = ~mask;\r\nh0 = (h0 & mask) | g0;\r\nh1 = (h1 & mask) | g1;\r\nh2 = (h2 & mask) | g2;\r\nh3 = (h3 & mask) | g3;\r\nh4 = (h4 & mask) | g4;\r\nh0 = (h0 >> 0) | (h1 << 26);\r\nh1 = (h1 >> 6) | (h2 << 20);\r\nh2 = (h2 >> 12) | (h3 << 14);\r\nh3 = (h3 >> 18) | (h4 << 8);\r\nf = (f >> 32) + h0 + dctx->s[0]; mac[0] = cpu_to_le32(f);\r\nf = (f >> 32) + h1 + dctx->s[1]; mac[1] = cpu_to_le32(f);\r\nf = (f >> 32) + h2 + dctx->s[2]; mac[2] = cpu_to_le32(f);\r\nf = (f >> 32) + h3 + dctx->s[3]; mac[3] = cpu_to_le32(f);\r\nreturn 0;\r\n}\r\nstatic int __init poly1305_mod_init(void)\r\n{\r\nreturn crypto_register_shash(&poly1305_alg);\r\n}\r\nstatic void __exit poly1305_mod_exit(void)\r\n{\r\ncrypto_unregister_shash(&poly1305_alg);\r\n}
