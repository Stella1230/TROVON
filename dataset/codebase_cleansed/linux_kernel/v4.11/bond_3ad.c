static inline struct bonding *__get_bond_by_port(struct port *port)\r\n{\r\nif (port->slave == NULL)\r\nreturn NULL;\r\nreturn bond_get_bond_by_slave(port->slave);\r\n}\r\nstatic inline struct aggregator *__get_first_agg(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nstruct slave *first_slave;\r\nstruct aggregator *agg;\r\nif (bond == NULL)\r\nreturn NULL;\r\nrcu_read_lock();\r\nfirst_slave = bond_first_slave_rcu(bond);\r\nagg = first_slave ? &(SLAVE_AD_INFO(first_slave)->aggregator) : NULL;\r\nrcu_read_unlock();\r\nreturn agg;\r\n}\r\nstatic inline int __agg_has_partner(struct aggregator *agg)\r\n{\r\nreturn !is_zero_ether_addr(agg->partner_system.mac_addr_value);\r\n}\r\nstatic inline void __disable_port(struct port *port)\r\n{\r\nbond_set_slave_inactive_flags(port->slave, BOND_SLAVE_NOTIFY_LATER);\r\n}\r\nstatic inline void __enable_port(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nif ((slave->link == BOND_LINK_UP) && bond_slave_is_up(slave))\r\nbond_set_slave_active_flags(slave, BOND_SLAVE_NOTIFY_LATER);\r\n}\r\nstatic inline int __port_is_enabled(struct port *port)\r\n{\r\nreturn bond_is_active_slave(port->slave);\r\n}\r\nstatic inline u32 __get_agg_selection_mode(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nif (bond == NULL)\r\nreturn BOND_AD_STABLE;\r\nreturn bond->params.ad_select;\r\n}\r\nstatic inline int __check_agg_selection_timer(struct port *port)\r\n{\r\nstruct bonding *bond = __get_bond_by_port(port);\r\nif (bond == NULL)\r\nreturn 0;\r\nreturn BOND_AD_INFO(bond).agg_select_timer ? 1 : 0;\r\n}\r\nstatic u16 __get_link_speed(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nu16 speed;\r\nif (slave->link != BOND_LINK_UP)\r\nspeed = 0;\r\nelse {\r\nswitch (slave->speed) {\r\ncase SPEED_10:\r\nspeed = AD_LINK_SPEED_10MBPS;\r\nbreak;\r\ncase SPEED_100:\r\nspeed = AD_LINK_SPEED_100MBPS;\r\nbreak;\r\ncase SPEED_1000:\r\nspeed = AD_LINK_SPEED_1000MBPS;\r\nbreak;\r\ncase SPEED_2500:\r\nspeed = AD_LINK_SPEED_2500MBPS;\r\nbreak;\r\ncase SPEED_10000:\r\nspeed = AD_LINK_SPEED_10000MBPS;\r\nbreak;\r\ncase SPEED_20000:\r\nspeed = AD_LINK_SPEED_20000MBPS;\r\nbreak;\r\ncase SPEED_40000:\r\nspeed = AD_LINK_SPEED_40000MBPS;\r\nbreak;\r\ncase SPEED_56000:\r\nspeed = AD_LINK_SPEED_56000MBPS;\r\nbreak;\r\ncase SPEED_100000:\r\nspeed = AD_LINK_SPEED_100000MBPS;\r\nbreak;\r\ndefault:\r\nspeed = 0;\r\nbreak;\r\n}\r\n}\r\nnetdev_dbg(slave->bond->dev, "Port %d Received link speed %d update from adapter\n",\r\nport->actor_port_number, speed);\r\nreturn speed;\r\n}\r\nstatic u8 __get_duplex(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nu8 retval = 0x0;\r\nif (slave->link == BOND_LINK_UP) {\r\nswitch (slave->duplex) {\r\ncase DUPLEX_FULL:\r\nretval = 0x1;\r\nnetdev_dbg(slave->bond->dev, "Port %d Received status full duplex update from adapter\n",\r\nport->actor_port_number);\r\nbreak;\r\ncase DUPLEX_HALF:\r\ndefault:\r\nretval = 0x0;\r\nnetdev_dbg(slave->bond->dev, "Port %d Received status NOT full duplex update from adapter\n",\r\nport->actor_port_number);\r\nbreak;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void __ad_actor_update_port(struct port *port)\r\n{\r\nconst struct bonding *bond = bond_get_bond_by_slave(port->slave);\r\nport->actor_system = BOND_AD_INFO(bond).system.sys_mac_addr;\r\nport->actor_system_priority = BOND_AD_INFO(bond).system.sys_priority;\r\n}\r\nstatic u16 __ad_timer_to_ticks(u16 timer_type, u16 par)\r\n{\r\nu16 retval = 0;\r\nswitch (timer_type) {\r\ncase AD_CURRENT_WHILE_TIMER:\r\nif (par)\r\nretval = (AD_SHORT_TIMEOUT_TIME*ad_ticks_per_sec);\r\nelse\r\nretval = (AD_LONG_TIMEOUT_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_ACTOR_CHURN_TIMER:\r\nretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_PERIODIC_TIMER:\r\nretval = (par*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_PARTNER_CHURN_TIMER:\r\nretval = (AD_CHURN_DETECTION_TIME*ad_ticks_per_sec);\r\nbreak;\r\ncase AD_WAIT_WHILE_TIMER:\r\nretval = (AD_AGGREGATE_WAIT_TIME*ad_ticks_per_sec);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void __choose_matched(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (((ntohs(lacpdu->partner_port) == port->actor_port_number) &&\r\n(ntohs(lacpdu->partner_port_priority) == port->actor_port_priority) &&\r\nMAC_ADDRESS_EQUAL(&(lacpdu->partner_system), &(port->actor_system)) &&\r\n(ntohs(lacpdu->partner_system_priority) == port->actor_system_priority) &&\r\n(ntohs(lacpdu->partner_key) == port->actor_oper_port_key) &&\r\n((lacpdu->partner_state & AD_STATE_AGGREGATION) == (port->actor_oper_port_state & AD_STATE_AGGREGATION))) ||\r\n((lacpdu->actor_state & AD_STATE_AGGREGATION) == 0)\r\n) {\r\nport->sm_vars |= AD_PORT_MATCHED;\r\n} else {\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\n}\r\n}\r\nstatic void __record_pdu(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nstruct port_params *partner = &port->partner_oper;\r\n__choose_matched(lacpdu, port);\r\npartner->port_number = ntohs(lacpdu->actor_port);\r\npartner->port_priority = ntohs(lacpdu->actor_port_priority);\r\npartner->system = lacpdu->actor_system;\r\npartner->system_priority = ntohs(lacpdu->actor_system_priority);\r\npartner->key = ntohs(lacpdu->actor_key);\r\npartner->port_state = lacpdu->actor_state;\r\nport->actor_oper_port_state &= ~AD_STATE_DEFAULTED;\r\nif ((port->sm_vars & AD_PORT_MATCHED) &&\r\n(lacpdu->actor_state & AD_STATE_SYNCHRONIZATION)) {\r\npartner->port_state |= AD_STATE_SYNCHRONIZATION;\r\npr_debug("%s partner sync=1\n", port->slave->dev->name);\r\n} else {\r\npartner->port_state &= ~AD_STATE_SYNCHRONIZATION;\r\npr_debug("%s partner sync=0\n", port->slave->dev->name);\r\n}\r\n}\r\n}\r\nstatic void __record_default(struct port *port)\r\n{\r\nif (port) {\r\nmemcpy(&port->partner_oper, &port->partner_admin,\r\nsizeof(struct port_params));\r\nport->actor_oper_port_state |= AD_STATE_DEFAULTED;\r\n}\r\n}\r\nstatic void __update_selected(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nconst struct port_params *partner = &port->partner_oper;\r\nif (ntohs(lacpdu->actor_port) != partner->port_number ||\r\nntohs(lacpdu->actor_port_priority) != partner->port_priority ||\r\n!MAC_ADDRESS_EQUAL(&lacpdu->actor_system, &partner->system) ||\r\nntohs(lacpdu->actor_system_priority) != partner->system_priority ||\r\nntohs(lacpdu->actor_key) != partner->key ||\r\n(lacpdu->actor_state & AD_STATE_AGGREGATION) != (partner->port_state & AD_STATE_AGGREGATION)) {\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n}\r\n}\r\n}\r\nstatic void __update_default_selected(struct port *port)\r\n{\r\nif (port) {\r\nconst struct port_params *admin = &port->partner_admin;\r\nconst struct port_params *oper = &port->partner_oper;\r\nif (admin->port_number != oper->port_number ||\r\nadmin->port_priority != oper->port_priority ||\r\n!MAC_ADDRESS_EQUAL(&admin->system, &oper->system) ||\r\nadmin->system_priority != oper->system_priority ||\r\nadmin->key != oper->key ||\r\n(admin->port_state & AD_STATE_AGGREGATION)\r\n!= (oper->port_state & AD_STATE_AGGREGATION)) {\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n}\r\n}\r\n}\r\nstatic void __update_ntt(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nif (lacpdu && port) {\r\nif ((ntohs(lacpdu->partner_port) != port->actor_port_number) ||\r\n(ntohs(lacpdu->partner_port_priority) != port->actor_port_priority) ||\r\n!MAC_ADDRESS_EQUAL(&(lacpdu->partner_system), &(port->actor_system)) ||\r\n(ntohs(lacpdu->partner_system_priority) != port->actor_system_priority) ||\r\n(ntohs(lacpdu->partner_key) != port->actor_oper_port_key) ||\r\n((lacpdu->partner_state & AD_STATE_LACP_ACTIVITY) != (port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY)) ||\r\n((lacpdu->partner_state & AD_STATE_LACP_TIMEOUT) != (port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT)) ||\r\n((lacpdu->partner_state & AD_STATE_SYNCHRONIZATION) != (port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION)) ||\r\n((lacpdu->partner_state & AD_STATE_AGGREGATION) != (port->actor_oper_port_state & AD_STATE_AGGREGATION))\r\n) {\r\nport->ntt = true;\r\n}\r\n}\r\n}\r\nstatic int __agg_ports_are_ready(struct aggregator *aggregator)\r\n{\r\nstruct port *port;\r\nint retval = 1;\r\nif (aggregator) {\r\nfor (port = aggregator->lag_ports;\r\nport;\r\nport = port->next_port_in_aggregator) {\r\nif (!(port->sm_vars & AD_PORT_READY_N)) {\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic void __set_agg_ports_ready(struct aggregator *aggregator, int val)\r\n{\r\nstruct port *port;\r\nfor (port = aggregator->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\nif (val)\r\nport->sm_vars |= AD_PORT_READY;\r\nelse\r\nport->sm_vars &= ~AD_PORT_READY;\r\n}\r\n}\r\nstatic int __agg_active_ports(struct aggregator *agg)\r\n{\r\nstruct port *port;\r\nint active = 0;\r\nfor (port = agg->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\nif (port->is_enabled)\r\nactive++;\r\n}\r\nreturn active;\r\n}\r\nstatic u32 __get_agg_bandwidth(struct aggregator *aggregator)\r\n{\r\nint nports = __agg_active_ports(aggregator);\r\nu32 bandwidth = 0;\r\nif (nports) {\r\nswitch (__get_link_speed(aggregator->lag_ports)) {\r\ncase AD_LINK_SPEED_1MBPS:\r\nbandwidth = nports;\r\nbreak;\r\ncase AD_LINK_SPEED_10MBPS:\r\nbandwidth = nports * 10;\r\nbreak;\r\ncase AD_LINK_SPEED_100MBPS:\r\nbandwidth = nports * 100;\r\nbreak;\r\ncase AD_LINK_SPEED_1000MBPS:\r\nbandwidth = nports * 1000;\r\nbreak;\r\ncase AD_LINK_SPEED_2500MBPS:\r\nbandwidth = nports * 2500;\r\nbreak;\r\ncase AD_LINK_SPEED_10000MBPS:\r\nbandwidth = nports * 10000;\r\nbreak;\r\ncase AD_LINK_SPEED_20000MBPS:\r\nbandwidth = nports * 20000;\r\nbreak;\r\ncase AD_LINK_SPEED_40000MBPS:\r\nbandwidth = nports * 40000;\r\nbreak;\r\ncase AD_LINK_SPEED_56000MBPS:\r\nbandwidth = nports * 56000;\r\nbreak;\r\ncase AD_LINK_SPEED_100000MBPS:\r\nbandwidth = nports * 100000;\r\nbreak;\r\ndefault:\r\nbandwidth = 0;\r\n}\r\n}\r\nreturn bandwidth;\r\n}\r\nstatic struct aggregator *__get_active_agg(struct aggregator *aggregator)\r\n{\r\nstruct bonding *bond = aggregator->slave->bond;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nbond_for_each_slave_rcu(bond, slave, iter)\r\nif (SLAVE_AD_INFO(slave)->aggregator.is_active)\r\nreturn &(SLAVE_AD_INFO(slave)->aggregator);\r\nreturn NULL;\r\n}\r\nstatic inline void __update_lacpdu_from_port(struct port *port)\r\n{\r\nstruct lacpdu *lacpdu = &port->lacpdu;\r\nconst struct port_params *partner = &port->partner_oper;\r\nlacpdu->actor_system_priority = htons(port->actor_system_priority);\r\nlacpdu->actor_system = port->actor_system;\r\nlacpdu->actor_key = htons(port->actor_oper_port_key);\r\nlacpdu->actor_port_priority = htons(port->actor_port_priority);\r\nlacpdu->actor_port = htons(port->actor_port_number);\r\nlacpdu->actor_state = port->actor_oper_port_state;\r\npr_debug("update lacpdu: %s, actor port state %x\n",\r\nport->slave->dev->name, port->actor_oper_port_state);\r\nlacpdu->partner_system_priority = htons(partner->system_priority);\r\nlacpdu->partner_system = partner->system;\r\nlacpdu->partner_key = htons(partner->key);\r\nlacpdu->partner_port_priority = htons(partner->port_priority);\r\nlacpdu->partner_port = htons(partner->port_number);\r\nlacpdu->partner_state = partner->port_state;\r\n}\r\nstatic int ad_lacpdu_send(struct port *port)\r\n{\r\nstruct slave *slave = port->slave;\r\nstruct sk_buff *skb;\r\nstruct lacpdu_header *lacpdu_header;\r\nint length = sizeof(struct lacpdu_header);\r\nskb = dev_alloc_skb(length);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb->dev = slave->dev;\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = PKT_TYPE_LACPDU;\r\nskb->priority = TC_PRIO_CONTROL;\r\nlacpdu_header = (struct lacpdu_header *)skb_put(skb, length);\r\nether_addr_copy(lacpdu_header->hdr.h_dest, lacpdu_mcast_addr);\r\nether_addr_copy(lacpdu_header->hdr.h_source, slave->perm_hwaddr);\r\nlacpdu_header->hdr.h_proto = PKT_TYPE_LACPDU;\r\nlacpdu_header->lacpdu = port->lacpdu;\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\n}\r\nstatic int ad_marker_send(struct port *port, struct bond_marker *marker)\r\n{\r\nstruct slave *slave = port->slave;\r\nstruct sk_buff *skb;\r\nstruct bond_marker_header *marker_header;\r\nint length = sizeof(struct bond_marker_header);\r\nskb = dev_alloc_skb(length + 16);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nskb_reserve(skb, 16);\r\nskb->dev = slave->dev;\r\nskb_reset_mac_header(skb);\r\nskb->network_header = skb->mac_header + ETH_HLEN;\r\nskb->protocol = PKT_TYPE_LACPDU;\r\nmarker_header = (struct bond_marker_header *)skb_put(skb, length);\r\nether_addr_copy(marker_header->hdr.h_dest, lacpdu_mcast_addr);\r\nether_addr_copy(marker_header->hdr.h_source, slave->perm_hwaddr);\r\nmarker_header->hdr.h_proto = PKT_TYPE_LACPDU;\r\nmarker_header->marker = *marker;\r\ndev_queue_xmit(skb);\r\nreturn 0;\r\n}\r\nstatic void ad_mux_machine(struct port *port, bool *update_slave_arr)\r\n{\r\nmux_states_t last_state;\r\nlast_state = port->sm_mux_state;\r\nif (port->sm_vars & AD_PORT_BEGIN) {\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\n} else {\r\nswitch (port->sm_mux_state) {\r\ncase AD_MUX_DETACHED:\r\nif ((port->sm_vars & AD_PORT_SELECTED)\r\n|| (port->sm_vars & AD_PORT_STANDBY))\r\nport->sm_mux_state = AD_MUX_WAITING;\r\nbreak;\r\ncase AD_MUX_WAITING:\r\nif (!(port->sm_vars & AD_PORT_SELECTED)) {\r\nport->sm_vars &= ~AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\nbreak;\r\n}\r\nif (port->sm_mux_timer_counter\r\n&& !(--port->sm_mux_timer_counter))\r\nport->sm_vars |= AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nif ((port->sm_vars & AD_PORT_READY)\r\n&& !port->sm_mux_timer_counter)\r\nport->sm_mux_state = AD_MUX_ATTACHED;\r\nbreak;\r\ncase AD_MUX_ATTACHED:\r\nif ((port->sm_vars & AD_PORT_SELECTED) &&\r\n(port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) &&\r\n!__check_agg_selection_timer(port)) {\r\nif (port->aggregator->is_active)\r\nport->sm_mux_state =\r\nAD_MUX_COLLECTING_DISTRIBUTING;\r\n} else if (!(port->sm_vars & AD_PORT_SELECTED) ||\r\n(port->sm_vars & AD_PORT_STANDBY)) {\r\nport->sm_vars &= ~AD_PORT_READY_N;\r\n__set_agg_ports_ready(port->aggregator, __agg_ports_are_ready(port->aggregator));\r\nport->sm_mux_state = AD_MUX_DETACHED;\r\n} else if (port->aggregator->is_active) {\r\nport->actor_oper_port_state |=\r\nAD_STATE_SYNCHRONIZATION;\r\n}\r\nbreak;\r\ncase AD_MUX_COLLECTING_DISTRIBUTING:\r\nif (!(port->sm_vars & AD_PORT_SELECTED) ||\r\n(port->sm_vars & AD_PORT_STANDBY) ||\r\n!(port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) ||\r\n!(port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION)) {\r\nport->sm_mux_state = AD_MUX_ATTACHED;\r\n} else {\r\nif (port->aggregator &&\r\nport->aggregator->is_active &&\r\n!__port_is_enabled(port)) {\r\n__enable_port(port);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (port->sm_mux_state != last_state) {\r\npr_debug("Mux Machine: Port=%d (%s), Last State=%d, Curr State=%d\n",\r\nport->actor_port_number,\r\nport->slave->dev->name,\r\nlast_state,\r\nport->sm_mux_state);\r\nswitch (port->sm_mux_state) {\r\ncase AD_MUX_DETACHED:\r\nport->actor_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;\r\nad_disable_collecting_distributing(port,\r\nupdate_slave_arr);\r\nport->actor_oper_port_state &= ~AD_STATE_COLLECTING;\r\nport->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;\r\nport->ntt = true;\r\nbreak;\r\ncase AD_MUX_WAITING:\r\nport->sm_mux_timer_counter = __ad_timer_to_ticks(AD_WAIT_WHILE_TIMER, 0);\r\nbreak;\r\ncase AD_MUX_ATTACHED:\r\nif (port->aggregator->is_active)\r\nport->actor_oper_port_state |=\r\nAD_STATE_SYNCHRONIZATION;\r\nelse\r\nport->actor_oper_port_state &=\r\n~AD_STATE_SYNCHRONIZATION;\r\nport->actor_oper_port_state &= ~AD_STATE_COLLECTING;\r\nport->actor_oper_port_state &= ~AD_STATE_DISTRIBUTING;\r\nad_disable_collecting_distributing(port,\r\nupdate_slave_arr);\r\nport->ntt = true;\r\nbreak;\r\ncase AD_MUX_COLLECTING_DISTRIBUTING:\r\nport->actor_oper_port_state |= AD_STATE_COLLECTING;\r\nport->actor_oper_port_state |= AD_STATE_DISTRIBUTING;\r\nport->actor_oper_port_state |= AD_STATE_SYNCHRONIZATION;\r\nad_enable_collecting_distributing(port,\r\nupdate_slave_arr);\r\nport->ntt = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_rx_machine(struct lacpdu *lacpdu, struct port *port)\r\n{\r\nrx_states_t last_state;\r\nlast_state = port->sm_rx_state;\r\nif (port->sm_vars & AD_PORT_BEGIN) {\r\nport->sm_rx_state = AD_RX_INITIALIZE;\r\nport->sm_vars |= AD_PORT_CHURNED;\r\n} else if (!(port->sm_vars & AD_PORT_BEGIN)\r\n&& !port->is_enabled && !(port->sm_vars & AD_PORT_MOVED))\r\nport->sm_rx_state = AD_RX_PORT_DISABLED;\r\nelse if (lacpdu && ((port->sm_rx_state == AD_RX_EXPIRED) ||\r\n(port->sm_rx_state == AD_RX_DEFAULTED) ||\r\n(port->sm_rx_state == AD_RX_CURRENT))) {\r\nif (port->sm_rx_state != AD_RX_CURRENT)\r\nport->sm_vars |= AD_PORT_CHURNED;\r\nport->sm_rx_timer_counter = 0;\r\nport->sm_rx_state = AD_RX_CURRENT;\r\n} else {\r\nif (port->sm_rx_timer_counter &&\r\n!(--port->sm_rx_timer_counter)) {\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_EXPIRED:\r\nport->sm_rx_state = AD_RX_DEFAULTED;\r\nbreak;\r\ncase AD_RX_CURRENT:\r\nport->sm_rx_state = AD_RX_EXPIRED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_PORT_DISABLED:\r\nif (port->sm_vars & AD_PORT_MOVED)\r\nport->sm_rx_state = AD_RX_INITIALIZE;\r\nelse if (port->is_enabled\r\n&& (port->sm_vars\r\n& AD_PORT_LACP_ENABLED))\r\nport->sm_rx_state = AD_RX_EXPIRED;\r\nelse if (port->is_enabled\r\n&& ((port->sm_vars\r\n& AD_PORT_LACP_ENABLED) == 0))\r\nport->sm_rx_state = AD_RX_LACP_DISABLED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((port->sm_rx_state != last_state) || (lacpdu)) {\r\npr_debug("Rx Machine: Port=%d (%s), Last State=%d, Curr State=%d\n",\r\nport->actor_port_number,\r\nport->slave->dev->name,\r\nlast_state,\r\nport->sm_rx_state);\r\nswitch (port->sm_rx_state) {\r\ncase AD_RX_INITIALIZE:\r\nif (!(port->actor_oper_port_key & AD_DUPLEX_KEY_MASKS))\r\nport->sm_vars &= ~AD_PORT_LACP_ENABLED;\r\nelse\r\nport->sm_vars |= AD_PORT_LACP_ENABLED;\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n__record_default(port);\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nport->sm_vars &= ~AD_PORT_MOVED;\r\nport->sm_rx_state = AD_RX_PORT_DISABLED;\r\ncase AD_RX_PORT_DISABLED:\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\nbreak;\r\ncase AD_RX_LACP_DISABLED:\r\nport->sm_vars &= ~AD_PORT_SELECTED;\r\n__record_default(port);\r\nport->partner_oper.port_state &= ~AD_STATE_AGGREGATION;\r\nport->sm_vars |= AD_PORT_MATCHED;\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ncase AD_RX_EXPIRED:\r\nport->partner_oper.port_state &= ~AD_STATE_SYNCHRONIZATION;\r\nport->sm_vars &= ~AD_PORT_MATCHED;\r\nport->partner_oper.port_state |= AD_STATE_LACP_TIMEOUT;\r\nport->partner_oper.port_state |= AD_STATE_LACP_ACTIVITY;\r\nport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(AD_SHORT_TIMEOUT));\r\nport->actor_oper_port_state |= AD_STATE_EXPIRED;\r\nport->sm_vars |= AD_PORT_CHURNED;\r\nbreak;\r\ncase AD_RX_DEFAULTED:\r\n__update_default_selected(port);\r\n__record_default(port);\r\nport->sm_vars |= AD_PORT_MATCHED;\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ncase AD_RX_CURRENT:\r\nif (MAC_ADDRESS_EQUAL(&(lacpdu->actor_system),\r\n&(port->actor_system))) {\r\nnetdev_err(port->slave->bond->dev, "An illegal loopback occurred on adapter (%s)\n"\r\n"Check the configuration to verify that all adapters are connected to 802.3ad compliant switch ports\n",\r\nport->slave->dev->name);\r\nreturn;\r\n}\r\n__update_selected(lacpdu, port);\r\n__update_ntt(lacpdu, port);\r\n__record_pdu(lacpdu, port);\r\nport->sm_rx_timer_counter = __ad_timer_to_ticks(AD_CURRENT_WHILE_TIMER, (u16)(port->actor_oper_port_state & AD_STATE_LACP_TIMEOUT));\r\nport->actor_oper_port_state &= ~AD_STATE_EXPIRED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_churn_machine(struct port *port)\r\n{\r\nif (port->sm_vars & AD_PORT_CHURNED) {\r\nport->sm_vars &= ~AD_PORT_CHURNED;\r\nport->sm_churn_actor_state = AD_CHURN_MONITOR;\r\nport->sm_churn_partner_state = AD_CHURN_MONITOR;\r\nport->sm_churn_actor_timer_counter =\r\n__ad_timer_to_ticks(AD_ACTOR_CHURN_TIMER, 0);\r\nport->sm_churn_partner_timer_counter =\r\n__ad_timer_to_ticks(AD_PARTNER_CHURN_TIMER, 0);\r\nreturn;\r\n}\r\nif (port->sm_churn_actor_timer_counter &&\r\n!(--port->sm_churn_actor_timer_counter) &&\r\nport->sm_churn_actor_state == AD_CHURN_MONITOR) {\r\nif (port->actor_oper_port_state & AD_STATE_SYNCHRONIZATION) {\r\nport->sm_churn_actor_state = AD_NO_CHURN;\r\n} else {\r\nport->churn_actor_count++;\r\nport->sm_churn_actor_state = AD_CHURN;\r\n}\r\n}\r\nif (port->sm_churn_partner_timer_counter &&\r\n!(--port->sm_churn_partner_timer_counter) &&\r\nport->sm_churn_partner_state == AD_CHURN_MONITOR) {\r\nif (port->partner_oper.port_state & AD_STATE_SYNCHRONIZATION) {\r\nport->sm_churn_partner_state = AD_NO_CHURN;\r\n} else {\r\nport->churn_partner_count++;\r\nport->sm_churn_partner_state = AD_CHURN;\r\n}\r\n}\r\n}\r\nstatic void ad_tx_machine(struct port *port)\r\n{\r\nif (port->sm_tx_timer_counter && !(--port->sm_tx_timer_counter)) {\r\nif (port->ntt && (port->sm_vars & AD_PORT_LACP_ENABLED)) {\r\n__update_lacpdu_from_port(port);\r\nif (ad_lacpdu_send(port) >= 0) {\r\npr_debug("Sent LACPDU on port %d\n",\r\nport->actor_port_number);\r\nport->ntt = false;\r\n}\r\n}\r\nport->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\r\n}\r\n}\r\nstatic void ad_periodic_machine(struct port *port)\r\n{\r\nperiodic_states_t last_state;\r\nlast_state = port->sm_periodic_state;\r\nif (((port->sm_vars & AD_PORT_BEGIN) || !(port->sm_vars & AD_PORT_LACP_ENABLED) || !port->is_enabled) ||\r\n(!(port->actor_oper_port_state & AD_STATE_LACP_ACTIVITY) && !(port->partner_oper.port_state & AD_STATE_LACP_ACTIVITY))\r\n) {\r\nport->sm_periodic_state = AD_NO_PERIODIC;\r\n}\r\nelse if (port->sm_periodic_timer_counter) {\r\nif (!(--port->sm_periodic_timer_counter)) {\r\nport->sm_periodic_state = AD_PERIODIC_TX;\r\n} else {\r\nswitch (port->sm_periodic_state) {\r\ncase AD_FAST_PERIODIC:\r\nif (!(port->partner_oper.port_state\r\n& AD_STATE_LACP_TIMEOUT))\r\nport->sm_periodic_state = AD_SLOW_PERIODIC;\r\nbreak;\r\ncase AD_SLOW_PERIODIC:\r\nif ((port->partner_oper.port_state & AD_STATE_LACP_TIMEOUT)) {\r\nport->sm_periodic_timer_counter = 0;\r\nport->sm_periodic_state = AD_PERIODIC_TX;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} else {\r\nswitch (port->sm_periodic_state) {\r\ncase AD_NO_PERIODIC:\r\nport->sm_periodic_state = AD_FAST_PERIODIC;\r\nbreak;\r\ncase AD_PERIODIC_TX:\r\nif (!(port->partner_oper.port_state &\r\nAD_STATE_LACP_TIMEOUT))\r\nport->sm_periodic_state = AD_SLOW_PERIODIC;\r\nelse\r\nport->sm_periodic_state = AD_FAST_PERIODIC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (port->sm_periodic_state != last_state) {\r\npr_debug("Periodic Machine: Port=%d, Last State=%d, Curr State=%d\n",\r\nport->actor_port_number, last_state,\r\nport->sm_periodic_state);\r\nswitch (port->sm_periodic_state) {\r\ncase AD_NO_PERIODIC:\r\nport->sm_periodic_timer_counter = 0;\r\nbreak;\r\ncase AD_FAST_PERIODIC:\r\nport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_FAST_PERIODIC_TIME))-1;\r\nbreak;\r\ncase AD_SLOW_PERIODIC:\r\nport->sm_periodic_timer_counter = __ad_timer_to_ticks(AD_PERIODIC_TIMER, (u16)(AD_SLOW_PERIODIC_TIME))-1;\r\nbreak;\r\ncase AD_PERIODIC_TX:\r\nport->ntt = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ad_port_selection_logic(struct port *port, bool *update_slave_arr)\r\n{\r\nstruct aggregator *aggregator, *free_aggregator = NULL, *temp_aggregator;\r\nstruct port *last_port = NULL, *curr_port;\r\nstruct list_head *iter;\r\nstruct bonding *bond;\r\nstruct slave *slave;\r\nint found = 0;\r\nif (port->sm_vars & AD_PORT_SELECTED)\r\nreturn;\r\nbond = __get_bond_by_port(port);\r\nif (port->aggregator) {\r\ntemp_aggregator = port->aggregator;\r\nfor (curr_port = temp_aggregator->lag_ports; curr_port;\r\nlast_port = curr_port,\r\ncurr_port = curr_port->next_port_in_aggregator) {\r\nif (curr_port == port) {\r\ntemp_aggregator->num_of_ports--;\r\nif (!last_port) {\r\ntemp_aggregator->lag_ports =\r\nport->next_port_in_aggregator;\r\n} else {\r\nlast_port->next_port_in_aggregator =\r\nport->next_port_in_aggregator;\r\n}\r\nport->aggregator = NULL;\r\nport->next_port_in_aggregator = NULL;\r\nport->actor_port_aggregator_identifier = 0;\r\nnetdev_dbg(bond->dev, "Port %d left LAG %d\n",\r\nport->actor_port_number,\r\ntemp_aggregator->aggregator_identifier);\r\nif (!temp_aggregator->lag_ports)\r\nad_clear_agg(temp_aggregator);\r\nbreak;\r\n}\r\n}\r\nif (!curr_port) {\r\nnet_warn_ratelimited("%s: Warning: Port %d (on %s) was related to aggregator %d but was not on its port list\n",\r\nport->slave->bond->dev->name,\r\nport->actor_port_number,\r\nport->slave->dev->name,\r\nport->aggregator->aggregator_identifier);\r\n}\r\n}\r\nbond_for_each_slave(bond, slave, iter) {\r\naggregator = &(SLAVE_AD_INFO(slave)->aggregator);\r\nif (!aggregator->lag_ports) {\r\nif (!free_aggregator)\r\nfree_aggregator = aggregator;\r\ncontinue;\r\n}\r\nif (((aggregator->actor_oper_aggregator_key == port->actor_oper_port_key) &&\r\nMAC_ADDRESS_EQUAL(&(aggregator->partner_system), &(port->partner_oper.system)) &&\r\n(aggregator->partner_system_priority == port->partner_oper.system_priority) &&\r\n(aggregator->partner_oper_aggregator_key == port->partner_oper.key)\r\n) &&\r\n((!MAC_ADDRESS_EQUAL(&(port->partner_oper.system), &(null_mac_addr)) &&\r\n!aggregator->is_individual)\r\n)\r\n) {\r\nport->aggregator = aggregator;\r\nport->actor_port_aggregator_identifier =\r\nport->aggregator->aggregator_identifier;\r\nport->next_port_in_aggregator = aggregator->lag_ports;\r\nport->aggregator->num_of_ports++;\r\naggregator->lag_ports = port;\r\nnetdev_dbg(bond->dev, "Port %d joined LAG %d(existing LAG)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\nport->sm_vars |= AD_PORT_SELECTED;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (free_aggregator) {\r\nport->aggregator = free_aggregator;\r\nport->actor_port_aggregator_identifier =\r\nport->aggregator->aggregator_identifier;\r\nif (port->actor_oper_port_key & AD_DUPLEX_KEY_MASKS)\r\nport->aggregator->is_individual = false;\r\nelse\r\nport->aggregator->is_individual = true;\r\nport->aggregator->actor_admin_aggregator_key =\r\nport->actor_admin_port_key;\r\nport->aggregator->actor_oper_aggregator_key =\r\nport->actor_oper_port_key;\r\nport->aggregator->partner_system =\r\nport->partner_oper.system;\r\nport->aggregator->partner_system_priority =\r\nport->partner_oper.system_priority;\r\nport->aggregator->partner_oper_aggregator_key = port->partner_oper.key;\r\nport->aggregator->receive_state = 1;\r\nport->aggregator->transmit_state = 1;\r\nport->aggregator->lag_ports = port;\r\nport->aggregator->num_of_ports++;\r\nport->sm_vars |= AD_PORT_SELECTED;\r\nnetdev_dbg(bond->dev, "Port %d joined LAG %d(new LAG)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n} else {\r\nnetdev_err(bond->dev, "Port %d (on %s) did not find a suitable aggregator\n",\r\nport->actor_port_number, port->slave->dev->name);\r\n}\r\n}\r\n__set_agg_ports_ready(port->aggregator,\r\n__agg_ports_are_ready(port->aggregator));\r\naggregator = __get_first_agg(port);\r\nad_agg_selection_logic(aggregator, update_slave_arr);\r\nif (!port->aggregator->is_active)\r\nport->actor_oper_port_state &= ~AD_STATE_SYNCHRONIZATION;\r\n}\r\nstatic struct aggregator *ad_agg_selection_test(struct aggregator *best,\r\nstruct aggregator *curr)\r\n{\r\nif (!best)\r\nreturn curr;\r\nif (!curr->is_individual && best->is_individual)\r\nreturn curr;\r\nif (curr->is_individual && !best->is_individual)\r\nreturn best;\r\nif (__agg_has_partner(curr) && !__agg_has_partner(best))\r\nreturn curr;\r\nif (!__agg_has_partner(curr) && __agg_has_partner(best))\r\nreturn best;\r\nswitch (__get_agg_selection_mode(curr->lag_ports)) {\r\ncase BOND_AD_COUNT:\r\nif (__agg_active_ports(curr) > __agg_active_ports(best))\r\nreturn curr;\r\nif (__agg_active_ports(curr) < __agg_active_ports(best))\r\nreturn best;\r\ncase BOND_AD_STABLE:\r\ncase BOND_AD_BANDWIDTH:\r\nif (__get_agg_bandwidth(curr) > __get_agg_bandwidth(best))\r\nreturn curr;\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("%s: Impossible agg select mode %d\n",\r\ncurr->slave->bond->dev->name,\r\n__get_agg_selection_mode(curr->lag_ports));\r\nbreak;\r\n}\r\nreturn best;\r\n}\r\nstatic int agg_device_up(const struct aggregator *agg)\r\n{\r\nstruct port *port = agg->lag_ports;\r\nif (!port)\r\nreturn 0;\r\nfor (port = agg->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\nif (netif_running(port->slave->dev) &&\r\nnetif_carrier_ok(port->slave->dev))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ad_agg_selection_logic(struct aggregator *agg,\r\nbool *update_slave_arr)\r\n{\r\nstruct aggregator *best, *active, *origin;\r\nstruct bonding *bond = agg->slave->bond;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nstruct port *port;\r\nrcu_read_lock();\r\norigin = agg;\r\nactive = __get_active_agg(agg);\r\nbest = (active && agg_device_up(active)) ? active : NULL;\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nagg = &(SLAVE_AD_INFO(slave)->aggregator);\r\nagg->is_active = 0;\r\nif (__agg_active_ports(agg) && agg_device_up(agg))\r\nbest = ad_agg_selection_test(best, agg);\r\n}\r\nif (best &&\r\n__get_agg_selection_mode(best->lag_ports) == BOND_AD_STABLE) {\r\nif (active && active->lag_ports &&\r\n__agg_active_ports(active) &&\r\n(__agg_has_partner(active) ||\r\n(!__agg_has_partner(active) &&\r\n!__agg_has_partner(best)))) {\r\nif (!(!active->actor_oper_aggregator_key &&\r\nbest->actor_oper_aggregator_key)) {\r\nbest = NULL;\r\nactive->is_active = 1;\r\n}\r\n}\r\n}\r\nif (best && (best == active)) {\r\nbest = NULL;\r\nactive->is_active = 1;\r\n}\r\nif (best) {\r\nnetdev_dbg(bond->dev, "best Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nbest->aggregator_identifier, best->num_of_ports,\r\nbest->actor_oper_aggregator_key,\r\nbest->partner_oper_aggregator_key,\r\nbest->is_individual, best->is_active);\r\nnetdev_dbg(bond->dev, "best ports %p slave %p %s\n",\r\nbest->lag_ports, best->slave,\r\nbest->slave ? best->slave->dev->name : "NULL");\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nagg = &(SLAVE_AD_INFO(slave)->aggregator);\r\nnetdev_dbg(bond->dev, "Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nagg->aggregator_identifier, agg->num_of_ports,\r\nagg->actor_oper_aggregator_key,\r\nagg->partner_oper_aggregator_key,\r\nagg->is_individual, agg->is_active);\r\n}\r\nif (best->is_individual) {\r\nnet_warn_ratelimited("%s: Warning: No 802.3ad response from the link partner for any adapters in the bond\n",\r\nbest->slave ?\r\nbest->slave->bond->dev->name : "NULL");\r\n}\r\nbest->is_active = 1;\r\nnetdev_dbg(bond->dev, "LAG %d chosen as the active LAG\n",\r\nbest->aggregator_identifier);\r\nnetdev_dbg(bond->dev, "Agg=%d; P=%d; a k=%d; p k=%d; Ind=%d; Act=%d\n",\r\nbest->aggregator_identifier, best->num_of_ports,\r\nbest->actor_oper_aggregator_key,\r\nbest->partner_oper_aggregator_key,\r\nbest->is_individual, best->is_active);\r\nif (active) {\r\nfor (port = active->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\n__disable_port(port);\r\n}\r\n}\r\n*update_slave_arr = true;\r\n}\r\nactive = __get_active_agg(origin);\r\nif (active) {\r\nif (!__agg_has_partner(active)) {\r\nfor (port = active->lag_ports; port;\r\nport = port->next_port_in_aggregator) {\r\n__enable_port(port);\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\nbond_3ad_set_carrier(bond);\r\n}\r\nstatic void ad_clear_agg(struct aggregator *aggregator)\r\n{\r\nif (aggregator) {\r\naggregator->is_individual = false;\r\naggregator->actor_admin_aggregator_key = 0;\r\naggregator->actor_oper_aggregator_key = 0;\r\neth_zero_addr(aggregator->partner_system.mac_addr_value);\r\naggregator->partner_system_priority = 0;\r\naggregator->partner_oper_aggregator_key = 0;\r\naggregator->receive_state = 0;\r\naggregator->transmit_state = 0;\r\naggregator->lag_ports = NULL;\r\naggregator->is_active = 0;\r\naggregator->num_of_ports = 0;\r\npr_debug("LAG %d was cleared\n",\r\naggregator->aggregator_identifier);\r\n}\r\n}\r\nstatic void ad_initialize_agg(struct aggregator *aggregator)\r\n{\r\nif (aggregator) {\r\nad_clear_agg(aggregator);\r\neth_zero_addr(aggregator->aggregator_mac_address.mac_addr_value);\r\naggregator->aggregator_identifier = 0;\r\naggregator->slave = NULL;\r\n}\r\n}\r\nstatic void ad_initialize_port(struct port *port, int lacp_fast)\r\n{\r\nstatic const struct port_params tmpl = {\r\n.system_priority = 0xffff,\r\n.key = 1,\r\n.port_number = 1,\r\n.port_priority = 0xff,\r\n.port_state = 1,\r\n};\r\nstatic const struct lacpdu lacpdu = {\r\n.subtype = 0x01,\r\n.version_number = 0x01,\r\n.tlv_type_actor_info = 0x01,\r\n.actor_information_length = 0x14,\r\n.tlv_type_partner_info = 0x02,\r\n.partner_information_length = 0x14,\r\n.tlv_type_collector_info = 0x03,\r\n.collector_information_length = 0x10,\r\n.collector_max_delay = htons(AD_COLLECTOR_MAX_DELAY),\r\n};\r\nif (port) {\r\nport->actor_port_priority = 0xff;\r\nport->actor_port_aggregator_identifier = 0;\r\nport->ntt = false;\r\nport->actor_admin_port_state = AD_STATE_AGGREGATION |\r\nAD_STATE_LACP_ACTIVITY;\r\nport->actor_oper_port_state = AD_STATE_AGGREGATION |\r\nAD_STATE_LACP_ACTIVITY;\r\nif (lacp_fast)\r\nport->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;\r\nmemcpy(&port->partner_admin, &tmpl, sizeof(tmpl));\r\nmemcpy(&port->partner_oper, &tmpl, sizeof(tmpl));\r\nport->is_enabled = true;\r\nport->sm_vars = AD_PORT_BEGIN | AD_PORT_LACP_ENABLED;\r\nport->sm_rx_state = 0;\r\nport->sm_rx_timer_counter = 0;\r\nport->sm_periodic_state = 0;\r\nport->sm_periodic_timer_counter = 0;\r\nport->sm_mux_state = 0;\r\nport->sm_mux_timer_counter = 0;\r\nport->sm_tx_state = 0;\r\nport->aggregator = NULL;\r\nport->next_port_in_aggregator = NULL;\r\nport->transaction_id = 0;\r\nport->sm_churn_actor_timer_counter = 0;\r\nport->sm_churn_actor_state = 0;\r\nport->churn_actor_count = 0;\r\nport->sm_churn_partner_timer_counter = 0;\r\nport->sm_churn_partner_state = 0;\r\nport->churn_partner_count = 0;\r\nmemcpy(&port->lacpdu, &lacpdu, sizeof(lacpdu));\r\n}\r\n}\r\nstatic void ad_enable_collecting_distributing(struct port *port,\r\nbool *update_slave_arr)\r\n{\r\nif (port->aggregator->is_active) {\r\npr_debug("Enabling port %d(LAG %d)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n__enable_port(port);\r\n*update_slave_arr = true;\r\n}\r\n}\r\nstatic void ad_disable_collecting_distributing(struct port *port,\r\nbool *update_slave_arr)\r\n{\r\nif (port->aggregator &&\r\n!MAC_ADDRESS_EQUAL(&(port->aggregator->partner_system),\r\n&(null_mac_addr))) {\r\npr_debug("Disabling port %d(LAG %d)\n",\r\nport->actor_port_number,\r\nport->aggregator->aggregator_identifier);\r\n__disable_port(port);\r\n*update_slave_arr = true;\r\n}\r\n}\r\nstatic void ad_marker_info_received(struct bond_marker *marker_info,\r\nstruct port *port)\r\n{\r\nstruct bond_marker marker;\r\nmemcpy(&marker, marker_info, sizeof(struct bond_marker));\r\nmarker.tlv_type = AD_MARKER_RESPONSE_SUBTYPE;\r\nif (ad_marker_send(port, &marker) >= 0) {\r\npr_debug("Sent Marker Response on port %d\n",\r\nport->actor_port_number);\r\n}\r\n}\r\nstatic void ad_marker_response_received(struct bond_marker *marker,\r\nstruct port *port)\r\n{\r\n}\r\nvoid bond_3ad_initiate_agg_selection(struct bonding *bond, int timeout)\r\n{\r\nBOND_AD_INFO(bond).agg_select_timer = timeout;\r\n}\r\nvoid bond_3ad_initialize(struct bonding *bond, u16 tick_resolution)\r\n{\r\nif (!MAC_ADDRESS_EQUAL(&(BOND_AD_INFO(bond).system.sys_mac_addr),\r\nbond->dev->dev_addr)) {\r\nBOND_AD_INFO(bond).aggregator_identifier = 0;\r\nBOND_AD_INFO(bond).system.sys_priority =\r\nbond->params.ad_actor_sys_prio;\r\nif (is_zero_ether_addr(bond->params.ad_actor_system))\r\nBOND_AD_INFO(bond).system.sys_mac_addr =\r\n*((struct mac_addr *)bond->dev->dev_addr);\r\nelse\r\nBOND_AD_INFO(bond).system.sys_mac_addr =\r\n*((struct mac_addr *)bond->params.ad_actor_system);\r\nad_ticks_per_sec = tick_resolution;\r\nbond_3ad_initiate_agg_selection(bond,\r\nAD_AGGREGATOR_SELECTION_TIMER *\r\nad_ticks_per_sec);\r\n}\r\n}\r\nvoid bond_3ad_bind_slave(struct slave *slave)\r\n{\r\nstruct bonding *bond = bond_get_bond_by_slave(slave);\r\nstruct port *port;\r\nstruct aggregator *aggregator;\r\nif (SLAVE_AD_INFO(slave)->port.slave != slave) {\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nad_initialize_port(port, bond->params.lacp_fast);\r\nport->slave = slave;\r\nport->actor_port_number = SLAVE_AD_INFO(slave)->id;\r\nport->actor_admin_port_key = bond->params.ad_user_port_key << 6;\r\nad_update_actor_keys(port, false);\r\n__ad_actor_update_port(port);\r\nport->sm_tx_timer_counter = ad_ticks_per_sec/AD_MAX_TX_IN_SECOND;\r\n__disable_port(port);\r\naggregator = &(SLAVE_AD_INFO(slave)->aggregator);\r\nad_initialize_agg(aggregator);\r\naggregator->aggregator_mac_address = *((struct mac_addr *)bond->dev->dev_addr);\r\naggregator->aggregator_identifier = ++BOND_AD_INFO(bond).aggregator_identifier;\r\naggregator->slave = slave;\r\naggregator->is_active = 0;\r\naggregator->num_of_ports = 0;\r\n}\r\n}\r\nvoid bond_3ad_unbind_slave(struct slave *slave)\r\n{\r\nstruct port *port, *prev_port, *temp_port;\r\nstruct aggregator *aggregator, *new_aggregator, *temp_aggregator;\r\nint select_new_active_agg = 0;\r\nstruct bonding *bond = slave->bond;\r\nstruct slave *slave_iter;\r\nstruct list_head *iter;\r\nbool dummy_slave_update;\r\nspin_lock_bh(&bond->mode_lock);\r\naggregator = &(SLAVE_AD_INFO(slave)->aggregator);\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (!port->slave) {\r\nnetdev_warn(bond->dev, "Trying to unbind an uninitialized port on %s\n",\r\nslave->dev->name);\r\ngoto out;\r\n}\r\nnetdev_dbg(bond->dev, "Unbinding Link Aggregation Group %d\n",\r\naggregator->aggregator_identifier);\r\nport->actor_oper_port_state &= ~AD_STATE_AGGREGATION;\r\n__update_lacpdu_from_port(port);\r\nad_lacpdu_send(port);\r\nif (aggregator->lag_ports) {\r\nif ((aggregator->lag_ports != port) ||\r\n(aggregator->lag_ports->next_port_in_aggregator)) {\r\nbond_for_each_slave(bond, slave_iter, iter) {\r\nnew_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);\r\nif (!new_aggregator->lag_ports ||\r\n((new_aggregator->lag_ports == port) &&\r\n!new_aggregator->lag_ports->next_port_in_aggregator))\r\nbreak;\r\n}\r\nif (!slave_iter)\r\nnew_aggregator = NULL;\r\nif ((new_aggregator) && ((!new_aggregator->lag_ports) || ((new_aggregator->lag_ports == port) && !new_aggregator->lag_ports->next_port_in_aggregator))) {\r\nnetdev_dbg(bond->dev, "Some port(s) related to LAG %d - replacing with LAG %d\n",\r\naggregator->aggregator_identifier,\r\nnew_aggregator->aggregator_identifier);\r\nif ((new_aggregator->lag_ports == port) &&\r\nnew_aggregator->is_active) {\r\nnetdev_info(bond->dev, "Removing an active aggregator\n");\r\nselect_new_active_agg = 1;\r\n}\r\nnew_aggregator->is_individual = aggregator->is_individual;\r\nnew_aggregator->actor_admin_aggregator_key = aggregator->actor_admin_aggregator_key;\r\nnew_aggregator->actor_oper_aggregator_key = aggregator->actor_oper_aggregator_key;\r\nnew_aggregator->partner_system = aggregator->partner_system;\r\nnew_aggregator->partner_system_priority = aggregator->partner_system_priority;\r\nnew_aggregator->partner_oper_aggregator_key = aggregator->partner_oper_aggregator_key;\r\nnew_aggregator->receive_state = aggregator->receive_state;\r\nnew_aggregator->transmit_state = aggregator->transmit_state;\r\nnew_aggregator->lag_ports = aggregator->lag_ports;\r\nnew_aggregator->is_active = aggregator->is_active;\r\nnew_aggregator->num_of_ports = aggregator->num_of_ports;\r\nfor (temp_port = aggregator->lag_ports; temp_port;\r\ntemp_port = temp_port->next_port_in_aggregator) {\r\ntemp_port->aggregator = new_aggregator;\r\ntemp_port->actor_port_aggregator_identifier = new_aggregator->aggregator_identifier;\r\n}\r\nad_clear_agg(aggregator);\r\nif (select_new_active_agg)\r\nad_agg_selection_logic(__get_first_agg(port),\r\n&dummy_slave_update);\r\n} else {\r\nnetdev_warn(bond->dev, "unbinding aggregator, and could not find a new aggregator for its ports\n");\r\n}\r\n} else {\r\nselect_new_active_agg = aggregator->is_active;\r\nad_clear_agg(aggregator);\r\nif (select_new_active_agg) {\r\nnetdev_info(bond->dev, "Removing an active aggregator\n");\r\ntemp_aggregator = __get_first_agg(port);\r\nif (temp_aggregator)\r\nad_agg_selection_logic(temp_aggregator,\r\n&dummy_slave_update);\r\n}\r\n}\r\n}\r\nnetdev_dbg(bond->dev, "Unbinding port %d\n", port->actor_port_number);\r\nbond_for_each_slave(bond, slave_iter, iter) {\r\ntemp_aggregator = &(SLAVE_AD_INFO(slave_iter)->aggregator);\r\nprev_port = NULL;\r\nfor (temp_port = temp_aggregator->lag_ports; temp_port;\r\nprev_port = temp_port,\r\ntemp_port = temp_port->next_port_in_aggregator) {\r\nif (temp_port == port) {\r\nif (prev_port)\r\nprev_port->next_port_in_aggregator = temp_port->next_port_in_aggregator;\r\nelse\r\ntemp_aggregator->lag_ports = temp_port->next_port_in_aggregator;\r\ntemp_aggregator->num_of_ports--;\r\nif (__agg_active_ports(temp_aggregator) == 0) {\r\nselect_new_active_agg = temp_aggregator->is_active;\r\nad_clear_agg(temp_aggregator);\r\nif (select_new_active_agg) {\r\nnetdev_info(bond->dev, "Removing an active aggregator\n");\r\nad_agg_selection_logic(__get_first_agg(port),\r\n&dummy_slave_update);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nport->slave = NULL;\r\nout:\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nvoid bond_3ad_update_ad_actor_settings(struct bonding *bond)\r\n{\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nASSERT_RTNL();\r\nBOND_AD_INFO(bond).system.sys_priority = bond->params.ad_actor_sys_prio;\r\nif (is_zero_ether_addr(bond->params.ad_actor_system))\r\nBOND_AD_INFO(bond).system.sys_mac_addr =\r\n*((struct mac_addr *)bond->dev->dev_addr);\r\nelse\r\nBOND_AD_INFO(bond).system.sys_mac_addr =\r\n*((struct mac_addr *)bond->params.ad_actor_system);\r\nspin_lock_bh(&bond->mode_lock);\r\nbond_for_each_slave(bond, slave, iter) {\r\nstruct port *port = &(SLAVE_AD_INFO(slave))->port;\r\n__ad_actor_update_port(port);\r\nport->ntt = true;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}\r\nvoid bond_3ad_state_machine_handler(struct work_struct *work)\r\n{\r\nstruct bonding *bond = container_of(work, struct bonding,\r\nad_work.work);\r\nstruct aggregator *aggregator;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nstruct port *port;\r\nbool should_notify_rtnl = BOND_SLAVE_NOTIFY_LATER;\r\nbool update_slave_arr = false;\r\nspin_lock_bh(&bond->mode_lock);\r\nrcu_read_lock();\r\nif (!bond_has_slaves(bond))\r\ngoto re_arm;\r\nif (BOND_AD_INFO(bond).agg_select_timer &&\r\n!(--BOND_AD_INFO(bond).agg_select_timer)) {\r\nslave = bond_first_slave_rcu(bond);\r\nport = slave ? &(SLAVE_AD_INFO(slave)->port) : NULL;\r\nif (port) {\r\nif (!port->slave) {\r\nnet_warn_ratelimited("%s: Warning: bond's first port is uninitialized\n",\r\nbond->dev->name);\r\ngoto re_arm;\r\n}\r\naggregator = __get_first_agg(port);\r\nad_agg_selection_logic(aggregator, &update_slave_arr);\r\n}\r\nbond_3ad_set_carrier(bond);\r\n}\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (!port->slave) {\r\nnet_warn_ratelimited("%s: Warning: Found an uninitialized port\n",\r\nbond->dev->name);\r\ngoto re_arm;\r\n}\r\nad_rx_machine(NULL, port);\r\nad_periodic_machine(port);\r\nad_port_selection_logic(port, &update_slave_arr);\r\nad_mux_machine(port, &update_slave_arr);\r\nad_tx_machine(port);\r\nad_churn_machine(port);\r\nif (port->sm_vars & AD_PORT_BEGIN)\r\nport->sm_vars &= ~AD_PORT_BEGIN;\r\n}\r\nre_arm:\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nif (slave->should_notify) {\r\nshould_notify_rtnl = BOND_SLAVE_NOTIFY_NOW;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nspin_unlock_bh(&bond->mode_lock);\r\nif (update_slave_arr)\r\nbond_slave_arr_work_rearm(bond, 0);\r\nif (should_notify_rtnl && rtnl_trylock()) {\r\nbond_slave_state_notify(bond);\r\nrtnl_unlock();\r\n}\r\nqueue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);\r\n}\r\nstatic int bond_3ad_rx_indication(struct lacpdu *lacpdu, struct slave *slave,\r\nu16 length)\r\n{\r\nstruct port *port;\r\nint ret = RX_HANDLER_ANOTHER;\r\nif (length >= sizeof(struct lacpdu)) {\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (!port->slave) {\r\nnet_warn_ratelimited("%s: Warning: port of slave %s is uninitialized\n",\r\nslave->dev->name, slave->bond->dev->name);\r\nreturn ret;\r\n}\r\nswitch (lacpdu->subtype) {\r\ncase AD_TYPE_LACPDU:\r\nret = RX_HANDLER_CONSUMED;\r\nnetdev_dbg(slave->bond->dev,\r\n"Received LACPDU on port %d slave %s\n",\r\nport->actor_port_number,\r\nslave->dev->name);\r\nspin_lock(&slave->bond->mode_lock);\r\nad_rx_machine(lacpdu, port);\r\nspin_unlock(&slave->bond->mode_lock);\r\nbreak;\r\ncase AD_TYPE_MARKER:\r\nret = RX_HANDLER_CONSUMED;\r\nswitch (((struct bond_marker *)lacpdu)->tlv_type) {\r\ncase AD_MARKER_INFORMATION_SUBTYPE:\r\nnetdev_dbg(slave->bond->dev, "Received Marker Information on port %d\n",\r\nport->actor_port_number);\r\nad_marker_info_received((struct bond_marker *)lacpdu, port);\r\nbreak;\r\ncase AD_MARKER_RESPONSE_SUBTYPE:\r\nnetdev_dbg(slave->bond->dev, "Received Marker Response on port %d\n",\r\nport->actor_port_number);\r\nad_marker_response_received((struct bond_marker *)lacpdu, port);\r\nbreak;\r\ndefault:\r\nnetdev_dbg(slave->bond->dev, "Received an unknown Marker subtype on slot %d\n",\r\nport->actor_port_number);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ad_update_actor_keys(struct port *port, bool reset)\r\n{\r\nu8 duplex = 0;\r\nu16 ospeed = 0, speed = 0;\r\nu16 old_oper_key = port->actor_oper_port_key;\r\nport->actor_admin_port_key &= ~(AD_SPEED_KEY_MASKS|AD_DUPLEX_KEY_MASKS);\r\nif (!reset) {\r\nspeed = __get_link_speed(port);\r\nospeed = (old_oper_key & AD_SPEED_KEY_MASKS) >> 1;\r\nduplex = __get_duplex(port);\r\nport->actor_admin_port_key |= (speed << 1) | duplex;\r\n}\r\nport->actor_oper_port_key = port->actor_admin_port_key;\r\nif (old_oper_key != port->actor_oper_port_key) {\r\nif (duplex)\r\nport->sm_vars |= AD_PORT_LACP_ENABLED;\r\nelse\r\nport->sm_vars &= ~AD_PORT_LACP_ENABLED;\r\nif (!reset) {\r\nif (!speed) {\r\nnetdev_err(port->slave->dev,\r\n"speed changed to 0 for port %s",\r\nport->slave->dev->name);\r\n} else if (duplex && ospeed != speed) {\r\nport->sm_vars |= AD_PORT_BEGIN;\r\n}\r\n}\r\n}\r\n}\r\nvoid bond_3ad_adapter_speed_duplex_changed(struct slave *slave)\r\n{\r\nstruct port *port;\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (!port->slave) {\r\nnetdev_warn(slave->bond->dev,\r\n"speed/duplex changed for uninitialized port %s\n",\r\nslave->dev->name);\r\nreturn;\r\n}\r\nspin_lock_bh(&slave->bond->mode_lock);\r\nad_update_actor_keys(port, false);\r\nnetdev_dbg(slave->bond->dev, "Port %d slave %s changed speed/duplex\n",\r\nport->actor_port_number, slave->dev->name);\r\nspin_unlock_bh(&slave->bond->mode_lock);\r\n}\r\nvoid bond_3ad_handle_link_change(struct slave *slave, char link)\r\n{\r\nstruct aggregator *agg;\r\nstruct port *port;\r\nbool dummy;\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (!port->slave) {\r\nnetdev_warn(slave->bond->dev, "link status changed for uninitialized port on %s\n",\r\nslave->dev->name);\r\nreturn;\r\n}\r\nspin_lock_bh(&slave->bond->mode_lock);\r\nif (link == BOND_LINK_UP) {\r\nport->is_enabled = true;\r\nad_update_actor_keys(port, false);\r\n} else {\r\nport->is_enabled = false;\r\nad_update_actor_keys(port, true);\r\n}\r\nagg = __get_first_agg(port);\r\nad_agg_selection_logic(agg, &dummy);\r\nnetdev_dbg(slave->bond->dev, "Port %d changed link status to %s\n",\r\nport->actor_port_number,\r\nlink == BOND_LINK_UP ? "UP" : "DOWN");\r\nspin_unlock_bh(&slave->bond->mode_lock);\r\nbond_update_slave_arr(slave->bond, NULL);\r\n}\r\nint bond_3ad_set_carrier(struct bonding *bond)\r\n{\r\nstruct aggregator *active;\r\nstruct slave *first_slave;\r\nint ret = 1;\r\nrcu_read_lock();\r\nfirst_slave = bond_first_slave_rcu(bond);\r\nif (!first_slave) {\r\nret = 0;\r\ngoto out;\r\n}\r\nactive = __get_active_agg(&(SLAVE_AD_INFO(first_slave)->aggregator));\r\nif (active) {\r\nif (__agg_active_ports(active) < bond->params.min_links) {\r\nif (netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_off(bond->dev);\r\ngoto out;\r\n}\r\n} else if (!netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_on(bond->dev);\r\ngoto out;\r\n}\r\n} else if (netif_carrier_ok(bond->dev)) {\r\nnetif_carrier_off(bond->dev);\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint __bond_3ad_get_active_agg_info(struct bonding *bond,\r\nstruct ad_info *ad_info)\r\n{\r\nstruct aggregator *aggregator = NULL;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nstruct port *port;\r\nbond_for_each_slave_rcu(bond, slave, iter) {\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (port->aggregator && port->aggregator->is_active) {\r\naggregator = port->aggregator;\r\nbreak;\r\n}\r\n}\r\nif (!aggregator)\r\nreturn -1;\r\nad_info->aggregator_id = aggregator->aggregator_identifier;\r\nad_info->ports = aggregator->num_of_ports;\r\nad_info->actor_key = aggregator->actor_oper_aggregator_key;\r\nad_info->partner_key = aggregator->partner_oper_aggregator_key;\r\nether_addr_copy(ad_info->partner_system,\r\naggregator->partner_system.mac_addr_value);\r\nreturn 0;\r\n}\r\nint bond_3ad_get_active_agg_info(struct bonding *bond, struct ad_info *ad_info)\r\n{\r\nint ret;\r\nrcu_read_lock();\r\nret = __bond_3ad_get_active_agg_info(bond, ad_info);\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,\r\nstruct slave *slave)\r\n{\r\nstruct lacpdu *lacpdu, _lacpdu;\r\nif (skb->protocol != PKT_TYPE_LACPDU)\r\nreturn RX_HANDLER_ANOTHER;\r\nif (!MAC_ADDRESS_EQUAL(eth_hdr(skb)->h_dest, lacpdu_mcast_addr))\r\nreturn RX_HANDLER_ANOTHER;\r\nlacpdu = skb_header_pointer(skb, 0, sizeof(_lacpdu), &_lacpdu);\r\nif (!lacpdu)\r\nreturn RX_HANDLER_ANOTHER;\r\nreturn bond_3ad_rx_indication(lacpdu, slave, skb->len);\r\n}\r\nvoid bond_3ad_update_lacp_rate(struct bonding *bond)\r\n{\r\nstruct port *port = NULL;\r\nstruct list_head *iter;\r\nstruct slave *slave;\r\nint lacp_fast;\r\nlacp_fast = bond->params.lacp_fast;\r\nspin_lock_bh(&bond->mode_lock);\r\nbond_for_each_slave(bond, slave, iter) {\r\nport = &(SLAVE_AD_INFO(slave)->port);\r\nif (lacp_fast)\r\nport->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;\r\nelse\r\nport->actor_oper_port_state &= ~AD_STATE_LACP_TIMEOUT;\r\n}\r\nspin_unlock_bh(&bond->mode_lock);\r\n}
