static void usage(void)\r\n{\r\nprintf("usage: %s flask.h av_permissions.h\n", progname);\r\nexit(1);\r\n}\r\nstatic char *stoupperx(const char *s)\r\n{\r\nchar *s2 = strdup(s);\r\nchar *p;\r\nif (!s2) {\r\nfprintf(stderr, "%s: out of memory\n", progname);\r\nexit(3);\r\n}\r\nfor (p = s2; *p; p++)\r\n*p = toupper(*p);\r\nreturn s2;\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint i, j, k;\r\nint isids_len;\r\nFILE *fout;\r\nconst char *needle = "SOCKET";\r\nchar *substr;\r\nprogname = argv[0];\r\nif (argc < 3)\r\nusage();\r\nfout = fopen(argv[1], "w");\r\nif (!fout) {\r\nfprintf(stderr, "Could not open %s for writing: %s\n",\r\nargv[1], strerror(errno));\r\nexit(2);\r\n}\r\nfor (i = 0; secclass_map[i].name; i++) {\r\nstruct security_class_mapping *map = &secclass_map[i];\r\nmap->name = stoupperx(map->name);\r\nfor (j = 0; map->perms[j]; j++)\r\nmap->perms[j] = stoupperx(map->perms[j]);\r\n}\r\nisids_len = sizeof(initial_sid_to_string) / sizeof (char *);\r\nfor (i = 1; i < isids_len; i++)\r\ninitial_sid_to_string[i] = stoupperx(initial_sid_to_string[i]);\r\nfprintf(fout, "/* This file is automatically generated. Do not edit. */\n");\r\nfprintf(fout, "#ifndef _SELINUX_FLASK_H_\n#define _SELINUX_FLASK_H_\n\n");\r\nfor (i = 0; secclass_map[i].name; i++) {\r\nstruct security_class_mapping *map = &secclass_map[i];\r\nfprintf(fout, "#define SECCLASS_%s", map->name);\r\nfor (j = 0; j < max(1, 40 - strlen(map->name)); j++)\r\nfprintf(fout, " ");\r\nfprintf(fout, "%2d\n", i+1);\r\n}\r\nfprintf(fout, "\n");\r\nfor (i = 1; i < isids_len; i++) {\r\nconst char *s = initial_sid_to_string[i];\r\nfprintf(fout, "#define SECINITSID_%s", s);\r\nfor (j = 0; j < max(1, 40 - strlen(s)); j++)\r\nfprintf(fout, " ");\r\nfprintf(fout, "%2d\n", i);\r\n}\r\nfprintf(fout, "\n#define SECINITSID_NUM %d\n", i-1);\r\nfprintf(fout, "\nstatic inline bool security_is_socket_class(u16 kern_tclass)\n");\r\nfprintf(fout, "{\n");\r\nfprintf(fout, "\tbool sock = false;\n\n");\r\nfprintf(fout, "\tswitch (kern_tclass) {\n");\r\nfor (i = 0; secclass_map[i].name; i++) {\r\nstruct security_class_mapping *map = &secclass_map[i];\r\nsubstr = strstr(map->name, needle);\r\nif (substr && strcmp(substr, needle) == 0)\r\nfprintf(fout, "\tcase SECCLASS_%s:\n", map->name);\r\n}\r\nfprintf(fout, "\t\tsock = true;\n");\r\nfprintf(fout, "\t\tbreak;\n");\r\nfprintf(fout, "\tdefault:\n");\r\nfprintf(fout, "\t\tbreak;\n");\r\nfprintf(fout, "\t}\n\n");\r\nfprintf(fout, "\treturn sock;\n");\r\nfprintf(fout, "}\n");\r\nfprintf(fout, "\n#endif\n");\r\nfclose(fout);\r\nfout = fopen(argv[2], "w");\r\nif (!fout) {\r\nfprintf(stderr, "Could not open %s for writing: %s\n",\r\nargv[2], strerror(errno));\r\nexit(4);\r\n}\r\nfprintf(fout, "/* This file is automatically generated. Do not edit. */\n");\r\nfprintf(fout, "#ifndef _SELINUX_AV_PERMISSIONS_H_\n#define _SELINUX_AV_PERMISSIONS_H_\n\n");\r\nfor (i = 0; secclass_map[i].name; i++) {\r\nstruct security_class_mapping *map = &secclass_map[i];\r\nfor (j = 0; map->perms[j]; j++) {\r\nfprintf(fout, "#define %s__%s", map->name,\r\nmap->perms[j]);\r\nfor (k = 0; k < max(1, 40 - strlen(map->name) - strlen(map->perms[j])); k++)\r\nfprintf(fout, " ");\r\nfprintf(fout, "0x%08xUL\n", (1<<j));\r\n}\r\n}\r\nfprintf(fout, "\n#endif\n");\r\nfclose(fout);\r\nexit(0);\r\n}
