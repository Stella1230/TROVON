static int flexcop_i2c_operation(struct flexcop_device *fc,\r\nflexcop_ibi_value *r100)\r\n{\r\nint i;\r\nflexcop_ibi_value r;\r\nr100->tw_sm_c_100.working_start = 1;\r\ndeb_i2c("r100 before: %08x\n",r100->raw);\r\nfc->write_ibi_reg(fc, tw_sm_c_100, ibi_zero);\r\nfc->write_ibi_reg(fc, tw_sm_c_100, *r100);\r\nfor (i = 0; i < FC_MAX_I2C_RETRIES; i++) {\r\nr = fc->read_ibi_reg(fc, tw_sm_c_100);\r\nif (!r.tw_sm_c_100.no_base_addr_ack_error) {\r\nif (r.tw_sm_c_100.st_done) {\r\n*r100 = r;\r\ndeb_i2c("i2c success\n");\r\nreturn 0;\r\n}\r\n} else {\r\ndeb_i2c("suffering from an i2c ack_error\n");\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\ndeb_i2c("tried %d times i2c operation, never finished or too many ack errors.\n",\r\ni);\r\nreturn -EREMOTEIO;\r\n}\r\nstatic int flexcop_i2c_read4(struct flexcop_i2c_adapter *i2c,\r\nflexcop_ibi_value r100, u8 *buf)\r\n{\r\nflexcop_ibi_value r104;\r\nint len = r100.tw_sm_c_100.total_bytes,\r\nret;\r\nif (i2c->fc->dev_type == FC_SKY_REV27)\r\nr100.tw_sm_c_100.no_base_addr_ack_error = i2c->no_base_addr;\r\nret = flexcop_i2c_operation(i2c->fc, &r100);\r\nif (ret != 0) {\r\ndeb_i2c("Retrying operation\n");\r\nr100.tw_sm_c_100.no_base_addr_ack_error = i2c->no_base_addr;\r\nret = flexcop_i2c_operation(i2c->fc, &r100);\r\n}\r\nif (ret != 0) {\r\ndeb_i2c("read failed. %d\n", ret);\r\nreturn ret;\r\n}\r\nbuf[0] = r100.tw_sm_c_100.data1_reg;\r\nif (len > 0) {\r\nr104 = i2c->fc->read_ibi_reg(i2c->fc, tw_sm_c_104);\r\ndeb_i2c("read: r100: %08x, r104: %08x\n", r100.raw, r104.raw);\r\nbuf[1] = r104.tw_sm_c_104.data2_reg;\r\nif (len > 1) buf[2] = r104.tw_sm_c_104.data3_reg;\r\nif (len > 2) buf[3] = r104.tw_sm_c_104.data4_reg;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flexcop_i2c_write4(struct flexcop_device *fc,\r\nflexcop_ibi_value r100, u8 *buf)\r\n{\r\nflexcop_ibi_value r104;\r\nint len = r100.tw_sm_c_100.total_bytes;\r\nr104.raw = 0;\r\nr100.tw_sm_c_100.data1_reg = buf[0];\r\nr104.tw_sm_c_104.data2_reg = len > 0 ? buf[1] : 0;\r\nr104.tw_sm_c_104.data3_reg = len > 1 ? buf[2] : 0;\r\nr104.tw_sm_c_104.data4_reg = len > 2 ? buf[3] : 0;\r\ndeb_i2c("write: r100: %08x, r104: %08x\n", r100.raw, r104.raw);\r\nfc->write_ibi_reg(fc, tw_sm_c_104, r104);\r\nreturn flexcop_i2c_operation(fc, &r100);\r\n}\r\nint flexcop_i2c_request(struct flexcop_i2c_adapter *i2c,\r\nflexcop_access_op_t op, u8 chipaddr, u8 addr, u8 *buf, u16 len)\r\n{\r\nint ret;\r\n#ifdef DUMP_I2C_MESSAGES\r\nint i;\r\n#endif\r\nu16 bytes_to_transfer;\r\nflexcop_ibi_value r100;\r\ndeb_i2c("op = %d\n",op);\r\nr100.raw = 0;\r\nr100.tw_sm_c_100.chipaddr = chipaddr;\r\nr100.tw_sm_c_100.twoWS_rw = op;\r\nr100.tw_sm_c_100.twoWS_port_reg = i2c->port;\r\n#ifdef DUMP_I2C_MESSAGES\r\nprintk(KERN_DEBUG "%d ", i2c->port);\r\nif (op == FC_READ)\r\nprintk(KERN_CONT "rd(");\r\nelse\r\nprintk(KERN_CONT "wr(");\r\nprintk(KERN_CONT "%02x): %02x ", chipaddr, addr);\r\n#endif\r\nif (i2c->no_base_addr && len == 0 && op == FC_WRITE) {\r\nbuf = &addr;\r\nlen = 1;\r\n}\r\nwhile (len != 0) {\r\nbytes_to_transfer = len > 4 ? 4 : len;\r\nr100.tw_sm_c_100.total_bytes = bytes_to_transfer - 1;\r\nr100.tw_sm_c_100.baseaddr = addr;\r\nif (op == FC_READ)\r\nret = flexcop_i2c_read4(i2c, r100, buf);\r\nelse\r\nret = flexcop_i2c_write4(i2c->fc, r100, buf);\r\n#ifdef DUMP_I2C_MESSAGES\r\nfor (i = 0; i < bytes_to_transfer; i++)\r\nprintk(KERN_CONT "%02x ", buf[i]);\r\n#endif\r\nif (ret < 0)\r\nreturn ret;\r\nbuf += bytes_to_transfer;\r\naddr += bytes_to_transfer;\r\nlen -= bytes_to_transfer;\r\n}\r\n#ifdef DUMP_I2C_MESSAGES\r\nprintk(KERN_CONT "\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int flexcop_master_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct flexcop_i2c_adapter *i2c = i2c_get_adapdata(i2c_adap);\r\nint i, ret = 0;\r\nif (num == 1 && msgs[0].flags == I2C_M_RD && msgs[0].len <= 1)\r\nreturn 1;\r\nif (mutex_lock_interruptible(&i2c->fc->i2c_mutex))\r\nreturn -ERESTARTSYS;\r\nfor (i = 0; i < num; i++) {\r\nif (i+1 < num && (msgs[i+1].flags == I2C_M_RD)) {\r\nret = i2c->fc->i2c_request(i2c, FC_READ, msgs[i].addr,\r\nmsgs[i].buf[0], msgs[i+1].buf,\r\nmsgs[i+1].len);\r\ni++;\r\n} else\r\nret = i2c->fc->i2c_request(i2c, FC_WRITE, msgs[i].addr,\r\nmsgs[i].buf[0], &msgs[i].buf[1],\r\nmsgs[i].len - 1);\r\nif (ret < 0) {\r\ndeb_i2c("i2c master_xfer failed");\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&i2c->fc->i2c_mutex);\r\nif (ret == 0)\r\nret = num;\r\nreturn ret;\r\n}\r\nstatic u32 flexcop_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint flexcop_i2c_init(struct flexcop_device *fc)\r\n{\r\nint ret;\r\nmutex_init(&fc->i2c_mutex);\r\nfc->fc_i2c_adap[0].fc = fc;\r\nfc->fc_i2c_adap[1].fc = fc;\r\nfc->fc_i2c_adap[2].fc = fc;\r\nfc->fc_i2c_adap[0].port = FC_I2C_PORT_DEMOD;\r\nfc->fc_i2c_adap[1].port = FC_I2C_PORT_EEPROM;\r\nfc->fc_i2c_adap[2].port = FC_I2C_PORT_TUNER;\r\nstrlcpy(fc->fc_i2c_adap[0].i2c_adap.name, "B2C2 FlexCop I2C to demod",\r\nsizeof(fc->fc_i2c_adap[0].i2c_adap.name));\r\nstrlcpy(fc->fc_i2c_adap[1].i2c_adap.name, "B2C2 FlexCop I2C to eeprom",\r\nsizeof(fc->fc_i2c_adap[1].i2c_adap.name));\r\nstrlcpy(fc->fc_i2c_adap[2].i2c_adap.name, "B2C2 FlexCop I2C to tuner",\r\nsizeof(fc->fc_i2c_adap[2].i2c_adap.name));\r\ni2c_set_adapdata(&fc->fc_i2c_adap[0].i2c_adap, &fc->fc_i2c_adap[0]);\r\ni2c_set_adapdata(&fc->fc_i2c_adap[1].i2c_adap, &fc->fc_i2c_adap[1]);\r\ni2c_set_adapdata(&fc->fc_i2c_adap[2].i2c_adap, &fc->fc_i2c_adap[2]);\r\nfc->fc_i2c_adap[0].i2c_adap.algo =\r\nfc->fc_i2c_adap[1].i2c_adap.algo =\r\nfc->fc_i2c_adap[2].i2c_adap.algo = &flexcop_algo;\r\nfc->fc_i2c_adap[0].i2c_adap.algo_data =\r\nfc->fc_i2c_adap[1].i2c_adap.algo_data =\r\nfc->fc_i2c_adap[2].i2c_adap.algo_data = NULL;\r\nfc->fc_i2c_adap[0].i2c_adap.dev.parent =\r\nfc->fc_i2c_adap[1].i2c_adap.dev.parent =\r\nfc->fc_i2c_adap[2].i2c_adap.dev.parent = fc->dev;\r\nret = i2c_add_adapter(&fc->fc_i2c_adap[0].i2c_adap);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_add_adapter(&fc->fc_i2c_adap[1].i2c_adap);\r\nif (ret < 0)\r\ngoto adap_1_failed;\r\nret = i2c_add_adapter(&fc->fc_i2c_adap[2].i2c_adap);\r\nif (ret < 0)\r\ngoto adap_2_failed;\r\nfc->init_state |= FC_STATE_I2C_INIT;\r\nreturn 0;\r\nadap_2_failed:\r\ni2c_del_adapter(&fc->fc_i2c_adap[1].i2c_adap);\r\nadap_1_failed:\r\ni2c_del_adapter(&fc->fc_i2c_adap[0].i2c_adap);\r\nreturn ret;\r\n}\r\nvoid flexcop_i2c_exit(struct flexcop_device *fc)\r\n{\r\nif (fc->init_state & FC_STATE_I2C_INIT) {\r\ni2c_del_adapter(&fc->fc_i2c_adap[2].i2c_adap);\r\ni2c_del_adapter(&fc->fc_i2c_adap[1].i2c_adap);\r\ni2c_del_adapter(&fc->fc_i2c_adap[0].i2c_adap);\r\n}\r\nfc->init_state &= ~FC_STATE_I2C_INIT;\r\n}
