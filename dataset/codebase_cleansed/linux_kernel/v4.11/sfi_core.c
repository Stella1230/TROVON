static void __iomem * __ref sfi_map_memory(u64 phys, u32 size)\r\n{\r\nif (!phys || !size)\r\nreturn NULL;\r\nif (sfi_use_ioremap)\r\nreturn ioremap_cache(phys, size);\r\nelse\r\nreturn early_ioremap(phys, size);\r\n}\r\nstatic void __ref sfi_unmap_memory(void __iomem *virt, u32 size)\r\n{\r\nif (!virt || !size)\r\nreturn;\r\nif (sfi_use_ioremap)\r\niounmap(virt);\r\nelse\r\nearly_iounmap(virt, size);\r\n}\r\nstatic void sfi_print_table_header(unsigned long long pa,\r\nstruct sfi_table_header *header)\r\n{\r\npr_info("%4.4s %llX, %04X (v%d %6.6s %8.8s)\n",\r\nheader->sig, pa,\r\nheader->len, header->rev, header->oem_id,\r\nheader->oem_table_id);\r\n}\r\nstatic int sfi_verify_table(struct sfi_table_header *table)\r\n{\r\nu8 checksum = 0;\r\nu8 *puchar = (u8 *)table;\r\nu32 length = table->len;\r\nif (length > 0x100000) {\r\npr_err("Invalid table length 0x%x\n", length);\r\nreturn -1;\r\n}\r\nwhile (length--)\r\nchecksum += *puchar++;\r\nif (checksum) {\r\npr_err("Checksum %2.2X should be %2.2X\n",\r\ntable->csum, table->csum - checksum);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sfi_table_header *sfi_map_table(u64 pa)\r\n{\r\nstruct sfi_table_header *th;\r\nu32 length;\r\nif (!TABLE_ON_PAGE(syst_pa, pa, sizeof(struct sfi_table_header)))\r\nth = sfi_map_memory(pa, sizeof(struct sfi_table_header));\r\nelse\r\nth = (void *)syst_va + (pa - syst_pa);\r\nif (TABLE_ON_PAGE(th, th, th->len))\r\nreturn th;\r\nlength = th->len;\r\nif (!TABLE_ON_PAGE(syst_pa, pa, sizeof(struct sfi_table_header)))\r\nsfi_unmap_memory(th, sizeof(struct sfi_table_header));\r\nreturn sfi_map_memory(pa, length);\r\n}\r\nstatic void sfi_unmap_table(struct sfi_table_header *th)\r\n{\r\nif (!TABLE_ON_PAGE(syst_va, th, th->len))\r\nsfi_unmap_memory(th, TABLE_ON_PAGE(th, th, th->len) ?\r\nsizeof(*th) : th->len);\r\n}\r\nstatic int sfi_table_check_key(struct sfi_table_header *th,\r\nstruct sfi_table_key *key)\r\n{\r\nif (strncmp(th->sig, key->sig, SFI_SIGNATURE_SIZE)\r\n|| (key->oem_id && strncmp(th->oem_id,\r\nkey->oem_id, SFI_OEM_ID_SIZE))\r\n|| (key->oem_table_id && strncmp(th->oem_table_id,\r\nkey->oem_table_id, SFI_OEM_TABLE_ID_SIZE)))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstruct sfi_table_header *\r\n__ref sfi_check_table(u64 pa, struct sfi_table_key *key)\r\n{\r\nstruct sfi_table_header *th;\r\nvoid *ret = NULL;\r\nth = sfi_map_table(pa);\r\nif (!th)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (!key->sig) {\r\nsfi_print_table_header(pa, th);\r\nif (sfi_verify_table(th))\r\nret = ERR_PTR(-EINVAL);\r\n} else {\r\nif (!sfi_table_check_key(th, key))\r\nreturn th;\r\n}\r\nsfi_unmap_table(th);\r\nreturn ret;\r\n}\r\nstruct sfi_table_header *sfi_get_table(struct sfi_table_key *key)\r\n{\r\nstruct sfi_table_header *th;\r\nu32 tbl_cnt, i;\r\ntbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);\r\nfor (i = 0; i < tbl_cnt; i++) {\r\nth = sfi_check_table(syst_va->pentry[i], key);\r\nif (!IS_ERR(th) && th)\r\nreturn th;\r\n}\r\nreturn NULL;\r\n}\r\nvoid sfi_put_table(struct sfi_table_header *th)\r\n{\r\nsfi_unmap_table(th);\r\n}\r\nint sfi_table_parse(char *signature, char *oem_id, char *oem_table_id,\r\nsfi_table_handler handler)\r\n{\r\nstruct sfi_table_header *table = NULL;\r\nstruct sfi_table_key key;\r\nint ret = -EINVAL;\r\nif (sfi_disabled || !handler || !signature)\r\ngoto exit;\r\nkey.sig = signature;\r\nkey.oem_id = oem_id;\r\nkey.oem_table_id = oem_table_id;\r\ntable = sfi_get_table(&key);\r\nif (!table)\r\ngoto exit;\r\nret = handler(table);\r\nsfi_put_table(table);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int __init sfi_parse_syst(void)\r\n{\r\nstruct sfi_table_key key = SFI_ANY_KEY;\r\nint tbl_cnt, i;\r\nvoid *ret;\r\nsyst_va = sfi_map_memory(syst_pa, sizeof(struct sfi_table_simple));\r\nif (!syst_va)\r\nreturn -ENOMEM;\r\ntbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);\r\nfor (i = 0; i < tbl_cnt; i++) {\r\nret = sfi_check_table(syst_va->pentry[i], &key);\r\nif (IS_ERR(ret))\r\nreturn PTR_ERR(ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int sfi_find_syst(void)\r\n{\r\nunsigned long offset, len;\r\nvoid *start;\r\nlen = SFI_SYST_SEARCH_END - SFI_SYST_SEARCH_BEGIN;\r\nstart = sfi_map_memory(SFI_SYST_SEARCH_BEGIN, len);\r\nif (!start)\r\nreturn -1;\r\nfor (offset = 0; offset < len; offset += 16) {\r\nstruct sfi_table_header *syst_hdr;\r\nsyst_hdr = start + offset;\r\nif (strncmp(syst_hdr->sig, SFI_SIG_SYST,\r\nSFI_SIGNATURE_SIZE))\r\ncontinue;\r\nif (syst_hdr->len > PAGE_SIZE)\r\ncontinue;\r\nsfi_print_table_header(SFI_SYST_SEARCH_BEGIN + offset,\r\nsyst_hdr);\r\nif (sfi_verify_table(syst_hdr))\r\ncontinue;\r\nif (!ON_SAME_PAGE(syst_pa, syst_pa + syst_hdr->len)) {\r\npr_info("SYST 0x%llx + 0x%x crosses page\n",\r\nsyst_pa, syst_hdr->len);\r\ncontinue;\r\n}\r\nsyst_pa = SFI_SYST_SEARCH_BEGIN + offset;\r\nsfi_unmap_memory(start, len);\r\nreturn 0;\r\n}\r\nsfi_unmap_memory(start, len);\r\nreturn -1;\r\n}\r\nstatic ssize_t sfi_table_show(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t offset, size_t count)\r\n{\r\nstruct sfi_table_attr *tbl_attr =\r\ncontainer_of(bin_attr, struct sfi_table_attr, attr);\r\nstruct sfi_table_header *th = NULL;\r\nstruct sfi_table_key key;\r\nssize_t cnt;\r\nkey.sig = tbl_attr->name;\r\nkey.oem_id = NULL;\r\nkey.oem_table_id = NULL;\r\nif (strncmp(SFI_SIG_SYST, tbl_attr->name, SFI_SIGNATURE_SIZE)) {\r\nth = sfi_get_table(&key);\r\nif (!th)\r\nreturn 0;\r\ncnt = memory_read_from_buffer(buf, count, &offset,\r\nth, th->len);\r\nsfi_put_table(th);\r\n} else\r\ncnt = memory_read_from_buffer(buf, count, &offset,\r\nsyst_va, syst_va->header.len);\r\nreturn cnt;\r\n}\r\nstruct sfi_table_attr __init *sfi_sysfs_install_table(u64 pa)\r\n{\r\nstruct sfi_table_attr *tbl_attr;\r\nstruct sfi_table_header *th;\r\nint ret;\r\ntbl_attr = kzalloc(sizeof(struct sfi_table_attr), GFP_KERNEL);\r\nif (!tbl_attr)\r\nreturn NULL;\r\nth = sfi_map_table(pa);\r\nif (!th || !th->sig[0]) {\r\nkfree(tbl_attr);\r\nreturn NULL;\r\n}\r\nsysfs_attr_init(&tbl_attr->attr.attr);\r\nmemcpy(tbl_attr->name, th->sig, SFI_SIGNATURE_SIZE);\r\ntbl_attr->attr.size = 0;\r\ntbl_attr->attr.read = sfi_table_show;\r\ntbl_attr->attr.attr.name = tbl_attr->name;\r\ntbl_attr->attr.attr.mode = 0400;\r\nret = sysfs_create_bin_file(tables_kobj,\r\n&tbl_attr->attr);\r\nif (ret) {\r\nkfree(tbl_attr);\r\ntbl_attr = NULL;\r\n}\r\nsfi_unmap_table(th);\r\nreturn tbl_attr;\r\n}\r\nstatic int __init sfi_sysfs_init(void)\r\n{\r\nint tbl_cnt, i;\r\nif (sfi_disabled)\r\nreturn 0;\r\nsfi_kobj = kobject_create_and_add("sfi", firmware_kobj);\r\nif (!sfi_kobj)\r\nreturn 0;\r\ntables_kobj = kobject_create_and_add("tables", sfi_kobj);\r\nif (!tables_kobj) {\r\nkobject_put(sfi_kobj);\r\nreturn 0;\r\n}\r\nsfi_sysfs_install_table(syst_pa);\r\ntbl_cnt = SFI_GET_NUM_ENTRIES(syst_va, u64);\r\nfor (i = 0; i < tbl_cnt; i++)\r\nsfi_sysfs_install_table(syst_va->pentry[i]);\r\nsfi_acpi_sysfs_init();\r\nkobject_uevent(sfi_kobj, KOBJ_ADD);\r\nkobject_uevent(tables_kobj, KOBJ_ADD);\r\npr_info("SFI sysfs interfaces init success\n");\r\nreturn 0;\r\n}\r\nvoid __init sfi_init(void)\r\n{\r\nif (!acpi_disabled)\r\ndisable_sfi();\r\nif (sfi_disabled)\r\nreturn;\r\npr_info("Simple Firmware Interface v0.81 http://simplefirmware.org\n");\r\nif (sfi_find_syst() || sfi_parse_syst() || sfi_platform_init())\r\ndisable_sfi();\r\nreturn;\r\n}\r\nvoid __init sfi_init_late(void)\r\n{\r\nint length;\r\nif (sfi_disabled)\r\nreturn;\r\nlength = syst_va->header.len;\r\nsfi_unmap_memory(syst_va, sizeof(struct sfi_table_simple));\r\nsfi_use_ioremap = 1;\r\nsyst_va = sfi_map_memory(syst_pa, length);\r\nsfi_acpi_init();\r\n}
