static void qcom_ebi2_setup_chipselect(struct device_node *np,\r\nstruct device *dev,\r\nvoid __iomem *ebi2_base,\r\nvoid __iomem *ebi2_xmem,\r\nu32 csindex)\r\n{\r\nconst struct cs_data *csd;\r\nu32 slowcfg, fastcfg;\r\nu32 val;\r\nint ret;\r\nint i;\r\ncsd = &cs_info[csindex];\r\nval = readl(ebi2_base);\r\nval |= csd->enable_mask;\r\nwritel(val, ebi2_base);\r\ndev_dbg(dev, "enabled CS%u\n", csindex);\r\nslowcfg = 0;\r\nfastcfg = 0;\r\nfor (i = 0; i < ARRAY_SIZE(xmem_props); i++) {\r\nconst struct ebi2_xmem_prop *xp = &xmem_props[i];\r\nret = of_property_read_u32(np, xp->prop, &val);\r\nif (ret) {\r\ndev_dbg(dev, "could not read %s for CS%d\n",\r\nxp->prop, csindex);\r\ncontinue;\r\n}\r\nif (xp->max == 1 && val) {\r\nif (xp->slowreg)\r\nslowcfg |= BIT(xp->shift);\r\nelse\r\nfastcfg |= BIT(xp->shift);\r\ndev_dbg(dev, "set %s flag\n", xp->prop);\r\ncontinue;\r\n}\r\nif (val > xp->max) {\r\ndev_err(dev,\r\n"too high value for %s: %u, capped at %u\n",\r\nxp->prop, val, xp->max);\r\nval = xp->max;\r\n}\r\nif (xp->slowreg)\r\nslowcfg |= (val << xp->shift);\r\nelse\r\nfastcfg |= (val << xp->shift);\r\ndev_dbg(dev, "set %s to %u\n", xp->prop, val);\r\n}\r\ndev_info(dev, "CS%u: SLOW CFG 0x%08x, FAST CFG 0x%08x\n",\r\ncsindex, slowcfg, fastcfg);\r\nif (slowcfg)\r\nwritel(slowcfg, ebi2_xmem + csd->slow_cfg);\r\nif (fastcfg)\r\nwritel(fastcfg, ebi2_xmem + csd->fast_cfg);\r\n}\r\nstatic int qcom_ebi2_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nvoid __iomem *ebi2_base;\r\nvoid __iomem *ebi2_xmem;\r\nstruct clk *ebi2xclk;\r\nstruct clk *ebi2clk;\r\nbool have_children = false;\r\nu32 val;\r\nint ret;\r\nebi2xclk = devm_clk_get(dev, "ebi2x");\r\nif (IS_ERR(ebi2xclk))\r\nreturn PTR_ERR(ebi2xclk);\r\nret = clk_prepare_enable(ebi2xclk);\r\nif (ret) {\r\ndev_err(dev, "could not enable EBI2X clk (%d)\n", ret);\r\nreturn ret;\r\n}\r\nebi2clk = devm_clk_get(dev, "ebi2");\r\nif (IS_ERR(ebi2clk)) {\r\nret = PTR_ERR(ebi2clk);\r\ngoto err_disable_2x_clk;\r\n}\r\nret = clk_prepare_enable(ebi2clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable EBI2 clk\n");\r\ngoto err_disable_2x_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nebi2_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ebi2_base)) {\r\nret = PTR_ERR(ebi2_base);\r\ngoto err_disable_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nebi2_xmem = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ebi2_xmem)) {\r\nret = PTR_ERR(ebi2_xmem);\r\ngoto err_disable_clk;\r\n}\r\nwritel(0UL, ebi2_xmem + EBI2_XMEM_CFG);\r\nval = readl(ebi2_base);\r\nval &= ~EBI2_CSN_MASK;\r\nwritel(val, ebi2_base);\r\nfor_each_available_child_of_node(np, child) {\r\nu32 csindex;\r\nret = of_property_read_u32(child, "reg", &csindex);\r\nif (ret)\r\nreturn ret;\r\nif (csindex > 5) {\r\ndev_err(dev,\r\n"invalid chipselect %u, we only support 0-5\n",\r\ncsindex);\r\ncontinue;\r\n}\r\nqcom_ebi2_setup_chipselect(child,\r\ndev,\r\nebi2_base,\r\nebi2_xmem,\r\ncsindex);\r\nhave_children = true;\r\n}\r\nif (have_children)\r\nreturn of_platform_default_populate(np, NULL, dev);\r\nreturn 0;\r\nerr_disable_clk:\r\nclk_disable_unprepare(ebi2clk);\r\nerr_disable_2x_clk:\r\nclk_disable_unprepare(ebi2xclk);\r\nreturn ret;\r\n}
