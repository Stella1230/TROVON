static inline u32 ib_fmr_hash(u64 first_page)\r\n{\r\nreturn jhash_2words((u32) first_page, (u32) (first_page >> 32), 0) &\r\n(IB_FMR_HASH_SIZE - 1);\r\n}\r\nstatic inline struct ib_pool_fmr *ib_fmr_cache_lookup(struct ib_fmr_pool *pool,\r\nu64 *page_list,\r\nint page_list_len,\r\nu64 io_virtual_address)\r\n{\r\nstruct hlist_head *bucket;\r\nstruct ib_pool_fmr *fmr;\r\nif (!pool->cache_bucket)\r\nreturn NULL;\r\nbucket = pool->cache_bucket + ib_fmr_hash(*page_list);\r\nhlist_for_each_entry(fmr, bucket, cache_node)\r\nif (io_virtual_address == fmr->io_virtual_address &&\r\npage_list_len == fmr->page_list_len &&\r\n!memcmp(page_list, fmr->page_list,\r\npage_list_len * sizeof *page_list))\r\nreturn fmr;\r\nreturn NULL;\r\n}\r\nstatic void ib_fmr_batch_release(struct ib_fmr_pool *pool)\r\n{\r\nint ret;\r\nstruct ib_pool_fmr *fmr;\r\nLIST_HEAD(unmap_list);\r\nLIST_HEAD(fmr_list);\r\nspin_lock_irq(&pool->pool_lock);\r\nlist_for_each_entry(fmr, &pool->dirty_list, list) {\r\nhlist_del_init(&fmr->cache_node);\r\nfmr->remap_count = 0;\r\nlist_add_tail(&fmr->fmr->list, &fmr_list);\r\n#ifdef DEBUG\r\nif (fmr->ref_count !=0) {\r\npr_warn(PFX "Unmapping FMR 0x%08x with ref count %d\n",\r\nfmr, fmr->ref_count);\r\n}\r\n#endif\r\n}\r\nlist_splice_init(&pool->dirty_list, &unmap_list);\r\npool->dirty_len = 0;\r\nspin_unlock_irq(&pool->pool_lock);\r\nif (list_empty(&unmap_list)) {\r\nreturn;\r\n}\r\nret = ib_unmap_fmr(&fmr_list);\r\nif (ret)\r\npr_warn(PFX "ib_unmap_fmr returned %d\n", ret);\r\nspin_lock_irq(&pool->pool_lock);\r\nlist_splice(&unmap_list, &pool->free_list);\r\nspin_unlock_irq(&pool->pool_lock);\r\n}\r\nstatic int ib_fmr_cleanup_thread(void *pool_ptr)\r\n{\r\nstruct ib_fmr_pool *pool = pool_ptr;\r\ndo {\r\nif (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) < 0) {\r\nib_fmr_batch_release(pool);\r\natomic_inc(&pool->flush_ser);\r\nwake_up_interruptible(&pool->force_wait);\r\nif (pool->flush_function)\r\npool->flush_function(pool, pool->flush_arg);\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (atomic_read(&pool->flush_ser) - atomic_read(&pool->req_ser) >= 0 &&\r\n!kthread_should_stop())\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\n} while (!kthread_should_stop());\r\nreturn 0;\r\n}\r\nstruct ib_fmr_pool *ib_create_fmr_pool(struct ib_pd *pd,\r\nstruct ib_fmr_pool_param *params)\r\n{\r\nstruct ib_device *device;\r\nstruct ib_fmr_pool *pool;\r\nint i;\r\nint ret;\r\nint max_remaps;\r\nif (!params)\r\nreturn ERR_PTR(-EINVAL);\r\ndevice = pd->device;\r\nif (!device->alloc_fmr || !device->dealloc_fmr ||\r\n!device->map_phys_fmr || !device->unmap_fmr) {\r\npr_info(PFX "Device %s does not support FMRs\n", device->name);\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nif (!device->attrs.max_map_per_fmr)\r\nmax_remaps = IB_FMR_MAX_REMAPS;\r\nelse\r\nmax_remaps = device->attrs.max_map_per_fmr;\r\npool = kmalloc(sizeof *pool, GFP_KERNEL);\r\nif (!pool)\r\nreturn ERR_PTR(-ENOMEM);\r\npool->cache_bucket = NULL;\r\npool->flush_function = params->flush_function;\r\npool->flush_arg = params->flush_arg;\r\nINIT_LIST_HEAD(&pool->free_list);\r\nINIT_LIST_HEAD(&pool->dirty_list);\r\nif (params->cache) {\r\npool->cache_bucket =\r\nkmalloc(IB_FMR_HASH_SIZE * sizeof *pool->cache_bucket,\r\nGFP_KERNEL);\r\nif (!pool->cache_bucket) {\r\nret = -ENOMEM;\r\ngoto out_free_pool;\r\n}\r\nfor (i = 0; i < IB_FMR_HASH_SIZE; ++i)\r\nINIT_HLIST_HEAD(pool->cache_bucket + i);\r\n}\r\npool->pool_size = 0;\r\npool->max_pages = params->max_pages_per_fmr;\r\npool->max_remaps = max_remaps;\r\npool->dirty_watermark = params->dirty_watermark;\r\npool->dirty_len = 0;\r\nspin_lock_init(&pool->pool_lock);\r\natomic_set(&pool->req_ser, 0);\r\natomic_set(&pool->flush_ser, 0);\r\ninit_waitqueue_head(&pool->force_wait);\r\npool->thread = kthread_run(ib_fmr_cleanup_thread,\r\npool,\r\n"ib_fmr(%s)",\r\ndevice->name);\r\nif (IS_ERR(pool->thread)) {\r\npr_warn(PFX "couldn't start cleanup thread\n");\r\nret = PTR_ERR(pool->thread);\r\ngoto out_free_pool;\r\n}\r\n{\r\nstruct ib_pool_fmr *fmr;\r\nstruct ib_fmr_attr fmr_attr = {\r\n.max_pages = params->max_pages_per_fmr,\r\n.max_maps = pool->max_remaps,\r\n.page_shift = params->page_shift\r\n};\r\nint bytes_per_fmr = sizeof *fmr;\r\nif (pool->cache_bucket)\r\nbytes_per_fmr += params->max_pages_per_fmr * sizeof (u64);\r\nfor (i = 0; i < params->pool_size; ++i) {\r\nfmr = kmalloc(bytes_per_fmr, GFP_KERNEL);\r\nif (!fmr)\r\ngoto out_fail;\r\nfmr->pool = pool;\r\nfmr->remap_count = 0;\r\nfmr->ref_count = 0;\r\nINIT_HLIST_NODE(&fmr->cache_node);\r\nfmr->fmr = ib_alloc_fmr(pd, params->access, &fmr_attr);\r\nif (IS_ERR(fmr->fmr)) {\r\npr_warn(PFX "fmr_create failed for FMR %d\n",\r\ni);\r\nkfree(fmr);\r\ngoto out_fail;\r\n}\r\nlist_add_tail(&fmr->list, &pool->free_list);\r\n++pool->pool_size;\r\n}\r\n}\r\nreturn pool;\r\nout_free_pool:\r\nkfree(pool->cache_bucket);\r\nkfree(pool);\r\nreturn ERR_PTR(ret);\r\nout_fail:\r\nib_destroy_fmr_pool(pool);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid ib_destroy_fmr_pool(struct ib_fmr_pool *pool)\r\n{\r\nstruct ib_pool_fmr *fmr;\r\nstruct ib_pool_fmr *tmp;\r\nLIST_HEAD(fmr_list);\r\nint i;\r\nkthread_stop(pool->thread);\r\nib_fmr_batch_release(pool);\r\ni = 0;\r\nlist_for_each_entry_safe(fmr, tmp, &pool->free_list, list) {\r\nif (fmr->remap_count) {\r\nINIT_LIST_HEAD(&fmr_list);\r\nlist_add_tail(&fmr->fmr->list, &fmr_list);\r\nib_unmap_fmr(&fmr_list);\r\n}\r\nib_dealloc_fmr(fmr->fmr);\r\nlist_del(&fmr->list);\r\nkfree(fmr);\r\n++i;\r\n}\r\nif (i < pool->pool_size)\r\npr_warn(PFX "pool still has %d regions registered\n",\r\npool->pool_size - i);\r\nkfree(pool->cache_bucket);\r\nkfree(pool);\r\n}\r\nint ib_flush_fmr_pool(struct ib_fmr_pool *pool)\r\n{\r\nint serial;\r\nstruct ib_pool_fmr *fmr, *next;\r\nspin_lock_irq(&pool->pool_lock);\r\nlist_for_each_entry_safe(fmr, next, &pool->free_list, list) {\r\nif (fmr->remap_count > 0)\r\nlist_move(&fmr->list, &pool->dirty_list);\r\n}\r\nspin_unlock_irq(&pool->pool_lock);\r\nserial = atomic_inc_return(&pool->req_ser);\r\nwake_up_process(pool->thread);\r\nif (wait_event_interruptible(pool->force_wait,\r\natomic_read(&pool->flush_ser) - serial >= 0))\r\nreturn -EINTR;\r\nreturn 0;\r\n}\r\nstruct ib_pool_fmr *ib_fmr_pool_map_phys(struct ib_fmr_pool *pool_handle,\r\nu64 *page_list,\r\nint list_len,\r\nu64 io_virtual_address)\r\n{\r\nstruct ib_fmr_pool *pool = pool_handle;\r\nstruct ib_pool_fmr *fmr;\r\nunsigned long flags;\r\nint result;\r\nif (list_len < 1 || list_len > pool->max_pages)\r\nreturn ERR_PTR(-EINVAL);\r\nspin_lock_irqsave(&pool->pool_lock, flags);\r\nfmr = ib_fmr_cache_lookup(pool,\r\npage_list,\r\nlist_len,\r\nio_virtual_address);\r\nif (fmr) {\r\n++fmr->ref_count;\r\nif (fmr->ref_count == 1) {\r\nlist_del(&fmr->list);\r\n}\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\nreturn fmr;\r\n}\r\nif (list_empty(&pool->free_list)) {\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nfmr = list_entry(pool->free_list.next, struct ib_pool_fmr, list);\r\nlist_del(&fmr->list);\r\nhlist_del_init(&fmr->cache_node);\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\nresult = ib_map_phys_fmr(fmr->fmr, page_list, list_len,\r\nio_virtual_address);\r\nif (result) {\r\nspin_lock_irqsave(&pool->pool_lock, flags);\r\nlist_add(&fmr->list, &pool->free_list);\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\npr_warn(PFX "fmr_map returns %d\n", result);\r\nreturn ERR_PTR(result);\r\n}\r\n++fmr->remap_count;\r\nfmr->ref_count = 1;\r\nif (pool->cache_bucket) {\r\nfmr->io_virtual_address = io_virtual_address;\r\nfmr->page_list_len = list_len;\r\nmemcpy(fmr->page_list, page_list, list_len * sizeof(*page_list));\r\nspin_lock_irqsave(&pool->pool_lock, flags);\r\nhlist_add_head(&fmr->cache_node,\r\npool->cache_bucket + ib_fmr_hash(fmr->page_list[0]));\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\n}\r\nreturn fmr;\r\n}\r\nint ib_fmr_pool_unmap(struct ib_pool_fmr *fmr)\r\n{\r\nstruct ib_fmr_pool *pool;\r\nunsigned long flags;\r\npool = fmr->pool;\r\nspin_lock_irqsave(&pool->pool_lock, flags);\r\n--fmr->ref_count;\r\nif (!fmr->ref_count) {\r\nif (fmr->remap_count < pool->max_remaps) {\r\nlist_add_tail(&fmr->list, &pool->free_list);\r\n} else {\r\nlist_add_tail(&fmr->list, &pool->dirty_list);\r\nif (++pool->dirty_len >= pool->dirty_watermark) {\r\natomic_inc(&pool->req_ser);\r\nwake_up_process(pool->thread);\r\n}\r\n}\r\n}\r\n#ifdef DEBUG\r\nif (fmr->ref_count < 0)\r\npr_warn(PFX "FMR %p has ref count %d < 0\n",\r\nfmr, fmr->ref_count);\r\n#endif\r\nspin_unlock_irqrestore(&pool->pool_lock, flags);\r\nreturn 0;\r\n}
