static int spi_clps711x_setup(struct spi_device *spi)\r\n{\r\nif (!spi->controller_state) {\r\nint ret;\r\nret = devm_gpio_request(&spi->master->dev, spi->cs_gpio,\r\ndev_name(&spi->master->dev));\r\nif (ret)\r\nreturn ret;\r\nspi->controller_state = spi;\r\n}\r\ngpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\nreturn 0;\r\n}\r\nstatic int spi_clps711x_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct spi_clps711x_data *hw = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\nreturn regmap_update_bits(hw->syscon, SYSCON_OFFSET, SYSCON3_ADCCKNSEN,\r\n(spi->mode & SPI_CPHA) ?\r\nSYSCON3_ADCCKNSEN : 0);\r\n}\r\nstatic int spi_clps711x_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct spi_clps711x_data *hw = spi_master_get_devdata(master);\r\nu8 data;\r\nclk_set_rate(hw->spi_clk, xfer->speed_hz ? : spi->max_speed_hz);\r\nhw->len = xfer->len;\r\nhw->bpw = xfer->bits_per_word;\r\nhw->tx_buf = (u8 *)xfer->tx_buf;\r\nhw->rx_buf = (u8 *)xfer->rx_buf;\r\ndata = hw->tx_buf ? *hw->tx_buf++ : 0;\r\nwritel(data | SYNCIO_FRMLEN(hw->bpw) | SYNCIO_TXFRMEN, hw->syncio);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t spi_clps711x_isr(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct spi_clps711x_data *hw = spi_master_get_devdata(master);\r\nu8 data;\r\ndata = readb(hw->syncio);\r\nif (hw->rx_buf)\r\n*hw->rx_buf++ = data;\r\nif (--hw->len > 0) {\r\ndata = hw->tx_buf ? *hw->tx_buf++ : 0;\r\nwritel(data | SYNCIO_FRMLEN(hw->bpw) | SYNCIO_TXFRMEN,\r\nhw->syncio);\r\n} else\r\nspi_finalize_current_transfer(master);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_clps711x_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_clps711x_data *hw;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nint irq, ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*hw));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->bus_num = -1;\r\nmaster->mode_bits = SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 8);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->setup = spi_clps711x_setup;\r\nmaster->prepare_message = spi_clps711x_prepare_message;\r\nmaster->transfer_one = spi_clps711x_transfer_one;\r\nhw = spi_master_get_devdata(master);\r\nhw->spi_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(hw->spi_clk)) {\r\nret = PTR_ERR(hw->spi_clk);\r\ngoto err_out;\r\n}\r\nhw->syscon =\r\nsyscon_regmap_lookup_by_compatible("cirrus,ep7209-syscon3");\r\nif (IS_ERR(hw->syscon)) {\r\nret = PTR_ERR(hw->syscon);\r\ngoto err_out;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhw->syncio = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hw->syncio)) {\r\nret = PTR_ERR(hw->syncio);\r\ngoto err_out;\r\n}\r\nregmap_update_bits(hw->syscon, SYSCON_OFFSET, SYSCON3_ADCCON, 0);\r\nreadl(hw->syncio);\r\nret = devm_request_irq(&pdev->dev, irq, spi_clps711x_isr, 0,\r\ndev_name(&pdev->dev), master);\r\nif (ret)\r\ngoto err_out;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (!ret)\r\nreturn 0;\r\nerr_out:\r\nspi_master_put(master);\r\nreturn ret;\r\n}
