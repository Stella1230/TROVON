static int brcmf_pno_channel_config(struct brcmf_if *ifp,\r\nstruct brcmf_pno_config_le *cfg)\r\n{\r\ncfg->reporttype = 0;\r\ncfg->flags = 0;\r\nreturn brcmf_fil_iovar_data_set(ifp, "pfn_cfg", cfg, sizeof(*cfg));\r\n}\r\nstatic int brcmf_pno_config(struct brcmf_if *ifp, u32 scan_freq,\r\nu32 mscan, u32 bestn)\r\n{\r\nstruct brcmf_pno_param_le pfn_param;\r\nu16 flags;\r\nu32 pfnmem;\r\ns32 err;\r\nmemset(&pfn_param, 0, sizeof(pfn_param));\r\npfn_param.version = cpu_to_le32(BRCMF_PNO_VERSION);\r\nflags = BIT(BRCMF_PNO_IMMEDIATE_SCAN_BIT) |\r\nBIT(BRCMF_PNO_REPORT_SEPARATELY_BIT) |\r\nBIT(BRCMF_PNO_ENABLE_ADAPTSCAN_BIT);\r\npfn_param.repeat = BRCMF_PNO_REPEAT;\r\npfn_param.exp = BRCMF_PNO_FREQ_EXPO_MAX;\r\nif (scan_freq < BRCMF_PNO_SCHED_SCAN_MIN_PERIOD) {\r\nbrcmf_dbg(SCAN, "scan period too small, using minimum\n");\r\nscan_freq = BRCMF_PNO_SCHED_SCAN_MIN_PERIOD;\r\n}\r\npfn_param.scan_freq = cpu_to_le32(scan_freq);\r\nif (mscan) {\r\npfnmem = bestn;\r\nerr = brcmf_fil_iovar_int_set(ifp, "pfnmem", pfnmem);\r\nif (err < 0) {\r\nbrcmf_err("failed to set pfnmem\n");\r\ngoto exit;\r\n}\r\nerr = brcmf_fil_iovar_int_get(ifp, "pfnmem", &pfnmem);\r\nif (err < 0) {\r\nbrcmf_err("failed to get pfnmem\n");\r\ngoto exit;\r\n}\r\nmscan = min_t(u32, mscan, pfnmem);\r\npfn_param.mscan = mscan;\r\npfn_param.bestn = bestn;\r\nflags |= BIT(BRCMF_PNO_ENABLE_BD_SCAN_BIT);\r\nbrcmf_dbg(INFO, "mscan=%d, bestn=%d\n", mscan, bestn);\r\n}\r\npfn_param.flags = cpu_to_le16(flags);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_set", &pfn_param,\r\nsizeof(pfn_param));\r\nif (err)\r\nbrcmf_err("pfn_set failed, err=%d\n", err);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_set_random(struct brcmf_if *ifp, u8 *mac_addr,\r\nu8 *mac_mask)\r\n{\r\nstruct brcmf_pno_macaddr_le pfn_mac;\r\nint err, i;\r\npfn_mac.version = BRCMF_PFN_MACADDR_CFG_VER;\r\npfn_mac.flags = BRCMF_PFN_MAC_OUI_ONLY | BRCMF_PFN_SET_MAC_UNASSOC;\r\nmemcpy(pfn_mac.mac, mac_addr, ETH_ALEN);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\npfn_mac.mac[i] &= mac_mask[i];\r\npfn_mac.mac[i] |= get_random_int() & ~(mac_mask[i]);\r\n}\r\npfn_mac.mac[0] &= 0xFE;\r\npfn_mac.mac[0] |= 0x02;\r\nerr = brcmf_fil_iovar_data_set(ifp, "pfn_macaddr", &pfn_mac,\r\nsizeof(pfn_mac));\r\nif (err)\r\nbrcmf_err("pfn_macaddr failed, err=%d\n", err);\r\nreturn err;\r\n}\r\nstatic int brcmf_pno_add_ssid(struct brcmf_if *ifp, struct cfg80211_ssid *ssid,\r\nbool active)\r\n{\r\nstruct brcmf_pno_net_param_le pfn;\r\npfn.auth = cpu_to_le32(WLAN_AUTH_OPEN);\r\npfn.wpa_auth = cpu_to_le32(BRCMF_PNO_WPA_AUTH_ANY);\r\npfn.wsec = cpu_to_le32(0);\r\npfn.infra = cpu_to_le32(1);\r\npfn.flags = 0;\r\nif (active)\r\npfn.flags = cpu_to_le32(1 << BRCMF_PNO_HIDDEN_BIT);\r\npfn.ssid.SSID_len = cpu_to_le32(ssid->ssid_len);\r\nmemcpy(pfn.ssid.SSID, ssid->ssid, ssid->ssid_len);\r\nreturn brcmf_fil_iovar_data_set(ifp, "pfn_add", &pfn, sizeof(pfn));\r\n}\r\nstatic bool brcmf_is_ssid_active(struct cfg80211_ssid *ssid,\r\nstruct cfg80211_sched_scan_request *req)\r\n{\r\nint i;\r\nif (!ssid || !req->ssids || !req->n_ssids)\r\nreturn false;\r\nfor (i = 0; i < req->n_ssids; i++) {\r\nif (ssid->ssid_len == req->ssids[i].ssid_len) {\r\nif (!strncmp(ssid->ssid, req->ssids[i].ssid,\r\nssid->ssid_len))\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nint brcmf_pno_clean(struct brcmf_if *ifp)\r\n{\r\nint ret;\r\nret = brcmf_fil_iovar_int_set(ifp, "pfn", 0);\r\nif (ret == 0) {\r\nret = brcmf_fil_iovar_data_set(ifp, "pfnclear", NULL, 0);\r\n}\r\nif (ret < 0)\r\nbrcmf_err("failed code %d\n", ret);\r\nreturn ret;\r\n}\r\nint brcmf_pno_start_sched_scan(struct brcmf_if *ifp,\r\nstruct cfg80211_sched_scan_request *req)\r\n{\r\nstruct brcmu_d11inf *d11inf;\r\nstruct brcmf_pno_config_le pno_cfg;\r\nstruct cfg80211_ssid *ssid;\r\nu16 chan;\r\nint i, ret;\r\nret = brcmf_pno_clean(ifp);\r\nif (ret < 0) {\r\nbrcmf_err("failed error=%d\n", ret);\r\nreturn ret;\r\n}\r\nret = brcmf_pno_config(ifp, req->scan_plans[0].interval, 0, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\r\nret = brcmf_pno_set_random(ifp, req->mac_addr,\r\nreq->mac_addr_mask);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nd11inf = &ifp->drvr->config->d11inf;\r\nfor (i = 0; i < req->n_channels; i++) {\r\nchan = req->channels[i]->hw_value;\r\npno_cfg.channel_list[i] = cpu_to_le16(chan);\r\n}\r\nif (req->n_channels) {\r\npno_cfg.channel_num = cpu_to_le32(req->n_channels);\r\nbrcmf_pno_channel_config(ifp, &pno_cfg);\r\n}\r\nfor (i = 0; i < req->n_match_sets; i++) {\r\nssid = &req->match_sets[i].ssid;\r\nif (!ssid->ssid_len) {\r\nbrcmf_err("skip broadcast ssid\n");\r\ncontinue;\r\n}\r\nret = brcmf_pno_add_ssid(ifp, ssid,\r\nbrcmf_is_ssid_active(ssid, req));\r\nif (ret < 0)\r\nbrcmf_dbg(SCAN, ">>> PNO filter %s for ssid (%s)\n",\r\nret == 0 ? "set" : "failed", ssid->ssid);\r\n}\r\nret = brcmf_fil_iovar_int_set(ifp, "pfn", 1);\r\nif (ret < 0)\r\nbrcmf_err("PNO enable failed!! ret=%d\n", ret);\r\nreturn ret;\r\n}
