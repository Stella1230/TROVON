static struct devcd_entry *dev_to_devcd(struct device *dev)\r\n{\r\nreturn container_of(dev, struct devcd_entry, devcd_dev);\r\n}\r\nstatic void devcd_dev_release(struct device *dev)\r\n{\r\nstruct devcd_entry *devcd = dev_to_devcd(dev);\r\ndevcd->free(devcd->data);\r\nmodule_put(devcd->owner);\r\nif (devcd->failing_dev->kobj.sd)\r\nsysfs_delete_link(&devcd->failing_dev->kobj, &dev->kobj,\r\n"devcoredump");\r\nput_device(devcd->failing_dev);\r\nkfree(devcd);\r\n}\r\nstatic void devcd_del(struct work_struct *wk)\r\n{\r\nstruct devcd_entry *devcd;\r\ndevcd = container_of(wk, struct devcd_entry, del_wk.work);\r\ndevice_del(&devcd->devcd_dev);\r\nput_device(&devcd->devcd_dev);\r\n}\r\nstatic ssize_t devcd_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct devcd_entry *devcd = dev_to_devcd(dev);\r\nreturn devcd->read(buffer, offset, count, devcd->data, devcd->datalen);\r\n}\r\nstatic ssize_t devcd_data_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct devcd_entry *devcd = dev_to_devcd(dev);\r\nmod_delayed_work(system_wq, &devcd->del_wk, 0);\r\nreturn count;\r\n}\r\nstatic int devcd_free(struct device *dev, void *data)\r\n{\r\nstruct devcd_entry *devcd = dev_to_devcd(dev);\r\nflush_delayed_work(&devcd->del_wk);\r\nreturn 0;\r\n}\r\nstatic ssize_t disabled_show(struct class *class, struct class_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", devcd_disabled);\r\n}\r\nstatic ssize_t disabled_store(struct class *class, struct class_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nlong tmp = simple_strtol(buf, NULL, 10);\r\nif (tmp != 1)\r\nreturn -EINVAL;\r\ndevcd_disabled = true;\r\nclass_for_each_device(&devcd_class, NULL, NULL, devcd_free);\r\nreturn count;\r\n}\r\nstatic ssize_t devcd_readv(char *buffer, loff_t offset, size_t count,\r\nvoid *data, size_t datalen)\r\n{\r\nif (offset > datalen)\r\nreturn -EINVAL;\r\nif (offset + count > datalen)\r\ncount = datalen - offset;\r\nif (count)\r\nmemcpy(buffer, ((u8 *)data) + offset, count);\r\nreturn count;\r\n}\r\nstatic void devcd_freev(void *data)\r\n{\r\nvfree(data);\r\n}\r\nvoid dev_coredumpv(struct device *dev, void *data, size_t datalen,\r\ngfp_t gfp)\r\n{\r\ndev_coredumpm(dev, NULL, data, datalen, gfp, devcd_readv, devcd_freev);\r\n}\r\nstatic int devcd_match_failing(struct device *dev, const void *failing)\r\n{\r\nstruct devcd_entry *devcd = dev_to_devcd(dev);\r\nreturn devcd->failing_dev == failing;\r\n}\r\nstatic void devcd_free_sgtable(void *data)\r\n{\r\n_devcd_free_sgtable(data);\r\n}\r\nstatic ssize_t devcd_read_from_sgtable(char *buffer, loff_t offset,\r\nsize_t buf_len, void *data,\r\nsize_t data_len)\r\n{\r\nstruct scatterlist *table = data;\r\nif (offset > data_len)\r\nreturn -EINVAL;\r\nif (offset + buf_len > data_len)\r\nbuf_len = data_len - offset;\r\nreturn sg_pcopy_to_buffer(table, sg_nents(table), buffer, buf_len,\r\noffset);\r\n}\r\nvoid dev_coredumpm(struct device *dev, struct module *owner,\r\nvoid *data, size_t datalen, gfp_t gfp,\r\nssize_t (*read)(char *buffer, loff_t offset, size_t count,\r\nvoid *data, size_t datalen),\r\nvoid (*free)(void *data))\r\n{\r\nstatic atomic_t devcd_count = ATOMIC_INIT(0);\r\nstruct devcd_entry *devcd;\r\nstruct device *existing;\r\nif (devcd_disabled)\r\ngoto free;\r\nexisting = class_find_device(&devcd_class, NULL, dev,\r\ndevcd_match_failing);\r\nif (existing) {\r\nput_device(existing);\r\ngoto free;\r\n}\r\nif (!try_module_get(owner))\r\ngoto free;\r\ndevcd = kzalloc(sizeof(*devcd), gfp);\r\nif (!devcd)\r\ngoto put_module;\r\ndevcd->owner = owner;\r\ndevcd->data = data;\r\ndevcd->datalen = datalen;\r\ndevcd->read = read;\r\ndevcd->free = free;\r\ndevcd->failing_dev = get_device(dev);\r\ndevice_initialize(&devcd->devcd_dev);\r\ndev_set_name(&devcd->devcd_dev, "devcd%d",\r\natomic_inc_return(&devcd_count));\r\ndevcd->devcd_dev.class = &devcd_class;\r\nif (device_add(&devcd->devcd_dev))\r\ngoto put_device;\r\nif (sysfs_create_link(&devcd->devcd_dev.kobj, &dev->kobj,\r\n"failing_device"))\r\n;\r\nif (sysfs_create_link(&dev->kobj, &devcd->devcd_dev.kobj,\r\n"devcoredump"))\r\n;\r\nINIT_DELAYED_WORK(&devcd->del_wk, devcd_del);\r\nschedule_delayed_work(&devcd->del_wk, DEVCD_TIMEOUT);\r\nreturn;\r\nput_device:\r\nput_device(&devcd->devcd_dev);\r\nput_module:\r\nmodule_put(owner);\r\nfree:\r\nfree(data);\r\n}\r\nvoid dev_coredumpsg(struct device *dev, struct scatterlist *table,\r\nsize_t datalen, gfp_t gfp)\r\n{\r\ndev_coredumpm(dev, NULL, table, datalen, gfp, devcd_read_from_sgtable,\r\ndevcd_free_sgtable);\r\n}\r\nstatic int __init devcoredump_init(void)\r\n{\r\nreturn class_register(&devcd_class);\r\n}\r\nstatic void __exit devcoredump_exit(void)\r\n{\r\nclass_for_each_device(&devcd_class, NULL, NULL, devcd_free);\r\nclass_unregister(&devcd_class);\r\n}
