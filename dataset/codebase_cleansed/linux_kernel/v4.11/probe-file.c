static void print_open_warning(int err, bool uprobe)\r\n{\r\nchar sbuf[STRERR_BUFSIZE];\r\nif (err == -ENOENT) {\r\nconst char *config;\r\nif (uprobe)\r\nconfig = "CONFIG_UPROBE_EVENTS";\r\nelse\r\nconfig = "CONFIG_KPROBE_EVENTS";\r\npr_warning("%cprobe_events file does not exist"\r\n" - please rebuild kernel with %s.\n",\r\nuprobe ? 'u' : 'k', config);\r\n} else if (err == -ENOTSUP)\r\npr_warning("Tracefs or debugfs is not mounted.\n");\r\nelse\r\npr_warning("Failed to open %cprobe_events: %s\n",\r\nuprobe ? 'u' : 'k',\r\nstr_error_r(-err, sbuf, sizeof(sbuf)));\r\n}\r\nstatic void print_both_open_warning(int kerr, int uerr)\r\n{\r\nif (kerr == -ENOTSUP && uerr == -ENOTSUP)\r\npr_warning("Tracefs or debugfs is not mounted.\n");\r\nelse if (kerr == -ENOENT && uerr == -ENOENT)\r\npr_warning("Please rebuild kernel with CONFIG_KPROBE_EVENTS "\r\n"or/and CONFIG_UPROBE_EVENTS.\n");\r\nelse {\r\nchar sbuf[STRERR_BUFSIZE];\r\npr_warning("Failed to open kprobe events: %s.\n",\r\nstr_error_r(-kerr, sbuf, sizeof(sbuf)));\r\npr_warning("Failed to open uprobe events: %s.\n",\r\nstr_error_r(-uerr, sbuf, sizeof(sbuf)));\r\n}\r\n}\r\nstatic int open_probe_events(const char *trace_file, bool readwrite)\r\n{\r\nchar buf[PATH_MAX];\r\nint ret;\r\nret = e_snprintf(buf, PATH_MAX, "%s/%s",\r\ntracing_path, trace_file);\r\nif (ret >= 0) {\r\npr_debug("Opening %s write=%d\n", buf, readwrite);\r\nif (readwrite && !probe_event_dry_run)\r\nret = open(buf, O_RDWR | O_APPEND, 0);\r\nelse\r\nret = open(buf, O_RDONLY, 0);\r\nif (ret < 0)\r\nret = -errno;\r\n}\r\nreturn ret;\r\n}\r\nstatic int open_kprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("kprobe_events", readwrite);\r\n}\r\nstatic int open_uprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("uprobe_events", readwrite);\r\n}\r\nint probe_file__open(int flag)\r\n{\r\nint fd;\r\nif (flag & PF_FL_UPROBE)\r\nfd = open_uprobe_events(flag & PF_FL_RW);\r\nelse\r\nfd = open_kprobe_events(flag & PF_FL_RW);\r\nif (fd < 0)\r\nprint_open_warning(fd, flag & PF_FL_UPROBE);\r\nreturn fd;\r\n}\r\nint probe_file__open_both(int *kfd, int *ufd, int flag)\r\n{\r\nif (!kfd || !ufd)\r\nreturn -EINVAL;\r\n*kfd = open_kprobe_events(flag & PF_FL_RW);\r\n*ufd = open_uprobe_events(flag & PF_FL_RW);\r\nif (*kfd < 0 && *ufd < 0) {\r\nprint_both_open_warning(*kfd, *ufd);\r\nreturn *kfd;\r\n}\r\nreturn 0;\r\n}\r\nstruct strlist *probe_file__get_rawlist(int fd)\r\n{\r\nint ret, idx, fddup;\r\nFILE *fp;\r\nchar buf[MAX_CMDLEN];\r\nchar *p;\r\nstruct strlist *sl;\r\nif (fd < 0)\r\nreturn NULL;\r\nsl = strlist__new(NULL, NULL);\r\nif (sl == NULL)\r\nreturn NULL;\r\nfddup = dup(fd);\r\nif (fddup < 0)\r\ngoto out_free_sl;\r\nfp = fdopen(fddup, "r");\r\nif (!fp)\r\ngoto out_close_fddup;\r\nwhile (!feof(fp)) {\r\np = fgets(buf, MAX_CMDLEN, fp);\r\nif (!p)\r\nbreak;\r\nidx = strlen(p) - 1;\r\nif (p[idx] == '\n')\r\np[idx] = '\0';\r\nret = strlist__add(sl, buf);\r\nif (ret < 0) {\r\npr_debug("strlist__add failed (%d)\n", ret);\r\ngoto out_close_fp;\r\n}\r\n}\r\nfclose(fp);\r\nreturn sl;\r\nout_close_fp:\r\nfclose(fp);\r\ngoto out_free_sl;\r\nout_close_fddup:\r\nclose(fddup);\r\nout_free_sl:\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\nstatic struct strlist *__probe_file__get_namelist(int fd, bool include_group)\r\n{\r\nchar buf[128];\r\nstruct strlist *sl, *rawlist;\r\nstruct str_node *ent;\r\nstruct probe_trace_event tev;\r\nint ret = 0;\r\nmemset(&tev, 0, sizeof(tev));\r\nrawlist = probe_file__get_rawlist(fd);\r\nif (!rawlist)\r\nreturn NULL;\r\nsl = strlist__new(NULL, NULL);\r\nstrlist__for_each_entry(ent, rawlist) {\r\nret = parse_probe_trace_command(ent->s, &tev);\r\nif (ret < 0)\r\nbreak;\r\nif (include_group) {\r\nret = e_snprintf(buf, 128, "%s:%s", tev.group,\r\ntev.event);\r\nif (ret >= 0)\r\nret = strlist__add(sl, buf);\r\n} else\r\nret = strlist__add(sl, tev.event);\r\nclear_probe_trace_event(&tev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nstrlist__delete(rawlist);\r\nif (ret < 0) {\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\nreturn sl;\r\n}\r\nstruct strlist *probe_file__get_namelist(int fd)\r\n{\r\nreturn __probe_file__get_namelist(fd, false);\r\n}\r\nint probe_file__add_event(int fd, struct probe_trace_event *tev)\r\n{\r\nint ret = 0;\r\nchar *buf = synthesize_probe_trace_command(tev);\r\nchar sbuf[STRERR_BUFSIZE];\r\nif (!buf) {\r\npr_debug("Failed to synthesize probe trace event.\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("Writing event: %s\n", buf);\r\nif (!probe_event_dry_run) {\r\nif (write(fd, buf, strlen(buf)) < (int)strlen(buf)) {\r\nret = -errno;\r\npr_warning("Failed to write event: %s\n",\r\nstr_error_r(errno, sbuf, sizeof(sbuf)));\r\n}\r\n}\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic int __del_trace_probe_event(int fd, struct str_node *ent)\r\n{\r\nchar *p;\r\nchar buf[128];\r\nint ret;\r\nret = e_snprintf(buf, 128, "-:%s", ent->s);\r\nif (ret < 0)\r\ngoto error;\r\np = strchr(buf + 2, ':');\r\nif (!p) {\r\npr_debug("Internal error: %s should have ':' but not.\n",\r\nent->s);\r\nret = -ENOTSUP;\r\ngoto error;\r\n}\r\n*p = '/';\r\npr_debug("Writing event: %s\n", buf);\r\nret = write(fd, buf, strlen(buf));\r\nif (ret < 0) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\npr_warning("Failed to delete event: %s\n",\r\nstr_error_r(-ret, buf, sizeof(buf)));\r\nreturn ret;\r\n}\r\nint probe_file__get_events(int fd, struct strfilter *filter,\r\nstruct strlist *plist)\r\n{\r\nstruct strlist *namelist;\r\nstruct str_node *ent;\r\nconst char *p;\r\nint ret = -ENOENT;\r\nif (!plist)\r\nreturn -EINVAL;\r\nnamelist = __probe_file__get_namelist(fd, true);\r\nif (!namelist)\r\nreturn -ENOENT;\r\nstrlist__for_each_entry(ent, namelist) {\r\np = strchr(ent->s, ':');\r\nif ((p && strfilter__compare(filter, p + 1)) ||\r\nstrfilter__compare(filter, ent->s)) {\r\nstrlist__add(plist, ent->s);\r\nret = 0;\r\n}\r\n}\r\nstrlist__delete(namelist);\r\nreturn ret;\r\n}\r\nint probe_file__del_strlist(int fd, struct strlist *namelist)\r\n{\r\nint ret = 0;\r\nstruct str_node *ent;\r\nstrlist__for_each_entry(ent, namelist) {\r\nret = __del_trace_probe_event(fd, ent);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint probe_file__del_events(int fd, struct strfilter *filter)\r\n{\r\nstruct strlist *namelist;\r\nint ret;\r\nnamelist = strlist__new(NULL, NULL);\r\nif (!namelist)\r\nreturn -ENOMEM;\r\nret = probe_file__get_events(fd, filter, namelist);\r\nif (ret < 0)\r\nreturn ret;\r\nret = probe_file__del_strlist(fd, namelist);\r\nstrlist__delete(namelist);\r\nreturn ret;\r\n}\r\nstatic void probe_cache_entry__delete(struct probe_cache_entry *entry)\r\n{\r\nif (entry) {\r\nBUG_ON(!list_empty(&entry->node));\r\nstrlist__delete(entry->tevlist);\r\nclear_perf_probe_event(&entry->pev);\r\nzfree(&entry->spev);\r\nfree(entry);\r\n}\r\n}\r\nstatic struct probe_cache_entry *\r\nprobe_cache_entry__new(struct perf_probe_event *pev)\r\n{\r\nstruct probe_cache_entry *entry = zalloc(sizeof(*entry));\r\nif (entry) {\r\nINIT_LIST_HEAD(&entry->node);\r\nentry->tevlist = strlist__new(NULL, NULL);\r\nif (!entry->tevlist)\r\nzfree(&entry);\r\nelse if (pev) {\r\nentry->spev = synthesize_perf_probe_command(pev);\r\nif (!entry->spev ||\r\nperf_probe_event__copy(&entry->pev, pev) < 0) {\r\nprobe_cache_entry__delete(entry);\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nreturn entry;\r\n}\r\nint probe_cache_entry__get_event(struct probe_cache_entry *entry,\r\nstruct probe_trace_event **tevs)\r\n{\r\nstruct probe_trace_event *tev;\r\nstruct str_node *node;\r\nint ret, i;\r\nret = strlist__nr_entries(entry->tevlist);\r\nif (ret > probe_conf.max_probes)\r\nreturn -E2BIG;\r\n*tevs = zalloc(ret * sizeof(*tev));\r\nif (!*tevs)\r\nreturn -ENOMEM;\r\ni = 0;\r\nstrlist__for_each_entry(node, entry->tevlist) {\r\ntev = &(*tevs)[i++];\r\nret = parse_probe_trace_command(node->s, tev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int probe_cache__open(struct probe_cache *pcache, const char *target)\r\n{\r\nchar cpath[PATH_MAX];\r\nchar sbuildid[SBUILD_ID_SIZE];\r\nchar *dir_name = NULL;\r\nbool is_kallsyms = false;\r\nint ret, fd;\r\nif (target && build_id_cache__cached(target)) {\r\nstrncpy(sbuildid, target, SBUILD_ID_SIZE);\r\ndir_name = build_id_cache__linkname(sbuildid, NULL, 0);\r\ngoto found;\r\n}\r\nif (!target || !strcmp(target, DSO__NAME_KALLSYMS)) {\r\ntarget = DSO__NAME_KALLSYMS;\r\nis_kallsyms = true;\r\nret = sysfs__sprintf_build_id("/", sbuildid);\r\n} else\r\nret = filename__sprintf_build_id(target, sbuildid);\r\nif (ret < 0) {\r\npr_debug("Failed to get build-id from %s.\n", target);\r\nreturn ret;\r\n}\r\nif (!build_id_cache__cached(sbuildid)) {\r\nret = build_id_cache__add_s(sbuildid, target,\r\nis_kallsyms, NULL);\r\nif (ret < 0) {\r\npr_debug("Failed to add build-id cache: %s\n", target);\r\nreturn ret;\r\n}\r\n}\r\ndir_name = build_id_cache__cachedir(sbuildid, target, is_kallsyms,\r\nfalse);\r\nfound:\r\nif (!dir_name) {\r\npr_debug("Failed to get cache from %s\n", target);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(cpath, PATH_MAX, "%s/probes", dir_name);\r\nfd = open(cpath, O_CREAT | O_RDWR, 0644);\r\nif (fd < 0)\r\npr_debug("Failed to open cache(%d): %s\n", fd, cpath);\r\nfree(dir_name);\r\npcache->fd = fd;\r\nreturn fd;\r\n}\r\nstatic int probe_cache__load(struct probe_cache *pcache)\r\n{\r\nstruct probe_cache_entry *entry = NULL;\r\nchar buf[MAX_CMDLEN], *p;\r\nint ret = 0, fddup;\r\nFILE *fp;\r\nfddup = dup(pcache->fd);\r\nif (fddup < 0)\r\nreturn -errno;\r\nfp = fdopen(fddup, "r");\r\nif (!fp) {\r\nclose(fddup);\r\nreturn -EINVAL;\r\n}\r\nwhile (!feof(fp)) {\r\nif (!fgets(buf, MAX_CMDLEN, fp))\r\nbreak;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\nif (buf[0] == '#' || buf[0] == '%') {\r\nentry = probe_cache_entry__new(NULL);\r\nif (!entry) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (buf[0] == '%')\r\nentry->sdt = true;\r\nentry->spev = strdup(buf + 1);\r\nif (entry->spev)\r\nret = parse_perf_probe_command(buf + 1,\r\n&entry->pev);\r\nelse\r\nret = -ENOMEM;\r\nif (ret < 0) {\r\nprobe_cache_entry__delete(entry);\r\ngoto out;\r\n}\r\nlist_add_tail(&entry->node, &pcache->entries);\r\n} else {\r\nif (!entry) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstrlist__add(entry->tevlist, buf);\r\n}\r\n}\r\nout:\r\nfclose(fp);\r\nreturn ret;\r\n}\r\nstatic struct probe_cache *probe_cache__alloc(void)\r\n{\r\nstruct probe_cache *pcache = zalloc(sizeof(*pcache));\r\nif (pcache) {\r\nINIT_LIST_HEAD(&pcache->entries);\r\npcache->fd = -EINVAL;\r\n}\r\nreturn pcache;\r\n}\r\nvoid probe_cache__purge(struct probe_cache *pcache)\r\n{\r\nstruct probe_cache_entry *entry, *n;\r\nlist_for_each_entry_safe(entry, n, &pcache->entries, node) {\r\nlist_del_init(&entry->node);\r\nprobe_cache_entry__delete(entry);\r\n}\r\n}\r\nvoid probe_cache__delete(struct probe_cache *pcache)\r\n{\r\nif (!pcache)\r\nreturn;\r\nprobe_cache__purge(pcache);\r\nif (pcache->fd > 0)\r\nclose(pcache->fd);\r\nfree(pcache);\r\n}\r\nstruct probe_cache *probe_cache__new(const char *target)\r\n{\r\nstruct probe_cache *pcache = probe_cache__alloc();\r\nint ret;\r\nif (!pcache)\r\nreturn NULL;\r\nret = probe_cache__open(pcache, target);\r\nif (ret < 0) {\r\npr_debug("Cache open error: %d\n", ret);\r\ngoto out_err;\r\n}\r\nret = probe_cache__load(pcache);\r\nif (ret < 0) {\r\npr_debug("Cache read error: %d\n", ret);\r\ngoto out_err;\r\n}\r\nreturn pcache;\r\nout_err:\r\nprobe_cache__delete(pcache);\r\nreturn NULL;\r\n}\r\nstatic bool streql(const char *a, const char *b)\r\n{\r\nif (a == b)\r\nreturn true;\r\nif (!a || !b)\r\nreturn false;\r\nreturn !strcmp(a, b);\r\n}\r\nstruct probe_cache_entry *\r\nprobe_cache__find(struct probe_cache *pcache, struct perf_probe_event *pev)\r\n{\r\nstruct probe_cache_entry *entry = NULL;\r\nchar *cmd = synthesize_perf_probe_command(pev);\r\nif (!cmd)\r\nreturn NULL;\r\nfor_each_probe_cache_entry(entry, pcache) {\r\nif (pev->sdt) {\r\nif (entry->pev.event &&\r\nstreql(entry->pev.event, pev->event) &&\r\n(!pev->group ||\r\nstreql(entry->pev.group, pev->group)))\r\ngoto found;\r\ncontinue;\r\n}\r\nif ((pev->event &&\r\n(streql(entry->pev.group, pev->group) &&\r\nstreql(entry->pev.event, pev->event))) ||\r\n(!strcmp(entry->spev, cmd)))\r\ngoto found;\r\n}\r\nentry = NULL;\r\nfound:\r\nfree(cmd);\r\nreturn entry;\r\n}\r\nstruct probe_cache_entry *\r\nprobe_cache__find_by_name(struct probe_cache *pcache,\r\nconst char *group, const char *event)\r\n{\r\nstruct probe_cache_entry *entry = NULL;\r\nfor_each_probe_cache_entry(entry, pcache) {\r\nif (streql(entry->pev.group, group) &&\r\nstreql(entry->pev.event, event))\r\ngoto found;\r\n}\r\nentry = NULL;\r\nfound:\r\nreturn entry;\r\n}\r\nint probe_cache__add_entry(struct probe_cache *pcache,\r\nstruct perf_probe_event *pev,\r\nstruct probe_trace_event *tevs, int ntevs)\r\n{\r\nstruct probe_cache_entry *entry = NULL;\r\nchar *command;\r\nint i, ret = 0;\r\nif (!pcache || !pev || !tevs || ntevs <= 0) {\r\nret = -EINVAL;\r\ngoto out_err;\r\n}\r\nentry = probe_cache__find(pcache, pev);\r\nif (entry) {\r\nlist_del_init(&entry->node);\r\nprobe_cache_entry__delete(entry);\r\n}\r\nret = -ENOMEM;\r\nentry = probe_cache_entry__new(pev);\r\nif (!entry)\r\ngoto out_err;\r\nfor (i = 0; i < ntevs; i++) {\r\nif (!tevs[i].point.symbol)\r\ncontinue;\r\ncommand = synthesize_probe_trace_command(&tevs[i]);\r\nif (!command)\r\ngoto out_err;\r\nstrlist__add(entry->tevlist, command);\r\nfree(command);\r\n}\r\nlist_add_tail(&entry->node, &pcache->entries);\r\npr_debug("Added probe cache: %d\n", ntevs);\r\nreturn 0;\r\nout_err:\r\npr_debug("Failed to add probe caches\n");\r\nprobe_cache_entry__delete(entry);\r\nreturn ret;\r\n}\r\nstatic unsigned long long sdt_note__get_addr(struct sdt_note *note)\r\n{\r\nreturn note->bit32 ? (unsigned long long)note->addr.a32[0]\r\n: (unsigned long long)note->addr.a64[0];\r\n}\r\nint probe_cache__scan_sdt(struct probe_cache *pcache, const char *pathname)\r\n{\r\nstruct probe_cache_entry *entry = NULL;\r\nstruct list_head sdtlist;\r\nstruct sdt_note *note;\r\nchar *buf;\r\nchar sdtgrp[64];\r\nint ret;\r\nINIT_LIST_HEAD(&sdtlist);\r\nret = get_sdt_note_list(&sdtlist, pathname);\r\nif (ret < 0) {\r\npr_debug4("Failed to get sdt note: %d\n", ret);\r\nreturn ret;\r\n}\r\nlist_for_each_entry(note, &sdtlist, note_list) {\r\nret = snprintf(sdtgrp, 64, "sdt_%s", note->provider);\r\nif (ret < 0)\r\nbreak;\r\nentry = probe_cache__find_by_name(pcache, sdtgrp, note->name);\r\nif (!entry) {\r\nentry = probe_cache_entry__new(NULL);\r\nif (!entry) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nentry->sdt = true;\r\nret = asprintf(&entry->spev, "%s:%s=%s", sdtgrp,\r\nnote->name, note->name);\r\nif (ret < 0)\r\nbreak;\r\nentry->pev.event = strdup(note->name);\r\nentry->pev.group = strdup(sdtgrp);\r\nlist_add_tail(&entry->node, &pcache->entries);\r\n}\r\nret = asprintf(&buf, "p:%s/%s %s:0x%llx",\r\nsdtgrp, note->name, pathname,\r\nsdt_note__get_addr(note));\r\nif (ret < 0)\r\nbreak;\r\nstrlist__add(entry->tevlist, buf);\r\nfree(buf);\r\nentry = NULL;\r\n}\r\nif (entry) {\r\nlist_del_init(&entry->node);\r\nprobe_cache_entry__delete(entry);\r\n}\r\ncleanup_sdt_note_list(&sdtlist);\r\nreturn ret;\r\n}\r\nstatic int probe_cache_entry__write(struct probe_cache_entry *entry, int fd)\r\n{\r\nstruct str_node *snode;\r\nstruct stat st;\r\nstruct iovec iov[3];\r\nconst char *prefix = entry->sdt ? "%" : "#";\r\nint ret;\r\nret = fstat(fd, &st);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("Writing cache: %s%s\n", prefix, entry->spev);\r\niov[0].iov_base = (void *)prefix; iov[0].iov_len = 1;\r\niov[1].iov_base = entry->spev; iov[1].iov_len = strlen(entry->spev);\r\niov[2].iov_base = (void *)"\n"; iov[2].iov_len = 1;\r\nret = writev(fd, iov, 3);\r\nif (ret < (int)iov[1].iov_len + 2)\r\ngoto rollback;\r\nstrlist__for_each_entry(snode, entry->tevlist) {\r\niov[0].iov_base = (void *)snode->s;\r\niov[0].iov_len = strlen(snode->s);\r\niov[1].iov_base = (void *)"\n"; iov[1].iov_len = 1;\r\nret = writev(fd, iov, 2);\r\nif (ret < (int)iov[0].iov_len + 1)\r\ngoto rollback;\r\n}\r\nreturn 0;\r\nrollback:\r\nif (ret > 0)\r\nret = -1;\r\nif (ftruncate(fd, st.st_size) < 0)\r\nret = -2;\r\nreturn ret;\r\n}\r\nint probe_cache__commit(struct probe_cache *pcache)\r\n{\r\nstruct probe_cache_entry *entry;\r\nint ret = 0;\r\nret = lseek(pcache->fd, 0, SEEK_SET);\r\nif (ret < 0)\r\ngoto out;\r\nret = ftruncate(pcache->fd, 0);\r\nif (ret < 0)\r\ngoto out;\r\nfor_each_probe_cache_entry(entry, pcache) {\r\nret = probe_cache_entry__write(entry, pcache->fd);\r\npr_debug("Cache committed: %d\n", ret);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic bool probe_cache_entry__compare(struct probe_cache_entry *entry,\r\nstruct strfilter *filter)\r\n{\r\nchar buf[128], *ptr = entry->spev;\r\nif (entry->pev.event) {\r\nsnprintf(buf, 128, "%s:%s", entry->pev.group, entry->pev.event);\r\nptr = buf;\r\n}\r\nreturn strfilter__compare(filter, ptr);\r\n}\r\nint probe_cache__filter_purge(struct probe_cache *pcache,\r\nstruct strfilter *filter)\r\n{\r\nstruct probe_cache_entry *entry, *tmp;\r\nlist_for_each_entry_safe(entry, tmp, &pcache->entries, node) {\r\nif (probe_cache_entry__compare(entry, filter)) {\r\npr_info("Removed cached event: %s\n", entry->spev);\r\nlist_del_init(&entry->node);\r\nprobe_cache_entry__delete(entry);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int probe_cache__show_entries(struct probe_cache *pcache,\r\nstruct strfilter *filter)\r\n{\r\nstruct probe_cache_entry *entry;\r\nfor_each_probe_cache_entry(entry, pcache) {\r\nif (probe_cache_entry__compare(entry, filter))\r\nprintf("%s\n", entry->spev);\r\n}\r\nreturn 0;\r\n}\r\nint probe_cache__show_all_caches(struct strfilter *filter)\r\n{\r\nstruct probe_cache *pcache;\r\nstruct strlist *bidlist;\r\nstruct str_node *nd;\r\nchar *buf = strfilter__string(filter);\r\npr_debug("list cache with filter: %s\n", buf);\r\nfree(buf);\r\nbidlist = build_id_cache__list_all(true);\r\nif (!bidlist) {\r\npr_debug("Failed to get buildids: %d\n", errno);\r\nreturn -EINVAL;\r\n}\r\nstrlist__for_each_entry(nd, bidlist) {\r\npcache = probe_cache__new(nd->s);\r\nif (!pcache)\r\ncontinue;\r\nif (!list_empty(&pcache->entries)) {\r\nbuf = build_id_cache__origname(nd->s);\r\nprintf("%s (%s):\n", buf, nd->s);\r\nfree(buf);\r\nprobe_cache__show_entries(pcache, filter);\r\n}\r\nprobe_cache__delete(pcache);\r\n}\r\nstrlist__delete(bidlist);\r\nreturn 0;\r\n}\r\nbool probe_type_is_available(enum probe_type type)\r\n{\r\nFILE *fp;\r\nchar *buf = NULL;\r\nsize_t len = 0;\r\nbool target_line = false;\r\nbool ret = probe_type_table[type].avail;\r\nif (type >= PROBE_TYPE_END)\r\nreturn false;\r\nif (ret || probe_type_table[type].checked)\r\nreturn ret;\r\nif (asprintf(&buf, "%s/README", tracing_path) < 0)\r\nreturn ret;\r\nfp = fopen(buf, "r");\r\nif (!fp)\r\ngoto end;\r\nzfree(&buf);\r\nwhile (getline(&buf, &len, fp) > 0 && !ret) {\r\nif (!target_line) {\r\ntarget_line = !!strstr(buf, " type: ");\r\nif (!target_line)\r\ncontinue;\r\n} else if (strstr(buf, "\t ") != buf)\r\nbreak;\r\nret = strglobmatch(buf, probe_type_table[type].pattern);\r\n}\r\nprobe_type_table[type].checked = true;\r\nprobe_type_table[type].avail = ret;\r\nfclose(fp);\r\nend:\r\nfree(buf);\r\nreturn ret;\r\n}
