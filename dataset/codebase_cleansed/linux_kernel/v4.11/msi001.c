static inline struct msi001_dev *sd_to_msi001_dev(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct msi001_dev, sd);\r\n}\r\nstatic int msi001_wreg(struct msi001_dev *dev, u32 data)\r\n{\r\nreturn spi_write(dev->spi, &data, 3);\r\n}\r\nstatic int msi001_set_gain(struct msi001_dev *dev, int lna_gain, int mixer_gain,\r\nint if_gain)\r\n{\r\nstruct spi_device *spi = dev->spi;\r\nint ret;\r\nu32 reg;\r\ndev_dbg(&spi->dev, "lna=%d mixer=%d if=%d\n",\r\nlna_gain, mixer_gain, if_gain);\r\nreg = 1 << 0;\r\nreg |= (59 - if_gain) << 4;\r\nreg |= 0 << 10;\r\nreg |= (1 - mixer_gain) << 12;\r\nreg |= (1 - lna_gain) << 13;\r\nreg |= 4 << 14;\r\nreg |= 0 << 17;\r\nret = msi001_wreg(dev, reg);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&spi->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int msi001_set_tuner(struct msi001_dev *dev)\r\n{\r\nstruct spi_device *spi = dev->spi;\r\nint ret, i;\r\nunsigned int uitmp, div_n, k, k_thresh, k_frac, div_lo, f_if1;\r\nu32 reg;\r\nu64 f_vco;\r\nu8 mode, filter_mode;\r\nstatic const struct {\r\nu32 rf;\r\nu8 mode;\r\nu8 div_lo;\r\n} band_lut[] = {\r\n{ 50000000, 0xe1, 16},\r\n{108000000, 0x42, 32},\r\n{330000000, 0x44, 16},\r\n{960000000, 0x48, 4},\r\n{ ~0U, 0x50, 2},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 filter_mode;\r\n} if_freq_lut[] = {\r\n{ 0, 0x03},\r\n{ 450000, 0x02},\r\n{1620000, 0x01},\r\n{2048000, 0x00},\r\n};\r\nstatic const struct {\r\nu32 freq;\r\nu8 val;\r\n} bandwidth_lut[] = {\r\n{ 200000, 0x00},\r\n{ 300000, 0x01},\r\n{ 600000, 0x02},\r\n{1536000, 0x03},\r\n{5000000, 0x04},\r\n{6000000, 0x05},\r\n{7000000, 0x06},\r\n{8000000, 0x07},\r\n};\r\nunsigned int f_rf = dev->f_tuner;\r\nunsigned int bandwidth;\r\nunsigned int f_if = 0;\r\n#define F_REF 24000000\r\n#define DIV_PRE_N 4\r\n#define F_VCO_STEP div_lo\r\ndev_dbg(&spi->dev, "f_rf=%d f_if=%d\n", f_rf, f_if);\r\nfor (i = 0; i < ARRAY_SIZE(band_lut); i++) {\r\nif (f_rf <= band_lut[i].rf) {\r\nmode = band_lut[i].mode;\r\ndiv_lo = band_lut[i].div_lo;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(band_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif ((mode >> 0) & 0x1)\r\nf_if1 = 5 * F_REF;\r\nelse\r\nf_if1 = 0;\r\nfor (i = 0; i < ARRAY_SIZE(if_freq_lut); i++) {\r\nif (f_if == if_freq_lut[i].freq) {\r\nfilter_mode = if_freq_lut[i].filter_mode;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(if_freq_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbandwidth = dev->bandwidth->val;\r\nbandwidth = clamp(bandwidth, 200000U, 8000000U);\r\nfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\r\nif (bandwidth <= bandwidth_lut[i].freq) {\r\nbandwidth = bandwidth_lut[i].val;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(bandwidth_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev->bandwidth->val = bandwidth_lut[i].freq;\r\ndev_dbg(&spi->dev, "bandwidth selected=%d\n", bandwidth_lut[i].freq);\r\nf_vco = (u64) (f_rf + f_if + f_if1) * div_lo;\r\ndiv_n = div_u64_rem(f_vco, DIV_PRE_N * F_REF, &k);\r\nk_thresh = (DIV_PRE_N * F_REF) / F_VCO_STEP;\r\nk_frac = div_u64((u64) k * k_thresh, (DIV_PRE_N * F_REF));\r\nuitmp = gcd(k_thresh, k_frac);\r\nk_thresh /= uitmp;\r\nk_frac /= uitmp;\r\nuitmp = DIV_ROUND_UP(k_thresh, 4095);\r\nk_thresh = DIV_ROUND_CLOSEST(k_thresh, uitmp);\r\nk_frac = DIV_ROUND_CLOSEST(k_frac, uitmp);\r\nuitmp = (unsigned int) F_REF * DIV_PRE_N * div_n;\r\nuitmp += (unsigned int) F_REF * DIV_PRE_N * k_frac / k_thresh;\r\nuitmp /= div_lo;\r\ndev_dbg(&spi->dev,\r\n"f_rf=%u:%u f_vco=%llu div_n=%u k_thresh=%u k_frac=%u div_lo=%u\n",\r\nf_rf, uitmp, f_vco, div_n, k_thresh, k_frac, div_lo);\r\nret = msi001_wreg(dev, 0x00000e);\r\nif (ret)\r\ngoto err;\r\nret = msi001_wreg(dev, 0x000003);\r\nif (ret)\r\ngoto err;\r\nreg = 0 << 0;\r\nreg |= mode << 4;\r\nreg |= filter_mode << 12;\r\nreg |= bandwidth << 14;\r\nreg |= 0x02 << 17;\r\nreg |= 0x00 << 20;\r\nret = msi001_wreg(dev, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 5 << 0;\r\nreg |= k_thresh << 4;\r\nreg |= 1 << 19;\r\nreg |= 1 << 21;\r\nret = msi001_wreg(dev, reg);\r\nif (ret)\r\ngoto err;\r\nreg = 2 << 0;\r\nreg |= k_frac << 4;\r\nreg |= div_n << 16;\r\nret = msi001_wreg(dev, reg);\r\nif (ret)\r\ngoto err;\r\nret = msi001_set_gain(dev, dev->lna_gain->cur.val,\r\ndev->mixer_gain->cur.val, dev->if_gain->cur.val);\r\nif (ret)\r\ngoto err;\r\nreg = 6 << 0;\r\nreg |= 63 << 4;\r\nreg |= 4095 << 10;\r\nret = msi001_wreg(dev, reg);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&spi->dev, "failed %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int msi001_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\nint ret;\r\ndev_dbg(&spi->dev, "on=%d\n", on);\r\nif (on)\r\nret = 0;\r\nelse\r\nret = msi001_wreg(dev, 0x000000);\r\nreturn ret;\r\n}\r\nstatic int msi001_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\ndev_dbg(&spi->dev, "index=%d\n", v->index);\r\nstrlcpy(v->name, "Mirics MSi001", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = 49000000;\r\nv->rangehigh = 960000000;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\ndev_dbg(&spi->dev, "index=%d\n", v->index);\r\nreturn 0;\r\n}\r\nstatic int msi001_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\ndev_dbg(&spi->dev, "tuner=%d\n", f->tuner);\r\nf->frequency = dev->f_tuner;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_frequency(struct v4l2_subdev *sd,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\nunsigned int band;\r\ndev_dbg(&spi->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\nif (f->frequency < ((bands[0].rangehigh + bands[1].rangelow) / 2))\r\nband = 0;\r\nelse\r\nband = 1;\r\ndev->f_tuner = clamp_t(unsigned int, f->frequency,\r\nbands[band].rangelow, bands[band].rangehigh);\r\nreturn msi001_set_tuner(dev);\r\n}\r\nstatic int msi001_enum_freq_bands(struct v4l2_subdev *sd,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\nstruct spi_device *spi = dev->spi;\r\ndev_dbg(&spi->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->index >= ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\nband->capability = bands[band->index].capability;\r\nband->rangelow = bands[band->index].rangelow;\r\nband->rangehigh = bands[band->index].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int msi001_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct msi001_dev *dev = container_of(ctrl->handler, struct msi001_dev, hdl);\r\nstruct spi_device *spi = dev->spi;\r\nint ret;\r\ndev_dbg(&spi->dev, "id=%d name=%s val=%d min=%lld max=%lld step=%lld\n",\r\nctrl->id, ctrl->name, ctrl->val, ctrl->minimum, ctrl->maximum,\r\nctrl->step);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nret = msi001_set_tuner(dev);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nret = msi001_set_gain(dev, dev->lna_gain->val,\r\ndev->mixer_gain->cur.val,\r\ndev->if_gain->cur.val);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\nret = msi001_set_gain(dev, dev->lna_gain->cur.val,\r\ndev->mixer_gain->val,\r\ndev->if_gain->cur.val);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nret = msi001_set_gain(dev, dev->lna_gain->cur.val,\r\ndev->mixer_gain->cur.val,\r\ndev->if_gain->val);\r\nbreak;\r\ndefault:\r\ndev_dbg(&spi->dev, "unknown control %d\n", ctrl->id);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int msi001_probe(struct spi_device *spi)\r\n{\r\nstruct msi001_dev *dev;\r\nint ret;\r\ndev_dbg(&spi->dev, "\n");\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->spi = spi;\r\ndev->f_tuner = bands[0].rangelow;\r\nv4l2_spi_subdev_init(&dev->sd, spi, &msi001_ops);\r\nv4l2_ctrl_handler_init(&dev->hdl, 5);\r\ndev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\r\ndev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH, 200000, 8000000, 1, 200000);\r\nv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\r\ndev->lna_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN, 0, 1, 1, 1);\r\ndev->mixer_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\r\ndev->if_gain = v4l2_ctrl_new_std(&dev->hdl, &msi001_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN, 0, 59, 1, 0);\r\nif (dev->hdl.error) {\r\nret = dev->hdl.error;\r\ndev_err(&spi->dev, "Could not initialize controls\n");\r\ngoto err_ctrl_handler_free;\r\n}\r\ndev->sd.ctrl_handler = &dev->hdl;\r\nreturn 0;\r\nerr_ctrl_handler_free:\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nkfree(dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int msi001_remove(struct spi_device *spi)\r\n{\r\nstruct v4l2_subdev *sd = spi_get_drvdata(spi);\r\nstruct msi001_dev *dev = sd_to_msi001_dev(sd);\r\ndev_dbg(&spi->dev, "\n");\r\nv4l2_device_unregister_subdev(&dev->sd);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nkfree(dev);\r\nreturn 0;\r\n}
