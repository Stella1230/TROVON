static inline void __iomem *brcm_sata_pcb_base(struct brcm_sata_port *port)\r\n{\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nu32 size = 0;\r\nswitch (priv->version) {\r\ncase BRCM_SATA_PHY_STB_28NM:\r\ncase BRCM_SATA_PHY_IPROC_NS2:\r\nsize = SATA_PCB_REG_28NM_SPACE_SIZE;\r\nbreak;\r\ncase BRCM_SATA_PHY_STB_40NM:\r\nsize = SATA_PCB_REG_40NM_SPACE_SIZE;\r\nbreak;\r\ndefault:\r\ndev_err(priv->dev, "invalid phy version\n");\r\nbreak;\r\n}\r\nreturn priv->phy_base + (port->portnum * size);\r\n}\r\nstatic inline void __iomem *brcm_sata_ctrl_base(struct brcm_sata_port *port)\r\n{\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nu32 size = 0;\r\nswitch (priv->version) {\r\ncase BRCM_SATA_PHY_IPROC_NS2:\r\nsize = SATA_PHY_CTRL_REG_28NM_SPACE_SIZE;\r\nbreak;\r\ndefault:\r\ndev_err(priv->dev, "invalid phy version\n");\r\nbreak;\r\n}\r\nreturn priv->ctrl_base + (port->portnum * size);\r\n}\r\nstatic void brcm_sata_phy_wr(void __iomem *pcb_base, u32 bank,\r\nu32 ofs, u32 msk, u32 value)\r\n{\r\nu32 tmp;\r\nwritel(bank, pcb_base + SATA_PCB_BANK_OFFSET);\r\ntmp = readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));\r\ntmp = (tmp & msk) | value;\r\nwritel(tmp, pcb_base + SATA_PCB_REG_OFFSET(ofs));\r\n}\r\nstatic u32 brcm_sata_phy_rd(void __iomem *pcb_base, u32 bank, u32 ofs)\r\n{\r\nwritel(bank, pcb_base + SATA_PCB_BANK_OFFSET);\r\nreturn readl(pcb_base + SATA_PCB_REG_OFFSET(ofs));\r\n}\r\nstatic int brcm_stb_sata_init(struct brcm_sata_port *port)\r\n{\r\nvoid __iomem *base = brcm_sata_pcb_base(port);\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nu32 tmp;\r\ntmp = TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL | TXPMD_CONTROL1_TX_SSC_EN_FRC;\r\nbrcm_sata_phy_wr(base, TXPMD_REG_BANK, TXPMD_CONTROL1, ~tmp, tmp);\r\nbrcm_sata_phy_wr(base, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL2,\r\n~TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK,\r\nSTB_FMIN_VAL_DEFAULT);\r\nif (port->ssc_en) {\r\ndev_info(priv->dev, "enabling SSC on port%d\n", port->portnum);\r\ntmp = STB_FMAX_VAL_SSC;\r\n} else {\r\ntmp = STB_FMAX_VAL_DEFAULT;\r\n}\r\nbrcm_sata_phy_wr(base, TXPMD_REG_BANK, TXPMD_TX_FREQ_CTRL_CONTROL3,\r\n~TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK, tmp);\r\nreturn 0;\r\n}\r\nstatic int brcm_ns2_sata_init(struct brcm_sata_port *port)\r\n{\r\nint try;\r\nunsigned int val;\r\nvoid __iomem *base = brcm_sata_pcb_base(port);\r\nvoid __iomem *ctrl_base = brcm_sata_ctrl_base(port);\r\nstruct device *dev = port->phy_priv->dev;\r\nval = 0x0;\r\nval |= (0xc << OOB_CTRL1_BURST_MAX_SHIFT);\r\nval |= (0x4 << OOB_CTRL1_BURST_MIN_SHIFT);\r\nval |= (0x9 << OOB_CTRL1_WAKE_IDLE_MAX_SHIFT);\r\nval |= (0x3 << OOB_CTRL1_WAKE_IDLE_MIN_SHIFT);\r\nbrcm_sata_phy_wr(base, OOB_REG_BANK, OOB_CTRL1, 0x0, val);\r\nval = 0x0;\r\nval |= (0x1b << OOB_CTRL2_RESET_IDLE_MAX_SHIFT);\r\nval |= (0x2 << OOB_CTRL2_BURST_CNT_SHIFT);\r\nval |= (0x9 << OOB_CTRL2_RESET_IDLE_MIN_SHIFT);\r\nbrcm_sata_phy_wr(base, OOB_REG_BANK, OOB_CTRL2, 0x0, val);\r\nval = NS2_PLL1_ACTRL2_MAGIC;\r\nbrcm_sata_phy_wr(base, PLL1_REG_BANK, PLL1_ACTRL2, 0x0, val);\r\nval = NS2_PLL1_ACTRL3_MAGIC;\r\nbrcm_sata_phy_wr(base, PLL1_REG_BANK, PLL1_ACTRL3, 0x0, val);\r\nval = NS2_PLL1_ACTRL4_MAGIC;\r\nbrcm_sata_phy_wr(base, PLL1_REG_BANK, PLL1_ACTRL4, 0x0, val);\r\nbrcm_sata_phy_wr(base, BLOCK0_REG_BANK, BLOCK0_SPARE,\r\n~BLOCK0_SPARE_OOB_CLK_SEL_MASK,\r\nBLOCK0_SPARE_OOB_CLK_SEL_REFBY2);\r\nwritel(PHY_CTRL_1_RESET, ctrl_base + PHY_CTRL_1);\r\nmdelay(1);\r\nwritel(0x0, ctrl_base + PHY_CTRL_1);\r\nmdelay(1);\r\ntry = 50;\r\nwhile (try) {\r\nval = brcm_sata_phy_rd(base, BLOCK0_REG_BANK,\r\nBLOCK0_XGXSSTATUS);\r\nif (val & BLOCK0_XGXSSTATUS_PLL_LOCK)\r\nbreak;\r\nmsleep(20);\r\ntry--;\r\n}\r\nif (!try) {\r\ndev_err(dev, "port%d PLL did not lock\n", port->portnum);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(dev, "port%d initialized\n", port->portnum);\r\nreturn 0;\r\n}\r\nstatic int brcm_nsp_sata_init(struct brcm_sata_port *port)\r\n{\r\nstruct brcm_sata_phy *priv = port->phy_priv;\r\nstruct device *dev = port->phy_priv->dev;\r\nvoid __iomem *base = priv->phy_base;\r\nunsigned int oob_bank;\r\nunsigned int val, try;\r\nif (port->portnum == 0)\r\noob_bank = OOB_REG_BANK;\r\nelse if (port->portnum == 1)\r\noob_bank = OOB1_REG_BANK;\r\nelse\r\nreturn -EINVAL;\r\nval = 0x0;\r\nval |= (0x0f << OOB_CTRL1_BURST_MAX_SHIFT);\r\nval |= (0x06 << OOB_CTRL1_BURST_MIN_SHIFT);\r\nval |= (0x0f << OOB_CTRL1_WAKE_IDLE_MAX_SHIFT);\r\nval |= (0x06 << OOB_CTRL1_WAKE_IDLE_MIN_SHIFT);\r\nbrcm_sata_phy_wr(base, oob_bank, OOB_CTRL1, 0x0, val);\r\nval = 0x0;\r\nval |= (0x2e << OOB_CTRL2_RESET_IDLE_MAX_SHIFT);\r\nval |= (0x02 << OOB_CTRL2_BURST_CNT_SHIFT);\r\nval |= (0x16 << OOB_CTRL2_RESET_IDLE_MIN_SHIFT);\r\nbrcm_sata_phy_wr(base, oob_bank, OOB_CTRL2, 0x0, val);\r\nbrcm_sata_phy_wr(base, PLL_REG_BANK_0, PLL_ACTRL2,\r\n~(PLL_ACTRL2_SELDIV_MASK << PLL_ACTRL2_SELDIV_SHIFT),\r\n0x0c << PLL_ACTRL2_SELDIV_SHIFT);\r\nbrcm_sata_phy_wr(base, PLL_REG_BANK_0, PLL_CAP_CONTROL,\r\n0xff0, 0x4f0);\r\nval = PLLCONTROL_0_FREQ_DET_RESTART | PLLCONTROL_0_FREQ_MONITOR;\r\nbrcm_sata_phy_wr(base, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\r\n~val, val);\r\nval = PLLCONTROL_0_SEQ_START;\r\nbrcm_sata_phy_wr(base, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\r\n~val, 0);\r\nmdelay(10);\r\nbrcm_sata_phy_wr(base, PLL_REG_BANK_0, PLL_REG_BANK_0_PLLCONTROL_0,\r\n~val, val);\r\ntry = 50;\r\nwhile (try--) {\r\nval = brcm_sata_phy_rd(base, BLOCK0_REG_BANK,\r\nBLOCK0_XGXSSTATUS);\r\nif (val & BLOCK0_XGXSSTATUS_PLL_LOCK)\r\nbreak;\r\nmsleep(20);\r\n}\r\nif (!try) {\r\ndev_err(dev, "port%d PLL did not lock\n", port->portnum);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(dev, "port%d initialized\n", port->portnum);\r\nreturn 0;\r\n}\r\nstatic int brcm_sata_phy_init(struct phy *phy)\r\n{\r\nint rc;\r\nstruct brcm_sata_port *port = phy_get_drvdata(phy);\r\nswitch (port->phy_priv->version) {\r\ncase BRCM_SATA_PHY_STB_28NM:\r\ncase BRCM_SATA_PHY_STB_40NM:\r\nrc = brcm_stb_sata_init(port);\r\nbreak;\r\ncase BRCM_SATA_PHY_IPROC_NS2:\r\nrc = brcm_ns2_sata_init(port);\r\nbreak;\r\ncase BRCM_SATA_PHY_IPROC_NSP:\r\nrc = brcm_nsp_sata_init(port);\r\nbreak;\r\ndefault:\r\nrc = -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic int brcm_sata_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dn = dev->of_node, *child;\r\nconst struct of_device_id *of_id;\r\nstruct brcm_sata_phy *priv;\r\nstruct resource *res;\r\nstruct phy_provider *provider;\r\nint ret, count = 0;\r\nif (of_get_child_count(dn) == 0)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, priv);\r\npriv->dev = dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy");\r\npriv->phy_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->phy_base))\r\nreturn PTR_ERR(priv->phy_base);\r\nof_id = of_match_node(brcm_sata_phy_of_match, dn);\r\nif (of_id)\r\npriv->version = (enum brcm_sata_phy_version)of_id->data;\r\nelse\r\npriv->version = BRCM_SATA_PHY_STB_28NM;\r\nif (priv->version == BRCM_SATA_PHY_IPROC_NS2) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"phy-ctrl");\r\npriv->ctrl_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->ctrl_base))\r\nreturn PTR_ERR(priv->ctrl_base);\r\n}\r\nfor_each_available_child_of_node(dn, child) {\r\nunsigned int id;\r\nstruct brcm_sata_port *port;\r\nif (of_property_read_u32(child, "reg", &id)) {\r\ndev_err(dev, "missing reg property in node %s\n",\r\nchild->name);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (id >= MAX_PORTS) {\r\ndev_err(dev, "invalid reg: %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (priv->phys[id].phy) {\r\ndev_err(dev, "already registered port %u\n", id);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nport = &priv->phys[id];\r\nport->portnum = id;\r\nport->phy_priv = priv;\r\nport->phy = devm_phy_create(dev, child, &phy_ops);\r\nport->ssc_en = of_property_read_bool(child, "brcm,enable-ssc");\r\nif (IS_ERR(port->phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nret = PTR_ERR(port->phy);\r\ngoto put_child;\r\n}\r\nphy_set_drvdata(port->phy, port);\r\ncount++;\r\n}\r\nprovider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(provider)) {\r\ndev_err(dev, "could not register PHY provider\n");\r\nreturn PTR_ERR(provider);\r\n}\r\ndev_info(dev, "registered %d port(s)\n", count);\r\nreturn 0;\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
