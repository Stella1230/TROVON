static inline unsigned long\r\nlcd_readl(struct pxafb_info *fbi, unsigned int off)\r\n{\r\nreturn __raw_readl(fbi->mmio_base + off);\r\n}\r\nstatic inline void\r\nlcd_writel(struct pxafb_info *fbi, unsigned int off, unsigned long val)\r\n{\r\n__raw_writel(val, fbi->mmio_base + off);\r\n}\r\nstatic inline void pxafb_schedule_work(struct pxafb_info *fbi, u_int state)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (fbi->task_state == C_ENABLE && state == C_REENABLE)\r\nstate = (u_int) -1;\r\nif (fbi->task_state == C_DISABLE && state == C_ENABLE)\r\nstate = C_REENABLE;\r\nif (state != (u_int)-1) {\r\nfbi->task_state = state;\r\nschedule_work(&fbi->task);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int\r\npxafb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nu_int val;\r\nif (regno >= fbi->palette_size)\r\nreturn 1;\r\nif (fbi->fb.var.grayscale) {\r\nfbi->palette_cpu[regno] = ((blue >> 8) & 0x00ff);\r\nreturn 0;\r\n}\r\nswitch (fbi->lccr4 & LCCR4_PAL_FOR_MASK) {\r\ncase LCCR4_PAL_FOR_0:\r\nval = ((red >> 0) & 0xf800);\r\nval |= ((green >> 5) & 0x07e0);\r\nval |= ((blue >> 11) & 0x001f);\r\nfbi->palette_cpu[regno] = val;\r\nbreak;\r\ncase LCCR4_PAL_FOR_1:\r\nval = ((red << 8) & 0x00f80000);\r\nval |= ((green >> 0) & 0x0000fc00);\r\nval |= ((blue >> 8) & 0x000000f8);\r\n((u32 *)(fbi->palette_cpu))[regno] = val;\r\nbreak;\r\ncase LCCR4_PAL_FOR_2:\r\nval = ((red << 8) & 0x00fc0000);\r\nval |= ((green >> 0) & 0x0000fc00);\r\nval |= ((blue >> 8) & 0x000000fc);\r\n((u32 *)(fbi->palette_cpu))[regno] = val;\r\nbreak;\r\ncase LCCR4_PAL_FOR_3:\r\nval = ((red << 8) & 0x00ff0000);\r\nval |= ((green >> 0) & 0x0000ff00);\r\nval |= ((blue >> 8) & 0x000000ff);\r\n((u32 *)(fbi->palette_cpu))[regno] = val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npxafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nunsigned int val;\r\nint ret = 1;\r\nif (fbi->cmap_inverse) {\r\nred = 0xffff - red;\r\ngreen = 0xffff - green;\r\nblue = 0xffff - blue;\r\n}\r\nif (fbi->fb.var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (fbi->fb.fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = fbi->fb.pseudo_palette;\r\nval = chan_to_field(red, &fbi->fb.var.red);\r\nval |= chan_to_field(green, &fbi->fb.var.green);\r\nval |= chan_to_field(blue, &fbi->fb.var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nret = pxafb_setpalettereg(regno, red, green, blue, trans, info);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int var_to_depth(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->red.length + var->green.length +\r\nvar->blue.length + var->transp.length;\r\n}\r\nstatic int pxafb_var_to_bpp(struct fb_var_screeninfo *var)\r\n{\r\nint bpp = -EINVAL;\r\nswitch (var->bits_per_pixel) {\r\ncase 1: bpp = 0; break;\r\ncase 2: bpp = 1; break;\r\ncase 4: bpp = 2; break;\r\ncase 8: bpp = 3; break;\r\ncase 16: bpp = 4; break;\r\ncase 24:\r\nswitch (var_to_depth(var)) {\r\ncase 18: bpp = 6; break;\r\ncase 19: bpp = 8; break;\r\ncase 24: bpp = 9; break;\r\n}\r\nbreak;\r\ncase 32:\r\nswitch (var_to_depth(var)) {\r\ncase 18: bpp = 5; break;\r\ncase 19: bpp = 7; break;\r\ncase 25: bpp = 10; break;\r\n}\r\nbreak;\r\n}\r\nreturn bpp;\r\n}\r\nstatic uint32_t pxafb_var_to_lccr3(struct fb_var_screeninfo *var)\r\n{\r\nint bpp = pxafb_var_to_bpp(var);\r\nuint32_t lccr3;\r\nif (bpp < 0)\r\nreturn 0;\r\nlccr3 = LCCR3_BPP(bpp);\r\nswitch (var_to_depth(var)) {\r\ncase 16: lccr3 |= var->transp.length ? LCCR3_PDFOR_3 : 0; break;\r\ncase 18: lccr3 |= LCCR3_PDFOR_3; break;\r\ncase 24: lccr3 |= var->transp.length ? LCCR3_PDFOR_2 : LCCR3_PDFOR_3;\r\nbreak;\r\ncase 19:\r\ncase 25: lccr3 |= LCCR3_PDFOR_0; break;\r\n}\r\nreturn lccr3;\r\n}\r\nstatic void pxafb_set_pixfmt(struct fb_var_screeninfo *var, int depth)\r\n{\r\nif (depth == 0)\r\ndepth = var->bits_per_pixel;\r\nif (var->bits_per_pixel < 16) {\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 8;\r\n}\r\nswitch (depth) {\r\ncase 16: var->transp.length ?\r\nSET_PIXFMT(var, 5, 5, 5, 1) :\r\nSET_PIXFMT(var, 5, 6, 5, 0); break;\r\ncase 18: SET_PIXFMT(var, 6, 6, 6, 0); break;\r\ncase 19: SET_PIXFMT(var, 6, 6, 6, 1); break;\r\ncase 24: var->transp.length ?\r\nSET_PIXFMT(var, 8, 8, 7, 1) :\r\nSET_PIXFMT(var, 8, 8, 8, 0); break;\r\ncase 25: SET_PIXFMT(var, 8, 8, 8, 1); break;\r\n}\r\n}\r\nstatic unsigned int pxafb_display_dma_period(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->pixclock * 8 * 16 / var->bits_per_pixel;\r\n}\r\nstatic struct pxafb_mode_info *pxafb_getmode(struct pxafb_mach_info *mach,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct pxafb_mode_info *mode = NULL;\r\nstruct pxafb_mode_info *modelist = mach->modes;\r\nunsigned int best_x = 0xffffffff, best_y = 0xffffffff;\r\nunsigned int i;\r\nfor (i = 0; i < mach->num_modes; i++) {\r\nif (modelist[i].xres >= var->xres &&\r\nmodelist[i].yres >= var->yres &&\r\nmodelist[i].xres < best_x &&\r\nmodelist[i].yres < best_y &&\r\nmodelist[i].bpp >= var->bits_per_pixel) {\r\nbest_x = modelist[i].xres;\r\nbest_y = modelist[i].yres;\r\nmode = &modelist[i];\r\n}\r\n}\r\nreturn mode;\r\n}\r\nstatic void pxafb_setmode(struct fb_var_screeninfo *var,\r\nstruct pxafb_mode_info *mode)\r\n{\r\nvar->xres = mode->xres;\r\nvar->yres = mode->yres;\r\nvar->bits_per_pixel = mode->bpp;\r\nvar->pixclock = mode->pixclock;\r\nvar->hsync_len = mode->hsync_len;\r\nvar->left_margin = mode->left_margin;\r\nvar->right_margin = mode->right_margin;\r\nvar->vsync_len = mode->vsync_len;\r\nvar->upper_margin = mode->upper_margin;\r\nvar->lower_margin = mode->lower_margin;\r\nvar->sync = mode->sync;\r\nvar->grayscale = mode->cmap_greyscale;\r\nvar->transp.length = mode->transparency;\r\npxafb_set_pixfmt(var, mode->depth);\r\n}\r\nstatic int pxafb_adjust_timing(struct pxafb_info *fbi,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint line_length;\r\nvar->xres = max_t(int, var->xres, MIN_XRES);\r\nvar->yres = max_t(int, var->yres, MIN_YRES);\r\nif (!(fbi->lccr0 & LCCR0_LCDT)) {\r\nclamp_val(var->hsync_len, 1, 64);\r\nclamp_val(var->vsync_len, 1, 64);\r\nclamp_val(var->left_margin, 1, 255);\r\nclamp_val(var->right_margin, 1, 255);\r\nclamp_val(var->upper_margin, 1, 255);\r\nclamp_val(var->lower_margin, 1, 255);\r\n}\r\nline_length = var->xres * var->bits_per_pixel / 8;\r\nline_length = ALIGN(line_length, 4);\r\nvar->xres = line_length * 8 / var->bits_per_pixel;\r\nvar->xres_virtual = var->xres;\r\nif (var->accel_flags & FB_ACCELF_TEXT)\r\nvar->yres_virtual = fbi->fb.fix.smem_len / line_length;\r\nelse\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\nif (var->xres > MAX_XRES || var->yres > MAX_YRES)\r\nreturn -EINVAL;\r\nif (var->yres > var->yres_virtual)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pxafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nstruct pxafb_mach_info *inf = fbi->inf;\r\nint err;\r\nif (inf->fixed_modes) {\r\nstruct pxafb_mode_info *mode;\r\nmode = pxafb_getmode(inf, var);\r\nif (!mode)\r\nreturn -EINVAL;\r\npxafb_setmode(var, mode);\r\n}\r\nerr = pxafb_var_to_bpp(var);\r\nif (err < 0)\r\nreturn err;\r\npxafb_set_pixfmt(var, var_to_depth(var));\r\nerr = pxafb_adjust_timing(fbi, var);\r\nif (err)\r\nreturn err;\r\n#ifdef CONFIG_CPU_FREQ\r\npr_debug("pxafb: dma period = %d ps\n",\r\npxafb_display_dma_period(var));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pxafb_set_par(struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nstruct fb_var_screeninfo *var = &info->var;\r\nif (var->bits_per_pixel >= 16)\r\nfbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse if (!fbi->cmap_static)\r\nfbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse {\r\nfbi->fb.fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\nfbi->fb.fix.line_length = var->xres_virtual *\r\nvar->bits_per_pixel / 8;\r\nif (var->bits_per_pixel >= 16)\r\nfbi->palette_size = 0;\r\nelse\r\nfbi->palette_size = var->bits_per_pixel == 1 ?\r\n4 : 1 << var->bits_per_pixel;\r\nfbi->palette_cpu = (u16 *)&fbi->dma_buff->palette[0];\r\nif (fbi->fb.var.bits_per_pixel >= 16)\r\nfb_dealloc_cmap(&fbi->fb.cmap);\r\nelse\r\nfb_alloc_cmap(&fbi->fb.cmap, 1<<fbi->fb.var.bits_per_pixel, 0);\r\npxafb_activate_var(var, fbi);\r\nreturn 0;\r\n}\r\nstatic int pxafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nstruct fb_var_screeninfo newvar;\r\nint dma = DMA_MAX + DMA_BASE;\r\nif (fbi->state != C_ENABLE)\r\nreturn 0;\r\nmemcpy(&newvar, &fbi->fb.var, sizeof(newvar));\r\nnewvar.xoffset = var->xoffset;\r\nnewvar.yoffset = var->yoffset;\r\nnewvar.vmode &= ~FB_VMODE_YWRAP;\r\nnewvar.vmode |= var->vmode & FB_VMODE_YWRAP;\r\nsetup_base_frame(fbi, &newvar, 1);\r\nif (fbi->lccr0 & LCCR0_SDS)\r\nlcd_writel(fbi, FBR1, fbi->fdadr[dma + 1] | 0x1);\r\nlcd_writel(fbi, FBR0, fbi->fdadr[dma] | 0x1);\r\nreturn 0;\r\n}\r\nstatic int pxafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nint i;\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\r\nfbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\r\nfor (i = 0; i < fbi->palette_size; i++)\r\npxafb_setpalettereg(i, 0, 0, 0, 0, info);\r\npxafb_schedule_work(fbi, C_DISABLE);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nif (fbi->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR ||\r\nfbi->fb.fix.visual == FB_VISUAL_STATIC_PSEUDOCOLOR)\r\nfb_set_cmap(&fbi->fb.cmap, info);\r\npxafb_schedule_work(fbi, C_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic void overlay1fb_setup(struct pxafb_layer *ofb)\r\n{\r\nint size = ofb->fb.fix.line_length * ofb->fb.var.yres_virtual;\r\nunsigned long start = ofb->video_mem_phys;\r\nsetup_frame_dma(ofb->fbi, DMA_OV1, PAL_NONE, start, size);\r\n}\r\nstatic void overlay1fb_enable(struct pxafb_layer *ofb)\r\n{\r\nint enabled = lcd_readl(ofb->fbi, OVL1C1) & OVLxC1_OEN;\r\nuint32_t fdadr1 = ofb->fbi->fdadr[DMA_OV1] | (enabled ? 0x1 : 0);\r\nlcd_writel(ofb->fbi, enabled ? FBR1 : FDADR1, fdadr1);\r\nlcd_writel(ofb->fbi, OVL1C2, ofb->control[1]);\r\nlcd_writel(ofb->fbi, OVL1C1, ofb->control[0] | OVLxC1_OEN);\r\n}\r\nstatic void overlay1fb_disable(struct pxafb_layer *ofb)\r\n{\r\nuint32_t lccr5;\r\nif (!(lcd_readl(ofb->fbi, OVL1C1) & OVLxC1_OEN))\r\nreturn;\r\nlccr5 = lcd_readl(ofb->fbi, LCCR5);\r\nlcd_writel(ofb->fbi, OVL1C1, ofb->control[0] & ~OVLxC1_OEN);\r\nlcd_writel(ofb->fbi, LCSR1, LCSR1_BS(1));\r\nlcd_writel(ofb->fbi, LCCR5, lccr5 & ~LCSR1_BS(1));\r\nlcd_writel(ofb->fbi, FBR1, ofb->fbi->fdadr[DMA_OV1] | 0x3);\r\nif (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)\r\npr_warning("%s: timeout disabling overlay1\n", __func__);\r\nlcd_writel(ofb->fbi, LCCR5, lccr5);\r\n}\r\nstatic void overlay2fb_setup(struct pxafb_layer *ofb)\r\n{\r\nint size, div = 1, pfor = NONSTD_TO_PFOR(ofb->fb.var.nonstd);\r\nunsigned long start[3] = { ofb->video_mem_phys, 0, 0 };\r\nif (pfor == OVERLAY_FORMAT_RGB || pfor == OVERLAY_FORMAT_YUV444_PACKED) {\r\nsize = ofb->fb.fix.line_length * ofb->fb.var.yres_virtual;\r\nsetup_frame_dma(ofb->fbi, DMA_OV2_Y, -1, start[0], size);\r\n} else {\r\nsize = ofb->fb.var.xres_virtual * ofb->fb.var.yres_virtual;\r\nswitch (pfor) {\r\ncase OVERLAY_FORMAT_YUV444_PLANAR: div = 1; break;\r\ncase OVERLAY_FORMAT_YUV422_PLANAR: div = 2; break;\r\ncase OVERLAY_FORMAT_YUV420_PLANAR: div = 4; break;\r\n}\r\nstart[1] = start[0] + size;\r\nstart[2] = start[1] + size / div;\r\nsetup_frame_dma(ofb->fbi, DMA_OV2_Y, -1, start[0], size);\r\nsetup_frame_dma(ofb->fbi, DMA_OV2_Cb, -1, start[1], size / div);\r\nsetup_frame_dma(ofb->fbi, DMA_OV2_Cr, -1, start[2], size / div);\r\n}\r\n}\r\nstatic void overlay2fb_enable(struct pxafb_layer *ofb)\r\n{\r\nint pfor = NONSTD_TO_PFOR(ofb->fb.var.nonstd);\r\nint enabled = lcd_readl(ofb->fbi, OVL2C1) & OVLxC1_OEN;\r\nuint32_t fdadr2 = ofb->fbi->fdadr[DMA_OV2_Y] | (enabled ? 0x1 : 0);\r\nuint32_t fdadr3 = ofb->fbi->fdadr[DMA_OV2_Cb] | (enabled ? 0x1 : 0);\r\nuint32_t fdadr4 = ofb->fbi->fdadr[DMA_OV2_Cr] | (enabled ? 0x1 : 0);\r\nif (pfor == OVERLAY_FORMAT_RGB || pfor == OVERLAY_FORMAT_YUV444_PACKED)\r\nlcd_writel(ofb->fbi, enabled ? FBR2 : FDADR2, fdadr2);\r\nelse {\r\nlcd_writel(ofb->fbi, enabled ? FBR2 : FDADR2, fdadr2);\r\nlcd_writel(ofb->fbi, enabled ? FBR3 : FDADR3, fdadr3);\r\nlcd_writel(ofb->fbi, enabled ? FBR4 : FDADR4, fdadr4);\r\n}\r\nlcd_writel(ofb->fbi, OVL2C2, ofb->control[1]);\r\nlcd_writel(ofb->fbi, OVL2C1, ofb->control[0] | OVLxC1_OEN);\r\n}\r\nstatic void overlay2fb_disable(struct pxafb_layer *ofb)\r\n{\r\nuint32_t lccr5;\r\nif (!(lcd_readl(ofb->fbi, OVL2C1) & OVLxC1_OEN))\r\nreturn;\r\nlccr5 = lcd_readl(ofb->fbi, LCCR5);\r\nlcd_writel(ofb->fbi, OVL2C1, ofb->control[0] & ~OVLxC1_OEN);\r\nlcd_writel(ofb->fbi, LCSR1, LCSR1_BS(2));\r\nlcd_writel(ofb->fbi, LCCR5, lccr5 & ~LCSR1_BS(2));\r\nlcd_writel(ofb->fbi, FBR2, ofb->fbi->fdadr[DMA_OV2_Y] | 0x3);\r\nlcd_writel(ofb->fbi, FBR3, ofb->fbi->fdadr[DMA_OV2_Cb] | 0x3);\r\nlcd_writel(ofb->fbi, FBR4, ofb->fbi->fdadr[DMA_OV2_Cr] | 0x3);\r\nif (wait_for_completion_timeout(&ofb->branch_done, 1 * HZ) == 0)\r\npr_warning("%s: timeout disabling overlay2\n", __func__);\r\n}\r\nstatic int overlayfb_open(struct fb_info *info, int user)\r\n{\r\nstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\r\nif (user == 0)\r\nreturn -ENODEV;\r\nif (ofb->usage++ == 0) {\r\nconsole_lock();\r\nfb_blank(&ofb->fbi->fb, FB_BLANK_UNBLANK);\r\nconsole_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int overlayfb_release(struct fb_info *info, int user)\r\n{\r\nstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\r\nif (ofb->usage == 1) {\r\nofb->ops->disable(ofb);\r\nofb->fb.var.height = -1;\r\nofb->fb.var.width = -1;\r\nofb->fb.var.xres = ofb->fb.var.xres_virtual = 0;\r\nofb->fb.var.yres = ofb->fb.var.yres_virtual = 0;\r\nofb->usage--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int overlayfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\r\nstruct fb_var_screeninfo *base_var = &ofb->fbi->fb.var;\r\nint xpos, ypos, pfor, bpp;\r\nxpos = NONSTD_TO_XPOS(var->nonstd);\r\nypos = NONSTD_TO_YPOS(var->nonstd);\r\npfor = NONSTD_TO_PFOR(var->nonstd);\r\nbpp = pxafb_var_to_bpp(var);\r\nif (bpp < 0)\r\nreturn -EINVAL;\r\nif (ofb->id == OVERLAY1 && pfor != 0)\r\nreturn -EINVAL;\r\nswitch (pfor) {\r\ncase OVERLAY_FORMAT_RGB:\r\nbpp = pxafb_var_to_bpp(var);\r\nif (bpp < 0)\r\nreturn -EINVAL;\r\npxafb_set_pixfmt(var, var_to_depth(var));\r\nbreak;\r\ncase OVERLAY_FORMAT_YUV444_PACKED: bpp = 24; break;\r\ncase OVERLAY_FORMAT_YUV444_PLANAR: bpp = 8; break;\r\ncase OVERLAY_FORMAT_YUV422_PLANAR: bpp = 4; break;\r\ncase OVERLAY_FORMAT_YUV420_PLANAR: bpp = 2; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((xpos * bpp) % 32)\r\nreturn -EINVAL;\r\nvar->xres = roundup(var->xres * bpp, 32) / bpp;\r\nif ((xpos + var->xres > base_var->xres) ||\r\n(ypos + var->yres > base_var->yres))\r\nreturn -EINVAL;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = max(var->yres, var->yres_virtual);\r\nreturn 0;\r\n}\r\nstatic int overlayfb_check_video_memory(struct pxafb_layer *ofb)\r\n{\r\nstruct fb_var_screeninfo *var = &ofb->fb.var;\r\nint pfor = NONSTD_TO_PFOR(var->nonstd);\r\nint size, bpp = 0;\r\nswitch (pfor) {\r\ncase OVERLAY_FORMAT_RGB: bpp = var->bits_per_pixel; break;\r\ncase OVERLAY_FORMAT_YUV444_PACKED: bpp = 24; break;\r\ncase OVERLAY_FORMAT_YUV444_PLANAR: bpp = 24; break;\r\ncase OVERLAY_FORMAT_YUV422_PLANAR: bpp = 16; break;\r\ncase OVERLAY_FORMAT_YUV420_PLANAR: bpp = 12; break;\r\n}\r\nofb->fb.fix.line_length = var->xres_virtual * bpp / 8;\r\nsize = PAGE_ALIGN(ofb->fb.fix.line_length * var->yres_virtual);\r\nif (ofb->video_mem) {\r\nif (ofb->video_mem_size >= size)\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int overlayfb_set_par(struct fb_info *info)\r\n{\r\nstruct pxafb_layer *ofb = container_of(info, struct pxafb_layer, fb);\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint xpos, ypos, pfor, bpp, ret;\r\nret = overlayfb_check_video_memory(ofb);\r\nif (ret)\r\nreturn ret;\r\nbpp = pxafb_var_to_bpp(var);\r\nxpos = NONSTD_TO_XPOS(var->nonstd);\r\nypos = NONSTD_TO_YPOS(var->nonstd);\r\npfor = NONSTD_TO_PFOR(var->nonstd);\r\nofb->control[0] = OVLxC1_PPL(var->xres) | OVLxC1_LPO(var->yres) |\r\nOVLxC1_BPP(bpp);\r\nofb->control[1] = OVLxC2_XPOS(xpos) | OVLxC2_YPOS(ypos);\r\nif (ofb->id == OVERLAY2)\r\nofb->control[1] |= OVL2C2_PFOR(pfor);\r\nofb->ops->setup(ofb);\r\nofb->ops->enable(ofb);\r\nreturn 0;\r\n}\r\nstatic void init_pxafb_overlay(struct pxafb_info *fbi, struct pxafb_layer *ofb,\r\nint id)\r\n{\r\nsprintf(ofb->fb.fix.id, "overlay%d", id + 1);\r\nofb->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nofb->fb.fix.xpanstep = 0;\r\nofb->fb.fix.ypanstep = 1;\r\nofb->fb.var.activate = FB_ACTIVATE_NOW;\r\nofb->fb.var.height = -1;\r\nofb->fb.var.width = -1;\r\nofb->fb.var.vmode = FB_VMODE_NONINTERLACED;\r\nofb->fb.fbops = &overlay_fb_ops;\r\nofb->fb.flags = FBINFO_FLAG_DEFAULT;\r\nofb->fb.node = -1;\r\nofb->fb.pseudo_palette = NULL;\r\nofb->id = id;\r\nofb->ops = &ofb_ops[id];\r\nofb->usage = 0;\r\nofb->fbi = fbi;\r\ninit_completion(&ofb->branch_done);\r\n}\r\nstatic inline int pxafb_overlay_supported(void)\r\n{\r\nif (cpu_is_pxa27x() || cpu_is_pxa3xx())\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int pxafb_overlay_map_video_memory(struct pxafb_info *pxafb,\r\nstruct pxafb_layer *ofb)\r\n{\r\nofb->video_mem = alloc_pages_exact(PAGE_ALIGN(pxafb->video_mem_size),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (ofb->video_mem == NULL)\r\nreturn -ENOMEM;\r\nofb->video_mem_phys = virt_to_phys(ofb->video_mem);\r\nofb->video_mem_size = PAGE_ALIGN(pxafb->video_mem_size);\r\nmutex_lock(&ofb->fb.mm_lock);\r\nofb->fb.fix.smem_start = ofb->video_mem_phys;\r\nofb->fb.fix.smem_len = pxafb->video_mem_size;\r\nmutex_unlock(&ofb->fb.mm_lock);\r\nofb->fb.screen_base = ofb->video_mem;\r\nreturn 0;\r\n}\r\nstatic void pxafb_overlay_init(struct pxafb_info *fbi)\r\n{\r\nint i, ret;\r\nif (!pxafb_overlay_supported())\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\nstruct pxafb_layer *ofb = &fbi->overlay[i];\r\ninit_pxafb_overlay(fbi, ofb, i);\r\nret = register_framebuffer(&ofb->fb);\r\nif (ret) {\r\ndev_err(fbi->dev, "failed to register overlay %d\n", i);\r\ncontinue;\r\n}\r\nret = pxafb_overlay_map_video_memory(fbi, ofb);\r\nif (ret) {\r\ndev_err(fbi->dev,\r\n"failed to map video memory for overlay %d\n",\r\ni);\r\nunregister_framebuffer(&ofb->fb);\r\ncontinue;\r\n}\r\nofb->registered = 1;\r\n}\r\nlcd_writel(fbi, LCCR5, ~0);\r\npr_info("PXA Overlay driver loaded successfully!\n");\r\n}\r\nstatic void pxafb_overlay_exit(struct pxafb_info *fbi)\r\n{\r\nint i;\r\nif (!pxafb_overlay_supported())\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\nstruct pxafb_layer *ofb = &fbi->overlay[i];\r\nif (ofb->registered) {\r\nif (ofb->video_mem)\r\nfree_pages_exact(ofb->video_mem,\r\nofb->video_mem_size);\r\nunregister_framebuffer(&ofb->fb);\r\n}\r\n}\r\n}\r\nstatic inline void pxafb_overlay_init(struct pxafb_info *fbi) {}\r\nstatic inline void pxafb_overlay_exit(struct pxafb_info *fbi) {}\r\nstatic inline unsigned int get_pcd(struct pxafb_info *fbi,\r\nunsigned int pixclock)\r\n{\r\nunsigned long long pcd;\r\npcd = (unsigned long long)(clk_get_rate(fbi->clk) / 10000);\r\npcd *= pixclock;\r\ndo_div(pcd, 100000000 * 2);\r\nreturn (unsigned int)pcd;\r\n}\r\nstatic inline void set_hsync_time(struct pxafb_info *fbi, unsigned int pcd)\r\n{\r\nunsigned long htime;\r\nif ((pcd == 0) || (fbi->fb.var.hsync_len == 0)) {\r\nfbi->hsync_time = 0;\r\nreturn;\r\n}\r\nhtime = clk_get_rate(fbi->clk) / (pcd * fbi->fb.var.hsync_len);\r\nfbi->hsync_time = htime;\r\n}\r\nunsigned long pxafb_get_hsync_time(struct device *dev)\r\n{\r\nstruct pxafb_info *fbi = dev_get_drvdata(dev);\r\nif (!fbi || (fbi->state != C_ENABLE))\r\nreturn 0;\r\nreturn fbi->hsync_time;\r\n}\r\nstatic int setup_frame_dma(struct pxafb_info *fbi, int dma, int pal,\r\nunsigned long start, size_t size)\r\n{\r\nstruct pxafb_dma_descriptor *dma_desc, *pal_desc;\r\nunsigned int dma_desc_off, pal_desc_off;\r\nif (dma < 0 || dma >= DMA_MAX * 2)\r\nreturn -EINVAL;\r\ndma_desc = &fbi->dma_buff->dma_desc[dma];\r\ndma_desc_off = offsetof(struct pxafb_dma_buff, dma_desc[dma]);\r\ndma_desc->fsadr = start;\r\ndma_desc->fidr = 0;\r\ndma_desc->ldcmd = size;\r\nif (pal < 0 || pal >= PAL_MAX * 2) {\r\ndma_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\r\nfbi->fdadr[dma] = fbi->dma_buff_phys + dma_desc_off;\r\n} else {\r\npal_desc = &fbi->dma_buff->pal_desc[pal];\r\npal_desc_off = offsetof(struct pxafb_dma_buff, pal_desc[pal]);\r\npal_desc->fsadr = fbi->dma_buff_phys + pal * PALETTE_SIZE;\r\npal_desc->fidr = 0;\r\nif ((fbi->lccr4 & LCCR4_PAL_FOR_MASK) == LCCR4_PAL_FOR_0)\r\npal_desc->ldcmd = fbi->palette_size * sizeof(u16);\r\nelse\r\npal_desc->ldcmd = fbi->palette_size * sizeof(u32);\r\npal_desc->ldcmd |= LDCMD_PAL;\r\npal_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\r\ndma_desc->fdadr = fbi->dma_buff_phys + pal_desc_off;\r\nfbi->fdadr[dma] = fbi->dma_buff_phys + dma_desc_off;\r\n}\r\nreturn 0;\r\n}\r\nstatic void setup_base_frame(struct pxafb_info *fbi,\r\nstruct fb_var_screeninfo *var,\r\nint branch)\r\n{\r\nstruct fb_fix_screeninfo *fix = &fbi->fb.fix;\r\nint nbytes, dma, pal, bpp = var->bits_per_pixel;\r\nunsigned long offset;\r\ndma = DMA_BASE + (branch ? DMA_MAX : 0);\r\npal = (bpp >= 16) ? PAL_NONE : PAL_BASE + (branch ? PAL_MAX : 0);\r\nnbytes = fix->line_length * var->yres;\r\noffset = fix->line_length * var->yoffset + fbi->video_mem_phys;\r\nif (fbi->lccr0 & LCCR0_SDS) {\r\nnbytes = nbytes / 2;\r\nsetup_frame_dma(fbi, dma + 1, PAL_NONE, offset + nbytes, nbytes);\r\n}\r\nsetup_frame_dma(fbi, dma, pal, offset, nbytes);\r\n}\r\nstatic int setup_smart_dma(struct pxafb_info *fbi)\r\n{\r\nstruct pxafb_dma_descriptor *dma_desc;\r\nunsigned long dma_desc_off, cmd_buff_off;\r\ndma_desc = &fbi->dma_buff->dma_desc[DMA_CMD];\r\ndma_desc_off = offsetof(struct pxafb_dma_buff, dma_desc[DMA_CMD]);\r\ncmd_buff_off = offsetof(struct pxafb_dma_buff, cmd_buff);\r\ndma_desc->fdadr = fbi->dma_buff_phys + dma_desc_off;\r\ndma_desc->fsadr = fbi->dma_buff_phys + cmd_buff_off;\r\ndma_desc->fidr = 0;\r\ndma_desc->ldcmd = fbi->n_smart_cmds * sizeof(uint16_t);\r\nfbi->fdadr[DMA_CMD] = dma_desc->fdadr;\r\nreturn 0;\r\n}\r\nint pxafb_smart_flush(struct fb_info *info)\r\n{\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nuint32_t prsr;\r\nint ret = 0;\r\nlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\r\nwhile (fbi->n_smart_cmds & 1)\r\nfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_NOOP;\r\nfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_INTERRUPT;\r\nfbi->smart_cmds[fbi->n_smart_cmds++] = SMART_CMD_WAIT_FOR_VSYNC;\r\nsetup_smart_dma(fbi);\r\nprsr = lcd_readl(fbi, PRSR) | PRSR_ST_OK | PRSR_CON_NT;\r\nlcd_writel(fbi, PRSR, prsr);\r\nlcd_writel(fbi, CMDCR, 0x0001);\r\nlcd_writel(fbi, LCCR5, LCCR5_IUM(6));\r\nlcd_writel(fbi, LCCR1, fbi->reg_lccr1);\r\nlcd_writel(fbi, LCCR2, fbi->reg_lccr2);\r\nlcd_writel(fbi, LCCR3, fbi->reg_lccr3);\r\nlcd_writel(fbi, LCCR4, fbi->reg_lccr4);\r\nlcd_writel(fbi, FDADR0, fbi->fdadr[0]);\r\nlcd_writel(fbi, FDADR6, fbi->fdadr[6]);\r\nlcd_writel(fbi, LCCR0, fbi->reg_lccr0 | LCCR0_ENB);\r\nif (wait_for_completion_timeout(&fbi->command_done, HZ/2) == 0) {\r\npr_warning("%s: timeout waiting for command done\n",\r\n__func__);\r\nret = -ETIMEDOUT;\r\n}\r\nprsr = lcd_readl(fbi, PRSR) & ~(PRSR_ST_OK | PRSR_CON_NT);\r\nlcd_writel(fbi, PRSR, prsr);\r\nlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\r\nlcd_writel(fbi, FDADR6, 0);\r\nfbi->n_smart_cmds = 0;\r\nreturn ret;\r\n}\r\nint pxafb_smart_queue(struct fb_info *info, uint16_t *cmds, int n_cmds)\r\n{\r\nint i;\r\nstruct pxafb_info *fbi = container_of(info, struct pxafb_info, fb);\r\nfor (i = 0; i < n_cmds; i++, cmds++) {\r\nif ((*cmds & 0xff00) == SMART_CMD_DELAY) {\r\npxafb_smart_flush(info);\r\nmdelay(*cmds & 0xff);\r\ncontinue;\r\n}\r\nif (fbi->n_smart_cmds == CMD_BUFF_SIZE - 8)\r\npxafb_smart_flush(info);\r\nfbi->smart_cmds[fbi->n_smart_cmds++] = *cmds;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int __smart_timing(unsigned time_ns, unsigned long lcd_clk)\r\n{\r\nunsigned int t = (time_ns * (lcd_clk / 1000000) / 1000);\r\nreturn (t == 0) ? 1 : t;\r\n}\r\nstatic void setup_smart_timing(struct pxafb_info *fbi,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct pxafb_mach_info *inf = fbi->inf;\r\nstruct pxafb_mode_info *mode = &inf->modes[0];\r\nunsigned long lclk = clk_get_rate(fbi->clk);\r\nunsigned t1, t2, t3, t4;\r\nt1 = max(mode->a0csrd_set_hld, mode->a0cswr_set_hld);\r\nt2 = max(mode->rd_pulse_width, mode->wr_pulse_width);\r\nt3 = mode->op_hold_time;\r\nt4 = mode->cmd_inh_time;\r\nfbi->reg_lccr1 =\r\nLCCR1_DisWdth(var->xres) |\r\nLCCR1_BegLnDel(__smart_timing(t1, lclk)) |\r\nLCCR1_EndLnDel(__smart_timing(t2, lclk)) |\r\nLCCR1_HorSnchWdth(__smart_timing(t3, lclk));\r\nfbi->reg_lccr2 = LCCR2_DisHght(var->yres);\r\nfbi->reg_lccr3 = fbi->lccr3 | LCCR3_PixClkDiv(__smart_timing(t4, lclk));\r\nfbi->reg_lccr3 |= (var->sync & FB_SYNC_HOR_HIGH_ACT) ? LCCR3_HSP : 0;\r\nfbi->reg_lccr3 |= (var->sync & FB_SYNC_VERT_HIGH_ACT) ? LCCR3_VSP : 0;\r\nfbi->reg_cmdcr = 1;\r\n}\r\nstatic int pxafb_smart_thread(void *arg)\r\n{\r\nstruct pxafb_info *fbi = arg;\r\nstruct pxafb_mach_info *inf = fbi->inf;\r\nif (!inf->smart_update) {\r\npr_err("%s: not properly initialized, thread terminated\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s(): task starting\n", __func__);\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\nif (try_to_freeze())\r\ncontinue;\r\nmutex_lock(&fbi->ctrlr_lock);\r\nif (fbi->state == C_ENABLE) {\r\ninf->smart_update(&fbi->fb);\r\ncomplete(&fbi->refresh_done);\r\n}\r\nmutex_unlock(&fbi->ctrlr_lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(30));\r\n}\r\npr_debug("%s(): task ending\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int pxafb_smart_init(struct pxafb_info *fbi)\r\n{\r\nif (!(fbi->lccr0 & LCCR0_LCDT))\r\nreturn 0;\r\nfbi->smart_cmds = (uint16_t *) fbi->dma_buff->cmd_buff;\r\nfbi->n_smart_cmds = 0;\r\ninit_completion(&fbi->command_done);\r\ninit_completion(&fbi->refresh_done);\r\nfbi->smart_thread = kthread_run(pxafb_smart_thread, fbi,\r\n"lcd_refresh");\r\nif (IS_ERR(fbi->smart_thread)) {\r\npr_err("%s: unable to create kernel thread\n", __func__);\r\nreturn PTR_ERR(fbi->smart_thread);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int pxafb_smart_init(struct pxafb_info *fbi) { return 0; }\r\nstatic void setup_parallel_timing(struct pxafb_info *fbi,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nunsigned int lines_per_panel, pcd = get_pcd(fbi, var->pixclock);\r\nfbi->reg_lccr1 =\r\nLCCR1_DisWdth(var->xres) +\r\nLCCR1_HorSnchWdth(var->hsync_len) +\r\nLCCR1_BegLnDel(var->left_margin) +\r\nLCCR1_EndLnDel(var->right_margin);\r\nlines_per_panel = var->yres;\r\nif ((fbi->lccr0 & LCCR0_SDS) == LCCR0_Dual)\r\nlines_per_panel /= 2;\r\nfbi->reg_lccr2 =\r\nLCCR2_DisHght(lines_per_panel) +\r\nLCCR2_VrtSnchWdth(var->vsync_len) +\r\nLCCR2_BegFrmDel(var->upper_margin) +\r\nLCCR2_EndFrmDel(var->lower_margin);\r\nfbi->reg_lccr3 = fbi->lccr3 |\r\n(var->sync & FB_SYNC_HOR_HIGH_ACT ?\r\nLCCR3_HorSnchH : LCCR3_HorSnchL) |\r\n(var->sync & FB_SYNC_VERT_HIGH_ACT ?\r\nLCCR3_VrtSnchH : LCCR3_VrtSnchL);\r\nif (pcd) {\r\nfbi->reg_lccr3 |= LCCR3_PixClkDiv(pcd);\r\nset_hsync_time(fbi, pcd);\r\n}\r\n}\r\nstatic int pxafb_activate_var(struct fb_var_screeninfo *var,\r\nstruct pxafb_info *fbi)\r\n{\r\nu_long flags;\r\nlocal_irq_save(flags);\r\n#ifdef CONFIG_FB_PXA_SMARTPANEL\r\nif (fbi->lccr0 & LCCR0_LCDT)\r\nsetup_smart_timing(fbi, var);\r\nelse\r\n#endif\r\nsetup_parallel_timing(fbi, var);\r\nsetup_base_frame(fbi, var, 0);\r\nfbi->reg_lccr0 = fbi->lccr0 |\r\n(LCCR0_LDM | LCCR0_SFM | LCCR0_IUM | LCCR0_EFM |\r\nLCCR0_QDM | LCCR0_BM | LCCR0_OUM);\r\nfbi->reg_lccr3 |= pxafb_var_to_lccr3(var);\r\nfbi->reg_lccr4 = lcd_readl(fbi, LCCR4) & ~LCCR4_PAL_FOR_MASK;\r\nfbi->reg_lccr4 |= (fbi->lccr4 & LCCR4_PAL_FOR_MASK);\r\nlocal_irq_restore(flags);\r\nif ((lcd_readl(fbi, LCCR0) != fbi->reg_lccr0) ||\r\n(lcd_readl(fbi, LCCR1) != fbi->reg_lccr1) ||\r\n(lcd_readl(fbi, LCCR2) != fbi->reg_lccr2) ||\r\n(lcd_readl(fbi, LCCR3) != fbi->reg_lccr3) ||\r\n(lcd_readl(fbi, LCCR4) != fbi->reg_lccr4) ||\r\n(lcd_readl(fbi, FDADR0) != fbi->fdadr[0]) ||\r\n((fbi->lccr0 & LCCR0_SDS) &&\r\n(lcd_readl(fbi, FDADR1) != fbi->fdadr[1])))\r\npxafb_schedule_work(fbi, C_REENABLE);\r\nreturn 0;\r\n}\r\nstatic inline void __pxafb_backlight_power(struct pxafb_info *fbi, int on)\r\n{\r\npr_debug("pxafb: backlight o%s\n", on ? "n" : "ff");\r\nif (fbi->backlight_power)\r\nfbi->backlight_power(on);\r\n}\r\nstatic inline void __pxafb_lcd_power(struct pxafb_info *fbi, int on)\r\n{\r\npr_debug("pxafb: LCD power o%s\n", on ? "n" : "ff");\r\nif (fbi->lcd_power)\r\nfbi->lcd_power(on, &fbi->fb.var);\r\n}\r\nstatic void pxafb_enable_controller(struct pxafb_info *fbi)\r\n{\r\npr_debug("pxafb: Enabling LCD controller\n");\r\npr_debug("fdadr0 0x%08x\n", (unsigned int) fbi->fdadr[0]);\r\npr_debug("fdadr1 0x%08x\n", (unsigned int) fbi->fdadr[1]);\r\npr_debug("reg_lccr0 0x%08x\n", (unsigned int) fbi->reg_lccr0);\r\npr_debug("reg_lccr1 0x%08x\n", (unsigned int) fbi->reg_lccr1);\r\npr_debug("reg_lccr2 0x%08x\n", (unsigned int) fbi->reg_lccr2);\r\npr_debug("reg_lccr3 0x%08x\n", (unsigned int) fbi->reg_lccr3);\r\nclk_prepare_enable(fbi->clk);\r\nif (fbi->lccr0 & LCCR0_LCDT)\r\nreturn;\r\nlcd_writel(fbi, LCCR4, fbi->reg_lccr4);\r\nlcd_writel(fbi, LCCR3, fbi->reg_lccr3);\r\nlcd_writel(fbi, LCCR2, fbi->reg_lccr2);\r\nlcd_writel(fbi, LCCR1, fbi->reg_lccr1);\r\nlcd_writel(fbi, LCCR0, fbi->reg_lccr0 & ~LCCR0_ENB);\r\nlcd_writel(fbi, FDADR0, fbi->fdadr[0]);\r\nif (fbi->lccr0 & LCCR0_SDS)\r\nlcd_writel(fbi, FDADR1, fbi->fdadr[1]);\r\nlcd_writel(fbi, LCCR0, fbi->reg_lccr0 | LCCR0_ENB);\r\n}\r\nstatic void pxafb_disable_controller(struct pxafb_info *fbi)\r\n{\r\nuint32_t lccr0;\r\n#ifdef CONFIG_FB_PXA_SMARTPANEL\r\nif (fbi->lccr0 & LCCR0_LCDT) {\r\nwait_for_completion_timeout(&fbi->refresh_done,\r\nmsecs_to_jiffies(200));\r\nreturn;\r\n}\r\n#endif\r\nlcd_writel(fbi, LCSR, 0xffffffff);\r\nlccr0 = lcd_readl(fbi, LCCR0) & ~LCCR0_LDM;\r\nlcd_writel(fbi, LCCR0, lccr0);\r\nlcd_writel(fbi, LCCR0, lccr0 | LCCR0_DIS);\r\nwait_for_completion_timeout(&fbi->disable_done, msecs_to_jiffies(200));\r\nclk_disable_unprepare(fbi->clk);\r\n}\r\nstatic irqreturn_t pxafb_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct pxafb_info *fbi = dev_id;\r\nunsigned int lccr0, lcsr;\r\nlcsr = lcd_readl(fbi, LCSR);\r\nif (lcsr & LCSR_LDD) {\r\nlccr0 = lcd_readl(fbi, LCCR0);\r\nlcd_writel(fbi, LCCR0, lccr0 | LCCR0_LDM);\r\ncomplete(&fbi->disable_done);\r\n}\r\n#ifdef CONFIG_FB_PXA_SMARTPANEL\r\nif (lcsr & LCSR_CMD_INT)\r\ncomplete(&fbi->command_done);\r\n#endif\r\nlcd_writel(fbi, LCSR, lcsr);\r\n#ifdef CONFIG_FB_PXA_OVERLAY\r\n{\r\nunsigned int lcsr1 = lcd_readl(fbi, LCSR1);\r\nif (lcsr1 & LCSR1_BS(1))\r\ncomplete(&fbi->overlay[0].branch_done);\r\nif (lcsr1 & LCSR1_BS(2))\r\ncomplete(&fbi->overlay[1].branch_done);\r\nlcd_writel(fbi, LCSR1, lcsr1);\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void set_ctrlr_state(struct pxafb_info *fbi, u_int state)\r\n{\r\nu_int old_state;\r\nmutex_lock(&fbi->ctrlr_lock);\r\nold_state = fbi->state;\r\nif (old_state == C_STARTUP && state == C_REENABLE)\r\nstate = C_ENABLE;\r\nswitch (state) {\r\ncase C_DISABLE_CLKCHANGE:\r\nif (old_state != C_DISABLE && old_state != C_DISABLE_PM) {\r\nfbi->state = state;\r\npxafb_disable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_DISABLE_PM:\r\ncase C_DISABLE:\r\nif (old_state != C_DISABLE) {\r\nfbi->state = state;\r\n__pxafb_backlight_power(fbi, 0);\r\n__pxafb_lcd_power(fbi, 0);\r\nif (old_state != C_DISABLE_CLKCHANGE)\r\npxafb_disable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_ENABLE_CLKCHANGE:\r\nif (old_state == C_DISABLE_CLKCHANGE) {\r\nfbi->state = C_ENABLE;\r\npxafb_enable_controller(fbi);\r\n}\r\nbreak;\r\ncase C_REENABLE:\r\nif (old_state == C_ENABLE) {\r\n__pxafb_lcd_power(fbi, 0);\r\npxafb_disable_controller(fbi);\r\npxafb_enable_controller(fbi);\r\n__pxafb_lcd_power(fbi, 1);\r\n}\r\nbreak;\r\ncase C_ENABLE_PM:\r\nif (old_state != C_DISABLE_PM)\r\nbreak;\r\ncase C_ENABLE:\r\nif (old_state != C_ENABLE) {\r\nfbi->state = C_ENABLE;\r\npxafb_enable_controller(fbi);\r\n__pxafb_lcd_power(fbi, 1);\r\n__pxafb_backlight_power(fbi, 1);\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&fbi->ctrlr_lock);\r\n}\r\nstatic void pxafb_task(struct work_struct *work)\r\n{\r\nstruct pxafb_info *fbi =\r\ncontainer_of(work, struct pxafb_info, task);\r\nu_int state = xchg(&fbi->task_state, -1);\r\nset_ctrlr_state(fbi, state);\r\n}\r\nstatic int\r\npxafb_freq_transition(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct pxafb_info *fbi = TO_INF(nb, freq_transition);\r\nu_int pcd;\r\nswitch (val) {\r\ncase CPUFREQ_PRECHANGE:\r\n#ifdef CONFIG_FB_PXA_OVERLAY\r\nif (!(fbi->overlay[0].usage || fbi->overlay[1].usage))\r\n#endif\r\nset_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);\r\nbreak;\r\ncase CPUFREQ_POSTCHANGE:\r\npcd = get_pcd(fbi, fbi->fb.var.pixclock);\r\nset_hsync_time(fbi, pcd);\r\nfbi->reg_lccr3 = (fbi->reg_lccr3 & ~0xff) |\r\nLCCR3_PixClkDiv(pcd);\r\nset_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npxafb_freq_policy(struct notifier_block *nb, unsigned long val, void *data)\r\n{\r\nstruct pxafb_info *fbi = TO_INF(nb, freq_policy);\r\nstruct fb_var_screeninfo *var = &fbi->fb.var;\r\nstruct cpufreq_policy *policy = data;\r\nswitch (val) {\r\ncase CPUFREQ_ADJUST:\r\npr_debug("min dma period: %d ps, "\r\n"new clock %d kHz\n", pxafb_display_dma_period(var),\r\npolicy->max);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxafb_suspend(struct device *dev)\r\n{\r\nstruct pxafb_info *fbi = dev_get_drvdata(dev);\r\nset_ctrlr_state(fbi, C_DISABLE_PM);\r\nreturn 0;\r\n}\r\nstatic int pxafb_resume(struct device *dev)\r\n{\r\nstruct pxafb_info *fbi = dev_get_drvdata(dev);\r\nset_ctrlr_state(fbi, C_ENABLE_PM);\r\nreturn 0;\r\n}\r\nstatic int pxafb_init_video_memory(struct pxafb_info *fbi)\r\n{\r\nint size = PAGE_ALIGN(fbi->video_mem_size);\r\nfbi->video_mem = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\r\nif (fbi->video_mem == NULL)\r\nreturn -ENOMEM;\r\nfbi->video_mem_phys = virt_to_phys(fbi->video_mem);\r\nfbi->video_mem_size = size;\r\nfbi->fb.fix.smem_start = fbi->video_mem_phys;\r\nfbi->fb.fix.smem_len = fbi->video_mem_size;\r\nfbi->fb.screen_base = fbi->video_mem;\r\nreturn fbi->video_mem ? 0 : -ENOMEM;\r\n}\r\nstatic void pxafb_decode_mach_info(struct pxafb_info *fbi,\r\nstruct pxafb_mach_info *inf)\r\n{\r\nunsigned int lcd_conn = inf->lcd_conn;\r\nstruct pxafb_mode_info *m;\r\nint i;\r\nfbi->cmap_inverse = inf->cmap_inverse;\r\nfbi->cmap_static = inf->cmap_static;\r\nfbi->lccr4 = inf->lccr4;\r\nswitch (lcd_conn & LCD_TYPE_MASK) {\r\ncase LCD_TYPE_MONO_STN:\r\nfbi->lccr0 = LCCR0_CMS;\r\nbreak;\r\ncase LCD_TYPE_MONO_DSTN:\r\nfbi->lccr0 = LCCR0_CMS | LCCR0_SDS;\r\nbreak;\r\ncase LCD_TYPE_COLOR_STN:\r\nfbi->lccr0 = 0;\r\nbreak;\r\ncase LCD_TYPE_COLOR_DSTN:\r\nfbi->lccr0 = LCCR0_SDS;\r\nbreak;\r\ncase LCD_TYPE_COLOR_TFT:\r\nfbi->lccr0 = LCCR0_PAS;\r\nbreak;\r\ncase LCD_TYPE_SMART_PANEL:\r\nfbi->lccr0 = LCCR0_LCDT | LCCR0_PAS;\r\nbreak;\r\ndefault:\r\nfbi->lccr0 = inf->lccr0;\r\nfbi->lccr3 = inf->lccr3;\r\ngoto decode_mode;\r\n}\r\nif (lcd_conn == LCD_MONO_STN_8BPP)\r\nfbi->lccr0 |= LCCR0_DPD;\r\nfbi->lccr0 |= (lcd_conn & LCD_ALTERNATE_MAPPING) ? LCCR0_LDDALT : 0;\r\nfbi->lccr3 = LCCR3_Acb((inf->lcd_conn >> 10) & 0xff);\r\nfbi->lccr3 |= (lcd_conn & LCD_BIAS_ACTIVE_LOW) ? LCCR3_OEP : 0;\r\nfbi->lccr3 |= (lcd_conn & LCD_PCLK_EDGE_FALL) ? LCCR3_PCP : 0;\r\ndecode_mode:\r\npxafb_setmode(&fbi->fb.var, &inf->modes[0]);\r\nfor (i = 0, m = &inf->modes[0]; i < inf->num_modes; i++, m++)\r\nfbi->video_mem_size = max_t(size_t, fbi->video_mem_size,\r\nm->xres * m->yres * m->bpp / 8);\r\nif (inf->video_mem_size > fbi->video_mem_size)\r\nfbi->video_mem_size = inf->video_mem_size;\r\nif (video_mem_size > fbi->video_mem_size)\r\nfbi->video_mem_size = video_mem_size;\r\n}\r\nstatic struct pxafb_info *pxafb_init_fbinfo(struct device *dev,\r\nstruct pxafb_mach_info *inf)\r\n{\r\nstruct pxafb_info *fbi;\r\nvoid *addr;\r\nfbi = kmalloc(sizeof(struct pxafb_info) + sizeof(u32) * 16, GFP_KERNEL);\r\nif (!fbi)\r\nreturn NULL;\r\nmemset(fbi, 0, sizeof(struct pxafb_info));\r\nfbi->dev = dev;\r\nfbi->inf = inf;\r\nfbi->clk = clk_get(dev, NULL);\r\nif (IS_ERR(fbi->clk)) {\r\nkfree(fbi);\r\nreturn NULL;\r\n}\r\nstrcpy(fbi->fb.fix.id, PXA_NAME);\r\nfbi->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbi->fb.fix.type_aux = 0;\r\nfbi->fb.fix.xpanstep = 0;\r\nfbi->fb.fix.ypanstep = 1;\r\nfbi->fb.fix.ywrapstep = 0;\r\nfbi->fb.fix.accel = FB_ACCEL_NONE;\r\nfbi->fb.var.nonstd = 0;\r\nfbi->fb.var.activate = FB_ACTIVATE_NOW;\r\nfbi->fb.var.height = -1;\r\nfbi->fb.var.width = -1;\r\nfbi->fb.var.accel_flags = FB_ACCELF_TEXT;\r\nfbi->fb.var.vmode = FB_VMODE_NONINTERLACED;\r\nfbi->fb.fbops = &pxafb_ops;\r\nfbi->fb.flags = FBINFO_DEFAULT;\r\nfbi->fb.node = -1;\r\naddr = fbi;\r\naddr = addr + sizeof(struct pxafb_info);\r\nfbi->fb.pseudo_palette = addr;\r\nfbi->state = C_STARTUP;\r\nfbi->task_state = (u_char)-1;\r\npxafb_decode_mach_info(fbi, inf);\r\n#ifdef CONFIG_FB_PXA_OVERLAY\r\nif (pxafb_overlay_supported())\r\nfbi->lccr0 |= LCCR0_OUC;\r\n#endif\r\ninit_waitqueue_head(&fbi->ctrlr_wait);\r\nINIT_WORK(&fbi->task, pxafb_task);\r\nmutex_init(&fbi->ctrlr_lock);\r\ninit_completion(&fbi->disable_done);\r\nreturn fbi;\r\n}\r\nstatic int parse_opt_mode(struct device *dev, const char *this_opt,\r\nstruct pxafb_mach_info *inf)\r\n{\r\nconst char *name = this_opt+5;\r\nunsigned int namelen = strlen(name);\r\nint res_specified = 0, bpp_specified = 0;\r\nunsigned int xres = 0, yres = 0, bpp = 0;\r\nint yres_specified = 0;\r\nint i;\r\nfor (i = namelen-1; i >= 0; i--) {\r\nswitch (name[i]) {\r\ncase '-':\r\nnamelen = i;\r\nif (!bpp_specified && !yres_specified) {\r\nbpp = simple_strtoul(&name[i+1], NULL, 0);\r\nbpp_specified = 1;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase 'x':\r\nif (!yres_specified) {\r\nyres = simple_strtoul(&name[i+1], NULL, 0);\r\nyres_specified = 1;\r\n} else\r\ngoto done;\r\nbreak;\r\ncase '0' ... '9':\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\n}\r\nif (i < 0 && yres_specified) {\r\nxres = simple_strtoul(name, NULL, 0);\r\nres_specified = 1;\r\n}\r\ndone:\r\nif (res_specified) {\r\ndev_info(dev, "overriding resolution: %dx%d\n", xres, yres);\r\ninf->modes[0].xres = xres; inf->modes[0].yres = yres;\r\n}\r\nif (bpp_specified)\r\nswitch (bpp) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\ncase 16:\r\ninf->modes[0].bpp = bpp;\r\ndev_info(dev, "overriding bit depth: %d\n", bpp);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Depth %d is not valid\n", bpp);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_opt(struct device *dev, char *this_opt,\r\nstruct pxafb_mach_info *inf)\r\n{\r\nstruct pxafb_mode_info *mode = &inf->modes[0];\r\nchar s[64];\r\ns[0] = '\0';\r\nif (!strncmp(this_opt, "vmem:", 5)) {\r\nvideo_mem_size = memparse(this_opt + 5, NULL);\r\n} else if (!strncmp(this_opt, "mode:", 5)) {\r\nreturn parse_opt_mode(dev, this_opt, inf);\r\n} else if (!strncmp(this_opt, "pixclock:", 9)) {\r\nmode->pixclock = simple_strtoul(this_opt+9, NULL, 0);\r\nsprintf(s, "pixclock: %ld\n", mode->pixclock);\r\n} else if (!strncmp(this_opt, "left:", 5)) {\r\nmode->left_margin = simple_strtoul(this_opt+5, NULL, 0);\r\nsprintf(s, "left: %u\n", mode->left_margin);\r\n} else if (!strncmp(this_opt, "right:", 6)) {\r\nmode->right_margin = simple_strtoul(this_opt+6, NULL, 0);\r\nsprintf(s, "right: %u\n", mode->right_margin);\r\n} else if (!strncmp(this_opt, "upper:", 6)) {\r\nmode->upper_margin = simple_strtoul(this_opt+6, NULL, 0);\r\nsprintf(s, "upper: %u\n", mode->upper_margin);\r\n} else if (!strncmp(this_opt, "lower:", 6)) {\r\nmode->lower_margin = simple_strtoul(this_opt+6, NULL, 0);\r\nsprintf(s, "lower: %u\n", mode->lower_margin);\r\n} else if (!strncmp(this_opt, "hsynclen:", 9)) {\r\nmode->hsync_len = simple_strtoul(this_opt+9, NULL, 0);\r\nsprintf(s, "hsynclen: %u\n", mode->hsync_len);\r\n} else if (!strncmp(this_opt, "vsynclen:", 9)) {\r\nmode->vsync_len = simple_strtoul(this_opt+9, NULL, 0);\r\nsprintf(s, "vsynclen: %u\n", mode->vsync_len);\r\n} else if (!strncmp(this_opt, "hsync:", 6)) {\r\nif (simple_strtoul(this_opt+6, NULL, 0) == 0) {\r\nsprintf(s, "hsync: Active Low\n");\r\nmode->sync &= ~FB_SYNC_HOR_HIGH_ACT;\r\n} else {\r\nsprintf(s, "hsync: Active High\n");\r\nmode->sync |= FB_SYNC_HOR_HIGH_ACT;\r\n}\r\n} else if (!strncmp(this_opt, "vsync:", 6)) {\r\nif (simple_strtoul(this_opt+6, NULL, 0) == 0) {\r\nsprintf(s, "vsync: Active Low\n");\r\nmode->sync &= ~FB_SYNC_VERT_HIGH_ACT;\r\n} else {\r\nsprintf(s, "vsync: Active High\n");\r\nmode->sync |= FB_SYNC_VERT_HIGH_ACT;\r\n}\r\n} else if (!strncmp(this_opt, "dpc:", 4)) {\r\nif (simple_strtoul(this_opt+4, NULL, 0) == 0) {\r\nsprintf(s, "double pixel clock: false\n");\r\ninf->lccr3 &= ~LCCR3_DPC;\r\n} else {\r\nsprintf(s, "double pixel clock: true\n");\r\ninf->lccr3 |= LCCR3_DPC;\r\n}\r\n} else if (!strncmp(this_opt, "outputen:", 9)) {\r\nif (simple_strtoul(this_opt+9, NULL, 0) == 0) {\r\nsprintf(s, "output enable: active low\n");\r\ninf->lccr3 = (inf->lccr3 & ~LCCR3_OEP) | LCCR3_OutEnL;\r\n} else {\r\nsprintf(s, "output enable: active high\n");\r\ninf->lccr3 = (inf->lccr3 & ~LCCR3_OEP) | LCCR3_OutEnH;\r\n}\r\n} else if (!strncmp(this_opt, "pixclockpol:", 12)) {\r\nif (simple_strtoul(this_opt+12, NULL, 0) == 0) {\r\nsprintf(s, "pixel clock polarity: falling edge\n");\r\ninf->lccr3 = (inf->lccr3 & ~LCCR3_PCP) | LCCR3_PixFlEdg;\r\n} else {\r\nsprintf(s, "pixel clock polarity: rising edge\n");\r\ninf->lccr3 = (inf->lccr3 & ~LCCR3_PCP) | LCCR3_PixRsEdg;\r\n}\r\n} else if (!strncmp(this_opt, "color", 5)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_CMS) | LCCR0_Color;\r\n} else if (!strncmp(this_opt, "mono", 4)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_CMS) | LCCR0_Mono;\r\n} else if (!strncmp(this_opt, "active", 6)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_PAS) | LCCR0_Act;\r\n} else if (!strncmp(this_opt, "passive", 7)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_PAS) | LCCR0_Pas;\r\n} else if (!strncmp(this_opt, "single", 6)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_SDS) | LCCR0_Sngl;\r\n} else if (!strncmp(this_opt, "dual", 4)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_SDS) | LCCR0_Dual;\r\n} else if (!strncmp(this_opt, "4pix", 4)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_DPD) | LCCR0_4PixMono;\r\n} else if (!strncmp(this_opt, "8pix", 4)) {\r\ninf->lccr0 = (inf->lccr0 & ~LCCR0_DPD) | LCCR0_8PixMono;\r\n} else {\r\ndev_err(dev, "unknown option: %s\n", this_opt);\r\nreturn -EINVAL;\r\n}\r\nif (s[0] != '\0')\r\ndev_info(dev, "override %s", s);\r\nreturn 0;\r\n}\r\nstatic int pxafb_parse_options(struct device *dev, char *options,\r\nstruct pxafb_mach_info *inf)\r\n{\r\nchar *this_opt;\r\nint ret;\r\nif (!options || !*options)\r\nreturn 0;\r\ndev_dbg(dev, "options are \"%s\"\n", options ? options : "null");\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nret = parse_opt(dev, this_opt, inf);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pxafb_setup_options(void)\r\n{\r\nchar *options = NULL;\r\nif (fb_get_options("pxafb", &options))\r\nreturn -ENODEV;\r\nif (options)\r\nstrlcpy(g_options, options, sizeof(g_options));\r\nreturn 0;\r\n}\r\nstatic void pxafb_check_options(struct device *dev, struct pxafb_mach_info *inf)\r\n{\r\nif (inf->lcd_conn)\r\nreturn;\r\nif (inf->lccr0 & LCCR0_INVALID_CONFIG_MASK)\r\ndev_warn(dev, "machine LCCR0 setting contains "\r\n"illegal bits: %08x\n",\r\ninf->lccr0 & LCCR0_INVALID_CONFIG_MASK);\r\nif (inf->lccr3 & LCCR3_INVALID_CONFIG_MASK)\r\ndev_warn(dev, "machine LCCR3 setting contains "\r\n"illegal bits: %08x\n",\r\ninf->lccr3 & LCCR3_INVALID_CONFIG_MASK);\r\nif (inf->lccr0 & LCCR0_DPD &&\r\n((inf->lccr0 & LCCR0_PAS) != LCCR0_Pas ||\r\n(inf->lccr0 & LCCR0_SDS) != LCCR0_Sngl ||\r\n(inf->lccr0 & LCCR0_CMS) != LCCR0_Mono))\r\ndev_warn(dev, "Double Pixel Data (DPD) mode is "\r\n"only valid in passive mono"\r\n" single panel mode\n");\r\nif ((inf->lccr0 & LCCR0_PAS) == LCCR0_Act &&\r\n(inf->lccr0 & LCCR0_SDS) == LCCR0_Dual)\r\ndev_warn(dev, "Dual panel only valid in passive mode\n");\r\nif ((inf->lccr0 & LCCR0_PAS) == LCCR0_Pas &&\r\n(inf->modes->upper_margin || inf->modes->lower_margin))\r\ndev_warn(dev, "Upper and lower margins must be 0 in "\r\n"passive mode\n");\r\n}\r\nstatic int of_get_pxafb_display(struct device *dev, struct device_node *disp,\r\nstruct pxafb_mach_info *info, u32 bus_width)\r\n{\r\nstruct display_timings *timings;\r\nstruct videomode vm;\r\nint i, ret = -EINVAL;\r\nconst char *s;\r\nret = of_property_read_string(disp, "lcd-type", &s);\r\nif (ret)\r\ns = "color-tft";\r\nfor (i = 0; lcd_types[i]; i++)\r\nif (!strcmp(s, lcd_types[i]))\r\nbreak;\r\nif (!i || !lcd_types[i]) {\r\ndev_err(dev, "lcd-type %s is unknown\n", s);\r\nreturn -EINVAL;\r\n}\r\ninfo->lcd_conn |= LCD_CONN_TYPE(i);\r\ninfo->lcd_conn |= LCD_CONN_WIDTH(bus_width);\r\ntimings = of_get_display_timings(disp);\r\nif (!timings)\r\nreturn -EINVAL;\r\nret = -ENOMEM;\r\ninfo->modes = kmalloc_array(timings->num_timings,\r\nsizeof(info->modes[0]), GFP_KERNEL);\r\nif (!info->modes)\r\ngoto out;\r\ninfo->num_modes = timings->num_timings;\r\nfor (i = 0; i < timings->num_timings; i++) {\r\nret = videomode_from_timings(timings, &vm, i);\r\nif (ret) {\r\ndev_err(dev, "videomode_from_timings %d failed: %d\n",\r\ni, ret);\r\ngoto out;\r\n}\r\nif (vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)\r\ninfo->lcd_conn |= LCD_PCLK_EDGE_RISE;\r\nif (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)\r\ninfo->lcd_conn |= LCD_PCLK_EDGE_FALL;\r\nif (vm.flags & DISPLAY_FLAGS_DE_HIGH)\r\ninfo->lcd_conn |= LCD_BIAS_ACTIVE_HIGH;\r\nif (vm.flags & DISPLAY_FLAGS_DE_LOW)\r\ninfo->lcd_conn |= LCD_BIAS_ACTIVE_LOW;\r\nif (vm.flags & DISPLAY_FLAGS_HSYNC_HIGH)\r\ninfo->modes[i].sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (vm.flags & DISPLAY_FLAGS_VSYNC_HIGH)\r\ninfo->modes[i].sync |= FB_SYNC_VERT_HIGH_ACT;\r\ninfo->modes[i].pixclock = 1000000000UL / (vm.pixelclock / 1000);\r\ninfo->modes[i].xres = vm.hactive;\r\ninfo->modes[i].yres = vm.vactive;\r\ninfo->modes[i].hsync_len = vm.hsync_len;\r\ninfo->modes[i].left_margin = vm.hback_porch;\r\ninfo->modes[i].right_margin = vm.hfront_porch;\r\ninfo->modes[i].vsync_len = vm.vsync_len;\r\ninfo->modes[i].upper_margin = vm.vback_porch;\r\ninfo->modes[i].lower_margin = vm.vfront_porch;\r\n}\r\nret = 0;\r\nout:\r\ndisplay_timings_release(timings);\r\nreturn ret;\r\n}\r\nstatic int of_get_pxafb_mode_info(struct device *dev,\r\nstruct pxafb_mach_info *info)\r\n{\r\nstruct device_node *display, *np;\r\nu32 bus_width;\r\nint ret, i;\r\nnp = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (!np) {\r\ndev_err(dev, "could not find endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(np, "bus-width", &bus_width);\r\nif (ret) {\r\ndev_err(dev, "no bus-width specified: %d\n", ret);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\ndisplay = of_graph_get_remote_port_parent(np);\r\nof_node_put(np);\r\nif (!display) {\r\ndev_err(dev, "no display defined\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_get_pxafb_display(dev, display, info, bus_width);\r\nof_node_put(display);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < info->num_modes; i++)\r\ninfo->modes[i].bpp = bus_width;\r\nreturn 0;\r\n}\r\nstatic struct pxafb_mach_info *of_pxafb_of_mach_info(struct device *dev)\r\n{\r\nint ret;\r\nstruct pxafb_mach_info *info;\r\nif (!dev->of_node)\r\nreturn NULL;\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = of_get_pxafb_mode_info(dev, info);\r\nif (ret) {\r\nkfree(info->modes);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn info;\r\n}\r\nstatic struct pxafb_mach_info *of_pxafb_of_mach_info(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int pxafb_probe(struct platform_device *dev)\r\n{\r\nstruct pxafb_info *fbi;\r\nstruct pxafb_mach_info *inf, *pdata;\r\nstruct resource *r;\r\nint i, irq, ret;\r\ndev_dbg(&dev->dev, "pxafb_probe\n");\r\nret = -ENOMEM;\r\npdata = dev_get_platdata(&dev->dev);\r\ninf = devm_kmalloc(&dev->dev, sizeof(*inf), GFP_KERNEL);\r\nif (!inf)\r\ngoto failed;\r\nif (pdata) {\r\n*inf = *pdata;\r\ninf->modes =\r\ndevm_kmalloc_array(&dev->dev, pdata->num_modes,\r\nsizeof(inf->modes[0]), GFP_KERNEL);\r\nif (!inf->modes)\r\ngoto failed;\r\nfor (i = 0; i < inf->num_modes; i++)\r\ninf->modes[i] = pdata->modes[i];\r\n}\r\nif (!pdata)\r\ninf = of_pxafb_of_mach_info(&dev->dev);\r\nif (IS_ERR_OR_NULL(inf))\r\ngoto failed;\r\nret = pxafb_parse_options(&dev->dev, g_options, inf);\r\nif (ret < 0)\r\ngoto failed;\r\npxafb_check_options(&dev->dev, inf);\r\ndev_dbg(&dev->dev, "got a %dx%dx%d LCD\n",\r\ninf->modes->xres,\r\ninf->modes->yres,\r\ninf->modes->bpp);\r\nif (inf->modes->xres == 0 ||\r\ninf->modes->yres == 0 ||\r\ninf->modes->bpp == 0) {\r\ndev_err(&dev->dev, "Invalid resolution or bit depth\n");\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nfbi = pxafb_init_fbinfo(&dev->dev, inf);\r\nif (!fbi) {\r\ndev_err(&dev->dev, "Failed to initialize framebuffer device\n");\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (cpu_is_pxa3xx() && inf->acceleration_enabled)\r\nfbi->fb.fix.accel = FB_ACCEL_PXA3XX;\r\nfbi->backlight_power = inf->pxafb_backlight_power;\r\nfbi->lcd_power = inf->pxafb_lcd_power;\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&dev->dev, "no I/O memory resource defined\n");\r\nret = -ENODEV;\r\ngoto failed_fbi;\r\n}\r\nr = request_mem_region(r->start, resource_size(r), dev->name);\r\nif (r == NULL) {\r\ndev_err(&dev->dev, "failed to request I/O memory\n");\r\nret = -EBUSY;\r\ngoto failed_fbi;\r\n}\r\nfbi->mmio_base = ioremap(r->start, resource_size(r));\r\nif (fbi->mmio_base == NULL) {\r\ndev_err(&dev->dev, "failed to map I/O memory\n");\r\nret = -EBUSY;\r\ngoto failed_free_res;\r\n}\r\nfbi->dma_buff_size = PAGE_ALIGN(sizeof(struct pxafb_dma_buff));\r\nfbi->dma_buff = dma_alloc_coherent(fbi->dev, fbi->dma_buff_size,\r\n&fbi->dma_buff_phys, GFP_KERNEL);\r\nif (fbi->dma_buff == NULL) {\r\ndev_err(&dev->dev, "failed to allocate memory for DMA\n");\r\nret = -ENOMEM;\r\ngoto failed_free_io;\r\n}\r\nret = pxafb_init_video_memory(fbi);\r\nif (ret) {\r\ndev_err(&dev->dev, "Failed to allocate video RAM: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto failed_free_dma;\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\ndev_err(&dev->dev, "no IRQ defined\n");\r\nret = -ENODEV;\r\ngoto failed_free_mem;\r\n}\r\nret = request_irq(irq, pxafb_handle_irq, 0, "LCD", fbi);\r\nif (ret) {\r\ndev_err(&dev->dev, "request_irq failed: %d\n", ret);\r\nret = -EBUSY;\r\ngoto failed_free_mem;\r\n}\r\nret = pxafb_smart_init(fbi);\r\nif (ret) {\r\ndev_err(&dev->dev, "failed to initialize smartpanel\n");\r\ngoto failed_free_irq;\r\n}\r\nret = pxafb_check_var(&fbi->fb.var, &fbi->fb);\r\nif (ret) {\r\ndev_err(&dev->dev, "failed to get suitable mode\n");\r\ngoto failed_free_irq;\r\n}\r\nret = pxafb_set_par(&fbi->fb);\r\nif (ret) {\r\ndev_err(&dev->dev, "Failed to set parameters\n");\r\ngoto failed_free_irq;\r\n}\r\nplatform_set_drvdata(dev, fbi);\r\nret = register_framebuffer(&fbi->fb);\r\nif (ret < 0) {\r\ndev_err(&dev->dev,\r\n"Failed to register framebuffer device: %d\n", ret);\r\ngoto failed_free_cmap;\r\n}\r\npxafb_overlay_init(fbi);\r\n#ifdef CONFIG_CPU_FREQ\r\nfbi->freq_transition.notifier_call = pxafb_freq_transition;\r\nfbi->freq_policy.notifier_call = pxafb_freq_policy;\r\ncpufreq_register_notifier(&fbi->freq_transition,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\ncpufreq_register_notifier(&fbi->freq_policy,\r\nCPUFREQ_POLICY_NOTIFIER);\r\n#endif\r\nset_ctrlr_state(fbi, C_ENABLE);\r\nreturn 0;\r\nfailed_free_cmap:\r\nif (fbi->fb.cmap.len)\r\nfb_dealloc_cmap(&fbi->fb.cmap);\r\nfailed_free_irq:\r\nfree_irq(irq, fbi);\r\nfailed_free_mem:\r\nfree_pages_exact(fbi->video_mem, fbi->video_mem_size);\r\nfailed_free_dma:\r\ndma_free_coherent(&dev->dev, fbi->dma_buff_size,\r\nfbi->dma_buff, fbi->dma_buff_phys);\r\nfailed_free_io:\r\niounmap(fbi->mmio_base);\r\nfailed_free_res:\r\nrelease_mem_region(r->start, resource_size(r));\r\nfailed_fbi:\r\nclk_put(fbi->clk);\r\nkfree(fbi);\r\nfailed:\r\nreturn ret;\r\n}\r\nstatic int pxafb_remove(struct platform_device *dev)\r\n{\r\nstruct pxafb_info *fbi = platform_get_drvdata(dev);\r\nstruct resource *r;\r\nint irq;\r\nstruct fb_info *info;\r\nif (!fbi)\r\nreturn 0;\r\ninfo = &fbi->fb;\r\npxafb_overlay_exit(fbi);\r\nunregister_framebuffer(info);\r\npxafb_disable_controller(fbi);\r\nif (fbi->fb.cmap.len)\r\nfb_dealloc_cmap(&fbi->fb.cmap);\r\nirq = platform_get_irq(dev, 0);\r\nfree_irq(irq, fbi);\r\nfree_pages_exact(fbi->video_mem, fbi->video_mem_size);\r\ndma_free_wc(&dev->dev, fbi->dma_buff_size, fbi->dma_buff,\r\nfbi->dma_buff_phys);\r\niounmap(fbi->mmio_base);\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(r->start, resource_size(r));\r\nclk_put(fbi->clk);\r\nkfree(fbi);\r\nreturn 0;\r\n}\r\nstatic int __init pxafb_init(void)\r\n{\r\nif (pxafb_setup_options())\r\nreturn -EINVAL;\r\nreturn platform_driver_register(&pxafb_driver);\r\n}\r\nstatic void __exit pxafb_exit(void)\r\n{\r\nplatform_driver_unregister(&pxafb_driver);\r\n}
