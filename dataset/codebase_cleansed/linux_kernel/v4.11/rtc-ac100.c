static unsigned long ac100_clkout_recalc_rate(struct clk_hw *hw,\r\nunsigned long prate)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nunsigned int reg, div;\r\nregmap_read(clk->regmap, clk->offset, &reg);\r\nif (prate != AC100_RTC_32K_RATE) {\r\ndiv = (reg >> AC100_CLKOUT_PRE_DIV_SHIFT) &\r\n((1 << AC100_CLKOUT_PRE_DIV_WIDTH) - 1);\r\nprate = divider_recalc_rate(hw, prate, div,\r\nac100_clkout_prediv, 0);\r\n}\r\ndiv = (reg >> AC100_CLKOUT_DIV_SHIFT) &\r\n(BIT(AC100_CLKOUT_DIV_WIDTH) - 1);\r\nreturn divider_recalc_rate(hw, prate, div, NULL,\r\nCLK_DIVIDER_POWER_OF_TWO);\r\n}\r\nstatic long ac100_clkout_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long prate)\r\n{\r\nunsigned long best_rate = 0, tmp_rate, tmp_prate;\r\nint i;\r\nif (prate == AC100_RTC_32K_RATE)\r\nreturn divider_round_rate(hw, rate, &prate, NULL,\r\nAC100_CLKOUT_DIV_WIDTH,\r\nCLK_DIVIDER_POWER_OF_TWO);\r\nfor (i = 0; ac100_clkout_prediv[i].div; i++) {\r\ntmp_prate = DIV_ROUND_UP(prate, ac100_clkout_prediv[i].val);\r\ntmp_rate = divider_round_rate(hw, rate, &tmp_prate, NULL,\r\nAC100_CLKOUT_DIV_WIDTH,\r\nCLK_DIVIDER_POWER_OF_TWO);\r\nif (tmp_rate > rate)\r\ncontinue;\r\nif (rate - tmp_rate < best_rate - tmp_rate)\r\nbest_rate = tmp_rate;\r\n}\r\nreturn best_rate;\r\n}\r\nstatic int ac100_clkout_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct clk_hw *best_parent;\r\nunsigned long best = 0;\r\nint i, num_parents = clk_hw_get_num_parents(hw);\r\nfor (i = 0; i < num_parents; i++) {\r\nstruct clk_hw *parent = clk_hw_get_parent_by_index(hw, i);\r\nunsigned long tmp, prate = clk_hw_get_rate(parent);\r\ntmp = ac100_clkout_round_rate(hw, req->rate, prate);\r\nif (tmp > req->rate)\r\ncontinue;\r\nif (req->rate - tmp < req->rate - best) {\r\nbest = tmp;\r\nbest_parent = parent;\r\n}\r\n}\r\nif (!best)\r\nreturn -EINVAL;\r\nreq->best_parent_hw = best_parent;\r\nreq->best_parent_rate = best;\r\nreq->rate = best;\r\nreturn 0;\r\n}\r\nstatic int ac100_clkout_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long prate)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nint div = 0, pre_div = 0;\r\ndo {\r\ndiv = divider_get_val(rate * ac100_clkout_prediv[pre_div].div,\r\nprate, NULL, AC100_CLKOUT_DIV_WIDTH,\r\nCLK_DIVIDER_POWER_OF_TWO);\r\nif (div >= 0)\r\nbreak;\r\n} while (prate != AC100_RTC_32K_RATE &&\r\nac100_clkout_prediv[++pre_div].div);\r\nif (div < 0)\r\nreturn div;\r\npre_div = ac100_clkout_prediv[pre_div].val;\r\nregmap_update_bits(clk->regmap, clk->offset,\r\n((1 << AC100_CLKOUT_DIV_WIDTH) - 1) << AC100_CLKOUT_DIV_SHIFT |\r\n((1 << AC100_CLKOUT_PRE_DIV_WIDTH) - 1) << AC100_CLKOUT_PRE_DIV_SHIFT,\r\n(div - 1) << AC100_CLKOUT_DIV_SHIFT |\r\n(pre_div - 1) << AC100_CLKOUT_PRE_DIV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int ac100_clkout_prepare(struct clk_hw *hw)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nreturn regmap_update_bits(clk->regmap, clk->offset, AC100_CLKOUT_EN,\r\nAC100_CLKOUT_EN);\r\n}\r\nstatic void ac100_clkout_unprepare(struct clk_hw *hw)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nregmap_update_bits(clk->regmap, clk->offset, AC100_CLKOUT_EN, 0);\r\n}\r\nstatic int ac100_clkout_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nunsigned int reg;\r\nregmap_read(clk->regmap, clk->offset, &reg);\r\nreturn reg & AC100_CLKOUT_EN;\r\n}\r\nstatic u8 ac100_clkout_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nunsigned int reg;\r\nregmap_read(clk->regmap, clk->offset, &reg);\r\nreturn (reg >> AC100_CLKOUT_MUX_SHIFT) & 0x1;\r\n}\r\nstatic int ac100_clkout_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct ac100_clkout *clk = to_ac100_clkout(hw);\r\nreturn regmap_update_bits(clk->regmap, clk->offset,\r\nBIT(AC100_CLKOUT_MUX_SHIFT),\r\nindex ? BIT(AC100_CLKOUT_MUX_SHIFT) : 0);\r\n}\r\nstatic int ac100_rtc_register_clks(struct ac100_rtc_dev *chip)\r\n{\r\nstruct device_node *np = chip->dev->of_node;\r\nconst char *parents[2] = {AC100_RTC_32K_NAME};\r\nint i, ret;\r\nchip->clk_data = devm_kzalloc(chip->dev, sizeof(*chip->clk_data) +\r\nsizeof(*chip->clk_data->hws) *\r\nAC100_CLKOUT_NUM,\r\nGFP_KERNEL);\r\nif (!chip->clk_data)\r\nreturn -ENOMEM;\r\nchip->rtc_32k_clk = clk_hw_register_fixed_rate(chip->dev,\r\nAC100_RTC_32K_NAME,\r\nNULL, 0,\r\nAC100_RTC_32K_RATE);\r\nif (IS_ERR(chip->rtc_32k_clk)) {\r\nret = PTR_ERR(chip->rtc_32k_clk);\r\ndev_err(chip->dev, "Failed to register RTC-32k clock: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nparents[1] = of_clk_get_parent_name(np, 0);\r\nif (!parents[1]) {\r\ndev_err(chip->dev, "Failed to get ADDA 4M clock\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < AC100_CLKOUT_NUM; i++) {\r\nstruct ac100_clkout *clk = &chip->clks[i];\r\nstruct clk_init_data init = {\r\n.name = ac100_clkout_names[i],\r\n.ops = &ac100_clkout_ops,\r\n.parent_names = parents,\r\n.num_parents = ARRAY_SIZE(parents),\r\n.flags = 0,\r\n};\r\nof_property_read_string_index(np, "clock-output-names",\r\ni, &init.name);\r\nclk->regmap = chip->regmap;\r\nclk->offset = AC100_CLKOUT_CTRL1 + i;\r\nclk->hw.init = &init;\r\nret = devm_clk_hw_register(chip->dev, &clk->hw);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to register clk '%s': %d\n",\r\ninit.name, ret);\r\ngoto err_unregister_rtc_32k;\r\n}\r\nchip->clk_data->hws[i] = &clk->hw;\r\n}\r\nchip->clk_data->num = i;\r\nret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, chip->clk_data);\r\nif (ret)\r\ngoto err_unregister_rtc_32k;\r\nreturn 0;\r\nerr_unregister_rtc_32k:\r\nclk_unregister_fixed_rate(chip->rtc_32k_clk->clk);\r\nreturn ret;\r\n}\r\nstatic void ac100_rtc_unregister_clks(struct ac100_rtc_dev *chip)\r\n{\r\nof_clk_del_provider(chip->dev->of_node);\r\nclk_unregister_fixed_rate(chip->rtc_32k_clk->clk);\r\n}\r\nstatic int ac100_rtc_get_time(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct regmap *regmap = chip->regmap;\r\nu16 reg[7];\r\nint ret;\r\nret = regmap_bulk_read(regmap, AC100_RTC_SEC, reg, 7);\r\nif (ret)\r\nreturn ret;\r\nrtc_tm->tm_sec = bcd2bin(reg[0] & AC100_RTC_SEC_MASK);\r\nrtc_tm->tm_min = bcd2bin(reg[1] & AC100_RTC_MIN_MASK);\r\nrtc_tm->tm_hour = bcd2bin(reg[2] & AC100_RTC_HOU_MASK);\r\nrtc_tm->tm_wday = bcd2bin(reg[3] & AC100_RTC_WEE_MASK);\r\nrtc_tm->tm_mday = bcd2bin(reg[4] & AC100_RTC_DAY_MASK);\r\nrtc_tm->tm_mon = bcd2bin(reg[5] & AC100_RTC_MON_MASK) - 1;\r\nrtc_tm->tm_year = bcd2bin(reg[6] & AC100_RTC_YEA_MASK) +\r\nAC100_YEAR_OFF;\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int ac100_rtc_set_time(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct regmap *regmap = chip->regmap;\r\nint year;\r\nu16 reg[8];\r\nyear = rtc_tm->tm_year - AC100_YEAR_OFF;\r\nif (year < 0 || year > (AC100_YEAR_MAX - 1900)) {\r\ndev_err(dev, "rtc only supports year in range %d - %d\n",\r\nAC100_YEAR_MIN, AC100_YEAR_MAX);\r\nreturn -EINVAL;\r\n}\r\nreg[0] = bin2bcd(rtc_tm->tm_sec) & AC100_RTC_SEC_MASK;\r\nreg[1] = bin2bcd(rtc_tm->tm_min) & AC100_RTC_MIN_MASK;\r\nreg[2] = bin2bcd(rtc_tm->tm_hour) & AC100_RTC_HOU_MASK;\r\nreg[3] = bin2bcd(rtc_tm->tm_wday) & AC100_RTC_WEE_MASK;\r\nreg[4] = bin2bcd(rtc_tm->tm_mday) & AC100_RTC_DAY_MASK;\r\nreg[5] = bin2bcd(rtc_tm->tm_mon + 1) & AC100_RTC_MON_MASK;\r\nreg[6] = bin2bcd(year) & AC100_RTC_YEA_MASK;\r\nreg[7] = AC100_RTC_UPD_TRIGGER;\r\nif (is_leap_year(year + AC100_YEAR_OFF + 1900))\r\nreg[6] |= AC100_RTC_YEA_LEAP;\r\nreturn regmap_bulk_write(regmap, AC100_RTC_SEC, reg, 8);\r\n}\r\nstatic int ac100_rtc_alarm_irq_enable(struct device *dev, unsigned int en)\r\n{\r\nstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct regmap *regmap = chip->regmap;\r\nunsigned int val;\r\nval = en ? AC100_ALM_INT_ENABLE : 0;\r\nreturn regmap_write(regmap, AC100_ALM_INT_ENA, val);\r\n}\r\nstatic int ac100_rtc_get_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct regmap *regmap = chip->regmap;\r\nstruct rtc_time *alrm_tm = &alrm->time;\r\nu16 reg[7];\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(regmap, AC100_ALM_INT_ENA, &val);\r\nif (ret)\r\nreturn ret;\r\nalrm->enabled = !!(val & AC100_ALM_INT_ENABLE);\r\nret = regmap_bulk_read(regmap, AC100_ALM_SEC, reg, 7);\r\nif (ret)\r\nreturn ret;\r\nalrm_tm->tm_sec = bcd2bin(reg[0] & AC100_ALM_SEC_MASK);\r\nalrm_tm->tm_min = bcd2bin(reg[1] & AC100_ALM_MIN_MASK);\r\nalrm_tm->tm_hour = bcd2bin(reg[2] & AC100_ALM_HOU_MASK);\r\nalrm_tm->tm_wday = bcd2bin(reg[3] & AC100_ALM_WEE_MASK);\r\nalrm_tm->tm_mday = bcd2bin(reg[4] & AC100_ALM_DAY_MASK);\r\nalrm_tm->tm_mon = bcd2bin(reg[5] & AC100_ALM_MON_MASK) - 1;\r\nalrm_tm->tm_year = bcd2bin(reg[6] & AC100_ALM_YEA_MASK) +\r\nAC100_YEAR_OFF;\r\nreturn 0;\r\n}\r\nstatic int ac100_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct ac100_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct regmap *regmap = chip->regmap;\r\nstruct rtc_time *alrm_tm = &alrm->time;\r\nu16 reg[8];\r\nint year;\r\nint ret;\r\nyear = alrm_tm->tm_year - AC100_YEAR_OFF;\r\nif (year < 0 || year > (AC100_YEAR_MAX - 1900)) {\r\ndev_err(dev, "alarm only supports year in range %d - %d\n",\r\nAC100_YEAR_MIN, AC100_YEAR_MAX);\r\nreturn -EINVAL;\r\n}\r\nreg[0] = (bin2bcd(alrm_tm->tm_sec) & AC100_ALM_SEC_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[1] = (bin2bcd(alrm_tm->tm_min) & AC100_ALM_MIN_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[2] = (bin2bcd(alrm_tm->tm_hour) & AC100_ALM_HOU_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[3] = bin2bcd(alrm_tm->tm_wday) & AC100_ALM_WEE_MASK;\r\nreg[4] = (bin2bcd(alrm_tm->tm_mday) & AC100_ALM_DAY_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[5] = (bin2bcd(alrm_tm->tm_mon + 1) & AC100_ALM_MON_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[6] = (bin2bcd(year) & AC100_ALM_YEA_MASK) |\r\nAC100_ALM_ENABLE_FLAG;\r\nreg[7] = AC100_ALM_UPD_TRIGGER;\r\nret = regmap_bulk_write(regmap, AC100_ALM_SEC, reg, 8);\r\nif (ret)\r\nreturn ret;\r\nreturn ac100_rtc_alarm_irq_enable(dev, alrm->enabled);\r\n}\r\nstatic irqreturn_t ac100_rtc_irq(int irq, void *data)\r\n{\r\nstruct ac100_rtc_dev *chip = data;\r\nstruct regmap *regmap = chip->regmap;\r\nunsigned int val = 0;\r\nint ret;\r\nmutex_lock(&chip->rtc->ops_lock);\r\nret = regmap_read(regmap, AC100_ALM_INT_STA, &val);\r\nif (ret)\r\ngoto out;\r\nif (val & AC100_ALM_INT_ENABLE) {\r\nrtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\r\nret = regmap_write(regmap, AC100_ALM_INT_STA, val);\r\nif (ret)\r\ngoto out;\r\nret = ac100_rtc_alarm_irq_enable(chip->dev, 0);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&chip->rtc->ops_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ac100_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);\r\nstruct ac100_rtc_dev *chip;\r\nint ret;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, chip);\r\nchip->dev = &pdev->dev;\r\nchip->regmap = ac100->regmap;\r\nchip->irq = platform_get_irq(pdev, 0);\r\nif (chip->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn chip->irq;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, chip->irq, NULL,\r\nac100_rtc_irq,\r\nIRQF_SHARED | IRQF_ONESHOT,\r\ndev_name(&pdev->dev), chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not request IRQ\n");\r\nreturn ret;\r\n}\r\nregmap_write_bits(chip->regmap, AC100_RTC_CTRL, AC100_RTC_CTRL_24HOUR,\r\nAC100_RTC_CTRL_24HOUR);\r\nregmap_write(chip->regmap, AC100_ALM_INT_ENA, 0);\r\nregmap_write(chip->regmap, AC100_ALM_INT_STA, AC100_ALM_INT_ENABLE);\r\nchip->rtc = devm_rtc_device_register(&pdev->dev, "rtc-ac100",\r\n&ac100_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(chip->rtc)) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\nreturn PTR_ERR(chip->rtc);\r\n}\r\nret = ac100_rtc_register_clks(chip);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&pdev->dev, "RTC enabled\n");\r\nreturn 0;\r\n}\r\nstatic int ac100_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct ac100_rtc_dev *chip = platform_get_drvdata(pdev);\r\nac100_rtc_unregister_clks(chip);\r\nreturn 0;\r\n}
