static int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "vivid");\r\nstrcpy(cap->card, "vivid");\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", dev->v4l2_dev.name);\r\ncap->capabilities = dev->vid_cap_caps | dev->vid_out_caps |\r\ndev->vbi_cap_caps | dev->vbi_out_caps |\r\ndev->radio_rx_caps | dev->radio_tx_caps |\r\ndev->sdr_cap_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *fh, const struct v4l2_hw_freq_seek *a)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_rx_s_hw_freq_seek(file, fh, a);\r\nreturn -ENOTTY;\r\n}\r\nstatic int vidioc_enum_freq_bands(struct file *file, void *fh, struct v4l2_frequency_band *band)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_rx_enum_freq_bands(file, fh, band);\r\nif (vdev->vfl_type == VFL_TYPE_SDR)\r\nreturn vivid_sdr_enum_freq_bands(file, fh, band);\r\nreturn -ENOTTY;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_rx_g_tuner(file, fh, vt);\r\nif (vdev->vfl_type == VFL_TYPE_SDR)\r\nreturn vivid_sdr_g_tuner(file, fh, vt);\r\nreturn vivid_video_g_tuner(file, fh, vt);\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_rx_s_tuner(file, fh, vt);\r\nif (vdev->vfl_type == VFL_TYPE_SDR)\r\nreturn vivid_sdr_s_tuner(file, fh, vt);\r\nreturn vivid_video_s_tuner(file, fh, vt);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *fh, struct v4l2_frequency *vf)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_g_frequency(file,\r\nvdev->vfl_dir == VFL_DIR_RX ?\r\n&dev->radio_rx_freq : &dev->radio_tx_freq, vf);\r\nif (vdev->vfl_type == VFL_TYPE_SDR)\r\nreturn vivid_sdr_g_frequency(file, fh, vf);\r\nreturn vivid_video_g_frequency(file, fh, vf);\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nreturn vivid_radio_s_frequency(file,\r\nvdev->vfl_dir == VFL_DIR_RX ?\r\n&dev->radio_rx_freq : &dev->radio_tx_freq, vf);\r\nif (vdev->vfl_type == VFL_TYPE_SDR)\r\nreturn vivid_sdr_s_frequency(file, fh, vf);\r\nreturn vivid_video_s_frequency(file, fh, vf);\r\n}\r\nstatic int vidioc_overlay(struct file *file, void *fh, unsigned i)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_overlay(file, fh, i);\r\nreturn vivid_vid_out_overlay(file, fh, i);\r\n}\r\nstatic int vidioc_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *a)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_g_fbuf(file, fh, a);\r\nreturn vivid_vid_out_g_fbuf(file, fh, a);\r\n}\r\nstatic int vidioc_s_fbuf(struct file *file, void *fh, const struct v4l2_framebuffer *a)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_s_fbuf(file, fh, a);\r\nreturn vivid_vid_out_s_fbuf(file, fh, a);\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id id)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_s_std(file, fh, id);\r\nreturn vivid_vid_out_s_std(file, fh, id);\r\n}\r\nstatic int vidioc_s_dv_timings(struct file *file, void *fh, struct v4l2_dv_timings *timings)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_s_dv_timings(file, fh, timings);\r\nreturn vivid_vid_out_s_dv_timings(file, fh, timings);\r\n}\r\nstatic int vidioc_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cc)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_cropcap(file, fh, cc);\r\nreturn vivid_vid_out_cropcap(file, fh, cc);\r\n}\r\nstatic int vidioc_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_g_selection(file, fh, sel);\r\nreturn vivid_vid_out_g_selection(file, fh, sel);\r\n}\r\nstatic int vidioc_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_s_selection(file, fh, sel);\r\nreturn vivid_vid_out_s_selection(file, fh, sel);\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_g_parm(file, fh, parm);\r\nreturn vivid_vid_out_g_parm(file, fh, parm);\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_vid_cap_s_parm(file, fh, parm);\r\nreturn vivid_vid_out_g_parm(file, fh, parm);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *fh)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nv4l2_ctrl_log_status(file, fh);\r\nif (vdev->vfl_dir == VFL_DIR_RX && vdev->vfl_type == VFL_TYPE_GRABBER)\r\ntpg_log_status(&dev->tpg);\r\nreturn 0;\r\n}\r\nstatic ssize_t vivid_radio_read(struct file *file, char __user *buf,\r\nsize_t size, loff_t *offset)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_TX)\r\nreturn -EINVAL;\r\nreturn vivid_radio_rx_read(file, buf, size, offset);\r\n}\r\nstatic ssize_t vivid_radio_write(struct file *file, const char __user *buf,\r\nsize_t size, loff_t *offset)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn -EINVAL;\r\nreturn vivid_radio_tx_write(file, buf, size, offset);\r\n}\r\nstatic unsigned int vivid_radio_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nreturn vivid_radio_rx_poll(file, wait);\r\nreturn vivid_radio_tx_poll(file, wait);\r\n}\r\nstatic bool vivid_is_in_use(struct video_device *vdev)\r\n{\r\nunsigned long flags;\r\nbool res;\r\nspin_lock_irqsave(&vdev->fh_lock, flags);\r\nres = !list_empty(&vdev->fh_list);\r\nspin_unlock_irqrestore(&vdev->fh_lock, flags);\r\nreturn res;\r\n}\r\nstatic bool vivid_is_last_user(struct vivid_dev *dev)\r\n{\r\nunsigned uses = vivid_is_in_use(&dev->vid_cap_dev) +\r\nvivid_is_in_use(&dev->vid_out_dev) +\r\nvivid_is_in_use(&dev->vbi_cap_dev) +\r\nvivid_is_in_use(&dev->vbi_out_dev) +\r\nvivid_is_in_use(&dev->sdr_cap_dev) +\r\nvivid_is_in_use(&dev->radio_rx_dev) +\r\nvivid_is_in_use(&dev->radio_tx_dev);\r\nreturn uses == 1;\r\n}\r\nstatic int vivid_fop_release(struct file *file)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nmutex_lock(&dev->mutex);\r\nif (!no_error_inj && v4l2_fh_is_singular_file(file) &&\r\n!video_is_registered(vdev) && vivid_is_last_user(dev)) {\r\nv4l2_info(&dev->v4l2_dev, "reconnect\n");\r\nset_bit(V4L2_FL_REGISTERED, &dev->vid_cap_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->vid_out_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->vbi_cap_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->vbi_out_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->sdr_cap_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->radio_rx_dev.flags);\r\nset_bit(V4L2_FL_REGISTERED, &dev->radio_tx_dev.flags);\r\n}\r\nmutex_unlock(&dev->mutex);\r\nif (file->private_data == dev->overlay_cap_owner)\r\ndev->overlay_cap_owner = NULL;\r\nif (file->private_data == dev->radio_rx_rds_owner) {\r\ndev->radio_rx_rds_last_block = 0;\r\ndev->radio_rx_rds_owner = NULL;\r\n}\r\nif (file->private_data == dev->radio_tx_rds_owner) {\r\ndev->radio_tx_rds_last_block = 0;\r\ndev->radio_tx_rds_owner = NULL;\r\n}\r\nif (vdev->queue)\r\nreturn vb2_fop_release(file);\r\nreturn v4l2_fh_release(file);\r\n}\r\nstatic void vivid_dev_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct vivid_dev *dev = container_of(v4l2_dev, struct vivid_dev, v4l2_dev);\r\nvivid_free_controls(dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nvfree(dev->scaled_line);\r\nvfree(dev->blended_line);\r\nvfree(dev->edid);\r\nvfree(dev->bitmap_cap);\r\nvfree(dev->bitmap_out);\r\ntpg_free(&dev->tpg);\r\nkfree(dev->query_dv_timings_qmenu);\r\nkfree(dev);\r\n}\r\nstatic int vivid_create_instance(struct platform_device *pdev, int inst)\r\n{\r\nstatic const struct v4l2_dv_timings def_dv_timings =\r\nV4L2_DV_BT_CEA_1280X720P60;\r\nunsigned in_type_counter[4] = { 0, 0, 0, 0 };\r\nunsigned out_type_counter[4] = { 0, 0, 0, 0 };\r\nint ccs_cap = ccs_cap_mode[inst];\r\nint ccs_out = ccs_out_mode[inst];\r\nbool has_tuner;\r\nbool has_modulator;\r\nstruct vivid_dev *dev;\r\nstruct video_device *vfd;\r\nstruct vb2_queue *q;\r\nunsigned node_type = node_types[inst];\r\nv4l2_std_id tvnorms_cap = 0, tvnorms_out = 0;\r\nint ret;\r\nint i;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->inst = inst;\r\nsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\r\n"%s-%03d", VIVID_MODULE_NAME, inst);\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret) {\r\nkfree(dev);\r\nreturn ret;\r\n}\r\ndev->v4l2_dev.release = vivid_dev_release;\r\ndev->multiplanar = multiplanar[inst] > 1;\r\nv4l2_info(&dev->v4l2_dev, "using %splanar format API\n",\r\ndev->multiplanar ? "multi" : "single ");\r\ndev->num_inputs = num_inputs[inst];\r\nif (dev->num_inputs < 1)\r\ndev->num_inputs = 1;\r\nif (dev->num_inputs >= MAX_INPUTS)\r\ndev->num_inputs = MAX_INPUTS;\r\nfor (i = 0; i < dev->num_inputs; i++) {\r\ndev->input_type[i] = (input_types[inst] >> (i * 2)) & 0x3;\r\ndev->input_name_counter[i] = in_type_counter[dev->input_type[i]]++;\r\n}\r\ndev->has_audio_inputs = in_type_counter[TV] && in_type_counter[SVID];\r\nif (in_type_counter[HDMI] == 16) {\r\nin_type_counter[HDMI]--;\r\ndev->num_inputs--;\r\n}\r\ndev->num_outputs = num_outputs[inst];\r\nif (dev->num_outputs < 1)\r\ndev->num_outputs = 1;\r\nif (dev->num_outputs >= MAX_OUTPUTS)\r\ndev->num_outputs = MAX_OUTPUTS;\r\nfor (i = 0; i < dev->num_outputs; i++) {\r\ndev->output_type[i] = ((output_types[inst] >> i) & 1) ? HDMI : SVID;\r\ndev->output_name_counter[i] = out_type_counter[dev->output_type[i]]++;\r\n}\r\ndev->has_audio_outputs = out_type_counter[SVID];\r\nif (out_type_counter[HDMI] == 16) {\r\nout_type_counter[HDMI]--;\r\ndev->num_outputs--;\r\n}\r\ndev->has_vid_cap = node_type & 0x0001;\r\nif (in_type_counter[TV] || in_type_counter[SVID]) {\r\ndev->has_raw_vbi_cap = node_type & 0x0004;\r\ndev->has_sliced_vbi_cap = node_type & 0x0008;\r\ndev->has_vbi_cap = dev->has_raw_vbi_cap | dev->has_sliced_vbi_cap;\r\n}\r\ndev->has_vid_out = node_type & 0x0100;\r\nif (out_type_counter[SVID]) {\r\ndev->has_raw_vbi_out = node_type & 0x0400;\r\ndev->has_sliced_vbi_out = node_type & 0x0800;\r\ndev->has_vbi_out = dev->has_raw_vbi_out | dev->has_sliced_vbi_out;\r\n}\r\ndev->has_radio_rx = node_type & 0x0010;\r\ndev->has_radio_tx = node_type & 0x1000;\r\ndev->has_sdr_cap = node_type & 0x0020;\r\nhas_tuner = ((dev->has_vid_cap || dev->has_vbi_cap) && in_type_counter[TV]) ||\r\ndev->has_radio_rx || dev->has_sdr_cap;\r\nhas_modulator = dev->has_radio_tx;\r\nif (dev->has_vid_cap)\r\ndev->has_fb = node_type & 0x10000;\r\nif (no_error_inj && ccs_cap == -1)\r\nccs_cap = 7;\r\nif (ccs_cap != -1) {\r\ndev->has_crop_cap = ccs_cap & 1;\r\ndev->has_compose_cap = ccs_cap & 2;\r\ndev->has_scaler_cap = ccs_cap & 4;\r\nv4l2_info(&dev->v4l2_dev, "Capture Crop: %c Compose: %c Scaler: %c\n",\r\ndev->has_crop_cap ? 'Y' : 'N',\r\ndev->has_compose_cap ? 'Y' : 'N',\r\ndev->has_scaler_cap ? 'Y' : 'N');\r\n}\r\nif (no_error_inj && ccs_out == -1)\r\nccs_out = 7;\r\nif (ccs_out != -1) {\r\ndev->has_crop_out = ccs_out & 1;\r\ndev->has_compose_out = ccs_out & 2;\r\ndev->has_scaler_out = ccs_out & 4;\r\nv4l2_info(&dev->v4l2_dev, "Output Crop: %c Compose: %c Scaler: %c\n",\r\ndev->has_crop_out ? 'Y' : 'N',\r\ndev->has_compose_out ? 'Y' : 'N',\r\ndev->has_scaler_out ? 'Y' : 'N');\r\n}\r\nif (dev->has_vid_cap) {\r\ndev->vid_cap_caps = dev->multiplanar ?\r\nV4L2_CAP_VIDEO_CAPTURE_MPLANE :\r\nV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OVERLAY;\r\ndev->vid_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nif (dev->has_audio_inputs)\r\ndev->vid_cap_caps |= V4L2_CAP_AUDIO;\r\nif (in_type_counter[TV])\r\ndev->vid_cap_caps |= V4L2_CAP_TUNER;\r\n}\r\nif (dev->has_vid_out) {\r\ndev->vid_out_caps = dev->multiplanar ?\r\nV4L2_CAP_VIDEO_OUTPUT_MPLANE :\r\nV4L2_CAP_VIDEO_OUTPUT;\r\nif (dev->has_fb)\r\ndev->vid_out_caps |= V4L2_CAP_VIDEO_OUTPUT_OVERLAY;\r\ndev->vid_out_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nif (dev->has_audio_outputs)\r\ndev->vid_out_caps |= V4L2_CAP_AUDIO;\r\n}\r\nif (dev->has_vbi_cap) {\r\ndev->vbi_cap_caps = (dev->has_raw_vbi_cap ? V4L2_CAP_VBI_CAPTURE : 0) |\r\n(dev->has_sliced_vbi_cap ? V4L2_CAP_SLICED_VBI_CAPTURE : 0);\r\ndev->vbi_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nif (dev->has_audio_inputs)\r\ndev->vbi_cap_caps |= V4L2_CAP_AUDIO;\r\nif (in_type_counter[TV])\r\ndev->vbi_cap_caps |= V4L2_CAP_TUNER;\r\n}\r\nif (dev->has_vbi_out) {\r\ndev->vbi_out_caps = (dev->has_raw_vbi_out ? V4L2_CAP_VBI_OUTPUT : 0) |\r\n(dev->has_sliced_vbi_out ? V4L2_CAP_SLICED_VBI_OUTPUT : 0);\r\ndev->vbi_out_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nif (dev->has_audio_outputs)\r\ndev->vbi_out_caps |= V4L2_CAP_AUDIO;\r\n}\r\nif (dev->has_sdr_cap) {\r\ndev->sdr_cap_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER;\r\ndev->sdr_cap_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\n}\r\nif (dev->has_radio_rx)\r\ndev->radio_rx_caps = V4L2_CAP_RADIO | V4L2_CAP_RDS_CAPTURE |\r\nV4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_TUNER |\r\nV4L2_CAP_READWRITE;\r\nif (dev->has_radio_tx)\r\ndev->radio_tx_caps = V4L2_CAP_RDS_OUTPUT | V4L2_CAP_MODULATOR |\r\nV4L2_CAP_READWRITE;\r\nret = -ENOMEM;\r\ntpg_init(&dev->tpg, 640, 360);\r\nif (tpg_alloc(&dev->tpg, MAX_ZOOM * MAX_WIDTH))\r\ngoto free_dev;\r\ndev->scaled_line = vzalloc(MAX_ZOOM * MAX_WIDTH);\r\nif (!dev->scaled_line)\r\ngoto free_dev;\r\ndev->blended_line = vzalloc(MAX_ZOOM * MAX_WIDTH);\r\nif (!dev->blended_line)\r\ngoto free_dev;\r\ndev->edid = vmalloc(256 * 128);\r\nif (!dev->edid)\r\ngoto free_dev;\r\nwhile (v4l2_dv_timings_presets[dev->query_dv_timings_size].bt.width)\r\ndev->query_dv_timings_size++;\r\ndev->query_dv_timings_qmenu = kmalloc(dev->query_dv_timings_size *\r\n(sizeof(void *) + 32), GFP_KERNEL);\r\nif (dev->query_dv_timings_qmenu == NULL)\r\ngoto free_dev;\r\nfor (i = 0; i < dev->query_dv_timings_size; i++) {\r\nconst struct v4l2_bt_timings *bt = &v4l2_dv_timings_presets[i].bt;\r\nchar *p = (char *)&dev->query_dv_timings_qmenu[dev->query_dv_timings_size];\r\nu32 htot, vtot;\r\np += i * 32;\r\ndev->query_dv_timings_qmenu[i] = p;\r\nhtot = V4L2_DV_BT_FRAME_WIDTH(bt);\r\nvtot = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nsnprintf(p, 32, "%ux%u%s%u",\r\nbt->width, bt->height, bt->interlaced ? "i" : "p",\r\n(u32)bt->pixelclock / (htot * vtot));\r\n}\r\nif (!dev->has_audio_inputs) {\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_AUDIO);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_AUDIO);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUMAUDIO);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_AUDIO);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_AUDIO);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_ENUMAUDIO);\r\n}\r\nif (!dev->has_audio_outputs) {\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_AUDOUT);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_AUDOUT);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUMAUDOUT);\r\nv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_S_AUDOUT);\r\nv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_G_AUDOUT);\r\nv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_ENUMAUDOUT);\r\n}\r\nif (!in_type_counter[TV] && !in_type_counter[SVID]) {\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_STD);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_STD);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUMSTD);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_QUERYSTD);\r\n}\r\nif (!out_type_counter[SVID]) {\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_STD);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_STD);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUMSTD);\r\n}\r\nif (!has_tuner && !has_modulator) {\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_FREQUENCY);\r\n}\r\nif (!has_tuner) {\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_G_TUNER);\r\n}\r\nif (in_type_counter[HDMI] == 0) {\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_EDID);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_EDID);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_DV_TIMINGS_CAP);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_G_DV_TIMINGS);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_DV_TIMINGS);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_ENUM_DV_TIMINGS);\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_QUERY_DV_TIMINGS);\r\n}\r\nif (out_type_counter[HDMI] == 0) {\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_EDID);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_DV_TIMINGS_CAP);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_DV_TIMINGS);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_DV_TIMINGS);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_DV_TIMINGS);\r\n}\r\nif (!dev->has_fb) {\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_FBUF);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_FBUF);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_OVERLAY);\r\n}\r\nv4l2_disable_ioctl(&dev->vid_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\r\nv4l2_disable_ioctl(&dev->vbi_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\r\nv4l2_disable_ioctl(&dev->sdr_cap_dev, VIDIOC_S_HW_FREQ_SEEK);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_FRAMESIZES);\r\nv4l2_disable_ioctl(&dev->vid_out_dev, VIDIOC_ENUM_FRAMEINTERVALS);\r\nv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_S_FREQUENCY);\r\nv4l2_disable_ioctl(&dev->vbi_out_dev, VIDIOC_G_FREQUENCY);\r\ndev->fmt_cap = &vivid_formats[0];\r\ndev->fmt_out = &vivid_formats[0];\r\nif (!dev->multiplanar)\r\nvivid_formats[0].data_offset[0] = 0;\r\ndev->webcam_size_idx = 1;\r\ndev->webcam_ival_idx = 3;\r\ntpg_s_fourcc(&dev->tpg, dev->fmt_cap->fourcc);\r\ndev->std_cap = V4L2_STD_PAL;\r\ndev->std_out = V4L2_STD_PAL;\r\nif (dev->input_type[0] == TV || dev->input_type[0] == SVID)\r\ntvnorms_cap = V4L2_STD_ALL;\r\nif (dev->output_type[0] == SVID)\r\ntvnorms_out = V4L2_STD_ALL;\r\ndev->dv_timings_cap = def_dv_timings;\r\ndev->dv_timings_out = def_dv_timings;\r\ndev->tv_freq = 2804 ;\r\ndev->tv_audmode = V4L2_TUNER_MODE_STEREO;\r\ndev->tv_field_cap = V4L2_FIELD_INTERLACED;\r\ndev->tv_field_out = V4L2_FIELD_INTERLACED;\r\ndev->radio_rx_freq = 95000 * 16;\r\ndev->radio_rx_audmode = V4L2_TUNER_MODE_STEREO;\r\nif (dev->has_radio_tx) {\r\ndev->radio_tx_freq = 95500 * 16;\r\ndev->radio_rds_loop = false;\r\n}\r\ndev->radio_tx_subchans = V4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_RDS;\r\ndev->sdr_adc_freq = 300000;\r\ndev->sdr_fm_freq = 50000000;\r\ndev->sdr_pixelformat = V4L2_SDR_FMT_CU8;\r\ndev->sdr_buffersize = SDR_CAP_SAMPLES_PER_BUF * 2;\r\ndev->edid_max_blocks = dev->edid_blocks = 2;\r\nmemcpy(dev->edid, vivid_hdmi_edid, sizeof(vivid_hdmi_edid));\r\nktime_get_ts(&dev->radio_rds_init_ts);\r\nret = vivid_create_controls(dev, ccs_cap == -1, ccs_out == -1, no_error_inj,\r\nin_type_counter[TV] || in_type_counter[SVID] ||\r\nout_type_counter[SVID],\r\nin_type_counter[HDMI] || out_type_counter[HDMI]);\r\nif (ret)\r\ngoto unreg_dev;\r\nvivid_update_format_cap(dev, false);\r\nvivid_update_format_out(dev);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vid_cap);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vid_out);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vbi_cap);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_vbi_out);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_radio_rx);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_radio_tx);\r\nv4l2_ctrl_handler_setup(&dev->ctrl_hdl_sdr_cap);\r\ndev->fb_cap.fmt.width = dev->src_rect.width;\r\ndev->fb_cap.fmt.height = dev->src_rect.height;\r\ndev->fb_cap.fmt.pixelformat = dev->fmt_cap->fourcc;\r\ndev->fb_cap.fmt.bytesperline = dev->src_rect.width * tpg_g_twopixelsize(&dev->tpg, 0) / 2;\r\ndev->fb_cap.fmt.sizeimage = dev->src_rect.height * dev->fb_cap.fmt.bytesperline;\r\nspin_lock_init(&dev->slock);\r\nmutex_init(&dev->mutex);\r\nINIT_LIST_HEAD(&dev->vid_cap_active);\r\nINIT_LIST_HEAD(&dev->vid_out_active);\r\nINIT_LIST_HEAD(&dev->vbi_cap_active);\r\nINIT_LIST_HEAD(&dev->vbi_out_active);\r\nINIT_LIST_HEAD(&dev->sdr_cap_active);\r\nINIT_LIST_HEAD(&dev->cec_work_list);\r\nspin_lock_init(&dev->cec_slock);\r\ndev->cec_workqueue =\r\nalloc_ordered_workqueue("vivid-%03d-cec", WQ_MEM_RECLAIM, inst);\r\nif (!dev->cec_workqueue) {\r\nret = -ENOMEM;\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_vid_cap) {\r\nq = &dev->vb_vid_cap_q;\r\nq->type = dev->multiplanar ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivid_buffer);\r\nq->ops = &vivid_vid_cap_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &dev->mutex;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_vid_out) {\r\nq = &dev->vb_vid_out_q;\r\nq->type = dev->multiplanar ? V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE :\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_WRITE;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivid_buffer);\r\nq->ops = &vivid_vid_out_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &dev->mutex;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_vbi_cap) {\r\nq = &dev->vb_vbi_cap_q;\r\nq->type = dev->has_raw_vbi_cap ? V4L2_BUF_TYPE_VBI_CAPTURE :\r\nV4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivid_buffer);\r\nq->ops = &vivid_vbi_cap_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &dev->mutex;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_vbi_out) {\r\nq = &dev->vb_vbi_out_q;\r\nq->type = dev->has_raw_vbi_out ? V4L2_BUF_TYPE_VBI_OUTPUT :\r\nV4L2_BUF_TYPE_SLICED_VBI_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_WRITE;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivid_buffer);\r\nq->ops = &vivid_vbi_out_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &dev->mutex;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_sdr_cap) {\r\nq = &dev->vb_sdr_cap_q;\r\nq->type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct vivid_buffer);\r\nq->ops = &vivid_sdr_cap_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 8;\r\nq->lock = &dev->mutex;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto unreg_dev;\r\n}\r\nif (dev->has_fb) {\r\nret = vivid_fb_init(dev);\r\nif (ret)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "Framebuffer device registered as fb%d\n",\r\ndev->fb_info.node);\r\n}\r\nif (dev->has_vid_cap) {\r\nvfd = &dev->vid_cap_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-vid-cap", inst);\r\nvfd->fops = &vivid_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->vid_cap_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = &dev->vb_vid_cap_q;\r\nvfd->tvnorms = tvnorms_cap;\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\n#ifdef CONFIG_VIDEO_VIVID_CEC\r\nif (in_type_counter[HDMI]) {\r\nstruct cec_adapter *adap;\r\nadap = vivid_cec_alloc_adap(dev, 0, false);\r\nret = PTR_ERR_OR_ZERO(adap);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\ndev->cec_rx_adap = adap;\r\nret = cec_register_adapter(adap, &pdev->dev);\r\nif (ret < 0) {\r\ncec_delete_adapter(adap);\r\ndev->cec_rx_adap = NULL;\r\ngoto unreg_dev;\r\n}\r\ncec_s_phys_addr(adap, 0, false);\r\nv4l2_info(&dev->v4l2_dev, "CEC adapter %s registered for HDMI input %d\n",\r\ndev_name(&adap->devnode.dev), i);\r\n}\r\n#endif\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, vid_cap_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 capture device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\n}\r\nif (dev->has_vid_out) {\r\n#ifdef CONFIG_VIDEO_VIVID_CEC\r\nunsigned int bus_cnt = 0;\r\n#endif\r\nvfd = &dev->vid_out_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-vid-out", inst);\r\nvfd->vfl_dir = VFL_DIR_TX;\r\nvfd->fops = &vivid_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->vid_out_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = &dev->vb_vid_out_q;\r\nvfd->tvnorms = tvnorms_out;\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\n#ifdef CONFIG_VIDEO_VIVID_CEC\r\nfor (i = 0; i < dev->num_outputs; i++) {\r\nstruct cec_adapter *adap;\r\nif (dev->output_type[i] != HDMI)\r\ncontinue;\r\ndev->cec_output2bus_map[i] = bus_cnt;\r\nadap = vivid_cec_alloc_adap(dev, bus_cnt, true);\r\nret = PTR_ERR_OR_ZERO(adap);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\ndev->cec_tx_adap[bus_cnt] = adap;\r\nret = cec_register_adapter(adap, &pdev->dev);\r\nif (ret < 0) {\r\ncec_delete_adapter(adap);\r\ndev->cec_tx_adap[bus_cnt] = NULL;\r\ngoto unreg_dev;\r\n}\r\nbus_cnt++;\r\nif (bus_cnt <= out_type_counter[HDMI])\r\ncec_s_phys_addr(adap, bus_cnt << 12, false);\r\nelse\r\ncec_s_phys_addr(adap, 0x1000, false);\r\nv4l2_info(&dev->v4l2_dev, "CEC adapter %s registered for HDMI output %d\n",\r\ndev_name(&adap->devnode.dev), i);\r\n}\r\n#endif\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, vid_out_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 output device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\n}\r\nif (dev->has_vbi_cap) {\r\nvfd = &dev->vbi_cap_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-vbi-cap", inst);\r\nvfd->fops = &vivid_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->vbi_cap_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = &dev->vb_vbi_cap_q;\r\nvfd->lock = &dev->mutex;\r\nvfd->tvnorms = tvnorms_cap;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_VBI, vbi_cap_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 capture device registered as %s, supports %s VBI\n",\r\nvideo_device_node_name(vfd),\r\n(dev->has_raw_vbi_cap && dev->has_sliced_vbi_cap) ?\r\n"raw and sliced" :\r\n(dev->has_raw_vbi_cap ? "raw" : "sliced"));\r\n}\r\nif (dev->has_vbi_out) {\r\nvfd = &dev->vbi_out_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-vbi-out", inst);\r\nvfd->vfl_dir = VFL_DIR_TX;\r\nvfd->fops = &vivid_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->vbi_out_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = &dev->vb_vbi_out_q;\r\nvfd->lock = &dev->mutex;\r\nvfd->tvnorms = tvnorms_out;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_VBI, vbi_out_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 output device registered as %s, supports %s VBI\n",\r\nvideo_device_node_name(vfd),\r\n(dev->has_raw_vbi_out && dev->has_sliced_vbi_out) ?\r\n"raw and sliced" :\r\n(dev->has_raw_vbi_out ? "raw" : "sliced"));\r\n}\r\nif (dev->has_sdr_cap) {\r\nvfd = &dev->sdr_cap_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-sdr-cap", inst);\r\nvfd->fops = &vivid_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->sdr_cap_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->queue = &dev->vb_sdr_cap_q;\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_SDR, sdr_cap_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 capture device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\n}\r\nif (dev->has_radio_rx) {\r\nvfd = &dev->radio_rx_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-rad-rx", inst);\r\nvfd->fops = &vivid_radio_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->radio_rx_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_RADIO, radio_rx_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 receiver device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\n}\r\nif (dev->has_radio_tx) {\r\nvfd = &dev->radio_tx_dev;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"vivid-%03d-rad-tx", inst);\r\nvfd->vfl_dir = VFL_DIR_TX;\r\nvfd->fops = &vivid_radio_fops;\r\nvfd->ioctl_ops = &vivid_ioctl_ops;\r\nvfd->device_caps = dev->radio_tx_caps;\r\nvfd->release = video_device_release_empty;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->lock = &dev->mutex;\r\nvideo_set_drvdata(vfd, dev);\r\nret = video_register_device(vfd, VFL_TYPE_RADIO, radio_tx_nr[inst]);\r\nif (ret < 0)\r\ngoto unreg_dev;\r\nv4l2_info(&dev->v4l2_dev, "V4L2 transmitter device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\n}\r\nvivid_devs[inst] = dev;\r\nreturn 0;\r\nunreg_dev:\r\nvideo_unregister_device(&dev->radio_tx_dev);\r\nvideo_unregister_device(&dev->radio_rx_dev);\r\nvideo_unregister_device(&dev->sdr_cap_dev);\r\nvideo_unregister_device(&dev->vbi_out_dev);\r\nvideo_unregister_device(&dev->vbi_cap_dev);\r\nvideo_unregister_device(&dev->vid_out_dev);\r\nvideo_unregister_device(&dev->vid_cap_dev);\r\ncec_unregister_adapter(dev->cec_rx_adap);\r\nfor (i = 0; i < MAX_OUTPUTS; i++)\r\ncec_unregister_adapter(dev->cec_tx_adap[i]);\r\nif (dev->cec_workqueue) {\r\nvivid_cec_bus_free_work(dev);\r\ndestroy_workqueue(dev->cec_workqueue);\r\n}\r\nfree_dev:\r\nv4l2_device_put(&dev->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int vivid_probe(struct platform_device *pdev)\r\n{\r\nconst struct font_desc *font = find_font("VGA8x16");\r\nint ret = 0, i;\r\nif (font == NULL) {\r\npr_err("vivid: could not find font\n");\r\nreturn -ENODEV;\r\n}\r\ntpg_set_font(font->data);\r\nn_devs = clamp_t(unsigned, n_devs, 1, VIVID_MAX_DEVS);\r\nfor (i = 0; i < n_devs; i++) {\r\nret = vivid_create_instance(pdev, i);\r\nif (ret) {\r\nif (i)\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\npr_err("vivid: error %d while loading driver\n", ret);\r\nreturn ret;\r\n}\r\nn_devs = i;\r\nreturn ret;\r\n}\r\nstatic int vivid_remove(struct platform_device *pdev)\r\n{\r\nstruct vivid_dev *dev;\r\nunsigned int i, j;\r\nfor (i = 0; i < n_devs; i++) {\r\ndev = vivid_devs[i];\r\nif (!dev)\r\ncontinue;\r\nif (dev->has_vid_cap) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->vid_cap_dev));\r\nvideo_unregister_device(&dev->vid_cap_dev);\r\n}\r\nif (dev->has_vid_out) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->vid_out_dev));\r\nvideo_unregister_device(&dev->vid_out_dev);\r\n}\r\nif (dev->has_vbi_cap) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->vbi_cap_dev));\r\nvideo_unregister_device(&dev->vbi_cap_dev);\r\n}\r\nif (dev->has_vbi_out) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->vbi_out_dev));\r\nvideo_unregister_device(&dev->vbi_out_dev);\r\n}\r\nif (dev->has_sdr_cap) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->sdr_cap_dev));\r\nvideo_unregister_device(&dev->sdr_cap_dev);\r\n}\r\nif (dev->has_radio_rx) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->radio_rx_dev));\r\nvideo_unregister_device(&dev->radio_rx_dev);\r\n}\r\nif (dev->has_radio_tx) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering %s\n",\r\nvideo_device_node_name(&dev->radio_tx_dev));\r\nvideo_unregister_device(&dev->radio_tx_dev);\r\n}\r\nif (dev->has_fb) {\r\nv4l2_info(&dev->v4l2_dev, "unregistering fb%d\n",\r\ndev->fb_info.node);\r\nunregister_framebuffer(&dev->fb_info);\r\nvivid_fb_release_buffers(dev);\r\n}\r\ncec_unregister_adapter(dev->cec_rx_adap);\r\nfor (j = 0; j < MAX_OUTPUTS; j++)\r\ncec_unregister_adapter(dev->cec_tx_adap[j]);\r\nif (dev->cec_workqueue) {\r\nvivid_cec_bus_free_work(dev);\r\ndestroy_workqueue(dev->cec_workqueue);\r\n}\r\nv4l2_device_put(&dev->v4l2_dev);\r\nvivid_devs[i] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vivid_pdev_release(struct device *dev)\r\n{\r\n}\r\nstatic int __init vivid_init(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&vivid_pdev);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&vivid_pdrv);\r\nif (ret)\r\nplatform_device_unregister(&vivid_pdev);\r\nreturn ret;\r\n}\r\nstatic void __exit vivid_exit(void)\r\n{\r\nplatform_driver_unregister(&vivid_pdrv);\r\nplatform_device_unregister(&vivid_pdev);\r\n}
