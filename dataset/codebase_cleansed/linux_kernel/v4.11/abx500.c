static inline void schedule_monitor(struct abx500_temp *data)\r\n{\r\ndata->work_active = true;\r\nschedule_delayed_work(&data->work, DEFAULT_MONITOR_DELAY);\r\n}\r\nstatic void threshold_updated(struct abx500_temp *data)\r\n{\r\nint i;\r\nfor (i = 0; i < data->monitored_sensors; i++)\r\nif (data->max[i] != 0 || data->min[i] != 0) {\r\nschedule_monitor(data);\r\nreturn;\r\n}\r\ndev_dbg(&data->pdev->dev, "No active thresholds.\n");\r\ncancel_delayed_work_sync(&data->work);\r\ndata->work_active = false;\r\n}\r\nstatic void gpadc_monitor(struct work_struct *work)\r\n{\r\nint temp, i, ret;\r\nchar alarm_node[30];\r\nbool updated_min_alarm, updated_max_alarm;\r\nstruct abx500_temp *data;\r\ndata = container_of(work, struct abx500_temp, work.work);\r\nmutex_lock(&data->lock);\r\nfor (i = 0; i < data->monitored_sensors; i++) {\r\nif (data->max[i] == 0 && data->min[i] == 0)\r\ncontinue;\r\nif (data->max[i] < data->min[i])\r\ncontinue;\r\nret = data->ops.read_sensor(data, data->gpadc_addr[i], &temp);\r\nif (ret < 0) {\r\ndev_err(&data->pdev->dev, "GPADC read failed\n");\r\ncontinue;\r\n}\r\nupdated_min_alarm = false;\r\nupdated_max_alarm = false;\r\nif (data->min[i] != 0) {\r\nif (temp < data->min[i]) {\r\nif (data->min_alarm[i] == false) {\r\ndata->min_alarm[i] = true;\r\nupdated_min_alarm = true;\r\n}\r\n} else {\r\nif (data->min_alarm[i] == true) {\r\ndata->min_alarm[i] = false;\r\nupdated_min_alarm = true;\r\n}\r\n}\r\n}\r\nif (data->max[i] != 0) {\r\nif (temp > data->max[i]) {\r\nif (data->max_alarm[i] == false) {\r\ndata->max_alarm[i] = true;\r\nupdated_max_alarm = true;\r\n}\r\n} else if (temp < data->max[i] - data->max_hyst[i]) {\r\nif (data->max_alarm[i] == true) {\r\ndata->max_alarm[i] = false;\r\nupdated_max_alarm = true;\r\n}\r\n}\r\n}\r\nif (updated_min_alarm) {\r\nret = sprintf(alarm_node, "temp%d_min_alarm", i + 1);\r\nsysfs_notify(&data->pdev->dev.kobj, NULL, alarm_node);\r\n}\r\nif (updated_max_alarm) {\r\nret = sprintf(alarm_node, "temp%d_max_alarm", i + 1);\r\nsysfs_notify(&data->pdev->dev.kobj, NULL, alarm_node);\r\n}\r\n}\r\nschedule_monitor(data);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nreturn data->ops.show_name(dev, devattr, buf);\r\n}\r\nstatic ssize_t show_label(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nreturn data->ops.show_label(dev, devattr, buf);\r\n}\r\nstatic ssize_t show_input(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nint ret, temp;\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nu8 gpadc_addr = data->gpadc_addr[attr->index];\r\nret = data->ops.read_sensor(data, gpadc_addr, &temp);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic ssize_t set_min(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint res = kstrtol(buf, 10, &val);\r\nif (res < 0)\r\nreturn res;\r\nval = clamp_val(val, 0, DEFAULT_MAX_TEMP);\r\nmutex_lock(&data->lock);\r\ndata->min[attr->index] = val;\r\nthreshold_updated(data);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_max(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint res = kstrtol(buf, 10, &val);\r\nif (res < 0)\r\nreturn res;\r\nval = clamp_val(val, 0, DEFAULT_MAX_TEMP);\r\nmutex_lock(&data->lock);\r\ndata->max[attr->index] = val;\r\nthreshold_updated(data);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_max_hyst(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint res = kstrtoul(buf, 10, &val);\r\nif (res < 0)\r\nreturn res;\r\nval = clamp_val(val, 0, DEFAULT_MAX_TEMP);\r\nmutex_lock(&data->lock);\r\ndata->max_hyst[attr->index] = val;\r\nthreshold_updated(data);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_min(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nreturn sprintf(buf, "%lu\n", data->min[attr->index]);\r\n}\r\nstatic ssize_t show_max(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nreturn sprintf(buf, "%lu\n", data->max[attr->index]);\r\n}\r\nstatic ssize_t show_max_hyst(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nreturn sprintf(buf, "%lu\n", data->max_hyst[attr->index]);\r\n}\r\nstatic ssize_t show_min_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nreturn sprintf(buf, "%d\n", data->min_alarm[attr->index]);\r\n}\r\nstatic ssize_t show_max_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nreturn sprintf(buf, "%d\n", data->max_alarm[attr->index]);\r\n}\r\nstatic umode_t abx500_attrs_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct abx500_temp *data = dev_get_drvdata(dev);\r\nif (data->ops.is_visible)\r\nreturn data->ops.is_visible(attr, n);\r\nreturn attr->mode;\r\n}\r\nstatic irqreturn_t abx500_temp_irq_handler(int irq, void *irq_data)\r\n{\r\nstruct platform_device *pdev = irq_data;\r\nstruct abx500_temp *data = platform_get_drvdata(pdev);\r\ndata->ops.irq_handler(irq, data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int setup_irqs(struct platform_device *pdev)\r\n{\r\nint ret;\r\nint irq = platform_get_irq_byname(pdev, "ABX500_TEMP_WARM");\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Get irq by name failed\n");\r\nreturn irq;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nabx500_temp_irq_handler, 0, "abx500-temp", pdev);\r\nif (ret < 0)\r\ndev_err(&pdev->dev, "Request threaded irq failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int abx500_temp_probe(struct platform_device *pdev)\r\n{\r\nstruct abx500_temp *data;\r\nint err;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->pdev = pdev;\r\nmutex_init(&data->lock);\r\nerr = abx500_hwmon_init(data);\r\nif (err < 0 || !data->ops.read_sensor || !data->ops.show_name ||\r\n!data->ops.show_label)\r\nreturn err;\r\nINIT_DEFERRABLE_WORK(&data->work, gpadc_monitor);\r\nplatform_set_drvdata(pdev, data);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &abx500_temp_group);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Create sysfs group failed (%d)\n", err);\r\nreturn err;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&pdev->dev, "Class registration failed (%d)\n", err);\r\ngoto exit_sysfs_group;\r\n}\r\nif (data->ops.irq_handler) {\r\nerr = setup_irqs(pdev);\r\nif (err < 0)\r\ngoto exit_hwmon_reg;\r\n}\r\nreturn 0;\r\nexit_hwmon_reg:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nexit_sysfs_group:\r\nsysfs_remove_group(&pdev->dev.kobj, &abx500_temp_group);\r\nreturn err;\r\n}\r\nstatic int abx500_temp_remove(struct platform_device *pdev)\r\n{\r\nstruct abx500_temp *data = platform_get_drvdata(pdev);\r\ncancel_delayed_work_sync(&data->work);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &abx500_temp_group);\r\nreturn 0;\r\n}\r\nstatic int abx500_temp_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct abx500_temp *data = platform_get_drvdata(pdev);\r\nif (data->work_active)\r\ncancel_delayed_work_sync(&data->work);\r\nreturn 0;\r\n}\r\nstatic int abx500_temp_resume(struct platform_device *pdev)\r\n{\r\nstruct abx500_temp *data = platform_get_drvdata(pdev);\r\nif (data->work_active)\r\nschedule_monitor(data);\r\nreturn 0;\r\n}
