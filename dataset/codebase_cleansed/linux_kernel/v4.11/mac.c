static void mac_exception(void *handle, enum fman_mac_exceptions ex)\r\n{\r\nstruct mac_device *mac_dev;\r\nstruct mac_priv_s *priv;\r\nmac_dev = handle;\r\npriv = mac_dev->priv;\r\nif (ex == FM_MAC_EX_10G_RX_FIFO_OVFL) {\r\nmac_dev->set_exception(mac_dev->fman_mac,\r\nFM_MAC_EX_10G_RX_FIFO_OVFL, false);\r\ndev_err(priv->dev, "10G MAC got RX FIFO Error = %x\n", ex);\r\n}\r\ndev_dbg(priv->dev, "%s:%s() -> %d\n", KBUILD_BASENAME ".c",\r\n__func__, ex);\r\n}\r\nstatic void set_fman_mac_params(struct mac_device *mac_dev,\r\nstruct fman_mac_params *params)\r\n{\r\nstruct mac_priv_s *priv = mac_dev->priv;\r\nparams->base_addr = (typeof(params->base_addr))\r\ndevm_ioremap(priv->dev, mac_dev->res->start,\r\nresource_size(mac_dev->res));\r\nmemcpy(&params->addr, mac_dev->addr, sizeof(mac_dev->addr));\r\nparams->max_speed = priv->max_speed;\r\nparams->phy_if = priv->phy_if;\r\nparams->basex_if = false;\r\nparams->mac_id = priv->cell_index;\r\nparams->fm = (void *)priv->fman;\r\nparams->exception_cb = mac_exception;\r\nparams->event_cb = mac_exception;\r\nparams->dev_id = mac_dev;\r\nparams->internal_phy_node = priv->internal_phy_node;\r\n}\r\nstatic int tgec_initialization(struct mac_device *mac_dev)\r\n{\r\nint err;\r\nstruct mac_priv_s *priv;\r\nstruct fman_mac_params params;\r\nu32 version;\r\npriv = mac_dev->priv;\r\nset_fman_mac_params(mac_dev, &params);\r\nmac_dev->fman_mac = tgec_config(&params);\r\nif (!mac_dev->fman_mac) {\r\nerr = -EINVAL;\r\ngoto _return;\r\n}\r\nerr = tgec_cfg_max_frame_len(mac_dev->fman_mac, fman_get_max_frm());\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = tgec_init(mac_dev->fman_mac);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = mac_dev->set_exception(mac_dev->fman_mac,\r\nFM_MAC_EX_10G_TX_ECC_ER, false);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = tgec_get_version(mac_dev->fman_mac, &version);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\ndev_info(priv->dev, "FMan XGEC version: 0x%08x\n", version);\r\ngoto _return;\r\n_return_fm_mac_free:\r\ntgec_free(mac_dev->fman_mac);\r\n_return:\r\nreturn err;\r\n}\r\nstatic int dtsec_initialization(struct mac_device *mac_dev)\r\n{\r\nint err;\r\nstruct mac_priv_s *priv;\r\nstruct fman_mac_params params;\r\nu32 version;\r\npriv = mac_dev->priv;\r\nset_fman_mac_params(mac_dev, &params);\r\nmac_dev->fman_mac = dtsec_config(&params);\r\nif (!mac_dev->fman_mac) {\r\nerr = -EINVAL;\r\ngoto _return;\r\n}\r\nerr = dtsec_cfg_max_frame_len(mac_dev->fman_mac, fman_get_max_frm());\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = dtsec_cfg_pad_and_crc(mac_dev->fman_mac, true);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = dtsec_init(mac_dev->fman_mac);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = mac_dev->set_exception(mac_dev->fman_mac,\r\nFM_MAC_EX_1G_RX_MIB_CNT_OVFL, false);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = dtsec_get_version(mac_dev->fman_mac, &version);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\ndev_info(priv->dev, "FMan dTSEC version: 0x%08x\n", version);\r\ngoto _return;\r\n_return_fm_mac_free:\r\ndtsec_free(mac_dev->fman_mac);\r\n_return:\r\nreturn err;\r\n}\r\nstatic int memac_initialization(struct mac_device *mac_dev)\r\n{\r\nint err;\r\nstruct mac_priv_s *priv;\r\nstruct fman_mac_params params;\r\npriv = mac_dev->priv;\r\nset_fman_mac_params(mac_dev, &params);\r\nif (priv->max_speed == SPEED_10000)\r\nparams.phy_if = PHY_INTERFACE_MODE_XGMII;\r\nmac_dev->fman_mac = memac_config(&params);\r\nif (!mac_dev->fman_mac) {\r\nerr = -EINVAL;\r\ngoto _return;\r\n}\r\nerr = memac_cfg_max_frame_len(mac_dev->fman_mac, fman_get_max_frm());\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = memac_cfg_reset_on_init(mac_dev->fman_mac, true);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = memac_cfg_fixed_link(mac_dev->fman_mac, priv->fixed_link);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\nerr = memac_init(mac_dev->fman_mac);\r\nif (err < 0)\r\ngoto _return_fm_mac_free;\r\ndev_info(priv->dev, "FMan MEMAC\n");\r\ngoto _return;\r\n_return_fm_mac_free:\r\nmemac_free(mac_dev->fman_mac);\r\n_return:\r\nreturn err;\r\n}\r\nstatic int start(struct mac_device *mac_dev)\r\n{\r\nint err;\r\nstruct phy_device *phy_dev = mac_dev->phy_dev;\r\nstruct mac_priv_s *priv = mac_dev->priv;\r\nerr = priv->enable(mac_dev->fman_mac, COMM_MODE_RX_AND_TX);\r\nif (!err && phy_dev)\r\nphy_start(phy_dev);\r\nreturn err;\r\n}\r\nstatic int stop(struct mac_device *mac_dev)\r\n{\r\nstruct mac_priv_s *priv = mac_dev->priv;\r\nif (mac_dev->phy_dev)\r\nphy_stop(mac_dev->phy_dev);\r\nreturn priv->disable(mac_dev->fman_mac, COMM_MODE_RX_AND_TX);\r\n}\r\nstatic int set_multi(struct net_device *net_dev, struct mac_device *mac_dev)\r\n{\r\nstruct mac_priv_s *priv;\r\nstruct mac_address *old_addr, *tmp;\r\nstruct netdev_hw_addr *ha;\r\nint err;\r\nenet_addr_t *addr;\r\npriv = mac_dev->priv;\r\nlist_for_each_entry_safe(old_addr, tmp, &priv->mc_addr_list, list) {\r\naddr = (enet_addr_t *)old_addr->addr;\r\nerr = mac_dev->remove_hash_mac_addr(mac_dev->fman_mac, addr);\r\nif (err < 0)\r\nreturn err;\r\nlist_del(&old_addr->list);\r\nkfree(old_addr);\r\n}\r\nnetdev_for_each_mc_addr(ha, net_dev) {\r\naddr = (enet_addr_t *)ha->addr;\r\nerr = mac_dev->add_hash_mac_addr(mac_dev->fman_mac, addr);\r\nif (err < 0)\r\nreturn err;\r\ntmp = kmalloc(sizeof(*tmp), GFP_ATOMIC);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nether_addr_copy(tmp->addr, ha->addr);\r\nlist_add(&tmp->list, &priv->mc_addr_list);\r\n}\r\nreturn 0;\r\n}\r\nint fman_set_mac_active_pause(struct mac_device *mac_dev, bool rx, bool tx)\r\n{\r\nstruct fman_mac *fman_mac = mac_dev->fman_mac;\r\nint err = 0;\r\nif (rx != mac_dev->rx_pause_active) {\r\nerr = mac_dev->set_rx_pause(fman_mac, rx);\r\nif (likely(err == 0))\r\nmac_dev->rx_pause_active = rx;\r\n}\r\nif (tx != mac_dev->tx_pause_active) {\r\nu16 pause_time = (tx ? FSL_FM_PAUSE_TIME_ENABLE :\r\nFSL_FM_PAUSE_TIME_DISABLE);\r\nerr = mac_dev->set_tx_pause(fman_mac, 0, pause_time, 0);\r\nif (likely(err == 0))\r\nmac_dev->tx_pause_active = tx;\r\n}\r\nreturn err;\r\n}\r\nvoid fman_get_pause_cfg(struct mac_device *mac_dev, bool *rx_pause,\r\nbool *tx_pause)\r\n{\r\nstruct phy_device *phy_dev = mac_dev->phy_dev;\r\nu16 lcl_adv, rmt_adv;\r\nu8 flowctrl;\r\n*rx_pause = *tx_pause = false;\r\nif (!phy_dev->duplex)\r\nreturn;\r\nif (!mac_dev->autoneg_pause) {\r\n*rx_pause = mac_dev->rx_pause_req;\r\n*tx_pause = mac_dev->tx_pause_req;\r\nreturn;\r\n}\r\nlcl_adv = 0;\r\nif (phy_dev->advertising & ADVERTISED_Pause)\r\nlcl_adv |= ADVERTISE_PAUSE_CAP;\r\nif (phy_dev->advertising & ADVERTISED_Asym_Pause)\r\nlcl_adv |= ADVERTISE_PAUSE_ASYM;\r\nrmt_adv = 0;\r\nif (phy_dev->pause)\r\nrmt_adv |= LPA_PAUSE_CAP;\r\nif (phy_dev->asym_pause)\r\nrmt_adv |= LPA_PAUSE_ASYM;\r\nflowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);\r\nif (flowctrl & FLOW_CTRL_RX)\r\n*rx_pause = true;\r\nif (flowctrl & FLOW_CTRL_TX)\r\n*tx_pause = true;\r\n}\r\nstatic void adjust_link_void(struct net_device *net_dev)\r\n{\r\n}\r\nstatic void adjust_link_dtsec(struct net_device *net_dev)\r\n{\r\nstruct device *dev = net_dev->dev.parent;\r\nstruct dpaa_eth_data *eth_data = dev->platform_data;\r\nstruct mac_device *mac_dev = eth_data->mac_dev;\r\nstruct phy_device *phy_dev = mac_dev->phy_dev;\r\nstruct fman_mac *fman_mac;\r\nbool rx_pause, tx_pause;\r\nint err;\r\nfman_mac = mac_dev->fman_mac;\r\nif (!phy_dev->link) {\r\ndtsec_restart_autoneg(fman_mac);\r\nreturn;\r\n}\r\ndtsec_adjust_link(fman_mac, phy_dev->speed);\r\nfman_get_pause_cfg(mac_dev, &rx_pause, &tx_pause);\r\nerr = fman_set_mac_active_pause(mac_dev, rx_pause, tx_pause);\r\nif (err < 0)\r\nnetdev_err(net_dev, "fman_set_mac_active_pause() = %d\n", err);\r\n}\r\nstatic void adjust_link_memac(struct net_device *net_dev)\r\n{\r\nstruct device *dev = net_dev->dev.parent;\r\nstruct dpaa_eth_data *eth_data = dev->platform_data;\r\nstruct mac_device *mac_dev = eth_data->mac_dev;\r\nstruct phy_device *phy_dev = mac_dev->phy_dev;\r\nstruct fman_mac *fman_mac;\r\nbool rx_pause, tx_pause;\r\nint err;\r\nfman_mac = mac_dev->fman_mac;\r\nmemac_adjust_link(fman_mac, phy_dev->speed);\r\nfman_get_pause_cfg(mac_dev, &rx_pause, &tx_pause);\r\nerr = fman_set_mac_active_pause(mac_dev, rx_pause, tx_pause);\r\nif (err < 0)\r\nnetdev_err(net_dev, "fman_set_mac_active_pause() = %d\n", err);\r\n}\r\nstatic struct phy_device *init_phy(struct net_device *net_dev,\r\nstruct mac_device *mac_dev,\r\nvoid (*adj_lnk)(struct net_device *))\r\n{\r\nstruct phy_device *phy_dev;\r\nstruct mac_priv_s *priv = mac_dev->priv;\r\nphy_dev = of_phy_connect(net_dev, priv->phy_node, adj_lnk, 0,\r\npriv->phy_if);\r\nif (!phy_dev) {\r\nnetdev_err(net_dev, "Could not connect to PHY\n");\r\nreturn NULL;\r\n}\r\nphy_dev->supported &= mac_dev->if_support;\r\nphy_dev->supported |= (SUPPORTED_Pause | SUPPORTED_Asym_Pause);\r\nphy_dev->advertising = phy_dev->supported;\r\nmac_dev->phy_dev = phy_dev;\r\nreturn phy_dev;\r\n}\r\nstatic struct phy_device *dtsec_init_phy(struct net_device *net_dev,\r\nstruct mac_device *mac_dev)\r\n{\r\nreturn init_phy(net_dev, mac_dev, &adjust_link_dtsec);\r\n}\r\nstatic struct phy_device *tgec_init_phy(struct net_device *net_dev,\r\nstruct mac_device *mac_dev)\r\n{\r\nreturn init_phy(net_dev, mac_dev, adjust_link_void);\r\n}\r\nstatic struct phy_device *memac_init_phy(struct net_device *net_dev,\r\nstruct mac_device *mac_dev)\r\n{\r\nreturn init_phy(net_dev, mac_dev, &adjust_link_memac);\r\n}\r\nstatic void setup_dtsec(struct mac_device *mac_dev)\r\n{\r\nmac_dev->init_phy = dtsec_init_phy;\r\nmac_dev->init = dtsec_initialization;\r\nmac_dev->set_promisc = dtsec_set_promiscuous;\r\nmac_dev->change_addr = dtsec_modify_mac_address;\r\nmac_dev->add_hash_mac_addr = dtsec_add_hash_mac_address;\r\nmac_dev->remove_hash_mac_addr = dtsec_del_hash_mac_address;\r\nmac_dev->set_tx_pause = dtsec_set_tx_pause_frames;\r\nmac_dev->set_rx_pause = dtsec_accept_rx_pause_frames;\r\nmac_dev->set_exception = dtsec_set_exception;\r\nmac_dev->set_multi = set_multi;\r\nmac_dev->start = start;\r\nmac_dev->stop = stop;\r\nmac_dev->priv->enable = dtsec_enable;\r\nmac_dev->priv->disable = dtsec_disable;\r\n}\r\nstatic void setup_tgec(struct mac_device *mac_dev)\r\n{\r\nmac_dev->init_phy = tgec_init_phy;\r\nmac_dev->init = tgec_initialization;\r\nmac_dev->set_promisc = tgec_set_promiscuous;\r\nmac_dev->change_addr = tgec_modify_mac_address;\r\nmac_dev->add_hash_mac_addr = tgec_add_hash_mac_address;\r\nmac_dev->remove_hash_mac_addr = tgec_del_hash_mac_address;\r\nmac_dev->set_tx_pause = tgec_set_tx_pause_frames;\r\nmac_dev->set_rx_pause = tgec_accept_rx_pause_frames;\r\nmac_dev->set_exception = tgec_set_exception;\r\nmac_dev->set_multi = set_multi;\r\nmac_dev->start = start;\r\nmac_dev->stop = stop;\r\nmac_dev->priv->enable = tgec_enable;\r\nmac_dev->priv->disable = tgec_disable;\r\n}\r\nstatic void setup_memac(struct mac_device *mac_dev)\r\n{\r\nmac_dev->init_phy = memac_init_phy;\r\nmac_dev->init = memac_initialization;\r\nmac_dev->set_promisc = memac_set_promiscuous;\r\nmac_dev->change_addr = memac_modify_mac_address;\r\nmac_dev->add_hash_mac_addr = memac_add_hash_mac_address;\r\nmac_dev->remove_hash_mac_addr = memac_del_hash_mac_address;\r\nmac_dev->set_tx_pause = memac_set_tx_pause_frames;\r\nmac_dev->set_rx_pause = memac_accept_rx_pause_frames;\r\nmac_dev->set_exception = memac_set_exception;\r\nmac_dev->set_multi = set_multi;\r\nmac_dev->start = start;\r\nmac_dev->stop = stop;\r\nmac_dev->priv->enable = memac_enable;\r\nmac_dev->priv->disable = memac_disable;\r\n}\r\nstatic struct platform_device *dpaa_eth_add_device(int fman_id,\r\nstruct mac_device *mac_dev,\r\nstruct device_node *node)\r\n{\r\nstruct platform_device *pdev;\r\nstruct dpaa_eth_data data;\r\nstruct mac_priv_s *priv;\r\nstatic int dpaa_eth_dev_cnt;\r\nint ret;\r\npriv = mac_dev->priv;\r\ndata.mac_dev = mac_dev;\r\ndata.mac_hw_id = priv->cell_index;\r\ndata.fman_hw_id = fman_id;\r\ndata.mac_node = node;\r\nmutex_lock(&eth_lock);\r\npdev = platform_device_alloc("dpaa-ethernet", dpaa_eth_dev_cnt);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto no_mem;\r\n}\r\nret = platform_device_add_data(pdev, &data, sizeof(data));\r\nif (ret)\r\ngoto err;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto err;\r\ndpaa_eth_dev_cnt++;\r\nmutex_unlock(&eth_lock);\r\nreturn pdev;\r\nerr:\r\nplatform_device_put(pdev);\r\nno_mem:\r\nmutex_unlock(&eth_lock);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int mac_probe(struct platform_device *_of_dev)\r\n{\r\nint err, i, nph;\r\nstruct device *dev;\r\nstruct device_node *mac_node, *dev_node;\r\nstruct mac_device *mac_dev;\r\nstruct platform_device *of_dev;\r\nstruct resource res;\r\nstruct mac_priv_s *priv;\r\nconst u8 *mac_addr;\r\nu32 val;\r\nu8 fman_id;\r\nint phy_if;\r\ndev = &_of_dev->dev;\r\nmac_node = dev->of_node;\r\nmac_dev = devm_kzalloc(dev, sizeof(*mac_dev), GFP_KERNEL);\r\nif (!mac_dev) {\r\nerr = -ENOMEM;\r\ndev_err(dev, "devm_kzalloc() = %d\n", err);\r\ngoto _return;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nerr = -ENOMEM;\r\ngoto _return;\r\n}\r\nmac_dev->priv = priv;\r\npriv->dev = dev;\r\nif (of_device_is_compatible(mac_node, "fsl,fman-dtsec")) {\r\nsetup_dtsec(mac_dev);\r\npriv->internal_phy_node = of_parse_phandle(mac_node,\r\n"tbi-handle", 0);\r\n} else if (of_device_is_compatible(mac_node, "fsl,fman-xgec")) {\r\nsetup_tgec(mac_dev);\r\n} else if (of_device_is_compatible(mac_node, "fsl,fman-memac")) {\r\nsetup_memac(mac_dev);\r\npriv->internal_phy_node = of_parse_phandle(mac_node,\r\n"pcsphy-handle", 0);\r\n} else {\r\ndev_err(dev, "MAC node (%s) contains unsupported MAC\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return;\r\n}\r\ndev_set_drvdata(dev, mac_dev);\r\nINIT_LIST_HEAD(&priv->mc_addr_list);\r\ndev_node = of_get_parent(mac_node);\r\nif (!dev_node) {\r\ndev_err(dev, "of_get_parent(%s) failed\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_dev_set_drvdata;\r\n}\r\nof_dev = of_find_device_by_node(dev_node);\r\nif (!of_dev) {\r\ndev_err(dev, "of_find_device_by_node(%s) failed\n",\r\ndev_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_of_node_put;\r\n}\r\nerr = of_property_read_u32(dev_node, "cell-index", &val);\r\nif (err) {\r\ndev_err(dev, "failed to read cell-index for %s\n",\r\ndev_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_of_node_put;\r\n}\r\nfman_id = (u8)(val + 1);\r\npriv->fman = fman_bind(&of_dev->dev);\r\nif (!priv->fman) {\r\ndev_err(dev, "fman_bind(%s) failed\n", dev_node->full_name);\r\nerr = -ENODEV;\r\ngoto _return_of_node_put;\r\n}\r\nof_node_put(dev_node);\r\nerr = of_address_to_resource(mac_node, 0, &res);\r\nif (err < 0) {\r\ndev_err(dev, "of_address_to_resource(%s) = %d\n",\r\nmac_node->full_name, err);\r\ngoto _return_dev_set_drvdata;\r\n}\r\nmac_dev->res = __devm_request_region(dev,\r\nfman_get_mem_region(priv->fman),\r\nres.start, res.end + 1 - res.start,\r\n"mac");\r\nif (!mac_dev->res) {\r\ndev_err(dev, "__devm_request_mem_region(mac) failed\n");\r\nerr = -EBUSY;\r\ngoto _return_dev_set_drvdata;\r\n}\r\npriv->vaddr = devm_ioremap(dev, mac_dev->res->start,\r\nmac_dev->res->end + 1 - mac_dev->res->start);\r\nif (!priv->vaddr) {\r\ndev_err(dev, "devm_ioremap() failed\n");\r\nerr = -EIO;\r\ngoto _return_dev_set_drvdata;\r\n}\r\nif (!of_device_is_available(mac_node)) {\r\ndevm_iounmap(dev, priv->vaddr);\r\n__devm_release_region(dev, fman_get_mem_region(priv->fman),\r\nres.start, res.end + 1 - res.start);\r\ndevm_kfree(dev, mac_dev);\r\ndev_set_drvdata(dev, NULL);\r\nreturn -ENODEV;\r\n}\r\nerr = of_property_read_u32(mac_node, "cell-index", &val);\r\nif (err) {\r\ndev_err(dev, "failed to read cell-index for %s\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_dev_set_drvdata;\r\n}\r\npriv->cell_index = (u8)val;\r\nmac_addr = of_get_mac_address(mac_node);\r\nif (!mac_addr) {\r\ndev_err(dev, "of_get_mac_address(%s) failed\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_dev_set_drvdata;\r\n}\r\nmemcpy(mac_dev->addr, mac_addr, sizeof(mac_dev->addr));\r\nnph = of_count_phandle_with_args(mac_node, "fsl,fman-ports", NULL);\r\nif (unlikely(nph < 0)) {\r\ndev_err(dev, "of_count_phandle_with_args(%s, fsl,fman-ports) failed\n",\r\nmac_node->full_name);\r\nerr = nph;\r\ngoto _return_dev_set_drvdata;\r\n}\r\nif (nph != ARRAY_SIZE(mac_dev->port)) {\r\ndev_err(dev, "Not supported number of fman-ports handles of mac node %s from device tree\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_dev_set_drvdata;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mac_dev->port); i++) {\r\ndev_node = of_parse_phandle(mac_node, "fsl,fman-ports", i);\r\nif (!dev_node) {\r\ndev_err(dev, "of_parse_phandle(%s, fsl,fman-ports) failed\n",\r\nmac_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_of_node_put;\r\n}\r\nof_dev = of_find_device_by_node(dev_node);\r\nif (!of_dev) {\r\ndev_err(dev, "of_find_device_by_node(%s) failed\n",\r\ndev_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_of_node_put;\r\n}\r\nmac_dev->port[i] = fman_port_bind(&of_dev->dev);\r\nif (!mac_dev->port[i]) {\r\ndev_err(dev, "dev_get_drvdata(%s) failed\n",\r\ndev_node->full_name);\r\nerr = -EINVAL;\r\ngoto _return_of_node_put;\r\n}\r\nof_node_put(dev_node);\r\n}\r\nphy_if = of_get_phy_mode(mac_node);\r\nif (phy_if < 0) {\r\ndev_warn(dev,\r\n"of_get_phy_mode() for %s failed. Defaulting to SGMII\n",\r\nmac_node->full_name);\r\nphy_if = PHY_INTERFACE_MODE_SGMII;\r\n}\r\npriv->phy_if = phy_if;\r\npriv->speed = phy2speed[priv->phy_if];\r\npriv->max_speed = priv->speed;\r\nmac_dev->if_support = DTSEC_SUPPORTED;\r\nif (priv->phy_if == PHY_INTERFACE_MODE_SGMII)\r\nmac_dev->if_support &= ~(SUPPORTED_10baseT_Half |\r\nSUPPORTED_100baseT_Half);\r\nif (priv->max_speed == 1000)\r\nmac_dev->if_support |= SUPPORTED_1000baseT_Full;\r\nif (priv->phy_if == PHY_INTERFACE_MODE_XGMII)\r\nmac_dev->if_support = SUPPORTED_10000baseT_Full;\r\npriv->phy_node = of_parse_phandle(mac_node, "phy-handle", 0);\r\nif (!priv->phy_node && of_phy_is_fixed_link(mac_node)) {\r\nstruct phy_device *phy;\r\nerr = of_phy_register_fixed_link(mac_node);\r\nif (err)\r\ngoto _return_dev_set_drvdata;\r\npriv->fixed_link = kzalloc(sizeof(*priv->fixed_link),\r\nGFP_KERNEL);\r\nif (!priv->fixed_link) {\r\nerr = -ENOMEM;\r\ngoto _return_dev_set_drvdata;\r\n}\r\npriv->phy_node = of_node_get(mac_node);\r\nphy = of_phy_find_device(priv->phy_node);\r\nif (!phy) {\r\nerr = -EINVAL;\r\ngoto _return_dev_set_drvdata;\r\n}\r\npriv->fixed_link->link = phy->link;\r\npriv->fixed_link->speed = phy->speed;\r\npriv->fixed_link->duplex = phy->duplex;\r\npriv->fixed_link->pause = phy->pause;\r\npriv->fixed_link->asym_pause = phy->asym_pause;\r\nput_device(&phy->mdio.dev);\r\n}\r\nerr = mac_dev->init(mac_dev);\r\nif (err < 0) {\r\ndev_err(dev, "mac_dev->init() = %d\n", err);\r\nof_node_put(priv->phy_node);\r\ngoto _return_dev_set_drvdata;\r\n}\r\nmac_dev->autoneg_pause = true;\r\nmac_dev->rx_pause_req = true;\r\nmac_dev->tx_pause_req = true;\r\nmac_dev->rx_pause_active = false;\r\nmac_dev->tx_pause_active = false;\r\nerr = fman_set_mac_active_pause(mac_dev, true, true);\r\nif (err < 0)\r\ndev_err(dev, "fman_set_mac_active_pause() = %d\n", err);\r\ndev_info(dev, "FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",\r\nmac_dev->addr[0], mac_dev->addr[1], mac_dev->addr[2],\r\nmac_dev->addr[3], mac_dev->addr[4], mac_dev->addr[5]);\r\npriv->eth_dev = dpaa_eth_add_device(fman_id, mac_dev, mac_node);\r\nif (IS_ERR(priv->eth_dev)) {\r\ndev_err(dev, "failed to add Ethernet platform device for MAC %d\n",\r\npriv->cell_index);\r\npriv->eth_dev = NULL;\r\n}\r\ngoto _return;\r\n_return_of_node_put:\r\nof_node_put(dev_node);\r\n_return_dev_set_drvdata:\r\nkfree(priv->fixed_link);\r\ndev_set_drvdata(dev, NULL);\r\n_return:\r\nreturn err;\r\n}
