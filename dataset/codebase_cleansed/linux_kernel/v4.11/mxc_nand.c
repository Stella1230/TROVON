static void memcpy32_fromio(void *trg, const void __iomem *src, size_t size)\r\n{\r\nint i;\r\nu32 *t = trg;\r\nconst __iomem u32 *s = src;\r\nfor (i = 0; i < (size >> 2); i++)\r\n*t++ = __raw_readl(s++);\r\n}\r\nstatic void memcpy16_fromio(void *trg, const void __iomem *src, size_t size)\r\n{\r\nint i;\r\nu16 *t = trg;\r\nconst __iomem u16 *s = src;\r\nif (PTR_ALIGN(trg, 4) == trg && IS_ALIGNED(size, 4)) {\r\nmemcpy32_fromio(trg, src, size);\r\nreturn;\r\n}\r\nfor (i = 0; i < (size >> 1); i++)\r\n*t++ = __raw_readw(s++);\r\n}\r\nstatic inline void memcpy32_toio(void __iomem *trg, const void *src, int size)\r\n{\r\n__iowrite32_copy(trg, src, size / 4);\r\n}\r\nstatic void memcpy16_toio(void __iomem *trg, const void *src, int size)\r\n{\r\nint i;\r\n__iomem u16 *t = trg;\r\nconst u16 *s = src;\r\nif (PTR_ALIGN(src, 4) == src && IS_ALIGNED(size, 4)) {\r\nmemcpy32_toio(trg, src, size);\r\nreturn;\r\n}\r\nfor (i = 0; i < (size >> 1); i++)\r\n__raw_writew(*s++, t++);\r\n}\r\nstatic int check_int_v3(struct mxc_nand_host *host)\r\n{\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_IPC);\r\nif (!(tmp & NFC_V3_IPC_INT))\r\nreturn 0;\r\ntmp &= ~NFC_V3_IPC_INT;\r\nwritel(tmp, NFC_V3_IPC);\r\nreturn 1;\r\n}\r\nstatic int check_int_v1_v2(struct mxc_nand_host *host)\r\n{\r\nuint32_t tmp;\r\ntmp = readw(NFC_V1_V2_CONFIG2);\r\nif (!(tmp & NFC_V1_V2_CONFIG2_INT))\r\nreturn 0;\r\nif (!host->devtype_data->irqpending_quirk)\r\nwritew(tmp & ~NFC_V1_V2_CONFIG2_INT, NFC_V1_V2_CONFIG2);\r\nreturn 1;\r\n}\r\nstatic void irq_control_v1_v2(struct mxc_nand_host *host, int activate)\r\n{\r\nuint16_t tmp;\r\ntmp = readw(NFC_V1_V2_CONFIG1);\r\nif (activate)\r\ntmp &= ~NFC_V1_V2_CONFIG1_INT_MSK;\r\nelse\r\ntmp |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nwritew(tmp, NFC_V1_V2_CONFIG1);\r\n}\r\nstatic void irq_control_v3(struct mxc_nand_host *host, int activate)\r\n{\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_CONFIG2);\r\nif (activate)\r\ntmp &= ~NFC_V3_CONFIG2_INT_MSK;\r\nelse\r\ntmp |= NFC_V3_CONFIG2_INT_MSK;\r\nwritel(tmp, NFC_V3_CONFIG2);\r\n}\r\nstatic void irq_control(struct mxc_nand_host *host, int activate)\r\n{\r\nif (host->devtype_data->irqpending_quirk) {\r\nif (activate)\r\nenable_irq(host->irq);\r\nelse\r\ndisable_irq_nosync(host->irq);\r\n} else {\r\nhost->devtype_data->irq_control(host, activate);\r\n}\r\n}\r\nstatic u32 get_ecc_status_v1(struct mxc_nand_host *host)\r\n{\r\nreturn readw(NFC_V1_V2_ECC_STATUS_RESULT);\r\n}\r\nstatic u32 get_ecc_status_v2(struct mxc_nand_host *host)\r\n{\r\nreturn readl(NFC_V1_V2_ECC_STATUS_RESULT);\r\n}\r\nstatic u32 get_ecc_status_v3(struct mxc_nand_host *host)\r\n{\r\nreturn readl(NFC_V3_ECC_STATUS_RESULT);\r\n}\r\nstatic irqreturn_t mxc_nfc_irq(int irq, void *dev_id)\r\n{\r\nstruct mxc_nand_host *host = dev_id;\r\nif (!host->devtype_data->check_int(host))\r\nreturn IRQ_NONE;\r\nirq_control(host, 0);\r\ncomplete(&host->op_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wait_op_done(struct mxc_nand_host *host, int useirq)\r\n{\r\nint ret = 0;\r\nif (host->devtype_data->check_int(host))\r\nreturn 0;\r\nif (useirq) {\r\nunsigned long timeout;\r\nreinit_completion(&host->op_completion);\r\nirq_control(host, 1);\r\ntimeout = wait_for_completion_timeout(&host->op_completion, HZ);\r\nif (!timeout && !host->devtype_data->check_int(host)) {\r\ndev_dbg(host->dev, "timeout waiting for irq\n");\r\nret = -ETIMEDOUT;\r\n}\r\n} else {\r\nint max_retries = 8000;\r\nint done;\r\ndo {\r\nudelay(1);\r\ndone = host->devtype_data->check_int(host);\r\nif (done)\r\nbreak;\r\n} while (--max_retries);\r\nif (!done) {\r\ndev_dbg(host->dev, "timeout polling for completion\n");\r\nret = -ETIMEDOUT;\r\n}\r\n}\r\nWARN_ONCE(ret < 0, "timeout! useirq=%d\n", useirq);\r\nreturn ret;\r\n}\r\nstatic void send_cmd_v3(struct mxc_nand_host *host, uint16_t cmd, int useirq)\r\n{\r\nwritel(cmd, NFC_V3_FLASH_CMD);\r\nwritel(NFC_CMD, NFC_V3_LAUNCH);\r\nwait_op_done(host, useirq);\r\n}\r\nstatic void send_cmd_v1_v2(struct mxc_nand_host *host, uint16_t cmd, int useirq)\r\n{\r\npr_debug("send_cmd(host, 0x%x, %d)\n", cmd, useirq);\r\nwritew(cmd, NFC_V1_V2_FLASH_CMD);\r\nwritew(NFC_CMD, NFC_V1_V2_CONFIG2);\r\nif (host->devtype_data->irqpending_quirk && (cmd == NAND_CMD_RESET)) {\r\nint max_retries = 100;\r\nwhile (max_retries-- > 0) {\r\nif (readw(NFC_V1_V2_CONFIG2) == 0) {\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (max_retries < 0)\r\npr_debug("%s: RESET failed\n", __func__);\r\n} else {\r\nwait_op_done(host, useirq);\r\n}\r\n}\r\nstatic void send_addr_v3(struct mxc_nand_host *host, uint16_t addr, int islast)\r\n{\r\nwritel(addr, NFC_V3_FLASH_ADDR0);\r\nwritel(NFC_ADDR, NFC_V3_LAUNCH);\r\nwait_op_done(host, 0);\r\n}\r\nstatic void send_addr_v1_v2(struct mxc_nand_host *host, uint16_t addr, int islast)\r\n{\r\npr_debug("send_addr(host, 0x%x %d)\n", addr, islast);\r\nwritew(addr, NFC_V1_V2_FLASH_ADDR);\r\nwritew(NFC_ADDR, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, islast);\r\n}\r\nstatic void send_page_v3(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint32_t tmp;\r\ntmp = readl(NFC_V3_CONFIG1);\r\ntmp &= ~(7 << 4);\r\nwritel(tmp, NFC_V3_CONFIG1);\r\nwritel(ops, NFC_V3_LAUNCH);\r\nwait_op_done(host, false);\r\n}\r\nstatic void send_page_v2(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nwritew(ops, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\n}\r\nstatic void send_page_v1(struct mtd_info *mtd, unsigned int ops)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nint bufs, i;\r\nif (mtd->writesize > 512)\r\nbufs = 4;\r\nelse\r\nbufs = 1;\r\nfor (i = 0; i < bufs; i++) {\r\nwritew((host->active_cs << 4) | i, NFC_V1_V2_BUF_ADDR);\r\nwritew(ops, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\n}\r\n}\r\nstatic void send_read_id_v3(struct mxc_nand_host *host)\r\n{\r\nwritel(NFC_ID, NFC_V3_LAUNCH);\r\nwait_op_done(host, true);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 16);\r\n}\r\nstatic void send_read_id_v1_v2(struct mxc_nand_host *host)\r\n{\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nwritew(NFC_ID, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 16);\r\n}\r\nstatic uint16_t get_dev_status_v3(struct mxc_nand_host *host)\r\n{\r\nwritew(NFC_STATUS, NFC_V3_LAUNCH);\r\nwait_op_done(host, true);\r\nreturn readl(NFC_V3_CONFIG1) >> 16;\r\n}\r\nstatic uint16_t get_dev_status_v1_v2(struct mxc_nand_host *host)\r\n{\r\nvoid __iomem *main_buf = host->main_area0;\r\nuint32_t store;\r\nuint16_t ret;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\nstore = readl(main_buf);\r\nwritew(NFC_STATUS, NFC_V1_V2_CONFIG2);\r\nwait_op_done(host, true);\r\nret = readw(main_buf);\r\nwritel(store, main_buf);\r\nreturn ret;\r\n}\r\nstatic int mxc_nand_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn 1;\r\n}\r\nstatic void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\n}\r\nstatic int mxc_nand_correct_data_v1(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint16_t ecc_status = get_ecc_status_v1(host);\r\nif (((ecc_status & 0x3) == 2) || ((ecc_status >> 2) == 2)) {\r\npr_debug("MXC_NAND: HWECC uncorrectable 2-bit ECC error\n");\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxc_nand_correct_data_v2_v3(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nu32 ecc_stat, err;\r\nint no_subpages = 1;\r\nint ret = 0;\r\nu8 ecc_bit_mask, err_limit;\r\necc_bit_mask = (host->eccsize == 4) ? 0x7 : 0xf;\r\nerr_limit = (host->eccsize == 4) ? 0x4 : 0x8;\r\nno_subpages = mtd->writesize >> 9;\r\necc_stat = host->devtype_data->get_ecc_status(host);\r\ndo {\r\nerr = ecc_stat & ecc_bit_mask;\r\nif (err > err_limit) {\r\nprintk(KERN_WARNING "UnCorrectable RS-ECC Error\n");\r\nreturn -EBADMSG;\r\n} else {\r\nret += err;\r\n}\r\necc_stat >>= 4;\r\n} while (--no_subpages);\r\npr_debug("%d Symbol Correctable RS-ECC Error\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nreturn 0;\r\n}\r\nstatic u_char mxc_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint8_t ret;\r\nif (host->status_request)\r\nreturn host->devtype_data->get_dev_status(host) & 0xFF;\r\nif (nand_chip->options & NAND_BUSWIDTH_16) {\r\nret = *(uint16_t *)(host->data_buf + host->buf_start);\r\nhost->buf_start += 2;\r\n} else {\r\nret = *(uint8_t *)(host->data_buf + host->buf_start);\r\nhost->buf_start++;\r\n}\r\npr_debug("%s: ret=0x%hhx (start=%u)\n", __func__, ret, host->buf_start);\r\nreturn ret;\r\n}\r\nstatic uint16_t mxc_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint16_t ret;\r\nret = *(uint16_t *)(host->data_buf + host->buf_start);\r\nhost->buf_start += 2;\r\nreturn ret;\r\n}\r\nstatic void mxc_nand_write_buf(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nu16 col = host->buf_start;\r\nint n = mtd->oobsize + mtd->writesize - col;\r\nn = min(n, len);\r\nmemcpy(host->data_buf + col, buf, n);\r\nhost->buf_start += n;\r\n}\r\nstatic void mxc_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nu16 col = host->buf_start;\r\nint n = mtd->oobsize + mtd->writesize - col;\r\nn = min(n, len);\r\nmemcpy(buf, host->data_buf + col, n);\r\nhost->buf_start += n;\r\n}\r\nstatic void mxc_nand_select_chip_v1_v3(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nif (chip == -1) {\r\nif (host->clk_act) {\r\nclk_disable_unprepare(host->clk);\r\nhost->clk_act = 0;\r\n}\r\nreturn;\r\n}\r\nif (!host->clk_act) {\r\nclk_prepare_enable(host->clk);\r\nhost->clk_act = 1;\r\n}\r\n}\r\nstatic void mxc_nand_select_chip_v2(struct mtd_info *mtd, int chip)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nif (chip == -1) {\r\nif (host->clk_act) {\r\nclk_disable_unprepare(host->clk);\r\nhost->clk_act = 0;\r\n}\r\nreturn;\r\n}\r\nif (!host->clk_act) {\r\nclk_prepare_enable(host->clk);\r\nhost->clk_act = 1;\r\n}\r\nhost->active_cs = chip;\r\nwritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\r\n}\r\nstatic void copy_spare(struct mtd_info *mtd, bool bfrom)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(this);\r\nu16 i, oob_chunk_size;\r\nu16 num_chunks = mtd->writesize / 512;\r\nu8 *d = host->data_buf + mtd->writesize;\r\nu8 __iomem *s = host->spare0;\r\nu16 sparebuf_size = host->devtype_data->spare_len;\r\noob_chunk_size = (host->used_oobsize / num_chunks) & ~1;\r\nif (bfrom) {\r\nfor (i = 0; i < num_chunks - 1; i++)\r\nmemcpy16_fromio(d + i * oob_chunk_size,\r\ns + i * sparebuf_size,\r\noob_chunk_size);\r\nmemcpy16_fromio(d + i * oob_chunk_size,\r\ns + i * sparebuf_size,\r\nhost->used_oobsize - i * oob_chunk_size);\r\n} else {\r\nfor (i = 0; i < num_chunks - 1; i++)\r\nmemcpy16_toio(&s[i * sparebuf_size],\r\n&d[i * oob_chunk_size],\r\noob_chunk_size);\r\nmemcpy16_toio(&s[i * sparebuf_size],\r\n&d[i * oob_chunk_size],\r\nhost->used_oobsize - i * oob_chunk_size);\r\n}\r\n}\r\nstatic void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nif (column != -1) {\r\nhost->devtype_data->send_addr(host, column & 0xff,\r\npage_addr == -1);\r\nif (mtd->writesize > 512)\r\nhost->devtype_data->send_addr(host,\r\n(column >> 8) & 0xff,\r\nfalse);\r\n}\r\nif (page_addr != -1) {\r\nhost->devtype_data->send_addr(host, (page_addr & 0xff), false);\r\nif (mtd->writesize > 512) {\r\nif (mtd->size >= 0x10000000) {\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff,\r\nfalse);\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 16) & 0xff,\r\ntrue);\r\n} else\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff, true);\r\n} else {\r\nif (mtd->size >= 0x4000000) {\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff,\r\nfalse);\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 16) & 0xff,\r\ntrue);\r\n} else\r\nhost->devtype_data->send_addr(host,\r\n(page_addr >> 8) & 0xff, true);\r\n}\r\n}\r\n}\r\nstatic int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nif (section >= nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (section * 16) + 6;\r\noobregion->length = nand_chip->ecc.bytes;\r\nreturn 0;\r\n}\r\nstatic int mxc_v1_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nif (section > nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\nif (!section) {\r\nif (mtd->writesize <= 512) {\r\noobregion->offset = 0;\r\noobregion->length = 5;\r\n} else {\r\noobregion->offset = 2;\r\noobregion->length = 4;\r\n}\r\n} else {\r\noobregion->offset = ((section - 1) * 16) +\r\nnand_chip->ecc.bytes + 6;\r\nif (section < nand_chip->ecc.steps)\r\noobregion->length = (section * 16) + 6 -\r\noobregion->offset;\r\nelse\r\noobregion->length = mtd->oobsize - oobregion->offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxc_v2_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nint stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;\r\nif (section >= nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = (section * stepsize) + 7;\r\noobregion->length = nand_chip->ecc.bytes;\r\nreturn 0;\r\n}\r\nstatic int mxc_v2_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nint stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;\r\nif (section >= nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\nif (!section) {\r\nif (mtd->writesize <= 512) {\r\noobregion->offset = 0;\r\noobregion->length = 5;\r\n} else {\r\noobregion->offset = 2;\r\noobregion->length = 4;\r\n}\r\n} else {\r\noobregion->offset = section * stepsize;\r\noobregion->length = 7;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_eccsize(struct mtd_info *mtd)\r\n{\r\nint oobbytes_per_512 = 0;\r\noobbytes_per_512 = mtd->oobsize * 512 / mtd->writesize;\r\nif (oobbytes_per_512 < 26)\r\nreturn 4;\r\nelse\r\nreturn 8;\r\n}\r\nstatic void preset_v1(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint16_t config1 = 0;\r\nif (nand_chip->ecc.mode == NAND_ECC_HW && mtd->writesize)\r\nconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\r\nif (!host->devtype_data->irqpending_quirk)\r\nconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nhost->eccsize = 1;\r\nwritew(config1, NFC_V1_V2_CONFIG1);\r\nwritew(0x2, NFC_V1_V2_CONFIG);\r\nwritew(0x0, NFC_V1_UNLOCKSTART_BLKADDR);\r\nwritew(0xffff, NFC_V1_UNLOCKEND_BLKADDR);\r\nwritew(0x4, NFC_V1_V2_WRPROT);\r\n}\r\nstatic int mxc_nand_v2_setup_data_interface(struct mtd_info *mtd,\r\nconst struct nand_data_interface *conf,\r\nbool check_only)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nint tRC_min_ns, tRC_ps, ret;\r\nunsigned long rate, rate_round;\r\nconst struct nand_sdr_timings *timings;\r\nu16 config1;\r\ntimings = nand_get_sdr_timings(conf);\r\nif (IS_ERR(timings))\r\nreturn -ENOTSUPP;\r\nconfig1 = readw(NFC_V1_V2_CONFIG1);\r\ntRC_min_ns = timings->tRC_min / 1000;\r\nrate = 1000000000 / tRC_min_ns;\r\nif (tRC_min_ns < 30) {\r\nrate_round = clk_round_rate(host->clk, rate);\r\nconfig1 |= NFC_V2_CONFIG1_ONE_CYCLE;\r\ntRC_ps = 1000000000 / (rate_round / 1000);\r\n} else {\r\nrate *= 2;\r\nrate_round = clk_round_rate(host->clk, rate);\r\nconfig1 &= ~NFC_V2_CONFIG1_ONE_CYCLE;\r\ntRC_ps = 1000000000 / (rate_round / 1000 / 2);\r\n}\r\nif (timings->tCLS_min > tRC_ps - 1000 ||\r\ntimings->tCLH_min > tRC_ps - 2000 ||\r\ntimings->tCS_min > tRC_ps - 1000 ||\r\ntimings->tCH_min > tRC_ps - 2000 ||\r\ntimings->tWP_min > tRC_ps - 1500 ||\r\ntimings->tALS_min > tRC_ps ||\r\ntimings->tALH_min > tRC_ps - 3000 ||\r\ntimings->tDS_min > tRC_ps ||\r\ntimings->tDH_min > tRC_ps - 5000 ||\r\ntimings->tWC_min > 2 * tRC_ps ||\r\ntimings->tWH_min > tRC_ps - 2500 ||\r\ntimings->tRR_min > 6 * tRC_ps ||\r\ntimings->tRP_min > 3 * tRC_ps / 2 ||\r\ntimings->tRC_min > 2 * tRC_ps ||\r\ntimings->tREH_min > (tRC_ps / 2) - 2500) {\r\ndev_dbg(host->dev, "Timing out of bounds\n");\r\nreturn -EINVAL;\r\n}\r\nif (check_only)\r\nreturn 0;\r\nret = clk_set_rate(host->clk, rate);\r\nif (ret)\r\nreturn ret;\r\nwritew(config1, NFC_V1_V2_CONFIG1);\r\ndev_dbg(host->dev, "Setting rate to %ldHz, %s mode\n", rate_round,\r\nconfig1 & NFC_V2_CONFIG1_ONE_CYCLE ? "One cycle (EDO)" :\r\n"normal");\r\nreturn 0;\r\n}\r\nstatic void preset_v2(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nuint16_t config1 = 0;\r\nconfig1 |= NFC_V2_CONFIG1_FP_INT;\r\nif (!host->devtype_data->irqpending_quirk)\r\nconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\r\nif (mtd->writesize) {\r\nuint16_t pages_per_block = mtd->erasesize / mtd->writesize;\r\nif (nand_chip->ecc.mode == NAND_ECC_HW)\r\nconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\r\nhost->eccsize = get_eccsize(mtd);\r\nif (host->eccsize == 4)\r\nconfig1 |= NFC_V2_CONFIG1_ECC_MODE_4;\r\nconfig1 |= NFC_V2_CONFIG1_PPB(ffs(pages_per_block) - 6);\r\n} else {\r\nhost->eccsize = 1;\r\n}\r\nwritew(config1, NFC_V1_V2_CONFIG1);\r\nwritew(0x2, NFC_V1_V2_CONFIG);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR0);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR1);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR2);\r\nwritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR3);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR0);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR1);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR2);\r\nwritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR3);\r\nwritew(0x4, NFC_V1_V2_WRPROT);\r\n}\r\nstatic void preset_v3(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(chip);\r\nuint32_t config2, config3;\r\nint i, addr_phases;\r\nwritel(NFC_V3_CONFIG1_RBA(0), NFC_V3_CONFIG1);\r\nwritel(NFC_V3_IPC_CREQ, NFC_V3_IPC);\r\nwritel(NFC_V3_WRPROT_BLS_UNLOCK | NFC_V3_WRPROT_UNLOCK,\r\nNFC_V3_WRPROT);\r\nfor (i = 0; i < NAND_MAX_CHIPS; i++)\r\nwritel(0xffff << 16, NFC_V3_WRPROT_UNLOCK_BLK_ADD0 + (i << 2));\r\nwritel(0, NFC_V3_IPC);\r\nconfig2 = NFC_V3_CONFIG2_ONE_CYCLE |\r\nNFC_V3_CONFIG2_2CMD_PHASES |\r\nNFC_V3_CONFIG2_SPAS(mtd->oobsize >> 1) |\r\nNFC_V3_CONFIG2_ST_CMD(0x70) |\r\nNFC_V3_CONFIG2_INT_MSK |\r\nNFC_V3_CONFIG2_NUM_ADDR_PHASE0;\r\naddr_phases = fls(chip->pagemask) >> 3;\r\nif (mtd->writesize == 2048) {\r\nconfig2 |= NFC_V3_CONFIG2_PS_2048;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\r\n} else if (mtd->writesize == 4096) {\r\nconfig2 |= NFC_V3_CONFIG2_PS_4096;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\r\n} else {\r\nconfig2 |= NFC_V3_CONFIG2_PS_512;\r\nconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases - 1);\r\n}\r\nif (mtd->writesize) {\r\nif (chip->ecc.mode == NAND_ECC_HW)\r\nconfig2 |= NFC_V3_CONFIG2_ECC_EN;\r\nconfig2 |= NFC_V3_CONFIG2_PPB(\r\nffs(mtd->erasesize / mtd->writesize) - 6,\r\nhost->devtype_data->ppb_shift);\r\nhost->eccsize = get_eccsize(mtd);\r\nif (host->eccsize == 8)\r\nconfig2 |= NFC_V3_CONFIG2_ECC_MODE_8;\r\n}\r\nwritel(config2, NFC_V3_CONFIG2);\r\nconfig3 = NFC_V3_CONFIG3_NUM_OF_DEVICES(0) |\r\nNFC_V3_CONFIG3_NO_SDMA |\r\nNFC_V3_CONFIG3_RBB_MODE |\r\nNFC_V3_CONFIG3_SBB(6) |\r\nNFC_V3_CONFIG3_ADD_OP(0);\r\nif (!(chip->options & NAND_BUSWIDTH_16))\r\nconfig3 |= NFC_V3_CONFIG3_FW8;\r\nwritel(config3, NFC_V3_CONFIG3);\r\nwritel(0, NFC_V3_DELAY_LINE);\r\n}\r\nstatic void mxc_nand_command(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\npr_debug("mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",\r\ncommand, column, page_addr);\r\nhost->status_request = false;\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nhost->devtype_data->preset(mtd);\r\nhost->devtype_data->send_cmd(host, command, false);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nhost->buf_start = 0;\r\nhost->status_request = true;\r\nhost->devtype_data->send_cmd(host, command, true);\r\nWARN_ONCE(column != -1 || page_addr != -1,\r\n"Unexpected column/row value (cmd=%u, col=%d, row=%d)\n",\r\ncommand, column, page_addr);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\nif (command == NAND_CMD_READ0)\r\nhost->buf_start = column;\r\nelse\r\nhost->buf_start = column + mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\nhost->devtype_data->send_cmd(host, command, false);\r\nWARN_ONCE(column < 0,\r\n"Unexpected column/row value (cmd=%u, col=%d, row=%d)\n",\r\ncommand, column, page_addr);\r\nmxc_do_addr_cycle(mtd, 0, page_addr);\r\nif (mtd->writesize > 512)\r\nhost->devtype_data->send_cmd(host,\r\nNAND_CMD_READSTART, true);\r\nhost->devtype_data->send_page(mtd, NFC_OUTPUT);\r\nmemcpy32_fromio(host->data_buf, host->main_area0,\r\nmtd->writesize);\r\ncopy_spare(mtd, true);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nif (column >= mtd->writesize)\r\nmxc_nand_command(mtd, NAND_CMD_READ0, 0, page_addr);\r\nhost->buf_start = column;\r\nhost->devtype_data->send_cmd(host, command, false);\r\nWARN_ONCE(column < -1,\r\n"Unexpected column/row value (cmd=%u, col=%d, row=%d)\n",\r\ncommand, column, page_addr);\r\nmxc_do_addr_cycle(mtd, 0, page_addr);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nmemcpy32_toio(host->main_area0, host->data_buf, mtd->writesize);\r\ncopy_spare(mtd, false);\r\nhost->devtype_data->send_page(mtd, NFC_INPUT);\r\nhost->devtype_data->send_cmd(host, command, true);\r\nWARN_ONCE(column != -1 || page_addr != -1,\r\n"Unexpected column/row value (cmd=%u, col=%d, row=%d)\n",\r\ncommand, column, page_addr);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nhost->devtype_data->send_cmd(host, command, true);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nhost->devtype_data->send_read_id(host);\r\nhost->buf_start = 0;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\nhost->devtype_data->send_cmd(host, command, false);\r\nWARN_ONCE(column != -1,\r\n"Unexpected column value (cmd=%u, col=%d)\n",\r\ncommand, column);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\nhost->devtype_data->send_cmd(host, command, false);\r\nmxc_do_addr_cycle(mtd, column, page_addr);\r\nhost->devtype_data->send_page(mtd, NFC_OUTPUT);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 512);\r\nhost->buf_start = 0;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Unimplemented command (cmd=%u)\n",\r\ncommand);\r\nbreak;\r\n}\r\n}\r\nstatic int mxc_nand_onfi_set_features(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int addr,\r\nu8 *subfeature_param)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nint i;\r\nif (!chip->onfi_version ||\r\n!(le16_to_cpu(chip->onfi_params.opt_cmd)\r\n& ONFI_OPT_CMD_SET_GET_FEATURES))\r\nreturn -EINVAL;\r\nhost->buf_start = 0;\r\nfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\r\nchip->write_byte(mtd, subfeature_param[i]);\r\nmemcpy32_toio(host->main_area0, host->data_buf, mtd->writesize);\r\nhost->devtype_data->send_cmd(host, NAND_CMD_SET_FEATURES, false);\r\nmxc_do_addr_cycle(mtd, addr, -1);\r\nhost->devtype_data->send_page(mtd, NFC_INPUT);\r\nreturn 0;\r\n}\r\nstatic int mxc_nand_onfi_get_features(struct mtd_info *mtd,\r\nstruct nand_chip *chip, int addr,\r\nu8 *subfeature_param)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\r\nint i;\r\nif (!chip->onfi_version ||\r\n!(le16_to_cpu(chip->onfi_params.opt_cmd)\r\n& ONFI_OPT_CMD_SET_GET_FEATURES))\r\nreturn -EINVAL;\r\nhost->devtype_data->send_cmd(host, NAND_CMD_GET_FEATURES, false);\r\nmxc_do_addr_cycle(mtd, addr, -1);\r\nhost->devtype_data->send_page(mtd, NFC_OUTPUT);\r\nmemcpy32_fromio(host->data_buf, host->main_area0, 512);\r\nhost->buf_start = 0;\r\nfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\r\n*subfeature_param++ = chip->read_byte(mtd);\r\nreturn 0;\r\n}\r\nstatic inline int is_imx21_nfc(struct mxc_nand_host *host)\r\n{\r\nreturn host->devtype_data == &imx21_nand_devtype_data;\r\n}\r\nstatic inline int is_imx27_nfc(struct mxc_nand_host *host)\r\n{\r\nreturn host->devtype_data == &imx27_nand_devtype_data;\r\n}\r\nstatic inline int is_imx25_nfc(struct mxc_nand_host *host)\r\n{\r\nreturn host->devtype_data == &imx25_nand_devtype_data;\r\n}\r\nstatic inline int is_imx51_nfc(struct mxc_nand_host *host)\r\n{\r\nreturn host->devtype_data == &imx51_nand_devtype_data;\r\n}\r\nstatic inline int is_imx53_nfc(struct mxc_nand_host *host)\r\n{\r\nreturn host->devtype_data == &imx53_nand_devtype_data;\r\n}\r\nstatic int __init mxcnd_probe_dt(struct mxc_nand_host *host)\r\n{\r\nstruct device_node *np = host->dev->of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxcnd_dt_ids, host->dev);\r\nif (!np)\r\nreturn 1;\r\nhost->devtype_data = of_id->data;\r\nreturn 0;\r\n}\r\nstatic int __init mxcnd_probe_dt(struct mxc_nand_host *host)\r\n{\r\nreturn 1;\r\n}\r\nstatic int mxcnd_probe(struct platform_device *pdev)\r\n{\r\nstruct nand_chip *this;\r\nstruct mtd_info *mtd;\r\nstruct mxc_nand_host *host;\r\nstruct resource *res;\r\nint err = 0;\r\nhost = devm_kzalloc(&pdev->dev, sizeof(struct mxc_nand_host),\r\nGFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->data_buf = devm_kzalloc(&pdev->dev, PAGE_SIZE, GFP_KERNEL);\r\nif (!host->data_buf)\r\nreturn -ENOMEM;\r\nhost->dev = &pdev->dev;\r\nthis = &host->nand;\r\nmtd = nand_to_mtd(this);\r\nmtd->dev.parent = &pdev->dev;\r\nmtd->name = DRIVER_NAME;\r\nthis->chip_delay = 5;\r\nnand_set_controller_data(this, host);\r\nnand_set_flash_node(this, pdev->dev.of_node),\r\nthis->dev_ready = mxc_nand_dev_ready;\r\nthis->cmdfunc = mxc_nand_command;\r\nthis->read_byte = mxc_nand_read_byte;\r\nthis->read_word = mxc_nand_read_word;\r\nthis->write_buf = mxc_nand_write_buf;\r\nthis->read_buf = mxc_nand_read_buf;\r\nthis->onfi_set_features = mxc_nand_onfi_set_features;\r\nthis->onfi_get_features = mxc_nand_onfi_get_features;\r\nhost->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk))\r\nreturn PTR_ERR(host->clk);\r\nerr = mxcnd_probe_dt(host);\r\nif (err > 0) {\r\nstruct mxc_nand_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nif (pdata) {\r\nhost->pdata = *pdata;\r\nhost->devtype_data = (struct mxc_nand_devtype_data *)\r\npdev->id_entry->driver_data;\r\n} else {\r\nerr = -ENODEV;\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nthis->setup_data_interface = host->devtype_data->setup_data_interface;\r\nif (host->devtype_data->needs_ip) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->regs_ip = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->regs_ip))\r\nreturn PTR_ERR(host->regs_ip);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\n} else {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\n}\r\nhost->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->base))\r\nreturn PTR_ERR(host->base);\r\nhost->main_area0 = host->base;\r\nif (host->devtype_data->regs_offset)\r\nhost->regs = host->base + host->devtype_data->regs_offset;\r\nhost->spare0 = host->base + host->devtype_data->spare0_offset;\r\nif (host->devtype_data->axi_offset)\r\nhost->regs_axi = host->base + host->devtype_data->axi_offset;\r\nthis->ecc.bytes = host->devtype_data->eccbytes;\r\nhost->eccsize = host->devtype_data->eccsize;\r\nthis->select_chip = host->devtype_data->select_chip;\r\nthis->ecc.size = 512;\r\nmtd_set_ooblayout(mtd, host->devtype_data->ooblayout);\r\nif (host->pdata.hw_ecc) {\r\nthis->ecc.mode = NAND_ECC_HW;\r\n} else {\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nthis->ecc.algo = NAND_ECC_HAMMING;\r\n}\r\nif (host->pdata.width == 2)\r\nthis->options |= NAND_BUSWIDTH_16;\r\nif (host->pdata.flash_bbt)\r\nthis->bbt_options |= NAND_BBT_USE_FLASH;\r\ninit_completion(&host->op_completion);\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (host->irq < 0)\r\nreturn host->irq;\r\nhost->devtype_data->irq_control(host, 0);\r\nerr = devm_request_irq(&pdev->dev, host->irq, mxc_nfc_irq,\r\n0, DRIVER_NAME, host);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(host->clk);\r\nif (err)\r\nreturn err;\r\nhost->clk_act = 1;\r\nif (host->devtype_data->irqpending_quirk) {\r\ndisable_irq_nosync(host->irq);\r\nhost->devtype_data->irq_control(host, 1);\r\n}\r\nerr = nand_scan_ident(mtd, is_imx25_nfc(host) ? 4 : 1, NULL);\r\nif (err)\r\ngoto escan;\r\nswitch (this->ecc.mode) {\r\ncase NAND_ECC_HW:\r\nthis->ecc.calculate = mxc_nand_calculate_ecc;\r\nthis->ecc.hwctl = mxc_nand_enable_hwecc;\r\nthis->ecc.correct = host->devtype_data->correct_data;\r\nbreak;\r\ncase NAND_ECC_SOFT:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto escan;\r\n}\r\nif (this->bbt_options & NAND_BBT_USE_FLASH) {\r\nthis->bbt_td = &bbt_main_descr;\r\nthis->bbt_md = &bbt_mirror_descr;\r\n}\r\ndevm_kfree(&pdev->dev, (void *)host->data_buf);\r\nhost->data_buf = devm_kzalloc(&pdev->dev, mtd->writesize + mtd->oobsize,\r\nGFP_KERNEL);\r\nif (!host->data_buf) {\r\nerr = -ENOMEM;\r\ngoto escan;\r\n}\r\nhost->devtype_data->preset(mtd);\r\nif (!this->ecc.bytes) {\r\nif (host->eccsize == 8)\r\nthis->ecc.bytes = 18;\r\nelse if (host->eccsize == 4)\r\nthis->ecc.bytes = 9;\r\n}\r\nhost->used_oobsize = min(mtd->oobsize, 218U);\r\nif (this->ecc.mode == NAND_ECC_HW) {\r\nif (is_imx21_nfc(host) || is_imx27_nfc(host))\r\nthis->ecc.strength = 1;\r\nelse\r\nthis->ecc.strength = (host->eccsize == 4) ? 4 : 8;\r\n}\r\nerr = nand_scan_tail(mtd);\r\nif (err)\r\ngoto escan;\r\nmtd_device_parse_register(mtd, part_probes,\r\nNULL,\r\nhost->pdata.parts,\r\nhost->pdata.nr_parts);\r\nplatform_set_drvdata(pdev, host);\r\nreturn 0;\r\nescan:\r\nif (host->clk_act)\r\nclk_disable_unprepare(host->clk);\r\nreturn err;\r\n}\r\nstatic int mxcnd_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_nand_host *host = platform_get_drvdata(pdev);\r\nnand_release(nand_to_mtd(&host->nand));\r\nif (host->clk_act)\r\nclk_disable_unprepare(host->clk);\r\nreturn 0;\r\n}
