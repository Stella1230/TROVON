static __init bool sead3_detect(void)\r\n{\r\nuint32_t rev;\r\nrev = __raw_readl((void *)MIPS_REVISION);\r\nreturn (rev & MIPS_REVISION_MACHINE) == MIPS_REVISION_MACHINE_SEAD3;\r\n}\r\nstatic __init int append_cmdline(void *fdt)\r\n{\r\nint err, chosen_off;\r\nchosen_off = fdt_path_offset(fdt, "/chosen");\r\nif (chosen_off == -FDT_ERR_NOTFOUND)\r\nchosen_off = fdt_path_offset(fdt, "/chosen@0");\r\nif (chosen_off == -FDT_ERR_NOTFOUND)\r\nchosen_off = fdt_add_subnode(fdt, 0, "chosen");\r\nif (chosen_off < 0) {\r\npr_err("Unable to find or add DT chosen node: %d\n",\r\nchosen_off);\r\nreturn chosen_off;\r\n}\r\nerr = fdt_setprop_string(fdt, chosen_off, "bootargs", fw_getcmdline());\r\nif (err) {\r\npr_err("Unable to set bootargs property: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int append_memory(void *fdt)\r\n{\r\nunsigned long phys_memsize, memsize;\r\n__be32 mem_array[2];\r\nint err, mem_off;\r\nchar *var;\r\nvar = fw_getenv("memsize");\r\nif (var) {\r\nerr = kstrtoul(var, 0, &phys_memsize);\r\nif (err) {\r\npr_err("Failed to read memsize env variable '%s'\n",\r\nvar);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npr_warn("The bootloader didn't provide memsize: defaulting to 32MB\n");\r\nphys_memsize = 32 << 20;\r\n}\r\nmemsize = phys_memsize;\r\nvar = strstr(arcs_cmdline, "memsize=");\r\nif (var)\r\nmemsize = memparse(var + strlen("memsize="), NULL);\r\nphys_memsize = max_t(unsigned long, phys_memsize, memsize);\r\nmem_off = fdt_path_offset(fdt, "/memory");\r\nif (mem_off == -FDT_ERR_NOTFOUND)\r\nmem_off = fdt_add_subnode(fdt, 0, "memory");\r\nif (mem_off < 0) {\r\npr_err("Unable to find or add memory DT node: %d\n", mem_off);\r\nreturn mem_off;\r\n}\r\nerr = fdt_setprop_string(fdt, mem_off, "device_type", "memory");\r\nif (err) {\r\npr_err("Unable to set memory node device_type: %d\n", err);\r\nreturn err;\r\n}\r\nmem_array[0] = 0;\r\nmem_array[1] = cpu_to_be32(phys_memsize);\r\nerr = fdt_setprop(fdt, mem_off, "reg", mem_array, sizeof(mem_array));\r\nif (err) {\r\npr_err("Unable to set memory regs property: %d\n", err);\r\nreturn err;\r\n}\r\nmem_array[0] = 0;\r\nmem_array[1] = cpu_to_be32(memsize);\r\nerr = fdt_setprop(fdt, mem_off, "linux,usable-memory",\r\nmem_array, sizeof(mem_array));\r\nif (err) {\r\npr_err("Unable to set linux,usable-memory property: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int remove_gic(void *fdt)\r\n{\r\nconst unsigned int cpu_ehci_int = 2;\r\nconst unsigned int cpu_uart_int = 4;\r\nconst unsigned int cpu_eth_int = 6;\r\nint gic_off, cpu_off, uart_off, eth_off, ehci_off, err;\r\nuint32_t cfg, cpu_phandle;\r\ncfg = __raw_readl((uint32_t *)SEAD_CONFIG);\r\nif (cfg & SEAD_CONFIG_GIC_PRESENT)\r\nreturn 0;\r\ngic_off = fdt_node_offset_by_compatible(fdt, -1, "mti,gic");\r\nif (gic_off < 0) {\r\npr_err("unable to find DT GIC node: %d\n", gic_off);\r\nreturn gic_off;\r\n}\r\nerr = fdt_nop_node(fdt, gic_off);\r\nif (err) {\r\npr_err("unable to nop GIC node\n");\r\nreturn err;\r\n}\r\ncpu_off = fdt_node_offset_by_compatible(fdt, -1,\r\n"mti,cpu-interrupt-controller");\r\nif (cpu_off < 0) {\r\npr_err("unable to find CPU intc node: %d\n", cpu_off);\r\nreturn cpu_off;\r\n}\r\ncpu_phandle = fdt_get_phandle(fdt, cpu_off);\r\nif (!cpu_phandle) {\r\npr_err("unable to get CPU intc phandle\n");\r\nreturn -EINVAL;\r\n}\r\nerr = fdt_setprop_u32(fdt, 0, "interrupt-parent", cpu_phandle);\r\nif (err) {\r\npr_err("unable to set root interrupt-parent: %d\n", err);\r\nreturn err;\r\n}\r\nuart_off = fdt_node_offset_by_compatible(fdt, -1, "ns16550a");\r\nwhile (uart_off >= 0) {\r\nerr = fdt_setprop_u32(fdt, uart_off, "interrupts",\r\ncpu_uart_int);\r\nif (err) {\r\npr_err("unable to set UART interrupts property: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nuart_off = fdt_node_offset_by_compatible(fdt, uart_off,\r\n"ns16550a");\r\n}\r\nif (uart_off != -FDT_ERR_NOTFOUND) {\r\npr_err("error searching for UART DT node: %d\n", uart_off);\r\nreturn uart_off;\r\n}\r\neth_off = fdt_node_offset_by_compatible(fdt, -1, "smsc,lan9115");\r\nif (eth_off < 0) {\r\npr_err("unable to find ethernet DT node: %d\n", eth_off);\r\nreturn eth_off;\r\n}\r\nerr = fdt_setprop_u32(fdt, eth_off, "interrupts", cpu_eth_int);\r\nif (err) {\r\npr_err("unable to set ethernet interrupts property: %d\n", err);\r\nreturn err;\r\n}\r\nehci_off = fdt_node_offset_by_compatible(fdt, -1, "generic-ehci");\r\nif (ehci_off < 0) {\r\npr_err("unable to find EHCI DT node: %d\n", ehci_off);\r\nreturn ehci_off;\r\n}\r\nerr = fdt_setprop_u32(fdt, ehci_off, "interrupts", cpu_ehci_int);\r\nif (err) {\r\npr_err("unable to set EHCI interrupts property: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int serial_config(void *fdt)\r\n{\r\nconst char *yamontty, *mode_var;\r\nchar mode_var_name[9], path[18], parity;\r\nunsigned int uart, baud, stop_bits;\r\nbool hw_flow;\r\nint chosen_off, err;\r\nyamontty = fw_getenv("yamontty");\r\nif (!yamontty || !strcmp(yamontty, "tty0")) {\r\nuart = 0;\r\n} else if (!strcmp(yamontty, "tty1")) {\r\nuart = 1;\r\n} else {\r\npr_warn("yamontty environment variable '%s' invalid\n",\r\nyamontty);\r\nuart = 0;\r\n}\r\nbaud = stop_bits = 0;\r\nparity = 0;\r\nhw_flow = false;\r\nsnprintf(mode_var_name, sizeof(mode_var_name), "modetty%u", uart);\r\nmode_var = fw_getenv(mode_var_name);\r\nif (mode_var) {\r\nwhile (mode_var[0] >= '0' && mode_var[0] <= '9') {\r\nbaud *= 10;\r\nbaud += mode_var[0] - '0';\r\nmode_var++;\r\n}\r\nif (mode_var[0] == ',')\r\nmode_var++;\r\nif (mode_var[0])\r\nparity = mode_var[0];\r\nif (mode_var[0] == ',')\r\nmode_var++;\r\nif (mode_var[0])\r\nstop_bits = mode_var[0] - '0';\r\nif (mode_var[0] == ',')\r\nmode_var++;\r\nif (!strcmp(mode_var, "hw"))\r\nhw_flow = true;\r\n}\r\nif (!baud)\r\nbaud = 38400;\r\nif (parity != 'e' && parity != 'n' && parity != 'o')\r\nparity = 'n';\r\nif (stop_bits != 7 && stop_bits != 8)\r\nstop_bits = 8;\r\nWARN_ON(snprintf(path, sizeof(path), "uart%u:%u%c%u%s",\r\nuart, baud, parity, stop_bits,\r\nhw_flow ? "r" : "") >= sizeof(path));\r\nchosen_off = fdt_path_offset(fdt, "/chosen");\r\nif (chosen_off == -FDT_ERR_NOTFOUND)\r\nchosen_off = fdt_path_offset(fdt, "/chosen@0");\r\nif (chosen_off == -FDT_ERR_NOTFOUND)\r\nchosen_off = fdt_add_subnode(fdt, 0, "chosen");\r\nif (chosen_off < 0) {\r\npr_err("Unable to find or add DT chosen node: %d\n",\r\nchosen_off);\r\nreturn chosen_off;\r\n}\r\nerr = fdt_setprop_string(fdt, chosen_off, "stdout-path", path);\r\nif (err) {\r\npr_err("Unable to set stdout-path property: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init const void *sead3_fixup_fdt(const void *fdt,\r\nconst void *match_data)\r\n{\r\nstatic unsigned char fdt_buf[16 << 10] __initdata;\r\nint err;\r\nif (fdt_check_header(fdt))\r\npanic("Corrupt DT");\r\nBUG_ON(fdt_node_check_compatible(fdt, 0, "mti,sead-3"));\r\nfw_init_cmdline();\r\nerr = fdt_open_into(fdt, fdt_buf, sizeof(fdt_buf));\r\nif (err)\r\npanic("Unable to open FDT: %d", err);\r\nerr = append_cmdline(fdt_buf);\r\nif (err)\r\npanic("Unable to patch FDT: %d", err);\r\nerr = append_memory(fdt_buf);\r\nif (err)\r\npanic("Unable to patch FDT: %d", err);\r\nerr = remove_gic(fdt_buf);\r\nif (err)\r\npanic("Unable to patch FDT: %d", err);\r\nerr = serial_config(fdt_buf);\r\nif (err)\r\npanic("Unable to patch FDT: %d", err);\r\nerr = fdt_pack(fdt_buf);\r\nif (err)\r\npanic("Unable to pack FDT: %d\n", err);\r\nreturn fdt_buf;\r\n}\r\nstatic __init unsigned int sead3_measure_hpt_freq(void)\r\n{\r\nvoid __iomem *status_reg = (void __iomem *)0xbf000410;\r\nunsigned int freq, orig, tick = 0;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\norig = readl(status_reg) & 0x2;\r\nwhile ((readl(status_reg) & 0x2) == orig)\r\n;\r\norig = orig ^ 0x2;\r\nwrite_c0_count(0);\r\nwhile (tick < 100) {\r\nwhile ((readl(status_reg) & 0x2) == orig)\r\n;\r\norig = orig ^ 0x2;\r\ntick++;\r\n}\r\nfreq = read_c0_count();\r\nlocal_irq_restore(flags);\r\nreturn freq;\r\n}
