struct rxrpc_connection *rxrpc_find_service_conn_rcu(struct rxrpc_peer *peer,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_connection *conn = NULL;\r\nstruct rxrpc_conn_proto k;\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct rb_node *p;\r\nunsigned int seq = 0;\r\nk.epoch = sp->hdr.epoch;\r\nk.cid = sp->hdr.cid & RXRPC_CIDMASK;\r\ndo {\r\nread_seqbegin_or_lock(&peer->service_conn_lock, &seq);\r\np = rcu_dereference_raw(peer->service_conns.rb_node);\r\nwhile (p) {\r\nconn = rb_entry(p, struct rxrpc_connection, service_node);\r\nif (conn->proto.index_key < k.index_key)\r\np = rcu_dereference_raw(p->rb_left);\r\nelse if (conn->proto.index_key > k.index_key)\r\np = rcu_dereference_raw(p->rb_right);\r\nelse\r\ngoto done;\r\nconn = NULL;\r\n}\r\n} while (need_seqretry(&peer->service_conn_lock, seq));\r\ndone:\r\ndone_seqretry(&peer->service_conn_lock, seq);\r\n_leave(" = %d", conn ? conn->debug_id : -1);\r\nreturn conn;\r\n}\r\nstatic void rxrpc_publish_service_conn(struct rxrpc_peer *peer,\r\nstruct rxrpc_connection *conn)\r\n{\r\nstruct rxrpc_connection *cursor = NULL;\r\nstruct rxrpc_conn_proto k = conn->proto;\r\nstruct rb_node **pp, *parent;\r\nwrite_seqlock_bh(&peer->service_conn_lock);\r\npp = &peer->service_conns.rb_node;\r\nparent = NULL;\r\nwhile (*pp) {\r\nparent = *pp;\r\ncursor = rb_entry(parent,\r\nstruct rxrpc_connection, service_node);\r\nif (cursor->proto.index_key < k.index_key)\r\npp = &(*pp)->rb_left;\r\nelse if (cursor->proto.index_key > k.index_key)\r\npp = &(*pp)->rb_right;\r\nelse\r\ngoto found_extant_conn;\r\n}\r\nrb_link_node_rcu(&conn->service_node, parent, pp);\r\nrb_insert_color(&conn->service_node, &peer->service_conns);\r\nconn_published:\r\nset_bit(RXRPC_CONN_IN_SERVICE_CONNS, &conn->flags);\r\nwrite_sequnlock_bh(&peer->service_conn_lock);\r\n_leave(" = %d [new]", conn->debug_id);\r\nreturn;\r\nfound_extant_conn:\r\nif (atomic_read(&cursor->usage) == 0)\r\ngoto replace_old_connection;\r\nwrite_sequnlock_bh(&peer->service_conn_lock);\r\nBUG();\r\nreplace_old_connection:\r\n_debug("replace conn");\r\nrb_replace_node_rcu(&cursor->service_node,\r\n&conn->service_node,\r\n&peer->service_conns);\r\nclear_bit(RXRPC_CONN_IN_SERVICE_CONNS, &cursor->flags);\r\ngoto conn_published;\r\n}\r\nstruct rxrpc_connection *rxrpc_prealloc_service_connection(gfp_t gfp)\r\n{\r\nstruct rxrpc_connection *conn = rxrpc_alloc_connection(gfp);\r\nif (conn) {\r\nconn->state = RXRPC_CONN_SERVICE_PREALLOC;\r\natomic_set(&conn->usage, 2);\r\nwrite_lock(&rxrpc_connection_lock);\r\nlist_add_tail(&conn->link, &rxrpc_connections);\r\nlist_add_tail(&conn->proc_link, &rxrpc_connection_proc_list);\r\nwrite_unlock(&rxrpc_connection_lock);\r\ntrace_rxrpc_conn(conn, rxrpc_conn_new_service,\r\natomic_read(&conn->usage),\r\n__builtin_return_address(0));\r\n}\r\nreturn conn;\r\n}\r\nvoid rxrpc_new_incoming_connection(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\n_enter("");\r\nconn->proto.epoch = sp->hdr.epoch;\r\nconn->proto.cid = sp->hdr.cid & RXRPC_CIDMASK;\r\nconn->params.service_id = sp->hdr.serviceId;\r\nconn->security_ix = sp->hdr.securityIndex;\r\nconn->out_clientflag = 0;\r\nif (conn->security_ix)\r\nconn->state = RXRPC_CONN_SERVICE_UNSECURED;\r\nelse\r\nconn->state = RXRPC_CONN_SERVICE;\r\nrxrpc_publish_service_conn(conn->params.peer, conn);\r\n_net("CONNECTION new %d {%x}", conn->debug_id, conn->proto.cid);\r\n}\r\nvoid rxrpc_unpublish_service_conn(struct rxrpc_connection *conn)\r\n{\r\nstruct rxrpc_peer *peer = conn->params.peer;\r\nwrite_seqlock_bh(&peer->service_conn_lock);\r\nif (test_and_clear_bit(RXRPC_CONN_IN_SERVICE_CONNS, &conn->flags))\r\nrb_erase(&conn->service_node, &peer->service_conns);\r\nwrite_sequnlock_bh(&peer->service_conn_lock);\r\n}
