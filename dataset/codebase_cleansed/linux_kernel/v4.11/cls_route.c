static inline int route4_fastmap_hash(u32 id, int iif)\r\n{\r\nreturn id & 0xF;\r\n}\r\nstatic void\r\nroute4_reset_fastmap(struct route4_head *head)\r\n{\r\nspin_lock_bh(&fastmap_lock);\r\nmemset(head->fastmap, 0, sizeof(head->fastmap));\r\nspin_unlock_bh(&fastmap_lock);\r\n}\r\nstatic void\r\nroute4_set_fastmap(struct route4_head *head, u32 id, int iif,\r\nstruct route4_filter *f)\r\n{\r\nint h = route4_fastmap_hash(id, iif);\r\nspin_lock_bh(&fastmap_lock);\r\nhead->fastmap[h].id = id;\r\nhead->fastmap[h].iif = iif;\r\nhead->fastmap[h].filter = f;\r\nspin_unlock_bh(&fastmap_lock);\r\n}\r\nstatic inline int route4_hash_to(u32 id)\r\n{\r\nreturn id & 0xFF;\r\n}\r\nstatic inline int route4_hash_from(u32 id)\r\n{\r\nreturn (id >> 16) & 0xF;\r\n}\r\nstatic inline int route4_hash_iif(int iif)\r\n{\r\nreturn 16 + ((iif >> 16) & 0xF);\r\n}\r\nstatic inline int route4_hash_wild(void)\r\n{\r\nreturn 32;\r\n}\r\nstatic int route4_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct route4_head *head = rcu_dereference_bh(tp->root);\r\nstruct dst_entry *dst;\r\nstruct route4_bucket *b;\r\nstruct route4_filter *f;\r\nu32 id, h;\r\nint iif, dont_cache = 0;\r\ndst = skb_dst(skb);\r\nif (!dst)\r\ngoto failure;\r\nid = dst->tclassid;\r\nif (head == NULL)\r\ngoto old_method;\r\niif = inet_iif(skb);\r\nh = route4_fastmap_hash(id, iif);\r\nspin_lock(&fastmap_lock);\r\nif (id == head->fastmap[h].id &&\r\niif == head->fastmap[h].iif &&\r\n(f = head->fastmap[h].filter) != NULL) {\r\nif (f == ROUTE4_FAILURE) {\r\nspin_unlock(&fastmap_lock);\r\ngoto failure;\r\n}\r\n*res = f->res;\r\nspin_unlock(&fastmap_lock);\r\nreturn 0;\r\n}\r\nspin_unlock(&fastmap_lock);\r\nh = route4_hash_to(id);\r\nrestart:\r\nb = rcu_dereference_bh(head->table[h]);\r\nif (b) {\r\nfor (f = rcu_dereference_bh(b->ht[route4_hash_from(id)]);\r\nf;\r\nf = rcu_dereference_bh(f->next))\r\nif (f->id == id)\r\nROUTE4_APPLY_RESULT();\r\nfor (f = rcu_dereference_bh(b->ht[route4_hash_iif(iif)]);\r\nf;\r\nf = rcu_dereference_bh(f->next))\r\nif (f->iif == iif)\r\nROUTE4_APPLY_RESULT();\r\nfor (f = rcu_dereference_bh(b->ht[route4_hash_wild()]);\r\nf;\r\nf = rcu_dereference_bh(f->next))\r\nROUTE4_APPLY_RESULT();\r\n}\r\nif (h < 256) {\r\nh = 256;\r\nid &= ~0xFFFF;\r\ngoto restart;\r\n}\r\nif (!dont_cache)\r\nroute4_set_fastmap(head, id, iif, ROUTE4_FAILURE);\r\nfailure:\r\nreturn -1;\r\nold_method:\r\nif (id && (TC_H_MAJ(id) == 0 ||\r\n!(TC_H_MAJ(id^tp->q->handle)))) {\r\nres->classid = id;\r\nres->class = 0;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic inline u32 to_hash(u32 id)\r\n{\r\nu32 h = id & 0xFF;\r\nif (id & 0x8000)\r\nh += 256;\r\nreturn h;\r\n}\r\nstatic inline u32 from_hash(u32 id)\r\n{\r\nid &= 0xFFFF;\r\nif (id == 0xFFFF)\r\nreturn 32;\r\nif (!(id & 0x8000)) {\r\nif (id > 255)\r\nreturn 256;\r\nreturn id & 0xF;\r\n}\r\nreturn 16 + (id & 0xF);\r\n}\r\nstatic unsigned long route4_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct route4_head *head = rtnl_dereference(tp->root);\r\nstruct route4_bucket *b;\r\nstruct route4_filter *f;\r\nunsigned int h1, h2;\r\nif (!head)\r\nreturn 0;\r\nh1 = to_hash(handle);\r\nif (h1 > 256)\r\nreturn 0;\r\nh2 = from_hash(handle >> 16);\r\nif (h2 > 32)\r\nreturn 0;\r\nb = rtnl_dereference(head->table[h1]);\r\nif (b) {\r\nfor (f = rtnl_dereference(b->ht[h2]);\r\nf;\r\nf = rtnl_dereference(f->next))\r\nif (f->handle == handle)\r\nreturn (unsigned long)f;\r\n}\r\nreturn 0;\r\n}\r\nstatic int route4_init(struct tcf_proto *tp)\r\n{\r\nstruct route4_head *head;\r\nhead = kzalloc(sizeof(struct route4_head), GFP_KERNEL);\r\nif (head == NULL)\r\nreturn -ENOBUFS;\r\nrcu_assign_pointer(tp->root, head);\r\nreturn 0;\r\n}\r\nstatic void route4_delete_filter(struct rcu_head *head)\r\n{\r\nstruct route4_filter *f = container_of(head, struct route4_filter, rcu);\r\ntcf_exts_destroy(&f->exts);\r\nkfree(f);\r\n}\r\nstatic bool route4_destroy(struct tcf_proto *tp, bool force)\r\n{\r\nstruct route4_head *head = rtnl_dereference(tp->root);\r\nint h1, h2;\r\nif (head == NULL)\r\nreturn true;\r\nif (!force) {\r\nfor (h1 = 0; h1 <= 256; h1++) {\r\nif (rcu_access_pointer(head->table[h1]))\r\nreturn false;\r\n}\r\n}\r\nfor (h1 = 0; h1 <= 256; h1++) {\r\nstruct route4_bucket *b;\r\nb = rtnl_dereference(head->table[h1]);\r\nif (b) {\r\nfor (h2 = 0; h2 <= 32; h2++) {\r\nstruct route4_filter *f;\r\nwhile ((f = rtnl_dereference(b->ht[h2])) != NULL) {\r\nstruct route4_filter *next;\r\nnext = rtnl_dereference(f->next);\r\nRCU_INIT_POINTER(b->ht[h2], next);\r\ntcf_unbind_filter(tp, &f->res);\r\ncall_rcu(&f->rcu, route4_delete_filter);\r\n}\r\n}\r\nRCU_INIT_POINTER(head->table[h1], NULL);\r\nkfree_rcu(b, rcu);\r\n}\r\n}\r\nRCU_INIT_POINTER(tp->root, NULL);\r\nkfree_rcu(head, rcu);\r\nreturn true;\r\n}\r\nstatic int route4_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct route4_head *head = rtnl_dereference(tp->root);\r\nstruct route4_filter *f = (struct route4_filter *)arg;\r\nstruct route4_filter __rcu **fp;\r\nstruct route4_filter *nf;\r\nstruct route4_bucket *b;\r\nunsigned int h = 0;\r\nint i;\r\nif (!head || !f)\r\nreturn -EINVAL;\r\nh = f->handle;\r\nb = f->bkt;\r\nfp = &b->ht[from_hash(h >> 16)];\r\nfor (nf = rtnl_dereference(*fp); nf;\r\nfp = &nf->next, nf = rtnl_dereference(*fp)) {\r\nif (nf == f) {\r\nRCU_INIT_POINTER(*fp, rtnl_dereference(f->next));\r\nroute4_reset_fastmap(head);\r\ntcf_unbind_filter(tp, &f->res);\r\ncall_rcu(&f->rcu, route4_delete_filter);\r\nfor (i = 0; i <= 32; i++) {\r\nstruct route4_filter *rt;\r\nrt = rtnl_dereference(b->ht[i]);\r\nif (rt)\r\nreturn 0;\r\n}\r\nRCU_INIT_POINTER(head->table[to_hash(h)], NULL);\r\nkfree_rcu(b, rcu);\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int route4_set_parms(struct net *net, struct tcf_proto *tp,\r\nunsigned long base, struct route4_filter *f,\r\nu32 handle, struct route4_head *head,\r\nstruct nlattr **tb, struct nlattr *est, int new,\r\nbool ovr)\r\n{\r\nu32 id = 0, to = 0, nhandle = 0x8000;\r\nstruct route4_filter *fp;\r\nunsigned int h1;\r\nstruct route4_bucket *b;\r\nstruct tcf_exts e;\r\nint err;\r\nerr = tcf_exts_init(&e, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_exts_validate(net, tp, tb, est, &e, ovr);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -EINVAL;\r\nif (tb[TCA_ROUTE4_TO]) {\r\nif (new && handle & 0x8000)\r\ngoto errout;\r\nto = nla_get_u32(tb[TCA_ROUTE4_TO]);\r\nif (to > 0xFF)\r\ngoto errout;\r\nnhandle = to;\r\n}\r\nif (tb[TCA_ROUTE4_FROM]) {\r\nif (tb[TCA_ROUTE4_IIF])\r\ngoto errout;\r\nid = nla_get_u32(tb[TCA_ROUTE4_FROM]);\r\nif (id > 0xFF)\r\ngoto errout;\r\nnhandle |= id << 16;\r\n} else if (tb[TCA_ROUTE4_IIF]) {\r\nid = nla_get_u32(tb[TCA_ROUTE4_IIF]);\r\nif (id > 0x7FFF)\r\ngoto errout;\r\nnhandle |= (id | 0x8000) << 16;\r\n} else\r\nnhandle |= 0xFFFF << 16;\r\nif (handle && new) {\r\nnhandle |= handle & 0x7F00;\r\nif (nhandle != handle)\r\ngoto errout;\r\n}\r\nh1 = to_hash(nhandle);\r\nb = rtnl_dereference(head->table[h1]);\r\nif (!b) {\r\nerr = -ENOBUFS;\r\nb = kzalloc(sizeof(struct route4_bucket), GFP_KERNEL);\r\nif (b == NULL)\r\ngoto errout;\r\nrcu_assign_pointer(head->table[h1], b);\r\n} else {\r\nunsigned int h2 = from_hash(nhandle >> 16);\r\nerr = -EEXIST;\r\nfor (fp = rtnl_dereference(b->ht[h2]);\r\nfp;\r\nfp = rtnl_dereference(fp->next))\r\nif (fp->handle == f->handle)\r\ngoto errout;\r\n}\r\nif (tb[TCA_ROUTE4_TO])\r\nf->id = to;\r\nif (tb[TCA_ROUTE4_FROM])\r\nf->id = to | id<<16;\r\nelse if (tb[TCA_ROUTE4_IIF])\r\nf->iif = id;\r\nf->handle = nhandle;\r\nf->bkt = b;\r\nf->tp = tp;\r\nif (tb[TCA_ROUTE4_CLASSID]) {\r\nf->res.classid = nla_get_u32(tb[TCA_ROUTE4_CLASSID]);\r\ntcf_bind_filter(tp, &f->res, base);\r\n}\r\ntcf_exts_change(tp, &f->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(&e);\r\nreturn err;\r\n}\r\nstatic int route4_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base, u32 handle,\r\nstruct nlattr **tca, unsigned long *arg, bool ovr)\r\n{\r\nstruct route4_head *head = rtnl_dereference(tp->root);\r\nstruct route4_filter __rcu **fp;\r\nstruct route4_filter *fold, *f1, *pfp, *f = NULL;\r\nstruct route4_bucket *b;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\r\nunsigned int h, th;\r\nint err;\r\nbool new = true;\r\nif (opt == NULL)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_ROUTE4_MAX, opt, route4_policy);\r\nif (err < 0)\r\nreturn err;\r\nfold = (struct route4_filter *)*arg;\r\nif (fold && handle && fold->handle != handle)\r\nreturn -EINVAL;\r\nerr = -ENOBUFS;\r\nf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\r\nif (!f)\r\ngoto errout;\r\nerr = tcf_exts_init(&f->exts, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\r\nif (err < 0)\r\ngoto errout;\r\nif (fold) {\r\nf->id = fold->id;\r\nf->iif = fold->iif;\r\nf->res = fold->res;\r\nf->handle = fold->handle;\r\nf->tp = fold->tp;\r\nf->bkt = fold->bkt;\r\nnew = false;\r\n}\r\nerr = route4_set_parms(net, tp, base, f, handle, head, tb,\r\ntca[TCA_RATE], new, ovr);\r\nif (err < 0)\r\ngoto errout;\r\nh = from_hash(f->handle >> 16);\r\nfp = &f->bkt->ht[h];\r\nfor (pfp = rtnl_dereference(*fp);\r\n(f1 = rtnl_dereference(*fp)) != NULL;\r\nfp = &f1->next)\r\nif (f->handle < f1->handle)\r\nbreak;\r\nnetif_keep_dst(qdisc_dev(tp->q));\r\nrcu_assign_pointer(f->next, f1);\r\nrcu_assign_pointer(*fp, f);\r\nif (fold && fold->handle && f->handle != fold->handle) {\r\nth = to_hash(fold->handle);\r\nh = from_hash(fold->handle >> 16);\r\nb = rtnl_dereference(head->table[th]);\r\nif (b) {\r\nfp = &b->ht[h];\r\nfor (pfp = rtnl_dereference(*fp); pfp;\r\nfp = &pfp->next, pfp = rtnl_dereference(*fp)) {\r\nif (pfp == f) {\r\n*fp = f->next;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nroute4_reset_fastmap(head);\r\n*arg = (unsigned long)f;\r\nif (fold) {\r\ntcf_unbind_filter(tp, &fold->res);\r\ncall_rcu(&fold->rcu, route4_delete_filter);\r\n}\r\nreturn 0;\r\nerrout:\r\nif (f)\r\ntcf_exts_destroy(&f->exts);\r\nkfree(f);\r\nreturn err;\r\n}\r\nstatic void route4_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct route4_head *head = rtnl_dereference(tp->root);\r\nunsigned int h, h1;\r\nif (head == NULL)\r\narg->stop = 1;\r\nif (arg->stop)\r\nreturn;\r\nfor (h = 0; h <= 256; h++) {\r\nstruct route4_bucket *b = rtnl_dereference(head->table[h]);\r\nif (b) {\r\nfor (h1 = 0; h1 <= 32; h1++) {\r\nstruct route4_filter *f;\r\nfor (f = rtnl_dereference(b->ht[h1]);\r\nf;\r\nf = rtnl_dereference(f->next)) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)f, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int route4_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct route4_filter *f = (struct route4_filter *)fh;\r\nstruct nlattr *nest;\r\nu32 id;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->handle;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (!(f->handle & 0x8000)) {\r\nid = f->id & 0xFF;\r\nif (nla_put_u32(skb, TCA_ROUTE4_TO, id))\r\ngoto nla_put_failure;\r\n}\r\nif (f->handle & 0x80000000) {\r\nif ((f->handle >> 16) != 0xFFFF &&\r\nnla_put_u32(skb, TCA_ROUTE4_IIF, f->iif))\r\ngoto nla_put_failure;\r\n} else {\r\nid = f->id >> 16;\r\nif (nla_put_u32(skb, TCA_ROUTE4_FROM, id))\r\ngoto nla_put_failure;\r\n}\r\nif (f->res.classid &&\r\nnla_put_u32(skb, TCA_ROUTE4_CLASSID, f->res.classid))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_route4(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_route4_ops);\r\n}\r\nstatic void __exit exit_route4(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_route4_ops);\r\n}
