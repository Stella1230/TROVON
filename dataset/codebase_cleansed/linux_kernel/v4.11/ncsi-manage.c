static inline int ncsi_filter_size(int table)\r\n{\r\nint sizes[] = { 2, 6, 6, 6 };\r\nBUILD_BUG_ON(ARRAY_SIZE(sizes) != NCSI_FILTER_MAX);\r\nif (table < NCSI_FILTER_BASE || table >= NCSI_FILTER_MAX)\r\nreturn -EINVAL;\r\nreturn sizes[table];\r\n}\r\nint ncsi_find_filter(struct ncsi_channel *nc, int table, void *data)\r\n{\r\nstruct ncsi_channel_filter *ncf;\r\nvoid *bitmap;\r\nint index, size;\r\nunsigned long flags;\r\nncf = nc->filters[table];\r\nif (!ncf)\r\nreturn -ENXIO;\r\nsize = ncsi_filter_size(table);\r\nif (size < 0)\r\nreturn size;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nbitmap = (void *)&ncf->bitmap;\r\nindex = -1;\r\nwhile ((index = find_next_bit(bitmap, ncf->total, index + 1))\r\n< ncf->total) {\r\nif (!memcmp(ncf->data + size * index, data, size)) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn index;\r\n}\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn -ENOENT;\r\n}\r\nint ncsi_add_filter(struct ncsi_channel *nc, int table, void *data)\r\n{\r\nstruct ncsi_channel_filter *ncf;\r\nint index, size;\r\nvoid *bitmap;\r\nunsigned long flags;\r\nsize = ncsi_filter_size(table);\r\nif (size < 0)\r\nreturn size;\r\nindex = ncsi_find_filter(nc, table, data);\r\nif (index >= 0)\r\nreturn index;\r\nncf = nc->filters[table];\r\nif (!ncf)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nbitmap = (void *)&ncf->bitmap;\r\ndo {\r\nindex = find_next_zero_bit(bitmap, ncf->total, 0);\r\nif (index >= ncf->total) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn -ENOSPC;\r\n}\r\n} while (test_and_set_bit(index, bitmap));\r\nmemcpy(ncf->data + size * index, data, size);\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn index;\r\n}\r\nint ncsi_remove_filter(struct ncsi_channel *nc, int table, int index)\r\n{\r\nstruct ncsi_channel_filter *ncf;\r\nint size;\r\nvoid *bitmap;\r\nunsigned long flags;\r\nsize = ncsi_filter_size(table);\r\nif (size < 0)\r\nreturn size;\r\nncf = nc->filters[table];\r\nif (!ncf || index >= ncf->total)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nbitmap = (void *)&ncf->bitmap;\r\nif (test_and_clear_bit(index, bitmap))\r\nmemset(ncf->data + size * index, 0, size);\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ncsi_report_link(struct ncsi_dev_priv *ndp, bool force_down)\r\n{\r\nstruct ncsi_dev *nd = &ndp->ndev;\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nunsigned long flags;\r\nnd->state = ncsi_dev_state_functional;\r\nif (force_down) {\r\nnd->link_up = 0;\r\ngoto report;\r\n}\r\nnd->link_up = 0;\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nspin_lock_irqsave(&nc->lock, flags);\r\nif (!list_empty(&nc->link) ||\r\nnc->state != NCSI_CHANNEL_ACTIVE) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\ncontinue;\r\n}\r\nif (nc->modes[NCSI_MODE_LINK].data[2] & 0x1) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nnd->link_up = 1;\r\ngoto report;\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\n}\r\n}\r\nreport:\r\nnd->handler(nd);\r\n}\r\nstatic void ncsi_channel_monitor(unsigned long data)\r\n{\r\nstruct ncsi_channel *nc = (struct ncsi_channel *)data;\r\nstruct ncsi_package *np = nc->package;\r\nstruct ncsi_dev_priv *ndp = np->ndp;\r\nstruct ncsi_cmd_arg nca;\r\nbool enabled, chained;\r\nunsigned int monitor_state;\r\nunsigned long flags;\r\nint state, ret;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nstate = nc->state;\r\nchained = !list_empty(&nc->link);\r\nenabled = nc->monitor.enabled;\r\nmonitor_state = nc->monitor.state;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nif (!enabled || chained)\r\nreturn;\r\nif (state != NCSI_CHANNEL_INACTIVE &&\r\nstate != NCSI_CHANNEL_ACTIVE)\r\nreturn;\r\nswitch (monitor_state) {\r\ncase NCSI_CHANNEL_MONITOR_START:\r\ncase NCSI_CHANNEL_MONITOR_RETRY:\r\nnca.ndp = ndp;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nnca.type = NCSI_PKT_CMD_GLS;\r\nnca.req_flags = 0;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret) {\r\nnetdev_err(ndp->ndev.dev, "Error %d sending GLS\n",\r\nret);\r\nreturn;\r\n}\r\nbreak;\r\ncase NCSI_CHANNEL_MONITOR_WAIT ... NCSI_CHANNEL_MONITOR_WAIT_MAX:\r\nbreak;\r\ndefault:\r\nif (!(ndp->flags & NCSI_DEV_HWA) &&\r\nstate == NCSI_CHANNEL_ACTIVE) {\r\nncsi_report_link(ndp, true);\r\nndp->flags |= NCSI_DEV_RESHUFFLE;\r\n}\r\nspin_lock_irqsave(&nc->lock, flags);\r\nnc->state = NCSI_CHANNEL_INVISIBLE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nncsi_process_next_channel(ndp);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&nc->lock, flags);\r\nnc->monitor.state++;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nmod_timer(&nc->monitor.timer, jiffies + HZ);\r\n}\r\nvoid ncsi_start_channel_monitor(struct ncsi_channel *nc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nWARN_ON_ONCE(nc->monitor.enabled);\r\nnc->monitor.enabled = true;\r\nnc->monitor.state = NCSI_CHANNEL_MONITOR_START;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nmod_timer(&nc->monitor.timer, jiffies + HZ);\r\n}\r\nvoid ncsi_stop_channel_monitor(struct ncsi_channel *nc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nif (!nc->monitor.enabled) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn;\r\n}\r\nnc->monitor.enabled = false;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\ndel_timer_sync(&nc->monitor.timer);\r\n}\r\nstruct ncsi_channel *ncsi_find_channel(struct ncsi_package *np,\r\nunsigned char id)\r\n{\r\nstruct ncsi_channel *nc;\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nif (nc->id == id)\r\nreturn nc;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ncsi_channel *ncsi_add_channel(struct ncsi_package *np, unsigned char id)\r\n{\r\nstruct ncsi_channel *nc, *tmp;\r\nint index;\r\nunsigned long flags;\r\nnc = kzalloc(sizeof(*nc), GFP_ATOMIC);\r\nif (!nc)\r\nreturn NULL;\r\nnc->id = id;\r\nnc->package = np;\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nnc->monitor.enabled = false;\r\nsetup_timer(&nc->monitor.timer,\r\nncsi_channel_monitor, (unsigned long)nc);\r\nspin_lock_init(&nc->lock);\r\nINIT_LIST_HEAD(&nc->link);\r\nfor (index = 0; index < NCSI_CAP_MAX; index++)\r\nnc->caps[index].index = index;\r\nfor (index = 0; index < NCSI_MODE_MAX; index++)\r\nnc->modes[index].index = index;\r\nspin_lock_irqsave(&np->lock, flags);\r\ntmp = ncsi_find_channel(np, id);\r\nif (tmp) {\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nkfree(nc);\r\nreturn tmp;\r\n}\r\nlist_add_tail_rcu(&nc->node, &np->channels);\r\nnp->channel_num++;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nreturn nc;\r\n}\r\nstatic void ncsi_remove_channel(struct ncsi_channel *nc)\r\n{\r\nstruct ncsi_package *np = nc->package;\r\nstruct ncsi_channel_filter *ncf;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nfor (i = 0; i < NCSI_FILTER_MAX; i++) {\r\nncf = nc->filters[i];\r\nif (!ncf)\r\ncontinue;\r\nnc->filters[i] = NULL;\r\nkfree(ncf);\r\n}\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nncsi_stop_channel_monitor(nc);\r\nspin_lock_irqsave(&np->lock, flags);\r\nlist_del_rcu(&nc->node);\r\nnp->channel_num--;\r\nspin_unlock_irqrestore(&np->lock, flags);\r\nkfree(nc);\r\n}\r\nstruct ncsi_package *ncsi_find_package(struct ncsi_dev_priv *ndp,\r\nunsigned char id)\r\n{\r\nstruct ncsi_package *np;\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nif (np->id == id)\r\nreturn np;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ncsi_package *ncsi_add_package(struct ncsi_dev_priv *ndp,\r\nunsigned char id)\r\n{\r\nstruct ncsi_package *np, *tmp;\r\nunsigned long flags;\r\nnp = kzalloc(sizeof(*np), GFP_ATOMIC);\r\nif (!np)\r\nreturn NULL;\r\nnp->id = id;\r\nnp->ndp = ndp;\r\nspin_lock_init(&np->lock);\r\nINIT_LIST_HEAD(&np->channels);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\ntmp = ncsi_find_package(ndp, id);\r\nif (tmp) {\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nkfree(np);\r\nreturn tmp;\r\n}\r\nlist_add_tail_rcu(&np->node, &ndp->packages);\r\nndp->package_num++;\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn np;\r\n}\r\nvoid ncsi_remove_package(struct ncsi_package *np)\r\n{\r\nstruct ncsi_dev_priv *ndp = np->ndp;\r\nstruct ncsi_channel *nc, *tmp;\r\nunsigned long flags;\r\nlist_for_each_entry_safe(nc, tmp, &np->channels, node)\r\nncsi_remove_channel(nc);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nlist_del_rcu(&np->node);\r\nndp->package_num--;\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nkfree(np);\r\n}\r\nvoid ncsi_find_package_and_channel(struct ncsi_dev_priv *ndp,\r\nunsigned char id,\r\nstruct ncsi_package **np,\r\nstruct ncsi_channel **nc)\r\n{\r\nstruct ncsi_package *p;\r\nstruct ncsi_channel *c;\r\np = ncsi_find_package(ndp, NCSI_PACKAGE_INDEX(id));\r\nc = p ? ncsi_find_channel(p, NCSI_CHANNEL_INDEX(id)) : NULL;\r\nif (np)\r\n*np = p;\r\nif (nc)\r\n*nc = c;\r\n}\r\nstruct ncsi_request *ncsi_alloc_request(struct ncsi_dev_priv *ndp,\r\nunsigned int req_flags)\r\n{\r\nstruct ncsi_request *nr = NULL;\r\nint i, limit = ARRAY_SIZE(ndp->requests);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nfor (i = ndp->request_id; i < limit; i++) {\r\nif (ndp->requests[i].used)\r\ncontinue;\r\nnr = &ndp->requests[i];\r\nnr->used = true;\r\nnr->flags = req_flags;\r\nndp->request_id = i + 1;\r\ngoto found;\r\n}\r\nfor (i = NCSI_REQ_START_IDX; i < ndp->request_id; i++) {\r\nif (ndp->requests[i].used)\r\ncontinue;\r\nnr = &ndp->requests[i];\r\nnr->used = true;\r\nnr->flags = req_flags;\r\nndp->request_id = i + 1;\r\ngoto found;\r\n}\r\nfound:\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn nr;\r\n}\r\nvoid ncsi_free_request(struct ncsi_request *nr)\r\n{\r\nstruct ncsi_dev_priv *ndp = nr->ndp;\r\nstruct sk_buff *cmd, *rsp;\r\nunsigned long flags;\r\nbool driven;\r\nif (nr->enabled) {\r\nnr->enabled = false;\r\ndel_timer_sync(&nr->timer);\r\n}\r\nspin_lock_irqsave(&ndp->lock, flags);\r\ncmd = nr->cmd;\r\nrsp = nr->rsp;\r\nnr->cmd = NULL;\r\nnr->rsp = NULL;\r\nnr->used = false;\r\ndriven = !!(nr->flags & NCSI_REQ_FLAG_EVENT_DRIVEN);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nif (driven && cmd && --ndp->pending_req_num == 0)\r\nschedule_work(&ndp->work);\r\nconsume_skb(cmd);\r\nconsume_skb(rsp);\r\n}\r\nstruct ncsi_dev *ncsi_find_dev(struct net_device *dev)\r\n{\r\nstruct ncsi_dev_priv *ndp;\r\nNCSI_FOR_EACH_DEV(ndp) {\r\nif (ndp->ndev.dev == dev)\r\nreturn &ndp->ndev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ncsi_request_timeout(unsigned long data)\r\n{\r\nstruct ncsi_request *nr = (struct ncsi_request *)data;\r\nstruct ncsi_dev_priv *ndp = nr->ndp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nnr->enabled = false;\r\nif (nr->rsp || !nr->cmd) {\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nncsi_free_request(nr);\r\n}\r\nstatic void ncsi_suspend_channel(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_dev *nd = &ndp->ndev;\r\nstruct ncsi_package *np = ndp->active_package;\r\nstruct ncsi_channel *nc = ndp->active_channel;\r\nstruct ncsi_cmd_arg nca;\r\nunsigned long flags;\r\nint ret;\r\nnca.ndp = ndp;\r\nnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\r\nswitch (nd->state) {\r\ncase ncsi_dev_state_suspend:\r\nnd->state = ncsi_dev_state_suspend_select;\r\ncase ncsi_dev_state_suspend_select:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_SP;\r\nnca.package = np->id;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nif (ndp->flags & NCSI_DEV_HWA)\r\nnca.bytes[0] = 0;\r\nelse\r\nnca.bytes[0] = 1;\r\nif (ndp->flags & NCSI_DEV_RESHUFFLE)\r\nnd->state = ncsi_dev_state_suspend_gls;\r\nelse\r\nnd->state = ncsi_dev_state_suspend_dcnt;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nbreak;\r\ncase ncsi_dev_state_suspend_gls:\r\nndp->pending_req_num = np->channel_num;\r\nnca.type = NCSI_PKT_CMD_GLS;\r\nnca.package = np->id;\r\nnd->state = ncsi_dev_state_suspend_dcnt;\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nnca.channel = nc->id;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nbreak;\r\ncase ncsi_dev_state_suspend_dcnt:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_DCNT;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nnd->state = ncsi_dev_state_suspend_dc;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nbreak;\r\ncase ncsi_dev_state_suspend_dc:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_DC;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nnca.bytes[0] = 1;\r\nnd->state = ncsi_dev_state_suspend_deselect;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nbreak;\r\ncase ncsi_dev_state_suspend_deselect:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_DP;\r\nnca.package = np->id;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nnd->state = ncsi_dev_state_suspend_done;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nbreak;\r\ncase ncsi_dev_state_suspend_done:\r\nspin_lock_irqsave(&nc->lock, flags);\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nncsi_process_next_channel(ndp);\r\nbreak;\r\ndefault:\r\nnetdev_warn(nd->dev, "Wrong NCSI state 0x%x in suspend\n",\r\nnd->state);\r\n}\r\nreturn;\r\nerror:\r\nnd->state = ncsi_dev_state_functional;\r\n}\r\nstatic void ncsi_configure_channel(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_dev *nd = &ndp->ndev;\r\nstruct net_device *dev = nd->dev;\r\nstruct ncsi_package *np = ndp->active_package;\r\nstruct ncsi_channel *nc = ndp->active_channel;\r\nstruct ncsi_channel *hot_nc = NULL;\r\nstruct ncsi_cmd_arg nca;\r\nunsigned char index;\r\nunsigned long flags;\r\nint ret;\r\nnca.ndp = ndp;\r\nnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\r\nswitch (nd->state) {\r\ncase ncsi_dev_state_config:\r\ncase ncsi_dev_state_config_sp:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_SP;\r\nif (ndp->flags & NCSI_DEV_HWA)\r\nnca.bytes[0] = 0;\r\nelse\r\nnca.bytes[0] = 1;\r\nnca.package = np->id;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nnd->state = ncsi_dev_state_config_cis;\r\nbreak;\r\ncase ncsi_dev_state_config_cis:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_CIS;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nnd->state = ncsi_dev_state_config_sma;\r\nbreak;\r\ncase ncsi_dev_state_config_sma:\r\ncase ncsi_dev_state_config_ebf:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase ncsi_dev_state_config_egmf:\r\n#endif\r\ncase ncsi_dev_state_config_ecnt:\r\ncase ncsi_dev_state_config_ec:\r\ncase ncsi_dev_state_config_ae:\r\ncase ncsi_dev_state_config_gls:\r\nndp->pending_req_num = 1;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nif (nd->state == ncsi_dev_state_config_sma) {\r\nnca.type = NCSI_PKT_CMD_SMA;\r\nfor (index = 0; index < 6; index++)\r\nnca.bytes[index] = dev->dev_addr[index];\r\nnca.bytes[6] = 0x1;\r\nnca.bytes[7] = 0x1;\r\nnd->state = ncsi_dev_state_config_ebf;\r\n} else if (nd->state == ncsi_dev_state_config_ebf) {\r\nnca.type = NCSI_PKT_CMD_EBF;\r\nnca.dwords[0] = nc->caps[NCSI_CAP_BC].cap;\r\nnd->state = ncsi_dev_state_config_ecnt;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (ndp->inet6_addr_num > 0 &&\r\n(nc->caps[NCSI_CAP_GENERIC].cap &\r\nNCSI_CAP_GENERIC_MC))\r\nnd->state = ncsi_dev_state_config_egmf;\r\nelse\r\nnd->state = ncsi_dev_state_config_ecnt;\r\n} else if (nd->state == ncsi_dev_state_config_egmf) {\r\nnca.type = NCSI_PKT_CMD_EGMF;\r\nnca.dwords[0] = nc->caps[NCSI_CAP_MC].cap;\r\nnd->state = ncsi_dev_state_config_ecnt;\r\n#endif\r\n} else if (nd->state == ncsi_dev_state_config_ecnt) {\r\nnca.type = NCSI_PKT_CMD_ECNT;\r\nnd->state = ncsi_dev_state_config_ec;\r\n} else if (nd->state == ncsi_dev_state_config_ec) {\r\nnca.type = NCSI_PKT_CMD_EC;\r\nnd->state = ncsi_dev_state_config_ae;\r\nif (!(nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK))\r\nnd->state = ncsi_dev_state_config_gls;\r\n} else if (nd->state == ncsi_dev_state_config_ae) {\r\nnca.type = NCSI_PKT_CMD_AE;\r\nnca.bytes[0] = 0;\r\nnca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;\r\nnd->state = ncsi_dev_state_config_gls;\r\n} else if (nd->state == ncsi_dev_state_config_gls) {\r\nnca.type = NCSI_PKT_CMD_GLS;\r\nnd->state = ncsi_dev_state_config_done;\r\n}\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nbreak;\r\ncase ncsi_dev_state_config_done:\r\nspin_lock_irqsave(&nc->lock, flags);\r\nif (nc->modes[NCSI_MODE_LINK].data[2] & 0x1) {\r\nhot_nc = nc;\r\nnc->state = NCSI_CHANNEL_ACTIVE;\r\n} else {\r\nhot_nc = NULL;\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nndp->hot_channel = hot_nc;\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nncsi_start_channel_monitor(nc);\r\nncsi_process_next_channel(ndp);\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "Wrong NCSI state 0x%x in config\n",\r\nnd->state);\r\n}\r\nreturn;\r\nerror:\r\nncsi_report_link(ndp, true);\r\n}\r\nstatic int ncsi_choose_active_channel(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc, *found, *hot_nc;\r\nstruct ncsi_channel_mode *ncm;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nhot_nc = ndp->hot_channel;\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nfound = NULL;\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nspin_lock_irqsave(&nc->lock, flags);\r\nif (!list_empty(&nc->link) ||\r\nnc->state != NCSI_CHANNEL_INACTIVE) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\ncontinue;\r\n}\r\nif (!found)\r\nfound = nc;\r\nif (nc == hot_nc)\r\nfound = nc;\r\nncm = &nc->modes[NCSI_MODE_LINK];\r\nif (ncm->data[2] & 0x1) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nfound = nc;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\n}\r\n}\r\nif (!found) {\r\nncsi_report_link(ndp, true);\r\nreturn -ENODEV;\r\n}\r\nout:\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nlist_add_tail_rcu(&found->link, &ndp->channel_queue);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn ncsi_process_next_channel(ndp);\r\n}\r\nstatic bool ncsi_check_hwa(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nunsigned int cap;\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\ncap = nc->caps[NCSI_CAP_GENERIC].cap;\r\nif (!(cap & NCSI_CAP_GENERIC_HWA) ||\r\n(cap & NCSI_CAP_GENERIC_HWA_MASK) !=\r\nNCSI_CAP_GENERIC_HWA_SUPPORT) {\r\nndp->flags &= ~NCSI_DEV_HWA;\r\nreturn false;\r\n}\r\n}\r\n}\r\nndp->flags |= NCSI_DEV_HWA;\r\nreturn true;\r\n}\r\nstatic int ncsi_enable_hwa(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nWARN_ON_ONCE(nc->state != NCSI_CHANNEL_INACTIVE ||\r\n!list_empty(&nc->link));\r\nncsi_stop_channel_monitor(nc);\r\nlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nif (list_empty(&ndp->channel_queue)) {\r\nncsi_report_link(ndp, false);\r\nreturn -ENOENT;\r\n}\r\nreturn ncsi_process_next_channel(ndp);\r\n}\r\nstatic void ncsi_probe_channel(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_dev *nd = &ndp->ndev;\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nstruct ncsi_cmd_arg nca;\r\nunsigned char index;\r\nint ret;\r\nnca.ndp = ndp;\r\nnca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;\r\nswitch (nd->state) {\r\ncase ncsi_dev_state_probe:\r\nnd->state = ncsi_dev_state_probe_deselect;\r\ncase ncsi_dev_state_probe_deselect:\r\nndp->pending_req_num = 8;\r\nnca.type = NCSI_PKT_CMD_DP;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nfor (index = 0; index < 8; index++) {\r\nnca.package = index;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nnd->state = ncsi_dev_state_probe_package;\r\nbreak;\r\ncase ncsi_dev_state_probe_package:\r\nndp->pending_req_num = 16;\r\nnca.type = NCSI_PKT_CMD_SP;\r\nnca.bytes[0] = 1;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nfor (index = 0; index < 8; index++) {\r\nnca.package = index;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nnca.type = NCSI_PKT_CMD_DP;\r\nfor (index = 0; index < 8; index++) {\r\nnca.package = index;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nnd->state = ncsi_dev_state_probe_channel;\r\nbreak;\r\ncase ncsi_dev_state_probe_channel:\r\nif (!ndp->active_package)\r\nndp->active_package = list_first_or_null_rcu(\r\n&ndp->packages, struct ncsi_package, node);\r\nelse if (list_is_last(&ndp->active_package->node,\r\n&ndp->packages))\r\nndp->active_package = NULL;\r\nelse\r\nndp->active_package = list_next_entry(\r\nndp->active_package, node);\r\nif (!ndp->active_package) {\r\nndp->flags |= NCSI_DEV_PROBED;\r\nif (ncsi_check_hwa(ndp))\r\nncsi_enable_hwa(ndp);\r\nelse\r\nncsi_choose_active_channel(ndp);\r\nreturn;\r\n}\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_SP;\r\nnca.bytes[0] = 1;\r\nnca.package = ndp->active_package->id;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nnd->state = ncsi_dev_state_probe_cis;\r\nbreak;\r\ncase ncsi_dev_state_probe_cis:\r\nndp->pending_req_num = NCSI_RESERVED_CHANNEL;\r\nnca.type = NCSI_PKT_CMD_CIS;\r\nnca.package = ndp->active_package->id;\r\nfor (index = 0; index < NCSI_RESERVED_CHANNEL; index++) {\r\nnca.channel = index;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nnd->state = ncsi_dev_state_probe_gvi;\r\nbreak;\r\ncase ncsi_dev_state_probe_gvi:\r\ncase ncsi_dev_state_probe_gc:\r\ncase ncsi_dev_state_probe_gls:\r\nnp = ndp->active_package;\r\nndp->pending_req_num = np->channel_num;\r\nif (nd->state == ncsi_dev_state_probe_gvi)\r\nnca.type = NCSI_PKT_CMD_GVI;\r\nelse if (nd->state == ncsi_dev_state_probe_gc)\r\nnca.type = NCSI_PKT_CMD_GC;\r\nelse\r\nnca.type = NCSI_PKT_CMD_GLS;\r\nnca.package = np->id;\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nnca.channel = nc->id;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\n}\r\nif (nd->state == ncsi_dev_state_probe_gvi)\r\nnd->state = ncsi_dev_state_probe_gc;\r\nelse if (nd->state == ncsi_dev_state_probe_gc)\r\nnd->state = ncsi_dev_state_probe_gls;\r\nelse\r\nnd->state = ncsi_dev_state_probe_dp;\r\nbreak;\r\ncase ncsi_dev_state_probe_dp:\r\nndp->pending_req_num = 1;\r\nnca.type = NCSI_PKT_CMD_DP;\r\nnca.package = ndp->active_package->id;\r\nnca.channel = NCSI_RESERVED_CHANNEL;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret)\r\ngoto error;\r\nnd->state = ncsi_dev_state_probe_channel;\r\nbreak;\r\ndefault:\r\nnetdev_warn(nd->dev, "Wrong NCSI state 0x%0x in enumeration\n",\r\nnd->state);\r\n}\r\nreturn;\r\nerror:\r\nncsi_report_link(ndp, true);\r\n}\r\nstatic void ncsi_dev_work(struct work_struct *work)\r\n{\r\nstruct ncsi_dev_priv *ndp = container_of(work,\r\nstruct ncsi_dev_priv, work);\r\nstruct ncsi_dev *nd = &ndp->ndev;\r\nswitch (nd->state & ncsi_dev_state_major) {\r\ncase ncsi_dev_state_probe:\r\nncsi_probe_channel(ndp);\r\nbreak;\r\ncase ncsi_dev_state_suspend:\r\nncsi_suspend_channel(ndp);\r\nbreak;\r\ncase ncsi_dev_state_config:\r\nncsi_configure_channel(ndp);\r\nbreak;\r\ndefault:\r\nnetdev_warn(nd->dev, "Wrong NCSI state 0x%x in workqueue\n",\r\nnd->state);\r\n}\r\n}\r\nint ncsi_process_next_channel(struct ncsi_dev_priv *ndp)\r\n{\r\nstruct ncsi_channel *nc;\r\nint old_state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nnc = list_first_or_null_rcu(&ndp->channel_queue,\r\nstruct ncsi_channel, link);\r\nif (!nc) {\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\ngoto out;\r\n}\r\nlist_del_init(&nc->link);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nspin_lock_irqsave(&nc->lock, flags);\r\nold_state = nc->state;\r\nnc->state = NCSI_CHANNEL_INVISIBLE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nndp->active_channel = nc;\r\nndp->active_package = nc->package;\r\nswitch (old_state) {\r\ncase NCSI_CHANNEL_INACTIVE:\r\nndp->ndev.state = ncsi_dev_state_config;\r\nncsi_configure_channel(ndp);\r\nbreak;\r\ncase NCSI_CHANNEL_ACTIVE:\r\nndp->ndev.state = ncsi_dev_state_suspend;\r\nncsi_suspend_channel(ndp);\r\nbreak;\r\ndefault:\r\nnetdev_err(ndp->ndev.dev, "Invalid state 0x%x on %d:%d\n",\r\nold_state, nc->package->id, nc->id);\r\nncsi_report_link(ndp, false);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nout:\r\nndp->active_channel = NULL;\r\nndp->active_package = NULL;\r\nif (ndp->flags & NCSI_DEV_RESHUFFLE) {\r\nndp->flags &= ~NCSI_DEV_RESHUFFLE;\r\nreturn ncsi_choose_active_channel(ndp);\r\n}\r\nncsi_report_link(ndp, false);\r\nreturn -ENODEV;\r\n}\r\nstatic int ncsi_inet6addr_event(struct notifier_block *this,\r\nunsigned long event, void *data)\r\n{\r\nstruct inet6_ifaddr *ifa = data;\r\nstruct net_device *dev = ifa->idev->dev;\r\nstruct ncsi_dev *nd = ncsi_find_dev(dev);\r\nstruct ncsi_dev_priv *ndp = nd ? TO_NCSI_DEV_PRIV(nd) : NULL;\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nstruct ncsi_cmd_arg nca;\r\nbool action;\r\nint ret;\r\nif (!ndp || (ipv6_addr_type(&ifa->addr) &\r\n(IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK)))\r\nreturn NOTIFY_OK;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\naction = (++ndp->inet6_addr_num) == 1;\r\nnca.type = NCSI_PKT_CMD_EGMF;\r\nbreak;\r\ncase NETDEV_DOWN:\r\naction = (--ndp->inet6_addr_num == 0);\r\nnca.type = NCSI_PKT_CMD_DGMF;\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_OK;\r\n}\r\nnp = ndp->active_package;\r\nnc = ndp->active_channel;\r\nif (!action || !np || !nc)\r\nreturn NOTIFY_OK;\r\nif (!(nc->caps[NCSI_CAP_GENERIC].cap & NCSI_CAP_GENERIC_MC))\r\nreturn NOTIFY_OK;\r\nnca.ndp = ndp;\r\nnca.req_flags = 0;\r\nnca.package = np->id;\r\nnca.channel = nc->id;\r\nnca.dwords[0] = nc->caps[NCSI_CAP_MC].cap;\r\nret = ncsi_xmit_cmd(&nca);\r\nif (ret) {\r\nnetdev_warn(dev, "Fail to %s global multicast filter (%d)\n",\r\n(event == NETDEV_UP) ? "enable" : "disable", ret);\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstruct ncsi_dev *ncsi_register_dev(struct net_device *dev,\r\nvoid (*handler)(struct ncsi_dev *ndev))\r\n{\r\nstruct ncsi_dev_priv *ndp;\r\nstruct ncsi_dev *nd;\r\nunsigned long flags;\r\nint i;\r\nnd = ncsi_find_dev(dev);\r\nif (nd)\r\nreturn nd;\r\nndp = kzalloc(sizeof(*ndp), GFP_ATOMIC);\r\nif (!ndp)\r\nreturn NULL;\r\nnd = &ndp->ndev;\r\nnd->state = ncsi_dev_state_registered;\r\nnd->dev = dev;\r\nnd->handler = handler;\r\nndp->pending_req_num = 0;\r\nINIT_LIST_HEAD(&ndp->channel_queue);\r\nINIT_WORK(&ndp->work, ncsi_dev_work);\r\nspin_lock_init(&ndp->lock);\r\nINIT_LIST_HEAD(&ndp->packages);\r\nndp->request_id = NCSI_REQ_START_IDX;\r\nfor (i = 0; i < ARRAY_SIZE(ndp->requests); i++) {\r\nndp->requests[i].id = i;\r\nndp->requests[i].ndp = ndp;\r\nsetup_timer(&ndp->requests[i].timer,\r\nncsi_request_timeout,\r\n(unsigned long)&ndp->requests[i]);\r\n}\r\nspin_lock_irqsave(&ncsi_dev_lock, flags);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nndp->inet6_addr_num = 0;\r\nif (list_empty(&ncsi_dev_list))\r\nregister_inet6addr_notifier(&ncsi_inet6addr_notifier);\r\n#endif\r\nlist_add_tail_rcu(&ndp->node, &ncsi_dev_list);\r\nspin_unlock_irqrestore(&ncsi_dev_lock, flags);\r\nndp->ptype.type = cpu_to_be16(ETH_P_NCSI);\r\nndp->ptype.func = ncsi_rcv_rsp;\r\nndp->ptype.dev = dev;\r\ndev_add_pack(&ndp->ptype);\r\nreturn nd;\r\n}\r\nint ncsi_start_dev(struct ncsi_dev *nd)\r\n{\r\nstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\r\nint ret;\r\nif (nd->state != ncsi_dev_state_registered &&\r\nnd->state != ncsi_dev_state_functional)\r\nreturn -ENOTTY;\r\nif (!(ndp->flags & NCSI_DEV_PROBED)) {\r\nnd->state = ncsi_dev_state_probe;\r\nschedule_work(&ndp->work);\r\nreturn 0;\r\n}\r\nif (ndp->flags & NCSI_DEV_HWA)\r\nret = ncsi_enable_hwa(ndp);\r\nelse\r\nret = ncsi_choose_active_channel(ndp);\r\nreturn ret;\r\n}\r\nvoid ncsi_stop_dev(struct ncsi_dev *nd)\r\n{\r\nstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\r\nstruct ncsi_package *np;\r\nstruct ncsi_channel *nc;\r\nbool chained;\r\nint old_state;\r\nunsigned long flags;\r\nNCSI_FOR_EACH_PACKAGE(ndp, np) {\r\nNCSI_FOR_EACH_CHANNEL(np, nc) {\r\nncsi_stop_channel_monitor(nc);\r\nspin_lock_irqsave(&nc->lock, flags);\r\nchained = !list_empty(&nc->link);\r\nold_state = nc->state;\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nWARN_ON_ONCE(chained ||\r\nold_state == NCSI_CHANNEL_INVISIBLE);\r\n}\r\n}\r\nncsi_report_link(ndp, true);\r\n}\r\nvoid ncsi_unregister_dev(struct ncsi_dev *nd)\r\n{\r\nstruct ncsi_dev_priv *ndp = TO_NCSI_DEV_PRIV(nd);\r\nstruct ncsi_package *np, *tmp;\r\nunsigned long flags;\r\ndev_remove_pack(&ndp->ptype);\r\nlist_for_each_entry_safe(np, tmp, &ndp->packages, node)\r\nncsi_remove_package(np);\r\nspin_lock_irqsave(&ncsi_dev_lock, flags);\r\nlist_del_rcu(&ndp->node);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (list_empty(&ncsi_dev_list))\r\nunregister_inet6addr_notifier(&ncsi_inet6addr_notifier);\r\n#endif\r\nspin_unlock_irqrestore(&ncsi_dev_lock, flags);\r\nkfree(ndp);\r\n}
