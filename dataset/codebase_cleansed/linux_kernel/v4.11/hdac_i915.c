int snd_hdac_set_codec_wakeup(struct hdac_bus *bus, bool enable)\r\n{\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nif (!acomp || !acomp->ops)\r\nreturn -ENODEV;\r\nif (!acomp->ops->codec_wake_override) {\r\ndev_warn(bus->dev,\r\n"Invalid codec wake callback\n");\r\nreturn 0;\r\n}\r\ndev_dbg(bus->dev, "%s codec wakeup\n",\r\nenable ? "enable" : "disable");\r\nacomp->ops->codec_wake_override(acomp->dev, enable);\r\nreturn 0;\r\n}\r\nint snd_hdac_display_power(struct hdac_bus *bus, bool enable)\r\n{\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nif (!acomp || !acomp->ops)\r\nreturn -ENODEV;\r\ndev_dbg(bus->dev, "display power %s\n",\r\nenable ? "enable" : "disable");\r\nif (enable) {\r\nif (!bus->i915_power_refcount++) {\r\nacomp->ops->get_power(acomp->dev);\r\nsnd_hdac_set_codec_wakeup(bus, true);\r\nsnd_hdac_set_codec_wakeup(bus, false);\r\n}\r\n} else {\r\nWARN_ON(!bus->i915_power_refcount);\r\nif (!--bus->i915_power_refcount)\r\nacomp->ops->put_power(acomp->dev);\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hdac_i915_set_bclk(struct hdac_bus *bus)\r\n{\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nstruct pci_dev *pci = to_pci_dev(bus->dev);\r\nint cdclk_freq;\r\nunsigned int bclk_m, bclk_n;\r\nif (!acomp || !acomp->ops || !acomp->ops->get_cdclk_freq)\r\nreturn;\r\nif (!CONTROLLER_IN_GPU(pci))\r\nreturn;\r\ncdclk_freq = acomp->ops->get_cdclk_freq(acomp->dev);\r\nswitch (cdclk_freq) {\r\ncase 337500:\r\nbclk_m = 16;\r\nbclk_n = 225;\r\nbreak;\r\ncase 450000:\r\ndefault:\r\nbclk_m = 4;\r\nbclk_n = 75;\r\nbreak;\r\ncase 540000:\r\nbclk_m = 4;\r\nbclk_n = 90;\r\nbreak;\r\ncase 675000:\r\nbclk_m = 8;\r\nbclk_n = 225;\r\nbreak;\r\n}\r\nsnd_hdac_chip_writew(bus, HSW_EM4, bclk_m);\r\nsnd_hdac_chip_writew(bus, HSW_EM5, bclk_n);\r\n}\r\nstatic int pin2port(struct hdac_device *codec, hda_nid_t pin_nid)\r\n{\r\nint base_nid;\r\nswitch (codec->vendor_id) {\r\ncase 0x80860054:\r\ncase 0x80862804:\r\ncase 0x80862882:\r\nbase_nid = 3;\r\nbreak;\r\ndefault:\r\nbase_nid = 4;\r\nbreak;\r\n}\r\nif (WARN_ON(pin_nid <= base_nid || pin_nid > base_nid + 3))\r\nreturn -1;\r\nreturn pin_nid - base_nid;\r\n}\r\nint snd_hdac_sync_audio_rate(struct hdac_device *codec, hda_nid_t nid,\r\nint dev_id, int rate)\r\n{\r\nstruct hdac_bus *bus = codec->bus;\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nint port, pipe;\r\nif (!acomp || !acomp->ops || !acomp->ops->sync_audio_rate)\r\nreturn -ENODEV;\r\nport = pin2port(codec, nid);\r\nif (port < 0)\r\nreturn -EINVAL;\r\npipe = dev_id;\r\nreturn acomp->ops->sync_audio_rate(acomp->dev, port, pipe, rate);\r\n}\r\nint snd_hdac_acomp_get_eld(struct hdac_device *codec, hda_nid_t nid, int dev_id,\r\nbool *audio_enabled, char *buffer, int max_bytes)\r\n{\r\nstruct hdac_bus *bus = codec->bus;\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nint port, pipe;\r\nif (!acomp || !acomp->ops || !acomp->ops->get_eld)\r\nreturn -ENODEV;\r\nport = pin2port(codec, nid);\r\nif (port < 0)\r\nreturn -EINVAL;\r\npipe = dev_id;\r\nreturn acomp->ops->get_eld(acomp->dev, port, pipe, audio_enabled,\r\nbuffer, max_bytes);\r\n}\r\nstatic int hdac_component_master_bind(struct device *dev)\r\n{\r\nstruct i915_audio_component *acomp = hdac_acomp;\r\nint ret;\r\nret = component_bind_all(dev, acomp);\r\nif (ret < 0)\r\nreturn ret;\r\nif (WARN_ON(!(acomp->dev && acomp->ops && acomp->ops->get_power &&\r\nacomp->ops->put_power && acomp->ops->get_cdclk_freq))) {\r\nret = -EINVAL;\r\ngoto out_unbind;\r\n}\r\nif (!try_module_get(acomp->ops->owner)) {\r\nret = -ENODEV;\r\ngoto out_unbind;\r\n}\r\nreturn 0;\r\nout_unbind:\r\ncomponent_unbind_all(dev, acomp);\r\nreturn ret;\r\n}\r\nstatic void hdac_component_master_unbind(struct device *dev)\r\n{\r\nstruct i915_audio_component *acomp = hdac_acomp;\r\nmodule_put(acomp->ops->owner);\r\ncomponent_unbind_all(dev, acomp);\r\nWARN_ON(acomp->ops || acomp->dev);\r\n}\r\nstatic int hdac_component_master_match(struct device *dev, void *data)\r\n{\r\nreturn !strcmp(dev->driver->name, "i915");\r\n}\r\nint snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)\r\n{\r\nif (WARN_ON(!hdac_acomp))\r\nreturn -ENODEV;\r\nhdac_acomp->audio_ops = aops;\r\nreturn 0;\r\n}\r\nstatic bool i915_gfx_present(void)\r\n{\r\nstatic struct pci_device_id ids[] = {\r\n{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_ANY_ID),\r\n.class = PCI_BASE_CLASS_DISPLAY << 16,\r\n.class_mask = 0xff << 16 },\r\n{}\r\n};\r\nreturn pci_dev_present(ids);\r\n}\r\nint snd_hdac_i915_init(struct hdac_bus *bus)\r\n{\r\nstruct component_match *match = NULL;\r\nstruct device *dev = bus->dev;\r\nstruct i915_audio_component *acomp;\r\nint ret;\r\nif (WARN_ON(hdac_acomp))\r\nreturn -EBUSY;\r\nif (!i915_gfx_present())\r\nreturn -ENODEV;\r\nacomp = kzalloc(sizeof(*acomp), GFP_KERNEL);\r\nif (!acomp)\r\nreturn -ENOMEM;\r\nbus->audio_component = acomp;\r\nhdac_acomp = acomp;\r\ncomponent_match_add(dev, &match, hdac_component_master_match, bus);\r\nret = component_master_add_with_match(dev, &hdac_component_master_ops,\r\nmatch);\r\nif (ret < 0)\r\ngoto out_err;\r\nrequest_module("i915");\r\nif (!acomp->ops) {\r\nret = -ENODEV;\r\ngoto out_master_del;\r\n}\r\ndev_dbg(dev, "bound to i915 component master\n");\r\nreturn 0;\r\nout_master_del:\r\ncomponent_master_del(dev, &hdac_component_master_ops);\r\nout_err:\r\nkfree(acomp);\r\nbus->audio_component = NULL;\r\nhdac_acomp = NULL;\r\ndev_info(dev, "failed to add i915 component master (%d)\n", ret);\r\nreturn ret;\r\n}\r\nint snd_hdac_i915_exit(struct hdac_bus *bus)\r\n{\r\nstruct device *dev = bus->dev;\r\nstruct i915_audio_component *acomp = bus->audio_component;\r\nif (!acomp)\r\nreturn 0;\r\nWARN_ON(bus->i915_power_refcount);\r\nif (bus->i915_power_refcount > 0 && acomp->ops)\r\nacomp->ops->put_power(acomp->dev);\r\ncomponent_master_del(dev, &hdac_component_master_ops);\r\nkfree(acomp);\r\nbus->audio_component = NULL;\r\nhdac_acomp = NULL;\r\nreturn 0;\r\n}
