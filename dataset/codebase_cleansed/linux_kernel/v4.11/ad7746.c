static int ad7746_select_channel(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nstruct ad7746_chip_info *chip = iio_priv(indio_dev);\r\nint ret, delay, idx;\r\nu8 vt_setup, cap_setup;\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\ncap_setup = (chan->address & 0xFF) | AD7746_CAPSETUP_CAPEN;\r\nvt_setup = chip->vt_setup & ~AD7746_VTSETUP_VTEN;\r\nidx = (chip->config & AD7746_CONF_CAPFS_MASK) >>\r\nAD7746_CONF_CAPFS_SHIFT;\r\ndelay = ad7746_cap_filter_rate_table[idx][1];\r\nif (chip->capdac_set != chan->channel) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_CAPDACA,\r\nchip->capdac[chan->channel][0]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_CAPDACB,\r\nchip->capdac[chan->channel][1]);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->capdac_set = chan->channel;\r\n}\r\nbreak;\r\ncase IIO_VOLTAGE:\r\ncase IIO_TEMP:\r\nvt_setup = (chan->address & 0xFF) | AD7746_VTSETUP_VTEN;\r\ncap_setup = chip->cap_setup & ~AD7746_CAPSETUP_CAPEN;\r\nidx = (chip->config & AD7746_CONF_VTFS_MASK) >>\r\nAD7746_CONF_VTFS_SHIFT;\r\ndelay = ad7746_cap_filter_rate_table[idx][1];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (chip->cap_setup != cap_setup) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_CAP_SETUP,\r\ncap_setup);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->cap_setup = cap_setup;\r\n}\r\nif (chip->vt_setup != vt_setup) {\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_VT_SETUP,\r\nvt_setup);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->vt_setup = vt_setup;\r\n}\r\nreturn delay;\r\n}\r\nstatic inline ssize_t ad7746_start_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len,\r\nu8 regval)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7746_chip_info *chip = iio_priv(indio_dev);\r\nbool doit;\r\nint ret, timeout = 10;\r\nret = strtobool(buf, &doit);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!doit)\r\nreturn 0;\r\nmutex_lock(&indio_dev->mlock);\r\nregval |= chip->config;\r\nret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG, regval);\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\ndo {\r\nmsleep(20);\r\nret = i2c_smbus_read_byte_data(chip->client, AD7746_REG_CFG);\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\n} while ((ret == regval) && timeout--);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn len;\r\n}\r\nstatic ssize_t ad7746_start_offset_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nint ret = ad7746_select_channel(indio_dev,\r\n&ad7746_channels[to_iio_dev_attr(attr)->address]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ad7746_start_calib(dev, attr, buf, len,\r\nAD7746_CONF_MODE_OFFS_CAL);\r\n}\r\nstatic ssize_t ad7746_start_gain_calib(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nint ret = ad7746_select_channel(indio_dev,\r\n&ad7746_channels[to_iio_dev_attr(attr)->address]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ad7746_start_calib(dev, attr, buf, len,\r\nAD7746_CONF_MODE_GAIN_CAL);\r\n}\r\nstatic int ad7746_store_cap_filter_rate_setup(struct ad7746_chip_info *chip,\r\nint val)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ad7746_cap_filter_rate_table); i++)\r\nif (val >= ad7746_cap_filter_rate_table[i][0])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ad7746_cap_filter_rate_table))\r\ni = ARRAY_SIZE(ad7746_cap_filter_rate_table) - 1;\r\nchip->config &= ~AD7746_CONF_CAPFS_MASK;\r\nchip->config |= i << AD7746_CONF_CAPFS_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int ad7746_store_vt_filter_rate_setup(struct ad7746_chip_info *chip,\r\nint val)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ad7746_vt_filter_rate_table); i++)\r\nif (val >= ad7746_vt_filter_rate_table[i][0])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ad7746_vt_filter_rate_table))\r\ni = ARRAY_SIZE(ad7746_vt_filter_rate_table) - 1;\r\nchip->config &= ~AD7746_CONF_VTFS_MASK;\r\nchip->config |= i << AD7746_CONF_VTFS_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int ad7746_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct ad7746_chip_info *chip = iio_priv(indio_dev);\r\nint ret, reg;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (val != 1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nval = (val2 * 1024) / 15625;\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\nreg = AD7746_REG_CAP_GAINH;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\nreg = AD7746_REG_VOLT_GAINH;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_word_data(chip->client, reg, swab16(val));\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif ((val < 0) | (val > 0xFFFF)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_write_word_data(chip->client,\r\nAD7746_REG_CAP_OFFH, swab16(val));\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nif ((val < 0) | (val > 43008000)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nval /= 338646;\r\nchip->capdac[chan->channel][chan->differential] = val > 0 ?\r\nAD7746_CAPDAC_DACP(val) | AD7746_CAPDAC_DACEN : 0;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_CAPDACA,\r\nchip->capdac[chan->channel][0]);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_CAPDACB,\r\nchip->capdac[chan->channel][1]);\r\nif (ret < 0)\r\ngoto out;\r\nchip->capdac_set = chan->channel;\r\nret = 0;\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val2) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\nret = ad7746_store_cap_filter_rate_setup(chip, val);\r\nbreak;\r\ncase IIO_VOLTAGE:\r\nret = ad7746_store_vt_filter_rate_setup(chip, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad7746_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ad7746_chip_info *chip = iio_priv(indio_dev);\r\nint ret, delay, idx;\r\nu8 regval, reg;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nret = ad7746_select_channel(indio_dev, chan);\r\nif (ret < 0)\r\ngoto out;\r\ndelay = ret;\r\nregval = chip->config | AD7746_CONF_MODE_SINGLE_CONV;\r\nret = i2c_smbus_write_byte_data(chip->client, AD7746_REG_CFG,\r\nregval);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(delay);\r\nret = i2c_smbus_read_i2c_block_data(chip->client,\r\nchan->address >> 8, 3, &chip->data.d8[1]);\r\nif (ret < 0)\r\ngoto out;\r\n*val = (be32_to_cpu(chip->data.d32) & 0xFFFFFF) - 0x800000;\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = (*val * 125) / 256;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\nif (chan->channel == 1)\r\n*val = *val * 6;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\nreg = AD7746_REG_CAP_GAINH;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\nreg = AD7746_REG_VOLT_GAINH;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = i2c_smbus_read_word_data(chip->client, reg);\r\nif (ret < 0)\r\ngoto out;\r\n*val = 1;\r\n*val2 = (15625 * swab16(ret)) / 1024;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nret = i2c_smbus_read_word_data(chip->client,\r\nAD7746_REG_CAP_OFFH);\r\nif (ret < 0)\r\ngoto out;\r\n*val = swab16(ret);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = AD7746_CAPDAC_DACP(chip->capdac[chan->channel]\r\n[chan->differential]) * 338646;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\n*val = 0;\r\n*val2 = 488;\r\nret = IIO_VAL_INT_PLUS_NANO;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\n*val = 1170;\r\n*val2 = 23;\r\nret = IIO_VAL_FRACTIONAL_LOG2;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nswitch (chan->type) {\r\ncase IIO_CAPACITANCE:\r\nidx = (chip->config & AD7746_CONF_CAPFS_MASK) >>\r\nAD7746_CONF_CAPFS_SHIFT;\r\n*val = ad7746_cap_filter_rate_table[idx][0];\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\nidx = (chip->config & AD7746_CONF_VTFS_MASK) >>\r\nAD7746_CONF_VTFS_SHIFT;\r\n*val = ad7746_vt_filter_rate_table[idx][0];\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad7746_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ad7746_platform_data *pdata = client->dev.platform_data;\r\nstruct ad7746_chip_info *chip;\r\nstruct iio_dev *indio_dev;\r\nint ret = 0;\r\nunsigned char regval = 0;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nchip->client = client;\r\nchip->capdac_set = -1;\r\nindio_dev->name = id->name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &ad7746_info;\r\nindio_dev->channels = ad7746_channels;\r\nif (id->driver_data == 7746)\r\nindio_dev->num_channels = ARRAY_SIZE(ad7746_channels);\r\nelse\r\nindio_dev->num_channels = ARRAY_SIZE(ad7746_channels) - 2;\r\nindio_dev->num_channels = ARRAY_SIZE(ad7746_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (pdata) {\r\nif (pdata->exca_en) {\r\nif (pdata->exca_inv_en)\r\nregval |= AD7746_EXCSETUP_NEXCA;\r\nelse\r\nregval |= AD7746_EXCSETUP_EXCA;\r\n}\r\nif (pdata->excb_en) {\r\nif (pdata->excb_inv_en)\r\nregval |= AD7746_EXCSETUP_NEXCB;\r\nelse\r\nregval |= AD7746_EXCSETUP_EXCB;\r\n}\r\nregval |= AD7746_EXCSETUP_EXCLVL(pdata->exclvl);\r\n} else {\r\ndev_warn(&client->dev, "No platform data? using default\n");\r\nregval = AD7746_EXCSETUP_EXCA | AD7746_EXCSETUP_EXCB |\r\nAD7746_EXCSETUP_EXCLVL(3);\r\n}\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nAD7746_REG_EXC_SETUP, regval);\r\nif (ret < 0)\r\nreturn ret;\r\nret = devm_iio_device_register(indio_dev->dev.parent, indio_dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
