static int ufx_reg_read(struct ufx_data *dev, u32 index, u32 *data)\r\n{\r\nu32 *buf = kmalloc(4, GFP_KERNEL);\r\nint ret;\r\nBUG_ON(!dev);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nUSB_VENDOR_REQUEST_READ_REGISTER,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n00, index, buf, 4, USB_CTRL_GET_TIMEOUT);\r\nle32_to_cpus(buf);\r\n*data = *buf;\r\nkfree(buf);\r\nif (unlikely(ret < 0))\r\npr_warn("Failed to read register index 0x%08x\n", index);\r\nreturn ret;\r\n}\r\nstatic int ufx_reg_write(struct ufx_data *dev, u32 index, u32 data)\r\n{\r\nu32 *buf = kmalloc(4, GFP_KERNEL);\r\nint ret;\r\nBUG_ON(!dev);\r\nif (!buf)\r\nreturn -ENOMEM;\r\n*buf = data;\r\ncpu_to_le32s(buf);\r\nret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nUSB_VENDOR_REQUEST_WRITE_REGISTER,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n00, index, buf, 4, USB_CTRL_SET_TIMEOUT);\r\nkfree(buf);\r\nif (unlikely(ret < 0))\r\npr_warn("Failed to write register index 0x%08x with value "\r\n"0x%08x\n", index, data);\r\nreturn ret;\r\n}\r\nstatic int ufx_reg_clear_and_set_bits(struct ufx_data *dev, u32 index,\r\nu32 bits_to_clear, u32 bits_to_set)\r\n{\r\nu32 data;\r\nint status = ufx_reg_read(dev, index, &data);\r\ncheck_warn_return(status, "ufx_reg_clear_and_set_bits error reading "\r\n"0x%x", index);\r\ndata &= (~bits_to_clear);\r\ndata |= bits_to_set;\r\nstatus = ufx_reg_write(dev, index, data);\r\ncheck_warn_return(status, "ufx_reg_clear_and_set_bits error writing "\r\n"0x%x", index);\r\nreturn 0;\r\n}\r\nstatic int ufx_reg_set_bits(struct ufx_data *dev, u32 index, u32 bits)\r\n{\r\nreturn ufx_reg_clear_and_set_bits(dev, index, 0, bits);\r\n}\r\nstatic int ufx_reg_clear_bits(struct ufx_data *dev, u32 index, u32 bits)\r\n{\r\nreturn ufx_reg_clear_and_set_bits(dev, index, bits, 0);\r\n}\r\nstatic int ufx_lite_reset(struct ufx_data *dev)\r\n{\r\nint status;\r\nu32 value;\r\nstatus = ufx_reg_write(dev, 0x3008, 0x00000001);\r\ncheck_warn_return(status, "ufx_lite_reset error writing 0x3008");\r\nstatus = ufx_reg_read(dev, 0x3008, &value);\r\ncheck_warn_return(status, "ufx_lite_reset error reading 0x3008");\r\nreturn (value == 0) ? 0 : -EIO;\r\n}\r\nstatic int ufx_blank(struct ufx_data *dev, bool wait)\r\n{\r\nu32 dc_ctrl, dc_sts;\r\nint i;\r\nint status = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_blank error reading 0x2004");\r\nstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\r\ncheck_warn_return(status, "ufx_blank error reading 0x2000");\r\nif ((dc_sts & 0x00000100) || (dc_ctrl & 0x00000100))\r\nreturn 0;\r\ndc_ctrl |= 0x00000100;\r\nstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\r\ncheck_warn_return(status, "ufx_blank error writing 0x2000");\r\nif (!wait)\r\nreturn 0;\r\nfor (i = 0; i < 250; i++) {\r\nstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_blank error reading 0x2004");\r\nif (dc_sts & 0x00000100)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ufx_unblank(struct ufx_data *dev, bool wait)\r\n{\r\nu32 dc_ctrl, dc_sts;\r\nint i;\r\nint status = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_unblank error reading 0x2004");\r\nstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\r\ncheck_warn_return(status, "ufx_unblank error reading 0x2000");\r\nif (((dc_sts & 0x00000100) == 0) || ((dc_ctrl & 0x00000100) == 0))\r\nreturn 0;\r\ndc_ctrl &= ~0x00000100;\r\nstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\r\ncheck_warn_return(status, "ufx_unblank error writing 0x2000");\r\nif (!wait)\r\nreturn 0;\r\nfor (i = 0; i < 250; i++) {\r\nstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_unblank error reading 0x2004");\r\nif ((dc_sts & 0x00000100) == 0)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ufx_disable(struct ufx_data *dev, bool wait)\r\n{\r\nu32 dc_ctrl, dc_sts;\r\nint i;\r\nint status = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_disable error reading 0x2004");\r\nstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\r\ncheck_warn_return(status, "ufx_disable error reading 0x2000");\r\nif (((dc_sts & 0x00000001) == 0) || ((dc_ctrl & 0x00000001) == 0))\r\nreturn 0;\r\ndc_ctrl &= ~(0x00000001);\r\nstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\r\ncheck_warn_return(status, "ufx_disable error writing 0x2000");\r\nif (!wait)\r\nreturn 0;\r\nfor (i = 0; i < 250; i++) {\r\nstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_disable error reading 0x2004");\r\nif ((dc_sts & 0x00000001) == 0)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ufx_enable(struct ufx_data *dev, bool wait)\r\n{\r\nu32 dc_ctrl, dc_sts;\r\nint i;\r\nint status = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_enable error reading 0x2004");\r\nstatus = ufx_reg_read(dev, 0x2000, &dc_ctrl);\r\ncheck_warn_return(status, "ufx_enable error reading 0x2000");\r\nif ((dc_sts & 0x00000001) || (dc_ctrl & 0x00000001))\r\nreturn 0;\r\ndc_ctrl |= 0x00000001;\r\nstatus = ufx_reg_write(dev, 0x2000, dc_ctrl);\r\ncheck_warn_return(status, "ufx_enable error writing 0x2000");\r\nif (!wait)\r\nreturn 0;\r\nfor (i = 0; i < 250; i++) {\r\nstatus = ufx_reg_read(dev, 0x2004, &dc_sts);\r\ncheck_warn_return(status, "ufx_enable error reading 0x2004");\r\nif (dc_sts & 0x00000001)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ufx_config_sys_clk(struct ufx_data *dev)\r\n{\r\nint status = ufx_reg_write(dev, 0x700C, 0x8000000F);\r\ncheck_warn_return(status, "error writing 0x700C");\r\nstatus = ufx_reg_write(dev, 0x7014, 0x0010024F);\r\ncheck_warn_return(status, "error writing 0x7014");\r\nstatus = ufx_reg_write(dev, 0x7010, 0x00000000);\r\ncheck_warn_return(status, "error writing 0x7010");\r\nstatus = ufx_reg_clear_bits(dev, 0x700C, 0x0000000A);\r\ncheck_warn_return(status, "error clearing PLL1 bypass in 0x700C");\r\nmsleep(1);\r\nstatus = ufx_reg_clear_bits(dev, 0x700C, 0x80000000);\r\ncheck_warn_return(status, "error clearing output gate in 0x700C");\r\nreturn 0;\r\n}\r\nstatic int ufx_config_ddr2(struct ufx_data *dev)\r\n{\r\nint status, i = 0;\r\nu32 tmp;\r\nstatus = ufx_reg_write(dev, 0x0004, 0x001F0F77);\r\ncheck_warn_return(status, "error writing 0x0004");\r\nstatus = ufx_reg_write(dev, 0x0008, 0xFFF00000);\r\ncheck_warn_return(status, "error writing 0x0008");\r\nstatus = ufx_reg_write(dev, 0x000C, 0x0FFF2222);\r\ncheck_warn_return(status, "error writing 0x000C");\r\nstatus = ufx_reg_write(dev, 0x0010, 0x00030814);\r\ncheck_warn_return(status, "error writing 0x0010");\r\nstatus = ufx_reg_write(dev, 0x0014, 0x00500019);\r\ncheck_warn_return(status, "error writing 0x0014");\r\nstatus = ufx_reg_write(dev, 0x0018, 0x020D0F15);\r\ncheck_warn_return(status, "error writing 0x0018");\r\nstatus = ufx_reg_write(dev, 0x001C, 0x02532305);\r\ncheck_warn_return(status, "error writing 0x001C");\r\nstatus = ufx_reg_write(dev, 0x0020, 0x0B030905);\r\ncheck_warn_return(status, "error writing 0x0020");\r\nstatus = ufx_reg_write(dev, 0x0024, 0x00000827);\r\ncheck_warn_return(status, "error writing 0x0024");\r\nstatus = ufx_reg_write(dev, 0x0028, 0x00000000);\r\ncheck_warn_return(status, "error writing 0x0028");\r\nstatus = ufx_reg_write(dev, 0x002C, 0x00000042);\r\ncheck_warn_return(status, "error writing 0x002C");\r\nstatus = ufx_reg_write(dev, 0x0030, 0x09520000);\r\ncheck_warn_return(status, "error writing 0x0030");\r\nstatus = ufx_reg_write(dev, 0x0034, 0x02223314);\r\ncheck_warn_return(status, "error writing 0x0034");\r\nstatus = ufx_reg_write(dev, 0x0038, 0x00430043);\r\ncheck_warn_return(status, "error writing 0x0038");\r\nstatus = ufx_reg_write(dev, 0x003C, 0xF00F000F);\r\ncheck_warn_return(status, "error writing 0x003C");\r\nstatus = ufx_reg_write(dev, 0x0040, 0xF380F00F);\r\ncheck_warn_return(status, "error writing 0x0040");\r\nstatus = ufx_reg_write(dev, 0x0044, 0xF00F0496);\r\ncheck_warn_return(status, "error writing 0x0044");\r\nstatus = ufx_reg_write(dev, 0x0048, 0x03080406);\r\ncheck_warn_return(status, "error writing 0x0048");\r\nstatus = ufx_reg_write(dev, 0x004C, 0x00001000);\r\ncheck_warn_return(status, "error writing 0x004C");\r\nstatus = ufx_reg_write(dev, 0x005C, 0x00000007);\r\ncheck_warn_return(status, "error writing 0x005C");\r\nstatus = ufx_reg_write(dev, 0x0100, 0x54F00012);\r\ncheck_warn_return(status, "error writing 0x0100");\r\nstatus = ufx_reg_write(dev, 0x0104, 0x00004012);\r\ncheck_warn_return(status, "error writing 0x0104");\r\nstatus = ufx_reg_write(dev, 0x0118, 0x40404040);\r\ncheck_warn_return(status, "error writing 0x0118");\r\nstatus = ufx_reg_write(dev, 0x0000, 0x00000001);\r\ncheck_warn_return(status, "error writing 0x0000");\r\nwhile (i++ < 500) {\r\nstatus = ufx_reg_read(dev, 0x0000, &tmp);\r\ncheck_warn_return(status, "error reading 0x0000");\r\nif (all_bits_set(tmp, 0xC0000000))\r\nreturn 0;\r\n}\r\npr_err("DDR2 initialisation timed out, reg 0x0000=0x%08x", tmp);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic u32 ufx_calc_range(u32 ref_freq)\r\n{\r\nif (ref_freq >= 88000000)\r\nreturn 7;\r\nif (ref_freq >= 54000000)\r\nreturn 6;\r\nif (ref_freq >= 34000000)\r\nreturn 5;\r\nif (ref_freq >= 21000000)\r\nreturn 4;\r\nif (ref_freq >= 13000000)\r\nreturn 3;\r\nif (ref_freq >= 8000000)\r\nreturn 2;\r\nreturn 1;\r\n}\r\nstatic void ufx_calc_pll_values(const u32 clk_pixel_pll, struct pll_values *asic_pll)\r\n{\r\nconst u32 ref_clk = 25000000;\r\nu32 div_r0, div_f0, div_q0, div_r1, div_f1, div_q1;\r\nu32 min_error = clk_pixel_pll;\r\nfor (div_r0 = 1; div_r0 <= 32; div_r0++) {\r\nu32 ref_freq0 = ref_clk / div_r0;\r\nif (ref_freq0 < 5000000)\r\nbreak;\r\nif (ref_freq0 > 200000000)\r\ncontinue;\r\nfor (div_f0 = 1; div_f0 <= 256; div_f0++) {\r\nu32 vco_freq0 = ref_freq0 * div_f0;\r\nif (vco_freq0 < 350000000)\r\ncontinue;\r\nif (vco_freq0 > 700000000)\r\nbreak;\r\nfor (div_q0 = 0; div_q0 < 7; div_q0++) {\r\nu32 pllout_freq0 = vco_freq0 / (1 << div_q0);\r\nif (pllout_freq0 < 5000000)\r\nbreak;\r\nif (pllout_freq0 > 200000000)\r\ncontinue;\r\nfor (div_r1 = 1; div_r1 <= 32; div_r1++) {\r\nu32 ref_freq1 = pllout_freq0 / div_r1;\r\nif (ref_freq1 < 5000000)\r\nbreak;\r\nfor (div_f1 = 1; div_f1 <= 256; div_f1++) {\r\nu32 vco_freq1 = ref_freq1 * div_f1;\r\nif (vco_freq1 < 350000000)\r\ncontinue;\r\nif (vco_freq1 > 700000000)\r\nbreak;\r\nfor (div_q1 = 0; div_q1 < 7; div_q1++) {\r\nu32 pllout_freq1 = vco_freq1 / (1 << div_q1);\r\nint error = abs(pllout_freq1 - clk_pixel_pll);\r\nif (pllout_freq1 < 5000000)\r\nbreak;\r\nif (pllout_freq1 > 700000000)\r\ncontinue;\r\nif (error < min_error) {\r\nmin_error = error;\r\nasic_pll->div_r0 = div_r0 - 1;\r\nasic_pll->div_f0 = div_f0 - 1;\r\nasic_pll->div_q0 = div_q0;\r\nasic_pll->div_r1 = div_r1 - 1;\r\nasic_pll->div_f1 = div_f1 - 1;\r\nasic_pll->div_q1 = div_q1;\r\nasic_pll->range0 = ufx_calc_range(ref_freq0);\r\nasic_pll->range1 = ufx_calc_range(ref_freq1);\r\nif (min_error == 0)\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int ufx_config_pix_clk(struct ufx_data *dev, u32 pixclock)\r\n{\r\nstruct pll_values asic_pll = {0};\r\nu32 value, clk_pixel, clk_pixel_pll;\r\nint status;\r\nclk_pixel = PICOS2KHZ(pixclock) * 1000;\r\npr_debug("pixclock %d ps = clk_pixel %d Hz", pixclock, clk_pixel);\r\nclk_pixel_pll = clk_pixel * 2;\r\nufx_calc_pll_values(clk_pixel_pll, &asic_pll);\r\nstatus = ufx_reg_write(dev, 0x7000, 0x8000000F);\r\ncheck_warn_return(status, "error writing 0x7000");\r\nvalue = (asic_pll.div_f1 | (asic_pll.div_r1 << 8) |\r\n(asic_pll.div_q1 << 16) | (asic_pll.range1 << 20));\r\nstatus = ufx_reg_write(dev, 0x7008, value);\r\ncheck_warn_return(status, "error writing 0x7008");\r\nvalue = (asic_pll.div_f0 | (asic_pll.div_r0 << 8) |\r\n(asic_pll.div_q0 << 16) | (asic_pll.range0 << 20));\r\nstatus = ufx_reg_write(dev, 0x7004, value);\r\ncheck_warn_return(status, "error writing 0x7004");\r\nstatus = ufx_reg_clear_bits(dev, 0x7000, 0x00000005);\r\ncheck_warn_return(status,\r\n"error clearing PLL0 bypass bits in 0x7000");\r\nmsleep(1);\r\nstatus = ufx_reg_clear_bits(dev, 0x7000, 0x0000000A);\r\ncheck_warn_return(status,\r\n"error clearing PLL1 bypass bits in 0x7000");\r\nmsleep(1);\r\nstatus = ufx_reg_clear_bits(dev, 0x7000, 0x80000000);\r\ncheck_warn_return(status, "error clearing gate bits in 0x7000");\r\nreturn 0;\r\n}\r\nstatic int ufx_set_vid_mode(struct ufx_data *dev, struct fb_var_screeninfo *var)\r\n{\r\nu32 temp;\r\nu16 h_total, h_active, h_blank_start, h_blank_end, h_sync_start, h_sync_end;\r\nu16 v_total, v_active, v_blank_start, v_blank_end, v_sync_start, v_sync_end;\r\nint status = ufx_reg_write(dev, 0x8028, 0);\r\ncheck_warn_return(status, "ufx_set_vid_mode error disabling RGB pad");\r\nstatus = ufx_reg_write(dev, 0x8024, 0);\r\ncheck_warn_return(status, "ufx_set_vid_mode error disabling VDAC");\r\nstatus = ufx_blank(dev, true);\r\ncheck_warn_return(status, "ufx_set_vid_mode error blanking display");\r\nstatus = ufx_disable(dev, true);\r\ncheck_warn_return(status, "ufx_set_vid_mode error disabling display");\r\nstatus = ufx_config_pix_clk(dev, var->pixclock);\r\ncheck_warn_return(status, "ufx_set_vid_mode error configuring pixclock");\r\nstatus = ufx_reg_write(dev, 0x2000, 0x00000104);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2000");\r\nh_total = var->xres + var->right_margin + var->hsync_len + var->left_margin;\r\nh_active = var->xres;\r\nh_blank_start = var->xres + var->right_margin;\r\nh_blank_end = var->xres + var->right_margin + var->hsync_len;\r\nh_sync_start = var->xres + var->right_margin;\r\nh_sync_end = var->xres + var->right_margin + var->hsync_len;\r\ntemp = ((h_total - 1) << 16) | (h_active - 1);\r\nstatus = ufx_reg_write(dev, 0x2008, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2008");\r\ntemp = ((h_blank_start - 1) << 16) | (h_blank_end - 1);\r\nstatus = ufx_reg_write(dev, 0x200C, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x200C");\r\ntemp = ((h_sync_start - 1) << 16) | (h_sync_end - 1);\r\nstatus = ufx_reg_write(dev, 0x2010, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2010");\r\nv_total = var->upper_margin + var->yres + var->lower_margin + var->vsync_len;\r\nv_active = var->yres;\r\nv_blank_start = var->yres + var->lower_margin;\r\nv_blank_end = var->yres + var->lower_margin + var->vsync_len;\r\nv_sync_start = var->yres + var->lower_margin;\r\nv_sync_end = var->yres + var->lower_margin + var->vsync_len;\r\ntemp = ((v_total - 1) << 16) | (v_active - 1);\r\nstatus = ufx_reg_write(dev, 0x2014, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2014");\r\ntemp = ((v_blank_start - 1) << 16) | (v_blank_end - 1);\r\nstatus = ufx_reg_write(dev, 0x2018, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2018");\r\ntemp = ((v_sync_start - 1) << 16) | (v_sync_end - 1);\r\nstatus = ufx_reg_write(dev, 0x201C, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x201C");\r\nstatus = ufx_reg_write(dev, 0x2020, 0x00000000);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2020");\r\nstatus = ufx_reg_write(dev, 0x2024, 0x00000000);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2024");\r\ntemp = var->xres * var->yres * 2;\r\ntemp = (temp + 7) & (~0x7);\r\nstatus = ufx_reg_write(dev, 0x2028, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2028");\r\nstatus = ufx_reg_write(dev, 0x2040, 0);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2040");\r\nstatus = ufx_reg_write(dev, 0x2044, 0);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2044");\r\nstatus = ufx_reg_write(dev, 0x2048, 0);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2048");\r\ntemp = 0x00000001;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\ntemp |= 0x00000010;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\ntemp |= 0x00000008;\r\nstatus = ufx_reg_write(dev, 0x2040, temp);\r\ncheck_warn_return(status, "ufx_set_vid_mode error writing 0x2040");\r\nstatus = ufx_enable(dev, true);\r\ncheck_warn_return(status, "ufx_set_vid_mode error enabling display");\r\nstatus = ufx_unblank(dev, true);\r\ncheck_warn_return(status, "ufx_set_vid_mode error unblanking display");\r\nstatus = ufx_reg_write(dev, 0x8028, 0x00000003);\r\ncheck_warn_return(status, "ufx_set_vid_mode error enabling RGB pad");\r\nstatus = ufx_reg_write(dev, 0x8024, 0x00000007);\r\ncheck_warn_return(status, "ufx_set_vid_mode error enabling VDAC");\r\nreturn 0;\r\n}\r\nstatic int ufx_ops_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long page, pos;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\nif (size > info->fix.smem_len)\r\nreturn -EINVAL;\r\nif (offset > info->fix.smem_len - size)\r\nreturn -EINVAL;\r\npos = (unsigned long)info->fix.smem_start + offset;\r\npr_debug("mmap() framebuffer addr:%lu size:%lu\n",\r\npos, size);\r\nwhile (size > 0) {\r\npage = vmalloc_to_pfn((void *)pos);\r\nif (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))\r\nreturn -EAGAIN;\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nif (size > PAGE_SIZE)\r\nsize -= PAGE_SIZE;\r\nelse\r\nsize = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ufx_raw_rect(struct ufx_data *dev, u16 *cmd, int x, int y,\r\nint width, int height)\r\n{\r\nsize_t packed_line_len = ALIGN((width * 2), 4);\r\nsize_t packed_rect_len = packed_line_len * height;\r\nint line;\r\nBUG_ON(!dev);\r\nBUG_ON(!dev->info);\r\n*((u32 *)&cmd[0]) = cpu_to_le32(0x01);\r\n*((u32 *)&cmd[2]) = cpu_to_le32(packed_rect_len + 16);\r\ncmd[4] = cpu_to_le16(x);\r\ncmd[5] = cpu_to_le16(y);\r\ncmd[6] = cpu_to_le16(width);\r\ncmd[7] = cpu_to_le16(height);\r\n*((u32 *)&cmd[8]) = cpu_to_le32(0);\r\ncmd[10] = cpu_to_le16(0x4000 | dev->info->var.xres);\r\ncmd[11] = cpu_to_le16(dev->info->var.yres);\r\nfor (line = 0; line < height; line++) {\r\nconst int line_offset = dev->info->fix.line_length * (y + line);\r\nconst int byte_offset = line_offset + (x * BPP);\r\nmemcpy(&cmd[(24 + (packed_line_len * line)) / 2],\r\n(char *)dev->info->fix.smem_start + byte_offset, width * BPP);\r\n}\r\n}\r\nstatic int ufx_handle_damage(struct ufx_data *dev, int x, int y,\r\nint width, int height)\r\n{\r\nsize_t packed_line_len = ALIGN((width * 2), 4);\r\nint len, status, urb_lines, start_line = 0;\r\nif ((width <= 0) || (height <= 0) ||\r\n(x + width > dev->info->var.xres) ||\r\n(y + height > dev->info->var.yres))\r\nreturn -EINVAL;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn 0;\r\nwhile (start_line < height) {\r\nstruct urb *urb = ufx_get_urb(dev);\r\nif (!urb) {\r\npr_warn("ufx_handle_damage unable to get urb");\r\nreturn 0;\r\n}\r\nBUG_ON(urb->transfer_buffer_length < (24 + (width * 2)));\r\nurb_lines = (urb->transfer_buffer_length - 24) / packed_line_len;\r\nurb_lines = min(urb_lines, (height - start_line));\r\nmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\r\nufx_raw_rect(dev, urb->transfer_buffer, x, (y + start_line), width, urb_lines);\r\nlen = 24 + (packed_line_len * urb_lines);\r\nstatus = ufx_submit_urb(dev, urb, len);\r\ncheck_warn_return(status, "Error submitting URB");\r\nstart_line += urb_lines;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ufx_ops_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t result;\r\nstruct ufx_data *dev = info->par;\r\nu32 offset = (u32) *ppos;\r\nresult = fb_sys_write(info, buf, count, ppos);\r\nif (result > 0) {\r\nint start = max((int)(offset / info->fix.line_length), 0);\r\nint lines = min((u32)((result / info->fix.line_length) + 1),\r\n(u32)info->var.yres);\r\nufx_handle_damage(dev, 0, start, info->var.xres, lines);\r\n}\r\nreturn result;\r\n}\r\nstatic void ufx_ops_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nsys_copyarea(info, area);\r\nufx_handle_damage(dev, area->dx, area->dy,\r\narea->width, area->height);\r\n}\r\nstatic void ufx_ops_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nsys_imageblit(info, image);\r\nufx_handle_damage(dev, image->dx, image->dy,\r\nimage->width, image->height);\r\n}\r\nstatic void ufx_ops_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nsys_fillrect(info, rect);\r\nufx_handle_damage(dev, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void ufx_dpy_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct page *cur;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct ufx_data *dev = info->par;\r\nif (!fb_defio)\r\nreturn;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn;\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nconst int x = 0;\r\nconst int width = dev->info->var.xres;\r\nconst int y = (cur->index << PAGE_SHIFT) / (width * 2);\r\nint height = (PAGE_SIZE / (width * 2)) + 1;\r\nheight = min(height, (int)(dev->info->var.yres - y));\r\nBUG_ON(y >= dev->info->var.yres);\r\nBUG_ON((y + height) > dev->info->var.yres);\r\nufx_handle_damage(dev, x, y, width, height);\r\n}\r\n}\r\nstatic int ufx_ops_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nstruct dloarea *area = NULL;\r\nif (!atomic_read(&dev->usb_active))\r\nreturn 0;\r\nif (cmd == UFX_IOCTL_RETURN_EDID) {\r\nu8 __user *edid = (u8 __user *)arg;\r\nif (copy_to_user(edid, dev->edid, dev->edid_size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cmd == UFX_IOCTL_REPORT_DAMAGE) {\r\nif (info->fbdefio)\r\ninfo->fbdefio->delay = UFX_DEFIO_WRITE_DISABLE;\r\narea = (struct dloarea *)arg;\r\nif (area->x < 0)\r\narea->x = 0;\r\nif (area->x > info->var.xres)\r\narea->x = info->var.xres;\r\nif (area->y < 0)\r\narea->y = 0;\r\nif (area->y > info->var.yres)\r\narea->y = info->var.yres;\r\nufx_handle_damage(dev, area->x, area->y, area->w, area->h);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nufx_ops_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *info)\r\n{\r\nint err = 0;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nif (regno < 16) {\r\nif (info->var.red.offset == 10) {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) | ((blue & 0xf800) >> 11);\r\n} else {\r\n((u32 *) (info->pseudo_palette))[regno] =\r\n((red & 0xf800)) |\r\n((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int ufx_ops_open(struct fb_info *info, int user)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nif (user == 0 && !console)\r\nreturn -EBUSY;\r\nif (dev->virtualized)\r\nreturn -ENODEV;\r\ndev->fb_count++;\r\nkref_get(&dev->kref);\r\nif (fb_defio && (info->fbdefio == NULL)) {\r\nstruct fb_deferred_io *fbdefio;\r\nfbdefio = kzalloc(sizeof(struct fb_deferred_io), GFP_KERNEL);\r\nif (fbdefio) {\r\nfbdefio->delay = UFX_DEFIO_WRITE_DELAY;\r\nfbdefio->deferred_io = ufx_dpy_deferred_io;\r\n}\r\ninfo->fbdefio = fbdefio;\r\nfb_deferred_io_init(info);\r\n}\r\npr_debug("open /dev/fb%d user=%d fb_info=%p count=%d",\r\ninfo->node, user, info, dev->fb_count);\r\nreturn 0;\r\n}\r\nstatic void ufx_free(struct kref *kref)\r\n{\r\nstruct ufx_data *dev = container_of(kref, struct ufx_data, kref);\r\nif (dev->urbs.count > 0)\r\nufx_free_urb_list(dev);\r\npr_debug("freeing ufx_data %p", dev);\r\nkfree(dev);\r\n}\r\nstatic void ufx_release_urb_work(struct work_struct *work)\r\n{\r\nstruct urb_node *unode = container_of(work, struct urb_node,\r\nrelease_urb_work.work);\r\nup(&unode->dev->urbs.limit_sem);\r\n}\r\nstatic void ufx_free_framebuffer_work(struct work_struct *work)\r\n{\r\nstruct ufx_data *dev = container_of(work, struct ufx_data,\r\nfree_framebuffer_work.work);\r\nstruct fb_info *info = dev->info;\r\nint node = info->node;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len != 0)\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->monspecs.modedb)\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nvfree(info->screen_base);\r\nfb_destroy_modelist(&info->modelist);\r\ndev->info = NULL;\r\nframebuffer_release(info);\r\npr_debug("fb_info for /dev/fb%d has been freed", node);\r\nkref_put(&dev->kref, ufx_free);\r\n}\r\nstatic int ufx_ops_release(struct fb_info *info, int user)\r\n{\r\nstruct ufx_data *dev = info->par;\r\ndev->fb_count--;\r\nif (dev->virtualized && (dev->fb_count == 0))\r\nschedule_delayed_work(&dev->free_framebuffer_work, HZ);\r\nif ((dev->fb_count == 0) && (info->fbdefio)) {\r\nfb_deferred_io_cleanup(info);\r\nkfree(info->fbdefio);\r\ninfo->fbdefio = NULL;\r\ninfo->fbops->fb_mmap = ufx_ops_mmap;\r\n}\r\npr_debug("released /dev/fb%d user=%d count=%d",\r\ninfo->node, user, dev->fb_count);\r\nkref_put(&dev->kref, ufx_free);\r\nreturn 0;\r\n}\r\nstatic int ufx_is_valid_mode(struct fb_videomode *mode,\r\nstruct fb_info *info)\r\n{\r\nif ((mode->xres * mode->yres) > (2048 * 1152)) {\r\npr_debug("%dx%d too many pixels",\r\nmode->xres, mode->yres);\r\nreturn 0;\r\n}\r\nif (mode->pixclock < 5000) {\r\npr_debug("%dx%d %dps pixel clock too fast",\r\nmode->xres, mode->yres, mode->pixclock);\r\nreturn 0;\r\n}\r\npr_debug("%dx%d (pixclk %dps %dMHz) valid mode", mode->xres, mode->yres,\r\nmode->pixclock, (1000000 / mode->pixclock));\r\nreturn 1;\r\n}\r\nstatic void ufx_var_color_format(struct fb_var_screeninfo *var)\r\n{\r\nconst struct fb_bitfield red = { 11, 5, 0 };\r\nconst struct fb_bitfield green = { 5, 6, 0 };\r\nconst struct fb_bitfield blue = { 0, 5, 0 };\r\nvar->bits_per_pixel = 16;\r\nvar->red = red;\r\nvar->green = green;\r\nvar->blue = blue;\r\n}\r\nstatic int ufx_ops_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct fb_videomode mode;\r\nif ((var->xres * var->yres * 2) > info->fix.smem_len)\r\nreturn -EINVAL;\r\nufx_var_color_format(var);\r\nfb_var_to_videomode(&mode, var);\r\nif (!ufx_is_valid_mode(&mode, info))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ufx_ops_set_par(struct fb_info *info)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nint result;\r\nu16 *pix_framebuffer;\r\nint i;\r\npr_debug("set_par mode %dx%d", info->var.xres, info->var.yres);\r\nresult = ufx_set_vid_mode(dev, &info->var);\r\nif ((result == 0) && (dev->fb_count == 0)) {\r\npix_framebuffer = (u16 *) info->screen_base;\r\nfor (i = 0; i < info->fix.smem_len / 2; i++)\r\npix_framebuffer[i] = 0x37e6;\r\nufx_handle_damage(dev, 0, 0, info->var.xres, info->var.yres);\r\n}\r\nif (info->fbdefio)\r\ninfo->fbdefio->delay = UFX_DEFIO_WRITE_DELAY;\r\nreturn result;\r\n}\r\nstatic int ufx_ops_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct ufx_data *dev = info->par;\r\nufx_set_vid_mode(dev, &info->var);\r\nreturn 0;\r\n}\r\nstatic int ufx_realloc_framebuffer(struct ufx_data *dev, struct fb_info *info)\r\n{\r\nint retval = -ENOMEM;\r\nint old_len = info->fix.smem_len;\r\nint new_len;\r\nunsigned char *old_fb = info->screen_base;\r\nunsigned char *new_fb;\r\npr_debug("Reallocating framebuffer. Addresses will change!");\r\nnew_len = info->fix.line_length * info->var.yres;\r\nif (PAGE_ALIGN(new_len) > old_len) {\r\nnew_fb = vmalloc(new_len);\r\nif (!new_fb) {\r\npr_err("Virtual framebuffer alloc failed");\r\ngoto error;\r\n}\r\nif (info->screen_base) {\r\nmemcpy(new_fb, old_fb, old_len);\r\nvfree(info->screen_base);\r\n}\r\ninfo->screen_base = new_fb;\r\ninfo->fix.smem_len = PAGE_ALIGN(new_len);\r\ninfo->fix.smem_start = (unsigned long) new_fb;\r\ninfo->flags = smscufx_info_flags;\r\n}\r\nretval = 0;\r\nerror:\r\nreturn retval;\r\n}\r\nstatic int ufx_i2c_init(struct ufx_data *dev)\r\n{\r\nu32 tmp;\r\nint status = ufx_reg_write(dev, 0x106C, 0x00);\r\ncheck_warn_return(status, "failed to disable I2C");\r\nstatus = ufx_reg_write(dev, 0x1018, 12);\r\ncheck_warn_return(status, "error writing 0x1018");\r\nstatus = ufx_reg_write(dev, 0x1014, 6);\r\ncheck_warn_return(status, "error writing 0x1014");\r\nstatus = ufx_reg_read(dev, 0x1000, &tmp);\r\ncheck_warn_return(status, "error reading 0x1000");\r\ntmp &= ~(0x06);\r\ntmp |= 0x02;\r\ntmp &= ~(0x10);\r\ntmp |= 0x21;\r\nstatus = ufx_reg_write(dev, 0x1000, tmp);\r\ncheck_warn_return(status, "error writing 0x1000");\r\nstatus = ufx_reg_clear_and_set_bits(dev, 0x1004, 0xC00, 0x000);\r\ncheck_warn_return(status, "error setting TX mode bits in 0x1004");\r\nstatus = ufx_reg_write(dev, 0x106C, 0x01);\r\ncheck_warn_return(status, "failed to enable I2C");\r\nreturn 0;\r\n}\r\nstatic int ufx_i2c_configure(struct ufx_data *dev)\r\n{\r\nint status = ufx_reg_write(dev, 0x106C, 0x00);\r\ncheck_warn_return(status, "failed to disable I2C");\r\nstatus = ufx_reg_write(dev, 0x3010, 0x00000000);\r\ncheck_warn_return(status, "failed to write 0x3010");\r\nstatus = ufx_reg_clear_and_set_bits(dev, 0x1004, 0x3FF, (0xA0 >> 1));\r\ncheck_warn_return(status, "failed to set TAR bits in 0x1004");\r\nstatus = ufx_reg_write(dev, 0x106C, 0x01);\r\ncheck_warn_return(status, "failed to enable I2C");\r\nreturn 0;\r\n}\r\nstatic int ufx_i2c_wait_busy(struct ufx_data *dev)\r\n{\r\nu32 tmp;\r\nint i, status;\r\nfor (i = 0; i < 15; i++) {\r\nstatus = ufx_reg_read(dev, 0x1100, &tmp);\r\ncheck_warn_return(status, "0x1100 read failed");\r\nif ((tmp & 0x80000000) == 0) {\r\nif (tmp & 0x20000000) {\r\npr_warn("I2C read failed, 0x1100=0x%08x", tmp);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nif (i >= 10)\r\nmsleep(10);\r\n}\r\npr_warn("I2C access timed out, resetting I2C hardware");\r\nstatus = ufx_reg_write(dev, 0x1100, 0x40000000);\r\ncheck_warn_return(status, "0x1100 write failed");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ufx_read_edid(struct ufx_data *dev, u8 *edid, int edid_len)\r\n{\r\nint i, j, status;\r\nu32 *edid_u32 = (u32 *)edid;\r\nBUG_ON(edid_len != EDID_LENGTH);\r\nstatus = ufx_i2c_configure(dev);\r\nif (status < 0) {\r\npr_err("ufx_i2c_configure failed");\r\nreturn status;\r\n}\r\nmemset(edid, 0xff, EDID_LENGTH);\r\nfor (i = 0; i < 2; i++) {\r\nu32 temp = 0x28070000 | (63 << 20) | (((u32)(i * 64)) << 8);\r\nstatus = ufx_reg_write(dev, 0x1100, temp);\r\ncheck_warn_return(status, "Failed to write 0x1100");\r\ntemp |= 0x80000000;\r\nstatus = ufx_reg_write(dev, 0x1100, temp);\r\ncheck_warn_return(status, "Failed to write 0x1100");\r\nstatus = ufx_i2c_wait_busy(dev);\r\ncheck_warn_return(status, "Timeout waiting for I2C BUSY to clear");\r\nfor (j = 0; j < 16; j++) {\r\nu32 data_reg_addr = 0x1110 + (j * 4);\r\nstatus = ufx_reg_read(dev, data_reg_addr, edid_u32++);\r\ncheck_warn_return(status, "Error reading i2c data");\r\n}\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nif (edid[i] != 0xFF) {\r\npr_debug("edid data read successfully");\r\nreturn EDID_LENGTH;\r\n}\r\n}\r\npr_warn("edid data contains all 0xff");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ufx_setup_modes(struct ufx_data *dev, struct fb_info *info,\r\nchar *default_edid, size_t default_edid_size)\r\n{\r\nconst struct fb_videomode *default_vmode = NULL;\r\nu8 *edid;\r\nint i, result = 0, tries = 3;\r\nif (info->dev)\r\nmutex_lock(&info->lock);\r\nedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\r\nif (!edid) {\r\nresult = -ENOMEM;\r\ngoto error;\r\n}\r\nfb_destroy_modelist(&info->modelist);\r\nmemset(&info->monspecs, 0, sizeof(info->monspecs));\r\nwhile (tries--) {\r\ni = ufx_read_edid(dev, edid, EDID_LENGTH);\r\nif (i >= EDID_LENGTH)\r\nfb_edid_to_monspecs(edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0) {\r\ndev->edid = edid;\r\ndev->edid_size = i;\r\nbreak;\r\n}\r\n}\r\nif (info->monspecs.modedb_len == 0) {\r\npr_err("Unable to get valid EDID from device/display\n");\r\nif (dev->edid) {\r\nfb_edid_to_monspecs(dev->edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0)\r\npr_err("Using previously queried EDID\n");\r\n}\r\n}\r\nif (info->monspecs.modedb_len == 0) {\r\nif (default_edid_size >= EDID_LENGTH) {\r\nfb_edid_to_monspecs(default_edid, &info->monspecs);\r\nif (info->monspecs.modedb_len > 0) {\r\nmemcpy(edid, default_edid, default_edid_size);\r\ndev->edid = edid;\r\ndev->edid_size = default_edid_size;\r\npr_err("Using default/backup EDID\n");\r\n}\r\n}\r\n}\r\nif (info->monspecs.modedb_len > 0) {\r\nfor (i = 0; i < info->monspecs.modedb_len; i++) {\r\nif (ufx_is_valid_mode(&info->monspecs.modedb[i], info))\r\nfb_add_videomode(&info->monspecs.modedb[i],\r\n&info->modelist);\r\nelse\r\ninfo->monspecs.misc &= ~FB_MISC_1ST_DETAIL;\r\n}\r\ndefault_vmode = fb_find_best_display(&info->monspecs,\r\n&info->modelist);\r\n}\r\nif (default_vmode == NULL) {\r\nstruct fb_videomode fb_vmode = {0};\r\nfor (i = 0; i < VESA_MODEDB_SIZE; i++) {\r\nif (ufx_is_valid_mode((struct fb_videomode *)\r\n&vesa_modes[i], info))\r\nfb_add_videomode(&vesa_modes[i],\r\n&info->modelist);\r\n}\r\nfb_vmode.xres = 800;\r\nfb_vmode.yres = 600;\r\nfb_vmode.refresh = 60;\r\ndefault_vmode = fb_find_nearest_mode(&fb_vmode,\r\n&info->modelist);\r\n}\r\nif ((default_vmode != NULL) && (dev->fb_count == 0)) {\r\nfb_videomode_to_var(&info->var, default_vmode);\r\nufx_var_color_format(&info->var);\r\nmemcpy(&info->fix, &ufx_fix, sizeof(ufx_fix));\r\ninfo->fix.line_length = info->var.xres *\r\n(info->var.bits_per_pixel / 8);\r\nresult = ufx_realloc_framebuffer(dev, info);\r\n} else\r\nresult = -EINVAL;\r\nerror:\r\nif (edid && (dev->edid != edid))\r\nkfree(edid);\r\nif (info->dev)\r\nmutex_unlock(&info->lock);\r\nreturn result;\r\n}\r\nstatic int ufx_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usbdev;\r\nstruct ufx_data *dev;\r\nstruct fb_info *info = NULL;\r\nint retval = -ENOMEM;\r\nu32 id_rev, fpga_rev;\r\nusbdev = interface_to_usbdev(interface);\r\nBUG_ON(!usbdev);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&usbdev->dev, "ufx_usb_probe: failed alloc of dev struct\n");\r\ngoto error;\r\n}\r\nkref_init(&dev->kref);\r\nkref_get(&dev->kref);\r\ndev->udev = usbdev;\r\ndev->gdev = &usbdev->dev;\r\nusb_set_intfdata(interface, dev);\r\ndev_dbg(dev->gdev, "%s %s - serial #%s\n",\r\nusbdev->manufacturer, usbdev->product, usbdev->serial);\r\ndev_dbg(dev->gdev, "vid_%04x&pid_%04x&rev_%04x driver's ufx_data struct at %p\n",\r\nusbdev->descriptor.idVendor, usbdev->descriptor.idProduct,\r\nusbdev->descriptor.bcdDevice, dev);\r\ndev_dbg(dev->gdev, "console enable=%d\n", console);\r\ndev_dbg(dev->gdev, "fb_defio enable=%d\n", fb_defio);\r\nif (!ufx_alloc_urb_list(dev, WRITES_IN_FLIGHT, MAX_TRANSFER)) {\r\nretval = -ENOMEM;\r\ndev_err(dev->gdev, "ufx_alloc_urb_list failed\n");\r\ngoto error;\r\n}\r\ninfo = framebuffer_alloc(0, &usbdev->dev);\r\nif (!info) {\r\nretval = -ENOMEM;\r\ndev_err(dev->gdev, "framebuffer_alloc failed\n");\r\ngoto error;\r\n}\r\ndev->info = info;\r\ninfo->par = dev;\r\ninfo->pseudo_palette = dev->pseudo_palette;\r\ninfo->fbops = &ufx_ops;\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0) {\r\ndev_err(dev->gdev, "fb_alloc_cmap failed %x\n", retval);\r\ngoto error;\r\n}\r\nINIT_DELAYED_WORK(&dev->free_framebuffer_work,\r\nufx_free_framebuffer_work);\r\nINIT_LIST_HEAD(&info->modelist);\r\nretval = ufx_reg_read(dev, 0x3000, &id_rev);\r\ncheck_warn_goto_error(retval, "error %d reading 0x3000 register from device", retval);\r\ndev_dbg(dev->gdev, "ID_REV register value 0x%08x", id_rev);\r\nretval = ufx_reg_read(dev, 0x3004, &fpga_rev);\r\ncheck_warn_goto_error(retval, "error %d reading 0x3004 register from device", retval);\r\ndev_dbg(dev->gdev, "FPGA_REV register value 0x%08x", fpga_rev);\r\ndev_dbg(dev->gdev, "resetting device");\r\nretval = ufx_lite_reset(dev);\r\ncheck_warn_goto_error(retval, "error %d resetting device", retval);\r\ndev_dbg(dev->gdev, "configuring system clock");\r\nretval = ufx_config_sys_clk(dev);\r\ncheck_warn_goto_error(retval, "error %d configuring system clock", retval);\r\ndev_dbg(dev->gdev, "configuring DDR2 controller");\r\nretval = ufx_config_ddr2(dev);\r\ncheck_warn_goto_error(retval, "error %d initialising DDR2 controller", retval);\r\ndev_dbg(dev->gdev, "configuring I2C controller");\r\nretval = ufx_i2c_init(dev);\r\ncheck_warn_goto_error(retval, "error %d initialising I2C controller", retval);\r\ndev_dbg(dev->gdev, "selecting display mode");\r\nretval = ufx_setup_modes(dev, info, NULL, 0);\r\ncheck_warn_goto_error(retval, "unable to find common mode for display and adapter");\r\nretval = ufx_reg_set_bits(dev, 0x4000, 0x00000001);\r\ncheck_warn_goto_error(retval, "error %d enabling graphics engine", retval);\r\natomic_set(&dev->usb_active, 1);\r\ndev_dbg(dev->gdev, "checking var");\r\nretval = ufx_ops_check_var(&info->var, info);\r\ncheck_warn_goto_error(retval, "error %d ufx_ops_check_var", retval);\r\ndev_dbg(dev->gdev, "setting par");\r\nretval = ufx_ops_set_par(info);\r\ncheck_warn_goto_error(retval, "error %d ufx_ops_set_par", retval);\r\ndev_dbg(dev->gdev, "registering framebuffer");\r\nretval = register_framebuffer(info);\r\ncheck_warn_goto_error(retval, "error %d register_framebuffer", retval);\r\ndev_info(dev->gdev, "SMSC UDX USB device /dev/fb%d attached. %dx%d resolution."\r\n" Using %dK framebuffer memory\n", info->node,\r\ninfo->var.xres, info->var.yres, info->fix.smem_len >> 10);\r\nreturn 0;\r\nerror:\r\nif (dev) {\r\nif (info) {\r\nif (info->cmap.len != 0)\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->monspecs.modedb)\r\nfb_destroy_modedb(info->monspecs.modedb);\r\nvfree(info->screen_base);\r\nfb_destroy_modelist(&info->modelist);\r\nframebuffer_release(info);\r\n}\r\nkref_put(&dev->kref, ufx_free);\r\nkref_put(&dev->kref, ufx_free);\r\n}\r\nreturn retval;\r\n}\r\nstatic void ufx_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct ufx_data *dev;\r\ndev = usb_get_intfdata(interface);\r\npr_debug("USB disconnect starting\n");\r\ndev->virtualized = true;\r\natomic_set(&dev->usb_active, 0);\r\nusb_set_intfdata(interface, NULL);\r\nif (dev->fb_count == 0)\r\nschedule_delayed_work(&dev->free_framebuffer_work, 0);\r\nkref_put(&dev->kref, ufx_free);\r\n}\r\nstatic void ufx_urb_completion(struct urb *urb)\r\n{\r\nstruct urb_node *unode = urb->context;\r\nstruct ufx_data *dev = unode->dev;\r\nunsigned long flags;\r\nif (urb->status) {\r\nif (!(urb->status == -ENOENT ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN)) {\r\npr_err("%s - nonzero write bulk status received: %d\n",\r\n__func__, urb->status);\r\natomic_set(&dev->lost_pixels, 1);\r\n}\r\n}\r\nurb->transfer_buffer_length = dev->urbs.size;\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nlist_add_tail(&unode->entry, &dev->urbs.list);\r\ndev->urbs.available++;\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nif (fb_defio)\r\nschedule_delayed_work(&unode->release_urb_work, 0);\r\nelse\r\nup(&dev->urbs.limit_sem);\r\n}\r\nstatic void ufx_free_urb_list(struct ufx_data *dev)\r\n{\r\nint count = dev->urbs.count;\r\nstruct list_head *node;\r\nstruct urb_node *unode;\r\nstruct urb *urb;\r\nint ret;\r\nunsigned long flags;\r\npr_debug("Waiting for completes and freeing all render urbs\n");\r\nwhile (count--) {\r\nret = down_interruptible(&dev->urbs.limit_sem);\r\nif (ret)\r\nbreak;\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nnode = dev->urbs.list.next;\r\nlist_del_init(node);\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nunode = list_entry(node, struct urb_node, entry);\r\nurb = unode->urb;\r\nusb_free_coherent(urb->dev, dev->urbs.size,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nkfree(node);\r\n}\r\n}\r\nstatic int ufx_alloc_urb_list(struct ufx_data *dev, int count, size_t size)\r\n{\r\nint i = 0;\r\nstruct urb *urb;\r\nstruct urb_node *unode;\r\nchar *buf;\r\nspin_lock_init(&dev->urbs.lock);\r\ndev->urbs.size = size;\r\nINIT_LIST_HEAD(&dev->urbs.list);\r\nwhile (i < count) {\r\nunode = kzalloc(sizeof(struct urb_node), GFP_KERNEL);\r\nif (!unode)\r\nbreak;\r\nunode->dev = dev;\r\nINIT_DELAYED_WORK(&unode->release_urb_work,\r\nufx_release_urb_work);\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nkfree(unode);\r\nbreak;\r\n}\r\nunode->urb = urb;\r\nbuf = usb_alloc_coherent(dev->udev, size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nkfree(unode);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 1),\r\nbuf, size, ufx_urb_completion, unode);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nlist_add_tail(&unode->entry, &dev->urbs.list);\r\ni++;\r\n}\r\nsema_init(&dev->urbs.limit_sem, i);\r\ndev->urbs.count = i;\r\ndev->urbs.available = i;\r\npr_debug("allocated %d %d byte urbs\n", i, (int) size);\r\nreturn i;\r\n}\r\nstatic struct urb *ufx_get_urb(struct ufx_data *dev)\r\n{\r\nint ret = 0;\r\nstruct list_head *entry;\r\nstruct urb_node *unode;\r\nstruct urb *urb = NULL;\r\nunsigned long flags;\r\nret = down_timeout(&dev->urbs.limit_sem, GET_URB_TIMEOUT);\r\nif (ret) {\r\natomic_set(&dev->lost_pixels, 1);\r\npr_warn("wait for urb interrupted: %x available: %d\n",\r\nret, dev->urbs.available);\r\ngoto error;\r\n}\r\nspin_lock_irqsave(&dev->urbs.lock, flags);\r\nBUG_ON(list_empty(&dev->urbs.list));\r\nentry = dev->urbs.list.next;\r\nlist_del_init(entry);\r\ndev->urbs.available--;\r\nspin_unlock_irqrestore(&dev->urbs.lock, flags);\r\nunode = list_entry(entry, struct urb_node, entry);\r\nurb = unode->urb;\r\nerror:\r\nreturn urb;\r\n}\r\nstatic int ufx_submit_urb(struct ufx_data *dev, struct urb *urb, size_t len)\r\n{\r\nint ret;\r\nBUG_ON(len > dev->urbs.size);\r\nurb->transfer_buffer_length = len;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nufx_urb_completion(urb);\r\natomic_set(&dev->lost_pixels, 1);\r\npr_err("usb_submit_urb error %x\n", ret);\r\n}\r\nreturn ret;\r\n}
