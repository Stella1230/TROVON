static int receive_data(struct gb_raw *raw, u32 len, u8 *data)\r\n{\r\nstruct raw_data *raw_data;\r\nstruct device *dev = &raw->connection->bundle->dev;\r\nint retval = 0;\r\nif (len > MAX_PACKET_SIZE) {\r\ndev_err(dev, "Too big of a data packet, rejected\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&raw->list_lock);\r\nif ((raw->list_data + len) > MAX_DATA_SIZE) {\r\ndev_err(dev, "Too much data in receive buffer, now dropping packets\n");\r\nretval = -EINVAL;\r\ngoto exit;\r\n}\r\nraw_data = kmalloc(sizeof(*raw_data) + len, GFP_KERNEL);\r\nif (!raw_data) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nraw->list_data += len;\r\nraw_data->len = len;\r\nmemcpy(&raw_data->data[0], data, len);\r\nlist_add_tail(&raw_data->entry, &raw->list);\r\nexit:\r\nmutex_unlock(&raw->list_lock);\r\nreturn retval;\r\n}\r\nstatic int gb_raw_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct device *dev = &connection->bundle->dev;\r\nstruct gb_raw *raw = greybus_get_drvdata(connection->bundle);\r\nstruct gb_raw_send_request *receive;\r\nu32 len;\r\nif (op->type != GB_RAW_TYPE_SEND) {\r\ndev_err(dev, "unknown request type 0x%02x\n", op->type);\r\nreturn -EINVAL;\r\n}\r\nif (op->request->payload_size < sizeof(*receive)) {\r\ndev_err(dev, "raw receive request too small (%zu < %zu)\n",\r\nop->request->payload_size, sizeof(*receive));\r\nreturn -EINVAL;\r\n}\r\nreceive = op->request->payload;\r\nlen = le32_to_cpu(receive->len);\r\nif (len != (int)(op->request->payload_size - sizeof(__le32))) {\r\ndev_err(dev, "raw receive request wrong size %d vs %d\n", len,\r\n(int)(op->request->payload_size - sizeof(__le32)));\r\nreturn -EINVAL;\r\n}\r\nif (len == 0) {\r\ndev_err(dev, "raw receive request of 0 bytes?\n");\r\nreturn -EINVAL;\r\n}\r\nreturn receive_data(raw, len, receive->data);\r\n}\r\nstatic int gb_raw_send(struct gb_raw *raw, u32 len, const char __user *data)\r\n{\r\nstruct gb_connection *connection = raw->connection;\r\nstruct gb_raw_send_request *request;\r\nint retval;\r\nrequest = kmalloc(len + sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nif (copy_from_user(&request->data[0], data, len)) {\r\nkfree(request);\r\nreturn -EFAULT;\r\n}\r\nrequest->len = cpu_to_le32(len);\r\nretval = gb_operation_sync(connection, GB_RAW_TYPE_SEND,\r\nrequest, len + sizeof(*request),\r\nNULL, 0);\r\nkfree(request);\r\nreturn retval;\r\n}\r\nstatic int gb_raw_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct gb_raw *raw;\r\nint retval;\r\nint minor;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_RAW)\r\nreturn -ENODEV;\r\nraw = kzalloc(sizeof(*raw), GFP_KERNEL);\r\nif (!raw)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngb_raw_request_handler);\r\nif (IS_ERR(connection)) {\r\nretval = PTR_ERR(connection);\r\ngoto error_free;\r\n}\r\nINIT_LIST_HEAD(&raw->list);\r\nmutex_init(&raw->list_lock);\r\nraw->connection = connection;\r\ngreybus_set_drvdata(bundle, raw);\r\nminor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);\r\nif (minor < 0) {\r\nretval = minor;\r\ngoto error_connection_destroy;\r\n}\r\nraw->dev = MKDEV(raw_major, minor);\r\ncdev_init(&raw->cdev, &raw_fops);\r\nretval = gb_connection_enable(connection);\r\nif (retval)\r\ngoto error_remove_ida;\r\nretval = cdev_add(&raw->cdev, raw->dev, 1);\r\nif (retval)\r\ngoto error_connection_disable;\r\nraw->device = device_create(raw_class, &connection->bundle->dev,\r\nraw->dev, raw, "gb!raw%d", minor);\r\nif (IS_ERR(raw->device)) {\r\nretval = PTR_ERR(raw->device);\r\ngoto error_del_cdev;\r\n}\r\nreturn 0;\r\nerror_del_cdev:\r\ncdev_del(&raw->cdev);\r\nerror_connection_disable:\r\ngb_connection_disable(connection);\r\nerror_remove_ida:\r\nida_simple_remove(&minors, minor);\r\nerror_connection_destroy:\r\ngb_connection_destroy(connection);\r\nerror_free:\r\nkfree(raw);\r\nreturn retval;\r\n}\r\nstatic void gb_raw_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_raw *raw = greybus_get_drvdata(bundle);\r\nstruct gb_connection *connection = raw->connection;\r\nstruct raw_data *raw_data;\r\nstruct raw_data *temp;\r\ndevice_destroy(raw_class, raw->dev);\r\ncdev_del(&raw->cdev);\r\ngb_connection_disable(connection);\r\nida_simple_remove(&minors, MINOR(raw->dev));\r\ngb_connection_destroy(connection);\r\nmutex_lock(&raw->list_lock);\r\nlist_for_each_entry_safe(raw_data, temp, &raw->list, entry) {\r\nlist_del(&raw_data->entry);\r\nkfree(raw_data);\r\n}\r\nmutex_unlock(&raw->list_lock);\r\nkfree(raw);\r\n}\r\nstatic int raw_open(struct inode *inode, struct file *file)\r\n{\r\nstruct cdev *cdev = inode->i_cdev;\r\nstruct gb_raw *raw = container_of(cdev, struct gb_raw, cdev);\r\nfile->private_data = raw;\r\nreturn 0;\r\n}\r\nstatic ssize_t raw_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct gb_raw *raw = file->private_data;\r\nint retval;\r\nif (!count)\r\nreturn 0;\r\nif (count > MAX_PACKET_SIZE)\r\nreturn -E2BIG;\r\nretval = gb_raw_send(raw, count, buf);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t raw_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct gb_raw *raw = file->private_data;\r\nint retval = 0;\r\nstruct raw_data *raw_data;\r\nmutex_lock(&raw->list_lock);\r\nif (list_empty(&raw->list))\r\ngoto exit;\r\nraw_data = list_first_entry(&raw->list, struct raw_data, entry);\r\nif (raw_data->len > count) {\r\nretval = -ENOSPC;\r\ngoto exit;\r\n}\r\nif (copy_to_user(buf, &raw_data->data[0], raw_data->len)) {\r\nretval = -EFAULT;\r\ngoto exit;\r\n}\r\nlist_del(&raw_data->entry);\r\nraw->list_data -= raw_data->len;\r\nretval = raw_data->len;\r\nkfree(raw_data);\r\nexit:\r\nmutex_unlock(&raw->list_lock);\r\nreturn retval;\r\n}\r\nstatic int raw_init(void)\r\n{\r\ndev_t dev;\r\nint retval;\r\nraw_class = class_create(THIS_MODULE, "gb_raw");\r\nif (IS_ERR(raw_class)) {\r\nretval = PTR_ERR(raw_class);\r\ngoto error_class;\r\n}\r\nretval = alloc_chrdev_region(&dev, 0, NUM_MINORS, "gb_raw");\r\nif (retval < 0)\r\ngoto error_chrdev;\r\nraw_major = MAJOR(dev);\r\nretval = greybus_register(&gb_raw_driver);\r\nif (retval)\r\ngoto error_gb;\r\nreturn 0;\r\nerror_gb:\r\nunregister_chrdev_region(dev, NUM_MINORS);\r\nerror_chrdev:\r\nclass_destroy(raw_class);\r\nerror_class:\r\nreturn retval;\r\n}\r\nstatic void __exit raw_exit(void)\r\n{\r\ngreybus_deregister(&gb_raw_driver);\r\nunregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);\r\nclass_destroy(raw_class);\r\nida_destroy(&minors);\r\n}
