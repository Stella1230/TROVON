static struct llog_handle *llog_alloc_handle(void)\r\n{\r\nstruct llog_handle *loghandle;\r\nloghandle = kzalloc(sizeof(*loghandle), GFP_NOFS);\r\nif (!loghandle)\r\nreturn NULL;\r\ninit_rwsem(&loghandle->lgh_lock);\r\nspin_lock_init(&loghandle->lgh_hdr_lock);\r\nINIT_LIST_HEAD(&loghandle->u.phd.phd_entry);\r\natomic_set(&loghandle->lgh_refcount, 1);\r\nreturn loghandle;\r\n}\r\nstatic void llog_free_handle(struct llog_handle *loghandle)\r\n{\r\nif (!loghandle->lgh_hdr)\r\ngoto out;\r\nif (loghandle->lgh_hdr->llh_flags & LLOG_F_IS_PLAIN)\r\nLASSERT(list_empty(&loghandle->u.phd.phd_entry));\r\nelse if (loghandle->lgh_hdr->llh_flags & LLOG_F_IS_CAT)\r\nLASSERT(list_empty(&loghandle->u.chd.chd_head));\r\nkvfree(loghandle->lgh_hdr);\r\nout:\r\nkfree(loghandle);\r\n}\r\nvoid llog_handle_get(struct llog_handle *loghandle)\r\n{\r\natomic_inc(&loghandle->lgh_refcount);\r\n}\r\nvoid llog_handle_put(struct llog_handle *loghandle)\r\n{\r\nLASSERT(atomic_read(&loghandle->lgh_refcount) > 0);\r\nif (atomic_dec_and_test(&loghandle->lgh_refcount))\r\nllog_free_handle(loghandle);\r\n}\r\nstatic int llog_read_header(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct obd_uuid *uuid)\r\n{\r\nstruct llog_operations *lop;\r\nint rc;\r\nrc = llog_handle2ops(handle, &lop);\r\nif (rc)\r\nreturn rc;\r\nif (!lop->lop_read_header)\r\nreturn -EOPNOTSUPP;\r\nrc = lop->lop_read_header(env, handle);\r\nif (rc == LLOG_EEMPTY) {\r\nstruct llog_log_hdr *llh = handle->lgh_hdr;\r\nsize_t len;\r\nhandle->lgh_last_idx = 0;\r\nllh->llh_count = 1;\r\nllh->llh_hdr.lrh_type = LLOG_HDR_MAGIC;\r\nLASSERT(handle->lgh_ctxt->loc_chunk_size >= LLOG_MIN_CHUNK_SIZE);\r\nllh->llh_hdr.lrh_len = handle->lgh_ctxt->loc_chunk_size;\r\nllh->llh_hdr.lrh_index = 0;\r\nllh->llh_timestamp = ktime_get_real_seconds();\r\nif (uuid)\r\nmemcpy(&llh->llh_tgtuuid, uuid,\r\nsizeof(llh->llh_tgtuuid));\r\nllh->llh_bitmap_offset = offsetof(typeof(*llh), llh_bitmap);\r\nlen = llh->llh_hdr.lrh_len - llh->llh_bitmap_offset;\r\nmemset(LLOG_HDR_BITMAP(llh), 0, len - sizeof(llh->llh_tail));\r\next2_set_bit(0, LLOG_HDR_BITMAP(llh));\r\nLLOG_HDR_TAIL(llh)->lrt_len = llh->llh_hdr.lrh_len;\r\nLLOG_HDR_TAIL(llh)->lrt_index = llh->llh_hdr.lrh_index;\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint llog_init_handle(const struct lu_env *env, struct llog_handle *handle,\r\nint flags, struct obd_uuid *uuid)\r\n{\r\nint chunk_size = handle->lgh_ctxt->loc_chunk_size;\r\nenum llog_flag fmt = flags & LLOG_F_EXT_MASK;\r\nstruct llog_log_hdr *llh;\r\nint rc;\r\nLASSERT(!handle->lgh_hdr);\r\nLASSERT(chunk_size >= LLOG_MIN_CHUNK_SIZE);\r\nllh = libcfs_kvzalloc(sizeof(*llh), GFP_NOFS);\r\nif (!llh)\r\nreturn -ENOMEM;\r\nhandle->lgh_hdr = llh;\r\nhandle->lgh_hdr_size = chunk_size;\r\nllh->llh_flags = flags;\r\nrc = llog_read_header(env, handle, uuid);\r\nif (rc == 0) {\r\nif (unlikely((llh->llh_flags & LLOG_F_IS_PLAIN &&\r\nflags & LLOG_F_IS_CAT) ||\r\n(llh->llh_flags & LLOG_F_IS_CAT &&\r\nflags & LLOG_F_IS_PLAIN))) {\r\nCERROR("%s: llog type is %s but initializing %s\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\nllh->llh_flags & LLOG_F_IS_CAT ?\r\n"catalog" : "plain",\r\nflags & LLOG_F_IS_CAT ? "catalog" : "plain");\r\nrc = -EINVAL;\r\ngoto out;\r\n} else if (llh->llh_flags &\r\n(LLOG_F_IS_PLAIN | LLOG_F_IS_CAT)) {\r\nflags = llh->llh_flags;\r\n} else {\r\nCERROR("llog type is not specified!\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely(uuid &&\r\n!obd_uuid_equals(uuid, &llh->llh_tgtuuid))) {\r\nCERROR("%s: llog uuid mismatch: %s/%s\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\n(char *)uuid->uuid,\r\n(char *)llh->llh_tgtuuid.uuid);\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nif (flags & LLOG_F_IS_CAT) {\r\nLASSERT(list_empty(&handle->u.chd.chd_head));\r\nINIT_LIST_HEAD(&handle->u.chd.chd_head);\r\nllh->llh_size = sizeof(struct llog_logid_rec);\r\nllh->llh_flags |= LLOG_F_IS_FIXSIZE;\r\n} else if (!(flags & LLOG_F_IS_PLAIN)) {\r\nCERROR("%s: unknown flags: %#x (expected %#x or %#x)\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\nflags, LLOG_F_IS_CAT, LLOG_F_IS_PLAIN);\r\nrc = -EINVAL;\r\n}\r\nllh->llh_flags |= fmt;\r\nout:\r\nif (rc) {\r\nkvfree(llh);\r\nhandle->lgh_hdr = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_process_thread(void *arg)\r\n{\r\nstruct llog_process_info *lpi = arg;\r\nstruct llog_handle *loghandle = lpi->lpi_loghandle;\r\nstruct llog_log_hdr *llh = loghandle->lgh_hdr;\r\nstruct llog_process_cat_data *cd = lpi->lpi_catdata;\r\nchar *buf;\r\nu64 cur_offset, tmp_offset;\r\nint chunk_size;\r\nint rc = 0, index = 1, last_index;\r\nint saved_index = 0;\r\nint last_called_index = 0;\r\nif (!llh)\r\nreturn -EINVAL;\r\ncur_offset = llh->llh_hdr.lrh_len;\r\nchunk_size = llh->llh_hdr.lrh_len;\r\nLASSERT(is_power_of_2(chunk_size));\r\nbuf = libcfs_kvzalloc(chunk_size, GFP_NOFS);\r\nif (!buf) {\r\nlpi->lpi_rc = -ENOMEM;\r\nreturn 0;\r\n}\r\nif (cd) {\r\nlast_called_index = cd->lpcd_first_idx;\r\nindex = cd->lpcd_first_idx + 1;\r\n}\r\nif (cd && cd->lpcd_last_idx)\r\nlast_index = cd->lpcd_last_idx;\r\nelse\r\nlast_index = LLOG_HDR_BITMAP_SIZE(llh) - 1;\r\nwhile (rc == 0) {\r\nunsigned int buf_offset = 0;\r\nstruct llog_rec_hdr *rec;\r\nbool partial_chunk;\r\noff_t chunk_offset;\r\nwhile (index <= last_index &&\r\n!ext2_test_bit(index, LLOG_HDR_BITMAP(llh)))\r\n++index;\r\nif (index > last_index)\r\nbreak;\r\nCDEBUG(D_OTHER, "index: %d last_index %d\n",\r\nindex, last_index);\r\nrepeat:\r\nmemset(buf, 0, chunk_size);\r\nrc = llog_next_block(lpi->lpi_env, loghandle, &saved_index,\r\nindex, &cur_offset, buf, chunk_size);\r\nif (rc)\r\ngoto out;\r\ntmp_offset = cur_offset;\r\nif (do_div(tmp_offset, chunk_size)) {\r\npartial_chunk = true;\r\nchunk_offset = cur_offset & ~(chunk_size - 1);\r\n} else {\r\npartial_chunk = false;\r\nchunk_offset = cur_offset - chunk_size;\r\n}\r\nfor (rec = (struct llog_rec_hdr *)(buf + buf_offset);\r\n(char *)rec < buf + chunk_size;\r\nrec = llog_rec_hdr_next(rec)) {\r\nCDEBUG(D_OTHER, "processing rec 0x%p type %#x\n",\r\nrec, rec->lrh_type);\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\nCDEBUG(D_OTHER, "after swabbing, type=%#x idx=%d\n",\r\nrec->lrh_type, rec->lrh_index);\r\nif (partial_chunk && !rec->lrh_index) {\r\nif (index > loghandle->lgh_last_idx) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nCDEBUG(D_OTHER, "Re-read last llog buffer for new records, index %u, last %u\n",\r\nindex, loghandle->lgh_last_idx);\r\nbuf_offset = (char *)rec - (char *)buf;\r\ncur_offset = chunk_offset;\r\ngoto repeat;\r\n}\r\nif (!rec->lrh_len || rec->lrh_len > chunk_size) {\r\nCWARN("invalid length %d in llog record for index %d/%d\n",\r\nrec->lrh_len,\r\nrec->lrh_index, index);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (rec->lrh_index < index) {\r\nCDEBUG(D_OTHER, "skipping lrh_index %d\n",\r\nrec->lrh_index);\r\ncontinue;\r\n}\r\nif (rec->lrh_index != index) {\r\nCERROR("%s: Invalid record: index %u but expected %u\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nrec->lrh_index, index);\r\nrc = -ERANGE;\r\ngoto out;\r\n}\r\nCDEBUG(D_OTHER,\r\n"lrh_index: %d lrh_len: %d (%d remains)\n",\r\nrec->lrh_index, rec->lrh_len,\r\n(int)(buf + chunk_size - (char *)rec));\r\nloghandle->lgh_cur_idx = rec->lrh_index;\r\nloghandle->lgh_cur_offset = (char *)rec - (char *)buf +\r\nchunk_offset;\r\nif (ext2_test_bit(index, LLOG_HDR_BITMAP(llh))) {\r\nrc = lpi->lpi_cb(lpi->lpi_env, loghandle, rec,\r\nlpi->lpi_cbdata);\r\nlast_called_index = index;\r\nif (rc)\r\ngoto out;\r\n}\r\nif (index >= last_index) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nindex++;\r\n}\r\n}\r\nout:\r\nif (cd)\r\ncd->lpcd_last_idx = last_called_index;\r\nkfree(buf);\r\nlpi->lpi_rc = rc;\r\nreturn 0;\r\n}\r\nstatic int llog_process_thread_daemonize(void *arg)\r\n{\r\nstruct llog_process_info *lpi = arg;\r\nstruct lu_env env;\r\nint rc;\r\nunshare_fs_struct();\r\nrc = lu_env_init(&env, LCT_LOCAL | LCT_MG_THREAD);\r\nif (rc)\r\ngoto out;\r\nlpi->lpi_env = &env;\r\nrc = llog_process_thread(arg);\r\nlu_env_fini(&env);\r\nout:\r\ncomplete(&lpi->lpi_completion);\r\nreturn rc;\r\n}\r\nint llog_process_or_fork(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nllog_cb_t cb, void *data, void *catdata, bool fork)\r\n{\r\nstruct llog_process_info *lpi;\r\nint rc;\r\nlpi = kzalloc(sizeof(*lpi), GFP_NOFS);\r\nif (!lpi)\r\nreturn -ENOMEM;\r\nlpi->lpi_loghandle = loghandle;\r\nlpi->lpi_cb = cb;\r\nlpi->lpi_cbdata = data;\r\nlpi->lpi_catdata = catdata;\r\nif (fork) {\r\nstruct task_struct *task;\r\nlpi->lpi_env = NULL;\r\ninit_completion(&lpi->lpi_completion);\r\ntask = kthread_run(llog_process_thread_daemonize, lpi,\r\n"llog_process_thread");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("%s: cannot start thread: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name, rc);\r\ngoto out_lpi;\r\n}\r\nwait_for_completion(&lpi->lpi_completion);\r\n} else {\r\nlpi->lpi_env = env;\r\nllog_process_thread(lpi);\r\n}\r\nrc = lpi->lpi_rc;\r\nout_lpi:\r\nkfree(lpi);\r\nreturn rc;\r\n}\r\nint llog_process(const struct lu_env *env, struct llog_handle *loghandle,\r\nllog_cb_t cb, void *data, void *catdata)\r\n{\r\nreturn llog_process_or_fork(env, loghandle, cb, data, catdata, true);\r\n}\r\nint llog_open(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nstruct llog_handle **lgh, struct llog_logid *logid,\r\nchar *name, enum llog_open_param open_param)\r\n{\r\nint raised;\r\nint rc;\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_logops);\r\nif (!ctxt->loc_logops->lop_open) {\r\n*lgh = NULL;\r\nreturn -EOPNOTSUPP;\r\n}\r\n*lgh = llog_alloc_handle();\r\nif (!*lgh)\r\nreturn -ENOMEM;\r\n(*lgh)->lgh_ctxt = ctxt;\r\n(*lgh)->lgh_logops = ctxt->loc_logops;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = ctxt->loc_logops->lop_open(env, *lgh, logid, name, open_param);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nif (rc) {\r\nllog_free_handle(*lgh);\r\n*lgh = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint llog_close(const struct lu_env *env, struct llog_handle *loghandle)\r\n{\r\nstruct llog_operations *lop;\r\nint rc;\r\nrc = llog_handle2ops(loghandle, &lop);\r\nif (rc)\r\ngoto out;\r\nif (!lop->lop_close) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = lop->lop_close(env, loghandle);\r\nout:\r\nllog_handle_put(loghandle);\r\nreturn rc;\r\n}
