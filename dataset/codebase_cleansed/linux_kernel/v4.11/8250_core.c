static irqreturn_t serial8250_interrupt(int irq, void *dev_id)\r\n{\r\nstruct irq_info *i = dev_id;\r\nstruct list_head *l, *end = NULL;\r\nint pass_counter = 0, handled = 0;\r\npr_debug("%s(%d): start\n", __func__, irq);\r\nspin_lock(&i->lock);\r\nl = i->head;\r\ndo {\r\nstruct uart_8250_port *up;\r\nstruct uart_port *port;\r\nup = list_entry(l, struct uart_8250_port, list);\r\nport = &up->port;\r\nif (port->handle_irq(port)) {\r\nhandled = 1;\r\nend = NULL;\r\n} else if (end == NULL)\r\nend = l;\r\nl = l->next;\r\nif (l == i->head && pass_counter++ > PASS_LIMIT) {\r\nprintk_ratelimited(KERN_ERR\r\n"serial8250: too much work for irq%d\n", irq);\r\nbreak;\r\n}\r\n} while (l != end);\r\nspin_unlock(&i->lock);\r\npr_debug("%s(%d): end\n", __func__, irq);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)\r\n{\r\nspin_lock_irq(&i->lock);\r\nif (!list_empty(i->head)) {\r\nif (i->head == &up->list)\r\ni->head = i->head->next;\r\nlist_del(&up->list);\r\n} else {\r\nBUG_ON(i->head != &up->list);\r\ni->head = NULL;\r\n}\r\nspin_unlock_irq(&i->lock);\r\nif (i->head == NULL) {\r\nhlist_del(&i->node);\r\nkfree(i);\r\n}\r\n}\r\nstatic int serial_link_irq_chain(struct uart_8250_port *up)\r\n{\r\nstruct hlist_head *h;\r\nstruct hlist_node *n;\r\nstruct irq_info *i;\r\nint ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;\r\nmutex_lock(&hash_mutex);\r\nh = &irq_lists[up->port.irq % NR_IRQ_HASH];\r\nhlist_for_each(n, h) {\r\ni = hlist_entry(n, struct irq_info, node);\r\nif (i->irq == up->port.irq)\r\nbreak;\r\n}\r\nif (n == NULL) {\r\ni = kzalloc(sizeof(struct irq_info), GFP_KERNEL);\r\nif (i == NULL) {\r\nmutex_unlock(&hash_mutex);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&i->lock);\r\ni->irq = up->port.irq;\r\nhlist_add_head(&i->node, h);\r\n}\r\nmutex_unlock(&hash_mutex);\r\nspin_lock_irq(&i->lock);\r\nif (i->head) {\r\nlist_add(&up->list, i->head);\r\nspin_unlock_irq(&i->lock);\r\nret = 0;\r\n} else {\r\nINIT_LIST_HEAD(&up->list);\r\ni->head = &up->list;\r\nspin_unlock_irq(&i->lock);\r\nirq_flags |= up->port.irqflags;\r\nret = request_irq(up->port.irq, serial8250_interrupt,\r\nirq_flags, "serial", i);\r\nif (ret < 0)\r\nserial_do_unlink(i, up);\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial_unlink_irq_chain(struct uart_8250_port *up)\r\n{\r\nstruct irq_info *i;\r\nstruct hlist_node *n;\r\nstruct hlist_head *h;\r\nmutex_lock(&hash_mutex);\r\nh = &irq_lists[up->port.irq % NR_IRQ_HASH];\r\nhlist_for_each(n, h) {\r\ni = hlist_entry(n, struct irq_info, node);\r\nif (i->irq == up->port.irq)\r\nbreak;\r\n}\r\nBUG_ON(n == NULL);\r\nBUG_ON(i->head == NULL);\r\nif (list_empty(i->head))\r\nfree_irq(up->port.irq, i);\r\nserial_do_unlink(i, up);\r\nmutex_unlock(&hash_mutex);\r\n}\r\nstatic void serial8250_timeout(unsigned long data)\r\n{\r\nstruct uart_8250_port *up = (struct uart_8250_port *)data;\r\nup->port.handle_irq(&up->port);\r\nmod_timer(&up->timer, jiffies + uart_poll_timeout(&up->port));\r\n}\r\nstatic void serial8250_backup_timeout(unsigned long data)\r\n{\r\nstruct uart_8250_port *up = (struct uart_8250_port *)data;\r\nunsigned int iir, ier = 0, lsr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (up->port.irq) {\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, 0);\r\n}\r\niir = serial_in(up, UART_IIR);\r\nlsr = serial_in(up, UART_LSR);\r\nup->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;\r\nif ((iir & UART_IIR_NO_INT) && (up->ier & UART_IER_THRI) &&\r\n(!uart_circ_empty(&up->port.state->xmit) || up->port.x_char) &&\r\n(lsr & UART_LSR_THRE)) {\r\niir &= ~(UART_IIR_ID | UART_IIR_NO_INT);\r\niir |= UART_IIR_THRI;\r\n}\r\nif (!(iir & UART_IIR_NO_INT))\r\nserial8250_tx_chars(up);\r\nif (up->port.irq)\r\nserial_out(up, UART_IER, ier);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nmod_timer(&up->timer,\r\njiffies + uart_poll_timeout(&up->port) + HZ / 5);\r\n}\r\nstatic int univ8250_setup_irq(struct uart_8250_port *up)\r\n{\r\nstruct uart_port *port = &up->port;\r\nint retval = 0;\r\nif (up->bugs & UART_BUG_THRE) {\r\npr_debug("ttyS%d - using backup timer\n", serial_index(port));\r\nup->timer.function = serial8250_backup_timeout;\r\nup->timer.data = (unsigned long)up;\r\nmod_timer(&up->timer, jiffies +\r\nuart_poll_timeout(port) + HZ / 5);\r\n}\r\nif (!port->irq) {\r\nup->timer.data = (unsigned long)up;\r\nmod_timer(&up->timer, jiffies + uart_poll_timeout(port));\r\n} else\r\nretval = serial_link_irq_chain(up);\r\nreturn retval;\r\n}\r\nstatic void univ8250_release_irq(struct uart_8250_port *up)\r\n{\r\nstruct uart_port *port = &up->port;\r\ndel_timer_sync(&up->timer);\r\nup->timer.function = serial8250_timeout;\r\nif (port->irq)\r\nserial_unlink_irq_chain(up);\r\n}\r\nstatic int serial8250_request_rsa_resource(struct uart_8250_port *up)\r\n{\r\nunsigned long start = UART_RSA_BASE << up->port.regshift;\r\nunsigned int size = 8 << up->port.regshift;\r\nstruct uart_port *port = &up->port;\r\nint ret = -EINVAL;\r\nswitch (port->iotype) {\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nstart += port->iobase;\r\nif (request_region(start, size, "serial-rsa"))\r\nret = 0;\r\nelse\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void serial8250_release_rsa_resource(struct uart_8250_port *up)\r\n{\r\nunsigned long offset = UART_RSA_BASE << up->port.regshift;\r\nunsigned int size = 8 << up->port.regshift;\r\nstruct uart_port *port = &up->port;\r\nswitch (port->iotype) {\r\ncase UPIO_HUB6:\r\ncase UPIO_PORT:\r\nrelease_region(port->iobase + offset, size);\r\nbreak;\r\n}\r\n}\r\nstruct uart_8250_port *serial8250_get_port(int line)\r\n{\r\nreturn &serial8250_ports[line];\r\n}\r\nvoid serial8250_set_isa_configurator(\r\nvoid (*v)(int port, struct uart_port *up, u32 *capabilities))\r\n{\r\nserial8250_isa_config = v;\r\n}\r\nstatic void univ8250_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nup->probe &= ~UART_PROBE_RSA;\r\nif (port->type == PORT_RSA) {\r\nif (serial8250_request_rsa_resource(up) == 0)\r\nup->probe |= UART_PROBE_RSA;\r\n} else if (flags & UART_CONFIG_TYPE) {\r\nint i;\r\nfor (i = 0; i < probe_rsa_count; i++) {\r\nif (probe_rsa[i] == up->port.iobase) {\r\nif (serial8250_request_rsa_resource(up) == 0)\r\nup->probe |= UART_PROBE_RSA;\r\nbreak;\r\n}\r\n}\r\n}\r\nbase_ops->config_port(port, flags);\r\nif (port->type != PORT_RSA && up->probe & UART_PROBE_RSA)\r\nserial8250_release_rsa_resource(up);\r\n}\r\nstatic int univ8250_request_port(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nint ret;\r\nret = base_ops->request_port(port);\r\nif (ret == 0 && port->type == PORT_RSA) {\r\nret = serial8250_request_rsa_resource(up);\r\nif (ret < 0)\r\nbase_ops->release_port(port);\r\n}\r\nreturn ret;\r\n}\r\nstatic void univ8250_release_port(struct uart_port *port)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(port);\r\nif (port->type == PORT_RSA)\r\nserial8250_release_rsa_resource(up);\r\nbase_ops->release_port(port);\r\n}\r\nstatic void univ8250_rsa_support(struct uart_ops *ops)\r\n{\r\nops->config_port = univ8250_config_port;\r\nops->request_port = univ8250_request_port;\r\nops->release_port = univ8250_release_port;\r\n}\r\nstatic void __init serial8250_isa_init_ports(void)\r\n{\r\nstruct uart_8250_port *up;\r\nstatic int first = 1;\r\nint i, irqflag = 0;\r\nif (!first)\r\nreturn;\r\nfirst = 0;\r\nif (nr_uarts > UART_NR)\r\nnr_uarts = UART_NR;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nstruct uart_port *port = &up->port;\r\nport->line = i;\r\nserial8250_init_port(up);\r\nif (!base_ops)\r\nbase_ops = port->ops;\r\nport->ops = &univ8250_port_ops;\r\ninit_timer(&up->timer);\r\nup->timer.function = serial8250_timeout;\r\nup->ops = &univ8250_driver_ops;\r\nup->mcr_mask = ~ALPHA_KLUDGE_MCR;\r\nup->mcr_force = ALPHA_KLUDGE_MCR;\r\n}\r\nuniv8250_port_ops = *base_ops;\r\nuniv8250_rsa_support(&univ8250_port_ops);\r\nif (share_irqs)\r\nirqflag = IRQF_SHARED;\r\nfor (i = 0, up = serial8250_ports;\r\ni < ARRAY_SIZE(old_serial_port) && i < nr_uarts;\r\ni++, up++) {\r\nstruct uart_port *port = &up->port;\r\nport->iobase = old_serial_port[i].port;\r\nport->irq = irq_canonicalize(old_serial_port[i].irq);\r\nport->irqflags = 0;\r\nport->uartclk = old_serial_port[i].baud_base * 16;\r\nport->flags = old_serial_port[i].flags;\r\nport->hub6 = 0;\r\nport->membase = old_serial_port[i].iomem_base;\r\nport->iotype = old_serial_port[i].io_type;\r\nport->regshift = old_serial_port[i].iomem_reg_shift;\r\nserial8250_set_defaults(up);\r\nport->irqflags |= irqflag;\r\nif (serial8250_isa_config != NULL)\r\nserial8250_isa_config(i, &up->port, &up->capabilities);\r\n}\r\n}\r\nstatic void __init\r\nserial8250_register_ports(struct uart_driver *drv, struct device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.type == PORT_8250_CIR)\r\ncontinue;\r\nif (up->port.dev)\r\ncontinue;\r\nup->port.dev = dev;\r\nif (skip_txen_test)\r\nup->port.flags |= UPF_NO_TXEN_TEST;\r\nuart_add_one_port(drv, &up->port);\r\n}\r\n}\r\nstatic void univ8250_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_8250_port *up = &serial8250_ports[co->index];\r\nserial8250_console_write(up, s, count);\r\n}\r\nstatic int univ8250_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint retval;\r\nif (co->index >= nr_uarts)\r\nco->index = 0;\r\nport = &serial8250_ports[co->index].port;\r\nport->cons = co;\r\nretval = serial8250_console_setup(port, options, false);\r\nif (retval != 0)\r\nport->cons = NULL;\r\nreturn retval;\r\n}\r\nstatic int univ8250_console_match(struct console *co, char *name, int idx,\r\nchar *options)\r\n{\r\nchar match[] = "uart";\r\nunsigned char iotype;\r\nresource_size_t addr;\r\nint i;\r\nif (strncmp(name, match, 4) != 0)\r\nreturn -ENODEV;\r\nif (uart_parse_earlycon(options, &iotype, &addr, &options))\r\nreturn -ENODEV;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_port *port = &serial8250_ports[i].port;\r\nif (port->iotype != iotype)\r\ncontinue;\r\nif ((iotype == UPIO_MEM || iotype == UPIO_MEM16 ||\r\niotype == UPIO_MEM32 || iotype == UPIO_MEM32BE)\r\n&& (port->mapbase != addr))\r\ncontinue;\r\nif (iotype == UPIO_PORT && port->iobase != addr)\r\ncontinue;\r\nco->index = i;\r\nport->cons = co;\r\nreturn serial8250_console_setup(port, options, true);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __init univ8250_console_init(void)\r\n{\r\nif (nr_uarts == 0)\r\nreturn -ENODEV;\r\nserial8250_isa_init_ports();\r\nregister_console(&univ8250_console);\r\nreturn 0;\r\n}\r\nint __init early_serial_setup(struct uart_port *port)\r\n{\r\nstruct uart_port *p;\r\nif (port->line >= ARRAY_SIZE(serial8250_ports) || nr_uarts == 0)\r\nreturn -ENODEV;\r\nserial8250_isa_init_ports();\r\np = &serial8250_ports[port->line].port;\r\np->iobase = port->iobase;\r\np->membase = port->membase;\r\np->irq = port->irq;\r\np->irqflags = port->irqflags;\r\np->uartclk = port->uartclk;\r\np->fifosize = port->fifosize;\r\np->regshift = port->regshift;\r\np->iotype = port->iotype;\r\np->flags = port->flags;\r\np->mapbase = port->mapbase;\r\np->mapsize = port->mapsize;\r\np->private_data = port->private_data;\r\np->type = port->type;\r\np->line = port->line;\r\nserial8250_set_defaults(up_to_u8250p(p));\r\nif (port->serial_in)\r\np->serial_in = port->serial_in;\r\nif (port->serial_out)\r\np->serial_out = port->serial_out;\r\nif (port->handle_irq)\r\np->handle_irq = port->handle_irq;\r\nreturn 0;\r\n}\r\nvoid serial8250_suspend_port(int line)\r\n{\r\nstruct uart_8250_port *up = &serial8250_ports[line];\r\nstruct uart_port *port = &up->port;\r\nif (!console_suspend_enabled && uart_console(port) &&\r\nport->type != PORT_8250) {\r\nunsigned char canary = 0xa5;\r\nserial_out(up, UART_SCR, canary);\r\nif (serial_in(up, UART_SCR) == canary)\r\nup->canary = canary;\r\n}\r\nuart_suspend_port(&serial8250_reg, port);\r\n}\r\nvoid serial8250_resume_port(int line)\r\n{\r\nstruct uart_8250_port *up = &serial8250_ports[line];\r\nstruct uart_port *port = &up->port;\r\nup->canary = 0;\r\nif (up->capabilities & UART_NATSEMI) {\r\nserial_port_out(port, UART_LCR, 0xE0);\r\nns16550a_goto_highspeed(up);\r\nserial_port_out(port, UART_LCR, 0);\r\nport->uartclk = 921600*16;\r\n}\r\nuart_resume_port(&serial8250_reg, port);\r\n}\r\nstatic int serial8250_probe(struct platform_device *dev)\r\n{\r\nstruct plat_serial8250_port *p = dev_get_platdata(&dev->dev);\r\nstruct uart_8250_port uart;\r\nint ret, i, irqflag = 0;\r\nmemset(&uart, 0, sizeof(uart));\r\nif (share_irqs)\r\nirqflag = IRQF_SHARED;\r\nfor (i = 0; p && p->flags != 0; p++, i++) {\r\nuart.port.iobase = p->iobase;\r\nuart.port.membase = p->membase;\r\nuart.port.irq = p->irq;\r\nuart.port.irqflags = p->irqflags;\r\nuart.port.uartclk = p->uartclk;\r\nuart.port.regshift = p->regshift;\r\nuart.port.iotype = p->iotype;\r\nuart.port.flags = p->flags;\r\nuart.port.mapbase = p->mapbase;\r\nuart.port.hub6 = p->hub6;\r\nuart.port.private_data = p->private_data;\r\nuart.port.type = p->type;\r\nuart.port.serial_in = p->serial_in;\r\nuart.port.serial_out = p->serial_out;\r\nuart.port.handle_irq = p->handle_irq;\r\nuart.port.handle_break = p->handle_break;\r\nuart.port.set_termios = p->set_termios;\r\nuart.port.set_ldisc = p->set_ldisc;\r\nuart.port.get_mctrl = p->get_mctrl;\r\nuart.port.pm = p->pm;\r\nuart.port.dev = &dev->dev;\r\nuart.port.irqflags |= irqflag;\r\nret = serial8250_register_8250_port(&uart);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "unable to register port at index %d "\r\n"(IO%lx MEM%llx IRQ%d): %d\n", i,\r\np->iobase, (unsigned long long)p->mapbase,\r\np->irq, ret);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_remove(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.dev == &dev->dev)\r\nserial8250_unregister_port(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nuart_suspend_port(&serial8250_reg, &up->port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int serial8250_resume(struct platform_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct uart_8250_port *up = &serial8250_ports[i];\r\nif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\r\nserial8250_resume_port(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct uart_8250_port *serial8250_find_match_or_unused(struct uart_port *port)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (uart_match_port(&serial8250_ports[i].port, port))\r\nreturn &serial8250_ports[i];\r\ni = port->line;\r\nif (i < nr_uarts && serial8250_ports[i].port.type == PORT_UNKNOWN &&\r\nserial8250_ports[i].port.iobase == 0)\r\nreturn &serial8250_ports[i];\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (serial8250_ports[i].port.type == PORT_UNKNOWN &&\r\nserial8250_ports[i].port.iobase == 0)\r\nreturn &serial8250_ports[i];\r\nfor (i = 0; i < nr_uarts; i++)\r\nif (serial8250_ports[i].port.type == PORT_UNKNOWN)\r\nreturn &serial8250_ports[i];\r\nreturn NULL;\r\n}\r\nint serial8250_register_8250_port(struct uart_8250_port *up)\r\n{\r\nstruct uart_8250_port *uart;\r\nint ret = -ENOSPC;\r\nif (up->port.uartclk == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&serial_mutex);\r\nuart = serial8250_find_match_or_unused(&up->port);\r\nif (uart && uart->port.type != PORT_8250_CIR) {\r\nif (uart->port.dev)\r\nuart_remove_one_port(&serial8250_reg, &uart->port);\r\nuart->port.iobase = up->port.iobase;\r\nuart->port.membase = up->port.membase;\r\nuart->port.irq = up->port.irq;\r\nuart->port.irqflags = up->port.irqflags;\r\nuart->port.uartclk = up->port.uartclk;\r\nuart->port.fifosize = up->port.fifosize;\r\nuart->port.regshift = up->port.regshift;\r\nuart->port.iotype = up->port.iotype;\r\nuart->port.flags = up->port.flags | UPF_BOOT_AUTOCONF;\r\nuart->bugs = up->bugs;\r\nuart->port.mapbase = up->port.mapbase;\r\nuart->port.mapsize = up->port.mapsize;\r\nuart->port.private_data = up->port.private_data;\r\nuart->tx_loadsz = up->tx_loadsz;\r\nuart->capabilities = up->capabilities;\r\nuart->port.throttle = up->port.throttle;\r\nuart->port.unthrottle = up->port.unthrottle;\r\nuart->port.rs485_config = up->port.rs485_config;\r\nuart->port.rs485 = up->port.rs485;\r\nuart->dma = up->dma;\r\nif (uart->port.fifosize && !uart->tx_loadsz)\r\nuart->tx_loadsz = uart->port.fifosize;\r\nif (up->port.dev)\r\nuart->port.dev = up->port.dev;\r\nif (skip_txen_test)\r\nuart->port.flags |= UPF_NO_TXEN_TEST;\r\nif (up->port.flags & UPF_FIXED_TYPE)\r\nuart->port.type = up->port.type;\r\nserial8250_set_defaults(uart);\r\nif (up->port.serial_in)\r\nuart->port.serial_in = up->port.serial_in;\r\nif (up->port.serial_out)\r\nuart->port.serial_out = up->port.serial_out;\r\nif (up->port.handle_irq)\r\nuart->port.handle_irq = up->port.handle_irq;\r\nif (up->port.set_termios)\r\nuart->port.set_termios = up->port.set_termios;\r\nif (up->port.set_ldisc)\r\nuart->port.set_ldisc = up->port.set_ldisc;\r\nif (up->port.get_mctrl)\r\nuart->port.get_mctrl = up->port.get_mctrl;\r\nif (up->port.set_mctrl)\r\nuart->port.set_mctrl = up->port.set_mctrl;\r\nif (up->port.startup)\r\nuart->port.startup = up->port.startup;\r\nif (up->port.shutdown)\r\nuart->port.shutdown = up->port.shutdown;\r\nif (up->port.pm)\r\nuart->port.pm = up->port.pm;\r\nif (up->port.handle_break)\r\nuart->port.handle_break = up->port.handle_break;\r\nif (up->dl_read)\r\nuart->dl_read = up->dl_read;\r\nif (up->dl_write)\r\nuart->dl_write = up->dl_write;\r\nif (uart->port.type != PORT_8250_CIR) {\r\nif (serial8250_isa_config != NULL)\r\nserial8250_isa_config(0, &uart->port,\r\n&uart->capabilities);\r\nret = uart_add_one_port(&serial8250_reg,\r\n&uart->port);\r\nif (ret == 0)\r\nret = uart->port.line;\r\n} else {\r\ndev_info(uart->port.dev,\r\n"skipping CIR port at 0x%lx / 0x%llx, IRQ %d\n",\r\nuart->port.iobase,\r\n(unsigned long long)uart->port.mapbase,\r\nuart->port.irq);\r\nret = 0;\r\n}\r\n}\r\nmutex_unlock(&serial_mutex);\r\nreturn ret;\r\n}\r\nvoid serial8250_unregister_port(int line)\r\n{\r\nstruct uart_8250_port *uart = &serial8250_ports[line];\r\nmutex_lock(&serial_mutex);\r\nif (uart->em485) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&uart->port.lock, flags);\r\nserial8250_em485_destroy(uart);\r\nspin_unlock_irqrestore(&uart->port.lock, flags);\r\n}\r\nuart_remove_one_port(&serial8250_reg, &uart->port);\r\nif (serial8250_isa_devs) {\r\nuart->port.flags &= ~UPF_BOOT_AUTOCONF;\r\nif (skip_txen_test)\r\nuart->port.flags |= UPF_NO_TXEN_TEST;\r\nuart->port.type = PORT_UNKNOWN;\r\nuart->port.dev = &serial8250_isa_devs->dev;\r\nuart->capabilities = 0;\r\nuart_add_one_port(&serial8250_reg, &uart->port);\r\n} else {\r\nuart->port.dev = NULL;\r\n}\r\nmutex_unlock(&serial_mutex);\r\n}\r\nstatic int __init serial8250_init(void)\r\n{\r\nint ret;\r\nif (nr_uarts == 0)\r\nreturn -ENODEV;\r\nserial8250_isa_init_ports();\r\npr_info("Serial: 8250/16550 driver, %d ports, IRQ sharing %sabled\n",\r\nnr_uarts, share_irqs ? "en" : "dis");\r\n#ifdef CONFIG_SPARC\r\nret = sunserial_register_minors(&serial8250_reg, UART_NR);\r\n#else\r\nserial8250_reg.nr = UART_NR;\r\nret = uart_register_driver(&serial8250_reg);\r\n#endif\r\nif (ret)\r\ngoto out;\r\nret = serial8250_pnp_init();\r\nif (ret)\r\ngoto unreg_uart_drv;\r\nserial8250_isa_devs = platform_device_alloc("serial8250",\r\nPLAT8250_DEV_LEGACY);\r\nif (!serial8250_isa_devs) {\r\nret = -ENOMEM;\r\ngoto unreg_pnp;\r\n}\r\nret = platform_device_add(serial8250_isa_devs);\r\nif (ret)\r\ngoto put_dev;\r\nserial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);\r\nret = platform_driver_register(&serial8250_isa_driver);\r\nif (ret == 0)\r\ngoto out;\r\nplatform_device_del(serial8250_isa_devs);\r\nput_dev:\r\nplatform_device_put(serial8250_isa_devs);\r\nunreg_pnp:\r\nserial8250_pnp_exit();\r\nunreg_uart_drv:\r\n#ifdef CONFIG_SPARC\r\nsunserial_unregister_minors(&serial8250_reg, UART_NR);\r\n#else\r\nuart_unregister_driver(&serial8250_reg);\r\n#endif\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit serial8250_exit(void)\r\n{\r\nstruct platform_device *isa_dev = serial8250_isa_devs;\r\nserial8250_isa_devs = NULL;\r\nplatform_driver_unregister(&serial8250_isa_driver);\r\nplatform_device_unregister(isa_dev);\r\nserial8250_pnp_exit();\r\n#ifdef CONFIG_SPARC\r\nsunserial_unregister_minors(&serial8250_reg, UART_NR);\r\n#else\r\nuart_unregister_driver(&serial8250_reg);\r\n#endif\r\n}\r\nstatic void __used s8250_options(void)\r\n{\r\n#undef MODULE_PARAM_PREFIX\r\n#define MODULE_PARAM_PREFIX "8250_core."\r\nmodule_param_cb(share_irqs, &param_ops_uint, &share_irqs, 0644);\r\nmodule_param_cb(nr_uarts, &param_ops_uint, &nr_uarts, 0644);\r\nmodule_param_cb(skip_txen_test, &param_ops_uint, &skip_txen_test, 0644);\r\n#ifdef CONFIG_SERIAL_8250_RSA\r\n__module_param_call(MODULE_PARAM_PREFIX, probe_rsa,\r\n&param_array_ops, .arr = &__param_arr_probe_rsa,\r\n0444, -1, 0);\r\n#endif\r\n}
