static bool acpi_nondev_subnode_extract(const union acpi_object *desc,\r\nacpi_handle handle,\r\nconst union acpi_object *link,\r\nstruct list_head *list)\r\n{\r\nstruct acpi_data_node *dn;\r\nbool result;\r\ndn = kzalloc(sizeof(*dn), GFP_KERNEL);\r\nif (!dn)\r\nreturn false;\r\ndn->name = link->package.elements[0].string.pointer;\r\ndn->fwnode.type = FWNODE_ACPI_DATA;\r\nINIT_LIST_HEAD(&dn->data.subnodes);\r\nresult = acpi_extract_properties(desc, &dn->data);\r\nif (handle) {\r\nacpi_handle scope;\r\nacpi_status status;\r\nstatus = acpi_get_parent(handle, &scope);\r\nif (ACPI_SUCCESS(status)\r\n&& acpi_enumerate_nondev_subnodes(scope, desc, &dn->data))\r\nresult = true;\r\n} else if (acpi_enumerate_nondev_subnodes(NULL, desc, &dn->data)) {\r\nresult = true;\r\n}\r\nif (result) {\r\ndn->handle = handle;\r\ndn->data.pointer = desc;\r\nlist_add_tail(&dn->sibling, list);\r\nreturn true;\r\n}\r\nkfree(dn);\r\nacpi_handle_debug(handle, "Invalid properties/subnodes data, skipping\n");\r\nreturn false;\r\n}\r\nstatic bool acpi_nondev_subnode_data_ok(acpi_handle handle,\r\nconst union acpi_object *link,\r\nstruct list_head *list)\r\n{\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\r\nacpi_status status;\r\nstatus = acpi_evaluate_object_typed(handle, NULL, NULL, &buf,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nif (acpi_nondev_subnode_extract(buf.pointer, handle, link, list))\r\nreturn true;\r\nACPI_FREE(buf.pointer);\r\nreturn false;\r\n}\r\nstatic bool acpi_nondev_subnode_ok(acpi_handle scope,\r\nconst union acpi_object *link,\r\nstruct list_head *list)\r\n{\r\nacpi_handle handle;\r\nacpi_status status;\r\nif (!scope)\r\nreturn false;\r\nstatus = acpi_get_handle(scope, link->package.elements[1].string.pointer,\r\n&handle);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nreturn acpi_nondev_subnode_data_ok(handle, link, list);\r\n}\r\nstatic int acpi_add_nondev_subnodes(acpi_handle scope,\r\nconst union acpi_object *links,\r\nstruct list_head *list)\r\n{\r\nbool ret = false;\r\nint i;\r\nfor (i = 0; i < links->package.count; i++) {\r\nconst union acpi_object *link, *desc;\r\nacpi_handle handle;\r\nbool result;\r\nlink = &links->package.elements[i];\r\nif (link->package.count != 2)\r\ncontinue;\r\nif (link->package.elements[0].type != ACPI_TYPE_STRING)\r\ncontinue;\r\nswitch (link->package.elements[1].type) {\r\ncase ACPI_TYPE_STRING:\r\nresult = acpi_nondev_subnode_ok(scope, link, list);\r\nbreak;\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\nhandle = link->package.elements[1].reference.handle;\r\nresult = acpi_nondev_subnode_data_ok(handle, link, list);\r\nbreak;\r\ncase ACPI_TYPE_PACKAGE:\r\ndesc = &link->package.elements[1];\r\nresult = acpi_nondev_subnode_extract(desc, NULL, link, list);\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nret = ret || result;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool acpi_enumerate_nondev_subnodes(acpi_handle scope,\r\nconst union acpi_object *desc,\r\nstruct acpi_device_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < desc->package.count; i += 2) {\r\nconst union acpi_object *uuid, *links;\r\nuuid = &desc->package.elements[i];\r\nlinks = &desc->package.elements[i + 1];\r\nif (uuid->type != ACPI_TYPE_BUFFER || uuid->buffer.length != 16\r\n|| links->type != ACPI_TYPE_PACKAGE)\r\nbreak;\r\nif (memcmp(uuid->buffer.pointer, ads_uuid, sizeof(ads_uuid)))\r\ncontinue;\r\nreturn acpi_add_nondev_subnodes(scope, links, &data->subnodes);\r\n}\r\nreturn false;\r\n}\r\nstatic bool acpi_property_value_ok(const union acpi_object *value)\r\n{\r\nint j;\r\nswitch (value->type) {\r\ncase ACPI_TYPE_INTEGER:\r\ncase ACPI_TYPE_STRING:\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\nreturn true;\r\ncase ACPI_TYPE_PACKAGE:\r\nfor (j = 0; j < value->package.count; j++)\r\nswitch (value->package.elements[j].type) {\r\ncase ACPI_TYPE_INTEGER:\r\ncase ACPI_TYPE_STRING:\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\ncontinue;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool acpi_properties_format_valid(const union acpi_object *properties)\r\n{\r\nint i;\r\nfor (i = 0; i < properties->package.count; i++) {\r\nconst union acpi_object *property;\r\nproperty = &properties->package.elements[i];\r\nif (property->package.count != 2\r\n|| property->package.elements[0].type != ACPI_TYPE_STRING\r\n|| !acpi_property_value_ok(&property->package.elements[1]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void acpi_init_of_compatible(struct acpi_device *adev)\r\n{\r\nconst union acpi_object *of_compatible;\r\nint ret;\r\nret = acpi_data_get_property_array(&adev->data, "compatible",\r\nACPI_TYPE_STRING, &of_compatible);\r\nif (ret) {\r\nret = acpi_dev_get_property(adev, "compatible",\r\nACPI_TYPE_STRING, &of_compatible);\r\nif (ret) {\r\nif (adev->parent\r\n&& adev->parent->flags.of_compatible_ok)\r\ngoto out;\r\nreturn;\r\n}\r\n}\r\nadev->data.of_compatible = of_compatible;\r\nout:\r\nadev->flags.of_compatible_ok = 1;\r\n}\r\nstatic bool acpi_extract_properties(const union acpi_object *desc,\r\nstruct acpi_device_data *data)\r\n{\r\nint i;\r\nif (desc->package.count % 2)\r\nreturn false;\r\nfor (i = 0; i < desc->package.count; i += 2) {\r\nconst union acpi_object *uuid, *properties;\r\nuuid = &desc->package.elements[i];\r\nproperties = &desc->package.elements[i + 1];\r\nif (uuid->type != ACPI_TYPE_BUFFER || uuid->buffer.length != 16\r\n|| properties->type != ACPI_TYPE_PACKAGE)\r\nbreak;\r\nif (memcmp(uuid->buffer.pointer, prp_uuid, sizeof(prp_uuid)))\r\ncontinue;\r\nif (!acpi_properties_format_valid(properties))\r\nbreak;\r\ndata->properties = properties;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid acpi_init_properties(struct acpi_device *adev)\r\n{\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\r\nstruct acpi_hardware_id *hwid;\r\nacpi_status status;\r\nbool acpi_of = false;\r\nINIT_LIST_HEAD(&adev->data.subnodes);\r\nlist_for_each_entry(hwid, &adev->pnp.ids, list) {\r\nif (!strcmp(hwid->id, ACPI_DT_NAMESPACE_HID)) {\r\nacpi_of = true;\r\nbreak;\r\n}\r\n}\r\nstatus = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (acpi_extract_properties(buf.pointer, &adev->data)) {\r\nadev->data.pointer = buf.pointer;\r\nif (acpi_of)\r\nacpi_init_of_compatible(adev);\r\n}\r\nif (acpi_enumerate_nondev_subnodes(adev->handle, buf.pointer, &adev->data))\r\nadev->data.pointer = buf.pointer;\r\nif (!adev->data.pointer) {\r\nacpi_handle_debug(adev->handle, "Invalid _DSD data, skipping\n");\r\nACPI_FREE(buf.pointer);\r\n}\r\nout:\r\nif (acpi_of && !adev->flags.of_compatible_ok)\r\nacpi_handle_info(adev->handle,\r\nACPI_DT_NAMESPACE_HID " requires 'compatible' property\n");\r\n}\r\nstatic void acpi_destroy_nondev_subnodes(struct list_head *list)\r\n{\r\nstruct acpi_data_node *dn, *next;\r\nif (list_empty(list))\r\nreturn;\r\nlist_for_each_entry_safe_reverse(dn, next, list, sibling) {\r\nacpi_destroy_nondev_subnodes(&dn->data.subnodes);\r\nwait_for_completion(&dn->kobj_done);\r\nlist_del(&dn->sibling);\r\nACPI_FREE((void *)dn->data.pointer);\r\nkfree(dn);\r\n}\r\n}\r\nvoid acpi_free_properties(struct acpi_device *adev)\r\n{\r\nacpi_destroy_nondev_subnodes(&adev->data.subnodes);\r\nACPI_FREE((void *)adev->data.pointer);\r\nadev->data.of_compatible = NULL;\r\nadev->data.pointer = NULL;\r\nadev->data.properties = NULL;\r\n}\r\nstatic int acpi_data_get_property(struct acpi_device_data *data,\r\nconst char *name, acpi_object_type type,\r\nconst union acpi_object **obj)\r\n{\r\nconst union acpi_object *properties;\r\nint i;\r\nif (!data || !name)\r\nreturn -EINVAL;\r\nif (!data->pointer || !data->properties)\r\nreturn -EINVAL;\r\nproperties = data->properties;\r\nfor (i = 0; i < properties->package.count; i++) {\r\nconst union acpi_object *propname, *propvalue;\r\nconst union acpi_object *property;\r\nproperty = &properties->package.elements[i];\r\npropname = &property->package.elements[0];\r\npropvalue = &property->package.elements[1];\r\nif (!strcmp(name, propname->string.pointer)) {\r\nif (type != ACPI_TYPE_ANY && propvalue->type != type)\r\nreturn -EPROTO;\r\nif (obj)\r\n*obj = propvalue;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint acpi_dev_get_property(struct acpi_device *adev, const char *name,\r\nacpi_object_type type, const union acpi_object **obj)\r\n{\r\nreturn adev ? acpi_data_get_property(&adev->data, name, type, obj) : -EINVAL;\r\n}\r\nstatic struct acpi_device_data *acpi_device_data_of_node(struct fwnode_handle *fwnode)\r\n{\r\nif (fwnode->type == FWNODE_ACPI) {\r\nstruct acpi_device *adev = to_acpi_device_node(fwnode);\r\nreturn &adev->data;\r\n} else if (fwnode->type == FWNODE_ACPI_DATA) {\r\nstruct acpi_data_node *dn = to_acpi_data_node(fwnode);\r\nreturn &dn->data;\r\n}\r\nreturn NULL;\r\n}\r\nint acpi_node_prop_get(struct fwnode_handle *fwnode, const char *propname,\r\nvoid **valptr)\r\n{\r\nreturn acpi_data_get_property(acpi_device_data_of_node(fwnode),\r\npropname, ACPI_TYPE_ANY,\r\n(const union acpi_object **)valptr);\r\n}\r\nstatic int acpi_data_get_property_array(struct acpi_device_data *data,\r\nconst char *name,\r\nacpi_object_type type,\r\nconst union acpi_object **obj)\r\n{\r\nconst union acpi_object *prop;\r\nint ret, i;\r\nret = acpi_data_get_property(data, name, ACPI_TYPE_PACKAGE, &prop);\r\nif (ret)\r\nreturn ret;\r\nif (type != ACPI_TYPE_ANY) {\r\nfor (i = 0; i < prop->package.count; i++)\r\nif (prop->package.elements[i].type != type)\r\nreturn -EPROTO;\r\n}\r\nif (obj)\r\n*obj = prop;\r\nreturn 0;\r\n}\r\nint __acpi_node_get_property_reference(struct fwnode_handle *fwnode,\r\nconst char *propname, size_t index, size_t num_args,\r\nstruct acpi_reference_args *args)\r\n{\r\nconst union acpi_object *element, *end;\r\nconst union acpi_object *obj;\r\nstruct acpi_device_data *data;\r\nstruct acpi_device *device;\r\nint ret, idx = 0;\r\ndata = acpi_device_data_of_node(fwnode);\r\nif (!data)\r\nreturn -EINVAL;\r\nret = acpi_data_get_property(data, propname, ACPI_TYPE_ANY, &obj);\r\nif (ret)\r\nreturn ret;\r\nif (obj->type == ACPI_TYPE_LOCAL_REFERENCE) {\r\nif (index)\r\nreturn -EINVAL;\r\nret = acpi_bus_get_device(obj->reference.handle, &device);\r\nif (ret)\r\nreturn ret;\r\nargs->adev = device;\r\nargs->nargs = 0;\r\nreturn 0;\r\n}\r\nif (obj->type != ACPI_TYPE_PACKAGE || index >= obj->package.count)\r\nreturn -EPROTO;\r\nelement = obj->package.elements;\r\nend = element + obj->package.count;\r\nwhile (element < end) {\r\nu32 nargs, i;\r\nif (element->type == ACPI_TYPE_LOCAL_REFERENCE) {\r\nret = acpi_bus_get_device(element->reference.handle,\r\n&device);\r\nif (ret)\r\nreturn -ENODEV;\r\nnargs = 0;\r\nelement++;\r\nfor (i = 0; element + i < end && i < num_args; i++) {\r\nint type = element[i].type;\r\nif (type == ACPI_TYPE_INTEGER)\r\nnargs++;\r\nelse if (type == ACPI_TYPE_LOCAL_REFERENCE)\r\nbreak;\r\nelse\r\nreturn -EPROTO;\r\n}\r\nif (nargs > MAX_ACPI_REFERENCE_ARGS)\r\nreturn -EPROTO;\r\nif (idx == index) {\r\nargs->adev = device;\r\nargs->nargs = nargs;\r\nfor (i = 0; i < nargs; i++)\r\nargs->args[i] = element[i].integer.value;\r\nreturn 0;\r\n}\r\nelement += nargs;\r\n} else if (element->type == ACPI_TYPE_INTEGER) {\r\nif (idx == index)\r\nreturn -ENOENT;\r\nelement++;\r\n} else {\r\nreturn -EPROTO;\r\n}\r\nidx++;\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic int acpi_data_prop_read_single(struct acpi_device_data *data,\r\nconst char *propname,\r\nenum dev_prop_type proptype, void *val)\r\n{\r\nconst union acpi_object *obj;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nif (proptype >= DEV_PROP_U8 && proptype <= DEV_PROP_U64) {\r\nret = acpi_data_get_property(data, propname, ACPI_TYPE_INTEGER, &obj);\r\nif (ret)\r\nreturn ret;\r\nswitch (proptype) {\r\ncase DEV_PROP_U8:\r\nif (obj->integer.value > U8_MAX)\r\nreturn -EOVERFLOW;\r\n*(u8 *)val = obj->integer.value;\r\nbreak;\r\ncase DEV_PROP_U16:\r\nif (obj->integer.value > U16_MAX)\r\nreturn -EOVERFLOW;\r\n*(u16 *)val = obj->integer.value;\r\nbreak;\r\ncase DEV_PROP_U32:\r\nif (obj->integer.value > U32_MAX)\r\nreturn -EOVERFLOW;\r\n*(u32 *)val = obj->integer.value;\r\nbreak;\r\ndefault:\r\n*(u64 *)val = obj->integer.value;\r\nbreak;\r\n}\r\n} else if (proptype == DEV_PROP_STRING) {\r\nret = acpi_data_get_property(data, propname, ACPI_TYPE_STRING, &obj);\r\nif (ret)\r\nreturn ret;\r\n*(char **)val = obj->string.pointer;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint acpi_dev_prop_read_single(struct acpi_device *adev, const char *propname,\r\nenum dev_prop_type proptype, void *val)\r\n{\r\nreturn adev ? acpi_data_prop_read_single(&adev->data, propname, proptype, val) : -EINVAL;\r\n}\r\nstatic int acpi_copy_property_array_u8(const union acpi_object *items, u8 *val,\r\nsize_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U8_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u16(const union acpi_object *items,\r\nu16 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U16_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u32(const union acpi_object *items,\r\nu32 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U32_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u64(const union acpi_object *items,\r\nu64 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_string(const union acpi_object *items,\r\nchar **val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_STRING)\r\nreturn -EPROTO;\r\nval[i] = items[i].string.pointer;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_data_prop_read(struct acpi_device_data *data,\r\nconst char *propname,\r\nenum dev_prop_type proptype,\r\nvoid *val, size_t nval)\r\n{\r\nconst union acpi_object *obj;\r\nconst union acpi_object *items;\r\nint ret;\r\nif (val && nval == 1) {\r\nret = acpi_data_prop_read_single(data, propname, proptype, val);\r\nif (!ret)\r\nreturn ret;\r\n}\r\nret = acpi_data_get_property_array(data, propname, ACPI_TYPE_ANY, &obj);\r\nif (ret)\r\nreturn ret;\r\nif (!val)\r\nreturn obj->package.count;\r\nif (nval > obj->package.count)\r\nreturn -EOVERFLOW;\r\nelse if (nval <= 0)\r\nreturn -EINVAL;\r\nitems = obj->package.elements;\r\nswitch (proptype) {\r\ncase DEV_PROP_U8:\r\nret = acpi_copy_property_array_u8(items, (u8 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U16:\r\nret = acpi_copy_property_array_u16(items, (u16 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U32:\r\nret = acpi_copy_property_array_u32(items, (u32 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U64:\r\nret = acpi_copy_property_array_u64(items, (u64 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_STRING:\r\nret = acpi_copy_property_array_string(items, (char **)val, nval);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint acpi_dev_prop_read(struct acpi_device *adev, const char *propname,\r\nenum dev_prop_type proptype, void *val, size_t nval)\r\n{\r\nreturn adev ? acpi_data_prop_read(&adev->data, propname, proptype, val, nval) : -EINVAL;\r\n}\r\nint acpi_node_prop_read(struct fwnode_handle *fwnode, const char *propname,\r\nenum dev_prop_type proptype, void *val, size_t nval)\r\n{\r\nreturn acpi_data_prop_read(acpi_device_data_of_node(fwnode),\r\npropname, proptype, val, nval);\r\n}\r\nstruct fwnode_handle *acpi_get_next_subnode(struct device *dev,\r\nstruct fwnode_handle *child)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nstruct list_head *head, *next;\r\nif (!adev)\r\nreturn NULL;\r\nif (!child || child->type == FWNODE_ACPI) {\r\nhead = &adev->children;\r\nif (list_empty(head))\r\ngoto nondev;\r\nif (child) {\r\nadev = to_acpi_device_node(child);\r\nnext = adev->node.next;\r\nif (next == head) {\r\nchild = NULL;\r\nadev = ACPI_COMPANION(dev);\r\ngoto nondev;\r\n}\r\nadev = list_entry(next, struct acpi_device, node);\r\n} else {\r\nadev = list_first_entry(head, struct acpi_device, node);\r\n}\r\nreturn acpi_fwnode_handle(adev);\r\n}\r\nnondev:\r\nif (!child || child->type == FWNODE_ACPI_DATA) {\r\nstruct acpi_data_node *dn;\r\nhead = &adev->data.subnodes;\r\nif (list_empty(head))\r\nreturn NULL;\r\nif (child) {\r\ndn = to_acpi_data_node(child);\r\nnext = dn->sibling.next;\r\nif (next == head)\r\nreturn NULL;\r\ndn = list_entry(next, struct acpi_data_node, sibling);\r\n} else {\r\ndn = list_first_entry(head, struct acpi_data_node, sibling);\r\n}\r\nreturn &dn->fwnode;\r\n}\r\nreturn NULL;\r\n}
