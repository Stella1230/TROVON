static void\r\nhwsq_cmd(struct nvkm_hwsq *hwsq, int size, u8 data[])\r\n{\r\nmemcpy(&hwsq->c.data[hwsq->c.size], data, size * sizeof(data[0]));\r\nhwsq->c.size += size;\r\n}\r\nint\r\nnvkm_hwsq_init(struct nvkm_subdev *subdev, struct nvkm_hwsq **phwsq)\r\n{\r\nstruct nvkm_hwsq *hwsq;\r\nhwsq = *phwsq = kmalloc(sizeof(*hwsq), GFP_KERNEL);\r\nif (hwsq) {\r\nhwsq->subdev = subdev;\r\nhwsq->addr = ~0;\r\nhwsq->data = ~0;\r\nmemset(hwsq->c.data, 0x7f, sizeof(hwsq->c.data));\r\nhwsq->c.size = 0;\r\n}\r\nreturn hwsq ? 0 : -ENOMEM;\r\n}\r\nint\r\nnvkm_hwsq_fini(struct nvkm_hwsq **phwsq, bool exec)\r\n{\r\nstruct nvkm_hwsq *hwsq = *phwsq;\r\nint ret = 0, i;\r\nif (hwsq) {\r\nstruct nvkm_subdev *subdev = hwsq->subdev;\r\nstruct nvkm_bus *bus = subdev->device->bus;\r\nhwsq->c.size = (hwsq->c.size + 4) / 4;\r\nif (hwsq->c.size <= bus->func->hwsq_size) {\r\nif (exec)\r\nret = bus->func->hwsq_exec(bus,\r\n(u32 *)hwsq->c.data,\r\nhwsq->c.size);\r\nif (ret)\r\nnvkm_error(subdev, "hwsq exec failed: %d\n", ret);\r\n} else {\r\nnvkm_error(subdev, "hwsq ucode too large\n");\r\nret = -ENOSPC;\r\n}\r\nfor (i = 0; ret && i < hwsq->c.size; i++)\r\nnvkm_error(subdev, "\t%08x\n", ((u32 *)hwsq->c.data)[i]);\r\n*phwsq = NULL;\r\nkfree(hwsq);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nnvkm_hwsq_wr32(struct nvkm_hwsq *hwsq, u32 addr, u32 data)\r\n{\r\nnvkm_debug(hwsq->subdev, "R[%06x] = %08x\n", addr, data);\r\nif (hwsq->data != data) {\r\nif ((data & 0xffff0000) != (hwsq->data & 0xffff0000)) {\r\nhwsq_cmd(hwsq, 5, (u8[]){ 0xe2, data, data >> 8,\r\ndata >> 16, data >> 24 });\r\n} else {\r\nhwsq_cmd(hwsq, 3, (u8[]){ 0x42, data, data >> 8 });\r\n}\r\n}\r\nif ((addr & 0xffff0000) != (hwsq->addr & 0xffff0000)) {\r\nhwsq_cmd(hwsq, 5, (u8[]){ 0xe0, addr, addr >> 8,\r\naddr >> 16, addr >> 24 });\r\n} else {\r\nhwsq_cmd(hwsq, 3, (u8[]){ 0x40, addr, addr >> 8 });\r\n}\r\nhwsq->addr = addr;\r\nhwsq->data = data;\r\n}\r\nvoid\r\nnvkm_hwsq_setf(struct nvkm_hwsq *hwsq, u8 flag, int data)\r\n{\r\nnvkm_debug(hwsq->subdev, " FLAG[%02x] = %d\n", flag, data);\r\nflag += 0x80;\r\nif (data >= 0)\r\nflag += 0x20;\r\nif (data >= 1)\r\nflag += 0x20;\r\nhwsq_cmd(hwsq, 1, (u8[]){ flag });\r\n}\r\nvoid\r\nnvkm_hwsq_wait(struct nvkm_hwsq *hwsq, u8 flag, u8 data)\r\n{\r\nnvkm_debug(hwsq->subdev, " WAIT[%02x] = %d\n", flag, data);\r\nhwsq_cmd(hwsq, 3, (u8[]){ 0x5f, flag, data });\r\n}\r\nvoid\r\nnvkm_hwsq_wait_vblank(struct nvkm_hwsq *hwsq)\r\n{\r\nstruct nvkm_subdev *subdev = hwsq->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nu32 heads, x, y, px = 0;\r\nint i, head_sync;\r\nheads = nvkm_rd32(device, 0x610050);\r\nfor (i = 0; i < 2; i++) {\r\nif (heads & (2 << (i << 3))) {\r\nx = nvkm_rd32(device, 0x610b40 + (0x540 * i));\r\ny = (x & 0xffff0000) >> 16;\r\nx &= 0x0000ffff;\r\nif ((x * y) > px) {\r\npx = (x * y);\r\nhead_sync = i;\r\n}\r\n}\r\n}\r\nif (px == 0) {\r\nnvkm_debug(subdev, "WAIT VBLANK !NO ACTIVE HEAD\n");\r\nreturn;\r\n}\r\nnvkm_debug(subdev, "WAIT VBLANK HEAD%d\n", head_sync);\r\nnvkm_hwsq_wait(hwsq, head_sync ? 0x3 : 0x1, 0x0);\r\nnvkm_hwsq_wait(hwsq, head_sync ? 0x3 : 0x1, 0x1);\r\n}\r\nvoid\r\nnvkm_hwsq_nsec(struct nvkm_hwsq *hwsq, u32 nsec)\r\n{\r\nu8 shift = 0, usec = nsec / 1000;\r\nwhile (usec & ~3) {\r\nusec >>= 2;\r\nshift++;\r\n}\r\nnvkm_debug(hwsq->subdev, " DELAY = %d ns\n", nsec);\r\nhwsq_cmd(hwsq, 1, (u8[]){ 0x00 | (shift << 2) | usec });\r\n}
