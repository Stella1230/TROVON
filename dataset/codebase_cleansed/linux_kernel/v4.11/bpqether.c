static void bpq_set_lockdep_class_one(struct net_device *dev,\r\nstruct netdev_queue *txq,\r\nvoid *_unused)\r\n{\r\nlockdep_set_class(&txq->_xmit_lock, &bpq_netdev_xmit_lock_key);\r\n}\r\nstatic void bpq_set_lockdep_class(struct net_device *dev)\r\n{\r\nlockdep_set_class(&dev->addr_list_lock, &bpq_netdev_addr_lock_key);\r\nnetdev_for_each_tx_queue(dev, bpq_set_lockdep_class_one, NULL);\r\n}\r\nstatic inline struct net_device *bpq_get_ether_dev(struct net_device *dev)\r\n{\r\nstruct bpqdev *bpq = netdev_priv(dev);\r\nreturn bpq ? bpq->ethdev : NULL;\r\n}\r\nstatic inline struct net_device *bpq_get_ax25_dev(struct net_device *dev)\r\n{\r\nstruct bpqdev *bpq;\r\nlist_for_each_entry_rcu(bpq, &bpq_devices, bpq_list) {\r\nif (bpq->ethdev == dev)\r\nreturn bpq->axdev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int dev_is_ethdev(struct net_device *dev)\r\n{\r\nreturn dev->type == ARPHRD_ETHER && strncmp(dev->name, "dummy", 5);\r\n}\r\nstatic int bpq_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *ptype, struct net_device *orig_dev)\r\n{\r\nint len;\r\nchar * ptr;\r\nstruct ethhdr *eth;\r\nstruct bpqdev *bpq;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\r\nreturn NET_RX_DROP;\r\nif (!pskb_may_pull(skb, sizeof(struct ethhdr)))\r\ngoto drop;\r\nrcu_read_lock();\r\ndev = bpq_get_ax25_dev(dev);\r\nif (dev == NULL || !netif_running(dev))\r\ngoto drop_unlock;\r\nbpq = netdev_priv(dev);\r\neth = eth_hdr(skb);\r\nif (!(bpq->acpt_addr[0] & 0x01) &&\r\n!ether_addr_equal(eth->h_source, bpq->acpt_addr))\r\ngoto drop_unlock;\r\nif (skb_cow(skb, sizeof(struct ethhdr)))\r\ngoto drop_unlock;\r\nlen = skb->data[0] + skb->data[1] * 256 - 5;\r\nskb_pull(skb, 2);\r\nskb_trim(skb, len);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nptr = skb_push(skb, 1);\r\n*ptr = 0;\r\nskb->protocol = ax25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nunlock:\r\nrcu_read_unlock();\r\nreturn 0;\r\ndrop_unlock:\r\nkfree_skb(skb);\r\ngoto unlock;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t bpq_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned char *ptr;\r\nstruct bpqdev *bpq;\r\nstruct net_device *orig_dev;\r\nint size;\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn ax25_ip_xmit(skb);\r\nif (!netif_running(dev)) {\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_pull(skb, 1);\r\nsize = skb->len;\r\nif (skb_cow(skb, AX25_BPQ_HEADER_LEN)) {\r\nif (net_ratelimit())\r\npr_err("bpqether: out of memory\n");\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nptr = skb_push(skb, 2);\r\n*ptr++ = (size + 5) % 256;\r\n*ptr++ = (size + 5) / 256;\r\nbpq = netdev_priv(dev);\r\norig_dev = dev;\r\nif ((dev = bpq_get_ether_dev(dev)) == NULL) {\r\norig_dev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb->protocol = ax25_type_trans(skb, dev);\r\nskb_reset_network_header(skb);\r\ndev_hard_header(skb, dev, ETH_P_BPQ, bpq->dest_addr, NULL, 0);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes+=skb->len;\r\ndev_queue_xmit(skb);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int bpq_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = (struct sockaddr *)addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int bpq_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct bpq_ethaddr __user *ethaddr = ifr->ifr_data;\r\nstruct bpqdev *bpq = netdev_priv(dev);\r\nstruct bpq_req req;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase SIOCSBPQETHOPT:\r\nif (copy_from_user(&req, ifr->ifr_data, sizeof(struct bpq_req)))\r\nreturn -EFAULT;\r\nswitch (req.cmd) {\r\ncase SIOCGBPQETHPARAM:\r\ncase SIOCSBPQETHPARAM:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SIOCSBPQETHADDR:\r\nif (copy_from_user(bpq->dest_addr, ethaddr->destination, ETH_ALEN))\r\nreturn -EFAULT;\r\nif (copy_from_user(bpq->acpt_addr, ethaddr->accept, ETH_ALEN))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bpq_open(struct net_device *dev)\r\n{\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int bpq_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void *bpq_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nint i = 1;\r\nstruct bpqdev *bpqdev;\r\nrcu_read_lock();\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nlist_for_each_entry_rcu(bpqdev, &bpq_devices, bpq_list) {\r\nif (i == *pos)\r\nreturn bpqdev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *bpq_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct list_head *p;\r\nstruct bpqdev *bpqdev = v;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\np = rcu_dereference(list_next_rcu(&bpq_devices));\r\nelse\r\np = rcu_dereference(list_next_rcu(&bpqdev->bpq_list));\r\nreturn (p == &bpq_devices) ? NULL\r\n: list_entry(p, struct bpqdev, bpq_list);\r\n}\r\nstatic void bpq_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int bpq_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"dev ether destination accept from\n");\r\nelse {\r\nconst struct bpqdev *bpqdev = v;\r\nseq_printf(seq, "%-5s %-10s %pM ",\r\nbpqdev->axdev->name, bpqdev->ethdev->name,\r\nbpqdev->dest_addr);\r\nif (is_multicast_ether_addr(bpqdev->acpt_addr))\r\nseq_printf(seq, "*\n");\r\nelse\r\nseq_printf(seq, "%pM\n", bpqdev->acpt_addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bpq_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &bpq_seqops);\r\n}\r\nstatic void bpq_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &bpq_netdev_ops;\r\ndev->destructor = free_netdev;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\ndev->flags = 0;\r\ndev->features = NETIF_F_LLTX;\r\n#if IS_ENABLED(CONFIG_AX25)\r\ndev->header_ops = &ax25_header_ops;\r\n#endif\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\r\ndev->mtu = AX25_DEF_PACLEN;\r\ndev->addr_len = AX25_ADDR_LEN;\r\n}\r\nstatic int bpq_new_device(struct net_device *edev)\r\n{\r\nint err;\r\nstruct net_device *ndev;\r\nstruct bpqdev *bpq;\r\nndev = alloc_netdev(sizeof(struct bpqdev), "bpq%d", NET_NAME_UNKNOWN,\r\nbpq_setup);\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nbpq = netdev_priv(ndev);\r\ndev_hold(edev);\r\nbpq->ethdev = edev;\r\nbpq->axdev = ndev;\r\nmemcpy(bpq->dest_addr, bcast_addr, sizeof(bpq_eth_addr));\r\nmemcpy(bpq->acpt_addr, bcast_addr, sizeof(bpq_eth_addr));\r\nerr = register_netdevice(ndev);\r\nif (err)\r\ngoto error;\r\nbpq_set_lockdep_class(ndev);\r\nlist_add_rcu(&bpq->bpq_list, &bpq_devices);\r\nreturn 0;\r\nerror:\r\ndev_put(edev);\r\nfree_netdev(ndev);\r\nreturn err;\r\n}\r\nstatic void bpq_free_device(struct net_device *ndev)\r\n{\r\nstruct bpqdev *bpq = netdev_priv(ndev);\r\ndev_put(bpq->ethdev);\r\nlist_del_rcu(&bpq->bpq_list);\r\nunregister_netdevice(ndev);\r\n}\r\nstatic int bpq_device_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (!dev_is_ethdev(dev))\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nif (bpq_get_ax25_dev(dev) == NULL)\r\nbpq_new_device(dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nif ((dev = bpq_get_ax25_dev(dev)) != NULL)\r\ndev_close(dev);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif ((dev = bpq_get_ax25_dev(dev)) != NULL)\r\nbpq_free_device(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init bpq_init_driver(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("bpqether", S_IRUGO, init_net.proc_net,\r\n&bpq_info_fops)) {\r\nprintk(KERN_ERR\r\n"bpq: cannot create /proc/net/bpqether entry.\n");\r\nreturn -ENOENT;\r\n}\r\n#endif\r\ndev_add_pack(&bpq_packet_type);\r\nregister_netdevice_notifier(&bpq_dev_notifier);\r\nprintk(banner);\r\nreturn 0;\r\n}\r\nstatic void __exit bpq_cleanup_driver(void)\r\n{\r\nstruct bpqdev *bpq;\r\ndev_remove_pack(&bpq_packet_type);\r\nunregister_netdevice_notifier(&bpq_dev_notifier);\r\nremove_proc_entry("bpqether", init_net.proc_net);\r\nrtnl_lock();\r\nwhile (!list_empty(&bpq_devices)) {\r\nbpq = list_entry(bpq_devices.next, struct bpqdev, bpq_list);\r\nbpq_free_device(bpq->axdev);\r\n}\r\nrtnl_unlock();\r\n}
