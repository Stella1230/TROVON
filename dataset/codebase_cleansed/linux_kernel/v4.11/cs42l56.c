static bool cs42l56_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L56_CHIP_ID_1 ... CS42L56_LIM_ATTACK_RATE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs42l56_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L56_INT_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs42l56_get_mclk_ratio(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clk_ratio_table); i++) {\r\nif (clk_ratio_table[i].mclk == mclk &&\r\nclk_ratio_table[i].srate == rate)\r\nreturn clk_ratio_table[i].ratio;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase CS42L56_MCLK_5P6448MHZ:\r\ncase CS42L56_MCLK_6MHZ:\r\ncase CS42L56_MCLK_6P144MHZ:\r\ncs42l56->mclk_div2 = 0;\r\ncs42l56->mclk_prediv = 0;\r\nbreak;\r\ncase CS42L56_MCLK_11P2896MHZ:\r\ncase CS42L56_MCLK_12MHZ:\r\ncase CS42L56_MCLK_12P288MHZ:\r\ncs42l56->mclk_div2 = CS42L56_MCLK_DIV2;\r\ncs42l56->mclk_prediv = 0;\r\nbreak;\r\ncase CS42L56_MCLK_22P5792MHZ:\r\ncase CS42L56_MCLK_24MHZ:\r\ncase CS42L56_MCLK_24P576MHZ:\r\ncs42l56->mclk_div2 = CS42L56_MCLK_DIV2;\r\ncs42l56->mclk_prediv = CS42L56_MCLK_PREDIV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncs42l56->mclk = freq;\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_MCLK_PREDIV_MASK,\r\ncs42l56->mclk_prediv);\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_MCLK_DIV2_MASK,\r\ncs42l56->mclk_div2);\r\nreturn 0;\r\n}\r\nstatic int cs42l56_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncs42l56->iface = CS42L56_MASTER_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ncs42l56->iface = CS42L56_SLAVE_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncs42l56->iface_fmt = CS42L56_DIG_FMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncs42l56->iface_fmt = CS42L56_DIG_FMT_LEFT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ncs42l56->iface_inv = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ncs42l56->iface_inv = CS42L56_SCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_MS_MODE_MASK, cs42l56->iface);\r\nsnd_soc_update_bits(codec, CS42L56_SERIAL_FMT,\r\nCS42L56_DIG_FMT_MASK, cs42l56->iface_fmt);\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_SCLK_INV_MASK, cs42l56->iface_inv);\r\nreturn 0;\r\n}\r\nstatic int cs42l56_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,\r\nCS42L56_ADCAMIX_MUTE_MASK |\r\nCS42L56_ADCBMIX_MUTE_MASK |\r\nCS42L56_PCMAMIX_MUTE_MASK |\r\nCS42L56_PCMBMIX_MUTE_MASK |\r\nCS42L56_MSTB_MUTE_MASK |\r\nCS42L56_MSTA_MUTE_MASK,\r\nCS42L56_MUTE_ALL);\r\nsnd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,\r\nCS42L56_ADCA_MUTE_MASK |\r\nCS42L56_ADCB_MUTE_MASK,\r\nCS42L56_MUTE_ALL);\r\nsnd_soc_update_bits(codec, CS42L56_HPA_VOLUME,\r\nCS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);\r\nsnd_soc_update_bits(codec, CS42L56_HPB_VOLUME,\r\nCS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);\r\nsnd_soc_update_bits(codec, CS42L56_LOA_VOLUME,\r\nCS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);\r\nsnd_soc_update_bits(codec, CS42L56_LOB_VOLUME,\r\nCS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);\r\n} else {\r\nsnd_soc_update_bits(codec, CS42L56_DSP_MUTE_CTL,\r\nCS42L56_ADCAMIX_MUTE_MASK |\r\nCS42L56_ADCBMIX_MUTE_MASK |\r\nCS42L56_PCMAMIX_MUTE_MASK |\r\nCS42L56_PCMBMIX_MUTE_MASK |\r\nCS42L56_MSTB_MUTE_MASK |\r\nCS42L56_MSTA_MUTE_MASK,\r\nCS42L56_UNMUTE);\r\nsnd_soc_update_bits(codec, CS42L56_MISC_ADC_CTL,\r\nCS42L56_ADCA_MUTE_MASK |\r\nCS42L56_ADCB_MUTE_MASK,\r\nCS42L56_UNMUTE);\r\nsnd_soc_update_bits(codec, CS42L56_HPA_VOLUME,\r\nCS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);\r\nsnd_soc_update_bits(codec, CS42L56_HPB_VOLUME,\r\nCS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);\r\nsnd_soc_update_bits(codec, CS42L56_LOA_VOLUME,\r\nCS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);\r\nsnd_soc_update_bits(codec, CS42L56_LOB_VOLUME,\r\nCS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l56_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\nint ratio;\r\nratio = cs42l56_get_mclk_ratio(cs42l56->mclk, params_rate(params));\r\nif (ratio >= 0) {\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_2,\r\nCS42L56_CLK_RATIO_MASK, ratio);\r\n} else {\r\ndev_err(codec->dev, "unsupported mclk/sclk/lrclk ratio\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l56_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_MCLK_DIS_MASK, 0);\r\nsnd_soc_update_bits(codec, CS42L56_PWRCTL_1,\r\nCS42L56_PDN_ALL_MASK, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nregcache_cache_only(cs42l56->regmap, false);\r\nregcache_sync(cs42l56->regmap);\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nif (ret != 0) {\r\ndev_err(cs42l56->dev,\r\n"Failed to enable regulators: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, CS42L56_PWRCTL_1,\r\nCS42L56_PDN_ALL_MASK, 1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, CS42L56_PWRCTL_1,\r\nCS42L56_PDN_ALL_MASK, 1);\r\nsnd_soc_update_bits(codec, CS42L56_CLKCTL_1,\r\nCS42L56_MCLK_DIS_MASK, 1);\r\nregcache_cache_only(cs42l56->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs42l56_beep_work(struct work_struct *work)\r\n{\r\nstruct cs42l56_private *cs42l56 =\r\ncontainer_of(work, struct cs42l56_private, beep_work);\r\nstruct snd_soc_codec *codec = cs42l56->codec;\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nint i;\r\nint val = 0;\r\nint best = 0;\r\nif (cs42l56->beep_rate) {\r\nfor (i = 0; i < ARRAY_SIZE(beep_freq); i++) {\r\nif (abs(cs42l56->beep_rate - beep_freq[i]) <\r\nabs(cs42l56->beep_rate - beep_freq[best]))\r\nbest = i;\r\n}\r\ndev_dbg(codec->dev, "Set beep rate %dHz for requested %dHz\n",\r\nbeep_freq[best], cs42l56->beep_rate);\r\nval = (best << CS42L56_BEEP_RATE_SHIFT);\r\nsnd_soc_dapm_enable_pin(dapm, "Beep");\r\n} else {\r\ndev_dbg(codec->dev, "Disabling beep\n");\r\nsnd_soc_dapm_disable_pin(dapm, "Beep");\r\n}\r\nsnd_soc_update_bits(codec, CS42L56_BEEP_FREQ_ONTIME,\r\nCS42L56_BEEP_FREQ_MASK, val);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nstatic int cs42l56_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct snd_soc_codec *codec = input_get_drvdata(dev);\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "Beep event %x %x\n", code, hz);\r\nswitch (code) {\r\ncase SND_BELL:\r\nif (hz)\r\nhz = 261;\r\ncase SND_TONE:\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\ncs42l56->beep_rate = hz;\r\nschedule_work(&cs42l56->beep_work);\r\nreturn 0;\r\n}\r\nstatic ssize_t cs42l56_beep_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cs42l56_private *cs42l56 = dev_get_drvdata(dev);\r\nlong int time;\r\nint ret;\r\nret = kstrtol(buf, 10, &time);\r\nif (ret != 0)\r\nreturn ret;\r\ninput_event(cs42l56->beep, EV_SND, SND_TONE, time);\r\nreturn count;\r\n}\r\nstatic void cs42l56_init_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncs42l56->beep = devm_input_allocate_device(codec->dev);\r\nif (!cs42l56->beep) {\r\ndev_err(codec->dev, "Failed to allocate beep device\n");\r\nreturn;\r\n}\r\nINIT_WORK(&cs42l56->beep_work, cs42l56_beep_work);\r\ncs42l56->beep_rate = 0;\r\ncs42l56->beep->name = "CS42L56 Beep Generator";\r\ncs42l56->beep->phys = dev_name(codec->dev);\r\ncs42l56->beep->id.bustype = BUS_I2C;\r\ncs42l56->beep->evbit[0] = BIT_MASK(EV_SND);\r\ncs42l56->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ncs42l56->beep->event = cs42l56_beep_event;\r\ncs42l56->beep->dev.parent = codec->dev;\r\ninput_set_drvdata(cs42l56->beep, codec);\r\nret = input_register_device(cs42l56->beep);\r\nif (ret != 0) {\r\ncs42l56->beep = NULL;\r\ndev_err(codec->dev, "Failed to register beep device\n");\r\n}\r\nret = device_create_file(codec->dev, &dev_attr_beep);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to create keyclick file: %d\n",\r\nret);\r\n}\r\n}\r\nstatic void cs42l56_free_beep(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l56_private *cs42l56 = snd_soc_codec_get_drvdata(codec);\r\ndevice_remove_file(codec->dev, &dev_attr_beep);\r\ncancel_work_sync(&cs42l56->beep_work);\r\ncs42l56->beep = NULL;\r\nsnd_soc_update_bits(codec, CS42L56_BEEP_TONE_CFG,\r\nCS42L56_BEEP_EN_MASK, 0);\r\n}\r\nstatic int cs42l56_probe(struct snd_soc_codec *codec)\r\n{\r\ncs42l56_init_beep(codec);\r\nreturn 0;\r\n}\r\nstatic int cs42l56_remove(struct snd_soc_codec *codec)\r\n{\r\ncs42l56_free_beep(codec);\r\nreturn 0;\r\n}\r\nstatic int cs42l56_handle_of_data(struct i2c_client *i2c_client,\r\nstruct cs42l56_platform_data *pdata)\r\n{\r\nstruct device_node *np = i2c_client->dev.of_node;\r\nu32 val32;\r\nif (of_property_read_bool(np, "cirrus,ain1a-reference-cfg"))\r\npdata->ain1a_ref_cfg = true;\r\nif (of_property_read_bool(np, "cirrus,ain2a-reference-cfg"))\r\npdata->ain2a_ref_cfg = true;\r\nif (of_property_read_bool(np, "cirrus,ain1b-reference-cfg"))\r\npdata->ain1b_ref_cfg = true;\r\nif (of_property_read_bool(np, "cirrus,ain2b-reference-cfg"))\r\npdata->ain2b_ref_cfg = true;\r\nif (of_property_read_u32(np, "cirrus,micbias-lvl", &val32) >= 0)\r\npdata->micbias_lvl = val32;\r\nif (of_property_read_u32(np, "cirrus,chgfreq-divisor", &val32) >= 0)\r\npdata->chgfreq = val32;\r\nif (of_property_read_u32(np, "cirrus,adaptive-pwr-cfg", &val32) >= 0)\r\npdata->adaptive_pwr = val32;\r\nif (of_property_read_u32(np, "cirrus,hpf-left-freq", &val32) >= 0)\r\npdata->hpfa_freq = val32;\r\nif (of_property_read_u32(np, "cirrus,hpf-left-freq", &val32) >= 0)\r\npdata->hpfb_freq = val32;\r\npdata->gpio_nreset = of_get_named_gpio(np, "cirrus,gpio-nreset", 0);\r\nreturn 0;\r\n}\r\nstatic int cs42l56_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs42l56_private *cs42l56;\r\nstruct cs42l56_platform_data *pdata =\r\ndev_get_platdata(&i2c_client->dev);\r\nint ret, i;\r\nunsigned int devid = 0;\r\nunsigned int alpha_rev, metal_rev;\r\nunsigned int reg;\r\ncs42l56 = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs42l56_private),\r\nGFP_KERNEL);\r\nif (cs42l56 == NULL)\r\nreturn -ENOMEM;\r\ncs42l56->dev = &i2c_client->dev;\r\ncs42l56->regmap = devm_regmap_init_i2c(i2c_client, &cs42l56_regmap);\r\nif (IS_ERR(cs42l56->regmap)) {\r\nret = PTR_ERR(cs42l56->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\ncs42l56->pdata = *pdata;\r\n} else {\r\npdata = devm_kzalloc(&i2c_client->dev,\r\nsizeof(struct cs42l56_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(&i2c_client->dev,\r\n"could not allocate pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c_client->dev.of_node) {\r\nret = cs42l56_handle_of_data(i2c_client,\r\n&cs42l56->pdata);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ncs42l56->pdata = *pdata;\r\n}\r\nif (cs42l56->pdata.gpio_nreset) {\r\nret = gpio_request_one(cs42l56->pdata.gpio_nreset,\r\nGPIOF_OUT_INIT_HIGH, "CS42L56 /RST");\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request /RST %d: %d\n",\r\ncs42l56->pdata.gpio_nreset, ret);\r\nreturn ret;\r\n}\r\ngpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 0);\r\ngpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 1);\r\n}\r\ni2c_set_clientdata(i2c_client, cs42l56);\r\nfor (i = 0; i < ARRAY_SIZE(cs42l56->supplies); i++)\r\ncs42l56->supplies[i].supply = cs42l56_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\nARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(cs42l56->regmap, CS42L56_CHIP_ID_1, &reg);\r\ndevid = reg & CS42L56_CHIP_ID_MASK;\r\nif (devid != CS42L56_DEVID) {\r\ndev_err(&i2c_client->dev,\r\n"CS42L56 Device ID (%X). Expected %X\n",\r\ndevid, CS42L56_DEVID);\r\ngoto err_enable;\r\n}\r\nalpha_rev = reg & CS42L56_AREV_MASK;\r\nmetal_rev = reg & CS42L56_MTLREV_MASK;\r\ndev_info(&i2c_client->dev, "Cirrus Logic CS42L56 ");\r\ndev_info(&i2c_client->dev, "Alpha Rev %X Metal Rev %X\n",\r\nalpha_rev, metal_rev);\r\nif (cs42l56->pdata.ain1a_ref_cfg)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\r\nCS42L56_AIN1A_REF_MASK,\r\nCS42L56_AIN1A_REF_MASK);\r\nif (cs42l56->pdata.ain1b_ref_cfg)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\r\nCS42L56_AIN1B_REF_MASK,\r\nCS42L56_AIN1B_REF_MASK);\r\nif (cs42l56->pdata.ain2a_ref_cfg)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\r\nCS42L56_AIN2A_REF_MASK,\r\nCS42L56_AIN2A_REF_MASK);\r\nif (cs42l56->pdata.ain2b_ref_cfg)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\r\nCS42L56_AIN2B_REF_MASK,\r\nCS42L56_AIN2B_REF_MASK);\r\nif (cs42l56->pdata.micbias_lvl)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_GAIN_BIAS_CTL,\r\nCS42L56_MIC_BIAS_MASK,\r\ncs42l56->pdata.micbias_lvl);\r\nif (cs42l56->pdata.chgfreq)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,\r\nCS42L56_CHRG_FREQ_MASK,\r\ncs42l56->pdata.chgfreq);\r\nif (cs42l56->pdata.hpfb_freq)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,\r\nCS42L56_HPFB_FREQ_MASK,\r\ncs42l56->pdata.hpfb_freq);\r\nif (cs42l56->pdata.hpfa_freq)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,\r\nCS42L56_HPFA_FREQ_MASK,\r\ncs42l56->pdata.hpfa_freq);\r\nif (cs42l56->pdata.adaptive_pwr)\r\nregmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,\r\nCS42L56_ADAPT_PWR_MASK,\r\ncs42l56->pdata.adaptive_pwr);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs42l56, &cs42l56_dai, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs42l56_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct cs42l56_private *cs42l56 = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\r\ncs42l56->supplies);\r\nreturn 0;\r\n}
