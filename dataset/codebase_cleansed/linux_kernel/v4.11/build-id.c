int build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread = machine__findnew_thread(machine, sample->pid,\r\nsample->tid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nthread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, sample->ip, &al);\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nthread__put(thread);\r\nreturn 0;\r\n}\r\nstatic int perf_event__exit_del_thread(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample\r\n__maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread = machine__findnew_thread(machine,\r\nevent->fork.pid,\r\nevent->fork.tid);\r\ndump_printf("(%d:%d):(%d:%d)\n", event->fork.pid, event->fork.tid,\r\nevent->fork.ppid, event->fork.ptid);\r\nif (thread) {\r\nmachine__remove_thread(machine, thread);\r\nthread__put(thread);\r\n}\r\nreturn 0;\r\n}\r\nint build_id__sprintf(const u8 *build_id, int len, char *bf)\r\n{\r\nchar *bid = bf;\r\nconst u8 *raw = build_id;\r\nint i;\r\nfor (i = 0; i < len; ++i) {\r\nsprintf(bid, "%02x", *raw);\r\n++raw;\r\nbid += 2;\r\n}\r\nreturn (bid - bf) + 1;\r\n}\r\nint sysfs__sprintf_build_id(const char *root_dir, char *sbuild_id)\r\n{\r\nchar notes[PATH_MAX];\r\nu8 build_id[BUILD_ID_SIZE];\r\nint ret;\r\nif (!root_dir)\r\nroot_dir = "";\r\nscnprintf(notes, sizeof(notes), "%s/sys/kernel/notes", root_dir);\r\nret = sysfs__read_build_id(notes, build_id, sizeof(build_id));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn build_id__sprintf(build_id, sizeof(build_id), sbuild_id);\r\n}\r\nint filename__sprintf_build_id(const char *pathname, char *sbuild_id)\r\n{\r\nu8 build_id[BUILD_ID_SIZE];\r\nint ret;\r\nret = filename__read_build_id(pathname, build_id, sizeof(build_id));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != sizeof(build_id))\r\nreturn -EINVAL;\r\nreturn build_id__sprintf(build_id, sizeof(build_id), sbuild_id);\r\n}\r\nstatic int asnprintf(char **strp, size_t size, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nif (!strp)\r\nreturn -EINVAL;\r\nva_start(ap, fmt);\r\nif (*strp)\r\nret = vsnprintf(*strp, size, fmt, ap);\r\nelse\r\nret = vasprintf(strp, fmt, ap);\r\nva_end(ap);\r\nreturn ret;\r\n}\r\nchar *build_id_cache__kallsyms_path(const char *sbuild_id, char *bf,\r\nsize_t size)\r\n{\r\nbool retry_old = true;\r\nsnprintf(bf, size, "%s/%s/%s/kallsyms",\r\nbuildid_dir, DSO__NAME_KALLSYMS, sbuild_id);\r\nretry:\r\nif (!access(bf, F_OK))\r\nreturn bf;\r\nif (retry_old) {\r\nsnprintf(bf, size, "%s/%s/%s",\r\nbuildid_dir, DSO__NAME_KALLSYMS, sbuild_id);\r\nretry_old = false;\r\ngoto retry;\r\n}\r\nreturn NULL;\r\n}\r\nchar *build_id_cache__linkname(const char *sbuild_id, char *bf, size_t size)\r\n{\r\nchar *tmp = bf;\r\nint ret = asnprintf(&bf, size, "%s/.build-id/%.2s/%s", buildid_dir,\r\nsbuild_id, sbuild_id + 2);\r\nif (ret < 0 || (tmp && size < (unsigned int)ret))\r\nreturn NULL;\r\nreturn bf;\r\n}\r\nchar *build_id_cache__origname(const char *sbuild_id)\r\n{\r\nchar *linkname;\r\nchar buf[PATH_MAX];\r\nchar *ret = NULL, *p;\r\nsize_t offs = 5;\r\nlinkname = build_id_cache__linkname(sbuild_id, NULL, 0);\r\nif (!linkname)\r\nreturn NULL;\r\nif (readlink(linkname, buf, PATH_MAX) < 0)\r\ngoto out;\r\np = strrchr(buf, '/');\r\nif (p && (p > buf + offs)) {\r\n*p = '\0';\r\nif (buf[offs + 1] == '[')\r\noffs++;\r\nret = strdup(buf + offs);\r\n}\r\nout:\r\nfree(linkname);\r\nreturn ret;\r\n}\r\nstatic bool build_id_cache__valid_id(char *sbuild_id)\r\n{\r\nchar real_sbuild_id[SBUILD_ID_SIZE] = "";\r\nchar *pathname;\r\nint ret = 0;\r\nbool result = false;\r\npathname = build_id_cache__origname(sbuild_id);\r\nif (!pathname)\r\nreturn false;\r\nif (!strcmp(pathname, DSO__NAME_KALLSYMS))\r\nret = sysfs__sprintf_build_id("/", real_sbuild_id);\r\nelse if (pathname[0] == '/')\r\nret = filename__sprintf_build_id(pathname, real_sbuild_id);\r\nelse\r\nret = -EINVAL;\r\nif (ret >= 0)\r\nresult = (strcmp(sbuild_id, real_sbuild_id) == 0);\r\nfree(pathname);\r\nreturn result;\r\n}\r\nstatic const char *build_id_cache__basename(bool is_kallsyms, bool is_vdso)\r\n{\r\nreturn is_kallsyms ? "kallsyms" : (is_vdso ? "vdso" : "elf");\r\n}\r\nchar *dso__build_id_filename(const struct dso *dso, char *bf, size_t size)\r\n{\r\nbool is_kallsyms = dso__is_kallsyms((struct dso *)dso);\r\nbool is_vdso = dso__is_vdso((struct dso *)dso);\r\nchar sbuild_id[SBUILD_ID_SIZE];\r\nchar *linkname;\r\nbool alloc = (bf == NULL);\r\nint ret;\r\nif (!dso->has_build_id)\r\nreturn NULL;\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id), sbuild_id);\r\nlinkname = build_id_cache__linkname(sbuild_id, NULL, 0);\r\nif (!linkname)\r\nreturn NULL;\r\nif (is_regular_file(linkname))\r\nret = asnprintf(&bf, size, "%s", linkname);\r\nelse\r\nret = asnprintf(&bf, size, "%s/%s", linkname,\r\nbuild_id_cache__basename(is_kallsyms, is_vdso));\r\nif (ret < 0 || (!alloc && size < (unsigned int)ret))\r\nbf = NULL;\r\nfree(linkname);\r\nreturn bf;\r\n}\r\nbool dso__build_id_is_kmod(const struct dso *dso, char *bf, size_t size)\r\n{\r\nchar *id_name = NULL, *ch;\r\nstruct stat sb;\r\nchar sbuild_id[SBUILD_ID_SIZE];\r\nif (!dso->has_build_id)\r\ngoto err;\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id), sbuild_id);\r\nid_name = build_id_cache__linkname(sbuild_id, NULL, 0);\r\nif (!id_name)\r\ngoto err;\r\nif (access(id_name, F_OK))\r\ngoto err;\r\nif (lstat(id_name, &sb) == -1)\r\ngoto err;\r\nif ((size_t)sb.st_size > size - 1)\r\ngoto err;\r\nif (readlink(id_name, bf, size - 1) < 0)\r\ngoto err;\r\nbf[sb.st_size] = '\0';\r\nch = strrchr(bf, '/');\r\nif (!ch)\r\ngoto err;\r\nif (ch - 3 < bf)\r\ngoto err;\r\nfree(id_name);\r\nreturn strncmp(".ko", ch - 3, 3) == 0;\r\nerr:\r\npr_err("Invalid build id: %s\n", id_name ? :\r\ndso->long_name ? :\r\ndso->short_name ? :\r\n"[unknown]");\r\nfree(id_name);\r\nreturn false;\r\n}\r\nstatic int write_buildid(const char *name, size_t name_len, u8 *build_id,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nint err;\r\nstruct build_id_event b;\r\nsize_t len;\r\nlen = name_len + 1;\r\nlen = PERF_ALIGN(len, NAME_ALIGN);\r\nmemset(&b, 0, sizeof(b));\r\nmemcpy(&b.build_id, build_id, BUILD_ID_SIZE);\r\nb.pid = pid;\r\nb.header.misc = misc;\r\nb.header.size = sizeof(b) + len;\r\nerr = writen(fd, &b, sizeof(b));\r\nif (err < 0)\r\nreturn err;\r\nreturn write_padded(fd, name, name_len + 1, len);\r\n}\r\nstatic int machine__write_buildid_table(struct machine *machine, int fd)\r\n{\r\nint err = 0;\r\nchar nm[PATH_MAX];\r\nstruct dso *pos;\r\nu16 kmisc = PERF_RECORD_MISC_KERNEL,\r\numisc = PERF_RECORD_MISC_USER;\r\nif (!machine__is_host(machine)) {\r\nkmisc = PERF_RECORD_MISC_GUEST_KERNEL;\r\numisc = PERF_RECORD_MISC_GUEST_USER;\r\n}\r\ndsos__for_each_with_build_id(pos, &machine->dsos.head) {\r\nconst char *name;\r\nsize_t name_len;\r\nbool in_kernel = false;\r\nif (!pos->hit && !dso__is_vdso(pos))\r\ncontinue;\r\nif (dso__is_vdso(pos)) {\r\nname = pos->short_name;\r\nname_len = pos->short_name_len;\r\n} else if (dso__is_kcore(pos)) {\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\nname_len = strlen(nm);\r\n} else {\r\nname = pos->long_name;\r\nname_len = pos->long_name_len;\r\n}\r\nin_kernel = pos->kernel ||\r\nis_kernel_module(name,\r\nPERF_RECORD_MISC_CPUMODE_UNKNOWN);\r\nerr = write_buildid(name, name_len, pos->build_id, machine->pid,\r\nin_kernel ? kmisc : umisc, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint perf_session__write_buildid_table(struct perf_session *session, int fd)\r\n{\r\nstruct rb_node *nd;\r\nint err = machine__write_buildid_table(&session->machines.host, fd);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__write_buildid_table(pos, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __dsos__hit_all(struct list_head *head)\r\n{\r\nstruct dso *pos;\r\nlist_for_each_entry(pos, head, node)\r\npos->hit = true;\r\nreturn 0;\r\n}\r\nstatic int machine__hit_all_dsos(struct machine *machine)\r\n{\r\nreturn __dsos__hit_all(&machine->dsos.head);\r\n}\r\nint dsos__hit_all(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint err;\r\nerr = machine__hit_all_dsos(&session->machines.host);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__hit_all_dsos(pos);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid disable_buildid_cache(void)\r\n{\r\nno_buildid_cache = true;\r\n}\r\nstatic bool lsdir_bid_head_filter(const char *name __maybe_unused,\r\nstruct dirent *d __maybe_unused)\r\n{\r\nreturn (strlen(d->d_name) == 2) &&\r\nisxdigit(d->d_name[0]) && isxdigit(d->d_name[1]);\r\n}\r\nstatic bool lsdir_bid_tail_filter(const char *name __maybe_unused,\r\nstruct dirent *d __maybe_unused)\r\n{\r\nint i = 0;\r\nwhile (isxdigit(d->d_name[i]) && i < SBUILD_ID_SIZE - 3)\r\ni++;\r\nreturn (i == SBUILD_ID_SIZE - 3) && (d->d_name[i] == '\0');\r\n}\r\nstruct strlist *build_id_cache__list_all(bool validonly)\r\n{\r\nstruct strlist *toplist, *linklist = NULL, *bidlist;\r\nstruct str_node *nd, *nd2;\r\nchar *topdir, *linkdir = NULL;\r\nchar sbuild_id[SBUILD_ID_SIZE];\r\nif (validonly)\r\nsymbol__init(NULL);\r\nif (asprintf(&topdir, "%s/.build-id/", buildid_dir) < 0)\r\nreturn NULL;\r\nbidlist = strlist__new(NULL, NULL);\r\nif (!bidlist)\r\ngoto out;\r\ntoplist = lsdir(topdir, lsdir_bid_head_filter);\r\nif (!toplist) {\r\npr_debug("Error in lsdir(%s): %d\n", topdir, errno);\r\nif (errno == ENOENT)\r\ngoto out;\r\ngoto err_out;\r\n}\r\nstrlist__for_each_entry(nd, toplist) {\r\nif (asprintf(&linkdir, "%s/%s", topdir, nd->s) < 0)\r\ngoto err_out;\r\nlinklist = lsdir(linkdir, lsdir_bid_tail_filter);\r\nif (!linklist) {\r\npr_debug("Error in lsdir(%s): %d\n", linkdir, errno);\r\ngoto err_out;\r\n}\r\nstrlist__for_each_entry(nd2, linklist) {\r\nif (snprintf(sbuild_id, SBUILD_ID_SIZE, "%s%s",\r\nnd->s, nd2->s) != SBUILD_ID_SIZE - 1)\r\ngoto err_out;\r\nif (validonly && !build_id_cache__valid_id(sbuild_id))\r\ncontinue;\r\nif (strlist__add(bidlist, sbuild_id) < 0)\r\ngoto err_out;\r\n}\r\nstrlist__delete(linklist);\r\nzfree(&linkdir);\r\n}\r\nout_free:\r\nstrlist__delete(toplist);\r\nout:\r\nfree(topdir);\r\nreturn bidlist;\r\nerr_out:\r\nstrlist__delete(linklist);\r\nzfree(&linkdir);\r\nstrlist__delete(bidlist);\r\nbidlist = NULL;\r\ngoto out_free;\r\n}\r\nstatic bool str_is_build_id(const char *maybe_sbuild_id, size_t len)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < len; i++) {\r\nif (!isxdigit(maybe_sbuild_id[i]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nchar *build_id_cache__complement(const char *incomplete_sbuild_id)\r\n{\r\nstruct strlist *bidlist;\r\nstruct str_node *nd, *cand = NULL;\r\nchar *sbuild_id = NULL;\r\nsize_t len = strlen(incomplete_sbuild_id);\r\nif (len >= SBUILD_ID_SIZE ||\r\n!str_is_build_id(incomplete_sbuild_id, len))\r\nreturn NULL;\r\nbidlist = build_id_cache__list_all(true);\r\nif (!bidlist)\r\nreturn NULL;\r\nstrlist__for_each_entry(nd, bidlist) {\r\nif (strncmp(nd->s, incomplete_sbuild_id, len) != 0)\r\ncontinue;\r\nif (cand) {\r\ncand = NULL;\r\nbreak;\r\n}\r\ncand = nd;\r\n}\r\nif (cand)\r\nsbuild_id = strdup(cand->s);\r\nstrlist__delete(bidlist);\r\nreturn sbuild_id;\r\n}\r\nchar *build_id_cache__cachedir(const char *sbuild_id, const char *name,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nchar *realname = (char *)name, *filename;\r\nbool slash = is_kallsyms || is_vdso;\r\nif (!slash) {\r\nrealname = realpath(name, NULL);\r\nif (!realname)\r\nreturn NULL;\r\n}\r\nif (asprintf(&filename, "%s%s%s%s%s", buildid_dir, slash ? "/" : "",\r\nis_vdso ? DSO__NAME_VDSO : realname,\r\nsbuild_id ? "/" : "", sbuild_id ?: "") < 0)\r\nfilename = NULL;\r\nif (!slash)\r\nfree(realname);\r\nreturn filename;\r\n}\r\nint build_id_cache__list_build_ids(const char *pathname,\r\nstruct strlist **result)\r\n{\r\nchar *dir_name;\r\nint ret = 0;\r\ndir_name = build_id_cache__cachedir(NULL, pathname, false, false);\r\nif (!dir_name)\r\nreturn -ENOMEM;\r\n*result = lsdir(dir_name, lsdir_no_dot_filter);\r\nif (!*result)\r\nret = -errno;\r\nfree(dir_name);\r\nreturn ret;\r\n}\r\nstatic int build_id_cache__add_sdt_cache(const char *sbuild_id,\r\nconst char *realname)\r\n{\r\nstruct probe_cache *cache;\r\nint ret;\r\ncache = probe_cache__new(sbuild_id);\r\nif (!cache)\r\nreturn -1;\r\nret = probe_cache__scan_sdt(cache, realname);\r\nif (ret >= 0) {\r\npr_debug4("Found %d SDTs in %s\n", ret, realname);\r\nif (probe_cache__commit(cache) < 0)\r\nret = -1;\r\n}\r\nprobe_cache__delete(cache);\r\nreturn ret;\r\n}\r\nint build_id_cache__add_s(const char *sbuild_id, const char *name,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *realname = NULL, *filename = NULL, *dir_name = NULL,\r\n*linkname = zalloc(size), *tmp;\r\nint err = -1;\r\nif (!is_kallsyms) {\r\nrealname = realpath(name, NULL);\r\nif (!realname)\r\ngoto out_free;\r\n}\r\ndir_name = build_id_cache__cachedir(sbuild_id, name,\r\nis_kallsyms, is_vdso);\r\nif (!dir_name)\r\ngoto out_free;\r\nif (is_regular_file(dir_name))\r\nif (unlink(dir_name))\r\ngoto out_free;\r\nif (mkdir_p(dir_name, 0755))\r\ngoto out_free;\r\nif (asprintf(&filename, "%s/%s", dir_name,\r\nbuild_id_cache__basename(is_kallsyms, is_vdso)) < 0) {\r\nfilename = NULL;\r\ngoto out_free;\r\n}\r\nif (access(filename, F_OK)) {\r\nif (is_kallsyms) {\r\nif (copyfile("/proc/kallsyms", filename))\r\ngoto out_free;\r\n} else if (link(realname, filename) && errno != EEXIST &&\r\ncopyfile(name, filename))\r\ngoto out_free;\r\n}\r\nif (!build_id_cache__linkname(sbuild_id, linkname, size))\r\ngoto out_free;\r\ntmp = strrchr(linkname, '/');\r\n*tmp = '\0';\r\nif (access(linkname, X_OK) && mkdir_p(linkname, 0755))\r\ngoto out_free;\r\n*tmp = '/';\r\ntmp = dir_name + strlen(buildid_dir) - 5;\r\nmemcpy(tmp, "../..", 5);\r\nif (symlink(tmp, linkname) == 0)\r\nerr = 0;\r\nif (build_id_cache__add_sdt_cache(sbuild_id, realname) < 0)\r\npr_debug4("Failed to update/scan SDT cache for %s\n", realname);\r\nout_free:\r\nif (!is_kallsyms)\r\nfree(realname);\r\nfree(filename);\r\nfree(dir_name);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int build_id_cache__add_b(const u8 *build_id, size_t build_id_size,\r\nconst char *name, bool is_kallsyms,\r\nbool is_vdso)\r\n{\r\nchar sbuild_id[SBUILD_ID_SIZE];\r\nbuild_id__sprintf(build_id, build_id_size, sbuild_id);\r\nreturn build_id_cache__add_s(sbuild_id, name, is_kallsyms, is_vdso);\r\n}\r\nbool build_id_cache__cached(const char *sbuild_id)\r\n{\r\nbool ret = false;\r\nchar *filename = build_id_cache__linkname(sbuild_id, NULL, 0);\r\nif (filename && !access(filename, F_OK))\r\nret = true;\r\nfree(filename);\r\nreturn ret;\r\n}\r\nint build_id_cache__remove_s(const char *sbuild_id)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *filename = zalloc(size),\r\n*linkname = zalloc(size), *tmp;\r\nint err = -1;\r\nif (filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nif (!build_id_cache__linkname(sbuild_id, linkname, size))\r\ngoto out_free;\r\nif (access(linkname, F_OK))\r\ngoto out_free;\r\nif (readlink(linkname, filename, size - 1) < 0)\r\ngoto out_free;\r\nif (unlink(linkname))\r\ngoto out_free;\r\ntmp = strrchr(linkname, '/') + 1;\r\nsnprintf(tmp, size - (tmp - linkname), "%s", filename);\r\nif (rm_rf(linkname))\r\ngoto out_free;\r\nerr = 0;\r\nout_free:\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int dso__cache_build_id(struct dso *dso, struct machine *machine)\r\n{\r\nbool is_kallsyms = dso__is_kallsyms(dso);\r\nbool is_vdso = dso__is_vdso(dso);\r\nconst char *name = dso->long_name;\r\nchar nm[PATH_MAX];\r\nif (dso__is_kcore(dso)) {\r\nis_kallsyms = true;\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\n}\r\nreturn build_id_cache__add_b(dso->build_id, sizeof(dso->build_id), name,\r\nis_kallsyms, is_vdso);\r\n}\r\nstatic int __dsos__cache_build_ids(struct list_head *head,\r\nstruct machine *machine)\r\n{\r\nstruct dso *pos;\r\nint err = 0;\r\ndsos__for_each_with_build_id(pos, head)\r\nif (dso__cache_build_id(pos, machine))\r\nerr = -1;\r\nreturn err;\r\n}\r\nstatic int machine__cache_build_ids(struct machine *machine)\r\n{\r\nreturn __dsos__cache_build_ids(&machine->dsos.head, machine);\r\n}\r\nint perf_session__cache_build_ids(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint ret;\r\nif (no_buildid_cache)\r\nreturn 0;\r\nif (mkdir(buildid_dir, 0755) != 0 && errno != EEXIST)\r\nreturn -1;\r\nret = machine__cache_build_ids(&session->machines.host);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__cache_build_ids(pos);\r\n}\r\nreturn ret ? -1 : 0;\r\n}\r\nstatic bool machine__read_build_ids(struct machine *machine, bool with_hits)\r\n{\r\nreturn __dsos__read_build_ids(&machine->dsos.head, with_hits);\r\n}\r\nbool perf_session__read_build_ids(struct perf_session *session, bool with_hits)\r\n{\r\nstruct rb_node *nd;\r\nbool ret = machine__read_build_ids(&session->machines.host, with_hits);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__read_build_ids(pos, with_hits);\r\n}\r\nreturn ret;\r\n}
