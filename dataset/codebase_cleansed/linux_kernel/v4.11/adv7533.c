static void adv7511_dsi_config_timing_gen(struct adv7511 *adv)\r\n{\r\nstruct mipi_dsi_device *dsi = adv->dsi;\r\nstruct drm_display_mode *mode = &adv->curr_mode;\r\nunsigned int hsw, hfp, hbp, vsw, vfp, vbp;\r\nu8 clock_div_by_lanes[] = { 6, 4, 3 };\r\nhsw = mode->hsync_end - mode->hsync_start;\r\nhfp = mode->hsync_start - mode->hdisplay;\r\nhbp = mode->htotal - mode->hsync_end;\r\nvsw = mode->vsync_end - mode->vsync_start;\r\nvfp = mode->vsync_start - mode->vdisplay;\r\nvbp = mode->vtotal - mode->vsync_end;\r\nregmap_write(adv->regmap_cec, 0x16,\r\nclock_div_by_lanes[dsi->lanes - 2] << 3);\r\nregmap_write(adv->regmap_cec, 0x28, mode->htotal >> 4);\r\nregmap_write(adv->regmap_cec, 0x29, (mode->htotal << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x2a, hsw >> 4);\r\nregmap_write(adv->regmap_cec, 0x2b, (hsw << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x2c, hfp >> 4);\r\nregmap_write(adv->regmap_cec, 0x2d, (hfp << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x2e, hbp >> 4);\r\nregmap_write(adv->regmap_cec, 0x2f, (hbp << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x30, mode->vtotal >> 4);\r\nregmap_write(adv->regmap_cec, 0x31, (mode->vtotal << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x32, vsw >> 4);\r\nregmap_write(adv->regmap_cec, 0x33, (vsw << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x34, vfp >> 4);\r\nregmap_write(adv->regmap_cec, 0x35, (vfp << 4) & 0xff);\r\nregmap_write(adv->regmap_cec, 0x36, vbp >> 4);\r\nregmap_write(adv->regmap_cec, 0x37, (vbp << 4) & 0xff);\r\n}\r\nvoid adv7533_dsi_power_on(struct adv7511 *adv)\r\n{\r\nstruct mipi_dsi_device *dsi = adv->dsi;\r\nif (adv->use_timing_gen)\r\nadv7511_dsi_config_timing_gen(adv);\r\nregmap_write(adv->regmap_cec, 0x1c, dsi->lanes << 4);\r\nif (adv->use_timing_gen) {\r\nregmap_write(adv->regmap_cec, 0x27, 0xcb);\r\nregmap_write(adv->regmap_cec, 0x27, 0x8b);\r\nregmap_write(adv->regmap_cec, 0x27, 0xcb);\r\n} else {\r\nregmap_write(adv->regmap_cec, 0x27, 0x0b);\r\n}\r\nregmap_write(adv->regmap_cec, 0x03, 0x89);\r\nregmap_write(adv->regmap_cec, 0x55, 0x00);\r\nregmap_register_patch(adv->regmap_cec, adv7533_cec_fixed_registers,\r\nARRAY_SIZE(adv7533_cec_fixed_registers));\r\n}\r\nvoid adv7533_dsi_power_off(struct adv7511 *adv)\r\n{\r\nregmap_write(adv->regmap_cec, 0x03, 0x0b);\r\nregmap_write(adv->regmap_cec, 0x27, 0x0b);\r\n}\r\nvoid adv7533_mode_set(struct adv7511 *adv, struct drm_display_mode *mode)\r\n{\r\nstruct mipi_dsi_device *dsi = adv->dsi;\r\nint lanes, ret;\r\nif (adv->num_dsi_lanes != 4)\r\nreturn;\r\nif (mode->clock > 80000)\r\nlanes = 4;\r\nelse\r\nlanes = 3;\r\nif (lanes != dsi->lanes) {\r\nmipi_dsi_detach(dsi);\r\ndsi->lanes = lanes;\r\nret = mipi_dsi_attach(dsi);\r\nif (ret)\r\ndev_err(&dsi->dev, "failed to change host lanes\n");\r\n}\r\n}\r\nint adv7533_patch_registers(struct adv7511 *adv)\r\n{\r\nreturn regmap_register_patch(adv->regmap,\r\nadv7533_fixed_registers,\r\nARRAY_SIZE(adv7533_fixed_registers));\r\n}\r\nvoid adv7533_uninit_cec(struct adv7511 *adv)\r\n{\r\ni2c_unregister_device(adv->i2c_cec);\r\n}\r\nint adv7533_init_cec(struct adv7511 *adv)\r\n{\r\nint ret;\r\nadv->i2c_cec = i2c_new_dummy(adv->i2c_main->adapter,\r\nadv->i2c_main->addr - 1);\r\nif (!adv->i2c_cec)\r\nreturn -ENOMEM;\r\nadv->regmap_cec = devm_regmap_init_i2c(adv->i2c_cec,\r\n&adv7533_cec_regmap_config);\r\nif (IS_ERR(adv->regmap_cec)) {\r\nret = PTR_ERR(adv->regmap_cec);\r\ngoto err;\r\n}\r\nret = regmap_register_patch(adv->regmap_cec,\r\nadv7533_cec_fixed_registers,\r\nARRAY_SIZE(adv7533_cec_fixed_registers));\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nadv7533_uninit_cec(adv);\r\nreturn ret;\r\n}\r\nint adv7533_attach_dsi(struct adv7511 *adv)\r\n{\r\nstruct device *dev = &adv->i2c_main->dev;\r\nstruct mipi_dsi_host *host;\r\nstruct mipi_dsi_device *dsi;\r\nint ret = 0;\r\nconst struct mipi_dsi_device_info info = { .type = "adv7533",\r\n.channel = 0,\r\n.node = NULL,\r\n};\r\nhost = of_find_mipi_dsi_host_by_node(adv->host_node);\r\nif (!host) {\r\ndev_err(dev, "failed to find dsi host\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ndsi = mipi_dsi_device_register_full(host, &info);\r\nif (IS_ERR(dsi)) {\r\ndev_err(dev, "failed to create dsi device\n");\r\nret = PTR_ERR(dsi);\r\ngoto err_dsi_device;\r\n}\r\nadv->dsi = dsi;\r\ndsi->lanes = adv->num_dsi_lanes;\r\ndsi->format = MIPI_DSI_FMT_RGB888;\r\ndsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\r\nMIPI_DSI_MODE_EOT_PACKET | MIPI_DSI_MODE_VIDEO_HSE;\r\nret = mipi_dsi_attach(dsi);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to attach dsi to host\n");\r\ngoto err_dsi_attach;\r\n}\r\nreturn 0;\r\nerr_dsi_attach:\r\nmipi_dsi_device_unregister(dsi);\r\nerr_dsi_device:\r\nreturn ret;\r\n}\r\nvoid adv7533_detach_dsi(struct adv7511 *adv)\r\n{\r\nmipi_dsi_detach(adv->dsi);\r\nmipi_dsi_device_unregister(adv->dsi);\r\n}\r\nint adv7533_parse_dt(struct device_node *np, struct adv7511 *adv)\r\n{\r\nu32 num_lanes;\r\nstruct device_node *endpoint;\r\nof_property_read_u32(np, "adi,dsi-lanes", &num_lanes);\r\nif (num_lanes < 1 || num_lanes > 4)\r\nreturn -EINVAL;\r\nadv->num_dsi_lanes = num_lanes;\r\nendpoint = of_graph_get_next_endpoint(np, NULL);\r\nif (!endpoint)\r\nreturn -ENODEV;\r\nadv->host_node = of_graph_get_remote_port_parent(endpoint);\r\nif (!adv->host_node) {\r\nof_node_put(endpoint);\r\nreturn -ENODEV;\r\n}\r\nof_node_put(endpoint);\r\nof_node_put(adv->host_node);\r\nadv->use_timing_gen = !of_property_read_bool(np,\r\n"adi,disable-timing-generator");\r\nadv->rgb = true;\r\nadv->embedded_sync = false;\r\nreturn 0;\r\n}
