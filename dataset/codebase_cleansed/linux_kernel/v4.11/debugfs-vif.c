static void iwl_dbgfs_update_pm(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nenum iwl_dbgfs_pm_mask param, int val)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_dbgfs_pm *dbgfs_pm = &mvmvif->dbgfs_pm;\r\ndbgfs_pm->mask |= param;\r\nswitch (param) {\r\ncase MVM_DEBUGFS_PM_KEEP_ALIVE: {\r\nint dtimper = vif->bss_conf.dtim_period ?: 1;\r\nint dtimper_msec = dtimper * vif->bss_conf.beacon_int;\r\nIWL_DEBUG_POWER(mvm, "debugfs: set keep_alive= %d sec\n", val);\r\nif (val * MSEC_PER_SEC < 3 * dtimper_msec)\r\nIWL_WARN(mvm,\r\n"debugfs: keep alive period (%ld msec) is less than minimum required (%d msec)\n",\r\nval * MSEC_PER_SEC, 3 * dtimper_msec);\r\ndbgfs_pm->keep_alive_seconds = val;\r\nbreak;\r\n}\r\ncase MVM_DEBUGFS_PM_SKIP_OVER_DTIM:\r\nIWL_DEBUG_POWER(mvm, "skip_over_dtim %s\n",\r\nval ? "enabled" : "disabled");\r\ndbgfs_pm->skip_over_dtim = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS:\r\nIWL_DEBUG_POWER(mvm, "skip_dtim_periods=%d\n", val);\r\ndbgfs_pm->skip_dtim_periods = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_RX_DATA_TIMEOUT:\r\nIWL_DEBUG_POWER(mvm, "rx_data_timeout=%d\n", val);\r\ndbgfs_pm->rx_data_timeout = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_TX_DATA_TIMEOUT:\r\nIWL_DEBUG_POWER(mvm, "tx_data_timeout=%d\n", val);\r\ndbgfs_pm->tx_data_timeout = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_LPRX_ENA:\r\nIWL_DEBUG_POWER(mvm, "lprx %s\n", val ? "enabled" : "disabled");\r\ndbgfs_pm->lprx_ena = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD:\r\nIWL_DEBUG_POWER(mvm, "lprx_rssi_threshold=%d\n", val);\r\ndbgfs_pm->lprx_rssi_threshold = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_SNOOZE_ENABLE:\r\nIWL_DEBUG_POWER(mvm, "snooze_enable=%d\n", val);\r\ndbgfs_pm->snooze_ena = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_UAPSD_MISBEHAVING:\r\nIWL_DEBUG_POWER(mvm, "uapsd_misbehaving_enable=%d\n", val);\r\ndbgfs_pm->uapsd_misbehaving = val;\r\nbreak;\r\ncase MVM_DEBUGFS_PM_USE_PS_POLL:\r\nIWL_DEBUG_POWER(mvm, "use_ps_poll=%d\n", val);\r\ndbgfs_pm->use_ps_poll = val;\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t iwl_dbgfs_pm_params_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nenum iwl_dbgfs_pm_mask param;\r\nint val, ret;\r\nif (!strncmp("keep_alive=", buf, 11)) {\r\nif (sscanf(buf + 11, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_KEEP_ALIVE;\r\n} else if (!strncmp("skip_over_dtim=", buf, 15)) {\r\nif (sscanf(buf + 15, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SKIP_OVER_DTIM;\r\n} else if (!strncmp("skip_dtim_periods=", buf, 18)) {\r\nif (sscanf(buf + 18, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SKIP_DTIM_PERIODS;\r\n} else if (!strncmp("rx_data_timeout=", buf, 16)) {\r\nif (sscanf(buf + 16, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_RX_DATA_TIMEOUT;\r\n} else if (!strncmp("tx_data_timeout=", buf, 16)) {\r\nif (sscanf(buf + 16, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_TX_DATA_TIMEOUT;\r\n} else if (!strncmp("lprx=", buf, 5)) {\r\nif (sscanf(buf + 5, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_LPRX_ENA;\r\n} else if (!strncmp("lprx_rssi_threshold=", buf, 20)) {\r\nif (sscanf(buf + 20, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nif (val > POWER_LPRX_RSSI_THRESHOLD_MAX || val <\r\nPOWER_LPRX_RSSI_THRESHOLD_MIN)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_LPRX_RSSI_THRESHOLD;\r\n} else if (!strncmp("snooze_enable=", buf, 14)) {\r\nif (sscanf(buf + 14, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_SNOOZE_ENABLE;\r\n} else if (!strncmp("uapsd_misbehaving=", buf, 18)) {\r\nif (sscanf(buf + 18, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_UAPSD_MISBEHAVING;\r\n} else if (!strncmp("use_ps_poll=", buf, 12)) {\r\nif (sscanf(buf + 12, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_PM_USE_PS_POLL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mvm->mutex);\r\niwl_dbgfs_update_pm(mvm, vif, param, val);\r\nret = iwl_mvm_power_update_mac(mvm);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tx_pwr_lmt_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nchar buf[64];\r\nint bufsz = sizeof(buf);\r\nint pos;\r\npos = scnprintf(buf, bufsz, "bss limit = %d\n",\r\nvif->bss_conf.txpower);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_pm_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[512];\r\nint bufsz = sizeof(buf);\r\nint pos;\r\npos = iwl_mvm_power_mac_dbgfs_read(mvm, vif, buf, bufsz);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_mac_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu8 ap_sta_id;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nchar buf[512];\r\nint bufsz = sizeof(buf);\r\nint pos = 0;\r\nint i;\r\nmutex_lock(&mvm->mutex);\r\nap_sta_id = mvmvif->ap_sta_id;\r\nswitch (ieee80211_vif_type_p2p(vif)) {\r\ncase NL80211_IFTYPE_ADHOC:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: ibss\n");\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: bss\n");\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: ap\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p client\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p go\n");\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\npos += scnprintf(buf+pos, bufsz-pos, "type: p2p dev\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npos += scnprintf(buf+pos, bufsz-pos, "mac id/color: %d / %d\n",\r\nmvmvif->id, mvmvif->color);\r\npos += scnprintf(buf+pos, bufsz-pos, "bssid: %pM\n",\r\nvif->bss_conf.bssid);\r\npos += scnprintf(buf+pos, bufsz-pos, "QoS:\n");\r\nfor (i = 0; i < ARRAY_SIZE(mvmvif->queue_params); i++)\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"\t%d: txop:%d - cw_min:%d - cw_max = %d - aifs = %d upasd = %d\n",\r\ni, mvmvif->queue_params[i].txop,\r\nmvmvif->queue_params[i].cw_min,\r\nmvmvif->queue_params[i].cw_max,\r\nmvmvif->queue_params[i].aifs,\r\nmvmvif->queue_params[i].uapsd);\r\nif (vif->type == NL80211_IFTYPE_STATION &&\r\nap_sta_id != IWL_MVM_STATION_COUNT) {\r\nstruct iwl_mvm_sta *mvm_sta;\r\nmvm_sta = iwl_mvm_sta_from_staid_protected(mvm, ap_sta_id);\r\nif (mvm_sta) {\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"ap_sta_id %d - reduced Tx power %d\n",\r\nap_sta_id,\r\nmvm_sta->bt_reduced_txpower);\r\n}\r\n}\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(vif->chanctx_conf);\r\nif (chanctx_conf)\r\npos += scnprintf(buf+pos, bufsz-pos,\r\n"idle rx chains %d, active rx chains: %d\n",\r\nchanctx_conf->rx_chains_static,\r\nchanctx_conf->rx_chains_dynamic);\r\nrcu_read_unlock();\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic void iwl_dbgfs_update_bf(struct ieee80211_vif *vif,\r\nenum iwl_dbgfs_bf_mask param, int value)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_dbgfs_bf *dbgfs_bf = &mvmvif->dbgfs_bf;\r\ndbgfs_bf->mask |= param;\r\nswitch (param) {\r\ncase MVM_DEBUGFS_BF_ENERGY_DELTA:\r\ndbgfs_bf->bf_energy_delta = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA:\r\ndbgfs_bf->bf_roaming_energy_delta = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ROAMING_STATE:\r\ndbgfs_bf->bf_roaming_state = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_THRESHOLD:\r\ndbgfs_bf->bf_temp_threshold = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_FAST_FILTER:\r\ndbgfs_bf->bf_temp_fast_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_TEMP_SLOW_FILTER:\r\ndbgfs_bf->bf_temp_slow_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER:\r\ndbgfs_bf->bf_enable_beacon_filter = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_DEBUG_FLAG:\r\ndbgfs_bf->bf_debug_flag = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BF_ESCAPE_TIMER:\r\ndbgfs_bf->bf_escape_timer = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT:\r\ndbgfs_bf->ba_enable_beacon_abort = value;\r\nbreak;\r\ncase MVM_DEBUGFS_BA_ESCAPE_TIMER:\r\ndbgfs_bf->ba_escape_timer = value;\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t iwl_dbgfs_bf_params_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nenum iwl_dbgfs_bf_mask param;\r\nint value, ret = 0;\r\nif (!strncmp("bf_energy_delta=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ENERGY_DELTA_MIN ||\r\nvalue > IWL_BF_ENERGY_DELTA_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ENERGY_DELTA;\r\n} else if (!strncmp("bf_roaming_energy_delta=", buf, 24)) {\r\nif (sscanf(buf+24, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ROAMING_ENERGY_DELTA_MIN ||\r\nvalue > IWL_BF_ROAMING_ENERGY_DELTA_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ROAMING_ENERGY_DELTA;\r\n} else if (!strncmp("bf_roaming_state=", buf, 17)) {\r\nif (sscanf(buf+17, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ROAMING_STATE_MIN ||\r\nvalue > IWL_BF_ROAMING_STATE_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ROAMING_STATE;\r\n} else if (!strncmp("bf_temp_threshold=", buf, 18)) {\r\nif (sscanf(buf+18, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_THRESHOLD_MIN ||\r\nvalue > IWL_BF_TEMP_THRESHOLD_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_THRESHOLD;\r\n} else if (!strncmp("bf_temp_fast_filter=", buf, 20)) {\r\nif (sscanf(buf+20, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_FAST_FILTER_MIN ||\r\nvalue > IWL_BF_TEMP_FAST_FILTER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_FAST_FILTER;\r\n} else if (!strncmp("bf_temp_slow_filter=", buf, 20)) {\r\nif (sscanf(buf+20, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_TEMP_SLOW_FILTER_MIN ||\r\nvalue > IWL_BF_TEMP_SLOW_FILTER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_TEMP_SLOW_FILTER;\r\n} else if (!strncmp("bf_enable_beacon_filter=", buf, 24)) {\r\nif (sscanf(buf+24, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER;\r\n} else if (!strncmp("bf_debug_flag=", buf, 14)) {\r\nif (sscanf(buf+14, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_DEBUG_FLAG;\r\n} else if (!strncmp("bf_escape_timer=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BF_ESCAPE_TIMER_MIN ||\r\nvalue > IWL_BF_ESCAPE_TIMER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BF_ESCAPE_TIMER;\r\n} else if (!strncmp("ba_escape_timer=", buf, 16)) {\r\nif (sscanf(buf+16, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < IWL_BA_ESCAPE_TIMER_MIN ||\r\nvalue > IWL_BA_ESCAPE_TIMER_MAX)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BA_ESCAPE_TIMER;\r\n} else if (!strncmp("ba_enable_beacon_abort=", buf, 23)) {\r\nif (sscanf(buf+23, "%d", &value) != 1)\r\nreturn -EINVAL;\r\nif (value < 0 || value > 1)\r\nreturn -EINVAL;\r\nparam = MVM_DEBUGFS_BA_ENABLE_BEACON_ABORT;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mvm->mutex);\r\niwl_dbgfs_update_bf(vif, param, value);\r\nif (param == MVM_DEBUGFS_BF_ENABLE_BEACON_FILTER && !value)\r\nret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\r\nelse\r\nret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_bf_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[256];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_beacon_filter_cmd cmd = {\r\nIWL_BF_CMD_CONFIG_DEFAULTS,\r\n.bf_enable_beacon_filter =\r\ncpu_to_le32(IWL_BF_ENABLE_BEACON_FILTER_DEFAULT),\r\n.ba_enable_beacon_abort =\r\ncpu_to_le32(IWL_BA_ENABLE_BEACON_ABORT_DEFAULT),\r\n};\r\niwl_mvm_beacon_filter_debugfs_parameters(vif, &cmd);\r\nif (mvmvif->bf_data.bf_enabled)\r\ncmd.bf_enable_beacon_filter = cpu_to_le32(1);\r\nelse\r\ncmd.bf_enable_beacon_filter = 0;\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_energy_delta = %d\n",\r\nle32_to_cpu(cmd.bf_energy_delta));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_energy_delta = %d\n",\r\nle32_to_cpu(cmd.bf_roaming_energy_delta));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_roaming_state = %d\n",\r\nle32_to_cpu(cmd.bf_roaming_state));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_threshold = %d\n",\r\nle32_to_cpu(cmd.bf_temp_threshold));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_fast_filter = %d\n",\r\nle32_to_cpu(cmd.bf_temp_fast_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_temp_slow_filter = %d\n",\r\nle32_to_cpu(cmd.bf_temp_slow_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_enable_beacon_filter = %d\n",\r\nle32_to_cpu(cmd.bf_enable_beacon_filter));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_debug_flag = %d\n",\r\nle32_to_cpu(cmd.bf_debug_flag));\r\npos += scnprintf(buf+pos, bufsz-pos, "bf_escape_timer = %d\n",\r\nle32_to_cpu(cmd.bf_escape_timer));\r\npos += scnprintf(buf+pos, bufsz-pos, "ba_escape_timer = %d\n",\r\nle32_to_cpu(cmd.ba_escape_timer));\r\npos += scnprintf(buf+pos, bufsz-pos, "ba_enable_beacon_abort = %d\n",\r\nle32_to_cpu(cmd.ba_enable_beacon_abort));\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic inline char *iwl_dbgfs_is_match(char *name, char *buf)\r\n{\r\nint len = strlen(name);\r\nreturn !strncmp(name, buf, len) ? buf + len : NULL;\r\n}\r\nstatic ssize_t iwl_dbgfs_os_device_timediff_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 curr_gp2;\r\nu64 curr_os;\r\ns64 diff;\r\nchar buf[64];\r\nconst size_t bufsz = sizeof(buf);\r\nint pos = 0;\r\niwl_mvm_get_sync_time(mvm, &curr_gp2, &curr_os);\r\ndo_div(curr_os, NSEC_PER_USEC);\r\ndiff = curr_os - curr_gp2;\r\npos += scnprintf(buf + pos, bufsz - pos, "diff=%lld\n", diff);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_enable_write(struct ieee80211_vif *vif,\r\nchar *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 value;\r\nint ret = -EINVAL;\r\nchar *data;\r\nmutex_lock(&mvm->mutex);\r\ndata = iwl_dbgfs_is_match("tof_disabled=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.tof_cfg.tof_disabled = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("one_sided_disabled=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.tof_cfg.one_sided_disabled = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("is_debug_mode=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.tof_cfg.is_debug_mode = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("is_buf=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.tof_cfg.is_buf_required = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("send_tof_cfg=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value) {\r\nret = iwl_mvm_tof_config_cmd(mvm);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_enable_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[256];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_tof_config_cmd *cmd;\r\ncmd = &mvm->tof_data.tof_cfg;\r\nmutex_lock(&mvm->mutex);\r\npos += scnprintf(buf + pos, bufsz - pos, "tof_disabled = %d\n",\r\ncmd->tof_disabled);\r\npos += scnprintf(buf + pos, bufsz - pos, "one_sided_disabled = %d\n",\r\ncmd->one_sided_disabled);\r\npos += scnprintf(buf + pos, bufsz - pos, "is_debug_mode = %d\n",\r\ncmd->is_debug_mode);\r\npos += scnprintf(buf + pos, bufsz - pos, "is_buf_required = %d\n",\r\ncmd->is_buf_required);\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_responder_params_write(struct ieee80211_vif *vif,\r\nchar *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 value;\r\nint ret = 0;\r\nchar *data;\r\nmutex_lock(&mvm->mutex);\r\ndata = iwl_dbgfs_is_match("burst_period=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (!ret)\r\nmvm->tof_data.responder_cfg.burst_period =\r\ncpu_to_le16(value);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("min_delta_ftm=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.min_delta_ftm = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("burst_duration=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.burst_duration = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("num_of_burst_exp=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.num_of_burst_exp = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("abort_responder=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.abort_responder = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("get_ch_est=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.get_ch_est = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("recv_sta_req_params=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.recv_sta_req_params = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("channel_num=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.channel_num = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("bandwidth=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.bandwidth = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("rate=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.rate = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("bssid=", buf);\r\nif (data) {\r\nu8 *mac = mvm->tof_data.responder_cfg.bssid;\r\nif (!mac_pton(data, mac)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ndata = iwl_dbgfs_is_match("tsf_timer_offset_msecs=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.tsf_timer_offset_msecs =\r\ncpu_to_le16(value);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("toa_offset=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.toa_offset =\r\ncpu_to_le16(value);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("center_freq=", buf);\r\nif (data) {\r\nstruct iwl_tof_responder_config_cmd *cmd =\r\n&mvm->tof_data.responder_cfg;\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value) {\r\nenum nl80211_band band = (cmd->channel_num <= 14) ?\r\nNL80211_BAND_2GHZ :\r\nNL80211_BAND_5GHZ;\r\nstruct ieee80211_channel chn = {\r\n.band = band,\r\n.center_freq = ieee80211_channel_to_frequency(\r\ncmd->channel_num, band),\r\n};\r\nstruct cfg80211_chan_def chandef = {\r\n.chan = &chn,\r\n.center_freq1 =\r\nieee80211_channel_to_frequency(value,\r\nband),\r\n};\r\ncmd->ctrl_ch_position = iwl_mvm_get_ctrl_pos(&chandef);\r\n}\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ftm_per_burst=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.ftm_per_burst = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ftm_resp_ts_avail=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.ftm_resp_ts_avail = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("asap_mode=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.responder_cfg.asap_mode = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("send_responder_cfg=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value) {\r\nret = iwl_mvm_tof_responder_cmd(mvm, vif);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_responder_params_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[256];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_tof_responder_config_cmd *cmd;\r\ncmd = &mvm->tof_data.responder_cfg;\r\nmutex_lock(&mvm->mutex);\r\npos += scnprintf(buf + pos, bufsz - pos, "burst_period = %d\n",\r\nle16_to_cpu(cmd->burst_period));\r\npos += scnprintf(buf + pos, bufsz - pos, "burst_duration = %d\n",\r\ncmd->burst_duration);\r\npos += scnprintf(buf + pos, bufsz - pos, "bandwidth = %d\n",\r\ncmd->bandwidth);\r\npos += scnprintf(buf + pos, bufsz - pos, "channel_num = %d\n",\r\ncmd->channel_num);\r\npos += scnprintf(buf + pos, bufsz - pos, "ctrl_ch_position = 0x%x\n",\r\ncmd->ctrl_ch_position);\r\npos += scnprintf(buf + pos, bufsz - pos, "bssid = %pM\n",\r\ncmd->bssid);\r\npos += scnprintf(buf + pos, bufsz - pos, "min_delta_ftm = %d\n",\r\ncmd->min_delta_ftm);\r\npos += scnprintf(buf + pos, bufsz - pos, "num_of_burst_exp = %d\n",\r\ncmd->num_of_burst_exp);\r\npos += scnprintf(buf + pos, bufsz - pos, "rate = %d\n", cmd->rate);\r\npos += scnprintf(buf + pos, bufsz - pos, "abort_responder = %d\n",\r\ncmd->abort_responder);\r\npos += scnprintf(buf + pos, bufsz - pos, "get_ch_est = %d\n",\r\ncmd->get_ch_est);\r\npos += scnprintf(buf + pos, bufsz - pos, "recv_sta_req_params = %d\n",\r\ncmd->recv_sta_req_params);\r\npos += scnprintf(buf + pos, bufsz - pos, "ftm_per_burst = %d\n",\r\ncmd->ftm_per_burst);\r\npos += scnprintf(buf + pos, bufsz - pos, "ftm_resp_ts_avail = %d\n",\r\ncmd->ftm_resp_ts_avail);\r\npos += scnprintf(buf + pos, bufsz - pos, "asap_mode = %d\n",\r\ncmd->asap_mode);\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"tsf_timer_offset_msecs = %d\n",\r\nle16_to_cpu(cmd->tsf_timer_offset_msecs));\r\npos += scnprintf(buf + pos, bufsz - pos, "toa_offset = %d\n",\r\nle16_to_cpu(cmd->toa_offset));\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_request_write(struct ieee80211_vif *vif,\r\nchar *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 value;\r\nint ret = 0;\r\nchar *data;\r\nmutex_lock(&mvm->mutex);\r\ndata = iwl_dbgfs_is_match("request_id=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.request_id = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("initiator=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.initiator = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("one_sided_los_disable=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.one_sided_los_disable = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("req_timeout=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.req_timeout = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("report_policy=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.report_policy = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("macaddr_random=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.macaddr_random = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("num_of_ap=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req.num_of_ap = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("macaddr_template=", buf);\r\nif (data) {\r\nu8 mac[ETH_ALEN];\r\nif (!mac_pton(data, mac)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(mvm->tof_data.range_req.macaddr_template, mac, ETH_ALEN);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("macaddr_mask=", buf);\r\nif (data) {\r\nu8 mac[ETH_ALEN];\r\nif (!mac_pton(data, mac)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(mvm->tof_data.range_req.macaddr_mask, mac, ETH_ALEN);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ap=", buf);\r\nif (data) {\r\nstruct iwl_tof_range_req_ap_entry ap = {};\r\nint size = sizeof(struct iwl_tof_range_req_ap_entry);\r\nu16 burst_period;\r\nu8 *mac = ap.bssid;\r\nunsigned int i;\r\nif (sscanf(data, "%u %hhd %hhd %hhd"\r\n"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx"\r\n"%hhd %hhd %hd"\r\n"%hhd %hhd %d"\r\n"%hhx %hhd %hhd %hhd",\r\n&i, &ap.channel_num, &ap.bandwidth,\r\n&ap.ctrl_ch_position,\r\nmac, mac + 1, mac + 2, mac + 3, mac + 4, mac + 5,\r\n&ap.measure_type, &ap.num_of_bursts,\r\n&burst_period,\r\n&ap.samples_per_burst, &ap.retries_per_sample,\r\n&ap.tsf_delta, &ap.location_req, &ap.asap_mode,\r\n&ap.enable_dyn_ack, &ap.rssi) != 20) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (i >= IWL_MVM_TOF_MAX_APS) {\r\nIWL_ERR(mvm, "Invalid AP index %d\n", i);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nap.burst_period = cpu_to_le16(burst_period);\r\nmemcpy(&mvm->tof_data.range_req.ap[i], &ap, size);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("send_range_request=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value)\r\nret = iwl_mvm_tof_range_request_cmd(mvm, vif);\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_request_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[512];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_tof_range_req_cmd *cmd;\r\nint i;\r\ncmd = &mvm->tof_data.range_req;\r\nmutex_lock(&mvm->mutex);\r\npos += scnprintf(buf + pos, bufsz - pos, "request_id= %d\n",\r\ncmd->request_id);\r\npos += scnprintf(buf + pos, bufsz - pos, "initiator= %d\n",\r\ncmd->initiator);\r\npos += scnprintf(buf + pos, bufsz - pos, "one_sided_los_disable = %d\n",\r\ncmd->one_sided_los_disable);\r\npos += scnprintf(buf + pos, bufsz - pos, "req_timeout= %d\n",\r\ncmd->req_timeout);\r\npos += scnprintf(buf + pos, bufsz - pos, "report_policy= %d\n",\r\ncmd->report_policy);\r\npos += scnprintf(buf + pos, bufsz - pos, "macaddr_random= %d\n",\r\ncmd->macaddr_random);\r\npos += scnprintf(buf + pos, bufsz - pos, "macaddr_template= %pM\n",\r\ncmd->macaddr_template);\r\npos += scnprintf(buf + pos, bufsz - pos, "macaddr_mask= %pM\n",\r\ncmd->macaddr_mask);\r\npos += scnprintf(buf + pos, bufsz - pos, "num_of_ap= %d\n",\r\ncmd->num_of_ap);\r\nfor (i = 0; i < cmd->num_of_ap; i++) {\r\nstruct iwl_tof_range_req_ap_entry *ap = &cmd->ap[i];\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"ap %.2d: channel_num=%hhd bw=%hhd"\r\n" control=%hhd bssid=%pM type=%hhd"\r\n" num_of_bursts=%hhd burst_period=%hd ftm=%hhd"\r\n" retries=%hhd tsf_delta=%d"\r\n" tsf_delta_direction=%hhd location_req=0x%hhx "\r\n" asap=%hhd enable=%hhd rssi=%hhd\n",\r\ni, ap->channel_num, ap->bandwidth,\r\nap->ctrl_ch_position, ap->bssid,\r\nap->measure_type, ap->num_of_bursts,\r\nap->burst_period, ap->samples_per_burst,\r\nap->retries_per_sample, ap->tsf_delta,\r\nap->tsf_delta_direction,\r\nap->location_req, ap->asap_mode,\r\nap->enable_dyn_ack, ap->rssi);\r\n}\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_req_ext_write(struct ieee80211_vif *vif,\r\nchar *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 value;\r\nint ret = 0;\r\nchar *data;\r\nmutex_lock(&mvm->mutex);\r\ndata = iwl_dbgfs_is_match("tsf_timer_offset_msec=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req_ext.tsf_timer_offset_msec =\r\ncpu_to_le16(value);\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("min_delta_ftm=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req_ext.min_delta_ftm = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ftm_format_and_bw20M=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req_ext.ftm_format_and_bw20M =\r\nvalue;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ftm_format_and_bw40M=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req_ext.ftm_format_and_bw40M =\r\nvalue;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("ftm_format_and_bw80M=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.range_req_ext.ftm_format_and_bw80M =\r\nvalue;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("send_range_req_ext=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value)\r\nret = iwl_mvm_tof_range_request_ext_cmd(mvm, vif);\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_req_ext_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[256];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nstruct iwl_tof_range_req_ext_cmd *cmd;\r\ncmd = &mvm->tof_data.range_req_ext;\r\nmutex_lock(&mvm->mutex);\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"tsf_timer_offset_msec = %hd\n",\r\ncmd->tsf_timer_offset_msec);\r\npos += scnprintf(buf + pos, bufsz - pos, "min_delta_ftm = %hhd\n",\r\ncmd->min_delta_ftm);\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"ftm_format_and_bw20M = %hhd\n",\r\ncmd->ftm_format_and_bw20M);\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"ftm_format_and_bw40M = %hhd\n",\r\ncmd->ftm_format_and_bw40M);\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"ftm_format_and_bw80M = %hhd\n",\r\ncmd->ftm_format_and_bw80M);\r\nmutex_unlock(&mvm->mutex);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_abort_write(struct ieee80211_vif *vif,\r\nchar *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu32 value;\r\nint abort_id, ret = 0;\r\nchar *data;\r\nmutex_lock(&mvm->mutex);\r\ndata = iwl_dbgfs_is_match("abort_id=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0)\r\nmvm->tof_data.last_abort_id = value;\r\ngoto out;\r\n}\r\ndata = iwl_dbgfs_is_match("send_range_abort=", buf);\r\nif (data) {\r\nret = kstrtou32(data, 10, &value);\r\nif (ret == 0 && value) {\r\nabort_id = mvm->tof_data.last_abort_id;\r\nret = iwl_mvm_tof_range_abort_cmd(mvm, abort_id);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_abort_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar buf[32];\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(buf);\r\nint last_abort_id;\r\nmutex_lock(&mvm->mutex);\r\nlast_abort_id = mvm->tof_data.last_abort_id;\r\nmutex_unlock(&mvm->mutex);\r\npos += scnprintf(buf + pos, bufsz - pos, "last_abort_id = %d\n",\r\nlast_abort_id);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\n}\r\nstatic ssize_t iwl_dbgfs_tof_range_response_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nchar *buf;\r\nint pos = 0;\r\nconst size_t bufsz = sizeof(struct iwl_tof_range_rsp_ntfy) + 256;\r\nstruct iwl_tof_range_rsp_ntfy *cmd;\r\nint i, ret;\r\nbuf = kzalloc(bufsz, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmutex_lock(&mvm->mutex);\r\ncmd = &mvm->tof_data.range_resp;\r\npos += scnprintf(buf + pos, bufsz - pos, "request_id = %d\n",\r\ncmd->request_id);\r\npos += scnprintf(buf + pos, bufsz - pos, "status = %d\n",\r\ncmd->request_status);\r\npos += scnprintf(buf + pos, bufsz - pos, "last_in_batch = %d\n",\r\ncmd->last_in_batch);\r\npos += scnprintf(buf + pos, bufsz - pos, "num_of_aps = %d\n",\r\ncmd->num_of_aps);\r\nfor (i = 0; i < cmd->num_of_aps; i++) {\r\nstruct iwl_tof_range_rsp_ap_entry_ntfy *ap = &cmd->ap[i];\r\npos += scnprintf(buf + pos, bufsz - pos,\r\n"ap %.2d: bssid=%pM status=%hhd bw=%hhd"\r\n" rtt=%d rtt_var=%d rtt_spread=%d"\r\n" rssi=%hhd rssi_spread=%hhd"\r\n" range=%d range_var=%d"\r\n" time_stamp=%d\n",\r\ni, ap->bssid, ap->measure_status,\r\nap->measure_bw,\r\nap->rtt, ap->rtt_variance, ap->rtt_spread,\r\nap->rssi, ap->rssi_spread, ap->range,\r\nap->range_variance, ap->timestamp);\r\n}\r\nmutex_unlock(&mvm->mutex);\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t iwl_dbgfs_low_latency_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nbool prev;\r\nu8 value;\r\nint ret;\r\nret = kstrtou8(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&mvm->mutex);\r\nprev = iwl_mvm_vif_low_latency(mvmvif);\r\nmvmvif->low_latency_dbgfs = value;\r\niwl_mvm_update_low_latency(mvm, vif, prev);\r\nmutex_unlock(&mvm->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t iwl_dbgfs_low_latency_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[30] = {};\r\nint len;\r\nlen = snprintf(buf, sizeof(buf) - 1,\r\n"traffic=%d\ndbgfs=%d\nvcmd=%d\n",\r\nmvmvif->low_latency_traffic,\r\nmvmvif->low_latency_dbgfs,\r\nmvmvif->low_latency_vcmd);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t iwl_dbgfs_uapsd_misbehaving_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[20];\r\nint len;\r\nlen = sprintf(buf, "%pM\n", mvmvif->uapsd_misbehaving_bssid);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t iwl_dbgfs_uapsd_misbehaving_write(struct ieee80211_vif *vif,\r\nchar *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nbool ret;\r\nmutex_lock(&mvm->mutex);\r\nret = mac_pton(buf, mvmvif->uapsd_misbehaving_bssid);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ? count : -EINVAL;\r\n}\r\nstatic ssize_t iwl_dbgfs_rx_phyinfo_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nstruct iwl_mvm_phy_ctxt *phy_ctxt;\r\nu16 value;\r\nint ret;\r\nret = kstrtou16(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&mvm->mutex);\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(vif->chanctx_conf);\r\nif (!chanctx_conf) {\r\nrcu_read_unlock();\r\nmutex_unlock(&mvm->mutex);\r\nreturn -EINVAL;\r\n}\r\nphy_ctxt = &mvm->phy_ctxts[*(u16 *)chanctx_conf->drv_priv];\r\nrcu_read_unlock();\r\nmvm->dbgfs_rx_phyinfo = value;\r\nret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &chanctx_conf->min_def,\r\nchanctx_conf->rx_chains_static,\r\nchanctx_conf->rx_chains_dynamic);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_rx_phyinfo_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[8];\r\nsnprintf(buf, sizeof(buf), "0x%04x\n", mvmvif->mvm->dbgfs_rx_phyinfo);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, sizeof(buf));\r\n}\r\nstatic void iwl_dbgfs_quota_check(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nint *ret = data;\r\nif (mvmvif->dbgfs_quota_min)\r\n*ret = -EINVAL;\r\n}\r\nstatic ssize_t iwl_dbgfs_quota_min_write(struct ieee80211_vif *vif, char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nu16 value;\r\nint ret;\r\nret = kstrtou16(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > 95)\r\nreturn -EINVAL;\r\nmutex_lock(&mvm->mutex);\r\nmvmvif->dbgfs_quota_min = 0;\r\nieee80211_iterate_interfaces(mvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_dbgfs_quota_check, &ret);\r\nif (ret == 0) {\r\nmvmvif->dbgfs_quota_min = value;\r\niwl_mvm_update_quotas(mvm, false, NULL);\r\n}\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t iwl_dbgfs_quota_min_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ieee80211_vif *vif = file->private_data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[10];\r\nint len;\r\nlen = snprintf(buf, sizeof(buf), "%d\n", mvmvif->dbgfs_quota_min);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic bool iwl_mvm_lqm_notif_wait(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct ieee80211_vif *vif = data;\r\nstruct iwl_mvm *mvm =\r\ncontainer_of(notif_wait, struct iwl_mvm, notif_wait);\r\nstruct iwl_link_qual_msrmnt_notif *report = (void *)pkt->data;\r\nu32 num_of_stations = le32_to_cpu(report->number_of_stations);\r\nint i;\r\nIWL_INFO(mvm, "LQM report:\n");\r\nIWL_INFO(mvm, "\tstatus: %d\n", report->status);\r\nIWL_INFO(mvm, "\tmacID: %d\n", le32_to_cpu(report->mac_id));\r\nIWL_INFO(mvm, "\ttx_frame_dropped: %d\n",\r\nle32_to_cpu(report->tx_frame_dropped));\r\nIWL_INFO(mvm, "\ttime_in_measurement_window: %d us\n",\r\nle32_to_cpu(report->time_in_measurement_window));\r\nIWL_INFO(mvm, "\ttotal_air_time_other_stations: %d\n",\r\nle32_to_cpu(report->total_air_time_other_stations));\r\nIWL_INFO(mvm, "\tchannel_freq: %d\n",\r\nvif->bss_conf.chandef.center_freq1);\r\nIWL_INFO(mvm, "\tchannel_width: %s\n",\r\nchanwidths[vif->bss_conf.chandef.width]);\r\nIWL_INFO(mvm, "\tnumber_of_stations: %d\n", num_of_stations);\r\nfor (i = 0; i < num_of_stations; i++)\r\nIWL_INFO(mvm, "\t\tsta[%d]: %d\n", i,\r\nreport->frequent_stations_air_time[i]);\r\nreturn true;\r\n}\r\nstatic ssize_t iwl_dbgfs_lqm_send_cmd_write(struct ieee80211_vif *vif,\r\nchar *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm *mvm = mvmvif->mvm;\r\nstruct iwl_notification_wait wait_lqm_notif;\r\nstatic u16 lqm_notif[] = {\r\nWIDE_ID(MAC_CONF_GROUP,\r\nLINK_QUALITY_MEASUREMENT_COMPLETE_NOTIF)\r\n};\r\nint err;\r\nu32 duration;\r\nu32 timeout;\r\nif (sscanf(buf, "%d,%d", &duration, &timeout) != 2)\r\nreturn -EINVAL;\r\niwl_init_notification_wait(&mvm->notif_wait, &wait_lqm_notif,\r\nlqm_notif, ARRAY_SIZE(lqm_notif),\r\niwl_mvm_lqm_notif_wait, vif);\r\nmutex_lock(&mvm->mutex);\r\nerr = iwl_mvm_send_lqm_cmd(vif, LQM_CMD_OPERATION_START_MEASUREMENT,\r\nduration, timeout);\r\nmutex_unlock(&mvm->mutex);\r\nif (err) {\r\nIWL_ERR(mvm, "Failed to send lqm cmdf(err=%d)\n", err);\r\niwl_remove_notification(&mvm->notif_wait, &wait_lqm_notif);\r\nreturn err;\r\n}\r\ntimeout = msecs_to_jiffies((timeout * 2) / 1000);\r\nerr = iwl_wait_notification(&mvm->notif_wait, &wait_lqm_notif,\r\ntimeout);\r\nif (err)\r\nIWL_ERR(mvm, "Getting lqm notif timed out\n");\r\nreturn count;\r\n}\r\nvoid iwl_mvm_vif_dbgfs_register(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct dentry *dbgfs_dir = vif->debugfs_dir;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nchar buf[100];\r\nif (!dbgfs_dir || mvmvif->dbgfs_dir)\r\nreturn;\r\nmvmvif->dbgfs_dir = debugfs_create_dir("iwlmvm", dbgfs_dir);\r\nif (!mvmvif->dbgfs_dir) {\r\nIWL_ERR(mvm, "Failed to create debugfs directory under %pd\n",\r\ndbgfs_dir);\r\nreturn;\r\n}\r\nif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM &&\r\n((vif->type == NL80211_IFTYPE_STATION && !vif->p2p) ||\r\n(vif->type == NL80211_IFTYPE_STATION && vif->p2p)))\r\nMVM_DEBUGFS_ADD_FILE_VIF(pm_params, mvmvif->dbgfs_dir, S_IWUSR |\r\nS_IRUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tx_pwr_lmt, mvmvif->dbgfs_dir, S_IRUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(mac_params, mvmvif->dbgfs_dir, S_IRUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(low_latency, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(uapsd_misbehaving, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(rx_phyinfo, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(quota_min, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(lqm_send_cmd, mvmvif->dbgfs_dir, S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(os_device_timediff,\r\nmvmvif->dbgfs_dir, S_IRUSR);\r\nif (vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&\r\nmvmvif == mvm->bf_allowed_vif)\r\nMVM_DEBUGFS_ADD_FILE_VIF(bf_params, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_TOF_SUPPORT) &&\r\n!vif->p2p && (vif->type != NL80211_IFTYPE_P2P_DEVICE)) {\r\nif (IWL_MVM_TOF_IS_RESPONDER && vif->type == NL80211_IFTYPE_AP)\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_responder_params,\r\nmvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_range_request, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_range_req_ext, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_enable, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_range_abort, mvmvif->dbgfs_dir,\r\nS_IRUSR | S_IWUSR);\r\nMVM_DEBUGFS_ADD_FILE_VIF(tof_range_response, mvmvif->dbgfs_dir,\r\nS_IRUSR);\r\n}\r\nsnprintf(buf, 100, "../../../%pd3/%pd",\r\ndbgfs_dir,\r\nmvmvif->dbgfs_dir);\r\nmvmvif->dbgfs_slink = debugfs_create_symlink(dbgfs_dir->d_name.name,\r\nmvm->debugfs_dir, buf);\r\nif (!mvmvif->dbgfs_slink)\r\nIWL_ERR(mvm, "Can't create debugfs symbolic link under %pd\n",\r\ndbgfs_dir);\r\nreturn;\r\nerr:\r\nIWL_ERR(mvm, "Can't create debugfs entity\n");\r\n}\r\nvoid iwl_mvm_vif_dbgfs_clean(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\ndebugfs_remove(mvmvif->dbgfs_slink);\r\nmvmvif->dbgfs_slink = NULL;\r\ndebugfs_remove_recursive(mvmvif->dbgfs_dir);\r\nmvmvif->dbgfs_dir = NULL;\r\n}
