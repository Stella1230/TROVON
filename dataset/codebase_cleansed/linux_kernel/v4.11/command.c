struct command *ibmasm_new_command(struct service_processor *sp, size_t buffer_size)\r\n{\r\nstruct command *cmd;\r\nif (buffer_size > IBMASM_CMD_MAX_BUFFER_SIZE)\r\nreturn NULL;\r\ncmd = kzalloc(sizeof(struct command), GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn NULL;\r\ncmd->buffer = kzalloc(buffer_size, GFP_KERNEL);\r\nif (cmd->buffer == NULL) {\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\ncmd->buffer_size = buffer_size;\r\nkref_init(&cmd->kref);\r\ncmd->lock = &sp->lock;\r\ncmd->status = IBMASM_CMD_PENDING;\r\ninit_waitqueue_head(&cmd->wait);\r\nINIT_LIST_HEAD(&cmd->queue_node);\r\natomic_inc(&command_count);\r\ndbg("command count: %d\n", atomic_read(&command_count));\r\nreturn cmd;\r\n}\r\nvoid ibmasm_free_command(struct kref *kref)\r\n{\r\nstruct command *cmd = to_command(kref);\r\nlist_del(&cmd->queue_node);\r\natomic_dec(&command_count);\r\ndbg("command count: %d\n", atomic_read(&command_count));\r\nkfree(cmd->buffer);\r\nkfree(cmd);\r\n}\r\nstatic void enqueue_command(struct service_processor *sp, struct command *cmd)\r\n{\r\nlist_add_tail(&cmd->queue_node, &sp->command_queue);\r\n}\r\nstatic struct command *dequeue_command(struct service_processor *sp)\r\n{\r\nstruct command *cmd;\r\nstruct list_head *next;\r\nif (list_empty(&sp->command_queue))\r\nreturn NULL;\r\nnext = sp->command_queue.next;\r\nlist_del_init(next);\r\ncmd = list_entry(next, struct command, queue_node);\r\nreturn cmd;\r\n}\r\nstatic inline void do_exec_command(struct service_processor *sp)\r\n{\r\nchar tsbuf[32];\r\ndbg("%s:%d at %s\n", __func__, __LINE__, get_timestamp(tsbuf));\r\nif (ibmasm_send_i2o_message(sp)) {\r\nsp->current_command->status = IBMASM_CMD_FAILED;\r\nwake_up(&sp->current_command->wait);\r\ncommand_put(sp->current_command);\r\nexec_next_command(sp);\r\n}\r\n}\r\nvoid ibmasm_exec_command(struct service_processor *sp, struct command *cmd)\r\n{\r\nunsigned long flags;\r\nchar tsbuf[32];\r\ndbg("%s:%d at %s\n", __func__, __LINE__, get_timestamp(tsbuf));\r\nspin_lock_irqsave(&sp->lock, flags);\r\nif (!sp->current_command) {\r\nsp->current_command = cmd;\r\ncommand_get(sp->current_command);\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\ndo_exec_command(sp);\r\n} else {\r\nenqueue_command(sp, cmd);\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\n}\r\n}\r\nstatic void exec_next_command(struct service_processor *sp)\r\n{\r\nunsigned long flags;\r\nchar tsbuf[32];\r\ndbg("%s:%d at %s\n", __func__, __LINE__, get_timestamp(tsbuf));\r\nspin_lock_irqsave(&sp->lock, flags);\r\nsp->current_command = dequeue_command(sp);\r\nif (sp->current_command) {\r\ncommand_get(sp->current_command);\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\ndo_exec_command(sp);\r\n} else {\r\nspin_unlock_irqrestore(&sp->lock, flags);\r\n}\r\n}\r\nvoid ibmasm_wait_for_response(struct command *cmd, int timeout)\r\n{\r\nwait_event_interruptible_timeout(cmd->wait,\r\ncmd->status == IBMASM_CMD_COMPLETE ||\r\ncmd->status == IBMASM_CMD_FAILED,\r\ntimeout * HZ);\r\n}\r\nvoid ibmasm_receive_command_response(struct service_processor *sp, void *response, size_t size)\r\n{\r\nstruct command *cmd = sp->current_command;\r\nif (!sp->current_command)\r\nreturn;\r\nmemcpy_fromio(cmd->buffer, response, min(size, cmd->buffer_size));\r\ncmd->status = IBMASM_CMD_COMPLETE;\r\nwake_up(&sp->current_command->wait);\r\ncommand_put(sp->current_command);\r\nexec_next_command(sp);\r\n}
