static int ipip_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nstruct ip_tunnel *t;\r\nint err;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nerr = -ENOENT;\r\nt = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->daddr, iph->saddr, 0);\r\nif (!t)\r\ngoto out;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nt->parms.link, 0, iph->protocol, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (type == ICMP_REDIRECT) {\r\nipv4_redirect(skb, dev_net(skb->dev), t->parms.link, 0,\r\niph->protocol, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (t->parms.iph.daddr == 0)\r\ngoto out;\r\nerr = 0;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\ngoto out;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipip_tunnel_rcv(struct sk_buff *skb, u8 ipproto)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nstruct metadata_dst *tun_dst = NULL;\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph;\r\niph = ip_hdr(skb);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\r\niph->saddr, iph->daddr, 0);\r\nif (tunnel) {\r\nconst struct tnl_ptk_info *tpi;\r\nif (tunnel->parms.iph.protocol != ipproto &&\r\ntunnel->parms.iph.protocol != 0)\r\ngoto drop;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto drop;\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nif (ipproto == IPPROTO_MPLS)\r\ntpi = &mplsip_tpi;\r\nelse\r\n#endif\r\ntpi = &ipip_tpi;\r\nif (iptunnel_pull_header(skb, 0, tpi->proto, false))\r\ngoto drop;\r\nif (tunnel->collect_md) {\r\ntun_dst = ip_tun_rx_dst(skb, 0, 0, 0);\r\nif (!tun_dst)\r\nreturn 0;\r\n}\r\nreturn ip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\r\n}\r\nreturn -1;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ipip_rcv(struct sk_buff *skb)\r\n{\r\nreturn ipip_tunnel_rcv(skb, IPPROTO_IPIP);\r\n}\r\nstatic int mplsip_rcv(struct sk_buff *skb)\r\n{\r\nreturn ipip_tunnel_rcv(skb, IPPROTO_MPLS);\r\n}\r\nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tiph = &tunnel->parms.iph;\r\nu8 ipproto;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nipproto = IPPROTO_IPIP;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_MPLS)\r\ncase htons(ETH_P_MPLS_UC):\r\nipproto = IPPROTO_MPLS;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto tx_error;\r\n}\r\nif (tiph->protocol != ipproto && tiph->protocol != 0)\r\ngoto tx_error;\r\nif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4))\r\ngoto tx_error;\r\nskb_set_inner_ipproto(skb, ipproto);\r\nif (tunnel->collect_md)\r\nip_md_tunnel_xmit(skb, dev, ipproto);\r\nelse\r\nip_tunnel_xmit(skb, dev, tiph, ipproto);\r\nreturn NETDEV_TX_OK;\r\ntx_error:\r\nkfree_skb(skb);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic bool ipip_tunnel_ioctl_verify_protocol(u8 ipproto)\r\n{\r\nswitch (ipproto) {\r\ncase 0:\r\ncase IPPROTO_IPIP:\r\n#if IS_ENABLED(CONFIG_MPLS)\r\ncase IPPROTO_MPLS:\r\n#endif\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nipip_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nreturn -EFAULT;\r\nif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\r\nif (p.iph.version != 4 ||\r\n!ipip_tunnel_ioctl_verify_protocol(p.iph.protocol) ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\r\nreturn -EINVAL;\r\n}\r\np.i_key = p.o_key = 0;\r\np.i_flags = p.o_flags = 0;\r\nerr = ip_tunnel_ioctl(dev, &p, cmd);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void ipip_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ipip_netdev_ops;\r\ndev->type = ARPHRD_TUNNEL;\r\ndev->flags = IFF_NOARP;\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_LLTX;\r\nnetif_keep_dst(dev);\r\ndev->features |= IPIP_FEATURES;\r\ndev->hw_features |= IPIP_FEATURES;\r\nip_tunnel_setup(dev, ipip_net_id);\r\n}\r\nstatic int ipip_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\r\ntunnel->tun_hlen = 0;\r\ntunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen;\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic int ipip_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nu8 proto;\r\nif (!data || !data[IFLA_IPTUN_PROTO])\r\nreturn 0;\r\nproto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\r\nif (proto != IPPROTO_IPIP && proto != IPPROTO_MPLS && proto != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ipip_netlink_parms(struct nlattr *data[],\r\nstruct ip_tunnel_parm *parms, bool *collect_md)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.version = 4;\r\nparms->iph.protocol = IPPROTO_IPIP;\r\nparms->iph.ihl = 5;\r\n*collect_md = false;\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_IPTUN_LINK])\r\nparms->link = nla_get_u32(data[IFLA_IPTUN_LINK]);\r\nif (data[IFLA_IPTUN_LOCAL])\r\nparms->iph.saddr = nla_get_in_addr(data[IFLA_IPTUN_LOCAL]);\r\nif (data[IFLA_IPTUN_REMOTE])\r\nparms->iph.daddr = nla_get_in_addr(data[IFLA_IPTUN_REMOTE]);\r\nif (data[IFLA_IPTUN_TTL]) {\r\nparms->iph.ttl = nla_get_u8(data[IFLA_IPTUN_TTL]);\r\nif (parms->iph.ttl)\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nif (data[IFLA_IPTUN_TOS])\r\nparms->iph.tos = nla_get_u8(data[IFLA_IPTUN_TOS]);\r\nif (data[IFLA_IPTUN_PROTO])\r\nparms->iph.protocol = nla_get_u8(data[IFLA_IPTUN_PROTO]);\r\nif (!data[IFLA_IPTUN_PMTUDISC] || nla_get_u8(data[IFLA_IPTUN_PMTUDISC]))\r\nparms->iph.frag_off = htons(IP_DF);\r\nif (data[IFLA_IPTUN_COLLECT_METADATA])\r\n*collect_md = true;\r\n}\r\nstatic bool ipip_netlink_encap_parms(struct nlattr *data[],\r\nstruct ip_tunnel_encap *ipencap)\r\n{\r\nbool ret = false;\r\nmemset(ipencap, 0, sizeof(*ipencap));\r\nif (!data)\r\nreturn ret;\r\nif (data[IFLA_IPTUN_ENCAP_TYPE]) {\r\nret = true;\r\nipencap->type = nla_get_u16(data[IFLA_IPTUN_ENCAP_TYPE]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_FLAGS]) {\r\nret = true;\r\nipencap->flags = nla_get_u16(data[IFLA_IPTUN_ENCAP_FLAGS]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_SPORT]) {\r\nret = true;\r\nipencap->sport = nla_get_be16(data[IFLA_IPTUN_ENCAP_SPORT]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_DPORT]) {\r\nret = true;\r\nipencap->dport = nla_get_be16(data[IFLA_IPTUN_ENCAP_DPORT]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipip_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_encap ipencap;\r\nif (ipip_netlink_encap_parms(data, &ipencap)) {\r\nint err = ip_tunnel_encap_setup(t, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nipip_netlink_parms(data, &p, &t->collect_md);\r\nreturn ip_tunnel_newlink(dev, tb, &p);\r\n}\r\nstatic int ipip_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_encap ipencap;\r\nbool collect_md;\r\nif (ipip_netlink_encap_parms(data, &ipencap)) {\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nint err = ip_tunnel_encap_setup(t, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nipip_netlink_parms(data, &p, &collect_md);\r\nif (collect_md)\r\nreturn -EINVAL;\r\nif (((dev->flags & IFF_POINTOPOINT) && !p.iph.daddr) ||\r\n(!(dev->flags & IFF_POINTOPOINT) && p.iph.daddr))\r\nreturn -EINVAL;\r\nreturn ip_tunnel_changelink(dev, tb, &p);\r\n}\r\nstatic size_t ipip_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(0) +\r\n0;\r\n}\r\nstatic int ipip_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct ip_tunnel_parm *parm = &tunnel->parms;\r\nif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\r\nnla_put_in_addr(skb, IFLA_IPTUN_LOCAL, parm->iph.saddr) ||\r\nnla_put_in_addr(skb, IFLA_IPTUN_REMOTE, parm->iph.daddr) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TTL, parm->iph.ttl) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TOS, parm->iph.tos) ||\r\nnla_put_u8(skb, IFLA_IPTUN_PROTO, parm->iph.protocol) ||\r\nnla_put_u8(skb, IFLA_IPTUN_PMTUDISC,\r\n!!(parm->iph.frag_off & htons(IP_DF))))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE,\r\ntunnel->encap.type) ||\r\nnla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT,\r\ntunnel->encap.sport) ||\r\nnla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT,\r\ntunnel->encap.dport) ||\r\nnla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS,\r\ntunnel->encap.flags))\r\ngoto nla_put_failure;\r\nif (tunnel->collect_md)\r\nif (nla_put_flag(skb, IFLA_IPTUN_COLLECT_METADATA))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int __net_init ipip_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, ipip_net_id, &ipip_link_ops, "tunl0");\r\n}\r\nstatic void __net_exit ipip_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\r\nip_tunnel_delete_net(itn, &ipip_link_ops);\r\n}\r\nstatic int __init ipip_init(void)\r\n{\r\nint err;\r\npr_info("ipip: IPv4 and MPLS over IPv4 tunneling driver\n");\r\nerr = register_pernet_device(&ipip_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\r\nif (err < 0) {\r\npr_info("%s: can't register tunnel\n", __func__);\r\ngoto xfrm_tunnel_ipip_failed;\r\n}\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nerr = xfrm4_tunnel_register(&mplsip_handler, AF_MPLS);\r\nif (err < 0) {\r\npr_info("%s: can't register tunnel\n", __func__);\r\ngoto xfrm_tunnel_mplsip_failed;\r\n}\r\n#endif\r\nerr = rtnl_link_register(&ipip_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nout:\r\nreturn err;\r\nrtnl_link_failed:\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nxfrm4_tunnel_deregister(&mplsip_handler, AF_INET);\r\nxfrm_tunnel_mplsip_failed:\r\n#endif\r\nxfrm4_tunnel_deregister(&ipip_handler, AF_INET);\r\nxfrm_tunnel_ipip_failed:\r\nunregister_pernet_device(&ipip_net_ops);\r\ngoto out;\r\n}\r\nstatic void __exit ipip_fini(void)\r\n{\r\nrtnl_link_unregister(&ipip_link_ops);\r\nif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\r\npr_info("%s: can't deregister tunnel\n", __func__);\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nif (xfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS))\r\npr_info("%s: can't deregister tunnel\n", __func__);\r\n#endif\r\nunregister_pernet_device(&ipip_net_ops);\r\n}
