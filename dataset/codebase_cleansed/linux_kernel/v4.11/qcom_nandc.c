static inline struct qcom_nand_host *to_qcom_nand_host(struct nand_chip *chip)\r\n{\r\nreturn container_of(chip, struct qcom_nand_host, chip);\r\n}\r\nstatic inline struct qcom_nand_controller *\r\nget_qcom_nand_controller(struct nand_chip *chip)\r\n{\r\nreturn container_of(chip->controller, struct qcom_nand_controller,\r\ncontroller);\r\n}\r\nstatic inline u32 nandc_read(struct qcom_nand_controller *nandc, int offset)\r\n{\r\nreturn ioread32(nandc->base + offset);\r\n}\r\nstatic inline void nandc_write(struct qcom_nand_controller *nandc, int offset,\r\nu32 val)\r\n{\r\niowrite32(val, nandc->base + offset);\r\n}\r\nstatic __le32 *offset_to_nandc_reg(struct nandc_regs *regs, int offset)\r\n{\r\nswitch (offset) {\r\ncase NAND_FLASH_CMD:\r\nreturn &regs->cmd;\r\ncase NAND_ADDR0:\r\nreturn &regs->addr0;\r\ncase NAND_ADDR1:\r\nreturn &regs->addr1;\r\ncase NAND_FLASH_CHIP_SELECT:\r\nreturn &regs->chip_sel;\r\ncase NAND_EXEC_CMD:\r\nreturn &regs->exec;\r\ncase NAND_FLASH_STATUS:\r\nreturn &regs->clrflashstatus;\r\ncase NAND_DEV0_CFG0:\r\nreturn &regs->cfg0;\r\ncase NAND_DEV0_CFG1:\r\nreturn &regs->cfg1;\r\ncase NAND_DEV0_ECC_CFG:\r\nreturn &regs->ecc_bch_cfg;\r\ncase NAND_READ_STATUS:\r\nreturn &regs->clrreadstatus;\r\ncase NAND_DEV_CMD1:\r\nreturn &regs->cmd1;\r\ncase NAND_DEV_CMD1_RESTORE:\r\nreturn &regs->orig_cmd1;\r\ncase NAND_DEV_CMD_VLD:\r\nreturn &regs->vld;\r\ncase NAND_DEV_CMD_VLD_RESTORE:\r\nreturn &regs->orig_vld;\r\ncase NAND_EBI2_ECC_BUF_CFG:\r\nreturn &regs->ecc_buf_cfg;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void nandc_set_reg(struct qcom_nand_controller *nandc, int offset,\r\nu32 val)\r\n{\r\nstruct nandc_regs *regs = nandc->regs;\r\n__le32 *reg;\r\nreg = offset_to_nandc_reg(regs, offset);\r\nif (reg)\r\n*reg = cpu_to_le32(val);\r\n}\r\nstatic void set_address(struct qcom_nand_host *host, u16 column, int page)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nif (chip->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nnandc_set_reg(nandc, NAND_ADDR0, page << 16 | column);\r\nnandc_set_reg(nandc, NAND_ADDR1, page >> 16 & 0xff);\r\n}\r\nstatic void update_rw_regs(struct qcom_nand_host *host, int num_cw, bool read)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nu32 cmd, cfg0, cfg1, ecc_bch_cfg;\r\nif (read) {\r\nif (host->use_ecc)\r\ncmd = PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE;\r\nelse\r\ncmd = PAGE_READ | PAGE_ACC | LAST_PAGE;\r\n} else {\r\ncmd = PROGRAM_PAGE | PAGE_ACC | LAST_PAGE;\r\n}\r\nif (host->use_ecc) {\r\ncfg0 = (host->cfg0 & ~(7U << CW_PER_PAGE)) |\r\n(num_cw - 1) << CW_PER_PAGE;\r\ncfg1 = host->cfg1;\r\necc_bch_cfg = host->ecc_bch_cfg;\r\n} else {\r\ncfg0 = (host->cfg0_raw & ~(7U << CW_PER_PAGE)) |\r\n(num_cw - 1) << CW_PER_PAGE;\r\ncfg1 = host->cfg1_raw;\r\necc_bch_cfg = 1 << ECC_CFG_ECC_DISABLE;\r\n}\r\nnandc_set_reg(nandc, NAND_FLASH_CMD, cmd);\r\nnandc_set_reg(nandc, NAND_DEV0_CFG0, cfg0);\r\nnandc_set_reg(nandc, NAND_DEV0_CFG1, cfg1);\r\nnandc_set_reg(nandc, NAND_DEV0_ECC_CFG, ecc_bch_cfg);\r\nnandc_set_reg(nandc, NAND_EBI2_ECC_BUF_CFG, host->ecc_buf_cfg);\r\nnandc_set_reg(nandc, NAND_FLASH_STATUS, host->clrflashstatus);\r\nnandc_set_reg(nandc, NAND_READ_STATUS, host->clrreadstatus);\r\nnandc_set_reg(nandc, NAND_EXEC_CMD, 1);\r\n}\r\nstatic int prep_dma_desc(struct qcom_nand_controller *nandc, bool read,\r\nint reg_off, const void *vaddr, int size,\r\nbool flow_control)\r\n{\r\nstruct desc_info *desc;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nstruct scatterlist *sgl;\r\nstruct dma_slave_config slave_conf;\r\nenum dma_transfer_direction dir_eng;\r\nint ret;\r\ndesc = kzalloc(sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\nsgl = &desc->sgl;\r\nsg_init_one(sgl, vaddr, size);\r\nif (read) {\r\ndir_eng = DMA_DEV_TO_MEM;\r\ndesc->dir = DMA_FROM_DEVICE;\r\n} else {\r\ndir_eng = DMA_MEM_TO_DEV;\r\ndesc->dir = DMA_TO_DEVICE;\r\n}\r\nret = dma_map_sg(nandc->dev, sgl, 1, desc->dir);\r\nif (ret == 0) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmemset(&slave_conf, 0x00, sizeof(slave_conf));\r\nslave_conf.device_fc = flow_control;\r\nif (read) {\r\nslave_conf.src_maxburst = 16;\r\nslave_conf.src_addr = nandc->base_dma + reg_off;\r\nslave_conf.slave_id = nandc->data_crci;\r\n} else {\r\nslave_conf.dst_maxburst = 16;\r\nslave_conf.dst_addr = nandc->base_dma + reg_off;\r\nslave_conf.slave_id = nandc->cmd_crci;\r\n}\r\nret = dmaengine_slave_config(nandc->chan, &slave_conf);\r\nif (ret) {\r\ndev_err(nandc->dev, "failed to configure dma channel\n");\r\ngoto err;\r\n}\r\ndma_desc = dmaengine_prep_slave_sg(nandc->chan, sgl, 1, dir_eng, 0);\r\nif (!dma_desc) {\r\ndev_err(nandc->dev, "failed to prepare desc\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndesc->dma_desc = dma_desc;\r\nlist_add_tail(&desc->node, &nandc->desc_list);\r\nreturn 0;\r\nerr:\r\nkfree(desc);\r\nreturn ret;\r\n}\r\nstatic int read_reg_dma(struct qcom_nand_controller *nandc, int first,\r\nint num_regs)\r\n{\r\nbool flow_control = false;\r\nvoid *vaddr;\r\nint size;\r\nif (first == NAND_READ_ID || first == NAND_FLASH_STATUS)\r\nflow_control = true;\r\nsize = num_regs * sizeof(u32);\r\nvaddr = nandc->reg_read_buf + nandc->reg_read_pos;\r\nnandc->reg_read_pos += num_regs;\r\nreturn prep_dma_desc(nandc, true, first, vaddr, size, flow_control);\r\n}\r\nstatic int write_reg_dma(struct qcom_nand_controller *nandc, int first,\r\nint num_regs)\r\n{\r\nbool flow_control = false;\r\nstruct nandc_regs *regs = nandc->regs;\r\nvoid *vaddr;\r\nint size;\r\nvaddr = offset_to_nandc_reg(regs, first);\r\nif (first == NAND_FLASH_CMD)\r\nflow_control = true;\r\nif (first == NAND_DEV_CMD1_RESTORE)\r\nfirst = NAND_DEV_CMD1;\r\nif (first == NAND_DEV_CMD_VLD_RESTORE)\r\nfirst = NAND_DEV_CMD_VLD;\r\nsize = num_regs * sizeof(u32);\r\nreturn prep_dma_desc(nandc, false, first, vaddr, size, flow_control);\r\n}\r\nstatic int read_data_dma(struct qcom_nand_controller *nandc, int reg_off,\r\nconst u8 *vaddr, int size)\r\n{\r\nreturn prep_dma_desc(nandc, true, reg_off, vaddr, size, false);\r\n}\r\nstatic int write_data_dma(struct qcom_nand_controller *nandc, int reg_off,\r\nconst u8 *vaddr, int size)\r\n{\r\nreturn prep_dma_desc(nandc, false, reg_off, vaddr, size, false);\r\n}\r\nstatic void config_cw_read(struct qcom_nand_controller *nandc)\r\n{\r\nwrite_reg_dma(nandc, NAND_FLASH_CMD, 3);\r\nwrite_reg_dma(nandc, NAND_DEV0_CFG0, 3);\r\nwrite_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1);\r\nwrite_reg_dma(nandc, NAND_EXEC_CMD, 1);\r\nread_reg_dma(nandc, NAND_FLASH_STATUS, 2);\r\nread_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1);\r\n}\r\nstatic void config_cw_write_pre(struct qcom_nand_controller *nandc)\r\n{\r\nwrite_reg_dma(nandc, NAND_FLASH_CMD, 3);\r\nwrite_reg_dma(nandc, NAND_DEV0_CFG0, 3);\r\nwrite_reg_dma(nandc, NAND_EBI2_ECC_BUF_CFG, 1);\r\n}\r\nstatic void config_cw_write_post(struct qcom_nand_controller *nandc)\r\n{\r\nwrite_reg_dma(nandc, NAND_EXEC_CMD, 1);\r\nread_reg_dma(nandc, NAND_FLASH_STATUS, 1);\r\nwrite_reg_dma(nandc, NAND_FLASH_STATUS, 1);\r\nwrite_reg_dma(nandc, NAND_READ_STATUS, 1);\r\n}\r\nstatic int nandc_param(struct qcom_nand_host *host)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nnandc_set_reg(nandc, NAND_FLASH_CMD, PAGE_READ | PAGE_ACC | LAST_PAGE);\r\nnandc_set_reg(nandc, NAND_ADDR0, 0);\r\nnandc_set_reg(nandc, NAND_ADDR1, 0);\r\nnandc_set_reg(nandc, NAND_DEV0_CFG0, 0 << CW_PER_PAGE\r\n| 512 << UD_SIZE_BYTES\r\n| 5 << NUM_ADDR_CYCLES\r\n| 0 << SPARE_SIZE_BYTES);\r\nnandc_set_reg(nandc, NAND_DEV0_CFG1, 7 << NAND_RECOVERY_CYCLES\r\n| 0 << CS_ACTIVE_BSY\r\n| 17 << BAD_BLOCK_BYTE_NUM\r\n| 1 << BAD_BLOCK_IN_SPARE_AREA\r\n| 2 << WR_RD_BSY_GAP\r\n| 0 << WIDE_FLASH\r\n| 1 << DEV0_CFG1_ECC_DISABLE);\r\nnandc_set_reg(nandc, NAND_EBI2_ECC_BUF_CFG, 1 << ECC_CFG_ECC_DISABLE);\r\nnandc_set_reg(nandc, NAND_DEV_CMD_VLD,\r\n(nandc->vld & ~(1 << READ_START_VLD))\r\n| 0 << READ_START_VLD);\r\nnandc_set_reg(nandc, NAND_DEV_CMD1,\r\n(nandc->cmd1 & ~(0xFF << READ_ADDR))\r\n| NAND_CMD_PARAM << READ_ADDR);\r\nnandc_set_reg(nandc, NAND_EXEC_CMD, 1);\r\nnandc_set_reg(nandc, NAND_DEV_CMD1_RESTORE, nandc->cmd1);\r\nnandc_set_reg(nandc, NAND_DEV_CMD_VLD_RESTORE, nandc->vld);\r\nwrite_reg_dma(nandc, NAND_DEV_CMD_VLD, 1);\r\nwrite_reg_dma(nandc, NAND_DEV_CMD1, 1);\r\nnandc->buf_count = 512;\r\nmemset(nandc->data_buffer, 0xff, nandc->buf_count);\r\nconfig_cw_read(nandc);\r\nread_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,\r\nnandc->buf_count);\r\nwrite_reg_dma(nandc, NAND_DEV_CMD1_RESTORE, 1);\r\nwrite_reg_dma(nandc, NAND_DEV_CMD_VLD_RESTORE, 1);\r\nreturn 0;\r\n}\r\nstatic int erase_block(struct qcom_nand_host *host, int page_addr)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nnandc_set_reg(nandc, NAND_FLASH_CMD,\r\nBLOCK_ERASE | PAGE_ACC | LAST_PAGE);\r\nnandc_set_reg(nandc, NAND_ADDR0, page_addr);\r\nnandc_set_reg(nandc, NAND_ADDR1, 0);\r\nnandc_set_reg(nandc, NAND_DEV0_CFG0,\r\nhost->cfg0_raw & ~(7 << CW_PER_PAGE));\r\nnandc_set_reg(nandc, NAND_DEV0_CFG1, host->cfg1_raw);\r\nnandc_set_reg(nandc, NAND_EXEC_CMD, 1);\r\nnandc_set_reg(nandc, NAND_FLASH_STATUS, host->clrflashstatus);\r\nnandc_set_reg(nandc, NAND_READ_STATUS, host->clrreadstatus);\r\nwrite_reg_dma(nandc, NAND_FLASH_CMD, 3);\r\nwrite_reg_dma(nandc, NAND_DEV0_CFG0, 2);\r\nwrite_reg_dma(nandc, NAND_EXEC_CMD, 1);\r\nread_reg_dma(nandc, NAND_FLASH_STATUS, 1);\r\nwrite_reg_dma(nandc, NAND_FLASH_STATUS, 1);\r\nwrite_reg_dma(nandc, NAND_READ_STATUS, 1);\r\nreturn 0;\r\n}\r\nstatic int read_id(struct qcom_nand_host *host, int column)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nif (column == -1)\r\nreturn 0;\r\nnandc_set_reg(nandc, NAND_FLASH_CMD, FETCH_ID);\r\nnandc_set_reg(nandc, NAND_ADDR0, column);\r\nnandc_set_reg(nandc, NAND_ADDR1, 0);\r\nnandc_set_reg(nandc, NAND_FLASH_CHIP_SELECT, DM_EN);\r\nnandc_set_reg(nandc, NAND_EXEC_CMD, 1);\r\nwrite_reg_dma(nandc, NAND_FLASH_CMD, 4);\r\nwrite_reg_dma(nandc, NAND_EXEC_CMD, 1);\r\nread_reg_dma(nandc, NAND_READ_ID, 1);\r\nreturn 0;\r\n}\r\nstatic int reset(struct qcom_nand_host *host)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nnandc_set_reg(nandc, NAND_FLASH_CMD, RESET_DEVICE);\r\nnandc_set_reg(nandc, NAND_EXEC_CMD, 1);\r\nwrite_reg_dma(nandc, NAND_FLASH_CMD, 1);\r\nwrite_reg_dma(nandc, NAND_EXEC_CMD, 1);\r\nread_reg_dma(nandc, NAND_FLASH_STATUS, 1);\r\nreturn 0;\r\n}\r\nstatic int submit_descs(struct qcom_nand_controller *nandc)\r\n{\r\nstruct desc_info *desc;\r\ndma_cookie_t cookie = 0;\r\nlist_for_each_entry(desc, &nandc->desc_list, node)\r\ncookie = dmaengine_submit(desc->dma_desc);\r\nif (dma_sync_wait(nandc->chan, cookie) != DMA_COMPLETE)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void free_descs(struct qcom_nand_controller *nandc)\r\n{\r\nstruct desc_info *desc, *n;\r\nlist_for_each_entry_safe(desc, n, &nandc->desc_list, node) {\r\nlist_del(&desc->node);\r\ndma_unmap_sg(nandc->dev, &desc->sgl, 1, desc->dir);\r\nkfree(desc);\r\n}\r\n}\r\nstatic void clear_read_regs(struct qcom_nand_controller *nandc)\r\n{\r\nnandc->reg_read_pos = 0;\r\nmemset(nandc->reg_read_buf, 0,\r\nMAX_REG_RD * sizeof(*nandc->reg_read_buf));\r\n}\r\nstatic void pre_command(struct qcom_nand_host *host, int command)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nnandc->buf_count = 0;\r\nnandc->buf_start = 0;\r\nhost->use_ecc = false;\r\nhost->last_command = command;\r\nclear_read_regs(nandc);\r\n}\r\nstatic void parse_erase_write_errors(struct qcom_nand_host *host, int command)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint num_cw;\r\nint i;\r\nnum_cw = command == NAND_CMD_PAGEPROG ? ecc->steps : 1;\r\nfor (i = 0; i < num_cw; i++) {\r\nu32 flash_status = le32_to_cpu(nandc->reg_read_buf[i]);\r\nif (flash_status & FS_MPU_ERR)\r\nhost->status &= ~NAND_STATUS_WP;\r\nif (flash_status & FS_OP_ERR || (i == (num_cw - 1) &&\r\n(flash_status &\r\nFS_DEVICE_STS_ERR)))\r\nhost->status |= NAND_STATUS_FAIL;\r\n}\r\n}\r\nstatic void post_command(struct qcom_nand_host *host, int command)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nswitch (command) {\r\ncase NAND_CMD_READID:\r\nmemcpy(nandc->data_buffer, nandc->reg_read_buf,\r\nnandc->buf_count);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\nparse_erase_write_errors(host, command);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void qcom_nandc_command(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nbool wait = false;\r\nint ret = 0;\r\npre_command(host, command);\r\nswitch (command) {\r\ncase NAND_CMD_RESET:\r\nret = reset(host);\r\nwait = true;\r\nbreak;\r\ncase NAND_CMD_READID:\r\nnandc->buf_count = 4;\r\nret = read_id(host, column);\r\nwait = true;\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\nret = nandc_param(host);\r\nwait = true;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nret = erase_block(host, page_addr);\r\nwait = true;\r\nbreak;\r\ncase NAND_CMD_READ0:\r\nWARN_ON(column != 0);\r\nhost->use_ecc = true;\r\nset_address(host, 0, page_addr);\r\nupdate_rw_regs(host, ecc->steps, true);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nWARN_ON(column != 0);\r\nset_address(host, 0, page_addr);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_STATUS:\r\ncase NAND_CMD_NONE:\r\ndefault:\r\nbreak;\r\n}\r\nif (ret) {\r\ndev_err(nandc->dev, "failure executing command %d\n",\r\ncommand);\r\nfree_descs(nandc);\r\nreturn;\r\n}\r\nif (wait) {\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev,\r\n"failure submitting descs for command %d\n",\r\ncommand);\r\n}\r\nfree_descs(nandc);\r\npost_command(host, command);\r\n}\r\nstatic bool erased_chunk_check_and_fixup(u8 *data_buf, int data_len)\r\n{\r\nu8 empty1, empty2;\r\nempty1 = data_buf[3];\r\nempty2 = data_buf[175];\r\nif ((empty1 == 0x54 && empty2 == 0xff) ||\r\n(empty1 == 0xff && empty2 == 0x54)) {\r\ndata_buf[3] = 0xff;\r\ndata_buf[175] = 0xff;\r\n}\r\nif (memchr_inv(data_buf, 0xff, data_len)) {\r\ndata_buf[3] = empty1;\r\ndata_buf[175] = empty2;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int parse_read_errors(struct qcom_nand_host *host, u8 *data_buf,\r\nu8 *oob_buf)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nunsigned int max_bitflips = 0;\r\nstruct read_stats *buf;\r\nint i;\r\nbuf = (struct read_stats *)nandc->reg_read_buf;\r\nfor (i = 0; i < ecc->steps; i++, buf++) {\r\nu32 flash, buffer, erased_cw;\r\nint data_len, oob_len;\r\nif (i == (ecc->steps - 1)) {\r\ndata_len = ecc->size - ((ecc->steps - 1) << 2);\r\noob_len = ecc->steps << 2;\r\n} else {\r\ndata_len = host->cw_data;\r\noob_len = 0;\r\n}\r\nflash = le32_to_cpu(buf->flash);\r\nbuffer = le32_to_cpu(buf->buffer);\r\nerased_cw = le32_to_cpu(buf->erased_cw);\r\nif (flash & (FS_OP_ERR | FS_MPU_ERR)) {\r\nbool erased;\r\nif (host->bch_enabled) {\r\nerased = (erased_cw & ERASED_CW) == ERASED_CW ?\r\ntrue : false;\r\n} else {\r\nerased = erased_chunk_check_and_fixup(data_buf,\r\ndata_len);\r\n}\r\nif (erased) {\r\ndata_buf += data_len;\r\nif (oob_buf)\r\noob_buf += oob_len + ecc->bytes;\r\ncontinue;\r\n}\r\nif (buffer & BS_UNCORRECTABLE_BIT) {\r\nint ret, ecclen, extraooblen;\r\nvoid *eccbuf;\r\neccbuf = oob_buf ? oob_buf + oob_len : NULL;\r\necclen = oob_buf ? host->ecc_bytes_hw : 0;\r\nextraooblen = oob_buf ? oob_len : 0;\r\nret = nand_check_erased_ecc_chunk(data_buf,\r\ndata_len, eccbuf, ecclen, oob_buf,\r\nextraooblen, ecc->strength);\r\nif (ret < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += ret;\r\nmax_bitflips =\r\nmax_t(unsigned int, max_bitflips, ret);\r\n}\r\n}\r\n} else {\r\nunsigned int stat;\r\nstat = buffer & BS_CORRECTABLE_ERR_MSK;\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max(max_bitflips, stat);\r\n}\r\ndata_buf += data_len;\r\nif (oob_buf)\r\noob_buf += oob_len + ecc->bytes;\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int read_page_ecc(struct qcom_nand_host *host, u8 *data_buf,\r\nu8 *oob_buf)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint i, ret;\r\nfor (i = 0; i < ecc->steps; i++) {\r\nint data_size, oob_size;\r\nif (i == (ecc->steps - 1)) {\r\ndata_size = ecc->size - ((ecc->steps - 1) << 2);\r\noob_size = (ecc->steps << 2) + host->ecc_bytes_hw +\r\nhost->spare_bytes;\r\n} else {\r\ndata_size = host->cw_data;\r\noob_size = host->ecc_bytes_hw + host->spare_bytes;\r\n}\r\nconfig_cw_read(nandc);\r\nif (data_buf)\r\nread_data_dma(nandc, FLASH_BUF_ACC, data_buf,\r\ndata_size);\r\nif (oob_buf) {\r\nint j;\r\nfor (j = 0; j < host->bbm_size; j++)\r\n*oob_buf++ = 0xff;\r\nread_data_dma(nandc, FLASH_BUF_ACC + data_size,\r\noob_buf, oob_size);\r\n}\r\nif (data_buf)\r\ndata_buf += data_size;\r\nif (oob_buf)\r\noob_buf += oob_size;\r\n}\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev, "failure to read page/oob\n");\r\nfree_descs(nandc);\r\nreturn ret;\r\n}\r\nstatic int copy_last_cw(struct qcom_nand_host *host, int page)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint size;\r\nint ret;\r\nclear_read_regs(nandc);\r\nsize = host->use_ecc ? host->cw_data : host->cw_size;\r\nmemset(nandc->data_buffer, 0xff, size);\r\nset_address(host, host->cw_size * (ecc->steps - 1), page);\r\nupdate_rw_regs(host, 1, true);\r\nconfig_cw_read(nandc);\r\nread_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, size);\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev, "failed to copy last codeword\n");\r\nfree_descs(nandc);\r\nreturn ret;\r\n}\r\nstatic int qcom_nandc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nu8 *data_buf, *oob_buf = NULL;\r\nint ret;\r\ndata_buf = buf;\r\noob_buf = oob_required ? chip->oob_poi : NULL;\r\nret = read_page_ecc(host, data_buf, oob_buf);\r\nif (ret) {\r\ndev_err(nandc->dev, "failure to read page\n");\r\nreturn ret;\r\n}\r\nreturn parse_read_errors(host, data_buf, oob_buf);\r\n}\r\nstatic int qcom_nandc_read_page_raw(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nu8 *data_buf, *oob_buf;\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint i, ret;\r\ndata_buf = buf;\r\noob_buf = chip->oob_poi;\r\nhost->use_ecc = false;\r\nupdate_rw_regs(host, ecc->steps, true);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nint data_size1, data_size2, oob_size1, oob_size2;\r\nint reg_off = FLASH_BUF_ACC;\r\ndata_size1 = mtd->writesize - host->cw_size * (ecc->steps - 1);\r\noob_size1 = host->bbm_size;\r\nif (i == (ecc->steps - 1)) {\r\ndata_size2 = ecc->size - data_size1 -\r\n((ecc->steps - 1) << 2);\r\noob_size2 = (ecc->steps << 2) + host->ecc_bytes_hw +\r\nhost->spare_bytes;\r\n} else {\r\ndata_size2 = host->cw_data - data_size1;\r\noob_size2 = host->ecc_bytes_hw + host->spare_bytes;\r\n}\r\nconfig_cw_read(nandc);\r\nread_data_dma(nandc, reg_off, data_buf, data_size1);\r\nreg_off += data_size1;\r\ndata_buf += data_size1;\r\nread_data_dma(nandc, reg_off, oob_buf, oob_size1);\r\nreg_off += oob_size1;\r\noob_buf += oob_size1;\r\nread_data_dma(nandc, reg_off, data_buf, data_size2);\r\nreg_off += data_size2;\r\ndata_buf += data_size2;\r\nread_data_dma(nandc, reg_off, oob_buf, oob_size2);\r\noob_buf += oob_size2;\r\n}\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev, "failure to read raw page\n");\r\nfree_descs(nandc);\r\nreturn 0;\r\n}\r\nstatic int qcom_nandc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint ret;\r\nclear_read_regs(nandc);\r\nhost->use_ecc = true;\r\nset_address(host, 0, page);\r\nupdate_rw_regs(host, ecc->steps, true);\r\nret = read_page_ecc(host, NULL, chip->oob_poi);\r\nif (ret)\r\ndev_err(nandc->dev, "failure to read oob\n");\r\nreturn ret;\r\n}\r\nstatic int qcom_nandc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nu8 *data_buf, *oob_buf;\r\nint i, ret;\r\nclear_read_regs(nandc);\r\ndata_buf = (u8 *)buf;\r\noob_buf = chip->oob_poi;\r\nhost->use_ecc = true;\r\nupdate_rw_regs(host, ecc->steps, false);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nint data_size, oob_size;\r\nif (i == (ecc->steps - 1)) {\r\ndata_size = ecc->size - ((ecc->steps - 1) << 2);\r\noob_size = (ecc->steps << 2) + host->ecc_bytes_hw +\r\nhost->spare_bytes;\r\n} else {\r\ndata_size = host->cw_data;\r\noob_size = ecc->bytes;\r\n}\r\nconfig_cw_write_pre(nandc);\r\nwrite_data_dma(nandc, FLASH_BUF_ACC, data_buf, data_size);\r\nif (i == (ecc->steps - 1)) {\r\noob_buf += host->bbm_size;\r\nwrite_data_dma(nandc, FLASH_BUF_ACC + data_size,\r\noob_buf, oob_size);\r\n}\r\nconfig_cw_write_post(nandc);\r\ndata_buf += data_size;\r\noob_buf += oob_size;\r\n}\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev, "failure to write page\n");\r\nfree_descs(nandc);\r\nreturn ret;\r\n}\r\nstatic int qcom_nandc_write_page_raw(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nu8 *data_buf, *oob_buf;\r\nint i, ret;\r\nclear_read_regs(nandc);\r\ndata_buf = (u8 *)buf;\r\noob_buf = chip->oob_poi;\r\nhost->use_ecc = false;\r\nupdate_rw_regs(host, ecc->steps, false);\r\nfor (i = 0; i < ecc->steps; i++) {\r\nint data_size1, data_size2, oob_size1, oob_size2;\r\nint reg_off = FLASH_BUF_ACC;\r\ndata_size1 = mtd->writesize - host->cw_size * (ecc->steps - 1);\r\noob_size1 = host->bbm_size;\r\nif (i == (ecc->steps - 1)) {\r\ndata_size2 = ecc->size - data_size1 -\r\n((ecc->steps - 1) << 2);\r\noob_size2 = (ecc->steps << 2) + host->ecc_bytes_hw +\r\nhost->spare_bytes;\r\n} else {\r\ndata_size2 = host->cw_data - data_size1;\r\noob_size2 = host->ecc_bytes_hw + host->spare_bytes;\r\n}\r\nconfig_cw_write_pre(nandc);\r\nwrite_data_dma(nandc, reg_off, data_buf, data_size1);\r\nreg_off += data_size1;\r\ndata_buf += data_size1;\r\nwrite_data_dma(nandc, reg_off, oob_buf, oob_size1);\r\nreg_off += oob_size1;\r\noob_buf += oob_size1;\r\nwrite_data_dma(nandc, reg_off, data_buf, data_size2);\r\nreg_off += data_size2;\r\ndata_buf += data_size2;\r\nwrite_data_dma(nandc, reg_off, oob_buf, oob_size2);\r\noob_buf += oob_size2;\r\nconfig_cw_write_post(nandc);\r\n}\r\nret = submit_descs(nandc);\r\nif (ret)\r\ndev_err(nandc->dev, "failure to write raw page\n");\r\nfree_descs(nandc);\r\nreturn ret;\r\n}\r\nstatic int qcom_nandc_write_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nu8 *oob = chip->oob_poi;\r\nint data_size, oob_size;\r\nint ret, status = 0;\r\nhost->use_ecc = true;\r\nret = copy_last_cw(host, page);\r\nif (ret)\r\nreturn ret;\r\nclear_read_regs(nandc);\r\ndata_size = ecc->size - ((ecc->steps - 1) << 2);\r\noob_size = mtd->oobavail;\r\nmtd_ooblayout_get_databytes(mtd, nandc->data_buffer + data_size, oob,\r\n0, mtd->oobavail);\r\nset_address(host, host->cw_size * (ecc->steps - 1), page);\r\nupdate_rw_regs(host, 1, false);\r\nconfig_cw_write_pre(nandc);\r\nwrite_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer,\r\ndata_size + oob_size);\r\nconfig_cw_write_post(nandc);\r\nret = submit_descs(nandc);\r\nfree_descs(nandc);\r\nif (ret) {\r\ndev_err(nandc->dev, "failure to write oob\n");\r\nreturn -EIO;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int qcom_nandc_block_bad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint page, ret, bbpos, bad = 0;\r\nu32 flash_status;\r\npage = (int)(ofs >> chip->page_shift) & chip->pagemask;\r\nhost->use_ecc = false;\r\nret = copy_last_cw(host, page);\r\nif (ret)\r\ngoto err;\r\nflash_status = le32_to_cpu(nandc->reg_read_buf[0]);\r\nif (flash_status & (FS_OP_ERR | FS_MPU_ERR)) {\r\ndev_warn(nandc->dev, "error when trying to read BBM\n");\r\ngoto err;\r\n}\r\nbbpos = mtd->writesize - host->cw_size * (ecc->steps - 1);\r\nbad = nandc->data_buffer[bbpos] != 0xff;\r\nif (chip->options & NAND_BUSWIDTH_16)\r\nbad = bad || (nandc->data_buffer[bbpos + 1] != 0xff);\r\nerr:\r\nreturn bad;\r\n}\r\nstatic int qcom_nandc_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nint page, ret, status = 0;\r\nclear_read_regs(nandc);\r\nmemset(nandc->data_buffer, 0x00, host->cw_size);\r\npage = (int)(ofs >> chip->page_shift) & chip->pagemask;\r\nhost->use_ecc = false;\r\nset_address(host, host->cw_size * (ecc->steps - 1), page);\r\nupdate_rw_regs(host, 1, false);\r\nconfig_cw_write_pre(nandc);\r\nwrite_data_dma(nandc, FLASH_BUF_ACC, nandc->data_buffer, host->cw_size);\r\nconfig_cw_write_post(nandc);\r\nret = submit_descs(nandc);\r\nfree_descs(nandc);\r\nif (ret) {\r\ndev_err(nandc->dev, "failure to update BBM\n");\r\nreturn -EIO;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic uint8_t qcom_nandc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nu8 *buf = nandc->data_buffer;\r\nu8 ret = 0x0;\r\nif (host->last_command == NAND_CMD_STATUS) {\r\nret = host->status;\r\nhost->status = NAND_STATUS_READY | NAND_STATUS_WP;\r\nreturn ret;\r\n}\r\nif (nandc->buf_start < nandc->buf_count)\r\nret = buf[nandc->buf_start++];\r\nreturn ret;\r\n}\r\nstatic void qcom_nandc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nint real_len = min_t(size_t, len, nandc->buf_count - nandc->buf_start);\r\nmemcpy(buf, nandc->data_buffer + nandc->buf_start, real_len);\r\nnandc->buf_start += real_len;\r\n}\r\nstatic void qcom_nandc_write_buf(struct mtd_info *mtd, const uint8_t *buf,\r\nint len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nint real_len = min_t(size_t, len, nandc->buf_count - nandc->buf_start);\r\nmemcpy(nandc->data_buffer + nandc->buf_start, buf, real_len);\r\nnandc->buf_start += real_len;\r\n}\r\nstatic void qcom_nandc_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nif (chipnr <= 0)\r\nreturn;\r\ndev_warn(nandc->dev, "invalid chip select\n");\r\n}\r\nstatic int qcom_nand_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nif (section > 1)\r\nreturn -ERANGE;\r\nif (!section) {\r\noobregion->length = (ecc->bytes * (ecc->steps - 1)) +\r\nhost->bbm_size;\r\noobregion->offset = 0;\r\n} else {\r\noobregion->length = host->ecc_bytes_hw + host->spare_bytes;\r\noobregion->offset = mtd->oobsize - oobregion->length;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_nand_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct qcom_nand_host *host = to_qcom_nand_host(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nif (section)\r\nreturn -ERANGE;\r\noobregion->length = ecc->steps * 4;\r\noobregion->offset = ((ecc->steps - 1) * ecc->bytes) + host->bbm_size;\r\nreturn 0;\r\n}\r\nstatic int qcom_nand_host_setup(struct qcom_nand_host *host)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);\r\nint cwperpage, bad_block_byte;\r\nbool wide_bus;\r\nint ecc_mode = 1;\r\nif (ecc->size != NANDC_STEP_SIZE) {\r\ndev_err(nandc->dev, "invalid ecc size\n");\r\nreturn -EINVAL;\r\n}\r\nwide_bus = chip->options & NAND_BUSWIDTH_16 ? true : false;\r\nif (ecc->strength >= 8) {\r\nhost->bch_enabled = true;\r\necc_mode = 1;\r\nif (wide_bus) {\r\nhost->ecc_bytes_hw = 14;\r\nhost->spare_bytes = 0;\r\nhost->bbm_size = 2;\r\n} else {\r\nhost->ecc_bytes_hw = 13;\r\nhost->spare_bytes = 2;\r\nhost->bbm_size = 1;\r\n}\r\n} else {\r\nif (nandc->ecc_modes & ECC_BCH_4BIT) {\r\nhost->bch_enabled = true;\r\necc_mode = 0;\r\nif (wide_bus) {\r\nhost->ecc_bytes_hw = 8;\r\nhost->spare_bytes = 2;\r\nhost->bbm_size = 2;\r\n} else {\r\nhost->ecc_bytes_hw = 7;\r\nhost->spare_bytes = 4;\r\nhost->bbm_size = 1;\r\n}\r\n} else {\r\nhost->ecc_bytes_hw = 10;\r\nif (wide_bus) {\r\nhost->spare_bytes = 0;\r\nhost->bbm_size = 2;\r\n} else {\r\nhost->spare_bytes = 1;\r\nhost->bbm_size = 1;\r\n}\r\n}\r\n}\r\necc->bytes = host->ecc_bytes_hw + host->spare_bytes + host->bbm_size;\r\necc->read_page = qcom_nandc_read_page;\r\necc->read_page_raw = qcom_nandc_read_page_raw;\r\necc->read_oob = qcom_nandc_read_oob;\r\necc->write_page = qcom_nandc_write_page;\r\necc->write_page_raw = qcom_nandc_write_page_raw;\r\necc->write_oob = qcom_nandc_write_oob;\r\necc->mode = NAND_ECC_HW;\r\nmtd_set_ooblayout(mtd, &qcom_nand_ooblayout_ops);\r\ncwperpage = mtd->writesize / ecc->size;\r\nhost->cw_data = 516;\r\nhost->cw_size = host->cw_data + ecc->bytes;\r\nif (ecc->bytes * (mtd->writesize / ecc->size) > mtd->oobsize) {\r\ndev_err(nandc->dev, "ecc data doesn't fit in OOB area\n");\r\nreturn -EINVAL;\r\n}\r\nbad_block_byte = mtd->writesize - host->cw_size * (cwperpage - 1) + 1;\r\nhost->cfg0 = (cwperpage - 1) << CW_PER_PAGE\r\n| host->cw_data << UD_SIZE_BYTES\r\n| 0 << DISABLE_STATUS_AFTER_WRITE\r\n| 5 << NUM_ADDR_CYCLES\r\n| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_RS\r\n| 0 << STATUS_BFR_READ\r\n| 1 << SET_RD_MODE_AFTER_STATUS\r\n| host->spare_bytes << SPARE_SIZE_BYTES;\r\nhost->cfg1 = 7 << NAND_RECOVERY_CYCLES\r\n| 0 << CS_ACTIVE_BSY\r\n| bad_block_byte << BAD_BLOCK_BYTE_NUM\r\n| 0 << BAD_BLOCK_IN_SPARE_AREA\r\n| 2 << WR_RD_BSY_GAP\r\n| wide_bus << WIDE_FLASH\r\n| host->bch_enabled << ENABLE_BCH_ECC;\r\nhost->cfg0_raw = (cwperpage - 1) << CW_PER_PAGE\r\n| host->cw_size << UD_SIZE_BYTES\r\n| 5 << NUM_ADDR_CYCLES\r\n| 0 << SPARE_SIZE_BYTES;\r\nhost->cfg1_raw = 7 << NAND_RECOVERY_CYCLES\r\n| 0 << CS_ACTIVE_BSY\r\n| 17 << BAD_BLOCK_BYTE_NUM\r\n| 1 << BAD_BLOCK_IN_SPARE_AREA\r\n| 2 << WR_RD_BSY_GAP\r\n| wide_bus << WIDE_FLASH\r\n| 1 << DEV0_CFG1_ECC_DISABLE;\r\nhost->ecc_bch_cfg = host->bch_enabled << ECC_CFG_ECC_DISABLE\r\n| 0 << ECC_SW_RESET\r\n| host->cw_data << ECC_NUM_DATA_BYTES\r\n| 1 << ECC_FORCE_CLK_OPEN\r\n| ecc_mode << ECC_MODE\r\n| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_BCH;\r\nhost->ecc_buf_cfg = 0x203 << NUM_STEPS;\r\nhost->clrflashstatus = FS_READY_BSY_N;\r\nhost->clrreadstatus = 0xc0;\r\ndev_dbg(nandc->dev,\r\n"cfg0 %x cfg1 %x ecc_buf_cfg %x ecc_bch cfg %x cw_size %d cw_data %d strength %d parity_bytes %d steps %d\n",\r\nhost->cfg0, host->cfg1, host->ecc_buf_cfg, host->ecc_bch_cfg,\r\nhost->cw_size, host->cw_data, ecc->strength, ecc->bytes,\r\ncwperpage);\r\nreturn 0;\r\n}\r\nstatic int qcom_nandc_alloc(struct qcom_nand_controller *nandc)\r\n{\r\nint ret;\r\nret = dma_set_coherent_mask(nandc->dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(nandc->dev, "failed to set DMA mask\n");\r\nreturn ret;\r\n}\r\nnandc->buf_size = 532;\r\nnandc->data_buffer = devm_kzalloc(nandc->dev, nandc->buf_size,\r\nGFP_KERNEL);\r\nif (!nandc->data_buffer)\r\nreturn -ENOMEM;\r\nnandc->regs = devm_kzalloc(nandc->dev, sizeof(*nandc->regs),\r\nGFP_KERNEL);\r\nif (!nandc->regs)\r\nreturn -ENOMEM;\r\nnandc->reg_read_buf = devm_kzalloc(nandc->dev,\r\nMAX_REG_RD * sizeof(*nandc->reg_read_buf),\r\nGFP_KERNEL);\r\nif (!nandc->reg_read_buf)\r\nreturn -ENOMEM;\r\nnandc->chan = dma_request_slave_channel(nandc->dev, "rxtx");\r\nif (!nandc->chan) {\r\ndev_err(nandc->dev, "failed to request slave channel\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_LIST_HEAD(&nandc->desc_list);\r\nINIT_LIST_HEAD(&nandc->host_list);\r\nnand_hw_control_init(&nandc->controller);\r\nreturn 0;\r\n}\r\nstatic void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)\r\n{\r\ndma_release_channel(nandc->chan);\r\n}\r\nstatic int qcom_nandc_setup(struct qcom_nand_controller *nandc)\r\n{\r\nnandc_write(nandc, SFLASHC_BURST_CFG, 0);\r\nnandc_write(nandc, NAND_FLASH_CHIP_SELECT, DM_EN);\r\nnandc->cmd1 = nandc_read(nandc, NAND_DEV_CMD1);\r\nnandc->vld = nandc_read(nandc, NAND_DEV_CMD_VLD);\r\nreturn 0;\r\n}\r\nstatic int qcom_nand_host_init(struct qcom_nand_controller *nandc,\r\nstruct qcom_nand_host *host,\r\nstruct device_node *dn)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nstruct device *dev = nandc->dev;\r\nint ret;\r\nret = of_property_read_u32(dn, "reg", &host->cs);\r\nif (ret) {\r\ndev_err(dev, "can't get chip-select\n");\r\nreturn -ENXIO;\r\n}\r\nnand_set_flash_node(chip, dn);\r\nmtd->name = devm_kasprintf(dev, GFP_KERNEL, "qcom_nand.%d", host->cs);\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = dev;\r\nchip->cmdfunc = qcom_nandc_command;\r\nchip->select_chip = qcom_nandc_select_chip;\r\nchip->read_byte = qcom_nandc_read_byte;\r\nchip->read_buf = qcom_nandc_read_buf;\r\nchip->write_buf = qcom_nandc_write_buf;\r\nchip->block_bad = qcom_nandc_block_bad;\r\nchip->block_markbad = qcom_nandc_block_markbad;\r\nchip->controller = &nandc->controller;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE | NAND_USE_BOUNCE_BUFFER |\r\nNAND_SKIP_BBTSCAN;\r\nhost->status = NAND_STATUS_READY | NAND_STATUS_WP;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\nreturn ret;\r\nret = qcom_nand_host_setup(host);\r\nif (ret)\r\nreturn ret;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\nreturn ret;\r\nreturn mtd_device_register(mtd, NULL, 0);\r\n}\r\nstatic int qcom_nandc_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct qcom_nand_controller *nandc = platform_get_drvdata(pdev);\r\nstruct device_node *np = nandc->dev->of_node;\r\nint ret;\r\nret = of_property_read_u32(np, "qcom,cmd-crci", &nandc->cmd_crci);\r\nif (ret) {\r\ndev_err(nandc->dev, "command CRCI unspecified\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "qcom,data-crci", &nandc->data_crci);\r\nif (ret) {\r\ndev_err(nandc->dev, "data CRCI unspecified\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_nandc_probe(struct platform_device *pdev)\r\n{\r\nstruct qcom_nand_controller *nandc;\r\nstruct qcom_nand_host *host;\r\nconst void *dev_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dn = dev->of_node, *child;\r\nstruct resource *res;\r\nint ret;\r\nnandc = devm_kzalloc(&pdev->dev, sizeof(*nandc), GFP_KERNEL);\r\nif (!nandc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, nandc);\r\nnandc->dev = dev;\r\ndev_data = of_device_get_match_data(dev);\r\nif (!dev_data) {\r\ndev_err(&pdev->dev, "failed to get device data\n");\r\nreturn -ENODEV;\r\n}\r\nnandc->ecc_modes = (unsigned long)dev_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnandc->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(nandc->base))\r\nreturn PTR_ERR(nandc->base);\r\nnandc->base_dma = phys_to_dma(dev, (phys_addr_t)res->start);\r\nnandc->core_clk = devm_clk_get(dev, "core");\r\nif (IS_ERR(nandc->core_clk))\r\nreturn PTR_ERR(nandc->core_clk);\r\nnandc->aon_clk = devm_clk_get(dev, "aon");\r\nif (IS_ERR(nandc->aon_clk))\r\nreturn PTR_ERR(nandc->aon_clk);\r\nret = qcom_nandc_parse_dt(pdev);\r\nif (ret)\r\nreturn ret;\r\nret = qcom_nandc_alloc(nandc);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(nandc->core_clk);\r\nif (ret)\r\ngoto err_core_clk;\r\nret = clk_prepare_enable(nandc->aon_clk);\r\nif (ret)\r\ngoto err_aon_clk;\r\nret = qcom_nandc_setup(nandc);\r\nif (ret)\r\ngoto err_setup;\r\nfor_each_available_child_of_node(dn, child) {\r\nif (of_device_is_compatible(child, "qcom,nandcs")) {\r\nhost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\r\nif (!host) {\r\nof_node_put(child);\r\nret = -ENOMEM;\r\ngoto err_cs_init;\r\n}\r\nret = qcom_nand_host_init(nandc, host, child);\r\nif (ret) {\r\ndevm_kfree(dev, host);\r\ncontinue;\r\n}\r\nlist_add_tail(&host->node, &nandc->host_list);\r\n}\r\n}\r\nif (list_empty(&nandc->host_list)) {\r\nret = -ENODEV;\r\ngoto err_cs_init;\r\n}\r\nreturn 0;\r\nerr_cs_init:\r\nlist_for_each_entry(host, &nandc->host_list, node)\r\nnand_release(nand_to_mtd(&host->chip));\r\nerr_setup:\r\nclk_disable_unprepare(nandc->aon_clk);\r\nerr_aon_clk:\r\nclk_disable_unprepare(nandc->core_clk);\r\nerr_core_clk:\r\nqcom_nandc_unalloc(nandc);\r\nreturn ret;\r\n}\r\nstatic int qcom_nandc_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_nand_controller *nandc = platform_get_drvdata(pdev);\r\nstruct qcom_nand_host *host;\r\nlist_for_each_entry(host, &nandc->host_list, node)\r\nnand_release(nand_to_mtd(&host->chip));\r\nqcom_nandc_unalloc(nandc);\r\nclk_disable_unprepare(nandc->aon_clk);\r\nclk_disable_unprepare(nandc->core_clk);\r\nreturn 0;\r\n}
