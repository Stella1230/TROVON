static int vexpress_regulator_get_voltage(struct regulator_dev *regdev)\r\n{\r\nstruct vexpress_regulator *reg = rdev_get_drvdata(regdev);\r\nu32 uV;\r\nint err = regmap_read(reg->regmap, 0, &uV);\r\nreturn err ? err : uV;\r\n}\r\nstatic int vexpress_regulator_set_voltage(struct regulator_dev *regdev,\r\nint min_uV, int max_uV, unsigned *selector)\r\n{\r\nstruct vexpress_regulator *reg = rdev_get_drvdata(regdev);\r\nreturn regmap_write(reg->regmap, 0, min_uV);\r\n}\r\nstatic int vexpress_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct vexpress_regulator *reg;\r\nstruct regulator_init_data *init_data;\r\nstruct regulator_config config = { };\r\nreg = devm_kzalloc(&pdev->dev, sizeof(*reg), GFP_KERNEL);\r\nif (!reg)\r\nreturn -ENOMEM;\r\nreg->regmap = devm_regmap_init_vexpress_config(&pdev->dev);\r\nif (IS_ERR(reg->regmap))\r\nreturn PTR_ERR(reg->regmap);\r\nreg->desc.name = dev_name(&pdev->dev);\r\nreg->desc.type = REGULATOR_VOLTAGE;\r\nreg->desc.owner = THIS_MODULE;\r\nreg->desc.continuous_voltage_range = true;\r\ninit_data = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node,\r\n&reg->desc);\r\nif (!init_data)\r\nreturn -EINVAL;\r\ninit_data->constraints.apply_uV = 0;\r\nif (init_data->constraints.min_uV && init_data->constraints.max_uV)\r\nreg->desc.ops = &vexpress_regulator_ops;\r\nelse\r\nreg->desc.ops = &vexpress_regulator_ops_ro;\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = reg;\r\nconfig.of_node = pdev->dev.of_node;\r\nreg->regdev = devm_regulator_register(&pdev->dev, &reg->desc, &config);\r\nif (IS_ERR(reg->regdev))\r\nreturn PTR_ERR(reg->regdev);\r\nplatform_set_drvdata(pdev, reg);\r\nreturn 0;\r\n}
