static inline u32 xgene_clk_read(void __iomem *csr)\r\n{\r\nreturn readl_relaxed(csr);\r\n}\r\nstatic inline void xgene_clk_write(u32 data, void __iomem *csr)\r\n{\r\nwritel_relaxed(data, csr);\r\n}\r\nstatic int xgene_clk_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct xgene_clk_pll *pllclk = to_xgene_clk_pll(hw);\r\nu32 data;\r\ndata = xgene_clk_read(pllclk->reg + pllclk->pll_offset);\r\npr_debug("%s pll %s\n", clk_hw_get_name(hw),\r\ndata & REGSPEC_RESET_F1_MASK ? "disabled" : "enabled");\r\nreturn data & REGSPEC_RESET_F1_MASK ? 0 : 1;\r\n}\r\nstatic unsigned long xgene_clk_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct xgene_clk_pll *pllclk = to_xgene_clk_pll(hw);\r\nunsigned long fref;\r\nunsigned long fvco;\r\nu32 pll;\r\nu32 nref;\r\nu32 nout;\r\nu32 nfb;\r\npll = xgene_clk_read(pllclk->reg + pllclk->pll_offset);\r\nif (pllclk->version <= 1) {\r\nif (pllclk->type == PLL_TYPE_PCP) {\r\nnout = 2;\r\nfvco = parent_rate * (N_DIV_RD(pll) + 4);\r\n} else {\r\nnref = CLKR_RD(pll) + 1;\r\nnout = CLKOD_RD(pll) + 1;\r\nnfb = CLKF_RD(pll);\r\nfref = parent_rate / nref;\r\nfvco = fref * nfb;\r\n}\r\n} else {\r\nnout = SC_OUTDIV2(pll) ? 2 : 3;\r\nfvco = parent_rate * SC_N_DIV_RD(pll);\r\n}\r\npr_debug("%s pll recalc rate %ld parent %ld version %d\n",\r\nclk_hw_get_name(hw), fvco / nout, parent_rate,\r\npllclk->version);\r\nreturn fvco / nout;\r\n}\r\nstatic struct clk *xgene_register_clk_pll(struct device *dev,\r\nconst char *name, const char *parent_name,\r\nunsigned long flags, void __iomem *reg, u32 pll_offset,\r\nu32 type, spinlock_t *lock, int version)\r\n{\r\nstruct xgene_clk_pll *apmclk;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\napmclk = kzalloc(sizeof(*apmclk), GFP_KERNEL);\r\nif (!apmclk) {\r\npr_err("%s: could not allocate APM clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &xgene_clk_pll_ops;\r\ninit.flags = flags;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\napmclk->version = version;\r\napmclk->reg = reg;\r\napmclk->lock = lock;\r\napmclk->pll_offset = pll_offset;\r\napmclk->type = type;\r\napmclk->hw.init = &init;\r\nclk = clk_register(dev, &apmclk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register clk %s\n", __func__, name);\r\nkfree(apmclk);\r\nreturn NULL;\r\n}\r\nreturn clk;\r\n}\r\nstatic int xgene_pllclk_version(struct device_node *np)\r\n{\r\nif (of_device_is_compatible(np, "apm,xgene-socpll-clock"))\r\nreturn 1;\r\nif (of_device_is_compatible(np, "apm,xgene-pcppll-clock"))\r\nreturn 1;\r\nreturn 2;\r\n}\r\nstatic void xgene_pllclk_init(struct device_node *np, enum xgene_pll_type pll_type)\r\n{\r\nconst char *clk_name = np->full_name;\r\nstruct clk *clk;\r\nvoid __iomem *reg;\r\nint version = xgene_pllclk_version(np);\r\nreg = of_iomap(np, 0);\r\nif (reg == NULL) {\r\npr_err("Unable to map CSR register for %s\n", np->full_name);\r\nreturn;\r\n}\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\nclk = xgene_register_clk_pll(NULL,\r\nclk_name, of_clk_get_parent_name(np, 0),\r\n0, reg, 0, pll_type, &clk_lock,\r\nversion);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, clk_name, NULL);\r\npr_debug("Add %s clock PLL\n", clk_name);\r\n}\r\n}\r\nstatic void xgene_socpllclk_init(struct device_node *np)\r\n{\r\nxgene_pllclk_init(np, PLL_TYPE_SOC);\r\n}\r\nstatic void xgene_pcppllclk_init(struct device_node *np)\r\n{\r\nxgene_pllclk_init(np, PLL_TYPE_PCP);\r\n}\r\nstatic unsigned long xgene_clk_pmd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\r\nunsigned long flags = 0;\r\nu64 ret, scale;\r\nu32 val;\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nelse\r\n__acquire(fd->lock);\r\nval = clk_readl(fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nelse\r\n__release(fd->lock);\r\nret = (u64)parent_rate;\r\nscale = (val & fd->mask) >> fd->shift;\r\nif (fd->flags & XGENE_CLK_PMD_SCALE_INVERTED)\r\nscale = fd->denom - scale;\r\nelse\r\nscale++;\r\ndo_div(ret, fd->denom);\r\nret *= scale;\r\nif (ret == 0)\r\nret = (u64)parent_rate;\r\nreturn ret;\r\n}\r\nstatic long xgene_clk_pmd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\r\nu64 ret, scale;\r\nif (!rate || rate >= *parent_rate)\r\nreturn *parent_rate;\r\nret = rate * fd->denom;\r\nscale = DIV_ROUND_UP_ULL(ret, *parent_rate);\r\nret = (u64)*parent_rate * scale;\r\ndo_div(ret, fd->denom);\r\nreturn ret;\r\n}\r\nstatic int xgene_clk_pmd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct xgene_clk_pmd *fd = to_xgene_clk_pmd(hw);\r\nunsigned long flags = 0;\r\nu64 scale, ret;\r\nu32 val;\r\nret = rate * fd->denom;\r\nscale = DIV_ROUND_UP_ULL(ret, (u64)parent_rate);\r\nif (fd->flags & XGENE_CLK_PMD_SCALE_INVERTED)\r\nscale = fd->denom - scale;\r\nelse\r\nscale--;\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nelse\r\n__acquire(fd->lock);\r\nval = clk_readl(fd->reg);\r\nval &= ~fd->mask;\r\nval |= (scale << fd->shift);\r\nclk_writel(val, fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nelse\r\n__release(fd->lock);\r\nreturn 0;\r\n}\r\nstatic struct clk *\r\nxgene_register_clk_pmd(struct device *dev,\r\nconst char *name, const char *parent_name,\r\nunsigned long flags, void __iomem *reg, u8 shift,\r\nu8 width, u64 denom, u32 clk_flags, spinlock_t *lock)\r\n{\r\nstruct xgene_clk_pmd *fd;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nfd = kzalloc(sizeof(*fd), GFP_KERNEL);\r\nif (!fd)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &xgene_clk_pmd_ops;\r\ninit.flags = flags;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\nfd->reg = reg;\r\nfd->shift = shift;\r\nfd->mask = (BIT(width) - 1) << shift;\r\nfd->denom = denom;\r\nfd->flags = clk_flags;\r\nfd->lock = lock;\r\nfd->hw.init = &init;\r\nclk = clk_register(dev, &fd->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register clk %s\n", __func__, name);\r\nkfree(fd);\r\nreturn NULL;\r\n}\r\nreturn clk;\r\n}\r\nstatic void xgene_pmdclk_init(struct device_node *np)\r\n{\r\nconst char *clk_name = np->full_name;\r\nvoid __iomem *csr_reg;\r\nstruct resource res;\r\nstruct clk *clk;\r\nu64 denom;\r\nu32 flags = 0;\r\nint rc;\r\nif (!of_device_is_available(np))\r\nreturn;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc != 0) {\r\npr_err("no DTS register for %s\n", np->full_name);\r\nreturn;\r\n}\r\ncsr_reg = of_iomap(np, 0);\r\nif (!csr_reg) {\r\npr_err("Unable to map resource for %s\n", np->full_name);\r\nreturn;\r\n}\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\ndenom = BIT(XGENE_CLK_PMD_WIDTH);\r\nflags |= XGENE_CLK_PMD_SCALE_INVERTED;\r\nclk = xgene_register_clk_pmd(NULL, clk_name,\r\nof_clk_get_parent_name(np, 0), 0,\r\ncsr_reg, XGENE_CLK_PMD_SHIFT,\r\nXGENE_CLK_PMD_WIDTH, denom,\r\nflags, &clk_lock);\r\nif (!IS_ERR(clk)) {\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nclk_register_clkdev(clk, clk_name, NULL);\r\npr_debug("Add %s clock\n", clk_name);\r\n} else {\r\nif (csr_reg)\r\niounmap(csr_reg);\r\n}\r\n}\r\nstatic int xgene_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nunsigned long flags = 0;\r\nu32 data;\r\nif (pclk->lock)\r\nspin_lock_irqsave(pclk->lock, flags);\r\nif (pclk->param.csr_reg != NULL) {\r\npr_debug("%s clock enabled\n", clk_hw_get_name(hw));\r\ndata = xgene_clk_read(pclk->param.csr_reg +\r\npclk->param.reg_clk_offset);\r\ndata |= pclk->param.reg_clk_mask;\r\nxgene_clk_write(data, pclk->param.csr_reg +\r\npclk->param.reg_clk_offset);\r\npr_debug("%s clk offset 0x%08X mask 0x%08X value 0x%08X\n",\r\nclk_hw_get_name(hw),\r\npclk->param.reg_clk_offset, pclk->param.reg_clk_mask,\r\ndata);\r\ndata = xgene_clk_read(pclk->param.csr_reg +\r\npclk->param.reg_csr_offset);\r\ndata &= ~pclk->param.reg_csr_mask;\r\nxgene_clk_write(data, pclk->param.csr_reg +\r\npclk->param.reg_csr_offset);\r\npr_debug("%s csr offset 0x%08X mask 0x%08X value 0x%08X\n",\r\nclk_hw_get_name(hw),\r\npclk->param.reg_csr_offset, pclk->param.reg_csr_mask,\r\ndata);\r\n}\r\nif (pclk->lock)\r\nspin_unlock_irqrestore(pclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void xgene_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nunsigned long flags = 0;\r\nu32 data;\r\nif (pclk->lock)\r\nspin_lock_irqsave(pclk->lock, flags);\r\nif (pclk->param.csr_reg != NULL) {\r\npr_debug("%s clock disabled\n", clk_hw_get_name(hw));\r\ndata = xgene_clk_read(pclk->param.csr_reg +\r\npclk->param.reg_csr_offset);\r\ndata |= pclk->param.reg_csr_mask;\r\nxgene_clk_write(data, pclk->param.csr_reg +\r\npclk->param.reg_csr_offset);\r\ndata = xgene_clk_read(pclk->param.csr_reg +\r\npclk->param.reg_clk_offset);\r\ndata &= ~pclk->param.reg_clk_mask;\r\nxgene_clk_write(data, pclk->param.csr_reg +\r\npclk->param.reg_clk_offset);\r\n}\r\nif (pclk->lock)\r\nspin_unlock_irqrestore(pclk->lock, flags);\r\n}\r\nstatic int xgene_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nu32 data = 0;\r\nif (pclk->param.csr_reg != NULL) {\r\npr_debug("%s clock checking\n", clk_hw_get_name(hw));\r\ndata = xgene_clk_read(pclk->param.csr_reg +\r\npclk->param.reg_clk_offset);\r\npr_debug("%s clock is %s\n", clk_hw_get_name(hw),\r\ndata & pclk->param.reg_clk_mask ? "enabled" :\r\n"disabled");\r\n}\r\nif (pclk->param.csr_reg == NULL)\r\nreturn 1;\r\nreturn data & pclk->param.reg_clk_mask ? 1 : 0;\r\n}\r\nstatic unsigned long xgene_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nu32 data;\r\nif (pclk->param.divider_reg) {\r\ndata = xgene_clk_read(pclk->param.divider_reg +\r\npclk->param.reg_divider_offset);\r\ndata >>= pclk->param.reg_divider_shift;\r\ndata &= (1 << pclk->param.reg_divider_width) - 1;\r\npr_debug("%s clock recalc rate %ld parent %ld\n",\r\nclk_hw_get_name(hw),\r\nparent_rate / data, parent_rate);\r\nreturn parent_rate / data;\r\n} else {\r\npr_debug("%s clock recalc rate %ld parent %ld\n",\r\nclk_hw_get_name(hw), parent_rate, parent_rate);\r\nreturn parent_rate;\r\n}\r\n}\r\nstatic int xgene_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nunsigned long flags = 0;\r\nu32 data;\r\nu32 divider;\r\nu32 divider_save;\r\nif (pclk->lock)\r\nspin_lock_irqsave(pclk->lock, flags);\r\nif (pclk->param.divider_reg) {\r\nif (rate > parent_rate)\r\nrate = parent_rate;\r\ndivider_save = divider = parent_rate / rate;\r\ndivider &= (1 << pclk->param.reg_divider_width) - 1;\r\ndivider <<= pclk->param.reg_divider_shift;\r\ndata = xgene_clk_read(pclk->param.divider_reg +\r\npclk->param.reg_divider_offset);\r\ndata &= ~(((1 << pclk->param.reg_divider_width) - 1)\r\n<< pclk->param.reg_divider_shift);\r\ndata |= divider;\r\nxgene_clk_write(data, pclk->param.divider_reg +\r\npclk->param.reg_divider_offset);\r\npr_debug("%s clock set rate %ld\n", clk_hw_get_name(hw),\r\nparent_rate / divider_save);\r\n} else {\r\ndivider_save = 1;\r\n}\r\nif (pclk->lock)\r\nspin_unlock_irqrestore(pclk->lock, flags);\r\nreturn parent_rate / divider_save;\r\n}\r\nstatic long xgene_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct xgene_clk *pclk = to_xgene_clk(hw);\r\nunsigned long parent_rate = *prate;\r\nu32 divider;\r\nif (pclk->param.divider_reg) {\r\nif (rate > parent_rate)\r\nrate = parent_rate;\r\ndivider = parent_rate / rate;\r\n} else {\r\ndivider = 1;\r\n}\r\nreturn parent_rate / divider;\r\n}\r\nstatic struct clk *xgene_register_clk(struct device *dev,\r\nconst char *name, const char *parent_name,\r\nstruct xgene_dev_parameters *parameters, spinlock_t *lock)\r\n{\r\nstruct xgene_clk *apmclk;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nint rc;\r\napmclk = kzalloc(sizeof(*apmclk), GFP_KERNEL);\r\nif (!apmclk) {\r\npr_err("%s: could not allocate APM clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &xgene_clk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\napmclk->lock = lock;\r\napmclk->hw.init = &init;\r\napmclk->param = *parameters;\r\nclk = clk_register(dev, &apmclk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register clk %s\n", __func__, name);\r\nkfree(apmclk);\r\nreturn clk;\r\n}\r\nrc = clk_register_clkdev(clk, name, NULL);\r\nif (rc != 0) {\r\npr_err("%s: could not register lookup clk %s\n",\r\n__func__, name);\r\n}\r\nreturn clk;\r\n}\r\nstatic void __init xgene_devclk_init(struct device_node *np)\r\n{\r\nconst char *clk_name = np->full_name;\r\nstruct clk *clk;\r\nstruct resource res;\r\nint rc;\r\nstruct xgene_dev_parameters parameters;\r\nint i;\r\nif (!of_device_is_available(np))\r\nreturn;\r\nparameters.csr_reg = NULL;\r\nparameters.divider_reg = NULL;\r\nfor (i = 0; i < 2; i++) {\r\nvoid __iomem *map_res;\r\nrc = of_address_to_resource(np, i, &res);\r\nif (rc != 0) {\r\nif (i == 0) {\r\npr_err("no DTS register for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\nmap_res = of_iomap(np, i);\r\nif (map_res == NULL) {\r\npr_err("Unable to map resource %d for %s\n",\r\ni, np->full_name);\r\ngoto err;\r\n}\r\nif (strcmp(res.name, "div-reg") == 0)\r\nparameters.divider_reg = map_res;\r\nelse\r\nparameters.csr_reg = map_res;\r\n}\r\nif (of_property_read_u32(np, "csr-offset", &parameters.reg_csr_offset))\r\nparameters.reg_csr_offset = 0;\r\nif (of_property_read_u32(np, "csr-mask", &parameters.reg_csr_mask))\r\nparameters.reg_csr_mask = 0xF;\r\nif (of_property_read_u32(np, "enable-offset",\r\n&parameters.reg_clk_offset))\r\nparameters.reg_clk_offset = 0x8;\r\nif (of_property_read_u32(np, "enable-mask", &parameters.reg_clk_mask))\r\nparameters.reg_clk_mask = 0xF;\r\nif (of_property_read_u32(np, "divider-offset",\r\n&parameters.reg_divider_offset))\r\nparameters.reg_divider_offset = 0;\r\nif (of_property_read_u32(np, "divider-width",\r\n&parameters.reg_divider_width))\r\nparameters.reg_divider_width = 0;\r\nif (of_property_read_u32(np, "divider-shift",\r\n&parameters.reg_divider_shift))\r\nparameters.reg_divider_shift = 0;\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\nclk = xgene_register_clk(NULL, clk_name,\r\nof_clk_get_parent_name(np, 0), &parameters, &clk_lock);\r\nif (IS_ERR(clk))\r\ngoto err;\r\npr_debug("Add %s clock\n", clk_name);\r\nrc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (rc != 0)\r\npr_err("%s: could register provider clk %s\n", __func__,\r\nnp->full_name);\r\nreturn;\r\nerr:\r\nif (parameters.csr_reg)\r\niounmap(parameters.csr_reg);\r\nif (parameters.divider_reg)\r\niounmap(parameters.divider_reg);\r\n}
