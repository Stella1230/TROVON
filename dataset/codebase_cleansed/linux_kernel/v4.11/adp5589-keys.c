static unsigned char adp5589_bank(unsigned char offset)\r\n{\r\nreturn offset >> 3;\r\n}\r\nstatic unsigned char adp5589_bit(unsigned char offset)\r\n{\r\nreturn 1u << (offset & 0x7);\r\n}\r\nstatic unsigned char adp5589_reg(unsigned char reg)\r\n{\r\nreturn reg;\r\n}\r\nstatic unsigned char adp5585_bank(unsigned char offset)\r\n{\r\nreturn offset > ADP5585_MAX_ROW_NUM;\r\n}\r\nstatic unsigned char adp5585_bit(unsigned char offset)\r\n{\r\nreturn (offset > ADP5585_MAX_ROW_NUM) ?\r\n1u << (offset - ADP5585_COL_SHIFT) : 1u << offset;\r\n}\r\nstatic unsigned char adp5585_reg(unsigned char reg)\r\n{\r\nreturn adp5585_reg_lut[reg];\r\n}\r\nstatic int adp5589_read(struct i2c_client *client, u8 reg)\r\n{\r\nint ret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Read Error\n");\r\nreturn ret;\r\n}\r\nstatic int adp5589_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int adp5589_gpio_get_value(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\r\nunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\r\nunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\r\nreturn !!(adp5589_read(kpad->client,\r\nkpad->var->reg(ADP5589_GPI_STATUS_A) + bank) &\r\nbit);\r\n}\r\nstatic void adp5589_gpio_set_value(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\r\nunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\r\nunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\r\nmutex_lock(&kpad->gpio_lock);\r\nif (val)\r\nkpad->dat_out[bank] |= bit;\r\nelse\r\nkpad->dat_out[bank] &= ~bit;\r\nadp5589_write(kpad->client, kpad->var->reg(ADP5589_GPO_DATA_OUT_A) +\r\nbank, kpad->dat_out[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\n}\r\nstatic int adp5589_gpio_direction_input(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\r\nunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\r\nunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\r\nint ret;\r\nmutex_lock(&kpad->gpio_lock);\r\nkpad->dir[bank] &= ~bit;\r\nret = adp5589_write(kpad->client,\r\nkpad->var->reg(ADP5589_GPIO_DIRECTION_A) + bank,\r\nkpad->dir[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int adp5589_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5589_kpad *kpad = gpiochip_get_data(chip);\r\nunsigned int bank = kpad->var->bank(kpad->gpiomap[off]);\r\nunsigned int bit = kpad->var->bit(kpad->gpiomap[off]);\r\nint ret;\r\nmutex_lock(&kpad->gpio_lock);\r\nkpad->dir[bank] |= bit;\r\nif (val)\r\nkpad->dat_out[bank] |= bit;\r\nelse\r\nkpad->dat_out[bank] &= ~bit;\r\nret = adp5589_write(kpad->client, kpad->var->reg(ADP5589_GPO_DATA_OUT_A)\r\n+ bank, kpad->dat_out[bank]);\r\nret |= adp5589_write(kpad->client,\r\nkpad->var->reg(ADP5589_GPIO_DIRECTION_A) + bank,\r\nkpad->dir[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int adp5589_build_gpiomap(struct adp5589_kpad *kpad,\r\nconst struct adp5589_kpad_platform_data *pdata)\r\n{\r\nbool pin_used[ADP5589_MAXGPIO];\r\nint n_unused = 0;\r\nint i;\r\nmemset(pin_used, false, sizeof(pin_used));\r\nfor (i = 0; i < kpad->var->maxgpio; i++)\r\nif (pdata->keypad_en_mask & (1 << i))\r\npin_used[i] = true;\r\nfor (i = 0; i < kpad->gpimapsize; i++)\r\npin_used[kpad->gpimap[i].pin - kpad->var->gpi_pin_base] = true;\r\nif (kpad->extend_cfg & R4_EXTEND_CFG)\r\npin_used[4] = true;\r\nif (kpad->extend_cfg & C4_EXTEND_CFG)\r\npin_used[kpad->var->c4_extend_cfg] = true;\r\nif (!kpad->support_row5)\r\npin_used[5] = true;\r\nfor (i = 0; i < kpad->var->maxgpio; i++)\r\nif (!pin_used[i])\r\nkpad->gpiomap[n_unused++] = i;\r\nreturn n_unused;\r\n}\r\nstatic int adp5589_gpio_add(struct adp5589_kpad *kpad)\r\n{\r\nstruct device *dev = &kpad->client->dev;\r\nconst struct adp5589_kpad_platform_data *pdata = dev_get_platdata(dev);\r\nconst struct adp5589_gpio_platform_data *gpio_data = pdata->gpio_data;\r\nint i, error;\r\nif (!gpio_data)\r\nreturn 0;\r\nkpad->gc.ngpio = adp5589_build_gpiomap(kpad, pdata);\r\nif (kpad->gc.ngpio == 0) {\r\ndev_info(dev, "No unused gpios left to export\n");\r\nreturn 0;\r\n}\r\nkpad->export_gpio = true;\r\nkpad->gc.direction_input = adp5589_gpio_direction_input;\r\nkpad->gc.direction_output = adp5589_gpio_direction_output;\r\nkpad->gc.get = adp5589_gpio_get_value;\r\nkpad->gc.set = adp5589_gpio_set_value;\r\nkpad->gc.can_sleep = 1;\r\nkpad->gc.base = gpio_data->gpio_start;\r\nkpad->gc.label = kpad->client->name;\r\nkpad->gc.owner = THIS_MODULE;\r\nmutex_init(&kpad->gpio_lock);\r\nerror = gpiochip_add_data(&kpad->gc, kpad);\r\nif (error) {\r\ndev_err(dev, "gpiochip_add_data() failed, err: %d\n", error);\r\nreturn error;\r\n}\r\nfor (i = 0; i <= kpad->var->bank(kpad->var->maxgpio); i++) {\r\nkpad->dat_out[i] = adp5589_read(kpad->client, kpad->var->reg(\r\nADP5589_GPO_DATA_OUT_A) + i);\r\nkpad->dir[i] = adp5589_read(kpad->client, kpad->var->reg(\r\nADP5589_GPIO_DIRECTION_A) + i);\r\n}\r\nif (gpio_data->setup) {\r\nerror = gpio_data->setup(kpad->client,\r\nkpad->gc.base, kpad->gc.ngpio,\r\ngpio_data->context);\r\nif (error)\r\ndev_warn(dev, "setup failed, %d\n", error);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adp5589_gpio_remove(struct adp5589_kpad *kpad)\r\n{\r\nstruct device *dev = &kpad->client->dev;\r\nconst struct adp5589_kpad_platform_data *pdata = dev_get_platdata(dev);\r\nconst struct adp5589_gpio_platform_data *gpio_data = pdata->gpio_data;\r\nint error;\r\nif (!kpad->export_gpio)\r\nreturn;\r\nif (gpio_data->teardown) {\r\nerror = gpio_data->teardown(kpad->client,\r\nkpad->gc.base, kpad->gc.ngpio,\r\ngpio_data->context);\r\nif (error)\r\ndev_warn(dev, "teardown failed %d\n", error);\r\n}\r\ngpiochip_remove(&kpad->gc);\r\n}\r\nstatic inline int adp5589_gpio_add(struct adp5589_kpad *kpad)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void adp5589_gpio_remove(struct adp5589_kpad *kpad)\r\n{\r\n}\r\nstatic void adp5589_report_switches(struct adp5589_kpad *kpad,\r\nint key, int key_val)\r\n{\r\nint i;\r\nfor (i = 0; i < kpad->gpimapsize; i++) {\r\nif (key_val == kpad->gpimap[i].pin) {\r\ninput_report_switch(kpad->input,\r\nkpad->gpimap[i].sw_evt,\r\nkey & KEY_EV_PRESSED);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void adp5589_report_events(struct adp5589_kpad *kpad, int ev_cnt)\r\n{\r\nint i;\r\nfor (i = 0; i < ev_cnt; i++) {\r\nint key = adp5589_read(kpad->client, ADP5589_5_FIFO_1 + i);\r\nint key_val = key & KEY_EV_MASK;\r\nif (key_val >= kpad->var->gpi_pin_base &&\r\nkey_val <= kpad->var->gpi_pin_end) {\r\nadp5589_report_switches(kpad, key, key_val);\r\n} else {\r\ninput_report_key(kpad->input,\r\nkpad->keycode[key_val - 1],\r\nkey & KEY_EV_PRESSED);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t adp5589_irq(int irq, void *handle)\r\n{\r\nstruct adp5589_kpad *kpad = handle;\r\nstruct i2c_client *client = kpad->client;\r\nint status, ev_cnt;\r\nstatus = adp5589_read(client, ADP5589_5_INT_STATUS);\r\nif (status & OVRFLOW_INT)\r\ndev_err(&client->dev, "Event Overflow Error\n");\r\nif (status & EVENT_INT) {\r\nev_cnt = adp5589_read(client, ADP5589_5_STATUS) & KEC;\r\nif (ev_cnt) {\r\nadp5589_report_events(kpad, ev_cnt);\r\ninput_sync(kpad->input);\r\n}\r\n}\r\nadp5589_write(client, ADP5589_5_INT_STATUS, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adp5589_get_evcode(struct adp5589_kpad *kpad, unsigned short key)\r\n{\r\nint i;\r\nfor (i = 0; i < kpad->var->keymapsize; i++)\r\nif (key == kpad->keycode[i])\r\nreturn (i + 1) | KEY_EV_PRESSED;\r\ndev_err(&kpad->client->dev, "RESET/UNLOCK key not in keycode map\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int adp5589_setup(struct adp5589_kpad *kpad)\r\n{\r\nstruct i2c_client *client = kpad->client;\r\nconst struct adp5589_kpad_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nu8 (*reg) (u8) = kpad->var->reg;\r\nunsigned char evt_mode1 = 0, evt_mode2 = 0, evt_mode3 = 0;\r\nunsigned char pull_mask = 0;\r\nint i, ret;\r\nret = adp5589_write(client, reg(ADP5589_PIN_CONFIG_A),\r\npdata->keypad_en_mask & kpad->var->row_mask);\r\nret |= adp5589_write(client, reg(ADP5589_PIN_CONFIG_B),\r\n(pdata->keypad_en_mask >> kpad->var->col_shift) &\r\nkpad->var->col_mask);\r\nif (!kpad->is_adp5585)\r\nret |= adp5589_write(client, ADP5589_PIN_CONFIG_C,\r\n(pdata->keypad_en_mask >> 16) & 0xFF);\r\nif (!kpad->is_adp5585 && pdata->en_keylock) {\r\nret |= adp5589_write(client, ADP5589_UNLOCK1,\r\npdata->unlock_key1);\r\nret |= adp5589_write(client, ADP5589_UNLOCK2,\r\npdata->unlock_key2);\r\nret |= adp5589_write(client, ADP5589_UNLOCK_TIMERS,\r\npdata->unlock_timer & LTIME_MASK);\r\nret |= adp5589_write(client, ADP5589_LOCK_CFG, LOCK_EN);\r\n}\r\nfor (i = 0; i < KEYP_MAX_EVENT; i++)\r\nret |= adp5589_read(client, ADP5589_5_FIFO_1 + i);\r\nfor (i = 0; i < pdata->gpimapsize; i++) {\r\nunsigned short pin = pdata->gpimap[i].pin;\r\nif (pin <= kpad->var->gpi_pin_row_end) {\r\nevt_mode1 |= (1 << (pin - kpad->var->gpi_pin_row_base));\r\n} else {\r\nevt_mode2 |=\r\n((1 << (pin - kpad->var->gpi_pin_col_base)) & 0xFF);\r\nif (!kpad->is_adp5585)\r\nevt_mode3 |= ((1 << (pin -\r\nkpad->var->gpi_pin_col_base)) >> 8);\r\n}\r\n}\r\nif (pdata->gpimapsize) {\r\nret |= adp5589_write(client, reg(ADP5589_GPI_EVENT_EN_A),\r\nevt_mode1);\r\nret |= adp5589_write(client, reg(ADP5589_GPI_EVENT_EN_B),\r\nevt_mode2);\r\nif (!kpad->is_adp5585)\r\nret |= adp5589_write(client,\r\nreg(ADP5589_GPI_EVENT_EN_C),\r\nevt_mode3);\r\n}\r\nif (pdata->pull_dis_mask & pdata->pullup_en_100k &\r\npdata->pullup_en_300k & pdata->pulldown_en_300k)\r\ndev_warn(&client->dev, "Conflicting pull resistor config\n");\r\nfor (i = 0; i <= kpad->var->max_row_num; i++) {\r\nunsigned val = 0, bit = (1 << i);\r\nif (pdata->pullup_en_300k & bit)\r\nval = 0;\r\nelse if (pdata->pulldown_en_300k & bit)\r\nval = 1;\r\nelse if (pdata->pullup_en_100k & bit)\r\nval = 2;\r\nelse if (pdata->pull_dis_mask & bit)\r\nval = 3;\r\npull_mask |= val << (2 * (i & 0x3));\r\nif (i % 4 == 3 || i == kpad->var->max_row_num) {\r\nret |= adp5589_write(client, reg(ADP5585_RPULL_CONFIG_A)\r\n+ (i >> 2), pull_mask);\r\npull_mask = 0;\r\n}\r\n}\r\nfor (i = 0; i <= kpad->var->max_col_num; i++) {\r\nunsigned val = 0, bit = 1 << (i + kpad->var->col_shift);\r\nif (pdata->pullup_en_300k & bit)\r\nval = 0;\r\nelse if (pdata->pulldown_en_300k & bit)\r\nval = 1;\r\nelse if (pdata->pullup_en_100k & bit)\r\nval = 2;\r\nelse if (pdata->pull_dis_mask & bit)\r\nval = 3;\r\npull_mask |= val << (2 * (i & 0x3));\r\nif (i % 4 == 3 || i == kpad->var->max_col_num) {\r\nret |= adp5589_write(client,\r\nreg(ADP5585_RPULL_CONFIG_C) +\r\n(i >> 2), pull_mask);\r\npull_mask = 0;\r\n}\r\n}\r\nif (pdata->reset1_key_1 && pdata->reset1_key_2 && pdata->reset1_key_3) {\r\nret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_A),\r\nadp5589_get_evcode(kpad,\r\npdata->reset1_key_1));\r\nret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_B),\r\nadp5589_get_evcode(kpad,\r\npdata->reset1_key_2));\r\nret |= adp5589_write(client, reg(ADP5589_RESET1_EVENT_C),\r\nadp5589_get_evcode(kpad,\r\npdata->reset1_key_3));\r\nkpad->extend_cfg |= R4_EXTEND_CFG;\r\n}\r\nif (pdata->reset2_key_1 && pdata->reset2_key_2) {\r\nret |= adp5589_write(client, reg(ADP5589_RESET2_EVENT_A),\r\nadp5589_get_evcode(kpad,\r\npdata->reset2_key_1));\r\nret |= adp5589_write(client, reg(ADP5589_RESET2_EVENT_B),\r\nadp5589_get_evcode(kpad,\r\npdata->reset2_key_2));\r\nkpad->extend_cfg |= C4_EXTEND_CFG;\r\n}\r\nif (kpad->extend_cfg) {\r\nret |= adp5589_write(client, reg(ADP5589_RESET_CFG),\r\npdata->reset_cfg);\r\nret |= adp5589_write(client, reg(ADP5589_PIN_CONFIG_D),\r\nkpad->extend_cfg);\r\n}\r\nret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_A),\r\npdata->debounce_dis_mask & kpad->var->row_mask);\r\nret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_B),\r\n(pdata->debounce_dis_mask >> kpad->var->col_shift)\r\n& kpad->var->col_mask);\r\nif (!kpad->is_adp5585)\r\nret |= adp5589_write(client, reg(ADP5589_DEBOUNCE_DIS_C),\r\n(pdata->debounce_dis_mask >> 16) & 0xFF);\r\nret |= adp5589_write(client, reg(ADP5589_POLL_PTIME_CFG),\r\npdata->scan_cycle_time & PTIME_MASK);\r\nret |= adp5589_write(client, ADP5589_5_INT_STATUS,\r\n(kpad->is_adp5585 ? 0 : LOGIC2_INT) |\r\nLOGIC1_INT | OVRFLOW_INT |\r\n(kpad->is_adp5585 ? 0 : LOCK_INT) |\r\nGPI_INT | EVENT_INT);\r\nret |= adp5589_write(client, reg(ADP5589_GENERAL_CFG),\r\nINT_CFG | OSC_EN | CORE_CLK(3));\r\nret |= adp5589_write(client, reg(ADP5589_INT_EN),\r\nOVRFLOW_IEN | GPI_IEN | EVENT_IEN);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Write Error\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adp5589_report_switch_state(struct adp5589_kpad *kpad)\r\n{\r\nint gpi_stat_tmp, pin_loc;\r\nint i;\r\nint gpi_stat1 = adp5589_read(kpad->client,\r\nkpad->var->reg(ADP5589_GPI_STATUS_A));\r\nint gpi_stat2 = adp5589_read(kpad->client,\r\nkpad->var->reg(ADP5589_GPI_STATUS_B));\r\nint gpi_stat3 = !kpad->is_adp5585 ?\r\nadp5589_read(kpad->client, ADP5589_GPI_STATUS_C) : 0;\r\nfor (i = 0; i < kpad->gpimapsize; i++) {\r\nunsigned short pin = kpad->gpimap[i].pin;\r\nif (pin <= kpad->var->gpi_pin_row_end) {\r\ngpi_stat_tmp = gpi_stat1;\r\npin_loc = pin - kpad->var->gpi_pin_row_base;\r\n} else if ((pin - kpad->var->gpi_pin_col_base) < 8) {\r\ngpi_stat_tmp = gpi_stat2;\r\npin_loc = pin - kpad->var->gpi_pin_col_base;\r\n} else {\r\ngpi_stat_tmp = gpi_stat3;\r\npin_loc = pin - kpad->var->gpi_pin_col_base - 8;\r\n}\r\nif (gpi_stat_tmp < 0) {\r\ndev_err(&kpad->client->dev,\r\n"Can't read GPIO_DAT_STAT switch %d, default to OFF\n",\r\npin);\r\ngpi_stat_tmp = 0;\r\n}\r\ninput_report_switch(kpad->input,\r\nkpad->gpimap[i].sw_evt,\r\n!(gpi_stat_tmp & (1 << pin_loc)));\r\n}\r\ninput_sync(kpad->input);\r\n}\r\nstatic int adp5589_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adp5589_kpad *kpad;\r\nconst struct adp5589_kpad_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct input_dev *input;\r\nunsigned int revid;\r\nint ret, i;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Byte Data not Supported\n");\r\nreturn -EIO;\r\n}\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data?\n");\r\nreturn -EINVAL;\r\n}\r\nkpad = kzalloc(sizeof(*kpad), GFP_KERNEL);\r\nif (!kpad)\r\nreturn -ENOMEM;\r\nswitch (id->driver_data) {\r\ncase ADP5585_02:\r\nkpad->support_row5 = true;\r\ncase ADP5585_01:\r\nkpad->is_adp5585 = true;\r\nkpad->var = &const_adp5585;\r\nbreak;\r\ncase ADP5589:\r\nkpad->support_row5 = true;\r\nkpad->var = &const_adp5589;\r\nbreak;\r\n}\r\nif (!((pdata->keypad_en_mask & kpad->var->row_mask) &&\r\n(pdata->keypad_en_mask >> kpad->var->col_shift)) ||\r\n!pdata->keymap) {\r\ndev_err(&client->dev, "no rows, cols or keymap from pdata\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nif (pdata->keymapsize != kpad->var->keymapsize) {\r\ndev_err(&client->dev, "invalid keymapsize\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nif (!pdata->gpimap && pdata->gpimapsize) {\r\ndev_err(&client->dev, "invalid gpimap from pdata\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nif (pdata->gpimapsize > kpad->var->gpimapsize_max) {\r\ndev_err(&client->dev, "invalid gpimapsize\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nfor (i = 0; i < pdata->gpimapsize; i++) {\r\nunsigned short pin = pdata->gpimap[i].pin;\r\nif (pin < kpad->var->gpi_pin_base ||\r\npin > kpad->var->gpi_pin_end) {\r\ndev_err(&client->dev, "invalid gpi pin data\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\nif ((1 << (pin - kpad->var->gpi_pin_row_base)) &\r\npdata->keypad_en_mask) {\r\ndev_err(&client->dev, "invalid gpi row/col data\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "no IRQ?\n");\r\nerror = -EINVAL;\r\ngoto err_free_mem;\r\n}\r\ninput = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkpad->client = client;\r\nkpad->input = input;\r\nret = adp5589_read(client, ADP5589_5_ID);\r\nif (ret < 0) {\r\nerror = ret;\r\ngoto err_free_input;\r\n}\r\nrevid = (u8) ret & ADP5589_5_DEVICE_ID_MASK;\r\ninput->name = client->name;\r\ninput->phys = "adp5589-keys/input0";\r\ninput->dev.parent = &client->dev;\r\ninput_set_drvdata(input, kpad);\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = revid;\r\ninput->keycodesize = sizeof(kpad->keycode[0]);\r\ninput->keycodemax = pdata->keymapsize;\r\ninput->keycode = kpad->keycode;\r\nmemcpy(kpad->keycode, pdata->keymap,\r\npdata->keymapsize * input->keycodesize);\r\nkpad->gpimap = pdata->gpimap;\r\nkpad->gpimapsize = pdata->gpimapsize;\r\n__set_bit(EV_KEY, input->evbit);\r\nif (pdata->repeat)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < input->keycodemax; i++)\r\nif (kpad->keycode[i] <= KEY_MAX)\r\n__set_bit(kpad->keycode[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nif (kpad->gpimapsize)\r\n__set_bit(EV_SW, input->evbit);\r\nfor (i = 0; i < kpad->gpimapsize; i++)\r\n__set_bit(kpad->gpimap[i].sw_evt, input->swbit);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&client->dev, "unable to register input device\n");\r\ngoto err_free_input;\r\n}\r\nerror = request_threaded_irq(client->irq, NULL, adp5589_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->dev.driver->name, kpad);\r\nif (error) {\r\ndev_err(&client->dev, "irq %d busy?\n", client->irq);\r\ngoto err_unreg_dev;\r\n}\r\nerror = adp5589_setup(kpad);\r\nif (error)\r\ngoto err_free_irq;\r\nif (kpad->gpimapsize)\r\nadp5589_report_switch_state(kpad);\r\nerror = adp5589_gpio_add(kpad);\r\nif (error)\r\ngoto err_free_irq;\r\ndevice_init_wakeup(&client->dev, 1);\r\ni2c_set_clientdata(client, kpad);\r\ndev_info(&client->dev, "Rev.%d keypad, irq %d\n", revid, client->irq);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, kpad);\r\nerr_unreg_dev:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr_free_input:\r\ninput_free_device(input);\r\nerr_free_mem:\r\nkfree(kpad);\r\nreturn error;\r\n}\r\nstatic int adp5589_remove(struct i2c_client *client)\r\n{\r\nstruct adp5589_kpad *kpad = i2c_get_clientdata(client);\r\nadp5589_write(client, kpad->var->reg(ADP5589_GENERAL_CFG), 0);\r\nfree_irq(client->irq, kpad);\r\ninput_unregister_device(kpad->input);\r\nadp5589_gpio_remove(kpad);\r\nkfree(kpad);\r\nreturn 0;\r\n}\r\nstatic int adp5589_suspend(struct device *dev)\r\n{\r\nstruct adp5589_kpad *kpad = dev_get_drvdata(dev);\r\nstruct i2c_client *client = kpad->client;\r\ndisable_irq(client->irq);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int adp5589_resume(struct device *dev)\r\n{\r\nstruct adp5589_kpad *kpad = dev_get_drvdata(dev);\r\nstruct i2c_client *client = kpad->client;\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
