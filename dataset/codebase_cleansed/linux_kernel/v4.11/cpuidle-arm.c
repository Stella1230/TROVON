static int arm_enter_idle_state(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int idx)\r\n{\r\nreturn CPU_PM_CPU_IDLE_ENTER(arm_cpuidle_suspend, idx);\r\n}\r\nstatic int __init arm_idle_init(void)\r\n{\r\nint cpu, ret;\r\nstruct cpuidle_driver *drv = &arm_idle_driver;\r\nstruct cpuidle_device *dev;\r\nret = dt_init_idle_driver(drv, arm_idle_state_match, 1);\r\nif (ret <= 0)\r\nreturn ret ? : -ENODEV;\r\nret = cpuidle_register_driver(drv);\r\nif (ret) {\r\npr_err("Failed to register cpuidle driver\n");\r\nreturn ret;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\nret = arm_cpuidle_init(cpu);\r\nif (ret == -ENXIO)\r\ncontinue;\r\nif (ret) {\r\npr_err("CPU %d failed to init idle CPU ops\n", cpu);\r\ngoto out_fail;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\npr_err("Failed to allocate cpuidle device\n");\r\nret = -ENOMEM;\r\ngoto out_fail;\r\n}\r\ndev->cpu = cpu;\r\nret = cpuidle_register_device(dev);\r\nif (ret) {\r\npr_err("Failed to register cpuidle device for CPU %d\n",\r\ncpu);\r\nkfree(dev);\r\ngoto out_fail;\r\n}\r\n}\r\nreturn 0;\r\nout_fail:\r\nwhile (--cpu >= 0) {\r\ndev = per_cpu(cpuidle_devices, cpu);\r\ncpuidle_unregister_device(dev);\r\nkfree(dev);\r\n}\r\ncpuidle_unregister_driver(drv);\r\nreturn ret;\r\n}
