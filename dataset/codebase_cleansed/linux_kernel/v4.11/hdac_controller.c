static void azx_clear_corbrp(struct hdac_bus *bus)\r\n{\r\nint timeout;\r\nfor (timeout = 1000; timeout > 0; timeout--) {\r\nif (snd_hdac_chip_readw(bus, CORBRP) & AZX_CORBRP_RST)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout <= 0)\r\ndev_err(bus->dev, "CORB reset timeout#1, CORBRP = %d\n",\r\nsnd_hdac_chip_readw(bus, CORBRP));\r\nsnd_hdac_chip_writew(bus, CORBRP, 0);\r\nfor (timeout = 1000; timeout > 0; timeout--) {\r\nif (snd_hdac_chip_readw(bus, CORBRP) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout <= 0)\r\ndev_err(bus->dev, "CORB reset timeout#2, CORBRP = %d\n",\r\nsnd_hdac_chip_readw(bus, CORBRP));\r\n}\r\nvoid snd_hdac_bus_init_cmd_io(struct hdac_bus *bus)\r\n{\r\nspin_lock_irq(&bus->reg_lock);\r\nbus->corb.addr = bus->rb.addr;\r\nbus->corb.buf = (__le32 *)bus->rb.area;\r\nsnd_hdac_chip_writel(bus, CORBLBASE, (u32)bus->corb.addr);\r\nsnd_hdac_chip_writel(bus, CORBUBASE, upper_32_bits(bus->corb.addr));\r\nsnd_hdac_chip_writeb(bus, CORBSIZE, 0x02);\r\nsnd_hdac_chip_writew(bus, CORBWP, 0);\r\nsnd_hdac_chip_writew(bus, CORBRP, AZX_CORBRP_RST);\r\nif (!bus->corbrp_self_clear)\r\nazx_clear_corbrp(bus);\r\nsnd_hdac_chip_writeb(bus, CORBCTL, AZX_CORBCTL_RUN);\r\nbus->rirb.addr = bus->rb.addr + 2048;\r\nbus->rirb.buf = (__le32 *)(bus->rb.area + 2048);\r\nbus->rirb.wp = bus->rirb.rp = 0;\r\nmemset(bus->rirb.cmds, 0, sizeof(bus->rirb.cmds));\r\nsnd_hdac_chip_writel(bus, RIRBLBASE, (u32)bus->rirb.addr);\r\nsnd_hdac_chip_writel(bus, RIRBUBASE, upper_32_bits(bus->rirb.addr));\r\nsnd_hdac_chip_writeb(bus, RIRBSIZE, 0x02);\r\nsnd_hdac_chip_writew(bus, RIRBWP, AZX_RIRBWP_RST);\r\nsnd_hdac_chip_writew(bus, RINTCNT, 1);\r\nsnd_hdac_chip_writeb(bus, RIRBCTL, AZX_RBCTL_DMA_EN | AZX_RBCTL_IRQ_EN);\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nstatic void hdac_wait_for_cmd_dmas(struct hdac_bus *bus)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile ((snd_hdac_chip_readb(bus, RIRBCTL) & AZX_RBCTL_DMA_EN)\r\n&& time_before(jiffies, timeout))\r\nudelay(10);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile ((snd_hdac_chip_readb(bus, CORBCTL) & AZX_CORBCTL_RUN)\r\n&& time_before(jiffies, timeout))\r\nudelay(10);\r\n}\r\nvoid snd_hdac_bus_stop_cmd_io(struct hdac_bus *bus)\r\n{\r\nspin_lock_irq(&bus->reg_lock);\r\nsnd_hdac_chip_writeb(bus, RIRBCTL, 0);\r\nsnd_hdac_chip_writeb(bus, CORBCTL, 0);\r\nhdac_wait_for_cmd_dmas(bus);\r\nsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, 0);\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nstatic unsigned int azx_command_addr(u32 cmd)\r\n{\r\nunsigned int addr = cmd >> 28;\r\nif (snd_BUG_ON(addr >= HDA_MAX_CODECS))\r\naddr = 0;\r\nreturn addr;\r\n}\r\nint snd_hdac_bus_send_cmd(struct hdac_bus *bus, unsigned int val)\r\n{\r\nunsigned int addr = azx_command_addr(val);\r\nunsigned int wp, rp;\r\nspin_lock_irq(&bus->reg_lock);\r\nbus->last_cmd[azx_command_addr(val)] = val;\r\nwp = snd_hdac_chip_readw(bus, CORBWP);\r\nif (wp == 0xffff) {\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn -EIO;\r\n}\r\nwp++;\r\nwp %= AZX_MAX_CORB_ENTRIES;\r\nrp = snd_hdac_chip_readw(bus, CORBRP);\r\nif (wp == rp) {\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn -EAGAIN;\r\n}\r\nbus->rirb.cmds[addr]++;\r\nbus->corb.buf[wp] = cpu_to_le32(val);\r\nsnd_hdac_chip_writew(bus, CORBWP, wp);\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_bus_update_rirb(struct hdac_bus *bus)\r\n{\r\nunsigned int rp, wp;\r\nunsigned int addr;\r\nu32 res, res_ex;\r\nwp = snd_hdac_chip_readw(bus, RIRBWP);\r\nif (wp == 0xffff) {\r\nreturn;\r\n}\r\nif (wp == bus->rirb.wp)\r\nreturn;\r\nbus->rirb.wp = wp;\r\nwhile (bus->rirb.rp != wp) {\r\nbus->rirb.rp++;\r\nbus->rirb.rp %= AZX_MAX_RIRB_ENTRIES;\r\nrp = bus->rirb.rp << 1;\r\nres_ex = le32_to_cpu(bus->rirb.buf[rp + 1]);\r\nres = le32_to_cpu(bus->rirb.buf[rp]);\r\naddr = res_ex & 0xf;\r\nif (addr >= HDA_MAX_CODECS) {\r\ndev_err(bus->dev,\r\n"spurious response %#x:%#x, rp = %d, wp = %d",\r\nres, res_ex, bus->rirb.rp, wp);\r\nsnd_BUG();\r\n} else if (res_ex & AZX_RIRB_EX_UNSOL_EV)\r\nsnd_hdac_bus_queue_event(bus, res, res_ex);\r\nelse if (bus->rirb.cmds[addr]) {\r\nbus->rirb.res[addr] = res;\r\nbus->rirb.cmds[addr]--;\r\n} else {\r\ndev_err_ratelimited(bus->dev,\r\n"spurious response %#x:%#x, last cmd=%#08x\n",\r\nres, res_ex, bus->last_cmd[addr]);\r\n}\r\n}\r\n}\r\nint snd_hdac_bus_get_response(struct hdac_bus *bus, unsigned int addr,\r\nunsigned int *res)\r\n{\r\nunsigned long timeout;\r\nunsigned long loopcounter;\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nfor (loopcounter = 0;; loopcounter++) {\r\nspin_lock_irq(&bus->reg_lock);\r\nif (!bus->rirb.cmds[addr]) {\r\nif (res)\r\n*res = bus->rirb.res[addr];\r\nspin_unlock_irq(&bus->reg_lock);\r\nreturn 0;\r\n}\r\nspin_unlock_irq(&bus->reg_lock);\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nif (loopcounter > 3000)\r\nmsleep(2);\r\nelse {\r\nudelay(10);\r\ncond_resched();\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nint snd_hdac_bus_parse_capabilities(struct hdac_bus *bus)\r\n{\r\nunsigned int cur_cap;\r\nunsigned int offset;\r\nunsigned int counter = 0;\r\noffset = snd_hdac_chip_readl(bus, LLCH);\r\ndo {\r\ncur_cap = _snd_hdac_chip_read(l, bus, offset);\r\ndev_dbg(bus->dev, "Capability version: 0x%x\n",\r\n(cur_cap & AZX_CAP_HDR_VER_MASK) >> AZX_CAP_HDR_VER_OFF);\r\ndev_dbg(bus->dev, "HDA capability ID: 0x%x\n",\r\n(cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF);\r\nswitch ((cur_cap & AZX_CAP_HDR_ID_MASK) >> AZX_CAP_HDR_ID_OFF) {\r\ncase AZX_ML_CAP_ID:\r\ndev_dbg(bus->dev, "Found ML capability\n");\r\nbus->mlcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_GTS_CAP_ID:\r\ndev_dbg(bus->dev, "Found GTS capability offset=%x\n", offset);\r\nbus->gtscap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_PP_CAP_ID:\r\ndev_dbg(bus->dev, "Found PP capability offset=%x\n", offset);\r\nbus->ppcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_SPB_CAP_ID:\r\ndev_dbg(bus->dev, "Found SPB capability\n");\r\nbus->spbcap = bus->remap_addr + offset;\r\nbreak;\r\ncase AZX_DRSM_CAP_ID:\r\ndev_dbg(bus->dev, "Found DRSM capability\n");\r\nbus->drsmcap = bus->remap_addr + offset;\r\nbreak;\r\ndefault:\r\ndev_dbg(bus->dev, "Unknown capability %d\n", cur_cap);\r\nbreak;\r\n}\r\ncounter++;\r\nif (counter > HDAC_MAX_CAPS) {\r\ndev_err(bus->dev, "We exceeded HDAC capabilities!!!\n");\r\nbreak;\r\n}\r\noffset = cur_cap & AZX_CAP_HDR_NXT_PTR_MASK;\r\n} while (offset);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_bus_enter_link_reset(struct hdac_bus *bus)\r\n{\r\nunsigned long timeout;\r\nsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_RESET, 0);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile ((snd_hdac_chip_readb(bus, GCTL) & AZX_GCTL_RESET) &&\r\ntime_before(jiffies, timeout))\r\nusleep_range(500, 1000);\r\n}\r\nvoid snd_hdac_bus_exit_link_reset(struct hdac_bus *bus)\r\n{\r\nunsigned long timeout;\r\nsnd_hdac_chip_updateb(bus, GCTL, 0, AZX_GCTL_RESET);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (!snd_hdac_chip_readb(bus, GCTL) && time_before(jiffies, timeout))\r\nusleep_range(500, 1000);\r\n}\r\nstatic int azx_reset(struct hdac_bus *bus, bool full_reset)\r\n{\r\nif (!full_reset)\r\ngoto skip_reset;\r\nsnd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);\r\nsnd_hdac_bus_enter_link_reset(bus);\r\nusleep_range(500, 1000);\r\nsnd_hdac_bus_exit_link_reset(bus);\r\nusleep_range(1000, 1200);\r\nskip_reset:\r\nif (!snd_hdac_chip_readb(bus, GCTL)) {\r\ndev_dbg(bus->dev, "azx_reset: controller not ready!\n");\r\nreturn -EBUSY;\r\n}\r\nsnd_hdac_chip_updatel(bus, GCTL, 0, AZX_GCTL_UNSOL);\r\nif (!bus->codec_mask) {\r\nbus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);\r\ndev_dbg(bus->dev, "codec_mask = 0x%lx\n", bus->codec_mask);\r\n}\r\nreturn 0;\r\n}\r\nstatic void azx_int_enable(struct hdac_bus *bus)\r\n{\r\nsnd_hdac_chip_updatel(bus, INTCTL, 0, AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN);\r\n}\r\nstatic void azx_int_disable(struct hdac_bus *bus)\r\n{\r\nstruct hdac_stream *azx_dev;\r\nlist_for_each_entry(azx_dev, &bus->stream_list, list)\r\nsnd_hdac_stream_updateb(azx_dev, SD_CTL, SD_INT_MASK, 0);\r\nsnd_hdac_chip_writeb(bus, INTCTL, 0);\r\nsnd_hdac_chip_updatel(bus, INTCTL, AZX_INT_CTRL_EN | AZX_INT_GLOBAL_EN, 0);\r\n}\r\nstatic void azx_int_clear(struct hdac_bus *bus)\r\n{\r\nstruct hdac_stream *azx_dev;\r\nlist_for_each_entry(azx_dev, &bus->stream_list, list)\r\nsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);\r\nsnd_hdac_chip_writew(bus, STATESTS, STATESTS_INT_MASK);\r\nsnd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);\r\nsnd_hdac_chip_writel(bus, INTSTS, AZX_INT_CTRL_EN | AZX_INT_ALL_STREAM);\r\n}\r\nbool snd_hdac_bus_init_chip(struct hdac_bus *bus, bool full_reset)\r\n{\r\nif (bus->chip_init)\r\nreturn false;\r\nazx_reset(bus, full_reset);\r\nazx_int_clear(bus);\r\nazx_int_enable(bus);\r\nsnd_hdac_bus_init_cmd_io(bus);\r\nif (bus->use_posbuf && bus->posbuf.addr) {\r\nsnd_hdac_chip_writel(bus, DPLBASE, (u32)bus->posbuf.addr);\r\nsnd_hdac_chip_writel(bus, DPUBASE, upper_32_bits(bus->posbuf.addr));\r\n}\r\nbus->chip_init = true;\r\nreturn true;\r\n}\r\nvoid snd_hdac_bus_stop_chip(struct hdac_bus *bus)\r\n{\r\nif (!bus->chip_init)\r\nreturn;\r\nazx_int_disable(bus);\r\nazx_int_clear(bus);\r\nsnd_hdac_bus_stop_cmd_io(bus);\r\nif (bus->posbuf.addr) {\r\nsnd_hdac_chip_writel(bus, DPLBASE, 0);\r\nsnd_hdac_chip_writel(bus, DPUBASE, 0);\r\n}\r\nbus->chip_init = false;\r\n}\r\nint snd_hdac_bus_handle_stream_irq(struct hdac_bus *bus, unsigned int status,\r\nvoid (*ack)(struct hdac_bus *,\r\nstruct hdac_stream *))\r\n{\r\nstruct hdac_stream *azx_dev;\r\nu8 sd_status;\r\nint handled = 0;\r\nlist_for_each_entry(azx_dev, &bus->stream_list, list) {\r\nif (status & azx_dev->sd_int_sta_mask) {\r\nsd_status = snd_hdac_stream_readb(azx_dev, SD_STS);\r\nsnd_hdac_stream_writeb(azx_dev, SD_STS, SD_INT_MASK);\r\nhandled |= 1 << azx_dev->index;\r\nif (!azx_dev->substream || !azx_dev->running ||\r\n!(sd_status & SD_INT_COMPLETE))\r\ncontinue;\r\nif (ack)\r\nack(bus, azx_dev);\r\n}\r\n}\r\nreturn handled;\r\n}\r\nint snd_hdac_bus_alloc_stream_pages(struct hdac_bus *bus)\r\n{\r\nstruct hdac_stream *s;\r\nint num_streams = 0;\r\nint err;\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nerr = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,\r\nBDL_SIZE, &s->bdl);\r\nnum_streams++;\r\nif (err < 0)\r\nreturn -ENOMEM;\r\n}\r\nif (WARN_ON(!num_streams))\r\nreturn -EINVAL;\r\nerr = bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,\r\nnum_streams * 8, &bus->posbuf);\r\nif (err < 0)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(s, &bus->stream_list, list)\r\ns->posbuf = (__le32 *)(bus->posbuf.area + s->index * 8);\r\nreturn bus->io_ops->dma_alloc_pages(bus, SNDRV_DMA_TYPE_DEV,\r\nPAGE_SIZE, &bus->rb);\r\n}\r\nvoid snd_hdac_bus_free_stream_pages(struct hdac_bus *bus)\r\n{\r\nstruct hdac_stream *s;\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nif (s->bdl.area)\r\nbus->io_ops->dma_free_pages(bus, &s->bdl);\r\n}\r\nif (bus->rb.area)\r\nbus->io_ops->dma_free_pages(bus, &bus->rb);\r\nif (bus->posbuf.area)\r\nbus->io_ops->dma_free_pages(bus, &bus->posbuf);\r\n}
