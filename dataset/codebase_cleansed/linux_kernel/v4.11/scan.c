static void\r\n_dbg_security_flags(int log_level, const char *func, const char *desc,\r\nstruct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\n_mwifiex_dbg(priv->adapter, log_level,\r\n"info: %s: %s:\twpa_ie=%#x wpa2_ie=%#x WEP=%s WPA=%s WPA2=%s\tEncMode=%#x privacy=%#x\n",\r\nfunc, desc,\r\nbss_desc->bcn_wpa_ie ?\r\nbss_desc->bcn_wpa_ie->vend_hdr.element_id : 0,\r\nbss_desc->bcn_rsn_ie ?\r\nbss_desc->bcn_rsn_ie->ieee_hdr.element_id : 0,\r\npriv->sec_info.wep_enabled ? "e" : "d",\r\npriv->sec_info.wpa_enabled ? "e" : "d",\r\npriv->sec_info.wpa2_enabled ? "e" : "d",\r\npriv->sec_info.encryption_mode,\r\nbss_desc->privacy);\r\n}\r\nstatic bool\r\nhas_ieee_hdr(struct ieee_types_generic *ie, u8 key)\r\n{\r\nreturn (ie && ie->ieee_hdr.element_id == key);\r\n}\r\nstatic bool\r\nhas_vendor_hdr(struct ieee_types_vendor_specific *ie, u8 key)\r\n{\r\nreturn (ie && ie->vend_hdr.element_id == key);\r\n}\r\nstatic u8\r\nmwifiex_search_oui_in_ie(struct ie_body *iebody, u8 *oui)\r\n{\r\nu8 count;\r\ncount = iebody->ptk_cnt[0];\r\nwhile (count) {\r\nif (!memcmp(iebody->ptk_body, oui, sizeof(iebody->ptk_body)))\r\nreturn MWIFIEX_OUI_PRESENT;\r\n--count;\r\nif (count)\r\niebody = (struct ie_body *) ((u8 *) iebody +\r\nsizeof(iebody->ptk_body));\r\n}\r\npr_debug("info: %s: OUI is not found in PTK\n", __func__);\r\nreturn MWIFIEX_OUI_NOT_PRESENT;\r\n}\r\nstatic u8\r\nmwifiex_is_rsn_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\r\n{\r\nu8 *oui;\r\nstruct ie_body *iebody;\r\nu8 ret = MWIFIEX_OUI_NOT_PRESENT;\r\nif (has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\r\niebody = (struct ie_body *)\r\n(((u8 *) bss_desc->bcn_rsn_ie->data) +\r\nRSN_GTK_OUI_OFFSET);\r\noui = &mwifiex_rsn_oui[cipher][0];\r\nret = mwifiex_search_oui_in_ie(iebody, oui);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic u8\r\nmwifiex_is_wpa_oui_present(struct mwifiex_bssdescriptor *bss_desc, u32 cipher)\r\n{\r\nu8 *oui;\r\nstruct ie_body *iebody;\r\nu8 ret = MWIFIEX_OUI_NOT_PRESENT;\r\nif (has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)) {\r\niebody = (struct ie_body *) bss_desc->bcn_wpa_ie->data;\r\noui = &mwifiex_wpa_oui[cipher][0];\r\nret = mwifiex_search_oui_in_ie(iebody, oui);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\ns32\r\nmwifiex_ssid_cmp(struct cfg80211_ssid *ssid1, struct cfg80211_ssid *ssid2)\r\n{\r\nif (!ssid1 || !ssid2 || (ssid1->ssid_len != ssid2->ssid_len))\r\nreturn -1;\r\nreturn memcmp(ssid1->ssid, ssid2->ssid, ssid1->ssid_len);\r\n}\r\nstatic bool\r\nmwifiex_is_bss_wapi(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (priv->sec_info.wapi_enabled &&\r\nhas_ieee_hdr(bss_desc->bcn_wapi_ie, WLAN_EID_BSS_AC_ACCESS_DELAY))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_no_sec(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\r\n!priv->sec_info.wpa2_enabled &&\r\n!has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\r\n!has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\r\n!priv->sec_info.encryption_mode && !bss_desc->privacy) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_static_wep(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\r\n!priv->sec_info.wpa2_enabled && bss_desc->privacy) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_wpa(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (!priv->sec_info.wep_enabled && priv->sec_info.wpa_enabled &&\r\n!priv->sec_info.wpa2_enabled &&\r\nhas_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC)\r\n) {\r\ndbg_security_flags(INFO, "WPA", priv, bss_desc);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_wpa2(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\r\npriv->sec_info.wpa2_enabled &&\r\nhas_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN)) {\r\ndbg_security_flags(INFO, "WAP2", priv, bss_desc);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_adhoc_aes(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\r\n!priv->sec_info.wpa2_enabled &&\r\n!has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\r\n!has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\r\n!priv->sec_info.encryption_mode && bss_desc->privacy) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nmwifiex_is_bss_dynamic_wep(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (!priv->sec_info.wep_enabled && !priv->sec_info.wpa_enabled &&\r\n!priv->sec_info.wpa2_enabled &&\r\n!has_vendor_hdr(bss_desc->bcn_wpa_ie, WLAN_EID_VENDOR_SPECIFIC) &&\r\n!has_ieee_hdr(bss_desc->bcn_rsn_ie, WLAN_EID_RSN) &&\r\npriv->sec_info.encryption_mode && bss_desc->privacy) {\r\ndbg_security_flags(INFO, "dynamic", priv, bss_desc);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic s32\r\nmwifiex_is_network_compatible(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc, u32 mode)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nbss_desc->disable_11n = false;\r\nif (priv->media_connected &&\r\n(priv->bss_mode == NL80211_IFTYPE_STATION) &&\r\n(bss_desc->bss_mode == NL80211_IFTYPE_STATION))\r\nreturn 0;\r\nif (priv->wps.session_enable) {\r\nmwifiex_dbg(adapter, IOCTL,\r\n"info: return success directly in WPS period\n");\r\nreturn 0;\r\n}\r\nif (bss_desc->chan_sw_ie_present) {\r\nmwifiex_dbg(adapter, INFO,\r\n"Don't connect to AP with WLAN_EID_CHANNEL_SWITCH\n");\r\nreturn -1;\r\n}\r\nif (mwifiex_is_bss_wapi(priv, bss_desc)) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: return success for WAPI AP\n");\r\nreturn 0;\r\n}\r\nif (bss_desc->bss_mode == mode) {\r\nif (mwifiex_is_bss_no_sec(priv, bss_desc)) {\r\nreturn 0;\r\n} else if (mwifiex_is_bss_static_wep(priv, bss_desc)) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Disable 11n in WEP mode.\n");\r\nbss_desc->disable_11n = true;\r\nreturn 0;\r\n} else if (mwifiex_is_bss_wpa(priv, bss_desc)) {\r\nif (((priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN) &&\r\nbss_desc->bcn_ht_cap) &&\r\n!mwifiex_is_wpa_oui_present(bss_desc,\r\nCIPHER_SUITE_CCMP)) {\r\nif (mwifiex_is_wpa_oui_present\r\n(bss_desc, CIPHER_SUITE_TKIP)) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Disable 11n if AES\t"\r\n"is not supported by AP\n");\r\nbss_desc->disable_11n = true;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n} else if (mwifiex_is_bss_wpa2(priv, bss_desc)) {\r\nif (((priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN) &&\r\nbss_desc->bcn_ht_cap) &&\r\n!mwifiex_is_rsn_oui_present(bss_desc,\r\nCIPHER_SUITE_CCMP)) {\r\nif (mwifiex_is_rsn_oui_present\r\n(bss_desc, CIPHER_SUITE_TKIP)) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Disable 11n if AES\t"\r\n"is not supported by AP\n");\r\nbss_desc->disable_11n = true;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n} else if (mwifiex_is_bss_adhoc_aes(priv, bss_desc)) {\r\nreturn 0;\r\n} else if (mwifiex_is_bss_dynamic_wep(priv, bss_desc)) {\r\nreturn 0;\r\n}\r\ndbg_security_flags(ERROR, "failed", priv, bss_desc);\r\nreturn -1;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nmwifiex_scan_create_channel_list(struct mwifiex_private *priv,\r\nconst struct mwifiex_user_scan_cfg\r\n*user_scan_in,\r\nstruct mwifiex_chan_scan_param_set\r\n*scan_chan_list,\r\nu8 filtered_scan)\r\n{\r\nenum nl80211_band band;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint chan_idx = 0, i;\r\nfor (band = 0; (band < NUM_NL80211_BANDS) ; band++) {\r\nif (!priv->wdev.wiphy->bands[band])\r\ncontinue;\r\nsband = priv->wdev.wiphy->bands[band];\r\nfor (i = 0; (i < sband->n_channels) ; i++) {\r\nch = &sband->channels[i];\r\nif (ch->flags & IEEE80211_CHAN_DISABLED)\r\ncontinue;\r\nscan_chan_list[chan_idx].radio_type = band;\r\nif (user_scan_in &&\r\nuser_scan_in->chan_list[0].scan_time)\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16((u16) user_scan_in->\r\nchan_list[0].scan_time);\r\nelse if (ch->flags & IEEE80211_CHAN_NO_IR)\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(adapter->passive_scan_time);\r\nelse\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(adapter->active_scan_time);\r\nif (ch->flags & IEEE80211_CHAN_NO_IR)\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n|= (MWIFIEX_PASSIVE_SCAN |\r\nMWIFIEX_HIDDEN_SSID_REPORT);\r\nelse\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n&= ~MWIFIEX_PASSIVE_SCAN;\r\nscan_chan_list[chan_idx].chan_number =\r\n(u32) ch->hw_value;\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n|= MWIFIEX_DISABLE_CHAN_FILT;\r\nif (filtered_scan) {\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(adapter->specific_scan_time);\r\n}\r\nchan_idx++;\r\n}\r\n}\r\nreturn chan_idx;\r\n}\r\nstatic int\r\nmwifiex_bgscan_create_channel_list(struct mwifiex_private *priv,\r\nconst struct mwifiex_bg_scan_cfg\r\n*bgscan_cfg_in,\r\nstruct mwifiex_chan_scan_param_set\r\n*scan_chan_list)\r\n{\r\nenum nl80211_band band;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint chan_idx = 0, i;\r\nfor (band = 0; (band < NUM_NL80211_BANDS); band++) {\r\nif (!priv->wdev.wiphy->bands[band])\r\ncontinue;\r\nsband = priv->wdev.wiphy->bands[band];\r\nfor (i = 0; (i < sband->n_channels) ; i++) {\r\nch = &sband->channels[i];\r\nif (ch->flags & IEEE80211_CHAN_DISABLED)\r\ncontinue;\r\nscan_chan_list[chan_idx].radio_type = band;\r\nif (bgscan_cfg_in->chan_list[0].scan_time)\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16((u16)bgscan_cfg_in->\r\nchan_list[0].scan_time);\r\nelse if (ch->flags & IEEE80211_CHAN_NO_IR)\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(adapter->passive_scan_time);\r\nelse\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(adapter->\r\nspecific_scan_time);\r\nif (ch->flags & IEEE80211_CHAN_NO_IR)\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n|= MWIFIEX_PASSIVE_SCAN;\r\nelse\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n&= ~MWIFIEX_PASSIVE_SCAN;\r\nscan_chan_list[chan_idx].chan_number =\r\n(u32)ch->hw_value;\r\nchan_idx++;\r\n}\r\n}\r\nreturn chan_idx;\r\n}\r\nstatic int\r\nmwifiex_append_rate_tlv(struct mwifiex_private *priv,\r\nstruct mwifiex_scan_cmd_config *scan_cfg_out,\r\nu8 radio)\r\n{\r\nstruct mwifiex_ie_types_rates_param_set *rates_tlv;\r\nu8 rates[MWIFIEX_SUPPORTED_RATES], *tlv_pos;\r\nu32 rates_size;\r\nmemset(rates, 0, sizeof(rates));\r\ntlv_pos = (u8 *)scan_cfg_out->tlv_buf + scan_cfg_out->tlv_buf_len;\r\nif (priv->scan_request)\r\nrates_size = mwifiex_get_rates_from_cfg80211(priv, rates,\r\nradio);\r\nelse\r\nrates_size = mwifiex_get_supported_rates(priv, rates);\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"info: SCAN_CMD: Rates size = %d\n",\r\nrates_size);\r\nrates_tlv = (struct mwifiex_ie_types_rates_param_set *)tlv_pos;\r\nrates_tlv->header.type = cpu_to_le16(WLAN_EID_SUPP_RATES);\r\nrates_tlv->header.len = cpu_to_le16((u16) rates_size);\r\nmemcpy(rates_tlv->rates, rates, rates_size);\r\nscan_cfg_out->tlv_buf_len += sizeof(rates_tlv->header) + rates_size;\r\nreturn rates_size;\r\n}\r\nstatic int\r\nmwifiex_scan_channel_list(struct mwifiex_private *priv,\r\nu32 max_chan_per_scan, u8 filtered_scan,\r\nstruct mwifiex_scan_cmd_config *scan_cfg_out,\r\nstruct mwifiex_ie_types_chan_list_param_set\r\n*chan_tlv_out,\r\nstruct mwifiex_chan_scan_param_set *scan_chan_list)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret = 0;\r\nstruct mwifiex_chan_scan_param_set *tmp_chan_list;\r\nstruct mwifiex_chan_scan_param_set *start_chan;\r\nu32 tlv_idx, rates_size, cmd_no;\r\nu32 total_scan_time;\r\nu32 done_early;\r\nu8 radio_type;\r\nif (!scan_cfg_out || !chan_tlv_out || !scan_chan_list) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"info: Scan: Null detect: %p, %p, %p\n",\r\nscan_cfg_out, chan_tlv_out, scan_chan_list);\r\nreturn -1;\r\n}\r\nmwifiex_11h_get_csa_closed_channel(priv);\r\nchan_tlv_out->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\ntmp_chan_list = scan_chan_list;\r\nwhile (tmp_chan_list->chan_number) {\r\ntlv_idx = 0;\r\ntotal_scan_time = 0;\r\nradio_type = 0;\r\nchan_tlv_out->header.len = 0;\r\nstart_chan = tmp_chan_list;\r\ndone_early = false;\r\nwhile (tlv_idx < max_chan_per_scan &&\r\ntmp_chan_list->chan_number && !done_early) {\r\nif (tmp_chan_list->chan_number == priv->csa_chan) {\r\ntmp_chan_list++;\r\ncontinue;\r\n}\r\nradio_type = tmp_chan_list->radio_type;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: Scan: Chan(%3d), Radio(%d),\t"\r\n"Mode(%d, %d), Dur(%d)\n",\r\ntmp_chan_list->chan_number,\r\ntmp_chan_list->radio_type,\r\ntmp_chan_list->chan_scan_mode_bitmap\r\n& MWIFIEX_PASSIVE_SCAN,\r\n(tmp_chan_list->chan_scan_mode_bitmap\r\n& MWIFIEX_DISABLE_CHAN_FILT) >> 1,\r\nle16_to_cpu(tmp_chan_list->max_scan_time));\r\nmemcpy(chan_tlv_out->chan_scan_param + tlv_idx,\r\ntmp_chan_list,\r\nsizeof(chan_tlv_out->chan_scan_param));\r\nle16_add_cpu(&chan_tlv_out->header.len,\r\nsizeof(chan_tlv_out->chan_scan_param));\r\nscan_cfg_out->tlv_buf_len = (u32) ((u8 *) chan_tlv_out -\r\nscan_cfg_out->tlv_buf);\r\nscan_cfg_out->tlv_buf_len +=\r\n(sizeof(chan_tlv_out->header)\r\n+ le16_to_cpu(chan_tlv_out->header.len));\r\ntlv_idx++;\r\ntotal_scan_time +=\r\nle16_to_cpu(tmp_chan_list->max_scan_time);\r\ndone_early = false;\r\nif (!filtered_scan &&\r\n(tmp_chan_list->chan_number == 1 ||\r\ntmp_chan_list->chan_number == 6 ||\r\ntmp_chan_list->chan_number == 11))\r\ndone_early = true;\r\ntmp_chan_list++;\r\nif (!filtered_scan &&\r\n(tmp_chan_list->chan_number == 1 ||\r\ntmp_chan_list->chan_number == 6 ||\r\ntmp_chan_list->chan_number == 11))\r\ndone_early = true;\r\n}\r\nif (total_scan_time > MWIFIEX_MAX_TOTAL_SCAN_TIME) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"total scan time %dms\t"\r\n"is over limit (%dms), scan skipped\n",\r\ntotal_scan_time,\r\nMWIFIEX_MAX_TOTAL_SCAN_TIME);\r\nret = -1;\r\nbreak;\r\n}\r\nrates_size = mwifiex_append_rate_tlv(priv, scan_cfg_out,\r\nradio_type);\r\npriv->adapter->scan_channels = start_chan;\r\nif (priv->adapter->ext_scan)\r\ncmd_no = HostCmd_CMD_802_11_SCAN_EXT;\r\nelse\r\ncmd_no = HostCmd_CMD_802_11_SCAN;\r\nret = mwifiex_send_cmd(priv, cmd_no, HostCmd_ACT_GEN_SET,\r\n0, scan_cfg_out, false);\r\nscan_cfg_out->tlv_buf_len -=\r\nsizeof(struct mwifiex_ie_types_header) + rates_size;\r\nif (ret) {\r\nmwifiex_cancel_pending_scan_cmd(adapter);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void\r\nmwifiex_config_scan(struct mwifiex_private *priv,\r\nconst struct mwifiex_user_scan_cfg *user_scan_in,\r\nstruct mwifiex_scan_cmd_config *scan_cfg_out,\r\nstruct mwifiex_ie_types_chan_list_param_set **chan_list_out,\r\nstruct mwifiex_chan_scan_param_set *scan_chan_list,\r\nu8 *max_chan_per_scan, u8 *filtered_scan,\r\nu8 *scan_current_only)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_ie_types_num_probes *num_probes_tlv;\r\nstruct mwifiex_ie_types_scan_chan_gap *chan_gap_tlv;\r\nstruct mwifiex_ie_types_random_mac *random_mac_tlv;\r\nstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\r\nstruct mwifiex_ie_types_bssid_list *bssid_tlv;\r\nu8 *tlv_pos;\r\nu32 num_probes;\r\nu32 ssid_len;\r\nu32 chan_idx;\r\nu32 scan_type;\r\nu16 scan_dur;\r\nu8 channel;\r\nu8 radio_type;\r\nint i;\r\nu8 ssid_filter;\r\nstruct mwifiex_ie_types_htcap *ht_cap;\r\nstruct mwifiex_ie_types_bss_mode *bss_mode;\r\nconst u8 zero_mac[6] = {0, 0, 0, 0, 0, 0};\r\nscan_cfg_out->tlv_buf_len = 0;\r\ntlv_pos = scan_cfg_out->tlv_buf;\r\n*filtered_scan = false;\r\n*scan_current_only = false;\r\nif (user_scan_in) {\r\nssid_filter = true;\r\nscan_cfg_out->bss_mode =\r\n(u8)(user_scan_in->bss_mode ?: adapter->scan_mode);\r\nnum_probes = user_scan_in->num_probes ?: adapter->scan_probes;\r\nmemcpy(scan_cfg_out->specific_bssid,\r\nuser_scan_in->specific_bssid,\r\nsizeof(scan_cfg_out->specific_bssid));\r\nif (adapter->ext_scan &&\r\n!is_zero_ether_addr(scan_cfg_out->specific_bssid)) {\r\nbssid_tlv =\r\n(struct mwifiex_ie_types_bssid_list *)tlv_pos;\r\nbssid_tlv->header.type = cpu_to_le16(TLV_TYPE_BSSID);\r\nbssid_tlv->header.len = cpu_to_le16(ETH_ALEN);\r\nmemcpy(bssid_tlv->bssid, user_scan_in->specific_bssid,\r\nETH_ALEN);\r\ntlv_pos += sizeof(struct mwifiex_ie_types_bssid_list);\r\n}\r\nfor (i = 0; i < user_scan_in->num_ssids; i++) {\r\nssid_len = user_scan_in->ssid_list[i].ssid_len;\r\nwildcard_ssid_tlv =\r\n(struct mwifiex_ie_types_wildcard_ssid_params *)\r\ntlv_pos;\r\nwildcard_ssid_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_WILDCARDSSID);\r\nwildcard_ssid_tlv->header.len = cpu_to_le16(\r\n(u16) (ssid_len + sizeof(wildcard_ssid_tlv->\r\nmax_ssid_length)));\r\nif (ssid_len)\r\nwildcard_ssid_tlv->max_ssid_length = 0;\r\nelse\r\nwildcard_ssid_tlv->max_ssid_length =\r\nIEEE80211_MAX_SSID_LEN;\r\nif (!memcmp(user_scan_in->ssid_list[i].ssid,\r\n"DIRECT-", 7))\r\nwildcard_ssid_tlv->max_ssid_length = 0xfe;\r\nmemcpy(wildcard_ssid_tlv->ssid,\r\nuser_scan_in->ssid_list[i].ssid, ssid_len);\r\ntlv_pos += (sizeof(wildcard_ssid_tlv->header)\r\n+ le16_to_cpu(wildcard_ssid_tlv->header.len));\r\nmwifiex_dbg(adapter, INFO,\r\n"info: scan: ssid[%d]: %s, %d\n",\r\ni, wildcard_ssid_tlv->ssid,\r\nwildcard_ssid_tlv->max_ssid_length);\r\nif (!ssid_len && wildcard_ssid_tlv->max_ssid_length)\r\nssid_filter = false;\r\n}\r\nif ((i && ssid_filter) ||\r\n!is_zero_ether_addr(scan_cfg_out->specific_bssid))\r\n*filtered_scan = true;\r\nif (user_scan_in->scan_chan_gap) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: scan: channel gap = %d\n",\r\nuser_scan_in->scan_chan_gap);\r\n*max_chan_per_scan =\r\nMWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\r\nchan_gap_tlv = (void *)tlv_pos;\r\nchan_gap_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_SCAN_CHANNEL_GAP);\r\nchan_gap_tlv->header.len =\r\ncpu_to_le16(sizeof(chan_gap_tlv->chan_gap));\r\nchan_gap_tlv->chan_gap =\r\ncpu_to_le16((user_scan_in->scan_chan_gap));\r\ntlv_pos +=\r\nsizeof(struct mwifiex_ie_types_scan_chan_gap);\r\n}\r\nif (!ether_addr_equal(user_scan_in->random_mac, zero_mac)) {\r\nrandom_mac_tlv = (void *)tlv_pos;\r\nrandom_mac_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_RANDOM_MAC);\r\nrandom_mac_tlv->header.len =\r\ncpu_to_le16(sizeof(random_mac_tlv->mac));\r\nether_addr_copy(random_mac_tlv->mac,\r\nuser_scan_in->random_mac);\r\ntlv_pos +=\r\nsizeof(struct mwifiex_ie_types_random_mac);\r\n}\r\n} else {\r\nscan_cfg_out->bss_mode = (u8) adapter->scan_mode;\r\nnum_probes = adapter->scan_probes;\r\n}\r\nif (*filtered_scan)\r\n*max_chan_per_scan = MWIFIEX_MAX_CHANNELS_PER_SPECIFIC_SCAN;\r\nelse\r\n*max_chan_per_scan = MWIFIEX_DEF_CHANNELS_PER_SCAN_CMD;\r\nif (adapter->ext_scan) {\r\nbss_mode = (struct mwifiex_ie_types_bss_mode *)tlv_pos;\r\nbss_mode->header.type = cpu_to_le16(TLV_TYPE_BSS_MODE);\r\nbss_mode->header.len = cpu_to_le16(sizeof(bss_mode->bss_mode));\r\nbss_mode->bss_mode = scan_cfg_out->bss_mode;\r\ntlv_pos += sizeof(bss_mode->header) +\r\nle16_to_cpu(bss_mode->header.len);\r\n}\r\nif (num_probes) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: scan: num_probes = %d\n",\r\nnum_probes);\r\nnum_probes_tlv = (struct mwifiex_ie_types_num_probes *) tlv_pos;\r\nnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\r\nnum_probes_tlv->header.len =\r\ncpu_to_le16(sizeof(num_probes_tlv->num_probes));\r\nnum_probes_tlv->num_probes = cpu_to_le16((u16) num_probes);\r\ntlv_pos += sizeof(num_probes_tlv->header) +\r\nle16_to_cpu(num_probes_tlv->header.len);\r\n}\r\nif (ISSUPP_11NENABLED(priv->adapter->fw_cap_info) &&\r\n(priv->adapter->config_bands & BAND_GN ||\r\npriv->adapter->config_bands & BAND_AN)) {\r\nht_cap = (struct mwifiex_ie_types_htcap *) tlv_pos;\r\nmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\r\nht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\r\nht_cap->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_cap));\r\nradio_type =\r\nmwifiex_band_to_radio_type(priv->adapter->config_bands);\r\nmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\r\ntlv_pos += sizeof(struct mwifiex_ie_types_htcap);\r\n}\r\nmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_SCAN, &tlv_pos);\r\n*chan_list_out =\r\n(struct mwifiex_ie_types_chan_list_param_set *) tlv_pos;\r\nif (user_scan_in && user_scan_in->chan_list[0].chan_number) {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Scan: Using supplied channel list\n");\r\nfor (chan_idx = 0;\r\nchan_idx < MWIFIEX_USER_SCAN_CHAN_MAX &&\r\nuser_scan_in->chan_list[chan_idx].chan_number;\r\nchan_idx++) {\r\nchannel = user_scan_in->chan_list[chan_idx].chan_number;\r\nscan_chan_list[chan_idx].chan_number = channel;\r\nradio_type =\r\nuser_scan_in->chan_list[chan_idx].radio_type;\r\nscan_chan_list[chan_idx].radio_type = radio_type;\r\nscan_type = user_scan_in->chan_list[chan_idx].scan_type;\r\nif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n|= (MWIFIEX_PASSIVE_SCAN |\r\nMWIFIEX_HIDDEN_SSID_REPORT);\r\nelse\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n&= ~MWIFIEX_PASSIVE_SCAN;\r\nscan_chan_list[chan_idx].chan_scan_mode_bitmap\r\n|= MWIFIEX_DISABLE_CHAN_FILT;\r\nif (user_scan_in->chan_list[chan_idx].scan_time) {\r\nscan_dur = (u16) user_scan_in->\r\nchan_list[chan_idx].scan_time;\r\n} else {\r\nif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\r\nscan_dur = adapter->passive_scan_time;\r\nelse if (*filtered_scan)\r\nscan_dur = adapter->specific_scan_time;\r\nelse\r\nscan_dur = adapter->active_scan_time;\r\n}\r\nscan_chan_list[chan_idx].min_scan_time =\r\ncpu_to_le16(scan_dur);\r\nscan_chan_list[chan_idx].max_scan_time =\r\ncpu_to_le16(scan_dur);\r\n}\r\nif ((chan_idx == 1) &&\r\n(user_scan_in->chan_list[0].chan_number ==\r\npriv->curr_bss_params.bss_descriptor.channel)) {\r\n*scan_current_only = true;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Scan: Scanning current channel only\n");\r\n}\r\n} else {\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Scan: Creating full region channel list\n");\r\nmwifiex_scan_create_channel_list(priv, user_scan_in,\r\nscan_chan_list,\r\n*filtered_scan);\r\n}\r\n}\r\nstatic void\r\nmwifiex_ret_802_11_scan_get_tlv_ptrs(struct mwifiex_adapter *adapter,\r\nstruct mwifiex_ie_types_data *tlv,\r\nu32 tlv_buf_size, u32 req_tlv_type,\r\nstruct mwifiex_ie_types_data **tlv_data)\r\n{\r\nstruct mwifiex_ie_types_data *current_tlv;\r\nu32 tlv_buf_left;\r\nu32 tlv_type;\r\nu32 tlv_len;\r\ncurrent_tlv = tlv;\r\ntlv_buf_left = tlv_buf_size;\r\n*tlv_data = NULL;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SCAN_RESP: tlv_buf_size = %d\n",\r\ntlv_buf_size);\r\nwhile (tlv_buf_left >= sizeof(struct mwifiex_ie_types_header)) {\r\ntlv_type = le16_to_cpu(current_tlv->header.type);\r\ntlv_len = le16_to_cpu(current_tlv->header.len);\r\nif (sizeof(tlv->header) + tlv_len > tlv_buf_left) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"SCAN_RESP: TLV buffer corrupt\n");\r\nbreak;\r\n}\r\nif (req_tlv_type == tlv_type) {\r\nswitch (tlv_type) {\r\ncase TLV_TYPE_TSFTIMESTAMP:\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SCAN_RESP: TSF\t"\r\n"timestamp TLV, len = %d\n",\r\ntlv_len);\r\n*tlv_data = current_tlv;\r\nbreak;\r\ncase TLV_TYPE_CHANNELBANDLIST:\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SCAN_RESP: channel\t"\r\n"band list TLV, len = %d\n",\r\ntlv_len);\r\n*tlv_data = current_tlv;\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, ERROR,\r\n"SCAN_RESP: unhandled TLV = %d\n",\r\ntlv_type);\r\nreturn;\r\n}\r\n}\r\nif (*tlv_data)\r\nbreak;\r\ntlv_buf_left -= (sizeof(tlv->header) + tlv_len);\r\ncurrent_tlv =\r\n(struct mwifiex_ie_types_data *) (current_tlv->data +\r\ntlv_len);\r\n}\r\n}\r\nint mwifiex_update_bss_desc_with_ie(struct mwifiex_adapter *adapter,\r\nstruct mwifiex_bssdescriptor *bss_entry)\r\n{\r\nint ret = 0;\r\nu8 element_id;\r\nstruct ieee_types_fh_param_set *fh_param_set;\r\nstruct ieee_types_ds_param_set *ds_param_set;\r\nstruct ieee_types_cf_param_set *cf_param_set;\r\nstruct ieee_types_ibss_param_set *ibss_param_set;\r\nu8 *current_ptr;\r\nu8 *rate;\r\nu8 element_len;\r\nu16 total_ie_len;\r\nu8 bytes_to_copy;\r\nu8 rate_size;\r\nu8 found_data_rate_ie;\r\nu32 bytes_left;\r\nstruct ieee_types_vendor_specific *vendor_ie;\r\nconst u8 wpa_oui[4] = { 0x00, 0x50, 0xf2, 0x01 };\r\nconst u8 wmm_oui[4] = { 0x00, 0x50, 0xf2, 0x02 };\r\nfound_data_rate_ie = false;\r\nrate_size = 0;\r\ncurrent_ptr = bss_entry->beacon_buf;\r\nbytes_left = bss_entry->beacon_buf_size;\r\nwhile (bytes_left >= 2) {\r\nelement_id = *current_ptr;\r\nelement_len = *(current_ptr + 1);\r\ntotal_ie_len = element_len + sizeof(struct ieee_types_header);\r\nif (bytes_left < total_ie_len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"err: InterpretIE: in processing\t"\r\n"IE, bytes left < IE length\n");\r\nreturn -1;\r\n}\r\nswitch (element_id) {\r\ncase WLAN_EID_SSID:\r\nbss_entry->ssid.ssid_len = element_len;\r\nmemcpy(bss_entry->ssid.ssid, (current_ptr + 2),\r\nelement_len);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: InterpretIE: ssid: %-32s\n",\r\nbss_entry->ssid.ssid);\r\nbreak;\r\ncase WLAN_EID_SUPP_RATES:\r\nmemcpy(bss_entry->data_rates, current_ptr + 2,\r\nelement_len);\r\nmemcpy(bss_entry->supported_rates, current_ptr + 2,\r\nelement_len);\r\nrate_size = element_len;\r\nfound_data_rate_ie = true;\r\nbreak;\r\ncase WLAN_EID_FH_PARAMS:\r\nfh_param_set =\r\n(struct ieee_types_fh_param_set *) current_ptr;\r\nmemcpy(&bss_entry->phy_param_set.fh_param_set,\r\nfh_param_set,\r\nsizeof(struct ieee_types_fh_param_set));\r\nbreak;\r\ncase WLAN_EID_DS_PARAMS:\r\nds_param_set =\r\n(struct ieee_types_ds_param_set *) current_ptr;\r\nbss_entry->channel = ds_param_set->current_chan;\r\nmemcpy(&bss_entry->phy_param_set.ds_param_set,\r\nds_param_set,\r\nsizeof(struct ieee_types_ds_param_set));\r\nbreak;\r\ncase WLAN_EID_CF_PARAMS:\r\ncf_param_set =\r\n(struct ieee_types_cf_param_set *) current_ptr;\r\nmemcpy(&bss_entry->ss_param_set.cf_param_set,\r\ncf_param_set,\r\nsizeof(struct ieee_types_cf_param_set));\r\nbreak;\r\ncase WLAN_EID_IBSS_PARAMS:\r\nibss_param_set =\r\n(struct ieee_types_ibss_param_set *)\r\ncurrent_ptr;\r\nmemcpy(&bss_entry->ss_param_set.ibss_param_set,\r\nibss_param_set,\r\nsizeof(struct ieee_types_ibss_param_set));\r\nbreak;\r\ncase WLAN_EID_ERP_INFO:\r\nbss_entry->erp_flags = *(current_ptr + 2);\r\nbreak;\r\ncase WLAN_EID_PWR_CONSTRAINT:\r\nbss_entry->local_constraint = *(current_ptr + 2);\r\nbss_entry->sensed_11h = true;\r\nbreak;\r\ncase WLAN_EID_CHANNEL_SWITCH:\r\nbss_entry->chan_sw_ie_present = true;\r\ncase WLAN_EID_PWR_CAPABILITY:\r\ncase WLAN_EID_TPC_REPORT:\r\ncase WLAN_EID_QUIET:\r\nbss_entry->sensed_11h = true;\r\nbreak;\r\ncase WLAN_EID_EXT_SUPP_RATES:\r\nif (found_data_rate_ie) {\r\nif ((element_len + rate_size) >\r\nMWIFIEX_SUPPORTED_RATES)\r\nbytes_to_copy =\r\n(MWIFIEX_SUPPORTED_RATES -\r\nrate_size);\r\nelse\r\nbytes_to_copy = element_len;\r\nrate = (u8 *) bss_entry->data_rates;\r\nrate += rate_size;\r\nmemcpy(rate, current_ptr + 2, bytes_to_copy);\r\nrate = (u8 *) bss_entry->supported_rates;\r\nrate += rate_size;\r\nmemcpy(rate, current_ptr + 2, bytes_to_copy);\r\n}\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nvendor_ie = (struct ieee_types_vendor_specific *)\r\ncurrent_ptr;\r\nif (!memcmp\r\n(vendor_ie->vend_hdr.oui, wpa_oui,\r\nsizeof(wpa_oui))) {\r\nbss_entry->bcn_wpa_ie =\r\n(struct ieee_types_vendor_specific *)\r\ncurrent_ptr;\r\nbss_entry->wpa_offset = (u16)\r\n(current_ptr - bss_entry->beacon_buf);\r\n} else if (!memcmp(vendor_ie->vend_hdr.oui, wmm_oui,\r\nsizeof(wmm_oui))) {\r\nif (total_ie_len ==\r\nsizeof(struct ieee_types_wmm_parameter) ||\r\ntotal_ie_len ==\r\nsizeof(struct ieee_types_wmm_info))\r\nmemcpy((u8 *) &bss_entry->wmm_ie,\r\ncurrent_ptr, total_ie_len);\r\n}\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nbss_entry->bcn_rsn_ie =\r\n(struct ieee_types_generic *) current_ptr;\r\nbss_entry->rsn_offset = (u16) (current_ptr -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_BSS_AC_ACCESS_DELAY:\r\nbss_entry->bcn_wapi_ie =\r\n(struct ieee_types_generic *) current_ptr;\r\nbss_entry->wapi_offset = (u16) (current_ptr -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_HT_CAPABILITY:\r\nbss_entry->bcn_ht_cap = (struct ieee80211_ht_cap *)\r\n(current_ptr +\r\nsizeof(struct ieee_types_header));\r\nbss_entry->ht_cap_offset = (u16) (current_ptr +\r\nsizeof(struct ieee_types_header) -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_HT_OPERATION:\r\nbss_entry->bcn_ht_oper =\r\n(struct ieee80211_ht_operation *)(current_ptr +\r\nsizeof(struct ieee_types_header));\r\nbss_entry->ht_info_offset = (u16) (current_ptr +\r\nsizeof(struct ieee_types_header) -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_VHT_CAPABILITY:\r\nbss_entry->disable_11ac = false;\r\nbss_entry->bcn_vht_cap =\r\n(void *)(current_ptr +\r\nsizeof(struct ieee_types_header));\r\nbss_entry->vht_cap_offset =\r\n(u16)((u8 *)bss_entry->bcn_vht_cap -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_VHT_OPERATION:\r\nbss_entry->bcn_vht_oper =\r\n(void *)(current_ptr +\r\nsizeof(struct ieee_types_header));\r\nbss_entry->vht_info_offset =\r\n(u16)((u8 *)bss_entry->bcn_vht_oper -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_BSS_COEX_2040:\r\nbss_entry->bcn_bss_co_2040 = current_ptr;\r\nbss_entry->bss_co_2040_offset =\r\n(u16) (current_ptr - bss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_EXT_CAPABILITY:\r\nbss_entry->bcn_ext_cap = current_ptr;\r\nbss_entry->ext_cap_offset =\r\n(u16) (current_ptr - bss_entry->beacon_buf);\r\nbreak;\r\ncase WLAN_EID_OPMODE_NOTIF:\r\nbss_entry->oper_mode = (void *)current_ptr;\r\nbss_entry->oper_mode_offset =\r\n(u16)((u8 *)bss_entry->oper_mode -\r\nbss_entry->beacon_buf);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncurrent_ptr += element_len + 2;\r\nbytes_left -= (element_len + 2);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8\r\nmwifiex_radio_type_to_band(u8 radio_type)\r\n{\r\nswitch (radio_type) {\r\ncase HostCmd_SCAN_RADIO_TYPE_A:\r\nreturn BAND_A;\r\ncase HostCmd_SCAN_RADIO_TYPE_BG:\r\ndefault:\r\nreturn BAND_G;\r\n}\r\n}\r\nint mwifiex_scan_networks(struct mwifiex_private *priv,\r\nconst struct mwifiex_user_scan_cfg *user_scan_in)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct cmd_ctrl_node *cmd_node;\r\nunion mwifiex_scan_cmd_config_tlv *scan_cfg_out;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_list_out;\r\nstruct mwifiex_chan_scan_param_set *scan_chan_list;\r\nu8 filtered_scan;\r\nu8 scan_current_chan_only;\r\nu8 max_chan_per_scan;\r\nunsigned long flags;\r\nif (adapter->scan_processing) {\r\nmwifiex_dbg(adapter, WARN,\r\n"cmd: Scan already in process...\n");\r\nreturn -EBUSY;\r\n}\r\nif (priv->scan_block) {\r\nmwifiex_dbg(adapter, WARN,\r\n"cmd: Scan is blocked during association...\n");\r\nreturn -EBUSY;\r\n}\r\nif (adapter->surprise_removed || adapter->is_cmd_timedout) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"Ignore scan. Card removed or firmware in bad state\n");\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = true;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nscan_cfg_out = kzalloc(sizeof(union mwifiex_scan_cmd_config_tlv),\r\nGFP_KERNEL);\r\nif (!scan_cfg_out) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nscan_chan_list = kcalloc(MWIFIEX_USER_SCAN_CHAN_MAX,\r\nsizeof(struct mwifiex_chan_scan_param_set),\r\nGFP_KERNEL);\r\nif (!scan_chan_list) {\r\nkfree(scan_cfg_out);\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nmwifiex_config_scan(priv, user_scan_in, &scan_cfg_out->config,\r\n&chan_list_out, scan_chan_list, &max_chan_per_scan,\r\n&filtered_scan, &scan_current_chan_only);\r\nret = mwifiex_scan_channel_list(priv, max_chan_per_scan, filtered_scan,\r\n&scan_cfg_out->config, chan_list_out,\r\nscan_chan_list);\r\nif (!ret) {\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nif (!list_empty(&adapter->scan_pending_q)) {\r\ncmd_node = list_first_entry(&adapter->scan_pending_q,\r\nstruct cmd_ctrl_node, list);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nflags);\r\nmwifiex_insert_cmd_to_pending_q(adapter, cmd_node,\r\ntrue);\r\nqueue_work(adapter->workqueue, &adapter->main_work);\r\nif (!priv->scan_request) {\r\nmwifiex_dbg(adapter, INFO,\r\n"wait internal scan\n");\r\nmwifiex_wait_queue_complete(adapter, cmd_node);\r\n}\r\n} else {\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nflags);\r\n}\r\n}\r\nkfree(scan_cfg_out);\r\nkfree(scan_chan_list);\r\ndone:\r\nif (ret) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nint mwifiex_cmd_802_11_scan(struct host_cmd_ds_command *cmd,\r\nstruct mwifiex_scan_cmd_config *scan_cfg)\r\n{\r\nstruct host_cmd_ds_802_11_scan *scan_cmd = &cmd->params.scan;\r\nscan_cmd->bss_mode = scan_cfg->bss_mode;\r\nmemcpy(scan_cmd->bssid, scan_cfg->specific_bssid,\r\nsizeof(scan_cmd->bssid));\r\nmemcpy(scan_cmd->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN);\r\ncmd->size = cpu_to_le16((u16) (sizeof(scan_cmd->bss_mode)\r\n+ sizeof(scan_cmd->bssid)\r\n+ scan_cfg->tlv_buf_len + S_DS_GEN));\r\nreturn 0;\r\n}\r\nint mwifiex_check_network_compatibility(struct mwifiex_private *priv,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nint ret = -1;\r\nif (!bss_desc)\r\nreturn -1;\r\nif ((mwifiex_get_cfp(priv, (u8) bss_desc->bss_band,\r\n(u16) bss_desc->channel, 0))) {\r\nswitch (priv->bss_mode) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\nret = mwifiex_is_network_compatible(priv, bss_desc,\r\npriv->bss_mode);\r\nif (ret)\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Incompatible network settings\n");\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic bool mwifiex_is_hidden_ssid(struct cfg80211_ssid *ssid)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < ssid->ssid_len; idx++) {\r\nif (ssid->ssid[idx])\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int mwifiex_save_hidden_ssid_channels(struct mwifiex_private *priv,\r\nstruct cfg80211_bss *bss)\r\n{\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nint ret;\r\nint chid;\r\nbss_desc = kzalloc(sizeof(*bss_desc), GFP_KERNEL);\r\nif (!bss_desc)\r\nreturn -ENOMEM;\r\nret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\r\nif (ret)\r\ngoto done;\r\nif (mwifiex_is_hidden_ssid(&bss_desc->ssid)) {\r\nmwifiex_dbg(priv->adapter, INFO, "found hidden SSID\n");\r\nfor (chid = 0 ; chid < MWIFIEX_USER_SCAN_CHAN_MAX; chid++) {\r\nif (priv->hidden_chan[chid].chan_number ==\r\nbss->channel->hw_value)\r\nbreak;\r\nif (!priv->hidden_chan[chid].chan_number) {\r\npriv->hidden_chan[chid].chan_number =\r\nbss->channel->hw_value;\r\npriv->hidden_chan[chid].radio_type =\r\nbss->channel->band;\r\npriv->hidden_chan[chid].scan_type =\r\nMWIFIEX_SCAN_TYPE_ACTIVE;\r\nbreak;\r\n}\r\n}\r\n}\r\ndone:\r\nkfree(bss_desc->beacon_buf);\r\nkfree(bss_desc);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_update_curr_bss_params(struct mwifiex_private *priv,\r\nstruct cfg80211_bss *bss)\r\n{\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nint ret;\r\nunsigned long flags;\r\nbss_desc = kzalloc(sizeof(struct mwifiex_bssdescriptor), GFP_KERNEL);\r\nif (!bss_desc)\r\nreturn -ENOMEM;\r\nret = mwifiex_fill_new_bss_desc(priv, bss, bss_desc);\r\nif (ret)\r\ngoto done;\r\nret = mwifiex_check_network_compatibility(priv, bss_desc);\r\nif (ret)\r\ngoto done;\r\nspin_lock_irqsave(&priv->curr_bcn_buf_lock, flags);\r\nmemcpy(&priv->curr_bss_params.bss_descriptor, bss_desc,\r\nsizeof(priv->curr_bss_params.bss_descriptor));\r\nmwifiex_save_curr_bcn(priv);\r\nspin_unlock_irqrestore(&priv->curr_bcn_buf_lock, flags);\r\ndone:\r\nkfree(bss_desc->beacon_buf);\r\nkfree(bss_desc);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_parse_single_response_buf(struct mwifiex_private *priv, u8 **bss_info,\r\nu32 *bytes_left, u64 fw_tsf, u8 *radio_type,\r\nbool ext_scan, s32 rssi_val)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_chan_freq_power *cfp;\r\nstruct cfg80211_bss *bss;\r\nu8 bssid[ETH_ALEN];\r\ns32 rssi;\r\nconst u8 *ie_buf;\r\nsize_t ie_len;\r\nu16 channel = 0;\r\nu16 beacon_size = 0;\r\nu32 curr_bcn_bytes;\r\nu32 freq;\r\nu16 beacon_period;\r\nu16 cap_info_bitmap;\r\nu8 *current_ptr;\r\nu64 timestamp;\r\nstruct mwifiex_fixed_bcn_param *bcn_param;\r\nstruct mwifiex_bss_priv *bss_priv;\r\nif (*bytes_left >= sizeof(beacon_size)) {\r\nbeacon_size = le16_to_cpu(*(__le16 *)(*bss_info));\r\n*bytes_left -= sizeof(beacon_size);\r\n*bss_info += sizeof(beacon_size);\r\n}\r\nif (!beacon_size || beacon_size > *bytes_left) {\r\n*bss_info += *bytes_left;\r\n*bytes_left = 0;\r\nreturn -EFAULT;\r\n}\r\ncurrent_ptr = *bss_info;\r\n*bss_info += beacon_size;\r\n*bytes_left -= beacon_size;\r\ncurr_bcn_bytes = beacon_size;\r\nif (curr_bcn_bytes < ETH_ALEN + sizeof(u8) +\r\nsizeof(struct mwifiex_fixed_bcn_param)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"InterpretIE: not enough bytes left\n");\r\nreturn -EFAULT;\r\n}\r\nmemcpy(bssid, current_ptr, ETH_ALEN);\r\ncurrent_ptr += ETH_ALEN;\r\ncurr_bcn_bytes -= ETH_ALEN;\r\nif (!ext_scan) {\r\nrssi = (s32) *current_ptr;\r\nrssi = (-rssi) * 100;\r\ncurrent_ptr += sizeof(u8);\r\ncurr_bcn_bytes -= sizeof(u8);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: InterpretIE: RSSI=%d\n", rssi);\r\n} else {\r\nrssi = rssi_val;\r\n}\r\nbcn_param = (struct mwifiex_fixed_bcn_param *)current_ptr;\r\ncurrent_ptr += sizeof(*bcn_param);\r\ncurr_bcn_bytes -= sizeof(*bcn_param);\r\ntimestamp = le64_to_cpu(bcn_param->timestamp);\r\nbeacon_period = le16_to_cpu(bcn_param->beacon_period);\r\ncap_info_bitmap = le16_to_cpu(bcn_param->cap_info_bitmap);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: InterpretIE: capabilities=0x%X\n",\r\ncap_info_bitmap);\r\nie_buf = current_ptr;\r\nie_len = curr_bcn_bytes;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: InterpretIE: IELength for this AP = %d\n",\r\ncurr_bcn_bytes);\r\nwhile (curr_bcn_bytes >= sizeof(struct ieee_types_header)) {\r\nu8 element_id, element_len;\r\nelement_id = *current_ptr;\r\nelement_len = *(current_ptr + 1);\r\nif (curr_bcn_bytes < element_len +\r\nsizeof(struct ieee_types_header)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"%s: bytes left < IE length\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nif (element_id == WLAN_EID_DS_PARAMS) {\r\nchannel = *(current_ptr +\r\nsizeof(struct ieee_types_header));\r\nbreak;\r\n}\r\ncurrent_ptr += element_len + sizeof(struct ieee_types_header);\r\ncurr_bcn_bytes -= element_len +\r\nsizeof(struct ieee_types_header);\r\n}\r\nif (channel) {\r\nstruct ieee80211_channel *chan;\r\nu8 band;\r\nif (channel == priv->csa_chan) {\r\nmwifiex_dbg(adapter, WARN,\r\n"Dropping entry on csa closed channel\n");\r\nreturn 0;\r\n}\r\nband = BAND_G;\r\nif (radio_type)\r\nband = mwifiex_radio_type_to_band(*radio_type &\r\n(BIT(0) | BIT(1)));\r\ncfp = mwifiex_get_cfp(priv, band, channel, 0);\r\nfreq = cfp ? cfp->freq : 0;\r\nchan = ieee80211_get_channel(priv->wdev.wiphy, freq);\r\nif (chan && !(chan->flags & IEEE80211_CHAN_DISABLED)) {\r\nbss = cfg80211_inform_bss(priv->wdev.wiphy,\r\nchan, CFG80211_BSS_FTYPE_UNKNOWN,\r\nbssid, timestamp,\r\ncap_info_bitmap, beacon_period,\r\nie_buf, ie_len, rssi, GFP_KERNEL);\r\nif (bss) {\r\nbss_priv = (struct mwifiex_bss_priv *)bss->priv;\r\nbss_priv->band = band;\r\nbss_priv->fw_tsf = fw_tsf;\r\nif (priv->media_connected &&\r\n!memcmp(bssid, priv->curr_bss_params.\r\nbss_descriptor.mac_address,\r\nETH_ALEN))\r\nmwifiex_update_curr_bss_params(priv,\r\nbss);\r\ncfg80211_put_bss(priv->wdev.wiphy, bss);\r\n}\r\nif ((chan->flags & IEEE80211_CHAN_RADAR) ||\r\n(chan->flags & IEEE80211_CHAN_NO_IR)) {\r\nmwifiex_dbg(adapter, INFO,\r\n"radar or passive channel %d\n",\r\nchannel);\r\nmwifiex_save_hidden_ssid_channels(priv, bss);\r\n}\r\n}\r\n} else {\r\nmwifiex_dbg(adapter, WARN, "missing BSS channel IE\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void mwifiex_complete_scan(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nadapter->survey_idx = 0;\r\nif (adapter->curr_cmd->wait_q_enabled) {\r\nadapter->cmd_wait_q.status = 0;\r\nif (!priv->scan_request) {\r\nmwifiex_dbg(adapter, INFO,\r\n"complete internal scan\n");\r\nmwifiex_complete_cmd(adapter, adapter->curr_cmd);\r\n}\r\n}\r\n}\r\nstatic int\r\nmwifiex_active_scan_req_for_passive_chan(struct mwifiex_private *priv)\r\n{\r\nint ret;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu8 id = 0;\r\nstruct mwifiex_user_scan_cfg *user_scan_cfg;\r\nif (adapter->active_scan_triggered || !priv->scan_request ||\r\npriv->scan_aborting) {\r\nadapter->active_scan_triggered = false;\r\nreturn 0;\r\n}\r\nif (!priv->hidden_chan[0].chan_number) {\r\nmwifiex_dbg(adapter, INFO, "No BSS with hidden SSID found on DFS channels\n");\r\nreturn 0;\r\n}\r\nuser_scan_cfg = kzalloc(sizeof(*user_scan_cfg), GFP_KERNEL);\r\nif (!user_scan_cfg)\r\nreturn -ENOMEM;\r\nmemset(user_scan_cfg, 0, sizeof(*user_scan_cfg));\r\nfor (id = 0; id < MWIFIEX_USER_SCAN_CHAN_MAX; id++) {\r\nif (!priv->hidden_chan[id].chan_number)\r\nbreak;\r\nmemcpy(&user_scan_cfg->chan_list[id],\r\n&priv->hidden_chan[id],\r\nsizeof(struct mwifiex_user_scan_chan));\r\n}\r\nadapter->active_scan_triggered = true;\r\nether_addr_copy(user_scan_cfg->random_mac, priv->random_mac);\r\nuser_scan_cfg->num_ssids = priv->scan_request->n_ssids;\r\nuser_scan_cfg->ssid_list = priv->scan_request->ssids;\r\nret = mwifiex_scan_networks(priv, user_scan_cfg);\r\nkfree(user_scan_cfg);\r\nmemset(&priv->hidden_chan, 0, sizeof(priv->hidden_chan));\r\nif (ret) {\r\ndev_err(priv->adapter->dev, "scan failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mwifiex_check_next_scan_command(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct cmd_ctrl_node *cmd_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nif (list_empty(&adapter->scan_pending_q)) {\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nmwifiex_active_scan_req_for_passive_chan(priv);\r\nif (!adapter->ext_scan)\r\nmwifiex_complete_scan(priv);\r\nif (priv->scan_request) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = false,\r\n};\r\nmwifiex_dbg(adapter, INFO,\r\n"info: notifying scan done\n");\r\ncfg80211_scan_done(priv->scan_request, &info);\r\npriv->scan_request = NULL;\r\npriv->scan_aborting = false;\r\n} else {\r\npriv->scan_aborting = false;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: scan already aborted\n");\r\n}\r\n} else if ((priv->scan_aborting && !priv->scan_request) ||\r\npriv->scan_block) {\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nmwifiex_cancel_pending_scan_cmd(adapter);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nif (!adapter->active_scan_triggered) {\r\nif (priv->scan_request) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = true,\r\n};\r\nmwifiex_dbg(adapter, INFO,\r\n"info: aborting scan\n");\r\ncfg80211_scan_done(priv->scan_request, &info);\r\npriv->scan_request = NULL;\r\npriv->scan_aborting = false;\r\n} else {\r\npriv->scan_aborting = false;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: scan already aborted\n");\r\n}\r\n}\r\n} else {\r\ncmd_node = list_first_entry(&adapter->scan_pending_q,\r\nstruct cmd_ctrl_node, list);\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nmwifiex_insert_cmd_to_pending_q(adapter, cmd_node, true);\r\n}\r\nreturn;\r\n}\r\nvoid mwifiex_cancel_scan(struct mwifiex_adapter *adapter)\r\n{\r\nstruct mwifiex_private *priv;\r\nunsigned long cmd_flags;\r\nint i;\r\nmwifiex_cancel_pending_scan_cmd(adapter);\r\nif (adapter->scan_processing) {\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, cmd_flags);\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nif (priv->scan_request) {\r\nstruct cfg80211_scan_info info = {\r\n.aborted = true,\r\n};\r\nmwifiex_dbg(adapter, INFO,\r\n"info: aborting scan\n");\r\ncfg80211_scan_done(priv->scan_request, &info);\r\npriv->scan_request = NULL;\r\npriv->scan_aborting = false;\r\n}\r\n}\r\n}\r\n}\r\nint mwifiex_ret_802_11_scan(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_scan_rsp *scan_rsp;\r\nstruct mwifiex_ie_types_data *tlv_data;\r\nstruct mwifiex_ie_types_tsf_timestamp *tsf_tlv;\r\nu8 *bss_info;\r\nu32 scan_resp_size;\r\nu32 bytes_left;\r\nu32 idx;\r\nu32 tlv_buf_size;\r\nstruct mwifiex_ie_types_chan_band_list_param_set *chan_band_tlv;\r\nstruct chan_band_param_set *chan_band;\r\nu8 is_bgscan_resp;\r\n__le64 fw_tsf = 0;\r\nu8 *radio_type;\r\nstruct cfg80211_wowlan_nd_match *pmatch;\r\nstruct cfg80211_sched_scan_request *nd_config = NULL;\r\nis_bgscan_resp = (le16_to_cpu(resp->command)\r\n== HostCmd_CMD_802_11_BG_SCAN_QUERY);\r\nif (is_bgscan_resp)\r\nscan_rsp = &resp->params.bg_scan_query_resp.scan_resp;\r\nelse\r\nscan_rsp = &resp->params.scan_resp;\r\nif (scan_rsp->number_of_sets > MWIFIEX_MAX_AP) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"SCAN_RESP: too many AP returned (%d)\n",\r\nscan_rsp->number_of_sets);\r\nret = -1;\r\ngoto check_next_scan;\r\n}\r\nmwifiex_11h_get_csa_closed_channel(priv);\r\nbytes_left = le16_to_cpu(scan_rsp->bss_descript_size);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SCAN_RESP: bss_descript_size %d\n",\r\nbytes_left);\r\nscan_resp_size = le16_to_cpu(resp->size);\r\nmwifiex_dbg(adapter, INFO,\r\n"info: SCAN_RESP: returned %d APs before parsing\n",\r\nscan_rsp->number_of_sets);\r\nbss_info = scan_rsp->bss_desc_and_tlv_buffer;\r\ntlv_buf_size = scan_resp_size - (bytes_left\r\n+ sizeof(scan_rsp->bss_descript_size)\r\n+ sizeof(scan_rsp->number_of_sets)\r\n+ S_DS_GEN);\r\ntlv_data = (struct mwifiex_ie_types_data *) (scan_rsp->\r\nbss_desc_and_tlv_buffer +\r\nbytes_left);\r\nmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\r\nTLV_TYPE_TSFTIMESTAMP,\r\n(struct mwifiex_ie_types_data **)\r\n&tsf_tlv);\r\nmwifiex_ret_802_11_scan_get_tlv_ptrs(adapter, tlv_data, tlv_buf_size,\r\nTLV_TYPE_CHANNELBANDLIST,\r\n(struct mwifiex_ie_types_data **)\r\n&chan_band_tlv);\r\n#ifdef CONFIG_PM\r\nif (priv->wdev.wiphy->wowlan_config)\r\nnd_config = priv->wdev.wiphy->wowlan_config->nd_config;\r\n#endif\r\nif (nd_config) {\r\nadapter->nd_info =\r\nkzalloc(sizeof(struct cfg80211_wowlan_nd_match) +\r\nsizeof(struct cfg80211_wowlan_nd_match *) *\r\nscan_rsp->number_of_sets, GFP_ATOMIC);\r\nif (adapter->nd_info)\r\nadapter->nd_info->n_matches = scan_rsp->number_of_sets;\r\n}\r\nfor (idx = 0; idx < scan_rsp->number_of_sets && bytes_left; idx++) {\r\nif (tsf_tlv)\r\nmemcpy(&fw_tsf, &tsf_tlv->tsf_data[idx * TSF_DATA_SIZE],\r\nsizeof(fw_tsf));\r\nif (chan_band_tlv) {\r\nchan_band = &chan_band_tlv->chan_band_param[idx];\r\nradio_type = &chan_band->radio_type;\r\n} else {\r\nradio_type = NULL;\r\n}\r\nif (chan_band_tlv && adapter->nd_info) {\r\nadapter->nd_info->matches[idx] =\r\nkzalloc(sizeof(*pmatch) + sizeof(u32),\r\nGFP_ATOMIC);\r\npmatch = adapter->nd_info->matches[idx];\r\nif (pmatch) {\r\npmatch->n_channels = 1;\r\npmatch->channels[0] = chan_band->chan_number;\r\n}\r\n}\r\nret = mwifiex_parse_single_response_buf(priv, &bss_info,\r\n&bytes_left,\r\nle64_to_cpu(fw_tsf),\r\nradio_type, false, 0);\r\nif (ret)\r\ngoto check_next_scan;\r\n}\r\ncheck_next_scan:\r\nmwifiex_check_next_scan_command(priv);\r\nreturn ret;\r\n}\r\nint mwifiex_cmd_802_11_scan_ext(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nvoid *data_buf)\r\n{\r\nstruct host_cmd_ds_802_11_scan_ext *ext_scan = &cmd->params.ext_scan;\r\nstruct mwifiex_scan_cmd_config *scan_cfg = data_buf;\r\nmemcpy(ext_scan->tlv_buffer, scan_cfg->tlv_buf, scan_cfg->tlv_buf_len);\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_SCAN_EXT);\r\ncmd->size = cpu_to_le16((u16)(sizeof(ext_scan->reserved)\r\n+ scan_cfg->tlv_buf_len + S_DS_GEN));\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_802_11_bg_scan_config(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nvoid *data_buf)\r\n{\r\nstruct host_cmd_ds_802_11_bg_scan_config *bgscan_config =\r\n&cmd->params.bg_scan_config;\r\nstruct mwifiex_bg_scan_cfg *bgscan_cfg_in = data_buf;\r\nu8 *tlv_pos = bgscan_config->tlv;\r\nu8 num_probes;\r\nu32 ssid_len, chan_idx, scan_type, scan_dur, chan_num;\r\nint i;\r\nstruct mwifiex_ie_types_num_probes *num_probes_tlv;\r\nstruct mwifiex_ie_types_repeat_count *repeat_count_tlv;\r\nstruct mwifiex_ie_types_min_rssi_threshold *rssi_threshold_tlv;\r\nstruct mwifiex_ie_types_bgscan_start_later *start_later_tlv;\r\nstruct mwifiex_ie_types_wildcard_ssid_params *wildcard_ssid_tlv;\r\nstruct mwifiex_ie_types_chan_list_param_set *chan_list_tlv;\r\nstruct mwifiex_chan_scan_param_set *temp_chan;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);\r\ncmd->size = cpu_to_le16(sizeof(*bgscan_config) + S_DS_GEN);\r\nbgscan_config->action = cpu_to_le16(bgscan_cfg_in->action);\r\nbgscan_config->enable = bgscan_cfg_in->enable;\r\nbgscan_config->bss_type = bgscan_cfg_in->bss_type;\r\nbgscan_config->scan_interval =\r\ncpu_to_le32(bgscan_cfg_in->scan_interval);\r\nbgscan_config->report_condition =\r\ncpu_to_le32(bgscan_cfg_in->report_condition);\r\nif (!bgscan_config->enable)\r\nreturn 0;\r\nbgscan_config->chan_per_scan = bgscan_cfg_in->chan_per_scan;\r\nnum_probes = (bgscan_cfg_in->num_probes ? bgscan_cfg_in->\r\nnum_probes : priv->adapter->scan_probes);\r\nif (num_probes) {\r\nnum_probes_tlv = (struct mwifiex_ie_types_num_probes *)tlv_pos;\r\nnum_probes_tlv->header.type = cpu_to_le16(TLV_TYPE_NUMPROBES);\r\nnum_probes_tlv->header.len =\r\ncpu_to_le16(sizeof(num_probes_tlv->num_probes));\r\nnum_probes_tlv->num_probes = cpu_to_le16((u16)num_probes);\r\ntlv_pos += sizeof(num_probes_tlv->header) +\r\nle16_to_cpu(num_probes_tlv->header.len);\r\n}\r\nif (bgscan_cfg_in->repeat_count) {\r\nrepeat_count_tlv =\r\n(struct mwifiex_ie_types_repeat_count *)tlv_pos;\r\nrepeat_count_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_REPEAT_COUNT);\r\nrepeat_count_tlv->header.len =\r\ncpu_to_le16(sizeof(repeat_count_tlv->repeat_count));\r\nrepeat_count_tlv->repeat_count =\r\ncpu_to_le16(bgscan_cfg_in->repeat_count);\r\ntlv_pos += sizeof(repeat_count_tlv->header) +\r\nle16_to_cpu(repeat_count_tlv->header.len);\r\n}\r\nif (bgscan_cfg_in->rssi_threshold) {\r\nrssi_threshold_tlv =\r\n(struct mwifiex_ie_types_min_rssi_threshold *)tlv_pos;\r\nrssi_threshold_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_RSSI_LOW);\r\nrssi_threshold_tlv->header.len =\r\ncpu_to_le16(sizeof(rssi_threshold_tlv->rssi_threshold));\r\nrssi_threshold_tlv->rssi_threshold =\r\ncpu_to_le16(bgscan_cfg_in->rssi_threshold);\r\ntlv_pos += sizeof(rssi_threshold_tlv->header) +\r\nle16_to_cpu(rssi_threshold_tlv->header.len);\r\n}\r\nfor (i = 0; i < bgscan_cfg_in->num_ssids; i++) {\r\nssid_len = bgscan_cfg_in->ssid_list[i].ssid.ssid_len;\r\nwildcard_ssid_tlv =\r\n(struct mwifiex_ie_types_wildcard_ssid_params *)tlv_pos;\r\nwildcard_ssid_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_WILDCARDSSID);\r\nwildcard_ssid_tlv->header.len = cpu_to_le16(\r\n(u16)(ssid_len + sizeof(wildcard_ssid_tlv->\r\nmax_ssid_length)));\r\nif (ssid_len)\r\nwildcard_ssid_tlv->max_ssid_length = 0;\r\nelse\r\nwildcard_ssid_tlv->max_ssid_length =\r\nIEEE80211_MAX_SSID_LEN;\r\nmemcpy(wildcard_ssid_tlv->ssid,\r\nbgscan_cfg_in->ssid_list[i].ssid.ssid, ssid_len);\r\ntlv_pos += (sizeof(wildcard_ssid_tlv->header)\r\n+ le16_to_cpu(wildcard_ssid_tlv->header.len));\r\n}\r\nchan_list_tlv = (struct mwifiex_ie_types_chan_list_param_set *)tlv_pos;\r\nif (bgscan_cfg_in->chan_list[0].chan_number) {\r\ndev_dbg(priv->adapter->dev, "info: bgscan: Using supplied channel list\n");\r\nchan_list_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\r\nfor (chan_idx = 0;\r\nchan_idx < MWIFIEX_BG_SCAN_CHAN_MAX &&\r\nbgscan_cfg_in->chan_list[chan_idx].chan_number;\r\nchan_idx++) {\r\ntemp_chan = chan_list_tlv->chan_scan_param + chan_idx;\r\nle16_add_cpu(&chan_list_tlv->header.len,\r\nsizeof(chan_list_tlv->chan_scan_param));\r\ntemp_chan->chan_number =\r\nbgscan_cfg_in->chan_list[chan_idx].chan_number;\r\ntemp_chan->radio_type =\r\nbgscan_cfg_in->chan_list[chan_idx].radio_type;\r\nscan_type =\r\nbgscan_cfg_in->chan_list[chan_idx].scan_type;\r\nif (scan_type == MWIFIEX_SCAN_TYPE_PASSIVE)\r\ntemp_chan->chan_scan_mode_bitmap\r\n|= MWIFIEX_PASSIVE_SCAN;\r\nelse\r\ntemp_chan->chan_scan_mode_bitmap\r\n&= ~MWIFIEX_PASSIVE_SCAN;\r\nif (bgscan_cfg_in->chan_list[chan_idx].scan_time) {\r\nscan_dur = (u16)bgscan_cfg_in->\r\nchan_list[chan_idx].scan_time;\r\n} else {\r\nscan_dur = (scan_type ==\r\nMWIFIEX_SCAN_TYPE_PASSIVE) ?\r\npriv->adapter->passive_scan_time :\r\npriv->adapter->specific_scan_time;\r\n}\r\ntemp_chan->min_scan_time = cpu_to_le16(scan_dur);\r\ntemp_chan->max_scan_time = cpu_to_le16(scan_dur);\r\n}\r\n} else {\r\ndev_dbg(priv->adapter->dev,\r\n"info: bgscan: Creating full region channel list\n");\r\nchan_num =\r\nmwifiex_bgscan_create_channel_list(priv, bgscan_cfg_in,\r\nchan_list_tlv->\r\nchan_scan_param);\r\nle16_add_cpu(&chan_list_tlv->header.len,\r\nchan_num *\r\nsizeof(chan_list_tlv->chan_scan_param[0]));\r\n}\r\ntlv_pos += (sizeof(chan_list_tlv->header)\r\n+ le16_to_cpu(chan_list_tlv->header.len));\r\nif (bgscan_cfg_in->start_later) {\r\nstart_later_tlv =\r\n(struct mwifiex_ie_types_bgscan_start_later *)tlv_pos;\r\nstart_later_tlv->header.type =\r\ncpu_to_le16(TLV_TYPE_BGSCAN_START_LATER);\r\nstart_later_tlv->header.len =\r\ncpu_to_le16(sizeof(start_later_tlv->start_later));\r\nstart_later_tlv->start_later =\r\ncpu_to_le16(bgscan_cfg_in->start_later);\r\ntlv_pos += sizeof(start_later_tlv->header) +\r\nle16_to_cpu(start_later_tlv->header.len);\r\n}\r\nmwifiex_cmd_append_vsie_tlv(priv, MWIFIEX_VSIE_MASK_BGSCAN, &tlv_pos);\r\nle16_add_cpu(&cmd->size, tlv_pos - bgscan_config->tlv);\r\nreturn 0;\r\n}\r\nint mwifiex_stop_bg_scan(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_bg_scan_cfg *bgscan_cfg;\r\nif (!priv->sched_scanning) {\r\ndev_dbg(priv->adapter->dev, "bgscan already stopped!\n");\r\nreturn 0;\r\n}\r\nbgscan_cfg = kzalloc(sizeof(*bgscan_cfg), GFP_KERNEL);\r\nif (!bgscan_cfg)\r\nreturn -ENOMEM;\r\nbgscan_cfg->bss_type = MWIFIEX_BSS_MODE_INFRA;\r\nbgscan_cfg->action = MWIFIEX_BGSCAN_ACT_SET;\r\nbgscan_cfg->enable = false;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_BG_SCAN_CONFIG,\r\nHostCmd_ACT_GEN_SET, 0, bgscan_cfg, true)) {\r\nkfree(bgscan_cfg);\r\nreturn -EFAULT;\r\n}\r\nkfree(bgscan_cfg);\r\npriv->sched_scanning = false;\r\nreturn 0;\r\n}\r\nstatic void\r\nmwifiex_update_chan_statistics(struct mwifiex_private *priv,\r\nstruct mwifiex_ietypes_chanstats *tlv_stat)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu8 i, num_chan;\r\nstruct mwifiex_fw_chan_stats *fw_chan_stats;\r\nstruct mwifiex_chan_stats chan_stats;\r\nfw_chan_stats = (void *)((u8 *)tlv_stat +\r\nsizeof(struct mwifiex_ie_types_header));\r\nnum_chan = le16_to_cpu(tlv_stat->header.len) /\r\nsizeof(struct mwifiex_chan_stats);\r\nfor (i = 0 ; i < num_chan; i++) {\r\nchan_stats.chan_num = fw_chan_stats->chan_num;\r\nchan_stats.bandcfg = fw_chan_stats->bandcfg;\r\nchan_stats.flags = fw_chan_stats->flags;\r\nchan_stats.noise = fw_chan_stats->noise;\r\nchan_stats.total_bss = le16_to_cpu(fw_chan_stats->total_bss);\r\nchan_stats.cca_scan_dur =\r\nle16_to_cpu(fw_chan_stats->cca_scan_dur);\r\nchan_stats.cca_busy_dur =\r\nle16_to_cpu(fw_chan_stats->cca_busy_dur);\r\nmwifiex_dbg(adapter, INFO,\r\n"chan=%d, noise=%d, total_network=%d scan_duration=%d, busy_duration=%d\n",\r\nchan_stats.chan_num,\r\nchan_stats.noise,\r\nchan_stats.total_bss,\r\nchan_stats.cca_scan_dur,\r\nchan_stats.cca_busy_dur);\r\nmemcpy(&adapter->chan_stats[adapter->survey_idx++], &chan_stats,\r\nsizeof(struct mwifiex_chan_stats));\r\nfw_chan_stats++;\r\n}\r\n}\r\nint mwifiex_ret_802_11_scan_ext(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_scan_ext *ext_scan_resp;\r\nstruct mwifiex_ie_types_header *tlv;\r\nstruct mwifiex_ietypes_chanstats *tlv_stat;\r\nu16 buf_left, type, len;\r\nstruct host_cmd_ds_command *cmd_ptr;\r\nstruct cmd_ctrl_node *cmd_node;\r\nunsigned long cmd_flags, scan_flags;\r\nbool complete_scan = false;\r\nmwifiex_dbg(adapter, INFO, "info: EXT scan returns successfully\n");\r\next_scan_resp = &resp->params.ext_scan;\r\ntlv = (void *)ext_scan_resp->tlv_buffer;\r\nbuf_left = le16_to_cpu(resp->size) - (sizeof(*ext_scan_resp) + S_DS_GEN\r\n- 1);\r\nwhile (buf_left >= sizeof(struct mwifiex_ie_types_header)) {\r\ntype = le16_to_cpu(tlv->type);\r\nlen = le16_to_cpu(tlv->len);\r\nif (buf_left < (sizeof(struct mwifiex_ie_types_header) + len)) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"error processing scan response TLVs");\r\nbreak;\r\n}\r\nswitch (type) {\r\ncase TLV_TYPE_CHANNEL_STATS:\r\ntlv_stat = (void *)tlv;\r\nmwifiex_update_chan_statistics(priv, tlv_stat);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbuf_left -= len + sizeof(struct mwifiex_ie_types_header);\r\ntlv = (void *)((u8 *)tlv + len +\r\nsizeof(struct mwifiex_ie_types_header));\r\n}\r\nspin_lock_irqsave(&adapter->cmd_pending_q_lock, cmd_flags);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, scan_flags);\r\nif (list_empty(&adapter->scan_pending_q)) {\r\ncomplete_scan = true;\r\nlist_for_each_entry(cmd_node, &adapter->cmd_pending_q, list) {\r\ncmd_ptr = (void *)cmd_node->cmd_skb->data;\r\nif (le16_to_cpu(cmd_ptr->command) ==\r\nHostCmd_CMD_802_11_SCAN_EXT) {\r\nmwifiex_dbg(adapter, INFO,\r\n"Scan pending in command pending list");\r\ncomplete_scan = false;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, scan_flags);\r\nspin_unlock_irqrestore(&adapter->cmd_pending_q_lock, cmd_flags);\r\nif (complete_scan)\r\nmwifiex_complete_scan(priv);\r\nreturn 0;\r\n}\r\nint mwifiex_handle_event_ext_scan_report(struct mwifiex_private *priv,\r\nvoid *buf)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu8 *bss_info;\r\nu32 bytes_left, bytes_left_for_tlv, idx;\r\nu16 type, len;\r\nstruct mwifiex_ie_types_data *tlv;\r\nstruct mwifiex_ie_types_bss_scan_rsp *scan_rsp_tlv;\r\nstruct mwifiex_ie_types_bss_scan_info *scan_info_tlv;\r\nu8 *radio_type;\r\nu64 fw_tsf = 0;\r\ns32 rssi = 0;\r\nstruct mwifiex_event_scan_result *event_scan = buf;\r\nu8 num_of_set = event_scan->num_of_set;\r\nu8 *scan_resp = buf + sizeof(struct mwifiex_event_scan_result);\r\nu16 scan_resp_size = le16_to_cpu(event_scan->buf_size);\r\nif (num_of_set > MWIFIEX_MAX_AP) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"EXT_SCAN: Invalid number of AP returned (%d)!!\n",\r\nnum_of_set);\r\nret = -1;\r\ngoto check_next_scan;\r\n}\r\nbytes_left = scan_resp_size;\r\nmwifiex_dbg(adapter, INFO,\r\n"EXT_SCAN: size %d, returned %d APs...",\r\nscan_resp_size, num_of_set);\r\nmwifiex_dbg_dump(adapter, CMD_D, "EXT_SCAN buffer:", buf,\r\nscan_resp_size +\r\nsizeof(struct mwifiex_event_scan_result));\r\ntlv = (struct mwifiex_ie_types_data *)scan_resp;\r\nfor (idx = 0; idx < num_of_set && bytes_left; idx++) {\r\ntype = le16_to_cpu(tlv->header.type);\r\nlen = le16_to_cpu(tlv->header.len);\r\nif (bytes_left < sizeof(struct mwifiex_ie_types_header) + len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"EXT_SCAN: Error bytes left < TLV length\n");\r\nbreak;\r\n}\r\nscan_rsp_tlv = NULL;\r\nscan_info_tlv = NULL;\r\nbytes_left_for_tlv = bytes_left;\r\nif (type != TLV_TYPE_BSS_SCAN_RSP)\r\nbreak;\r\nbss_info = (u8 *)tlv;\r\nscan_rsp_tlv = (struct mwifiex_ie_types_bss_scan_rsp *)tlv;\r\ntlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\r\nbytes_left_for_tlv -=\r\n(len + sizeof(struct mwifiex_ie_types_header));\r\nwhile (bytes_left_for_tlv >=\r\nsizeof(struct mwifiex_ie_types_header) &&\r\nle16_to_cpu(tlv->header.type) != TLV_TYPE_BSS_SCAN_RSP) {\r\ntype = le16_to_cpu(tlv->header.type);\r\nlen = le16_to_cpu(tlv->header.len);\r\nif (bytes_left_for_tlv <\r\nsizeof(struct mwifiex_ie_types_header) + len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"EXT_SCAN: Error in processing TLV,\t"\r\n"bytes left < TLV length\n");\r\nscan_rsp_tlv = NULL;\r\nbytes_left_for_tlv = 0;\r\ncontinue;\r\n}\r\nswitch (type) {\r\ncase TLV_TYPE_BSS_SCAN_INFO:\r\nscan_info_tlv =\r\n(struct mwifiex_ie_types_bss_scan_info *)tlv;\r\nif (len !=\r\nsizeof(struct mwifiex_ie_types_bss_scan_info) -\r\nsizeof(struct mwifiex_ie_types_header)) {\r\nbytes_left_for_tlv = 0;\r\ncontinue;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntlv = (struct mwifiex_ie_types_data *)(tlv->data + len);\r\nbytes_left -=\r\n(len + sizeof(struct mwifiex_ie_types_header));\r\nbytes_left_for_tlv -=\r\n(len + sizeof(struct mwifiex_ie_types_header));\r\n}\r\nif (!scan_rsp_tlv)\r\nbreak;\r\nbss_info += sizeof(u16);\r\nbytes_left -= sizeof(u16);\r\nif (scan_info_tlv) {\r\nrssi = (s32)(s16)(le16_to_cpu(scan_info_tlv->rssi));\r\nrssi *= 100;\r\nmwifiex_dbg(adapter, INFO,\r\n"info: InterpretIE: RSSI=%d\n", rssi);\r\nfw_tsf = le64_to_cpu(scan_info_tlv->tsf);\r\nradio_type = &scan_info_tlv->radio_type;\r\n} else {\r\nradio_type = NULL;\r\n}\r\nret = mwifiex_parse_single_response_buf(priv, &bss_info,\r\n&bytes_left, fw_tsf,\r\nradio_type, true, rssi);\r\nif (ret)\r\ngoto check_next_scan;\r\n}\r\ncheck_next_scan:\r\nif (!event_scan->more_event)\r\nmwifiex_check_next_scan_command(priv);\r\nreturn ret;\r\n}\r\nint mwifiex_cmd_802_11_bg_scan_query(struct host_cmd_ds_command *cmd)\r\n{\r\nstruct host_cmd_ds_802_11_bg_scan_query *bg_query =\r\n&cmd->params.bg_scan_query;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_QUERY);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_bg_scan_query)\r\n+ S_DS_GEN);\r\nbg_query->flush = 1;\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_queue_scan_cmd(struct mwifiex_private *priv,\r\nstruct cmd_ctrl_node *cmd_node)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nunsigned long flags;\r\ncmd_node->wait_q_enabled = true;\r\ncmd_node->condition = &adapter->scan_wait_q_woken;\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nlist_add_tail(&cmd_node->list, &adapter->scan_pending_q);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\n}\r\nstatic int mwifiex_scan_specific_ssid(struct mwifiex_private *priv,\r\nstruct cfg80211_ssid *req_ssid)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct mwifiex_user_scan_cfg *scan_cfg;\r\nif (adapter->scan_processing) {\r\nmwifiex_dbg(adapter, WARN,\r\n"cmd: Scan already in process...\n");\r\nreturn -EBUSY;\r\n}\r\nif (priv->scan_block) {\r\nmwifiex_dbg(adapter, WARN,\r\n"cmd: Scan is blocked during association...\n");\r\nreturn -EBUSY;\r\n}\r\nscan_cfg = kzalloc(sizeof(struct mwifiex_user_scan_cfg), GFP_KERNEL);\r\nif (!scan_cfg)\r\nreturn -ENOMEM;\r\nether_addr_copy(scan_cfg->random_mac, priv->random_mac);\r\nscan_cfg->ssid_list = req_ssid;\r\nscan_cfg->num_ssids = 1;\r\nret = mwifiex_scan_networks(priv, scan_cfg);\r\nkfree(scan_cfg);\r\nreturn ret;\r\n}\r\nint mwifiex_request_scan(struct mwifiex_private *priv,\r\nstruct cfg80211_ssid *req_ssid)\r\n{\r\nint ret;\r\nif (down_interruptible(&priv->async_sem)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"%s: acquire semaphore fail\n",\r\n__func__);\r\nreturn -1;\r\n}\r\npriv->adapter->scan_wait_q_woken = false;\r\nif (req_ssid && req_ssid->ssid_len != 0)\r\nret = mwifiex_scan_specific_ssid(priv, req_ssid);\r\nelse\r\nret = mwifiex_scan_networks(priv, NULL);\r\nup(&priv->async_sem);\r\nreturn ret;\r\n}\r\nint\r\nmwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\r\nu16 vsie_mask, u8 **buffer)\r\n{\r\nint id, ret_len = 0;\r\nstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\r\nif (!buffer)\r\nreturn 0;\r\nif (!(*buffer))\r\nreturn 0;\r\nfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\r\nif (priv->vs_ie[id].mask & vsie_mask) {\r\nvs_param_set =\r\n(struct mwifiex_ie_types_vendor_param_set *)\r\n*buffer;\r\nvs_param_set->header.type =\r\ncpu_to_le16(TLV_TYPE_PASSTHROUGH);\r\nvs_param_set->header.len =\r\ncpu_to_le16((((u16) priv->vs_ie[id].ie[1])\r\n& 0x00FF) + 2);\r\nmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\r\nle16_to_cpu(vs_param_set->header.len));\r\n*buffer += le16_to_cpu(vs_param_set->header.len) +\r\nsizeof(struct mwifiex_ie_types_header);\r\nret_len += le16_to_cpu(vs_param_set->header.len) +\r\nsizeof(struct mwifiex_ie_types_header);\r\n}\r\n}\r\nreturn ret_len;\r\n}\r\nvoid\r\nmwifiex_save_curr_bcn(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_bssdescriptor *curr_bss =\r\n&priv->curr_bss_params.bss_descriptor;\r\nif (!curr_bss->beacon_buf_size)\r\nreturn;\r\nif (!priv->curr_bcn_buf ||\r\npriv->curr_bcn_size != curr_bss->beacon_buf_size) {\r\npriv->curr_bcn_size = curr_bss->beacon_buf_size;\r\nkfree(priv->curr_bcn_buf);\r\npriv->curr_bcn_buf = kmalloc(curr_bss->beacon_buf_size,\r\nGFP_ATOMIC);\r\nif (!priv->curr_bcn_buf)\r\nreturn;\r\n}\r\nmemcpy(priv->curr_bcn_buf, curr_bss->beacon_buf,\r\ncurr_bss->beacon_buf_size);\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: current beacon saved %d\n",\r\npriv->curr_bcn_size);\r\ncurr_bss->beacon_buf = priv->curr_bcn_buf;\r\nif (curr_bss->bcn_wpa_ie)\r\ncurr_bss->bcn_wpa_ie =\r\n(struct ieee_types_vendor_specific *)\r\n(curr_bss->beacon_buf +\r\ncurr_bss->wpa_offset);\r\nif (curr_bss->bcn_rsn_ie)\r\ncurr_bss->bcn_rsn_ie = (struct ieee_types_generic *)\r\n(curr_bss->beacon_buf +\r\ncurr_bss->rsn_offset);\r\nif (curr_bss->bcn_ht_cap)\r\ncurr_bss->bcn_ht_cap = (struct ieee80211_ht_cap *)\r\n(curr_bss->beacon_buf +\r\ncurr_bss->ht_cap_offset);\r\nif (curr_bss->bcn_ht_oper)\r\ncurr_bss->bcn_ht_oper = (struct ieee80211_ht_operation *)\r\n(curr_bss->beacon_buf +\r\ncurr_bss->ht_info_offset);\r\nif (curr_bss->bcn_vht_cap)\r\ncurr_bss->bcn_vht_cap = (void *)(curr_bss->beacon_buf +\r\ncurr_bss->vht_cap_offset);\r\nif (curr_bss->bcn_vht_oper)\r\ncurr_bss->bcn_vht_oper = (void *)(curr_bss->beacon_buf +\r\ncurr_bss->vht_info_offset);\r\nif (curr_bss->bcn_bss_co_2040)\r\ncurr_bss->bcn_bss_co_2040 =\r\n(curr_bss->beacon_buf + curr_bss->bss_co_2040_offset);\r\nif (curr_bss->bcn_ext_cap)\r\ncurr_bss->bcn_ext_cap = curr_bss->beacon_buf +\r\ncurr_bss->ext_cap_offset;\r\nif (curr_bss->oper_mode)\r\ncurr_bss->oper_mode = (void *)(curr_bss->beacon_buf +\r\ncurr_bss->oper_mode_offset);\r\n}\r\nvoid\r\nmwifiex_free_curr_bcn(struct mwifiex_private *priv)\r\n{\r\nkfree(priv->curr_bcn_buf);\r\npriv->curr_bcn_buf = NULL;\r\n}
