static void ath9k_htc_op_ps_wakeup(struct ath_common *common)\r\n{\r\nath9k_htc_ps_wakeup((struct ath9k_htc_priv *) common->priv);\r\n}\r\nstatic void ath9k_htc_op_ps_restore(struct ath_common *common)\r\n{\r\nath9k_htc_ps_restore((struct ath9k_htc_priv *) common->priv);\r\n}\r\nstatic int ath9k_htc_wait_for_target(struct ath9k_htc_priv *priv)\r\n{\r\nunsigned long time_left;\r\nif (atomic_read(&priv->htc->tgt_ready) > 0) {\r\natomic_dec(&priv->htc->tgt_ready);\r\nreturn 0;\r\n}\r\ntime_left = wait_for_completion_timeout(&priv->htc->target_wait, HZ);\r\nif (!time_left) {\r\ndev_err(priv->dev, "ath9k_htc: Target is unresponsive\n");\r\nreturn -ETIMEDOUT;\r\n}\r\natomic_dec(&priv->htc->tgt_ready);\r\nreturn 0;\r\n}\r\nstatic void ath9k_deinit_priv(struct ath9k_htc_priv *priv)\r\n{\r\nath9k_hw_deinit(priv->ah);\r\nkfree(priv->ah);\r\npriv->ah = NULL;\r\n}\r\nstatic void ath9k_deinit_device(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nwiphy_rfkill_stop_polling(hw->wiphy);\r\nath9k_deinit_leds(priv);\r\nath9k_htc_deinit_debug(priv);\r\nieee80211_unregister_hw(hw);\r\nath9k_rx_cleanup(priv);\r\nath9k_tx_cleanup(priv);\r\nath9k_deinit_priv(priv);\r\n}\r\nstatic inline int ath9k_htc_connect_svc(struct ath9k_htc_priv *priv,\r\nu16 service_id,\r\nvoid (*tx) (void *,\r\nstruct sk_buff *,\r\nenum htc_endpoint_id,\r\nbool txok),\r\nenum htc_endpoint_id *ep_id)\r\n{\r\nstruct htc_service_connreq req;\r\nmemset(&req, 0, sizeof(struct htc_service_connreq));\r\nreq.service_id = service_id;\r\nreq.ep_callbacks.priv = priv;\r\nreq.ep_callbacks.rx = ath9k_htc_rxep;\r\nreq.ep_callbacks.tx = tx;\r\nreturn htc_connect_service(priv->htc, &req, ep_id);\r\n}\r\nstatic int ath9k_init_htc_services(struct ath9k_htc_priv *priv, u16 devid,\r\nu32 drv_info)\r\n{\r\nint ret;\r\nret = ath9k_wmi_connect(priv->htc, priv->wmi, &priv->wmi_cmd_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_BEACON_SVC, ath9k_htc_beaconep,\r\n&priv->beacon_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_CAB_SVC, ath9k_htc_txep,\r\n&priv->cab_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_UAPSD_SVC, ath9k_htc_txep,\r\n&priv->uapsd_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_MGMT_SVC, ath9k_htc_txep,\r\n&priv->mgmt_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_DATA_BE_SVC, ath9k_htc_txep,\r\n&priv->data_be_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_DATA_BK_SVC, ath9k_htc_txep,\r\n&priv->data_bk_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_DATA_VI_SVC, ath9k_htc_txep,\r\n&priv->data_vi_ep);\r\nif (ret)\r\ngoto err;\r\nret = ath9k_htc_connect_svc(priv, WMI_DATA_VO_SVC, ath9k_htc_txep,\r\n&priv->data_vo_ep);\r\nif (ret)\r\ngoto err;\r\nif (IS_AR7010_DEVICE(drv_info))\r\npriv->htc->credits = 45;\r\nelse\r\npriv->htc->credits = 33;\r\nret = htc_init(priv->htc);\r\nif (ret)\r\ngoto err;\r\ndev_info(priv->dev, "ath9k_htc: HTC initialized with %d credits\n",\r\npriv->htc->credits);\r\nreturn 0;\r\nerr:\r\ndev_err(priv->dev, "ath9k_htc: Unable to initialize HTC services\n");\r\nreturn ret;\r\n}\r\nstatic void ath9k_reg_notifier(struct wiphy *wiphy,\r\nstruct regulatory_request *request)\r\n{\r\nstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nath_reg_notifier_apply(wiphy, request,\r\nath9k_hw_regulatory(priv->ah));\r\n}\r\nstatic unsigned int ath9k_regread(void *hw_priv, u32 reg_offset)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\n__be32 val, reg = cpu_to_be32(reg_offset);\r\nint r;\r\nr = ath9k_wmi_cmd(priv->wmi, WMI_REG_READ_CMDID,\r\n(u8 *) &reg, sizeof(reg),\r\n(u8 *) &val, sizeof(val),\r\n100);\r\nif (unlikely(r)) {\r\nath_dbg(common, WMI, "REGISTER READ FAILED: (0x%04x, %d)\n",\r\nreg_offset, r);\r\nreturn -EIO;\r\n}\r\nreturn be32_to_cpu(val);\r\n}\r\nstatic void ath9k_multi_regread(void *hw_priv, u32 *addr,\r\nu32 *val, u16 count)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\n__be32 tmpaddr[8];\r\n__be32 tmpval[8];\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\ntmpaddr[i] = cpu_to_be32(addr[i]);\r\n}\r\nret = ath9k_wmi_cmd(priv->wmi, WMI_REG_READ_CMDID,\r\n(u8 *)tmpaddr , sizeof(u32) * count,\r\n(u8 *)tmpval, sizeof(u32) * count,\r\n100);\r\nif (unlikely(ret)) {\r\nath_dbg(common, WMI,\r\n"Multiple REGISTER READ FAILED (count: %d)\n", count);\r\n}\r\nfor (i = 0; i < count; i++) {\r\nval[i] = be32_to_cpu(tmpval[i]);\r\n}\r\n}\r\nstatic void ath9k_regwrite_multi(struct ath_common *common)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nu32 rsp_status;\r\nint r;\r\nr = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,\r\n(u8 *) &priv->wmi->multi_write,\r\nsizeof(struct register_write) * priv->wmi->multi_write_idx,\r\n(u8 *) &rsp_status, sizeof(rsp_status),\r\n100);\r\nif (unlikely(r)) {\r\nath_dbg(common, WMI,\r\n"REGISTER WRITE FAILED, multi len: %d\n",\r\npriv->wmi->multi_write_idx);\r\n}\r\npriv->wmi->multi_write_idx = 0;\r\n}\r\nstatic void ath9k_regwrite_single(void *hw_priv, u32 val, u32 reg_offset)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nconst __be32 buf[2] = {\r\ncpu_to_be32(reg_offset),\r\ncpu_to_be32(val),\r\n};\r\nint r;\r\nr = ath9k_wmi_cmd(priv->wmi, WMI_REG_WRITE_CMDID,\r\n(u8 *) &buf, sizeof(buf),\r\n(u8 *) &val, sizeof(val),\r\n100);\r\nif (unlikely(r)) {\r\nath_dbg(common, WMI, "REGISTER WRITE FAILED:(0x%04x, %d)\n",\r\nreg_offset, r);\r\n}\r\n}\r\nstatic void ath9k_regwrite_buffer(void *hw_priv, u32 val, u32 reg_offset)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nmutex_lock(&priv->wmi->multi_write_mutex);\r\npriv->wmi->multi_write[priv->wmi->multi_write_idx].reg =\r\ncpu_to_be32(reg_offset);\r\npriv->wmi->multi_write[priv->wmi->multi_write_idx].val =\r\ncpu_to_be32(val);\r\npriv->wmi->multi_write_idx++;\r\nif (priv->wmi->multi_write_idx == MAX_CMD_NUMBER)\r\nath9k_regwrite_multi(common);\r\nmutex_unlock(&priv->wmi->multi_write_mutex);\r\n}\r\nstatic void ath9k_regwrite(void *hw_priv, u32 val, u32 reg_offset)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nif (atomic_read(&priv->wmi->mwrite_cnt))\r\nath9k_regwrite_buffer(hw_priv, val, reg_offset);\r\nelse\r\nath9k_regwrite_single(hw_priv, val, reg_offset);\r\n}\r\nstatic void ath9k_enable_regwrite_buffer(void *hw_priv)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\natomic_inc(&priv->wmi->mwrite_cnt);\r\n}\r\nstatic void ath9k_regwrite_flush(void *hw_priv)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\natomic_dec(&priv->wmi->mwrite_cnt);\r\nmutex_lock(&priv->wmi->multi_write_mutex);\r\nif (priv->wmi->multi_write_idx)\r\nath9k_regwrite_multi(common);\r\nmutex_unlock(&priv->wmi->multi_write_mutex);\r\n}\r\nstatic void ath9k_reg_rmw_buffer(void *hw_priv,\r\nu32 reg_offset, u32 set, u32 clr)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nu32 rsp_status;\r\nint r;\r\nmutex_lock(&priv->wmi->multi_rmw_mutex);\r\npriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].reg =\r\ncpu_to_be32(reg_offset);\r\npriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].set =\r\ncpu_to_be32(set);\r\npriv->wmi->multi_rmw[priv->wmi->multi_rmw_idx].clr =\r\ncpu_to_be32(clr);\r\npriv->wmi->multi_rmw_idx++;\r\nif (priv->wmi->multi_rmw_idx == MAX_RMW_CMD_NUMBER) {\r\nr = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\r\n(u8 *) &priv->wmi->multi_rmw,\r\nsizeof(struct register_write) * priv->wmi->multi_rmw_idx,\r\n(u8 *) &rsp_status, sizeof(rsp_status),\r\n100);\r\nif (unlikely(r)) {\r\nath_dbg(common, WMI,\r\n"REGISTER RMW FAILED, multi len: %d\n",\r\npriv->wmi->multi_rmw_idx);\r\n}\r\npriv->wmi->multi_rmw_idx = 0;\r\n}\r\nmutex_unlock(&priv->wmi->multi_rmw_mutex);\r\n}\r\nstatic void ath9k_reg_rmw_flush(void *hw_priv)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nu32 rsp_status;\r\nint r;\r\nif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags))\r\nreturn;\r\natomic_dec(&priv->wmi->m_rmw_cnt);\r\nmutex_lock(&priv->wmi->multi_rmw_mutex);\r\nif (priv->wmi->multi_rmw_idx) {\r\nr = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\r\n(u8 *) &priv->wmi->multi_rmw,\r\nsizeof(struct register_rmw) * priv->wmi->multi_rmw_idx,\r\n(u8 *) &rsp_status, sizeof(rsp_status),\r\n100);\r\nif (unlikely(r)) {\r\nath_dbg(common, WMI,\r\n"REGISTER RMW FAILED, multi len: %d\n",\r\npriv->wmi->multi_rmw_idx);\r\n}\r\npriv->wmi->multi_rmw_idx = 0;\r\n}\r\nmutex_unlock(&priv->wmi->multi_rmw_mutex);\r\n}\r\nstatic void ath9k_enable_rmw_buffer(void *hw_priv)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags))\r\nreturn;\r\natomic_inc(&priv->wmi->m_rmw_cnt);\r\n}\r\nstatic u32 ath9k_reg_rmw_single(void *hw_priv,\r\nu32 reg_offset, u32 set, u32 clr)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nstruct register_rmw buf, buf_ret;\r\nint ret;\r\nu32 val = 0;\r\nbuf.reg = cpu_to_be32(reg_offset);\r\nbuf.set = cpu_to_be32(set);\r\nbuf.clr = cpu_to_be32(clr);\r\nret = ath9k_wmi_cmd(priv->wmi, WMI_REG_RMW_CMDID,\r\n(u8 *) &buf, sizeof(buf),\r\n(u8 *) &buf_ret, sizeof(buf_ret),\r\n100);\r\nif (unlikely(ret)) {\r\nath_dbg(common, WMI, "REGISTER RMW FAILED:(0x%04x, %d)\n",\r\nreg_offset, ret);\r\n}\r\nreturn val;\r\n}\r\nstatic u32 ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 clr)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) hw_priv;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) common->priv;\r\nif (test_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags)) {\r\nu32 val;\r\nval = REG_READ(ah, reg_offset);\r\nval &= ~clr;\r\nval |= set;\r\nREG_WRITE(ah, reg_offset, val);\r\nreturn 0;\r\n}\r\nif (atomic_read(&priv->wmi->m_rmw_cnt))\r\nath9k_reg_rmw_buffer(hw_priv, reg_offset, set, clr);\r\nelse\r\nath9k_reg_rmw_single(hw_priv, reg_offset, set, clr);\r\nreturn 0;\r\n}\r\nstatic void ath_usb_read_cachesize(struct ath_common *common, int *csz)\r\n{\r\n*csz = L1_CACHE_BYTES >> 2;\r\n}\r\nstatic bool ath_usb_eeprom_read(struct ath_common *common, u32 off, u16 *data)\r\n{\r\nstruct ath_hw *ah = (struct ath_hw *) common->ah;\r\n(void)REG_READ(ah, AR5416_EEPROM_OFFSET + (off << AR5416_EEPROM_S));\r\nif (!ath9k_hw_wait(ah,\r\nAR_EEPROM_STATUS_DATA,\r\nAR_EEPROM_STATUS_DATA_BUSY |\r\nAR_EEPROM_STATUS_DATA_PROT_ACCESS, 0,\r\nAH_WAIT_TIMEOUT))\r\nreturn false;\r\n*data = MS(REG_READ(ah, AR_EEPROM_STATUS_DATA),\r\nAR_EEPROM_STATUS_DATA_VAL);\r\nreturn true;\r\n}\r\nstatic int ath9k_init_queues(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(priv->hwq_map); i++)\r\npriv->hwq_map[i] = -1;\r\npriv->beacon.beaconq = ath9k_hw_beaconq_setup(priv->ah);\r\nif (priv->beacon.beaconq == -1) {\r\nath_err(common, "Unable to setup BEACON xmit queue\n");\r\ngoto err;\r\n}\r\npriv->cabq = ath9k_htc_cabq_setup(priv);\r\nif (priv->cabq == -1) {\r\nath_err(common, "Unable to setup CAB xmit queue\n");\r\ngoto err;\r\n}\r\nif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_BE)) {\r\nath_err(common, "Unable to setup xmit queue for BE traffic\n");\r\ngoto err;\r\n}\r\nif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_BK)) {\r\nath_err(common, "Unable to setup xmit queue for BK traffic\n");\r\ngoto err;\r\n}\r\nif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_VI)) {\r\nath_err(common, "Unable to setup xmit queue for VI traffic\n");\r\ngoto err;\r\n}\r\nif (!ath9k_htc_txq_setup(priv, IEEE80211_AC_VO)) {\r\nath_err(common, "Unable to setup xmit queue for VO traffic\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nstatic void ath9k_init_misc(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nmemcpy(common->bssidmask, ath_bcast_mac, ETH_ALEN);\r\ncommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\r\npriv->ah->opmode = NL80211_IFTYPE_STATION;\r\npriv->spec_priv.ah = priv->ah;\r\npriv->spec_priv.spec_config.enabled = 0;\r\npriv->spec_priv.spec_config.short_repeat = true;\r\npriv->spec_priv.spec_config.count = 8;\r\npriv->spec_priv.spec_config.endless = false;\r\npriv->spec_priv.spec_config.period = 0x12;\r\npriv->spec_priv.spec_config.fft_period = 0x02;\r\n}\r\nstatic int ath9k_init_priv(struct ath9k_htc_priv *priv,\r\nu16 devid, char *product,\r\nu32 drv_info)\r\n{\r\nstruct ath_hw *ah = NULL;\r\nstruct ath_common *common;\r\nint i, ret = 0, csz = 0;\r\nah = kzalloc(sizeof(struct ath_hw), GFP_KERNEL);\r\nif (!ah)\r\nreturn -ENOMEM;\r\nah->dev = priv->dev;\r\nah->hw = priv->hw;\r\nah->hw_version.devid = devid;\r\nah->hw_version.usbdev = drv_info;\r\nah->ah_flags |= AH_USE_EEPROM;\r\nah->reg_ops.read = ath9k_regread;\r\nah->reg_ops.multi_read = ath9k_multi_regread;\r\nah->reg_ops.write = ath9k_regwrite;\r\nah->reg_ops.enable_write_buffer = ath9k_enable_regwrite_buffer;\r\nah->reg_ops.write_flush = ath9k_regwrite_flush;\r\nah->reg_ops.enable_rmw_buffer = ath9k_enable_rmw_buffer;\r\nah->reg_ops.rmw_flush = ath9k_reg_rmw_flush;\r\nah->reg_ops.rmw = ath9k_reg_rmw;\r\npriv->ah = ah;\r\ncommon = ath9k_hw_common(ah);\r\ncommon->ops = &ah->reg_ops;\r\ncommon->ps_ops = &ath9k_htc_ps_ops;\r\ncommon->bus_ops = &ath9k_usb_bus_ops;\r\ncommon->ah = ah;\r\ncommon->hw = priv->hw;\r\ncommon->priv = priv;\r\ncommon->debug_mask = ath9k_debug;\r\ncommon->btcoex_enabled = ath9k_htc_btcoex_enable == 1;\r\nset_bit(ATH_OP_INVALID, &common->op_flags);\r\nspin_lock_init(&priv->beacon_lock);\r\nspin_lock_init(&priv->tx.tx_lock);\r\nmutex_init(&priv->mutex);\r\nmutex_init(&priv->htc_pm_lock);\r\ntasklet_init(&priv->rx_tasklet, ath9k_rx_tasklet,\r\n(unsigned long)priv);\r\ntasklet_init(&priv->tx_failed_tasklet, ath9k_tx_failed_tasklet,\r\n(unsigned long)priv);\r\nINIT_DELAYED_WORK(&priv->ani_work, ath9k_htc_ani_work);\r\nINIT_WORK(&priv->ps_work, ath9k_ps_work);\r\nINIT_WORK(&priv->fatal_work, ath9k_fatal_work);\r\nsetup_timer(&priv->tx.cleanup_timer, ath9k_htc_tx_cleanup_timer,\r\n(unsigned long)priv);\r\nath_read_cachesize(common, &csz);\r\ncommon->cachelsz = csz << 2;\r\nret = ath9k_hw_init(ah);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to initialize hardware; initialization status: %d\n",\r\nret);\r\ngoto err_hw;\r\n}\r\nret = ath9k_init_queues(priv);\r\nif (ret)\r\ngoto err_queues;\r\nfor (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++)\r\npriv->beacon.bslot[i] = NULL;\r\npriv->beacon.slottime = 9;\r\nath9k_cmn_init_channels_rates(common);\r\nath9k_cmn_init_crypto(ah);\r\nath9k_init_misc(priv);\r\nath9k_htc_init_btcoex(priv, product);\r\nreturn 0;\r\nerr_queues:\r\nath9k_hw_deinit(ah);\r\nerr_hw:\r\nkfree(ah);\r\npriv->ah = NULL;\r\nreturn ret;\r\n}\r\nstatic void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_hw *hw)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct base_eep_header *pBase;\r\nieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\r\nieee80211_hw_set(hw, MFP_CAPABLE);\r\nieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\r\nieee80211_hw_set(hw, PS_NULLFUNC_STACK);\r\nieee80211_hw_set(hw, RX_INCLUDES_FCS);\r\nieee80211_hw_set(hw, HAS_RATE_CONTROL);\r\nieee80211_hw_set(hw, SPECTRUM_MGMT);\r\nieee80211_hw_set(hw, SIGNAL_DBM);\r\nieee80211_hw_set(hw, AMPDU_AGGREGATION);\r\nif (ath9k_ps_enable)\r\nieee80211_hw_set(hw, SUPPORTS_PS);\r\nhw->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_AP) |\r\nBIT(NL80211_IFTYPE_P2P_GO) |\r\nBIT(NL80211_IFTYPE_P2P_CLIENT) |\r\nBIT(NL80211_IFTYPE_MESH_POINT) |\r\nBIT(NL80211_IFTYPE_OCB);\r\nhw->wiphy->iface_combinations = &if_comb;\r\nhw->wiphy->n_iface_combinations = 1;\r\nhw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nhw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN |\r\nWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\r\nWIPHY_FLAG_HAS_CHANNEL_SWITCH;\r\nhw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\r\nhw->queues = 4;\r\nhw->max_listen_interval = 1;\r\nhw->vif_data_size = sizeof(struct ath9k_htc_vif);\r\nhw->sta_data_size = sizeof(struct ath9k_htc_sta);\r\nhw->extra_tx_headroom = sizeof(struct tx_frame_hdr) +\r\nsizeof(struct htc_frame_hdr) + 4;\r\nif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)\r\nhw->wiphy->bands[NL80211_BAND_2GHZ] =\r\n&common->sbands[NL80211_BAND_2GHZ];\r\nif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)\r\nhw->wiphy->bands[NL80211_BAND_5GHZ] =\r\n&common->sbands[NL80211_BAND_5GHZ];\r\nath9k_cmn_reload_chainmask(ah);\r\npBase = ath9k_htc_get_eeprom_base(priv);\r\nif (pBase) {\r\nhw->wiphy->available_antennas_rx = pBase->rxMask;\r\nhw->wiphy->available_antennas_tx = pBase->txMask;\r\n}\r\nSET_IEEE80211_PERM_ADDR(hw, common->macaddr);\r\n}\r\nstatic int ath9k_init_firmware_version(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct wmi_fw_version cmd_rsp;\r\nint ret;\r\nmemset(&cmd_rsp, 0, sizeof(cmd_rsp));\r\nWMI_CMD(WMI_GET_FW_VERSION);\r\nif (ret)\r\nreturn -EINVAL;\r\npriv->fw_version_major = be16_to_cpu(cmd_rsp.major);\r\npriv->fw_version_minor = be16_to_cpu(cmd_rsp.minor);\r\nsnprintf(hw->wiphy->fw_version, sizeof(hw->wiphy->fw_version), "%d.%d",\r\npriv->fw_version_major,\r\npriv->fw_version_minor);\r\ndev_info(priv->dev, "ath9k_htc: FW Version: %d.%d\n",\r\npriv->fw_version_major,\r\npriv->fw_version_minor);\r\nif (priv->fw_version_major != MAJOR_VERSION_REQ ||\r\npriv->fw_version_minor < MINOR_VERSION_REQ) {\r\ndev_err(priv->dev, "ath9k_htc: Please upgrade to FW version %d.%d\n",\r\nMAJOR_VERSION_REQ, MINOR_VERSION_REQ);\r\nreturn -EINVAL;\r\n}\r\nif (priv->fw_version_major == 1 && priv->fw_version_minor < 4)\r\nset_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags);\r\ndev_info(priv->dev, "FW RMW support: %s\n",\r\ntest_bit(HTC_FWFLAG_NO_RMW, &priv->fw_flags) ? "Off" : "On");\r\nreturn 0;\r\n}\r\nstatic int ath9k_init_device(struct ath9k_htc_priv *priv,\r\nu16 devid, char *product, u32 drv_info)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct ath_common *common;\r\nstruct ath_hw *ah;\r\nint error = 0;\r\nstruct ath_regulatory *reg;\r\nchar hw_name[64];\r\nerror = ath9k_init_priv(priv, devid, product, drv_info);\r\nif (error != 0)\r\ngoto err_init;\r\nah = priv->ah;\r\ncommon = ath9k_hw_common(ah);\r\nath9k_set_hw_capab(priv, hw);\r\nerror = ath9k_init_firmware_version(priv);\r\nif (error != 0)\r\ngoto err_fw;\r\nerror = ath_regd_init(&common->regulatory, priv->hw->wiphy,\r\nath9k_reg_notifier);\r\nif (error)\r\ngoto err_regd;\r\nreg = &common->regulatory;\r\nerror = ath9k_tx_init(priv);\r\nif (error != 0)\r\ngoto err_tx;\r\nerror = ath9k_rx_init(priv);\r\nif (error != 0)\r\ngoto err_rx;\r\nath9k_hw_disable(priv->ah);\r\n#ifdef CONFIG_MAC80211_LEDS\r\npriv->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(priv->hw,\r\nIEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_htc_tpt_blink,\r\nARRAY_SIZE(ath9k_htc_tpt_blink));\r\n#endif\r\nerror = ieee80211_register_hw(hw);\r\nif (error)\r\ngoto err_register;\r\nif (!ath_is_world_regd(reg)) {\r\nerror = regulatory_hint(hw->wiphy, reg->alpha2);\r\nif (error)\r\ngoto err_world;\r\n}\r\nerror = ath9k_htc_init_debug(priv->ah);\r\nif (error) {\r\nath_err(common, "Unable to create debugfs files\n");\r\ngoto err_world;\r\n}\r\nath_dbg(common, CONFIG,\r\n"WMI:%d, BCN:%d, CAB:%d, UAPSD:%d, MGMT:%d, BE:%d, BK:%d, VI:%d, VO:%d\n",\r\npriv->wmi_cmd_ep,\r\npriv->beacon_ep,\r\npriv->cab_ep,\r\npriv->uapsd_ep,\r\npriv->mgmt_ep,\r\npriv->data_be_ep,\r\npriv->data_bk_ep,\r\npriv->data_vi_ep,\r\npriv->data_vo_ep);\r\nath9k_hw_name(priv->ah, hw_name, sizeof(hw_name));\r\nwiphy_info(hw->wiphy, "%s\n", hw_name);\r\nath9k_init_leds(priv);\r\nath9k_start_rfkill_poll(priv);\r\nreturn 0;\r\nerr_world:\r\nieee80211_unregister_hw(hw);\r\nerr_register:\r\nath9k_rx_cleanup(priv);\r\nerr_rx:\r\nath9k_tx_cleanup(priv);\r\nerr_tx:\r\nerr_regd:\r\nerr_fw:\r\nath9k_deinit_priv(priv);\r\nerr_init:\r\nreturn error;\r\n}\r\nint ath9k_htc_probe_device(struct htc_target *htc_handle, struct device *dev,\r\nu16 devid, char *product, u32 drv_info)\r\n{\r\nstruct ieee80211_hw *hw;\r\nstruct ath9k_htc_priv *priv;\r\nint ret;\r\nhw = ieee80211_alloc_hw(sizeof(struct ath9k_htc_priv), &ath9k_htc_ops);\r\nif (!hw)\r\nreturn -ENOMEM;\r\npriv = hw->priv;\r\npriv->hw = hw;\r\npriv->htc = htc_handle;\r\npriv->dev = dev;\r\nhtc_handle->drv_priv = priv;\r\nSET_IEEE80211_DEV(hw, priv->dev);\r\nret = ath9k_htc_wait_for_target(priv);\r\nif (ret)\r\ngoto err_free;\r\npriv->wmi = ath9k_init_wmi(priv);\r\nif (!priv->wmi) {\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nret = ath9k_init_htc_services(priv, devid, drv_info);\r\nif (ret)\r\ngoto err_init;\r\nret = ath9k_init_device(priv, devid, product, drv_info);\r\nif (ret)\r\ngoto err_init;\r\nreturn 0;\r\nerr_init:\r\nath9k_deinit_wmi(priv);\r\nerr_free:\r\nieee80211_free_hw(hw);\r\nreturn ret;\r\n}\r\nvoid ath9k_htc_disconnect_device(struct htc_target *htc_handle, bool hotunplug)\r\n{\r\nif (htc_handle->drv_priv) {\r\nif (hotunplug)\r\nhtc_handle->drv_priv->ah->ah_flags |= AH_UNPLUGGED;\r\nath9k_deinit_device(htc_handle->drv_priv);\r\nath9k_deinit_wmi(htc_handle->drv_priv);\r\nieee80211_free_hw(htc_handle->drv_priv->hw);\r\n}\r\n}\r\nvoid ath9k_htc_suspend(struct htc_target *htc_handle)\r\n{\r\nath9k_htc_setpower(htc_handle->drv_priv, ATH9K_PM_FULL_SLEEP);\r\n}\r\nint ath9k_htc_resume(struct htc_target *htc_handle)\r\n{\r\nstruct ath9k_htc_priv *priv = htc_handle->drv_priv;\r\nint ret;\r\nret = ath9k_htc_wait_for_target(priv);\r\nif (ret)\r\nreturn ret;\r\nret = ath9k_init_htc_services(priv, priv->ah->hw_version.devid,\r\npriv->ah->hw_version.usbdev);\r\nath9k_configure_leds(priv);\r\nreturn ret;\r\n}\r\nstatic int __init ath9k_htc_init(void)\r\n{\r\nif (ath9k_hif_usb_init() < 0) {\r\npr_err("No USB devices found, driver not installed\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ath9k_htc_exit(void)\r\n{\r\nath9k_hif_usb_exit();\r\npr_info("Driver unloaded\n");\r\n}
