static bool cs35l33_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L33_DEVID_AB:\r\ncase CS35L33_DEVID_CD:\r\ncase CS35L33_DEVID_E:\r\ncase CS35L33_REV_ID:\r\ncase CS35L33_INT_STATUS_1:\r\ncase CS35L33_INT_STATUS_2:\r\ncase CS35L33_HG_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs35l33_writeable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L33_DEVID_AB:\r\ncase CS35L33_DEVID_CD:\r\ncase CS35L33_DEVID_E:\r\ncase CS35L33_REV_ID:\r\ncase CS35L33_INT_STATUS_1:\r\ncase CS35L33_INT_STATUS_2:\r\ncase CS35L33_HG_STATUS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool cs35l33_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS35L33_DEVID_AB:\r\ncase CS35L33_DEVID_CD:\r\ncase CS35L33_DEVID_E:\r\ncase CS35L33_REV_ID:\r\ncase CS35L33_PWRCTL1:\r\ncase CS35L33_PWRCTL2:\r\ncase CS35L33_CLK_CTL:\r\ncase CS35L33_BST_PEAK_CTL:\r\ncase CS35L33_PROTECT_CTL:\r\ncase CS35L33_BST_CTL1:\r\ncase CS35L33_BST_CTL2:\r\ncase CS35L33_ADSP_CTL:\r\ncase CS35L33_ADC_CTL:\r\ncase CS35L33_DAC_CTL:\r\ncase CS35L33_DIG_VOL_CTL:\r\ncase CS35L33_CLASSD_CTL:\r\ncase CS35L33_AMP_CTL:\r\ncase CS35L33_INT_MASK_1:\r\ncase CS35L33_INT_MASK_2:\r\ncase CS35L33_INT_STATUS_1:\r\ncase CS35L33_INT_STATUS_2:\r\ncase CS35L33_DIAG_LOCK:\r\ncase CS35L33_DIAG_CTRL_1:\r\ncase CS35L33_DIAG_CTRL_2:\r\ncase CS35L33_HG_MEMLDO_CTL:\r\ncase CS35L33_HG_REL_RATE:\r\ncase CS35L33_LDO_DEL:\r\ncase CS35L33_HG_HEAD:\r\ncase CS35L33_HG_EN:\r\ncase CS35L33_TX_VMON:\r\ncase CS35L33_TX_IMON:\r\ncase CS35L33_TX_VPMON:\r\ncase CS35L33_TX_VBSTMON:\r\ncase CS35L33_TX_FLAG:\r\ncase CS35L33_TX_EN1:\r\ncase CS35L33_TX_EN2:\r\ncase CS35L33_TX_EN3:\r\ncase CS35L33_TX_EN4:\r\ncase CS35L33_RX_AUD:\r\ncase CS35L33_RX_SPLY:\r\ncase CS35L33_RX_ALIVE:\r\ncase CS35L33_BST_CTL4:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs35l33_spkrdrv_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (!priv->amp_cal) {\r\nusleep_range(8000, 9000);\r\npriv->amp_cal = true;\r\nregmap_update_bits(priv->regmap, CS35L33_CLASSD_CTL,\r\nCS35L33_AMP_CAL, 0);\r\ndev_dbg(codec->dev, "Amp calibration done\n");\r\n}\r\ndev_dbg(codec->dev, "Amp turned on\n");\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\ndev_dbg(codec->dev, "Amp turned off\n");\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid event = 0x%x\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_sdin_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\r\nCS35L33_PDN_BST, 0);\r\nval = priv->is_tdm_mode ? 0 : CS35L33_PDN_TDM;\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\r\nCS35L33_PDN_TDM, val);\r\ndev_dbg(codec->dev, "BST turned on\n");\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\ndev_dbg(codec->dev, "SDIN turned on\n");\r\nif (!priv->amp_cal) {\r\nregmap_update_bits(priv->regmap, CS35L33_CLASSD_CTL,\r\nCS35L33_AMP_CAL, CS35L33_AMP_CAL);\r\ndev_dbg(codec->dev, "Amp calibration started\n");\r\nusleep_range(10000, 11000);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\r\nCS35L33_PDN_TDM, CS35L33_PDN_TDM);\r\nusleep_range(4000, 4100);\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\r\nCS35L33_PDN_BST, CS35L33_PDN_BST);\r\ndev_dbg(codec->dev, "BST and SDIN turned off\n");\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid event = 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_sdout_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = CS35L33_SDOUT_3ST_I2S | CS35L33_PDN_TDM;\r\nunsigned int mask2 = CS35L33_SDOUT_3ST_TDM;\r\nunsigned int val, val2;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (priv->is_tdm_mode) {\r\nval = CS35L33_SDOUT_3ST_I2S;\r\nval2 = 0;\r\n} else {\r\nval = CS35L33_PDN_TDM;\r\nval2 = CS35L33_SDOUT_3ST_TDM;\r\n}\r\ndev_dbg(codec->dev, "SDOUT turned on\n");\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nval = CS35L33_SDOUT_3ST_I2S | CS35L33_PDN_TDM;\r\nval2 = CS35L33_SDOUT_3ST_TDM;\r\ndev_dbg(codec->dev, "SDOUT turned off\n");\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid event = 0x%x\n", event);\r\nreturn 0;\r\n}\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\r\nmask, val);\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nmask2, val2);\r\nreturn 0;\r\n}\r\nstatic int cs35l33_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nunsigned int val;\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\r\nCS35L33_PDN_ALL, 0);\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nCS35L33_MCLKDIS, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\r\nCS35L33_PDN_ALL, CS35L33_PDN_ALL);\r\nregmap_read(priv->regmap, CS35L33_INT_STATUS_2, &val);\r\nusleep_range(1000, 1100);\r\nif (val & CS35L33_PDN_DONE)\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nCS35L33_MCLKDIS, CS35L33_MCLKDIS);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_get_mclk_coeff(int mclk, int srate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs35l33_mclk_coeffs); i++) {\r\nif (cs35l33_mclk_coeffs[i].mclk == mclk &&\r\ncs35l33_mclk_coeffs[i].srate == srate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs35l33_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregmap_update_bits(priv->regmap, CS35L33_ADSP_CTL,\r\nCS35L33_MS_MASK, CS35L33_MS_MASK);\r\ndev_dbg(codec->dev, "Audio port in master mode\n");\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nregmap_update_bits(priv->regmap, CS35L33_ADSP_CTL,\r\nCS35L33_MS_MASK, 0);\r\ndev_dbg(codec->dev, "Audio port in slave mode\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\npriv->is_tdm_mode = true;\r\ndev_dbg(codec->dev, "Audio port in TDM mode\n");\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\npriv->is_tdm_mode = false;\r\ndev_dbg(codec->dev, "Audio port in I2S mode\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nint sample_size = params_width(params);\r\nint coeff = cs35l33_get_mclk_coeff(priv->mclk_int, params_rate(params));\r\nif (coeff < 0)\r\nreturn coeff;\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nCS35L33_ADSP_FS | CS35L33_INT_FS_RATE,\r\ncs35l33_mclk_coeffs[coeff].int_fs_ratio\r\n| cs35l33_mclk_coeffs[coeff].adsp_rate);\r\nif (priv->is_tdm_mode) {\r\nsample_size = (sample_size / 8) - 1;\r\nif (sample_size > 2)\r\nsample_size = 2;\r\nregmap_update_bits(priv->regmap, CS35L33_RX_AUD,\r\nCS35L33_AUDIN_RX_DEPTH,\r\nsample_size << CS35L33_AUDIN_RX_DEPTH_SHIFT);\r\n}\r\ndev_dbg(codec->dev, "sample rate=%d, bits per sample=%d\n",\r\nparams_rate(params), params_width(params));\r\nreturn 0;\r\n}\r\nstatic int cs35l33_pcm_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&cs35l33_constraints);\r\nreturn 0;\r\n}\r\nstatic int cs35l33_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nif (tristate) {\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\r\nCS35L33_SDOUT_3ST_I2S, CS35L33_SDOUT_3ST_I2S);\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nCS35L33_SDOUT_3ST_TDM, CS35L33_SDOUT_3ST_TDM);\r\n} else {\r\nregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\r\nCS35L33_SDOUT_3ST_I2S, 0);\r\nregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\r\nCS35L33_SDOUT_3ST_TDM, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg, bit_pos, i;\r\nint slot, slot_num;\r\nif (slot_width != 8)\r\nreturn -EINVAL;\r\nslot = ffs(rx_mask) - 1;\r\nif (slot >= 0) {\r\nregmap_update_bits(priv->regmap, CS35L33_RX_AUD,\r\nCS35L33_X_LOC, slot);\r\ndev_dbg(codec->dev, "Audio starts from slots %d", slot);\r\n}\r\nslot = ffs(tx_mask) - 1;\r\nslot_num = 0;\r\nfor (i = 0; i < 2 ; i++) {\r\nregmap_update_bits(priv->regmap, CS35L33_TX_VPMON + i,\r\nCS35L33_X_STATE | CS35L33_X_LOC, CS35L33_X_STATE\r\n| CS35L33_X_LOC);\r\n}\r\nsnd_soc_dapm_del_routes(dapm, cs35l33_vp_vbst_mon_route,\r\nARRAY_SIZE(cs35l33_vp_vbst_mon_route));\r\nwhile (slot >= 0) {\r\nif (slot_num == 0) {\r\nregmap_update_bits(priv->regmap, CS35L33_TX_VMON,\r\nCS35L33_X_STATE | CS35L33_X_LOC, slot);\r\ndev_dbg(codec->dev, "VMON enabled in slots %d-%d",\r\nslot, slot + 1);\r\n}\r\nif (slot_num == 3) {\r\nregmap_update_bits(priv->regmap, CS35L33_TX_IMON,\r\nCS35L33_X_STATE | CS35L33_X_LOC, slot);\r\ndev_dbg(codec->dev, "IMON enabled in slots %d-%d",\r\nslot, slot + 1);\r\n}\r\nif (slot_num == 4) {\r\nregmap_update_bits(priv->regmap, CS35L33_TX_VPMON,\r\nCS35L33_X_STATE | CS35L33_X_LOC, slot);\r\nsnd_soc_dapm_add_routes(dapm,\r\n&cs35l33_vp_vbst_mon_route[0], 2);\r\ndev_dbg(codec->dev, "VPMON enabled in slots %d", slot);\r\n}\r\nif (slot_num == 5) {\r\nregmap_update_bits(priv->regmap, CS35L33_TX_VBSTMON,\r\nCS35L33_X_STATE | CS35L33_X_LOC, slot);\r\nsnd_soc_dapm_add_routes(dapm,\r\n&cs35l33_vp_vbst_mon_route[2], 2);\r\ndev_dbg(codec->dev,\r\n"VBSTMON enabled in slots %d", slot);\r\n}\r\nreg = CS35L33_TX_EN4 - (slot/8);\r\nbit_pos = slot - ((slot / 8) * (8));\r\nregmap_update_bits(priv->regmap, reg,\r\n1 << bit_pos, 1 << bit_pos);\r\ntx_mask &= ~(1 << slot);\r\nslot = ffs(tx_mask) - 1;\r\nslot_num++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_codec_set_sysclk(struct snd_soc_codec *codec,\r\nint clk_id, int source, unsigned int freq, int dir)\r\n{\r\nstruct cs35l33_private *cs35l33 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase CS35L33_MCLK_5644:\r\ncase CS35L33_MCLK_6:\r\ncase CS35L33_MCLK_6144:\r\nregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\r\nCS35L33_MCLKDIV2, 0);\r\ncs35l33->mclk_int = freq;\r\nbreak;\r\ncase CS35L33_MCLK_11289:\r\ncase CS35L33_MCLK_12:\r\ncase CS35L33_MCLK_12288:\r\nregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\r\nCS35L33_MCLKDIV2, CS35L33_MCLKDIV2);\r\ncs35l33->mclk_int = freq/2;\r\nbreak;\r\ndefault:\r\ncs35l33->mclk_int = 0;\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "external mclk freq=%d, internal mclk freq=%d\n",\r\nfreq, cs35l33->mclk_int);\r\nreturn 0;\r\n}\r\nstatic int cs35l33_set_hg_data(struct snd_soc_codec *codec,\r\nstruct cs35l33_pdata *pdata)\r\n{\r\nstruct cs35l33_hg *hg_config = &pdata->hg_config;\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct cs35l33_private *priv = snd_soc_codec_get_drvdata(codec);\r\nif (hg_config->enable_hg_algo) {\r\nregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\r\nCS35L33_MEM_DEPTH_MASK,\r\nhg_config->mem_depth << CS35L33_MEM_DEPTH_SHIFT);\r\nregmap_write(priv->regmap, CS35L33_HG_REL_RATE,\r\nhg_config->release_rate);\r\nregmap_update_bits(priv->regmap, CS35L33_HG_HEAD,\r\nCS35L33_HD_RM_MASK,\r\nhg_config->hd_rm << CS35L33_HD_RM_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\r\nCS35L33_LDO_THLD_MASK,\r\nhg_config->ldo_thld << CS35L33_LDO_THLD_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\r\nCS35L33_LDO_DISABLE_MASK,\r\nhg_config->ldo_path_disable <<\r\nCS35L33_LDO_DISABLE_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\r\nCS35L33_LDO_ENTRY_DELAY_MASK,\r\nhg_config->ldo_entry_delay <<\r\nCS35L33_LDO_ENTRY_DELAY_SHIFT);\r\nif (hg_config->vp_hg_auto) {\r\nregmap_update_bits(priv->regmap, CS35L33_HG_EN,\r\nCS35L33_VP_HG_AUTO_MASK,\r\nCS35L33_VP_HG_AUTO_MASK);\r\nsnd_soc_dapm_add_routes(dapm, cs35l33_vphg_auto_route,\r\nARRAY_SIZE(cs35l33_vphg_auto_route));\r\n}\r\nregmap_update_bits(priv->regmap, CS35L33_HG_EN,\r\nCS35L33_VP_HG_MASK,\r\nhg_config->vp_hg << CS35L33_VP_HG_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\r\nCS35L33_VP_HG_RATE_MASK,\r\nhg_config->vp_hg_rate << CS35L33_VP_HG_RATE_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\r\nCS35L33_VP_HG_VA_MASK,\r\nhg_config->vp_hg_va << CS35L33_VP_HG_VA_SHIFT);\r\nregmap_update_bits(priv->regmap, CS35L33_HG_EN,\r\nCS35L33_CLASS_HG_EN_MASK, CS35L33_CLASS_HG_EN_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs35l33_set_bst_ipk(struct snd_soc_codec *codec, unsigned int bst)\r\n{\r\nstruct cs35l33_private *cs35l33 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0, steps = 0;\r\nif (bst > 3600000 || bst < 1850000) {\r\ndev_err(codec->dev, "Invalid boost current %d\n", bst);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (bst % 15625) {\r\ndev_err(codec->dev, "Current not a multiple of 15625uA (%d)\n",\r\nbst);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nwhile (bst > 1850000) {\r\nbst -= 15625;\r\nsteps++;\r\n}\r\nregmap_write(cs35l33->regmap, CS35L33_BST_PEAK_CTL,\r\nsteps+0x70);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int cs35l33_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs35l33_private *cs35l33 = snd_soc_codec_get_drvdata(codec);\r\ncs35l33->codec = codec;\r\npm_runtime_get_sync(codec->dev);\r\nregmap_update_bits(cs35l33->regmap, CS35L33_PROTECT_CTL,\r\nCS35L33_ALIVE_WD_DIS, 0x8);\r\nregmap_update_bits(cs35l33->regmap, CS35L33_BST_CTL2,\r\nCS35L33_ALIVE_WD_DIS2,\r\nCS35L33_ALIVE_WD_DIS2);\r\nregmap_update_bits(cs35l33->regmap, CS35L33_BST_CTL1,\r\nCS35L33_BST_CTL_MASK, cs35l33->pdata.boost_ctl);\r\nregmap_update_bits(cs35l33->regmap, CS35L33_CLASSD_CTL,\r\nCS35L33_AMP_DRV_SEL_MASK,\r\ncs35l33->pdata.amp_drv_sel << CS35L33_AMP_DRV_SEL_SHIFT);\r\nif (cs35l33->pdata.boost_ipk)\r\ncs35l33_set_bst_ipk(codec, cs35l33->pdata.boost_ipk);\r\nif (cs35l33->enable_soft_ramp) {\r\nsnd_soc_update_bits(codec, CS35L33_DAC_CTL,\r\nCS35L33_DIGSFT, CS35L33_DIGSFT);\r\nsnd_soc_update_bits(codec, CS35L33_DAC_CTL,\r\nCS35L33_DSR_RATE, cs35l33->pdata.ramp_rate);\r\n} else {\r\nsnd_soc_update_bits(codec, CS35L33_DAC_CTL,\r\nCS35L33_DIGSFT, 0);\r\n}\r\nif (cs35l33->pdata.imon_adc_scale != 0x8)\r\nsnd_soc_update_bits(codec, CS35L33_ADC_CTL,\r\nCS35L33_IMON_SCALE, cs35l33->pdata.imon_adc_scale);\r\ncs35l33_set_hg_data(codec, &(cs35l33->pdata));\r\nregmap_update_bits(cs35l33->regmap, CS35L33_INT_MASK_1,\r\nCS35L33_M_OTE | CS35L33_M_OTW | CS35L33_M_AMP_SHORT |\r\nCS35L33_M_CAL_ERR, 0);\r\npm_runtime_put_sync(codec->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cs35l33_runtime_resume(struct device *dev)\r\n{\r\nstruct cs35l33_private *cs35l33 = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (cs35l33->reset_gpio)\r\ngpiod_set_value_cansleep(cs35l33->reset_gpio, 0);\r\nret = regulator_bulk_enable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable core supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(cs35l33->regmap, false);\r\nif (cs35l33->reset_gpio)\r\ngpiod_set_value_cansleep(cs35l33->reset_gpio, 1);\r\nmsleep(CS35L33_BOOT_DELAY);\r\nret = regcache_sync(cs35l33->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to restore register cache\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nregcache_cache_only(cs35l33->regmap, true);\r\nregulator_bulk_disable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused cs35l33_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs35l33_private *cs35l33 = dev_get_drvdata(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\ncs35l33->amp_cal = false;\r\nregcache_cache_only(cs35l33->regmap, true);\r\nregcache_mark_dirty(cs35l33->regmap);\r\nregulator_bulk_disable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nreturn 0;\r\n}\r\nstatic int cs35l33_get_hg_data(const struct device_node *np,\r\nstruct cs35l33_pdata *pdata)\r\n{\r\nstruct device_node *hg;\r\nstruct cs35l33_hg *hg_config = &pdata->hg_config;\r\nu32 val32;\r\nhg = of_get_child_by_name(np, "cirrus,hg-algo");\r\nhg_config->enable_hg_algo = hg ? true : false;\r\nif (hg_config->enable_hg_algo) {\r\nif (of_property_read_u32(hg, "cirrus,mem-depth", &val32) >= 0)\r\nhg_config->mem_depth = val32;\r\nif (of_property_read_u32(hg, "cirrus,release-rate",\r\n&val32) >= 0)\r\nhg_config->release_rate = val32;\r\nif (of_property_read_u32(hg, "cirrus,ldo-thld", &val32) >= 0)\r\nhg_config->ldo_thld = val32;\r\nif (of_property_read_u32(hg, "cirrus,ldo-path-disable",\r\n&val32) >= 0)\r\nhg_config->ldo_path_disable = val32;\r\nif (of_property_read_u32(hg, "cirrus,ldo-entry-delay",\r\n&val32) >= 0)\r\nhg_config->ldo_entry_delay = val32;\r\nhg_config->vp_hg_auto = of_property_read_bool(hg,\r\n"cirrus,vp-hg-auto");\r\nif (of_property_read_u32(hg, "cirrus,vp-hg", &val32) >= 0)\r\nhg_config->vp_hg = val32;\r\nif (of_property_read_u32(hg, "cirrus,vp-hg-rate", &val32) >= 0)\r\nhg_config->vp_hg_rate = val32;\r\nif (of_property_read_u32(hg, "cirrus,vp-hg-va", &val32) >= 0)\r\nhg_config->vp_hg_va = val32;\r\n}\r\nof_node_put(hg);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t cs35l33_irq_thread(int irq, void *data)\r\n{\r\nstruct cs35l33_private *cs35l33 = data;\r\nstruct snd_soc_codec *codec = cs35l33->codec;\r\nunsigned int sticky_val1, sticky_val2, current_val, mask1, mask2;\r\nregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_2,\r\n&sticky_val2);\r\nregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_1,\r\n&sticky_val1);\r\nregmap_read(cs35l33->regmap, CS35L33_INT_MASK_2, &mask2);\r\nregmap_read(cs35l33->regmap, CS35L33_INT_MASK_1, &mask1);\r\nif (!(sticky_val1 & ~mask1) && !(sticky_val2 & ~mask2))\r\nreturn IRQ_NONE;\r\nregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_1,\r\n&current_val);\r\nif (sticky_val1 & CS35L33_AMP_SHORT) {\r\ndev_crit(codec->dev, "Amp short error\n");\r\nif (!(current_val & CS35L33_AMP_SHORT)) {\r\ndev_dbg(codec->dev,\r\n"Amp short error release\n");\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL,\r\nCS35L33_AMP_SHORT_RLS, 0);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL,\r\nCS35L33_AMP_SHORT_RLS,\r\nCS35L33_AMP_SHORT_RLS);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_AMP_SHORT_RLS,\r\n0);\r\n}\r\n}\r\nif (sticky_val1 & CS35L33_CAL_ERR) {\r\ndev_err(codec->dev, "Cal error\n");\r\ncs35l33->amp_cal = false;\r\nif (!(current_val & CS35L33_CAL_ERR)) {\r\ndev_dbg(codec->dev, "Cal error release\n");\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\r\n0);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\r\nCS35L33_CAL_ERR_RLS);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\r\n0);\r\n}\r\n}\r\nif (sticky_val1 & CS35L33_OTE) {\r\ndev_crit(codec->dev, "Over temperature error\n");\r\nif (!(current_val & CS35L33_OTE)) {\r\ndev_dbg(codec->dev,\r\n"Over temperature error release\n");\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTE_RLS, 0);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTE_RLS,\r\nCS35L33_OTE_RLS);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTE_RLS, 0);\r\n}\r\n}\r\nif (sticky_val1 & CS35L33_OTW) {\r\ndev_err(codec->dev, "Over temperature warning\n");\r\nif (!(current_val & CS35L33_OTW)) {\r\ndev_dbg(codec->dev,\r\n"Over temperature warning release\n");\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTW_RLS, 0);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTW_RLS,\r\nCS35L33_OTW_RLS);\r\nregmap_update_bits(cs35l33->regmap,\r\nCS35L33_AMP_CTL, CS35L33_OTW_RLS, 0);\r\n}\r\n}\r\nif (CS35L33_ALIVE_ERR & sticky_val1)\r\ndev_err(codec->dev, "ERROR: ADSPCLK Interrupt\n");\r\nif (CS35L33_MCLK_ERR & sticky_val1)\r\ndev_err(codec->dev, "ERROR: MCLK Interrupt\n");\r\nif (CS35L33_VMON_OVFL & sticky_val2)\r\ndev_err(codec->dev,\r\n"ERROR: VMON Overflow Interrupt\n");\r\nif (CS35L33_IMON_OVFL & sticky_val2)\r\ndev_err(codec->dev,\r\n"ERROR: IMON Overflow Interrupt\n");\r\nif (CS35L33_VPMON_OVFL & sticky_val2)\r\ndev_err(codec->dev,\r\n"ERROR: VPMON Overflow Interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cs35l33_of_get_pdata(struct device *dev,\r\nstruct cs35l33_private *cs35l33)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct cs35l33_pdata *pdata = &cs35l33->pdata;\r\nu32 val32;\r\nif (!np)\r\nreturn 0;\r\nif (of_property_read_u32(np, "cirrus,boost-ctl", &val32) >= 0) {\r\npdata->boost_ctl = val32;\r\npdata->amp_drv_sel = 1;\r\n}\r\nif (of_property_read_u32(np, "cirrus,ramp-rate", &val32) >= 0) {\r\npdata->ramp_rate = val32;\r\ncs35l33->enable_soft_ramp = true;\r\n}\r\nif (of_property_read_u32(np, "cirrus,boost-ipk", &val32) >= 0)\r\npdata->boost_ipk = val32;\r\nif (of_property_read_u32(np, "cirrus,imon-adc-scale", &val32) >= 0) {\r\nif ((val32 == 0x0) || (val32 == 0x7) || (val32 == 0x6))\r\npdata->imon_adc_scale = val32;\r\nelse\r\npdata->imon_adc_scale = 0x8;\r\n} else {\r\npdata->imon_adc_scale = 0x8;\r\n}\r\ncs35l33_get_hg_data(np, pdata);\r\nreturn 0;\r\n}\r\nstatic int cs35l33_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs35l33_private *cs35l33;\r\nstruct cs35l33_pdata *pdata = dev_get_platdata(&i2c_client->dev);\r\nint ret, devid, i;\r\nunsigned int reg;\r\ncs35l33 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs35l33_private),\r\nGFP_KERNEL);\r\nif (!cs35l33)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c_client, cs35l33);\r\ncs35l33->regmap = devm_regmap_init_i2c(i2c_client, &cs35l33_regmap);\r\nif (IS_ERR(cs35l33->regmap)) {\r\nret = PTR_ERR(cs35l33->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(cs35l33->regmap, true);\r\nfor (i = 0; i < ARRAY_SIZE(cs35l33_core_supplies); i++)\r\ncs35l33->core_supplies[i].supply\r\n= cs35l33_core_supplies[i];\r\ncs35l33->num_core_supplies = ARRAY_SIZE(cs35l33_core_supplies);\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\ncs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (pdata) {\r\ncs35l33->pdata = *pdata;\r\n} else {\r\ncs35l33_of_get_pdata(&i2c_client->dev, cs35l33);\r\npdata = &cs35l33->pdata;\r\n}\r\nret = devm_request_threaded_irq(&i2c_client->dev, i2c_client->irq, NULL,\r\ncs35l33_irq_thread, IRQF_ONESHOT | IRQF_TRIGGER_LOW,\r\n"cs35l33", cs35l33);\r\nif (ret != 0)\r\ndev_warn(&i2c_client->dev, "Failed to request IRQ: %d\n", ret);\r\ncs35l33->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\r\n"reset-gpios", GPIOD_OUT_HIGH);\r\nif (IS_ERR(cs35l33->reset_gpio)) {\r\ndev_err(&i2c_client->dev, "%s ERROR: Can't get reset GPIO\n",\r\n__func__);\r\nreturn PTR_ERR(cs35l33->reset_gpio);\r\n}\r\nret = regulator_bulk_enable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to enable core supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (cs35l33->reset_gpio)\r\ngpiod_set_value_cansleep(cs35l33->reset_gpio, 1);\r\nmsleep(CS35L33_BOOT_DELAY);\r\nregcache_cache_only(cs35l33->regmap, false);\r\nret = regmap_read(cs35l33->regmap, CS35L33_DEVID_AB, &reg);\r\ndevid = (reg & 0xFF) << 12;\r\nret = regmap_read(cs35l33->regmap, CS35L33_DEVID_CD, &reg);\r\ndevid |= (reg & 0xFF) << 4;\r\nret = regmap_read(cs35l33->regmap, CS35L33_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS35L33_CHIP_ID) {\r\ndev_err(&i2c_client->dev,\r\n"CS35L33 Device ID (%X). Expected ID %X\n",\r\ndevid, CS35L33_CHIP_ID);\r\ngoto err_enable;\r\n}\r\nret = regmap_read(cs35l33->regmap, CS35L33_REV_ID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Get Revision ID failed\n");\r\ngoto err_enable;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"Cirrus Logic CS35L33, Revision: %02X\n", reg & 0xFF);\r\nret = regmap_register_patch(cs35l33->regmap,\r\ncs35l33_patch, ARRAY_SIZE(cs35l33_patch));\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev,\r\n"Error in applying regmap patch: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\r\nCS35L33_MCLKDIS | CS35L33_SDOUT_3ST_TDM,\r\nCS35L33_MCLKDIS | CS35L33_SDOUT_3ST_TDM);\r\npm_runtime_set_autosuspend_delay(&i2c_client->dev, 100);\r\npm_runtime_use_autosuspend(&i2c_client->dev);\r\npm_runtime_set_active(&i2c_client->dev);\r\npm_runtime_enable(&i2c_client->dev);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs35l33, &cs35l33_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "%s: Register codec failed\n",\r\n__func__);\r\ngoto err_enable;\r\n}\r\nreturn 0;\r\nerr_enable:\r\nregulator_bulk_disable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nreturn ret;\r\n}\r\nstatic int cs35l33_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct cs35l33_private *cs35l33 = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nif (cs35l33->reset_gpio)\r\ngpiod_set_value_cansleep(cs35l33->reset_gpio, 0);\r\npm_runtime_disable(&client->dev);\r\nregulator_bulk_disable(cs35l33->num_core_supplies,\r\ncs35l33->core_supplies);\r\nreturn 0;\r\n}
