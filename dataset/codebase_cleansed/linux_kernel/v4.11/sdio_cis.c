static int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nunsigned i, nr_strings;\r\nchar **buffer, *string;\r\nbuf += 2;\r\nsize -= 2;\r\nnr_strings = 0;\r\nfor (i = 0; i < size; i++) {\r\nif (buf[i] == 0xff)\r\nbreak;\r\nif (buf[i] == 0)\r\nnr_strings++;\r\n}\r\nif (nr_strings == 0)\r\nreturn 0;\r\nsize = i;\r\nbuffer = kzalloc(sizeof(char*) * nr_strings + size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nstring = (char*)(buffer + nr_strings);\r\nfor (i = 0; i < nr_strings; i++) {\r\nbuffer[i] = string;\r\nstrcpy(string, buf);\r\nstring += strlen(string) + 1;\r\nbuf += strlen(buf) + 1;\r\n}\r\nif (func) {\r\nfunc->num_info = nr_strings;\r\nfunc->info = (const char**)buffer;\r\n} else {\r\ncard->num_info = nr_strings;\r\ncard->info = (const char**)buffer;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cistpl_manfid(struct mmc_card *card, struct sdio_func *func,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nunsigned int vendor, device;\r\nvendor = buf[0] | (buf[1] << 8);\r\ndevice = buf[2] | (buf[3] << 8);\r\nif (func) {\r\nfunc->vendor = vendor;\r\nfunc->device = device;\r\n} else {\r\ncard->cis.vendor = vendor;\r\ncard->cis.device = device;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cis_tpl_parse(struct mmc_card *card, struct sdio_func *func,\r\nconst char *tpl_descr,\r\nconst struct cis_tpl *tpl, int tpl_count,\r\nunsigned char code,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < tpl_count; i++, tpl++) {\r\nif (tpl->code == code)\r\nbreak;\r\n}\r\nif (i < tpl_count) {\r\nif (size >= tpl->min_size) {\r\nif (tpl->parse)\r\nret = tpl->parse(card, func, buf, size);\r\nelse\r\nret = -EILSEQ;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (ret && ret != -EILSEQ && ret != -ENOENT) {\r\npr_err("%s: bad %s tuple 0x%02x (%u bytes)\n",\r\nmmc_hostname(card->host), tpl_descr, code, size);\r\n}\r\n} else {\r\nret = -ENOENT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cistpl_funce_common(struct mmc_card *card, struct sdio_func *func,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nif (func)\r\nreturn -EINVAL;\r\ncard->cis.blksize = buf[1] | (buf[2] << 8);\r\ncard->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *\r\nspeed_unit[buf[3] & 7];\r\nreturn 0;\r\n}\r\nstatic int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nunsigned vsn;\r\nunsigned min_size;\r\nif (!func)\r\nreturn -EINVAL;\r\nvsn = func->card->cccr.sdio_vsn;\r\nmin_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;\r\nif (size == 28 && vsn == SDIO_SDIO_REV_1_10) {\r\npr_warn("%s: card has broken SDIO 1.1 CIS, forcing SDIO 1.0\n",\r\nmmc_hostname(card->host));\r\nvsn = SDIO_SDIO_REV_1_00;\r\n} else if (size < min_size) {\r\nreturn -EINVAL;\r\n}\r\nfunc->max_blksize = buf[12] | (buf[13] << 8);\r\nif (vsn > SDIO_SDIO_REV_1_00)\r\nfunc->enable_timeout = (buf[28] | (buf[29] << 8)) * 10;\r\nelse\r\nfunc->enable_timeout = jiffies_to_msecs(HZ);\r\nreturn 0;\r\n}\r\nstatic int cistpl_funce(struct mmc_card *card, struct sdio_func *func,\r\nconst unsigned char *buf, unsigned size)\r\n{\r\nif (size < 1)\r\nreturn -EINVAL;\r\nreturn cis_tpl_parse(card, func, "CISTPL_FUNCE",\r\ncis_tpl_funce_list,\r\nARRAY_SIZE(cis_tpl_funce_list),\r\nbuf[0], buf, size);\r\n}\r\nstatic int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)\r\n{\r\nint ret;\r\nstruct sdio_func_tuple *this, **prev;\r\nunsigned i, ptr = 0;\r\nfor (i = 0; i < 3; i++) {\r\nunsigned char x, fn;\r\nif (func)\r\nfn = func->num;\r\nelse\r\nfn = 0;\r\nret = mmc_io_rw_direct(card, 0, 0,\r\nSDIO_FBR_BASE(fn) + SDIO_FBR_CIS + i, 0, &x);\r\nif (ret)\r\nreturn ret;\r\nptr |= x << (i * 8);\r\n}\r\nif (func)\r\nprev = &func->tuples;\r\nelse\r\nprev = &card->tuples;\r\nif (*prev)\r\nreturn -EINVAL;\r\ndo {\r\nunsigned char tpl_code, tpl_link;\r\nret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_code);\r\nif (ret)\r\nbreak;\r\nif (tpl_code == 0xff)\r\nbreak;\r\nif (tpl_code == 0x00)\r\ncontinue;\r\nret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);\r\nif (ret)\r\nbreak;\r\nif (tpl_link == 0xff)\r\nbreak;\r\nthis = kmalloc(sizeof(*this) + tpl_link, GFP_KERNEL);\r\nif (!this)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < tpl_link; i++) {\r\nret = mmc_io_rw_direct(card, 0, 0,\r\nptr + i, 0, &this->data[i]);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret) {\r\nkfree(this);\r\nbreak;\r\n}\r\nret = cis_tpl_parse(card, func, "CIS",\r\ncis_tpl_list, ARRAY_SIZE(cis_tpl_list),\r\ntpl_code, this->data, tpl_link);\r\nif (ret == -EILSEQ || ret == -ENOENT) {\r\nthis->next = NULL;\r\nthis->code = tpl_code;\r\nthis->size = tpl_link;\r\n*prev = this;\r\nprev = &this->next;\r\nif (ret == -ENOENT) {\r\npr_warn_ratelimited("%s: queuing unknown"\r\n" CIS tuple 0x%02x (%u bytes)\n",\r\nmmc_hostname(card->host),\r\ntpl_code, tpl_link);\r\n}\r\nret = 0;\r\n} else {\r\nkfree(this);\r\n}\r\nptr += tpl_link;\r\n} while (!ret);\r\nif (func)\r\n*prev = card->tuples;\r\nreturn ret;\r\n}\r\nint sdio_read_common_cis(struct mmc_card *card)\r\n{\r\nreturn sdio_read_cis(card, NULL);\r\n}\r\nvoid sdio_free_common_cis(struct mmc_card *card)\r\n{\r\nstruct sdio_func_tuple *tuple, *victim;\r\ntuple = card->tuples;\r\nwhile (tuple) {\r\nvictim = tuple;\r\ntuple = tuple->next;\r\nkfree(victim);\r\n}\r\ncard->tuples = NULL;\r\n}\r\nint sdio_read_func_cis(struct sdio_func *func)\r\n{\r\nint ret;\r\nret = sdio_read_cis(func->card, func);\r\nif (ret)\r\nreturn ret;\r\nget_device(&func->card->dev);\r\nif (func->vendor == 0) {\r\nfunc->vendor = func->card->cis.vendor;\r\nfunc->device = func->card->cis.device;\r\n}\r\nreturn 0;\r\n}\r\nvoid sdio_free_func_cis(struct sdio_func *func)\r\n{\r\nstruct sdio_func_tuple *tuple, *victim;\r\ntuple = func->tuples;\r\nwhile (tuple && tuple != func->card->tuples) {\r\nvictim = tuple;\r\ntuple = tuple->next;\r\nkfree(victim);\r\n}\r\nfunc->tuples = NULL;\r\nput_device(&func->card->dev);\r\n}
