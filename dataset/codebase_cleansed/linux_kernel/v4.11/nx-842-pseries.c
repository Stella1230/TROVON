static int check_constraints(unsigned long buf, unsigned int *len, bool in)\r\n{\r\nif (!IS_ALIGNED(buf, nx842_pseries_constraints.alignment)) {\r\npr_debug("%s buffer 0x%lx not aligned to 0x%x\n",\r\nin ? "input" : "output", buf,\r\nnx842_pseries_constraints.alignment);\r\nreturn -EINVAL;\r\n}\r\nif (*len % nx842_pseries_constraints.multiple) {\r\npr_debug("%s buffer len 0x%x not multiple of 0x%x\n",\r\nin ? "input" : "output", *len,\r\nnx842_pseries_constraints.multiple);\r\nif (in)\r\nreturn -EINVAL;\r\n*len = round_down(*len, nx842_pseries_constraints.multiple);\r\n}\r\nif (*len < nx842_pseries_constraints.minimum) {\r\npr_debug("%s buffer len 0x%x under minimum 0x%x\n",\r\nin ? "input" : "output", *len,\r\nnx842_pseries_constraints.minimum);\r\nreturn -EINVAL;\r\n}\r\nif (*len > nx842_pseries_constraints.maximum) {\r\npr_debug("%s buffer len 0x%x over maximum 0x%x\n",\r\nin ? "input" : "output", *len,\r\nnx842_pseries_constraints.maximum);\r\nif (in)\r\nreturn -EINVAL;\r\n*len = nx842_pseries_constraints.maximum;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ibm_nx842_incr_hist(atomic64_t *times, unsigned int time)\r\n{\r\nint bucket = fls(time);\r\nif (bucket)\r\nbucket = min((NX842_HIST_SLOTS - 1), bucket - 1);\r\natomic64_inc(&times[bucket]);\r\n}\r\nstatic unsigned long nx842_get_desired_dma(struct vio_dev *viodev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned long nx842_get_scatterlist_size(\r\nstruct nx842_scatterlist *sl)\r\n{\r\nreturn sl->entry_nr * sizeof(struct nx842_slentry);\r\n}\r\nstatic int nx842_build_scatterlist(unsigned long buf, int len,\r\nstruct nx842_scatterlist *sl)\r\n{\r\nunsigned long entrylen;\r\nstruct nx842_slentry *entry;\r\nsl->entry_nr = 0;\r\nentry = sl->entries;\r\nwhile (len) {\r\nentry->ptr = cpu_to_be64(nx842_get_pa((void *)buf));\r\nentrylen = min_t(int, len,\r\nLEN_ON_SIZE(buf, NX842_HW_PAGE_SIZE));\r\nentry->len = cpu_to_be64(entrylen);\r\nlen -= entrylen;\r\nbuf += entrylen;\r\nsl->entry_nr++;\r\nentry++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nx842_validate_result(struct device *dev,\r\nstruct cop_status_block *csb)\r\n{\r\nif (!NX842_CSBCBP_VALID_CHK(csb->valid)) {\r\ndev_err(dev, "%s: cspcbp not valid upon completion.\n",\r\n__func__);\r\ndev_dbg(dev, "valid:0x%02x cs:0x%02x cc:0x%02x ce:0x%02x\n",\r\ncsb->valid,\r\ncsb->crb_seq_number,\r\ncsb->completion_code,\r\ncsb->completion_extension);\r\ndev_dbg(dev, "processed_bytes:%d address:0x%016lx\n",\r\nbe32_to_cpu(csb->processed_byte_count),\r\n(unsigned long)be64_to_cpu(csb->address));\r\nreturn -EIO;\r\n}\r\nswitch (csb->completion_code) {\r\ncase 0:\r\nbreak;\r\ncase 64:\r\ndev_dbg(dev, "%s: output size larger than input size\n",\r\n__func__);\r\nbreak;\r\ncase 13:\r\ndev_dbg(dev, "%s: Out of space in output buffer\n",\r\n__func__);\r\nreturn -ENOSPC;\r\ncase 65:\r\ndev_dbg(dev, "%s: CRC mismatch for decompression\n",\r\n__func__);\r\nreturn -EINVAL;\r\ncase 66:\r\ncase 67:\r\ndev_dbg(dev, "%s: Bad data for decompression (code:%d)\n",\r\n__func__, csb->completion_code);\r\nreturn -EINVAL;\r\ndefault:\r\ndev_dbg(dev, "%s: Unspecified error (code:%d)\n",\r\n__func__, csb->completion_code);\r\nreturn -EIO;\r\n}\r\nif (!NX842_CSBCPB_CE2(csb->completion_extension)) {\r\ndev_err(dev, "%s: No error returned by hardware, but "\r\n"data returned is unusable, contact support.\n"\r\n"(Additional info: csbcbp->processed bytes "\r\n"does not specify processed bytes for the "\r\n"target buffer.)\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nx842_pseries_compress(const unsigned char *in, unsigned int inlen,\r\nunsigned char *out, unsigned int *outlen,\r\nvoid *wmem)\r\n{\r\nstruct nx842_devdata *local_devdata;\r\nstruct device *dev = NULL;\r\nstruct nx842_workmem *workmem;\r\nstruct nx842_scatterlist slin, slout;\r\nstruct nx_csbcpb *csbcpb;\r\nint ret = 0, max_sync_size;\r\nunsigned long inbuf, outbuf;\r\nstruct vio_pfo_op op = {\r\n.done = NULL,\r\n.handle = 0,\r\n.timeout = 0,\r\n};\r\nunsigned long start = get_tb();\r\ninbuf = (unsigned long)in;\r\nif (check_constraints(inbuf, &inlen, true))\r\nreturn -EINVAL;\r\noutbuf = (unsigned long)out;\r\nif (check_constraints(outbuf, outlen, false))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (!local_devdata || !local_devdata->dev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nmax_sync_size = local_devdata->max_sync_size;\r\ndev = local_devdata->dev;\r\nworkmem = PTR_ALIGN(wmem, WORKMEM_ALIGN);\r\nslin.entries = (struct nx842_slentry *)workmem->slin;\r\nslout.entries = (struct nx842_slentry *)workmem->slout;\r\nop.flags = NX842_OP_COMPRESS_CRC;\r\ncsbcpb = &workmem->csbcpb;\r\nmemset(csbcpb, 0, sizeof(*csbcpb));\r\nop.csbcpb = nx842_get_pa(csbcpb);\r\nif ((inbuf & NX842_HW_PAGE_MASK) ==\r\n((inbuf + inlen - 1) & NX842_HW_PAGE_MASK)) {\r\nop.in = nx842_get_pa((void *)inbuf);\r\nop.inlen = inlen;\r\n} else {\r\nnx842_build_scatterlist(inbuf, inlen, &slin);\r\nop.in = nx842_get_pa(slin.entries);\r\nop.inlen = -nx842_get_scatterlist_size(&slin);\r\n}\r\nif ((outbuf & NX842_HW_PAGE_MASK) ==\r\n((outbuf + *outlen - 1) & NX842_HW_PAGE_MASK)) {\r\nop.out = nx842_get_pa((void *)outbuf);\r\nop.outlen = *outlen;\r\n} else {\r\nnx842_build_scatterlist(outbuf, *outlen, &slout);\r\nop.out = nx842_get_pa(slout.entries);\r\nop.outlen = -nx842_get_scatterlist_size(&slout);\r\n}\r\ndev_dbg(dev, "%s: op.in %lx op.inlen %ld op.out %lx op.outlen %ld\n",\r\n__func__, (unsigned long)op.in, (long)op.inlen,\r\n(unsigned long)op.out, (long)op.outlen);\r\nret = vio_h_cop_sync(local_devdata->vdev, &op);\r\nif (ret) {\r\ndev_dbg(dev, "%s: vio_h_cop_sync error (ret=%d, hret=%ld)\n",\r\n__func__, ret, op.hcall_err);\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nret = nx842_validate_result(dev, &csbcpb->csb);\r\nif (ret)\r\ngoto unlock;\r\n*outlen = be32_to_cpu(csbcpb->csb.processed_byte_count);\r\ndev_dbg(dev, "%s: processed_bytes=%d\n", __func__, *outlen);\r\nunlock:\r\nif (ret)\r\nnx842_inc_comp_failed(local_devdata);\r\nelse {\r\nnx842_inc_comp_complete(local_devdata);\r\nibm_nx842_incr_hist(local_devdata->counters->comp_times,\r\n(get_tb() - start) / tb_ticks_per_usec);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int nx842_pseries_decompress(const unsigned char *in, unsigned int inlen,\r\nunsigned char *out, unsigned int *outlen,\r\nvoid *wmem)\r\n{\r\nstruct nx842_devdata *local_devdata;\r\nstruct device *dev = NULL;\r\nstruct nx842_workmem *workmem;\r\nstruct nx842_scatterlist slin, slout;\r\nstruct nx_csbcpb *csbcpb;\r\nint ret = 0, max_sync_size;\r\nunsigned long inbuf, outbuf;\r\nstruct vio_pfo_op op = {\r\n.done = NULL,\r\n.handle = 0,\r\n.timeout = 0,\r\n};\r\nunsigned long start = get_tb();\r\ninbuf = (unsigned long)in;\r\nif (check_constraints(inbuf, &inlen, true))\r\nreturn -EINVAL;\r\noutbuf = (unsigned long)out;\r\nif (check_constraints(outbuf, outlen, false))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (!local_devdata || !local_devdata->dev) {\r\nrcu_read_unlock();\r\nreturn -ENODEV;\r\n}\r\nmax_sync_size = local_devdata->max_sync_size;\r\ndev = local_devdata->dev;\r\nworkmem = PTR_ALIGN(wmem, WORKMEM_ALIGN);\r\nslin.entries = (struct nx842_slentry *)workmem->slin;\r\nslout.entries = (struct nx842_slentry *)workmem->slout;\r\nop.flags = NX842_OP_DECOMPRESS_CRC;\r\ncsbcpb = &workmem->csbcpb;\r\nmemset(csbcpb, 0, sizeof(*csbcpb));\r\nop.csbcpb = nx842_get_pa(csbcpb);\r\nif ((inbuf & NX842_HW_PAGE_MASK) ==\r\n((inbuf + inlen - 1) & NX842_HW_PAGE_MASK)) {\r\nop.in = nx842_get_pa((void *)inbuf);\r\nop.inlen = inlen;\r\n} else {\r\nnx842_build_scatterlist(inbuf, inlen, &slin);\r\nop.in = nx842_get_pa(slin.entries);\r\nop.inlen = -nx842_get_scatterlist_size(&slin);\r\n}\r\nif ((outbuf & NX842_HW_PAGE_MASK) ==\r\n((outbuf + *outlen - 1) & NX842_HW_PAGE_MASK)) {\r\nop.out = nx842_get_pa((void *)outbuf);\r\nop.outlen = *outlen;\r\n} else {\r\nnx842_build_scatterlist(outbuf, *outlen, &slout);\r\nop.out = nx842_get_pa(slout.entries);\r\nop.outlen = -nx842_get_scatterlist_size(&slout);\r\n}\r\ndev_dbg(dev, "%s: op.in %lx op.inlen %ld op.out %lx op.outlen %ld\n",\r\n__func__, (unsigned long)op.in, (long)op.inlen,\r\n(unsigned long)op.out, (long)op.outlen);\r\nret = vio_h_cop_sync(local_devdata->vdev, &op);\r\nif (ret) {\r\ndev_dbg(dev, "%s: vio_h_cop_sync error (ret=%d, hret=%ld)\n",\r\n__func__, ret, op.hcall_err);\r\ngoto unlock;\r\n}\r\nret = nx842_validate_result(dev, &csbcpb->csb);\r\nif (ret)\r\ngoto unlock;\r\n*outlen = be32_to_cpu(csbcpb->csb.processed_byte_count);\r\nunlock:\r\nif (ret)\r\nnx842_inc_decomp_failed(local_devdata);\r\nelse {\r\nnx842_inc_decomp_complete(local_devdata);\r\nibm_nx842_incr_hist(local_devdata->counters->decomp_times,\r\n(get_tb() - start) / tb_ticks_per_usec);\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_set_defaults(struct nx842_devdata *devdata)\r\n{\r\nif (devdata) {\r\ndevdata->max_sync_size = 0;\r\ndevdata->max_sync_sg = 0;\r\ndevdata->max_sg_len = 0;\r\nreturn 0;\r\n} else\r\nreturn -ENOENT;\r\n}\r\nstatic int nx842_OF_upd_status(struct property *prop)\r\n{\r\nconst char *status = (const char *)prop->value;\r\nif (!strncmp(status, "okay", (size_t)prop->length))\r\nreturn 0;\r\nif (!strncmp(status, "disabled", (size_t)prop->length))\r\nreturn -ENODEV;\r\ndev_info(devdata->dev, "%s: unknown status '%s'\n", __func__, status);\r\nreturn -EINVAL;\r\n}\r\nstatic int nx842_OF_upd_maxsglen(struct nx842_devdata *devdata,\r\nstruct property *prop) {\r\nint ret = 0;\r\nconst unsigned int maxsglen = of_read_number(prop->value, 1);\r\nif (prop->length != sizeof(maxsglen)) {\r\ndev_err(devdata->dev, "%s: unexpected format for ibm,max-sg-len property\n", __func__);\r\ndev_dbg(devdata->dev, "%s: ibm,max-sg-len is %d bytes long, expected %lu bytes\n", __func__,\r\nprop->length, sizeof(maxsglen));\r\nret = -EINVAL;\r\n} else {\r\ndevdata->max_sg_len = min_t(unsigned int,\r\nmaxsglen, NX842_HW_PAGE_SIZE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_upd_maxsyncop(struct nx842_devdata *devdata,\r\nstruct property *prop) {\r\nint ret = 0;\r\nunsigned int comp_data_limit, decomp_data_limit;\r\nunsigned int comp_sg_limit, decomp_sg_limit;\r\nconst struct maxsynccop_t {\r\n__be32 comp_elements;\r\n__be32 comp_data_limit;\r\n__be32 comp_sg_limit;\r\n__be32 decomp_elements;\r\n__be32 decomp_data_limit;\r\n__be32 decomp_sg_limit;\r\n} *maxsynccop;\r\nif (prop->length != sizeof(*maxsynccop)) {\r\ndev_err(devdata->dev, "%s: unexpected format for ibm,max-sync-cop property\n", __func__);\r\ndev_dbg(devdata->dev, "%s: ibm,max-sync-cop is %d bytes long, expected %lu bytes\n", __func__, prop->length,\r\nsizeof(*maxsynccop));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmaxsynccop = (const struct maxsynccop_t *)prop->value;\r\ncomp_data_limit = be32_to_cpu(maxsynccop->comp_data_limit);\r\ncomp_sg_limit = be32_to_cpu(maxsynccop->comp_sg_limit);\r\ndecomp_data_limit = be32_to_cpu(maxsynccop->decomp_data_limit);\r\ndecomp_sg_limit = be32_to_cpu(maxsynccop->decomp_sg_limit);\r\ndevdata->max_sync_size = min(comp_data_limit, decomp_data_limit);\r\ndevdata->max_sync_size = min_t(unsigned int, devdata->max_sync_size,\r\n65536);\r\nif (devdata->max_sync_size < 4096) {\r\ndev_err(devdata->dev, "%s: hardware max data size (%u) is "\r\n"less than the driver minimum, unable to use "\r\n"the hardware device\n",\r\n__func__, devdata->max_sync_size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnx842_pseries_constraints.maximum = devdata->max_sync_size;\r\ndevdata->max_sync_sg = min(comp_sg_limit, decomp_sg_limit);\r\nif (devdata->max_sync_sg < 1) {\r\ndev_err(devdata->dev, "%s: hardware max sg size (%u) is "\r\n"less than the driver minimum, unable to use "\r\n"the hardware device\n",\r\n__func__, devdata->max_sync_sg);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_upd(struct property *new_prop)\r\n{\r\nstruct nx842_devdata *old_devdata = NULL;\r\nstruct nx842_devdata *new_devdata = NULL;\r\nstruct device_node *of_node = NULL;\r\nstruct property *status = NULL;\r\nstruct property *maxsglen = NULL;\r\nstruct property *maxsyncop = NULL;\r\nint ret = 0;\r\nunsigned long flags;\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\r\nif (!new_devdata)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nif (old_devdata)\r\nof_node = old_devdata->dev->of_node;\r\nif (!old_devdata || !of_node) {\r\npr_err("%s: device is not available\n", __func__);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nkfree(new_devdata);\r\nreturn -ENODEV;\r\n}\r\nmemcpy(new_devdata, old_devdata, sizeof(*old_devdata));\r\nnew_devdata->counters = old_devdata->counters;\r\nstatus = of_find_property(of_node, "status", NULL);\r\nmaxsglen = of_find_property(of_node, "ibm,max-sg-len", NULL);\r\nmaxsyncop = of_find_property(of_node, "ibm,max-sync-cop", NULL);\r\nif (!status || !maxsglen || !maxsyncop) {\r\ndev_err(old_devdata->dev, "%s: Could not locate device properties\n", __func__);\r\nret = -EINVAL;\r\ngoto error_out;\r\n}\r\nif (new_prop && (strncmp(new_prop->name, "status", new_prop->length) ||\r\nstrncmp(new_prop->name, "ibm,max-sg-len", new_prop->length) ||\r\nstrncmp(new_prop->name, "ibm,max-sync-cop", new_prop->length)))\r\ngoto out;\r\nret = nx842_OF_upd_status(status);\r\nif (ret)\r\ngoto error_out;\r\nret = nx842_OF_upd_maxsglen(new_devdata, maxsglen);\r\nif (ret)\r\ngoto error_out;\r\nret = nx842_OF_upd_maxsyncop(new_devdata, maxsyncop);\r\nif (ret)\r\ngoto error_out;\r\nout:\r\ndev_info(old_devdata->dev, "%s: max_sync_size new:%u old:%u\n",\r\n__func__, new_devdata->max_sync_size,\r\nold_devdata->max_sync_size);\r\ndev_info(old_devdata->dev, "%s: max_sync_sg new:%u old:%u\n",\r\n__func__, new_devdata->max_sync_sg,\r\nold_devdata->max_sync_sg);\r\ndev_info(old_devdata->dev, "%s: max_sg_len new:%u old:%u\n",\r\n__func__, new_devdata->max_sg_len,\r\nold_devdata->max_sg_len);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(new_devdata->dev, new_devdata);\r\nkfree(old_devdata);\r\nreturn 0;\r\nerror_out:\r\nif (new_devdata) {\r\ndev_info(old_devdata->dev, "%s: device disabled\n", __func__);\r\nnx842_OF_set_defaults(new_devdata);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(new_devdata->dev, new_devdata);\r\nkfree(old_devdata);\r\n} else {\r\ndev_err(old_devdata->dev, "%s: could not update driver from hardware\n", __func__);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\n}\r\nif (!ret)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int nx842_OF_notifier(struct notifier_block *np, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct of_reconfig_data *upd = data;\r\nstruct nx842_devdata *local_devdata;\r\nstruct device_node *node = NULL;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (local_devdata)\r\nnode = local_devdata->dev->of_node;\r\nif (local_devdata &&\r\naction == OF_RECONFIG_UPDATE_PROPERTY &&\r\n!strcmp(upd->dn->name, node->name)) {\r\nrcu_read_unlock();\r\nnx842_OF_upd(upd->prop);\r\n} else\r\nrcu_read_unlock();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic ssize_t nx842_timehist_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf) {\r\nchar *p = buf;\r\nstruct nx842_devdata *local_devdata;\r\natomic64_t *times;\r\nint bytes_remain = PAGE_SIZE;\r\nint bytes;\r\nint i;\r\nrcu_read_lock();\r\nlocal_devdata = rcu_dereference(devdata);\r\nif (!local_devdata) {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nif (attr == &dev_attr_comp_times)\r\ntimes = local_devdata->counters->comp_times;\r\nelse if (attr == &dev_attr_decomp_times)\r\ntimes = local_devdata->counters->decomp_times;\r\nelse {\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nfor (i = 0; i < (NX842_HIST_SLOTS - 2); i++) {\r\nbytes = snprintf(p, bytes_remain, "%u-%uus:\t%ld\n",\r\ni ? (2<<(i-1)) : 0, (2<<i)-1,\r\natomic64_read(&times[i]));\r\nbytes_remain -= bytes;\r\np += bytes;\r\n}\r\nbytes = snprintf(p, bytes_remain, "%uus - :\t%ld\n",\r\n2<<(NX842_HIST_SLOTS - 2),\r\natomic64_read(&times[(NX842_HIST_SLOTS - 1)]));\r\np += bytes;\r\nrcu_read_unlock();\r\nreturn p - buf;\r\n}\r\nstatic int nx842_pseries_crypto_init(struct crypto_tfm *tfm)\r\n{\r\nreturn nx842_crypto_init(tfm, &nx842_pseries_driver);\r\n}\r\nstatic int nx842_probe(struct vio_dev *viodev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct nx842_devdata *old_devdata, *new_devdata = NULL;\r\nunsigned long flags;\r\nint ret = 0;\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_NOFS);\r\nif (!new_devdata)\r\nreturn -ENOMEM;\r\nnew_devdata->counters = kzalloc(sizeof(*new_devdata->counters),\r\nGFP_NOFS);\r\nif (!new_devdata->counters) {\r\nkfree(new_devdata);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nif (old_devdata && old_devdata->vdev != NULL) {\r\ndev_err(&viodev->dev, "%s: Attempt to register more than one instance of the hardware\n", __func__);\r\nret = -1;\r\ngoto error_unlock;\r\n}\r\ndev_set_drvdata(&viodev->dev, NULL);\r\nnew_devdata->vdev = viodev;\r\nnew_devdata->dev = &viodev->dev;\r\nnx842_OF_set_defaults(new_devdata);\r\nrcu_assign_pointer(devdata, new_devdata);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\nkfree(old_devdata);\r\nof_reconfig_notifier_register(&nx842_of_nb);\r\nret = nx842_OF_upd(NULL);\r\nif (ret)\r\ngoto error;\r\nret = crypto_register_alg(&nx842_pseries_alg);\r\nif (ret) {\r\ndev_err(&viodev->dev, "could not register comp alg: %d\n", ret);\r\ngoto error;\r\n}\r\nrcu_read_lock();\r\ndev_set_drvdata(&viodev->dev, rcu_dereference(devdata));\r\nrcu_read_unlock();\r\nif (sysfs_create_group(&viodev->dev.kobj, &nx842_attribute_group)) {\r\ndev_err(&viodev->dev, "could not create sysfs device attributes\n");\r\nret = -1;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror_unlock:\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nif (new_devdata)\r\nkfree(new_devdata->counters);\r\nkfree(new_devdata);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int nx842_remove(struct vio_dev *viodev)\r\n{\r\nstruct nx842_devdata *old_devdata;\r\nunsigned long flags;\r\npr_info("Removing IBM Power 842 compression device\n");\r\nsysfs_remove_group(&viodev->dev.kobj, &nx842_attribute_group);\r\ncrypto_unregister_alg(&nx842_pseries_alg);\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nof_reconfig_notifier_unregister(&nx842_of_nb);\r\nRCU_INIT_POINTER(devdata, NULL);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\ndev_set_drvdata(&viodev->dev, NULL);\r\nif (old_devdata)\r\nkfree(old_devdata->counters);\r\nkfree(old_devdata);\r\nreturn 0;\r\n}\r\nstatic int __init nx842_pseries_init(void)\r\n{\r\nstruct nx842_devdata *new_devdata;\r\nint ret;\r\nif (!of_find_compatible_node(NULL, NULL, "ibm,compression"))\r\nreturn -ENODEV;\r\nRCU_INIT_POINTER(devdata, NULL);\r\nnew_devdata = kzalloc(sizeof(*new_devdata), GFP_KERNEL);\r\nif (!new_devdata) {\r\npr_err("Could not allocate memory for device data\n");\r\nreturn -ENOMEM;\r\n}\r\nRCU_INIT_POINTER(devdata, new_devdata);\r\nret = vio_register_driver(&nx842_vio_driver);\r\nif (ret) {\r\npr_err("Could not register VIO driver %d\n", ret);\r\nkfree(new_devdata);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit nx842_pseries_exit(void)\r\n{\r\nstruct nx842_devdata *old_devdata;\r\nunsigned long flags;\r\ncrypto_unregister_alg(&nx842_pseries_alg);\r\nspin_lock_irqsave(&devdata_mutex, flags);\r\nold_devdata = rcu_dereference_check(devdata,\r\nlockdep_is_held(&devdata_mutex));\r\nRCU_INIT_POINTER(devdata, NULL);\r\nspin_unlock_irqrestore(&devdata_mutex, flags);\r\nsynchronize_rcu();\r\nif (old_devdata && old_devdata->dev)\r\ndev_set_drvdata(old_devdata->dev, NULL);\r\nkfree(old_devdata);\r\nvio_unregister_driver(&nx842_vio_driver);\r\n}
