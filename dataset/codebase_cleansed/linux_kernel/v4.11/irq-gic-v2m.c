static void gicv2m_mask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_mask_irq(d);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void gicv2m_unmask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_unmask_irq(d);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic void gicv2m_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)\r\n{\r\nstruct v2m_data *v2m = irq_data_get_irq_chip_data(data);\r\nphys_addr_t addr = v2m->res.start + V2M_MSI_SETSPI_NS;\r\nmsg->address_hi = upper_32_bits(addr);\r\nmsg->address_lo = lower_32_bits(addr);\r\nmsg->data = data->hwirq;\r\nif (v2m->flags & GICV2M_NEEDS_SPI_OFFSET)\r\nmsg->data -= v2m->spi_offset;\r\niommu_dma_map_msi_msg(data->irq, msg);\r\n}\r\nstatic int gicv2m_irq_gic_domain_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct irq_fwspec fwspec;\r\nstruct irq_data *d;\r\nint err;\r\nif (is_of_node(domain->parent->fwnode)) {\r\nfwspec.fwnode = domain->parent->fwnode;\r\nfwspec.param_count = 3;\r\nfwspec.param[0] = 0;\r\nfwspec.param[1] = hwirq - 32;\r\nfwspec.param[2] = IRQ_TYPE_EDGE_RISING;\r\n} else if (is_fwnode_irqchip(domain->parent->fwnode)) {\r\nfwspec.fwnode = domain->parent->fwnode;\r\nfwspec.param_count = 2;\r\nfwspec.param[0] = hwirq;\r\nfwspec.param[1] = IRQ_TYPE_EDGE_RISING;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nerr = irq_domain_alloc_irqs_parent(domain, virq, 1, &fwspec);\r\nif (err)\r\nreturn err;\r\nd = irq_domain_get_irq_data(domain->parent, virq);\r\nd->chip->irq_set_type(d, IRQ_TYPE_EDGE_RISING);\r\nreturn 0;\r\n}\r\nstatic void gicv2m_unalloc_msi(struct v2m_data *v2m, unsigned int hwirq)\r\n{\r\nint pos;\r\npos = hwirq - v2m->spi_start;\r\nif (pos < 0 || pos >= v2m->nr_spis) {\r\npr_err("Failed to teardown msi. Invalid hwirq %d\n", hwirq);\r\nreturn;\r\n}\r\nspin_lock(&v2m_lock);\r\n__clear_bit(pos, v2m->bm);\r\nspin_unlock(&v2m_lock);\r\n}\r\nstatic int gicv2m_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\r\nunsigned int nr_irqs, void *args)\r\n{\r\nstruct v2m_data *v2m = NULL, *tmp;\r\nint hwirq, offset, err = 0;\r\nspin_lock(&v2m_lock);\r\nlist_for_each_entry(tmp, &v2m_nodes, entry) {\r\noffset = find_first_zero_bit(tmp->bm, tmp->nr_spis);\r\nif (offset < tmp->nr_spis) {\r\n__set_bit(offset, tmp->bm);\r\nv2m = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&v2m_lock);\r\nif (!v2m)\r\nreturn -ENOSPC;\r\nhwirq = v2m->spi_start + offset;\r\nerr = gicv2m_irq_gic_domain_alloc(domain, virq, hwirq);\r\nif (err) {\r\ngicv2m_unalloc_msi(v2m, hwirq);\r\nreturn err;\r\n}\r\nirq_domain_set_hwirq_and_chip(domain, virq, hwirq,\r\n&gicv2m_irq_chip, v2m);\r\nreturn 0;\r\n}\r\nstatic void gicv2m_irq_domain_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nstruct v2m_data *v2m = irq_data_get_irq_chip_data(d);\r\nBUG_ON(nr_irqs != 1);\r\ngicv2m_unalloc_msi(v2m, d->hwirq);\r\nirq_domain_free_irqs_parent(domain, virq, nr_irqs);\r\n}\r\nstatic bool is_msi_spi_valid(u32 base, u32 num)\r\n{\r\nif (base < V2M_MIN_SPI) {\r\npr_err("Invalid MSI base SPI (base:%u)\n", base);\r\nreturn false;\r\n}\r\nif ((num == 0) || (base + num > V2M_MAX_SPI)) {\r\npr_err("Number of SPIs (%u) exceed maximum (%u)\n",\r\nnum, V2M_MAX_SPI - V2M_MIN_SPI + 1);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void gicv2m_teardown(void)\r\n{\r\nstruct v2m_data *v2m, *tmp;\r\nlist_for_each_entry_safe(v2m, tmp, &v2m_nodes, entry) {\r\nlist_del(&v2m->entry);\r\nkfree(v2m->bm);\r\niounmap(v2m->base);\r\nof_node_put(to_of_node(v2m->fwnode));\r\nif (is_fwnode_irqchip(v2m->fwnode))\r\nirq_domain_free_fwnode(v2m->fwnode);\r\nkfree(v2m);\r\n}\r\n}\r\nstatic int gicv2m_allocate_domains(struct irq_domain *parent)\r\n{\r\nstruct irq_domain *inner_domain, *pci_domain, *plat_domain;\r\nstruct v2m_data *v2m;\r\nv2m = list_first_entry_or_null(&v2m_nodes, struct v2m_data, entry);\r\nif (!v2m)\r\nreturn 0;\r\ninner_domain = irq_domain_create_tree(v2m->fwnode,\r\n&gicv2m_domain_ops, v2m);\r\nif (!inner_domain) {\r\npr_err("Failed to create GICv2m domain\n");\r\nreturn -ENOMEM;\r\n}\r\ninner_domain->bus_token = DOMAIN_BUS_NEXUS;\r\ninner_domain->parent = parent;\r\npci_domain = pci_msi_create_irq_domain(v2m->fwnode,\r\n&gicv2m_msi_domain_info,\r\ninner_domain);\r\nplat_domain = platform_msi_create_irq_domain(v2m->fwnode,\r\n&gicv2m_pmsi_domain_info,\r\ninner_domain);\r\nif (!pci_domain || !plat_domain) {\r\npr_err("Failed to create MSI domains\n");\r\nif (plat_domain)\r\nirq_domain_remove(plat_domain);\r\nif (pci_domain)\r\nirq_domain_remove(pci_domain);\r\nirq_domain_remove(inner_domain);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init gicv2m_init_one(struct fwnode_handle *fwnode,\r\nu32 spi_start, u32 nr_spis,\r\nstruct resource *res)\r\n{\r\nint ret;\r\nstruct v2m_data *v2m;\r\nv2m = kzalloc(sizeof(struct v2m_data), GFP_KERNEL);\r\nif (!v2m) {\r\npr_err("Failed to allocate struct v2m_data.\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&v2m->entry);\r\nv2m->fwnode = fwnode;\r\nmemcpy(&v2m->res, res, sizeof(struct resource));\r\nv2m->base = ioremap(v2m->res.start, resource_size(&v2m->res));\r\nif (!v2m->base) {\r\npr_err("Failed to map GICv2m resource\n");\r\nret = -ENOMEM;\r\ngoto err_free_v2m;\r\n}\r\nif (spi_start && nr_spis) {\r\nv2m->spi_start = spi_start;\r\nv2m->nr_spis = nr_spis;\r\n} else {\r\nu32 typer = readl_relaxed(v2m->base + V2M_MSI_TYPER);\r\nv2m->spi_start = V2M_MSI_TYPER_BASE_SPI(typer);\r\nv2m->nr_spis = V2M_MSI_TYPER_NUM_SPI(typer);\r\n}\r\nif (!is_msi_spi_valid(v2m->spi_start, v2m->nr_spis)) {\r\nret = -EINVAL;\r\ngoto err_iounmap;\r\n}\r\nswitch (readl_relaxed(v2m->base + V2M_MSI_IIDR)) {\r\ncase XGENE_GICV2M_MSI_IIDR:\r\nv2m->flags |= GICV2M_NEEDS_SPI_OFFSET;\r\nv2m->spi_offset = v2m->spi_start;\r\nbreak;\r\ncase BCM_NS2_GICV2M_MSI_IIDR:\r\nv2m->flags |= GICV2M_NEEDS_SPI_OFFSET;\r\nv2m->spi_offset = 32;\r\nbreak;\r\n}\r\nv2m->bm = kzalloc(sizeof(long) * BITS_TO_LONGS(v2m->nr_spis),\r\nGFP_KERNEL);\r\nif (!v2m->bm) {\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\nlist_add_tail(&v2m->entry, &v2m_nodes);\r\npr_info("range%pR, SPI[%d:%d]\n", res,\r\nv2m->spi_start, (v2m->spi_start + v2m->nr_spis - 1));\r\nreturn 0;\r\nerr_iounmap:\r\niounmap(v2m->base);\r\nerr_free_v2m:\r\nkfree(v2m);\r\nreturn ret;\r\n}\r\nstatic int __init gicv2m_of_init(struct fwnode_handle *parent_handle,\r\nstruct irq_domain *parent)\r\n{\r\nint ret = 0;\r\nstruct device_node *node = to_of_node(parent_handle);\r\nstruct device_node *child;\r\nfor (child = of_find_matching_node(node, gicv2m_device_id); child;\r\nchild = of_find_matching_node(child, gicv2m_device_id)) {\r\nu32 spi_start = 0, nr_spis = 0;\r\nstruct resource res;\r\nif (!of_find_property(child, "msi-controller", NULL))\r\ncontinue;\r\nret = of_address_to_resource(child, 0, &res);\r\nif (ret) {\r\npr_err("Failed to allocate v2m resource.\n");\r\nbreak;\r\n}\r\nif (!of_property_read_u32(child, "arm,msi-base-spi",\r\n&spi_start) &&\r\n!of_property_read_u32(child, "arm,msi-num-spis", &nr_spis))\r\npr_info("DT overriding V2M MSI_TYPER (base:%u, num:%u)\n",\r\nspi_start, nr_spis);\r\nret = gicv2m_init_one(&child->fwnode, spi_start, nr_spis, &res);\r\nif (ret) {\r\nof_node_put(child);\r\nbreak;\r\n}\r\n}\r\nif (!ret)\r\nret = gicv2m_allocate_domains(parent);\r\nif (ret)\r\ngicv2m_teardown();\r\nreturn ret;\r\n}\r\nstatic struct fwnode_handle *gicv2m_get_fwnode(struct device *dev)\r\n{\r\nstruct v2m_data *data;\r\nif (WARN_ON(acpi_num_msi <= 0))\r\nreturn NULL;\r\ndata = list_first_entry_or_null(&v2m_nodes, struct v2m_data, entry);\r\nif (!data)\r\nreturn NULL;\r\nreturn data->fwnode;\r\n}\r\nstatic int __init\r\nacpi_parse_madt_msi(struct acpi_subtable_header *header,\r\nconst unsigned long end)\r\n{\r\nint ret;\r\nstruct resource res;\r\nu32 spi_start = 0, nr_spis = 0;\r\nstruct acpi_madt_generic_msi_frame *m;\r\nstruct fwnode_handle *fwnode;\r\nm = (struct acpi_madt_generic_msi_frame *)header;\r\nif (BAD_MADT_ENTRY(m, end))\r\nreturn -EINVAL;\r\nres.start = m->base_address;\r\nres.end = m->base_address + SZ_4K - 1;\r\nres.flags = IORESOURCE_MEM;\r\nif (m->flags & ACPI_MADT_OVERRIDE_SPI_VALUES) {\r\nspi_start = m->spi_base;\r\nnr_spis = m->spi_count;\r\npr_info("ACPI overriding V2M MSI_TYPER (base:%u, num:%u)\n",\r\nspi_start, nr_spis);\r\n}\r\nfwnode = irq_domain_alloc_fwnode((void *)m->base_address);\r\nif (!fwnode) {\r\npr_err("Unable to allocate GICv2m domain token\n");\r\nreturn -EINVAL;\r\n}\r\nret = gicv2m_init_one(fwnode, spi_start, nr_spis, &res);\r\nif (ret)\r\nirq_domain_free_fwnode(fwnode);\r\nreturn ret;\r\n}\r\nstatic int __init gicv2m_acpi_init(struct irq_domain *parent)\r\n{\r\nint ret;\r\nif (acpi_num_msi > 0)\r\nreturn 0;\r\nacpi_num_msi = acpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_MSI_FRAME,\r\nacpi_parse_madt_msi, 0);\r\nif (acpi_num_msi <= 0)\r\ngoto err_out;\r\nret = gicv2m_allocate_domains(parent);\r\nif (ret)\r\ngoto err_out;\r\npci_msi_register_fwnode_provider(&gicv2m_get_fwnode);\r\nreturn 0;\r\nerr_out:\r\ngicv2m_teardown();\r\nreturn -EINVAL;\r\n}\r\nstatic int __init gicv2m_acpi_init(struct irq_domain *parent)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint __init gicv2m_init(struct fwnode_handle *parent_handle,\r\nstruct irq_domain *parent)\r\n{\r\nif (is_of_node(parent_handle))\r\nreturn gicv2m_of_init(parent_handle, parent);\r\nreturn gicv2m_acpi_init(parent);\r\n}
