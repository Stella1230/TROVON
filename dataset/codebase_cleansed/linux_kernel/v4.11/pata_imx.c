static void pata_imx_set_timing(struct ata_device *adev,\r\nstruct pata_imx_priv *priv)\r\n{\r\nstruct ata_timing timing;\r\nunsigned long clkrate;\r\nu32 T, mode;\r\nclkrate = clk_get_rate(priv->clk);\r\nif (adev->pio_mode < XFER_PIO_0 || adev->pio_mode > XFER_PIO_4 ||\r\n!clkrate)\r\nreturn;\r\nT = 1000000000 / clkrate;\r\nata_timing_compute(adev, adev->pio_mode, &timing, T * 1000, 0);\r\nmode = adev->pio_mode - XFER_PIO_0;\r\nwriteb(3, priv->host_regs + PATA_IMX_ATA_TIME_OFF);\r\nwriteb(3, priv->host_regs + PATA_IMX_ATA_TIME_ON);\r\nwriteb(timing.setup, priv->host_regs + PATA_IMX_ATA_TIME_1);\r\nwriteb(timing.act8b, priv->host_regs + PATA_IMX_ATA_TIME_2W);\r\nwriteb(timing.act8b, priv->host_regs + PATA_IMX_ATA_TIME_2R);\r\nwriteb(1, priv->host_regs + PATA_IMX_ATA_TIME_PIO_RDX);\r\nwriteb(pio_t4[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_4);\r\nwriteb(pio_t9[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_9);\r\nwriteb(pio_tA[mode] / T + 1, priv->host_regs + PATA_IMX_ATA_TIME_AX);\r\n}\r\nstatic void pata_imx_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pata_imx_priv *priv = ap->host->private_data;\r\nu32 val;\r\npata_imx_set_timing(adev, priv);\r\nval = __raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\r\nif (ata_pio_need_iordy(adev))\r\nval |= PATA_IMX_ATA_CTRL_IORDY_EN;\r\nelse\r\nval &= ~PATA_IMX_ATA_CTRL_IORDY_EN;\r\n__raw_writel(val, priv->host_regs + PATA_IMX_ATA_CONTROL);\r\n}\r\nstatic void pata_imx_setup_port(struct ata_ioports *ioaddr)\r\n{\r\nioaddr->data_addr = ioaddr->cmd_addr + (ATA_REG_DATA << 2);\r\nioaddr->error_addr = ioaddr->cmd_addr + (ATA_REG_ERR << 2);\r\nioaddr->feature_addr = ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);\r\nioaddr->nsect_addr = ioaddr->cmd_addr + (ATA_REG_NSECT << 2);\r\nioaddr->lbal_addr = ioaddr->cmd_addr + (ATA_REG_LBAL << 2);\r\nioaddr->lbam_addr = ioaddr->cmd_addr + (ATA_REG_LBAM << 2);\r\nioaddr->lbah_addr = ioaddr->cmd_addr + (ATA_REG_LBAH << 2);\r\nioaddr->device_addr = ioaddr->cmd_addr + (ATA_REG_DEVICE << 2);\r\nioaddr->status_addr = ioaddr->cmd_addr + (ATA_REG_STATUS << 2);\r\nioaddr->command_addr = ioaddr->cmd_addr + (ATA_REG_CMD << 2);\r\n}\r\nstatic int pata_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nstruct pata_imx_priv *priv;\r\nint irq = 0;\r\nstruct resource *io_res;\r\nint ret;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof(struct pata_imx_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nhost = ata_host_alloc(&pdev->dev, 1);\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nhost->private_data = priv;\r\nap = host->ports[0];\r\nap->ops = &pata_imx_port_ops;\r\nap->pio_mask = ATA_PIO4;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nio_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->host_regs = devm_ioremap_resource(&pdev->dev, io_res);\r\nif (IS_ERR(priv->host_regs)) {\r\nret = PTR_ERR(priv->host_regs);\r\ngoto err;\r\n}\r\nap->ioaddr.cmd_addr = priv->host_regs + PATA_IMX_DRIVE_DATA;\r\nap->ioaddr.ctl_addr = priv->host_regs + PATA_IMX_DRIVE_CONTROL;\r\nap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;\r\npata_imx_setup_port(&ap->ioaddr);\r\nata_port_desc(ap, "cmd 0x%llx ctl 0x%llx",\r\n(unsigned long long)io_res->start + PATA_IMX_DRIVE_DATA,\r\n(unsigned long long)io_res->start + PATA_IMX_DRIVE_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_CTRL_FIFO_RST_B |\r\nPATA_IMX_ATA_CTRL_ATA_RST_B,\r\npriv->host_regs + PATA_IMX_ATA_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\r\npriv->host_regs + PATA_IMX_ATA_INT_EN);\r\nret = ata_host_activate(host, irq, ata_sff_interrupt, 0,\r\n&pata_imx_sht);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int pata_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nata_host_detach(host);\r\n__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int pata_imx_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nint ret;\r\nret = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (!ret) {\r\n__raw_writel(0, priv->host_regs + PATA_IMX_ATA_INT_EN);\r\npriv->ata_ctl =\r\n__raw_readl(priv->host_regs + PATA_IMX_ATA_CONTROL);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pata_imx_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct pata_imx_priv *priv = host->private_data;\r\nint ret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\n__raw_writel(priv->ata_ctl, priv->host_regs + PATA_IMX_ATA_CONTROL);\r\n__raw_writel(PATA_IMX_ATA_INTR_ATA_INTRQ2,\r\npriv->host_regs + PATA_IMX_ATA_INT_EN);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
