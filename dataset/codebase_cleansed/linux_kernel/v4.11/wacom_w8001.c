static void parse_pen_data(u8 *data, struct w8001_coord *coord)\r\n{\r\nmemset(coord, 0, sizeof(*coord));\r\ncoord->rdy = data[0] & 0x20;\r\ncoord->tsw = data[0] & 0x01;\r\ncoord->f1 = data[0] & 0x02;\r\ncoord->f2 = data[0] & 0x04;\r\ncoord->x = (data[1] & 0x7F) << 9;\r\ncoord->x |= (data[2] & 0x7F) << 2;\r\ncoord->x |= (data[6] & 0x60) >> 5;\r\ncoord->y = (data[3] & 0x7F) << 9;\r\ncoord->y |= (data[4] & 0x7F) << 2;\r\ncoord->y |= (data[6] & 0x18) >> 3;\r\ncoord->pen_pressure = data[5] & 0x7F;\r\ncoord->pen_pressure |= (data[6] & 0x07) << 7 ;\r\ncoord->tilt_x = data[7] & 0x7F;\r\ncoord->tilt_y = data[8] & 0x7F;\r\n}\r\nstatic void parse_single_touch(u8 *data, struct w8001_coord *coord)\r\n{\r\ncoord->x = (data[1] << 7) | data[2];\r\ncoord->y = (data[3] << 7) | data[4];\r\ncoord->tsw = data[0] & 0x01;\r\n}\r\nstatic void scale_touch_coordinates(struct w8001 *w8001,\r\nunsigned int *x, unsigned int *y)\r\n{\r\nif (w8001->max_pen_x && w8001->max_touch_x)\r\n*x = *x * w8001->max_pen_x / w8001->max_touch_x;\r\nif (w8001->max_pen_y && w8001->max_touch_y)\r\n*y = *y * w8001->max_pen_y / w8001->max_touch_y;\r\n}\r\nstatic void parse_multi_touch(struct w8001 *w8001)\r\n{\r\nstruct input_dev *dev = w8001->touch_dev;\r\nunsigned char *data = w8001->data;\r\nunsigned int x, y;\r\nint i;\r\nint count = 0;\r\nfor (i = 0; i < 2; i++) {\r\nbool touch = data[0] & (1 << i);\r\ninput_mt_slot(dev, i);\r\ninput_mt_report_slot_state(dev, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nx = (data[6 * i + 1] << 7) | data[6 * i + 2];\r\ny = (data[6 * i + 3] << 7) | data[6 * i + 4];\r\nscale_touch_coordinates(w8001, &x, &y);\r\ninput_report_abs(dev, ABS_MT_POSITION_X, x);\r\ninput_report_abs(dev, ABS_MT_POSITION_Y, y);\r\ncount++;\r\n}\r\n}\r\nif (w8001->type != BTN_TOOL_PEN &&\r\nw8001->type != BTN_TOOL_RUBBER) {\r\nw8001->type = count == 1 ? BTN_TOOL_FINGER : KEY_RESERVED;\r\ninput_mt_report_pointer_emulation(dev, true);\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic void parse_touchquery(u8 *data, struct w8001_touch_query *query)\r\n{\r\nmemset(query, 0, sizeof(*query));\r\nquery->panel_res = data[1];\r\nquery->sensor_id = data[2] & 0x7;\r\nquery->capacity_res = data[7];\r\nquery->x = data[3] << 9;\r\nquery->x |= data[4] << 2;\r\nquery->x |= (data[2] >> 5) & 0x3;\r\nquery->y = data[5] << 9;\r\nquery->y |= data[6] << 2;\r\nquery->y |= (data[2] >> 3) & 0x3;\r\nif (!query->x && !query->y) {\r\nquery->x = 1024;\r\nquery->y = 1024;\r\nif (query->panel_res)\r\nquery->x = query->y = (1 << query->panel_res);\r\nquery->panel_res = W8001_TOUCH_RESOLUTION;\r\n}\r\n}\r\nstatic void report_pen_events(struct w8001 *w8001, struct w8001_coord *coord)\r\n{\r\nstruct input_dev *dev = w8001->pen_dev;\r\nswitch (w8001->type) {\r\ncase BTN_TOOL_RUBBER:\r\nif (!coord->f2) {\r\ninput_report_abs(dev, ABS_PRESSURE, 0);\r\ninput_report_key(dev, BTN_TOUCH, 0);\r\ninput_report_key(dev, BTN_STYLUS, 0);\r\ninput_report_key(dev, BTN_STYLUS2, 0);\r\ninput_report_key(dev, BTN_TOOL_RUBBER, 0);\r\ninput_sync(dev);\r\nw8001->type = BTN_TOOL_PEN;\r\n}\r\nbreak;\r\ncase BTN_TOOL_FINGER:\r\ncase KEY_RESERVED:\r\nw8001->type = coord->f2 ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nbreak;\r\ndefault:\r\ninput_report_key(dev, BTN_STYLUS2, coord->f2);\r\nbreak;\r\n}\r\ninput_report_abs(dev, ABS_X, coord->x);\r\ninput_report_abs(dev, ABS_Y, coord->y);\r\ninput_report_abs(dev, ABS_PRESSURE, coord->pen_pressure);\r\ninput_report_key(dev, BTN_TOUCH, coord->tsw);\r\ninput_report_key(dev, BTN_STYLUS, coord->f1);\r\ninput_report_key(dev, w8001->type, coord->rdy);\r\ninput_sync(dev);\r\nif (!coord->rdy)\r\nw8001->type = KEY_RESERVED;\r\n}\r\nstatic void report_single_touch(struct w8001 *w8001, struct w8001_coord *coord)\r\n{\r\nstruct input_dev *dev = w8001->touch_dev;\r\nunsigned int x = coord->x;\r\nunsigned int y = coord->y;\r\nscale_touch_coordinates(w8001, &x, &y);\r\ninput_report_abs(dev, ABS_X, x);\r\ninput_report_abs(dev, ABS_Y, y);\r\ninput_report_key(dev, BTN_TOUCH, coord->tsw);\r\ninput_sync(dev);\r\nw8001->type = coord->tsw ? BTN_TOOL_FINGER : KEY_RESERVED;\r\n}\r\nstatic irqreturn_t w8001_interrupt(struct serio *serio,\r\nunsigned char data, unsigned int flags)\r\n{\r\nstruct w8001 *w8001 = serio_get_drvdata(serio);\r\nstruct w8001_coord coord;\r\nunsigned char tmp;\r\nw8001->data[w8001->idx] = data;\r\nswitch (w8001->idx++) {\r\ncase 0:\r\nif ((data & W8001_LEAD_MASK) != W8001_LEAD_BYTE) {\r\npr_debug("w8001: unsynchronized data: 0x%02x\n", data);\r\nw8001->idx = 0;\r\n}\r\nbreak;\r\ncase W8001_PKTLEN_TOUCH93 - 1:\r\ncase W8001_PKTLEN_TOUCH9A - 1:\r\ntmp = w8001->data[0] & W8001_TOUCH_BYTE;\r\nif (tmp != W8001_TOUCH_BYTE)\r\nbreak;\r\nif (w8001->pktlen == w8001->idx) {\r\nw8001->idx = 0;\r\nif (w8001->type != BTN_TOOL_PEN &&\r\nw8001->type != BTN_TOOL_RUBBER) {\r\nparse_single_touch(w8001->data, &coord);\r\nreport_single_touch(w8001, &coord);\r\n}\r\n}\r\nbreak;\r\ncase W8001_PKTLEN_TPCPEN - 1:\r\ntmp = w8001->data[0] & W8001_TAB_MASK;\r\nif (unlikely(tmp == W8001_TAB_BYTE))\r\nbreak;\r\ntmp = w8001->data[0] & W8001_TOUCH_BYTE;\r\nif (tmp == W8001_TOUCH_BYTE)\r\nbreak;\r\nw8001->idx = 0;\r\nparse_pen_data(w8001->data, &coord);\r\nreport_pen_events(w8001, &coord);\r\nbreak;\r\ncase W8001_PKTLEN_TPCCTL - 1:\r\ntmp = w8001->data[0] & W8001_TOUCH_MASK;\r\nif (tmp == W8001_TOUCH_BYTE)\r\nbreak;\r\nw8001->idx = 0;\r\nmemcpy(w8001->response, w8001->data, W8001_MAX_LENGTH);\r\nw8001->response_type = W8001_QUERY_PACKET;\r\ncomplete(&w8001->cmd_done);\r\nbreak;\r\ncase W8001_PKTLEN_TOUCH2FG - 1:\r\nw8001->idx = 0;\r\nparse_multi_touch(w8001);\r\nbreak;\r\ndefault:\r\nif (!w8001->touch_dev && w8001->idx > W8001_PKTLEN_TPCPEN - 1)\r\nw8001->idx = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int w8001_command(struct w8001 *w8001, unsigned char command,\r\nbool wait_response)\r\n{\r\nint rc;\r\nw8001->response_type = 0;\r\ninit_completion(&w8001->cmd_done);\r\nrc = serio_write(w8001->serio, command);\r\nif (rc == 0 && wait_response) {\r\nwait_for_completion_timeout(&w8001->cmd_done, HZ);\r\nif (w8001->response_type != W8001_QUERY_PACKET)\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int w8001_open(struct input_dev *dev)\r\n{\r\nstruct w8001 *w8001 = input_get_drvdata(dev);\r\nint err;\r\nerr = mutex_lock_interruptible(&w8001->mutex);\r\nif (err)\r\nreturn err;\r\nif (w8001->open_count++ == 0) {\r\nerr = w8001_command(w8001, W8001_CMD_START, false);\r\nif (err)\r\nw8001->open_count--;\r\n}\r\nmutex_unlock(&w8001->mutex);\r\nreturn err;\r\n}\r\nstatic void w8001_close(struct input_dev *dev)\r\n{\r\nstruct w8001 *w8001 = input_get_drvdata(dev);\r\nmutex_lock(&w8001->mutex);\r\nif (--w8001->open_count == 0)\r\nw8001_command(w8001, W8001_CMD_STOP, false);\r\nmutex_unlock(&w8001->mutex);\r\n}\r\nstatic int w8001_detect(struct w8001 *w8001)\r\n{\r\nint error;\r\nerror = w8001_command(w8001, W8001_CMD_STOP, false);\r\nif (error)\r\nreturn error;\r\nmsleep(250);\r\nreturn 0;\r\n}\r\nstatic int w8001_setup_pen(struct w8001 *w8001, char *basename,\r\nsize_t basename_sz)\r\n{\r\nstruct input_dev *dev = w8001->pen_dev;\r\nstruct w8001_coord coord;\r\nint error;\r\nerror = w8001_command(w8001, W8001_CMD_QUERY, true);\r\nif (error)\r\nreturn error;\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(EV_ABS, dev->evbit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(BTN_TOOL_PEN, dev->keybit);\r\n__set_bit(BTN_TOOL_RUBBER, dev->keybit);\r\n__set_bit(BTN_STYLUS, dev->keybit);\r\n__set_bit(BTN_STYLUS2, dev->keybit);\r\n__set_bit(INPUT_PROP_DIRECT, dev->propbit);\r\nparse_pen_data(w8001->response, &coord);\r\nw8001->max_pen_x = coord.x;\r\nw8001->max_pen_y = coord.y;\r\ninput_set_abs_params(dev, ABS_X, 0, coord.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, coord.y, 0, 0);\r\ninput_abs_set_res(dev, ABS_X, W8001_PEN_RESOLUTION);\r\ninput_abs_set_res(dev, ABS_Y, W8001_PEN_RESOLUTION);\r\ninput_set_abs_params(dev, ABS_PRESSURE, 0, coord.pen_pressure, 0, 0);\r\nif (coord.tilt_x && coord.tilt_y) {\r\ninput_set_abs_params(dev, ABS_TILT_X, 0, coord.tilt_x, 0, 0);\r\ninput_set_abs_params(dev, ABS_TILT_Y, 0, coord.tilt_y, 0, 0);\r\n}\r\nw8001->id = 0x90;\r\nstrlcat(basename, " Penabled", basename_sz);\r\nreturn 0;\r\n}\r\nstatic int w8001_setup_touch(struct w8001 *w8001, char *basename,\r\nsize_t basename_sz)\r\n{\r\nstruct input_dev *dev = w8001->touch_dev;\r\nstruct w8001_touch_query touch;\r\nint error;\r\nerror = w8001_command(w8001, W8001_CMD_TOUCHQUERY, true);\r\nif (error)\r\nreturn error;\r\nif (!w8001->response[1])\r\nreturn -ENXIO;\r\n__set_bit(EV_KEY, dev->evbit);\r\n__set_bit(EV_ABS, dev->evbit);\r\n__set_bit(BTN_TOUCH, dev->keybit);\r\n__set_bit(INPUT_PROP_DIRECT, dev->propbit);\r\nparse_touchquery(w8001->response, &touch);\r\nw8001->max_touch_x = touch.x;\r\nw8001->max_touch_y = touch.y;\r\nif (w8001->max_pen_x && w8001->max_pen_y) {\r\ntouch.x = w8001->max_pen_x;\r\ntouch.y = w8001->max_pen_y;\r\ntouch.panel_res = W8001_PEN_RESOLUTION;\r\n}\r\ninput_set_abs_params(dev, ABS_X, 0, touch.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_Y, 0, touch.y, 0, 0);\r\ninput_abs_set_res(dev, ABS_X, touch.panel_res);\r\ninput_abs_set_res(dev, ABS_Y, touch.panel_res);\r\nswitch (touch.sensor_id) {\r\ncase 0:\r\ncase 2:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH93;\r\nw8001->id = 0x93;\r\nstrlcat(basename, " 1FG", basename_sz);\r\nbreak;\r\ncase 1:\r\ncase 3:\r\ncase 4:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH9A;\r\nstrlcat(basename, " 1FG", basename_sz);\r\nw8001->id = 0x9a;\r\nbreak;\r\ncase 5:\r\nw8001->pktlen = W8001_PKTLEN_TOUCH2FG;\r\n__set_bit(BTN_TOOL_DOUBLETAP, dev->keybit);\r\nerror = input_mt_init_slots(dev, 2, 0);\r\nif (error) {\r\ndev_err(&w8001->serio->dev,\r\n"failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\ninput_set_abs_params(dev, ABS_MT_POSITION_X,\r\n0, touch.x, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_POSITION_Y,\r\n0, touch.y, 0, 0);\r\ninput_set_abs_params(dev, ABS_MT_TOOL_TYPE,\r\n0, MT_TOOL_MAX, 0, 0);\r\ninput_abs_set_res(dev, ABS_MT_POSITION_X, touch.panel_res);\r\ninput_abs_set_res(dev, ABS_MT_POSITION_Y, touch.panel_res);\r\nstrlcat(basename, " 2FG", basename_sz);\r\nif (w8001->max_pen_x && w8001->max_pen_y)\r\nw8001->id = 0xE3;\r\nelse\r\nw8001->id = 0xE2;\r\nbreak;\r\n}\r\nstrlcat(basename, " Touchscreen", basename_sz);\r\nreturn 0;\r\n}\r\nstatic void w8001_set_devdata(struct input_dev *dev, struct w8001 *w8001,\r\nstruct serio *serio)\r\n{\r\ndev->phys = w8001->phys;\r\ndev->id.bustype = BUS_RS232;\r\ndev->id.product = w8001->id;\r\ndev->id.vendor = 0x056a;\r\ndev->id.version = 0x0100;\r\ndev->open = w8001_open;\r\ndev->close = w8001_close;\r\ndev->dev.parent = &serio->dev;\r\ninput_set_drvdata(dev, w8001);\r\n}\r\nstatic void w8001_disconnect(struct serio *serio)\r\n{\r\nstruct w8001 *w8001 = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nif (w8001->pen_dev)\r\ninput_unregister_device(w8001->pen_dev);\r\nif (w8001->touch_dev)\r\ninput_unregister_device(w8001->touch_dev);\r\nkfree(w8001);\r\nserio_set_drvdata(serio, NULL);\r\n}\r\nstatic int w8001_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct w8001 *w8001;\r\nstruct input_dev *input_dev_pen;\r\nstruct input_dev *input_dev_touch;\r\nchar basename[64];\r\nint err, err_pen, err_touch;\r\nw8001 = kzalloc(sizeof(struct w8001), GFP_KERNEL);\r\ninput_dev_pen = input_allocate_device();\r\ninput_dev_touch = input_allocate_device();\r\nif (!w8001 || !input_dev_pen || !input_dev_touch) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nw8001->serio = serio;\r\nw8001->pen_dev = input_dev_pen;\r\nw8001->touch_dev = input_dev_touch;\r\nmutex_init(&w8001->mutex);\r\ninit_completion(&w8001->cmd_done);\r\nsnprintf(w8001->phys, sizeof(w8001->phys), "%s/input0", serio->phys);\r\nserio_set_drvdata(serio, w8001);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto fail2;\r\nerr = w8001_detect(w8001);\r\nif (err)\r\ngoto fail3;\r\nstrlcpy(basename, "Wacom Serial", sizeof(basename));\r\nerr_pen = w8001_setup_pen(w8001, basename, sizeof(basename));\r\nerr_touch = w8001_setup_touch(w8001, basename, sizeof(basename));\r\nif (err_pen && err_touch) {\r\nerr = -ENXIO;\r\ngoto fail3;\r\n}\r\nif (!err_pen) {\r\nstrlcpy(w8001->pen_name, basename, sizeof(w8001->pen_name));\r\nstrlcat(w8001->pen_name, " Pen", sizeof(w8001->pen_name));\r\ninput_dev_pen->name = w8001->pen_name;\r\nw8001_set_devdata(input_dev_pen, w8001, serio);\r\nerr = input_register_device(w8001->pen_dev);\r\nif (err)\r\ngoto fail3;\r\n} else {\r\ninput_free_device(input_dev_pen);\r\ninput_dev_pen = NULL;\r\nw8001->pen_dev = NULL;\r\n}\r\nif (!err_touch) {\r\nstrlcpy(w8001->touch_name, basename, sizeof(w8001->touch_name));\r\nstrlcat(w8001->touch_name, " Finger",\r\nsizeof(w8001->touch_name));\r\ninput_dev_touch->name = w8001->touch_name;\r\nw8001_set_devdata(input_dev_touch, w8001, serio);\r\nerr = input_register_device(w8001->touch_dev);\r\nif (err)\r\ngoto fail4;\r\n} else {\r\ninput_free_device(input_dev_touch);\r\ninput_dev_touch = NULL;\r\nw8001->touch_dev = NULL;\r\n}\r\nreturn 0;\r\nfail4:\r\nif (w8001->pen_dev)\r\ninput_unregister_device(w8001->pen_dev);\r\nfail3:\r\nserio_close(serio);\r\nfail2:\r\nserio_set_drvdata(serio, NULL);\r\nfail1:\r\ninput_free_device(input_dev_pen);\r\ninput_free_device(input_dev_touch);\r\nkfree(w8001);\r\nreturn err;\r\n}
