void nf_register_queue_handler(struct net *net, const struct nf_queue_handler *qh)\r\n{\r\nWARN_ON(rcu_access_pointer(net->nf.queue_handler));\r\nrcu_assign_pointer(net->nf.queue_handler, qh);\r\n}\r\nvoid nf_unregister_queue_handler(struct net *net)\r\n{\r\nRCU_INIT_POINTER(net->nf.queue_handler, NULL);\r\n}\r\nvoid nf_queue_entry_release_refs(struct nf_queue_entry *entry)\r\n{\r\nstruct nf_hook_state *state = &entry->state;\r\nif (state->in)\r\ndev_put(state->in);\r\nif (state->out)\r\ndev_put(state->out);\r\nif (state->sk)\r\nsock_put(state->sk);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (entry->skb->nf_bridge) {\r\nstruct net_device *physdev;\r\nphysdev = nf_bridge_get_physindev(entry->skb);\r\nif (physdev)\r\ndev_put(physdev);\r\nphysdev = nf_bridge_get_physoutdev(entry->skb);\r\nif (physdev)\r\ndev_put(physdev);\r\n}\r\n#endif\r\n}\r\nvoid nf_queue_entry_get_refs(struct nf_queue_entry *entry)\r\n{\r\nstruct nf_hook_state *state = &entry->state;\r\nif (state->in)\r\ndev_hold(state->in);\r\nif (state->out)\r\ndev_hold(state->out);\r\nif (state->sk)\r\nsock_hold(state->sk);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (entry->skb->nf_bridge) {\r\nstruct net_device *physdev;\r\nphysdev = nf_bridge_get_physindev(entry->skb);\r\nif (physdev)\r\ndev_hold(physdev);\r\nphysdev = nf_bridge_get_physoutdev(entry->skb);\r\nif (physdev)\r\ndev_hold(physdev);\r\n}\r\n#endif\r\n}\r\nvoid nf_queue_nf_hook_drop(struct net *net, const struct nf_hook_entry *entry)\r\n{\r\nconst struct nf_queue_handler *qh;\r\nrcu_read_lock();\r\nqh = rcu_dereference(net->nf.queue_handler);\r\nif (qh)\r\nqh->nf_hook_drop(net, entry);\r\nrcu_read_unlock();\r\n}\r\nstatic int __nf_queue(struct sk_buff *skb, const struct nf_hook_state *state,\r\nstruct nf_hook_entry *hook_entry, unsigned int queuenum)\r\n{\r\nint status = -ENOENT;\r\nstruct nf_queue_entry *entry = NULL;\r\nconst struct nf_afinfo *afinfo;\r\nconst struct nf_queue_handler *qh;\r\nstruct net *net = state->net;\r\nqh = rcu_dereference(net->nf.queue_handler);\r\nif (!qh) {\r\nstatus = -ESRCH;\r\ngoto err;\r\n}\r\nafinfo = nf_get_afinfo(state->pf);\r\nif (!afinfo)\r\ngoto err;\r\nentry = kmalloc(sizeof(*entry) + afinfo->route_key_size, GFP_ATOMIC);\r\nif (!entry) {\r\nstatus = -ENOMEM;\r\ngoto err;\r\n}\r\n*entry = (struct nf_queue_entry) {\r\n.skb = skb,\r\n.state = *state,\r\n.hook = hook_entry,\r\n.size = sizeof(*entry) + afinfo->route_key_size,\r\n};\r\nnf_queue_entry_get_refs(entry);\r\nskb_dst_force(skb);\r\nafinfo->saveroute(skb, entry);\r\nstatus = qh->outfn(entry, queuenum);\r\nif (status < 0) {\r\nnf_queue_entry_release_refs(entry);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nkfree(entry);\r\nreturn status;\r\n}\r\nint nf_queue(struct sk_buff *skb, struct nf_hook_state *state,\r\nstruct nf_hook_entry **entryp, unsigned int verdict)\r\n{\r\nstruct nf_hook_entry *entry = *entryp;\r\nint ret;\r\nret = __nf_queue(skb, state, entry, verdict >> NF_VERDICT_QBITS);\r\nif (ret < 0) {\r\nif (ret == -ESRCH &&\r\n(verdict & NF_VERDICT_FLAG_QUEUE_BYPASS)) {\r\n*entryp = rcu_dereference(entry->next);\r\nreturn 1;\r\n}\r\nkfree_skb(skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int nf_iterate(struct sk_buff *skb,\r\nstruct nf_hook_state *state,\r\nstruct nf_hook_entry **entryp)\r\n{\r\nunsigned int verdict;\r\ndo {\r\nrepeat:\r\nverdict = nf_hook_entry_hookfn((*entryp), skb, state);\r\nif (verdict != NF_ACCEPT) {\r\nif (verdict != NF_REPEAT)\r\nreturn verdict;\r\ngoto repeat;\r\n}\r\n*entryp = rcu_dereference((*entryp)->next);\r\n} while (*entryp);\r\nreturn NF_ACCEPT;\r\n}\r\nvoid nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)\r\n{\r\nstruct nf_hook_entry *hook_entry = entry->hook;\r\nstruct sk_buff *skb = entry->skb;\r\nconst struct nf_afinfo *afinfo;\r\nint err;\r\nnf_queue_entry_release_refs(entry);\r\nif (verdict == NF_REPEAT)\r\nverdict = nf_hook_entry_hookfn(hook_entry, skb, &entry->state);\r\nif (verdict == NF_ACCEPT) {\r\nafinfo = nf_get_afinfo(entry->state.pf);\r\nif (!afinfo || afinfo->reroute(entry->state.net, skb, entry) < 0)\r\nverdict = NF_DROP;\r\n}\r\nif (verdict == NF_ACCEPT) {\r\nhook_entry = rcu_dereference(hook_entry->next);\r\nif (hook_entry)\r\nnext_hook:\r\nverdict = nf_iterate(skb, &entry->state, &hook_entry);\r\n}\r\nswitch (verdict & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_STOP:\r\nokfn:\r\nlocal_bh_disable();\r\nentry->state.okfn(entry->state.net, entry->state.sk, skb);\r\nlocal_bh_enable();\r\nbreak;\r\ncase NF_QUEUE:\r\nerr = nf_queue(skb, &entry->state, &hook_entry, verdict);\r\nif (err == 1) {\r\nif (hook_entry)\r\ngoto next_hook;\r\ngoto okfn;\r\n}\r\nbreak;\r\ncase NF_STOLEN:\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\n}\r\nkfree(entry);\r\n}
