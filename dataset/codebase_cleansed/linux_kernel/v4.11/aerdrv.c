void pci_no_aer(void)\r\n{\r\npcie_aer_disable = 1;\r\n}\r\nbool pci_aer_available(void)\r\n{\r\nreturn !pcie_aer_disable && pci_msi_enabled();\r\n}\r\nstatic int set_device_error_reporting(struct pci_dev *dev, void *data)\r\n{\r\nbool enable = *((bool *)data);\r\nint type = pci_pcie_type(dev);\r\nif ((type == PCI_EXP_TYPE_ROOT_PORT) ||\r\n(type == PCI_EXP_TYPE_UPSTREAM) ||\r\n(type == PCI_EXP_TYPE_DOWNSTREAM)) {\r\nif (enable)\r\npci_enable_pcie_error_reporting(dev);\r\nelse\r\npci_disable_pcie_error_reporting(dev);\r\n}\r\nif (enable)\r\npcie_set_ecrc_checking(dev);\r\nreturn 0;\r\n}\r\nstatic void set_downstream_devices_error_reporting(struct pci_dev *dev,\r\nbool enable)\r\n{\r\nset_device_error_reporting(dev, &enable);\r\nif (!dev->subordinate)\r\nreturn;\r\npci_walk_bus(dev->subordinate, set_device_error_reporting, &enable);\r\n}\r\nstatic void aer_enable_rootport(struct aer_rpc *rpc)\r\n{\r\nstruct pci_dev *pdev = rpc->rpd->port;\r\nint aer_pos;\r\nu16 reg16;\r\nu32 reg32;\r\npcie_capability_read_word(pdev, PCI_EXP_DEVSTA, &reg16);\r\npcie_capability_write_word(pdev, PCI_EXP_DEVSTA, reg16);\r\npcie_capability_clear_word(pdev, PCI_EXP_RTCTL,\r\nSYSTEM_ERROR_INTR_ON_MESG_MASK);\r\naer_pos = pdev->aer_cap;\r\npci_read_config_dword(pdev, aer_pos + PCI_ERR_ROOT_STATUS, &reg32);\r\npci_write_config_dword(pdev, aer_pos + PCI_ERR_ROOT_STATUS, reg32);\r\npci_read_config_dword(pdev, aer_pos + PCI_ERR_COR_STATUS, &reg32);\r\npci_write_config_dword(pdev, aer_pos + PCI_ERR_COR_STATUS, reg32);\r\npci_read_config_dword(pdev, aer_pos + PCI_ERR_UNCOR_STATUS, &reg32);\r\npci_write_config_dword(pdev, aer_pos + PCI_ERR_UNCOR_STATUS, reg32);\r\nset_downstream_devices_error_reporting(pdev, true);\r\npci_read_config_dword(pdev, aer_pos + PCI_ERR_ROOT_COMMAND, &reg32);\r\nreg32 |= ROOT_PORT_INTR_ON_MESG_MASK;\r\npci_write_config_dword(pdev, aer_pos + PCI_ERR_ROOT_COMMAND, reg32);\r\n}\r\nstatic void aer_disable_rootport(struct aer_rpc *rpc)\r\n{\r\nstruct pci_dev *pdev = rpc->rpd->port;\r\nu32 reg32;\r\nint pos;\r\nset_downstream_devices_error_reporting(pdev, false);\r\npos = pdev->aer_cap;\r\npci_read_config_dword(pdev, pos + PCI_ERR_ROOT_COMMAND, &reg32);\r\nreg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;\r\npci_write_config_dword(pdev, pos + PCI_ERR_ROOT_COMMAND, reg32);\r\npci_read_config_dword(pdev, pos + PCI_ERR_ROOT_STATUS, &reg32);\r\npci_write_config_dword(pdev, pos + PCI_ERR_ROOT_STATUS, reg32);\r\n}\r\nirqreturn_t aer_irq(int irq, void *context)\r\n{\r\nunsigned int status, id;\r\nstruct pcie_device *pdev = (struct pcie_device *)context;\r\nstruct aer_rpc *rpc = get_service_data(pdev);\r\nint next_prod_idx;\r\nunsigned long flags;\r\nint pos;\r\npos = pdev->port->aer_cap;\r\nspin_lock_irqsave(&rpc->e_lock, flags);\r\npci_read_config_dword(pdev->port, pos + PCI_ERR_ROOT_STATUS, &status);\r\nif (!(status & (PCI_ERR_ROOT_UNCOR_RCV|PCI_ERR_ROOT_COR_RCV))) {\r\nspin_unlock_irqrestore(&rpc->e_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\npci_read_config_dword(pdev->port, pos + PCI_ERR_ROOT_ERR_SRC, &id);\r\npci_write_config_dword(pdev->port, pos + PCI_ERR_ROOT_STATUS, status);\r\nnext_prod_idx = rpc->prod_idx + 1;\r\nif (next_prod_idx == AER_ERROR_SOURCES_MAX)\r\nnext_prod_idx = 0;\r\nif (next_prod_idx == rpc->cons_idx) {\r\nspin_unlock_irqrestore(&rpc->e_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nrpc->e_sources[rpc->prod_idx].status = status;\r\nrpc->e_sources[rpc->prod_idx].id = id;\r\nrpc->prod_idx = next_prod_idx;\r\nspin_unlock_irqrestore(&rpc->e_lock, flags);\r\nschedule_work(&rpc->dpc_handler);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct aer_rpc *aer_alloc_rpc(struct pcie_device *dev)\r\n{\r\nstruct aer_rpc *rpc;\r\nrpc = kzalloc(sizeof(struct aer_rpc), GFP_KERNEL);\r\nif (!rpc)\r\nreturn NULL;\r\nspin_lock_init(&rpc->e_lock);\r\nrpc->rpd = dev;\r\nINIT_WORK(&rpc->dpc_handler, aer_isr);\r\nmutex_init(&rpc->rpc_mutex);\r\nset_service_data(dev, rpc);\r\nreturn rpc;\r\n}\r\nstatic void aer_remove(struct pcie_device *dev)\r\n{\r\nstruct aer_rpc *rpc = get_service_data(dev);\r\nif (rpc) {\r\nif (rpc->isr)\r\nfree_irq(dev->irq, dev);\r\nflush_work(&rpc->dpc_handler);\r\naer_disable_rootport(rpc);\r\nkfree(rpc);\r\nset_service_data(dev, NULL);\r\n}\r\n}\r\nstatic int aer_probe(struct pcie_device *dev)\r\n{\r\nint status;\r\nstruct aer_rpc *rpc;\r\nstruct device *device = &dev->port->dev;\r\nrpc = aer_alloc_rpc(dev);\r\nif (!rpc) {\r\ndev_printk(KERN_DEBUG, device, "alloc AER rpc failed\n");\r\naer_remove(dev);\r\nreturn -ENOMEM;\r\n}\r\nstatus = request_irq(dev->irq, aer_irq, IRQF_SHARED, "aerdrv", dev);\r\nif (status) {\r\ndev_printk(KERN_DEBUG, device, "request AER IRQ %d failed\n",\r\ndev->irq);\r\naer_remove(dev);\r\nreturn status;\r\n}\r\nrpc->isr = 1;\r\naer_enable_rootport(rpc);\r\ndev_info(device, "AER enabled with IRQ %d\n", dev->irq);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t aer_root_reset(struct pci_dev *dev)\r\n{\r\nu32 reg32;\r\nint pos;\r\npos = dev->aer_cap;\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND, &reg32);\r\nreg32 &= ~ROOT_PORT_INTR_ON_MESG_MASK;\r\npci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND, reg32);\r\npci_reset_bridge_secondary_bus(dev);\r\ndev_printk(KERN_DEBUG, &dev->dev, "Root Port link has been reset\n");\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);\r\npci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, reg32);\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND, &reg32);\r\nreg32 |= ROOT_PORT_INTR_ON_MESG_MASK;\r\npci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND, reg32);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic pci_ers_result_t aer_error_detected(struct pci_dev *dev,\r\nenum pci_channel_state error)\r\n{\r\nreturn PCI_ERS_RESULT_CAN_RECOVER;\r\n}\r\nstatic void aer_error_resume(struct pci_dev *dev)\r\n{\r\nint pos;\r\nu32 status, mask;\r\nu16 reg16;\r\npcie_capability_read_word(dev, PCI_EXP_DEVSTA, &reg16);\r\npcie_capability_write_word(dev, PCI_EXP_DEVSTA, reg16);\r\npos = dev->aer_cap;\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &status);\r\npci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &mask);\r\nif (dev->error_state == pci_channel_io_normal)\r\nstatus &= ~mask;\r\nelse\r\nstatus &= mask;\r\npci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, status);\r\n}\r\nstatic int __init aer_service_init(void)\r\n{\r\nif (!pci_aer_available() || aer_acpi_firmware_first())\r\nreturn -ENXIO;\r\nreturn pcie_port_service_register(&aerdriver);\r\n}
