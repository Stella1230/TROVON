static void ssusb_wakeup_ip_sleep_en(struct ssusb_mtk *ssusb)\r\n{\r\nu32 tmp;\r\nstruct regmap *pericfg = ssusb->pericfg;\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_IS_P;\r\ntmp &= ~(UWK_CTL1_IS_C(0xf));\r\ntmp |= UWK_CTL1_IS_C(0x8);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp | UWK_CTL1_IS_E);\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ndev_dbg(ssusb->dev, "%s(): WK_CTRL1[P6,E25,C26:29]=%#x\n",\r\n__func__, tmp);\r\n}\r\nstatic void ssusb_wakeup_ip_sleep_dis(struct ssusb_mtk *ssusb)\r\n{\r\nu32 tmp;\r\nregmap_read(ssusb->pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_IS_E;\r\nregmap_write(ssusb->pericfg, PERI_WK_CTRL1, tmp);\r\n}\r\nint ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,\r\nstruct device_node *dn)\r\n{\r\nstruct device *dev = ssusb->dev;\r\nssusb->wakeup_en = of_property_read_bool(dn, "mediatek,enable-wakeup");\r\nif (!ssusb->wakeup_en)\r\nreturn 0;\r\nssusb->wk_deb_p0 = devm_clk_get(dev, "wakeup_deb_p0");\r\nif (IS_ERR(ssusb->wk_deb_p0)) {\r\ndev_err(dev, "fail to get wakeup_deb_p0\n");\r\nreturn PTR_ERR(ssusb->wk_deb_p0);\r\n}\r\nif (of_property_read_bool(dn, "wakeup_deb_p1")) {\r\nssusb->wk_deb_p1 = devm_clk_get(dev, "wakeup_deb_p1");\r\nif (IS_ERR(ssusb->wk_deb_p1)) {\r\ndev_err(dev, "fail to get wakeup_deb_p1\n");\r\nreturn PTR_ERR(ssusb->wk_deb_p1);\r\n}\r\n}\r\nssusb->pericfg = syscon_regmap_lookup_by_phandle(dn,\r\n"mediatek,syscon-wakeup");\r\nif (IS_ERR(ssusb->pericfg)) {\r\ndev_err(dev, "fail to get pericfg regs\n");\r\nreturn PTR_ERR(ssusb->pericfg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssusb_wakeup_clks_enable(struct ssusb_mtk *ssusb)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(ssusb->wk_deb_p0);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to enable wk_deb_p0\n");\r\ngoto usb_p0_err;\r\n}\r\nret = clk_prepare_enable(ssusb->wk_deb_p1);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to enable wk_deb_p1\n");\r\ngoto usb_p1_err;\r\n}\r\nreturn 0;\r\nusb_p1_err:\r\nclk_disable_unprepare(ssusb->wk_deb_p0);\r\nusb_p0_err:\r\nreturn -EINVAL;\r\n}\r\nstatic void ssusb_wakeup_clks_disable(struct ssusb_mtk *ssusb)\r\n{\r\nclk_disable_unprepare(ssusb->wk_deb_p1);\r\nclk_disable_unprepare(ssusb->wk_deb_p0);\r\n}\r\nstatic void host_ports_num_get(struct ssusb_mtk *ssusb)\r\n{\r\nu32 xhci_cap;\r\nxhci_cap = mtu3_readl(ssusb->ippc_base, U3D_SSUSB_IP_XHCI_CAP);\r\nssusb->u2_ports = SSUSB_IP_XHCI_U2_PORT_NUM(xhci_cap);\r\nssusb->u3_ports = SSUSB_IP_XHCI_U3_PORT_NUM(xhci_cap);\r\ndev_dbg(ssusb->dev, "host - u2_ports:%d, u3_ports:%d\n",\r\nssusb->u2_ports, ssusb->u3_ports);\r\n}\r\nint ssusb_host_enable(struct ssusb_mtk *ssusb)\r\n{\r\nvoid __iomem *ibase = ssusb->ippc_base;\r\nint num_u3p = ssusb->u3_ports;\r\nint num_u2p = ssusb->u2_ports;\r\nu32 check_clk;\r\nu32 value;\r\nint i;\r\nmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\r\nfor (i = 0; i < num_u3p; i++) {\r\nvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\r\nvalue &= ~(SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS);\r\nvalue |= SSUSB_U3_PORT_HOST_SEL;\r\nmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\r\n}\r\nfor (i = 0; i < num_u2p; i++) {\r\nvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\r\nvalue &= ~(SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS);\r\nvalue |= SSUSB_U2_PORT_HOST_SEL;\r\nmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\r\n}\r\ncheck_clk = SSUSB_XHCI_RST_B_STS;\r\nif (num_u3p)\r\ncheck_clk = SSUSB_U3_MAC_RST_B_STS;\r\nreturn ssusb_check_clocks(ssusb, check_clk);\r\n}\r\nint ssusb_host_disable(struct ssusb_mtk *ssusb, bool suspend)\r\n{\r\nvoid __iomem *ibase = ssusb->ippc_base;\r\nint num_u3p = ssusb->u3_ports;\r\nint num_u2p = ssusb->u2_ports;\r\nu32 value;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < num_u3p; i++) {\r\nvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\r\nvalue |= SSUSB_U3_PORT_PDN;\r\nvalue |= suspend ? 0 : SSUSB_U3_PORT_DIS;\r\nmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\r\n}\r\nfor (i = 0; i < num_u2p; i++) {\r\nvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\r\nvalue |= SSUSB_U2_PORT_PDN;\r\nvalue |= suspend ? 0 : SSUSB_U2_PORT_DIS;\r\nmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\r\n}\r\nmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\r\nif (!suspend)\r\nreturn 0;\r\nret = readl_poll_timeout(ibase + U3D_SSUSB_IP_PW_STS1, value,\r\n(value & SSUSB_IP_SLEEP_STS), 100, 100000);\r\nif (ret)\r\ndev_err(ssusb->dev, "ip sleep failed!!!\n");\r\nreturn ret;\r\n}\r\nstatic void ssusb_host_setup(struct ssusb_mtk *ssusb)\r\n{\r\nhost_ports_num_get(ssusb);\r\nssusb_host_enable(ssusb);\r\nssusb_set_vbus(&ssusb->otg_switch, 1);\r\n}\r\nstatic void ssusb_host_cleanup(struct ssusb_mtk *ssusb)\r\n{\r\nif (ssusb->is_host)\r\nssusb_set_vbus(&ssusb->otg_switch, 0);\r\nssusb_host_disable(ssusb, false);\r\n}\r\nint ssusb_host_init(struct ssusb_mtk *ssusb, struct device_node *parent_dn)\r\n{\r\nstruct device *parent_dev = ssusb->dev;\r\nint ret;\r\nssusb_host_setup(ssusb);\r\nret = of_platform_populate(parent_dn, NULL, NULL, parent_dev);\r\nif (ret) {\r\ndev_dbg(parent_dev, "failed to create child devices at %s\n",\r\nparent_dn->full_name);\r\nreturn ret;\r\n}\r\ndev_info(parent_dev, "xHCI platform device register success...\n");\r\nreturn 0;\r\n}\r\nvoid ssusb_host_exit(struct ssusb_mtk *ssusb)\r\n{\r\nof_platform_depopulate(ssusb->dev);\r\nssusb_host_cleanup(ssusb);\r\n}\r\nint ssusb_wakeup_enable(struct ssusb_mtk *ssusb)\r\n{\r\nint ret = 0;\r\nif (ssusb->wakeup_en) {\r\nret = ssusb_wakeup_clks_enable(ssusb);\r\nssusb_wakeup_ip_sleep_en(ssusb);\r\n}\r\nreturn ret;\r\n}\r\nvoid ssusb_wakeup_disable(struct ssusb_mtk *ssusb)\r\n{\r\nif (ssusb->wakeup_en) {\r\nssusb_wakeup_ip_sleep_dis(ssusb);\r\nssusb_wakeup_clks_disable(ssusb);\r\n}\r\n}
