static void inet_diag_msg_sctpasoc_fill(struct inet_diag_msg *r,\r\nstruct sock *sk,\r\nstruct sctp_association *asoc)\r\n{\r\nunion sctp_addr laddr, paddr;\r\nstruct dst_entry *dst;\r\nstruct timer_list *t3_rtx = &asoc->peer.primary_path->T3_rtx_timer;\r\nladdr = list_entry(asoc->base.bind_addr.address_list.next,\r\nstruct sctp_sockaddr_entry, list)->a;\r\npaddr = asoc->peer.primary_path->ipaddr;\r\ndst = asoc->peer.primary_path->dst;\r\nr->idiag_family = sk->sk_family;\r\nr->id.idiag_sport = htons(asoc->base.bind_addr.port);\r\nr->id.idiag_dport = htons(asoc->peer.port);\r\nr->id.idiag_if = dst ? dst->dev->ifindex : 0;\r\nsock_diag_save_cookie(sk, r->id.idiag_cookie);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == AF_INET6) {\r\n*(struct in6_addr *)r->id.idiag_src = laddr.v6.sin6_addr;\r\n*(struct in6_addr *)r->id.idiag_dst = paddr.v6.sin6_addr;\r\n} else\r\n#endif\r\n{\r\nmemset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));\r\nmemset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));\r\nr->id.idiag_src[0] = laddr.v4.sin_addr.s_addr;\r\nr->id.idiag_dst[0] = paddr.v4.sin_addr.s_addr;\r\n}\r\nr->idiag_state = asoc->state;\r\nif (timer_pending(t3_rtx)) {\r\nr->idiag_timer = SCTP_EVENT_TIMEOUT_T3_RTX;\r\nr->idiag_retrans = asoc->rtx_data_chunks;\r\nr->idiag_expires = jiffies_to_msecs(t3_rtx->expires - jiffies);\r\n} else {\r\nr->idiag_timer = 0;\r\nr->idiag_retrans = 0;\r\nr->idiag_expires = 0;\r\n}\r\n}\r\nstatic int inet_diag_msg_sctpladdrs_fill(struct sk_buff *skb,\r\nstruct list_head *address_list)\r\n{\r\nstruct sctp_sockaddr_entry *laddr;\r\nint addrlen = sizeof(struct sockaddr_storage);\r\nint addrcnt = 0;\r\nstruct nlattr *attr;\r\nvoid *info = NULL;\r\nlist_for_each_entry_rcu(laddr, address_list, list)\r\naddrcnt++;\r\nattr = nla_reserve(skb, INET_DIAG_LOCALS, addrlen * addrcnt);\r\nif (!attr)\r\nreturn -EMSGSIZE;\r\ninfo = nla_data(attr);\r\nlist_for_each_entry_rcu(laddr, address_list, list) {\r\nmemcpy(info, &laddr->a, addrlen);\r\ninfo += addrlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int inet_diag_msg_sctpaddrs_fill(struct sk_buff *skb,\r\nstruct sctp_association *asoc)\r\n{\r\nint addrlen = sizeof(struct sockaddr_storage);\r\nstruct sctp_transport *from;\r\nstruct nlattr *attr;\r\nvoid *info = NULL;\r\nattr = nla_reserve(skb, INET_DIAG_PEERS,\r\naddrlen * asoc->peer.transport_count);\r\nif (!attr)\r\nreturn -EMSGSIZE;\r\ninfo = nla_data(attr);\r\nlist_for_each_entry(from, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nmemcpy(info, &from->ipaddr, addrlen);\r\ninfo += addrlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int inet_sctp_diag_fill(struct sock *sk, struct sctp_association *asoc,\r\nstruct sk_buff *skb,\r\nconst struct inet_diag_req_v2 *req,\r\nstruct user_namespace *user_ns,\r\nint portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh,\r\nbool net_admin)\r\n{\r\nstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\r\nstruct list_head *addr_list;\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nint ext = req->idiag_ext;\r\nstruct sctp_infox infox;\r\nvoid *info = NULL;\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nBUG_ON(!sk_fullsock(sk));\r\nif (asoc) {\r\ninet_diag_msg_sctpasoc_fill(r, sk, asoc);\r\n} else {\r\ninet_diag_msg_common_fill(r, sk);\r\nr->idiag_state = sk->sk_state;\r\nr->idiag_timer = 0;\r\nr->idiag_retrans = 0;\r\n}\r\nif (inet_diag_msg_attrs_fill(sk, skb, r, ext, user_ns, net_admin))\r\ngoto errout;\r\nif (ext & (1 << (INET_DIAG_SKMEMINFO - 1))) {\r\nu32 mem[SK_MEMINFO_VARS];\r\nint amt;\r\nif (asoc && asoc->ep->sndbuf_policy)\r\namt = asoc->sndbuf_used;\r\nelse\r\namt = sk_wmem_alloc_get(sk);\r\nmem[SK_MEMINFO_WMEM_ALLOC] = amt;\r\nif (asoc && asoc->ep->rcvbuf_policy)\r\namt = atomic_read(&asoc->rmem_alloc);\r\nelse\r\namt = sk_rmem_alloc_get(sk);\r\nmem[SK_MEMINFO_RMEM_ALLOC] = amt;\r\nmem[SK_MEMINFO_RCVBUF] = sk->sk_rcvbuf;\r\nmem[SK_MEMINFO_SNDBUF] = sk->sk_sndbuf;\r\nmem[SK_MEMINFO_FWD_ALLOC] = sk->sk_forward_alloc;\r\nmem[SK_MEMINFO_WMEM_QUEUED] = sk->sk_wmem_queued;\r\nmem[SK_MEMINFO_OPTMEM] = atomic_read(&sk->sk_omem_alloc);\r\nmem[SK_MEMINFO_BACKLOG] = sk->sk_backlog.len;\r\nmem[SK_MEMINFO_DROPS] = atomic_read(&sk->sk_drops);\r\nif (nla_put(skb, INET_DIAG_SKMEMINFO, sizeof(mem), &mem) < 0)\r\ngoto errout;\r\n}\r\nif (ext & (1 << (INET_DIAG_INFO - 1))) {\r\nstruct nlattr *attr;\r\nattr = nla_reserve_64bit(skb, INET_DIAG_INFO,\r\nsizeof(struct sctp_info),\r\nINET_DIAG_PAD);\r\nif (!attr)\r\ngoto errout;\r\ninfo = nla_data(attr);\r\n}\r\ninfox.sctpinfo = (struct sctp_info *)info;\r\ninfox.asoc = asoc;\r\nsctp_diag_get_info(sk, r, &infox);\r\naddr_list = asoc ? &asoc->base.bind_addr.address_list\r\n: &ep->base.bind_addr.address_list;\r\nif (inet_diag_msg_sctpladdrs_fill(skb, addr_list))\r\ngoto errout;\r\nif (asoc && (ext & (1 << (INET_DIAG_CONG - 1))))\r\nif (nla_put_string(skb, INET_DIAG_CONG, "reno") < 0)\r\ngoto errout;\r\nif (asoc && inet_diag_msg_sctpaddrs_fill(skb, asoc))\r\ngoto errout;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic size_t inet_assoc_attr_size(struct sctp_association *asoc)\r\n{\r\nint addrlen = sizeof(struct sockaddr_storage);\r\nint addrcnt = 0;\r\nstruct sctp_sockaddr_entry *laddr;\r\nlist_for_each_entry_rcu(laddr, &asoc->base.bind_addr.address_list,\r\nlist)\r\naddrcnt++;\r\nreturn nla_total_size(sizeof(struct sctp_info))\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(4)\r\n+ nla_total_size(addrlen * asoc->peer.transport_count)\r\n+ nla_total_size(addrlen * addrcnt)\r\n+ nla_total_size(sizeof(struct inet_diag_meminfo))\r\n+ nla_total_size(sizeof(struct inet_diag_msg))\r\n+ 64;\r\n}\r\nstatic int sctp_tsp_dump_one(struct sctp_transport *tsp, void *p)\r\n{\r\nstruct sctp_association *assoc = tsp->asoc;\r\nstruct sock *sk = tsp->asoc->base.sk;\r\nstruct sctp_comm_param *commp = p;\r\nstruct sk_buff *in_skb = commp->skb;\r\nconst struct inet_diag_req_v2 *req = commp->r;\r\nconst struct nlmsghdr *nlh = commp->nlh;\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct sk_buff *rep;\r\nint err;\r\nerr = sock_diag_check_cookie(sk, req->id.idiag_cookie);\r\nif (err)\r\ngoto out;\r\nerr = -ENOMEM;\r\nrep = nlmsg_new(inet_assoc_attr_size(assoc), GFP_KERNEL);\r\nif (!rep)\r\ngoto out;\r\nlock_sock(sk);\r\nif (sk != assoc->base.sk) {\r\nrelease_sock(sk);\r\nsk = assoc->base.sk;\r\nlock_sock(sk);\r\n}\r\nerr = inet_sctp_diag_fill(sk, assoc, rep, req,\r\nsk_user_ns(NETLINK_CB(in_skb).sk),\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, 0, nlh,\r\ncommp->net_admin);\r\nrelease_sock(sk);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(rep);\r\ngoto out;\r\n}\r\nerr = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,\r\nMSG_DONTWAIT);\r\nif (err > 0)\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int sctp_sock_dump(struct sock *sk, void *p)\r\n{\r\nstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\r\nstruct sctp_comm_param *commp = p;\r\nstruct sk_buff *skb = commp->skb;\r\nstruct netlink_callback *cb = commp->cb;\r\nconst struct inet_diag_req_v2 *r = commp->r;\r\nstruct sctp_association *assoc;\r\nint err = 0;\r\nlock_sock(sk);\r\nlist_for_each_entry(assoc, &ep->asocs, asocs) {\r\nif (cb->args[4] < cb->args[1])\r\ngoto next;\r\nif (r->id.idiag_sport != htons(assoc->base.bind_addr.port) &&\r\nr->id.idiag_sport)\r\ngoto next;\r\nif (r->id.idiag_dport != htons(assoc->peer.port) &&\r\nr->id.idiag_dport)\r\ngoto next;\r\nif (!cb->args[3] &&\r\ninet_sctp_diag_fill(sk, NULL, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI, cb->nlh,\r\ncommp->net_admin) < 0) {\r\ncb->args[3] = 1;\r\nerr = 1;\r\ngoto release;\r\n}\r\ncb->args[3] = 1;\r\nif (inet_sctp_diag_fill(sk, assoc, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, 0, cb->nlh,\r\ncommp->net_admin) < 0) {\r\nerr = 1;\r\ngoto release;\r\n}\r\nnext:\r\ncb->args[4]++;\r\n}\r\ncb->args[1] = 0;\r\ncb->args[2]++;\r\ncb->args[3] = 0;\r\ncb->args[4] = 0;\r\nrelease:\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int sctp_get_sock(struct sctp_transport *tsp, void *p)\r\n{\r\nstruct sctp_endpoint *ep = tsp->asoc->ep;\r\nstruct sctp_comm_param *commp = p;\r\nstruct sock *sk = ep->base.sk;\r\nstruct netlink_callback *cb = commp->cb;\r\nconst struct inet_diag_req_v2 *r = commp->r;\r\nstruct sctp_association *assoc =\r\nlist_entry(ep->asocs.next, struct sctp_association, asocs);\r\nif (tsp->asoc != assoc)\r\ngoto out;\r\nif (r->sdiag_family != AF_UNSPEC && sk->sk_family != r->sdiag_family)\r\ngoto out;\r\nsock_hold(sk);\r\ncb->args[5] = (long)sk;\r\nreturn 1;\r\nout:\r\ncb->args[2]++;\r\nreturn 0;\r\n}\r\nstatic int sctp_ep_dump(struct sctp_endpoint *ep, void *p)\r\n{\r\nstruct sctp_comm_param *commp = p;\r\nstruct sock *sk = ep->base.sk;\r\nstruct sk_buff *skb = commp->skb;\r\nstruct netlink_callback *cb = commp->cb;\r\nconst struct inet_diag_req_v2 *r = commp->r;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct inet_sock *inet = inet_sk(sk);\r\nint err = 0;\r\nif (!net_eq(sock_net(sk), net))\r\ngoto out;\r\nif (cb->args[4] < cb->args[1])\r\ngoto next;\r\nif (!(r->idiag_states & TCPF_LISTEN) && !list_empty(&ep->asocs))\r\ngoto next;\r\nif (r->sdiag_family != AF_UNSPEC &&\r\nsk->sk_family != r->sdiag_family)\r\ngoto next;\r\nif (r->id.idiag_sport != inet->inet_sport &&\r\nr->id.idiag_sport)\r\ngoto next;\r\nif (r->id.idiag_dport != inet->inet_dport &&\r\nr->id.idiag_dport)\r\ngoto next;\r\nif (inet_sctp_diag_fill(sk, NULL, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\ncb->nlh, commp->net_admin) < 0) {\r\nerr = 2;\r\ngoto out;\r\n}\r\nnext:\r\ncb->args[4]++;\r\nout:\r\nreturn err;\r\n}\r\nstatic void sctp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\r\nvoid *info)\r\n{\r\nstruct sctp_infox *infox = (struct sctp_infox *)info;\r\nif (infox->asoc) {\r\nr->idiag_rqueue = atomic_read(&infox->asoc->rmem_alloc);\r\nr->idiag_wqueue = infox->asoc->sndbuf_used;\r\n} else {\r\nr->idiag_rqueue = sk->sk_ack_backlog;\r\nr->idiag_wqueue = sk->sk_max_ack_backlog;\r\n}\r\nif (infox->sctpinfo)\r\nsctp_get_sctp_info(sk, infox->asoc, infox->sctpinfo);\r\n}\r\nstatic int sctp_diag_dump_one(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct inet_diag_req_v2 *req)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nunion sctp_addr laddr, paddr;\r\nstruct sctp_comm_param commp = {\r\n.skb = in_skb,\r\n.r = req,\r\n.nlh = nlh,\r\n.net_admin = netlink_net_capable(in_skb, CAP_NET_ADMIN),\r\n};\r\nif (req->sdiag_family == AF_INET) {\r\nladdr.v4.sin_port = req->id.idiag_sport;\r\nladdr.v4.sin_addr.s_addr = req->id.idiag_src[0];\r\nladdr.v4.sin_family = AF_INET;\r\npaddr.v4.sin_port = req->id.idiag_dport;\r\npaddr.v4.sin_addr.s_addr = req->id.idiag_dst[0];\r\npaddr.v4.sin_family = AF_INET;\r\n} else {\r\nladdr.v6.sin6_port = req->id.idiag_sport;\r\nmemcpy(&laddr.v6.sin6_addr, req->id.idiag_src,\r\nsizeof(laddr.v6.sin6_addr));\r\nladdr.v6.sin6_family = AF_INET6;\r\npaddr.v6.sin6_port = req->id.idiag_dport;\r\nmemcpy(&paddr.v6.sin6_addr, req->id.idiag_dst,\r\nsizeof(paddr.v6.sin6_addr));\r\npaddr.v6.sin6_family = AF_INET6;\r\n}\r\nreturn sctp_transport_lookup_process(sctp_tsp_dump_one,\r\nnet, &laddr, &paddr, &commp);\r\n}\r\nstatic void sctp_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r, struct nlattr *bc)\r\n{\r\nu32 idiag_states = r->idiag_states;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct sctp_comm_param commp = {\r\n.skb = skb,\r\n.cb = cb,\r\n.r = r,\r\n.net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN),\r\n};\r\nif (cb->args[0] == 0) {\r\nif (!(idiag_states & TCPF_LISTEN))\r\ngoto skip;\r\nif (sctp_for_each_endpoint(sctp_ep_dump, &commp))\r\ngoto done;\r\nskip:\r\ncb->args[0] = 1;\r\ncb->args[1] = 0;\r\ncb->args[4] = 0;\r\n}\r\nif (!(idiag_states & ~(TCPF_LISTEN | TCPF_CLOSE)))\r\ngoto done;\r\nnext:\r\ncb->args[5] = 0;\r\nsctp_for_each_transport(sctp_get_sock, net, cb->args[2], &commp);\r\nif (cb->args[5] && !sctp_sock_dump((struct sock *)cb->args[5], &commp))\r\ngoto next;\r\ndone:\r\ncb->args[1] = cb->args[4];\r\ncb->args[4] = 0;\r\n}\r\nstatic int __init sctp_diag_init(void)\r\n{\r\nreturn inet_diag_register(&sctp_diag_handler);\r\n}\r\nstatic void __exit sctp_diag_exit(void)\r\n{\r\ninet_diag_unregister(&sctp_diag_handler);\r\n}
