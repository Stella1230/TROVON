static void dht11_edges_print(struct dht11 *dht11)\r\n{\r\nint i;\r\ndev_dbg(dht11->dev, "%d edges detected:\n", dht11->num_edges);\r\nfor (i = 1; i < dht11->num_edges; ++i) {\r\ndev_dbg(dht11->dev, "%d: %lld ns %s\n", i,\r\ndht11->edges[i].ts - dht11->edges[i - 1].ts,\r\ndht11->edges[i - 1].value ? "high" : "low");\r\n}\r\n}\r\nstatic unsigned char dht11_decode_byte(char *bits)\r\n{\r\nunsigned char ret = 0;\r\nint i;\r\nfor (i = 0; i < 8; ++i) {\r\nret <<= 1;\r\nif (bits[i])\r\n++ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dht11_decode(struct dht11 *dht11, int offset)\r\n{\r\nint i, t;\r\nchar bits[DHT11_BITS_PER_READ];\r\nunsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;\r\nfor (i = 0; i < DHT11_BITS_PER_READ; ++i) {\r\nt = dht11->edges[offset + 2 * i + 2].ts -\r\ndht11->edges[offset + 2 * i + 1].ts;\r\nif (!dht11->edges[offset + 2 * i + 1].value) {\r\ndev_dbg(dht11->dev,\r\n"lost synchronisation at edge %d\n",\r\noffset + 2 * i + 1);\r\nreturn -EIO;\r\n}\r\nbits[i] = t > DHT11_THRESHOLD;\r\n}\r\nhum_int = dht11_decode_byte(bits);\r\nhum_dec = dht11_decode_byte(&bits[8]);\r\ntemp_int = dht11_decode_byte(&bits[16]);\r\ntemp_dec = dht11_decode_byte(&bits[24]);\r\nchecksum = dht11_decode_byte(&bits[32]);\r\nif (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum) {\r\ndev_dbg(dht11->dev, "invalid checksum\n");\r\nreturn -EIO;\r\n}\r\ndht11->timestamp = ktime_get_boot_ns();\r\nif (hum_int < 20) {\r\ndht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *\r\n((temp_int & 0x80) ? -100 : 100);\r\ndht11->humidity = ((hum_int << 8) + hum_dec) * 100;\r\n} else if (temp_dec == 0 && hum_dec == 0) {\r\ndht11->temperature = temp_int * 1000;\r\ndht11->humidity = hum_int * 1000;\r\n} else {\r\ndev_err(dht11->dev,\r\n"Don't know how to decode data: %d %d %d %d\n",\r\nhum_int, hum_dec, temp_int, temp_dec);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dht11_handle_irq(int irq, void *data)\r\n{\r\nstruct iio_dev *iio = data;\r\nstruct dht11 *dht11 = iio_priv(iio);\r\nif (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {\r\ndht11->edges[dht11->num_edges].ts = ktime_get_boot_ns();\r\ndht11->edges[dht11->num_edges++].value =\r\ngpio_get_value(dht11->gpio);\r\nif (dht11->num_edges >= DHT11_EDGES_PER_READ)\r\ncomplete(&dht11->completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dht11_read_raw(struct iio_dev *iio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint *val, int *val2, long m)\r\n{\r\nstruct dht11 *dht11 = iio_priv(iio_dev);\r\nint ret, timeres, offset;\r\nmutex_lock(&dht11->lock);\r\nif (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boot_ns()) {\r\ntimeres = ktime_get_resolution_ns();\r\ndev_dbg(dht11->dev, "current timeresolution: %dns\n", timeres);\r\nif (timeres > DHT11_MIN_TIMERES) {\r\ndev_err(dht11->dev, "timeresolution %dns too low\n",\r\ntimeres);\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nif (timeres > DHT11_AMBIG_LOW && timeres < DHT11_AMBIG_HIGH)\r\ndev_warn(dht11->dev,\r\n"timeresolution: %dns - decoding ambiguous\n",\r\ntimeres);\r\nreinit_completion(&dht11->completion);\r\ndht11->num_edges = 0;\r\nret = gpio_direction_output(dht11->gpio, 0);\r\nif (ret)\r\ngoto err;\r\nusleep_range(DHT11_START_TRANSMISSION_MIN,\r\nDHT11_START_TRANSMISSION_MAX);\r\nret = gpio_direction_input(dht11->gpio);\r\nif (ret)\r\ngoto err;\r\nret = request_irq(dht11->irq, dht11_handle_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\niio_dev->name, iio_dev);\r\nif (ret)\r\ngoto err;\r\nret = wait_for_completion_killable_timeout(&dht11->completion,\r\nHZ);\r\nfree_irq(dht11->irq, iio_dev);\r\n#ifdef CONFIG_DYNAMIC_DEBUG\r\ndht11_edges_print(dht11);\r\n#endif\r\nif (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {\r\ndev_err(dht11->dev, "Only %d signal edges detected\n",\r\ndht11->num_edges);\r\nret = -ETIMEDOUT;\r\n}\r\nif (ret < 0)\r\ngoto err;\r\noffset = DHT11_EDGES_PREAMBLE +\r\ndht11->num_edges - DHT11_EDGES_PER_READ;\r\nfor (; offset >= 0; --offset) {\r\nret = dht11_decode(dht11, offset);\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret)\r\ngoto err;\r\n}\r\nret = IIO_VAL_INT;\r\nif (chan->type == IIO_TEMP)\r\n*val = dht11->temperature;\r\nelse if (chan->type == IIO_HUMIDITYRELATIVE)\r\n*val = dht11->humidity;\r\nelse\r\nret = -EINVAL;\r\nerr:\r\ndht11->num_edges = -1;\r\nmutex_unlock(&dht11->lock);\r\nreturn ret;\r\n}\r\nstatic int dht11_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct dht11 *dht11;\r\nstruct iio_dev *iio;\r\nint ret;\r\niio = devm_iio_device_alloc(dev, sizeof(*dht11));\r\nif (!iio) {\r\ndev_err(dev, "Failed to allocate IIO device\n");\r\nreturn -ENOMEM;\r\n}\r\ndht11 = iio_priv(iio);\r\ndht11->dev = dev;\r\nret = of_get_gpio(node, 0);\r\nif (ret < 0)\r\nreturn ret;\r\ndht11->gpio = ret;\r\nret = devm_gpio_request_one(dev, dht11->gpio, GPIOF_IN, pdev->name);\r\nif (ret)\r\nreturn ret;\r\ndht11->irq = gpio_to_irq(dht11->gpio);\r\nif (dht11->irq < 0) {\r\ndev_err(dev, "GPIO %d has no interrupt\n", dht11->gpio);\r\nreturn -EINVAL;\r\n}\r\ndht11->timestamp = ktime_get_boot_ns() - DHT11_DATA_VALID_TIME - 1;\r\ndht11->num_edges = -1;\r\nplatform_set_drvdata(pdev, iio);\r\ninit_completion(&dht11->completion);\r\nmutex_init(&dht11->lock);\r\niio->name = pdev->name;\r\niio->dev.parent = &pdev->dev;\r\niio->info = &dht11_iio_info;\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->channels = dht11_chan_spec;\r\niio->num_channels = ARRAY_SIZE(dht11_chan_spec);\r\nreturn devm_iio_device_register(dev, iio);\r\n}
