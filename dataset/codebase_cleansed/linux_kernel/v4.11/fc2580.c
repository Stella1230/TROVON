static int fc2580_wr_reg_ff(struct fc2580_dev *dev, u8 reg, u8 val)\r\n{\r\nif (val == 0xff)\r\nreturn 0;\r\nelse\r\nreturn regmap_write(dev->regmap, reg, val);\r\n}\r\nstatic int fc2580_set_params(struct fc2580_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\nunsigned int uitmp, div_ref, div_ref_val, div_n, k, k_cw, div_out;\r\nu64 f_vco;\r\nu8 synth_config;\r\nunsigned long timeout;\r\nif (!dev->active) {\r\ndev_dbg(&client->dev, "tuner is sleeping\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_pll_lut); i++) {\r\nif (dev->f_frequency <= fc2580_pll_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_pll_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n#define DIV_PRE_N 2\r\n#define F_REF dev->clk\r\ndiv_out = fc2580_pll_lut[i].div_out;\r\nf_vco = (u64) dev->f_frequency * div_out;\r\nsynth_config = fc2580_pll_lut[i].band;\r\nif (f_vco < 2600000000ULL)\r\nsynth_config |= 0x06;\r\nelse\r\nsynth_config |= 0x0e;\r\n#define DIV_N_MIN 76\r\nif (f_vco >= div_u64((u64) DIV_PRE_N * DIV_N_MIN * F_REF, 1)) {\r\ndiv_ref = 1;\r\ndiv_ref_val = 0x00;\r\n} else if (f_vco >= div_u64((u64) DIV_PRE_N * DIV_N_MIN * F_REF, 2)) {\r\ndiv_ref = 2;\r\ndiv_ref_val = 0x10;\r\n} else {\r\ndiv_ref = 4;\r\ndiv_ref_val = 0x20;\r\n}\r\nuitmp = DIV_PRE_N * F_REF / div_ref;\r\ndiv_n = div_u64_rem(f_vco, uitmp, &k);\r\nk_cw = div_u64((u64) k * 0x100000, uitmp);\r\ndev_dbg(&client->dev,\r\n"frequency=%u bandwidth=%u f_vco=%llu F_REF=%u div_ref=%u div_n=%u k=%u div_out=%u k_cw=%0x\n",\r\ndev->f_frequency, dev->f_bandwidth, f_vco, F_REF, div_ref,\r\ndiv_n, k, div_out, k_cw);\r\nret = regmap_write(dev->regmap, 0x02, synth_config);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x18, div_ref_val << 0 | k_cw >> 16);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1a, (k_cw >> 8) & 0xff);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1b, (k_cw >> 0) & 0xff);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1c, div_n);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_freq_regs_lut); i++) {\r\nif (dev->f_frequency <= fc2580_freq_regs_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_freq_regs_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = fc2580_wr_reg_ff(dev, 0x25, fc2580_freq_regs_lut[i].r25_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x27, fc2580_freq_regs_lut[i].r27_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x28, fc2580_freq_regs_lut[i].r28_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x29, fc2580_freq_regs_lut[i].r29_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x2b, fc2580_freq_regs_lut[i].r2b_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x2c, fc2580_freq_regs_lut[i].r2c_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x2d, fc2580_freq_regs_lut[i].r2d_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x30, fc2580_freq_regs_lut[i].r30_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x44, fc2580_freq_regs_lut[i].r44_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x50, fc2580_freq_regs_lut[i].r50_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x53, fc2580_freq_regs_lut[i].r53_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x5f, fc2580_freq_regs_lut[i].r5f_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x61, fc2580_freq_regs_lut[i].r61_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x62, fc2580_freq_regs_lut[i].r62_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x63, fc2580_freq_regs_lut[i].r63_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x67, fc2580_freq_regs_lut[i].r67_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x68, fc2580_freq_regs_lut[i].r68_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x69, fc2580_freq_regs_lut[i].r69_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6a, fc2580_freq_regs_lut[i].r6a_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6b, fc2580_freq_regs_lut[i].r6b_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6c, fc2580_freq_regs_lut[i].r6c_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6d, fc2580_freq_regs_lut[i].r6d_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6e, fc2580_freq_regs_lut[i].r6e_val);\r\nif (ret)\r\ngoto err;\r\nret = fc2580_wr_reg_ff(dev, 0x6f, fc2580_freq_regs_lut[i].r6f_val);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_if_filter_lut); i++) {\r\nif (dev->f_bandwidth <= fc2580_if_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(fc2580_if_filter_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x36, fc2580_if_filter_lut[i].r36_val);\r\nif (ret)\r\ngoto err;\r\nuitmp = (unsigned int) 8058000 - (dev->f_bandwidth * 122 / 100 / 2);\r\nuitmp = div64_u64((u64) dev->clk * uitmp, 1000000000000ULL);\r\nret = regmap_write(dev->regmap, 0x37, uitmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x39, fc2580_if_filter_lut[i].r39_val);\r\nif (ret)\r\ngoto err;\r\ntimeout = jiffies + msecs_to_jiffies(30);\r\nfor (uitmp = ~0xc0; !time_after(jiffies, timeout) && uitmp != 0xc0;) {\r\nret = regmap_write(dev->regmap, 0x2e, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0x2f, &uitmp);\r\nif (ret)\r\ngoto err;\r\nuitmp &= 0xc0;\r\nret = regmap_write(dev->regmap, 0x2e, 0x01);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (uitmp != 0xc0)\r\ndev_dbg(&client->dev, "filter did not lock %02x\n", uitmp);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_init(struct fc2580_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i;\r\ndev_dbg(&client->dev, "\n");\r\nfor (i = 0; i < ARRAY_SIZE(fc2580_init_reg_vals); i++) {\r\nret = regmap_write(dev->regmap, fc2580_init_reg_vals[i].reg,\r\nfc2580_init_reg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev->active = true;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_sleep(struct fc2580_dev *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\ndev->active = false;\r\nret = regmap_write(dev->regmap, 0x02, 0x0a);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_dvb_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct fc2580_dev *dev = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndev->f_frequency = c->frequency;\r\ndev->f_bandwidth = c->bandwidth_hz;\r\nreturn fc2580_set_params(dev);\r\n}\r\nstatic int fc2580_dvb_init(struct dvb_frontend *fe)\r\n{\r\nreturn fc2580_init(fe->tuner_priv);\r\n}\r\nstatic int fc2580_dvb_sleep(struct dvb_frontend *fe)\r\n{\r\nreturn fc2580_sleep(fe->tuner_priv);\r\n}\r\nstatic int fc2580_dvb_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic inline struct fc2580_dev *fc2580_subdev_to_dev(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct fc2580_dev, subdev);\r\n}\r\nstatic int fc2580_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "on=%d\n", on);\r\nif (on)\r\nret = fc2580_init(dev);\r\nelse\r\nret = fc2580_sleep(dev);\r\nif (ret)\r\nreturn ret;\r\nreturn fc2580_set_params(dev);\r\n}\r\nstatic int fc2580_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *v)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "index=%d\n", v->index);\r\nstrlcpy(v->name, "FCI FC2580", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands[0].rangelow;\r\nv->rangehigh = bands[0].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int fc2580_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *v)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "index=%d\n", v->index);\r\nreturn 0;\r\n}\r\nstatic int fc2580_g_frequency(struct v4l2_subdev *sd, struct v4l2_frequency *f)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d\n", f->tuner);\r\nf->frequency = dev->f_frequency;\r\nreturn 0;\r\n}\r\nstatic int fc2580_s_frequency(struct v4l2_subdev *sd,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\ndev->f_frequency = clamp_t(unsigned int, f->frequency,\r\nbands[0].rangelow, bands[0].rangehigh);\r\nreturn fc2580_set_params(dev);\r\n}\r\nstatic int fc2580_enum_freq_bands(struct v4l2_subdev *sd,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct fc2580_dev *dev = fc2580_subdev_to_dev(sd);\r\nstruct i2c_client *client = dev->client;\r\ndev_dbg(&client->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->index >= ARRAY_SIZE(bands))\r\nreturn -EINVAL;\r\nband->capability = bands[band->index].capability;\r\nband->rangelow = bands[band->index].rangelow;\r\nband->rangehigh = bands[band->index].rangehigh;\r\nreturn 0;\r\n}\r\nstatic int fc2580_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fc2580_dev *dev = container_of(ctrl->handler, struct fc2580_dev, hdl);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "ctrl: id=%d name=%s cur.val=%d val=%d\n",\r\nctrl->id, ctrl->name, ctrl->cur.val, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\ndev->f_bandwidth = dev->bandwidth->val;\r\nret = fc2580_set_params(dev);\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "unknown ctrl");\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct v4l2_subdev *fc2580_get_v4l2_subdev(struct i2c_client *client)\r\n{\r\nstruct fc2580_dev *dev = i2c_get_clientdata(client);\r\nif (dev->subdev.ops)\r\nreturn &dev->subdev;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int fc2580_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct fc2580_dev *dev;\r\nstruct fc2580_platform_data *pdata = client->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\nint ret;\r\nunsigned int uitmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (pdata->clk)\r\ndev->clk = pdata->clk;\r\nelse\r\ndev->clk = 16384000;\r\ndev->client = client;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0x01, &uitmp);\r\nif (ret)\r\ngoto err_kfree;\r\ndev_dbg(&client->dev, "chip_id=%02x\n", uitmp);\r\nswitch (uitmp) {\r\ncase 0x56:\r\ncase 0x5a:\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err_kfree;\r\n}\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_init(&dev->hdl, 2);\r\ndev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, &fc2580_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\r\n0, 1, 1, 1);\r\ndev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, &fc2580_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH,\r\n3000, 10000000, 1, 3000);\r\nv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\r\nif (dev->hdl.error) {\r\nret = dev->hdl.error;\r\ndev_err(&client->dev, "Could not initialize controls\n");\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\ngoto err_kfree;\r\n}\r\ndev->subdev.ctrl_handler = &dev->hdl;\r\ndev->f_frequency = bands[0].rangelow;\r\ndev->f_bandwidth = dev->bandwidth->val;\r\nv4l2_i2c_subdev_init(&dev->subdev, client, &fc2580_subdev_ops);\r\n#endif\r\nfe->tuner_priv = dev;\r\nmemcpy(&fe->ops.tuner_ops, &fc2580_dvb_tuner_ops,\r\nsizeof(fe->ops.tuner_ops));\r\npdata->get_v4l2_subdev = fc2580_get_v4l2_subdev;\r\ni2c_set_clientdata(client, dev);\r\ndev_info(&client->dev, "FCI FC2580 successfully identified\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fc2580_remove(struct i2c_client *client)\r\n{\r\nstruct fc2580_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\n#endif\r\nkfree(dev);\r\nreturn 0;\r\n}
