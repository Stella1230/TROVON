static void analogix_dp_psr_set(struct drm_encoder *encoder, bool enabled)\r\n{\r\nstruct rockchip_dp_device *dp = to_dp(encoder);\r\nunsigned long flags;\r\nif (!analogix_dp_psr_supported(dp->dev))\r\nreturn;\r\ndev_dbg(dp->dev, "%s PSR...\n", enabled ? "Entry" : "Exit");\r\nspin_lock_irqsave(&dp->psr_lock, flags);\r\nif (enabled)\r\ndp->psr_state = EDP_VSC_PSR_STATE_ACTIVE;\r\nelse\r\ndp->psr_state = ~EDP_VSC_PSR_STATE_ACTIVE;\r\nschedule_work(&dp->psr_work);\r\nspin_unlock_irqrestore(&dp->psr_lock, flags);\r\n}\r\nstatic void analogix_dp_psr_work(struct work_struct *work)\r\n{\r\nstruct rockchip_dp_device *dp =\r\ncontainer_of(work, typeof(*dp), psr_work);\r\nstruct drm_crtc *crtc = dp->encoder.crtc;\r\nint psr_state = dp->psr_state;\r\nint vact_end;\r\nint ret;\r\nunsigned long flags;\r\nif (!crtc)\r\nreturn;\r\nvact_end = crtc->mode.vtotal - crtc->mode.vsync_start + crtc->mode.vdisplay;\r\nret = rockchip_drm_wait_line_flag(dp->encoder.crtc, vact_end,\r\nPSR_WAIT_LINE_FLAG_TIMEOUT_MS);\r\nif (ret) {\r\ndev_err(dp->dev, "line flag interrupt did not arrive\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dp->psr_lock, flags);\r\nif (psr_state == EDP_VSC_PSR_STATE_ACTIVE)\r\nanalogix_dp_enable_psr(dp->dev);\r\nelse\r\nanalogix_dp_disable_psr(dp->dev);\r\nspin_unlock_irqrestore(&dp->psr_lock, flags);\r\n}\r\nstatic int rockchip_dp_pre_init(struct rockchip_dp_device *dp)\r\n{\r\nreset_control_assert(dp->rst);\r\nusleep_range(10, 20);\r\nreset_control_deassert(dp->rst);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_poweron(struct analogix_dp_plat_data *plat_data)\r\n{\r\nstruct rockchip_dp_device *dp = to_dp(plat_data);\r\nint ret;\r\ncancel_work_sync(&dp->psr_work);\r\nret = clk_prepare_enable(dp->pclk);\r\nif (ret < 0) {\r\ndev_err(dp->dev, "failed to enable pclk %d\n", ret);\r\nreturn ret;\r\n}\r\nret = rockchip_dp_pre_init(dp);\r\nif (ret < 0) {\r\ndev_err(dp->dev, "failed to dp pre init %d\n", ret);\r\nclk_disable_unprepare(dp->pclk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_powerdown(struct analogix_dp_plat_data *plat_data)\r\n{\r\nstruct rockchip_dp_device *dp = to_dp(plat_data);\r\nclk_disable_unprepare(dp->pclk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_get_modes(struct analogix_dp_plat_data *plat_data,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_display_info *di = &connector->display_info;\r\nu32 mask = DRM_COLOR_FORMAT_YCRCB444 | DRM_COLOR_FORMAT_YCRCB422;\r\nif ((di->color_formats & mask)) {\r\nDRM_DEBUG_KMS("Swapping display color format from YUV to RGB\n");\r\ndi->color_formats &= ~mask;\r\ndi->color_formats |= DRM_COLOR_FORMAT_RGB444;\r\ndi->bpc = 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool\r\nrockchip_dp_drm_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void rockchip_dp_drm_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted)\r\n{\r\n}\r\nstatic void rockchip_dp_drm_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct rockchip_dp_device *dp = to_dp(encoder);\r\nint ret;\r\nu32 val;\r\nret = drm_of_encoder_active_endpoint_id(dp->dev->of_node, encoder);\r\nif (ret < 0)\r\nreturn;\r\nif (ret)\r\nval = dp->data->lcdsel_lit;\r\nelse\r\nval = dp->data->lcdsel_big;\r\ndev_dbg(dp->dev, "vop %s output to dp\n", (ret) ? "LIT" : "BIG");\r\nret = clk_prepare_enable(dp->grfclk);\r\nif (ret < 0) {\r\ndev_err(dp->dev, "failed to enable grfclk %d\n", ret);\r\nreturn;\r\n}\r\nret = regmap_write(dp->grf, dp->data->lcdsel_grf_reg, val);\r\nif (ret != 0)\r\ndev_err(dp->dev, "Could not write to GRF: %d\n", ret);\r\nclk_disable_unprepare(dp->grfclk);\r\n}\r\nstatic void rockchip_dp_drm_encoder_nop(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic int\r\nrockchip_dp_drm_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\r\nstruct rockchip_dp_device *dp = to_dp(encoder);\r\nint ret;\r\ns->output_mode = ROCKCHIP_OUT_MODE_AAAA;\r\ns->output_type = DRM_MODE_CONNECTOR_eDP;\r\nif (dp->data->chip_type == RK3399_EDP) {\r\nret = drm_of_encoder_active_endpoint_id(dp->dev->of_node,\r\nencoder);\r\nif (ret > 0)\r\ns->output_mode = ROCKCHIP_OUT_MODE_P888;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rockchip_dp_drm_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic int rockchip_dp_init(struct rockchip_dp_device *dp)\r\n{\r\nstruct device *dev = dp->dev;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\ndp->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");\r\nif (IS_ERR(dp->grf)) {\r\ndev_err(dev, "failed to get rockchip,grf property\n");\r\nreturn PTR_ERR(dp->grf);\r\n}\r\ndp->grfclk = devm_clk_get(dev, "grf");\r\nif (PTR_ERR(dp->grfclk) == -ENOENT) {\r\ndp->grfclk = NULL;\r\n} else if (PTR_ERR(dp->grfclk) == -EPROBE_DEFER) {\r\nreturn -EPROBE_DEFER;\r\n} else if (IS_ERR(dp->grfclk)) {\r\ndev_err(dev, "failed to get grf clock\n");\r\nreturn PTR_ERR(dp->grfclk);\r\n}\r\ndp->pclk = devm_clk_get(dev, "pclk");\r\nif (IS_ERR(dp->pclk)) {\r\ndev_err(dev, "failed to get pclk property\n");\r\nreturn PTR_ERR(dp->pclk);\r\n}\r\ndp->rst = devm_reset_control_get(dev, "dp");\r\nif (IS_ERR(dp->rst)) {\r\ndev_err(dev, "failed to get dp reset control\n");\r\nreturn PTR_ERR(dp->rst);\r\n}\r\nret = clk_prepare_enable(dp->pclk);\r\nif (ret < 0) {\r\ndev_err(dp->dev, "failed to enable pclk %d\n", ret);\r\nreturn ret;\r\n}\r\nret = rockchip_dp_pre_init(dp);\r\nif (ret < 0) {\r\ndev_err(dp->dev, "failed to pre init %d\n", ret);\r\nclk_disable_unprepare(dp->pclk);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_drm_create_encoder(struct rockchip_dp_device *dp)\r\n{\r\nstruct drm_encoder *encoder = &dp->encoder;\r\nstruct drm_device *drm_dev = dp->drm_dev;\r\nstruct device *dev = dp->dev;\r\nint ret;\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm_dev,\r\ndev->of_node);\r\nDRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);\r\nret = drm_encoder_init(drm_dev, encoder, &rockchip_dp_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize encoder with drm\n");\r\nreturn ret;\r\n}\r\ndrm_encoder_helper_add(encoder, &rockchip_dp_encoder_helper_funcs);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\r\nconst struct rockchip_dp_chip_data *dp_data;\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\ndev_set_drvdata(dev, NULL);\r\ndp_data = of_device_get_match_data(dev);\r\nif (!dp_data)\r\nreturn -ENODEV;\r\nret = rockchip_dp_init(dp);\r\nif (ret < 0)\r\nreturn ret;\r\ndp->data = dp_data;\r\ndp->drm_dev = drm_dev;\r\nret = rockchip_dp_drm_create_encoder(dp);\r\nif (ret) {\r\nDRM_ERROR("failed to create drm encoder\n");\r\nreturn ret;\r\n}\r\ndp->plat_data.encoder = &dp->encoder;\r\ndp->plat_data.dev_type = dp->data->chip_type;\r\ndp->plat_data.power_on = rockchip_dp_poweron;\r\ndp->plat_data.power_off = rockchip_dp_powerdown;\r\ndp->plat_data.get_modes = rockchip_dp_get_modes;\r\nspin_lock_init(&dp->psr_lock);\r\ndp->psr_state = ~EDP_VSC_PSR_STATE_ACTIVE;\r\nINIT_WORK(&dp->psr_work, analogix_dp_psr_work);\r\nrockchip_drm_psr_register(&dp->encoder, analogix_dp_psr_set);\r\nreturn analogix_dp_bind(dev, dp->drm_dev, &dp->plat_data);\r\n}\r\nstatic void rockchip_dp_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct rockchip_dp_device *dp = dev_get_drvdata(dev);\r\nrockchip_drm_psr_unregister(&dp->encoder);\r\nreturn analogix_dp_unbind(dev, master, data);\r\n}\r\nstatic int rockchip_dp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *panel_node, *port, *endpoint;\r\nstruct drm_panel *panel = NULL;\r\nstruct rockchip_dp_device *dp;\r\nport = of_graph_get_port_by_id(dev->of_node, 1);\r\nif (port) {\r\nendpoint = of_get_child_by_name(port, "endpoint");\r\nof_node_put(port);\r\nif (!endpoint) {\r\ndev_err(dev, "no output endpoint found\n");\r\nreturn -EINVAL;\r\n}\r\npanel_node = of_graph_get_remote_port_parent(endpoint);\r\nof_node_put(endpoint);\r\nif (!panel_node) {\r\ndev_err(dev, "no output node found\n");\r\nreturn -EINVAL;\r\n}\r\npanel = of_drm_find_panel(panel_node);\r\nof_node_put(panel_node);\r\nif (!panel)\r\nreturn -EPROBE_DEFER;\r\n}\r\ndp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);\r\nif (!dp)\r\nreturn -ENOMEM;\r\ndp->dev = dev;\r\ndp->plat_data.panel = panel;\r\nplatform_set_drvdata(pdev, dp);\r\nreturn component_add(dev, &rockchip_dp_component_ops);\r\n}\r\nstatic int rockchip_dp_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &rockchip_dp_component_ops);\r\nreturn 0;\r\n}
