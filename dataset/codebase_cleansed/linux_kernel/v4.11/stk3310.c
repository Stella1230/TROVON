static int stk3310_get_index(const int table[][2], int table_size,\r\nint val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < table_size; i++) {\r\nif (val == table[i][0] && val2 == table[i][1])\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stk3310_read_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nu8 reg;\r\n__be16 buf;\r\nint ret;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nif (info != IIO_EV_INFO_VALUE)\r\nreturn -EINVAL;\r\nif (dir == IIO_EV_DIR_RISING)\r\nreg = STK3310_REG_THDH_PS;\r\nelse if (dir == IIO_EV_DIR_FALLING)\r\nreg = STK3310_REG_THDL_PS;\r\nelse\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = regmap_bulk_read(data->regmap, reg, &buf, 2);\r\nmutex_unlock(&data->lock);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "register read failed\n");\r\nreturn ret;\r\n}\r\n*val = be16_to_cpu(buf);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int stk3310_write_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nu8 reg;\r\n__be16 buf;\r\nint ret;\r\nunsigned int index;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nret = regmap_field_read(data->reg_ps_gain, &index);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val < 0 || val > stk3310_ps_max[index])\r\nreturn -EINVAL;\r\nif (dir == IIO_EV_DIR_RISING)\r\nreg = STK3310_REG_THDH_PS;\r\nelse if (dir == IIO_EV_DIR_FALLING)\r\nreg = STK3310_REG_THDL_PS;\r\nelse\r\nreturn -EINVAL;\r\nbuf = cpu_to_be16(val);\r\nret = regmap_bulk_write(data->regmap, reg, &buf, 2);\r\nif (ret < 0)\r\ndev_err(&client->dev, "failed to set PS threshold!\n");\r\nreturn ret;\r\n}\r\nstatic int stk3310_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nunsigned int event_val;\r\nint ret;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nret = regmap_field_read(data->reg_int_ps, &event_val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn event_val;\r\n}\r\nstatic int stk3310_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nint state)\r\n{\r\nint ret;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nif (state < 0 || state > 7)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = regmap_field_write(data->reg_int_ps, state);\r\nif (ret < 0)\r\ndev_err(&client->dev, "failed to set interrupt mode\n");\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int stk3310_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nu8 reg;\r\n__be16 buf;\r\nint ret;\r\nunsigned int index;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nif (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)\r\nreturn -EINVAL;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_LIGHT)\r\nreg = STK3310_REG_ALS_DATA_MSB;\r\nelse\r\nreg = STK3310_REG_PS_DATA_MSB;\r\nmutex_lock(&data->lock);\r\nret = regmap_bulk_read(data->regmap, reg, &buf, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "register read failed\n");\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\n*val = be16_to_cpu(buf);\r\nmutex_unlock(&data->lock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (chan->type == IIO_LIGHT)\r\nret = regmap_field_read(data->reg_als_it, &index);\r\nelse\r\nret = regmap_field_read(data->reg_ps_it, &index);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = stk3310_it_table[index][0];\r\n*val2 = stk3310_it_table[index][1];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_LIGHT)\r\nret = regmap_field_read(data->reg_als_gain, &index);\r\nelse\r\nret = regmap_field_read(data->reg_ps_gain, &index);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = stk3310_scale_table[index][0];\r\n*val2 = stk3310_scale_table[index][1];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stk3310_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nint ret;\r\nint index;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nif (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)\r\nreturn -EINVAL;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nindex = stk3310_get_index(stk3310_it_table,\r\nARRAY_SIZE(stk3310_it_table),\r\nval, val2);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nif (chan->type == IIO_LIGHT)\r\nret = regmap_field_write(data->reg_als_it, index);\r\nelse\r\nret = regmap_field_write(data->reg_ps_it, index);\r\nif (ret < 0)\r\ndev_err(&data->client->dev,\r\n"sensor configuration failed\n");\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\nindex = stk3310_get_index(stk3310_scale_table,\r\nARRAY_SIZE(stk3310_scale_table),\r\nval, val2);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nif (chan->type == IIO_LIGHT)\r\nret = regmap_field_write(data->reg_als_gain, index);\r\nelse\r\nret = regmap_field_write(data->reg_ps_gain, index);\r\nif (ret < 0)\r\ndev_err(&data->client->dev,\r\n"sensor configuration failed\n");\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int stk3310_set_state(struct stk3310_data *data, u8 state)\r\n{\r\nint ret;\r\nstruct i2c_client *client = data->client;\r\nif (state > 7 || state == 4)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nret = regmap_field_write(data->reg_state, state);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to change sensor state\n");\r\n} else if (state != STK3310_STATE_STANDBY) {\r\ndata->ps_enabled = !!(state & STK3310_STATE_EN_PS);\r\ndata->als_enabled = !!(state & STK3310_STATE_EN_ALS);\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int stk3310_init(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nint chipid;\r\nu8 state;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nret = regmap_read(data->regmap, STK3310_REG_ID, &chipid);\r\nif (ret < 0)\r\nreturn ret;\r\nif (chipid != STK3310_CHIP_ID_VAL &&\r\nchipid != STK3311_CHIP_ID_VAL) {\r\ndev_err(&client->dev, "invalid chip id: 0x%x\n", chipid);\r\nreturn -ENODEV;\r\n}\r\nstate = STK3310_STATE_EN_ALS | STK3310_STATE_EN_PS;\r\nret = stk3310_set_state(data, state);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to enable sensor");\r\nreturn ret;\r\n}\r\nret = regmap_field_write(data->reg_int_ps, STK3310_PSINT_EN);\r\nif (ret < 0)\r\ndev_err(&client->dev, "failed to enable interrupts!\n");\r\nreturn ret;\r\n}\r\nstatic bool stk3310_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase STK3310_REG_ALS_DATA_MSB:\r\ncase STK3310_REG_ALS_DATA_LSB:\r\ncase STK3310_REG_PS_DATA_LSB:\r\ncase STK3310_REG_PS_DATA_MSB:\r\ncase STK3310_REG_FLAG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int stk3310_regmap_init(struct stk3310_data *data)\r\n{\r\nstruct regmap *regmap;\r\nstruct i2c_client *client;\r\nclient = data->client;\r\nregmap = devm_regmap_init_i2c(client, &stk3310_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "regmap initialization failed.\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\ndata->regmap = regmap;\r\nSTK3310_REGFIELD(state);\r\nSTK3310_REGFIELD(als_gain);\r\nSTK3310_REGFIELD(ps_gain);\r\nSTK3310_REGFIELD(als_it);\r\nSTK3310_REGFIELD(ps_it);\r\nSTK3310_REGFIELD(int_ps);\r\nSTK3310_REGFIELD(flag_psint);\r\nSTK3310_REGFIELD(flag_nf);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stk3310_irq_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\ndata->timestamp = iio_get_time_ns(indio_dev);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t stk3310_irq_event_handler(int irq, void *private)\r\n{\r\nint ret;\r\nunsigned int dir;\r\nu64 event;\r\nstruct iio_dev *indio_dev = private;\r\nstruct stk3310_data *data = iio_priv(indio_dev);\r\nmutex_lock(&data->lock);\r\nret = regmap_field_read(data->reg_flag_nf, &dir);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev, "register read failed\n");\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nevent = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1,\r\nIIO_EV_TYPE_THRESH,\r\n(dir ? IIO_EV_DIR_FALLING :\r\nIIO_EV_DIR_RISING));\r\niio_push_event(indio_dev, event, data->timestamp);\r\nret = regmap_field_write(data->reg_flag_psint, 0);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "failed to reset interrupts\n");\r\nmutex_unlock(&data->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stk3310_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct iio_dev *indio_dev;\r\nstruct stk3310_data *data;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev) {\r\ndev_err(&client->dev, "iio allocation failed!\n");\r\nreturn -ENOMEM;\r\n}\r\ndata = iio_priv(indio_dev);\r\ndata->client = client;\r\ni2c_set_clientdata(client, indio_dev);\r\nmutex_init(&data->lock);\r\nret = stk3310_regmap_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = &stk3310_info;\r\nindio_dev->name = STK3310_DRIVER_NAME;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = stk3310_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(stk3310_channels);\r\nret = stk3310_init(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nstk3310_irq_handler,\r\nstk3310_irq_event_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nSTK3310_EVENT, indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "request irq %d failed\n",\r\nclient->irq);\r\ngoto err_standby;\r\n}\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "device_register failed\n");\r\ngoto err_standby;\r\n}\r\nreturn 0;\r\nerr_standby:\r\nstk3310_set_state(data, STK3310_STATE_STANDBY);\r\nreturn ret;\r\n}\r\nstatic int stk3310_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\nreturn stk3310_set_state(iio_priv(indio_dev), STK3310_STATE_STANDBY);\r\n}\r\nstatic int stk3310_suspend(struct device *dev)\r\n{\r\nstruct stk3310_data *data;\r\ndata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\r\nreturn stk3310_set_state(data, STK3310_STATE_STANDBY);\r\n}\r\nstatic int stk3310_resume(struct device *dev)\r\n{\r\nu8 state = 0;\r\nstruct stk3310_data *data;\r\ndata = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));\r\nif (data->ps_enabled)\r\nstate |= STK3310_STATE_EN_PS;\r\nif (data->als_enabled)\r\nstate |= STK3310_STATE_EN_ALS;\r\nreturn stk3310_set_state(data, state);\r\n}
