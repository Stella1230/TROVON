static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI,\r\nstrlen(CHT_CODEC_DAI)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int cht_aif1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_sysclk(codec_dai, M98090_REG_SYSTEM_CLOCK,\r\nCHT_PLAT_CLK_3_HZ, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_ti_jack_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct snd_soc_jack *jack = (struct snd_soc_jack *)data;\r\nstruct snd_soc_dapm_context *dapm = &jack->card->dapm;\r\nif (event & SND_JACK_MICROPHONE) {\r\nsnd_soc_dapm_force_enable_pin(dapm, "SHDN");\r\nsnd_soc_dapm_force_enable_pin(dapm, "MICBIAS");\r\nsnd_soc_dapm_sync(dapm);\r\n} else {\r\nsnd_soc_dapm_disable_pin(dapm, "MICBIAS");\r\nsnd_soc_dapm_disable_pin(dapm, "SHDN");\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_codec_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nint ret;\r\nint jack_type;\r\nstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);\r\nstruct snd_soc_jack *jack = &ctx->jack;\r\nif (ctx->ts3a227e_present)\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE |\r\nSND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3;\r\nelse\r\njack_type = SND_JACK_HEADPHONE | SND_JACK_MICROPHONE;\r\nret = snd_soc_card_jack_new(runtime->card, "Headset Jack",\r\njack_type, jack, NULL, 0);\r\nif (ret) {\r\ndev_err(runtime->dev, "Headset Jack creation failed %d\n", ret);\r\nreturn ret;\r\n}\r\nif (ctx->ts3a227e_present)\r\nsnd_soc_jack_notifier_register(jack, &cht_jack_nb);\r\nreturn ret;\r\n}\r\nstatic int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nint ret = 0;\r\nunsigned int fmt = 0;\r\nret = snd_soc_dai_set_tdm_slot(rtd->cpu_dai, 0x3, 0x3, 2, 16);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set cpu_dai slot fmt: %d\n", ret);\r\nreturn ret;\r\n}\r\nfmt = SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF\r\n| SND_SOC_DAIFMT_CBS_CFS;\r\nret = snd_soc_dai_set_fmt(rtd->cpu_dai, fmt);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set cpu_dai set fmt: %d\n", ret);\r\nreturn ret;\r\n}\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic int cht_max98090_headset_init(struct snd_soc_component *component)\r\n{\r\nstruct snd_soc_card *card = component->card;\r\nstruct cht_mc_private *ctx = snd_soc_card_get_drvdata(card);\r\nreturn ts3a227e_enable_jack_detect(component, &ctx->jack);\r\n}\r\nstatic int snd_cht_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0;\r\nstruct cht_mc_private *drv;\r\ndrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);\r\nif (!drv)\r\nreturn -ENOMEM;\r\ndrv->ts3a227e_present = acpi_dev_found("104C227E");\r\nif (!drv->ts3a227e_present) {\r\nsnd_soc_card_cht.aux_dev = NULL;\r\nsnd_soc_card_cht.num_aux_devs = 0;\r\n}\r\nsnd_soc_card_cht.dev = &pdev->dev;\r\nsnd_soc_card_set_drvdata(&snd_soc_card_cht, drv);\r\nret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cht);\r\nif (ret_val) {\r\ndev_err(&pdev->dev,\r\n"snd_soc_register_card failed %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, &snd_soc_card_cht);\r\nreturn ret_val;\r\n}
