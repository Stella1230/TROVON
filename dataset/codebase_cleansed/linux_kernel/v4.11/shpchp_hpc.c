static inline u8 shpc_readb(struct controller *ctrl, int reg)\r\n{\r\nreturn readb(ctrl->creg + reg);\r\n}\r\nstatic inline void shpc_writeb(struct controller *ctrl, int reg, u8 val)\r\n{\r\nwriteb(val, ctrl->creg + reg);\r\n}\r\nstatic inline u16 shpc_readw(struct controller *ctrl, int reg)\r\n{\r\nreturn readw(ctrl->creg + reg);\r\n}\r\nstatic inline void shpc_writew(struct controller *ctrl, int reg, u16 val)\r\n{\r\nwritew(val, ctrl->creg + reg);\r\n}\r\nstatic inline u32 shpc_readl(struct controller *ctrl, int reg)\r\n{\r\nreturn readl(ctrl->creg + reg);\r\n}\r\nstatic inline void shpc_writel(struct controller *ctrl, int reg, u32 val)\r\n{\r\nwritel(val, ctrl->creg + reg);\r\n}\r\nstatic inline int shpc_indirect_read(struct controller *ctrl, int index,\r\nu32 *value)\r\n{\r\nint rc;\r\nu32 cap_offset = ctrl->cap_offset;\r\nstruct pci_dev *pdev = ctrl->pci_dev;\r\nrc = pci_write_config_byte(pdev, cap_offset + DWORD_SELECT, index);\r\nif (rc)\r\nreturn rc;\r\nreturn pci_read_config_dword(pdev, cap_offset + DWORD_DATA, value);\r\n}\r\nstatic void int_poll_timeout(unsigned long data)\r\n{\r\nstruct controller *ctrl = (struct controller *)data;\r\nshpc_isr(0, ctrl);\r\ninit_timer(&ctrl->poll_timer);\r\nif (!shpchp_poll_time)\r\nshpchp_poll_time = 2;\r\nstart_int_poll_timer(ctrl, shpchp_poll_time);\r\n}\r\nstatic void start_int_poll_timer(struct controller *ctrl, int sec)\r\n{\r\nif ((sec <= 0) || (sec > 60))\r\nsec = 2;\r\nctrl->poll_timer.function = &int_poll_timeout;\r\nctrl->poll_timer.data = (unsigned long)ctrl;\r\nctrl->poll_timer.expires = jiffies + sec * HZ;\r\nadd_timer(&ctrl->poll_timer);\r\n}\r\nstatic inline int is_ctrl_busy(struct controller *ctrl)\r\n{\r\nu16 cmd_status = shpc_readw(ctrl, CMD_STATUS);\r\nreturn cmd_status & 0x1;\r\n}\r\nstatic inline int shpc_poll_ctrl_busy(struct controller *ctrl)\r\n{\r\nint i;\r\nif (!is_ctrl_busy(ctrl))\r\nreturn 1;\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(100);\r\nif (!is_ctrl_busy(ctrl))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int shpc_wait_cmd(struct controller *ctrl)\r\n{\r\nint retval = 0;\r\nunsigned long timeout = msecs_to_jiffies(1000);\r\nint rc;\r\nif (shpchp_poll_mode)\r\nrc = shpc_poll_ctrl_busy(ctrl);\r\nelse\r\nrc = wait_event_interruptible_timeout(ctrl->queue,\r\n!is_ctrl_busy(ctrl), timeout);\r\nif (!rc && is_ctrl_busy(ctrl)) {\r\nretval = -EIO;\r\nctrl_err(ctrl, "Command not completed in 1000 msec\n");\r\n} else if (rc < 0) {\r\nretval = -EINTR;\r\nctrl_info(ctrl, "Command was interrupted by a signal\n");\r\n}\r\nreturn retval;\r\n}\r\nstatic int shpc_write_cmd(struct slot *slot, u8 t_slot, u8 cmd)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 cmd_status;\r\nint retval = 0;\r\nu16 temp_word;\r\nmutex_lock(&slot->ctrl->cmd_lock);\r\nif (!shpc_poll_ctrl_busy(ctrl)) {\r\nctrl_err(ctrl, "Controller is still busy after 1 sec\n");\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\n++t_slot;\r\ntemp_word = (t_slot << 8) | (cmd & 0xFF);\r\nctrl_dbg(ctrl, "%s: t_slot %x cmd %x\n", __func__, t_slot, cmd);\r\nshpc_writew(ctrl, CMD, temp_word);\r\nretval = shpc_wait_cmd(slot->ctrl);\r\nif (retval)\r\ngoto out;\r\ncmd_status = hpc_check_cmd_status(slot->ctrl);\r\nif (cmd_status) {\r\nctrl_err(ctrl, "Failed to issued command 0x%x (error code = %d)\n",\r\ncmd, cmd_status);\r\nretval = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&slot->ctrl->cmd_lock);\r\nreturn retval;\r\n}\r\nstatic int hpc_check_cmd_status(struct controller *ctrl)\r\n{\r\nint retval = 0;\r\nu16 cmd_status = shpc_readw(ctrl, CMD_STATUS) & 0x000F;\r\nswitch (cmd_status >> 1) {\r\ncase 0:\r\nretval = 0;\r\nbreak;\r\ncase 1:\r\nretval = SWITCH_OPEN;\r\nctrl_err(ctrl, "Switch opened!\n");\r\nbreak;\r\ncase 2:\r\nretval = INVALID_CMD;\r\nctrl_err(ctrl, "Invalid HPC command!\n");\r\nbreak;\r\ncase 4:\r\nretval = INVALID_SPEED_MODE;\r\nctrl_err(ctrl, "Invalid bus speed/mode!\n");\r\nbreak;\r\ndefault:\r\nretval = cmd_status;\r\n}\r\nreturn retval;\r\n}\r\nstatic int hpc_get_attention_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\nu8 state = (slot_reg & ATN_LED_STATE_MASK) >> ATN_LED_STATE_SHIFT;\r\nswitch (state) {\r\ncase ATN_LED_STATE_ON:\r\n*status = 1;\r\nbreak;\r\ncase ATN_LED_STATE_BLINK:\r\n*status = 2;\r\nbreak;\r\ncase ATN_LED_STATE_OFF:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hpc_get_power_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\nu8 state = (slot_reg & SLOT_STATE_MASK) >> SLOT_STATE_SHIFT;\r\nswitch (state) {\r\ncase SLOT_STATE_PWRONLY:\r\n*status = 2;\r\nbreak;\r\ncase SLOT_STATE_ENABLED:\r\n*status = 1;\r\nbreak;\r\ncase SLOT_STATE_DISABLED:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hpc_get_latch_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\n*status = !!(slot_reg & MRL_SENSOR);\r\nreturn 0;\r\n}\r\nstatic int hpc_get_adapter_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\nu8 state = (slot_reg & PRSNT_MASK) >> PRSNT_SHIFT;\r\n*status = (state != 0x3) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int hpc_get_prog_int(struct slot *slot, u8 *prog_int)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\n*prog_int = shpc_readb(ctrl, PROG_INTERFACE);\r\nreturn 0;\r\n}\r\nstatic int hpc_get_adapter_speed(struct slot *slot, enum pci_bus_speed *value)\r\n{\r\nint retval = 0;\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\nu8 m66_cap = !!(slot_reg & MHZ66_CAP);\r\nu8 pi, pcix_cap;\r\nretval = hpc_get_prog_int(slot, &pi);\r\nif (retval)\r\nreturn retval;\r\nswitch (pi) {\r\ncase 1:\r\npcix_cap = (slot_reg & PCIX_CAP_MASK_PI1) >> PCIX_CAP_SHIFT;\r\nbreak;\r\ncase 2:\r\npcix_cap = (slot_reg & PCIX_CAP_MASK_PI2) >> PCIX_CAP_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nctrl_dbg(ctrl, "%s: slot_reg = %x, pcix_cap = %x, m66_cap = %x\n",\r\n__func__, slot_reg, pcix_cap, m66_cap);\r\nswitch (pcix_cap) {\r\ncase 0x0:\r\n*value = m66_cap ? PCI_SPEED_66MHz : PCI_SPEED_33MHz;\r\nbreak;\r\ncase 0x1:\r\n*value = PCI_SPEED_66MHz_PCIX;\r\nbreak;\r\ncase 0x3:\r\n*value = PCI_SPEED_133MHz_PCIX;\r\nbreak;\r\ncase 0x4:\r\n*value = PCI_SPEED_133MHz_PCIX_266;\r\nbreak;\r\ncase 0x5:\r\n*value = PCI_SPEED_133MHz_PCIX_533;\r\nbreak;\r\ncase 0x2:\r\ndefault:\r\n*value = PCI_SPEED_UNKNOWN;\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\nctrl_dbg(ctrl, "Adapter speed = %d\n", *value);\r\nreturn retval;\r\n}\r\nstatic int hpc_get_mode1_ECC_cap(struct slot *slot, u8 *mode)\r\n{\r\nint retval = 0;\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 sec_bus_status = shpc_readw(ctrl, SEC_BUS_CONFIG);\r\nu8 pi = shpc_readb(ctrl, PROG_INTERFACE);\r\nif (pi == 2) {\r\n*mode = (sec_bus_status & 0x0100) >> 8;\r\n} else {\r\nretval = -1;\r\n}\r\nctrl_dbg(ctrl, "Mode 1 ECC cap = %d\n", *mode);\r\nreturn retval;\r\n}\r\nstatic int hpc_query_power_fault(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu32 slot_reg = shpc_readl(ctrl, SLOT_REG(slot->hp_slot));\r\nreturn !(slot_reg & POWER_FAULT);\r\n}\r\nstatic int hpc_set_attention_status(struct slot *slot, u8 value)\r\n{\r\nu8 slot_cmd = 0;\r\nswitch (value) {\r\ncase 0:\r\nslot_cmd = SET_ATTN_OFF;\r\nbreak;\r\ncase 1:\r\nslot_cmd = SET_ATTN_ON;\r\nbreak;\r\ncase 2:\r\nslot_cmd = SET_ATTN_BLINK;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn shpc_write_cmd(slot, slot->hp_slot, slot_cmd);\r\n}\r\nstatic void hpc_set_green_led_on(struct slot *slot)\r\n{\r\nshpc_write_cmd(slot, slot->hp_slot, SET_PWR_ON);\r\n}\r\nstatic void hpc_set_green_led_off(struct slot *slot)\r\n{\r\nshpc_write_cmd(slot, slot->hp_slot, SET_PWR_OFF);\r\n}\r\nstatic void hpc_set_green_led_blink(struct slot *slot)\r\n{\r\nshpc_write_cmd(slot, slot->hp_slot, SET_PWR_BLINK);\r\n}\r\nstatic void hpc_release_ctlr(struct controller *ctrl)\r\n{\r\nint i;\r\nu32 slot_reg, serr_int;\r\nfor (i = 0; i < ctrl->num_slots; i++) {\r\nslot_reg = shpc_readl(ctrl, SLOT_REG(i));\r\nslot_reg |= (PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\r\nBUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\r\nCON_PFAULT_INTR_MASK | MRL_CHANGE_SERR_MASK |\r\nCON_PFAULT_SERR_MASK);\r\nslot_reg &= ~SLOT_REG_RSVDZ_MASK;\r\nshpc_writel(ctrl, SLOT_REG(i), slot_reg);\r\n}\r\ncleanup_slots(ctrl);\r\nserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nserr_int |= (GLOBAL_INTR_MASK | GLOBAL_SERR_MASK |\r\nCOMMAND_INTR_MASK | ARBITER_SERR_MASK);\r\nserr_int &= ~SERR_INTR_RSVDZ_MASK;\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\r\nif (shpchp_poll_mode)\r\ndel_timer(&ctrl->poll_timer);\r\nelse {\r\nfree_irq(ctrl->pci_dev->irq, ctrl);\r\npci_disable_msi(ctrl->pci_dev);\r\n}\r\niounmap(ctrl->creg);\r\nrelease_mem_region(ctrl->mmio_base, ctrl->mmio_size);\r\n}\r\nstatic int hpc_power_on_slot(struct slot *slot)\r\n{\r\nint retval;\r\nretval = shpc_write_cmd(slot, slot->hp_slot, SET_SLOT_PWR);\r\nif (retval)\r\nctrl_err(slot->ctrl, "%s: Write command failed!\n", __func__);\r\nreturn retval;\r\n}\r\nstatic int hpc_slot_enable(struct slot *slot)\r\n{\r\nint retval;\r\nretval = shpc_write_cmd(slot, slot->hp_slot,\r\nSET_SLOT_ENABLE | SET_PWR_BLINK | SET_ATTN_OFF);\r\nif (retval)\r\nctrl_err(slot->ctrl, "%s: Write command failed!\n", __func__);\r\nreturn retval;\r\n}\r\nstatic int hpc_slot_disable(struct slot *slot)\r\n{\r\nint retval;\r\nretval = shpc_write_cmd(slot, slot->hp_slot,\r\nSET_SLOT_DISABLE | SET_PWR_OFF | SET_ATTN_ON);\r\nif (retval)\r\nctrl_err(slot->ctrl, "%s: Write command failed!\n", __func__);\r\nreturn retval;\r\n}\r\nstatic int shpc_get_cur_bus_speed(struct controller *ctrl)\r\n{\r\nint retval = 0;\r\nstruct pci_bus *bus = ctrl->pci_dev->subordinate;\r\nenum pci_bus_speed bus_speed = PCI_SPEED_UNKNOWN;\r\nu16 sec_bus_reg = shpc_readw(ctrl, SEC_BUS_CONFIG);\r\nu8 pi = shpc_readb(ctrl, PROG_INTERFACE);\r\nu8 speed_mode = (pi == 2) ? (sec_bus_reg & 0xF) : (sec_bus_reg & 0x7);\r\nif ((pi == 1) && (speed_mode > 4)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (speed_mode) {\r\ncase 0x0:\r\nbus_speed = PCI_SPEED_33MHz;\r\nbreak;\r\ncase 0x1:\r\nbus_speed = PCI_SPEED_66MHz;\r\nbreak;\r\ncase 0x2:\r\nbus_speed = PCI_SPEED_66MHz_PCIX;\r\nbreak;\r\ncase 0x3:\r\nbus_speed = PCI_SPEED_100MHz_PCIX;\r\nbreak;\r\ncase 0x4:\r\nbus_speed = PCI_SPEED_133MHz_PCIX;\r\nbreak;\r\ncase 0x5:\r\nbus_speed = PCI_SPEED_66MHz_PCIX_ECC;\r\nbreak;\r\ncase 0x6:\r\nbus_speed = PCI_SPEED_100MHz_PCIX_ECC;\r\nbreak;\r\ncase 0x7:\r\nbus_speed = PCI_SPEED_133MHz_PCIX_ECC;\r\nbreak;\r\ncase 0x8:\r\nbus_speed = PCI_SPEED_66MHz_PCIX_266;\r\nbreak;\r\ncase 0x9:\r\nbus_speed = PCI_SPEED_100MHz_PCIX_266;\r\nbreak;\r\ncase 0xa:\r\nbus_speed = PCI_SPEED_133MHz_PCIX_266;\r\nbreak;\r\ncase 0xb:\r\nbus_speed = PCI_SPEED_66MHz_PCIX_533;\r\nbreak;\r\ncase 0xc:\r\nbus_speed = PCI_SPEED_100MHz_PCIX_533;\r\nbreak;\r\ncase 0xd:\r\nbus_speed = PCI_SPEED_133MHz_PCIX_533;\r\nbreak;\r\ndefault:\r\nretval = -ENODEV;\r\nbreak;\r\n}\r\nout:\r\nbus->cur_bus_speed = bus_speed;\r\ndbg("Current bus speed = %d\n", bus_speed);\r\nreturn retval;\r\n}\r\nstatic int hpc_set_bus_speed_mode(struct slot *slot, enum pci_bus_speed value)\r\n{\r\nint retval;\r\nstruct controller *ctrl = slot->ctrl;\r\nu8 pi, cmd;\r\npi = shpc_readb(ctrl, PROG_INTERFACE);\r\nif ((pi == 1) && (value > PCI_SPEED_133MHz_PCIX))\r\nreturn -EINVAL;\r\nswitch (value) {\r\ncase PCI_SPEED_33MHz:\r\ncmd = SETA_PCI_33MHZ;\r\nbreak;\r\ncase PCI_SPEED_66MHz:\r\ncmd = SETA_PCI_66MHZ;\r\nbreak;\r\ncase PCI_SPEED_66MHz_PCIX:\r\ncmd = SETA_PCIX_66MHZ;\r\nbreak;\r\ncase PCI_SPEED_100MHz_PCIX:\r\ncmd = SETA_PCIX_100MHZ;\r\nbreak;\r\ncase PCI_SPEED_133MHz_PCIX:\r\ncmd = SETA_PCIX_133MHZ;\r\nbreak;\r\ncase PCI_SPEED_66MHz_PCIX_ECC:\r\ncmd = SETB_PCIX_66MHZ_EM;\r\nbreak;\r\ncase PCI_SPEED_100MHz_PCIX_ECC:\r\ncmd = SETB_PCIX_100MHZ_EM;\r\nbreak;\r\ncase PCI_SPEED_133MHz_PCIX_ECC:\r\ncmd = SETB_PCIX_133MHZ_EM;\r\nbreak;\r\ncase PCI_SPEED_66MHz_PCIX_266:\r\ncmd = SETB_PCIX_66MHZ_266;\r\nbreak;\r\ncase PCI_SPEED_100MHz_PCIX_266:\r\ncmd = SETB_PCIX_100MHZ_266;\r\nbreak;\r\ncase PCI_SPEED_133MHz_PCIX_266:\r\ncmd = SETB_PCIX_133MHZ_266;\r\nbreak;\r\ncase PCI_SPEED_66MHz_PCIX_533:\r\ncmd = SETB_PCIX_66MHZ_533;\r\nbreak;\r\ncase PCI_SPEED_100MHz_PCIX_533:\r\ncmd = SETB_PCIX_100MHZ_533;\r\nbreak;\r\ncase PCI_SPEED_133MHz_PCIX_533:\r\ncmd = SETB_PCIX_133MHZ_533;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nretval = shpc_write_cmd(slot, 0, cmd);\r\nif (retval)\r\nctrl_err(ctrl, "%s: Write command failed!\n", __func__);\r\nelse\r\nshpc_get_cur_bus_speed(ctrl);\r\nreturn retval;\r\n}\r\nstatic irqreturn_t shpc_isr(int irq, void *dev_id)\r\n{\r\nstruct controller *ctrl = (struct controller *)dev_id;\r\nu32 serr_int, slot_reg, intr_loc, intr_loc2;\r\nint hp_slot;\r\nintr_loc = shpc_readl(ctrl, INTR_LOC);\r\nif (!intr_loc)\r\nreturn IRQ_NONE;\r\nctrl_dbg(ctrl, "%s: intr_loc = %x\n", __func__, intr_loc);\r\nif (!shpchp_poll_mode) {\r\nserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nserr_int |= GLOBAL_INTR_MASK;\r\nserr_int &= ~SERR_INTR_RSVDZ_MASK;\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\r\nintr_loc2 = shpc_readl(ctrl, INTR_LOC);\r\nctrl_dbg(ctrl, "%s: intr_loc2 = %x\n", __func__, intr_loc2);\r\n}\r\nif (intr_loc & CMD_INTR_PENDING) {\r\nserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nserr_int &= ~SERR_INTR_RSVDZ_MASK;\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\r\nwake_up_interruptible(&ctrl->queue);\r\n}\r\nif (!(intr_loc & ~CMD_INTR_PENDING))\r\ngoto out;\r\nfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\r\nif (!(intr_loc & SLOT_INTR_PENDING(hp_slot)))\r\ncontinue;\r\nslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\r\nctrl_dbg(ctrl, "Slot %x with intr, slot register = %x\n",\r\nhp_slot, slot_reg);\r\nif (slot_reg & MRL_CHANGE_DETECTED)\r\nshpchp_handle_switch_change(hp_slot, ctrl);\r\nif (slot_reg & BUTTON_PRESS_DETECTED)\r\nshpchp_handle_attention_button(hp_slot, ctrl);\r\nif (slot_reg & PRSNT_CHANGE_DETECTED)\r\nshpchp_handle_presence_change(hp_slot, ctrl);\r\nif (slot_reg & (ISO_PFAULT_DETECTED | CON_PFAULT_DETECTED))\r\nshpchp_handle_power_fault(hp_slot, ctrl);\r\nslot_reg &= ~SLOT_REG_RSVDZ_MASK;\r\nshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\r\n}\r\nout:\r\nif (!shpchp_poll_mode) {\r\nserr_int = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nserr_int &= ~(GLOBAL_INTR_MASK | SERR_INTR_RSVDZ_MASK);\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, serr_int);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int shpc_get_max_bus_speed(struct controller *ctrl)\r\n{\r\nint retval = 0;\r\nstruct pci_bus *bus = ctrl->pci_dev->subordinate;\r\nenum pci_bus_speed bus_speed = PCI_SPEED_UNKNOWN;\r\nu8 pi = shpc_readb(ctrl, PROG_INTERFACE);\r\nu32 slot_avail1 = shpc_readl(ctrl, SLOT_AVAIL1);\r\nu32 slot_avail2 = shpc_readl(ctrl, SLOT_AVAIL2);\r\nif (pi == 2) {\r\nif (slot_avail2 & SLOT_133MHZ_PCIX_533)\r\nbus_speed = PCI_SPEED_133MHz_PCIX_533;\r\nelse if (slot_avail2 & SLOT_100MHZ_PCIX_533)\r\nbus_speed = PCI_SPEED_100MHz_PCIX_533;\r\nelse if (slot_avail2 & SLOT_66MHZ_PCIX_533)\r\nbus_speed = PCI_SPEED_66MHz_PCIX_533;\r\nelse if (slot_avail2 & SLOT_133MHZ_PCIX_266)\r\nbus_speed = PCI_SPEED_133MHz_PCIX_266;\r\nelse if (slot_avail2 & SLOT_100MHZ_PCIX_266)\r\nbus_speed = PCI_SPEED_100MHz_PCIX_266;\r\nelse if (slot_avail2 & SLOT_66MHZ_PCIX_266)\r\nbus_speed = PCI_SPEED_66MHz_PCIX_266;\r\n}\r\nif (bus_speed == PCI_SPEED_UNKNOWN) {\r\nif (slot_avail1 & SLOT_133MHZ_PCIX)\r\nbus_speed = PCI_SPEED_133MHz_PCIX;\r\nelse if (slot_avail1 & SLOT_100MHZ_PCIX)\r\nbus_speed = PCI_SPEED_100MHz_PCIX;\r\nelse if (slot_avail1 & SLOT_66MHZ_PCIX)\r\nbus_speed = PCI_SPEED_66MHz_PCIX;\r\nelse if (slot_avail2 & SLOT_66MHZ)\r\nbus_speed = PCI_SPEED_66MHz;\r\nelse if (slot_avail1 & SLOT_33MHZ)\r\nbus_speed = PCI_SPEED_33MHz;\r\nelse\r\nretval = -ENODEV;\r\n}\r\nbus->max_bus_speed = bus_speed;\r\nctrl_dbg(ctrl, "Max bus speed = %d\n", bus_speed);\r\nreturn retval;\r\n}\r\nint shpc_init(struct controller *ctrl, struct pci_dev *pdev)\r\n{\r\nint rc = -1, num_slots = 0;\r\nu8 hp_slot;\r\nu32 shpc_base_offset;\r\nu32 tempdword, slot_reg, slot_config;\r\nu8 i;\r\nctrl->pci_dev = pdev;\r\nctrl_dbg(ctrl, "Hotplug Controller:\n");\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD &&\r\npdev->device == PCI_DEVICE_ID_AMD_GOLAM_7450) {\r\nctrl->mmio_base = pci_resource_start(pdev, 0);\r\nctrl->mmio_size = pci_resource_len(pdev, 0);\r\n} else {\r\nctrl->cap_offset = pci_find_capability(pdev, PCI_CAP_ID_SHPC);\r\nif (!ctrl->cap_offset) {\r\nctrl_err(ctrl, "Cannot find PCI capability\n");\r\ngoto abort;\r\n}\r\nctrl_dbg(ctrl, " cap_offset = %x\n", ctrl->cap_offset);\r\nrc = shpc_indirect_read(ctrl, 0, &shpc_base_offset);\r\nif (rc) {\r\nctrl_err(ctrl, "Cannot read base_offset\n");\r\ngoto abort;\r\n}\r\nrc = shpc_indirect_read(ctrl, 3, &tempdword);\r\nif (rc) {\r\nctrl_err(ctrl, "Cannot read slot config\n");\r\ngoto abort;\r\n}\r\nnum_slots = tempdword & SLOT_NUM;\r\nctrl_dbg(ctrl, " num_slots (indirect) %x\n", num_slots);\r\nfor (i = 0; i < 9 + num_slots; i++) {\r\nrc = shpc_indirect_read(ctrl, i, &tempdword);\r\nif (rc) {\r\nctrl_err(ctrl, "Cannot read creg (index = %d)\n",\r\ni);\r\ngoto abort;\r\n}\r\nctrl_dbg(ctrl, " offset %d: value %x\n", i, tempdword);\r\n}\r\nctrl->mmio_base =\r\npci_resource_start(pdev, 0) + shpc_base_offset;\r\nctrl->mmio_size = 0x24 + 0x4 * num_slots;\r\n}\r\nctrl_info(ctrl, "HPC vendor_id %x device_id %x ss_vid %x ss_did %x\n",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\nctrl_err(ctrl, "pci_enable_device failed\n");\r\ngoto abort;\r\n}\r\nif (!request_mem_region(ctrl->mmio_base, ctrl->mmio_size, MY_NAME)) {\r\nctrl_err(ctrl, "Cannot reserve MMIO region\n");\r\nrc = -1;\r\ngoto abort;\r\n}\r\nctrl->creg = ioremap(ctrl->mmio_base, ctrl->mmio_size);\r\nif (!ctrl->creg) {\r\nctrl_err(ctrl, "Cannot remap MMIO region %lx @ %lx\n",\r\nctrl->mmio_size, ctrl->mmio_base);\r\nrelease_mem_region(ctrl->mmio_base, ctrl->mmio_size);\r\nrc = -1;\r\ngoto abort;\r\n}\r\nctrl_dbg(ctrl, "ctrl->creg %p\n", ctrl->creg);\r\nmutex_init(&ctrl->crit_sect);\r\nmutex_init(&ctrl->cmd_lock);\r\ninit_waitqueue_head(&ctrl->queue);\r\nctrl->hpc_ops = &shpchp_hpc_ops;\r\nslot_config = shpc_readl(ctrl, SLOT_CONFIG);\r\nctrl->slot_device_offset = (slot_config & FIRST_DEV_NUM) >> 8;\r\nctrl->num_slots = slot_config & SLOT_NUM;\r\nctrl->first_slot = (slot_config & PSN) >> 16;\r\nctrl->slot_num_inc = ((slot_config & UPDOWN) >> 29) ? 1 : -1;\r\ntempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nctrl_dbg(ctrl, "SERR_INTR_ENABLE = %x\n", tempdword);\r\ntempdword |= (GLOBAL_INTR_MASK | GLOBAL_SERR_MASK |\r\nCOMMAND_INTR_MASK | ARBITER_SERR_MASK);\r\ntempdword &= ~SERR_INTR_RSVDZ_MASK;\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, tempdword);\r\ntempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nctrl_dbg(ctrl, "SERR_INTR_ENABLE = %x\n", tempdword);\r\nfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\r\nslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\r\nctrl_dbg(ctrl, "Default Logical Slot Register %d value %x\n",\r\nhp_slot, slot_reg);\r\nslot_reg |= (PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\r\nBUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\r\nCON_PFAULT_INTR_MASK | MRL_CHANGE_SERR_MASK |\r\nCON_PFAULT_SERR_MASK);\r\nslot_reg &= ~SLOT_REG_RSVDZ_MASK;\r\nshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\r\n}\r\nif (shpchp_poll_mode) {\r\ninit_timer(&ctrl->poll_timer);\r\nstart_int_poll_timer(ctrl, 10);\r\n} else {\r\nrc = pci_enable_msi(pdev);\r\nif (rc) {\r\nctrl_info(ctrl, "Can't get msi for the hotplug controller\n");\r\nctrl_info(ctrl, "Use INTx for the hotplug controller\n");\r\n}\r\nrc = request_irq(ctrl->pci_dev->irq, shpc_isr, IRQF_SHARED,\r\nMY_NAME, (void *)ctrl);\r\nctrl_dbg(ctrl, "request_irq %d (returns %d)\n",\r\nctrl->pci_dev->irq, rc);\r\nif (rc) {\r\nctrl_err(ctrl, "Can't get irq %d for the hotplug controller\n",\r\nctrl->pci_dev->irq);\r\ngoto abort_iounmap;\r\n}\r\n}\r\nctrl_dbg(ctrl, "HPC at %s irq=%x\n", pci_name(pdev), pdev->irq);\r\nshpc_get_max_bus_speed(ctrl);\r\nshpc_get_cur_bus_speed(ctrl);\r\nfor (hp_slot = 0; hp_slot < ctrl->num_slots; hp_slot++) {\r\nslot_reg = shpc_readl(ctrl, SLOT_REG(hp_slot));\r\nctrl_dbg(ctrl, "Default Logical Slot Register %d value %x\n",\r\nhp_slot, slot_reg);\r\nslot_reg &= ~(PRSNT_CHANGE_INTR_MASK | ISO_PFAULT_INTR_MASK |\r\nBUTTON_PRESS_INTR_MASK | MRL_CHANGE_INTR_MASK |\r\nCON_PFAULT_INTR_MASK | SLOT_REG_RSVDZ_MASK);\r\nshpc_writel(ctrl, SLOT_REG(hp_slot), slot_reg);\r\n}\r\nif (!shpchp_poll_mode) {\r\ntempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\ntempdword &= ~(GLOBAL_INTR_MASK | COMMAND_INTR_MASK |\r\nSERR_INTR_RSVDZ_MASK);\r\nshpc_writel(ctrl, SERR_INTR_ENABLE, tempdword);\r\ntempdword = shpc_readl(ctrl, SERR_INTR_ENABLE);\r\nctrl_dbg(ctrl, "SERR_INTR_ENABLE = %x\n", tempdword);\r\n}\r\nreturn 0;\r\nabort_iounmap:\r\niounmap(ctrl->creg);\r\nabort:\r\nreturn rc;\r\n}
