static inline int i2c_slave_did_ack(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct cx23885_i2c *bus = i2c_adap->algo_data;\r\nstruct cx23885_dev *dev = bus->dev;\r\nreturn cx_read(bus->reg_stat) & 0x01;\r\n}\r\nstatic inline int i2c_is_busy(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct cx23885_i2c *bus = i2c_adap->algo_data;\r\nstruct cx23885_dev *dev = bus->dev;\r\nreturn cx_read(bus->reg_stat) & 0x02 ? 1 : 0;\r\n}\r\nstatic int i2c_wait_done(struct i2c_adapter *i2c_adap)\r\n{\r\nint count;\r\nfor (count = 0; count < I2C_WAIT_RETRY; count++) {\r\nif (!i2c_is_busy(i2c_adap))\r\nbreak;\r\nudelay(I2C_WAIT_DELAY);\r\n}\r\nif (I2C_WAIT_RETRY == count)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int i2c_sendbytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg, int joined_rlen)\r\n{\r\nstruct cx23885_i2c *bus = i2c_adap->algo_data;\r\nstruct cx23885_dev *dev = bus->dev;\r\nu32 wdata, addr, ctrl;\r\nint retval, cnt;\r\nif (joined_rlen)\r\ndprintk(1, "%s(msg->wlen=%d, nextmsg->rlen=%d)\n", __func__,\r\nmsg->len, joined_rlen);\r\nelse\r\ndprintk(1, "%s(msg->len=%d)\n", __func__, msg->len);\r\nif (msg->len == 0) {\r\ncx_write(bus->reg_addr, msg->addr << 25);\r\ncx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));\r\nif (!i2c_wait_done(i2c_adap))\r\nreturn -EIO;\r\nif (!i2c_slave_did_ack(i2c_adap))\r\nreturn -ENXIO;\r\ndprintk(1, "%s() returns 0\n", __func__);\r\nreturn 0;\r\n}\r\naddr = (msg->addr << 25) | msg->buf[0];\r\nwdata = msg->buf[0];\r\nctrl = bus->i2c_period | (1 << 12) | (1 << 2);\r\nif (msg->len > 1)\r\nctrl |= I2C_NOSTOP | I2C_EXTEND;\r\nelse if (joined_rlen)\r\nctrl |= I2C_NOSTOP;\r\ncx_write(bus->reg_addr, addr);\r\ncx_write(bus->reg_wdata, wdata);\r\ncx_write(bus->reg_ctrl, ctrl);\r\nif (!i2c_wait_done(i2c_adap))\r\ngoto eio;\r\nif (i2c_debug) {\r\nprintk(KERN_DEBUG " <W %02x %02x", msg->addr << 1, msg->buf[0]);\r\nif (!(ctrl & I2C_NOSTOP))\r\npr_cont(" >\n");\r\n}\r\nfor (cnt = 1; cnt < msg->len; cnt++) {\r\nwdata = msg->buf[cnt];\r\nctrl = bus->i2c_period | (1 << 12) | (1 << 2);\r\nif (cnt < msg->len - 1)\r\nctrl |= I2C_NOSTOP | I2C_EXTEND;\r\nelse if (joined_rlen)\r\nctrl |= I2C_NOSTOP;\r\ncx_write(bus->reg_addr, addr);\r\ncx_write(bus->reg_wdata, wdata);\r\ncx_write(bus->reg_ctrl, ctrl);\r\nif (!i2c_wait_done(i2c_adap))\r\ngoto eio;\r\nif (i2c_debug) {\r\npr_cont(" %02x", msg->buf[cnt]);\r\nif (!(ctrl & I2C_NOSTOP))\r\npr_cont(" >\n");\r\n}\r\n}\r\nreturn msg->len;\r\neio:\r\nretval = -EIO;\r\nif (i2c_debug)\r\npr_err(" ERR: %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int i2c_readbytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg, int joined)\r\n{\r\nstruct cx23885_i2c *bus = i2c_adap->algo_data;\r\nstruct cx23885_dev *dev = bus->dev;\r\nu32 ctrl, cnt;\r\nint retval;\r\nif (i2c_debug && !joined)\r\ndprintk(1, "%s(msg->len=%d)\n", __func__, msg->len);\r\nif (msg->len == 0) {\r\ncx_write(bus->reg_addr, msg->addr << 25);\r\ncx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);\r\nif (!i2c_wait_done(i2c_adap))\r\nreturn -EIO;\r\nif (!i2c_slave_did_ack(i2c_adap))\r\nreturn -ENXIO;\r\ndprintk(1, "%s() returns 0\n", __func__);\r\nreturn 0;\r\n}\r\nif (i2c_debug) {\r\nif (joined)\r\ndprintk(1, " R");\r\nelse\r\ndprintk(1, " <R %02x", (msg->addr << 1) + 1);\r\n}\r\nfor (cnt = 0; cnt < msg->len; cnt++) {\r\nctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;\r\nif (cnt < msg->len - 1)\r\nctrl |= I2C_NOSTOP | I2C_EXTEND;\r\ncx_write(bus->reg_addr, msg->addr << 25);\r\ncx_write(bus->reg_ctrl, ctrl);\r\nif (!i2c_wait_done(i2c_adap))\r\ngoto eio;\r\nmsg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;\r\nif (i2c_debug) {\r\ndprintk(1, " %02x", msg->buf[cnt]);\r\nif (!(ctrl & I2C_NOSTOP))\r\ndprintk(1, " >\n");\r\n}\r\n}\r\nreturn msg->len;\r\neio:\r\nretval = -EIO;\r\nif (i2c_debug)\r\npr_err(" ERR: %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nint i, retval = 0;\r\ndprintk(1, "%s(num = %d)\n", __func__, num);\r\nfor (i = 0 ; i < num; i++) {\r\ndprintk(1, "%s(num = %d) addr = 0x%02x len = 0x%x\n",\r\n__func__, num, msgs[i].addr, msgs[i].len);\r\nif (msgs[i].flags & I2C_M_RD) {\r\nretval = i2c_readbytes(i2c_adap, &msgs[i], 0);\r\n} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\r\nmsgs[i].addr == msgs[i + 1].addr) {\r\nretval = i2c_sendbytes(i2c_adap, &msgs[i],\r\nmsgs[i + 1].len);\r\nif (retval < 0)\r\ngoto err;\r\ni++;\r\nretval = i2c_readbytes(i2c_adap, &msgs[i], 1);\r\n} else {\r\nretval = i2c_sendbytes(i2c_adap, &msgs[i], 0);\r\n}\r\nif (retval < 0)\r\ngoto err;\r\n}\r\nreturn num;\r\nerr:\r\nreturn retval;\r\n}\r\nstatic u32 cx23885_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\r\n}\r\nstatic void do_i2c_scan(char *name, struct i2c_client *c)\r\n{\r\nunsigned char buf;\r\nint i, rc;\r\nfor (i = 0; i < 128; i++) {\r\nc->addr = i;\r\nrc = i2c_master_recv(c, &buf, 0);\r\nif (rc < 0)\r\ncontinue;\r\npr_info("%s: i2c scan: found device @ 0x%04x [%s]\n",\r\nname, i, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\n}\r\nint cx23885_i2c_register(struct cx23885_i2c *bus)\r\n{\r\nstruct cx23885_dev *dev = bus->dev;\r\ndprintk(1, "%s(bus = %d)\n", __func__, bus->nr);\r\nbus->i2c_adap = cx23885_i2c_adap_template;\r\nbus->i2c_client = cx23885_i2c_client_template;\r\nbus->i2c_adap.dev.parent = &dev->pci->dev;\r\nstrlcpy(bus->i2c_adap.name, bus->dev->name,\r\nsizeof(bus->i2c_adap.name));\r\nbus->i2c_adap.algo_data = bus;\r\ni2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);\r\ni2c_add_adapter(&bus->i2c_adap);\r\nbus->i2c_client.adapter = &bus->i2c_adap;\r\nif (0 == bus->i2c_rc) {\r\ndprintk(1, "%s: i2c bus %d registered\n", dev->name, bus->nr);\r\nif (i2c_scan) {\r\npr_info("%s: scan bus %d:\n",\r\ndev->name, bus->nr);\r\ndo_i2c_scan(dev->name, &bus->i2c_client);\r\n}\r\n} else\r\npr_warn("%s: i2c bus %d register FAILED\n",\r\ndev->name, bus->nr);\r\nif (0 == bus->i2c_rc) {\r\nstruct i2c_board_info info;\r\nconst unsigned short addr_list[] = {\r\n0x6b, I2C_CLIENT_END\r\n};\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\ni2c_new_probed_device(&bus->i2c_adap, &info, addr_list,\r\ni2c_probe_func_quick_read);\r\n}\r\nreturn bus->i2c_rc;\r\n}\r\nint cx23885_i2c_unregister(struct cx23885_i2c *bus)\r\n{\r\ni2c_del_adapter(&bus->i2c_adap);\r\nreturn 0;\r\n}\r\nvoid cx23885_av_clk(struct cx23885_dev *dev, int enable)\r\n{\r\nchar buffer[3];\r\nstruct i2c_msg msg;\r\ndprintk(1, "%s(enabled = %d)\n", __func__, enable);\r\nbuffer[0] = 0x01;\r\nbuffer[1] = 0x44;\r\nif (enable == 1)\r\nbuffer[2] = 0x05;\r\nelse\r\nbuffer[2] = 0x00;\r\nmsg.addr = 0x44;\r\nmsg.flags = I2C_M_TEN;\r\nmsg.len = 3;\r\nmsg.buf = buffer;\r\ni2c_xfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);\r\n}
