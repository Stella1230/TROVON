static char *decode_ep0_state(struct mtu3 *mtu)\r\n{\r\nswitch (mtu->ep0_state) {\r\ncase MU3D_EP0_STATE_SETUP:\r\nreturn "SETUP";\r\ncase MU3D_EP0_STATE_TX:\r\nreturn "IN";\r\ncase MU3D_EP0_STATE_RX:\r\nreturn "OUT";\r\ncase MU3D_EP0_STATE_TX_END:\r\nreturn "TX-END";\r\ncase MU3D_EP0_STATE_STALL:\r\nreturn "STALL";\r\ndefault:\r\nreturn "??";\r\n}\r\n}\r\nstatic void ep0_req_giveback(struct mtu3 *mtu, struct usb_request *req)\r\n{\r\nmtu3_req_complete(mtu->ep0, req, 0);\r\n}\r\nstatic int\r\nforward_to_driver(struct mtu3 *mtu, const struct usb_ctrlrequest *setup)\r\n__releases(mtu->lock)\r\n__acquires(mtu->lock)\r\n{\r\nint ret;\r\nif (!mtu->gadget_driver)\r\nreturn -EOPNOTSUPP;\r\nspin_unlock(&mtu->lock);\r\nret = mtu->gadget_driver->setup(&mtu->g, setup);\r\nspin_lock(&mtu->lock);\r\ndev_dbg(mtu->dev, "%s ret %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void ep0_write_fifo(struct mtu3_ep *mep, const u8 *src, u16 len)\r\n{\r\nvoid __iomem *fifo = mep->mtu->mac_base + U3D_FIFO0;\r\nu16 index = 0;\r\ndev_dbg(mep->mtu->dev, "%s: ep%din, len=%d, buf=%p\n",\r\n__func__, mep->epnum, len, src);\r\nif (len >= 4) {\r\niowrite32_rep(fifo, src, len >> 2);\r\nindex = len & ~0x03;\r\n}\r\nif (len & 0x02) {\r\nwritew(*(u16 *)&src[index], fifo);\r\nindex += 2;\r\n}\r\nif (len & 0x01)\r\nwriteb(src[index], fifo);\r\n}\r\nstatic void ep0_read_fifo(struct mtu3_ep *mep, u8 *dst, u16 len)\r\n{\r\nvoid __iomem *fifo = mep->mtu->mac_base + U3D_FIFO0;\r\nu32 value;\r\nu16 index = 0;\r\ndev_dbg(mep->mtu->dev, "%s: ep%dout len=%d buf=%p\n",\r\n__func__, mep->epnum, len, dst);\r\nif (len >= 4) {\r\nioread32_rep(fifo, dst, len >> 2);\r\nindex = len & ~0x03;\r\n}\r\nif (len & 0x3) {\r\nvalue = readl(fifo);\r\nmemcpy(&dst[index], &value, len & 0x3);\r\n}\r\n}\r\nstatic void ep0_load_test_packet(struct mtu3 *mtu)\r\n{\r\nep0_write_fifo(mtu->ep0, mtu3_test_packet, sizeof(mtu3_test_packet));\r\n}\r\nstatic void ep0_stall_set(struct mtu3_ep *mep0, bool set, u32 pktrdy)\r\n{\r\nstruct mtu3 *mtu = mep0->mtu;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 csr;\r\ncsr = mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS;\r\nif (set)\r\ncsr |= EP0_SENDSTALL | pktrdy;\r\nelse\r\ncsr = (csr & ~EP0_SENDSTALL) | EP0_SENTSTALL;\r\nmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr);\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\ndev_dbg(mtu->dev, "ep0: %s STALL, ep0_state: %s\n",\r\nset ? "SEND" : "CLEAR", decode_ep0_state(mtu));\r\n}\r\nstatic void ep0_dummy_complete(struct usb_ep *ep, struct usb_request *req)\r\n{}\r\nstatic void ep0_set_sel_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct mtu3_request *mreq;\r\nstruct mtu3 *mtu;\r\nstruct usb_set_sel_req sel;\r\nmemcpy(&sel, req->buf, sizeof(sel));\r\nmreq = to_mtu3_request(req);\r\nmtu = mreq->mtu;\r\ndev_dbg(mtu->dev, "u1sel:%d, u1pel:%d, u2sel:%d, u2pel:%d\n",\r\nsel.u1_sel, sel.u1_pel, sel.u2_sel, sel.u2_pel);\r\n}\r\nstatic int ep0_set_sel(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\r\n{\r\nint ret;\r\nu16 length = le16_to_cpu(setup->wLength);\r\nif (unlikely(length != 6)) {\r\ndev_err(mtu->dev, "%s wrong wLength:%d\n",\r\n__func__, length);\r\nreturn -EINVAL;\r\n}\r\nmtu->ep0_req.mep = mtu->ep0;\r\nmtu->ep0_req.request.length = 6;\r\nmtu->ep0_req.request.buf = mtu->setup_buf;\r\nmtu->ep0_req.request.complete = ep0_set_sel_complete;\r\nret = ep0_queue(mtu->ep0, &mtu->ep0_req);\r\nreturn ret < 0 ? ret : 1;\r\n}\r\nstatic int\r\nep0_get_status(struct mtu3 *mtu, const struct usb_ctrlrequest *setup)\r\n{\r\nstruct mtu3_ep *mep = NULL;\r\nint handled = 1;\r\nu8 result[2] = {0, 0};\r\nu8 epnum = 0;\r\nint is_in;\r\nswitch (setup->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nresult[0] = mtu->is_self_powered << USB_DEVICE_SELF_POWERED;\r\nresult[0] |= mtu->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\r\nif (mtu->g.speed == USB_SPEED_SUPER) {\r\nresult[0] |= mtu->u1_enable << USB_DEV_STAT_U1_ENABLED;\r\nresult[0] |= mtu->u2_enable << USB_DEV_STAT_U2_ENABLED;\r\n}\r\ndev_dbg(mtu->dev, "%s result=%x, U1=%x, U2=%x\n", __func__,\r\nresult[0], mtu->u1_enable, mtu->u2_enable);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nepnum = (u8) le16_to_cpu(setup->wIndex);\r\nis_in = epnum & USB_DIR_IN;\r\nepnum &= USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum >= mtu->num_eps) {\r\nhandled = -EINVAL;\r\nbreak;\r\n}\r\nif (!epnum)\r\nbreak;\r\nmep = (is_in ? mtu->in_eps : mtu->out_eps) + epnum;\r\nif (!mep->desc) {\r\nhandled = -EINVAL;\r\nbreak;\r\n}\r\nif (mep->flags & MTU3_EP_STALL)\r\nresult[0] |= 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\nhandled = 0;\r\nbreak;\r\n}\r\nif (handled > 0) {\r\nint ret;\r\ndev_dbg(mtu->dev, "get_status=%x\n", *(u16 *)result);\r\nmemcpy(mtu->setup_buf, result, sizeof(result));\r\nmtu->ep0_req.mep = mtu->ep0;\r\nmtu->ep0_req.request.length = 2;\r\nmtu->ep0_req.request.buf = &mtu->setup_buf;\r\nmtu->ep0_req.request.complete = ep0_dummy_complete;\r\nret = ep0_queue(mtu->ep0, &mtu->ep0_req);\r\nif (ret < 0)\r\nhandled = ret;\r\n}\r\nreturn handled;\r\n}\r\nstatic int handle_test_mode(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint handled = 1;\r\nswitch (le16_to_cpu(setup->wIndex) >> 8) {\r\ncase TEST_J:\r\ndev_dbg(mtu->dev, "TEST_J\n");\r\nmtu->test_mode_nr = TEST_J_MODE;\r\nbreak;\r\ncase TEST_K:\r\ndev_dbg(mtu->dev, "TEST_K\n");\r\nmtu->test_mode_nr = TEST_K_MODE;\r\nbreak;\r\ncase TEST_SE0_NAK:\r\ndev_dbg(mtu->dev, "TEST_SE0_NAK\n");\r\nmtu->test_mode_nr = TEST_SE0_NAK_MODE;\r\nbreak;\r\ncase TEST_PACKET:\r\ndev_dbg(mtu->dev, "TEST_PACKET\n");\r\nmtu->test_mode_nr = TEST_PACKET_MODE;\r\nbreak;\r\ndefault:\r\nhandled = -EINVAL;\r\ngoto out;\r\n}\r\nmtu->test_mode = true;\r\nif (mtu->test_mode_nr == TEST_PACKET_MODE)\r\nep0_load_test_packet(mtu);\r\nmtu3_writel(mbase, U3D_USB2_TEST_MODE, mtu->test_mode_nr);\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\nout:\r\nreturn handled;\r\n}\r\nstatic int ep0_handle_feature_dev(struct mtu3 *mtu,\r\nstruct usb_ctrlrequest *setup, bool set)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint handled = -EINVAL;\r\nu32 lpc;\r\nswitch (le16_to_cpu(setup->wValue)) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nmtu->may_wakeup = !!set;\r\nhandled = 1;\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\nif (!set || (mtu->g.speed != USB_SPEED_HIGH) ||\r\n(le16_to_cpu(setup->wIndex) & 0xff))\r\nbreak;\r\nhandled = handle_test_mode(mtu, setup);\r\nbreak;\r\ncase USB_DEVICE_U1_ENABLE:\r\nif (mtu->g.speed != USB_SPEED_SUPER ||\r\nmtu->g.state != USB_STATE_CONFIGURED)\r\nbreak;\r\nlpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);\r\nif (set)\r\nlpc |= SW_U1_ACCEPT_ENABLE;\r\nelse\r\nlpc &= ~SW_U1_ACCEPT_ENABLE;\r\nmtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);\r\nmtu->u1_enable = !!set;\r\nhandled = 1;\r\nbreak;\r\ncase USB_DEVICE_U2_ENABLE:\r\nif (mtu->g.speed != USB_SPEED_SUPER ||\r\nmtu->g.state != USB_STATE_CONFIGURED)\r\nbreak;\r\nlpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);\r\nif (set)\r\nlpc |= SW_U2_ACCEPT_ENABLE;\r\nelse\r\nlpc &= ~SW_U2_ACCEPT_ENABLE;\r\nmtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);\r\nmtu->u2_enable = !!set;\r\nhandled = 1;\r\nbreak;\r\ndefault:\r\nhandled = -EINVAL;\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int ep0_handle_feature(struct mtu3 *mtu,\r\nstruct usb_ctrlrequest *setup, bool set)\r\n{\r\nstruct mtu3_ep *mep;\r\nint handled = -EINVAL;\r\nint is_in;\r\nu16 value;\r\nu16 index;\r\nu8 epnum;\r\nvalue = le16_to_cpu(setup->wValue);\r\nindex = le16_to_cpu(setup->wIndex);\r\nswitch (setup->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nhandled = ep0_handle_feature_dev(mtu, setup, set);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nif ((value == USB_INTRF_FUNC_SUSPEND)\r\n&& (mtu->g.speed == USB_SPEED_SUPER)) {\r\nhandled = 0;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nepnum = index & USB_ENDPOINT_NUMBER_MASK;\r\nif (epnum == 0 || epnum >= mtu->num_eps ||\r\nvalue != USB_ENDPOINT_HALT)\r\nbreak;\r\nis_in = index & USB_DIR_IN;\r\nmep = (is_in ? mtu->in_eps : mtu->out_eps) + epnum;\r\nif (!mep->desc)\r\nbreak;\r\nhandled = 1;\r\nif (mep->wedged)\r\nbreak;\r\nmtu3_ep_stall_set(mep, set);\r\nbreak;\r\ndefault:\r\nhandled = 0;\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic int handle_standard_request(struct mtu3 *mtu,\r\nstruct usb_ctrlrequest *setup)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nenum usb_device_state state = mtu->g.state;\r\nint handled = -EINVAL;\r\nu32 dev_conf;\r\nu16 value;\r\nvalue = le16_to_cpu(setup->wValue);\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nmtu->address = (u8) (value & 0x7f);\r\ndev_dbg(mtu->dev, "set address to 0x%x\n", mtu->address);\r\ndev_conf = mtu3_readl(mbase, U3D_DEVICE_CONF);\r\ndev_conf &= ~DEV_ADDR_MSK;\r\ndev_conf |= DEV_ADDR(mtu->address);\r\nmtu3_writel(mbase, U3D_DEVICE_CONF, dev_conf);\r\nif (mtu->address)\r\nusb_gadget_set_state(&mtu->g, USB_STATE_ADDRESS);\r\nelse\r\nusb_gadget_set_state(&mtu->g, USB_STATE_DEFAULT);\r\nhandled = 1;\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\nif (state == USB_STATE_ADDRESS) {\r\nusb_gadget_set_state(&mtu->g,\r\nUSB_STATE_CONFIGURED);\r\n} else if (state == USB_STATE_CONFIGURED) {\r\nif (!value)\r\nusb_gadget_set_state(&mtu->g,\r\nUSB_STATE_ADDRESS);\r\n}\r\nhandled = 0;\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nhandled = ep0_handle_feature(mtu, setup, 0);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nhandled = ep0_handle_feature(mtu, setup, 1);\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\nhandled = ep0_get_status(mtu, setup);\r\nbreak;\r\ncase USB_REQ_SET_SEL:\r\nhandled = ep0_set_sel(mtu, setup);\r\nbreak;\r\ncase USB_REQ_SET_ISOCH_DELAY:\r\nhandled = 1;\r\nbreak;\r\ndefault:\r\nhandled = 0;\r\n}\r\nreturn handled;\r\n}\r\nstatic void ep0_rx_state(struct mtu3 *mtu)\r\n{\r\nstruct mtu3_request *mreq;\r\nstruct usb_request *req;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 maxp;\r\nu32 csr;\r\nu16 count = 0;\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\ncsr = mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS;\r\nmreq = next_ep0_request(mtu);\r\nreq = &mreq->request;\r\nif (req) {\r\nvoid *buf = req->buf + req->actual;\r\nunsigned int len = req->length - req->actual;\r\ncount = mtu3_readl(mbase, U3D_RXCOUNT0);\r\nif (count > len) {\r\nreq->status = -EOVERFLOW;\r\ncount = len;\r\n}\r\nep0_read_fifo(mtu->ep0, buf, count);\r\nreq->actual += count;\r\ncsr |= EP0_RXPKTRDY;\r\nmaxp = mtu->g.ep0->maxpacket;\r\nif (count < maxp || req->actual == req->length) {\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\ndev_dbg(mtu->dev, "ep0 state: %s\n",\r\ndecode_ep0_state(mtu));\r\ncsr |= EP0_DATAEND;\r\n} else {\r\nreq = NULL;\r\n}\r\n} else {\r\ncsr |= EP0_RXPKTRDY | EP0_SENDSTALL;\r\ndev_dbg(mtu->dev, "%s: SENDSTALL\n", __func__);\r\n}\r\nmtu3_writel(mbase, U3D_EP0CSR, csr);\r\nif (req)\r\nep0_req_giveback(mtu, req);\r\n}\r\nstatic void ep0_tx_state(struct mtu3 *mtu)\r\n{\r\nstruct mtu3_request *mreq = next_ep0_request(mtu);\r\nstruct usb_request *req;\r\nu32 csr;\r\nu8 *src;\r\nu8 count;\r\nu32 maxp;\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\nif (!mreq)\r\nreturn;\r\nmaxp = mtu->g.ep0->maxpacket;\r\nreq = &mreq->request;\r\nsrc = (u8 *)req->buf + req->actual;\r\ncount = min(maxp, req->length - req->actual);\r\nif (count)\r\nep0_write_fifo(mtu->ep0, src, count);\r\ndev_dbg(mtu->dev, "%s act=%d, len=%d, cnt=%d, maxp=%d zero=%d\n",\r\n__func__, req->actual, req->length, count, maxp, req->zero);\r\nreq->actual += count;\r\nif ((count < maxp)\r\n|| ((req->actual == req->length) && !req->zero))\r\nmtu->ep0_state = MU3D_EP0_STATE_TX_END;\r\ncsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR) & EP0_W1C_BITS;\r\nmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr | EP0_TXPKTRDY);\r\ndev_dbg(mtu->dev, "%s ep0csr=0x%x\n", __func__,\r\nmtu3_readl(mtu->mac_base, U3D_EP0CSR));\r\n}\r\nstatic void ep0_read_setup(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\r\n{\r\nstruct mtu3_request *mreq;\r\nu32 count;\r\nu32 csr;\r\ncsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR) & EP0_W1C_BITS;\r\ncount = mtu3_readl(mtu->mac_base, U3D_RXCOUNT0);\r\nep0_read_fifo(mtu->ep0, (u8 *)setup, count);\r\ndev_dbg(mtu->dev, "SETUP req%02x.%02x v%04x i%04x l%04x\n",\r\nsetup->bRequestType, setup->bRequest,\r\nle16_to_cpu(setup->wValue), le16_to_cpu(setup->wIndex),\r\nle16_to_cpu(setup->wLength));\r\nmreq = next_ep0_request(mtu);\r\nif (mreq)\r\nep0_req_giveback(mtu, &mreq->request);\r\nif (le16_to_cpu(setup->wLength) == 0) {\r\n;\r\n} else if (setup->bRequestType & USB_DIR_IN) {\r\nmtu3_writel(mtu->mac_base, U3D_EP0CSR,\r\ncsr | EP0_SETUPPKTRDY | EP0_DPHTX);\r\nmtu->ep0_state = MU3D_EP0_STATE_TX;\r\n} else {\r\nmtu3_writel(mtu->mac_base, U3D_EP0CSR,\r\n(csr | EP0_SETUPPKTRDY) & (~EP0_DPHTX));\r\nmtu->ep0_state = MU3D_EP0_STATE_RX;\r\n}\r\n}\r\nstatic int ep0_handle_setup(struct mtu3 *mtu)\r\n__releases(mtu->lock)\r\n__acquires(mtu->lock)\r\n{\r\nstruct usb_ctrlrequest setup;\r\nstruct mtu3_request *mreq;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint handled = 0;\r\nep0_read_setup(mtu, &setup);\r\nif ((setup.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\r\nhandled = handle_standard_request(mtu, &setup);\r\ndev_dbg(mtu->dev, "handled %d, ep0_state: %s\n",\r\nhandled, decode_ep0_state(mtu));\r\nif (handled < 0)\r\ngoto stall;\r\nelse if (handled > 0)\r\ngoto finish;\r\nhandled = forward_to_driver(mtu, &setup);\r\nif (handled < 0) {\r\nstall:\r\ndev_dbg(mtu->dev, "%s stall (%d)\n", __func__, handled);\r\nep0_stall_set(mtu->ep0, true,\r\nle16_to_cpu(setup.wLength) ? 0 : EP0_SETUPPKTRDY);\r\nreturn 0;\r\n}\r\nfinish:\r\nif (mtu->test_mode) {\r\n;\r\n} else if (le16_to_cpu(setup.wLength) == 0) {\r\nmtu3_writel(mbase, U3D_EP0CSR,\r\n(mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS)\r\n| EP0_SETUPPKTRDY | EP0_DATAEND);\r\nmreq = next_ep0_request(mtu);\r\nif (mreq && !mreq->request.length)\r\nep0_req_giveback(mtu, &mreq->request);\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t mtu3_ep0_isr(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct mtu3_request *mreq;\r\nu32 int_status;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 csr;\r\nu32 len;\r\nint_status = mtu3_readl(mbase, U3D_EPISR);\r\nint_status &= mtu3_readl(mbase, U3D_EPIER);\r\nmtu3_writel(mbase, U3D_EPISR, int_status);\r\nif (!(int_status & EP0ISR))\r\nreturn IRQ_NONE;\r\ncsr = mtu3_readl(mbase, U3D_EP0CSR);\r\ndev_dbg(mtu->dev, "%s csr=0x%x\n", __func__, csr);\r\nif (csr & EP0_SENTSTALL) {\r\nep0_stall_set(mtu->ep0, false, 0);\r\ncsr = mtu3_readl(mbase, U3D_EP0CSR);\r\nret = IRQ_HANDLED;\r\n}\r\ndev_dbg(mtu->dev, "ep0_state: %s\n", decode_ep0_state(mtu));\r\nswitch (mtu->ep0_state) {\r\ncase MU3D_EP0_STATE_TX:\r\nif ((csr & EP0_FIFOFULL) == 0) {\r\nep0_tx_state(mtu);\r\nret = IRQ_HANDLED;\r\n}\r\nbreak;\r\ncase MU3D_EP0_STATE_RX:\r\nif (csr & EP0_RXPKTRDY) {\r\nep0_rx_state(mtu);\r\nret = IRQ_HANDLED;\r\n}\r\nbreak;\r\ncase MU3D_EP0_STATE_TX_END:\r\nmtu3_writel(mbase, U3D_EP0CSR,\r\n(csr & EP0_W1C_BITS) | EP0_DATAEND);\r\nmreq = next_ep0_request(mtu);\r\nif (mreq)\r\nep0_req_giveback(mtu, &mreq->request);\r\nmtu->ep0_state = MU3D_EP0_STATE_SETUP;\r\nret = IRQ_HANDLED;\r\ndev_dbg(mtu->dev, "ep0_state: %s\n", decode_ep0_state(mtu));\r\nbreak;\r\ncase MU3D_EP0_STATE_SETUP:\r\nif (!(csr & EP0_SETUPPKTRDY))\r\nbreak;\r\nlen = mtu3_readl(mbase, U3D_RXCOUNT0);\r\nif (len != 8) {\r\ndev_err(mtu->dev, "SETUP packet len %d != 8 ?\n", len);\r\nbreak;\r\n}\r\nep0_handle_setup(mtu);\r\nret = IRQ_HANDLED;\r\nbreak;\r\ndefault:\r\nep0_stall_set(mtu->ep0, true, 0);\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mtu3_ep0_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int mtu3_ep0_disable(struct usb_ep *ep)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ep0_queue(struct mtu3_ep *mep, struct mtu3_request *mreq)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nmreq->mtu = mtu;\r\nmreq->request.actual = 0;\r\nmreq->request.status = -EINPROGRESS;\r\ndev_dbg(mtu->dev, "%s %s (ep0_state: %s), len#%d\n", __func__,\r\nmep->name, decode_ep0_state(mtu), mreq->request.length);\r\nif (!list_empty(&mep->req_list))\r\nreturn -EBUSY;\r\nswitch (mtu->ep0_state) {\r\ncase MU3D_EP0_STATE_SETUP:\r\ncase MU3D_EP0_STATE_RX:\r\ncase MU3D_EP0_STATE_TX:\r\nbreak;\r\ndefault:\r\ndev_err(mtu->dev, "%s, error in ep0 state %s\n", __func__,\r\ndecode_ep0_state(mtu));\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&mreq->list, &mep->req_list);\r\nif (mtu->ep0_state == MU3D_EP0_STATE_TX)\r\nep0_tx_state(mtu);\r\nreturn 0;\r\n}\r\nstatic int mtu3_ep0_queue(struct usb_ep *ep,\r\nstruct usb_request *req, gfp_t gfp)\r\n{\r\nstruct mtu3_ep *mep;\r\nstruct mtu3_request *mreq;\r\nstruct mtu3 *mtu;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!ep || !req)\r\nreturn -EINVAL;\r\nmep = to_mtu3_ep(ep);\r\nmtu = mep->mtu;\r\nmreq = to_mtu3_request(req);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nret = ep0_queue(mep, mreq);\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int mtu3_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int mtu3_ep0_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct mtu3_ep *mep;\r\nstruct mtu3 *mtu;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!ep || !value)\r\nreturn -EINVAL;\r\nmep = to_mtu3_ep(ep);\r\nmtu = mep->mtu;\r\ndev_dbg(mtu->dev, "%s\n", __func__);\r\nspin_lock_irqsave(&mtu->lock, flags);\r\nif (!list_empty(&mep->req_list)) {\r\nret = -EBUSY;\r\ngoto cleanup;\r\n}\r\nswitch (mtu->ep0_state) {\r\ncase MU3D_EP0_STATE_TX:\r\ncase MU3D_EP0_STATE_TX_END:\r\ncase MU3D_EP0_STATE_RX:\r\ncase MU3D_EP0_STATE_SETUP:\r\nep0_stall_set(mtu->ep0, true, 0);\r\nbreak;\r\ndefault:\r\ndev_dbg(mtu->dev, "ep0 can't halt in state %s\n",\r\ndecode_ep0_state(mtu));\r\nret = -EINVAL;\r\n}\r\ncleanup:\r\nspin_unlock_irqrestore(&mtu->lock, flags);\r\nreturn ret;\r\n}
