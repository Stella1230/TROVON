static inline struct f_ncm *func_to_ncm(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_ncm, port.func);\r\n}\r\nstatic inline unsigned ncm_bitrate(struct usb_gadget *g)\r\n{\r\nif (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)\r\nreturn 13 * 1024 * 8 * 1000 * 8;\r\nelse if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)\r\nreturn 13 * 512 * 8 * 1000 * 8;\r\nelse\r\nreturn 19 * 64 * 1 * 1000 * 8;\r\n}\r\nstatic inline void put_ncm(__le16 **p, unsigned size, unsigned val)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nput_unaligned_le16((u16)val, *p);\r\nbreak;\r\ncase 2:\r\nput_unaligned_le32((u32)val, *p);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n*p += size;\r\n}\r\nstatic inline unsigned get_ncm(__le16 **p, unsigned size)\r\n{\r\nunsigned tmp;\r\nswitch (size) {\r\ncase 1:\r\ntmp = get_unaligned_le16(*p);\r\nbreak;\r\ncase 2:\r\ntmp = get_unaligned_le32(*p);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n*p += size;\r\nreturn tmp;\r\n}\r\nstatic inline void ncm_reset_values(struct f_ncm *ncm)\r\n{\r\nncm->parser_opts = &ndp16_opts;\r\nncm->is_crc = false;\r\nncm->port.cdc_filter = DEFAULT_FILTER;\r\nncm->port.header_len = 0;\r\nncm->port.fixed_out_len = le32_to_cpu(ntb_parameters.dwNtbOutMaxSize);\r\nncm->port.fixed_in_len = NTB_DEFAULT_IN_SIZE;\r\n}\r\nstatic void ncm_do_notify(struct f_ncm *ncm)\r\n{\r\nstruct usb_request *req = ncm->notify_req;\r\nstruct usb_cdc_notification *event;\r\nstruct usb_composite_dev *cdev = ncm->port.func.config->cdev;\r\n__le32 *data;\r\nint status;\r\nif (!req)\r\nreturn;\r\nevent = req->buf;\r\nswitch (ncm->notify_state) {\r\ncase NCM_NOTIFY_NONE:\r\nreturn;\r\ncase NCM_NOTIFY_CONNECT:\r\nevent->bNotificationType = USB_CDC_NOTIFY_NETWORK_CONNECTION;\r\nif (ncm->is_open)\r\nevent->wValue = cpu_to_le16(1);\r\nelse\r\nevent->wValue = cpu_to_le16(0);\r\nevent->wLength = 0;\r\nreq->length = sizeof *event;\r\nDBG(cdev, "notify connect %s\n",\r\nncm->is_open ? "true" : "false");\r\nncm->notify_state = NCM_NOTIFY_NONE;\r\nbreak;\r\ncase NCM_NOTIFY_SPEED:\r\nevent->bNotificationType = USB_CDC_NOTIFY_SPEED_CHANGE;\r\nevent->wValue = cpu_to_le16(0);\r\nevent->wLength = cpu_to_le16(8);\r\nreq->length = NCM_STATUS_BYTECOUNT;\r\ndata = req->buf + sizeof *event;\r\ndata[0] = cpu_to_le32(ncm_bitrate(cdev->gadget));\r\ndata[1] = data[0];\r\nDBG(cdev, "notify speed %d\n", ncm_bitrate(cdev->gadget));\r\nncm->notify_state = NCM_NOTIFY_CONNECT;\r\nbreak;\r\n}\r\nevent->bmRequestType = 0xA1;\r\nevent->wIndex = cpu_to_le16(ncm->ctrl_id);\r\nncm->notify_req = NULL;\r\nspin_unlock(&ncm->lock);\r\nstatus = usb_ep_queue(ncm->notify, req, GFP_ATOMIC);\r\nspin_lock(&ncm->lock);\r\nif (status < 0) {\r\nncm->notify_req = req;\r\nDBG(cdev, "notify --> %d\n", status);\r\n}\r\n}\r\nstatic void ncm_notify(struct f_ncm *ncm)\r\n{\r\nncm->notify_state = NCM_NOTIFY_SPEED;\r\nncm_do_notify(ncm);\r\n}\r\nstatic void ncm_notify_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_ncm *ncm = req->context;\r\nstruct usb_composite_dev *cdev = ncm->port.func.config->cdev;\r\nstruct usb_cdc_notification *event = req->buf;\r\nspin_lock(&ncm->lock);\r\nswitch (req->status) {\r\ncase 0:\r\nVDBG(cdev, "Notification %02x sent\n",\r\nevent->bNotificationType);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nncm->notify_state = NCM_NOTIFY_NONE;\r\nbreak;\r\ndefault:\r\nDBG(cdev, "event %02x --> %d\n",\r\nevent->bNotificationType, req->status);\r\nbreak;\r\n}\r\nncm->notify_req = req;\r\nncm_do_notify(ncm);\r\nspin_unlock(&ncm->lock);\r\n}\r\nstatic void ncm_ep0out_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned in_size;\r\nstruct usb_function *f = req->context;\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nreq->context = NULL;\r\nif (req->status || req->actual != req->length) {\r\nDBG(cdev, "Bad control-OUT transfer\n");\r\ngoto invalid;\r\n}\r\nin_size = get_unaligned_le32(req->buf);\r\nif (in_size < USB_CDC_NCM_NTB_MIN_IN_SIZE ||\r\nin_size > le32_to_cpu(ntb_parameters.dwNtbInMaxSize)) {\r\nDBG(cdev, "Got wrong INPUT SIZE (%d) from host\n", in_size);\r\ngoto invalid;\r\n}\r\nncm->port.fixed_in_len = in_size;\r\nVDBG(cdev, "Set NTB INPUT SIZE %d\n", in_size);\r\nreturn;\r\ninvalid:\r\nusb_ep_set_halt(ep);\r\nreturn;\r\n}\r\nstatic int ncm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SET_ETHERNET_PACKET_FILTER:\r\nif (w_length != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nDBG(cdev, "packet filter %02x\n", w_value);\r\nncm->port.cdc_filter = w_value;\r\nvalue = 0;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_NTB_PARAMETERS:\r\nif (w_length == 0 || w_value != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nvalue = w_length > sizeof ntb_parameters ?\r\nsizeof ntb_parameters : w_length;\r\nmemcpy(req->buf, &ntb_parameters, value);\r\nVDBG(cdev, "Host asked NTB parameters\n");\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_NTB_INPUT_SIZE:\r\nif (w_length < 4 || w_value != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nput_unaligned_le32(ncm->port.fixed_in_len, req->buf);\r\nvalue = 4;\r\nVDBG(cdev, "Host asked INPUT SIZE, sending %d\n",\r\nncm->port.fixed_in_len);\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SET_NTB_INPUT_SIZE:\r\n{\r\nif (w_length != 4 || w_value != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nreq->complete = ncm_ep0out_complete;\r\nreq->length = w_length;\r\nreq->context = f;\r\nvalue = req->length;\r\nbreak;\r\n}\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_NTB_FORMAT:\r\n{\r\nuint16_t format;\r\nif (w_length < 2 || w_value != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nformat = (ncm->parser_opts == &ndp16_opts) ? 0x0000 : 0x0001;\r\nput_unaligned_le16(format, req->buf);\r\nvalue = 2;\r\nVDBG(cdev, "Host asked NTB FORMAT, sending %d\n", format);\r\nbreak;\r\n}\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SET_NTB_FORMAT:\r\n{\r\nif (w_length != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nswitch (w_value) {\r\ncase 0x0000:\r\nncm->parser_opts = &ndp16_opts;\r\nDBG(cdev, "NCM16 selected\n");\r\nbreak;\r\ncase 0x0001:\r\nncm->parser_opts = &ndp32_opts;\r\nDBG(cdev, "NCM32 selected\n");\r\nbreak;\r\ndefault:\r\ngoto invalid;\r\n}\r\nvalue = 0;\r\nbreak;\r\n}\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_CRC_MODE:\r\n{\r\nuint16_t is_crc;\r\nif (w_length < 2 || w_value != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nis_crc = ncm->is_crc ? 0x0001 : 0x0000;\r\nput_unaligned_le16(is_crc, req->buf);\r\nvalue = 2;\r\nVDBG(cdev, "Host asked CRC MODE, sending %d\n", is_crc);\r\nbreak;\r\n}\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SET_CRC_MODE:\r\n{\r\nint ndp_hdr_crc = 0;\r\nif (w_length != 0 || w_index != ncm->ctrl_id)\r\ngoto invalid;\r\nswitch (w_value) {\r\ncase 0x0000:\r\nncm->is_crc = false;\r\nndp_hdr_crc = NCM_NDP_HDR_NOCRC;\r\nDBG(cdev, "non-CRC mode selected\n");\r\nbreak;\r\ncase 0x0001:\r\nncm->is_crc = true;\r\nndp_hdr_crc = NCM_NDP_HDR_CRC;\r\nDBG(cdev, "CRC mode selected\n");\r\nbreak;\r\ndefault:\r\ngoto invalid;\r\n}\r\nncm->ndp_sign = ncm->parser_opts->ndp_sign | ndp_hdr_crc;\r\nvalue = 0;\r\nbreak;\r\n}\r\ndefault:\r\ninvalid:\r\nDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "ncm req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "ncm req %02x.%02x response err %d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nvalue);\r\n}\r\nreturn value;\r\n}\r\nstatic int ncm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == ncm->ctrl_id) {\r\nif (alt != 0)\r\ngoto fail;\r\nDBG(cdev, "reset ncm control %d\n", intf);\r\nusb_ep_disable(ncm->notify);\r\nif (!(ncm->notify->desc)) {\r\nDBG(cdev, "init ncm ctrl %d\n", intf);\r\nif (config_ep_by_speed(cdev->gadget, f, ncm->notify))\r\ngoto fail;\r\n}\r\nusb_ep_enable(ncm->notify);\r\n} else if (intf == ncm->data_id) {\r\nif (alt > 1)\r\ngoto fail;\r\nif (ncm->port.in_ep->enabled) {\r\nDBG(cdev, "reset ncm\n");\r\nncm->timer_stopping = true;\r\nncm->netdev = NULL;\r\ngether_disconnect(&ncm->port);\r\nncm_reset_values(ncm);\r\n}\r\nif (alt == 1) {\r\nstruct net_device *net;\r\nif (!ncm->port.in_ep->desc ||\r\n!ncm->port.out_ep->desc) {\r\nDBG(cdev, "init ncm\n");\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nncm->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nncm->port.out_ep)) {\r\nncm->port.in_ep->desc = NULL;\r\nncm->port.out_ep->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\nncm->port.is_zlp_ok =\r\ngadget_is_zlp_supported(cdev->gadget);\r\nncm->port.no_skb_reserve =\r\ngadget_avoids_skb_reserve(cdev->gadget);\r\nncm->port.cdc_filter = DEFAULT_FILTER;\r\nDBG(cdev, "activate ncm\n");\r\nnet = gether_connect(&ncm->port);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\nncm->netdev = net;\r\nncm->timer_stopping = false;\r\n}\r\nspin_lock(&ncm->lock);\r\nncm_notify(ncm);\r\nspin_unlock(&ncm->lock);\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic int ncm_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nif (intf == ncm->ctrl_id)\r\nreturn 0;\r\nreturn ncm->port.in_ep->enabled ? 1 : 0;\r\n}\r\nstatic struct sk_buff *package_for_tx(struct f_ncm *ncm)\r\n{\r\n__le16 *ntb_iter;\r\nstruct sk_buff *skb2 = NULL;\r\nunsigned ndp_pad;\r\nunsigned ndp_index;\r\nunsigned new_len;\r\nconst struct ndp_parser_opts *opts = ncm->parser_opts;\r\nconst int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);\r\nconst int dgram_idx_len = 2 * 2 * opts->dgram_item_len;\r\nhrtimer_try_to_cancel(&ncm->task_timer);\r\nndp_pad = ALIGN(ncm->skb_tx_data->len, ndp_align) -\r\nncm->skb_tx_data->len;\r\nndp_index = ncm->skb_tx_data->len + ndp_pad;\r\nnew_len = ndp_index + dgram_idx_len + ncm->skb_tx_ndp->len;\r\nntb_iter = (void *) ncm->skb_tx_data->data;\r\nntb_iter += 2 + 1 + 1;\r\nput_ncm(&ntb_iter, opts->block_length, new_len);\r\nput_ncm(&ntb_iter, opts->ndp_index, ndp_index);\r\nnew_len = opts->ndp_size +\r\n(ncm->ndp_dgram_count * dgram_idx_len);\r\nncm->ndp_dgram_count = 0;\r\nntb_iter = (void *) ncm->skb_tx_ndp->data;\r\nntb_iter += 2;\r\nput_unaligned_le16(new_len, ntb_iter);\r\nswap(skb2, ncm->skb_tx_data);\r\nif (ncm->skb_tx_data) {\r\ndev_consume_skb_any(ncm->skb_tx_data);\r\nncm->skb_tx_data = NULL;\r\n}\r\nntb_iter = (void *) skb_put(skb2, ndp_pad);\r\nmemset(ntb_iter, 0, ndp_pad);\r\nntb_iter = (void *) skb_put(skb2, ncm->skb_tx_ndp->len);\r\nmemcpy(ntb_iter, ncm->skb_tx_ndp->data, ncm->skb_tx_ndp->len);\r\ndev_consume_skb_any(ncm->skb_tx_ndp);\r\nncm->skb_tx_ndp = NULL;\r\nntb_iter = (void *) skb_put(skb2, dgram_idx_len);\r\nmemset(ntb_iter, 0, dgram_idx_len);\r\nreturn skb2;\r\n}\r\nstatic struct sk_buff *ncm_wrap_ntb(struct gether *port,\r\nstruct sk_buff *skb)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(&port->func);\r\nstruct sk_buff *skb2 = NULL;\r\nint ncb_len = 0;\r\n__le16 *ntb_data;\r\n__le16 *ntb_ndp;\r\nint dgram_pad;\r\nunsigned max_size = ncm->port.fixed_in_len;\r\nconst struct ndp_parser_opts *opts = ncm->parser_opts;\r\nconst int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);\r\nconst int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);\r\nconst int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);\r\nconst int dgram_idx_len = 2 * 2 * opts->dgram_item_len;\r\nif (!skb && !ncm->skb_tx_data)\r\nreturn NULL;\r\nif (skb) {\r\nif (ncm->is_crc) {\r\nuint32_t crc;\r\n__le16 *crc_pos;\r\ncrc = ~crc32_le(~0,\r\nskb->data,\r\nskb->len);\r\ncrc_pos = (void *) skb_put(skb, sizeof(uint32_t));\r\nput_unaligned_le32(crc, crc_pos);\r\n}\r\nif (ncm->skb_tx_data\r\n&& (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE\r\n|| (ncm->skb_tx_data->len +\r\ndiv + rem + skb->len +\r\nncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))\r\n> max_size)) {\r\nskb2 = package_for_tx(ncm);\r\nif (!skb2)\r\ngoto err;\r\n}\r\nif (!ncm->skb_tx_data) {\r\nncb_len = opts->nth_size;\r\ndgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;\r\nncb_len += dgram_pad;\r\nncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);\r\nif (!ncm->skb_tx_data)\r\ngoto err;\r\nncm->skb_tx_data->dev = ncm->netdev;\r\nntb_data = (void *) skb_put(ncm->skb_tx_data, ncb_len);\r\nmemset(ntb_data, 0, ncb_len);\r\nput_unaligned_le32(opts->nth_sign, ntb_data);\r\nntb_data += 2;\r\nput_unaligned_le16(opts->nth_size, ntb_data++);\r\nncm->skb_tx_ndp = alloc_skb((int)(opts->ndp_size\r\n+ opts->dpe_size\r\n* TX_MAX_NUM_DPE),\r\nGFP_ATOMIC);\r\nif (!ncm->skb_tx_ndp)\r\ngoto err;\r\nncm->skb_tx_ndp->dev = ncm->netdev;\r\nntb_ndp = (void *) skb_put(ncm->skb_tx_ndp,\r\nopts->ndp_size);\r\nmemset(ntb_ndp, 0, ncb_len);\r\nput_unaligned_le32(ncm->ndp_sign, ntb_ndp);\r\nntb_ndp += 2;\r\nncm->ndp_dgram_count = 1;\r\n}\r\nhrtimer_start(&ncm->task_timer, TX_TIMEOUT_NSECS,\r\nHRTIMER_MODE_REL);\r\nntb_ndp = (void *) skb_put(ncm->skb_tx_ndp, dgram_idx_len);\r\nmemset(ntb_ndp, 0, dgram_idx_len);\r\nncb_len = ncm->skb_tx_data->len;\r\ndgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;\r\nncb_len += dgram_pad;\r\nput_ncm(&ntb_ndp, opts->dgram_item_len, ncb_len);\r\nput_ncm(&ntb_ndp, opts->dgram_item_len, skb->len);\r\nncm->ndp_dgram_count++;\r\nntb_data = (void *) skb_put(ncm->skb_tx_data, dgram_pad);\r\nmemset(ntb_data, 0, dgram_pad);\r\nntb_data = (void *) skb_put(ncm->skb_tx_data, skb->len);\r\nmemcpy(ntb_data, skb->data, skb->len);\r\ndev_consume_skb_any(skb);\r\nskb = NULL;\r\n} else if (ncm->skb_tx_data && ncm->timer_force_tx) {\r\nskb2 = package_for_tx(ncm);\r\nif (!skb2)\r\ngoto err;\r\n}\r\nreturn skb2;\r\nerr:\r\nncm->netdev->stats.tx_dropped++;\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nif (ncm->skb_tx_data)\r\ndev_kfree_skb_any(ncm->skb_tx_data);\r\nif (ncm->skb_tx_ndp)\r\ndev_kfree_skb_any(ncm->skb_tx_ndp);\r\nreturn NULL;\r\n}\r\nstatic void ncm_tx_tasklet(unsigned long data)\r\n{\r\nstruct f_ncm *ncm = (void *)data;\r\nif (ncm->timer_stopping)\r\nreturn;\r\nif (ncm->skb_tx_data) {\r\nncm->timer_force_tx = true;\r\nncm->netdev->netdev_ops->ndo_start_xmit(NULL, ncm->netdev);\r\nncm->timer_force_tx = false;\r\n}\r\n}\r\nstatic enum hrtimer_restart ncm_tx_timeout(struct hrtimer *data)\r\n{\r\nstruct f_ncm *ncm = container_of(data, struct f_ncm, task_timer);\r\ntasklet_schedule(&ncm->tx_tasklet);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int ncm_unwrap_ntb(struct gether *port,\r\nstruct sk_buff *skb,\r\nstruct sk_buff_head *list)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(&port->func);\r\n__le16 *tmp = (void *) skb->data;\r\nunsigned index, index2;\r\nint ndp_index;\r\nunsigned dg_len, dg_len2;\r\nunsigned ndp_len;\r\nstruct sk_buff *skb2;\r\nint ret = -EINVAL;\r\nunsigned max_size = le32_to_cpu(ntb_parameters.dwNtbOutMaxSize);\r\nconst struct ndp_parser_opts *opts = ncm->parser_opts;\r\nunsigned crc_len = ncm->is_crc ? sizeof(uint32_t) : 0;\r\nint dgram_counter;\r\nif (get_unaligned_le32(tmp) != opts->nth_sign) {\r\nINFO(port->func.config->cdev, "Wrong NTH SIGN, skblen %d\n",\r\nskb->len);\r\nprint_hex_dump(KERN_INFO, "HEAD:", DUMP_PREFIX_ADDRESS, 32, 1,\r\nskb->data, 32, false);\r\ngoto err;\r\n}\r\ntmp += 2;\r\nif (get_unaligned_le16(tmp++) != opts->nth_size) {\r\nINFO(port->func.config->cdev, "Wrong NTB headersize\n");\r\ngoto err;\r\n}\r\ntmp++;\r\nif (get_ncm(&tmp, opts->block_length) > max_size) {\r\nINFO(port->func.config->cdev, "OUT size exceeded\n");\r\ngoto err;\r\n}\r\nndp_index = get_ncm(&tmp, opts->ndp_index);\r\ndo {\r\nif (((ndp_index % 4) != 0) &&\r\n(ndp_index < opts->nth_size)) {\r\nINFO(port->func.config->cdev, "Bad index: %#X\n",\r\nndp_index);\r\ngoto err;\r\n}\r\ntmp = (void *)(skb->data + ndp_index);\r\nif (get_unaligned_le32(tmp) != ncm->ndp_sign) {\r\nINFO(port->func.config->cdev, "Wrong NDP SIGN\n");\r\ngoto err;\r\n}\r\ntmp += 2;\r\nndp_len = get_unaligned_le16(tmp++);\r\nif ((ndp_len < opts->ndp_size\r\n+ 2 * 2 * (opts->dgram_item_len * 2))\r\n|| (ndp_len % opts->ndplen_align != 0)) {\r\nINFO(port->func.config->cdev, "Bad NDP length: %#X\n",\r\nndp_len);\r\ngoto err;\r\n}\r\ntmp += opts->reserved1;\r\nndp_index = get_ncm(&tmp, opts->next_ndp_index);\r\ntmp += opts->reserved2;\r\nndp_len -= opts->ndp_size;\r\nindex2 = get_ncm(&tmp, opts->dgram_item_len);\r\ndg_len2 = get_ncm(&tmp, opts->dgram_item_len);\r\ndgram_counter = 0;\r\ndo {\r\nindex = index2;\r\ndg_len = dg_len2;\r\nif (dg_len < 14 + crc_len) {\r\nINFO(port->func.config->cdev,\r\n"Bad dgram length: %#X\n", dg_len);\r\ngoto err;\r\n}\r\nif (ncm->is_crc) {\r\nuint32_t crc, crc2;\r\ncrc = get_unaligned_le32(skb->data +\r\nindex + dg_len -\r\ncrc_len);\r\ncrc2 = ~crc32_le(~0,\r\nskb->data + index,\r\ndg_len - crc_len);\r\nif (crc != crc2) {\r\nINFO(port->func.config->cdev,\r\n"Bad CRC\n");\r\ngoto err;\r\n}\r\n}\r\nindex2 = get_ncm(&tmp, opts->dgram_item_len);\r\ndg_len2 = get_ncm(&tmp, opts->dgram_item_len);\r\nskb2 = netdev_alloc_skb_ip_align(ncm->netdev,\r\ndg_len - crc_len);\r\nif (skb2 == NULL)\r\ngoto err;\r\nmemcpy(skb_put(skb2, dg_len - crc_len),\r\nskb->data + index, dg_len - crc_len);\r\nskb_queue_tail(list, skb2);\r\nndp_len -= 2 * (opts->dgram_item_len * 2);\r\ndgram_counter++;\r\nif (index2 == 0 || dg_len2 == 0)\r\nbreak;\r\n} while (ndp_len > 2 * (opts->dgram_item_len * 2));\r\n} while (ndp_index);\r\ndev_consume_skb_any(skb);\r\nVDBG(port->func.config->cdev,\r\n"Parsed NTB with %d frames\n", dgram_counter);\r\nreturn 0;\r\nerr:\r\nskb_queue_purge(list);\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nstatic void ncm_disable(struct usb_function *f)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "ncm deactivated\n");\r\nif (ncm->port.in_ep->enabled) {\r\nncm->timer_stopping = true;\r\nncm->netdev = NULL;\r\ngether_disconnect(&ncm->port);\r\n}\r\nif (ncm->notify->enabled) {\r\nusb_ep_disable(ncm->notify);\r\nncm->notify->desc = NULL;\r\n}\r\n}\r\nstatic void ncm_open(struct gether *geth)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(&geth->func);\r\nDBG(ncm->port.func.config->cdev, "%s\n", __func__);\r\nspin_lock(&ncm->lock);\r\nncm->is_open = true;\r\nncm_notify(ncm);\r\nspin_unlock(&ncm->lock);\r\n}\r\nstatic void ncm_close(struct gether *geth)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(&geth->func);\r\nDBG(ncm->port.func.config->cdev, "%s\n", __func__);\r\nspin_lock(&ncm->lock);\r\nncm->is_open = false;\r\nncm_notify(ncm);\r\nspin_unlock(&ncm->lock);\r\n}\r\nstatic int ncm_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nstruct usb_string *us;\r\nint status;\r\nstruct usb_ep *ep;\r\nstruct f_ncm_opts *ncm_opts;\r\nif (!can_support_ecm(cdev->gadget))\r\nreturn -EINVAL;\r\nncm_opts = container_of(f->fi, struct f_ncm_opts, func_inst);\r\nif (!ncm_opts->bound) {\r\nmutex_lock(&ncm_opts->lock);\r\ngether_set_gadget(ncm_opts->net, cdev->gadget);\r\nstatus = gether_register_netdev(ncm_opts->net);\r\nmutex_unlock(&ncm_opts->lock);\r\nif (status)\r\nreturn status;\r\nncm_opts->bound = true;\r\n}\r\nus = usb_gstrings_attach(cdev, ncm_strings,\r\nARRAY_SIZE(ncm_string_defs));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nncm_control_intf.iInterface = us[STRING_CTRL_IDX].id;\r\nncm_data_nop_intf.iInterface = us[STRING_DATA_IDX].id;\r\nncm_data_intf.iInterface = us[STRING_DATA_IDX].id;\r\necm_desc.iMACAddress = us[STRING_MAC_IDX].id;\r\nncm_iad_desc.iFunction = us[STRING_IAD_IDX].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nncm->ctrl_id = status;\r\nncm_iad_desc.bFirstInterface = status;\r\nncm_control_intf.bInterfaceNumber = status;\r\nncm_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nncm->data_id = status;\r\nncm_data_nop_intf.bInterfaceNumber = status;\r\nncm_data_intf.bInterfaceNumber = status;\r\nncm_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nncm->port.in_ep = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nncm->port.out_ep = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\nncm->notify = ep;\r\nstatus = -ENOMEM;\r\nncm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (!ncm->notify_req)\r\ngoto fail;\r\nncm->notify_req->buf = kmalloc(NCM_STATUS_BYTECOUNT, GFP_KERNEL);\r\nif (!ncm->notify_req->buf)\r\ngoto fail;\r\nncm->notify_req->context = ncm;\r\nncm->notify_req->complete = ncm_notify_complete;\r\nhs_ncm_in_desc.bEndpointAddress = fs_ncm_in_desc.bEndpointAddress;\r\nhs_ncm_out_desc.bEndpointAddress = fs_ncm_out_desc.bEndpointAddress;\r\nhs_ncm_notify_desc.bEndpointAddress =\r\nfs_ncm_notify_desc.bEndpointAddress;\r\nss_ncm_in_desc.bEndpointAddress = fs_ncm_in_desc.bEndpointAddress;\r\nss_ncm_out_desc.bEndpointAddress = fs_ncm_out_desc.bEndpointAddress;\r\nss_ncm_notify_desc.bEndpointAddress =\r\nfs_ncm_notify_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, ncm_fs_function, ncm_hs_function,\r\nncm_ss_function, NULL);\r\nif (status)\r\ngoto fail;\r\nncm->port.open = ncm_open;\r\nncm->port.close = ncm_close;\r\ntasklet_init(&ncm->tx_tasklet, ncm_tx_tasklet, (unsigned long) ncm);\r\nhrtimer_init(&ncm->task_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nncm->task_timer.function = ncm_tx_timeout;\r\nDBG(cdev, "CDC Network: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nncm->port.in_ep->name, ncm->port.out_ep->name,\r\nncm->notify->name);\r\nreturn 0;\r\nfail:\r\nif (ncm->notify_req) {\r\nkfree(ncm->notify_req->buf);\r\nusb_ep_free_request(ncm->notify, ncm->notify_req);\r\n}\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic inline struct f_ncm_opts *to_f_ncm_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_ncm_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void ncm_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_ncm_opts *opts;\r\nopts = container_of(f, struct f_ncm_opts, func_inst);\r\nif (opts->bound)\r\ngether_cleanup(netdev_priv(opts->net));\r\nelse\r\nfree_netdev(opts->net);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *ncm_alloc_inst(void)\r\n{\r\nstruct f_ncm_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = ncm_free_inst;\r\nopts->net = gether_setup_default();\r\nif (IS_ERR(opts->net)) {\r\nstruct net_device *net = opts->net;\r\nkfree(opts);\r\nreturn ERR_CAST(net);\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "", &ncm_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void ncm_free(struct usb_function *f)\r\n{\r\nstruct f_ncm *ncm;\r\nstruct f_ncm_opts *opts;\r\nncm = func_to_ncm(f);\r\nopts = container_of(f->fi, struct f_ncm_opts, func_inst);\r\nkfree(ncm);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void ncm_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_ncm *ncm = func_to_ncm(f);\r\nDBG(c->cdev, "ncm unbind\n");\r\nhrtimer_cancel(&ncm->task_timer);\r\ntasklet_kill(&ncm->tx_tasklet);\r\nncm_string_defs[0].id = 0;\r\nusb_free_all_descriptors(f);\r\nkfree(ncm->notify_req->buf);\r\nusb_ep_free_request(ncm->notify, ncm->notify_req);\r\n}\r\nstatic struct usb_function *ncm_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_ncm *ncm;\r\nstruct f_ncm_opts *opts;\r\nint status;\r\nncm = kzalloc(sizeof(*ncm), GFP_KERNEL);\r\nif (!ncm)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_ncm_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt++;\r\nstatus = gether_get_host_addr_cdc(opts->net, ncm->ethaddr,\r\nsizeof(ncm->ethaddr));\r\nif (status < 12) {\r\nkfree(ncm);\r\nmutex_unlock(&opts->lock);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nncm_string_defs[STRING_MAC_IDX].s = ncm->ethaddr;\r\nspin_lock_init(&ncm->lock);\r\nncm_reset_values(ncm);\r\nncm->port.ioport = netdev_priv(opts->net);\r\nmutex_unlock(&opts->lock);\r\nncm->port.is_fixed = true;\r\nncm->port.supports_multi_frame = true;\r\nncm->port.func.name = "cdc_network";\r\nncm->port.func.bind = ncm_bind;\r\nncm->port.func.unbind = ncm_unbind;\r\nncm->port.func.set_alt = ncm_set_alt;\r\nncm->port.func.get_alt = ncm_get_alt;\r\nncm->port.func.setup = ncm_setup;\r\nncm->port.func.disable = ncm_disable;\r\nncm->port.func.free_func = ncm_free;\r\nncm->port.wrap = ncm_wrap_ntb;\r\nncm->port.unwrap = ncm_unwrap_ntb;\r\nreturn &ncm->port.func;\r\n}
