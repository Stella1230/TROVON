static inline unsigned char MISCin(struct riva_par *par)\r\n{\r\nreturn (VGA_RD08(par->riva.PVIO, 0x3cc));\r\n}\r\nstatic Bool\r\nriva_is_connected(struct riva_par *par, Bool second)\r\n{\r\nvolatile U032 __iomem *PRAMDAC = par->riva.PRAMDAC0;\r\nU032 reg52C, reg608;\r\nBool present;\r\nif(second) PRAMDAC += 0x800;\r\nreg52C = NV_RD32(PRAMDAC, 0x052C);\r\nreg608 = NV_RD32(PRAMDAC, 0x0608);\r\nNV_WR32(PRAMDAC, 0x0608, reg608 & ~0x00010000);\r\nNV_WR32(PRAMDAC, 0x052C, reg52C & 0x0000FEEE);\r\nmdelay(1);\r\nNV_WR32(PRAMDAC, 0x052C, NV_RD32(PRAMDAC, 0x052C) | 1);\r\nNV_WR32(par->riva.PRAMDAC0, 0x0610, 0x94050140);\r\nNV_WR32(par->riva.PRAMDAC0, 0x0608, 0x00001000);\r\nmdelay(1);\r\npresent = (NV_RD32(PRAMDAC, 0x0608) & (1 << 28)) ? TRUE : FALSE;\r\nNV_WR32(par->riva.PRAMDAC0, 0x0608,\r\nNV_RD32(par->riva.PRAMDAC0, 0x0608) & 0x0000EFFF);\r\nNV_WR32(PRAMDAC, 0x052C, reg52C);\r\nNV_WR32(PRAMDAC, 0x0608, reg608);\r\nreturn present;\r\n}\r\nstatic void\r\nriva_override_CRTC(struct riva_par *par)\r\n{\r\nprintk(KERN_INFO PFX\r\n"Detected CRTC controller %i being used\n",\r\npar->SecondCRTC ? 1 : 0);\r\nif(par->forceCRTC != -1) {\r\nprintk(KERN_INFO PFX\r\n"Forcing usage of CRTC %i\n", par->forceCRTC);\r\npar->SecondCRTC = par->forceCRTC;\r\n}\r\n}\r\nstatic void\r\nriva_is_second(struct riva_par *par)\r\n{\r\nif (par->FlatPanel == 1) {\r\nswitch(par->Chipset & 0xffff) {\r\ncase 0x0174:\r\ncase 0x0175:\r\ncase 0x0176:\r\ncase 0x0177:\r\ncase 0x0179:\r\ncase 0x017C:\r\ncase 0x017D:\r\ncase 0x0186:\r\ncase 0x0187:\r\ncase 0x0286:\r\ncase 0x028C:\r\ncase 0x0316:\r\ncase 0x0317:\r\ncase 0x031A:\r\ncase 0x031B:\r\ncase 0x031C:\r\ncase 0x031D:\r\ncase 0x031E:\r\ncase 0x031F:\r\ncase 0x0324:\r\ncase 0x0325:\r\ncase 0x0328:\r\ncase 0x0329:\r\ncase 0x032C:\r\ncase 0x032D:\r\npar->SecondCRTC = TRUE;\r\nbreak;\r\ndefault:\r\npar->SecondCRTC = FALSE;\r\nbreak;\r\n}\r\n} else {\r\nif(riva_is_connected(par, 0)) {\r\nif (NV_RD32(par->riva.PRAMDAC0, 0x0000052C) & 0x100)\r\npar->SecondCRTC = TRUE;\r\nelse\r\npar->SecondCRTC = FALSE;\r\n} else\r\nif (riva_is_connected(par, 1)) {\r\nif(NV_RD32(par->riva.PRAMDAC0, 0x0000252C) & 0x100)\r\npar->SecondCRTC = TRUE;\r\nelse\r\npar->SecondCRTC = FALSE;\r\n} else\r\npar->SecondCRTC = FALSE;\r\n}\r\nriva_override_CRTC(par);\r\n}\r\nunsigned long riva_get_memlen(struct riva_par *par)\r\n{\r\nRIVA_HW_INST *chip = &par->riva;\r\nunsigned long memlen = 0;\r\nunsigned int chipset = par->Chipset;\r\nstruct pci_dev* dev;\r\nu32 amt;\r\nswitch (chip->Architecture) {\r\ncase NV_ARCH_03:\r\nif (NV_RD32(chip->PFB, 0x00000000) & 0x00000020) {\r\nif (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)\r\n&& ((NV_RD32(chip->PMC, 0x00000000)&0x0F)>=0x02)) {\r\nswitch (NV_RD32(chip->PFB,0x00000000) & 0x03) {\r\ncase 2:\r\nmemlen = 1024 * 4;\r\nbreak;\r\ncase 1:\r\nmemlen = 1024 * 2;\r\nbreak;\r\ndefault:\r\nmemlen = 1024 * 8;\r\nbreak;\r\n}\r\n} else {\r\nmemlen = 1024 * 8;\r\n}\r\n} else {\r\nswitch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003) {\r\ncase 0:\r\nmemlen = 1024 * 8;\r\nbreak;\r\ncase 2:\r\nmemlen = 1024 * 4;\r\nbreak;\r\ndefault:\r\nmemlen = 1024 * 2;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase NV_ARCH_04:\r\nif (NV_RD32(chip->PFB, 0x00000000) & 0x00000100) {\r\nmemlen = ((NV_RD32(chip->PFB, 0x00000000)>>12)&0x0F) *\r\n1024 * 2 + 1024 * 2;\r\n} else {\r\nswitch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003) {\r\ncase 0:\r\nmemlen = 1024 * 32;\r\nbreak;\r\ncase 1:\r\nmemlen = 1024 * 4;\r\nbreak;\r\ncase 2:\r\nmemlen = 1024 * 8;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nmemlen = 1024 * 16;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nif(chipset == NV_CHIP_IGEFORCE2) {\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x7C, &amt);\r\npci_dev_put(dev);\r\nmemlen = (((amt >> 6) & 31) + 1) * 1024;\r\n} else if (chipset == NV_CHIP_0x01F0) {\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x84, &amt);\r\npci_dev_put(dev);\r\nmemlen = (((amt >> 4) & 127) + 1) * 1024;\r\n} else {\r\nswitch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) &\r\n0x000000FF){\r\ncase 0x02:\r\nmemlen = 1024 * 2;\r\nbreak;\r\ncase 0x04:\r\nmemlen = 1024 * 4;\r\nbreak;\r\ncase 0x08:\r\nmemlen = 1024 * 8;\r\nbreak;\r\ncase 0x10:\r\nmemlen = 1024 * 16;\r\nbreak;\r\ncase 0x20:\r\nmemlen = 1024 * 32;\r\nbreak;\r\ncase 0x40:\r\nmemlen = 1024 * 64;\r\nbreak;\r\ncase 0x80:\r\nmemlen = 1024 * 128;\r\nbreak;\r\ndefault:\r\nmemlen = 1024 * 16;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn memlen;\r\n}\r\nunsigned long riva_get_maxdclk(struct riva_par *par)\r\n{\r\nRIVA_HW_INST *chip = &par->riva;\r\nunsigned long dclk = 0;\r\nswitch (chip->Architecture) {\r\ncase NV_ARCH_03:\r\nif (NV_RD32(chip->PFB, 0x00000000) & 0x00000020) {\r\nif (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)\r\n&& ((NV_RD32(chip->PMC,0x00000000)&0x0F) >= 0x02)) {\r\ndclk = 800000;\r\n} else {\r\ndclk = 1000000;\r\n}\r\n} else {\r\ndclk = 1000000;\r\n}\r\nbreak;\r\ncase NV_ARCH_04:\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nswitch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003) {\r\ncase 3:\r\ndclk = 800000;\r\nbreak;\r\ndefault:\r\ndclk = 1000000;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn dclk;\r\n}\r\nvoid\r\nriva_common_setup(struct riva_par *par)\r\n{\r\npar->riva.EnableIRQ = 0;\r\npar->riva.PRAMDAC0 =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00680000);\r\npar->riva.PFB =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00100000);\r\npar->riva.PFIFO =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00002000);\r\npar->riva.PGRAPH =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00400000);\r\npar->riva.PEXTDEV =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00101000);\r\npar->riva.PTIMER =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00009000);\r\npar->riva.PMC =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00000000);\r\npar->riva.FIFO =\r\n(volatile U032 __iomem *)(par->ctrl_base + 0x00800000);\r\npar->riva.PCIO0 = par->ctrl_base + 0x00601000;\r\npar->riva.PDIO0 = par->ctrl_base + 0x00681000;\r\npar->riva.PVIO = par->ctrl_base + 0x000C0000;\r\npar->riva.IO = (MISCin(par) & 0x01) ? 0x3D0 : 0x3B0;\r\nif (par->FlatPanel == -1) {\r\nswitch (par->Chipset & 0xffff) {\r\ncase 0x0112:\r\ncase 0x0174:\r\ncase 0x0175:\r\ncase 0x0176:\r\ncase 0x0177:\r\ncase 0x0179:\r\ncase 0x017C:\r\ncase 0x017D:\r\ncase 0x0186:\r\ncase 0x0187:\r\ncase 0x0286:\r\ncase 0x028C:\r\ncase 0x0316:\r\ncase 0x0317:\r\ncase 0x031A:\r\ncase 0x031B:\r\ncase 0x031C:\r\ncase 0x031D:\r\ncase 0x031E:\r\ncase 0x031F:\r\ncase 0x0324:\r\ncase 0x0325:\r\ncase 0x0328:\r\ncase 0x0329:\r\ncase 0x032C:\r\ncase 0x032D:\r\nprintk(KERN_INFO PFX\r\n"On a laptop. Assuming Digital Flat Panel\n");\r\npar->FlatPanel = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (par->Chipset & 0x0ff0) {\r\ncase 0x0110:\r\nif (par->Chipset == NV_CHIP_GEFORCE2_GO)\r\npar->SecondCRTC = TRUE;\r\n#if defined(__powerpc__)\r\nif (par->FlatPanel == 1)\r\npar->SecondCRTC = TRUE;\r\n#endif\r\nriva_override_CRTC(par);\r\nbreak;\r\ncase 0x0170:\r\ncase 0x0180:\r\ncase 0x01F0:\r\ncase 0x0250:\r\ncase 0x0280:\r\ncase 0x0300:\r\ncase 0x0310:\r\ncase 0x0320:\r\ncase 0x0330:\r\ncase 0x0340:\r\nriva_is_second(par);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (par->SecondCRTC) {\r\npar->riva.PCIO = par->riva.PCIO0 + 0x2000;\r\npar->riva.PCRTC = par->riva.PCRTC0 + 0x800;\r\npar->riva.PRAMDAC = par->riva.PRAMDAC0 + 0x800;\r\npar->riva.PDIO = par->riva.PDIO0 + 0x2000;\r\n} else {\r\npar->riva.PCIO = par->riva.PCIO0;\r\npar->riva.PCRTC = par->riva.PCRTC0;\r\npar->riva.PRAMDAC = par->riva.PRAMDAC0;\r\npar->riva.PDIO = par->riva.PDIO0;\r\n}\r\nif (par->FlatPanel == -1) {\r\npar->FlatPanel = 0;\r\n}\r\npar->riva.flatPanel = (par->FlatPanel > 0) ? TRUE : FALSE;\r\nRivaGetConfig(&par->riva, par->Chipset);\r\n}
