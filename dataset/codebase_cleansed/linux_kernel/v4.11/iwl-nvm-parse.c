static u32 iwl_get_channel_flags(u8 ch_num, int ch_idx, bool is_5ghz,\r\nu16 nvm_flags, const struct iwl_cfg *cfg)\r\n{\r\nu32 flags = IEEE80211_CHAN_NO_HT40;\r\nu32 last_5ghz_ht = LAST_5GHZ_HT;\r\nif (cfg->device_family == IWL_DEVICE_FAMILY_8000)\r\nlast_5ghz_ht = LAST_5GHZ_HT_FAMILY_8000;\r\nif (!is_5ghz && (nvm_flags & NVM_CHANNEL_40MHZ)) {\r\nif (ch_num <= LAST_2GHZ_HT_PLUS)\r\nflags &= ~IEEE80211_CHAN_NO_HT40PLUS;\r\nif (ch_num >= FIRST_2GHZ_HT_MINUS)\r\nflags &= ~IEEE80211_CHAN_NO_HT40MINUS;\r\n} else if (ch_num <= last_5ghz_ht && (nvm_flags & NVM_CHANNEL_40MHZ)) {\r\nif ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)\r\nflags &= ~IEEE80211_CHAN_NO_HT40PLUS;\r\nelse\r\nflags &= ~IEEE80211_CHAN_NO_HT40MINUS;\r\n}\r\nif (!(nvm_flags & NVM_CHANNEL_80MHZ))\r\nflags |= IEEE80211_CHAN_NO_80MHZ;\r\nif (!(nvm_flags & NVM_CHANNEL_160MHZ))\r\nflags |= IEEE80211_CHAN_NO_160MHZ;\r\nif (!(nvm_flags & NVM_CHANNEL_IBSS))\r\nflags |= IEEE80211_CHAN_NO_IR;\r\nif (!(nvm_flags & NVM_CHANNEL_ACTIVE))\r\nflags |= IEEE80211_CHAN_NO_IR;\r\nif (nvm_flags & NVM_CHANNEL_RADAR)\r\nflags |= IEEE80211_CHAN_RADAR;\r\nif (nvm_flags & NVM_CHANNEL_INDOOR_ONLY)\r\nflags |= IEEE80211_CHAN_INDOOR_ONLY;\r\nif ((nvm_flags & NVM_CHANNEL_GO_CONCURRENT) &&\r\n(flags & IEEE80211_CHAN_NO_IR))\r\nflags |= IEEE80211_CHAN_IR_CONCURRENT;\r\nreturn flags;\r\n}\r\nstatic int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst __le16 * const nvm_ch_flags,\r\nbool lar_supported)\r\n{\r\nint ch_idx;\r\nint n_channels = 0;\r\nstruct ieee80211_channel *channel;\r\nu16 ch_flags;\r\nbool is_5ghz;\r\nint num_of_ch, num_2ghz_channels;\r\nconst u8 *nvm_chan;\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000) {\r\nnum_of_ch = IWL_NUM_CHANNELS;\r\nnvm_chan = &iwl_nvm_channels[0];\r\nnum_2ghz_channels = NUM_2GHZ_CHANNELS;\r\n} else {\r\nnum_of_ch = IWL_NUM_CHANNELS_FAMILY_8000;\r\nnvm_chan = &iwl_nvm_channels_family_8000[0];\r\nnum_2ghz_channels = NUM_2GHZ_CHANNELS_FAMILY_8000;\r\n}\r\nfor (ch_idx = 0; ch_idx < num_of_ch; ch_idx++) {\r\nch_flags = __le16_to_cpup(nvm_ch_flags + ch_idx);\r\nif (ch_idx >= num_2ghz_channels &&\r\n!data->sku_cap_band_52GHz_enable)\r\ncontinue;\r\nif (ch_flags & NVM_CHANNEL_160MHZ)\r\ndata->vht160_supported = true;\r\nif (!lar_supported && !(ch_flags & NVM_CHANNEL_VALID)) {\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d Flags %x [%sGHz] - No traffic\n",\r\nnvm_chan[ch_idx],\r\nch_flags,\r\n(ch_idx >= num_2ghz_channels) ?\r\n"5.2" : "2.4");\r\ncontinue;\r\n}\r\nchannel = &data->channels[n_channels];\r\nn_channels++;\r\nchannel->hw_value = nvm_chan[ch_idx];\r\nchannel->band = (ch_idx < num_2ghz_channels) ?\r\nNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\r\nchannel->center_freq =\r\nieee80211_channel_to_frequency(\r\nchannel->hw_value, channel->band);\r\nchannel->max_power = IWL_DEFAULT_MAX_TX_POWER;\r\nis_5ghz = channel->band == NL80211_BAND_5GHZ;\r\nif (!lar_supported)\r\nchannel->flags = iwl_get_channel_flags(nvm_chan[ch_idx],\r\nch_idx, is_5ghz,\r\nch_flags, cfg);\r\nelse\r\nchannel->flags = 0;\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d [%sGHz] flags 0x%x %s%s%s%s%s%s%s%s%s%s(%ddBm): Ad-Hoc %ssupported\n",\r\nchannel->hw_value,\r\nis_5ghz ? "5.2" : "2.4",\r\nch_flags,\r\nCHECK_AND_PRINT_I(VALID),\r\nCHECK_AND_PRINT_I(IBSS),\r\nCHECK_AND_PRINT_I(ACTIVE),\r\nCHECK_AND_PRINT_I(RADAR),\r\nCHECK_AND_PRINT_I(INDOOR_ONLY),\r\nCHECK_AND_PRINT_I(GO_CONCURRENT),\r\nCHECK_AND_PRINT_I(WIDE),\r\nCHECK_AND_PRINT_I(40MHZ),\r\nCHECK_AND_PRINT_I(80MHZ),\r\nCHECK_AND_PRINT_I(160MHZ),\r\nchannel->max_power,\r\n((ch_flags & NVM_CHANNEL_IBSS) &&\r\n!(ch_flags & NVM_CHANNEL_RADAR))\r\n? "" : "not ");\r\n}\r\nreturn n_channels;\r\n}\r\nstatic void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nstruct ieee80211_sta_vht_cap *vht_cap,\r\nu8 tx_chains, u8 rx_chains)\r\n{\r\nint num_rx_ants = num_of_ant(rx_chains);\r\nint num_tx_ants = num_of_ant(tx_chains);\r\nunsigned int max_ampdu_exponent = (cfg->max_vht_ampdu_exponent ?:\r\nIEEE80211_VHT_MAX_AMPDU_1024K);\r\nvht_cap->vht_supported = true;\r\nvht_cap->cap = IEEE80211_VHT_CAP_SHORT_GI_80 |\r\nIEEE80211_VHT_CAP_RXSTBC_1 |\r\nIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\r\n3 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT |\r\nmax_ampdu_exponent <<\r\nIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\r\nif (data->vht160_supported)\r\nvht_cap->cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ |\r\nIEEE80211_VHT_CAP_SHORT_GI_160;\r\nif (cfg->vht_mu_mimo_supported)\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\r\nif (cfg->ht_params->ldpc)\r\nvht_cap->cap |= IEEE80211_VHT_CAP_RXLDPC;\r\nif (data->sku_cap_mimo_disabled) {\r\nnum_rx_ants = 1;\r\nnum_tx_ants = 1;\r\n}\r\nif (num_tx_ants > 1)\r\nvht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;\r\nelse\r\nvht_cap->cap |= IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;\r\nswitch (iwlwifi_mod_params.amsdu_size) {\r\ncase IWL_AMSDU_DEF:\r\nif (cfg->mq_rx_supported)\r\nvht_cap->cap |=\r\nIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\r\nelse\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\r\nbreak;\r\ncase IWL_AMSDU_4K:\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895;\r\nbreak;\r\ncase IWL_AMSDU_8K:\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;\r\nbreak;\r\ncase IWL_AMSDU_12K:\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvht_cap->vht_mcs.rx_mcs_map =\r\ncpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 14);\r\nif (num_rx_ants == 1 || cfg->rx_with_siso_diversity) {\r\nvht_cap->cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN;\r\nvht_cap->vht_mcs.rx_mcs_map |=\r\ncpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << 2);\r\n}\r\nvht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;\r\n}\r\nstatic void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst __le16 *ch_section,\r\nu8 tx_chains, u8 rx_chains, bool lar_supported)\r\n{\r\nint n_channels;\r\nint n_used = 0;\r\nstruct ieee80211_supported_band *sband;\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\nn_channels = iwl_init_channel_map(\r\ndev, cfg, data,\r\n&ch_section[NVM_CHANNELS], lar_supported);\r\nelse\r\nn_channels = iwl_init_channel_map(\r\ndev, cfg, data,\r\n&ch_section[NVM_CHANNELS_FAMILY_8000],\r\nlar_supported);\r\nsband = &data->bands[NL80211_BAND_2GHZ];\r\nsband->band = NL80211_BAND_2GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];\r\nsband->n_bitrates = N_RATES_24;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nNL80211_BAND_2GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, NL80211_BAND_2GHZ,\r\ntx_chains, rx_chains);\r\nsband = &data->bands[NL80211_BAND_5GHZ];\r\nsband->band = NL80211_BAND_5GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\r\nsband->n_bitrates = N_RATES_52;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nNL80211_BAND_5GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, NL80211_BAND_5GHZ,\r\ntx_chains, rx_chains);\r\nif (data->sku_cap_11ac_enable && !iwlwifi_mod_params.disable_11ac)\r\niwl_init_vht_hw_capab(cfg, data, &sband->vht_cap,\r\ntx_chains, rx_chains);\r\nif (n_channels != n_used)\r\nIWL_ERR_DEV(dev, "NVM: used only %d of %d channels\n",\r\nn_used, n_channels);\r\n}\r\nstatic int iwl_get_sku(const struct iwl_cfg *cfg, const __le16 *nvm_sw,\r\nconst __le16 *phy_sku)\r\n{\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\nreturn le16_to_cpup(nvm_sw + SKU);\r\nreturn le32_to_cpup((__le32 *)(phy_sku + SKU_FAMILY_8000));\r\n}\r\nstatic int iwl_get_nvm_version(const struct iwl_cfg *cfg, const __le16 *nvm_sw)\r\n{\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\nreturn le16_to_cpup(nvm_sw + NVM_VERSION);\r\nelse\r\nreturn le32_to_cpup((__le32 *)(nvm_sw +\r\nNVM_VERSION_FAMILY_8000));\r\n}\r\nstatic int iwl_get_radio_cfg(const struct iwl_cfg *cfg, const __le16 *nvm_sw,\r\nconst __le16 *phy_sku)\r\n{\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\nreturn le16_to_cpup(nvm_sw + RADIO_CFG);\r\nreturn le32_to_cpup((__le32 *)(phy_sku + RADIO_CFG_FAMILY_8000));\r\n}\r\nstatic int iwl_get_n_hw_addrs(const struct iwl_cfg *cfg, const __le16 *nvm_sw)\r\n{\r\nint n_hw_addr;\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\nreturn le16_to_cpup(nvm_sw + N_HW_ADDRS);\r\nn_hw_addr = le32_to_cpup((__le32 *)(nvm_sw + N_HW_ADDRS_FAMILY_8000));\r\nreturn n_hw_addr & N_HW_ADDR_MASK;\r\n}\r\nstatic void iwl_set_radio_cfg(const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nu32 radio_cfg)\r\n{\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000) {\r\ndata->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);\r\ndata->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);\r\ndata->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);\r\ndata->radio_cfg_pnum = NVM_RF_CFG_PNUM_MSK(radio_cfg);\r\nreturn;\r\n}\r\ndata->radio_cfg_type = NVM_RF_CFG_TYPE_MSK_FAMILY_8000(radio_cfg);\r\ndata->radio_cfg_step = NVM_RF_CFG_STEP_MSK_FAMILY_8000(radio_cfg);\r\ndata->radio_cfg_dash = NVM_RF_CFG_DASH_MSK_FAMILY_8000(radio_cfg);\r\ndata->radio_cfg_pnum = NVM_RF_CFG_FLAVOR_MSK_FAMILY_8000(radio_cfg);\r\ndata->valid_tx_ant = NVM_RF_CFG_TX_ANT_MSK_FAMILY_8000(radio_cfg);\r\ndata->valid_rx_ant = NVM_RF_CFG_RX_ANT_MSK_FAMILY_8000(radio_cfg);\r\n}\r\nstatic void iwl_flip_hw_address(__le32 mac_addr0, __le32 mac_addr1, u8 *dest)\r\n{\r\nconst u8 *hw_addr;\r\nhw_addr = (const u8 *)&mac_addr0;\r\ndest[0] = hw_addr[3];\r\ndest[1] = hw_addr[2];\r\ndest[2] = hw_addr[1];\r\ndest[3] = hw_addr[0];\r\nhw_addr = (const u8 *)&mac_addr1;\r\ndest[4] = hw_addr[1];\r\ndest[5] = hw_addr[0];\r\n}\r\nstatic void iwl_set_hw_address_from_csr(struct iwl_trans *trans,\r\nstruct iwl_nvm_data *data)\r\n{\r\n__le32 mac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_STRAP));\r\n__le32 mac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_STRAP));\r\niwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\r\nif (is_valid_ether_addr(data->hw_addr))\r\nreturn;\r\nmac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_OTP));\r\nmac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_OTP));\r\niwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\r\n}\r\nstatic void iwl_set_hw_address_family_8000(struct iwl_trans *trans,\r\nconst struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst __le16 *mac_override,\r\nconst __le16 *nvm_hw)\r\n{\r\nconst u8 *hw_addr;\r\nif (mac_override) {\r\nstatic const u8 reserved_mac[] = {\r\n0x02, 0xcc, 0xaa, 0xff, 0xee, 0x00\r\n};\r\nhw_addr = (const u8 *)(mac_override +\r\nMAC_ADDRESS_OVERRIDE_FAMILY_8000);\r\nmemcpy(data->hw_addr, hw_addr, ETH_ALEN);\r\nif (is_valid_ether_addr(data->hw_addr) &&\r\nmemcmp(reserved_mac, hw_addr, ETH_ALEN) != 0)\r\nreturn;\r\nIWL_ERR(trans,\r\n"mac address from nvm override section is not valid\n");\r\n}\r\nif (nvm_hw) {\r\n__le32 mac_addr0 = cpu_to_le32(iwl_trans_read_prph(trans,\r\nWFMP_MAC_ADDR_0));\r\n__le32 mac_addr1 = cpu_to_le32(iwl_trans_read_prph(trans,\r\nWFMP_MAC_ADDR_1));\r\niwl_flip_hw_address(mac_addr0, mac_addr1, data->hw_addr);\r\nreturn;\r\n}\r\nIWL_ERR(trans, "mac address is not found\n");\r\n}\r\nstatic int iwl_set_hw_address(struct iwl_trans *trans,\r\nconst struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data, const __le16 *nvm_hw,\r\nconst __le16 *mac_override)\r\n{\r\nif (cfg->mac_addr_from_csr) {\r\niwl_set_hw_address_from_csr(trans, data);\r\n} else if (cfg->device_family != IWL_DEVICE_FAMILY_8000) {\r\nconst u8 *hw_addr = (const u8 *)(nvm_hw + HW_ADDR);\r\ndata->hw_addr[0] = hw_addr[1];\r\ndata->hw_addr[1] = hw_addr[0];\r\ndata->hw_addr[2] = hw_addr[3];\r\ndata->hw_addr[3] = hw_addr[2];\r\ndata->hw_addr[4] = hw_addr[5];\r\ndata->hw_addr[5] = hw_addr[4];\r\n} else {\r\niwl_set_hw_address_family_8000(trans, cfg, data,\r\nmac_override, nvm_hw);\r\n}\r\nif (!is_valid_ether_addr(data->hw_addr)) {\r\nIWL_ERR(trans, "no valid mac address was found\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct iwl_nvm_data *\r\niwl_parse_nvm_data(struct iwl_trans *trans, const struct iwl_cfg *cfg,\r\nconst __le16 *nvm_hw, const __le16 *nvm_sw,\r\nconst __le16 *nvm_calib, const __le16 *regulatory,\r\nconst __le16 *mac_override, const __le16 *phy_sku,\r\nu8 tx_chains, u8 rx_chains, bool lar_fw_supported)\r\n{\r\nstruct device *dev = trans->dev;\r\nstruct iwl_nvm_data *data;\r\nbool lar_enabled;\r\nu32 sku, radio_cfg;\r\nu16 lar_config;\r\nconst __le16 *ch_section;\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000)\r\ndata = kzalloc(sizeof(*data) +\r\nsizeof(struct ieee80211_channel) *\r\nIWL_NUM_CHANNELS,\r\nGFP_KERNEL);\r\nelse\r\ndata = kzalloc(sizeof(*data) +\r\nsizeof(struct ieee80211_channel) *\r\nIWL_NUM_CHANNELS_FAMILY_8000,\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ndata->nvm_version = iwl_get_nvm_version(cfg, nvm_sw);\r\nradio_cfg = iwl_get_radio_cfg(cfg, nvm_sw, phy_sku);\r\niwl_set_radio_cfg(cfg, data, radio_cfg);\r\nif (data->valid_tx_ant)\r\ntx_chains &= data->valid_tx_ant;\r\nif (data->valid_rx_ant)\r\nrx_chains &= data->valid_rx_ant;\r\nsku = iwl_get_sku(cfg, nvm_sw, phy_sku);\r\ndata->sku_cap_band_24GHz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;\r\ndata->sku_cap_band_52GHz_enable = sku & NVM_SKU_CAP_BAND_52GHZ;\r\ndata->sku_cap_11n_enable = sku & NVM_SKU_CAP_11N_ENABLE;\r\nif (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)\r\ndata->sku_cap_11n_enable = false;\r\ndata->sku_cap_11ac_enable = data->sku_cap_11n_enable &&\r\n(sku & NVM_SKU_CAP_11AC_ENABLE);\r\ndata->sku_cap_mimo_disabled = sku & NVM_SKU_CAP_MIMO_DISABLE;\r\ndata->n_hw_addrs = iwl_get_n_hw_addrs(cfg, nvm_sw);\r\nif (cfg->device_family != IWL_DEVICE_FAMILY_8000) {\r\nif (!nvm_calib) {\r\nIWL_ERR(trans,\r\n"Can't parse empty Calib NVM sections\n");\r\nkfree(data);\r\nreturn NULL;\r\n}\r\ndata->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);\r\ndata->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);\r\nlar_enabled = true;\r\nch_section = nvm_sw;\r\n} else {\r\nu16 lar_offset = data->nvm_version < 0xE39 ?\r\nNVM_LAR_OFFSET_FAMILY_8000_OLD :\r\nNVM_LAR_OFFSET_FAMILY_8000;\r\nlar_config = le16_to_cpup(regulatory + lar_offset);\r\ndata->lar_enabled = !!(lar_config &\r\nNVM_LAR_ENABLED_FAMILY_8000);\r\nlar_enabled = data->lar_enabled;\r\nch_section = regulatory;\r\n}\r\nif (iwl_set_hw_address(trans, cfg, data, nvm_hw, mac_override)) {\r\nkfree(data);\r\nreturn NULL;\r\n}\r\niwl_init_sbands(dev, cfg, data, ch_section, tx_chains, rx_chains,\r\nlar_fw_supported && lar_enabled);\r\ndata->calib_version = 255;\r\nreturn data;\r\n}\r\nstatic u32 iwl_nvm_get_regdom_bw_flags(const u8 *nvm_chan,\r\nint ch_idx, u16 nvm_flags,\r\nconst struct iwl_cfg *cfg)\r\n{\r\nu32 flags = NL80211_RRF_NO_HT40;\r\nu32 last_5ghz_ht = LAST_5GHZ_HT;\r\nif (cfg->device_family == IWL_DEVICE_FAMILY_8000)\r\nlast_5ghz_ht = LAST_5GHZ_HT_FAMILY_8000;\r\nif (ch_idx < NUM_2GHZ_CHANNELS &&\r\n(nvm_flags & NVM_CHANNEL_40MHZ)) {\r\nif (nvm_chan[ch_idx] <= LAST_2GHZ_HT_PLUS)\r\nflags &= ~NL80211_RRF_NO_HT40PLUS;\r\nif (nvm_chan[ch_idx] >= FIRST_2GHZ_HT_MINUS)\r\nflags &= ~NL80211_RRF_NO_HT40MINUS;\r\n} else if (nvm_chan[ch_idx] <= last_5ghz_ht &&\r\n(nvm_flags & NVM_CHANNEL_40MHZ)) {\r\nif ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)\r\nflags &= ~NL80211_RRF_NO_HT40PLUS;\r\nelse\r\nflags &= ~NL80211_RRF_NO_HT40MINUS;\r\n}\r\nif (!(nvm_flags & NVM_CHANNEL_80MHZ))\r\nflags |= NL80211_RRF_NO_80MHZ;\r\nif (!(nvm_flags & NVM_CHANNEL_160MHZ))\r\nflags |= NL80211_RRF_NO_160MHZ;\r\nif (!(nvm_flags & NVM_CHANNEL_ACTIVE))\r\nflags |= NL80211_RRF_NO_IR;\r\nif (nvm_flags & NVM_CHANNEL_RADAR)\r\nflags |= NL80211_RRF_DFS;\r\nif (nvm_flags & NVM_CHANNEL_INDOOR_ONLY)\r\nflags |= NL80211_RRF_NO_OUTDOOR;\r\nif ((nvm_flags & NVM_CHANNEL_GO_CONCURRENT) &&\r\n(flags & NL80211_RRF_NO_IR))\r\nflags |= NL80211_RRF_GO_CONCURRENT;\r\nreturn flags;\r\n}\r\nstruct ieee80211_regdomain *\r\niwl_parse_nvm_mcc_info(struct device *dev, const struct iwl_cfg *cfg,\r\nint num_of_ch, __le32 *channels, u16 fw_mcc)\r\n{\r\nint ch_idx;\r\nu16 ch_flags, prev_ch_flags = 0;\r\nconst u8 *nvm_chan = cfg->device_family == IWL_DEVICE_FAMILY_8000 ?\r\niwl_nvm_channels_family_8000 : iwl_nvm_channels;\r\nstruct ieee80211_regdomain *regd;\r\nint size_of_regd;\r\nstruct ieee80211_reg_rule *rule;\r\nenum nl80211_band band;\r\nint center_freq, prev_center_freq = 0;\r\nint valid_rules = 0;\r\nbool new_rule;\r\nint max_num_ch = cfg->device_family == IWL_DEVICE_FAMILY_8000 ?\r\nIWL_NUM_CHANNELS_FAMILY_8000 : IWL_NUM_CHANNELS;\r\nif (WARN_ON_ONCE(num_of_ch > NL80211_MAX_SUPP_REG_RULES))\r\nreturn ERR_PTR(-EINVAL);\r\nif (WARN_ON(num_of_ch > max_num_ch))\r\nnum_of_ch = max_num_ch;\r\nIWL_DEBUG_DEV(dev, IWL_DL_LAR, "building regdom for %d channels\n",\r\nnum_of_ch);\r\nsize_of_regd =\r\nsizeof(struct ieee80211_regdomain) +\r\nnum_of_ch * sizeof(struct ieee80211_reg_rule);\r\nregd = kzalloc(size_of_regd, GFP_KERNEL);\r\nif (!regd)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (ch_idx = 0; ch_idx < num_of_ch; ch_idx++) {\r\nch_flags = (u16)__le32_to_cpup(channels + ch_idx);\r\nband = (ch_idx < NUM_2GHZ_CHANNELS) ?\r\nNL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\r\ncenter_freq = ieee80211_channel_to_frequency(nvm_chan[ch_idx],\r\nband);\r\nnew_rule = false;\r\nif (!(ch_flags & NVM_CHANNEL_VALID)) {\r\nIWL_DEBUG_DEV(dev, IWL_DL_LAR,\r\n"Ch. %d Flags %x [%sGHz] - No traffic\n",\r\nnvm_chan[ch_idx],\r\nch_flags,\r\n(ch_idx >= NUM_2GHZ_CHANNELS) ?\r\n"5.2" : "2.4");\r\ncontinue;\r\n}\r\nif (ch_idx == 0 || prev_ch_flags != ch_flags ||\r\ncenter_freq - prev_center_freq > 20) {\r\nvalid_rules++;\r\nnew_rule = true;\r\n}\r\nrule = &regd->reg_rules[valid_rules - 1];\r\nif (new_rule)\r\nrule->freq_range.start_freq_khz =\r\nMHZ_TO_KHZ(center_freq - 10);\r\nrule->freq_range.end_freq_khz = MHZ_TO_KHZ(center_freq + 10);\r\nrule->power_rule.max_antenna_gain = DBI_TO_MBI(6);\r\nrule->power_rule.max_eirp =\r\nDBM_TO_MBM(IWL_DEFAULT_MAX_TX_POWER);\r\nrule->flags = iwl_nvm_get_regdom_bw_flags(nvm_chan, ch_idx,\r\nch_flags, cfg);\r\nrule->flags |= NL80211_RRF_AUTO_BW;\r\nrule->freq_range.max_bandwidth_khz = 0;\r\nprev_ch_flags = ch_flags;\r\nprev_center_freq = center_freq;\r\nIWL_DEBUG_DEV(dev, IWL_DL_LAR,\r\n"Ch. %d [%sGHz] %s%s%s%s%s%s%s%s%s(0x%02x): Ad-Hoc %ssupported\n",\r\ncenter_freq,\r\nband == NL80211_BAND_5GHZ ? "5.2" : "2.4",\r\nCHECK_AND_PRINT_I(VALID),\r\nCHECK_AND_PRINT_I(ACTIVE),\r\nCHECK_AND_PRINT_I(RADAR),\r\nCHECK_AND_PRINT_I(WIDE),\r\nCHECK_AND_PRINT_I(40MHZ),\r\nCHECK_AND_PRINT_I(80MHZ),\r\nCHECK_AND_PRINT_I(160MHZ),\r\nCHECK_AND_PRINT_I(INDOOR_ONLY),\r\nCHECK_AND_PRINT_I(GO_CONCURRENT),\r\nch_flags,\r\n((ch_flags & NVM_CHANNEL_ACTIVE) &&\r\n!(ch_flags & NVM_CHANNEL_RADAR))\r\n? "" : "not ");\r\n}\r\nregd->n_reg_rules = valid_rules;\r\nregd->alpha2[0] = fw_mcc >> 8;\r\nregd->alpha2[1] = fw_mcc & 0xff;\r\nreturn regd;\r\n}\r\nstatic u32 iwl_wrdd_get_mcc(struct device *dev, union acpi_object *wrdd)\r\n{\r\nunion acpi_object *mcc_pkg, *domain_type, *mcc_value;\r\nu32 i;\r\nif (wrdd->type != ACPI_TYPE_PACKAGE ||\r\nwrdd->package.count < 2 ||\r\nwrdd->package.elements[0].type != ACPI_TYPE_INTEGER ||\r\nwrdd->package.elements[0].integer.value != 0) {\r\nIWL_DEBUG_EEPROM(dev, "Unsupported wrdd structure\n");\r\nreturn 0;\r\n}\r\nfor (i = 1 ; i < wrdd->package.count ; ++i) {\r\nmcc_pkg = &wrdd->package.elements[i];\r\nif (mcc_pkg->type != ACPI_TYPE_PACKAGE ||\r\nmcc_pkg->package.count < 2 ||\r\nmcc_pkg->package.elements[0].type != ACPI_TYPE_INTEGER ||\r\nmcc_pkg->package.elements[1].type != ACPI_TYPE_INTEGER) {\r\nmcc_pkg = NULL;\r\ncontinue;\r\n}\r\ndomain_type = &mcc_pkg->package.elements[0];\r\nif (domain_type->integer.value == WRDD_WIFI)\r\nbreak;\r\nmcc_pkg = NULL;\r\n}\r\nif (mcc_pkg) {\r\nmcc_value = &mcc_pkg->package.elements[1];\r\nreturn mcc_value->integer.value;\r\n}\r\nreturn 0;\r\n}\r\nint iwl_get_bios_mcc(struct device *dev, char *mcc)\r\n{\r\nacpi_handle root_handle;\r\nacpi_handle handle;\r\nstruct acpi_buffer wrdd = {ACPI_ALLOCATE_BUFFER, NULL};\r\nacpi_status status;\r\nu32 mcc_val;\r\nroot_handle = ACPI_HANDLE(dev);\r\nif (!root_handle) {\r\nIWL_DEBUG_EEPROM(dev,\r\n"Could not retrieve root port ACPI handle\n");\r\nreturn -ENOENT;\r\n}\r\nstatus = acpi_get_handle(root_handle, (acpi_string)WRDD_METHOD,\r\n&handle);\r\nif (ACPI_FAILURE(status)) {\r\nIWL_DEBUG_EEPROM(dev, "WRD method not found\n");\r\nreturn -ENOENT;\r\n}\r\nstatus = acpi_evaluate_object(handle, NULL, NULL, &wrdd);\r\nif (ACPI_FAILURE(status)) {\r\nIWL_DEBUG_EEPROM(dev, "WRDC invocation failed (0x%x)\n",\r\nstatus);\r\nreturn -ENOENT;\r\n}\r\nmcc_val = iwl_wrdd_get_mcc(dev, wrdd.pointer);\r\nkfree(wrdd.pointer);\r\nif (!mcc_val)\r\nreturn -ENOENT;\r\nmcc[0] = (mcc_val >> 8) & 0xff;\r\nmcc[1] = mcc_val & 0xff;\r\nmcc[2] = '\0';\r\nreturn 0;\r\n}
