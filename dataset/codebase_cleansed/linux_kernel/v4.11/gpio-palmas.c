static int palmas_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct palmas_gpio *pg = gpiochip_get_data(gc);\r\nstruct palmas *palmas = pg->palmas;\r\nunsigned int val;\r\nint ret;\r\nunsigned int reg;\r\nint gpio16 = (offset/8);\r\noffset %= 8;\r\nreg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\r\nret = palmas_read(palmas, PALMAS_GPIO_BASE, reg, &val);\r\nif (ret < 0) {\r\ndev_err(gc->parent, "Reg 0x%02x read failed, %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nif (val & BIT(offset))\r\nreg = (gpio16) ? PALMAS_GPIO_DATA_OUT2 : PALMAS_GPIO_DATA_OUT;\r\nelse\r\nreg = (gpio16) ? PALMAS_GPIO_DATA_IN2 : PALMAS_GPIO_DATA_IN;\r\nret = palmas_read(palmas, PALMAS_GPIO_BASE, reg, &val);\r\nif (ret < 0) {\r\ndev_err(gc->parent, "Reg 0x%02x read failed, %d\n", reg, ret);\r\nreturn ret;\r\n}\r\nreturn !!(val & BIT(offset));\r\n}\r\nstatic void palmas_gpio_set(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct palmas_gpio *pg = gpiochip_get_data(gc);\r\nstruct palmas *palmas = pg->palmas;\r\nint ret;\r\nunsigned int reg;\r\nint gpio16 = (offset/8);\r\noffset %= 8;\r\nif (gpio16)\r\nreg = (value) ?\r\nPALMAS_GPIO_SET_DATA_OUT2 : PALMAS_GPIO_CLEAR_DATA_OUT2;\r\nelse\r\nreg = (value) ?\r\nPALMAS_GPIO_SET_DATA_OUT : PALMAS_GPIO_CLEAR_DATA_OUT;\r\nret = palmas_write(palmas, PALMAS_GPIO_BASE, reg, BIT(offset));\r\nif (ret < 0)\r\ndev_err(gc->parent, "Reg 0x%02x write failed, %d\n", reg, ret);\r\n}\r\nstatic int palmas_gpio_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct palmas_gpio *pg = gpiochip_get_data(gc);\r\nstruct palmas *palmas = pg->palmas;\r\nint ret;\r\nunsigned int reg;\r\nint gpio16 = (offset/8);\r\noffset %= 8;\r\nreg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\r\npalmas_gpio_set(gc, offset, value);\r\nret = palmas_update_bits(palmas, PALMAS_GPIO_BASE, reg,\r\nBIT(offset), BIT(offset));\r\nif (ret < 0)\r\ndev_err(gc->parent, "Reg 0x%02x update failed, %d\n", reg,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int palmas_gpio_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct palmas_gpio *pg = gpiochip_get_data(gc);\r\nstruct palmas *palmas = pg->palmas;\r\nint ret;\r\nunsigned int reg;\r\nint gpio16 = (offset/8);\r\noffset %= 8;\r\nreg = (gpio16) ? PALMAS_GPIO_DATA_DIR2 : PALMAS_GPIO_DATA_DIR;\r\nret = palmas_update_bits(palmas, PALMAS_GPIO_BASE, reg, BIT(offset), 0);\r\nif (ret < 0)\r\ndev_err(gc->parent, "Reg 0x%02x update failed, %d\n", reg,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int palmas_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct palmas_gpio *pg = gpiochip_get_data(gc);\r\nstruct palmas *palmas = pg->palmas;\r\nreturn palmas_irq_get_virq(palmas, PALMAS_GPIO_0_IRQ + offset);\r\n}\r\nstatic int palmas_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct palmas *palmas = dev_get_drvdata(pdev->dev.parent);\r\nstruct palmas_platform_data *palmas_pdata;\r\nstruct palmas_gpio *palmas_gpio;\r\nint ret;\r\nconst struct of_device_id *match;\r\nconst struct palmas_device_data *dev_data;\r\nmatch = of_match_device(of_palmas_gpio_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\ndev_data = match->data;\r\nif (!dev_data)\r\ndev_data = &palmas_dev_data;\r\npalmas_gpio = devm_kzalloc(&pdev->dev,\r\nsizeof(*palmas_gpio), GFP_KERNEL);\r\nif (!palmas_gpio)\r\nreturn -ENOMEM;\r\npalmas_gpio->palmas = palmas;\r\npalmas_gpio->gpio_chip.owner = THIS_MODULE;\r\npalmas_gpio->gpio_chip.label = dev_name(&pdev->dev);\r\npalmas_gpio->gpio_chip.ngpio = dev_data->ngpio;\r\npalmas_gpio->gpio_chip.can_sleep = true;\r\npalmas_gpio->gpio_chip.direction_input = palmas_gpio_input;\r\npalmas_gpio->gpio_chip.direction_output = palmas_gpio_output;\r\npalmas_gpio->gpio_chip.to_irq = palmas_gpio_to_irq;\r\npalmas_gpio->gpio_chip.set = palmas_gpio_set;\r\npalmas_gpio->gpio_chip.get = palmas_gpio_get;\r\npalmas_gpio->gpio_chip.parent = &pdev->dev;\r\n#ifdef CONFIG_OF_GPIO\r\npalmas_gpio->gpio_chip.of_node = pdev->dev.of_node;\r\n#endif\r\npalmas_pdata = dev_get_platdata(palmas->dev);\r\nif (palmas_pdata && palmas_pdata->gpio_base)\r\npalmas_gpio->gpio_chip.base = palmas_pdata->gpio_base;\r\nelse\r\npalmas_gpio->gpio_chip.base = -1;\r\nret = devm_gpiochip_add_data(&pdev->dev, &palmas_gpio->gpio_chip,\r\npalmas_gpio);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, palmas_gpio);\r\nreturn ret;\r\n}\r\nstatic int __init palmas_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&palmas_gpio_driver);\r\n}
