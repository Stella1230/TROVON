void amdgpu_connector_hotplug(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->hpd.hpd == AMDGPU_HPD_NONE)\r\nreturn;\r\namdgpu_display_hpd_set_polarity(adev, amdgpu_connector->hpd.hpd);\r\nif (connector->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\r\nstruct amdgpu_connector_atom_dig *dig_connector =\r\namdgpu_connector->con_priv;\r\nif (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT)\r\nreturn;\r\ndig_connector->dp_sink_type = amdgpu_atombios_dp_get_sinktype(amdgpu_connector);\r\nif (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\r\nint saved_dpms = connector->dpms;\r\nif (!amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\n} else if (amdgpu_atombios_dp_needs_link_train(amdgpu_connector)) {\r\nif (amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\r\nreturn;\r\nconnector->dpms = DRM_MODE_DPMS_OFF;\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\r\n}\r\nconnector->dpms = saved_dpms;\r\n}\r\n}\r\n}\r\nstatic void amdgpu_connector_property_change_mode(struct drm_encoder *encoder)\r\n{\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nif (crtc && crtc->enabled) {\r\ndrm_crtc_helper_set_mode(crtc, &crtc->mode,\r\ncrtc->x, crtc->y, crtc->primary->fb);\r\n}\r\n}\r\nint amdgpu_connector_get_monitor_bpc(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct amdgpu_connector_atom_dig *dig_connector;\r\nint bpc = 8;\r\nunsigned mode_clock, max_tmds_clock;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\nif (amdgpu_connector->use_digital) {\r\nif (drm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\nif (drm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ndig_connector = amdgpu_connector->con_priv;\r\nif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) ||\r\ndrm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\nif (connector->display_info.bpc)\r\nbpc = connector->display_info.bpc;\r\nelse {\r\nconst struct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nstruct drm_encoder *encoder = connector_funcs->best_encoder(connector);\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct amdgpu_encoder_atom_dig *dig = amdgpu_encoder->enc_priv;\r\nif (dig->lcd_misc & ATOM_PANEL_MISC_V13_6BIT_PER_COLOR)\r\nbpc = 6;\r\nelse if (dig->lcd_misc & ATOM_PANEL_MISC_V13_8BIT_PER_COLOR)\r\nbpc = 8;\r\n}\r\nbreak;\r\n}\r\nif (drm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (bpc > 12) {\r\nDRM_DEBUG("%s: HDMI deep color %d bpc unsupported. Using 12 bpc.\n",\r\nconnector->name, bpc);\r\nbpc = 12;\r\n}\r\nif (connector->display_info.max_tmds_clock > 0) {\r\nmode_clock = amdgpu_connector->pixelclock_for_modeset;\r\nmax_tmds_clock = connector->display_info.max_tmds_clock;\r\nDRM_DEBUG("%s: hdmi mode dotclock %d kHz, max tmds input clock %d kHz.\n",\r\nconnector->name, mode_clock, max_tmds_clock);\r\nif ((bpc == 12) && (mode_clock * 3/2 > max_tmds_clock)) {\r\nif ((connector->display_info.edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_30) &&\r\n(mode_clock * 5/4 <= max_tmds_clock))\r\nbpc = 10;\r\nelse\r\nbpc = 8;\r\nDRM_DEBUG("%s: HDMI deep color 12 bpc exceeds max tmds clock. Using %d bpc.\n",\r\nconnector->name, bpc);\r\n}\r\nif ((bpc == 10) && (mode_clock * 5/4 > max_tmds_clock)) {\r\nbpc = 8;\r\nDRM_DEBUG("%s: HDMI deep color 10 bpc exceeds max tmds clock. Using %d bpc.\n",\r\nconnector->name, bpc);\r\n}\r\n} else if (bpc > 8) {\r\nDRM_DEBUG("%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\n",\r\nconnector->name);\r\nbpc = 8;\r\n}\r\n}\r\nif ((amdgpu_deep_color == 0) && (bpc > 8)) {\r\nDRM_DEBUG("%s: Deep color disabled. Set amdgpu module param deep_color=1 to enable.\n",\r\nconnector->name);\r\nbpc = 8;\r\n}\r\nDRM_DEBUG("%s: Display bpc=%d, returned bpc=%d\n",\r\nconnector->name, connector->display_info.bpc, bpc);\r\nreturn bpc;\r\n}\r\nstatic void\r\namdgpu_connector_update_scratch_regs(struct drm_connector *connector,\r\nenum drm_connector_status status)\r\n{\r\nstruct drm_encoder *best_encoder = NULL;\r\nstruct drm_encoder *encoder = NULL;\r\nconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\nbool connected;\r\nint i;\r\nbest_encoder = connector_funcs->best_encoder(connector);\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif ((encoder == best_encoder) && (status == connector_status_connected))\r\nconnected = true;\r\nelse\r\nconnected = false;\r\namdgpu_atombios_encoder_set_bios_scratch_regs(connector, encoder, connected);\r\n}\r\n}\r\nstatic struct drm_encoder *\r\namdgpu_connector_find_encoder(struct drm_connector *connector,\r\nint encoder_type)\r\n{\r\nstruct drm_encoder *encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (encoder->encoder_type == encoder_type)\r\nreturn encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstruct edid *amdgpu_connector_edid(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct drm_property_blob *edid_blob = connector->edid_blob_ptr;\r\nif (amdgpu_connector->edid) {\r\nreturn amdgpu_connector->edid;\r\n} else if (edid_blob) {\r\nstruct edid *edid = kmemdup(edid_blob->data, edid_blob->length, GFP_KERNEL);\r\nif (edid)\r\namdgpu_connector->edid = edid;\r\n}\r\nreturn amdgpu_connector->edid;\r\n}\r\nstatic struct edid *\r\namdgpu_connector_get_hardcoded_edid(struct amdgpu_device *adev)\r\n{\r\nstruct edid *edid;\r\nif (adev->mode_info.bios_hardcoded_edid) {\r\nedid = kmalloc(adev->mode_info.bios_hardcoded_edid_size, GFP_KERNEL);\r\nif (edid) {\r\nmemcpy((unsigned char *)edid,\r\n(unsigned char *)adev->mode_info.bios_hardcoded_edid,\r\nadev->mode_info.bios_hardcoded_edid_size);\r\nreturn edid;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void amdgpu_connector_get_edid(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->edid)\r\nreturn;\r\nif (amdgpu_connector->router.ddc_valid)\r\namdgpu_i2c_router_select_ddc_port(amdgpu_connector);\r\nif ((amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) &&\r\namdgpu_connector->ddc_bus->has_aux) {\r\namdgpu_connector->edid = drm_get_edid(connector,\r\n&amdgpu_connector->ddc_bus->aux.ddc);\r\n} else if ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\r\nstruct amdgpu_connector_atom_dig *dig = amdgpu_connector->con_priv;\r\nif ((dig->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT ||\r\ndig->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) &&\r\namdgpu_connector->ddc_bus->has_aux)\r\namdgpu_connector->edid = drm_get_edid(connector,\r\n&amdgpu_connector->ddc_bus->aux.ddc);\r\nelse if (amdgpu_connector->ddc_bus)\r\namdgpu_connector->edid = drm_get_edid(connector,\r\n&amdgpu_connector->ddc_bus->adapter);\r\n} else if (amdgpu_connector->ddc_bus) {\r\namdgpu_connector->edid = drm_get_edid(connector,\r\n&amdgpu_connector->ddc_bus->adapter);\r\n}\r\nif (!amdgpu_connector->edid) {\r\nif (((connector->connector_type == DRM_MODE_CONNECTOR_LVDS) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_eDP)))\r\namdgpu_connector->edid = amdgpu_connector_get_hardcoded_edid(adev);\r\n}\r\n}\r\nstatic void amdgpu_connector_free_edid(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->edid) {\r\nkfree(amdgpu_connector->edid);\r\namdgpu_connector->edid = NULL;\r\n}\r\n}\r\nstatic int amdgpu_connector_ddc_get_modes(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nint ret;\r\nif (amdgpu_connector->edid) {\r\ndrm_mode_connector_update_edid_property(connector, amdgpu_connector->edid);\r\nret = drm_add_edid_modes(connector, amdgpu_connector->edid);\r\ndrm_edid_to_eld(connector, amdgpu_connector->edid);\r\nreturn ret;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *\r\namdgpu_connector_best_single_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void amdgpu_get_native_mode(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nif (encoder == NULL)\r\nreturn;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (!list_empty(&connector->probed_modes)) {\r\nstruct drm_display_mode *preferred_mode =\r\nlist_first_entry(&connector->probed_modes,\r\nstruct drm_display_mode, head);\r\namdgpu_encoder->native_mode = *preferred_mode;\r\n} else {\r\namdgpu_encoder->native_mode.clock = 0;\r\n}\r\n}\r\nstatic struct drm_display_mode *\r\namdgpu_connector_lcd_native_mode(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nif (native_mode->hdisplay != 0 &&\r\nnative_mode->vdisplay != 0 &&\r\nnative_mode->clock != 0) {\r\nmode = drm_mode_duplicate(dev, native_mode);\r\nmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\r\ndrm_mode_set_name(mode);\r\nDRM_DEBUG_KMS("Adding native panel mode %s\n", mode->name);\r\n} else if (native_mode->hdisplay != 0 &&\r\nnative_mode->vdisplay != 0) {\r\nmode = drm_cvt_mode(dev, native_mode->hdisplay, native_mode->vdisplay, 60, true, false, false);\r\nmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\r\nDRM_DEBUG_KMS("Adding cvt approximation of native panel mode %s\n", mode->name);\r\n}\r\nreturn mode;\r\n}\r\nstatic void amdgpu_connector_add_common_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *mode = NULL;\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nint i;\r\nstatic const struct mode_size {\r\nint w;\r\nint h;\r\n} common_modes[17] = {\r\n{ 640, 480},\r\n{ 720, 480},\r\n{ 800, 600},\r\n{ 848, 480},\r\n{1024, 768},\r\n{1152, 768},\r\n{1280, 720},\r\n{1280, 800},\r\n{1280, 854},\r\n{1280, 960},\r\n{1280, 1024},\r\n{1440, 900},\r\n{1400, 1050},\r\n{1680, 1050},\r\n{1600, 1200},\r\n{1920, 1080},\r\n{1920, 1200}\r\n};\r\nfor (i = 0; i < 17; i++) {\r\nif (amdgpu_encoder->devices & (ATOM_DEVICE_TV_SUPPORT)) {\r\nif (common_modes[i].w > 1024 ||\r\ncommon_modes[i].h > 768)\r\ncontinue;\r\n}\r\nif (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (common_modes[i].w > native_mode->hdisplay ||\r\ncommon_modes[i].h > native_mode->vdisplay ||\r\n(common_modes[i].w == native_mode->hdisplay &&\r\ncommon_modes[i].h == native_mode->vdisplay))\r\ncontinue;\r\n}\r\nif (common_modes[i].w < 320 || common_modes[i].h < 200)\r\ncontinue;\r\nmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\n}\r\nstatic int amdgpu_connector_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nif (property == adev->mode_info.coherent_mode_property) {\r\nstruct amdgpu_encoder_atom_dig *dig;\r\nbool new_coherent_mode;\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (!amdgpu_encoder->enc_priv)\r\nreturn 0;\r\ndig = amdgpu_encoder->enc_priv;\r\nnew_coherent_mode = val ? true : false;\r\nif (dig->coherent_mode != new_coherent_mode) {\r\ndig->coherent_mode = new_coherent_mode;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.audio_property) {\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_connector->audio != val) {\r\namdgpu_connector->audio = val;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.dither_property) {\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_connector->dither != val) {\r\namdgpu_connector->dither = val;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.underscan_property) {\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_encoder->underscan_type != val) {\r\namdgpu_encoder->underscan_type = val;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.underscan_hborder_property) {\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_encoder->underscan_hborder != val) {\r\namdgpu_encoder->underscan_hborder = val;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.underscan_vborder_property) {\r\nencoder = amdgpu_connector_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\r\nif (!encoder)\r\nreturn 0;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_encoder->underscan_vborder != val) {\r\namdgpu_encoder->underscan_vborder = val;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\n}\r\nif (property == adev->mode_info.load_detect_property) {\r\nstruct amdgpu_connector *amdgpu_connector =\r\nto_amdgpu_connector(connector);\r\nif (val == 0)\r\namdgpu_connector->dac_load_detect = false;\r\nelse\r\namdgpu_connector->dac_load_detect = true;\r\n}\r\nif (property == dev->mode_config.scaling_mode_property) {\r\nenum amdgpu_rmx_type rmx_type;\r\nif (connector->encoder) {\r\namdgpu_encoder = to_amdgpu_encoder(connector->encoder);\r\n} else {\r\nconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\namdgpu_encoder = to_amdgpu_encoder(connector_funcs->best_encoder(connector));\r\n}\r\nswitch (val) {\r\ndefault:\r\ncase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\r\ncase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\r\ncase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\r\ncase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\r\n}\r\nif (amdgpu_encoder->rmx_type == rmx_type)\r\nreturn 0;\r\nif ((rmx_type != DRM_MODE_SCALE_NONE) &&\r\n(amdgpu_encoder->native_mode.clock == 0))\r\nreturn 0;\r\namdgpu_encoder->rmx_type = rmx_type;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\namdgpu_connector_fixup_lcd_native_mode(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nstruct drm_display_mode *t, *mode;\r\nlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\r\nif (mode->type & DRM_MODE_TYPE_PREFERRED) {\r\nif (mode->hdisplay != native_mode->hdisplay ||\r\nmode->vdisplay != native_mode->vdisplay)\r\nmemcpy(native_mode, mode, sizeof(*mode));\r\n}\r\n}\r\nif (!native_mode->clock) {\r\nlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\r\nif (mode->hdisplay == native_mode->hdisplay &&\r\nmode->vdisplay == native_mode->vdisplay) {\r\n*native_mode = *mode;\r\ndrm_mode_set_crtcinfo(native_mode, CRTC_INTERLACE_HALVE_V);\r\nDRM_DEBUG_KMS("Determined LVDS native mode details from EDID\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!native_mode->clock) {\r\nDRM_DEBUG_KMS("No LVDS native mode details, disabling RMX\n");\r\namdgpu_encoder->rmx_type = RMX_OFF;\r\n}\r\n}\r\nstatic int amdgpu_connector_lvds_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nint ret = 0;\r\nstruct drm_display_mode *mode;\r\namdgpu_connector_get_edid(connector);\r\nret = amdgpu_connector_ddc_get_modes(connector);\r\nif (ret > 0) {\r\nencoder = amdgpu_connector_best_single_encoder(connector);\r\nif (encoder) {\r\namdgpu_connector_fixup_lcd_native_mode(encoder, connector);\r\namdgpu_connector_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nencoder = amdgpu_connector_best_single_encoder(connector);\r\nif (!encoder)\r\nreturn 0;\r\nmode = amdgpu_connector_lcd_native_mode(encoder);\r\nif (mode) {\r\nret = 1;\r\ndrm_mode_probed_add(connector, mode);\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\namdgpu_connector_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nstatic int amdgpu_connector_lvds_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\r\nreturn MODE_PANEL;\r\nif (encoder) {\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nif ((mode->hdisplay > native_mode->hdisplay) ||\r\n(mode->vdisplay > native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nif (amdgpu_encoder->rmx_type == RMX_OFF) {\r\nif ((mode->hdisplay != native_mode->hdisplay) ||\r\n(mode->vdisplay != native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\n}\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_connector_status\r\namdgpu_connector_lvds_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (encoder) {\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\r\nret = connector_status_connected;\r\n}\r\namdgpu_connector_get_edid(connector);\r\nif (amdgpu_connector->edid)\r\nret = connector_status_connected;\r\namdgpu_connector_update_scratch_regs(connector, ret);\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic void amdgpu_connector_unregister(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->ddc_bus && amdgpu_connector->ddc_bus->has_aux) {\r\ndrm_dp_aux_unregister(&amdgpu_connector->ddc_bus->aux);\r\namdgpu_connector->ddc_bus->has_aux = false;\r\n}\r\n}\r\nstatic void amdgpu_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\namdgpu_connector_free_edid(connector);\r\nkfree(amdgpu_connector->con_priv);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic int amdgpu_connector_set_lcd_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t value)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nenum amdgpu_rmx_type rmx_type;\r\nDRM_DEBUG_KMS("\n");\r\nif (property != dev->mode_config.scaling_mode_property)\r\nreturn 0;\r\nif (connector->encoder)\r\namdgpu_encoder = to_amdgpu_encoder(connector->encoder);\r\nelse {\r\nconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\r\namdgpu_encoder = to_amdgpu_encoder(connector_funcs->best_encoder(connector));\r\n}\r\nswitch (value) {\r\ncase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\r\ncase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\r\ncase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\r\ndefault:\r\ncase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\r\n}\r\nif (amdgpu_encoder->rmx_type == rmx_type)\r\nreturn 0;\r\namdgpu_encoder->rmx_type = rmx_type;\r\namdgpu_connector_property_change_mode(&amdgpu_encoder->base);\r\nreturn 0;\r\n}\r\nstatic int amdgpu_connector_vga_get_modes(struct drm_connector *connector)\r\n{\r\nint ret;\r\namdgpu_connector_get_edid(connector);\r\nret = amdgpu_connector_ddc_get_modes(connector);\r\nreturn ret;\r\n}\r\nstatic int amdgpu_connector_vga_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nif ((mode->clock / 10) > adev->clock.max_pixel_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic enum drm_connector_status\r\namdgpu_connector_vga_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct drm_encoder *encoder;\r\nconst struct drm_encoder_helper_funcs *encoder_funcs;\r\nbool dret = false;\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nencoder = amdgpu_connector_best_single_encoder(connector);\r\nif (!encoder)\r\nret = connector_status_disconnected;\r\nif (amdgpu_connector->ddc_bus)\r\ndret = amdgpu_ddc_probe(amdgpu_connector, false);\r\nif (dret) {\r\namdgpu_connector->detected_by_load = false;\r\namdgpu_connector_free_edid(connector);\r\namdgpu_connector_get_edid(connector);\r\nif (!amdgpu_connector->edid) {\r\nDRM_ERROR("%s: probed a monitor but no|invalid EDID\n",\r\nconnector->name);\r\nret = connector_status_connected;\r\n} else {\r\namdgpu_connector->use_digital =\r\n!!(amdgpu_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\r\nif (amdgpu_connector->use_digital && amdgpu_connector->shared_ddc) {\r\namdgpu_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n} else {\r\nret = connector_status_connected;\r\n}\r\n}\r\n} else {\r\nif (!force) {\r\nif (amdgpu_connector->detected_by_load)\r\nret = connector->status;\r\ngoto out;\r\n}\r\nif (amdgpu_connector->dac_load_detect && encoder) {\r\nencoder_funcs = encoder->helper_private;\r\nret = encoder_funcs->detect(encoder, connector);\r\nif (ret != connector_status_disconnected)\r\namdgpu_connector->detected_by_load = true;\r\n}\r\n}\r\namdgpu_connector_update_scratch_regs(connector, ret);\r\nout:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic bool\r\namdgpu_connector_check_hpd_status_unchanged(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nenum drm_connector_status status;\r\nif (amdgpu_connector->hpd.hpd != AMDGPU_HPD_NONE) {\r\nif (amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\nif (connector->status == status)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\namdgpu_connector_dvi_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct drm_encoder *encoder = NULL;\r\nconst struct drm_encoder_helper_funcs *encoder_funcs;\r\nint i, r;\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nbool dret = false, broken_edid = false;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (!force && amdgpu_connector_check_hpd_status_unchanged(connector)) {\r\nret = connector->status;\r\ngoto exit;\r\n}\r\nif (amdgpu_connector->ddc_bus)\r\ndret = amdgpu_ddc_probe(amdgpu_connector, false);\r\nif (dret) {\r\namdgpu_connector->detected_by_load = false;\r\namdgpu_connector_free_edid(connector);\r\namdgpu_connector_get_edid(connector);\r\nif (!amdgpu_connector->edid) {\r\nDRM_ERROR("%s: probed a monitor but no|invalid EDID\n",\r\nconnector->name);\r\nret = connector_status_connected;\r\nbroken_edid = true;\r\n} else {\r\namdgpu_connector->use_digital =\r\n!!(amdgpu_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\r\nif ((!amdgpu_connector->use_digital) && amdgpu_connector->shared_ddc) {\r\namdgpu_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n} else {\r\nret = connector_status_connected;\r\n}\r\nif (amdgpu_connector->shared_ddc && (ret == connector_status_connected)) {\r\nstruct drm_connector *list_connector;\r\nstruct amdgpu_connector *list_amdgpu_connector;\r\nlist_for_each_entry(list_connector, &dev->mode_config.connector_list, head) {\r\nif (connector == list_connector)\r\ncontinue;\r\nlist_amdgpu_connector = to_amdgpu_connector(list_connector);\r\nif (list_amdgpu_connector->shared_ddc &&\r\n(list_amdgpu_connector->ddc_bus->rec.i2c_id ==\r\namdgpu_connector->ddc_bus->rec.i2c_id)) {\r\nif (list_connector->connector_type != DRM_MODE_CONNECTOR_VGA) {\r\nif (!amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\r\namdgpu_connector_free_edid(connector);\r\nret = connector_status_disconnected;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif ((ret == connector_status_connected) && (amdgpu_connector->use_digital == true))\r\ngoto out;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_DVID) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))\r\ngoto out;\r\nif (!force) {\r\nif (amdgpu_connector->detected_by_load)\r\nret = connector->status;\r\ngoto out;\r\n}\r\nif (amdgpu_connector->dac_load_detect) {\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (encoder->encoder_type != DRM_MODE_ENCODER_DAC &&\r\nencoder->encoder_type != DRM_MODE_ENCODER_TVDAC)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->detect) {\r\nif (!broken_edid) {\r\nif (ret != connector_status_connected) {\r\nret = encoder_funcs->detect(encoder, connector);\r\nif (ret == connector_status_connected) {\r\namdgpu_connector->use_digital = false;\r\n}\r\nif (ret != connector_status_disconnected)\r\namdgpu_connector->detected_by_load = true;\r\n}\r\n} else {\r\nenum drm_connector_status lret;\r\namdgpu_connector->use_digital = true;\r\nlret = encoder_funcs->detect(encoder, connector);\r\nDRM_DEBUG_KMS("load_detect %x returned: %x\n",encoder->encoder_type,lret);\r\nif (lret == connector_status_connected)\r\namdgpu_connector->use_digital = false;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nout:\r\namdgpu_connector_update_scratch_regs(connector, ret);\r\nexit:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic struct drm_encoder *\r\namdgpu_connector_dvi_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct drm_encoder *encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev, connector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\nif (amdgpu_connector->use_digital == true) {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\r\nreturn encoder;\r\n} else {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_DAC ||\r\nencoder->encoder_type == DRM_MODE_ENCODER_TVDAC)\r\nreturn encoder;\r\n}\r\n}\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void amdgpu_connector_dvi_force(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (connector->force == DRM_FORCE_ON)\r\namdgpu_connector->use_digital = false;\r\nif (connector->force == DRM_FORCE_ON_DIGITAL)\r\namdgpu_connector->use_digital = true;\r\n}\r\nstatic int amdgpu_connector_dvi_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->use_digital && (mode->clock > 165000)) {\r\nif ((amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I) ||\r\n(amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D) ||\r\n(amdgpu_connector->connector_object_id == CONNECTOR_OBJECT_ID_HDMI_TYPE_B)) {\r\nreturn MODE_OK;\r\n} else if (drm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (mode->clock > 340000)\r\nreturn MODE_CLOCK_HIGH;\r\nelse\r\nreturn MODE_OK;\r\n} else {\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\n}\r\nif ((mode->clock / 10) > adev->clock.max_pixel_clock)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic int amdgpu_connector_dp_get_modes(struct drm_connector *connector)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nint ret;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nstruct drm_display_mode *mode;\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\r\nif (!amdgpu_dig_connector->edp_on)\r\namdgpu_atombios_encoder_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\namdgpu_connector_get_edid(connector);\r\nret = amdgpu_connector_ddc_get_modes(connector);\r\nif (!amdgpu_dig_connector->edp_on)\r\namdgpu_atombios_encoder_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_OFF);\r\n} else {\r\nif (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\nif (encoder)\r\namdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\r\n}\r\namdgpu_connector_get_edid(connector);\r\nret = amdgpu_connector_ddc_get_modes(connector);\r\n}\r\nif (ret > 0) {\r\nif (encoder) {\r\namdgpu_connector_fixup_lcd_native_mode(encoder, connector);\r\namdgpu_connector_add_common_modes(encoder, connector);\r\n}\r\nreturn ret;\r\n}\r\nif (!encoder)\r\nreturn 0;\r\nmode = amdgpu_connector_lcd_native_mode(encoder);\r\nif (mode) {\r\nret = 1;\r\ndrm_mode_probed_add(connector, mode);\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\namdgpu_connector_add_common_modes(encoder, connector);\r\n}\r\n} else {\r\nif (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\nif (encoder)\r\namdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\r\n}\r\namdgpu_connector_get_edid(connector);\r\nret = amdgpu_connector_ddc_get_modes(connector);\r\namdgpu_get_native_mode(connector);\r\n}\r\nreturn ret;\r\n}\r\nu16 amdgpu_connector_encoder_get_dp_bridge_encoder_id(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nint i;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nswitch (amdgpu_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_TRAVIS:\r\ncase ENCODER_OBJECT_ID_NUTMEG:\r\nreturn amdgpu_encoder->encoder_id;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn ENCODER_OBJECT_ID_NONE;\r\n}\r\nstatic bool amdgpu_connector_encoder_is_hbr2(struct drm_connector *connector)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nint i;\r\nbool found = false;\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nencoder = drm_encoder_find(connector->dev,\r\nconnector->encoder_ids[i]);\r\nif (!encoder)\r\ncontinue;\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_encoder->caps & ATOM_ENCODER_CAP_RECORD_HBR2)\r\nfound = true;\r\n}\r\nreturn found;\r\n}\r\nbool amdgpu_connector_is_dp12_capable(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nif ((adev->clock.default_dispclk >= 53900) &&\r\namdgpu_connector_encoder_is_hbr2(connector)) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status\r\namdgpu_connector_dp_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct amdgpu_device *adev = dev->dev_private;\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nenum drm_connector_status ret = connector_status_disconnected;\r\nstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nint r;\r\nr = pm_runtime_get_sync(connector->dev->dev);\r\nif (r < 0)\r\nreturn connector_status_disconnected;\r\nif (!force && amdgpu_connector_check_hpd_status_unchanged(connector)) {\r\nret = connector->status;\r\ngoto out;\r\n}\r\namdgpu_connector_free_edid(connector);\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nif (encoder) {\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\r\nret = connector_status_connected;\r\n}\r\namdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\r\nif (!amdgpu_dig_connector->edp_on)\r\namdgpu_atombios_encoder_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_ON);\r\nif (!amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\r\nret = connector_status_connected;\r\nif (!amdgpu_dig_connector->edp_on)\r\namdgpu_atombios_encoder_set_edp_panel_power(connector,\r\nATOM_TRANSMITTER_ACTION_POWER_OFF);\r\n} else if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) !=\r\nENCODER_OBJECT_ID_NONE) {\r\namdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\r\namdgpu_atombios_dp_get_dpcd(amdgpu_connector);\r\nif (encoder) {\r\namdgpu_atombios_encoder_setup_ext_encoder_ddc(encoder);\r\nif (amdgpu_ddc_probe(amdgpu_connector, true))\r\nret = connector_status_connected;\r\nelse if (amdgpu_connector->dac_load_detect) {\r\nconst struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nret = encoder_funcs->detect(encoder, connector);\r\n}\r\n}\r\n} else {\r\namdgpu_dig_connector->dp_sink_type =\r\namdgpu_atombios_dp_get_sinktype(amdgpu_connector);\r\nif (amdgpu_display_hpd_sense(adev, amdgpu_connector->hpd.hpd)) {\r\nret = connector_status_connected;\r\nif (amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)\r\namdgpu_atombios_dp_get_dpcd(amdgpu_connector);\r\n} else {\r\nif (amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\r\nif (!amdgpu_atombios_dp_get_dpcd(amdgpu_connector))\r\nret = connector_status_connected;\r\n} else {\r\nif (amdgpu_ddc_probe(amdgpu_connector, false))\r\nret = connector_status_connected;\r\n}\r\n}\r\n}\r\namdgpu_connector_update_scratch_regs(connector, ret);\r\nout:\r\npm_runtime_mark_last_busy(connector->dev->dev);\r\npm_runtime_put_autosuspend(connector->dev->dev);\r\nreturn ret;\r\n}\r\nstatic int amdgpu_connector_dp_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);\r\nstruct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;\r\nif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\r\n(connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\r\nstruct drm_encoder *encoder = amdgpu_connector_best_single_encoder(connector);\r\nif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\r\nreturn MODE_PANEL;\r\nif (encoder) {\r\nstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\r\nstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\r\nif ((mode->hdisplay > native_mode->hdisplay) ||\r\n(mode->vdisplay > native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\nif (amdgpu_encoder->rmx_type == RMX_OFF) {\r\nif ((mode->hdisplay != native_mode->hdisplay) ||\r\n(mode->vdisplay != native_mode->vdisplay))\r\nreturn MODE_PANEL;\r\n}\r\n}\r\nreturn MODE_OK;\r\n} else {\r\nif ((amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(amdgpu_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\r\nreturn amdgpu_atombios_dp_mode_valid_helper(connector, mode);\r\n} else {\r\nif (drm_detect_hdmi_monitor(amdgpu_connector_edid(connector))) {\r\nif (mode->clock > 340000)\r\nreturn MODE_CLOCK_HIGH;\r\n} else {\r\nif (mode->clock > 165000)\r\nreturn MODE_CLOCK_HIGH;\r\n}\r\n}\r\n}\r\nreturn MODE_OK;\r\n}\r\nvoid\r\namdgpu_connector_add(struct amdgpu_device *adev,\r\nuint32_t connector_id,\r\nuint32_t supported_device,\r\nint connector_type,\r\nstruct amdgpu_i2c_bus_rec *i2c_bus,\r\nuint16_t connector_object_id,\r\nstruct amdgpu_hpd *hpd,\r\nstruct amdgpu_router *router)\r\n{\r\nstruct drm_device *dev = adev->ddev;\r\nstruct drm_connector *connector;\r\nstruct amdgpu_connector *amdgpu_connector;\r\nstruct amdgpu_connector_atom_dig *amdgpu_dig_connector;\r\nstruct drm_encoder *encoder;\r\nstruct amdgpu_encoder *amdgpu_encoder;\r\nuint32_t subpixel_order = SubPixelNone;\r\nbool shared_ddc = false;\r\nbool is_dp_bridge = false;\r\nbool has_aux = false;\r\nif (connector_type == DRM_MODE_CONNECTOR_Unknown)\r\nreturn;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\namdgpu_connector = to_amdgpu_connector(connector);\r\nif (amdgpu_connector->connector_id == connector_id) {\r\namdgpu_connector->devices |= supported_device;\r\nreturn;\r\n}\r\nif (amdgpu_connector->ddc_bus && i2c_bus->valid) {\r\nif (amdgpu_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {\r\namdgpu_connector->shared_ddc = true;\r\nshared_ddc = true;\r\n}\r\nif (amdgpu_connector->router_bus && router->ddc_valid &&\r\n(amdgpu_connector->router.router_id == router->router_id)) {\r\namdgpu_connector->shared_ddc = false;\r\nshared_ddc = false;\r\n}\r\n}\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\namdgpu_encoder = to_amdgpu_encoder(encoder);\r\nif (amdgpu_encoder->devices & supported_device) {\r\nswitch (amdgpu_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_TRAVIS:\r\ncase ENCODER_OBJECT_ID_NUTMEG:\r\nis_dp_bridge = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\namdgpu_connector = kzalloc(sizeof(struct amdgpu_connector), GFP_KERNEL);\r\nif (!amdgpu_connector)\r\nreturn;\r\nconnector = &amdgpu_connector->base;\r\namdgpu_connector->connector_id = connector_id;\r\namdgpu_connector->devices = supported_device;\r\namdgpu_connector->shared_ddc = shared_ddc;\r\namdgpu_connector->connector_object_id = connector_object_id;\r\namdgpu_connector->hpd = *hpd;\r\namdgpu_connector->router = *router;\r\nif (router->ddc_valid || router->cd_valid) {\r\namdgpu_connector->router_bus = amdgpu_i2c_lookup(adev, &router->i2c_info);\r\nif (!amdgpu_connector->router_bus)\r\nDRM_ERROR("Failed to assign router i2c bus! Check dmesg for i2c errors.\n");\r\n}\r\nif (is_dp_bridge) {\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (amdgpu_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nswitch (connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ndefault:\r\ndrm_connector_init(dev, &amdgpu_connector->base,\r\n&amdgpu_connector_dp_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base,\r\n&amdgpu_connector_dp_helper_funcs);\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\namdgpu_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.load_detect_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ndrm_connector_init(dev, &amdgpu_connector->base,\r\n&amdgpu_connector_dp_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base,\r\n&amdgpu_connector_dp_helper_funcs);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.dither_property,\r\nAMDGPU_FMT_DITHER_DISABLE);\r\nif (amdgpu_audio != 0)\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.audio_property,\r\nAMDGPU_AUDIO_AUTO);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII) {\r\namdgpu_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.load_detect_property,\r\n1);\r\n}\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ndrm_connector_init(dev, &amdgpu_connector->base,\r\n&amdgpu_connector_edp_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base,\r\n&amdgpu_connector_dp_helper_funcs);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\n}\r\n} else {\r\nswitch (connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_vga_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_vga_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (!amdgpu_connector->ddc_bus)\r\nDRM_ERROR("VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\namdgpu_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.load_detect_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\namdgpu_connector->hpd.hpd = AMDGPU_HPD_NONE;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_vga_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_vga_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (!amdgpu_connector->ddc_bus)\r\nDRM_ERROR("DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\namdgpu_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.load_detect_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\namdgpu_connector->hpd.hpd = AMDGPU_HPD_NONE;\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = true;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_dvi_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dvi_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (!amdgpu_connector->ddc_bus)\r\nDRM_ERROR("DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.coherent_mode_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nif (amdgpu_audio != 0) {\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.audio_property,\r\nAMDGPU_AUDIO_AUTO);\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.dither_property,\r\nAMDGPU_FMT_DITHER_DISABLE);\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII) {\r\namdgpu_connector->dac_load_detect = true;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.load_detect_property,\r\n1);\r\n}\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_DVII)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_dvi_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dvi_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (!amdgpu_connector->ddc_bus)\r\nDRM_ERROR("HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.coherent_mode_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nif (amdgpu_audio != 0) {\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.audio_property,\r\nAMDGPU_AUDIO_AUTO);\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.dither_property,\r\nAMDGPU_FMT_DITHER_DISABLE);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = true;\r\nif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\r\nconnector->doublescan_allowed = true;\r\nelse\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_dp_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dp_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (amdgpu_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\nsubpixel_order = SubPixelHorizontalRGB;\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.coherent_mode_property,\r\n1);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_property,\r\nUNDERSCAN_OFF);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_hborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.underscan_vborder_property,\r\n0);\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_NONE);\r\nif (amdgpu_audio != 0) {\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.audio_property,\r\nAMDGPU_AUDIO_AUTO);\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\nadev->mode_info.dither_property,\r\nAMDGPU_FMT_DITHER_DISABLE);\r\nconnector->interlace_allowed = true;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_eDP:\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_edp_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_dp_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (amdgpu_connector->ddc_bus)\r\nhas_aux = true;\r\nelse\r\nDRM_ERROR("DP: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\namdgpu_dig_connector = kzalloc(sizeof(struct amdgpu_connector_atom_dig), GFP_KERNEL);\r\nif (!amdgpu_dig_connector)\r\ngoto failed;\r\namdgpu_connector->con_priv = amdgpu_dig_connector;\r\ndrm_connector_init(dev, &amdgpu_connector->base, &amdgpu_connector_lvds_funcs, connector_type);\r\ndrm_connector_helper_add(&amdgpu_connector->base, &amdgpu_connector_lvds_helper_funcs);\r\nif (i2c_bus->valid) {\r\namdgpu_connector->ddc_bus = amdgpu_i2c_lookup(adev, i2c_bus);\r\nif (!amdgpu_connector->ddc_bus)\r\nDRM_ERROR("LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\n");\r\n}\r\ndrm_object_attach_property(&amdgpu_connector->base.base,\r\ndev->mode_config.scaling_mode_property,\r\nDRM_MODE_SCALE_FULLSCREEN);\r\nsubpixel_order = SubPixelHorizontalRGB;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nbreak;\r\n}\r\n}\r\nif (amdgpu_connector->hpd.hpd == AMDGPU_HPD_NONE) {\r\nif (i2c_bus->valid) {\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\n}\r\n} else\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nconnector->display_info.subpixel_order = subpixel_order;\r\ndrm_connector_register(connector);\r\nif (has_aux)\r\namdgpu_atombios_dp_aux_init(amdgpu_connector);\r\nreturn;\r\nfailed:\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}
