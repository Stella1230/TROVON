static inline unsigned long\r\nfind_pa(unsigned long address)\r\n{\r\nunsigned long result;\r\nresult = VPTB[address >> 13];\r\nresult >>= 32;\r\nresult <<= 13;\r\nresult |= address & 0x1fff;\r\nreturn result;\r\n}\r\nint\r\ncheck_range(unsigned long vstart, unsigned long vend,\r\nunsigned long kstart, unsigned long kend)\r\n{\r\nunsigned long vaddr, kaddr;\r\n#ifdef DEBUG_CHECK_RANGE\r\nsrm_printk("check_range: V[0x%lx:0x%lx] K[0x%lx:0x%lx]\n",\r\nvstart, vend, kstart, kend);\r\n#endif\r\nfor (vaddr = vstart; vaddr <= vend; vaddr += PAGE_SIZE)\r\n{\r\nkaddr = (find_pa(vaddr) | PAGE_OFFSET);\r\nif (kaddr >= kstart && kaddr <= kend)\r\n{\r\n#ifdef DEBUG_CHECK_RANGE\r\nsrm_printk("OVERLAP: vaddr 0x%lx kaddr 0x%lx"\r\n" [0x%lx:0x%lx]\n",\r\nvaddr, kaddr, kstart, kend);\r\n#endif\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\npal_init(void)\r\n{\r\nunsigned long i, rev;\r\nstruct percpu_struct * percpu;\r\nstruct pcb_struct * pcb_pa;\r\npcb_va->ksp = 0;\r\npcb_va->usp = 0;\r\npcb_va->ptbr = L1[1] >> 32;\r\npcb_va->asn = 0;\r\npcb_va->pcc = 0;\r\npcb_va->unique = 0;\r\npcb_va->flags = 1;\r\npcb_va->res1 = 0;\r\npcb_va->res2 = 0;\r\npcb_pa = (struct pcb_struct *)find_pa((unsigned long)pcb_va);\r\nsrm_printk("Switching to OSF PAL-code... ");\r\ni = switch_to_osf_pal(2, pcb_va, pcb_pa, VPTB);\r\nif (i) {\r\nsrm_printk("failed, code %ld\n", i);\r\n__halt();\r\n}\r\npercpu = (struct percpu_struct *)\r\n(INIT_HWRPB->processor_offset + (unsigned long) INIT_HWRPB);\r\nrev = percpu->pal_revision = percpu->palcode_avail[2];\r\nsrm_printk("OK (rev %lx)\n", rev);\r\ntbia();\r\n}\r\nstatic inline void\r\nrunkernel(void)\r\n{\r\n__asm__ __volatile__(\r\n"bis %0,%0,$27\n\t"\r\n"jmp ($27)"\r\n:\r\n: "r" (START_ADDR));\r\n}\r\nvoid\r\nstart_kernel(void)\r\n{\r\nint must_move = 0;\r\nunsigned long uncompressed_image_start = K_KERNEL_IMAGE_START;\r\nunsigned long uncompressed_image_end = K_KERNEL_IMAGE_END;\r\nunsigned long initrd_image_start = K_INITRD_START;\r\nstatic long nbytes;\r\nstatic char envval[256] __attribute__((aligned(8)));\r\nregister unsigned long asm_sp asm("30");\r\nSP_on_entry = asm_sp;\r\nsrm_printk("Linux/Alpha BOOTPZ Loader for Linux " UTS_RELEASE "\n");\r\nif (INIT_HWRPB->pagesize != 8192) {\r\nsrm_printk("Expected 8kB pages, got %ldkB\n",\r\nINIT_HWRPB->pagesize >> 10);\r\nreturn;\r\n}\r\nif (INIT_HWRPB->vptb != (unsigned long) VPTB) {\r\nsrm_printk("Expected vptb at %p, got %p\n",\r\nVPTB, (void *)INIT_HWRPB->vptb);\r\nreturn;\r\n}\r\npal_init();\r\nnbytes = callback_getenv(ENV_BOOTED_OSFLAGS, envval, sizeof(envval));\r\nif (nbytes < 0 || nbytes >= sizeof(envval)) {\r\nnbytes = 0;\r\n}\r\nenvval[nbytes] = '\0';\r\n#ifdef DEBUG_ADDRESSES\r\nsrm_printk("START_ADDR 0x%lx\n", START_ADDR);\r\nsrm_printk("KERNEL_ORIGIN 0x%lx\n", KERNEL_ORIGIN);\r\nsrm_printk("KERNEL_SIZE 0x%x\n", KERNEL_SIZE);\r\nsrm_printk("KERNEL_Z_SIZE 0x%x\n", KERNEL_Z_SIZE);\r\n#endif\r\nif (check_range(V_BOOTSTRAPPER_START, V_BOOTSTRAPPER_END,\r\nK_KERNEL_DATA_START, K_KERNEL_IMAGE_END))\r\n{\r\nsrm_printk("FATAL ERROR: overlap of bootstrapper code\n");\r\n__halt();\r\n}\r\nif (check_range(V_DATA_START, V_DATA_END,\r\nK_KERNEL_IMAGE_START, K_COPY_IMAGE_END))\r\n{\r\n#ifdef DEBUG_ADDRESSES\r\nsrm_printk("OVERLAP: cannot decompress in place\n");\r\n#endif\r\nuncompressed_image_start = K_COPY_IMAGE_START;\r\nuncompressed_image_end = K_COPY_IMAGE_END;\r\nmust_move = 1;\r\nwhile (check_range(V_DATA_START, V_DATA_END,\r\nuncompressed_image_start,\r\nuncompressed_image_end))\r\n{\r\n#if 0\r\nuncompressed_image_start += K_COPY_IMAGE_SIZE;\r\nuncompressed_image_end += K_COPY_IMAGE_SIZE;\r\ninitrd_image_start += K_COPY_IMAGE_SIZE;\r\n#else\r\nuncompressed_image_start += PAGE_SIZE;\r\nuncompressed_image_end += PAGE_SIZE;\r\ninitrd_image_start += PAGE_SIZE;\r\n#endif\r\n}\r\n}\r\nsrm_printk("Starting to load the kernel with args '%s'\n", envval);\r\n#ifdef DEBUG_ADDRESSES\r\nsrm_printk("Decompressing the kernel...\n"\r\n"...from 0x%lx to 0x%lx size 0x%x\n",\r\nV_DATA_START,\r\nuncompressed_image_start,\r\nKERNEL_SIZE);\r\n#endif\r\ndecompress_kernel((void *)uncompressed_image_start,\r\n(void *)V_DATA_START,\r\nKERNEL_SIZE, KERNEL_Z_SIZE);\r\n#ifdef INITRD_IMAGE_SIZE\r\n#ifdef DEBUG_ADDRESSES\r\nsrm_printk("Moving the INITRD image...\n"\r\n" from 0x%lx to 0x%lx size 0x%x\n",\r\nV_INITRD_START,\r\ninitrd_image_start,\r\nINITRD_IMAGE_SIZE);\r\n#endif\r\nmemcpy((void *)initrd_image_start, (void *)V_INITRD_START,\r\nINITRD_IMAGE_SIZE);\r\n#endif\r\nif (must_move) {\r\n#ifdef DEBUG_ADDRESSES\r\nsrm_printk("Moving the uncompressed kernel...\n"\r\n"...from 0x%lx to 0x%lx size 0x%x\n",\r\nuncompressed_image_start,\r\nK_KERNEL_IMAGE_START,\r\n(unsigned)KERNEL_SIZE);\r\n#endif\r\nmove_stack(initrd_image_start - PAGE_SIZE);\r\nmemcpy((void *)K_KERNEL_IMAGE_START,\r\n(void *)uncompressed_image_start, KERNEL_SIZE);\r\n}\r\n#ifdef DEBUG_LAST_STEPS\r\nsrm_printk("Preparing ZERO_PGE...\n");\r\n#endif\r\nmemset((char*)ZERO_PGE, 0, PAGE_SIZE);\r\nstrcpy((char*)ZERO_PGE, envval);\r\n#ifdef INITRD_IMAGE_SIZE\r\n#ifdef DEBUG_LAST_STEPS\r\nsrm_printk("Preparing INITRD info...\n");\r\n#endif\r\n((long *)(ZERO_PGE+256))[0] = initrd_image_start;\r\n((long *)(ZERO_PGE+256))[1] = INITRD_IMAGE_SIZE;\r\n#endif\r\n#ifdef DEBUG_LAST_STEPS\r\nsrm_printk("Doing 'runkernel()'...\n");\r\n#endif\r\nrunkernel();\r\n}\r\nvoid *__kmalloc(size_t size, gfp_t flags)\r\n{\r\nreturn (void *)NULL;\r\n}
