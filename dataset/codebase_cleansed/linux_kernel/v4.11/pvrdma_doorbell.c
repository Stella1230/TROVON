int pvrdma_uar_table_init(struct pvrdma_dev *dev)\r\n{\r\nu32 num = dev->dsr->caps.max_uar;\r\nu32 mask = num - 1;\r\nstruct pvrdma_id_table *tbl = &dev->uar_table.tbl;\r\nif (!is_power_of_2(num))\r\nreturn -EINVAL;\r\ntbl->last = 0;\r\ntbl->top = 0;\r\ntbl->max = num;\r\ntbl->mask = mask;\r\nspin_lock_init(&tbl->lock);\r\ntbl->table = kcalloc(BITS_TO_LONGS(num), sizeof(long), GFP_KERNEL);\r\nif (!tbl->table)\r\nreturn -ENOMEM;\r\nset_bit(0, tbl->table);\r\nreturn 0;\r\n}\r\nvoid pvrdma_uar_table_cleanup(struct pvrdma_dev *dev)\r\n{\r\nstruct pvrdma_id_table *tbl = &dev->uar_table.tbl;\r\nkfree(tbl->table);\r\n}\r\nint pvrdma_uar_alloc(struct pvrdma_dev *dev, struct pvrdma_uar_map *uar)\r\n{\r\nstruct pvrdma_id_table *tbl;\r\nunsigned long flags;\r\nu32 obj;\r\ntbl = &dev->uar_table.tbl;\r\nspin_lock_irqsave(&tbl->lock, flags);\r\nobj = find_next_zero_bit(tbl->table, tbl->max, tbl->last);\r\nif (obj >= tbl->max) {\r\ntbl->top = (tbl->top + tbl->max) & tbl->mask;\r\nobj = find_first_zero_bit(tbl->table, tbl->max);\r\n}\r\nif (obj >= tbl->max) {\r\nspin_unlock_irqrestore(&tbl->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nset_bit(obj, tbl->table);\r\nobj |= tbl->top;\r\nspin_unlock_irqrestore(&tbl->lock, flags);\r\nuar->index = obj;\r\nuar->pfn = (pci_resource_start(dev->pdev, PVRDMA_PCI_RESOURCE_UAR) >>\r\nPAGE_SHIFT) + uar->index;\r\nreturn 0;\r\n}\r\nvoid pvrdma_uar_free(struct pvrdma_dev *dev, struct pvrdma_uar_map *uar)\r\n{\r\nstruct pvrdma_id_table *tbl = &dev->uar_table.tbl;\r\nunsigned long flags;\r\nu32 obj;\r\nobj = uar->index & (tbl->max - 1);\r\nspin_lock_irqsave(&tbl->lock, flags);\r\nclear_bit(obj, tbl->table);\r\ntbl->last = min(tbl->last, obj);\r\ntbl->top = (tbl->top + tbl->max) & tbl->mask;\r\nspin_unlock_irqrestore(&tbl->lock, flags);\r\n}
