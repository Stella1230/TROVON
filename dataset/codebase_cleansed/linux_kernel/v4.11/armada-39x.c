static u32 __init armada_39x_get_tclk_freq(void __iomem *sar)\r\n{\r\nu8 tclk_freq_select;\r\ntclk_freq_select = ((readl(sar + SARL) >> SARL_A390_TCLK_FREQ_OPT) &\r\nSARL_A390_TCLK_FREQ_OPT_MASK);\r\nreturn armada_39x_tclk_frequencies[tclk_freq_select];\r\n}\r\nstatic u32 __init armada_39x_get_cpu_freq(void __iomem *sar)\r\n{\r\nu8 cpu_freq_select;\r\ncpu_freq_select = ((readl(sar + SARL) >> SARL_A390_CPU_DDR_L2_FREQ_OPT) &\r\nSARL_A390_CPU_DDR_L2_FREQ_OPT_MASK);\r\nif (cpu_freq_select >= ARRAY_SIZE(armada_39x_cpu_frequencies)) {\r\npr_err("Selected CPU frequency (%d) unsupported\n",\r\ncpu_freq_select);\r\nreturn 0;\r\n}\r\nreturn armada_39x_cpu_frequencies[cpu_freq_select];\r\n}\r\nstatic void __init armada_39x_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase A390_CPU_TO_NBCLK:\r\n*mult = 1;\r\n*div = 2;\r\nbreak;\r\ncase A390_CPU_TO_HCLK:\r\n*mult = 1;\r\n*div = 4;\r\nbreak;\r\ncase A390_CPU_TO_DCLK:\r\n*mult = 1;\r\n*div = 2;\r\nbreak;\r\n}\r\n}\r\nstatic u32 __init armada_39x_refclk_ratio(void __iomem *sar)\r\n{\r\nif (readl(sar + SARH) & SARH_A390_REFCLK_FREQ)\r\nreturn 40 * 1000 * 1000;\r\nelse\r\nreturn 25 * 1000 * 1000;\r\n}\r\nstatic void __init armada_39x_coreclk_init(struct device_node *np)\r\n{\r\nmvebu_coreclk_setup(np, &armada_39x_coreclks);\r\n}\r\nstatic void __init armada_39x_clk_gating_init(struct device_node *np)\r\n{\r\nmvebu_clk_gating_setup(np, armada_39x_gating_desc);\r\n}
