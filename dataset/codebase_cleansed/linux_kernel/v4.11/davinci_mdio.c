static void davinci_mdio_init_clk(struct davinci_mdio_data *data)\r\n{\r\nu32 mdio_in, div, mdio_out_khz, access_time;\r\nmdio_in = clk_get_rate(data->clk);\r\ndiv = (mdio_in / data->pdata.bus_freq) - 1;\r\nif (div > CONTROL_MAX_DIV)\r\ndiv = CONTROL_MAX_DIV;\r\ndata->clk_div = div;\r\nmdio_out_khz = mdio_in / (1000 * (div + 1));\r\naccess_time = (88 * 1000) / mdio_out_khz;\r\ndata->access_time = usecs_to_jiffies(access_time * 4);\r\nif (!data->access_time)\r\ndata->access_time = 1;\r\n}\r\nstatic void davinci_mdio_enable(struct davinci_mdio_data *data)\r\n{\r\n__raw_writel(data->clk_div | CONTROL_ENABLE, &data->regs->control);\r\n}\r\nstatic int davinci_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 phy_mask, ver;\r\nint ret;\r\nret = pm_runtime_get_sync(data->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(data->dev);\r\nreturn ret;\r\n}\r\nmsleep(PHY_MAX_ADDR * data->access_time);\r\nver = __raw_readl(&data->regs->version);\r\ndev_info(data->dev, "davinci mdio revision %d.%d\n",\r\n(ver >> 8) & 0xff, ver & 0xff);\r\nif (data->skip_scan)\r\ngoto done;\r\nphy_mask = __raw_readl(&data->regs->alive);\r\nif (phy_mask) {\r\ndev_info(data->dev, "detected phy mask %x\n", ~phy_mask);\r\nphy_mask = ~phy_mask;\r\n} else {\r\ndev_warn(data->dev, "no live phy, scanning all\n");\r\nphy_mask = 0;\r\n}\r\ndata->bus->phy_mask = phy_mask;\r\ndone:\r\npm_runtime_mark_last_busy(data->dev);\r\npm_runtime_put_autosuspend(data->dev);\r\nreturn 0;\r\n}\r\nstatic inline int wait_for_user_access(struct davinci_mdio_data *data)\r\n{\r\nstruct davinci_mdio_regs __iomem *regs = data->regs;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);\r\nu32 reg;\r\nwhile (time_after(timeout, jiffies)) {\r\nreg = __raw_readl(&regs->user[0].access);\r\nif ((reg & USERACCESS_GO) == 0)\r\nreturn 0;\r\nreg = __raw_readl(&regs->control);\r\nif ((reg & CONTROL_IDLE) == 0)\r\ncontinue;\r\ndev_warn(data->dev, "resetting idled controller\n");\r\ndavinci_mdio_enable(data);\r\nreturn -EAGAIN;\r\n}\r\nreg = __raw_readl(&regs->user[0].access);\r\nif ((reg & USERACCESS_GO) == 0)\r\nreturn 0;\r\ndev_err(data->dev, "timed out waiting for user access\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int wait_for_idle(struct davinci_mdio_data *data)\r\n{\r\nstruct davinci_mdio_regs __iomem *regs = data->regs;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);\r\nwhile (time_after(timeout, jiffies)) {\r\nif (__raw_readl(&regs->control) & CONTROL_IDLE)\r\nreturn 0;\r\n}\r\ndev_err(data->dev, "timed out waiting for idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int davinci_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 reg;\r\nint ret;\r\nif (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)\r\nreturn -EINVAL;\r\nret = pm_runtime_get_sync(data->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(data->dev);\r\nreturn ret;\r\n}\r\nreg = (USERACCESS_GO | USERACCESS_READ | (phy_reg << 21) |\r\n(phy_id << 16));\r\nwhile (1) {\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\n__raw_writel(reg, &data->regs->user[0].access);\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\nreg = __raw_readl(&data->regs->user[0].access);\r\nret = (reg & USERACCESS_ACK) ? (reg & USERACCESS_DATA) : -EIO;\r\nbreak;\r\n}\r\npm_runtime_mark_last_busy(data->dev);\r\npm_runtime_put_autosuspend(data->dev);\r\nreturn ret;\r\n}\r\nstatic int davinci_mdio_write(struct mii_bus *bus, int phy_id,\r\nint phy_reg, u16 phy_data)\r\n{\r\nstruct davinci_mdio_data *data = bus->priv;\r\nu32 reg;\r\nint ret;\r\nif (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)\r\nreturn -EINVAL;\r\nret = pm_runtime_get_sync(data->dev);\r\nif (ret < 0) {\r\npm_runtime_put_noidle(data->dev);\r\nreturn ret;\r\n}\r\nreg = (USERACCESS_GO | USERACCESS_WRITE | (phy_reg << 21) |\r\n(phy_id << 16) | (phy_data & USERACCESS_DATA));\r\nwhile (1) {\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nif (ret < 0)\r\nbreak;\r\n__raw_writel(reg, &data->regs->user[0].access);\r\nret = wait_for_user_access(data);\r\nif (ret == -EAGAIN)\r\ncontinue;\r\nbreak;\r\n}\r\npm_runtime_mark_last_busy(data->dev);\r\npm_runtime_put_autosuspend(data->dev);\r\nreturn ret;\r\n}\r\nstatic int davinci_mdio_probe_dt(struct mdio_platform_data *data,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nu32 prop;\r\nif (!node)\r\nreturn -EINVAL;\r\nif (of_property_read_u32(node, "bus_freq", &prop)) {\r\ndev_err(&pdev->dev, "Missing bus_freq property in the DT.\n");\r\nreturn -EINVAL;\r\n}\r\ndata->bus_freq = prop;\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct mdio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct davinci_mdio_data *data;\r\nstruct resource *res;\r\nstruct phy_device *phy;\r\nint ret, addr;\r\nint autosuspend_delay_ms = -1;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->bus = devm_mdiobus_alloc(dev);\r\nif (!data->bus) {\r\ndev_err(dev, "failed to alloc mii bus\n");\r\nreturn -ENOMEM;\r\n}\r\nif (dev->of_node) {\r\nconst struct of_device_id *of_id;\r\nret = davinci_mdio_probe_dt(&data->pdata, pdev);\r\nif (ret)\r\nreturn ret;\r\nsnprintf(data->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);\r\nof_id = of_match_device(davinci_mdio_of_mtable, &pdev->dev);\r\nif (of_id) {\r\nconst struct davinci_mdio_of_param *of_mdio_data;\r\nof_mdio_data = of_id->data;\r\nif (of_mdio_data)\r\nautosuspend_delay_ms =\r\nof_mdio_data->autosuspend_delay_ms;\r\n}\r\n} else {\r\ndata->pdata = pdata ? (*pdata) : default_pdata;\r\nsnprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, pdev->id);\r\n}\r\ndata->bus->name = dev_name(dev);\r\ndata->bus->read = davinci_mdio_read,\r\ndata->bus->write = davinci_mdio_write,\r\ndata->bus->reset = davinci_mdio_reset,\r\ndata->bus->parent = dev;\r\ndata->bus->priv = data;\r\ndata->clk = devm_clk_get(dev, "fck");\r\nif (IS_ERR(data->clk)) {\r\ndev_err(dev, "failed to get device clock\n");\r\nreturn PTR_ERR(data->clk);\r\n}\r\ndev_set_drvdata(dev, data);\r\ndata->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(data->regs))\r\nreturn PTR_ERR(data->regs);\r\ndavinci_mdio_init_clk(data);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, autosuspend_delay_ms);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nif (dev->of_node && of_get_child_count(dev->of_node)) {\r\ndata->skip_scan = true;\r\nret = of_mdiobus_register(data->bus, dev->of_node);\r\n} else {\r\nret = mdiobus_register(data->bus);\r\n}\r\nif (ret)\r\ngoto bail_out;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nphy = mdiobus_get_phy(data->bus, addr);\r\nif (phy) {\r\ndev_info(dev, "phy[%d]: device %s, driver %s\n",\r\nphy->mdio.addr, phydev_name(phy),\r\nphy->drv ? phy->drv->name : "unknown");\r\n}\r\n}\r\nreturn 0;\r\nbail_out:\r\npm_runtime_dont_use_autosuspend(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int davinci_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_mdio_data *data = platform_get_drvdata(pdev);\r\nif (data->bus)\r\nmdiobus_unregister(data->bus);\r\npm_runtime_dont_use_autosuspend(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_runtime_suspend(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\nu32 ctrl;\r\nctrl = __raw_readl(&data->regs->control);\r\nctrl &= ~CONTROL_ENABLE;\r\n__raw_writel(ctrl, &data->regs->control);\r\nwait_for_idle(data);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_runtime_resume(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\ndavinci_mdio_enable(data);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_suspend(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\nint ret = 0;\r\ndata->active_in_suspend = !pm_runtime_status_suspended(dev);\r\nif (data->active_in_suspend)\r\nret = pm_runtime_force_suspend(dev);\r\nif (ret < 0)\r\nreturn ret;\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int davinci_mdio_resume(struct device *dev)\r\n{\r\nstruct davinci_mdio_data *data = dev_get_drvdata(dev);\r\npinctrl_pm_select_default_state(dev);\r\nif (data->active_in_suspend)\r\npm_runtime_force_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_mdio_init(void)\r\n{\r\nreturn platform_driver_register(&davinci_mdio_driver);\r\n}\r\nstatic void __exit davinci_mdio_exit(void)\r\n{\r\nplatform_driver_unregister(&davinci_mdio_driver);\r\n}
