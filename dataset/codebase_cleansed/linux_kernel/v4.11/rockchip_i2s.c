static int i2s_runtime_suspend(struct device *dev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\r\nregcache_cache_only(i2s->regmap, true);\r\nclk_disable_unprepare(i2s->mclk);\r\nreturn 0;\r\n}\r\nstatic int i2s_runtime_resume(struct device *dev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2s->mclk);\r\nif (ret) {\r\ndev_err(i2s->dev, "clock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(i2s->regmap, false);\r\nregcache_mark_dirty(i2s->regmap);\r\nret = regcache_sync(i2s->regmap);\r\nif (ret)\r\nclk_disable_unprepare(i2s->mclk);\r\nreturn ret;\r\n}\r\nstatic inline struct rk_i2s_dev *to_info(struct snd_soc_dai *dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(dai);\r\n}\r\nstatic void rockchip_snd_txctrl(struct rk_i2s_dev *i2s, int on)\r\n{\r\nunsigned int val = 0;\r\nint retry = 10;\r\nif (on) {\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_ENABLE);\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START);\r\ni2s->tx_start = true;\r\n} else {\r\ni2s->tx_start = false;\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_TDE_ENABLE, I2S_DMACR_TDE_DISABLE);\r\nif (!i2s->rx_start) {\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START |\r\nI2S_XFER_RXS_START,\r\nI2S_XFER_TXS_STOP |\r\nI2S_XFER_RXS_STOP);\r\nregmap_update_bits(i2s->regmap, I2S_CLR,\r\nI2S_CLR_TXC | I2S_CLR_RXC,\r\nI2S_CLR_TXC | I2S_CLR_RXC);\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nwhile (val) {\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nretry--;\r\nif (!retry) {\r\ndev_warn(i2s->dev, "fail to clear\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void rockchip_snd_rxctrl(struct rk_i2s_dev *i2s, int on)\r\n{\r\nunsigned int val = 0;\r\nint retry = 10;\r\nif (on) {\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_ENABLE);\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START,\r\nI2S_XFER_TXS_START | I2S_XFER_RXS_START);\r\ni2s->rx_start = true;\r\n} else {\r\ni2s->rx_start = false;\r\nregmap_update_bits(i2s->regmap, I2S_DMACR,\r\nI2S_DMACR_RDE_ENABLE, I2S_DMACR_RDE_DISABLE);\r\nif (!i2s->tx_start) {\r\nregmap_update_bits(i2s->regmap, I2S_XFER,\r\nI2S_XFER_TXS_START |\r\nI2S_XFER_RXS_START,\r\nI2S_XFER_TXS_STOP |\r\nI2S_XFER_RXS_STOP);\r\nregmap_update_bits(i2s->regmap, I2S_CLR,\r\nI2S_CLR_TXC | I2S_CLR_RXC,\r\nI2S_CLR_TXC | I2S_CLR_RXC);\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nwhile (val) {\r\nregmap_read(i2s->regmap, I2S_CLR, &val);\r\nretry--;\r\nif (!retry) {\r\ndev_warn(i2s->dev, "fail to clear\n");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int rockchip_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(cpu_dai);\r\nunsigned int mask = 0, val = 0;\r\nmask = I2S_CKR_MSS_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval = I2S_CKR_MSS_MASTER;\r\ni2s->is_master_mode = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nval = I2S_CKR_MSS_SLAVE;\r\ni2s->is_master_mode = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_CKR, mask, val);\r\nmask = I2S_TXCR_IBM_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = I2S_TXCR_IBM_RSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = I2S_TXCR_IBM_LSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = I2S_TXCR_IBM_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_TXCR, mask, val);\r\nmask = I2S_RXCR_IBM_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nval = I2S_RXCR_IBM_RSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval = I2S_RXCR_IBM_LSJM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval = I2S_RXCR_IBM_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_RXCR, mask, val);\r\nreturn 0;\r\n}\r\nstatic int rockchip_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(dai);\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nunsigned int val = 0;\r\nunsigned int mclk_rate, bclk_rate, div_bclk, div_lrck;\r\nif (i2s->is_master_mode) {\r\nmclk_rate = clk_get_rate(i2s->mclk);\r\nbclk_rate = 2 * 32 * params_rate(params);\r\nif (bclk_rate && mclk_rate % bclk_rate)\r\nreturn -EINVAL;\r\ndiv_bclk = mclk_rate / bclk_rate;\r\ndiv_lrck = bclk_rate / params_rate(params);\r\nregmap_update_bits(i2s->regmap, I2S_CKR,\r\nI2S_CKR_MDIV_MASK,\r\nI2S_CKR_MDIV(div_bclk));\r\nregmap_update_bits(i2s->regmap, I2S_CKR,\r\nI2S_CKR_TSD_MASK |\r\nI2S_CKR_RSD_MASK,\r\nI2S_CKR_TSD(div_lrck) |\r\nI2S_CKR_RSD(div_lrck));\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nval |= I2S_TXCR_VDW(8);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval |= I2S_TXCR_VDW(16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval |= I2S_TXCR_VDW(20);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval |= I2S_TXCR_VDW(24);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nval |= I2S_TXCR_VDW(32);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_channels(params)) {\r\ncase 8:\r\nval |= I2S_CHN_8;\r\nbreak;\r\ncase 6:\r\nval |= I2S_CHN_6;\r\nbreak;\r\ncase 4:\r\nval |= I2S_CHN_4;\r\nbreak;\r\ncase 2:\r\nval |= I2S_CHN_2;\r\nbreak;\r\ndefault:\r\ndev_err(i2s->dev, "invalid channel: %d\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nregmap_update_bits(i2s->regmap, I2S_RXCR,\r\nI2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,\r\nval);\r\nelse\r\nregmap_update_bits(i2s->regmap, I2S_TXCR,\r\nI2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,\r\nval);\r\nif (!IS_ERR(i2s->grf) && i2s->pins) {\r\nregmap_read(i2s->regmap, I2S_TXCR, &val);\r\nval &= I2S_TXCR_CSR_MASK;\r\nswitch (val) {\r\ncase I2S_CHN_4:\r\nval = I2S_IO_4CH_OUT_6CH_IN;\r\nbreak;\r\ncase I2S_CHN_6:\r\nval = I2S_IO_6CH_OUT_4CH_IN;\r\nbreak;\r\ncase I2S_CHN_8:\r\nval = I2S_IO_8CH_OUT_2CH_IN;\r\nbreak;\r\ndefault:\r\nval = I2S_IO_2CH_OUT_8CH_IN;\r\nbreak;\r\n}\r\nval <<= i2s->pins->shift;\r\nval |= (I2S_IO_DIRECTION_MASK << i2s->pins->shift) << 16;\r\nregmap_write(i2s->grf, i2s->pins->reg_offset, val);\r\n}\r\nregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,\r\nI2S_DMACR_TDL(16));\r\nregmap_update_bits(i2s->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,\r\nI2S_DMACR_RDL(16));\r\nval = I2S_CKR_TRCM_TXRX;\r\nif (dai->driver->symmetric_rates && rtd->dai_link->symmetric_rates)\r\nval = I2S_CKR_TRCM_TXONLY;\r\nregmap_update_bits(i2s->regmap, I2S_CKR,\r\nI2S_CKR_TRCM_MASK,\r\nval);\r\nreturn 0;\r\n}\r\nstatic int rockchip_i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrockchip_snd_rxctrl(i2s, 1);\r\nelse\r\nrockchip_snd_txctrl(i2s, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrockchip_snd_rxctrl(i2s, 0);\r\nelse\r\nrockchip_snd_txctrl(i2s, 0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct rk_i2s_dev *i2s = to_info(cpu_dai);\r\nint ret;\r\nret = clk_set_rate(i2s->mclk, freq);\r\nif (ret)\r\ndev_err(i2s->dev, "Fail to set mclk %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct rk_i2s_dev *i2s = snd_soc_dai_get_drvdata(dai);\r\ndai->capture_dma_data = &i2s->capture_dma_data;\r\ndai->playback_dma_data = &i2s->playback_dma_data;\r\nreturn 0;\r\n}\r\nstatic bool rockchip_i2s_wr_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_TXCR:\r\ncase I2S_RXCR:\r\ncase I2S_CKR:\r\ncase I2S_DMACR:\r\ncase I2S_INTCR:\r\ncase I2S_XFER:\r\ncase I2S_CLR:\r\ncase I2S_TXDR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_rd_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_TXCR:\r\ncase I2S_RXCR:\r\ncase I2S_CKR:\r\ncase I2S_DMACR:\r\ncase I2S_INTCR:\r\ncase I2S_XFER:\r\ncase I2S_CLR:\r\ncase I2S_RXDR:\r\ncase I2S_FIFOLR:\r\ncase I2S_INTSR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase I2S_INTSR:\r\ncase I2S_CLR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rockchip_i2s_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rockchip_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *of_id;\r\nstruct rk_i2s_dev *i2s;\r\nstruct snd_soc_dai_driver *soc_dai;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint ret;\r\nint val;\r\ni2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\r\nif (!i2s) {\r\ndev_err(&pdev->dev, "Can't allocate rk_i2s_dev\n");\r\nreturn -ENOMEM;\r\n}\r\ni2s->dev = &pdev->dev;\r\ni2s->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");\r\nif (!IS_ERR(i2s->grf)) {\r\nof_id = of_match_device(rockchip_i2s_match, &pdev->dev);\r\nif (!of_id || !of_id->data)\r\nreturn -EINVAL;\r\ni2s->pins = of_id->data;\r\n}\r\ni2s->hclk = devm_clk_get(&pdev->dev, "i2s_hclk");\r\nif (IS_ERR(i2s->hclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s bus clock\n");\r\nreturn PTR_ERR(i2s->hclk);\r\n}\r\nret = clk_prepare_enable(i2s->hclk);\r\nif (ret) {\r\ndev_err(i2s->dev, "hclock enable failed %d\n", ret);\r\nreturn ret;\r\n}\r\ni2s->mclk = devm_clk_get(&pdev->dev, "i2s_clk");\r\nif (IS_ERR(i2s->mclk)) {\r\ndev_err(&pdev->dev, "Can't retrieve i2s master clock\n");\r\nreturn PTR_ERR(i2s->mclk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\ni2s->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\r\n&rockchip_i2s_regmap_config);\r\nif (IS_ERR(i2s->regmap)) {\r\ndev_err(&pdev->dev,\r\n"Failed to initialise managed register map\n");\r\nreturn PTR_ERR(i2s->regmap);\r\n}\r\ni2s->playback_dma_data.addr = res->start + I2S_TXDR;\r\ni2s->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->playback_dma_data.maxburst = 4;\r\ni2s->capture_dma_data.addr = res->start + I2S_RXDR;\r\ni2s->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ni2s->capture_dma_data.maxburst = 4;\r\ndev_set_drvdata(&pdev->dev, i2s);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = i2s_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nsoc_dai = devm_kzalloc(&pdev->dev,\r\nsizeof(*soc_dai), GFP_KERNEL);\r\nif (!soc_dai)\r\nreturn -ENOMEM;\r\nmemcpy(soc_dai, &rockchip_i2s_dai, sizeof(*soc_dai));\r\nif (!of_property_read_u32(node, "rockchip,playback-channels", &val)) {\r\nif (val >= 2 && val <= 8)\r\nsoc_dai->playback.channels_max = val;\r\n}\r\nif (!of_property_read_u32(node, "rockchip,capture-channels", &val)) {\r\nif (val >= 2 && val <= 8)\r\nsoc_dai->capture.channels_max = val;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&rockchip_i2s_component,\r\nsoc_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register DAI\n");\r\ngoto err_suspend;\r\n}\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not register PCM\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ni2s_runtime_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int rockchip_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct rk_i2s_dev *i2s = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ni2s_runtime_suspend(&pdev->dev);\r\nclk_disable_unprepare(i2s->mclk);\r\nclk_disable_unprepare(i2s->hclk);\r\nreturn 0;\r\n}
