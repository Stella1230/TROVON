static inline void advk_writel(struct advk_pcie *pcie, u32 val, u64 reg)\r\n{\r\nwritel(val, pcie->base + reg);\r\n}\r\nstatic inline u32 advk_readl(struct advk_pcie *pcie, u64 reg)\r\n{\r\nreturn readl(pcie->base + reg);\r\n}\r\nstatic int advk_pcie_link_up(struct advk_pcie *pcie)\r\n{\r\nu32 val, ltssm_state;\r\nval = advk_readl(pcie, CFG_REG);\r\nltssm_state = (val >> LTSSM_SHIFT) & LTSSM_MASK;\r\nreturn ltssm_state >= LTSSM_L0;\r\n}\r\nstatic int advk_pcie_wait_for_link(struct advk_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nint retries;\r\nfor (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {\r\nif (advk_pcie_link_up(pcie)) {\r\ndev_info(dev, "link up\n");\r\nreturn 0;\r\n}\r\nusleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);\r\n}\r\ndev_err(dev, "link never came up\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void advk_pcie_set_ob_win(struct advk_pcie *pcie,\r\nu32 win_num, u32 match_ms,\r\nu32 match_ls, u32 mask_ms,\r\nu32 mask_ls, u32 remap_ms,\r\nu32 remap_ls, u32 action)\r\n{\r\nadvk_writel(pcie, match_ls, OB_WIN_MATCH_LS(win_num));\r\nadvk_writel(pcie, match_ms, OB_WIN_MATCH_MS(win_num));\r\nadvk_writel(pcie, mask_ms, OB_WIN_MASK_MS(win_num));\r\nadvk_writel(pcie, mask_ls, OB_WIN_MASK_LS(win_num));\r\nadvk_writel(pcie, remap_ms, OB_WIN_REMAP_MS(win_num));\r\nadvk_writel(pcie, remap_ls, OB_WIN_REMAP_LS(win_num));\r\nadvk_writel(pcie, action, OB_WIN_ACTIONS(win_num));\r\nadvk_writel(pcie, match_ls | BIT(0), OB_WIN_MATCH_LS(win_num));\r\n}\r\nstatic void advk_pcie_setup_hw(struct advk_pcie *pcie)\r\n{\r\nu32 reg;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nadvk_pcie_set_ob_win(pcie, i, 0, 0, 0, 0, 0, 0, 0);\r\nreg = advk_readl(pcie, CTRL_CONFIG_REG);\r\nreg &= ~(CTRL_MODE_MASK << CTRL_MODE_SHIFT);\r\nreg |= ((PCIE_CORE_MODE_DIRECT & CTRL_MODE_MASK) << CTRL_MODE_SHIFT);\r\nadvk_writel(pcie, reg, CTRL_CONFIG_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\r\nreg |= (IS_RC_MSK << IS_RC_SHIFT);\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\r\nreg = PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX |\r\nPCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN |\r\nPCIE_CORE_ERR_CAPCTL_ECRC_CHCK |\r\nPCIE_CORE_ERR_CAPCTL_ECRC_CHCK_RCV;\r\nadvk_writel(pcie, reg, PCIE_CORE_ERR_CAPCTL_REG);\r\nreg = PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE |\r\n(7 << PCIE_CORE_DEV_CTRL_STATS_MAX_PAYLOAD_SZ_SHIFT) |\r\nPCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE |\r\nPCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SIZE_SHIFT;\r\nadvk_writel(pcie, reg, PCIE_CORE_DEV_CTRL_STATS_REG);\r\nreg = PCIE_CORE_CTRL2_RESERVED |\r\nPCIE_CORE_CTRL2_TD_ENABLE;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\r\nreg &= ~PCIE_GEN_SEL_MSK;\r\nreg |= SPEED_GEN_2;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\r\nreg &= ~LANE_CNT_MSK;\r\nreg |= LANE_COUNT_1;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);\r\nreg |= LINK_TRAINING_EN;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);\r\nreg |= PCIE_CORE_CTRL2_MSI_ENABLE;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\r\nadvk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_REG);\r\nadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);\r\nadvk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);\r\nreg = PCIE_ISR0_ALL_MASK;\r\nreg &= ~PCIE_ISR0_MSI_INT_PENDING;\r\nadvk_writel(pcie, reg, PCIE_ISR0_MASK_REG);\r\nadvk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);\r\nadvk_writel(pcie, 0, PCIE_MSI_MASK_REG);\r\nreg = PCIE_IRQ_ALL_MASK & (~PCIE_IRQ_ENABLE_INTS_MASK);\r\nadvk_writel(pcie, reg, HOST_CTRL_INT_MASK_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);\r\nreg |= PCIE_CORE_CTRL2_OB_WIN_ENABLE;\r\nadvk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);\r\nreg = advk_readl(pcie, PIO_CTRL);\r\nreg |= PIO_CTRL_ADDR_WIN_DISABLE;\r\nadvk_writel(pcie, reg, PIO_CTRL);\r\nreg = advk_readl(pcie, PCIE_CORE_LINK_CTRL_STAT_REG);\r\nreg |= PCIE_CORE_LINK_TRAINING;\r\nadvk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);\r\nadvk_pcie_wait_for_link(pcie);\r\nreg = PCIE_CORE_LINK_L0S_ENTRY |\r\n(1 << PCIE_CORE_LINK_WIDTH_SHIFT);\r\nadvk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);\r\nreg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);\r\nreg |= PCIE_CORE_CMD_MEM_ACCESS_EN |\r\nPCIE_CORE_CMD_IO_ACCESS_EN |\r\nPCIE_CORE_CMD_MEM_IO_REQ_EN;\r\nadvk_writel(pcie, reg, PCIE_CORE_CMD_STATUS_REG);\r\n}\r\nstatic void advk_pcie_check_pio_status(struct advk_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nu32 reg;\r\nunsigned int status;\r\nchar *strcomp_status, *str_posted;\r\nreg = advk_readl(pcie, PIO_STAT);\r\nstatus = (reg & PIO_COMPLETION_STATUS_MASK) >>\r\nPIO_COMPLETION_STATUS_SHIFT;\r\nif (!status)\r\nreturn;\r\nswitch (status) {\r\ncase PIO_COMPLETION_STATUS_UR:\r\nstrcomp_status = "UR";\r\nbreak;\r\ncase PIO_COMPLETION_STATUS_CRS:\r\nstrcomp_status = "CRS";\r\nbreak;\r\ncase PIO_COMPLETION_STATUS_CA:\r\nstrcomp_status = "CA";\r\nbreak;\r\ndefault:\r\nstrcomp_status = "Unknown";\r\nbreak;\r\n}\r\nif (reg & PIO_NON_POSTED_REQ)\r\nstr_posted = "Non-posted";\r\nelse\r\nstr_posted = "Posted";\r\ndev_err(dev, "%s PIO Response Status: %s, %#x @ %#x\n",\r\nstr_posted, strcomp_status, reg, advk_readl(pcie, PIO_ADDR_LS));\r\n}\r\nstatic int advk_pcie_wait_pio(struct advk_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(PIO_TIMEOUT_MS);\r\nwhile (time_before(jiffies, timeout)) {\r\nu32 start, isr;\r\nstart = advk_readl(pcie, PIO_START);\r\nisr = advk_readl(pcie, PIO_ISR);\r\nif (!start && isr)\r\nreturn 0;\r\n}\r\ndev_err(dev, "config read/write timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int advk_pcie_rd_conf(struct pci_bus *bus, u32 devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct advk_pcie *pcie = bus->sysdata;\r\nu32 reg;\r\nint ret;\r\nif (PCI_SLOT(devfn) != 0) {\r\n*val = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nadvk_writel(pcie, 0, PIO_START);\r\nadvk_writel(pcie, 1, PIO_ISR);\r\nreg = advk_readl(pcie, PIO_CTRL);\r\nreg &= ~PIO_CTRL_TYPE_MASK;\r\nif (bus->number == pcie->root_bus_nr)\r\nreg |= PCIE_CONFIG_RD_TYPE0;\r\nelse\r\nreg |= PCIE_CONFIG_RD_TYPE1;\r\nadvk_writel(pcie, reg, PIO_CTRL);\r\nreg = PCIE_BDF(devfn) | PCIE_CONF_REG(where);\r\nadvk_writel(pcie, reg, PIO_ADDR_LS);\r\nadvk_writel(pcie, 0, PIO_ADDR_MS);\r\nadvk_writel(pcie, 0xf, PIO_WR_DATA_STRB);\r\nadvk_writel(pcie, 1, PIO_START);\r\nret = advk_pcie_wait_pio(pcie);\r\nif (ret < 0)\r\nreturn PCIBIOS_SET_FAILED;\r\nadvk_pcie_check_pio_status(pcie);\r\n*val = advk_readl(pcie, PIO_RD_DATA);\r\nif (size == 1)\r\n*val = (*val >> (8 * (where & 3))) & 0xff;\r\nelse if (size == 2)\r\n*val = (*val >> (8 * (where & 3))) & 0xffff;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int advk_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct advk_pcie *pcie = bus->sysdata;\r\nu32 reg;\r\nu32 data_strobe = 0x0;\r\nint offset;\r\nint ret;\r\nif (PCI_SLOT(devfn) != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (where % size)\r\nreturn PCIBIOS_SET_FAILED;\r\nadvk_writel(pcie, 0, PIO_START);\r\nadvk_writel(pcie, 1, PIO_ISR);\r\nreg = advk_readl(pcie, PIO_CTRL);\r\nreg &= ~PIO_CTRL_TYPE_MASK;\r\nif (bus->number == pcie->root_bus_nr)\r\nreg |= PCIE_CONFIG_WR_TYPE0;\r\nelse\r\nreg |= PCIE_CONFIG_WR_TYPE1;\r\nadvk_writel(pcie, reg, PIO_CTRL);\r\nreg = PCIE_CONF_ADDR(bus->number, devfn, where);\r\nadvk_writel(pcie, reg, PIO_ADDR_LS);\r\nadvk_writel(pcie, 0, PIO_ADDR_MS);\r\noffset = where & 0x3;\r\nreg = val << (8 * offset);\r\ndata_strobe = GENMASK(size - 1, 0) << offset;\r\nadvk_writel(pcie, reg, PIO_WR_DATA);\r\nadvk_writel(pcie, data_strobe, PIO_WR_DATA_STRB);\r\nadvk_writel(pcie, 1, PIO_START);\r\nret = advk_pcie_wait_pio(pcie);\r\nif (ret < 0)\r\nreturn PCIBIOS_SET_FAILED;\r\nadvk_pcie_check_pio_status(pcie);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int advk_pcie_alloc_msi(struct advk_pcie *pcie)\r\n{\r\nint hwirq;\r\nmutex_lock(&pcie->msi_used_lock);\r\nhwirq = find_first_zero_bit(pcie->msi_irq_in_use, MSI_IRQ_NUM);\r\nif (hwirq >= MSI_IRQ_NUM)\r\nhwirq = -ENOSPC;\r\nelse\r\nset_bit(hwirq, pcie->msi_irq_in_use);\r\nmutex_unlock(&pcie->msi_used_lock);\r\nreturn hwirq;\r\n}\r\nstatic void advk_pcie_free_msi(struct advk_pcie *pcie, int hwirq)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nmutex_lock(&pcie->msi_used_lock);\r\nif (!test_bit(hwirq, pcie->msi_irq_in_use))\r\ndev_err(dev, "trying to free unused MSI#%d\n", hwirq);\r\nelse\r\nclear_bit(hwirq, pcie->msi_irq_in_use);\r\nmutex_unlock(&pcie->msi_used_lock);\r\n}\r\nstatic int advk_pcie_setup_msi_irq(struct msi_controller *chip,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct advk_pcie *pcie = pdev->bus->sysdata;\r\nstruct msi_msg msg;\r\nint virq, hwirq;\r\nphys_addr_t msi_msg_phys;\r\nif (desc->msi_attrib.is_msix)\r\nreturn -EINVAL;\r\nhwirq = advk_pcie_alloc_msi(pcie);\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nvirq = irq_create_mapping(pcie->msi_domain, hwirq);\r\nif (!virq) {\r\nadvk_pcie_free_msi(pcie, hwirq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_msi_desc(virq, desc);\r\nmsi_msg_phys = virt_to_phys(&pcie->msi_msg);\r\nmsg.address_lo = lower_32_bits(msi_msg_phys);\r\nmsg.address_hi = upper_32_bits(msi_msg_phys);\r\nmsg.data = virq;\r\npci_write_msi_msg(virq, &msg);\r\nreturn 0;\r\n}\r\nstatic void advk_pcie_teardown_msi_irq(struct msi_controller *chip,\r\nunsigned int irq)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nstruct msi_desc *msi = irq_data_get_msi_desc(d);\r\nstruct advk_pcie *pcie = msi_desc_to_pci_sysdata(msi);\r\nunsigned long hwirq = d->hwirq;\r\nirq_dispose_mapping(irq);\r\nadvk_pcie_free_msi(pcie, hwirq);\r\n}\r\nstatic int advk_pcie_msi_map(struct irq_domain *domain,\r\nunsigned int virq, irq_hw_number_t hw)\r\n{\r\nstruct advk_pcie *pcie = domain->host_data;\r\nirq_set_chip_and_handler(virq, &pcie->msi_irq_chip,\r\nhandle_simple_irq);\r\nreturn 0;\r\n}\r\nstatic void advk_pcie_irq_mask(struct irq_data *d)\r\n{\r\nstruct advk_pcie *pcie = d->domain->host_data;\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nu32 mask;\r\nmask = advk_readl(pcie, PCIE_ISR0_MASK_REG);\r\nmask |= PCIE_ISR0_INTX_ASSERT(hwirq);\r\nadvk_writel(pcie, mask, PCIE_ISR0_MASK_REG);\r\n}\r\nstatic void advk_pcie_irq_unmask(struct irq_data *d)\r\n{\r\nstruct advk_pcie *pcie = d->domain->host_data;\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nu32 mask;\r\nmask = advk_readl(pcie, PCIE_ISR0_MASK_REG);\r\nmask &= ~PCIE_ISR0_INTX_ASSERT(hwirq);\r\nadvk_writel(pcie, mask, PCIE_ISR0_MASK_REG);\r\n}\r\nstatic int advk_pcie_irq_map(struct irq_domain *h,\r\nunsigned int virq, irq_hw_number_t hwirq)\r\n{\r\nstruct advk_pcie *pcie = h->host_data;\r\nadvk_pcie_irq_mask(irq_get_irq_data(virq));\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &pcie->irq_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(virq, pcie);\r\nreturn 0;\r\n}\r\nstatic int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct irq_chip *msi_irq_chip;\r\nstruct msi_controller *msi;\r\nphys_addr_t msi_msg_phys;\r\nint ret;\r\nmsi_irq_chip = &pcie->msi_irq_chip;\r\nmsi_irq_chip->name = devm_kasprintf(dev, GFP_KERNEL, "%s-msi",\r\ndev_name(dev));\r\nif (!msi_irq_chip->name)\r\nreturn -ENOMEM;\r\nmsi_irq_chip->irq_enable = pci_msi_unmask_irq;\r\nmsi_irq_chip->irq_disable = pci_msi_mask_irq;\r\nmsi_irq_chip->irq_mask = pci_msi_mask_irq;\r\nmsi_irq_chip->irq_unmask = pci_msi_unmask_irq;\r\nmsi = &pcie->msi;\r\nmsi->setup_irq = advk_pcie_setup_msi_irq;\r\nmsi->teardown_irq = advk_pcie_teardown_msi_irq;\r\nmsi->of_node = node;\r\nmutex_init(&pcie->msi_used_lock);\r\nmsi_msg_phys = virt_to_phys(&pcie->msi_msg);\r\nadvk_writel(pcie, lower_32_bits(msi_msg_phys),\r\nPCIE_MSI_ADDR_LOW_REG);\r\nadvk_writel(pcie, upper_32_bits(msi_msg_phys),\r\nPCIE_MSI_ADDR_HIGH_REG);\r\npcie->msi_domain =\r\nirq_domain_add_linear(NULL, MSI_IRQ_NUM,\r\n&advk_pcie_msi_irq_ops, pcie);\r\nif (!pcie->msi_domain)\r\nreturn -ENOMEM;\r\nret = of_pci_msi_chip_add(msi);\r\nif (ret < 0) {\r\nirq_domain_remove(pcie->msi_domain);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void advk_pcie_remove_msi_irq_domain(struct advk_pcie *pcie)\r\n{\r\nof_pci_msi_chip_remove(&pcie->msi);\r\nirq_domain_remove(pcie->msi_domain);\r\n}\r\nstatic int advk_pcie_init_irq_domain(struct advk_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *pcie_intc_node;\r\nstruct irq_chip *irq_chip;\r\npcie_intc_node = of_get_next_child(node, NULL);\r\nif (!pcie_intc_node) {\r\ndev_err(dev, "No PCIe Intc node found\n");\r\nreturn -ENODEV;\r\n}\r\nirq_chip = &pcie->irq_chip;\r\nirq_chip->name = devm_kasprintf(dev, GFP_KERNEL, "%s-irq",\r\ndev_name(dev));\r\nif (!irq_chip->name) {\r\nof_node_put(pcie_intc_node);\r\nreturn -ENOMEM;\r\n}\r\nirq_chip->irq_mask = advk_pcie_irq_mask;\r\nirq_chip->irq_mask_ack = advk_pcie_irq_mask;\r\nirq_chip->irq_unmask = advk_pcie_irq_unmask;\r\npcie->irq_domain =\r\nirq_domain_add_linear(pcie_intc_node, LEGACY_IRQ_NUM,\r\n&advk_pcie_irq_domain_ops, pcie);\r\nif (!pcie->irq_domain) {\r\ndev_err(dev, "Failed to get a INTx IRQ domain\n");\r\nof_node_put(pcie_intc_node);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void advk_pcie_remove_irq_domain(struct advk_pcie *pcie)\r\n{\r\nirq_domain_remove(pcie->irq_domain);\r\n}\r\nstatic void advk_pcie_handle_msi(struct advk_pcie *pcie)\r\n{\r\nu32 msi_val, msi_mask, msi_status, msi_idx;\r\nu16 msi_data;\r\nmsi_mask = advk_readl(pcie, PCIE_MSI_MASK_REG);\r\nmsi_val = advk_readl(pcie, PCIE_MSI_STATUS_REG);\r\nmsi_status = msi_val & ~msi_mask;\r\nfor (msi_idx = 0; msi_idx < MSI_IRQ_NUM; msi_idx++) {\r\nif (!(BIT(msi_idx) & msi_status))\r\ncontinue;\r\nadvk_writel(pcie, BIT(msi_idx), PCIE_MSI_STATUS_REG);\r\nmsi_data = advk_readl(pcie, PCIE_MSI_PAYLOAD_REG) & 0xFF;\r\ngeneric_handle_irq(msi_data);\r\n}\r\nadvk_writel(pcie, PCIE_ISR0_MSI_INT_PENDING,\r\nPCIE_ISR0_REG);\r\n}\r\nstatic void advk_pcie_handle_int(struct advk_pcie *pcie)\r\n{\r\nu32 val, mask, status;\r\nint i, virq;\r\nval = advk_readl(pcie, PCIE_ISR0_REG);\r\nmask = advk_readl(pcie, PCIE_ISR0_MASK_REG);\r\nstatus = val & ((~mask) & PCIE_ISR0_ALL_MASK);\r\nif (!status) {\r\nadvk_writel(pcie, val, PCIE_ISR0_REG);\r\nreturn;\r\n}\r\nif (status & PCIE_ISR0_MSI_INT_PENDING)\r\nadvk_pcie_handle_msi(pcie);\r\nfor (i = 0; i < LEGACY_IRQ_NUM; i++) {\r\nif (!(status & PCIE_ISR0_INTX_ASSERT(i)))\r\ncontinue;\r\nadvk_writel(pcie, PCIE_ISR0_INTX_ASSERT(i),\r\nPCIE_ISR0_REG);\r\nvirq = irq_find_mapping(pcie->irq_domain, i);\r\ngeneric_handle_irq(virq);\r\n}\r\n}\r\nstatic irqreturn_t advk_pcie_irq_handler(int irq, void *arg)\r\n{\r\nstruct advk_pcie *pcie = arg;\r\nu32 status;\r\nstatus = advk_readl(pcie, HOST_CTRL_INT_STATUS_REG);\r\nif (!(status & PCIE_IRQ_CORE_INT))\r\nreturn IRQ_NONE;\r\nadvk_pcie_handle_int(pcie);\r\nadvk_writel(pcie, PCIE_IRQ_CORE_INT, HOST_CTRL_INT_STATUS_REG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)\r\n{\r\nint err, res_valid = 0;\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource_entry *win, *tmp;\r\nresource_size_t iobase;\r\nINIT_LIST_HEAD(&pcie->resources);\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, &pcie->resources,\r\n&iobase);\r\nif (err)\r\nreturn err;\r\nerr = devm_request_pci_bus_resources(dev, &pcie->resources);\r\nif (err)\r\ngoto out_release_res;\r\nresource_list_for_each_entry_safe(win, tmp, &pcie->resources) {\r\nstruct resource *res = win->res;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_IO:\r\nadvk_pcie_set_ob_win(pcie, 1,\r\nupper_32_bits(res->start),\r\nlower_32_bits(res->start),\r\n0, 0xF8000000, 0,\r\nlower_32_bits(res->start),\r\nOB_PCIE_IO);\r\nerr = pci_remap_iospace(res, iobase);\r\nif (err) {\r\ndev_warn(dev, "error %d: failed to map resource %pR\n",\r\nerr, res);\r\nresource_list_destroy_entry(win);\r\n}\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nadvk_pcie_set_ob_win(pcie, 0,\r\nupper_32_bits(res->start),\r\nlower_32_bits(res->start),\r\n0x0, 0xF8000000, 0,\r\nlower_32_bits(res->start),\r\n(2 << 20) | OB_PCIE_MEM);\r\nres_valid |= !(res->flags & IORESOURCE_PREFETCH);\r\nbreak;\r\ncase IORESOURCE_BUS:\r\npcie->root_bus_nr = res->start;\r\nbreak;\r\n}\r\n}\r\nif (!res_valid) {\r\ndev_err(dev, "non-prefetchable memory resource required\n");\r\nerr = -EINVAL;\r\ngoto out_release_res;\r\n}\r\nreturn 0;\r\nout_release_res:\r\npci_free_resource_list(&pcie->resources);\r\nreturn err;\r\n}\r\nstatic int advk_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct advk_pcie *pcie;\r\nstruct resource *res;\r\nstruct pci_bus *bus, *child;\r\nstruct msi_controller *msi;\r\nstruct device_node *msi_node;\r\nint ret, irq;\r\npcie = devm_kzalloc(dev, sizeof(struct advk_pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npcie->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pcie->base))\r\nreturn PTR_ERR(pcie->base);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(dev, irq, advk_pcie_irq_handler,\r\nIRQF_SHARED | IRQF_NO_THREAD, "advk-pcie",\r\npcie);\r\nif (ret) {\r\ndev_err(dev, "Failed to register interrupt\n");\r\nreturn ret;\r\n}\r\nret = advk_pcie_parse_request_of_pci_ranges(pcie);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse resources\n");\r\nreturn ret;\r\n}\r\nadvk_pcie_setup_hw(pcie);\r\nret = advk_pcie_init_irq_domain(pcie);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize irq\n");\r\nreturn ret;\r\n}\r\nret = advk_pcie_init_msi_irq_domain(pcie);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize irq\n");\r\nadvk_pcie_remove_irq_domain(pcie);\r\nreturn ret;\r\n}\r\nmsi_node = of_parse_phandle(dev->of_node, "msi-parent", 0);\r\nif (msi_node)\r\nmsi = of_pci_find_msi_chip_by_node(msi_node);\r\nelse\r\nmsi = NULL;\r\nbus = pci_scan_root_bus_msi(dev, 0, &advk_pcie_ops,\r\npcie, &pcie->resources, &pcie->msi);\r\nif (!bus) {\r\nadvk_pcie_remove_msi_irq_domain(pcie);\r\nadvk_pcie_remove_irq_domain(pcie);\r\nreturn -ENOMEM;\r\n}\r\npci_bus_assign_resources(bus);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\n}
