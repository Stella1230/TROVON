static int sbs_read_word_data(struct i2c_client *client, u8 address)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nretries = chip->i2c_retry_count;\r\nwhile (retries > 0) {\r\nret = i2c_smbus_read_word_data(client, address);\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c read at address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(ret);\r\n}\r\nstatic int sbs_read_string_data(struct i2c_client *client, u8 address,\r\nchar *values)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret = 0, block_length = 0;\r\nint retries_length = 1, retries_block = 1;\r\nu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\r\nretries_length = chip->i2c_retry_count;\r\nretries_block = chip->i2c_retry_count;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK)){\r\nreturn -ENODEV;\r\n}\r\nwhile (retries_length > 0) {\r\nret = i2c_smbus_read_byte_data(client, address);\r\nif (ret >= 0)\r\nbreak;\r\nretries_length--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c read at address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nblock_length = ret;\r\nif (block_length > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&client->dev,\r\n"%s: Returned block_length is longer than 0x%x\n",\r\n__func__, I2C_SMBUS_BLOCK_MAX);\r\nreturn -EINVAL;\r\n}\r\nwhile (retries_block > 0) {\r\nret = i2c_smbus_read_i2c_block_data(\r\nclient, address,\r\nblock_length + 1, block_buffer);\r\nif (ret >= 0)\r\nbreak;\r\nretries_block--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c read at address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nmemcpy(values, block_buffer + 1, block_length);\r\nvalues[block_length] = '\0';\r\nreturn le16_to_cpu(ret);\r\n}\r\nstatic int sbs_write_word_data(struct i2c_client *client, u8 address,\r\nu16 value)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nretries = chip->i2c_retry_count;\r\nwhile (retries > 0) {\r\nret = i2c_smbus_write_word_data(client, address,\r\nle16_to_cpu(value));\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c write to address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_presence_and_health(\r\nstruct i2c_client *client, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT && chip->gpio_detect) {\r\nret = gpiod_get_value_cansleep(chip->gpio_detect);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret;\r\nchip->is_present = val->intval;\r\nreturn ret;\r\n}\r\nsbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_STATUS);\r\nret = sbs_read_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr);\r\nif (ret < 0) {\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nval->intval = 0;\r\nreturn ret;\r\n}\r\nif (ret < sbs_data[REG_MANUFACTURER_DATA].min_value ||\r\nret > sbs_data[REG_MANUFACTURER_DATA].max_value) {\r\nval->intval = 0;\r\nreturn 0;\r\n}\r\nret &= 0x0F00;\r\nret >>= 8;\r\nif (psp == POWER_SUPPLY_PROP_PRESENT) {\r\nif (ret == 0x0F)\r\nval->intval = 0;\r\nelse\r\nval->intval = 1;\r\n} else if (psp == POWER_SUPPLY_PROP_HEALTH) {\r\nif (ret == 0x09)\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nelse if (ret == 0x0B)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (ret == 0x0C)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_property(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret;\r\nret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sbs_data[reg_offset].min_value < 0)\r\nret = (s16)ret;\r\nif (ret >= sbs_data[reg_offset].min_value &&\r\nret <= sbs_data[reg_offset].max_value) {\r\nval->intval = ret;\r\nif (psp == POWER_SUPPLY_PROP_CAPACITY_LEVEL) {\r\nif (!(ret & BATTERY_INITIALIZED))\r\nval->intval =\r\nPOWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\r\nelse if (ret & BATTERY_FULL_CHARGED)\r\nval->intval =\r\nPOWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nelse if (ret & BATTERY_FULL_DISCHARGED)\r\nval->intval =\r\nPOWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse\r\nval->intval =\r\nPOWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\nreturn 0;\r\n} else if (psp != POWER_SUPPLY_PROP_STATUS) {\r\nreturn 0;\r\n}\r\nif (ret & BATTERY_FULL_CHARGED)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nif (chip->poll_time == 0)\r\nchip->last_state = val->intval;\r\nelse if (chip->last_state != val->intval) {\r\ncancel_delayed_work_sync(&chip->work);\r\npower_supply_changed(chip->power_supply);\r\nchip->poll_time = 0;\r\n}\r\n} else {\r\nif (psp == POWER_SUPPLY_PROP_STATUS)\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nelse\r\nval->intval = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_string_property(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp, char *val)\r\n{\r\ns32 ret;\r\nret = sbs_read_string_data(client, sbs_data[reg_offset].addr, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void sbs_unit_adjustment(struct i2c_client *client,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\n#define BASE_UNIT_CONVERSION 1000\r\n#define BATTERY_MODE_CAP_MULT_WATT (10 * BASE_UNIT_CONVERSION)\r\n#define TIME_UNIT_CONVERSION 60\r\n#define TEMP_KELVIN_TO_CELSIUS 2731\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nval->intval *= BATTERY_MODE_CAP_MULT_WATT;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval *= BASE_UNIT_CONVERSION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval -= TEMP_KELVIN_TO_CELSIUS;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\nval->intval *= TIME_UNIT_CONVERSION;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev,\r\n"%s: no need for unit conversion %d\n", __func__, psp);\r\n}\r\n}\r\nstatic enum sbs_battery_mode sbs_set_battery_mode(struct i2c_client *client,\r\nenum sbs_battery_mode mode)\r\n{\r\nint ret, original_val;\r\noriginal_val = sbs_read_word_data(client, BATTERY_MODE_OFFSET);\r\nif (original_val < 0)\r\nreturn original_val;\r\nif ((original_val & BATTERY_MODE_MASK) == mode)\r\nreturn mode;\r\nif (mode == BATTERY_MODE_AMPS)\r\nret = original_val & ~BATTERY_MODE_MASK;\r\nelse\r\nret = original_val | BATTERY_MODE_MASK;\r\nret = sbs_write_word_data(client, BATTERY_MODE_OFFSET, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn original_val & BATTERY_MODE_MASK;\r\n}\r\nstatic int sbs_get_battery_capacity(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nenum sbs_battery_mode mode = BATTERY_MODE_WATTS;\r\nif (power_supply_is_amp_property(psp))\r\nmode = BATTERY_MODE_AMPS;\r\nmode = sbs_set_battery_mode(client, mode);\r\nif (mode < 0)\r\nreturn mode;\r\nret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (psp == POWER_SUPPLY_PROP_CAPACITY) {\r\nval->intval = min(ret, 100);\r\n} else\r\nval->intval = ret;\r\nret = sbs_set_battery_mode(client, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_serial_number(struct i2c_client *client,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nret = sbs_read_word_data(client, sbs_data[REG_SERIAL_NUMBER].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sprintf(sbs_serial, "%04x", ret);\r\nval->strval = sbs_serial;\r\nreturn 0;\r\n}\r\nstatic int sbs_get_property_index(struct i2c_client *client,\r\nenum power_supply_property psp)\r\n{\r\nint count;\r\nfor (count = 0; count < ARRAY_SIZE(sbs_data); count++)\r\nif (psp == sbs_data[count].psp)\r\nreturn count;\r\ndev_warn(&client->dev,\r\n"%s: Invalid Property - %d\n", __func__, psp);\r\nreturn -EINVAL;\r\n}\r\nstatic int sbs_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct sbs_info *chip = power_supply_get_drvdata(psy);\r\nstruct i2c_client *client = chip->client;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = sbs_get_battery_presence_and_health(client, psp, val);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nreturn 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\ngoto done;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_capacity(client, ret, psp, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nret = sbs_get_battery_serial_number(client, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_TEMP:\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_property(client, ret, psp, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_string_property(client, ret, psp,\r\nmodel_name);\r\nval->strval = model_name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_string_property(client, ret, psp,\r\nmanufacturer);\r\nval->strval = manufacturer;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"%s: INVALID property\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!chip->enable_detection)\r\ngoto done;\r\nif (!chip->gpio_detect &&\r\nchip->is_present != (ret >= 0)) {\r\nchip->is_present = (ret >= 0);\r\npower_supply_changed(chip->power_supply);\r\n}\r\ndone:\r\nif (!ret) {\r\nsbs_unit_adjustment(client, psp, val);\r\n}\r\ndev_dbg(&client->dev,\r\n"%s: property = %d, value = %x\n", __func__, psp, val->intval);\r\nif (ret && chip->is_present)\r\nreturn ret;\r\nif (ret)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sbs_irq(int irq, void *devid)\r\n{\r\nstruct sbs_info *chip = devid;\r\nstruct power_supply *battery = chip->power_supply;\r\nint ret;\r\nret = gpiod_get_value_cansleep(chip->gpio_detect);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->is_present = ret;\r\npower_supply_changed(battery);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sbs_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct sbs_info *chip = power_supply_get_drvdata(psy);\r\nif (chip->ignore_changes > 0) {\r\nchip->ignore_changes--;\r\nreturn;\r\n}\r\ncancel_delayed_work_sync(&chip->work);\r\nschedule_delayed_work(&chip->work, HZ);\r\nchip->poll_time = chip->poll_retry_count;\r\n}\r\nstatic void sbs_delayed_work(struct work_struct *work)\r\n{\r\nstruct sbs_info *chip;\r\ns32 ret;\r\nchip = container_of(work, struct sbs_info, work.work);\r\nret = sbs_read_word_data(chip->client, sbs_data[REG_STATUS].addr);\r\nif (ret < 0) {\r\nchip->poll_time = 0;\r\nreturn;\r\n}\r\nif (ret & BATTERY_FULL_CHARGED)\r\nret = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nret = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nret = POWER_SUPPLY_STATUS_CHARGING;\r\nif (chip->last_state != ret) {\r\nchip->poll_time = 0;\r\npower_supply_changed(chip->power_supply);\r\nreturn;\r\n}\r\nif (chip->poll_time > 0) {\r\nschedule_delayed_work(&chip->work, HZ);\r\nchip->poll_time--;\r\nreturn;\r\n}\r\n}\r\nstatic int sbs_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sbs_info *chip;\r\nstruct power_supply_desc *sbs_desc;\r\nstruct sbs_platform_data *pdata = client->dev.platform_data;\r\nstruct power_supply_config psy_cfg = {};\r\nint rc;\r\nint irq;\r\nsbs_desc = devm_kmemdup(&client->dev, &sbs_default_desc,\r\nsizeof(*sbs_desc), GFP_KERNEL);\r\nif (!sbs_desc)\r\nreturn -ENOMEM;\r\nsbs_desc->name = devm_kasprintf(&client->dev, GFP_KERNEL, "sbs-%s",\r\ndev_name(&client->dev));\r\nif (!sbs_desc->name)\r\nreturn -ENOMEM;\r\nchip = devm_kzalloc(&client->dev, sizeof(struct sbs_info), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->client = client;\r\nchip->enable_detection = false;\r\npsy_cfg.of_node = client->dev.of_node;\r\npsy_cfg.drv_data = chip;\r\nchip->ignore_changes = 1;\r\nchip->last_state = POWER_SUPPLY_STATUS_UNKNOWN;\r\nrc = of_property_read_u32(client->dev.of_node, "sbs,i2c-retry-count",\r\n&chip->i2c_retry_count);\r\nif (rc)\r\nchip->i2c_retry_count = 0;\r\nrc = of_property_read_u32(client->dev.of_node, "sbs,poll-retry-count",\r\n&chip->poll_retry_count);\r\nif (rc)\r\nchip->poll_retry_count = 0;\r\nif (pdata) {\r\nchip->poll_retry_count = pdata->poll_retry_count;\r\nchip->i2c_retry_count = pdata->i2c_retry_count;\r\n}\r\nchip->i2c_retry_count = chip->i2c_retry_count + 1;\r\nchip->gpio_detect = devm_gpiod_get_optional(&client->dev,\r\n"sbs,battery-detect", GPIOD_IN);\r\nif (IS_ERR(chip->gpio_detect)) {\r\ndev_err(&client->dev, "Failed to get gpio: %ld\n",\r\nPTR_ERR(chip->gpio_detect));\r\nreturn PTR_ERR(chip->gpio_detect);\r\n}\r\ni2c_set_clientdata(client, chip);\r\nif (!chip->gpio_detect)\r\ngoto skip_gpio;\r\nirq = gpiod_to_irq(chip->gpio_detect);\r\nif (irq <= 0) {\r\ndev_warn(&client->dev, "Failed to get gpio as irq: %d\n", irq);\r\ngoto skip_gpio;\r\n}\r\nrc = devm_request_threaded_irq(&client->dev, irq, NULL, sbs_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\ndev_name(&client->dev), chip);\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to request irq: %d\n", rc);\r\ngoto skip_gpio;\r\n}\r\nskip_gpio:\r\nif (!(force_load || chip->gpio_detect)) {\r\nrc = sbs_read_word_data(client, sbs_data[REG_STATUS].addr);\r\nif (rc < 0) {\r\ndev_err(&client->dev, "%s: Failed to get device status\n",\r\n__func__);\r\ngoto exit_psupply;\r\n}\r\n}\r\nchip->power_supply = devm_power_supply_register(&client->dev, sbs_desc,\r\n&psy_cfg);\r\nif (IS_ERR(chip->power_supply)) {\r\ndev_err(&client->dev,\r\n"%s: Failed to register power supply\n", __func__);\r\nrc = PTR_ERR(chip->power_supply);\r\ngoto exit_psupply;\r\n}\r\ndev_info(&client->dev,\r\n"%s: battery gas gauge device registered\n", client->name);\r\nINIT_DELAYED_WORK(&chip->work, sbs_delayed_work);\r\nchip->enable_detection = true;\r\nreturn 0;\r\nexit_psupply:\r\nreturn rc;\r\n}\r\nstatic int sbs_remove(struct i2c_client *client)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ncancel_delayed_work_sync(&chip->work);\r\nreturn 0;\r\n}\r\nstatic int sbs_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\nif (chip->poll_time > 0)\r\ncancel_delayed_work_sync(&chip->work);\r\nsbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_SLEEP);\r\nreturn 0;\r\n}
