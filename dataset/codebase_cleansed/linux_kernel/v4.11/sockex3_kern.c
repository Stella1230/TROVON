static inline void parse_eth_proto(struct __sk_buff *skb, u32 proto)\r\n{\r\nswitch (proto) {\r\ncase ETH_P_8021Q:\r\ncase ETH_P_8021AD:\r\nbpf_tail_call(skb, &jmp_table, PARSE_VLAN);\r\nbreak;\r\ncase ETH_P_MPLS_UC:\r\ncase ETH_P_MPLS_MC:\r\nbpf_tail_call(skb, &jmp_table, PARSE_MPLS);\r\nbreak;\r\ncase ETH_P_IP:\r\nbpf_tail_call(skb, &jmp_table, PARSE_IP);\r\nbreak;\r\ncase ETH_P_IPV6:\r\nbpf_tail_call(skb, &jmp_table, PARSE_IPV6);\r\nbreak;\r\n}\r\n}\r\nstatic inline int ip_is_fragment(struct __sk_buff *ctx, __u64 nhoff)\r\n{\r\nreturn load_half(ctx, nhoff + offsetof(struct iphdr, frag_off))\r\n& (IP_MF | IP_OFFSET);\r\n}\r\nstatic inline __u32 ipv6_addr_hash(struct __sk_buff *ctx, __u64 off)\r\n{\r\n__u64 w0 = load_word(ctx, off);\r\n__u64 w1 = load_word(ctx, off + 4);\r\n__u64 w2 = load_word(ctx, off + 8);\r\n__u64 w3 = load_word(ctx, off + 12);\r\nreturn (__u32)(w0 ^ w1 ^ w2 ^ w3);\r\n}\r\nstatic struct globals *this_cpu_globals(void)\r\n{\r\nu32 key = bpf_get_smp_processor_id();\r\nreturn bpf_map_lookup_elem(&percpu_map, &key);\r\n}\r\nstatic void update_stats(struct __sk_buff *skb, struct globals *g)\r\n{\r\nstruct bpf_flow_keys key = g->flow;\r\nstruct pair *value;\r\nvalue = bpf_map_lookup_elem(&hash_map, &key);\r\nif (value) {\r\n__sync_fetch_and_add(&value->packets, 1);\r\n__sync_fetch_and_add(&value->bytes, skb->len);\r\n} else {\r\nstruct pair val = {1, skb->len};\r\nbpf_map_update_elem(&hash_map, &key, &val, BPF_ANY);\r\n}\r\n}\r\nstatic __always_inline void parse_ip_proto(struct __sk_buff *skb,\r\nstruct globals *g, __u32 ip_proto)\r\n{\r\n__u32 nhoff = skb->cb[0];\r\nint poff;\r\nswitch (ip_proto) {\r\ncase IPPROTO_GRE: {\r\nstruct gre_hdr {\r\n__be16 flags;\r\n__be16 proto;\r\n};\r\n__u32 gre_flags = load_half(skb,\r\nnhoff + offsetof(struct gre_hdr, flags));\r\n__u32 gre_proto = load_half(skb,\r\nnhoff + offsetof(struct gre_hdr, proto));\r\nif (gre_flags & (GRE_VERSION|GRE_ROUTING))\r\nbreak;\r\nnhoff += 4;\r\nif (gre_flags & GRE_CSUM)\r\nnhoff += 4;\r\nif (gre_flags & GRE_KEY)\r\nnhoff += 4;\r\nif (gre_flags & GRE_SEQ)\r\nnhoff += 4;\r\nskb->cb[0] = nhoff;\r\nparse_eth_proto(skb, gre_proto);\r\nbreak;\r\n}\r\ncase IPPROTO_IPIP:\r\nparse_eth_proto(skb, ETH_P_IP);\r\nbreak;\r\ncase IPPROTO_IPV6:\r\nparse_eth_proto(skb, ETH_P_IPV6);\r\nbreak;\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_UDP:\r\ng->flow.ports = load_word(skb, nhoff);\r\ncase IPPROTO_ICMP:\r\ng->flow.ip_proto = ip_proto;\r\nupdate_stats(skb, g);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nPROG(PARSE_IP)(struct __sk_buff *skb)\r\n{\r\nstruct globals *g = this_cpu_globals();\r\n__u32 nhoff, verlen, ip_proto;\r\nif (!g)\r\nreturn 0;\r\nnhoff = skb->cb[0];\r\nif (unlikely(ip_is_fragment(skb, nhoff)))\r\nreturn 0;\r\nip_proto = load_byte(skb, nhoff + offsetof(struct iphdr, protocol));\r\nif (ip_proto != IPPROTO_GRE) {\r\ng->flow.src = load_word(skb, nhoff + offsetof(struct iphdr, saddr));\r\ng->flow.dst = load_word(skb, nhoff + offsetof(struct iphdr, daddr));\r\n}\r\nverlen = load_byte(skb, nhoff + 0);\r\nnhoff += (verlen & 0xF) << 2;\r\nskb->cb[0] = nhoff;\r\nparse_ip_proto(skb, g, ip_proto);\r\nreturn 0;\r\n}\r\nPROG(PARSE_IPV6)(struct __sk_buff *skb)\r\n{\r\nstruct globals *g = this_cpu_globals();\r\n__u32 nhoff, ip_proto;\r\nif (!g)\r\nreturn 0;\r\nnhoff = skb->cb[0];\r\nip_proto = load_byte(skb,\r\nnhoff + offsetof(struct ipv6hdr, nexthdr));\r\ng->flow.src = ipv6_addr_hash(skb,\r\nnhoff + offsetof(struct ipv6hdr, saddr));\r\ng->flow.dst = ipv6_addr_hash(skb,\r\nnhoff + offsetof(struct ipv6hdr, daddr));\r\nnhoff += sizeof(struct ipv6hdr);\r\nskb->cb[0] = nhoff;\r\nparse_ip_proto(skb, g, ip_proto);\r\nreturn 0;\r\n}\r\nPROG(PARSE_VLAN)(struct __sk_buff *skb)\r\n{\r\n__u32 nhoff, proto;\r\nnhoff = skb->cb[0];\r\nproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\r\nh_vlan_encapsulated_proto));\r\nnhoff += sizeof(struct vlan_hdr);\r\nskb->cb[0] = nhoff;\r\nparse_eth_proto(skb, proto);\r\nreturn 0;\r\n}\r\nPROG(PARSE_MPLS)(struct __sk_buff *skb)\r\n{\r\n__u32 nhoff, label;\r\nnhoff = skb->cb[0];\r\nlabel = load_word(skb, nhoff);\r\nnhoff += sizeof(struct mpls_label);\r\nskb->cb[0] = nhoff;\r\nif (label & MPLS_LS_S_MASK) {\r\n__u8 verlen = load_byte(skb, nhoff);\r\nif ((verlen & 0xF0) == 4)\r\nparse_eth_proto(skb, ETH_P_IP);\r\nelse\r\nparse_eth_proto(skb, ETH_P_IPV6);\r\n} else {\r\nparse_eth_proto(skb, ETH_P_MPLS_UC);\r\n}\r\nreturn 0;\r\n}\r\nint main_prog(struct __sk_buff *skb)\r\n{\r\n__u32 nhoff = ETH_HLEN;\r\n__u32 proto = load_half(skb, 12);\r\nskb->cb[0] = nhoff;\r\nparse_eth_proto(skb, proto);\r\nreturn 0;\r\n}
