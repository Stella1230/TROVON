static int omap_vout_allocate_vrfb_buffers(struct omap_vout_device *vout,\r\nunsigned int *count, int startindex)\r\n{\r\nint i, j;\r\nfor (i = 0; i < *count; i++) {\r\nif (!vout->smsshado_virt_addr[i]) {\r\nvout->smsshado_virt_addr[i] =\r\nomap_vout_alloc_buffer(vout->smsshado_size,\r\n&vout->smsshado_phy_addr[i]);\r\n}\r\nif (!vout->smsshado_virt_addr[i] && startindex != -1) {\r\nif (V4L2_MEMORY_MMAP == vout->memory && i >= startindex)\r\nbreak;\r\n}\r\nif (!vout->smsshado_virt_addr[i]) {\r\nfor (j = 0; j < i; j++) {\r\nomap_vout_free_buffer(\r\nvout->smsshado_virt_addr[j],\r\nvout->smsshado_size);\r\nvout->smsshado_virt_addr[j] = 0;\r\nvout->smsshado_phy_addr[j] = 0;\r\n}\r\n*count = 0;\r\nreturn -ENOMEM;\r\n}\r\nmemset((void *) vout->smsshado_virt_addr[i], 0,\r\nvout->smsshado_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_vout_vrfb_dma_tx_callback(int lch, u16 ch_status, void *data)\r\n{\r\nstruct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;\r\nt->tx_status = 1;\r\nwake_up_interruptible(&t->wait);\r\n}\r\nvoid omap_vout_free_vrfb_buffers(struct omap_vout_device *vout)\r\n{\r\nint j;\r\nfor (j = 0; j < VRFB_NUM_BUFS; j++) {\r\nif (vout->smsshado_virt_addr[j]) {\r\nomap_vout_free_buffer(vout->smsshado_virt_addr[j],\r\nvout->smsshado_size);\r\nvout->smsshado_virt_addr[j] = 0;\r\nvout->smsshado_phy_addr[j] = 0;\r\n}\r\n}\r\n}\r\nint omap_vout_setup_vrfb_bufs(struct platform_device *pdev, int vid_num,\r\nbool static_vrfb_allocation)\r\n{\r\nint ret = 0, i, j;\r\nstruct omap_vout_device *vout;\r\nstruct video_device *vfd;\r\nint image_width, image_height;\r\nint vrfb_num_bufs = VRFB_NUM_BUFS;\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct omap2video_device *vid_dev =\r\ncontainer_of(v4l2_dev, struct omap2video_device, v4l2_dev);\r\nvout = vid_dev->vouts[vid_num];\r\nvfd = vout->vfd;\r\nfor (i = 0; i < VRFB_NUM_BUFS; i++) {\r\nif (omap_vrfb_request_ctx(&vout->vrfb_context[i])) {\r\ndev_info(&pdev->dev, ": VRFB allocation failed\n");\r\nfor (j = 0; j < i; j++)\r\nomap_vrfb_release_ctx(&vout->vrfb_context[j]);\r\nret = -ENOMEM;\r\ngoto free_buffers;\r\n}\r\n}\r\nimage_width = VID_MAX_WIDTH / TILE_SIZE;\r\nif (VID_MAX_WIDTH % TILE_SIZE)\r\nimage_width++;\r\nimage_width = image_width * TILE_SIZE;\r\nimage_height = VID_MAX_HEIGHT / TILE_SIZE;\r\nif (VID_MAX_HEIGHT % TILE_SIZE)\r\nimage_height++;\r\nimage_height = image_height * TILE_SIZE;\r\nvout->smsshado_size = PAGE_ALIGN(image_width * image_height * 2 * 2);\r\nvout->vrfb_dma_tx.dev_id = OMAP_DMA_NO_DEVICE;\r\nvout->vrfb_dma_tx.dma_ch = -1;\r\nvout->vrfb_dma_tx.req_status = DMA_CHAN_ALLOTED;\r\nret = omap_request_dma(vout->vrfb_dma_tx.dev_id, "VRFB DMA TX",\r\nomap_vout_vrfb_dma_tx_callback,\r\n(void *) &vout->vrfb_dma_tx, &vout->vrfb_dma_tx.dma_ch);\r\nif (ret < 0) {\r\nvout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;\r\ndev_info(&pdev->dev,\r\n": failed to allocate DMA Channel for video%d\n",\r\nvfd->minor);\r\n}\r\ninit_waitqueue_head(&vout->vrfb_dma_tx.wait);\r\nif (static_vrfb_allocation) {\r\nif (omap_vout_allocate_vrfb_buffers(vout, &vrfb_num_bufs, -1)) {\r\nret = -ENOMEM;\r\ngoto release_vrfb_ctx;\r\n}\r\nvout->vrfb_static_allocation = true;\r\n}\r\nreturn 0;\r\nrelease_vrfb_ctx:\r\nfor (j = 0; j < VRFB_NUM_BUFS; j++)\r\nomap_vrfb_release_ctx(&vout->vrfb_context[j]);\r\nfree_buffers:\r\nomap_vout_free_buffers(vout);\r\nreturn ret;\r\n}\r\nvoid omap_vout_release_vrfb(struct omap_vout_device *vout)\r\n{\r\nint i;\r\nfor (i = 0; i < VRFB_NUM_BUFS; i++)\r\nomap_vrfb_release_ctx(&vout->vrfb_context[i]);\r\nif (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {\r\nvout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;\r\nomap_free_dma(vout->vrfb_dma_tx.dma_ch);\r\n}\r\n}\r\nint omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,\r\nunsigned int *count, unsigned int startindex)\r\n{\r\nint i;\r\nbool yuv_mode;\r\nif (!is_rotation_enabled(vout))\r\nreturn 0;\r\n*count = *count > VRFB_NUM_BUFS ? VRFB_NUM_BUFS : *count;\r\nif (!vout->vrfb_static_allocation)\r\nif (omap_vout_allocate_vrfb_buffers(vout, count, startindex))\r\nreturn -ENOMEM;\r\nif (vout->dss_mode == OMAP_DSS_COLOR_YUV2 ||\r\nvout->dss_mode == OMAP_DSS_COLOR_UYVY)\r\nyuv_mode = true;\r\nelse\r\nyuv_mode = false;\r\nfor (i = 0; i < *count; i++)\r\nomap_vrfb_setup(&vout->vrfb_context[i],\r\nvout->smsshado_phy_addr[i], vout->pix.width,\r\nvout->pix.height, vout->bpp, yuv_mode);\r\nreturn 0;\r\n}\r\nint omap_vout_prepare_vrfb(struct omap_vout_device *vout,\r\nstruct videobuf_buffer *vb)\r\n{\r\ndma_addr_t dmabuf;\r\nstruct vid_vrfb_dma *tx;\r\nenum dss_rotation rotation;\r\nu32 dest_frame_index = 0, src_element_index = 0;\r\nu32 dest_element_index = 0, src_frame_index = 0;\r\nu32 elem_count = 0, frame_count = 0, pixsize = 2;\r\nif (!is_rotation_enabled(vout))\r\nreturn 0;\r\ndmabuf = vout->buf_phy_addr[vb->i];\r\npixsize = vout->bpp * vout->vrfb_bpp;\r\ndest_frame_index = ((MAX_PIXELS_PER_LINE * pixsize) -\r\n(vout->pix.width * vout->bpp)) + 1;\r\nsrc_element_index = 0;\r\nsrc_frame_index = 0;\r\ndest_element_index = 1;\r\nelem_count = vout->pix.width * vout->bpp;\r\nframe_count = vout->pix.height;\r\ntx = &vout->vrfb_dma_tx;\r\ntx->tx_status = 0;\r\nomap_set_dma_transfer_params(tx->dma_ch, OMAP_DMA_DATA_TYPE_S32,\r\n(elem_count / 4), frame_count, OMAP_DMA_SYNC_ELEMENT,\r\ntx->dev_id, 0x0);\r\nomap_set_dma_src_params(tx->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,\r\ndmabuf, src_element_index, src_frame_index);\r\nomap_set_dma_src_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);\r\nrotation = calc_rotation(vout);\r\nomap_set_dma_dest_params(tx->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,\r\nvout->vrfb_context[vb->i].paddr[0], dest_element_index,\r\ndest_frame_index);\r\nomap_set_dma_dest_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);\r\nomap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);\r\nomap_start_dma(tx->dma_ch);\r\nwait_event_interruptible_timeout(tx->wait, tx->tx_status == 1,\r\nVRFB_TX_TIMEOUT);\r\nif (tx->tx_status == 0) {\r\nomap_stop_dma(tx->dma_ch);\r\nreturn -EINVAL;\r\n}\r\nvout->queued_buf_addr[vb->i] = (u8 *)\r\nvout->vrfb_context[vb->i].paddr[rotation];\r\nreturn 0;\r\n}\r\nvoid omap_vout_calculate_vrfb_offset(struct omap_vout_device *vout)\r\n{\r\nenum dss_rotation rotation;\r\nbool mirroring = vout->mirror;\r\nstruct v4l2_rect *crop = &vout->crop;\r\nstruct v4l2_pix_format *pix = &vout->pix;\r\nint *cropped_offset = &vout->cropped_offset;\r\nint vr_ps = 1, ps = 2, temp_ps = 2;\r\nint offset = 0, ctop = 0, cleft = 0, line_length = 0;\r\nrotation = calc_rotation(vout);\r\nif (V4L2_PIX_FMT_YUYV == pix->pixelformat ||\r\nV4L2_PIX_FMT_UYVY == pix->pixelformat) {\r\nif (is_rotation_enabled(vout)) {\r\nps = 4;\r\nvr_ps = 2;\r\n} else {\r\nps = 2;\r\n}\r\n} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {\r\nps = 4;\r\n} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {\r\nps = 3;\r\n}\r\nvout->ps = ps;\r\nvout->vr_ps = vr_ps;\r\nif (is_rotation_enabled(vout)) {\r\nline_length = MAX_PIXELS_PER_LINE;\r\nctop = (pix->height - crop->height) - crop->top;\r\ncleft = (pix->width - crop->width) - crop->left;\r\n} else {\r\nline_length = pix->width;\r\n}\r\nvout->line_length = line_length;\r\nswitch (rotation) {\r\ncase dss_rotation_90_degree:\r\noffset = vout->vrfb_context[0].yoffset *\r\nvout->vrfb_context[0].bytespp;\r\ntemp_ps = ps / vr_ps;\r\nif (!mirroring) {\r\n*cropped_offset = offset + line_length *\r\ntemp_ps * cleft + crop->top * temp_ps;\r\n} else {\r\n*cropped_offset = offset + line_length * temp_ps *\r\ncleft + crop->top * temp_ps + (line_length *\r\n((crop->width / (vr_ps)) - 1) * ps);\r\n}\r\nbreak;\r\ncase dss_rotation_180_degree:\r\noffset = ((MAX_PIXELS_PER_LINE * vout->vrfb_context[0].yoffset *\r\nvout->vrfb_context[0].bytespp) +\r\n(vout->vrfb_context[0].xoffset *\r\nvout->vrfb_context[0].bytespp));\r\nif (!mirroring) {\r\n*cropped_offset = offset + (line_length * ps * ctop) +\r\n(cleft / vr_ps) * ps;\r\n} else {\r\n*cropped_offset = offset + (line_length * ps * ctop) +\r\n(cleft / vr_ps) * ps + (line_length *\r\n(crop->height - 1) * ps);\r\n}\r\nbreak;\r\ncase dss_rotation_270_degree:\r\noffset = MAX_PIXELS_PER_LINE * vout->vrfb_context[0].xoffset *\r\nvout->vrfb_context[0].bytespp;\r\ntemp_ps = ps / vr_ps;\r\nif (!mirroring) {\r\n*cropped_offset = offset + line_length *\r\ntemp_ps * crop->left + ctop * ps;\r\n} else {\r\n*cropped_offset = offset + line_length *\r\ntemp_ps * crop->left + ctop * ps +\r\n(line_length * ((crop->width / vr_ps) - 1) *\r\nps);\r\n}\r\nbreak;\r\ncase dss_rotation_0_degree:\r\nif (!mirroring) {\r\n*cropped_offset = (line_length * ps) *\r\ncrop->top + (crop->left / vr_ps) * ps;\r\n} else {\r\n*cropped_offset = (line_length * ps) *\r\ncrop->top + (crop->left / vr_ps) * ps +\r\n(line_length * (crop->height - 1) * ps);\r\n}\r\nbreak;\r\ndefault:\r\n*cropped_offset = (line_length * ps * crop->top) /\r\nvr_ps + (crop->left * ps) / vr_ps +\r\n((crop->width / vr_ps) - 1) * ps;\r\nbreak;\r\n}\r\n}
