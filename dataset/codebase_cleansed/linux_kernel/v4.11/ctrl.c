static int\r\nnvkm_control_mthd_pstate_info(struct nvkm_control *ctrl, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_info_v0 v0;\r\n} *args = data;\r\nstruct nvkm_clk *clk = ctrl->device->clk;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(&ctrl->object, "control pstate info size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(&ctrl->object, "control pstate info vers %d\n",\r\nargs->v0.version);\r\n} else\r\nreturn ret;\r\nif (clk) {\r\nargs->v0.count = clk->state_nr;\r\nargs->v0.ustate_ac = clk->ustate_ac;\r\nargs->v0.ustate_dc = clk->ustate_dc;\r\nargs->v0.pwrsrc = clk->pwrsrc;\r\nargs->v0.pstate = clk->pstate;\r\n} else {\r\nargs->v0.count = 0;\r\nargs->v0.ustate_ac = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\r\nargs->v0.ustate_dc = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\r\nargs->v0.pwrsrc = -ENOSYS;\r\nargs->v0.pstate = NVIF_CONTROL_PSTATE_INFO_V0_PSTATE_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_control_mthd_pstate_attr(struct nvkm_control *ctrl, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_attr_v0 v0;\r\n} *args = data;\r\nstruct nvkm_clk *clk = ctrl->device->clk;\r\nconst struct nvkm_domain *domain;\r\nstruct nvkm_pstate *pstate;\r\nstruct nvkm_cstate *cstate;\r\nint i = 0, j = -1;\r\nu32 lo, hi;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(&ctrl->object, "control pstate attr size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(&ctrl->object,\r\n"control pstate attr vers %d state %d index %d\n",\r\nargs->v0.version, args->v0.state, args->v0.index);\r\nif (!clk)\r\nreturn -ENODEV;\r\nif (args->v0.state < NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT)\r\nreturn -EINVAL;\r\nif (args->v0.state >= clk->state_nr)\r\nreturn -EINVAL;\r\n} else\r\nreturn ret;\r\ndomain = clk->domains;\r\nwhile (domain->name != nv_clk_src_max) {\r\nif (domain->mname && ++j == args->v0.index)\r\nbreak;\r\ndomain++;\r\n}\r\nif (domain->name == nv_clk_src_max)\r\nreturn -EINVAL;\r\nif (args->v0.state != NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT) {\r\nlist_for_each_entry(pstate, &clk->states, head) {\r\nif (i++ == args->v0.state)\r\nbreak;\r\n}\r\nlo = pstate->base.domain[domain->name];\r\nhi = lo;\r\nlist_for_each_entry(cstate, &pstate->list, head) {\r\nlo = min(lo, cstate->domain[domain->name]);\r\nhi = max(hi, cstate->domain[domain->name]);\r\n}\r\nargs->v0.state = pstate->pstate;\r\n} else {\r\nlo = max(nvkm_clk_read(clk, domain->name), 0);\r\nhi = lo;\r\n}\r\nsnprintf(args->v0.name, sizeof(args->v0.name), "%s", domain->mname);\r\nsnprintf(args->v0.unit, sizeof(args->v0.unit), "MHz");\r\nargs->v0.min = lo / domain->mdiv;\r\nargs->v0.max = hi / domain->mdiv;\r\nargs->v0.index = 0;\r\nwhile ((++domain)->name != nv_clk_src_max) {\r\nif (domain->mname) {\r\nargs->v0.index = ++j;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_control_mthd_pstate_user(struct nvkm_control *ctrl, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_control_pstate_user_v0 v0;\r\n} *args = data;\r\nstruct nvkm_clk *clk = ctrl->device->clk;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(&ctrl->object, "control pstate user size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(&ctrl->object,\r\n"control pstate user vers %d ustate %d pwrsrc %d\n",\r\nargs->v0.version, args->v0.ustate, args->v0.pwrsrc);\r\nif (!clk)\r\nreturn -ENODEV;\r\n} else\r\nreturn ret;\r\nif (args->v0.pwrsrc >= 0) {\r\nret |= nvkm_clk_ustate(clk, args->v0.ustate, args->v0.pwrsrc);\r\n} else {\r\nret |= nvkm_clk_ustate(clk, args->v0.ustate, 0);\r\nret |= nvkm_clk_ustate(clk, args->v0.ustate, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_control_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\r\n{\r\nstruct nvkm_control *ctrl = nvkm_control(object);\r\nswitch (mthd) {\r\ncase NVIF_CONTROL_PSTATE_INFO:\r\nreturn nvkm_control_mthd_pstate_info(ctrl, data, size);\r\ncase NVIF_CONTROL_PSTATE_ATTR:\r\nreturn nvkm_control_mthd_pstate_attr(ctrl, data, size);\r\ncase NVIF_CONTROL_PSTATE_USER:\r\nreturn nvkm_control_mthd_pstate_user(ctrl, data, size);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnvkm_control_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nstruct nvkm_control *ctrl;\r\nif (!(ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &ctrl->object;\r\nctrl->device = device;\r\nnvkm_object_ctor(&nvkm_control, oclass, &ctrl->object);\r\nreturn 0;\r\n}
