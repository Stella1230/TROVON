static int vss_do_freeze(char *dir, unsigned int cmd)\r\n{\r\nint ret, fd = open(dir, O_RDONLY);\r\nif (fd < 0)\r\nreturn 1;\r\nret = ioctl(fd, cmd, 0);\r\nif (ret) {\r\nif ((cmd == FIFREEZE && errno == EBUSY) ||\r\n(cmd == FITHAW && errno == EINVAL)) {\r\nclose(fd);\r\nreturn 0;\r\n}\r\n}\r\nclose(fd);\r\nreturn !!ret;\r\n}\r\nstatic int vss_operate(int operation)\r\n{\r\nchar match[] = "/dev/";\r\nFILE *mounts;\r\nstruct mntent *ent;\r\nchar errdir[1024] = {0};\r\nunsigned int cmd;\r\nint error = 0, root_seen = 0, save_errno = 0;\r\nswitch (operation) {\r\ncase VSS_OP_FREEZE:\r\ncmd = FIFREEZE;\r\nbreak;\r\ncase VSS_OP_THAW:\r\ncmd = FITHAW;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmounts = setmntent("/proc/mounts", "r");\r\nif (mounts == NULL)\r\nreturn -1;\r\nwhile ((ent = getmntent(mounts))) {\r\nif (strncmp(ent->mnt_fsname, match, strlen(match)))\r\ncontinue;\r\nif (hasmntopt(ent, MNTOPT_RO) != NULL)\r\ncontinue;\r\nif (strcmp(ent->mnt_type, "vfat") == 0)\r\ncontinue;\r\nif (strcmp(ent->mnt_dir, "/") == 0) {\r\nroot_seen = 1;\r\ncontinue;\r\n}\r\nerror |= vss_do_freeze(ent->mnt_dir, cmd);\r\nif (error && operation == VSS_OP_FREEZE)\r\ngoto err;\r\n}\r\nendmntent(mounts);\r\nif (root_seen) {\r\nerror |= vss_do_freeze("/", cmd);\r\nif (error && operation == VSS_OP_FREEZE)\r\ngoto err;\r\n}\r\ngoto out;\r\nerr:\r\nsave_errno = errno;\r\nif (ent) {\r\nstrncpy(errdir, ent->mnt_dir, sizeof(errdir)-1);\r\nendmntent(mounts);\r\n}\r\nvss_operate(VSS_OP_THAW);\r\nif (ent)\r\nsyslog(LOG_ERR, "FREEZE of %s failed; error:%d %s",\r\nerrdir, save_errno, strerror(save_errno));\r\nelse\r\nsyslog(LOG_ERR, "FREEZE of / failed; error:%d %s", save_errno,\r\nstrerror(save_errno));\r\nout:\r\nreturn error;\r\n}\r\nvoid print_usage(char *argv[])\r\n{\r\nfprintf(stderr, "Usage: %s [options]\n"\r\n"Options are:\n"\r\n" -n, --no-daemon stay in foreground, don't daemonize\n"\r\n" -h, --help print this help\n", argv[0]);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint vss_fd, len;\r\nint error;\r\nstruct pollfd pfd;\r\nint op;\r\nstruct hv_vss_msg vss_msg[1];\r\nint daemonize = 1, long_index = 0, opt;\r\nint in_handshake = 1;\r\n__u32 kernel_modver;\r\nstatic struct option long_options[] = {\r\n{"help", no_argument, 0, 'h' },\r\n{"no-daemon", no_argument, 0, 'n' },\r\n{0, 0, 0, 0 }\r\n};\r\nwhile ((opt = getopt_long(argc, argv, "hn", long_options,\r\n&long_index)) != -1) {\r\nswitch (opt) {\r\ncase 'n':\r\ndaemonize = 0;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nprint_usage(argv);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nif (daemonize && daemon(1, 0))\r\nreturn 1;\r\nopenlog("Hyper-V VSS", 0, LOG_USER);\r\nsyslog(LOG_INFO, "VSS starting; pid is:%d", getpid());\r\nvss_fd = open("/dev/vmbus/hv_vss", O_RDWR);\r\nif (vss_fd < 0) {\r\nsyslog(LOG_ERR, "open /dev/vmbus/hv_vss failed; error: %d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nvss_msg->vss_hdr.operation = VSS_OP_REGISTER1;\r\nlen = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "registration to kernel failed; error: %d %s",\r\nerrno, strerror(errno));\r\nclose(vss_fd);\r\nexit(EXIT_FAILURE);\r\n}\r\npfd.fd = vss_fd;\r\nwhile (1) {\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\nif (poll(&pfd, 1, -1) < 0) {\r\nsyslog(LOG_ERR, "poll failed; error:%d %s", errno, strerror(errno));\r\nif (errno == EINVAL) {\r\nclose(vss_fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nelse\r\ncontinue;\r\n}\r\nlen = read(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\r\nif (in_handshake) {\r\nif (len != sizeof(kernel_modver)) {\r\nsyslog(LOG_ERR, "invalid version negotiation");\r\nexit(EXIT_FAILURE);\r\n}\r\nkernel_modver = *(__u32 *)vss_msg;\r\nin_handshake = 0;\r\nsyslog(LOG_INFO, "VSS: kernel module version: %d",\r\nkernel_modver);\r\ncontinue;\r\n}\r\nif (len != sizeof(struct hv_vss_msg)) {\r\nsyslog(LOG_ERR, "read failed; error:%d %s",\r\nerrno, strerror(errno));\r\nclose(vss_fd);\r\nreturn EXIT_FAILURE;\r\n}\r\nop = vss_msg->vss_hdr.operation;\r\nerror = HV_S_OK;\r\nswitch (op) {\r\ncase VSS_OP_FREEZE:\r\ncase VSS_OP_THAW:\r\nerror = vss_operate(op);\r\nsyslog(LOG_INFO, "VSS: op=%s: %s\n",\r\nop == VSS_OP_FREEZE ? "FREEZE" : "THAW",\r\nerror ? "failed" : "succeeded");\r\nif (error) {\r\nerror = HV_E_FAIL;\r\nsyslog(LOG_ERR, "op=%d failed!", op);\r\nsyslog(LOG_ERR, "report it with these files:");\r\nsyslog(LOG_ERR, "/etc/fstab and /proc/mounts");\r\n}\r\nbreak;\r\ncase VSS_OP_HOT_BACKUP:\r\nsyslog(LOG_INFO, "VSS: op=CHECK HOT BACKUP\n");\r\nbreak;\r\ndefault:\r\nsyslog(LOG_ERR, "Illegal op:%d\n", op);\r\n}\r\nvss_msg->error = error;\r\nlen = write(vss_fd, vss_msg, sizeof(struct hv_vss_msg));\r\nif (len != sizeof(struct hv_vss_msg)) {\r\nsyslog(LOG_ERR, "write failed; error: %d %s", errno,\r\nstrerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nclose(vss_fd);\r\nexit(0);\r\n}
