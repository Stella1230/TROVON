static void msm_hdmi_phy_reset(struct hdmi *hdmi)\r\n{\r\nunsigned int val;\r\nval = hdmi_read(hdmi, REG_HDMI_PHY_CTRL);\r\nif (val & HDMI_PHY_CTRL_SW_RESET_LOW) {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval & ~HDMI_PHY_CTRL_SW_RESET);\r\n} else {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval | HDMI_PHY_CTRL_SW_RESET);\r\n}\r\nif (val & HDMI_PHY_CTRL_SW_RESET_PLL_LOW) {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval & ~HDMI_PHY_CTRL_SW_RESET_PLL);\r\n} else {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval | HDMI_PHY_CTRL_SW_RESET_PLL);\r\n}\r\nmsleep(100);\r\nif (val & HDMI_PHY_CTRL_SW_RESET_LOW) {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval | HDMI_PHY_CTRL_SW_RESET);\r\n} else {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval & ~HDMI_PHY_CTRL_SW_RESET);\r\n}\r\nif (val & HDMI_PHY_CTRL_SW_RESET_PLL_LOW) {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval | HDMI_PHY_CTRL_SW_RESET_PLL);\r\n} else {\r\nhdmi_write(hdmi, REG_HDMI_PHY_CTRL,\r\nval & ~HDMI_PHY_CTRL_SW_RESET_PLL);\r\n}\r\n}\r\nstatic int gpio_config(struct hdmi *hdmi, bool on)\r\n{\r\nstruct device *dev = &hdmi->pdev->dev;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nint ret, i;\r\nif (on) {\r\nfor (i = 0; i < HDMI_MAX_NUM_GPIO; i++) {\r\nstruct hdmi_gpio_data gpio = config->gpios[i];\r\nif (gpio.num != -1) {\r\nret = gpio_request(gpio.num, gpio.label);\r\nif (ret) {\r\ndev_err(dev,\r\n"'%s'(%d) gpio_request failed: %d\n",\r\ngpio.label, gpio.num, ret);\r\ngoto err;\r\n}\r\nif (gpio.output) {\r\ngpio_direction_output(gpio.num,\r\ngpio.value);\r\n} else {\r\ngpio_direction_input(gpio.num);\r\ngpio_set_value_cansleep(gpio.num,\r\ngpio.value);\r\n}\r\n}\r\n}\r\nDBG("gpio on");\r\n} else {\r\nfor (i = 0; i < HDMI_MAX_NUM_GPIO; i++) {\r\nstruct hdmi_gpio_data gpio = config->gpios[i];\r\nif (gpio.num == -1)\r\ncontinue;\r\nif (gpio.output) {\r\nint value = gpio.value ? 0 : 1;\r\ngpio_set_value_cansleep(gpio.num, value);\r\n}\r\ngpio_free(gpio.num);\r\n};\r\nDBG("gpio off");\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (i--) {\r\nif (config->gpios[i].num != -1)\r\ngpio_free(config->gpios[i].num);\r\n}\r\nreturn ret;\r\n}\r\nstatic int hpd_enable(struct hdmi_connector *hdmi_connector)\r\n{\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct device *dev = &hdmi->pdev->dev;\r\nuint32_t hpd_ctrl;\r\nint i, ret;\r\nunsigned long flags;\r\nfor (i = 0; i < config->hpd_reg_cnt; i++) {\r\nret = regulator_enable(hdmi->hpd_regs[i]);\r\nif (ret) {\r\ndev_err(dev, "failed to enable hpd regulator: %s (%d)\n",\r\nconfig->hpd_reg_names[i], ret);\r\ngoto fail;\r\n}\r\n}\r\nret = pinctrl_pm_select_default_state(dev);\r\nif (ret) {\r\ndev_err(dev, "pinctrl state chg failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = gpio_config(hdmi, true);\r\nif (ret) {\r\ndev_err(dev, "failed to configure GPIOs: %d\n", ret);\r\ngoto fail;\r\n}\r\nfor (i = 0; i < config->hpd_clk_cnt; i++) {\r\nif (config->hpd_freq && config->hpd_freq[i]) {\r\nret = clk_set_rate(hdmi->hpd_clks[i],\r\nconfig->hpd_freq[i]);\r\nif (ret)\r\ndev_warn(dev, "failed to set clk %s (%d)\n",\r\nconfig->hpd_clk_names[i], ret);\r\n}\r\nret = clk_prepare_enable(hdmi->hpd_clks[i]);\r\nif (ret) {\r\ndev_err(dev, "failed to enable hpd clk: %s (%d)\n",\r\nconfig->hpd_clk_names[i], ret);\r\ngoto fail;\r\n}\r\n}\r\nmsm_hdmi_set_mode(hdmi, false);\r\nmsm_hdmi_phy_reset(hdmi);\r\nmsm_hdmi_set_mode(hdmi, true);\r\nhdmi_write(hdmi, REG_HDMI_USEC_REFTIMER, 0x0001001b);\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\r\nHDMI_HPD_INT_CTRL_INT_CONNECT |\r\nHDMI_HPD_INT_CTRL_INT_EN);\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nhpd_ctrl = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nhpd_ctrl |= HDMI_HPD_CTRL_TIMEOUT(0x1fff);\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL,\r\n~HDMI_HPD_CTRL_ENABLE & hpd_ctrl);\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL,\r\nHDMI_HPD_CTRL_ENABLE | hpd_ctrl);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void hdp_disable(struct hdmi_connector *hdmi_connector)\r\n{\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct device *dev = &hdmi->pdev->dev;\r\nint i, ret = 0;\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, 0);\r\nmsm_hdmi_set_mode(hdmi, false);\r\nfor (i = 0; i < config->hpd_clk_cnt; i++)\r\nclk_disable_unprepare(hdmi->hpd_clks[i]);\r\nret = gpio_config(hdmi, false);\r\nif (ret)\r\ndev_warn(dev, "failed to unconfigure GPIOs: %d\n", ret);\r\nret = pinctrl_pm_select_sleep_state(dev);\r\nif (ret)\r\ndev_warn(dev, "pinctrl state chg failed: %d\n", ret);\r\nfor (i = 0; i < config->hpd_reg_cnt; i++) {\r\nret = regulator_disable(hdmi->hpd_regs[i]);\r\nif (ret)\r\ndev_warn(dev, "failed to disable hpd regulator: %s (%d)\n",\r\nconfig->hpd_reg_names[i], ret);\r\n}\r\n}\r\nstatic void\r\nmsm_hdmi_hotplug_work(struct work_struct *work)\r\n{\r\nstruct hdmi_connector *hdmi_connector =\r\ncontainer_of(work, struct hdmi_connector, hpd_work);\r\nstruct drm_connector *connector = &hdmi_connector->base;\r\ndrm_helper_hpd_irq_event(connector->dev);\r\n}\r\nvoid msm_hdmi_connector_irq(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nuint32_t hpd_int_status, hpd_int_ctrl;\r\nhpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\r\nhpd_int_ctrl = hdmi_read(hdmi, REG_HDMI_HPD_INT_CTRL);\r\nif ((hpd_int_ctrl & HDMI_HPD_INT_CTRL_INT_EN) &&\r\n(hpd_int_status & HDMI_HPD_INT_STATUS_INT)) {\r\nbool detected = !!(hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED);\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\r\nHDMI_HPD_INT_CTRL_INT_ACK);\r\nDBG("status=%04x, ctrl=%04x", hpd_int_status, hpd_int_ctrl);\r\nhpd_int_ctrl = HDMI_HPD_INT_CTRL_INT_EN;\r\nif (!detected)\r\nhpd_int_ctrl |= HDMI_HPD_INT_CTRL_INT_CONNECT;\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, hpd_int_ctrl);\r\nqueue_work(hdmi->workq, &hdmi_connector->hpd_work);\r\n}\r\n}\r\nstatic enum drm_connector_status detect_reg(struct hdmi *hdmi)\r\n{\r\nuint32_t hpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\r\nreturn (hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status detect_gpio(struct hdmi *hdmi)\r\n{\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct hdmi_gpio_data hpd_gpio = config->gpios[HPD_GPIO_INDEX];\r\nreturn gpio_get_value(hpd_gpio.num) ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status hdmi_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct hdmi_gpio_data hpd_gpio = config->gpios[HPD_GPIO_INDEX];\r\nenum drm_connector_status stat_gpio, stat_reg;\r\nint retry = 20;\r\nif (hpd_gpio.num == -1)\r\nreturn detect_reg(hdmi);\r\ndo {\r\nstat_gpio = detect_gpio(hdmi);\r\nstat_reg = detect_reg(hdmi);\r\nif (stat_gpio == stat_reg)\r\nbreak;\r\nmdelay(10);\r\n} while (--retry);\r\nif (stat_gpio != stat_reg) {\r\nDBG("HDMI_HPD_INT_STATUS tells us: %d", stat_reg);\r\nDBG("hpd gpio tells us: %d", stat_gpio);\r\n}\r\nreturn stat_gpio;\r\n}\r\nstatic void hdmi_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nhdp_disable(hdmi_connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(hdmi_connector);\r\n}\r\nstatic int msm_hdmi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nstruct edid *edid;\r\nuint32_t hdmi_ctrl;\r\nint ret = 0;\r\nhdmi_ctrl = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nhdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl | HDMI_CTRL_ENABLE);\r\nedid = drm_get_edid(connector, hdmi->i2c);\r\nhdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl);\r\nhdmi->hdmi_mode = drm_detect_hdmi_monitor(edid);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nif (edid) {\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int msm_hdmi_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nlong actual, requested;\r\nrequested = 1000 * mode->clock;\r\nactual = kms->funcs->round_pixclk(kms,\r\nrequested, hdmi_connector->hdmi->encoder);\r\nif (config->pwr_clk_cnt > 0)\r\nactual = clk_round_rate(hdmi->pwr_clks[0], actual);\r\nDBG("requested=%ld, actual=%ld", requested, actual);\r\nif (actual != requested)\r\nreturn MODE_CLOCK_RANGE;\r\nreturn 0;\r\n}\r\nstruct drm_connector *msm_hdmi_connector_init(struct hdmi *hdmi)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct hdmi_connector *hdmi_connector;\r\nint ret;\r\nhdmi_connector = kzalloc(sizeof(*hdmi_connector), GFP_KERNEL);\r\nif (!hdmi_connector)\r\nreturn ERR_PTR(-ENOMEM);\r\nhdmi_connector->hdmi = hdmi;\r\nINIT_WORK(&hdmi_connector->hpd_work, msm_hdmi_hotplug_work);\r\nconnector = &hdmi_connector->base;\r\ndrm_connector_init(hdmi->dev, connector, &hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\ndrm_connector_helper_add(connector, &msm_hdmi_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nret = hpd_enable(hdmi_connector);\r\nif (ret) {\r\ndev_err(&hdmi->pdev->dev, "failed to enable HPD: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\ndrm_mode_connector_attach_encoder(connector, hdmi->encoder);\r\nreturn connector;\r\n}
