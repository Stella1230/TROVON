static int fpga_region_of_node_match(struct device *dev, const void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstatic struct fpga_region *fpga_region_find(struct device_node *np)\r\n{\r\nstruct device *dev;\r\ndev = class_find_device(fpga_region_class, NULL, np,\r\nfpga_region_of_node_match);\r\nif (!dev)\r\nreturn NULL;\r\nreturn to_fpga_region(dev);\r\n}\r\nstatic struct fpga_region *fpga_region_get(struct fpga_region *region)\r\n{\r\nstruct device *dev = &region->dev;\r\nif (!mutex_trylock(&region->mutex)) {\r\ndev_dbg(dev, "%s: FPGA Region already in use\n", __func__);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nget_device(dev);\r\nof_node_get(dev->of_node);\r\nif (!try_module_get(dev->parent->driver->owner)) {\r\nof_node_put(dev->of_node);\r\nput_device(dev);\r\nmutex_unlock(&region->mutex);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ndev_dbg(&region->dev, "get\n");\r\nreturn region;\r\n}\r\nstatic void fpga_region_put(struct fpga_region *region)\r\n{\r\nstruct device *dev = &region->dev;\r\ndev_dbg(&region->dev, "put\n");\r\nmodule_put(dev->parent->driver->owner);\r\nof_node_put(dev->of_node);\r\nput_device(dev);\r\nmutex_unlock(&region->mutex);\r\n}\r\nstatic struct fpga_manager *fpga_region_get_manager(struct fpga_region *region)\r\n{\r\nstruct device *dev = &region->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *mgr_node;\r\nstruct fpga_manager *mgr;\r\nof_node_get(np);\r\nwhile (np) {\r\nif (of_device_is_compatible(np, "fpga-region")) {\r\nmgr_node = of_parse_phandle(np, "fpga-mgr", 0);\r\nif (mgr_node) {\r\nmgr = of_fpga_mgr_get(mgr_node);\r\nof_node_put(np);\r\nreturn mgr;\r\n}\r\n}\r\nnp = of_get_next_parent(np);\r\n}\r\nof_node_put(np);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int fpga_region_get_bridges(struct fpga_region *region,\r\nstruct device_node *overlay)\r\n{\r\nstruct device *dev = &region->dev;\r\nstruct device_node *region_np = dev->of_node;\r\nstruct device_node *br, *np, *parent_br = NULL;\r\nint i, ret;\r\nret = fpga_bridge_get_to_list(region_np->parent, region->info,\r\n&region->bridge_list);\r\nif (ret == -EBUSY)\r\nreturn ret;\r\nif (!ret)\r\nparent_br = region_np->parent;\r\nif (of_parse_phandle(overlay, "fpga-bridges", 0))\r\nnp = overlay;\r\nelse\r\nnp = region_np;\r\nfor (i = 0; ; i++) {\r\nbr = of_parse_phandle(np, "fpga-bridges", i);\r\nif (!br)\r\nbreak;\r\nif (br == parent_br)\r\ncontinue;\r\nret = fpga_bridge_get_to_list(br, region->info,\r\n&region->bridge_list);\r\nif (ret == -EBUSY) {\r\nfpga_bridges_put(&region->bridge_list);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_region_program_fpga(struct fpga_region *region,\r\nconst char *firmware_name,\r\nstruct device_node *overlay)\r\n{\r\nstruct fpga_manager *mgr;\r\nint ret;\r\nregion = fpga_region_get(region);\r\nif (IS_ERR(region)) {\r\npr_err("failed to get fpga region\n");\r\nreturn PTR_ERR(region);\r\n}\r\nmgr = fpga_region_get_manager(region);\r\nif (IS_ERR(mgr)) {\r\npr_err("failed to get fpga region manager\n");\r\nreturn PTR_ERR(mgr);\r\n}\r\nret = fpga_region_get_bridges(region, overlay);\r\nif (ret) {\r\npr_err("failed to get fpga region bridges\n");\r\ngoto err_put_mgr;\r\n}\r\nret = fpga_bridges_disable(&region->bridge_list);\r\nif (ret) {\r\npr_err("failed to disable region bridges\n");\r\ngoto err_put_br;\r\n}\r\nret = fpga_mgr_firmware_load(mgr, region->info, firmware_name);\r\nif (ret) {\r\npr_err("failed to load fpga image\n");\r\ngoto err_put_br;\r\n}\r\nret = fpga_bridges_enable(&region->bridge_list);\r\nif (ret) {\r\npr_err("failed to enable region bridges\n");\r\ngoto err_put_br;\r\n}\r\nfpga_mgr_put(mgr);\r\nfpga_region_put(region);\r\nreturn 0;\r\nerr_put_br:\r\nfpga_bridges_put(&region->bridge_list);\r\nerr_put_mgr:\r\nfpga_mgr_put(mgr);\r\nfpga_region_put(region);\r\nreturn ret;\r\n}\r\nstatic int child_regions_with_firmware(struct device_node *overlay)\r\n{\r\nstruct device_node *child_region;\r\nconst char *child_firmware_name;\r\nint ret = 0;\r\nof_node_get(overlay);\r\nchild_region = of_find_matching_node(overlay, fpga_region_of_match);\r\nwhile (child_region) {\r\nif (!of_property_read_string(child_region, "firmware-name",\r\n&child_firmware_name)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nchild_region = of_find_matching_node(child_region,\r\nfpga_region_of_match);\r\n}\r\nof_node_put(child_region);\r\nif (ret)\r\npr_err("firmware-name not allowed in child FPGA region: %s",\r\nchild_region->full_name);\r\nreturn ret;\r\n}\r\nstatic int fpga_region_notify_pre_apply(struct fpga_region *region,\r\nstruct of_overlay_notify_data *nd)\r\n{\r\nconst char *firmware_name = NULL;\r\nstruct fpga_image_info *info;\r\nint ret;\r\ninfo = devm_kzalloc(&region->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nregion->info = info;\r\nret = child_regions_with_firmware(nd->overlay);\r\nif (ret)\r\nreturn ret;\r\nif (of_property_read_bool(nd->overlay, "partial-fpga-config"))\r\ninfo->flags |= FPGA_MGR_PARTIAL_RECONFIG;\r\nif (of_property_read_bool(nd->overlay, "external-fpga-config"))\r\ninfo->flags |= FPGA_MGR_EXTERNAL_CONFIG;\r\nof_property_read_string(nd->overlay, "firmware-name", &firmware_name);\r\nof_property_read_u32(nd->overlay, "region-unfreeze-timeout-us",\r\n&info->enable_timeout_us);\r\nof_property_read_u32(nd->overlay, "region-freeze-timeout-us",\r\n&info->disable_timeout_us);\r\nif ((info->flags & FPGA_MGR_EXTERNAL_CONFIG) && firmware_name) {\r\npr_err("error: specified firmware and external-fpga-config");\r\nreturn -EINVAL;\r\n}\r\nif (info->flags & FPGA_MGR_EXTERNAL_CONFIG)\r\nreturn 0;\r\nif (!firmware_name) {\r\npr_err("should specify firmware-name or external-fpga-config\n");\r\nreturn -EINVAL;\r\n}\r\nreturn fpga_region_program_fpga(region, firmware_name, nd->overlay);\r\n}\r\nstatic void fpga_region_notify_post_remove(struct fpga_region *region,\r\nstruct of_overlay_notify_data *nd)\r\n{\r\nfpga_bridges_disable(&region->bridge_list);\r\nfpga_bridges_put(&region->bridge_list);\r\ndevm_kfree(&region->dev, region->info);\r\nregion->info = NULL;\r\n}\r\nstatic int of_fpga_region_notify(struct notifier_block *nb,\r\nunsigned long action, void *arg)\r\n{\r\nstruct of_overlay_notify_data *nd = arg;\r\nstruct fpga_region *region;\r\nint ret;\r\nswitch (action) {\r\ncase OF_OVERLAY_PRE_APPLY:\r\npr_debug("%s OF_OVERLAY_PRE_APPLY\n", __func__);\r\nbreak;\r\ncase OF_OVERLAY_POST_APPLY:\r\npr_debug("%s OF_OVERLAY_POST_APPLY\n", __func__);\r\nreturn NOTIFY_OK;\r\ncase OF_OVERLAY_PRE_REMOVE:\r\npr_debug("%s OF_OVERLAY_PRE_REMOVE\n", __func__);\r\nreturn NOTIFY_OK;\r\ncase OF_OVERLAY_POST_REMOVE:\r\npr_debug("%s OF_OVERLAY_POST_REMOVE\n", __func__);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_OK;\r\n}\r\nregion = fpga_region_find(nd->target);\r\nif (!region)\r\nreturn NOTIFY_OK;\r\nret = 0;\r\nswitch (action) {\r\ncase OF_OVERLAY_PRE_APPLY:\r\nret = fpga_region_notify_pre_apply(region, nd);\r\nbreak;\r\ncase OF_OVERLAY_POST_REMOVE:\r\nfpga_region_notify_post_remove(region, nd);\r\nbreak;\r\n}\r\nput_device(&region->dev);\r\nif (ret)\r\nreturn notifier_from_errno(ret);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int fpga_region_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct fpga_region *region;\r\nint id, ret = 0;\r\nregion = kzalloc(sizeof(*region), GFP_KERNEL);\r\nif (!region)\r\nreturn -ENOMEM;\r\nid = ida_simple_get(&fpga_region_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nret = id;\r\ngoto err_kfree;\r\n}\r\nmutex_init(&region->mutex);\r\nINIT_LIST_HEAD(&region->bridge_list);\r\ndevice_initialize(&region->dev);\r\nregion->dev.class = fpga_region_class;\r\nregion->dev.parent = dev;\r\nregion->dev.of_node = np;\r\nregion->dev.id = id;\r\ndev_set_drvdata(dev, region);\r\nret = dev_set_name(&region->dev, "region%d", id);\r\nif (ret)\r\ngoto err_remove;\r\nret = device_add(&region->dev);\r\nif (ret)\r\ngoto err_remove;\r\nof_platform_populate(np, fpga_region_of_match, NULL, &region->dev);\r\ndev_info(dev, "FPGA Region probed\n");\r\nreturn 0;\r\nerr_remove:\r\nida_simple_remove(&fpga_region_ida, id);\r\nerr_kfree:\r\nkfree(region);\r\nreturn ret;\r\n}\r\nstatic int fpga_region_remove(struct platform_device *pdev)\r\n{\r\nstruct fpga_region *region = platform_get_drvdata(pdev);\r\ndevice_unregister(&region->dev);\r\nreturn 0;\r\n}\r\nstatic void fpga_region_dev_release(struct device *dev)\r\n{\r\nstruct fpga_region *region = to_fpga_region(dev);\r\nida_simple_remove(&fpga_region_ida, region->dev.id);\r\nkfree(region);\r\n}\r\nstatic int __init fpga_region_init(void)\r\n{\r\nint ret;\r\nfpga_region_class = class_create(THIS_MODULE, "fpga_region");\r\nif (IS_ERR(fpga_region_class))\r\nreturn PTR_ERR(fpga_region_class);\r\nfpga_region_class->dev_release = fpga_region_dev_release;\r\nret = of_overlay_notifier_register(&fpga_region_of_nb);\r\nif (ret)\r\ngoto err_class;\r\nret = platform_driver_register(&fpga_region_driver);\r\nif (ret)\r\ngoto err_plat;\r\nreturn 0;\r\nerr_plat:\r\nof_overlay_notifier_unregister(&fpga_region_of_nb);\r\nerr_class:\r\nclass_destroy(fpga_region_class);\r\nida_destroy(&fpga_region_ida);\r\nreturn ret;\r\n}\r\nstatic void __exit fpga_region_exit(void)\r\n{\r\nplatform_driver_unregister(&fpga_region_driver);\r\nof_overlay_notifier_unregister(&fpga_region_of_nb);\r\nclass_destroy(fpga_region_class);\r\nida_destroy(&fpga_region_ida);\r\n}
