static void mpc52xx_gpt_irq_unmask(struct irq_data *d)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nsetbits32(&gpt->regs->mode, MPC52xx_GPT_MODE_IRQ_EN);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\n}\r\nstatic void mpc52xx_gpt_irq_mask(struct irq_data *d)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nclrbits32(&gpt->regs->mode, MPC52xx_GPT_MODE_IRQ_EN);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\n}\r\nstatic void mpc52xx_gpt_irq_ack(struct irq_data *d)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = irq_data_get_irq_chip_data(d);\r\nout_be32(&gpt->regs->status, MPC52xx_GPT_STATUS_IRQMASK);\r\n}\r\nstatic int mpc52xx_gpt_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nu32 reg;\r\ndev_dbg(gpt->dev, "%s: virq=%i type=%x\n", __func__, d->irq, flow_type);\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nreg = in_be32(&gpt->regs->mode) & ~MPC52xx_GPT_MODE_ICT_MASK;\r\nif (flow_type & IRQF_TRIGGER_RISING)\r\nreg |= MPC52xx_GPT_MODE_ICT_RISING;\r\nif (flow_type & IRQF_TRIGGER_FALLING)\r\nreg |= MPC52xx_GPT_MODE_ICT_FALLING;\r\nout_be32(&gpt->regs->mode, reg);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mpc52xx_gpt_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = irq_desc_get_handler_data(desc);\r\nint sub_virq;\r\nu32 status;\r\nstatus = in_be32(&gpt->regs->status) & MPC52xx_GPT_STATUS_IRQMASK;\r\nif (status) {\r\nsub_virq = irq_linear_revmap(gpt->irqhost, 0);\r\ngeneric_handle_irq(sub_virq);\r\n}\r\n}\r\nstatic int mpc52xx_gpt_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = h->host_data;\r\ndev_dbg(gpt->dev, "%s: h=%p, virq=%i\n", __func__, h, virq);\r\nirq_set_chip_data(virq, gpt);\r\nirq_set_chip_and_handler(virq, &mpc52xx_gpt_irq_chip, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_gpt_irq_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq,\r\nunsigned int *out_flags)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = h->host_data;\r\ndev_dbg(gpt->dev, "%s: flags=%i\n", __func__, intspec[0]);\r\nif ((intsize < 1) || (intspec[0] > 3)) {\r\ndev_err(gpt->dev, "bad irq specifier in %s\n", ct->full_name);\r\nreturn -EINVAL;\r\n}\r\n*out_hwirq = 0;\r\n*out_flags = intspec[0];\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_gpt_irq_setup(struct mpc52xx_gpt_priv *gpt, struct device_node *node)\r\n{\r\nint cascade_virq;\r\nunsigned long flags;\r\nu32 mode;\r\ncascade_virq = irq_of_parse_and_map(node, 0);\r\nif (!cascade_virq)\r\nreturn;\r\ngpt->irqhost = irq_domain_add_linear(node, 1, &mpc52xx_gpt_irq_ops, gpt);\r\nif (!gpt->irqhost) {\r\ndev_err(gpt->dev, "irq_domain_add_linear() failed\n");\r\nreturn;\r\n}\r\nirq_set_handler_data(cascade_virq, gpt);\r\nirq_set_chained_handler(cascade_virq, mpc52xx_gpt_irq_cascade);\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nmode = in_be32(&gpt->regs->mode);\r\nif ((mode & MPC52xx_GPT_MODE_MS_MASK) == 0)\r\nout_be32(&gpt->regs->mode, mode | MPC52xx_GPT_MODE_MS_IC);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\ndev_dbg(gpt->dev, "%s() complete. virq=%i\n", __func__, cascade_virq);\r\n}\r\nstatic int mpc52xx_gpt_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = gpiochip_get_data(gc);\r\nreturn (in_be32(&gpt->regs->status) >> 8) & 1;\r\n}\r\nstatic void\r\nmpc52xx_gpt_gpio_set(struct gpio_chip *gc, unsigned int gpio, int v)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 r;\r\ndev_dbg(gpt->dev, "%s: gpio:%d v:%d\n", __func__, gpio, v);\r\nr = v ? MPC52xx_GPT_MODE_GPIO_OUT_HIGH : MPC52xx_GPT_MODE_GPIO_OUT_LOW;\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nclrsetbits_be32(&gpt->regs->mode, MPC52xx_GPT_MODE_GPIO_MASK, r);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\n}\r\nstatic int mpc52xx_gpt_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt = gpiochip_get_data(gc);\r\nunsigned long flags;\r\ndev_dbg(gpt->dev, "%s: gpio:%d\n", __func__, gpio);\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nclrbits32(&gpt->regs->mode, MPC52xx_GPT_MODE_GPIO_MASK);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nmpc52xx_gpt_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nmpc52xx_gpt_gpio_set(gc, gpio, val);\r\nreturn 0;\r\n}\r\nstatic void\r\nmpc52xx_gpt_gpio_setup(struct mpc52xx_gpt_priv *gpt, struct device_node *node)\r\n{\r\nint rc;\r\nif (!of_find_property(node, "gpio-controller", NULL))\r\nreturn;\r\ngpt->gc.label = kstrdup(node->full_name, GFP_KERNEL);\r\nif (!gpt->gc.label) {\r\ndev_err(gpt->dev, "out of memory\n");\r\nreturn;\r\n}\r\ngpt->gc.ngpio = 1;\r\ngpt->gc.direction_input = mpc52xx_gpt_gpio_dir_in;\r\ngpt->gc.direction_output = mpc52xx_gpt_gpio_dir_out;\r\ngpt->gc.get = mpc52xx_gpt_gpio_get;\r\ngpt->gc.set = mpc52xx_gpt_gpio_set;\r\ngpt->gc.base = -1;\r\ngpt->gc.of_node = node;\r\nclrsetbits_be32(&gpt->regs->mode, MPC52xx_GPT_MODE_MS_MASK,\r\nMPC52xx_GPT_MODE_MS_GPIO);\r\nrc = gpiochip_add_data(&gpt->gc, gpt);\r\nif (rc)\r\ndev_err(gpt->dev, "gpiochip_add_data() failed; rc=%i\n", rc);\r\ndev_dbg(gpt->dev, "%s() complete.\n", __func__);\r\n}\r\nstatic void\r\nmpc52xx_gpt_gpio_setup(struct mpc52xx_gpt_priv *p, struct device_node *np) { }\r\nstruct mpc52xx_gpt_priv *mpc52xx_gpt_from_irq(int irq)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt;\r\nstruct list_head *pos;\r\nmutex_lock(&mpc52xx_gpt_list_mutex);\r\nlist_for_each(pos, &mpc52xx_gpt_list) {\r\ngpt = container_of(pos, struct mpc52xx_gpt_priv, list);\r\nif (gpt->irqhost && irq == irq_linear_revmap(gpt->irqhost, 0)) {\r\nmutex_unlock(&mpc52xx_gpt_list_mutex);\r\nreturn gpt;\r\n}\r\n}\r\nmutex_unlock(&mpc52xx_gpt_list_mutex);\r\nreturn NULL;\r\n}\r\nstatic int mpc52xx_gpt_do_start(struct mpc52xx_gpt_priv *gpt, u64 period,\r\nint continuous, int as_wdt)\r\n{\r\nu32 clear, set;\r\nu64 clocks;\r\nu32 prescale;\r\nunsigned long flags;\r\nclear = MPC52xx_GPT_MODE_MS_MASK | MPC52xx_GPT_MODE_CONTINUOUS;\r\nset = MPC52xx_GPT_MODE_MS_GPIO | MPC52xx_GPT_MODE_COUNTER_ENABLE;\r\nif (as_wdt) {\r\nclear |= MPC52xx_GPT_MODE_IRQ_EN;\r\nset |= MPC52xx_GPT_MODE_WDT_EN;\r\n} else if (continuous)\r\nset |= MPC52xx_GPT_MODE_CONTINUOUS;\r\nclocks = period * (u64)gpt->ipb_freq;\r\ndo_div(clocks, 1000000000);\r\nif (clocks > 0xffffffff)\r\nreturn -EINVAL;\r\nprescale = (clocks >> 16) + 1;\r\ndo_div(clocks, prescale);\r\nif (clocks > 0xffff) {\r\npr_err("calculation error; prescale:%x clocks:%llx\n",\r\nprescale, clocks);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nif (as_wdt)\r\ngpt->wdt_mode |= MPC52xx_GPT_IS_WDT;\r\nelse if ((gpt->wdt_mode & MPC52xx_GPT_IS_WDT) != 0) {\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nout_be32(&gpt->regs->count, prescale << 16 | clocks);\r\nclrsetbits_be32(&gpt->regs->mode, clear, set);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn 0;\r\n}\r\nint mpc52xx_gpt_start_timer(struct mpc52xx_gpt_priv *gpt, u64 period,\r\nint continuous)\r\n{\r\nreturn mpc52xx_gpt_do_start(gpt, period, continuous, 0);\r\n}\r\nint mpc52xx_gpt_stop_timer(struct mpc52xx_gpt_priv *gpt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nif ((gpt->wdt_mode & MPC52xx_GPT_IS_WDT) != 0) {\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nclrbits32(&gpt->regs->mode, MPC52xx_GPT_MODE_COUNTER_ENABLE);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nreturn 0;\r\n}\r\nu64 mpc52xx_gpt_timer_period(struct mpc52xx_gpt_priv *gpt)\r\n{\r\nu64 period;\r\nu64 prescale;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt->lock, flags);\r\nperiod = in_be32(&gpt->regs->count);\r\nspin_unlock_irqrestore(&gpt->lock, flags);\r\nprescale = period >> 16;\r\nperiod &= 0xffff;\r\nif (prescale == 0)\r\nprescale = 0x10000;\r\nperiod = period * prescale * 1000000000ULL;\r\ndo_div(period, (u64)gpt->ipb_freq);\r\nreturn period;\r\n}\r\nstatic inline void mpc52xx_gpt_wdt_ping(struct mpc52xx_gpt_priv *gpt_wdt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt_wdt->lock, flags);\r\nout_8((u8 *) &gpt_wdt->regs->mode, MPC52xx_GPT_MODE_WDT_PING);\r\nspin_unlock_irqrestore(&gpt_wdt->lock, flags);\r\n}\r\nstatic ssize_t mpc52xx_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt_wdt = file->private_data;\r\nmpc52xx_gpt_wdt_ping(gpt_wdt);\r\nreturn 0;\r\n}\r\nstatic long mpc52xx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt_wdt = file->private_data;\r\nint __user *data = (int __user *)arg;\r\nint timeout;\r\nu64 real_timeout;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = copy_to_user(data, &mpc5200_wdt_info,\r\nsizeof(mpc5200_wdt_info));\r\nif (ret)\r\nret = -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, data);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nmpc52xx_gpt_wdt_ping(gpt_wdt);\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(timeout, data);\r\nif (ret)\r\nbreak;\r\nreal_timeout = (u64) timeout * 1000000000ULL;\r\nret = mpc52xx_gpt_do_start(gpt_wdt, real_timeout, 0, 1);\r\nif (ret)\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nreal_timeout =\r\nmpc52xx_gpt_timer_period(gpt_wdt) + 500000000ULL;\r\ndo_div(real_timeout, 1000000000ULL);\r\ntimeout = (int) real_timeout;\r\nret = put_user(timeout, data);\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mpc52xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nif (!mpc52xx_gpt_wdt)\r\nreturn -ENODEV;\r\nif (test_and_set_bit(0, &wdt_is_active))\r\nreturn -EBUSY;\r\nret = mpc52xx_gpt_do_start(mpc52xx_gpt_wdt, 30ULL * 1000000000ULL,\r\n0, 1);\r\nif (ret) {\r\nclear_bit(0, &wdt_is_active);\r\nreturn ret;\r\n}\r\nfile->private_data = mpc52xx_gpt_wdt;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int mpc52xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\n#if !defined(CONFIG_WATCHDOG_NOWAYOUT)\r\nstruct mpc52xx_gpt_priv *gpt_wdt = file->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpt_wdt->lock, flags);\r\nclrbits32(&gpt_wdt->regs->mode,\r\nMPC52xx_GPT_MODE_COUNTER_ENABLE | MPC52xx_GPT_MODE_WDT_EN);\r\ngpt_wdt->wdt_mode &= ~MPC52xx_GPT_IS_WDT;\r\nspin_unlock_irqrestore(&gpt_wdt->lock, flags);\r\n#endif\r\nclear_bit(0, &wdt_is_active);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_gpt_wdt_init(void)\r\n{\r\nint err;\r\nerr = misc_register(&mpc52xx_wdt_miscdev);\r\nif (err)\r\npr_err("%s: cannot register watchdog device\n", WDT_IDENTITY);\r\nelse\r\npr_info("%s: watchdog device registered\n", WDT_IDENTITY);\r\nreturn err;\r\n}\r\nstatic int mpc52xx_gpt_wdt_setup(struct mpc52xx_gpt_priv *gpt,\r\nconst u32 *period)\r\n{\r\nu64 real_timeout;\r\nmpc52xx_gpt_wdt = gpt;\r\nif (!period || *period == 0)\r\nreturn 0;\r\nreal_timeout = (u64) *period * 1000000000ULL;\r\nif (mpc52xx_gpt_do_start(gpt, real_timeout, 0, 1))\r\ndev_warn(gpt->dev, "starting as wdt failed\n");\r\nelse\r\ndev_info(gpt->dev, "watchdog set to %us timeout\n", *period);\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_gpt_wdt_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int mpc52xx_gpt_wdt_setup(struct mpc52xx_gpt_priv *gpt,\r\nconst u32 *period)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_gpt_probe(struct platform_device *ofdev)\r\n{\r\nstruct mpc52xx_gpt_priv *gpt;\r\ngpt = devm_kzalloc(&ofdev->dev, sizeof *gpt, GFP_KERNEL);\r\nif (!gpt)\r\nreturn -ENOMEM;\r\nspin_lock_init(&gpt->lock);\r\ngpt->dev = &ofdev->dev;\r\ngpt->ipb_freq = mpc5xxx_get_bus_frequency(ofdev->dev.of_node);\r\ngpt->regs = of_iomap(ofdev->dev.of_node, 0);\r\nif (!gpt->regs)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&ofdev->dev, gpt);\r\nmpc52xx_gpt_gpio_setup(gpt, ofdev->dev.of_node);\r\nmpc52xx_gpt_irq_setup(gpt, ofdev->dev.of_node);\r\nmutex_lock(&mpc52xx_gpt_list_mutex);\r\nlist_add(&gpt->list, &mpc52xx_gpt_list);\r\nmutex_unlock(&mpc52xx_gpt_list_mutex);\r\nif (of_get_property(ofdev->dev.of_node, "fsl,has-wdt", NULL) ||\r\nof_get_property(ofdev->dev.of_node, "has-wdt", NULL)) {\r\nconst u32 *on_boot_wdt;\r\ngpt->wdt_mode = MPC52xx_GPT_CAN_WDT;\r\non_boot_wdt = of_get_property(ofdev->dev.of_node,\r\n"fsl,wdt-on-boot", NULL);\r\nif (on_boot_wdt) {\r\ndev_info(gpt->dev, "used as watchdog\n");\r\ngpt->wdt_mode |= MPC52xx_GPT_IS_WDT;\r\n} else\r\ndev_info(gpt->dev, "can function as watchdog\n");\r\nmpc52xx_gpt_wdt_setup(gpt, on_boot_wdt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc52xx_gpt_remove(struct platform_device *ofdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init mpc52xx_gpt_init(void)\r\n{\r\nreturn platform_driver_register(&mpc52xx_gpt_driver);\r\n}
