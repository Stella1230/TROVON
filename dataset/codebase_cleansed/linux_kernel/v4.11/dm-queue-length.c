static struct selector *alloc_selector(void)\r\n{\r\nstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (s) {\r\nINIT_LIST_HEAD(&s->valid_paths);\r\nINIT_LIST_HEAD(&s->failed_paths);\r\nspin_lock_init(&s->lock);\r\n}\r\nreturn s;\r\n}\r\nstatic int ql_create(struct path_selector *ps, unsigned argc, char **argv)\r\n{\r\nstruct selector *s = alloc_selector();\r\nif (!s)\r\nreturn -ENOMEM;\r\nps->context = s;\r\nreturn 0;\r\n}\r\nstatic void ql_free_paths(struct list_head *paths)\r\n{\r\nstruct path_info *pi, *next;\r\nlist_for_each_entry_safe(pi, next, paths, list) {\r\nlist_del(&pi->list);\r\nkfree(pi);\r\n}\r\n}\r\nstatic void ql_destroy(struct path_selector *ps)\r\n{\r\nstruct selector *s = ps->context;\r\nql_free_paths(&s->valid_paths);\r\nql_free_paths(&s->failed_paths);\r\nkfree(s);\r\nps->context = NULL;\r\n}\r\nstatic int ql_status(struct path_selector *ps, struct dm_path *path,\r\nstatus_type_t type, char *result, unsigned maxlen)\r\n{\r\nunsigned sz = 0;\r\nstruct path_info *pi;\r\nif (!path)\r\nDMEMIT("0 ");\r\nelse {\r\npi = path->pscontext;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%d ", atomic_read(&pi->qlen));\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%u ", pi->repeat_count);\r\nbreak;\r\n}\r\n}\r\nreturn sz;\r\n}\r\nstatic int ql_add_path(struct path_selector *ps, struct dm_path *path,\r\nint argc, char **argv, char **error)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi;\r\nunsigned repeat_count = QL_MIN_IO;\r\nchar dummy;\r\nunsigned long flags;\r\nif (argc > 1) {\r\n*error = "queue-length ps: incorrect number of arguments";\r\nreturn -EINVAL;\r\n}\r\nif ((argc == 1) && (sscanf(argv[0], "%u%c", &repeat_count, &dummy) != 1)) {\r\n*error = "queue-length ps: invalid repeat count";\r\nreturn -EINVAL;\r\n}\r\nif (repeat_count > 1) {\r\nDMWARN_LIMIT("repeat_count > 1 is deprecated, using 1 instead");\r\nrepeat_count = 1;\r\n}\r\npi = kmalloc(sizeof(*pi), GFP_KERNEL);\r\nif (!pi) {\r\n*error = "queue-length ps: Error allocating path information";\r\nreturn -ENOMEM;\r\n}\r\npi->path = path;\r\npi->repeat_count = repeat_count;\r\natomic_set(&pi->qlen, 0);\r\npath->pscontext = pi;\r\nspin_lock_irqsave(&s->lock, flags);\r\nlist_add_tail(&pi->list, &s->valid_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ql_fail_path(struct path_selector *ps, struct dm_path *path)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = path->pscontext;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nlist_move(&pi->list, &s->failed_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic int ql_reinstate_path(struct path_selector *ps, struct dm_path *path)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = path->pscontext;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nlist_move_tail(&pi->list, &s->valid_paths);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct dm_path *ql_select_path(struct path_selector *ps, size_t nr_bytes)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = NULL, *best = NULL;\r\nstruct dm_path *ret = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (list_empty(&s->valid_paths))\r\ngoto out;\r\nlist_move_tail(s->valid_paths.next, &s->valid_paths);\r\nlist_for_each_entry(pi, &s->valid_paths, list) {\r\nif (!best ||\r\n(atomic_read(&pi->qlen) < atomic_read(&best->qlen)))\r\nbest = pi;\r\nif (!atomic_read(&best->qlen))\r\nbreak;\r\n}\r\nif (!best)\r\ngoto out;\r\nret = best->path;\r\nout:\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ql_start_io(struct path_selector *ps, struct dm_path *path,\r\nsize_t nr_bytes)\r\n{\r\nstruct path_info *pi = path->pscontext;\r\natomic_inc(&pi->qlen);\r\nreturn 0;\r\n}\r\nstatic int ql_end_io(struct path_selector *ps, struct dm_path *path,\r\nsize_t nr_bytes)\r\n{\r\nstruct path_info *pi = path->pscontext;\r\natomic_dec(&pi->qlen);\r\nreturn 0;\r\n}\r\nstatic int __init dm_ql_init(void)\r\n{\r\nint r = dm_register_path_selector(&ql_ps);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nDMINFO("version " QL_VERSION " loaded");\r\nreturn r;\r\n}\r\nstatic void __exit dm_ql_exit(void)\r\n{\r\nint r = dm_unregister_path_selector(&ql_ps);\r\nif (r < 0)\r\nDMERR("unregister failed %d", r);\r\n}
