static bool\r\nnft_payload_copy_vlan(u32 *d, const struct sk_buff *skb, u8 offset, u8 len)\r\n{\r\nint mac_off = skb_mac_header(skb) - skb->data;\r\nu8 vlan_len, *vlanh, *dst_u8 = (u8 *) d;\r\nstruct vlan_ethhdr veth;\r\nvlanh = (u8 *) &veth;\r\nif (offset < ETH_HLEN) {\r\nu8 ethlen = min_t(u8, len, ETH_HLEN - offset);\r\nif (skb_copy_bits(skb, mac_off, &veth, ETH_HLEN))\r\nreturn false;\r\nveth.h_vlan_proto = skb->vlan_proto;\r\nmemcpy(dst_u8, vlanh + offset, ethlen);\r\nlen -= ethlen;\r\nif (len == 0)\r\nreturn true;\r\ndst_u8 += ethlen;\r\noffset = ETH_HLEN;\r\n} else if (offset >= VLAN_ETH_HLEN) {\r\noffset -= VLAN_HLEN;\r\ngoto skip;\r\n}\r\nveth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));\r\nveth.h_vlan_encapsulated_proto = skb->protocol;\r\nvlanh += offset;\r\nvlan_len = min_t(u8, len, VLAN_ETH_HLEN - offset);\r\nmemcpy(dst_u8, vlanh, vlan_len);\r\nlen -= vlan_len;\r\nif (!len)\r\nreturn true;\r\ndst_u8 += vlan_len;\r\nskip:\r\nreturn skb_copy_bits(skb, offset + mac_off, dst_u8, len) == 0;\r\n}\r\nstatic void nft_payload_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nu32 *dest = &regs->data[priv->dreg];\r\nint offset;\r\ndest[priv->len / NFT_REG32_SIZE] = 0;\r\nswitch (priv->base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\nif (!skb_mac_header_was_set(skb))\r\ngoto err;\r\nif (skb_vlan_tag_present(skb)) {\r\nif (!nft_payload_copy_vlan(dest, skb,\r\npriv->offset, priv->len))\r\ngoto err;\r\nreturn;\r\n}\r\noffset = skb_mac_header(skb) - skb->data;\r\nbreak;\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\noffset = skb_network_offset(skb);\r\nbreak;\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nif (!pkt->tprot_set)\r\ngoto err;\r\noffset = pkt->xt.thoff;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\noffset += priv->offset;\r\nif (skb_copy_bits(skb, offset, dest, priv->len) < 0)\r\ngoto err;\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_payload_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_payload *priv = nft_expr_priv(expr);\r\npriv->base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\npriv->dreg = nft_parse_register(tb[NFTA_PAYLOAD_DREG]);\r\nreturn nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, priv->len);\r\n}\r\nstatic int nft_payload_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_PAYLOAD_DREG, priv->dreg) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_BASE, htonl(priv->base)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_OFFSET, htonl(priv->offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic inline void nft_csum_replace(__sum16 *sum, __wsum fsum, __wsum tsum)\r\n{\r\n*sum = csum_fold(csum_add(csum_sub(~csum_unfold(*sum), fsum), tsum));\r\nif (*sum == 0)\r\n*sum = CSUM_MANGLED_0;\r\n}\r\nstatic bool nft_payload_udp_checksum(struct sk_buff *skb, unsigned int thoff)\r\n{\r\nstruct udphdr *uh, _uh;\r\nuh = skb_header_pointer(skb, thoff, sizeof(_uh), &_uh);\r\nif (!uh)\r\nreturn false;\r\nreturn uh->check;\r\n}\r\nstatic int nft_payload_l4csum_offset(const struct nft_pktinfo *pkt,\r\nstruct sk_buff *skb,\r\nunsigned int *l4csum_offset)\r\n{\r\nswitch (pkt->tprot) {\r\ncase IPPROTO_TCP:\r\n*l4csum_offset = offsetof(struct tcphdr, check);\r\nbreak;\r\ncase IPPROTO_UDP:\r\nif (!nft_payload_udp_checksum(skb, pkt->xt.thoff))\r\nreturn -1;\r\ncase IPPROTO_UDPLITE:\r\n*l4csum_offset = offsetof(struct udphdr, check);\r\nbreak;\r\ncase IPPROTO_ICMPV6:\r\n*l4csum_offset = offsetof(struct icmp6hdr, icmp6_cksum);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n*l4csum_offset += pkt->xt.thoff;\r\nreturn 0;\r\n}\r\nstatic int nft_payload_l4csum_update(const struct nft_pktinfo *pkt,\r\nstruct sk_buff *skb,\r\n__wsum fsum, __wsum tsum)\r\n{\r\nint l4csum_offset;\r\n__sum16 sum;\r\nif (nft_payload_l4csum_offset(pkt, skb, &l4csum_offset) < 0)\r\nreturn 0;\r\nif (skb_copy_bits(skb, l4csum_offset, &sum, sizeof(sum)) < 0)\r\nreturn -1;\r\nif (skb->ip_summed != CHECKSUM_PARTIAL) {\r\nnft_csum_replace(&sum, fsum, tsum);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nskb->csum = ~csum_add(csum_sub(~(skb->csum), fsum),\r\ntsum);\r\n}\r\n} else {\r\nsum = ~csum_fold(csum_add(csum_sub(csum_unfold(sum), fsum),\r\ntsum));\r\n}\r\nif (!skb_make_writable(skb, l4csum_offset + sizeof(sum)) ||\r\nskb_store_bits(skb, l4csum_offset, &sum, sizeof(sum)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int nft_payload_csum_inet(struct sk_buff *skb, const u32 *src,\r\n__wsum fsum, __wsum tsum, int csum_offset)\r\n{\r\n__sum16 sum;\r\nif (skb_copy_bits(skb, csum_offset, &sum, sizeof(sum)) < 0)\r\nreturn -1;\r\nnft_csum_replace(&sum, fsum, tsum);\r\nif (!skb_make_writable(skb, csum_offset + sizeof(sum)) ||\r\nskb_store_bits(skb, csum_offset, &sum, sizeof(sum)) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void nft_payload_set_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload_set *priv = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\nconst u32 *src = &regs->data[priv->sreg];\r\nint offset, csum_offset;\r\n__wsum fsum, tsum;\r\nswitch (priv->base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\nif (!skb_mac_header_was_set(skb))\r\ngoto err;\r\noffset = skb_mac_header(skb) - skb->data;\r\nbreak;\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\noffset = skb_network_offset(skb);\r\nbreak;\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nif (!pkt->tprot_set)\r\ngoto err;\r\noffset = pkt->xt.thoff;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ncsum_offset = offset + priv->csum_offset;\r\noffset += priv->offset;\r\nif ((priv->csum_type == NFT_PAYLOAD_CSUM_INET || priv->csum_flags) &&\r\n(priv->base != NFT_PAYLOAD_TRANSPORT_HEADER ||\r\nskb->ip_summed != CHECKSUM_PARTIAL)) {\r\nfsum = skb_checksum(skb, offset, priv->len, 0);\r\ntsum = csum_partial(src, priv->len, 0);\r\nif (priv->csum_type == NFT_PAYLOAD_CSUM_INET &&\r\nnft_payload_csum_inet(skb, src, fsum, tsum, csum_offset))\r\ngoto err;\r\nif (priv->csum_flags &&\r\nnft_payload_l4csum_update(pkt, skb, fsum, tsum) < 0)\r\ngoto err;\r\n}\r\nif (!skb_make_writable(skb, max(offset + priv->len, 0)) ||\r\nskb_store_bits(skb, offset, src, priv->len) < 0)\r\ngoto err;\r\nreturn;\r\nerr:\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic int nft_payload_set_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_payload_set *priv = nft_expr_priv(expr);\r\npriv->base = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\npriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\npriv->sreg = nft_parse_register(tb[NFTA_PAYLOAD_SREG]);\r\nif (tb[NFTA_PAYLOAD_CSUM_TYPE])\r\npriv->csum_type =\r\nntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_TYPE]));\r\nif (tb[NFTA_PAYLOAD_CSUM_OFFSET])\r\npriv->csum_offset =\r\nntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_OFFSET]));\r\nif (tb[NFTA_PAYLOAD_CSUM_FLAGS]) {\r\nu32 flags;\r\nflags = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_CSUM_FLAGS]));\r\nif (flags & ~NFT_PAYLOAD_L4CSUM_PSEUDOHDR)\r\nreturn -EINVAL;\r\npriv->csum_flags = flags;\r\n}\r\nswitch (priv->csum_type) {\r\ncase NFT_PAYLOAD_CSUM_NONE:\r\ncase NFT_PAYLOAD_CSUM_INET:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn nft_validate_register_load(priv->sreg, priv->len);\r\n}\r\nstatic int nft_payload_set_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_payload_set *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_PAYLOAD_SREG, priv->sreg) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_BASE, htonl(priv->base)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_OFFSET, htonl(priv->offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_LEN, htonl(priv->len)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_CSUM_TYPE, htonl(priv->csum_type)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_CSUM_OFFSET,\r\nhtonl(priv->csum_offset)) ||\r\nnla_put_be32(skb, NFTA_PAYLOAD_CSUM_FLAGS, htonl(priv->csum_flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_payload_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_payload_bases base;\r\nunsigned int offset, len;\r\nif (tb[NFTA_PAYLOAD_BASE] == NULL ||\r\ntb[NFTA_PAYLOAD_OFFSET] == NULL ||\r\ntb[NFTA_PAYLOAD_LEN] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nbase = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\r\nswitch (base) {\r\ncase NFT_PAYLOAD_LL_HEADER:\r\ncase NFT_PAYLOAD_NETWORK_HEADER:\r\ncase NFT_PAYLOAD_TRANSPORT_HEADER:\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nif (tb[NFTA_PAYLOAD_SREG] != NULL) {\r\nif (tb[NFTA_PAYLOAD_DREG] != NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn &nft_payload_set_ops;\r\n}\r\nif (tb[NFTA_PAYLOAD_DREG] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\noffset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\r\nlen = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\r\nif (len <= 4 && is_power_of_2(len) && IS_ALIGNED(offset, len) &&\r\nbase != NFT_PAYLOAD_LL_HEADER)\r\nreturn &nft_payload_fast_ops;\r\nelse\r\nreturn &nft_payload_ops;\r\n}
