static unsigned int mpu3050_get_freq(struct mpu3050 *mpu3050)\r\n{\r\nunsigned int freq;\r\nif (mpu3050->lpf == MPU3050_DLPF_CFG_256HZ_NOLPF2)\r\nfreq = 8000;\r\nelse\r\nfreq = 1000;\r\nfreq /= (mpu3050->divisor + 1);\r\nreturn freq;\r\n}\r\nstatic int mpu3050_start_sampling(struct mpu3050 *mpu3050)\r\n{\r\n__be16 raw_val[3];\r\nint ret;\r\nint i;\r\nret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_RESET, MPU3050_PWR_MGM_RESET);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_CLKSEL_MASK,\r\nMPU3050_PWR_MGM_PLL_Z);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 3; i++)\r\nraw_val[i] = cpu_to_be16(mpu3050->calibration[i]);\r\nret = regmap_bulk_write(mpu3050->map, MPU3050_X_OFFS_USR_H, raw_val,\r\nsizeof(raw_val));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(mpu3050->map, MPU3050_DLPF_FS_SYNC,\r\nMPU3050_EXT_SYNC_NONE << MPU3050_EXT_SYNC_SHIFT |\r\nmpu3050->fullscale << MPU3050_FS_SHIFT |\r\nmpu3050->lpf << MPU3050_DLPF_CFG_SHIFT);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(mpu3050->map, MPU3050_SMPLRT_DIV, mpu3050->divisor);\r\nif (ret)\r\nreturn ret;\r\nmsleep(50 + 1000 / mpu3050_get_freq(mpu3050));\r\nreturn 0;\r\n}\r\nstatic int mpu3050_set_8khz_samplerate(struct mpu3050 *mpu3050)\r\n{\r\nint ret;\r\nu8 divisor;\r\nenum mpu3050_lpf lpf;\r\nlpf = mpu3050->lpf;\r\ndivisor = mpu3050->divisor;\r\nmpu3050->lpf = LPF_256_HZ_NOLPF;\r\nmpu3050->divisor = 0;\r\nret = mpu3050_start_sampling(mpu3050);\r\nmpu3050->lpf = lpf;\r\nmpu3050->divisor = divisor;\r\nreturn ret;\r\n}\r\nstatic int mpu3050_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nint ret;\r\n__be16 raw_val;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = 23000;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = mpu3050->calibration[chan->scan_index-1];\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = mpu3050_get_freq(mpu3050);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = 1000;\r\n*val2 = 280;\r\nreturn IIO_VAL_FRACTIONAL;\r\ncase IIO_ANGL_VEL:\r\n*val = mpu3050_fs_precision[mpu3050->fullscale] * 2;\r\n*val2 = U16_MAX;\r\nreturn IIO_VAL_FRACTIONAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_RAW:\r\npm_runtime_get_sync(mpu3050->dev);\r\nmutex_lock(&mpu3050->lock);\r\nret = mpu3050_set_8khz_samplerate(mpu3050);\r\nif (ret)\r\ngoto out_read_raw_unlock;\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\nret = regmap_bulk_read(mpu3050->map, MPU3050_TEMP_H,\r\n&raw_val, sizeof(raw_val));\r\nif (ret) {\r\ndev_err(mpu3050->dev,\r\n"error reading temperature\n");\r\ngoto out_read_raw_unlock;\r\n}\r\n*val = be16_to_cpu(raw_val);\r\nret = IIO_VAL_INT;\r\ngoto out_read_raw_unlock;\r\ncase IIO_ANGL_VEL:\r\nret = regmap_bulk_read(mpu3050->map,\r\nMPU3050_AXIS_REGS(chan->scan_index-1),\r\n&raw_val,\r\nsizeof(raw_val));\r\nif (ret) {\r\ndev_err(mpu3050->dev,\r\n"error reading axis data\n");\r\ngoto out_read_raw_unlock;\r\n}\r\n*val = be16_to_cpu(raw_val);\r\nret = IIO_VAL_INT;\r\ngoto out_read_raw_unlock;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out_read_raw_unlock;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\nout_read_raw_unlock:\r\nmutex_unlock(&mpu3050->lock);\r\npm_runtime_mark_last_busy(mpu3050->dev);\r\npm_runtime_put_autosuspend(mpu3050->dev);\r\nreturn ret;\r\n}\r\nstatic int mpu3050_write_raw(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nunsigned int fs250 =\r\nDIV_ROUND_CLOSEST(mpu3050_fs_precision[0] * 1000000 * 2,\r\nU16_MAX);\r\nunsigned int fs500 =\r\nDIV_ROUND_CLOSEST(mpu3050_fs_precision[1] * 1000000 * 2,\r\nU16_MAX);\r\nunsigned int fs1000 =\r\nDIV_ROUND_CLOSEST(mpu3050_fs_precision[2] * 1000000 * 2,\r\nU16_MAX);\r\nunsigned int fs2000 =\r\nDIV_ROUND_CLOSEST(mpu3050_fs_precision[3] * 1000000 * 2,\r\nU16_MAX);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (chan->type != IIO_ANGL_VEL)\r\nreturn -EINVAL;\r\nmpu3050->calibration[chan->scan_index-1] = val;\r\nreturn 0;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val < 4 || val > 8000)\r\nreturn -EINVAL;\r\nif (val > 1000) {\r\nmpu3050->lpf = LPF_256_HZ_NOLPF;\r\nmpu3050->divisor = DIV_ROUND_CLOSEST(8000, val) - 1;\r\nreturn 0;\r\n}\r\nmpu3050->lpf = LPF_188_HZ;\r\nmpu3050->divisor = DIV_ROUND_CLOSEST(1000, val) - 1;\r\nreturn 0;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type != IIO_ANGL_VEL)\r\nreturn -EINVAL;\r\nif (val != 0) {\r\nmpu3050->fullscale = FS_2000_DPS;\r\nreturn 0;\r\n}\r\nif (val2 <= fs250 ||\r\nval2 < ((fs500 + fs250) / 2))\r\nmpu3050->fullscale = FS_250_DPS;\r\nelse if (val2 <= fs500 ||\r\nval2 < ((fs1000 + fs500) / 2))\r\nmpu3050->fullscale = FS_500_DPS;\r\nelse if (val2 <= fs1000 ||\r\nval2 < ((fs2000 + fs1000) / 2))\r\nmpu3050->fullscale = FS_1000_DPS;\r\nelse\r\nmpu3050->fullscale = FS_2000_DPS;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t mpu3050_trigger_handler(int irq, void *p)\r\n{\r\nconst struct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nint ret;\r\n__be16 hw_values[8];\r\ns64 timestamp;\r\nunsigned int datums_from_fifo = 0;\r\nif (iio_trigger_using_own(indio_dev))\r\ntimestamp = mpu3050->hw_timestamp;\r\nelse\r\ntimestamp = iio_get_time_ns(indio_dev);\r\nmutex_lock(&mpu3050->lock);\r\nif (mpu3050->hw_irq_trigger) {\r\n__be16 raw_fifocnt;\r\nu16 fifocnt;\r\nunsigned int bytes_per_datum = 8;\r\nbool fifo_overflow = false;\r\nret = regmap_bulk_read(mpu3050->map,\r\nMPU3050_FIFO_COUNT_H,\r\n&raw_fifocnt,\r\nsizeof(raw_fifocnt));\r\nif (ret)\r\ngoto out_trigger_unlock;\r\nfifocnt = be16_to_cpu(raw_fifocnt);\r\nif (fifocnt == 512) {\r\ndev_info(mpu3050->dev,\r\n"FIFO overflow! Emptying and resetting FIFO\n");\r\nfifo_overflow = true;\r\nret = regmap_update_bits(mpu3050->map,\r\nMPU3050_USR_CTRL,\r\nMPU3050_USR_CTRL_FIFO_EN |\r\nMPU3050_USR_CTRL_FIFO_RST,\r\nMPU3050_USR_CTRL_FIFO_EN |\r\nMPU3050_USR_CTRL_FIFO_RST);\r\nif (ret) {\r\ndev_info(mpu3050->dev, "error resetting FIFO\n");\r\ngoto out_trigger_unlock;\r\n}\r\nmpu3050->pending_fifo_footer = false;\r\n}\r\nif (fifocnt)\r\ndev_dbg(mpu3050->dev,\r\n"%d bytes in the FIFO\n",\r\nfifocnt);\r\nwhile (!fifo_overflow && fifocnt > bytes_per_datum) {\r\nunsigned int toread;\r\nunsigned int offset;\r\n__be16 fifo_values[5];\r\nif (mpu3050->pending_fifo_footer) {\r\ntoread = bytes_per_datum + 2;\r\noffset = 0;\r\n} else {\r\ntoread = bytes_per_datum;\r\noffset = 1;\r\nfifo_values[0] = 0xAAAA;\r\n}\r\nret = regmap_bulk_read(mpu3050->map,\r\nMPU3050_FIFO_R,\r\n&fifo_values[offset],\r\ntoread);\r\ndev_dbg(mpu3050->dev,\r\n"%04x %04x %04x %04x %04x\n",\r\nfifo_values[0],\r\nfifo_values[1],\r\nfifo_values[2],\r\nfifo_values[3],\r\nfifo_values[4]);\r\niio_push_to_buffers_with_timestamp(indio_dev,\r\n&fifo_values[1],\r\ntimestamp);\r\nfifocnt -= toread;\r\ndatums_from_fifo++;\r\nmpu3050->pending_fifo_footer = true;\r\nif (fifocnt < bytes_per_datum) {\r\nret = regmap_bulk_read(mpu3050->map,\r\nMPU3050_FIFO_COUNT_H,\r\n&raw_fifocnt,\r\nsizeof(raw_fifocnt));\r\nif (ret)\r\ngoto out_trigger_unlock;\r\nfifocnt = be16_to_cpu(raw_fifocnt);\r\n}\r\nif (fifocnt < bytes_per_datum)\r\ndev_dbg(mpu3050->dev,\r\n"%d bytes left in the FIFO\n",\r\nfifocnt);\r\ntimestamp = 0;\r\n}\r\n}\r\nif (datums_from_fifo) {\r\ndev_dbg(mpu3050->dev,\r\n"read %d datums from the FIFO\n",\r\ndatums_from_fifo);\r\ngoto out_trigger_unlock;\r\n}\r\nret = regmap_bulk_read(mpu3050->map, MPU3050_TEMP_H, &hw_values,\r\nsizeof(hw_values));\r\nif (ret) {\r\ndev_err(mpu3050->dev,\r\n"error reading axis data\n");\r\ngoto out_trigger_unlock;\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, hw_values, timestamp);\r\nout_trigger_unlock:\r\nmutex_unlock(&mpu3050->lock);\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpu3050_buffer_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\npm_runtime_get_sync(mpu3050->dev);\r\nif (!mpu3050->hw_irq_trigger)\r\nreturn mpu3050_set_8khz_samplerate(mpu3050);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_buffer_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\npm_runtime_mark_last_busy(mpu3050->dev);\r\npm_runtime_put_autosuspend(mpu3050->dev);\r\nreturn 0;\r\n}\r\nstatic const struct iio_mount_matrix *\r\nmpu3050_get_mount_matrix(const struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nreturn &mpu3050->orientation;\r\n}\r\nstatic int mpu3050_read_mem(struct mpu3050 *mpu3050,\r\nu8 bank,\r\nu8 addr,\r\nu8 len,\r\nu8 *buf)\r\n{\r\nint ret;\r\nret = regmap_write(mpu3050->map,\r\nMPU3050_BANK_SEL,\r\nbank);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(mpu3050->map,\r\nMPU3050_MEM_START_ADDR,\r\naddr);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_bulk_read(mpu3050->map,\r\nMPU3050_MEM_R_W,\r\nbuf,\r\nlen);\r\n}\r\nstatic int mpu3050_hw_init(struct mpu3050 *mpu3050)\r\n{\r\nint ret;\r\nu8 otp[8];\r\nret = regmap_update_bits(mpu3050->map,\r\nMPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_RESET,\r\nMPU3050_PWR_MGM_RESET);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(mpu3050->map,\r\nMPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_CLKSEL_MASK,\r\nMPU3050_PWR_MGM_PLL_Z);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_write(mpu3050->map,\r\nMPU3050_INT_CFG,\r\n0);\r\nif (ret)\r\nreturn ret;\r\nret = mpu3050_read_mem(mpu3050,\r\n(MPU3050_MEM_PRFTCH |\r\nMPU3050_MEM_USER_BANK |\r\nMPU3050_MEM_OTP_BANK_0),\r\n0,\r\nsizeof(otp),\r\notp);\r\nif (ret)\r\nreturn ret;\r\nadd_device_randomness(otp, sizeof(otp));\r\ndev_info(mpu3050->dev,\r\n"die ID: %04X, wafer ID: %02X, A lot ID: %04X, "\r\n"W lot ID: %03X, WP ID: %01X, rev ID: %02X\n",\r\n(otp[1] << 8 | otp[0]) & 0x1fff,\r\n((otp[2] << 8 | otp[1]) & 0x03e0) >> 5,\r\n((otp[4] << 16 | otp[3] << 8 | otp[2]) & 0x3fffc) >> 2,\r\n((otp[5] << 8 | otp[4]) & 0x3ffc) >> 2,\r\n((otp[6] << 8 | otp[5]) & 0x0380) >> 7,\r\notp[6] >> 2);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_power_up(struct mpu3050 *mpu3050)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(mpu3050->regs), mpu3050->regs);\r\nif (ret) {\r\ndev_err(mpu3050->dev, "cannot enable regulators\n");\r\nreturn ret;\r\n}\r\nmsleep(200);\r\nret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_SLEEP, 0);\r\nif (ret) {\r\ndev_err(mpu3050->dev, "error setting power mode\n");\r\nreturn ret;\r\n}\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_power_down(struct mpu3050 *mpu3050)\r\n{\r\nint ret;\r\nret = regmap_update_bits(mpu3050->map, MPU3050_PWR_MGM,\r\nMPU3050_PWR_MGM_SLEEP, MPU3050_PWR_MGM_SLEEP);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error putting to sleep\n");\r\nret = regulator_bulk_disable(ARRAY_SIZE(mpu3050->regs), mpu3050->regs);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error disabling regulators\n");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mpu3050_irq_handler(int irq, void *p)\r\n{\r\nstruct iio_trigger *trig = p;\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nif (!mpu3050->hw_irq_trigger)\r\nreturn IRQ_NONE;\r\nmpu3050->hw_timestamp = iio_get_time_ns(indio_dev);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t mpu3050_irq_thread(int irq, void *p)\r\n{\r\nstruct iio_trigger *trig = p;\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\r\nif (ret) {\r\ndev_err(mpu3050->dev, "error reading IRQ status\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!(val & MPU3050_INT_STATUS_RAW_RDY))\r\nreturn IRQ_NONE;\r\niio_trigger_poll_chained(p);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpu3050_drdy_trigger_set_state(struct iio_trigger *trig,\r\nbool enable)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nunsigned int val;\r\nint ret;\r\nif (!enable) {\r\nret = regmap_write(mpu3050->map,\r\nMPU3050_INT_CFG,\r\n0);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error disabling IRQ\n");\r\nret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error clearing IRQ status\n");\r\nret = regmap_write(mpu3050->map, MPU3050_FIFO_EN, 0);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error disabling FIFO\n");\r\nret = regmap_write(mpu3050->map, MPU3050_USR_CTRL,\r\nMPU3050_USR_CTRL_FIFO_RST);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error resetting FIFO\n");\r\npm_runtime_mark_last_busy(mpu3050->dev);\r\npm_runtime_put_autosuspend(mpu3050->dev);\r\nmpu3050->hw_irq_trigger = false;\r\nreturn 0;\r\n} else {\r\npm_runtime_get_sync(mpu3050->dev);\r\nmpu3050->hw_irq_trigger = true;\r\nret = regmap_write(mpu3050->map, MPU3050_FIFO_EN, 0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(mpu3050->map, MPU3050_USR_CTRL,\r\nMPU3050_USR_CTRL_FIFO_EN |\r\nMPU3050_USR_CTRL_FIFO_RST,\r\nMPU3050_USR_CTRL_FIFO_EN |\r\nMPU3050_USR_CTRL_FIFO_RST);\r\nif (ret)\r\nreturn ret;\r\nmpu3050->pending_fifo_footer = false;\r\nret = regmap_write(mpu3050->map, MPU3050_FIFO_EN,\r\nMPU3050_FIFO_EN_TEMP_OUT |\r\nMPU3050_FIFO_EN_GYRO_XOUT |\r\nMPU3050_FIFO_EN_GYRO_YOUT |\r\nMPU3050_FIFO_EN_GYRO_ZOUT |\r\nMPU3050_FIFO_EN_FOOTER);\r\nif (ret)\r\nreturn ret;\r\nret = mpu3050_start_sampling(mpu3050);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(mpu3050->map, MPU3050_INT_STATUS, &val);\r\nif (ret)\r\ndev_err(mpu3050->dev, "error clearing IRQ status\n");\r\nval = MPU3050_INT_RAW_RDY_EN;\r\nif (mpu3050->irq_actl)\r\nval |= MPU3050_INT_ACTL;\r\nif (mpu3050->irq_latch)\r\nval |= MPU3050_INT_LATCH_EN;\r\nif (mpu3050->irq_opendrain)\r\nval |= MPU3050_INT_OPEN;\r\nret = regmap_write(mpu3050->map, MPU3050_INT_CFG, val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpu3050_trigger_probe(struct iio_dev *indio_dev, int irq)\r\n{\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nunsigned long irq_trig;\r\nint ret;\r\nmpu3050->trig = devm_iio_trigger_alloc(&indio_dev->dev,\r\n"%s-dev%d",\r\nindio_dev->name,\r\nindio_dev->id);\r\nif (!mpu3050->trig)\r\nreturn -ENOMEM;\r\nif (of_property_read_bool(mpu3050->dev->of_node, "drive-open-drain"))\r\nmpu3050->irq_opendrain = true;\r\nirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\r\nswitch (irq_trig) {\r\ncase IRQF_TRIGGER_RISING:\r\ndev_info(&indio_dev->dev,\r\n"pulse interrupts on the rising edge\n");\r\nif (mpu3050->irq_opendrain) {\r\ndev_info(&indio_dev->dev,\r\n"rising edge incompatible with open drain\n");\r\nmpu3050->irq_opendrain = false;\r\n}\r\nbreak;\r\ncase IRQF_TRIGGER_FALLING:\r\nmpu3050->irq_actl = true;\r\ndev_info(&indio_dev->dev,\r\n"pulse interrupts on the falling edge\n");\r\nbreak;\r\ncase IRQF_TRIGGER_HIGH:\r\nmpu3050->irq_latch = true;\r\ndev_info(&indio_dev->dev,\r\n"interrupts active high level\n");\r\nif (mpu3050->irq_opendrain) {\r\ndev_info(&indio_dev->dev,\r\n"active high incompatible with open drain\n");\r\nmpu3050->irq_opendrain = false;\r\n}\r\nirq_trig |= IRQF_ONESHOT;\r\nbreak;\r\ncase IRQF_TRIGGER_LOW:\r\nmpu3050->irq_latch = true;\r\nmpu3050->irq_actl = true;\r\nirq_trig |= IRQF_ONESHOT;\r\ndev_info(&indio_dev->dev,\r\n"interrupts active low level\n");\r\nbreak;\r\ndefault:\r\ndev_err(&indio_dev->dev,\r\n"unsupported IRQ trigger specified (%lx), enforce "\r\n"rising edge\n", irq_trig);\r\nirq_trig = IRQF_TRIGGER_RISING;\r\nbreak;\r\n}\r\nif (mpu3050->irq_opendrain)\r\nirq_trig |= IRQF_SHARED;\r\nret = request_threaded_irq(irq,\r\nmpu3050_irq_handler,\r\nmpu3050_irq_thread,\r\nirq_trig,\r\nmpu3050->trig->name,\r\nmpu3050->trig);\r\nif (ret) {\r\ndev_err(mpu3050->dev,\r\n"can't get IRQ %d, error %d\n", irq, ret);\r\nreturn ret;\r\n}\r\nmpu3050->irq = irq;\r\nmpu3050->trig->dev.parent = mpu3050->dev;\r\nmpu3050->trig->ops = &mpu3050_trigger_ops;\r\niio_trigger_set_drvdata(mpu3050->trig, indio_dev);\r\nret = iio_trigger_register(mpu3050->trig);\r\nif (ret)\r\nreturn ret;\r\nindio_dev->trig = iio_trigger_get(mpu3050->trig);\r\nreturn 0;\r\n}\r\nint mpu3050_common_probe(struct device *dev,\r\nstruct regmap *map,\r\nint irq,\r\nconst char *name)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct mpu3050 *mpu3050;\r\nunsigned int val;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*mpu3050));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nmpu3050 = iio_priv(indio_dev);\r\nmpu3050->dev = dev;\r\nmpu3050->map = map;\r\nmutex_init(&mpu3050->lock);\r\nmpu3050->fullscale = FS_2000_DPS;\r\nmpu3050->lpf = MPU3050_DLPF_CFG_188HZ;\r\nmpu3050->divisor = 99;\r\nret = of_iio_read_mount_matrix(dev, "mount-matrix",\r\n&mpu3050->orientation);\r\nif (ret)\r\nreturn ret;\r\nmpu3050->regs[0].supply = mpu3050_reg_vdd;\r\nmpu3050->regs[1].supply = mpu3050_reg_vlogic;\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(mpu3050->regs),\r\nmpu3050->regs);\r\nif (ret) {\r\ndev_err(dev, "Cannot get regulators\n");\r\nreturn ret;\r\n}\r\nret = mpu3050_power_up(mpu3050);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(map, MPU3050_CHIP_ID_REG, &val);\r\nif (ret) {\r\ndev_err(dev, "could not read device ID\n");\r\nret = -ENODEV;\r\ngoto err_power_down;\r\n}\r\nif (val != MPU3050_CHIP_ID) {\r\ndev_err(dev, "unsupported chip id %02x\n", (u8)val);\r\nret = -ENODEV;\r\ngoto err_power_down;\r\n}\r\nret = regmap_read(map, MPU3050_PRODUCT_ID_REG, &val);\r\nif (ret) {\r\ndev_err(dev, "could not read device ID\n");\r\nret = -ENODEV;\r\ngoto err_power_down;\r\n}\r\ndev_info(dev, "found MPU-3050 part no: %d, version: %d\n",\r\n((val >> 4) & 0xf), (val & 0xf));\r\nret = mpu3050_hw_init(mpu3050);\r\nif (ret)\r\ngoto err_power_down;\r\nindio_dev->dev.parent = dev;\r\nindio_dev->channels = mpu3050_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mpu3050_channels);\r\nindio_dev->info = &mpu3050_info;\r\nindio_dev->available_scan_masks = mpu3050_scan_masks;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = name;\r\nret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time,\r\nmpu3050_trigger_handler,\r\n&mpu3050_buffer_setup_ops);\r\nif (ret) {\r\ndev_err(dev, "triggered buffer setup failed\n");\r\ngoto err_power_down;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(dev, "device register failed\n");\r\ngoto err_cleanup_buffer;\r\n}\r\ndev_set_drvdata(dev, indio_dev);\r\nif (irq) {\r\nret = mpu3050_trigger_probe(indio_dev, irq);\r\nif (ret)\r\ndev_err(dev, "failed to register trigger\n");\r\n}\r\npm_runtime_get_noresume(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_set_autosuspend_delay(dev, 10000);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr_cleanup_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerr_power_down:\r\nmpu3050_power_down(mpu3050);\r\nreturn ret;\r\n}\r\nint mpu3050_common_remove(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\npm_runtime_get_sync(dev);\r\npm_runtime_put_noidle(dev);\r\npm_runtime_disable(dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nif (mpu3050->irq)\r\nfree_irq(mpu3050->irq, mpu3050);\r\niio_device_unregister(indio_dev);\r\nmpu3050_power_down(mpu3050);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_runtime_suspend(struct device *dev)\r\n{\r\nreturn mpu3050_power_down(iio_priv(dev_get_drvdata(dev)));\r\n}\r\nstatic int mpu3050_runtime_resume(struct device *dev)\r\n{\r\nreturn mpu3050_power_up(iio_priv(dev_get_drvdata(dev)));\r\n}
