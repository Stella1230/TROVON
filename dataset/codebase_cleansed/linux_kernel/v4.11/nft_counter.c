static inline void nft_counter_do_eval(struct nft_counter_percpu_priv *priv,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_counter *this_cpu;\r\nseqcount_t *myseq;\r\nlocal_bh_disable();\r\nthis_cpu = this_cpu_ptr(priv->counter);\r\nmyseq = this_cpu_ptr(&nft_counter_seq);\r\nwrite_seqcount_begin(myseq);\r\nthis_cpu->bytes += pkt->skb->len;\r\nthis_cpu->packets++;\r\nwrite_seqcount_end(myseq);\r\nlocal_bh_enable();\r\n}\r\nstatic inline void nft_counter_obj_eval(struct nft_object *obj,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\r\nnft_counter_do_eval(priv, regs, pkt);\r\n}\r\nstatic int nft_counter_do_init(const struct nlattr * const tb[],\r\nstruct nft_counter_percpu_priv *priv)\r\n{\r\nstruct nft_counter __percpu *cpu_stats;\r\nstruct nft_counter *this_cpu;\r\ncpu_stats = alloc_percpu(struct nft_counter);\r\nif (cpu_stats == NULL)\r\nreturn -ENOMEM;\r\npreempt_disable();\r\nthis_cpu = this_cpu_ptr(cpu_stats);\r\nif (tb[NFTA_COUNTER_PACKETS]) {\r\nthis_cpu->packets =\r\nbe64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\r\n}\r\nif (tb[NFTA_COUNTER_BYTES]) {\r\nthis_cpu->bytes =\r\nbe64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\r\n}\r\npreempt_enable();\r\npriv->counter = cpu_stats;\r\nreturn 0;\r\n}\r\nstatic int nft_counter_obj_init(const struct nlattr * const tb[],\r\nstruct nft_object *obj)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\r\nreturn nft_counter_do_init(tb, priv);\r\n}\r\nstatic void nft_counter_do_destroy(struct nft_counter_percpu_priv *priv)\r\n{\r\nfree_percpu(priv->counter);\r\n}\r\nstatic void nft_counter_obj_destroy(struct nft_object *obj)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\r\nnft_counter_do_destroy(priv);\r\n}\r\nstatic void nft_counter_reset(struct nft_counter_percpu_priv __percpu *priv,\r\nstruct nft_counter *total)\r\n{\r\nstruct nft_counter *this_cpu;\r\nlocal_bh_disable();\r\nthis_cpu = this_cpu_ptr(priv->counter);\r\nthis_cpu->packets -= total->packets;\r\nthis_cpu->bytes -= total->bytes;\r\nlocal_bh_enable();\r\n}\r\nstatic void nft_counter_fetch(struct nft_counter_percpu_priv *priv,\r\nstruct nft_counter *total)\r\n{\r\nstruct nft_counter *this_cpu;\r\nconst seqcount_t *myseq;\r\nu64 bytes, packets;\r\nunsigned int seq;\r\nint cpu;\r\nmemset(total, 0, sizeof(*total));\r\nfor_each_possible_cpu(cpu) {\r\nmyseq = per_cpu_ptr(&nft_counter_seq, cpu);\r\nthis_cpu = per_cpu_ptr(priv->counter, cpu);\r\ndo {\r\nseq = read_seqcount_begin(myseq);\r\nbytes = this_cpu->bytes;\r\npackets = this_cpu->packets;\r\n} while (read_seqcount_retry(myseq, seq));\r\ntotal->bytes += bytes;\r\ntotal->packets += packets;\r\n}\r\n}\r\nstatic int nft_counter_do_dump(struct sk_buff *skb,\r\nstruct nft_counter_percpu_priv *priv,\r\nbool reset)\r\n{\r\nstruct nft_counter total;\r\nnft_counter_fetch(priv, &total);\r\nif (nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes),\r\nNFTA_COUNTER_PAD) ||\r\nnla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.packets),\r\nNFTA_COUNTER_PAD))\r\ngoto nla_put_failure;\r\nif (reset)\r\nnft_counter_reset(priv, &total);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_counter_obj_dump(struct sk_buff *skb,\r\nstruct nft_object *obj, bool reset)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_obj_data(obj);\r\nreturn nft_counter_do_dump(skb, priv, reset);\r\n}\r\nstatic void nft_counter_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\r\nnft_counter_do_eval(priv, regs, pkt);\r\n}\r\nstatic int nft_counter_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\r\nreturn nft_counter_do_dump(skb, priv, false);\r\n}\r\nstatic int nft_counter_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\r\nreturn nft_counter_do_init(tb, priv);\r\n}\r\nstatic void nft_counter_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_expr_priv(expr);\r\nnft_counter_do_destroy(priv);\r\n}\r\nstatic int nft_counter_clone(struct nft_expr *dst, const struct nft_expr *src)\r\n{\r\nstruct nft_counter_percpu_priv *priv = nft_expr_priv(src);\r\nstruct nft_counter_percpu_priv *priv_clone = nft_expr_priv(dst);\r\nstruct nft_counter __percpu *cpu_stats;\r\nstruct nft_counter *this_cpu;\r\nstruct nft_counter total;\r\nnft_counter_fetch(priv, &total);\r\ncpu_stats = alloc_percpu_gfp(struct nft_counter, GFP_ATOMIC);\r\nif (cpu_stats == NULL)\r\nreturn -ENOMEM;\r\npreempt_disable();\r\nthis_cpu = this_cpu_ptr(cpu_stats);\r\nthis_cpu->packets = total.packets;\r\nthis_cpu->bytes = total.bytes;\r\npreempt_enable();\r\npriv_clone->counter = cpu_stats;\r\nreturn 0;\r\n}\r\nstatic int __init nft_counter_module_init(void)\r\n{\r\nint cpu, err;\r\nfor_each_possible_cpu(cpu)\r\nseqcount_init(per_cpu_ptr(&nft_counter_seq, cpu));\r\nerr = nft_register_obj(&nft_counter_obj);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_register_expr(&nft_counter_type);\r\nif (err < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nnft_unregister_obj(&nft_counter_obj);\r\nreturn err;\r\n}\r\nstatic void __exit nft_counter_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_counter_type);\r\nnft_unregister_obj(&nft_counter_obj);\r\n}
