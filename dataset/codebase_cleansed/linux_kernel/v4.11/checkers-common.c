enum probes_insn checker_stack_use_none(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nasi->stack_space = 0;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_unknown(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nasi->stack_space = -1;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_imm_0xx(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nint imm = insn & 0xff;\r\nasi->stack_space = imm;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_t32strd(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nint imm = insn & 0xff;\r\nasi->stack_space = imm << 2;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_imm_x0x(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nint imm = ((insn & 0xf00) >> 4) + (insn & 0xf);\r\nasi->stack_space = imm;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_imm_xxx(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nint imm = insn & 0xfff;\r\nasi->stack_space = imm;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nenum probes_insn checker_stack_use_stmdx(probes_opcode_t insn,\r\nstruct arch_probes_insn *asi,\r\nconst struct decode_header *h)\r\n{\r\nunsigned int reglist = insn & 0xffff;\r\nint pbit = insn & (1 << 24);\r\nasi->stack_space = (hweight32(reglist) - (!pbit ? 1 : 0)) * 4;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}
