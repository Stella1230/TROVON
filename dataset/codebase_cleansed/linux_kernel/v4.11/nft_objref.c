static void nft_objref_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_object *obj = nft_objref_priv(expr);\r\nobj->type->eval(obj, regs, pkt);\r\n}\r\nstatic int nft_objref_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_object *obj = nft_objref_priv(expr);\r\nu8 genmask = nft_genmask_next(ctx->net);\r\nu32 objtype;\r\nif (!tb[NFTA_OBJREF_IMM_NAME] ||\r\n!tb[NFTA_OBJREF_IMM_TYPE])\r\nreturn -EINVAL;\r\nobjtype = ntohl(nla_get_be32(tb[NFTA_OBJREF_IMM_TYPE]));\r\nobj = nf_tables_obj_lookup(ctx->table, tb[NFTA_OBJREF_IMM_NAME], objtype,\r\ngenmask);\r\nif (IS_ERR(obj))\r\nreturn -ENOENT;\r\nnft_objref_priv(expr) = obj;\r\nobj->use++;\r\nreturn 0;\r\n}\r\nstatic int nft_objref_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_object *obj = nft_objref_priv(expr);\r\nif (nla_put_string(skb, NFTA_OBJREF_IMM_NAME, obj->name) ||\r\nnla_put_be32(skb, NFTA_OBJREF_IMM_TYPE, htonl(obj->type->type)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic void nft_objref_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_object *obj = nft_objref_priv(expr);\r\nobj->use--;\r\n}\r\nstatic void nft_objref_map_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_objref_map *priv = nft_expr_priv(expr);\r\nconst struct nft_set *set = priv->set;\r\nconst struct nft_set_ext *ext;\r\nstruct nft_object *obj;\r\nbool found;\r\nfound = set->ops->lookup(nft_net(pkt), set, &regs->data[priv->sreg],\r\n&ext);\r\nif (!found) {\r\nregs->verdict.code = NFT_BREAK;\r\nreturn;\r\n}\r\nobj = *nft_set_ext_obj(ext);\r\nobj->type->eval(obj, regs, pkt);\r\n}\r\nstatic int nft_objref_map_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_objref_map *priv = nft_expr_priv(expr);\r\nu8 genmask = nft_genmask_next(ctx->net);\r\nstruct nft_set *set;\r\nint err;\r\nset = nf_tables_set_lookup(ctx->table, tb[NFTA_OBJREF_SET_NAME], genmask);\r\nif (IS_ERR(set)) {\r\nif (tb[NFTA_OBJREF_SET_ID]) {\r\nset = nf_tables_set_lookup_byid(ctx->net,\r\ntb[NFTA_OBJREF_SET_ID],\r\ngenmask);\r\n}\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\n}\r\nif (!(set->flags & NFT_SET_OBJECT))\r\nreturn -EINVAL;\r\npriv->sreg = nft_parse_register(tb[NFTA_OBJREF_SET_SREG]);\r\nerr = nft_validate_register_load(priv->sreg, set->klen);\r\nif (err < 0)\r\nreturn err;\r\npriv->binding.flags = set->flags & NFT_SET_OBJECT;\r\nerr = nf_tables_bind_set(ctx, set, &priv->binding);\r\nif (err < 0)\r\nreturn err;\r\npriv->set = set;\r\nreturn 0;\r\n}\r\nstatic int nft_objref_map_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_objref_map *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_OBJREF_SET_SREG, priv->sreg) ||\r\nnla_put_string(skb, NFTA_OBJREF_SET_NAME, priv->set->name))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic void nft_objref_map_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nstruct nft_objref_map *priv = nft_expr_priv(expr);\r\nnf_tables_unbind_set(ctx, priv->set, &priv->binding);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_objref_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_OBJREF_SET_SREG] &&\r\n(tb[NFTA_OBJREF_SET_NAME] ||\r\ntb[NFTA_OBJREF_SET_ID]))\r\nreturn &nft_objref_map_ops;\r\nelse if (tb[NFTA_OBJREF_IMM_NAME] &&\r\ntb[NFTA_OBJREF_IMM_TYPE])\r\nreturn &nft_objref_ops;\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nstatic int __init nft_objref_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_objref_type);\r\n}\r\nstatic void __exit nft_objref_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_objref_type);\r\n}
