void WILC_WFI_monitor_rx(u8 *buff, u32 size)\r\n{\r\nu32 header, pkt_offset;\r\nstruct sk_buff *skb = NULL;\r\nstruct wilc_wfi_radiotap_hdr *hdr;\r\nstruct wilc_wfi_radiotap_cb_hdr *cb_hdr;\r\nif (!wilc_wfi_mon)\r\nreturn;\r\nif (!netif_running(wilc_wfi_mon))\r\nreturn;\r\nmemcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);\r\npkt_offset = GET_PKT_OFFSET(header);\r\nif (pkt_offset & IS_MANAGMEMENT_CALLBACK) {\r\nskb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\nif (!skb)\r\nreturn;\r\nmemcpy(skb_put(skb, size), buff, size);\r\ncb_hdr = (struct wilc_wfi_radiotap_cb_hdr *)skb_push(skb, sizeof(*cb_hdr));\r\nmemset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\ncb_hdr->hdr.it_version = 0;\r\ncb_hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\ncb_hdr->hdr.it_present = cpu_to_le32(\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_TX_FLAGS));\r\ncb_hdr->rate = 5;\r\nif (pkt_offset & IS_MGMT_STATUS_SUCCES) {\r\ncb_hdr->tx_flags = IEEE80211_RADIOTAP_F_TX_RTS;\r\n} else {\r\ncb_hdr->tx_flags = IEEE80211_RADIOTAP_F_TX_FAIL;\r\n}\r\n} else {\r\nskb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_hdr));\r\nif (!skb)\r\nreturn;\r\nmemcpy(skb_put(skb, size), buff, size);\r\nhdr = (struct wilc_wfi_radiotap_hdr *)skb_push(skb, sizeof(*hdr));\r\nmemset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));\r\nhdr->hdr.it_version = 0;\r\nhdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_hdr));\r\nhdr->hdr.it_present = cpu_to_le32\r\n(1 << IEEE80211_RADIOTAP_RATE);\r\nhdr->rate = 5;\r\n}\r\nskb->dev = wilc_wfi_mon;\r\nskb_reset_mac_header(skb);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nskb->protocol = htons(ETH_P_802_2);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\nstatic void mgmt_tx_complete(void *priv, int status)\r\n{\r\nstruct tx_complete_mon_data *pv_data = priv;\r\nkfree(pv_data->buff);\r\nkfree(pv_data);\r\n}\r\nstatic int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)\r\n{\r\nstruct tx_complete_mon_data *mgmt_tx = NULL;\r\nif (!dev)\r\nreturn -EFAULT;\r\nnetif_stop_queue(dev);\r\nmgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);\r\nif (!mgmt_tx)\r\nreturn -ENOMEM;\r\nmgmt_tx->buff = kmalloc(len, GFP_ATOMIC);\r\nif (!mgmt_tx->buff) {\r\nkfree(mgmt_tx);\r\nreturn -ENOMEM;\r\n}\r\nmgmt_tx->size = len;\r\nmemcpy(mgmt_tx->buff, buf, len);\r\nwilc_wlan_txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,\r\nmgmt_tx_complete);\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t WILC_WFI_mon_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nu32 rtap_len, ret = 0;\r\nstruct WILC_WFI_mon_priv *mon_priv;\r\nstruct sk_buff *skb2;\r\nstruct wilc_wfi_radiotap_cb_hdr *cb_hdr;\r\nif (!wilc_wfi_mon)\r\nreturn -EFAULT;\r\nmon_priv = netdev_priv(wilc_wfi_mon);\r\nif (!mon_priv)\r\nreturn -EFAULT;\r\nrtap_len = ieee80211_get_radiotap_len(skb->data);\r\nif (skb->len < rtap_len)\r\nreturn -1;\r\nskb_pull(skb, rtap_len);\r\nif (skb->data[0] == 0xc0 && (!(memcmp(broadcast, &skb->data[4], 6)))) {\r\nskb2 = dev_alloc_skb(skb->len + sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\nmemcpy(skb_put(skb2, skb->len), skb->data, skb->len);\r\ncb_hdr = (struct wilc_wfi_radiotap_cb_hdr *)skb_push(skb2, sizeof(*cb_hdr));\r\nmemset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\ncb_hdr->hdr.it_version = 0;\r\ncb_hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_cb_hdr));\r\ncb_hdr->hdr.it_present = cpu_to_le32(\r\n(1 << IEEE80211_RADIOTAP_RATE) |\r\n(1 << IEEE80211_RADIOTAP_TX_FLAGS));\r\ncb_hdr->rate = 5;\r\ncb_hdr->tx_flags = 0x0004;\r\nskb2->dev = wilc_wfi_mon;\r\nskb_reset_mac_header(skb2);\r\nskb2->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb2->pkt_type = PACKET_OTHERHOST;\r\nskb2->protocol = htons(ETH_P_802_2);\r\nmemset(skb2->cb, 0, sizeof(skb2->cb));\r\nnetif_rx(skb2);\r\nreturn 0;\r\n}\r\nskb->dev = mon_priv->real_ndev;\r\nmemcpy(srcadd, &skb->data[10], 6);\r\nmemcpy(bssid, &skb->data[16], 6);\r\nif (!(memcmp(srcadd, bssid, 6))) {\r\nret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);\r\nif (ret)\r\nnetdev_err(dev, "fail to mgmt tx\n");\r\ndev_kfree_skb(skb);\r\n} else {\r\nret = wilc_mac_xmit(skb, mon_priv->real_ndev);\r\n}\r\nreturn ret;\r\n}\r\nstruct net_device *WILC_WFI_init_mon_interface(const char *name,\r\nstruct net_device *real_dev)\r\n{\r\nu32 ret = 0;\r\nstruct WILC_WFI_mon_priv *priv;\r\nif (wilc_wfi_mon)\r\nreturn wilc_wfi_mon;\r\nwilc_wfi_mon = alloc_etherdev(sizeof(struct WILC_WFI_mon_priv));\r\nif (!wilc_wfi_mon)\r\nreturn NULL;\r\nwilc_wfi_mon->type = ARPHRD_IEEE80211_RADIOTAP;\r\nstrncpy(wilc_wfi_mon->name, name, IFNAMSIZ);\r\nwilc_wfi_mon->name[IFNAMSIZ - 1] = 0;\r\nwilc_wfi_mon->netdev_ops = &wilc_wfi_netdev_ops;\r\nret = register_netdevice(wilc_wfi_mon);\r\nif (ret) {\r\nnetdev_err(real_dev, "register_netdevice failed\n");\r\nreturn NULL;\r\n}\r\npriv = netdev_priv(wilc_wfi_mon);\r\nif (!priv)\r\nreturn NULL;\r\npriv->real_ndev = real_dev;\r\nreturn wilc_wfi_mon;\r\n}\r\nint WILC_WFI_deinit_mon_interface(void)\r\n{\r\nbool rollback_lock = false;\r\nif (wilc_wfi_mon) {\r\nif (rtnl_is_locked()) {\r\nrtnl_unlock();\r\nrollback_lock = true;\r\n}\r\nunregister_netdev(wilc_wfi_mon);\r\nif (rollback_lock) {\r\nrtnl_lock();\r\nrollback_lock = false;\r\n}\r\nwilc_wfi_mon = NULL;\r\n}\r\nreturn 0;\r\n}
