static int pic32_rng_read(struct hwrng *rng, void *buf, size_t max,\r\nbool wait)\r\n{\r\nstruct pic32_rng *priv = container_of(rng, struct pic32_rng, rng);\r\nu64 *data = buf;\r\nu32 t;\r\nunsigned int timeout = RNG_TIMEOUT;\r\ndo {\r\nt = readl(priv->base + RNGRCNT) & RCNT_MASK;\r\nif (t == 64) {\r\n*data = ((u64)readl(priv->base + RNGSEED2) << 32) +\r\nreadl(priv->base + RNGSEED1);\r\nreturn 8;\r\n}\r\n} while (wait && --timeout);\r\nreturn -EIO;\r\n}\r\nstatic int pic32_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct pic32_rng *priv;\r\nstruct resource *res;\r\nu32 v;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->base))\r\nreturn PTR_ERR(priv->base);\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nv = TRNGEN | TRNGMOD;\r\nwritel(v, priv->base + RNGCON);\r\npriv->rng.name = pdev->name;\r\npriv->rng.read = pic32_rng_read;\r\nret = hwrng_register(&priv->rng);\r\nif (ret)\r\ngoto err_register;\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\nerr_register:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int pic32_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct pic32_rng *rng = platform_get_drvdata(pdev);\r\nhwrng_unregister(&rng->rng);\r\nwritel(0, rng->base + RNGCON);\r\nclk_disable_unprepare(rng->clk);\r\nreturn 0;\r\n}
