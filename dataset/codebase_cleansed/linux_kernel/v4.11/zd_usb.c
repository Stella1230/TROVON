static int request_fw_file(\r\nconst struct firmware **fw, const char *name, struct device *device)\r\n{\r\nint r;\r\ndev_dbg_f(device, "fw name %s\n", name);\r\nr = request_firmware(fw, name, device);\r\nif (r)\r\ndev_err(device,\r\n"Could not load firmware file %s. Error number %d\n",\r\nname, r);\r\nreturn r;\r\n}\r\nstatic inline u16 get_bcdDevice(const struct usb_device *udev)\r\n{\r\nreturn le16_to_cpu(udev->descriptor.bcdDevice);\r\n}\r\nstatic int upload_code(struct usb_device *udev,\r\nconst u8 *data, size_t size, u16 code_offset, int flags)\r\n{\r\nu8 *p;\r\nint r;\r\np = kmalloc(MAX_TRANSFER_SIZE, GFP_KERNEL);\r\nif (!p) {\r\nr = -ENOMEM;\r\ngoto error;\r\n}\r\nsize &= ~1;\r\nwhile (size > 0) {\r\nsize_t transfer_size = size <= MAX_TRANSFER_SIZE ?\r\nsize : MAX_TRANSFER_SIZE;\r\ndev_dbg_f(&udev->dev, "transfer size %zu\n", transfer_size);\r\nmemcpy(p, data, transfer_size);\r\nr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nUSB_REQ_FIRMWARE_DOWNLOAD,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR,\r\ncode_offset, 0, p, transfer_size, 1000 );\r\nif (r < 0) {\r\ndev_err(&udev->dev,\r\n"USB control request for firmware upload"\r\n" failed. Error number %d\n", r);\r\ngoto error;\r\n}\r\ntransfer_size = r & ~1;\r\nsize -= transfer_size;\r\ndata += transfer_size;\r\ncode_offset += transfer_size/sizeof(u16);\r\n}\r\nif (flags & REBOOT) {\r\nu8 ret;\r\nr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nUSB_REQ_FIRMWARE_CONFIRM,\r\nUSB_DIR_IN | USB_TYPE_VENDOR,\r\n0, 0, p, sizeof(ret), 5000 );\r\nif (r != sizeof(ret)) {\r\ndev_err(&udev->dev,\r\n"control request firmware confirmation failed."\r\n" Return value %d\n", r);\r\nif (r >= 0)\r\nr = -ENODEV;\r\ngoto error;\r\n}\r\nret = p[0];\r\nif (ret & 0x80) {\r\ndev_err(&udev->dev,\r\n"Internal error while downloading."\r\n" Firmware confirm return value %#04x\n",\r\n(unsigned int)ret);\r\nr = -ENODEV;\r\ngoto error;\r\n}\r\ndev_dbg_f(&udev->dev, "firmware confirm return value %#04x\n",\r\n(unsigned int)ret);\r\n}\r\nr = 0;\r\nerror:\r\nkfree(p);\r\nreturn r;\r\n}\r\nstatic u16 get_word(const void *data, u16 offset)\r\n{\r\nconst __le16 *p = data;\r\nreturn le16_to_cpu(p[offset]);\r\n}\r\nstatic char *get_fw_name(struct zd_usb *usb, char *buffer, size_t size,\r\nconst char* postfix)\r\n{\r\nscnprintf(buffer, size, "%s%s",\r\nusb->is_zd1211b ?\r\nFW_ZD1211B_PREFIX : FW_ZD1211_PREFIX,\r\npostfix);\r\nreturn buffer;\r\n}\r\nstatic int handle_version_mismatch(struct zd_usb *usb,\r\nconst struct firmware *ub_fw)\r\n{\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nconst struct firmware *ur_fw = NULL;\r\nint offset;\r\nint r = 0;\r\nchar fw_name[128];\r\nr = request_fw_file(&ur_fw,\r\nget_fw_name(usb, fw_name, sizeof(fw_name), "ur"),\r\n&udev->dev);\r\nif (r)\r\ngoto error;\r\nr = upload_code(udev, ur_fw->data, ur_fw->size, FW_START, REBOOT);\r\nif (r)\r\ngoto error;\r\noffset = (E2P_BOOT_CODE_OFFSET * sizeof(u16));\r\nr = upload_code(udev, ub_fw->data + offset, ub_fw->size - offset,\r\nE2P_START + E2P_BOOT_CODE_OFFSET, REBOOT);\r\nerror:\r\nrelease_firmware(ur_fw);\r\nreturn r;\r\n}\r\nstatic int upload_firmware(struct zd_usb *usb)\r\n{\r\nint r;\r\nu16 fw_bcdDevice;\r\nu16 bcdDevice;\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nconst struct firmware *ub_fw = NULL;\r\nconst struct firmware *uph_fw = NULL;\r\nchar fw_name[128];\r\nbcdDevice = get_bcdDevice(udev);\r\nr = request_fw_file(&ub_fw,\r\nget_fw_name(usb, fw_name, sizeof(fw_name), "ub"),\r\n&udev->dev);\r\nif (r)\r\ngoto error;\r\nfw_bcdDevice = get_word(ub_fw->data, E2P_DATA_OFFSET);\r\nif (fw_bcdDevice != bcdDevice) {\r\ndev_info(&udev->dev,\r\n"firmware version %#06x and device bootcode version "\r\n"%#06x differ\n", fw_bcdDevice, bcdDevice);\r\nif (bcdDevice <= 0x4313)\r\ndev_warn(&udev->dev, "device has old bootcode, please "\r\n"report success or failure\n");\r\nr = handle_version_mismatch(usb, ub_fw);\r\nif (r)\r\ngoto error;\r\n} else {\r\ndev_dbg_f(&udev->dev,\r\n"firmware device id %#06x is equal to the "\r\n"actual device id\n", fw_bcdDevice);\r\n}\r\nr = request_fw_file(&uph_fw,\r\nget_fw_name(usb, fw_name, sizeof(fw_name), "uphr"),\r\n&udev->dev);\r\nif (r)\r\ngoto error;\r\nr = upload_code(udev, uph_fw->data, uph_fw->size, FW_START, REBOOT);\r\nif (r) {\r\ndev_err(&udev->dev,\r\n"Could not upload firmware code uph. Error number %d\n",\r\nr);\r\n}\r\nerror:\r\nrelease_firmware(ub_fw);\r\nrelease_firmware(uph_fw);\r\nreturn r;\r\n}\r\nint zd_usb_read_fw(struct zd_usb *usb, zd_addr_t addr, u8 *data, u16 len)\r\n{\r\nint r;\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nu8 *buf;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nUSB_REQ_FIRMWARE_READ_DATA, USB_DIR_IN | 0x40, addr, 0,\r\nbuf, len, 5000);\r\nif (r < 0) {\r\ndev_err(&udev->dev,\r\n"read over firmware interface failed: %d\n", r);\r\ngoto exit;\r\n} else if (r != len) {\r\ndev_err(&udev->dev,\r\n"incomplete read over firmware interface: %d/%d\n",\r\nr, len);\r\nr = -EIO;\r\ngoto exit;\r\n}\r\nr = 0;\r\nmemcpy(data, buf, len);\r\nexit:\r\nkfree(buf);\r\nreturn r;\r\n}\r\nstatic inline void handle_regs_int_override(struct urb *urb)\r\n{\r\nstruct zd_usb *usb = urb->context;\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nspin_lock(&intr->lock);\r\nif (atomic_read(&intr->read_regs_enabled)) {\r\natomic_set(&intr->read_regs_enabled, 0);\r\nintr->read_regs_int_overridden = 1;\r\ncomplete(&intr->read_regs.completion);\r\n}\r\nspin_unlock(&intr->lock);\r\n}\r\nstatic inline void handle_regs_int(struct urb *urb)\r\n{\r\nstruct zd_usb *usb = urb->context;\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nint len;\r\nu16 int_num;\r\nZD_ASSERT(in_interrupt());\r\nspin_lock(&intr->lock);\r\nint_num = le16_to_cpu(*(__le16 *)(urb->transfer_buffer+2));\r\nif (int_num == CR_INTERRUPT) {\r\nstruct zd_mac *mac = zd_hw_mac(zd_usb_to_hw(urb->context));\r\nspin_lock(&mac->lock);\r\nmemcpy(&mac->intr_buffer, urb->transfer_buffer,\r\nUSB_MAX_EP_INT_BUFFER);\r\nspin_unlock(&mac->lock);\r\nschedule_work(&mac->process_intr);\r\n} else if (atomic_read(&intr->read_regs_enabled)) {\r\nlen = urb->actual_length;\r\nintr->read_regs.length = urb->actual_length;\r\nif (len > sizeof(intr->read_regs.buffer))\r\nlen = sizeof(intr->read_regs.buffer);\r\nmemcpy(intr->read_regs.buffer, urb->transfer_buffer, len);\r\nif (!check_read_regs(usb, intr->read_regs.req,\r\nintr->read_regs.req_count))\r\ngoto out;\r\natomic_set(&intr->read_regs_enabled, 0);\r\nintr->read_regs_int_overridden = 0;\r\ncomplete(&intr->read_regs.completion);\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock(&intr->lock);\r\nif (int_num == CR_INTERRUPT && atomic_read(&intr->read_regs_enabled))\r\nhandle_regs_int_override(urb);\r\n}\r\nstatic void int_urb_complete(struct urb *urb)\r\n{\r\nint r;\r\nstruct usb_int_header *hdr;\r\nstruct zd_usb *usb;\r\nstruct zd_usb_interrupt *intr;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -EINVAL:\r\ncase -ENODEV:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EPIPE:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\ngoto resubmit;\r\n}\r\nif (urb->actual_length < sizeof(hdr)) {\r\ndev_dbg_f(urb_dev(urb), "error: urb %p to small\n", urb);\r\ngoto resubmit;\r\n}\r\nhdr = urb->transfer_buffer;\r\nif (hdr->type != USB_INT_TYPE) {\r\ndev_dbg_f(urb_dev(urb), "error: urb %p wrong type\n", urb);\r\ngoto resubmit;\r\n}\r\nusb = urb->context;\r\nintr = &usb->intr;\r\nif (hdr->id != USB_INT_ID_REGS && atomic_read(&intr->read_regs_enabled))\r\nhandle_regs_int_override(urb);\r\nswitch (hdr->id) {\r\ncase USB_INT_ID_REGS:\r\nhandle_regs_int(urb);\r\nbreak;\r\ncase USB_INT_ID_RETRY_FAILED:\r\nzd_mac_tx_failed(urb);\r\nbreak;\r\ndefault:\r\ndev_dbg_f(urb_dev(urb), "error: urb %p unknown id %x\n", urb,\r\n(unsigned int)hdr->id);\r\ngoto resubmit;\r\n}\r\nresubmit:\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r) {\r\ndev_dbg_f(urb_dev(urb), "error: resubmit urb %p err code %d\n",\r\nurb, r);\r\n}\r\nreturn;\r\n}\r\nstatic inline int int_urb_interval(struct usb_device *udev)\r\n{\r\nswitch (udev->speed) {\r\ncase USB_SPEED_HIGH:\r\nreturn 4;\r\ncase USB_SPEED_LOW:\r\nreturn 10;\r\ncase USB_SPEED_FULL:\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int usb_int_enabled(struct zd_usb *usb)\r\n{\r\nunsigned long flags;\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nstruct urb *urb;\r\nspin_lock_irqsave(&intr->lock, flags);\r\nurb = intr->urb;\r\nspin_unlock_irqrestore(&intr->lock, flags);\r\nreturn urb != NULL;\r\n}\r\nint zd_usb_enable_int(struct zd_usb *usb)\r\n{\r\nint r;\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nstruct urb *urb;\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nZD_ASSERT(!irqs_disabled());\r\nspin_lock_irq(&intr->lock);\r\nif (intr->urb) {\r\nspin_unlock_irq(&intr->lock);\r\nr = 0;\r\ngoto error_free_urb;\r\n}\r\nintr->urb = urb;\r\nspin_unlock_irq(&intr->lock);\r\nr = -ENOMEM;\r\nintr->buffer = usb_alloc_coherent(udev, USB_MAX_EP_INT_BUFFER,\r\nGFP_KERNEL, &intr->buffer_dma);\r\nif (!intr->buffer) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"couldn't allocate transfer_buffer\n");\r\ngoto error_set_urb_null;\r\n}\r\nusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, EP_INT_IN),\r\nintr->buffer, USB_MAX_EP_INT_BUFFER,\r\nint_urb_complete, usb,\r\nintr->interval);\r\nurb->transfer_dma = intr->buffer_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\ndev_dbg_f(zd_usb_dev(usb), "submit urb %p\n", intr->urb);\r\nr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"Couldn't submit urb. Error number %d\n", r);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nusb_free_coherent(udev, USB_MAX_EP_INT_BUFFER,\r\nintr->buffer, intr->buffer_dma);\r\nerror_set_urb_null:\r\nspin_lock_irq(&intr->lock);\r\nintr->urb = NULL;\r\nspin_unlock_irq(&intr->lock);\r\nerror_free_urb:\r\nusb_free_urb(urb);\r\nout:\r\nreturn r;\r\n}\r\nvoid zd_usb_disable_int(struct zd_usb *usb)\r\n{\r\nunsigned long flags;\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nstruct urb *urb;\r\nvoid *buffer;\r\ndma_addr_t buffer_dma;\r\nspin_lock_irqsave(&intr->lock, flags);\r\nurb = intr->urb;\r\nif (!urb) {\r\nspin_unlock_irqrestore(&intr->lock, flags);\r\nreturn;\r\n}\r\nintr->urb = NULL;\r\nbuffer = intr->buffer;\r\nbuffer_dma = intr->buffer_dma;\r\nintr->buffer = NULL;\r\nspin_unlock_irqrestore(&intr->lock, flags);\r\nusb_kill_urb(urb);\r\ndev_dbg_f(zd_usb_dev(usb), "urb %p killed\n", urb);\r\nusb_free_urb(urb);\r\nif (buffer)\r\nusb_free_coherent(udev, USB_MAX_EP_INT_BUFFER,\r\nbuffer, buffer_dma);\r\n}\r\nstatic void handle_rx_packet(struct zd_usb *usb, const u8 *buffer,\r\nunsigned int length)\r\n{\r\nint i;\r\nconst struct rx_length_info *length_info;\r\nif (length < sizeof(struct rx_length_info)) {\r\ndev_dbg_f(zd_usb_dev(usb), "invalid, small RX packet : %d\n",\r\nlength);\r\nreturn;\r\n}\r\nlength_info = (struct rx_length_info *)\r\n(buffer + length - sizeof(struct rx_length_info));\r\nif (get_unaligned_le16(&length_info->tag) == RX_LENGTH_INFO_TAG)\r\n{\r\nunsigned int l, k, n;\r\nfor (i = 0, l = 0;; i++) {\r\nk = get_unaligned_le16(&length_info->length[i]);\r\nif (k == 0)\r\nreturn;\r\nn = l+k;\r\nif (n > length)\r\nreturn;\r\nzd_mac_rx(zd_usb_to_hw(usb), buffer+l, k);\r\nif (i >= 2)\r\nreturn;\r\nl = (n+3) & ~3;\r\n}\r\n} else {\r\nzd_mac_rx(zd_usb_to_hw(usb), buffer, length);\r\n}\r\n}\r\nstatic void rx_urb_complete(struct urb *urb)\r\n{\r\nint r;\r\nstruct zd_usb *usb;\r\nstruct zd_usb_rx *rx;\r\nconst u8 *buffer;\r\nunsigned int length;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -EINVAL:\r\ncase -ENODEV:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EPIPE:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\ngoto resubmit;\r\n}\r\nbuffer = urb->transfer_buffer;\r\nlength = urb->actual_length;\r\nusb = urb->context;\r\nrx = &usb->rx;\r\ntasklet_schedule(&rx->reset_timer_tasklet);\r\nif (length%rx->usb_packet_size > rx->usb_packet_size-4) {\r\ndev_dbg_f(urb_dev(urb), "*** first fragment ***\n");\r\nZD_ASSERT(length <= ARRAY_SIZE(rx->fragment));\r\nspin_lock(&rx->lock);\r\nmemcpy(rx->fragment, buffer, length);\r\nrx->fragment_length = length;\r\nspin_unlock(&rx->lock);\r\ngoto resubmit;\r\n}\r\nspin_lock(&rx->lock);\r\nif (rx->fragment_length > 0) {\r\nZD_ASSERT(length + rx->fragment_length <=\r\nARRAY_SIZE(rx->fragment));\r\ndev_dbg_f(urb_dev(urb), "*** second fragment ***\n");\r\nmemcpy(rx->fragment+rx->fragment_length, buffer, length);\r\nhandle_rx_packet(usb, rx->fragment,\r\nrx->fragment_length + length);\r\nrx->fragment_length = 0;\r\nspin_unlock(&rx->lock);\r\n} else {\r\nspin_unlock(&rx->lock);\r\nhandle_rx_packet(usb, buffer, length);\r\n}\r\nresubmit:\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r)\r\ndev_dbg_f(urb_dev(urb), "urb %p resubmit error %d\n", urb, r);\r\n}\r\nstatic struct urb *alloc_rx_urb(struct zd_usb *usb)\r\n{\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nstruct urb *urb;\r\nvoid *buffer;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn NULL;\r\nbuffer = usb_alloc_coherent(udev, USB_MAX_RX_SIZE, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buffer) {\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nusb_fill_bulk_urb(urb, udev, usb_rcvbulkpipe(udev, EP_DATA_IN),\r\nbuffer, USB_MAX_RX_SIZE,\r\nrx_urb_complete, usb);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nreturn urb;\r\n}\r\nstatic void free_rx_urb(struct urb *urb)\r\n{\r\nif (!urb)\r\nreturn;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\n}\r\nstatic int __zd_usb_enable_rx(struct zd_usb *usb)\r\n{\r\nint i, r;\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nstruct urb **urbs;\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nr = -ENOMEM;\r\nurbs = kcalloc(RX_URBS_COUNT, sizeof(struct urb *), GFP_KERNEL);\r\nif (!urbs)\r\ngoto error;\r\nfor (i = 0; i < RX_URBS_COUNT; i++) {\r\nurbs[i] = alloc_rx_urb(usb);\r\nif (!urbs[i])\r\ngoto error;\r\n}\r\nZD_ASSERT(!irqs_disabled());\r\nspin_lock_irq(&rx->lock);\r\nif (rx->urbs) {\r\nspin_unlock_irq(&rx->lock);\r\nr = 0;\r\ngoto error;\r\n}\r\nrx->urbs = urbs;\r\nrx->urbs_count = RX_URBS_COUNT;\r\nspin_unlock_irq(&rx->lock);\r\nfor (i = 0; i < RX_URBS_COUNT; i++) {\r\nr = usb_submit_urb(urbs[i], GFP_KERNEL);\r\nif (r)\r\ngoto error_submit;\r\n}\r\nreturn 0;\r\nerror_submit:\r\nfor (i = 0; i < RX_URBS_COUNT; i++) {\r\nusb_kill_urb(urbs[i]);\r\n}\r\nspin_lock_irq(&rx->lock);\r\nrx->urbs = NULL;\r\nrx->urbs_count = 0;\r\nspin_unlock_irq(&rx->lock);\r\nerror:\r\nif (urbs) {\r\nfor (i = 0; i < RX_URBS_COUNT; i++)\r\nfree_rx_urb(urbs[i]);\r\n}\r\nreturn r;\r\n}\r\nint zd_usb_enable_rx(struct zd_usb *usb)\r\n{\r\nint r;\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nmutex_lock(&rx->setup_mutex);\r\nr = __zd_usb_enable_rx(usb);\r\nmutex_unlock(&rx->setup_mutex);\r\nzd_usb_reset_rx_idle_timer(usb);\r\nreturn r;\r\n}\r\nstatic void __zd_usb_disable_rx(struct zd_usb *usb)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct urb **urbs;\r\nunsigned int count;\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nspin_lock_irqsave(&rx->lock, flags);\r\nurbs = rx->urbs;\r\ncount = rx->urbs_count;\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nif (!urbs)\r\nreturn;\r\nfor (i = 0; i < count; i++) {\r\nusb_kill_urb(urbs[i]);\r\nfree_rx_urb(urbs[i]);\r\n}\r\nkfree(urbs);\r\nspin_lock_irqsave(&rx->lock, flags);\r\nrx->urbs = NULL;\r\nrx->urbs_count = 0;\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\n}\r\nvoid zd_usb_disable_rx(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nmutex_lock(&rx->setup_mutex);\r\n__zd_usb_disable_rx(usb);\r\nmutex_unlock(&rx->setup_mutex);\r\ntasklet_kill(&rx->reset_timer_tasklet);\r\ncancel_delayed_work_sync(&rx->idle_work);\r\n}\r\nstatic void zd_usb_reset_rx(struct zd_usb *usb)\r\n{\r\nbool do_reset;\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nunsigned long flags;\r\nmutex_lock(&rx->setup_mutex);\r\nspin_lock_irqsave(&rx->lock, flags);\r\ndo_reset = rx->urbs != NULL;\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nif (do_reset) {\r\n__zd_usb_disable_rx(usb);\r\n__zd_usb_enable_rx(usb);\r\n}\r\nmutex_unlock(&rx->setup_mutex);\r\nif (do_reset)\r\nzd_usb_reset_rx_idle_timer(usb);\r\n}\r\nvoid zd_usb_disable_tx(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nunsigned long flags;\r\natomic_set(&tx->enabled, 0);\r\nusb_kill_anchored_urbs(&tx->submitted);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nWARN_ON(!skb_queue_empty(&tx->submitted_skbs));\r\nWARN_ON(tx->submitted_urbs != 0);\r\ntx->submitted_urbs = 0;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nvoid zd_usb_enable_tx(struct zd_usb *usb)\r\n{\r\nunsigned long flags;\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nspin_lock_irqsave(&tx->lock, flags);\r\natomic_set(&tx->enabled, 1);\r\ntx->submitted_urbs = 0;\r\nieee80211_wake_queues(zd_usb_to_hw(usb));\r\ntx->stopped = 0;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic void tx_dec_submitted_urbs(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\n--tx->submitted_urbs;\r\nif (tx->stopped && tx->submitted_urbs <= ZD_USB_TX_LOW) {\r\nieee80211_wake_queues(zd_usb_to_hw(usb));\r\ntx->stopped = 0;\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic void tx_inc_submitted_urbs(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\n++tx->submitted_urbs;\r\nif (!tx->stopped && tx->submitted_urbs > ZD_USB_TX_HIGH) {\r\nieee80211_stop_queues(zd_usb_to_hw(usb));\r\ntx->stopped = 1;\r\n}\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic void tx_urb_complete(struct urb *urb)\r\n{\r\nint r;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_tx_info *info;\r\nstruct zd_usb *usb;\r\nstruct zd_usb_tx *tx;\r\nskb = (struct sk_buff *)urb->context;\r\ninfo = IEEE80211_SKB_CB(skb);\r\nusb = &zd_hw_mac(info->rate_driver_data[0])->chip.usb;\r\ntx = &usb->tx;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -EINVAL:\r\ncase -ENODEV:\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -EPIPE:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\nbreak;\r\ndefault:\r\ndev_dbg_f(urb_dev(urb), "urb %p error %d\n", urb, urb->status);\r\ngoto resubmit;\r\n}\r\nfree_urb:\r\nskb_unlink(skb, &usb->tx.submitted_skbs);\r\nzd_mac_tx_to_dev(skb, urb->status);\r\nusb_free_urb(urb);\r\ntx_dec_submitted_urbs(usb);\r\nreturn;\r\nresubmit:\r\nusb_anchor_urb(urb, &tx->submitted);\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r) {\r\nusb_unanchor_urb(urb);\r\ndev_dbg_f(urb_dev(urb), "error resubmit urb %p %d\n", urb, r);\r\ngoto free_urb;\r\n}\r\n}\r\nint zd_usb_tx(struct zd_usb *usb, struct sk_buff *skb)\r\n{\r\nint r;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct usb_device *udev = zd_usb_to_usbdev(usb);\r\nstruct urb *urb;\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nif (!atomic_read(&tx->enabled)) {\r\nr = -ENOENT;\r\ngoto out;\r\n}\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, EP_DATA_OUT),\r\nskb->data, skb->len, tx_urb_complete, skb);\r\ninfo->rate_driver_data[1] = (void *)jiffies;\r\nskb_queue_tail(&tx->submitted_skbs, skb);\r\nusb_anchor_urb(urb, &tx->submitted);\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb), "error submit urb %p %d\n", urb, r);\r\nusb_unanchor_urb(urb);\r\nskb_unlink(skb, &tx->submitted_skbs);\r\ngoto error;\r\n}\r\ntx_inc_submitted_urbs(usb);\r\nreturn 0;\r\nerror:\r\nusb_free_urb(urb);\r\nout:\r\nreturn r;\r\n}\r\nstatic bool zd_tx_timeout(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nstruct sk_buff_head *q = &tx->submitted_skbs;\r\nstruct sk_buff *skb, *skbnext;\r\nstruct ieee80211_tx_info *info;\r\nunsigned long flags, trans_start;\r\nbool have_timedout = false;\r\nspin_lock_irqsave(&q->lock, flags);\r\nskb_queue_walk_safe(q, skb, skbnext) {\r\ninfo = IEEE80211_SKB_CB(skb);\r\ntrans_start = (unsigned long)info->rate_driver_data[1];\r\nif (time_is_before_jiffies(trans_start + ZD_TX_TIMEOUT)) {\r\nhave_timedout = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&q->lock, flags);\r\nreturn have_timedout;\r\n}\r\nstatic void zd_tx_watchdog_handler(struct work_struct *work)\r\n{\r\nstruct zd_usb *usb =\r\ncontainer_of(work, struct zd_usb, tx.watchdog_work.work);\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nif (!atomic_read(&tx->enabled) || !tx->watchdog_enabled)\r\ngoto out;\r\nif (!zd_tx_timeout(usb))\r\ngoto out;\r\ndev_warn(zd_usb_dev(usb), "TX-stall detected, resetting device...");\r\nusb_queue_reset_device(usb->intf);\r\nreturn;\r\nout:\r\nqueue_delayed_work(zd_workqueue, &tx->watchdog_work,\r\nZD_TX_WATCHDOG_INTERVAL);\r\n}\r\nvoid zd_tx_watchdog_enable(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nif (!tx->watchdog_enabled) {\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nqueue_delayed_work(zd_workqueue, &tx->watchdog_work,\r\nZD_TX_WATCHDOG_INTERVAL);\r\ntx->watchdog_enabled = 1;\r\n}\r\n}\r\nvoid zd_tx_watchdog_disable(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nif (tx->watchdog_enabled) {\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\ntx->watchdog_enabled = 0;\r\ncancel_delayed_work_sync(&tx->watchdog_work);\r\n}\r\n}\r\nstatic void zd_rx_idle_timer_handler(struct work_struct *work)\r\n{\r\nstruct zd_usb *usb =\r\ncontainer_of(work, struct zd_usb, rx.idle_work.work);\r\nstruct zd_mac *mac = zd_usb_to_mac(usb);\r\nif (!test_bit(ZD_DEVICE_RUNNING, &mac->flags))\r\nreturn;\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nzd_usb_reset_rx(usb);\r\n}\r\nstatic void zd_usb_reset_rx_idle_timer_tasklet(unsigned long param)\r\n{\r\nstruct zd_usb *usb = (struct zd_usb *)param;\r\nzd_usb_reset_rx_idle_timer(usb);\r\n}\r\nvoid zd_usb_reset_rx_idle_timer(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nmod_delayed_work(zd_workqueue, &rx->idle_work, ZD_RX_IDLE_INTERVAL);\r\n}\r\nstatic inline void init_usb_interrupt(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nspin_lock_init(&intr->lock);\r\nintr->interval = int_urb_interval(zd_usb_to_usbdev(usb));\r\ninit_completion(&intr->read_regs.completion);\r\natomic_set(&intr->read_regs_enabled, 0);\r\nintr->read_regs.cr_int_addr = cpu_to_le16((u16)CR_INTERRUPT);\r\n}\r\nstatic inline void init_usb_rx(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_rx *rx = &usb->rx;\r\nspin_lock_init(&rx->lock);\r\nmutex_init(&rx->setup_mutex);\r\nif (interface_to_usbdev(usb->intf)->speed == USB_SPEED_HIGH) {\r\nrx->usb_packet_size = 512;\r\n} else {\r\nrx->usb_packet_size = 64;\r\n}\r\nZD_ASSERT(rx->fragment_length == 0);\r\nINIT_DELAYED_WORK(&rx->idle_work, zd_rx_idle_timer_handler);\r\nrx->reset_timer_tasklet.func = zd_usb_reset_rx_idle_timer_tasklet;\r\nrx->reset_timer_tasklet.data = (unsigned long)usb;\r\n}\r\nstatic inline void init_usb_tx(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_tx *tx = &usb->tx;\r\nspin_lock_init(&tx->lock);\r\natomic_set(&tx->enabled, 0);\r\ntx->stopped = 0;\r\nskb_queue_head_init(&tx->submitted_skbs);\r\ninit_usb_anchor(&tx->submitted);\r\ntx->submitted_urbs = 0;\r\ntx->watchdog_enabled = 0;\r\nINIT_DELAYED_WORK(&tx->watchdog_work, zd_tx_watchdog_handler);\r\n}\r\nvoid zd_usb_init(struct zd_usb *usb, struct ieee80211_hw *hw,\r\nstruct usb_interface *intf)\r\n{\r\nmemset(usb, 0, sizeof(*usb));\r\nusb->intf = usb_get_intf(intf);\r\nusb_set_intfdata(usb->intf, hw);\r\ninit_usb_anchor(&usb->submitted_cmds);\r\ninit_usb_interrupt(usb);\r\ninit_usb_tx(usb);\r\ninit_usb_rx(usb);\r\n}\r\nvoid zd_usb_clear(struct zd_usb *usb)\r\n{\r\nusb_set_intfdata(usb->intf, NULL);\r\nusb_put_intf(usb->intf);\r\nZD_MEMCLEAR(usb, sizeof(*usb));\r\n}\r\nstatic const char *speed(enum usb_device_speed speed)\r\n{\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\nreturn "low";\r\ncase USB_SPEED_FULL:\r\nreturn "full";\r\ncase USB_SPEED_HIGH:\r\nreturn "high";\r\ndefault:\r\nreturn "unknown speed";\r\n}\r\n}\r\nstatic int scnprint_id(struct usb_device *udev, char *buffer, size_t size)\r\n{\r\nreturn scnprintf(buffer, size, "%04hx:%04hx v%04hx %s",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct),\r\nget_bcdDevice(udev),\r\nspeed(udev->speed));\r\n}\r\nint zd_usb_scnprint_id(struct zd_usb *usb, char *buffer, size_t size)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(usb->intf);\r\nreturn scnprint_id(udev, buffer, size);\r\n}\r\nstatic void print_id(struct usb_device *udev)\r\n{\r\nchar buffer[40];\r\nscnprint_id(udev, buffer, sizeof(buffer));\r\nbuffer[sizeof(buffer)-1] = 0;\r\ndev_dbg_f(&udev->dev, "%s\n", buffer);\r\n}\r\nstatic int eject_installer(struct usb_interface *intf)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_host_interface *iface_desc = &intf->altsetting[0];\r\nstruct usb_endpoint_descriptor *endpoint;\r\nunsigned char *cmd;\r\nu8 bulk_out_ep;\r\nint r;\r\nfor (r = 1; r >= 0; r--) {\r\nendpoint = &iface_desc->endpoint[r].desc;\r\nif (usb_endpoint_dir_out(endpoint) &&\r\nusb_endpoint_xfer_bulk(endpoint)) {\r\nbulk_out_ep = endpoint->bEndpointAddress;\r\nbreak;\r\n}\r\n}\r\nif (r == -1) {\r\ndev_err(&udev->dev,\r\n"zd1211rw: Could not find bulk out endpoint\n");\r\nreturn -ENODEV;\r\n}\r\ncmd = kzalloc(31, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENODEV;\r\ncmd[0] = 0x55;\r\ncmd[1] = 0x53;\r\ncmd[2] = 0x42;\r\ncmd[3] = 0x43;\r\ncmd[14] = 6;\r\ncmd[15] = 0x1b;\r\ncmd[19] = 0x2;\r\ndev_info(&udev->dev, "Ejecting virtual installer media...\n");\r\nr = usb_bulk_msg(udev, usb_sndbulkpipe(udev, bulk_out_ep),\r\ncmd, 31, NULL, 2000);\r\nkfree(cmd);\r\nif (r)\r\nreturn r;\r\nusb_set_intfdata(intf, NULL);\r\nreturn 0;\r\n}\r\nint zd_usb_init_hw(struct zd_usb *usb)\r\n{\r\nint r;\r\nstruct zd_mac *mac = zd_usb_to_mac(usb);\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nr = upload_firmware(usb);\r\nif (r) {\r\ndev_err(zd_usb_dev(usb),\r\n"couldn't load firmware. Error number %d\n", r);\r\nreturn r;\r\n}\r\nr = usb_reset_configuration(zd_usb_to_usbdev(usb));\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"couldn't reset configuration. Error number %d\n", r);\r\nreturn r;\r\n}\r\nr = zd_mac_init_hw(mac->hw);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"couldn't initialize mac. Error number %d\n", r);\r\nreturn r;\r\n}\r\nusb->initialized = 1;\r\nreturn 0;\r\n}\r\nstatic int probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint r;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct zd_usb *usb;\r\nstruct ieee80211_hw *hw = NULL;\r\nprint_id(udev);\r\nif (id->driver_info & DEVICE_INSTALLER)\r\nreturn eject_installer(intf);\r\nswitch (udev->speed) {\r\ncase USB_SPEED_LOW:\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_HIGH:\r\nbreak;\r\ndefault:\r\ndev_dbg_f(&intf->dev, "Unknown USB speed\n");\r\nr = -ENODEV;\r\ngoto error;\r\n}\r\nr = usb_reset_device(udev);\r\nif (r) {\r\ndev_err(&intf->dev,\r\n"couldn't reset usb device. Error number %d\n", r);\r\ngoto error;\r\n}\r\nhw = zd_mac_alloc_hw(intf);\r\nif (hw == NULL) {\r\nr = -ENOMEM;\r\ngoto error;\r\n}\r\nusb = &zd_hw_mac(hw)->chip.usb;\r\nusb->is_zd1211b = (id->driver_info == DEVICE_ZD1211B) != 0;\r\nr = zd_mac_preinit_hw(hw);\r\nif (r) {\r\ndev_dbg_f(&intf->dev,\r\n"couldn't initialize mac. Error number %d\n", r);\r\ngoto error;\r\n}\r\nr = ieee80211_register_hw(hw);\r\nif (r) {\r\ndev_dbg_f(&intf->dev,\r\n"couldn't register device. Error number %d\n", r);\r\ngoto error;\r\n}\r\ndev_dbg_f(&intf->dev, "successful\n");\r\ndev_info(&intf->dev, "%s\n", wiphy_name(hw->wiphy));\r\nreturn 0;\r\nerror:\r\nusb_reset_device(interface_to_usbdev(intf));\r\nif (hw) {\r\nzd_mac_clear(zd_hw_mac(hw));\r\nieee80211_free_hw(hw);\r\n}\r\nreturn r;\r\n}\r\nstatic void disconnect(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *hw = zd_intf_to_hw(intf);\r\nstruct zd_mac *mac;\r\nstruct zd_usb *usb;\r\nif (hw == NULL)\r\nreturn;\r\nmac = zd_hw_mac(hw);\r\nusb = &mac->chip.usb;\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nieee80211_unregister_hw(hw);\r\nzd_usb_disable_tx(usb);\r\nzd_usb_disable_rx(usb);\r\nzd_usb_disable_int(usb);\r\nusb_reset_device(interface_to_usbdev(intf));\r\nzd_mac_clear(mac);\r\nieee80211_free_hw(hw);\r\ndev_dbg(&intf->dev, "disconnected\n");\r\n}\r\nstatic void zd_usb_resume(struct zd_usb *usb)\r\n{\r\nstruct zd_mac *mac = zd_usb_to_mac(usb);\r\nint r;\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nr = zd_op_start(zd_usb_to_hw(usb));\r\nif (r < 0) {\r\ndev_warn(zd_usb_dev(usb), "Device resume failed "\r\n"with error code %d. Retrying...\n", r);\r\nif (usb->was_running)\r\nset_bit(ZD_DEVICE_RUNNING, &mac->flags);\r\nusb_queue_reset_device(usb->intf);\r\nreturn;\r\n}\r\nif (mac->type != NL80211_IFTYPE_UNSPECIFIED) {\r\nr = zd_restore_settings(mac);\r\nif (r < 0) {\r\ndev_dbg(zd_usb_dev(usb),\r\n"failed to restore settings, %d\n", r);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void zd_usb_stop(struct zd_usb *usb)\r\n{\r\ndev_dbg_f(zd_usb_dev(usb), "\n");\r\nzd_op_stop(zd_usb_to_hw(usb));\r\nzd_usb_disable_tx(usb);\r\nzd_usb_disable_rx(usb);\r\nzd_usb_disable_int(usb);\r\nusb->initialized = 0;\r\n}\r\nstatic int pre_reset(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(intf);\r\nstruct zd_mac *mac;\r\nstruct zd_usb *usb;\r\nif (!hw || intf->condition != USB_INTERFACE_BOUND)\r\nreturn 0;\r\nmac = zd_hw_mac(hw);\r\nusb = &mac->chip.usb;\r\nusb->was_running = test_bit(ZD_DEVICE_RUNNING, &mac->flags);\r\nzd_usb_stop(usb);\r\nmutex_lock(&mac->chip.mutex);\r\nreturn 0;\r\n}\r\nstatic int post_reset(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(intf);\r\nstruct zd_mac *mac;\r\nstruct zd_usb *usb;\r\nif (!hw || intf->condition != USB_INTERFACE_BOUND)\r\nreturn 0;\r\nmac = zd_hw_mac(hw);\r\nusb = &mac->chip.usb;\r\nmutex_unlock(&mac->chip.mutex);\r\nif (usb->was_running)\r\nzd_usb_resume(usb);\r\nreturn 0;\r\n}\r\nstatic int __init usb_init(void)\r\n{\r\nint r;\r\npr_debug("%s usb_init()\n", driver.name);\r\nzd_workqueue = create_singlethread_workqueue(driver.name);\r\nif (zd_workqueue == NULL) {\r\nprintk(KERN_ERR "%s couldn't create workqueue\n", driver.name);\r\nreturn -ENOMEM;\r\n}\r\nr = usb_register(&driver);\r\nif (r) {\r\ndestroy_workqueue(zd_workqueue);\r\nprintk(KERN_ERR "%s usb_register() failed. Error number %d\n",\r\ndriver.name, r);\r\nreturn r;\r\n}\r\npr_debug("%s initialized\n", driver.name);\r\nreturn 0;\r\n}\r\nstatic void __exit usb_exit(void)\r\n{\r\npr_debug("%s usb_exit()\n", driver.name);\r\nusb_deregister(&driver);\r\ndestroy_workqueue(zd_workqueue);\r\n}\r\nstatic int zd_ep_regs_out_msg(struct usb_device *udev, void *data, int len,\r\nint *actual_length, int timeout)\r\n{\r\nstruct usb_host_endpoint *ep;\r\nunsigned int pipe;\r\npipe = usb_sndintpipe(udev, EP_REGS_OUT);\r\nep = usb_pipe_endpoint(udev, pipe);\r\nif (!ep)\r\nreturn -EINVAL;\r\nif (usb_endpoint_xfer_int(&ep->desc)) {\r\nreturn usb_interrupt_msg(udev, pipe, data, len,\r\nactual_length, timeout);\r\n} else {\r\npipe = usb_sndbulkpipe(udev, EP_REGS_OUT);\r\nreturn usb_bulk_msg(udev, pipe, data, len, actual_length,\r\ntimeout);\r\n}\r\n}\r\nstatic int usb_int_regs_length(unsigned int count)\r\n{\r\nreturn sizeof(struct usb_int_regs) + count * sizeof(struct reg_data);\r\n}\r\nstatic void prepare_read_regs_int(struct zd_usb *usb,\r\nstruct usb_req_read_regs *req,\r\nunsigned int count)\r\n{\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nspin_lock_irq(&intr->lock);\r\natomic_set(&intr->read_regs_enabled, 1);\r\nintr->read_regs.req = req;\r\nintr->read_regs.req_count = count;\r\nreinit_completion(&intr->read_regs.completion);\r\nspin_unlock_irq(&intr->lock);\r\n}\r\nstatic void disable_read_regs_int(struct zd_usb *usb)\r\n{\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nspin_lock_irq(&intr->lock);\r\natomic_set(&intr->read_regs_enabled, 0);\r\nspin_unlock_irq(&intr->lock);\r\n}\r\nstatic bool check_read_regs(struct zd_usb *usb, struct usb_req_read_regs *req,\r\nunsigned int count)\r\n{\r\nint i;\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nstruct read_regs_int *rr = &intr->read_regs;\r\nstruct usb_int_regs *regs = (struct usb_int_regs *)rr->buffer;\r\nif (rr->length < usb_int_regs_length(count)) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: actual length %d less than expected %d\n",\r\nrr->length, usb_int_regs_length(count));\r\nreturn false;\r\n}\r\nif (rr->length > sizeof(rr->buffer)) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: actual length %d exceeds buffer size %zu\n",\r\nrr->length, sizeof(rr->buffer));\r\nreturn false;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nstruct reg_data *rd = &regs->regs[i];\r\nif (rd->addr != req->addr[i]) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"rd[%d] addr %#06hx expected %#06hx\n", i,\r\nle16_to_cpu(rd->addr),\r\nle16_to_cpu(req->addr[i]));\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int get_results(struct zd_usb *usb, u16 *values,\r\nstruct usb_req_read_regs *req, unsigned int count,\r\nbool *retry)\r\n{\r\nint r;\r\nint i;\r\nstruct zd_usb_interrupt *intr = &usb->intr;\r\nstruct read_regs_int *rr = &intr->read_regs;\r\nstruct usb_int_regs *regs = (struct usb_int_regs *)rr->buffer;\r\nspin_lock_irq(&intr->lock);\r\nr = -EIO;\r\n*retry = !!intr->read_regs_int_overridden;\r\nif (*retry)\r\ngoto error_unlock;\r\nif (!check_read_regs(usb, req, count)) {\r\ndev_dbg_f(zd_usb_dev(usb), "error: invalid read regs\n");\r\ngoto error_unlock;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nstruct reg_data *rd = &regs->regs[i];\r\nvalues[i] = le16_to_cpu(rd->value);\r\n}\r\nr = 0;\r\nerror_unlock:\r\nspin_unlock_irq(&intr->lock);\r\nreturn r;\r\n}\r\nint zd_usb_ioread16v(struct zd_usb *usb, u16 *values,\r\nconst zd_addr_t *addresses, unsigned int count)\r\n{\r\nint r, i, req_len, actual_req_len, try_count = 0;\r\nstruct usb_device *udev;\r\nstruct usb_req_read_regs *req = NULL;\r\nunsigned long timeout;\r\nbool retry = false;\r\nif (count < 1) {\r\ndev_dbg_f(zd_usb_dev(usb), "error: count is zero\n");\r\nreturn -EINVAL;\r\n}\r\nif (count > USB_MAX_IOREAD16_COUNT) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: count %u exceeds possible max %u\n",\r\ncount, USB_MAX_IOREAD16_COUNT);\r\nreturn -EINVAL;\r\n}\r\nif (in_atomic()) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: io in atomic context not supported\n");\r\nreturn -EWOULDBLOCK;\r\n}\r\nif (!usb_int_enabled(usb)) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: usb interrupt not enabled\n");\r\nreturn -EWOULDBLOCK;\r\n}\r\nZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\r\nBUILD_BUG_ON(sizeof(struct usb_req_read_regs) + USB_MAX_IOREAD16_COUNT *\r\nsizeof(__le16) > sizeof(usb->req_buf));\r\nBUG_ON(sizeof(struct usb_req_read_regs) + count * sizeof(__le16) >\r\nsizeof(usb->req_buf));\r\nreq_len = sizeof(struct usb_req_read_regs) + count * sizeof(__le16);\r\nreq = (void *)usb->req_buf;\r\nreq->id = cpu_to_le16(USB_REQ_READ_REGS);\r\nfor (i = 0; i < count; i++)\r\nreq->addr[i] = cpu_to_le16((u16)addresses[i]);\r\nretry_read:\r\ntry_count++;\r\nudev = zd_usb_to_usbdev(usb);\r\nprepare_read_regs_int(usb, req, count);\r\nr = zd_ep_regs_out_msg(udev, req, req_len, &actual_req_len, 50 );\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error in zd_ep_regs_out_msg(). Error number %d\n", r);\r\ngoto error;\r\n}\r\nif (req_len != actual_req_len) {\r\ndev_dbg_f(zd_usb_dev(usb), "error in zd_ep_regs_out_msg()\n"\r\n" req_len %d != actual_req_len %d\n",\r\nreq_len, actual_req_len);\r\nr = -EIO;\r\ngoto error;\r\n}\r\ntimeout = wait_for_completion_timeout(&usb->intr.read_regs.completion,\r\nmsecs_to_jiffies(50));\r\nif (!timeout) {\r\ndisable_read_regs_int(usb);\r\ndev_dbg_f(zd_usb_dev(usb), "read timed out\n");\r\nr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nr = get_results(usb, values, req, count, &retry);\r\nif (retry && try_count < 20) {\r\ndev_dbg_f(zd_usb_dev(usb), "read retry, tries so far: %d\n",\r\ntry_count);\r\ngoto retry_read;\r\n}\r\nerror:\r\nreturn r;\r\n}\r\nstatic void iowrite16v_urb_complete(struct urb *urb)\r\n{\r\nstruct zd_usb *usb = urb->context;\r\nif (urb->status && !usb->cmd_error)\r\nusb->cmd_error = urb->status;\r\nif (!usb->cmd_error &&\r\nurb->actual_length != urb->transfer_buffer_length)\r\nusb->cmd_error = -EIO;\r\n}\r\nstatic int zd_submit_waiting_urb(struct zd_usb *usb, bool last)\r\n{\r\nint r = 0;\r\nstruct urb *urb = usb->urb_async_waiting;\r\nif (!urb)\r\nreturn 0;\r\nusb->urb_async_waiting = NULL;\r\nif (!last)\r\nurb->transfer_flags |= URB_NO_INTERRUPT;\r\nusb_anchor_urb(urb, &usb->submitted_cmds);\r\nr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (r) {\r\nusb_unanchor_urb(urb);\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error in usb_submit_urb(). Error number %d\n", r);\r\ngoto error;\r\n}\r\nerror:\r\nusb_free_urb(urb);\r\nreturn r;\r\n}\r\nvoid zd_usb_iowrite16v_async_start(struct zd_usb *usb)\r\n{\r\nZD_ASSERT(usb_anchor_empty(&usb->submitted_cmds));\r\nZD_ASSERT(usb->urb_async_waiting == NULL);\r\nZD_ASSERT(!usb->in_async);\r\nZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\r\nusb->in_async = 1;\r\nusb->cmd_error = 0;\r\nusb->urb_async_waiting = NULL;\r\n}\r\nint zd_usb_iowrite16v_async_end(struct zd_usb *usb, unsigned int timeout)\r\n{\r\nint r;\r\nZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\r\nZD_ASSERT(usb->in_async);\r\nr = zd_submit_waiting_urb(usb, true);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error in zd_submit_waiting_usb(). "\r\n"Error number %d\n", r);\r\nusb_kill_anchored_urbs(&usb->submitted_cmds);\r\ngoto error;\r\n}\r\nif (timeout)\r\ntimeout = usb_wait_anchor_empty_timeout(&usb->submitted_cmds,\r\ntimeout);\r\nif (!timeout) {\r\nusb_kill_anchored_urbs(&usb->submitted_cmds);\r\nif (usb->cmd_error == -ENOENT) {\r\ndev_dbg_f(zd_usb_dev(usb), "timed out");\r\nr = -ETIMEDOUT;\r\ngoto error;\r\n}\r\n}\r\nr = usb->cmd_error;\r\nerror:\r\nusb->in_async = 0;\r\nreturn r;\r\n}\r\nint zd_usb_iowrite16v_async(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\r\nunsigned int count)\r\n{\r\nint r;\r\nstruct usb_device *udev;\r\nstruct usb_req_write_regs *req = NULL;\r\nint i, req_len;\r\nstruct urb *urb;\r\nstruct usb_host_endpoint *ep;\r\nZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\r\nZD_ASSERT(usb->in_async);\r\nif (count == 0)\r\nreturn 0;\r\nif (count > USB_MAX_IOWRITE16_COUNT) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: count %u exceeds possible max %u\n",\r\ncount, USB_MAX_IOWRITE16_COUNT);\r\nreturn -EINVAL;\r\n}\r\nif (in_atomic()) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: io in atomic context not supported\n");\r\nreturn -EWOULDBLOCK;\r\n}\r\nudev = zd_usb_to_usbdev(usb);\r\nep = usb_pipe_endpoint(udev, usb_sndintpipe(udev, EP_REGS_OUT));\r\nif (!ep)\r\nreturn -ENOENT;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nreq_len = sizeof(struct usb_req_write_regs) +\r\ncount * sizeof(struct reg_data);\r\nreq = kmalloc(req_len, GFP_KERNEL);\r\nif (!req) {\r\nr = -ENOMEM;\r\ngoto error;\r\n}\r\nreq->id = cpu_to_le16(USB_REQ_WRITE_REGS);\r\nfor (i = 0; i < count; i++) {\r\nstruct reg_data *rw = &req->reg_writes[i];\r\nrw->addr = cpu_to_le16((u16)ioreqs[i].addr);\r\nrw->value = cpu_to_le16(ioreqs[i].value);\r\n}\r\nif (usb_endpoint_xfer_int(&ep->desc))\r\nusb_fill_int_urb(urb, udev, usb_sndintpipe(udev, EP_REGS_OUT),\r\nreq, req_len, iowrite16v_urb_complete, usb,\r\nep->desc.bInterval);\r\nelse\r\nusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, EP_REGS_OUT),\r\nreq, req_len, iowrite16v_urb_complete, usb);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nr = zd_submit_waiting_urb(usb, false);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error in zd_submit_waiting_usb(). "\r\n"Error number %d\n", r);\r\ngoto error;\r\n}\r\nusb->urb_async_waiting = urb;\r\nreturn 0;\r\nerror:\r\nusb_free_urb(urb);\r\nreturn r;\r\n}\r\nint zd_usb_iowrite16v(struct zd_usb *usb, const struct zd_ioreq16 *ioreqs,\r\nunsigned int count)\r\n{\r\nint r;\r\nzd_usb_iowrite16v_async_start(usb);\r\nr = zd_usb_iowrite16v_async(usb, ioreqs, count);\r\nif (r) {\r\nzd_usb_iowrite16v_async_end(usb, 0);\r\nreturn r;\r\n}\r\nreturn zd_usb_iowrite16v_async_end(usb, 50 );\r\n}\r\nint zd_usb_rfwrite(struct zd_usb *usb, u32 value, u8 bits)\r\n{\r\nint r;\r\nstruct usb_device *udev;\r\nstruct usb_req_rfwrite *req = NULL;\r\nint i, req_len, actual_req_len;\r\nu16 bit_value_template;\r\nif (in_atomic()) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: io in atomic context not supported\n");\r\nreturn -EWOULDBLOCK;\r\n}\r\nif (bits < USB_MIN_RFWRITE_BIT_COUNT) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: bits %d are smaller than"\r\n" USB_MIN_RFWRITE_BIT_COUNT %d\n",\r\nbits, USB_MIN_RFWRITE_BIT_COUNT);\r\nreturn -EINVAL;\r\n}\r\nif (bits > USB_MAX_RFWRITE_BIT_COUNT) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: bits %d exceed USB_MAX_RFWRITE_BIT_COUNT %d\n",\r\nbits, USB_MAX_RFWRITE_BIT_COUNT);\r\nreturn -EINVAL;\r\n}\r\n#ifdef DEBUG\r\nif (value & (~0UL << bits)) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error: value %#09x has bits >= %d set\n",\r\nvalue, bits);\r\nreturn -EINVAL;\r\n}\r\n#endif\r\ndev_dbg_f(zd_usb_dev(usb), "value %#09x bits %d\n", value, bits);\r\nr = zd_usb_ioread16(usb, &bit_value_template, ZD_CR203);\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error %d: Couldn't read ZD_CR203\n", r);\r\nreturn r;\r\n}\r\nbit_value_template &= ~(RF_IF_LE|RF_CLK|RF_DATA);\r\nZD_ASSERT(mutex_is_locked(&zd_usb_to_chip(usb)->mutex));\r\nBUILD_BUG_ON(sizeof(struct usb_req_rfwrite) +\r\nUSB_MAX_RFWRITE_BIT_COUNT * sizeof(__le16) >\r\nsizeof(usb->req_buf));\r\nBUG_ON(sizeof(struct usb_req_rfwrite) + bits * sizeof(__le16) >\r\nsizeof(usb->req_buf));\r\nreq_len = sizeof(struct usb_req_rfwrite) + bits * sizeof(__le16);\r\nreq = (void *)usb->req_buf;\r\nreq->id = cpu_to_le16(USB_REQ_WRITE_RF);\r\nreq->value = cpu_to_le16(2);\r\nreq->bits = cpu_to_le16(bits);\r\nfor (i = 0; i < bits; i++) {\r\nu16 bv = bit_value_template;\r\nif (value & (1 << (bits-1-i)))\r\nbv |= RF_DATA;\r\nreq->bit_values[i] = cpu_to_le16(bv);\r\n}\r\nudev = zd_usb_to_usbdev(usb);\r\nr = zd_ep_regs_out_msg(udev, req, req_len, &actual_req_len, 50 );\r\nif (r) {\r\ndev_dbg_f(zd_usb_dev(usb),\r\n"error in zd_ep_regs_out_msg(). Error number %d\n", r);\r\ngoto out;\r\n}\r\nif (req_len != actual_req_len) {\r\ndev_dbg_f(zd_usb_dev(usb), "error in zd_ep_regs_out_msg()"\r\n" req_len %d != actual_req_len %d\n",\r\nreq_len, actual_req_len);\r\nr = -EIO;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}
