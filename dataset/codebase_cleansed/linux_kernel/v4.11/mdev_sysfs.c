static ssize_t mdev_type_attr_show(struct kobject *kobj,\r\nstruct attribute *__attr, char *buf)\r\n{\r\nstruct mdev_type_attribute *attr = to_mdev_type_attr(__attr);\r\nstruct mdev_type *type = to_mdev_type(kobj);\r\nssize_t ret = -EIO;\r\nif (attr->show)\r\nret = attr->show(kobj, type->parent->dev, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t mdev_type_attr_store(struct kobject *kobj,\r\nstruct attribute *__attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mdev_type_attribute *attr = to_mdev_type_attr(__attr);\r\nstruct mdev_type *type = to_mdev_type(kobj);\r\nssize_t ret = -EIO;\r\nif (attr->store)\r\nret = attr->store(&type->kobj, type->parent->dev, buf, count);\r\nreturn ret;\r\n}\r\nstatic ssize_t create_store(struct kobject *kobj, struct device *dev,\r\nconst char *buf, size_t count)\r\n{\r\nchar *str;\r\nuuid_le uuid;\r\nint ret;\r\nif ((count < UUID_STRING_LEN) || (count > UUID_STRING_LEN + 1))\r\nreturn -EINVAL;\r\nstr = kstrndup(buf, count, GFP_KERNEL);\r\nif (!str)\r\nreturn -ENOMEM;\r\nret = uuid_le_to_bin(str, &uuid);\r\nkfree(str);\r\nif (ret)\r\nreturn ret;\r\nret = mdev_device_create(kobj, dev, uuid);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic void mdev_type_release(struct kobject *kobj)\r\n{\r\nstruct mdev_type *type = to_mdev_type(kobj);\r\npr_debug("Releasing group %s\n", kobj->name);\r\nkfree(type);\r\n}\r\nstruct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,\r\nstruct attribute_group *group)\r\n{\r\nstruct mdev_type *type;\r\nint ret;\r\nif (!group->name) {\r\npr_err("%s: Type name empty!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntype = kzalloc(sizeof(*type), GFP_KERNEL);\r\nif (!type)\r\nreturn ERR_PTR(-ENOMEM);\r\ntype->kobj.kset = parent->mdev_types_kset;\r\nret = kobject_init_and_add(&type->kobj, &mdev_type_ktype, NULL,\r\n"%s-%s", dev_driver_string(parent->dev),\r\ngroup->name);\r\nif (ret) {\r\nkfree(type);\r\nreturn ERR_PTR(ret);\r\n}\r\nret = sysfs_create_file(&type->kobj, &mdev_type_attr_create.attr);\r\nif (ret)\r\ngoto attr_create_failed;\r\ntype->devices_kobj = kobject_create_and_add("devices", &type->kobj);\r\nif (!type->devices_kobj) {\r\nret = -ENOMEM;\r\ngoto attr_devices_failed;\r\n}\r\nret = sysfs_create_files(&type->kobj,\r\n(const struct attribute **)group->attrs);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto attrs_failed;\r\n}\r\ntype->group = group;\r\ntype->parent = parent;\r\nreturn type;\r\nattrs_failed:\r\nkobject_put(type->devices_kobj);\r\nattr_devices_failed:\r\nsysfs_remove_file(&type->kobj, &mdev_type_attr_create.attr);\r\nattr_create_failed:\r\nkobject_del(&type->kobj);\r\nkobject_put(&type->kobj);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void remove_mdev_supported_type(struct mdev_type *type)\r\n{\r\nsysfs_remove_files(&type->kobj,\r\n(const struct attribute **)type->group->attrs);\r\nkobject_put(type->devices_kobj);\r\nsysfs_remove_file(&type->kobj, &mdev_type_attr_create.attr);\r\nkobject_del(&type->kobj);\r\nkobject_put(&type->kobj);\r\n}\r\nstatic int add_mdev_supported_type_groups(struct mdev_parent *parent)\r\n{\r\nint i;\r\nfor (i = 0; parent->ops->supported_type_groups[i]; i++) {\r\nstruct mdev_type *type;\r\ntype = add_mdev_supported_type(parent,\r\nparent->ops->supported_type_groups[i]);\r\nif (IS_ERR(type)) {\r\nstruct mdev_type *ltype, *tmp;\r\nlist_for_each_entry_safe(ltype, tmp, &parent->type_list,\r\nnext) {\r\nlist_del(&ltype->next);\r\nremove_mdev_supported_type(ltype);\r\n}\r\nreturn PTR_ERR(type);\r\n}\r\nlist_add(&type->next, &parent->type_list);\r\n}\r\nreturn 0;\r\n}\r\nvoid parent_remove_sysfs_files(struct mdev_parent *parent)\r\n{\r\nstruct mdev_type *type, *tmp;\r\nlist_for_each_entry_safe(type, tmp, &parent->type_list, next) {\r\nlist_del(&type->next);\r\nremove_mdev_supported_type(type);\r\n}\r\nsysfs_remove_groups(&parent->dev->kobj, parent->ops->dev_attr_groups);\r\nkset_unregister(parent->mdev_types_kset);\r\n}\r\nint parent_create_sysfs_files(struct mdev_parent *parent)\r\n{\r\nint ret;\r\nparent->mdev_types_kset = kset_create_and_add("mdev_supported_types",\r\nNULL, &parent->dev->kobj);\r\nif (!parent->mdev_types_kset)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&parent->type_list);\r\nret = sysfs_create_groups(&parent->dev->kobj,\r\nparent->ops->dev_attr_groups);\r\nif (ret)\r\ngoto create_err;\r\nret = add_mdev_supported_type_groups(parent);\r\nif (ret)\r\nsysfs_remove_groups(&parent->dev->kobj,\r\nparent->ops->dev_attr_groups);\r\nelse\r\nreturn ret;\r\ncreate_err:\r\nkset_unregister(parent->mdev_types_kset);\r\nreturn ret;\r\n}\r\nstatic ssize_t remove_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val) < 0)\r\nreturn -EINVAL;\r\nif (val && device_remove_file_self(dev, attr)) {\r\nint ret;\r\nret = mdev_device_remove(dev, false);\r\nif (ret) {\r\ndevice_create_file(dev, attr);\r\nreturn ret;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint mdev_create_sysfs_files(struct device *dev, struct mdev_type *type)\r\n{\r\nint ret;\r\nret = sysfs_create_files(&dev->kobj, mdev_device_attrs);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_link(type->devices_kobj, &dev->kobj, dev_name(dev));\r\nif (ret)\r\ngoto device_link_failed;\r\nret = sysfs_create_link(&dev->kobj, &type->kobj, "mdev_type");\r\nif (ret)\r\ngoto type_link_failed;\r\nreturn ret;\r\ntype_link_failed:\r\nsysfs_remove_link(type->devices_kobj, dev_name(dev));\r\ndevice_link_failed:\r\nsysfs_remove_files(&dev->kobj, mdev_device_attrs);\r\nreturn ret;\r\n}\r\nvoid mdev_remove_sysfs_files(struct device *dev, struct mdev_type *type)\r\n{\r\nsysfs_remove_link(&dev->kobj, "mdev_type");\r\nsysfs_remove_link(type->devices_kobj, dev_name(dev));\r\nsysfs_remove_files(&dev->kobj, mdev_device_attrs);\r\n}
