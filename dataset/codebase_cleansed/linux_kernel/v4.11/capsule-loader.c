static void efi_free_all_buff_pages(struct capsule_info *cap_info)\r\n{\r\nwhile (cap_info->index > 0)\r\n__free_page(cap_info->pages[--cap_info->index]);\r\ncap_info->index = NO_FURTHER_WRITE_ACTION;\r\n}\r\nstatic ssize_t efi_capsule_setup_info(struct capsule_info *cap_info,\r\nvoid *kbuff, size_t hdr_bytes)\r\n{\r\nefi_capsule_header_t *cap_hdr;\r\nsize_t pages_needed;\r\nint ret;\r\nvoid *temp_page;\r\nif (hdr_bytes < sizeof(efi_capsule_header_t))\r\nreturn 0;\r\ncap_hdr = kbuff - cap_info->count;\r\npages_needed = ALIGN(cap_hdr->imagesize, PAGE_SIZE) >> PAGE_SHIFT;\r\nif (pages_needed == 0) {\r\npr_err("%s: pages count invalid\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = efi_capsule_supported(cap_hdr->guid, cap_hdr->flags,\r\ncap_hdr->imagesize,\r\n&cap_info->reset_type);\r\nif (ret) {\r\npr_err("%s: efi_capsule_supported() failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\ncap_info->total_size = cap_hdr->imagesize;\r\ntemp_page = krealloc(cap_info->pages,\r\npages_needed * sizeof(void *),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!temp_page) {\r\npr_debug("%s: krealloc() failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ncap_info->pages = temp_page;\r\ncap_info->header_obtained = true;\r\nreturn 0;\r\n}\r\nstatic ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)\r\n{\r\nint ret;\r\nvoid *cap_hdr_temp;\r\ncap_hdr_temp = vmap(cap_info->pages, cap_info->index,\r\nVM_MAP, PAGE_KERNEL);\r\nif (!cap_hdr_temp) {\r\npr_debug("%s: vmap() failed\n", __func__);\r\nreturn -EFAULT;\r\n}\r\nret = efi_capsule_update(cap_hdr_temp, cap_info->pages);\r\nvunmap(cap_hdr_temp);\r\nif (ret) {\r\npr_err("%s: efi_capsule_update() failed\n", __func__);\r\nreturn ret;\r\n}\r\ncap_info->index = NO_FURTHER_WRITE_ACTION;\r\npr_info("%s: Successfully upload capsule file with reboot type '%s'\n",\r\n__func__, !cap_info->reset_type ? "RESET_COLD" :\r\ncap_info->reset_type == 1 ? "RESET_WARM" :\r\n"RESET_SHUTDOWN");\r\nreturn 0;\r\n}\r\nstatic ssize_t efi_capsule_write(struct file *file, const char __user *buff,\r\nsize_t count, loff_t *offp)\r\n{\r\nint ret = 0;\r\nstruct capsule_info *cap_info = file->private_data;\r\nstruct page *page;\r\nvoid *kbuff = NULL;\r\nsize_t write_byte;\r\nif (count == 0)\r\nreturn 0;\r\nif (cap_info->index < 0)\r\nreturn -EIO;\r\nif (!cap_info->page_bytes_remain) {\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page) {\r\npr_debug("%s: alloc_page() failed\n", __func__);\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\ncap_info->pages[cap_info->index++] = page;\r\ncap_info->page_bytes_remain = PAGE_SIZE;\r\n}\r\npage = cap_info->pages[cap_info->index - 1];\r\nkbuff = kmap(page);\r\nif (!kbuff) {\r\npr_debug("%s: kmap() failed\n", __func__);\r\nret = -EFAULT;\r\ngoto failed;\r\n}\r\nkbuff += PAGE_SIZE - cap_info->page_bytes_remain;\r\nwrite_byte = min_t(size_t, count, cap_info->page_bytes_remain);\r\nif (copy_from_user(kbuff, buff, write_byte)) {\r\npr_debug("%s: copy_from_user() failed\n", __func__);\r\nret = -EFAULT;\r\ngoto fail_unmap;\r\n}\r\ncap_info->page_bytes_remain -= write_byte;\r\nif (!cap_info->header_obtained) {\r\nret = efi_capsule_setup_info(cap_info, kbuff,\r\ncap_info->count + write_byte);\r\nif (ret)\r\ngoto fail_unmap;\r\n}\r\ncap_info->count += write_byte;\r\nkunmap(page);\r\nif (cap_info->header_obtained &&\r\ncap_info->count >= cap_info->total_size) {\r\nif (cap_info->count > cap_info->total_size) {\r\npr_err("%s: upload size exceeded header defined size\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nret = efi_capsule_submit_update(cap_info);\r\nif (ret)\r\ngoto failed;\r\n}\r\nreturn write_byte;\r\nfail_unmap:\r\nkunmap(page);\r\nfailed:\r\nefi_free_all_buff_pages(cap_info);\r\nreturn ret;\r\n}\r\nstatic int efi_capsule_flush(struct file *file, fl_owner_t id)\r\n{\r\nint ret = 0;\r\nstruct capsule_info *cap_info = file->private_data;\r\nif (cap_info->index > 0) {\r\npr_err("%s: capsule upload not complete\n", __func__);\r\nefi_free_all_buff_pages(cap_info);\r\nret = -ECANCELED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int efi_capsule_release(struct inode *inode, struct file *file)\r\n{\r\nstruct capsule_info *cap_info = file->private_data;\r\nkfree(cap_info->pages);\r\nkfree(file->private_data);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int efi_capsule_open(struct inode *inode, struct file *file)\r\n{\r\nstruct capsule_info *cap_info;\r\ncap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);\r\nif (!cap_info)\r\nreturn -ENOMEM;\r\ncap_info->pages = kzalloc(sizeof(void *), GFP_KERNEL);\r\nif (!cap_info->pages) {\r\nkfree(cap_info);\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = cap_info;\r\nreturn 0;\r\n}\r\nstatic int __init efi_capsule_loader_init(void)\r\n{\r\nint ret;\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn -ENODEV;\r\nret = misc_register(&efi_capsule_misc);\r\nif (ret)\r\npr_err("%s: Failed to register misc char file note\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstatic void __exit efi_capsule_loader_exit(void)\r\n{\r\nmisc_deregister(&efi_capsule_misc);\r\n}
