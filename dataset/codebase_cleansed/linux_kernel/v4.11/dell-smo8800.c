static irqreturn_t smo8800_interrupt_quick(int irq, void *data)\r\n{\r\nstruct smo8800_device *smo8800 = data;\r\natomic_inc(&smo8800->counter);\r\nwake_up_interruptible(&smo8800->misc_wait);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t smo8800_interrupt_thread(int irq, void *data)\r\n{\r\nstruct smo8800_device *smo8800 = data;\r\ndev_info(smo8800->dev, "detected free fall\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic acpi_status smo8800_get_resource(struct acpi_resource *resource,\r\nvoid *context)\r\n{\r\nstruct acpi_resource_extended_irq *irq;\r\nif (resource->type != ACPI_RESOURCE_TYPE_EXTENDED_IRQ)\r\nreturn AE_OK;\r\nirq = &resource->data.extended_irq;\r\nif (!irq || !irq->interrupt_count)\r\nreturn AE_OK;\r\n*((u32 *)context) = irq->interrupts[0];\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic u32 smo8800_get_irq(struct acpi_device *device)\r\n{\r\nu32 irq = 0;\r\nacpi_status status;\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nsmo8800_get_resource, &irq);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(&device->dev, "acpi_walk_resources failed\n");\r\nreturn 0;\r\n}\r\nreturn irq;\r\n}\r\nstatic ssize_t smo8800_misc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct smo8800_device *smo8800 = container_of(file->private_data,\r\nstruct smo8800_device, miscdev);\r\nu32 data = 0;\r\nunsigned char byte_data = 0;\r\nssize_t retval = 1;\r\nif (count < 1)\r\nreturn -EINVAL;\r\natomic_set(&smo8800->counter, 0);\r\nretval = wait_event_interruptible(smo8800->misc_wait,\r\n(data = atomic_xchg(&smo8800->counter, 0)));\r\nif (retval)\r\nreturn retval;\r\nbyte_data = 1;\r\nretval = 1;\r\nif (data < 255)\r\nbyte_data = data;\r\nelse\r\nbyte_data = 255;\r\nif (put_user(byte_data, buf))\r\nretval = -EFAULT;\r\nreturn retval;\r\n}\r\nstatic int smo8800_misc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct smo8800_device *smo8800 = container_of(file->private_data,\r\nstruct smo8800_device, miscdev);\r\nif (test_and_set_bit(0, &smo8800->misc_opened))\r\nreturn -EBUSY;\r\natomic_set(&smo8800->counter, 0);\r\nreturn 0;\r\n}\r\nstatic int smo8800_misc_release(struct inode *inode, struct file *file)\r\n{\r\nstruct smo8800_device *smo8800 = container_of(file->private_data,\r\nstruct smo8800_device, miscdev);\r\nclear_bit(0, &smo8800->misc_opened);\r\nreturn 0;\r\n}\r\nstatic int smo8800_add(struct acpi_device *device)\r\n{\r\nint err;\r\nstruct smo8800_device *smo8800;\r\nsmo8800 = devm_kzalloc(&device->dev, sizeof(*smo8800), GFP_KERNEL);\r\nif (!smo8800) {\r\ndev_err(&device->dev, "failed to allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nsmo8800->dev = &device->dev;\r\nsmo8800->miscdev.minor = MISC_DYNAMIC_MINOR;\r\nsmo8800->miscdev.name = "freefall";\r\nsmo8800->miscdev.fops = &smo8800_misc_fops;\r\ninit_waitqueue_head(&smo8800->misc_wait);\r\nerr = misc_register(&smo8800->miscdev);\r\nif (err) {\r\ndev_err(&device->dev, "failed to register misc dev: %d\n", err);\r\nreturn err;\r\n}\r\ndevice->driver_data = smo8800;\r\nsmo8800->irq = smo8800_get_irq(device);\r\nif (!smo8800->irq) {\r\ndev_err(&device->dev, "failed to obtain IRQ\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nerr = request_threaded_irq(smo8800->irq, smo8800_interrupt_quick,\r\nsmo8800_interrupt_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\nDRIVER_NAME, smo8800);\r\nif (err) {\r\ndev_err(&device->dev,\r\n"failed to request thread for IRQ %d: %d\n",\r\nsmo8800->irq, err);\r\ngoto error;\r\n}\r\ndev_dbg(&device->dev, "device /dev/freefall registered with IRQ %d\n",\r\nsmo8800->irq);\r\nreturn 0;\r\nerror:\r\nmisc_deregister(&smo8800->miscdev);\r\nreturn err;\r\n}\r\nstatic int smo8800_remove(struct acpi_device *device)\r\n{\r\nstruct smo8800_device *smo8800 = device->driver_data;\r\nfree_irq(smo8800->irq, smo8800);\r\nmisc_deregister(&smo8800->miscdev);\r\ndev_dbg(&device->dev, "device /dev/freefall unregistered\n");\r\nreturn 0;\r\n}
