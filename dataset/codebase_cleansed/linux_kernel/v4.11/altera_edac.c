static irqreturn_t altr_sdram_mc_err_handler(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\r\nconst struct altr_sdram_prv_data *priv = drvdata->data;\r\nu32 status, err_count = 1, err_addr;\r\nregmap_read(drvdata->mc_vbase, priv->ecc_stat_offset, &status);\r\nif (status & priv->ecc_stat_ue_mask) {\r\nregmap_read(drvdata->mc_vbase, priv->ecc_daddr_offset,\r\n&err_addr);\r\nif (priv->ecc_uecnt_offset)\r\nregmap_read(drvdata->mc_vbase, priv->ecc_uecnt_offset,\r\n&err_count);\r\npanic("\nEDAC: [%d Uncorrectable errors @ 0x%08X]\n",\r\nerr_count, err_addr);\r\n}\r\nif (status & priv->ecc_stat_ce_mask) {\r\nregmap_read(drvdata->mc_vbase, priv->ecc_saddr_offset,\r\n&err_addr);\r\nif (priv->ecc_uecnt_offset)\r\nregmap_read(drvdata->mc_vbase, priv->ecc_cecnt_offset,\r\n&err_count);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, err_count,\r\nerr_addr >> PAGE_SHIFT,\r\nerr_addr & ~PAGE_MASK, 0,\r\n0, 0, -1, mci->ctl_name, "");\r\nregmap_write(drvdata->mc_vbase, priv->ecc_irq_clr_offset,\r\npriv->ecc_irq_clr_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic ssize_t altr_sdr_mc_err_inject_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mem_ctl_info *mci = file->private_data;\r\nstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\r\nconst struct altr_sdram_prv_data *priv = drvdata->data;\r\nu32 *ptemp;\r\ndma_addr_t dma_handle;\r\nu32 reg, read_reg;\r\nptemp = dma_alloc_coherent(mci->pdev, 16, &dma_handle, GFP_KERNEL);\r\nif (!ptemp) {\r\ndma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Inject: Buffer Allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\nregmap_read(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n&read_reg);\r\nread_reg &= ~(priv->ce_set_mask | priv->ue_set_mask);\r\nif (count == 3) {\r\nedac_printk(KERN_ALERT, EDAC_MC,\r\n"Inject Double bit error\n");\r\nlocal_irq_disable();\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n(read_reg | priv->ue_set_mask));\r\nlocal_irq_enable();\r\n} else {\r\nedac_printk(KERN_ALERT, EDAC_MC,\r\n"Inject Single bit error\n");\r\nlocal_irq_disable();\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\r\n(read_reg | priv->ce_set_mask));\r\nlocal_irq_enable();\r\n}\r\nptemp[0] = 0x5A5A5A5A;\r\nptemp[1] = 0xA5A5A5A5;\r\nregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset, read_reg);\r\nwmb();\r\nreg = ACCESS_ONCE(ptemp[0]);\r\nread_reg = ACCESS_ONCE(ptemp[1]);\r\nrmb();\r\nedac_printk(KERN_ALERT, EDAC_MC, "Read Data [0x%X, 0x%X]\n",\r\nreg, read_reg);\r\ndma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\r\nreturn count;\r\n}\r\nstatic void altr_sdr_mc_create_debugfs_nodes(struct mem_ctl_info *mci)\r\n{\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\r\nreturn;\r\nif (!mci->debugfs)\r\nreturn;\r\nedac_debugfs_create_file("altr_trigger", S_IWUSR, mci->debugfs, mci,\r\n&altr_sdr_mc_debug_inject_fops);\r\n}\r\nstatic unsigned long get_total_mem(void)\r\n{\r\nstruct device_node *np = NULL;\r\nconst unsigned int *reg, *reg_end;\r\nint len, sw, aw;\r\nunsigned long start, size, total_mem = 0;\r\nfor_each_node_by_type(np, "memory") {\r\naw = of_n_addr_cells(np);\r\nsw = of_n_size_cells(np);\r\nreg = (const unsigned int *)of_get_property(np, "reg", &len);\r\nreg_end = reg + (len / sizeof(u32));\r\ntotal_mem = 0;\r\ndo {\r\nstart = of_read_number(reg, aw);\r\nreg += aw;\r\nsize = of_read_number(reg, sw);\r\nreg += sw;\r\ntotal_mem += size;\r\n} while (reg < reg_end);\r\n}\r\nedac_dbg(0, "total_mem 0x%lx\n", total_mem);\r\nreturn total_mem;\r\n}\r\nstatic int a10_init(struct regmap *mc_vbase)\r\n{\r\nif (regmap_update_bits(mc_vbase, A10_INTMODE_OFST,\r\nA10_INTMODE_SB_INT, A10_INTMODE_SB_INT)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error setting SB IRQ mode\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_write(mc_vbase, A10_SERRCNTREG_OFST, 1)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error setting trigger count\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int a10_unmask_irq(struct platform_device *pdev, u32 mask)\r\n{\r\nvoid __iomem *sm_base;\r\nint ret = 0;\r\nif (!request_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32),\r\ndev_name(&pdev->dev))) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to request mem region\n");\r\nreturn -EBUSY;\r\n}\r\nsm_base = ioremap(A10_SYMAN_INTMASK_CLR, sizeof(u32));\r\nif (!sm_base) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to ioremap device\n");\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\niowrite32(mask, sm_base);\r\niounmap(sm_base);\r\nrelease:\r\nrelease_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32));\r\nreturn ret;\r\n}\r\nstatic int altr_sdram_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct edac_mc_layer layers[2];\r\nstruct mem_ctl_info *mci;\r\nstruct altr_sdram_mc_data *drvdata;\r\nconst struct altr_sdram_prv_data *priv;\r\nstruct regmap *mc_vbase;\r\nstruct dimm_info *dimm;\r\nu32 read_reg;\r\nint irq, irq2, res = 0;\r\nunsigned long mem_size, irqflags = 0;\r\nid = of_match_device(altr_sdram_ctrl_of_match, &pdev->dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nmc_vbase = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"altr,sdr-syscon");\r\nif (IS_ERR(mc_vbase)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"regmap for altr,sdr-syscon lookup failed.\n");\r\nreturn -ENODEV;\r\n}\r\npriv = of_match_node(altr_sdram_ctrl_of_match,\r\npdev->dev.of_node)->data;\r\nif (regmap_read(mc_vbase, priv->ecc_ctrl_offset, &read_reg) ||\r\n((read_reg & priv->ecc_ctl_en_mask) != priv->ecc_ctl_en_mask)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"No ECC/ECC disabled [0x%08X]\n", read_reg);\r\nreturn -ENODEV;\r\n}\r\nmem_size = get_total_mem();\r\nif (!mem_size) {\r\nedac_printk(KERN_ERR, EDAC_MC, "Unable to calculate memory size\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_irq_en_offset,\r\npriv->ecc_irq_en_mask, 0)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error disabling SDRAM ECC IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\r\npriv->ecc_cnt_rst_mask,\r\npriv->ecc_cnt_rst_mask)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error clearing SDRAM ECC count\n");\r\nreturn -ENODEV;\r\n}\r\nif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\r\npriv->ecc_cnt_rst_mask, 0)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Error clearing SDRAM ECC count\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"No irq %d in DT\n", irq);\r\nreturn -ENODEV;\r\n}\r\nirq2 = platform_get_irq(pdev, 1);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(struct altr_sdram_mc_data));\r\nif (!mci)\r\nreturn -ENOMEM;\r\nmci->pdev = &pdev->dev;\r\ndrvdata = mci->pvt_info;\r\ndrvdata->mc_vbase = mc_vbase;\r\ndrvdata->data = priv;\r\nplatform_set_drvdata(pdev, mci);\r\nif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"Unable to get managed device resource\n");\r\nres = -ENOMEM;\r\ngoto free;\r\n}\r\nmci->mtype_cap = MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = EDAC_VERSION;\r\nmci->ctl_name = dev_name(&pdev->dev);\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nmci->dev_name = dev_name(&pdev->dev);\r\ndimm = *mci->dimms;\r\ndimm->nr_pages = ((mem_size - 1) >> PAGE_SHIFT) + 1;\r\ndimm->grain = 8;\r\ndimm->dtype = DEV_X8;\r\ndimm->mtype = MEM_DDR3;\r\ndimm->edac_mode = EDAC_SECDED;\r\nres = edac_mc_add_mc(mci);\r\nif (res < 0)\r\ngoto err;\r\nif (irq2 > 0) {\r\nres = a10_init(mc_vbase);\r\nif (res < 0)\r\ngoto err2;\r\nres = devm_request_irq(&pdev->dev, irq2,\r\naltr_sdram_mc_err_handler,\r\nIRQF_SHARED, dev_name(&pdev->dev), mci);\r\nif (res < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Unable to request irq %d\n", irq2);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nres = a10_unmask_irq(pdev, A10_DDR0_IRQ_MASK);\r\nif (res < 0)\r\ngoto err2;\r\nirqflags = IRQF_SHARED;\r\n}\r\nres = devm_request_irq(&pdev->dev, irq, altr_sdram_mc_err_handler,\r\nirqflags, dev_name(&pdev->dev), mci);\r\nif (res < 0) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Unable to request irq %d\n", irq);\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\nif (regmap_update_bits(drvdata->mc_vbase, priv->ecc_irq_en_offset,\r\npriv->ecc_irq_en_mask, priv->ecc_irq_en_mask)) {\r\nedac_mc_printk(mci, KERN_ERR,\r\n"Error enabling SDRAM ECC IRQ\n");\r\nres = -ENODEV;\r\ngoto err2;\r\n}\r\naltr_sdr_mc_create_debugfs_nodes(mci);\r\ndevres_close_group(&pdev->dev, NULL);\r\nreturn 0;\r\nerr2:\r\nedac_mc_del_mc(&pdev->dev);\r\nerr:\r\ndevres_release_group(&pdev->dev, NULL);\r\nfree:\r\nedac_mc_free(mci);\r\nedac_printk(KERN_ERR, EDAC_MC,\r\n"EDAC Probe Failed; Error %d\n", res);\r\nreturn res;\r\n}\r\nstatic int altr_sdram_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int altr_sdram_prepare(struct device *dev)\r\n{\r\npr_err("Suspend not allowed when EDAC is enabled.\n");\r\nreturn -EPERM;\r\n}\r\nstatic int altr_edac_probe(struct platform_device *pdev)\r\n{\r\nof_platform_populate(pdev->dev.of_node, altr_edac_device_of_match,\r\nNULL, &pdev->dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t altr_edac_device_handler(int irq, void *dev_id)\r\n{\r\nirqreturn_t ret_value = IRQ_NONE;\r\nstruct edac_device_ctl_info *dci = dev_id;\r\nstruct altr_edac_device_dev *drvdata = dci->pvt_info;\r\nconst struct edac_device_prv_data *priv = drvdata->data;\r\nif (irq == drvdata->sb_irq) {\r\nif (priv->ce_clear_mask)\r\nwritel(priv->ce_clear_mask, drvdata->base);\r\nedac_device_handle_ce(dci, 0, 0, drvdata->edac_dev_name);\r\nret_value = IRQ_HANDLED;\r\n} else if (irq == drvdata->db_irq) {\r\nif (priv->ue_clear_mask)\r\nwritel(priv->ue_clear_mask, drvdata->base);\r\nedac_device_handle_ue(dci, 0, 0, drvdata->edac_dev_name);\r\npanic("\nEDAC:ECC_DEVICE[Uncorrectable errors]\n");\r\nret_value = IRQ_HANDLED;\r\n} else {\r\nWARN_ON(1);\r\n}\r\nreturn ret_value;\r\n}\r\nstatic ssize_t altr_edac_device_trig(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu32 *ptemp, i, error_mask;\r\nint result = 0;\r\nu8 trig_type;\r\nunsigned long flags;\r\nstruct edac_device_ctl_info *edac_dci = file->private_data;\r\nstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\r\nconst struct edac_device_prv_data *priv = drvdata->data;\r\nvoid *generic_ptr = edac_dci->dev;\r\nif (!user_buf || get_user(trig_type, user_buf))\r\nreturn -EFAULT;\r\nif (!priv->alloc_mem)\r\nreturn -ENOMEM;\r\nptemp = priv->alloc_mem(priv->trig_alloc_sz, &generic_ptr);\r\nif (!ptemp) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Inject: Buffer Allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\nif (trig_type == ALTR_UE_TRIGGER_CHAR)\r\nerror_mask = priv->ue_set_mask;\r\nelse\r\nerror_mask = priv->ce_set_mask;\r\nedac_printk(KERN_ALERT, EDAC_DEVICE,\r\n"Trigger Error Mask (0x%X)\n", error_mask);\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < (priv->trig_alloc_sz / sizeof(*ptemp)); i++) {\r\nrmb();\r\nif (ACCESS_ONCE(ptemp[i]))\r\nresult = -1;\r\nwritel(error_mask, (drvdata->base + priv->set_err_ofst));\r\nwritel(priv->ecc_enable_mask, (drvdata->base +\r\npriv->set_err_ofst));\r\nptemp[i] = i;\r\n}\r\nwmb();\r\nlocal_irq_restore(flags);\r\nif (result)\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "Mem Not Cleared\n");\r\nfor (i = 0; i < ALTR_TRIGGER_READ_WRD_CNT; i++)\r\nif (ACCESS_ONCE(ptemp[i]) != i)\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Read doesn't match written data\n");\r\nif (priv->free_mem)\r\npriv->free_mem(ptemp, priv->trig_alloc_sz, generic_ptr);\r\nreturn count;\r\n}\r\nstatic void altr_create_edacdev_dbgfs(struct edac_device_ctl_info *edac_dci,\r\nconst struct edac_device_prv_data *priv)\r\n{\r\nstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\r\nreturn;\r\ndrvdata->debugfs_dir = edac_debugfs_create_dir(drvdata->edac_dev_name);\r\nif (!drvdata->debugfs_dir)\r\nreturn;\r\nif (!edac_debugfs_create_file("altr_trigger", S_IWUSR,\r\ndrvdata->debugfs_dir, edac_dci,\r\npriv->inject_fops))\r\ndebugfs_remove_recursive(drvdata->debugfs_dir);\r\n}\r\nstatic int altr_edac_device_probe(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *dci;\r\nstruct altr_edac_device_dev *drvdata;\r\nstruct resource *r;\r\nint res = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nchar *ecc_name = (char *)np->name;\r\nstatic int dev_instance;\r\nif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Unable to open devm\n");\r\nreturn -ENOMEM;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Unable to get mem resource\n");\r\nres = -ENODEV;\r\ngoto fail;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, r->start, resource_size(r),\r\ndev_name(&pdev->dev))) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s:Error requesting mem region\n", ecc_name);\r\nres = -EBUSY;\r\ngoto fail;\r\n}\r\ndci = edac_device_alloc_ctl_info(sizeof(*drvdata), ecc_name,\r\n1, ecc_name, 1, 0, NULL, 0,\r\ndev_instance++);\r\nif (!dci) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s: Unable to allocate EDAC device\n", ecc_name);\r\nres = -ENOMEM;\r\ngoto fail;\r\n}\r\ndrvdata = dci->pvt_info;\r\ndci->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, dci);\r\ndrvdata->edac_dev_name = ecc_name;\r\ndrvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!drvdata->base)\r\ngoto fail1;\r\ndrvdata->data = of_match_node(altr_edac_device_of_match, np)->data;\r\nif (drvdata->data->setup) {\r\nres = drvdata->data->setup(drvdata);\r\nif (res)\r\ngoto fail1;\r\n}\r\ndrvdata->sb_irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev, drvdata->sb_irq,\r\naltr_edac_device_handler,\r\n0, dev_name(&pdev->dev), dci);\r\nif (res)\r\ngoto fail1;\r\ndrvdata->db_irq = platform_get_irq(pdev, 1);\r\nres = devm_request_irq(&pdev->dev, drvdata->db_irq,\r\naltr_edac_device_handler,\r\n0, dev_name(&pdev->dev), dci);\r\nif (res)\r\ngoto fail1;\r\ndci->mod_name = "Altera ECC Manager";\r\ndci->dev_name = drvdata->edac_dev_name;\r\nres = edac_device_add_device(dci);\r\nif (res)\r\ngoto fail1;\r\naltr_create_edacdev_dbgfs(dci, drvdata->data);\r\ndevres_close_group(&pdev->dev, NULL);\r\nreturn 0;\r\nfail1:\r\nedac_device_free_ctl_info(dci);\r\nfail:\r\ndevres_release_group(&pdev->dev, NULL);\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s:Error setting up EDAC device: %d\n", ecc_name, res);\r\nreturn res;\r\n}\r\nstatic int altr_edac_device_remove(struct platform_device *pdev)\r\n{\r\nstruct edac_device_ctl_info *dci = platform_get_drvdata(pdev);\r\nstruct altr_edac_device_dev *drvdata = dci->pvt_info;\r\ndebugfs_remove_recursive(drvdata->debugfs_dir);\r\nedac_device_del_device(&pdev->dev);\r\nedac_device_free_ctl_info(dci);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused\r\naltr_check_ecc_deps(struct altr_edac_device_dev *device)\r\n{\r\nvoid __iomem *base = device->base;\r\nconst struct edac_device_prv_data *prv = device->data;\r\nif (readl(base + prv->ecc_en_ofst) & prv->ecc_enable_mask)\r\nreturn 0;\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s: No ECC present or ECC disabled.\n",\r\ndevice->edac_dev_name);\r\nreturn -ENODEV;\r\n}\r\nstatic irqreturn_t __maybe_unused altr_edac_a10_ecc_irq(int irq, void *dev_id)\r\n{\r\nstruct altr_edac_device_dev *dci = dev_id;\r\nvoid __iomem *base = dci->base;\r\nif (irq == dci->sb_irq) {\r\nwritel(ALTR_A10_ECC_SERRPENA,\r\nbase + ALTR_A10_ECC_INTSTAT_OFST);\r\nedac_device_handle_ce(dci->edac_dev, 0, 0, dci->edac_dev_name);\r\nreturn IRQ_HANDLED;\r\n} else if (irq == dci->db_irq) {\r\nwritel(ALTR_A10_ECC_DERRPENA,\r\nbase + ALTR_A10_ECC_INTSTAT_OFST);\r\nedac_device_handle_ue(dci->edac_dev, 0, 0, dci->edac_dev_name);\r\nif (dci->data->panic)\r\npanic("\nEDAC:ECC_DEVICE[Uncorrectable errors]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nWARN_ON(1);\r\nreturn IRQ_NONE;\r\n}\r\nstatic inline int a10_get_irq_mask(struct device_node *np)\r\n{\r\nint irq;\r\nconst u32 *handle = of_get_property(np, "interrupts", NULL);\r\nif (!handle)\r\nreturn -ENODEV;\r\nirq = be32_to_cpup(handle);\r\nreturn irq;\r\n}\r\nstatic inline void ecc_set_bits(u32 bit_mask, void __iomem *ioaddr)\r\n{\r\nu32 value = readl(ioaddr);\r\nvalue |= bit_mask;\r\nwritel(value, ioaddr);\r\n}\r\nstatic inline void ecc_clear_bits(u32 bit_mask, void __iomem *ioaddr)\r\n{\r\nu32 value = readl(ioaddr);\r\nvalue &= ~bit_mask;\r\nwritel(value, ioaddr);\r\n}\r\nstatic inline int ecc_test_bits(u32 bit_mask, void __iomem *ioaddr)\r\n{\r\nu32 value = readl(ioaddr);\r\nreturn (value & bit_mask) ? 1 : 0;\r\n}\r\nstatic int __maybe_unused altr_init_memory_port(void __iomem *ioaddr, int port)\r\n{\r\nint limit = ALTR_A10_ECC_INIT_WATCHDOG_10US;\r\nu32 init_mask, stat_mask, clear_mask;\r\nint ret = 0;\r\nif (port) {\r\ninit_mask = ALTR_A10_ECC_INITB;\r\nstat_mask = ALTR_A10_ECC_INITCOMPLETEB;\r\nclear_mask = ALTR_A10_ECC_ERRPENB_MASK;\r\n} else {\r\ninit_mask = ALTR_A10_ECC_INITA;\r\nstat_mask = ALTR_A10_ECC_INITCOMPLETEA;\r\nclear_mask = ALTR_A10_ECC_ERRPENA_MASK;\r\n}\r\necc_set_bits(init_mask, (ioaddr + ALTR_A10_ECC_CTRL_OFST));\r\nwhile (limit--) {\r\nif (ecc_test_bits(stat_mask,\r\n(ioaddr + ALTR_A10_ECC_INITSTAT_OFST)))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit < 0)\r\nret = -EBUSY;\r\nwritel(clear_mask, (ioaddr + ALTR_A10_ECC_INTSTAT_OFST));\r\nreturn ret;\r\n}\r\nstatic __init int __maybe_unused\r\naltr_init_a10_ecc_block(struct device_node *np, u32 irq_mask,\r\nu32 ecc_ctrl_en_mask, bool dual_port)\r\n{\r\nint ret = 0;\r\nvoid __iomem *ecc_block_base;\r\nstruct regmap *ecc_mgr_map;\r\nchar *ecc_name;\r\nstruct device_node *np_eccmgr;\r\necc_name = (char *)np->name;\r\nnp_eccmgr = of_get_parent(np);\r\necc_mgr_map = syscon_regmap_lookup_by_phandle(np_eccmgr,\r\n"altr,sysmgr-syscon");\r\nof_node_put(np_eccmgr);\r\nif (IS_ERR(ecc_mgr_map)) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Unable to get syscon altr,sysmgr-syscon\n");\r\nreturn -ENODEV;\r\n}\r\necc_block_base = of_iomap(np, 0);\r\nif (!ecc_block_base) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Unable to map %s ECC block\n", ecc_name);\r\nreturn -ENODEV;\r\n}\r\nregmap_write(ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_SET_OFST, irq_mask);\r\nwritel(ALTR_A10_ECC_SERRINTEN,\r\n(ecc_block_base + ALTR_A10_ECC_ERRINTENR_OFST));\r\necc_clear_bits(ecc_ctrl_en_mask,\r\n(ecc_block_base + ALTR_A10_ECC_CTRL_OFST));\r\nwmb();\r\nret = altr_init_memory_port(ecc_block_base, 0);\r\nif (ret) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"ECC: cannot init %s PORTA memory\n", ecc_name);\r\ngoto out;\r\n}\r\nif (dual_port) {\r\nret = altr_init_memory_port(ecc_block_base, 1);\r\nif (ret) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"ECC: cannot init %s PORTB memory\n",\r\necc_name);\r\ngoto out;\r\n}\r\n}\r\nregmap_write(ecc_mgr_map, ALTR_A10_ECC_INTMODE_OFST,\r\nALTR_A10_ECC_INTMODE);\r\necc_set_bits(ecc_ctrl_en_mask, (ecc_block_base +\r\nALTR_A10_ECC_CTRL_OFST));\r\nwritel(ALTR_A10_ECC_SERRINTEN,\r\n(ecc_block_base + ALTR_A10_ECC_ERRINTENS_OFST));\r\nregmap_write(ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_CLR_OFST, irq_mask);\r\nwmb();\r\nout:\r\niounmap(ecc_block_base);\r\nreturn ret;\r\n}\r\nstatic int __init __maybe_unused altr_init_a10_ecc_device_type(char *compat)\r\n{\r\nint irq;\r\nstruct device_node *child, *np = of_find_compatible_node(NULL, NULL,\r\n"altr,socfpga-a10-ecc-manager");\r\nif (!np) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "ECC Manager not found\n");\r\nreturn -ENODEV;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nconst struct of_device_id *pdev_id;\r\nconst struct edac_device_prv_data *prv;\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nif (!of_device_is_compatible(child, compat))\r\ncontinue;\r\nif (validate_parent_available(child))\r\ncontinue;\r\nirq = a10_get_irq_mask(child);\r\nif (irq < 0)\r\ncontinue;\r\npdev_id = of_match_node(altr_edac_a10_device_of_match, child);\r\nif (IS_ERR_OR_NULL(pdev_id))\r\ncontinue;\r\nprv = pdev_id->data;\r\nif (!prv)\r\ncontinue;\r\naltr_init_a10_ecc_block(child, BIT(irq),\r\nprv->ecc_enable_mask, 0);\r\n}\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void *ocram_alloc_mem(size_t size, void **other)\r\n{\r\nstruct device_node *np;\r\nstruct gen_pool *gp;\r\nvoid *sram_addr;\r\nnp = of_find_compatible_node(NULL, NULL, "altr,socfpga-ocram-ecc");\r\nif (!np)\r\nreturn NULL;\r\ngp = of_gen_pool_get(np, "iram", 0);\r\nof_node_put(np);\r\nif (!gp)\r\nreturn NULL;\r\nsram_addr = (void *)gen_pool_alloc(gp, size);\r\nif (!sram_addr)\r\nreturn NULL;\r\nmemset(sram_addr, 0, size);\r\nwmb();\r\n*other = gp;\r\nreturn sram_addr;\r\n}\r\nstatic void ocram_free_mem(void *p, size_t size, void *other)\r\n{\r\ngen_pool_free((struct gen_pool *)other, (u32)p, size);\r\n}\r\nstatic void *l2_alloc_mem(size_t size, void **other)\r\n{\r\nstruct device *dev = *other;\r\nvoid *ptemp = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!ptemp)\r\nreturn NULL;\r\nwmb();\r\nflush_cache_all();\r\nreturn ptemp;\r\n}\r\nstatic void l2_free_mem(void *p, size_t size, void *other)\r\n{\r\nstruct device *dev = other;\r\nif (dev && p)\r\ndevm_kfree(dev, p);\r\n}\r\nstatic int altr_l2_check_deps(struct altr_edac_device_dev *device)\r\n{\r\nvoid __iomem *base = device->base;\r\nconst struct edac_device_prv_data *prv = device->data;\r\nif ((readl(base) & prv->ecc_enable_mask) ==\r\nprv->ecc_enable_mask)\r\nreturn 0;\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"L2: No ECC present, or ECC disabled\n");\r\nreturn -ENODEV;\r\n}\r\nstatic irqreturn_t altr_edac_a10_l2_irq(int irq, void *dev_id)\r\n{\r\nstruct altr_edac_device_dev *dci = dev_id;\r\nif (irq == dci->sb_irq) {\r\nregmap_write(dci->edac->ecc_mgr_map,\r\nA10_SYSGMR_MPU_CLEAR_L2_ECC_OFST,\r\nA10_SYSGMR_MPU_CLEAR_L2_ECC_SB);\r\nedac_device_handle_ce(dci->edac_dev, 0, 0, dci->edac_dev_name);\r\nreturn IRQ_HANDLED;\r\n} else if (irq == dci->db_irq) {\r\nregmap_write(dci->edac->ecc_mgr_map,\r\nA10_SYSGMR_MPU_CLEAR_L2_ECC_OFST,\r\nA10_SYSGMR_MPU_CLEAR_L2_ECC_MB);\r\nedac_device_handle_ue(dci->edac_dev, 0, 0, dci->edac_dev_name);\r\npanic("\nEDAC:ECC_DEVICE[Uncorrectable errors]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nWARN_ON(1);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int __init socfpga_init_ethernet_ecc(void)\r\n{\r\nreturn altr_init_a10_ecc_device_type("altr,socfpga-eth-mac-ecc");\r\n}\r\nstatic int __init socfpga_init_nand_ecc(void)\r\n{\r\nreturn altr_init_a10_ecc_device_type("altr,socfpga-nand-ecc");\r\n}\r\nstatic int __init socfpga_init_dma_ecc(void)\r\n{\r\nreturn altr_init_a10_ecc_device_type("altr,socfpga-dma-ecc");\r\n}\r\nstatic int __init socfpga_init_usb_ecc(void)\r\n{\r\nreturn altr_init_a10_ecc_device_type("altr,socfpga-usb-ecc");\r\n}\r\nstatic int __init socfpga_init_qspi_ecc(void)\r\n{\r\nreturn altr_init_a10_ecc_device_type("altr,socfpga-qspi-ecc");\r\n}\r\nstatic int altr_portb_setup(struct altr_edac_device_dev *device)\r\n{\r\nstruct edac_device_ctl_info *dci;\r\nstruct altr_edac_device_dev *altdev;\r\nchar *ecc_name = "sdmmcb-ecc";\r\nint edac_idx, rc;\r\nstruct device_node *np;\r\nconst struct edac_device_prv_data *prv = &a10_sdmmceccb_data;\r\nrc = altr_check_ecc_deps(device);\r\nif (rc)\r\nreturn rc;\r\nnp = of_find_compatible_node(NULL, NULL, "altr,socfpga-sdmmc-ecc");\r\nif (!np) {\r\nedac_printk(KERN_WARNING, EDAC_DEVICE, "SDMMC node not found\n");\r\nreturn -ENODEV;\r\n}\r\nedac_idx = edac_device_alloc_index();\r\ndci = edac_device_alloc_ctl_info(sizeof(*altdev), ecc_name, 1,\r\necc_name, 1, 0, NULL, 0, edac_idx);\r\nif (!dci) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s: Unable to allocate PortB EDAC device\n",\r\necc_name);\r\nreturn -ENOMEM;\r\n}\r\naltdev = dci->pvt_info;\r\n*altdev = *device;\r\nif (!devres_open_group(&altdev->ddev, altr_portb_setup, GFP_KERNEL))\r\nreturn -ENOMEM;\r\naltdev->edac_dev_name = ecc_name;\r\naltdev->edac_idx = edac_idx;\r\naltdev->edac_dev = dci;\r\naltdev->data = prv;\r\ndci->dev = &altdev->ddev;\r\ndci->ctl_name = "Altera ECC Manager";\r\ndci->mod_name = ecc_name;\r\ndci->dev_name = ecc_name;\r\naltdev->sb_irq = irq_of_parse_and_map(np, 2);\r\nif (!altdev->sb_irq) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "Error PortB SBIRQ alloc\n");\r\nrc = -ENODEV;\r\ngoto err_release_group_1;\r\n}\r\nrc = devm_request_irq(&altdev->ddev, altdev->sb_irq,\r\nprv->ecc_irq_handler,\r\nIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\r\necc_name, altdev);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "PortB SBERR IRQ error\n");\r\ngoto err_release_group_1;\r\n}\r\naltdev->db_irq = irq_of_parse_and_map(np, 3);\r\nif (!altdev->db_irq) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "Error PortB DBIRQ alloc\n");\r\nrc = -ENODEV;\r\ngoto err_release_group_1;\r\n}\r\nrc = devm_request_irq(&altdev->ddev, altdev->db_irq,\r\nprv->ecc_irq_handler,\r\nIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\r\necc_name, altdev);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "PortB DBERR IRQ error\n");\r\ngoto err_release_group_1;\r\n}\r\nrc = edac_device_add_device(dci);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"edac_device_add_device portB failed\n");\r\nrc = -ENOMEM;\r\ngoto err_release_group_1;\r\n}\r\naltr_create_edacdev_dbgfs(dci, prv);\r\nlist_add(&altdev->next, &altdev->edac->a10_ecc_devices);\r\ndevres_remove_group(&altdev->ddev, altr_portb_setup);\r\nreturn 0;\r\nerr_release_group_1:\r\nedac_device_free_ctl_info(dci);\r\ndevres_release_group(&altdev->ddev, altr_portb_setup);\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s:Error setting up EDAC device: %d\n", ecc_name, rc);\r\nreturn rc;\r\n}\r\nstatic irqreturn_t altr_edac_a10_ecc_irq_portb(int irq, void *dev_id)\r\n{\r\nstruct altr_edac_device_dev *ad = dev_id;\r\nvoid __iomem *base = ad->base;\r\nconst struct edac_device_prv_data *priv = ad->data;\r\nif (irq == ad->sb_irq) {\r\nwritel(priv->ce_clear_mask,\r\nbase + ALTR_A10_ECC_INTSTAT_OFST);\r\nedac_device_handle_ce(ad->edac_dev, 0, 0, ad->edac_dev_name);\r\nreturn IRQ_HANDLED;\r\n} else if (irq == ad->db_irq) {\r\nwritel(priv->ue_clear_mask,\r\nbase + ALTR_A10_ECC_INTSTAT_OFST);\r\nedac_device_handle_ue(ad->edac_dev, 0, 0, ad->edac_dev_name);\r\nreturn IRQ_HANDLED;\r\n}\r\nWARN_ONCE(1, "Unhandled IRQ%d on Port B.", irq);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int __init socfpga_init_sdmmc_ecc(void)\r\n{\r\nint rc = -ENODEV;\r\nstruct device_node *child = of_find_compatible_node(NULL, NULL,\r\n"altr,socfpga-sdmmc-ecc");\r\nif (!child) {\r\nedac_printk(KERN_WARNING, EDAC_DEVICE, "SDMMC node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (!of_device_is_available(child))\r\ngoto exit;\r\nif (validate_parent_available(child))\r\ngoto exit;\r\nrc = altr_init_a10_ecc_block(child, ALTR_A10_SDMMC_IRQ_MASK,\r\na10_sdmmcecca_data.ecc_enable_mask, 1);\r\nexit:\r\nof_node_put(child);\r\nreturn rc;\r\n}\r\nstatic ssize_t altr_edac_a10_device_trig(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct edac_device_ctl_info *edac_dci = file->private_data;\r\nstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\r\nconst struct edac_device_prv_data *priv = drvdata->data;\r\nvoid __iomem *set_addr = (drvdata->base + priv->set_err_ofst);\r\nunsigned long flags;\r\nu8 trig_type;\r\nif (!user_buf || get_user(trig_type, user_buf))\r\nreturn -EFAULT;\r\nlocal_irq_save(flags);\r\nif (trig_type == ALTR_UE_TRIGGER_CHAR)\r\nwritel(priv->ue_set_mask, set_addr);\r\nelse\r\nwritel(priv->ce_set_mask, set_addr);\r\nwmb();\r\nlocal_irq_restore(flags);\r\nreturn count;\r\n}\r\nstatic void altr_edac_a10_irq_handler(struct irq_desc *desc)\r\n{\r\nint dberr, bit, sm_offset, irq_status;\r\nstruct altr_arria10_edac *edac = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint irq = irq_desc_get_irq(desc);\r\ndberr = (irq == edac->db_irq) ? 1 : 0;\r\nsm_offset = dberr ? A10_SYSMGR_ECC_INTSTAT_DERR_OFST :\r\nA10_SYSMGR_ECC_INTSTAT_SERR_OFST;\r\nchained_irq_enter(chip, desc);\r\nregmap_read(edac->ecc_mgr_map, sm_offset, &irq_status);\r\nfor_each_set_bit(bit, (unsigned long *)&irq_status, 32) {\r\nirq = irq_linear_revmap(edac->domain, dberr * 32 + bit);\r\nif (irq)\r\ngeneric_handle_irq(irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int validate_parent_available(struct device_node *np)\r\n{\r\nstruct device_node *parent;\r\nint ret = 0;\r\nparent = of_parse_phandle(np, "altr,ecc-parent", 0);\r\nif (parent && !of_device_is_available(parent))\r\nret = -ENODEV;\r\nof_node_put(parent);\r\nreturn ret;\r\n}\r\nstatic int altr_edac_a10_device_add(struct altr_arria10_edac *edac,\r\nstruct device_node *np)\r\n{\r\nstruct edac_device_ctl_info *dci;\r\nstruct altr_edac_device_dev *altdev;\r\nchar *ecc_name = (char *)np->name;\r\nstruct resource res;\r\nint edac_idx;\r\nint rc = 0;\r\nconst struct edac_device_prv_data *prv;\r\nconst struct of_device_id *pdev_id =\r\nof_match_node(altr_edac_a10_device_of_match, np);\r\nif (IS_ERR_OR_NULL(pdev_id))\r\nreturn -ENODEV;\r\nprv = pdev_id->data;\r\nif (IS_ERR_OR_NULL(prv))\r\nreturn -ENODEV;\r\nif (validate_parent_available(np))\r\nreturn -ENODEV;\r\nif (!devres_open_group(edac->dev, altr_edac_a10_device_add, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc < 0) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s: no resource address\n", ecc_name);\r\ngoto err_release_group;\r\n}\r\nedac_idx = edac_device_alloc_index();\r\ndci = edac_device_alloc_ctl_info(sizeof(*altdev), ecc_name,\r\n1, ecc_name, 1, 0, NULL, 0,\r\nedac_idx);\r\nif (!dci) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s: Unable to allocate EDAC device\n", ecc_name);\r\nrc = -ENOMEM;\r\ngoto err_release_group;\r\n}\r\naltdev = dci->pvt_info;\r\ndci->dev = edac->dev;\r\naltdev->edac_dev_name = ecc_name;\r\naltdev->edac_idx = edac_idx;\r\naltdev->edac = edac;\r\naltdev->edac_dev = dci;\r\naltdev->data = prv;\r\naltdev->ddev = *edac->dev;\r\ndci->dev = &altdev->ddev;\r\ndci->ctl_name = "Altera ECC Manager";\r\ndci->mod_name = ecc_name;\r\ndci->dev_name = ecc_name;\r\naltdev->base = devm_ioremap_resource(edac->dev, &res);\r\nif (IS_ERR(altdev->base)) {\r\nrc = PTR_ERR(altdev->base);\r\ngoto err_release_group1;\r\n}\r\nif (altdev->data->setup) {\r\nrc = altdev->data->setup(altdev);\r\nif (rc)\r\ngoto err_release_group1;\r\n}\r\naltdev->sb_irq = irq_of_parse_and_map(np, 0);\r\nif (!altdev->sb_irq) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "Error allocating SBIRQ\n");\r\nrc = -ENODEV;\r\ngoto err_release_group1;\r\n}\r\nrc = devm_request_irq(edac->dev, altdev->sb_irq, prv->ecc_irq_handler,\r\nIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\r\necc_name, altdev);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "No SBERR IRQ resource\n");\r\ngoto err_release_group1;\r\n}\r\naltdev->db_irq = irq_of_parse_and_map(np, 1);\r\nif (!altdev->db_irq) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "Error allocating DBIRQ\n");\r\nrc = -ENODEV;\r\ngoto err_release_group1;\r\n}\r\nrc = devm_request_irq(edac->dev, altdev->db_irq, prv->ecc_irq_handler,\r\nIRQF_ONESHOT | IRQF_TRIGGER_HIGH,\r\necc_name, altdev);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE, "No DBERR IRQ resource\n");\r\ngoto err_release_group1;\r\n}\r\nrc = edac_device_add_device(dci);\r\nif (rc) {\r\ndev_err(edac->dev, "edac_device_add_device failed\n");\r\nrc = -ENOMEM;\r\ngoto err_release_group1;\r\n}\r\naltr_create_edacdev_dbgfs(dci, prv);\r\nlist_add(&altdev->next, &edac->a10_ecc_devices);\r\ndevres_remove_group(edac->dev, altr_edac_a10_device_add);\r\nreturn 0;\r\nerr_release_group1:\r\nedac_device_free_ctl_info(dci);\r\nerr_release_group:\r\ndevres_release_group(edac->dev, NULL);\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"%s:Error setting up EDAC device: %d\n", ecc_name, rc);\r\nreturn rc;\r\n}\r\nstatic void a10_eccmgr_irq_mask(struct irq_data *d)\r\n{\r\nstruct altr_arria10_edac *edac = irq_data_get_irq_chip_data(d);\r\nregmap_write(edac->ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_SET_OFST,\r\nBIT(d->hwirq));\r\n}\r\nstatic void a10_eccmgr_irq_unmask(struct irq_data *d)\r\n{\r\nstruct altr_arria10_edac *edac = irq_data_get_irq_chip_data(d);\r\nregmap_write(edac->ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_CLR_OFST,\r\nBIT(d->hwirq));\r\n}\r\nstatic int a10_eccmgr_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct altr_arria10_edac *edac = d->host_data;\r\nirq_set_chip_and_handler(irq, &edac->irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, edac);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic int altr_edac_a10_probe(struct platform_device *pdev)\r\n{\r\nstruct altr_arria10_edac *edac;\r\nstruct device_node *child;\r\nedac = devm_kzalloc(&pdev->dev, sizeof(*edac), GFP_KERNEL);\r\nif (!edac)\r\nreturn -ENOMEM;\r\nedac->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, edac);\r\nINIT_LIST_HEAD(&edac->a10_ecc_devices);\r\nedac->ecc_mgr_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"altr,sysmgr-syscon");\r\nif (IS_ERR(edac->ecc_mgr_map)) {\r\nedac_printk(KERN_ERR, EDAC_DEVICE,\r\n"Unable to get syscon altr,sysmgr-syscon\n");\r\nreturn PTR_ERR(edac->ecc_mgr_map);\r\n}\r\nedac->irq_chip.name = pdev->dev.of_node->name;\r\nedac->irq_chip.irq_mask = a10_eccmgr_irq_mask;\r\nedac->irq_chip.irq_unmask = a10_eccmgr_irq_unmask;\r\nedac->domain = irq_domain_add_linear(pdev->dev.of_node, 64,\r\n&a10_eccmgr_ic_ops, edac);\r\nif (!edac->domain) {\r\ndev_err(&pdev->dev, "Error adding IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nedac->sb_irq = platform_get_irq(pdev, 0);\r\nif (edac->sb_irq < 0) {\r\ndev_err(&pdev->dev, "No SBERR IRQ resource\n");\r\nreturn edac->sb_irq;\r\n}\r\nirq_set_chained_handler_and_data(edac->sb_irq,\r\naltr_edac_a10_irq_handler,\r\nedac);\r\nedac->db_irq = platform_get_irq(pdev, 1);\r\nif (edac->db_irq < 0) {\r\ndev_err(&pdev->dev, "No DBERR IRQ resource\n");\r\nreturn edac->db_irq;\r\n}\r\nirq_set_chained_handler_and_data(edac->db_irq,\r\naltr_edac_a10_irq_handler,\r\nedac);\r\nfor_each_child_of_node(pdev->dev.of_node, child) {\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nif (of_device_is_compatible(child, "altr,socfpga-a10-l2-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-a10-ocram-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-eth-mac-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-nand-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-dma-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-usb-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-qspi-ecc") ||\r\nof_device_is_compatible(child, "altr,socfpga-sdmmc-ecc"))\r\naltr_edac_a10_device_add(edac, child);\r\nelse if (of_device_is_compatible(child, "altr,sdram-edac-a10"))\r\nof_platform_populate(pdev->dev.of_node,\r\naltr_sdram_ctrl_of_match,\r\nNULL, &pdev->dev);\r\n}\r\nreturn 0;\r\n}
