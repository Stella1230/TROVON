void switchdev_trans_item_enqueue(struct switchdev_trans *trans,\r\nvoid *data, void (*destructor)(void const *),\r\nstruct switchdev_trans_item *tritem)\r\n{\r\ntritem->data = data;\r\ntritem->destructor = destructor;\r\nlist_add_tail(&tritem->list, &trans->item_list);\r\n}\r\nstatic struct switchdev_trans_item *\r\n__switchdev_trans_item_dequeue(struct switchdev_trans *trans)\r\n{\r\nstruct switchdev_trans_item *tritem;\r\nif (list_empty(&trans->item_list))\r\nreturn NULL;\r\ntritem = list_first_entry(&trans->item_list,\r\nstruct switchdev_trans_item, list);\r\nlist_del(&tritem->list);\r\nreturn tritem;\r\n}\r\nvoid *switchdev_trans_item_dequeue(struct switchdev_trans *trans)\r\n{\r\nstruct switchdev_trans_item *tritem;\r\ntritem = __switchdev_trans_item_dequeue(trans);\r\nBUG_ON(!tritem);\r\nreturn tritem->data;\r\n}\r\nstatic void switchdev_trans_init(struct switchdev_trans *trans)\r\n{\r\nINIT_LIST_HEAD(&trans->item_list);\r\n}\r\nstatic void switchdev_trans_items_destroy(struct switchdev_trans *trans)\r\n{\r\nstruct switchdev_trans_item *tritem;\r\nwhile ((tritem = __switchdev_trans_item_dequeue(trans)))\r\ntritem->destructor(tritem->data);\r\n}\r\nstatic void switchdev_trans_items_warn_destroy(struct net_device *dev,\r\nstruct switchdev_trans *trans)\r\n{\r\nWARN(!list_empty(&trans->item_list), "%s: transaction item queue is not empty.\n",\r\ndev->name);\r\nswitchdev_trans_items_destroy(trans);\r\n}\r\nstatic struct switchdev_deferred_item *switchdev_deferred_dequeue(void)\r\n{\r\nstruct switchdev_deferred_item *dfitem;\r\nspin_lock_bh(&deferred_lock);\r\nif (list_empty(&deferred)) {\r\ndfitem = NULL;\r\ngoto unlock;\r\n}\r\ndfitem = list_first_entry(&deferred,\r\nstruct switchdev_deferred_item, list);\r\nlist_del(&dfitem->list);\r\nunlock:\r\nspin_unlock_bh(&deferred_lock);\r\nreturn dfitem;\r\n}\r\nvoid switchdev_deferred_process(void)\r\n{\r\nstruct switchdev_deferred_item *dfitem;\r\nASSERT_RTNL();\r\nwhile ((dfitem = switchdev_deferred_dequeue())) {\r\ndfitem->func(dfitem->dev, dfitem->data);\r\ndev_put(dfitem->dev);\r\nkfree(dfitem);\r\n}\r\n}\r\nstatic void switchdev_deferred_process_work(struct work_struct *work)\r\n{\r\nrtnl_lock();\r\nswitchdev_deferred_process();\r\nrtnl_unlock();\r\n}\r\nstatic int switchdev_deferred_enqueue(struct net_device *dev,\r\nconst void *data, size_t data_len,\r\nswitchdev_deferred_func_t *func)\r\n{\r\nstruct switchdev_deferred_item *dfitem;\r\ndfitem = kmalloc(sizeof(*dfitem) + data_len, GFP_ATOMIC);\r\nif (!dfitem)\r\nreturn -ENOMEM;\r\ndfitem->dev = dev;\r\ndfitem->func = func;\r\nmemcpy(dfitem->data, data, data_len);\r\ndev_hold(dev);\r\nspin_lock_bh(&deferred_lock);\r\nlist_add_tail(&dfitem->list, &deferred);\r\nspin_unlock_bh(&deferred_lock);\r\nschedule_work(&deferred_process_work);\r\nreturn 0;\r\n}\r\nint switchdev_port_attr_get(struct net_device *dev, struct switchdev_attr *attr)\r\n{\r\nconst struct switchdev_ops *ops = dev->switchdev_ops;\r\nstruct net_device *lower_dev;\r\nstruct list_head *iter;\r\nstruct switchdev_attr first = {\r\n.id = SWITCHDEV_ATTR_ID_UNDEFINED\r\n};\r\nint err = -EOPNOTSUPP;\r\nif (ops && ops->switchdev_port_attr_get)\r\nreturn ops->switchdev_port_attr_get(dev, attr);\r\nif (attr->flags & SWITCHDEV_F_NO_RECURSE)\r\nreturn err;\r\nnetdev_for_each_lower_dev(dev, lower_dev, iter) {\r\nerr = switchdev_port_attr_get(lower_dev, attr);\r\nif (err)\r\nbreak;\r\nif (first.id == SWITCHDEV_ATTR_ID_UNDEFINED)\r\nfirst = *attr;\r\nelse if (memcmp(&first, attr, sizeof(*attr)))\r\nreturn -ENODATA;\r\n}\r\nreturn err;\r\n}\r\nstatic int __switchdev_port_attr_set(struct net_device *dev,\r\nconst struct switchdev_attr *attr,\r\nstruct switchdev_trans *trans)\r\n{\r\nconst struct switchdev_ops *ops = dev->switchdev_ops;\r\nstruct net_device *lower_dev;\r\nstruct list_head *iter;\r\nint err = -EOPNOTSUPP;\r\nif (ops && ops->switchdev_port_attr_set) {\r\nerr = ops->switchdev_port_attr_set(dev, attr, trans);\r\ngoto done;\r\n}\r\nif (attr->flags & SWITCHDEV_F_NO_RECURSE)\r\ngoto done;\r\nnetdev_for_each_lower_dev(dev, lower_dev, iter) {\r\nerr = __switchdev_port_attr_set(lower_dev, attr, trans);\r\nif (err)\r\nbreak;\r\n}\r\ndone:\r\nif (err == -EOPNOTSUPP && attr->flags & SWITCHDEV_F_SKIP_EOPNOTSUPP)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int switchdev_port_attr_set_now(struct net_device *dev,\r\nconst struct switchdev_attr *attr)\r\n{\r\nstruct switchdev_trans trans;\r\nint err;\r\nswitchdev_trans_init(&trans);\r\ntrans.ph_prepare = true;\r\nerr = __switchdev_port_attr_set(dev, attr, &trans);\r\nif (err) {\r\nif (err != -EOPNOTSUPP)\r\nswitchdev_trans_items_destroy(&trans);\r\nreturn err;\r\n}\r\ntrans.ph_prepare = false;\r\nerr = __switchdev_port_attr_set(dev, attr, &trans);\r\nWARN(err, "%s: Commit of attribute (id=%d) failed.\n",\r\ndev->name, attr->id);\r\nswitchdev_trans_items_warn_destroy(dev, &trans);\r\nreturn err;\r\n}\r\nstatic void switchdev_port_attr_set_deferred(struct net_device *dev,\r\nconst void *data)\r\n{\r\nconst struct switchdev_attr *attr = data;\r\nint err;\r\nerr = switchdev_port_attr_set_now(dev, attr);\r\nif (err && err != -EOPNOTSUPP)\r\nnetdev_err(dev, "failed (err=%d) to set attribute (id=%d)\n",\r\nerr, attr->id);\r\nif (attr->complete)\r\nattr->complete(dev, err, attr->complete_priv);\r\n}\r\nstatic int switchdev_port_attr_set_defer(struct net_device *dev,\r\nconst struct switchdev_attr *attr)\r\n{\r\nreturn switchdev_deferred_enqueue(dev, attr, sizeof(*attr),\r\nswitchdev_port_attr_set_deferred);\r\n}\r\nint switchdev_port_attr_set(struct net_device *dev,\r\nconst struct switchdev_attr *attr)\r\n{\r\nif (attr->flags & SWITCHDEV_F_DEFER)\r\nreturn switchdev_port_attr_set_defer(dev, attr);\r\nASSERT_RTNL();\r\nreturn switchdev_port_attr_set_now(dev, attr);\r\n}\r\nstatic size_t switchdev_obj_size(const struct switchdev_obj *obj)\r\n{\r\nswitch (obj->id) {\r\ncase SWITCHDEV_OBJ_ID_PORT_VLAN:\r\nreturn sizeof(struct switchdev_obj_port_vlan);\r\ncase SWITCHDEV_OBJ_ID_PORT_FDB:\r\nreturn sizeof(struct switchdev_obj_port_fdb);\r\ncase SWITCHDEV_OBJ_ID_PORT_MDB:\r\nreturn sizeof(struct switchdev_obj_port_mdb);\r\ndefault:\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int __switchdev_port_obj_add(struct net_device *dev,\r\nconst struct switchdev_obj *obj,\r\nstruct switchdev_trans *trans)\r\n{\r\nconst struct switchdev_ops *ops = dev->switchdev_ops;\r\nstruct net_device *lower_dev;\r\nstruct list_head *iter;\r\nint err = -EOPNOTSUPP;\r\nif (ops && ops->switchdev_port_obj_add)\r\nreturn ops->switchdev_port_obj_add(dev, obj, trans);\r\nnetdev_for_each_lower_dev(dev, lower_dev, iter) {\r\nerr = __switchdev_port_obj_add(lower_dev, obj, trans);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int switchdev_port_obj_add_now(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nstruct switchdev_trans trans;\r\nint err;\r\nASSERT_RTNL();\r\nswitchdev_trans_init(&trans);\r\ntrans.ph_prepare = true;\r\nerr = __switchdev_port_obj_add(dev, obj, &trans);\r\nif (err) {\r\nif (err != -EOPNOTSUPP)\r\nswitchdev_trans_items_destroy(&trans);\r\nreturn err;\r\n}\r\ntrans.ph_prepare = false;\r\nerr = __switchdev_port_obj_add(dev, obj, &trans);\r\nWARN(err, "%s: Commit of object (id=%d) failed.\n", dev->name, obj->id);\r\nswitchdev_trans_items_warn_destroy(dev, &trans);\r\nreturn err;\r\n}\r\nstatic void switchdev_port_obj_add_deferred(struct net_device *dev,\r\nconst void *data)\r\n{\r\nconst struct switchdev_obj *obj = data;\r\nint err;\r\nerr = switchdev_port_obj_add_now(dev, obj);\r\nif (err && err != -EOPNOTSUPP)\r\nnetdev_err(dev, "failed (err=%d) to add object (id=%d)\n",\r\nerr, obj->id);\r\nif (obj->complete)\r\nobj->complete(dev, err, obj->complete_priv);\r\n}\r\nstatic int switchdev_port_obj_add_defer(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nreturn switchdev_deferred_enqueue(dev, obj, switchdev_obj_size(obj),\r\nswitchdev_port_obj_add_deferred);\r\n}\r\nint switchdev_port_obj_add(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nif (obj->flags & SWITCHDEV_F_DEFER)\r\nreturn switchdev_port_obj_add_defer(dev, obj);\r\nASSERT_RTNL();\r\nreturn switchdev_port_obj_add_now(dev, obj);\r\n}\r\nstatic int switchdev_port_obj_del_now(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nconst struct switchdev_ops *ops = dev->switchdev_ops;\r\nstruct net_device *lower_dev;\r\nstruct list_head *iter;\r\nint err = -EOPNOTSUPP;\r\nif (ops && ops->switchdev_port_obj_del)\r\nreturn ops->switchdev_port_obj_del(dev, obj);\r\nnetdev_for_each_lower_dev(dev, lower_dev, iter) {\r\nerr = switchdev_port_obj_del_now(lower_dev, obj);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void switchdev_port_obj_del_deferred(struct net_device *dev,\r\nconst void *data)\r\n{\r\nconst struct switchdev_obj *obj = data;\r\nint err;\r\nerr = switchdev_port_obj_del_now(dev, obj);\r\nif (err && err != -EOPNOTSUPP)\r\nnetdev_err(dev, "failed (err=%d) to del object (id=%d)\n",\r\nerr, obj->id);\r\nif (obj->complete)\r\nobj->complete(dev, err, obj->complete_priv);\r\n}\r\nstatic int switchdev_port_obj_del_defer(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nreturn switchdev_deferred_enqueue(dev, obj, switchdev_obj_size(obj),\r\nswitchdev_port_obj_del_deferred);\r\n}\r\nint switchdev_port_obj_del(struct net_device *dev,\r\nconst struct switchdev_obj *obj)\r\n{\r\nif (obj->flags & SWITCHDEV_F_DEFER)\r\nreturn switchdev_port_obj_del_defer(dev, obj);\r\nASSERT_RTNL();\r\nreturn switchdev_port_obj_del_now(dev, obj);\r\n}\r\nint switchdev_port_obj_dump(struct net_device *dev, struct switchdev_obj *obj,\r\nswitchdev_obj_dump_cb_t *cb)\r\n{\r\nconst struct switchdev_ops *ops = dev->switchdev_ops;\r\nstruct net_device *lower_dev;\r\nstruct list_head *iter;\r\nint err = -EOPNOTSUPP;\r\nASSERT_RTNL();\r\nif (ops && ops->switchdev_port_obj_dump)\r\nreturn ops->switchdev_port_obj_dump(dev, obj, cb);\r\nnetdev_for_each_lower_dev(dev, lower_dev, iter) {\r\nerr = switchdev_port_obj_dump(lower_dev, obj, cb);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nint register_switchdev_notifier(struct notifier_block *nb)\r\n{\r\nint err;\r\nrtnl_lock();\r\nerr = raw_notifier_chain_register(&switchdev_notif_chain, nb);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint unregister_switchdev_notifier(struct notifier_block *nb)\r\n{\r\nint err;\r\nrtnl_lock();\r\nerr = raw_notifier_chain_unregister(&switchdev_notif_chain, nb);\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nint call_switchdev_notifiers(unsigned long val, struct net_device *dev,\r\nstruct switchdev_notifier_info *info)\r\n{\r\nASSERT_RTNL();\r\ninfo->dev = dev;\r\nreturn raw_notifier_call_chain(&switchdev_notif_chain, val, info);\r\n}\r\nstatic int switchdev_port_vlan_dump_put(struct switchdev_vlan_dump *dump)\r\n{\r\nstruct bridge_vlan_info vinfo;\r\nvinfo.flags = dump->flags;\r\nif (dump->begin == 0 && dump->end == 0) {\r\nreturn 0;\r\n} else if (dump->begin == dump->end) {\r\nvinfo.vid = dump->begin;\r\nif (nla_put(dump->skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\nreturn -EMSGSIZE;\r\n} else {\r\nvinfo.vid = dump->begin;\r\nvinfo.flags |= BRIDGE_VLAN_INFO_RANGE_BEGIN;\r\nif (nla_put(dump->skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\nreturn -EMSGSIZE;\r\nvinfo.vid = dump->end;\r\nvinfo.flags &= ~BRIDGE_VLAN_INFO_RANGE_BEGIN;\r\nvinfo.flags |= BRIDGE_VLAN_INFO_RANGE_END;\r\nif (nla_put(dump->skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int switchdev_port_vlan_dump_cb(struct switchdev_obj *obj)\r\n{\r\nstruct switchdev_obj_port_vlan *vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\r\nstruct switchdev_vlan_dump *dump =\r\ncontainer_of(vlan, struct switchdev_vlan_dump, vlan);\r\nint err = 0;\r\nif (vlan->vid_begin > vlan->vid_end)\r\nreturn -EINVAL;\r\nif (dump->filter_mask & RTEXT_FILTER_BRVLAN) {\r\ndump->flags = vlan->flags;\r\nfor (dump->begin = dump->end = vlan->vid_begin;\r\ndump->begin <= vlan->vid_end;\r\ndump->begin++, dump->end++) {\r\nerr = switchdev_port_vlan_dump_put(dump);\r\nif (err)\r\nreturn err;\r\n}\r\n} else if (dump->filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED) {\r\nif (dump->begin > vlan->vid_begin &&\r\ndump->begin >= vlan->vid_end) {\r\nif ((dump->begin - 1) == vlan->vid_end &&\r\ndump->flags == vlan->flags) {\r\ndump->begin = vlan->vid_begin;\r\n} else {\r\nerr = switchdev_port_vlan_dump_put(dump);\r\ndump->flags = vlan->flags;\r\ndump->begin = vlan->vid_begin;\r\ndump->end = vlan->vid_end;\r\n}\r\n} else if (dump->end <= vlan->vid_begin &&\r\ndump->end < vlan->vid_end) {\r\nif ((dump->end + 1) == vlan->vid_begin &&\r\ndump->flags == vlan->flags) {\r\ndump->end = vlan->vid_end;\r\n} else {\r\nerr = switchdev_port_vlan_dump_put(dump);\r\ndump->flags = vlan->flags;\r\ndump->begin = vlan->vid_begin;\r\ndump->end = vlan->vid_end;\r\n}\r\n} else {\r\nerr = -EINVAL;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int switchdev_port_vlan_fill(struct sk_buff *skb, struct net_device *dev,\r\nu32 filter_mask)\r\n{\r\nstruct switchdev_vlan_dump dump = {\r\n.vlan.obj.orig_dev = dev,\r\n.vlan.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\r\n.skb = skb,\r\n.filter_mask = filter_mask,\r\n};\r\nint err = 0;\r\nif ((filter_mask & RTEXT_FILTER_BRVLAN) ||\r\n(filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)) {\r\nerr = switchdev_port_obj_dump(dev, &dump.vlan.obj,\r\nswitchdev_port_vlan_dump_cb);\r\nif (err)\r\ngoto err_out;\r\nif (filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)\r\nerr = switchdev_port_vlan_dump_put(&dump);\r\n}\r\nerr_out:\r\nreturn err == -EOPNOTSUPP ? 0 : err;\r\n}\r\nint switchdev_port_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\r\nstruct net_device *dev, u32 filter_mask,\r\nint nlflags)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = dev,\r\n.id = SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS,\r\n};\r\nu16 mode = BRIDGE_MODE_UNDEF;\r\nu32 mask = BR_LEARNING | BR_LEARNING_SYNC | BR_FLOOD;\r\nint err;\r\nif (!netif_is_bridge_port(dev))\r\nreturn -EOPNOTSUPP;\r\nerr = switchdev_port_attr_get(dev, &attr);\r\nif (err && err != -EOPNOTSUPP)\r\nreturn err;\r\nreturn ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode,\r\nattr.u.brport_flags, mask, nlflags,\r\nfilter_mask, switchdev_port_vlan_fill);\r\n}\r\nstatic int switchdev_port_br_setflag(struct net_device *dev,\r\nstruct nlattr *nlattr,\r\nunsigned long brport_flag)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = dev,\r\n.id = SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS,\r\n};\r\nu8 flag = nla_get_u8(nlattr);\r\nint err;\r\nerr = switchdev_port_attr_get(dev, &attr);\r\nif (err)\r\nreturn err;\r\nif (flag)\r\nattr.u.brport_flags |= brport_flag;\r\nelse\r\nattr.u.brport_flags &= ~brport_flag;\r\nreturn switchdev_port_attr_set(dev, &attr);\r\n}\r\nstatic int switchdev_port_br_setlink_protinfo(struct net_device *dev,\r\nstruct nlattr *protinfo)\r\n{\r\nstruct nlattr *attr;\r\nint rem;\r\nint err;\r\nerr = nla_validate_nested(protinfo, IFLA_BRPORT_MAX,\r\nswitchdev_port_bridge_policy);\r\nif (err)\r\nreturn err;\r\nnla_for_each_nested(attr, protinfo, rem) {\r\nswitch (nla_type(attr)) {\r\ncase IFLA_BRPORT_LEARNING:\r\nerr = switchdev_port_br_setflag(dev, attr,\r\nBR_LEARNING);\r\nbreak;\r\ncase IFLA_BRPORT_LEARNING_SYNC:\r\nerr = switchdev_port_br_setflag(dev, attr,\r\nBR_LEARNING_SYNC);\r\nbreak;\r\ncase IFLA_BRPORT_UNICAST_FLOOD:\r\nerr = switchdev_port_br_setflag(dev, attr, BR_FLOOD);\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int switchdev_port_br_afspec(struct net_device *dev,\r\nstruct nlattr *afspec,\r\nint (*f)(struct net_device *dev,\r\nconst struct switchdev_obj *obj))\r\n{\r\nstruct nlattr *attr;\r\nstruct bridge_vlan_info *vinfo;\r\nstruct switchdev_obj_port_vlan vlan = {\r\n.obj.orig_dev = dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\r\n};\r\nint rem;\r\nint err;\r\nnla_for_each_nested(attr, afspec, rem) {\r\nif (nla_type(attr) != IFLA_BRIDGE_VLAN_INFO)\r\ncontinue;\r\nif (nla_len(attr) != sizeof(struct bridge_vlan_info))\r\nreturn -EINVAL;\r\nvinfo = nla_data(attr);\r\nif (!vinfo->vid || vinfo->vid >= VLAN_VID_MASK)\r\nreturn -EINVAL;\r\nvlan.flags = vinfo->flags;\r\nif (vinfo->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {\r\nif (vlan.vid_begin)\r\nreturn -EINVAL;\r\nvlan.vid_begin = vinfo->vid;\r\nif (vlan.flags & BRIDGE_VLAN_INFO_PVID)\r\nreturn -EINVAL;\r\n} else if (vinfo->flags & BRIDGE_VLAN_INFO_RANGE_END) {\r\nif (!vlan.vid_begin)\r\nreturn -EINVAL;\r\nvlan.vid_end = vinfo->vid;\r\nif (vlan.vid_end <= vlan.vid_begin)\r\nreturn -EINVAL;\r\nerr = f(dev, &vlan.obj);\r\nif (err)\r\nreturn err;\r\nvlan.vid_begin = 0;\r\n} else {\r\nif (vlan.vid_begin)\r\nreturn -EINVAL;\r\nvlan.vid_begin = vinfo->vid;\r\nvlan.vid_end = vinfo->vid;\r\nerr = f(dev, &vlan.obj);\r\nif (err)\r\nreturn err;\r\nvlan.vid_begin = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint switchdev_port_bridge_setlink(struct net_device *dev,\r\nstruct nlmsghdr *nlh, u16 flags)\r\n{\r\nstruct nlattr *protinfo;\r\nstruct nlattr *afspec;\r\nint err = 0;\r\nif (!netif_is_bridge_port(dev))\r\nreturn -EOPNOTSUPP;\r\nprotinfo = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg),\r\nIFLA_PROTINFO);\r\nif (protinfo) {\r\nerr = switchdev_port_br_setlink_protinfo(dev, protinfo);\r\nif (err)\r\nreturn err;\r\n}\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg),\r\nIFLA_AF_SPEC);\r\nif (afspec)\r\nerr = switchdev_port_br_afspec(dev, afspec,\r\nswitchdev_port_obj_add);\r\nreturn err;\r\n}\r\nint switchdev_port_bridge_dellink(struct net_device *dev,\r\nstruct nlmsghdr *nlh, u16 flags)\r\n{\r\nstruct nlattr *afspec;\r\nif (!netif_is_bridge_port(dev))\r\nreturn -EOPNOTSUPP;\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg),\r\nIFLA_AF_SPEC);\r\nif (afspec)\r\nreturn switchdev_port_br_afspec(dev, afspec,\r\nswitchdev_port_obj_del);\r\nreturn 0;\r\n}\r\nint switchdev_port_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev, const unsigned char *addr,\r\nu16 vid, u16 nlm_flags)\r\n{\r\nstruct switchdev_obj_port_fdb fdb = {\r\n.obj.orig_dev = dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_FDB,\r\n.vid = vid,\r\n};\r\nether_addr_copy(fdb.addr, addr);\r\nreturn switchdev_port_obj_add(dev, &fdb.obj);\r\n}\r\nint switchdev_port_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev, const unsigned char *addr,\r\nu16 vid)\r\n{\r\nstruct switchdev_obj_port_fdb fdb = {\r\n.obj.orig_dev = dev,\r\n.obj.id = SWITCHDEV_OBJ_ID_PORT_FDB,\r\n.vid = vid,\r\n};\r\nether_addr_copy(fdb.addr, addr);\r\nreturn switchdev_port_obj_del(dev, &fdb.obj);\r\n}\r\nstatic int switchdev_port_fdb_dump_cb(struct switchdev_obj *obj)\r\n{\r\nstruct switchdev_obj_port_fdb *fdb = SWITCHDEV_OBJ_PORT_FDB(obj);\r\nstruct switchdev_fdb_dump *dump =\r\ncontainer_of(fdb, struct switchdev_fdb_dump, fdb);\r\nu32 portid = NETLINK_CB(dump->cb->skb).portid;\r\nu32 seq = dump->cb->nlh->nlmsg_seq;\r\nstruct nlmsghdr *nlh;\r\nstruct ndmsg *ndm;\r\nif (dump->idx < dump->cb->args[2])\r\ngoto skip;\r\nnlh = nlmsg_put(dump->skb, portid, seq, RTM_NEWNEIGH,\r\nsizeof(*ndm), NLM_F_MULTI);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nndm = nlmsg_data(nlh);\r\nndm->ndm_family = AF_BRIDGE;\r\nndm->ndm_pad1 = 0;\r\nndm->ndm_pad2 = 0;\r\nndm->ndm_flags = NTF_SELF;\r\nndm->ndm_type = 0;\r\nndm->ndm_ifindex = dump->dev->ifindex;\r\nndm->ndm_state = fdb->ndm_state;\r\nif (nla_put(dump->skb, NDA_LLADDR, ETH_ALEN, fdb->addr))\r\ngoto nla_put_failure;\r\nif (fdb->vid && nla_put_u16(dump->skb, NDA_VLAN, fdb->vid))\r\ngoto nla_put_failure;\r\nnlmsg_end(dump->skb, nlh);\r\nskip:\r\ndump->idx++;\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_cancel(dump->skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nint switchdev_port_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct net_device *dev,\r\nstruct net_device *filter_dev, int *idx)\r\n{\r\nstruct switchdev_fdb_dump dump = {\r\n.fdb.obj.orig_dev = dev,\r\n.fdb.obj.id = SWITCHDEV_OBJ_ID_PORT_FDB,\r\n.dev = dev,\r\n.skb = skb,\r\n.cb = cb,\r\n.idx = *idx,\r\n};\r\nint err;\r\nerr = switchdev_port_obj_dump(dev, &dump.fdb.obj,\r\nswitchdev_port_fdb_dump_cb);\r\n*idx = dump.idx;\r\nreturn err;\r\n}\r\nbool switchdev_port_same_parent_id(struct net_device *a,\r\nstruct net_device *b)\r\n{\r\nstruct switchdev_attr a_attr = {\r\n.orig_dev = a,\r\n.id = SWITCHDEV_ATTR_ID_PORT_PARENT_ID,\r\n};\r\nstruct switchdev_attr b_attr = {\r\n.orig_dev = b,\r\n.id = SWITCHDEV_ATTR_ID_PORT_PARENT_ID,\r\n};\r\nif (switchdev_port_attr_get(a, &a_attr) ||\r\nswitchdev_port_attr_get(b, &b_attr))\r\nreturn false;\r\nreturn netdev_phys_item_id_same(&a_attr.u.ppid, &b_attr.u.ppid);\r\n}
