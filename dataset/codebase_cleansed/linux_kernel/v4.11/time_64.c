unsigned long profile_pc(struct pt_regs *regs)\r\n{\r\nunsigned long pc = instruction_pointer(regs);\r\nif (in_lock_functions(pc))\r\nreturn regs->u_regs[UREG_RETPC];\r\nreturn pc;\r\n}\r\nstatic void tick_disable_protection(void)\r\n{\r\n__asm__ __volatile__(\r\n" ba,pt %%xcc, 1f\n"\r\n" nop\n"\r\n" .align 64\n"\r\n"1: rd %%tick, %%g2\n"\r\n" add %%g2, 6, %%g2\n"\r\n" andn %%g2, %0, %%g2\n"\r\n" wrpr %%g2, 0, %%tick\n"\r\n" rdpr %%tick, %%g0"\r\n:\r\n: "r" (TICK_PRIV_BIT)\r\n: "g2");\r\n}\r\nstatic void tick_disable_irq(void)\r\n{\r\n__asm__ __volatile__(\r\n" ba,pt %%xcc, 1f\n"\r\n" nop\n"\r\n" .align 64\n"\r\n"1: wr %0, 0x0, %%tick_cmpr\n"\r\n" rd %%tick_cmpr, %%g0"\r\n:\r\n: "r" (TICKCMP_IRQ_BIT));\r\n}\r\nstatic void tick_init_tick(void)\r\n{\r\ntick_disable_protection();\r\ntick_disable_irq();\r\n}\r\nstatic unsigned long long tick_get_tick(void)\r\n{\r\nunsigned long ret;\r\n__asm__ __volatile__("rd %%tick, %0\n\t"\r\n"mov %0, %0"\r\n: "=r" (ret));\r\nreturn ret & ~TICK_PRIV_BIT;\r\n}\r\nstatic int tick_add_compare(unsigned long adj)\r\n{\r\nunsigned long orig_tick, new_tick, new_compare;\r\n__asm__ __volatile__("rd %%tick, %0"\r\n: "=r" (orig_tick));\r\norig_tick &= ~TICKCMP_IRQ_BIT;\r\n__asm__ __volatile__("ba,pt %%xcc, 1f\n\t"\r\n" add %1, %2, %0\n\t"\r\n".align 64\n"\r\n"1:\n\t"\r\n"wr %0, 0, %%tick_cmpr\n\t"\r\n"rd %%tick_cmpr, %%g0\n\t"\r\n: "=r" (new_compare)\r\n: "r" (orig_tick), "r" (adj));\r\n__asm__ __volatile__("rd %%tick, %0"\r\n: "=r" (new_tick));\r\nnew_tick &= ~TICKCMP_IRQ_BIT;\r\nreturn ((long)(new_tick - (orig_tick+adj))) > 0L;\r\n}\r\nstatic unsigned long tick_add_tick(unsigned long adj)\r\n{\r\nunsigned long new_tick;\r\n__asm__ __volatile__("rd %%tick, %0\n\t"\r\n"add %0, %1, %0\n\t"\r\n"wrpr %0, 0, %%tick\n\t"\r\n: "=&r" (new_tick)\r\n: "r" (adj));\r\nreturn new_tick;\r\n}\r\nstatic void stick_disable_irq(void)\r\n{\r\n__asm__ __volatile__(\r\n"wr %0, 0x0, %%asr25"\r\n:\r\n: "r" (TICKCMP_IRQ_BIT));\r\n}\r\nstatic void stick_init_tick(void)\r\n{\r\nif (tlb_type != hypervisor) {\r\ntick_disable_protection();\r\ntick_disable_irq();\r\n__asm__ __volatile__(\r\n" rd %%asr24, %%g2\n"\r\n" andn %%g2, %0, %%g2\n"\r\n" wr %%g2, 0, %%asr24"\r\n:\r\n: "r" (TICK_PRIV_BIT)\r\n: "g1", "g2");\r\n}\r\nstick_disable_irq();\r\n}\r\nstatic unsigned long long stick_get_tick(void)\r\n{\r\nunsigned long ret;\r\n__asm__ __volatile__("rd %%asr24, %0"\r\n: "=r" (ret));\r\nreturn ret & ~TICK_PRIV_BIT;\r\n}\r\nstatic unsigned long stick_add_tick(unsigned long adj)\r\n{\r\nunsigned long new_tick;\r\n__asm__ __volatile__("rd %%asr24, %0\n\t"\r\n"add %0, %1, %0\n\t"\r\n"wr %0, 0, %%asr24\n\t"\r\n: "=&r" (new_tick)\r\n: "r" (adj));\r\nreturn new_tick;\r\n}\r\nstatic int stick_add_compare(unsigned long adj)\r\n{\r\nunsigned long orig_tick, new_tick;\r\n__asm__ __volatile__("rd %%asr24, %0"\r\n: "=r" (orig_tick));\r\norig_tick &= ~TICKCMP_IRQ_BIT;\r\n__asm__ __volatile__("wr %0, 0, %%asr25"\r\n:\r\n: "r" (orig_tick + adj));\r\n__asm__ __volatile__("rd %%asr24, %0"\r\n: "=r" (new_tick));\r\nnew_tick &= ~TICKCMP_IRQ_BIT;\r\nreturn ((long)(new_tick - (orig_tick+adj))) > 0L;\r\n}\r\nstatic unsigned long __hbird_read_stick(void)\r\n{\r\nunsigned long ret, tmp1, tmp2, tmp3;\r\nunsigned long addr = HBIRD_STICK_ADDR+8;\r\n__asm__ __volatile__("ldxa [%1] %5, %2\n"\r\n"1:\n\t"\r\n"sub %1, 0x8, %1\n\t"\r\n"ldxa [%1] %5, %3\n\t"\r\n"add %1, 0x8, %1\n\t"\r\n"ldxa [%1] %5, %4\n\t"\r\n"cmp %4, %2\n\t"\r\n"bne,a,pn %%xcc, 1b\n\t"\r\n" mov %4, %2\n\t"\r\n"sllx %4, 32, %4\n\t"\r\n"or %3, %4, %0\n\t"\r\n: "=&r" (ret), "=&r" (addr),\r\n"=&r" (tmp1), "=&r" (tmp2), "=&r" (tmp3)\r\n: "i" (ASI_PHYS_BYPASS_EC_E), "1" (addr));\r\nreturn ret;\r\n}\r\nstatic void __hbird_write_stick(unsigned long val)\r\n{\r\nunsigned long low = (val & 0xffffffffUL);\r\nunsigned long high = (val >> 32UL);\r\nunsigned long addr = HBIRD_STICK_ADDR;\r\n__asm__ __volatile__("stxa %%g0, [%0] %4\n\t"\r\n"add %0, 0x8, %0\n\t"\r\n"stxa %3, [%0] %4\n\t"\r\n"sub %0, 0x8, %0\n\t"\r\n"stxa %2, [%0] %4"\r\n: "=&r" (addr)\r\n: "0" (addr), "r" (low), "r" (high),\r\n"i" (ASI_PHYS_BYPASS_EC_E));\r\n}\r\nstatic void __hbird_write_compare(unsigned long val)\r\n{\r\nunsigned long low = (val & 0xffffffffUL);\r\nunsigned long high = (val >> 32UL);\r\nunsigned long addr = HBIRD_STICKCMP_ADDR + 0x8UL;\r\n__asm__ __volatile__("stxa %3, [%0] %4\n\t"\r\n"sub %0, 0x8, %0\n\t"\r\n"stxa %2, [%0] %4"\r\n: "=&r" (addr)\r\n: "0" (addr), "r" (low), "r" (high),\r\n"i" (ASI_PHYS_BYPASS_EC_E));\r\n}\r\nstatic void hbtick_disable_irq(void)\r\n{\r\n__hbird_write_compare(TICKCMP_IRQ_BIT);\r\n}\r\nstatic void hbtick_init_tick(void)\r\n{\r\ntick_disable_protection();\r\n__hbird_write_stick(__hbird_read_stick());\r\nhbtick_disable_irq();\r\n}\r\nstatic unsigned long long hbtick_get_tick(void)\r\n{\r\nreturn __hbird_read_stick() & ~TICK_PRIV_BIT;\r\n}\r\nstatic unsigned long hbtick_add_tick(unsigned long adj)\r\n{\r\nunsigned long val;\r\nval = __hbird_read_stick() + adj;\r\n__hbird_write_stick(val);\r\nreturn val;\r\n}\r\nstatic int hbtick_add_compare(unsigned long adj)\r\n{\r\nunsigned long val = __hbird_read_stick();\r\nunsigned long val2;\r\nval &= ~TICKCMP_IRQ_BIT;\r\nval += adj;\r\n__hbird_write_compare(val);\r\nval2 = __hbird_read_stick() & ~TICKCMP_IRQ_BIT;\r\nreturn ((long)(val2 - val)) > 0L;\r\n}\r\nstatic int rtc_probe(struct platform_device *op)\r\n{\r\nstruct resource *r;\r\nprintk(KERN_INFO "%s: RTC regs at 0x%llx\n",\r\nop->dev.of_node->full_name, op->resource[0].start);\r\nr = &rtc_cmos_resource;\r\nr->flags = IORESOURCE_IO;\r\nr->name = op->resource[0].name;\r\nr->start = op->resource[0].start;\r\nr->end = op->resource[0].end;\r\ncmos_regs = op->resource[0].start;\r\nreturn platform_device_register(&rtc_cmos_device);\r\n}\r\nstatic int bq4802_probe(struct platform_device *op)\r\n{\r\nprintk(KERN_INFO "%s: BQ4802 regs at 0x%llx\n",\r\nop->dev.of_node->full_name, op->resource[0].start);\r\nrtc_bq4802_device.resource = &op->resource[0];\r\nreturn platform_device_register(&rtc_bq4802_device);\r\n}\r\nstatic unsigned char mostek_read_byte(struct device *dev, u32 ofs)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nvoid __iomem *regs = (void __iomem *) pdev->resource[0].start;\r\nreturn readb(regs + ofs);\r\n}\r\nstatic void mostek_write_byte(struct device *dev, u32 ofs, u8 val)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nvoid __iomem *regs = (void __iomem *) pdev->resource[0].start;\r\nwriteb(val, regs + ofs);\r\n}\r\nstatic int mostek_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nif (!strcmp(dp->parent->name, "fhc") &&\r\nstrcmp(dp->parent->parent->name, "central") != 0)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "%s: Mostek regs at 0x%llx\n",\r\ndp->full_name, op->resource[0].start);\r\nm48t59_rtc.resource = &op->resource[0];\r\nreturn platform_device_register(&m48t59_rtc);\r\n}\r\nstatic int __init clock_init(void)\r\n{\r\nif (this_is_starfire)\r\nreturn platform_device_register(&rtc_starfire_device);\r\nif (tlb_type == hypervisor)\r\nreturn platform_device_register(&rtc_sun4v_device);\r\n(void) platform_driver_register(&rtc_driver);\r\n(void) platform_driver_register(&mostek_driver);\r\n(void) platform_driver_register(&bq4802_driver);\r\nreturn 0;\r\n}\r\nstatic unsigned long sparc64_init_timers(void)\r\n{\r\nstruct device_node *dp;\r\nunsigned long freq;\r\ndp = of_find_node_by_path("/");\r\nif (tlb_type == spitfire) {\r\nunsigned long ver, manuf, impl;\r\n__asm__ __volatile__ ("rdpr %%ver, %0"\r\n: "=&r" (ver));\r\nmanuf = ((ver >> 48) & 0xffff);\r\nimpl = ((ver >> 32) & 0xffff);\r\nif (manuf == 0x17 && impl == 0x13) {\r\ntick_ops = &hbtick_operations;\r\nfreq = of_getintprop_default(dp, "stick-frequency", 0);\r\n} else {\r\ntick_ops = &tick_operations;\r\nfreq = local_cpu_data().clock_tick;\r\n}\r\n} else {\r\ntick_ops = &stick_operations;\r\nfreq = of_getintprop_default(dp, "stick-frequency", 0);\r\n}\r\nreturn freq;\r\n}\r\nunsigned long sparc64_get_clock_tick(unsigned int cpu)\r\n{\r\nstruct freq_table *ft = &per_cpu(sparc64_freq_table, cpu);\r\nif (ft->clock_tick_ref)\r\nreturn ft->clock_tick_ref;\r\nreturn cpu_data(cpu).clock_tick;\r\n}\r\nstatic int sparc64_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\r\nvoid *data)\r\n{\r\nstruct cpufreq_freqs *freq = data;\r\nunsigned int cpu = freq->cpu;\r\nstruct freq_table *ft = &per_cpu(sparc64_freq_table, cpu);\r\nif (!ft->ref_freq) {\r\nft->ref_freq = freq->old;\r\nft->clock_tick_ref = cpu_data(cpu).clock_tick;\r\n}\r\nif ((val == CPUFREQ_PRECHANGE && freq->old < freq->new) ||\r\n(val == CPUFREQ_POSTCHANGE && freq->old > freq->new)) {\r\ncpu_data(cpu).clock_tick =\r\ncpufreq_scale(ft->clock_tick_ref,\r\nft->ref_freq,\r\nfreq->new);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init register_sparc64_cpufreq_notifier(void)\r\n{\r\ncpufreq_register_notifier(&sparc64_cpufreq_notifier_block,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nreturn 0;\r\n}\r\nstatic int sparc64_next_event(unsigned long delta,\r\nstruct clock_event_device *evt)\r\n{\r\nreturn tick_ops->add_compare(delta) ? -ETIME : 0;\r\n}\r\nstatic int sparc64_timer_shutdown(struct clock_event_device *evt)\r\n{\r\ntick_ops->disable_irq();\r\nreturn 0;\r\n}\r\nvoid __irq_entry timer_interrupt(int irq, struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs = set_irq_regs(regs);\r\nunsigned long tick_mask = tick_ops->softint_mask;\r\nint cpu = smp_processor_id();\r\nstruct clock_event_device *evt = &per_cpu(sparc64_events, cpu);\r\nclear_softint(tick_mask);\r\nirq_enter();\r\nlocal_cpu_data().irq0_irqs++;\r\nkstat_incr_irq_this_cpu(0);\r\nif (unlikely(!evt->event_handler)) {\r\nprintk(KERN_WARNING\r\n"Spurious SPARC64 timer interrupt on cpu %d\n", cpu);\r\n} else\r\nevt->event_handler(evt);\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid setup_sparc64_timer(void)\r\n{\r\nstruct clock_event_device *sevt;\r\nunsigned long pstate;\r\n__asm__ __volatile__("rdpr %%pstate, %0\n\t"\r\n"wrpr %0, %1, %%pstate"\r\n: "=r" (pstate)\r\n: "i" (PSTATE_IE));\r\ntick_ops->init_tick();\r\n__asm__ __volatile__("wrpr %0, 0x0, %%pstate"\r\n:\r\n: "r" (pstate));\r\nsevt = this_cpu_ptr(&sparc64_events);\r\nmemcpy(sevt, &sparc64_clockevent, sizeof(*sevt));\r\nsevt->cpumask = cpumask_of(smp_processor_id());\r\nclockevents_register_device(sevt);\r\n}\r\nvoid __delay(unsigned long loops)\r\n{\r\nunsigned long bclock, now;\r\nbclock = tick_ops->get_tick();\r\ndo {\r\nnow = tick_ops->get_tick();\r\n} while ((now-bclock) < loops);\r\n}\r\nvoid udelay(unsigned long usecs)\r\n{\r\n__delay(tb_ticks_per_usec * usecs);\r\n}\r\nstatic u64 clocksource_tick_read(struct clocksource *cs)\r\n{\r\nreturn tick_ops->get_tick();\r\n}\r\nvoid __init time_init(void)\r\n{\r\nunsigned long freq = sparc64_init_timers();\r\ntb_ticks_per_usec = freq / USEC_PER_SEC;\r\ntimer_ticks_per_nsec_quotient =\r\nclocksource_hz2mult(freq, SPARC64_NSEC_PER_CYC_SHIFT);\r\nclocksource_tick.name = tick_ops->name;\r\nclocksource_tick.read = clocksource_tick_read;\r\nclocksource_register_hz(&clocksource_tick, freq);\r\nprintk("clocksource: mult[%x] shift[%d]\n",\r\nclocksource_tick.mult, clocksource_tick.shift);\r\nsparc64_clockevent.name = tick_ops->name;\r\nclockevents_calc_mult_shift(&sparc64_clockevent, freq, 4);\r\nsparc64_clockevent.max_delta_ns =\r\nclockevent_delta2ns(0x7fffffffffffffffUL, &sparc64_clockevent);\r\nsparc64_clockevent.min_delta_ns =\r\nclockevent_delta2ns(0xF, &sparc64_clockevent);\r\nprintk("clockevent: mult[%x] shift[%d]\n",\r\nsparc64_clockevent.mult, sparc64_clockevent.shift);\r\nsetup_sparc64_timer();\r\n}\r\nunsigned long long sched_clock(void)\r\n{\r\nunsigned long ticks = tick_ops->get_tick();\r\nreturn (ticks * timer_ticks_per_nsec_quotient)\r\n>> SPARC64_NSEC_PER_CYC_SHIFT;\r\n}\r\nint read_current_timer(unsigned long *timer_val)\r\n{\r\n*timer_val = tick_ops->get_tick();\r\nreturn 0;\r\n}
