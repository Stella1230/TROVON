static inline void pxamci_init_ocr(struct pxamci_host *host)\r\n{\r\n#ifdef CONFIG_REGULATOR\r\nhost->vcc = devm_regulator_get_optional(mmc_dev(host->mmc), "vmmc");\r\nif (IS_ERR(host->vcc))\r\nhost->vcc = NULL;\r\nelse {\r\nhost->mmc->ocr_avail = mmc_regulator_get_ocrmask(host->vcc);\r\nif (host->pdata && host->pdata->ocr_mask)\r\ndev_warn(mmc_dev(host->mmc),\r\n"ocr_mask/setpower will not be used\n");\r\n}\r\n#endif\r\nif (host->vcc == NULL) {\r\nhost->mmc->ocr_avail = host->pdata ?\r\nhost->pdata->ocr_mask :\r\nMMC_VDD_32_33 | MMC_VDD_33_34;\r\n}\r\n}\r\nstatic inline int pxamci_set_power(struct pxamci_host *host,\r\nunsigned char power_mode,\r\nunsigned int vdd)\r\n{\r\nint on;\r\nif (host->vcc) {\r\nint ret;\r\nif (power_mode == MMC_POWER_UP) {\r\nret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);\r\nif (ret)\r\nreturn ret;\r\n} else if (power_mode == MMC_POWER_OFF) {\r\nret = mmc_regulator_set_ocr(host->mmc, host->vcc, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nif (!host->vcc && host->pdata &&\r\ngpio_is_valid(host->pdata->gpio_power)) {\r\non = ((1 << vdd) & host->pdata->ocr_mask);\r\ngpio_set_value(host->pdata->gpio_power,\r\n!!on ^ host->pdata->gpio_power_invert);\r\n}\r\nif (!host->vcc && host->pdata && host->pdata->setpower)\r\nreturn host->pdata->setpower(mmc_dev(host->mmc), vdd);\r\nreturn 0;\r\n}\r\nstatic void pxamci_stop_clock(struct pxamci_host *host)\r\n{\r\nif (readl(host->base + MMC_STAT) & STAT_CLK_EN) {\r\nunsigned long timeout = 10000;\r\nunsigned int v;\r\nwritel(STOP_CLOCK, host->base + MMC_STRPCL);\r\ndo {\r\nv = readl(host->base + MMC_STAT);\r\nif (!(v & STAT_CLK_EN))\r\nbreak;\r\nudelay(1);\r\n} while (timeout--);\r\nif (v & STAT_CLK_EN)\r\ndev_err(mmc_dev(host->mmc), "unable to stop clock\n");\r\n}\r\n}\r\nstatic void pxamci_enable_irq(struct pxamci_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask &= ~mask;\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void pxamci_disable_irq(struct pxamci_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask |= mask;\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void pxamci_setup_data(struct pxamci_host *host, struct mmc_data *data)\r\n{\r\nstruct dma_async_tx_descriptor *tx;\r\nenum dma_data_direction direction;\r\nstruct dma_slave_config config;\r\nstruct dma_chan *chan;\r\nunsigned int nob = data->blocks;\r\nunsigned long long clks;\r\nunsigned int timeout;\r\nint ret;\r\nhost->data = data;\r\nwritel(nob, host->base + MMC_NOB);\r\nwritel(data->blksz, host->base + MMC_BLKLEN);\r\nclks = (unsigned long long)data->timeout_ns * host->clkrate;\r\ndo_div(clks, 1000000000UL);\r\ntimeout = (unsigned int)clks + (data->timeout_clks << host->clkrt);\r\nwritel((timeout + 255) / 256, host->base + MMC_RDTO);\r\nmemset(&config, 0, sizeof(config));\r\nconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nconfig.src_addr = host->res->start + MMC_RXFIFO;\r\nconfig.dst_addr = host->res->start + MMC_TXFIFO;\r\nconfig.src_maxburst = 32;\r\nconfig.dst_maxburst = 32;\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\ndirection = DMA_DEV_TO_MEM;\r\nchan = host->dma_chan_rx;\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\ndirection = DMA_MEM_TO_DEV;\r\nchan = host->dma_chan_tx;\r\n}\r\nconfig.direction = direction;\r\nret = dmaengine_slave_config(chan, &config);\r\nif (ret < 0) {\r\ndev_err(mmc_dev(host->mmc), "dma slave config failed\n");\r\nreturn;\r\n}\r\nhost->dma_len = dma_map_sg(chan->device->dev, data->sg, data->sg_len,\r\nhost->dma_dir);\r\ntx = dmaengine_prep_slave_sg(chan, data->sg, host->dma_len, direction,\r\nDMA_PREP_INTERRUPT);\r\nif (!tx) {\r\ndev_err(mmc_dev(host->mmc), "prep_slave_sg() failed\n");\r\nreturn;\r\n}\r\nif (!(data->flags & MMC_DATA_READ)) {\r\ntx->callback = pxamci_dma_irq;\r\ntx->callback_param = host;\r\n}\r\nhost->dma_cookie = dmaengine_submit(tx);\r\nif (!cpu_is_pxa27x() || data->flags & MMC_DATA_READ)\r\ndma_async_issue_pending(chan);\r\n}\r\nstatic void pxamci_start_cmd(struct pxamci_host *host, struct mmc_command *cmd, unsigned int cmdat)\r\n{\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdat |= CMDAT_BUSY;\r\n#define RSP_TYPE(x) ((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))\r\nswitch (RSP_TYPE(mmc_resp_type(cmd))) {\r\ncase RSP_TYPE(MMC_RSP_R1):\r\ncmdat |= CMDAT_RESP_SHORT;\r\nbreak;\r\ncase RSP_TYPE(MMC_RSP_R3):\r\ncmdat |= CMDAT_RESP_R3;\r\nbreak;\r\ncase RSP_TYPE(MMC_RSP_R2):\r\ncmdat |= CMDAT_RESP_R2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(cmd->opcode, host->base + MMC_CMD);\r\nwritel(cmd->arg >> 16, host->base + MMC_ARGH);\r\nwritel(cmd->arg & 0xffff, host->base + MMC_ARGL);\r\nwritel(cmdat, host->base + MMC_CMDAT);\r\nwritel(host->clkrt, host->base + MMC_CLKRT);\r\nwritel(START_CLOCK, host->base + MMC_STRPCL);\r\npxamci_enable_irq(host, END_CMD_RES);\r\n}\r\nstatic void pxamci_finish_request(struct pxamci_host *host, struct mmc_request *mrq)\r\n{\r\nhost->mrq = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic int pxamci_cmd_done(struct pxamci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint i;\r\nu32 v;\r\nif (!cmd)\r\nreturn 0;\r\nhost->cmd = NULL;\r\nv = readl(host->base + MMC_RES) & 0xffff;\r\nfor (i = 0; i < 4; i++) {\r\nu32 w1 = readl(host->base + MMC_RES) & 0xffff;\r\nu32 w2 = readl(host->base + MMC_RES) & 0xffff;\r\ncmd->resp[i] = v << 24 | w1 << 8 | w2 >> 8;\r\nv = w2;\r\n}\r\nif (stat & STAT_TIME_OUT_RESPONSE) {\r\ncmd->error = -ETIMEDOUT;\r\n} else if (stat & STAT_RES_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\r\nif (cpu_is_pxa27x() &&\r\n(cmd->flags & MMC_RSP_136 && cmd->resp[0] & 0x80000000))\r\npr_debug("ignoring CRC from command %d - *risky*\n", cmd->opcode);\r\nelse\r\ncmd->error = -EILSEQ;\r\n}\r\npxamci_disable_irq(host, END_CMD_RES);\r\nif (host->data && !cmd->error) {\r\npxamci_enable_irq(host, DATA_TRAN_DONE);\r\nif (cpu_is_pxa27x() && host->data->flags & MMC_DATA_WRITE)\r\ndma_async_issue_pending(host->dma_chan_tx);\r\n} else {\r\npxamci_finish_request(host, host->mrq);\r\n}\r\nreturn 1;\r\n}\r\nstatic int pxamci_data_done(struct pxamci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nstruct dma_chan *chan;\r\nif (!data)\r\nreturn 0;\r\nif (data->flags & MMC_DATA_READ)\r\nchan = host->dma_chan_rx;\r\nelse\r\nchan = host->dma_chan_tx;\r\ndma_unmap_sg(chan->device->dev,\r\ndata->sg, data->sg_len, host->dma_dir);\r\nif (stat & STAT_READ_TIME_OUT)\r\ndata->error = -ETIMEDOUT;\r\nelse if (stat & (STAT_CRC_READ_ERROR|STAT_CRC_WRITE_ERROR))\r\ndata->error = -EILSEQ;\r\nif (!data->error)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\nelse\r\ndata->bytes_xfered = 0;\r\npxamci_disable_irq(host, DATA_TRAN_DONE);\r\nhost->data = NULL;\r\nif (host->mrq->stop) {\r\npxamci_stop_clock(host);\r\npxamci_start_cmd(host, host->mrq->stop, host->cmdat);\r\n} else {\r\npxamci_finish_request(host, host->mrq);\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t pxamci_irq(int irq, void *devid)\r\n{\r\nstruct pxamci_host *host = devid;\r\nunsigned int ireg;\r\nint handled = 0;\r\nireg = readl(host->base + MMC_I_REG) & ~readl(host->base + MMC_I_MASK);\r\nif (ireg) {\r\nunsigned stat = readl(host->base + MMC_STAT);\r\npr_debug("PXAMCI: irq %08x stat %08x\n", ireg, stat);\r\nif (ireg & END_CMD_RES)\r\nhandled |= pxamci_cmd_done(host, stat);\r\nif (ireg & DATA_TRAN_DONE)\r\nhandled |= pxamci_data_done(host, stat);\r\nif (ireg & SDIO_INT) {\r\nmmc_signal_sdio_irq(host->mmc);\r\nhandled = 1;\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pxamci_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nunsigned int cmdat;\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = mrq;\r\npxamci_stop_clock(host);\r\ncmdat = host->cmdat;\r\nhost->cmdat &= ~CMDAT_INIT;\r\nif (mrq->data) {\r\npxamci_setup_data(host, mrq->data);\r\ncmdat &= ~CMDAT_BUSY;\r\ncmdat |= CMDAT_DATAEN | CMDAT_DMAEN;\r\nif (mrq->data->flags & MMC_DATA_WRITE)\r\ncmdat |= CMDAT_WRITE;\r\n}\r\npxamci_start_cmd(host, mrq->cmd, cmdat);\r\n}\r\nstatic int pxamci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nif (host->pdata && gpio_is_valid(host->pdata->gpio_card_ro))\r\nreturn mmc_gpio_get_ro(mmc);\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc_dev(mmc));\r\nreturn -ENOSYS;\r\n}\r\nstatic void pxamci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nif (ios->clock) {\r\nunsigned long rate = host->clkrate;\r\nunsigned int clk = rate / ios->clock;\r\nif (host->clkrt == CLKRT_OFF)\r\nclk_prepare_enable(host->clk);\r\nif (ios->clock == 26000000) {\r\nhost->clkrt = 7;\r\n} else {\r\nif (!clk)\r\nclk = 1;\r\nif (rate / clk > ios->clock)\r\nclk <<= 1;\r\nhost->clkrt = fls(clk) - 1;\r\n}\r\n} else {\r\npxamci_stop_clock(host);\r\nif (host->clkrt != CLKRT_OFF) {\r\nhost->clkrt = CLKRT_OFF;\r\nclk_disable_unprepare(host->clk);\r\n}\r\n}\r\nif (host->power_mode != ios->power_mode) {\r\nint ret;\r\nhost->power_mode = ios->power_mode;\r\nret = pxamci_set_power(host, ios->power_mode, ios->vdd);\r\nif (ret) {\r\ndev_err(mmc_dev(mmc), "unable to set power\n");\r\nreturn;\r\n}\r\nif (ios->power_mode == MMC_POWER_ON)\r\nhost->cmdat |= CMDAT_INIT;\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nhost->cmdat |= CMDAT_SD_4DAT;\r\nelse\r\nhost->cmdat &= ~CMDAT_SD_4DAT;\r\ndev_dbg(mmc_dev(mmc), "PXAMCI: clkrt = %x cmdat = %x\n",\r\nhost->clkrt, host->cmdat);\r\n}\r\nstatic void pxamci_enable_sdio_irq(struct mmc_host *host, int enable)\r\n{\r\nstruct pxamci_host *pxa_host = mmc_priv(host);\r\nif (enable)\r\npxamci_enable_irq(pxa_host, SDIO_INT);\r\nelse\r\npxamci_disable_irq(pxa_host, SDIO_INT);\r\n}\r\nstatic void pxamci_dma_irq(void *param)\r\n{\r\nstruct pxamci_host *host = param;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nstruct dma_chan *chan;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (!host->data)\r\ngoto out_unlock;\r\nif (host->data->flags & MMC_DATA_READ)\r\nchan = host->dma_chan_rx;\r\nelse\r\nchan = host->dma_chan_tx;\r\nstatus = dmaengine_tx_status(chan, host->dma_cookie, &state);\r\nif (likely(status == DMA_COMPLETE)) {\r\nwritel(BUF_PART_FULL, host->base + MMC_PRTBUF);\r\n} else {\r\npr_err("%s: DMA error on %s channel\n", mmc_hostname(host->mmc),\r\nhost->data->flags & MMC_DATA_READ ? "rx" : "tx");\r\nhost->data->error = -EIO;\r\npxamci_data_done(host, 0);\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic irqreturn_t pxamci_detect_irq(int irq, void *devid)\r\n{\r\nstruct pxamci_host *host = mmc_priv(devid);\r\nmmc_detect_change(devid, msecs_to_jiffies(host->pdata->detect_delay_ms));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxamci_of_init(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pxamci_platform_data *pdata;\r\nu32 tmp;\r\nif (!np)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->gpio_card_detect =\r\nof_get_named_gpio(np, "cd-gpios", 0);\r\npdata->gpio_card_ro =\r\nof_get_named_gpio(np, "wp-gpios", 0);\r\npdata->gpio_power =\r\nof_get_named_gpio(np, "pxa-mmc,gpio-power", 0);\r\nif (of_property_read_u32(np, "pxa-mmc,detect-delay-ms", &tmp) == 0)\r\npdata->detect_delay_ms = tmp;\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int pxamci_of_init(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pxamci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct pxamci_host *host = NULL;\r\nstruct resource *r, *dmarx, *dmatx;\r\nstruct pxad_param param_rx, param_tx;\r\nint ret, irq, gpio_cd = -1, gpio_ro = -1, gpio_power = -1;\r\ndma_cap_mask_t mask;\r\nret = pxamci_of_init(pdev);\r\nif (ret)\r\nreturn ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nmmc = mmc_alloc_host(sizeof(struct pxamci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmmc->ops = &pxamci_ops;\r\nmmc->max_segs = NR_SG;\r\nmmc->max_seg_size = PAGE_SIZE;\r\nmmc->max_blk_size = cpu_is_pxa25x() ? 1023 : 2048;\r\nmmc->max_blk_count = 65535;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->pdata = pdev->dev.platform_data;\r\nhost->clkrt = CLKRT_OFF;\r\nhost->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\nhost->clk = NULL;\r\ngoto out;\r\n}\r\nhost->clkrate = clk_get_rate(host->clk);\r\nmmc->f_min = (host->clkrate + 63) / 64;\r\nmmc->f_max = (mmc_has_26MHz()) ? 26000000 : host->clkrate;\r\npxamci_init_ocr(host);\r\nmmc->caps = 0;\r\nhost->cmdat = 0;\r\nif (!cpu_is_pxa25x()) {\r\nmmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nhost->cmdat |= CMDAT_SDIO_INT_EN;\r\nif (mmc_has_26MHz())\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED |\r\nMMC_CAP_SD_HIGHSPEED;\r\n}\r\nspin_lock_init(&host->lock);\r\nhost->res = r;\r\nhost->irq = irq;\r\nhost->imask = MMC_I_MASK_ALL;\r\nhost->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto out;\r\n}\r\npxamci_stop_clock(host);\r\nwritel(0, host->base + MMC_SPI);\r\nwritel(64, host->base + MMC_RESTO);\r\nwritel(host->imask, host->base + MMC_I_MASK);\r\nret = devm_request_irq(&pdev->dev, host->irq, pxamci_irq, 0,\r\nDRIVER_NAME, host);\r\nif (ret)\r\ngoto out;\r\nplatform_set_drvdata(pdev, mmc);\r\nif (!pdev->dev.of_node) {\r\ndmarx = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\ndmatx = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!dmarx || !dmatx) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nparam_rx.prio = PXAD_PRIO_LOWEST;\r\nparam_rx.drcmr = dmarx->start;\r\nparam_tx.prio = PXAD_PRIO_LOWEST;\r\nparam_tx.drcmr = dmatx->start;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->dma_chan_rx =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&param_rx, &pdev->dev, "rx");\r\nif (host->dma_chan_rx == NULL) {\r\ndev_err(&pdev->dev, "unable to request rx dma channel\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nhost->dma_chan_tx =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&param_tx, &pdev->dev, "tx");\r\nif (host->dma_chan_tx == NULL) {\r\ndev_err(&pdev->dev, "unable to request tx dma channel\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (host->pdata) {\r\ngpio_cd = host->pdata->gpio_card_detect;\r\ngpio_ro = host->pdata->gpio_card_ro;\r\ngpio_power = host->pdata->gpio_power;\r\n}\r\nif (gpio_is_valid(gpio_power)) {\r\nret = devm_gpio_request(&pdev->dev, gpio_power,\r\n"mmc card power");\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_power %d\n",\r\ngpio_power);\r\ngoto out;\r\n}\r\ngpio_direction_output(gpio_power,\r\nhost->pdata->gpio_power_invert);\r\n}\r\nif (gpio_is_valid(gpio_ro)) {\r\nret = mmc_gpio_request_ro(mmc, gpio_ro);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_ro %d\n",\r\ngpio_ro);\r\ngoto out;\r\n} else {\r\nmmc->caps2 |= host->pdata->gpio_card_ro_invert ?\r\n0 : MMC_CAP2_RO_ACTIVE_HIGH;\r\n}\r\n}\r\nif (gpio_is_valid(gpio_cd))\r\nret = mmc_gpio_request_cd(mmc, gpio_cd, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed requesting gpio_cd %d\n", gpio_cd);\r\ngoto out;\r\n}\r\nif (host->pdata && host->pdata->init)\r\nhost->pdata->init(&pdev->dev, pxamci_detect_irq, mmc);\r\nif (gpio_is_valid(gpio_power) && host->pdata->setpower)\r\ndev_warn(&pdev->dev, "gpio_power and setpower() both defined\n");\r\nif (gpio_is_valid(gpio_ro) && host->pdata->get_ro)\r\ndev_warn(&pdev->dev, "gpio_ro and get_ro() both defined\n");\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nout:\r\nif (host) {\r\nif (host->dma_chan_rx)\r\ndma_release_channel(host->dma_chan_rx);\r\nif (host->dma_chan_tx)\r\ndma_release_channel(host->dma_chan_tx);\r\n}\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int pxamci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nint gpio_cd = -1, gpio_ro = -1, gpio_power = -1;\r\nif (mmc) {\r\nstruct pxamci_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\nif (host->pdata) {\r\ngpio_cd = host->pdata->gpio_card_detect;\r\ngpio_ro = host->pdata->gpio_card_ro;\r\ngpio_power = host->pdata->gpio_power;\r\n}\r\nif (host->pdata && host->pdata->exit)\r\nhost->pdata->exit(&pdev->dev, mmc);\r\npxamci_stop_clock(host);\r\nwritel(TXFIFO_WR_REQ|RXFIFO_RD_REQ|CLK_IS_OFF|STOP_CMD|\r\nEND_CMD_RES|PRG_DONE|DATA_TRAN_DONE,\r\nhost->base + MMC_I_MASK);\r\ndmaengine_terminate_all(host->dma_chan_rx);\r\ndmaengine_terminate_all(host->dma_chan_tx);\r\ndma_release_channel(host->dma_chan_rx);\r\ndma_release_channel(host->dma_chan_tx);\r\nmmc_free_host(mmc);\r\n}\r\nreturn 0;\r\n}
