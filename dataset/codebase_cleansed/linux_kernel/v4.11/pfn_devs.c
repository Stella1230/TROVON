static void nd_pfn_release(struct device *dev)\r\n{\r\nstruct nd_region *nd_region = to_nd_region(dev->parent);\r\nstruct nd_pfn *nd_pfn = to_nd_pfn(dev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nnd_detach_ndns(&nd_pfn->dev, &nd_pfn->ndns);\r\nida_simple_remove(&nd_region->pfn_ida, nd_pfn->id);\r\nkfree(nd_pfn->uuid);\r\nkfree(nd_pfn);\r\n}\r\nbool is_nd_pfn(struct device *dev)\r\n{\r\nreturn dev ? dev->type == &nd_pfn_device_type : false;\r\n}\r\nstruct nd_pfn *to_nd_pfn(struct device *dev)\r\n{\r\nstruct nd_pfn *nd_pfn = container_of(dev, struct nd_pfn, dev);\r\nWARN_ON(!is_nd_pfn(dev));\r\nreturn nd_pfn;\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nswitch (nd_pfn->mode) {\r\ncase PFN_MODE_RAM:\r\nreturn sprintf(buf, "ram\n");\r\ncase PFN_MODE_PMEM:\r\nreturn sprintf(buf, "pmem\n");\r\ndefault:\r\nreturn sprintf(buf, "none\n");\r\n}\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc = 0;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nif (dev->driver)\r\nrc = -EBUSY;\r\nelse {\r\nsize_t n = len - 1;\r\nif (strncmp(buf, "pmem\n", n) == 0\r\n|| strncmp(buf, "pmem", n) == 0) {\r\nnd_pfn->mode = PFN_MODE_PMEM;\r\n} else if (strncmp(buf, "ram\n", n) == 0\r\n|| strncmp(buf, "ram", n) == 0)\r\nnd_pfn->mode = PFN_MODE_RAM;\r\nelse if (strncmp(buf, "none\n", n) == 0\r\n|| strncmp(buf, "none", n) == 0)\r\nnd_pfn->mode = PFN_MODE_NONE;\r\nelse\r\nrc = -EINVAL;\r\n}\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t align_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nreturn sprintf(buf, "%ld\n", nd_pfn->align);\r\n}\r\nstatic ssize_t __align_store(struct nd_pfn *nd_pfn, const char *buf)\r\n{\r\nunsigned long val;\r\nint rc;\r\nrc = kstrtoul(buf, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nif (!is_power_of_2(val) || val < PAGE_SIZE || val > SZ_1G)\r\nreturn -EINVAL;\r\nif (nd_pfn->dev.driver)\r\nreturn -EBUSY;\r\nelse\r\nnd_pfn->align = val;\r\nreturn 0;\r\n}\r\nstatic ssize_t align_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nrc = __align_store(nd_pfn, buf);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t uuid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nif (nd_pfn->uuid)\r\nreturn sprintf(buf, "%pUb\n", nd_pfn->uuid);\r\nreturn sprintf(buf, "\n");\r\n}\r\nstatic ssize_t uuid_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nrc = nd_uuid_store(dev, &nd_pfn->uuid, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\ndevice_unlock(dev);\r\nreturn rc ? rc : len;\r\n}\r\nstatic ssize_t namespace_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\nnvdimm_bus_lock(dev);\r\nrc = sprintf(buf, "%s\n", nd_pfn->ndns\r\n? dev_name(&nd_pfn->ndns->dev) : "");\r\nnvdimm_bus_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t namespace_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nnvdimm_bus_lock(dev);\r\nrc = nd_namespace_store(dev, &nd_pfn->ndns, buf, len);\r\ndev_dbg(dev, "%s: result: %zd wrote: %s%s", __func__,\r\nrc, buf, buf[len - 1] == '\n' ? "" : "\n");\r\nnvdimm_bus_unlock(dev);\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t resource_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nif (dev->driver) {\r\nstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\r\nu64 offset = __le64_to_cpu(pfn_sb->dataoff);\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\r\nstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\r\nrc = sprintf(buf, "%#llx\n", (unsigned long long) nsio->res.start\r\n+ start_pad + offset);\r\n} else {\r\nrc = -ENXIO;\r\n}\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstatic ssize_t size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct nd_pfn *nd_pfn = to_nd_pfn_safe(dev);\r\nssize_t rc;\r\ndevice_lock(dev);\r\nif (dev->driver) {\r\nstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\r\nu64 offset = __le64_to_cpu(pfn_sb->dataoff);\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\r\nu32 end_trunc = __le32_to_cpu(pfn_sb->end_trunc);\r\nstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\r\nrc = sprintf(buf, "%llu\n", (unsigned long long)\r\nresource_size(&nsio->res) - start_pad\r\n- end_trunc - offset);\r\n} else {\r\nrc = -ENXIO;\r\n}\r\ndevice_unlock(dev);\r\nreturn rc;\r\n}\r\nstruct device *nd_pfn_devinit(struct nd_pfn *nd_pfn,\r\nstruct nd_namespace_common *ndns)\r\n{\r\nstruct device *dev = &nd_pfn->dev;\r\nif (!nd_pfn)\r\nreturn NULL;\r\nnd_pfn->mode = PFN_MODE_NONE;\r\nnd_pfn->align = HPAGE_SIZE;\r\ndev = &nd_pfn->dev;\r\ndevice_initialize(&nd_pfn->dev);\r\nif (ndns && !__nd_attach_ndns(&nd_pfn->dev, ndns, &nd_pfn->ndns)) {\r\ndev_dbg(&ndns->dev, "%s failed, already claimed by %s\n",\r\n__func__, dev_name(ndns->claim));\r\nput_device(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic struct nd_pfn *nd_pfn_alloc(struct nd_region *nd_region)\r\n{\r\nstruct nd_pfn *nd_pfn;\r\nstruct device *dev;\r\nnd_pfn = kzalloc(sizeof(*nd_pfn), GFP_KERNEL);\r\nif (!nd_pfn)\r\nreturn NULL;\r\nnd_pfn->id = ida_simple_get(&nd_region->pfn_ida, 0, 0, GFP_KERNEL);\r\nif (nd_pfn->id < 0) {\r\nkfree(nd_pfn);\r\nreturn NULL;\r\n}\r\ndev = &nd_pfn->dev;\r\ndev_set_name(dev, "pfn%d.%d", nd_region->id, nd_pfn->id);\r\ndev->groups = nd_pfn_attribute_groups;\r\ndev->type = &nd_pfn_device_type;\r\ndev->parent = &nd_region->dev;\r\nreturn nd_pfn;\r\n}\r\nstruct device *nd_pfn_create(struct nd_region *nd_region)\r\n{\r\nstruct nd_pfn *nd_pfn;\r\nstruct device *dev;\r\nif (!is_nd_pmem(&nd_region->dev))\r\nreturn NULL;\r\nnd_pfn = nd_pfn_alloc(nd_region);\r\ndev = nd_pfn_devinit(nd_pfn, NULL);\r\n__nd_device_register(dev);\r\nreturn dev;\r\n}\r\nint nd_pfn_validate(struct nd_pfn *nd_pfn, const char *sig)\r\n{\r\nu64 checksum, offset;\r\nunsigned long align;\r\nenum nd_pfn_mode mode;\r\nstruct nd_namespace_io *nsio;\r\nstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nconst u8 *parent_uuid = nd_dev_to_uuid(&ndns->dev);\r\nif (!pfn_sb || !ndns)\r\nreturn -ENODEV;\r\nif (!is_nd_pmem(nd_pfn->dev.parent))\r\nreturn -ENODEV;\r\nif (nvdimm_read_bytes(ndns, SZ_4K, pfn_sb, sizeof(*pfn_sb)))\r\nreturn -ENXIO;\r\nif (memcmp(pfn_sb->signature, sig, PFN_SIG_LEN) != 0)\r\nreturn -ENODEV;\r\nchecksum = le64_to_cpu(pfn_sb->checksum);\r\npfn_sb->checksum = 0;\r\nif (checksum != nd_sb_checksum((struct nd_gen_sb *) pfn_sb))\r\nreturn -ENODEV;\r\npfn_sb->checksum = cpu_to_le64(checksum);\r\nif (memcmp(pfn_sb->parent_uuid, parent_uuid, 16) != 0)\r\nreturn -ENODEV;\r\nif (__le16_to_cpu(pfn_sb->version_minor) < 1) {\r\npfn_sb->start_pad = 0;\r\npfn_sb->end_trunc = 0;\r\n}\r\nif (__le16_to_cpu(pfn_sb->version_minor) < 2)\r\npfn_sb->align = 0;\r\nswitch (le32_to_cpu(pfn_sb->mode)) {\r\ncase PFN_MODE_RAM:\r\ncase PFN_MODE_PMEM:\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nalign = le32_to_cpu(pfn_sb->align);\r\noffset = le64_to_cpu(pfn_sb->dataoff);\r\nif (align == 0)\r\nalign = 1UL << ilog2(offset);\r\nmode = le32_to_cpu(pfn_sb->mode);\r\nif (!nd_pfn->uuid) {\r\nnd_pfn->uuid = kmemdup(pfn_sb->uuid, 16, GFP_KERNEL);\r\nif (!nd_pfn->uuid)\r\nreturn -ENOMEM;\r\nnd_pfn->align = align;\r\nnd_pfn->mode = mode;\r\n} else {\r\nif (memcmp(nd_pfn->uuid, pfn_sb->uuid, 16) != 0)\r\nreturn -ENODEV;\r\nif (nd_pfn->align != align || nd_pfn->mode != mode) {\r\ndev_err(&nd_pfn->dev,\r\n"init failed, settings mismatch\n");\r\ndev_dbg(&nd_pfn->dev, "align: %lx:%lx mode: %d:%d\n",\r\nnd_pfn->align, align, nd_pfn->mode,\r\nmode);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (align > nvdimm_namespace_capacity(ndns)) {\r\ndev_err(&nd_pfn->dev, "alignment: %lx exceeds capacity %llx\n",\r\nalign, nvdimm_namespace_capacity(ndns));\r\nreturn -EINVAL;\r\n}\r\nnsio = to_nd_namespace_io(&ndns->dev);\r\nif (offset >= resource_size(&nsio->res)) {\r\ndev_err(&nd_pfn->dev, "pfn array size exceeds capacity of %s\n",\r\ndev_name(&ndns->dev));\r\nreturn -EBUSY;\r\n}\r\nif ((align && !IS_ALIGNED(offset, align))\r\n|| !IS_ALIGNED(offset, PAGE_SIZE)) {\r\ndev_err(&nd_pfn->dev,\r\n"bad offset: %#llx dax disabled align: %#lx\n",\r\noffset, align);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nint nd_pfn_probe(struct device *dev, struct nd_namespace_common *ndns)\r\n{\r\nint rc;\r\nstruct nd_pfn *nd_pfn;\r\nstruct device *pfn_dev;\r\nstruct nd_pfn_sb *pfn_sb;\r\nstruct nd_region *nd_region = to_nd_region(ndns->dev.parent);\r\nif (ndns->force_raw)\r\nreturn -ENODEV;\r\nnvdimm_bus_lock(&ndns->dev);\r\nnd_pfn = nd_pfn_alloc(nd_region);\r\npfn_dev = nd_pfn_devinit(nd_pfn, ndns);\r\nnvdimm_bus_unlock(&ndns->dev);\r\nif (!pfn_dev)\r\nreturn -ENOMEM;\r\npfn_sb = devm_kzalloc(dev, sizeof(*pfn_sb), GFP_KERNEL);\r\nnd_pfn = to_nd_pfn(pfn_dev);\r\nnd_pfn->pfn_sb = pfn_sb;\r\nrc = nd_pfn_validate(nd_pfn, PFN_SIG);\r\ndev_dbg(dev, "%s: pfn: %s\n", __func__,\r\nrc == 0 ? dev_name(pfn_dev) : "<none>");\r\nif (rc < 0) {\r\n__nd_detach_ndns(pfn_dev, &nd_pfn->ndns);\r\nput_device(pfn_dev);\r\n} else\r\n__nd_device_register(pfn_dev);\r\nreturn rc;\r\n}\r\nstatic unsigned long init_altmap_base(resource_size_t base)\r\n{\r\nunsigned long base_pfn = PHYS_PFN(base);\r\nreturn PFN_SECTION_ALIGN_DOWN(base_pfn);\r\n}\r\nstatic unsigned long init_altmap_reserve(resource_size_t base)\r\n{\r\nunsigned long reserve = PHYS_PFN(SZ_8K);\r\nunsigned long base_pfn = PHYS_PFN(base);\r\nreserve += base_pfn - PFN_SECTION_ALIGN_DOWN(base_pfn);\r\nreturn reserve;\r\n}\r\nstatic struct vmem_altmap *__nvdimm_setup_pfn(struct nd_pfn *nd_pfn,\r\nstruct resource *res, struct vmem_altmap *altmap)\r\n{\r\nstruct nd_pfn_sb *pfn_sb = nd_pfn->pfn_sb;\r\nu64 offset = le64_to_cpu(pfn_sb->dataoff);\r\nu32 start_pad = __le32_to_cpu(pfn_sb->start_pad);\r\nu32 end_trunc = __le32_to_cpu(pfn_sb->end_trunc);\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nstruct nd_namespace_io *nsio = to_nd_namespace_io(&ndns->dev);\r\nresource_size_t base = nsio->res.start + start_pad;\r\nstruct vmem_altmap __altmap = {\r\n.base_pfn = init_altmap_base(base),\r\n.reserve = init_altmap_reserve(base),\r\n};\r\nmemcpy(res, &nsio->res, sizeof(*res));\r\nres->start += start_pad;\r\nres->end -= end_trunc;\r\nif (nd_pfn->mode == PFN_MODE_RAM) {\r\nif (offset < SZ_8K)\r\nreturn ERR_PTR(-EINVAL);\r\nnd_pfn->npfns = le64_to_cpu(pfn_sb->npfns);\r\naltmap = NULL;\r\n} else if (nd_pfn->mode == PFN_MODE_PMEM) {\r\nnd_pfn->npfns = (resource_size(res) - offset) / PAGE_SIZE;\r\nif (le64_to_cpu(nd_pfn->pfn_sb->npfns) > nd_pfn->npfns)\r\ndev_info(&nd_pfn->dev,\r\n"number of pfns truncated from %lld to %ld\n",\r\nle64_to_cpu(nd_pfn->pfn_sb->npfns),\r\nnd_pfn->npfns);\r\nmemcpy(altmap, &__altmap, sizeof(*altmap));\r\naltmap->free = PHYS_PFN(offset - SZ_8K);\r\naltmap->alloc = 0;\r\n} else\r\nreturn ERR_PTR(-ENXIO);\r\nreturn altmap;\r\n}\r\nstatic int nd_pfn_init(struct nd_pfn *nd_pfn)\r\n{\r\nu32 dax_label_reserve = is_nd_dax(&nd_pfn->dev) ? SZ_128K : 0;\r\nstruct nd_namespace_common *ndns = nd_pfn->ndns;\r\nu32 start_pad = 0, end_trunc = 0;\r\nresource_size_t start, size;\r\nstruct nd_namespace_io *nsio;\r\nstruct nd_region *nd_region;\r\nstruct nd_pfn_sb *pfn_sb;\r\nunsigned long npfns;\r\nphys_addr_t offset;\r\nconst char *sig;\r\nu64 checksum;\r\nint rc;\r\npfn_sb = devm_kzalloc(&nd_pfn->dev, sizeof(*pfn_sb), GFP_KERNEL);\r\nif (!pfn_sb)\r\nreturn -ENOMEM;\r\nnd_pfn->pfn_sb = pfn_sb;\r\nif (is_nd_dax(&nd_pfn->dev))\r\nsig = DAX_SIG;\r\nelse\r\nsig = PFN_SIG;\r\nrc = nd_pfn_validate(nd_pfn, sig);\r\nif (rc != -ENODEV)\r\nreturn rc;\r\n;\r\nnd_region = to_nd_region(nd_pfn->dev.parent);\r\nif (nd_region->ro) {\r\ndev_info(&nd_pfn->dev,\r\n"%s is read-only, unable to init metadata\n",\r\ndev_name(&nd_region->dev));\r\nreturn -ENXIO;\r\n}\r\nmemset(pfn_sb, 0, sizeof(*pfn_sb));\r\nnsio = to_nd_namespace_io(&ndns->dev);\r\nstart = PHYS_SECTION_ALIGN_DOWN(nsio->res.start);\r\nsize = resource_size(&nsio->res);\r\nif (region_intersects(start, size, IORESOURCE_SYSTEM_RAM,\r\nIORES_DESC_NONE) == REGION_MIXED) {\r\nstart = nsio->res.start;\r\nstart_pad = PHYS_SECTION_ALIGN_UP(start) - start;\r\n}\r\nstart = nsio->res.start;\r\nsize = PHYS_SECTION_ALIGN_UP(start + size) - start;\r\nif (region_intersects(start, size, IORESOURCE_SYSTEM_RAM,\r\nIORES_DESC_NONE) == REGION_MIXED) {\r\nsize = resource_size(&nsio->res);\r\nend_trunc = start + size - PHYS_SECTION_ALIGN_DOWN(start + size);\r\n}\r\nif (start_pad + end_trunc)\r\ndev_info(&nd_pfn->dev, "%s section collision, truncate %d bytes\n",\r\ndev_name(&ndns->dev), start_pad + end_trunc);\r\nstart += start_pad;\r\nsize = resource_size(&nsio->res);\r\nnpfns = (size - start_pad - end_trunc - SZ_8K) / SZ_4K;\r\nif (nd_pfn->mode == PFN_MODE_PMEM) {\r\noffset = ALIGN(start + SZ_8K + 64 * npfns + dax_label_reserve,\r\nmax(nd_pfn->align, HPAGE_SIZE)) - start;\r\n} else if (nd_pfn->mode == PFN_MODE_RAM)\r\noffset = ALIGN(start + SZ_8K + dax_label_reserve,\r\nnd_pfn->align) - start;\r\nelse\r\nreturn -ENXIO;\r\nif (offset + start_pad + end_trunc >= size) {\r\ndev_err(&nd_pfn->dev, "%s unable to satisfy requested alignment\n",\r\ndev_name(&ndns->dev));\r\nreturn -ENXIO;\r\n}\r\nnpfns = (size - offset - start_pad - end_trunc) / SZ_4K;\r\npfn_sb->mode = cpu_to_le32(nd_pfn->mode);\r\npfn_sb->dataoff = cpu_to_le64(offset);\r\npfn_sb->npfns = cpu_to_le64(npfns);\r\nmemcpy(pfn_sb->signature, sig, PFN_SIG_LEN);\r\nmemcpy(pfn_sb->uuid, nd_pfn->uuid, 16);\r\nmemcpy(pfn_sb->parent_uuid, nd_dev_to_uuid(&ndns->dev), 16);\r\npfn_sb->version_major = cpu_to_le16(1);\r\npfn_sb->version_minor = cpu_to_le16(2);\r\npfn_sb->start_pad = cpu_to_le32(start_pad);\r\npfn_sb->end_trunc = cpu_to_le32(end_trunc);\r\npfn_sb->align = cpu_to_le32(nd_pfn->align);\r\nchecksum = nd_sb_checksum((struct nd_gen_sb *) pfn_sb);\r\npfn_sb->checksum = cpu_to_le64(checksum);\r\nreturn nvdimm_write_bytes(ndns, SZ_4K, pfn_sb, sizeof(*pfn_sb));\r\n}\r\nstruct vmem_altmap *nvdimm_setup_pfn(struct nd_pfn *nd_pfn,\r\nstruct resource *res, struct vmem_altmap *altmap)\r\n{\r\nint rc;\r\nif (!nd_pfn->uuid || !nd_pfn->ndns)\r\nreturn ERR_PTR(-ENODEV);\r\nrc = nd_pfn_init(nd_pfn);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn __nvdimm_setup_pfn(nd_pfn, res, altmap);\r\n}
