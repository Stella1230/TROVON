__be32 nfs4_callback_getattr(struct cb_getattrargs *args,\r\nstruct cb_getattrres *res,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct nfs_inode *nfsi;\r\nstruct inode *inode;\r\nres->status = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\nres->bitmap[0] = res->bitmap[1] = 0;\r\nres->status = htonl(NFS4ERR_BADHANDLE);\r\ndprintk_rcu("NFS: GETATTR callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\ninode = nfs_delegation_find_inode(cps->clp, &args->fh);\r\nif (inode == NULL) {\r\ntrace_nfs4_cb_getattr(cps->clp, &args->fh, NULL,\r\n-ntohl(res->status));\r\ngoto out;\r\n}\r\nnfsi = NFS_I(inode);\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(nfsi->delegation);\r\nif (delegation == NULL || (delegation->type & FMODE_WRITE) == 0)\r\ngoto out_iput;\r\nres->size = i_size_read(inode);\r\nres->change_attr = delegation->change_attr;\r\nif (nfsi->nrequests != 0)\r\nres->change_attr++;\r\nres->ctime = inode->i_ctime;\r\nres->mtime = inode->i_mtime;\r\nres->bitmap[0] = (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE) &\r\nargs->bitmap[0];\r\nres->bitmap[1] = (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY) &\r\nargs->bitmap[1];\r\nres->status = 0;\r\nout_iput:\r\nrcu_read_unlock();\r\ntrace_nfs4_cb_getattr(cps->clp, &args->fh, inode, -ntohl(res->status));\r\niput(inode);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(res->status));\r\nreturn res->status;\r\n}\r\n__be32 nfs4_callback_recall(struct cb_recallargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct inode *inode;\r\n__be32 res;\r\nres = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: RECALL callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nres = htonl(NFS4ERR_BADHANDLE);\r\ninode = nfs_delegation_find_inode(cps->clp, &args->fh);\r\nif (inode == NULL) {\r\ntrace_nfs4_cb_recall(cps->clp, &args->fh, NULL,\r\n&args->stateid, -ntohl(res));\r\ngoto out;\r\n}\r\nswitch (nfs_async_inode_return_delegation(inode, &args->stateid)) {\r\ncase 0:\r\nres = 0;\r\nbreak;\r\ncase -ENOENT:\r\nres = htonl(NFS4ERR_BAD_STATEID);\r\nbreak;\r\ndefault:\r\nres = htonl(NFS4ERR_RESOURCE);\r\n}\r\ntrace_nfs4_cb_recall(cps->clp, &args->fh, inode,\r\n&args->stateid, -ntohl(res));\r\niput(inode);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(res));\r\nreturn res;\r\n}\r\nstatic struct inode *nfs_layout_find_inode_by_stateid(struct nfs_client *clp,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct nfs_server *server;\r\nstruct inode *inode;\r\nstruct pnfs_layout_hdr *lo;\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry(lo, &server->layouts, plh_layouts) {\r\nif (stateid != NULL &&\r\n!nfs4_stateid_match_other(stateid, &lo->plh_stateid))\r\ncontinue;\r\ninode = igrab(lo->plh_inode);\r\nif (!inode)\r\ncontinue;\r\nif (!nfs_sb_active(inode->i_sb)) {\r\nrcu_read_lock();\r\nspin_unlock(&clp->cl_lock);\r\niput(inode);\r\nspin_lock(&clp->cl_lock);\r\ngoto restart;\r\n}\r\nreturn inode;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct inode *nfs_layout_find_inode_by_fh(struct nfs_client *clp,\r\nconst struct nfs_fh *fh)\r\n{\r\nstruct nfs_server *server;\r\nstruct nfs_inode *nfsi;\r\nstruct inode *inode;\r\nstruct pnfs_layout_hdr *lo;\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry(lo, &server->layouts, plh_layouts) {\r\nnfsi = NFS_I(lo->plh_inode);\r\nif (nfs_compare_fh(fh, &nfsi->fh))\r\ncontinue;\r\nif (nfsi->layout != lo)\r\ncontinue;\r\ninode = igrab(lo->plh_inode);\r\nif (!inode)\r\ncontinue;\r\nif (!nfs_sb_active(inode->i_sb)) {\r\nrcu_read_lock();\r\nspin_unlock(&clp->cl_lock);\r\niput(inode);\r\nspin_lock(&clp->cl_lock);\r\ngoto restart;\r\n}\r\nreturn inode;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct inode *nfs_layout_find_inode(struct nfs_client *clp,\r\nconst struct nfs_fh *fh,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct inode *inode;\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\ninode = nfs_layout_find_inode_by_stateid(clp, stateid);\r\nif (!inode)\r\ninode = nfs_layout_find_inode_by_fh(clp, fh);\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nreturn inode;\r\n}\r\nstatic u32 pnfs_check_callback_stateid(struct pnfs_layout_hdr *lo,\r\nconst nfs4_stateid *new)\r\n{\r\nu32 oldseq, newseq;\r\nif (!pnfs_layout_is_valid(lo))\r\nreturn NFS4ERR_DELAY;\r\nif (!nfs4_stateid_match_other(&lo->plh_stateid, new))\r\nreturn NFS4ERR_BAD_STATEID;\r\nnewseq = be32_to_cpu(new->seqid);\r\nif (test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags) &&\r\nlo->plh_return_seq != 0) {\r\nif (newseq < lo->plh_return_seq)\r\nreturn NFS4ERR_OLD_STATEID;\r\nif (newseq > lo->plh_return_seq)\r\nreturn NFS4ERR_DELAY;\r\ngoto out;\r\n}\r\noldseq = be32_to_cpu(lo->plh_stateid.seqid);\r\nif (newseq > oldseq + 1)\r\nreturn NFS4ERR_DELAY;\r\nif (newseq <= oldseq)\r\nreturn NFS4ERR_OLD_STATEID;\r\nout:\r\nreturn NFS_OK;\r\n}\r\nstatic u32 initiate_file_draining(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nstruct inode *ino;\r\nstruct pnfs_layout_hdr *lo;\r\nu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\r\nLIST_HEAD(free_me_list);\r\nino = nfs_layout_find_inode(clp, &args->cbl_fh, &args->cbl_stateid);\r\nif (!ino)\r\ngoto out;\r\npnfs_layoutcommit_inode(ino, false);\r\nspin_lock(&ino->i_lock);\r\nlo = NFS_I(ino)->layout;\r\nif (!lo) {\r\nspin_unlock(&ino->i_lock);\r\ngoto out;\r\n}\r\npnfs_get_layout_hdr(lo);\r\nrv = pnfs_check_callback_stateid(lo, &args->cbl_stateid);\r\nif (rv != NFS_OK)\r\ngoto unlock;\r\npnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\r\nif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\r\nrv = NFS4ERR_DELAY;\r\ngoto unlock;\r\n}\r\nif (pnfs_mark_matching_lsegs_return(lo, &free_me_list,\r\n&args->cbl_range,\r\nbe32_to_cpu(args->cbl_stateid.seqid))) {\r\nrv = NFS4_OK;\r\ngoto unlock;\r\n}\r\nrv = NFS4ERR_NOMATCHING_LAYOUT;\r\nif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\r\nNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,\r\n&args->cbl_range);\r\n}\r\nunlock:\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_lseg_list(&free_me_list);\r\nnfs_commit_inode(ino, 0);\r\npnfs_put_layout_hdr(lo);\r\nout:\r\ntrace_nfs4_cb_layoutrecall_file(clp, &args->cbl_fh, ino,\r\n&args->cbl_stateid, -rv);\r\nnfs_iput_and_deactive(ino);\r\nreturn rv;\r\n}\r\nstatic u32 initiate_bulk_draining(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nint stat;\r\nif (args->cbl_recall_type == RETURN_FSID)\r\nstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\r\nelse\r\nstat = pnfs_destroy_layouts_byclid(clp, true);\r\nif (stat != 0)\r\nreturn NFS4ERR_DELAY;\r\nreturn NFS4ERR_NOMATCHING_LAYOUT;\r\n}\r\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nu32 res;\r\ndprintk("%s enter, type=%i\n", __func__, args->cbl_recall_type);\r\nif (args->cbl_recall_type == RETURN_FILE)\r\nres = initiate_file_draining(clp, args);\r\nelse\r\nres = initiate_bulk_draining(clp, args);\r\ndprintk("%s returning %i\n", __func__, res);\r\nreturn res;\r\n}\r\n__be32 nfs4_callback_layoutrecall(struct cb_layoutrecallargs *args,\r\nvoid *dummy, struct cb_process_state *cps)\r\n{\r\nu32 res;\r\ndprintk("%s: -->\n", __func__);\r\nif (cps->clp)\r\nres = do_callback_layoutrecall(cps->clp, args);\r\nelse\r\nres = NFS4ERR_OP_NOT_IN_SESSION;\r\ndprintk("%s: exit with status = %d\n", __func__, res);\r\nreturn cpu_to_be32(res);\r\n}\r\nstatic void pnfs_recall_all_layouts(struct nfs_client *clp)\r\n{\r\nstruct cb_layoutrecallargs args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.cbl_recall_type = RETURN_ALL;\r\ndo_callback_layoutrecall(clp, &args);\r\n}\r\n__be32 nfs4_callback_devicenotify(struct cb_devicenotifyargs *args,\r\nvoid *dummy, struct cb_process_state *cps)\r\n{\r\nint i;\r\n__be32 res = 0;\r\nstruct nfs_client *clp = cps->clp;\r\nstruct nfs_server *server = NULL;\r\ndprintk("%s: -->\n", __func__);\r\nif (!clp) {\r\nres = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\r\ngoto out;\r\n}\r\nfor (i = 0; i < args->ndevs; i++) {\r\nstruct cb_devicenotifyitem *dev = &args->devs[i];\r\nif (!server ||\r\nserver->pnfs_curr_ld->id != dev->cbd_layout_type) {\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nif (server->pnfs_curr_ld &&\r\nserver->pnfs_curr_ld->id == dev->cbd_layout_type) {\r\nrcu_read_unlock();\r\ngoto found;\r\n}\r\nrcu_read_unlock();\r\ndprintk("%s: layout type %u not found\n",\r\n__func__, dev->cbd_layout_type);\r\ncontinue;\r\n}\r\nfound:\r\nnfs4_delete_deviceid(server->pnfs_curr_ld, clp, &dev->cbd_dev_id);\r\n}\r\nout:\r\nkfree(args->devs);\r\ndprintk("%s: exit with status = %u\n",\r\n__func__, be32_to_cpu(res));\r\nreturn res;\r\n}\r\nstatic __be32\r\nvalidate_seqid(const struct nfs4_slot_table *tbl, const struct nfs4_slot *slot,\r\nconst struct cb_sequenceargs * args)\r\n{\r\ndprintk("%s enter. slotid %u seqid %u, slot table seqid: %u\n",\r\n__func__, args->csa_slotid, args->csa_sequenceid, slot->seq_nr);\r\nif (args->csa_slotid > tbl->server_highest_slotid)\r\nreturn htonl(NFS4ERR_BADSLOT);\r\nif (args->csa_sequenceid == slot->seq_nr) {\r\ndprintk("%s seqid %u is a replay\n",\r\n__func__, args->csa_sequenceid);\r\nif (nfs4_test_locked_slot(tbl, slot->slot_nr))\r\nreturn htonl(NFS4ERR_DELAY);\r\nif (args->csa_cachethis == 0)\r\nreturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\r\nreturn htonl(NFS4ERR_SEQ_FALSE_RETRY);\r\n}\r\nif (unlikely(slot->seq_nr == 0xFFFFFFFFU)) {\r\nif (args->csa_sequenceid == 1)\r\nreturn htonl(NFS4_OK);\r\n} else if (likely(args->csa_sequenceid == slot->seq_nr + 1))\r\nreturn htonl(NFS4_OK);\r\nreturn htonl(NFS4ERR_SEQ_MISORDERED);\r\n}\r\nstatic bool referring_call_exists(struct nfs_client *clp,\r\nuint32_t nrclists,\r\nstruct referring_call_list *rclists)\r\n{\r\nbool status = 0;\r\nint i, j;\r\nstruct nfs4_session *session;\r\nstruct nfs4_slot_table *tbl;\r\nstruct referring_call_list *rclist;\r\nstruct referring_call *ref;\r\nsession = clp->cl_session;\r\ntbl = &session->fc_slot_table;\r\nfor (i = 0; i < nrclists; i++) {\r\nrclist = &rclists[i];\r\nif (memcmp(session->sess_id.data,\r\nrclist->rcl_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN) != 0)\r\ncontinue;\r\nfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\r\nref = &rclist->rcl_refcalls[j];\r\ndprintk("%s: sessionid %x:%x:%x:%x sequenceid %u "\r\n"slotid %u\n", __func__,\r\n((u32 *)&rclist->rcl_sessionid.data)[0],\r\n((u32 *)&rclist->rcl_sessionid.data)[1],\r\n((u32 *)&rclist->rcl_sessionid.data)[2],\r\n((u32 *)&rclist->rcl_sessionid.data)[3],\r\nref->rc_sequenceid, ref->rc_slotid);\r\nstatus = nfs4_slot_wait_on_seqid(tbl, ref->rc_slotid,\r\nref->rc_sequenceid, HZ >> 1) < 0;\r\nif (status)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn status;\r\n}\r\n__be32 nfs4_callback_sequence(struct cb_sequenceargs *args,\r\nstruct cb_sequenceres *res,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs4_slot_table *tbl;\r\nstruct nfs4_slot *slot;\r\nstruct nfs_client *clp;\r\nint i;\r\n__be32 status = htonl(NFS4ERR_BADSESSION);\r\nclp = nfs4_find_client_sessionid(cps->net, args->csa_addr,\r\n&args->csa_sessionid, cps->minorversion);\r\nif (clp == NULL)\r\ngoto out;\r\nif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\r\ngoto out;\r\ntbl = &clp->cl_session->bc_slot_table;\r\nmemcpy(&res->csr_sessionid, &args->csa_sessionid,\r\nsizeof(res->csr_sessionid));\r\nres->csr_sequenceid = args->csa_sequenceid;\r\nres->csr_slotid = args->csa_slotid;\r\nspin_lock(&tbl->slot_tbl_lock);\r\nif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\r\nstatus = htonl(NFS4ERR_DELAY);\r\nif (test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state))\r\nstatus = htonl(NFS4ERR_BADSESSION);\r\ngoto out_unlock;\r\n}\r\nstatus = htonl(NFS4ERR_BADSLOT);\r\nslot = nfs4_lookup_slot(tbl, args->csa_slotid);\r\nif (IS_ERR(slot))\r\ngoto out_unlock;\r\nres->csr_highestslotid = tbl->server_highest_slotid;\r\nres->csr_target_highestslotid = tbl->target_highest_slotid;\r\nstatus = validate_seqid(tbl, slot, args);\r\nif (status)\r\ngoto out_unlock;\r\nif (!nfs4_try_to_lock_slot(tbl, slot)) {\r\nstatus = htonl(NFS4ERR_DELAY);\r\ngoto out_unlock;\r\n}\r\ncps->slot = slot;\r\nif (args->csa_cachethis != 0) {\r\nstatus = htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\r\ngoto out_unlock;\r\n}\r\nif (referring_call_exists(clp, args->csa_nrclists, args->csa_rclists)) {\r\nstatus = htonl(NFS4ERR_DELAY);\r\ngoto out_unlock;\r\n}\r\nslot->seq_nr = args->csa_sequenceid;\r\nout_unlock:\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nout:\r\ncps->clp = clp;\r\nfor (i = 0; i < args->csa_nrclists; i++)\r\nkfree(args->csa_rclists[i].rcl_refcalls);\r\nkfree(args->csa_rclists);\r\nif (status == htonl(NFS4ERR_RETRY_UNCACHED_REP)) {\r\ncps->drc_status = status;\r\nstatus = 0;\r\n} else\r\nres->csr_status = status;\r\ntrace_nfs4_cb_sequence(args, res, status);\r\ndprintk("%s: exit with status = %d res->csr_status %d\n", __func__,\r\nntohl(status), ntohl(res->csr_status));\r\nreturn status;\r\n}\r\nstatic bool\r\nvalidate_bitmap_values(unsigned long mask)\r\n{\r\nreturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\r\n}\r\n__be32 nfs4_callback_recallany(struct cb_recallanyargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\n__be32 status;\r\nfmode_t flags = 0;\r\nstatus = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: RECALL_ANY callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nstatus = cpu_to_be32(NFS4ERR_INVAL);\r\nif (!validate_bitmap_values(args->craa_type_mask))\r\ngoto out;\r\nstatus = cpu_to_be32(NFS4_OK);\r\nif (test_bit(RCA4_TYPE_MASK_RDATA_DLG, (const unsigned long *)\r\n&args->craa_type_mask))\r\nflags = FMODE_READ;\r\nif (test_bit(RCA4_TYPE_MASK_WDATA_DLG, (const unsigned long *)\r\n&args->craa_type_mask))\r\nflags |= FMODE_WRITE;\r\nif (test_bit(RCA4_TYPE_MASK_FILE_LAYOUT, (const unsigned long *)\r\n&args->craa_type_mask))\r\npnfs_recall_all_layouts(cps->clp);\r\nif (flags)\r\nnfs_expire_unused_delegation_types(cps->clp, flags);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\n__be32 nfs4_callback_recallslot(struct cb_recallslotargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs4_slot_table *fc_tbl;\r\n__be32 status;\r\nstatus = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: CB_RECALL_SLOT request from %s target highest slotid %u\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR),\r\nargs->crsa_target_highest_slotid);\r\nfc_tbl = &cps->clp->cl_session->fc_slot_table;\r\nstatus = htonl(NFS4_OK);\r\nnfs41_set_target_slotid(fc_tbl, args->crsa_target_highest_slotid);\r\nnfs41_notify_server(cps->clp);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\n__be32 nfs4_callback_notify_lock(struct cb_notify_lock_args *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\nif (!cps->clp)\r\nreturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\ndprintk_rcu("NFS: CB_NOTIFY_LOCK request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nif (args->cbnl_valid)\r\n__wake_up(&cps->clp->cl_lock_waitq, TASK_NORMAL, 0, args);\r\nreturn htonl(NFS4_OK);\r\n}
