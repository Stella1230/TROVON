static int perf_do_probe_api(setup_probe_fn_t fn, int cpu, const char *str)\r\n{\r\nstruct perf_evlist *evlist;\r\nstruct perf_evsel *evsel;\r\nunsigned long flags = perf_event_open_cloexec_flag();\r\nint err = -EAGAIN, fd;\r\nstatic pid_t pid = -1;\r\nevlist = perf_evlist__new();\r\nif (!evlist)\r\nreturn -ENOMEM;\r\nif (parse_events(evlist, str, NULL))\r\ngoto out_delete;\r\nevsel = perf_evlist__first(evlist);\r\nwhile (1) {\r\nfd = sys_perf_event_open(&evsel->attr, pid, cpu, -1, flags);\r\nif (fd < 0) {\r\nif (pid == -1 && errno == EACCES) {\r\npid = 0;\r\ncontinue;\r\n}\r\ngoto out_delete;\r\n}\r\nbreak;\r\n}\r\nclose(fd);\r\nfn(evsel);\r\nfd = sys_perf_event_open(&evsel->attr, pid, cpu, -1, flags);\r\nif (fd < 0) {\r\nif (errno == EINVAL)\r\nerr = -EINVAL;\r\ngoto out_delete;\r\n}\r\nclose(fd);\r\nerr = 0;\r\nout_delete:\r\nperf_evlist__delete(evlist);\r\nreturn err;\r\n}\r\nstatic bool perf_probe_api(setup_probe_fn_t fn)\r\n{\r\nconst char *try[] = {"cycles:u", "instructions:u", "cpu-clock:u", NULL};\r\nstruct cpu_map *cpus;\r\nint cpu, ret, i = 0;\r\ncpus = cpu_map__new(NULL);\r\nif (!cpus)\r\nreturn false;\r\ncpu = cpus->map[0];\r\ncpu_map__put(cpus);\r\ndo {\r\nret = perf_do_probe_api(fn, cpu, try[i++]);\r\nif (!ret)\r\nreturn true;\r\n} while (ret == -EAGAIN && try[i]);\r\nreturn false;\r\n}\r\nstatic void perf_probe_sample_identifier(struct perf_evsel *evsel)\r\n{\r\nevsel->attr.sample_type |= PERF_SAMPLE_IDENTIFIER;\r\n}\r\nstatic void perf_probe_comm_exec(struct perf_evsel *evsel)\r\n{\r\nevsel->attr.comm_exec = 1;\r\n}\r\nstatic void perf_probe_context_switch(struct perf_evsel *evsel)\r\n{\r\nevsel->attr.context_switch = 1;\r\n}\r\nbool perf_can_sample_identifier(void)\r\n{\r\nreturn perf_probe_api(perf_probe_sample_identifier);\r\n}\r\nstatic bool perf_can_comm_exec(void)\r\n{\r\nreturn perf_probe_api(perf_probe_comm_exec);\r\n}\r\nbool perf_can_record_switch_events(void)\r\n{\r\nreturn perf_probe_api(perf_probe_context_switch);\r\n}\r\nbool perf_can_record_cpu_wide(void)\r\n{\r\nstruct perf_event_attr attr = {\r\n.type = PERF_TYPE_SOFTWARE,\r\n.config = PERF_COUNT_SW_CPU_CLOCK,\r\n.exclude_kernel = 1,\r\n};\r\nstruct cpu_map *cpus;\r\nint cpu, fd;\r\ncpus = cpu_map__new(NULL);\r\nif (!cpus)\r\nreturn false;\r\ncpu = cpus->map[0];\r\ncpu_map__put(cpus);\r\nfd = sys_perf_event_open(&attr, -1, cpu, -1, 0);\r\nif (fd < 0)\r\nreturn false;\r\nclose(fd);\r\nreturn true;\r\n}\r\nvoid perf_evlist__config(struct perf_evlist *evlist, struct record_opts *opts,\r\nstruct callchain_param *callchain)\r\n{\r\nstruct perf_evsel *evsel;\r\nbool use_sample_identifier = false;\r\nbool use_comm_exec;\r\nif (opts->group)\r\nperf_evlist__set_leader(evlist);\r\nif (evlist->cpus->map[0] < 0)\r\nopts->no_inherit = true;\r\nuse_comm_exec = perf_can_comm_exec();\r\nevlist__for_each_entry(evlist, evsel) {\r\nperf_evsel__config(evsel, opts, callchain);\r\nif (evsel->tracking && use_comm_exec)\r\nevsel->attr.comm_exec = 1;\r\n}\r\nif (opts->full_auxtrace) {\r\nuse_sample_identifier = perf_can_sample_identifier();\r\nevlist__for_each_entry(evlist, evsel)\r\nperf_evsel__set_sample_id(evsel, use_sample_identifier);\r\n} else if (evlist->nr_entries > 1) {\r\nstruct perf_evsel *first = perf_evlist__first(evlist);\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (evsel->attr.sample_type == first->attr.sample_type)\r\ncontinue;\r\nuse_sample_identifier = perf_can_sample_identifier();\r\nbreak;\r\n}\r\nevlist__for_each_entry(evlist, evsel)\r\nperf_evsel__set_sample_id(evsel, use_sample_identifier);\r\n}\r\nperf_evlist__set_id_pos(evlist);\r\n}\r\nstatic int get_max_rate(unsigned int *rate)\r\n{\r\nreturn sysctl__read_int("kernel/perf_event_max_sample_rate", (int *)rate);\r\n}\r\nstatic int record_opts__config_freq(struct record_opts *opts)\r\n{\r\nbool user_freq = opts->user_freq != UINT_MAX;\r\nunsigned int max_rate;\r\nif (opts->user_interval != ULLONG_MAX)\r\nopts->default_interval = opts->user_interval;\r\nif (user_freq)\r\nopts->freq = opts->user_freq;\r\nif (opts->default_interval)\r\nopts->freq = 0;\r\nelse if (opts->freq) {\r\nopts->default_interval = opts->freq;\r\n} else {\r\npr_err("frequency and count are zero, aborting\n");\r\nreturn -1;\r\n}\r\nif (get_max_rate(&max_rate))\r\nreturn 0;\r\nif (user_freq && (max_rate < opts->freq)) {\r\npr_err("Maximum frequency rate (%u) reached.\n"\r\n"Please use -F freq option with lower value or consider\n"\r\n"tweaking /proc/sys/kernel/perf_event_max_sample_rate.\n",\r\nmax_rate);\r\nreturn -1;\r\n}\r\nif (max_rate < opts->freq) {\r\npr_warning("Lowering default frequency rate to %u.\n"\r\n"Please consider tweaking "\r\n"/proc/sys/kernel/perf_event_max_sample_rate.\n",\r\nmax_rate);\r\nopts->freq = max_rate;\r\n}\r\nreturn 0;\r\n}\r\nint record_opts__config(struct record_opts *opts)\r\n{\r\nreturn record_opts__config_freq(opts);\r\n}\r\nbool perf_evlist__can_select_event(struct perf_evlist *evlist, const char *str)\r\n{\r\nstruct perf_evlist *temp_evlist;\r\nstruct perf_evsel *evsel;\r\nint err, fd, cpu;\r\nbool ret = false;\r\npid_t pid = -1;\r\ntemp_evlist = perf_evlist__new();\r\nif (!temp_evlist)\r\nreturn false;\r\nerr = parse_events(temp_evlist, str, NULL);\r\nif (err)\r\ngoto out_delete;\r\nevsel = perf_evlist__last(temp_evlist);\r\nif (!evlist || cpu_map__empty(evlist->cpus)) {\r\nstruct cpu_map *cpus = cpu_map__new(NULL);\r\ncpu = cpus ? cpus->map[0] : 0;\r\ncpu_map__put(cpus);\r\n} else {\r\ncpu = evlist->cpus->map[0];\r\n}\r\nwhile (1) {\r\nfd = sys_perf_event_open(&evsel->attr, pid, cpu, -1,\r\nperf_event_open_cloexec_flag());\r\nif (fd < 0) {\r\nif (pid == -1 && errno == EACCES) {\r\npid = 0;\r\ncontinue;\r\n}\r\ngoto out_delete;\r\n}\r\nbreak;\r\n}\r\nclose(fd);\r\nret = true;\r\nout_delete:\r\nperf_evlist__delete(temp_evlist);\r\nreturn ret;\r\n}
