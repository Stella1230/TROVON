const char *ip_vs_proto_name(unsigned int proto)\r\n{\r\nstatic char buf[20];\r\nswitch (proto) {\r\ncase IPPROTO_IP:\r\nreturn "IP";\r\ncase IPPROTO_UDP:\r\nreturn "UDP";\r\ncase IPPROTO_TCP:\r\nreturn "TCP";\r\ncase IPPROTO_SCTP:\r\nreturn "SCTP";\r\ncase IPPROTO_ICMP:\r\nreturn "ICMP";\r\n#ifdef CONFIG_IP_VS_IPV6\r\ncase IPPROTO_ICMPV6:\r\nreturn "ICMPv6";\r\n#endif\r\ndefault:\r\nsprintf(buf, "IP_%u", proto);\r\nreturn buf;\r\n}\r\n}\r\nvoid ip_vs_init_hash_table(struct list_head *table, int rows)\r\n{\r\nwhile (--rows >= 0)\r\nINIT_LIST_HEAD(&table[rows]);\r\n}\r\nstatic inline void\r\nip_vs_in_stats(struct ip_vs_conn *cp, struct sk_buff *skb)\r\n{\r\nstruct ip_vs_dest *dest = cp->dest;\r\nstruct netns_ipvs *ipvs = cp->ipvs;\r\nif (dest && (dest->flags & IP_VS_DEST_F_AVAILABLE)) {\r\nstruct ip_vs_cpu_stats *s;\r\nstruct ip_vs_service *svc;\r\ns = this_cpu_ptr(dest->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.inpkts++;\r\ns->cnt.inbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\nrcu_read_lock();\r\nsvc = rcu_dereference(dest->svc);\r\ns = this_cpu_ptr(svc->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.inpkts++;\r\ns->cnt.inbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\nrcu_read_unlock();\r\ns = this_cpu_ptr(ipvs->tot_stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.inpkts++;\r\ns->cnt.inbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\n}\r\n}\r\nstatic inline void\r\nip_vs_out_stats(struct ip_vs_conn *cp, struct sk_buff *skb)\r\n{\r\nstruct ip_vs_dest *dest = cp->dest;\r\nstruct netns_ipvs *ipvs = cp->ipvs;\r\nif (dest && (dest->flags & IP_VS_DEST_F_AVAILABLE)) {\r\nstruct ip_vs_cpu_stats *s;\r\nstruct ip_vs_service *svc;\r\ns = this_cpu_ptr(dest->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.outpkts++;\r\ns->cnt.outbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\nrcu_read_lock();\r\nsvc = rcu_dereference(dest->svc);\r\ns = this_cpu_ptr(svc->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.outpkts++;\r\ns->cnt.outbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\nrcu_read_unlock();\r\ns = this_cpu_ptr(ipvs->tot_stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.outpkts++;\r\ns->cnt.outbytes += skb->len;\r\nu64_stats_update_end(&s->syncp);\r\n}\r\n}\r\nstatic inline void\r\nip_vs_conn_stats(struct ip_vs_conn *cp, struct ip_vs_service *svc)\r\n{\r\nstruct netns_ipvs *ipvs = svc->ipvs;\r\nstruct ip_vs_cpu_stats *s;\r\ns = this_cpu_ptr(cp->dest->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.conns++;\r\nu64_stats_update_end(&s->syncp);\r\ns = this_cpu_ptr(svc->stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.conns++;\r\nu64_stats_update_end(&s->syncp);\r\ns = this_cpu_ptr(ipvs->tot_stats.cpustats);\r\nu64_stats_update_begin(&s->syncp);\r\ns->cnt.conns++;\r\nu64_stats_update_end(&s->syncp);\r\n}\r\nstatic inline void\r\nip_vs_set_state(struct ip_vs_conn *cp, int direction,\r\nconst struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd)\r\n{\r\nif (likely(pd->pp->state_transition))\r\npd->pp->state_transition(cp, direction, skb, pd);\r\n}\r\nstatic inline int\r\nip_vs_conn_fill_param_persist(const struct ip_vs_service *svc,\r\nstruct sk_buff *skb, int protocol,\r\nconst union nf_inet_addr *caddr, __be16 cport,\r\nconst union nf_inet_addr *vaddr, __be16 vport,\r\nstruct ip_vs_conn_param *p)\r\n{\r\nip_vs_conn_fill_param(svc->ipvs, svc->af, protocol, caddr, cport, vaddr,\r\nvport, p);\r\np->pe = rcu_dereference(svc->pe);\r\nif (p->pe && p->pe->fill_param)\r\nreturn p->pe->fill_param(p, skb);\r\nreturn 0;\r\n}\r\nstatic struct ip_vs_conn *\r\nip_vs_sched_persist(struct ip_vs_service *svc,\r\nstruct sk_buff *skb, __be16 src_port, __be16 dst_port,\r\nint *ignored, struct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_conn *cp = NULL;\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_conn *ct;\r\n__be16 dport = 0;\r\nunsigned int flags;\r\nstruct ip_vs_conn_param param;\r\nconst union nf_inet_addr fwmark = { .ip = htonl(svc->fwmark) };\r\nunion nf_inet_addr snet;\r\nconst union nf_inet_addr *src_addr, *dst_addr;\r\nif (likely(!ip_vs_iph_inverse(iph))) {\r\nsrc_addr = &iph->saddr;\r\ndst_addr = &iph->daddr;\r\n} else {\r\nsrc_addr = &iph->daddr;\r\ndst_addr = &iph->saddr;\r\n}\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (svc->af == AF_INET6)\r\nipv6_addr_prefix(&snet.in6, &src_addr->in6,\r\n(__force __u32) svc->netmask);\r\nelse\r\n#endif\r\nsnet.ip = src_addr->ip & svc->netmask;\r\nIP_VS_DBG_BUF(6, "p-schedule: src %s:%u dest %s:%u "\r\n"mnet %s\n",\r\nIP_VS_DBG_ADDR(svc->af, src_addr), ntohs(src_port),\r\nIP_VS_DBG_ADDR(svc->af, dst_addr), ntohs(dst_port),\r\nIP_VS_DBG_ADDR(svc->af, &snet));\r\n{\r\nint protocol = iph->protocol;\r\nconst union nf_inet_addr *vaddr = dst_addr;\r\n__be16 vport = 0;\r\nif (dst_port == svc->port) {\r\nif (svc->port != FTPPORT)\r\nvport = dst_port;\r\n} else {\r\nif (svc->fwmark) {\r\nprotocol = IPPROTO_IP;\r\nvaddr = &fwmark;\r\n}\r\n}\r\nif (ip_vs_conn_fill_param_persist(svc, skb, protocol, &snet, 0,\r\nvaddr, vport, &param) < 0) {\r\n*ignored = -1;\r\nreturn NULL;\r\n}\r\n}\r\nct = ip_vs_ct_in_get(&param);\r\nif (!ct || !ip_vs_check_template(ct, NULL)) {\r\nstruct ip_vs_scheduler *sched;\r\nsched = rcu_dereference(svc->scheduler);\r\nif (sched) {\r\nsmp_rmb();\r\ndest = sched->schedule(svc, skb, iph);\r\n} else {\r\ndest = NULL;\r\n}\r\nif (!dest) {\r\nIP_VS_DBG(1, "p-schedule: no dest found.\n");\r\nkfree(param.pe_data);\r\n*ignored = 0;\r\nreturn NULL;\r\n}\r\nif (dst_port == svc->port && svc->port != FTPPORT)\r\ndport = dest->port;\r\nct = ip_vs_conn_new(&param, dest->af, &dest->addr, dport,\r\nIP_VS_CONN_F_TEMPLATE, dest, skb->mark);\r\nif (ct == NULL) {\r\nkfree(param.pe_data);\r\n*ignored = -1;\r\nreturn NULL;\r\n}\r\nct->timeout = svc->timeout;\r\n} else {\r\ndest = ct->dest;\r\nkfree(param.pe_data);\r\n}\r\ndport = dst_port;\r\nif (dport == svc->port && dest->port)\r\ndport = dest->port;\r\nflags = (svc->flags & IP_VS_SVC_F_ONEPACKET\r\n&& iph->protocol == IPPROTO_UDP) ?\r\nIP_VS_CONN_F_ONE_PACKET : 0;\r\nip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol, src_addr,\r\nsrc_port, dst_addr, dst_port, &param);\r\ncp = ip_vs_conn_new(&param, dest->af, &dest->addr, dport, flags, dest,\r\nskb->mark);\r\nif (cp == NULL) {\r\nip_vs_conn_put(ct);\r\n*ignored = -1;\r\nreturn NULL;\r\n}\r\nip_vs_control_add(cp, ct);\r\nip_vs_conn_put(ct);\r\nip_vs_conn_stats(cp, svc);\r\nreturn cp;\r\n}\r\nstruct ip_vs_conn *\r\nip_vs_schedule(struct ip_vs_service *svc, struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd, int *ignored,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_protocol *pp = pd->pp;\r\nstruct ip_vs_conn *cp = NULL;\r\nstruct ip_vs_scheduler *sched;\r\nstruct ip_vs_dest *dest;\r\n__be16 _ports[2], *pptr, cport, vport;\r\nconst void *caddr, *vaddr;\r\nunsigned int flags;\r\n*ignored = 1;\r\npptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports, iph);\r\nif (pptr == NULL)\r\nreturn NULL;\r\nif (likely(!ip_vs_iph_inverse(iph))) {\r\ncport = pptr[0];\r\ncaddr = &iph->saddr;\r\nvport = pptr[1];\r\nvaddr = &iph->daddr;\r\n} else {\r\ncport = pptr[1];\r\ncaddr = &iph->daddr;\r\nvport = pptr[0];\r\nvaddr = &iph->saddr;\r\n}\r\nif (cport == FTPDATA) {\r\nIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\r\n"Not scheduling FTPDATA");\r\nreturn NULL;\r\n}\r\nif ((!skb->dev || skb->dev->flags & IFF_LOOPBACK)) {\r\niph->hdr_flags ^= IP_VS_HDR_INVERSE;\r\ncp = pp->conn_in_get(svc->ipvs, svc->af, skb, iph);\r\niph->hdr_flags ^= IP_VS_HDR_INVERSE;\r\nif (cp) {\r\nIP_VS_DBG_PKT(12, svc->af, pp, skb, iph->off,\r\n"Not scheduling reply for existing"\r\n" connection");\r\n__ip_vs_conn_put(cp);\r\nreturn NULL;\r\n}\r\n}\r\nif (svc->flags & IP_VS_SVC_F_PERSISTENT)\r\nreturn ip_vs_sched_persist(svc, skb, cport, vport, ignored,\r\niph);\r\n*ignored = 0;\r\nif (!svc->fwmark && vport != svc->port) {\r\nif (!svc->port)\r\npr_err("Schedule: port zero only supported "\r\n"in persistent services, "\r\n"check your ipvs configuration\n");\r\nreturn NULL;\r\n}\r\nsched = rcu_dereference(svc->scheduler);\r\nif (sched) {\r\nsmp_rmb();\r\ndest = sched->schedule(svc, skb, iph);\r\n} else {\r\ndest = NULL;\r\n}\r\nif (dest == NULL) {\r\nIP_VS_DBG(1, "Schedule: no dest found.\n");\r\nreturn NULL;\r\n}\r\nflags = (svc->flags & IP_VS_SVC_F_ONEPACKET\r\n&& iph->protocol == IPPROTO_UDP) ?\r\nIP_VS_CONN_F_ONE_PACKET : 0;\r\n{\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\r\ncaddr, cport, vaddr, vport, &p);\r\ncp = ip_vs_conn_new(&p, dest->af, &dest->addr,\r\ndest->port ? dest->port : vport,\r\nflags, dest, skb->mark);\r\nif (!cp) {\r\n*ignored = -1;\r\nreturn NULL;\r\n}\r\n}\r\nIP_VS_DBG_BUF(6, "Schedule fwd:%c c:%s:%u v:%s:%u "\r\n"d:%s:%u conn->flags:%X conn->refcnt:%d\n",\r\nip_vs_fwd_tag(cp),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\r\nIP_VS_DBG_ADDR(cp->daf, &cp->daddr), ntohs(cp->dport),\r\ncp->flags, atomic_read(&cp->refcnt));\r\nip_vs_conn_stats(cp, svc);\r\nreturn cp;\r\n}\r\nstatic inline int ip_vs_addr_is_unicast(struct net *net, int af,\r\nunion nf_inet_addr *addr)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nreturn ipv6_addr_type(&addr->in6) & IPV6_ADDR_UNICAST;\r\n#endif\r\nreturn (inet_addr_type(net, addr->ip) == RTN_UNICAST);\r\n}\r\nint ip_vs_leave(struct ip_vs_service *svc, struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd, struct ip_vs_iphdr *iph)\r\n{\r\n__be16 _ports[2], *pptr, dport;\r\nstruct netns_ipvs *ipvs = svc->ipvs;\r\nstruct net *net = ipvs->net;\r\npptr = frag_safe_skb_hp(skb, iph->len, sizeof(_ports), _ports, iph);\r\nif (!pptr)\r\nreturn NF_DROP;\r\ndport = likely(!ip_vs_iph_inverse(iph)) ? pptr[1] : pptr[0];\r\nif (sysctl_cache_bypass(ipvs) && svc->fwmark &&\r\n!(iph->hdr_flags & (IP_VS_HDR_INVERSE | IP_VS_HDR_ICMP)) &&\r\nip_vs_addr_is_unicast(net, svc->af, &iph->daddr)) {\r\nint ret;\r\nstruct ip_vs_conn *cp;\r\nunsigned int flags = (svc->flags & IP_VS_SVC_F_ONEPACKET &&\r\niph->protocol == IPPROTO_UDP) ?\r\nIP_VS_CONN_F_ONE_PACKET : 0;\r\nunion nf_inet_addr daddr = { .all = { 0, 0, 0, 0 } };\r\nIP_VS_DBG(6, "%s(): create a cache_bypass entry\n", __func__);\r\n{\r\nstruct ip_vs_conn_param p;\r\nip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\r\n&iph->saddr, pptr[0],\r\n&iph->daddr, pptr[1], &p);\r\ncp = ip_vs_conn_new(&p, svc->af, &daddr, 0,\r\nIP_VS_CONN_F_BYPASS | flags,\r\nNULL, skb->mark);\r\nif (!cp)\r\nreturn NF_DROP;\r\n}\r\nip_vs_in_stats(cp, skb);\r\nip_vs_set_state(cp, IP_VS_DIR_INPUT, skb, pd);\r\nret = cp->packet_xmit(skb, cp, pd->pp, iph);\r\nif ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && cp->control)\r\natomic_inc(&cp->control->in_pkts);\r\nelse\r\natomic_inc(&cp->in_pkts);\r\nip_vs_conn_put(cp);\r\nreturn ret;\r\n}\r\nif (svc->port == FTPPORT && dport != FTPPORT)\r\nreturn NF_ACCEPT;\r\nif (unlikely(ip_vs_iph_icmp(iph)))\r\nreturn NF_DROP;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (svc->af == AF_INET6) {\r\nif (!skb->dev)\r\nskb->dev = net->loopback_dev;\r\nicmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\r\n} else\r\n#endif\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\nreturn NF_DROP;\r\n}\r\nstatic int sysctl_snat_reroute(struct netns_ipvs *ipvs)\r\n{\r\nreturn ipvs->sysctl_snat_reroute;\r\n}\r\nstatic int sysctl_nat_icmp_send(struct netns_ipvs *ipvs)\r\n{\r\nreturn ipvs->sysctl_nat_icmp_send;\r\n}\r\nstatic int sysctl_expire_nodest_conn(struct netns_ipvs *ipvs)\r\n{\r\nreturn ipvs->sysctl_expire_nodest_conn;\r\n}\r\nstatic int sysctl_snat_reroute(struct netns_ipvs *ipvs) { return 0; }\r\nstatic int sysctl_nat_icmp_send(struct netns_ipvs *ipvs) { return 0; }\r\nstatic int sysctl_expire_nodest_conn(struct netns_ipvs *ipvs) { return 0; }\r\n__sum16 ip_vs_checksum_complete(struct sk_buff *skb, int offset)\r\n{\r\nreturn csum_fold(skb_checksum(skb, offset, skb->len - offset, 0));\r\n}\r\nstatic inline enum ip_defrag_users ip_vs_defrag_user(unsigned int hooknum)\r\n{\r\nif (NF_INET_LOCAL_IN == hooknum)\r\nreturn IP_DEFRAG_VS_IN;\r\nif (NF_INET_FORWARD == hooknum)\r\nreturn IP_DEFRAG_VS_FWD;\r\nreturn IP_DEFRAG_VS_OUT;\r\n}\r\nstatic inline int ip_vs_gather_frags(struct netns_ipvs *ipvs,\r\nstruct sk_buff *skb, u_int32_t user)\r\n{\r\nint err;\r\nlocal_bh_disable();\r\nerr = ip_defrag(ipvs->net, skb, user);\r\nlocal_bh_enable();\r\nif (!err)\r\nip_send_check(ip_hdr(skb));\r\nreturn err;\r\n}\r\nstatic int ip_vs_route_me_harder(struct netns_ipvs *ipvs, int af,\r\nstruct sk_buff *skb, unsigned int hooknum)\r\n{\r\nif (!sysctl_snat_reroute(ipvs))\r\nreturn 0;\r\nif (NF_INET_LOCAL_IN == hooknum)\r\nreturn 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nstruct dst_entry *dst = skb_dst(skb);\r\nif (dst->dev && !(dst->dev->flags & IFF_LOOPBACK) &&\r\nip6_route_me_harder(ipvs->net, skb) != 0)\r\nreturn 1;\r\n} else\r\n#endif\r\nif (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL) &&\r\nip_route_me_harder(ipvs->net, skb, RTN_LOCAL) != 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid ip_vs_nat_icmp(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, int inout)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb);\r\nunsigned int icmp_offset = iph->ihl*4;\r\nstruct icmphdr *icmph = (struct icmphdr *)(skb_network_header(skb) +\r\nicmp_offset);\r\nstruct iphdr *ciph = (struct iphdr *)(icmph + 1);\r\nif (inout) {\r\niph->saddr = cp->vaddr.ip;\r\nip_send_check(iph);\r\nciph->daddr = cp->vaddr.ip;\r\nip_send_check(ciph);\r\n} else {\r\niph->daddr = cp->daddr.ip;\r\nip_send_check(iph);\r\nciph->saddr = cp->daddr.ip;\r\nip_send_check(ciph);\r\n}\r\nif (IPPROTO_TCP == ciph->protocol || IPPROTO_UDP == ciph->protocol ||\r\nIPPROTO_SCTP == ciph->protocol) {\r\n__be16 *ports = (void *)ciph + ciph->ihl*4;\r\nif (inout)\r\nports[1] = cp->vport;\r\nelse\r\nports[0] = cp->dport;\r\n}\r\nicmph->checksum = 0;\r\nicmph->checksum = ip_vs_checksum_complete(skb, icmp_offset);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nif (inout)\r\nIP_VS_DBG_PKT(11, AF_INET, pp, skb, (void *)ciph - (void *)iph,\r\n"Forwarding altered outgoing ICMP");\r\nelse\r\nIP_VS_DBG_PKT(11, AF_INET, pp, skb, (void *)ciph - (void *)iph,\r\n"Forwarding altered incoming ICMP");\r\n}\r\nvoid ip_vs_nat_icmp_v6(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, int inout)\r\n{\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nunsigned int icmp_offset = 0;\r\nunsigned int offs = 0;\r\nint protocol;\r\nstruct icmp6hdr *icmph;\r\nstruct ipv6hdr *ciph;\r\nunsigned short fragoffs;\r\nipv6_find_hdr(skb, &icmp_offset, IPPROTO_ICMPV6, &fragoffs, NULL);\r\nicmph = (struct icmp6hdr *)(skb_network_header(skb) + icmp_offset);\r\noffs = icmp_offset + sizeof(struct icmp6hdr);\r\nciph = (struct ipv6hdr *)(skb_network_header(skb) + offs);\r\nprotocol = ipv6_find_hdr(skb, &offs, -1, &fragoffs, NULL);\r\nif (inout) {\r\niph->saddr = cp->vaddr.in6;\r\nciph->daddr = cp->vaddr.in6;\r\n} else {\r\niph->daddr = cp->daddr.in6;\r\nciph->saddr = cp->daddr.in6;\r\n}\r\nif (!fragoffs && (IPPROTO_TCP == protocol || IPPROTO_UDP == protocol ||\r\nIPPROTO_SCTP == protocol)) {\r\n__be16 *ports = (void *)(skb_network_header(skb) + offs);\r\nIP_VS_DBG(11, "%s() changed port %d to %d\n", __func__,\r\nntohs(inout ? ports[1] : ports[0]),\r\nntohs(inout ? cp->vport : cp->dport));\r\nif (inout)\r\nports[1] = cp->vport;\r\nelse\r\nports[0] = cp->dport;\r\n}\r\nicmph->icmp6_cksum = ~csum_ipv6_magic(&iph->saddr, &iph->daddr,\r\nskb->len - icmp_offset,\r\nIPPROTO_ICMPV6, 0);\r\nskb->csum_start = skb_network_header(skb) - skb->head + icmp_offset;\r\nskb->csum_offset = offsetof(struct icmp6hdr, icmp6_cksum);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nif (inout)\r\nIP_VS_DBG_PKT(11, AF_INET6, pp, skb,\r\n(void *)ciph - (void *)iph,\r\n"Forwarding altered outgoing ICMPv6");\r\nelse\r\nIP_VS_DBG_PKT(11, AF_INET6, pp, skb,\r\n(void *)ciph - (void *)iph,\r\n"Forwarding altered incoming ICMPv6");\r\n}\r\nstatic int handle_response_icmp(int af, struct sk_buff *skb,\r\nunion nf_inet_addr *snet,\r\n__u8 protocol, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp,\r\nunsigned int offset, unsigned int ihl,\r\nunsigned int hooknum)\r\n{\r\nunsigned int verdict = NF_DROP;\r\nif (IP_VS_FWD_METHOD(cp) != 0) {\r\npr_err("shouldn't reach here, because the box is on the "\r\n"half connection in the tun/dr module.\n");\r\n}\r\nif (!skb_csum_unnecessary(skb) && ip_vs_checksum_complete(skb, ihl)) {\r\nIP_VS_DBG_BUF(1, "Forward ICMP: failed checksum from %s!\n",\r\nIP_VS_DBG_ADDR(af, snet));\r\ngoto out;\r\n}\r\nif (IPPROTO_TCP == protocol || IPPROTO_UDP == protocol ||\r\nIPPROTO_SCTP == protocol)\r\noffset += 2 * sizeof(__u16);\r\nif (!skb_make_writable(skb, offset))\r\ngoto out;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nip_vs_nat_icmp_v6(skb, pp, cp, 1);\r\nelse\r\n#endif\r\nip_vs_nat_icmp(skb, pp, cp, 1);\r\nif (ip_vs_route_me_harder(cp->ipvs, af, skb, hooknum))\r\ngoto out;\r\nip_vs_out_stats(cp, skb);\r\nskb->ipvs_property = 1;\r\nif (!(cp->flags & IP_VS_CONN_F_NFCT))\r\nip_vs_notrack(skb);\r\nelse\r\nip_vs_update_conntrack(skb, cp, 0);\r\nverdict = NF_ACCEPT;\r\nout:\r\n__ip_vs_conn_put(cp);\r\nreturn verdict;\r\n}\r\nstatic int ip_vs_out_icmp(struct netns_ipvs *ipvs, struct sk_buff *skb,\r\nint *related, unsigned int hooknum)\r\n{\r\nstruct iphdr *iph;\r\nstruct icmphdr _icmph, *ic;\r\nstruct iphdr _ciph, *cih;\r\nstruct ip_vs_iphdr ciph;\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_protocol *pp;\r\nunsigned int offset, ihl;\r\nunion nf_inet_addr snet;\r\n*related = 1;\r\nif (ip_is_fragment(ip_hdr(skb))) {\r\nif (ip_vs_gather_frags(ipvs, skb, ip_vs_defrag_user(hooknum)))\r\nreturn NF_STOLEN;\r\n}\r\niph = ip_hdr(skb);\r\noffset = ihl = iph->ihl * 4;\r\nic = skb_header_pointer(skb, offset, sizeof(_icmph), &_icmph);\r\nif (ic == NULL)\r\nreturn NF_DROP;\r\nIP_VS_DBG(12, "Outgoing ICMP (%d,%d) %pI4->%pI4\n",\r\nic->type, ntohs(icmp_id(ic)),\r\n&iph->saddr, &iph->daddr);\r\nif ((ic->type != ICMP_DEST_UNREACH) &&\r\n(ic->type != ICMP_SOURCE_QUENCH) &&\r\n(ic->type != ICMP_TIME_EXCEEDED)) {\r\n*related = 0;\r\nreturn NF_ACCEPT;\r\n}\r\noffset += sizeof(_icmph);\r\ncih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\r\nif (cih == NULL)\r\nreturn NF_ACCEPT;\r\npp = ip_vs_proto_get(cih->protocol);\r\nif (!pp)\r\nreturn NF_ACCEPT;\r\nif (unlikely(cih->frag_off & htons(IP_OFFSET) &&\r\npp->dont_defrag))\r\nreturn NF_ACCEPT;\r\nIP_VS_DBG_PKT(11, AF_INET, pp, skb, offset,\r\n"Checking outgoing ICMP for");\r\nip_vs_fill_iph_skb_icmp(AF_INET, skb, offset, true, &ciph);\r\ncp = pp->conn_out_get(ipvs, AF_INET, skb, &ciph);\r\nif (!cp)\r\nreturn NF_ACCEPT;\r\nsnet.ip = iph->saddr;\r\nreturn handle_response_icmp(AF_INET, skb, &snet, cih->protocol, cp,\r\npp, ciph.len, ihl, hooknum);\r\n}\r\nstatic int ip_vs_out_icmp_v6(struct netns_ipvs *ipvs, struct sk_buff *skb,\r\nint *related, unsigned int hooknum,\r\nstruct ip_vs_iphdr *ipvsh)\r\n{\r\nstruct icmp6hdr _icmph, *ic;\r\nstruct ip_vs_iphdr ciph = {.flags = 0, .fragoffs = 0};\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_protocol *pp;\r\nunion nf_inet_addr snet;\r\nunsigned int offset;\r\n*related = 1;\r\nic = frag_safe_skb_hp(skb, ipvsh->len, sizeof(_icmph), &_icmph, ipvsh);\r\nif (ic == NULL)\r\nreturn NF_DROP;\r\nif (ic->icmp6_type & ICMPV6_INFOMSG_MASK) {\r\n*related = 0;\r\nreturn NF_ACCEPT;\r\n}\r\nif (ipvsh->flags & IP6_FH_F_FRAG)\r\nreturn NF_DROP;\r\nIP_VS_DBG(8, "Outgoing ICMPv6 (%d,%d) %pI6c->%pI6c\n",\r\nic->icmp6_type, ntohs(icmpv6_id(ic)),\r\n&ipvsh->saddr, &ipvsh->daddr);\r\nif (!ip_vs_fill_iph_skb_icmp(AF_INET6, skb, ipvsh->len + sizeof(_icmph),\r\ntrue, &ciph))\r\nreturn NF_ACCEPT;\r\npp = ip_vs_proto_get(ciph.protocol);\r\nif (!pp)\r\nreturn NF_ACCEPT;\r\ncp = pp->conn_out_get(ipvs, AF_INET6, skb, &ciph);\r\nif (!cp)\r\nreturn NF_ACCEPT;\r\nsnet.in6 = ciph.saddr.in6;\r\noffset = ciph.len;\r\nreturn handle_response_icmp(AF_INET6, skb, &snet, ciph.protocol, cp,\r\npp, offset, sizeof(struct ipv6hdr),\r\nhooknum);\r\n}\r\nstatic inline int is_sctp_abort(const struct sk_buff *skb, int nh_len)\r\n{\r\nsctp_chunkhdr_t *sch, schunk;\r\nsch = skb_header_pointer(skb, nh_len + sizeof(sctp_sctphdr_t),\r\nsizeof(schunk), &schunk);\r\nif (sch == NULL)\r\nreturn 0;\r\nif (sch->type == SCTP_CID_ABORT)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int is_tcp_reset(const struct sk_buff *skb, int nh_len)\r\n{\r\nstruct tcphdr _tcph, *th;\r\nth = skb_header_pointer(skb, nh_len, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn 0;\r\nreturn th->rst;\r\n}\r\nstatic inline bool is_new_conn(const struct sk_buff *skb,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nswitch (iph->protocol) {\r\ncase IPPROTO_TCP: {\r\nstruct tcphdr _tcph, *th;\r\nth = skb_header_pointer(skb, iph->len, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn false;\r\nreturn th->syn;\r\n}\r\ncase IPPROTO_SCTP: {\r\nsctp_chunkhdr_t *sch, schunk;\r\nsch = skb_header_pointer(skb, iph->len + sizeof(sctp_sctphdr_t),\r\nsizeof(schunk), &schunk);\r\nif (sch == NULL)\r\nreturn false;\r\nreturn sch->type == SCTP_CID_INIT;\r\n}\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline bool is_new_conn_expected(const struct ip_vs_conn *cp,\r\nint conn_reuse_mode)\r\n{\r\nif (cp->control)\r\nreturn false;\r\nswitch (cp->protocol) {\r\ncase IPPROTO_TCP:\r\nreturn (cp->state == IP_VS_TCP_S_TIME_WAIT) ||\r\n(cp->state == IP_VS_TCP_S_CLOSE) ||\r\n((conn_reuse_mode & 2) &&\r\n(cp->state == IP_VS_TCP_S_FIN_WAIT) &&\r\n(cp->flags & IP_VS_CONN_F_NOOUTPUT));\r\ncase IPPROTO_SCTP:\r\nreturn cp->state == IP_VS_SCTP_S_CLOSED;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstruct ip_vs_conn *ip_vs_new_conn_out(struct ip_vs_service *svc,\r\nstruct ip_vs_dest *dest,\r\nstruct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph,\r\n__be16 dport,\r\n__be16 cport)\r\n{\r\nstruct ip_vs_conn_param param;\r\nstruct ip_vs_conn *ct = NULL, *cp = NULL;\r\nconst union nf_inet_addr *vaddr, *daddr, *caddr;\r\nunion nf_inet_addr snet;\r\n__be16 vport;\r\nunsigned int flags;\r\nEnterFunction(12);\r\nvaddr = &svc->addr;\r\nvport = svc->port;\r\ndaddr = &iph->saddr;\r\ncaddr = &iph->daddr;\r\nif (svc->fwmark)\r\nreturn NULL;\r\nif (!vport || !dport)\r\nreturn NULL;\r\nif (svc->flags & IP_VS_SVC_F_PERSISTENT) {\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (svc->af == AF_INET6)\r\nipv6_addr_prefix(&snet.in6, &caddr->in6,\r\n(__force __u32)svc->netmask);\r\nelse\r\n#endif\r\nsnet.ip = caddr->ip & svc->netmask;\r\nif (ip_vs_conn_fill_param_persist(svc, skb, iph->protocol,\r\n&snet, 0, vaddr,\r\nvport, &param) < 0)\r\nreturn NULL;\r\nct = ip_vs_ct_in_get(&param);\r\nif (!ct || !ip_vs_check_template(ct, dest)) {\r\nct = ip_vs_conn_new(&param, dest->af, daddr, dport,\r\nIP_VS_CONN_F_TEMPLATE, dest, 0);\r\nif (!ct) {\r\nkfree(param.pe_data);\r\nreturn NULL;\r\n}\r\nct->timeout = svc->timeout;\r\n} else {\r\nkfree(param.pe_data);\r\n}\r\n}\r\nflags = ((svc->flags & IP_VS_SVC_F_ONEPACKET) &&\r\niph->protocol == IPPROTO_UDP) ? IP_VS_CONN_F_ONE_PACKET : 0;\r\nip_vs_conn_fill_param(svc->ipvs, svc->af, iph->protocol,\r\ncaddr, cport, vaddr, vport, &param);\r\ncp = ip_vs_conn_new(&param, dest->af, daddr, dport, flags, dest, 0);\r\nif (!cp) {\r\nif (ct)\r\nip_vs_conn_put(ct);\r\nreturn NULL;\r\n}\r\nif (ct) {\r\nip_vs_control_add(cp, ct);\r\nip_vs_conn_put(ct);\r\n}\r\nip_vs_conn_stats(cp, svc);\r\nIP_VS_DBG_BUF(6, "New connection RS-initiated:%c c:%s:%u v:%s:%u "\r\n"d:%s:%u conn->flags:%X conn->refcnt:%d\n",\r\nip_vs_fwd_tag(cp),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr), ntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr), ntohs(cp->vport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->daddr), ntohs(cp->dport),\r\ncp->flags, atomic_read(&cp->refcnt));\r\nLeaveFunction(12);\r\nreturn cp;\r\n}\r\nstatic struct ip_vs_conn *__ip_vs_rs_conn_out(unsigned int hooknum,\r\nstruct netns_ipvs *ipvs,\r\nint af, struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_dest *dest;\r\nstruct ip_vs_conn *cp = NULL;\r\n__be16 _ports[2], *pptr;\r\nif (hooknum == NF_INET_LOCAL_IN)\r\nreturn NULL;\r\npptr = frag_safe_skb_hp(skb, iph->len,\r\nsizeof(_ports), _ports, iph);\r\nif (!pptr)\r\nreturn NULL;\r\nrcu_read_lock();\r\ndest = ip_vs_find_real_service(ipvs, af, iph->protocol,\r\n&iph->saddr, pptr[0]);\r\nif (dest) {\r\nstruct ip_vs_service *svc;\r\nstruct ip_vs_pe *pe;\r\nsvc = rcu_dereference(dest->svc);\r\nif (svc) {\r\npe = rcu_dereference(svc->pe);\r\nif (pe && pe->conn_out)\r\ncp = pe->conn_out(svc, dest, skb, iph,\r\npptr[0], pptr[1]);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn cp;\r\n}\r\nstatic unsigned int\r\nhandle_response(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph,\r\nunsigned int hooknum)\r\n{\r\nstruct ip_vs_protocol *pp = pd->pp;\r\nIP_VS_DBG_PKT(11, af, pp, skb, iph->off, "Outgoing packet");\r\nif (!skb_make_writable(skb, iph->len))\r\ngoto drop;\r\nif (pp->snat_handler && !pp->snat_handler(skb, pp, cp, iph))\r\ngoto drop;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\nipv6_hdr(skb)->saddr = cp->vaddr.in6;\r\nelse\r\n#endif\r\n{\r\nip_hdr(skb)->saddr = cp->vaddr.ip;\r\nip_send_check(ip_hdr(skb));\r\n}\r\nif (ip_vs_route_me_harder(cp->ipvs, af, skb, hooknum))\r\ngoto drop;\r\nIP_VS_DBG_PKT(10, af, pp, skb, iph->off, "After SNAT");\r\nip_vs_out_stats(cp, skb);\r\nip_vs_set_state(cp, IP_VS_DIR_OUTPUT, skb, pd);\r\nskb->ipvs_property = 1;\r\nif (!(cp->flags & IP_VS_CONN_F_NFCT))\r\nip_vs_notrack(skb);\r\nelse\r\nip_vs_update_conntrack(skb, cp, 0);\r\nip_vs_conn_put(cp);\r\nLeaveFunction(11);\r\nreturn NF_ACCEPT;\r\ndrop:\r\nip_vs_conn_put(cp);\r\nkfree_skb(skb);\r\nLeaveFunction(11);\r\nreturn NF_STOLEN;\r\n}\r\nstatic unsigned int\r\nip_vs_out(struct netns_ipvs *ipvs, unsigned int hooknum, struct sk_buff *skb, int af)\r\n{\r\nstruct ip_vs_iphdr iph;\r\nstruct ip_vs_protocol *pp;\r\nstruct ip_vs_proto_data *pd;\r\nstruct ip_vs_conn *cp;\r\nstruct sock *sk;\r\nEnterFunction(11);\r\nif (skb->ipvs_property)\r\nreturn NF_ACCEPT;\r\nsk = skb_to_full_sk(skb);\r\nif (unlikely(sk && hooknum == NF_INET_LOCAL_OUT &&\r\naf == AF_INET)) {\r\nif (sk->sk_family == PF_INET && inet_sk(sk)->nodefrag)\r\nreturn NF_ACCEPT;\r\n}\r\nif (unlikely(!skb_dst(skb)))\r\nreturn NF_ACCEPT;\r\nif (!ipvs->enable)\r\nreturn NF_ACCEPT;\r\nip_vs_fill_iph_skb(af, skb, false, &iph);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nif (unlikely(iph.protocol == IPPROTO_ICMPV6)) {\r\nint related;\r\nint verdict = ip_vs_out_icmp_v6(ipvs, skb, &related,\r\nhooknum, &iph);\r\nif (related)\r\nreturn verdict;\r\n}\r\n} else\r\n#endif\r\nif (unlikely(iph.protocol == IPPROTO_ICMP)) {\r\nint related;\r\nint verdict = ip_vs_out_icmp(ipvs, skb, &related, hooknum);\r\nif (related)\r\nreturn verdict;\r\n}\r\npd = ip_vs_proto_data_get(ipvs, iph.protocol);\r\nif (unlikely(!pd))\r\nreturn NF_ACCEPT;\r\npp = pd->pp;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET)\r\n#endif\r\nif (unlikely(ip_is_fragment(ip_hdr(skb)) && !pp->dont_defrag)) {\r\nif (ip_vs_gather_frags(ipvs, skb,\r\nip_vs_defrag_user(hooknum)))\r\nreturn NF_STOLEN;\r\nip_vs_fill_iph_skb(AF_INET, skb, false, &iph);\r\n}\r\ncp = pp->conn_out_get(ipvs, af, skb, &iph);\r\nif (likely(cp))\r\nreturn handle_response(af, skb, pd, cp, &iph, hooknum);\r\nif (atomic_read(&ipvs->conn_out_counter)) {\r\nif (pp->protocol == IPPROTO_UDP) {\r\ncp = __ip_vs_rs_conn_out(hooknum, ipvs, af, skb, &iph);\r\nif (likely(cp))\r\nreturn handle_response(af, skb, pd, cp, &iph,\r\nhooknum);\r\n}\r\n}\r\nif (sysctl_nat_icmp_send(ipvs) &&\r\n(pp->protocol == IPPROTO_TCP ||\r\npp->protocol == IPPROTO_UDP ||\r\npp->protocol == IPPROTO_SCTP)) {\r\n__be16 _ports[2], *pptr;\r\npptr = frag_safe_skb_hp(skb, iph.len,\r\nsizeof(_ports), _ports, &iph);\r\nif (pptr == NULL)\r\nreturn NF_ACCEPT;\r\nif (ip_vs_has_real_service(ipvs, af, iph.protocol, &iph.saddr,\r\npptr[0])) {\r\nif ((iph.protocol != IPPROTO_TCP &&\r\niph.protocol != IPPROTO_SCTP)\r\n|| ((iph.protocol == IPPROTO_TCP\r\n&& !is_tcp_reset(skb, iph.len))\r\n|| (iph.protocol == IPPROTO_SCTP\r\n&& !is_sctp_abort(skb,\r\niph.len)))) {\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nif (!skb->dev)\r\nskb->dev = ipvs->net->loopback_dev;\r\nicmpv6_send(skb,\r\nICMPV6_DEST_UNREACH,\r\nICMPV6_PORT_UNREACH,\r\n0);\r\n} else\r\n#endif\r\nicmp_send(skb,\r\nICMP_DEST_UNREACH,\r\nICMP_PORT_UNREACH, 0);\r\nreturn NF_DROP;\r\n}\r\n}\r\n}\r\nIP_VS_DBG_PKT(12, af, pp, skb, iph.off,\r\n"ip_vs_out: packet continues traversal as normal");\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int\r\nip_vs_reply4(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_out(net_ipvs(state->net), state->hook, skb, AF_INET);\r\n}\r\nstatic unsigned int\r\nip_vs_local_reply4(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_out(net_ipvs(state->net), state->hook, skb, AF_INET);\r\n}\r\nstatic unsigned int\r\nip_vs_reply6(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_out(net_ipvs(state->net), state->hook, skb, AF_INET6);\r\n}\r\nstatic unsigned int\r\nip_vs_local_reply6(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_out(net_ipvs(state->net), state->hook, skb, AF_INET6);\r\n}\r\nstatic unsigned int\r\nip_vs_try_to_schedule(struct netns_ipvs *ipvs, int af, struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct ip_vs_protocol *pp = pd->pp;\r\nif (!iph->fragoffs) {\r\nif (!pp->conn_schedule(ipvs, af, skb, pd, verdict, cpp, iph))\r\nreturn 0;\r\n}\r\nif (unlikely(!*cpp)) {\r\nIP_VS_DBG_PKT(12, af, pp, skb, iph->off,\r\n"ip_vs_in: packet continues traversal as normal");\r\nif (iph->fragoffs) {\r\nIP_VS_DBG_RL("Unhandled frag, load nf_defrag_ipv6\n");\r\nIP_VS_DBG_PKT(7, af, pp, skb, iph->off,\r\n"unhandled fragment");\r\n}\r\n*verdict = NF_ACCEPT;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nip_vs_in_icmp(struct netns_ipvs *ipvs, struct sk_buff *skb, int *related,\r\nunsigned int hooknum)\r\n{\r\nstruct iphdr *iph;\r\nstruct icmphdr _icmph, *ic;\r\nstruct iphdr _ciph, *cih;\r\nstruct ip_vs_iphdr ciph;\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_protocol *pp;\r\nstruct ip_vs_proto_data *pd;\r\nunsigned int offset, offset2, ihl, verdict;\r\nbool ipip, new_cp = false;\r\n*related = 1;\r\nif (ip_is_fragment(ip_hdr(skb))) {\r\nif (ip_vs_gather_frags(ipvs, skb, ip_vs_defrag_user(hooknum)))\r\nreturn NF_STOLEN;\r\n}\r\niph = ip_hdr(skb);\r\noffset = ihl = iph->ihl * 4;\r\nic = skb_header_pointer(skb, offset, sizeof(_icmph), &_icmph);\r\nif (ic == NULL)\r\nreturn NF_DROP;\r\nIP_VS_DBG(12, "Incoming ICMP (%d,%d) %pI4->%pI4\n",\r\nic->type, ntohs(icmp_id(ic)),\r\n&iph->saddr, &iph->daddr);\r\nif ((ic->type != ICMP_DEST_UNREACH) &&\r\n(ic->type != ICMP_SOURCE_QUENCH) &&\r\n(ic->type != ICMP_TIME_EXCEEDED)) {\r\n*related = 0;\r\nreturn NF_ACCEPT;\r\n}\r\noffset += sizeof(_icmph);\r\ncih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\r\nif (cih == NULL)\r\nreturn NF_ACCEPT;\r\nipip = false;\r\nif (cih->protocol == IPPROTO_IPIP) {\r\nif (unlikely(cih->frag_off & htons(IP_OFFSET)))\r\nreturn NF_ACCEPT;\r\nif (!(skb_rtable(skb)->rt_flags & RTCF_LOCAL))\r\nreturn NF_ACCEPT;\r\noffset += cih->ihl * 4;\r\ncih = skb_header_pointer(skb, offset, sizeof(_ciph), &_ciph);\r\nif (cih == NULL)\r\nreturn NF_ACCEPT;\r\nipip = true;\r\n}\r\npd = ip_vs_proto_data_get(ipvs, cih->protocol);\r\nif (!pd)\r\nreturn NF_ACCEPT;\r\npp = pd->pp;\r\nif (unlikely(cih->frag_off & htons(IP_OFFSET) &&\r\npp->dont_defrag))\r\nreturn NF_ACCEPT;\r\nIP_VS_DBG_PKT(11, AF_INET, pp, skb, offset,\r\n"Checking incoming ICMP for");\r\noffset2 = offset;\r\nip_vs_fill_iph_skb_icmp(AF_INET, skb, offset, !ipip, &ciph);\r\noffset = ciph.len;\r\ncp = pp->conn_in_get(ipvs, AF_INET, skb, &ciph);\r\nif (!cp) {\r\nint v;\r\nif (!sysctl_schedule_icmp(ipvs))\r\nreturn NF_ACCEPT;\r\nif (!ip_vs_try_to_schedule(ipvs, AF_INET, skb, pd, &v, &cp, &ciph))\r\nreturn v;\r\nnew_cp = true;\r\n}\r\nverdict = NF_DROP;\r\nif (!skb_csum_unnecessary(skb) && ip_vs_checksum_complete(skb, ihl)) {\r\nIP_VS_DBG(1, "Incoming ICMP: failed checksum from %pI4!\n",\r\n&iph->saddr);\r\ngoto out;\r\n}\r\nif (ipip) {\r\n__be32 info = ic->un.gateway;\r\n__u8 type = ic->type;\r\n__u8 code = ic->code;\r\nif (ic->type == ICMP_DEST_UNREACH &&\r\nic->code == ICMP_FRAG_NEEDED) {\r\nstruct ip_vs_dest *dest = cp->dest;\r\nu32 mtu = ntohs(ic->un.frag.mtu);\r\n__be16 frag_off = cih->frag_off;\r\nif (pskb_pull(skb, ihl + sizeof(_icmph)) == NULL)\r\ngoto ignore_ipip;\r\noffset2 -= ihl + sizeof(_icmph);\r\nskb_reset_network_header(skb);\r\nIP_VS_DBG(12, "ICMP for IPIP %pI4->%pI4: mtu=%u\n",\r\n&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr, mtu);\r\nipv4_update_pmtu(skb, ipvs->net,\r\nmtu, 0, 0, 0, 0);\r\nif (!(frag_off & htons(IP_DF)))\r\ngoto ignore_ipip;\r\nif (dest) {\r\nstruct ip_vs_dest_dst *dest_dst;\r\nrcu_read_lock();\r\ndest_dst = rcu_dereference(dest->dest_dst);\r\nif (dest_dst)\r\nmtu = dst_mtu(dest_dst->dst_cache);\r\nrcu_read_unlock();\r\n}\r\nif (mtu > 68 + sizeof(struct iphdr))\r\nmtu -= sizeof(struct iphdr);\r\ninfo = htonl(mtu);\r\n}\r\nif (pskb_pull(skb, offset2) == NULL)\r\ngoto ignore_ipip;\r\nskb_reset_network_header(skb);\r\nIP_VS_DBG(12, "Sending ICMP for %pI4->%pI4: t=%u, c=%u, i=%u\n",\r\n&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,\r\ntype, code, ntohl(info));\r\nicmp_send(skb, type, code, info);\r\nip_vs_out_stats(cp, skb);\r\nignore_ipip:\r\nconsume_skb(skb);\r\nverdict = NF_STOLEN;\r\ngoto out;\r\n}\r\nip_vs_in_stats(cp, skb);\r\nif (IPPROTO_TCP == cih->protocol || IPPROTO_UDP == cih->protocol ||\r\nIPPROTO_SCTP == cih->protocol)\r\noffset += 2 * sizeof(__u16);\r\nverdict = ip_vs_icmp_xmit(skb, cp, pp, offset, hooknum, &ciph);\r\nout:\r\nif (likely(!new_cp))\r\n__ip_vs_conn_put(cp);\r\nelse\r\nip_vs_conn_put(cp);\r\nreturn verdict;\r\n}\r\nstatic int ip_vs_in_icmp_v6(struct netns_ipvs *ipvs, struct sk_buff *skb,\r\nint *related, unsigned int hooknum,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct icmp6hdr _icmph, *ic;\r\nstruct ip_vs_iphdr ciph = {.flags = 0, .fragoffs = 0};\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_protocol *pp;\r\nstruct ip_vs_proto_data *pd;\r\nunsigned int offset, verdict;\r\nbool new_cp = false;\r\n*related = 1;\r\nic = frag_safe_skb_hp(skb, iph->len, sizeof(_icmph), &_icmph, iph);\r\nif (ic == NULL)\r\nreturn NF_DROP;\r\nif (ic->icmp6_type & ICMPV6_INFOMSG_MASK) {\r\n*related = 0;\r\nreturn NF_ACCEPT;\r\n}\r\nif (iph->flags & IP6_FH_F_FRAG)\r\nreturn NF_DROP;\r\nIP_VS_DBG(8, "Incoming ICMPv6 (%d,%d) %pI6c->%pI6c\n",\r\nic->icmp6_type, ntohs(icmpv6_id(ic)),\r\n&iph->saddr, &iph->daddr);\r\noffset = iph->len + sizeof(_icmph);\r\nif (!ip_vs_fill_iph_skb_icmp(AF_INET6, skb, offset, true, &ciph))\r\nreturn NF_ACCEPT;\r\npd = ip_vs_proto_data_get(ipvs, ciph.protocol);\r\nif (!pd)\r\nreturn NF_ACCEPT;\r\npp = pd->pp;\r\nif (ciph.fragoffs)\r\nreturn NF_ACCEPT;\r\nIP_VS_DBG_PKT(11, AF_INET6, pp, skb, offset,\r\n"Checking incoming ICMPv6 for");\r\ncp = pp->conn_in_get(ipvs, AF_INET6, skb, &ciph);\r\nif (!cp) {\r\nint v;\r\nif (!sysctl_schedule_icmp(ipvs))\r\nreturn NF_ACCEPT;\r\nif (!ip_vs_try_to_schedule(ipvs, AF_INET6, skb, pd, &v, &cp, &ciph))\r\nreturn v;\r\nnew_cp = true;\r\n}\r\nif ((hooknum == NF_INET_LOCAL_OUT) &&\r\n(IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)) {\r\nverdict = NF_ACCEPT;\r\ngoto out;\r\n}\r\nip_vs_in_stats(cp, skb);\r\noffset = ciph.len;\r\nif (IPPROTO_TCP == ciph.protocol || IPPROTO_UDP == ciph.protocol ||\r\nIPPROTO_SCTP == ciph.protocol)\r\noffset += 2 * sizeof(__u16);\r\nverdict = ip_vs_icmp_xmit_v6(skb, cp, pp, offset, hooknum, &ciph);\r\nout:\r\nif (likely(!new_cp))\r\n__ip_vs_conn_put(cp);\r\nelse\r\nip_vs_conn_put(cp);\r\nreturn verdict;\r\n}\r\nstatic unsigned int\r\nip_vs_in(struct netns_ipvs *ipvs, unsigned int hooknum, struct sk_buff *skb, int af)\r\n{\r\nstruct ip_vs_iphdr iph;\r\nstruct ip_vs_protocol *pp;\r\nstruct ip_vs_proto_data *pd;\r\nstruct ip_vs_conn *cp;\r\nint ret, pkts;\r\nint conn_reuse_mode;\r\nstruct sock *sk;\r\nif (skb->ipvs_property)\r\nreturn NF_ACCEPT;\r\nif (unlikely((skb->pkt_type != PACKET_HOST &&\r\nhooknum != NF_INET_LOCAL_OUT) ||\r\n!skb_dst(skb))) {\r\nip_vs_fill_iph_skb(af, skb, false, &iph);\r\nIP_VS_DBG_BUF(12, "packet type=%d proto=%d daddr=%s"\r\n" ignored in hook %u\n",\r\nskb->pkt_type, iph.protocol,\r\nIP_VS_DBG_ADDR(af, &iph.daddr), hooknum);\r\nreturn NF_ACCEPT;\r\n}\r\nif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\r\nreturn NF_ACCEPT;\r\nip_vs_fill_iph_skb(af, skb, false, &iph);\r\nsk = skb_to_full_sk(skb);\r\nif (unlikely(sk && hooknum == NF_INET_LOCAL_OUT &&\r\naf == AF_INET)) {\r\nif (sk->sk_family == PF_INET && inet_sk(sk)->nodefrag)\r\nreturn NF_ACCEPT;\r\n}\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nif (unlikely(iph.protocol == IPPROTO_ICMPV6)) {\r\nint related;\r\nint verdict = ip_vs_in_icmp_v6(ipvs, skb, &related,\r\nhooknum, &iph);\r\nif (related)\r\nreturn verdict;\r\n}\r\n} else\r\n#endif\r\nif (unlikely(iph.protocol == IPPROTO_ICMP)) {\r\nint related;\r\nint verdict = ip_vs_in_icmp(ipvs, skb, &related,\r\nhooknum);\r\nif (related)\r\nreturn verdict;\r\n}\r\npd = ip_vs_proto_data_get(ipvs, iph.protocol);\r\nif (unlikely(!pd)) {\r\nif (sysctl_ignore_tunneled(ipvs))\r\nskb->ipvs_property = 1;\r\nreturn NF_ACCEPT;\r\n}\r\npp = pd->pp;\r\ncp = pp->conn_in_get(ipvs, af, skb, &iph);\r\nconn_reuse_mode = sysctl_conn_reuse_mode(ipvs);\r\nif (conn_reuse_mode && !iph.fragoffs && is_new_conn(skb, &iph) && cp) {\r\nbool uses_ct = false, resched = false;\r\nif (unlikely(sysctl_expire_nodest_conn(ipvs)) && cp->dest &&\r\nunlikely(!atomic_read(&cp->dest->weight))) {\r\nresched = true;\r\nuses_ct = ip_vs_conn_uses_conntrack(cp, skb);\r\n} else if (is_new_conn_expected(cp, conn_reuse_mode)) {\r\nuses_ct = ip_vs_conn_uses_conntrack(cp, skb);\r\nif (!atomic_read(&cp->n_control)) {\r\nresched = true;\r\n} else {\r\nresched = !uses_ct;\r\n}\r\n}\r\nif (resched) {\r\nif (!atomic_read(&cp->n_control))\r\nip_vs_conn_expire_now(cp);\r\n__ip_vs_conn_put(cp);\r\nif (uses_ct)\r\nreturn NF_DROP;\r\ncp = NULL;\r\n}\r\n}\r\nif (unlikely(!cp)) {\r\nint v;\r\nif (!ip_vs_try_to_schedule(ipvs, af, skb, pd, &v, &cp, &iph))\r\nreturn v;\r\n}\r\nIP_VS_DBG_PKT(11, af, pp, skb, iph.off, "Incoming packet");\r\nif (cp->dest && !(cp->dest->flags & IP_VS_DEST_F_AVAILABLE)) {\r\nif (sysctl_expire_nodest_conn(ipvs)) {\r\nip_vs_conn_expire_now(cp);\r\n}\r\n__ip_vs_conn_put(cp);\r\nreturn NF_DROP;\r\n}\r\nip_vs_in_stats(cp, skb);\r\nip_vs_set_state(cp, IP_VS_DIR_INPUT, skb, pd);\r\nif (cp->packet_xmit)\r\nret = cp->packet_xmit(skb, cp, pp, &iph);\r\nelse {\r\nIP_VS_DBG_RL("warning: packet_xmit is null");\r\nret = NF_ACCEPT;\r\n}\r\nif (cp->flags & IP_VS_CONN_F_ONE_PACKET)\r\npkts = sysctl_sync_threshold(ipvs);\r\nelse\r\npkts = atomic_add_return(1, &cp->in_pkts);\r\nif (ipvs->sync_state & IP_VS_STATE_MASTER)\r\nip_vs_sync_conn(ipvs, cp, pkts);\r\nelse if ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && cp->control)\r\natomic_inc(&cp->control->in_pkts);\r\nip_vs_conn_put(cp);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nip_vs_remote_request4(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_in(net_ipvs(state->net), state->hook, skb, AF_INET);\r\n}\r\nstatic unsigned int\r\nip_vs_local_request4(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_in(net_ipvs(state->net), state->hook, skb, AF_INET);\r\n}\r\nstatic unsigned int\r\nip_vs_remote_request6(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_in(net_ipvs(state->net), state->hook, skb, AF_INET6);\r\n}\r\nstatic unsigned int\r\nip_vs_local_request6(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn ip_vs_in(net_ipvs(state->net), state->hook, skb, AF_INET6);\r\n}\r\nstatic unsigned int\r\nip_vs_forward_icmp(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nint r;\r\nstruct netns_ipvs *ipvs = net_ipvs(state->net);\r\nif (ip_hdr(skb)->protocol != IPPROTO_ICMP)\r\nreturn NF_ACCEPT;\r\nif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\r\nreturn NF_ACCEPT;\r\nreturn ip_vs_in_icmp(ipvs, skb, &r, state->hook);\r\n}\r\nstatic unsigned int\r\nip_vs_forward_icmp_v6(void *priv, struct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nint r;\r\nstruct netns_ipvs *ipvs = net_ipvs(state->net);\r\nstruct ip_vs_iphdr iphdr;\r\nip_vs_fill_iph_skb(AF_INET6, skb, false, &iphdr);\r\nif (iphdr.protocol != IPPROTO_ICMPV6)\r\nreturn NF_ACCEPT;\r\nif (unlikely(sysctl_backup_only(ipvs) || !ipvs->enable))\r\nreturn NF_ACCEPT;\r\nreturn ip_vs_in_icmp_v6(ipvs, skb, &r, state->hook, &iphdr);\r\n}\r\nstatic int __net_init __ip_vs_init(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs;\r\nipvs = net_generic(net, ip_vs_net_id);\r\nif (ipvs == NULL)\r\nreturn -ENOMEM;\r\nipvs->enable = 0;\r\nipvs->net = net;\r\nipvs->gen = atomic_read(&ipvs_netns_cnt);\r\natomic_inc(&ipvs_netns_cnt);\r\nnet->ipvs = ipvs;\r\nif (ip_vs_estimator_net_init(ipvs) < 0)\r\ngoto estimator_fail;\r\nif (ip_vs_control_net_init(ipvs) < 0)\r\ngoto control_fail;\r\nif (ip_vs_protocol_net_init(ipvs) < 0)\r\ngoto protocol_fail;\r\nif (ip_vs_app_net_init(ipvs) < 0)\r\ngoto app_fail;\r\nif (ip_vs_conn_net_init(ipvs) < 0)\r\ngoto conn_fail;\r\nif (ip_vs_sync_net_init(ipvs) < 0)\r\ngoto sync_fail;\r\nprintk(KERN_INFO "IPVS: Creating netns size=%zu id=%d\n",\r\nsizeof(struct netns_ipvs), ipvs->gen);\r\nreturn 0;\r\nsync_fail:\r\nip_vs_conn_net_cleanup(ipvs);\r\nconn_fail:\r\nip_vs_app_net_cleanup(ipvs);\r\napp_fail:\r\nip_vs_protocol_net_cleanup(ipvs);\r\nprotocol_fail:\r\nip_vs_control_net_cleanup(ipvs);\r\ncontrol_fail:\r\nip_vs_estimator_net_cleanup(ipvs);\r\nestimator_fail:\r\nnet->ipvs = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit __ip_vs_cleanup(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nip_vs_service_net_cleanup(ipvs);\r\nip_vs_conn_net_cleanup(ipvs);\r\nip_vs_app_net_cleanup(ipvs);\r\nip_vs_protocol_net_cleanup(ipvs);\r\nip_vs_control_net_cleanup(ipvs);\r\nip_vs_estimator_net_cleanup(ipvs);\r\nIP_VS_DBG(2, "ipvs netns %d released\n", ipvs->gen);\r\nnet->ipvs = NULL;\r\n}\r\nstatic void __net_exit __ip_vs_dev_cleanup(struct net *net)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nEnterFunction(2);\r\nipvs->enable = 0;\r\nsmp_wmb();\r\nip_vs_sync_net_cleanup(ipvs);\r\nLeaveFunction(2);\r\n}\r\nstatic int __init ip_vs_init(void)\r\n{\r\nint ret;\r\nret = ip_vs_control_init();\r\nif (ret < 0) {\r\npr_err("can't setup control.\n");\r\ngoto exit;\r\n}\r\nip_vs_protocol_init();\r\nret = ip_vs_conn_init();\r\nif (ret < 0) {\r\npr_err("can't setup connection table.\n");\r\ngoto cleanup_protocol;\r\n}\r\nret = register_pernet_subsys(&ipvs_core_ops);\r\nif (ret < 0)\r\ngoto cleanup_conn;\r\nret = register_pernet_device(&ipvs_core_dev_ops);\r\nif (ret < 0)\r\ngoto cleanup_sub;\r\nret = nf_register_hooks(ip_vs_ops, ARRAY_SIZE(ip_vs_ops));\r\nif (ret < 0) {\r\npr_err("can't register hooks.\n");\r\ngoto cleanup_dev;\r\n}\r\nret = ip_vs_register_nl_ioctl();\r\nif (ret < 0) {\r\npr_err("can't register netlink/ioctl.\n");\r\ngoto cleanup_hooks;\r\n}\r\npr_info("ipvs loaded.\n");\r\nreturn ret;\r\ncleanup_hooks:\r\nnf_unregister_hooks(ip_vs_ops, ARRAY_SIZE(ip_vs_ops));\r\ncleanup_dev:\r\nunregister_pernet_device(&ipvs_core_dev_ops);\r\ncleanup_sub:\r\nunregister_pernet_subsys(&ipvs_core_ops);\r\ncleanup_conn:\r\nip_vs_conn_cleanup();\r\ncleanup_protocol:\r\nip_vs_protocol_cleanup();\r\nip_vs_control_cleanup();\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void __exit ip_vs_cleanup(void)\r\n{\r\nip_vs_unregister_nl_ioctl();\r\nnf_unregister_hooks(ip_vs_ops, ARRAY_SIZE(ip_vs_ops));\r\nunregister_pernet_device(&ipvs_core_dev_ops);\r\nunregister_pernet_subsys(&ipvs_core_ops);\r\nip_vs_conn_cleanup();\r\nip_vs_protocol_cleanup();\r\nip_vs_control_cleanup();\r\npr_info("ipvs unloaded.\n");\r\n}
