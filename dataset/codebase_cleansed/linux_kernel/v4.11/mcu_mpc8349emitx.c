static int shutdown_thread_fn(void *data)\r\n{\r\nint ret;\r\nstruct mcu *mcu = glob_mcu;\r\nwhile (!kthread_should_stop()) {\r\nret = i2c_smbus_read_byte_data(mcu->client, MCU_REG_CTRL);\r\nif (ret < 0)\r\npr_err("MCU status reg read failed.\n");\r\nmcu->reg_ctrl = ret;\r\nif (mcu->reg_ctrl & MCU_CTRL_BTN) {\r\ni2c_smbus_write_byte_data(mcu->client, MCU_REG_CTRL,\r\nmcu->reg_ctrl & ~MCU_CTRL_BTN);\r\nctrl_alt_del();\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t show_status(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nstruct mcu *mcu = glob_mcu;\r\nret = i2c_smbus_read_byte_data(mcu->client, MCU_REG_CTRL);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nmcu->reg_ctrl = ret;\r\nreturn sprintf(buf, "%02x\n", ret);\r\n}\r\nstatic void mcu_power_off(void)\r\n{\r\nstruct mcu *mcu = glob_mcu;\r\npr_info("Sending power-off request to the MCU...\n");\r\nmutex_lock(&mcu->lock);\r\ni2c_smbus_write_byte_data(mcu->client, MCU_REG_CTRL,\r\nmcu->reg_ctrl | MCU_CTRL_POFF);\r\nmutex_unlock(&mcu->lock);\r\n}\r\nstatic void mcu_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct mcu *mcu = gpiochip_get_data(gc);\r\nu8 bit = 1 << (4 + gpio);\r\nmutex_lock(&mcu->lock);\r\nif (val)\r\nmcu->reg_ctrl &= ~bit;\r\nelse\r\nmcu->reg_ctrl |= bit;\r\ni2c_smbus_write_byte_data(mcu->client, MCU_REG_CTRL, mcu->reg_ctrl);\r\nmutex_unlock(&mcu->lock);\r\n}\r\nstatic int mcu_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nmcu_gpio_set(gc, gpio, val);\r\nreturn 0;\r\n}\r\nstatic int mcu_gpiochip_add(struct mcu *mcu)\r\n{\r\nstruct device_node *np;\r\nstruct gpio_chip *gc = &mcu->gc;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mcu-mpc8349emitx");\r\nif (!np)\r\nreturn -ENODEV;\r\ngc->owner = THIS_MODULE;\r\ngc->label = np->full_name;\r\ngc->can_sleep = 1;\r\ngc->ngpio = MCU_NUM_GPIO;\r\ngc->base = -1;\r\ngc->set = mcu_gpio_set;\r\ngc->direction_output = mcu_gpio_dir_out;\r\ngc->of_node = np;\r\nreturn gpiochip_add_data(gc, mcu);\r\n}\r\nstatic int mcu_gpiochip_remove(struct mcu *mcu)\r\n{\r\ngpiochip_remove(&mcu->gc);\r\nreturn 0;\r\n}\r\nstatic int mcu_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct mcu *mcu;\r\nint ret;\r\nmcu = kzalloc(sizeof(*mcu), GFP_KERNEL);\r\nif (!mcu)\r\nreturn -ENOMEM;\r\nmutex_init(&mcu->lock);\r\nmcu->client = client;\r\ni2c_set_clientdata(client, mcu);\r\nret = i2c_smbus_read_byte_data(mcu->client, MCU_REG_CTRL);\r\nif (ret < 0)\r\ngoto err;\r\nmcu->reg_ctrl = ret;\r\nret = mcu_gpiochip_add(mcu);\r\nif (ret)\r\ngoto err;\r\nif (!pm_power_off) {\r\nglob_mcu = mcu;\r\npm_power_off = mcu_power_off;\r\ndev_info(&client->dev, "will provide power-off service\n");\r\n}\r\nif (device_create_file(&client->dev, &dev_attr_status))\r\ndev_err(&client->dev,\r\n"couldn't create device file for status\n");\r\nshutdown_thread = kthread_run(shutdown_thread_fn, NULL,\r\n"mcu-i2c-shdn");\r\nreturn 0;\r\nerr:\r\nkfree(mcu);\r\nreturn ret;\r\n}\r\nstatic int mcu_remove(struct i2c_client *client)\r\n{\r\nstruct mcu *mcu = i2c_get_clientdata(client);\r\nint ret;\r\nkthread_stop(shutdown_thread);\r\ndevice_remove_file(&client->dev, &dev_attr_status);\r\nif (glob_mcu == mcu) {\r\npm_power_off = NULL;\r\nglob_mcu = NULL;\r\n}\r\nret = mcu_gpiochip_remove(mcu);\r\nif (ret)\r\nreturn ret;\r\nkfree(mcu);\r\nreturn 0;\r\n}
