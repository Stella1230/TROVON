i40e_status i40e_init_nvm(struct i40e_hw *hw)\r\n{\r\nstruct i40e_nvm_info *nvm = &hw->nvm;\r\ni40e_status ret_code = 0;\r\nu32 fla, gens;\r\nu8 sr_size;\r\ngens = rd32(hw, I40E_GLNVM_GENS);\r\nsr_size = ((gens & I40E_GLNVM_GENS_SR_SIZE_MASK) >>\r\nI40E_GLNVM_GENS_SR_SIZE_SHIFT);\r\nnvm->sr_size = BIT(sr_size) * I40E_SR_WORDS_IN_1KB;\r\nfla = rd32(hw, I40E_GLNVM_FLA);\r\nif (fla & I40E_GLNVM_FLA_LOCKED_MASK) {\r\nnvm->timeout = I40E_MAX_NVM_TIMEOUT;\r\nnvm->blank_nvm_mode = false;\r\n} else {\r\nnvm->blank_nvm_mode = true;\r\nret_code = I40E_ERR_NVM_BLANK_MODE;\r\ni40e_debug(hw, I40E_DEBUG_NVM, "NVM init error: unsupported blank mode.\n");\r\n}\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_acquire_nvm(struct i40e_hw *hw,\r\nenum i40e_aq_resource_access_type access)\r\n{\r\ni40e_status ret_code = 0;\r\nu64 gtime, timeout;\r\nu64 time_left = 0;\r\nif (hw->nvm.blank_nvm_mode)\r\ngoto i40e_i40e_acquire_nvm_exit;\r\nret_code = i40e_aq_request_resource(hw, I40E_NVM_RESOURCE_ID, access,\r\n0, &time_left, NULL);\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\nhw->nvm.hw_semaphore_timeout = I40E_MS_TO_GTIME(time_left) + gtime;\r\nif (ret_code)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM acquire type %d failed time_left=%llu ret=%d aq_err=%d\n",\r\naccess, time_left, ret_code, hw->aq.asq_last_status);\r\nif (ret_code && time_left) {\r\ntimeout = I40E_MS_TO_GTIME(I40E_MAX_NVM_TIMEOUT) + gtime;\r\nwhile ((gtime < timeout) && time_left) {\r\nusleep_range(10000, 20000);\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\nret_code = i40e_aq_request_resource(hw,\r\nI40E_NVM_RESOURCE_ID,\r\naccess, 0, &time_left,\r\nNULL);\r\nif (!ret_code) {\r\nhw->nvm.hw_semaphore_timeout =\r\nI40E_MS_TO_GTIME(time_left) + gtime;\r\nbreak;\r\n}\r\n}\r\nif (ret_code) {\r\nhw->nvm.hw_semaphore_timeout = 0;\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM acquire timed out, wait %llu ms before trying again. status=%d aq_err=%d\n",\r\ntime_left, ret_code, hw->aq.asq_last_status);\r\n}\r\n}\r\ni40e_i40e_acquire_nvm_exit:\r\nreturn ret_code;\r\n}\r\nvoid i40e_release_nvm(struct i40e_hw *hw)\r\n{\r\nif (!hw->nvm.blank_nvm_mode)\r\ni40e_aq_release_resource(hw, I40E_NVM_RESOURCE_ID, 0, NULL);\r\n}\r\nstatic i40e_status i40e_poll_sr_srctl_done_bit(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 srctl, wait_cnt;\r\nfor (wait_cnt = 0; wait_cnt < I40E_SRRD_SRCTL_ATTEMPTS; wait_cnt++) {\r\nsrctl = rd32(hw, I40E_GLNVM_SRCTL);\r\nif (srctl & I40E_GLNVM_SRCTL_DONE_MASK) {\r\nret_code = 0;\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nif (ret_code == I40E_ERR_TIMEOUT)\r\ni40e_debug(hw, I40E_DEBUG_NVM, "Done bit in GLNVM_SRCTL not set");\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_read_nvm_word_srctl(struct i40e_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nu32 sr_reg;\r\nif (offset >= hw->nvm.sr_size) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM read error: offset %d beyond Shadow RAM limit %d\n",\r\noffset, hw->nvm.sr_size);\r\nret_code = I40E_ERR_PARAM;\r\ngoto read_nvm_exit;\r\n}\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = ((u32)offset << I40E_GLNVM_SRCTL_ADDR_SHIFT) |\r\nBIT(I40E_GLNVM_SRCTL_START_SHIFT);\r\nwr32(hw, I40E_GLNVM_SRCTL, sr_reg);\r\nret_code = i40e_poll_sr_srctl_done_bit(hw);\r\nif (!ret_code) {\r\nsr_reg = rd32(hw, I40E_GLNVM_SRDATA);\r\n*data = (u16)((sr_reg &\r\nI40E_GLNVM_SRDATA_RDDATA_MASK)\r\n>> I40E_GLNVM_SRDATA_RDDATA_SHIFT);\r\n}\r\n}\r\nif (ret_code)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM read error: Couldn't access Shadow RAM address: 0x%x\n",\r\noffset);\r\nread_nvm_exit:\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_read_nvm_aq(struct i40e_hw *hw, u8 module_pointer,\r\nu32 offset, u16 words, void *data,\r\nbool last_command)\r\n{\r\ni40e_status ret_code = I40E_ERR_NVM;\r\nstruct i40e_asq_cmd_details cmd_details;\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\nif ((offset + words) > hw->nvm.sr_size)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write error: offset %d beyond Shadow RAM limit %d\n",\r\n(offset + words), hw->nvm.sr_size);\r\nelse if (words > I40E_SR_SECTOR_SIZE_IN_WORDS)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write fail error: tried to write %d words, limit is %d.\n",\r\nwords, I40E_SR_SECTOR_SIZE_IN_WORDS);\r\nelse if (((offset + (words - 1)) / I40E_SR_SECTOR_SIZE_IN_WORDS)\r\n!= (offset / I40E_SR_SECTOR_SIZE_IN_WORDS))\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write error: cannot spread over two sectors in a single write offset=%d words=%d\n",\r\noffset, words);\r\nelse\r\nret_code = i40e_aq_read_nvm(hw, module_pointer,\r\n2 * offset,\r\n2 * words,\r\ndata, last_command, &cmd_details);\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_read_nvm_word_aq(struct i40e_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\ni40e_status ret_code = I40E_ERR_TIMEOUT;\r\nret_code = i40e_read_nvm_aq(hw, 0x0, offset, 1, data, true);\r\n*data = le16_to_cpu(*(__le16 *)data);\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_word(struct i40e_hw *hw, u16 offset,\r\nu16 *data)\r\n{\r\nenum i40e_status_code ret_code = 0;\r\nif (hw->flags & I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE) {\r\nret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (!ret_code) {\r\nret_code = i40e_read_nvm_word_aq(hw, offset, data);\r\ni40e_release_nvm(hw);\r\n}\r\n} else {\r\nret_code = i40e_read_nvm_word_srctl(hw, offset, data);\r\n}\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_read_nvm_buffer_srctl(struct i40e_hw *hw, u16 offset,\r\nu16 *words, u16 *data)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 index, word;\r\nfor (word = 0; word < *words; word++) {\r\nindex = offset + word;\r\nret_code = i40e_read_nvm_word_srctl(hw, index, &data[word]);\r\nif (ret_code)\r\nbreak;\r\n}\r\n*words = word;\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_read_nvm_buffer_aq(struct i40e_hw *hw, u16 offset,\r\nu16 *words, u16 *data)\r\n{\r\ni40e_status ret_code;\r\nu16 read_size = *words;\r\nbool last_cmd = false;\r\nu16 words_read = 0;\r\nu16 i = 0;\r\ndo {\r\nif (offset % I40E_SR_SECTOR_SIZE_IN_WORDS)\r\nread_size = min(*words,\r\n(u16)(I40E_SR_SECTOR_SIZE_IN_WORDS -\r\n(offset % I40E_SR_SECTOR_SIZE_IN_WORDS)));\r\nelse\r\nread_size = min((*words - words_read),\r\nI40E_SR_SECTOR_SIZE_IN_WORDS);\r\nif ((words_read + read_size) >= *words)\r\nlast_cmd = true;\r\nret_code = i40e_read_nvm_aq(hw, 0x0, offset, read_size,\r\ndata + words_read, last_cmd);\r\nif (ret_code)\r\ngoto read_nvm_buffer_aq_exit;\r\nwords_read += read_size;\r\noffset += read_size;\r\n} while (words_read < *words);\r\nfor (i = 0; i < *words; i++)\r\ndata[i] = le16_to_cpu(((__le16 *)data)[i]);\r\nread_nvm_buffer_aq_exit:\r\n*words = words_read;\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_read_nvm_buffer(struct i40e_hw *hw, u16 offset,\r\nu16 *words, u16 *data)\r\n{\r\nenum i40e_status_code ret_code = 0;\r\nif (hw->flags & I40E_HW_FLAG_AQ_SRCTL_ACCESS_ENABLE) {\r\nret_code = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (!ret_code) {\r\nret_code = i40e_read_nvm_buffer_aq(hw, offset, words,\r\ndata);\r\ni40e_release_nvm(hw);\r\n}\r\n} else {\r\nret_code = i40e_read_nvm_buffer_srctl(hw, offset, words, data);\r\n}\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_write_nvm_aq(struct i40e_hw *hw, u8 module_pointer,\r\nu32 offset, u16 words, void *data,\r\nbool last_command)\r\n{\r\ni40e_status ret_code = I40E_ERR_NVM;\r\nstruct i40e_asq_cmd_details cmd_details;\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\ncmd_details.wb_desc = &hw->nvm_wb_desc;\r\nif ((offset + words) > hw->nvm.sr_size)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write error: offset %d beyond Shadow RAM limit %d\n",\r\n(offset + words), hw->nvm.sr_size);\r\nelse if (words > I40E_SR_SECTOR_SIZE_IN_WORDS)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write fail error: tried to write %d words, limit is %d.\n",\r\nwords, I40E_SR_SECTOR_SIZE_IN_WORDS);\r\nelse if (((offset + (words - 1)) / I40E_SR_SECTOR_SIZE_IN_WORDS)\r\n!= (offset / I40E_SR_SECTOR_SIZE_IN_WORDS))\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVM write error: cannot spread over two sectors in a single write offset=%d words=%d\n",\r\noffset, words);\r\nelse\r\nret_code = i40e_aq_update_nvm(hw, module_pointer,\r\n2 * offset,\r\n2 * words,\r\ndata, last_command, &cmd_details);\r\nreturn ret_code;\r\n}\r\nstatic i40e_status i40e_calc_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code;\r\nstruct i40e_virt_mem vmem;\r\nu16 pcie_alt_module = 0;\r\nu16 checksum_local = 0;\r\nu16 vpd_module = 0;\r\nu16 *data;\r\nu16 i = 0;\r\nret_code = i40e_allocate_virt_mem(hw, &vmem,\r\nI40E_SR_SECTOR_SIZE_IN_WORDS * sizeof(u16));\r\nif (ret_code)\r\ngoto i40e_calc_nvm_checksum_exit;\r\ndata = (u16 *)vmem.va;\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_VPD_PTR, &vpd_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nret_code = i40e_read_nvm_word(hw, I40E_SR_PCIE_ALT_AUTO_LOAD_PTR,\r\n&pcie_alt_module);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\nfor (i = 0; i < hw->nvm.sr_size; i++) {\r\nif ((i % I40E_SR_SECTOR_SIZE_IN_WORDS) == 0) {\r\nu16 words = I40E_SR_SECTOR_SIZE_IN_WORDS;\r\nret_code = i40e_read_nvm_buffer(hw, i, &words, data);\r\nif (ret_code) {\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\ngoto i40e_calc_nvm_checksum_exit;\r\n}\r\n}\r\nif (i == I40E_SR_SW_CHECKSUM_WORD)\r\ncontinue;\r\nif ((i >= (u32)vpd_module) &&\r\n(i < ((u32)vpd_module +\r\n(I40E_SR_VPD_MODULE_MAX_SIZE / 2)))) {\r\ncontinue;\r\n}\r\nif ((i >= (u32)pcie_alt_module) &&\r\n(i < ((u32)pcie_alt_module +\r\n(I40E_SR_PCIE_ALT_MODULE_MAX_SIZE / 2)))) {\r\ncontinue;\r\n}\r\nchecksum_local += data[i % I40E_SR_SECTOR_SIZE_IN_WORDS];\r\n}\r\n*checksum = (u16)I40E_SR_SW_CHECKSUM_BASE - checksum_local;\r\ni40e_calc_nvm_checksum_exit:\r\ni40e_free_virt_mem(hw, &vmem);\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_update_nvm_checksum(struct i40e_hw *hw)\r\n{\r\ni40e_status ret_code;\r\nu16 checksum;\r\n__le16 le_sum;\r\nret_code = i40e_calc_nvm_checksum(hw, &checksum);\r\nif (!ret_code) {\r\nle_sum = cpu_to_le16(checksum);\r\nret_code = i40e_write_nvm_aq(hw, 0x00, I40E_SR_SW_CHECKSUM_WORD,\r\n1, &le_sum, true);\r\n}\r\nreturn ret_code;\r\n}\r\ni40e_status i40e_validate_nvm_checksum(struct i40e_hw *hw,\r\nu16 *checksum)\r\n{\r\ni40e_status ret_code = 0;\r\nu16 checksum_sr = 0;\r\nu16 checksum_local = 0;\r\nret_code = i40e_calc_nvm_checksum(hw, &checksum_local);\r\nif (ret_code)\r\ngoto i40e_validate_nvm_checksum_exit;\r\ni40e_read_nvm_word(hw, I40E_SR_SW_CHECKSUM_WORD, &checksum_sr);\r\nif (checksum_local != checksum_sr)\r\nret_code = I40E_ERR_NVM_CHECKSUM;\r\nif (checksum)\r\n*checksum = checksum_local;\r\ni40e_validate_nvm_checksum_exit:\r\nreturn ret_code;\r\n}\r\nstatic inline u8 i40e_nvmupd_get_module(u32 val)\r\n{\r\nreturn (u8)(val & I40E_NVM_MOD_PNT_MASK);\r\n}\r\nstatic inline u8 i40e_nvmupd_get_transaction(u32 val)\r\n{\r\nreturn (u8)((val & I40E_NVM_TRANS_MASK) >> I40E_NVM_TRANS_SHIFT);\r\n}\r\ni40e_status i40e_nvmupd_command(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\ni40e_status status;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\n*perrno = 0;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\r\ni40e_debug(hw, I40E_DEBUG_NVM, "%s state %d nvm_release_on_hold %d opc 0x%04x cmd 0x%08x config 0x%08x offset 0x%08x data_size 0x%08x\n",\r\ni40e_nvm_update_state_str[upd_cmd],\r\nhw->nvmupd_state,\r\nhw->nvm_release_on_done, hw->nvm_wait_opcode,\r\ncmd->command, cmd->config, cmd->offset, cmd->data_size);\r\nif (upd_cmd == I40E_NVMUPD_INVALID) {\r\n*perrno = -EFAULT;\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_validate_command returns %d errno %d\n",\r\nupd_cmd, *perrno);\r\n}\r\nif (upd_cmd == I40E_NVMUPD_STATUS) {\r\nif (!cmd->data_size) {\r\n*perrno = -EFAULT;\r\nreturn I40E_ERR_BUF_TOO_SHORT;\r\n}\r\nbytes[0] = hw->nvmupd_state;\r\nif (cmd->data_size >= 4) {\r\nbytes[1] = 0;\r\n*((u16 *)&bytes[2]) = hw->nvm_wait_opcode;\r\n}\r\nif (hw->nvmupd_state == I40E_NVMUPD_STATE_ERROR)\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\nreturn 0;\r\n}\r\nif (hw->nvmupd_state == I40E_NVMUPD_STATE_ERROR) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"Clearing I40E_NVMUPD_STATE_ERROR state without reading\n");\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n}\r\nswitch (hw->nvmupd_state) {\r\ncase I40E_NVMUPD_STATE_INIT:\r\nstatus = i40e_nvmupd_state_init(hw, cmd, bytes, perrno);\r\nbreak;\r\ncase I40E_NVMUPD_STATE_READING:\r\nstatus = i40e_nvmupd_state_reading(hw, cmd, bytes, perrno);\r\nbreak;\r\ncase I40E_NVMUPD_STATE_WRITING:\r\nstatus = i40e_nvmupd_state_writing(hw, cmd, bytes, perrno);\r\nbreak;\r\ncase I40E_NVMUPD_STATE_INIT_WAIT:\r\ncase I40E_NVMUPD_STATE_WRITE_WAIT:\r\nif (cmd->offset == 0xffff) {\r\ni40e_nvmupd_check_wait_event(hw, hw->nvm_wait_opcode);\r\nreturn 0;\r\n}\r\nstatus = I40E_ERR_NOT_READY;\r\n*perrno = -EBUSY;\r\nbreak;\r\ndefault:\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: no such state %d\n", hw->nvmupd_state);\r\nstatus = I40E_NOT_SUPPORTED;\r\n*perrno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_init(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\ni40e_status status = 0;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_READ_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\r\ni40e_release_nvm(hw);\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_READ_SNT:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_READ);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\r\nif (status)\r\ni40e_release_nvm(hw);\r\nelse\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_READING;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_ERA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_erase(hw, cmd, perrno);\r\nif (status) {\r\ni40e_release_nvm(hw);\r\n} else {\r\nhw->nvm_release_on_done = true;\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_erase;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\r\nif (status) {\r\ni40e_release_nvm(hw);\r\n} else {\r\nhw->nvm_release_on_done = true;\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_SNT:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\r\nif (status) {\r\ni40e_release_nvm(hw);\r\n} else {\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\r\n}\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_SA:\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\n*perrno = i40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status);\r\n} else {\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status) {\r\n*perrno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status) :\r\n-EIO;\r\ni40e_release_nvm(hw);\r\n} else {\r\nhw->nvm_release_on_done = true;\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_EXEC_AQ:\r\nstatus = i40e_nvmupd_exec_aq(hw, cmd, bytes, perrno);\r\nbreak;\r\ncase I40E_NVMUPD_GET_AQ_RESULT:\r\nstatus = i40e_nvmupd_get_aq_result(hw, cmd, bytes, perrno);\r\nbreak;\r\ndefault:\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: bad cmd %s in init state\n",\r\ni40e_nvm_update_state_str[upd_cmd]);\r\nstatus = I40E_ERR_NVM;\r\n*perrno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_reading(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\ni40e_status status = 0;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_READ_SA:\r\ncase I40E_NVMUPD_READ_CON:\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\r\nbreak;\r\ncase I40E_NVMUPD_READ_LCB:\r\nstatus = i40e_nvmupd_nvm_read(hw, cmd, bytes, perrno);\r\ni40e_release_nvm(hw);\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\nbreak;\r\ndefault:\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: bad cmd %s in reading state.\n",\r\ni40e_nvm_update_state_str[upd_cmd]);\r\nstatus = I40E_NOT_SUPPORTED;\r\n*perrno = -ESRCH;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_state_writing(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\ni40e_status status = 0;\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nbool retry_attempt = false;\r\nupd_cmd = i40e_nvmupd_validate_command(hw, cmd, perrno);\r\nretry:\r\nswitch (upd_cmd) {\r\ncase I40E_NVMUPD_WRITE_CON:\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\r\nif (!status) {\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_WRITE_LCB:\r\nstatus = i40e_nvmupd_nvm_write(hw, cmd, bytes, perrno);\r\nif (status) {\r\n*perrno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status) :\r\n-EIO;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n} else {\r\nhw->nvm_release_on_done = true;\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_CON:\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status) {\r\n*perrno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status) :\r\n-EIO;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n} else {\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_WRITE_WAIT;\r\n}\r\nbreak;\r\ncase I40E_NVMUPD_CSUM_LCB:\r\nstatus = i40e_update_nvm_checksum(hw);\r\nif (status) {\r\n*perrno = hw->aq.asq_last_status ?\r\ni40e_aq_rc_to_posix(status,\r\nhw->aq.asq_last_status) :\r\n-EIO;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\n} else {\r\nhw->nvm_release_on_done = true;\r\nhw->nvm_wait_opcode = i40e_aqc_opc_nvm_update;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\nbreak;\r\ndefault:\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: bad cmd %s in writing state.\n",\r\ni40e_nvm_update_state_str[upd_cmd]);\r\nstatus = I40E_NOT_SUPPORTED;\r\n*perrno = -ESRCH;\r\nbreak;\r\n}\r\nif (status && (hw->aq.asq_last_status == I40E_AQ_RC_EBUSY) &&\r\n!retry_attempt) {\r\ni40e_status old_status = status;\r\nu32 old_asq_status = hw->aq.asq_last_status;\r\nu32 gtime;\r\ngtime = rd32(hw, I40E_GLVFGEN_TIMER);\r\nif (gtime >= hw->nvm.hw_semaphore_timeout) {\r\ni40e_debug(hw, I40E_DEBUG_ALL,\r\n"NVMUPD: write semaphore expired (%d >= %lld), retrying\n",\r\ngtime, hw->nvm.hw_semaphore_timeout);\r\ni40e_release_nvm(hw);\r\nstatus = i40e_acquire_nvm(hw, I40E_RESOURCE_WRITE);\r\nif (status) {\r\ni40e_debug(hw, I40E_DEBUG_ALL,\r\n"NVMUPD: write semaphore reacquire failed aq_err = %d\n",\r\nhw->aq.asq_last_status);\r\nstatus = old_status;\r\nhw->aq.asq_last_status = old_asq_status;\r\n} else {\r\nretry_attempt = true;\r\ngoto retry;\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid i40e_nvmupd_check_wait_event(struct i40e_hw *hw, u16 opcode)\r\n{\r\nif (opcode == hw->nvm_wait_opcode) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: clearing wait on opcode 0x%04x\n", opcode);\r\nif (hw->nvm_release_on_done) {\r\ni40e_release_nvm(hw);\r\nhw->nvm_release_on_done = false;\r\n}\r\nhw->nvm_wait_opcode = 0;\r\nif (hw->aq.arq_last_status) {\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_ERROR;\r\nreturn;\r\n}\r\nswitch (hw->nvmupd_state) {\r\ncase I40E_NVMUPD_STATE_INIT_WAIT:\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT;\r\nbreak;\r\ncase I40E_NVMUPD_STATE_WRITE_WAIT:\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_WRITING;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum i40e_nvmupd_cmd i40e_nvmupd_validate_command(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nint *perrno)\r\n{\r\nenum i40e_nvmupd_cmd upd_cmd;\r\nu8 module, transaction;\r\nupd_cmd = I40E_NVMUPD_INVALID;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nif ((cmd->data_size < 1) ||\r\n(cmd->data_size > I40E_NVMUPD_MAX_DATA)) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_validate_command data_size %d\n",\r\ncmd->data_size);\r\n*perrno = -EFAULT;\r\nreturn I40E_NVMUPD_INVALID;\r\n}\r\nswitch (cmd->command) {\r\ncase I40E_NVM_READ:\r\nswitch (transaction) {\r\ncase I40E_NVM_CON:\r\nupd_cmd = I40E_NVMUPD_READ_CON;\r\nbreak;\r\ncase I40E_NVM_SNT:\r\nupd_cmd = I40E_NVMUPD_READ_SNT;\r\nbreak;\r\ncase I40E_NVM_LCB:\r\nupd_cmd = I40E_NVMUPD_READ_LCB;\r\nbreak;\r\ncase I40E_NVM_SA:\r\nupd_cmd = I40E_NVMUPD_READ_SA;\r\nbreak;\r\ncase I40E_NVM_EXEC:\r\nif (module == 0xf)\r\nupd_cmd = I40E_NVMUPD_STATUS;\r\nelse if (module == 0)\r\nupd_cmd = I40E_NVMUPD_GET_AQ_RESULT;\r\nbreak;\r\n}\r\nbreak;\r\ncase I40E_NVM_WRITE:\r\nswitch (transaction) {\r\ncase I40E_NVM_CON:\r\nupd_cmd = I40E_NVMUPD_WRITE_CON;\r\nbreak;\r\ncase I40E_NVM_SNT:\r\nupd_cmd = I40E_NVMUPD_WRITE_SNT;\r\nbreak;\r\ncase I40E_NVM_LCB:\r\nupd_cmd = I40E_NVMUPD_WRITE_LCB;\r\nbreak;\r\ncase I40E_NVM_SA:\r\nupd_cmd = I40E_NVMUPD_WRITE_SA;\r\nbreak;\r\ncase I40E_NVM_ERA:\r\nupd_cmd = I40E_NVMUPD_WRITE_ERA;\r\nbreak;\r\ncase I40E_NVM_CSUM:\r\nupd_cmd = I40E_NVMUPD_CSUM_CON;\r\nbreak;\r\ncase (I40E_NVM_CSUM|I40E_NVM_SA):\r\nupd_cmd = I40E_NVMUPD_CSUM_SA;\r\nbreak;\r\ncase (I40E_NVM_CSUM|I40E_NVM_LCB):\r\nupd_cmd = I40E_NVMUPD_CSUM_LCB;\r\nbreak;\r\ncase I40E_NVM_EXEC:\r\nif (module == 0)\r\nupd_cmd = I40E_NVMUPD_EXEC_AQ;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn upd_cmd;\r\n}\r\nstatic i40e_status i40e_nvmupd_exec_aq(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\nstruct i40e_asq_cmd_details cmd_details;\r\ni40e_status status;\r\nstruct i40e_aq_desc *aq_desc;\r\nu32 buff_size = 0;\r\nu8 *buff = NULL;\r\nu32 aq_desc_len;\r\nu32 aq_data_len;\r\ni40e_debug(hw, I40E_DEBUG_NVM, "NVMUPD: %s\n", __func__);\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\ncmd_details.wb_desc = &hw->nvm_wb_desc;\r\naq_desc_len = sizeof(struct i40e_aq_desc);\r\nmemset(&hw->nvm_wb_desc, 0, aq_desc_len);\r\nif (cmd->data_size < aq_desc_len) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: not enough aq desc bytes for exec, size %d < %d\n",\r\ncmd->data_size, aq_desc_len);\r\n*perrno = -EINVAL;\r\nreturn I40E_ERR_PARAM;\r\n}\r\naq_desc = (struct i40e_aq_desc *)bytes;\r\naq_data_len = cmd->data_size - aq_desc_len;\r\nbuff_size = max_t(u32, aq_data_len, le16_to_cpu(aq_desc->datalen));\r\nif (buff_size) {\r\nif (!hw->nvm_buff.va) {\r\nstatus = i40e_allocate_virt_mem(hw, &hw->nvm_buff,\r\nhw->aq.asq_buf_size);\r\nif (status)\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"NVMUPD: i40e_allocate_virt_mem for exec buff failed, %d\n",\r\nstatus);\r\n}\r\nif (hw->nvm_buff.va) {\r\nbuff = hw->nvm_buff.va;\r\nmemcpy(buff, &bytes[aq_desc_len], aq_data_len);\r\n}\r\n}\r\nstatus = i40e_asq_send_command(hw, aq_desc, buff,\r\nbuff_size, &cmd_details);\r\nif (status) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_exec_aq err %s aq_err %s\n",\r\ni40e_stat_str(hw, status),\r\ni40e_aq_str(hw, hw->aq.asq_last_status));\r\n*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\r\n}\r\nif (cmd->offset) {\r\nhw->nvm_wait_opcode = cmd->offset;\r\nhw->nvmupd_state = I40E_NVMUPD_STATE_INIT_WAIT;\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_get_aq_result(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\nu32 aq_total_len;\r\nu32 aq_desc_len;\r\nint remainder;\r\nu8 *buff;\r\ni40e_debug(hw, I40E_DEBUG_NVM, "NVMUPD: %s\n", __func__);\r\naq_desc_len = sizeof(struct i40e_aq_desc);\r\naq_total_len = aq_desc_len + le16_to_cpu(hw->nvm_wb_desc.datalen);\r\nif (cmd->offset > aq_total_len) {\r\ni40e_debug(hw, I40E_DEBUG_NVM, "%s: offset too big %d > %d\n",\r\n__func__, cmd->offset, aq_total_len);\r\n*perrno = -EINVAL;\r\nreturn I40E_ERR_PARAM;\r\n}\r\nif (cmd->data_size > (aq_total_len - cmd->offset)) {\r\nint new_len = aq_total_len - cmd->offset;\r\ni40e_debug(hw, I40E_DEBUG_NVM, "%s: copy length %d too big, trimming to %d\n",\r\n__func__, cmd->data_size, new_len);\r\ncmd->data_size = new_len;\r\n}\r\nremainder = cmd->data_size;\r\nif (cmd->offset < aq_desc_len) {\r\nu32 len = aq_desc_len - cmd->offset;\r\nlen = min(len, cmd->data_size);\r\ni40e_debug(hw, I40E_DEBUG_NVM, "%s: aq_desc bytes %d to %d\n",\r\n__func__, cmd->offset, cmd->offset + len);\r\nbuff = ((u8 *)&hw->nvm_wb_desc) + cmd->offset;\r\nmemcpy(bytes, buff, len);\r\nbytes += len;\r\nremainder -= len;\r\nbuff = hw->nvm_buff.va;\r\n} else {\r\nbuff = hw->nvm_buff.va + (cmd->offset - aq_desc_len);\r\n}\r\nif (remainder > 0) {\r\nint start_byte = buff - (u8 *)hw->nvm_buff.va;\r\ni40e_debug(hw, I40E_DEBUG_NVM, "%s: databuf bytes %d to %d\n",\r\n__func__, start_byte, start_byte + remainder);\r\nmemcpy(bytes, buff, remainder);\r\n}\r\nreturn 0;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_read(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\nstruct i40e_asq_cmd_details cmd_details;\r\ni40e_status status;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction == I40E_NVM_LCB) || (transaction == I40E_NVM_SA);\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\ncmd_details.wb_desc = &hw->nvm_wb_desc;\r\nstatus = i40e_aq_read_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\r\nbytes, last, &cmd_details);\r\nif (status) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_read mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_read status %d aq %d\n",\r\nstatus, hw->aq.asq_last_status);\r\n*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_erase(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nint *perrno)\r\n{\r\ni40e_status status = 0;\r\nstruct i40e_asq_cmd_details cmd_details;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction & I40E_NVM_LCB);\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\ncmd_details.wb_desc = &hw->nvm_wb_desc;\r\nstatus = i40e_aq_erase_nvm(hw, module, cmd->offset, (u16)cmd->data_size,\r\nlast, &cmd_details);\r\nif (status) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_erase mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_erase status %d aq %d\n",\r\nstatus, hw->aq.asq_last_status);\r\n*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\r\n}\r\nreturn status;\r\n}\r\nstatic i40e_status i40e_nvmupd_nvm_write(struct i40e_hw *hw,\r\nstruct i40e_nvm_access *cmd,\r\nu8 *bytes, int *perrno)\r\n{\r\ni40e_status status = 0;\r\nstruct i40e_asq_cmd_details cmd_details;\r\nu8 module, transaction;\r\nbool last;\r\ntransaction = i40e_nvmupd_get_transaction(cmd->config);\r\nmodule = i40e_nvmupd_get_module(cmd->config);\r\nlast = (transaction & I40E_NVM_LCB);\r\nmemset(&cmd_details, 0, sizeof(cmd_details));\r\ncmd_details.wb_desc = &hw->nvm_wb_desc;\r\nstatus = i40e_aq_update_nvm(hw, module, cmd->offset,\r\n(u16)cmd->data_size, bytes, last,\r\n&cmd_details);\r\nif (status) {\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_write mod 0x%x off 0x%x len 0x%x\n",\r\nmodule, cmd->offset, cmd->data_size);\r\ni40e_debug(hw, I40E_DEBUG_NVM,\r\n"i40e_nvmupd_nvm_write status %d aq %d\n",\r\nstatus, hw->aq.asq_last_status);\r\n*perrno = i40e_aq_rc_to_posix(status, hw->aq.asq_last_status);\r\n}\r\nreturn status;\r\n}
