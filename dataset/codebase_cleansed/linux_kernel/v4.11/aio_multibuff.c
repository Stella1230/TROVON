static void display_event(struct usb_functionfs_event *event)\r\n{\r\nstatic const char *const names[] = {\r\n[FUNCTIONFS_BIND] = "BIND",\r\n[FUNCTIONFS_UNBIND] = "UNBIND",\r\n[FUNCTIONFS_ENABLE] = "ENABLE",\r\n[FUNCTIONFS_DISABLE] = "DISABLE",\r\n[FUNCTIONFS_SETUP] = "SETUP",\r\n[FUNCTIONFS_SUSPEND] = "SUSPEND",\r\n[FUNCTIONFS_RESUME] = "RESUME",\r\n};\r\nswitch (event->type) {\r\ncase FUNCTIONFS_BIND:\r\ncase FUNCTIONFS_UNBIND:\r\ncase FUNCTIONFS_ENABLE:\r\ncase FUNCTIONFS_DISABLE:\r\ncase FUNCTIONFS_SETUP:\r\ncase FUNCTIONFS_SUSPEND:\r\ncase FUNCTIONFS_RESUME:\r\nprintf("Event %s\n", names[event->type]);\r\n}\r\n}\r\nstatic void handle_ep0(int ep0, bool *ready)\r\n{\r\nint ret;\r\nstruct usb_functionfs_event event;\r\nret = read(ep0, &event, sizeof(event));\r\nif (!ret) {\r\nperror("unable to read event from ep0");\r\nreturn;\r\n}\r\ndisplay_event(&event);\r\nswitch (event.type) {\r\ncase FUNCTIONFS_SETUP:\r\nif (event.u.setup.bRequestType & USB_DIR_IN)\r\nwrite(ep0, NULL, 0);\r\nelse\r\nread(ep0, NULL, 0);\r\nbreak;\r\ncase FUNCTIONFS_ENABLE:\r\n*ready = true;\r\nbreak;\r\ncase FUNCTIONFS_DISABLE:\r\n*ready = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid init_bufs(struct io_buffer *iobuf, unsigned n, unsigned len)\r\n{\r\nunsigned i;\r\niobuf->buf = malloc(n*sizeof(*iobuf->buf));\r\niobuf->iocb = malloc(n*sizeof(*iobuf->iocb));\r\niobuf->cnt = n;\r\niobuf->len = len;\r\niobuf->requested = 0;\r\nfor (i = 0; i < n; ++i) {\r\niobuf->buf[i] = malloc(len*sizeof(**iobuf->buf));\r\niobuf->iocb[i] = malloc(sizeof(**iobuf->iocb));\r\n}\r\niobuf->cnt = n;\r\n}\r\nvoid delete_bufs(struct io_buffer *iobuf)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < iobuf->cnt; ++i) {\r\nfree(iobuf->buf[i]);\r\nfree(iobuf->iocb[i]);\r\n}\r\nfree(iobuf->buf);\r\nfree(iobuf->iocb);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint ret;\r\nunsigned i, j;\r\nchar *ep_path;\r\nint ep0, ep1;\r\nio_context_t ctx;\r\nint evfd;\r\nfd_set rfds;\r\nstruct io_buffer iobuf[2];\r\nint actual = 0;\r\nbool ready;\r\nif (argc != 2) {\r\nprintf("ffs directory not specified!\n");\r\nreturn 1;\r\n}\r\nep_path = malloc(strlen(argv[1]) + 4 + 1 );\r\nif (!ep_path) {\r\nperror("malloc");\r\nreturn 1;\r\n}\r\nsprintf(ep_path, "%s/ep0", argv[1]);\r\nep0 = open(ep_path, O_RDWR);\r\nif (ep0 < 0) {\r\nperror("unable to open ep0");\r\nreturn 1;\r\n}\r\nif (write(ep0, &descriptors, sizeof(descriptors)) < 0) {\r\nperror("unable do write descriptors");\r\nreturn 1;\r\n}\r\nif (write(ep0, &strings, sizeof(strings)) < 0) {\r\nperror("unable to write strings");\r\nreturn 1;\r\n}\r\nsprintf(ep_path, "%s/ep1", argv[1]);\r\nep1 = open(ep_path, O_RDWR);\r\nif (ep1 < 0) {\r\nperror("unable to open ep1");\r\nreturn 1;\r\n}\r\nfree(ep_path);\r\nmemset(&ctx, 0, sizeof(ctx));\r\nif (io_setup(AIO_MAX, &ctx) < 0) {\r\nperror("unable to setup aio");\r\nreturn 1;\r\n}\r\nevfd = eventfd(0, 0);\r\nif (evfd < 0) {\r\nperror("unable to open eventfd");\r\nreturn 1;\r\n}\r\nfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i)\r\ninit_bufs(&iobuf[i], BUFS_MAX, BUF_LEN);\r\nwhile (1) {\r\nFD_ZERO(&rfds);\r\nFD_SET(ep0, &rfds);\r\nFD_SET(evfd, &rfds);\r\nret = select(((ep0 > evfd) ? ep0 : evfd)+1,\r\n&rfds, NULL, NULL, NULL);\r\nif (ret < 0) {\r\nif (errno == EINTR)\r\ncontinue;\r\nperror("select");\r\nbreak;\r\n}\r\nif (FD_ISSET(ep0, &rfds))\r\nhandle_ep0(ep0, &ready);\r\nif (!ready)\r\ncontinue;\r\nfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i) {\r\nif (iobuf[i].requested)\r\ncontinue;\r\nfor (j = 0; j < iobuf[i].cnt; ++j) {\r\nio_prep_pwrite(iobuf[i].iocb[j], ep1,\r\niobuf[i].buf[j],\r\niobuf[i].len, 0);\r\niobuf[i].iocb[j]->u.c.flags |= IOCB_FLAG_RESFD;\r\niobuf[i].iocb[j]->u.c.resfd = evfd;\r\n}\r\nret = io_submit(ctx, iobuf[i].cnt, iobuf[i].iocb);\r\nif (ret >= 0) {\r\niobuf[i].requested = ret;\r\nprintf("submit: %d requests buf: %d\n", ret, i);\r\n} else\r\nperror("unable to submit requests");\r\n}\r\nif (!FD_ISSET(evfd, &rfds))\r\ncontinue;\r\nuint64_t ev_cnt;\r\nret = read(evfd, &ev_cnt, sizeof(ev_cnt));\r\nif (ret < 0) {\r\nperror("unable to read eventfd");\r\nbreak;\r\n}\r\nstruct io_event e[BUFS_MAX];\r\nret = io_getevents(ctx, 1, BUFS_MAX, e, NULL);\r\nif (ret > 0)\r\niobuf[actual].requested -= ret;\r\nif (!iobuf[actual].requested)\r\nactual = (actual + 1)%(sizeof(iobuf)/sizeof(*iobuf));\r\n}\r\nfor (i = 0; i < sizeof(iobuf)/sizeof(*iobuf); ++i)\r\ndelete_bufs(&iobuf[i]);\r\nio_destroy(ctx);\r\nclose(ep1);\r\nclose(ep0);\r\nreturn 0;\r\n}
