unsigned int\r\nnf_nat_masquerade_ipv6(struct sk_buff *skb, const struct nf_nat_range *range,\r\nconst struct net_device *out)\r\n{\r\nenum ip_conntrack_info ctinfo;\r\nstruct in6_addr src;\r\nstruct nf_conn *ct;\r\nstruct nf_nat_range newrange;\r\nct = nf_ct_get(skb, &ctinfo);\r\nNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||\r\nctinfo == IP_CT_RELATED_REPLY));\r\nif (ipv6_dev_get_saddr(nf_ct_net(ct), out,\r\n&ipv6_hdr(skb)->daddr, 0, &src) < 0)\r\nreturn NF_DROP;\r\nnfct_nat(ct)->masq_index = out->ifindex;\r\nnewrange.flags = range->flags | NF_NAT_RANGE_MAP_IPS;\r\nnewrange.min_addr.in6 = src;\r\nnewrange.max_addr.in6 = src;\r\nnewrange.min_proto = range->min_proto;\r\nnewrange.max_proto = range->max_proto;\r\nreturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);\r\n}\r\nstatic int device_cmp(struct nf_conn *ct, void *ifindex)\r\n{\r\nconst struct nf_conn_nat *nat = nfct_nat(ct);\r\nif (!nat)\r\nreturn 0;\r\nif (nf_ct_l3num(ct) != NFPROTO_IPV6)\r\nreturn 0;\r\nreturn nat->masq_index == (int)(long)ifindex;\r\n}\r\nstatic int masq_device_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nconst struct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct net *net = dev_net(dev);\r\nif (event == NETDEV_DOWN)\r\nnf_ct_iterate_cleanup(net, device_cmp,\r\n(void *)(long)dev->ifindex, 0, 0);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void iterate_cleanup_work(struct work_struct *work)\r\n{\r\nstruct masq_dev_work *w;\r\nlong index;\r\nw = container_of(work, struct masq_dev_work, work);\r\nindex = w->ifindex;\r\nnf_ct_iterate_cleanup(w->net, device_cmp, (void *)index, 0, 0);\r\nput_net(w->net);\r\nkfree(w);\r\natomic_dec(&v6_worker_count);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int masq_inet_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct inet6_ifaddr *ifa = ptr;\r\nconst struct net_device *dev;\r\nstruct masq_dev_work *w;\r\nstruct net *net;\r\nif (event != NETDEV_DOWN ||\r\natomic_read(&v6_worker_count) >= MAX_WORK_COUNT)\r\nreturn NOTIFY_DONE;\r\ndev = ifa->idev->dev;\r\nnet = maybe_get_net(dev_net(dev));\r\nif (!net)\r\nreturn NOTIFY_DONE;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err_module;\r\nw = kmalloc(sizeof(*w), GFP_ATOMIC);\r\nif (w) {\r\natomic_inc(&v6_worker_count);\r\nINIT_WORK(&w->work, iterate_cleanup_work);\r\nw->ifindex = dev->ifindex;\r\nw->net = net;\r\nschedule_work(&w->work);\r\nreturn NOTIFY_DONE;\r\n}\r\nmodule_put(THIS_MODULE);\r\nerr_module:\r\nput_net(net);\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid nf_nat_masquerade_ipv6_register_notifier(void)\r\n{\r\nif (atomic_inc_return(&masquerade_notifier_refcount) > 1)\r\nreturn;\r\nregister_netdevice_notifier(&masq_dev_notifier);\r\nregister_inet6addr_notifier(&masq_inet_notifier);\r\n}\r\nvoid nf_nat_masquerade_ipv6_unregister_notifier(void)\r\n{\r\nif (atomic_dec_return(&masquerade_notifier_refcount) > 0)\r\nreturn;\r\nunregister_inet6addr_notifier(&masq_inet_notifier);\r\nunregister_netdevice_notifier(&masq_dev_notifier);\r\n}
