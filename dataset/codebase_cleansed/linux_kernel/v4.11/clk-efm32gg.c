static void __init efm32gg_cmu_init(struct device_node *np)\r\n{\r\nint i;\r\nvoid __iomem *base;\r\nstruct clk_hw **hws;\r\nclk_data = kzalloc(sizeof(*clk_data) +\r\nsizeof(*clk_data->hws) * CMU_MAX_CLKS, GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nhws = clk_data->hws;\r\nfor (i = 0; i < CMU_MAX_CLKS; ++i)\r\nhws[i] = ERR_PTR(-ENOENT);\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_warn("Failed to map address range for efm32gg,cmu node\n");\r\nreturn;\r\n}\r\nhws[clk_HFXO] = clk_hw_register_fixed_rate(NULL, "HFXO", NULL, 0,\r\n48000000);\r\nhws[clk_HFPERCLKUSART0] = clk_hw_register_gate(NULL, "HFPERCLK.USART0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 0, 0, NULL);\r\nhws[clk_HFPERCLKUSART1] = clk_hw_register_gate(NULL, "HFPERCLK.USART1",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 1, 0, NULL);\r\nhws[clk_HFPERCLKUSART2] = clk_hw_register_gate(NULL, "HFPERCLK.USART2",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 2, 0, NULL);\r\nhws[clk_HFPERCLKUART0] = clk_hw_register_gate(NULL, "HFPERCLK.UART0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 3, 0, NULL);\r\nhws[clk_HFPERCLKUART1] = clk_hw_register_gate(NULL, "HFPERCLK.UART1",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 4, 0, NULL);\r\nhws[clk_HFPERCLKTIMER0] = clk_hw_register_gate(NULL, "HFPERCLK.TIMER0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 5, 0, NULL);\r\nhws[clk_HFPERCLKTIMER1] = clk_hw_register_gate(NULL, "HFPERCLK.TIMER1",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 6, 0, NULL);\r\nhws[clk_HFPERCLKTIMER2] = clk_hw_register_gate(NULL, "HFPERCLK.TIMER2",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 7, 0, NULL);\r\nhws[clk_HFPERCLKTIMER3] = clk_hw_register_gate(NULL, "HFPERCLK.TIMER3",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 8, 0, NULL);\r\nhws[clk_HFPERCLKACMP0] = clk_hw_register_gate(NULL, "HFPERCLK.ACMP0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 9, 0, NULL);\r\nhws[clk_HFPERCLKACMP1] = clk_hw_register_gate(NULL, "HFPERCLK.ACMP1",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 10, 0, NULL);\r\nhws[clk_HFPERCLKI2C0] = clk_hw_register_gate(NULL, "HFPERCLK.I2C0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 11, 0, NULL);\r\nhws[clk_HFPERCLKI2C1] = clk_hw_register_gate(NULL, "HFPERCLK.I2C1",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 12, 0, NULL);\r\nhws[clk_HFPERCLKGPIO] = clk_hw_register_gate(NULL, "HFPERCLK.GPIO",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 13, 0, NULL);\r\nhws[clk_HFPERCLKVCMP] = clk_hw_register_gate(NULL, "HFPERCLK.VCMP",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 14, 0, NULL);\r\nhws[clk_HFPERCLKPRS] = clk_hw_register_gate(NULL, "HFPERCLK.PRS",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 15, 0, NULL);\r\nhws[clk_HFPERCLKADC0] = clk_hw_register_gate(NULL, "HFPERCLK.ADC0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 16, 0, NULL);\r\nhws[clk_HFPERCLKDAC0] = clk_hw_register_gate(NULL, "HFPERCLK.DAC0",\r\n"HFXO", 0, base + CMU_HFPERCLKEN0, 17, 0, NULL);\r\nof_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\r\n}
