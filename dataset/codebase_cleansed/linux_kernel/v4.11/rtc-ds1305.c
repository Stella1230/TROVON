static unsigned bcd2hour(u8 bcd)\r\n{\r\nif (bcd & DS1305_HR_12) {\r\nunsigned hour = 0;\r\nbcd &= ~DS1305_HR_12;\r\nif (bcd & DS1305_HR_PM) {\r\nhour = 12;\r\nbcd &= ~DS1305_HR_PM;\r\n}\r\nhour += bcd2bin(bcd);\r\nreturn hour - 1;\r\n}\r\nreturn bcd2bin(bcd);\r\n}\r\nstatic u8 hour2bcd(bool hr12, int hour)\r\n{\r\nif (hr12) {\r\nhour++;\r\nif (hour <= 12)\r\nreturn DS1305_HR_12 | bin2bcd(hour);\r\nhour -= 12;\r\nreturn DS1305_HR_12 | DS1305_HR_PM | bin2bcd(hour);\r\n}\r\nreturn bin2bcd(hour);\r\n}\r\nstatic int ds1305_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nu8 buf[2];\r\nlong err = -EINVAL;\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nif (enabled) {\r\nif (ds1305->ctrl[0] & DS1305_AEI0)\r\ngoto done;\r\nbuf[1] |= DS1305_AEI0;\r\n} else {\r\nif (!(buf[1] & DS1305_AEI0))\r\ngoto done;\r\nbuf[1] &= ~DS1305_AEI0;\r\n}\r\nerr = spi_write_then_read(ds1305->spi, buf, sizeof(buf), NULL, 0);\r\nif (err >= 0)\r\nds1305->ctrl[0] = buf[1];\r\ndone:\r\nreturn err;\r\n}\r\nstatic int ds1305_get_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nu8 addr = DS1305_SEC;\r\nu8 buf[DS1305_RTC_LEN];\r\nint status;\r\nstatus = spi_write_then_read(ds1305->spi, &addr, sizeof(addr),\r\nbuf, sizeof(buf));\r\nif (status < 0)\r\nreturn status;\r\ndev_vdbg(dev, "%s: %3ph, %4ph\n", "read", &buf[0], &buf[3]);\r\ntime->tm_sec = bcd2bin(buf[DS1305_SEC]);\r\ntime->tm_min = bcd2bin(buf[DS1305_MIN]);\r\ntime->tm_hour = bcd2hour(buf[DS1305_HOUR]);\r\ntime->tm_wday = buf[DS1305_WDAY] - 1;\r\ntime->tm_mday = bcd2bin(buf[DS1305_MDAY]);\r\ntime->tm_mon = bcd2bin(buf[DS1305_MON]) - 1;\r\ntime->tm_year = bcd2bin(buf[DS1305_YEAR]) + 100;\r\ndev_vdbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read", time->tm_sec, time->tm_min,\r\ntime->tm_hour, time->tm_mday,\r\ntime->tm_mon, time->tm_year, time->tm_wday);\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int ds1305_set_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nu8 buf[1 + DS1305_RTC_LEN];\r\nu8 *bp = buf;\r\ndev_vdbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write", time->tm_sec, time->tm_min,\r\ntime->tm_hour, time->tm_mday,\r\ntime->tm_mon, time->tm_year, time->tm_wday);\r\n*bp++ = DS1305_WRITE | DS1305_SEC;\r\n*bp++ = bin2bcd(time->tm_sec);\r\n*bp++ = bin2bcd(time->tm_min);\r\n*bp++ = hour2bcd(ds1305->hr12, time->tm_hour);\r\n*bp++ = (time->tm_wday < 7) ? (time->tm_wday + 1) : 1;\r\n*bp++ = bin2bcd(time->tm_mday);\r\n*bp++ = bin2bcd(time->tm_mon + 1);\r\n*bp++ = bin2bcd(time->tm_year - 100);\r\ndev_dbg(dev, "%s: %3ph, %4ph\n", "write", &buf[1], &buf[4]);\r\nreturn spi_write_then_read(ds1305->spi, buf, sizeof(buf),\r\nNULL, 0);\r\n}\r\nstatic int ds1305_get_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nstruct spi_device *spi = ds1305->spi;\r\nu8 addr;\r\nint status;\r\nu8 buf[DS1305_ALM_LEN];\r\naddr = DS1305_CONTROL;\r\nstatus = spi_write_then_read(spi, &addr, sizeof(addr),\r\nds1305->ctrl, sizeof(ds1305->ctrl));\r\nif (status < 0)\r\nreturn status;\r\nalm->enabled = !!(ds1305->ctrl[0] & DS1305_AEI0);\r\nalm->pending = !!(ds1305->ctrl[1] & DS1305_AEI0);\r\naddr = DS1305_ALM0(DS1305_SEC);\r\nstatus = spi_write_then_read(spi, &addr, sizeof(addr),\r\nbuf, sizeof(buf));\r\nif (status < 0)\r\nreturn status;\r\ndev_vdbg(dev, "%s: %02x %02x %02x %02x\n",\r\n"alm0 read", buf[DS1305_SEC], buf[DS1305_MIN],\r\nbuf[DS1305_HOUR], buf[DS1305_WDAY]);\r\nif ((DS1305_ALM_DISABLE & buf[DS1305_SEC])\r\n|| (DS1305_ALM_DISABLE & buf[DS1305_MIN])\r\n|| (DS1305_ALM_DISABLE & buf[DS1305_HOUR]))\r\nreturn -EIO;\r\nalm->time.tm_sec = bcd2bin(buf[DS1305_SEC]);\r\nalm->time.tm_min = bcd2bin(buf[DS1305_MIN]);\r\nalm->time.tm_hour = bcd2hour(buf[DS1305_HOUR]);\r\nreturn 0;\r\n}\r\nstatic int ds1305_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nstruct spi_device *spi = ds1305->spi;\r\nunsigned long now, later;\r\nstruct rtc_time tm;\r\nint status;\r\nu8 buf[1 + DS1305_ALM_LEN];\r\nstatus = rtc_tm_to_time(&alm->time, &later);\r\nif (status < 0)\r\nreturn status;\r\nstatus = ds1305_get_time(dev, &tm);\r\nif (status < 0)\r\nreturn status;\r\nstatus = rtc_tm_to_time(&tm, &now);\r\nif (status < 0)\r\nreturn status;\r\nif (later <= now)\r\nreturn -EINVAL;\r\nif ((later - now) > 24 * 60 * 60)\r\nreturn -EDOM;\r\nif (ds1305->ctrl[0] & DS1305_AEI0) {\r\nds1305->ctrl[0] &= ~DS1305_AEI0;\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nbuf[0] = DS1305_WRITE | DS1305_ALM0(DS1305_SEC);\r\nbuf[1 + DS1305_SEC] = bin2bcd(alm->time.tm_sec);\r\nbuf[1 + DS1305_MIN] = bin2bcd(alm->time.tm_min);\r\nbuf[1 + DS1305_HOUR] = hour2bcd(ds1305->hr12, alm->time.tm_hour);\r\nbuf[1 + DS1305_WDAY] = DS1305_ALM_DISABLE;\r\ndev_dbg(dev, "%s: %02x %02x %02x %02x\n",\r\n"alm0 write", buf[1 + DS1305_SEC], buf[1 + DS1305_MIN],\r\nbuf[1 + DS1305_HOUR], buf[1 + DS1305_WDAY]);\r\nstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\r\nif (status < 0)\r\nreturn status;\r\nif (alm->enabled) {\r\nds1305->ctrl[0] |= DS1305_AEI0;\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\r\n}\r\nreturn status;\r\n}\r\nstatic int ds1305_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct ds1305 *ds1305 = dev_get_drvdata(dev);\r\nchar *diodes = "no";\r\nchar *resistors = "";\r\nif ((ds1305->ctrl[2] & 0xf0) == DS1305_TRICKLE_MAGIC) {\r\nswitch (ds1305->ctrl[2] & 0x0c) {\r\ncase DS1305_TRICKLE_DS2:\r\ndiodes = "2 diodes, ";\r\nbreak;\r\ncase DS1305_TRICKLE_DS1:\r\ndiodes = "1 diode, ";\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\nswitch (ds1305->ctrl[2] & 0x03) {\r\ncase DS1305_TRICKLE_2K:\r\nresistors = "2k Ohm";\r\nbreak;\r\ncase DS1305_TRICKLE_4K:\r\nresistors = "4k Ohm";\r\nbreak;\r\ncase DS1305_TRICKLE_8K:\r\nresistors = "8k Ohm";\r\nbreak;\r\ndefault:\r\ndiodes = "no";\r\nbreak;\r\n}\r\n}\r\ndone:\r\nseq_printf(seq, "trickle_charge\t: %s%s\n", diodes, resistors);\r\nreturn 0;\r\n}\r\nstatic void ds1305_work(struct work_struct *work)\r\n{\r\nstruct ds1305 *ds1305 = container_of(work, struct ds1305, work);\r\nstruct mutex *lock = &ds1305->rtc->ops_lock;\r\nstruct spi_device *spi = ds1305->spi;\r\nu8 buf[3];\r\nint status;\r\nmutex_lock(lock);\r\nds1305->ctrl[0] &= ~(DS1305_AEI1 | DS1305_AEI0);\r\nds1305->ctrl[1] = 0;\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nbuf[2] = 0;\r\nstatus = spi_write_then_read(spi, buf, sizeof(buf),\r\nNULL, 0);\r\nif (status < 0)\r\ndev_dbg(&spi->dev, "clear irq --> %d\n", status);\r\nmutex_unlock(lock);\r\nif (!test_bit(FLAG_EXITING, &ds1305->flags))\r\nenable_irq(spi->irq);\r\nrtc_update_irq(ds1305->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nstatic irqreturn_t ds1305_irq(int irq, void *p)\r\n{\r\nstruct ds1305 *ds1305 = p;\r\ndisable_irq(irq);\r\nschedule_work(&ds1305->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void msg_init(struct spi_message *m, struct spi_transfer *x,\r\nu8 *addr, size_t count, char *tx, char *rx)\r\n{\r\nspi_message_init(m);\r\nmemset(x, 0, 2 * sizeof(*x));\r\nx->tx_buf = addr;\r\nx->len = 1;\r\nspi_message_add_tail(x, m);\r\nx++;\r\nx->tx_buf = tx;\r\nx->rx_buf = rx;\r\nx->len = count;\r\nspi_message_add_tail(x, m);\r\n}\r\nstatic ssize_t\r\nds1305_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct spi_device *spi;\r\nu8 addr;\r\nstruct spi_message m;\r\nstruct spi_transfer x[2];\r\nint status;\r\nspi = to_spi_device(kobj_to_dev(kobj));\r\naddr = DS1305_NVRAM + off;\r\nmsg_init(&m, x, &addr, count, NULL, buf);\r\nstatus = spi_sync(spi, &m);\r\nif (status < 0)\r\ndev_err(&spi->dev, "nvram %s error %d\n", "read", status);\r\nreturn (status < 0) ? status : count;\r\n}\r\nstatic ssize_t\r\nds1305_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct spi_device *spi;\r\nu8 addr;\r\nstruct spi_message m;\r\nstruct spi_transfer x[2];\r\nint status;\r\nspi = to_spi_device(kobj_to_dev(kobj));\r\naddr = (DS1305_WRITE | DS1305_NVRAM) + off;\r\nmsg_init(&m, x, &addr, count, buf, NULL);\r\nstatus = spi_sync(spi, &m);\r\nif (status < 0)\r\ndev_err(&spi->dev, "nvram %s error %d\n", "write", status);\r\nreturn (status < 0) ? status : count;\r\n}\r\nstatic int ds1305_probe(struct spi_device *spi)\r\n{\r\nstruct ds1305 *ds1305;\r\nint status;\r\nu8 addr, value;\r\nstruct ds1305_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nbool write_ctrl = false;\r\nif ((spi->bits_per_word && spi->bits_per_word != 8)\r\n|| (spi->max_speed_hz > 2000000)\r\n|| !(spi->mode & SPI_CPHA))\r\nreturn -EINVAL;\r\nds1305 = devm_kzalloc(&spi->dev, sizeof(*ds1305), GFP_KERNEL);\r\nif (!ds1305)\r\nreturn -ENOMEM;\r\nds1305->spi = spi;\r\nspi_set_drvdata(spi, ds1305);\r\naddr = DS1305_CONTROL;\r\nstatus = spi_write_then_read(spi, &addr, sizeof(addr),\r\nds1305->ctrl, sizeof(ds1305->ctrl));\r\nif (status < 0) {\r\ndev_dbg(&spi->dev, "can't %s, %d\n",\r\n"read", status);\r\nreturn status;\r\n}\r\ndev_dbg(&spi->dev, "ctrl %s: %3ph\n", "read", ds1305->ctrl);\r\nif ((ds1305->ctrl[0] & 0x38) != 0 || (ds1305->ctrl[1] & 0xfc) != 0) {\r\ndev_dbg(&spi->dev, "RTC chip is not present\n");\r\nreturn -ENODEV;\r\n}\r\nif (ds1305->ctrl[2] == 0)\r\ndev_dbg(&spi->dev, "chip may not be present\n");\r\nif (ds1305->ctrl[0] & DS1305_WP) {\r\nu8 buf[2];\r\nds1305->ctrl[0] &= ~DS1305_WP;\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\r\ndev_dbg(&spi->dev, "clear WP --> %d\n", status);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nif (ds1305->ctrl[0] & DS1305_nEOSC) {\r\nds1305->ctrl[0] &= ~DS1305_nEOSC;\r\nwrite_ctrl = true;\r\ndev_warn(&spi->dev, "SET TIME!\n");\r\n}\r\nif (ds1305->ctrl[1]) {\r\nds1305->ctrl[1] = 0;\r\nwrite_ctrl = true;\r\n}\r\nif (pdata) {\r\nif (((ds1305->ctrl[2] & 0xf0) != DS1305_TRICKLE_MAGIC)) {\r\nds1305->ctrl[2] = DS1305_TRICKLE_MAGIC\r\n| pdata->trickle;\r\nwrite_ctrl = true;\r\n}\r\nif (pdata->is_ds1306) {\r\nif (pdata->en_1hz) {\r\nif (!(ds1305->ctrl[0] & DS1306_1HZ)) {\r\nds1305->ctrl[0] |= DS1306_1HZ;\r\nwrite_ctrl = true;\r\n}\r\n} else {\r\nif (ds1305->ctrl[0] & DS1306_1HZ) {\r\nds1305->ctrl[0] &= ~DS1306_1HZ;\r\nwrite_ctrl = true;\r\n}\r\n}\r\n}\r\n}\r\nif (write_ctrl) {\r\nu8 buf[4];\r\nbuf[0] = DS1305_WRITE | DS1305_CONTROL;\r\nbuf[1] = ds1305->ctrl[0];\r\nbuf[2] = ds1305->ctrl[1];\r\nbuf[3] = ds1305->ctrl[2];\r\nstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\r\nif (status < 0) {\r\ndev_dbg(&spi->dev, "can't %s, %d\n",\r\n"write", status);\r\nreturn status;\r\n}\r\ndev_dbg(&spi->dev, "ctrl %s: %3ph\n", "write", ds1305->ctrl);\r\n}\r\naddr = DS1305_HOUR;\r\nstatus = spi_write_then_read(spi, &addr, sizeof(addr),\r\n&value, sizeof(value));\r\nif (status < 0) {\r\ndev_dbg(&spi->dev, "read HOUR --> %d\n", status);\r\nreturn status;\r\n}\r\nds1305->hr12 = (DS1305_HR_12 & value) != 0;\r\nif (ds1305->hr12)\r\ndev_dbg(&spi->dev, "AM/PM\n");\r\nds1305->rtc = devm_rtc_device_register(&spi->dev, "ds1305",\r\n&ds1305_ops, THIS_MODULE);\r\nif (IS_ERR(ds1305->rtc)) {\r\nstatus = PTR_ERR(ds1305->rtc);\r\ndev_dbg(&spi->dev, "register rtc --> %d\n", status);\r\nreturn status;\r\n}\r\nif (spi->irq) {\r\nINIT_WORK(&ds1305->work, ds1305_work);\r\nstatus = devm_request_irq(&spi->dev, spi->irq, ds1305_irq,\r\n0, dev_name(&ds1305->rtc->dev), ds1305);\r\nif (status < 0) {\r\ndev_err(&spi->dev, "request_irq %d --> %d\n",\r\nspi->irq, status);\r\n} else {\r\ndevice_set_wakeup_capable(&spi->dev, 1);\r\n}\r\n}\r\nstatus = sysfs_create_bin_file(&spi->dev.kobj, &nvram);\r\nif (status < 0) {\r\ndev_err(&spi->dev, "register nvram --> %d\n", status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds1305_remove(struct spi_device *spi)\r\n{\r\nstruct ds1305 *ds1305 = spi_get_drvdata(spi);\r\nsysfs_remove_bin_file(&spi->dev.kobj, &nvram);\r\nif (spi->irq) {\r\nset_bit(FLAG_EXITING, &ds1305->flags);\r\ndevm_free_irq(&spi->dev, spi->irq, ds1305);\r\ncancel_work_sync(&ds1305->work);\r\n}\r\nreturn 0;\r\n}
