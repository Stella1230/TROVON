static int pkcs7_digest(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct public_key_signature *sig = sinfo->sig;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t desc_size;\r\nint ret;\r\nkenter(",%u,%s", sinfo->index, sinfo->sig->hash_algo);\r\nif (!sinfo->sig->hash_algo)\r\nreturn -ENOPKG;\r\ntfm = crypto_alloc_shash(sinfo->sig->hash_algo, 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? -ENOPKG : PTR_ERR(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\nsig->digest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\nsig->digest = kmalloc(sig->digest_size, GFP_KERNEL);\r\nif (!sig->digest)\r\ngoto error_no_desc;\r\ndesc = kzalloc(desc_size, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_no_desc;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nret = crypto_shash_finup(desc, pkcs7->data, pkcs7->data_len,\r\nsig->digest);\r\nif (ret < 0)\r\ngoto error;\r\npr_devel("MsgDigest = [%*ph]\n", 8, sig->digest);\r\nif (sinfo->authattrs) {\r\nu8 tag;\r\nif (!sinfo->msgdigest) {\r\npr_warn("Sig %u: No messageDigest\n", sinfo->index);\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nif (sinfo->msgdigest_len != sig->digest_size) {\r\npr_debug("Sig %u: Invalid digest size (%u)\n",\r\nsinfo->index, sinfo->msgdigest_len);\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nif (memcmp(sig->digest, sinfo->msgdigest,\r\nsinfo->msgdigest_len) != 0) {\r\npr_debug("Sig %u: Message digest doesn't match\n",\r\nsinfo->index);\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nmemset(sig->digest, 0, sig->digest_size);\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\ntag = ASN1_CONS_BIT | ASN1_SET;\r\nret = crypto_shash_update(desc, &tag, 1);\r\nif (ret < 0)\r\ngoto error;\r\nret = crypto_shash_finup(desc, sinfo->authattrs,\r\nsinfo->authattrs_len, sig->digest);\r\nif (ret < 0)\r\ngoto error;\r\npr_devel("AADigest = [%*ph]\n", 8, sig->digest);\r\n}\r\nerror:\r\nkfree(desc);\r\nerror_no_desc:\r\ncrypto_free_shash(tfm);\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int pkcs7_find_key(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct x509_certificate *x509;\r\nunsigned certix = 1;\r\nkenter("%u", sinfo->index);\r\nfor (x509 = pkcs7->certs; x509; x509 = x509->next, certix++) {\r\nif (!asymmetric_key_id_same(x509->id, sinfo->sig->auth_ids[0]))\r\ncontinue;\r\npr_devel("Sig %u: Found cert serial match X.509[%u]\n",\r\nsinfo->index, certix);\r\nif (x509->pub->pkey_algo != sinfo->sig->pkey_algo) {\r\npr_warn("Sig %u: X.509 algo and PKCS#7 sig algo don't match\n",\r\nsinfo->index);\r\ncontinue;\r\n}\r\nsinfo->signer = x509;\r\nreturn 0;\r\n}\r\npr_debug("Sig %u: Issuing X.509 cert not found (#%*phN)\n",\r\nsinfo->index,\r\nsinfo->sig->auth_ids[0]->len, sinfo->sig->auth_ids[0]->data);\r\nreturn 0;\r\n}\r\nstatic int pkcs7_verify_sig_chain(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nstruct public_key_signature *sig;\r\nstruct x509_certificate *x509 = sinfo->signer, *p;\r\nstruct asymmetric_key_id *auth;\r\nint ret;\r\nkenter("");\r\nfor (p = pkcs7->certs; p; p = p->next)\r\np->seen = false;\r\nfor (;;) {\r\npr_debug("verify %s: %*phN\n",\r\nx509->subject,\r\nx509->raw_serial_size, x509->raw_serial);\r\nx509->seen = true;\r\nif (x509->unsupported_key)\r\ngoto unsupported_crypto_in_x509;\r\npr_debug("- issuer %s\n", x509->issuer);\r\nsig = x509->sig;\r\nif (sig->auth_ids[0])\r\npr_debug("- authkeyid.id %*phN\n",\r\nsig->auth_ids[0]->len, sig->auth_ids[0]->data);\r\nif (sig->auth_ids[1])\r\npr_debug("- authkeyid.skid %*phN\n",\r\nsig->auth_ids[1]->len, sig->auth_ids[1]->data);\r\nif (x509->self_signed) {\r\nif (x509->unsupported_sig)\r\ngoto unsupported_crypto_in_x509;\r\nx509->signer = x509;\r\npr_debug("- self-signed\n");\r\nreturn 0;\r\n}\r\nauth = sig->auth_ids[0];\r\nif (auth) {\r\npr_debug("- want %*phN\n", auth->len, auth->data);\r\nfor (p = pkcs7->certs; p; p = p->next) {\r\npr_debug("- cmp [%u] %*phN\n",\r\np->index, p->id->len, p->id->data);\r\nif (asymmetric_key_id_same(p->id, auth))\r\ngoto found_issuer_check_skid;\r\n}\r\n} else if (sig->auth_ids[1]) {\r\nauth = sig->auth_ids[1];\r\npr_debug("- want %*phN\n", auth->len, auth->data);\r\nfor (p = pkcs7->certs; p; p = p->next) {\r\nif (!p->skid)\r\ncontinue;\r\npr_debug("- cmp [%u] %*phN\n",\r\np->index, p->skid->len, p->skid->data);\r\nif (asymmetric_key_id_same(p->skid, auth))\r\ngoto found_issuer;\r\n}\r\n}\r\npr_debug("- top\n");\r\nreturn 0;\r\nfound_issuer_check_skid:\r\nif (sig->auth_ids[1] &&\r\n!asymmetric_key_id_same(p->skid, sig->auth_ids[1])) {\r\npr_warn("Sig %u: X.509 chain contains auth-skid nonmatch (%u->%u)\n",\r\nsinfo->index, x509->index, p->index);\r\nreturn -EKEYREJECTED;\r\n}\r\nfound_issuer:\r\npr_debug("- subject %s\n", p->subject);\r\nif (p->seen) {\r\npr_warn("Sig %u: X.509 chain contains loop\n",\r\nsinfo->index);\r\nreturn 0;\r\n}\r\nret = public_key_verify_signature(p->pub, p->sig);\r\nif (ret < 0)\r\nreturn ret;\r\nx509->signer = p;\r\nif (x509 == p) {\r\npr_debug("- self-signed\n");\r\nreturn 0;\r\n}\r\nx509 = p;\r\nmight_sleep();\r\n}\r\nunsupported_crypto_in_x509:\r\nreturn 0;\r\n}\r\nstatic int pkcs7_verify_one(struct pkcs7_message *pkcs7,\r\nstruct pkcs7_signed_info *sinfo)\r\n{\r\nint ret;\r\nkenter(",%u", sinfo->index);\r\nret = pkcs7_digest(pkcs7, sinfo);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pkcs7_find_key(pkcs7, sinfo);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!sinfo->signer)\r\nreturn 0;\r\npr_devel("Using X.509[%u] for sig %u\n",\r\nsinfo->signer->index, sinfo->index);\r\nif (test_bit(sinfo_has_signing_time, &sinfo->aa_set)) {\r\nif (sinfo->signing_time < sinfo->signer->valid_from ||\r\nsinfo->signing_time > sinfo->signer->valid_to) {\r\npr_warn("Message signed outside of X.509 validity window\n");\r\nreturn -EKEYREJECTED;\r\n}\r\n}\r\nret = public_key_verify_signature(sinfo->signer->pub, sinfo->sig);\r\nif (ret < 0)\r\nreturn ret;\r\npr_devel("Verified signature %u\n", sinfo->index);\r\nreturn pkcs7_verify_sig_chain(pkcs7, sinfo);\r\n}\r\nint pkcs7_verify(struct pkcs7_message *pkcs7,\r\nenum key_being_used_for usage)\r\n{\r\nstruct pkcs7_signed_info *sinfo;\r\nint enopkg = -ENOPKG;\r\nint ret;\r\nkenter("");\r\nswitch (usage) {\r\ncase VERIFYING_MODULE_SIGNATURE:\r\nif (pkcs7->data_type != OID_data) {\r\npr_warn("Invalid module sig (not pkcs7-data)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nif (pkcs7->have_authattrs) {\r\npr_warn("Invalid module sig (has authattrs)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nbreak;\r\ncase VERIFYING_FIRMWARE_SIGNATURE:\r\nif (pkcs7->data_type != OID_data) {\r\npr_warn("Invalid firmware sig (not pkcs7-data)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nif (!pkcs7->have_authattrs) {\r\npr_warn("Invalid firmware sig (missing authattrs)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nbreak;\r\ncase VERIFYING_KEXEC_PE_SIGNATURE:\r\nif (pkcs7->data_type != OID_msIndirectData) {\r\npr_warn("Invalid kexec sig (not Authenticode)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nbreak;\r\ncase VERIFYING_UNSPECIFIED_SIGNATURE:\r\nif (pkcs7->data_type != OID_data) {\r\npr_warn("Invalid unspecified sig (not pkcs7-data)\n");\r\nreturn -EKEYREJECTED;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (sinfo = pkcs7->signed_infos; sinfo; sinfo = sinfo->next) {\r\nret = pkcs7_verify_one(pkcs7, sinfo);\r\nif (ret < 0) {\r\nif (ret == -ENOPKG) {\r\nsinfo->unsupported_crypto = true;\r\ncontinue;\r\n}\r\nkleave(" = %d", ret);\r\nreturn ret;\r\n}\r\nenopkg = 0;\r\n}\r\nkleave(" = %d", enopkg);\r\nreturn enopkg;\r\n}\r\nint pkcs7_supply_detached_data(struct pkcs7_message *pkcs7,\r\nconst void *data, size_t datalen)\r\n{\r\nif (pkcs7->data) {\r\npr_debug("Data already supplied\n");\r\nreturn -EINVAL;\r\n}\r\npkcs7->data = data;\r\npkcs7->data_len = datalen;\r\nreturn 0;\r\n}
