static int sc18is602_wait_ready(struct sc18is602 *hw, int len)\r\n{\r\nint i, err;\r\nint usecs = 1000000 * len / hw->speed + 1;\r\nu8 dummy[1];\r\nfor (i = 0; i < 10; i++) {\r\nerr = i2c_master_recv(hw->client, dummy, 1);\r\nif (err >= 0)\r\nreturn 0;\r\nusleep_range(usecs, usecs * 2);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sc18is602_txrx(struct sc18is602 *hw, struct spi_message *msg,\r\nstruct spi_transfer *t, bool do_transfer)\r\n{\r\nunsigned int len = t->len;\r\nint ret;\r\nif (hw->tlen == 0) {\r\nhw->buffer[0] = 1 << msg->spi->chip_select;\r\nhw->tlen = 1;\r\nhw->rindex = 0;\r\n}\r\nif (t->tx_buf) {\r\nmemcpy(&hw->buffer[hw->tlen], t->tx_buf, len);\r\nhw->tlen += len;\r\nif (t->rx_buf)\r\ndo_transfer = true;\r\nelse\r\nhw->rindex = hw->tlen - 1;\r\n} else if (t->rx_buf) {\r\nhw->rindex = hw->tlen - 1;\r\nmemset(&hw->buffer[hw->tlen], 0, len);\r\nhw->tlen += len;\r\ndo_transfer = true;\r\n}\r\nif (do_transfer && hw->tlen > 1) {\r\nret = sc18is602_wait_ready(hw, SC18IS602_BUFSIZ);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_master_send(hw->client, hw->buffer, hw->tlen);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != hw->tlen)\r\nreturn -EIO;\r\nif (t->rx_buf) {\r\nint rlen = hw->rindex + len;\r\nret = sc18is602_wait_ready(hw, hw->tlen);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_master_recv(hw->client, hw->buffer, rlen);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != rlen)\r\nreturn -EIO;\r\nmemcpy(t->rx_buf, &hw->buffer[hw->rindex], len);\r\n}\r\nhw->tlen = 0;\r\n}\r\nreturn len;\r\n}\r\nstatic int sc18is602_setup_transfer(struct sc18is602 *hw, u32 hz, u8 mode)\r\n{\r\nu8 ctrl = 0;\r\nint ret;\r\nif (mode & SPI_CPHA)\r\nctrl |= SC18IS602_MODE_CPHA;\r\nif (mode & SPI_CPOL)\r\nctrl |= SC18IS602_MODE_CPOL;\r\nif (mode & SPI_LSB_FIRST)\r\nctrl |= SC18IS602_MODE_LSB_FIRST;\r\nif (hz >= hw->freq / 4) {\r\nctrl |= SC18IS602_MODE_CLOCK_DIV_4;\r\nhw->speed = hw->freq / 4;\r\n} else if (hz >= hw->freq / 16) {\r\nctrl |= SC18IS602_MODE_CLOCK_DIV_16;\r\nhw->speed = hw->freq / 16;\r\n} else if (hz >= hw->freq / 64) {\r\nctrl |= SC18IS602_MODE_CLOCK_DIV_64;\r\nhw->speed = hw->freq / 64;\r\n} else {\r\nctrl |= SC18IS602_MODE_CLOCK_DIV_128;\r\nhw->speed = hw->freq / 128;\r\n}\r\nif (ctrl == hw->ctrl)\r\nreturn 0;\r\nret = i2c_smbus_write_byte_data(hw->client, 0xf0, ctrl);\r\nif (ret < 0)\r\nreturn ret;\r\nhw->ctrl = ctrl;\r\nreturn 0;\r\n}\r\nstatic int sc18is602_check_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t, int tlen)\r\n{\r\nif (t && t->len + tlen > SC18IS602_BUFSIZ)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int sc18is602_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct sc18is602 *hw = spi_master_get_devdata(master);\r\nstruct spi_device *spi = m->spi;\r\nstruct spi_transfer *t;\r\nint status = 0;\r\nhw->tlen = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nbool do_transfer;\r\nstatus = sc18is602_check_transfer(spi, t, hw->tlen);\r\nif (status < 0)\r\nbreak;\r\nstatus = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);\r\nif (status < 0)\r\nbreak;\r\ndo_transfer = t->cs_change || list_is_last(&t->transfer_list,\r\n&m->transfers);\r\nif (t->len) {\r\nstatus = sc18is602_txrx(hw, m, t, do_transfer);\r\nif (status < 0)\r\nbreak;\r\nm->actual_length += status;\r\n}\r\nstatus = 0;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\n}\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int sc18is602_setup(struct spi_device *spi)\r\n{\r\nstruct sc18is602 *hw = spi_master_get_devdata(spi->master);\r\nif (hw->id == sc18is602 && spi->chip_select == 2)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic int sc18is602_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct sc18is602_platform_data *pdata = dev_get_platdata(dev);\r\nstruct sc18is602 *hw;\r\nstruct spi_master *master;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EINVAL;\r\nmaster = spi_alloc_master(dev, sizeof(struct sc18is602));\r\nif (!master)\r\nreturn -ENOMEM;\r\nhw = spi_master_get_devdata(master);\r\ni2c_set_clientdata(client, hw);\r\nhw->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(hw->reset))\r\nreturn PTR_ERR(hw->reset);\r\ngpiod_set_value_cansleep(hw->reset, 0);\r\nhw->master = master;\r\nhw->client = client;\r\nhw->dev = dev;\r\nhw->ctrl = 0xff;\r\nhw->id = id->driver_data;\r\nswitch (hw->id) {\r\ncase sc18is602:\r\ncase sc18is602b:\r\nmaster->num_chipselect = 4;\r\nhw->freq = SC18IS602_CLOCK;\r\nbreak;\r\ncase sc18is603:\r\nmaster->num_chipselect = 2;\r\nif (pdata) {\r\nhw->freq = pdata->clock_frequency;\r\n} else {\r\nconst __be32 *val;\r\nint len;\r\nval = of_get_property(np, "clock-frequency", &len);\r\nif (val && len >= sizeof(__be32))\r\nhw->freq = be32_to_cpup(val);\r\n}\r\nif (!hw->freq)\r\nhw->freq = SC18IS602_CLOCK;\r\nbreak;\r\n}\r\nmaster->bus_num = np ? -1 : client->adapter->nr;\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->setup = sc18is602_setup;\r\nmaster->transfer_one_message = sc18is602_transfer_one;\r\nmaster->dev.of_node = np;\r\nmaster->min_speed_hz = hw->freq / 128;\r\nmaster->max_speed_hz = hw->freq / 4;\r\nerror = devm_spi_register_master(dev, master);\r\nif (error)\r\ngoto error_reg;\r\nreturn 0;\r\nerror_reg:\r\nspi_master_put(master);\r\nreturn error;\r\n}
