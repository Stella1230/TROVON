int main(int argc, char **argv)\r\n{\r\nstruct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};\r\nchar filename[256];\r\nFILE *f;\r\nint i, sock;\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nsetrlimit(RLIMIT_MEMLOCK, &r);\r\nif (load_bpf_file(filename)) {\r\nprintf("%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\nsock = open_raw_sock("lo");\r\nassert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd[4],\r\nsizeof(__u32)) == 0);\r\nif (argc > 1)\r\nf = popen("ping -c5 localhost", "r");\r\nelse\r\nf = popen("netperf -l 4 localhost", "r");\r\n(void) f;\r\nfor (i = 0; i < 5; i++) {\r\nstruct bpf_flow_keys key = {}, next_key;\r\nstruct pair value;\r\nsleep(1);\r\nprintf("IP src.port -> dst.port bytes packets\n");\r\nwhile (bpf_map_get_next_key(map_fd[2], &key, &next_key) == 0) {\r\nbpf_map_lookup_elem(map_fd[2], &next_key, &value);\r\nprintf("%s.%05d -> %s.%05d %12lld %12lld\n",\r\ninet_ntoa((struct in_addr){htonl(next_key.src)}),\r\nnext_key.port16[0],\r\ninet_ntoa((struct in_addr){htonl(next_key.dst)}),\r\nnext_key.port16[1],\r\nvalue.bytes, value.packets);\r\nkey = next_key;\r\n}\r\n}\r\nreturn 0;\r\n}
