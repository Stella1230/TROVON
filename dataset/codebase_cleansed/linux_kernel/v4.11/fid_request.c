static int seq_client_rpc(struct lu_client_seq *seq,\r\nstruct lu_seq_range *output, __u32 opc,\r\nconst char *opcname)\r\n{\r\nstruct obd_export *exp = seq->lcs_exp;\r\nstruct ptlrpc_request *req;\r\nstruct lu_seq_range *out, *in;\r\n__u32 *op;\r\nunsigned int debug_mask;\r\nint rc;\r\nLASSERT(exp && !IS_ERR(exp));\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp), &RQF_SEQ_QUERY,\r\nLUSTRE_MDS_VERSION, SEQ_QUERY);\r\nif (!req)\r\nreturn -ENOMEM;\r\nop = req_capsule_client_get(&req->rq_pill, &RMF_SEQ_OPC);\r\n*op = opc;\r\nin = req_capsule_client_get(&req->rq_pill, &RMF_SEQ_RANGE);\r\nlu_seq_range_init(in);\r\nptlrpc_request_set_replen(req);\r\nin->lsr_index = seq->lcs_space.lsr_index;\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA)\r\nfld_range_set_mdt(in);\r\nelse\r\nfld_range_set_ost(in);\r\nif (opc == SEQ_ALLOC_SUPER) {\r\nreq->rq_request_portal = SEQ_CONTROLLER_PORTAL;\r\nreq->rq_reply_portal = MDC_REPLY_PORTAL;\r\nif (seq->lcs_type == LUSTRE_SEQ_DATA) {\r\nreq->rq_no_delay = 1;\r\nreq->rq_no_resend = 1;\r\n}\r\ndebug_mask = D_CONSOLE;\r\n} else {\r\nif (seq->lcs_type == LUSTRE_SEQ_METADATA) {\r\nreq->rq_reply_portal = MDC_REPLY_PORTAL;\r\nreq->rq_request_portal = SEQ_METADATA_PORTAL;\r\n} else {\r\nreq->rq_reply_portal = OSC_REPLY_PORTAL;\r\nreq->rq_request_portal = SEQ_DATA_PORTAL;\r\n}\r\ndebug_mask = D_INFO;\r\n}\r\nptlrpc_at_set_req_timeout(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out_req;\r\nout = req_capsule_server_get(&req->rq_pill, &RMF_SEQ_RANGE);\r\n*output = *out;\r\nif (!lu_seq_range_is_sane(output)) {\r\nCERROR("%s: Invalid range received from server: "\r\nDRANGE "\n", seq->lcs_name, PRANGE(output));\r\nrc = -EINVAL;\r\ngoto out_req;\r\n}\r\nif (lu_seq_range_is_exhausted(output)) {\r\nCERROR("%s: Range received from server is exhausted: "\r\nDRANGE "]\n", seq->lcs_name, PRANGE(output));\r\nrc = -EINVAL;\r\ngoto out_req;\r\n}\r\nCDEBUG_LIMIT(debug_mask, "%s: Allocated %s-sequence " DRANGE "]\n",\r\nseq->lcs_name, opcname, PRANGE(output));\r\nout_req:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int seq_client_alloc_meta(const struct lu_env *env,\r\nstruct lu_client_seq *seq)\r\n{\r\nint rc;\r\ndo {\r\nrc = seq_client_rpc(seq, &seq->lcs_space,\r\nSEQ_ALLOC_META, "meta");\r\n} while (rc == -EINPROGRESS || rc == -EAGAIN);\r\nreturn rc;\r\n}\r\nstatic int seq_client_alloc_seq(const struct lu_env *env,\r\nstruct lu_client_seq *seq, u64 *seqnr)\r\n{\r\nint rc;\r\nLASSERT(lu_seq_range_is_sane(&seq->lcs_space));\r\nif (lu_seq_range_is_exhausted(&seq->lcs_space)) {\r\nrc = seq_client_alloc_meta(env, seq);\r\nif (rc) {\r\nCERROR("%s: Can't allocate new meta-sequence, rc %d\n",\r\nseq->lcs_name, rc);\r\nreturn rc;\r\n}\r\nCDEBUG(D_INFO, "%s: New range - " DRANGE "\n",\r\nseq->lcs_name, PRANGE(&seq->lcs_space));\r\n} else {\r\nrc = 0;\r\n}\r\nLASSERT(!lu_seq_range_is_exhausted(&seq->lcs_space));\r\n*seqnr = seq->lcs_space.lsr_start;\r\nseq->lcs_space.lsr_start += 1;\r\nCDEBUG(D_INFO, "%s: Allocated sequence [%#llx]\n", seq->lcs_name,\r\n*seqnr);\r\nreturn rc;\r\n}\r\nstatic int seq_fid_alloc_prep(struct lu_client_seq *seq,\r\nwait_queue_t *link)\r\n{\r\nif (seq->lcs_update) {\r\nadd_wait_queue(&seq->lcs_waitq, link);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nmutex_unlock(&seq->lcs_mutex);\r\nschedule();\r\nmutex_lock(&seq->lcs_mutex);\r\nremove_wait_queue(&seq->lcs_waitq, link);\r\nset_current_state(TASK_RUNNING);\r\nreturn -EAGAIN;\r\n}\r\n++seq->lcs_update;\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn 0;\r\n}\r\nstatic void seq_fid_alloc_fini(struct lu_client_seq *seq)\r\n{\r\nLASSERT(seq->lcs_update == 1);\r\nmutex_lock(&seq->lcs_mutex);\r\n--seq->lcs_update;\r\nwake_up(&seq->lcs_waitq);\r\n}\r\nint seq_client_alloc_fid(const struct lu_env *env,\r\nstruct lu_client_seq *seq, struct lu_fid *fid)\r\n{\r\nwait_queue_t link;\r\nint rc;\r\nLASSERT(seq);\r\nLASSERT(fid);\r\ninit_waitqueue_entry(&link, current);\r\nmutex_lock(&seq->lcs_mutex);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_SEQ_EXHAUST))\r\nseq->lcs_fid.f_oid = seq->lcs_width;\r\nwhile (1) {\r\nu64 seqnr;\r\nif (!fid_is_zero(&seq->lcs_fid) &&\r\nfid_oid(&seq->lcs_fid) < seq->lcs_width) {\r\nseq->lcs_fid.f_oid += 1;\r\nrc = 0;\r\nbreak;\r\n}\r\nrc = seq_fid_alloc_prep(seq, &link);\r\nif (rc)\r\ncontinue;\r\nrc = seq_client_alloc_seq(env, seq, &seqnr);\r\nif (rc) {\r\nCERROR("%s: Can't allocate new sequence, rc %d\n",\r\nseq->lcs_name, rc);\r\nseq_fid_alloc_fini(seq);\r\nmutex_unlock(&seq->lcs_mutex);\r\nreturn rc;\r\n}\r\nCDEBUG(D_INFO, "%s: Switch to sequence [0x%16.16Lx]\n",\r\nseq->lcs_name, seqnr);\r\nseq->lcs_fid.f_oid = LUSTRE_FID_INIT_OID;\r\nseq->lcs_fid.f_seq = seqnr;\r\nseq->lcs_fid.f_ver = 0;\r\nrc = 1;\r\nseq_fid_alloc_fini(seq);\r\nbreak;\r\n}\r\n*fid = seq->lcs_fid;\r\nmutex_unlock(&seq->lcs_mutex);\r\nCDEBUG(D_INFO, "%s: Allocated FID "DFID"\n", seq->lcs_name, PFID(fid));\r\nreturn rc;\r\n}\r\nvoid seq_client_flush(struct lu_client_seq *seq)\r\n{\r\nwait_queue_t link;\r\nLASSERT(seq);\r\ninit_waitqueue_entry(&link, current);\r\nmutex_lock(&seq->lcs_mutex);\r\nwhile (seq->lcs_update) {\r\nadd_wait_queue(&seq->lcs_waitq, &link);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nmutex_unlock(&seq->lcs_mutex);\r\nschedule();\r\nmutex_lock(&seq->lcs_mutex);\r\nremove_wait_queue(&seq->lcs_waitq, &link);\r\nset_current_state(TASK_RUNNING);\r\n}\r\nfid_zero(&seq->lcs_fid);\r\nseq->lcs_space.lsr_index = -1;\r\nlu_seq_range_init(&seq->lcs_space);\r\nmutex_unlock(&seq->lcs_mutex);\r\n}\r\nstatic void seq_client_debugfs_fini(struct lu_client_seq *seq)\r\n{\r\nif (!IS_ERR_OR_NULL(seq->lcs_debugfs_entry))\r\nldebugfs_remove(&seq->lcs_debugfs_entry);\r\n}\r\nstatic int seq_client_debugfs_init(struct lu_client_seq *seq)\r\n{\r\nint rc;\r\nseq->lcs_debugfs_entry = ldebugfs_register(seq->lcs_name,\r\nseq_debugfs_dir,\r\nNULL, NULL);\r\nif (IS_ERR_OR_NULL(seq->lcs_debugfs_entry)) {\r\nCERROR("%s: LdebugFS failed in seq-init\n", seq->lcs_name);\r\nrc = seq->lcs_debugfs_entry ? PTR_ERR(seq->lcs_debugfs_entry)\r\n: -ENOMEM;\r\nseq->lcs_debugfs_entry = NULL;\r\nreturn rc;\r\n}\r\nrc = ldebugfs_add_vars(seq->lcs_debugfs_entry,\r\nseq_client_debugfs_list, seq);\r\nif (rc) {\r\nCERROR("%s: Can't init sequence manager debugfs, rc %d\n",\r\nseq->lcs_name, rc);\r\ngoto out_cleanup;\r\n}\r\nreturn 0;\r\nout_cleanup:\r\nseq_client_debugfs_fini(seq);\r\nreturn rc;\r\n}\r\nstatic void seq_client_fini(struct lu_client_seq *seq)\r\n{\r\nseq_client_debugfs_fini(seq);\r\nif (seq->lcs_exp) {\r\nclass_export_put(seq->lcs_exp);\r\nseq->lcs_exp = NULL;\r\n}\r\n}\r\nstatic int seq_client_init(struct lu_client_seq *seq,\r\nstruct obd_export *exp,\r\nenum lu_cli_type type,\r\nconst char *prefix)\r\n{\r\nint rc;\r\nLASSERT(seq);\r\nLASSERT(prefix);\r\nseq->lcs_type = type;\r\nmutex_init(&seq->lcs_mutex);\r\nif (type == LUSTRE_SEQ_METADATA)\r\nseq->lcs_width = LUSTRE_METADATA_SEQ_MAX_WIDTH;\r\nelse\r\nseq->lcs_width = LUSTRE_DATA_SEQ_MAX_WIDTH;\r\ninit_waitqueue_head(&seq->lcs_waitq);\r\nseq_client_flush(seq);\r\nseq->lcs_exp = class_export_get(exp);\r\nsnprintf(seq->lcs_name, sizeof(seq->lcs_name),\r\n"cli-%s", prefix);\r\nrc = seq_client_debugfs_init(seq);\r\nif (rc)\r\nseq_client_fini(seq);\r\nreturn rc;\r\n}\r\nint client_fid_init(struct obd_device *obd,\r\nstruct obd_export *exp, enum lu_cli_type type)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nchar *prefix;\r\nint rc;\r\ncli->cl_seq = kzalloc(sizeof(*cli->cl_seq), GFP_NOFS);\r\nif (!cli->cl_seq)\r\nreturn -ENOMEM;\r\nprefix = kzalloc(MAX_OBD_NAME + 5, GFP_NOFS);\r\nif (!prefix) {\r\nrc = -ENOMEM;\r\ngoto out_free_seq;\r\n}\r\nsnprintf(prefix, MAX_OBD_NAME + 5, "cli-%s", obd->obd_name);\r\nrc = seq_client_init(cli->cl_seq, exp, type, prefix);\r\nkfree(prefix);\r\nif (rc)\r\ngoto out_free_seq;\r\nreturn rc;\r\nout_free_seq:\r\nkfree(cli->cl_seq);\r\ncli->cl_seq = NULL;\r\nreturn rc;\r\n}\r\nint client_fid_fini(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_seq) {\r\nseq_client_fini(cli->cl_seq);\r\nkfree(cli->cl_seq);\r\ncli->cl_seq = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fid_init(void)\r\n{\r\nseq_debugfs_dir = ldebugfs_register(LUSTRE_SEQ_NAME,\r\ndebugfs_lustre_root,\r\nNULL, NULL);\r\nreturn PTR_ERR_OR_ZERO(seq_debugfs_dir);\r\n}\r\nstatic void __exit fid_exit(void)\r\n{\r\nif (!IS_ERR_OR_NULL(seq_debugfs_dir))\r\nldebugfs_remove(&seq_debugfs_dir);\r\n}
