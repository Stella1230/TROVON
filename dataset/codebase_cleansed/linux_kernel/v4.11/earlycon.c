static void __iomem * __init earlycon_map(resource_size_t paddr, size_t size)\r\n{\r\nvoid __iomem *base;\r\n#ifdef CONFIG_FIX_EARLYCON_MEM\r\nset_fixmap_io(FIX_EARLYCON_MEM_BASE, paddr & PAGE_MASK);\r\nbase = (void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);\r\nbase += paddr & ~PAGE_MASK;\r\n#else\r\nbase = ioremap(paddr, size);\r\n#endif\r\nif (!base)\r\npr_err("%s: Couldn't map %pa\n", __func__, &paddr);\r\nreturn base;\r\n}\r\nstatic void __init earlycon_init(struct earlycon_device *device,\r\nconst char *name)\r\n{\r\nstruct console *earlycon = device->con;\r\nstruct uart_port *port = &device->port;\r\nconst char *s;\r\nsize_t len;\r\nfor (s = name + strlen(name);\r\ns > name && s[-1] >= '0' && s[-1] <= '9';\r\ns--)\r\n;\r\nif (*s)\r\nearlycon->index = simple_strtoul(s, NULL, 10);\r\nlen = s - name;\r\nstrlcpy(earlycon->name, name, min(len + 1, sizeof(earlycon->name)));\r\nearlycon->data = &early_console_dev;\r\nif (port->iotype == UPIO_MEM || port->iotype == UPIO_MEM16 ||\r\nport->iotype == UPIO_MEM32 || port->iotype == UPIO_MEM32BE)\r\npr_info("%s%d at MMIO%s %pa (options '%s')\n",\r\nearlycon->name, earlycon->index,\r\n(port->iotype == UPIO_MEM) ? "" :\r\n(port->iotype == UPIO_MEM16) ? "16" :\r\n(port->iotype == UPIO_MEM32) ? "32" : "32be",\r\n&port->mapbase, device->options);\r\nelse\r\npr_info("%s%d at I/O port 0x%lx (options '%s')\n",\r\nearlycon->name, earlycon->index,\r\nport->iobase, device->options);\r\n}\r\nstatic int __init parse_options(struct earlycon_device *device, char *options)\r\n{\r\nstruct uart_port *port = &device->port;\r\nint length;\r\nresource_size_t addr;\r\nif (uart_parse_earlycon(options, &port->iotype, &addr, &options))\r\nreturn -EINVAL;\r\nswitch (port->iotype) {\r\ncase UPIO_MEM:\r\nport->mapbase = addr;\r\nbreak;\r\ncase UPIO_MEM16:\r\nport->regshift = 1;\r\nport->mapbase = addr;\r\nbreak;\r\ncase UPIO_MEM32:\r\ncase UPIO_MEM32BE:\r\nport->regshift = 2;\r\nport->mapbase = addr;\r\nbreak;\r\ncase UPIO_PORT:\r\nport->iobase = addr;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (options) {\r\ndevice->baud = simple_strtoul(options, NULL, 0);\r\nlength = min(strcspn(options, " ") + 1,\r\n(size_t)(sizeof(device->options)));\r\nstrlcpy(device->options, options, length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init register_earlycon(char *buf, const struct earlycon_id *match)\r\n{\r\nint err;\r\nstruct uart_port *port = &early_console_dev.port;\r\nif (buf && !parse_options(&early_console_dev, buf))\r\nbuf = NULL;\r\nspin_lock_init(&port->lock);\r\nport->uartclk = BASE_BAUD * 16;\r\nif (port->mapbase)\r\nport->membase = earlycon_map(port->mapbase, 64);\r\nearlycon_init(&early_console_dev, match->name);\r\nerr = match->setup(&early_console_dev, buf);\r\nif (err < 0)\r\nreturn err;\r\nif (!early_console_dev.con->write)\r\nreturn -ENODEV;\r\nregister_console(early_console_dev.con);\r\nreturn 0;\r\n}\r\nint __init setup_earlycon(char *buf)\r\n{\r\nconst struct earlycon_id *match;\r\nif (!buf || !buf[0])\r\nreturn -EINVAL;\r\nif (early_con.flags & CON_ENABLED)\r\nreturn -EALREADY;\r\nfor (match = __earlycon_table; match < __earlycon_table_end; match++) {\r\nsize_t len = strlen(match->name);\r\nif (strncmp(buf, match->name, len))\r\ncontinue;\r\nif (buf[len]) {\r\nif (buf[len] != ',')\r\ncontinue;\r\nbuf += len + 1;\r\n} else\r\nbuf = NULL;\r\nreturn register_earlycon(buf, match);\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int __init param_setup_earlycon(char *buf)\r\n{\r\nint err;\r\nif (!buf || !buf[0]) {\r\nif (IS_ENABLED(CONFIG_ACPI_SPCR_TABLE)) {\r\nearlycon_init_is_deferred = true;\r\nreturn 0;\r\n} else {\r\nreturn early_init_dt_scan_chosen_stdout();\r\n}\r\n}\r\nerr = setup_earlycon(buf);\r\nif (err == -ENOENT || err == -EALREADY)\r\nreturn 0;\r\nreturn err;\r\n}\r\nint __init of_setup_earlycon(const struct earlycon_id *match,\r\nunsigned long node,\r\nconst char *options)\r\n{\r\nint err;\r\nstruct uart_port *port = &early_console_dev.port;\r\nconst __be32 *val;\r\nbool big_endian;\r\nu64 addr;\r\nspin_lock_init(&port->lock);\r\nport->iotype = UPIO_MEM;\r\naddr = of_flat_dt_translate_address(node);\r\nif (addr == OF_BAD_ADDR) {\r\npr_warn("[%s] bad address\n", match->name);\r\nreturn -ENXIO;\r\n}\r\nport->mapbase = addr;\r\nport->uartclk = BASE_BAUD * 16;\r\nport->membase = earlycon_map(port->mapbase, SZ_4K);\r\nval = of_get_flat_dt_prop(node, "reg-offset", NULL);\r\nif (val)\r\nport->mapbase += be32_to_cpu(*val);\r\nval = of_get_flat_dt_prop(node, "reg-shift", NULL);\r\nif (val)\r\nport->regshift = be32_to_cpu(*val);\r\nbig_endian = of_get_flat_dt_prop(node, "big-endian", NULL) != NULL ||\r\n(IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&\r\nof_get_flat_dt_prop(node, "native-endian", NULL) != NULL);\r\nval = of_get_flat_dt_prop(node, "reg-io-width", NULL);\r\nif (val) {\r\nswitch (be32_to_cpu(*val)) {\r\ncase 1:\r\nport->iotype = UPIO_MEM;\r\nbreak;\r\ncase 2:\r\nport->iotype = UPIO_MEM16;\r\nbreak;\r\ncase 4:\r\nport->iotype = (big_endian) ? UPIO_MEM32BE : UPIO_MEM32;\r\nbreak;\r\ndefault:\r\npr_warn("[%s] unsupported reg-io-width\n", match->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (options) {\r\nstrlcpy(early_console_dev.options, options,\r\nsizeof(early_console_dev.options));\r\n}\r\nearlycon_init(&early_console_dev, match->name);\r\nerr = match->setup(&early_console_dev, options);\r\nif (err < 0)\r\nreturn err;\r\nif (!early_console_dev.con->write)\r\nreturn -ENODEV;\r\nregister_console(early_console_dev.con);\r\nreturn 0;\r\n}
