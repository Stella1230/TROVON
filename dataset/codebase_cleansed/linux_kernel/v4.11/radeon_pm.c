int radeon_pm_get_type_index(struct radeon_device *rdev,\r\nenum radeon_pm_state_type ps_type,\r\nint instance)\r\n{\r\nint i;\r\nint found_instance = -1;\r\nfor (i = 0; i < rdev->pm.num_power_states; i++) {\r\nif (rdev->pm.power_state[i].type == ps_type) {\r\nfound_instance++;\r\nif (found_instance == instance)\r\nreturn i;\r\n}\r\n}\r\nreturn rdev->pm.default_power_state_index;\r\n}\r\nvoid radeon_pm_acpi_event_handler(struct radeon_device *rdev)\r\n{\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nmutex_lock(&rdev->pm.mutex);\r\nif (power_supply_is_system_supplied() > 0)\r\nrdev->pm.dpm.ac_power = true;\r\nelse\r\nrdev->pm.dpm.ac_power = false;\r\nif (rdev->family == CHIP_ARUBA) {\r\nif (rdev->asic->dpm.enable_bapm)\r\nradeon_dpm_enable_bapm(rdev, rdev->pm.dpm.ac_power);\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\nradeon_pm_compute_clocks_dpm(rdev);\r\n} else if (rdev->pm.pm_method == PM_METHOD_PROFILE) {\r\nif (rdev->pm.profile == PM_PROFILE_AUTO) {\r\nmutex_lock(&rdev->pm.mutex);\r\nradeon_pm_update_profile(rdev);\r\nradeon_pm_set_clocks(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\n}\r\n}\r\nstatic void radeon_pm_update_profile(struct radeon_device *rdev)\r\n{\r\nswitch (rdev->pm.profile) {\r\ncase PM_PROFILE_DEFAULT:\r\nrdev->pm.profile_index = PM_PROFILE_DEFAULT_IDX;\r\nbreak;\r\ncase PM_PROFILE_AUTO:\r\nif (power_supply_is_system_supplied() > 0) {\r\nif (rdev->pm.active_crtc_count > 1)\r\nrdev->pm.profile_index = PM_PROFILE_HIGH_MH_IDX;\r\nelse\r\nrdev->pm.profile_index = PM_PROFILE_HIGH_SH_IDX;\r\n} else {\r\nif (rdev->pm.active_crtc_count > 1)\r\nrdev->pm.profile_index = PM_PROFILE_MID_MH_IDX;\r\nelse\r\nrdev->pm.profile_index = PM_PROFILE_MID_SH_IDX;\r\n}\r\nbreak;\r\ncase PM_PROFILE_LOW:\r\nif (rdev->pm.active_crtc_count > 1)\r\nrdev->pm.profile_index = PM_PROFILE_LOW_MH_IDX;\r\nelse\r\nrdev->pm.profile_index = PM_PROFILE_LOW_SH_IDX;\r\nbreak;\r\ncase PM_PROFILE_MID:\r\nif (rdev->pm.active_crtc_count > 1)\r\nrdev->pm.profile_index = PM_PROFILE_MID_MH_IDX;\r\nelse\r\nrdev->pm.profile_index = PM_PROFILE_MID_SH_IDX;\r\nbreak;\r\ncase PM_PROFILE_HIGH:\r\nif (rdev->pm.active_crtc_count > 1)\r\nrdev->pm.profile_index = PM_PROFILE_HIGH_MH_IDX;\r\nelse\r\nrdev->pm.profile_index = PM_PROFILE_HIGH_SH_IDX;\r\nbreak;\r\n}\r\nif (rdev->pm.active_crtc_count == 0) {\r\nrdev->pm.requested_power_state_index =\r\nrdev->pm.profiles[rdev->pm.profile_index].dpms_off_ps_idx;\r\nrdev->pm.requested_clock_mode_index =\r\nrdev->pm.profiles[rdev->pm.profile_index].dpms_off_cm_idx;\r\n} else {\r\nrdev->pm.requested_power_state_index =\r\nrdev->pm.profiles[rdev->pm.profile_index].dpms_on_ps_idx;\r\nrdev->pm.requested_clock_mode_index =\r\nrdev->pm.profiles[rdev->pm.profile_index].dpms_on_cm_idx;\r\n}\r\n}\r\nstatic void radeon_unmap_vram_bos(struct radeon_device *rdev)\r\n{\r\nstruct radeon_bo *bo, *n;\r\nif (list_empty(&rdev->gem.objects))\r\nreturn;\r\nlist_for_each_entry_safe(bo, n, &rdev->gem.objects, list) {\r\nif (bo->tbo.mem.mem_type == TTM_PL_VRAM)\r\nttm_bo_unmap_virtual(&bo->tbo);\r\n}\r\n}\r\nstatic void radeon_sync_with_vblank(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.active_crtcs) {\r\nrdev->pm.vblank_sync = false;\r\nwait_event_timeout(\r\nrdev->irq.vblank_queue, rdev->pm.vblank_sync,\r\nmsecs_to_jiffies(RADEON_WAIT_VBLANK_TIMEOUT));\r\n}\r\n}\r\nstatic void radeon_set_power_state(struct radeon_device *rdev)\r\n{\r\nu32 sclk, mclk;\r\nbool misc_after = false;\r\nif ((rdev->pm.requested_clock_mode_index == rdev->pm.current_clock_mode_index) &&\r\n(rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index))\r\nreturn;\r\nif (radeon_gui_idle(rdev)) {\r\nsclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\r\nclock_info[rdev->pm.requested_clock_mode_index].sclk;\r\nif (sclk > rdev->pm.default_sclk)\r\nsclk = rdev->pm.default_sclk;\r\nif ((rdev->pm.pm_method == PM_METHOD_PROFILE) &&\r\n(rdev->family >= CHIP_BARTS) &&\r\nrdev->pm.active_crtc_count &&\r\n((rdev->pm.profile_index == PM_PROFILE_MID_MH_IDX) ||\r\n(rdev->pm.profile_index == PM_PROFILE_LOW_MH_IDX)))\r\nmclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\r\nclock_info[rdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx].mclk;\r\nelse\r\nmclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\r\nclock_info[rdev->pm.requested_clock_mode_index].mclk;\r\nif (mclk > rdev->pm.default_mclk)\r\nmclk = rdev->pm.default_mclk;\r\nif (sclk < rdev->pm.current_sclk)\r\nmisc_after = true;\r\nradeon_sync_with_vblank(rdev);\r\nif (rdev->pm.pm_method == PM_METHOD_DYNPM) {\r\nif (!radeon_pm_in_vbl(rdev))\r\nreturn;\r\n}\r\nradeon_pm_prepare(rdev);\r\nif (!misc_after)\r\nradeon_pm_misc(rdev);\r\nif (sclk != rdev->pm.current_sclk) {\r\nradeon_pm_debug_check_in_vbl(rdev, false);\r\nradeon_set_engine_clock(rdev, sclk);\r\nradeon_pm_debug_check_in_vbl(rdev, true);\r\nrdev->pm.current_sclk = sclk;\r\nDRM_DEBUG_DRIVER("Setting: e: %d\n", sclk);\r\n}\r\nif (rdev->asic->pm.set_memory_clock && (mclk != rdev->pm.current_mclk)) {\r\nradeon_pm_debug_check_in_vbl(rdev, false);\r\nradeon_set_memory_clock(rdev, mclk);\r\nradeon_pm_debug_check_in_vbl(rdev, true);\r\nrdev->pm.current_mclk = mclk;\r\nDRM_DEBUG_DRIVER("Setting: m: %d\n", mclk);\r\n}\r\nif (misc_after)\r\nradeon_pm_misc(rdev);\r\nradeon_pm_finish(rdev);\r\nrdev->pm.current_power_state_index = rdev->pm.requested_power_state_index;\r\nrdev->pm.current_clock_mode_index = rdev->pm.requested_clock_mode_index;\r\n} else\r\nDRM_DEBUG_DRIVER("pm: GUI not idle!!!\n");\r\n}\r\nstatic void radeon_pm_set_clocks(struct radeon_device *rdev)\r\n{\r\nstruct drm_crtc *crtc;\r\nint i, r;\r\nif ((rdev->pm.requested_clock_mode_index == rdev->pm.current_clock_mode_index) &&\r\n(rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index))\r\nreturn;\r\ndown_write(&rdev->pm.mclk_lock);\r\nmutex_lock(&rdev->ring_lock);\r\nfor (i = 0; i < RADEON_NUM_RINGS; i++) {\r\nstruct radeon_ring *ring = &rdev->ring[i];\r\nif (!ring->ready) {\r\ncontinue;\r\n}\r\nr = radeon_fence_wait_empty(rdev, i);\r\nif (r) {\r\nmutex_unlock(&rdev->ring_lock);\r\nup_write(&rdev->pm.mclk_lock);\r\nreturn;\r\n}\r\n}\r\nradeon_unmap_vram_bos(rdev);\r\nif (rdev->irq.installed) {\r\ni = 0;\r\ndrm_for_each_crtc(crtc, rdev->ddev) {\r\nif (rdev->pm.active_crtcs & (1 << i)) {\r\nif (drm_crtc_vblank_get(crtc) == 0)\r\nrdev->pm.req_vblank |= (1 << i);\r\nelse\r\nDRM_DEBUG_DRIVER("crtc %d no vblank, can glitch\n",\r\ni);\r\n}\r\ni++;\r\n}\r\n}\r\nradeon_set_power_state(rdev);\r\nif (rdev->irq.installed) {\r\ni = 0;\r\ndrm_for_each_crtc(crtc, rdev->ddev) {\r\nif (rdev->pm.req_vblank & (1 << i)) {\r\nrdev->pm.req_vblank &= ~(1 << i);\r\ndrm_crtc_vblank_put(crtc);\r\n}\r\ni++;\r\n}\r\n}\r\nradeon_update_bandwidth_info(rdev);\r\nif (rdev->pm.active_crtc_count)\r\nradeon_bandwidth_update(rdev);\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\r\nmutex_unlock(&rdev->ring_lock);\r\nup_write(&rdev->pm.mclk_lock);\r\n}\r\nstatic void radeon_pm_print_states(struct radeon_device *rdev)\r\n{\r\nint i, j;\r\nstruct radeon_power_state *power_state;\r\nstruct radeon_pm_clock_info *clock_info;\r\nDRM_DEBUG_DRIVER("%d Power State(s)\n", rdev->pm.num_power_states);\r\nfor (i = 0; i < rdev->pm.num_power_states; i++) {\r\npower_state = &rdev->pm.power_state[i];\r\nDRM_DEBUG_DRIVER("State %d: %s\n", i,\r\nradeon_pm_state_type_name[power_state->type]);\r\nif (i == rdev->pm.default_power_state_index)\r\nDRM_DEBUG_DRIVER("\tDefault");\r\nif ((rdev->flags & RADEON_IS_PCIE) && !(rdev->flags & RADEON_IS_IGP))\r\nDRM_DEBUG_DRIVER("\t%d PCIE Lanes\n", power_state->pcie_lanes);\r\nif (power_state->flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\r\nDRM_DEBUG_DRIVER("\tSingle display only\n");\r\nDRM_DEBUG_DRIVER("\t%d Clock Mode(s)\n", power_state->num_clock_modes);\r\nfor (j = 0; j < power_state->num_clock_modes; j++) {\r\nclock_info = &(power_state->clock_info[j]);\r\nif (rdev->flags & RADEON_IS_IGP)\r\nDRM_DEBUG_DRIVER("\t\t%d e: %d\n",\r\nj,\r\nclock_info->sclk * 10);\r\nelse\r\nDRM_DEBUG_DRIVER("\t\t%d e: %d\tm: %d\tv: %d\n",\r\nj,\r\nclock_info->sclk * 10,\r\nclock_info->mclk * 10,\r\nclock_info->voltage.voltage);\r\n}\r\n}\r\n}\r\nstatic ssize_t radeon_get_pm_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nint cp = rdev->pm.profile;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(cp == PM_PROFILE_AUTO) ? "auto" :\r\n(cp == PM_PROFILE_LOW) ? "low" :\r\n(cp == PM_PROFILE_MID) ? "mid" :\r\n(cp == PM_PROFILE_HIGH) ? "high" : "default");\r\n}\r\nstatic ssize_t radeon_set_pm_profile(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn -EINVAL;\r\nmutex_lock(&rdev->pm.mutex);\r\nif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\r\nif (strncmp("default", buf, strlen("default")) == 0)\r\nrdev->pm.profile = PM_PROFILE_DEFAULT;\r\nelse if (strncmp("auto", buf, strlen("auto")) == 0)\r\nrdev->pm.profile = PM_PROFILE_AUTO;\r\nelse if (strncmp("low", buf, strlen("low")) == 0)\r\nrdev->pm.profile = PM_PROFILE_LOW;\r\nelse if (strncmp("mid", buf, strlen("mid")) == 0)\r\nrdev->pm.profile = PM_PROFILE_MID;\r\nelse if (strncmp("high", buf, strlen("high")) == 0)\r\nrdev->pm.profile = PM_PROFILE_HIGH;\r\nelse {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nradeon_pm_update_profile(rdev);\r\nradeon_pm_set_clocks(rdev);\r\n} else\r\ncount = -EINVAL;\r\nfail:\r\nmutex_unlock(&rdev->pm.mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_get_pm_method(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nint pm = rdev->pm.pm_method;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(pm == PM_METHOD_DYNPM) ? "dynpm" :\r\n(pm == PM_METHOD_PROFILE) ? "profile" : "dpm");\r\n}\r\nstatic ssize_t radeon_set_pm_method(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON)) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (rdev->pm.pm_method == PM_METHOD_DPM) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (strncmp("dynpm", buf, strlen("dynpm")) == 0) {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.pm_method = PM_METHOD_DYNPM;\r\nrdev->pm.dynpm_state = DYNPM_STATE_PAUSED;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\r\nmutex_unlock(&rdev->pm.mutex);\r\n} else if (strncmp("profile", buf, strlen("profile")) == 0) {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nmutex_unlock(&rdev->pm.mutex);\r\ncancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\r\n} else {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nradeon_pm_compute_clocks(rdev);\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_get_dpm_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nenum radeon_pm_state_type pm = rdev->pm.dpm.user_state;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(pm == POWER_STATE_TYPE_BATTERY) ? "battery" :\r\n(pm == POWER_STATE_TYPE_BALANCED) ? "balanced" : "performance");\r\n}\r\nstatic ssize_t radeon_set_dpm_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nmutex_lock(&rdev->pm.mutex);\r\nif (strncmp("battery", buf, strlen("battery")) == 0)\r\nrdev->pm.dpm.user_state = POWER_STATE_TYPE_BATTERY;\r\nelse if (strncmp("balanced", buf, strlen("balanced")) == 0)\r\nrdev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\r\nelse if (strncmp("performance", buf, strlen("performance")) == 0)\r\nrdev->pm.dpm.user_state = POWER_STATE_TYPE_PERFORMANCE;\r\nelse {\r\nmutex_unlock(&rdev->pm.mutex);\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\nif (!(rdev->flags & RADEON_IS_PX) ||\r\n(ddev->switch_power_state == DRM_SWITCH_POWER_ON))\r\nradeon_pm_compute_clocks(rdev);\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_get_dpm_forced_performance_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nenum radeon_dpm_forced_level level = rdev->pm.dpm.forced_level;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn snprintf(buf, PAGE_SIZE, "off\n");\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\n(level == RADEON_DPM_FORCED_LEVEL_AUTO) ? "auto" :\r\n(level == RADEON_DPM_FORCED_LEVEL_LOW) ? "low" : "high");\r\n}\r\nstatic ssize_t radeon_set_dpm_forced_performance_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct drm_device *ddev = dev_get_drvdata(dev);\r\nstruct radeon_device *rdev = ddev->dev_private;\r\nenum radeon_dpm_forced_level level;\r\nint ret = 0;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn -EINVAL;\r\nmutex_lock(&rdev->pm.mutex);\r\nif (strncmp("low", buf, strlen("low")) == 0) {\r\nlevel = RADEON_DPM_FORCED_LEVEL_LOW;\r\n} else if (strncmp("high", buf, strlen("high")) == 0) {\r\nlevel = RADEON_DPM_FORCED_LEVEL_HIGH;\r\n} else if (strncmp("auto", buf, strlen("auto")) == 0) {\r\nlevel = RADEON_DPM_FORCED_LEVEL_AUTO;\r\n} else {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nif (rdev->asic->dpm.force_performance_level) {\r\nif (rdev->pm.dpm.thermal_active) {\r\ncount = -EINVAL;\r\ngoto fail;\r\n}\r\nret = radeon_dpm_force_performance_level(rdev, level);\r\nif (ret)\r\ncount = -EINVAL;\r\n}\r\nfail:\r\nmutex_unlock(&rdev->pm.mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_hwmon_get_pwm1_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nu32 pwm_mode = 0;\r\nif (rdev->asic->dpm.fan_ctrl_get_mode)\r\npwm_mode = rdev->asic->dpm.fan_ctrl_get_mode(rdev);\r\nreturn sprintf(buf, "%i\n", pwm_mode == FDO_PWM_MODE_STATIC ? 1 : 2);\r\n}\r\nstatic ssize_t radeon_hwmon_set_pwm1_enable(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nint err;\r\nint value;\r\nif(!rdev->asic->dpm.fan_ctrl_set_mode)\r\nreturn -EINVAL;\r\nerr = kstrtoint(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nswitch (value) {\r\ncase 1:\r\nrdev->asic->dpm.fan_ctrl_set_mode(rdev, FDO_PWM_MODE_STATIC);\r\nbreak;\r\ndefault:\r\nrdev->asic->dpm.fan_ctrl_set_mode(rdev, 0);\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_hwmon_get_pwm1_min(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", 0);\r\n}\r\nstatic ssize_t radeon_hwmon_get_pwm1_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%i\n", 255);\r\n}\r\nstatic ssize_t radeon_hwmon_set_pwm1(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nint err;\r\nu32 value;\r\nerr = kstrtou32(buf, 10, &value);\r\nif (err)\r\nreturn err;\r\nvalue = (value * 100) / 255;\r\nerr = rdev->asic->dpm.set_fan_speed_percent(rdev, value);\r\nif (err)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t radeon_hwmon_get_pwm1(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nint err;\r\nu32 speed;\r\nerr = rdev->asic->dpm.get_fan_speed_percent(rdev, &speed);\r\nif (err)\r\nreturn err;\r\nspeed = (speed * 255) / 100;\r\nreturn sprintf(buf, "%i\n", speed);\r\n}\r\nstatic ssize_t radeon_hwmon_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nstruct drm_device *ddev = rdev->ddev;\r\nint temp;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\r\nreturn -EINVAL;\r\nif (rdev->asic->pm.get_temperature)\r\ntemp = radeon_get_temperature(rdev);\r\nelse\r\ntemp = 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic ssize_t radeon_hwmon_show_temp_thresh(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\nint hyst = to_sensor_dev_attr(attr)->index;\r\nint temp;\r\nif (hyst)\r\ntemp = rdev->pm.dpm.thermal.min_temp;\r\nelse\r\ntemp = rdev->pm.dpm.thermal.max_temp;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic umode_t hwmon_attributes_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct radeon_device *rdev = dev_get_drvdata(dev);\r\numode_t effective_mode = attr->mode;\r\nif (rdev->pm.pm_method != PM_METHOD_DPM &&\r\n(attr == &sensor_dev_attr_temp1_crit.dev_attr.attr ||\r\nattr == &sensor_dev_attr_temp1_crit_hyst.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nif (rdev->pm.no_fan &&\r\n(attr == &sensor_dev_attr_pwm1.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nif ((!rdev->asic->dpm.get_fan_speed_percent &&\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr) ||\r\n(!rdev->asic->dpm.fan_ctrl_get_mode &&\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))\r\neffective_mode &= ~S_IRUGO;\r\nif ((!rdev->asic->dpm.set_fan_speed_percent &&\r\nattr == &sensor_dev_attr_pwm1.dev_attr.attr) ||\r\n(!rdev->asic->dpm.fan_ctrl_set_mode &&\r\nattr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))\r\neffective_mode &= ~S_IWUSR;\r\nif ((!rdev->asic->dpm.set_fan_speed_percent &&\r\n!rdev->asic->dpm.get_fan_speed_percent) &&\r\n(attr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\r\nattr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\r\nreturn 0;\r\nreturn effective_mode;\r\n}\r\nstatic int radeon_hwmon_init(struct radeon_device *rdev)\r\n{\r\nint err = 0;\r\nswitch (rdev->pm.int_thermal_type) {\r\ncase THERMAL_TYPE_RV6XX:\r\ncase THERMAL_TYPE_RV770:\r\ncase THERMAL_TYPE_EVERGREEN:\r\ncase THERMAL_TYPE_NI:\r\ncase THERMAL_TYPE_SUMO:\r\ncase THERMAL_TYPE_SI:\r\ncase THERMAL_TYPE_CI:\r\ncase THERMAL_TYPE_KV:\r\nif (rdev->asic->pm.get_temperature == NULL)\r\nreturn err;\r\nrdev->pm.int_hwmon_dev = hwmon_device_register_with_groups(rdev->dev,\r\n"radeon", rdev,\r\nhwmon_groups);\r\nif (IS_ERR(rdev->pm.int_hwmon_dev)) {\r\nerr = PTR_ERR(rdev->pm.int_hwmon_dev);\r\ndev_err(rdev->dev,\r\n"Unable to register hwmon device: %d\n", err);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void radeon_hwmon_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.int_hwmon_dev)\r\nhwmon_device_unregister(rdev->pm.int_hwmon_dev);\r\n}\r\nstatic void radeon_dpm_thermal_work_handler(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev =\r\ncontainer_of(work, struct radeon_device,\r\npm.dpm.thermal.work);\r\nenum radeon_pm_state_type dpm_state = POWER_STATE_TYPE_INTERNAL_THERMAL;\r\nif (!rdev->pm.dpm_enabled)\r\nreturn;\r\nif (rdev->asic->pm.get_temperature) {\r\nint temp = radeon_get_temperature(rdev);\r\nif (temp < rdev->pm.dpm.thermal.min_temp)\r\ndpm_state = rdev->pm.dpm.user_state;\r\n} else {\r\nif (rdev->pm.dpm.thermal.high_to_low)\r\ndpm_state = rdev->pm.dpm.user_state;\r\n}\r\nmutex_lock(&rdev->pm.mutex);\r\nif (dpm_state == POWER_STATE_TYPE_INTERNAL_THERMAL)\r\nrdev->pm.dpm.thermal_active = true;\r\nelse\r\nrdev->pm.dpm.thermal_active = false;\r\nrdev->pm.dpm.state = dpm_state;\r\nmutex_unlock(&rdev->pm.mutex);\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\nstatic bool radeon_dpm_single_display(struct radeon_device *rdev)\r\n{\r\nbool single_display = (rdev->pm.dpm.new_active_crtc_count < 2) ?\r\ntrue : false;\r\nif (single_display && rdev->asic->dpm.vblank_too_short) {\r\nif (radeon_dpm_vblank_too_short(rdev))\r\nsingle_display = false;\r\n}\r\nif (single_display && (r600_dpm_get_vrefresh(rdev) >= 120))\r\nsingle_display = false;\r\nreturn single_display;\r\n}\r\nstatic struct radeon_ps *radeon_dpm_pick_power_state(struct radeon_device *rdev,\r\nenum radeon_pm_state_type dpm_state)\r\n{\r\nint i;\r\nstruct radeon_ps *ps;\r\nu32 ui_class;\r\nbool single_display = radeon_dpm_single_display(rdev);\r\nif (dpm_state == POWER_STATE_TYPE_PERFORMANCE)\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_3DPERF;\r\nif (dpm_state == POWER_STATE_TYPE_BALANCED)\r\ndpm_state = rdev->pm.dpm.ac_power ?\r\nPOWER_STATE_TYPE_PERFORMANCE : POWER_STATE_TYPE_BATTERY;\r\nrestart_search:\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nps = &rdev->pm.dpm.ps[i];\r\nui_class = ps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK;\r\nswitch (dpm_state) {\r\ncase POWER_STATE_TYPE_BATTERY:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_BALANCED:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BALANCED) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_PERFORMANCE:\r\nif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\r\nif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\r\nif (single_display)\r\nreturn ps;\r\n} else\r\nreturn ps;\r\n}\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD:\r\nif (rdev->pm.dpm.uvd_ps)\r\nreturn rdev->pm.dpm.uvd_ps;\r\nelse\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_SD:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\r\nif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_BOOT:\r\nreturn rdev->pm.dpm.boot_ps;\r\ncase POWER_STATE_TYPE_INTERNAL_THERMAL:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_ACPI:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_ULV:\r\nif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\r\nreturn ps;\r\nbreak;\r\ncase POWER_STATE_TYPE_INTERNAL_3DPERF:\r\nif (ps->class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nreturn ps;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (dpm_state) {\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_SD:\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD:\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\r\ncase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\r\nif (rdev->pm.dpm.uvd_ps) {\r\nreturn rdev->pm.dpm.uvd_ps;\r\n} else {\r\ndpm_state = POWER_STATE_TYPE_PERFORMANCE;\r\ngoto restart_search;\r\n}\r\ncase POWER_STATE_TYPE_INTERNAL_THERMAL:\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_ACPI;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_INTERNAL_ACPI:\r\ndpm_state = POWER_STATE_TYPE_BATTERY;\r\ngoto restart_search;\r\ncase POWER_STATE_TYPE_BATTERY:\r\ncase POWER_STATE_TYPE_BALANCED:\r\ncase POWER_STATE_TYPE_INTERNAL_3DPERF:\r\ndpm_state = POWER_STATE_TYPE_PERFORMANCE;\r\ngoto restart_search;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void radeon_dpm_change_power_state_locked(struct radeon_device *rdev)\r\n{\r\nint i;\r\nstruct radeon_ps *ps;\r\nenum radeon_pm_state_type dpm_state;\r\nint ret;\r\nbool single_display = radeon_dpm_single_display(rdev);\r\nif (!rdev->pm.dpm_enabled)\r\nreturn;\r\nif (rdev->pm.dpm.user_state != rdev->pm.dpm.state) {\r\nif ((!rdev->pm.dpm.thermal_active) &&\r\n(!rdev->pm.dpm.uvd_active))\r\nrdev->pm.dpm.state = rdev->pm.dpm.user_state;\r\n}\r\ndpm_state = rdev->pm.dpm.state;\r\nps = radeon_dpm_pick_power_state(rdev, dpm_state);\r\nif (ps)\r\nrdev->pm.dpm.requested_ps = ps;\r\nelse\r\nreturn;\r\nif (rdev->pm.dpm.current_ps == rdev->pm.dpm.requested_ps) {\r\nif (ps->vce_active != rdev->pm.dpm.vce_active)\r\ngoto force;\r\nif (rdev->pm.dpm.single_display != single_display)\r\ngoto force;\r\nif ((rdev->family < CHIP_BARTS) || (rdev->flags & RADEON_IS_IGP)) {\r\nif (rdev->pm.dpm.new_active_crtcs != rdev->pm.dpm.current_active_crtcs) {\r\nradeon_bandwidth_update(rdev);\r\nradeon_dpm_display_configuration_changed(rdev);\r\nrdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\r\nrdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\r\n}\r\nreturn;\r\n} else {\r\nif (rdev->pm.dpm.new_active_crtcs ==\r\nrdev->pm.dpm.current_active_crtcs) {\r\nreturn;\r\n} else {\r\nif ((rdev->pm.dpm.current_active_crtc_count > 1) &&\r\n(rdev->pm.dpm.new_active_crtc_count > 1)) {\r\nradeon_bandwidth_update(rdev);\r\nradeon_dpm_display_configuration_changed(rdev);\r\nrdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\r\nrdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nforce:\r\nif (radeon_dpm == 1) {\r\nprintk("switching from power state:\n");\r\nradeon_dpm_print_power_state(rdev, rdev->pm.dpm.current_ps);\r\nprintk("switching to power state:\n");\r\nradeon_dpm_print_power_state(rdev, rdev->pm.dpm.requested_ps);\r\n}\r\ndown_write(&rdev->pm.mclk_lock);\r\nmutex_lock(&rdev->ring_lock);\r\nps->vce_active = rdev->pm.dpm.vce_active;\r\nret = radeon_dpm_pre_set_power_state(rdev);\r\nif (ret)\r\ngoto done;\r\nradeon_bandwidth_update(rdev);\r\nradeon_dpm_display_configuration_changed(rdev);\r\nfor (i = 0; i < RADEON_NUM_RINGS; i++) {\r\nstruct radeon_ring *ring = &rdev->ring[i];\r\nif (ring->ready)\r\nradeon_fence_wait_empty(rdev, i);\r\n}\r\nradeon_dpm_set_power_state(rdev);\r\nrdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps;\r\nradeon_dpm_post_set_power_state(rdev);\r\nrdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\r\nrdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\r\nrdev->pm.dpm.single_display = single_display;\r\nif (rdev->asic->dpm.force_performance_level) {\r\nif (rdev->pm.dpm.thermal_active) {\r\nenum radeon_dpm_forced_level level = rdev->pm.dpm.forced_level;\r\nradeon_dpm_force_performance_level(rdev, RADEON_DPM_FORCED_LEVEL_LOW);\r\nrdev->pm.dpm.forced_level = level;\r\n} else {\r\nradeon_dpm_force_performance_level(rdev, rdev->pm.dpm.forced_level);\r\n}\r\n}\r\ndone:\r\nmutex_unlock(&rdev->ring_lock);\r\nup_write(&rdev->pm.mclk_lock);\r\n}\r\nvoid radeon_dpm_enable_uvd(struct radeon_device *rdev, bool enable)\r\n{\r\nenum radeon_pm_state_type dpm_state;\r\nif (rdev->asic->dpm.powergate_uvd) {\r\nmutex_lock(&rdev->pm.mutex);\r\nenable |= rdev->pm.dpm.sd > 0;\r\nenable |= rdev->pm.dpm.hd > 0;\r\nradeon_dpm_powergate_uvd(rdev, !enable);\r\nmutex_unlock(&rdev->pm.mutex);\r\n} else {\r\nif (enable) {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.uvd_active = true;\r\n#if 0\r\nif ((rdev->pm.dpm.sd == 1) && (rdev->pm.dpm.hd == 0))\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_SD;\r\nelse if ((rdev->pm.dpm.sd == 2) && (rdev->pm.dpm.hd == 0))\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\r\nelse if ((rdev->pm.dpm.sd == 0) && (rdev->pm.dpm.hd == 1))\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\r\nelse if ((rdev->pm.dpm.sd == 0) && (rdev->pm.dpm.hd == 2))\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD2;\r\nelse\r\n#endif\r\ndpm_state = POWER_STATE_TYPE_INTERNAL_UVD;\r\nrdev->pm.dpm.state = dpm_state;\r\nmutex_unlock(&rdev->pm.mutex);\r\n} else {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.uvd_active = false;\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\n}\r\nvoid radeon_dpm_enable_vce(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable) {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.vce_active = true;\r\nrdev->pm.dpm.vce_level = RADEON_VCE_LEVEL_AC_ALL;\r\nmutex_unlock(&rdev->pm.mutex);\r\n} else {\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.vce_active = false;\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\nstatic void radeon_pm_suspend_old(struct radeon_device *rdev)\r\n{\r\nmutex_lock(&rdev->pm.mutex);\r\nif (rdev->pm.pm_method == PM_METHOD_DYNPM) {\r\nif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE)\r\nrdev->pm.dynpm_state = DYNPM_STATE_SUSPENDED;\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\ncancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\r\n}\r\nstatic void radeon_pm_suspend_dpm(struct radeon_device *rdev)\r\n{\r\nmutex_lock(&rdev->pm.mutex);\r\nradeon_dpm_disable(rdev);\r\nrdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\r\nrdev->pm.dpm_enabled = false;\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\nvoid radeon_pm_suspend(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.pm_method == PM_METHOD_DPM)\r\nradeon_pm_suspend_dpm(rdev);\r\nelse\r\nradeon_pm_suspend_old(rdev);\r\n}\r\nstatic void radeon_pm_resume_old(struct radeon_device *rdev)\r\n{\r\nif ((rdev->family >= CHIP_BARTS) &&\r\n(rdev->family <= CHIP_CAYMAN) &&\r\nrdev->mc_fw) {\r\nif (rdev->pm.default_vddc)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC);\r\nif (rdev->pm.default_vddci)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\r\nSET_VOLTAGE_TYPE_ASIC_VDDCI);\r\nif (rdev->pm.default_sclk)\r\nradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\r\nif (rdev->pm.default_mclk)\r\nradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\r\n}\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\r\nrdev->pm.current_clock_mode_index = 0;\r\nrdev->pm.current_sclk = rdev->pm.default_sclk;\r\nrdev->pm.current_mclk = rdev->pm.default_mclk;\r\nif (rdev->pm.power_state) {\r\nrdev->pm.current_vddc = rdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.voltage;\r\nrdev->pm.current_vddci = rdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.vddci;\r\n}\r\nif (rdev->pm.pm_method == PM_METHOD_DYNPM\r\n&& rdev->pm.dynpm_state == DYNPM_STATE_SUSPENDED) {\r\nrdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\r\nschedule_delayed_work(&rdev->pm.dynpm_idle_work,\r\nmsecs_to_jiffies(RADEON_IDLE_LOOP_MS));\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\nstatic void radeon_pm_resume_dpm(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\r\nradeon_dpm_setup_asic(rdev);\r\nret = radeon_dpm_enable(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\nif (ret)\r\ngoto dpm_resume_fail;\r\nrdev->pm.dpm_enabled = true;\r\nreturn;\r\ndpm_resume_fail:\r\nDRM_ERROR("radeon: dpm resume failed\n");\r\nif ((rdev->family >= CHIP_BARTS) &&\r\n(rdev->family <= CHIP_CAYMAN) &&\r\nrdev->mc_fw) {\r\nif (rdev->pm.default_vddc)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC);\r\nif (rdev->pm.default_vddci)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\r\nSET_VOLTAGE_TYPE_ASIC_VDDCI);\r\nif (rdev->pm.default_sclk)\r\nradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\r\nif (rdev->pm.default_mclk)\r\nradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\r\n}\r\n}\r\nvoid radeon_pm_resume(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.pm_method == PM_METHOD_DPM)\r\nradeon_pm_resume_dpm(rdev);\r\nelse\r\nradeon_pm_resume_old(rdev);\r\n}\r\nstatic int radeon_pm_init_old(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nrdev->pm.profile = PM_PROFILE_DEFAULT;\r\nrdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\r\nrdev->pm.dynpm_can_upclock = true;\r\nrdev->pm.dynpm_can_downclock = true;\r\nrdev->pm.default_sclk = rdev->clock.default_sclk;\r\nrdev->pm.default_mclk = rdev->clock.default_mclk;\r\nrdev->pm.current_sclk = rdev->clock.default_sclk;\r\nrdev->pm.current_mclk = rdev->clock.default_mclk;\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_NONE;\r\nif (rdev->bios) {\r\nif (rdev->is_atom_bios)\r\nradeon_atombios_get_power_modes(rdev);\r\nelse\r\nradeon_combios_get_power_modes(rdev);\r\nradeon_pm_print_states(rdev);\r\nradeon_pm_init_profile(rdev);\r\nif ((rdev->family >= CHIP_BARTS) &&\r\n(rdev->family <= CHIP_CAYMAN) &&\r\nrdev->mc_fw) {\r\nif (rdev->pm.default_vddc)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC);\r\nif (rdev->pm.default_vddci)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\r\nSET_VOLTAGE_TYPE_ASIC_VDDCI);\r\nif (rdev->pm.default_sclk)\r\nradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\r\nif (rdev->pm.default_mclk)\r\nradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\r\n}\r\n}\r\nret = radeon_hwmon_init(rdev);\r\nif (ret)\r\nreturn ret;\r\nINIT_DELAYED_WORK(&rdev->pm.dynpm_idle_work, radeon_dynpm_idle_work_handler);\r\nif (rdev->pm.num_power_states > 1) {\r\nif (radeon_debugfs_pm_init(rdev)) {\r\nDRM_ERROR("Failed to register debugfs file for PM!\n");\r\n}\r\nDRM_INFO("radeon: power management initialized\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_dpm_print_power_states(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nprintk("== power state %d ==\n", i);\r\nradeon_dpm_print_power_state(rdev, &rdev->pm.dpm.ps[i]);\r\n}\r\n}\r\nstatic int radeon_pm_init_dpm(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nrdev->pm.dpm.state = POWER_STATE_TYPE_BALANCED;\r\nrdev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\r\nrdev->pm.dpm.forced_level = RADEON_DPM_FORCED_LEVEL_AUTO;\r\nrdev->pm.default_sclk = rdev->clock.default_sclk;\r\nrdev->pm.default_mclk = rdev->clock.default_mclk;\r\nrdev->pm.current_sclk = rdev->clock.default_sclk;\r\nrdev->pm.current_mclk = rdev->clock.default_mclk;\r\nrdev->pm.int_thermal_type = THERMAL_TYPE_NONE;\r\nif (rdev->bios && rdev->is_atom_bios)\r\nradeon_atombios_get_power_modes(rdev);\r\nelse\r\nreturn -EINVAL;\r\nret = radeon_hwmon_init(rdev);\r\nif (ret)\r\nreturn ret;\r\nINIT_WORK(&rdev->pm.dpm.thermal.work, radeon_dpm_thermal_work_handler);\r\nmutex_lock(&rdev->pm.mutex);\r\nradeon_dpm_init(rdev);\r\nrdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\r\nif (radeon_dpm == 1)\r\nradeon_dpm_print_power_states(rdev);\r\nradeon_dpm_setup_asic(rdev);\r\nret = radeon_dpm_enable(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\nif (ret)\r\ngoto dpm_failed;\r\nrdev->pm.dpm_enabled = true;\r\nif (radeon_debugfs_pm_init(rdev)) {\r\nDRM_ERROR("Failed to register debugfs file for dpm!\n");\r\n}\r\nDRM_INFO("radeon: dpm initialized\n");\r\nreturn 0;\r\ndpm_failed:\r\nrdev->pm.dpm_enabled = false;\r\nif ((rdev->family >= CHIP_BARTS) &&\r\n(rdev->family <= CHIP_CAYMAN) &&\r\nrdev->mc_fw) {\r\nif (rdev->pm.default_vddc)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\r\nSET_VOLTAGE_TYPE_ASIC_VDDC);\r\nif (rdev->pm.default_vddci)\r\nradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\r\nSET_VOLTAGE_TYPE_ASIC_VDDCI);\r\nif (rdev->pm.default_sclk)\r\nradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\r\nif (rdev->pm.default_mclk)\r\nradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\r\n}\r\nDRM_ERROR("radeon: dpm initialization failed\n");\r\nreturn ret;\r\n}\r\nint radeon_pm_init(struct radeon_device *rdev)\r\n{\r\nstruct radeon_dpm_quirk *p = radeon_dpm_quirk_list;\r\nbool disable_dpm = false;\r\nwhile (p && p->chip_device != 0) {\r\nif (rdev->pdev->vendor == p->chip_vendor &&\r\nrdev->pdev->device == p->chip_device &&\r\nrdev->pdev->subsystem_vendor == p->subsys_vendor &&\r\nrdev->pdev->subsystem_device == p->subsys_device) {\r\ndisable_dpm = true;\r\nbreak;\r\n}\r\n++p;\r\n}\r\nswitch (rdev->family) {\r\ncase CHIP_RV610:\r\ncase CHIP_RV630:\r\ncase CHIP_RV620:\r\ncase CHIP_RV635:\r\ncase CHIP_RV670:\r\ncase CHIP_RS780:\r\ncase CHIP_RS880:\r\ncase CHIP_RV770:\r\nif (!rdev->rlc_fw)\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse if ((rdev->family >= CHIP_RV770) &&\r\n(!(rdev->flags & RADEON_IS_IGP)) &&\r\n(!rdev->smc_fw))\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse if (radeon_dpm == 1)\r\nrdev->pm.pm_method = PM_METHOD_DPM;\r\nelse\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nbreak;\r\ncase CHIP_RV730:\r\ncase CHIP_RV710:\r\ncase CHIP_RV740:\r\ncase CHIP_CEDAR:\r\ncase CHIP_REDWOOD:\r\ncase CHIP_JUNIPER:\r\ncase CHIP_CYPRESS:\r\ncase CHIP_HEMLOCK:\r\ncase CHIP_PALM:\r\ncase CHIP_SUMO:\r\ncase CHIP_SUMO2:\r\ncase CHIP_BARTS:\r\ncase CHIP_TURKS:\r\ncase CHIP_CAICOS:\r\ncase CHIP_CAYMAN:\r\ncase CHIP_ARUBA:\r\ncase CHIP_TAHITI:\r\ncase CHIP_PITCAIRN:\r\ncase CHIP_VERDE:\r\ncase CHIP_OLAND:\r\ncase CHIP_HAINAN:\r\ncase CHIP_BONAIRE:\r\ncase CHIP_KABINI:\r\ncase CHIP_KAVERI:\r\ncase CHIP_HAWAII:\r\ncase CHIP_MULLINS:\r\nif (!rdev->rlc_fw)\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse if ((rdev->family >= CHIP_RV770) &&\r\n(!(rdev->flags & RADEON_IS_IGP)) &&\r\n(!rdev->smc_fw))\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse if (disable_dpm && (radeon_dpm == -1))\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse if (radeon_dpm == 0)\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nelse\r\nrdev->pm.pm_method = PM_METHOD_DPM;\r\nbreak;\r\ndefault:\r\nrdev->pm.pm_method = PM_METHOD_PROFILE;\r\nbreak;\r\n}\r\nif (rdev->pm.pm_method == PM_METHOD_DPM)\r\nreturn radeon_pm_init_dpm(rdev);\r\nelse\r\nreturn radeon_pm_init_old(rdev);\r\n}\r\nint radeon_pm_late_init(struct radeon_device *rdev)\r\n{\r\nint ret = 0;\r\nif (rdev->pm.pm_method == PM_METHOD_DPM) {\r\nif (rdev->pm.dpm_enabled) {\r\nif (!rdev->pm.sysfs_initialized) {\r\nret = device_create_file(rdev->dev, &dev_attr_power_dpm_state);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for dpm state\n");\r\nret = device_create_file(rdev->dev, &dev_attr_power_dpm_force_performance_level);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for dpm state\n");\r\nret = device_create_file(rdev->dev, &dev_attr_power_profile);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for power profile\n");\r\nret = device_create_file(rdev->dev, &dev_attr_power_method);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for power method\n");\r\nrdev->pm.sysfs_initialized = true;\r\n}\r\nmutex_lock(&rdev->pm.mutex);\r\nret = radeon_dpm_late_enable(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\nif (ret) {\r\nrdev->pm.dpm_enabled = false;\r\nDRM_ERROR("radeon_pm_late_init failed, disabling dpm\n");\r\n} else {\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\n}\r\n} else {\r\nif ((rdev->pm.num_power_states > 1) &&\r\n(!rdev->pm.sysfs_initialized)) {\r\nret = device_create_file(rdev->dev, &dev_attr_power_profile);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for power profile\n");\r\nret = device_create_file(rdev->dev, &dev_attr_power_method);\r\nif (ret)\r\nDRM_ERROR("failed to create device file for power method\n");\r\nif (!ret)\r\nrdev->pm.sysfs_initialized = true;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void radeon_pm_fini_old(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.num_power_states > 1) {\r\nmutex_lock(&rdev->pm.mutex);\r\nif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\r\nrdev->pm.profile = PM_PROFILE_DEFAULT;\r\nradeon_pm_update_profile(rdev);\r\nradeon_pm_set_clocks(rdev);\r\n} else if (rdev->pm.pm_method == PM_METHOD_DYNPM) {\r\nrdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\r\nradeon_pm_set_clocks(rdev);\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\ncancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_profile);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_method);\r\n}\r\nradeon_hwmon_fini(rdev);\r\nkfree(rdev->pm.power_state);\r\n}\r\nstatic void radeon_pm_fini_dpm(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.num_power_states > 1) {\r\nmutex_lock(&rdev->pm.mutex);\r\nradeon_dpm_disable(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_dpm_state);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_dpm_force_performance_level);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_profile);\r\ndevice_remove_file(rdev->dev, &dev_attr_power_method);\r\n}\r\nradeon_dpm_fini(rdev);\r\nradeon_hwmon_fini(rdev);\r\nkfree(rdev->pm.power_state);\r\n}\r\nvoid radeon_pm_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.pm_method == PM_METHOD_DPM)\r\nradeon_pm_fini_dpm(rdev);\r\nelse\r\nradeon_pm_fini_old(rdev);\r\n}\r\nstatic void radeon_pm_compute_clocks_old(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *ddev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nif (rdev->pm.num_power_states < 2)\r\nreturn;\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.active_crtcs = 0;\r\nrdev->pm.active_crtc_count = 0;\r\nif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc,\r\n&ddev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (radeon_crtc->enabled) {\r\nrdev->pm.active_crtcs |= (1 << radeon_crtc->crtc_id);\r\nrdev->pm.active_crtc_count++;\r\n}\r\n}\r\n}\r\nif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\r\nradeon_pm_update_profile(rdev);\r\nradeon_pm_set_clocks(rdev);\r\n} else if (rdev->pm.pm_method == PM_METHOD_DYNPM) {\r\nif (rdev->pm.dynpm_state != DYNPM_STATE_DISABLED) {\r\nif (rdev->pm.active_crtc_count > 1) {\r\nif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {\r\ncancel_delayed_work(&rdev->pm.dynpm_idle_work);\r\nrdev->pm.dynpm_state = DYNPM_STATE_PAUSED;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\r\nradeon_pm_get_dynpm_state(rdev);\r\nradeon_pm_set_clocks(rdev);\r\nDRM_DEBUG_DRIVER("radeon: dynamic power management deactivated\n");\r\n}\r\n} else if (rdev->pm.active_crtc_count == 1) {\r\nif (rdev->pm.dynpm_state == DYNPM_STATE_MINIMUM) {\r\nrdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_UPCLOCK;\r\nradeon_pm_get_dynpm_state(rdev);\r\nradeon_pm_set_clocks(rdev);\r\nschedule_delayed_work(&rdev->pm.dynpm_idle_work,\r\nmsecs_to_jiffies(RADEON_IDLE_LOOP_MS));\r\n} else if (rdev->pm.dynpm_state == DYNPM_STATE_PAUSED) {\r\nrdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\r\nschedule_delayed_work(&rdev->pm.dynpm_idle_work,\r\nmsecs_to_jiffies(RADEON_IDLE_LOOP_MS));\r\nDRM_DEBUG_DRIVER("radeon: dynamic power management activated\n");\r\n}\r\n} else {\r\nif (rdev->pm.dynpm_state != DYNPM_STATE_MINIMUM) {\r\ncancel_delayed_work(&rdev->pm.dynpm_idle_work);\r\nrdev->pm.dynpm_state = DYNPM_STATE_MINIMUM;\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_MINIMUM;\r\nradeon_pm_get_dynpm_state(rdev);\r\nradeon_pm_set_clocks(rdev);\r\n}\r\n}\r\n}\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\nstatic void radeon_pm_compute_clocks_dpm(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *ddev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nif (!rdev->pm.dpm_enabled)\r\nreturn;\r\nmutex_lock(&rdev->pm.mutex);\r\nrdev->pm.dpm.new_active_crtcs = 0;\r\nrdev->pm.dpm.new_active_crtc_count = 0;\r\nif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc,\r\n&ddev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (crtc->enabled) {\r\nrdev->pm.dpm.new_active_crtcs |= (1 << radeon_crtc->crtc_id);\r\nrdev->pm.dpm.new_active_crtc_count++;\r\n}\r\n}\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\nrdev->pm.dpm.ac_power = true;\r\nelse\r\nrdev->pm.dpm.ac_power = false;\r\nradeon_dpm_change_power_state_locked(rdev);\r\nmutex_unlock(&rdev->pm.mutex);\r\n}\r\nvoid radeon_pm_compute_clocks(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.pm_method == PM_METHOD_DPM)\r\nradeon_pm_compute_clocks_dpm(rdev);\r\nelse\r\nradeon_pm_compute_clocks_old(rdev);\r\n}\r\nstatic bool radeon_pm_in_vbl(struct radeon_device *rdev)\r\n{\r\nint crtc, vpos, hpos, vbl_status;\r\nbool in_vbl = true;\r\nfor (crtc = 0; (crtc < rdev->num_crtc) && in_vbl; crtc++) {\r\nif (rdev->pm.active_crtcs & (1 << crtc)) {\r\nvbl_status = radeon_get_crtc_scanoutpos(rdev->ddev,\r\ncrtc,\r\nUSE_REAL_VBLANKSTART,\r\n&vpos, &hpos, NULL, NULL,\r\n&rdev->mode_info.crtcs[crtc]->base.hwmode);\r\nif ((vbl_status & DRM_SCANOUTPOS_VALID) &&\r\n!(vbl_status & DRM_SCANOUTPOS_IN_VBLANK))\r\nin_vbl = false;\r\n}\r\n}\r\nreturn in_vbl;\r\n}\r\nstatic bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish)\r\n{\r\nu32 stat_crtc = 0;\r\nbool in_vbl = radeon_pm_in_vbl(rdev);\r\nif (in_vbl == false)\r\nDRM_DEBUG_DRIVER("not in vbl for pm change %08x at %s\n", stat_crtc,\r\nfinish ? "exit" : "entry");\r\nreturn in_vbl;\r\n}\r\nstatic void radeon_dynpm_idle_work_handler(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev;\r\nint resched;\r\nrdev = container_of(work, struct radeon_device,\r\npm.dynpm_idle_work.work);\r\nresched = ttm_bo_lock_delayed_workqueue(&rdev->mman.bdev);\r\nmutex_lock(&rdev->pm.mutex);\r\nif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {\r\nint not_processed = 0;\r\nint i;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nstruct radeon_ring *ring = &rdev->ring[i];\r\nif (ring->ready) {\r\nnot_processed += radeon_fence_count_emitted(rdev, i);\r\nif (not_processed >= 3)\r\nbreak;\r\n}\r\n}\r\nif (not_processed >= 3) {\r\nif (rdev->pm.dynpm_planned_action == DYNPM_ACTION_DOWNCLOCK) {\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\r\n} else if (rdev->pm.dynpm_planned_action == DYNPM_ACTION_NONE &&\r\nrdev->pm.dynpm_can_upclock) {\r\nrdev->pm.dynpm_planned_action =\r\nDYNPM_ACTION_UPCLOCK;\r\nrdev->pm.dynpm_action_timeout = jiffies +\r\nmsecs_to_jiffies(RADEON_RECLOCK_DELAY_MS);\r\n}\r\n} else if (not_processed == 0) {\r\nif (rdev->pm.dynpm_planned_action == DYNPM_ACTION_UPCLOCK) {\r\nrdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\r\n} else if (rdev->pm.dynpm_planned_action == DYNPM_ACTION_NONE &&\r\nrdev->pm.dynpm_can_downclock) {\r\nrdev->pm.dynpm_planned_action =\r\nDYNPM_ACTION_DOWNCLOCK;\r\nrdev->pm.dynpm_action_timeout = jiffies +\r\nmsecs_to_jiffies(RADEON_RECLOCK_DELAY_MS);\r\n}\r\n}\r\nif (rdev->pm.dynpm_planned_action != DYNPM_ACTION_NONE &&\r\njiffies > rdev->pm.dynpm_action_timeout) {\r\nradeon_pm_get_dynpm_state(rdev);\r\nradeon_pm_set_clocks(rdev);\r\n}\r\nschedule_delayed_work(&rdev->pm.dynpm_idle_work,\r\nmsecs_to_jiffies(RADEON_IDLE_LOOP_MS));\r\n}\r\nmutex_unlock(&rdev->pm.mutex);\r\nttm_bo_unlock_delayed_workqueue(&rdev->mman.bdev, resched);\r\n}\r\nstatic int radeon_debugfs_pm_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_device *ddev = rdev->ddev;\r\nif ((rdev->flags & RADEON_IS_PX) &&\r\n(ddev->switch_power_state != DRM_SWITCH_POWER_ON)) {\r\nseq_printf(m, "PX asic powered off\n");\r\n} else if (rdev->pm.dpm_enabled) {\r\nmutex_lock(&rdev->pm.mutex);\r\nif (rdev->asic->dpm.debugfs_print_current_performance_level)\r\nradeon_dpm_debugfs_print_current_performance_level(rdev, m);\r\nelse\r\nseq_printf(m, "Debugfs support not implemented for this asic\n");\r\nmutex_unlock(&rdev->pm.mutex);\r\n} else {\r\nseq_printf(m, "default engine clock: %u0 kHz\n", rdev->pm.default_sclk);\r\nif ((rdev->family >= CHIP_PALM) && (rdev->flags & RADEON_IS_IGP))\r\nseq_printf(m, "current engine clock: %u0 kHz\n", rdev->pm.current_sclk);\r\nelse\r\nseq_printf(m, "current engine clock: %u0 kHz\n", radeon_get_engine_clock(rdev));\r\nseq_printf(m, "default memory clock: %u0 kHz\n", rdev->pm.default_mclk);\r\nif (rdev->asic->pm.get_memory_clock)\r\nseq_printf(m, "current memory clock: %u0 kHz\n", radeon_get_memory_clock(rdev));\r\nif (rdev->pm.current_vddc)\r\nseq_printf(m, "voltage: %u mV\n", rdev->pm.current_vddc);\r\nif (rdev->asic->pm.get_pcie_lanes)\r\nseq_printf(m, "PCIE lanes: %d\n", radeon_get_pcie_lanes(rdev));\r\n}\r\nreturn 0;\r\n}\r\nstatic int radeon_debugfs_pm_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, radeon_pm_info_list, ARRAY_SIZE(radeon_pm_info_list));\r\n#else\r\nreturn 0;\r\n#endif\r\n}
