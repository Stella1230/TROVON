static int nsp_get_groups_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_groups;\r\n}\r\nstatic const char *nsp_get_group_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->groups[selector].name;\r\n}\r\nstatic int nsp_get_group_pins(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector, const unsigned int **pins,\r\nunsigned int *num_pins)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*pins = pinctrl->groups[selector].pins;\r\n*num_pins = pinctrl->groups[selector].num_pins;\r\nreturn 0;\r\n}\r\nstatic void nsp_pin_dbg_show(struct pinctrl_dev *pctrl_dev,\r\nstruct seq_file *s, unsigned int offset)\r\n{\r\nseq_printf(s, " %s", dev_name(pctrl_dev->dev));\r\n}\r\nstatic int nsp_get_functions_count(struct pinctrl_dev *pctrl_dev)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->num_functions;\r\n}\r\nstatic const char *nsp_get_function_name(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nreturn pinctrl->functions[selector].name;\r\n}\r\nstatic int nsp_get_function_groups(struct pinctrl_dev *pctrl_dev,\r\nunsigned int selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\n*groups = pinctrl->functions[selector].groups;\r\n*num_groups = pinctrl->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int nsp_pinmux_set(struct nsp_pinctrl *pinctrl,\r\nconst struct nsp_pin_function *func,\r\nconst struct nsp_pin_group *grp,\r\nstruct nsp_mux_log *mux_log)\r\n{\r\nconst struct nsp_mux *mux = &grp->mux;\r\nint i;\r\nu32 val, mask;\r\nunsigned long flags;\r\nvoid __iomem *base_address;\r\nfor (i = 0; i < pinctrl->num_groups; i++) {\r\nif ((mux->shift != mux_log[i].mux.shift) ||\r\n(mux->base != mux_log[i].mux.base))\r\ncontinue;\r\nif (!mux_log[i].is_configured)\r\nbreak;\r\nif (mux_log[i].mux.alt != mux->alt) {\r\ndev_err(pinctrl->dev,\r\n"double configuration error detected!\n");\r\ndev_err(pinctrl->dev, "func:%s grp:%s\n",\r\nfunc->name, grp->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (i == pinctrl->num_groups)\r\nreturn -EINVAL;\r\nmask = mux->mask;\r\nmux_log[i].mux.alt = mux->alt;\r\nmux_log[i].is_configured = true;\r\nswitch (mux->base) {\r\ncase NSP_MUX_BASE0:\r\nbase_address = pinctrl->base0;\r\nbreak;\r\ncase NSP_MUX_BASE1:\r\nbase_address = pinctrl->base1;\r\nbreak;\r\ncase NSP_MUX_BASE2:\r\nbase_address = pinctrl->base2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(base_address);\r\nval &= ~(mask << grp->mux.shift);\r\nval |= grp->mux.alt << grp->mux.shift;\r\nwritel(val, base_address);\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int nsp_pinmux_enable(struct pinctrl_dev *pctrl_dev,\r\nunsigned int func_select, unsigned int grp_select)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nconst struct nsp_pin_function *func;\r\nconst struct nsp_pin_group *grp;\r\nif (grp_select > pinctrl->num_groups ||\r\nfunc_select > pinctrl->num_functions)\r\nreturn -EINVAL;\r\nfunc = &pinctrl->functions[func_select];\r\ngrp = &pinctrl->groups[grp_select];\r\ndev_dbg(pctrl_dev->dev, "func:%u name:%s grp:%u name:%s\n",\r\nfunc_select, func->name, grp_select, grp->name);\r\ndev_dbg(pctrl_dev->dev, "shift:%u alt:%u\n", grp->mux.shift,\r\ngrp->mux.alt);\r\nreturn nsp_pinmux_set(pinctrl, func, grp, pinctrl->mux_log);\r\n}\r\nstatic int nsp_gpio_request_enable(struct pinctrl_dev *pctrl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nu32 *gpio_select = pctrl_dev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->base0);\r\nif ((val & BIT(pin)) != (*gpio_select << pin)) {\r\nval &= ~BIT(pin);\r\nval |= *gpio_select << pin;\r\nwritel(val, pinctrl->base0);\r\n}\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void nsp_gpio_disable_free(struct pinctrl_dev *pctrl_dev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\r\nu32 *gpio_select = pctrl_dev->desc->pins[pin].drv_data;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pinctrl->lock, flags);\r\nval = readl(pinctrl->base0);\r\nif ((val & (1 << pin)) == (*gpio_select << pin)) {\r\nval &= ~(1 << pin);\r\nif (!(*gpio_select))\r\nval |= (1 << pin);\r\nwritel(val, pinctrl->base0);\r\n}\r\nspin_unlock_irqrestore(&pinctrl->lock, flags);\r\n}\r\nstatic int nsp_mux_log_init(struct nsp_pinctrl *pinctrl)\r\n{\r\nstruct nsp_mux_log *log;\r\nunsigned int i;\r\nu32 no_of_groups = ARRAY_SIZE(nsp_pin_groups);\r\npinctrl->mux_log = devm_kcalloc(pinctrl->dev, no_of_groups,\r\nsizeof(struct nsp_mux_log),\r\nGFP_KERNEL);\r\nif (!pinctrl->mux_log)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < no_of_groups; i++) {\r\nlog = &pinctrl->mux_log[i];\r\nlog->mux.base = nsp_pin_groups[i].mux.base;\r\nlog->mux.shift = nsp_pin_groups[i].mux.shift;\r\nlog->mux.alt = 0;\r\nlog->is_configured = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nsp_pinmux_probe(struct platform_device *pdev)\r\n{\r\nstruct nsp_pinctrl *pinctrl;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct pinctrl_pin_desc *pins;\r\nunsigned int num_pins = ARRAY_SIZE(nsp_pins);\r\npinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\r\nif (!pinctrl)\r\nreturn -ENOMEM;\r\npinctrl->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pinctrl);\r\nspin_lock_init(&pinctrl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npinctrl->base0 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->base0))\r\nreturn PTR_ERR(pinctrl->base0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npinctrl->base1 = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!pinctrl->base1) {\r\ndev_err(&pdev->dev, "unable to map I/O space\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\npinctrl->base2 = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pinctrl->base2))\r\nreturn PTR_ERR(pinctrl->base2);\r\nret = nsp_mux_log_init(pinctrl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to initialize IOMUX log\n");\r\nreturn ret;\r\n}\r\npins = devm_kcalloc(&pdev->dev, num_pins, sizeof(*pins), GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pins; i++) {\r\npins[i].number = nsp_pins[i].pin;\r\npins[i].name = nsp_pins[i].name;\r\npins[i].drv_data = &nsp_pins[i].gpio_select;\r\n}\r\npinctrl->groups = nsp_pin_groups;\r\npinctrl->num_groups = ARRAY_SIZE(nsp_pin_groups);\r\npinctrl->functions = nsp_pin_functions;\r\npinctrl->num_functions = ARRAY_SIZE(nsp_pin_functions);\r\nnsp_pinctrl_desc.pins = pins;\r\nnsp_pinctrl_desc.npins = num_pins;\r\npinctrl->pctl = devm_pinctrl_register(&pdev->dev, &nsp_pinctrl_desc,\r\npinctrl);\r\nif (IS_ERR(pinctrl->pctl)) {\r\ndev_err(&pdev->dev, "unable to register nsp IOMUX pinctrl\n");\r\nreturn PTR_ERR(pinctrl->pctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nsp_pinmux_init(void)\r\n{\r\nreturn platform_driver_register(&nsp_pinmux_driver);\r\n}
