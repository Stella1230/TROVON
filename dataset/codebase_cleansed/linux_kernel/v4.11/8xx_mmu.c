phys_addr_t v_block_mapped(unsigned long va)\r\n{\r\nunsigned long p = PHYS_IMMR_BASE;\r\nif (__map_without_ltlbs)\r\nreturn 0;\r\nif (va >= VIRT_IMMR_BASE && va < VIRT_IMMR_BASE + IMMR_SIZE)\r\nreturn p + va - VIRT_IMMR_BASE;\r\nreturn 0;\r\n}\r\nunsigned long p_block_mapped(phys_addr_t pa)\r\n{\r\nunsigned long p = PHYS_IMMR_BASE;\r\nif (__map_without_ltlbs)\r\nreturn 0;\r\nif (pa >= p && pa < p + IMMR_SIZE)\r\nreturn VIRT_IMMR_BASE + pa - p;\r\nreturn 0;\r\n}\r\nvoid __init MMU_init_hw(void)\r\n{\r\n#ifdef CONFIG_PIN_TLB\r\nunsigned long ctr = mfspr(SPRN_MD_CTR) & 0xfe000000;\r\nunsigned long flags = 0xf0 | MD_SPS16K | _PAGE_SHARED | _PAGE_DIRTY;\r\n#ifdef CONFIG_PIN_TLB_IMMR\r\nint i = 29;\r\n#else\r\nint i = 28;\r\n#endif\r\nunsigned long addr = 0;\r\nunsigned long mem = total_lowmem;\r\nfor (; i < 32 && mem >= LARGE_PAGE_SIZE_8M; i++) {\r\nmtspr(SPRN_MD_CTR, ctr | (i << 8));\r\nmtspr(SPRN_MD_EPN, (unsigned long)__va(addr) | MD_EVALID);\r\nmtspr(SPRN_MD_TWC, MD_PS8MEG | MD_SVALID);\r\nmtspr(SPRN_MD_RPN, addr | flags | _PAGE_PRESENT);\r\naddr += LARGE_PAGE_SIZE_8M;\r\nmem -= LARGE_PAGE_SIZE_8M;\r\n}\r\n#endif\r\n}\r\nstatic void mmu_mapin_immr(void)\r\n{\r\nunsigned long p = PHYS_IMMR_BASE;\r\nunsigned long v = VIRT_IMMR_BASE;\r\nunsigned long f = pgprot_val(PAGE_KERNEL_NCG);\r\nint offset;\r\nfor (offset = 0; offset < IMMR_SIZE; offset += PAGE_SIZE)\r\nmap_page(v + offset, p + offset, f);\r\n}\r\nvoid mmu_patch_cmp_limit(unsigned int *addr, unsigned long mapped)\r\n{\r\nunsigned int instr = *addr;\r\ninstr &= 0xffff0000;\r\ninstr |= (unsigned long)__va(mapped) >> 16;\r\npatch_instruction(addr, instr);\r\n}\r\nunsigned long __init mmu_mapin_ram(unsigned long top)\r\n{\r\nunsigned long mapped;\r\nif (__map_without_ltlbs) {\r\nmapped = 0;\r\nmmu_mapin_immr();\r\n#ifndef CONFIG_PIN_TLB_IMMR\r\npatch_instruction(&DTLBMiss_jmp, PPC_INST_NOP);\r\n#endif\r\n} else {\r\nmapped = top & ~(LARGE_PAGE_SIZE_8M - 1);\r\n}\r\nmmu_patch_cmp_limit(&DTLBMiss_cmp, mapped);\r\nmmu_patch_cmp_limit(&FixupDAR_cmp, mapped);\r\nif (mapped)\r\nmemblock_set_current_limit(mapped);\r\nreturn mapped;\r\n}\r\nvoid setup_initial_memory_limit(phys_addr_t first_memblock_base,\r\nphys_addr_t first_memblock_size)\r\n{\r\nBUG_ON(first_memblock_base != 0);\r\nmemblock_set_current_limit(min_t(u64, first_memblock_size, 0x01800000));\r\n}\r\nvoid set_context(unsigned long id, pgd_t *pgd)\r\n{\r\ns16 offset = (s16)(__pa(swapper_pg_dir));\r\n#ifdef CONFIG_BDI_SWITCH\r\npgd_t **ptr = *(pgd_t ***)(KERNELBASE + 0xf0);\r\n*(ptr + 1) = pgd;\r\n#endif\r\nmtspr(SPRN_M_TW, __pa(pgd) - offset);\r\nmtspr(SPRN_M_CASID, id);\r\nmb();\r\n}\r\nvoid flush_instruction_cache(void)\r\n{\r\nisync();\r\nmtspr(SPRN_IC_CST, IDC_INVALL);\r\nisync();\r\n}
