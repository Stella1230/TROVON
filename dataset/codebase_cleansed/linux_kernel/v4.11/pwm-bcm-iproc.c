static inline struct iproc_pwmc *to_iproc_pwmc(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct iproc_pwmc, chip);\r\n}\r\nstatic void iproc_pwmc_enable(struct iproc_pwmc *ip, unsigned int channel)\r\n{\r\nu32 value;\r\nvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\r\nvalue |= 1 << IPROC_PWM_CTRL_EN_SHIFT(channel);\r\nwritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\r\nndelay(400);\r\n}\r\nstatic void iproc_pwmc_disable(struct iproc_pwmc *ip, unsigned int channel)\r\n{\r\nu32 value;\r\nvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\r\nvalue &= ~(1 << IPROC_PWM_CTRL_EN_SHIFT(channel));\r\nwritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\r\nndelay(400);\r\n}\r\nstatic void iproc_pwmc_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct iproc_pwmc *ip = to_iproc_pwmc(chip);\r\nu64 tmp, multi, rate;\r\nu32 value, prescale;\r\nrate = clk_get_rate(ip->clk);\r\nvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\r\nif (value & BIT(IPROC_PWM_CTRL_EN_SHIFT(pwm->hwpwm)))\r\nstate->enabled = true;\r\nelse\r\nstate->enabled = false;\r\nif (value & BIT(IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm)))\r\nstate->polarity = PWM_POLARITY_NORMAL;\r\nelse\r\nstate->polarity = PWM_POLARITY_INVERSED;\r\nvalue = readl(ip->base + IPROC_PWM_PRESCALE_OFFSET);\r\nprescale = value >> IPROC_PWM_PRESCALE_SHIFT(pwm->hwpwm);\r\nprescale &= IPROC_PWM_PRESCALE_MAX;\r\nmulti = NSEC_PER_SEC * (prescale + 1);\r\nvalue = readl(ip->base + IPROC_PWM_PERIOD_OFFSET(pwm->hwpwm));\r\ntmp = (value & IPROC_PWM_PERIOD_MAX) * multi;\r\nstate->period = div64_u64(tmp, rate);\r\nvalue = readl(ip->base + IPROC_PWM_DUTY_CYCLE_OFFSET(pwm->hwpwm));\r\ntmp = (value & IPROC_PWM_PERIOD_MAX) * multi;\r\nstate->duty_cycle = div64_u64(tmp, rate);\r\n}\r\nstatic int iproc_pwmc_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nunsigned long prescale = IPROC_PWM_PRESCALE_MIN;\r\nstruct iproc_pwmc *ip = to_iproc_pwmc(chip);\r\nu32 value, period, duty;\r\nu64 rate;\r\nrate = clk_get_rate(ip->clk);\r\nwhile (1) {\r\nu64 value, div;\r\ndiv = NSEC_PER_SEC * (prescale + 1);\r\nvalue = rate * state->period;\r\nperiod = div64_u64(value, div);\r\nvalue = rate * state->duty_cycle;\r\nduty = div64_u64(value, div);\r\nif (period < IPROC_PWM_PERIOD_MIN ||\r\nduty < IPROC_PWM_DUTY_CYCLE_MIN)\r\nreturn -EINVAL;\r\nif (period <= IPROC_PWM_PERIOD_MAX &&\r\nduty <= IPROC_PWM_DUTY_CYCLE_MAX)\r\nbreak;\r\nif (++prescale > IPROC_PWM_PRESCALE_MAX)\r\nreturn -EINVAL;\r\n}\r\niproc_pwmc_disable(ip, pwm->hwpwm);\r\nvalue = readl(ip->base + IPROC_PWM_PRESCALE_OFFSET);\r\nvalue &= ~IPROC_PWM_PRESCALE_MASK(pwm->hwpwm);\r\nvalue |= prescale << IPROC_PWM_PRESCALE_SHIFT(pwm->hwpwm);\r\nwritel(value, ip->base + IPROC_PWM_PRESCALE_OFFSET);\r\nwritel(period, ip->base + IPROC_PWM_PERIOD_OFFSET(pwm->hwpwm));\r\nwritel(duty, ip->base + IPROC_PWM_DUTY_CYCLE_OFFSET(pwm->hwpwm));\r\nvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\r\nif (state->polarity == PWM_POLARITY_NORMAL)\r\nvalue |= 1 << IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm);\r\nelse\r\nvalue &= ~(1 << IPROC_PWM_CTRL_POLARITY_SHIFT(pwm->hwpwm));\r\nwritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\r\nif (state->enabled)\r\niproc_pwmc_enable(ip, pwm->hwpwm);\r\nreturn 0;\r\n}\r\nstatic int iproc_pwmc_probe(struct platform_device *pdev)\r\n{\r\nstruct iproc_pwmc *ip;\r\nstruct resource *res;\r\nunsigned int i;\r\nu32 value;\r\nint ret;\r\nip = devm_kzalloc(&pdev->dev, sizeof(*ip), GFP_KERNEL);\r\nif (!ip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ip);\r\nip->chip.dev = &pdev->dev;\r\nip->chip.ops = &iproc_pwm_ops;\r\nip->chip.base = -1;\r\nip->chip.npwm = 4;\r\nip->chip.of_xlate = of_pwm_xlate_with_flags;\r\nip->chip.of_pwm_n_cells = 3;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ip->base))\r\nreturn PTR_ERR(ip->base);\r\nip->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ip->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock: %ld\n",\r\nPTR_ERR(ip->clk));\r\nreturn PTR_ERR(ip->clk);\r\n}\r\nret = clk_prepare_enable(ip->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nvalue = readl(ip->base + IPROC_PWM_CTRL_OFFSET);\r\nfor (i = 0; i < ip->chip.npwm; i++) {\r\nvalue &= ~(1 << IPROC_PWM_CTRL_TYPE_SHIFT(i));\r\nvalue |= 1 << IPROC_PWM_CTRL_POLARITY_SHIFT(i);\r\n}\r\nwritel(value, ip->base + IPROC_PWM_CTRL_OFFSET);\r\nret = pwmchip_add(&ip->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nclk_disable_unprepare(ip->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int iproc_pwmc_remove(struct platform_device *pdev)\r\n{\r\nstruct iproc_pwmc *ip = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(ip->clk);\r\nreturn pwmchip_remove(&ip->chip);\r\n}
