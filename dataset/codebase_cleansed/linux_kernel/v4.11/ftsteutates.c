static int fts_read_byte(struct i2c_client *client, unsigned short reg)\r\n{\r\nint ret;\r\nunsigned char page = reg >> 8;\r\nstruct fts_data *data = dev_get_drvdata(&client->dev);\r\nmutex_lock(&data->access_lock);\r\ndev_dbg(&client->dev, "page select - page: 0x%.02x\n", page);\r\nret = i2c_smbus_write_byte_data(client, FTS_PAGE_SELECT_REG, page);\r\nif (ret < 0)\r\ngoto error;\r\nreg &= 0xFF;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\ndev_dbg(&client->dev, "read - reg: 0x%.02x: val: 0x%.02x\n", reg, ret);\r\nerror:\r\nmutex_unlock(&data->access_lock);\r\nreturn ret;\r\n}\r\nstatic int fts_write_byte(struct i2c_client *client, unsigned short reg,\r\nunsigned char value)\r\n{\r\nint ret;\r\nunsigned char page = reg >> 8;\r\nstruct fts_data *data = dev_get_drvdata(&client->dev);\r\nmutex_lock(&data->access_lock);\r\ndev_dbg(&client->dev, "page select - page: 0x%.02x\n", page);\r\nret = i2c_smbus_write_byte_data(client, FTS_PAGE_SELECT_REG, page);\r\nif (ret < 0)\r\ngoto error;\r\nreg &= 0xFF;\r\ndev_dbg(&client->dev,\r\n"write - reg: 0x%.02x: val: 0x%.02x\n", reg, value);\r\nret = i2c_smbus_write_byte_data(client, reg, value);\r\nerror:\r\nmutex_unlock(&data->access_lock);\r\nreturn ret;\r\n}\r\nstatic int fts_update_device(struct fts_data *data)\r\n{\r\nint i;\r\nint err = 0;\r\nmutex_lock(&data->update_lock);\r\nif (!time_after(jiffies, data->last_updated + 2 * HZ) && data->valid)\r\ngoto exit;\r\nerr = fts_read_byte(data->client, FTS_DEVICE_STATUS_REG);\r\nif (err < 0)\r\ngoto exit;\r\ndata->valid = !!(err & 0x02);\r\nif (unlikely(!data->valid)) {\r\nerr = -EAGAIN;\r\ngoto exit;\r\n}\r\nerr = fts_read_byte(data->client, FTS_FAN_PRESENT_REG);\r\nif (err < 0)\r\ngoto exit;\r\ndata->fan_present = err;\r\nerr = fts_read_byte(data->client, FTS_FAN_EVENT_REG);\r\nif (err < 0)\r\ngoto exit;\r\ndata->fan_alarm = err;\r\nfor (i = 0; i < FTS_NO_FAN_SENSORS; i++) {\r\nif (data->fan_present & BIT(i)) {\r\nerr = fts_read_byte(data->client, FTS_REG_FAN_INPUT(i));\r\nif (err < 0)\r\ngoto exit;\r\ndata->fan_input[i] = err;\r\nerr = fts_read_byte(data->client,\r\nFTS_REG_FAN_SOURCE(i));\r\nif (err < 0)\r\ngoto exit;\r\ndata->fan_source[i] = err;\r\n} else {\r\ndata->fan_input[i] = 0;\r\ndata->fan_source[i] = 0;\r\n}\r\n}\r\nerr = fts_read_byte(data->client, FTS_SENSOR_EVENT_REG);\r\nif (err < 0)\r\ngoto exit;\r\ndata->temp_alarm = err;\r\nfor (i = 0; i < FTS_NO_TEMP_SENSORS; i++) {\r\nerr = fts_read_byte(data->client, FTS_REG_TEMP_INPUT(i));\r\nif (err < 0)\r\ngoto exit;\r\ndata->temp_input[i] = err;\r\n}\r\nfor (i = 0; i < FTS_NO_VOLT_SENSORS; i++) {\r\nerr = fts_read_byte(data->client, FTS_REG_VOLT(i));\r\nif (err < 0)\r\ngoto exit;\r\ndata->volt[i] = err;\r\n}\r\ndata->last_updated = jiffies;\r\nerr = 0;\r\nexit:\r\nmutex_unlock(&data->update_lock);\r\nreturn err;\r\n}\r\nstatic int fts_wd_set_resolution(struct fts_data *data,\r\nenum WATCHDOG_RESOLUTION resolution)\r\n{\r\nint ret;\r\nif (data->resolution == resolution)\r\nreturn 0;\r\nret = fts_read_byte(data->client, FTS_WATCHDOG_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((resolution == seconds && ret & BIT(1)) ||\r\n(resolution == minutes && (ret & BIT(1)) == 0)) {\r\ndata->resolution = resolution;\r\nreturn 0;\r\n}\r\nif (resolution == seconds)\r\nret |= BIT(1);\r\nelse\r\nret &= ~BIT(1);\r\nret = fts_write_byte(data->client, FTS_WATCHDOG_CONTROL, ret);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->resolution = resolution;\r\nreturn ret;\r\n}\r\nstatic int fts_wd_set_timeout(struct watchdog_device *wdd, unsigned int timeout)\r\n{\r\nstruct fts_data *data;\r\nenum WATCHDOG_RESOLUTION resolution = seconds;\r\nint ret;\r\ndata = watchdog_get_drvdata(wdd);\r\nif (timeout > 0xFF) {\r\ntimeout = DIV_ROUND_UP(timeout, 60) * 60;\r\nresolution = minutes;\r\n}\r\nret = fts_wd_set_resolution(data, resolution);\r\nif (ret < 0)\r\nreturn ret;\r\nwdd->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic int fts_wd_start(struct watchdog_device *wdd)\r\n{\r\nstruct fts_data *data = watchdog_get_drvdata(wdd);\r\nreturn fts_write_byte(data->client, FTS_WATCHDOG_TIME_PRESET,\r\nwdd->timeout / (u8)data->resolution);\r\n}\r\nstatic int fts_wd_stop(struct watchdog_device *wdd)\r\n{\r\nstruct fts_data *data;\r\ndata = watchdog_get_drvdata(wdd);\r\nreturn fts_write_byte(data->client, FTS_WATCHDOG_TIME_PRESET, 0);\r\n}\r\nstatic int fts_watchdog_init(struct fts_data *data)\r\n{\r\nint timeout, ret;\r\nwatchdog_set_drvdata(&data->wdd, data);\r\ntimeout = fts_read_byte(data->client, FTS_WATCHDOG_TIME_PRESET);\r\nif (timeout < 0)\r\nreturn timeout;\r\nif (timeout == 0) {\r\nret = fts_wd_set_resolution(data, seconds);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->wdd.timeout = 60;\r\n} else {\r\nret = fts_read_byte(data->client, FTS_WATCHDOG_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->resolution = ret & BIT(1) ? seconds : minutes;\r\ndata->wdd.timeout = timeout * (u8)data->resolution;\r\nset_bit(WDOG_HW_RUNNING, &data->wdd.status);\r\n}\r\ndata->wdd.info = &fts_wd_info;\r\ndata->wdd.ops = &fts_wd_ops;\r\ndata->wdd.parent = &data->client->dev;\r\ndata->wdd.min_timeout = 1;\r\ndata->wdd.max_hw_heartbeat_ms = 0xFF * 60 * MSEC_PER_SEC;\r\nreturn watchdog_register_device(&data->wdd);\r\n}\r\nstatic ssize_t show_in_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", data->volt[index]);\r\n}\r\nstatic ssize_t show_temp_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", data->temp_input[index]);\r\n}\r\nstatic ssize_t show_temp_fault(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", data->temp_input[index] == 0);\r\n}\r\nstatic ssize_t show_temp_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", !!(data->temp_alarm & BIT(index)));\r\n}\r\nstatic ssize_t\r\nclear_temp_alarm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nlong ret;\r\nret = fts_update_device(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (kstrtoul(buf, 10, &ret) || ret != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = fts_read_byte(data->client, FTS_REG_TEMP_CONTROL(index));\r\nif (ret < 0)\r\ngoto error;\r\nret = fts_write_byte(data->client, FTS_REG_TEMP_CONTROL(index),\r\nret | 0x1);\r\nif (ret < 0)\r\ngoto error;\r\ndata->valid = false;\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_fan_value(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", data->fan_input[index]);\r\n}\r\nstatic ssize_t show_fan_source(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", data->fan_source[index]);\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nint err;\r\nerr = fts_update_device(data);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", !!(data->fan_alarm & BIT(index)));\r\n}\r\nstatic ssize_t\r\nclear_fan_alarm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(dev);\r\nint index = to_sensor_dev_attr(devattr)->index;\r\nlong ret;\r\nret = fts_update_device(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (kstrtoul(buf, 10, &ret) || ret != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = fts_read_byte(data->client, FTS_REG_FAN_CONTROL(index));\r\nif (ret < 0)\r\ngoto error;\r\nret = fts_write_byte(data->client, FTS_REG_FAN_CONTROL(index),\r\nret | 0x1);\r\nif (ret < 0)\r\ngoto error;\r\ndata->valid = false;\r\nerror:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int fts_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint val;\r\nval = i2c_smbus_read_byte_data(client, FTS_DEVICE_REVISION_REG);\r\nif (val < 0x2b)\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_1);\r\nif (val != 0x17)\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_2);\r\nif (val != 0x34)\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, FTS_DEVICE_DETECT_REG_3);\r\nif (val != 0x54)\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, FTS_DEVICE_ID_REG);\r\nif (val != 0x11)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, fts_id[0].name, I2C_NAME_SIZE);\r\ninfo->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int fts_remove(struct i2c_client *client)\r\n{\r\nstruct fts_data *data = dev_get_drvdata(&client->dev);\r\nwatchdog_unregister_device(&data->wdd);\r\nreturn 0;\r\n}\r\nstatic int fts_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nu8 revision;\r\nstruct fts_data *data;\r\nint err;\r\ns8 deviceid;\r\nstruct device *hwmon_dev;\r\nif (client->addr != 0x73)\r\nreturn -ENODEV;\r\ndeviceid = i2c_smbus_read_byte_data(client, FTS_DEVICE_ID_REG);\r\nif (deviceid > 0 && (deviceid & 0xF0) == 0x10) {\r\nswitch (deviceid & 0x0F) {\r\ncase 0x01:\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev,\r\n"No Baseboard Management Controller\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\ndev_dbg(&client->dev, "No fujitsu board\n");\r\nreturn -ENODEV;\r\n}\r\ndata = devm_kzalloc(&client->dev, sizeof(struct fts_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->update_lock);\r\nmutex_init(&data->access_lock);\r\ndata->client = client;\r\ndev_set_drvdata(&client->dev, data);\r\nerr = i2c_smbus_read_byte_data(client, FTS_DEVICE_REVISION_REG);\r\nif (err < 0)\r\nreturn err;\r\nrevision = err;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,\r\n"ftsteutates",\r\ndata,\r\nfts_attr_groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\nerr = fts_watchdog_init(data);\r\nif (err)\r\nreturn err;\r\ndev_info(&client->dev, "Detected FTS Teutates chip, revision: %d.%d\n",\r\n(revision & 0xF0) >> 4, revision & 0x0F);\r\nreturn 0;\r\n}
