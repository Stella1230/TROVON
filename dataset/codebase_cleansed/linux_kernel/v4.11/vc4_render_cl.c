static inline void rcl_u8(struct vc4_rcl_setup *setup, u8 val)\r\n{\r\n*(u8 *)(setup->rcl->vaddr + setup->next_offset) = val;\r\nsetup->next_offset += 1;\r\n}\r\nstatic inline void rcl_u16(struct vc4_rcl_setup *setup, u16 val)\r\n{\r\n*(u16 *)(setup->rcl->vaddr + setup->next_offset) = val;\r\nsetup->next_offset += 2;\r\n}\r\nstatic inline void rcl_u32(struct vc4_rcl_setup *setup, u32 val)\r\n{\r\n*(u32 *)(setup->rcl->vaddr + setup->next_offset) = val;\r\nsetup->next_offset += 4;\r\n}\r\nstatic void vc4_store_before_load(struct vc4_rcl_setup *setup)\r\n{\r\nrcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\r\nrcl_u16(setup,\r\nVC4_SET_FIELD(VC4_LOADSTORE_TILE_BUFFER_NONE,\r\nVC4_LOADSTORE_TILE_BUFFER_BUFFER) |\r\nVC4_STORE_TILE_BUFFER_DISABLE_COLOR_CLEAR |\r\nVC4_STORE_TILE_BUFFER_DISABLE_ZS_CLEAR |\r\nVC4_STORE_TILE_BUFFER_DISABLE_VG_MASK_CLEAR);\r\nrcl_u32(setup, 0);\r\n}\r\nstatic uint32_t vc4_full_res_offset(struct vc4_exec_info *exec,\r\nstruct drm_gem_cma_object *bo,\r\nstruct drm_vc4_submit_rcl_surface *surf,\r\nuint8_t x, uint8_t y)\r\n{\r\nreturn bo->paddr + surf->offset + VC4_TILE_BUFFER_SIZE *\r\n(DIV_ROUND_UP(exec->args->width, 32) * y + x);\r\n}\r\nstatic void vc4_tile_coordinates(struct vc4_rcl_setup *setup,\r\nuint32_t x, uint32_t y)\r\n{\r\nrcl_u8(setup, VC4_PACKET_TILE_COORDINATES);\r\nrcl_u8(setup, x);\r\nrcl_u8(setup, y);\r\n}\r\nstatic void emit_tile(struct vc4_exec_info *exec,\r\nstruct vc4_rcl_setup *setup,\r\nuint8_t x, uint8_t y, bool first, bool last)\r\n{\r\nstruct drm_vc4_submit_cl *args = exec->args;\r\nbool has_bin = args->bin_cl_size != 0;\r\nif (setup->color_read) {\r\nif (args->color_read.flags &\r\nVC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nrcl_u8(setup, VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER);\r\nrcl_u32(setup,\r\nvc4_full_res_offset(exec, setup->color_read,\r\n&args->color_read, x, y) |\r\nVC4_LOADSTORE_FULL_RES_DISABLE_ZS);\r\n} else {\r\nrcl_u8(setup, VC4_PACKET_LOAD_TILE_BUFFER_GENERAL);\r\nrcl_u16(setup, args->color_read.bits);\r\nrcl_u32(setup, setup->color_read->paddr +\r\nargs->color_read.offset);\r\n}\r\n}\r\nif (setup->zs_read) {\r\nif (args->zs_read.flags &\r\nVC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nrcl_u8(setup, VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER);\r\nrcl_u32(setup,\r\nvc4_full_res_offset(exec, setup->zs_read,\r\n&args->zs_read, x, y) |\r\nVC4_LOADSTORE_FULL_RES_DISABLE_COLOR);\r\n} else {\r\nif (setup->color_read) {\r\nvc4_tile_coordinates(setup, x, y);\r\nvc4_store_before_load(setup);\r\n}\r\nrcl_u8(setup, VC4_PACKET_LOAD_TILE_BUFFER_GENERAL);\r\nrcl_u16(setup, args->zs_read.bits);\r\nrcl_u32(setup, setup->zs_read->paddr +\r\nargs->zs_read.offset);\r\n}\r\n}\r\nvc4_tile_coordinates(setup, x, y);\r\nif (first && has_bin)\r\nrcl_u8(setup, VC4_PACKET_WAIT_ON_SEMAPHORE);\r\nif (has_bin) {\r\nrcl_u8(setup, VC4_PACKET_BRANCH_TO_SUB_LIST);\r\nrcl_u32(setup, (exec->tile_bo->paddr +\r\nexec->tile_alloc_offset +\r\n(y * exec->bin_tiles_x + x) * 32));\r\n}\r\nif (setup->msaa_color_write) {\r\nbool last_tile_write = (!setup->msaa_zs_write &&\r\n!setup->zs_write &&\r\n!setup->color_write);\r\nuint32_t bits = VC4_LOADSTORE_FULL_RES_DISABLE_ZS;\r\nif (!last_tile_write)\r\nbits |= VC4_LOADSTORE_FULL_RES_DISABLE_CLEAR_ALL;\r\nelse if (last)\r\nbits |= VC4_LOADSTORE_FULL_RES_EOF;\r\nrcl_u8(setup, VC4_PACKET_STORE_FULL_RES_TILE_BUFFER);\r\nrcl_u32(setup,\r\nvc4_full_res_offset(exec, setup->msaa_color_write,\r\n&args->msaa_color_write, x, y) |\r\nbits);\r\n}\r\nif (setup->msaa_zs_write) {\r\nbool last_tile_write = (!setup->zs_write &&\r\n!setup->color_write);\r\nuint32_t bits = VC4_LOADSTORE_FULL_RES_DISABLE_COLOR;\r\nif (setup->msaa_color_write)\r\nvc4_tile_coordinates(setup, x, y);\r\nif (!last_tile_write)\r\nbits |= VC4_LOADSTORE_FULL_RES_DISABLE_CLEAR_ALL;\r\nelse if (last)\r\nbits |= VC4_LOADSTORE_FULL_RES_EOF;\r\nrcl_u8(setup, VC4_PACKET_STORE_FULL_RES_TILE_BUFFER);\r\nrcl_u32(setup,\r\nvc4_full_res_offset(exec, setup->msaa_zs_write,\r\n&args->msaa_zs_write, x, y) |\r\nbits);\r\n}\r\nif (setup->zs_write) {\r\nbool last_tile_write = !setup->color_write;\r\nif (setup->msaa_color_write || setup->msaa_zs_write)\r\nvc4_tile_coordinates(setup, x, y);\r\nrcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\r\nrcl_u16(setup, args->zs_write.bits |\r\n(last_tile_write ?\r\n0 : VC4_STORE_TILE_BUFFER_DISABLE_COLOR_CLEAR));\r\nrcl_u32(setup,\r\n(setup->zs_write->paddr + args->zs_write.offset) |\r\n((last && last_tile_write) ?\r\nVC4_LOADSTORE_TILE_BUFFER_EOF : 0));\r\n}\r\nif (setup->color_write) {\r\nif (setup->msaa_color_write || setup->msaa_zs_write ||\r\nsetup->zs_write) {\r\nvc4_tile_coordinates(setup, x, y);\r\n}\r\nif (last)\r\nrcl_u8(setup, VC4_PACKET_STORE_MS_TILE_BUFFER_AND_EOF);\r\nelse\r\nrcl_u8(setup, VC4_PACKET_STORE_MS_TILE_BUFFER);\r\n}\r\n}\r\nstatic int vc4_create_rcl_bo(struct drm_device *dev, struct vc4_exec_info *exec,\r\nstruct vc4_rcl_setup *setup)\r\n{\r\nstruct drm_vc4_submit_cl *args = exec->args;\r\nbool has_bin = args->bin_cl_size != 0;\r\nuint8_t min_x_tile = args->min_x_tile;\r\nuint8_t min_y_tile = args->min_y_tile;\r\nuint8_t max_x_tile = args->max_x_tile;\r\nuint8_t max_y_tile = args->max_y_tile;\r\nuint8_t xtiles = max_x_tile - min_x_tile + 1;\r\nuint8_t ytiles = max_y_tile - min_y_tile + 1;\r\nuint8_t x, y;\r\nuint32_t size, loop_body_size;\r\nsize = VC4_PACKET_TILE_RENDERING_MODE_CONFIG_SIZE;\r\nloop_body_size = VC4_PACKET_TILE_COORDINATES_SIZE;\r\nif (args->flags & VC4_SUBMIT_CL_USE_CLEAR_COLOR) {\r\nsize += VC4_PACKET_CLEAR_COLORS_SIZE +\r\nVC4_PACKET_TILE_COORDINATES_SIZE +\r\nVC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\r\n}\r\nif (setup->color_read) {\r\nif (args->color_read.flags &\r\nVC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nloop_body_size += VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER_SIZE;\r\n} else {\r\nloop_body_size += VC4_PACKET_LOAD_TILE_BUFFER_GENERAL_SIZE;\r\n}\r\n}\r\nif (setup->zs_read) {\r\nif (args->zs_read.flags &\r\nVC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nloop_body_size += VC4_PACKET_LOAD_FULL_RES_TILE_BUFFER_SIZE;\r\n} else {\r\nif (setup->color_read &&\r\n!(args->color_read.flags &\r\nVC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES)) {\r\nloop_body_size += VC4_PACKET_TILE_COORDINATES_SIZE;\r\nloop_body_size += VC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\r\n}\r\nloop_body_size += VC4_PACKET_LOAD_TILE_BUFFER_GENERAL_SIZE;\r\n}\r\n}\r\nif (has_bin) {\r\nsize += VC4_PACKET_WAIT_ON_SEMAPHORE_SIZE;\r\nloop_body_size += VC4_PACKET_BRANCH_TO_SUB_LIST_SIZE;\r\n}\r\nif (setup->msaa_color_write)\r\nloop_body_size += VC4_PACKET_STORE_FULL_RES_TILE_BUFFER_SIZE;\r\nif (setup->msaa_zs_write)\r\nloop_body_size += VC4_PACKET_STORE_FULL_RES_TILE_BUFFER_SIZE;\r\nif (setup->zs_write)\r\nloop_body_size += VC4_PACKET_STORE_TILE_BUFFER_GENERAL_SIZE;\r\nif (setup->color_write)\r\nloop_body_size += VC4_PACKET_STORE_MS_TILE_BUFFER_SIZE;\r\nloop_body_size += VC4_PACKET_TILE_COORDINATES_SIZE *\r\n((setup->msaa_color_write != NULL) +\r\n(setup->msaa_zs_write != NULL) +\r\n(setup->color_write != NULL) +\r\n(setup->zs_write != NULL) - 1);\r\nsize += xtiles * ytiles * loop_body_size;\r\nsetup->rcl = &vc4_bo_create(dev, size, true)->base;\r\nif (IS_ERR(setup->rcl))\r\nreturn PTR_ERR(setup->rcl);\r\nlist_add_tail(&to_vc4_bo(&setup->rcl->base)->unref_head,\r\n&exec->unref_list);\r\nif (args->flags & VC4_SUBMIT_CL_USE_CLEAR_COLOR) {\r\nrcl_u8(setup, VC4_PACKET_CLEAR_COLORS);\r\nrcl_u32(setup, args->clear_color[0]);\r\nrcl_u32(setup, args->clear_color[1]);\r\nrcl_u32(setup, args->clear_z);\r\nrcl_u8(setup, args->clear_s);\r\nvc4_tile_coordinates(setup, 0, 0);\r\nrcl_u8(setup, VC4_PACKET_STORE_TILE_BUFFER_GENERAL);\r\nrcl_u16(setup, VC4_LOADSTORE_TILE_BUFFER_NONE);\r\nrcl_u32(setup, 0);\r\n}\r\nrcl_u8(setup, VC4_PACKET_TILE_RENDERING_MODE_CONFIG);\r\nrcl_u32(setup,\r\n(setup->color_write ? (setup->color_write->paddr +\r\nargs->color_write.offset) :\r\n0));\r\nrcl_u16(setup, args->width);\r\nrcl_u16(setup, args->height);\r\nrcl_u16(setup, args->color_write.bits);\r\nfor (y = min_y_tile; y <= max_y_tile; y++) {\r\nfor (x = min_x_tile; x <= max_x_tile; x++) {\r\nbool first = (x == min_x_tile && y == min_y_tile);\r\nbool last = (x == max_x_tile && y == max_y_tile);\r\nemit_tile(exec, setup, x, y, first, last);\r\n}\r\n}\r\nBUG_ON(setup->next_offset != size);\r\nexec->ct1ca = setup->rcl->paddr;\r\nexec->ct1ea = setup->rcl->paddr + setup->next_offset;\r\nreturn 0;\r\n}\r\nstatic int vc4_full_res_bounds_check(struct vc4_exec_info *exec,\r\nstruct drm_gem_cma_object *obj,\r\nstruct drm_vc4_submit_rcl_surface *surf)\r\n{\r\nstruct drm_vc4_submit_cl *args = exec->args;\r\nu32 render_tiles_stride = DIV_ROUND_UP(exec->args->width, 32);\r\nif (surf->offset > obj->base.size) {\r\nDRM_ERROR("surface offset %d > BO size %zd\n",\r\nsurf->offset, obj->base.size);\r\nreturn -EINVAL;\r\n}\r\nif ((obj->base.size - surf->offset) / VC4_TILE_BUFFER_SIZE <\r\nrender_tiles_stride * args->max_y_tile + args->max_x_tile) {\r\nDRM_ERROR("MSAA tile %d, %d out of bounds "\r\n"(bo size %zd, offset %d).\n",\r\nargs->max_x_tile, args->max_y_tile,\r\nobj->base.size,\r\nsurf->offset);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vc4_rcl_msaa_surface_setup(struct vc4_exec_info *exec,\r\nstruct drm_gem_cma_object **obj,\r\nstruct drm_vc4_submit_rcl_surface *surf)\r\n{\r\nif (surf->flags != 0 || surf->bits != 0) {\r\nDRM_ERROR("MSAA surface had nonzero flags/bits\n");\r\nreturn -EINVAL;\r\n}\r\nif (surf->hindex == ~0)\r\nreturn 0;\r\n*obj = vc4_use_bo(exec, surf->hindex);\r\nif (!*obj)\r\nreturn -EINVAL;\r\nexec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\r\nif (surf->offset & 0xf) {\r\nDRM_ERROR("MSAA write must be 16b aligned.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vc4_full_res_bounds_check(exec, *obj, surf);\r\n}\r\nstatic int vc4_rcl_surface_setup(struct vc4_exec_info *exec,\r\nstruct drm_gem_cma_object **obj,\r\nstruct drm_vc4_submit_rcl_surface *surf,\r\nbool is_write)\r\n{\r\nuint8_t tiling = VC4_GET_FIELD(surf->bits,\r\nVC4_LOADSTORE_TILE_BUFFER_TILING);\r\nuint8_t buffer = VC4_GET_FIELD(surf->bits,\r\nVC4_LOADSTORE_TILE_BUFFER_BUFFER);\r\nuint8_t format = VC4_GET_FIELD(surf->bits,\r\nVC4_LOADSTORE_TILE_BUFFER_FORMAT);\r\nint cpp;\r\nint ret;\r\nif (surf->flags & ~VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nDRM_ERROR("Extra flags set\n");\r\nreturn -EINVAL;\r\n}\r\nif (surf->hindex == ~0)\r\nreturn 0;\r\n*obj = vc4_use_bo(exec, surf->hindex);\r\nif (!*obj)\r\nreturn -EINVAL;\r\nif (is_write)\r\nexec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\r\nif (surf->flags & VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {\r\nif (surf == &exec->args->zs_write) {\r\nDRM_ERROR("general zs write may not be a full-res.\n");\r\nreturn -EINVAL;\r\n}\r\nif (surf->bits != 0) {\r\nDRM_ERROR("load/store general bits set with "\r\n"full res load/store.\n");\r\nreturn -EINVAL;\r\n}\r\nret = vc4_full_res_bounds_check(exec, *obj, surf);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nif (surf->bits & ~(VC4_LOADSTORE_TILE_BUFFER_TILING_MASK |\r\nVC4_LOADSTORE_TILE_BUFFER_BUFFER_MASK |\r\nVC4_LOADSTORE_TILE_BUFFER_FORMAT_MASK)) {\r\nDRM_ERROR("Unknown bits in load/store: 0x%04x\n",\r\nsurf->bits);\r\nreturn -EINVAL;\r\n}\r\nif (tiling > VC4_TILING_FORMAT_LT) {\r\nDRM_ERROR("Bad tiling format\n");\r\nreturn -EINVAL;\r\n}\r\nif (buffer == VC4_LOADSTORE_TILE_BUFFER_ZS) {\r\nif (format != 0) {\r\nDRM_ERROR("No color format should be set for ZS\n");\r\nreturn -EINVAL;\r\n}\r\ncpp = 4;\r\n} else if (buffer == VC4_LOADSTORE_TILE_BUFFER_COLOR) {\r\nswitch (format) {\r\ncase VC4_LOADSTORE_TILE_BUFFER_BGR565:\r\ncase VC4_LOADSTORE_TILE_BUFFER_BGR565_DITHER:\r\ncpp = 2;\r\nbreak;\r\ncase VC4_LOADSTORE_TILE_BUFFER_RGBA8888:\r\ncpp = 4;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad tile buffer format\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nDRM_ERROR("Bad load/store buffer %d.\n", buffer);\r\nreturn -EINVAL;\r\n}\r\nif (surf->offset & 0xf) {\r\nDRM_ERROR("load/store buffer must be 16b aligned.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vc4_check_tex_size(exec, *obj, surf->offset, tiling,\r\nexec->args->width, exec->args->height, cpp)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvc4_rcl_render_config_surface_setup(struct vc4_exec_info *exec,\r\nstruct vc4_rcl_setup *setup,\r\nstruct drm_gem_cma_object **obj,\r\nstruct drm_vc4_submit_rcl_surface *surf)\r\n{\r\nuint8_t tiling = VC4_GET_FIELD(surf->bits,\r\nVC4_RENDER_CONFIG_MEMORY_FORMAT);\r\nuint8_t format = VC4_GET_FIELD(surf->bits,\r\nVC4_RENDER_CONFIG_FORMAT);\r\nint cpp;\r\nif (surf->flags != 0) {\r\nDRM_ERROR("No flags supported on render config.\n");\r\nreturn -EINVAL;\r\n}\r\nif (surf->bits & ~(VC4_RENDER_CONFIG_MEMORY_FORMAT_MASK |\r\nVC4_RENDER_CONFIG_FORMAT_MASK |\r\nVC4_RENDER_CONFIG_MS_MODE_4X |\r\nVC4_RENDER_CONFIG_DECIMATE_MODE_4X)) {\r\nDRM_ERROR("Unknown bits in render config: 0x%04x\n",\r\nsurf->bits);\r\nreturn -EINVAL;\r\n}\r\nif (surf->hindex == ~0)\r\nreturn 0;\r\n*obj = vc4_use_bo(exec, surf->hindex);\r\nif (!*obj)\r\nreturn -EINVAL;\r\nexec->rcl_write_bo[exec->rcl_write_bo_count++] = *obj;\r\nif (tiling > VC4_TILING_FORMAT_LT) {\r\nDRM_ERROR("Bad tiling format\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (format) {\r\ncase VC4_RENDER_CONFIG_FORMAT_BGR565_DITHERED:\r\ncase VC4_RENDER_CONFIG_FORMAT_BGR565:\r\ncpp = 2;\r\nbreak;\r\ncase VC4_RENDER_CONFIG_FORMAT_RGBA8888:\r\ncpp = 4;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad tile buffer format\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vc4_check_tex_size(exec, *obj, surf->offset, tiling,\r\nexec->args->width, exec->args->height, cpp)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint vc4_get_rcl(struct drm_device *dev, struct vc4_exec_info *exec)\r\n{\r\nstruct vc4_rcl_setup setup = {0};\r\nstruct drm_vc4_submit_cl *args = exec->args;\r\nbool has_bin = args->bin_cl_size != 0;\r\nint ret;\r\nif (args->min_x_tile > args->max_x_tile ||\r\nargs->min_y_tile > args->max_y_tile) {\r\nDRM_ERROR("Bad render tile set (%d,%d)-(%d,%d)\n",\r\nargs->min_x_tile, args->min_y_tile,\r\nargs->max_x_tile, args->max_y_tile);\r\nreturn -EINVAL;\r\n}\r\nif (has_bin &&\r\n(args->max_x_tile > exec->bin_tiles_x ||\r\nargs->max_y_tile > exec->bin_tiles_y)) {\r\nDRM_ERROR("Render tiles (%d,%d) outside of bin config "\r\n"(%d,%d)\n",\r\nargs->max_x_tile, args->max_y_tile,\r\nexec->bin_tiles_x, exec->bin_tiles_y);\r\nreturn -EINVAL;\r\n}\r\nret = vc4_rcl_render_config_surface_setup(exec, &setup,\r\n&setup.color_write,\r\n&args->color_write);\r\nif (ret)\r\nreturn ret;\r\nret = vc4_rcl_surface_setup(exec, &setup.color_read, &args->color_read,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nret = vc4_rcl_surface_setup(exec, &setup.zs_read, &args->zs_read,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nret = vc4_rcl_surface_setup(exec, &setup.zs_write, &args->zs_write,\r\ntrue);\r\nif (ret)\r\nreturn ret;\r\nret = vc4_rcl_msaa_surface_setup(exec, &setup.msaa_color_write,\r\n&args->msaa_color_write);\r\nif (ret)\r\nreturn ret;\r\nret = vc4_rcl_msaa_surface_setup(exec, &setup.msaa_zs_write,\r\n&args->msaa_zs_write);\r\nif (ret)\r\nreturn ret;\r\nif (!setup.color_write && !setup.zs_write &&\r\n!setup.msaa_color_write && !setup.msaa_zs_write) {\r\nDRM_ERROR("RCL requires color or Z/S write\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vc4_create_rcl_bo(dev, exec, &setup);\r\n}
