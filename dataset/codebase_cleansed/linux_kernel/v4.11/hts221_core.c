static int hts221_write_with_mask(struct hts221_hw *hw, u8 addr, u8 mask,\r\nu8 val)\r\n{\r\nu8 data;\r\nint err;\r\nmutex_lock(&hw->lock);\r\nerr = hw->tf->read(hw->dev, addr, sizeof(data), &data);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to read %02x register\n", addr);\r\ngoto unlock;\r\n}\r\ndata = (data & ~mask) | (val & mask);\r\nerr = hw->tf->write(hw->dev, addr, sizeof(data), &data);\r\nif (err < 0)\r\ndev_err(hw->dev, "failed to write %02x register\n", addr);\r\nunlock:\r\nmutex_unlock(&hw->lock);\r\nreturn err;\r\n}\r\nstatic int hts221_check_whoami(struct hts221_hw *hw)\r\n{\r\nu8 data;\r\nint err;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_WHOAMI_ADDR, sizeof(data),\r\n&data);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to read whoami register\n");\r\nreturn err;\r\n}\r\nif (data != HTS221_REG_WHOAMI_VAL) {\r\ndev_err(hw->dev, "wrong whoami {%02x vs %02x}\n",\r\ndata, HTS221_REG_WHOAMI_VAL);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint hts221_config_drdy(struct hts221_hw *hw, bool enable)\r\n{\r\nu8 val = enable ? BIT(2) : 0;\r\nint err;\r\nerr = hts221_write_with_mask(hw, HTS221_REG_CNTRL3_ADDR,\r\nHTS221_DRDY_MASK, val);\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic int hts221_update_odr(struct hts221_hw *hw, u8 odr)\r\n{\r\nint i, err;\r\nu8 val;\r\nfor (i = 0; i < ARRAY_SIZE(hts221_odr_table); i++)\r\nif (hts221_odr_table[i].hz == odr)\r\nbreak;\r\nif (i == ARRAY_SIZE(hts221_odr_table))\r\nreturn -EINVAL;\r\nval = HTS221_ENABLE_SENSOR | HTS221_BDU_MASK | hts221_odr_table[i].val;\r\nerr = hts221_write_with_mask(hw, HTS221_REG_CNTRL1_ADDR,\r\nHTS221_ODR_MASK, val);\r\nif (err < 0)\r\nreturn err;\r\nhw->odr = odr;\r\nreturn 0;\r\n}\r\nstatic int hts221_update_avg(struct hts221_hw *hw,\r\nenum hts221_sensor_type type,\r\nu16 val)\r\n{\r\nint i, err;\r\nconst struct hts221_avg *avg = &hts221_avg_list[type];\r\nfor (i = 0; i < HTS221_AVG_DEPTH; i++)\r\nif (avg->avg_avl[i].avg == val)\r\nbreak;\r\nif (i == HTS221_AVG_DEPTH)\r\nreturn -EINVAL;\r\nerr = hts221_write_with_mask(hw, avg->addr, avg->mask,\r\navg->avg_avl[i].val);\r\nif (err < 0)\r\nreturn err;\r\nhw->sensors[type].cur_avg_idx = i;\r\nreturn 0;\r\n}\r\nstatic ssize_t hts221_sysfs_sampling_freq(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint i;\r\nssize_t len = 0;\r\nfor (i = 0; i < ARRAY_SIZE(hts221_odr_table); i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ",\r\nhts221_odr_table[i].hz);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nhts221_sysfs_rh_oversampling_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nconst struct hts221_avg *avg = &hts221_avg_list[HTS221_SENSOR_H];\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(avg->avg_avl); i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ",\r\navg->avg_avl[i].avg);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nhts221_sysfs_temp_oversampling_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nconst struct hts221_avg *avg = &hts221_avg_list[HTS221_SENSOR_T];\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(avg->avg_avl); i++)\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d ",\r\navg->avg_avl[i].avg);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nint hts221_power_on(struct hts221_hw *hw)\r\n{\r\nreturn hts221_update_odr(hw, hw->odr);\r\n}\r\nint hts221_power_off(struct hts221_hw *hw)\r\n{\r\nu8 data[] = {0x00, 0x00};\r\nreturn hw->tf->write(hw->dev, HTS221_REG_CNTRL1_ADDR, sizeof(data),\r\ndata);\r\n}\r\nstatic int hts221_parse_temp_caldata(struct hts221_hw *hw)\r\n{\r\nint err, *slope, *b_gen;\r\ns16 cal_x0, cal_x1, cal_y0, cal_y1;\r\nu8 cal0, cal1;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_0T_CAL_Y_H,\r\nsizeof(cal0), &cal0);\r\nif (err < 0)\r\nreturn err;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_T1_T0_CAL_Y_H,\r\nsizeof(cal1), &cal1);\r\nif (err < 0)\r\nreturn err;\r\ncal_y0 = (le16_to_cpu(cal1 & 0x3) << 8) | cal0;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_1T_CAL_Y_H,\r\nsizeof(cal0), &cal0);\r\nif (err < 0)\r\nreturn err;\r\ncal_y1 = (((cal1 & 0xc) >> 2) << 8) | cal0;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_0T_CAL_X_L, sizeof(cal_x0),\r\n(u8 *)&cal_x0);\r\nif (err < 0)\r\nreturn err;\r\ncal_x0 = le16_to_cpu(cal_x0);\r\nerr = hw->tf->read(hw->dev, HTS221_REG_1T_CAL_X_L, sizeof(cal_x1),\r\n(u8 *)&cal_x1);\r\nif (err < 0)\r\nreturn err;\r\ncal_x1 = le16_to_cpu(cal_x1);\r\nslope = &hw->sensors[HTS221_SENSOR_T].slope;\r\nb_gen = &hw->sensors[HTS221_SENSOR_T].b_gen;\r\n*slope = ((cal_y1 - cal_y0) * 8000) / (cal_x1 - cal_x0);\r\n*b_gen = (((s32)cal_x1 * cal_y0 - (s32)cal_x0 * cal_y1) * 1000) /\r\n(cal_x1 - cal_x0);\r\n*b_gen *= 8;\r\nreturn 0;\r\n}\r\nstatic int hts221_parse_rh_caldata(struct hts221_hw *hw)\r\n{\r\nint err, *slope, *b_gen;\r\ns16 cal_x0, cal_x1, cal_y0, cal_y1;\r\nu8 data;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_0RH_CAL_Y_H, sizeof(data),\r\n&data);\r\nif (err < 0)\r\nreturn err;\r\ncal_y0 = data;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_1RH_CAL_Y_H, sizeof(data),\r\n&data);\r\nif (err < 0)\r\nreturn err;\r\ncal_y1 = data;\r\nerr = hw->tf->read(hw->dev, HTS221_REG_0RH_CAL_X_H, sizeof(cal_x0),\r\n(u8 *)&cal_x0);\r\nif (err < 0)\r\nreturn err;\r\ncal_x0 = le16_to_cpu(cal_x0);\r\nerr = hw->tf->read(hw->dev, HTS221_REG_1RH_CAL_X_H, sizeof(cal_x1),\r\n(u8 *)&cal_x1);\r\nif (err < 0)\r\nreturn err;\r\ncal_x1 = le16_to_cpu(cal_x1);\r\nslope = &hw->sensors[HTS221_SENSOR_H].slope;\r\nb_gen = &hw->sensors[HTS221_SENSOR_H].b_gen;\r\n*slope = ((cal_y1 - cal_y0) * 8000) / (cal_x1 - cal_x0);\r\n*b_gen = (((s32)cal_x1 * cal_y0 - (s32)cal_x0 * cal_y1) * 1000) /\r\n(cal_x1 - cal_x0);\r\n*b_gen *= 8;\r\nreturn 0;\r\n}\r\nstatic int hts221_get_sensor_scale(struct hts221_hw *hw,\r\nenum iio_chan_type ch_type,\r\nint *val, int *val2)\r\n{\r\ns64 tmp;\r\ns32 rem, div, data;\r\nswitch (ch_type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\ndata = hw->sensors[HTS221_SENSOR_H].slope;\r\ndiv = (1 << 4) * 1000;\r\nbreak;\r\ncase IIO_TEMP:\r\ndata = hw->sensors[HTS221_SENSOR_T].slope;\r\ndiv = (1 << 6) * 1000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntmp = div_s64(data * 1000000000LL, div);\r\ntmp = div_s64_rem(tmp, 1000000000LL, &rem);\r\n*val = tmp;\r\n*val2 = rem;\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nstatic int hts221_get_sensor_offset(struct hts221_hw *hw,\r\nenum iio_chan_type ch_type,\r\nint *val, int *val2)\r\n{\r\ns64 tmp;\r\ns32 rem, div, data;\r\nswitch (ch_type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\ndata = hw->sensors[HTS221_SENSOR_H].b_gen;\r\ndiv = hw->sensors[HTS221_SENSOR_H].slope;\r\nbreak;\r\ncase IIO_TEMP:\r\ndata = hw->sensors[HTS221_SENSOR_T].b_gen;\r\ndiv = hw->sensors[HTS221_SENSOR_T].slope;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntmp = div_s64(data * 1000000000LL, div);\r\ntmp = div_s64_rem(tmp, 1000000000LL, &rem);\r\n*val = tmp;\r\n*val2 = rem;\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nstatic int hts221_read_oneshot(struct hts221_hw *hw, u8 addr, int *val)\r\n{\r\nu8 data[HTS221_DATA_SIZE];\r\nint err;\r\nerr = hts221_power_on(hw);\r\nif (err < 0)\r\nreturn err;\r\nmsleep(50);\r\nerr = hw->tf->read(hw->dev, addr, sizeof(data), data);\r\nif (err < 0)\r\nreturn err;\r\nhts221_power_off(hw);\r\n*val = (s16)get_unaligned_le16(data);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int hts221_read_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *ch,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct hts221_hw *hw = iio_priv(iio_dev);\r\nint ret;\r\nret = iio_device_claim_direct_mode(iio_dev);\r\nif (ret)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = hts221_read_oneshot(hw, ch->address, val);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = hts221_get_sensor_scale(hw, ch->type, val, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nret = hts221_get_sensor_offset(hw, ch->type, val, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = hw->odr;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_OVERSAMPLING_RATIO: {\r\nu8 idx;\r\nconst struct hts221_avg *avg;\r\nswitch (ch->type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\navg = &hts221_avg_list[HTS221_SENSOR_H];\r\nidx = hw->sensors[HTS221_SENSOR_H].cur_avg_idx;\r\n*val = avg->avg_avl[idx].avg;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_TEMP:\r\navg = &hts221_avg_list[HTS221_SENSOR_T];\r\nidx = hw->sensors[HTS221_SENSOR_T].cur_avg_idx;\r\n*val = avg->avg_avl[idx].avg;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(iio_dev);\r\nreturn ret;\r\n}\r\nstatic int hts221_write_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct hts221_hw *hw = iio_priv(iio_dev);\r\nint ret;\r\nret = iio_device_claim_direct_mode(iio_dev);\r\nif (ret)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nret = hts221_update_odr(hw, val);\r\nbreak;\r\ncase IIO_CHAN_INFO_OVERSAMPLING_RATIO:\r\nswitch (chan->type) {\r\ncase IIO_HUMIDITYRELATIVE:\r\nret = hts221_update_avg(hw, HTS221_SENSOR_H, val);\r\nbreak;\r\ncase IIO_TEMP:\r\nret = hts221_update_avg(hw, HTS221_SENSOR_T, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(iio_dev);\r\nreturn ret;\r\n}\r\nstatic int hts221_validate_trigger(struct iio_dev *iio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct hts221_hw *hw = iio_priv(iio_dev);\r\nreturn hw->trig == trig ? 0 : -EINVAL;\r\n}\r\nint hts221_probe(struct iio_dev *iio_dev)\r\n{\r\nstruct hts221_hw *hw = iio_priv(iio_dev);\r\nint err;\r\nu8 data;\r\nmutex_init(&hw->lock);\r\nerr = hts221_check_whoami(hw);\r\nif (err < 0)\r\nreturn err;\r\nhw->odr = hts221_odr_table[0].hz;\r\niio_dev->modes = INDIO_DIRECT_MODE;\r\niio_dev->dev.parent = hw->dev;\r\niio_dev->available_scan_masks = hts221_scan_masks;\r\niio_dev->channels = hts221_channels;\r\niio_dev->num_channels = ARRAY_SIZE(hts221_channels);\r\niio_dev->name = HTS221_DEV_NAME;\r\niio_dev->info = &hts221_info;\r\nerr = hts221_parse_rh_caldata(hw);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to get rh calibration data\n");\r\nreturn err;\r\n}\r\ndata = hts221_avg_list[HTS221_SENSOR_H].avg_avl[3].avg;\r\nerr = hts221_update_avg(hw, HTS221_SENSOR_H, data);\r\nif (err < 0) {\r\ndev_err(hw->dev, "failed to set rh oversampling ratio\n");\r\nreturn err;\r\n}\r\nerr = hts221_parse_temp_caldata(hw);\r\nif (err < 0) {\r\ndev_err(hw->dev,\r\n"failed to get temperature calibration data\n");\r\nreturn err;\r\n}\r\ndata = hts221_avg_list[HTS221_SENSOR_T].avg_avl[3].avg;\r\nerr = hts221_update_avg(hw, HTS221_SENSOR_T, data);\r\nif (err < 0) {\r\ndev_err(hw->dev,\r\n"failed to set temperature oversampling ratio\n");\r\nreturn err;\r\n}\r\nif (hw->irq > 0) {\r\nerr = hts221_allocate_buffers(hw);\r\nif (err < 0)\r\nreturn err;\r\nerr = hts221_allocate_trigger(hw);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn devm_iio_device_register(hw->dev, iio_dev);\r\n}
