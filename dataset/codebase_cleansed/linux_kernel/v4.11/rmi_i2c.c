static int rmi_set_page(struct rmi_i2c_xport *rmi_i2c, u8 page)\r\n{\r\nstruct i2c_client *client = rmi_i2c->client;\r\nu8 txbuf[2] = {RMI_PAGE_SELECT_REGISTER, page};\r\nint retval;\r\nretval = i2c_master_send(client, txbuf, sizeof(txbuf));\r\nif (retval != sizeof(txbuf)) {\r\ndev_err(&client->dev,\r\n"%s: set page failed: %d.", __func__, retval);\r\nreturn (retval < 0) ? retval : -EIO;\r\n}\r\nrmi_i2c->page = page;\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_write_block(struct rmi_transport_dev *xport, u16 addr,\r\nconst void *buf, size_t len)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c =\r\ncontainer_of(xport, struct rmi_i2c_xport, xport);\r\nstruct i2c_client *client = rmi_i2c->client;\r\nsize_t tx_size = len + 1;\r\nint retval;\r\nmutex_lock(&rmi_i2c->page_mutex);\r\nif (!rmi_i2c->tx_buf || rmi_i2c->tx_buf_size < tx_size) {\r\nif (rmi_i2c->tx_buf)\r\ndevm_kfree(&client->dev, rmi_i2c->tx_buf);\r\nrmi_i2c->tx_buf_size = tx_size + BUFFER_SIZE_INCREMENT;\r\nrmi_i2c->tx_buf = devm_kzalloc(&client->dev,\r\nrmi_i2c->tx_buf_size,\r\nGFP_KERNEL);\r\nif (!rmi_i2c->tx_buf) {\r\nrmi_i2c->tx_buf_size = 0;\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\n}\r\nrmi_i2c->tx_buf[0] = addr & 0xff;\r\nmemcpy(rmi_i2c->tx_buf + 1, buf, len);\r\nif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\r\nretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\r\nif (retval)\r\ngoto exit;\r\n}\r\nretval = i2c_master_send(client, rmi_i2c->tx_buf, tx_size);\r\nif (retval == tx_size)\r\nretval = 0;\r\nelse if (retval >= 0)\r\nretval = -EIO;\r\nexit:\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev,\r\n"write %zd bytes at %#06x: %d (%*ph)\n",\r\nlen, addr, retval, (int)len, buf);\r\nmutex_unlock(&rmi_i2c->page_mutex);\r\nreturn retval;\r\n}\r\nstatic int rmi_i2c_read_block(struct rmi_transport_dev *xport, u16 addr,\r\nvoid *buf, size_t len)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c =\r\ncontainer_of(xport, struct rmi_i2c_xport, xport);\r\nstruct i2c_client *client = rmi_i2c->client;\r\nu8 addr_offset = addr & 0xff;\r\nint retval;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.len = sizeof(addr_offset),\r\n.buf = &addr_offset,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n},\r\n};\r\nmutex_lock(&rmi_i2c->page_mutex);\r\nif (RMI_I2C_PAGE(addr) != rmi_i2c->page) {\r\nretval = rmi_set_page(rmi_i2c, RMI_I2C_PAGE(addr));\r\nif (retval)\r\ngoto exit;\r\n}\r\nretval = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (retval == ARRAY_SIZE(msgs))\r\nretval = 0;\r\nelse if (retval >= 0)\r\nretval = -EIO;\r\nexit:\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev,\r\n"read %zd bytes at %#06x: %d (%*ph)\n",\r\nlen, addr, retval, (int)len, buf);\r\nmutex_unlock(&rmi_i2c->page_mutex);\r\nreturn retval;\r\n}\r\nstatic void rmi_i2c_regulator_bulk_disable(void *data)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c = data;\r\nregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\n}\r\nstatic void rmi_i2c_unregister_transport(void *data)\r\n{\r\nstruct rmi_i2c_xport *rmi_i2c = data;\r\nrmi_unregister_transport_device(&rmi_i2c->xport);\r\n}\r\nstatic int rmi_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rmi_device_platform_data *pdata;\r\nstruct rmi_device_platform_data *client_pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct rmi_i2c_xport *rmi_i2c;\r\nint retval;\r\nrmi_i2c = devm_kzalloc(&client->dev, sizeof(struct rmi_i2c_xport),\r\nGFP_KERNEL);\r\nif (!rmi_i2c)\r\nreturn -ENOMEM;\r\npdata = &rmi_i2c->xport.pdata;\r\nif (!client->dev.of_node && client_pdata)\r\n*pdata = *client_pdata;\r\npdata->irq = client->irq;\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev, "Probing %s.\n",\r\ndev_name(&client->dev));\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev,\r\n"adapter does not support required functionality.\n");\r\nreturn -ENODEV;\r\n}\r\nrmi_i2c->supplies[0].supply = "vdd";\r\nrmi_i2c->supplies[1].supply = "vio";\r\nretval = devm_regulator_bulk_get(&client->dev,\r\nARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = devm_add_action_or_reset(&client->dev,\r\nrmi_i2c_regulator_bulk_disable,\r\nrmi_i2c);\r\nif (retval)\r\nreturn retval;\r\nof_property_read_u32(client->dev.of_node, "syna,startup-delay-ms",\r\n&rmi_i2c->startup_delay);\r\nmsleep(rmi_i2c->startup_delay);\r\nrmi_i2c->client = client;\r\nmutex_init(&rmi_i2c->page_mutex);\r\nrmi_i2c->xport.dev = &client->dev;\r\nrmi_i2c->xport.proto_name = "i2c";\r\nrmi_i2c->xport.ops = &rmi_i2c_ops;\r\ni2c_set_clientdata(client, rmi_i2c);\r\nretval = rmi_set_page(rmi_i2c, 0);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to set page select to 0.\n");\r\nreturn retval;\r\n}\r\nretval = rmi_register_transport_device(&rmi_i2c->xport);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to register transport driver at 0x%.2X.\n",\r\nclient->addr);\r\nreturn retval;\r\n}\r\nretval = devm_add_action_or_reset(&client->dev,\r\nrmi_i2c_unregister_transport,\r\nrmi_i2c);\r\nif (retval)\r\nreturn retval;\r\ndev_info(&client->dev, "registered rmi i2c driver at %#04x.\n",\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev, true);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nreturn ret;\r\n}\r\nstatic int rmi_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nif (ret)\r\nreturn ret;\r\nmsleep(rmi_i2c->startup_delay);\r\nret = rmi_driver_resume(rmi_i2c->xport.rmi_dev, true);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rmi_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_i2c->xport.rmi_dev, false);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nregulator_bulk_disable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nreturn 0;\r\n}\r\nstatic int rmi_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_i2c_xport *rmi_i2c = i2c_get_clientdata(client);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(rmi_i2c->supplies),\r\nrmi_i2c->supplies);\r\nif (ret)\r\nreturn ret;\r\nmsleep(rmi_i2c->startup_delay);\r\nret = rmi_driver_resume(rmi_i2c->xport.rmi_dev, false);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn 0;\r\n}
