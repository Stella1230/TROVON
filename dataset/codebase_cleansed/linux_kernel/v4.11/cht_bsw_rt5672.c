static inline struct snd_soc_dai *cht_get_codec_dai(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd;\r\nlist_for_each_entry(rtd, &card->rtd_list, list) {\r\nif (!strncmp(rtd->codec_dai->name, CHT_CODEC_DAI,\r\nstrlen(CHT_CODEC_DAI)))\r\nreturn rtd->codec_dai;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int platform_clock_control(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct snd_soc_dapm_context *dapm = w->dapm;\r\nstruct snd_soc_card *card = dapm->card;\r\nstruct snd_soc_dai *codec_dai;\r\nint ret;\r\ncodec_dai = cht_get_codec_dai(card);\r\nif (!codec_dai) {\r\ndev_err(card->dev, "Codec dai not found; Unable to set platform clock\n");\r\nreturn -EIO;\r\n}\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nret = snd_soc_dai_set_pll(codec_dai, 0, RT5670_PLL1_S_MCLK,\r\nCHT_PLAT_CLK_3_HZ, 48000 * 512);\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec pll: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5670_SCLK_S_PLL1,\r\n48000 * 512, SND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(card->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nsnd_soc_dai_set_sysclk(codec_dai, RT5670_SCLK_S_RCCLK,\r\n48000 * 512, SND_SOC_CLOCK_IN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *codec_dai = rtd->codec_dai;\r\nint ret;\r\nret = snd_soc_dai_set_pll(codec_dai, 0, RT5670_PLL1_S_MCLK,\r\nCHT_PLAT_CLK_3_HZ, params_rate(params) * 512);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec pll: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_dai_set_sysclk(codec_dai, RT5670_SCLK_S_PLL1,\r\nparams_rate(params) * 512,\r\nSND_SOC_CLOCK_IN);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_codec_init(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nint ret;\r\nstruct snd_soc_dai *codec_dai = runtime->codec_dai;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4, 24);\r\nif (ret < 0) {\r\ndev_err(runtime->dev, "can't set codec TDM slot %d\n", ret);\r\nreturn ret;\r\n}\r\nrt5670_sel_asrc_clk_src(codec,\r\nRT5670_DA_STEREO_FILTER\r\n| RT5670_DA_MONO_L_FILTER\r\n| RT5670_DA_MONO_R_FILTER\r\n| RT5670_AD_STEREO_FILTER\r\n| RT5670_AD_MONO_L_FILTER\r\n| RT5670_AD_MONO_R_FILTER,\r\nRT5670_CLK_SEL_I2S1_ASRC);\r\nret = snd_soc_card_jack_new(runtime->card, "Headset",\r\nSND_JACK_HEADSET | SND_JACK_BTN_0 |\r\nSND_JACK_BTN_1 | SND_JACK_BTN_2, &cht_bsw_headset,\r\ncht_bsw_headset_pins, ARRAY_SIZE(cht_bsw_headset_pins));\r\nif (ret)\r\nreturn ret;\r\nrt5670_set_jack_detect(codec, &cht_bsw_headset);\r\nreturn 0;\r\n}\r\nstatic int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_interval *rate = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval *channels = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nrate->min = rate->max = 48000;\r\nchannels->min = channels->max = 2;\r\nparams_set_format(params, SNDRV_PCM_FORMAT_S24_LE);\r\nreturn 0;\r\n}\r\nstatic int cht_aif1_startup(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_hw_constraint_single(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, 48000);\r\n}\r\nstatic int cht_suspend_pre(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_component *component;\r\nlist_for_each_entry(component, &card->component_dev_list, card_list) {\r\nif (!strcmp(component->name, "i2c-10EC5670:00")) {\r\nstruct snd_soc_codec *codec = snd_soc_component_to_codec(component);\r\ndev_dbg(codec->dev, "disabling jack detect before going to suspend.\n");\r\nrt5670_jack_suspend(codec);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cht_resume_post(struct snd_soc_card *card)\r\n{\r\nstruct snd_soc_component *component;\r\nlist_for_each_entry(component, &card->component_dev_list, card_list) {\r\nif (!strcmp(component->name, "i2c-10EC5670:00")) {\r\nstruct snd_soc_codec *codec = snd_soc_component_to_codec(component);\r\ndev_dbg(codec->dev, "enabling jack detect for resume.\n");\r\nrt5670_jack_resume(codec);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cht_mc_probe(struct platform_device *pdev)\r\n{\r\nint ret_val = 0;\r\nstruct sst_acpi_mach *mach = pdev->dev.platform_data;\r\nconst char *i2c_name;\r\nint i;\r\nstrcpy(cht_bsw_codec_name, RT5672_I2C_DEFAULT);\r\nif (mach) {\r\ni2c_name = sst_acpi_find_name_from_hid(mach->id);\r\nif (i2c_name) {\r\nsnprintf(cht_bsw_codec_name, sizeof(cht_bsw_codec_name),\r\n"i2c-%s", i2c_name);\r\nfor (i = 0; i < ARRAY_SIZE(cht_dailink); i++) {\r\nif (!strcmp(cht_dailink[i].codec_name,\r\nRT5672_I2C_DEFAULT)) {\r\ncht_dailink[i].codec_name =\r\ncht_bsw_codec_name;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nsnd_soc_card_cht.dev = &pdev->dev;\r\nret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cht);\r\nif (ret_val) {\r\ndev_err(&pdev->dev,\r\n"snd_soc_register_card failed %d\n", ret_val);\r\nreturn ret_val;\r\n}\r\nplatform_set_drvdata(pdev, &snd_soc_card_cht);\r\nreturn ret_val;\r\n}
