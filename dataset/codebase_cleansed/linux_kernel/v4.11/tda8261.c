static int tda8261_read(struct tda8261_state *state, u8 *buf)\r\n{\r\nconst struct tda8261_config *config = state->config;\r\nint err = 0;\r\nstruct i2c_msg msg = { .addr = config->addr, .flags = I2C_M_RD,.buf = buf, .len = 1 };\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1)\r\npr_err("%s: read error, err=%d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int tda8261_write(struct tda8261_state *state, u8 *buf)\r\n{\r\nconst struct tda8261_config *config = state->config;\r\nint err = 0;\r\nstruct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = 4 };\r\nif ((err = i2c_transfer(state->i2c, &msg, 1)) != 1)\r\npr_err("%s: write error, err=%d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic int tda8261_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct tda8261_state *state = fe->tuner_priv;\r\nu8 result = 0;\r\nint err = 0;\r\n*status = 0;\r\nif ((err = tda8261_read(state, &result)) < 0) {\r\npr_err("%s: I/O Error\n", __func__);\r\nreturn err;\r\n}\r\nif ((result >> 6) & 0x01) {\r\npr_debug("%s: Tuner Phase Locked\n", __func__);\r\n*status = 1;\r\n}\r\nreturn err;\r\n}\r\nstatic int tda8261_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda8261_state *state = fe->tuner_priv;\r\n*frequency = state->frequency;\r\nreturn 0;\r\n}\r\nstatic int tda8261_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct tda8261_state *state = fe->tuner_priv;\r\nconst struct tda8261_config *config = state->config;\r\nu32 frequency, N, status = 0;\r\nu8 buf[4];\r\nint err = 0;\r\nfrequency = c->frequency;\r\nif ((frequency < 950000) || (frequency > 2150000)) {\r\npr_warn("%s: Frequency beyond limits, frequency=%d\n",\r\n__func__, frequency);\r\nreturn -EINVAL;\r\n}\r\nN = (frequency + (div_tab[config->step_size] - 1)) / div_tab[config->step_size];\r\npr_debug("%s: Step size=%d, Divider=%d, PG=0x%02x (%d)\n",\r\n__func__, config->step_size, div_tab[config->step_size], N, N);\r\nbuf[0] = (N >> 8) & 0xff;\r\nbuf[1] = N & 0xff;\r\nbuf[2] = (0x01 << 7) | ((ref_div[config->step_size] & 0x07) << 1);\r\nif (frequency < 1450000)\r\nbuf[3] = 0x00;\r\nelse if (frequency < 2000000)\r\nbuf[3] = 0x40;\r\nelse if (frequency < 2150000)\r\nbuf[3] = 0x80;\r\nerr = tda8261_write(state, buf);\r\nif (err < 0) {\r\npr_err("%s: I/O Error\n", __func__);\r\nreturn err;\r\n}\r\npr_debug("%s: Waiting to Phase LOCK\n", __func__);\r\nmsleep(20);\r\nif ((err = tda8261_get_status(fe, &status)) < 0) {\r\npr_err("%s: I/O Error\n", __func__);\r\nreturn err;\r\n}\r\nif (status == 1) {\r\npr_debug("%s: Tuner Phase locked: status=%d\n", __func__,\r\nstatus);\r\nstate->frequency = frequency;\r\n} else {\r\npr_debug("%s: No Phase lock: status=%d\n", __func__, status);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tda8261_release(struct dvb_frontend *fe)\r\n{\r\nstruct tda8261_state *state = fe->tuner_priv;\r\nfe->tuner_priv = NULL;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *tda8261_attach(struct dvb_frontend *fe,\r\nconst struct tda8261_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct tda8261_state *state = NULL;\r\nif ((state = kzalloc(sizeof (struct tda8261_state), GFP_KERNEL)) == NULL)\r\ngoto exit;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->fe = fe;\r\nfe->tuner_priv = state;\r\nfe->ops.tuner_ops = tda8261_ops;\r\nfe->ops.tuner_ops.info.frequency_step = div_tab[config->step_size];\r\npr_info("%s: Attaching TDA8261 8PSK/QPSK tuner\n", __func__);\r\nreturn fe;\r\nexit:\r\nkfree(state);\r\nreturn NULL;\r\n}
