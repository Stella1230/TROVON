static struct i40iw_handler *i40iw_find_i40e_handler(struct i40e_info *ldev)\r\n{\r\nstruct i40iw_handler *hdl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&i40iw_handler_lock, flags);\r\nlist_for_each_entry(hdl, &i40iw_handlers, list) {\r\nif (hdl->ldev.netdev == ldev->netdev) {\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\nreturn hdl;\r\n}\r\n}\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\nreturn NULL;\r\n}\r\nstruct i40iw_handler *i40iw_find_netdev(struct net_device *netdev)\r\n{\r\nstruct i40iw_handler *hdl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&i40iw_handler_lock, flags);\r\nlist_for_each_entry(hdl, &i40iw_handlers, list) {\r\nif (hdl->ldev.netdev == netdev) {\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\nreturn hdl;\r\n}\r\n}\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void i40iw_add_handler(struct i40iw_handler *hdl)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&i40iw_handler_lock, flags);\r\nlist_add(&hdl->list, &i40iw_handlers);\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\n}\r\nstatic int i40iw_del_handler(struct i40iw_handler *hdl)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&i40iw_handler_lock, flags);\r\nlist_del(&hdl->list);\r\nspin_unlock_irqrestore(&i40iw_handler_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void i40iw_enable_intr(struct i40iw_sc_dev *dev, u32 msix_id)\r\n{\r\nu32 val;\r\nval = I40E_PFINT_DYN_CTLN_INTENA_MASK |\r\nI40E_PFINT_DYN_CTLN_CLEARPBA_MASK |\r\n(3 << I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT);\r\nif (dev->is_pf)\r\ni40iw_wr32(dev->hw, I40E_PFINT_DYN_CTLN(msix_id - 1), val);\r\nelse\r\ni40iw_wr32(dev->hw, I40E_VFINT_DYN_CTLN1(msix_id - 1), val);\r\n}\r\nstatic void i40iw_dpc(unsigned long data)\r\n{\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)data;\r\nif (iwdev->msix_shared)\r\ni40iw_process_ceq(iwdev, iwdev->ceqlist);\r\ni40iw_process_aeq(iwdev);\r\ni40iw_enable_intr(&iwdev->sc_dev, iwdev->iw_msixtbl[0].idx);\r\n}\r\nstatic void i40iw_ceq_dpc(unsigned long data)\r\n{\r\nstruct i40iw_ceq *iwceq = (struct i40iw_ceq *)data;\r\nstruct i40iw_device *iwdev = iwceq->iwdev;\r\ni40iw_process_ceq(iwdev, iwceq);\r\ni40iw_enable_intr(&iwdev->sc_dev, iwceq->msix_idx);\r\n}\r\nstatic irqreturn_t i40iw_irq_handler(int irq, void *data)\r\n{\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)data;\r\ntasklet_schedule(&iwdev->dpc_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void i40iw_destroy_cqp(struct i40iw_device *iwdev, bool free_hwcqp)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_cqp *cqp = &iwdev->cqp;\r\nif (free_hwcqp)\r\ndev->cqp_ops->cqp_destroy(dev->cqp);\r\ni40iw_free_dma_mem(dev->hw, &cqp->sq);\r\nkfree(cqp->scratch_array);\r\niwdev->cqp.scratch_array = NULL;\r\nkfree(cqp->cqp_requests);\r\ncqp->cqp_requests = NULL;\r\n}\r\nstatic void i40iw_disable_irq(struct i40iw_sc_dev *dev,\r\nstruct i40iw_msix_vector *msix_vec,\r\nvoid *dev_id)\r\n{\r\nif (dev->is_pf)\r\ni40iw_wr32(dev->hw, I40E_PFINT_DYN_CTLN(msix_vec->idx - 1), 0);\r\nelse\r\ni40iw_wr32(dev->hw, I40E_VFINT_DYN_CTLN1(msix_vec->idx - 1), 0);\r\nirq_set_affinity_hint(msix_vec->irq, NULL);\r\nfree_irq(msix_vec->irq, dev_id);\r\n}\r\nstatic void i40iw_destroy_aeq(struct i40iw_device *iwdev, bool reset)\r\n{\r\nenum i40iw_status_code status = I40IW_ERR_NOT_READY;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_aeq *aeq = &iwdev->aeq;\r\nif (!iwdev->msix_shared)\r\ni40iw_disable_irq(dev, iwdev->iw_msixtbl, (void *)iwdev);\r\nif (reset)\r\ngoto exit;\r\nif (!dev->aeq_ops->aeq_destroy(&aeq->sc_aeq, 0, 1))\r\nstatus = dev->aeq_ops->aeq_destroy_done(&aeq->sc_aeq);\r\nif (status)\r\ni40iw_pr_err("destroy aeq failed %d\n", status);\r\nexit:\r\ni40iw_free_dma_mem(dev->hw, &aeq->mem);\r\n}\r\nstatic void i40iw_destroy_ceq(struct i40iw_device *iwdev,\r\nstruct i40iw_ceq *iwceq,\r\nbool reset)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nif (reset)\r\ngoto exit;\r\nstatus = dev->ceq_ops->ceq_destroy(&iwceq->sc_ceq, 0, 1);\r\nif (status) {\r\ni40iw_pr_err("ceq destroy command failed %d\n", status);\r\ngoto exit;\r\n}\r\nstatus = dev->ceq_ops->cceq_destroy_done(&iwceq->sc_ceq);\r\nif (status)\r\ni40iw_pr_err("ceq destroy completion failed %d\n", status);\r\nexit:\r\ni40iw_free_dma_mem(dev->hw, &iwceq->mem);\r\n}\r\nstatic void i40iw_dele_ceqs(struct i40iw_device *iwdev, bool reset)\r\n{\r\nu32 i = 0;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_ceq *iwceq = iwdev->ceqlist;\r\nstruct i40iw_msix_vector *msix_vec = iwdev->iw_msixtbl;\r\nif (iwdev->msix_shared) {\r\ni40iw_disable_irq(dev, msix_vec, (void *)iwdev);\r\ni40iw_destroy_ceq(iwdev, iwceq, reset);\r\niwceq++;\r\ni++;\r\n}\r\nfor (msix_vec++; i < iwdev->ceqs_count; i++, msix_vec++, iwceq++) {\r\ni40iw_disable_irq(dev, msix_vec, (void *)iwceq);\r\ni40iw_destroy_ceq(iwdev, iwceq, reset);\r\n}\r\n}\r\nstatic void i40iw_destroy_ccq(struct i40iw_device *iwdev, bool reset)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_ccq *ccq = &iwdev->ccq;\r\nenum i40iw_status_code status = 0;\r\nif (!reset)\r\nstatus = dev->ccq_ops->ccq_destroy(dev->ccq, 0, true);\r\nif (status)\r\ni40iw_pr_err("ccq destroy failed %d\n", status);\r\ni40iw_free_dma_mem(dev->hw, &ccq->mem_cq);\r\n}\r\nstatic void i40iw_close_hmc_objects_type(struct i40iw_sc_dev *dev,\r\nenum i40iw_hmc_rsrc_type obj_type,\r\nstruct i40iw_hmc_info *hmc_info,\r\nbool is_pf,\r\nbool reset)\r\n{\r\nstruct i40iw_hmc_del_obj_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.hmc_info = hmc_info;\r\ninfo.rsrc_type = obj_type;\r\ninfo.count = hmc_info->hmc_obj[obj_type].cnt;\r\ninfo.is_pf = is_pf;\r\nif (dev->hmc_ops->del_hmc_object(dev, &info, reset))\r\ni40iw_pr_err("del obj of type %d failed\n", obj_type);\r\n}\r\nstatic void i40iw_del_hmc_objects(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_info *hmc_info,\r\nbool is_pf,\r\nbool reset)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < IW_HMC_OBJ_TYPE_NUM; i++)\r\ni40iw_close_hmc_objects_type(dev, iw_hmc_obj_types[i], hmc_info, is_pf, reset);\r\n}\r\nstatic irqreturn_t i40iw_ceq_handler(int irq, void *data)\r\n{\r\nstruct i40iw_ceq *iwceq = (struct i40iw_ceq *)data;\r\nif (iwceq->irq != irq)\r\ni40iw_pr_err("expected irq = %d received irq = %d\n", iwceq->irq, irq);\r\ntasklet_schedule(&iwceq->dpc_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum i40iw_status_code i40iw_create_hmc_obj_type(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_create_obj_info *info)\r\n{\r\nreturn dev->hmc_ops->create_hmc_object(dev, info);\r\n}\r\nstatic enum i40iw_status_code i40iw_create_hmc_objs(struct i40iw_device *iwdev,\r\nbool is_pf)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_hmc_create_obj_info info;\r\nenum i40iw_status_code status;\r\nint i;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.hmc_info = dev->hmc_info;\r\ninfo.is_pf = is_pf;\r\ninfo.entry_type = iwdev->sd_type;\r\nfor (i = 0; i < IW_HMC_OBJ_TYPE_NUM; i++) {\r\ninfo.rsrc_type = iw_hmc_obj_types[i];\r\ninfo.count = dev->hmc_info->hmc_obj[info.rsrc_type].cnt;\r\nstatus = i40iw_create_hmc_obj_type(dev, &info);\r\nif (status) {\r\ni40iw_pr_err("create obj type %d status = %d\n",\r\niw_hmc_obj_types[i], status);\r\nbreak;\r\n}\r\n}\r\nif (!status)\r\nreturn (dev->cqp_misc_ops->static_hmc_pages_allocated(dev->cqp, 0,\r\ndev->hmc_fn_id,\r\ntrue, true));\r\nwhile (i) {\r\ni--;\r\ni40iw_close_hmc_objects_type(dev,\r\niw_hmc_obj_types[i],\r\ndev->hmc_info,\r\nis_pf,\r\nfalse);\r\n}\r\nreturn status;\r\n}\r\nenum i40iw_status_code i40iw_obj_aligned_mem(struct i40iw_device *iwdev,\r\nstruct i40iw_dma_mem *memptr,\r\nu32 size,\r\nu32 mask)\r\n{\r\nunsigned long va, newva;\r\nunsigned long extra;\r\nva = (unsigned long)iwdev->obj_next.va;\r\nnewva = va;\r\nif (mask)\r\nnewva = ALIGN(va, (mask + 1));\r\nextra = newva - va;\r\nmemptr->va = (u8 *)va + extra;\r\nmemptr->pa = iwdev->obj_next.pa + extra;\r\nmemptr->size = size;\r\nif ((memptr->va + size) > (iwdev->obj_mem.va + iwdev->obj_mem.size))\r\nreturn I40IW_ERR_NO_MEMORY;\r\niwdev->obj_next.va = memptr->va + size;\r\niwdev->obj_next.pa = memptr->pa + size;\r\nreturn 0;\r\n}\r\nstatic enum i40iw_status_code i40iw_create_cqp(struct i40iw_device *iwdev)\r\n{\r\nenum i40iw_status_code status;\r\nu32 sqsize = I40IW_CQP_SW_SQSIZE_2048;\r\nstruct i40iw_dma_mem mem;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_cqp_init_info cqp_init_info;\r\nstruct i40iw_cqp *cqp = &iwdev->cqp;\r\nu16 maj_err, min_err;\r\nint i;\r\ncqp->cqp_requests = kcalloc(sqsize, sizeof(*cqp->cqp_requests), GFP_KERNEL);\r\nif (!cqp->cqp_requests)\r\nreturn I40IW_ERR_NO_MEMORY;\r\ncqp->scratch_array = kcalloc(sqsize, sizeof(*cqp->scratch_array), GFP_KERNEL);\r\nif (!cqp->scratch_array) {\r\nkfree(cqp->cqp_requests);\r\nreturn I40IW_ERR_NO_MEMORY;\r\n}\r\ndev->cqp = &cqp->sc_cqp;\r\ndev->cqp->dev = dev;\r\nmemset(&cqp_init_info, 0, sizeof(cqp_init_info));\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &cqp->sq,\r\n(sizeof(struct i40iw_cqp_sq_wqe) * sqsize),\r\nI40IW_CQP_ALIGNMENT);\r\nif (status)\r\ngoto exit;\r\nstatus = i40iw_obj_aligned_mem(iwdev, &mem, sizeof(struct i40iw_cqp_ctx),\r\nI40IW_HOST_CTX_ALIGNMENT_MASK);\r\nif (status)\r\ngoto exit;\r\ndev->cqp->host_ctx_pa = mem.pa;\r\ndev->cqp->host_ctx = mem.va;\r\ncqp_init_info.dev = dev;\r\ncqp_init_info.sq_size = sqsize;\r\ncqp_init_info.sq = cqp->sq.va;\r\ncqp_init_info.sq_pa = cqp->sq.pa;\r\ncqp_init_info.host_ctx_pa = mem.pa;\r\ncqp_init_info.host_ctx = mem.va;\r\ncqp_init_info.hmc_profile = iwdev->resource_profile;\r\ncqp_init_info.enabled_vf_count = iwdev->max_rdma_vfs;\r\ncqp_init_info.scratch_array = cqp->scratch_array;\r\nstatus = dev->cqp_ops->cqp_init(dev->cqp, &cqp_init_info);\r\nif (status) {\r\ni40iw_pr_err("cqp init status %d\n", status);\r\ngoto exit;\r\n}\r\nstatus = dev->cqp_ops->cqp_create(dev->cqp, &maj_err, &min_err);\r\nif (status) {\r\ni40iw_pr_err("cqp create status %d maj_err %d min_err %d\n",\r\nstatus, maj_err, min_err);\r\ngoto exit;\r\n}\r\nspin_lock_init(&cqp->req_lock);\r\nINIT_LIST_HEAD(&cqp->cqp_avail_reqs);\r\nINIT_LIST_HEAD(&cqp->cqp_pending_reqs);\r\nfor (i = 0; i < I40IW_CQP_SW_SQSIZE_2048; i++) {\r\ninit_waitqueue_head(&cqp->cqp_requests[i].waitq);\r\nlist_add_tail(&cqp->cqp_requests[i].list, &cqp->cqp_avail_reqs);\r\n}\r\nreturn 0;\r\nexit:\r\ni40iw_destroy_cqp(iwdev, false);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_create_ccq(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_dma_mem mem;\r\nenum i40iw_status_code status;\r\nstruct i40iw_ccq_init_info info;\r\nstruct i40iw_ccq *ccq = &iwdev->ccq;\r\nmemset(&info, 0, sizeof(info));\r\ndev->ccq = &ccq->sc_cq;\r\ndev->ccq->dev = dev;\r\ninfo.dev = dev;\r\nccq->shadow_area.size = sizeof(struct i40iw_cq_shadow_area);\r\nccq->mem_cq.size = sizeof(struct i40iw_cqe) * IW_CCQ_SIZE;\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &ccq->mem_cq,\r\nccq->mem_cq.size, I40IW_CQ0_ALIGNMENT);\r\nif (status)\r\ngoto exit;\r\nstatus = i40iw_obj_aligned_mem(iwdev, &mem, ccq->shadow_area.size,\r\nI40IW_SHADOWAREA_MASK);\r\nif (status)\r\ngoto exit;\r\nccq->sc_cq.back_cq = (void *)ccq;\r\ninfo.cq_base = ccq->mem_cq.va;\r\ninfo.cq_pa = ccq->mem_cq.pa;\r\ninfo.num_elem = IW_CCQ_SIZE;\r\ninfo.shadow_area = mem.va;\r\ninfo.shadow_area_pa = mem.pa;\r\ninfo.ceqe_mask = false;\r\ninfo.ceq_id_valid = true;\r\ninfo.shadow_read_threshold = 16;\r\nstatus = dev->ccq_ops->ccq_init(dev->ccq, &info);\r\nif (!status)\r\nstatus = dev->ccq_ops->ccq_create(dev->ccq, 0, true, true);\r\nexit:\r\nif (status)\r\ni40iw_free_dma_mem(dev->hw, &ccq->mem_cq);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_configure_ceq_vector(struct i40iw_device *iwdev,\r\nstruct i40iw_ceq *iwceq,\r\nu32 ceq_id,\r\nstruct i40iw_msix_vector *msix_vec)\r\n{\r\nenum i40iw_status_code status;\r\ncpumask_t mask;\r\nif (iwdev->msix_shared && !ceq_id) {\r\ntasklet_init(&iwdev->dpc_tasklet, i40iw_dpc, (unsigned long)iwdev);\r\nstatus = request_irq(msix_vec->irq, i40iw_irq_handler, 0, "AEQCEQ", iwdev);\r\n} else {\r\ntasklet_init(&iwceq->dpc_tasklet, i40iw_ceq_dpc, (unsigned long)iwceq);\r\nstatus = request_irq(msix_vec->irq, i40iw_ceq_handler, 0, "CEQ", iwceq);\r\n}\r\ncpumask_clear(&mask);\r\ncpumask_set_cpu(msix_vec->cpu_affinity, &mask);\r\nirq_set_affinity_hint(msix_vec->irq, &mask);\r\nif (status) {\r\ni40iw_pr_err("ceq irq config fail\n");\r\nreturn I40IW_ERR_CONFIG;\r\n}\r\nmsix_vec->ceq_id = ceq_id;\r\nreturn 0;\r\n}\r\nstatic enum i40iw_status_code i40iw_create_ceq(struct i40iw_device *iwdev,\r\nstruct i40iw_ceq *iwceq,\r\nu32 ceq_id)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_ceq_init_info info;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nu64 scratch;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.ceq_id = ceq_id;\r\niwceq->iwdev = iwdev;\r\niwceq->mem.size = sizeof(struct i40iw_ceqe) *\r\niwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_CQ].cnt;\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &iwceq->mem, iwceq->mem.size,\r\nI40IW_CEQ_ALIGNMENT);\r\nif (status)\r\ngoto exit;\r\ninfo.ceq_id = ceq_id;\r\ninfo.ceqe_base = iwceq->mem.va;\r\ninfo.ceqe_pa = iwceq->mem.pa;\r\ninfo.elem_cnt = iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_CQ].cnt;\r\niwceq->sc_ceq.ceq_id = ceq_id;\r\ninfo.dev = dev;\r\nscratch = (uintptr_t)&iwdev->cqp.sc_cqp;\r\nstatus = dev->ceq_ops->ceq_init(&iwceq->sc_ceq, &info);\r\nif (!status)\r\nstatus = dev->ceq_ops->cceq_create(&iwceq->sc_ceq, scratch);\r\nexit:\r\nif (status)\r\ni40iw_free_dma_mem(dev->hw, &iwceq->mem);\r\nreturn status;\r\n}\r\nvoid i40iw_request_reset(struct i40iw_device *iwdev)\r\n{\r\nstruct i40e_info *ldev = iwdev->ldev;\r\nldev->ops->request_reset(ldev, iwdev->client, 1);\r\n}\r\nstatic enum i40iw_status_code i40iw_setup_ceqs(struct i40iw_device *iwdev,\r\nstruct i40e_info *ldev)\r\n{\r\nu32 i;\r\nu32 ceq_id;\r\nstruct i40iw_ceq *iwceq;\r\nstruct i40iw_msix_vector *msix_vec;\r\nenum i40iw_status_code status = 0;\r\nu32 num_ceqs;\r\nif (ldev && ldev->ops && ldev->ops->setup_qvlist) {\r\nstatus = ldev->ops->setup_qvlist(ldev, &i40iw_client,\r\niwdev->iw_qvlist);\r\nif (status)\r\ngoto exit;\r\n} else {\r\nstatus = I40IW_ERR_BAD_PTR;\r\ngoto exit;\r\n}\r\nnum_ceqs = min(iwdev->msix_count, iwdev->sc_dev.hmc_fpm_misc.max_ceqs);\r\niwdev->ceqlist = kcalloc(num_ceqs, sizeof(*iwdev->ceqlist), GFP_KERNEL);\r\nif (!iwdev->ceqlist) {\r\nstatus = I40IW_ERR_NO_MEMORY;\r\ngoto exit;\r\n}\r\ni = (iwdev->msix_shared) ? 0 : 1;\r\nfor (ceq_id = 0; i < num_ceqs; i++, ceq_id++) {\r\niwceq = &iwdev->ceqlist[ceq_id];\r\nstatus = i40iw_create_ceq(iwdev, iwceq, ceq_id);\r\nif (status) {\r\ni40iw_pr_err("create ceq status = %d\n", status);\r\nbreak;\r\n}\r\nmsix_vec = &iwdev->iw_msixtbl[i];\r\niwceq->irq = msix_vec->irq;\r\niwceq->msix_idx = msix_vec->idx;\r\nstatus = i40iw_configure_ceq_vector(iwdev, iwceq, ceq_id, msix_vec);\r\nif (status) {\r\ni40iw_destroy_ceq(iwdev, iwceq, false);\r\nbreak;\r\n}\r\ni40iw_enable_intr(&iwdev->sc_dev, msix_vec->idx);\r\niwdev->ceqs_count++;\r\n}\r\nexit:\r\nif (status) {\r\nif (!iwdev->ceqs_count) {\r\nkfree(iwdev->ceqlist);\r\niwdev->ceqlist = NULL;\r\n} else {\r\nstatus = 0;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_configure_aeq_vector(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_msix_vector *msix_vec = iwdev->iw_msixtbl;\r\nu32 ret = 0;\r\nif (!iwdev->msix_shared) {\r\ntasklet_init(&iwdev->dpc_tasklet, i40iw_dpc, (unsigned long)iwdev);\r\nret = request_irq(msix_vec->irq, i40iw_irq_handler, 0, "i40iw", iwdev);\r\n}\r\nif (ret) {\r\ni40iw_pr_err("aeq irq config fail\n");\r\nreturn I40IW_ERR_CONFIG;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum i40iw_status_code i40iw_create_aeq(struct i40iw_device *iwdev)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_aeq_init_info info;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_aeq *aeq = &iwdev->aeq;\r\nu64 scratch = 0;\r\nu32 aeq_size;\r\naeq_size = 2 * iwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_QP].cnt +\r\niwdev->sc_dev.hmc_info->hmc_obj[I40IW_HMC_IW_CQ].cnt;\r\nmemset(&info, 0, sizeof(info));\r\naeq->mem.size = sizeof(struct i40iw_sc_aeqe) * aeq_size;\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &aeq->mem, aeq->mem.size,\r\nI40IW_AEQ_ALIGNMENT);\r\nif (status)\r\ngoto exit;\r\ninfo.aeqe_base = aeq->mem.va;\r\ninfo.aeq_elem_pa = aeq->mem.pa;\r\ninfo.elem_cnt = aeq_size;\r\ninfo.dev = dev;\r\nstatus = dev->aeq_ops->aeq_init(&aeq->sc_aeq, &info);\r\nif (status)\r\ngoto exit;\r\nstatus = dev->aeq_ops->aeq_create(&aeq->sc_aeq, scratch, 1);\r\nif (!status)\r\nstatus = dev->aeq_ops->aeq_create_done(&aeq->sc_aeq);\r\nexit:\r\nif (status)\r\ni40iw_free_dma_mem(dev->hw, &aeq->mem);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_setup_aeq(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nstatus = i40iw_create_aeq(iwdev);\r\nif (status)\r\nreturn status;\r\nstatus = i40iw_configure_aeq_vector(iwdev);\r\nif (status) {\r\ni40iw_destroy_aeq(iwdev, false);\r\nreturn status;\r\n}\r\nif (!iwdev->msix_shared)\r\ni40iw_enable_intr(dev, iwdev->iw_msixtbl[0].idx);\r\nreturn 0;\r\n}\r\nstatic enum i40iw_status_code i40iw_initialize_ilq(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_puda_rsrc_info info;\r\nenum i40iw_status_code status;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.type = I40IW_PUDA_RSRC_TYPE_ILQ;\r\ninfo.cq_id = 1;\r\ninfo.qp_id = 0;\r\ninfo.count = 1;\r\ninfo.pd_id = 1;\r\ninfo.sq_size = 8192;\r\ninfo.rq_size = 8192;\r\ninfo.buf_size = 1024;\r\ninfo.tx_buf_cnt = 16384;\r\ninfo.receive = i40iw_receive_ilq;\r\ninfo.xmit_complete = i40iw_free_sqbuf;\r\nstatus = i40iw_puda_create_rsrc(&iwdev->vsi, &info);\r\nif (status)\r\ni40iw_pr_err("ilq create fail\n");\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_initialize_ieq(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_puda_rsrc_info info;\r\nenum i40iw_status_code status;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.type = I40IW_PUDA_RSRC_TYPE_IEQ;\r\ninfo.cq_id = 2;\r\ninfo.qp_id = iwdev->sc_dev.exception_lan_queue;\r\ninfo.count = 1;\r\ninfo.pd_id = 2;\r\ninfo.sq_size = 8192;\r\ninfo.rq_size = 8192;\r\ninfo.buf_size = 2048;\r\ninfo.tx_buf_cnt = 16384;\r\nstatus = i40iw_puda_create_rsrc(&iwdev->vsi, &info);\r\nif (status)\r\ni40iw_pr_err("ieq create fail\n");\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_hmc_setup(struct i40iw_device *iwdev)\r\n{\r\nenum i40iw_status_code status;\r\niwdev->sd_type = I40IW_SD_TYPE_DIRECT;\r\nstatus = i40iw_config_fpm_values(&iwdev->sc_dev, IW_CFG_FPM_QP_COUNT);\r\nif (status)\r\ngoto exit;\r\nstatus = i40iw_create_hmc_objs(iwdev, true);\r\nif (status)\r\ngoto exit;\r\niwdev->init_state = HMC_OBJS_CREATED;\r\nexit:\r\nreturn status;\r\n}\r\nstatic void i40iw_del_init_mem(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\ni40iw_free_dma_mem(&iwdev->hw, &iwdev->obj_mem);\r\nkfree(dev->hmc_info->sd_table.sd_entry);\r\ndev->hmc_info->sd_table.sd_entry = NULL;\r\nkfree(iwdev->mem_resources);\r\niwdev->mem_resources = NULL;\r\nkfree(iwdev->ceqlist);\r\niwdev->ceqlist = NULL;\r\nkfree(iwdev->iw_msixtbl);\r\niwdev->iw_msixtbl = NULL;\r\nkfree(iwdev->hmc_info_mem);\r\niwdev->hmc_info_mem = NULL;\r\n}\r\nstatic void i40iw_del_macip_entry(struct i40iw_device *iwdev, u8 idx)\r\n{\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nenum i40iw_status_code status = 0;\r\ncqp_request = i40iw_get_cqp_request(iwcqp, true);\r\nif (!cqp_request) {\r\ni40iw_pr_err("cqp_request memory failed\n");\r\nreturn;\r\n}\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_DELETE_LOCAL_MAC_IPADDR_ENTRY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.del_local_mac_ipaddr_entry.cqp = &iwcqp->sc_cqp;\r\ncqp_info->in.u.del_local_mac_ipaddr_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->in.u.del_local_mac_ipaddr_entry.entry_idx = idx;\r\ncqp_info->in.u.del_local_mac_ipaddr_entry.ignore_ref_count = 0;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Del MAC Ip entry fail");\r\n}\r\nstatic enum i40iw_status_code i40iw_add_mac_ipaddr_entry(struct i40iw_device *iwdev,\r\nu8 *mac_addr,\r\nu8 idx)\r\n{\r\nstruct i40iw_local_mac_ipaddr_entry_info *info;\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nenum i40iw_status_code status = 0;\r\ncqp_request = i40iw_get_cqp_request(iwcqp, true);\r\nif (!cqp_request) {\r\ni40iw_pr_err("cqp_request memory failed\n");\r\nreturn I40IW_ERR_NO_MEMORY;\r\n}\r\ncqp_info = &cqp_request->info;\r\ncqp_info->post_sq = 1;\r\ninfo = &cqp_info->in.u.add_local_mac_ipaddr_entry.info;\r\nether_addr_copy(info->mac_addr, mac_addr);\r\ninfo->entry_idx = idx;\r\ncqp_info->in.u.add_local_mac_ipaddr_entry.scratch = (uintptr_t)cqp_request;\r\ncqp_info->cqp_cmd = OP_ADD_LOCAL_MAC_IPADDR_ENTRY;\r\ncqp_info->in.u.add_local_mac_ipaddr_entry.cqp = &iwcqp->sc_cqp;\r\ncqp_info->in.u.add_local_mac_ipaddr_entry.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (status)\r\ni40iw_pr_err("CQP-OP Add MAC Ip entry fail");\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_alloc_local_mac_ipaddr_entry(struct i40iw_device *iwdev,\r\nu16 *mac_ip_tbl_idx)\r\n{\r\nstruct i40iw_cqp *iwcqp = &iwdev->cqp;\r\nstruct i40iw_cqp_request *cqp_request;\r\nstruct cqp_commands_info *cqp_info;\r\nenum i40iw_status_code status = 0;\r\ncqp_request = i40iw_get_cqp_request(iwcqp, true);\r\nif (!cqp_request) {\r\ni40iw_pr_err("cqp_request memory failed\n");\r\nreturn I40IW_ERR_NO_MEMORY;\r\n}\r\natomic_inc(&cqp_request->refcount);\r\ncqp_info = &cqp_request->info;\r\ncqp_info->cqp_cmd = OP_ALLOC_LOCAL_MAC_IPADDR_ENTRY;\r\ncqp_info->post_sq = 1;\r\ncqp_info->in.u.alloc_local_mac_ipaddr_entry.cqp = &iwcqp->sc_cqp;\r\ncqp_info->in.u.alloc_local_mac_ipaddr_entry.scratch = (uintptr_t)cqp_request;\r\nstatus = i40iw_handle_cqp_op(iwdev, cqp_request);\r\nif (!status)\r\n*mac_ip_tbl_idx = cqp_request->compl_info.op_ret_val;\r\nelse\r\ni40iw_pr_err("CQP-OP Alloc MAC Ip entry fail");\r\ni40iw_put_cqp_request(iwcqp, cqp_request);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_alloc_set_mac_ipaddr(struct i40iw_device *iwdev,\r\nu8 *macaddr)\r\n{\r\nenum i40iw_status_code status;\r\nstatus = i40iw_alloc_local_mac_ipaddr_entry(iwdev, &iwdev->mac_ip_table_idx);\r\nif (!status) {\r\nstatus = i40iw_add_mac_ipaddr_entry(iwdev, macaddr,\r\n(u8)iwdev->mac_ip_table_idx);\r\nif (status)\r\ni40iw_del_macip_entry(iwdev, (u8)iwdev->mac_ip_table_idx);\r\n}\r\nreturn status;\r\n}\r\nstatic void i40iw_add_ipv6_addr(struct i40iw_device *iwdev)\r\n{\r\nstruct net_device *ip_dev;\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifp, *tmp;\r\nu32 local_ipaddr6[4];\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, ip_dev) {\r\nif ((((rdma_vlan_dev_vlan_id(ip_dev) < 0xFFFF) &&\r\n(rdma_vlan_dev_real_dev(ip_dev) == iwdev->netdev)) ||\r\n(ip_dev == iwdev->netdev)) && (ip_dev->flags & IFF_UP)) {\r\nidev = __in6_dev_get(ip_dev);\r\nif (!idev) {\r\ni40iw_pr_err("ipv6 inet device not found\n");\r\nbreak;\r\n}\r\nlist_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {\r\ni40iw_pr_info("IP=%pI6, vlan_id=%d, MAC=%pM\n", &ifp->addr,\r\nrdma_vlan_dev_vlan_id(ip_dev), ip_dev->dev_addr);\r\ni40iw_copy_ip_ntohl(local_ipaddr6,\r\nifp->addr.in6_u.u6_addr32);\r\ni40iw_manage_arp_cache(iwdev,\r\nip_dev->dev_addr,\r\nlocal_ipaddr6,\r\nfalse,\r\nI40IW_ARP_ADD);\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void i40iw_add_ipv4_addr(struct i40iw_device *iwdev)\r\n{\r\nstruct net_device *dev;\r\nstruct in_device *idev;\r\nbool got_lock = true;\r\nu32 ip_addr;\r\nif (!rtnl_trylock())\r\ngot_lock = false;\r\nfor_each_netdev(&init_net, dev) {\r\nif ((((rdma_vlan_dev_vlan_id(dev) < 0xFFFF) &&\r\n(rdma_vlan_dev_real_dev(dev) == iwdev->netdev)) ||\r\n(dev == iwdev->netdev)) && (dev->flags & IFF_UP)) {\r\nidev = in_dev_get(dev);\r\nfor_ifa(idev) {\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_CM,\r\n"IP=%pI4, vlan_id=%d, MAC=%pM\n", &ifa->ifa_address,\r\nrdma_vlan_dev_vlan_id(dev), dev->dev_addr);\r\nip_addr = ntohl(ifa->ifa_address);\r\ni40iw_manage_arp_cache(iwdev,\r\ndev->dev_addr,\r\n&ip_addr,\r\ntrue,\r\nI40IW_ARP_ADD);\r\n}\r\nendfor_ifa(idev);\r\nin_dev_put(idev);\r\n}\r\n}\r\nif (got_lock)\r\nrtnl_unlock();\r\n}\r\nstatic enum i40iw_status_code i40iw_add_mac_ip(struct i40iw_device *iwdev)\r\n{\r\nstruct net_device *netdev = iwdev->netdev;\r\nenum i40iw_status_code status;\r\nstatus = i40iw_alloc_set_mac_ipaddr(iwdev, (u8 *)netdev->dev_addr);\r\nif (status)\r\nreturn status;\r\ni40iw_add_ipv4_addr(iwdev);\r\ni40iw_add_ipv6_addr(iwdev);\r\nreturn 0;\r\n}\r\nstatic void i40iw_wait_pe_ready(struct i40iw_hw *hw)\r\n{\r\nu32 statusfw;\r\nu32 statuscpu0;\r\nu32 statuscpu1;\r\nu32 statuscpu2;\r\nu32 retrycount = 0;\r\ndo {\r\nstatusfw = i40iw_rd32(hw, I40E_GLPE_FWLDSTATUS);\r\ni40iw_pr_info("[%04d] fm load status[x%04X]\n", __LINE__, statusfw);\r\nstatuscpu0 = i40iw_rd32(hw, I40E_GLPE_CPUSTATUS0);\r\ni40iw_pr_info("[%04d] CSR_CQP status[x%04X]\n", __LINE__, statuscpu0);\r\nstatuscpu1 = i40iw_rd32(hw, I40E_GLPE_CPUSTATUS1);\r\ni40iw_pr_info("[%04d] I40E_GLPE_CPUSTATUS1 status[x%04X]\n",\r\n__LINE__, statuscpu1);\r\nstatuscpu2 = i40iw_rd32(hw, I40E_GLPE_CPUSTATUS2);\r\ni40iw_pr_info("[%04d] I40E_GLPE_CPUSTATUS2 status[x%04X]\n",\r\n__LINE__, statuscpu2);\r\nif ((statuscpu0 == 0x80) && (statuscpu1 == 0x80) && (statuscpu2 == 0x80))\r\nbreak;\r\nmdelay(1000);\r\nretrycount++;\r\n} while (retrycount < 14);\r\ni40iw_wr32(hw, 0xb4040, 0x4C104C5);\r\n}\r\nstatic enum i40iw_status_code i40iw_initialize_dev(struct i40iw_device *iwdev,\r\nstruct i40e_info *ldev)\r\n{\r\nenum i40iw_status_code status;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nstruct i40iw_device_init_info info;\r\nstruct i40iw_vsi_init_info vsi_info;\r\nstruct i40iw_dma_mem mem;\r\nstruct i40iw_l2params l2params;\r\nu32 size;\r\nstruct i40iw_vsi_stats_info stats_info;\r\nu16 last_qset = I40IW_NO_QSET;\r\nu16 qset;\r\nu32 i;\r\nmemset(&l2params, 0, sizeof(l2params));\r\nmemset(&info, 0, sizeof(info));\r\nsize = sizeof(struct i40iw_hmc_pble_rsrc) + sizeof(struct i40iw_hmc_info) +\r\n(sizeof(struct i40iw_hmc_obj_info) * I40IW_HMC_IW_MAX);\r\niwdev->hmc_info_mem = kzalloc(size, GFP_KERNEL);\r\nif (!iwdev->hmc_info_mem)\r\nreturn I40IW_ERR_NO_MEMORY;\r\niwdev->pble_rsrc = (struct i40iw_hmc_pble_rsrc *)iwdev->hmc_info_mem;\r\ndev->hmc_info = &iwdev->hw.hmc;\r\ndev->hmc_info->hmc_obj = (struct i40iw_hmc_obj_info *)(iwdev->pble_rsrc + 1);\r\nstatus = i40iw_obj_aligned_mem(iwdev, &mem, I40IW_QUERY_FPM_BUF_SIZE,\r\nI40IW_FPM_QUERY_BUF_ALIGNMENT_MASK);\r\nif (status)\r\ngoto exit;\r\ninfo.fpm_query_buf_pa = mem.pa;\r\ninfo.fpm_query_buf = mem.va;\r\nstatus = i40iw_obj_aligned_mem(iwdev, &mem, I40IW_COMMIT_FPM_BUF_SIZE,\r\nI40IW_FPM_COMMIT_BUF_ALIGNMENT_MASK);\r\nif (status)\r\ngoto exit;\r\ninfo.fpm_commit_buf_pa = mem.pa;\r\ninfo.fpm_commit_buf = mem.va;\r\ninfo.hmc_fn_id = ldev->fid;\r\ninfo.is_pf = (ldev->ftype) ? false : true;\r\ninfo.bar0 = ldev->hw_addr;\r\ninfo.hw = &iwdev->hw;\r\ninfo.debug_mask = debug;\r\nl2params.mss =\r\n(ldev->params.mtu) ? ldev->params.mtu - I40IW_MTU_TO_MSS : I40IW_DEFAULT_MSS;\r\nfor (i = 0; i < I40E_CLIENT_MAX_USER_PRIORITY; i++) {\r\nqset = ldev->params.qos.prio_qos[i].qs_handle;\r\nl2params.qs_handle_list[i] = qset;\r\nif (last_qset == I40IW_NO_QSET)\r\nlast_qset = qset;\r\nelse if ((qset != last_qset) && (qset != I40IW_NO_QSET))\r\niwdev->dcb = true;\r\n}\r\ni40iw_pr_info("DCB is set/clear = %d\n", iwdev->dcb);\r\ninfo.exception_lan_queue = 1;\r\ninfo.vchnl_send = i40iw_virtchnl_send;\r\nstatus = i40iw_device_init(&iwdev->sc_dev, &info);\r\nexit:\r\nif (status) {\r\nkfree(iwdev->hmc_info_mem);\r\niwdev->hmc_info_mem = NULL;\r\n}\r\nmemset(&vsi_info, 0, sizeof(vsi_info));\r\nvsi_info.dev = &iwdev->sc_dev;\r\nvsi_info.back_vsi = (void *)iwdev;\r\nvsi_info.params = &l2params;\r\ni40iw_sc_vsi_init(&iwdev->vsi, &vsi_info);\r\nif (dev->is_pf) {\r\nmemset(&stats_info, 0, sizeof(stats_info));\r\nstats_info.fcn_id = ldev->fid;\r\nstats_info.pestat = kzalloc(sizeof(*stats_info.pestat), GFP_KERNEL);\r\nstats_info.stats_initialize = true;\r\nif (stats_info.pestat)\r\ni40iw_vsi_stats_init(&iwdev->vsi, &stats_info);\r\n}\r\nreturn status;\r\n}\r\nstatic void i40iw_register_notifiers(void)\r\n{\r\nif (atomic_inc_return(&i40iw_notifiers_registered) == 1) {\r\nregister_inetaddr_notifier(&i40iw_inetaddr_notifier);\r\nregister_inet6addr_notifier(&i40iw_inetaddr6_notifier);\r\nregister_netevent_notifier(&i40iw_net_notifier);\r\n}\r\n}\r\nstatic enum i40iw_status_code i40iw_save_msix_info(struct i40iw_device *iwdev,\r\nstruct i40e_info *ldev)\r\n{\r\nstruct i40e_qvlist_info *iw_qvlist;\r\nstruct i40e_qv_info *iw_qvinfo;\r\nu32 ceq_idx;\r\nu32 i;\r\nu32 size;\r\niwdev->msix_count = ldev->msix_count;\r\nsize = sizeof(struct i40iw_msix_vector) * iwdev->msix_count;\r\nsize += sizeof(struct i40e_qvlist_info);\r\nsize += sizeof(struct i40e_qv_info) * iwdev->msix_count - 1;\r\niwdev->iw_msixtbl = kzalloc(size, GFP_KERNEL);\r\nif (!iwdev->iw_msixtbl)\r\nreturn I40IW_ERR_NO_MEMORY;\r\niwdev->iw_qvlist = (struct i40e_qvlist_info *)(&iwdev->iw_msixtbl[iwdev->msix_count]);\r\niw_qvlist = iwdev->iw_qvlist;\r\niw_qvinfo = iw_qvlist->qv_info;\r\niw_qvlist->num_vectors = iwdev->msix_count;\r\nif (iwdev->msix_count <= num_online_cpus())\r\niwdev->msix_shared = true;\r\nfor (i = 0, ceq_idx = 0; i < iwdev->msix_count; i++, iw_qvinfo++) {\r\niwdev->iw_msixtbl[i].idx = ldev->msix_entries[i].entry;\r\niwdev->iw_msixtbl[i].irq = ldev->msix_entries[i].vector;\r\niwdev->iw_msixtbl[i].cpu_affinity = ceq_idx;\r\nif (i == 0) {\r\niw_qvinfo->aeq_idx = 0;\r\nif (iwdev->msix_shared)\r\niw_qvinfo->ceq_idx = ceq_idx++;\r\nelse\r\niw_qvinfo->ceq_idx = I40E_QUEUE_INVALID_IDX;\r\n} else {\r\niw_qvinfo->aeq_idx = I40E_QUEUE_INVALID_IDX;\r\niw_qvinfo->ceq_idx = ceq_idx++;\r\n}\r\niw_qvinfo->itr_idx = 3;\r\niw_qvinfo->v_idx = iwdev->iw_msixtbl[i].idx;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i40iw_deinit_device(struct i40iw_device *iwdev, bool reset)\r\n{\r\nstruct i40e_info *ldev = iwdev->ldev;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\ni40iw_pr_info("state = %d\n", iwdev->init_state);\r\nif (iwdev->param_wq)\r\ndestroy_workqueue(iwdev->param_wq);\r\nswitch (iwdev->init_state) {\r\ncase RDMA_DEV_REGISTERED:\r\niwdev->iw_status = 0;\r\ni40iw_port_ibevent(iwdev);\r\ni40iw_destroy_rdma_device(iwdev->iwibdev);\r\ncase IP_ADDR_REGISTERED:\r\nif (!reset)\r\ni40iw_del_macip_entry(iwdev, (u8)iwdev->mac_ip_table_idx);\r\ncase INET_NOTIFIER:\r\nif (!atomic_dec_return(&i40iw_notifiers_registered)) {\r\nunregister_netevent_notifier(&i40iw_net_notifier);\r\nunregister_inetaddr_notifier(&i40iw_inetaddr_notifier);\r\nunregister_inet6addr_notifier(&i40iw_inetaddr6_notifier);\r\n}\r\ncase CEQ_CREATED:\r\ni40iw_dele_ceqs(iwdev, reset);\r\ncase AEQ_CREATED:\r\ni40iw_destroy_aeq(iwdev, reset);\r\ncase IEQ_CREATED:\r\ni40iw_puda_dele_resources(&iwdev->vsi, I40IW_PUDA_RSRC_TYPE_IEQ, reset);\r\ncase ILQ_CREATED:\r\ni40iw_puda_dele_resources(&iwdev->vsi, I40IW_PUDA_RSRC_TYPE_ILQ, reset);\r\ncase CCQ_CREATED:\r\ni40iw_destroy_ccq(iwdev, reset);\r\ncase PBLE_CHUNK_MEM:\r\ni40iw_destroy_pble_pool(dev, iwdev->pble_rsrc);\r\ncase HMC_OBJS_CREATED:\r\ni40iw_del_hmc_objects(dev, dev->hmc_info, true, reset);\r\ncase CQP_CREATED:\r\ni40iw_destroy_cqp(iwdev, true);\r\ncase INITIAL_STATE:\r\ni40iw_cleanup_cm_core(&iwdev->cm_core);\r\nif (iwdev->vsi.pestat) {\r\ni40iw_vsi_stats_free(&iwdev->vsi);\r\nkfree(iwdev->vsi.pestat);\r\n}\r\ni40iw_del_init_mem(iwdev);\r\nbreak;\r\ncase INVALID_STATE:\r\ndefault:\r\ni40iw_pr_err("bad init_state = %d\n", iwdev->init_state);\r\nbreak;\r\n}\r\ni40iw_del_handler(i40iw_find_i40e_handler(ldev));\r\nkfree(iwdev->hdl);\r\n}\r\nstatic enum i40iw_status_code i40iw_setup_init_state(struct i40iw_handler *hdl,\r\nstruct i40e_info *ldev,\r\nstruct i40e_client *client)\r\n{\r\nstruct i40iw_device *iwdev = &hdl->device;\r\nstruct i40iw_sc_dev *dev = &iwdev->sc_dev;\r\nenum i40iw_status_code status;\r\nmemcpy(&hdl->ldev, ldev, sizeof(*ldev));\r\nif (resource_profile == 1)\r\nresource_profile = 2;\r\niwdev->mpa_version = mpa_version;\r\niwdev->resource_profile = (resource_profile < I40IW_HMC_PROFILE_EQUAL) ?\r\n(u8)resource_profile + I40IW_HMC_PROFILE_DEFAULT :\r\nI40IW_HMC_PROFILE_DEFAULT;\r\niwdev->max_rdma_vfs =\r\n(iwdev->resource_profile != I40IW_HMC_PROFILE_DEFAULT) ? max_rdma_vfs : 0;\r\niwdev->max_enabled_vfs = iwdev->max_rdma_vfs;\r\niwdev->netdev = ldev->netdev;\r\nhdl->client = client;\r\nif (!ldev->ftype)\r\niwdev->db_start = pci_resource_start(ldev->pcidev, 0) + I40IW_DB_ADDR_OFFSET;\r\nelse\r\niwdev->db_start = pci_resource_start(ldev->pcidev, 0) + I40IW_VF_DB_ADDR_OFFSET;\r\nstatus = i40iw_save_msix_info(iwdev, ldev);\r\nif (status)\r\ngoto exit;\r\niwdev->hw.dev_context = (void *)ldev->pcidev;\r\niwdev->hw.hw_addr = ldev->hw_addr;\r\nstatus = i40iw_allocate_dma_mem(&iwdev->hw,\r\n&iwdev->obj_mem, 8192, 4096);\r\nif (status)\r\ngoto exit;\r\niwdev->obj_next = iwdev->obj_mem;\r\niwdev->push_mode = push_mode;\r\ninit_waitqueue_head(&iwdev->vchnl_waitq);\r\ninit_waitqueue_head(&dev->vf_reqs);\r\ninit_waitqueue_head(&iwdev->close_wq);\r\nstatus = i40iw_initialize_dev(iwdev, ldev);\r\nexit:\r\nif (status) {\r\nkfree(iwdev->iw_msixtbl);\r\ni40iw_free_dma_mem(dev->hw, &iwdev->obj_mem);\r\niwdev->iw_msixtbl = NULL;\r\n}\r\nreturn status;\r\n}\r\nstatic void i40iw_get_used_rsrc(struct i40iw_device *iwdev)\r\n{\r\niwdev->used_pds = find_next_zero_bit(iwdev->allocated_pds, iwdev->max_pd, 0);\r\niwdev->used_qps = find_next_zero_bit(iwdev->allocated_qps, iwdev->max_qp, 0);\r\niwdev->used_cqs = find_next_zero_bit(iwdev->allocated_cqs, iwdev->max_cq, 0);\r\niwdev->used_mrs = find_next_zero_bit(iwdev->allocated_mrs, iwdev->max_mr, 0);\r\n}\r\nstatic int i40iw_open(struct i40e_info *ldev, struct i40e_client *client)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_sc_dev *dev;\r\nenum i40iw_status_code status;\r\nstruct i40iw_handler *hdl;\r\nhdl = i40iw_find_netdev(ldev->netdev);\r\nif (hdl)\r\nreturn 0;\r\nhdl = kzalloc(sizeof(*hdl), GFP_KERNEL);\r\nif (!hdl)\r\nreturn -ENOMEM;\r\niwdev = &hdl->device;\r\niwdev->hdl = hdl;\r\ndev = &iwdev->sc_dev;\r\ni40iw_setup_cm_core(iwdev);\r\ndev->back_dev = (void *)iwdev;\r\niwdev->ldev = &hdl->ldev;\r\niwdev->client = client;\r\nmutex_init(&iwdev->pbl_mutex);\r\ni40iw_add_handler(hdl);\r\ndo {\r\nstatus = i40iw_setup_init_state(hdl, ldev, client);\r\nif (status)\r\nbreak;\r\niwdev->init_state = INITIAL_STATE;\r\nif (dev->is_pf)\r\ni40iw_wait_pe_ready(dev->hw);\r\nstatus = i40iw_create_cqp(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = CQP_CREATED;\r\nstatus = i40iw_hmc_setup(iwdev);\r\nif (status)\r\nbreak;\r\nstatus = i40iw_create_ccq(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = CCQ_CREATED;\r\nstatus = i40iw_initialize_ilq(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = ILQ_CREATED;\r\nstatus = i40iw_initialize_ieq(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = IEQ_CREATED;\r\nstatus = i40iw_setup_aeq(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = AEQ_CREATED;\r\nstatus = i40iw_setup_ceqs(iwdev, ldev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = CEQ_CREATED;\r\nstatus = i40iw_initialize_hw_resources(iwdev);\r\nif (status)\r\nbreak;\r\ni40iw_get_used_rsrc(iwdev);\r\ndev->ccq_ops->ccq_arm(dev->ccq);\r\nstatus = i40iw_hmc_init_pble(&iwdev->sc_dev, iwdev->pble_rsrc);\r\nif (status)\r\nbreak;\r\niwdev->virtchnl_wq = alloc_ordered_workqueue("iwvch", WQ_MEM_RECLAIM);\r\ni40iw_register_notifiers();\r\niwdev->init_state = INET_NOTIFIER;\r\nstatus = i40iw_add_mac_ip(iwdev);\r\nif (status)\r\nbreak;\r\niwdev->init_state = IP_ADDR_REGISTERED;\r\nif (i40iw_register_rdma_device(iwdev)) {\r\ni40iw_pr_err("register rdma device fail\n");\r\nbreak;\r\n};\r\niwdev->init_state = RDMA_DEV_REGISTERED;\r\niwdev->iw_status = 1;\r\ni40iw_port_ibevent(iwdev);\r\niwdev->param_wq = alloc_ordered_workqueue("l2params", WQ_MEM_RECLAIM);\r\nif(iwdev->param_wq == NULL)\r\nbreak;\r\ni40iw_pr_info("i40iw_open completed\n");\r\nreturn 0;\r\n} while (0);\r\ni40iw_pr_err("status = %d last completion = %d\n", status, iwdev->init_state);\r\ni40iw_deinit_device(iwdev, false);\r\nreturn -ERESTART;\r\n}\r\nstatic void i40iw_l2params_worker(struct work_struct *work)\r\n{\r\nstruct l2params_work *dwork =\r\ncontainer_of(work, struct l2params_work, work);\r\nstruct i40iw_device *iwdev = dwork->iwdev;\r\ni40iw_change_l2params(&iwdev->vsi, &dwork->l2params);\r\natomic_dec(&iwdev->params_busy);\r\nkfree(work);\r\n}\r\nstatic void i40iw_l2param_change(struct i40e_info *ldev, struct i40e_client *client,\r\nstruct i40e_params *params)\r\n{\r\nstruct i40iw_handler *hdl;\r\nstruct i40iw_l2params *l2params;\r\nstruct l2params_work *work;\r\nstruct i40iw_device *iwdev;\r\nint i;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn;\r\niwdev = &hdl->device;\r\nif (atomic_read(&iwdev->params_busy))\r\nreturn;\r\nwork = kzalloc(sizeof(*work), GFP_ATOMIC);\r\nif (!work)\r\nreturn;\r\natomic_inc(&iwdev->params_busy);\r\nwork->iwdev = iwdev;\r\nl2params = &work->l2params;\r\nfor (i = 0; i < I40E_CLIENT_MAX_USER_PRIORITY; i++)\r\nl2params->qs_handle_list[i] = params->qos.prio_qos[i].qs_handle;\r\nl2params->mss = (params->mtu) ? params->mtu - I40IW_MTU_TO_MSS : iwdev->vsi.mss;\r\nINIT_WORK(&work->work, i40iw_l2params_worker);\r\nqueue_work(iwdev->param_wq, &work->work);\r\n}\r\nstatic void i40iw_close(struct i40e_info *ldev, struct i40e_client *client, bool reset)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_handler *hdl;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn;\r\niwdev = &hdl->device;\r\niwdev->closing = true;\r\ni40iw_cm_disconnect_all(iwdev);\r\ndestroy_workqueue(iwdev->virtchnl_wq);\r\ni40iw_deinit_device(iwdev, reset);\r\n}\r\nstatic void i40iw_vf_reset(struct i40e_info *ldev, struct i40e_client *client, u32 vf_id)\r\n{\r\nstruct i40iw_handler *hdl;\r\nstruct i40iw_sc_dev *dev;\r\nstruct i40iw_hmc_fcn_info hmc_fcn_info;\r\nstruct i40iw_virt_mem vf_dev_mem;\r\nstruct i40iw_vfdev *tmp_vfdev;\r\nunsigned int i;\r\nunsigned long flags;\r\nstruct i40iw_device *iwdev;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn;\r\ndev = &hdl->device.sc_dev;\r\niwdev = (struct i40iw_device *)dev->back_dev;\r\nfor (i = 0; i < I40IW_MAX_PE_ENABLED_VF_COUNT; i++) {\r\nif (!dev->vf_dev[i] || (dev->vf_dev[i]->vf_id != vf_id))\r\ncontinue;\r\ntmp_vfdev = dev->vf_dev[i];\r\nspin_lock_irqsave(&iwdev->vsi.pestat->lock, flags);\r\ndev->vf_dev[i] = NULL;\r\nspin_unlock_irqrestore(&iwdev->vsi.pestat->lock, flags);\r\ni40iw_del_hmc_objects(dev, &tmp_vfdev->hmc_info, false, false);\r\nmemset(&hmc_fcn_info, 0, sizeof(hmc_fcn_info));\r\nhmc_fcn_info.vf_id = vf_id;\r\nhmc_fcn_info.iw_vf_idx = tmp_vfdev->iw_vf_idx;\r\nhmc_fcn_info.free_fcn = true;\r\ni40iw_cqp_manage_hmc_fcn_cmd(dev, &hmc_fcn_info);\r\nvf_dev_mem.va = tmp_vfdev;\r\nvf_dev_mem.size = sizeof(struct i40iw_vfdev) +\r\nsizeof(struct i40iw_hmc_obj_info) * I40IW_HMC_IW_MAX;\r\ni40iw_free_virt_mem(dev->hw, &vf_dev_mem);\r\nbreak;\r\n}\r\n}\r\nstatic void i40iw_vf_enable(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 num_vfs)\r\n{\r\nstruct i40iw_handler *hdl;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn;\r\nif (num_vfs > I40IW_MAX_PE_ENABLED_VF_COUNT)\r\nhdl->device.max_enabled_vfs = I40IW_MAX_PE_ENABLED_VF_COUNT;\r\nelse\r\nhdl->device.max_enabled_vfs = num_vfs;\r\n}\r\nstatic int i40iw_vf_capable(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 vf_id)\r\n{\r\nstruct i40iw_handler *hdl;\r\nstruct i40iw_sc_dev *dev;\r\nunsigned int i;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn 0;\r\ndev = &hdl->device.sc_dev;\r\nfor (i = 0; i < hdl->device.max_enabled_vfs; i++) {\r\nif (!dev->vf_dev[i] || (dev->vf_dev[i]->vf_id == vf_id))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i40iw_virtchnl_receive(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 vf_id,\r\nu8 *msg,\r\nu16 len)\r\n{\r\nstruct i40iw_handler *hdl;\r\nstruct i40iw_sc_dev *dev;\r\nstruct i40iw_device *iwdev;\r\nint ret_code = I40IW_NOT_SUPPORTED;\r\nif (!len || !msg)\r\nreturn I40IW_ERR_PARAM;\r\nhdl = i40iw_find_i40e_handler(ldev);\r\nif (!hdl)\r\nreturn I40IW_ERR_PARAM;\r\ndev = &hdl->device.sc_dev;\r\niwdev = dev->back_dev;\r\nif (dev->vchnl_if.vchnl_recv) {\r\nret_code = dev->vchnl_if.vchnl_recv(dev, vf_id, msg, len);\r\nif (!dev->is_pf) {\r\natomic_dec(&iwdev->vchnl_msgs);\r\nwake_up(&iwdev->vchnl_waitq);\r\n}\r\n}\r\nreturn ret_code;\r\n}\r\nbool i40iw_vf_clear_to_send(struct i40iw_sc_dev *dev)\r\n{\r\nstruct i40iw_device *iwdev;\r\nwait_queue_t wait;\r\niwdev = dev->back_dev;\r\nif (!wq_has_sleeper(&dev->vf_reqs) &&\r\n(atomic_read(&iwdev->vchnl_msgs) == 0))\r\nreturn true;\r\ninit_wait(&wait);\r\nadd_wait_queue_exclusive(&dev->vf_reqs, &wait);\r\nif (!wait_event_timeout(dev->vf_reqs,\r\n(atomic_read(&iwdev->vchnl_msgs) == 0),\r\nI40IW_VCHNL_EVENT_TIMEOUT))\r\ndev->vchnl_up = false;\r\nremove_wait_queue(&dev->vf_reqs, &wait);\r\nreturn dev->vchnl_up;\r\n}\r\nstatic enum i40iw_status_code i40iw_virtchnl_send(struct i40iw_sc_dev *dev,\r\nu32 vf_id,\r\nu8 *msg,\r\nu16 len)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40e_info *ldev;\r\nif (!dev || !dev->back_dev)\r\nreturn I40IW_ERR_BAD_PTR;\r\niwdev = dev->back_dev;\r\nldev = iwdev->ldev;\r\nif (ldev && ldev->ops && ldev->ops->virtchnl_send)\r\nreturn ldev->ops->virtchnl_send(ldev, &i40iw_client, vf_id, msg, len);\r\nreturn I40IW_ERR_BAD_PTR;\r\n}\r\nstatic int __init i40iw_init_module(void)\r\n{\r\nint ret;\r\nmemset(&i40iw_client, 0, sizeof(i40iw_client));\r\ni40iw_client.version.major = CLIENT_IW_INTERFACE_VERSION_MAJOR;\r\ni40iw_client.version.minor = CLIENT_IW_INTERFACE_VERSION_MINOR;\r\ni40iw_client.version.build = CLIENT_IW_INTERFACE_VERSION_BUILD;\r\ni40iw_client.ops = &i40e_ops;\r\nmemcpy(i40iw_client.name, i40iw_client_name, I40E_CLIENT_STR_LENGTH);\r\ni40iw_client.type = I40E_CLIENT_IWARP;\r\nspin_lock_init(&i40iw_handler_lock);\r\nret = i40e_register_client(&i40iw_client);\r\nreturn ret;\r\n}\r\nstatic void __exit i40iw_exit_module(void)\r\n{\r\ni40e_unregister_client(&i40iw_client);\r\n}
