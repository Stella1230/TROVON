static int tcf_act_police_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, police_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tcf_act_police_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a,\r\nint ovr, int bind)\r\n{\r\nint ret = 0, err;\r\nstruct nlattr *tb[TCA_POLICE_MAX + 1];\r\nstruct tc_police *parm;\r\nstruct tcf_police *police;\r\nstruct qdisc_rate_table *R_tab = NULL, *P_tab = NULL;\r\nstruct tc_action_net *tn = net_generic(net, police_net_id);\r\nbool exists = false;\r\nint size;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_POLICE_MAX, nla, police_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_POLICE_TBF] == NULL)\r\nreturn -EINVAL;\r\nsize = nla_len(tb[TCA_POLICE_TBF]);\r\nif (size != sizeof(*parm) && size != sizeof(struct tc_police_compat))\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_POLICE_TBF]);\r\nexists = tcf_hash_check(tn, parm->index, a, bind);\r\nif (exists && bind)\r\nreturn 0;\r\nif (!exists) {\r\nret = tcf_hash_create(tn, parm->index, NULL, a,\r\n&act_police_ops, bind, false);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\ntcf_hash_release(*a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\npolice = to_police(*a);\r\nif (parm->rate.rate) {\r\nerr = -ENOMEM;\r\nR_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE]);\r\nif (R_tab == NULL)\r\ngoto failure;\r\nif (parm->peakrate.rate) {\r\nP_tab = qdisc_get_rtab(&parm->peakrate,\r\ntb[TCA_POLICE_PEAKRATE]);\r\nif (P_tab == NULL)\r\ngoto failure;\r\n}\r\n}\r\nspin_lock_bh(&police->tcf_lock);\r\nif (est) {\r\nerr = gen_replace_estimator(&police->tcf_bstats, NULL,\r\n&police->tcf_rate_est,\r\n&police->tcf_lock,\r\nNULL, est);\r\nif (err)\r\ngoto failure_unlock;\r\n} else if (tb[TCA_POLICE_AVRATE] &&\r\n(ret == ACT_P_CREATED ||\r\n!gen_estimator_active(&police->tcf_rate_est))) {\r\nerr = -EINVAL;\r\ngoto failure_unlock;\r\n}\r\npolice->tcfp_mtu = parm->mtu;\r\nif (police->tcfp_mtu == 0) {\r\npolice->tcfp_mtu = ~0;\r\nif (R_tab)\r\npolice->tcfp_mtu = 255 << R_tab->rate.cell_log;\r\n}\r\nif (R_tab) {\r\npolice->rate_present = true;\r\npsched_ratecfg_precompute(&police->rate, &R_tab->rate, 0);\r\nqdisc_put_rtab(R_tab);\r\n} else {\r\npolice->rate_present = false;\r\n}\r\nif (P_tab) {\r\npolice->peak_present = true;\r\npsched_ratecfg_precompute(&police->peak, &P_tab->rate, 0);\r\nqdisc_put_rtab(P_tab);\r\n} else {\r\npolice->peak_present = false;\r\n}\r\nif (tb[TCA_POLICE_RESULT])\r\npolice->tcfp_result = nla_get_u32(tb[TCA_POLICE_RESULT]);\r\npolice->tcfp_burst = PSCHED_TICKS2NS(parm->burst);\r\npolice->tcfp_toks = police->tcfp_burst;\r\nif (police->peak_present) {\r\npolice->tcfp_mtu_ptoks = (s64) psched_l2t_ns(&police->peak,\r\npolice->tcfp_mtu);\r\npolice->tcfp_ptoks = police->tcfp_mtu_ptoks;\r\n}\r\npolice->tcf_action = parm->action;\r\nif (tb[TCA_POLICE_AVRATE])\r\npolice->tcfp_ewma_rate = nla_get_u32(tb[TCA_POLICE_AVRATE]);\r\nspin_unlock_bh(&police->tcf_lock);\r\nif (ret != ACT_P_CREATED)\r\nreturn ret;\r\npolice->tcfp_t_c = ktime_get_ns();\r\ntcf_hash_insert(tn, *a);\r\nreturn ret;\r\nfailure_unlock:\r\nspin_unlock_bh(&police->tcf_lock);\r\nfailure:\r\nqdisc_put_rtab(P_tab);\r\nqdisc_put_rtab(R_tab);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_cleanup(*a, est);\r\nreturn err;\r\n}\r\nstatic int tcf_act_police(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_police *police = to_police(a);\r\ns64 now;\r\ns64 toks;\r\ns64 ptoks = 0;\r\nspin_lock(&police->tcf_lock);\r\nbstats_update(&police->tcf_bstats, skb);\r\ntcf_lastuse_update(&police->tcf_tm);\r\nif (police->tcfp_ewma_rate) {\r\nstruct gnet_stats_rate_est64 sample;\r\nif (!gen_estimator_read(&police->tcf_rate_est, &sample) ||\r\nsample.bps >= police->tcfp_ewma_rate) {\r\npolice->tcf_qstats.overlimits++;\r\nif (police->tcf_action == TC_ACT_SHOT)\r\npolice->tcf_qstats.drops++;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcf_action;\r\n}\r\n}\r\nif (qdisc_pkt_len(skb) <= police->tcfp_mtu) {\r\nif (!police->rate_present) {\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcfp_result;\r\n}\r\nnow = ktime_get_ns();\r\ntoks = min_t(s64, now - police->tcfp_t_c,\r\npolice->tcfp_burst);\r\nif (police->peak_present) {\r\nptoks = toks + police->tcfp_ptoks;\r\nif (ptoks > police->tcfp_mtu_ptoks)\r\nptoks = police->tcfp_mtu_ptoks;\r\nptoks -= (s64) psched_l2t_ns(&police->peak,\r\nqdisc_pkt_len(skb));\r\n}\r\ntoks += police->tcfp_toks;\r\nif (toks > police->tcfp_burst)\r\ntoks = police->tcfp_burst;\r\ntoks -= (s64) psched_l2t_ns(&police->rate, qdisc_pkt_len(skb));\r\nif ((toks|ptoks) >= 0) {\r\npolice->tcfp_t_c = now;\r\npolice->tcfp_toks = toks;\r\npolice->tcfp_ptoks = ptoks;\r\nif (police->tcfp_result == TC_ACT_SHOT)\r\npolice->tcf_qstats.drops++;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcfp_result;\r\n}\r\n}\r\npolice->tcf_qstats.overlimits++;\r\nif (police->tcf_action == TC_ACT_SHOT)\r\npolice->tcf_qstats.drops++;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcf_action;\r\n}\r\nstatic int tcf_act_police_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_police *police = to_police(a);\r\nstruct tc_police opt = {\r\n.index = police->tcf_index,\r\n.action = police->tcf_action,\r\n.mtu = police->tcfp_mtu,\r\n.burst = PSCHED_NS2TICKS(police->tcfp_burst),\r\n.refcnt = police->tcf_refcnt - ref,\r\n.bindcnt = police->tcf_bindcnt - bind,\r\n};\r\nstruct tcf_t t;\r\nif (police->rate_present)\r\npsched_ratecfg_getrate(&opt.rate, &police->rate);\r\nif (police->peak_present)\r\npsched_ratecfg_getrate(&opt.peakrate, &police->peak);\r\nif (nla_put(skb, TCA_POLICE_TBF, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nif (police->tcfp_result &&\r\nnla_put_u32(skb, TCA_POLICE_RESULT, police->tcfp_result))\r\ngoto nla_put_failure;\r\nif (police->tcfp_ewma_rate &&\r\nnla_put_u32(skb, TCA_POLICE_AVRATE, police->tcfp_ewma_rate))\r\ngoto nla_put_failure;\r\nt.install = jiffies_to_clock_t(jiffies - police->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - police->tcf_tm.lastuse);\r\nt.firstuse = jiffies_to_clock_t(jiffies - police->tcf_tm.firstuse);\r\nt.expires = jiffies_to_clock_t(police->tcf_tm.expires);\r\nif (nla_put_64bit(skb, TCA_POLICE_TM, sizeof(t), &t, TCA_POLICE_PAD))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int tcf_police_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, police_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int police_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, police_net_id);\r\nreturn tc_action_net_init(tn, &act_police_ops, POL_TAB_MASK);\r\n}\r\nstatic void __net_exit police_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, police_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int __init police_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_police_ops, &police_net_ops);\r\n}\r\nstatic void __exit police_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_police_ops, &police_net_ops);\r\n}
