static const char *get_descriptor_type_string(u8 type)\r\n{\r\nswitch (type) {\r\ncase GREYBUS_TYPE_INVALID:\r\nreturn "invalid";\r\ncase GREYBUS_TYPE_STRING:\r\nreturn "string";\r\ncase GREYBUS_TYPE_INTERFACE:\r\nreturn "interface";\r\ncase GREYBUS_TYPE_CPORT:\r\nreturn "cport";\r\ncase GREYBUS_TYPE_BUNDLE:\r\nreturn "bundle";\r\ndefault:\r\nWARN_ON(1);\r\nreturn "unknown";\r\n}\r\n}\r\nstatic void release_manifest_descriptor(struct manifest_desc *descriptor)\r\n{\r\nlist_del(&descriptor->links);\r\nkfree(descriptor);\r\n}\r\nstatic void release_manifest_descriptors(struct gb_interface *intf)\r\n{\r\nstruct manifest_desc *descriptor;\r\nstruct manifest_desc *next;\r\nlist_for_each_entry_safe(descriptor, next, &intf->manifest_descs, links)\r\nrelease_manifest_descriptor(descriptor);\r\n}\r\nstatic void release_cport_descriptors(struct list_head *head, u8 bundle_id)\r\n{\r\nstruct manifest_desc *desc, *tmp;\r\nstruct greybus_descriptor_cport *desc_cport;\r\nlist_for_each_entry_safe(desc, tmp, head, links) {\r\ndesc_cport = desc->data;\r\nif (desc->type != GREYBUS_TYPE_CPORT)\r\ncontinue;\r\nif (desc_cport->bundle == bundle_id)\r\nrelease_manifest_descriptor(desc);\r\n}\r\n}\r\nstatic struct manifest_desc *get_next_bundle_desc(struct gb_interface *intf)\r\n{\r\nstruct manifest_desc *descriptor;\r\nstruct manifest_desc *next;\r\nlist_for_each_entry_safe(descriptor, next, &intf->manifest_descs, links)\r\nif (descriptor->type == GREYBUS_TYPE_BUNDLE)\r\nreturn descriptor;\r\nreturn NULL;\r\n}\r\nstatic int identify_descriptor(struct gb_interface *intf,\r\nstruct greybus_descriptor *desc, size_t size)\r\n{\r\nstruct greybus_descriptor_header *desc_header = &desc->header;\r\nstruct manifest_desc *descriptor;\r\nsize_t desc_size;\r\nsize_t expected_size;\r\nif (size < sizeof(*desc_header)) {\r\ndev_err(&intf->dev, "manifest too small (%zu < %zu)\n",\r\nsize, sizeof(*desc_header));\r\nreturn -EINVAL;\r\n}\r\ndesc_size = le16_to_cpu(desc_header->size);\r\nif (desc_size > size) {\r\ndev_err(&intf->dev, "descriptor too big (%zu > %zu)\n",\r\ndesc_size, size);\r\nreturn -EINVAL;\r\n}\r\nexpected_size = sizeof(*desc_header);\r\nswitch (desc_header->type) {\r\ncase GREYBUS_TYPE_STRING:\r\nexpected_size += sizeof(struct greybus_descriptor_string);\r\nexpected_size += desc->string.length;\r\nexpected_size = ALIGN(expected_size, 4);\r\nbreak;\r\ncase GREYBUS_TYPE_INTERFACE:\r\nexpected_size += sizeof(struct greybus_descriptor_interface);\r\nbreak;\r\ncase GREYBUS_TYPE_BUNDLE:\r\nexpected_size += sizeof(struct greybus_descriptor_bundle);\r\nbreak;\r\ncase GREYBUS_TYPE_CPORT:\r\nexpected_size += sizeof(struct greybus_descriptor_cport);\r\nbreak;\r\ncase GREYBUS_TYPE_INVALID:\r\ndefault:\r\ndev_err(&intf->dev, "invalid descriptor type (%u)\n",\r\ndesc_header->type);\r\nreturn -EINVAL;\r\n}\r\nif (desc_size < expected_size) {\r\ndev_err(&intf->dev, "%s descriptor too small (%zu < %zu)\n",\r\nget_descriptor_type_string(desc_header->type),\r\ndesc_size, expected_size);\r\nreturn -EINVAL;\r\n}\r\nif (desc_size > expected_size) {\r\ndev_warn(&intf->dev, "%s descriptor size mismatch (want %zu got %zu)\n",\r\nget_descriptor_type_string(desc_header->type),\r\nexpected_size, desc_size);\r\n}\r\ndescriptor = kzalloc(sizeof(*descriptor), GFP_KERNEL);\r\nif (!descriptor)\r\nreturn -ENOMEM;\r\ndescriptor->size = desc_size;\r\ndescriptor->data = (char *)desc + sizeof(*desc_header);\r\ndescriptor->type = desc_header->type;\r\nlist_add_tail(&descriptor->links, &intf->manifest_descs);\r\nreturn desc_size;\r\n}\r\nstatic char *gb_string_get(struct gb_interface *intf, u8 string_id)\r\n{\r\nstruct greybus_descriptor_string *desc_string;\r\nstruct manifest_desc *descriptor;\r\nbool found = false;\r\nchar *string;\r\nif (!string_id)\r\nreturn NULL;\r\nlist_for_each_entry(descriptor, &intf->manifest_descs, links) {\r\nif (descriptor->type != GREYBUS_TYPE_STRING)\r\ncontinue;\r\ndesc_string = descriptor->data;\r\nif (desc_string->id == string_id) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn ERR_PTR(-ENOENT);\r\nstring = kmemdup(&desc_string->string, desc_string->length + 1,\r\nGFP_KERNEL);\r\nif (!string)\r\nreturn ERR_PTR(-ENOMEM);\r\nstring[desc_string->length] = '\0';\r\nrelease_manifest_descriptor(descriptor);\r\nreturn string;\r\n}\r\nstatic u32 gb_manifest_parse_cports(struct gb_bundle *bundle)\r\n{\r\nstruct gb_interface *intf = bundle->intf;\r\nstruct greybus_descriptor_cport *desc_cport;\r\nstruct manifest_desc *desc, *next, *tmp;\r\nLIST_HEAD(list);\r\nu8 bundle_id = bundle->id;\r\nu16 cport_id;\r\nu32 count = 0;\r\nint i;\r\nlist_for_each_entry_safe(desc, next, &intf->manifest_descs, links) {\r\nif (desc->type != GREYBUS_TYPE_CPORT)\r\ncontinue;\r\ndesc_cport = desc->data;\r\nif (desc_cport->bundle != bundle_id)\r\ncontinue;\r\ncport_id = le16_to_cpu(desc_cport->id);\r\nif (cport_id > CPORT_ID_MAX)\r\ngoto exit;\r\nif (cport_id == GB_CONTROL_CPORT_ID) {\r\ndev_err(&bundle->dev, "invalid cport id found (%02u)\n",\r\ncport_id);\r\ngoto exit;\r\n}\r\nlist_for_each_entry(tmp, &list, links) {\r\ndesc_cport = tmp->data;\r\nif (cport_id == le16_to_cpu(desc_cport->id)) {\r\ndev_err(&bundle->dev,\r\n"duplicate CPort %u found\n",\r\ncport_id);\r\ngoto exit;\r\n}\r\n}\r\nlist_move_tail(&desc->links, &list);\r\ncount++;\r\n}\r\nif (!count)\r\nreturn 0;\r\nbundle->cport_desc = kcalloc(count, sizeof(*bundle->cport_desc),\r\nGFP_KERNEL);\r\nif (!bundle->cport_desc)\r\ngoto exit;\r\nbundle->num_cports = count;\r\ni = 0;\r\nlist_for_each_entry_safe(desc, next, &list, links) {\r\ndesc_cport = desc->data;\r\nmemcpy(&bundle->cport_desc[i++], desc_cport,\r\nsizeof(*desc_cport));\r\nrelease_manifest_descriptor(desc);\r\n}\r\nreturn count;\r\nexit:\r\nrelease_cport_descriptors(&list, bundle_id);\r\nrelease_cport_descriptors(&intf->manifest_descs, bundle_id);\r\nreturn 0;\r\n}\r\nstatic u32 gb_manifest_parse_bundles(struct gb_interface *intf)\r\n{\r\nstruct manifest_desc *desc;\r\nstruct gb_bundle *bundle;\r\nstruct gb_bundle *bundle_next;\r\nu32 count = 0;\r\nu8 bundle_id;\r\nu8 class;\r\nwhile ((desc = get_next_bundle_desc(intf))) {\r\nstruct greybus_descriptor_bundle *desc_bundle;\r\ndesc_bundle = desc->data;\r\nbundle_id = desc_bundle->id;\r\nclass = desc_bundle->class;\r\nrelease_manifest_descriptor(desc);\r\nif (bundle_id == GB_CONTROL_BUNDLE_ID) {\r\ndev_dbg(&intf->dev, "%s - ignoring control bundle\n",\r\n__func__);\r\nrelease_cport_descriptors(&intf->manifest_descs,\r\nbundle_id);\r\ncontinue;\r\n}\r\nif (class == GREYBUS_CLASS_CONTROL) {\r\ndev_err(&intf->dev,\r\n"bundle %u cannot use control class\n",\r\nbundle_id);\r\ngoto cleanup;\r\n}\r\nbundle = gb_bundle_create(intf, bundle_id, class);\r\nif (!bundle)\r\ngoto cleanup;\r\nif (!gb_manifest_parse_cports(bundle)) {\r\ngb_bundle_destroy(bundle);\r\ncontinue;\r\n}\r\ncount++;\r\n}\r\nreturn count;\r\ncleanup:\r\nlist_for_each_entry_safe(bundle, bundle_next, &intf->bundles, links) {\r\ngb_bundle_destroy(bundle);\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool gb_manifest_parse_interface(struct gb_interface *intf,\r\nstruct manifest_desc *interface_desc)\r\n{\r\nstruct greybus_descriptor_interface *desc_intf = interface_desc->data;\r\nstruct gb_control *control = intf->control;\r\nchar *str;\r\nstr = gb_string_get(intf, desc_intf->vendor_stringid);\r\nif (IS_ERR(str))\r\nreturn false;\r\ncontrol->vendor_string = str;\r\nstr = gb_string_get(intf, desc_intf->product_stringid);\r\nif (IS_ERR(str))\r\ngoto out_free_vendor_string;\r\ncontrol->product_string = str;\r\nintf->features = desc_intf->features;\r\nrelease_manifest_descriptor(interface_desc);\r\nif (!gb_manifest_parse_bundles(intf)) {\r\ndev_err(&intf->dev, "manifest bundle descriptors not valid\n");\r\ngoto out_err;\r\n}\r\nreturn true;\r\nout_err:\r\nkfree(control->product_string);\r\ncontrol->product_string = NULL;\r\nout_free_vendor_string:\r\nkfree(control->vendor_string);\r\ncontrol->vendor_string = NULL;\r\nreturn false;\r\n}\r\nbool gb_manifest_parse(struct gb_interface *intf, void *data, size_t size)\r\n{\r\nstruct greybus_manifest *manifest;\r\nstruct greybus_manifest_header *header;\r\nstruct greybus_descriptor *desc;\r\nstruct manifest_desc *descriptor;\r\nstruct manifest_desc *interface_desc = NULL;\r\nu16 manifest_size;\r\nu32 found = 0;\r\nbool result;\r\nif (WARN_ON(!list_empty(&intf->manifest_descs)))\r\nreturn false;\r\nif (size < sizeof(*header)) {\r\ndev_err(&intf->dev, "short manifest (%zu < %zu)\n",\r\nsize, sizeof(*header));\r\nreturn false;\r\n}\r\nmanifest = data;\r\nheader = &manifest->header;\r\nmanifest_size = le16_to_cpu(header->size);\r\nif (manifest_size != size) {\r\ndev_err(&intf->dev, "manifest size mismatch (%zu != %u)\n",\r\nsize, manifest_size);\r\nreturn false;\r\n}\r\nif (header->version_major > GREYBUS_VERSION_MAJOR) {\r\ndev_err(&intf->dev, "manifest version too new (%u.%u > %u.%u)\n",\r\nheader->version_major, header->version_minor,\r\nGREYBUS_VERSION_MAJOR, GREYBUS_VERSION_MINOR);\r\nreturn false;\r\n}\r\ndesc = manifest->descriptors;\r\nsize -= sizeof(*header);\r\nwhile (size) {\r\nint desc_size;\r\ndesc_size = identify_descriptor(intf, desc, size);\r\nif (desc_size < 0) {\r\nresult = false;\r\ngoto out;\r\n}\r\ndesc = (struct greybus_descriptor *)((char *)desc + desc_size);\r\nsize -= desc_size;\r\n}\r\nlist_for_each_entry(descriptor, &intf->manifest_descs, links) {\r\nif (descriptor->type == GREYBUS_TYPE_INTERFACE)\r\nif (!found++)\r\ninterface_desc = descriptor;\r\n}\r\nif (found != 1) {\r\ndev_err(&intf->dev, "manifest must have 1 interface descriptor (%u found)\n",\r\nfound);\r\nresult = false;\r\ngoto out;\r\n}\r\nresult = gb_manifest_parse_interface(intf, interface_desc);\r\nif (result && !list_empty(&intf->manifest_descs))\r\ndev_info(&intf->dev, "excess descriptors in interface manifest\n");\r\nout:\r\nrelease_manifest_descriptors(intf);\r\nreturn result;\r\n}
