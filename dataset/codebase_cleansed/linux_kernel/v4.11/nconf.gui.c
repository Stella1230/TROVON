static void set_normal_colors(void)\r\n{\r\ninit_pair(NORMAL, -1, -1);\r\ninit_pair(MAIN_HEADING, COLOR_MAGENTA, -1);\r\ninit_pair(MAIN_MENU_FORE, -1, -1);\r\ninit_pair(MAIN_MENU_BACK, -1, -1);\r\ninit_pair(MAIN_MENU_GREY, -1, -1);\r\ninit_pair(MAIN_MENU_HEADING, COLOR_GREEN, -1);\r\ninit_pair(MAIN_MENU_BOX, COLOR_YELLOW, -1);\r\ninit_pair(SCROLLWIN_TEXT, -1, -1);\r\ninit_pair(SCROLLWIN_HEADING, COLOR_GREEN, -1);\r\ninit_pair(SCROLLWIN_BOX, COLOR_YELLOW, -1);\r\ninit_pair(DIALOG_TEXT, -1, -1);\r\ninit_pair(DIALOG_BOX, COLOR_YELLOW, -1);\r\ninit_pair(DIALOG_MENU_BACK, COLOR_YELLOW, -1);\r\ninit_pair(DIALOG_MENU_FORE, COLOR_RED, -1);\r\ninit_pair(INPUT_BOX, COLOR_YELLOW, -1);\r\ninit_pair(INPUT_HEADING, COLOR_GREEN, -1);\r\ninit_pair(INPUT_TEXT, -1, -1);\r\ninit_pair(INPUT_FIELD, -1, -1);\r\ninit_pair(FUNCTION_HIGHLIGHT, -1, -1);\r\ninit_pair(FUNCTION_TEXT, COLOR_YELLOW, -1);\r\n}\r\nstatic void normal_color_theme(void)\r\n{\r\n#define mkattr(name, attr) do { \\r\nattributes[name] = attr | COLOR_PAIR(name); } while (0)\r\nmkattr(NORMAL, NORMAL);\r\nmkattr(MAIN_HEADING, A_BOLD | A_UNDERLINE);\r\nmkattr(MAIN_MENU_FORE, A_REVERSE);\r\nmkattr(MAIN_MENU_BACK, A_NORMAL);\r\nmkattr(MAIN_MENU_GREY, A_NORMAL);\r\nmkattr(MAIN_MENU_HEADING, A_BOLD);\r\nmkattr(MAIN_MENU_BOX, A_NORMAL);\r\nmkattr(SCROLLWIN_TEXT, A_NORMAL);\r\nmkattr(SCROLLWIN_HEADING, A_BOLD);\r\nmkattr(SCROLLWIN_BOX, A_BOLD);\r\nmkattr(DIALOG_TEXT, A_BOLD);\r\nmkattr(DIALOG_BOX, A_BOLD);\r\nmkattr(DIALOG_MENU_FORE, A_STANDOUT);\r\nmkattr(DIALOG_MENU_BACK, A_NORMAL);\r\nmkattr(INPUT_BOX, A_NORMAL);\r\nmkattr(INPUT_HEADING, A_BOLD);\r\nmkattr(INPUT_TEXT, A_NORMAL);\r\nmkattr(INPUT_FIELD, A_UNDERLINE);\r\nmkattr(FUNCTION_HIGHLIGHT, A_BOLD);\r\nmkattr(FUNCTION_TEXT, A_REVERSE);\r\n}\r\nstatic void no_colors_theme(void)\r\n{\r\n#define mkattrn(name, attr) { attributes[name] = attr; }\r\nmkattrn(NORMAL, NORMAL);\r\nmkattrn(MAIN_HEADING, A_BOLD | A_UNDERLINE);\r\nmkattrn(MAIN_MENU_FORE, A_STANDOUT);\r\nmkattrn(MAIN_MENU_BACK, A_NORMAL);\r\nmkattrn(MAIN_MENU_GREY, A_NORMAL);\r\nmkattrn(MAIN_MENU_HEADING, A_BOLD);\r\nmkattrn(MAIN_MENU_BOX, A_NORMAL);\r\nmkattrn(SCROLLWIN_TEXT, A_NORMAL);\r\nmkattrn(SCROLLWIN_HEADING, A_BOLD);\r\nmkattrn(SCROLLWIN_BOX, A_BOLD);\r\nmkattrn(DIALOG_TEXT, A_NORMAL);\r\nmkattrn(DIALOG_BOX, A_BOLD);\r\nmkattrn(DIALOG_MENU_FORE, A_STANDOUT);\r\nmkattrn(DIALOG_MENU_BACK, A_NORMAL);\r\nmkattrn(INPUT_BOX, A_BOLD);\r\nmkattrn(INPUT_HEADING, A_BOLD);\r\nmkattrn(INPUT_TEXT, A_NORMAL);\r\nmkattrn(INPUT_FIELD, A_UNDERLINE);\r\nmkattrn(FUNCTION_HIGHLIGHT, A_BOLD);\r\nmkattrn(FUNCTION_TEXT, A_REVERSE);\r\n}\r\nvoid set_colors()\r\n{\r\nstart_color();\r\nuse_default_colors();\r\nset_normal_colors();\r\nif (has_colors()) {\r\nnormal_color_theme();\r\n} else {\r\nno_colors_theme();\r\n}\r\n}\r\nvoid print_in_middle(WINDOW *win,\r\nint starty,\r\nint startx,\r\nint width,\r\nconst char *string,\r\nchtype color)\r\n{ int length, x, y;\r\nfloat temp;\r\nif (win == NULL)\r\nwin = stdscr;\r\ngetyx(win, y, x);\r\nif (startx != 0)\r\nx = startx;\r\nif (starty != 0)\r\ny = starty;\r\nif (width == 0)\r\nwidth = 80;\r\nlength = strlen(string);\r\ntemp = (width - length) / 2;\r\nx = startx + (int)temp;\r\n(void) wattrset(win, color);\r\nmvwprintw(win, y, x, "%s", string);\r\nrefresh();\r\n}\r\nint get_line_no(const char *text)\r\n{\r\nint i;\r\nint total = 1;\r\nif (!text)\r\nreturn 0;\r\nfor (i = 0; text[i] != '\0'; i++)\r\nif (text[i] == '\n')\r\ntotal++;\r\nreturn total;\r\n}\r\nconst char *get_line(const char *text, int line_no)\r\n{\r\nint i;\r\nint lines = 0;\r\nif (!text)\r\nreturn 0;\r\nfor (i = 0; text[i] != '\0' && lines < line_no; i++)\r\nif (text[i] == '\n')\r\nlines++;\r\nreturn text+i;\r\n}\r\nint get_line_length(const char *line)\r\n{\r\nint res = 0;\r\nwhile (*line != '\0' && *line != '\n') {\r\nline++;\r\nres++;\r\n}\r\nreturn res;\r\n}\r\nvoid fill_window(WINDOW *win, const char *text)\r\n{\r\nint x, y;\r\nint total_lines = get_line_no(text);\r\nint i;\r\ngetmaxyx(win, y, x);\r\ntotal_lines = min(total_lines, y);\r\nfor (i = 0; i < total_lines; i++) {\r\nchar tmp[x+10];\r\nconst char *line = get_line(text, i);\r\nint len = get_line_length(line);\r\nstrncpy(tmp, line, min(len, x));\r\ntmp[len] = '\0';\r\nmvwprintw(win, i, 0, "%s", tmp);\r\n}\r\n}\r\nint btn_dialog(WINDOW *main_window, const char *msg, int btn_num, ...)\r\n{\r\nva_list ap;\r\nchar *btn;\r\nint btns_width = 0;\r\nint msg_lines = 0;\r\nint msg_width = 0;\r\nint total_width;\r\nint win_rows = 0;\r\nWINDOW *win;\r\nWINDOW *msg_win;\r\nWINDOW *menu_win;\r\nMENU *menu;\r\nITEM *btns[btn_num+1];\r\nint i, x, y;\r\nint res = -1;\r\nva_start(ap, btn_num);\r\nfor (i = 0; i < btn_num; i++) {\r\nbtn = va_arg(ap, char *);\r\nbtns[i] = new_item(btn, "");\r\nbtns_width += strlen(btn)+1;\r\n}\r\nva_end(ap);\r\nbtns[btn_num] = NULL;\r\nmsg_lines = get_line_no(msg);\r\nfor (i = 0; i < msg_lines; i++) {\r\nconst char *line = get_line(msg, i);\r\nint len = get_line_length(line);\r\nif (msg_width < len)\r\nmsg_width = len;\r\n}\r\ntotal_width = max(msg_width, btns_width);\r\ny = (getmaxy(stdscr)-(msg_lines+4))/2;\r\nx = (getmaxx(stdscr)-(total_width+4))/2;\r\nif (btn_num > 0)\r\nwin_rows = msg_lines+4;\r\nelse\r\nwin_rows = msg_lines+2;\r\nwin = newwin(win_rows, total_width+4, y, x);\r\nkeypad(win, TRUE);\r\nmenu_win = derwin(win, 1, btns_width, win_rows-2,\r\n1+(total_width+2-btns_width)/2);\r\nmenu = new_menu(btns);\r\nmsg_win = derwin(win, win_rows-2, msg_width, 1,\r\n1+(total_width+2-msg_width)/2);\r\nset_menu_fore(menu, attributes[DIALOG_MENU_FORE]);\r\nset_menu_back(menu, attributes[DIALOG_MENU_BACK]);\r\n(void) wattrset(win, attributes[DIALOG_BOX]);\r\nbox(win, 0, 0);\r\n(void) wattrset(msg_win, attributes[DIALOG_TEXT]);\r\nfill_window(msg_win, msg);\r\nset_menu_win(menu, win);\r\nset_menu_sub(menu, menu_win);\r\nset_menu_format(menu, 1, btn_num);\r\nmenu_opts_off(menu, O_SHOWDESC);\r\nmenu_opts_off(menu, O_SHOWMATCH);\r\nmenu_opts_on(menu, O_ONEVALUE);\r\nmenu_opts_on(menu, O_NONCYCLIC);\r\nset_menu_mark(menu, "");\r\npost_menu(menu);\r\ntouchwin(win);\r\nrefresh_all_windows(main_window);\r\nwhile ((res = wgetch(win))) {\r\nswitch (res) {\r\ncase KEY_LEFT:\r\nmenu_driver(menu, REQ_LEFT_ITEM);\r\nbreak;\r\ncase KEY_RIGHT:\r\nmenu_driver(menu, REQ_RIGHT_ITEM);\r\nbreak;\r\ncase 10:\r\ncase 27:\r\ncase ' ':\r\ncase KEY_F(F_BACK):\r\ncase KEY_F(F_EXIT):\r\nbreak;\r\n}\r\ntouchwin(win);\r\nrefresh_all_windows(main_window);\r\nif (res == 10 || res == ' ') {\r\nres = item_index(current_item(menu));\r\nbreak;\r\n} else if (res == 27 || res == KEY_F(F_BACK) ||\r\nres == KEY_F(F_EXIT)) {\r\nres = KEY_EXIT;\r\nbreak;\r\n}\r\n}\r\nunpost_menu(menu);\r\nfree_menu(menu);\r\nfor (i = 0; i < btn_num; i++)\r\nfree_item(btns[i]);\r\ndelwin(win);\r\nreturn res;\r\n}\r\nint dialog_inputbox(WINDOW *main_window,\r\nconst char *title, const char *prompt,\r\nconst char *init, char **resultp, int *result_len)\r\n{\r\nint prompt_lines = 0;\r\nint prompt_width = 0;\r\nWINDOW *win;\r\nWINDOW *prompt_win;\r\nWINDOW *form_win;\r\nPANEL *panel;\r\nint i, x, y, lines, columns, win_lines, win_cols;\r\nint res = -1;\r\nint cursor_position = strlen(init);\r\nint cursor_form_win;\r\nchar *result = *resultp;\r\ngetmaxyx(stdscr, lines, columns);\r\nif (strlen(init)+1 > *result_len) {\r\n*result_len = strlen(init)+1;\r\n*resultp = result = realloc(result, *result_len);\r\n}\r\nprompt_lines = get_line_no(prompt);\r\nfor (i = 0; i < prompt_lines; i++) {\r\nconst char *line = get_line(prompt, i);\r\nint len = get_line_length(line);\r\nprompt_width = max(prompt_width, len);\r\n}\r\nif (title)\r\nprompt_width = max(prompt_width, strlen(title));\r\nwin_lines = min(prompt_lines+6, lines-2);\r\nwin_cols = min(prompt_width+7, columns-2);\r\nprompt_lines = max(win_lines-6, 0);\r\nprompt_width = max(win_cols-7, 0);\r\ny = (lines-win_lines)/2;\r\nx = (columns-win_cols)/2;\r\nstrncpy(result, init, *result_len);\r\nwin = newwin(win_lines, win_cols, y, x);\r\nprompt_win = derwin(win, prompt_lines+1, prompt_width, 2, 2);\r\nform_win = derwin(win, 1, prompt_width, prompt_lines+3, 2);\r\nkeypad(form_win, TRUE);\r\n(void) wattrset(form_win, attributes[INPUT_FIELD]);\r\n(void) wattrset(win, attributes[INPUT_BOX]);\r\nbox(win, 0, 0);\r\n(void) wattrset(win, attributes[INPUT_HEADING]);\r\nif (title)\r\nmvwprintw(win, 0, 3, "%s", title);\r\n(void) wattrset(prompt_win, attributes[INPUT_TEXT]);\r\nfill_window(prompt_win, prompt);\r\nmvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");\r\ncursor_form_win = min(cursor_position, prompt_width-1);\r\nmvwprintw(form_win, 0, 0, "%s",\r\nresult + cursor_position-cursor_form_win);\r\npanel = new_panel(win);\r\ncurs_set(1);\r\ntouchwin(win);\r\nrefresh_all_windows(main_window);\r\nwhile ((res = wgetch(form_win))) {\r\nint len = strlen(result);\r\nswitch (res) {\r\ncase 10:\r\ncase 27:\r\ncase KEY_F(F_HELP):\r\ncase KEY_F(F_EXIT):\r\ncase KEY_F(F_BACK):\r\nbreak;\r\ncase 127:\r\ncase KEY_BACKSPACE:\r\nif (cursor_position > 0) {\r\nmemmove(&result[cursor_position-1],\r\n&result[cursor_position],\r\nlen-cursor_position+1);\r\ncursor_position--;\r\ncursor_form_win--;\r\nlen--;\r\n}\r\nbreak;\r\ncase KEY_DC:\r\nif (cursor_position >= 0 && cursor_position < len) {\r\nmemmove(&result[cursor_position],\r\n&result[cursor_position+1],\r\nlen-cursor_position+1);\r\nlen--;\r\n}\r\nbreak;\r\ncase KEY_UP:\r\ncase KEY_RIGHT:\r\nif (cursor_position < len) {\r\ncursor_position++;\r\ncursor_form_win++;\r\n}\r\nbreak;\r\ncase KEY_DOWN:\r\ncase KEY_LEFT:\r\nif (cursor_position > 0) {\r\ncursor_position--;\r\ncursor_form_win--;\r\n}\r\nbreak;\r\ncase KEY_HOME:\r\ncursor_position = 0;\r\ncursor_form_win = 0;\r\nbreak;\r\ncase KEY_END:\r\ncursor_position = len;\r\ncursor_form_win = min(cursor_position, prompt_width-1);\r\nbreak;\r\ndefault:\r\nif ((isgraph(res) || isspace(res))) {\r\nif (len+2 > *result_len) {\r\n*result_len = len+2;\r\n*resultp = result = realloc(result,\r\n*result_len);\r\n}\r\nmemmove(&result[cursor_position+1],\r\n&result[cursor_position],\r\nlen-cursor_position+1);\r\nresult[cursor_position] = res;\r\ncursor_position++;\r\ncursor_form_win++;\r\nlen++;\r\n} else {\r\nmvprintw(0, 0, "unknown key: %d\n", res);\r\n}\r\nbreak;\r\n}\r\nif (cursor_form_win < 0)\r\ncursor_form_win = 0;\r\nelse if (cursor_form_win > prompt_width-1)\r\ncursor_form_win = prompt_width-1;\r\nwmove(form_win, 0, 0);\r\nwclrtoeol(form_win);\r\nmvwprintw(form_win, 0, 0, "%*s", prompt_width, " ");\r\nmvwprintw(form_win, 0, 0, "%s",\r\nresult + cursor_position-cursor_form_win);\r\nwmove(form_win, 0, cursor_form_win);\r\ntouchwin(win);\r\nrefresh_all_windows(main_window);\r\nif (res == 10) {\r\nres = 0;\r\nbreak;\r\n} else if (res == 27 || res == KEY_F(F_BACK) ||\r\nres == KEY_F(F_EXIT)) {\r\nres = KEY_EXIT;\r\nbreak;\r\n} else if (res == KEY_F(F_HELP)) {\r\nres = 1;\r\nbreak;\r\n}\r\n}\r\ncurs_set(0);\r\ndel_panel(panel);\r\ndelwin(prompt_win);\r\ndelwin(form_win);\r\ndelwin(win);\r\nreturn res;\r\n}\r\nvoid refresh_all_windows(WINDOW *main_window)\r\n{\r\nupdate_panels();\r\ntouchwin(main_window);\r\nrefresh();\r\n}\r\nvoid show_scroll_win(WINDOW *main_window,\r\nconst char *title,\r\nconst char *text)\r\n{\r\nint res;\r\nint total_lines = get_line_no(text);\r\nint x, y, lines, columns;\r\nint start_x = 0, start_y = 0;\r\nint text_lines = 0, text_cols = 0;\r\nint total_cols = 0;\r\nint win_cols = 0;\r\nint win_lines = 0;\r\nint i = 0;\r\nWINDOW *win;\r\nWINDOW *pad;\r\nPANEL *panel;\r\ngetmaxyx(stdscr, lines, columns);\r\ntotal_lines = get_line_no(text);\r\nfor (i = 0; i < total_lines; i++) {\r\nconst char *line = get_line(text, i);\r\nint len = get_line_length(line);\r\ntotal_cols = max(total_cols, len+2);\r\n}\r\npad = newpad(total_lines+10, total_cols+10);\r\n(void) wattrset(pad, attributes[SCROLLWIN_TEXT]);\r\nfill_window(pad, text);\r\nwin_lines = min(total_lines+4, lines-2);\r\nwin_cols = min(total_cols+2, columns-2);\r\ntext_lines = max(win_lines-4, 0);\r\ntext_cols = max(win_cols-2, 0);\r\ny = (lines-win_lines)/2;\r\nx = (columns-win_cols)/2;\r\nwin = newwin(win_lines, win_cols, y, x);\r\nkeypad(win, TRUE);\r\n(void) wattrset(win, attributes[SCROLLWIN_BOX]);\r\nbox(win, 0, 0);\r\n(void) wattrset(win, attributes[SCROLLWIN_HEADING]);\r\nmvwprintw(win, 0, 3, " %s ", title);\r\npanel = new_panel(win);\r\ndo {\r\ncopywin(pad, win, start_y, start_x, 2, 2, text_lines,\r\ntext_cols, 0);\r\nprint_in_middle(win,\r\ntext_lines+2,\r\n0,\r\ntext_cols,\r\n"<OK>",\r\nattributes[DIALOG_MENU_FORE]);\r\nwrefresh(win);\r\nres = wgetch(win);\r\nswitch (res) {\r\ncase KEY_NPAGE:\r\ncase ' ':\r\ncase 'd':\r\nstart_y += text_lines-2;\r\nbreak;\r\ncase KEY_PPAGE:\r\ncase 'u':\r\nstart_y -= text_lines+2;\r\nbreak;\r\ncase KEY_HOME:\r\nstart_y = 0;\r\nbreak;\r\ncase KEY_END:\r\nstart_y = total_lines-text_lines;\r\nbreak;\r\ncase KEY_DOWN:\r\ncase 'j':\r\nstart_y++;\r\nbreak;\r\ncase KEY_UP:\r\ncase 'k':\r\nstart_y--;\r\nbreak;\r\ncase KEY_LEFT:\r\ncase 'h':\r\nstart_x--;\r\nbreak;\r\ncase KEY_RIGHT:\r\ncase 'l':\r\nstart_x++;\r\nbreak;\r\n}\r\nif (res == 10 || res == 27 || res == 'q' ||\r\nres == KEY_F(F_HELP) || res == KEY_F(F_BACK) ||\r\nres == KEY_F(F_EXIT))\r\nbreak;\r\nif (start_y < 0)\r\nstart_y = 0;\r\nif (start_y >= total_lines-text_lines)\r\nstart_y = total_lines-text_lines;\r\nif (start_x < 0)\r\nstart_x = 0;\r\nif (start_x >= total_cols-text_cols)\r\nstart_x = total_cols-text_cols;\r\n} while (res);\r\ndel_panel(panel);\r\ndelwin(win);\r\nrefresh_all_windows(main_window);\r\n}
