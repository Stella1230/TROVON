static inline struct ps8622_bridge *\r\nbridge_to_ps8622(struct drm_bridge *bridge)\r\n{\r\nreturn container_of(bridge, struct ps8622_bridge, bridge);\r\n}\r\nstatic inline struct ps8622_bridge *\r\nconnector_to_ps8622(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct ps8622_bridge, connector);\r\n}\r\nstatic int ps8622_set(struct i2c_client *client, u8 page, u8 reg, u8 val)\r\n{\r\nint ret;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nu8 data[] = {reg, val};\r\nmsg.addr = client->addr + page;\r\nmsg.flags = 0;\r\nmsg.len = sizeof(data);\r\nmsg.buf = data;\r\nret = i2c_transfer(adap, &msg, 1);\r\nif (ret != 1)\r\npr_warn("PS8622 I2C write (0x%02x,0x%02x,0x%02x) failed: %d\n",\r\nclient->addr + page, reg, val, ret);\r\nreturn !(ret == 1);\r\n}\r\nstatic int ps8622_send_config(struct ps8622_bridge *ps8622)\r\n{\r\nstruct i2c_client *cl = ps8622->client;\r\nint err = 0;\r\nerr = ps8622_set(cl, 0x02, 0xa1, 0x01);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x14, 0x01);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0xe3, 0x20);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0xe2, 0x80);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x8a, 0x0c);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x89, 0x08);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x71, 0x2d);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x7d, 0x07);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x7b, 0x00);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x7a, 0xfd);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0xc0, 0x12);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0xc1, 0x92);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0xc2, 0x1c);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x32, 0x80);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x00, 0xb0);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x15, 0x40);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x54, 0x10);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0x02, 0x80 | ps8622->max_lane_count);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0x21, 0x80 | ps8622->lane_count);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0x52, 0x20);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0xf1, 0x03);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0x62, 0x41);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0xf6, 0x01);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0x77, 0x06);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x00, 0x4c, 0x04);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc0, 0x00);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc1, 0x1c);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc2, 0xf8);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc3, 0x44);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc4, 0x32);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc5, 0x53);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc6, 0x4c);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc7, 0x56);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xc8, 0x35);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xca, 0x01);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xcb, 0x05);\r\nif (err)\r\ngoto error;\r\nif (ps8622->bl) {\r\nerr = ps8622_set(cl, 0x01, 0xa5, 0xa0);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x01, 0xa7,\r\nps8622->bl->props.brightness);\r\nif (err)\r\ngoto error;\r\n} else {\r\nerr = ps8622_set(cl, 0x01, 0xa5, 0x80);\r\nif (err)\r\ngoto error;\r\n}\r\nerr = ps8622_set(cl, 0x01, 0xcc, 0x13);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x02, 0xb1, 0x20);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x10, 0x16);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x59, 0x60);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x04, 0x54, 0x14);\r\nif (err)\r\ngoto error;\r\nerr = ps8622_set(cl, 0x02, 0xa1, 0x91);\r\nerror:\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int ps8622_backlight_update(struct backlight_device *bl)\r\n{\r\nstruct ps8622_bridge *ps8622 = dev_get_drvdata(&bl->dev);\r\nint ret, brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK ||\r\nbl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nif (!ps8622->enabled)\r\nreturn -EINVAL;\r\nret = ps8622_set(ps8622->client, 0x01, 0xa7, brightness);\r\nreturn ret;\r\n}\r\nstatic void ps8622_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\r\nint ret;\r\nif (ps8622->enabled)\r\nreturn;\r\ngpiod_set_value(ps8622->gpio_rst, 0);\r\nif (ps8622->v12) {\r\nret = regulator_enable(ps8622->v12);\r\nif (ret)\r\nDRM_ERROR("fails to enable ps8622->v12");\r\n}\r\nif (drm_panel_prepare(ps8622->panel)) {\r\nDRM_ERROR("failed to prepare panel\n");\r\nreturn;\r\n}\r\ngpiod_set_value(ps8622->gpio_slp, 1);\r\nusleep_range(PS8622_RST_HIGH_T2_MIN_US + PS8622_POWER_RISE_T1_MAX_US,\r\nPS8622_RST_HIGH_T2_MAX_US + PS8622_POWER_RISE_T1_MIN_US);\r\ngpiod_set_value(ps8622->gpio_rst, 1);\r\nusleep_range(20000, 30000);\r\nret = ps8622_send_config(ps8622);\r\nif (ret) {\r\nDRM_ERROR("Failed to send config to bridge (%d)\n", ret);\r\nreturn;\r\n}\r\nps8622->enabled = true;\r\n}\r\nstatic void ps8622_enable(struct drm_bridge *bridge)\r\n{\r\nstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\r\nif (drm_panel_enable(ps8622->panel)) {\r\nDRM_ERROR("failed to enable panel\n");\r\nreturn;\r\n}\r\n}\r\nstatic void ps8622_disable(struct drm_bridge *bridge)\r\n{\r\nstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\r\nif (drm_panel_disable(ps8622->panel)) {\r\nDRM_ERROR("failed to disable panel\n");\r\nreturn;\r\n}\r\nmsleep(PS8622_PWMO_END_T12_MS);\r\n}\r\nstatic void ps8622_post_disable(struct drm_bridge *bridge)\r\n{\r\nstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\r\nif (!ps8622->enabled)\r\nreturn;\r\nps8622->enabled = false;\r\ngpiod_set_value(ps8622->gpio_slp, 0);\r\nif (drm_panel_unprepare(ps8622->panel)) {\r\nDRM_ERROR("failed to unprepare panel\n");\r\nreturn;\r\n}\r\nif (ps8622->v12)\r\nregulator_disable(ps8622->v12);\r\nusleep_range(PS8622_POWER_FALL_T16_MAX_US,\r\n2 * PS8622_POWER_FALL_T16_MAX_US);\r\ngpiod_set_value(ps8622->gpio_rst, 0);\r\nmsleep(PS8622_POWER_OFF_T17_MS);\r\n}\r\nstatic int ps8622_get_modes(struct drm_connector *connector)\r\n{\r\nstruct ps8622_bridge *ps8622;\r\nps8622 = connector_to_ps8622(connector);\r\nreturn drm_panel_get_modes(ps8622->panel);\r\n}\r\nstatic int ps8622_attach(struct drm_bridge *bridge)\r\n{\r\nstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\r\nint ret;\r\nif (!bridge->encoder) {\r\nDRM_ERROR("Parent encoder object not found");\r\nreturn -ENODEV;\r\n}\r\nps8622->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(bridge->dev, &ps8622->connector,\r\n&ps8622_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(&ps8622->connector,\r\n&ps8622_connector_helper_funcs);\r\ndrm_connector_register(&ps8622->connector);\r\ndrm_mode_connector_attach_encoder(&ps8622->connector,\r\nbridge->encoder);\r\nif (ps8622->panel)\r\ndrm_panel_attach(ps8622->panel, &ps8622->connector);\r\ndrm_helper_hpd_irq_event(ps8622->connector.dev);\r\nreturn ret;\r\n}\r\nstatic int ps8622_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device_node *endpoint, *panel_node;\r\nstruct ps8622_bridge *ps8622;\r\nint ret;\r\nps8622 = devm_kzalloc(dev, sizeof(*ps8622), GFP_KERNEL);\r\nif (!ps8622)\r\nreturn -ENOMEM;\r\nendpoint = of_graph_get_next_endpoint(dev->of_node, NULL);\r\nif (endpoint) {\r\npanel_node = of_graph_get_remote_port_parent(endpoint);\r\nif (panel_node) {\r\nps8622->panel = of_drm_find_panel(panel_node);\r\nof_node_put(panel_node);\r\nif (!ps8622->panel)\r\nreturn -EPROBE_DEFER;\r\n}\r\n}\r\nps8622->client = client;\r\nps8622->v12 = devm_regulator_get(dev, "vdd12");\r\nif (IS_ERR(ps8622->v12)) {\r\ndev_info(dev, "no 1.2v regulator found for PS8622\n");\r\nps8622->v12 = NULL;\r\n}\r\nps8622->gpio_slp = devm_gpiod_get(dev, "sleep", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ps8622->gpio_slp)) {\r\nret = PTR_ERR(ps8622->gpio_slp);\r\ndev_err(dev, "cannot get gpio_slp %d\n", ret);\r\nreturn ret;\r\n}\r\nps8622->gpio_rst = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ps8622->gpio_rst)) {\r\nret = PTR_ERR(ps8622->gpio_rst);\r\ndev_err(dev, "cannot get gpio_rst %d\n", ret);\r\nreturn ret;\r\n}\r\nps8622->max_lane_count = id->driver_data;\r\nif (of_property_read_u32(dev->of_node, "lane-count",\r\n&ps8622->lane_count)) {\r\nps8622->lane_count = ps8622->max_lane_count;\r\n} else if (ps8622->lane_count > ps8622->max_lane_count) {\r\ndev_info(dev, "lane-count property is too high,"\r\n"using max_lane_count\n");\r\nps8622->lane_count = ps8622->max_lane_count;\r\n}\r\nif (!of_find_property(dev->of_node, "use-external-pwm", NULL)) {\r\nps8622->bl = backlight_device_register("ps8622-backlight",\r\ndev, ps8622, &ps8622_backlight_ops,\r\nNULL);\r\nif (IS_ERR(ps8622->bl)) {\r\nDRM_ERROR("failed to register backlight\n");\r\nret = PTR_ERR(ps8622->bl);\r\nps8622->bl = NULL;\r\nreturn ret;\r\n}\r\nps8622->bl->props.max_brightness = PS8622_MAX_BRIGHTNESS;\r\nps8622->bl->props.brightness = PS8622_MAX_BRIGHTNESS;\r\n}\r\nps8622->bridge.funcs = &ps8622_bridge_funcs;\r\nps8622->bridge.of_node = dev->of_node;\r\nret = drm_bridge_add(&ps8622->bridge);\r\nif (ret) {\r\nDRM_ERROR("Failed to add bridge\n");\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, ps8622);\r\nreturn 0;\r\n}\r\nstatic int ps8622_remove(struct i2c_client *client)\r\n{\r\nstruct ps8622_bridge *ps8622 = i2c_get_clientdata(client);\r\nbacklight_device_unregister(ps8622->bl);\r\ndrm_bridge_remove(&ps8622->bridge);\r\nreturn 0;\r\n}
