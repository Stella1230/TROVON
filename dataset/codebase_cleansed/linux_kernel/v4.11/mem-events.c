char *perf_mem_events__name(int i)\r\n{\r\nif (i == PERF_MEM_EVENTS__LOAD) {\r\nif (!mem_loads_name__init) {\r\nmem_loads_name__init = true;\r\nscnprintf(mem_loads_name, sizeof(mem_loads_name),\r\nperf_mem_events[i].name,\r\nperf_mem_events__loads_ldlat);\r\n}\r\nreturn mem_loads_name;\r\n}\r\nreturn (char *)perf_mem_events[i].name;\r\n}\r\nint perf_mem_events__parse(const char *str)\r\n{\r\nchar *tok, *saveptr = NULL;\r\nbool found = false;\r\nchar *buf;\r\nint j;\r\nbuf = malloc(strlen(str) + 1);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nstrcpy(buf, str);\r\ntok = strtok_r((char *)buf, ",", &saveptr);\r\nwhile (tok) {\r\nfor (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\r\nstruct perf_mem_event *e = &perf_mem_events[j];\r\nif (strstr(e->tag, tok))\r\ne->record = found = true;\r\n}\r\ntok = strtok_r(NULL, ",", &saveptr);\r\n}\r\nfree(buf);\r\nif (found)\r\nreturn 0;\r\npr_err("failed: event '%s' not found, use '-e list' to get list of available events\n", str);\r\nreturn -1;\r\n}\r\nint perf_mem_events__init(void)\r\n{\r\nconst char *mnt = sysfs__mount();\r\nbool found = false;\r\nint j;\r\nif (!mnt)\r\nreturn -ENOENT;\r\nfor (j = 0; j < PERF_MEM_EVENTS__MAX; j++) {\r\nchar path[PATH_MAX];\r\nstruct perf_mem_event *e = &perf_mem_events[j];\r\nstruct stat st;\r\nscnprintf(path, PATH_MAX, "%s/devices/cpu/events/%s",\r\nmnt, e->sysfs_name);\r\nif (!stat(path, &st))\r\ne->supported = found = true;\r\n}\r\nreturn found ? 0 : -ENOENT;\r\n}\r\nint perf_mem__tlb_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\r\n{\r\nsize_t l = 0, i;\r\nu64 m = PERF_MEM_TLB_NA;\r\nu64 hit, miss;\r\nsz -= 1;\r\nout[0] = '\0';\r\nif (mem_info)\r\nm = mem_info->data_src.mem_dtlb;\r\nhit = m & PERF_MEM_TLB_HIT;\r\nmiss = m & PERF_MEM_TLB_MISS;\r\nm &= ~(PERF_MEM_TLB_HIT|PERF_MEM_TLB_MISS);\r\nfor (i = 0; m && i < ARRAY_SIZE(tlb_access); i++, m >>= 1) {\r\nif (!(m & 0x1))\r\ncontinue;\r\nif (l) {\r\nstrcat(out, " or ");\r\nl += 4;\r\n}\r\nl += scnprintf(out + l, sz - l, tlb_access[i]);\r\n}\r\nif (*out == '\0')\r\nl += scnprintf(out, sz - l, "N/A");\r\nif (hit)\r\nl += scnprintf(out + l, sz - l, " hit");\r\nif (miss)\r\nl += scnprintf(out + l, sz - l, " miss");\r\nreturn l;\r\n}\r\nint perf_mem__lvl_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\r\n{\r\nsize_t i, l = 0;\r\nu64 m = PERF_MEM_LVL_NA;\r\nu64 hit, miss;\r\nif (mem_info)\r\nm = mem_info->data_src.mem_lvl;\r\nsz -= 1;\r\nout[0] = '\0';\r\nhit = m & PERF_MEM_LVL_HIT;\r\nmiss = m & PERF_MEM_LVL_MISS;\r\nm &= ~(PERF_MEM_LVL_HIT|PERF_MEM_LVL_MISS);\r\nfor (i = 0; m && i < ARRAY_SIZE(mem_lvl); i++, m >>= 1) {\r\nif (!(m & 0x1))\r\ncontinue;\r\nif (l) {\r\nstrcat(out, " or ");\r\nl += 4;\r\n}\r\nl += scnprintf(out + l, sz - l, mem_lvl[i]);\r\n}\r\nif (*out == '\0')\r\nl += scnprintf(out, sz - l, "N/A");\r\nif (hit)\r\nl += scnprintf(out + l, sz - l, " hit");\r\nif (miss)\r\nl += scnprintf(out + l, sz - l, " miss");\r\nreturn l;\r\n}\r\nint perf_mem__snp_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\r\n{\r\nsize_t i, l = 0;\r\nu64 m = PERF_MEM_SNOOP_NA;\r\nsz -= 1;\r\nout[0] = '\0';\r\nif (mem_info)\r\nm = mem_info->data_src.mem_snoop;\r\nfor (i = 0; m && i < ARRAY_SIZE(snoop_access); i++, m >>= 1) {\r\nif (!(m & 0x1))\r\ncontinue;\r\nif (l) {\r\nstrcat(out, " or ");\r\nl += 4;\r\n}\r\nl += scnprintf(out + l, sz - l, snoop_access[i]);\r\n}\r\nif (*out == '\0')\r\nl += scnprintf(out, sz - l, "N/A");\r\nreturn l;\r\n}\r\nint perf_mem__lck_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\r\n{\r\nu64 mask = PERF_MEM_LOCK_NA;\r\nint l;\r\nif (mem_info)\r\nmask = mem_info->data_src.mem_lock;\r\nif (mask & PERF_MEM_LOCK_NA)\r\nl = scnprintf(out, sz, "N/A");\r\nelse if (mask & PERF_MEM_LOCK_LOCKED)\r\nl = scnprintf(out, sz, "Yes");\r\nelse\r\nl = scnprintf(out, sz, "No");\r\nreturn l;\r\n}\r\nint perf_script__meminfo_scnprintf(char *out, size_t sz, struct mem_info *mem_info)\r\n{\r\nint i = 0;\r\ni += perf_mem__lvl_scnprintf(out, sz, mem_info);\r\ni += scnprintf(out + i, sz - i, "|SNP ");\r\ni += perf_mem__snp_scnprintf(out + i, sz - i, mem_info);\r\ni += scnprintf(out + i, sz - i, "|TLB ");\r\ni += perf_mem__tlb_scnprintf(out + i, sz - i, mem_info);\r\ni += scnprintf(out + i, sz - i, "|LCK ");\r\ni += perf_mem__lck_scnprintf(out + i, sz - i, mem_info);\r\nreturn i;\r\n}\r\nint c2c_decode_stats(struct c2c_stats *stats, struct mem_info *mi)\r\n{\r\nunion perf_mem_data_src *data_src = &mi->data_src;\r\nu64 daddr = mi->daddr.addr;\r\nu64 op = data_src->mem_op;\r\nu64 lvl = data_src->mem_lvl;\r\nu64 snoop = data_src->mem_snoop;\r\nu64 lock = data_src->mem_lock;\r\nint err = 0;\r\n#define HITM_INC(__f) \\r\ndo { \\r\nstats->__f++; \\r\nstats->tot_hitm++; \\r\n} while (0)\r\n#define P(a, b) PERF_MEM_##a##_##b\r\nstats->nr_entries++;\r\nif (lock & P(LOCK, LOCKED)) stats->locks++;\r\nif (op & P(OP, LOAD)) {\r\nstats->load++;\r\nif (!daddr) {\r\nstats->ld_noadrs++;\r\nreturn -1;\r\n}\r\nif (lvl & P(LVL, HIT)) {\r\nif (lvl & P(LVL, UNC)) stats->ld_uncache++;\r\nif (lvl & P(LVL, IO)) stats->ld_io++;\r\nif (lvl & P(LVL, LFB)) stats->ld_fbhit++;\r\nif (lvl & P(LVL, L1 )) stats->ld_l1hit++;\r\nif (lvl & P(LVL, L2 )) stats->ld_l2hit++;\r\nif (lvl & P(LVL, L3 )) {\r\nif (snoop & P(SNOOP, HITM))\r\nHITM_INC(lcl_hitm);\r\nelse\r\nstats->ld_llchit++;\r\n}\r\nif (lvl & P(LVL, LOC_RAM)) {\r\nstats->lcl_dram++;\r\nif (snoop & P(SNOOP, HIT))\r\nstats->ld_shared++;\r\nelse\r\nstats->ld_excl++;\r\n}\r\nif ((lvl & P(LVL, REM_RAM1)) ||\r\n(lvl & P(LVL, REM_RAM2))) {\r\nstats->rmt_dram++;\r\nif (snoop & P(SNOOP, HIT))\r\nstats->ld_shared++;\r\nelse\r\nstats->ld_excl++;\r\n}\r\n}\r\nif ((lvl & P(LVL, REM_CCE1)) ||\r\n(lvl & P(LVL, REM_CCE2))) {\r\nif (snoop & P(SNOOP, HIT))\r\nstats->rmt_hit++;\r\nelse if (snoop & P(SNOOP, HITM))\r\nHITM_INC(rmt_hitm);\r\n}\r\nif ((lvl & P(LVL, MISS)))\r\nstats->ld_miss++;\r\n} else if (op & P(OP, STORE)) {\r\nstats->store++;\r\nif (!daddr) {\r\nstats->st_noadrs++;\r\nreturn -1;\r\n}\r\nif (lvl & P(LVL, HIT)) {\r\nif (lvl & P(LVL, UNC)) stats->st_uncache++;\r\nif (lvl & P(LVL, L1 )) stats->st_l1hit++;\r\n}\r\nif (lvl & P(LVL, MISS))\r\nif (lvl & P(LVL, L1)) stats->st_l1miss++;\r\n} else {\r\nstats->noparse++;\r\nreturn -1;\r\n}\r\nif (!mi->daddr.map || !mi->iaddr.map) {\r\nstats->nomap++;\r\nreturn -1;\r\n}\r\n#undef P\r\n#undef HITM_INC\r\nreturn err;\r\n}\r\nvoid c2c_add_stats(struct c2c_stats *stats, struct c2c_stats *add)\r\n{\r\nstats->nr_entries += add->nr_entries;\r\nstats->locks += add->locks;\r\nstats->store += add->store;\r\nstats->st_uncache += add->st_uncache;\r\nstats->st_noadrs += add->st_noadrs;\r\nstats->st_l1hit += add->st_l1hit;\r\nstats->st_l1miss += add->st_l1miss;\r\nstats->load += add->load;\r\nstats->ld_excl += add->ld_excl;\r\nstats->ld_shared += add->ld_shared;\r\nstats->ld_uncache += add->ld_uncache;\r\nstats->ld_io += add->ld_io;\r\nstats->ld_miss += add->ld_miss;\r\nstats->ld_noadrs += add->ld_noadrs;\r\nstats->ld_fbhit += add->ld_fbhit;\r\nstats->ld_l1hit += add->ld_l1hit;\r\nstats->ld_l2hit += add->ld_l2hit;\r\nstats->ld_llchit += add->ld_llchit;\r\nstats->lcl_hitm += add->lcl_hitm;\r\nstats->rmt_hitm += add->rmt_hitm;\r\nstats->tot_hitm += add->tot_hitm;\r\nstats->rmt_hit += add->rmt_hit;\r\nstats->lcl_dram += add->lcl_dram;\r\nstats->rmt_dram += add->rmt_dram;\r\nstats->nomap += add->nomap;\r\nstats->noparse += add->noparse;\r\n}
