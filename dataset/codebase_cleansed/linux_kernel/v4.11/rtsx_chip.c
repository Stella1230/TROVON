static void rtsx_calibration(struct rtsx_chip *chip)\r\n{\r\nrtsx_write_phy_register(chip, 0x1B, 0x135E);\r\nwait_timeout(10);\r\nrtsx_write_phy_register(chip, 0x00, 0x0280);\r\nrtsx_write_phy_register(chip, 0x01, 0x7112);\r\nrtsx_write_phy_register(chip, 0x01, 0x7110);\r\nrtsx_write_phy_register(chip, 0x01, 0x7112);\r\nrtsx_write_phy_register(chip, 0x01, 0x7113);\r\nrtsx_write_phy_register(chip, 0x00, 0x0288);\r\n}\r\nvoid rtsx_enable_card_int(struct rtsx_chip *chip)\r\n{\r\nu32 reg = rtsx_readl(chip, RTSX_BIER);\r\nint i;\r\nfor (i = 0; i <= chip->max_lun; i++) {\r\nif (chip->lun2card[i] & XD_CARD)\r\nreg |= XD_INT_EN;\r\nif (chip->lun2card[i] & SD_CARD)\r\nreg |= SD_INT_EN;\r\nif (chip->lun2card[i] & MS_CARD)\r\nreg |= MS_INT_EN;\r\n}\r\nif (chip->hw_bypass_sd)\r\nreg &= ~((u32)SD_INT_EN);\r\nrtsx_writel(chip, RTSX_BIER, reg);\r\n}\r\nvoid rtsx_enable_bus_int(struct rtsx_chip *chip)\r\n{\r\nu32 reg = 0;\r\n#ifndef DISABLE_CARD_INT\r\nint i;\r\n#endif\r\nreg = TRANS_OK_INT_EN | TRANS_FAIL_INT_EN;\r\n#ifndef DISABLE_CARD_INT\r\nfor (i = 0; i <= chip->max_lun; i++) {\r\ndev_dbg(rtsx_dev(chip), "lun2card[%d] = 0x%02x\n",\r\ni, chip->lun2card[i]);\r\nif (chip->lun2card[i] & XD_CARD)\r\nreg |= XD_INT_EN;\r\nif (chip->lun2card[i] & SD_CARD)\r\nreg |= SD_INT_EN;\r\nif (chip->lun2card[i] & MS_CARD)\r\nreg |= MS_INT_EN;\r\n}\r\nif (chip->hw_bypass_sd)\r\nreg &= ~((u32)SD_INT_EN);\r\n#endif\r\nif (chip->ic_version >= IC_VER_C)\r\nreg |= DELINK_INT_EN;\r\n#ifdef SUPPORT_OCP\r\nreg |= OC_INT_EN;\r\n#endif\r\nif (!chip->adma_mode)\r\nreg |= DATA_DONE_INT_EN;\r\nrtsx_writel(chip, RTSX_BIER, reg);\r\ndev_dbg(rtsx_dev(chip), "RTSX_BIER: 0x%08x\n", reg);\r\n}\r\nvoid rtsx_disable_bus_int(struct rtsx_chip *chip)\r\n{\r\nrtsx_writel(chip, RTSX_BIER, 0);\r\n}\r\nstatic int rtsx_pre_handle_sdio_old(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nif (chip->ignore_sd && CHK_SDIO_EXIST(chip)) {\r\nif (chip->asic_code) {\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL5,\r\n0xFF,\r\nMS_INS_PU | SD_WP_PU |\r\nSD_CD_PU | SD_CMD_PU);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n} else {\r\nretval = rtsx_write_register(chip, FPGA_PULL_CTL,\r\n0xFF,\r\nFPGA_SD_PULL_CTL_EN);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, CARD_SHARE_MODE, 0xFF,\r\nCARD_SHARE_48_SD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, 0xFF2C, 0x01, 0x01);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, SDIO_CTRL, 0xFF,\r\nSDIO_BUS_CTRL | SDIO_CD_CTRL);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->sd_int = 1;\r\nchip->sd_io = 1;\r\n} else {\r\nchip->need_reset |= SD_CARD;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rtsx_pre_handle_sdio_new(struct rtsx_chip *chip)\r\n{\r\nu8 tmp;\r\nbool sw_bypass_sd = false;\r\nint retval;\r\nif (chip->driver_first_load) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_read_register(chip, 0xFE5A, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (tmp & 0x08)\r\nsw_bypass_sd = true;\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_read_register(chip, 0xFE70, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (tmp & 0x80)\r\nsw_bypass_sd = true;\r\n}\r\n} else {\r\nif (chip->sdio_in_charge)\r\nsw_bypass_sd = true;\r\n}\r\ndev_dbg(rtsx_dev(chip), "chip->sdio_in_charge = %d\n",\r\nchip->sdio_in_charge);\r\ndev_dbg(rtsx_dev(chip), "chip->driver_first_load = %d\n",\r\nchip->driver_first_load);\r\ndev_dbg(rtsx_dev(chip), "sw_bypass_sd = %d\n",\r\nsw_bypass_sd);\r\nif (sw_bypass_sd) {\r\nu8 cd_toggle_mask = 0;\r\nretval = rtsx_read_register(chip, TLPTISTAT, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ncd_toggle_mask = 0x08;\r\nif (tmp & cd_toggle_mask) {\r\nif (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_register(chip, 0xFE5A,\r\n0x08, 0x00);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_write_register(chip, 0xFE70,\r\n0x80, 0x00);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, TLPTISTAT, 0xFF,\r\ntmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->need_reset |= SD_CARD;\r\n} else {\r\ndev_dbg(rtsx_dev(chip), "Chip inserted with SDIO!\n");\r\nif (chip->asic_code) {\r\nretval = sd_pull_ctl_enable(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nretval = rtsx_write_register\r\n(chip, FPGA_PULL_CTL,\r\nFPGA_SD_PULL_CTL_BIT | 0x20,\r\n0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = card_share_mode(chip, SD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_register(chip, 0xFE5A,\r\n0x08, 0x08);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n} else if (CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_write_register(chip, 0xFE70,\r\n0x80, 0x80);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nchip->chip_insert_with_sdio = 1;\r\nchip->sd_io = 1;\r\n}\r\n} else {\r\nretval = rtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->need_reset |= SD_CARD;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rtsx_reset_aspm(struct rtsx_chip *chip)\r\n{\r\nint ret;\r\nif (chip->dynamic_aspm) {\r\nif (!CHK_SDIO_EXIST(chip) || !CHECK_PID(chip, 0x5288))\r\nreturn STATUS_SUCCESS;\r\nret = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFF,\r\nchip->aspm_l0s_l1_en);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nif (CHECK_PID(chip, 0x5208)) {\r\nret = rtsx_write_register(chip, ASPM_FORCE_CTL, 0xFF, 0x3F);\r\nif (ret) {\r\nrtsx_trace(chip);\r\nreturn ret;\r\n}\r\n}\r\nret = rtsx_write_config_byte(chip, LCTLR, chip->aspm_l0s_l1_en);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nchip->aspm_level[0] = chip->aspm_l0s_l1_en;\r\nif (CHK_SDIO_EXIST(chip)) {\r\nchip->aspm_level[1] = chip->aspm_l0s_l1_en;\r\nret = rtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\r\n0xC0, 0xFF, chip->aspm_l0s_l1_en);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nchip->aspm_enabled = 1;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rtsx_enable_pcie_intr(struct rtsx_chip *chip)\r\n{\r\nint ret;\r\nif (!chip->asic_code || !CHECK_PID(chip, 0x5208)) {\r\nrtsx_enable_bus_int(chip);\r\nreturn STATUS_SUCCESS;\r\n}\r\nif (chip->phy_debug_mode) {\r\nret = rtsx_write_register(chip, CDRESUMECTL, 0x77, 0);\r\nif (ret) {\r\nrtsx_trace(chip);\r\nreturn ret;\r\n}\r\nrtsx_disable_bus_int(chip);\r\n} else {\r\nrtsx_enable_bus_int(chip);\r\n}\r\nif (chip->ic_version >= IC_VER_D) {\r\nu16 reg;\r\nret = rtsx_read_phy_register(chip, 0x00, &reg);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreg &= 0xFE7F;\r\nreg |= 0x80;\r\nret = rtsx_write_phy_register(chip, 0x00, reg);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nret = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreg &= 0xFFF7;\r\nret = rtsx_write_phy_register(chip, 0x1C, reg);\r\nif (ret != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (chip->driver_first_load && (chip->ic_version < IC_VER_C))\r\nrtsx_calibration(chip);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_reset_chip(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nrtsx_writel(chip, RTSX_HCBAR, chip->host_cmds_addr);\r\nrtsx_disable_aspm(chip);\r\nretval = rtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 0x00);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_CLK_EN, 0x1E, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n#ifdef SUPPORT_OCP\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n} else {\r\nretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN,\r\nMS_OC_POWER_DOWN);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, OCPPARA1, OCP_TIME_MASK,\r\nOCP_TIME_800);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, OCPPARA2, OCP_THD_MASK,\r\nOCP_THD_244_946);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, OCPCTL, 0xFF,\r\nCARD_OC_INT_EN | CARD_DETECT_EN);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n#else\r\nretval = rtsx_write_register(chip, FPDCTL, OC_POWER_DOWN,\r\nOC_POWER_DOWN);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n#endif\r\nif (!CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_register(chip, CARD_GPIO_DIR, 0xFF, 0x03);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, CARD_GPIO, 0xFF, 0x03);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_DRIVE_SEL, 0xFF,\r\nchip->card_drive_sel);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n#ifdef LED_AUTO_BLINK\r\nretval = rtsx_write_register(chip, CARD_AUTO_BLINK, 0xFF,\r\nLED_BLINK_SPEED | BLINK_EN | LED_GPIO0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n#endif\r\nif (chip->asic_code) {\r\nretval = rtsx_write_register(chip, SSC_CTL1, 0xFF,\r\nSSC_8X_EN | SSC_SEL_4M);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, SSC_CTL2, 0xFF, 0x12);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, CHANGE_LINK_STATE, 0x16, 0x10);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (chip->aspm_l0s_l1_en) {\r\nretval = rtsx_reset_aspm(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_write_phy_register(chip, 0x07, 0x0129);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nretval = rtsx_write_config_byte(chip, LCTLR,\r\nchip->aspm_l0s_l1_en);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nretval = rtsx_write_config_byte(chip, 0x81, 1);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (CHK_SDIO_EXIST(chip)) {\r\nretval = rtsx_write_cfg_dw(chip,\r\nCHECK_PID(chip, 0x5288) ? 2 : 1,\r\n0xC0, 0xFF00, 0x0100);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (CHECK_PID(chip, 0x5288) && !CHK_SDIO_EXIST(chip)) {\r\nretval = rtsx_write_cfg_dw(chip, 2, 0xC0, 0xFFFF, 0x0103);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = rtsx_write_cfg_dw(chip, 2, 0x84, 0xFF, 0x03);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nretval = rtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT,\r\nLINK_RDY_INT);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PERST_GLITCH_WIDTH, 0xFF, 0x80);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_enable_pcie_intr(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nchip->need_reset = 0;\r\nchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\r\nif (chip->hw_bypass_sd)\r\ngoto nextcard;\r\ndev_dbg(rtsx_dev(chip), "In %s, chip->int_reg = 0x%x\n", __func__,\r\nchip->int_reg);\r\nif (chip->int_reg & SD_EXIST) {\r\n#ifdef HW_AUTO_SWITCH_SD_BUS\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version < IC_VER_C))\r\nretval = rtsx_pre_handle_sdio_old(chip);\r\nelse\r\nretval = rtsx_pre_handle_sdio_new(chip);\r\ndev_dbg(rtsx_dev(chip), "chip->need_reset = 0x%x (rtsx_reset_chip)\n",\r\n(unsigned int)(chip->need_reset));\r\n#else\r\nretval = rtsx_pre_handle_sdio_old(chip);\r\n#endif\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nchip->sd_io = 0;\r\nretval = rtsx_write_register(chip, SDIO_CTRL,\r\nSDIO_BUS_CTRL | SDIO_CD_CTRL, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nnextcard:\r\nif (chip->int_reg & XD_EXIST)\r\nchip->need_reset |= XD_CARD;\r\nif (chip->int_reg & MS_EXIST)\r\nchip->need_reset |= MS_CARD;\r\nif (chip->int_reg & CARD_EXIST) {\r\nretval = rtsx_write_register(chip, SSC_CTL1, SSC_RSTB,\r\nSSC_RSTB);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\ndev_dbg(rtsx_dev(chip), "In %s, chip->need_reset = 0x%x\n", __func__,\r\n(unsigned int)(chip->need_reset));\r\nretval = rtsx_write_register(chip, RCCTL, 0x01, 0x00);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (CHECK_PID(chip, 0x5208) || CHECK_PID(chip, 0x5288)) {\r\nretval = rtsx_write_register(chip, MAIN_PWR_OFF_CTL, 0x03,\r\n0x03);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nif (chip->remote_wakeup_en && !chip->auto_delink_en) {\r\nretval = rtsx_write_register(chip, WAKE_SEL_CTL, 0x07, 0x07);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (chip->aux_pwr_exist) {\r\nretval = rtsx_write_register(chip, PME_FORCE_CTL,\r\n0xFF, 0x33);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\n} else {\r\nretval = rtsx_write_register(chip, WAKE_SEL_CTL, 0x07, 0x04);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PME_FORCE_CTL, 0xFF, 0x30);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {\r\nretval = rtsx_write_register(chip, PETXCFG, 0x1C, 0x14);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_clr_phy_reg_bit(chip, 0x1C, 2);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (chip->ft2_fast_mode) {\r\nretval = rtsx_write_register(chip, CARD_PWR_CTL, 0xFF,\r\nMS_PARTIAL_POWER_ON |\r\nSD_PARTIAL_POWER_ON);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nudelay(chip->pmos_pwr_on_interval);\r\nretval = rtsx_write_register(chip, CARD_PWR_CTL, 0xFF,\r\nMS_POWER_ON | SD_POWER_ON);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nwait_timeout(200);\r\n}\r\nrtsx_reset_detected_cards(chip, 0);\r\nchip->driver_first_load = 0;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic inline int check_sd_speed_prior(u32 sd_speed_prior)\r\n{\r\nbool fake_para = false;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nu8 tmp = (u8)(sd_speed_prior >> (i * 8));\r\nif ((tmp < 0x01) || (tmp > 0x04)) {\r\nfake_para = true;\r\nbreak;\r\n}\r\n}\r\nreturn !fake_para;\r\n}\r\nstatic inline int check_sd_current_prior(u32 sd_current_prior)\r\n{\r\nbool fake_para = false;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nu8 tmp = (u8)(sd_current_prior >> (i * 8));\r\nif (tmp > 0x03) {\r\nfake_para = true;\r\nbreak;\r\n}\r\n}\r\nreturn !fake_para;\r\n}\r\nstatic int rts5208_init(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu16 reg = 0;\r\nu8 val = 0;\r\nretval = rtsx_write_register(chip, CLK_SEL, 0x03, 0x03);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_read_register(chip, CLK_SEL, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->asic_code = val == 0 ? 1 : 0;\r\nif (chip->asic_code) {\r\nretval = rtsx_read_phy_register(chip, 0x1C, &reg);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\ndev_dbg(rtsx_dev(chip), "Value of phy register 0x1C is 0x%x\n",\r\nreg);\r\nchip->ic_version = (reg >> 4) & 0x07;\r\nchip->phy_debug_mode = reg & PHY_DEBUG_MODE ? 1 : 0;\r\n} else {\r\nretval = rtsx_read_register(chip, 0xFE80, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->ic_version = val;\r\nchip->phy_debug_mode = 0;\r\n}\r\nretval = rtsx_read_register(chip, PDINFO, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "PDINFO: 0x%x\n", val);\r\nchip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;\r\nretval = rtsx_read_register(chip, 0xFE50, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->hw_bypass_sd = val & 0x01 ? 1 : 0;\r\nrtsx_read_config_byte(chip, 0x0E, &val);\r\nif (val & 0x80)\r\nSET_SDIO_EXIST(chip);\r\nelse\r\nCLR_SDIO_EXIST(chip);\r\nif (chip->use_hw_setting) {\r\nretval = rtsx_read_register(chip, CHANGE_LINK_STATE, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->auto_delink_en = val & 0x80 ? 1 : 0;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rts5288_init(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 val = 0, max_func;\r\nu32 lval = 0;\r\nretval = rtsx_write_register(chip, CLK_SEL, 0x03, 0x03);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_read_register(chip, CLK_SEL, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->asic_code = val == 0 ? 1 : 0;\r\nchip->ic_version = 0;\r\nchip->phy_debug_mode = 0;\r\nretval = rtsx_read_register(chip, PDINFO, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "PDINFO: 0x%x\n", val);\r\nchip->aux_pwr_exist = val & AUX_PWR_DETECTED ? 1 : 0;\r\nretval = rtsx_read_register(chip, CARD_SHARE_MODE, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "CARD_SHARE_MODE: 0x%x\n", val);\r\nchip->baro_pkg = val & 0x04 ? QFN : LQFP;\r\nretval = rtsx_read_register(chip, 0xFE5A, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->hw_bypass_sd = val & 0x10 ? 1 : 0;\r\nretval = rtsx_read_cfg_dw(chip, 0, 0x718, &lval);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nmax_func = (u8)((lval >> 29) & 0x07);\r\ndev_dbg(rtsx_dev(chip), "Max function number: %d\n", max_func);\r\nif (max_func == 0x02)\r\nSET_SDIO_EXIST(chip);\r\nelse\r\nCLR_SDIO_EXIST(chip);\r\nif (chip->use_hw_setting) {\r\nretval = rtsx_read_register(chip, CHANGE_LINK_STATE, &val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nchip->auto_delink_en = val & 0x80 ? 1 : 0;\r\nif (CHECK_BARO_PKG(chip, LQFP))\r\nchip->lun_mode = SD_MS_1LUN;\r\nelse\r\nchip->lun_mode = DEFAULT_SINGLE;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_init_chip(struct rtsx_chip *chip)\r\n{\r\nstruct sd_info *sd_card = &chip->sd_card;\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct ms_info *ms_card = &chip->ms_card;\r\nint retval;\r\nunsigned int i;\r\ndev_dbg(rtsx_dev(chip), "Vendor ID: 0x%04x, Product ID: 0x%04x\n",\r\nchip->vendor_id, chip->product_id);\r\nchip->ic_version = 0;\r\n#ifdef _MSG_TRACE\r\nchip->msg_idx = 0;\r\n#endif\r\nmemset(xd_card, 0, sizeof(struct xd_info));\r\nmemset(sd_card, 0, sizeof(struct sd_info));\r\nmemset(ms_card, 0, sizeof(struct ms_info));\r\nchip->xd_reset_counter = 0;\r\nchip->sd_reset_counter = 0;\r\nchip->ms_reset_counter = 0;\r\nchip->xd_show_cnt = MAX_SHOW_CNT;\r\nchip->sd_show_cnt = MAX_SHOW_CNT;\r\nchip->ms_show_cnt = MAX_SHOW_CNT;\r\nchip->sd_io = 0;\r\nchip->auto_delink_cnt = 0;\r\nchip->auto_delink_allowed = 1;\r\nrtsx_set_stat(chip, RTSX_STAT_INIT);\r\nchip->aspm_enabled = 0;\r\nchip->chip_insert_with_sdio = 0;\r\nchip->sdio_aspm = 0;\r\nchip->sdio_idle = 0;\r\nchip->sdio_counter = 0;\r\nchip->cur_card = 0;\r\nchip->phy_debug_mode = 0;\r\nchip->sdio_func_exist = 0;\r\nmemset(chip->sdio_raw_data, 0, 12);\r\nfor (i = 0; i < MAX_ALLOWED_LUN_CNT; i++) {\r\nset_sense_type(chip, i, SENSE_TYPE_NO_SENSE);\r\nchip->rw_fail_cnt[i] = 0;\r\n}\r\nif (!check_sd_speed_prior(chip->sd_speed_prior))\r\nchip->sd_speed_prior = 0x01040203;\r\ndev_dbg(rtsx_dev(chip), "sd_speed_prior = 0x%08x\n",\r\nchip->sd_speed_prior);\r\nif (!check_sd_current_prior(chip->sd_current_prior))\r\nchip->sd_current_prior = 0x00010203;\r\ndev_dbg(rtsx_dev(chip), "sd_current_prior = 0x%08x\n",\r\nchip->sd_current_prior);\r\nif ((chip->sd_ddr_tx_phase > 31) || (chip->sd_ddr_tx_phase < 0))\r\nchip->sd_ddr_tx_phase = 0;\r\nif ((chip->mmc_ddr_tx_phase > 31) || (chip->mmc_ddr_tx_phase < 0))\r\nchip->mmc_ddr_tx_phase = 0;\r\nretval = rtsx_write_register(chip, FPDCTL, SSC_POWER_DOWN, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nwait_timeout(200);\r\nretval = rtsx_write_register(chip, CLK_DIV, 0x07, 0x07);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "chip->use_hw_setting = %d\n",\r\nchip->use_hw_setting);\r\nif (CHECK_PID(chip, 0x5208)) {\r\nretval = rts5208_init(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nretval = rts5288_init(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (chip->ss_en == 2)\r\nchip->ss_en = 0;\r\ndev_dbg(rtsx_dev(chip), "chip->asic_code = %d\n", chip->asic_code);\r\ndev_dbg(rtsx_dev(chip), "chip->ic_version = 0x%x\n", chip->ic_version);\r\ndev_dbg(rtsx_dev(chip), "chip->phy_debug_mode = %d\n",\r\nchip->phy_debug_mode);\r\ndev_dbg(rtsx_dev(chip), "chip->aux_pwr_exist = %d\n",\r\nchip->aux_pwr_exist);\r\ndev_dbg(rtsx_dev(chip), "chip->sdio_func_exist = %d\n",\r\nchip->sdio_func_exist);\r\ndev_dbg(rtsx_dev(chip), "chip->hw_bypass_sd = %d\n",\r\nchip->hw_bypass_sd);\r\ndev_dbg(rtsx_dev(chip), "chip->aspm_l0s_l1_en = %d\n",\r\nchip->aspm_l0s_l1_en);\r\ndev_dbg(rtsx_dev(chip), "chip->lun_mode = %d\n", chip->lun_mode);\r\ndev_dbg(rtsx_dev(chip), "chip->auto_delink_en = %d\n",\r\nchip->auto_delink_en);\r\ndev_dbg(rtsx_dev(chip), "chip->ss_en = %d\n", chip->ss_en);\r\ndev_dbg(rtsx_dev(chip), "chip->baro_pkg = %d\n", chip->baro_pkg);\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN)) {\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 1;\r\nchip->card2lun[XD_CARD] = 0xFF;\r\nchip->lun2card[0] = SD_CARD;\r\nchip->lun2card[1] = MS_CARD;\r\nchip->max_lun = 1;\r\nSET_SDIO_IGNORED(chip);\r\n} else if (CHECK_LUN_MODE(chip, SD_MS_1LUN)) {\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 0;\r\nchip->card2lun[XD_CARD] = 0xFF;\r\nchip->lun2card[0] = SD_CARD | MS_CARD;\r\nchip->max_lun = 0;\r\n} else {\r\nchip->card2lun[XD_CARD] = 0;\r\nchip->card2lun[SD_CARD] = 0;\r\nchip->card2lun[MS_CARD] = 0;\r\nchip->lun2card[0] = XD_CARD | SD_CARD | MS_CARD;\r\nchip->max_lun = 0;\r\n}\r\nretval = rtsx_reset_chip(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rtsx_release_chip(struct rtsx_chip *chip)\r\n{\r\nxd_free_l2p_tbl(chip);\r\nms_free_l2p_tbl(chip);\r\nchip->card_exist = 0;\r\nchip->card_ready = 0;\r\n}\r\nstatic inline void rtsx_blink_led(struct rtsx_chip *chip)\r\n{\r\nif (chip->card_exist && chip->blink_led) {\r\nif (chip->led_toggle_counter < LED_TOGGLE_INTERVAL) {\r\nchip->led_toggle_counter++;\r\n} else {\r\nchip->led_toggle_counter = 0;\r\ntoggle_gpio(chip, LED_GPIO);\r\n}\r\n}\r\n}\r\nstatic void rtsx_monitor_aspm_config(struct rtsx_chip *chip)\r\n{\r\nbool reg_changed, maybe_support_aspm;\r\nu32 tmp = 0;\r\nu8 reg0 = 0, reg1 = 0;\r\nmaybe_support_aspm = false;\r\nreg_changed = false;\r\nrtsx_read_config_byte(chip, LCTLR, &reg0);\r\nif (chip->aspm_level[0] != reg0) {\r\nreg_changed = true;\r\nchip->aspm_level[0] = reg0;\r\n}\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\r\nrtsx_read_cfg_dw(chip, 1, 0xC0, &tmp);\r\nreg1 = (u8)tmp;\r\nif (chip->aspm_level[1] != reg1) {\r\nreg_changed = true;\r\nchip->aspm_level[1] = reg1;\r\n}\r\nif ((reg0 & 0x03) && (reg1 & 0x03))\r\nmaybe_support_aspm = true;\r\n} else {\r\nif (reg0 & 0x03)\r\nmaybe_support_aspm = true;\r\n}\r\nif (reg_changed) {\r\nif (maybe_support_aspm)\r\nchip->aspm_l0s_l1_en = 0x03;\r\ndev_dbg(rtsx_dev(chip), "aspm_level[0] = 0x%02x, aspm_level[1] = 0x%02x\n",\r\nchip->aspm_level[0], chip->aspm_level[1]);\r\nif (chip->aspm_l0s_l1_en) {\r\nchip->aspm_enabled = 1;\r\n} else {\r\nchip->aspm_enabled = 0;\r\nchip->sdio_aspm = 0;\r\n}\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xFF,\r\n0x30 | chip->aspm_level[0] |\r\n(chip->aspm_level[1] << 2));\r\n}\r\n}\r\nstatic void rtsx_manage_ocp(struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_OCP\r\nif (!chip->ocp_int)\r\nreturn;\r\nrtsx_read_register(chip, OCPSTAT, &chip->ocp_stat);\r\nif (chip->card_exist & SD_CARD)\r\nsd_power_off_card3v3(chip);\r\nelse if (chip->card_exist & MS_CARD)\r\nms_power_off_card3v3(chip);\r\nelse if (chip->card_exist & XD_CARD)\r\nxd_power_off_card3v3(chip);\r\nchip->ocp_int = 0;\r\n#endif\r\n}\r\nstatic void rtsx_manage_sd_lock(struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_SD_LOCK\r\nstruct sd_info *sd_card = &chip->sd_card;\r\nu8 val;\r\nif (!sd_card->sd_erase_status)\r\nreturn;\r\nif (chip->card_exist & SD_CARD) {\r\nrtsx_read_register(chip, 0xFD30, &val);\r\nif (val & 0x02) {\r\nsd_card->sd_erase_status = SD_NOT_ERASE;\r\nsd_card->sd_lock_notify = 1;\r\nchip->need_reinit |= SD_CARD;\r\n}\r\n} else {\r\nsd_card->sd_erase_status = SD_NOT_ERASE;\r\n}\r\n#endif\r\n}\r\nstatic bool rtsx_is_ss_allowed(struct rtsx_chip *chip)\r\n{\r\nu32 val;\r\nif (!chip->ss_en || CHECK_PID(chip, 0x5288))\r\nreturn false;\r\nif (CHK_SDIO_EXIST(chip) && !CHK_SDIO_IGNORED(chip)) {\r\nrtsx_read_cfg_dw(chip, 1, 0x04, &val);\r\nif (val & 0x07)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void rtsx_manage_ss(struct rtsx_chip *chip)\r\n{\r\nif (!rtsx_is_ss_allowed(chip) || chip->sd_io)\r\nreturn;\r\nif (rtsx_get_stat(chip) != RTSX_STAT_IDLE) {\r\nchip->ss_counter = 0;\r\nreturn;\r\n}\r\nif (chip->ss_counter < (chip->ss_idle_period / POLLING_INTERVAL))\r\nchip->ss_counter++;\r\nelse\r\nrtsx_exclusive_enter_ss(chip);\r\n}\r\nstatic void rtsx_manage_aspm(struct rtsx_chip *chip)\r\n{\r\nu8 data;\r\nif (!CHECK_PID(chip, 0x5208))\r\nreturn;\r\nrtsx_monitor_aspm_config(chip);\r\n#ifdef SUPPORT_SDIO_ASPM\r\nif (!CHK_SDIO_EXIST(chip) || CHK_SDIO_IGNORED(chip) ||\r\n!chip->aspm_l0s_l1_en || !chip->dynamic_aspm)\r\nreturn;\r\nif (chip->sd_io) {\r\ndynamic_configure_sdio_aspm(chip);\r\nreturn;\r\n}\r\nif (chip->sdio_aspm)\r\nreturn;\r\ndev_dbg(rtsx_dev(chip), "SDIO enter ASPM!\n");\r\ndata = 0x30 | (chip->aspm_level[1] << 2);\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xFC, data);\r\nchip->sdio_aspm = 1;\r\n#endif\r\n}\r\nstatic void rtsx_manage_idle(struct rtsx_chip *chip)\r\n{\r\nif (chip->idle_counter < IDLE_MAX_COUNT) {\r\nchip->idle_counter++;\r\nreturn;\r\n}\r\nif (rtsx_get_stat(chip) == RTSX_STAT_IDLE)\r\nreturn;\r\ndev_dbg(rtsx_dev(chip), "Idle state!\n");\r\nrtsx_set_stat(chip, RTSX_STAT_IDLE);\r\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\r\nchip->led_toggle_counter = 0;\r\n#endif\r\nrtsx_force_power_on(chip, SSC_PDCTL);\r\nturn_off_led(chip, LED_GPIO);\r\nif (chip->auto_power_down && !chip->card_ready && !chip->sd_io)\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\n}\r\nstatic void rtsx_manage_2lun_mode(struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_OCP\r\nu8 sd_oc, ms_oc;\r\nsd_oc = chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER);\r\nms_oc = chip->ocp_stat & (MS_OC_NOW | MS_OC_EVER);\r\nif (sd_oc || ms_oc)\r\ndev_dbg(rtsx_dev(chip), "Over current, OCPSTAT is 0x%x\n",\r\nchip->ocp_stat);\r\nif (sd_oc && (chip->card_exist & SD_CARD)) {\r\nrtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\r\ncard_power_off(chip, SD_CARD);\r\nchip->card_fail |= SD_CARD;\r\n}\r\nif (ms_oc && (chip->card_exist & MS_CARD)) {\r\nrtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\r\ncard_power_off(chip, MS_CARD);\r\nchip->card_fail |= MS_CARD;\r\n}\r\n#endif\r\n}\r\nstatic void rtsx_manage_1lun_mode(struct rtsx_chip *chip)\r\n{\r\n#ifdef SUPPORT_OCP\r\nif (!(chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)))\r\nreturn;\r\ndev_dbg(rtsx_dev(chip), "Over current, OCPSTAT is 0x%x\n",\r\nchip->ocp_stat);\r\nif (chip->card_exist & SD_CARD) {\r\nrtsx_write_register(chip, CARD_OE, SD_OUTPUT_EN, 0);\r\nchip->card_fail |= SD_CARD;\r\n} else if (chip->card_exist & MS_CARD) {\r\nrtsx_write_register(chip, CARD_OE, MS_OUTPUT_EN, 0);\r\nchip->card_fail |= MS_CARD;\r\n} else if (chip->card_exist & XD_CARD) {\r\nrtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\r\nchip->card_fail |= XD_CARD;\r\n}\r\ncard_power_off(chip, SD_CARD);\r\n#endif\r\n}\r\nstatic void rtsx_delink_stage1(struct rtsx_chip *chip, int enter_L1,\r\nint stage3_cnt)\r\n{\r\nu8 val;\r\nrtsx_set_stat(chip, RTSX_STAT_DELINK);\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_set_phy_reg_bit(chip, 0x1C, 2);\r\nif (chip->card_exist)\r\ndev_dbg(rtsx_dev(chip), "False card inserted, do force delink\n");\r\nelse\r\ndev_dbg(rtsx_dev(chip), "No card inserted, do delink\n");\r\nif (enter_L1)\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 1);\r\nif (chip->card_exist)\r\nval = 0x02;\r\nelse\r\nval = 0x0A;\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, val, val);\r\nif (enter_L1)\r\nrtsx_enter_L1(chip);\r\nif (chip->card_exist)\r\nchip->auto_delink_cnt = stage3_cnt + 1;\r\n}\r\nstatic void rtsx_delink_stage(struct rtsx_chip *chip)\r\n{\r\nint delink_stage1_cnt, delink_stage2_cnt, delink_stage3_cnt;\r\nint enter_L1;\r\nif (!chip->auto_delink_en || !chip->auto_delink_allowed ||\r\nchip->card_ready || chip->card_ejected || chip->sd_io) {\r\nchip->auto_delink_cnt = 0;\r\nreturn;\r\n}\r\nenter_L1 = chip->auto_delink_in_L1 &&\r\n(chip->aspm_l0s_l1_en || chip->ss_en);\r\ndelink_stage1_cnt = chip->delink_stage1_step;\r\ndelink_stage2_cnt = delink_stage1_cnt + chip->delink_stage2_step;\r\ndelink_stage3_cnt = delink_stage2_cnt + chip->delink_stage3_step;\r\nif (chip->auto_delink_cnt > delink_stage3_cnt)\r\nreturn;\r\nif (chip->auto_delink_cnt == delink_stage1_cnt)\r\nrtsx_delink_stage1(chip, enter_L1, delink_stage3_cnt);\r\nif (chip->auto_delink_cnt == delink_stage2_cnt) {\r\ndev_dbg(rtsx_dev(chip), "Try to do force delink\n");\r\nif (enter_L1)\r\nrtsx_exit_L1(chip);\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_set_phy_reg_bit(chip, 0x1C, 2);\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x0A, 0x0A);\r\n}\r\nchip->auto_delink_cnt++;\r\n}\r\nvoid rtsx_polling_func(struct rtsx_chip *chip)\r\n{\r\nif (rtsx_chk_stat(chip, RTSX_STAT_SUSPEND))\r\nreturn;\r\nif (rtsx_chk_stat(chip, RTSX_STAT_DELINK))\r\ngoto delink_stage;\r\nif (chip->polling_config) {\r\nu8 val;\r\nrtsx_read_config_byte(chip, 0, &val);\r\n}\r\nif (rtsx_chk_stat(chip, RTSX_STAT_SS))\r\nreturn;\r\nrtsx_manage_ocp(chip);\r\nrtsx_manage_sd_lock(chip);\r\nrtsx_init_cards(chip);\r\nrtsx_manage_ss(chip);\r\nrtsx_manage_aspm(chip);\r\nrtsx_manage_idle(chip);\r\nswitch (rtsx_get_stat(chip)) {\r\ncase RTSX_STAT_RUN:\r\n#if !defined(LED_AUTO_BLINK) && defined(REGULAR_BLINK)\r\nrtsx_blink_led(chip);\r\n#endif\r\ndo_remaining_work(chip);\r\nbreak;\r\ncase RTSX_STAT_IDLE:\r\nif (chip->sd_io && !chip->sd_int)\r\ntry_to_switch_sdio_ctrl(chip);\r\nrtsx_enable_aspm(chip);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nrtsx_manage_2lun_mode(chip);\r\nelse\r\nrtsx_manage_1lun_mode(chip);\r\ndelink_stage:\r\nrtsx_delink_stage(chip);\r\n}\r\nvoid rtsx_stop_cmd(struct rtsx_chip *chip, int card)\r\n{\r\nint i;\r\nfor (i = 0; i <= 8; i++) {\r\nint addr = RTSX_HCBAR + i * 4;\r\nu32 reg;\r\nreg = rtsx_readl(chip, addr);\r\ndev_dbg(rtsx_dev(chip), "BAR (0x%02x): 0x%08x\n", addr, reg);\r\n}\r\nrtsx_writel(chip, RTSX_HCBCTLR, STOP_CMD);\r\nrtsx_writel(chip, RTSX_HDBCTLR, STOP_DMA);\r\nfor (i = 0; i < 16; i++) {\r\nu16 addr = 0xFE20 + (u16)i;\r\nu8 val;\r\nrtsx_read_register(chip, addr, &val);\r\ndev_dbg(rtsx_dev(chip), "0x%04X: 0x%02x\n", addr, val);\r\n}\r\nrtsx_write_register(chip, DMACTL, 0x80, 0x80);\r\nrtsx_write_register(chip, RBCTL, 0x80, 0x80);\r\n}\r\nint rtsx_write_register(struct rtsx_chip *chip, u16 addr, u8 mask, u8 data)\r\n{\r\nint i;\r\nu32 val = 3 << 30;\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nval |= (u32)mask << 8;\r\nval |= (u32)data;\r\nrtsx_writel(chip, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_readl(chip, RTSX_HAIMR);\r\nif ((val & (1 << 31)) == 0) {\r\nif (data != (u8)val) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nrtsx_trace(chip);\r\nreturn STATUS_TIMEDOUT;\r\n}\r\nint rtsx_read_register(struct rtsx_chip *chip, u16 addr, u8 *data)\r\n{\r\nu32 val = 2 << 30;\r\nint i;\r\nif (data)\r\n*data = 0;\r\nval |= (u32)(addr & 0x3FFF) << 16;\r\nrtsx_writel(chip, RTSX_HAIMR, val);\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nval = rtsx_readl(chip, RTSX_HAIMR);\r\nif ((val & (1 << 31)) == 0)\r\nbreak;\r\n}\r\nif (i >= MAX_RW_REG_CNT) {\r\nrtsx_trace(chip);\r\nreturn STATUS_TIMEDOUT;\r\n}\r\nif (data)\r\n*data = (u8)(val & 0xFF);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 mask,\r\nu32 val)\r\n{\r\nint retval;\r\nu8 mode = 0, tmp;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nif (mask & 0xFF) {\r\nretval = rtsx_write_register(chip, CFGDATA0 + i,\r\n0xFF,\r\n(u8)(val & mask & 0xFF));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nmode |= (1 << i);\r\n}\r\nmask >>= 8;\r\nval >>= 8;\r\n}\r\nif (mode) {\r\nretval = rtsx_write_register(chip, CFGADDR0, 0xFF, (u8)addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CFGADDR1, 0xFF,\r\n(u8)(addr >> 8));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CFGRWCTL, 0xFF,\r\n0x80 | mode |\r\n((func_no & 0x03) << 4));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nretval = rtsx_read_register(chip, CFGRWCTL, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif ((tmp & 0x80) == 0)\r\nbreak;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_cfg_dw(struct rtsx_chip *chip, u8 func_no, u16 addr, u32 *val)\r\n{\r\nint retval;\r\nint i;\r\nu8 tmp;\r\nu32 data = 0;\r\nretval = rtsx_write_register(chip, CFGADDR0, 0xFF, (u8)addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CFGADDR1, 0xFF, (u8)(addr >> 8));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CFGRWCTL, 0xFF,\r\n0x80 | ((func_no & 0x03) << 4));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < MAX_RW_REG_CNT; i++) {\r\nretval = rtsx_read_register(chip, CFGRWCTL, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif ((tmp & 0x80) == 0)\r\nbreak;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nretval = rtsx_read_register(chip, CFGDATA0 + i, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndata |= (u32)tmp << (i * 8);\r\n}\r\nif (val)\r\n*val = data;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf,\r\nint len)\r\n{\r\nu32 *data, *mask;\r\nu16 offset = addr % 4;\r\nu16 aligned_addr = addr - offset;\r\nint dw_len, i, j;\r\nint retval;\r\nif (!buf) {\r\nrtsx_trace(chip);\r\nreturn STATUS_NOMEM;\r\n}\r\nif ((len + offset) % 4)\r\ndw_len = (len + offset) / 4 + 1;\r\nelse\r\ndw_len = (len + offset) / 4;\r\ndev_dbg(rtsx_dev(chip), "dw_len = %d\n", dw_len);\r\ndata = vzalloc(dw_len * 4);\r\nif (!data) {\r\nrtsx_trace(chip);\r\nreturn STATUS_NOMEM;\r\n}\r\nmask = vzalloc(dw_len * 4);\r\nif (!mask) {\r\nvfree(data);\r\nrtsx_trace(chip);\r\nreturn STATUS_NOMEM;\r\n}\r\nj = 0;\r\nfor (i = 0; i < len; i++) {\r\nmask[j] |= 0xFF << (offset * 8);\r\ndata[j] |= buf[i] << (offset * 8);\r\nif (++offset == 4) {\r\nj++;\r\noffset = 0;\r\n}\r\n}\r\nprint_hex_dump_bytes(KBUILD_MODNAME ": ", DUMP_PREFIX_NONE, mask,\r\ndw_len * 4);\r\nprint_hex_dump_bytes(KBUILD_MODNAME ": ", DUMP_PREFIX_NONE, data,\r\ndw_len * 4);\r\nfor (i = 0; i < dw_len; i++) {\r\nretval = rtsx_write_cfg_dw(chip, func, aligned_addr + i * 4,\r\nmask[i], data[i]);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(data);\r\nvfree(mask);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nvfree(data);\r\nvfree(mask);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_cfg_seq(struct rtsx_chip *chip, u8 func, u16 addr, u8 *buf,\r\nint len)\r\n{\r\nu32 *data;\r\nu16 offset = addr % 4;\r\nu16 aligned_addr = addr - offset;\r\nint dw_len, i, j;\r\nint retval;\r\nif ((len + offset) % 4)\r\ndw_len = (len + offset) / 4 + 1;\r\nelse\r\ndw_len = (len + offset) / 4;\r\ndev_dbg(rtsx_dev(chip), "dw_len = %d\n", dw_len);\r\ndata = vmalloc(dw_len * 4);\r\nif (!data) {\r\nrtsx_trace(chip);\r\nreturn STATUS_NOMEM;\r\n}\r\nfor (i = 0; i < dw_len; i++) {\r\nretval = rtsx_read_cfg_dw(chip, func, aligned_addr + i * 4,\r\ndata + i);\r\nif (retval != STATUS_SUCCESS) {\r\nvfree(data);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (buf) {\r\nj = 0;\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = (u8)(data[j] >> (offset * 8));\r\nif (++offset == 4) {\r\nj++;\r\noffset = 0;\r\n}\r\n}\r\n}\r\nvfree(data);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_phy_register(struct rtsx_chip *chip, u8 addr, u16 val)\r\n{\r\nint retval;\r\nbool finished = false;\r\nint i;\r\nu8 tmp;\r\nretval = rtsx_write_register(chip, PHYDATA0, 0xFF, (u8)val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PHYDATA1, 0xFF, (u8)(val >> 8));\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PHYADDR, 0xFF, addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PHYRWCTL, 0xFF, 0x81);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < 100000; i++) {\r\nretval = rtsx_read_register(chip, PHYRWCTL, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!(tmp & 0x80)) {\r\nfinished = true;\r\nbreak;\r\n}\r\n}\r\nif (!finished) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_phy_register(struct rtsx_chip *chip, u8 addr, u16 *val)\r\n{\r\nint retval;\r\nbool finished = false;\r\nint i;\r\nu16 data = 0;\r\nu8 tmp;\r\nretval = rtsx_write_register(chip, PHYADDR, 0xFF, addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, PHYRWCTL, 0xFF, 0x80);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < 100000; i++) {\r\nretval = rtsx_read_register(chip, PHYRWCTL, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!(tmp & 0x80)) {\r\nfinished = true;\r\nbreak;\r\n}\r\n}\r\nif (!finished) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = rtsx_read_register(chip, PHYDATA0, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndata = tmp;\r\nretval = rtsx_read_register(chip, PHYDATA1, &tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndata |= (u16)tmp << 8;\r\nif (val)\r\n*val = data;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_read_efuse(struct rtsx_chip *chip, u8 addr, u8 *val)\r\n{\r\nint retval;\r\nint i;\r\nu8 data = 0;\r\nretval = rtsx_write_register(chip, EFUSE_CTRL, 0xFF, 0x80 | addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = 0; i < 100; i++) {\r\nretval = rtsx_read_register(chip, EFUSE_CTRL, &data);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!(data & 0x80))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (data & 0x80) {\r\nrtsx_trace(chip);\r\nreturn STATUS_TIMEDOUT;\r\n}\r\nretval = rtsx_read_register(chip, EFUSE_DATA, &data);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (val)\r\n*val = data;\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_efuse(struct rtsx_chip *chip, u8 addr, u8 val)\r\n{\r\nint retval;\r\nint i, j;\r\nu8 data = 0, tmp = 0xFF;\r\nfor (i = 0; i < 8; i++) {\r\nif (val & (u8)(1 << i))\r\ncontinue;\r\ntmp &= (~(u8)(1 << i));\r\ndev_dbg(rtsx_dev(chip), "Write 0x%x to 0x%x\n", tmp, addr);\r\nretval = rtsx_write_register(chip, EFUSE_DATA, 0xFF, tmp);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, EFUSE_CTRL, 0xFF,\r\n0xA0 | addr);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (j = 0; j < 100; j++) {\r\nretval = rtsx_read_register(chip, EFUSE_CTRL, &data);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!(data & 0x80))\r\nbreak;\r\nwait_timeout(3);\r\n}\r\nif (data & 0x80) {\r\nrtsx_trace(chip);\r\nreturn STATUS_TIMEDOUT;\r\n}\r\nwait_timeout(5);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_clr_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\r\n{\r\nint retval;\r\nu16 value;\r\nretval = rtsx_read_phy_register(chip, reg, &value);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (value & (1 << bit)) {\r\nvalue &= ~(1 << bit);\r\nretval = rtsx_write_phy_register(chip, reg, value);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_set_phy_reg_bit(struct rtsx_chip *chip, u8 reg, u8 bit)\r\n{\r\nint retval;\r\nu16 value;\r\nretval = rtsx_read_phy_register(chip, reg, &value);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif ((value & (1 << bit)) == 0) {\r\nvalue |= (1 << bit);\r\nretval = rtsx_write_phy_register(chip, reg, value);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void rtsx_handle_pm_dstate(struct rtsx_chip *chip, u8 dstate)\r\n{\r\nu32 ultmp;\r\ndev_dbg(rtsx_dev(chip), "%04x set pm_dstate to %d\n",\r\nchip->product_id, dstate);\r\nif (CHK_SDIO_EXIST(chip)) {\r\nu8 func_no;\r\nif (CHECK_PID(chip, 0x5288))\r\nfunc_no = 2;\r\nelse\r\nfunc_no = 1;\r\nrtsx_read_cfg_dw(chip, func_no, 0x84, &ultmp);\r\ndev_dbg(rtsx_dev(chip), "pm_dstate of function %d: 0x%x\n",\r\n(int)func_no, ultmp);\r\nrtsx_write_cfg_dw(chip, func_no, 0x84, 0xFF, dstate);\r\n}\r\nrtsx_write_config_byte(chip, 0x44, dstate);\r\nrtsx_write_config_byte(chip, 0x45, 0);\r\n}\r\nvoid rtsx_enter_L1(struct rtsx_chip *chip)\r\n{\r\nrtsx_handle_pm_dstate(chip, 2);\r\n}\r\nvoid rtsx_exit_L1(struct rtsx_chip *chip)\r\n{\r\nrtsx_write_config_byte(chip, 0x44, 0);\r\nrtsx_write_config_byte(chip, 0x45, 0);\r\n}\r\nvoid rtsx_enter_ss(struct rtsx_chip *chip)\r\n{\r\ndev_dbg(rtsx_dev(chip), "Enter Selective Suspend State!\n");\r\nrtsx_write_register(chip, IRQSTAT0, LINK_RDY_INT, LINK_RDY_INT);\r\nif (chip->power_down_in_ss) {\r\nrtsx_power_off_card(chip);\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\n}\r\nif (CHK_SDIO_EXIST(chip))\r\nrtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\r\n0xC0, 0xFF00, 0x0100);\r\nif (chip->auto_delink_en) {\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x01, 0x01);\r\n} else {\r\nif (!chip->phy_debug_mode) {\r\nu32 tmp;\r\ntmp = rtsx_readl(chip, RTSX_BIER);\r\ntmp |= CARD_INT;\r\nrtsx_writel(chip, RTSX_BIER, tmp);\r\n}\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 0);\r\n}\r\nrtsx_enter_L1(chip);\r\nRTSX_CLR_DELINK(chip);\r\nrtsx_set_stat(chip, RTSX_STAT_SS);\r\n}\r\nvoid rtsx_exit_ss(struct rtsx_chip *chip)\r\n{\r\ndev_dbg(rtsx_dev(chip), "Exit Selective Suspend State!\n");\r\nrtsx_exit_L1(chip);\r\nif (chip->power_down_in_ss) {\r\nrtsx_force_power_on(chip, SSC_PDCTL | OC_PDCTL);\r\nudelay(1000);\r\n}\r\nif (RTSX_TST_DELINK(chip)) {\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 1);\r\nRTSX_CLR_DELINK(chip);\r\n} else if (chip->power_down_in_ss) {\r\nchip->need_reinit = SD_CARD | MS_CARD | XD_CARD;\r\nrtsx_reinit_cards(chip, 0);\r\n}\r\n}\r\nint rtsx_pre_handle_interrupt(struct rtsx_chip *chip)\r\n{\r\nu32 status, int_enable;\r\nbool exit_ss = false;\r\n#ifdef SUPPORT_OCP\r\nu32 ocp_int = 0;\r\nocp_int = OC_INT;\r\n#endif\r\nif (chip->ss_en) {\r\nchip->ss_counter = 0;\r\nif (rtsx_get_stat(chip) == RTSX_STAT_SS) {\r\nexit_ss = true;\r\nrtsx_exit_L1(chip);\r\nrtsx_set_stat(chip, RTSX_STAT_RUN);\r\n}\r\n}\r\nint_enable = rtsx_readl(chip, RTSX_BIER);\r\nchip->int_reg = rtsx_readl(chip, RTSX_BIPR);\r\nif (((chip->int_reg & int_enable) == 0) ||\r\n(chip->int_reg == 0xFFFFFFFF))\r\nreturn STATUS_FAIL;\r\nstatus = chip->int_reg &= (int_enable | 0x7FFFFF);\r\nif (status & CARD_INT) {\r\nchip->auto_delink_cnt = 0;\r\nif (status & SD_INT) {\r\nif (status & SD_EXIST) {\r\nset_bit(SD_NR, &chip->need_reset);\r\n} else {\r\nset_bit(SD_NR, &chip->need_release);\r\nchip->sd_reset_counter = 0;\r\nchip->sd_show_cnt = 0;\r\nclear_bit(SD_NR, &chip->need_reset);\r\n}\r\n} else {\r\nif (exit_ss && (status & SD_EXIST))\r\nset_bit(SD_NR, &chip->need_reinit);\r\n}\r\nif (!CHECK_PID(chip, 0x5288) || CHECK_BARO_PKG(chip, QFN)) {\r\nif (status & XD_INT) {\r\nif (status & XD_EXIST) {\r\nset_bit(XD_NR, &chip->need_reset);\r\n} else {\r\nset_bit(XD_NR, &chip->need_release);\r\nchip->xd_reset_counter = 0;\r\nchip->xd_show_cnt = 0;\r\nclear_bit(XD_NR, &chip->need_reset);\r\n}\r\n} else {\r\nif (exit_ss && (status & XD_EXIST))\r\nset_bit(XD_NR, &chip->need_reinit);\r\n}\r\n}\r\nif (status & MS_INT) {\r\nif (status & MS_EXIST) {\r\nset_bit(MS_NR, &chip->need_reset);\r\n} else {\r\nset_bit(MS_NR, &chip->need_release);\r\nchip->ms_reset_counter = 0;\r\nchip->ms_show_cnt = 0;\r\nclear_bit(MS_NR, &chip->need_reset);\r\n}\r\n} else {\r\nif (exit_ss && (status & MS_EXIST))\r\nset_bit(MS_NR, &chip->need_reinit);\r\n}\r\n}\r\n#ifdef SUPPORT_OCP\r\nchip->ocp_int = ocp_int & status;\r\n#endif\r\nif (chip->sd_io && (chip->int_reg & DATA_DONE_INT))\r\nchip->int_reg &= ~(u32)DATA_DONE_INT;\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid rtsx_do_before_power_down(struct rtsx_chip *chip, int pm_stat)\r\n{\r\nint retval;\r\ndev_dbg(rtsx_dev(chip), "%s, pm_stat = %d\n", __func__, pm_stat);\r\nrtsx_set_stat(chip, RTSX_STAT_SUSPEND);\r\nretval = rtsx_force_power_on(chip, SSC_PDCTL);\r\nif (retval != STATUS_SUCCESS)\r\nreturn;\r\nrtsx_release_cards(chip);\r\nrtsx_disable_bus_int(chip);\r\nturn_off_led(chip, LED_GPIO);\r\n#ifdef HW_AUTO_SWITCH_SD_BUS\r\nif (chip->sd_io) {\r\nchip->sdio_in_charge = 1;\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\r\nrtsx_write_register(chip, 0xFE70, 0x80, 0x80);\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nrtsx_write_register(chip, TLPTISTAT, 0x08, 0x08);\r\nrtsx_write_register(chip, 0xFE5A, 0x08, 0x08);\r\n}\r\n}\r\n#endif\r\nif (CHECK_PID(chip, 0x5208) && (chip->ic_version >= IC_VER_D)) {\r\nrtsx_write_register(chip, PETXCFG, 0x08, 0x08);\r\n}\r\nif (pm_stat == PM_S1) {\r\ndev_dbg(rtsx_dev(chip), "Host enter S1\n");\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03,\r\nHOST_ENTER_S1);\r\n} else if (pm_stat == PM_S3) {\r\nif (chip->s3_pwr_off_delay > 0)\r\nwait_timeout(chip->s3_pwr_off_delay);\r\ndev_dbg(rtsx_dev(chip), "Host enter S3\n");\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03,\r\nHOST_ENTER_S3);\r\n}\r\nif (chip->do_delink_before_power_down && chip->auto_delink_en)\r\nrtsx_write_register(chip, CHANGE_LINK_STATE, 0x02, 2);\r\nrtsx_force_power_down(chip, SSC_PDCTL | OC_PDCTL);\r\nchip->cur_clk = 0;\r\nchip->cur_card = 0;\r\nchip->card_exist = 0;\r\n}\r\nvoid rtsx_enable_aspm(struct rtsx_chip *chip)\r\n{\r\nif (chip->aspm_l0s_l1_en && chip->dynamic_aspm && !chip->aspm_enabled) {\r\ndev_dbg(rtsx_dev(chip), "Try to enable ASPM\n");\r\nchip->aspm_enabled = 1;\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_write_phy_register(chip, 0x07, 0);\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_write_register(chip, ASPM_FORCE_CTL, 0xF3,\r\n0x30 | chip->aspm_level[0]);\r\n} else {\r\nrtsx_write_config_byte(chip, LCTLR,\r\nchip->aspm_l0s_l1_en);\r\n}\r\nif (CHK_SDIO_EXIST(chip)) {\r\nu16 val = chip->aspm_l0s_l1_en | 0x0100;\r\nrtsx_write_cfg_dw(chip, CHECK_PID(chip, 0x5288) ? 2 : 1,\r\n0xC0, 0xFFF, val);\r\n}\r\n}\r\n}\r\nvoid rtsx_disable_aspm(struct rtsx_chip *chip)\r\n{\r\nif (CHECK_PID(chip, 0x5208))\r\nrtsx_monitor_aspm_config(chip);\r\nif (chip->aspm_l0s_l1_en && chip->dynamic_aspm && chip->aspm_enabled) {\r\ndev_dbg(rtsx_dev(chip), "Try to disable ASPM\n");\r\nchip->aspm_enabled = 0;\r\nif (chip->asic_code && CHECK_PID(chip, 0x5208))\r\nrtsx_write_phy_register(chip, 0x07, 0x0129);\r\nif (CHECK_PID(chip, 0x5208))\r\nrtsx_write_register(chip, ASPM_FORCE_CTL,\r\n0xF3, 0x30);\r\nelse\r\nrtsx_write_config_byte(chip, LCTLR, 0x00);\r\nwait_timeout(1);\r\n}\r\n}\r\nint rtsx_read_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nint i, j;\r\nu16 reg_addr;\r\nu8 *ptr;\r\nif (!buf) {\r\nrtsx_trace(chip);\r\nreturn STATUS_ERROR;\r\n}\r\nptr = buf;\r\nreg_addr = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len / 256; i++) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < 256; j++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nmemcpy(ptr, rtsx_get_cmd_data(chip), 256);\r\nptr += 256;\r\n}\r\nif (buf_len % 256) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < buf_len % 256; j++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, reg_addr++, 0, 0);\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nmemcpy(ptr, rtsx_get_cmd_data(chip), buf_len % 256);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_write_ppbuf(struct rtsx_chip *chip, u8 *buf, int buf_len)\r\n{\r\nint retval;\r\nint i, j;\r\nu16 reg_addr;\r\nu8 *ptr;\r\nif (!buf) {\r\nrtsx_trace(chip);\r\nreturn STATUS_ERROR;\r\n}\r\nptr = buf;\r\nreg_addr = PPBUF_BASE2;\r\nfor (i = 0; i < buf_len / 256; i++) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < 256; j++) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF,\r\n*ptr);\r\nptr++;\r\n}\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (buf_len % 256) {\r\nrtsx_init_cmd(chip);\r\nfor (j = 0; j < buf_len % 256; j++) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, reg_addr++, 0xFF,\r\n*ptr);\r\nptr++;\r\n}\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_check_chip_exist(struct rtsx_chip *chip)\r\n{\r\nif (rtsx_readl(chip, 0) == 0xFFFFFFFF) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_force_power_on(struct rtsx_chip *chip, u8 ctl)\r\n{\r\nint retval;\r\nu8 mask = 0;\r\nif (ctl & SSC_PDCTL)\r\nmask |= SSC_POWER_DOWN;\r\n#ifdef SUPPORT_OCP\r\nif (ctl & OC_PDCTL) {\r\nmask |= SD_OC_POWER_DOWN;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nmask |= MS_OC_POWER_DOWN;\r\n}\r\n#endif\r\nif (mask) {\r\nretval = rtsx_write_register(chip, FPDCTL, mask, 0);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (CHECK_PID(chip, 0x5288))\r\nwait_timeout(200);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rtsx_force_power_down(struct rtsx_chip *chip, u8 ctl)\r\n{\r\nint retval;\r\nu8 mask = 0, val = 0;\r\nif (ctl & SSC_PDCTL)\r\nmask |= SSC_POWER_DOWN;\r\n#ifdef SUPPORT_OCP\r\nif (ctl & OC_PDCTL) {\r\nmask |= SD_OC_POWER_DOWN;\r\nif (CHECK_LUN_MODE(chip, SD_MS_2LUN))\r\nmask |= MS_OC_POWER_DOWN;\r\n}\r\n#endif\r\nif (mask) {\r\nval = mask;\r\nretval = rtsx_write_register(chip, FPDCTL, mask, val);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}
