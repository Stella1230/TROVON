int sptlrpc_proc_enc_pool_seq_show(struct seq_file *m, void *v)\r\n{\r\nspin_lock(&page_pools.epp_lock);\r\nseq_printf(m,\r\n"physical pages: %lu\n"\r\n"pages per pool: %lu\n"\r\n"max pages: %lu\n"\r\n"max pools: %u\n"\r\n"total pages: %lu\n"\r\n"total free: %lu\n"\r\n"idle index: %lu/100\n"\r\n"last shrink: %lds\n"\r\n"last access: %lds\n"\r\n"max pages reached: %lu\n"\r\n"grows: %u\n"\r\n"grows failure: %u\n"\r\n"shrinks: %u\n"\r\n"cache access: %lu\n"\r\n"cache missing: %lu\n"\r\n"low free mark: %lu\n"\r\n"max waitqueue depth: %u\n"\r\n"max wait time: %ld/%lu\n"\r\n"out of mem: %lu\n",\r\ntotalram_pages,\r\nPAGES_PER_POOL,\r\npage_pools.epp_max_pages,\r\npage_pools.epp_max_pools,\r\npage_pools.epp_total_pages,\r\npage_pools.epp_free_pages,\r\npage_pools.epp_idle_idx,\r\n(long)(ktime_get_seconds() - page_pools.epp_last_shrink),\r\n(long)(ktime_get_seconds() - page_pools.epp_last_access),\r\npage_pools.epp_st_max_pages,\r\npage_pools.epp_st_grows,\r\npage_pools.epp_st_grow_fails,\r\npage_pools.epp_st_shrinks,\r\npage_pools.epp_st_access,\r\npage_pools.epp_st_missings,\r\npage_pools.epp_st_lowfree,\r\npage_pools.epp_st_max_wqlen,\r\npage_pools.epp_st_max_wait,\r\nmsecs_to_jiffies(MSEC_PER_SEC),\r\npage_pools.epp_st_outofmem);\r\nspin_unlock(&page_pools.epp_lock);\r\nreturn 0;\r\n}\r\nstatic void enc_pools_release_free_pages(long npages)\r\n{\r\nint p_idx, g_idx;\r\nint p_idx_max1, p_idx_max2;\r\nLASSERT(npages > 0);\r\nLASSERT(npages <= page_pools.epp_free_pages);\r\nLASSERT(page_pools.epp_free_pages <= page_pools.epp_total_pages);\r\np_idx_max2 = (page_pools.epp_total_pages - 1) / PAGES_PER_POOL;\r\npage_pools.epp_free_pages -= npages;\r\npage_pools.epp_total_pages -= npages;\r\np_idx_max1 = page_pools.epp_total_pages == 0 ? -1 :\r\n((page_pools.epp_total_pages - 1) / PAGES_PER_POOL);\r\np_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\ng_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nwhile (npages--) {\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nLASSERT(page_pools.epp_pools[p_idx][g_idx]);\r\n__free_page(page_pools.epp_pools[p_idx][g_idx]);\r\npage_pools.epp_pools[p_idx][g_idx] = NULL;\r\nif (++g_idx == PAGES_PER_POOL) {\r\np_idx++;\r\ng_idx = 0;\r\n}\r\n}\r\nwhile (p_idx_max1 < p_idx_max2) {\r\nLASSERT(page_pools.epp_pools[p_idx_max2]);\r\nkfree(page_pools.epp_pools[p_idx_max2]);\r\npage_pools.epp_pools[p_idx_max2] = NULL;\r\np_idx_max2--;\r\n}\r\n}\r\nstatic unsigned long enc_pools_shrink_count(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nif (unlikely(ktime_get_seconds() - page_pools.epp_last_access >\r\nCACHE_QUIESCENT_PERIOD)) {\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_idle_idx = IDLE_IDX_MAX;\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nLASSERT(page_pools.epp_idle_idx <= IDLE_IDX_MAX);\r\nreturn max((int)page_pools.epp_free_pages - PTLRPC_MAX_BRW_PAGES, 0) *\r\n(IDLE_IDX_MAX - page_pools.epp_idle_idx) / IDLE_IDX_MAX;\r\n}\r\nstatic unsigned long enc_pools_shrink_scan(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nspin_lock(&page_pools.epp_lock);\r\nsc->nr_to_scan = min_t(unsigned long, sc->nr_to_scan,\r\npage_pools.epp_free_pages - PTLRPC_MAX_BRW_PAGES);\r\nif (sc->nr_to_scan > 0) {\r\nenc_pools_release_free_pages(sc->nr_to_scan);\r\nCDEBUG(D_SEC, "released %ld pages, %ld left\n",\r\n(long)sc->nr_to_scan, page_pools.epp_free_pages);\r\npage_pools.epp_st_shrinks++;\r\npage_pools.epp_last_shrink = ktime_get_seconds();\r\n}\r\nspin_unlock(&page_pools.epp_lock);\r\nif (unlikely(ktime_get_seconds() - page_pools.epp_last_access >\r\nCACHE_QUIESCENT_PERIOD)) {\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_idle_idx = IDLE_IDX_MAX;\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nLASSERT(page_pools.epp_idle_idx <= IDLE_IDX_MAX);\r\nreturn sc->nr_to_scan;\r\n}\r\nstatic inline\r\nint npages_to_npools(unsigned long npages)\r\n{\r\nreturn (int)((npages + PAGES_PER_POOL - 1) / PAGES_PER_POOL);\r\n}\r\nstatic unsigned long enc_pools_cleanup(struct page ***pools, int npools)\r\n{\r\nunsigned long cleaned = 0;\r\nint i, j;\r\nfor (i = 0; i < npools; i++) {\r\nif (pools[i]) {\r\nfor (j = 0; j < PAGES_PER_POOL; j++) {\r\nif (pools[i][j]) {\r\n__free_page(pools[i][j]);\r\ncleaned++;\r\n}\r\n}\r\nkfree(pools[i]);\r\npools[i] = NULL;\r\n}\r\n}\r\nreturn cleaned;\r\n}\r\nstatic inline void enc_pools_wakeup(void)\r\n{\r\nassert_spin_locked(&page_pools.epp_lock);\r\nif (unlikely(page_pools.epp_waitqlen)) {\r\nLASSERT(waitqueue_active(&page_pools.epp_waitq));\r\nwake_up_all(&page_pools.epp_waitq);\r\n}\r\n}\r\nint get_free_pages_in_pool(void)\r\n{\r\nreturn page_pools.epp_free_pages;\r\n}\r\nint pool_is_at_full_capacity(void)\r\n{\r\nreturn (page_pools.epp_total_pages == page_pools.epp_max_pages);\r\n}\r\nvoid sptlrpc_enc_pool_put_pages(struct ptlrpc_bulk_desc *desc)\r\n{\r\nint p_idx, g_idx;\r\nint i;\r\nLASSERT(ptlrpc_is_bulk_desc_kiov(desc->bd_type));\r\nif (!GET_ENC_KIOV(desc))\r\nreturn;\r\nLASSERT(desc->bd_iov_count > 0);\r\nspin_lock(&page_pools.epp_lock);\r\np_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\ng_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nLASSERT(page_pools.epp_free_pages + desc->bd_iov_count <=\r\npage_pools.epp_total_pages);\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\nLASSERT(BD_GET_ENC_KIOV(desc, i).bv_page);\r\nLASSERT(g_idx != 0 || page_pools.epp_pools[p_idx]);\r\nLASSERT(!page_pools.epp_pools[p_idx][g_idx]);\r\npage_pools.epp_pools[p_idx][g_idx] =\r\nBD_GET_ENC_KIOV(desc, i).bv_page;\r\nif (++g_idx == PAGES_PER_POOL) {\r\np_idx++;\r\ng_idx = 0;\r\n}\r\n}\r\npage_pools.epp_free_pages += desc->bd_iov_count;\r\nenc_pools_wakeup();\r\nspin_unlock(&page_pools.epp_lock);\r\nkfree(GET_ENC_KIOV(desc));\r\nGET_ENC_KIOV(desc) = NULL;\r\n}\r\nstatic inline void enc_pools_alloc(void)\r\n{\r\nLASSERT(page_pools.epp_max_pools);\r\npage_pools.epp_pools =\r\nlibcfs_kvzalloc(page_pools.epp_max_pools *\r\nsizeof(*page_pools.epp_pools),\r\nGFP_NOFS);\r\n}\r\nstatic inline void enc_pools_free(void)\r\n{\r\nLASSERT(page_pools.epp_max_pools);\r\nLASSERT(page_pools.epp_pools);\r\nkvfree(page_pools.epp_pools);\r\n}\r\nint sptlrpc_enc_pool_init(void)\r\n{\r\npage_pools.epp_max_pages = totalram_pages / 8;\r\npage_pools.epp_max_pools = npages_to_npools(page_pools.epp_max_pages);\r\ninit_waitqueue_head(&page_pools.epp_waitq);\r\npage_pools.epp_waitqlen = 0;\r\npage_pools.epp_pages_short = 0;\r\npage_pools.epp_growing = 0;\r\npage_pools.epp_idle_idx = 0;\r\npage_pools.epp_last_shrink = ktime_get_seconds();\r\npage_pools.epp_last_access = ktime_get_seconds();\r\nspin_lock_init(&page_pools.epp_lock);\r\npage_pools.epp_total_pages = 0;\r\npage_pools.epp_free_pages = 0;\r\npage_pools.epp_st_max_pages = 0;\r\npage_pools.epp_st_grows = 0;\r\npage_pools.epp_st_grow_fails = 0;\r\npage_pools.epp_st_shrinks = 0;\r\npage_pools.epp_st_access = 0;\r\npage_pools.epp_st_missings = 0;\r\npage_pools.epp_st_lowfree = 0;\r\npage_pools.epp_st_max_wqlen = 0;\r\npage_pools.epp_st_max_wait = 0;\r\npage_pools.epp_st_outofmem = 0;\r\nenc_pools_alloc();\r\nif (!page_pools.epp_pools)\r\nreturn -ENOMEM;\r\nregister_shrinker(&pools_shrinker);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_enc_pool_fini(void)\r\n{\r\nunsigned long cleaned, npools;\r\nLASSERT(page_pools.epp_pools);\r\nLASSERT(page_pools.epp_total_pages == page_pools.epp_free_pages);\r\nunregister_shrinker(&pools_shrinker);\r\nnpools = npages_to_npools(page_pools.epp_total_pages);\r\ncleaned = enc_pools_cleanup(page_pools.epp_pools, npools);\r\nLASSERT(cleaned == page_pools.epp_total_pages);\r\nenc_pools_free();\r\nif (page_pools.epp_st_access > 0) {\r\nCDEBUG(D_SEC,\r\n"max pages %lu, grows %u, grow fails %u, shrinks %u, access %lu, missing %lu, max qlen %u, max wait %ld/%ld, out of mem %lu\n",\r\npage_pools.epp_st_max_pages, page_pools.epp_st_grows,\r\npage_pools.epp_st_grow_fails,\r\npage_pools.epp_st_shrinks, page_pools.epp_st_access,\r\npage_pools.epp_st_missings, page_pools.epp_st_max_wqlen,\r\npage_pools.epp_st_max_wait,\r\nmsecs_to_jiffies(MSEC_PER_SEC),\r\npage_pools.epp_st_outofmem);\r\n}\r\n}\r\nconst char *sptlrpc_get_hash_name(__u8 hash_alg)\r\n{\r\nreturn cfs_crypto_hash_name(cfs_hash_alg_id[hash_alg]);\r\n}\r\n__u8 sptlrpc_get_hash_alg(const char *algname)\r\n{\r\nreturn cfs_crypto_hash_alg(algname);\r\n}\r\nint bulk_sec_desc_unpack(struct lustre_msg *msg, int offset, int swabbed)\r\n{\r\nstruct ptlrpc_bulk_sec_desc *bsd;\r\nint size = msg->lm_buflens[offset];\r\nbsd = lustre_msg_buf(msg, offset, sizeof(*bsd));\r\nif (!bsd) {\r\nCERROR("Invalid bulk sec desc: size %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (swabbed)\r\n__swab32s(&bsd->bsd_nob);\r\nif (unlikely(bsd->bsd_version != 0)) {\r\nCERROR("Unexpected version %u\n", bsd->bsd_version);\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(bsd->bsd_type >= SPTLRPC_BULK_MAX)) {\r\nCERROR("Invalid type %u\n", bsd->bsd_type);\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(bsd->bsd_svc != SPTLRPC_BULK_SVC_NULL &&\r\nbsd->bsd_svc != SPTLRPC_BULK_SVC_INTG &&\r\nbsd->bsd_svc != SPTLRPC_BULK_SVC_PRIV)) {\r\nCERROR("Invalid svc %u\n", bsd->bsd_svc);\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_get_bulk_checksum(struct ptlrpc_bulk_desc *desc, __u8 alg,\r\nvoid *buf, int buflen)\r\n{\r\nstruct cfs_crypto_hash_desc *hdesc;\r\nint hashsize;\r\nunsigned int bufsize;\r\nint i, err;\r\nLASSERT(alg > BULK_HASH_ALG_NULL && alg < BULK_HASH_ALG_MAX);\r\nLASSERT(buflen >= 4);\r\nhdesc = cfs_crypto_hash_init(cfs_hash_alg_id[alg], NULL, 0);\r\nif (IS_ERR(hdesc)) {\r\nCERROR("Unable to initialize checksum hash %s\n",\r\ncfs_crypto_hash_name(cfs_hash_alg_id[alg]));\r\nreturn PTR_ERR(hdesc);\r\n}\r\nhashsize = cfs_crypto_hash_digestsize(cfs_hash_alg_id[alg]);\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\ncfs_crypto_hash_update_page(hdesc,\r\nBD_GET_KIOV(desc, i).bv_page,\r\nBD_GET_KIOV(desc, i).bv_offset &\r\n~PAGE_MASK,\r\nBD_GET_KIOV(desc, i).bv_len);\r\n}\r\nif (hashsize > buflen) {\r\nunsigned char hashbuf[CFS_CRYPTO_HASH_DIGESTSIZE_MAX];\r\nbufsize = sizeof(hashbuf);\r\nLASSERTF(bufsize >= hashsize, "bufsize = %u < hashsize %u\n",\r\nbufsize, hashsize);\r\nerr = cfs_crypto_hash_final(hdesc, hashbuf, &bufsize);\r\nmemcpy(buf, hashbuf, buflen);\r\n} else {\r\nbufsize = buflen;\r\nerr = cfs_crypto_hash_final(hdesc, buf, &bufsize);\r\n}\r\nreturn err;\r\n}
