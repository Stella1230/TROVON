static inline int _step_to_temp(int step)\r\n{\r\nreturn (HISI_TEMP_BASE * 1000 + (step * 200000 / 255));\r\n}\r\nstatic inline long _temp_to_step(long temp)\r\n{\r\nreturn ((temp - HISI_TEMP_BASE * 1000) * 255) / 200000;\r\n}\r\nstatic long hisi_thermal_get_sensor_temp(struct hisi_thermal_data *data,\r\nstruct hisi_thermal_sensor *sensor)\r\n{\r\nlong val;\r\nmutex_lock(&data->thermal_lock);\r\nwritel(0x0, data->regs + TEMP0_INT_EN);\r\nwritel(0x1, data->regs + TEMP0_INT_CLR);\r\nwritel(0x0, data->regs + TEMP0_EN);\r\nwritel((sensor->id << 12), data->regs + TEMP0_CFG);\r\nwritel(0x1, data->regs + TEMP0_EN);\r\nusleep_range(3000, 5000);\r\nval = readl(data->regs + TEMP0_VALUE);\r\nval = _step_to_temp(val);\r\nmutex_unlock(&data->thermal_lock);\r\nreturn val;\r\n}\r\nstatic void hisi_thermal_enable_bind_irq_sensor\r\n(struct hisi_thermal_data *data)\r\n{\r\nstruct hisi_thermal_sensor *sensor;\r\nmutex_lock(&data->thermal_lock);\r\nsensor = &data->sensors[data->irq_bind_sensor];\r\nwritel(0x0, data->regs + TEMP0_CFG);\r\nwritel(0x0, data->regs + TEMP0_RST_MSK);\r\nwritel(0x0, data->regs + TEMP0_EN);\r\nwritel((sensor->id << 12), data->regs + TEMP0_CFG);\r\nwritel(_temp_to_step(sensor->thres_temp) | 0x0FFFFFF00,\r\ndata->regs + TEMP0_TH);\r\nwritel(_temp_to_step(HISI_TEMP_RESET), data->regs + TEMP0_RST_TH);\r\nwritel(0x1, data->regs + TEMP0_RST_MSK);\r\nwritel(0x1, data->regs + TEMP0_EN);\r\nwritel(0x0, data->regs + TEMP0_INT_CLR);\r\nwritel(0x1, data->regs + TEMP0_INT_EN);\r\nusleep_range(3000, 5000);\r\nmutex_unlock(&data->thermal_lock);\r\n}\r\nstatic void hisi_thermal_disable_sensor(struct hisi_thermal_data *data)\r\n{\r\nmutex_lock(&data->thermal_lock);\r\nwritel(0x0, data->regs + TEMP0_INT_EN);\r\nwritel(0x0, data->regs + TEMP0_RST_MSK);\r\nwritel(0x0, data->regs + TEMP0_EN);\r\nmutex_unlock(&data->thermal_lock);\r\n}\r\nstatic int hisi_thermal_get_temp(void *_sensor, int *temp)\r\n{\r\nstruct hisi_thermal_sensor *sensor = _sensor;\r\nstruct hisi_thermal_data *data = sensor->thermal;\r\nint sensor_id = -1, i;\r\nlong max_temp = 0;\r\n*temp = hisi_thermal_get_sensor_temp(data, sensor);\r\nsensor->sensor_temp = *temp;\r\nfor (i = 0; i < HISI_MAX_SENSORS; i++) {\r\nif (!data->sensors[i].tzd)\r\ncontinue;\r\nif (data->sensors[i].sensor_temp >= max_temp) {\r\nmax_temp = data->sensors[i].sensor_temp;\r\nsensor_id = i;\r\n}\r\n}\r\nif (sensor_id == -1)\r\nreturn 0;\r\nmutex_lock(&data->thermal_lock);\r\ndata->irq_bind_sensor = sensor_id;\r\nmutex_unlock(&data->thermal_lock);\r\ndev_dbg(&data->pdev->dev, "id=%d, irq=%d, temp=%d, thres=%d\n",\r\nsensor->id, data->irq_enabled, *temp, sensor->thres_temp);\r\nif (data->irq_enabled) {\r\nhisi_thermal_enable_bind_irq_sensor(data);\r\nreturn 0;\r\n}\r\nif (max_temp < sensor->thres_temp) {\r\ndata->irq_enabled = true;\r\nhisi_thermal_enable_bind_irq_sensor(data);\r\nenable_irq(data->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hisi_thermal_alarm_irq(int irq, void *dev)\r\n{\r\nstruct hisi_thermal_data *data = dev;\r\ndisable_irq_nosync(irq);\r\ndata->irq_enabled = false;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t hisi_thermal_alarm_irq_thread(int irq, void *dev)\r\n{\r\nstruct hisi_thermal_data *data = dev;\r\nstruct hisi_thermal_sensor *sensor;\r\nint i;\r\nmutex_lock(&data->thermal_lock);\r\nsensor = &data->sensors[data->irq_bind_sensor];\r\ndev_crit(&data->pdev->dev, "THERMAL ALARM: T > %d\n",\r\nsensor->thres_temp / 1000);\r\nmutex_unlock(&data->thermal_lock);\r\nfor (i = 0; i < HISI_MAX_SENSORS; i++) {\r\nif (!data->sensors[i].tzd)\r\ncontinue;\r\nthermal_zone_device_update(data->sensors[i].tzd,\r\nTHERMAL_EVENT_UNSPECIFIED);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hisi_thermal_register_sensor(struct platform_device *pdev,\r\nstruct hisi_thermal_data *data,\r\nstruct hisi_thermal_sensor *sensor,\r\nint index)\r\n{\r\nint ret, i;\r\nconst struct thermal_trip *trip;\r\nsensor->id = index;\r\nsensor->thermal = data;\r\nsensor->tzd = devm_thermal_zone_of_sensor_register(&pdev->dev,\r\nsensor->id, sensor, &hisi_of_thermal_ops);\r\nif (IS_ERR(sensor->tzd)) {\r\nret = PTR_ERR(sensor->tzd);\r\nsensor->tzd = NULL;\r\ndev_err(&pdev->dev, "failed to register sensor id %d: %d\n",\r\nsensor->id, ret);\r\nreturn ret;\r\n}\r\ntrip = of_thermal_get_trip_points(sensor->tzd);\r\nfor (i = 0; i < of_thermal_get_ntrips(sensor->tzd); i++) {\r\nif (trip[i].type == THERMAL_TRIP_PASSIVE) {\r\nsensor->thres_temp = trip[i].temperature;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hisi_thermal_toggle_sensor(struct hisi_thermal_sensor *sensor,\r\nbool on)\r\n{\r\nstruct thermal_zone_device *tzd = sensor->tzd;\r\ntzd->ops->set_mode(tzd,\r\non ? THERMAL_DEVICE_ENABLED : THERMAL_DEVICE_DISABLED);\r\n}\r\nstatic int hisi_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct hisi_thermal_data *data;\r\nstruct resource *res;\r\nint i;\r\nint ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->thermal_lock);\r\ndata->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndata->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(data->regs)) {\r\ndev_err(&pdev->dev, "failed to get io address\n");\r\nreturn PTR_ERR(data->regs);\r\n}\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0)\r\nreturn data->irq;\r\nret = devm_request_threaded_irq(&pdev->dev, data->irq,\r\nhisi_thermal_alarm_irq,\r\nhisi_thermal_alarm_irq_thread,\r\n0, "hisi_thermal", data);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request alarm irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\ndata->clk = devm_clk_get(&pdev->dev, "thermal_clk");\r\nif (IS_ERR(data->clk)) {\r\nret = PTR_ERR(data->clk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"failed to get thermal clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable thermal clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nhisi_thermal_enable_bind_irq_sensor(data);\r\nirq_get_irqchip_state(data->irq, IRQCHIP_STATE_MASKED,\r\n&data->irq_enabled);\r\nfor (i = 0; i < HISI_MAX_SENSORS; ++i) {\r\nret = hisi_thermal_register_sensor(pdev, data,\r\n&data->sensors[i], i);\r\nif (ret)\r\ndev_err(&pdev->dev,\r\n"failed to register thermal sensor: %d\n", ret);\r\nelse\r\nhisi_thermal_toggle_sensor(&data->sensors[i], true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hisi_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct hisi_thermal_data *data = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < HISI_MAX_SENSORS; i++) {\r\nstruct hisi_thermal_sensor *sensor = &data->sensors[i];\r\nif (!sensor->tzd)\r\ncontinue;\r\nhisi_thermal_toggle_sensor(sensor, false);\r\n}\r\nhisi_thermal_disable_sensor(data);\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int hisi_thermal_suspend(struct device *dev)\r\n{\r\nstruct hisi_thermal_data *data = dev_get_drvdata(dev);\r\nhisi_thermal_disable_sensor(data);\r\ndata->irq_enabled = false;\r\nclk_disable_unprepare(data->clk);\r\nreturn 0;\r\n}\r\nstatic int hisi_thermal_resume(struct device *dev)\r\n{\r\nstruct hisi_thermal_data *data = dev_get_drvdata(dev);\r\nclk_prepare_enable(data->clk);\r\ndata->irq_enabled = true;\r\nhisi_thermal_enable_bind_irq_sensor(data);\r\nreturn 0;\r\n}
