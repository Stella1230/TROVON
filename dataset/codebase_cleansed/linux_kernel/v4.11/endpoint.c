static inline unsigned get_usb_full_speed_rate(unsigned int rate)\r\n{\r\nreturn ((rate << 13) + 62) / 125;\r\n}\r\nstatic inline unsigned get_usb_high_speed_rate(unsigned int rate)\r\n{\r\nreturn ((rate << 10) + 62) / 125;\r\n}\r\nstatic void release_urb_ctx(struct snd_urb_ctx *u)\r\n{\r\nif (u->buffer_size)\r\nusb_free_coherent(u->ep->chip->dev, u->buffer_size,\r\nu->urb->transfer_buffer,\r\nu->urb->transfer_dma);\r\nusb_free_urb(u->urb);\r\nu->urb = NULL;\r\n}\r\nstatic const char *usb_error_string(int err)\r\n{\r\nswitch (err) {\r\ncase -ENODEV:\r\nreturn "no device";\r\ncase -ENOENT:\r\nreturn "endpoint not enabled";\r\ncase -EPIPE:\r\nreturn "endpoint stalled";\r\ncase -ENOSPC:\r\nreturn "not enough bandwidth";\r\ncase -ESHUTDOWN:\r\nreturn "device disabled";\r\ncase -EHOSTUNREACH:\r\nreturn "device suspended";\r\ncase -EINVAL:\r\ncase -EAGAIN:\r\ncase -EFBIG:\r\ncase -EMSGSIZE:\r\nreturn "internal error";\r\ndefault:\r\nreturn "unknown error";\r\n}\r\n}\r\nint snd_usb_endpoint_implicit_feedback_sink(struct snd_usb_endpoint *ep)\r\n{\r\nreturn ep->sync_master &&\r\nep->sync_master->type == SND_USB_ENDPOINT_TYPE_DATA &&\r\nep->type == SND_USB_ENDPOINT_TYPE_DATA &&\r\nusb_pipeout(ep->pipe);\r\n}\r\nint snd_usb_endpoint_next_packet_size(struct snd_usb_endpoint *ep)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nif (ep->fill_max)\r\nreturn ep->maxframesize;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nep->phase = (ep->phase & 0xffff)\r\n+ (ep->freqm << ep->datainterval);\r\nret = min(ep->phase >> 16, ep->maxframesize);\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void retire_outbound_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_urb_ctx *urb_ctx)\r\n{\r\nif (ep->retire_data_urb)\r\nep->retire_data_urb(ep->data_subs, urb_ctx->urb);\r\n}\r\nstatic void retire_inbound_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_urb_ctx *urb_ctx)\r\n{\r\nstruct urb *urb = urb_ctx->urb;\r\nif (unlikely(ep->skip_packets > 0)) {\r\nep->skip_packets--;\r\nreturn;\r\n}\r\nif (ep->sync_slave)\r\nsnd_usb_handle_sync_urb(ep->sync_slave, ep, urb);\r\nif (ep->retire_data_urb)\r\nep->retire_data_urb(ep->data_subs, urb);\r\n}\r\nstatic void prepare_silent_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_urb_ctx *ctx)\r\n{\r\nstruct urb *urb = ctx->urb;\r\nunsigned int offs = 0;\r\nunsigned int extra = 0;\r\n__le32 packet_length;\r\nint i;\r\nif (ep->chip->tx_length_quirk)\r\nextra = sizeof(packet_length);\r\nfor (i = 0; i < ctx->packets; ++i) {\r\nunsigned int offset;\r\nunsigned int length;\r\nint counts;\r\nif (ctx->packet_size[i])\r\ncounts = ctx->packet_size[i];\r\nelse\r\ncounts = snd_usb_endpoint_next_packet_size(ep);\r\nlength = counts * ep->stride;\r\noffset = offs * ep->stride + extra * i;\r\nurb->iso_frame_desc[i].offset = offset;\r\nurb->iso_frame_desc[i].length = length + extra;\r\nif (extra) {\r\npacket_length = cpu_to_le32(length);\r\nmemcpy(urb->transfer_buffer + offset,\r\n&packet_length, sizeof(packet_length));\r\n}\r\nmemset(urb->transfer_buffer + offset + extra,\r\nep->silence_value, length);\r\noffs += counts;\r\n}\r\nurb->number_of_packets = ctx->packets;\r\nurb->transfer_buffer_length = offs * ep->stride + ctx->packets * extra;\r\n}\r\nstatic void prepare_outbound_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_urb_ctx *ctx)\r\n{\r\nstruct urb *urb = ctx->urb;\r\nunsigned char *cp = urb->transfer_buffer;\r\nurb->dev = ep->chip->dev;\r\nswitch (ep->type) {\r\ncase SND_USB_ENDPOINT_TYPE_DATA:\r\nif (ep->prepare_data_urb) {\r\nep->prepare_data_urb(ep->data_subs, urb);\r\n} else {\r\nprepare_silent_urb(ep, ctx);\r\n}\r\nbreak;\r\ncase SND_USB_ENDPOINT_TYPE_SYNC:\r\nif (snd_usb_get_speed(ep->chip->dev) >= USB_SPEED_HIGH) {\r\nurb->iso_frame_desc[0].length = 4;\r\nurb->iso_frame_desc[0].offset = 0;\r\ncp[0] = ep->freqn;\r\ncp[1] = ep->freqn >> 8;\r\ncp[2] = ep->freqn >> 16;\r\ncp[3] = ep->freqn >> 24;\r\n} else {\r\nurb->iso_frame_desc[0].length = 3;\r\nurb->iso_frame_desc[0].offset = 0;\r\ncp[0] = ep->freqn >> 2;\r\ncp[1] = ep->freqn >> 10;\r\ncp[2] = ep->freqn >> 18;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic inline void prepare_inbound_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_urb_ctx *urb_ctx)\r\n{\r\nint i, offs;\r\nstruct urb *urb = urb_ctx->urb;\r\nurb->dev = ep->chip->dev;\r\nswitch (ep->type) {\r\ncase SND_USB_ENDPOINT_TYPE_DATA:\r\noffs = 0;\r\nfor (i = 0; i < urb_ctx->packets; i++) {\r\nurb->iso_frame_desc[i].offset = offs;\r\nurb->iso_frame_desc[i].length = ep->curpacksize;\r\noffs += ep->curpacksize;\r\n}\r\nurb->transfer_buffer_length = offs;\r\nurb->number_of_packets = urb_ctx->packets;\r\nbreak;\r\ncase SND_USB_ENDPOINT_TYPE_SYNC:\r\nurb->iso_frame_desc[0].length = min(4u, ep->syncmaxsize);\r\nurb->iso_frame_desc[0].offset = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void queue_pending_output_urbs(struct snd_usb_endpoint *ep)\r\n{\r\nwhile (test_bit(EP_FLAG_RUNNING, &ep->flags)) {\r\nunsigned long flags;\r\nstruct snd_usb_packet_info *uninitialized_var(packet);\r\nstruct snd_urb_ctx *ctx = NULL;\r\nstruct urb *urb;\r\nint err, i;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nif (ep->next_packet_read_pos != ep->next_packet_write_pos) {\r\npacket = ep->next_packet + ep->next_packet_read_pos;\r\nep->next_packet_read_pos++;\r\nep->next_packet_read_pos %= MAX_URBS;\r\nif (!list_empty(&ep->ready_playback_urbs))\r\nctx = list_first_entry(&ep->ready_playback_urbs,\r\nstruct snd_urb_ctx, ready_list);\r\n}\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nif (ctx == NULL)\r\nreturn;\r\nlist_del_init(&ctx->ready_list);\r\nurb = ctx->urb;\r\nfor (i = 0; i < packet->packets; i++)\r\nctx->packet_size[i] = packet->packet_size[i];\r\nprepare_outbound_urb(ep, ctx);\r\nerr = usb_submit_urb(ctx->urb, GFP_ATOMIC);\r\nif (err < 0)\r\nusb_audio_err(ep->chip,\r\n"Unable to submit urb #%d: %d (urb %p)\n",\r\nctx->index, err, ctx->urb);\r\nelse\r\nset_bit(ctx->index, &ep->active_mask);\r\n}\r\n}\r\nstatic void snd_complete_urb(struct urb *urb)\r\n{\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nstruct snd_usb_endpoint *ep = ctx->ep;\r\nstruct snd_pcm_substream *substream;\r\nunsigned long flags;\r\nint err;\r\nif (unlikely(urb->status == -ENOENT ||\r\nurb->status == -ENODEV ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ngoto exit_clear;\r\nif (unlikely(atomic_read(&ep->chip->shutdown)))\r\ngoto exit_clear;\r\nif (unlikely(!test_bit(EP_FLAG_RUNNING, &ep->flags)))\r\ngoto exit_clear;\r\nif (usb_pipeout(ep->pipe)) {\r\nretire_outbound_urb(ep, ctx);\r\nif (unlikely(!test_bit(EP_FLAG_RUNNING, &ep->flags)))\r\ngoto exit_clear;\r\nif (snd_usb_endpoint_implicit_feedback_sink(ep)) {\r\nspin_lock_irqsave(&ep->lock, flags);\r\nlist_add_tail(&ctx->ready_list, &ep->ready_playback_urbs);\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nqueue_pending_output_urbs(ep);\r\ngoto exit_clear;\r\n}\r\nprepare_outbound_urb(ep, ctx);\r\n} else {\r\nretire_inbound_urb(ep, ctx);\r\nif (unlikely(!test_bit(EP_FLAG_RUNNING, &ep->flags)))\r\ngoto exit_clear;\r\nprepare_inbound_urb(ep, ctx);\r\n}\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err == 0)\r\nreturn;\r\nusb_audio_err(ep->chip, "cannot submit urb (err = %d)\n", err);\r\nif (ep->data_subs && ep->data_subs->pcm_substream) {\r\nsubstream = ep->data_subs->pcm_substream;\r\nsnd_pcm_stop_xrun(substream);\r\n}\r\nexit_clear:\r\nclear_bit(ctx->index, &ep->active_mask);\r\n}\r\nstruct snd_usb_endpoint *snd_usb_add_endpoint(struct snd_usb_audio *chip,\r\nstruct usb_host_interface *alts,\r\nint ep_num, int direction, int type)\r\n{\r\nstruct snd_usb_endpoint *ep;\r\nint is_playback = direction == SNDRV_PCM_STREAM_PLAYBACK;\r\nif (WARN_ON(!alts))\r\nreturn NULL;\r\nmutex_lock(&chip->mutex);\r\nlist_for_each_entry(ep, &chip->ep_list, list) {\r\nif (ep->ep_num == ep_num &&\r\nep->iface == alts->desc.bInterfaceNumber &&\r\nep->altsetting == alts->desc.bAlternateSetting) {\r\nusb_audio_dbg(ep->chip,\r\n"Re-using EP %x in iface %d,%d @%p\n",\r\nep_num, ep->iface, ep->altsetting, ep);\r\ngoto __exit_unlock;\r\n}\r\n}\r\nusb_audio_dbg(chip, "Creating new %s %s endpoint #%x\n",\r\nis_playback ? "playback" : "capture",\r\ntype == SND_USB_ENDPOINT_TYPE_DATA ? "data" : "sync",\r\nep_num);\r\nep = kzalloc(sizeof(*ep), GFP_KERNEL);\r\nif (!ep)\r\ngoto __exit_unlock;\r\nep->chip = chip;\r\nspin_lock_init(&ep->lock);\r\nep->type = type;\r\nep->ep_num = ep_num;\r\nep->iface = alts->desc.bInterfaceNumber;\r\nep->altsetting = alts->desc.bAlternateSetting;\r\nINIT_LIST_HEAD(&ep->ready_playback_urbs);\r\nep_num &= USB_ENDPOINT_NUMBER_MASK;\r\nif (is_playback)\r\nep->pipe = usb_sndisocpipe(chip->dev, ep_num);\r\nelse\r\nep->pipe = usb_rcvisocpipe(chip->dev, ep_num);\r\nif (type == SND_USB_ENDPOINT_TYPE_SYNC) {\r\nif (get_endpoint(alts, 1)->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE &&\r\nget_endpoint(alts, 1)->bRefresh >= 1 &&\r\nget_endpoint(alts, 1)->bRefresh <= 9)\r\nep->syncinterval = get_endpoint(alts, 1)->bRefresh;\r\nelse if (snd_usb_get_speed(chip->dev) == USB_SPEED_FULL)\r\nep->syncinterval = 1;\r\nelse if (get_endpoint(alts, 1)->bInterval >= 1 &&\r\nget_endpoint(alts, 1)->bInterval <= 16)\r\nep->syncinterval = get_endpoint(alts, 1)->bInterval - 1;\r\nelse\r\nep->syncinterval = 3;\r\nep->syncmaxsize = le16_to_cpu(get_endpoint(alts, 1)->wMaxPacketSize);\r\n}\r\nlist_add_tail(&ep->list, &chip->ep_list);\r\n__exit_unlock:\r\nmutex_unlock(&chip->mutex);\r\nreturn ep;\r\n}\r\nstatic int wait_clear_urbs(struct snd_usb_endpoint *ep)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(1000);\r\nint alive;\r\ndo {\r\nalive = bitmap_weight(&ep->active_mask, ep->nurbs);\r\nif (!alive)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\nif (alive)\r\nusb_audio_err(ep->chip,\r\n"timeout: still %d active urbs on EP #%x\n",\r\nalive, ep->ep_num);\r\nclear_bit(EP_FLAG_STOPPING, &ep->flags);\r\nep->data_subs = NULL;\r\nep->sync_slave = NULL;\r\nep->retire_data_urb = NULL;\r\nep->prepare_data_urb = NULL;\r\nreturn 0;\r\n}\r\nvoid snd_usb_endpoint_sync_pending_stop(struct snd_usb_endpoint *ep)\r\n{\r\nif (ep && test_bit(EP_FLAG_STOPPING, &ep->flags))\r\nwait_clear_urbs(ep);\r\n}\r\nstatic int deactivate_urbs(struct snd_usb_endpoint *ep, bool force)\r\n{\r\nunsigned int i;\r\nif (!force && atomic_read(&ep->chip->shutdown))\r\nreturn -EBADFD;\r\nclear_bit(EP_FLAG_RUNNING, &ep->flags);\r\nINIT_LIST_HEAD(&ep->ready_playback_urbs);\r\nep->next_packet_read_pos = 0;\r\nep->next_packet_write_pos = 0;\r\nfor (i = 0; i < ep->nurbs; i++) {\r\nif (test_bit(i, &ep->active_mask)) {\r\nif (!test_and_set_bit(i, &ep->unlink_mask)) {\r\nstruct urb *u = ep->urb[i].urb;\r\nusb_unlink_urb(u);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_urbs(struct snd_usb_endpoint *ep, int force)\r\n{\r\nint i;\r\nep->retire_data_urb = NULL;\r\nep->prepare_data_urb = NULL;\r\ndeactivate_urbs(ep, force);\r\nwait_clear_urbs(ep);\r\nfor (i = 0; i < ep->nurbs; i++)\r\nrelease_urb_ctx(&ep->urb[i]);\r\nif (ep->syncbuf)\r\nusb_free_coherent(ep->chip->dev, SYNC_URBS * 4,\r\nep->syncbuf, ep->sync_dma);\r\nep->syncbuf = NULL;\r\nep->nurbs = 0;\r\n}\r\nstatic int data_ep_set_params(struct snd_usb_endpoint *ep,\r\nsnd_pcm_format_t pcm_format,\r\nunsigned int channels,\r\nunsigned int period_bytes,\r\nunsigned int frames_per_period,\r\nunsigned int periods_per_buffer,\r\nstruct audioformat *fmt,\r\nstruct snd_usb_endpoint *sync_ep)\r\n{\r\nunsigned int maxsize, minsize, packs_per_ms, max_packs_per_urb;\r\nunsigned int max_packs_per_period, urbs_per_period, urb_packs;\r\nunsigned int max_urbs, i;\r\nint frame_bits = snd_pcm_format_physical_width(pcm_format) * channels;\r\nint tx_length_quirk = (ep->chip->tx_length_quirk &&\r\nusb_pipeout(ep->pipe));\r\nif (pcm_format == SNDRV_PCM_FORMAT_DSD_U16_LE && fmt->dsd_dop) {\r\nframe_bits += channels << 3;\r\n}\r\nep->datainterval = fmt->datainterval;\r\nep->stride = frame_bits >> 3;\r\nswitch (pcm_format) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\nep->silence_value = 0x80;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_DSD_U8:\r\ncase SNDRV_PCM_FORMAT_DSD_U16_LE:\r\ncase SNDRV_PCM_FORMAT_DSD_U32_LE:\r\ncase SNDRV_PCM_FORMAT_DSD_U16_BE:\r\ncase SNDRV_PCM_FORMAT_DSD_U32_BE:\r\nep->silence_value = 0x69;\r\nbreak;\r\ndefault:\r\nep->silence_value = 0;\r\n}\r\nep->freqmax = ep->freqn + (ep->freqn >> 1);\r\nmaxsize = (((ep->freqmax << ep->datainterval) + 0xffff) >> 16) *\r\n(frame_bits >> 3);\r\nif (tx_length_quirk)\r\nmaxsize += sizeof(__le32);\r\nif (ep->maxpacksize && ep->maxpacksize < maxsize) {\r\nunsigned int data_maxsize = maxsize = ep->maxpacksize;\r\nif (tx_length_quirk)\r\ndata_maxsize -= sizeof(__le32);\r\nep->freqmax = (data_maxsize / (frame_bits >> 3))\r\n<< (16 - ep->datainterval);\r\n}\r\nif (ep->fill_max)\r\nep->curpacksize = ep->maxpacksize;\r\nelse\r\nep->curpacksize = maxsize;\r\nif (snd_usb_get_speed(ep->chip->dev) != USB_SPEED_FULL) {\r\npacks_per_ms = 8 >> ep->datainterval;\r\nmax_packs_per_urb = MAX_PACKS_HS;\r\n} else {\r\npacks_per_ms = 1;\r\nmax_packs_per_urb = MAX_PACKS;\r\n}\r\nif (sync_ep && !snd_usb_endpoint_implicit_feedback_sink(ep))\r\nmax_packs_per_urb = min(max_packs_per_urb,\r\n1U << sync_ep->syncinterval);\r\nmax_packs_per_urb = max(1u, max_packs_per_urb >> ep->datainterval);\r\nif (usb_pipein(ep->pipe) ||\r\nsnd_usb_endpoint_implicit_feedback_sink(ep)) {\r\nurb_packs = packs_per_ms;\r\nif (snd_usb_get_speed(ep->chip->dev) == USB_SPEED_WIRELESS) {\r\nint interval = ep->datainterval;\r\nwhile (interval < 5) {\r\nurb_packs <<= 1;\r\n++interval;\r\n}\r\n}\r\nurb_packs = min(max_packs_per_urb, urb_packs);\r\nwhile (urb_packs > 1 && urb_packs * maxsize >= period_bytes)\r\nurb_packs >>= 1;\r\nep->nurbs = MAX_URBS;\r\n} else {\r\nminsize = (ep->freqn >> (16 - ep->datainterval)) *\r\n(frame_bits >> 3);\r\nif (sync_ep)\r\nminsize -= minsize >> 3;\r\nminsize = max(minsize, 1u);\r\nmax_packs_per_period = DIV_ROUND_UP(period_bytes, minsize);\r\nurbs_per_period = DIV_ROUND_UP(max_packs_per_period,\r\nmax_packs_per_urb);\r\nurb_packs = DIV_ROUND_UP(max_packs_per_period, urbs_per_period);\r\nep->max_urb_frames = DIV_ROUND_UP(frames_per_period,\r\nurbs_per_period);\r\nmax_urbs = min((unsigned) MAX_URBS,\r\nMAX_QUEUE * packs_per_ms / urb_packs);\r\nep->nurbs = min(max_urbs, urbs_per_period * periods_per_buffer);\r\n}\r\nfor (i = 0; i < ep->nurbs; i++) {\r\nstruct snd_urb_ctx *u = &ep->urb[i];\r\nu->index = i;\r\nu->ep = ep;\r\nu->packets = urb_packs;\r\nu->buffer_size = maxsize * u->packets;\r\nif (fmt->fmt_type == UAC_FORMAT_TYPE_II)\r\nu->packets++;\r\nu->urb = usb_alloc_urb(u->packets, GFP_KERNEL);\r\nif (!u->urb)\r\ngoto out_of_memory;\r\nu->urb->transfer_buffer =\r\nusb_alloc_coherent(ep->chip->dev, u->buffer_size,\r\nGFP_KERNEL, &u->urb->transfer_dma);\r\nif (!u->urb->transfer_buffer)\r\ngoto out_of_memory;\r\nu->urb->pipe = ep->pipe;\r\nu->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nu->urb->interval = 1 << ep->datainterval;\r\nu->urb->context = u;\r\nu->urb->complete = snd_complete_urb;\r\nINIT_LIST_HEAD(&u->ready_list);\r\n}\r\nreturn 0;\r\nout_of_memory:\r\nrelease_urbs(ep, 0);\r\nreturn -ENOMEM;\r\n}\r\nstatic int sync_ep_set_params(struct snd_usb_endpoint *ep)\r\n{\r\nint i;\r\nep->syncbuf = usb_alloc_coherent(ep->chip->dev, SYNC_URBS * 4,\r\nGFP_KERNEL, &ep->sync_dma);\r\nif (!ep->syncbuf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nstruct snd_urb_ctx *u = &ep->urb[i];\r\nu->index = i;\r\nu->ep = ep;\r\nu->packets = 1;\r\nu->urb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!u->urb)\r\ngoto out_of_memory;\r\nu->urb->transfer_buffer = ep->syncbuf + i * 4;\r\nu->urb->transfer_dma = ep->sync_dma + i * 4;\r\nu->urb->transfer_buffer_length = 4;\r\nu->urb->pipe = ep->pipe;\r\nu->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nu->urb->number_of_packets = 1;\r\nu->urb->interval = 1 << ep->syncinterval;\r\nu->urb->context = u;\r\nu->urb->complete = snd_complete_urb;\r\n}\r\nep->nurbs = SYNC_URBS;\r\nreturn 0;\r\nout_of_memory:\r\nrelease_urbs(ep, 0);\r\nreturn -ENOMEM;\r\n}\r\nint snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,\r\nsnd_pcm_format_t pcm_format,\r\nunsigned int channels,\r\nunsigned int period_bytes,\r\nunsigned int period_frames,\r\nunsigned int buffer_periods,\r\nunsigned int rate,\r\nstruct audioformat *fmt,\r\nstruct snd_usb_endpoint *sync_ep)\r\n{\r\nint err;\r\nif (ep->use_count != 0) {\r\nusb_audio_warn(ep->chip,\r\n"Unable to change format on ep #%x: already in use\n",\r\nep->ep_num);\r\nreturn -EBUSY;\r\n}\r\nrelease_urbs(ep, 0);\r\nep->datainterval = fmt->datainterval;\r\nep->maxpacksize = fmt->maxpacksize;\r\nep->fill_max = !!(fmt->attributes & UAC_EP_CS_ATTR_FILL_MAX);\r\nif (snd_usb_get_speed(ep->chip->dev) == USB_SPEED_FULL)\r\nep->freqn = get_usb_full_speed_rate(rate);\r\nelse\r\nep->freqn = get_usb_high_speed_rate(rate);\r\nep->freqm = ep->freqn;\r\nep->freqshift = INT_MIN;\r\nep->phase = 0;\r\nswitch (ep->type) {\r\ncase SND_USB_ENDPOINT_TYPE_DATA:\r\nerr = data_ep_set_params(ep, pcm_format, channels,\r\nperiod_bytes, period_frames,\r\nbuffer_periods, fmt, sync_ep);\r\nbreak;\r\ncase SND_USB_ENDPOINT_TYPE_SYNC:\r\nerr = sync_ep_set_params(ep);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nusb_audio_dbg(ep->chip,\r\n"Setting params for ep #%x (type %d, %d urbs), ret=%d\n",\r\nep->ep_num, ep->type, ep->nurbs, err);\r\nreturn err;\r\n}\r\nint snd_usb_endpoint_start(struct snd_usb_endpoint *ep)\r\n{\r\nint err;\r\nunsigned int i;\r\nif (atomic_read(&ep->chip->shutdown))\r\nreturn -EBADFD;\r\nif (++ep->use_count != 1)\r\nreturn 0;\r\ndeactivate_urbs(ep, false);\r\nep->active_mask = 0;\r\nep->unlink_mask = 0;\r\nep->phase = 0;\r\nsnd_usb_endpoint_start_quirk(ep);\r\nset_bit(EP_FLAG_RUNNING, &ep->flags);\r\nif (snd_usb_endpoint_implicit_feedback_sink(ep)) {\r\nfor (i = 0; i < ep->nurbs; i++) {\r\nstruct snd_urb_ctx *ctx = ep->urb + i;\r\nlist_add_tail(&ctx->ready_list, &ep->ready_playback_urbs);\r\n}\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ep->nurbs; i++) {\r\nstruct urb *urb = ep->urb[i].urb;\r\nif (snd_BUG_ON(!urb))\r\ngoto __error;\r\nif (usb_pipeout(ep->pipe)) {\r\nprepare_outbound_urb(ep, urb->context);\r\n} else {\r\nprepare_inbound_urb(ep, urb->context);\r\n}\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nusb_audio_err(ep->chip,\r\n"cannot submit urb %d, error %d: %s\n",\r\ni, err, usb_error_string(err));\r\ngoto __error;\r\n}\r\nset_bit(i, &ep->active_mask);\r\n}\r\nreturn 0;\r\n__error:\r\nclear_bit(EP_FLAG_RUNNING, &ep->flags);\r\nep->use_count--;\r\ndeactivate_urbs(ep, false);\r\nreturn -EPIPE;\r\n}\r\nvoid snd_usb_endpoint_stop(struct snd_usb_endpoint *ep)\r\n{\r\nif (!ep)\r\nreturn;\r\nif (snd_BUG_ON(ep->use_count == 0))\r\nreturn;\r\nif (--ep->use_count == 0) {\r\ndeactivate_urbs(ep, false);\r\nset_bit(EP_FLAG_STOPPING, &ep->flags);\r\n}\r\n}\r\nvoid snd_usb_endpoint_deactivate(struct snd_usb_endpoint *ep)\r\n{\r\nif (!ep)\r\nreturn;\r\nif (ep->use_count != 0)\r\nreturn;\r\ndeactivate_urbs(ep, true);\r\nwait_clear_urbs(ep);\r\n}\r\nvoid snd_usb_endpoint_release(struct snd_usb_endpoint *ep)\r\n{\r\nrelease_urbs(ep, 1);\r\n}\r\nvoid snd_usb_endpoint_free(struct snd_usb_endpoint *ep)\r\n{\r\nkfree(ep);\r\n}\r\nvoid snd_usb_handle_sync_urb(struct snd_usb_endpoint *ep,\r\nstruct snd_usb_endpoint *sender,\r\nconst struct urb *urb)\r\n{\r\nint shift;\r\nunsigned int f;\r\nunsigned long flags;\r\nsnd_BUG_ON(ep == sender);\r\nif (snd_usb_endpoint_implicit_feedback_sink(ep) &&\r\nep->use_count != 0) {\r\nint i, bytes = 0;\r\nstruct snd_urb_ctx *in_ctx;\r\nstruct snd_usb_packet_info *out_packet;\r\nin_ctx = urb->context;\r\nfor (i = 0; i < in_ctx->packets; i++)\r\nif (urb->iso_frame_desc[i].status == 0)\r\nbytes += urb->iso_frame_desc[i].actual_length;\r\nif (bytes == 0)\r\nreturn;\r\nspin_lock_irqsave(&ep->lock, flags);\r\nout_packet = ep->next_packet + ep->next_packet_write_pos;\r\nout_packet->packets = in_ctx->packets;\r\nfor (i = 0; i < in_ctx->packets; i++) {\r\nif (urb->iso_frame_desc[i].status == 0)\r\nout_packet->packet_size[i] =\r\nurb->iso_frame_desc[i].actual_length / sender->stride;\r\nelse\r\nout_packet->packet_size[i] = 0;\r\n}\r\nep->next_packet_write_pos++;\r\nep->next_packet_write_pos %= MAX_URBS;\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\nqueue_pending_output_urbs(ep);\r\nreturn;\r\n}\r\nif (urb->iso_frame_desc[0].status != 0 ||\r\nurb->iso_frame_desc[0].actual_length < 3)\r\nreturn;\r\nf = le32_to_cpup(urb->transfer_buffer);\r\nif (urb->iso_frame_desc[0].actual_length == 3)\r\nf &= 0x00ffffff;\r\nelse\r\nf &= 0x0fffffff;\r\nif (f == 0)\r\nreturn;\r\nif (unlikely(sender->tenor_fb_quirk)) {\r\nif (f < ep->freqn - 0x8000)\r\nf += 0xf000;\r\nelse if (f > ep->freqn + 0x8000)\r\nf -= 0xf000;\r\n} else if (unlikely(ep->freqshift == INT_MIN)) {\r\nshift = 0;\r\nwhile (f < ep->freqn - ep->freqn / 4) {\r\nf <<= 1;\r\nshift++;\r\n}\r\nwhile (f > ep->freqn + ep->freqn / 2) {\r\nf >>= 1;\r\nshift--;\r\n}\r\nep->freqshift = shift;\r\n} else if (ep->freqshift >= 0)\r\nf <<= ep->freqshift;\r\nelse\r\nf >>= -ep->freqshift;\r\nif (likely(f >= ep->freqn - ep->freqn / 8 && f <= ep->freqmax)) {\r\nspin_lock_irqsave(&ep->lock, flags);\r\nep->freqm = f;\r\nspin_unlock_irqrestore(&ep->lock, flags);\r\n} else {\r\nep->freqshift = INT_MIN;\r\n}\r\n}
