static int mxs_i2c_reset(struct mxs_i2c_dev *i2c)\r\n{\r\nint ret = stmp_reset_block(i2c->regs);\r\nif (ret)\r\nreturn ret;\r\nwritel(i2c->timing0, i2c->regs + MXS_I2C_TIMING0);\r\nwritel(i2c->timing1, i2c->regs + MXS_I2C_TIMING1);\r\nwritel(i2c->timing2, i2c->regs + MXS_I2C_TIMING2);\r\nwritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_SET);\r\nreturn 0;\r\n}\r\nstatic void mxs_i2c_dma_finish(struct mxs_i2c_dev *i2c)\r\n{\r\nif (i2c->dma_read) {\r\ndma_unmap_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\r\ndma_unmap_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\r\n} else {\r\ndma_unmap_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\r\n}\r\n}\r\nstatic void mxs_i2c_dma_irq_callback(void *param)\r\n{\r\nstruct mxs_i2c_dev *i2c = param;\r\ncomplete(&i2c->cmd_complete);\r\nmxs_i2c_dma_finish(i2c);\r\n}\r\nstatic int mxs_i2c_dma_setup_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, uint32_t flags)\r\n{\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\r\nif (msg->flags & I2C_M_RD) {\r\ni2c->dma_read = 1;\r\ni2c->addr_data = (msg->addr << 1) | I2C_SMBUS_READ;\r\ni2c->pio_data[0] = MXS_CMD_I2C_SELECT;\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach,\r\n(struct scatterlist *)&i2c->pio_data[0],\r\n1, DMA_TRANS_NONE, 0);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get PIO reg. write descriptor.\n");\r\ngoto select_init_pio_fail;\r\n}\r\nsg_init_one(&i2c->sg_io[0], &i2c->addr_data, 1);\r\ndma_map_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach, &i2c->sg_io[0], 1,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get DMA data write descriptor.\n");\r\ngoto select_init_dma_fail;\r\n}\r\ni2c->pio_data[1] = flags | MXS_CMD_I2C_READ |\r\nMXS_I2C_CTRL0_XFER_COUNT(msg->len);\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach,\r\n(struct scatterlist *)&i2c->pio_data[1],\r\n1, DMA_TRANS_NONE, DMA_PREP_INTERRUPT);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get PIO reg. write descriptor.\n");\r\ngoto select_init_dma_fail;\r\n}\r\nsg_init_one(&i2c->sg_io[1], msg->buf, msg->len);\r\ndma_map_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach, &i2c->sg_io[1], 1,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get DMA data write descriptor.\n");\r\ngoto read_init_dma_fail;\r\n}\r\n} else {\r\ni2c->dma_read = 0;\r\ni2c->addr_data = (msg->addr << 1) | I2C_SMBUS_WRITE;\r\ni2c->pio_data[0] = flags | MXS_CMD_I2C_WRITE |\r\nMXS_I2C_CTRL0_XFER_COUNT(msg->len + 1);\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach,\r\n(struct scatterlist *)&i2c->pio_data[0],\r\n1, DMA_TRANS_NONE, 0);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get PIO reg. write descriptor.\n");\r\ngoto write_init_pio_fail;\r\n}\r\nsg_init_table(i2c->sg_io, 2);\r\nsg_set_buf(&i2c->sg_io[0], &i2c->addr_data, 1);\r\nsg_set_buf(&i2c->sg_io[1], msg->buf, msg->len);\r\ndma_map_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\r\ndesc = dmaengine_prep_slave_sg(i2c->dmach, i2c->sg_io, 2,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(i2c->dev,\r\n"Failed to get DMA data write descriptor.\n");\r\ngoto write_init_dma_fail;\r\n}\r\n}\r\ndesc->callback = mxs_i2c_dma_irq_callback;\r\ndesc->callback_param = i2c;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(i2c->dmach);\r\nreturn 0;\r\nread_init_dma_fail:\r\ndma_unmap_sg(i2c->dev, &i2c->sg_io[1], 1, DMA_FROM_DEVICE);\r\nselect_init_dma_fail:\r\ndma_unmap_sg(i2c->dev, &i2c->sg_io[0], 1, DMA_TO_DEVICE);\r\nselect_init_pio_fail:\r\ndmaengine_terminate_all(i2c->dmach);\r\nreturn -EINVAL;\r\nwrite_init_dma_fail:\r\ndma_unmap_sg(i2c->dev, i2c->sg_io, 2, DMA_TO_DEVICE);\r\nwrite_init_pio_fail:\r\ndmaengine_terminate_all(i2c->dmach);\r\nreturn -EINVAL;\r\n}\r\nstatic int mxs_i2c_pio_wait_xfer_end(struct mxs_i2c_dev *i2c)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (readl(i2c->regs + MXS_I2C_CTRL0) & MXS_I2C_CTRL0_RUN) {\r\nif (readl(i2c->regs + MXS_I2C_CTRL1) &\r\nMXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\r\nreturn -ENXIO;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_i2c_pio_check_error_state(struct mxs_i2c_dev *i2c)\r\n{\r\nu32 state;\r\nstate = readl(i2c->regs + MXS_I2C_CTRL1_CLR) & MXS_I2C_IRQ_MASK;\r\nif (state & MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\r\ni2c->cmd_err = -ENXIO;\r\nelse if (state & (MXS_I2C_CTRL1_EARLY_TERM_IRQ |\r\nMXS_I2C_CTRL1_MASTER_LOSS_IRQ |\r\nMXS_I2C_CTRL1_SLAVE_STOP_IRQ |\r\nMXS_I2C_CTRL1_SLAVE_IRQ))\r\ni2c->cmd_err = -EIO;\r\nreturn i2c->cmd_err;\r\n}\r\nstatic void mxs_i2c_pio_trigger_cmd(struct mxs_i2c_dev *i2c, u32 cmd)\r\n{\r\nu32 reg;\r\nwritel(cmd, i2c->regs + MXS_I2C_CTRL0);\r\nreg = readl(i2c->regs + MXS_I2C_CTRL0);\r\nreg |= MXS_I2C_CTRL0_RUN;\r\nwritel(reg, i2c->regs + MXS_I2C_CTRL0);\r\n}\r\nstatic void mxs_i2c_pio_trigger_write_cmd(struct mxs_i2c_dev *i2c, u32 cmd,\r\nu32 data)\r\n{\r\nwritel(cmd, i2c->regs + MXS_I2C_CTRL0);\r\nif (i2c->dev_type == MXS_I2C_V1)\r\nwritel(MXS_I2C_CTRL0_PIO_MODE, i2c->regs + MXS_I2C_CTRL0_SET);\r\nwritel(data, i2c->regs + MXS_I2C_DATA(i2c));\r\nwritel(MXS_I2C_CTRL0_RUN, i2c->regs + MXS_I2C_CTRL0_SET);\r\n}\r\nstatic int mxs_i2c_pio_setup_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, uint32_t flags)\r\n{\r\nstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\r\nuint32_t addr_data = msg->addr << 1;\r\nuint32_t data = 0;\r\nint i, ret, xlen = 0, xmit = 0;\r\nuint32_t start;\r\nwritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_CLR);\r\nif (msg->flags & I2C_M_RD) {\r\nBUG_ON(msg->len > 4);\r\naddr_data |= I2C_SMBUS_READ;\r\nmxs_i2c_pio_trigger_write_cmd(i2c, MXS_CMD_I2C_SELECT,\r\naddr_data);\r\nret = mxs_i2c_pio_wait_xfer_end(i2c);\r\nif (ret) {\r\ndev_err(i2c->dev,\r\n"PIO: Failed to send SELECT command!\n");\r\ngoto cleanup;\r\n}\r\nmxs_i2c_pio_trigger_cmd(i2c,\r\nMXS_CMD_I2C_READ | flags |\r\nMXS_I2C_CTRL0_XFER_COUNT(msg->len));\r\nret = mxs_i2c_pio_wait_xfer_end(i2c);\r\nif (ret) {\r\ndev_err(i2c->dev,\r\n"PIO: Failed to send READ command!\n");\r\ngoto cleanup;\r\n}\r\ndata = readl(i2c->regs + MXS_I2C_DATA(i2c));\r\nfor (i = 0; i < msg->len; i++) {\r\nmsg->buf[i] = data & 0xff;\r\ndata >>= 8;\r\n}\r\n} else {\r\naddr_data |= I2C_SMBUS_WRITE;\r\ndata = addr_data << 24;\r\nstart = MXS_I2C_CTRL0_PRE_SEND_START;\r\nif (msg->len > 3)\r\nstart |= MXS_I2C_CTRL0_RETAIN_CLOCK;\r\nfor (i = 0; i < msg->len; i++) {\r\ndata >>= 8;\r\ndata |= (msg->buf[i] << 24);\r\nxmit = 0;\r\nif (i + 1 == msg->len) {\r\nstart |= flags;\r\nstart &= ~MXS_I2C_CTRL0_RETAIN_CLOCK;\r\nxmit = 1;\r\n}\r\nif ((i & 3) == 2)\r\nxmit = 1;\r\nif (!xmit)\r\ncontinue;\r\nif ((i % 4) == 3)\r\nxlen = 1;\r\nelse\r\nxlen = (i % 4) + 2;\r\ndata >>= (4 - xlen) * 8;\r\ndev_dbg(i2c->dev,\r\n"PIO: len=%i pos=%i total=%i [W%s%s%s]\n",\r\nxlen, i, msg->len,\r\nstart & MXS_I2C_CTRL0_PRE_SEND_START ? "S" : "",\r\nstart & MXS_I2C_CTRL0_POST_SEND_STOP ? "E" : "",\r\nstart & MXS_I2C_CTRL0_RETAIN_CLOCK ? "C" : "");\r\nwritel(MXS_I2C_DEBUG0_DMAREQ,\r\ni2c->regs + MXS_I2C_DEBUG0_CLR(i2c));\r\nmxs_i2c_pio_trigger_write_cmd(i2c,\r\nstart | MXS_I2C_CTRL0_MASTER_MODE |\r\nMXS_I2C_CTRL0_DIRECTION |\r\nMXS_I2C_CTRL0_XFER_COUNT(xlen), data);\r\nstart &= ~MXS_I2C_CTRL0_PRE_SEND_START;\r\nret = mxs_i2c_pio_wait_xfer_end(i2c);\r\nif (ret) {\r\ndev_err(i2c->dev,\r\n"PIO: Failed to finish WRITE cmd!\n");\r\nbreak;\r\n}\r\nret = readl(i2c->regs + MXS_I2C_STAT) &\r\nMXS_I2C_STAT_GOT_A_NAK;\r\nif (ret) {\r\nret = -ENXIO;\r\ngoto cleanup;\r\n}\r\n}\r\n}\r\nret = mxs_i2c_pio_check_error_state(i2c);\r\ncleanup:\r\nwritel(MXS_I2C_IRQ_MASK, i2c->regs + MXS_I2C_CTRL1_CLR);\r\nwritel(MXS_I2C_IRQ_MASK << 8, i2c->regs + MXS_I2C_CTRL1_SET);\r\nif (i2c->dev_type == MXS_I2C_V1)\r\nwritel(MXS_I2C_CTRL0_PIO_MODE, i2c->regs + MXS_I2C_CTRL0_CLR);\r\nreturn ret;\r\n}\r\nstatic int mxs_i2c_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint stop)\r\n{\r\nstruct mxs_i2c_dev *i2c = i2c_get_adapdata(adap);\r\nint ret;\r\nint flags;\r\nint use_pio = 0;\r\nunsigned long time_left;\r\nflags = stop ? MXS_I2C_CTRL0_POST_SEND_STOP : 0;\r\ndev_dbg(i2c->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\nif ((msg->flags & I2C_M_RD) && (msg->len <= 4))\r\nuse_pio = 1;\r\nif (!(msg->flags & I2C_M_RD) && (msg->len < 7))\r\nuse_pio = 1;\r\ni2c->cmd_err = 0;\r\nif (use_pio) {\r\nret = mxs_i2c_pio_setup_xfer(adap, msg, flags);\r\nif (ret && (ret != -ENXIO))\r\nmxs_i2c_reset(i2c);\r\n} else {\r\nreinit_completion(&i2c->cmd_complete);\r\nret = mxs_i2c_dma_setup_xfer(adap, msg, flags);\r\nif (ret)\r\nreturn ret;\r\ntime_left = wait_for_completion_timeout(&i2c->cmd_complete,\r\nmsecs_to_jiffies(1000));\r\nif (!time_left)\r\ngoto timeout;\r\nret = i2c->cmd_err;\r\n}\r\nif (ret == -ENXIO) {\r\nwritel(MXS_I2C_CTRL1_CLR_GOT_A_NAK,\r\ni2c->regs + MXS_I2C_CTRL1_SET);\r\n}\r\nif (i2c->dev_type == MXS_I2C_V1)\r\nmxs_i2c_reset(i2c);\r\ndev_dbg(i2c->dev, "Done with err=%d\n", ret);\r\nreturn ret;\r\ntimeout:\r\ndev_dbg(i2c->dev, "Timeout!\n");\r\nmxs_i2c_dma_finish(i2c);\r\nret = mxs_i2c_reset(i2c);\r\nif (ret)\r\nreturn ret;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mxs_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < num; i++) {\r\nerr = mxs_i2c_xfer_msg(adap, &msgs[i], i == (num - 1));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 mxs_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic irqreturn_t mxs_i2c_isr(int this_irq, void *dev_id)\r\n{\r\nstruct mxs_i2c_dev *i2c = dev_id;\r\nu32 stat = readl(i2c->regs + MXS_I2C_CTRL1) & MXS_I2C_IRQ_MASK;\r\nif (!stat)\r\nreturn IRQ_NONE;\r\nif (stat & MXS_I2C_CTRL1_NO_SLAVE_ACK_IRQ)\r\ni2c->cmd_err = -ENXIO;\r\nelse if (stat & (MXS_I2C_CTRL1_EARLY_TERM_IRQ |\r\nMXS_I2C_CTRL1_MASTER_LOSS_IRQ |\r\nMXS_I2C_CTRL1_SLAVE_STOP_IRQ | MXS_I2C_CTRL1_SLAVE_IRQ))\r\ni2c->cmd_err = -EIO;\r\nwritel(stat, i2c->regs + MXS_I2C_CTRL1_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxs_i2c_derive_timing(struct mxs_i2c_dev *i2c, uint32_t speed)\r\n{\r\nconst uint32_t clk = 24000000;\r\nuint32_t divider;\r\nuint16_t high_count, low_count, rcv_count, xmit_count;\r\nuint32_t bus_free, leadin;\r\nstruct device *dev = i2c->dev;\r\ndivider = DIV_ROUND_UP(clk, speed);\r\nif (divider < 25) {\r\ndivider = 25;\r\ndev_warn(dev,\r\n"Speed too high (%u.%03u kHz), using %u.%03u kHz\n",\r\nspeed / 1000, speed % 1000,\r\nclk / divider / 1000, clk / divider % 1000);\r\n} else if (divider > 1897) {\r\ndivider = 1897;\r\ndev_warn(dev,\r\n"Speed too low (%u.%03u kHz), using %u.%03u kHz\n",\r\nspeed / 1000, speed % 1000,\r\nclk / divider / 1000, clk / divider % 1000);\r\n}\r\nif (speed > 100000) {\r\nlow_count = DIV_ROUND_CLOSEST(divider * 13, (13 + 6));\r\nhigh_count = DIV_ROUND_CLOSEST(divider * 6, (13 + 6));\r\nleadin = DIV_ROUND_UP(600 * (clk / 1000000), 1000);\r\nbus_free = DIV_ROUND_UP(1300 * (clk / 1000000), 1000);\r\n} else {\r\nlow_count = DIV_ROUND_CLOSEST(divider * 47, (47 + 40));\r\nhigh_count = DIV_ROUND_CLOSEST(divider * 40, (47 + 40));\r\nleadin = DIV_ROUND_UP(4700 * (clk / 1000000), 1000);\r\nbus_free = DIV_ROUND_UP(4700 * (clk / 1000000), 1000);\r\n}\r\nrcv_count = high_count * 3 / 8;\r\nxmit_count = low_count * 3 / 8;\r\ndev_dbg(dev,\r\n"speed=%u(actual %u) divider=%u low=%u high=%u xmit=%u rcv=%u leadin=%u bus_free=%u\n",\r\nspeed, clk / divider, divider, low_count, high_count,\r\nxmit_count, rcv_count, leadin, bus_free);\r\nlow_count -= 2;\r\nhigh_count -= 7;\r\ni2c->timing0 = (high_count << 16) | rcv_count;\r\ni2c->timing1 = (low_count << 16) | xmit_count;\r\ni2c->timing2 = (bus_free << 16 | leadin);\r\n}\r\nstatic int mxs_i2c_get_ofdata(struct mxs_i2c_dev *i2c)\r\n{\r\nuint32_t speed;\r\nstruct device *dev = i2c->dev;\r\nstruct device_node *node = dev->of_node;\r\nint ret;\r\nret = of_property_read_u32(node, "clock-frequency", &speed);\r\nif (ret) {\r\ndev_warn(dev, "No I2C speed selected, using 100kHz\n");\r\nspeed = 100000;\r\n}\r\nmxs_i2c_derive_timing(i2c, speed);\r\nreturn 0;\r\n}\r\nstatic int mxs_i2c_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_i2c_dt_ids, &pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct mxs_i2c_dev *i2c;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint err, irq;\r\ni2c = devm_kzalloc(dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nif (of_id) {\r\nconst struct platform_device_id *device_id = of_id->data;\r\ni2c->dev_type = device_id->driver_data;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->regs))\r\nreturn PTR_ERR(i2c->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nerr = devm_request_irq(dev, irq, mxs_i2c_isr, 0, dev_name(dev), i2c);\r\nif (err)\r\nreturn err;\r\ni2c->dev = dev;\r\ninit_completion(&i2c->cmd_complete);\r\nif (dev->of_node) {\r\nerr = mxs_i2c_get_ofdata(i2c);\r\nif (err)\r\nreturn err;\r\n}\r\ni2c->dmach = dma_request_slave_channel(dev, "rx-tx");\r\nif (!i2c->dmach) {\r\ndev_err(dev, "Failed to request dma\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, i2c);\r\nerr = mxs_i2c_reset(i2c);\r\nif (err)\r\nreturn err;\r\nadap = &i2c->adapter;\r\nstrlcpy(adap->name, "MXS I2C adapter", sizeof(adap->name));\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &mxs_i2c_algo;\r\nadap->dev.parent = dev;\r\nadap->nr = pdev->id;\r\nadap->dev.of_node = pdev->dev.of_node;\r\ni2c_set_adapdata(adap, i2c);\r\nerr = i2c_add_numbered_adapter(adap);\r\nif (err) {\r\nwritel(MXS_I2C_CTRL0_SFTRST,\r\ni2c->regs + MXS_I2C_CTRL0_SET);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_i2c_dev *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adapter);\r\nif (i2c->dmach)\r\ndma_release_channel(i2c->dmach);\r\nwritel(MXS_I2C_CTRL0_SFTRST, i2c->regs + MXS_I2C_CTRL0_SET);\r\nreturn 0;\r\n}\r\nstatic int __init mxs_i2c_init(void)\r\n{\r\nreturn platform_driver_register(&mxs_i2c_driver);\r\n}\r\nstatic void __exit mxs_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&mxs_i2c_driver);\r\n}
