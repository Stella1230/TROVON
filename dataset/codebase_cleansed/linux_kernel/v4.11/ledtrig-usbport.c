static bool usbport_trig_usb_dev_observed(struct usbport_trig_data *usbport_data,\r\nstruct usb_device *usb_dev)\r\n{\r\nstruct usbport_trig_port *port;\r\nif (!usb_dev->parent)\r\nreturn false;\r\nlist_for_each_entry(port, &usbport_data->ports, list) {\r\nif (usb_dev->parent == port->hub &&\r\nusb_dev->portnum == port->portnum)\r\nreturn port->observed;\r\n}\r\nreturn false;\r\n}\r\nstatic int usbport_trig_usb_dev_check(struct usb_device *usb_dev, void *data)\r\n{\r\nstruct usbport_trig_data *usbport_data = data;\r\nif (usbport_trig_usb_dev_observed(usbport_data, usb_dev))\r\nusbport_data->count++;\r\nreturn 0;\r\n}\r\nstatic void usbport_trig_update_count(struct usbport_trig_data *usbport_data)\r\n{\r\nstruct led_classdev *led_cdev = usbport_data->led_cdev;\r\nusbport_data->count = 0;\r\nusb_for_each_dev(usbport_data, usbport_trig_usb_dev_check);\r\nled_set_brightness(led_cdev, usbport_data->count ? LED_FULL : LED_OFF);\r\n}\r\nstatic ssize_t usbport_trig_port_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usbport_trig_port *port = container_of(attr,\r\nstruct usbport_trig_port,\r\nattr);\r\nreturn sprintf(buf, "%d\n", port->observed) + 1;\r\n}\r\nstatic ssize_t usbport_trig_port_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct usbport_trig_port *port = container_of(attr,\r\nstruct usbport_trig_port,\r\nattr);\r\nif (!strcmp(buf, "0") || !strcmp(buf, "0\n"))\r\nport->observed = 0;\r\nelse if (!strcmp(buf, "1") || !strcmp(buf, "1\n"))\r\nport->observed = 1;\r\nelse\r\nreturn -EINVAL;\r\nusbport_trig_update_count(port->data);\r\nreturn size;\r\n}\r\nstatic int usbport_trig_add_port(struct usbport_trig_data *usbport_data,\r\nstruct usb_device *usb_dev,\r\nconst char *hub_name, int portnum)\r\n{\r\nstruct led_classdev *led_cdev = usbport_data->led_cdev;\r\nstruct usbport_trig_port *port;\r\nsize_t len;\r\nint err;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nport->data = usbport_data;\r\nport->hub = usb_dev;\r\nport->portnum = portnum;\r\nlen = strlen(hub_name) + 8;\r\nport->port_name = kzalloc(len, GFP_KERNEL);\r\nif (!port->port_name) {\r\nerr = -ENOMEM;\r\ngoto err_free_port;\r\n}\r\nsnprintf(port->port_name, len, "%s-port%d", hub_name, portnum);\r\nport->attr.attr.name = port->port_name;\r\nport->attr.attr.mode = S_IRUSR | S_IWUSR;\r\nport->attr.show = usbport_trig_port_show;\r\nport->attr.store = usbport_trig_port_store;\r\nerr = sysfs_add_file_to_group(&led_cdev->dev->kobj, &port->attr.attr,\r\nports_group.name);\r\nif (err)\r\ngoto err_free_port_name;\r\nlist_add_tail(&port->list, &usbport_data->ports);\r\nreturn 0;\r\nerr_free_port_name:\r\nkfree(port->port_name);\r\nerr_free_port:\r\nkfree(port);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int usbport_trig_add_usb_dev_ports(struct usb_device *usb_dev,\r\nvoid *data)\r\n{\r\nstruct usbport_trig_data *usbport_data = data;\r\nint i;\r\nfor (i = 1; i <= usb_dev->maxchild; i++)\r\nusbport_trig_add_port(usbport_data, usb_dev,\r\ndev_name(&usb_dev->dev), i);\r\nreturn 0;\r\n}\r\nstatic void usbport_trig_remove_port(struct usbport_trig_data *usbport_data,\r\nstruct usbport_trig_port *port)\r\n{\r\nstruct led_classdev *led_cdev = usbport_data->led_cdev;\r\nlist_del(&port->list);\r\nsysfs_remove_file_from_group(&led_cdev->dev->kobj, &port->attr.attr,\r\nports_group.name);\r\nkfree(port->port_name);\r\nkfree(port);\r\n}\r\nstatic void usbport_trig_remove_usb_dev_ports(struct usbport_trig_data *usbport_data,\r\nstruct usb_device *usb_dev)\r\n{\r\nstruct usbport_trig_port *port, *tmp;\r\nlist_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {\r\nif (port->hub == usb_dev)\r\nusbport_trig_remove_port(usbport_data, port);\r\n}\r\n}\r\nstatic int usbport_trig_notify(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct usbport_trig_data *usbport_data =\r\ncontainer_of(nb, struct usbport_trig_data, nb);\r\nstruct led_classdev *led_cdev = usbport_data->led_cdev;\r\nstruct usb_device *usb_dev = data;\r\nbool observed;\r\nobserved = usbport_trig_usb_dev_observed(usbport_data, usb_dev);\r\nswitch (action) {\r\ncase USB_DEVICE_ADD:\r\nusbport_trig_add_usb_dev_ports(usb_dev, usbport_data);\r\nif (observed && usbport_data->count++ == 0)\r\nled_set_brightness(led_cdev, LED_FULL);\r\nreturn NOTIFY_OK;\r\ncase USB_DEVICE_REMOVE:\r\nusbport_trig_remove_usb_dev_ports(usbport_data, usb_dev);\r\nif (observed && --usbport_data->count == 0)\r\nled_set_brightness(led_cdev, LED_OFF);\r\nreturn NOTIFY_OK;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void usbport_trig_activate(struct led_classdev *led_cdev)\r\n{\r\nstruct usbport_trig_data *usbport_data;\r\nint err;\r\nusbport_data = kzalloc(sizeof(*usbport_data), GFP_KERNEL);\r\nif (!usbport_data)\r\nreturn;\r\nusbport_data->led_cdev = led_cdev;\r\nINIT_LIST_HEAD(&usbport_data->ports);\r\nerr = sysfs_create_group(&led_cdev->dev->kobj, &ports_group);\r\nif (err)\r\ngoto err_free;\r\nusb_for_each_dev(usbport_data, usbport_trig_add_usb_dev_ports);\r\nusbport_data->nb.notifier_call = usbport_trig_notify,\r\nled_cdev->trigger_data = usbport_data;\r\nusb_register_notify(&usbport_data->nb);\r\nled_cdev->activated = true;\r\nreturn;\r\nerr_free:\r\nkfree(usbport_data);\r\n}\r\nstatic void usbport_trig_deactivate(struct led_classdev *led_cdev)\r\n{\r\nstruct usbport_trig_data *usbport_data = led_cdev->trigger_data;\r\nstruct usbport_trig_port *port, *tmp;\r\nif (!led_cdev->activated)\r\nreturn;\r\nlist_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {\r\nusbport_trig_remove_port(usbport_data, port);\r\n}\r\nusb_unregister_notify(&usbport_data->nb);\r\nsysfs_remove_group(&led_cdev->dev->kobj, &ports_group);\r\nkfree(usbport_data);\r\nled_cdev->activated = false;\r\n}\r\nstatic int __init usbport_trig_init(void)\r\n{\r\nreturn led_trigger_register(&usbport_led_trigger);\r\n}\r\nstatic void __exit usbport_trig_exit(void)\r\n{\r\nled_trigger_unregister(&usbport_led_trigger);\r\n}
