static void tcp_gso_tstamp(struct sk_buff *skb, unsigned int ts_seq,\r\nunsigned int seq, unsigned int mss)\r\n{\r\nwhile (skb) {\r\nif (before(ts_seq, seq + mss)) {\r\nskb_shinfo(skb)->tx_flags |= SKBTX_SW_TSTAMP;\r\nskb_shinfo(skb)->tskey = ts_seq;\r\nreturn;\r\n}\r\nskb = skb->next;\r\nseq += mss;\r\n}\r\n}\r\nstatic struct sk_buff *tcp4_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\r\nreturn ERR_PTR(-EINVAL);\r\nif (unlikely(skb->ip_summed != CHECKSUM_PARTIAL)) {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct tcphdr *th = tcp_hdr(skb);\r\nth->check = 0;\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\n__tcp_v4_send_check(skb, iph->saddr, iph->daddr);\r\n}\r\nreturn tcp_gso_segment(skb, features);\r\n}\r\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nunsigned int sum_truesize = 0;\r\nstruct tcphdr *th;\r\nunsigned int thlen;\r\nunsigned int seq;\r\n__be32 delta;\r\nunsigned int oldlen;\r\nunsigned int mss;\r\nstruct sk_buff *gso_skb = skb;\r\n__sum16 newcheck;\r\nbool ooo_okay, copy_destructor;\r\nth = tcp_hdr(skb);\r\nthlen = th->doff * 4;\r\nif (thlen < sizeof(*th))\r\ngoto out;\r\nif (!pskb_may_pull(skb, thlen))\r\ngoto out;\r\noldlen = (u16)~skb->len;\r\n__skb_pull(skb, thlen);\r\nmss = skb_shinfo(skb)->gso_size;\r\nif (unlikely(skb->len <= mss))\r\ngoto out;\r\nif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\r\nskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\r\nsegs = NULL;\r\ngoto out;\r\n}\r\ncopy_destructor = gso_skb->destructor == tcp_wfree;\r\nooo_okay = gso_skb->ooo_okay;\r\nskb->ooo_okay = 0;\r\nsegs = skb_segment(skb, features);\r\nif (IS_ERR(segs))\r\ngoto out;\r\nsegs->ooo_okay = ooo_okay;\r\nif (skb_is_gso(segs))\r\nmss *= skb_shinfo(segs)->gso_segs;\r\ndelta = htonl(oldlen + (thlen + mss));\r\nskb = segs;\r\nth = tcp_hdr(skb);\r\nseq = ntohl(th->seq);\r\nif (unlikely(skb_shinfo(gso_skb)->tx_flags & SKBTX_SW_TSTAMP))\r\ntcp_gso_tstamp(segs, skb_shinfo(gso_skb)->tskey, seq, mss);\r\nnewcheck = ~csum_fold((__force __wsum)((__force u32)th->check +\r\n(__force u32)delta));\r\nwhile (skb->next) {\r\nth->fin = th->psh = 0;\r\nth->check = newcheck;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\ngso_reset_checksum(skb, ~th->check);\r\nelse\r\nth->check = gso_make_checksum(skb, ~th->check);\r\nseq += mss;\r\nif (copy_destructor) {\r\nskb->destructor = gso_skb->destructor;\r\nskb->sk = gso_skb->sk;\r\nsum_truesize += skb->truesize;\r\n}\r\nskb = skb->next;\r\nth = tcp_hdr(skb);\r\nth->seq = htonl(seq);\r\nth->cwr = 0;\r\n}\r\nif (copy_destructor) {\r\nswap(gso_skb->sk, skb->sk);\r\nswap(gso_skb->destructor, skb->destructor);\r\nsum_truesize += skb->truesize;\r\natomic_add(sum_truesize - gso_skb->truesize,\r\n&skb->sk->sk_wmem_alloc);\r\n}\r\ndelta = htonl(oldlen + (skb_tail_pointer(skb) -\r\nskb_transport_header(skb)) +\r\nskb->data_len);\r\nth->check = ~csum_fold((__force __wsum)((__force u32)th->check +\r\n(__force u32)delta));\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\ngso_reset_checksum(skb, ~th->check);\r\nelse\r\nth->check = gso_make_checksum(skb, ~th->check);\r\nout:\r\nreturn segs;\r\n}\r\nstruct sk_buff **tcp_gro_receive(struct sk_buff **head, struct sk_buff *skb)\r\n{\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nstruct tcphdr *th;\r\nstruct tcphdr *th2;\r\nunsigned int len;\r\nunsigned int thlen;\r\n__be32 flags;\r\nunsigned int mss = 1;\r\nunsigned int hlen;\r\nunsigned int off;\r\nint flush = 1;\r\nint i;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*th);\r\nth = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\nth = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!th))\r\ngoto out;\r\n}\r\nthlen = th->doff * 4;\r\nif (thlen < sizeof(*th))\r\ngoto out;\r\nhlen = off + thlen;\r\nif (skb_gro_header_hard(skb, hlen)) {\r\nth = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!th))\r\ngoto out;\r\n}\r\nskb_gro_pull(skb, thlen);\r\nlen = skb_gro_len(skb);\r\nflags = tcp_flag_word(th);\r\nfor (; (p = *head); head = &p->next) {\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\nth2 = tcp_hdr(p);\r\nif (*(u32 *)&th->source ^ *(u32 *)&th2->source) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\ngoto found;\r\n}\r\ngoto out_check_final;\r\nfound:\r\nflush = NAPI_GRO_CB(p)->flush;\r\nflush |= (__force int)(flags & TCP_FLAG_CWR);\r\nflush |= (__force int)((flags ^ tcp_flag_word(th2)) &\r\n~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));\r\nflush |= (__force int)(th->ack_seq ^ th2->ack_seq);\r\nfor (i = sizeof(*th); i < thlen; i += 4)\r\nflush |= *(u32 *)((u8 *)th + i) ^\r\n*(u32 *)((u8 *)th2 + i);\r\nif (NAPI_GRO_CB(p)->flush_id != 1 ||\r\nNAPI_GRO_CB(p)->count != 1 ||\r\n!NAPI_GRO_CB(p)->is_atomic)\r\nflush |= NAPI_GRO_CB(p)->flush_id;\r\nelse\r\nNAPI_GRO_CB(p)->is_atomic = false;\r\nmss = skb_shinfo(p)->gso_size;\r\nflush |= (len - 1) >= mss;\r\nflush |= (ntohl(th2->seq) + skb_gro_len(p)) ^ ntohl(th->seq);\r\nif (flush || skb_gro_receive(head, skb)) {\r\nmss = 1;\r\ngoto out_check_final;\r\n}\r\np = *head;\r\nth2 = tcp_hdr(p);\r\ntcp_flag_word(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);\r\nout_check_final:\r\nflush = len < mss;\r\nflush |= (__force int)(flags & (TCP_FLAG_URG | TCP_FLAG_PSH |\r\nTCP_FLAG_RST | TCP_FLAG_SYN |\r\nTCP_FLAG_FIN));\r\nif (p && (!NAPI_GRO_CB(skb)->same_flow || flush))\r\npp = head;\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= (flush != 0);\r\nreturn pp;\r\n}\r\nint tcp_gro_complete(struct sk_buff *skb)\r\n{\r\nstruct tcphdr *th = tcp_hdr(skb);\r\nskb->csum_start = (unsigned char *)th - skb->head;\r\nskb->csum_offset = offsetof(struct tcphdr, check);\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\r\nif (th->cwr)\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_ECN;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff **tcp4_gro_receive(struct sk_buff **head, struct sk_buff *skb)\r\n{\r\nif (!NAPI_GRO_CB(skb)->flush &&\r\nskb_gro_checksum_validate(skb, IPPROTO_TCP,\r\ninet_gro_compute_pseudo)) {\r\nNAPI_GRO_CB(skb)->flush = 1;\r\nreturn NULL;\r\n}\r\nreturn tcp_gro_receive(head, skb);\r\n}\r\nstatic int tcp4_gro_complete(struct sk_buff *skb, int thoff)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct tcphdr *th = tcp_hdr(skb);\r\nth->check = ~tcp_v4_check(skb->len - thoff, iph->saddr,\r\niph->daddr, 0);\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_TCPV4;\r\nif (NAPI_GRO_CB(skb)->is_atomic)\r\nskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_FIXEDID;\r\nreturn tcp_gro_complete(skb);\r\n}\r\nint __init tcpv4_offload_init(void)\r\n{\r\nreturn inet_add_offload(&tcpv4_offload, IPPROTO_TCP);\r\n}
