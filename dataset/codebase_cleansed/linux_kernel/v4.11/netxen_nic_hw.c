static inline u64 readq(void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64) readl(addr + 4)) << 32LL);\r\n}\r\nstatic inline void writeq(u64 val, void __iomem *addr)\r\n{\r\nwritel(((u32) (val)), (addr));\r\nwritel(((u32) (val >> 32)), (addr + 4));\r\n}\r\nstatic void __iomem *pci_base_offset(struct netxen_adapter *adapter,\r\nunsigned long off)\r\n{\r\nif (ADDR_IN_RANGE(off, FIRST_PAGE_GROUP_START, FIRST_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_FIRST_RANGE(adapter, off);\r\nif (ADDR_IN_RANGE(off, SECOND_PAGE_GROUP_START, SECOND_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_SECOND_RANGE(adapter, off);\r\nif (ADDR_IN_RANGE(off, THIRD_PAGE_GROUP_START, THIRD_PAGE_GROUP_END))\r\nreturn PCI_OFFSET_THIRD_RANGE(adapter, off);\r\nreturn NULL;\r\n}\r\nint\r\nnetxen_pcie_sem_lock(struct netxen_adapter *adapter, int sem, u32 id_reg)\r\n{\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = NXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_LOCK(sem)));\r\nif (done == 1)\r\nbreak;\r\nif (++timeout >= NETXEN_PCIE_SEM_TIMEOUT)\r\nreturn -EIO;\r\nmsleep(1);\r\n}\r\nif (id_reg)\r\nNXWR32(adapter, id_reg, adapter->portnum);\r\nreturn 0;\r\n}\r\nvoid\r\nnetxen_pcie_sem_unlock(struct netxen_adapter *adapter, int sem)\r\n{\r\nNXRD32(adapter, NETXEN_PCIE_REG(PCIE_SEM_UNLOCK(sem)));\r\n}\r\nstatic int netxen_niu_xg_init_port(struct netxen_adapter *adapter, int port)\r\n{\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_1+(0x10000*port), 0x1447);\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0+(0x10000*port), 0x5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_niu_disable_xg_port(struct netxen_adapter *adapter)\r\n{\r\n__u32 mac_cfg;\r\nu32 port = adapter->physical_port;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id))\r\nreturn 0;\r\nif (port >= NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_cfg = 0;\r\nif (NXWR32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int netxen_p2_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\r\n{\r\nu32 mac_cfg;\r\nu32 cnt = 0;\r\n__u32 reg = 0x0200;\r\nu32 port = adapter->physical_port;\r\nu16 board_type = adapter->ahw.board_type;\r\nif (port >= NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_cfg = NXRD32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port));\r\nmac_cfg &= ~0x4;\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\r\nif ((board_type == NETXEN_BRDTYPE_P2_SB31_10G_IMEZ) ||\r\n(board_type == NETXEN_BRDTYPE_P2_SB31_10G_HMEZ))\r\nreg = (0x20 << port);\r\nNXWR32(adapter, NETXEN_NIU_FRAME_COUNT_SELECT, reg);\r\nmdelay(10);\r\nwhile (NXRD32(adapter, NETXEN_NIU_FRAME_COUNT) && ++cnt < 20)\r\nmdelay(10);\r\nif (cnt < 20) {\r\nreg = NXRD32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port));\r\nif (mode == NETXEN_NIU_PROMISC_MODE)\r\nreg = (reg | 0x2000UL);\r\nelse\r\nreg = (reg & ~0x2000UL);\r\nif (mode == NETXEN_NIU_ALLMULTI_MODE)\r\nreg = (reg | 0x1000UL);\r\nelse\r\nreg = (reg & ~0x1000UL);\r\nNXWR32(adapter,\r\nNETXEN_NIU_XGE_CONFIG_1 + (0x10000 * port), reg);\r\n}\r\nmac_cfg |= 0x4;\r\nNXWR32(adapter, NETXEN_NIU_XGE_CONFIG_0 + (0x10000 * port), mac_cfg);\r\nreturn 0;\r\n}\r\nstatic int netxen_p2_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\r\n{\r\nu32 mac_hi, mac_lo;\r\nu32 reg_hi, reg_lo;\r\nu8 phy = adapter->physical_port;\r\nif (phy >= NETXEN_NIU_MAX_XG_PORTS)\r\nreturn -EINVAL;\r\nmac_lo = ((u32)addr[0] << 16) | ((u32)addr[1] << 24);\r\nmac_hi = addr[2] | ((u32)addr[3] << 8) |\r\n((u32)addr[4] << 16) | ((u32)addr[5] << 24);\r\nreg_lo = NETXEN_NIU_XGE_STATION_ADDR_0_1 + (0x10000 * phy);\r\nreg_hi = NETXEN_NIU_XGE_STATION_ADDR_0_HI + (0x10000 * phy);\r\nif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\r\nreturn -EIO;\r\nif (NXWR32(adapter, reg_lo, mac_lo) || NXWR32(adapter, reg_hi, mac_hi))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_enable_mcast_filter(struct netxen_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nu16 port = adapter->physical_port;\r\nu8 *addr = adapter->mac_addr;\r\nif (adapter->mc_enabled)\r\nreturn 0;\r\nval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\r\nval |= (1UL << (28+port));\r\nNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\r\nval = 0xffffff;\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\r\nval = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), val);\r\nval = MAC_LO(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, val);\r\nadapter->mc_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_disable_mcast_filter(struct netxen_adapter *adapter)\r\n{\r\nu32 val = 0;\r\nu16 port = adapter->physical_port;\r\nu8 *addr = adapter->mac_addr;\r\nif (!adapter->mc_enabled)\r\nreturn 0;\r\nval = NXRD32(adapter, NETXEN_MAC_ADDR_CNTL_REG);\r\nval &= ~(1UL << (28+port));\r\nNXWR32(adapter, NETXEN_MAC_ADDR_CNTL_REG, val);\r\nval = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0), val);\r\nval = MAC_LO(addr);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 0)+4, val);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1), 0);\r\nNXWR32(adapter, NETXEN_UNICAST_ADDR(port, 1)+4, 0);\r\nadapter->mc_enabled = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_set_mcast_addr(struct netxen_adapter *adapter,\r\nint index, u8 *addr)\r\n{\r\nu32 hi = 0, lo = 0;\r\nu16 port = adapter->physical_port;\r\nlo = MAC_LO(addr);\r\nhi = MAC_HI(addr);\r\nNXWR32(adapter, NETXEN_MCAST_ADDR(port, index), hi);\r\nNXWR32(adapter, NETXEN_MCAST_ADDR(port, index)+4, lo);\r\nreturn 0;\r\n}\r\nstatic void netxen_p2_nic_set_multi(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nu8 null_addr[ETH_ALEN];\r\nint i;\r\neth_zero_addr(null_addr);\r\nif (netdev->flags & IFF_PROMISC) {\r\nadapter->set_promisc(adapter,\r\nNETXEN_NIU_PROMISC_MODE);\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nif (netdev_mc_empty(netdev)) {\r\nadapter->set_promisc(adapter,\r\nNETXEN_NIU_NON_PROMISC_MODE);\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nadapter->set_promisc(adapter, NETXEN_NIU_ALLMULTI_MODE);\r\nif (netdev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(netdev) > adapter->max_mc_count) {\r\nnetxen_nic_disable_mcast_filter(adapter);\r\nreturn;\r\n}\r\nnetxen_nic_enable_mcast_filter(adapter);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nnetxen_nic_set_mcast_addr(adapter, i++, ha->addr);\r\nwhile (i < adapter->max_mc_count)\r\nnetxen_nic_set_mcast_addr(adapter, i++, null_addr);\r\n}\r\nstatic int\r\nnetxen_send_cmd_descs(struct netxen_adapter *adapter,\r\nstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\r\n{\r\nu32 i, producer, consumer;\r\nstruct netxen_cmd_buffer *pbuf;\r\nstruct cmd_desc_type0 *cmd_desc;\r\nstruct nx_host_tx_ring *tx_ring;\r\ni = 0;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn -EIO;\r\ntx_ring = adapter->tx_ring;\r\n__netif_tx_lock_bh(tx_ring->txq);\r\nproducer = tx_ring->producer;\r\nconsumer = tx_ring->sw_consumer;\r\nif (nr_desc >= netxen_tx_avail(tx_ring)) {\r\nnetif_tx_stop_queue(tx_ring->txq);\r\nsmp_mb();\r\nif (netxen_tx_avail(tx_ring) > nr_desc) {\r\nif (netxen_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_tx_wake_queue(tx_ring->txq);\r\n} else {\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndo {\r\ncmd_desc = &cmd_desc_arr[i];\r\npbuf = &tx_ring->cmd_buf_arr[producer];\r\npbuf->skb = NULL;\r\npbuf->frag_count = 0;\r\nmemcpy(&tx_ring->desc_head[producer],\r\n&cmd_desc_arr[i], sizeof(struct cmd_desc_type0));\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\ni++;\r\n} while (i != nr_desc);\r\ntx_ring->producer = producer;\r\nnetxen_nic_update_cmd_producer(adapter, tx_ring);\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn 0;\r\n}\r\nstatic int\r\nnx_p3_sre_macaddr_change(struct netxen_adapter *adapter, u8 *addr, unsigned op)\r\n{\r\nnx_nic_req_t req;\r\nnx_mac_req_t *mac_req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_NIC_REQUEST << 23);\r\nword = NX_MAC_EVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nmac_req = (nx_mac_req_t *)&req.words[0];\r\nmac_req->op = op;\r\nmemcpy(mac_req->mac_addr, addr, ETH_ALEN);\r\nreturn netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\n}\r\nstatic int nx_p3_nic_add_mac(struct netxen_adapter *adapter,\r\nconst u8 *addr, struct list_head *del_list)\r\n{\r\nstruct list_head *head;\r\nnx_mac_list_t *cur;\r\nlist_for_each(head, del_list) {\r\ncur = list_entry(head, nx_mac_list_t, list);\r\nif (ether_addr_equal(addr, cur->mac_addr)) {\r\nlist_move_tail(head, &adapter->mac_list);\r\nreturn 0;\r\n}\r\n}\r\ncur = kzalloc(sizeof(nx_mac_list_t), GFP_ATOMIC);\r\nif (cur == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(cur->mac_addr, addr, ETH_ALEN);\r\nlist_add_tail(&cur->list, &adapter->mac_list);\r\nreturn nx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_ADD);\r\n}\r\nstatic void netxen_p3_nic_set_multi(struct net_device *netdev)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nstatic const u8 bcast_addr[ETH_ALEN] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nu32 mode = VPORT_MISS_MODE_DROP;\r\nLIST_HEAD(del_list);\r\nstruct list_head *head;\r\nnx_mac_list_t *cur;\r\nif (adapter->is_up != NETXEN_ADAPTER_UP_MAGIC)\r\nreturn;\r\nlist_splice_tail_init(&adapter->mac_list, &del_list);\r\nnx_p3_nic_add_mac(adapter, adapter->mac_addr, &del_list);\r\nnx_p3_nic_add_mac(adapter, bcast_addr, &del_list);\r\nif (netdev->flags & IFF_PROMISC) {\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\ngoto send_fw_cmd;\r\n}\r\nif ((netdev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(netdev) > adapter->max_mc_count)) {\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\ngoto send_fw_cmd;\r\n}\r\nif (!netdev_mc_empty(netdev)) {\r\nnetdev_for_each_mc_addr(ha, netdev)\r\nnx_p3_nic_add_mac(adapter, ha->addr, &del_list);\r\n}\r\nsend_fw_cmd:\r\nadapter->set_promisc(adapter, mode);\r\nhead = &del_list;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, nx_mac_list_t, list);\r\nnx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nstatic int netxen_p3_nic_set_promisc(struct netxen_adapter *adapter, u32 mode)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_PROXY_SET_VPORT_MISS_MODE |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(mode);\r\nreturn netxen_send_cmd_descs(adapter,\r\n(struct cmd_desc_type0 *)&req, 1);\r\n}\r\nvoid netxen_p3_free_mac_list(struct netxen_adapter *adapter)\r\n{\r\nnx_mac_list_t *cur;\r\nstruct list_head *head = &adapter->mac_list;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, nx_mac_list_t, list);\r\nnx_p3_sre_macaddr_change(adapter,\r\ncur->mac_addr, NETXEN_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nstatic int netxen_p3_nic_set_mac_addr(struct netxen_adapter *adapter, u8 *addr)\r\n{\r\nnetxen_p3_nic_set_multi(adapter->netdev);\r\nreturn 0;\r\n}\r\nint netxen_config_intr_coalesce(struct netxen_adapter *adapter)\r\n{\r\nnx_nic_req_t req;\r\nu64 word[6];\r\nint rv, i;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nmemset(word, 0, sizeof(word));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword[0] = NETXEN_CONFIG_INTR_COALESCE | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word[0]);\r\nmemcpy(&word[0], &adapter->coal, sizeof(adapter->coal));\r\nfor (i = 0; i < 6; i++)\r\nreq.words[i] = cpu_to_le64(word[i]);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"interrupt coalescing parameters\n");\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_hw_lro(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv = 0;\r\nif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"configure hw lro request\n");\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_bridged_mode(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv = 0;\r\nif (!!(adapter->flags & NETXEN_NIC_BRIDGE_ENABLED) == enable)\r\nreturn rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_BRIDGING |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "ERROR. Could not send "\r\n"configure bridge mode request\n");\r\n}\r\nadapter->flags ^= NETXEN_NIC_BRIDGE_ENABLED;\r\nreturn rv;\r\n}\r\nint netxen_config_rss(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint i, rv;\r\nstatic const u64 key[] = {\r\n0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\r\n0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\r\n0x255b0ec26d5a56daULL\r\n};\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nword = ((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\r\n((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\r\n((u64)(enable & 0x1) << 8) |\r\n((0x7ULL) << 48);\r\nreq.words[0] = cpu_to_le64(word);\r\nfor (i = 0; i < ARRAY_SIZE(key); i++)\r\nreq.words[i+1] = cpu_to_le64(key[i]);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not configure RSS\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_config_ipaddr(struct netxen_adapter *adapter, __be32 ip, int cmd)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(cmd);\r\nmemcpy(&req.words[1], &ip, sizeof(u32));\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not notify %s IP 0x%x request\n",\r\nadapter->netdev->name,\r\n(cmd == NX_IP_UP) ? "Add" : "Remove", ip);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_linkevent_request(struct netxen_adapter *adapter, int enable)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable | (enable << 8));\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not configure link notification\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_send_lro_cleanup(struct netxen_adapter *adapter)\r\n{\r\nnx_nic_req_t req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__NX_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(nx_nic_req_t));\r\nreq.qhdr = cpu_to_le64(NX_HOST_REQUEST << 23);\r\nword = NX_NIC_H2C_OPCODE_LRO_REQUEST |\r\n((u64)adapter->portnum << 16) |\r\n((u64)NX_NIC_LRO_REQUEST_CLEANUP << 56) ;\r\nreq.req_hdr = cpu_to_le64(word);\r\nrv = netxen_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0) {\r\nprintk(KERN_ERR "%s: could not cleanup lro flows\n",\r\nadapter->netdev->name);\r\n}\r\nreturn rv;\r\n}\r\nint netxen_nic_change_mtu(struct net_device *netdev, int mtu)\r\n{\r\nstruct netxen_adapter *adapter = netdev_priv(netdev);\r\nint rc = 0;\r\nif (adapter->set_mtu)\r\nrc = adapter->set_mtu(adapter, mtu);\r\nif (!rc)\r\nnetdev->mtu = mtu;\r\nreturn rc;\r\n}\r\nstatic int netxen_get_flash_block(struct netxen_adapter *adapter, int base,\r\nint size, __le32 * buf)\r\n{\r\nint i, v, addr;\r\n__le32 *ptr32;\r\nint ret;\r\naddr = base;\r\nptr32 = buf;\r\nfor (i = 0; i < size / sizeof(u32); i++) {\r\nret = netxen_rom_fast_read(adapter, addr, &v);\r\nif (ret)\r\nreturn ret;\r\n*ptr32 = cpu_to_le32(v);\r\nptr32++;\r\naddr += sizeof(u32);\r\n}\r\nif ((char *)buf + size > (char *)ptr32) {\r\n__le32 local;\r\nret = netxen_rom_fast_read(adapter, addr, &v);\r\nif (ret)\r\nreturn ret;\r\nlocal = cpu_to_le32(v);\r\nmemcpy(ptr32, &local, (char *)buf + size - (char *)ptr32);\r\n}\r\nreturn 0;\r\n}\r\nint netxen_get_flash_mac_addr(struct netxen_adapter *adapter, u64 *mac)\r\n{\r\n__le32 *pmac = (__le32 *) mac;\r\nu32 offset;\r\noffset = NX_FW_MAC_ADDR_OFFSET + (adapter->portnum * sizeof(u64));\r\nif (netxen_get_flash_block(adapter, offset, sizeof(u64), pmac) == -1)\r\nreturn -1;\r\nif (*mac == ~0ULL) {\r\noffset = NX_OLD_MAC_ADDR_OFFSET +\r\n(adapter->portnum * sizeof(u64));\r\nif (netxen_get_flash_block(adapter,\r\noffset, sizeof(u64), pmac) == -1)\r\nreturn -1;\r\nif (*mac == ~0ULL)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint netxen_p3_get_mac_addr(struct netxen_adapter *adapter, u64 *mac)\r\n{\r\nuint32_t crbaddr, mac_hi, mac_lo;\r\nint pci_func = adapter->ahw.pci_func;\r\ncrbaddr = CRB_MAC_BLOCK_START +\r\n(4 * ((pci_func/2) * 3)) + (4 * (pci_func & 1));\r\nmac_lo = NXRD32(adapter, crbaddr);\r\nmac_hi = NXRD32(adapter, crbaddr+4);\r\nif (pci_func & 1)\r\n*mac = le64_to_cpu((mac_lo >> 16) | ((u64)mac_hi << 16));\r\nelse\r\n*mac = le64_to_cpu((u64)mac_lo | ((u64)mac_hi << 32));\r\nreturn 0;\r\n}\r\nstatic void\r\nnetxen_nic_pci_set_crbwindow_128M(struct netxen_adapter *adapter,\r\nu32 window)\r\n{\r\nvoid __iomem *offset;\r\nint count = 10;\r\nu8 func = adapter->ahw.pci_func;\r\nif (adapter->ahw.crb_win == window)\r\nreturn;\r\noffset = PCI_OFFSET_SECOND_RANGE(adapter,\r\nNETXEN_PCIX_PH_REG(PCIE_CRB_WINDOW_REG(func)));\r\nwritel(window, offset);\r\ndo {\r\nif (window == readl(offset))\r\nbreak;\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d\n",\r\n(window == NETXEN_WINDOW_ONE));\r\nudelay(1);\r\n} while (--count > 0);\r\nif (count > 0)\r\nadapter->ahw.crb_win = window;\r\n}\r\nstatic int\r\nnetxen_nic_pci_get_crb_addr_2M(struct netxen_adapter *adapter,\r\nulong off, void __iomem **addr)\r\n{\r\ncrb_128M_2M_sub_block_map_t *m;\r\nif ((off >= NETXEN_CRB_MAX) || (off < NETXEN_PCI_CRBSPACE))\r\nreturn -EINVAL;\r\noff -= NETXEN_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\r\nif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\r\n*addr = adapter->ahw.pci_base0 + m->start_2M +\r\n(off - m->start_128M);\r\nreturn 0;\r\n}\r\n*addr = adapter->ahw.pci_base0 + CRB_INDIRECT_2M +\r\n(off & MASK(16));\r\nreturn 1;\r\n}\r\nstatic void\r\nnetxen_nic_pci_set_crbwindow_2M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nu32 window;\r\nvoid __iomem *addr = adapter->ahw.pci_base0 + CRB_WINDOW_2M;\r\noff -= NETXEN_PCI_CRBSPACE;\r\nwindow = CRB_HI(off);\r\nwritel(window, addr);\r\nif (readl(addr) != window) {\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d off 0x%lx\n",\r\nwindow, off);\r\n}\r\n}\r\nstatic void __iomem *\r\nnetxen_nic_map_indirect_address_128M(struct netxen_adapter *adapter,\r\nulong win_off, void __iomem **mem_ptr)\r\n{\r\nulong off = win_off;\r\nvoid __iomem *addr;\r\nresource_size_t mem_base;\r\nif (ADDR_IN_WINDOW1(win_off))\r\noff = NETXEN_CRB_NORMAL(win_off);\r\naddr = pci_base_offset(adapter, off);\r\nif (addr)\r\nreturn addr;\r\nif (adapter->ahw.pci_len0 == 0)\r\noff -= NETXEN_PCI_CRBSPACE;\r\nmem_base = pci_resource_start(adapter->pdev, 0);\r\n*mem_ptr = ioremap(mem_base + (off & PAGE_MASK), PAGE_SIZE);\r\nif (*mem_ptr)\r\naddr = *mem_ptr + (off & (PAGE_SIZE - 1));\r\nreturn addr;\r\n}\r\nstatic int\r\nnetxen_nic_hw_write_wx_128M(struct netxen_adapter *adapter, ulong off, u32 data)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\naddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\r\nif (!addr)\r\nreturn -EIO;\r\nif (ADDR_IN_WINDOW1(off)) {\r\nnetxen_nic_io_write_128M(adapter, addr, data);\r\n} else {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(data, addr);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter,\r\nNETXEN_WINDOW_ONE);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\n}\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn 0;\r\n}\r\nstatic u32\r\nnetxen_nic_hw_read_wx_128M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\nu32 data;\r\naddr = netxen_nic_map_indirect_address_128M(adapter, off, &mem_ptr);\r\nif (!addr)\r\nreturn -EIO;\r\nif (ADDR_IN_WINDOW1(off)) {\r\ndata = netxen_nic_io_read_128M(adapter, addr);\r\n} else {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\ndata = readl(addr);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter,\r\nNETXEN_WINDOW_ONE);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\n}\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn data;\r\n}\r\nstatic int\r\nnetxen_nic_hw_write_wx_2M(struct netxen_adapter *adapter, ulong off, u32 data)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nvoid __iomem *addr = NULL;\r\nrv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0) {\r\nwritel(data, addr);\r\nreturn 0;\r\n}\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nnetxen_nic_pci_set_crbwindow_2M(adapter, off);\r\nwritel(data, addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\nreturn 0;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -EIO;\r\n}\r\nstatic u32\r\nnetxen_nic_hw_read_wx_2M(struct netxen_adapter *adapter, ulong off)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nu32 data;\r\nvoid __iomem *addr = NULL;\r\nrv = netxen_nic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0)\r\nreturn readl(addr);\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw.crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nnetxen_nic_pci_set_crbwindow_2M(adapter, off);\r\ndata = readl(addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw.crb_lock, flags);\r\nreturn data;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -1;\r\n}\r\nstatic void netxen_nic_io_write_128M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr, u32 data)\r\n{\r\nread_lock(&adapter->ahw.crb_lock);\r\nwritel(data, addr);\r\nread_unlock(&adapter->ahw.crb_lock);\r\n}\r\nstatic u32 netxen_nic_io_read_128M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr)\r\n{\r\nu32 val;\r\nread_lock(&adapter->ahw.crb_lock);\r\nval = readl(addr);\r\nread_unlock(&adapter->ahw.crb_lock);\r\nreturn val;\r\n}\r\nstatic void netxen_nic_io_write_2M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr, u32 data)\r\n{\r\nwritel(data, addr);\r\n}\r\nstatic u32 netxen_nic_io_read_2M(struct netxen_adapter *adapter,\r\nvoid __iomem *addr)\r\n{\r\nreturn readl(addr);\r\n}\r\nvoid __iomem *\r\nnetxen_get_ioaddr(struct netxen_adapter *adapter, u32 offset)\r\n{\r\nvoid __iomem *addr = NULL;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nif ((offset < NETXEN_CRB_PCIX_HOST2) &&\r\n(offset > NETXEN_CRB_PCIX_HOST))\r\naddr = PCI_OFFSET_SECOND_RANGE(adapter, offset);\r\nelse\r\naddr = NETXEN_CRB_NORMALIZE(adapter, offset);\r\n} else {\r\nWARN_ON(netxen_nic_pci_get_crb_addr_2M(adapter,\r\noffset, &addr));\r\n}\r\nreturn addr;\r\n}\r\nstatic int\r\nnetxen_nic_pci_set_window_128M(struct netxen_adapter *adapter,\r\nu64 addr, u32 *start)\r\n{\r\nif (ADDR_IN_RANGE(addr, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\r\n*start = (addr - NETXEN_ADDR_OCM0 + NETXEN_PCI_OCM0);\r\nreturn 0;\r\n} else if (ADDR_IN_RANGE(addr,\r\nNETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\n*start = (addr - NETXEN_ADDR_OCM1 + NETXEN_PCI_OCM1);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nnetxen_nic_pci_set_window_2M(struct netxen_adapter *adapter,\r\nu64 addr, u32 *start)\r\n{\r\nu32 window;\r\nwindow = OCM_WIN(addr);\r\nwritel(window, adapter->ahw.ocm_win_crb);\r\nreadl(adapter->ahw.ocm_win_crb);\r\nadapter->ahw.ocm_win = window;\r\n*start = NETXEN_PCI_OCM0_2M + GET_MEM_OFFS_2M(addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_access_direct(struct netxen_adapter *adapter, u64 off,\r\nu64 *data, int op)\r\n{\r\nvoid __iomem *addr, *mem_ptr = NULL;\r\nresource_size_t mem_base;\r\nint ret;\r\nu32 start;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nret = adapter->pci_set_window(adapter, off, &start);\r\nif (ret != 0)\r\ngoto unlock;\r\nif (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {\r\naddr = adapter->ahw.pci_base0 + start;\r\n} else {\r\naddr = pci_base_offset(adapter, start);\r\nif (addr)\r\ngoto noremap;\r\nmem_base = pci_resource_start(adapter->pdev, 0) +\r\n(start & PAGE_MASK);\r\nmem_ptr = ioremap(mem_base, PAGE_SIZE);\r\nif (mem_ptr == NULL) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\naddr = mem_ptr + (start & (PAGE_SIZE-1));\r\n}\r\nnoremap:\r\nif (op == 0)\r\n*data = readq(addr);\r\nelse\r\nwriteq(*data, addr);\r\nunlock:\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nvoid\r\nnetxen_pci_camqm_read_2M(struct netxen_adapter *adapter, u64 off, u64 *data)\r\n{\r\nvoid __iomem *addr = adapter->ahw.pci_base0 +\r\nNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\r\nspin_lock(&adapter->ahw.mem_lock);\r\n*data = readq(addr);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\n}\r\nvoid\r\nnetxen_pci_camqm_write_2M(struct netxen_adapter *adapter, u64 off, u64 data)\r\n{\r\nvoid __iomem *addr = adapter->ahw.pci_base0 +\r\nNETXEN_PCI_CAMQM_2M_BASE + (off - NETXEN_PCI_CAMQM);\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwriteq(data, addr);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_write_128M(struct netxen_adapter *adapter,\r\nu64 off, u64 data)\r\n{\r\nint j, ret;\r\nu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P2)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\r\naddr_hi = SIU_TEST_AGT_ADDR_HI;\r\ndata_lo = SIU_TEST_AGT_WRDATA_LO;\r\ndata_hi = SIU_TEST_AGT_WRDATA_HI;\r\noff_lo = off & SIU_TEST_AGT_ADDR_MASK;\r\noff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\naddr_hi = MIU_TEST_AGT_ADDR_HI;\r\ndata_lo = MIU_TEST_AGT_WRDATA_LO;\r\ndata_hi = MIU_TEST_AGT_WRDATA_HI;\r\noff_lo = off & MIU_TEST_AGT_ADDR_MASK;\r\noff_hi = 0;\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\r\nADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\nif (adapter->ahw.pci_len0 != 0) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, &data, 1);\r\n}\r\n}\r\nreturn -EIO;\r\ncorrect:\r\nspin_lock(&adapter->ahw.mem_lock);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(off_hi, (mem_crb + addr_hi));\r\nwritel(data & 0xffffffff, (mem_crb + data_lo));\r\nwritel((data >> 32) & 0xffffffff, (mem_crb + data_hi));\r\nwritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl((mem_crb + TEST_AGT_CTRL));\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_read_128M(struct netxen_adapter *adapter,\r\nu64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off_lo, off_hi, addr_hi, data_hi, data_lo;\r\nu64 val;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P2)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_QDR_NET+SIU_TEST_AGT_BASE);\r\naddr_hi = SIU_TEST_AGT_ADDR_HI;\r\ndata_lo = SIU_TEST_AGT_RDDATA_LO;\r\ndata_hi = SIU_TEST_AGT_RDDATA_HI;\r\noff_lo = off & SIU_TEST_AGT_ADDR_MASK;\r\noff_hi = SIU_TEST_AGT_UPPER_ADDR(off);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = pci_base_offset(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\naddr_hi = MIU_TEST_AGT_ADDR_HI;\r\ndata_lo = MIU_TEST_AGT_RDDATA_LO;\r\ndata_hi = MIU_TEST_AGT_RDDATA_HI;\r\noff_lo = off & MIU_TEST_AGT_ADDR_MASK;\r\noff_hi = 0;\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX) ||\r\nADDR_IN_RANGE(off, NETXEN_ADDR_OCM1, NETXEN_ADDR_OCM1_MAX)) {\r\nif (adapter->ahw.pci_len0 != 0) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, data, 0);\r\n}\r\n}\r\nreturn -EIO;\r\ncorrect:\r\nspin_lock(&adapter->ahw.mem_lock);\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, 0);\r\nwritel(off_lo, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(off_hi, (mem_crb + addr_hi));\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START|TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\ntemp = readl(mem_crb + data_hi);\r\nval = ((u64)temp << 32);\r\nval |= readl(mem_crb + data_lo);\r\n*data = val;\r\nret = 0;\r\n}\r\nnetxen_nic_pci_set_crbwindow_128M(adapter, NETXEN_WINDOW_ONE);\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_write_2M(struct netxen_adapter *adapter,\r\nu64 off, u64 data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P3)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX))\r\nreturn netxen_nic_pci_mem_access_direct(adapter, off, &data, 1);\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & 0xfffffff8;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\nwritel(data & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA_LO);\r\nwritel((data >> 32) & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA_HI);\r\nwritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\nnetxen_nic_pci_mem_read_2M(struct netxen_adapter *adapter,\r\nu64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nu64 val;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_QDR_NET,\r\nNETXEN_ADDR_QDR_NET_MAX_P3)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_DDR_NET, NETXEN_ADDR_DDR_NET_MAX)) {\r\nmem_crb = netxen_get_ioaddr(adapter,\r\nNETXEN_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, NETXEN_ADDR_OCM0, NETXEN_ADDR_OCM0_MAX)) {\r\nreturn netxen_nic_pci_mem_access_direct(adapter,\r\noff, data, 0);\r\n}\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & 0xfffffff8;\r\nspin_lock(&adapter->ahw.mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\nval = (u64)(readl(mem_crb + MIU_TEST_AGT_RDDATA_HI)) << 32;\r\nval |= readl(mem_crb + MIU_TEST_AGT_RDDATA_LO);\r\n*data = val;\r\nret = 0;\r\n}\r\nspin_unlock(&adapter->ahw.mem_lock);\r\nreturn ret;\r\n}\r\nvoid\r\nnetxen_setup_hwops(struct netxen_adapter *adapter)\r\n{\r\nadapter->init_port = netxen_niu_xg_init_port;\r\nadapter->stop_port = netxen_niu_disable_xg_port;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nadapter->crb_read = netxen_nic_hw_read_wx_128M,\r\nadapter->crb_write = netxen_nic_hw_write_wx_128M,\r\nadapter->pci_set_window = netxen_nic_pci_set_window_128M,\r\nadapter->pci_mem_read = netxen_nic_pci_mem_read_128M,\r\nadapter->pci_mem_write = netxen_nic_pci_mem_write_128M,\r\nadapter->io_read = netxen_nic_io_read_128M,\r\nadapter->io_write = netxen_nic_io_write_128M,\r\nadapter->macaddr_set = netxen_p2_nic_set_mac_addr;\r\nadapter->set_multi = netxen_p2_nic_set_multi;\r\nadapter->set_mtu = netxen_nic_set_mtu_xgb;\r\nadapter->set_promisc = netxen_p2_nic_set_promisc;\r\n} else {\r\nadapter->crb_read = netxen_nic_hw_read_wx_2M,\r\nadapter->crb_write = netxen_nic_hw_write_wx_2M,\r\nadapter->pci_set_window = netxen_nic_pci_set_window_2M,\r\nadapter->pci_mem_read = netxen_nic_pci_mem_read_2M,\r\nadapter->pci_mem_write = netxen_nic_pci_mem_write_2M,\r\nadapter->io_read = netxen_nic_io_read_2M,\r\nadapter->io_write = netxen_nic_io_write_2M,\r\nadapter->set_mtu = nx_fw_cmd_set_mtu;\r\nadapter->set_promisc = netxen_p3_nic_set_promisc;\r\nadapter->macaddr_set = netxen_p3_nic_set_mac_addr;\r\nadapter->set_multi = netxen_p3_nic_set_multi;\r\nadapter->phy_read = nx_fw_cmd_query_phy;\r\nadapter->phy_write = nx_fw_cmd_set_phy;\r\n}\r\n}\r\nint netxen_nic_get_board_info(struct netxen_adapter *adapter)\r\n{\r\nint offset, board_type, magic;\r\nstruct pci_dev *pdev = adapter->pdev;\r\noffset = NX_FW_MAGIC_OFFSET;\r\nif (netxen_rom_fast_read(adapter, offset, &magic))\r\nreturn -EIO;\r\nif (magic != NETXEN_BDINFO_MAGIC) {\r\ndev_err(&pdev->dev, "invalid board config, magic=%08x\n",\r\nmagic);\r\nreturn -EIO;\r\n}\r\noffset = NX_BRDTYPE_OFFSET;\r\nif (netxen_rom_fast_read(adapter, offset, &board_type))\r\nreturn -EIO;\r\nif (board_type == NETXEN_BRDTYPE_P3_4_GB_MM) {\r\nu32 gpio = NXRD32(adapter, NETXEN_ROMUSB_GLB_PAD_GPIO_I);\r\nif ((gpio & 0x8000) == 0)\r\nboard_type = NETXEN_BRDTYPE_P3_10G_TP;\r\n}\r\nadapter->ahw.board_type = board_type;\r\nswitch (board_type) {\r\ncase NETXEN_BRDTYPE_P2_SB35_4G:\r\nadapter->ahw.port_type = NETXEN_NIC_GBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P2_SB31_10G:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_IMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_HMEZ:\r\ncase NETXEN_BRDTYPE_P2_SB31_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_HMEZ:\r\ncase NETXEN_BRDTYPE_P3_XG_LOM:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4:\r\ncase NETXEN_BRDTYPE_P3_10G_CX4_LP:\r\ncase NETXEN_BRDTYPE_P3_IMEZ:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_PLUS:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_CT:\r\ncase NETXEN_BRDTYPE_P3_10G_SFP_QT:\r\ncase NETXEN_BRDTYPE_P3_10G_XFP:\r\ncase NETXEN_BRDTYPE_P3_10000_BASE_T:\r\nadapter->ahw.port_type = NETXEN_NIC_XGBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P1_BD:\r\ncase NETXEN_BRDTYPE_P1_SB:\r\ncase NETXEN_BRDTYPE_P1_SMAX:\r\ncase NETXEN_BRDTYPE_P1_SOCK:\r\ncase NETXEN_BRDTYPE_P3_REF_QG:\r\ncase NETXEN_BRDTYPE_P3_4_GB:\r\ncase NETXEN_BRDTYPE_P3_4_GB_MM:\r\nadapter->ahw.port_type = NETXEN_NIC_GBE;\r\nbreak;\r\ncase NETXEN_BRDTYPE_P3_10G_TP:\r\nadapter->ahw.port_type = (adapter->portnum < 2) ?\r\nNETXEN_NIC_XGBE : NETXEN_NIC_GBE;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unknown board type %x\n", board_type);\r\nadapter->ahw.port_type = NETXEN_NIC_XGBE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_nic_set_mtu_xgb(struct netxen_adapter *adapter, int new_mtu)\r\n{\r\nnew_mtu += MTU_FUDGE_FACTOR;\r\nif (adapter->physical_port == 0)\r\nNXWR32(adapter, NETXEN_NIU_XGE_MAX_FRAME_SIZE, new_mtu);\r\nelse\r\nNXWR32(adapter, NETXEN_NIU_XG1_MAX_FRAME_SIZE, new_mtu);\r\nreturn 0;\r\n}\r\nvoid netxen_nic_set_link_parameters(struct netxen_adapter *adapter)\r\n{\r\n__u32 status;\r\n__u32 autoneg;\r\n__u32 port_mode;\r\nif (!netif_carrier_ok(adapter->netdev)) {\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = -1;\r\nadapter->link_autoneg = AUTONEG_ENABLE;\r\nreturn;\r\n}\r\nif (adapter->ahw.port_type == NETXEN_NIC_GBE) {\r\nport_mode = NXRD32(adapter, NETXEN_PORT_MODE_ADDR);\r\nif (port_mode == NETXEN_PORT_MODE_802_3_AP) {\r\nadapter->link_speed = SPEED_1000;\r\nadapter->link_duplex = DUPLEX_FULL;\r\nadapter->link_autoneg = AUTONEG_DISABLE;\r\nreturn;\r\n}\r\nif (adapter->phy_read &&\r\nadapter->phy_read(adapter,\r\nNETXEN_NIU_GB_MII_MGMT_ADDR_PHY_STATUS,\r\n&status) == 0) {\r\nif (netxen_get_phy_link(status)) {\r\nswitch (netxen_get_phy_speed(status)) {\r\ncase 0:\r\nadapter->link_speed = SPEED_10;\r\nbreak;\r\ncase 1:\r\nadapter->link_speed = SPEED_100;\r\nbreak;\r\ncase 2:\r\nadapter->link_speed = SPEED_1000;\r\nbreak;\r\ndefault:\r\nadapter->link_speed = 0;\r\nbreak;\r\n}\r\nswitch (netxen_get_phy_duplex(status)) {\r\ncase 0:\r\nadapter->link_duplex = DUPLEX_HALF;\r\nbreak;\r\ncase 1:\r\nadapter->link_duplex = DUPLEX_FULL;\r\nbreak;\r\ndefault:\r\nadapter->link_duplex = -1;\r\nbreak;\r\n}\r\nif (adapter->phy_read &&\r\nadapter->phy_read(adapter,\r\nNETXEN_NIU_GB_MII_MGMT_ADDR_AUTONEG,\r\n&autoneg) == 0)\r\nadapter->link_autoneg = autoneg;\r\n} else\r\ngoto link_down;\r\n} else {\r\nlink_down:\r\nadapter->link_speed = 0;\r\nadapter->link_duplex = -1;\r\n}\r\n}\r\n}\r\nint\r\nnetxen_nic_wol_supported(struct netxen_adapter *adapter)\r\n{\r\nu32 wol_cfg;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nreturn 0;\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG_NV);\r\nif (wol_cfg & (1UL << adapter->portnum)) {\r\nwol_cfg = NXRD32(adapter, NETXEN_WOL_CONFIG);\r\nif (wol_cfg & (1 << adapter->portnum))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 netxen_md_cntrl(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_template_hdr *template_hdr,\r\nstruct netxen_minidump_entry_crb *crtEntry)\r\n{\r\nint loop_cnt, i, rv = 0, timeout_flag;\r\nu32 op_count, stride;\r\nu32 opcode, read_value, addr;\r\nunsigned long timeout, timeout_jiffies;\r\naddr = crtEntry->addr;\r\nop_count = crtEntry->op_count;\r\nstride = crtEntry->addr_stride;\r\nfor (loop_cnt = 0; loop_cnt < op_count; loop_cnt++) {\r\nfor (i = 0; i < sizeof(crtEntry->opcode) * 8; i++) {\r\nopcode = (crtEntry->opcode & (0x1 << i));\r\nif (opcode) {\r\nswitch (opcode) {\r\ncase NX_DUMP_WCRB:\r\nNX_WR_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\ncrtEntry->value_1);\r\nbreak;\r\ncase NX_DUMP_RWCRB:\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\nNX_WR_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\nread_value);\r\nbreak;\r\ncase NX_DUMP_ANDCRB:\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\nread_value &= crtEntry->value_2;\r\nNX_WR_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\nread_value);\r\nbreak;\r\ncase NX_DUMP_ORCRB:\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\nread_value |= crtEntry->value_3;\r\nNX_WR_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\nread_value);\r\nbreak;\r\ncase NX_DUMP_POLLCRB:\r\ntimeout = crtEntry->poll_timeout;\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\ntimeout_jiffies =\r\nmsecs_to_jiffies(timeout) + jiffies;\r\nfor (timeout_flag = 0;\r\n!timeout_flag\r\n&& ((read_value & crtEntry->value_2)\r\n!= crtEntry->value_1);) {\r\nif (time_after(jiffies,\r\ntimeout_jiffies))\r\ntimeout_flag = 1;\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\n}\r\nif (timeout_flag) {\r\ndev_err(&adapter->pdev->dev, "%s : "\r\n"Timeout in poll_crb control operation.\n"\r\n, __func__);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase NX_DUMP_RD_SAVE:\r\nif (crtEntry->state_index_a)\r\naddr =\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_a];\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_v]\r\n= read_value;\r\nbreak;\r\ncase NX_DUMP_WRT_SAVED:\r\nif (crtEntry->state_index_v)\r\nread_value =\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_v];\r\nelse\r\nread_value = crtEntry->value_1;\r\nif (crtEntry->state_index_a)\r\naddr =\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_a];\r\nNX_WR_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\nread_value);\r\nbreak;\r\ncase NX_DUMP_MOD_SAVE_ST:\r\nread_value =\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_v];\r\nread_value <<= crtEntry->shl;\r\nread_value >>= crtEntry->shr;\r\nif (crtEntry->value_2)\r\nread_value &=\r\ncrtEntry->value_2;\r\nread_value |= crtEntry->value_3;\r\nread_value += crtEntry->value_1;\r\ntemplate_hdr->saved_state_array\r\n[crtEntry->state_index_v]\r\n= read_value;\r\nbreak;\r\ndefault:\r\nrv = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\naddr = addr + stride;\r\n}\r\nreturn rv;\r\n}\r\nstatic u32\r\nnetxen_md_rdmem(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_rdmem\r\n*memEntry, u64 *data_buff)\r\n{\r\nu64 addr, value = 0;\r\nint i = 0, loop_cnt;\r\naddr = (u64)memEntry->read_addr;\r\nloop_cnt = memEntry->read_data_size;\r\nloop_cnt /= sizeof(value);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nif (netxen_nic_pci_mem_read_2M(adapter, addr, &value))\r\ngoto out;\r\n*data_buff++ = value;\r\naddr += sizeof(value);\r\n}\r\nout:\r\nreturn i * sizeof(value);\r\n}\r\nstatic u32 netxen_md_rd_crb(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_crb\r\n*crbEntry, u32 *data_buff)\r\n{\r\nint loop_cnt;\r\nu32 op_count, addr, stride, value;\r\naddr = crbEntry->addr;\r\nop_count = crbEntry->op_count;\r\nstride = crbEntry->addr_stride;\r\nfor (loop_cnt = 0; loop_cnt < op_count; loop_cnt++) {\r\nNX_RD_DUMP_REG(addr, adapter->ahw.pci_base0, &value);\r\n*data_buff++ = addr;\r\n*data_buff++ = value;\r\naddr = addr + stride;\r\n}\r\nreturn loop_cnt * (2 * sizeof(u32));\r\n}\r\nstatic u32\r\nnetxen_md_rdrom(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_rdrom\r\n*romEntry, __le32 *data_buff)\r\n{\r\nint i, count = 0;\r\nu32 size, lck_val;\r\nu32 val;\r\nu32 fl_addr, waddr, raddr;\r\nfl_addr = romEntry->read_addr;\r\nsize = romEntry->read_data_size/4;\r\nlock_try:\r\nlck_val = readl((void __iomem *)(adapter->ahw.pci_base0 +\r\nNX_FLASH_SEM2_LK));\r\nif (!lck_val && count < MAX_CTL_CHECK) {\r\nmsleep(20);\r\ncount++;\r\ngoto lock_try;\r\n}\r\nwritel(adapter->ahw.pci_func, (void __iomem *)(adapter->ahw.pci_base0 +\r\nNX_FLASH_LOCK_ID));\r\nfor (i = 0; i < size; i++) {\r\nwaddr = fl_addr & 0xFFFF0000;\r\nNX_WR_DUMP_REG(FLASH_ROM_WINDOW, adapter->ahw.pci_base0, waddr);\r\nraddr = FLASH_ROM_DATA + (fl_addr & 0x0000FFFF);\r\nNX_RD_DUMP_REG(raddr, adapter->ahw.pci_base0, &val);\r\n*data_buff++ = cpu_to_le32(val);\r\nfl_addr += sizeof(val);\r\n}\r\nreadl((void __iomem *)(adapter->ahw.pci_base0 + NX_FLASH_SEM2_ULK));\r\nreturn romEntry->read_data_size;\r\n}\r\nstatic u32\r\nnetxen_md_L2Cache(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_cache\r\n*cacheEntry, u32 *data_buff)\r\n{\r\nint loop_cnt, i, k, timeout_flag = 0;\r\nu32 addr, read_addr, read_value, cntrl_addr, tag_reg_addr;\r\nu32 tag_value, read_cnt;\r\nu8 cntl_value_w, cntl_value_r;\r\nunsigned long timeout, timeout_jiffies;\r\nloop_cnt = cacheEntry->op_count;\r\nread_addr = cacheEntry->read_addr;\r\ncntrl_addr = cacheEntry->control_addr;\r\ncntl_value_w = (u32) cacheEntry->write_value;\r\ntag_reg_addr = cacheEntry->tag_reg_addr;\r\ntag_value = cacheEntry->init_tag_value;\r\nread_cnt = cacheEntry->read_addr_cnt;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nNX_WR_DUMP_REG(tag_reg_addr, adapter->ahw.pci_base0, tag_value);\r\nif (cntl_value_w)\r\nNX_WR_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\r\n(u32)cntl_value_w);\r\nif (cacheEntry->poll_mask) {\r\ntimeout = cacheEntry->poll_wait;\r\nNX_RD_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\r\n&cntl_value_r);\r\ntimeout_jiffies = msecs_to_jiffies(timeout) + jiffies;\r\nfor (timeout_flag = 0; !timeout_flag &&\r\n((cntl_value_r & cacheEntry->poll_mask) != 0);) {\r\nif (time_after(jiffies, timeout_jiffies))\r\ntimeout_flag = 1;\r\nNX_RD_DUMP_REG(cntrl_addr,\r\nadapter->ahw.pci_base0,\r\n&cntl_value_r);\r\n}\r\nif (timeout_flag) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout in processing L2 Tag poll.\n");\r\nreturn -1;\r\n}\r\n}\r\naddr = read_addr;\r\nfor (k = 0; k < read_cnt; k++) {\r\nNX_RD_DUMP_REG(addr, adapter->ahw.pci_base0,\r\n&read_value);\r\n*data_buff++ = read_value;\r\naddr += cacheEntry->read_addr_stride;\r\n}\r\ntag_value += cacheEntry->tag_value_stride;\r\n}\r\nreturn read_cnt * loop_cnt * sizeof(read_value);\r\n}\r\nstatic u32 netxen_md_L1Cache(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_cache\r\n*cacheEntry, u32 *data_buff)\r\n{\r\nint i, k, loop_cnt;\r\nu32 addr, read_addr, read_value, cntrl_addr, tag_reg_addr;\r\nu32 tag_value, read_cnt;\r\nu8 cntl_value_w;\r\nloop_cnt = cacheEntry->op_count;\r\nread_addr = cacheEntry->read_addr;\r\ncntrl_addr = cacheEntry->control_addr;\r\ncntl_value_w = (u32) cacheEntry->write_value;\r\ntag_reg_addr = cacheEntry->tag_reg_addr;\r\ntag_value = cacheEntry->init_tag_value;\r\nread_cnt = cacheEntry->read_addr_cnt;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nNX_WR_DUMP_REG(tag_reg_addr, adapter->ahw.pci_base0, tag_value);\r\nNX_WR_DUMP_REG(cntrl_addr, adapter->ahw.pci_base0,\r\n(u32) cntl_value_w);\r\naddr = read_addr;\r\nfor (k = 0; k < read_cnt; k++) {\r\nNX_RD_DUMP_REG(addr,\r\nadapter->ahw.pci_base0,\r\n&read_value);\r\n*data_buff++ = read_value;\r\naddr += cacheEntry->read_addr_stride;\r\n}\r\ntag_value += cacheEntry->tag_value_stride;\r\n}\r\nreturn read_cnt * loop_cnt * sizeof(read_value);\r\n}\r\nstatic u32\r\nnetxen_md_rdocm(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_rdocm\r\n*ocmEntry, u32 *data_buff)\r\n{\r\nint i, loop_cnt;\r\nu32 value;\r\nvoid __iomem *addr;\r\naddr = (ocmEntry->read_addr + adapter->ahw.pci_base0);\r\nloop_cnt = ocmEntry->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nvalue = readl(addr);\r\n*data_buff++ = value;\r\naddr += ocmEntry->read_addr_stride;\r\n}\r\nreturn i * sizeof(u32);\r\n}\r\nstatic u32\r\nnetxen_md_rdmux(struct netxen_adapter *adapter, struct netxen_minidump_entry_mux\r\n*muxEntry, u32 *data_buff)\r\n{\r\nint loop_cnt = 0;\r\nu32 read_addr, read_value, select_addr, sel_value;\r\nread_addr = muxEntry->read_addr;\r\nsel_value = muxEntry->select_value;\r\nselect_addr = muxEntry->select_addr;\r\nfor (loop_cnt = 0; loop_cnt < muxEntry->op_count; loop_cnt++) {\r\nNX_WR_DUMP_REG(select_addr, adapter->ahw.pci_base0, sel_value);\r\nNX_RD_DUMP_REG(read_addr, adapter->ahw.pci_base0, &read_value);\r\n*data_buff++ = sel_value;\r\n*data_buff++ = read_value;\r\nsel_value += muxEntry->select_value_stride;\r\n}\r\nreturn loop_cnt * (2 * sizeof(u32));\r\n}\r\nstatic u32\r\nnetxen_md_rdqueue(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry_queue\r\n*queueEntry, u32 *data_buff)\r\n{\r\nint loop_cnt, k;\r\nu32 queue_id, read_addr, read_value, read_stride, select_addr, read_cnt;\r\nread_cnt = queueEntry->read_addr_cnt;\r\nread_stride = queueEntry->read_addr_stride;\r\nselect_addr = queueEntry->select_addr;\r\nfor (loop_cnt = 0, queue_id = 0; loop_cnt < queueEntry->op_count;\r\nloop_cnt++) {\r\nNX_WR_DUMP_REG(select_addr, adapter->ahw.pci_base0, queue_id);\r\nread_addr = queueEntry->read_addr;\r\nfor (k = 0; k < read_cnt; k--) {\r\nNX_RD_DUMP_REG(read_addr, adapter->ahw.pci_base0,\r\n&read_value);\r\n*data_buff++ = read_value;\r\nread_addr += read_stride;\r\n}\r\nqueue_id += queueEntry->queue_id_stride;\r\n}\r\nreturn loop_cnt * (read_cnt * sizeof(read_value));\r\n}\r\nstatic int netxen_md_entry_err_chk(struct netxen_adapter *adapter,\r\nstruct netxen_minidump_entry *entry, int esize)\r\n{\r\nif (esize < 0) {\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nreturn esize;\r\n}\r\nif (esize != entry->hdr.entry_capture_size) {\r\nentry->hdr.entry_capture_size = esize;\r\nentry->hdr.driver_flags |= NX_DUMP_SIZE_ERR;\r\ndev_info(&adapter->pdev->dev,\r\n"Invalidate dump, Type:%d\tMask:%d\tSize:%dCap_size:%d\n",\r\nentry->hdr.entry_type, entry->hdr.entry_capture_mask,\r\nesize, entry->hdr.entry_capture_size);\r\ndev_info(&adapter->pdev->dev, "Aborting further dump capture\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int netxen_parse_md_template(struct netxen_adapter *adapter)\r\n{\r\nint num_of_entries, buff_level, e_cnt, esize;\r\nint end_cnt = 0, rv = 0, sane_start = 0, sane_end = 0;\r\nchar *dbuff;\r\nvoid *template_buff = adapter->mdump.md_template;\r\nchar *dump_buff = adapter->mdump.md_capture_buff;\r\nint capture_mask = adapter->mdump.md_capture_mask;\r\nstruct netxen_minidump_template_hdr *template_hdr;\r\nstruct netxen_minidump_entry *entry;\r\nif ((capture_mask & 0x3) != 0x3) {\r\ndev_err(&adapter->pdev->dev, "Capture mask %02x below minimum needed "\r\n"for valid firmware dump\n", capture_mask);\r\nreturn -EINVAL;\r\n}\r\ntemplate_hdr = (struct netxen_minidump_template_hdr *) template_buff;\r\nnum_of_entries = template_hdr->num_of_entries;\r\nentry = (struct netxen_minidump_entry *) ((char *) template_buff +\r\ntemplate_hdr->first_entry_offset);\r\nmemcpy(dump_buff, template_buff, adapter->mdump.md_template_size);\r\ndump_buff = dump_buff + adapter->mdump.md_template_size;\r\nif (template_hdr->entry_type == TLHDR)\r\nsane_start = 1;\r\nfor (e_cnt = 0, buff_level = 0; e_cnt < num_of_entries; e_cnt++) {\r\nif (!(entry->hdr.entry_capture_mask & capture_mask)) {\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nentry = (struct netxen_minidump_entry *)\r\n((char *) entry + entry->hdr.entry_size);\r\ncontinue;\r\n}\r\nswitch (entry->hdr.entry_type) {\r\ncase RDNOP:\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nbreak;\r\ncase RDEND:\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nif (!sane_end)\r\nend_cnt = e_cnt;\r\nsane_end += 1;\r\nbreak;\r\ncase CNTRL:\r\nrv = netxen_md_cntrl(adapter,\r\ntemplate_hdr, (void *)entry);\r\nif (rv)\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nbreak;\r\ncase RDCRB:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rd_crb(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase RDMN:\r\ncase RDMEM:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rdmem(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase BOARD:\r\ncase RDROM:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rdrom(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase L2ITG:\r\ncase L2DTG:\r\ncase L2DAT:\r\ncase L2INS:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_L2Cache(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase L1DAT:\r\ncase L1INS:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_L1Cache(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase RDOCM:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rdocm(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase RDMUX:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rdmux(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ncase QUEUE:\r\ndbuff = dump_buff + buff_level;\r\nesize = netxen_md_rdqueue(adapter,\r\n(void *) entry, (void *) dbuff);\r\nrv = netxen_md_entry_err_chk\r\n(adapter, entry, esize);\r\nif (rv < 0)\r\nbreak;\r\nbuff_level += esize;\r\nbreak;\r\ndefault:\r\nentry->hdr.driver_flags |= NX_DUMP_SKIP;\r\nbreak;\r\n}\r\nentry = (struct netxen_minidump_entry *)\r\n((char *) entry + entry->hdr.entry_size);\r\n}\r\nif (!sane_start || sane_end > 1) {\r\ndev_err(&adapter->pdev->dev,\r\n"Firmware minidump template configuration error.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_collect_minidump(struct netxen_adapter *adapter)\r\n{\r\nint ret = 0;\r\nstruct netxen_minidump_template_hdr *hdr;\r\nstruct timespec val;\r\nhdr = (struct netxen_minidump_template_hdr *)\r\nadapter->mdump.md_template;\r\nhdr->driver_capture_mask = adapter->mdump.md_capture_mask;\r\njiffies_to_timespec(jiffies, &val);\r\nhdr->driver_timestamp = (u32) val.tv_sec;\r\nhdr->driver_info_word2 = adapter->fw_version;\r\nhdr->driver_info_word3 = NXRD32(adapter, CRB_DRIVER_VERSION);\r\nret = netxen_parse_md_template(adapter);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nvoid\r\nnetxen_dump_fw(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_minidump_template_hdr *hdr;\r\nint i, k, data_size = 0;\r\nu32 capture_mask;\r\nhdr = (struct netxen_minidump_template_hdr *)\r\nadapter->mdump.md_template;\r\ncapture_mask = adapter->mdump.md_capture_mask;\r\nfor (i = 0x2, k = 1; (i & NX_DUMP_MASK_MAX); i <<= 1, k++) {\r\nif (i & capture_mask)\r\ndata_size += hdr->capture_size_array[k];\r\n}\r\nif (!data_size) {\r\ndev_err(&adapter->pdev->dev,\r\n"Invalid cap sizes for capture_mask=0x%x\n",\r\nadapter->mdump.md_capture_mask);\r\nreturn;\r\n}\r\nadapter->mdump.md_capture_size = data_size;\r\nadapter->mdump.md_dump_size = adapter->mdump.md_template_size +\r\nadapter->mdump.md_capture_size;\r\nif (!adapter->mdump.md_capture_buff) {\r\nadapter->mdump.md_capture_buff =\r\nvzalloc(adapter->mdump.md_dump_size);\r\nif (!adapter->mdump.md_capture_buff)\r\nreturn;\r\nif (netxen_collect_minidump(adapter)) {\r\nadapter->mdump.has_valid_dump = 0;\r\nadapter->mdump.md_dump_size = 0;\r\nvfree(adapter->mdump.md_capture_buff);\r\nadapter->mdump.md_capture_buff = NULL;\r\ndev_err(&adapter->pdev->dev,\r\n"Error in collecting firmware minidump.\n");\r\n} else {\r\nadapter->mdump.md_timestamp = jiffies;\r\nadapter->mdump.has_valid_dump = 1;\r\nadapter->fw_mdump_rdy = 1;\r\ndev_info(&adapter->pdev->dev, "%s Successfully "\r\n"collected fw dump.\n", adapter->netdev->name);\r\n}\r\n} else {\r\ndev_info(&adapter->pdev->dev,\r\n"Cannot overwrite previously collected "\r\n"firmware minidump.\n");\r\nadapter->fw_mdump_rdy = 1;\r\nreturn;\r\n}\r\n}
