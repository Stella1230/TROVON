static int dib3000_read_reg(struct dib3000_state *state, u16 reg)\r\n{\r\nu8 wb[] = { ((reg >> 8) | 0x80) & 0xff, reg & 0xff };\r\nu8 rb[2];\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config.demod_address, .flags = 0, .buf = wb, .len = 2 },\r\n{ .addr = state->config.demod_address, .flags = I2C_M_RD, .buf = rb, .len = 2 },\r\n};\r\nif (i2c_transfer(state->i2c, msg, 2) != 2)\r\ndeb_i2c("i2c read error\n");\r\ndeb_i2c("reading i2c bus (reg: %5d 0x%04x, val: %5d 0x%04x)\n",reg,reg,\r\n(rb[0] << 8) | rb[1],(rb[0] << 8) | rb[1]);\r\nreturn (rb[0] << 8) | rb[1];\r\n}\r\nstatic int dib3000_write_reg(struct dib3000_state *state, u16 reg, u16 val)\r\n{\r\nu8 b[] = {\r\n(reg >> 8) & 0xff, reg & 0xff,\r\n(val >> 8) & 0xff, val & 0xff,\r\n};\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config.demod_address, .flags = 0, .buf = b, .len = 4 }\r\n};\r\ndeb_i2c("writing i2c bus (reg: %5d 0x%04x, val: %5d 0x%04x)\n",reg,reg,val,val);\r\nreturn i2c_transfer(state->i2c,msg, 1) != 1 ? -EREMOTEIO : 0;\r\n}\r\nstatic int dib3000_search_status(u16 irq,u16 lock)\r\n{\r\nif (irq & 0x02) {\r\nif (lock & 0x01) {\r\ndeb_srch("auto search succeeded\n");\r\nreturn 1;\r\n} else {\r\ndeb_srch("auto search not successful\n");\r\nreturn 0;\r\n}\r\n} else if (irq & 0x01) {\r\ndeb_srch("auto search failed\n");\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dib3000mb_set_frontend(struct dvb_frontend *fe, int tuner)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nenum fe_code_rate fe_cr = FEC_NONE;\r\nint search_state, seq;\r\nif (tuner && fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\nswitch (c->bandwidth_hz) {\r\ncase 8000000:\r\nwr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[2]);\r\nwr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_8mhz);\r\nbreak;\r\ncase 7000000:\r\nwr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[1]);\r\nwr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_7mhz);\r\nbreak;\r\ncase 6000000:\r\nwr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[0]);\r\nwr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_6mhz);\r\nbreak;\r\ncase 0:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\npr_err("unknown bandwidth value.\n");\r\nreturn -EINVAL;\r\n}\r\ndeb_setf("bandwidth: %d MHZ\n", c->bandwidth_hz / 1000000);\r\n}\r\nwr(DIB3000MB_REG_LOCK1_MASK, DIB3000MB_LOCK1_SEARCH_4);\r\nswitch (c->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ndeb_setf("transmission mode: 2k\n");\r\nwr(DIB3000MB_REG_FFT, DIB3000_TRANSMISSION_MODE_2K);\r\nbreak;\r\ncase TRANSMISSION_MODE_8K:\r\ndeb_setf("transmission mode: 8k\n");\r\nwr(DIB3000MB_REG_FFT, DIB3000_TRANSMISSION_MODE_8K);\r\nbreak;\r\ncase TRANSMISSION_MODE_AUTO:\r\ndeb_setf("transmission mode: auto\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (c->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\ndeb_setf("guard 1_32\n");\r\nwr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_32);\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ndeb_setf("guard 1_16\n");\r\nwr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_16);\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ndeb_setf("guard 1_8\n");\r\nwr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_8);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\ndeb_setf("guard 1_4\n");\r\nwr(DIB3000MB_REG_GUARD_TIME, DIB3000_GUARD_TIME_1_4);\r\nbreak;\r\ncase GUARD_INTERVAL_AUTO:\r\ndeb_setf("guard auto\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (c->inversion) {\r\ncase INVERSION_OFF:\r\ndeb_setf("inversion off\n");\r\nwr(DIB3000MB_REG_DDS_INV, DIB3000_DDS_INVERSION_OFF);\r\nbreak;\r\ncase INVERSION_AUTO:\r\ndeb_setf("inversion auto\n");\r\nbreak;\r\ncase INVERSION_ON:\r\ndeb_setf("inversion on\n");\r\nwr(DIB3000MB_REG_DDS_INV, DIB3000_DDS_INVERSION_ON);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (c->modulation) {\r\ncase QPSK:\r\ndeb_setf("modulation: qpsk\n");\r\nwr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_QPSK);\r\nbreak;\r\ncase QAM_16:\r\ndeb_setf("modulation: qam16\n");\r\nwr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_16QAM);\r\nbreak;\r\ncase QAM_64:\r\ndeb_setf("modulation: qam64\n");\r\nwr(DIB3000MB_REG_QAM, DIB3000_CONSTELLATION_64QAM);\r\nbreak;\r\ncase QAM_AUTO:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (c->hierarchy) {\r\ncase HIERARCHY_NONE:\r\ndeb_setf("hierarchy: none\n");\r\ncase HIERARCHY_1:\r\ndeb_setf("hierarchy: alpha=1\n");\r\nwr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_1);\r\nbreak;\r\ncase HIERARCHY_2:\r\ndeb_setf("hierarchy: alpha=2\n");\r\nwr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_2);\r\nbreak;\r\ncase HIERARCHY_4:\r\ndeb_setf("hierarchy: alpha=4\n");\r\nwr(DIB3000MB_REG_VIT_ALPHA, DIB3000_ALPHA_4);\r\nbreak;\r\ncase HIERARCHY_AUTO:\r\ndeb_setf("hierarchy: alpha=auto\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (c->hierarchy == HIERARCHY_NONE) {\r\nwr(DIB3000MB_REG_VIT_HRCH, DIB3000_HRCH_OFF);\r\nwr(DIB3000MB_REG_VIT_HP, DIB3000_SELECT_HP);\r\nfe_cr = c->code_rate_HP;\r\n} else if (c->hierarchy != HIERARCHY_AUTO) {\r\nwr(DIB3000MB_REG_VIT_HRCH, DIB3000_HRCH_ON);\r\nwr(DIB3000MB_REG_VIT_HP, DIB3000_SELECT_LP);\r\nfe_cr = c->code_rate_LP;\r\n}\r\nswitch (fe_cr) {\r\ncase FEC_1_2:\r\ndeb_setf("fec: 1_2\n");\r\nwr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_1_2);\r\nbreak;\r\ncase FEC_2_3:\r\ndeb_setf("fec: 2_3\n");\r\nwr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_2_3);\r\nbreak;\r\ncase FEC_3_4:\r\ndeb_setf("fec: 3_4\n");\r\nwr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_3_4);\r\nbreak;\r\ncase FEC_5_6:\r\ndeb_setf("fec: 5_6\n");\r\nwr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_5_6);\r\nbreak;\r\ncase FEC_7_8:\r\ndeb_setf("fec: 7_8\n");\r\nwr(DIB3000MB_REG_VIT_CODE_RATE, DIB3000_FEC_7_8);\r\nbreak;\r\ncase FEC_NONE:\r\ndeb_setf("fec: none\n");\r\nbreak;\r\ncase FEC_AUTO:\r\ndeb_setf("fec: auto\n");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nseq = dib3000_seq\r\n[c->transmission_mode == TRANSMISSION_MODE_AUTO]\r\n[c->guard_interval == GUARD_INTERVAL_AUTO]\r\n[c->inversion == INVERSION_AUTO];\r\ndeb_setf("seq? %d\n", seq);\r\nwr(DIB3000MB_REG_SEQ, seq);\r\nwr(DIB3000MB_REG_ISI, seq ? DIB3000MB_ISI_INHIBIT : DIB3000MB_ISI_ACTIVATE);\r\nif (c->transmission_mode == TRANSMISSION_MODE_2K) {\r\nif (c->guard_interval == GUARD_INTERVAL_1_8) {\r\nwr(DIB3000MB_REG_SYNC_IMPROVEMENT, DIB3000MB_SYNC_IMPROVE_2K_1_8);\r\n} else {\r\nwr(DIB3000MB_REG_SYNC_IMPROVEMENT, DIB3000MB_SYNC_IMPROVE_DEFAULT);\r\n}\r\nwr(DIB3000MB_REG_UNK_121, DIB3000MB_UNK_121_2K);\r\n} else {\r\nwr(DIB3000MB_REG_UNK_121, DIB3000MB_UNK_121_DEFAULT);\r\n}\r\nwr(DIB3000MB_REG_MOBILE_ALGO, DIB3000MB_MOBILE_ALGO_OFF);\r\nwr(DIB3000MB_REG_MOBILE_MODE_QAM, DIB3000MB_MOBILE_MODE_QAM_OFF);\r\nwr(DIB3000MB_REG_MOBILE_MODE, DIB3000MB_MOBILE_MODE_OFF);\r\nwr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_high);\r\nwr(DIB3000MB_REG_ISI, DIB3000MB_ISI_ACTIVATE);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AGC + DIB3000MB_RESTART_CTRL);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\r\nmsleep(70);\r\nwr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_low);\r\nif (c->modulation == QAM_AUTO ||\r\nc->hierarchy == HIERARCHY_AUTO ||\r\nfe_cr == FEC_AUTO ||\r\nc->inversion == INVERSION_AUTO) {\r\nint as_count=0;\r\ndeb_setf("autosearch enabled.\n");\r\nwr(DIB3000MB_REG_ISI, DIB3000MB_ISI_INHIBIT);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AUTO_SEARCH);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\r\nwhile ((search_state =\r\ndib3000_search_status(\r\nrd(DIB3000MB_REG_AS_IRQ_PENDING),\r\nrd(DIB3000MB_REG_LOCK2_VALUE))) < 0 && as_count++ < 100)\r\nmsleep(1);\r\ndeb_setf("search_state after autosearch %d after %d checks\n",\r\nsearch_state, as_count);\r\nif (search_state == 1) {\r\nif (dib3000mb_get_frontend(fe, c) == 0) {\r\ndeb_setf("reading tuning data from frontend succeeded.\n");\r\nreturn dib3000mb_set_frontend(fe, 0);\r\n}\r\n}\r\n} else {\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_CTRL);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_OFF);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_fe_init(struct dvb_frontend* fe, int mobile_mode)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\ndeb_info("dib3000mb is getting up.\n");\r\nwr(DIB3000MB_REG_POWER_CONTROL, DIB3000MB_POWER_UP);\r\nwr(DIB3000MB_REG_RESTART, DIB3000MB_RESTART_AGC);\r\nwr(DIB3000MB_REG_RESET_DEVICE, DIB3000MB_RESET_DEVICE);\r\nwr(DIB3000MB_REG_RESET_DEVICE, DIB3000MB_RESET_DEVICE_RST);\r\nwr(DIB3000MB_REG_CLOCK, DIB3000MB_CLOCK_DEFAULT);\r\nwr(DIB3000MB_REG_ELECT_OUT_MODE, DIB3000MB_ELECT_OUT_MODE_ON);\r\nwr(DIB3000MB_REG_DDS_FREQ_MSB, DIB3000MB_DDS_FREQ_MSB);\r\nwr(DIB3000MB_REG_DDS_FREQ_LSB, DIB3000MB_DDS_FREQ_LSB);\r\nwr_foreach(dib3000mb_reg_timing_freq, dib3000mb_timing_freq[2]);\r\nwr_foreach(dib3000mb_reg_impulse_noise,\r\ndib3000mb_impulse_noise_values[DIB3000MB_IMPNOISE_OFF]);\r\nwr_foreach(dib3000mb_reg_agc_gain, dib3000mb_default_agc_gain);\r\nwr(DIB3000MB_REG_PHASE_NOISE, DIB3000MB_PHASE_NOISE_DEFAULT);\r\nwr_foreach(dib3000mb_reg_phase_noise, dib3000mb_default_noise_phase);\r\nwr_foreach(dib3000mb_reg_lock_duration, dib3000mb_default_lock_duration);\r\nwr_foreach(dib3000mb_reg_agc_bandwidth, dib3000mb_agc_bandwidth_low);\r\nwr(DIB3000MB_REG_LOCK0_MASK, DIB3000MB_LOCK0_DEFAULT);\r\nwr(DIB3000MB_REG_LOCK1_MASK, DIB3000MB_LOCK1_SEARCH_4);\r\nwr(DIB3000MB_REG_LOCK2_MASK, DIB3000MB_LOCK2_DEFAULT);\r\nwr(DIB3000MB_REG_SEQ, dib3000_seq[1][1][1]);\r\nwr_foreach(dib3000mb_reg_bandwidth, dib3000mb_bandwidth_8mhz);\r\nwr(DIB3000MB_REG_UNK_68, DIB3000MB_UNK_68);\r\nwr(DIB3000MB_REG_UNK_69, DIB3000MB_UNK_69);\r\nwr(DIB3000MB_REG_UNK_71, DIB3000MB_UNK_71);\r\nwr(DIB3000MB_REG_UNK_77, DIB3000MB_UNK_77);\r\nwr(DIB3000MB_REG_UNK_78, DIB3000MB_UNK_78);\r\nwr(DIB3000MB_REG_ISI, DIB3000MB_ISI_INHIBIT);\r\nwr(DIB3000MB_REG_UNK_92, DIB3000MB_UNK_92);\r\nwr(DIB3000MB_REG_UNK_96, DIB3000MB_UNK_96);\r\nwr(DIB3000MB_REG_UNK_97, DIB3000MB_UNK_97);\r\nwr(DIB3000MB_REG_UNK_106, DIB3000MB_UNK_106);\r\nwr(DIB3000MB_REG_UNK_107, DIB3000MB_UNK_107);\r\nwr(DIB3000MB_REG_UNK_108, DIB3000MB_UNK_108);\r\nwr(DIB3000MB_REG_UNK_122, DIB3000MB_UNK_122);\r\nwr(DIB3000MB_REG_MOBILE_MODE_QAM, DIB3000MB_MOBILE_MODE_QAM_OFF);\r\nwr(DIB3000MB_REG_BERLEN, DIB3000MB_BERLEN_DEFAULT);\r\nwr_foreach(dib3000mb_reg_filter_coeffs, dib3000mb_filter_coeffs);\r\nwr(DIB3000MB_REG_MOBILE_ALGO, DIB3000MB_MOBILE_ALGO_ON);\r\nwr(DIB3000MB_REG_MULTI_DEMOD_MSB, DIB3000MB_MULTI_DEMOD_MSB);\r\nwr(DIB3000MB_REG_MULTI_DEMOD_LSB, DIB3000MB_MULTI_DEMOD_LSB);\r\nwr(DIB3000MB_REG_OUTPUT_MODE, DIB3000MB_OUTPUT_MODE_SLAVE);\r\nwr(DIB3000MB_REG_FIFO_142, DIB3000MB_FIFO_142);\r\nwr(DIB3000MB_REG_MPEG2_OUT_MODE, DIB3000MB_MPEG2_OUT_MODE_188);\r\nwr(DIB3000MB_REG_PID_PARSE, DIB3000MB_PID_PARSE_ACTIVATE);\r\nwr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_INHIBIT);\r\nwr(DIB3000MB_REG_FIFO_146, DIB3000MB_FIFO_146);\r\nwr(DIB3000MB_REG_FIFO_147, DIB3000MB_FIFO_147);\r\nwr(DIB3000MB_REG_DATA_IN_DIVERSITY, DIB3000MB_DATA_DIVERSITY_IN_OFF);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_get_frontend(struct dvb_frontend* fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\nenum fe_code_rate *cr;\r\nu16 tps_val;\r\nint inv_test1,inv_test2;\r\nu32 dds_val, threshold = 0x800000;\r\nif (!rd(DIB3000MB_REG_TPS_LOCK))\r\nreturn 0;\r\ndds_val = ((rd(DIB3000MB_REG_DDS_VALUE_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_VALUE_LSB);\r\ndeb_getf("DDS_VAL: %x %x %x\n", dds_val, rd(DIB3000MB_REG_DDS_VALUE_MSB), rd(DIB3000MB_REG_DDS_VALUE_LSB));\r\nif (dds_val < threshold)\r\ninv_test1 = 0;\r\nelse if (dds_val == threshold)\r\ninv_test1 = 1;\r\nelse\r\ninv_test1 = 2;\r\ndds_val = ((rd(DIB3000MB_REG_DDS_FREQ_MSB) & 0xff) << 16) + rd(DIB3000MB_REG_DDS_FREQ_LSB);\r\ndeb_getf("DDS_FREQ: %x %x %x\n", dds_val, rd(DIB3000MB_REG_DDS_FREQ_MSB), rd(DIB3000MB_REG_DDS_FREQ_LSB));\r\nif (dds_val < threshold)\r\ninv_test2 = 0;\r\nelse if (dds_val == threshold)\r\ninv_test2 = 1;\r\nelse\r\ninv_test2 = 2;\r\nc->inversion =\r\n((inv_test2 == 2) && (inv_test1==1 || inv_test1==0)) ||\r\n((inv_test2 == 0) && (inv_test1==1 || inv_test1==2)) ?\r\nINVERSION_ON : INVERSION_OFF;\r\ndeb_getf("inversion %d %d, %d\n", inv_test2, inv_test1, c->inversion);\r\nswitch ((tps_val = rd(DIB3000MB_REG_TPS_QAM))) {\r\ncase DIB3000_CONSTELLATION_QPSK:\r\ndeb_getf("QPSK\n");\r\nc->modulation = QPSK;\r\nbreak;\r\ncase DIB3000_CONSTELLATION_16QAM:\r\ndeb_getf("QAM16\n");\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase DIB3000_CONSTELLATION_64QAM:\r\ndeb_getf("QAM64\n");\r\nc->modulation = QAM_64;\r\nbreak;\r\ndefault:\r\npr_err("Unexpected constellation returned by TPS (%d)\n", tps_val);\r\nbreak;\r\n}\r\ndeb_getf("TPS: %d\n", tps_val);\r\nif (rd(DIB3000MB_REG_TPS_HRCH)) {\r\ndeb_getf("HRCH ON\n");\r\ncr = &c->code_rate_LP;\r\nc->code_rate_HP = FEC_NONE;\r\nswitch ((tps_val = rd(DIB3000MB_REG_TPS_VIT_ALPHA))) {\r\ncase DIB3000_ALPHA_0:\r\ndeb_getf("HIERARCHY_NONE\n");\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase DIB3000_ALPHA_1:\r\ndeb_getf("HIERARCHY_1\n");\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase DIB3000_ALPHA_2:\r\ndeb_getf("HIERARCHY_2\n");\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase DIB3000_ALPHA_4:\r\ndeb_getf("HIERARCHY_4\n");\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\ndefault:\r\npr_err("Unexpected ALPHA value returned by TPS (%d)\n", tps_val);\r\nbreak;\r\n}\r\ndeb_getf("TPS: %d\n", tps_val);\r\ntps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_LP);\r\n} else {\r\ndeb_getf("HRCH OFF\n");\r\ncr = &c->code_rate_HP;\r\nc->code_rate_LP = FEC_NONE;\r\nc->hierarchy = HIERARCHY_NONE;\r\ntps_val = rd(DIB3000MB_REG_TPS_CODE_RATE_HP);\r\n}\r\nswitch (tps_val) {\r\ncase DIB3000_FEC_1_2:\r\ndeb_getf("FEC_1_2\n");\r\n*cr = FEC_1_2;\r\nbreak;\r\ncase DIB3000_FEC_2_3:\r\ndeb_getf("FEC_2_3\n");\r\n*cr = FEC_2_3;\r\nbreak;\r\ncase DIB3000_FEC_3_4:\r\ndeb_getf("FEC_3_4\n");\r\n*cr = FEC_3_4;\r\nbreak;\r\ncase DIB3000_FEC_5_6:\r\ndeb_getf("FEC_5_6\n");\r\n*cr = FEC_4_5;\r\nbreak;\r\ncase DIB3000_FEC_7_8:\r\ndeb_getf("FEC_7_8\n");\r\n*cr = FEC_7_8;\r\nbreak;\r\ndefault:\r\npr_err("Unexpected FEC returned by TPS (%d)\n", tps_val);\r\nbreak;\r\n}\r\ndeb_getf("TPS: %d\n",tps_val);\r\nswitch ((tps_val = rd(DIB3000MB_REG_TPS_GUARD_TIME))) {\r\ncase DIB3000_GUARD_TIME_1_32:\r\ndeb_getf("GUARD_INTERVAL_1_32\n");\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase DIB3000_GUARD_TIME_1_16:\r\ndeb_getf("GUARD_INTERVAL_1_16\n");\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase DIB3000_GUARD_TIME_1_8:\r\ndeb_getf("GUARD_INTERVAL_1_8\n");\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase DIB3000_GUARD_TIME_1_4:\r\ndeb_getf("GUARD_INTERVAL_1_4\n");\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\ndefault:\r\npr_err("Unexpected Guard Time returned by TPS (%d)\n", tps_val);\r\nbreak;\r\n}\r\ndeb_getf("TPS: %d\n", tps_val);\r\nswitch ((tps_val = rd(DIB3000MB_REG_TPS_FFT))) {\r\ncase DIB3000_TRANSMISSION_MODE_2K:\r\ndeb_getf("TRANSMISSION_MODE_2K\n");\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase DIB3000_TRANSMISSION_MODE_8K:\r\ndeb_getf("TRANSMISSION_MODE_8K\n");\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\ndefault:\r\npr_err("unexpected transmission mode return by TPS (%d)\n", tps_val);\r\nbreak;\r\n}\r\ndeb_getf("TPS: %d\n", tps_val);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_read_status(struct dvb_frontend *fe,\r\nenum fe_status *stat)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\n*stat = 0;\r\nif (rd(DIB3000MB_REG_AGC_LOCK))\r\n*stat |= FE_HAS_SIGNAL;\r\nif (rd(DIB3000MB_REG_CARRIER_LOCK))\r\n*stat |= FE_HAS_CARRIER;\r\nif (rd(DIB3000MB_REG_VIT_LCK))\r\n*stat |= FE_HAS_VITERBI;\r\nif (rd(DIB3000MB_REG_TS_SYNC_LOCK))\r\n*stat |= (FE_HAS_SYNC | FE_HAS_LOCK);\r\ndeb_getf("actual status is %2x\n",*stat);\r\ndeb_getf("autoval: tps: %d, qam: %d, hrch: %d, alpha: %d, hp: %d, lp: %d, guard: %d, fft: %d cell: %d\n",\r\nrd(DIB3000MB_REG_TPS_LOCK),\r\nrd(DIB3000MB_REG_TPS_QAM),\r\nrd(DIB3000MB_REG_TPS_HRCH),\r\nrd(DIB3000MB_REG_TPS_VIT_ALPHA),\r\nrd(DIB3000MB_REG_TPS_CODE_RATE_HP),\r\nrd(DIB3000MB_REG_TPS_CODE_RATE_LP),\r\nrd(DIB3000MB_REG_TPS_GUARD_TIME),\r\nrd(DIB3000MB_REG_TPS_FFT),\r\nrd(DIB3000MB_REG_TPS_CELL_ID));\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_read_ber(struct dvb_frontend* fe, u32 *ber)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\n*ber = ((rd(DIB3000MB_REG_BER_MSB) << 16) | rd(DIB3000MB_REG_BER_LSB));\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_read_signal_strength(struct dvb_frontend* fe, u16 *strength)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\n*strength = rd(DIB3000MB_REG_SIGNAL_POWER) * 0xffff / 0x170;\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_read_snr(struct dvb_frontend* fe, u16 *snr)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\nshort sigpow = rd(DIB3000MB_REG_SIGNAL_POWER);\r\nint icipow = ((rd(DIB3000MB_REG_NOISE_POWER_MSB) & 0xff) << 16) |\r\nrd(DIB3000MB_REG_NOISE_POWER_LSB);\r\n*snr = (sigpow << 8) / ((icipow > 0) ? icipow : 1);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_read_unc_blocks(struct dvb_frontend* fe, u32 *unc)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\n*unc = rd(DIB3000MB_REG_PACKET_ERROR_RATE);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct dib3000_state* state = fe->demodulator_priv;\r\ndeb_info("dib3000mb is going to bed.\n");\r\nwr(DIB3000MB_REG_POWER_CONTROL, DIB3000MB_POWER_DOWN);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 800;\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_fe_init_nonmobile(struct dvb_frontend* fe)\r\n{\r\nreturn dib3000mb_fe_init(fe, 0);\r\n}\r\nstatic int dib3000mb_set_frontend_and_tuner(struct dvb_frontend *fe)\r\n{\r\nreturn dib3000mb_set_frontend(fe, 1);\r\n}\r\nstatic void dib3000mb_release(struct dvb_frontend* fe)\r\n{\r\nstruct dib3000_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int dib3000mb_pid_control(struct dvb_frontend *fe,int index, int pid,int onoff)\r\n{\r\nstruct dib3000_state *state = fe->demodulator_priv;\r\npid = (onoff ? pid | DIB3000_ACTIVATE_PID_FILTERING : 0);\r\nwr(index+DIB3000MB_REG_FIRST_PID,pid);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_fifo_control(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib3000_state *state = fe->demodulator_priv;\r\ndeb_xfer("%s fifo\n",onoff ? "enabling" : "disabling");\r\nif (onoff) {\r\nwr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_ACTIVATE);\r\n} else {\r\nwr(DIB3000MB_REG_FIFO, DIB3000MB_FIFO_INHIBIT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_pid_parse(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib3000_state *state = fe->demodulator_priv;\r\ndeb_xfer("%s pid parsing\n",onoff ? "enabling" : "disabling");\r\nwr(DIB3000MB_REG_PID_PARSE,onoff);\r\nreturn 0;\r\n}\r\nstatic int dib3000mb_tuner_pass_ctrl(struct dvb_frontend *fe, int onoff, u8 pll_addr)\r\n{\r\nstruct dib3000_state *state = fe->demodulator_priv;\r\nif (onoff) {\r\nwr(DIB3000MB_REG_TUNER, DIB3000_TUNER_WRITE_ENABLE(pll_addr));\r\n} else {\r\nwr(DIB3000MB_REG_TUNER, DIB3000_TUNER_WRITE_DISABLE(pll_addr));\r\n}\r\nreturn 0;\r\n}\r\nstruct dvb_frontend* dib3000mb_attach(const struct dib3000_config* config,\r\nstruct i2c_adapter* i2c, struct dib_fe_xfer_ops *xfer_ops)\r\n{\r\nstruct dib3000_state* state = NULL;\r\nstate = kzalloc(sizeof(struct dib3000_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->i2c = i2c;\r\nmemcpy(&state->config,config,sizeof(struct dib3000_config));\r\nif (rd(DIB3000_REG_MANUFACTOR_ID) != DIB3000_I2C_ID_DIBCOM)\r\ngoto error;\r\nif (rd(DIB3000_REG_DEVICE_ID) != DIB3000MB_DEVICE_ID)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &dib3000mb_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nxfer_ops->pid_parse = dib3000mb_pid_parse;\r\nxfer_ops->fifo_ctrl = dib3000mb_fifo_control;\r\nxfer_ops->pid_ctrl = dib3000mb_pid_control;\r\nxfer_ops->tuner_pass_ctrl = dib3000mb_tuner_pass_ctrl;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
