static void rt5514_enable_dsp_prepare(struct rt5514_priv *rt5514)\r\n{\r\nregmap_write(rt5514->i2c_regmap, 0x18002000, 0x000010ec);\r\nregmap_write(rt5514->i2c_regmap, 0x18002200, 0x00028604);\r\nregmap_write(rt5514->i2c_regmap, 0xfafafafa, 0x00000001);\r\nregmap_write(rt5514->i2c_regmap, 0x18002f00, 0x0005514b);\r\nregmap_write(rt5514->i2c_regmap, 0x18002f00, 0x00055149);\r\nregmap_write(rt5514->i2c_regmap, 0xfafafafa, 0x00000000);\r\nregmap_write(rt5514->i2c_regmap, 0x18002070, 0x00000040);\r\nregmap_write(rt5514->i2c_regmap, 0x18002240, 0x0000000a);\r\nregmap_write(rt5514->i2c_regmap, 0x18002100, 0x0000000b);\r\nregmap_write(rt5514->i2c_regmap, 0x18002004, 0x00808b81);\r\nregmap_write(rt5514->i2c_regmap, 0x18002f08, 0x00000005);\r\nregmap_write(rt5514->i2c_regmap, 0x18001114, 0x00000001);\r\nregmap_write(rt5514->i2c_regmap, 0x18001118, 0x00000001);\r\n}\r\nstatic bool rt5514_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5514_VENDOR_ID1:\r\ncase RT5514_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt5514_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5514_RESET:\r\ncase RT5514_PWR_ANA1:\r\ncase RT5514_PWR_ANA2:\r\ncase RT5514_I2S_CTRL1:\r\ncase RT5514_I2S_CTRL2:\r\ncase RT5514_VAD_CTRL6:\r\ncase RT5514_EXT_VAD_CTRL:\r\ncase RT5514_DIG_IO_CTRL:\r\ncase RT5514_PAD_CTRL1:\r\ncase RT5514_DMIC_DATA_CTRL:\r\ncase RT5514_DIG_SOURCE_CTRL:\r\ncase RT5514_SRC_CTRL:\r\ncase RT5514_DOWNFILTER2_CTRL1:\r\ncase RT5514_PLL_SOURCE_CTRL:\r\ncase RT5514_CLK_CTRL1:\r\ncase RT5514_CLK_CTRL2:\r\ncase RT5514_PLL3_CALIB_CTRL1:\r\ncase RT5514_PLL3_CALIB_CTRL5:\r\ncase RT5514_DELAY_BUF_CTRL1:\r\ncase RT5514_DELAY_BUF_CTRL3:\r\ncase RT5514_DOWNFILTER0_CTRL1:\r\ncase RT5514_DOWNFILTER0_CTRL2:\r\ncase RT5514_DOWNFILTER0_CTRL3:\r\ncase RT5514_DOWNFILTER1_CTRL1:\r\ncase RT5514_DOWNFILTER1_CTRL2:\r\ncase RT5514_DOWNFILTER1_CTRL3:\r\ncase RT5514_ANA_CTRL_LDO10:\r\ncase RT5514_ANA_CTRL_LDO18_16:\r\ncase RT5514_ANA_CTRL_ADC12:\r\ncase RT5514_ANA_CTRL_ADC21:\r\ncase RT5514_ANA_CTRL_ADC22:\r\ncase RT5514_ANA_CTRL_ADC23:\r\ncase RT5514_ANA_CTRL_MICBST:\r\ncase RT5514_ANA_CTRL_ADCFED:\r\ncase RT5514_ANA_CTRL_INBUF:\r\ncase RT5514_ANA_CTRL_VREF:\r\ncase RT5514_ANA_CTRL_PLL3:\r\ncase RT5514_ANA_CTRL_PLL1_1:\r\ncase RT5514_ANA_CTRL_PLL1_2:\r\ncase RT5514_DMIC_LP_CTRL:\r\ncase RT5514_MISC_CTRL_DSP:\r\ncase RT5514_DSP_CTRL1:\r\ncase RT5514_DSP_CTRL3:\r\ncase RT5514_DSP_CTRL4:\r\ncase RT5514_VENDOR_ID1:\r\ncase RT5514_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt5514_i2c_readable_register(struct device *dev,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase RT5514_DSP_MAPPING | RT5514_RESET:\r\ncase RT5514_DSP_MAPPING | RT5514_PWR_ANA1:\r\ncase RT5514_DSP_MAPPING | RT5514_PWR_ANA2:\r\ncase RT5514_DSP_MAPPING | RT5514_I2S_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_I2S_CTRL2:\r\ncase RT5514_DSP_MAPPING | RT5514_VAD_CTRL6:\r\ncase RT5514_DSP_MAPPING | RT5514_EXT_VAD_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_DIG_IO_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_PAD_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_DMIC_DATA_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_DIG_SOURCE_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_SRC_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER2_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_PLL_SOURCE_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_CLK_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_CLK_CTRL2:\r\ncase RT5514_DSP_MAPPING | RT5514_PLL3_CALIB_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_PLL3_CALIB_CTRL5:\r\ncase RT5514_DSP_MAPPING | RT5514_DELAY_BUF_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_DELAY_BUF_CTRL3:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER0_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER0_CTRL2:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER0_CTRL3:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER1_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER1_CTRL2:\r\ncase RT5514_DSP_MAPPING | RT5514_DOWNFILTER1_CTRL3:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_LDO10:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_LDO18_16:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_ADC12:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_ADC21:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_ADC22:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_ADC23:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_MICBST:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_ADCFED:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_INBUF:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_VREF:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_PLL3:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_PLL1_1:\r\ncase RT5514_DSP_MAPPING | RT5514_ANA_CTRL_PLL1_2:\r\ncase RT5514_DSP_MAPPING | RT5514_DMIC_LP_CTRL:\r\ncase RT5514_DSP_MAPPING | RT5514_MISC_CTRL_DSP:\r\ncase RT5514_DSP_MAPPING | RT5514_DSP_CTRL1:\r\ncase RT5514_DSP_MAPPING | RT5514_DSP_CTRL3:\r\ncase RT5514_DSP_MAPPING | RT5514_DSP_CTRL4:\r\ncase RT5514_DSP_MAPPING | RT5514_VENDOR_ID1:\r\ncase RT5514_DSP_MAPPING | RT5514_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int rt5514_dsp_voice_wake_up_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct rt5514_priv *rt5514 = snd_soc_component_get_drvdata(component);\r\nucontrol->value.integer.value[0] = rt5514->dsp_enabled;\r\nreturn 0;\r\n}\r\nstatic int rt5514_dsp_voice_wake_up_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct rt5514_priv *rt5514 = snd_soc_component_get_drvdata(component);\r\nstruct snd_soc_codec *codec = rt5514->codec;\r\nconst struct firmware *fw = NULL;\r\nif (ucontrol->value.integer.value[0] == rt5514->dsp_enabled)\r\nreturn 0;\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nrt5514->dsp_enabled = ucontrol->value.integer.value[0];\r\nif (rt5514->dsp_enabled) {\r\nrt5514_enable_dsp_prepare(rt5514);\r\nrequest_firmware(&fw, RT5514_FIRMWARE1, codec->dev);\r\nif (fw) {\r\n#if defined(CONFIG_SND_SOC_RT5514_SPI)\r\nrt5514_spi_burst_write(0x4ff60000, fw->data,\r\n((fw->size/8)+1)*8);\r\n#else\r\ndev_err(codec->dev, "There is no SPI driver for"\r\n" loading the firmware\n");\r\n#endif\r\nrelease_firmware(fw);\r\nfw = NULL;\r\n}\r\nrequest_firmware(&fw, RT5514_FIRMWARE2, codec->dev);\r\nif (fw) {\r\n#if defined(CONFIG_SND_SOC_RT5514_SPI)\r\nrt5514_spi_burst_write(0x4ffc0000, fw->data,\r\n((fw->size/8)+1)*8);\r\n#else\r\ndev_err(codec->dev, "There is no SPI driver for"\r\n" loading the firmware\n");\r\n#endif\r\nrelease_firmware(fw);\r\nfw = NULL;\r\n}\r\nregmap_write(rt5514->i2c_regmap, 0x18002f00,\r\n0x00055148);\r\n} else {\r\nregmap_multi_reg_write(rt5514->i2c_regmap,\r\nrt5514_i2c_patch, ARRAY_SIZE(rt5514_i2c_patch));\r\nregcache_mark_dirty(rt5514->regmap);\r\nregcache_sync(rt5514->regmap);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5514_calc_dmic_clk(struct snd_soc_codec *codec, int rate)\r\n{\r\nint div[] = {2, 3, 4, 8, 12, 16, 24, 32};\r\nint i;\r\nif (rate < 1000000 * div[0]) {\r\npr_warn("Base clock rate %d is too low\n", rate);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(div); i++) {\r\nif (3072000 * div[i] >= rate)\r\nreturn i;\r\n}\r\ndev_warn(codec->dev, "Base clock rate %d is too high\n", rate);\r\nreturn -EINVAL;\r\n}\r\nstatic int rt5514_set_dmic_clk(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nint idx;\r\nidx = rt5514_calc_dmic_clk(codec, rt5514->sysclk);\r\nif (idx < 0)\r\ndev_err(codec->dev, "Failed to set DMIC clock\n");\r\nelse\r\nregmap_update_bits(rt5514->regmap, RT5514_CLK_CTRL1,\r\nRT5514_CLK_DMIC_OUT_SEL_MASK,\r\nidx << RT5514_CLK_DMIC_OUT_SEL_SFT);\r\nif (rt5514->pdata.dmic_init_delay)\r\nmsleep(rt5514->pdata.dmic_init_delay);\r\nreturn idx;\r\n}\r\nstatic int rt5514_is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nif (rt5514->sysclk_src == RT5514_SCLK_S_PLL1)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int rt5514_pre_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (rt5514->dsp_enabled) {\r\nrt5514->dsp_enabled = 0;\r\nregmap_multi_reg_write(rt5514->i2c_regmap,\r\nrt5514_i2c_patch, ARRAY_SIZE(rt5514_i2c_patch));\r\nregcache_mark_dirty(rt5514->regmap);\r\nregcache_sync(rt5514->regmap);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5514_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nint pre_div, bclk_ms, frame_size;\r\nunsigned int val_len = 0;\r\nrt5514->lrck = params_rate(params);\r\npre_div = rl6231_get_clk_info(rt5514->sysclk, rt5514->lrck);\r\nif (pre_div < 0) {\r\ndev_err(codec->dev, "Unsupported clock setting\n");\r\nreturn -EINVAL;\r\n}\r\nframe_size = snd_soc_params_to_frame_size(params);\r\nif (frame_size < 0) {\r\ndev_err(codec->dev, "Unsupported frame size: %d\n", frame_size);\r\nreturn -EINVAL;\r\n}\r\nbclk_ms = frame_size > 32;\r\nrt5514->bclk = rt5514->lrck * (32 << bclk_ms);\r\ndev_dbg(dai->dev, "bclk is %dHz and lrck is %dHz\n",\r\nrt5514->bclk, rt5514->lrck);\r\ndev_dbg(dai->dev, "bclk_ms is %d and pre_div is %d for iis %d\n",\r\nbclk_ms, pre_div, dai->id);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval_len = RT5514_I2S_DL_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval_len = RT5514_I2S_DL_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S8:\r\nval_len = RT5514_I2S_DL_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(rt5514->regmap, RT5514_I2S_CTRL1, RT5514_I2S_DL_MASK,\r\nval_len);\r\nregmap_update_bits(rt5514->regmap, RT5514_CLK_CTRL2,\r\nRT5514_CLK_SYS_DIV_OUT_MASK | RT5514_SEL_ADC_OSR_MASK,\r\npre_div << RT5514_CLK_SYS_DIV_OUT_SFT |\r\npre_div << RT5514_SEL_ADC_OSR_SFT);\r\nreturn 0;\r\n}\r\nstatic int rt5514_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nreg_val |= RT5514_I2S_LR_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nreg_val |= RT5514_I2S_BP_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nreg_val |= RT5514_I2S_BP_INV | RT5514_I2S_LR_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nreg_val |= RT5514_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nreg_val |= RT5514_I2S_DF_PCM_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nreg_val |= RT5514_I2S_DF_PCM_B;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(rt5514->regmap, RT5514_I2S_CTRL1,\r\nRT5514_I2S_DF_MASK | RT5514_I2S_BP_MASK | RT5514_I2S_LR_MASK,\r\nreg_val);\r\nreturn 0;\r\n}\r\nstatic int rt5514_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg_val = 0;\r\nif (freq == rt5514->sysclk && clk_id == rt5514->sysclk_src)\r\nreturn 0;\r\nswitch (clk_id) {\r\ncase RT5514_SCLK_S_MCLK:\r\nreg_val |= RT5514_CLK_SYS_PRE_SEL_MCLK;\r\nbreak;\r\ncase RT5514_SCLK_S_PLL1:\r\nreg_val |= RT5514_CLK_SYS_PRE_SEL_PLL;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(rt5514->regmap, RT5514_CLK_CTRL2,\r\nRT5514_CLK_SYS_PRE_SEL_MASK, reg_val);\r\nrt5514->sysclk = freq;\r\nrt5514->sysclk_src = clk_id;\r\ndev_dbg(dai->dev, "Sysclk is %dHz and clock id is %d\n", freq, clk_id);\r\nreturn 0;\r\n}\r\nstatic int rt5514_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nstruct rl6231_pll_code pll_code;\r\nint ret;\r\nif (!freq_in || !freq_out) {\r\ndev_dbg(codec->dev, "PLL disabled\n");\r\nrt5514->pll_in = 0;\r\nrt5514->pll_out = 0;\r\nregmap_update_bits(rt5514->regmap, RT5514_CLK_CTRL2,\r\nRT5514_CLK_SYS_PRE_SEL_MASK,\r\nRT5514_CLK_SYS_PRE_SEL_MCLK);\r\nreturn 0;\r\n}\r\nif (source == rt5514->pll_src && freq_in == rt5514->pll_in &&\r\nfreq_out == rt5514->pll_out)\r\nreturn 0;\r\nswitch (source) {\r\ncase RT5514_PLL1_S_MCLK:\r\nregmap_update_bits(rt5514->regmap, RT5514_PLL_SOURCE_CTRL,\r\nRT5514_PLL_1_SEL_MASK, RT5514_PLL_1_SEL_MCLK);\r\nbreak;\r\ncase RT5514_PLL1_S_BCLK:\r\nregmap_update_bits(rt5514->regmap, RT5514_PLL_SOURCE_CTRL,\r\nRT5514_PLL_1_SEL_MASK, RT5514_PLL_1_SEL_SCLK);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown PLL source %d\n", source);\r\nreturn -EINVAL;\r\n}\r\nret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Unsupport input clock %d\n", freq_in);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "bypass=%d m=%d n=%d k=%d\n",\r\npll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\r\npll_code.n_code, pll_code.k_code);\r\nregmap_write(rt5514->regmap, RT5514_ANA_CTRL_PLL1_1,\r\npll_code.k_code << RT5514_PLL_K_SFT |\r\npll_code.n_code << RT5514_PLL_N_SFT |\r\n(pll_code.m_bp ? 0 : pll_code.m_code) << RT5514_PLL_M_SFT);\r\nregmap_update_bits(rt5514->regmap, RT5514_ANA_CTRL_PLL1_2,\r\nRT5514_PLL_M_BP, pll_code.m_bp << RT5514_PLL_M_BP_SFT);\r\nrt5514->pll_in = freq_in;\r\nrt5514->pll_out = freq_out;\r\nrt5514->pll_src = source;\r\nreturn 0;\r\n}\r\nstatic int rt5514_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = 0;\r\nif (rx_mask || tx_mask)\r\nval |= RT5514_TDM_MODE;\r\nif (slots == 4)\r\nval |= RT5514_TDMSLOT_SEL_RX_4CH | RT5514_TDMSLOT_SEL_TX_4CH;\r\nswitch (slot_width) {\r\ncase 20:\r\nval |= RT5514_CH_LEN_RX_20 | RT5514_CH_LEN_TX_20;\r\nbreak;\r\ncase 24:\r\nval |= RT5514_CH_LEN_RX_24 | RT5514_CH_LEN_TX_24;\r\nbreak;\r\ncase 32:\r\nval |= RT5514_CH_LEN_RX_32 | RT5514_CH_LEN_TX_32;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nbreak;\r\n}\r\nregmap_update_bits(rt5514->regmap, RT5514_I2S_CTRL1, RT5514_TDM_MODE |\r\nRT5514_TDMSLOT_SEL_RX_MASK | RT5514_TDMSLOT_SEL_TX_MASK |\r\nRT5514_CH_LEN_RX_MASK | RT5514_CH_LEN_TX_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int rt5514_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (IS_ERR(rt5514->mclk))\r\nbreak;\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON) {\r\nclk_disable_unprepare(rt5514->mclk);\r\n} else {\r\nret = clk_prepare_enable(rt5514->mclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt5514_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct rt5514_priv *rt5514 = snd_soc_codec_get_drvdata(codec);\r\nrt5514->mclk = devm_clk_get(codec->dev, "mclk");\r\nif (PTR_ERR(rt5514->mclk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nrt5514->codec = codec;\r\nreturn 0;\r\n}\r\nstatic int rt5514_i2c_read(void *context, unsigned int reg, unsigned int *val)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct rt5514_priv *rt5514 = i2c_get_clientdata(client);\r\nregmap_read(rt5514->i2c_regmap, reg | RT5514_DSP_MAPPING, val);\r\nreturn 0;\r\n}\r\nstatic int rt5514_i2c_write(void *context, unsigned int reg, unsigned int val)\r\n{\r\nstruct i2c_client *client = context;\r\nstruct rt5514_priv *rt5514 = i2c_get_clientdata(client);\r\nregmap_write(rt5514->i2c_regmap, reg | RT5514_DSP_MAPPING, val);\r\nreturn 0;\r\n}\r\nstatic int rt5514_parse_dt(struct rt5514_priv *rt5514, struct device *dev)\r\n{\r\ndevice_property_read_u32(dev, "realtek,dmic-init-delay-ms",\r\n&rt5514->pdata.dmic_init_delay);\r\nreturn 0;\r\n}\r\nstatic int rt5514_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt5514_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct rt5514_priv *rt5514;\r\nint ret;\r\nunsigned int val;\r\nrt5514 = devm_kzalloc(&i2c->dev, sizeof(struct rt5514_priv),\r\nGFP_KERNEL);\r\nif (rt5514 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, rt5514);\r\nif (pdata)\r\nrt5514->pdata = *pdata;\r\nelse if (i2c->dev.of_node)\r\nrt5514_parse_dt(rt5514, &i2c->dev);\r\nrt5514->i2c_regmap = devm_regmap_init_i2c(i2c, &rt5514_i2c_regmap);\r\nif (IS_ERR(rt5514->i2c_regmap)) {\r\nret = PTR_ERR(rt5514->i2c_regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nrt5514->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt5514_regmap);\r\nif (IS_ERR(rt5514->regmap)) {\r\nret = PTR_ERR(rt5514->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregmap_read(rt5514->regmap, RT5514_VENDOR_ID2, &val);\r\nif (val != RT5514_DEVICE_ID) {\r\ndev_err(&i2c->dev,\r\n"Device with ID register %x is not rt5514\n", val);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_multi_reg_write(rt5514->i2c_regmap, rt5514_i2c_patch,\r\nARRAY_SIZE(rt5514_i2c_patch));\r\nif (ret != 0)\r\ndev_warn(&i2c->dev, "Failed to apply i2c_regmap patch: %d\n",\r\nret);\r\nret = regmap_register_patch(rt5514->regmap, rt5514_patch,\r\nARRAY_SIZE(rt5514_patch));\r\nif (ret != 0)\r\ndev_warn(&i2c->dev, "Failed to apply regmap patch: %d\n", ret);\r\nreturn snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5514,\r\nrt5514_dai, ARRAY_SIZE(rt5514_dai));\r\n}\r\nstatic int rt5514_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
