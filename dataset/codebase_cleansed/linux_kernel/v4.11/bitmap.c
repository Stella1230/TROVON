static __u32 count_free(struct buffer_head *map[], unsigned blocksize, __u32 numbits)\r\n{\r\n__u32 sum = 0;\r\nunsigned blocks = DIV_ROUND_UP(numbits, blocksize * 8);\r\nwhile (blocks--) {\r\nunsigned words = blocksize / 2;\r\n__u16 *p = (__u16 *)(*map++)->b_data;\r\nwhile (words--)\r\nsum += 16 - hweight16(*p++);\r\n}\r\nreturn sum;\r\n}\r\nvoid minix_free_block(struct inode *inode, unsigned long block)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nstruct buffer_head *bh;\r\nint k = sb->s_blocksize_bits + 3;\r\nunsigned long bit, zone;\r\nif (block < sbi->s_firstdatazone || block >= sbi->s_nzones) {\r\nprintk("Trying to free block not in datazone\n");\r\nreturn;\r\n}\r\nzone = block - sbi->s_firstdatazone + 1;\r\nbit = zone & ((1<<k) - 1);\r\nzone >>= k;\r\nif (zone >= sbi->s_zmap_blocks) {\r\nprintk("minix_free_block: nonexistent bitmap buffer\n");\r\nreturn;\r\n}\r\nbh = sbi->s_zmap[zone];\r\nspin_lock(&bitmap_lock);\r\nif (!minix_test_and_clear_bit(bit, bh->b_data))\r\nprintk("minix_free_block (%s:%lu): bit already cleared\n",\r\nsb->s_id, block);\r\nspin_unlock(&bitmap_lock);\r\nmark_buffer_dirty(bh);\r\nreturn;\r\n}\r\nint minix_new_block(struct inode * inode)\r\n{\r\nstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\r\nint bits_per_zone = 8 * inode->i_sb->s_blocksize;\r\nint i;\r\nfor (i = 0; i < sbi->s_zmap_blocks; i++) {\r\nstruct buffer_head *bh = sbi->s_zmap[i];\r\nint j;\r\nspin_lock(&bitmap_lock);\r\nj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\r\nif (j < bits_per_zone) {\r\nminix_set_bit(j, bh->b_data);\r\nspin_unlock(&bitmap_lock);\r\nmark_buffer_dirty(bh);\r\nj += i * bits_per_zone + sbi->s_firstdatazone-1;\r\nif (j < sbi->s_firstdatazone || j >= sbi->s_nzones)\r\nbreak;\r\nreturn j;\r\n}\r\nspin_unlock(&bitmap_lock);\r\n}\r\nreturn 0;\r\n}\r\nunsigned long minix_count_free_blocks(struct super_block *sb)\r\n{\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nu32 bits = sbi->s_nzones - sbi->s_firstdatazone + 1;\r\nreturn (count_free(sbi->s_zmap, sb->s_blocksize, bits)\r\n<< sbi->s_log_zone_size);\r\n}\r\nstruct minix_inode *\r\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\r\n{\r\nint block;\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nstruct minix_inode *p;\r\nif (!ino || ino > sbi->s_ninodes) {\r\nprintk("Bad inode number on dev %s: %ld is out of range\n",\r\nsb->s_id, (long)ino);\r\nreturn NULL;\r\n}\r\nino--;\r\nblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\r\nino / MINIX_INODES_PER_BLOCK;\r\n*bh = sb_bread(sb, block);\r\nif (!*bh) {\r\nprintk("Unable to read inode block\n");\r\nreturn NULL;\r\n}\r\np = (void *)(*bh)->b_data;\r\nreturn p + ino % MINIX_INODES_PER_BLOCK;\r\n}\r\nstruct minix2_inode *\r\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\r\n{\r\nint block;\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nstruct minix2_inode *p;\r\nint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\r\n*bh = NULL;\r\nif (!ino || ino > sbi->s_ninodes) {\r\nprintk("Bad inode number on dev %s: %ld is out of range\n",\r\nsb->s_id, (long)ino);\r\nreturn NULL;\r\n}\r\nino--;\r\nblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\r\nino / minix2_inodes_per_block;\r\n*bh = sb_bread(sb, block);\r\nif (!*bh) {\r\nprintk("Unable to read inode block\n");\r\nreturn NULL;\r\n}\r\np = (void *)(*bh)->b_data;\r\nreturn p + ino % minix2_inodes_per_block;\r\n}\r\nstatic void minix_clear_inode(struct inode *inode)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nif (INODE_VERSION(inode) == MINIX_V1) {\r\nstruct minix_inode *raw_inode;\r\nraw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\r\nif (raw_inode) {\r\nraw_inode->i_nlinks = 0;\r\nraw_inode->i_mode = 0;\r\n}\r\n} else {\r\nstruct minix2_inode *raw_inode;\r\nraw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\r\nif (raw_inode) {\r\nraw_inode->i_nlinks = 0;\r\nraw_inode->i_mode = 0;\r\n}\r\n}\r\nif (bh) {\r\nmark_buffer_dirty(bh);\r\nbrelse (bh);\r\n}\r\n}\r\nvoid minix_free_inode(struct inode * inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\r\nstruct buffer_head *bh;\r\nint k = sb->s_blocksize_bits + 3;\r\nunsigned long ino, bit;\r\nino = inode->i_ino;\r\nif (ino < 1 || ino > sbi->s_ninodes) {\r\nprintk("minix_free_inode: inode 0 or nonexistent inode\n");\r\nreturn;\r\n}\r\nbit = ino & ((1<<k) - 1);\r\nino >>= k;\r\nif (ino >= sbi->s_imap_blocks) {\r\nprintk("minix_free_inode: nonexistent imap in superblock\n");\r\nreturn;\r\n}\r\nminix_clear_inode(inode);\r\nbh = sbi->s_imap[ino];\r\nspin_lock(&bitmap_lock);\r\nif (!minix_test_and_clear_bit(bit, bh->b_data))\r\nprintk("minix_free_inode: bit %lu already cleared\n", bit);\r\nspin_unlock(&bitmap_lock);\r\nmark_buffer_dirty(bh);\r\n}\r\nstruct inode *minix_new_inode(const struct inode *dir, umode_t mode, int *error)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nstruct inode *inode = new_inode(sb);\r\nstruct buffer_head * bh;\r\nint bits_per_zone = 8 * sb->s_blocksize;\r\nunsigned long j;\r\nint i;\r\nif (!inode) {\r\n*error = -ENOMEM;\r\nreturn NULL;\r\n}\r\nj = bits_per_zone;\r\nbh = NULL;\r\n*error = -ENOSPC;\r\nspin_lock(&bitmap_lock);\r\nfor (i = 0; i < sbi->s_imap_blocks; i++) {\r\nbh = sbi->s_imap[i];\r\nj = minix_find_first_zero_bit(bh->b_data, bits_per_zone);\r\nif (j < bits_per_zone)\r\nbreak;\r\n}\r\nif (!bh || j >= bits_per_zone) {\r\nspin_unlock(&bitmap_lock);\r\niput(inode);\r\nreturn NULL;\r\n}\r\nif (minix_test_and_set_bit(j, bh->b_data)) {\r\nspin_unlock(&bitmap_lock);\r\nprintk("minix_new_inode: bit already set\n");\r\niput(inode);\r\nreturn NULL;\r\n}\r\nspin_unlock(&bitmap_lock);\r\nmark_buffer_dirty(bh);\r\nj += i * bits_per_zone;\r\nif (!j || j > sbi->s_ninodes) {\r\niput(inode);\r\nreturn NULL;\r\n}\r\ninode_init_owner(inode, dir, mode);\r\ninode->i_ino = j;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\r\ninode->i_blocks = 0;\r\nmemset(&minix_i(inode)->u, 0, sizeof(minix_i(inode)->u));\r\ninsert_inode_hash(inode);\r\nmark_inode_dirty(inode);\r\n*error = 0;\r\nreturn inode;\r\n}\r\nunsigned long minix_count_free_inodes(struct super_block *sb)\r\n{\r\nstruct minix_sb_info *sbi = minix_sb(sb);\r\nu32 bits = sbi->s_ninodes + 1;\r\nreturn count_free(sbi->s_imap, sb->s_blocksize, bits);\r\n}
