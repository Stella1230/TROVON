int osc_lock_is_lockless(const struct osc_lock *olck)\r\n{\r\nreturn (olck->ols_cl.cls_ops == &osc_lock_lockless_ops);\r\n}\r\nstatic struct ldlm_lock *osc_handle_ptr(struct lustre_handle *handle)\r\n{\r\nstruct ldlm_lock *lock;\r\nlock = ldlm_handle2lock(handle);\r\nif (lock)\r\nLDLM_LOCK_PUT(lock);\r\nreturn lock;\r\n}\r\nstatic int osc_lock_invariant(struct osc_lock *ols)\r\n{\r\nstruct ldlm_lock *lock = osc_handle_ptr(&ols->ols_handle);\r\nstruct ldlm_lock *olock = ols->ols_dlmlock;\r\nint handle_used = lustre_handle_is_used(&ols->ols_handle);\r\nif (ergo(osc_lock_is_lockless(ols),\r\nols->ols_locklessable && !ols->ols_dlmlock))\r\nreturn 1;\r\nif (!ergo(olock, handle_used))\r\nreturn 0;\r\nif (!ergo(olock, olock->l_handle.h_cookie == ols->ols_handle.cookie))\r\nreturn 0;\r\nif (!ergo(handle_used,\r\nergo(lock && olock, lock == olock) &&\r\nergo(!lock, !olock)))\r\nreturn 0;\r\nif (!ergo(ols->ols_state == OLS_CANCELLED,\r\n!olock && !handle_used))\r\nreturn 0;\r\nif (!ergo(olock && ols->ols_state < OLS_CANCELLED,\r\n!ldlm_is_destroyed(olock)))\r\nreturn 0;\r\nif (!ergo(ols->ols_state == OLS_GRANTED,\r\nolock && olock->l_req_mode == olock->l_granted_mode &&\r\nols->ols_hold))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void osc_lock_fini(const struct lu_env *env,\r\nstruct cl_lock_slice *slice)\r\n{\r\nstruct osc_lock *ols = cl2osc_lock(slice);\r\nLINVRNT(osc_lock_invariant(ols));\r\nLASSERT(!ols->ols_dlmlock);\r\nkmem_cache_free(osc_lock_kmem, ols);\r\n}\r\nstatic void osc_lock_build_policy(const struct lu_env *env,\r\nconst struct cl_lock *lock,\r\nunion ldlm_policy_data *policy)\r\n{\r\nconst struct cl_lock_descr *d = &lock->cll_descr;\r\nosc_index2policy(policy, d->cld_obj, d->cld_start, d->cld_end);\r\npolicy->l_extent.gid = d->cld_gid;\r\n}\r\nstatic __u64 osc_enq2ldlm_flags(__u32 enqflags)\r\n{\r\n__u64 result = 0;\r\nLASSERT((enqflags & ~CEF_MASK) == 0);\r\nif (enqflags & CEF_NONBLOCK)\r\nresult |= LDLM_FL_BLOCK_NOWAIT;\r\nif (enqflags & CEF_ASYNC)\r\nresult |= LDLM_FL_HAS_INTENT;\r\nif (enqflags & CEF_DISCARD_DATA)\r\nresult |= LDLM_FL_AST_DISCARD_DATA;\r\nif (enqflags & CEF_PEEK)\r\nresult |= LDLM_FL_TEST_LOCK;\r\nreturn result;\r\n}\r\nstatic void osc_lock_lvb_update(const struct lu_env *env,\r\nstruct osc_object *osc,\r\nstruct ldlm_lock *dlmlock,\r\nstruct ost_lvb *lvb)\r\n{\r\nstruct cl_object *obj = osc2cl(osc);\r\nstruct lov_oinfo *oinfo = osc->oo_oinfo;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nunsigned int valid;\r\nvalid = CAT_BLOCKS | CAT_ATIME | CAT_CTIME | CAT_MTIME | CAT_SIZE;\r\nif (!lvb)\r\nlvb = dlmlock->l_lvb_data;\r\ncl_lvb2attr(attr, lvb);\r\ncl_object_attr_lock(obj);\r\nif (dlmlock) {\r\n__u64 size;\r\ncheck_res_locked(dlmlock->l_resource);\r\nLASSERT(lvb == dlmlock->l_lvb_data);\r\nsize = lvb->lvb_size;\r\nif (size > dlmlock->l_policy_data.l_extent.end)\r\nsize = dlmlock->l_policy_data.l_extent.end + 1;\r\nif (size >= oinfo->loi_kms) {\r\nLDLM_DEBUG(dlmlock, "lock acquired, setting rss=%llu, kms=%llu",\r\nlvb->lvb_size, size);\r\nvalid |= CAT_KMS;\r\nattr->cat_kms = size;\r\n} else {\r\nLDLM_DEBUG(dlmlock, "lock acquired, setting rss=%llu; leaving kms=%llu, end=%llu",\r\nlvb->lvb_size, oinfo->loi_kms,\r\ndlmlock->l_policy_data.l_extent.end);\r\n}\r\nldlm_lock_allow_match_locked(dlmlock);\r\n}\r\ncl_object_attr_update(env, obj, attr, valid);\r\ncl_object_attr_unlock(obj);\r\n}\r\nstatic void osc_lock_granted(const struct lu_env *env, struct osc_lock *oscl,\r\nstruct lustre_handle *lockh, bool lvb_update)\r\n{\r\nstruct ldlm_lock *dlmlock;\r\ndlmlock = ldlm_handle2lock_long(lockh, 0);\r\nLASSERT(dlmlock);\r\nlu_ref_add(&dlmlock->l_reference, "osc_lock", oscl);\r\noscl->ols_has_ref = 1;\r\nLASSERT(!oscl->ols_dlmlock);\r\noscl->ols_dlmlock = dlmlock;\r\nif (!oscl->ols_glimpse) {\r\nlustre_handle_copy(&oscl->ols_handle, lockh);\r\nldlm_lock_addref(lockh, oscl->ols_einfo.ei_mode);\r\noscl->ols_hold = 1;\r\n}\r\nlock_res_and_lock(dlmlock);\r\nif (dlmlock->l_granted_mode == dlmlock->l_req_mode) {\r\nstruct ldlm_extent *ext = &dlmlock->l_policy_data.l_extent;\r\nstruct cl_lock_descr *descr = &oscl->ols_cl.cls_lock->cll_descr;\r\ndescr->cld_mode = osc_ldlm2cl_lock(dlmlock->l_granted_mode);\r\ndescr->cld_start = cl_index(descr->cld_obj, ext->start);\r\ndescr->cld_end = cl_index(descr->cld_obj, ext->end);\r\ndescr->cld_gid = ext->gid;\r\nif (lvb_update) {\r\nLASSERT(oscl->ols_flags & LDLM_FL_LVB_READY);\r\nosc_lock_lvb_update(env, cl2osc(oscl->ols_cl.cls_obj),\r\ndlmlock, NULL);\r\n}\r\nLINVRNT(osc_lock_invariant(oscl));\r\n}\r\nunlock_res_and_lock(dlmlock);\r\nLASSERT(oscl->ols_state != OLS_GRANTED);\r\noscl->ols_state = OLS_GRANTED;\r\n}\r\nstatic int osc_lock_upcall(void *cookie, struct lustre_handle *lockh,\r\nint errcode)\r\n{\r\nstruct osc_lock *oscl = cookie;\r\nstruct cl_lock_slice *slice = &oscl->ols_cl;\r\nstruct lu_env *env;\r\nint rc;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nLASSERT(!IS_ERR(env));\r\nrc = ldlm_error2errno(errcode);\r\nif (oscl->ols_state == OLS_ENQUEUED) {\r\noscl->ols_state = OLS_UPCALL_RECEIVED;\r\n} else if (oscl->ols_state == OLS_CANCELLED) {\r\nrc = -EIO;\r\n} else {\r\nCERROR("Impossible state: %d\n", oscl->ols_state);\r\nLBUG();\r\n}\r\nif (rc == 0)\r\nosc_lock_granted(env, oscl, lockh, errcode == ELDLM_OK);\r\nif (oscl->ols_locklessable && rc == -EUSERS) {\r\nosc_object_set_contended(cl2osc(slice->cls_obj));\r\nLASSERT(slice->cls_ops == &osc_lock_ops);\r\nosc_lock_to_lockless(env, oscl, 1);\r\noscl->ols_state = OLS_GRANTED;\r\nrc = 0;\r\n} else if (oscl->ols_glimpse && rc == -ENAVAIL) {\r\nLASSERT(oscl->ols_flags & LDLM_FL_LVB_READY);\r\nosc_lock_lvb_update(env, cl2osc(slice->cls_obj),\r\nNULL, &oscl->ols_lvb);\r\nrc = 0;\r\n}\r\nif (oscl->ols_owner)\r\ncl_sync_io_note(env, oscl->ols_owner, rc);\r\ncl_env_put(env, &refcheck);\r\nreturn rc;\r\n}\r\nstatic int osc_lock_upcall_agl(void *cookie, struct lustre_handle *lockh,\r\nint errcode)\r\n{\r\nstruct osc_object *osc = cookie;\r\nstruct ldlm_lock *dlmlock;\r\nstruct lu_env *env;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nLASSERT(!IS_ERR(env));\r\nif (errcode == ELDLM_LOCK_MATCHED) {\r\nerrcode = ELDLM_OK;\r\ngoto out;\r\n}\r\nif (errcode != ELDLM_OK)\r\ngoto out;\r\ndlmlock = ldlm_handle2lock(lockh);\r\nLASSERT(dlmlock);\r\nlock_res_and_lock(dlmlock);\r\nLASSERT(dlmlock->l_granted_mode == dlmlock->l_req_mode);\r\nosc_lock_lvb_update(env, osc, dlmlock, NULL);\r\nunlock_res_and_lock(dlmlock);\r\nLDLM_LOCK_PUT(dlmlock);\r\nout:\r\ncl_object_put(env, osc2cl(osc));\r\ncl_env_put(env, &refcheck);\r\nreturn ldlm_error2errno(errcode);\r\n}\r\nstatic int osc_lock_flush(struct osc_object *obj, pgoff_t start, pgoff_t end,\r\nenum cl_lock_mode mode, int discard)\r\n{\r\nstruct lu_env *env;\r\nint refcheck;\r\nint rc = 0;\r\nint rc2 = 0;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\nif (mode == CLM_WRITE) {\r\nrc = osc_cache_writeback_range(env, obj, start, end, 1,\r\ndiscard);\r\nCDEBUG(D_CACHE, "object %p: [%lu -> %lu] %d pages were %s.\n",\r\nobj, start, end, rc,\r\ndiscard ? "discarded" : "written back");\r\nif (rc > 0)\r\nrc = 0;\r\n}\r\nrc2 = osc_lock_discard_pages(env, obj, start, end, mode);\r\nif (rc == 0 && rc2 < 0)\r\nrc = rc2;\r\ncl_env_put(env, &refcheck);\r\nreturn rc;\r\n}\r\nstatic int osc_dlm_blocking_ast0(const struct lu_env *env,\r\nstruct ldlm_lock *dlmlock,\r\nvoid *data, int flag)\r\n{\r\nstruct cl_object *obj = NULL;\r\nint result = 0;\r\nint discard;\r\nenum cl_lock_mode mode = CLM_READ;\r\nLASSERT(flag == LDLM_CB_CANCELING);\r\nlock_res_and_lock(dlmlock);\r\nif (dlmlock->l_granted_mode != dlmlock->l_req_mode) {\r\ndlmlock->l_ast_data = NULL;\r\nunlock_res_and_lock(dlmlock);\r\nreturn 0;\r\n}\r\ndiscard = ldlm_is_discard_data(dlmlock);\r\nif (dlmlock->l_granted_mode & (LCK_PW | LCK_GROUP))\r\nmode = CLM_WRITE;\r\nif (dlmlock->l_ast_data) {\r\nobj = osc2cl(dlmlock->l_ast_data);\r\ndlmlock->l_ast_data = NULL;\r\ncl_object_get(obj);\r\n}\r\nunlock_res_and_lock(dlmlock);\r\nif (obj) {\r\nstruct ldlm_extent *extent = &dlmlock->l_policy_data.l_extent;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\n__u64 old_kms;\r\nresult = osc_lock_flush(cl2osc(obj),\r\ncl_index(obj, extent->start),\r\ncl_index(obj, extent->end),\r\nmode, discard);\r\nlock_res_and_lock(dlmlock);\r\ncl_object_attr_lock(obj);\r\nold_kms = cl2osc(obj)->oo_oinfo->loi_kms;\r\nattr->cat_kms = ldlm_extent_shift_kms(dlmlock, old_kms);\r\ncl_object_attr_update(env, obj, attr, CAT_KMS);\r\ncl_object_attr_unlock(obj);\r\nunlock_res_and_lock(dlmlock);\r\ncl_object_put(env, obj);\r\n}\r\nreturn result;\r\n}\r\nstatic int osc_ldlm_blocking_ast(struct ldlm_lock *dlmlock,\r\nstruct ldlm_lock_desc *new, void *data,\r\nint flag)\r\n{\r\nint result = 0;\r\nswitch (flag) {\r\ncase LDLM_CB_BLOCKING: {\r\nstruct lustre_handle lockh;\r\nldlm_lock2handle(dlmlock, &lockh);\r\nresult = ldlm_cli_cancel(&lockh, LCF_ASYNC);\r\nif (result == -ENODATA)\r\nresult = 0;\r\nbreak;\r\n}\r\ncase LDLM_CB_CANCELING: {\r\nstruct lu_env *env;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env)) {\r\nresult = PTR_ERR(env);\r\nbreak;\r\n}\r\nresult = osc_dlm_blocking_ast0(env, dlmlock, data, flag);\r\ncl_env_put(env, &refcheck);\r\nbreak;\r\n}\r\ndefault:\r\nLBUG();\r\n}\r\nreturn result;\r\n}\r\nstatic int osc_ldlm_glimpse_ast(struct ldlm_lock *dlmlock, void *data)\r\n{\r\nstruct ptlrpc_request *req = data;\r\nstruct lu_env *env;\r\nstruct ost_lvb *lvb;\r\nstruct req_capsule *cap;\r\nstruct cl_object *obj = NULL;\r\nint result;\r\nint refcheck;\r\nLASSERT(lustre_msg_get_opc(req->rq_reqmsg) == LDLM_GL_CALLBACK);\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env)) {\r\nresult = PTR_ERR(env);\r\ngoto out;\r\n}\r\nlock_res_and_lock(dlmlock);\r\nif (dlmlock->l_ast_data) {\r\nobj = osc2cl(dlmlock->l_ast_data);\r\ncl_object_get(obj);\r\n}\r\nunlock_res_and_lock(dlmlock);\r\nif (obj) {\r\ncap = &req->rq_pill;\r\nreq_capsule_extend(cap, &RQF_LDLM_GL_CALLBACK);\r\nreq_capsule_set_size(cap, &RMF_DLM_LVB, RCL_SERVER,\r\nsizeof(*lvb));\r\nresult = req_capsule_server_pack(cap);\r\nif (result == 0) {\r\nlvb = req_capsule_server_get(cap, &RMF_DLM_LVB);\r\nresult = cl_object_glimpse(env, obj, lvb);\r\n}\r\nif (!exp_connect_lvb_type(req->rq_export)) {\r\nreq_capsule_shrink(&req->rq_pill, &RMF_DLM_LVB,\r\nsizeof(struct ost_lvb_v1),\r\nRCL_SERVER);\r\n}\r\ncl_object_put(env, obj);\r\n} else {\r\nlustre_pack_reply(req, 1, NULL, NULL);\r\nresult = -ELDLM_NO_LOCK_DATA;\r\n}\r\ncl_env_put(env, &refcheck);\r\nout:\r\nreq->rq_status = result;\r\nreturn result;\r\n}\r\nstatic int weigh_cb(const struct lu_env *env, struct cl_io *io,\r\nstruct osc_page *ops, void *cbdata)\r\n{\r\nstruct cl_page *page = ops->ops_cl.cpl_page;\r\nif (cl_page_is_vmlocked(env, page) ||\r\nPageDirty(page->cp_vmpage) || PageWriteback(page->cp_vmpage)\r\n)\r\nreturn CLP_GANG_ABORT;\r\n*(pgoff_t *)cbdata = osc_index(ops) + 1;\r\nreturn CLP_GANG_OKAY;\r\n}\r\nstatic unsigned long osc_lock_weight(const struct lu_env *env,\r\nstruct osc_object *oscobj,\r\nstruct ldlm_extent *extent)\r\n{\r\nstruct cl_io *io = &osc_env_info(env)->oti_io;\r\nstruct cl_object *obj = cl_object_top(&oscobj->oo_cl);\r\npgoff_t page_index;\r\nint result;\r\nio->ci_obj = obj;\r\nio->ci_ignore_layout = 1;\r\nresult = cl_io_init(env, io, CIT_MISC, io->ci_obj);\r\nif (result != 0)\r\nreturn result;\r\npage_index = cl_index(obj, extent->start);\r\ndo {\r\nresult = osc_page_gang_lookup(env, io, oscobj,\r\npage_index,\r\ncl_index(obj, extent->end),\r\nweigh_cb, (void *)&page_index);\r\nif (result == CLP_GANG_ABORT)\r\nbreak;\r\nif (result == CLP_GANG_RESCHED)\r\ncond_resched();\r\n} while (result != CLP_GANG_OKAY);\r\ncl_io_fini(env, io);\r\nreturn result == CLP_GANG_ABORT ? 1 : 0;\r\n}\r\nunsigned long osc_ldlm_weigh_ast(struct ldlm_lock *dlmlock)\r\n{\r\nstruct lu_env *env;\r\nstruct osc_object *obj;\r\nstruct osc_lock *oscl;\r\nunsigned long weight;\r\nbool found = false;\r\nint refcheck;\r\nmight_sleep();\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn 1;\r\nLASSERT(dlmlock->l_resource->lr_type == LDLM_EXTENT);\r\nobj = dlmlock->l_ast_data;\r\nif (!obj) {\r\nweight = 1;\r\ngoto out;\r\n}\r\nspin_lock(&obj->oo_ol_spin);\r\nlist_for_each_entry(oscl, &obj->oo_ol_list, ols_nextlock_oscobj) {\r\nif (oscl->ols_dlmlock && oscl->ols_dlmlock != dlmlock)\r\ncontinue;\r\nfound = true;\r\n}\r\nspin_unlock(&obj->oo_ol_spin);\r\nif (found) {\r\nweight = 1;\r\ngoto out;\r\n}\r\nweight = osc_lock_weight(env, obj, &dlmlock->l_policy_data.l_extent);\r\nout:\r\ncl_env_put(env, &refcheck);\r\nreturn weight;\r\n}\r\nstatic void osc_lock_build_einfo(const struct lu_env *env,\r\nconst struct cl_lock *lock,\r\nstruct osc_object *osc,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\neinfo->ei_type = LDLM_EXTENT;\r\neinfo->ei_mode = osc_cl_lock2ldlm(lock->cll_descr.cld_mode);\r\neinfo->ei_cb_bl = osc_ldlm_blocking_ast;\r\neinfo->ei_cb_cp = ldlm_completion_ast;\r\neinfo->ei_cb_gl = osc_ldlm_glimpse_ast;\r\neinfo->ei_cbdata = osc;\r\n}\r\nstatic void osc_lock_to_lockless(const struct lu_env *env,\r\nstruct osc_lock *ols, int force)\r\n{\r\nstruct cl_lock_slice *slice = &ols->ols_cl;\r\nLASSERT(ols->ols_state == OLS_NEW ||\r\nols->ols_state == OLS_UPCALL_RECEIVED);\r\nif (force) {\r\nols->ols_locklessable = 1;\r\nslice->cls_ops = &osc_lock_lockless_ops;\r\n} else {\r\nstruct osc_io *oio = osc_env_io(env);\r\nstruct cl_io *io = oio->oi_cl.cis_io;\r\nstruct cl_object *obj = slice->cls_obj;\r\nstruct osc_object *oob = cl2osc(obj);\r\nconst struct osc_device *osd = lu2osc_dev(obj->co_lu.lo_dev);\r\nstruct obd_connect_data *ocd;\r\nLASSERT(io->ci_lockreq == CILR_MANDATORY ||\r\nio->ci_lockreq == CILR_MAYBE ||\r\nio->ci_lockreq == CILR_NEVER);\r\nocd = &class_exp2cliimp(osc_export(oob))->imp_connect_data;\r\nols->ols_locklessable = (io->ci_type != CIT_SETATTR) &&\r\n(io->ci_lockreq == CILR_MAYBE) &&\r\n(ocd->ocd_connect_flags & OBD_CONNECT_SRVLOCK);\r\nif (io->ci_lockreq == CILR_NEVER ||\r\n(ols->ols_locklessable && osc_object_is_contended(oob)) ||\r\n(cl_io_is_trunc(io) &&\r\n(ocd->ocd_connect_flags & OBD_CONNECT_TRUNCLOCK) &&\r\nosd->od_lockless_truncate)) {\r\nols->ols_locklessable = 1;\r\nslice->cls_ops = &osc_lock_lockless_ops;\r\n}\r\n}\r\nLASSERT(ergo(ols->ols_glimpse, !osc_lock_is_lockless(ols)));\r\n}\r\nstatic bool osc_lock_compatible(const struct osc_lock *qing,\r\nconst struct osc_lock *qed)\r\n{\r\nstruct cl_lock_descr *qed_descr = &qed->ols_cl.cls_lock->cll_descr;\r\nstruct cl_lock_descr *qing_descr = &qing->ols_cl.cls_lock->cll_descr;\r\nif (qed->ols_glimpse)\r\nreturn true;\r\nif (qing_descr->cld_mode == CLM_READ && qed_descr->cld_mode == CLM_READ)\r\nreturn true;\r\nif (qed->ols_state < OLS_GRANTED)\r\nreturn true;\r\nif (qed_descr->cld_mode >= qing_descr->cld_mode &&\r\nqed_descr->cld_start <= qing_descr->cld_start &&\r\nqed_descr->cld_end >= qing_descr->cld_end)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void osc_lock_wake_waiters(const struct lu_env *env,\r\nstruct osc_object *osc,\r\nstruct osc_lock *oscl)\r\n{\r\nspin_lock(&osc->oo_ol_spin);\r\nlist_del_init(&oscl->ols_nextlock_oscobj);\r\nspin_unlock(&osc->oo_ol_spin);\r\nspin_lock(&oscl->ols_lock);\r\nwhile (!list_empty(&oscl->ols_waiting_list)) {\r\nstruct osc_lock *scan;\r\nscan = list_entry(oscl->ols_waiting_list.next, struct osc_lock,\r\nols_wait_entry);\r\nlist_del_init(&scan->ols_wait_entry);\r\ncl_sync_io_note(env, scan->ols_owner, 0);\r\n}\r\nspin_unlock(&oscl->ols_lock);\r\n}\r\nstatic void osc_lock_enqueue_wait(const struct lu_env *env,\r\nstruct osc_object *obj,\r\nstruct osc_lock *oscl)\r\n{\r\nstruct osc_lock *tmp_oscl;\r\nstruct cl_lock_descr *need = &oscl->ols_cl.cls_lock->cll_descr;\r\nstruct cl_sync_io *waiter = &osc_env_info(env)->oti_anchor;\r\nspin_lock(&obj->oo_ol_spin);\r\nlist_add_tail(&oscl->ols_nextlock_oscobj, &obj->oo_ol_list);\r\nrestart:\r\nlist_for_each_entry(tmp_oscl, &obj->oo_ol_list,\r\nols_nextlock_oscobj) {\r\nstruct cl_lock_descr *descr;\r\nif (tmp_oscl == oscl)\r\nbreak;\r\ndescr = &tmp_oscl->ols_cl.cls_lock->cll_descr;\r\nif (descr->cld_start > need->cld_end ||\r\ndescr->cld_end < need->cld_start)\r\ncontinue;\r\nif (descr->cld_mode == CLM_GROUP)\r\nbreak;\r\nif (!osc_lock_is_lockless(oscl) &&\r\nosc_lock_compatible(oscl, tmp_oscl))\r\ncontinue;\r\ncl_sync_io_init(waiter, 1, cl_sync_io_end);\r\noscl->ols_owner = waiter;\r\nspin_lock(&tmp_oscl->ols_lock);\r\nlist_add_tail(&oscl->ols_wait_entry,\r\n&tmp_oscl->ols_waiting_list);\r\nspin_unlock(&tmp_oscl->ols_lock);\r\nspin_unlock(&obj->oo_ol_spin);\r\n(void)cl_sync_io_wait(env, waiter, 0);\r\nspin_lock(&obj->oo_ol_spin);\r\noscl->ols_owner = NULL;\r\ngoto restart;\r\n}\r\nspin_unlock(&obj->oo_ol_spin);\r\n}\r\nstatic int osc_lock_enqueue(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice,\r\nstruct cl_io *unused, struct cl_sync_io *anchor)\r\n{\r\nstruct osc_thread_info *info = osc_env_info(env);\r\nstruct osc_io *oio = osc_env_io(env);\r\nstruct osc_object *osc = cl2osc(slice->cls_obj);\r\nstruct osc_lock *oscl = cl2osc_lock(slice);\r\nstruct cl_lock *lock = slice->cls_lock;\r\nstruct ldlm_res_id *resname = &info->oti_resname;\r\nunion ldlm_policy_data *policy = &info->oti_policy;\r\nosc_enqueue_upcall_f upcall = osc_lock_upcall;\r\nvoid *cookie = oscl;\r\nbool async = false;\r\nint result;\r\nLASSERTF(ergo(oscl->ols_glimpse, lock->cll_descr.cld_mode <= CLM_READ),\r\n"lock = %p, ols = %p\n", lock, oscl);\r\nif (oscl->ols_state == OLS_GRANTED)\r\nreturn 0;\r\nif (oscl->ols_flags & LDLM_FL_TEST_LOCK)\r\ngoto enqueue_base;\r\nif (oscl->ols_glimpse) {\r\nLASSERT(equi(oscl->ols_agl, !anchor));\r\nasync = true;\r\ngoto enqueue_base;\r\n}\r\nosc_lock_enqueue_wait(env, osc, oscl);\r\nif (osc_lock_is_lockless(oscl)) {\r\noscl->ols_state = OLS_GRANTED;\r\noio->oi_lockless = 1;\r\nreturn 0;\r\n}\r\nenqueue_base:\r\noscl->ols_state = OLS_ENQUEUED;\r\nif (anchor) {\r\natomic_inc(&anchor->csi_sync_nr);\r\noscl->ols_owner = anchor;\r\n}\r\nostid_build_res_name(&osc->oo_oinfo->loi_oi, resname);\r\nosc_lock_build_einfo(env, lock, osc, &oscl->ols_einfo);\r\nosc_lock_build_policy(env, lock, policy);\r\nif (oscl->ols_agl) {\r\noscl->ols_einfo.ei_cbdata = NULL;\r\ncl_object_get(osc2cl(osc));\r\nupcall = osc_lock_upcall_agl;\r\ncookie = osc;\r\n}\r\nresult = osc_enqueue_base(osc_export(osc), resname, &oscl->ols_flags,\r\npolicy, &oscl->ols_lvb,\r\nosc->oo_oinfo->loi_kms_valid,\r\nupcall, cookie,\r\n&oscl->ols_einfo, PTLRPCD_SET, async,\r\noscl->ols_agl);\r\nif (result != 0) {\r\noscl->ols_state = OLS_CANCELLED;\r\nosc_lock_wake_waiters(env, osc, oscl);\r\nif (oscl->ols_agl) {\r\ncl_object_put(env, osc2cl(osc));\r\nresult = 0;\r\n}\r\nif (anchor)\r\ncl_sync_io_note(env, anchor, result);\r\n} else {\r\nif (osc_lock_is_lockless(oscl)) {\r\noio->oi_lockless = 1;\r\n} else if (!async) {\r\nLASSERT(oscl->ols_state == OLS_GRANTED);\r\nLASSERT(oscl->ols_hold);\r\nLASSERT(oscl->ols_dlmlock);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void osc_lock_detach(const struct lu_env *env, struct osc_lock *olck)\r\n{\r\nstruct ldlm_lock *dlmlock;\r\ndlmlock = olck->ols_dlmlock;\r\nif (!dlmlock)\r\nreturn;\r\nif (olck->ols_hold) {\r\nolck->ols_hold = 0;\r\nldlm_lock_decref(&olck->ols_handle, olck->ols_einfo.ei_mode);\r\nolck->ols_handle.cookie = 0ULL;\r\n}\r\nolck->ols_dlmlock = NULL;\r\nLASSERT(olck->ols_has_ref);\r\nlu_ref_del(&dlmlock->l_reference, "osc_lock", olck);\r\nLDLM_LOCK_RELEASE(dlmlock);\r\nolck->ols_has_ref = 0;\r\n}\r\nstatic void osc_lock_cancel(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct osc_object *obj = cl2osc(slice->cls_obj);\r\nstruct osc_lock *oscl = cl2osc_lock(slice);\r\nLINVRNT(osc_lock_invariant(oscl));\r\nosc_lock_detach(env, oscl);\r\noscl->ols_state = OLS_CANCELLED;\r\noscl->ols_flags &= ~LDLM_FL_LVB_READY;\r\nosc_lock_wake_waiters(env, obj, oscl);\r\n}\r\nstatic int osc_lock_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct cl_lock_slice *slice)\r\n{\r\nstruct osc_lock *lock = cl2osc_lock(slice);\r\n(*p)(env, cookie, "%p %#16llx %#llx %d %p ",\r\nlock->ols_dlmlock, lock->ols_flags, lock->ols_handle.cookie,\r\nlock->ols_state, lock->ols_owner);\r\nosc_lvb_print(env, cookie, p, &lock->ols_lvb);\r\nreturn 0;\r\n}\r\nstatic void osc_lock_lockless_cancel(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct osc_lock *ols = cl2osc_lock(slice);\r\nstruct osc_object *osc = cl2osc(slice->cls_obj);\r\nstruct cl_lock_descr *descr = &slice->cls_lock->cll_descr;\r\nint result;\r\nLASSERT(!ols->ols_dlmlock);\r\nresult = osc_lock_flush(osc, descr->cld_start, descr->cld_end,\r\ndescr->cld_mode, 0);\r\nif (result)\r\nCERROR("Pages for lockless lock %p were not purged(%d)\n",\r\nols, result);\r\nosc_lock_wake_waiters(env, osc, ols);\r\n}\r\nstatic void osc_lock_set_writer(const struct lu_env *env,\r\nconst struct cl_io *io,\r\nstruct cl_object *obj, struct osc_lock *oscl)\r\n{\r\nstruct cl_lock_descr *descr = &oscl->ols_cl.cls_lock->cll_descr;\r\npgoff_t io_start;\r\npgoff_t io_end;\r\nif (!cl_object_same(io->ci_obj, obj))\r\nreturn;\r\nif (likely(io->ci_type == CIT_WRITE)) {\r\nio_start = cl_index(obj, io->u.ci_rw.crw_pos);\r\nio_end = cl_index(obj, io->u.ci_rw.crw_pos +\r\nio->u.ci_rw.crw_count - 1);\r\nif (cl_io_is_append(io)) {\r\nio_start = 0;\r\nio_end = CL_PAGE_EOF;\r\n}\r\n} else {\r\nLASSERT(cl_io_is_mkwrite(io));\r\nio_start = io->u.ci_fault.ft_index;\r\nio_end = io->u.ci_fault.ft_index;\r\n}\r\nif (descr->cld_mode >= CLM_WRITE &&\r\ndescr->cld_start <= io_start && descr->cld_end >= io_end) {\r\nstruct osc_io *oio = osc_env_io(env);\r\nLASSERT(!oio->oi_write_osclock);\r\noio->oi_write_osclock = oscl;\r\n}\r\n}\r\nint osc_lock_init(const struct lu_env *env,\r\nstruct cl_object *obj, struct cl_lock *lock,\r\nconst struct cl_io *io)\r\n{\r\nstruct osc_lock *oscl;\r\n__u32 enqflags = lock->cll_descr.cld_enq_flags;\r\noscl = kmem_cache_zalloc(osc_lock_kmem, GFP_NOFS);\r\nif (!oscl)\r\nreturn -ENOMEM;\r\noscl->ols_state = OLS_NEW;\r\nspin_lock_init(&oscl->ols_lock);\r\nINIT_LIST_HEAD(&oscl->ols_waiting_list);\r\nINIT_LIST_HEAD(&oscl->ols_wait_entry);\r\nINIT_LIST_HEAD(&oscl->ols_nextlock_oscobj);\r\noscl->ols_flags = osc_enq2ldlm_flags(enqflags);\r\noscl->ols_agl = !!(enqflags & CEF_AGL);\r\nif (oscl->ols_agl)\r\noscl->ols_flags |= LDLM_FL_BLOCK_NOWAIT;\r\nif (oscl->ols_flags & LDLM_FL_HAS_INTENT) {\r\noscl->ols_flags |= LDLM_FL_BLOCK_GRANTED;\r\noscl->ols_glimpse = 1;\r\n}\r\ncl_lock_slice_add(lock, &oscl->ols_cl, obj, &osc_lock_ops);\r\nif (!(enqflags & CEF_MUST))\r\nosc_lock_to_lockless(env, oscl, (enqflags & CEF_NEVER));\r\nif (oscl->ols_locklessable && !(enqflags & CEF_DISCARD_DATA))\r\noscl->ols_flags |= LDLM_FL_DENY_ON_CONTENTION;\r\nif (io->ci_type == CIT_WRITE || cl_io_is_mkwrite(io))\r\nosc_lock_set_writer(env, io, obj, oscl);\r\nLDLM_DEBUG_NOLOCK("lock %p, osc lock %p, flags %llx",\r\nlock, oscl, oscl->ols_flags);\r\nreturn 0;\r\n}\r\nstruct ldlm_lock *osc_dlmlock_at_pgoff(const struct lu_env *env,\r\nstruct osc_object *obj, pgoff_t index,\r\nenum osc_dap_flags dap_flags)\r\n{\r\nstruct osc_thread_info *info = osc_env_info(env);\r\nstruct ldlm_res_id *resname = &info->oti_resname;\r\nunion ldlm_policy_data *policy = &info->oti_policy;\r\nstruct lustre_handle lockh;\r\nstruct ldlm_lock *lock = NULL;\r\nenum ldlm_mode mode;\r\n__u64 flags;\r\nostid_build_res_name(&obj->oo_oinfo->loi_oi, resname);\r\nosc_index2policy(policy, osc2cl(obj), index, index);\r\npolicy->l_extent.gid = LDLM_GID_ANY;\r\nflags = LDLM_FL_BLOCK_GRANTED | LDLM_FL_CBPENDING;\r\nif (dap_flags & OSC_DAP_FL_TEST_LOCK)\r\nflags |= LDLM_FL_TEST_LOCK;\r\nagain:\r\nmode = osc_match_base(osc_export(obj), resname, LDLM_EXTENT, policy,\r\nLCK_PR | LCK_PW | LCK_GROUP, &flags, obj, &lockh,\r\ndap_flags & OSC_DAP_FL_CANCELING);\r\nif (mode != 0) {\r\nlock = ldlm_handle2lock(&lockh);\r\nif (unlikely(!lock))\r\ngoto again;\r\n}\r\nreturn lock;\r\n}
