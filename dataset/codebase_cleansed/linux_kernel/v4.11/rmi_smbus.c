static int rmi_smb_get_version(struct rmi_smb_xport *rmi_smb)\r\n{\r\nstruct i2c_client *client = rmi_smb->client;\r\nint retval;\r\nretval = i2c_smbus_read_byte_data(client, SMB_PROTOCOL_VERSION_ADDRESS);\r\nif (retval < 0) {\r\ndev_err(&client->dev, "failed to get SMBus version number!\n");\r\nreturn retval;\r\n}\r\nreturn retval + 1;\r\n}\r\nstatic int smb_block_write(struct rmi_transport_dev *xport,\r\nu8 commandcode, const void *buf, size_t len)\r\n{\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nstruct i2c_client *client = rmi_smb->client;\r\nint retval;\r\nretval = i2c_smbus_write_block_data(client, commandcode, len, buf);\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev,\r\n"wrote %zd bytes at %#04x: %d (%*ph)\n",\r\nlen, commandcode, retval, (int)len, buf);\r\nreturn retval;\r\n}\r\nstatic int rmi_smb_get_command_code(struct rmi_transport_dev *xport,\r\nu16 rmiaddr, int bytecount, bool isread, u8 *commandcode)\r\n{\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nint i;\r\nint retval;\r\nstruct mapping_table_entry mapping_data[1];\r\nmutex_lock(&rmi_smb->mappingtable_mutex);\r\nfor (i = 0; i < RMI_SMB2_MAP_SIZE; i++) {\r\nif (rmi_smb->mapping_table[i].rmiaddr == rmiaddr) {\r\nif (isread) {\r\nif (rmi_smb->mapping_table[i].readcount\r\n== bytecount) {\r\n*commandcode = i;\r\nretval = 0;\r\ngoto exit;\r\n}\r\n} else {\r\nif (rmi_smb->mapping_table[i].flags &\r\nRMI_SMB2_MAP_FLAGS_WE) {\r\n*commandcode = i;\r\nretval = 0;\r\ngoto exit;\r\n}\r\n}\r\n}\r\n}\r\ni = rmi_smb->table_index;\r\nrmi_smb->table_index = (i + 1) % RMI_SMB2_MAP_SIZE;\r\nmemset(mapping_data, 0, sizeof(mapping_data));\r\nmapping_data[0].rmiaddr = cpu_to_le16(rmiaddr);\r\nmapping_data[0].readcount = bytecount;\r\nmapping_data[0].flags = !isread ? RMI_SMB2_MAP_FLAGS_WE : 0;\r\nretval = smb_block_write(xport, i + 0x80, mapping_data,\r\nsizeof(mapping_data));\r\nif (retval < 0) {\r\nrmi_smb->mapping_table[i].rmiaddr = 0x0000;\r\nrmi_smb->mapping_table[i].readcount = 0;\r\nrmi_smb->mapping_table[i].flags = 0;\r\ngoto exit;\r\n}\r\nrmi_smb->mapping_table[i].rmiaddr = rmiaddr;\r\nrmi_smb->mapping_table[i].readcount = bytecount;\r\nrmi_smb->mapping_table[i].flags = !isread ? RMI_SMB2_MAP_FLAGS_WE : 0;\r\n*commandcode = i;\r\nexit:\r\nmutex_unlock(&rmi_smb->mappingtable_mutex);\r\nreturn retval;\r\n}\r\nstatic int rmi_smb_write_block(struct rmi_transport_dev *xport, u16 rmiaddr,\r\nconst void *databuff, size_t len)\r\n{\r\nint retval = 0;\r\nu8 commandcode;\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nint cur_len = (int)len;\r\nmutex_lock(&rmi_smb->page_mutex);\r\nwhile (cur_len > 0) {\r\nint block_len = min_t(int, len, SMB_MAX_COUNT);\r\nretval = rmi_smb_get_command_code(xport, rmiaddr, block_len,\r\nfalse, &commandcode);\r\nif (retval < 0)\r\ngoto exit;\r\nretval = smb_block_write(xport, commandcode,\r\ndatabuff, block_len);\r\nif (retval < 0)\r\ngoto exit;\r\ncur_len -= SMB_MAX_COUNT;\r\ndatabuff += SMB_MAX_COUNT;\r\nrmiaddr += SMB_MAX_COUNT;\r\n}\r\nexit:\r\nmutex_unlock(&rmi_smb->page_mutex);\r\nreturn retval;\r\n}\r\nstatic int smb_block_read(struct rmi_transport_dev *xport,\r\nu8 commandcode, void *buf, size_t len)\r\n{\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nstruct i2c_client *client = rmi_smb->client;\r\nint retval;\r\nretval = i2c_smbus_read_block_data(client, commandcode, buf);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn retval;\r\n}\r\nstatic int rmi_smb_read_block(struct rmi_transport_dev *xport, u16 rmiaddr,\r\nvoid *databuff, size_t len)\r\n{\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nint retval;\r\nu8 commandcode;\r\nint cur_len = (int)len;\r\nmutex_lock(&rmi_smb->page_mutex);\r\nmemset(databuff, 0, len);\r\nwhile (cur_len > 0) {\r\nint block_len = min_t(int, cur_len, SMB_MAX_COUNT);\r\nretval = rmi_smb_get_command_code(xport, rmiaddr, block_len,\r\ntrue, &commandcode);\r\nif (retval < 0)\r\ngoto exit;\r\nretval = smb_block_read(xport, commandcode,\r\ndatabuff, block_len);\r\nif (retval < 0)\r\ngoto exit;\r\ncur_len -= SMB_MAX_COUNT;\r\ndatabuff += SMB_MAX_COUNT;\r\nrmiaddr += SMB_MAX_COUNT;\r\n}\r\nretval = 0;\r\nexit:\r\nmutex_unlock(&rmi_smb->page_mutex);\r\nreturn retval;\r\n}\r\nstatic void rmi_smb_clear_state(struct rmi_smb_xport *rmi_smb)\r\n{\r\nmutex_lock(&rmi_smb->mappingtable_mutex);\r\nmemset(rmi_smb->mapping_table, 0, sizeof(rmi_smb->mapping_table));\r\nmutex_unlock(&rmi_smb->mappingtable_mutex);\r\n}\r\nstatic int rmi_smb_enable_smbus_mode(struct rmi_smb_xport *rmi_smb)\r\n{\r\nint retval;\r\nretval = rmi_smb_get_version(rmi_smb);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic int rmi_smb_reset(struct rmi_transport_dev *xport, u16 reset_addr)\r\n{\r\nstruct rmi_smb_xport *rmi_smb =\r\ncontainer_of(xport, struct rmi_smb_xport, xport);\r\nrmi_smb_clear_state(rmi_smb);\r\nreturn rmi_smb_enable_smbus_mode(rmi_smb);\r\n}\r\nstatic int rmi_smb_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rmi_device_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct rmi_smb_xport *rmi_smb;\r\nint retval;\r\nint smbus_version;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_HOST_NOTIFY)) {\r\ndev_err(&client->dev,\r\n"adapter does not support required functionality.\n");\r\nreturn -ENODEV;\r\n}\r\nif (client->irq <= 0) {\r\ndev_err(&client->dev, "no IRQ provided, giving up.\n");\r\nreturn client->irq ? client->irq : -ENODEV;\r\n}\r\nrmi_smb = devm_kzalloc(&client->dev, sizeof(struct rmi_smb_xport),\r\nGFP_KERNEL);\r\nif (!rmi_smb)\r\nreturn -ENOMEM;\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data, aborting\n");\r\nreturn -ENOMEM;\r\n}\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev, "Probing %s.\n",\r\ndev_name(&client->dev));\r\nrmi_smb->client = client;\r\nmutex_init(&rmi_smb->page_mutex);\r\nmutex_init(&rmi_smb->mappingtable_mutex);\r\nrmi_smb->xport.dev = &client->dev;\r\nrmi_smb->xport.pdata = *pdata;\r\nrmi_smb->xport.pdata.irq = client->irq;\r\nrmi_smb->xport.proto_name = "smb2";\r\nrmi_smb->xport.ops = &rmi_smb_ops;\r\nretval = rmi_smb_get_version(rmi_smb);\r\nif (retval < 0)\r\nreturn retval;\r\nsmbus_version = retval;\r\nrmi_dbg(RMI_DEBUG_XPORT, &client->dev, "Smbus version is %d",\r\nsmbus_version);\r\nif (smbus_version != 2) {\r\ndev_err(&client->dev, "Unrecognized SMB version %d.\n",\r\nsmbus_version);\r\nreturn -ENODEV;\r\n}\r\ni2c_set_clientdata(client, rmi_smb);\r\nretval = rmi_register_transport_device(&rmi_smb->xport);\r\nif (retval) {\r\ndev_err(&client->dev, "Failed to register transport driver at 0x%.2X.\n",\r\nclient->addr);\r\ni2c_set_clientdata(client, NULL);\r\nreturn retval;\r\n}\r\ndev_info(&client->dev, "registered rmi smb driver at %#04x.\n",\r\nclient->addr);\r\nreturn 0;\r\n}\r\nstatic int rmi_smb_remove(struct i2c_client *client)\r\n{\r\nstruct rmi_smb_xport *rmi_smb = i2c_get_clientdata(client);\r\nrmi_unregister_transport_device(&rmi_smb->xport);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rmi_smb_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_smb_xport *rmi_smb = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_smb->xport.rmi_dev, true);\r\nif (ret)\r\ndev_warn(dev, "Failed to suspend device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused rmi_smb_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_smb_xport *rmi_smb = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_suspend(rmi_smb->xport.rmi_dev, false);\r\nif (ret)\r\ndev_warn(dev, "Failed to suspend device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused rmi_smb_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct rmi_smb_xport *rmi_smb = i2c_get_clientdata(client);\r\nstruct rmi_device *rmi_dev = rmi_smb->xport.rmi_dev;\r\nint ret;\r\nrmi_smb_reset(&rmi_smb->xport, 0);\r\nrmi_reset(rmi_dev);\r\nret = rmi_driver_resume(rmi_smb->xport.rmi_dev, true);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rmi_smb_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rmi_smb_xport *rmi_smb = i2c_get_clientdata(client);\r\nint ret;\r\nret = rmi_driver_resume(rmi_smb->xport.rmi_dev, false);\r\nif (ret)\r\ndev_warn(dev, "Failed to resume device: %d\n", ret);\r\nreturn 0;\r\n}
