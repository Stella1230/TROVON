static void *squashfs_xz_comp_opts(struct squashfs_sb_info *msblk,\r\nvoid *buff, int len)\r\n{\r\nstruct disk_comp_opts *comp_opts = buff;\r\nstruct comp_opts *opts;\r\nint err = 0, n;\r\nopts = kmalloc(sizeof(*opts), GFP_KERNEL);\r\nif (opts == NULL) {\r\nerr = -ENOMEM;\r\ngoto out2;\r\n}\r\nif (comp_opts) {\r\nif (len < sizeof(*comp_opts)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nopts->dict_size = le32_to_cpu(comp_opts->dictionary_size);\r\nn = ffs(opts->dict_size) - 1;\r\nif (opts->dict_size != (1 << n) && opts->dict_size != (1 << n) +\r\n(1 << (n + 1))) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n} else\r\nopts->dict_size = max_t(int, msblk->block_size,\r\nSQUASHFS_METADATA_SIZE);\r\nreturn opts;\r\nout:\r\nkfree(opts);\r\nout2:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void *squashfs_xz_init(struct squashfs_sb_info *msblk, void *buff)\r\n{\r\nstruct comp_opts *comp_opts = buff;\r\nstruct squashfs_xz *stream;\r\nint err;\r\nstream = kmalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL) {\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nstream->state = xz_dec_init(XZ_PREALLOC, comp_opts->dict_size);\r\nif (stream->state == NULL) {\r\nkfree(stream);\r\nerr = -ENOMEM;\r\ngoto failed;\r\n}\r\nreturn stream;\r\nfailed:\r\nERROR("Failed to initialise xz decompressor\n");\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void squashfs_xz_free(void *strm)\r\n{\r\nstruct squashfs_xz *stream = strm;\r\nif (stream) {\r\nxz_dec_end(stream->state);\r\nkfree(stream);\r\n}\r\n}\r\nstatic int squashfs_xz_uncompress(struct squashfs_sb_info *msblk, void *strm,\r\nstruct buffer_head **bh, int b, int offset, int length,\r\nstruct squashfs_page_actor *output)\r\n{\r\nenum xz_ret xz_err;\r\nint avail, total = 0, k = 0;\r\nstruct squashfs_xz *stream = strm;\r\nxz_dec_reset(stream->state);\r\nstream->buf.in_pos = 0;\r\nstream->buf.in_size = 0;\r\nstream->buf.out_pos = 0;\r\nstream->buf.out_size = PAGE_SIZE;\r\nstream->buf.out = squashfs_first_page(output);\r\ndo {\r\nif (stream->buf.in_pos == stream->buf.in_size && k < b) {\r\navail = min(length, msblk->devblksize - offset);\r\nlength -= avail;\r\nstream->buf.in = bh[k]->b_data + offset;\r\nstream->buf.in_size = avail;\r\nstream->buf.in_pos = 0;\r\noffset = 0;\r\n}\r\nif (stream->buf.out_pos == stream->buf.out_size) {\r\nstream->buf.out = squashfs_next_page(output);\r\nif (stream->buf.out != NULL) {\r\nstream->buf.out_pos = 0;\r\ntotal += PAGE_SIZE;\r\n}\r\n}\r\nxz_err = xz_dec_run(stream->state, &stream->buf);\r\nif (stream->buf.in_pos == stream->buf.in_size && k < b)\r\nput_bh(bh[k++]);\r\n} while (xz_err == XZ_OK);\r\nsquashfs_finish_page(output);\r\nif (xz_err != XZ_STREAM_END || k < b)\r\ngoto out;\r\nreturn total + stream->buf.out_pos;\r\nout:\r\nfor (; k < b; k++)\r\nput_bh(bh[k]);\r\nreturn -EIO;\r\n}
