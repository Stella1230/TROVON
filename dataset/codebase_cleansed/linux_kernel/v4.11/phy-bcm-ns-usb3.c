static int bcm_ns_usb3_wait_reg(struct bcm_ns_usb3 *usb3, void __iomem *addr,\r\nu32 mask, u32 value, unsigned long timeout)\r\n{\r\nunsigned long deadline = jiffies + timeout;\r\nu32 val;\r\ndo {\r\nval = readl(addr);\r\nif ((val & mask) == value)\r\nreturn 0;\r\ncpu_relax();\r\nudelay(10);\r\n} while (!time_after_eq(jiffies, deadline));\r\ndev_err(usb3->dev, "Timeout waiting for register %p\n", addr);\r\nreturn -EBUSY;\r\n}\r\nstatic inline int bcm_ns_usb3_mii_mng_wait_idle(struct bcm_ns_usb3 *usb3)\r\n{\r\nreturn bcm_ns_usb3_wait_reg(usb3, usb3->ccb_mii + BCMA_CCB_MII_MNG_CTL,\r\n0x0100, 0x0000,\r\nusecs_to_jiffies(BCM_NS_USB3_MII_MNG_TIMEOUT_US));\r\n}\r\nstatic int bcm_ns_usb3_mii_mng_write32(struct bcm_ns_usb3 *usb3, u32 value)\r\n{\r\nint err;\r\nerr = bcm_ns_usb3_mii_mng_wait_idle(usb3);\r\nif (err < 0) {\r\ndev_err(usb3->dev, "Couldn't write 0x%08x value\n", value);\r\nreturn err;\r\n}\r\nwritel(value, usb3->ccb_mii + BCMA_CCB_MII_MNG_CMD_DATA);\r\nreturn 0;\r\n}\r\nstatic int bcm_ns_usb3_phy_init_ns_bx(struct bcm_ns_usb3 *usb3)\r\n{\r\nint err;\r\nwritel(0x0000009a, usb3->ccb_mii + BCMA_CCB_MII_MNG_CTL);\r\nudelay(2);\r\nerr = bcm_ns_usb3_mii_mng_write32(usb3, 0x587e8000);\r\nif (err < 0)\r\nreturn err;\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x58061000);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x582a6400);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x582ec000);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x582e8000);\r\nbcm_ns_usb3_mii_mng_wait_idle(usb3);\r\nwritel(0, usb3->dmp + BCMA_RESET_CTL);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x58069000);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x587e8060);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x580af30d);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x580e6302);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x587e8040);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x58061003);\r\nbcm_ns_usb3_mii_mng_wait_idle(usb3);\r\nreturn 0;\r\n}\r\nstatic int bcm_ns_usb3_phy_init_ns_ax(struct bcm_ns_usb3 *usb3)\r\n{\r\nint err;\r\nwritel(0x0000009a, usb3->ccb_mii + BCMA_CCB_MII_MNG_CTL);\r\nudelay(2);\r\nerr = bcm_ns_usb3_mii_mng_write32(usb3, 0x587e8000);\r\nif (err < 0)\r\nreturn err;\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x582a6400);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x587e80e0);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x580a009c);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x587e8040);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x580a21d3);\r\nbcm_ns_usb3_mii_mng_write32(usb3, 0x58061003);\r\nbcm_ns_usb3_mii_mng_wait_idle(usb3);\r\nwritel(0, usb3->dmp + BCMA_RESET_CTL);\r\nreturn 0;\r\n}\r\nstatic int bcm_ns_usb3_phy_init(struct phy *phy)\r\n{\r\nstruct bcm_ns_usb3 *usb3 = phy_get_drvdata(phy);\r\nint err;\r\nwritel(BCMA_RESET_CTL_RESET, usb3->dmp + BCMA_RESET_CTL);\r\nswitch (usb3->family) {\r\ncase BCM_NS_AX:\r\nerr = bcm_ns_usb3_phy_init_ns_ax(usb3);\r\nbreak;\r\ncase BCM_NS_BX:\r\nerr = bcm_ns_usb3_phy_init_ns_bx(usb3);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nerr = -ENOTSUPP;\r\n}\r\nreturn err;\r\n}\r\nstatic int bcm_ns_usb3_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct bcm_ns_usb3 *usb3;\r\nstruct resource *res;\r\nstruct phy_provider *phy_provider;\r\nusb3 = devm_kzalloc(dev, sizeof(*usb3), GFP_KERNEL);\r\nif (!usb3)\r\nreturn -ENOMEM;\r\nusb3->dev = dev;\r\nof_id = of_match_device(bcm_ns_usb3_id_table, dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nusb3->family = (enum bcm_ns_family)of_id->data;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dmp");\r\nusb3->dmp = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(usb3->dmp)) {\r\ndev_err(dev, "Failed to map DMP regs\n");\r\nreturn PTR_ERR(usb3->dmp);\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ccb-mii");\r\nusb3->ccb_mii = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(usb3->ccb_mii)) {\r\ndev_err(dev, "Failed to map ChipCommon B MII regs\n");\r\nreturn PTR_ERR(usb3->ccb_mii);\r\n}\r\nusb3->phy = devm_phy_create(dev, NULL, &ops);\r\nif (IS_ERR(usb3->phy)) {\r\ndev_err(dev, "Failed to create PHY\n");\r\nreturn PTR_ERR(usb3->phy);\r\n}\r\nphy_set_drvdata(usb3->phy, usb3);\r\nplatform_set_drvdata(pdev, usb3);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (!IS_ERR(phy_provider))\r\ndev_info(dev, "Registered Broadcom Northstar USB 3.0 PHY driver\n");\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
