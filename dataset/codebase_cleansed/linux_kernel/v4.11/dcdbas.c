static void smi_data_buf_free(void)\r\n{\r\nif (!smi_data_buf)\r\nreturn;\r\ndev_dbg(&dcdbas_pdev->dev, "%s: phys: %x size: %lu\n",\r\n__func__, smi_data_buf_phys_addr, smi_data_buf_size);\r\ndma_free_coherent(&dcdbas_pdev->dev, smi_data_buf_size, smi_data_buf,\r\nsmi_data_buf_handle);\r\nsmi_data_buf = NULL;\r\nsmi_data_buf_handle = 0;\r\nsmi_data_buf_phys_addr = 0;\r\nsmi_data_buf_size = 0;\r\n}\r\nstatic int smi_data_buf_realloc(unsigned long size)\r\n{\r\nvoid *buf;\r\ndma_addr_t handle;\r\nif (smi_data_buf_size >= size)\r\nreturn 0;\r\nif (size > MAX_SMI_DATA_BUF_SIZE)\r\nreturn -EINVAL;\r\nbuf = dma_alloc_coherent(&dcdbas_pdev->dev, size, &handle, GFP_KERNEL);\r\nif (!buf) {\r\ndev_dbg(&dcdbas_pdev->dev,\r\n"%s: failed to allocate memory size %lu\n",\r\n__func__, size);\r\nreturn -ENOMEM;\r\n}\r\nif (smi_data_buf)\r\nmemcpy(buf, smi_data_buf, smi_data_buf_size);\r\nsmi_data_buf_free();\r\nsmi_data_buf = buf;\r\nsmi_data_buf_handle = handle;\r\nsmi_data_buf_phys_addr = (u32) virt_to_phys(buf);\r\nsmi_data_buf_size = size;\r\ndev_dbg(&dcdbas_pdev->dev, "%s: phys: %x size: %lu\n",\r\n__func__, smi_data_buf_phys_addr, smi_data_buf_size);\r\nreturn 0;\r\n}\r\nstatic ssize_t smi_data_buf_phys_addr_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%x\n", smi_data_buf_phys_addr);\r\n}\r\nstatic ssize_t smi_data_buf_size_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", smi_data_buf_size);\r\n}\r\nstatic ssize_t smi_data_buf_size_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long buf_size;\r\nssize_t ret;\r\nbuf_size = simple_strtoul(buf, NULL, 10);\r\nmutex_lock(&smi_data_lock);\r\nret = smi_data_buf_realloc(buf_size);\r\nmutex_unlock(&smi_data_lock);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t smi_data_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nssize_t ret;\r\nmutex_lock(&smi_data_lock);\r\nret = memory_read_from_buffer(buf, count, &pos, smi_data_buf,\r\nsmi_data_buf_size);\r\nmutex_unlock(&smi_data_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t smi_data_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nssize_t ret;\r\nif ((pos + count) > MAX_SMI_DATA_BUF_SIZE)\r\nreturn -EINVAL;\r\nmutex_lock(&smi_data_lock);\r\nret = smi_data_buf_realloc(pos + count);\r\nif (ret)\r\ngoto out;\r\nmemcpy(smi_data_buf + pos, buf, count);\r\nret = count;\r\nout:\r\nmutex_unlock(&smi_data_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t host_control_action_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", host_control_action);\r\n}\r\nstatic ssize_t host_control_action_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nssize_t ret;\r\nmutex_lock(&smi_data_lock);\r\nret = smi_data_buf_realloc(sizeof(struct apm_cmd));\r\nmutex_unlock(&smi_data_lock);\r\nif (ret)\r\nreturn ret;\r\nhost_control_action = simple_strtoul(buf, NULL, 10);\r\nreturn count;\r\n}\r\nstatic ssize_t host_control_smi_type_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", host_control_smi_type);\r\n}\r\nstatic ssize_t host_control_smi_type_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nhost_control_smi_type = simple_strtoul(buf, NULL, 10);\r\nreturn count;\r\n}\r\nstatic ssize_t host_control_on_shutdown_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", host_control_on_shutdown);\r\n}\r\nstatic ssize_t host_control_on_shutdown_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nhost_control_on_shutdown = simple_strtoul(buf, NULL, 10);\r\nreturn count;\r\n}\r\nstatic int raise_smi(void *par)\r\n{\r\nstruct smi_cmd *smi_cmd = par;\r\nif (smp_processor_id() != 0) {\r\ndev_dbg(&dcdbas_pdev->dev, "%s: failed to get CPU 0\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nasm volatile (\r\n"outb %b0,%w1\n"\r\n"inb %w1"\r\n:\r\n: "a" (smi_cmd->command_code),\r\n"d" (smi_cmd->command_address),\r\n"b" (smi_cmd->ebx),\r\n"c" (smi_cmd->ecx)\r\n: "memory"\r\n);\r\nreturn 0;\r\n}\r\nint dcdbas_smi_request(struct smi_cmd *smi_cmd)\r\n{\r\nint ret;\r\nif (smi_cmd->magic != SMI_CMD_MAGIC) {\r\ndev_info(&dcdbas_pdev->dev, "%s: invalid magic value\n",\r\n__func__);\r\nreturn -EBADR;\r\n}\r\nget_online_cpus();\r\nret = smp_call_on_cpu(0, raise_smi, smi_cmd, true);\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic ssize_t smi_request_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct smi_cmd *smi_cmd;\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nssize_t ret;\r\nmutex_lock(&smi_data_lock);\r\nif (smi_data_buf_size < sizeof(struct smi_cmd)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsmi_cmd = (struct smi_cmd *)smi_data_buf;\r\nswitch (val) {\r\ncase 2:\r\nret = dcdbas_smi_request(smi_cmd);\r\nif (!ret)\r\nret = count;\r\nbreak;\r\ncase 1:\r\nsmi_cmd->ebx = (u32) virt_to_phys(smi_cmd->command_buffer);\r\nret = dcdbas_smi_request(smi_cmd);\r\nif (!ret)\r\nret = count;\r\nbreak;\r\ncase 0:\r\nmemset(smi_data_buf, 0, smi_data_buf_size);\r\nret = count;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&smi_data_lock);\r\nreturn ret;\r\n}\r\nstatic int host_control_smi(void)\r\n{\r\nstruct apm_cmd *apm_cmd;\r\nu8 *data;\r\nunsigned long flags;\r\nu32 num_ticks;\r\ns8 cmd_status;\r\nu8 index;\r\napm_cmd = (struct apm_cmd *)smi_data_buf;\r\napm_cmd->status = ESM_STATUS_CMD_UNSUCCESSFUL;\r\nswitch (host_control_smi_type) {\r\ncase HC_SMITYPE_TYPE1:\r\nspin_lock_irqsave(&rtc_lock, flags);\r\ndata = (u8 *)&smi_data_buf_phys_addr;\r\nfor (index = PE1300_CMOS_CMD_STRUCT_PTR;\r\nindex < (PE1300_CMOS_CMD_STRUCT_PTR + 4);\r\nindex++, data++) {\r\noutb(index,\r\n(CMOS_BASE_PORT + CMOS_PAGE2_INDEX_PORT_PIIX4));\r\noutb(*data,\r\n(CMOS_BASE_PORT + CMOS_PAGE2_DATA_PORT_PIIX4));\r\n}\r\ncmd_status = ESM_STATUS_CMD_UNSUCCESSFUL;\r\noutb((u8) cmd_status, PCAT_APM_STATUS_PORT);\r\noutb(ESM_APM_CMD, PCAT_APM_CONTROL_PORT);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\nnum_ticks = TIMEOUT_USEC_SHORT_SEMA_BLOCKING;\r\nwhile ((cmd_status = inb(PCAT_APM_STATUS_PORT))\r\n== ESM_STATUS_CMD_UNSUCCESSFUL) {\r\nnum_ticks--;\r\nif (num_ticks == EXPIRED_TIMER)\r\nreturn -ETIME;\r\n}\r\nbreak;\r\ncase HC_SMITYPE_TYPE2:\r\ncase HC_SMITYPE_TYPE3:\r\nspin_lock_irqsave(&rtc_lock, flags);\r\ndata = (u8 *)&smi_data_buf_phys_addr;\r\nfor (index = PE1400_CMOS_CMD_STRUCT_PTR;\r\nindex < (PE1400_CMOS_CMD_STRUCT_PTR + 4);\r\nindex++, data++) {\r\noutb(index, (CMOS_BASE_PORT + CMOS_PAGE1_INDEX_PORT));\r\noutb(*data, (CMOS_BASE_PORT + CMOS_PAGE1_DATA_PORT));\r\n}\r\nif (host_control_smi_type == HC_SMITYPE_TYPE3)\r\noutb(ESM_APM_CMD, PCAT_APM_CONTROL_PORT);\r\nelse\r\noutb(ESM_APM_CMD, PE1400_APM_CONTROL_PORT);\r\nCMOS_READ(RTC_REG_C);\r\nspin_unlock_irqrestore(&rtc_lock, flags);\r\ncmd_status = inb(PE1400_APM_CONTROL_PORT);\r\nnum_ticks = TIMEOUT_USEC_SHORT_SEMA_BLOCKING;\r\nwhile (apm_cmd->status == ESM_STATUS_CMD_UNSUCCESSFUL) {\r\nnum_ticks--;\r\nif (num_ticks == EXPIRED_TIMER)\r\nreturn -ETIME;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&dcdbas_pdev->dev, "%s: invalid SMI type %u\n",\r\n__func__, host_control_smi_type);\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dcdbas_host_control(void)\r\n{\r\nstruct apm_cmd *apm_cmd;\r\nu8 action;\r\nif (host_control_action == HC_ACTION_NONE)\r\nreturn;\r\naction = host_control_action;\r\nhost_control_action = HC_ACTION_NONE;\r\nif (!smi_data_buf) {\r\ndev_dbg(&dcdbas_pdev->dev, "%s: no SMI buffer\n", __func__);\r\nreturn;\r\n}\r\nif (smi_data_buf_size < sizeof(struct apm_cmd)) {\r\ndev_dbg(&dcdbas_pdev->dev, "%s: SMI buffer too small\n",\r\n__func__);\r\nreturn;\r\n}\r\napm_cmd = (struct apm_cmd *)smi_data_buf;\r\nif (action & HC_ACTION_HOST_CONTROL_POWEROFF) {\r\napm_cmd->command = ESM_APM_POWER_CYCLE;\r\napm_cmd->reserved = 0;\r\n*((s16 *)&apm_cmd->parameters.shortreq.parm[0]) = (s16) 0;\r\nhost_control_smi();\r\n} else if (action & HC_ACTION_HOST_CONTROL_POWERCYCLE) {\r\napm_cmd->command = ESM_APM_POWER_CYCLE;\r\napm_cmd->reserved = 0;\r\n*((s16 *)&apm_cmd->parameters.shortreq.parm[0]) = (s16) 20;\r\nhost_control_smi();\r\n}\r\n}\r\nstatic int dcdbas_reboot_notify(struct notifier_block *nb, unsigned long code,\r\nvoid *unused)\r\n{\r\nswitch (code) {\r\ncase SYS_DOWN:\r\ncase SYS_HALT:\r\ncase SYS_POWER_OFF:\r\nif (host_control_on_shutdown) {\r\nprintk(KERN_WARNING "Please wait for shutdown "\r\n"action to complete...\n");\r\ndcdbas_host_control();\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int dcdbas_probe(struct platform_device *dev)\r\n{\r\nint error;\r\nhost_control_action = HC_ACTION_NONE;\r\nhost_control_smi_type = HC_SMITYPE_NONE;\r\ndcdbas_pdev = dev;\r\nerror = dma_set_coherent_mask(&dcdbas_pdev->dev, DMA_BIT_MASK(32));\r\nif (error)\r\nreturn error;\r\nerror = sysfs_create_group(&dev->dev.kobj, &dcdbas_attr_group);\r\nif (error)\r\nreturn error;\r\nregister_reboot_notifier(&dcdbas_reboot_nb);\r\ndev_info(&dev->dev, "%s (version %s)\n",\r\nDRIVER_DESCRIPTION, DRIVER_VERSION);\r\nreturn 0;\r\n}\r\nstatic int dcdbas_remove(struct platform_device *dev)\r\n{\r\nunregister_reboot_notifier(&dcdbas_reboot_nb);\r\nsysfs_remove_group(&dev->dev.kobj, &dcdbas_attr_group);\r\nreturn 0;\r\n}\r\nstatic int __init dcdbas_init(void)\r\n{\r\nint error;\r\nerror = platform_driver_register(&dcdbas_driver);\r\nif (error)\r\nreturn error;\r\ndcdbas_pdev_reg = platform_device_register_full(&dcdbas_dev_info);\r\nif (IS_ERR(dcdbas_pdev_reg)) {\r\nerror = PTR_ERR(dcdbas_pdev_reg);\r\ngoto err_unregister_driver;\r\n}\r\nreturn 0;\r\nerr_unregister_driver:\r\nplatform_driver_unregister(&dcdbas_driver);\r\nreturn error;\r\n}\r\nstatic void __exit dcdbas_exit(void)\r\n{\r\nunregister_reboot_notifier(&dcdbas_reboot_nb);\r\nif (dcdbas_pdev)\r\nsmi_data_buf_free();\r\nplatform_device_unregister(dcdbas_pdev_reg);\r\nplatform_driver_unregister(&dcdbas_driver);\r\n}
