static void mlx4_free_icm_pages(struct mlx4_dev *dev, struct mlx4_icm_chunk *chunk)\r\n{\r\nint i;\r\nif (chunk->nsg > 0)\r\npci_unmap_sg(dev->persist->pdev, chunk->mem, chunk->npages,\r\nPCI_DMA_BIDIRECTIONAL);\r\nfor (i = 0; i < chunk->npages; ++i)\r\n__free_pages(sg_page(&chunk->mem[i]),\r\nget_order(chunk->mem[i].length));\r\n}\r\nstatic void mlx4_free_icm_coherent(struct mlx4_dev *dev, struct mlx4_icm_chunk *chunk)\r\n{\r\nint i;\r\nfor (i = 0; i < chunk->npages; ++i)\r\ndma_free_coherent(&dev->persist->pdev->dev,\r\nchunk->mem[i].length,\r\nlowmem_page_address(sg_page(&chunk->mem[i])),\r\nsg_dma_address(&chunk->mem[i]));\r\n}\r\nvoid mlx4_free_icm(struct mlx4_dev *dev, struct mlx4_icm *icm, int coherent)\r\n{\r\nstruct mlx4_icm_chunk *chunk, *tmp;\r\nif (!icm)\r\nreturn;\r\nlist_for_each_entry_safe(chunk, tmp, &icm->chunk_list, list) {\r\nif (coherent)\r\nmlx4_free_icm_coherent(dev, chunk);\r\nelse\r\nmlx4_free_icm_pages(dev, chunk);\r\nkfree(chunk);\r\n}\r\nkfree(icm);\r\n}\r\nstatic int mlx4_alloc_icm_pages(struct scatterlist *mem, int order,\r\ngfp_t gfp_mask, int node)\r\n{\r\nstruct page *page;\r\npage = alloc_pages_node(node, gfp_mask, order);\r\nif (!page) {\r\npage = alloc_pages(gfp_mask, order);\r\nif (!page)\r\nreturn -ENOMEM;\r\n}\r\nsg_set_page(mem, page, PAGE_SIZE << order, 0);\r\nreturn 0;\r\n}\r\nstatic int mlx4_alloc_icm_coherent(struct device *dev, struct scatterlist *mem,\r\nint order, gfp_t gfp_mask)\r\n{\r\nvoid *buf = dma_alloc_coherent(dev, PAGE_SIZE << order,\r\n&sg_dma_address(mem), gfp_mask);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (offset_in_page(buf)) {\r\ndma_free_coherent(dev, PAGE_SIZE << order,\r\nbuf, sg_dma_address(mem));\r\nreturn -ENOMEM;\r\n}\r\nsg_set_buf(mem, buf, PAGE_SIZE << order);\r\nsg_dma_len(mem) = PAGE_SIZE << order;\r\nreturn 0;\r\n}\r\nstruct mlx4_icm *mlx4_alloc_icm(struct mlx4_dev *dev, int npages,\r\ngfp_t gfp_mask, int coherent)\r\n{\r\nstruct mlx4_icm *icm;\r\nstruct mlx4_icm_chunk *chunk = NULL;\r\nint cur_order;\r\nint ret;\r\nBUG_ON(coherent && (gfp_mask & __GFP_HIGHMEM));\r\nicm = kmalloc_node(sizeof(*icm),\r\ngfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN),\r\ndev->numa_node);\r\nif (!icm) {\r\nicm = kmalloc(sizeof(*icm),\r\ngfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN));\r\nif (!icm)\r\nreturn NULL;\r\n}\r\nicm->refcount = 0;\r\nINIT_LIST_HEAD(&icm->chunk_list);\r\ncur_order = get_order(MLX4_ICM_ALLOC_SIZE);\r\nwhile (npages > 0) {\r\nif (!chunk) {\r\nchunk = kmalloc_node(sizeof(*chunk),\r\ngfp_mask & ~(__GFP_HIGHMEM |\r\n__GFP_NOWARN),\r\ndev->numa_node);\r\nif (!chunk) {\r\nchunk = kmalloc(sizeof(*chunk),\r\ngfp_mask & ~(__GFP_HIGHMEM |\r\n__GFP_NOWARN));\r\nif (!chunk)\r\ngoto fail;\r\n}\r\nsg_init_table(chunk->mem, MLX4_ICM_CHUNK_LEN);\r\nchunk->npages = 0;\r\nchunk->nsg = 0;\r\nlist_add_tail(&chunk->list, &icm->chunk_list);\r\n}\r\nwhile (1 << cur_order > npages)\r\n--cur_order;\r\nif (coherent)\r\nret = mlx4_alloc_icm_coherent(&dev->persist->pdev->dev,\r\n&chunk->mem[chunk->npages],\r\ncur_order, gfp_mask);\r\nelse\r\nret = mlx4_alloc_icm_pages(&chunk->mem[chunk->npages],\r\ncur_order, gfp_mask,\r\ndev->numa_node);\r\nif (ret) {\r\nif (--cur_order < 0)\r\ngoto fail;\r\nelse\r\ncontinue;\r\n}\r\n++chunk->npages;\r\nif (coherent)\r\n++chunk->nsg;\r\nelse if (chunk->npages == MLX4_ICM_CHUNK_LEN) {\r\nchunk->nsg = pci_map_sg(dev->persist->pdev, chunk->mem,\r\nchunk->npages,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (chunk->nsg <= 0)\r\ngoto fail;\r\n}\r\nif (chunk->npages == MLX4_ICM_CHUNK_LEN)\r\nchunk = NULL;\r\nnpages -= 1 << cur_order;\r\n}\r\nif (!coherent && chunk) {\r\nchunk->nsg = pci_map_sg(dev->persist->pdev, chunk->mem,\r\nchunk->npages,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (chunk->nsg <= 0)\r\ngoto fail;\r\n}\r\nreturn icm;\r\nfail:\r\nmlx4_free_icm(dev, icm, coherent);\r\nreturn NULL;\r\n}\r\nstatic int mlx4_MAP_ICM(struct mlx4_dev *dev, struct mlx4_icm *icm, u64 virt)\r\n{\r\nreturn mlx4_map_cmd(dev, MLX4_CMD_MAP_ICM, icm, virt);\r\n}\r\nstatic int mlx4_UNMAP_ICM(struct mlx4_dev *dev, u64 virt, u32 page_count)\r\n{\r\nreturn mlx4_cmd(dev, virt, page_count, 0, MLX4_CMD_UNMAP_ICM,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\n}\r\nint mlx4_MAP_ICM_AUX(struct mlx4_dev *dev, struct mlx4_icm *icm)\r\n{\r\nreturn mlx4_map_cmd(dev, MLX4_CMD_MAP_ICM_AUX, icm, -1);\r\n}\r\nint mlx4_UNMAP_ICM_AUX(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_UNMAP_ICM_AUX,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\n}\r\nint mlx4_table_get(struct mlx4_dev *dev, struct mlx4_icm_table *table, u32 obj,\r\ngfp_t gfp)\r\n{\r\nu32 i = (obj & (table->num_obj - 1)) /\r\n(MLX4_TABLE_CHUNK_SIZE / table->obj_size);\r\nint ret = 0;\r\nmutex_lock(&table->mutex);\r\nif (table->icm[i]) {\r\n++table->icm[i]->refcount;\r\ngoto out;\r\n}\r\ntable->icm[i] = mlx4_alloc_icm(dev, MLX4_TABLE_CHUNK_SIZE >> PAGE_SHIFT,\r\n(table->lowmem ? gfp : GFP_HIGHUSER) |\r\n__GFP_NOWARN, table->coherent);\r\nif (!table->icm[i]) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (mlx4_MAP_ICM(dev, table->icm[i], table->virt +\r\n(u64) i * MLX4_TABLE_CHUNK_SIZE)) {\r\nmlx4_free_icm(dev, table->icm[i], table->coherent);\r\ntable->icm[i] = NULL;\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n++table->icm[i]->refcount;\r\nout:\r\nmutex_unlock(&table->mutex);\r\nreturn ret;\r\n}\r\nvoid mlx4_table_put(struct mlx4_dev *dev, struct mlx4_icm_table *table, u32 obj)\r\n{\r\nu32 i;\r\nu64 offset;\r\ni = (obj & (table->num_obj - 1)) / (MLX4_TABLE_CHUNK_SIZE / table->obj_size);\r\nmutex_lock(&table->mutex);\r\nif (--table->icm[i]->refcount == 0) {\r\noffset = (u64) i * MLX4_TABLE_CHUNK_SIZE;\r\nmlx4_UNMAP_ICM(dev, table->virt + offset,\r\nMLX4_TABLE_CHUNK_SIZE / MLX4_ICM_PAGE_SIZE);\r\nmlx4_free_icm(dev, table->icm[i], table->coherent);\r\ntable->icm[i] = NULL;\r\n}\r\nmutex_unlock(&table->mutex);\r\n}\r\nvoid *mlx4_table_find(struct mlx4_icm_table *table, u32 obj,\r\ndma_addr_t *dma_handle)\r\n{\r\nint offset, dma_offset, i;\r\nu64 idx;\r\nstruct mlx4_icm_chunk *chunk;\r\nstruct mlx4_icm *icm;\r\nstruct page *page = NULL;\r\nif (!table->lowmem)\r\nreturn NULL;\r\nmutex_lock(&table->mutex);\r\nidx = (u64) (obj & (table->num_obj - 1)) * table->obj_size;\r\nicm = table->icm[idx / MLX4_TABLE_CHUNK_SIZE];\r\ndma_offset = offset = idx % MLX4_TABLE_CHUNK_SIZE;\r\nif (!icm)\r\ngoto out;\r\nlist_for_each_entry(chunk, &icm->chunk_list, list) {\r\nfor (i = 0; i < chunk->npages; ++i) {\r\nif (dma_handle && dma_offset >= 0) {\r\nif (sg_dma_len(&chunk->mem[i]) > dma_offset)\r\n*dma_handle = sg_dma_address(&chunk->mem[i]) +\r\ndma_offset;\r\ndma_offset -= sg_dma_len(&chunk->mem[i]);\r\n}\r\nif (chunk->mem[i].length > offset) {\r\npage = sg_page(&chunk->mem[i]);\r\ngoto out;\r\n}\r\noffset -= chunk->mem[i].length;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&table->mutex);\r\nreturn page ? lowmem_page_address(page) + offset : NULL;\r\n}\r\nint mlx4_table_get_range(struct mlx4_dev *dev, struct mlx4_icm_table *table,\r\nu32 start, u32 end)\r\n{\r\nint inc = MLX4_TABLE_CHUNK_SIZE / table->obj_size;\r\nint err;\r\nu32 i;\r\nfor (i = start; i <= end; i += inc) {\r\nerr = mlx4_table_get(dev, table, i, GFP_KERNEL);\r\nif (err)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nwhile (i > start) {\r\ni -= inc;\r\nmlx4_table_put(dev, table, i);\r\n}\r\nreturn err;\r\n}\r\nvoid mlx4_table_put_range(struct mlx4_dev *dev, struct mlx4_icm_table *table,\r\nu32 start, u32 end)\r\n{\r\nu32 i;\r\nfor (i = start; i <= end; i += MLX4_TABLE_CHUNK_SIZE / table->obj_size)\r\nmlx4_table_put(dev, table, i);\r\n}\r\nint mlx4_init_icm_table(struct mlx4_dev *dev, struct mlx4_icm_table *table,\r\nu64 virt, int obj_size, u32 nobj, int reserved,\r\nint use_lowmem, int use_coherent)\r\n{\r\nint obj_per_chunk;\r\nint num_icm;\r\nunsigned chunk_size;\r\nint i;\r\nu64 size;\r\nobj_per_chunk = MLX4_TABLE_CHUNK_SIZE / obj_size;\r\nnum_icm = (nobj + obj_per_chunk - 1) / obj_per_chunk;\r\ntable->icm = kcalloc(num_icm, sizeof *table->icm, GFP_KERNEL);\r\nif (!table->icm)\r\nreturn -ENOMEM;\r\ntable->virt = virt;\r\ntable->num_icm = num_icm;\r\ntable->num_obj = nobj;\r\ntable->obj_size = obj_size;\r\ntable->lowmem = use_lowmem;\r\ntable->coherent = use_coherent;\r\nmutex_init(&table->mutex);\r\nsize = (u64) nobj * obj_size;\r\nfor (i = 0; i * MLX4_TABLE_CHUNK_SIZE < reserved * obj_size; ++i) {\r\nchunk_size = MLX4_TABLE_CHUNK_SIZE;\r\nif ((i + 1) * MLX4_TABLE_CHUNK_SIZE > size)\r\nchunk_size = PAGE_ALIGN(size -\r\ni * MLX4_TABLE_CHUNK_SIZE);\r\ntable->icm[i] = mlx4_alloc_icm(dev, chunk_size >> PAGE_SHIFT,\r\n(use_lowmem ? GFP_KERNEL : GFP_HIGHUSER) |\r\n__GFP_NOWARN, use_coherent);\r\nif (!table->icm[i])\r\ngoto err;\r\nif (mlx4_MAP_ICM(dev, table->icm[i], virt + i * MLX4_TABLE_CHUNK_SIZE)) {\r\nmlx4_free_icm(dev, table->icm[i], use_coherent);\r\ntable->icm[i] = NULL;\r\ngoto err;\r\n}\r\n++table->icm[i]->refcount;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < num_icm; ++i)\r\nif (table->icm[i]) {\r\nmlx4_UNMAP_ICM(dev, virt + i * MLX4_TABLE_CHUNK_SIZE,\r\nMLX4_TABLE_CHUNK_SIZE / MLX4_ICM_PAGE_SIZE);\r\nmlx4_free_icm(dev, table->icm[i], use_coherent);\r\n}\r\nkfree(table->icm);\r\nreturn -ENOMEM;\r\n}\r\nvoid mlx4_cleanup_icm_table(struct mlx4_dev *dev, struct mlx4_icm_table *table)\r\n{\r\nint i;\r\nfor (i = 0; i < table->num_icm; ++i)\r\nif (table->icm[i]) {\r\nmlx4_UNMAP_ICM(dev, table->virt + i * MLX4_TABLE_CHUNK_SIZE,\r\nMLX4_TABLE_CHUNK_SIZE / MLX4_ICM_PAGE_SIZE);\r\nmlx4_free_icm(dev, table->icm[i], table->coherent);\r\n}\r\nkfree(table->icm);\r\n}
