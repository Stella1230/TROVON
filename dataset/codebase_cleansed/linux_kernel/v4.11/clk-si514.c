static int si514_enable_output(struct clk_si514 *data, bool enable)\r\n{\r\nreturn regmap_update_bits(data->regmap, SI514_REG_CONTROL,\r\nSI514_CONTROL_OE, enable ? SI514_CONTROL_OE : 0);\r\n}\r\nstatic int si514_get_muldiv(struct clk_si514 *data,\r\nstruct clk_si514_muldiv *settings)\r\n{\r\nint err;\r\nu8 reg[7];\r\nerr = regmap_bulk_read(data->regmap, SI514_REG_M_FRAC1,\r\nreg, ARRAY_SIZE(reg));\r\nif (err)\r\nreturn err;\r\nsettings->m_frac = reg[0] | reg[1] << 8 | reg[2] << 16 |\r\n(reg[3] & 0x1F) << 24;\r\nsettings->m_int = (reg[4] & 0x3f) << 3 | reg[3] >> 5;\r\nsettings->ls_div_bits = (reg[6] >> 4) & 0x07;\r\nsettings->hs_div = (reg[6] & 0x03) << 8 | reg[5];\r\nreturn 0;\r\n}\r\nstatic int si514_set_muldiv(struct clk_si514 *data,\r\nstruct clk_si514_muldiv *settings)\r\n{\r\nu8 lp;\r\nu8 reg[7];\r\nint err;\r\nif (settings->m_int < 65 ||\r\n(settings->m_int == 65 && settings->m_frac <= 139575831))\r\nlp = 0x22;\r\nelse if (settings->m_int < 67 ||\r\n(settings->m_int == 67 && settings->m_frac <= 461581994))\r\nlp = 0x23;\r\nelse if (settings->m_int < 72 ||\r\n(settings->m_int == 72 && settings->m_frac <= 503383578))\r\nlp = 0x33;\r\nelse if (settings->m_int < 75 ||\r\n(settings->m_int == 75 && settings->m_frac <= 452724474))\r\nlp = 0x34;\r\nelse\r\nlp = 0x44;\r\nerr = regmap_write(data->regmap, SI514_REG_LP, lp);\r\nif (err < 0)\r\nreturn err;\r\nreg[0] = settings->m_frac;\r\nreg[1] = settings->m_frac >> 8;\r\nreg[2] = settings->m_frac >> 16;\r\nreg[3] = settings->m_frac >> 24 | settings->m_int << 5;\r\nreg[4] = settings->m_int >> 3;\r\nreg[5] = settings->hs_div;\r\nreg[6] = (settings->hs_div >> 8) | (settings->ls_div_bits << 4);\r\nerr = regmap_bulk_write(data->regmap, SI514_REG_HS_DIV, reg + 5, 2);\r\nif (err < 0)\r\nreturn err;\r\nreturn regmap_bulk_write(data->regmap, SI514_REG_M_FRAC1, reg, 5);\r\n}\r\nstatic int si514_calc_muldiv(struct clk_si514_muldiv *settings,\r\nunsigned long frequency)\r\n{\r\nu64 m;\r\nu32 ls_freq;\r\nu32 tmp;\r\nu8 res;\r\nif ((frequency < SI514_MIN_FREQ) || (frequency > SI514_MAX_FREQ))\r\nreturn -EINVAL;\r\nls_freq = frequency;\r\nif (frequency >= (FVCO_MIN / HS_DIV_MAX))\r\nsettings->ls_div_bits = 0;\r\nelse {\r\nres = 1;\r\ntmp = 2 * HS_DIV_MAX;\r\nwhile (tmp <= (HS_DIV_MAX * 32)) {\r\nif ((frequency * tmp) >= FVCO_MIN)\r\nbreak;\r\n++res;\r\ntmp <<= 1;\r\n}\r\nsettings->ls_div_bits = res;\r\nls_freq = frequency << res;\r\n}\r\nsettings->hs_div = DIV_ROUND_UP(FVCO_MIN >> 1, ls_freq) << 1;\r\nm = ((u64)(ls_freq * settings->hs_div) << 29) + (FXO / 2);\r\ndo_div(m, FXO);\r\nsettings->m_frac = (u32)m & (BIT(29) - 1);\r\nsettings->m_int = (u32)(m >> 29);\r\nreturn 0;\r\n}\r\nstatic unsigned long si514_calc_rate(struct clk_si514_muldiv *settings)\r\n{\r\nu64 m = settings->m_frac | ((u64)settings->m_int << 29);\r\nu32 d = settings->hs_div * BIT(settings->ls_div_bits);\r\nreturn ((u32)(((m * FXO) + (FXO / 2)) >> 29)) / d;\r\n}\r\nstatic unsigned long si514_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_si514 *data = to_clk_si514(hw);\r\nstruct clk_si514_muldiv settings;\r\nint err;\r\nerr = si514_get_muldiv(data, &settings);\r\nif (err) {\r\ndev_err(&data->i2c_client->dev, "unable to retrieve settings\n");\r\nreturn 0;\r\n}\r\nreturn si514_calc_rate(&settings);\r\n}\r\nstatic long si514_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct clk_si514_muldiv settings;\r\nint err;\r\nif (!rate)\r\nreturn 0;\r\nerr = si514_calc_muldiv(&settings, rate);\r\nif (err)\r\nreturn err;\r\nreturn si514_calc_rate(&settings);\r\n}\r\nstatic int si514_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_si514 *data = to_clk_si514(hw);\r\nstruct clk_si514_muldiv settings;\r\nint err;\r\nerr = si514_calc_muldiv(&settings, rate);\r\nif (err)\r\nreturn err;\r\nsi514_enable_output(data, false);\r\nerr = si514_set_muldiv(data, &settings);\r\nif (err < 0)\r\nreturn err;\r\nerr = regmap_write(data->regmap, SI514_REG_CONTROL, SI514_CONTROL_FCAL);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(10000, 12000);\r\nsi514_enable_output(data, true);\r\nreturn err;\r\n}\r\nstatic bool si514_regmap_is_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SI514_REG_CONTROL:\r\ncase SI514_REG_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool si514_regmap_is_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase SI514_REG_LP:\r\ncase SI514_REG_M_FRAC1 ... SI514_REG_LS_HS_DIV:\r\ncase SI514_REG_OE_STATE:\r\ncase SI514_REG_RESET:\r\ncase SI514_REG_CONTROL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int si514_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct clk_si514 *data;\r\nstruct clk_init_data init;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninit.ops = &si514_clk_ops;\r\ninit.flags = 0;\r\ninit.num_parents = 0;\r\ndata->hw.init = &init;\r\ndata->i2c_client = client;\r\nif (of_property_read_string(client->dev.of_node, "clock-output-names",\r\n&init.name))\r\ninit.name = client->dev.of_node->name;\r\ndata->regmap = devm_regmap_init_i2c(client, &si514_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nreturn PTR_ERR(data->regmap);\r\n}\r\ni2c_set_clientdata(client, data);\r\nerr = devm_clk_hw_register(&client->dev, &data->hw);\r\nif (err) {\r\ndev_err(&client->dev, "clock registration failed\n");\r\nreturn err;\r\n}\r\nerr = of_clk_add_hw_provider(client->dev.of_node, of_clk_hw_simple_get,\r\n&data->hw);\r\nif (err) {\r\ndev_err(&client->dev, "unable to add clk provider\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si514_remove(struct i2c_client *client)\r\n{\r\nof_clk_del_provider(client->dev.of_node);\r\nreturn 0;\r\n}
