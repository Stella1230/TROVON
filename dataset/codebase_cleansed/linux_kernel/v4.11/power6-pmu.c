static int power6_marked_instr_event(u64 event)\r\n{\r\nint pmc, psel, ptype;\r\nint bit, byte, unit;\r\nu32 mask;\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\npsel = (event & PM_PMCSEL_MSK) >> 1;\r\nif (pmc >= 5)\r\nreturn 0;\r\nbit = -1;\r\nif (psel < sizeof(direct_event_is_marked)) {\r\nptype = direct_event_is_marked[psel];\r\nif (pmc == 0 || !(ptype & (1 << (pmc - 1))))\r\nreturn 0;\r\nptype >>= 4;\r\nif (ptype == 0)\r\nreturn 1;\r\nif (ptype == 1)\r\nbit = 0;\r\nelse\r\nbit = ptype ^ (pmc - 1);\r\n} else if ((psel & 0x48) == 0x40)\r\nbit = psel & 7;\r\nif (!(event & PM_BUSEVENT_MSK) || bit == -1)\r\nreturn 0;\r\nbyte = (event >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nunit = (event >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nmask = marked_bus_events[unit];\r\nreturn (mask >> (byte * 8 + bit)) & 1;\r\n}\r\nstatic int p6_compute_mmcr(u64 event[], int n_ev,\r\nunsigned int hwc[], unsigned long mmcr[], struct perf_event *pevents[])\r\n{\r\nunsigned long mmcr1 = 0;\r\nunsigned long mmcra = MMCRA_SDAR_DCACHE_MISS | MMCRA_SDAR_ERAT_MISS;\r\nint i;\r\nunsigned int pmc, ev, b, u, s, psel;\r\nunsigned int ttmset = 0;\r\nunsigned int pmc_inuse = 0;\r\nif (n_ev > 6)\r\nreturn -1;\r\nfor (i = 0; i < n_ev; ++i) {\r\npmc = (event[i] >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc) {\r\nif (pmc_inuse & (1 << (pmc - 1)))\r\nreturn -1;\r\npmc_inuse |= 1 << (pmc - 1);\r\n}\r\n}\r\nfor (i = 0; i < n_ev; ++i) {\r\nev = event[i];\r\npmc = (ev >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc) {\r\n--pmc;\r\n} else {\r\nfor (pmc = 0; pmc < 4; ++pmc)\r\nif (!(pmc_inuse & (1 << pmc)))\r\nbreak;\r\nif (pmc >= 4)\r\nreturn -1;\r\npmc_inuse |= 1 << pmc;\r\n}\r\nhwc[i] = pmc;\r\npsel = ev & PM_PMCSEL_MSK;\r\nif (ev & PM_BUSEVENT_MSK) {\r\nb = (ev >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nu = (ev >> PM_UNIT_SH) & PM_UNIT_MSK;\r\nif ((ttmset & (1 << b)) && MMCR1_TTMSEL(mmcr1, b) != u)\r\nreturn -1;\r\nmmcr1 |= (unsigned long)u << MMCR1_TTMSEL_SH(b);\r\nttmset |= 1 << b;\r\nif (u == 5) {\r\ns = (ev >> PM_SUBUNIT_SH) & PM_SUBUNIT_MSK;\r\nif ((ttmset & 0x10) &&\r\nMMCR1_NESTSEL(mmcr1) != s)\r\nreturn -1;\r\nttmset |= 0x10;\r\nmmcr1 |= (unsigned long)s << MMCR1_NESTSEL_SH;\r\n}\r\nif (0x30 <= psel && psel <= 0x3d) {\r\nif (b >= 2)\r\nmmcr1 |= MMCR1_PMC1_ADDR_SEL >> pmc;\r\n}\r\nif (pmc >= 2 && (psel & 0x90) == 0x80)\r\npsel ^= 0x20;\r\n}\r\nif (ev & PM_LLA) {\r\nmmcr1 |= MMCR1_PMC1_LLA >> pmc;\r\nif (ev & PM_LLAV)\r\nmmcr1 |= MMCR1_PMC1_LLA_VALUE >> pmc;\r\n}\r\nif (power6_marked_instr_event(event[i]))\r\nmmcra |= MMCRA_SAMPLE_ENABLE;\r\nif (pmc < 4)\r\nmmcr1 |= (unsigned long)psel << MMCR1_PMCSEL_SH(pmc);\r\n}\r\nmmcr[0] = 0;\r\nif (pmc_inuse & 1)\r\nmmcr[0] = MMCR0_PMC1CE;\r\nif (pmc_inuse & 0xe)\r\nmmcr[0] |= MMCR0_PMCjCE;\r\nmmcr[1] = mmcr1;\r\nmmcr[2] = mmcra;\r\nreturn 0;\r\n}\r\nstatic int p6_get_constraint(u64 event, unsigned long *maskp,\r\nunsigned long *valp)\r\n{\r\nint pmc, byte, sh, subunit;\r\nunsigned long mask = 0, value = 0;\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc) {\r\nif (pmc > 4 && !(event == 0x500009 || event == 0x600005))\r\nreturn -1;\r\nsh = (pmc - 1) * 2;\r\nmask |= 2 << sh;\r\nvalue |= 1 << sh;\r\n}\r\nif (event & PM_BUSEVENT_MSK) {\r\nbyte = (event >> PM_BYTE_SH) & PM_BYTE_MSK;\r\nsh = byte * 4 + (16 - PM_UNIT_SH);\r\nmask |= PM_UNIT_MSKS << sh;\r\nvalue |= (unsigned long)(event & PM_UNIT_MSKS) << sh;\r\nif ((event & PM_UNIT_MSKS) == (5 << PM_UNIT_SH)) {\r\nsubunit = (event >> PM_SUBUNIT_SH) & PM_SUBUNIT_MSK;\r\nmask |= (unsigned long)PM_SUBUNIT_MSK << 32;\r\nvalue |= (unsigned long)subunit << 32;\r\n}\r\n}\r\nif (pmc <= 4) {\r\nmask |= 0x8000;\r\nvalue |= 0x1000;\r\n}\r\n*maskp = mask;\r\n*valp = value;\r\nreturn 0;\r\n}\r\nstatic int p6_limited_pmc_event(u64 event)\r\n{\r\nint pmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nreturn pmc == 5 || pmc == 6;\r\n}\r\nstatic int find_alternatives_list(u64 event)\r\n{\r\nint i, j;\r\nunsigned int alt;\r\nfor (i = 0; i < ARRAY_SIZE(event_alternatives); ++i) {\r\nif (event < event_alternatives[i][0])\r\nreturn -1;\r\nfor (j = 0; j < MAX_ALT; ++j) {\r\nalt = event_alternatives[i][j];\r\nif (!alt || event < alt)\r\nbreak;\r\nif (event == alt)\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int p6_get_alternatives(u64 event, unsigned int flags, u64 alt[])\r\n{\r\nint i, j, nlim;\r\nunsigned int psel, pmc;\r\nunsigned int nalt = 1;\r\nu64 aevent;\r\nalt[0] = event;\r\nnlim = p6_limited_pmc_event(event);\r\ni = find_alternatives_list(event);\r\nif (i >= 0) {\r\nfor (j = 0; j < MAX_ALT; ++j) {\r\naevent = event_alternatives[i][j];\r\nif (!aevent)\r\nbreak;\r\nif (aevent != event)\r\nalt[nalt++] = aevent;\r\nnlim += p6_limited_pmc_event(aevent);\r\n}\r\n} else {\r\npsel = event & (PM_PMCSEL_MSK & ~1);\r\npmc = (event >> PM_PMC_SH) & PM_PMC_MSK;\r\nif (pmc && (psel == 0x32 || psel == 0x34))\r\nalt[nalt++] = ((event ^ 0x6) & ~PM_PMC_MSKS) |\r\n((5 - pmc) << PM_PMC_SH);\r\nif (pmc && (psel == 0x38 || psel == 0x3a))\r\nalt[nalt++] = ((event ^ 0x2) & ~PM_PMC_MSKS) |\r\n((pmc > 2? pmc - 2: pmc + 2) << PM_PMC_SH);\r\n}\r\nif (flags & PPMU_ONLY_COUNT_RUN) {\r\nj = nalt;\r\nfor (i = 0; i < nalt; ++i) {\r\nswitch (alt[i]) {\r\ncase 0x1e:\r\nalt[j++] = 0x600005;\r\n++nlim;\r\nbreak;\r\ncase 0x10000a:\r\nalt[j++] = 0x1e;\r\nbreak;\r\ncase 2:\r\nalt[j++] = 0x500009;\r\n++nlim;\r\nbreak;\r\ncase 0x500009:\r\nalt[j++] = 2;\r\nbreak;\r\ncase 0x10000e:\r\nalt[j++] = 0x4000f4;\r\nbreak;\r\ncase 0x4000f4:\r\nalt[j++] = 0x10000e;\r\nbreak;\r\n}\r\n}\r\nnalt = j;\r\n}\r\nif (!(flags & PPMU_LIMITED_PMC_OK) && nlim) {\r\nj = 0;\r\nfor (i = 0; i < nalt; ++i) {\r\nif (!p6_limited_pmc_event(alt[i])) {\r\nalt[j] = alt[i];\r\n++j;\r\n}\r\n}\r\nnalt = j;\r\n} else if ((flags & PPMU_LIMITED_PMC_REQD) && nlim < nalt) {\r\nj = 0;\r\nfor (i = 0; i < nalt; ++i) {\r\nif (p6_limited_pmc_event(alt[i])) {\r\nalt[j] = alt[i];\r\n++j;\r\n}\r\n}\r\nnalt = j;\r\n}\r\nreturn nalt;\r\n}\r\nstatic void p6_disable_pmc(unsigned int pmc, unsigned long mmcr[])\r\n{\r\nif (pmc <= 3)\r\nmmcr[1] &= ~(0xffUL << MMCR1_PMCSEL_SH(pmc));\r\n}\r\nstatic int __init init_power6_pmu(void)\r\n{\r\nif (!cur_cpu_spec->oprofile_cpu_type ||\r\nstrcmp(cur_cpu_spec->oprofile_cpu_type, "ppc64/power6"))\r\nreturn -ENODEV;\r\nreturn register_power_pmu(&power6_pmu);\r\n}
