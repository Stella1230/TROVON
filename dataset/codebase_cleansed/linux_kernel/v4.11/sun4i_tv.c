static inline struct sun4i_tv *\r\ndrm_encoder_to_sun4i_tv(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct sun4i_tv,\r\nencoder);\r\n}\r\nstatic inline struct sun4i_tv *\r\ndrm_connector_to_sun4i_tv(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct sun4i_tv,\r\nconnector);\r\n}\r\nstatic const struct tv_mode *sun4i_tv_find_tv_by_mode(const struct drm_display_mode *mode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\r\nconst struct tv_mode *tv_mode = &tv_modes[i];\r\nDRM_DEBUG_DRIVER("Comparing mode %s vs %s",\r\nmode->name, tv_mode->name);\r\nif (!strcmp(mode->name, tv_mode->name))\r\nreturn tv_mode;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\r\nconst struct tv_mode *tv_mode = &tv_modes[i];\r\nDRM_DEBUG_DRIVER("Comparing mode %s vs %s (X: %d vs %d)",\r\nmode->name, tv_mode->name,\r\nmode->vdisplay, tv_mode->vdisplay);\r\nif (mode->vdisplay == tv_mode->vdisplay)\r\nreturn tv_mode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sun4i_tv_mode_to_drm_mode(const struct tv_mode *tv_mode,\r\nstruct drm_display_mode *mode)\r\n{\r\nDRM_DEBUG_DRIVER("Creating mode %s\n", mode->name);\r\nmode->type = DRM_MODE_TYPE_DRIVER;\r\nmode->clock = 13500;\r\nmode->flags = DRM_MODE_FLAG_INTERLACE;\r\nmode->hdisplay = tv_mode->hdisplay;\r\nmode->hsync_start = mode->hdisplay + tv_mode->hfront_porch;\r\nmode->hsync_end = mode->hsync_start + tv_mode->hsync_len;\r\nmode->htotal = mode->hsync_end + tv_mode->hback_porch;\r\nmode->vdisplay = tv_mode->vdisplay;\r\nmode->vsync_start = mode->vdisplay + tv_mode->vfront_porch;\r\nmode->vsync_end = mode->vsync_start + tv_mode->vsync_len;\r\nmode->vtotal = mode->vsync_end + tv_mode->vback_porch;\r\n}\r\nstatic int sun4i_tv_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sun4i_tv_disable(struct drm_encoder *encoder)\r\n{\r\nstruct sun4i_tv *tv = drm_encoder_to_sun4i_tv(encoder);\r\nstruct sun4i_drv *drv = tv->drv;\r\nstruct sun4i_tcon *tcon = drv->tcon;\r\nDRM_DEBUG_DRIVER("Disabling the TV Output\n");\r\nsun4i_tcon_channel_disable(tcon, 1);\r\nregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\r\nSUN4I_TVE_EN_ENABLE,\r\n0);\r\nsun4i_backend_disable_color_correction(drv->backend);\r\n}\r\nstatic void sun4i_tv_enable(struct drm_encoder *encoder)\r\n{\r\nstruct sun4i_tv *tv = drm_encoder_to_sun4i_tv(encoder);\r\nstruct sun4i_drv *drv = tv->drv;\r\nstruct sun4i_tcon *tcon = drv->tcon;\r\nDRM_DEBUG_DRIVER("Enabling the TV Output\n");\r\nsun4i_backend_apply_color_correction(drv->backend);\r\nregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\r\nSUN4I_TVE_EN_ENABLE,\r\nSUN4I_TVE_EN_ENABLE);\r\nsun4i_tcon_channel_enable(tcon, 1);\r\n}\r\nstatic void sun4i_tv_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sun4i_tv *tv = drm_encoder_to_sun4i_tv(encoder);\r\nstruct sun4i_drv *drv = tv->drv;\r\nstruct sun4i_tcon *tcon = drv->tcon;\r\nconst struct tv_mode *tv_mode = sun4i_tv_find_tv_by_mode(mode);\r\nsun4i_tcon1_mode_set(tcon, mode);\r\nregmap_update_bits(tv->regs, SUN4I_TVE_EN_REG,\r\nSUN4I_TVE_EN_DAC_MAP_MASK,\r\nSUN4I_TVE_EN_DAC_MAP(0, 1) |\r\nSUN4I_TVE_EN_DAC_MAP(1, 2) |\r\nSUN4I_TVE_EN_DAC_MAP(2, 3) |\r\nSUN4I_TVE_EN_DAC_MAP(3, 4));\r\nregmap_write(tv->regs, SUN4I_TVE_CFG0_REG,\r\ntv_mode->mode |\r\n(tv_mode->yc_en ? SUN4I_TVE_CFG0_YC_EN : 0) |\r\nSUN4I_TVE_CFG0_COMP_EN |\r\nSUN4I_TVE_CFG0_DAC_CONTROL_54M |\r\nSUN4I_TVE_CFG0_CORE_DATAPATH_54M |\r\nSUN4I_TVE_CFG0_CORE_CONTROL_54M);\r\nregmap_write(tv->regs, SUN4I_TVE_DAC0_REG,\r\nSUN4I_TVE_DAC0_DAC_EN(0) |\r\n(tv_mode->dac3_en ? SUN4I_TVE_DAC0_DAC_EN(3) : 0) |\r\nSUN4I_TVE_DAC0_INTERNAL_DAC_37_5_OHMS |\r\nSUN4I_TVE_DAC0_CHROMA_0_75 |\r\nSUN4I_TVE_DAC0_LUMA_0_4 |\r\nSUN4I_TVE_DAC0_CLOCK_INVERT |\r\n(tv_mode->dac_bit25_en ? BIT(25) : 0) |\r\nBIT(30));\r\nregmap_write(tv->regs, SUN4I_TVE_NOTCH_REG,\r\nSUN4I_TVE_NOTCH_DAC0_TO_DAC_DLY(1, 0) |\r\nSUN4I_TVE_NOTCH_DAC0_TO_DAC_DLY(2, 0));\r\nregmap_write(tv->regs, SUN4I_TVE_CHROMA_FREQ_REG,\r\ntv_mode->chroma_freq);\r\nregmap_write(tv->regs, SUN4I_TVE_PORCH_REG,\r\nSUN4I_TVE_PORCH_BACK(tv_mode->back_porch) |\r\nSUN4I_TVE_PORCH_FRONT(tv_mode->front_porch));\r\nregmap_write(tv->regs, SUN4I_TVE_LINE_REG,\r\nSUN4I_TVE_LINE_FIRST(22) |\r\nSUN4I_TVE_LINE_NUMBER(tv_mode->line_number));\r\nregmap_write(tv->regs, SUN4I_TVE_LEVEL_REG,\r\nSUN4I_TVE_LEVEL_BLANK(tv_mode->video_levels->blank) |\r\nSUN4I_TVE_LEVEL_BLACK(tv_mode->video_levels->black));\r\nregmap_write(tv->regs, SUN4I_TVE_DAC1_REG,\r\nSUN4I_TVE_DAC1_AMPLITUDE(0, 0x18) |\r\nSUN4I_TVE_DAC1_AMPLITUDE(1, 0x18) |\r\nSUN4I_TVE_DAC1_AMPLITUDE(2, 0x18) |\r\nSUN4I_TVE_DAC1_AMPLITUDE(3, 0x18));\r\nregmap_write(tv->regs, SUN4I_TVE_CB_CR_LVL_REG,\r\nSUN4I_TVE_CB_CR_LVL_CB_BURST(tv_mode->burst_levels->cb) |\r\nSUN4I_TVE_CB_CR_LVL_CR_BURST(tv_mode->burst_levels->cr));\r\nregmap_write(tv->regs, SUN4I_TVE_BURST_WIDTH_REG,\r\nSUN4I_TVE_BURST_WIDTH_HSYNC_WIDTH(126) |\r\nSUN4I_TVE_BURST_WIDTH_BURST_WIDTH(68) |\r\nSUN4I_TVE_BURST_WIDTH_BREEZEWAY(22));\r\nregmap_write(tv->regs, SUN4I_TVE_CB_CR_GAIN_REG,\r\nSUN4I_TVE_CB_CR_GAIN_CB(tv_mode->color_gains->cb) |\r\nSUN4I_TVE_CB_CR_GAIN_CR(tv_mode->color_gains->cr));\r\nregmap_write(tv->regs, SUN4I_TVE_SYNC_VBI_REG,\r\nSUN4I_TVE_SYNC_VBI_SYNC(0x10) |\r\nSUN4I_TVE_SYNC_VBI_VBLANK(tv_mode->vblank_level));\r\nregmap_write(tv->regs, SUN4I_TVE_ACTIVE_LINE_REG,\r\nSUN4I_TVE_ACTIVE_LINE(1440));\r\nregmap_write(tv->regs, SUN4I_TVE_CHROMA_REG,\r\nSUN4I_TVE_CHROMA_COMP_GAIN_50);\r\nregmap_write(tv->regs, SUN4I_TVE_12C_REG,\r\nSUN4I_TVE_12C_COMP_YUV_EN |\r\nSUN4I_TVE_12C_NOTCH_WIDTH_WIDE);\r\nregmap_write(tv->regs, SUN4I_TVE_RESYNC_REG,\r\nSUN4I_TVE_RESYNC_PIXEL(tv_mode->resync_params->pixel) |\r\nSUN4I_TVE_RESYNC_LINE(tv_mode->resync_params->line) |\r\n(tv_mode->resync_params->field ?\r\nSUN4I_TVE_RESYNC_FIELD : 0));\r\nregmap_write(tv->regs, SUN4I_TVE_SLAVE_REG, 0);\r\nclk_set_rate(tcon->sclk1, mode->crtc_clock * 1000);\r\n}\r\nstatic void sun4i_tv_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic int sun4i_tv_comp_get_modes(struct drm_connector *connector)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tv_modes); i++) {\r\nstruct drm_display_mode *mode;\r\nconst struct tv_mode *tv_mode = &tv_modes[i];\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("Failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\nstrcpy(mode->name, tv_mode->name);\r\nsun4i_tv_mode_to_drm_mode(tv_mode, mode);\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nreturn i;\r\n}\r\nstatic int sun4i_tv_comp_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void\r\nsun4i_tv_comp_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int sun4i_tv_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct sun4i_drv *drv = drm->dev_private;\r\nstruct sun4i_tv *tv;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint ret;\r\ntv = devm_kzalloc(dev, sizeof(*tv), GFP_KERNEL);\r\nif (!tv)\r\nreturn -ENOMEM;\r\ntv->drv = drv;\r\ndev_set_drvdata(dev, tv);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(regs)) {\r\ndev_err(dev, "Couldn't map the TV encoder registers\n");\r\nreturn PTR_ERR(regs);\r\n}\r\ntv->regs = devm_regmap_init_mmio(dev, regs,\r\n&sun4i_tv_regmap_config);\r\nif (IS_ERR(tv->regs)) {\r\ndev_err(dev, "Couldn't create the TV encoder regmap\n");\r\nreturn PTR_ERR(tv->regs);\r\n}\r\ntv->reset = devm_reset_control_get(dev, NULL);\r\nif (IS_ERR(tv->reset)) {\r\ndev_err(dev, "Couldn't get our reset line\n");\r\nreturn PTR_ERR(tv->reset);\r\n}\r\nret = reset_control_deassert(tv->reset);\r\nif (ret) {\r\ndev_err(dev, "Couldn't deassert our reset line\n");\r\nreturn ret;\r\n}\r\ntv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(tv->clk)) {\r\ndev_err(dev, "Couldn't get the TV encoder clock\n");\r\nret = PTR_ERR(tv->clk);\r\ngoto err_assert_reset;\r\n}\r\nclk_prepare_enable(tv->clk);\r\ndrm_encoder_helper_add(&tv->encoder,\r\n&sun4i_tv_helper_funcs);\r\nret = drm_encoder_init(drm,\r\n&tv->encoder,\r\n&sun4i_tv_funcs,\r\nDRM_MODE_ENCODER_TVDAC,\r\nNULL);\r\nif (ret) {\r\ndev_err(dev, "Couldn't initialise the TV encoder\n");\r\ngoto err_disable_clk;\r\n}\r\ntv->encoder.possible_crtcs = BIT(0);\r\ndrm_connector_helper_add(&tv->connector,\r\n&sun4i_tv_comp_connector_helper_funcs);\r\nret = drm_connector_init(drm, &tv->connector,\r\n&sun4i_tv_comp_connector_funcs,\r\nDRM_MODE_CONNECTOR_Composite);\r\nif (ret) {\r\ndev_err(dev,\r\n"Couldn't initialise the Composite connector\n");\r\ngoto err_cleanup_connector;\r\n}\r\ntv->connector.interlace_allowed = true;\r\ndrm_mode_connector_attach_encoder(&tv->connector, &tv->encoder);\r\nreturn 0;\r\nerr_cleanup_connector:\r\ndrm_encoder_cleanup(&tv->encoder);\r\nerr_disable_clk:\r\nclk_disable_unprepare(tv->clk);\r\nerr_assert_reset:\r\nreset_control_assert(tv->reset);\r\nreturn ret;\r\n}\r\nstatic void sun4i_tv_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct sun4i_tv *tv = dev_get_drvdata(dev);\r\ndrm_connector_cleanup(&tv->connector);\r\ndrm_encoder_cleanup(&tv->encoder);\r\nclk_disable_unprepare(tv->clk);\r\n}\r\nstatic int sun4i_tv_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &sun4i_tv_ops);\r\n}\r\nstatic int sun4i_tv_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sun4i_tv_ops);\r\nreturn 0;\r\n}
