static void mei_deinit(struct mei *cl)\r\n{\r\nif (cl->fd != -1)\r\nclose(cl->fd);\r\ncl->fd = -1;\r\ncl->buf_size = 0;\r\ncl->prot_ver = 0;\r\ncl->initialized = false;\r\n}\r\nstatic bool mei_init(struct mei *me, const uuid_le *guid,\r\nunsigned char req_protocol_version, bool verbose)\r\n{\r\nint result;\r\nstruct mei_client *cl;\r\nstruct mei_connect_client_data data;\r\nme->verbose = verbose;\r\nme->fd = open("/dev/mei", O_RDWR);\r\nif (me->fd == -1) {\r\nmei_err(me, "Cannot establish a handle to the Intel MEI driver\n");\r\ngoto err;\r\n}\r\nmemcpy(&me->guid, guid, sizeof(*guid));\r\nmemset(&data, 0, sizeof(data));\r\nme->initialized = true;\r\nmemcpy(&data.in_client_uuid, &me->guid, sizeof(me->guid));\r\nresult = ioctl(me->fd, IOCTL_MEI_CONNECT_CLIENT, &data);\r\nif (result) {\r\nmei_err(me, "IOCTL_MEI_CONNECT_CLIENT receive message. err=%d\n", result);\r\ngoto err;\r\n}\r\ncl = &data.out_client_properties;\r\nmei_msg(me, "max_message_length %d\n", cl->max_msg_length);\r\nmei_msg(me, "protocol_version %d\n", cl->protocol_version);\r\nif ((req_protocol_version > 0) &&\r\n(cl->protocol_version != req_protocol_version)) {\r\nmei_err(me, "Intel MEI protocol version not supported\n");\r\ngoto err;\r\n}\r\nme->buf_size = cl->max_msg_length;\r\nme->prot_ver = cl->protocol_version;\r\nreturn true;\r\nerr:\r\nmei_deinit(me);\r\nreturn false;\r\n}\r\nstatic ssize_t mei_recv_msg(struct mei *me, unsigned char *buffer,\r\nssize_t len, unsigned long timeout)\r\n{\r\nssize_t rc;\r\nmei_msg(me, "call read length = %zd\n", len);\r\nrc = read(me->fd, buffer, len);\r\nif (rc < 0) {\r\nmei_err(me, "read failed with status %zd %s\n",\r\nrc, strerror(errno));\r\nmei_deinit(me);\r\n} else {\r\nmei_msg(me, "read succeeded with result %zd\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t mei_send_msg(struct mei *me, const unsigned char *buffer,\r\nssize_t len, unsigned long timeout)\r\n{\r\nstruct timeval tv;\r\nssize_t written;\r\nssize_t rc;\r\nfd_set set;\r\ntv.tv_sec = timeout / 1000;\r\ntv.tv_usec = (timeout % 1000) * 1000000;\r\nmei_msg(me, "call write length = %zd\n", len);\r\nwritten = write(me->fd, buffer, len);\r\nif (written < 0) {\r\nrc = -errno;\r\nmei_err(me, "write failed with status %zd %s\n",\r\nwritten, strerror(errno));\r\ngoto out;\r\n}\r\nFD_ZERO(&set);\r\nFD_SET(me->fd, &set);\r\nrc = select(me->fd + 1 , &set, NULL, NULL, &tv);\r\nif (rc > 0 && FD_ISSET(me->fd, &set)) {\r\nmei_msg(me, "write success\n");\r\n} else if (rc == 0) {\r\nmei_err(me, "write failed on timeout with status\n");\r\ngoto out;\r\n} else {\r\nmei_err(me, "write failed on select with status %zd\n", rc);\r\ngoto out;\r\n}\r\nrc = written;\r\nout:\r\nif (rc < 0)\r\nmei_deinit(me);\r\nreturn rc;\r\n}\r\nstatic bool amt_host_if_init(struct amt_host_if *acmd,\r\nunsigned long send_timeout, bool verbose)\r\n{\r\nacmd->send_timeout = (send_timeout) ? send_timeout : 20000;\r\nacmd->initialized = mei_init(&acmd->mei_cl, &MEI_IAMTHIF, 0, verbose);\r\nreturn acmd->initialized;\r\n}\r\nstatic void amt_host_if_deinit(struct amt_host_if *acmd)\r\n{\r\nmei_deinit(&acmd->mei_cl);\r\nacmd->initialized = false;\r\n}\r\nstatic uint32_t amt_verify_code_versions(const struct amt_host_if_resp_header *resp)\r\n{\r\nuint32_t status = AMT_STATUS_SUCCESS;\r\nstruct amt_code_versions *code_ver;\r\nsize_t code_ver_len;\r\nuint32_t ver_type_cnt;\r\nuint32_t len;\r\nuint32_t i;\r\ncode_ver = (struct amt_code_versions *)resp->data;\r\ncode_ver_len = resp->header.length - sizeof(uint32_t);\r\nver_type_cnt = code_ver_len -\r\nsizeof(code_ver->bios) -\r\nsizeof(code_ver->count);\r\nif (code_ver->count != ver_type_cnt / sizeof(struct amt_version_type)) {\r\nstatus = AMT_STATUS_INTERNAL_ERROR;\r\ngoto out;\r\n}\r\nfor (i = 0; i < code_ver->count; i++) {\r\nlen = code_ver->versions[i].description.length;\r\nif (len > AMT_UNICODE_STRING_LEN) {\r\nstatus = AMT_STATUS_INTERNAL_ERROR;\r\ngoto out;\r\n}\r\nlen = code_ver->versions[i].version.length;\r\nif (code_ver->versions[i].version.string[len] != '\0' ||\r\nlen != strlen(code_ver->versions[i].version.string)) {\r\nstatus = AMT_STATUS_INTERNAL_ERROR;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn status;\r\n}\r\nstatic uint32_t amt_verify_response_header(uint32_t command,\r\nconst struct amt_host_if_msg_header *resp_hdr,\r\nuint32_t response_size)\r\n{\r\nif (response_size < sizeof(struct amt_host_if_resp_header)) {\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\n} else if (response_size != (resp_hdr->length +\r\nsizeof(struct amt_host_if_msg_header))) {\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\n} else if (resp_hdr->command != command) {\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\n} else if (resp_hdr->_reserved != 0) {\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\n} else if (resp_hdr->version.major != AMT_MAJOR_VERSION ||\r\nresp_hdr->version.minor < AMT_MINOR_VERSION) {\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\n}\r\nreturn AMT_STATUS_SUCCESS;\r\n}\r\nstatic uint32_t amt_host_if_call(struct amt_host_if *acmd,\r\nconst unsigned char *command, ssize_t command_sz,\r\nuint8_t **read_buf, uint32_t rcmd,\r\nunsigned int expected_sz)\r\n{\r\nuint32_t in_buf_sz;\r\nuint32_t out_buf_sz;\r\nssize_t written;\r\nuint32_t status;\r\nstruct amt_host_if_resp_header *msg_hdr;\r\nin_buf_sz = acmd->mei_cl.buf_size;\r\n*read_buf = (uint8_t *)malloc(sizeof(uint8_t) * in_buf_sz);\r\nif (*read_buf == NULL)\r\nreturn AMT_STATUS_SDK_RESOURCES;\r\nmemset(*read_buf, 0, in_buf_sz);\r\nmsg_hdr = (struct amt_host_if_resp_header *)*read_buf;\r\nwritten = mei_send_msg(&acmd->mei_cl,\r\ncommand, command_sz, acmd->send_timeout);\r\nif (written != command_sz)\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\nout_buf_sz = mei_recv_msg(&acmd->mei_cl, *read_buf, in_buf_sz, 2000);\r\nif (out_buf_sz <= 0)\r\nreturn AMT_STATUS_HOST_IF_EMPTY_RESPONSE;\r\nstatus = msg_hdr->status;\r\nif (status != AMT_STATUS_SUCCESS)\r\nreturn status;\r\nstatus = amt_verify_response_header(rcmd,\r\n&msg_hdr->header, out_buf_sz);\r\nif (status != AMT_STATUS_SUCCESS)\r\nreturn status;\r\nif (expected_sz && expected_sz != out_buf_sz)\r\nreturn AMT_STATUS_INTERNAL_ERROR;\r\nreturn AMT_STATUS_SUCCESS;\r\n}\r\nstatic uint32_t amt_get_code_versions(struct amt_host_if *cmd,\r\nstruct amt_code_versions *versions)\r\n{\r\nstruct amt_host_if_resp_header *response = NULL;\r\nuint32_t status;\r\nstatus = amt_host_if_call(cmd,\r\n(const unsigned char *)&CODE_VERSION_REQ,\r\nsizeof(CODE_VERSION_REQ),\r\n(uint8_t **)&response,\r\nAMT_HOST_IF_CODE_VERSIONS_RESPONSE, 0);\r\nif (status != AMT_STATUS_SUCCESS)\r\ngoto out;\r\nstatus = amt_verify_code_versions(response);\r\nif (status != AMT_STATUS_SUCCESS)\r\ngoto out;\r\nmemcpy(versions, response->data, sizeof(struct amt_code_versions));\r\nout:\r\nif (response != NULL)\r\nfree(response);\r\nreturn status;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nstruct amt_code_versions ver;\r\nstruct amt_host_if acmd;\r\nunsigned int i;\r\nuint32_t status;\r\nint ret;\r\nbool verbose;\r\nverbose = (argc > 1 && strcmp(argv[1], "-v") == 0);\r\nif (!amt_host_if_init(&acmd, 5000, verbose)) {\r\nret = 1;\r\ngoto out;\r\n}\r\nstatus = amt_get_code_versions(&acmd, &ver);\r\namt_host_if_deinit(&acmd);\r\nswitch (status) {\r\ncase AMT_STATUS_HOST_IF_EMPTY_RESPONSE:\r\nprintf("Intel AMT: DISABLED\n");\r\nret = 0;\r\nbreak;\r\ncase AMT_STATUS_SUCCESS:\r\nprintf("Intel AMT: ENABLED\n");\r\nfor (i = 0; i < ver.count; i++) {\r\nprintf("%s:\t%s\n", ver.versions[i].description.string,\r\nver.versions[i].version.string);\r\n}\r\nret = 0;\r\nbreak;\r\ndefault:\r\nprintf("An error has occurred\n");\r\nret = 1;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}
