static int ag6xx_open(struct hci_uart *hu)\r\n{\r\nstruct ag6xx_data *ag6xx;\r\nBT_DBG("hu %p", hu);\r\nag6xx = kzalloc(sizeof(*ag6xx), GFP_KERNEL);\r\nif (!ag6xx)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&ag6xx->txq);\r\nhu->priv = ag6xx;\r\nreturn 0;\r\n}\r\nstatic int ag6xx_close(struct hci_uart *hu)\r\n{\r\nstruct ag6xx_data *ag6xx = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ag6xx->txq);\r\nkfree_skb(ag6xx->rx_skb);\r\nkfree(ag6xx);\r\nhu->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int ag6xx_flush(struct hci_uart *hu)\r\n{\r\nstruct ag6xx_data *ag6xx = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ag6xx->txq);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *ag6xx_dequeue(struct hci_uart *hu)\r\n{\r\nstruct ag6xx_data *ag6xx = hu->priv;\r\nstruct sk_buff *skb;\r\nskb = skb_dequeue(&ag6xx->txq);\r\nif (!skb)\r\nreturn skb;\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nreturn skb;\r\n}\r\nstatic int ag6xx_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct ag6xx_data *ag6xx = hu->priv;\r\nskb_queue_tail(&ag6xx->txq, skb);\r\nreturn 0;\r\n}\r\nstatic int ag6xx_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct ag6xx_data *ag6xx = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nag6xx->rx_skb = h4_recv_buf(hu->hdev, ag6xx->rx_skb, data, count,\r\nag6xx_recv_pkts,\r\nARRAY_SIZE(ag6xx_recv_pkts));\r\nif (IS_ERR(ag6xx->rx_skb)) {\r\nint err = PTR_ERR(ag6xx->rx_skb);\r\nbt_dev_err(hu->hdev, "Frame reassembly failed (%d)", err);\r\nag6xx->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic int intel_mem_write(struct hci_dev *hdev, u32 addr, u32 plen,\r\nconst void *data)\r\n{\r\nwhile (plen > 0) {\r\nstruct sk_buff *skb;\r\nu8 cmd_param[253], fragment_len = (plen > 247) ? 247 : plen;\r\n__le32 leaddr = cpu_to_le32(addr);\r\nmemcpy(cmd_param, &leaddr, 4);\r\ncmd_param[4] = 0;\r\ncmd_param[5] = fragment_len;\r\nmemcpy(cmd_param + 6, data, fragment_len);\r\nskb = __hci_cmd_sync(hdev, 0xfc8e, fragment_len + 6, cmd_param,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nplen -= fragment_len;\r\ndata += fragment_len;\r\naddr += fragment_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ag6xx_setup(struct hci_uart *hu)\r\n{\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct sk_buff *skb;\r\nstruct intel_version ver;\r\nconst struct firmware *fw;\r\nconst u8 *fw_ptr;\r\nchar fwname[64];\r\nbool patched = false;\r\nint err;\r\nhu->hdev->set_diag = btintel_set_diag;\r\nhu->hdev->set_bdaddr = btintel_set_bdaddr;\r\nerr = btintel_enter_mfg(hdev);\r\nif (err)\r\nreturn err;\r\nerr = btintel_read_version(hdev, &ver);\r\nif (err)\r\nreturn err;\r\nbtintel_version_info(hdev, &ver);\r\nif (ver.hw_platform != 0x37) {\r\nbt_dev_err(hdev, "Unsupported Intel hardware platform: 0x%X",\r\nver.hw_platform);\r\nreturn -EINVAL;\r\n}\r\nif (ver.hw_variant != 0x0a) {\r\nbt_dev_err(hdev, "Unsupported Intel hardware variant: 0x%x",\r\nver.hw_variant);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(fwname, sizeof(fwname), "intel/ibt-hw-%x.%x.bddata",\r\nver.hw_platform, ver.hw_variant);\r\nerr = request_firmware(&fw, fwname, &hdev->dev);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to open Intel bddata file: %s (%d)",\r\nfwname, err);\r\ngoto patch;\r\n}\r\nfw_ptr = fw->data;\r\nbt_dev_info(hdev, "Applying bddata (%s)", fwname);\r\nskb = __hci_cmd_sync_ev(hdev, 0xfc2f, fw->size, fw->data,\r\nHCI_EV_CMD_STATUS, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Applying bddata failed (%ld)", PTR_ERR(skb));\r\nrelease_firmware(fw);\r\nreturn PTR_ERR(skb);\r\n}\r\nkfree_skb(skb);\r\nrelease_firmware(fw);\r\npatch:\r\nif (ver.fw_patch_num) {\r\nbt_dev_info(hdev, "Device is already patched. patch num: %02x",\r\nver.fw_patch_num);\r\npatched = true;\r\ngoto complete;\r\n}\r\nsnprintf(fwname, sizeof(fwname),\r\n"intel/ibt-hw-%x.%x.%x-fw-%x.%x.%x.%x.%x.pbn",\r\nver.hw_platform, ver.hw_variant, ver.hw_revision,\r\nver.fw_variant, ver.fw_revision, ver.fw_build_num,\r\nver.fw_build_ww, ver.fw_build_yy);\r\nerr = request_firmware(&fw, fwname, &hdev->dev);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to open Intel patch file: %s(%d)",\r\nfwname, err);\r\ngoto complete;\r\n}\r\nfw_ptr = fw->data;\r\nbt_dev_info(hdev, "Patching firmware file (%s)", fwname);\r\nwhile (fw->size > fw_ptr - fw->data) {\r\nstruct pbn_entry *pbn = (void *)fw_ptr;\r\nu32 addr, plen;\r\nif (pbn->addr == 0xffffffff) {\r\nbt_dev_info(hdev, "Patching complete");\r\npatched = true;\r\nbreak;\r\n}\r\naddr = le32_to_cpu(pbn->addr);\r\nplen = le32_to_cpu(pbn->plen);\r\nif (fw->data + fw->size <= pbn->data + plen) {\r\nbt_dev_info(hdev, "Invalid patch len (%d)", plen);\r\nbreak;\r\n}\r\nbt_dev_info(hdev, "Patching %td/%zu", (fw_ptr - fw->data),\r\nfw->size);\r\nerr = intel_mem_write(hdev, addr, plen, pbn->data);\r\nif (err) {\r\nbt_dev_err(hdev, "Patching failed");\r\nbreak;\r\n}\r\nfw_ptr = pbn->data + plen;\r\n}\r\nrelease_firmware(fw);\r\ncomplete:\r\nerr = btintel_exit_mfg(hdev, true, patched);\r\nif (err)\r\nreturn err;\r\nbtintel_set_event_mask_mfg(hdev, false);\r\nbtintel_check_bdaddr(hdev);\r\nreturn 0;\r\n}\r\nint __init ag6xx_init(void)\r\n{\r\nreturn hci_uart_register_proto(&ag6xx_proto);\r\n}\r\nint __exit ag6xx_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&ag6xx_proto);\r\n}
