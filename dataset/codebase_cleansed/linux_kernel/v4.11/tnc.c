static int insert_old_idx(struct ubifs_info *c, int lnum, int offs)\r\n{\r\nstruct ubifs_old_idx *old_idx, *o;\r\nstruct rb_node **p, *parent = NULL;\r\nold_idx = kmalloc(sizeof(struct ubifs_old_idx), GFP_NOFS);\r\nif (unlikely(!old_idx))\r\nreturn -ENOMEM;\r\nold_idx->lnum = lnum;\r\nold_idx->offs = offs;\r\np = &c->old_idx.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\no = rb_entry(parent, struct ubifs_old_idx, rb);\r\nif (lnum < o->lnum)\r\np = &(*p)->rb_left;\r\nelse if (lnum > o->lnum)\r\np = &(*p)->rb_right;\r\nelse if (offs < o->offs)\r\np = &(*p)->rb_left;\r\nelse if (offs > o->offs)\r\np = &(*p)->rb_right;\r\nelse {\r\nubifs_err(c, "old idx added twice!");\r\nkfree(old_idx);\r\nreturn 0;\r\n}\r\n}\r\nrb_link_node(&old_idx->rb, parent, p);\r\nrb_insert_color(&old_idx->rb, &c->old_idx);\r\nreturn 0;\r\n}\r\nint insert_old_idx_znode(struct ubifs_info *c, struct ubifs_znode *znode)\r\n{\r\nif (znode->parent) {\r\nstruct ubifs_zbranch *zbr;\r\nzbr = &znode->parent->zbranch[znode->iip];\r\nif (zbr->len)\r\nreturn insert_old_idx(c, zbr->lnum, zbr->offs);\r\n} else\r\nif (c->zroot.len)\r\nreturn insert_old_idx(c, c->zroot.lnum,\r\nc->zroot.offs);\r\nreturn 0;\r\n}\r\nstatic int ins_clr_old_idx_znode(struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nint err;\r\nif (znode->parent) {\r\nstruct ubifs_zbranch *zbr;\r\nzbr = &znode->parent->zbranch[znode->iip];\r\nif (zbr->len) {\r\nerr = insert_old_idx(c, zbr->lnum, zbr->offs);\r\nif (err)\r\nreturn err;\r\nzbr->lnum = 0;\r\nzbr->offs = 0;\r\nzbr->len = 0;\r\n}\r\n} else\r\nif (c->zroot.len) {\r\nerr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\r\nif (err)\r\nreturn err;\r\nc->zroot.lnum = 0;\r\nc->zroot.offs = 0;\r\nc->zroot.len = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid destroy_old_idx(struct ubifs_info *c)\r\n{\r\nstruct ubifs_old_idx *old_idx, *n;\r\nrbtree_postorder_for_each_entry_safe(old_idx, n, &c->old_idx, rb)\r\nkfree(old_idx);\r\nc->old_idx = RB_ROOT;\r\n}\r\nstatic struct ubifs_znode *copy_znode(struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nstruct ubifs_znode *zn;\r\nzn = kmemdup(znode, c->max_znode_sz, GFP_NOFS);\r\nif (unlikely(!zn))\r\nreturn ERR_PTR(-ENOMEM);\r\nzn->cnext = NULL;\r\n__set_bit(DIRTY_ZNODE, &zn->flags);\r\n__clear_bit(COW_ZNODE, &zn->flags);\r\nubifs_assert(!ubifs_zn_obsolete(znode));\r\n__set_bit(OBSOLETE_ZNODE, &znode->flags);\r\nif (znode->level != 0) {\r\nint i;\r\nconst int n = zn->child_cnt;\r\nfor (i = 0; i < n; i++) {\r\nstruct ubifs_zbranch *zbr = &zn->zbranch[i];\r\nif (zbr->znode)\r\nzbr->znode->parent = zn;\r\n}\r\n}\r\natomic_long_inc(&c->dirty_zn_cnt);\r\nreturn zn;\r\n}\r\nstatic int add_idx_dirt(struct ubifs_info *c, int lnum, int dirt)\r\n{\r\nc->calc_idx_sz -= ALIGN(dirt, 8);\r\nreturn ubifs_add_dirt(c, lnum, dirt);\r\n}\r\nstatic struct ubifs_znode *dirty_cow_znode(struct ubifs_info *c,\r\nstruct ubifs_zbranch *zbr)\r\n{\r\nstruct ubifs_znode *znode = zbr->znode;\r\nstruct ubifs_znode *zn;\r\nint err;\r\nif (!ubifs_zn_cow(znode)) {\r\nif (!test_and_set_bit(DIRTY_ZNODE, &znode->flags)) {\r\natomic_long_inc(&c->dirty_zn_cnt);\r\natomic_long_dec(&c->clean_zn_cnt);\r\natomic_long_dec(&ubifs_clean_zn_cnt);\r\nerr = add_idx_dirt(c, zbr->lnum, zbr->len);\r\nif (unlikely(err))\r\nreturn ERR_PTR(err);\r\n}\r\nreturn znode;\r\n}\r\nzn = copy_znode(c, znode);\r\nif (IS_ERR(zn))\r\nreturn zn;\r\nif (zbr->len) {\r\nerr = insert_old_idx(c, zbr->lnum, zbr->offs);\r\nif (unlikely(err))\r\nreturn ERR_PTR(err);\r\nerr = add_idx_dirt(c, zbr->lnum, zbr->len);\r\n} else\r\nerr = 0;\r\nzbr->znode = zn;\r\nzbr->lnum = 0;\r\nzbr->offs = 0;\r\nzbr->len = 0;\r\nif (unlikely(err))\r\nreturn ERR_PTR(err);\r\nreturn zn;\r\n}\r\nstatic int lnc_add(struct ubifs_info *c, struct ubifs_zbranch *zbr,\r\nconst void *node)\r\n{\r\nint err;\r\nvoid *lnc_node;\r\nconst struct ubifs_dent_node *dent = node;\r\nubifs_assert(!zbr->leaf);\r\nubifs_assert(zbr->len != 0);\r\nubifs_assert(is_hash_key(c, &zbr->key));\r\nerr = ubifs_validate_entry(c, dent);\r\nif (err) {\r\ndump_stack();\r\nubifs_dump_node(c, dent);\r\nreturn err;\r\n}\r\nlnc_node = kmemdup(node, zbr->len, GFP_NOFS);\r\nif (!lnc_node)\r\nreturn 0;\r\nzbr->leaf = lnc_node;\r\nreturn 0;\r\n}\r\nstatic int lnc_add_directly(struct ubifs_info *c, struct ubifs_zbranch *zbr,\r\nvoid *node)\r\n{\r\nint err;\r\nubifs_assert(!zbr->leaf);\r\nubifs_assert(zbr->len != 0);\r\nerr = ubifs_validate_entry(c, node);\r\nif (err) {\r\ndump_stack();\r\nubifs_dump_node(c, node);\r\nreturn err;\r\n}\r\nzbr->leaf = node;\r\nreturn 0;\r\n}\r\nstatic void lnc_free(struct ubifs_zbranch *zbr)\r\n{\r\nif (!zbr->leaf)\r\nreturn;\r\nkfree(zbr->leaf);\r\nzbr->leaf = NULL;\r\n}\r\nstatic int tnc_read_hashed_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\r\nvoid *node)\r\n{\r\nint err;\r\nubifs_assert(is_hash_key(c, &zbr->key));\r\nif (zbr->leaf) {\r\nubifs_assert(zbr->len != 0);\r\nmemcpy(node, zbr->leaf, zbr->len);\r\nreturn 0;\r\n}\r\nif (c->replaying) {\r\nerr = fallible_read_node(c, &zbr->key, zbr, node);\r\nif (err == 0)\r\nerr = -ENOENT;\r\nelse if (err == 1)\r\nerr = 0;\r\n} else {\r\nerr = ubifs_tnc_read_node(c, zbr, node);\r\n}\r\nif (err)\r\nreturn err;\r\nerr = lnc_add(c, zbr, node);\r\nreturn err;\r\n}\r\nstatic int try_read_node(const struct ubifs_info *c, void *buf, int type,\r\nint len, int lnum, int offs)\r\n{\r\nint err, node_len;\r\nstruct ubifs_ch *ch = buf;\r\nuint32_t crc, node_crc;\r\ndbg_io("LEB %d:%d, %s, length %d", lnum, offs, dbg_ntype(type), len);\r\nerr = ubifs_leb_read(c, lnum, buf, offs, len, 1);\r\nif (err) {\r\nubifs_err(c, "cannot read node type %d from LEB %d:%d, error %d",\r\ntype, lnum, offs, err);\r\nreturn err;\r\n}\r\nif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\r\nreturn 0;\r\nif (ch->node_type != type)\r\nreturn 0;\r\nnode_len = le32_to_cpu(ch->len);\r\nif (node_len != len)\r\nreturn 0;\r\nif (type == UBIFS_DATA_NODE && c->no_chk_data_crc && !c->mounting &&\r\n!c->remounting_rw)\r\nreturn 1;\r\ncrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\r\nnode_crc = le32_to_cpu(ch->crc);\r\nif (crc != node_crc)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,\r\nstruct ubifs_zbranch *zbr, void *node)\r\n{\r\nint ret;\r\ndbg_tnck(key, "LEB %d:%d, key ", zbr->lnum, zbr->offs);\r\nret = try_read_node(c, node, key_type(c, key), zbr->len, zbr->lnum,\r\nzbr->offs);\r\nif (ret == 1) {\r\nunion ubifs_key node_key;\r\nstruct ubifs_dent_node *dent = node;\r\nkey_read(c, &dent->key, &node_key);\r\nif (keys_cmp(c, key, &node_key) != 0)\r\nret = 0;\r\n}\r\nif (ret == 0 && c->replaying)\r\ndbg_mntk(key, "dangling branch LEB %d:%d len %d, key ",\r\nzbr->lnum, zbr->offs, zbr->len);\r\nreturn ret;\r\n}\r\nstatic int matches_name(struct ubifs_info *c, struct ubifs_zbranch *zbr,\r\nconst struct fscrypt_name *nm)\r\n{\r\nstruct ubifs_dent_node *dent;\r\nint nlen, err;\r\nif (!zbr->leaf) {\r\ndent = kmalloc(zbr->len, GFP_NOFS);\r\nif (!dent)\r\nreturn -ENOMEM;\r\nerr = ubifs_tnc_read_node(c, zbr, dent);\r\nif (err)\r\ngoto out_free;\r\nerr = lnc_add_directly(c, zbr, dent);\r\nif (err)\r\ngoto out_free;\r\n} else\r\ndent = zbr->leaf;\r\nnlen = le16_to_cpu(dent->nlen);\r\nerr = memcmp(dent->name, fname_name(nm), min_t(int, nlen, fname_len(nm)));\r\nif (err == 0) {\r\nif (nlen == fname_len(nm))\r\nreturn NAME_MATCHES;\r\nelse if (nlen < fname_len(nm))\r\nreturn NAME_LESS;\r\nelse\r\nreturn NAME_GREATER;\r\n} else if (err < 0)\r\nreturn NAME_LESS;\r\nelse\r\nreturn NAME_GREATER;\r\nout_free:\r\nkfree(dent);\r\nreturn err;\r\n}\r\nstatic struct ubifs_znode *get_znode(struct ubifs_info *c,\r\nstruct ubifs_znode *znode, int n)\r\n{\r\nstruct ubifs_zbranch *zbr;\r\nzbr = &znode->zbranch[n];\r\nif (zbr->znode)\r\nznode = zbr->znode;\r\nelse\r\nznode = ubifs_load_znode(c, zbr, znode, n);\r\nreturn znode;\r\n}\r\nstatic int tnc_next(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\r\n{\r\nstruct ubifs_znode *znode = *zn;\r\nint nn = *n;\r\nnn += 1;\r\nif (nn < znode->child_cnt) {\r\n*n = nn;\r\nreturn 0;\r\n}\r\nwhile (1) {\r\nstruct ubifs_znode *zp;\r\nzp = znode->parent;\r\nif (!zp)\r\nreturn -ENOENT;\r\nnn = znode->iip + 1;\r\nznode = zp;\r\nif (nn < znode->child_cnt) {\r\nznode = get_znode(c, znode, nn);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nwhile (znode->level != 0) {\r\nznode = get_znode(c, znode, 0);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\nnn = 0;\r\nbreak;\r\n}\r\n}\r\n*zn = znode;\r\n*n = nn;\r\nreturn 0;\r\n}\r\nstatic int tnc_prev(struct ubifs_info *c, struct ubifs_znode **zn, int *n)\r\n{\r\nstruct ubifs_znode *znode = *zn;\r\nint nn = *n;\r\nif (nn > 0) {\r\n*n = nn - 1;\r\nreturn 0;\r\n}\r\nwhile (1) {\r\nstruct ubifs_znode *zp;\r\nzp = znode->parent;\r\nif (!zp)\r\nreturn -ENOENT;\r\nnn = znode->iip - 1;\r\nznode = zp;\r\nif (nn >= 0) {\r\nznode = get_znode(c, znode, nn);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nwhile (znode->level != 0) {\r\nnn = znode->child_cnt - 1;\r\nznode = get_znode(c, znode, nn);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\nnn = znode->child_cnt - 1;\r\nbreak;\r\n}\r\n}\r\n*zn = znode;\r\n*n = nn;\r\nreturn 0;\r\n}\r\nstatic int resolve_collision(struct ubifs_info *c, const union ubifs_key *key,\r\nstruct ubifs_znode **zn, int *n,\r\nconst struct fscrypt_name *nm)\r\n{\r\nint err;\r\nerr = matches_name(c, &(*zn)->zbranch[*n], nm);\r\nif (unlikely(err < 0))\r\nreturn err;\r\nif (err == NAME_MATCHES)\r\nreturn 1;\r\nif (err == NAME_GREATER) {\r\nwhile (1) {\r\nerr = tnc_prev(c, zn, n);\r\nif (err == -ENOENT) {\r\nubifs_assert(*n == 0);\r\n*n = -1;\r\nreturn 0;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\r\nif (*n == (*zn)->child_cnt - 1) {\r\nerr = tnc_next(c, zn, n);\r\nif (err) {\r\nubifs_assert(0);\r\nif (err == -ENOENT)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nubifs_assert(*n == 0);\r\n*n = -1;\r\n}\r\nreturn 0;\r\n}\r\nerr = matches_name(c, &(*zn)->zbranch[*n], nm);\r\nif (err < 0)\r\nreturn err;\r\nif (err == NAME_LESS)\r\nreturn 0;\r\nif (err == NAME_MATCHES)\r\nreturn 1;\r\nubifs_assert(err == NAME_GREATER);\r\n}\r\n} else {\r\nint nn = *n;\r\nstruct ubifs_znode *znode = *zn;\r\nwhile (1) {\r\nerr = tnc_next(c, &znode, &nn);\r\nif (err == -ENOENT)\r\nreturn 0;\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &znode->zbranch[nn].key, key))\r\nreturn 0;\r\nerr = matches_name(c, &znode->zbranch[nn], nm);\r\nif (err < 0)\r\nreturn err;\r\nif (err == NAME_GREATER)\r\nreturn 0;\r\n*zn = znode;\r\n*n = nn;\r\nif (err == NAME_MATCHES)\r\nreturn 1;\r\nubifs_assert(err == NAME_LESS);\r\n}\r\n}\r\n}\r\nstatic int fallible_matches_name(struct ubifs_info *c,\r\nstruct ubifs_zbranch *zbr,\r\nconst struct fscrypt_name *nm)\r\n{\r\nstruct ubifs_dent_node *dent;\r\nint nlen, err;\r\nif (!zbr->leaf) {\r\ndent = kmalloc(zbr->len, GFP_NOFS);\r\nif (!dent)\r\nreturn -ENOMEM;\r\nerr = fallible_read_node(c, &zbr->key, zbr, dent);\r\nif (err < 0)\r\ngoto out_free;\r\nif (err == 0) {\r\nerr = NOT_ON_MEDIA;\r\ngoto out_free;\r\n}\r\nubifs_assert(err == 1);\r\nerr = lnc_add_directly(c, zbr, dent);\r\nif (err)\r\ngoto out_free;\r\n} else\r\ndent = zbr->leaf;\r\nnlen = le16_to_cpu(dent->nlen);\r\nerr = memcmp(dent->name, fname_name(nm), min_t(int, nlen, fname_len(nm)));\r\nif (err == 0) {\r\nif (nlen == fname_len(nm))\r\nreturn NAME_MATCHES;\r\nelse if (nlen < fname_len(nm))\r\nreturn NAME_LESS;\r\nelse\r\nreturn NAME_GREATER;\r\n} else if (err < 0)\r\nreturn NAME_LESS;\r\nelse\r\nreturn NAME_GREATER;\r\nout_free:\r\nkfree(dent);\r\nreturn err;\r\n}\r\nstatic int fallible_resolve_collision(struct ubifs_info *c,\r\nconst union ubifs_key *key,\r\nstruct ubifs_znode **zn, int *n,\r\nconst struct fscrypt_name *nm,\r\nint adding)\r\n{\r\nstruct ubifs_znode *o_znode = NULL, *znode = *zn;\r\nint uninitialized_var(o_n), err, cmp, unsure = 0, nn = *n;\r\ncmp = fallible_matches_name(c, &znode->zbranch[nn], nm);\r\nif (unlikely(cmp < 0))\r\nreturn cmp;\r\nif (cmp == NAME_MATCHES)\r\nreturn 1;\r\nif (cmp == NOT_ON_MEDIA) {\r\no_znode = znode;\r\no_n = nn;\r\nunsure = 1;\r\n} else if (!adding)\r\nunsure = 1;\r\nif (cmp == NAME_GREATER || unsure) {\r\nwhile (1) {\r\nerr = tnc_prev(c, zn, n);\r\nif (err == -ENOENT) {\r\nubifs_assert(*n == 0);\r\n*n = -1;\r\nbreak;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &(*zn)->zbranch[*n].key, key)) {\r\nif (*n == (*zn)->child_cnt - 1) {\r\nerr = tnc_next(c, zn, n);\r\nif (err) {\r\nubifs_assert(0);\r\nif (err == -ENOENT)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nubifs_assert(*n == 0);\r\n*n = -1;\r\n}\r\nbreak;\r\n}\r\nerr = fallible_matches_name(c, &(*zn)->zbranch[*n], nm);\r\nif (err < 0)\r\nreturn err;\r\nif (err == NAME_MATCHES)\r\nreturn 1;\r\nif (err == NOT_ON_MEDIA) {\r\no_znode = *zn;\r\no_n = *n;\r\ncontinue;\r\n}\r\nif (!adding)\r\ncontinue;\r\nif (err == NAME_LESS)\r\nbreak;\r\nelse\r\nunsure = 0;\r\n}\r\n}\r\nif (cmp == NAME_LESS || unsure) {\r\n*zn = znode;\r\n*n = nn;\r\nwhile (1) {\r\nerr = tnc_next(c, &znode, &nn);\r\nif (err == -ENOENT)\r\nbreak;\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &znode->zbranch[nn].key, key))\r\nbreak;\r\nerr = fallible_matches_name(c, &znode->zbranch[nn], nm);\r\nif (err < 0)\r\nreturn err;\r\nif (err == NAME_GREATER)\r\nbreak;\r\n*zn = znode;\r\n*n = nn;\r\nif (err == NAME_MATCHES)\r\nreturn 1;\r\nif (err == NOT_ON_MEDIA) {\r\no_znode = znode;\r\no_n = nn;\r\n}\r\n}\r\n}\r\nif (adding || !o_znode)\r\nreturn 0;\r\ndbg_mntk(key, "dangling match LEB %d:%d len %d key ",\r\no_znode->zbranch[o_n].lnum, o_znode->zbranch[o_n].offs,\r\no_znode->zbranch[o_n].len);\r\n*zn = o_znode;\r\n*n = o_n;\r\nreturn 1;\r\n}\r\nstatic int matches_position(struct ubifs_zbranch *zbr, int lnum, int offs)\r\n{\r\nif (zbr->lnum == lnum && zbr->offs == offs)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int resolve_collision_directly(struct ubifs_info *c,\r\nconst union ubifs_key *key,\r\nstruct ubifs_znode **zn, int *n,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_znode *znode;\r\nint nn, err;\r\nznode = *zn;\r\nnn = *n;\r\nif (matches_position(&znode->zbranch[nn], lnum, offs))\r\nreturn 1;\r\nwhile (1) {\r\nerr = tnc_prev(c, &znode, &nn);\r\nif (err == -ENOENT)\r\nbreak;\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &znode->zbranch[nn].key, key))\r\nbreak;\r\nif (matches_position(&znode->zbranch[nn], lnum, offs)) {\r\n*zn = znode;\r\n*n = nn;\r\nreturn 1;\r\n}\r\n}\r\nznode = *zn;\r\nnn = *n;\r\nwhile (1) {\r\nerr = tnc_next(c, &znode, &nn);\r\nif (err == -ENOENT)\r\nreturn 0;\r\nif (err < 0)\r\nreturn err;\r\nif (keys_cmp(c, &znode->zbranch[nn].key, key))\r\nreturn 0;\r\n*zn = znode;\r\n*n = nn;\r\nif (matches_position(&znode->zbranch[nn], lnum, offs))\r\nreturn 1;\r\n}\r\n}\r\nstatic struct ubifs_znode *dirty_cow_bottom_up(struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nstruct ubifs_znode *zp;\r\nint *path = c->bottom_up_buf, p = 0;\r\nubifs_assert(c->zroot.znode);\r\nubifs_assert(znode);\r\nif (c->zroot.znode->level > BOTTOM_UP_HEIGHT) {\r\nkfree(c->bottom_up_buf);\r\nc->bottom_up_buf = kmalloc(c->zroot.znode->level * sizeof(int),\r\nGFP_NOFS);\r\nif (!c->bottom_up_buf)\r\nreturn ERR_PTR(-ENOMEM);\r\npath = c->bottom_up_buf;\r\n}\r\nif (c->zroot.znode->level) {\r\nwhile (1) {\r\nint n;\r\nzp = znode->parent;\r\nif (!zp)\r\nbreak;\r\nn = znode->iip;\r\nubifs_assert(p < c->zroot.znode->level);\r\npath[p++] = n;\r\nif (!zp->cnext && ubifs_zn_dirty(znode))\r\nbreak;\r\nznode = zp;\r\n}\r\n}\r\nwhile (1) {\r\nstruct ubifs_zbranch *zbr;\r\nzp = znode->parent;\r\nif (zp) {\r\nubifs_assert(path[p - 1] >= 0);\r\nubifs_assert(path[p - 1] < zp->child_cnt);\r\nzbr = &zp->zbranch[path[--p]];\r\nznode = dirty_cow_znode(c, zbr);\r\n} else {\r\nubifs_assert(znode == c->zroot.znode);\r\nznode = dirty_cow_znode(c, &c->zroot);\r\n}\r\nif (IS_ERR(znode) || !p)\r\nbreak;\r\nubifs_assert(path[p - 1] >= 0);\r\nubifs_assert(path[p - 1] < znode->child_cnt);\r\nznode = znode->zbranch[path[p - 1]].znode;\r\n}\r\nreturn znode;\r\n}\r\nint ubifs_lookup_level0(struct ubifs_info *c, const union ubifs_key *key,\r\nstruct ubifs_znode **zn, int *n)\r\n{\r\nint err, exact;\r\nstruct ubifs_znode *znode;\r\nunsigned long time = get_seconds();\r\ndbg_tnck(key, "search key ");\r\nubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\r\nznode = c->zroot.znode;\r\nif (unlikely(!znode)) {\r\nznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\nznode->time = time;\r\nwhile (1) {\r\nstruct ubifs_zbranch *zbr;\r\nexact = ubifs_search_zbranch(c, znode, key, n);\r\nif (znode->level == 0)\r\nbreak;\r\nif (*n < 0)\r\n*n = 0;\r\nzbr = &znode->zbranch[*n];\r\nif (zbr->znode) {\r\nznode->time = time;\r\nznode = zbr->znode;\r\ncontinue;\r\n}\r\nznode = ubifs_load_znode(c, zbr, znode, *n);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\n*zn = znode;\r\nif (exact || !is_hash_key(c, key) || *n != -1) {\r\ndbg_tnc("found %d, lvl %d, n %d", exact, znode->level, *n);\r\nreturn exact;\r\n}\r\nerr = tnc_prev(c, &znode, n);\r\nif (err == -ENOENT) {\r\ndbg_tnc("found 0, lvl %d, n -1", znode->level);\r\n*n = -1;\r\nreturn 0;\r\n}\r\nif (unlikely(err < 0))\r\nreturn err;\r\nif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\r\ndbg_tnc("found 0, lvl %d, n -1", znode->level);\r\n*n = -1;\r\nreturn 0;\r\n}\r\ndbg_tnc("found 1, lvl %d, n %d", znode->level, *n);\r\n*zn = znode;\r\nreturn 1;\r\n}\r\nstatic int lookup_level0_dirty(struct ubifs_info *c, const union ubifs_key *key,\r\nstruct ubifs_znode **zn, int *n)\r\n{\r\nint err, exact;\r\nstruct ubifs_znode *znode;\r\nunsigned long time = get_seconds();\r\ndbg_tnck(key, "search and dirty key ");\r\nznode = c->zroot.znode;\r\nif (unlikely(!znode)) {\r\nznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\nznode = dirty_cow_znode(c, &c->zroot);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nznode->time = time;\r\nwhile (1) {\r\nstruct ubifs_zbranch *zbr;\r\nexact = ubifs_search_zbranch(c, znode, key, n);\r\nif (znode->level == 0)\r\nbreak;\r\nif (*n < 0)\r\n*n = 0;\r\nzbr = &znode->zbranch[*n];\r\nif (zbr->znode) {\r\nznode->time = time;\r\nznode = dirty_cow_znode(c, zbr);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\ncontinue;\r\n}\r\nznode = ubifs_load_znode(c, zbr, znode, *n);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nznode = dirty_cow_znode(c, zbr);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\n*zn = znode;\r\nif (exact || !is_hash_key(c, key) || *n != -1) {\r\ndbg_tnc("found %d, lvl %d, n %d", exact, znode->level, *n);\r\nreturn exact;\r\n}\r\nerr = tnc_prev(c, &znode, n);\r\nif (err == -ENOENT) {\r\n*n = -1;\r\ndbg_tnc("found 0, lvl %d, n -1", znode->level);\r\nreturn 0;\r\n}\r\nif (unlikely(err < 0))\r\nreturn err;\r\nif (keys_cmp(c, key, &znode->zbranch[*n].key)) {\r\n*n = -1;\r\ndbg_tnc("found 0, lvl %d, n -1", znode->level);\r\nreturn 0;\r\n}\r\nif (znode->cnext || !ubifs_zn_dirty(znode)) {\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\n}\r\ndbg_tnc("found 1, lvl %d, n %d", znode->level, *n);\r\n*zn = znode;\r\nreturn 1;\r\n}\r\nstatic int maybe_leb_gced(struct ubifs_info *c, int lnum, int gc_seq1)\r\n{\r\nint gc_seq2, gced_lnum;\r\ngced_lnum = c->gced_lnum;\r\nsmp_rmb();\r\ngc_seq2 = c->gc_seq;\r\nif (gc_seq1 == gc_seq2)\r\nreturn 0;\r\nif (gc_seq1 + 1 != gc_seq2)\r\nreturn 1;\r\nsmp_rmb();\r\nif (gced_lnum != c->gced_lnum)\r\nreturn 1;\r\nif (gced_lnum == lnum)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint ubifs_tnc_locate(struct ubifs_info *c, const union ubifs_key *key,\r\nvoid *node, int *lnum, int *offs)\r\n{\r\nint found, n, err, safely = 0, gc_seq1;\r\nstruct ubifs_znode *znode;\r\nstruct ubifs_zbranch zbr, *zt;\r\nagain:\r\nmutex_lock(&c->tnc_mutex);\r\nfound = ubifs_lookup_level0(c, key, &znode, &n);\r\nif (!found) {\r\nerr = -ENOENT;\r\ngoto out;\r\n} else if (found < 0) {\r\nerr = found;\r\ngoto out;\r\n}\r\nzt = &znode->zbranch[n];\r\nif (lnum) {\r\n*lnum = zt->lnum;\r\n*offs = zt->offs;\r\n}\r\nif (is_hash_key(c, key)) {\r\nerr = tnc_read_hashed_node(c, zt, node);\r\ngoto out;\r\n}\r\nif (safely) {\r\nerr = ubifs_tnc_read_node(c, zt, node);\r\ngoto out;\r\n}\r\nzbr = znode->zbranch[n];\r\ngc_seq1 = c->gc_seq;\r\nmutex_unlock(&c->tnc_mutex);\r\nif (ubifs_get_wbuf(c, zbr.lnum)) {\r\nerr = ubifs_tnc_read_node(c, &zbr, node);\r\nreturn err;\r\n}\r\nerr = fallible_read_node(c, key, &zbr, node);\r\nif (err <= 0 || maybe_leb_gced(c, zbr.lnum, gc_seq1)) {\r\nsafely = 1;\r\ngoto again;\r\n}\r\nreturn 0;\r\nout:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_get_bu_keys(struct ubifs_info *c, struct bu_info *bu)\r\n{\r\nint n, err = 0, lnum = -1, uninitialized_var(offs);\r\nint uninitialized_var(len);\r\nunsigned int block = key_block(c, &bu->key);\r\nstruct ubifs_znode *znode;\r\nbu->cnt = 0;\r\nbu->blk_cnt = 0;\r\nbu->eof = 0;\r\nmutex_lock(&c->tnc_mutex);\r\nerr = ubifs_lookup_level0(c, &bu->key, &znode, &n);\r\nif (err < 0)\r\ngoto out;\r\nif (err) {\r\nlen = znode->zbranch[n].len;\r\nif (len > bu->buf_len) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nbu->zbranch[bu->cnt++] = znode->zbranch[n];\r\nbu->blk_cnt += 1;\r\nlnum = znode->zbranch[n].lnum;\r\noffs = ALIGN(znode->zbranch[n].offs + len, 8);\r\n}\r\nwhile (1) {\r\nstruct ubifs_zbranch *zbr;\r\nunion ubifs_key *key;\r\nunsigned int next_block;\r\nerr = tnc_next(c, &znode, &n);\r\nif (err)\r\ngoto out;\r\nzbr = &znode->zbranch[n];\r\nkey = &zbr->key;\r\nif (key_inum(c, key) != key_inum(c, &bu->key) ||\r\nkey_type(c, key) != UBIFS_DATA_KEY) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nif (lnum < 0) {\r\nlnum = zbr->lnum;\r\noffs = ALIGN(zbr->offs + zbr->len, 8);\r\nlen = zbr->len;\r\nif (len > bu->buf_len) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\nif (zbr->lnum != lnum || zbr->offs != offs)\r\ngoto out;\r\noffs += ALIGN(zbr->len, 8);\r\nlen = ALIGN(len, 8) + zbr->len;\r\nif (len > bu->buf_len)\r\ngoto out;\r\n}\r\nnext_block = key_block(c, key);\r\nbu->blk_cnt += (next_block - block - 1);\r\nif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\r\ngoto out;\r\nblock = next_block;\r\nbu->zbranch[bu->cnt++] = *zbr;\r\nbu->blk_cnt += 1;\r\nif (bu->cnt >= UBIFS_MAX_BULK_READ)\r\ngoto out;\r\nif (bu->blk_cnt >= UBIFS_MAX_BULK_READ)\r\ngoto out;\r\n}\r\nout:\r\nif (err == -ENOENT) {\r\nbu->eof = 1;\r\nerr = 0;\r\n}\r\nbu->gc_seq = c->gc_seq;\r\nmutex_unlock(&c->tnc_mutex);\r\nif (err)\r\nreturn err;\r\nif (bu->blk_cnt > UBIFS_MAX_BULK_READ)\r\nbu->blk_cnt = UBIFS_MAX_BULK_READ;\r\nif (UBIFS_BLOCKS_PER_PAGE == 1 ||\r\n!(bu->blk_cnt & (UBIFS_BLOCKS_PER_PAGE - 1)))\r\nreturn 0;\r\nif (bu->eof) {\r\nbu->blk_cnt += UBIFS_BLOCKS_PER_PAGE - 1;\r\nreturn 0;\r\n}\r\nblock = key_block(c, &bu->key) + bu->blk_cnt;\r\nblock &= ~(UBIFS_BLOCKS_PER_PAGE - 1);\r\nwhile (bu->cnt) {\r\nif (key_block(c, &bu->zbranch[bu->cnt - 1].key) < block)\r\nbreak;\r\nbu->cnt -= 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_wbuf(struct ubifs_wbuf *wbuf, void *buf, int len, int lnum,\r\nint offs)\r\n{\r\nconst struct ubifs_info *c = wbuf->c;\r\nint rlen, overlap;\r\ndbg_io("LEB %d:%d, length %d", lnum, offs, len);\r\nubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\r\nubifs_assert(!(offs & 7) && offs < c->leb_size);\r\nubifs_assert(offs + len <= c->leb_size);\r\nspin_lock(&wbuf->lock);\r\noverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\r\nif (!overlap) {\r\nspin_unlock(&wbuf->lock);\r\nreturn ubifs_leb_read(c, lnum, buf, offs, len, 0);\r\n}\r\nrlen = wbuf->offs - offs;\r\nif (rlen < 0)\r\nrlen = 0;\r\nmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\r\nspin_unlock(&wbuf->lock);\r\nif (rlen > 0)\r\nreturn ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\r\nreturn 0;\r\n}\r\nstatic int validate_data_node(struct ubifs_info *c, void *buf,\r\nstruct ubifs_zbranch *zbr)\r\n{\r\nunion ubifs_key key1;\r\nstruct ubifs_ch *ch = buf;\r\nint err, len;\r\nif (ch->node_type != UBIFS_DATA_NODE) {\r\nubifs_err(c, "bad node type (%d but expected %d)",\r\nch->node_type, UBIFS_DATA_NODE);\r\ngoto out_err;\r\n}\r\nerr = ubifs_check_node(c, buf, zbr->lnum, zbr->offs, 0, 0);\r\nif (err) {\r\nubifs_err(c, "expected node type %d", UBIFS_DATA_NODE);\r\ngoto out;\r\n}\r\nlen = le32_to_cpu(ch->len);\r\nif (len != zbr->len) {\r\nubifs_err(c, "bad node length %d, expected %d", len, zbr->len);\r\ngoto out_err;\r\n}\r\nkey_read(c, buf + UBIFS_KEY_OFFSET, &key1);\r\nif (!keys_eq(c, &zbr->key, &key1)) {\r\nubifs_err(c, "bad key in node at LEB %d:%d",\r\nzbr->lnum, zbr->offs);\r\ndbg_tnck(&zbr->key, "looked for key ");\r\ndbg_tnck(&key1, "found node's key ");\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nerr = -EINVAL;\r\nout:\r\nubifs_err(c, "bad node at LEB %d:%d", zbr->lnum, zbr->offs);\r\nubifs_dump_node(c, buf);\r\ndump_stack();\r\nreturn err;\r\n}\r\nint ubifs_tnc_bulk_read(struct ubifs_info *c, struct bu_info *bu)\r\n{\r\nint lnum = bu->zbranch[0].lnum, offs = bu->zbranch[0].offs, len, err, i;\r\nstruct ubifs_wbuf *wbuf;\r\nvoid *buf;\r\nlen = bu->zbranch[bu->cnt - 1].offs;\r\nlen += bu->zbranch[bu->cnt - 1].len - offs;\r\nif (len > bu->buf_len) {\r\nubifs_err(c, "buffer too small %d vs %d", bu->buf_len, len);\r\nreturn -EINVAL;\r\n}\r\nwbuf = ubifs_get_wbuf(c, lnum);\r\nif (wbuf)\r\nerr = read_wbuf(wbuf, bu->buf, len, lnum, offs);\r\nelse\r\nerr = ubifs_leb_read(c, lnum, bu->buf, offs, len, 0);\r\nif (maybe_leb_gced(c, lnum, bu->gc_seq))\r\nreturn -EAGAIN;\r\nif (err && err != -EBADMSG) {\r\nubifs_err(c, "failed to read from LEB %d:%d, error %d",\r\nlnum, offs, err);\r\ndump_stack();\r\ndbg_tnck(&bu->key, "key ");\r\nreturn err;\r\n}\r\nbuf = bu->buf;\r\nfor (i = 0; i < bu->cnt; i++) {\r\nerr = validate_data_node(c, buf, &bu->zbranch[i]);\r\nif (err)\r\nreturn err;\r\nbuf = buf + ALIGN(bu->zbranch[i].len, 8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\r\nvoid *node, const struct fscrypt_name *nm)\r\n{\r\nint found, n, err;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\nfound = ubifs_lookup_level0(c, key, &znode, &n);\r\nif (!found) {\r\nerr = -ENOENT;\r\ngoto out_unlock;\r\n} else if (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nubifs_assert(n >= 0);\r\nerr = resolve_collision(c, key, &znode, &n, nm);\r\ndbg_tnc("rc returned %d, znode %p, n %d", err, znode, n);\r\nif (unlikely(err < 0))\r\ngoto out_unlock;\r\nif (err == 0) {\r\nerr = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nerr = tnc_read_hashed_node(c, &znode->zbranch[n], node);\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_lookup_nm(struct ubifs_info *c, const union ubifs_key *key,\r\nvoid *node, const struct fscrypt_name *nm)\r\n{\r\nint err, len;\r\nconst struct ubifs_dent_node *dent = node;\r\nerr = ubifs_tnc_lookup(c, key, node);\r\nif (err)\r\nreturn err;\r\nlen = le16_to_cpu(dent->nlen);\r\nif (fname_len(nm) == len && !memcmp(dent->name, fname_name(nm), len))\r\nreturn 0;\r\nreturn do_lookup_nm(c, key, node, nm);\r\n}\r\nstatic int do_lookup_dh(struct ubifs_info *c, const union ubifs_key *key,\r\nstruct ubifs_dent_node *dent, uint32_t cookie)\r\n{\r\nint n, err, type = key_type(c, key);\r\nstruct ubifs_znode *znode;\r\nstruct ubifs_zbranch *zbr;\r\nunion ubifs_key *dkey, start_key;\r\nubifs_assert(is_hash_key(c, key));\r\nlowest_dent_key(c, &start_key, key_inum(c, key));\r\nmutex_lock(&c->tnc_mutex);\r\nerr = ubifs_lookup_level0(c, &start_key, &znode, &n);\r\nif (unlikely(err < 0))\r\ngoto out_unlock;\r\nfor (;;) {\r\nif (!err) {\r\nerr = tnc_next(c, &znode, &n);\r\nif (err)\r\ngoto out_unlock;\r\n}\r\nzbr = &znode->zbranch[n];\r\ndkey = &zbr->key;\r\nif (key_inum(c, dkey) != key_inum(c, key) ||\r\nkey_type(c, dkey) != type) {\r\nerr = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nerr = tnc_read_hashed_node(c, zbr, dent);\r\nif (err)\r\ngoto out_unlock;\r\nif (key_hash(c, key) == key_hash(c, dkey) &&\r\nle32_to_cpu(dent->cookie) == cookie)\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_lookup_dh(struct ubifs_info *c, const union ubifs_key *key,\r\nvoid *node, uint32_t cookie)\r\n{\r\nint err;\r\nconst struct ubifs_dent_node *dent = node;\r\nif (!c->double_hash)\r\nreturn -EOPNOTSUPP;\r\nerr = ubifs_tnc_lookup(c, key, node);\r\nif (err)\r\nreturn err;\r\nif (le32_to_cpu(dent->cookie) == cookie)\r\nreturn 0;\r\nreturn do_lookup_dh(c, key, node, cookie);\r\n}\r\nstatic void correct_parent_keys(const struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nunion ubifs_key *key, *key1;\r\nubifs_assert(znode->parent);\r\nubifs_assert(znode->iip == 0);\r\nkey = &znode->zbranch[0].key;\r\nkey1 = &znode->parent->zbranch[0].key;\r\nwhile (keys_cmp(c, key, key1) < 0) {\r\nkey_copy(c, key, key1);\r\nznode = znode->parent;\r\nznode->alt = 1;\r\nif (!znode->parent || znode->iip)\r\nbreak;\r\nkey1 = &znode->parent->zbranch[0].key;\r\n}\r\n}\r\nstatic void insert_zbranch(struct ubifs_znode *znode,\r\nconst struct ubifs_zbranch *zbr, int n)\r\n{\r\nint i;\r\nubifs_assert(ubifs_zn_dirty(znode));\r\nif (znode->level) {\r\nfor (i = znode->child_cnt; i > n; i--) {\r\nznode->zbranch[i] = znode->zbranch[i - 1];\r\nif (znode->zbranch[i].znode)\r\nznode->zbranch[i].znode->iip = i;\r\n}\r\nif (zbr->znode)\r\nzbr->znode->iip = n;\r\n} else\r\nfor (i = znode->child_cnt; i > n; i--)\r\nznode->zbranch[i] = znode->zbranch[i - 1];\r\nznode->zbranch[n] = *zbr;\r\nznode->child_cnt += 1;\r\nif (n == 0)\r\nznode->alt = 1;\r\n}\r\nstatic int tnc_insert(struct ubifs_info *c, struct ubifs_znode *znode,\r\nstruct ubifs_zbranch *zbr, int n)\r\n{\r\nstruct ubifs_znode *zn, *zi, *zp;\r\nint i, keep, move, appending = 0;\r\nunion ubifs_key *key = &zbr->key, *key1;\r\nubifs_assert(n >= 0 && n <= c->fanout);\r\nagain:\r\nzp = znode->parent;\r\nif (znode->child_cnt < c->fanout) {\r\nubifs_assert(n != c->fanout);\r\ndbg_tnck(key, "inserted at %d level %d, key ", n, znode->level);\r\ninsert_zbranch(znode, zbr, n);\r\nif (n == 0 && zp && znode->iip == 0)\r\ncorrect_parent_keys(c, znode);\r\nreturn 0;\r\n}\r\ndbg_tnck(key, "splitting level %d, key ", znode->level);\r\nif (znode->alt)\r\nins_clr_old_idx_znode(c, znode);\r\nzn = kzalloc(c->max_znode_sz, GFP_NOFS);\r\nif (!zn)\r\nreturn -ENOMEM;\r\nzn->parent = zp;\r\nzn->level = znode->level;\r\nif (znode->level == 0 && key_type(c, key) == UBIFS_DATA_KEY) {\r\nif (n == c->fanout) {\r\nkey1 = &znode->zbranch[n - 1].key;\r\nif (key_inum(c, key1) == key_inum(c, key) &&\r\nkey_type(c, key1) == UBIFS_DATA_KEY)\r\nappending = 1;\r\n} else\r\ngoto check_split;\r\n} else if (appending && n != c->fanout) {\r\nappending = 0;\r\ncheck_split:\r\nif (n >= (c->fanout + 1) / 2) {\r\nkey1 = &znode->zbranch[0].key;\r\nif (key_inum(c, key1) == key_inum(c, key) &&\r\nkey_type(c, key1) == UBIFS_DATA_KEY) {\r\nkey1 = &znode->zbranch[n].key;\r\nif (key_inum(c, key1) != key_inum(c, key) ||\r\nkey_type(c, key1) != UBIFS_DATA_KEY) {\r\nkeep = n;\r\nmove = c->fanout - keep;\r\nzi = znode;\r\ngoto do_split;\r\n}\r\n}\r\n}\r\n}\r\nif (appending) {\r\nkeep = c->fanout;\r\nmove = 0;\r\n} else {\r\nkeep = (c->fanout + 1) / 2;\r\nmove = c->fanout - keep;\r\n}\r\nif (n < keep) {\r\nzi = znode;\r\nmove += 1;\r\nkeep -= 1;\r\n} else {\r\nzi = zn;\r\nn -= keep;\r\nif (zn->level != 0)\r\nzbr->znode->parent = zn;\r\n}\r\ndo_split:\r\n__set_bit(DIRTY_ZNODE, &zn->flags);\r\natomic_long_inc(&c->dirty_zn_cnt);\r\nzn->child_cnt = move;\r\nznode->child_cnt = keep;\r\ndbg_tnc("moving %d, keeping %d", move, keep);\r\nfor (i = 0; i < move; i++) {\r\nzn->zbranch[i] = znode->zbranch[keep + i];\r\nif (zn->level != 0)\r\nif (zn->zbranch[i].znode) {\r\nzn->zbranch[i].znode->parent = zn;\r\nzn->zbranch[i].znode->iip = i;\r\n}\r\n}\r\ndbg_tnck(key, "inserting at %d level %d, key ", n, zn->level);\r\ninsert_zbranch(zi, zbr, n);\r\nif (zp) {\r\nif (n == 0 && zi == znode && znode->iip == 0)\r\ncorrect_parent_keys(c, znode);\r\nn = znode->iip + 1;\r\nzbr->key = zn->zbranch[0].key;\r\nzbr->znode = zn;\r\nzbr->lnum = 0;\r\nzbr->offs = 0;\r\nzbr->len = 0;\r\nznode = zp;\r\ngoto again;\r\n}\r\ndbg_tnc("creating new zroot at level %d", znode->level + 1);\r\nzi = kzalloc(c->max_znode_sz, GFP_NOFS);\r\nif (!zi)\r\nreturn -ENOMEM;\r\nzi->child_cnt = 2;\r\nzi->level = znode->level + 1;\r\n__set_bit(DIRTY_ZNODE, &zi->flags);\r\natomic_long_inc(&c->dirty_zn_cnt);\r\nzi->zbranch[0].key = znode->zbranch[0].key;\r\nzi->zbranch[0].znode = znode;\r\nzi->zbranch[0].lnum = c->zroot.lnum;\r\nzi->zbranch[0].offs = c->zroot.offs;\r\nzi->zbranch[0].len = c->zroot.len;\r\nzi->zbranch[1].key = zn->zbranch[0].key;\r\nzi->zbranch[1].znode = zn;\r\nc->zroot.lnum = 0;\r\nc->zroot.offs = 0;\r\nc->zroot.len = 0;\r\nc->zroot.znode = zi;\r\nzn->parent = zi;\r\nzn->iip = 1;\r\nznode->parent = zi;\r\nznode->iip = 0;\r\nreturn 0;\r\n}\r\nint ubifs_tnc_add(struct ubifs_info *c, const union ubifs_key *key, int lnum,\r\nint offs, int len)\r\n{\r\nint found, n, err = 0;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\ndbg_tnck(key, "%d:%d, len %d, key ", lnum, offs, len);\r\nfound = lookup_level0_dirty(c, key, &znode, &n);\r\nif (!found) {\r\nstruct ubifs_zbranch zbr;\r\nzbr.znode = NULL;\r\nzbr.lnum = lnum;\r\nzbr.offs = offs;\r\nzbr.len = len;\r\nkey_copy(c, key, &zbr.key);\r\nerr = tnc_insert(c, znode, &zbr, n + 1);\r\n} else if (found == 1) {\r\nstruct ubifs_zbranch *zbr = &znode->zbranch[n];\r\nlnc_free(zbr);\r\nerr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\r\nzbr->lnum = lnum;\r\nzbr->offs = offs;\r\nzbr->len = len;\r\n} else\r\nerr = found;\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_replace(struct ubifs_info *c, const union ubifs_key *key,\r\nint old_lnum, int old_offs, int lnum, int offs, int len)\r\n{\r\nint found, n, err = 0;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\ndbg_tnck(key, "old LEB %d:%d, new LEB %d:%d, len %d, key ", old_lnum,\r\nold_offs, lnum, offs, len);\r\nfound = lookup_level0_dirty(c, key, &znode, &n);\r\nif (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nif (found == 1) {\r\nstruct ubifs_zbranch *zbr = &znode->zbranch[n];\r\nfound = 0;\r\nif (zbr->lnum == old_lnum && zbr->offs == old_offs) {\r\nlnc_free(zbr);\r\nerr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\r\nif (err)\r\ngoto out_unlock;\r\nzbr->lnum = lnum;\r\nzbr->offs = offs;\r\nzbr->len = len;\r\nfound = 1;\r\n} else if (is_hash_key(c, key)) {\r\nfound = resolve_collision_directly(c, key, &znode, &n,\r\nold_lnum, old_offs);\r\ndbg_tnc("rc returned %d, znode %p, n %d, LEB %d:%d",\r\nfound, znode, n, old_lnum, old_offs);\r\nif (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nif (found) {\r\nif (znode->cnext || !ubifs_zn_dirty(znode)) {\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\n}\r\nzbr = &znode->zbranch[n];\r\nlnc_free(zbr);\r\nerr = ubifs_add_dirt(c, zbr->lnum,\r\nzbr->len);\r\nif (err)\r\ngoto out_unlock;\r\nzbr->lnum = lnum;\r\nzbr->offs = offs;\r\nzbr->len = len;\r\n}\r\n}\r\n}\r\nif (!found)\r\nerr = ubifs_add_dirt(c, lnum, len);\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_add_nm(struct ubifs_info *c, const union ubifs_key *key,\r\nint lnum, int offs, int len,\r\nconst struct fscrypt_name *nm)\r\n{\r\nint found, n, err = 0;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\nfound = lookup_level0_dirty(c, key, &znode, &n);\r\nif (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nif (found == 1) {\r\nif (c->replaying)\r\nfound = fallible_resolve_collision(c, key, &znode, &n,\r\nnm, 1);\r\nelse\r\nfound = resolve_collision(c, key, &znode, &n, nm);\r\ndbg_tnc("rc returned %d, znode %p, n %d", found, znode, n);\r\nif (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nif (znode->cnext || !ubifs_zn_dirty(znode)) {\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\n}\r\nif (found == 1) {\r\nstruct ubifs_zbranch *zbr = &znode->zbranch[n];\r\nlnc_free(zbr);\r\nerr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\r\nzbr->lnum = lnum;\r\nzbr->offs = offs;\r\nzbr->len = len;\r\ngoto out_unlock;\r\n}\r\n}\r\nif (!found) {\r\nstruct ubifs_zbranch zbr;\r\nzbr.znode = NULL;\r\nzbr.lnum = lnum;\r\nzbr.offs = offs;\r\nzbr.len = len;\r\nkey_copy(c, key, &zbr.key);\r\nerr = tnc_insert(c, znode, &zbr, n + 1);\r\nif (err)\r\ngoto out_unlock;\r\nif (c->replaying) {\r\nstruct fscrypt_name noname = { .disk_name = { .name = "", .len = 1 } };\r\nerr = dbg_check_tnc(c, 0);\r\nmutex_unlock(&c->tnc_mutex);\r\nif (err)\r\nreturn err;\r\nreturn ubifs_tnc_remove_nm(c, key, &noname);\r\n}\r\n}\r\nout_unlock:\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nstatic int tnc_delete(struct ubifs_info *c, struct ubifs_znode *znode, int n)\r\n{\r\nstruct ubifs_zbranch *zbr;\r\nstruct ubifs_znode *zp;\r\nint i, err;\r\nubifs_assert(znode->level == 0);\r\nubifs_assert(n >= 0 && n < c->fanout);\r\ndbg_tnck(&znode->zbranch[n].key, "deleting key ");\r\nzbr = &znode->zbranch[n];\r\nlnc_free(zbr);\r\nerr = ubifs_add_dirt(c, zbr->lnum, zbr->len);\r\nif (err) {\r\nubifs_dump_znode(c, znode);\r\nreturn err;\r\n}\r\nfor (i = n; i < znode->child_cnt - 1; i++)\r\nznode->zbranch[i] = znode->zbranch[i + 1];\r\nznode->child_cnt -= 1;\r\nif (znode->child_cnt > 0)\r\nreturn 0;\r\ndo {\r\nubifs_assert(!ubifs_zn_obsolete(znode));\r\nubifs_assert(ubifs_zn_dirty(znode));\r\nzp = znode->parent;\r\nn = znode->iip;\r\natomic_long_dec(&c->dirty_zn_cnt);\r\nerr = insert_old_idx_znode(c, znode);\r\nif (err)\r\nreturn err;\r\nif (znode->cnext) {\r\n__set_bit(OBSOLETE_ZNODE, &znode->flags);\r\natomic_long_inc(&c->clean_zn_cnt);\r\natomic_long_inc(&ubifs_clean_zn_cnt);\r\n} else\r\nkfree(znode);\r\nznode = zp;\r\n} while (znode->child_cnt == 1);\r\nznode->child_cnt -= 1;\r\nubifs_assert(znode->level != 0);\r\nfor (i = n; i < znode->child_cnt; i++) {\r\nznode->zbranch[i] = znode->zbranch[i + 1];\r\nif (znode->zbranch[i].znode)\r\nznode->zbranch[i].znode->iip = i;\r\n}\r\nif (!znode->parent) {\r\nwhile (znode->child_cnt == 1 && znode->level != 0) {\r\nzp = znode;\r\nzbr = &znode->zbranch[0];\r\nznode = get_znode(c, znode, 0);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nznode = dirty_cow_znode(c, zbr);\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nznode->parent = NULL;\r\nznode->iip = 0;\r\nif (c->zroot.len) {\r\nerr = insert_old_idx(c, c->zroot.lnum,\r\nc->zroot.offs);\r\nif (err)\r\nreturn err;\r\n}\r\nc->zroot.lnum = zbr->lnum;\r\nc->zroot.offs = zbr->offs;\r\nc->zroot.len = zbr->len;\r\nc->zroot.znode = znode;\r\nubifs_assert(!ubifs_zn_obsolete(zp));\r\nubifs_assert(ubifs_zn_dirty(zp));\r\natomic_long_dec(&c->dirty_zn_cnt);\r\nif (zp->cnext) {\r\n__set_bit(OBSOLETE_ZNODE, &zp->flags);\r\natomic_long_inc(&c->clean_zn_cnt);\r\natomic_long_inc(&ubifs_clean_zn_cnt);\r\n} else\r\nkfree(zp);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ubifs_tnc_remove(struct ubifs_info *c, const union ubifs_key *key)\r\n{\r\nint found, n, err = 0;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\ndbg_tnck(key, "key ");\r\nfound = lookup_level0_dirty(c, key, &znode, &n);\r\nif (found < 0) {\r\nerr = found;\r\ngoto out_unlock;\r\n}\r\nif (found == 1)\r\nerr = tnc_delete(c, znode, n);\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_remove_nm(struct ubifs_info *c, const union ubifs_key *key,\r\nconst struct fscrypt_name *nm)\r\n{\r\nint n, err;\r\nstruct ubifs_znode *znode;\r\nmutex_lock(&c->tnc_mutex);\r\nerr = lookup_level0_dirty(c, key, &znode, &n);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (err) {\r\nif (c->replaying)\r\nerr = fallible_resolve_collision(c, key, &znode, &n,\r\nnm, 0);\r\nelse\r\nerr = resolve_collision(c, key, &znode, &n, nm);\r\ndbg_tnc("rc returned %d, znode %p, n %d", err, znode, n);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (err) {\r\nif (znode->cnext || !ubifs_zn_dirty(znode)) {\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\n}\r\nerr = tnc_delete(c, znode, n);\r\n}\r\n}\r\nout_unlock:\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nstatic int key_in_range(struct ubifs_info *c, union ubifs_key *key,\r\nunion ubifs_key *from_key, union ubifs_key *to_key)\r\n{\r\nif (keys_cmp(c, key, from_key) < 0)\r\nreturn 0;\r\nif (keys_cmp(c, key, to_key) > 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ubifs_tnc_remove_range(struct ubifs_info *c, union ubifs_key *from_key,\r\nunion ubifs_key *to_key)\r\n{\r\nint i, n, k, err = 0;\r\nstruct ubifs_znode *znode;\r\nunion ubifs_key *key;\r\nmutex_lock(&c->tnc_mutex);\r\nwhile (1) {\r\nerr = ubifs_lookup_level0(c, from_key, &znode, &n);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (err)\r\nkey = from_key;\r\nelse {\r\nerr = tnc_next(c, &znode, &n);\r\nif (err == -ENOENT) {\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\nif (err < 0)\r\ngoto out_unlock;\r\nkey = &znode->zbranch[n].key;\r\nif (!key_in_range(c, key, from_key, to_key)) {\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\n}\r\nif (znode->cnext || !ubifs_zn_dirty(znode)) {\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\n}\r\nfor (i = n + 1, k = 0; i < znode->child_cnt; i++, k++) {\r\nkey = &znode->zbranch[i].key;\r\nif (!key_in_range(c, key, from_key, to_key))\r\nbreak;\r\nlnc_free(&znode->zbranch[i]);\r\nerr = ubifs_add_dirt(c, znode->zbranch[i].lnum,\r\nznode->zbranch[i].len);\r\nif (err) {\r\nubifs_dump_znode(c, znode);\r\ngoto out_unlock;\r\n}\r\ndbg_tnck(key, "removing key ");\r\n}\r\nif (k) {\r\nfor (i = n + 1 + k; i < znode->child_cnt; i++)\r\nznode->zbranch[i - k] = znode->zbranch[i];\r\nznode->child_cnt -= k;\r\n}\r\nerr = tnc_delete(c, znode, n);\r\nif (err)\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nif (!err)\r\nerr = dbg_check_tnc(c, 0);\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_tnc_remove_ino(struct ubifs_info *c, ino_t inum)\r\n{\r\nunion ubifs_key key1, key2;\r\nstruct ubifs_dent_node *xent, *pxent = NULL;\r\nstruct fscrypt_name nm = {0};\r\ndbg_tnc("ino %lu", (unsigned long)inum);\r\nlowest_xent_key(c, &key1, inum);\r\nwhile (1) {\r\nino_t xattr_inum;\r\nint err;\r\nxent = ubifs_tnc_next_ent(c, &key1, &nm);\r\nif (IS_ERR(xent)) {\r\nerr = PTR_ERR(xent);\r\nif (err == -ENOENT)\r\nbreak;\r\nreturn err;\r\n}\r\nxattr_inum = le64_to_cpu(xent->inum);\r\ndbg_tnc("xent '%s', ino %lu", xent->name,\r\n(unsigned long)xattr_inum);\r\nfname_name(&nm) = xent->name;\r\nfname_len(&nm) = le16_to_cpu(xent->nlen);\r\nerr = ubifs_tnc_remove_nm(c, &key1, &nm);\r\nif (err) {\r\nkfree(xent);\r\nreturn err;\r\n}\r\nlowest_ino_key(c, &key1, xattr_inum);\r\nhighest_ino_key(c, &key2, xattr_inum);\r\nerr = ubifs_tnc_remove_range(c, &key1, &key2);\r\nif (err) {\r\nkfree(xent);\r\nreturn err;\r\n}\r\nkfree(pxent);\r\npxent = xent;\r\nkey_read(c, &xent->key, &key1);\r\n}\r\nkfree(pxent);\r\nlowest_ino_key(c, &key1, inum);\r\nhighest_ino_key(c, &key2, inum);\r\nreturn ubifs_tnc_remove_range(c, &key1, &key2);\r\n}\r\nstruct ubifs_dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,\r\nunion ubifs_key *key,\r\nconst struct fscrypt_name *nm)\r\n{\r\nint n, err, type = key_type(c, key);\r\nstruct ubifs_znode *znode;\r\nstruct ubifs_dent_node *dent;\r\nstruct ubifs_zbranch *zbr;\r\nunion ubifs_key *dkey;\r\nubifs_assert(is_hash_key(c, key));\r\nmutex_lock(&c->tnc_mutex);\r\nerr = ubifs_lookup_level0(c, key, &znode, &n);\r\nif (unlikely(err < 0))\r\ngoto out_unlock;\r\nif (fname_len(nm) > 0) {\r\nif (err) {\r\nif (c->replaying)\r\nerr = fallible_resolve_collision(c, key, &znode, &n,\r\nnm, 0);\r\nelse\r\nerr = resolve_collision(c, key, &znode, &n, nm);\r\ndbg_tnc("rc returned %d, znode %p, n %d",\r\nerr, znode, n);\r\nif (unlikely(err < 0))\r\ngoto out_unlock;\r\n}\r\nerr = tnc_next(c, &znode, &n);\r\nif (unlikely(err))\r\ngoto out_unlock;\r\n} else {\r\nif (!err) {\r\nerr = tnc_next(c, &znode, &n);\r\nif (err)\r\ngoto out_unlock;\r\n}\r\n}\r\nzbr = &znode->zbranch[n];\r\ndent = kmalloc(zbr->len, GFP_NOFS);\r\nif (unlikely(!dent)) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\ndkey = &zbr->key;\r\nif (key_inum(c, dkey) != key_inum(c, key) ||\r\nkey_type(c, dkey) != type) {\r\nerr = -ENOENT;\r\ngoto out_free;\r\n}\r\nerr = tnc_read_hashed_node(c, zbr, dent);\r\nif (unlikely(err))\r\ngoto out_free;\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn dent;\r\nout_free:\r\nkfree(dent);\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void tnc_destroy_cnext(struct ubifs_info *c)\r\n{\r\nstruct ubifs_znode *cnext;\r\nif (!c->cnext)\r\nreturn;\r\nubifs_assert(c->cmt_state == COMMIT_BROKEN);\r\ncnext = c->cnext;\r\ndo {\r\nstruct ubifs_znode *znode = cnext;\r\ncnext = cnext->cnext;\r\nif (ubifs_zn_obsolete(znode))\r\nkfree(znode);\r\n} while (cnext && cnext != c->cnext);\r\n}\r\nvoid ubifs_tnc_close(struct ubifs_info *c)\r\n{\r\ntnc_destroy_cnext(c);\r\nif (c->zroot.znode) {\r\nlong n, freed;\r\nn = atomic_long_read(&c->clean_zn_cnt);\r\nfreed = ubifs_destroy_tnc_subtree(c->zroot.znode);\r\nubifs_assert(freed == n);\r\natomic_long_sub(n, &ubifs_clean_zn_cnt);\r\n}\r\nkfree(c->gap_lebs);\r\nkfree(c->ilebs);\r\ndestroy_old_idx(c);\r\n}\r\nstatic struct ubifs_znode *left_znode(struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nint level = znode->level;\r\nwhile (1) {\r\nint n = znode->iip - 1;\r\nznode = znode->parent;\r\nif (!znode)\r\nreturn NULL;\r\nif (n >= 0) {\r\nznode = get_znode(c, znode, n);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\nwhile (znode->level != level) {\r\nn = znode->child_cnt - 1;\r\nznode = get_znode(c, znode, n);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn znode;\r\n}\r\nstatic struct ubifs_znode *right_znode(struct ubifs_info *c,\r\nstruct ubifs_znode *znode)\r\n{\r\nint level = znode->level;\r\nwhile (1) {\r\nint n = znode->iip + 1;\r\nznode = znode->parent;\r\nif (!znode)\r\nreturn NULL;\r\nif (n < znode->child_cnt) {\r\nznode = get_znode(c, znode, n);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\nwhile (znode->level != level) {\r\nznode = get_znode(c, znode, 0);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn znode;\r\n}\r\nstatic struct ubifs_znode *lookup_znode(struct ubifs_info *c,\r\nunion ubifs_key *key, int level,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_znode *znode, *zn;\r\nint n, nn;\r\nubifs_assert(key_type(c, key) < UBIFS_INVALID_KEY);\r\nif (level < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nznode = c->zroot.znode;\r\nif (!znode) {\r\nznode = ubifs_load_znode(c, &c->zroot, NULL, 0);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\n}\r\nif (c->zroot.lnum == lnum && c->zroot.offs == offs)\r\nreturn znode;\r\nif (level >= znode->level)\r\nreturn NULL;\r\nwhile (1) {\r\nubifs_search_zbranch(c, znode, key, &n);\r\nif (n < 0) {\r\nznode = left_znode(c, znode);\r\nif (!znode)\r\nreturn NULL;\r\nif (IS_ERR(znode))\r\nreturn znode;\r\nubifs_search_zbranch(c, znode, key, &n);\r\nubifs_assert(n >= 0);\r\n}\r\nif (znode->level == level + 1)\r\nbreak;\r\nznode = get_znode(c, znode, n);\r\nif (IS_ERR(znode))\r\nreturn znode;\r\n}\r\nif (znode->zbranch[n].lnum == lnum && znode->zbranch[n].offs == offs)\r\nreturn get_znode(c, znode, n);\r\nif (!is_hash_key(c, key))\r\nreturn NULL;\r\nzn = znode;\r\nnn = n;\r\nwhile (1) {\r\nif (n)\r\nn -= 1;\r\nelse {\r\nznode = left_znode(c, znode);\r\nif (!znode)\r\nbreak;\r\nif (IS_ERR(znode))\r\nreturn znode;\r\nn = znode->child_cnt - 1;\r\n}\r\nif (znode->zbranch[n].lnum == lnum &&\r\nznode->zbranch[n].offs == offs)\r\nreturn get_znode(c, znode, n);\r\nif (keys_cmp(c, &znode->zbranch[n].key, key) < 0)\r\nbreak;\r\n}\r\nznode = zn;\r\nn = nn;\r\nwhile (1) {\r\nif (++n >= znode->child_cnt) {\r\nznode = right_znode(c, znode);\r\nif (!znode)\r\nbreak;\r\nif (IS_ERR(znode))\r\nreturn znode;\r\nn = 0;\r\n}\r\nif (znode->zbranch[n].lnum == lnum &&\r\nznode->zbranch[n].offs == offs)\r\nreturn get_znode(c, znode, n);\r\nif (keys_cmp(c, &znode->zbranch[n].key, key) > 0)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nint is_idx_node_in_tnc(struct ubifs_info *c, union ubifs_key *key, int level,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_znode *znode;\r\nznode = lookup_znode(c, key, level, lnum, offs);\r\nif (!znode)\r\nreturn 0;\r\nif (IS_ERR(znode))\r\nreturn PTR_ERR(znode);\r\nreturn ubifs_zn_dirty(znode) ? 1 : 2;\r\n}\r\nstatic int is_leaf_node_in_tnc(struct ubifs_info *c, union ubifs_key *key,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_zbranch *zbr;\r\nstruct ubifs_znode *znode, *zn;\r\nint n, found, err, nn;\r\nconst int unique = !is_hash_key(c, key);\r\nfound = ubifs_lookup_level0(c, key, &znode, &n);\r\nif (found < 0)\r\nreturn found;\r\nif (!found)\r\nreturn 0;\r\nzbr = &znode->zbranch[n];\r\nif (lnum == zbr->lnum && offs == zbr->offs)\r\nreturn 1;\r\nif (unique)\r\nreturn 0;\r\nzn = znode;\r\nnn = n;\r\nwhile (1) {\r\nerr = tnc_prev(c, &znode, &n);\r\nif (err == -ENOENT)\r\nbreak;\r\nif (err)\r\nreturn err;\r\nif (keys_cmp(c, key, &znode->zbranch[n].key))\r\nbreak;\r\nzbr = &znode->zbranch[n];\r\nif (lnum == zbr->lnum && offs == zbr->offs)\r\nreturn 1;\r\n}\r\nznode = zn;\r\nn = nn;\r\nwhile (1) {\r\nerr = tnc_next(c, &znode, &n);\r\nif (err) {\r\nif (err == -ENOENT)\r\nreturn 0;\r\nreturn err;\r\n}\r\nif (keys_cmp(c, key, &znode->zbranch[n].key))\r\nbreak;\r\nzbr = &znode->zbranch[n];\r\nif (lnum == zbr->lnum && offs == zbr->offs)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint ubifs_tnc_has_node(struct ubifs_info *c, union ubifs_key *key, int level,\r\nint lnum, int offs, int is_idx)\r\n{\r\nint err;\r\nmutex_lock(&c->tnc_mutex);\r\nif (is_idx) {\r\nerr = is_idx_node_in_tnc(c, key, level, lnum, offs);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (err == 1)\r\nerr = 0;\r\nelse if (err == 2)\r\nerr = 1;\r\nelse\r\nBUG_ON(err != 0);\r\n} else\r\nerr = is_leaf_node_in_tnc(c, key, lnum, offs);\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint ubifs_dirty_idx_node(struct ubifs_info *c, union ubifs_key *key, int level,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_znode *znode;\r\nint err = 0;\r\nmutex_lock(&c->tnc_mutex);\r\nznode = lookup_znode(c, key, level, lnum, offs);\r\nif (!znode)\r\ngoto out_unlock;\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\nznode = dirty_cow_bottom_up(c, znode);\r\nif (IS_ERR(znode)) {\r\nerr = PTR_ERR(znode);\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}\r\nint dbg_check_inode_size(struct ubifs_info *c, const struct inode *inode,\r\nloff_t size)\r\n{\r\nint err, n;\r\nunion ubifs_key from_key, to_key, *key;\r\nstruct ubifs_znode *znode;\r\nunsigned int block;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn 0;\r\nif (!dbg_is_chk_gen(c))\r\nreturn 0;\r\nblock = (size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\r\ndata_key_init(c, &from_key, inode->i_ino, block);\r\nhighest_data_key(c, &to_key, inode->i_ino);\r\nmutex_lock(&c->tnc_mutex);\r\nerr = ubifs_lookup_level0(c, &from_key, &znode, &n);\r\nif (err < 0)\r\ngoto out_unlock;\r\nif (err) {\r\nkey = &from_key;\r\ngoto out_dump;\r\n}\r\nerr = tnc_next(c, &znode, &n);\r\nif (err == -ENOENT) {\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\nif (err < 0)\r\ngoto out_unlock;\r\nubifs_assert(err == 0);\r\nkey = &znode->zbranch[n].key;\r\nif (!key_in_range(c, key, &from_key, &to_key))\r\ngoto out_unlock;\r\nout_dump:\r\nblock = key_block(c, key);\r\nubifs_err(c, "inode %lu has size %lld, but there are data at offset %lld",\r\n(unsigned long)inode->i_ino, size,\r\n((loff_t)block) << UBIFS_BLOCK_SHIFT);\r\nmutex_unlock(&c->tnc_mutex);\r\nubifs_dump_inode(c, inode);\r\ndump_stack();\r\nreturn -EINVAL;\r\nout_unlock:\r\nmutex_unlock(&c->tnc_mutex);\r\nreturn err;\r\n}
