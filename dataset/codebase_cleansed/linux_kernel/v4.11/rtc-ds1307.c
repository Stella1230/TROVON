static s32 ds1307_read_block_data_once(const struct i2c_client *client,\r\nu8 command, u8 length, u8 *values)\r\n{\r\ns32 i, data;\r\nfor (i = 0; i < length; i++) {\r\ndata = i2c_smbus_read_byte_data(client, command + i);\r\nif (data < 0)\r\nreturn data;\r\nvalues[i] = data;\r\n}\r\nreturn i;\r\n}\r\nstatic s32 ds1307_read_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, u8 *values)\r\n{\r\nu8 oldvalues[255];\r\ns32 ret;\r\nint tries = 0;\r\ndev_dbg(&client->dev, "ds1307_read_block_data (length=%d)\n", length);\r\nret = ds1307_read_block_data_once(client, command, length, values);\r\nif (ret < 0)\r\nreturn ret;\r\ndo {\r\nif (++tries > BLOCK_DATA_MAX_TRIES) {\r\ndev_err(&client->dev,\r\n"ds1307_read_block_data failed\n");\r\nreturn -EIO;\r\n}\r\nmemcpy(oldvalues, values, length);\r\nret = ds1307_read_block_data_once(client, command, length,\r\nvalues);\r\nif (ret < 0)\r\nreturn ret;\r\n} while (memcmp(oldvalues, values, length));\r\nreturn length;\r\n}\r\nstatic s32 ds1307_write_block_data(const struct i2c_client *client, u8 command,\r\nu8 length, const u8 *values)\r\n{\r\nu8 currvalues[255];\r\nint tries = 0;\r\ndev_dbg(&client->dev, "ds1307_write_block_data (length=%d)\n", length);\r\ndo {\r\ns32 i, ret;\r\nif (++tries > BLOCK_DATA_MAX_TRIES) {\r\ndev_err(&client->dev,\r\n"ds1307_write_block_data failed\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < length; i++) {\r\nret = i2c_smbus_write_byte_data(client, command + i,\r\nvalues[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = ds1307_read_block_data_once(client, command, length,\r\ncurrvalues);\r\nif (ret < 0)\r\nreturn ret;\r\n} while (memcmp(currvalues, values, length));\r\nreturn length;\r\n}\r\nstatic s32 ds1307_native_smbus_write_block_data(const struct i2c_client *client,\r\nu8 command, u8 length, const u8 *values)\r\n{\r\nu8 suboffset = 0;\r\nif (length <= I2C_SMBUS_BLOCK_MAX) {\r\ns32 retval = i2c_smbus_write_i2c_block_data(client,\r\ncommand, length, values);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn length;\r\n}\r\nwhile (suboffset < length) {\r\ns32 retval = i2c_smbus_write_i2c_block_data(client,\r\ncommand + suboffset,\r\nmin(I2C_SMBUS_BLOCK_MAX, length - suboffset),\r\nvalues + suboffset);\r\nif (retval < 0)\r\nreturn retval;\r\nsuboffset += I2C_SMBUS_BLOCK_MAX;\r\n}\r\nreturn length;\r\n}\r\nstatic s32 ds1307_native_smbus_read_block_data(const struct i2c_client *client,\r\nu8 command, u8 length, u8 *values)\r\n{\r\nu8 suboffset = 0;\r\nif (length <= I2C_SMBUS_BLOCK_MAX)\r\nreturn i2c_smbus_read_i2c_block_data(client,\r\ncommand, length, values);\r\nwhile (suboffset < length) {\r\ns32 retval = i2c_smbus_read_i2c_block_data(client,\r\ncommand + suboffset,\r\nmin(I2C_SMBUS_BLOCK_MAX, length - suboffset),\r\nvalues + suboffset);\r\nif (retval < 0)\r\nreturn retval;\r\nsuboffset += I2C_SMBUS_BLOCK_MAX;\r\n}\r\nreturn length;\r\n}\r\nstatic irqreturn_t ds1307_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nstruct mutex *lock = &ds1307->rtc->ops_lock;\r\nint stat, control;\r\nmutex_lock(lock);\r\nstat = i2c_smbus_read_byte_data(client, DS1337_REG_STATUS);\r\nif (stat < 0)\r\ngoto out;\r\nif (stat & DS1337_BIT_A1I) {\r\nstat &= ~DS1337_BIT_A1I;\r\ni2c_smbus_write_byte_data(client, DS1337_REG_STATUS, stat);\r\ncontrol = i2c_smbus_read_byte_data(client, DS1337_REG_CONTROL);\r\nif (control < 0)\r\ngoto out;\r\ncontrol &= ~DS1337_BIT_A1IE;\r\ni2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, control);\r\nrtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nout:\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ds1307_get_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct ds1307 *ds1307 = dev_get_drvdata(dev);\r\nint tmp;\r\ntmp = ds1307->read_block_data(ds1307->client,\r\nds1307->offset, 7, ds1307->regs);\r\nif (tmp != 7) {\r\ndev_err(dev, "%s error %d\n", "read", tmp);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "%s: %7ph\n", "read", ds1307->regs);\r\nt->tm_sec = bcd2bin(ds1307->regs[DS1307_REG_SECS] & 0x7f);\r\nt->tm_min = bcd2bin(ds1307->regs[DS1307_REG_MIN] & 0x7f);\r\ntmp = ds1307->regs[DS1307_REG_HOUR] & 0x3f;\r\nt->tm_hour = bcd2bin(tmp);\r\nt->tm_wday = bcd2bin(ds1307->regs[DS1307_REG_WDAY] & 0x07) - 1;\r\nt->tm_mday = bcd2bin(ds1307->regs[DS1307_REG_MDAY] & 0x3f);\r\ntmp = ds1307->regs[DS1307_REG_MONTH] & 0x1f;\r\nt->tm_mon = bcd2bin(tmp) - 1;\r\nt->tm_year = bcd2bin(ds1307->regs[DS1307_REG_YEAR]) + 100;\r\n#ifdef CONFIG_RTC_DRV_DS1307_CENTURY\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\nif (ds1307->regs[DS1307_REG_MONTH] & DS1337_BIT_CENTURY)\r\nt->tm_year += 100;\r\nbreak;\r\ncase ds_1340:\r\nif (ds1307->regs[DS1307_REG_HOUR] & DS1340_BIT_CENTURY)\r\nt->tm_year += 100;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#endif\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"read", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\nreturn rtc_valid_tm(t);\r\n}\r\nstatic int ds1307_set_time(struct device *dev, struct rtc_time *t)\r\n{\r\nstruct ds1307 *ds1307 = dev_get_drvdata(dev);\r\nint result;\r\nint tmp;\r\nu8 *buf = ds1307->regs;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\n",\r\n"write", t->tm_sec, t->tm_min,\r\nt->tm_hour, t->tm_mday,\r\nt->tm_mon, t->tm_year, t->tm_wday);\r\n#ifdef CONFIG_RTC_DRV_DS1307_CENTURY\r\nif (t->tm_year < 100)\r\nreturn -EINVAL;\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\ncase ds_1340:\r\nif (t->tm_year > 299)\r\nreturn -EINVAL;\r\ndefault:\r\nif (t->tm_year > 199)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\n#else\r\nif (t->tm_year < 100 || t->tm_year > 199)\r\nreturn -EINVAL;\r\n#endif\r\nbuf[DS1307_REG_SECS] = bin2bcd(t->tm_sec);\r\nbuf[DS1307_REG_MIN] = bin2bcd(t->tm_min);\r\nbuf[DS1307_REG_HOUR] = bin2bcd(t->tm_hour);\r\nbuf[DS1307_REG_WDAY] = bin2bcd(t->tm_wday + 1);\r\nbuf[DS1307_REG_MDAY] = bin2bcd(t->tm_mday);\r\nbuf[DS1307_REG_MONTH] = bin2bcd(t->tm_mon + 1);\r\ntmp = t->tm_year - 100;\r\nbuf[DS1307_REG_YEAR] = bin2bcd(tmp);\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\nif (t->tm_year > 199)\r\nbuf[DS1307_REG_MONTH] |= DS1337_BIT_CENTURY;\r\nbreak;\r\ncase ds_1340:\r\nbuf[DS1307_REG_HOUR] |= DS1340_BIT_CENTURY_EN;\r\nif (t->tm_year > 199)\r\nbuf[DS1307_REG_HOUR] |= DS1340_BIT_CENTURY;\r\nbreak;\r\ncase mcp794xx:\r\nbuf[DS1307_REG_SECS] |= MCP794XX_BIT_ST;\r\nbuf[DS1307_REG_WDAY] |= MCP794XX_BIT_VBATEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(dev, "%s: %7ph\n", "write", buf);\r\nresult = ds1307->write_block_data(ds1307->client,\r\nds1307->offset, 7, buf);\r\nif (result < 0) {\r\ndev_err(dev, "%s error %d\n", "write", result);\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds1337_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\nret = ds1307->read_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, ds1307->regs);\r\nif (ret != 9) {\r\ndev_err(dev, "%s error %d\n", "alarm read", ret);\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "%s: %4ph, %3ph, %2ph\n", "alarm read",\r\n&ds1307->regs[0], &ds1307->regs[4], &ds1307->regs[7]);\r\nt->time.tm_sec = bcd2bin(ds1307->regs[0] & 0x7f);\r\nt->time.tm_min = bcd2bin(ds1307->regs[1] & 0x7f);\r\nt->time.tm_hour = bcd2bin(ds1307->regs[2] & 0x3f);\r\nt->time.tm_mday = bcd2bin(ds1307->regs[3] & 0x3f);\r\nt->enabled = !!(ds1307->regs[7] & DS1337_BIT_A1IE);\r\nt->pending = !!(ds1307->regs[8] & DS1337_BIT_A1I);\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, enabled=%d, pending=%d\n",\r\n"alarm read", t->time.tm_sec, t->time.tm_min,\r\nt->time.tm_hour, t->time.tm_mday,\r\nt->enabled, t->pending);\r\nreturn 0;\r\n}\r\nstatic int ds1337_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nunsigned char *buf = ds1307->regs;\r\nu8 control, status;\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\ndev_dbg(dev, "%s secs=%d, mins=%d, "\r\n"hours=%d, mday=%d, enabled=%d, pending=%d\n",\r\n"alarm set", t->time.tm_sec, t->time.tm_min,\r\nt->time.tm_hour, t->time.tm_mday,\r\nt->enabled, t->pending);\r\nret = ds1307->read_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, buf);\r\nif (ret != 9) {\r\ndev_err(dev, "%s error %d\n", "alarm write", ret);\r\nreturn -EIO;\r\n}\r\ncontrol = ds1307->regs[7];\r\nstatus = ds1307->regs[8];\r\ndev_dbg(dev, "%s: %4ph, %3ph, %02x %02x\n", "alarm set (old status)",\r\n&ds1307->regs[0], &ds1307->regs[4], control, status);\r\nbuf[0] = bin2bcd(t->time.tm_sec);\r\nbuf[1] = bin2bcd(t->time.tm_min);\r\nbuf[2] = bin2bcd(t->time.tm_hour);\r\nbuf[3] = bin2bcd(t->time.tm_mday);\r\nbuf[4] = 0;\r\nbuf[5] = 0;\r\nbuf[6] = 0;\r\nbuf[7] = control & ~(DS1337_BIT_A1IE | DS1337_BIT_A2IE);\r\nbuf[8] = status & ~(DS1337_BIT_A1I | DS1337_BIT_A2I);\r\nret = ds1307->write_block_data(client,\r\nDS1339_REG_ALARM1_SECS, 9, buf);\r\nif (ret < 0) {\r\ndev_err(dev, "can't set alarm time\n");\r\nreturn ret;\r\n}\r\nif (t->enabled) {\r\ndev_dbg(dev, "alarm IRQ armed\n");\r\nbuf[7] |= DS1337_BIT_A1IE;\r\ni2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, buf[7]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds1307_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -ENOTTY;\r\nret = i2c_smbus_read_byte_data(client, DS1337_REG_CONTROL);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enabled)\r\nret |= DS1337_BIT_A1IE;\r\nelse\r\nret &= ~DS1337_BIT_A1IE;\r\nret = i2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mcp794xx_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nstruct mutex *lock = &ds1307->rtc->ops_lock;\r\nint reg, ret;\r\nmutex_lock(lock);\r\nreg = i2c_smbus_read_byte_data(client, MCP794XX_REG_ALARM0_CTRL);\r\nif (reg < 0)\r\ngoto out;\r\nif (!(reg & MCP794XX_BIT_ALMX_IF))\r\ngoto out;\r\nreg &= ~MCP794XX_BIT_ALMX_IF;\r\nret = i2c_smbus_write_byte_data(client, MCP794XX_REG_ALARM0_CTRL, reg);\r\nif (ret < 0)\r\ngoto out;\r\nreg = i2c_smbus_read_byte_data(client, MCP794XX_REG_CONTROL);\r\nif (reg < 0)\r\ngoto out;\r\nreg &= ~MCP794XX_BIT_ALM0_EN;\r\nret = i2c_smbus_write_byte_data(client, MCP794XX_REG_CONTROL, reg);\r\nif (ret < 0)\r\ngoto out;\r\nrtc_update_irq(ds1307->rtc, 1, RTC_AF | RTC_IRQF);\r\nout:\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mcp794xx_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nu8 *regs = ds1307->regs;\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\nret = ds1307->read_block_data(client, MCP794XX_REG_CONTROL, 10, regs);\r\nif (ret < 0)\r\nreturn ret;\r\nt->enabled = !!(regs[0] & MCP794XX_BIT_ALM0_EN);\r\nt->time.tm_sec = bcd2bin(ds1307->regs[3] & 0x7f);\r\nt->time.tm_min = bcd2bin(ds1307->regs[4] & 0x7f);\r\nt->time.tm_hour = bcd2bin(ds1307->regs[5] & 0x3f);\r\nt->time.tm_wday = bcd2bin(ds1307->regs[6] & 0x7) - 1;\r\nt->time.tm_mday = bcd2bin(ds1307->regs[7] & 0x3f);\r\nt->time.tm_mon = bcd2bin(ds1307->regs[8] & 0x1f) - 1;\r\nt->time.tm_year = -1;\r\nt->time.tm_yday = -1;\r\nt->time.tm_isdst = -1;\r\ndev_dbg(dev, "%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d "\r\n"enabled=%d polarity=%d irq=%d match=%d\n", __func__,\r\nt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\r\nt->time.tm_wday, t->time.tm_mday, t->time.tm_mon, t->enabled,\r\n!!(ds1307->regs[6] & MCP794XX_BIT_ALMX_POL),\r\n!!(ds1307->regs[6] & MCP794XX_BIT_ALMX_IF),\r\n(ds1307->regs[6] & MCP794XX_MSK_ALMX_MATCH) >> 4);\r\nreturn 0;\r\n}\r\nstatic int mcp794xx_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nunsigned char *regs = ds1307->regs;\r\nint ret;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\ndev_dbg(dev, "%s, sec=%d min=%d hour=%d wday=%d mday=%d mon=%d "\r\n"enabled=%d pending=%d\n", __func__,\r\nt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\r\nt->time.tm_wday, t->time.tm_mday, t->time.tm_mon,\r\nt->enabled, t->pending);\r\nret = ds1307->read_block_data(client, MCP794XX_REG_CONTROL, 10, regs);\r\nif (ret < 0)\r\nreturn ret;\r\nregs[3] = bin2bcd(t->time.tm_sec);\r\nregs[4] = bin2bcd(t->time.tm_min);\r\nregs[5] = bin2bcd(t->time.tm_hour);\r\nregs[6] = bin2bcd(t->time.tm_wday + 1);\r\nregs[7] = bin2bcd(t->time.tm_mday);\r\nregs[8] = bin2bcd(t->time.tm_mon + 1);\r\nregs[6] &= ~MCP794XX_BIT_ALMX_IF;\r\nregs[6] |= MCP794XX_MSK_ALMX_MATCH;\r\nregs[0] &= ~MCP794XX_BIT_ALM0_EN;\r\nret = ds1307->write_block_data(client, MCP794XX_REG_CONTROL, 10, regs);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!t->enabled)\r\nreturn 0;\r\nregs[0] |= MCP794XX_BIT_ALM0_EN;\r\nreturn i2c_smbus_write_byte_data(client, MCP794XX_REG_CONTROL, regs[0]);\r\n}\r\nstatic int mcp794xx_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nint reg;\r\nif (!test_bit(HAS_ALARM, &ds1307->flags))\r\nreturn -EINVAL;\r\nreg = i2c_smbus_read_byte_data(client, MCP794XX_REG_CONTROL);\r\nif (reg < 0)\r\nreturn reg;\r\nif (enabled)\r\nreg |= MCP794XX_BIT_ALM0_EN;\r\nelse\r\nreg &= ~MCP794XX_BIT_ALM0_EN;\r\nreturn i2c_smbus_write_byte_data(client, MCP794XX_REG_CONTROL, reg);\r\n}\r\nstatic ssize_t\r\nds1307_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nstruct ds1307 *ds1307;\r\nint result;\r\nclient = kobj_to_i2c_client(kobj);\r\nds1307 = i2c_get_clientdata(client);\r\nresult = ds1307->read_block_data(client, ds1307->nvram_offset + off,\r\ncount, buf);\r\nif (result < 0)\r\ndev_err(&client->dev, "%s error %d\n", "nvram read", result);\r\nreturn result;\r\n}\r\nstatic ssize_t\r\nds1307_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nstruct ds1307 *ds1307;\r\nint result;\r\nclient = kobj_to_i2c_client(kobj);\r\nds1307 = i2c_get_clientdata(client);\r\nresult = ds1307->write_block_data(client, ds1307->nvram_offset + off,\r\ncount, buf);\r\nif (result < 0) {\r\ndev_err(&client->dev, "%s error %d\n", "nvram write", result);\r\nreturn result;\r\n}\r\nreturn count;\r\n}\r\nstatic u8 do_trickle_setup_ds1339(struct i2c_client *client,\r\nuint32_t ohms, bool diode)\r\n{\r\nu8 setup = (diode) ? DS1307_TRICKLE_CHARGER_DIODE :\r\nDS1307_TRICKLE_CHARGER_NO_DIODE;\r\nswitch (ohms) {\r\ncase 250:\r\nsetup |= DS1307_TRICKLE_CHARGER_250_OHM;\r\nbreak;\r\ncase 2000:\r\nsetup |= DS1307_TRICKLE_CHARGER_2K_OHM;\r\nbreak;\r\ncase 4000:\r\nsetup |= DS1307_TRICKLE_CHARGER_4K_OHM;\r\nbreak;\r\ndefault:\r\ndev_warn(&client->dev,\r\n"Unsupported ohm value %u in dt\n", ohms);\r\nreturn 0;\r\n}\r\nreturn setup;\r\n}\r\nstatic void ds1307_trickle_init(struct i2c_client *client,\r\nstruct chip_desc *chip)\r\n{\r\nuint32_t ohms = 0;\r\nbool diode = true;\r\nif (!chip->do_trickle_setup)\r\ngoto out;\r\nif (device_property_read_u32(&client->dev, "trickle-resistor-ohms", &ohms))\r\ngoto out;\r\nif (device_property_read_bool(&client->dev, "trickle-diode-disable"))\r\ndiode = false;\r\nchip->trickle_charger_setup = chip->do_trickle_setup(client,\r\nohms, diode);\r\nout:\r\nreturn;\r\n}\r\nstatic int ds3231_hwmon_read_temp(struct device *dev, s32 *mC)\r\n{\r\nstruct ds1307 *ds1307 = dev_get_drvdata(dev);\r\nu8 temp_buf[2];\r\ns16 temp;\r\nint ret;\r\nret = ds1307->read_block_data(ds1307->client, DS3231_REG_TEMPERATURE,\r\nsizeof(temp_buf), temp_buf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != sizeof(temp_buf))\r\nreturn -EIO;\r\ntemp = (temp_buf[0] << 8) | temp_buf[1];\r\ntemp >>= 6;\r\n*mC = temp * 250;\r\nreturn 0;\r\n}\r\nstatic ssize_t ds3231_hwmon_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\ns32 temp;\r\nret = ds3231_hwmon_read_temp(dev, &temp);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic void ds1307_hwmon_register(struct ds1307 *ds1307)\r\n{\r\nstruct device *dev;\r\nif (ds1307->type != ds_3231)\r\nreturn;\r\ndev = devm_hwmon_device_register_with_groups(&ds1307->client->dev,\r\nds1307->client->name,\r\nds1307, ds3231_hwmon_groups);\r\nif (IS_ERR(dev)) {\r\ndev_warn(&ds1307->client->dev,\r\n"unable to register hwmon device %ld\n", PTR_ERR(dev));\r\n}\r\n}\r\nstatic void ds1307_hwmon_register(struct ds1307 *ds1307)\r\n{\r\n}\r\nstatic int ds1337_write_control(struct ds1307 *ds1307, u8 mask, u8 value)\r\n{\r\nstruct i2c_client *client = ds1307->client;\r\nstruct mutex *lock = &ds1307->rtc->ops_lock;\r\nint control;\r\nint ret;\r\nmutex_lock(lock);\r\ncontrol = i2c_smbus_read_byte_data(client, DS1337_REG_CONTROL);\r\nif (control < 0) {\r\nret = control;\r\ngoto out;\r\n}\r\ncontrol &= ~mask;\r\ncontrol |= value;\r\nret = i2c_smbus_write_byte_data(client, DS1337_REG_CONTROL, control);\r\nout:\r\nmutex_unlock(lock);\r\nreturn ret;\r\n}\r\nstatic unsigned long ds3231_clk_sqw_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\r\nint control;\r\nint rate_sel = 0;\r\ncontrol = i2c_smbus_read_byte_data(ds1307->client, DS1337_REG_CONTROL);\r\nif (control < 0)\r\nreturn control;\r\nif (control & DS1337_BIT_RS1)\r\nrate_sel += 1;\r\nif (control & DS1337_BIT_RS2)\r\nrate_sel += 2;\r\nreturn ds3231_clk_sqw_rates[rate_sel];\r\n}\r\nstatic long ds3231_clk_sqw_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nint i;\r\nfor (i = ARRAY_SIZE(ds3231_clk_sqw_rates) - 1; i >= 0; i--) {\r\nif (ds3231_clk_sqw_rates[i] <= rate)\r\nreturn ds3231_clk_sqw_rates[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int ds3231_clk_sqw_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\r\nint control = 0;\r\nint rate_sel;\r\nfor (rate_sel = 0; rate_sel < ARRAY_SIZE(ds3231_clk_sqw_rates);\r\nrate_sel++) {\r\nif (ds3231_clk_sqw_rates[rate_sel] == rate)\r\nbreak;\r\n}\r\nif (rate_sel == ARRAY_SIZE(ds3231_clk_sqw_rates))\r\nreturn -EINVAL;\r\nif (rate_sel & 1)\r\ncontrol |= DS1337_BIT_RS1;\r\nif (rate_sel & 2)\r\ncontrol |= DS1337_BIT_RS2;\r\nreturn ds1337_write_control(ds1307, DS1337_BIT_RS1 | DS1337_BIT_RS2,\r\ncontrol);\r\n}\r\nstatic int ds3231_clk_sqw_prepare(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\r\nreturn ds1337_write_control(ds1307, DS1337_BIT_INTCN, 0);\r\n}\r\nstatic void ds3231_clk_sqw_unprepare(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\r\nds1337_write_control(ds1307, DS1337_BIT_INTCN, DS1337_BIT_INTCN);\r\n}\r\nstatic int ds3231_clk_sqw_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_sqw_to_ds1307(hw);\r\nint control;\r\ncontrol = i2c_smbus_read_byte_data(ds1307->client, DS1337_REG_CONTROL);\r\nif (control < 0)\r\nreturn control;\r\nreturn !(control & DS1337_BIT_INTCN);\r\n}\r\nstatic unsigned long ds3231_clk_32khz_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic int ds3231_clk_32khz_control(struct ds1307 *ds1307, bool enable)\r\n{\r\nstruct i2c_client *client = ds1307->client;\r\nstruct mutex *lock = &ds1307->rtc->ops_lock;\r\nint status;\r\nint ret;\r\nmutex_lock(lock);\r\nstatus = i2c_smbus_read_byte_data(client, DS1337_REG_STATUS);\r\nif (status < 0) {\r\nret = status;\r\ngoto out;\r\n}\r\nif (enable)\r\nstatus |= DS3231_BIT_EN32KHZ;\r\nelse\r\nstatus &= ~DS3231_BIT_EN32KHZ;\r\nret = i2c_smbus_write_byte_data(client, DS1337_REG_STATUS, status);\r\nout:\r\nmutex_unlock(lock);\r\nreturn ret;\r\n}\r\nstatic int ds3231_clk_32khz_prepare(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\r\nreturn ds3231_clk_32khz_control(ds1307, true);\r\n}\r\nstatic void ds3231_clk_32khz_unprepare(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\r\nds3231_clk_32khz_control(ds1307, false);\r\n}\r\nstatic int ds3231_clk_32khz_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct ds1307 *ds1307 = clk_32khz_to_ds1307(hw);\r\nint status;\r\nstatus = i2c_smbus_read_byte_data(ds1307->client, DS1337_REG_STATUS);\r\nif (status < 0)\r\nreturn status;\r\nreturn !!(status & DS3231_BIT_EN32KHZ);\r\n}\r\nstatic int ds3231_clks_register(struct ds1307 *ds1307)\r\n{\r\nstruct i2c_client *client = ds1307->client;\r\nstruct device_node *node = client->dev.of_node;\r\nstruct clk_onecell_data *onecell;\r\nint i;\r\nonecell = devm_kzalloc(&client->dev, sizeof(*onecell), GFP_KERNEL);\r\nif (!onecell)\r\nreturn -ENOMEM;\r\nonecell->clk_num = ARRAY_SIZE(ds3231_clks_init);\r\nonecell->clks = devm_kcalloc(&client->dev, onecell->clk_num,\r\nsizeof(onecell->clks[0]), GFP_KERNEL);\r\nif (!onecell->clks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(ds3231_clks_init); i++) {\r\nstruct clk_init_data init = ds3231_clks_init[i];\r\nif (i == DS3231_CLK_SQW && test_bit(HAS_ALARM, &ds1307->flags))\r\ncontinue;\r\nof_property_read_string_index(node, "clock-output-names", i,\r\n&init.name);\r\nds1307->clks[i].init = &init;\r\nonecell->clks[i] = devm_clk_register(&client->dev,\r\n&ds1307->clks[i]);\r\nif (IS_ERR(onecell->clks[i]))\r\nreturn PTR_ERR(onecell->clks[i]);\r\n}\r\nif (!node)\r\nreturn 0;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, onecell);\r\nreturn 0;\r\n}\r\nstatic void ds1307_clks_register(struct ds1307 *ds1307)\r\n{\r\nint ret;\r\nif (ds1307->type != ds_3231)\r\nreturn;\r\nret = ds3231_clks_register(ds1307);\r\nif (ret) {\r\ndev_warn(&ds1307->client->dev,\r\n"unable to register clock device %d\n", ret);\r\n}\r\n}\r\nstatic void ds1307_clks_register(struct ds1307 *ds1307)\r\n{\r\n}\r\nstatic int ds1307_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ds1307 *ds1307;\r\nint err = -ENODEV;\r\nint tmp, wday;\r\nstruct chip_desc *chip;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nbool want_irq = false;\r\nbool ds1307_can_wakeup_device = false;\r\nunsigned char *buf;\r\nstruct ds1307_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct rtc_time tm;\r\nunsigned long timestamp;\r\nirq_handler_t irq_handler = ds1307_irq;\r\nstatic const int bbsqi_bitpos[] = {\r\n[ds_1337] = 0,\r\n[ds_1339] = DS1339_BIT_BBSQI,\r\n[ds_3231] = DS3231_BIT_BBSQW,\r\n};\r\nconst struct rtc_class_ops *rtc_ops = &ds13xx_rtc_ops;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)\r\n&& !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\nds1307 = devm_kzalloc(&client->dev, sizeof(struct ds1307), GFP_KERNEL);\r\nif (!ds1307)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, ds1307);\r\nds1307->client = client;\r\nif (id) {\r\nchip = &chips[id->driver_data];\r\nds1307->type = id->driver_data;\r\n} else {\r\nconst struct acpi_device_id *acpi_id;\r\nacpi_id = acpi_match_device(ACPI_PTR(ds1307_acpi_ids),\r\n&client->dev);\r\nif (!acpi_id)\r\nreturn -ENODEV;\r\nchip = &chips[acpi_id->driver_data];\r\nds1307->type = acpi_id->driver_data;\r\n}\r\nif (!pdata)\r\nds1307_trickle_init(client, chip);\r\nelse if (pdata->trickle_charger_setup)\r\nchip->trickle_charger_setup = pdata->trickle_charger_setup;\r\nif (chip->trickle_charger_setup && chip->trickle_charger_reg) {\r\ndev_dbg(&client->dev, "writing trickle charger info 0x%x to 0x%x\n",\r\nDS13XX_TRICKLE_CHARGER_MAGIC | chip->trickle_charger_setup,\r\nchip->trickle_charger_reg);\r\ni2c_smbus_write_byte_data(client, chip->trickle_charger_reg,\r\nDS13XX_TRICKLE_CHARGER_MAGIC |\r\nchip->trickle_charger_setup);\r\n}\r\nbuf = ds1307->regs;\r\nif (i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\nds1307->read_block_data = ds1307_native_smbus_read_block_data;\r\nds1307->write_block_data = ds1307_native_smbus_write_block_data;\r\n} else {\r\nds1307->read_block_data = ds1307_read_block_data;\r\nds1307->write_block_data = ds1307_write_block_data;\r\n}\r\n#ifdef CONFIG_OF\r\nif (of_property_read_bool(client->dev.of_node, "wakeup-source")) {\r\nds1307_can_wakeup_device = true;\r\n}\r\nif (of_property_read_bool(client->dev.of_node,\r\n"isil,irq2-can-wakeup-machine")) {\r\nds1307_can_wakeup_device = true;\r\n}\r\n#endif\r\nswitch (ds1307->type) {\r\ncase ds_1337:\r\ncase ds_1339:\r\ncase ds_3231:\r\ntmp = ds1307->read_block_data(ds1307->client,\r\nDS1337_REG_CONTROL, 2, buf);\r\nif (tmp != 2) {\r\ndev_dbg(&client->dev, "read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nif (ds1307->regs[0] & DS1337_BIT_nEOSC)\r\nds1307->regs[0] &= ~DS1337_BIT_nEOSC;\r\nif (chip->alarm && (ds1307->client->irq > 0 ||\r\nds1307_can_wakeup_device)) {\r\nds1307->regs[0] |= DS1337_BIT_INTCN\r\n| bbsqi_bitpos[ds1307->type];\r\nds1307->regs[0] &= ~(DS1337_BIT_A2IE | DS1337_BIT_A1IE);\r\nwant_irq = true;\r\n}\r\ni2c_smbus_write_byte_data(client, DS1337_REG_CONTROL,\r\nds1307->regs[0]);\r\nif (ds1307->regs[1] & DS1337_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1337_REG_STATUS,\r\nds1307->regs[1] & ~DS1337_BIT_OSF);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\n}\r\nbreak;\r\ncase rx_8025:\r\ntmp = i2c_smbus_read_i2c_block_data(ds1307->client,\r\nRX8025_REG_CTRL1 << 4 | 0x08, 2, buf);\r\nif (tmp != 2) {\r\ndev_dbg(&client->dev, "read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nif (!(ds1307->regs[1] & RX8025_BIT_XST)) {\r\nds1307->regs[1] |= RX8025_BIT_XST;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev,\r\n"oscillator stop detected - SET TIME!\n");\r\n}\r\nif (ds1307->regs[1] & RX8025_BIT_PON) {\r\nds1307->regs[1] &= ~RX8025_BIT_PON;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev, "power-on detected\n");\r\n}\r\nif (ds1307->regs[1] & RX8025_BIT_VDET) {\r\nds1307->regs[1] &= ~RX8025_BIT_VDET;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL2 << 4 | 0x08,\r\nds1307->regs[1]);\r\ndev_warn(&client->dev, "voltage drop detected\n");\r\n}\r\nif (!(ds1307->regs[0] & RX8025_BIT_2412)) {\r\nu8 hour;\r\ni2c_smbus_write_byte_data(client,\r\nRX8025_REG_CTRL1 << 4 | 0x08,\r\nds1307->regs[0] |\r\nRX8025_BIT_2412);\r\ntmp = i2c_smbus_read_i2c_block_data(ds1307->client,\r\nRX8025_REG_CTRL1 << 4 | 0x08, 2, buf);\r\nif (tmp != 2) {\r\ndev_dbg(&client->dev, "read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nhour = bcd2bin(ds1307->regs[DS1307_REG_HOUR]);\r\nif (hour == 12)\r\nhour = 0;\r\nif (ds1307->regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\r\nhour += 12;\r\ni2c_smbus_write_byte_data(client,\r\nDS1307_REG_HOUR << 4 | 0x08,\r\nhour);\r\n}\r\nbreak;\r\ncase ds_1388:\r\nds1307->offset = 1;\r\nbreak;\r\ncase mcp794xx:\r\nrtc_ops = &mcp794xx_rtc_ops;\r\nif (ds1307->client->irq > 0 && chip->alarm) {\r\nirq_handler = mcp794xx_irq;\r\nwant_irq = true;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_rtc:\r\ntmp = ds1307->read_block_data(ds1307->client, ds1307->offset, 8, buf);\r\nif (tmp != 8) {\r\ndev_dbg(&client->dev, "read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\ntmp = ds1307->regs[DS1307_REG_SECS];\r\nswitch (ds1307->type) {\r\ncase ds_1307:\r\ncase m41t00:\r\nif (tmp & DS1307_BIT_CH) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ncase ds_1338:\r\nif (tmp & DS1307_BIT_CH)\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\nif (ds1307->regs[DS1307_REG_CONTROL] & DS1338_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_CONTROL,\r\nds1307->regs[DS1307_REG_CONTROL]\r\n& ~DS1338_BIT_OSF);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ncase ds_1340:\r\nif (tmp & DS1340_BIT_nEOSC)\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS, 0);\r\ntmp = i2c_smbus_read_byte_data(client, DS1340_REG_FLAG);\r\nif (tmp < 0) {\r\ndev_dbg(&client->dev, "read error %d\n", tmp);\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nif (tmp & DS1340_BIT_OSF) {\r\ni2c_smbus_write_byte_data(client, DS1340_REG_FLAG, 0);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\n}\r\nbreak;\r\ncase mcp794xx:\r\nif (!(ds1307->regs[DS1307_REG_WDAY] & MCP794XX_BIT_VBATEN)) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_WDAY,\r\nds1307->regs[DS1307_REG_WDAY]\r\n| MCP794XX_BIT_VBATEN);\r\n}\r\nif (!(tmp & MCP794XX_BIT_ST)) {\r\ni2c_smbus_write_byte_data(client, DS1307_REG_SECS,\r\nMCP794XX_BIT_ST);\r\ndev_warn(&client->dev, "SET TIME!\n");\r\ngoto read_rtc;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntmp = ds1307->regs[DS1307_REG_HOUR];\r\nswitch (ds1307->type) {\r\ncase ds_1340:\r\ncase m41t00:\r\nbreak;\r\ncase rx_8025:\r\nbreak;\r\ndefault:\r\nif (!(tmp & DS1307_BIT_12HR))\r\nbreak;\r\ntmp = bcd2bin(tmp & 0x1f);\r\nif (tmp == 12)\r\ntmp = 0;\r\nif (ds1307->regs[DS1307_REG_HOUR] & DS1307_BIT_PM)\r\ntmp += 12;\r\ni2c_smbus_write_byte_data(client,\r\nds1307->offset + DS1307_REG_HOUR,\r\nbin2bcd(tmp));\r\n}\r\nds1307_get_time(&client->dev, &tm);\r\nwday = tm.tm_wday;\r\ntimestamp = rtc_tm_to_time64(&tm);\r\nrtc_time64_to_tm(timestamp, &tm);\r\nif (wday != tm.tm_wday) {\r\nwday = i2c_smbus_read_byte_data(client, MCP794XX_REG_WEEKDAY);\r\nwday = wday & ~MCP794XX_REG_WEEKDAY_WDAY_MASK;\r\nwday = wday | (tm.tm_wday + 1);\r\ni2c_smbus_write_byte_data(client, MCP794XX_REG_WEEKDAY, wday);\r\n}\r\nif (want_irq) {\r\ndevice_set_wakeup_capable(&client->dev, true);\r\nset_bit(HAS_ALARM, &ds1307->flags);\r\n}\r\nds1307->rtc = devm_rtc_device_register(&client->dev, client->name,\r\nrtc_ops, THIS_MODULE);\r\nif (IS_ERR(ds1307->rtc)) {\r\nreturn PTR_ERR(ds1307->rtc);\r\n}\r\nif (ds1307_can_wakeup_device && ds1307->client->irq <= 0) {\r\nwant_irq = false;\r\ndev_info(&client->dev, "'wakeup-source' is set, request for an IRQ is disabled!\n");\r\nds1307->rtc->uie_unsupported = 1;\r\n}\r\nif (want_irq) {\r\nerr = devm_request_threaded_irq(&client->dev,\r\nclient->irq, NULL, irq_handler,\r\nIRQF_SHARED | IRQF_ONESHOT,\r\nds1307->rtc->name, client);\r\nif (err) {\r\nclient->irq = 0;\r\ndevice_set_wakeup_capable(&client->dev, false);\r\nclear_bit(HAS_ALARM, &ds1307->flags);\r\ndev_err(&client->dev, "unable to request IRQ!\n");\r\n} else\r\ndev_dbg(&client->dev, "got IRQ %d\n", client->irq);\r\n}\r\nif (chip->nvram_size) {\r\nds1307->nvram = devm_kzalloc(&client->dev,\r\nsizeof(struct bin_attribute),\r\nGFP_KERNEL);\r\nif (!ds1307->nvram) {\r\ndev_err(&client->dev, "cannot allocate memory for nvram sysfs\n");\r\n} else {\r\nds1307->nvram->attr.name = "nvram";\r\nds1307->nvram->attr.mode = S_IRUGO | S_IWUSR;\r\nsysfs_bin_attr_init(ds1307->nvram);\r\nds1307->nvram->read = ds1307_nvram_read;\r\nds1307->nvram->write = ds1307_nvram_write;\r\nds1307->nvram->size = chip->nvram_size;\r\nds1307->nvram_offset = chip->nvram_offset;\r\nerr = sysfs_create_bin_file(&client->dev.kobj,\r\nds1307->nvram);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"unable to create sysfs file: %s\n",\r\nds1307->nvram->attr.name);\r\n} else {\r\nset_bit(HAS_NVRAM, &ds1307->flags);\r\ndev_info(&client->dev, "%zu bytes nvram\n",\r\nds1307->nvram->size);\r\n}\r\n}\r\n}\r\nds1307_hwmon_register(ds1307);\r\nds1307_clks_register(ds1307);\r\nreturn 0;\r\nexit:\r\nreturn err;\r\n}\r\nstatic int ds1307_remove(struct i2c_client *client)\r\n{\r\nstruct ds1307 *ds1307 = i2c_get_clientdata(client);\r\nif (test_and_clear_bit(HAS_NVRAM, &ds1307->flags))\r\nsysfs_remove_bin_file(&client->dev.kobj, ds1307->nvram);\r\nreturn 0;\r\n}
