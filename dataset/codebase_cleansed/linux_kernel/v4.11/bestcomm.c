struct bcom_task *\r\nbcom_task_alloc(int bd_count, int bd_size, int priv_size)\r\n{\r\nint i, tasknum = -1;\r\nstruct bcom_task *tsk;\r\nif (!bcom_eng)\r\nreturn NULL;\r\nspin_lock(&bcom_eng->lock);\r\nfor (i=0; i<BCOM_MAX_TASKS; i++)\r\nif (!bcom_eng->tdt[i].stop) {\r\nbcom_eng->tdt[i].stop = 0xfffffffful;\r\ntasknum = i;\r\nbreak;\r\n}\r\nspin_unlock(&bcom_eng->lock);\r\nif (tasknum < 0)\r\nreturn NULL;\r\ntsk = kzalloc(sizeof(struct bcom_task) + priv_size, GFP_KERNEL);\r\nif (!tsk)\r\ngoto error;\r\ntsk->tasknum = tasknum;\r\nif (priv_size)\r\ntsk->priv = (void*)tsk + sizeof(struct bcom_task);\r\ntsk->irq = irq_of_parse_and_map(bcom_eng->ofnode, tsk->tasknum);\r\nif (!tsk->irq)\r\ngoto error;\r\nif (bd_count) {\r\ntsk->cookie = kmalloc(sizeof(void*) * bd_count, GFP_KERNEL);\r\nif (!tsk->cookie)\r\ngoto error;\r\ntsk->bd = bcom_sram_alloc(bd_count * bd_size, 4, &tsk->bd_pa);\r\nif (!tsk->bd)\r\ngoto error;\r\nmemset(tsk->bd, 0x00, bd_count * bd_size);\r\ntsk->num_bd = bd_count;\r\ntsk->bd_size = bd_size;\r\n}\r\nreturn tsk;\r\nerror:\r\nif (tsk) {\r\nif (tsk->irq)\r\nirq_dispose_mapping(tsk->irq);\r\nbcom_sram_free(tsk->bd);\r\nkfree(tsk->cookie);\r\nkfree(tsk);\r\n}\r\nbcom_eng->tdt[tasknum].stop = 0;\r\nreturn NULL;\r\n}\r\nvoid\r\nbcom_task_free(struct bcom_task *tsk)\r\n{\r\nbcom_disable_task(tsk->tasknum);\r\nbcom_eng->tdt[tsk->tasknum].start = 0;\r\nbcom_eng->tdt[tsk->tasknum].stop = 0;\r\nirq_dispose_mapping(tsk->irq);\r\nbcom_sram_free(tsk->bd);\r\nkfree(tsk->cookie);\r\nkfree(tsk);\r\n}\r\nint\r\nbcom_load_image(int task, u32 *task_image)\r\n{\r\nstruct bcom_task_header *hdr = (struct bcom_task_header *)task_image;\r\nstruct bcom_tdt *tdt;\r\nu32 *desc, *var, *inc;\r\nu32 *desc_src, *var_src, *inc_src;\r\nif (hdr->magic != BCOM_TASK_MAGIC) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": Trying to load invalid microcode\n");\r\nreturn -EINVAL;\r\n}\r\nif ((task < 0) || (task >= BCOM_MAX_TASKS)) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": Trying to load invalid task %d\n", task);\r\nreturn -EINVAL;\r\n}\r\ntdt = &bcom_eng->tdt[task];\r\nif (tdt->start) {\r\ndesc = bcom_task_desc(task);\r\nif (hdr->desc_size != bcom_task_num_descs(task)) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": Trying to reload wrong task image "\r\n"(%d size %d/%d)!\n",\r\ntask,\r\nhdr->desc_size,\r\nbcom_task_num_descs(task));\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nphys_addr_t start_pa;\r\ndesc = bcom_sram_alloc(hdr->desc_size * sizeof(u32), 4, &start_pa);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ntdt->start = start_pa;\r\ntdt->stop = start_pa + ((hdr->desc_size-1) * sizeof(u32));\r\n}\r\nvar = bcom_task_var(task);\r\ninc = bcom_task_inc(task);\r\nmemset(var, 0x00, BCOM_VAR_SIZE);\r\nmemset(inc, 0x00, BCOM_INC_SIZE);\r\ndesc_src = (u32 *)(hdr + 1);\r\nvar_src = desc_src + hdr->desc_size;\r\ninc_src = var_src + hdr->var_size;\r\nmemcpy(desc, desc_src, hdr->desc_size * sizeof(u32));\r\nmemcpy(var + hdr->first_var, var_src, hdr->var_size * sizeof(u32));\r\nmemcpy(inc, inc_src, hdr->inc_size * sizeof(u32));\r\nreturn 0;\r\n}\r\nvoid\r\nbcom_set_initiator(int task, int initiator)\r\n{\r\nint i;\r\nint num_descs;\r\nu32 *desc;\r\nint next_drd_has_initiator;\r\nbcom_set_tcr_initiator(task, initiator);\r\ndesc = bcom_task_desc(task);\r\nnext_drd_has_initiator = 1;\r\nnum_descs = bcom_task_num_descs(task);\r\nfor (i=0; i<num_descs; i++, desc++) {\r\nif (!bcom_desc_is_drd(*desc))\r\ncontinue;\r\nif (next_drd_has_initiator)\r\nif (bcom_desc_initiator(*desc) != BCOM_INITIATOR_ALWAYS)\r\nbcom_set_desc_initiator(desc, initiator);\r\nnext_drd_has_initiator = !bcom_drd_is_extended(*desc);\r\n}\r\n}\r\nvoid\r\nbcom_enable(struct bcom_task *tsk)\r\n{\r\nbcom_enable_task(tsk->tasknum);\r\n}\r\nvoid\r\nbcom_disable(struct bcom_task *tsk)\r\n{\r\nbcom_disable_task(tsk->tasknum);\r\n}\r\nstatic int bcom_engine_init(void)\r\n{\r\nint task;\r\nphys_addr_t tdt_pa, ctx_pa, var_pa, fdt_pa;\r\nunsigned int tdt_size, ctx_size, var_size, fdt_size;\r\ntdt_size = BCOM_MAX_TASKS * sizeof(struct bcom_tdt);\r\nctx_size = BCOM_MAX_TASKS * BCOM_CTX_SIZE;\r\nvar_size = BCOM_MAX_TASKS * (BCOM_VAR_SIZE + BCOM_INC_SIZE);\r\nfdt_size = BCOM_FDT_SIZE;\r\nbcom_eng->tdt = bcom_sram_alloc(tdt_size, sizeof(u32), &tdt_pa);\r\nbcom_eng->ctx = bcom_sram_alloc(ctx_size, BCOM_CTX_ALIGN, &ctx_pa);\r\nbcom_eng->var = bcom_sram_alloc(var_size, BCOM_VAR_ALIGN, &var_pa);\r\nbcom_eng->fdt = bcom_sram_alloc(fdt_size, BCOM_FDT_ALIGN, &fdt_pa);\r\nif (!bcom_eng->tdt || !bcom_eng->ctx || !bcom_eng->var || !bcom_eng->fdt) {\r\nprintk(KERN_ERR "DMA: SRAM alloc failed in engine init !\n");\r\nbcom_sram_free(bcom_eng->tdt);\r\nbcom_sram_free(bcom_eng->ctx);\r\nbcom_sram_free(bcom_eng->var);\r\nbcom_sram_free(bcom_eng->fdt);\r\nreturn -ENOMEM;\r\n}\r\nmemset(bcom_eng->tdt, 0x00, tdt_size);\r\nmemset(bcom_eng->ctx, 0x00, ctx_size);\r\nmemset(bcom_eng->var, 0x00, var_size);\r\nmemset(bcom_eng->fdt, 0x00, fdt_size);\r\nmemcpy(&bcom_eng->fdt[48], fdt_ops, sizeof(fdt_ops));\r\nfor (task=0; task<BCOM_MAX_TASKS; task++)\r\n{\r\nout_be16(&bcom_eng->regs->tcr[task], 0);\r\nout_8(&bcom_eng->regs->ipr[task], 0);\r\nbcom_eng->tdt[task].context = ctx_pa;\r\nbcom_eng->tdt[task].var = var_pa;\r\nbcom_eng->tdt[task].fdt = fdt_pa;\r\nvar_pa += BCOM_VAR_SIZE + BCOM_INC_SIZE;\r\nctx_pa += BCOM_CTX_SIZE;\r\n}\r\nout_be32(&bcom_eng->regs->taskBar, tdt_pa);\r\nout_8(&bcom_eng->regs->ipr[BCOM_INITIATOR_ALWAYS], BCOM_IPR_ALWAYS);\r\nif ((mfspr(SPRN_SVR) & MPC5200_SVR_MASK) == MPC5200_SVR)\r\nbcom_disable_prefetch();\r\nspin_lock_init(&bcom_eng->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nbcom_engine_cleanup(void)\r\n{\r\nint task;\r\nfor (task=0; task<BCOM_MAX_TASKS; task++)\r\n{\r\nout_be16(&bcom_eng->regs->tcr[task], 0);\r\nout_8(&bcom_eng->regs->ipr[task], 0);\r\n}\r\nout_be32(&bcom_eng->regs->taskBar, 0ul);\r\nbcom_sram_free(bcom_eng->tdt);\r\nbcom_sram_free(bcom_eng->ctx);\r\nbcom_sram_free(bcom_eng->var);\r\nbcom_sram_free(bcom_eng->fdt);\r\n}\r\nstatic int mpc52xx_bcom_probe(struct platform_device *op)\r\n{\r\nstruct device_node *ofn_sram;\r\nstruct resource res_bcom;\r\nint rv;\r\nprintk(KERN_INFO "DMA: MPC52xx BestComm driver\n");\r\nof_node_get(op->dev.of_node);\r\nofn_sram = of_find_matching_node(NULL, mpc52xx_sram_ids);\r\nif (!ofn_sram) {\r\nprintk(KERN_ERR DRIVER_NAME ": "\r\n"No SRAM found in device tree\n");\r\nrv = -ENODEV;\r\ngoto error_ofput;\r\n}\r\nrv = bcom_sram_init(ofn_sram, DRIVER_NAME);\r\nof_node_put(ofn_sram);\r\nif (rv) {\r\nprintk(KERN_ERR DRIVER_NAME ": "\r\n"Error in SRAM init\n");\r\ngoto error_ofput;\r\n}\r\nbcom_eng = kzalloc(sizeof(struct bcom_engine), GFP_KERNEL);\r\nif (!bcom_eng) {\r\nrv = -ENOMEM;\r\ngoto error_sramclean;\r\n}\r\nbcom_eng->ofnode = op->dev.of_node;\r\nif (of_address_to_resource(op->dev.of_node, 0, &res_bcom)) {\r\nprintk(KERN_ERR DRIVER_NAME ": "\r\n"Can't get resource\n");\r\nrv = -EINVAL;\r\ngoto error_sramclean;\r\n}\r\nif (!request_mem_region(res_bcom.start, resource_size(&res_bcom),\r\nDRIVER_NAME)) {\r\nprintk(KERN_ERR DRIVER_NAME ": "\r\n"Can't request registers region\n");\r\nrv = -EBUSY;\r\ngoto error_sramclean;\r\n}\r\nbcom_eng->regs_base = res_bcom.start;\r\nbcom_eng->regs = ioremap(res_bcom.start, sizeof(struct mpc52xx_sdma));\r\nif (!bcom_eng->regs) {\r\nprintk(KERN_ERR DRIVER_NAME ": "\r\n"Can't map registers\n");\r\nrv = -ENOMEM;\r\ngoto error_release;\r\n}\r\nrv = bcom_engine_init();\r\nif (rv)\r\ngoto error_unmap;\r\nprintk(KERN_INFO "DMA: MPC52xx BestComm engine @%08lx ok !\n",\r\n(long)bcom_eng->regs_base);\r\nreturn 0;\r\nerror_unmap:\r\niounmap(bcom_eng->regs);\r\nerror_release:\r\nrelease_mem_region(res_bcom.start, sizeof(struct mpc52xx_sdma));\r\nerror_sramclean:\r\nkfree(bcom_eng);\r\nbcom_sram_cleanup();\r\nerror_ofput:\r\nof_node_put(op->dev.of_node);\r\nprintk(KERN_ERR "DMA: MPC52xx BestComm init failed !\n");\r\nreturn rv;\r\n}\r\nstatic int mpc52xx_bcom_remove(struct platform_device *op)\r\n{\r\nbcom_engine_cleanup();\r\nbcom_sram_cleanup();\r\niounmap(bcom_eng->regs);\r\nrelease_mem_region(bcom_eng->regs_base, sizeof(struct mpc52xx_sdma));\r\nof_node_put(bcom_eng->ofnode);\r\nkfree(bcom_eng);\r\nbcom_eng = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init\r\nmpc52xx_bcom_init(void)\r\n{\r\nreturn platform_driver_register(&mpc52xx_bcom_of_platform_driver);\r\n}\r\nstatic void __exit\r\nmpc52xx_bcom_exit(void)\r\n{\r\nplatform_driver_unregister(&mpc52xx_bcom_of_platform_driver);\r\n}
