void cx23885_mc417_init(struct cx23885_dev *dev)\r\n{\r\nu32 regval;\r\ndprintk(2, "%s()\n", __func__);\r\nregval = MC417_SPD_CTL(MC417_SPD_CTL_FAST) |\r\nMC417_GPIO_SEL(MC417_GPIO_SEL_GPIO3) |\r\nMC417_UART_GPIO_EN;\r\ncx_write(MC417_CTL, regval);\r\nregval = MC417_MIRDY;\r\ncx_write(MC417_OEN, regval);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS;\r\ncx_write(MC417_RWD, regval);\r\n}\r\nstatic int mc417_wait_ready(struct cx23885_dev *dev)\r\n{\r\nu32 mi_ready;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nfor (;;) {\r\nmi_ready = cx_read(MC417_RWD) & MC417_MIRDY;\r\nif (mi_ready != 0)\r\nreturn 0;\r\nif (time_after(jiffies, timeout))\r\nreturn -1;\r\nudelay(1);\r\n}\r\n}\r\nint mc417_register_write(struct cx23885_dev *dev, u16 address, u32 value)\r\n{\r\nu32 regval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0 |\r\n(value & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1 |\r\n((value >> 8) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2 |\r\n((value >> 16) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3 |\r\n((value >> 24) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\r\nMCI_MODE_REGISTER_WRITE;\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nreturn mc417_wait_ready(dev);\r\n}\r\nint mc417_register_read(struct cx23885_dev *dev, u16 address, u32 *value)\r\n{\r\nint retval;\r\nu32 regval;\r\nu32 tempval;\r\nu32 dataval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE0 |\r\n((address & 0x00FF));\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_MODE |\r\nMCI_MODE_REGISTER_READ;\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nretval = mc417_wait_ready(dev);\r\ncx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval = tempval & 0x000000FF;\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 8);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 16);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_REGISTER_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 24);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\n*value = dataval;\r\nreturn retval;\r\n}\r\nint mc417_memory_write(struct cx23885_dev *dev, u32 address, u32 value)\r\n{\r\nu32 regval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0 |\r\n(value & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1 |\r\n((value >> 8) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2 |\r\n((value >> 16) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3 |\r\n((value >> 24) & 0x000000FF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\r\nMCI_MODE_MEMORY_WRITE | ((address >> 16) & 0x3F);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nreturn mc417_wait_ready(dev);\r\n}\r\nint mc417_memory_read(struct cx23885_dev *dev, u32 address, u32 *value)\r\n{\r\nint retval;\r\nu32 regval;\r\nu32 tempval;\r\nu32 dataval;\r\ncx_write(MC417_OEN, MC417_MIRDY);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE2 |\r\nMCI_MODE_MEMORY_READ | ((address >> 16) & 0x3F);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE1 |\r\n((address >> 8) & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_ADDRESS_BYTE0 |\r\n(address & 0xFF);\r\ncx_write(MC417_RWD, regval);\r\nregval |= MC417_MICS | MC417_MIWR;\r\ncx_write(MC417_RWD, regval);\r\nretval = mc417_wait_ready(dev);\r\ncx_write(MC417_OEN, MC417_MIRDY | MC417_MIDATA);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE3;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval = ((tempval & 0x000000FF) << 24);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE2;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 16);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE1;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= ((tempval & 0x000000FF) << 8);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIRD | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\nregval = MC417_MIWR | MC417_MIRDY | MCI_MEMORY_DATA_BYTE0;\r\ncx_write(MC417_RWD, regval);\r\ntempval = cx_read(MC417_RWD);\r\ndataval |= (tempval & 0x000000FF);\r\nregval = MC417_MIWR | MC417_MIRD | MC417_MICS | MC417_MIRDY;\r\ncx_write(MC417_RWD, regval);\r\n*value = dataval;\r\nreturn retval;\r\n}\r\nvoid mc417_gpio_set(struct cx23885_dev *dev, u32 mask)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x900C, &val);\r\nval |= (mask & 0x000ffff);\r\nmc417_register_write(dev, 0x900C, val);\r\n}\r\nvoid mc417_gpio_clear(struct cx23885_dev *dev, u32 mask)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x900C, &val);\r\nval &= ~(mask & 0x0000ffff);\r\nmc417_register_write(dev, 0x900C, val);\r\n}\r\nvoid mc417_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)\r\n{\r\nu32 val;\r\nmc417_register_read(dev, 0x9020, &val);\r\nif (asoutput)\r\nval |= (mask & 0x0000ffff);\r\nelse\r\nval &= ~(mask & 0x0000ffff);\r\nmc417_register_write(dev, 0x9020, val);\r\n}\r\nstatic char *cmd_to_str(int cmd)\r\n{\r\nswitch (cmd) {\r\ncase CX2341X_ENC_PING_FW:\r\nreturn "PING_FW";\r\ncase CX2341X_ENC_START_CAPTURE:\r\nreturn "START_CAPTURE";\r\ncase CX2341X_ENC_STOP_CAPTURE:\r\nreturn "STOP_CAPTURE";\r\ncase CX2341X_ENC_SET_AUDIO_ID:\r\nreturn "SET_AUDIO_ID";\r\ncase CX2341X_ENC_SET_VIDEO_ID:\r\nreturn "SET_VIDEO_ID";\r\ncase CX2341X_ENC_SET_PCR_ID:\r\nreturn "SET_PCR_ID";\r\ncase CX2341X_ENC_SET_FRAME_RATE:\r\nreturn "SET_FRAME_RATE";\r\ncase CX2341X_ENC_SET_FRAME_SIZE:\r\nreturn "SET_FRAME_SIZE";\r\ncase CX2341X_ENC_SET_BIT_RATE:\r\nreturn "SET_BIT_RATE";\r\ncase CX2341X_ENC_SET_GOP_PROPERTIES:\r\nreturn "SET_GOP_PROPERTIES";\r\ncase CX2341X_ENC_SET_ASPECT_RATIO:\r\nreturn "SET_ASPECT_RATIO";\r\ncase CX2341X_ENC_SET_DNR_FILTER_MODE:\r\nreturn "SET_DNR_FILTER_MODE";\r\ncase CX2341X_ENC_SET_DNR_FILTER_PROPS:\r\nreturn "SET_DNR_FILTER_PROPS";\r\ncase CX2341X_ENC_SET_CORING_LEVELS:\r\nreturn "SET_CORING_LEVELS";\r\ncase CX2341X_ENC_SET_SPATIAL_FILTER_TYPE:\r\nreturn "SET_SPATIAL_FILTER_TYPE";\r\ncase CX2341X_ENC_SET_VBI_LINE:\r\nreturn "SET_VBI_LINE";\r\ncase CX2341X_ENC_SET_STREAM_TYPE:\r\nreturn "SET_STREAM_TYPE";\r\ncase CX2341X_ENC_SET_OUTPUT_PORT:\r\nreturn "SET_OUTPUT_PORT";\r\ncase CX2341X_ENC_SET_AUDIO_PROPERTIES:\r\nreturn "SET_AUDIO_PROPERTIES";\r\ncase CX2341X_ENC_HALT_FW:\r\nreturn "HALT_FW";\r\ncase CX2341X_ENC_GET_VERSION:\r\nreturn "GET_VERSION";\r\ncase CX2341X_ENC_SET_GOP_CLOSURE:\r\nreturn "SET_GOP_CLOSURE";\r\ncase CX2341X_ENC_GET_SEQ_END:\r\nreturn "GET_SEQ_END";\r\ncase CX2341X_ENC_SET_PGM_INDEX_INFO:\r\nreturn "SET_PGM_INDEX_INFO";\r\ncase CX2341X_ENC_SET_VBI_CONFIG:\r\nreturn "SET_VBI_CONFIG";\r\ncase CX2341X_ENC_SET_DMA_BLOCK_SIZE:\r\nreturn "SET_DMA_BLOCK_SIZE";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_10:\r\nreturn "GET_PREV_DMA_INFO_MB_10";\r\ncase CX2341X_ENC_GET_PREV_DMA_INFO_MB_9:\r\nreturn "GET_PREV_DMA_INFO_MB_9";\r\ncase CX2341X_ENC_SCHED_DMA_TO_HOST:\r\nreturn "SCHED_DMA_TO_HOST";\r\ncase CX2341X_ENC_INITIALIZE_INPUT:\r\nreturn "INITIALIZE_INPUT";\r\ncase CX2341X_ENC_SET_FRAME_DROP_RATE:\r\nreturn "SET_FRAME_DROP_RATE";\r\ncase CX2341X_ENC_PAUSE_ENCODER:\r\nreturn "PAUSE_ENCODER";\r\ncase CX2341X_ENC_REFRESH_INPUT:\r\nreturn "REFRESH_INPUT";\r\ncase CX2341X_ENC_SET_COPYRIGHT:\r\nreturn "SET_COPYRIGHT";\r\ncase CX2341X_ENC_SET_EVENT_NOTIFICATION:\r\nreturn "SET_EVENT_NOTIFICATION";\r\ncase CX2341X_ENC_SET_NUM_VSYNC_LINES:\r\nreturn "SET_NUM_VSYNC_LINES";\r\ncase CX2341X_ENC_SET_PLACEHOLDER:\r\nreturn "SET_PLACEHOLDER";\r\ncase CX2341X_ENC_MUTE_VIDEO:\r\nreturn "MUTE_VIDEO";\r\ncase CX2341X_ENC_MUTE_AUDIO:\r\nreturn "MUTE_AUDIO";\r\ncase CX2341X_ENC_MISC:\r\nreturn "MISC";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int cx23885_mbox_func(void *priv,\r\nu32 command,\r\nint in,\r\nint out,\r\nu32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nstruct cx23885_dev *dev = priv;\r\nunsigned long timeout;\r\nu32 value, flag, retval = 0;\r\nint i;\r\ndprintk(3, "%s: command(0x%X) = %s\n", __func__, command,\r\ncmd_to_str(command));\r\nmc417_memory_read(dev, dev->cx23417_mailbox - 4, &value);\r\nif (value != 0x12345678) {\r\npr_err("Firmware and/or mailbox pointer not initialized or corrupted, signature = 0x%x, cmd = %s\n",\r\nvalue, cmd_to_str(command));\r\nreturn -1;\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (flag) {\r\npr_err("ERROR: Mailbox appears to be in use (%x), cmd = %s\n",\r\nflag, cmd_to_str(command));\r\nreturn -1;\r\n}\r\nflag |= 1;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 1, command);\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 3,\r\nIVTV_API_STD_TIMEOUT);\r\nfor (i = 0; i < in; i++) {\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, data[i]);\r\ndprintk(3, "API Input %d = %d\n", i, data[i]);\r\n}\r\nfor (; i < CX2341X_MBOX_MAX_DATA; i++)\r\nmc417_memory_write(dev, dev->cx23417_mailbox + 4 + i, 0);\r\nflag |= 3;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nfor (;;) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox, &flag);\r\nif (0 != (flag & 4))\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\npr_err("ERROR: API Mailbox timeout\n");\r\nreturn -1;\r\n}\r\nudelay(10);\r\n}\r\nfor (i = 0; i < out; i++) {\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 4 + i, data + i);\r\ndprintk(3, "API Output %d = %d\n", i, data[i]);\r\n}\r\nmc417_memory_read(dev, dev->cx23417_mailbox + 2, &retval);\r\ndprintk(3, "API result = %d\n", retval);\r\nflag = 0;\r\nmc417_memory_write(dev, dev->cx23417_mailbox, flag);\r\nreturn retval;\r\n}\r\nstatic int cx23885_api_cmd(struct cx23885_dev *dev,\r\nu32 command,\r\nu32 inputcnt,\r\nu32 outputcnt,\r\n...)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nva_list vargs;\r\nint i, err;\r\ndprintk(3, "%s() cmds = 0x%08x\n", __func__, command);\r\nva_start(vargs, outputcnt);\r\nfor (i = 0; i < inputcnt; i++)\r\ndata[i] = va_arg(vargs, int);\r\nerr = cx23885_mbox_func(dev, command, inputcnt, outputcnt, data);\r\nfor (i = 0; i < outputcnt; i++) {\r\nint *vptr = va_arg(vargs, int *);\r\n*vptr = data[i];\r\n}\r\nva_end(vargs);\r\nreturn err;\r\n}\r\nstatic int cx23885_api_func(void *priv, u32 cmd, int in, int out, u32 data[CX2341X_MBOX_MAX_DATA])\r\n{\r\nreturn cx23885_mbox_func(priv, cmd, in, out, data);\r\n}\r\nstatic int cx23885_find_mailbox(struct cx23885_dev *dev)\r\n{\r\nu32 signature[4] = {\r\n0x12345678, 0x34567812, 0x56781234, 0x78123456\r\n};\r\nint signaturecnt = 0;\r\nu32 value;\r\nint i;\r\ndprintk(2, "%s()\n", __func__);\r\nfor (i = 0; i < CX23885_FIRM_IMAGE_SIZE; i++) {\r\nmc417_memory_read(dev, i, &value);\r\nif (value == signature[signaturecnt])\r\nsignaturecnt++;\r\nelse\r\nsignaturecnt = 0;\r\nif (4 == signaturecnt) {\r\ndprintk(1, "Mailbox signature found at 0x%x\n", i+1);\r\nreturn i+1;\r\n}\r\n}\r\npr_err("Mailbox signature values not found!\n");\r\nreturn -1;\r\n}\r\nstatic int cx23885_load_firmware(struct cx23885_dev *dev)\r\n{\r\nstatic const unsigned char magic[8] = {\r\n0xa7, 0x0d, 0x00, 0x00, 0x66, 0xbb, 0x55, 0xaa\r\n};\r\nconst struct firmware *firmware;\r\nint i, retval = 0;\r\nu32 value = 0;\r\nu32 gpio_output = 0;\r\nu32 gpio_value;\r\nu32 checksum = 0;\r\nu32 *dataptr;\r\ndprintk(2, "%s()\n", __func__);\r\nretval |= mc417_memory_read(dev, 0x9020, &gpio_output);\r\nretval |= mc417_memory_read(dev, 0x900C, &gpio_value);\r\nretval = mc417_register_write(dev,\r\nIVTV_REG_VPU, 0xFFFFFFED);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_HW_BLOCKS, IVTV_CMD_HW_BLOCKS_RST);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_REFRESH, 0x80000800);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_ENC_SDRAM_PRECHARGE, 0x1A);\r\nretval |= mc417_register_write(dev,\r\nIVTV_REG_APU, 0);\r\nif (retval != 0) {\r\npr_err("%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nretval = request_firmware(&firmware, CX23885_FIRM_IMAGE_NAME,\r\n&dev->pci->dev);\r\nif (retval != 0) {\r\npr_err("ERROR: Hotplug firmware request failed (%s).\n",\r\nCX23885_FIRM_IMAGE_NAME);\r\npr_err("Please fix your hotplug setup, the board will not work without firmware loaded!\n");\r\nreturn -1;\r\n}\r\nif (firmware->size != CX23885_FIRM_IMAGE_SIZE) {\r\npr_err("ERROR: Firmware size mismatch (have %zu, expected %d)\n",\r\nfirmware->size, CX23885_FIRM_IMAGE_SIZE);\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nif (0 != memcmp(firmware->data, magic, 8)) {\r\npr_err("ERROR: Firmware magic mismatch, wrong file?\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ndprintk(2, "Loading firmware ...\n");\r\ndataptr = (u32 *)firmware->data;\r\nfor (i = 0; i < (firmware->size >> 2); i++) {\r\nvalue = *dataptr;\r\nchecksum += ~value;\r\nif (mc417_memory_write(dev, i, value) != 0) {\r\npr_err("ERROR: Loading firmware failed!\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\ndataptr++;\r\n}\r\ndprintk(1, "Verifying firmware ...\n");\r\nfor (i--; i >= 0; i--) {\r\nif (mc417_memory_read(dev, i, &value) != 0) {\r\npr_err("ERROR: Reading firmware failed!\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nchecksum -= ~value;\r\n}\r\nif (checksum) {\r\npr_err("ERROR: Firmware load failed (checksum mismatch).\n");\r\nrelease_firmware(firmware);\r\nreturn -1;\r\n}\r\nrelease_firmware(firmware);\r\ndprintk(1, "Firmware upload successful.\n");\r\nretval |= mc417_register_write(dev, IVTV_REG_HW_BLOCKS,\r\nIVTV_CMD_HW_BLOCKS_RST);\r\nretval |= mc417_register_write(dev, 0x9020, gpio_output);\r\nretval |= mc417_register_write(dev, 0x900C, gpio_value);\r\nretval |= mc417_register_read(dev, IVTV_REG_VPU, &value);\r\nretval |= mc417_register_write(dev, IVTV_REG_VPU, value & 0xFFFFFFE8);\r\nretval |= mc417_register_write(dev, 0x9020, 0x4000);\r\nretval |= mc417_register_write(dev, 0x900C, 0x4000);\r\nmc417_register_read(dev, 0x9020, &gpio_output);\r\nmc417_register_read(dev, 0x900C, &gpio_value);\r\nif (retval < 0)\r\npr_err("%s: Error with mc417_register_write\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nvoid cx23885_417_check_encoder(struct cx23885_dev *dev)\r\n{\r\nu32 status, seq;\r\nstatus = seq = 0;\r\ncx23885_api_cmd(dev, CX2341X_ENC_GET_SEQ_END, 0, 2, &status, &seq);\r\ndprintk(1, "%s() status = %d, seq = %d\n", __func__, status, seq);\r\n}\r\nstatic void cx23885_codec_settings(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (dev->encodernorm.id & V4L2_STD_525_60)\r\ndev->ts1.height = 480;\r\nelse\r\ndev->ts1.height = 576;\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_FRAME_SIZE, 2, 0,\r\ndev->ts1.height, dev->ts1.width);\r\ndev->cxhdl.width = dev->ts1.width;\r\ndev->cxhdl.height = dev->ts1.height;\r\ndev->cxhdl.is_50hz =\r\n(dev->encodernorm.id & V4L2_STD_625_50) != 0;\r\ncx2341x_handler_setup(&dev->cxhdl);\r\ncx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 3, 1);\r\ncx23885_api_cmd(dev, CX2341X_ENC_MISC, 2, 0, 4, 1);\r\n}\r\nstatic int cx23885_initialize_codec(struct cx23885_dev *dev, int startencoder)\r\n{\r\nint version;\r\nint retval;\r\nu32 i, data[7];\r\ndprintk(1, "%s()\n", __func__);\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\ndprintk(2, "%s() PING OK\n", __func__);\r\nretval = cx23885_load_firmware(dev);\r\nif (retval < 0) {\r\npr_err("%s() f/w load failed\n", __func__);\r\nreturn retval;\r\n}\r\nretval = cx23885_find_mailbox(dev);\r\nif (retval < 0) {\r\npr_err("%s() mailbox < 0, error\n",\r\n__func__);\r\nreturn -1;\r\n}\r\ndev->cx23417_mailbox = retval;\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_PING_FW, 0, 0);\r\nif (retval < 0) {\r\npr_err("ERROR: cx23417 firmware ping failed!\n");\r\nreturn -1;\r\n}\r\nretval = cx23885_api_cmd(dev, CX2341X_ENC_GET_VERSION, 0, 1,\r\n&version);\r\nif (retval < 0) {\r\npr_err("ERROR: cx23417 firmware get encoder :version failed!\n");\r\nreturn -1;\r\n}\r\ndprintk(1, "cx23417 firmware version is 0x%08x\n", version);\r\nmsleep(200);\r\n}\r\ncx23885_codec_settings(dev);\r\nmsleep(60);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_NUM_VSYNC_LINES, 2, 0,\r\nCX23885_FIELD1_SAA7115, CX23885_FIELD2_SAA7115);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_PLACEHOLDER, 12, 0,\r\nCX23885_CUSTOM_EXTENSION_USR_DATA, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0);\r\ndata[0] = 0x0001BD00;\r\ndata[1] = 1;\r\ndata[2] = 4;\r\ndata[3] = 0x91559155;\r\ndata[4] = 0x206080C0;\r\ndata[5] = 6;\r\ndata[6] = 64;\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_CONFIG, 7, 0, data[0], data[1],\r\ndata[2], data[3], data[4], data[5], data[6]);\r\nfor (i = 2; i <= 24; i++) {\r\nint valid;\r\nvalid = ((i >= 19) && (i <= 21));\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0, i,\r\nvalid, 0 , 0, 0);\r\ncx23885_api_cmd(dev, CX2341X_ENC_SET_VBI_LINE, 5, 0,\r\ni | 0x80000000, valid, 0, 0, 0);\r\n}\r\ncx23885_api_cmd(dev, CX2341X_ENC_MUTE_AUDIO, 1, 0, CX23885_UNMUTE);\r\nmsleep(60);\r\ncx23885_api_cmd(dev, CX2341X_ENC_INITIALIZE_INPUT, 0, 0);\r\nmsleep(60);\r\nmc417_memory_write(dev, 2120, 0x00000080);\r\nif (startencoder) {\r\ncx23885_api_cmd(dev, CX2341X_ENC_START_CAPTURE, 2, 0,\r\nCX23885_MPEG_CAPTURE, CX23885_RAW_BITS_NONE);\r\nmsleep(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *q,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\ndev->ts1.ts_packet_size = mpeglinesize;\r\ndev->ts1.ts_packet_count = mpeglines;\r\n*num_planes = 1;\r\nsizes[0] = mpeglinesize * mpeglines;\r\n*num_buffers = mpegbufs;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf =\r\ncontainer_of(vbuf, struct cx23885_buffer, vb);\r\nreturn cx23885_buf_prepare(buf, &dev->ts1);\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf = container_of(vbuf,\r\nstruct cx23885_buffer, vb);\r\ncx23885_free_buffer(dev, buf);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf = container_of(vbuf,\r\nstruct cx23885_buffer, vb);\r\ncx23885_buf_queue(&dev->ts1, buf);\r\n}\r\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\nstruct cx23885_dmaqueue *dmaq = &dev->ts1.mpegq;\r\nunsigned long flags;\r\nint ret;\r\nret = cx23885_initialize_codec(dev, 1);\r\nif (ret == 0) {\r\nstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx23885_buffer, queue);\r\ncx23885_start_dma(&dev->ts1, dmaq, buf);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&dmaq->active)) {\r\nstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx23885_buffer, queue);\r\nlist_del(&buf->queue);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn ret;\r\n}\r\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\ncx23885_api_cmd(dev, CX2341X_ENC_STOP_CAPTURE, 3, 0,\r\nCX23885_END_NOW, CX23885_MPEG_CAPTURE,\r\nCX23885_RAW_BITS_NONE);\r\nmsleep(500);\r\ncx23885_417_check_encoder(dev);\r\ncx23885_cancel_buffers(&dev->ts1);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\n*id = dev->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(cx23885_tvnorms); i++)\r\nif (id & cx23885_tvnorms[i].id)\r\nbreak;\r\nif (i == ARRAY_SIZE(cx23885_tvnorms))\r\nreturn -EINVAL;\r\nret = cx23885_set_tvnorm(dev, id);\r\nif (!ret)\r\ndev->encodernorm = cx23885_tvnorms[i];\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s()\n", __func__);\r\nreturn cx23885_enum_input(dev, i);\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nreturn cx23885_get_input(file, priv, i);\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn cx23885_set_input(file, priv, i);\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\ncall_all(dev, tuner, g_tuner, t);\r\ndprintk(1, "VIDIOC_G_TUNER: tuner type %d\n", t->type);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->freq;\r\ncall_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nreturn cx23885_set_frequency(file, priv, f);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct cx23885_tsport *tsport = &dev->ts1;\r\nstrlcpy(cap->driver, dev->name, sizeof(cap->driver));\r\nstrlcpy(cap->card, cx23885_boards[tsport->dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCIe:%s", pci_name(dev->pci));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_AUDIO | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.width = dev->ts1.width;\r\nf->fmt.pix.height = dev->ts1.height;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\ndprintk(1, "VIDIOC_G_FMT: w: %d, h: %d\n",\r\ndev->ts1.width, dev->ts1.height);\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\ndprintk(1, "VIDIOC_TRY_FMT: w: %d, h: %d\n",\r\ndev->ts1.width, dev->ts1.height);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\ndev->ts1.ts_packet_size * dev->ts1.ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\ndprintk(1, "VIDIOC_S_FMT: w: %d, h: %d, f: %d\n",\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nchar name[32 + 2];\r\nsnprintf(name, sizeof(name), "%s/2", dev->name);\r\ncall_all(dev, core, log_status);\r\nv4l2_ctrl_handler_log_status(&dev->cxhdl.hdl, name);\r\nreturn 0;\r\n}\r\nvoid cx23885_417_unregister(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nif (dev->v4l_device) {\r\nif (video_is_registered(dev->v4l_device))\r\nvideo_unregister_device(dev->v4l_device);\r\nelse\r\nvideo_device_release(dev->v4l_device);\r\nv4l2_ctrl_handler_free(&dev->cxhdl.hdl);\r\ndev->v4l_device = NULL;\r\n}\r\n}\r\nstatic struct video_device *cx23885_video_dev_alloc(\r\nstruct cx23885_tsport *tsport,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\nstruct cx23885_dev *dev = tsport->dev;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s (%s)",\r\ncx23885_boards[tsport->dev->board].name, type);\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nreturn vfd;\r\n}\r\nint cx23885_417_register(struct cx23885_dev *dev)\r\n{\r\nint err = -ENODEV;\r\nstruct cx23885_tsport *tsport = &dev->ts1;\r\nstruct vb2_queue *q;\r\ndprintk(1, "%s()\n", __func__);\r\nif (cx23885_boards[dev->board].portb != CX23885_MPEG_ENCODER)\r\nreturn err;\r\ndev->encodernorm = cx23885_tvnorms[0];\r\nif (dev->encodernorm.id & V4L2_STD_525_60)\r\ntsport->height = 480;\r\nelse\r\ntsport->height = 576;\r\ntsport->width = 720;\r\ndev->cxhdl.port = CX2341X_PORT_SERIAL;\r\nerr = cx2341x_handler_init(&dev->cxhdl, 50);\r\nif (err)\r\nreturn err;\r\ndev->cxhdl.priv = dev;\r\ndev->cxhdl.func = cx23885_api_func;\r\ncx2341x_handler_set_50hz(&dev->cxhdl, tsport->height == 576);\r\nv4l2_ctrl_add_handler(&dev->ctrl_handler, &dev->cxhdl.hdl, NULL);\r\ndev->v4l_device = cx23885_video_dev_alloc(tsport,\r\ndev->pci, &cx23885_mpeg_template, "mpeg");\r\nq = &dev->vb2_mpegq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx23885_buffer);\r\nq->ops = &cx23885_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nq->dev = &dev->pci->dev;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\nreturn err;\r\nvideo_set_drvdata(dev->v4l_device, dev);\r\ndev->v4l_device->lock = &dev->lock;\r\ndev->v4l_device->queue = q;\r\nerr = video_register_device(dev->v4l_device,\r\nVFL_TYPE_GRABBER, -1);\r\nif (err < 0) {\r\npr_info("%s: can't register mpeg device\n", dev->name);\r\nreturn err;\r\n}\r\npr_info("%s: registered device %s [mpeg]\n",\r\ndev->name, video_device_node_name(dev->v4l_device));\r\ncx23885_initialize_codec(dev, 0);\r\nreturn 0;\r\n}
