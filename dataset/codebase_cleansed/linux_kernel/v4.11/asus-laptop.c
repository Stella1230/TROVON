static int write_acpi_int_ret(acpi_handle handle, const char *method, int val,\r\nstruct acpi_buffer *output)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nacpi_status status;\r\nif (!handle)\r\nreturn -1;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = val;\r\nstatus = acpi_evaluate_object(handle, (char *)method, &params, output);\r\nif (status == AE_OK)\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic int write_acpi_int(acpi_handle handle, const char *method, int val)\r\n{\r\nreturn write_acpi_int_ret(handle, method, val, NULL);\r\n}\r\nstatic int acpi_check_handle(acpi_handle handle, const char *method,\r\nacpi_handle *ret)\r\n{\r\nacpi_status status;\r\nif (method == NULL)\r\nreturn -ENODEV;\r\nif (ret)\r\nstatus = acpi_get_handle(handle, (char *)method,\r\nret);\r\nelse {\r\nacpi_handle dummy;\r\nstatus = acpi_get_handle(handle, (char *)method,\r\n&dummy);\r\n}\r\nif (status != AE_OK) {\r\nif (ret)\r\npr_warn("Error finding %s\n", method);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool asus_check_pega_lucid(struct asus_laptop *asus)\r\n{\r\nreturn !strcmp(asus->name, DEVICE_NAME_PEGA) &&\r\n!acpi_check_handle(asus->handle, METHOD_PEGA_ENABLE, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_PEGA_DISABLE, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_PEGA_READ, NULL);\r\n}\r\nstatic int asus_pega_lucid_set(struct asus_laptop *asus, int unit, bool enable)\r\n{\r\nchar *method = enable ? METHOD_PEGA_ENABLE : METHOD_PEGA_DISABLE;\r\nreturn write_acpi_int(asus->handle, method, unit);\r\n}\r\nstatic int pega_acc_axis(struct asus_laptop *asus, int curr, char *method)\r\n{\r\nint i, delta;\r\nunsigned long long val;\r\nfor (i = 0; i < PEGA_ACC_RETRIES; i++) {\r\nacpi_evaluate_integer(asus->handle, method, NULL, &val);\r\ndelta = abs(curr - (short)val);\r\nif (delta < 128 && !(val & ~0xffff))\r\nbreak;\r\n}\r\nreturn clamp_val((short)val, -PEGA_ACC_CLAMP, PEGA_ACC_CLAMP);\r\n}\r\nstatic void pega_accel_poll(struct input_polled_dev *ipd)\r\n{\r\nstruct device *parent = ipd->input->dev.parent;\r\nstruct asus_laptop *asus = dev_get_drvdata(parent);\r\nif (!asus->pega_acc_live) {\r\nasus->pega_acc_live = true;\r\ninput_report_abs(ipd->input, ABS_X, 0);\r\ninput_report_abs(ipd->input, ABS_Y, 0);\r\ninput_report_abs(ipd->input, ABS_Z, 0);\r\ninput_sync(ipd->input);\r\nreturn;\r\n}\r\nasus->pega_acc_x = pega_acc_axis(asus, asus->pega_acc_x, METHOD_XLRX);\r\nasus->pega_acc_y = pega_acc_axis(asus, asus->pega_acc_y, METHOD_XLRY);\r\nasus->pega_acc_z = pega_acc_axis(asus, asus->pega_acc_z, METHOD_XLRZ);\r\ninput_report_abs(ipd->input, ABS_X, -asus->pega_acc_x);\r\ninput_report_abs(ipd->input, ABS_Y, -asus->pega_acc_y);\r\ninput_report_abs(ipd->input, ABS_Z, asus->pega_acc_z);\r\ninput_sync(ipd->input);\r\n}\r\nstatic void pega_accel_exit(struct asus_laptop *asus)\r\n{\r\nif (asus->pega_accel_poll) {\r\ninput_unregister_polled_device(asus->pega_accel_poll);\r\ninput_free_polled_device(asus->pega_accel_poll);\r\n}\r\nasus->pega_accel_poll = NULL;\r\n}\r\nstatic int pega_accel_init(struct asus_laptop *asus)\r\n{\r\nint err;\r\nstruct input_polled_dev *ipd;\r\nif (!asus->is_pega_lucid)\r\nreturn -ENODEV;\r\nif (acpi_check_handle(asus->handle, METHOD_XLRX, NULL) ||\r\nacpi_check_handle(asus->handle, METHOD_XLRY, NULL) ||\r\nacpi_check_handle(asus->handle, METHOD_XLRZ, NULL))\r\nreturn -ENODEV;\r\nipd = input_allocate_polled_device();\r\nif (!ipd)\r\nreturn -ENOMEM;\r\nipd->poll = pega_accel_poll;\r\nipd->poll_interval = 125;\r\nipd->poll_interval_min = 50;\r\nipd->poll_interval_max = 2000;\r\nipd->input->name = PEGA_ACCEL_DESC;\r\nipd->input->phys = PEGA_ACCEL_NAME "/input0";\r\nipd->input->dev.parent = &asus->platform_device->dev;\r\nipd->input->id.bustype = BUS_HOST;\r\nset_bit(EV_ABS, ipd->input->evbit);\r\ninput_set_abs_params(ipd->input, ABS_X,\r\n-PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\r\ninput_set_abs_params(ipd->input, ABS_Y,\r\n-PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\r\ninput_set_abs_params(ipd->input, ABS_Z,\r\n-PEGA_ACC_CLAMP, PEGA_ACC_CLAMP, 0, 0);\r\nerr = input_register_polled_device(ipd);\r\nif (err)\r\ngoto exit;\r\nasus->pega_accel_poll = ipd;\r\nreturn 0;\r\nexit:\r\ninput_free_polled_device(ipd);\r\nreturn err;\r\n}\r\nstatic int asus_led_set(struct asus_laptop *asus, const char *method,\r\nint value)\r\n{\r\nif (!strcmp(method, METHOD_MLED))\r\nvalue = !value;\r\nelse if (!strcmp(method, METHOD_GLED))\r\nvalue = !value + 1;\r\nelse\r\nvalue = !!value;\r\nreturn write_acpi_int(asus->handle, method, value);\r\n}\r\nstatic void asus_led_cdev_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\r\nstruct asus_laptop *asus = led->asus;\r\nled->wk = !!value;\r\nqueue_work(asus->led_workqueue, &led->work);\r\n}\r\nstatic void asus_led_cdev_update(struct work_struct *work)\r\n{\r\nstruct asus_led *led = container_of(work, struct asus_led, work);\r\nstruct asus_laptop *asus = led->asus;\r\nasus_led_set(asus, led->method, led->wk);\r\n}\r\nstatic enum led_brightness asus_led_cdev_get(struct led_classdev *led_cdev)\r\n{\r\nreturn led_cdev->brightness;\r\n}\r\nstatic int asus_kled_lvl(struct asus_laptop *asus)\r\n{\r\nunsigned long long kblv;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nacpi_status rv;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = 2;\r\nrv = acpi_evaluate_integer(asus->handle, METHOD_KBD_LIGHT_GET,\r\n&params, &kblv);\r\nif (ACPI_FAILURE(rv)) {\r\npr_warn("Error reading kled level\n");\r\nreturn -ENODEV;\r\n}\r\nreturn kblv;\r\n}\r\nstatic int asus_kled_set(struct asus_laptop *asus, int kblv)\r\n{\r\nif (kblv > 0)\r\nkblv = (1 << 7) | (kblv & 0x7F);\r\nelse\r\nkblv = 0;\r\nif (write_acpi_int(asus->handle, METHOD_KBD_LIGHT_SET, kblv)) {\r\npr_warn("Keyboard LED display write failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void asus_kled_cdev_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\r\nstruct asus_laptop *asus = led->asus;\r\nled->wk = value;\r\nqueue_work(asus->led_workqueue, &led->work);\r\n}\r\nstatic void asus_kled_cdev_update(struct work_struct *work)\r\n{\r\nstruct asus_led *led = container_of(work, struct asus_led, work);\r\nstruct asus_laptop *asus = led->asus;\r\nasus_kled_set(asus, led->wk);\r\n}\r\nstatic enum led_brightness asus_kled_cdev_get(struct led_classdev *led_cdev)\r\n{\r\nstruct asus_led *led = container_of(led_cdev, struct asus_led, led);\r\nstruct asus_laptop *asus = led->asus;\r\nreturn asus_kled_lvl(asus);\r\n}\r\nstatic void asus_led_exit(struct asus_laptop *asus)\r\n{\r\nif (!IS_ERR_OR_NULL(asus->wled.led.dev))\r\nled_classdev_unregister(&asus->wled.led);\r\nif (!IS_ERR_OR_NULL(asus->bled.led.dev))\r\nled_classdev_unregister(&asus->bled.led);\r\nif (!IS_ERR_OR_NULL(asus->mled.led.dev))\r\nled_classdev_unregister(&asus->mled.led);\r\nif (!IS_ERR_OR_NULL(asus->tled.led.dev))\r\nled_classdev_unregister(&asus->tled.led);\r\nif (!IS_ERR_OR_NULL(asus->pled.led.dev))\r\nled_classdev_unregister(&asus->pled.led);\r\nif (!IS_ERR_OR_NULL(asus->rled.led.dev))\r\nled_classdev_unregister(&asus->rled.led);\r\nif (!IS_ERR_OR_NULL(asus->gled.led.dev))\r\nled_classdev_unregister(&asus->gled.led);\r\nif (!IS_ERR_OR_NULL(asus->kled.led.dev))\r\nled_classdev_unregister(&asus->kled.led);\r\nif (asus->led_workqueue) {\r\ndestroy_workqueue(asus->led_workqueue);\r\nasus->led_workqueue = NULL;\r\n}\r\n}\r\nstatic int asus_led_register(struct asus_laptop *asus,\r\nstruct asus_led *led,\r\nconst char *name, const char *method)\r\n{\r\nstruct led_classdev *led_cdev = &led->led;\r\nif (!method || acpi_check_handle(asus->handle, method, NULL))\r\nreturn 0;\r\nled->asus = asus;\r\nled->method = method;\r\nINIT_WORK(&led->work, asus_led_cdev_update);\r\nled_cdev->name = name;\r\nled_cdev->brightness_set = asus_led_cdev_set;\r\nled_cdev->brightness_get = asus_led_cdev_get;\r\nled_cdev->max_brightness = 1;\r\nreturn led_classdev_register(&asus->platform_device->dev, led_cdev);\r\n}\r\nstatic int asus_led_init(struct asus_laptop *asus)\r\n{\r\nint r = 0;\r\nif (asus->is_pega_lucid)\r\nreturn 0;\r\nasus->led_workqueue = create_singlethread_workqueue("led_workqueue");\r\nif (!asus->led_workqueue)\r\nreturn -ENOMEM;\r\nif (asus->wled_type == TYPE_LED)\r\nr = asus_led_register(asus, &asus->wled, "asus::wlan",\r\nMETHOD_WLAN);\r\nif (r)\r\ngoto error;\r\nif (asus->bled_type == TYPE_LED)\r\nr = asus_led_register(asus, &asus->bled, "asus::bluetooth",\r\nMETHOD_BLUETOOTH);\r\nif (r)\r\ngoto error;\r\nr = asus_led_register(asus, &asus->mled, "asus::mail", METHOD_MLED);\r\nif (r)\r\ngoto error;\r\nr = asus_led_register(asus, &asus->tled, "asus::touchpad", METHOD_TLED);\r\nif (r)\r\ngoto error;\r\nr = asus_led_register(asus, &asus->rled, "asus::record", METHOD_RLED);\r\nif (r)\r\ngoto error;\r\nr = asus_led_register(asus, &asus->pled, "asus::phone", METHOD_PLED);\r\nif (r)\r\ngoto error;\r\nr = asus_led_register(asus, &asus->gled, "asus::gaming", METHOD_GLED);\r\nif (r)\r\ngoto error;\r\nif (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_GET, NULL)) {\r\nstruct asus_led *led = &asus->kled;\r\nstruct led_classdev *cdev = &led->led;\r\nled->asus = asus;\r\nINIT_WORK(&led->work, asus_kled_cdev_update);\r\ncdev->name = "asus::kbd_backlight";\r\ncdev->brightness_set = asus_kled_cdev_set;\r\ncdev->brightness_get = asus_kled_cdev_get;\r\ncdev->max_brightness = 3;\r\nr = led_classdev_register(&asus->platform_device->dev, cdev);\r\n}\r\nerror:\r\nif (r)\r\nasus_led_exit(asus);\r\nreturn r;\r\n}\r\nstatic int asus_read_brightness(struct backlight_device *bd)\r\n{\r\nstruct asus_laptop *asus = bl_get_data(bd);\r\nunsigned long long value;\r\nacpi_status rv;\r\nrv = acpi_evaluate_integer(asus->handle, METHOD_BRIGHTNESS_GET,\r\nNULL, &value);\r\nif (ACPI_FAILURE(rv)) {\r\npr_warn("Error reading brightness\n");\r\nreturn 0;\r\n}\r\nreturn value;\r\n}\r\nstatic int asus_set_brightness(struct backlight_device *bd, int value)\r\n{\r\nstruct asus_laptop *asus = bl_get_data(bd);\r\nif (write_acpi_int(asus->handle, METHOD_BRIGHTNESS_SET, value)) {\r\npr_warn("Error changing brightness\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int update_bl_status(struct backlight_device *bd)\r\n{\r\nint value = bd->props.brightness;\r\nreturn asus_set_brightness(bd, value);\r\n}\r\nstatic int asus_backlight_notify(struct asus_laptop *asus)\r\n{\r\nstruct backlight_device *bd = asus->backlight_device;\r\nint old = bd->props.brightness;\r\nbacklight_force_update(bd, BACKLIGHT_UPDATE_HOTKEY);\r\nreturn old;\r\n}\r\nstatic int asus_backlight_init(struct asus_laptop *asus)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nif (acpi_check_handle(asus->handle, METHOD_BRIGHTNESS_GET, NULL) ||\r\nacpi_check_handle(asus->handle, METHOD_BRIGHTNESS_SET, NULL))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 15;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nbd = backlight_device_register(ASUS_LAPTOP_FILE,\r\n&asus->platform_device->dev, asus,\r\n&asusbl_ops, &props);\r\nif (IS_ERR(bd)) {\r\npr_err("Could not register asus backlight device\n");\r\nasus->backlight_device = NULL;\r\nreturn PTR_ERR(bd);\r\n}\r\nasus->backlight_device = bd;\r\nbd->props.brightness = asus_read_brightness(bd);\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic void asus_backlight_exit(struct asus_laptop *asus)\r\n{\r\nbacklight_device_unregister(asus->backlight_device);\r\nasus->backlight_device = NULL;\r\n}\r\nstatic ssize_t infos_show(struct device *dev, struct device_attribute *attr,\r\nchar *page)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint len = 0;\r\nunsigned long long temp;\r\nchar buf[16];\r\nacpi_status rv;\r\nlen += sprintf(page, ASUS_LAPTOP_NAME " " ASUS_LAPTOP_VERSION "\n");\r\nlen += sprintf(page + len, "Model reference : %s\n", asus->name);\r\nrv = acpi_evaluate_integer(asus->handle, "SFUN", NULL, &temp);\r\nif (!ACPI_FAILURE(rv))\r\nlen += sprintf(page + len, "SFUN value : %#x\n",\r\n(uint) temp);\r\nrv = acpi_evaluate_integer(asus->handle, "HWRS", NULL, &temp);\r\nif (!ACPI_FAILURE(rv))\r\nlen += sprintf(page + len, "HWRS value : %#x\n",\r\n(uint) temp);\r\nrv = acpi_evaluate_integer(asus->handle, "ASYM", NULL, &temp);\r\nif (!ACPI_FAILURE(rv))\r\nlen += sprintf(page + len, "ASYM value : %#x\n",\r\n(uint) temp);\r\nif (asus->dsdt_info) {\r\nsnprintf(buf, 16, "%d", asus->dsdt_info->length);\r\nlen += sprintf(page + len, "DSDT length : %s\n", buf);\r\nsnprintf(buf, 16, "%d", asus->dsdt_info->checksum);\r\nlen += sprintf(page + len, "DSDT checksum : %s\n", buf);\r\nsnprintf(buf, 16, "%d", asus->dsdt_info->revision);\r\nlen += sprintf(page + len, "DSDT revision : %s\n", buf);\r\nsnprintf(buf, 7, "%s", asus->dsdt_info->oem_id);\r\nlen += sprintf(page + len, "OEM id : %s\n", buf);\r\nsnprintf(buf, 9, "%s", asus->dsdt_info->oem_table_id);\r\nlen += sprintf(page + len, "OEM table id : %s\n", buf);\r\nsnprintf(buf, 16, "%x", asus->dsdt_info->oem_revision);\r\nlen += sprintf(page + len, "OEM revision : 0x%s\n", buf);\r\nsnprintf(buf, 5, "%s", asus->dsdt_info->asl_compiler_id);\r\nlen += sprintf(page + len, "ASL comp vendor id : %s\n", buf);\r\nsnprintf(buf, 16, "%x", asus->dsdt_info->asl_compiler_revision);\r\nlen += sprintf(page + len, "ASL comp revision : 0x%s\n", buf);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t sysfs_acpi_set(struct asus_laptop *asus,\r\nconst char *buf, size_t count,\r\nconst char *method)\r\n{\r\nint rv, value;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nif (write_acpi_int(asus->handle, method, value))\r\nreturn -ENODEV;\r\nreturn count;\r\n}\r\nstatic ssize_t ledd_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "0x%08x\n", asus->ledd_status);\r\n}\r\nstatic ssize_t ledd_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nif (write_acpi_int(asus->handle, METHOD_LEDD, value)) {\r\npr_warn("LED display write failed\n");\r\nreturn -ENODEV;\r\n}\r\nasus->ledd_status = (u32) value;\r\nreturn count;\r\n}\r\nstatic int asus_wireless_status(struct asus_laptop *asus, int mask)\r\n{\r\nunsigned long long status;\r\nacpi_status rv = AE_OK;\r\nif (!asus->have_rsts)\r\nreturn (asus->wireless_status & mask) ? 1 : 0;\r\nrv = acpi_evaluate_integer(asus->handle, METHOD_WL_STATUS,\r\nNULL, &status);\r\nif (ACPI_FAILURE(rv)) {\r\npr_warn("Error reading Wireless status\n");\r\nreturn -EINVAL;\r\n}\r\nreturn !!(status & mask);\r\n}\r\nstatic int asus_wlan_set(struct asus_laptop *asus, int status)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_WLAN, !!status)) {\r\npr_warn("Error setting wlan status to %d\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t wlan_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus_wireless_status(asus, WL_RSTS));\r\n}\r\nstatic ssize_t wlan_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sysfs_acpi_set(asus, buf, count, METHOD_WLAN);\r\n}\r\nstatic int asus_bluetooth_set(struct asus_laptop *asus, int status)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_BLUETOOTH, !!status)) {\r\npr_warn("Error setting bluetooth status to %d\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t bluetooth_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus_wireless_status(asus, BT_RSTS));\r\n}\r\nstatic ssize_t bluetooth_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sysfs_acpi_set(asus, buf, count, METHOD_BLUETOOTH);\r\n}\r\nstatic int asus_wimax_set(struct asus_laptop *asus, int status)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_WIMAX, !!status)) {\r\npr_warn("Error setting wimax status to %d\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t wimax_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus_wireless_status(asus, WM_RSTS));\r\n}\r\nstatic ssize_t wimax_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sysfs_acpi_set(asus, buf, count, METHOD_WIMAX);\r\n}\r\nstatic int asus_wwan_set(struct asus_laptop *asus, int status)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_WWAN, !!status)) {\r\npr_warn("Error setting wwan status to %d\n", status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t wwan_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus_wireless_status(asus, WW_RSTS));\r\n}\r\nstatic ssize_t wwan_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sysfs_acpi_set(asus, buf, count, METHOD_WWAN);\r\n}\r\nstatic void asus_set_display(struct asus_laptop *asus, int value)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_SWITCH_DISPLAY, value))\r\npr_warn("Error setting display\n");\r\nreturn;\r\n}\r\nstatic ssize_t display_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nasus_set_display(asus, value);\r\nreturn count;\r\n}\r\nstatic void asus_als_switch(struct asus_laptop *asus, int value)\r\n{\r\nint ret;\r\nif (asus->is_pega_lucid) {\r\nret = asus_pega_lucid_set(asus, PEGA_ALS, value);\r\nif (!ret)\r\nret = asus_pega_lucid_set(asus, PEGA_ALS_POWER, value);\r\n} else {\r\nret = write_acpi_int(asus->handle, METHOD_ALS_CONTROL, value);\r\n}\r\nif (ret)\r\npr_warning("Error setting light sensor switch\n");\r\nasus->light_switch = value;\r\n}\r\nstatic ssize_t ls_switch_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus->light_switch);\r\n}\r\nstatic ssize_t ls_switch_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nasus_als_switch(asus, value ? 1 : 0);\r\nreturn count;\r\n}\r\nstatic void asus_als_level(struct asus_laptop *asus, int value)\r\n{\r\nif (write_acpi_int(asus->handle, METHOD_ALS_LEVEL, value))\r\npr_warn("Error setting light sensor level\n");\r\nasus->light_level = value;\r\n}\r\nstatic ssize_t ls_level_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus->light_level);\r\n}\r\nstatic ssize_t ls_level_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint rv, value;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nvalue = (0 < value) ? ((15 < value) ? 15 : value) : 0;\r\nasus_als_level(asus, value);\r\nreturn count;\r\n}\r\nstatic int pega_int_read(struct asus_laptop *asus, int arg, int *result)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nint err = write_acpi_int_ret(asus->handle, METHOD_PEGA_READ, arg,\r\n&buffer);\r\nif (!err) {\r\nunion acpi_object *obj = buffer.pointer;\r\nif (obj && obj->type == ACPI_TYPE_INTEGER)\r\n*result = obj->integer.value;\r\nelse\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t ls_value_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint err, hi, lo;\r\nerr = pega_int_read(asus, PEGA_READ_ALS_H, &hi);\r\nif (!err)\r\nerr = pega_int_read(asus, PEGA_READ_ALS_L, &lo);\r\nif (!err)\r\nreturn sprintf(buf, "%d\n", 10 * hi + lo);\r\nreturn err;\r\n}\r\nstatic int asus_gps_status(struct asus_laptop *asus)\r\n{\r\nunsigned long long status;\r\nacpi_status rv;\r\nrv = acpi_evaluate_integer(asus->handle, METHOD_GPS_STATUS,\r\nNULL, &status);\r\nif (ACPI_FAILURE(rv)) {\r\npr_warn("Error reading GPS status\n");\r\nreturn -ENODEV;\r\n}\r\nreturn !!status;\r\n}\r\nstatic int asus_gps_switch(struct asus_laptop *asus, int status)\r\n{\r\nconst char *meth = status ? METHOD_GPS_ON : METHOD_GPS_OFF;\r\nif (write_acpi_int(asus->handle, meth, 0x02))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic ssize_t gps_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", asus_gps_status(asus));\r\n}\r\nstatic ssize_t gps_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asus_laptop *asus = dev_get_drvdata(dev);\r\nint rv, value;\r\nint ret;\r\nrv = kstrtoint(buf, 0, &value);\r\nif (rv < 0)\r\nreturn rv;\r\nret = asus_gps_switch(asus, !!value);\r\nif (ret)\r\nreturn ret;\r\nrfkill_set_sw_state(asus->gps.rfkill, !value);\r\nreturn count;\r\n}\r\nstatic int asus_gps_rfkill_set(void *data, bool blocked)\r\n{\r\nstruct asus_laptop *asus = data;\r\nreturn asus_gps_switch(asus, !blocked);\r\n}\r\nstatic int asus_rfkill_set(void *data, bool blocked)\r\n{\r\nstruct asus_rfkill *rfk = data;\r\nstruct asus_laptop *asus = rfk->asus;\r\nif (rfk->control_id == WL_RSTS)\r\nreturn asus_wlan_set(asus, !blocked);\r\nelse if (rfk->control_id == BT_RSTS)\r\nreturn asus_bluetooth_set(asus, !blocked);\r\nelse if (rfk->control_id == WM_RSTS)\r\nreturn asus_wimax_set(asus, !blocked);\r\nelse if (rfk->control_id == WW_RSTS)\r\nreturn asus_wwan_set(asus, !blocked);\r\nreturn -EINVAL;\r\n}\r\nstatic void asus_rfkill_terminate(struct asus_rfkill *rfk)\r\n{\r\nif (!rfk->rfkill)\r\nreturn ;\r\nrfkill_unregister(rfk->rfkill);\r\nrfkill_destroy(rfk->rfkill);\r\nrfk->rfkill = NULL;\r\n}\r\nstatic void asus_rfkill_exit(struct asus_laptop *asus)\r\n{\r\nasus_rfkill_terminate(&asus->wwan);\r\nasus_rfkill_terminate(&asus->bluetooth);\r\nasus_rfkill_terminate(&asus->wlan);\r\nasus_rfkill_terminate(&asus->gps);\r\n}\r\nstatic int asus_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,\r\nconst char *name, int control_id, int type,\r\nconst struct rfkill_ops *ops)\r\n{\r\nint result;\r\nrfk->control_id = control_id;\r\nrfk->asus = asus;\r\nrfk->rfkill = rfkill_alloc(name, &asus->platform_device->dev,\r\ntype, ops, rfk);\r\nif (!rfk->rfkill)\r\nreturn -EINVAL;\r\nresult = rfkill_register(rfk->rfkill);\r\nif (result) {\r\nrfkill_destroy(rfk->rfkill);\r\nrfk->rfkill = NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic int asus_rfkill_init(struct asus_laptop *asus)\r\n{\r\nint result = 0;\r\nif (asus->is_pega_lucid)\r\nreturn -ENODEV;\r\nif (!acpi_check_handle(asus->handle, METHOD_GPS_ON, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_GPS_OFF, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_GPS_STATUS, NULL))\r\nresult = asus_rfkill_setup(asus, &asus->gps, "asus-gps",\r\n-1, RFKILL_TYPE_GPS,\r\n&asus_gps_rfkill_ops);\r\nif (result)\r\ngoto exit;\r\nif (!acpi_check_handle(asus->handle, METHOD_WLAN, NULL) &&\r\nasus->wled_type == TYPE_RFKILL)\r\nresult = asus_rfkill_setup(asus, &asus->wlan, "asus-wlan",\r\nWL_RSTS, RFKILL_TYPE_WLAN,\r\n&asus_rfkill_ops);\r\nif (result)\r\ngoto exit;\r\nif (!acpi_check_handle(asus->handle, METHOD_BLUETOOTH, NULL) &&\r\nasus->bled_type == TYPE_RFKILL)\r\nresult = asus_rfkill_setup(asus, &asus->bluetooth,\r\n"asus-bluetooth", BT_RSTS,\r\nRFKILL_TYPE_BLUETOOTH,\r\n&asus_rfkill_ops);\r\nif (result)\r\ngoto exit;\r\nif (!acpi_check_handle(asus->handle, METHOD_WWAN, NULL))\r\nresult = asus_rfkill_setup(asus, &asus->wwan, "asus-wwan",\r\nWW_RSTS, RFKILL_TYPE_WWAN,\r\n&asus_rfkill_ops);\r\nif (result)\r\ngoto exit;\r\nif (!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL))\r\nresult = asus_rfkill_setup(asus, &asus->wimax, "asus-wimax",\r\nWM_RSTS, RFKILL_TYPE_WIMAX,\r\n&asus_rfkill_ops);\r\nif (result)\r\ngoto exit;\r\nexit:\r\nif (result)\r\nasus_rfkill_exit(asus);\r\nreturn result;\r\n}\r\nstatic int pega_rfkill_set(void *data, bool blocked)\r\n{\r\nstruct asus_rfkill *rfk = data;\r\nint ret = asus_pega_lucid_set(rfk->asus, rfk->control_id, !blocked);\r\nreturn ret;\r\n}\r\nstatic int pega_rfkill_setup(struct asus_laptop *asus, struct asus_rfkill *rfk,\r\nconst char *name, int controlid, int rfkill_type)\r\n{\r\nreturn asus_rfkill_setup(asus, rfk, name, controlid, rfkill_type,\r\n&pega_rfkill_ops);\r\n}\r\nstatic int pega_rfkill_init(struct asus_laptop *asus)\r\n{\r\nint ret = 0;\r\nif(!asus->is_pega_lucid)\r\nreturn -ENODEV;\r\nret = pega_rfkill_setup(asus, &asus->wlan, "pega-wlan",\r\nPEGA_WLAN, RFKILL_TYPE_WLAN);\r\nif(ret)\r\ngoto exit;\r\nret = pega_rfkill_setup(asus, &asus->bluetooth, "pega-bt",\r\nPEGA_BLUETOOTH, RFKILL_TYPE_BLUETOOTH);\r\nif(ret)\r\ngoto exit;\r\nret = pega_rfkill_setup(asus, &asus->wwan, "pega-wwan",\r\nPEGA_WWAN, RFKILL_TYPE_WWAN);\r\nexit:\r\nif (ret)\r\nasus_rfkill_exit(asus);\r\nreturn ret;\r\n}\r\nstatic void asus_input_notify(struct asus_laptop *asus, int event)\r\n{\r\nif (!asus->inputdev)\r\nreturn ;\r\nif (!sparse_keymap_report_event(asus->inputdev, event, 1, true))\r\npr_info("Unknown key %x pressed\n", event);\r\n}\r\nstatic int asus_input_init(struct asus_laptop *asus)\r\n{\r\nstruct input_dev *input;\r\nint error;\r\ninput = input_allocate_device();\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = "Asus Laptop extra buttons";\r\ninput->phys = ASUS_LAPTOP_FILE "/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &asus->platform_device->dev;\r\nerror = sparse_keymap_setup(input, asus_keymap, NULL);\r\nif (error) {\r\npr_err("Unable to setup input device keymap\n");\r\ngoto err_free_dev;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\npr_warn("Unable to register input device\n");\r\ngoto err_free_keymap;\r\n}\r\nasus->inputdev = input;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(input);\r\nerr_free_dev:\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\nstatic void asus_input_exit(struct asus_laptop *asus)\r\n{\r\nif (asus->inputdev) {\r\nsparse_keymap_free(asus->inputdev);\r\ninput_unregister_device(asus->inputdev);\r\n}\r\nasus->inputdev = NULL;\r\n}\r\nstatic void asus_acpi_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct asus_laptop *asus = acpi_driver_data(device);\r\nu16 count;\r\ncount = asus->event_count[event % 128]++;\r\nacpi_bus_generate_netlink_event(asus->device->pnp.device_class,\r\ndev_name(&asus->device->dev), event,\r\ncount);\r\nif (event >= ATKD_BRNUP_MIN && event <= ATKD_BRNUP_MAX)\r\nevent = ATKD_BRNUP;\r\nelse if (event >= ATKD_BRNDOWN_MIN &&\r\nevent <= ATKD_BRNDOWN_MAX)\r\nevent = ATKD_BRNDOWN;\r\nif (event == ATKD_BRNDOWN || event == ATKD_BRNUP) {\r\nif (asus->backlight_device != NULL) {\r\nasus_backlight_notify(asus);\r\nreturn ;\r\n}\r\n}\r\nif (asus->pega_accel_poll && event == 0xEA) {\r\nkobject_uevent(&asus->pega_accel_poll->input->dev.kobj,\r\nKOBJ_CHANGE);\r\nreturn ;\r\n}\r\nasus_input_notify(asus, event);\r\n}\r\nstatic umode_t asus_sysfs_is_visible(struct kobject *kobj,\r\nstruct attribute *attr,\r\nint idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct asus_laptop *asus = platform_get_drvdata(pdev);\r\nacpi_handle handle = asus->handle;\r\nbool supported;\r\nif (asus->is_pega_lucid) {\r\nif (attr == &dev_attr_ls_switch.attr)\r\nsupported = true;\r\nelse if (attr == &dev_attr_ls_level.attr)\r\nsupported = false;\r\nelse\r\ngoto normal;\r\nreturn supported ? attr->mode : 0;\r\n}\r\nnormal:\r\nif (attr == &dev_attr_wlan.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_WLAN, NULL);\r\n} else if (attr == &dev_attr_bluetooth.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_BLUETOOTH, NULL);\r\n} else if (attr == &dev_attr_display.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_SWITCH_DISPLAY, NULL);\r\n} else if (attr == &dev_attr_wimax.attr) {\r\nsupported =\r\n!acpi_check_handle(asus->handle, METHOD_WIMAX, NULL);\r\n} else if (attr == &dev_attr_wwan.attr) {\r\nsupported = !acpi_check_handle(asus->handle, METHOD_WWAN, NULL);\r\n} else if (attr == &dev_attr_ledd.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_LEDD, NULL);\r\n} else if (attr == &dev_attr_ls_switch.attr ||\r\nattr == &dev_attr_ls_level.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_ALS_CONTROL, NULL) &&\r\n!acpi_check_handle(handle, METHOD_ALS_LEVEL, NULL);\r\n} else if (attr == &dev_attr_ls_value.attr) {\r\nsupported = asus->is_pega_lucid;\r\n} else if (attr == &dev_attr_gps.attr) {\r\nsupported = !acpi_check_handle(handle, METHOD_GPS_ON, NULL) &&\r\n!acpi_check_handle(handle, METHOD_GPS_OFF, NULL) &&\r\n!acpi_check_handle(handle, METHOD_GPS_STATUS, NULL);\r\n} else {\r\nsupported = true;\r\n}\r\nreturn supported ? attr->mode : 0;\r\n}\r\nstatic int asus_platform_init(struct asus_laptop *asus)\r\n{\r\nint result;\r\nasus->platform_device = platform_device_alloc(ASUS_LAPTOP_FILE, -1);\r\nif (!asus->platform_device)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(asus->platform_device, asus);\r\nresult = platform_device_add(asus->platform_device);\r\nif (result)\r\ngoto fail_platform_device;\r\nresult = sysfs_create_group(&asus->platform_device->dev.kobj,\r\n&asus_attr_group);\r\nif (result)\r\ngoto fail_sysfs;\r\nreturn 0;\r\nfail_sysfs:\r\nplatform_device_del(asus->platform_device);\r\nfail_platform_device:\r\nplatform_device_put(asus->platform_device);\r\nreturn result;\r\n}\r\nstatic void asus_platform_exit(struct asus_laptop *asus)\r\n{\r\nsysfs_remove_group(&asus->platform_device->dev.kobj, &asus_attr_group);\r\nplatform_device_unregister(asus->platform_device);\r\n}\r\nstatic int asus_laptop_get_info(struct asus_laptop *asus)\r\n{\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *model = NULL;\r\nunsigned long long bsts_result;\r\nchar *string = NULL;\r\nacpi_status status;\r\nstatus = acpi_get_table(ACPI_SIG_DSDT, 1, &asus->dsdt_info);\r\nif (ACPI_FAILURE(status))\r\npr_warn("Couldn't get the DSDT table header\n");\r\nif (write_acpi_int_ret(asus->handle, "INIT", 0, &buffer)) {\r\npr_err("Hotkey initialization failed\n");\r\nreturn -ENODEV;\r\n}\r\nstatus =\r\nacpi_evaluate_integer(asus->handle, "BSTS", NULL, &bsts_result);\r\nif (ACPI_FAILURE(status))\r\npr_warn("Error calling BSTS\n");\r\nelse if (bsts_result)\r\npr_notice("BSTS called, 0x%02x returned\n",\r\n(uint) bsts_result);\r\nif (write_acpi_int(asus->handle, "CWAP", wapf))\r\npr_err("Error calling CWAP(%d)\n", wapf);\r\nif (buffer.pointer) {\r\nmodel = buffer.pointer;\r\nswitch (model->type) {\r\ncase ACPI_TYPE_STRING:\r\nstring = model->string.pointer;\r\nbreak;\r\ncase ACPI_TYPE_BUFFER:\r\nstring = model->buffer.pointer;\r\nbreak;\r\ndefault:\r\nstring = "";\r\nbreak;\r\n}\r\n}\r\nasus->name = kstrdup(string, GFP_KERNEL);\r\nif (!asus->name) {\r\nkfree(buffer.pointer);\r\nreturn -ENOMEM;\r\n}\r\nif (string)\r\npr_notice(" %s model detected\n", string);\r\nif (!acpi_check_handle(asus->handle, METHOD_WL_STATUS, NULL))\r\nasus->have_rsts = true;\r\nkfree(model);\r\nreturn AE_OK;\r\n}\r\nstatic int asus_acpi_init(struct asus_laptop *asus)\r\n{\r\nint result = 0;\r\nresult = acpi_bus_get_status(asus->device);\r\nif (result)\r\nreturn result;\r\nif (!asus->device->status.present) {\r\npr_err("Hotkey device not present, aborting\n");\r\nreturn -ENODEV;\r\n}\r\nresult = asus_laptop_get_info(asus);\r\nif (result)\r\nreturn result;\r\nif (!strcmp(bled_type, "led"))\r\nasus->bled_type = TYPE_LED;\r\nelse if (!strcmp(bled_type, "rfkill"))\r\nasus->bled_type = TYPE_RFKILL;\r\nif (!strcmp(wled_type, "led"))\r\nasus->wled_type = TYPE_LED;\r\nelse if (!strcmp(wled_type, "rfkill"))\r\nasus->wled_type = TYPE_RFKILL;\r\nif (bluetooth_status >= 0)\r\nasus_bluetooth_set(asus, !!bluetooth_status);\r\nif (wlan_status >= 0)\r\nasus_wlan_set(asus, !!wlan_status);\r\nif (wimax_status >= 0)\r\nasus_wimax_set(asus, !!wimax_status);\r\nif (wwan_status >= 0)\r\nasus_wwan_set(asus, !!wwan_status);\r\nif (!acpi_check_handle(asus->handle, METHOD_KBD_LIGHT_SET, NULL))\r\nasus_kled_set(asus, 1);\r\nasus->ledd_status = 0xFFF;\r\nasus->light_switch = !!als_status;\r\nasus->light_level = 5;\r\nif (asus->is_pega_lucid) {\r\nasus_als_switch(asus, asus->light_switch);\r\n} else if (!acpi_check_handle(asus->handle, METHOD_ALS_CONTROL, NULL) &&\r\n!acpi_check_handle(asus->handle, METHOD_ALS_LEVEL, NULL)) {\r\nasus_als_switch(asus, asus->light_switch);\r\nasus_als_level(asus, asus->light_level);\r\n}\r\nreturn result;\r\n}\r\nstatic void asus_dmi_check(void)\r\n{\r\nconst char *model;\r\nmodel = dmi_get_system_info(DMI_PRODUCT_NAME);\r\nif (!model)\r\nreturn;\r\nif (strncmp(model, "L1400B", 6) == 0) {\r\nwlan_status = -1;\r\n}\r\n}\r\nstatic int asus_acpi_add(struct acpi_device *device)\r\n{\r\nstruct asus_laptop *asus;\r\nint result;\r\npr_notice("Asus Laptop Support version %s\n",\r\nASUS_LAPTOP_VERSION);\r\nasus = kzalloc(sizeof(struct asus_laptop), GFP_KERNEL);\r\nif (!asus)\r\nreturn -ENOMEM;\r\nasus->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ASUS_LAPTOP_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ASUS_LAPTOP_CLASS);\r\ndevice->driver_data = asus;\r\nasus->device = device;\r\nasus_dmi_check();\r\nresult = asus_acpi_init(asus);\r\nif (result)\r\ngoto fail_platform;\r\nasus->is_pega_lucid = asus_check_pega_lucid(asus);\r\nresult = asus_platform_init(asus);\r\nif (result)\r\ngoto fail_platform;\r\nif (acpi_video_get_backlight_type() == acpi_backlight_vendor) {\r\nresult = asus_backlight_init(asus);\r\nif (result)\r\ngoto fail_backlight;\r\n}\r\nresult = asus_input_init(asus);\r\nif (result)\r\ngoto fail_input;\r\nresult = asus_led_init(asus);\r\nif (result)\r\ngoto fail_led;\r\nresult = asus_rfkill_init(asus);\r\nif (result && result != -ENODEV)\r\ngoto fail_rfkill;\r\nresult = pega_accel_init(asus);\r\nif (result && result != -ENODEV)\r\ngoto fail_pega_accel;\r\nresult = pega_rfkill_init(asus);\r\nif (result && result != -ENODEV)\r\ngoto fail_pega_rfkill;\r\nasus_device_present = true;\r\nreturn 0;\r\nfail_pega_rfkill:\r\npega_accel_exit(asus);\r\nfail_pega_accel:\r\nasus_rfkill_exit(asus);\r\nfail_rfkill:\r\nasus_led_exit(asus);\r\nfail_led:\r\nasus_input_exit(asus);\r\nfail_input:\r\nasus_backlight_exit(asus);\r\nfail_backlight:\r\nasus_platform_exit(asus);\r\nfail_platform:\r\nkfree(asus);\r\nreturn result;\r\n}\r\nstatic int asus_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct asus_laptop *asus = acpi_driver_data(device);\r\nasus_backlight_exit(asus);\r\nasus_rfkill_exit(asus);\r\nasus_led_exit(asus);\r\nasus_input_exit(asus);\r\npega_accel_exit(asus);\r\nasus_platform_exit(asus);\r\nkfree(asus->name);\r\nkfree(asus);\r\nreturn 0;\r\n}\r\nstatic int __init asus_laptop_init(void)\r\n{\r\nint result;\r\nresult = platform_driver_register(&platform_driver);\r\nif (result < 0)\r\nreturn result;\r\nresult = acpi_bus_register_driver(&asus_acpi_driver);\r\nif (result < 0)\r\ngoto fail_acpi_driver;\r\nif (!asus_device_present) {\r\nresult = -ENODEV;\r\ngoto fail_no_device;\r\n}\r\nreturn 0;\r\nfail_no_device:\r\nacpi_bus_unregister_driver(&asus_acpi_driver);\r\nfail_acpi_driver:\r\nplatform_driver_unregister(&platform_driver);\r\nreturn result;\r\n}\r\nstatic void __exit asus_laptop_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&asus_acpi_driver);\r\nplatform_driver_unregister(&platform_driver);\r\n}
