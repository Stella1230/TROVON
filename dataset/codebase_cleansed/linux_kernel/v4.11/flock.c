static int afs_init_lock_manager(void)\r\n{\r\nint ret;\r\nret = 0;\r\nif (!afs_lock_manager) {\r\nmutex_lock(&afs_lock_manager_mutex);\r\nif (!afs_lock_manager) {\r\nafs_lock_manager = alloc_workqueue("kafs_lockd",\r\nWQ_MEM_RECLAIM, 0);\r\nif (!afs_lock_manager)\r\nret = -ENOMEM;\r\n}\r\nmutex_unlock(&afs_lock_manager_mutex);\r\n}\r\nreturn ret;\r\n}\r\nvoid __exit afs_kill_lock_manager(void)\r\n{\r\nif (afs_lock_manager)\r\ndestroy_workqueue(afs_lock_manager);\r\n}\r\nvoid afs_lock_may_be_available(struct afs_vnode *vnode)\r\n{\r\n_enter("{%x:%u}", vnode->fid.vid, vnode->fid.vnode);\r\nqueue_delayed_work(afs_lock_manager, &vnode->lock_work, 0);\r\n}\r\nstatic void afs_schedule_lock_extension(struct afs_vnode *vnode)\r\n{\r\nqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\r\nAFS_LOCKWAIT * HZ / 2);\r\n}\r\nstatic void afs_grant_locks(struct afs_vnode *vnode, struct file_lock *fl)\r\n{\r\nstruct file_lock *p, *_p;\r\nlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\r\nif (fl->fl_type == F_RDLCK) {\r\nlist_for_each_entry_safe(p, _p, &vnode->pending_locks,\r\nfl_u.afs.link) {\r\nif (p->fl_type == F_RDLCK) {\r\np->fl_u.afs.state = AFS_LOCK_GRANTED;\r\nlist_move_tail(&p->fl_u.afs.link,\r\n&vnode->granted_locks);\r\nwake_up(&p->fl_wait);\r\n}\r\n}\r\n}\r\n}\r\nvoid afs_lock_work(struct work_struct *work)\r\n{\r\nstruct afs_vnode *vnode =\r\ncontainer_of(work, struct afs_vnode, lock_work.work);\r\nstruct file_lock *fl;\r\nafs_lock_type_t type;\r\nstruct key *key;\r\nint ret;\r\n_enter("{%x:%u}", vnode->fid.vid, vnode->fid.vnode);\r\nspin_lock(&vnode->lock);\r\nif (test_bit(AFS_VNODE_UNLOCKING, &vnode->flags)) {\r\n_debug("unlock");\r\nspin_unlock(&vnode->lock);\r\nret = afs_vnode_release_lock(vnode, vnode->unlock_key);\r\nif (ret < 0)\r\nprintk(KERN_WARNING "AFS:"\r\n" Failed to release lock on {%x:%x} error %d\n",\r\nvnode->fid.vid, vnode->fid.vnode, ret);\r\nspin_lock(&vnode->lock);\r\nkey_put(vnode->unlock_key);\r\nvnode->unlock_key = NULL;\r\nclear_bit(AFS_VNODE_UNLOCKING, &vnode->flags);\r\n}\r\nif (!list_empty(&vnode->granted_locks)) {\r\n_debug("extend");\r\nif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\r\nBUG();\r\nfl = list_entry(vnode->granted_locks.next,\r\nstruct file_lock, fl_u.afs.link);\r\nkey = key_get(fl->fl_file->private_data);\r\nspin_unlock(&vnode->lock);\r\nret = afs_vnode_extend_lock(vnode, key);\r\nclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\r\nkey_put(key);\r\nswitch (ret) {\r\ncase 0:\r\nafs_schedule_lock_extension(vnode);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "AFS:"\r\n" Failed to extend lock on {%x:%x} error %d\n",\r\nvnode->fid.vid, vnode->fid.vnode, ret);\r\nqueue_delayed_work(afs_lock_manager, &vnode->lock_work,\r\nHZ * 10);\r\nbreak;\r\n}\r\n_leave(" [extend]");\r\nreturn;\r\n}\r\nif (!list_empty(&vnode->pending_locks)) {\r\n_debug("get");\r\nif (test_and_set_bit(AFS_VNODE_LOCKING, &vnode->flags))\r\nBUG();\r\nfl = list_entry(vnode->pending_locks.next,\r\nstruct file_lock, fl_u.afs.link);\r\nkey = key_get(fl->fl_file->private_data);\r\ntype = (fl->fl_type == F_RDLCK) ?\r\nAFS_LOCK_READ : AFS_LOCK_WRITE;\r\nspin_unlock(&vnode->lock);\r\nret = afs_vnode_set_lock(vnode, key, type);\r\nclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\r\nswitch (ret) {\r\ncase -EWOULDBLOCK:\r\n_debug("blocked");\r\nbreak;\r\ncase 0:\r\n_debug("acquired");\r\nif (type == AFS_LOCK_READ)\r\nset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\r\nelse\r\nset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\r\nret = AFS_LOCK_GRANTED;\r\ndefault:\r\nspin_lock(&vnode->lock);\r\nif (list_entry(vnode->pending_locks.next,\r\nstruct file_lock, fl_u.afs.link) == fl) {\r\nfl->fl_u.afs.state = ret;\r\nif (ret == AFS_LOCK_GRANTED)\r\nafs_grant_locks(vnode, fl);\r\nelse\r\nlist_del_init(&fl->fl_u.afs.link);\r\nwake_up(&fl->fl_wait);\r\nspin_unlock(&vnode->lock);\r\n} else {\r\n_debug("withdrawn");\r\nclear_bit(AFS_VNODE_READLOCKED, &vnode->flags);\r\nclear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\r\nspin_unlock(&vnode->lock);\r\nafs_vnode_release_lock(vnode, key);\r\nif (!list_empty(&vnode->pending_locks))\r\nafs_lock_may_be_available(vnode);\r\n}\r\nbreak;\r\n}\r\nkey_put(key);\r\n_leave(" [pend]");\r\nreturn;\r\n}\r\nspin_unlock(&vnode->lock);\r\n_leave(" [no locks]");\r\n}\r\nstatic void afs_defer_unlock(struct afs_vnode *vnode, struct key *key)\r\n{\r\ncancel_delayed_work(&vnode->lock_work);\r\nif (!test_and_clear_bit(AFS_VNODE_READLOCKED, &vnode->flags) &&\r\n!test_and_clear_bit(AFS_VNODE_WRITELOCKED, &vnode->flags))\r\nBUG();\r\nif (test_and_set_bit(AFS_VNODE_UNLOCKING, &vnode->flags))\r\nBUG();\r\nvnode->unlock_key = key_get(key);\r\nafs_lock_may_be_available(vnode);\r\n}\r\nstatic int afs_do_setlk(struct file *file, struct file_lock *fl)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct afs_vnode *vnode = AFS_FS_I(inode);\r\nafs_lock_type_t type;\r\nstruct key *key = file->private_data;\r\nint ret;\r\n_enter("{%x:%u},%u", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\r\nif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\r\nreturn -EINVAL;\r\nret = afs_init_lock_manager();\r\nif (ret < 0)\r\nreturn ret;\r\nfl->fl_ops = &afs_lock_ops;\r\nINIT_LIST_HEAD(&fl->fl_u.afs.link);\r\nfl->fl_u.afs.state = AFS_LOCK_PENDING;\r\ntype = (fl->fl_type == F_RDLCK) ? AFS_LOCK_READ : AFS_LOCK_WRITE;\r\nspin_lock(&inode->i_lock);\r\nret = afs_vnode_fetch_status(vnode, NULL, key);\r\nif (ret < 0)\r\ngoto error;\r\nif (vnode->status.lock_count != 0 && !(fl->fl_flags & FL_SLEEP)) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nspin_lock(&vnode->lock);\r\nif (type == AFS_LOCK_READ &&\r\nvnode->flags & (1 << AFS_VNODE_READLOCKED)) {\r\n_debug("instant readlock");\r\nASSERTCMP(vnode->flags &\r\n((1 << AFS_VNODE_LOCKING) |\r\n(1 << AFS_VNODE_WRITELOCKED)), ==, 0);\r\nASSERT(!list_empty(&vnode->granted_locks));\r\ngoto sharing_existing_lock;\r\n}\r\nif (list_empty(&vnode->pending_locks) &&\r\nlist_empty(&vnode->granted_locks)) {\r\n_debug("not locked");\r\nASSERTCMP(vnode->flags &\r\n((1 << AFS_VNODE_LOCKING) |\r\n(1 << AFS_VNODE_READLOCKED) |\r\n(1 << AFS_VNODE_WRITELOCKED)), ==, 0);\r\nlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\r\nset_bit(AFS_VNODE_LOCKING, &vnode->flags);\r\nspin_unlock(&vnode->lock);\r\nret = afs_vnode_set_lock(vnode, key, type);\r\nclear_bit(AFS_VNODE_LOCKING, &vnode->flags);\r\nswitch (ret) {\r\ncase 0:\r\n_debug("acquired");\r\ngoto acquired_server_lock;\r\ncase -EWOULDBLOCK:\r\n_debug("would block");\r\nspin_lock(&vnode->lock);\r\nASSERT(list_empty(&vnode->granted_locks));\r\nASSERTCMP(vnode->pending_locks.next, ==,\r\n&fl->fl_u.afs.link);\r\ngoto wait;\r\ndefault:\r\nspin_lock(&vnode->lock);\r\nlist_del_init(&fl->fl_u.afs.link);\r\nspin_unlock(&vnode->lock);\r\ngoto error;\r\n}\r\n}\r\n_debug("wait local");\r\nlist_add_tail(&fl->fl_u.afs.link, &vnode->pending_locks);\r\nwait:\r\nif (!(fl->fl_flags & FL_SLEEP)) {\r\n_debug("noblock");\r\nret = -EAGAIN;\r\ngoto abort_attempt;\r\n}\r\nspin_unlock(&vnode->lock);\r\n_debug("sleep");\r\nret = wait_event_interruptible(fl->fl_wait,\r\nfl->fl_u.afs.state <= AFS_LOCK_GRANTED);\r\nif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\r\nret = fl->fl_u.afs.state;\r\nif (ret < 0)\r\ngoto error;\r\nspin_lock(&vnode->lock);\r\ngoto given_lock;\r\n}\r\n_debug("intr");\r\nASSERTCMP(ret, ==, -ERESTARTSYS);\r\nspin_lock(&vnode->lock);\r\nif (fl->fl_u.afs.state <= AFS_LOCK_GRANTED) {\r\nret = fl->fl_u.afs.state;\r\nif (ret < 0) {\r\nspin_unlock(&vnode->lock);\r\ngoto error;\r\n}\r\ngoto given_lock;\r\n}\r\nabort_attempt:\r\n_debug("abort");\r\nif (list_empty(&vnode->granted_locks) &&\r\nvnode->pending_locks.next == &fl->fl_u.afs.link) {\r\nif (vnode->pending_locks.prev != &fl->fl_u.afs.link) {\r\nlist_del_init(&fl->fl_u.afs.link);\r\nafs_lock_may_be_available(vnode);\r\n}\r\n} else {\r\nlist_del_init(&fl->fl_u.afs.link);\r\n}\r\nspin_unlock(&vnode->lock);\r\ngoto error;\r\nacquired_server_lock:\r\nspin_lock(&vnode->lock);\r\nafs_schedule_lock_extension(vnode);\r\nif (type == AFS_LOCK_READ)\r\nset_bit(AFS_VNODE_READLOCKED, &vnode->flags);\r\nelse\r\nset_bit(AFS_VNODE_WRITELOCKED, &vnode->flags);\r\nsharing_existing_lock:\r\nfl->fl_u.afs.state = AFS_LOCK_GRANTED;\r\nlist_move_tail(&fl->fl_u.afs.link, &vnode->granted_locks);\r\ngiven_lock:\r\nASSERT(!(vnode->flags & (1 << AFS_VNODE_LOCKING)));\r\nASSERT((vnode->flags & ((1 << AFS_VNODE_READLOCKED) |\r\n(1 << AFS_VNODE_WRITELOCKED))) != 0);\r\nret = posix_lock_file(file, fl, NULL);\r\nif (ret < 0)\r\ngoto vfs_rejected_lock;\r\nspin_unlock(&vnode->lock);\r\nafs_vnode_fetch_status(vnode, NULL, key);\r\nerror:\r\nspin_unlock(&inode->i_lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nvfs_rejected_lock:\r\n_debug("vfs refused %d", ret);\r\nlist_del_init(&fl->fl_u.afs.link);\r\nif (list_empty(&vnode->granted_locks))\r\nafs_defer_unlock(vnode, key);\r\ngoto abort_attempt;\r\n}\r\nstatic int afs_do_unlk(struct file *file, struct file_lock *fl)\r\n{\r\nstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\r\nstruct key *key = file->private_data;\r\nint ret;\r\n_enter("{%x:%u},%u", vnode->fid.vid, vnode->fid.vnode, fl->fl_type);\r\nif (fl->fl_start != 0 || fl->fl_end != OFFSET_MAX)\r\nreturn -EINVAL;\r\nfl->fl_ops = &afs_lock_ops;\r\nINIT_LIST_HEAD(&fl->fl_u.afs.link);\r\nfl->fl_u.afs.state = AFS_LOCK_PENDING;\r\nspin_lock(&vnode->lock);\r\nret = posix_lock_file(file, fl, NULL);\r\nif (ret < 0) {\r\nspin_unlock(&vnode->lock);\r\n_leave(" = %d [vfs]", ret);\r\nreturn ret;\r\n}\r\nif (list_empty(&vnode->granted_locks))\r\nafs_defer_unlock(vnode, key);\r\nspin_unlock(&vnode->lock);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int afs_do_getlk(struct file *file, struct file_lock *fl)\r\n{\r\nstruct afs_vnode *vnode = AFS_FS_I(file->f_mapping->host);\r\nstruct key *key = file->private_data;\r\nint ret, lock_count;\r\n_enter("");\r\nfl->fl_type = F_UNLCK;\r\ninode_lock(&vnode->vfs_inode);\r\nret = 0;\r\nposix_test_lock(file, fl);\r\nif (fl->fl_type == F_UNLCK) {\r\nret = afs_vnode_fetch_status(vnode, NULL, key);\r\nif (ret < 0)\r\ngoto error;\r\nlock_count = vnode->status.lock_count;\r\nif (lock_count) {\r\nif (lock_count > 0)\r\nfl->fl_type = F_RDLCK;\r\nelse\r\nfl->fl_type = F_WRLCK;\r\nfl->fl_start = 0;\r\nfl->fl_end = OFFSET_MAX;\r\n}\r\n}\r\nerror:\r\ninode_unlock(&vnode->vfs_inode);\r\n_leave(" = %d [%hd]", ret, fl->fl_type);\r\nreturn ret;\r\n}\r\nint afs_lock(struct file *file, int cmd, struct file_lock *fl)\r\n{\r\nstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\r\n_enter("{%x:%u},%d,{t=%x,fl=%x,r=%Ld:%Ld}",\r\nvnode->fid.vid, vnode->fid.vnode, cmd,\r\nfl->fl_type, fl->fl_flags,\r\n(long long) fl->fl_start, (long long) fl->fl_end);\r\nif (__mandatory_lock(&vnode->vfs_inode) && fl->fl_type != F_UNLCK)\r\nreturn -ENOLCK;\r\nif (IS_GETLK(cmd))\r\nreturn afs_do_getlk(file, fl);\r\nif (fl->fl_type == F_UNLCK)\r\nreturn afs_do_unlk(file, fl);\r\nreturn afs_do_setlk(file, fl);\r\n}\r\nint afs_flock(struct file *file, int cmd, struct file_lock *fl)\r\n{\r\nstruct afs_vnode *vnode = AFS_FS_I(file_inode(file));\r\n_enter("{%x:%u},%d,{t=%x,fl=%x}",\r\nvnode->fid.vid, vnode->fid.vnode, cmd,\r\nfl->fl_type, fl->fl_flags);\r\nif (!(fl->fl_flags & FL_FLOCK))\r\nreturn -ENOLCK;\r\nif (fl->fl_type == F_UNLCK)\r\nreturn afs_do_unlk(file, fl);\r\nreturn afs_do_setlk(file, fl);\r\n}\r\nstatic void afs_fl_copy_lock(struct file_lock *new, struct file_lock *fl)\r\n{\r\n_enter("");\r\nlist_add(&new->fl_u.afs.link, &fl->fl_u.afs.link);\r\n}\r\nstatic void afs_fl_release_private(struct file_lock *fl)\r\n{\r\n_enter("");\r\nlist_del_init(&fl->fl_u.afs.link);\r\n}
