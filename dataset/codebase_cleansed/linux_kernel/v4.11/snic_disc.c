static inline const char *\r\nsnic_tgt_type_to_str(int typ)\r\n{\r\nreturn ((typ > SNIC_TGT_NONE && typ <= SNIC_TGT_SAN) ?\r\nsnic_tgt_type_str[typ] : "Unknown");\r\n}\r\nconst char *\r\nsnic_tgt_state_to_str(int state)\r\n{\r\nreturn ((state >= SNIC_TGT_STAT_INIT && state <= SNIC_TGT_STAT_DEL) ?\r\nsnic_tgt_state_str[state] : "UNKNOWN");\r\n}\r\nstatic void\r\nsnic_report_tgt_init(struct snic_host_req *req, u32 hid, u8 *buf, u32 len,\r\ndma_addr_t rsp_buf_pa, ulong ctx)\r\n{\r\nstruct snic_sg_desc *sgd = NULL;\r\nsnic_io_hdr_enc(&req->hdr, SNIC_REQ_REPORT_TGTS, 0, SCSI_NO_TAG, hid,\r\n1, ctx);\r\nreq->u.rpt_tgts.sg_cnt = cpu_to_le16(1);\r\nsgd = req_to_sgl(req);\r\nsgd[0].addr = cpu_to_le64(rsp_buf_pa);\r\nsgd[0].len = cpu_to_le32(len);\r\nsgd[0]._resvd = 0;\r\nreq->u.rpt_tgts.sg_addr = cpu_to_le64((ulong)sgd);\r\n}\r\nstatic int\r\nsnic_queue_report_tgt_req(struct snic *snic)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nu32 ntgts, buf_len = 0;\r\nu8 *buf = NULL;\r\ndma_addr_t pa = 0;\r\nint ret = 0;\r\nrqi = snic_req_init(snic, 1);\r\nif (!rqi) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (snic->fwinfo.max_tgts)\r\nntgts = min_t(u32, snic->fwinfo.max_tgts, snic->shost->max_id);\r\nelse\r\nntgts = snic->shost->max_id;\r\nSNIC_BUG_ON(ntgts == 0);\r\nbuf_len = ntgts * sizeof(struct snic_tgt_id) + SNIC_SG_DESC_ALIGN;\r\nbuf = kzalloc(buf_len, GFP_KERNEL|GFP_DMA);\r\nif (!buf) {\r\nsnic_req_free(snic, rqi);\r\nSNIC_HOST_ERR(snic->shost, "Resp Buf Alloc Failed.\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nSNIC_BUG_ON((((unsigned long)buf) % SNIC_SG_DESC_ALIGN) != 0);\r\npa = pci_map_single(snic->pdev, buf, buf_len, PCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(snic->pdev, pa)) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Rpt-tgt rspbuf %p: PCI DMA Mapping Failed\n",\r\nbuf);\r\nkfree(buf);\r\nsnic_req_free(snic, rqi);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nSNIC_BUG_ON(pa == 0);\r\nrqi->sge_va = (ulong) buf;\r\nsnic_report_tgt_init(rqi->req,\r\nsnic->config.hid,\r\nbuf,\r\nbuf_len,\r\npa,\r\n(ulong)rqi);\r\nsnic_handle_untagged_req(snic, rqi);\r\nret = snic_queue_wq_desc(snic, rqi->req, rqi->req_len);\r\nif (ret) {\r\npci_unmap_single(snic->pdev, pa, buf_len, PCI_DMA_FROMDEVICE);\r\nkfree(buf);\r\nrqi->sge_va = 0;\r\nsnic_release_untagged_req(snic, rqi);\r\nSNIC_HOST_ERR(snic->shost, "Queuing Report Tgts Failed.\n");\r\ngoto error;\r\n}\r\nSNIC_DISC_DBG(snic->shost, "Report Targets Issued.\n");\r\nreturn ret;\r\nerror:\r\nSNIC_HOST_ERR(snic->shost,\r\n"Queuing Report Targets Failed, err = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic void\r\nsnic_scsi_scan_tgt(struct work_struct *work)\r\n{\r\nstruct snic_tgt *tgt = container_of(work, struct snic_tgt, scan_work);\r\nstruct Scsi_Host *shost = dev_to_shost(&tgt->dev);\r\nunsigned long flags;\r\nSNIC_HOST_INFO(shost, "Scanning Target id 0x%x\n", tgt->id);\r\nscsi_scan_target(&tgt->dev,\r\ntgt->channel,\r\ntgt->scsi_tgt_id,\r\nSCAN_WILD_CARD,\r\nSCSI_SCAN_RESCAN);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\ntgt->flags &= ~SNIC_TGT_SCAN_PENDING;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nstatic struct snic_tgt *\r\nsnic_tgt_lookup(struct snic *snic, struct snic_tgt_id *tgtid)\r\n{\r\nstruct list_head *cur, *nxt;\r\nstruct snic_tgt *tgt = NULL;\r\nlist_for_each_safe(cur, nxt, &snic->disc.tgt_list) {\r\ntgt = list_entry(cur, struct snic_tgt, list);\r\nif (tgt->id == le32_to_cpu(tgtid->tgt_id))\r\nreturn tgt;\r\ntgt = NULL;\r\n}\r\nreturn tgt;\r\n}\r\nvoid\r\nsnic_tgt_dev_release(struct device *dev)\r\n{\r\nstruct snic_tgt *tgt = dev_to_tgt(dev);\r\nSNIC_HOST_INFO(snic_tgt_to_shost(tgt),\r\n"Target Device ID %d (%s) Permanently Deleted.\n",\r\ntgt->id,\r\ndev_name(dev));\r\nSNIC_BUG_ON(!list_empty(&tgt->list));\r\nkfree(tgt);\r\n}\r\nstatic void\r\nsnic_tgt_del(struct work_struct *work)\r\n{\r\nstruct snic_tgt *tgt = container_of(work, struct snic_tgt, del_work);\r\nstruct Scsi_Host *shost = snic_tgt_to_shost(tgt);\r\nif (tgt->flags & SNIC_TGT_SCAN_PENDING)\r\nscsi_flush_work(shost);\r\nscsi_target_block(&tgt->dev);\r\nsnic_tgt_scsi_abort_io(tgt);\r\nscsi_target_unblock(&tgt->dev, SDEV_TRANSPORT_OFFLINE);\r\nscsi_remove_target(&tgt->dev);\r\ndevice_del(&tgt->dev);\r\nput_device(&tgt->dev);\r\n}\r\nstatic struct snic_tgt *\r\nsnic_tgt_create(struct snic *snic, struct snic_tgt_id *tgtid)\r\n{\r\nstruct snic_tgt *tgt = NULL;\r\nunsigned long flags;\r\nint ret;\r\ntgt = snic_tgt_lookup(snic, tgtid);\r\nif (tgt) {\r\nreturn tgt;\r\n}\r\ntgt = kzalloc(sizeof(*tgt), GFP_KERNEL);\r\nif (!tgt) {\r\nSNIC_HOST_ERR(snic->shost, "Failure to allocate snic_tgt.\n");\r\nret = -ENOMEM;\r\nreturn tgt;\r\n}\r\nINIT_LIST_HEAD(&tgt->list);\r\ntgt->id = le32_to_cpu(tgtid->tgt_id);\r\ntgt->channel = 0;\r\nSNIC_BUG_ON(le16_to_cpu(tgtid->tgt_type) > SNIC_TGT_SAN);\r\ntgt->tdata.typ = le16_to_cpu(tgtid->tgt_type);\r\ntgt->tdata.disc_id = 0;\r\ntgt->state = SNIC_TGT_STAT_INIT;\r\ndevice_initialize(&tgt->dev);\r\ntgt->dev.parent = get_device(&snic->shost->shost_gendev);\r\ntgt->dev.release = snic_tgt_dev_release;\r\nINIT_WORK(&tgt->scan_work, snic_scsi_scan_tgt);\r\nINIT_WORK(&tgt->del_work, snic_tgt_del);\r\nswitch (tgt->tdata.typ) {\r\ncase SNIC_TGT_DAS:\r\ndev_set_name(&tgt->dev, "snic_das_tgt:%d:%d-%d",\r\nsnic->shost->host_no, tgt->channel, tgt->id);\r\nbreak;\r\ncase SNIC_TGT_SAN:\r\ndev_set_name(&tgt->dev, "snic_san_tgt:%d:%d-%d",\r\nsnic->shost->host_no, tgt->channel, tgt->id);\r\nbreak;\r\ndefault:\r\nSNIC_HOST_INFO(snic->shost, "Target type Unknown Detected.\n");\r\ndev_set_name(&tgt->dev, "snic_das_tgt:%d:%d-%d",\r\nsnic->shost->host_no, tgt->channel, tgt->id);\r\nbreak;\r\n}\r\nspin_lock_irqsave(snic->shost->host_lock, flags);\r\nlist_add_tail(&tgt->list, &snic->disc.tgt_list);\r\ntgt->scsi_tgt_id = snic->disc.nxt_tgt_id++;\r\ntgt->state = SNIC_TGT_STAT_ONLINE;\r\nspin_unlock_irqrestore(snic->shost->host_lock, flags);\r\nSNIC_HOST_INFO(snic->shost,\r\n"Tgt %d, type = %s detected. Adding..\n",\r\ntgt->id, snic_tgt_type_to_str(tgt->tdata.typ));\r\nret = device_add(&tgt->dev);\r\nif (ret) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Snic Tgt: device_add, with err = %d\n",\r\nret);\r\nput_device(&snic->shost->shost_gendev);\r\nkfree(tgt);\r\ntgt = NULL;\r\nreturn tgt;\r\n}\r\nSNIC_HOST_INFO(snic->shost, "Scanning %s.\n", dev_name(&tgt->dev));\r\nscsi_queue_work(snic->shost, &tgt->scan_work);\r\nreturn tgt;\r\n}\r\nvoid\r\nsnic_handle_tgt_disc(struct work_struct *work)\r\n{\r\nstruct snic *snic = container_of(work, struct snic, tgt_work);\r\nstruct snic_tgt_id *tgtid = NULL;\r\nstruct snic_tgt *tgt = NULL;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nif (snic->in_remove) {\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nkfree(snic->disc.rtgt_info);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nmutex_lock(&snic->disc.mutex);\r\nif (snic->disc.req_cnt) {\r\nsnic->disc.state = SNIC_DISC_DONE;\r\nsnic->disc.req_cnt = 0;\r\nmutex_unlock(&snic->disc.mutex);\r\nkfree(snic->disc.rtgt_info);\r\nsnic->disc.rtgt_info = NULL;\r\nSNIC_HOST_INFO(snic->shost, "tgt_disc: Discovery restart.\n");\r\nsnic_disc_start(snic);\r\nreturn;\r\n}\r\ntgtid = (struct snic_tgt_id *)snic->disc.rtgt_info;\r\nSNIC_BUG_ON(snic->disc.rtgt_cnt == 0 || tgtid == NULL);\r\nfor (i = 0; i < snic->disc.rtgt_cnt; i++) {\r\ntgt = snic_tgt_create(snic, &tgtid[i]);\r\nif (!tgt) {\r\nint buf_sz = snic->disc.rtgt_cnt * sizeof(*tgtid);\r\nSNIC_HOST_ERR(snic->shost, "Failed to create tgt.\n");\r\nsnic_hex_dump("rpt_tgt_rsp", (char *)tgtid, buf_sz);\r\nbreak;\r\n}\r\n}\r\nsnic->disc.rtgt_info = NULL;\r\nsnic->disc.state = SNIC_DISC_DONE;\r\nmutex_unlock(&snic->disc.mutex);\r\nSNIC_HOST_INFO(snic->shost, "Discovery Completed.\n");\r\nkfree(tgtid);\r\n}\r\nint\r\nsnic_report_tgt_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nu8 typ, cmpl_stat;\r\nu32 cmnd_id, hid, tgt_cnt = 0;\r\nulong ctx;\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_tgt_id *tgtid;\r\nint i, ret = 0;\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &cmpl_stat, &cmnd_id, &hid, &ctx);\r\nrqi = (struct snic_req_info *) ctx;\r\ntgtid = (struct snic_tgt_id *) rqi->sge_va;\r\ntgt_cnt = le32_to_cpu(fwreq->u.rpt_tgts_cmpl.tgt_cnt);\r\nif (tgt_cnt == 0) {\r\nSNIC_HOST_ERR(snic->shost, "No Targets Found on this host.\n");\r\nret = 1;\r\ngoto end;\r\n}\r\nSNIC_HOST_INFO(snic->shost, "Target Count = %d\n", tgt_cnt);\r\nSNIC_BUG_ON(tgt_cnt > snic->fwinfo.max_tgts);\r\nfor (i = 0; i < tgt_cnt; i++)\r\nSNIC_HOST_INFO(snic->shost,\r\n"Tgt id = 0x%x\n",\r\nle32_to_cpu(tgtid[i].tgt_id));\r\nsnic->disc.rtgt_cnt = tgt_cnt;\r\nsnic->disc.rtgt_info = (u8 *) tgtid;\r\nqueue_work(snic_glob->event_q, &snic->tgt_work);\r\nret = 0;\r\nend:\r\nsnic_pci_unmap_rsp_buf(snic, rqi);\r\nif (ret)\r\nkfree(tgtid);\r\nrqi->sge_va = 0;\r\nsnic_release_untagged_req(snic, rqi);\r\nreturn ret;\r\n}\r\nvoid\r\nsnic_disc_init(struct snic_disc *disc)\r\n{\r\nINIT_LIST_HEAD(&disc->tgt_list);\r\nmutex_init(&disc->mutex);\r\ndisc->disc_id = 0;\r\ndisc->nxt_tgt_id = 0;\r\ndisc->state = SNIC_DISC_INIT;\r\ndisc->req_cnt = 0;\r\ndisc->rtgt_cnt = 0;\r\ndisc->rtgt_info = NULL;\r\ndisc->cb = NULL;\r\n}\r\nvoid\r\nsnic_disc_term(struct snic *snic)\r\n{\r\nstruct snic_disc *disc = &snic->disc;\r\nmutex_lock(&disc->mutex);\r\nif (disc->req_cnt) {\r\ndisc->req_cnt = 0;\r\nSNIC_SCSI_DBG(snic->shost, "Terminating Discovery.\n");\r\n}\r\nmutex_unlock(&disc->mutex);\r\n}\r\nint\r\nsnic_disc_start(struct snic *snic)\r\n{\r\nstruct snic_disc *disc = &snic->disc;\r\nunsigned long flags;\r\nint ret = 0;\r\nSNIC_SCSI_DBG(snic->shost, "Discovery Start.\n");\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nif (snic->in_remove) {\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nSNIC_ERR("snic driver removal in progress ...\n");\r\nret = 0;\r\nreturn ret;\r\n}\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nmutex_lock(&disc->mutex);\r\nif (disc->state == SNIC_DISC_PENDING) {\r\ndisc->req_cnt++;\r\nmutex_unlock(&disc->mutex);\r\nreturn ret;\r\n}\r\ndisc->state = SNIC_DISC_PENDING;\r\nmutex_unlock(&disc->mutex);\r\nret = snic_queue_report_tgt_req(snic);\r\nif (ret)\r\nSNIC_HOST_INFO(snic->shost, "Discovery Failed, err=%d.\n", ret);\r\nreturn ret;\r\n}\r\nvoid\r\nsnic_handle_disc(struct work_struct *work)\r\n{\r\nstruct snic *snic = container_of(work, struct snic, disc_work);\r\nint ret = 0;\r\nSNIC_HOST_INFO(snic->shost, "disc_work: Discovery\n");\r\nret = snic_disc_start(snic);\r\nif (ret)\r\ngoto disc_err;\r\ndisc_err:\r\nSNIC_HOST_ERR(snic->shost,\r\n"disc_work: Discovery Failed w/ err = %d\n",\r\nret);\r\n}\r\nvoid\r\nsnic_tgt_del_all(struct snic *snic)\r\n{\r\nstruct snic_tgt *tgt = NULL;\r\nstruct list_head *cur, *nxt;\r\nunsigned long flags;\r\nscsi_flush_work(snic->shost);\r\nmutex_lock(&snic->disc.mutex);\r\nspin_lock_irqsave(snic->shost->host_lock, flags);\r\nlist_for_each_safe(cur, nxt, &snic->disc.tgt_list) {\r\ntgt = list_entry(cur, struct snic_tgt, list);\r\ntgt->state = SNIC_TGT_STAT_DEL;\r\nlist_del_init(&tgt->list);\r\nSNIC_HOST_INFO(snic->shost, "Tgt %d q'ing for del\n", tgt->id);\r\nqueue_work(snic_glob->event_q, &tgt->del_work);\r\ntgt = NULL;\r\n}\r\nspin_unlock_irqrestore(snic->shost->host_lock, flags);\r\nmutex_unlock(&snic->disc.mutex);\r\nflush_workqueue(snic_glob->event_q);\r\n}
