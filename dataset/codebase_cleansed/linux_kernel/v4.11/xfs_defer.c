STATIC void\r\nxfs_defer_intake_work(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dop)\r\n{\r\nstruct list_head *li;\r\nstruct xfs_defer_pending *dfp;\r\nlist_for_each_entry(dfp, &dop->dop_intake, dfp_list) {\r\ndfp->dfp_intent = dfp->dfp_type->create_intent(tp,\r\ndfp->dfp_count);\r\ntrace_xfs_defer_intake_work(tp->t_mountp, dfp);\r\nlist_sort(tp->t_mountp, &dfp->dfp_work,\r\ndfp->dfp_type->diff_items);\r\nlist_for_each(li, &dfp->dfp_work)\r\ndfp->dfp_type->log_item(tp, dfp->dfp_intent, li);\r\n}\r\nlist_splice_tail_init(&dop->dop_intake, &dop->dop_pending);\r\n}\r\nSTATIC void\r\nxfs_defer_trans_abort(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dop,\r\nint error)\r\n{\r\nstruct xfs_defer_pending *dfp;\r\ntrace_xfs_defer_trans_abort(tp->t_mountp, dop);\r\nlist_for_each_entry(dfp, &dop->dop_pending, dfp_list) {\r\ntrace_xfs_defer_pending_abort(tp->t_mountp, dfp);\r\nif (dfp->dfp_intent && !dfp->dfp_done) {\r\ndfp->dfp_type->abort_intent(dfp->dfp_intent);\r\ndfp->dfp_intent = NULL;\r\n}\r\n}\r\nxfs_force_shutdown(tp->t_mountp, (error == -EFSCORRUPTED) ?\r\nSHUTDOWN_CORRUPT_INCORE : SHUTDOWN_META_IO_ERROR);\r\n}\r\nSTATIC int\r\nxfs_defer_trans_roll(\r\nstruct xfs_trans **tp,\r\nstruct xfs_defer_ops *dop,\r\nstruct xfs_inode *ip)\r\n{\r\nint i;\r\nint error;\r\nfor (i = 0; i < XFS_DEFER_OPS_NR_INODES && dop->dop_inodes[i]; i++) {\r\nif (dop->dop_inodes[i] == ip)\r\ncontinue;\r\nxfs_trans_log_inode(*tp, dop->dop_inodes[i], XFS_ILOG_CORE);\r\n}\r\ntrace_xfs_defer_trans_roll((*tp)->t_mountp, dop);\r\nerror = xfs_trans_roll(tp, ip);\r\nif (error) {\r\ntrace_xfs_defer_trans_roll_error((*tp)->t_mountp, dop, error);\r\nxfs_defer_trans_abort(*tp, dop, error);\r\nreturn error;\r\n}\r\ndop->dop_committed = true;\r\nfor (i = 0; i < XFS_DEFER_OPS_NR_INODES && dop->dop_inodes[i]; i++) {\r\nif (dop->dop_inodes[i] == ip)\r\ncontinue;\r\nxfs_trans_ijoin(*tp, dop->dop_inodes[i], 0);\r\n}\r\nreturn error;\r\n}\r\nbool\r\nxfs_defer_has_unfinished_work(\r\nstruct xfs_defer_ops *dop)\r\n{\r\nreturn !list_empty(&dop->dop_pending) || !list_empty(&dop->dop_intake);\r\n}\r\nint\r\nxfs_defer_join(\r\nstruct xfs_defer_ops *dop,\r\nstruct xfs_inode *ip)\r\n{\r\nint i;\r\nfor (i = 0; i < XFS_DEFER_OPS_NR_INODES; i++) {\r\nif (dop->dop_inodes[i] == ip)\r\nreturn 0;\r\nelse if (dop->dop_inodes[i] == NULL) {\r\ndop->dop_inodes[i] = ip;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EFSCORRUPTED;\r\n}\r\nint\r\nxfs_defer_finish(\r\nstruct xfs_trans **tp,\r\nstruct xfs_defer_ops *dop,\r\nstruct xfs_inode *ip)\r\n{\r\nstruct xfs_defer_pending *dfp;\r\nstruct list_head *li;\r\nstruct list_head *n;\r\nvoid *state;\r\nint error = 0;\r\nvoid (*cleanup_fn)(struct xfs_trans *, void *, int);\r\nASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\r\ntrace_xfs_defer_finish((*tp)->t_mountp, dop);\r\nwhile (xfs_defer_has_unfinished_work(dop)) {\r\nxfs_defer_intake_work(*tp, dop);\r\nerror = xfs_defer_trans_roll(tp, dop, ip);\r\nif (error)\r\ngoto out;\r\ndfp = list_first_entry(&dop->dop_pending,\r\nstruct xfs_defer_pending, dfp_list);\r\ntrace_xfs_defer_pending_finish((*tp)->t_mountp, dfp);\r\ndfp->dfp_done = dfp->dfp_type->create_done(*tp, dfp->dfp_intent,\r\ndfp->dfp_count);\r\ncleanup_fn = dfp->dfp_type->finish_cleanup;\r\nstate = NULL;\r\nlist_for_each_safe(li, n, &dfp->dfp_work) {\r\nlist_del(li);\r\ndfp->dfp_count--;\r\nerror = dfp->dfp_type->finish_item(*tp, dop, li,\r\ndfp->dfp_done, &state);\r\nif (error == -EAGAIN) {\r\nlist_add(li, &dfp->dfp_work);\r\ndfp->dfp_count++;\r\nbreak;\r\n} else if (error) {\r\nif (cleanup_fn)\r\ncleanup_fn(*tp, state, error);\r\nxfs_defer_trans_abort(*tp, dop, error);\r\ngoto out;\r\n}\r\n}\r\nif (error == -EAGAIN) {\r\ndfp->dfp_intent = dfp->dfp_type->create_intent(*tp,\r\ndfp->dfp_count);\r\ndfp->dfp_done = NULL;\r\nlist_for_each(li, &dfp->dfp_work)\r\ndfp->dfp_type->log_item(*tp, dfp->dfp_intent,\r\nli);\r\n} else {\r\nlist_del(&dfp->dfp_list);\r\nkmem_free(dfp);\r\n}\r\nif (cleanup_fn)\r\ncleanup_fn(*tp, state, error);\r\n}\r\nout:\r\nif (error)\r\ntrace_xfs_defer_finish_error((*tp)->t_mountp, dop, error);\r\nelse\r\ntrace_xfs_defer_finish_done((*tp)->t_mountp, dop);\r\nreturn error;\r\n}\r\nvoid\r\nxfs_defer_cancel(\r\nstruct xfs_defer_ops *dop)\r\n{\r\nstruct xfs_defer_pending *dfp;\r\nstruct xfs_defer_pending *pli;\r\nstruct list_head *pwi;\r\nstruct list_head *n;\r\ntrace_xfs_defer_cancel(NULL, dop);\r\nlist_for_each_entry_safe(dfp, pli, &dop->dop_intake, dfp_list) {\r\ntrace_xfs_defer_intake_cancel(NULL, dfp);\r\nlist_del(&dfp->dfp_list);\r\nlist_for_each_safe(pwi, n, &dfp->dfp_work) {\r\nlist_del(pwi);\r\ndfp->dfp_count--;\r\ndfp->dfp_type->cancel_item(pwi);\r\n}\r\nASSERT(dfp->dfp_count == 0);\r\nkmem_free(dfp);\r\n}\r\nlist_for_each_entry_safe(dfp, pli, &dop->dop_pending, dfp_list) {\r\ntrace_xfs_defer_pending_cancel(NULL, dfp);\r\nlist_del(&dfp->dfp_list);\r\nlist_for_each_safe(pwi, n, &dfp->dfp_work) {\r\nlist_del(pwi);\r\ndfp->dfp_count--;\r\ndfp->dfp_type->cancel_item(pwi);\r\n}\r\nASSERT(dfp->dfp_count == 0);\r\nkmem_free(dfp);\r\n}\r\n}\r\nvoid\r\nxfs_defer_add(\r\nstruct xfs_defer_ops *dop,\r\nenum xfs_defer_ops_type type,\r\nstruct list_head *li)\r\n{\r\nstruct xfs_defer_pending *dfp = NULL;\r\nif (!list_empty(&dop->dop_intake)) {\r\ndfp = list_last_entry(&dop->dop_intake,\r\nstruct xfs_defer_pending, dfp_list);\r\nif (dfp->dfp_type->type != type ||\r\n(dfp->dfp_type->max_items &&\r\ndfp->dfp_count >= dfp->dfp_type->max_items))\r\ndfp = NULL;\r\n}\r\nif (!dfp) {\r\ndfp = kmem_alloc(sizeof(struct xfs_defer_pending),\r\nKM_SLEEP | KM_NOFS);\r\ndfp->dfp_type = defer_op_types[type];\r\ndfp->dfp_intent = NULL;\r\ndfp->dfp_done = NULL;\r\ndfp->dfp_count = 0;\r\nINIT_LIST_HEAD(&dfp->dfp_work);\r\nlist_add_tail(&dfp->dfp_list, &dop->dop_intake);\r\n}\r\nlist_add_tail(li, &dfp->dfp_work);\r\ndfp->dfp_count++;\r\n}\r\nvoid\r\nxfs_defer_init_op_type(\r\nconst struct xfs_defer_op_type *type)\r\n{\r\ndefer_op_types[type->type] = type;\r\n}\r\nvoid\r\nxfs_defer_init(\r\nstruct xfs_defer_ops *dop,\r\nxfs_fsblock_t *fbp)\r\n{\r\ndop->dop_committed = false;\r\ndop->dop_low = false;\r\nmemset(&dop->dop_inodes, 0, sizeof(dop->dop_inodes));\r\n*fbp = NULLFSBLOCK;\r\nINIT_LIST_HEAD(&dop->dop_intake);\r\nINIT_LIST_HEAD(&dop->dop_pending);\r\ntrace_xfs_defer_init(NULL, dop);\r\n}
