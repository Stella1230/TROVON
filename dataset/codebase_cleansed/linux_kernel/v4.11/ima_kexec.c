static int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\r\nunsigned long segment_size)\r\n{\r\nstruct ima_queue_entry *qe;\r\nstruct seq_file file;\r\nstruct ima_kexec_hdr khdr;\r\nint ret = 0;\r\nfile.buf = vmalloc(segment_size);\r\nif (!file.buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfile.size = segment_size;\r\nfile.read_pos = 0;\r\nfile.count = sizeof(khdr);\r\nmemset(&khdr, 0, sizeof(khdr));\r\nkhdr.version = 1;\r\nlist_for_each_entry_rcu(qe, &ima_measurements, later) {\r\nif (file.count < file.size) {\r\nkhdr.count++;\r\nima_measurements_show(&file, qe);\r\n} else {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nkhdr.buffer_size = file.count;\r\nif (ima_canonical_fmt) {\r\nkhdr.version = cpu_to_le16(khdr.version);\r\nkhdr.count = cpu_to_le64(khdr.count);\r\nkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\r\n}\r\nmemcpy(file.buf, &khdr, sizeof(khdr));\r\nprint_hex_dump(KERN_DEBUG, "ima dump: ", DUMP_PREFIX_NONE,\r\n16, 1, file.buf,\r\nfile.count < 100 ? file.count : 100, true);\r\n*buffer_size = file.count;\r\n*buffer = file.buf;\r\nout:\r\nif (ret == -EINVAL)\r\nvfree(file.buf);\r\nreturn ret;\r\n}\r\nvoid ima_add_kexec_buffer(struct kimage *image)\r\n{\r\nstruct kexec_buf kbuf = { .image = image, .buf_align = PAGE_SIZE,\r\n.buf_min = 0, .buf_max = ULONG_MAX,\r\n.top_down = true };\r\nunsigned long binary_runtime_size;\r\nvoid *kexec_buffer = NULL;\r\nsize_t kexec_buffer_size;\r\nsize_t kexec_segment_size;\r\nint ret;\r\nbinary_runtime_size = ima_get_binary_runtime_size();\r\nif (binary_runtime_size >= ULONG_MAX - PAGE_SIZE)\r\nkexec_segment_size = ULONG_MAX;\r\nelse\r\nkexec_segment_size = ALIGN(ima_get_binary_runtime_size() +\r\nPAGE_SIZE / 2, PAGE_SIZE);\r\nif ((kexec_segment_size == ULONG_MAX) ||\r\n((kexec_segment_size >> PAGE_SHIFT) > totalram_pages / 2)) {\r\npr_err("Binary measurement list too large.\n");\r\nreturn;\r\n}\r\nima_dump_measurement_list(&kexec_buffer_size, &kexec_buffer,\r\nkexec_segment_size);\r\nif (!kexec_buffer) {\r\npr_err("Not enough memory for the kexec measurement buffer.\n");\r\nreturn;\r\n}\r\nkbuf.buffer = kexec_buffer;\r\nkbuf.bufsz = kexec_buffer_size;\r\nkbuf.memsz = kexec_segment_size;\r\nret = kexec_add_buffer(&kbuf);\r\nif (ret) {\r\npr_err("Error passing over kexec measurement buffer.\n");\r\nreturn;\r\n}\r\nret = arch_ima_add_kexec_buffer(image, kbuf.mem, kexec_segment_size);\r\nif (ret) {\r\npr_err("Error passing over kexec measurement buffer.\n");\r\nreturn;\r\n}\r\npr_debug("kexec measurement buffer for the loaded kernel at 0x%lx.\n",\r\nkbuf.mem);\r\n}\r\nvoid ima_load_kexec_buffer(void)\r\n{\r\nvoid *kexec_buffer = NULL;\r\nsize_t kexec_buffer_size = 0;\r\nint rc;\r\nrc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\r\nswitch (rc) {\r\ncase 0:\r\nrc = ima_restore_measurement_list(kexec_buffer_size,\r\nkexec_buffer);\r\nif (rc != 0)\r\npr_err("Failed to restore the measurement list: %d\n",\r\nrc);\r\nima_free_kexec_buffer();\r\nbreak;\r\ncase -ENOTSUPP:\r\npr_debug("Restoring the measurement list not supported\n");\r\nbreak;\r\ncase -ENOENT:\r\npr_debug("No measurement list to restore\n");\r\nbreak;\r\ndefault:\r\npr_debug("Error restoring the measurement list: %d\n", rc);\r\n}\r\n}
