static void do_cleanup(void)\r\n{\r\nstruct gntalloc_gref *gref, *n;\r\nlist_for_each_entry_safe(gref, n, &gref_list, next_gref) {\r\nif (!gref->users)\r\n__del_gref(gref);\r\n}\r\n}\r\nstatic int add_grefs(struct ioctl_gntalloc_alloc_gref *op,\r\nuint32_t *gref_ids, struct gntalloc_file_private_data *priv)\r\n{\r\nint i, rc, readonly;\r\nLIST_HEAD(queue_gref);\r\nLIST_HEAD(queue_file);\r\nstruct gntalloc_gref *gref, *next;\r\nreadonly = !(op->flags & GNTALLOC_FLAG_WRITABLE);\r\nfor (i = 0; i < op->count; i++) {\r\ngref = kzalloc(sizeof(*gref), GFP_KERNEL);\r\nif (!gref) {\r\nrc = -ENOMEM;\r\ngoto undo;\r\n}\r\nlist_add_tail(&gref->next_gref, &queue_gref);\r\nlist_add_tail(&gref->next_file, &queue_file);\r\ngref->users = 1;\r\ngref->file_index = op->index + i * PAGE_SIZE;\r\ngref->page = alloc_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!gref->page) {\r\nrc = -ENOMEM;\r\ngoto undo;\r\n}\r\nrc = gnttab_grant_foreign_access(op->domid,\r\nxen_page_to_gfn(gref->page),\r\nreadonly);\r\nif (rc < 0)\r\ngoto undo;\r\ngref_ids[i] = gref->gref_id = rc;\r\n}\r\nmutex_lock(&gref_mutex);\r\nlist_splice_tail(&queue_gref, &gref_list);\r\nlist_splice_tail(&queue_file, &priv->list);\r\nmutex_unlock(&gref_mutex);\r\nreturn 0;\r\nundo:\r\nmutex_lock(&gref_mutex);\r\ngref_size -= (op->count - i);\r\nlist_for_each_entry_safe(gref, next, &queue_file, next_file) {\r\nlist_del(&gref->next_file);\r\n__del_gref(gref);\r\n}\r\nif (unlikely(!list_empty(&queue_gref)))\r\nlist_splice_tail(&queue_gref, &gref_list);\r\nmutex_unlock(&gref_mutex);\r\nreturn rc;\r\n}\r\nstatic void __del_gref(struct gntalloc_gref *gref)\r\n{\r\nif (gref->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\r\nuint8_t *tmp = kmap(gref->page);\r\ntmp[gref->notify.pgoff] = 0;\r\nkunmap(gref->page);\r\n}\r\nif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\r\nnotify_remote_via_evtchn(gref->notify.event);\r\nevtchn_put(gref->notify.event);\r\n}\r\ngref->notify.flags = 0;\r\nif (gref->gref_id) {\r\nif (gnttab_query_foreign_access(gref->gref_id))\r\nreturn;\r\nif (!gnttab_end_foreign_access_ref(gref->gref_id, 0))\r\nreturn;\r\ngnttab_free_grant_reference(gref->gref_id);\r\n}\r\ngref_size--;\r\nlist_del(&gref->next_gref);\r\nif (gref->page)\r\n__free_page(gref->page);\r\nkfree(gref);\r\n}\r\nstatic struct gntalloc_gref *find_grefs(struct gntalloc_file_private_data *priv,\r\nuint64_t index, uint32_t count)\r\n{\r\nstruct gntalloc_gref *rv = NULL, *gref;\r\nlist_for_each_entry(gref, &priv->list, next_file) {\r\nif (gref->file_index == index && !rv)\r\nrv = gref;\r\nif (rv) {\r\nif (gref->file_index != index)\r\nreturn NULL;\r\nindex += PAGE_SIZE;\r\ncount--;\r\nif (count == 0)\r\nreturn rv;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gntalloc_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct gntalloc_file_private_data *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\ngoto out_nomem;\r\nINIT_LIST_HEAD(&priv->list);\r\nfilp->private_data = priv;\r\npr_debug("%s: priv %p\n", __func__, priv);\r\nreturn 0;\r\nout_nomem:\r\nreturn -ENOMEM;\r\n}\r\nstatic int gntalloc_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct gntalloc_file_private_data *priv = filp->private_data;\r\nstruct gntalloc_gref *gref;\r\npr_debug("%s: priv %p\n", __func__, priv);\r\nmutex_lock(&gref_mutex);\r\nwhile (!list_empty(&priv->list)) {\r\ngref = list_entry(priv->list.next,\r\nstruct gntalloc_gref, next_file);\r\nlist_del(&gref->next_file);\r\ngref->users--;\r\nif (gref->users == 0)\r\n__del_gref(gref);\r\n}\r\nkfree(priv);\r\nmutex_unlock(&gref_mutex);\r\nreturn 0;\r\n}\r\nstatic long gntalloc_ioctl_alloc(struct gntalloc_file_private_data *priv,\r\nstruct ioctl_gntalloc_alloc_gref __user *arg)\r\n{\r\nint rc = 0;\r\nstruct ioctl_gntalloc_alloc_gref op;\r\nuint32_t *gref_ids;\r\npr_debug("%s: priv %p\n", __func__, priv);\r\nif (copy_from_user(&op, arg, sizeof(op))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\ngref_ids = kcalloc(op.count, sizeof(gref_ids[0]), GFP_TEMPORARY);\r\nif (!gref_ids) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmutex_lock(&gref_mutex);\r\ndo_cleanup();\r\nif (gref_size + op.count > limit) {\r\nmutex_unlock(&gref_mutex);\r\nrc = -ENOSPC;\r\ngoto out_free;\r\n}\r\ngref_size += op.count;\r\nop.index = priv->index;\r\npriv->index += op.count * PAGE_SIZE;\r\nmutex_unlock(&gref_mutex);\r\nrc = add_grefs(&op, gref_ids, priv);\r\nif (rc < 0)\r\ngoto out_free;\r\nif (copy_to_user(arg, &op, sizeof(op))) {\r\nrc = -EFAULT;\r\ngoto out_free;\r\n}\r\nif (copy_to_user(arg->gref_ids, gref_ids,\r\nsizeof(gref_ids[0]) * op.count)) {\r\nrc = -EFAULT;\r\ngoto out_free;\r\n}\r\nout_free:\r\nkfree(gref_ids);\r\nout:\r\nreturn rc;\r\n}\r\nstatic long gntalloc_ioctl_dealloc(struct gntalloc_file_private_data *priv,\r\nvoid __user *arg)\r\n{\r\nint i, rc = 0;\r\nstruct ioctl_gntalloc_dealloc_gref op;\r\nstruct gntalloc_gref *gref, *n;\r\npr_debug("%s: priv %p\n", __func__, priv);\r\nif (copy_from_user(&op, arg, sizeof(op))) {\r\nrc = -EFAULT;\r\ngoto dealloc_grant_out;\r\n}\r\nmutex_lock(&gref_mutex);\r\ngref = find_grefs(priv, op.index, op.count);\r\nif (gref) {\r\nfor (i = 0; i < op.count; i++) {\r\nn = list_entry(gref->next_file.next,\r\nstruct gntalloc_gref, next_file);\r\nlist_del(&gref->next_file);\r\ngref->users--;\r\ngref = n;\r\n}\r\n} else {\r\nrc = -EINVAL;\r\n}\r\ndo_cleanup();\r\nmutex_unlock(&gref_mutex);\r\ndealloc_grant_out:\r\nreturn rc;\r\n}\r\nstatic long gntalloc_ioctl_unmap_notify(struct gntalloc_file_private_data *priv,\r\nvoid __user *arg)\r\n{\r\nstruct ioctl_gntalloc_unmap_notify op;\r\nstruct gntalloc_gref *gref;\r\nuint64_t index;\r\nint pgoff;\r\nint rc;\r\nif (copy_from_user(&op, arg, sizeof(op)))\r\nreturn -EFAULT;\r\nindex = op.index & ~(PAGE_SIZE - 1);\r\npgoff = op.index & (PAGE_SIZE - 1);\r\nmutex_lock(&gref_mutex);\r\ngref = find_grefs(priv, index, 1);\r\nif (!gref) {\r\nrc = -ENOENT;\r\ngoto unlock_out;\r\n}\r\nif (op.action & ~(UNMAP_NOTIFY_CLEAR_BYTE|UNMAP_NOTIFY_SEND_EVENT)) {\r\nrc = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nif (op.action & UNMAP_NOTIFY_SEND_EVENT) {\r\nif (evtchn_get(op.event_channel_port)) {\r\nrc = -EINVAL;\r\ngoto unlock_out;\r\n}\r\n}\r\nif (gref->notify.flags & UNMAP_NOTIFY_SEND_EVENT)\r\nevtchn_put(gref->notify.event);\r\ngref->notify.flags = op.action;\r\ngref->notify.pgoff = pgoff;\r\ngref->notify.event = op.event_channel_port;\r\nrc = 0;\r\nunlock_out:\r\nmutex_unlock(&gref_mutex);\r\nreturn rc;\r\n}\r\nstatic long gntalloc_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct gntalloc_file_private_data *priv = filp->private_data;\r\nswitch (cmd) {\r\ncase IOCTL_GNTALLOC_ALLOC_GREF:\r\nreturn gntalloc_ioctl_alloc(priv, (void __user *)arg);\r\ncase IOCTL_GNTALLOC_DEALLOC_GREF:\r\nreturn gntalloc_ioctl_dealloc(priv, (void __user *)arg);\r\ncase IOCTL_GNTALLOC_SET_UNMAP_NOTIFY:\r\nreturn gntalloc_ioctl_unmap_notify(priv, (void __user *)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gntalloc_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct gntalloc_vma_private_data *priv = vma->vm_private_data;\r\nif (!priv)\r\nreturn;\r\nmutex_lock(&gref_mutex);\r\npriv->users++;\r\nmutex_unlock(&gref_mutex);\r\n}\r\nstatic void gntalloc_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct gntalloc_vma_private_data *priv = vma->vm_private_data;\r\nstruct gntalloc_gref *gref, *next;\r\nint i;\r\nif (!priv)\r\nreturn;\r\nmutex_lock(&gref_mutex);\r\npriv->users--;\r\nif (priv->users == 0) {\r\ngref = priv->gref;\r\nfor (i = 0; i < priv->count; i++) {\r\ngref->users--;\r\nnext = list_entry(gref->next_gref.next,\r\nstruct gntalloc_gref, next_gref);\r\nif (gref->users == 0)\r\n__del_gref(gref);\r\ngref = next;\r\n}\r\nkfree(priv);\r\n}\r\nmutex_unlock(&gref_mutex);\r\n}\r\nstatic int gntalloc_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct gntalloc_file_private_data *priv = filp->private_data;\r\nstruct gntalloc_vma_private_data *vm_priv;\r\nstruct gntalloc_gref *gref;\r\nint count = vma_pages(vma);\r\nint rv, i;\r\nif (!(vma->vm_flags & VM_SHARED)) {\r\npr_err("%s: Mapping must be shared\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nvm_priv = kmalloc(sizeof(*vm_priv), GFP_KERNEL);\r\nif (!vm_priv)\r\nreturn -ENOMEM;\r\nmutex_lock(&gref_mutex);\r\npr_debug("%s: priv %p,%p, page %lu+%d\n", __func__,\r\npriv, vm_priv, vma->vm_pgoff, count);\r\ngref = find_grefs(priv, vma->vm_pgoff << PAGE_SHIFT, count);\r\nif (gref == NULL) {\r\nrv = -ENOENT;\r\npr_debug("%s: Could not find grant reference",\r\n__func__);\r\nkfree(vm_priv);\r\ngoto out_unlock;\r\n}\r\nvm_priv->gref = gref;\r\nvm_priv->users = 1;\r\nvm_priv->count = count;\r\nvma->vm_private_data = vm_priv;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_ops = &gntalloc_vmops;\r\nfor (i = 0; i < count; i++) {\r\ngref->users++;\r\nrv = vm_insert_page(vma, vma->vm_start + i * PAGE_SIZE,\r\ngref->page);\r\nif (rv)\r\ngoto out_unlock;\r\ngref = list_entry(gref->next_file.next,\r\nstruct gntalloc_gref, next_file);\r\n}\r\nrv = 0;\r\nout_unlock:\r\nmutex_unlock(&gref_mutex);\r\nreturn rv;\r\n}\r\nstatic int __init gntalloc_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nerr = misc_register(&gntalloc_miscdev);\r\nif (err != 0) {\r\npr_err("Could not register misc gntalloc device\n");\r\nreturn err;\r\n}\r\npr_debug("Created grant allocation device at %d,%d\n",\r\nMISC_MAJOR, gntalloc_miscdev.minor);\r\nreturn 0;\r\n}\r\nstatic void __exit gntalloc_exit(void)\r\n{\r\nmisc_deregister(&gntalloc_miscdev);\r\n}
