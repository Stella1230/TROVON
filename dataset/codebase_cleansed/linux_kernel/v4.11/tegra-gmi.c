static int tegra_gmi_enable(struct tegra_gmi *gmi)\r\n{\r\nint err;\r\nerr = clk_prepare_enable(gmi->clk);\r\nif (err < 0) {\r\ndev_err(gmi->dev, "failed to enable clock: %d\n", err);\r\nreturn err;\r\n}\r\nreset_control_assert(gmi->rst);\r\nusleep_range(2000, 4000);\r\nreset_control_deassert(gmi->rst);\r\nwritel(gmi->snor_timing0, gmi->base + TEGRA_GMI_TIMING0);\r\nwritel(gmi->snor_timing1, gmi->base + TEGRA_GMI_TIMING1);\r\ngmi->snor_config |= TEGRA_GMI_CONFIG_GO;\r\nwritel(gmi->snor_config, gmi->base + TEGRA_GMI_CONFIG);\r\nreturn 0;\r\n}\r\nstatic void tegra_gmi_disable(struct tegra_gmi *gmi)\r\n{\r\nu32 config;\r\nconfig = readl(gmi->base + TEGRA_GMI_CONFIG);\r\nconfig &= ~TEGRA_GMI_CONFIG_GO;\r\nwritel(config, gmi->base + TEGRA_GMI_CONFIG);\r\nreset_control_assert(gmi->rst);\r\nclk_disable_unprepare(gmi->clk);\r\n}\r\nstatic int tegra_gmi_parse_dt(struct tegra_gmi *gmi)\r\n{\r\nstruct device_node *child;\r\nu32 property, ranges[4];\r\nint err;\r\nchild = of_get_next_available_child(gmi->dev->of_node, NULL);\r\nif (!child) {\r\ndev_err(gmi->dev, "no child nodes found\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_get_child_count(gmi->dev->of_node) > 1)\r\ndev_warn(gmi->dev, "only one child device is supported.");\r\nif (of_property_read_bool(child, "nvidia,snor-data-width-32bit"))\r\ngmi->snor_config |= TEGRA_GMI_BUS_WIDTH_32BIT;\r\nif (of_property_read_bool(child, "nvidia,snor-mux-mode"))\r\ngmi->snor_config |= TEGRA_GMI_MUX_MODE;\r\nif (of_property_read_bool(child, "nvidia,snor-rdy-active-before-data"))\r\ngmi->snor_config |= TEGRA_GMI_RDY_BEFORE_DATA;\r\nif (of_property_read_bool(child, "nvidia,snor-rdy-active-high"))\r\ngmi->snor_config |= TEGRA_GMI_RDY_ACTIVE_HIGH;\r\nif (of_property_read_bool(child, "nvidia,snor-adv-active-high"))\r\ngmi->snor_config |= TEGRA_GMI_ADV_ACTIVE_HIGH;\r\nif (of_property_read_bool(child, "nvidia,snor-oe-active-high"))\r\ngmi->snor_config |= TEGRA_GMI_OE_ACTIVE_HIGH;\r\nif (of_property_read_bool(child, "nvidia,snor-cs-active-high"))\r\ngmi->snor_config |= TEGRA_GMI_CS_ACTIVE_HIGH;\r\nerr = of_property_read_u32_array(child, "ranges", ranges, 4);\r\nif (err < 0) {\r\nif (err == -EOVERFLOW) {\r\ndev_err(gmi->dev,\r\n"failed to decode CS: invalid ranges length\n");\r\ngoto error_cs;\r\n}\r\nerr = of_property_read_u32(child, "reg", &property);\r\nif (err < 0) {\r\ndev_err(gmi->dev,\r\n"failed to decode CS: no reg property found\n");\r\ngoto error_cs;\r\n}\r\n} else {\r\nproperty = ranges[1];\r\n}\r\nif (property >= TEGRA_GMI_MAX_CHIP_SELECT) {\r\ndev_err(gmi->dev, "invalid chip select: %d", property);\r\nerr = -EINVAL;\r\ngoto error_cs;\r\n}\r\ngmi->snor_config |= TEGRA_GMI_CS_SELECT(property);\r\nif (!of_property_read_u32(child, "nvidia,snor-muxed-width", &property))\r\ngmi->snor_timing0 |= TEGRA_GMI_MUXED_WIDTH(property);\r\nelse\r\ngmi->snor_timing0 |= TEGRA_GMI_MUXED_WIDTH(1);\r\nif (!of_property_read_u32(child, "nvidia,snor-hold-width", &property))\r\ngmi->snor_timing0 |= TEGRA_GMI_HOLD_WIDTH(property);\r\nelse\r\ngmi->snor_timing0 |= TEGRA_GMI_HOLD_WIDTH(1);\r\nif (!of_property_read_u32(child, "nvidia,snor-adv-width", &property))\r\ngmi->snor_timing0 |= TEGRA_GMI_ADV_WIDTH(property);\r\nelse\r\ngmi->snor_timing0 |= TEGRA_GMI_ADV_WIDTH(1);\r\nif (!of_property_read_u32(child, "nvidia,snor-ce-width", &property))\r\ngmi->snor_timing0 |= TEGRA_GMI_CE_WIDTH(property);\r\nelse\r\ngmi->snor_timing0 |= TEGRA_GMI_CE_WIDTH(4);\r\nif (!of_property_read_u32(child, "nvidia,snor-we-width", &property))\r\ngmi->snor_timing1 |= TEGRA_GMI_WE_WIDTH(property);\r\nelse\r\ngmi->snor_timing1 |= TEGRA_GMI_WE_WIDTH(1);\r\nif (!of_property_read_u32(child, "nvidia,snor-oe-width", &property))\r\ngmi->snor_timing1 |= TEGRA_GMI_OE_WIDTH(property);\r\nelse\r\ngmi->snor_timing1 |= TEGRA_GMI_OE_WIDTH(1);\r\nif (!of_property_read_u32(child, "nvidia,snor-wait-width", &property))\r\ngmi->snor_timing1 |= TEGRA_GMI_WAIT_WIDTH(property);\r\nelse\r\ngmi->snor_timing1 |= TEGRA_GMI_WAIT_WIDTH(3);\r\nerror_cs:\r\nof_node_put(child);\r\nreturn err;\r\n}\r\nstatic int tegra_gmi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tegra_gmi *gmi;\r\nstruct resource *res;\r\nint err;\r\ngmi = devm_kzalloc(dev, sizeof(*gmi), GFP_KERNEL);\r\nif (!gmi)\r\nreturn -ENOMEM;\r\ngmi->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngmi->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(gmi->base))\r\nreturn PTR_ERR(gmi->base);\r\ngmi->clk = devm_clk_get(dev, "gmi");\r\nif (IS_ERR(gmi->clk)) {\r\ndev_err(dev, "can not get clock\n");\r\nreturn PTR_ERR(gmi->clk);\r\n}\r\ngmi->rst = devm_reset_control_get(dev, "gmi");\r\nif (IS_ERR(gmi->rst)) {\r\ndev_err(dev, "can not get reset\n");\r\nreturn PTR_ERR(gmi->rst);\r\n}\r\nerr = tegra_gmi_parse_dt(gmi);\r\nif (err)\r\nreturn err;\r\nerr = tegra_gmi_enable(gmi);\r\nif (err < 0)\r\nreturn err;\r\nerr = of_platform_default_populate(dev->of_node, NULL, dev);\r\nif (err < 0) {\r\ndev_err(dev, "fail to create devices.\n");\r\ntegra_gmi_disable(gmi);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, gmi);\r\nreturn 0;\r\n}\r\nstatic int tegra_gmi_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_gmi *gmi = platform_get_drvdata(pdev);\r\nof_platform_depopulate(gmi->dev);\r\ntegra_gmi_disable(gmi);\r\nreturn 0;\r\n}
