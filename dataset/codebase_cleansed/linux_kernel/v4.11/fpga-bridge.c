static int fpga_bridge_of_node_match(struct device *dev, const void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nint fpga_bridge_enable(struct fpga_bridge *bridge)\r\n{\r\ndev_dbg(&bridge->dev, "enable\n");\r\nif (bridge->br_ops && bridge->br_ops->enable_set)\r\nreturn bridge->br_ops->enable_set(bridge, 1);\r\nreturn 0;\r\n}\r\nint fpga_bridge_disable(struct fpga_bridge *bridge)\r\n{\r\ndev_dbg(&bridge->dev, "disable\n");\r\nif (bridge->br_ops && bridge->br_ops->enable_set)\r\nreturn bridge->br_ops->enable_set(bridge, 0);\r\nreturn 0;\r\n}\r\nstruct fpga_bridge *of_fpga_bridge_get(struct device_node *np,\r\nstruct fpga_image_info *info)\r\n{\r\nstruct device *dev;\r\nstruct fpga_bridge *bridge;\r\nint ret = -ENODEV;\r\ndev = class_find_device(fpga_bridge_class, NULL, np,\r\nfpga_bridge_of_node_match);\r\nif (!dev)\r\ngoto err_dev;\r\nbridge = to_fpga_bridge(dev);\r\nif (!bridge)\r\ngoto err_dev;\r\nbridge->info = info;\r\nif (!mutex_trylock(&bridge->mutex)) {\r\nret = -EBUSY;\r\ngoto err_dev;\r\n}\r\nif (!try_module_get(dev->parent->driver->owner))\r\ngoto err_ll_mod;\r\ndev_dbg(&bridge->dev, "get\n");\r\nreturn bridge;\r\nerr_ll_mod:\r\nmutex_unlock(&bridge->mutex);\r\nerr_dev:\r\nput_device(dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid fpga_bridge_put(struct fpga_bridge *bridge)\r\n{\r\ndev_dbg(&bridge->dev, "put\n");\r\nbridge->info = NULL;\r\nmodule_put(bridge->dev.parent->driver->owner);\r\nmutex_unlock(&bridge->mutex);\r\nput_device(&bridge->dev);\r\n}\r\nint fpga_bridges_enable(struct list_head *bridge_list)\r\n{\r\nstruct fpga_bridge *bridge;\r\nstruct list_head *node;\r\nint ret;\r\nlist_for_each(node, bridge_list) {\r\nbridge = list_entry(node, struct fpga_bridge, node);\r\nret = fpga_bridge_enable(bridge);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint fpga_bridges_disable(struct list_head *bridge_list)\r\n{\r\nstruct fpga_bridge *bridge;\r\nstruct list_head *node;\r\nint ret;\r\nlist_for_each(node, bridge_list) {\r\nbridge = list_entry(node, struct fpga_bridge, node);\r\nret = fpga_bridge_disable(bridge);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid fpga_bridges_put(struct list_head *bridge_list)\r\n{\r\nstruct fpga_bridge *bridge;\r\nstruct list_head *node, *next;\r\nunsigned long flags;\r\nlist_for_each_safe(node, next, bridge_list) {\r\nbridge = list_entry(node, struct fpga_bridge, node);\r\nfpga_bridge_put(bridge);\r\nspin_lock_irqsave(&bridge_list_lock, flags);\r\nlist_del(&bridge->node);\r\nspin_unlock_irqrestore(&bridge_list_lock, flags);\r\n}\r\n}\r\nint fpga_bridge_get_to_list(struct device_node *np,\r\nstruct fpga_image_info *info,\r\nstruct list_head *bridge_list)\r\n{\r\nstruct fpga_bridge *bridge;\r\nunsigned long flags;\r\nbridge = of_fpga_bridge_get(np, info);\r\nif (IS_ERR(bridge))\r\nreturn PTR_ERR(bridge);\r\nspin_lock_irqsave(&bridge_list_lock, flags);\r\nlist_add(&bridge->node, bridge_list);\r\nspin_unlock_irqrestore(&bridge_list_lock, flags);\r\nreturn 0;\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fpga_bridge *bridge = to_fpga_bridge(dev);\r\nreturn sprintf(buf, "%s\n", bridge->name);\r\n}\r\nstatic ssize_t state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fpga_bridge *bridge = to_fpga_bridge(dev);\r\nint enable = 1;\r\nif (bridge->br_ops && bridge->br_ops->enable_show)\r\nenable = bridge->br_ops->enable_show(bridge);\r\nreturn sprintf(buf, "%s\n", enable ? "enabled" : "disabled");\r\n}\r\nint fpga_bridge_register(struct device *dev, const char *name,\r\nconst struct fpga_bridge_ops *br_ops, void *priv)\r\n{\r\nstruct fpga_bridge *bridge;\r\nint id, ret = 0;\r\nif (!name || !strlen(name)) {\r\ndev_err(dev, "Attempt to register with no name!\n");\r\nreturn -EINVAL;\r\n}\r\nbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nid = ida_simple_get(&fpga_bridge_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nret = id;\r\ngoto error_kfree;\r\n}\r\nmutex_init(&bridge->mutex);\r\nINIT_LIST_HEAD(&bridge->node);\r\nbridge->name = name;\r\nbridge->br_ops = br_ops;\r\nbridge->priv = priv;\r\ndevice_initialize(&bridge->dev);\r\nbridge->dev.class = fpga_bridge_class;\r\nbridge->dev.parent = dev;\r\nbridge->dev.of_node = dev->of_node;\r\nbridge->dev.id = id;\r\ndev_set_drvdata(dev, bridge);\r\nret = dev_set_name(&bridge->dev, "br%d", id);\r\nif (ret)\r\ngoto error_device;\r\nret = device_add(&bridge->dev);\r\nif (ret)\r\ngoto error_device;\r\nof_platform_populate(dev->of_node, NULL, NULL, dev);\r\ndev_info(bridge->dev.parent, "fpga bridge [%s] registered\n",\r\nbridge->name);\r\nreturn 0;\r\nerror_device:\r\nida_simple_remove(&fpga_bridge_ida, id);\r\nerror_kfree:\r\nkfree(bridge);\r\nreturn ret;\r\n}\r\nvoid fpga_bridge_unregister(struct device *dev)\r\n{\r\nstruct fpga_bridge *bridge = dev_get_drvdata(dev);\r\nif (bridge->br_ops && bridge->br_ops->fpga_bridge_remove)\r\nbridge->br_ops->fpga_bridge_remove(bridge);\r\ndevice_unregister(&bridge->dev);\r\n}\r\nstatic void fpga_bridge_dev_release(struct device *dev)\r\n{\r\nstruct fpga_bridge *bridge = to_fpga_bridge(dev);\r\nida_simple_remove(&fpga_bridge_ida, bridge->dev.id);\r\nkfree(bridge);\r\n}\r\nstatic int __init fpga_bridge_dev_init(void)\r\n{\r\nspin_lock_init(&bridge_list_lock);\r\nfpga_bridge_class = class_create(THIS_MODULE, "fpga_bridge");\r\nif (IS_ERR(fpga_bridge_class))\r\nreturn PTR_ERR(fpga_bridge_class);\r\nfpga_bridge_class->dev_groups = fpga_bridge_groups;\r\nfpga_bridge_class->dev_release = fpga_bridge_dev_release;\r\nreturn 0;\r\n}\r\nstatic void __exit fpga_bridge_dev_exit(void)\r\n{\r\nclass_destroy(fpga_bridge_class);\r\nida_destroy(&fpga_bridge_ida);\r\n}
