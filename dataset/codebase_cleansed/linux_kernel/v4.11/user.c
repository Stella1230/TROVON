static int snapshot_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct snapshot_data *data;\r\nint error, nr_calls = 0;\r\nif (!hibernation_available())\r\nreturn -EPERM;\r\nlock_system_sleep();\r\nif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\r\nerror = -EBUSY;\r\ngoto Unlock;\r\n}\r\nif ((filp->f_flags & O_ACCMODE) == O_RDWR) {\r\natomic_inc(&snapshot_device_available);\r\nerror = -ENOSYS;\r\ngoto Unlock;\r\n}\r\nnonseekable_open(inode, filp);\r\ndata = &snapshot_state;\r\nfilp->private_data = data;\r\nmemset(&data->handle, 0, sizeof(struct snapshot_handle));\r\nif ((filp->f_flags & O_ACCMODE) == O_RDONLY) {\r\ndata->swap = swsusp_resume_device ?\r\nswap_type_of(swsusp_resume_device, 0, NULL) : -1;\r\ndata->mode = O_RDONLY;\r\ndata->free_bitmaps = false;\r\nerror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\r\nif (error)\r\n__pm_notifier_call_chain(PM_POST_HIBERNATION, --nr_calls, NULL);\r\n} else {\r\nwait_for_device_probe();\r\ndata->swap = -1;\r\ndata->mode = O_WRONLY;\r\nerror = __pm_notifier_call_chain(PM_RESTORE_PREPARE, -1, &nr_calls);\r\nif (!error) {\r\nerror = create_basic_memory_bitmaps();\r\ndata->free_bitmaps = !error;\r\n} else\r\nnr_calls--;\r\nif (error)\r\n__pm_notifier_call_chain(PM_POST_RESTORE, nr_calls, NULL);\r\n}\r\nif (error)\r\natomic_inc(&snapshot_device_available);\r\ndata->frozen = false;\r\ndata->ready = false;\r\ndata->platform_support = false;\r\nUnlock:\r\nunlock_system_sleep();\r\nreturn error;\r\n}\r\nstatic int snapshot_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct snapshot_data *data;\r\nlock_system_sleep();\r\nswsusp_free();\r\ndata = filp->private_data;\r\nfree_all_swap_pages(data->swap);\r\nif (data->frozen) {\r\npm_restore_gfp_mask();\r\nfree_basic_memory_bitmaps();\r\nthaw_processes();\r\n} else if (data->free_bitmaps) {\r\nfree_basic_memory_bitmaps();\r\n}\r\npm_notifier_call_chain(data->mode == O_RDONLY ?\r\nPM_POST_HIBERNATION : PM_POST_RESTORE);\r\natomic_inc(&snapshot_device_available);\r\nunlock_system_sleep();\r\nreturn 0;\r\n}\r\nstatic ssize_t snapshot_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct snapshot_data *data;\r\nssize_t res;\r\nloff_t pg_offp = *offp & ~PAGE_MASK;\r\nlock_system_sleep();\r\ndata = filp->private_data;\r\nif (!data->ready) {\r\nres = -ENODATA;\r\ngoto Unlock;\r\n}\r\nif (!pg_offp) {\r\nres = snapshot_read_next(&data->handle);\r\nif (res <= 0)\r\ngoto Unlock;\r\n} else {\r\nres = PAGE_SIZE - pg_offp;\r\n}\r\nres = simple_read_from_buffer(buf, count, &pg_offp,\r\ndata_of(data->handle), res);\r\nif (res > 0)\r\n*offp += res;\r\nUnlock:\r\nunlock_system_sleep();\r\nreturn res;\r\n}\r\nstatic ssize_t snapshot_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct snapshot_data *data;\r\nssize_t res;\r\nloff_t pg_offp = *offp & ~PAGE_MASK;\r\nlock_system_sleep();\r\ndata = filp->private_data;\r\nif (!pg_offp) {\r\nres = snapshot_write_next(&data->handle);\r\nif (res <= 0)\r\ngoto unlock;\r\n} else {\r\nres = PAGE_SIZE - pg_offp;\r\n}\r\nres = simple_write_to_buffer(data_of(data->handle), res, &pg_offp,\r\nbuf, count);\r\nif (res > 0)\r\n*offp += res;\r\nunlock:\r\nunlock_system_sleep();\r\nreturn res;\r\n}\r\nstatic long snapshot_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint error = 0;\r\nstruct snapshot_data *data;\r\nloff_t size;\r\nsector_t offset;\r\nif (_IOC_TYPE(cmd) != SNAPSHOT_IOC_MAGIC)\r\nreturn -ENOTTY;\r\nif (_IOC_NR(cmd) > SNAPSHOT_IOC_MAXNR)\r\nreturn -ENOTTY;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!mutex_trylock(&pm_mutex))\r\nreturn -EBUSY;\r\nlock_device_hotplug();\r\ndata = filp->private_data;\r\nswitch (cmd) {\r\ncase SNAPSHOT_FREEZE:\r\nif (data->frozen)\r\nbreak;\r\nprintk("Syncing filesystems ... ");\r\nsys_sync();\r\nprintk("done.\n");\r\nerror = freeze_processes();\r\nif (error)\r\nbreak;\r\nerror = create_basic_memory_bitmaps();\r\nif (error)\r\nthaw_processes();\r\nelse\r\ndata->frozen = true;\r\nbreak;\r\ncase SNAPSHOT_UNFREEZE:\r\nif (!data->frozen || data->ready)\r\nbreak;\r\npm_restore_gfp_mask();\r\nfree_basic_memory_bitmaps();\r\ndata->free_bitmaps = false;\r\nthaw_processes();\r\ndata->frozen = false;\r\nbreak;\r\ncase SNAPSHOT_CREATE_IMAGE:\r\nif (data->mode != O_RDONLY || !data->frozen || data->ready) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\npm_restore_gfp_mask();\r\nerror = hibernation_snapshot(data->platform_support);\r\nif (!error) {\r\nerror = put_user(in_suspend, (int __user *)arg);\r\ndata->ready = !freezer_test_done && !error;\r\nfreezer_test_done = false;\r\n}\r\nbreak;\r\ncase SNAPSHOT_ATOMIC_RESTORE:\r\nsnapshot_write_finalize(&data->handle);\r\nif (data->mode != O_WRONLY || !data->frozen ||\r\n!snapshot_image_loaded(&data->handle)) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\nerror = hibernation_restore(data->platform_support);\r\nbreak;\r\ncase SNAPSHOT_FREE:\r\nswsusp_free();\r\nmemset(&data->handle, 0, sizeof(struct snapshot_handle));\r\ndata->ready = false;\r\nthaw_kernel_threads();\r\nbreak;\r\ncase SNAPSHOT_PREF_IMAGE_SIZE:\r\nimage_size = arg;\r\nbreak;\r\ncase SNAPSHOT_GET_IMAGE_SIZE:\r\nif (!data->ready) {\r\nerror = -ENODATA;\r\nbreak;\r\n}\r\nsize = snapshot_get_image_size();\r\nsize <<= PAGE_SHIFT;\r\nerror = put_user(size, (loff_t __user *)arg);\r\nbreak;\r\ncase SNAPSHOT_AVAIL_SWAP_SIZE:\r\nsize = count_swap_pages(data->swap, 1);\r\nsize <<= PAGE_SHIFT;\r\nerror = put_user(size, (loff_t __user *)arg);\r\nbreak;\r\ncase SNAPSHOT_ALLOC_SWAP_PAGE:\r\nif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\r\nerror = -ENODEV;\r\nbreak;\r\n}\r\noffset = alloc_swapdev_block(data->swap);\r\nif (offset) {\r\noffset <<= PAGE_SHIFT;\r\nerror = put_user(offset, (loff_t __user *)arg);\r\n} else {\r\nerror = -ENOSPC;\r\n}\r\nbreak;\r\ncase SNAPSHOT_FREE_SWAP_PAGES:\r\nif (data->swap < 0 || data->swap >= MAX_SWAPFILES) {\r\nerror = -ENODEV;\r\nbreak;\r\n}\r\nfree_all_swap_pages(data->swap);\r\nbreak;\r\ncase SNAPSHOT_S2RAM:\r\nif (!data->frozen) {\r\nerror = -EPERM;\r\nbreak;\r\n}\r\nerror = suspend_devices_and_enter(PM_SUSPEND_MEM);\r\ndata->ready = false;\r\nbreak;\r\ncase SNAPSHOT_PLATFORM_SUPPORT:\r\ndata->platform_support = !!arg;\r\nbreak;\r\ncase SNAPSHOT_POWER_OFF:\r\nif (data->platform_support)\r\nerror = hibernation_platform_enter();\r\nbreak;\r\ncase SNAPSHOT_SET_SWAP_AREA:\r\nif (swsusp_swap_in_use()) {\r\nerror = -EPERM;\r\n} else {\r\nstruct resume_swap_area swap_area;\r\ndev_t swdev;\r\nerror = copy_from_user(&swap_area, (void __user *)arg,\r\nsizeof(struct resume_swap_area));\r\nif (error) {\r\nerror = -EFAULT;\r\nbreak;\r\n}\r\nswdev = new_decode_dev(swap_area.dev);\r\nif (swdev) {\r\noffset = swap_area.offset;\r\ndata->swap = swap_type_of(swdev, offset, NULL);\r\nif (data->swap < 0)\r\nerror = -ENODEV;\r\n} else {\r\ndata->swap = -1;\r\nerror = -EINVAL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nerror = -ENOTTY;\r\n}\r\nunlock_device_hotplug();\r\nmutex_unlock(&pm_mutex);\r\nreturn error;\r\n}\r\nstatic long\r\nsnapshot_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nBUILD_BUG_ON(sizeof(loff_t) != sizeof(compat_loff_t));\r\nswitch (cmd) {\r\ncase SNAPSHOT_GET_IMAGE_SIZE:\r\ncase SNAPSHOT_AVAIL_SWAP_SIZE:\r\ncase SNAPSHOT_ALLOC_SWAP_PAGE: {\r\ncompat_loff_t __user *uoffset = compat_ptr(arg);\r\nloff_t offset;\r\nmm_segment_t old_fs;\r\nint err;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = snapshot_ioctl(file, cmd, (unsigned long) &offset);\r\nset_fs(old_fs);\r\nif (!err && put_user(offset, uoffset))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\ncase SNAPSHOT_CREATE_IMAGE:\r\nreturn snapshot_ioctl(file, cmd,\r\n(unsigned long) compat_ptr(arg));\r\ncase SNAPSHOT_SET_SWAP_AREA: {\r\nstruct compat_resume_swap_area __user *u_swap_area =\r\ncompat_ptr(arg);\r\nstruct resume_swap_area swap_area;\r\nmm_segment_t old_fs;\r\nint err;\r\nerr = get_user(swap_area.offset, &u_swap_area->offset);\r\nerr |= get_user(swap_area.dev, &u_swap_area->dev);\r\nif (err)\r\nreturn -EFAULT;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = snapshot_ioctl(file, SNAPSHOT_SET_SWAP_AREA,\r\n(unsigned long) &swap_area);\r\nset_fs(old_fs);\r\nreturn err;\r\n}\r\ndefault:\r\nreturn snapshot_ioctl(file, cmd, arg);\r\n}\r\n}\r\nstatic int __init snapshot_device_init(void)\r\n{\r\nreturn misc_register(&snapshot_device);\r\n}
