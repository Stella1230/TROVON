struct group_info *groups_alloc(int gidsetsize)\r\n{\r\nstruct group_info *gi;\r\nunsigned int len;\r\nlen = sizeof(struct group_info) + sizeof(kgid_t) * gidsetsize;\r\ngi = kmalloc(len, GFP_KERNEL_ACCOUNT|__GFP_NOWARN|__GFP_NORETRY);\r\nif (!gi)\r\ngi = __vmalloc(len, GFP_KERNEL_ACCOUNT|__GFP_HIGHMEM, PAGE_KERNEL);\r\nif (!gi)\r\nreturn NULL;\r\natomic_set(&gi->usage, 1);\r\ngi->ngroups = gidsetsize;\r\nreturn gi;\r\n}\r\nvoid groups_free(struct group_info *group_info)\r\n{\r\nkvfree(group_info);\r\n}\r\nstatic int groups_to_user(gid_t __user *grouplist,\r\nconst struct group_info *group_info)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nunsigned int count = group_info->ngroups;\r\nfor (i = 0; i < count; i++) {\r\ngid_t gid;\r\ngid = from_kgid_munged(user_ns, group_info->gid[i]);\r\nif (put_user(gid, grouplist+i))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int groups_from_user(struct group_info *group_info,\r\ngid_t __user *grouplist)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nunsigned int count = group_info->ngroups;\r\nfor (i = 0; i < count; i++) {\r\ngid_t gid;\r\nkgid_t kgid;\r\nif (get_user(gid, grouplist+i))\r\nreturn -EFAULT;\r\nkgid = make_kgid(user_ns, gid);\r\nif (!gid_valid(kgid))\r\nreturn -EINVAL;\r\ngroup_info->gid[i] = kgid;\r\n}\r\nreturn 0;\r\n}\r\nstatic void groups_sort(struct group_info *group_info)\r\n{\r\nint base, max, stride;\r\nint gidsetsize = group_info->ngroups;\r\nfor (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)\r\n;\r\nstride /= 3;\r\nwhile (stride) {\r\nmax = gidsetsize - stride;\r\nfor (base = 0; base < max; base++) {\r\nint left = base;\r\nint right = left + stride;\r\nkgid_t tmp = group_info->gid[right];\r\nwhile (left >= 0 && gid_gt(group_info->gid[left], tmp)) {\r\ngroup_info->gid[right] = group_info->gid[left];\r\nright = left;\r\nleft -= stride;\r\n}\r\ngroup_info->gid[right] = tmp;\r\n}\r\nstride /= 3;\r\n}\r\n}\r\nint groups_search(const struct group_info *group_info, kgid_t grp)\r\n{\r\nunsigned int left, right;\r\nif (!group_info)\r\nreturn 0;\r\nleft = 0;\r\nright = group_info->ngroups;\r\nwhile (left < right) {\r\nunsigned int mid = (left+right)/2;\r\nif (gid_gt(grp, group_info->gid[mid]))\r\nleft = mid + 1;\r\nelse if (gid_lt(grp, group_info->gid[mid]))\r\nright = mid;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid set_groups(struct cred *new, struct group_info *group_info)\r\n{\r\nput_group_info(new->group_info);\r\ngroups_sort(group_info);\r\nget_group_info(group_info);\r\nnew->group_info = group_info;\r\n}\r\nint set_current_groups(struct group_info *group_info)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nset_groups(new, group_info);\r\nreturn commit_creds(new);\r\n}\r\nbool may_setgroups(void)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nreturn ns_capable(user_ns, CAP_SETGID) &&\r\nuserns_may_setgroups(user_ns);\r\n}\r\nint in_group_p(kgid_t grp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval = 1;\r\nif (!gid_eq(grp, cred->fsgid))\r\nretval = groups_search(cred->group_info, grp);\r\nreturn retval;\r\n}\r\nint in_egroup_p(kgid_t grp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval = 1;\r\nif (!gid_eq(grp, cred->egid))\r\nretval = groups_search(cred->group_info, grp);\r\nreturn retval;\r\n}
