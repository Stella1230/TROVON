static int tpa6130a2_power(struct tpa6130a2_data *data, bool enable)\r\n{\r\nint ret = 0, ret2;\r\nif (enable) {\r\nret = regulator_enable(data->supply);\r\nif (ret != 0) {\r\ndev_err(data->dev,\r\n"Failed to enable supply: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 1);\r\nregcache_cache_only(data->regmap, false);\r\nret = regcache_sync(data->regmap);\r\nif (ret != 0) {\r\ndev_err(data->dev,\r\n"Failed to sync registers: %d\n", ret);\r\nregcache_cache_only(data->regmap, true);\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 0);\r\nret2 = regulator_disable(data->supply);\r\nif (ret2 != 0)\r\ndev_err(data->dev,\r\n"Failed to disable supply: %d\n", ret2);\r\nreturn ret;\r\n}\r\n} else {\r\nregcache_mark_dirty(data->regmap);\r\nregcache_cache_only(data->regmap, true);\r\nif (data->power_gpio >= 0)\r\ngpio_set_value(data->power_gpio, 0);\r\nret = regulator_disable(data->supply);\r\nif (ret != 0) {\r\ndev_err(data->dev,\r\n"Failed to disable supply: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tpa6130a2_power_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kctrl, int event)\r\n{\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct tpa6130a2_data *data = snd_soc_component_get_drvdata(c);\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nreturn tpa6130a2_power(data, true);\r\n} else {\r\nreturn tpa6130a2_power(data, false);\r\n}\r\n}\r\nstatic int tpa6130a2_component_probe(struct snd_soc_component *component)\r\n{\r\nstruct tpa6130a2_data *data = snd_soc_component_get_drvdata(component);\r\nif (data->id == TPA6140A2)\r\nreturn snd_soc_add_component_controls(component,\r\ntpa6140a2_controls, ARRAY_SIZE(tpa6140a2_controls));\r\nelse\r\nreturn snd_soc_add_component_controls(component,\r\ntpa6130a2_controls, ARRAY_SIZE(tpa6130a2_controls));\r\n}\r\nstatic int tpa6130a2_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev;\r\nstruct tpa6130a2_data *data;\r\nstruct tpa6130a2_platform_data *pdata = client->dev.platform_data;\r\nstruct device_node *np = client->dev.of_node;\r\nconst char *regulator;\r\nunsigned int version;\r\nint ret;\r\ndev = &client->dev;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dev = dev;\r\ndata->regmap = devm_regmap_init_i2c(client, &tpa6130a2_regmap_config);\r\nif (IS_ERR(data->regmap))\r\nreturn PTR_ERR(data->regmap);\r\nif (pdata) {\r\ndata->power_gpio = pdata->power_gpio;\r\n} else if (np) {\r\ndata->power_gpio = of_get_named_gpio(np, "power-gpio", 0);\r\n} else {\r\ndev_err(dev, "Platform data not set\n");\r\ndump_stack();\r\nreturn -ENODEV;\r\n}\r\ni2c_set_clientdata(client, data);\r\ndata->id = id->driver_data;\r\nif (data->power_gpio >= 0) {\r\nret = devm_gpio_request(dev, data->power_gpio,\r\n"tpa6130a2 enable");\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request power GPIO (%d)\n",\r\ndata->power_gpio);\r\nreturn ret;\r\n}\r\ngpio_direction_output(data->power_gpio, 0);\r\n}\r\nswitch (data->id) {\r\ndefault:\r\ndev_warn(dev, "Unknown TPA model (%d). Assuming 6130A2\n",\r\ndata->id);\r\ncase TPA6130A2:\r\nregulator = "Vdd";\r\nbreak;\r\ncase TPA6140A2:\r\nregulator = "AVdd";\r\nbreak;\r\n}\r\ndata->supply = devm_regulator_get(dev, regulator);\r\nif (IS_ERR(data->supply)) {\r\nret = PTR_ERR(data->supply);\r\ndev_err(dev, "Failed to request supply: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = tpa6130a2_power(data, true);\r\nif (ret != 0)\r\nreturn ret;\r\nregmap_read(data->regmap, TPA6130A2_REG_VERSION, &version);\r\nversion &= TPA6130A2_VERSION_MASK;\r\nif ((version != 1) && (version != 2))\r\ndev_warn(dev, "UNTESTED version detected (%d)\n", version);\r\nret = tpa6130a2_power(data, false);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn devm_snd_soc_register_component(&client->dev,\r\n&tpa6130a2_component_driver, NULL, 0);\r\n}
