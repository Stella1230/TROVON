static u32 fw_hash(u32 handle)\r\n{\r\nhandle ^= (handle >> 16);\r\nhandle ^= (handle >> 8);\r\nreturn handle % HTSIZE;\r\n}\r\nstatic int fw_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nstruct fw_head *head = rcu_dereference_bh(tp->root);\r\nstruct fw_filter *f;\r\nint r;\r\nu32 id = skb->mark;\r\nif (head != NULL) {\r\nid &= head->mask;\r\nfor (f = rcu_dereference_bh(head->ht[fw_hash(id)]); f;\r\nf = rcu_dereference_bh(f->next)) {\r\nif (f->id == id) {\r\n*res = f->res;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (!tcf_match_indev(skb, f->ifindex))\r\ncontinue;\r\n#endif\r\nr = tcf_exts_exec(skb, &f->exts, res);\r\nif (r < 0)\r\ncontinue;\r\nreturn r;\r\n}\r\n}\r\n} else {\r\nif (id && (TC_H_MAJ(id) == 0 ||\r\n!(TC_H_MAJ(id ^ tp->q->handle)))) {\r\nres->classid = id;\r\nres->class = 0;\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned long fw_get(struct tcf_proto *tp, u32 handle)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct fw_filter *f;\r\nif (head == NULL)\r\nreturn 0;\r\nf = rtnl_dereference(head->ht[fw_hash(handle)]);\r\nfor (; f; f = rtnl_dereference(f->next)) {\r\nif (f->id == handle)\r\nreturn (unsigned long)f;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fw_init(struct tcf_proto *tp)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fw_delete_filter(struct rcu_head *head)\r\n{\r\nstruct fw_filter *f = container_of(head, struct fw_filter, rcu);\r\ntcf_exts_destroy(&f->exts);\r\nkfree(f);\r\n}\r\nstatic bool fw_destroy(struct tcf_proto *tp, bool force)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct fw_filter *f;\r\nint h;\r\nif (head == NULL)\r\nreturn true;\r\nif (!force) {\r\nfor (h = 0; h < HTSIZE; h++)\r\nif (rcu_access_pointer(head->ht[h]))\r\nreturn false;\r\n}\r\nfor (h = 0; h < HTSIZE; h++) {\r\nwhile ((f = rtnl_dereference(head->ht[h])) != NULL) {\r\nRCU_INIT_POINTER(head->ht[h],\r\nrtnl_dereference(f->next));\r\ntcf_unbind_filter(tp, &f->res);\r\ncall_rcu(&f->rcu, fw_delete_filter);\r\n}\r\n}\r\nRCU_INIT_POINTER(tp->root, NULL);\r\nkfree_rcu(head, rcu);\r\nreturn true;\r\n}\r\nstatic int fw_delete(struct tcf_proto *tp, unsigned long arg)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct fw_filter *f = (struct fw_filter *)arg;\r\nstruct fw_filter __rcu **fp;\r\nstruct fw_filter *pfp;\r\nif (head == NULL || f == NULL)\r\ngoto out;\r\nfp = &head->ht[fw_hash(f->id)];\r\nfor (pfp = rtnl_dereference(*fp); pfp;\r\nfp = &pfp->next, pfp = rtnl_dereference(*fp)) {\r\nif (pfp == f) {\r\nRCU_INIT_POINTER(*fp, rtnl_dereference(f->next));\r\ntcf_unbind_filter(tp, &f->res);\r\ncall_rcu(&f->rcu, fw_delete_filter);\r\nreturn 0;\r\n}\r\n}\r\nout:\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfw_change_attrs(struct net *net, struct tcf_proto *tp, struct fw_filter *f,\r\nstruct nlattr **tb, struct nlattr **tca, unsigned long base,\r\nbool ovr)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct tcf_exts e;\r\nu32 mask;\r\nint err;\r\nerr = tcf_exts_init(&e, TCA_FW_ACT, TCA_FW_POLICE);\r\nif (err < 0)\r\nreturn err;\r\nerr = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, ovr);\r\nif (err < 0)\r\ngoto errout;\r\nif (tb[TCA_FW_CLASSID]) {\r\nf->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]);\r\ntcf_bind_filter(tp, &f->res, base);\r\n}\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (tb[TCA_FW_INDEV]) {\r\nint ret;\r\nret = tcf_change_indev(net, tb[TCA_FW_INDEV]);\r\nif (ret < 0) {\r\nerr = ret;\r\ngoto errout;\r\n}\r\nf->ifindex = ret;\r\n}\r\n#endif\r\nerr = -EINVAL;\r\nif (tb[TCA_FW_MASK]) {\r\nmask = nla_get_u32(tb[TCA_FW_MASK]);\r\nif (mask != head->mask)\r\ngoto errout;\r\n} else if (head->mask != 0xFFFFFFFF)\r\ngoto errout;\r\ntcf_exts_change(tp, &f->exts, &e);\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(&e);\r\nreturn err;\r\n}\r\nstatic int fw_change(struct net *net, struct sk_buff *in_skb,\r\nstruct tcf_proto *tp, unsigned long base,\r\nu32 handle, struct nlattr **tca, unsigned long *arg,\r\nbool ovr)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct fw_filter *f = (struct fw_filter *) *arg;\r\nstruct nlattr *opt = tca[TCA_OPTIONS];\r\nstruct nlattr *tb[TCA_FW_MAX + 1];\r\nint err;\r\nif (!opt)\r\nreturn handle ? -EINVAL : 0;\r\nerr = nla_parse_nested(tb, TCA_FW_MAX, opt, fw_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (f) {\r\nstruct fw_filter *pfp, *fnew;\r\nstruct fw_filter __rcu **fp;\r\nif (f->id != handle && handle)\r\nreturn -EINVAL;\r\nfnew = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);\r\nif (!fnew)\r\nreturn -ENOBUFS;\r\nfnew->id = f->id;\r\nfnew->res = f->res;\r\n#ifdef CONFIG_NET_CLS_IND\r\nfnew->ifindex = f->ifindex;\r\n#endif\r\nfnew->tp = f->tp;\r\nerr = tcf_exts_init(&fnew->exts, TCA_FW_ACT, TCA_FW_POLICE);\r\nif (err < 0) {\r\nkfree(fnew);\r\nreturn err;\r\n}\r\nerr = fw_change_attrs(net, tp, fnew, tb, tca, base, ovr);\r\nif (err < 0) {\r\ntcf_exts_destroy(&fnew->exts);\r\nkfree(fnew);\r\nreturn err;\r\n}\r\nfp = &head->ht[fw_hash(fnew->id)];\r\nfor (pfp = rtnl_dereference(*fp); pfp;\r\nfp = &pfp->next, pfp = rtnl_dereference(*fp))\r\nif (pfp == f)\r\nbreak;\r\nRCU_INIT_POINTER(fnew->next, rtnl_dereference(pfp->next));\r\nrcu_assign_pointer(*fp, fnew);\r\ntcf_unbind_filter(tp, &f->res);\r\ncall_rcu(&f->rcu, fw_delete_filter);\r\n*arg = (unsigned long)fnew;\r\nreturn err;\r\n}\r\nif (!handle)\r\nreturn -EINVAL;\r\nif (!head) {\r\nu32 mask = 0xFFFFFFFF;\r\nif (tb[TCA_FW_MASK])\r\nmask = nla_get_u32(tb[TCA_FW_MASK]);\r\nhead = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (!head)\r\nreturn -ENOBUFS;\r\nhead->mask = mask;\r\nrcu_assign_pointer(tp->root, head);\r\n}\r\nf = kzalloc(sizeof(struct fw_filter), GFP_KERNEL);\r\nif (f == NULL)\r\nreturn -ENOBUFS;\r\nerr = tcf_exts_init(&f->exts, TCA_FW_ACT, TCA_FW_POLICE);\r\nif (err < 0)\r\ngoto errout;\r\nf->id = handle;\r\nf->tp = tp;\r\nerr = fw_change_attrs(net, tp, f, tb, tca, base, ovr);\r\nif (err < 0)\r\ngoto errout;\r\nRCU_INIT_POINTER(f->next, head->ht[fw_hash(handle)]);\r\nrcu_assign_pointer(head->ht[fw_hash(handle)], f);\r\n*arg = (unsigned long)f;\r\nreturn 0;\r\nerrout:\r\ntcf_exts_destroy(&f->exts);\r\nkfree(f);\r\nreturn err;\r\n}\r\nstatic void fw_walk(struct tcf_proto *tp, struct tcf_walker *arg)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nint h;\r\nif (head == NULL)\r\narg->stop = 1;\r\nif (arg->stop)\r\nreturn;\r\nfor (h = 0; h < HTSIZE; h++) {\r\nstruct fw_filter *f;\r\nfor (f = rtnl_dereference(head->ht[h]); f;\r\nf = rtnl_dereference(f->next)) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(tp, (unsigned long)f, arg) < 0) {\r\narg->stop = 1;\r\nreturn;\r\n}\r\narg->count++;\r\n}\r\n}\r\n}\r\nstatic int fw_dump(struct net *net, struct tcf_proto *tp, unsigned long fh,\r\nstruct sk_buff *skb, struct tcmsg *t)\r\n{\r\nstruct fw_head *head = rtnl_dereference(tp->root);\r\nstruct fw_filter *f = (struct fw_filter *)fh;\r\nstruct nlattr *nest;\r\nif (f == NULL)\r\nreturn skb->len;\r\nt->tcm_handle = f->id;\r\nif (!f->res.classid && !tcf_exts_is_available(&f->exts))\r\nreturn skb->len;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (f->res.classid &&\r\nnla_put_u32(skb, TCA_FW_CLASSID, f->res.classid))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_NET_CLS_IND\r\nif (f->ifindex) {\r\nstruct net_device *dev;\r\ndev = __dev_get_by_index(net, f->ifindex);\r\nif (dev && nla_put_string(skb, TCA_FW_INDEV, dev->name))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\nif (head->mask != 0xFFFFFFFF &&\r\nnla_put_u32(skb, TCA_FW_MASK, head->mask))\r\ngoto nla_put_failure;\r\nif (tcf_exts_dump(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\nif (tcf_exts_dump_stats(skb, &f->exts) < 0)\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic int __init init_fw(void)\r\n{\r\nreturn register_tcf_proto_ops(&cls_fw_ops);\r\n}\r\nstatic void __exit exit_fw(void)\r\n{\r\nunregister_tcf_proto_ops(&cls_fw_ops);\r\n}
