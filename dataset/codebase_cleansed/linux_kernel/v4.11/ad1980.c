static bool ad1980_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase AC97_RESET ... AC97_MASTER_MONO:\r\ncase AC97_PHONE ... AC97_CD:\r\ncase AC97_AUX ... AC97_GENERAL_PURPOSE:\r\ncase AC97_POWERDOWN ... AC97_PCM_LR_ADC_RATE:\r\ncase AC97_SPDIF:\r\ncase AC97_CODEC_CLASS_REV:\r\ncase AC97_PCI_SVID:\r\ncase AC97_AD_CODEC_CFG:\r\ncase AC97_AD_JACK_SPDIF:\r\ncase AC97_AD_SERIAL_CFG:\r\ncase AC97_VENDOR_ID1:\r\ncase AC97_VENDOR_ID2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool ad1980_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase AC97_VENDOR_ID1:\r\ncase AC97_VENDOR_ID2:\r\nreturn false;\r\ndefault:\r\nreturn ad1980_readable_reg(dev, reg);\r\n}\r\n}\r\nstatic int ad1980_reset(struct snd_soc_codec *codec, int try_warm)\r\n{\r\nstruct snd_ac97 *ac97 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int retry_cnt = 0;\r\nint ret;\r\ndo {\r\nret = snd_ac97_reset(ac97, true, AD1980_VENDOR_ID,\r\nAD1980_VENDOR_MASK);\r\nif (ret >= 0)\r\nreturn 0;\r\nsnd_soc_write(codec, AC97_AD_SERIAL_CFG, 0x9900);\r\n} while (retry_cnt++ < 10);\r\ndev_err(codec->dev, "Failed to reset: AC97 link error\n");\r\nreturn -EIO;\r\n}\r\nstatic int ad1980_soc_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_ac97 *ac97;\r\nstruct regmap *regmap;\r\nint ret;\r\nu16 vendor_id2;\r\nu16 ext_status;\r\nac97 = snd_soc_new_ac97_codec(codec, 0, 0);\r\nif (IS_ERR(ac97)) {\r\nret = PTR_ERR(ac97);\r\ndev_err(codec->dev, "Failed to register AC97 codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap = regmap_init_ac97(ac97, &ad1980_regmap_config);\r\nif (IS_ERR(regmap)) {\r\nret = PTR_ERR(regmap);\r\ngoto err_free_ac97;\r\n}\r\nsnd_soc_codec_init_regmap(codec, regmap);\r\nsnd_soc_codec_set_drvdata(codec, ac97);\r\nret = ad1980_reset(codec, 0);\r\nif (ret < 0)\r\ngoto reset_err;\r\nvendor_id2 = snd_soc_read(codec, AC97_VENDOR_ID2);\r\nif (vendor_id2 == 0x5374) {\r\ndev_warn(codec->dev,\r\n"Found AD1981 - only 2/2 IN/OUT Channels supported\n");\r\n}\r\nsnd_soc_write(codec, AC97_MASTER, 0x0000);\r\nsnd_soc_write(codec, AC97_PCM, 0x0000);\r\nsnd_soc_write(codec, AC97_REC_GAIN, 0x0000);\r\nsnd_soc_write(codec, AC97_CENTER_LFE_MASTER, 0x0000);\r\nsnd_soc_write(codec, AC97_SURROUND_MASTER, 0x0000);\r\next_status = snd_soc_read(codec, AC97_EXTENDED_STATUS);\r\nsnd_soc_write(codec, AC97_EXTENDED_STATUS, ext_status&~0x3800);\r\nreturn 0;\r\nreset_err:\r\nsnd_soc_codec_exit_regmap(codec);\r\nerr_free_ac97:\r\nsnd_soc_free_ac97_codec(ac97);\r\nreturn ret;\r\n}\r\nstatic int ad1980_soc_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_ac97 *ac97 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_codec_exit_regmap(codec);\r\nsnd_soc_free_ac97_codec(ac97);\r\nreturn 0;\r\n}\r\nstatic int ad1980_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev,\r\n&soc_codec_dev_ad1980, &ad1980_dai, 1);\r\n}\r\nstatic int ad1980_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
