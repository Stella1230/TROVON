static inline int calculate_message_bytes(u8 status)\r\n{\r\nswitch (status) {\r\ncase 0xf6:\r\ncase 0xf8:\r\ncase 0xfa:\r\ncase 0xfb:\r\ncase 0xfc:\r\ncase 0xfe:\r\ncase 0xff:\r\nreturn 1;\r\ncase 0xf1:\r\ncase 0xf3:\r\nreturn 2;\r\ncase 0xf2:\r\nreturn 3;\r\ncase 0xf0:\r\nreturn 0;\r\ncase 0xf7:\r\nbreak;\r\ncase 0xf4:\r\ncase 0xf5:\r\ncase 0xf9:\r\ncase 0xfd:\r\nbreak;\r\ndefault:\r\nswitch (status & 0xf0) {\r\ncase 0x80:\r\ncase 0x90:\r\ncase 0xa0:\r\ncase 0xb0:\r\ncase 0xe0:\r\nreturn 3;\r\ncase 0xc0:\r\ncase 0xd0:\r\nreturn 2;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int fill_message(struct snd_rawmidi_substream *substream, u8 *buf)\r\n{\r\nstruct snd_tscm *tscm = substream->rmidi->private_data;\r\nunsigned int port = substream->number;\r\nint i, len, consume;\r\nu8 *label, *msg;\r\nu8 status;\r\nlabel = buf;\r\nmsg = buf + 1;\r\nconsume = snd_rawmidi_transmit_peek(substream, msg, 3);\r\nif (consume == 0)\r\nreturn 0;\r\nif (tscm->on_sysex[port]) {\r\nfor (i = 0; i < consume; ++i) {\r\nif (msg[i] == 0xf7) {\r\ntscm->on_sysex[port] = false;\r\nbreak;\r\n}\r\n}\r\nif (!tscm->on_sysex[port]) {\r\nconsume = i + 1;\r\n*label = (port << 4) | 0x07;\r\n} else if (consume == 3) {\r\n*label = (port << 4) | 0x04;\r\n} else {\r\nreturn 0;\r\n}\r\nlen = consume;\r\n} else {\r\nif (msg[0] == 0xf0) {\r\ntscm->on_sysex[port] = true;\r\nreturn 0;\r\n} else {\r\nif ((msg[0] & 0x80) != 0x80)\r\nstatus = tscm->running_status[port];\r\nelse\r\nstatus = msg[0];\r\nlen = calculate_message_bytes(status);\r\nif (len <= 0)\r\nreturn 0;\r\nif ((msg[0] & 0x80) != 0x80) {\r\nif (consume < len - 1)\r\nreturn 0;\r\nconsume = len - 1;\r\nmsg[2] = msg[1];\r\nmsg[1] = msg[0];\r\nmsg[0] = tscm->running_status[port];\r\n} else {\r\nif (consume < len)\r\nreturn 0;\r\nconsume = len;\r\ntscm->running_status[port] = msg[0];\r\n}\r\n}\r\n*label = (port << 4) | (msg[0] >> 4);\r\n}\r\nif (len > 0 && len < 3)\r\nmemset(msg + len, 0, 3 - len);\r\nreturn consume;\r\n}\r\nstatic void handle_midi_tx(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source,\r\nint generation, unsigned long long offset,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct snd_tscm *tscm = callback_data;\r\nu32 *buf = (u32 *)data;\r\nunsigned int messages;\r\nunsigned int i;\r\nunsigned int port;\r\nstruct snd_rawmidi_substream *substream;\r\nu8 *b;\r\nint bytes;\r\nif (offset != tscm->async_handler.offset)\r\ngoto end;\r\nmessages = length / 8;\r\nfor (i = 0; i < messages; i++) {\r\nb = (u8 *)(buf + i * 2);\r\nport = b[0] >> 4;\r\nif (port >= tscm->spec->midi_capture_ports)\r\ngoto end;\r\nbytes = calculate_message_bytes(b[1]);\r\nif (bytes <= 0) {\r\nfor (bytes = 1; bytes < 4; bytes++) {\r\nif (b[bytes] == 0xf7)\r\nbreak;\r\n}\r\nif (bytes == 4)\r\nbytes = 3;\r\n}\r\nsubstream = ACCESS_ONCE(tscm->tx_midi_substreams[port]);\r\nif (substream != NULL)\r\nsnd_rawmidi_receive(substream, b + 1, bytes);\r\n}\r\nend:\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nint snd_tscm_transaction_register(struct snd_tscm *tscm)\r\n{\r\nstatic const struct fw_address_region resp_register_region = {\r\n.start = 0xffffe0000000ull,\r\n.end = 0xffffe000ffffull,\r\n};\r\nunsigned int i;\r\nint err;\r\ntscm->async_handler.length = 8 * 8;\r\ntscm->async_handler.address_callback = handle_midi_tx;\r\ntscm->async_handler.callback_data = tscm;\r\nerr = fw_core_add_address_handler(&tscm->async_handler,\r\n&resp_register_region);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_tscm_transaction_reregister(tscm);\r\nif (err < 0)\r\ngoto error;\r\nfor (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++) {\r\nerr = snd_fw_async_midi_port_init(\r\n&tscm->out_ports[i], tscm->unit,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_RX_QUAD,\r\n4, fill_message);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nreturn err;\r\nerror:\r\nfw_core_remove_address_handler(&tscm->async_handler);\r\ntscm->async_handler.callback_data = NULL;\r\nreturn err;\r\n}\r\nint snd_tscm_transaction_reregister(struct snd_tscm *tscm)\r\n{\r\nstruct fw_device *device = fw_parent_device(tscm->unit);\r\n__be32 reg;\r\nint err;\r\nreg = cpu_to_be32((device->card->node_id << 16) |\r\n(tscm->async_handler.offset >> 32));\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(tscm->async_handler.offset);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x00000001);\r\nerr = snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\r\n&reg, sizeof(reg), 0);\r\nif (err < 0)\r\nreturn err;\r\nreg = cpu_to_be32(0x0001008e);\r\nreturn snd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\r\n&reg, sizeof(reg), 0);\r\n}\r\nvoid snd_tscm_transaction_unregister(struct snd_tscm *tscm)\r\n{\r\n__be32 reg;\r\nunsigned int i;\r\nif (tscm->async_handler.callback_data == NULL)\r\nreturn;\r\nreg = cpu_to_be32(0x0000008e);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_LED_POWER,\r\n&reg, sizeof(reg), 0);\r\nreg = cpu_to_be32(0x00000000);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ON,\r\n&reg, sizeof(reg), 0);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_HI,\r\n&reg, sizeof(reg), 0);\r\nsnd_fw_transaction(tscm->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nTSCM_ADDR_BASE + TSCM_OFFSET_MIDI_TX_ADDR_LO,\r\n&reg, sizeof(reg), 0);\r\nfw_core_remove_address_handler(&tscm->async_handler);\r\ntscm->async_handler.callback_data = NULL;\r\nfor (i = 0; i < TSCM_MIDI_OUT_PORT_MAX; i++)\r\nsnd_fw_async_midi_port_destroy(&tscm->out_ports[i]);\r\n}
