static bool rt286_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0 ... 0xff:\r\ncase RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\r\ncase RT286_GET_HP_SENSE:\r\ncase RT286_GET_MIC1_SENSE:\r\ncase RT286_PROC_COEF:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt286_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0 ... 0xff:\r\ncase RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\r\ncase RT286_GET_HP_SENSE:\r\ncase RT286_GET_MIC1_SENSE:\r\ncase RT286_SET_AUDIO_POWER:\r\ncase RT286_SET_HPO_POWER:\r\ncase RT286_SET_SPK_POWER:\r\ncase RT286_SET_DMIC1_POWER:\r\ncase RT286_SPK_MUX:\r\ncase RT286_HPO_MUX:\r\ncase RT286_ADC0_MUX:\r\ncase RT286_ADC1_MUX:\r\ncase RT286_SET_MIC1:\r\ncase RT286_SET_PIN_HPO:\r\ncase RT286_SET_PIN_SPK:\r\ncase RT286_SET_PIN_DMIC1:\r\ncase RT286_SPK_EAPD:\r\ncase RT286_SET_AMP_GAIN_HPO:\r\ncase RT286_SET_DMIC2_DEFAULT:\r\ncase RT286_DACL_GAIN:\r\ncase RT286_DACR_GAIN:\r\ncase RT286_ADCL_GAIN:\r\ncase RT286_ADCR_GAIN:\r\ncase RT286_MIC_GAIN:\r\ncase RT286_SPOL_GAIN:\r\ncase RT286_SPOR_GAIN:\r\ncase RT286_HPOL_GAIN:\r\ncase RT286_HPOR_GAIN:\r\ncase RT286_F_DAC_SWITCH:\r\ncase RT286_F_RECMIX_SWITCH:\r\ncase RT286_REC_MIC_SWITCH:\r\ncase RT286_REC_I2S_SWITCH:\r\ncase RT286_REC_LINE_SWITCH:\r\ncase RT286_REC_BEEP_SWITCH:\r\ncase RT286_DAC_FORMAT:\r\ncase RT286_ADC_FORMAT:\r\ncase RT286_COEF_INDEX:\r\ncase RT286_PROC_COEF:\r\ncase RT286_SET_AMP_GAIN_ADC_IN1:\r\ncase RT286_SET_AMP_GAIN_ADC_IN2:\r\ncase RT286_SET_POWER(RT286_DAC_OUT1):\r\ncase RT286_SET_POWER(RT286_DAC_OUT2):\r\ncase RT286_SET_POWER(RT286_ADC_IN1):\r\ncase RT286_SET_POWER(RT286_ADC_IN2):\r\ncase RT286_SET_POWER(RT286_DMIC2):\r\ncase RT286_SET_POWER(RT286_MIC1):\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void rt286_index_sync(struct snd_soc_codec *codec)\r\n{\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 0; i < INDEX_CACHE_SIZE; i++) {\r\nsnd_soc_write(codec, rt286->index_cache[i].reg,\r\nrt286->index_cache[i].def);\r\n}\r\n}\r\nstatic int rt286_jack_detect(struct rt286_priv *rt286, bool *hp, bool *mic)\r\n{\r\nstruct snd_soc_dapm_context *dapm;\r\nunsigned int val, buf;\r\n*hp = false;\r\n*mic = false;\r\nif (!rt286->codec)\r\nreturn -EINVAL;\r\ndapm = snd_soc_codec_get_dapm(rt286->codec);\r\nif (rt286->pdata.cbj_en) {\r\nregmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);\r\n*hp = buf & 0x80000000;\r\nif (*hp) {\r\nregmap_update_bits(rt286->regmap,\r\nRT286_DC_GAIN, 0x200, 0x200);\r\nsnd_soc_dapm_force_enable_pin(dapm, "HV");\r\nsnd_soc_dapm_force_enable_pin(dapm, "VREF");\r\nsnd_soc_dapm_force_enable_pin(dapm, "LDO1");\r\nsnd_soc_dapm_sync(dapm);\r\nregmap_write(rt286->regmap, RT286_SET_MIC1, 0x24);\r\nmsleep(50);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_CBJ_CTRL1, 0xfcc0, 0xd400);\r\nmsleep(300);\r\nregmap_read(rt286->regmap, RT286_CBJ_CTRL2, &val);\r\nif (0x0070 == (val & 0x0070)) {\r\n*mic = true;\r\n} else {\r\nregmap_update_bits(rt286->regmap,\r\nRT286_CBJ_CTRL1, 0xfcc0, 0xe400);\r\nmsleep(300);\r\nregmap_read(rt286->regmap,\r\nRT286_CBJ_CTRL2, &val);\r\nif (0x0070 == (val & 0x0070))\r\n*mic = true;\r\nelse\r\n*mic = false;\r\n}\r\nregmap_update_bits(rt286->regmap,\r\nRT286_DC_GAIN, 0x200, 0x0);\r\n} else {\r\n*mic = false;\r\nregmap_write(rt286->regmap, RT286_SET_MIC1, 0x20);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_CBJ_CTRL1, 0x0400, 0x0000);\r\n}\r\n} else {\r\nregmap_read(rt286->regmap, RT286_GET_HP_SENSE, &buf);\r\n*hp = buf & 0x80000000;\r\nregmap_read(rt286->regmap, RT286_GET_MIC1_SENSE, &buf);\r\n*mic = buf & 0x80000000;\r\n}\r\nsnd_soc_dapm_disable_pin(dapm, "HV");\r\nsnd_soc_dapm_disable_pin(dapm, "VREF");\r\nif (!*hp)\r\nsnd_soc_dapm_disable_pin(dapm, "LDO1");\r\nsnd_soc_dapm_sync(dapm);\r\nreturn 0;\r\n}\r\nstatic void rt286_jack_detect_work(struct work_struct *work)\r\n{\r\nstruct rt286_priv *rt286 =\r\ncontainer_of(work, struct rt286_priv, jack_detect_work.work);\r\nint status = 0;\r\nbool hp = false;\r\nbool mic = false;\r\nrt286_jack_detect(rt286, &hp, &mic);\r\nif (hp == true)\r\nstatus |= SND_JACK_HEADPHONE;\r\nif (mic == true)\r\nstatus |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(rt286->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\n}\r\nint rt286_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nrt286->jack = jack;\r\nif (jack) {\r\nif (rt286->jack->status & SND_JACK_HEADPHONE)\r\nsnd_soc_dapm_force_enable_pin(dapm, "LDO1");\r\nregmap_update_bits(rt286->regmap, RT286_IRQ_CTRL, 0x2, 0x2);\r\nsnd_soc_jack_report(rt286->jack, rt286->jack->status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\n} else {\r\nregmap_update_bits(rt286->regmap, RT286_IRQ_CTRL, 0x2, 0x0);\r\nsnd_soc_dapm_disable_pin(dapm, "LDO1");\r\n}\r\nsnd_soc_dapm_sync(dapm);\r\nreturn 0;\r\n}\r\nstatic int is_mclk_mode(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nif (rt286->clk_id == RT286_SCLK_S_MCLK)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int rt286_spk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec,\r\nRT286_SPK_EAPD, RT286_SET_EAPD_HIGH);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_write(codec,\r\nRT286_SPK_EAPD, RT286_SET_EAPD_LOW);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt286_set_dmic1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec, RT286_SET_PIN_DMIC1, 0x20);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_write(codec, RT286_SET_PIN_DMIC1, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt286_ldo2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x08);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, RT286_POWER_CTRL2, 0x38, 0x30);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt286_mic1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec,\r\nRT286_A_BIAS_CTRL3, 0xc000, 0x8000);\r\nsnd_soc_update_bits(codec,\r\nRT286_A_BIAS_CTRL2, 0xc000, 0x8000);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec,\r\nRT286_A_BIAS_CTRL3, 0xc000, 0x0000);\r\nsnd_soc_update_bits(codec,\r\nRT286_A_BIAS_CTRL2, 0xc000, 0x0000);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt286_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = 0;\r\nint d_len_code;\r\nswitch (params_rate(params)) {\r\ncase 44100:\r\nval |= 0x4000;\r\nbreak;\r\ncase 48000:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported sample rate %d\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nswitch (rt286->sys_clk) {\r\ncase 12288000:\r\ncase 24576000:\r\nif (params_rate(params) != 48000) {\r\ndev_err(codec->dev, "Sys_clk is not matched (%d %d)\n",\r\nparams_rate(params), rt286->sys_clk);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 11289600:\r\ncase 22579200:\r\nif (params_rate(params) != 44100) {\r\ndev_err(codec->dev, "Sys_clk is not matched (%d %d)\n",\r\nparams_rate(params), rt286->sys_clk);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (params_channels(params) <= 16) {\r\nval |= (params_channels(params) - 1);\r\n} else {\r\ndev_err(codec->dev, "Unsupported channels %d\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nd_len_code = 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nd_len_code = 0;\r\nval |= (0x1 << 4);\r\nbreak;\r\ncase 32:\r\nd_len_code = 2;\r\nval |= (0x4 << 4);\r\nbreak;\r\ncase 20:\r\nd_len_code = 1;\r\nval |= (0x2 << 4);\r\nbreak;\r\ncase 24:\r\nd_len_code = 2;\r\nval |= (0x3 << 4);\r\nbreak;\r\ncase 8:\r\nd_len_code = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x0018, d_len_code << 3);\r\ndev_dbg(codec->dev, "format val = 0x%x\n", val);\r\nsnd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x407f, val);\r\nsnd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x407f, val);\r\nreturn 0;\r\n}\r\nstatic int rt286_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x800, 0x800);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x800, 0x0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x300, 0x0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x300, 0x1 << 8);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x300, 0x2 << 8);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x300, 0x3 << 8);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT286_DAC_FORMAT, 0x8000, 0);\r\nsnd_soc_update_bits(codec, RT286_ADC_FORMAT, 0x8000, 0);\r\nreturn 0;\r\n}\r\nstatic int rt286_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s freq=%d\n", __func__, freq);\r\nif (RT286_SCLK_S_MCLK == clk_id) {\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x0100, 0x0);\r\nsnd_soc_update_bits(codec,\r\nRT286_PLL_CTRL1, 0x20, 0x20);\r\n} else {\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec,\r\nRT286_PLL_CTRL, 0x4, 0x4);\r\nsnd_soc_update_bits(codec,\r\nRT286_PLL_CTRL1, 0x20, 0x0);\r\n}\r\nswitch (freq) {\r\ncase 19200000:\r\nif (RT286_SCLK_S_MCLK == clk_id) {\r\ndev_err(codec->dev, "Should not use MCLK\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x40, 0x40);\r\nbreak;\r\ncase 24000000:\r\nif (RT286_SCLK_S_MCLK == clk_id) {\r\ndev_err(codec->dev, "Should not use MCLK\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x40, 0x0);\r\nbreak;\r\ncase 12288000:\r\ncase 11289600:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x8, 0x0);\r\nsnd_soc_update_bits(codec,\r\nRT286_CLK_DIV, 0xfc1e, 0x0004);\r\nbreak;\r\ncase 24576000:\r\ncase 22579200:\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL2, 0x8, 0x8);\r\nsnd_soc_update_bits(codec,\r\nRT286_CLK_DIV, 0xfc1e, 0x5406);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported system clock\n");\r\nreturn -EINVAL;\r\n}\r\nrt286->sys_clk = freq;\r\nrt286->clk_id = clk_id;\r\nreturn 0;\r\n}\r\nstatic int rt286_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\ndev_dbg(codec->dev, "%s ratio=%d\n", __func__, ratio);\r\nif (50 == ratio)\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x1000, 0x1000);\r\nelse\r\nsnd_soc_update_bits(codec,\r\nRT286_I2S_CTRL1, 0x1000, 0x0);\r\nreturn 0;\r\n}\r\nstatic int rt286_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (SND_SOC_BIAS_STANDBY == snd_soc_codec_get_bias_level(codec)) {\r\nsnd_soc_write(codec,\r\nRT286_SET_AUDIO_POWER, AC_PWRST_D0);\r\nsnd_soc_update_bits(codec,\r\nRT286_DC_GAIN, 0x200, 0x200);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_ON:\r\nmdelay(10);\r\nsnd_soc_update_bits(codec,\r\nRT286_DC_GAIN, 0x200, 0x0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec,\r\nRT286_SET_AUDIO_POWER, AC_PWRST_D3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rt286_irq(int irq, void *data)\r\n{\r\nstruct rt286_priv *rt286 = data;\r\nbool hp = false;\r\nbool mic = false;\r\nint status = 0;\r\nrt286_jack_detect(rt286, &hp, &mic);\r\nregmap_update_bits(rt286->regmap, RT286_IRQ_CTRL, 0x1, 0x1);\r\nif (hp == true)\r\nstatus |= SND_JACK_HEADPHONE;\r\nif (mic == true)\r\nstatus |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(rt286->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\npm_wakeup_event(&rt286->i2c->dev, 300);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rt286_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nrt286->codec = codec;\r\nif (rt286->i2c->irq) {\r\nregmap_update_bits(rt286->regmap,\r\nRT286_IRQ_CTRL, 0x2, 0x2);\r\nINIT_DELAYED_WORK(&rt286->jack_detect_work,\r\nrt286_jack_detect_work);\r\nschedule_delayed_work(&rt286->jack_detect_work,\r\nmsecs_to_jiffies(1250));\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt286_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\ncancel_delayed_work_sync(&rt286->jack_detect_work);\r\nreturn 0;\r\n}\r\nstatic int rt286_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt286->regmap, true);\r\nregcache_mark_dirty(rt286->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt286_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct rt286_priv *rt286 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt286->regmap, false);\r\nrt286_index_sync(codec);\r\nregcache_sync(rt286->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt286_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt286_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct rt286_priv *rt286;\r\nint i, ret, val;\r\nrt286 = devm_kzalloc(&i2c->dev, sizeof(*rt286),\r\nGFP_KERNEL);\r\nif (NULL == rt286)\r\nreturn -ENOMEM;\r\nrt286->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt286_regmap);\r\nif (IS_ERR(rt286->regmap)) {\r\nret = PTR_ERR(rt286->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_read(rt286->regmap,\r\nRT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &val);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "I2C error %d\n", ret);\r\nreturn ret;\r\n}\r\nif (val != RT286_VENDOR_ID && val != RT288_VENDOR_ID) {\r\ndev_err(&i2c->dev,\r\n"Device with ID register %#x is not rt286\n", val);\r\nreturn -ENODEV;\r\n}\r\nrt286->index_cache = devm_kmemdup(&i2c->dev, rt286_index_def,\r\nsizeof(rt286_index_def), GFP_KERNEL);\r\nif (!rt286->index_cache)\r\nreturn -ENOMEM;\r\nrt286->index_cache_size = INDEX_CACHE_SIZE;\r\nrt286->i2c = i2c;\r\ni2c_set_clientdata(i2c, rt286);\r\nfor (i = 0; i < INDEX_CACHE_SIZE; i++)\r\nregmap_write(rt286->regmap, rt286->index_cache[i].reg,\r\nrt286->index_cache[i].def);\r\nfor (i = 0; i < ARRAY_SIZE(rt286_reg); i++)\r\nregmap_write(rt286->regmap, rt286_reg[i].reg,\r\nrt286_reg[i].def);\r\nif (pdata)\r\nrt286->pdata = *pdata;\r\nif (dmi_check_system(force_combo_jack_table) ||\r\ndmi_check_system(dmi_dell_dino))\r\nrt286->pdata.cbj_en = true;\r\nregmap_write(rt286->regmap, RT286_SET_AUDIO_POWER, AC_PWRST_D3);\r\nfor (i = 0; i < RT286_POWER_REG_LEN; i++)\r\nregmap_write(rt286->regmap,\r\nRT286_SET_POWER(rt286_support_power_controls[i]),\r\nAC_PWRST_D1);\r\nif (!rt286->pdata.cbj_en) {\r\nregmap_write(rt286->regmap, RT286_CBJ_CTRL2, 0x0000);\r\nregmap_write(rt286->regmap, RT286_MIC1_DET_CTRL, 0x0816);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_CBJ_CTRL1, 0xf000, 0xb000);\r\n} else {\r\nregmap_update_bits(rt286->regmap,\r\nRT286_CBJ_CTRL1, 0xf000, 0x5000);\r\n}\r\nmdelay(10);\r\nif (!rt286->pdata.gpio2_en)\r\nregmap_write(rt286->regmap, RT286_SET_DMIC2_DEFAULT, 0x4000);\r\nelse\r\nregmap_write(rt286->regmap, RT286_SET_DMIC2_DEFAULT, 0);\r\nmdelay(10);\r\nregmap_write(rt286->regmap, RT286_MISC_CTRL1, 0x0000);\r\nregmap_update_bits(rt286->regmap, RT286_POWER_CTRL2, 0xc, 0x0);\r\nregmap_update_bits(rt286->regmap, RT286_POWER_CTRL1, 0x1001, 0x1001);\r\nregmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL2, 0x403a, 0x401a);\r\nregmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL3, 0xf777, 0x4737);\r\nregmap_update_bits(rt286->regmap, RT286_DEPOP_CTRL4, 0x00ff, 0x003f);\r\nif (dmi_check_system(dmi_dell_dino)) {\r\nregmap_update_bits(rt286->regmap,\r\nRT286_SET_GPIO_MASK, 0x40, 0x40);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_SET_GPIO_DIRECTION, 0x40, 0x40);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_SET_GPIO_DATA, 0x40, 0x40);\r\nregmap_update_bits(rt286->regmap,\r\nRT286_GPIO_CTRL, 0xc, 0x8);\r\n}\r\nif (rt286->i2c->irq) {\r\nret = request_threaded_irq(rt286->i2c->irq, NULL, rt286_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT, "rt286", rt286);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev,\r\n"Failed to reguest IRQ: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt286,\r\nrt286_dai, ARRAY_SIZE(rt286_dai));\r\nreturn ret;\r\n}\r\nstatic int rt286_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct rt286_priv *rt286 = i2c_get_clientdata(i2c);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, rt286);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
