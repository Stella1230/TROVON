static bool find_by_address(u64 base_address)\r\n{\r\nstruct device_node *dn = of_find_all_nodes(NULL);\r\nstruct resource res;\r\nwhile (dn) {\r\nif (!of_address_to_resource(dn, 0, &res)) {\r\nif (res.start == base_address) {\r\nof_node_put(dn);\r\nreturn true;\r\n}\r\n}\r\ndn = of_find_all_nodes(dn);\r\n}\r\nreturn false;\r\n}\r\nbool __init board_staging_dt_node_available(const struct resource *resource,\r\nunsigned int num_resources)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_resources; i++) {\r\nconst struct resource *r = resource + i;\r\nif (resource_type(r) == IORESOURCE_MEM)\r\nif (find_by_address(r->start))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint __init board_staging_gic_setup_xlate(const char *gic_match,\r\nunsigned int base)\r\n{\r\nWARN_ON(irqc_node);\r\nirqc_node = of_find_compatible_node(NULL, NULL, gic_match);\r\nWARN_ON(!irqc_node);\r\nif (!irqc_node)\r\nreturn -ENOENT;\r\nirqc_base = base;\r\nreturn 0;\r\n}\r\nstatic void __init gic_fixup_resource(struct resource *res)\r\n{\r\nstruct of_phandle_args irq_data;\r\nunsigned int hwirq = res->start;\r\nunsigned int virq;\r\nif (resource_type(res) != IORESOURCE_IRQ || !irqc_node)\r\nreturn;\r\nirq_data.np = irqc_node;\r\nirq_data.args_count = 3;\r\nirq_data.args[0] = 0;\r\nirq_data.args[1] = hwirq - irqc_base;\r\nswitch (res->flags &\r\n(IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE |\r\nIORESOURCE_IRQ_LOWLEVEL | IORESOURCE_IRQ_HIGHLEVEL)) {\r\ncase IORESOURCE_IRQ_LOWEDGE:\r\nirq_data.args[2] = IRQ_TYPE_EDGE_FALLING;\r\nbreak;\r\ncase IORESOURCE_IRQ_HIGHEDGE:\r\nirq_data.args[2] = IRQ_TYPE_EDGE_RISING;\r\nbreak;\r\ncase IORESOURCE_IRQ_LOWLEVEL:\r\nirq_data.args[2] = IRQ_TYPE_LEVEL_LOW;\r\nbreak;\r\ncase IORESOURCE_IRQ_HIGHLEVEL:\r\ndefault:\r\nirq_data.args[2] = IRQ_TYPE_LEVEL_HIGH;\r\nbreak;\r\n}\r\nvirq = irq_create_of_mapping(&irq_data);\r\nif (WARN_ON(!virq))\r\nreturn;\r\npr_debug("hwirq %u -> virq %u\n", hwirq, virq);\r\nres->start = virq;\r\n}\r\nvoid __init board_staging_gic_fixup_resources(struct resource *res,\r\nunsigned int nres)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nres; i++)\r\ngic_fixup_resource(&res[i]);\r\n}\r\nint __init board_staging_register_clock(const struct board_staging_clk *bsc)\r\n{\r\nint error;\r\npr_debug("Aliasing clock %s for con_id %s dev_id %s\n", bsc->clk,\r\nbsc->con_id, bsc->dev_id);\r\nerror = clk_add_alias(bsc->con_id, bsc->dev_id, bsc->clk, NULL);\r\nif (error)\r\npr_err("Failed to alias clock %s (%d)\n", bsc->clk, error);\r\nreturn error;\r\n}\r\nstatic int board_staging_add_dev_domain(struct platform_device *pdev,\r\nconst char *domain)\r\n{\r\nstruct of_phandle_args pd_args;\r\nstruct device_node *np;\r\nnp = of_find_node_by_path(domain);\r\nif (!np) {\r\npr_err("Cannot find domain node %s\n", domain);\r\nreturn -ENOENT;\r\n}\r\npd_args.np = np;\r\npd_args.args_count = 0;\r\nreturn of_genpd_add_device(&pd_args, &pdev->dev);\r\n}\r\nstatic inline int board_staging_add_dev_domain(struct platform_device *pdev,\r\nconst char *domain)\r\n{\r\nreturn 0;\r\n}\r\nint __init board_staging_register_device(const struct board_staging_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nunsigned int i;\r\nint error;\r\npr_debug("Trying to register device %s\n", pdev->name);\r\nif (board_staging_dt_node_available(pdev->resource,\r\npdev->num_resources)) {\r\npr_warn("Skipping %s, already in DT\n", pdev->name);\r\nreturn -EEXIST;\r\n}\r\nboard_staging_gic_fixup_resources(pdev->resource, pdev->num_resources);\r\nfor (i = 0; i < dev->nclocks; i++)\r\nboard_staging_register_clock(&dev->clocks[i]);\r\nif (dev->domain)\r\nboard_staging_add_dev_domain(pdev, dev->domain);\r\nerror = platform_device_register(pdev);\r\nif (error) {\r\npr_err("Failed to register device %s (%d)\n", pdev->name,\r\nerror);\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nvoid __init board_staging_register_devices(const struct board_staging_dev *devs,\r\nunsigned int ndevs)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ndevs; i++)\r\nboard_staging_register_device(&devs[i]);\r\n}
