static inline void vsp1_uds_write(struct vsp1_uds *uds, struct vsp1_dl_list *dl,\r\nu32 reg, u32 data)\r\n{\r\nvsp1_dl_list_write(dl, reg + uds->entity.index * VI6_UDS_OFFSET, data);\r\n}\r\nvoid vsp1_uds_set_alpha(struct vsp1_entity *entity, struct vsp1_dl_list *dl,\r\nunsigned int alpha)\r\n{\r\nstruct vsp1_uds *uds = to_uds(&entity->subdev);\r\nvsp1_uds_write(uds, dl, VI6_UDS_ALPVAL,\r\nalpha << VI6_UDS_ALPVAL_VAL0_SHIFT);\r\n}\r\nstatic unsigned int uds_output_size(unsigned int input, unsigned int ratio)\r\n{\r\nif (ratio > 4096) {\r\nunsigned int mp;\r\nmp = ratio / 4096;\r\nmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\r\nreturn (input - 1) / mp * mp * 4096 / ratio + 1;\r\n} else {\r\nreturn (input - 1) * 4096 / ratio + 1;\r\n}\r\n}\r\nstatic void uds_output_limits(unsigned int input,\r\nunsigned int *minimum, unsigned int *maximum)\r\n{\r\n*minimum = max(uds_output_size(input, UDS_MAX_FACTOR), UDS_MIN_SIZE);\r\n*maximum = min(uds_output_size(input, UDS_MIN_FACTOR), UDS_MAX_SIZE);\r\n}\r\nstatic unsigned int uds_passband_width(unsigned int ratio)\r\n{\r\nif (ratio >= 4096) {\r\nunsigned int mp;\r\nmp = ratio / 4096;\r\nmp = mp < 4 ? 1 : (mp < 8 ? 2 : 4);\r\nreturn 64 * 4096 * mp / ratio;\r\n} else {\r\nreturn 64;\r\n}\r\n}\r\nstatic unsigned int uds_compute_ratio(unsigned int input, unsigned int output)\r\n{\r\nreturn (input - 1) * 4096 / (output - 1);\r\n}\r\nstatic int uds_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstatic const unsigned int codes[] = {\r\nMEDIA_BUS_FMT_ARGB8888_1X32,\r\nMEDIA_BUS_FMT_AYUV8_1X32,\r\n};\r\nreturn vsp1_subdev_enum_mbus_code(subdev, cfg, code, codes,\r\nARRAY_SIZE(codes));\r\n}\r\nstatic int uds_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nconfig = vsp1_entity_get_pad_config(&uds->entity, cfg, fse->which);\r\nif (!config)\r\nreturn -EINVAL;\r\nformat = vsp1_entity_get_pad_format(&uds->entity, config,\r\nUDS_PAD_SINK);\r\nmutex_lock(&uds->entity.lock);\r\nif (fse->index || fse->code != format->code) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (fse->pad == UDS_PAD_SINK) {\r\nfse->min_width = UDS_MIN_SIZE;\r\nfse->max_width = UDS_MAX_SIZE;\r\nfse->min_height = UDS_MIN_SIZE;\r\nfse->max_height = UDS_MAX_SIZE;\r\n} else {\r\nuds_output_limits(format->width, &fse->min_width,\r\n&fse->max_width);\r\nuds_output_limits(format->height, &fse->min_height,\r\n&fse->max_height);\r\n}\r\ndone:\r\nmutex_unlock(&uds->entity.lock);\r\nreturn ret;\r\n}\r\nstatic void uds_try_format(struct vsp1_uds *uds,\r\nstruct v4l2_subdev_pad_config *config,\r\nunsigned int pad, struct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned int minimum;\r\nunsigned int maximum;\r\nswitch (pad) {\r\ncase UDS_PAD_SINK:\r\nif (fmt->code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\r\nfmt->code != MEDIA_BUS_FMT_AYUV8_1X32)\r\nfmt->code = MEDIA_BUS_FMT_AYUV8_1X32;\r\nfmt->width = clamp(fmt->width, UDS_MIN_SIZE, UDS_MAX_SIZE);\r\nfmt->height = clamp(fmt->height, UDS_MIN_SIZE, UDS_MAX_SIZE);\r\nbreak;\r\ncase UDS_PAD_SOURCE:\r\nformat = vsp1_entity_get_pad_format(&uds->entity, config,\r\nUDS_PAD_SINK);\r\nfmt->code = format->code;\r\nuds_output_limits(format->width, &minimum, &maximum);\r\nfmt->width = clamp(fmt->width, minimum, maximum);\r\nuds_output_limits(format->height, &minimum, &maximum);\r\nfmt->height = clamp(fmt->height, minimum, maximum);\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\n}\r\nstatic int uds_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_uds *uds = to_uds(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nmutex_lock(&uds->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&uds->entity, cfg, fmt->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nuds_try_format(uds, config, fmt->pad, &fmt->format);\r\nformat = vsp1_entity_get_pad_format(&uds->entity, config, fmt->pad);\r\n*format = fmt->format;\r\nif (fmt->pad == UDS_PAD_SINK) {\r\nformat = vsp1_entity_get_pad_format(&uds->entity, config,\r\nUDS_PAD_SOURCE);\r\n*format = fmt->format;\r\nuds_try_format(uds, config, UDS_PAD_SOURCE, format);\r\n}\r\ndone:\r\nmutex_unlock(&uds->entity.lock);\r\nreturn ret;\r\n}\r\nstatic void uds_configure(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl,\r\nenum vsp1_entity_params params)\r\n{\r\nstruct vsp1_uds *uds = to_uds(&entity->subdev);\r\nconst struct v4l2_mbus_framefmt *output;\r\nconst struct v4l2_mbus_framefmt *input;\r\nunsigned int hscale;\r\nunsigned int vscale;\r\nbool multitap;\r\nif (params == VSP1_ENTITY_PARAMS_PARTITION) {\r\nconst struct v4l2_rect *clip = &pipe->partition;\r\nvsp1_uds_write(uds, dl, VI6_UDS_CLIP_SIZE,\r\n(clip->width << VI6_UDS_CLIP_SIZE_HSIZE_SHIFT) |\r\n(clip->height << VI6_UDS_CLIP_SIZE_VSIZE_SHIFT));\r\nreturn;\r\n}\r\nif (params != VSP1_ENTITY_PARAMS_INIT)\r\nreturn;\r\ninput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\r\nUDS_PAD_SINK);\r\noutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\r\nUDS_PAD_SOURCE);\r\nhscale = uds_compute_ratio(input->width, output->width);\r\nvscale = uds_compute_ratio(input->height, output->height);\r\ndev_dbg(uds->entity.vsp1->dev, "hscale %u vscale %u\n", hscale, vscale);\r\nif (uds->scale_alpha && (hscale >= 8192 || vscale >= 8192))\r\nmultitap = false;\r\nelse\r\nmultitap = true;\r\nvsp1_uds_write(uds, dl, VI6_UDS_CTRL,\r\n(uds->scale_alpha ? VI6_UDS_CTRL_AON : 0) |\r\n(multitap ? VI6_UDS_CTRL_BC : 0));\r\nvsp1_uds_write(uds, dl, VI6_UDS_PASS_BWIDTH,\r\n(uds_passband_width(hscale)\r\n<< VI6_UDS_PASS_BWIDTH_H_SHIFT) |\r\n(uds_passband_width(vscale)\r\n<< VI6_UDS_PASS_BWIDTH_V_SHIFT));\r\nvsp1_uds_write(uds, dl, VI6_UDS_SCALE,\r\n(hscale << VI6_UDS_SCALE_HFRAC_SHIFT) |\r\n(vscale << VI6_UDS_SCALE_VFRAC_SHIFT));\r\n}\r\nstatic unsigned int uds_max_width(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe)\r\n{\r\nstruct vsp1_uds *uds = to_uds(&entity->subdev);\r\nconst struct v4l2_mbus_framefmt *output;\r\nconst struct v4l2_mbus_framefmt *input;\r\nunsigned int hscale;\r\ninput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\r\nUDS_PAD_SINK);\r\noutput = vsp1_entity_get_pad_format(&uds->entity, uds->entity.config,\r\nUDS_PAD_SOURCE);\r\nhscale = output->width / input->width;\r\nif (hscale <= 2)\r\nreturn 256;\r\nelse if (hscale <= 4)\r\nreturn 512;\r\nelse if (hscale <= 8)\r\nreturn 1024;\r\nelse\r\nreturn 2048;\r\n}\r\nstruct vsp1_uds *vsp1_uds_create(struct vsp1_device *vsp1, unsigned int index)\r\n{\r\nstruct vsp1_uds *uds;\r\nchar name[6];\r\nint ret;\r\nuds = devm_kzalloc(vsp1->dev, sizeof(*uds), GFP_KERNEL);\r\nif (uds == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nuds->entity.ops = &uds_entity_ops;\r\nuds->entity.type = VSP1_ENTITY_UDS;\r\nuds->entity.index = index;\r\nsprintf(name, "uds.%u", index);\r\nret = vsp1_entity_init(vsp1, &uds->entity, name, 2, &uds_ops,\r\nMEDIA_ENT_F_PROC_VIDEO_SCALER);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nreturn uds;\r\n}
