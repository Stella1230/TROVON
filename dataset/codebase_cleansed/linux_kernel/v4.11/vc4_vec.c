static inline struct vc4_vec_encoder *\r\nto_vc4_vec_encoder(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct vc4_vec_encoder, base.base);\r\n}\r\nstatic inline struct vc4_vec_connector *\r\nto_vc4_vec_connector(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct vc4_vec_connector, base);\r\n}\r\nint vc4_vec_debugfs_regs(struct seq_file *m, void *unused)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_vec *vec = vc4->vec;\r\nint i;\r\nif (!vec)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(vec_regs); i++) {\r\nseq_printf(m, "%s (0x%04x): 0x%08x\n",\r\nvec_regs[i].name, vec_regs[i].reg,\r\nVEC_READ(vec_regs[i].reg));\r\n}\r\nreturn 0;\r\n}\r\nstatic void vc4_vec_ntsc_mode_set(struct vc4_vec *vec)\r\n{\r\nVEC_WRITE(VEC_CONFIG0, VEC_CONFIG0_NTSC_STD | VEC_CONFIG0_PDEN);\r\nVEC_WRITE(VEC_CONFIG1, VEC_CONFIG1_C_CVBS_CVBS);\r\n}\r\nstatic void vc4_vec_ntsc_j_mode_set(struct vc4_vec *vec)\r\n{\r\nVEC_WRITE(VEC_CONFIG0, VEC_CONFIG0_NTSC_STD);\r\nVEC_WRITE(VEC_CONFIG1, VEC_CONFIG1_C_CVBS_CVBS);\r\n}\r\nstatic void vc4_vec_pal_mode_set(struct vc4_vec *vec)\r\n{\r\nVEC_WRITE(VEC_CONFIG0, VEC_CONFIG0_PAL_BDGHI_STD);\r\nVEC_WRITE(VEC_CONFIG1, VEC_CONFIG1_C_CVBS_CVBS);\r\n}\r\nstatic void vc4_vec_pal_m_mode_set(struct vc4_vec *vec)\r\n{\r\nVEC_WRITE(VEC_CONFIG0, VEC_CONFIG0_PAL_BDGHI_STD);\r\nVEC_WRITE(VEC_CONFIG1,\r\nVEC_CONFIG1_C_CVBS_CVBS | VEC_CONFIG1_CUSTOM_FREQ);\r\nVEC_WRITE(VEC_FREQ3_2, 0x223b);\r\nVEC_WRITE(VEC_FREQ1_0, 0x61d1);\r\n}\r\nstatic enum drm_connector_status\r\nvc4_vec_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_unknown;\r\n}\r\nstatic void vc4_vec_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int vc4_vec_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_connector_state *state = connector->state;\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(connector->dev,\r\nvc4_vec_tv_modes[state->tv.mode].mode);\r\nif (!mode) {\r\nDRM_ERROR("Failed to create a new display mode\n");\r\nreturn -ENOMEM;\r\n}\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nstatic struct drm_connector *vc4_vec_connector_init(struct drm_device *dev,\r\nstruct vc4_vec *vec)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct vc4_vec_connector *vec_connector;\r\nvec_connector = devm_kzalloc(dev->dev, sizeof(*vec_connector),\r\nGFP_KERNEL);\r\nif (!vec_connector)\r\nreturn ERR_PTR(-ENOMEM);\r\nconnector = &vec_connector->base;\r\nconnector->interlace_allowed = true;\r\nvec_connector->encoder = vec->encoder;\r\nvec_connector->vec = vec;\r\ndrm_connector_init(dev, connector, &vc4_vec_connector_funcs,\r\nDRM_MODE_CONNECTOR_Composite);\r\ndrm_connector_helper_add(connector, &vc4_vec_connector_helper_funcs);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.tv_mode_property,\r\nVC4_VEC_TV_MODE_NTSC);\r\nvec->tv_mode = &vc4_vec_tv_modes[VC4_VEC_TV_MODE_NTSC];\r\ndrm_mode_connector_attach_encoder(connector, vec->encoder);\r\nreturn connector;\r\n}\r\nstatic void vc4_vec_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct vc4_vec_encoder *vc4_vec_encoder = to_vc4_vec_encoder(encoder);\r\nstruct vc4_vec *vec = vc4_vec_encoder->vec;\r\nint ret;\r\nVEC_WRITE(VEC_CFG, 0);\r\nVEC_WRITE(VEC_DAC_MISC,\r\nVEC_DAC_MISC_VCD_PWRDN |\r\nVEC_DAC_MISC_BIAS_PWRDN |\r\nVEC_DAC_MISC_DAC_PWRDN |\r\nVEC_DAC_MISC_LDO_PWRDN);\r\nclk_disable_unprepare(vec->clock);\r\nret = pm_runtime_put(&vec->pdev->dev);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to release power domain: %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nstatic void vc4_vec_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct vc4_vec_encoder *vc4_vec_encoder = to_vc4_vec_encoder(encoder);\r\nstruct vc4_vec *vec = vc4_vec_encoder->vec;\r\nint ret;\r\nret = pm_runtime_get_sync(&vec->pdev->dev);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to retain power domain: %d\n", ret);\r\nreturn;\r\n}\r\nret = clk_set_rate(vec->clock, 108000000);\r\nif (ret) {\r\nDRM_ERROR("Failed to set clock rate: %d\n", ret);\r\nreturn;\r\n}\r\nret = clk_prepare_enable(vec->clock);\r\nif (ret) {\r\nDRM_ERROR("Failed to turn on core clock: %d\n", ret);\r\nreturn;\r\n}\r\nVEC_WRITE(VEC_WSE_RESET, 1);\r\nVEC_WRITE(VEC_SOFT_RESET, 1);\r\nVEC_WRITE(VEC_WSE_CONTROL, 0);\r\nVEC_WRITE(VEC_SCHPH, 0x28);\r\nVEC_WRITE(VEC_CLMP0_START, 0xac);\r\nVEC_WRITE(VEC_CLMP0_END, 0xec);\r\nVEC_WRITE(VEC_CONFIG2,\r\nVEC_CONFIG2_UV_DIG_DIS | VEC_CONFIG2_RGB_DIG_DIS);\r\nVEC_WRITE(VEC_CONFIG3, VEC_CONFIG3_HORIZ_LEN_STD);\r\nVEC_WRITE(VEC_DAC_CONFIG,\r\nVEC_DAC_CONFIG_DAC_CTRL(0xc) |\r\nVEC_DAC_CONFIG_DRIVER_CTRL(0xc) |\r\nVEC_DAC_CONFIG_LDO_BIAS_CTRL(0x46));\r\nVEC_WRITE(VEC_MASK0, 0);\r\nvec->tv_mode->mode_set(vec);\r\nVEC_WRITE(VEC_DAC_MISC,\r\nVEC_DAC_MISC_VID_ACT | VEC_DAC_MISC_DAC_RST_N);\r\nVEC_WRITE(VEC_CFG, VEC_CFG_VEC_EN);\r\n}\r\nstatic bool vc4_vec_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void vc4_vec_encoder_atomic_mode_set(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct vc4_vec_encoder *vc4_vec_encoder = to_vc4_vec_encoder(encoder);\r\nstruct vc4_vec *vec = vc4_vec_encoder->vec;\r\nvec->tv_mode = &vc4_vec_tv_modes[conn_state->tv.mode];\r\n}\r\nstatic int vc4_vec_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nconst struct vc4_vec_tv_mode *vec_mode;\r\nvec_mode = &vc4_vec_tv_modes[conn_state->tv.mode];\r\nif (conn_state->crtc &&\r\n!drm_mode_equal(vec_mode->mode, &crtc_state->adjusted_mode))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vc4_vec_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\nstruct vc4_vec *vec;\r\nstruct vc4_vec_encoder *vc4_vec_encoder;\r\nint ret;\r\nret = drm_mode_create_tv_properties(drm, ARRAY_SIZE(tv_mode_names),\r\ntv_mode_names);\r\nif (ret)\r\nreturn ret;\r\nvec = devm_kzalloc(dev, sizeof(*vec), GFP_KERNEL);\r\nif (!vec)\r\nreturn -ENOMEM;\r\nvc4_vec_encoder = devm_kzalloc(dev, sizeof(*vc4_vec_encoder),\r\nGFP_KERNEL);\r\nif (!vc4_vec_encoder)\r\nreturn -ENOMEM;\r\nvc4_vec_encoder->base.type = VC4_ENCODER_TYPE_VEC;\r\nvc4_vec_encoder->vec = vec;\r\nvec->encoder = &vc4_vec_encoder->base.base;\r\nvec->pdev = pdev;\r\nvec->regs = vc4_ioremap_regs(pdev, 0);\r\nif (IS_ERR(vec->regs))\r\nreturn PTR_ERR(vec->regs);\r\nvec->clock = devm_clk_get(dev, NULL);\r\nif (IS_ERR(vec->clock)) {\r\nret = PTR_ERR(vec->clock);\r\nif (ret != -EPROBE_DEFER)\r\nDRM_ERROR("Failed to get clock: %d\n", ret);\r\nreturn ret;\r\n}\r\npm_runtime_enable(dev);\r\ndrm_encoder_init(drm, vec->encoder, &vc4_vec_encoder_funcs,\r\nDRM_MODE_ENCODER_TVDAC, NULL);\r\ndrm_encoder_helper_add(vec->encoder, &vc4_vec_encoder_helper_funcs);\r\nvec->connector = vc4_vec_connector_init(drm, vec);\r\nif (IS_ERR(vec->connector)) {\r\nret = PTR_ERR(vec->connector);\r\ngoto err_destroy_encoder;\r\n}\r\ndev_set_drvdata(dev, vec);\r\nvc4->vec = vec;\r\nreturn 0;\r\nerr_destroy_encoder:\r\ndrm_encoder_cleanup(vec->encoder);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic void vc4_vec_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\nstruct vc4_vec *vec = dev_get_drvdata(dev);\r\nvc4_vec_connector_destroy(vec->connector);\r\ndrm_encoder_cleanup(vec->encoder);\r\npm_runtime_disable(dev);\r\nvc4->vec = NULL;\r\n}\r\nstatic int vc4_vec_dev_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &vc4_vec_ops);\r\n}\r\nstatic int vc4_vec_dev_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &vc4_vec_ops);\r\nreturn 0;\r\n}
