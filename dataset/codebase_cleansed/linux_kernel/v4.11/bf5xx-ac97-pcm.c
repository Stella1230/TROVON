static void bf5xx_mmap_copy(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nunsigned int chan_mask = ac97_chan_mask[runtime->channels - 1];\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nbf5xx_pcm_to_ac97((struct ac97_frame *)sport->tx_dma_buf +\r\nsport->tx_pos, (__u16 *)runtime->dma_area + sport->tx_pos *\r\nruntime->channels, count, chan_mask);\r\nsport->tx_pos += runtime->period_size;\r\nif (sport->tx_pos >= runtime->buffer_size)\r\nsport->tx_pos %= runtime->buffer_size;\r\nsport->tx_delay_pos = sport->tx_pos;\r\n} else {\r\nbf5xx_ac97_to_pcm((struct ac97_frame *)sport->rx_dma_buf +\r\nsport->rx_pos, (__u16 *)runtime->dma_area + sport->rx_pos *\r\nruntime->channels, count);\r\nsport->rx_pos += runtime->period_size;\r\nif (sport->rx_pos >= runtime->buffer_size)\r\nsport->rx_pos %= runtime->buffer_size;\r\n}\r\n}\r\nstatic void bf5xx_dma_irq(void *data)\r\n{\r\nstruct snd_pcm_substream *pcm = data;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nstruct snd_pcm_runtime *runtime = pcm->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nbf5xx_mmap_copy(pcm, runtime->period_size);\r\nif (pcm->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (sport->once == 0) {\r\nsnd_pcm_period_elapsed(pcm);\r\nbf5xx_mmap_copy(pcm, runtime->period_size);\r\nsport->once = 1;\r\n}\r\n}\r\n#endif\r\nsnd_pcm_period_elapsed(pcm);\r\n}\r\nstatic int bf5xx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nsize_t size = bf5xx_pcm_hardware.buffer_bytes_max\r\n* sizeof(struct ac97_frame) / 4;\r\nsnd_pcm_lib_malloc_pages(substream, size);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsport->once = 0;\r\nif (runtime->dma_area)\r\nmemset(runtime->dma_area, 0, runtime->buffer_size);\r\nmemset(sport->tx_dma_buf, 0, runtime->buffer_size *\r\nsizeof(struct ac97_frame));\r\n} else\r\nmemset(sport->rx_dma_buf, 0, runtime->buffer_size *\r\nsizeof(struct ac97_frame));\r\n#endif\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsport_set_tx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_tx_dma(sport, sport->tx_dma_buf, runtime->periods,\r\nruntime->period_size * sizeof(struct ac97_frame));\r\n} else {\r\nsport_set_rx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_rx_dma(sport, sport->rx_dma_buf, runtime->periods,\r\nruntime->period_size * sizeof(struct ac97_frame));\r\n}\r\n#else\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsport_set_tx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_tx_dma(sport, runtime->dma_area, runtime->periods,\r\nruntime->period_size * sizeof(struct ac97_frame));\r\n} else {\r\nsport_set_rx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_rx_dma(sport, runtime->dma_area, runtime->periods,\r\nruntime->period_size * sizeof(struct ac97_frame));\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nint ret = 0;\r\npr_debug("%s enter\n", __func__);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nbf5xx_mmap_copy(substream, runtime->period_size);\r\nsport->tx_delay_pos = 0;\r\n#endif\r\nsport_tx_start(sport);\r\n} else\r\nsport_rx_start(sport);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nsport->tx_pos = 0;\r\n#endif\r\nsport_tx_stop(sport);\r\n} else {\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nsport->rx_pos = 0;\r\n#endif\r\nsport_rx_stop(sport);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t bf5xx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nunsigned int curr;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncurr = sport->tx_delay_pos;\r\nelse\r\ncurr = sport->rx_pos;\r\n#else\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncurr = sport_curr_offset_tx(sport) / sizeof(struct ac97_frame);\r\nelse\r\ncurr = sport_curr_offset_rx(sport) / sizeof(struct ac97_frame);\r\n#endif\r\nreturn curr;\r\n}\r\nstatic int bf5xx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct sport_device *sport_handle = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret;\r\npr_debug("%s enter\n", __func__);\r\nsnd_soc_set_runtime_hwparams(substream, &bf5xx_pcm_hardware);\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ngoto out;\r\nif (sport_handle != NULL)\r\nruntime->private_data = sport_handle;\r\nelse {\r\npr_err("sport_handle is NULL\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bf5xx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsize_t size = vma->vm_end - vma->vm_start;\r\nvma->vm_start = (unsigned long)runtime->dma_area;\r\nvma->vm_end = vma->vm_start + size;\r\nvma->vm_flags |= VM_SHARED;\r\nreturn 0 ;\r\n}\r\nstatic int bf5xx_pcm_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *buf, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int chan_mask = ac97_chan_mask[runtime->channels - 1];\r\npr_debug("%s copy pos:0x%lx count:0x%lx\n",\r\nsubstream->stream ? "Capture" : "Playback", pos, count);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nbf5xx_pcm_to_ac97((struct ac97_frame *)runtime->dma_area + pos,\r\n(__u16 *)buf, count, chan_mask);\r\nelse\r\nbf5xx_ac97_to_pcm((struct ac97_frame *)runtime->dma_area + pos,\r\n(__u16 *)buf, count);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = pcm->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct sport_device *sport_handle = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = bf5xx_pcm_hardware.buffer_bytes_max\r\n* sizeof(struct ac97_frame) / 4;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_coherent(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area) {\r\npr_err("Failed to allocate dma memory\n");\r\npr_err("Please increase uncached DMA memory region\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf->bytes = size;\r\npr_debug("%s, area:%p, size:0x%08lx\n", __func__,\r\nbuf->area, buf->bytes);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsport_handle->tx_buf = buf->area;\r\nelse\r\nsport_handle->rx_buf = buf->area;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (!sport_handle->tx_dma_buf) {\r\nsport_handle->tx_dma_buf = dma_alloc_coherent(NULL, \\r\nsize, &sport_handle->tx_dma_phy, GFP_KERNEL);\r\nif (!sport_handle->tx_dma_buf) {\r\npr_err("Failed to allocate memory for tx dma buf - Please increase uncached DMA memory region\n");\r\nreturn -ENOMEM;\r\n} else\r\nmemset(sport_handle->tx_dma_buf, 0, size);\r\n} else\r\nmemset(sport_handle->tx_dma_buf, 0, size);\r\n} else {\r\nif (!sport_handle->rx_dma_buf) {\r\nsport_handle->rx_dma_buf = dma_alloc_coherent(NULL, \\r\nsize, &sport_handle->rx_dma_phy, GFP_KERNEL);\r\nif (!sport_handle->rx_dma_buf) {\r\npr_err("Failed to allocate memory for rx dma buf - Please increase uncached DMA memory region\n");\r\nreturn -ENOMEM;\r\n} else\r\nmemset(sport_handle->rx_dma_buf, 0, size);\r\n} else\r\nmemset(sport_handle->rx_dma_buf, 0, size);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void bf5xx_pcm_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nstruct snd_soc_pcm_runtime *rtd = pcm->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct sport_device *sport_handle = snd_soc_dai_get_drvdata(cpu_dai);\r\nsize_t size = bf5xx_pcm_hardware.buffer_bytes_max *\r\nsizeof(struct ac97_frame) / 4;\r\n#endif\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_coherent(NULL, buf->bytes, buf->area, 0);\r\nbuf->area = NULL;\r\n#if defined(CONFIG_SND_BF5XX_MMAP_SUPPORT)\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (sport_handle->tx_dma_buf)\r\ndma_free_coherent(NULL, size, \\r\nsport_handle->tx_dma_buf, 0);\r\nsport_handle->tx_dma_buf = NULL;\r\n} else {\r\nif (sport_handle->rx_dma_buf)\r\ndma_free_coherent(NULL, size, \\r\nsport_handle->rx_dma_buf, 0);\r\nsport_handle->rx_dma_buf = NULL;\r\n}\r\n#endif\r\n}\r\n}\r\nstatic int bf5xx_pcm_ac97_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret;\r\npr_debug("%s enter\n", __func__);\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = bf5xx_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = bf5xx_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bf5xx_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn devm_snd_soc_register_platform(&pdev->dev,\r\n&bf5xx_ac97_soc_platform);\r\n}
