struct rpc_cred *rpc_lookup_cred(void)\r\n{\r\nreturn rpcauth_lookupcred(&generic_auth, 0);\r\n}\r\nstruct rpc_cred *\r\nrpc_lookup_generic_cred(struct auth_cred *acred, int flags, gfp_t gfp)\r\n{\r\nreturn rpcauth_lookup_credcache(&generic_auth, acred, flags, gfp);\r\n}\r\nstruct rpc_cred *rpc_lookup_cred_nonblock(void)\r\n{\r\nreturn rpcauth_lookupcred(&generic_auth, RPCAUTH_LOOKUP_RCU);\r\n}\r\nstruct rpc_cred *rpc_lookup_machine_cred(const char *service_name)\r\n{\r\nstruct auth_cred acred = {\r\n.uid = RPC_MACHINE_CRED_USERID,\r\n.gid = RPC_MACHINE_CRED_GROUPID,\r\n.principal = service_name,\r\n.machine_cred = 1,\r\n};\r\ndprintk("RPC: looking up machine cred for service %s\n",\r\nservice_name);\r\nreturn generic_auth.au_ops->lookup_cred(&generic_auth, &acred, 0);\r\n}\r\nstatic struct rpc_cred *generic_bind_cred(struct rpc_task *task,\r\nstruct rpc_cred *cred, int lookupflags)\r\n{\r\nstruct rpc_auth *auth = task->tk_client->cl_auth;\r\nstruct auth_cred *acred = &container_of(cred, struct generic_cred, gc_base)->acred;\r\nreturn auth->au_ops->lookup_cred(auth, acred, lookupflags);\r\n}\r\nstatic int\r\ngeneric_hash_cred(struct auth_cred *acred, unsigned int hashbits)\r\n{\r\nreturn hash_64(from_kgid(&init_user_ns, acred->gid) |\r\n((u64)from_kuid(&init_user_ns, acred->uid) <<\r\n(sizeof(gid_t) * 8)), hashbits);\r\n}\r\nstatic struct rpc_cred *\r\ngeneric_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nreturn rpcauth_lookup_credcache(&generic_auth, acred, flags, GFP_KERNEL);\r\n}\r\nstatic struct rpc_cred *\r\ngeneric_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags, gfp_t gfp)\r\n{\r\nstruct generic_cred *gcred;\r\ngcred = kmalloc(sizeof(*gcred), gfp);\r\nif (gcred == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nrpcauth_init_cred(&gcred->gc_base, acred, &generic_auth, &generic_credops);\r\ngcred->gc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\r\ngcred->acred.uid = acred->uid;\r\ngcred->acred.gid = acred->gid;\r\ngcred->acred.group_info = acred->group_info;\r\ngcred->acred.ac_flags = 0;\r\nif (gcred->acred.group_info != NULL)\r\nget_group_info(gcred->acred.group_info);\r\ngcred->acred.machine_cred = acred->machine_cred;\r\ngcred->acred.principal = acred->principal;\r\ndprintk("RPC: allocated %s cred %p for uid %d gid %d\n",\r\ngcred->acred.machine_cred ? "machine" : "generic",\r\ngcred,\r\nfrom_kuid(&init_user_ns, acred->uid),\r\nfrom_kgid(&init_user_ns, acred->gid));\r\nreturn &gcred->gc_base;\r\n}\r\nstatic void\r\ngeneric_free_cred(struct rpc_cred *cred)\r\n{\r\nstruct generic_cred *gcred = container_of(cred, struct generic_cred, gc_base);\r\ndprintk("RPC: generic_free_cred %p\n", gcred);\r\nif (gcred->acred.group_info != NULL)\r\nput_group_info(gcred->acred.group_info);\r\nkfree(gcred);\r\n}\r\nstatic void\r\ngeneric_free_cred_callback(struct rcu_head *head)\r\n{\r\nstruct rpc_cred *cred = container_of(head, struct rpc_cred, cr_rcu);\r\ngeneric_free_cred(cred);\r\n}\r\nstatic void\r\ngeneric_destroy_cred(struct rpc_cred *cred)\r\n{\r\ncall_rcu(&cred->cr_rcu, generic_free_cred_callback);\r\n}\r\nstatic int\r\nmachine_cred_match(struct auth_cred *acred, struct generic_cred *gcred, int flags)\r\n{\r\nif (!gcred->acred.machine_cred ||\r\ngcred->acred.principal != acred->principal ||\r\n!uid_eq(gcred->acred.uid, acred->uid) ||\r\n!gid_eq(gcred->acred.gid, acred->gid))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\ngeneric_match(struct auth_cred *acred, struct rpc_cred *cred, int flags)\r\n{\r\nstruct generic_cred *gcred = container_of(cred, struct generic_cred, gc_base);\r\nint i;\r\nif (acred->machine_cred)\r\nreturn machine_cred_match(acred, gcred, flags);\r\nif (!uid_eq(gcred->acred.uid, acred->uid) ||\r\n!gid_eq(gcred->acred.gid, acred->gid) ||\r\ngcred->acred.machine_cred != 0)\r\ngoto out_nomatch;\r\nif (gcred->acred.group_info == acred->group_info)\r\ngoto out_match;\r\nif (gcred->acred.group_info->ngroups != acred->group_info->ngroups)\r\ngoto out_nomatch;\r\nfor (i = 0; i < gcred->acred.group_info->ngroups; i++) {\r\nif (!gid_eq(gcred->acred.group_info->gid[i],\r\nacred->group_info->gid[i]))\r\ngoto out_nomatch;\r\n}\r\nout_match:\r\nreturn 1;\r\nout_nomatch:\r\nreturn 0;\r\n}\r\nint __init rpc_init_generic_auth(void)\r\n{\r\nreturn rpcauth_init_credcache(&generic_auth);\r\n}\r\nvoid rpc_destroy_generic_auth(void)\r\n{\r\nrpcauth_destroy_credcache(&generic_auth);\r\n}\r\nstatic int\r\ngeneric_key_timeout(struct rpc_auth *auth, struct rpc_cred *cred)\r\n{\r\nstruct auth_cred *acred = &container_of(cred, struct generic_cred,\r\ngc_base)->acred;\r\nstruct rpc_cred *tcred;\r\nint ret = 0;\r\nif (auth->au_flags & RPCAUTH_AUTH_NO_CRKEY_TIMEOUT)\r\nreturn 0;\r\nif (test_bit(RPC_CRED_NOTIFY_TIMEOUT, &acred->ac_flags))\r\nreturn 0;\r\ntcred = auth->au_ops->lookup_cred(auth, acred, 0);\r\nif (IS_ERR(tcred))\r\nreturn -EACCES;\r\nret = tcred->cr_ops->crkey_timeout(tcred);\r\nif (ret != 0) {\r\nset_bit(RPC_CRED_KEY_EXPIRE_SOON, &acred->ac_flags);\r\nret = 0;\r\n} else {\r\nif (test_and_clear_bit(RPC_CRED_KEY_EXPIRE_SOON,\r\n&acred->ac_flags))\r\ndprintk("RPC: UID %d Credential key reset\n",\r\nfrom_kuid(&init_user_ns, tcred->cr_uid));\r\nset_bit(RPC_CRED_NOTIFY_TIMEOUT, &acred->ac_flags);\r\n}\r\nput_rpccred(tcred);\r\nreturn ret;\r\n}\r\nstatic bool generic_key_to_expire(struct rpc_cred *cred)\r\n{\r\nstruct auth_cred *acred = &container_of(cred, struct generic_cred,\r\ngc_base)->acred;\r\nbool ret;\r\nget_rpccred(cred);\r\nret = test_bit(RPC_CRED_KEY_EXPIRE_SOON, &acred->ac_flags);\r\nput_rpccred(cred);\r\nreturn ret;\r\n}
