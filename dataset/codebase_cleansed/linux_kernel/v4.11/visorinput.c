static int visorinput_open(struct input_dev *visorinput_dev)\r\n{\r\nstruct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);\r\nif (!devdata) {\r\ndev_err(&visorinput_dev->dev,\r\n"%s input_get_drvdata(%p) returned NULL\n",\r\n__func__, visorinput_dev);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&visorinput_dev->dev, "%s opened\n", __func__);\r\nmutex_lock(&devdata->lock_visor_dev);\r\ndevdata->interrupts_enabled = true;\r\nif (devdata->paused)\r\ngoto out_unlock;\r\nvisorbus_enable_channel_interrupts(devdata->dev);\r\nout_unlock:\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nreturn 0;\r\n}\r\nstatic void visorinput_close(struct input_dev *visorinput_dev)\r\n{\r\nstruct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);\r\nif (!devdata) {\r\ndev_err(&visorinput_dev->dev,\r\n"%s input_get_drvdata(%p) returned NULL\n",\r\n__func__, visorinput_dev);\r\nreturn;\r\n}\r\ndev_dbg(&visorinput_dev->dev, "%s closed\n", __func__);\r\nmutex_lock(&devdata->lock_visor_dev);\r\ndevdata->interrupts_enabled = false;\r\nif (devdata->paused)\r\ngoto out_unlock;\r\nvisorbus_disable_channel_interrupts(devdata->dev);\r\nout_unlock:\r\nmutex_unlock(&devdata->lock_visor_dev);\r\n}\r\nstatic struct input_dev *\r\nsetup_client_keyboard(void *devdata,\r\nunsigned char *keycode_table)\r\n{\r\nint i;\r\nstruct input_dev *visorinput_dev;\r\nvisorinput_dev = input_allocate_device();\r\nif (!visorinput_dev)\r\nreturn NULL;\r\nvisorinput_dev->name = "visor Keyboard";\r\nvisorinput_dev->phys = "visorkbd:input0";\r\nvisorinput_dev->id.bustype = BUS_VIRTUAL;\r\nvisorinput_dev->id.vendor = 0x0001;\r\nvisorinput_dev->id.product = 0x0001;\r\nvisorinput_dev->id.version = 0x0100;\r\nvisorinput_dev->evbit[0] = BIT_MASK(EV_KEY) |\r\nBIT_MASK(EV_REP) |\r\nBIT_MASK(EV_LED);\r\nvisorinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) |\r\nBIT_MASK(LED_SCROLLL) |\r\nBIT_MASK(LED_NUML);\r\nvisorinput_dev->keycode = keycode_table;\r\nvisorinput_dev->keycodesize = 1;\r\nvisorinput_dev->keycodemax = KEYCODE_TABLE_BYTES;\r\nfor (i = 1; i < visorinput_dev->keycodemax; i++)\r\nset_bit(keycode_table[i], visorinput_dev->keybit);\r\nfor (i = 1; i < visorinput_dev->keycodemax; i++)\r\nset_bit(keycode_table[i + KEYCODE_TABLE_BYTES],\r\nvisorinput_dev->keybit);\r\nvisorinput_dev->open = visorinput_open;\r\nvisorinput_dev->close = visorinput_close;\r\ninput_set_drvdata(visorinput_dev, devdata);\r\nreturn visorinput_dev;\r\n}\r\nstatic struct input_dev *\r\nsetup_client_mouse(void *devdata )\r\n{\r\nstruct input_dev *visorinput_dev = NULL;\r\nint xres, yres;\r\nstruct fb_info *fb0;\r\nvisorinput_dev = input_allocate_device();\r\nif (!visorinput_dev)\r\nreturn NULL;\r\nvisorinput_dev->name = "visor Mouse";\r\nvisorinput_dev->phys = "visormou:input0";\r\nvisorinput_dev->id.bustype = BUS_VIRTUAL;\r\nvisorinput_dev->id.vendor = 0x0001;\r\nvisorinput_dev->id.product = 0x0002;\r\nvisorinput_dev->id.version = 0x0100;\r\nvisorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nset_bit(BTN_LEFT, visorinput_dev->keybit);\r\nset_bit(BTN_RIGHT, visorinput_dev->keybit);\r\nset_bit(BTN_MIDDLE, visorinput_dev->keybit);\r\nif (registered_fb[0]) {\r\nfb0 = registered_fb[0];\r\nxres = fb0->var.xres_virtual;\r\nyres = fb0->var.yres_virtual;\r\n} else {\r\nxres = PIXELS_ACROSS_DEFAULT;\r\nyres = PIXELS_DOWN_DEFAULT;\r\n}\r\ninput_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);\r\ninput_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);\r\nvisorinput_dev->open = visorinput_open;\r\nvisorinput_dev->close = visorinput_close;\r\ninput_set_drvdata(visorinput_dev, devdata);\r\ninput_set_capability(visorinput_dev, EV_REL, REL_WHEEL);\r\nreturn visorinput_dev;\r\n}\r\nstatic struct visorinput_devdata *\r\ndevdata_create(struct visor_device *dev, enum visorinput_device_type devtype)\r\n{\r\nstruct visorinput_devdata *devdata = NULL;\r\nunsigned int extra_bytes = 0;\r\nif (devtype == visorinput_keyboard)\r\nextra_bytes = KEYCODE_TABLE_BYTES * 2;\r\ndevdata = kzalloc(sizeof(*devdata) + extra_bytes, GFP_KERNEL);\r\nif (!devdata)\r\nreturn NULL;\r\nmutex_init(&devdata->lock_visor_dev);\r\nmutex_lock(&devdata->lock_visor_dev);\r\ndevdata->dev = dev;\r\ndevdata->paused = true;\r\nswitch (devtype) {\r\ncase visorinput_keyboard:\r\ndevdata->keycode_table_bytes = extra_bytes;\r\nmemcpy(devdata->keycode_table, visorkbd_keycode,\r\nKEYCODE_TABLE_BYTES);\r\nmemcpy(devdata->keycode_table + KEYCODE_TABLE_BYTES,\r\nvisorkbd_ext_keycode, KEYCODE_TABLE_BYTES);\r\ndevdata->visorinput_dev = setup_client_keyboard\r\n(devdata, devdata->keycode_table);\r\nif (!devdata->visorinput_dev)\r\ngoto cleanups_register;\r\nbreak;\r\ncase visorinput_mouse:\r\ndevdata->visorinput_dev = setup_client_mouse(devdata);\r\nif (!devdata->visorinput_dev)\r\ngoto cleanups_register;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_set_drvdata(&dev->device, devdata);\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nif (input_register_device(devdata->visorinput_dev)) {\r\ninput_free_device(devdata->visorinput_dev);\r\ngoto err_kfree_devdata;\r\n}\r\nmutex_lock(&devdata->lock_visor_dev);\r\ndevdata->paused = false;\r\nif (devdata->interrupts_enabled)\r\nvisorbus_enable_channel_interrupts(dev);\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nreturn devdata;\r\ncleanups_register:\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nerr_kfree_devdata:\r\nkfree(devdata);\r\nreturn NULL;\r\n}\r\nstatic int\r\nvisorinput_probe(struct visor_device *dev)\r\n{\r\nuuid_le guid;\r\nenum visorinput_device_type devtype;\r\nguid = visorchannel_get_uuid(dev->visorchannel);\r\nif (uuid_le_cmp(guid, spar_mouse_channel_protocol_uuid) == 0)\r\ndevtype = visorinput_mouse;\r\nelse if (uuid_le_cmp(guid, spar_keyboard_channel_protocol_uuid) == 0)\r\ndevtype = visorinput_keyboard;\r\nelse\r\nreturn -ENODEV;\r\nvisorbus_disable_channel_interrupts(dev);\r\nif (!devdata_create(dev, devtype))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void\r\nunregister_client_input(struct input_dev *visorinput_dev)\r\n{\r\nif (visorinput_dev)\r\ninput_unregister_device(visorinput_dev);\r\n}\r\nstatic void\r\nvisorinput_remove(struct visor_device *dev)\r\n{\r\nstruct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);\r\nif (!devdata)\r\nreturn;\r\nmutex_lock(&devdata->lock_visor_dev);\r\nvisorbus_disable_channel_interrupts(dev);\r\ndev_set_drvdata(&dev->device, NULL);\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nunregister_client_input(devdata->visorinput_dev);\r\nkfree(devdata);\r\n}\r\nstatic void\r\nhandle_locking_key(struct input_dev *visorinput_dev,\r\nint keycode, int desired_state)\r\n{\r\nint led;\r\nswitch (keycode) {\r\ncase KEY_CAPSLOCK:\r\nled = LED_CAPSL;\r\nbreak;\r\ncase KEY_SCROLLLOCK:\r\nled = LED_SCROLLL;\r\nbreak;\r\ncase KEY_NUMLOCK:\r\nled = LED_NUML;\r\nbreak;\r\ndefault:\r\nled = -1;\r\nreturn;\r\n}\r\nif (test_bit(led, visorinput_dev->led) != desired_state) {\r\ninput_report_key(visorinput_dev, keycode, 1);\r\ninput_sync(visorinput_dev);\r\ninput_report_key(visorinput_dev, keycode, 0);\r\ninput_sync(visorinput_dev);\r\n__change_bit(led, visorinput_dev->led);\r\n}\r\n}\r\nstatic int\r\nscancode_to_keycode(int scancode)\r\n{\r\nint keycode;\r\nif (scancode > 0xff)\r\nkeycode = visorkbd_ext_keycode[(scancode >> 8) & 0xff];\r\nelse\r\nkeycode = visorkbd_keycode[scancode];\r\nreturn keycode;\r\n}\r\nstatic int\r\ncalc_button(int x)\r\n{\r\nswitch (x) {\r\ncase 1:\r\nreturn BTN_LEFT;\r\ncase 2:\r\nreturn BTN_MIDDLE;\r\ncase 3:\r\nreturn BTN_RIGHT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void\r\nvisorinput_channel_interrupt(struct visor_device *dev)\r\n{\r\nstruct ultra_inputreport r;\r\nint scancode, keycode;\r\nstruct input_dev *visorinput_dev;\r\nint xmotion, ymotion, button;\r\nint i;\r\nstruct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);\r\nif (!devdata)\r\nreturn;\r\nvisorinput_dev = devdata->visorinput_dev;\r\nwhile (!visorchannel_signalremove(dev->visorchannel, 0, &r)) {\r\nscancode = r.activity.arg1;\r\nkeycode = scancode_to_keycode(scancode);\r\nswitch (r.activity.action) {\r\ncase inputaction_key_down:\r\ninput_report_key(visorinput_dev, keycode, 1);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_key_up:\r\ninput_report_key(visorinput_dev, keycode, 0);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_key_down_up:\r\ninput_report_key(visorinput_dev, keycode, 1);\r\ninput_sync(visorinput_dev);\r\ninput_report_key(visorinput_dev, keycode, 0);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_set_locking_key_state:\r\nhandle_locking_key(visorinput_dev, keycode,\r\nr.activity.arg2);\r\nbreak;\r\ncase inputaction_xy_motion:\r\nxmotion = r.activity.arg1;\r\nymotion = r.activity.arg2;\r\ninput_report_abs(visorinput_dev, ABS_X, xmotion);\r\ninput_report_abs(visorinput_dev, ABS_Y, ymotion);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_mouse_button_down:\r\nbutton = calc_button(r.activity.arg1);\r\nif (button < 0)\r\nbreak;\r\ninput_report_key(visorinput_dev, button, 1);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_mouse_button_up:\r\nbutton = calc_button(r.activity.arg1);\r\nif (button < 0)\r\nbreak;\r\ninput_report_key(visorinput_dev, button, 0);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_mouse_button_click:\r\nbutton = calc_button(r.activity.arg1);\r\nif (button < 0)\r\nbreak;\r\ninput_report_key(visorinput_dev, button, 1);\r\ninput_sync(visorinput_dev);\r\ninput_report_key(visorinput_dev, button, 0);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_mouse_button_dclick:\r\nbutton = calc_button(r.activity.arg1);\r\nif (button < 0)\r\nbreak;\r\nfor (i = 0; i < 2; i++) {\r\ninput_report_key(visorinput_dev, button, 1);\r\ninput_sync(visorinput_dev);\r\ninput_report_key(visorinput_dev, button, 0);\r\ninput_sync(visorinput_dev);\r\n}\r\nbreak;\r\ncase inputaction_wheel_rotate_away:\r\ninput_report_rel(visorinput_dev, REL_WHEEL, 1);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ncase inputaction_wheel_rotate_toward:\r\ninput_report_rel(visorinput_dev, REL_WHEEL, -1);\r\ninput_sync(visorinput_dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int\r\nvisorinput_pause(struct visor_device *dev,\r\nvisorbus_state_complete_func complete_func)\r\n{\r\nint rc;\r\nstruct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);\r\nif (!devdata) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nmutex_lock(&devdata->lock_visor_dev);\r\nif (devdata->paused) {\r\nrc = -EBUSY;\r\ngoto out_locked;\r\n}\r\nif (devdata->interrupts_enabled)\r\nvisorbus_disable_channel_interrupts(dev);\r\ndevdata->paused = true;\r\ncomplete_func(dev, 0);\r\nrc = 0;\r\nout_locked:\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nvisorinput_resume(struct visor_device *dev,\r\nvisorbus_state_complete_func complete_func)\r\n{\r\nint rc;\r\nstruct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);\r\nif (!devdata) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nmutex_lock(&devdata->lock_visor_dev);\r\nif (!devdata->paused) {\r\nrc = -EBUSY;\r\ngoto out_locked;\r\n}\r\ndevdata->paused = false;\r\ncomplete_func(dev, 0);\r\nif (devdata->interrupts_enabled)\r\nvisorbus_enable_channel_interrupts(dev);\r\nrc = 0;\r\nout_locked:\r\nmutex_unlock(&devdata->lock_visor_dev);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nvisorinput_init(void)\r\n{\r\nreturn visorbus_register_visor_driver(&visorinput_driver);\r\n}\r\nstatic void\r\nvisorinput_cleanup(void)\r\n{\r\nvisorbus_unregister_visor_driver(&visorinput_driver);\r\n}
