static int cec_log_addr2idx(const struct cec_adapter *adap, u8 log_addr)\r\n{\r\nint i;\r\nfor (i = 0; i < adap->log_addrs.num_log_addrs; i++)\r\nif (adap->log_addrs.log_addr[i] == log_addr)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic unsigned int cec_log_addr2dev(const struct cec_adapter *adap, u8 log_addr)\r\n{\r\nint i = cec_log_addr2idx(adap, log_addr);\r\nreturn adap->log_addrs.primary_device_type[i < 0 ? 0 : i];\r\n}\r\nvoid cec_queue_event_fh(struct cec_fh *fh,\r\nconst struct cec_event *new_ev, u64 ts)\r\n{\r\nstruct cec_event *ev = &fh->events[new_ev->event - 1];\r\nif (ts == 0)\r\nts = ktime_get_ns();\r\nmutex_lock(&fh->lock);\r\nif (new_ev->event == CEC_EVENT_LOST_MSGS &&\r\nfh->pending_events & (1 << new_ev->event)) {\r\nev->lost_msgs.lost_msgs += new_ev->lost_msgs.lost_msgs;\r\ngoto unlock;\r\n}\r\n*ev = *new_ev;\r\nev->ts = ts;\r\nfh->pending_events |= 1 << new_ev->event;\r\nunlock:\r\nmutex_unlock(&fh->lock);\r\nwake_up_interruptible(&fh->wait);\r\n}\r\nstatic void cec_queue_event(struct cec_adapter *adap,\r\nconst struct cec_event *ev)\r\n{\r\nu64 ts = ktime_get_ns();\r\nstruct cec_fh *fh;\r\nmutex_lock(&adap->devnode.lock);\r\nlist_for_each_entry(fh, &adap->devnode.fhs, list)\r\ncec_queue_event_fh(fh, ev, ts);\r\nmutex_unlock(&adap->devnode.lock);\r\n}\r\nstatic void cec_queue_msg_fh(struct cec_fh *fh, const struct cec_msg *msg)\r\n{\r\nstatic const struct cec_event ev_lost_msg = {\r\n.ts = 0,\r\n.event = CEC_EVENT_LOST_MSGS,\r\n.flags = 0,\r\n{\r\n.lost_msgs.lost_msgs = 1,\r\n},\r\n};\r\nstruct cec_msg_entry *entry;\r\nmutex_lock(&fh->lock);\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\ngoto lost_msgs;\r\nentry->msg = *msg;\r\nlist_add_tail(&entry->list, &fh->msgs);\r\nif (fh->queued_msgs == CEC_MAX_MSG_RX_QUEUE_SZ) {\r\nlist_del(&entry->list);\r\ngoto lost_msgs;\r\n}\r\nfh->queued_msgs++;\r\nmutex_unlock(&fh->lock);\r\nwake_up_interruptible(&fh->wait);\r\nreturn;\r\nlost_msgs:\r\nmutex_unlock(&fh->lock);\r\ncec_queue_event_fh(fh, &ev_lost_msg, 0);\r\n}\r\nstatic void cec_queue_msg_monitor(struct cec_adapter *adap,\r\nconst struct cec_msg *msg,\r\nbool valid_la)\r\n{\r\nstruct cec_fh *fh;\r\nu32 monitor_mode = valid_la ? CEC_MODE_MONITOR :\r\nCEC_MODE_MONITOR_ALL;\r\nmutex_lock(&adap->devnode.lock);\r\nlist_for_each_entry(fh, &adap->devnode.fhs, list) {\r\nif (fh->mode_follower >= monitor_mode)\r\ncec_queue_msg_fh(fh, msg);\r\n}\r\nmutex_unlock(&adap->devnode.lock);\r\n}\r\nstatic void cec_queue_msg_followers(struct cec_adapter *adap,\r\nconst struct cec_msg *msg)\r\n{\r\nstruct cec_fh *fh;\r\nmutex_lock(&adap->devnode.lock);\r\nlist_for_each_entry(fh, &adap->devnode.fhs, list) {\r\nif (fh->mode_follower == CEC_MODE_FOLLOWER)\r\ncec_queue_msg_fh(fh, msg);\r\n}\r\nmutex_unlock(&adap->devnode.lock);\r\n}\r\nstatic void cec_post_state_event(struct cec_adapter *adap)\r\n{\r\nstruct cec_event ev = {\r\n.event = CEC_EVENT_STATE_CHANGE,\r\n};\r\nev.state_change.phys_addr = adap->phys_addr;\r\nev.state_change.log_addr_mask = adap->log_addrs.log_addr_mask;\r\ncec_queue_event(adap, &ev);\r\n}\r\nstatic void cec_data_completed(struct cec_data *data)\r\n{\r\nif (data->fh)\r\nlist_del(&data->xfer_list);\r\nif (data->blocking) {\r\ndata->completed = true;\r\ncomplete(&data->c);\r\n} else {\r\nif (data->fh)\r\ncec_queue_msg_fh(data->fh, &data->msg);\r\nkfree(data);\r\n}\r\n}\r\nstatic void cec_data_cancel(struct cec_data *data)\r\n{\r\nif (data->adap->transmitting == data) {\r\ndata->adap->transmitting = NULL;\r\n} else {\r\nlist_del_init(&data->list);\r\nif (!(data->msg.tx_status & CEC_TX_STATUS_OK))\r\ndata->adap->transmit_queue_sz--;\r\n}\r\ndata->msg.tx_ts = ktime_get_ns();\r\ndata->msg.tx_status |= CEC_TX_STATUS_ERROR |\r\nCEC_TX_STATUS_MAX_RETRIES;\r\ndata->msg.tx_error_cnt++;\r\ndata->attempts = 0;\r\ncec_queue_msg_monitor(data->adap, &data->msg, 1);\r\ncec_data_completed(data);\r\n}\r\nint cec_thread_func(void *_adap)\r\n{\r\nstruct cec_adapter *adap = _adap;\r\nfor (;;) {\r\nunsigned int signal_free_time;\r\nstruct cec_data *data;\r\nbool timeout = false;\r\nu8 attempts;\r\nif (adap->transmitting) {\r\nint err;\r\nerr = wait_event_interruptible_timeout(adap->kthread_waitq,\r\nkthread_should_stop() ||\r\n(!adap->is_configured && !adap->is_configuring) ||\r\n(!adap->transmitting &&\r\n!list_empty(&adap->transmit_queue)),\r\nmsecs_to_jiffies(CEC_XFER_TIMEOUT_MS));\r\ntimeout = err == 0;\r\n} else {\r\nwait_event_interruptible(adap->kthread_waitq,\r\nkthread_should_stop() ||\r\n(!adap->transmitting &&\r\n!list_empty(&adap->transmit_queue)));\r\n}\r\nmutex_lock(&adap->lock);\r\nif ((!adap->is_configured && !adap->is_configuring) ||\r\nkthread_should_stop()) {\r\nwhile (!list_empty(&adap->transmit_queue)) {\r\ndata = list_first_entry(&adap->transmit_queue,\r\nstruct cec_data, list);\r\ncec_data_cancel(data);\r\n}\r\nif (adap->transmitting)\r\ncec_data_cancel(adap->transmitting);\r\nwhile (!list_empty(&adap->wait_queue)) {\r\ndata = list_first_entry(&adap->wait_queue,\r\nstruct cec_data, list);\r\nif (!cancel_delayed_work(&data->work)) {\r\nmutex_unlock(&adap->lock);\r\nflush_scheduled_work();\r\nmutex_lock(&adap->lock);\r\n}\r\ncec_data_cancel(data);\r\n}\r\ngoto unlock;\r\n}\r\nif (adap->transmitting && timeout) {\r\ndprintk(0, "message %*ph timed out!\n",\r\nadap->transmitting->msg.len,\r\nadap->transmitting->msg.msg);\r\ncec_data_cancel(adap->transmitting);\r\ngoto unlock;\r\n}\r\nif (adap->transmitting || list_empty(&adap->transmit_queue))\r\ngoto unlock;\r\ndata = list_first_entry(&adap->transmit_queue,\r\nstruct cec_data, list);\r\nlist_del_init(&data->list);\r\nadap->transmit_queue_sz--;\r\nadap->transmitting = data;\r\nif (data->msg.len == 1 && adap->is_configured)\r\nattempts = 2;\r\nelse\r\nattempts = 4;\r\nif (data->attempts) {\r\nsignal_free_time = CEC_SIGNAL_FREE_TIME_RETRY;\r\n} else if (data->new_initiator) {\r\nsignal_free_time = CEC_SIGNAL_FREE_TIME_NEW_INITIATOR;\r\n} else {\r\nsignal_free_time = CEC_SIGNAL_FREE_TIME_NEXT_XFER;\r\n}\r\nif (data->attempts == 0)\r\ndata->attempts = attempts;\r\nif (adap->ops->adap_transmit(adap, data->attempts,\r\nsignal_free_time, &data->msg))\r\ncec_data_cancel(data);\r\nunlock:\r\nmutex_unlock(&adap->lock);\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid cec_transmit_done(struct cec_adapter *adap, u8 status, u8 arb_lost_cnt,\r\nu8 nack_cnt, u8 low_drive_cnt, u8 error_cnt)\r\n{\r\nstruct cec_data *data;\r\nstruct cec_msg *msg;\r\nu64 ts = ktime_get_ns();\r\ndprintk(2, "cec_transmit_done %02x\n", status);\r\nmutex_lock(&adap->lock);\r\ndata = adap->transmitting;\r\nif (!data) {\r\ndprintk(1, "cec_transmit_done without an ongoing transmit!\n");\r\ngoto unlock;\r\n}\r\nmsg = &data->msg;\r\nWARN_ON(status == 0);\r\nmsg->tx_ts = ts;\r\nmsg->tx_status |= status;\r\nmsg->tx_arb_lost_cnt += arb_lost_cnt;\r\nmsg->tx_nack_cnt += nack_cnt;\r\nmsg->tx_low_drive_cnt += low_drive_cnt;\r\nmsg->tx_error_cnt += error_cnt;\r\nadap->transmitting = NULL;\r\nif (data->attempts > 1 &&\r\n!(status & (CEC_TX_STATUS_MAX_RETRIES | CEC_TX_STATUS_OK))) {\r\ndata->attempts--;\r\nlist_add(&data->list, &adap->transmit_queue);\r\nadap->transmit_queue_sz++;\r\ngoto wake_thread;\r\n}\r\ndata->attempts = 0;\r\nif (!(status & CEC_TX_STATUS_OK))\r\nmsg->tx_status |= CEC_TX_STATUS_MAX_RETRIES;\r\ncec_queue_msg_monitor(adap, msg, 1);\r\nif ((status & CEC_TX_STATUS_OK) && adap->is_configured &&\r\nmsg->timeout) {\r\nlist_add_tail(&data->list, &adap->wait_queue);\r\nschedule_delayed_work(&data->work,\r\nmsecs_to_jiffies(msg->timeout));\r\n} else {\r\ncec_data_completed(data);\r\n}\r\nwake_thread:\r\nwake_up_interruptible(&adap->kthread_waitq);\r\nunlock:\r\nmutex_unlock(&adap->lock);\r\n}\r\nstatic void cec_wait_timeout(struct work_struct *work)\r\n{\r\nstruct cec_data *data = container_of(work, struct cec_data, work.work);\r\nstruct cec_adapter *adap = data->adap;\r\nmutex_lock(&adap->lock);\r\nif (list_empty(&data->list))\r\ngoto unlock;\r\nlist_del_init(&data->list);\r\ndata->msg.rx_ts = ktime_get_ns();\r\ndata->msg.rx_status = CEC_RX_STATUS_TIMEOUT;\r\ncec_data_completed(data);\r\nunlock:\r\nmutex_unlock(&adap->lock);\r\n}\r\nint cec_transmit_msg_fh(struct cec_adapter *adap, struct cec_msg *msg,\r\nstruct cec_fh *fh, bool block)\r\n{\r\nstruct cec_data *data;\r\nu8 last_initiator = 0xff;\r\nunsigned int timeout;\r\nint res = 0;\r\nmsg->rx_ts = 0;\r\nmsg->tx_ts = 0;\r\nmsg->rx_status = 0;\r\nmsg->tx_status = 0;\r\nmsg->tx_arb_lost_cnt = 0;\r\nmsg->tx_nack_cnt = 0;\r\nmsg->tx_low_drive_cnt = 0;\r\nmsg->tx_error_cnt = 0;\r\nmsg->sequence = ++adap->sequence;\r\nif (!msg->sequence)\r\nmsg->sequence = ++adap->sequence;\r\nif (msg->reply && msg->timeout == 0) {\r\nmsg->timeout = 1000;\r\n}\r\nif (msg->timeout)\r\nmsg->flags &= CEC_MSG_FL_REPLY_TO_FOLLOWERS;\r\nelse\r\nmsg->flags = 0;\r\nif (msg->len == 0 || msg->len > CEC_MAX_MSG_SIZE) {\r\ndprintk(1, "cec_transmit_msg: invalid length %d\n", msg->len);\r\nreturn -EINVAL;\r\n}\r\nif (msg->timeout && msg->len == 1) {\r\ndprintk(1, "cec_transmit_msg: can't reply for poll msg\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(msg->msg + msg->len, 0, sizeof(msg->msg) - msg->len);\r\nif (msg->len == 1) {\r\nif (cec_msg_destination(msg) == 0xf) {\r\ndprintk(1, "cec_transmit_msg: invalid poll message\n");\r\nreturn -EINVAL;\r\n}\r\nif (cec_has_log_addr(adap, cec_msg_destination(msg))) {\r\nmsg->tx_ts = ktime_get_ns();\r\nmsg->tx_status = CEC_TX_STATUS_NACK |\r\nCEC_TX_STATUS_MAX_RETRIES;\r\nmsg->tx_nack_cnt = 1;\r\nreturn 0;\r\n}\r\n}\r\nif (msg->len > 1 && !cec_msg_is_broadcast(msg) &&\r\ncec_has_log_addr(adap, cec_msg_destination(msg))) {\r\ndprintk(1, "cec_transmit_msg: destination is the adapter itself\n");\r\nreturn -EINVAL;\r\n}\r\nif (msg->len > 1 && adap->is_configured &&\r\n!cec_has_log_addr(adap, cec_msg_initiator(msg))) {\r\ndprintk(1, "cec_transmit_msg: initiator has unknown logical address %d\n",\r\ncec_msg_initiator(msg));\r\nreturn -EINVAL;\r\n}\r\nif (!adap->is_configured && !adap->is_configuring)\r\nreturn -ENONET;\r\nif (adap->transmit_queue_sz >= CEC_MAX_MSG_TX_QUEUE_SZ)\r\nreturn -EBUSY;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (msg->len > 1 && msg->msg[1] == CEC_MSG_CDC_MESSAGE) {\r\nmsg->msg[2] = adap->phys_addr >> 8;\r\nmsg->msg[3] = adap->phys_addr & 0xff;\r\n}\r\nif (msg->timeout)\r\ndprintk(2, "cec_transmit_msg: %*ph (wait for 0x%02x%s)\n",\r\nmsg->len, msg->msg, msg->reply, !block ? ", nb" : "");\r\nelse\r\ndprintk(2, "cec_transmit_msg: %*ph%s\n",\r\nmsg->len, msg->msg, !block ? " (nb)" : "");\r\ndata->msg = *msg;\r\ndata->fh = fh;\r\ndata->adap = adap;\r\ndata->blocking = block;\r\nif (msg->len > 1) {\r\nif (!(list_empty(&adap->transmit_queue))) {\r\nconst struct cec_data *last;\r\nlast = list_last_entry(&adap->transmit_queue,\r\nconst struct cec_data, list);\r\nlast_initiator = cec_msg_initiator(&last->msg);\r\n} else if (adap->transmitting) {\r\nlast_initiator =\r\ncec_msg_initiator(&adap->transmitting->msg);\r\n}\r\n}\r\ndata->new_initiator = last_initiator != cec_msg_initiator(msg);\r\ninit_completion(&data->c);\r\nINIT_DELAYED_WORK(&data->work, cec_wait_timeout);\r\nif (fh)\r\nlist_add_tail(&data->xfer_list, &fh->xfer_list);\r\nlist_add_tail(&data->list, &adap->transmit_queue);\r\nadap->transmit_queue_sz++;\r\nif (!adap->transmitting)\r\nwake_up_interruptible(&adap->kthread_waitq);\r\nif (!block)\r\nreturn 0;\r\ntimeout = CEC_XFER_TIMEOUT_MS;\r\nif (msg->timeout)\r\ntimeout += msg->timeout;\r\nmutex_unlock(&adap->lock);\r\nres = wait_for_completion_killable_timeout(&data->c,\r\nmsecs_to_jiffies(timeout));\r\nmutex_lock(&adap->lock);\r\nif (data->completed) {\r\n*msg = data->msg;\r\nkfree(data);\r\nreturn 0;\r\n}\r\ndata->blocking = false;\r\nif (data->fh)\r\nlist_del(&data->xfer_list);\r\ndata->fh = NULL;\r\nif (res == 0) {\r\nif (msg->timeout && (msg->tx_status & CEC_TX_STATUS_OK))\r\nmsg->rx_status = CEC_RX_STATUS_TIMEOUT;\r\nelse\r\nmsg->tx_status = CEC_TX_STATUS_MAX_RETRIES;\r\n}\r\nreturn res > 0 ? 0 : res;\r\n}\r\nint cec_transmit_msg(struct cec_adapter *adap, struct cec_msg *msg,\r\nbool block)\r\n{\r\nint ret;\r\nmutex_lock(&adap->lock);\r\nret = cec_transmit_msg_fh(adap, msg, NULL, block);\r\nmutex_unlock(&adap->lock);\r\nreturn ret;\r\n}\r\nvoid cec_received_msg(struct cec_adapter *adap, struct cec_msg *msg)\r\n{\r\nstruct cec_data *data;\r\nu8 msg_init = cec_msg_initiator(msg);\r\nu8 msg_dest = cec_msg_destination(msg);\r\nu8 cmd = msg->msg[1];\r\nbool is_reply = false;\r\nbool valid_la = true;\r\nu8 min_len = 0;\r\nif (WARN_ON(!msg->len || msg->len > CEC_MAX_MSG_SIZE))\r\nreturn;\r\nif (msg_init != CEC_LOG_ADDR_UNREGISTERED &&\r\ncec_has_log_addr(adap, msg_init))\r\nreturn;\r\nmsg->rx_ts = ktime_get_ns();\r\nmsg->rx_status = CEC_RX_STATUS_OK;\r\nmsg->sequence = msg->reply = msg->timeout = 0;\r\nmsg->tx_status = 0;\r\nmsg->tx_ts = 0;\r\nmsg->tx_arb_lost_cnt = 0;\r\nmsg->tx_nack_cnt = 0;\r\nmsg->tx_low_drive_cnt = 0;\r\nmsg->tx_error_cnt = 0;\r\nmsg->flags = 0;\r\nmemset(msg->msg + msg->len, 0, sizeof(msg->msg) - msg->len);\r\nmutex_lock(&adap->lock);\r\ndprintk(2, "cec_received_msg: %*ph\n", msg->len, msg->msg);\r\nif (!cec_msg_is_broadcast(msg))\r\nvalid_la = cec_has_log_addr(adap, msg_dest);\r\nif (valid_la && msg->len > 1 && cec_msg_size[cmd]) {\r\nu8 dir_fl = cec_msg_size[cmd] & BOTH;\r\nmin_len = cec_msg_size[cmd] & 0x1f;\r\nif (msg->len < min_len)\r\nvalid_la = false;\r\nelse if (!cec_msg_is_broadcast(msg) && !(dir_fl & DIRECTED))\r\nvalid_la = false;\r\nelse if (cec_msg_is_broadcast(msg) && !(dir_fl & BCAST1_4))\r\nvalid_la = false;\r\nelse if (cec_msg_is_broadcast(msg) &&\r\nadap->log_addrs.cec_version >= CEC_OP_CEC_VERSION_2_0 &&\r\n!(dir_fl & BCAST2_0))\r\nvalid_la = false;\r\n}\r\nif (valid_la && min_len) {\r\nswitch (cmd) {\r\ncase CEC_MSG_TIMER_STATUS:\r\nif (msg->msg[2] & 0x10) {\r\nswitch (msg->msg[2] & 0xf) {\r\ncase CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE:\r\ncase CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE:\r\nif (msg->len < 5)\r\nvalid_la = false;\r\nbreak;\r\n}\r\n} else if ((msg->msg[2] & 0xf) == CEC_OP_PROG_ERROR_DUPLICATE) {\r\nif (msg->len < 5)\r\nvalid_la = false;\r\n}\r\nbreak;\r\ncase CEC_MSG_RECORD_ON:\r\nswitch (msg->msg[2]) {\r\ncase CEC_OP_RECORD_SRC_OWN:\r\nbreak;\r\ncase CEC_OP_RECORD_SRC_DIGITAL:\r\nif (msg->len < 10)\r\nvalid_la = false;\r\nbreak;\r\ncase CEC_OP_RECORD_SRC_ANALOG:\r\nif (msg->len < 7)\r\nvalid_la = false;\r\nbreak;\r\ncase CEC_OP_RECORD_SRC_EXT_PLUG:\r\nif (msg->len < 4)\r\nvalid_la = false;\r\nbreak;\r\ncase CEC_OP_RECORD_SRC_EXT_PHYS_ADDR:\r\nif (msg->len < 5)\r\nvalid_la = false;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (valid_la && msg->len > 1 && cmd != CEC_MSG_CDC_MESSAGE) {\r\nbool abort = cmd == CEC_MSG_FEATURE_ABORT;\r\nif (abort)\r\ncmd = msg->msg[2];\r\nlist_for_each_entry(data, &adap->wait_queue, list) {\r\nstruct cec_msg *dst = &data->msg;\r\nif (!abort && dst->msg[1] == CEC_MSG_INITIATE_ARC &&\r\n(cmd == CEC_MSG_REPORT_ARC_INITIATED ||\r\ncmd == CEC_MSG_REPORT_ARC_TERMINATED) &&\r\n(dst->reply == CEC_MSG_REPORT_ARC_INITIATED ||\r\ndst->reply == CEC_MSG_REPORT_ARC_TERMINATED))\r\ndst->reply = cmd;\r\nif ((abort && cmd != dst->msg[1]) ||\r\n(!abort && cmd != dst->reply))\r\ncontinue;\r\nif (msg_init != cec_msg_destination(dst) &&\r\n!cec_msg_is_broadcast(dst))\r\ncontinue;\r\nmemcpy(dst->msg, msg->msg, msg->len);\r\ndst->len = msg->len;\r\ndst->rx_ts = msg->rx_ts;\r\ndst->rx_status = msg->rx_status;\r\nif (abort)\r\ndst->rx_status |= CEC_RX_STATUS_FEATURE_ABORT;\r\nmsg->flags = dst->flags;\r\nlist_del_init(&data->list);\r\nif (!cancel_delayed_work(&data->work)) {\r\nmutex_unlock(&adap->lock);\r\nflush_scheduled_work();\r\nmutex_lock(&adap->lock);\r\n}\r\nif (data->fh)\r\nis_reply = true;\r\ncec_data_completed(data);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&adap->lock);\r\ncec_queue_msg_monitor(adap, msg, valid_la);\r\nif (!valid_la || msg->len <= 1)\r\nreturn;\r\nif (adap->log_addrs.log_addr_mask == 0)\r\nreturn;\r\ncec_receive_notify(adap, msg, is_reply);\r\n}\r\nstatic int cec_config_log_addr(struct cec_adapter *adap,\r\nunsigned int idx,\r\nunsigned int log_addr)\r\n{\r\nstruct cec_log_addrs *las = &adap->log_addrs;\r\nstruct cec_msg msg = { };\r\nint err;\r\nif (cec_has_log_addr(adap, log_addr))\r\nreturn 0;\r\nmsg.len = 1;\r\nmsg.msg[0] = (log_addr << 4) | log_addr;\r\nerr = cec_transmit_msg_fh(adap, &msg, NULL, true);\r\nif (!adap->is_configuring)\r\nreturn -EINTR;\r\nif (err)\r\nreturn err;\r\nif (msg.tx_status & CEC_TX_STATUS_OK)\r\nreturn 0;\r\nerr = adap->ops->adap_log_addr(adap, log_addr);\r\nif (err)\r\nreturn err;\r\nlas->log_addr[idx] = log_addr;\r\nlas->log_addr_mask |= 1 << log_addr;\r\nadap->phys_addrs[log_addr] = adap->phys_addr;\r\ndprintk(2, "claimed addr %d (%d)\n", log_addr,\r\nlas->primary_device_type[idx]);\r\nreturn 1;\r\n}\r\nstatic void cec_adap_unconfigure(struct cec_adapter *adap)\r\n{\r\nWARN_ON(adap->ops->adap_log_addr(adap, CEC_LOG_ADDR_INVALID));\r\nadap->log_addrs.log_addr_mask = 0;\r\nadap->is_configuring = false;\r\nadap->is_configured = false;\r\nmemset(adap->phys_addrs, 0xff, sizeof(adap->phys_addrs));\r\nwake_up_interruptible(&adap->kthread_waitq);\r\ncec_post_state_event(adap);\r\n}\r\nstatic int cec_config_thread_func(void *arg)\r\n{\r\nstatic const u8 tv_log_addrs[] = {\r\nCEC_LOG_ADDR_TV, CEC_LOG_ADDR_SPECIFIC,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 record_log_addrs[] = {\r\nCEC_LOG_ADDR_RECORD_1, CEC_LOG_ADDR_RECORD_2,\r\nCEC_LOG_ADDR_RECORD_3,\r\nCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 tuner_log_addrs[] = {\r\nCEC_LOG_ADDR_TUNER_1, CEC_LOG_ADDR_TUNER_2,\r\nCEC_LOG_ADDR_TUNER_3, CEC_LOG_ADDR_TUNER_4,\r\nCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 playback_log_addrs[] = {\r\nCEC_LOG_ADDR_PLAYBACK_1, CEC_LOG_ADDR_PLAYBACK_2,\r\nCEC_LOG_ADDR_PLAYBACK_3,\r\nCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 audiosystem_log_addrs[] = {\r\nCEC_LOG_ADDR_AUDIOSYSTEM,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 specific_use_log_addrs[] = {\r\nCEC_LOG_ADDR_SPECIFIC,\r\nCEC_LOG_ADDR_BACKUP_1, CEC_LOG_ADDR_BACKUP_2,\r\nCEC_LOG_ADDR_INVALID\r\n};\r\nstatic const u8 *type2addrs[6] = {\r\n[CEC_LOG_ADDR_TYPE_TV] = tv_log_addrs,\r\n[CEC_LOG_ADDR_TYPE_RECORD] = record_log_addrs,\r\n[CEC_LOG_ADDR_TYPE_TUNER] = tuner_log_addrs,\r\n[CEC_LOG_ADDR_TYPE_PLAYBACK] = playback_log_addrs,\r\n[CEC_LOG_ADDR_TYPE_AUDIOSYSTEM] = audiosystem_log_addrs,\r\n[CEC_LOG_ADDR_TYPE_SPECIFIC] = specific_use_log_addrs,\r\n};\r\nstatic const u16 type2mask[] = {\r\n[CEC_LOG_ADDR_TYPE_TV] = CEC_LOG_ADDR_MASK_TV,\r\n[CEC_LOG_ADDR_TYPE_RECORD] = CEC_LOG_ADDR_MASK_RECORD,\r\n[CEC_LOG_ADDR_TYPE_TUNER] = CEC_LOG_ADDR_MASK_TUNER,\r\n[CEC_LOG_ADDR_TYPE_PLAYBACK] = CEC_LOG_ADDR_MASK_PLAYBACK,\r\n[CEC_LOG_ADDR_TYPE_AUDIOSYSTEM] = CEC_LOG_ADDR_MASK_AUDIOSYSTEM,\r\n[CEC_LOG_ADDR_TYPE_SPECIFIC] = CEC_LOG_ADDR_MASK_SPECIFIC,\r\n};\r\nstruct cec_adapter *adap = arg;\r\nstruct cec_log_addrs *las = &adap->log_addrs;\r\nint err;\r\nint i, j;\r\nmutex_lock(&adap->lock);\r\ndprintk(1, "physical address: %x.%x.%x.%x, claim %d logical addresses\n",\r\ncec_phys_addr_exp(adap->phys_addr), las->num_log_addrs);\r\nlas->log_addr_mask = 0;\r\nif (las->log_addr_type[0] == CEC_LOG_ADDR_TYPE_UNREGISTERED)\r\ngoto configured;\r\nfor (i = 0; i < las->num_log_addrs; i++) {\r\nunsigned int type = las->log_addr_type[i];\r\nconst u8 *la_list;\r\nu8 last_la;\r\nif (adap->phys_addr && type == CEC_LOG_ADDR_TYPE_TV)\r\ntype = CEC_LOG_ADDR_TYPE_SPECIFIC;\r\nla_list = type2addrs[type];\r\nlast_la = las->log_addr[i];\r\nlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\r\nif (last_la == CEC_LOG_ADDR_INVALID ||\r\nlast_la == CEC_LOG_ADDR_UNREGISTERED ||\r\n!((1 << last_la) & type2mask[type]))\r\nlast_la = la_list[0];\r\nerr = cec_config_log_addr(adap, i, last_la);\r\nif (err > 0)\r\ncontinue;\r\nif (err < 0)\r\ngoto unconfigure;\r\nfor (j = 0; la_list[j] != CEC_LOG_ADDR_INVALID; j++) {\r\nif (la_list[j] == last_la)\r\ncontinue;\r\nif ((la_list[j] == CEC_LOG_ADDR_BACKUP_1 ||\r\nla_list[j] == CEC_LOG_ADDR_BACKUP_2) &&\r\nlas->cec_version < CEC_OP_CEC_VERSION_2_0)\r\ncontinue;\r\nerr = cec_config_log_addr(adap, i, la_list[j]);\r\nif (err == 0)\r\ncontinue;\r\nif (err < 0)\r\ngoto unconfigure;\r\nbreak;\r\n}\r\nif (la_list[j] == CEC_LOG_ADDR_INVALID)\r\ndprintk(1, "could not claim LA %d\n", i);\r\n}\r\nif (adap->log_addrs.log_addr_mask == 0 &&\r\n!(las->flags & CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK))\r\ngoto unconfigure;\r\nconfigured:\r\nif (adap->log_addrs.log_addr_mask == 0) {\r\nlas->log_addr[0] = CEC_LOG_ADDR_UNREGISTERED;\r\nlas->log_addr_mask = 1 << las->log_addr[0];\r\nfor (i = 1; i < las->num_log_addrs; i++)\r\nlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\r\n}\r\nfor (i = las->num_log_addrs; i < CEC_MAX_LOG_ADDRS; i++)\r\nlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\r\nadap->is_configured = true;\r\nadap->is_configuring = false;\r\ncec_post_state_event(adap);\r\nfor (i = 0; i < las->num_log_addrs; i++) {\r\nstruct cec_msg msg = {};\r\nif (las->log_addr[i] == CEC_LOG_ADDR_INVALID ||\r\n(las->flags & CEC_LOG_ADDRS_FL_CDC_ONLY))\r\ncontinue;\r\nmsg.msg[0] = (las->log_addr[i] << 4) | 0x0f;\r\nif (las->log_addr[i] != CEC_LOG_ADDR_UNREGISTERED &&\r\nadap->log_addrs.cec_version >= CEC_OP_CEC_VERSION_2_0) {\r\ncec_fill_msg_report_features(adap, &msg, i);\r\ncec_transmit_msg_fh(adap, &msg, NULL, false);\r\n}\r\ncec_msg_report_physical_addr(&msg, adap->phys_addr,\r\nlas->primary_device_type[i]);\r\ndprintk(2, "config: la %d pa %x.%x.%x.%x\n",\r\nlas->log_addr[i],\r\ncec_phys_addr_exp(adap->phys_addr));\r\ncec_transmit_msg_fh(adap, &msg, NULL, false);\r\n}\r\nadap->kthread_config = NULL;\r\ncomplete(&adap->config_completion);\r\nmutex_unlock(&adap->lock);\r\nreturn 0;\r\nunconfigure:\r\nfor (i = 0; i < las->num_log_addrs; i++)\r\nlas->log_addr[i] = CEC_LOG_ADDR_INVALID;\r\ncec_adap_unconfigure(adap);\r\nadap->kthread_config = NULL;\r\nmutex_unlock(&adap->lock);\r\ncomplete(&adap->config_completion);\r\nreturn 0;\r\n}\r\nstatic void cec_claim_log_addrs(struct cec_adapter *adap, bool block)\r\n{\r\nif (WARN_ON(adap->is_configuring || adap->is_configured))\r\nreturn;\r\ninit_completion(&adap->config_completion);\r\nadap->is_configuring = true;\r\nadap->kthread_config = kthread_run(cec_config_thread_func, adap,\r\n"ceccfg-%s", adap->name);\r\nif (IS_ERR(adap->kthread_config)) {\r\nadap->kthread_config = NULL;\r\n} else if (block) {\r\nmutex_unlock(&adap->lock);\r\nwait_for_completion(&adap->config_completion);\r\nmutex_lock(&adap->lock);\r\n}\r\n}\r\nvoid __cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr, bool block)\r\n{\r\nif (phys_addr == adap->phys_addr || adap->devnode.unregistered)\r\nreturn;\r\nif (phys_addr == CEC_PHYS_ADDR_INVALID ||\r\nadap->phys_addr != CEC_PHYS_ADDR_INVALID) {\r\nadap->phys_addr = CEC_PHYS_ADDR_INVALID;\r\ncec_post_state_event(adap);\r\ncec_adap_unconfigure(adap);\r\nif (adap->monitor_all_cnt)\r\nWARN_ON(call_op(adap, adap_monitor_all_enable, false));\r\nWARN_ON(adap->ops->adap_enable(adap, false));\r\nif (phys_addr == CEC_PHYS_ADDR_INVALID)\r\nreturn;\r\n}\r\nif (adap->ops->adap_enable(adap, true))\r\nreturn;\r\nif (adap->monitor_all_cnt &&\r\ncall_op(adap, adap_monitor_all_enable, true)) {\r\nWARN_ON(adap->ops->adap_enable(adap, false));\r\nreturn;\r\n}\r\nadap->phys_addr = phys_addr;\r\ncec_post_state_event(adap);\r\nif (adap->log_addrs.num_log_addrs)\r\ncec_claim_log_addrs(adap, block);\r\n}\r\nvoid cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr, bool block)\r\n{\r\nif (IS_ERR_OR_NULL(adap))\r\nreturn;\r\nmutex_lock(&adap->lock);\r\n__cec_s_phys_addr(adap, phys_addr, block);\r\nmutex_unlock(&adap->lock);\r\n}\r\nint __cec_s_log_addrs(struct cec_adapter *adap,\r\nstruct cec_log_addrs *log_addrs, bool block)\r\n{\r\nu16 type_mask = 0;\r\nint i;\r\nif (adap->devnode.unregistered)\r\nreturn -ENODEV;\r\nif (!log_addrs || log_addrs->num_log_addrs == 0) {\r\nadap->log_addrs.num_log_addrs = 0;\r\ncec_adap_unconfigure(adap);\r\nreturn 0;\r\n}\r\nif (log_addrs->flags & CEC_LOG_ADDRS_FL_CDC_ONLY) {\r\nlog_addrs->num_log_addrs = 1;\r\nlog_addrs->osd_name[0] = '\0';\r\nlog_addrs->vendor_id = CEC_VENDOR_ID_NONE;\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\r\nlog_addrs->primary_device_type[0] = CEC_OP_PRIM_DEVTYPE_SWITCH;\r\nlog_addrs->all_device_types[0] = 0;\r\nlog_addrs->features[0][0] = 0;\r\nlog_addrs->features[0][1] = 0;\r\n}\r\nlog_addrs->osd_name[sizeof(log_addrs->osd_name) - 1] = '\0';\r\nif (log_addrs->num_log_addrs > adap->available_log_addrs) {\r\ndprintk(1, "num_log_addrs > %d\n", adap->available_log_addrs);\r\nreturn -EINVAL;\r\n}\r\nif (log_addrs->vendor_id != CEC_VENDOR_ID_NONE &&\r\n(log_addrs->vendor_id & 0xff000000) != 0)\r\nreturn -EINVAL;\r\nif (log_addrs->cec_version != CEC_OP_CEC_VERSION_1_4 &&\r\nlog_addrs->cec_version != CEC_OP_CEC_VERSION_2_0)\r\nreturn -EINVAL;\r\nif (log_addrs->num_log_addrs > 1)\r\nfor (i = 0; i < log_addrs->num_log_addrs; i++)\r\nif (log_addrs->log_addr_type[i] ==\r\nCEC_LOG_ADDR_TYPE_UNREGISTERED) {\r\ndprintk(1, "num_log_addrs > 1 can't be combined with unregistered LA\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < log_addrs->num_log_addrs; i++) {\r\nconst u8 feature_sz = ARRAY_SIZE(log_addrs->features[0]);\r\nu8 *features = log_addrs->features[i];\r\nbool op_is_dev_features = false;\r\nunsigned j;\r\nlog_addrs->log_addr[i] = CEC_LOG_ADDR_INVALID;\r\nif (type_mask & (1 << log_addrs->log_addr_type[i])) {\r\ndprintk(1, "duplicate logical address type\n");\r\nreturn -EINVAL;\r\n}\r\ntype_mask |= 1 << log_addrs->log_addr_type[i];\r\nif ((type_mask & (1 << CEC_LOG_ADDR_TYPE_RECORD)) &&\r\n(type_mask & (1 << CEC_LOG_ADDR_TYPE_PLAYBACK))) {\r\ndprintk(1, "invalid record + playback combination\n");\r\nreturn -EINVAL;\r\n}\r\nif (log_addrs->primary_device_type[i] >\r\nCEC_OP_PRIM_DEVTYPE_PROCESSOR) {\r\ndprintk(1, "unknown primary device type\n");\r\nreturn -EINVAL;\r\n}\r\nif (log_addrs->primary_device_type[i] == 2) {\r\ndprintk(1, "invalid primary device type\n");\r\nreturn -EINVAL;\r\n}\r\nif (log_addrs->log_addr_type[i] > CEC_LOG_ADDR_TYPE_UNREGISTERED) {\r\ndprintk(1, "unknown logical address type\n");\r\nreturn -EINVAL;\r\n}\r\nfor (j = 0; j < feature_sz; j++) {\r\nif ((features[j] & 0x80) == 0) {\r\nif (op_is_dev_features)\r\nbreak;\r\nop_is_dev_features = true;\r\n}\r\n}\r\nif (!op_is_dev_features || j == feature_sz) {\r\ndprintk(1, "malformed features\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(features + j + 1, 0, feature_sz - j - 1);\r\n}\r\nif (log_addrs->cec_version >= CEC_OP_CEC_VERSION_2_0) {\r\nif (log_addrs->num_log_addrs > 2) {\r\ndprintk(1, "CEC 2.0 allows no more than 2 logical addresses\n");\r\nreturn -EINVAL;\r\n}\r\nif (log_addrs->num_log_addrs == 2) {\r\nif (!(type_mask & ((1 << CEC_LOG_ADDR_TYPE_AUDIOSYSTEM) |\r\n(1 << CEC_LOG_ADDR_TYPE_TV)))) {\r\ndprintk(1, "Two LAs is only allowed for audiosystem and TV\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(type_mask & ((1 << CEC_LOG_ADDR_TYPE_PLAYBACK) |\r\n(1 << CEC_LOG_ADDR_TYPE_RECORD)))) {\r\ndprintk(1, "An audiosystem/TV can only be combined with record or playback\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nfor (i = log_addrs->num_log_addrs; i < CEC_MAX_LOG_ADDRS; i++) {\r\nlog_addrs->primary_device_type[i] = 0;\r\nlog_addrs->log_addr_type[i] = 0;\r\nlog_addrs->all_device_types[i] = 0;\r\nmemset(log_addrs->features[i], 0,\r\nsizeof(log_addrs->features[i]));\r\n}\r\nlog_addrs->log_addr_mask = adap->log_addrs.log_addr_mask;\r\nadap->log_addrs = *log_addrs;\r\nif (adap->phys_addr != CEC_PHYS_ADDR_INVALID)\r\ncec_claim_log_addrs(adap, block);\r\nreturn 0;\r\n}\r\nint cec_s_log_addrs(struct cec_adapter *adap,\r\nstruct cec_log_addrs *log_addrs, bool block)\r\n{\r\nint err;\r\nmutex_lock(&adap->lock);\r\nerr = __cec_s_log_addrs(adap, log_addrs, block);\r\nmutex_unlock(&adap->lock);\r\nreturn err;\r\n}\r\nstatic void cec_fill_msg_report_features(struct cec_adapter *adap,\r\nstruct cec_msg *msg,\r\nunsigned int la_idx)\r\n{\r\nconst struct cec_log_addrs *las = &adap->log_addrs;\r\nconst u8 *features = las->features[la_idx];\r\nbool op_is_dev_features = false;\r\nunsigned int idx;\r\nmsg->msg[0] = (las->log_addr[la_idx] << 4) | 0x0f;\r\nmsg->len = 4;\r\nmsg->msg[1] = CEC_MSG_REPORT_FEATURES;\r\nmsg->msg[2] = adap->log_addrs.cec_version;\r\nmsg->msg[3] = las->all_device_types[la_idx];\r\nfor (idx = 0; idx < ARRAY_SIZE(las->features[0]); idx++) {\r\nmsg->msg[msg->len++] = features[idx];\r\nif ((features[idx] & CEC_OP_FEAT_EXT) == 0) {\r\nif (op_is_dev_features)\r\nbreak;\r\nop_is_dev_features = true;\r\n}\r\n}\r\n}\r\nstatic int cec_feature_abort_reason(struct cec_adapter *adap,\r\nstruct cec_msg *msg, u8 reason)\r\n{\r\nstruct cec_msg tx_msg = { };\r\nif (msg->msg[1] == CEC_MSG_FEATURE_ABORT)\r\nreturn 0;\r\ncec_msg_set_reply_to(&tx_msg, msg);\r\ncec_msg_feature_abort(&tx_msg, msg->msg[1], reason);\r\nreturn cec_transmit_msg(adap, &tx_msg, false);\r\n}\r\nstatic int cec_feature_abort(struct cec_adapter *adap, struct cec_msg *msg)\r\n{\r\nreturn cec_feature_abort_reason(adap, msg,\r\nCEC_OP_ABORT_UNRECOGNIZED_OP);\r\n}\r\nstatic int cec_feature_refused(struct cec_adapter *adap, struct cec_msg *msg)\r\n{\r\nreturn cec_feature_abort_reason(adap, msg,\r\nCEC_OP_ABORT_REFUSED);\r\n}\r\nstatic int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,\r\nbool is_reply)\r\n{\r\nbool is_broadcast = cec_msg_is_broadcast(msg);\r\nu8 dest_laddr = cec_msg_destination(msg);\r\nu8 init_laddr = cec_msg_initiator(msg);\r\nu8 devtype = cec_log_addr2dev(adap, dest_laddr);\r\nint la_idx = cec_log_addr2idx(adap, dest_laddr);\r\nbool from_unregistered = init_laddr == 0xf;\r\nstruct cec_msg tx_cec_msg = { };\r\ndprintk(1, "cec_receive_notify: %*ph\n", msg->len, msg->msg);\r\nif (cec_is_cdc_only(&adap->log_addrs) &&\r\nmsg->msg[1] != CEC_MSG_CDC_MESSAGE)\r\nreturn 0;\r\nif (adap->ops->received) {\r\nif (adap->ops->received(adap, msg) != -ENOMSG)\r\nreturn 0;\r\n}\r\nswitch (msg->msg[1]) {\r\ncase CEC_MSG_GET_CEC_VERSION:\r\ncase CEC_MSG_GIVE_DEVICE_VENDOR_ID:\r\ncase CEC_MSG_ABORT:\r\ncase CEC_MSG_GIVE_DEVICE_POWER_STATUS:\r\ncase CEC_MSG_GIVE_PHYSICAL_ADDR:\r\ncase CEC_MSG_GIVE_OSD_NAME:\r\ncase CEC_MSG_GIVE_FEATURES:\r\nif (adap->passthrough)\r\ngoto skip_processing;\r\nif (is_broadcast || from_unregistered)\r\nreturn 0;\r\nbreak;\r\ncase CEC_MSG_USER_CONTROL_PRESSED:\r\ncase CEC_MSG_USER_CONTROL_RELEASED:\r\nif (is_broadcast || from_unregistered)\r\ngoto skip_processing;\r\nbreak;\r\ncase CEC_MSG_REPORT_PHYSICAL_ADDR:\r\nif (!is_broadcast)\r\ngoto skip_processing;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncec_msg_set_reply_to(&tx_cec_msg, msg);\r\nswitch (msg->msg[1]) {\r\ncase CEC_MSG_REPORT_PHYSICAL_ADDR: {\r\nu16 pa = (msg->msg[2] << 8) | msg->msg[3];\r\nif (!from_unregistered)\r\nadap->phys_addrs[init_laddr] = pa;\r\ndprintk(1, "Reported physical address %x.%x.%x.%x for logical address %d\n",\r\ncec_phys_addr_exp(pa), init_laddr);\r\nbreak;\r\n}\r\ncase CEC_MSG_USER_CONTROL_PRESSED:\r\nif (!(adap->capabilities & CEC_CAP_RC) ||\r\n!(adap->log_addrs.flags & CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU))\r\nbreak;\r\n#if IS_REACHABLE(CONFIG_RC_CORE)\r\nswitch (msg->msg[2]) {\r\ncase 0x60:\r\nif (msg->len == 2)\r\nrc_keydown(adap->rc, RC_TYPE_CEC,\r\nmsg->msg[2], 0);\r\nelse\r\nrc_keydown(adap->rc, RC_TYPE_CEC,\r\nmsg->msg[2] << 8 | msg->msg[3], 0);\r\nbreak;\r\ncase 0x56: case 0x57:\r\ncase 0x67: case 0x68: case 0x69: case 0x6a:\r\nbreak;\r\ndefault:\r\nrc_keydown(adap->rc, RC_TYPE_CEC, msg->msg[2], 0);\r\nbreak;\r\n}\r\n#endif\r\nbreak;\r\ncase CEC_MSG_USER_CONTROL_RELEASED:\r\nif (!(adap->capabilities & CEC_CAP_RC) ||\r\n!(adap->log_addrs.flags & CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU))\r\nbreak;\r\n#if IS_REACHABLE(CONFIG_RC_CORE)\r\nrc_keyup(adap->rc);\r\n#endif\r\nbreak;\r\ncase CEC_MSG_GET_CEC_VERSION:\r\ncec_msg_cec_version(&tx_cec_msg, adap->log_addrs.cec_version);\r\nreturn cec_transmit_msg(adap, &tx_cec_msg, false);\r\ncase CEC_MSG_GIVE_PHYSICAL_ADDR:\r\nif (devtype == CEC_OP_PRIM_DEVTYPE_SWITCH && dest_laddr == 15)\r\nreturn 0;\r\ncec_msg_report_physical_addr(&tx_cec_msg, adap->phys_addr, devtype);\r\nreturn cec_transmit_msg(adap, &tx_cec_msg, false);\r\ncase CEC_MSG_GIVE_DEVICE_VENDOR_ID:\r\nif (adap->log_addrs.vendor_id == CEC_VENDOR_ID_NONE)\r\nreturn cec_feature_abort(adap, msg);\r\ncec_msg_device_vendor_id(&tx_cec_msg, adap->log_addrs.vendor_id);\r\nreturn cec_transmit_msg(adap, &tx_cec_msg, false);\r\ncase CEC_MSG_ABORT:\r\nif (devtype == CEC_OP_PRIM_DEVTYPE_SWITCH)\r\nreturn 0;\r\nreturn cec_feature_refused(adap, msg);\r\ncase CEC_MSG_GIVE_OSD_NAME: {\r\nif (adap->log_addrs.osd_name[0] == 0)\r\nreturn cec_feature_abort(adap, msg);\r\ncec_msg_set_osd_name(&tx_cec_msg, adap->log_addrs.osd_name);\r\nreturn cec_transmit_msg(adap, &tx_cec_msg, false);\r\n}\r\ncase CEC_MSG_GIVE_FEATURES:\r\nif (adap->log_addrs.cec_version < CEC_OP_CEC_VERSION_2_0)\r\nreturn cec_feature_abort(adap, msg);\r\ncec_fill_msg_report_features(adap, &tx_cec_msg, la_idx);\r\nreturn cec_transmit_msg(adap, &tx_cec_msg, false);\r\ndefault:\r\nif (!is_broadcast && !is_reply && !adap->follower_cnt &&\r\n!adap->cec_follower && msg->msg[1] != CEC_MSG_FEATURE_ABORT)\r\nreturn cec_feature_abort(adap, msg);\r\nbreak;\r\n}\r\nskip_processing:\r\nif (is_reply && !(msg->flags & CEC_MSG_FL_REPLY_TO_FOLLOWERS))\r\nreturn 0;\r\nif (adap->cec_follower)\r\ncec_queue_msg_fh(adap->cec_follower, msg);\r\nelse\r\ncec_queue_msg_followers(adap, msg);\r\nreturn 0;\r\n}\r\nint cec_monitor_all_cnt_inc(struct cec_adapter *adap)\r\n{\r\nint ret = 0;\r\nif (adap->monitor_all_cnt == 0)\r\nret = call_op(adap, adap_monitor_all_enable, 1);\r\nif (ret == 0)\r\nadap->monitor_all_cnt++;\r\nreturn ret;\r\n}\r\nvoid cec_monitor_all_cnt_dec(struct cec_adapter *adap)\r\n{\r\nadap->monitor_all_cnt--;\r\nif (adap->monitor_all_cnt == 0)\r\nWARN_ON(call_op(adap, adap_monitor_all_enable, 0));\r\n}\r\nint cec_adap_status(struct seq_file *file, void *priv)\r\n{\r\nstruct cec_adapter *adap = dev_get_drvdata(file->private);\r\nstruct cec_data *data;\r\nmutex_lock(&adap->lock);\r\nseq_printf(file, "configured: %d\n", adap->is_configured);\r\nseq_printf(file, "configuring: %d\n", adap->is_configuring);\r\nseq_printf(file, "phys_addr: %x.%x.%x.%x\n",\r\ncec_phys_addr_exp(adap->phys_addr));\r\nseq_printf(file, "number of LAs: %d\n", adap->log_addrs.num_log_addrs);\r\nseq_printf(file, "LA mask: 0x%04x\n", adap->log_addrs.log_addr_mask);\r\nif (adap->cec_follower)\r\nseq_printf(file, "has CEC follower%s\n",\r\nadap->passthrough ? " (in passthrough mode)" : "");\r\nif (adap->cec_initiator)\r\nseq_puts(file, "has CEC initiator\n");\r\nif (adap->monitor_all_cnt)\r\nseq_printf(file, "file handles in Monitor All mode: %u\n",\r\nadap->monitor_all_cnt);\r\ndata = adap->transmitting;\r\nif (data)\r\nseq_printf(file, "transmitting message: %*ph (reply: %02x, timeout: %ums)\n",\r\ndata->msg.len, data->msg.msg, data->msg.reply,\r\ndata->msg.timeout);\r\nseq_printf(file, "pending transmits: %u\n", adap->transmit_queue_sz);\r\nlist_for_each_entry(data, &adap->transmit_queue, list) {\r\nseq_printf(file, "queued tx message: %*ph (reply: %02x, timeout: %ums)\n",\r\ndata->msg.len, data->msg.msg, data->msg.reply,\r\ndata->msg.timeout);\r\n}\r\nlist_for_each_entry(data, &adap->wait_queue, list) {\r\nseq_printf(file, "message waiting for reply: %*ph (reply: %02x, timeout: %ums)\n",\r\ndata->msg.len, data->msg.msg, data->msg.reply,\r\ndata->msg.timeout);\r\n}\r\ncall_void_op(adap, adap_status, file);\r\nmutex_unlock(&adap->lock);\r\nreturn 0;\r\n}
