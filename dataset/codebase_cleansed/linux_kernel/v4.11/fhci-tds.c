static struct usb_td __iomem *next_bd(struct usb_td __iomem *base,\r\nstruct usb_td __iomem *td,\r\nu16 status)\r\n{\r\nif (status & TD_W)\r\nreturn base;\r\nelse\r\nreturn ++td;\r\n}\r\nvoid fhci_push_dummy_bd(struct endpoint *ep)\r\n{\r\nif (!ep->already_pushed_dummy_bd) {\r\nu16 td_status = in_be16(&ep->empty_td->status);\r\nout_be32(&ep->empty_td->buf_ptr, DUMMY_BD_BUFFER);\r\nep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);\r\nep->already_pushed_dummy_bd = true;\r\n}\r\n}\r\nvoid fhci_ep0_free(struct fhci_usb *usb)\r\n{\r\nstruct endpoint *ep;\r\nint size;\r\nep = usb->ep0;\r\nif (ep) {\r\nif (ep->td_base)\r\ncpm_muram_free(cpm_muram_offset(ep->td_base));\r\nif (kfifo_initialized(&ep->conf_frame_Q)) {\r\nsize = cq_howmany(&ep->conf_frame_Q);\r\nfor (; size; size--) {\r\nstruct packet *pkt = cq_get(&ep->conf_frame_Q);\r\nkfree(pkt);\r\n}\r\ncq_delete(&ep->conf_frame_Q);\r\n}\r\nif (kfifo_initialized(&ep->empty_frame_Q)) {\r\nsize = cq_howmany(&ep->empty_frame_Q);\r\nfor (; size; size--) {\r\nstruct packet *pkt = cq_get(&ep->empty_frame_Q);\r\nkfree(pkt);\r\n}\r\ncq_delete(&ep->empty_frame_Q);\r\n}\r\nif (kfifo_initialized(&ep->dummy_packets_Q)) {\r\nsize = cq_howmany(&ep->dummy_packets_Q);\r\nfor (; size; size--) {\r\nu8 *buff = cq_get(&ep->dummy_packets_Q);\r\nkfree(buff);\r\n}\r\ncq_delete(&ep->dummy_packets_Q);\r\n}\r\nkfree(ep);\r\nusb->ep0 = NULL;\r\n}\r\n}\r\nu32 fhci_create_ep(struct fhci_usb *usb, enum fhci_mem_alloc data_mem,\r\nu32 ring_len)\r\n{\r\nstruct endpoint *ep;\r\nstruct usb_td __iomem *td;\r\nunsigned long ep_offset;\r\nchar *err_for = "endpoint PRAM";\r\nint ep_mem_size;\r\nu32 i;\r\nif (!(ring_len > 2)) {\r\nfhci_err(usb->fhci, "illegal TD ring length parameters\n");\r\nreturn -EINVAL;\r\n}\r\nep = kzalloc(sizeof(*ep), GFP_KERNEL);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nep_mem_size = ring_len * sizeof(*td) + sizeof(struct fhci_ep_pram);\r\nep_offset = cpm_muram_alloc(ep_mem_size, 32);\r\nif (IS_ERR_VALUE(ep_offset))\r\ngoto err;\r\nep->td_base = cpm_muram_addr(ep_offset);\r\nif (cq_new(&ep->conf_frame_Q, ring_len + 2) ||\r\ncq_new(&ep->empty_frame_Q, ring_len + 2) ||\r\ncq_new(&ep->dummy_packets_Q, ring_len + 2)) {\r\nerr_for = "frame_queues";\r\ngoto err;\r\n}\r\nfor (i = 0; i < (ring_len + 1); i++) {\r\nstruct packet *pkt;\r\nu8 *buff;\r\npkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\r\nif (!pkt) {\r\nerr_for = "frame";\r\ngoto err;\r\n}\r\nbuff = kmalloc(1028 * sizeof(*buff), GFP_KERNEL);\r\nif (!buff) {\r\nkfree(pkt);\r\nerr_for = "buffer";\r\ngoto err;\r\n}\r\ncq_put(&ep->empty_frame_Q, pkt);\r\ncq_put(&ep->dummy_packets_Q, buff);\r\n}\r\nep->ep_pram_ptr = (void __iomem *)ep->td_base + sizeof(*td) * ring_len;\r\nep->conf_td = ep->td_base;\r\nep->empty_td = ep->td_base;\r\nep->already_pushed_dummy_bd = false;\r\ntd = ep->td_base;\r\nfor (i = 0; i < ring_len; i++) {\r\nout_be32(&td->buf_ptr, 0);\r\nout_be16(&td->status, 0);\r\nout_be16(&td->length, 0);\r\nout_be16(&td->extra, 0);\r\ntd++;\r\n}\r\ntd--;\r\nout_be16(&td->status, TD_W);\r\nout_be16(&td->length, 0);\r\nusb->ep0 = ep;\r\nreturn 0;\r\nerr:\r\nfhci_ep0_free(usb);\r\nkfree(ep);\r\nfhci_err(usb->fhci, "no memory for the %s\n", err_for);\r\nreturn -ENOMEM;\r\n}\r\nvoid fhci_init_ep_registers(struct fhci_usb *usb, struct endpoint *ep,\r\nenum fhci_mem_alloc data_mem)\r\n{\r\nu8 rt;\r\nout_be16(&usb->fhci->regs->usb_usep[0],\r\nUSB_TRANS_CTR | USB_EP_MF | USB_EP_RTE);\r\nout_be16(&usb->fhci->pram->ep_ptr[0],\r\ncpm_muram_offset(ep->ep_pram_ptr));\r\nrt = (BUS_MODE_BO_BE | BUS_MODE_GBL);\r\n#ifdef MULTI_DATA_BUS\r\nif (data_mem == MEM_SECONDARY)\r\nrt |= BUS_MODE_DTB;\r\n#endif\r\nout_8(&ep->ep_pram_ptr->rx_func_code, rt);\r\nout_8(&ep->ep_pram_ptr->tx_func_code, rt);\r\nout_be16(&ep->ep_pram_ptr->rx_buff_len, 1028);\r\nout_be16(&ep->ep_pram_ptr->rx_base, 0);\r\nout_be16(&ep->ep_pram_ptr->tx_base, cpm_muram_offset(ep->td_base));\r\nout_be16(&ep->ep_pram_ptr->rx_bd_ptr, 0);\r\nout_be16(&ep->ep_pram_ptr->tx_bd_ptr, cpm_muram_offset(ep->td_base));\r\nout_be32(&ep->ep_pram_ptr->tx_state, 0);\r\n}\r\nstatic void fhci_td_transaction_confirm(struct fhci_usb *usb)\r\n{\r\nstruct endpoint *ep = usb->ep0;\r\nstruct packet *pkt;\r\nstruct usb_td __iomem *td;\r\nu16 extra_data;\r\nu16 td_status;\r\nu16 td_length;\r\nu32 buf;\r\nwhile (1) {\r\ntd = ep->conf_td;\r\ntd_status = in_be16(&td->status);\r\ntd_length = in_be16(&td->length);\r\nbuf = in_be32(&td->buf_ptr);\r\nextra_data = in_be16(&td->extra);\r\nif (!(!(td_status & TD_R) && ((td_status & ~TD_W) || buf)))\r\nbreak;\r\nelse if ((buf == DUMMY_BD_BUFFER) && !(td_status & ~TD_W))\r\nbreak;\r\nclrbits16(&td->status, ~TD_W);\r\nout_be16(&td->length, 0);\r\nout_be32(&td->buf_ptr, 0);\r\nout_be16(&td->extra, 0);\r\nep->conf_td = next_bd(ep->td_base, ep->conf_td, td_status);\r\nif ((buf == DUMMY2_BD_BUFFER) && !(td_status & ~TD_W))\r\ncontinue;\r\npkt = cq_get(&ep->conf_frame_Q);\r\nif (!pkt)\r\nfhci_err(usb->fhci, "no frame to confirm\n");\r\nif (td_status & TD_ERRORS) {\r\nif (td_status & TD_RXER) {\r\nif (td_status & TD_CR)\r\npkt->status = USB_TD_RX_ER_CRC;\r\nelse if (td_status & TD_AB)\r\npkt->status = USB_TD_RX_ER_BITSTUFF;\r\nelse if (td_status & TD_OV)\r\npkt->status = USB_TD_RX_ER_OVERUN;\r\nelse if (td_status & TD_BOV)\r\npkt->status = USB_TD_RX_DATA_OVERUN;\r\nelse if (td_status & TD_NO)\r\npkt->status = USB_TD_RX_ER_NONOCT;\r\nelse\r\nfhci_err(usb->fhci, "illegal error "\r\n"occurred\n");\r\n} else if (td_status & TD_NAK)\r\npkt->status = USB_TD_TX_ER_NAK;\r\nelse if (td_status & TD_TO)\r\npkt->status = USB_TD_TX_ER_TIMEOUT;\r\nelse if (td_status & TD_UN)\r\npkt->status = USB_TD_TX_ER_UNDERUN;\r\nelse if (td_status & TD_STAL)\r\npkt->status = USB_TD_TX_ER_STALL;\r\nelse\r\nfhci_err(usb->fhci, "illegal error occurred\n");\r\n} else if ((extra_data & TD_TOK_IN) &&\r\npkt->len > td_length - CRC_SIZE) {\r\npkt->status = USB_TD_RX_DATA_UNDERUN;\r\n}\r\nif (extra_data & TD_TOK_IN)\r\npkt->len = td_length - CRC_SIZE;\r\nelse if (pkt->info & PKT_ZLP)\r\npkt->len = 0;\r\nelse\r\npkt->len = td_length;\r\nfhci_transaction_confirm(usb, pkt);\r\n}\r\n}\r\nu32 fhci_host_transaction(struct fhci_usb *usb,\r\nstruct packet *pkt,\r\nenum fhci_ta_type trans_type,\r\nu8 dest_addr,\r\nu8 dest_ep,\r\nenum fhci_tf_mode trans_mode,\r\nenum fhci_speed dest_speed, u8 data_toggle)\r\n{\r\nstruct endpoint *ep = usb->ep0;\r\nstruct usb_td __iomem *td;\r\nu16 extra_data;\r\nu16 td_status;\r\nfhci_usb_disable_interrupt(usb);\r\ntd = ep->empty_td;\r\ntd_status = in_be16(&td->status);\r\nif (td_status & TD_R && in_be16(&td->length)) {\r\nfhci_usb_enable_interrupt(usb);\r\nreturn -1;\r\n}\r\nep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);\r\nfhci_usb_enable_interrupt(usb);\r\npkt->priv_data = td;\r\nout_be32(&td->buf_ptr, virt_to_phys(pkt->data));\r\nextra_data = (dest_ep << TD_ENDP_SHIFT) | dest_addr;\r\nswitch (trans_type) {\r\ncase FHCI_TA_IN:\r\nextra_data |= TD_TOK_IN;\r\nbreak;\r\ncase FHCI_TA_OUT:\r\nextra_data |= TD_TOK_OUT;\r\nbreak;\r\ncase FHCI_TA_SETUP:\r\nextra_data |= TD_TOK_SETUP;\r\nbreak;\r\n}\r\nif (trans_mode == FHCI_TF_ISO)\r\nextra_data |= TD_ISO;\r\nout_be16(&td->extra, extra_data);\r\ntd_status = ((td_status & TD_W) | TD_R | TD_L | TD_I | TD_CNF);\r\nif (!(pkt->info & PKT_NO_CRC))\r\ntd_status |= TD_TC;\r\nswitch (trans_type) {\r\ncase FHCI_TA_IN:\r\nif (data_toggle)\r\npkt->info |= PKT_PID_DATA1;\r\nelse\r\npkt->info |= PKT_PID_DATA0;\r\nbreak;\r\ndefault:\r\nif (data_toggle) {\r\ntd_status |= TD_PID_DATA1;\r\npkt->info |= PKT_PID_DATA1;\r\n} else {\r\ntd_status |= TD_PID_DATA0;\r\npkt->info |= PKT_PID_DATA0;\r\n}\r\nbreak;\r\n}\r\nif ((dest_speed == FHCI_LOW_SPEED) &&\r\n(usb->port_status == FHCI_PORT_FULL))\r\ntd_status |= TD_LSP;\r\nout_be16(&td->status, td_status);\r\nif (trans_type == FHCI_TA_IN)\r\nout_be16(&td->length, pkt->len + CRC_SIZE);\r\nelse\r\nout_be16(&td->length, pkt->len);\r\ncq_put(&ep->conf_frame_Q, pkt);\r\nif (cq_howmany(&ep->conf_frame_Q) == 1)\r\nout_8(&usb->fhci->regs->usb_uscom, USB_CMD_STR_FIFO);\r\nreturn 0;\r\n}\r\nvoid fhci_flush_bds(struct fhci_usb *usb)\r\n{\r\nu16 extra_data;\r\nu16 td_status;\r\nu32 buf;\r\nstruct usb_td __iomem *td;\r\nstruct endpoint *ep = usb->ep0;\r\ntd = ep->td_base;\r\nwhile (1) {\r\ntd_status = in_be16(&td->status);\r\nbuf = in_be32(&td->buf_ptr);\r\nextra_data = in_be16(&td->extra);\r\nif (td_status & TD_R)\r\nout_be16(&td->status, (td_status & ~TD_R) | TD_TO);\r\nelse if (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER)\r\nout_be32(&td->buf_ptr, DUMMY2_BD_BUFFER);\r\nif (td_status & TD_W)\r\nbreak;\r\ntd++;\r\n}\r\nfhci_td_transaction_confirm(usb);\r\ntd = ep->td_base;\r\ndo {\r\nout_be16(&td->status, 0);\r\nout_be16(&td->length, 0);\r\nout_be32(&td->buf_ptr, 0);\r\nout_be16(&td->extra, 0);\r\ntd++;\r\n} while (!(in_be16(&td->status) & TD_W));\r\nout_be16(&td->status, TD_W);\r\nout_be16(&td->length, 0);\r\nout_be32(&td->buf_ptr, 0);\r\nout_be16(&td->extra, 0);\r\nout_be16(&ep->ep_pram_ptr->tx_bd_ptr,\r\nin_be16(&ep->ep_pram_ptr->tx_base));\r\nout_be32(&ep->ep_pram_ptr->tx_state, 0);\r\nout_be16(&ep->ep_pram_ptr->tx_cnt, 0);\r\nep->empty_td = ep->td_base;\r\nep->conf_td = ep->td_base;\r\n}\r\nvoid fhci_flush_actual_frame(struct fhci_usb *usb)\r\n{\r\nu8 mode;\r\nu16 tb_ptr;\r\nu16 extra_data;\r\nu16 td_status;\r\nu32 buf_ptr;\r\nstruct usb_td __iomem *td;\r\nstruct endpoint *ep = usb->ep0;\r\nmode = in_8(&usb->fhci->regs->usb_usmod);\r\nout_8(&usb->fhci->regs->usb_usmod, mode & ~USB_MODE_EN);\r\ntb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);\r\ntd = cpm_muram_addr(tb_ptr);\r\ntd_status = in_be16(&td->status);\r\nbuf_ptr = in_be32(&td->buf_ptr);\r\nextra_data = in_be16(&td->extra);\r\ndo {\r\nif (td_status & TD_R) {\r\nout_be16(&td->status, (td_status & ~TD_R) | TD_TO);\r\n} else {\r\nout_be32(&td->buf_ptr, 0);\r\nep->already_pushed_dummy_bd = false;\r\nbreak;\r\n}\r\ntd = next_bd(ep->td_base, td, td_status);\r\ntd_status = in_be16(&td->status);\r\nbuf_ptr = in_be32(&td->buf_ptr);\r\nextra_data = in_be16(&td->extra);\r\n} while ((td_status & TD_R) || buf_ptr);\r\nfhci_td_transaction_confirm(usb);\r\nout_be16(&ep->ep_pram_ptr->tx_bd_ptr,\r\nin_be16(&ep->ep_pram_ptr->tx_base));\r\nout_be32(&ep->ep_pram_ptr->tx_state, 0);\r\nout_be16(&ep->ep_pram_ptr->tx_cnt, 0);\r\nep->empty_td = ep->td_base;\r\nep->conf_td = ep->td_base;\r\nusb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;\r\nout_be16(&usb->fhci->regs->usb_usber, 0xffff);\r\nout_8(&usb->fhci->regs->usb_usmod, mode | USB_MODE_EN);\r\n}\r\nvoid fhci_tx_conf_interrupt(struct fhci_usb *usb)\r\n{\r\nfhci_td_transaction_confirm(usb);\r\nif (((fhci_get_sof_timer_count(usb) < usb->max_frame_usage) ||\r\n(usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)) &&\r\n(list_empty(&usb->actual_frame->tds_list)))\r\nfhci_schedule_transactions(usb);\r\n}\r\nvoid fhci_host_transmit_actual_frame(struct fhci_usb *usb)\r\n{\r\nu16 tb_ptr;\r\nu16 td_status;\r\nstruct usb_td __iomem *td;\r\nstruct endpoint *ep = usb->ep0;\r\ntb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);\r\ntd = cpm_muram_addr(tb_ptr);\r\nif (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER) {\r\nstruct usb_td __iomem *old_td = td;\r\nep->already_pushed_dummy_bd = false;\r\ntd_status = in_be16(&td->status);\r\ntd = next_bd(ep->td_base, td, td_status);\r\ntb_ptr = cpm_muram_offset(td);\r\nout_be16(&ep->ep_pram_ptr->tx_bd_ptr, tb_ptr);\r\nif (in_be16(&td->status) & TD_R)\r\nout_8(&usb->fhci->regs->usb_uscom, USB_CMD_STR_FIFO);\r\nif (in_be32(&ep->conf_td->buf_ptr) == DUMMY_BD_BUFFER) {\r\nout_be32(&old_td->buf_ptr, 0);\r\nep->conf_td = next_bd(ep->td_base, ep->conf_td,\r\ntd_status);\r\n} else {\r\nout_be32(&old_td->buf_ptr, DUMMY2_BD_BUFFER);\r\n}\r\n}\r\n}
