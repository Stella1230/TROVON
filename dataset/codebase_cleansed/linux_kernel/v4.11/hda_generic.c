int snd_hda_gen_spec_init(struct hda_gen_spec *spec)\r\n{\r\nsnd_array_init(&spec->kctls, sizeof(struct snd_kcontrol_new), 32);\r\nsnd_array_init(&spec->paths, sizeof(struct nid_path), 8);\r\nsnd_array_init(&spec->loopback_list, sizeof(struct hda_amp_list), 8);\r\nmutex_init(&spec->pcm_mutex);\r\nreturn 0;\r\n}\r\nstruct snd_kcontrol_new *\r\nsnd_hda_gen_add_kctl(struct hda_gen_spec *spec, const char *name,\r\nconst struct snd_kcontrol_new *temp)\r\n{\r\nstruct snd_kcontrol_new *knew = snd_array_new(&spec->kctls);\r\nif (!knew)\r\nreturn NULL;\r\n*knew = *temp;\r\nif (name)\r\nknew->name = kstrdup(name, GFP_KERNEL);\r\nelse if (knew->name)\r\nknew->name = kstrdup(knew->name, GFP_KERNEL);\r\nif (!knew->name)\r\nreturn NULL;\r\nreturn knew;\r\n}\r\nstatic void free_kctls(struct hda_gen_spec *spec)\r\n{\r\nif (spec->kctls.list) {\r\nstruct snd_kcontrol_new *kctl = spec->kctls.list;\r\nint i;\r\nfor (i = 0; i < spec->kctls.used; i++)\r\nkfree(kctl[i].name);\r\n}\r\nsnd_array_free(&spec->kctls);\r\n}\r\nstatic void snd_hda_gen_spec_free(struct hda_gen_spec *spec)\r\n{\r\nif (!spec)\r\nreturn;\r\nfree_kctls(spec);\r\nsnd_array_free(&spec->paths);\r\nsnd_array_free(&spec->loopback_list);\r\n}\r\nstatic void parse_user_hints(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint val;\r\nval = snd_hda_get_bool_hint(codec, "jack_detect");\r\nif (val >= 0)\r\ncodec->no_jack_detect = !val;\r\nval = snd_hda_get_bool_hint(codec, "inv_jack_detect");\r\nif (val >= 0)\r\ncodec->inv_jack_detect = !!val;\r\nval = snd_hda_get_bool_hint(codec, "trigger_sense");\r\nif (val >= 0)\r\ncodec->no_trigger_sense = !val;\r\nval = snd_hda_get_bool_hint(codec, "inv_eapd");\r\nif (val >= 0)\r\ncodec->inv_eapd = !!val;\r\nval = snd_hda_get_bool_hint(codec, "pcm_format_first");\r\nif (val >= 0)\r\ncodec->pcm_format_first = !!val;\r\nval = snd_hda_get_bool_hint(codec, "sticky_stream");\r\nif (val >= 0)\r\ncodec->no_sticky_stream = !val;\r\nval = snd_hda_get_bool_hint(codec, "spdif_status_reset");\r\nif (val >= 0)\r\ncodec->spdif_status_reset = !!val;\r\nval = snd_hda_get_bool_hint(codec, "pin_amp_workaround");\r\nif (val >= 0)\r\ncodec->pin_amp_workaround = !!val;\r\nval = snd_hda_get_bool_hint(codec, "single_adc_amp");\r\nif (val >= 0)\r\ncodec->single_adc_amp = !!val;\r\nval = snd_hda_get_bool_hint(codec, "power_save_node");\r\nif (val >= 0)\r\ncodec->power_save_node = !!val;\r\nval = snd_hda_get_bool_hint(codec, "auto_mute");\r\nif (val >= 0)\r\nspec->suppress_auto_mute = !val;\r\nval = snd_hda_get_bool_hint(codec, "auto_mic");\r\nif (val >= 0)\r\nspec->suppress_auto_mic = !val;\r\nval = snd_hda_get_bool_hint(codec, "line_in_auto_switch");\r\nif (val >= 0)\r\nspec->line_in_auto_switch = !!val;\r\nval = snd_hda_get_bool_hint(codec, "auto_mute_via_amp");\r\nif (val >= 0)\r\nspec->auto_mute_via_amp = !!val;\r\nval = snd_hda_get_bool_hint(codec, "need_dac_fix");\r\nif (val >= 0)\r\nspec->need_dac_fix = !!val;\r\nval = snd_hda_get_bool_hint(codec, "primary_hp");\r\nif (val >= 0)\r\nspec->no_primary_hp = !val;\r\nval = snd_hda_get_bool_hint(codec, "multi_io");\r\nif (val >= 0)\r\nspec->no_multi_io = !val;\r\nval = snd_hda_get_bool_hint(codec, "multi_cap_vol");\r\nif (val >= 0)\r\nspec->multi_cap_vol = !!val;\r\nval = snd_hda_get_bool_hint(codec, "inv_dmic_split");\r\nif (val >= 0)\r\nspec->inv_dmic_split = !!val;\r\nval = snd_hda_get_bool_hint(codec, "indep_hp");\r\nif (val >= 0)\r\nspec->indep_hp = !!val;\r\nval = snd_hda_get_bool_hint(codec, "add_stereo_mix_input");\r\nif (val >= 0)\r\nspec->add_stereo_mix_input = !!val;\r\nval = snd_hda_get_bool_hint(codec, "add_out_jack_modes");\r\nif (val >= 0)\r\nspec->add_jack_modes = !!val;\r\nval = snd_hda_get_bool_hint(codec, "add_in_jack_modes");\r\nif (val >= 0)\r\nspec->add_jack_modes = !!val;\r\nval = snd_hda_get_bool_hint(codec, "add_jack_modes");\r\nif (val >= 0)\r\nspec->add_jack_modes = !!val;\r\nval = snd_hda_get_bool_hint(codec, "power_down_unused");\r\nif (val >= 0)\r\nspec->power_down_unused = !!val;\r\nval = snd_hda_get_bool_hint(codec, "add_hp_mic");\r\nif (val >= 0)\r\nspec->hp_mic = !!val;\r\nval = snd_hda_get_bool_hint(codec, "hp_mic_detect");\r\nif (val >= 0)\r\nspec->suppress_hp_mic_detect = !val;\r\nif (!snd_hda_get_int_hint(codec, "mixer_nid", &val))\r\nspec->mixer_nid = val;\r\n}\r\nstatic inline void restore_pin_ctl(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nupdate_pin_ctl(codec, pin, snd_hda_codec_get_pin_target(codec, pin));\r\n}\r\nstatic void set_pin_target(struct hda_codec *codec, hda_nid_t pin,\r\nunsigned int val, bool do_write)\r\n{\r\nif (!pin)\r\nreturn;\r\nval = snd_hda_correct_pin_ctl(codec, pin, val);\r\nsnd_hda_codec_set_pin_target(codec, pin, val);\r\nif (do_write)\r\nupdate_pin_ctl(codec, pin, val);\r\n}\r\nstatic void set_pin_targets(struct hda_codec *codec, int num_pins,\r\nhda_nid_t *pins, unsigned int val)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pins; i++)\r\nset_pin_target(codec, pins[i], val, false);\r\n}\r\nstatic int find_idx_in_nid_list(hda_nid_t nid, const hda_nid_t *list, int nums)\r\n{\r\nint i;\r\nfor (i = 0; i < nums; i++)\r\nif (list[i] == nid)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic bool is_nid_contained(struct nid_path *path, hda_nid_t nid)\r\n{\r\nreturn find_idx_in_nid_list(nid, path->path, path->depth) >= 0;\r\n}\r\nstatic struct nid_path *get_nid_path(struct hda_codec *codec,\r\nhda_nid_t from_nid, hda_nid_t to_nid,\r\nint anchor_nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->paths.used; i++) {\r\nstruct nid_path *path = snd_array_elem(&spec->paths, i);\r\nif (path->depth <= 0)\r\ncontinue;\r\nif ((!from_nid || path->path[0] == from_nid) &&\r\n(!to_nid || path->path[path->depth - 1] == to_nid)) {\r\nif (!anchor_nid ||\r\n(anchor_nid > 0 && is_nid_contained(path, anchor_nid)) ||\r\n(anchor_nid < 0 && !is_nid_contained(path, anchor_nid)))\r\nreturn path;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint snd_hda_get_path_idx(struct hda_codec *codec, struct nid_path *path)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *array = spec->paths.list;\r\nssize_t idx;\r\nif (!spec->paths.used)\r\nreturn 0;\r\nidx = path - array;\r\nif (idx < 0 || idx >= spec->paths.used)\r\nreturn 0;\r\nreturn idx + 1;\r\n}\r\nstruct nid_path *snd_hda_get_path_from_idx(struct hda_codec *codec, int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (idx <= 0 || idx > spec->paths.used)\r\nreturn NULL;\r\nreturn snd_array_elem(&spec->paths, idx - 1);\r\n}\r\nstatic bool is_dac_already_used(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->paths.used; i++) {\r\nstruct nid_path *path = snd_array_elem(&spec->paths, i);\r\nif (path->path[0] == nid)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool is_reachable_path(struct hda_codec *codec,\r\nhda_nid_t from_nid, hda_nid_t to_nid)\r\n{\r\nif (!from_nid || !to_nid)\r\nreturn false;\r\nreturn snd_hda_get_conn_index(codec, to_nid, from_nid, true) >= 0;\r\n}\r\nstatic bool is_ctl_used(struct hda_codec *codec, unsigned int val, int type)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nval &= AMP_VAL_COMPARE_MASK;\r\nfor (i = 0; i < spec->paths.used; i++) {\r\nstruct nid_path *path = snd_array_elem(&spec->paths, i);\r\nif ((path->ctls[type] & AMP_VAL_COMPARE_MASK) == val)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool is_ctl_associated(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx, int type)\r\n{\r\nunsigned int val = HDA_COMPOSE_AMP_VAL(nid, 3, idx, dir);\r\nreturn is_ctl_used(codec, val, type);\r\n}\r\nstatic void print_nid_path(struct hda_codec *codec,\r\nconst char *pfx, struct nid_path *path)\r\n{\r\nchar buf[40];\r\nchar *pos = buf;\r\nint i;\r\n*pos = 0;\r\nfor (i = 0; i < path->depth; i++)\r\npos += scnprintf(pos, sizeof(buf) - (pos - buf), "%s%02x",\r\npos != buf ? ":" : "",\r\npath->path[i]);\r\ncodec_dbg(codec, "%s path: depth=%d '%s'\n", pfx, path->depth, buf);\r\n}\r\nstatic bool __parse_nid_path(struct hda_codec *codec,\r\nhda_nid_t from_nid, hda_nid_t to_nid,\r\nint anchor_nid, struct nid_path *path,\r\nint depth)\r\n{\r\nconst hda_nid_t *conn;\r\nint i, nums;\r\nif (to_nid == anchor_nid)\r\nanchor_nid = 0;\r\nelse if (to_nid == (hda_nid_t)(-anchor_nid))\r\nreturn false;\r\nnums = snd_hda_get_conn_list(codec, to_nid, &conn);\r\nfor (i = 0; i < nums; i++) {\r\nif (conn[i] != from_nid) {\r\nif (from_nid ||\r\nget_wcaps_type(get_wcaps(codec, conn[i])) != AC_WID_AUD_OUT ||\r\nis_dac_already_used(codec, conn[i]))\r\ncontinue;\r\n}\r\nif (anchor_nid <= 0)\r\ngoto found;\r\n}\r\nif (depth >= MAX_NID_PATH_DEPTH)\r\nreturn false;\r\nfor (i = 0; i < nums; i++) {\r\nunsigned int type;\r\ntype = get_wcaps_type(get_wcaps(codec, conn[i]));\r\nif (type == AC_WID_AUD_OUT || type == AC_WID_AUD_IN ||\r\ntype == AC_WID_PIN)\r\ncontinue;\r\nif (__parse_nid_path(codec, from_nid, conn[i],\r\nanchor_nid, path, depth + 1))\r\ngoto found;\r\n}\r\nreturn false;\r\nfound:\r\npath->path[path->depth] = conn[i];\r\npath->idx[path->depth + 1] = i;\r\nif (nums > 1 && get_wcaps_type(get_wcaps(codec, to_nid)) != AC_WID_AUD_MIX)\r\npath->multi[path->depth + 1] = 1;\r\npath->depth++;\r\nreturn true;\r\n}\r\nstatic bool snd_hda_parse_nid_path(struct hda_codec *codec, hda_nid_t from_nid,\r\nhda_nid_t to_nid, int anchor_nid,\r\nstruct nid_path *path)\r\n{\r\nif (__parse_nid_path(codec, from_nid, to_nid, anchor_nid, path, 1)) {\r\npath->path[path->depth] = to_nid;\r\npath->depth++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstruct nid_path *\r\nsnd_hda_add_new_path(struct hda_codec *codec, hda_nid_t from_nid,\r\nhda_nid_t to_nid, int anchor_nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nif (from_nid && to_nid && !is_reachable_path(codec, from_nid, to_nid))\r\nreturn NULL;\r\npath = get_nid_path(codec, from_nid, to_nid, anchor_nid);\r\nif (path)\r\nreturn path;\r\npath = snd_array_new(&spec->paths);\r\nif (!path)\r\nreturn NULL;\r\nmemset(path, 0, sizeof(*path));\r\nif (snd_hda_parse_nid_path(codec, from_nid, to_nid, anchor_nid, path))\r\nreturn path;\r\nspec->paths.used--;\r\nreturn NULL;\r\n}\r\nstatic void invalidate_nid_path(struct hda_codec *codec, int idx)\r\n{\r\nstruct nid_path *path = snd_hda_get_path_from_idx(codec, idx);\r\nif (!path)\r\nreturn;\r\nmemset(path, 0, sizeof(*path));\r\n}\r\nstatic hda_nid_t get_preferred_dac(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst hda_nid_t *list = spec->preferred_dacs;\r\nif (!list)\r\nreturn 0;\r\nfor (; *list; list += 2)\r\nif (*list == pin)\r\nreturn list[1];\r\nreturn 0;\r\n}\r\nstatic hda_nid_t look_for_dac(struct hda_codec *codec, hda_nid_t pin,\r\nbool is_digital)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nbool cap_digital;\r\nint i;\r\nfor (i = 0; i < spec->num_all_dacs; i++) {\r\nhda_nid_t nid = spec->all_dacs[i];\r\nif (!nid || is_dac_already_used(codec, nid))\r\ncontinue;\r\ncap_digital = !!(get_wcaps(codec, nid) & AC_WCAP_DIGITAL);\r\nif (is_digital != cap_digital)\r\ncontinue;\r\nif (is_reachable_path(codec, nid, pin))\r\nreturn nid;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int amp_val_replace_channels(unsigned int val, unsigned int chs)\r\n{\r\nval &= ~(0x3U << 16);\r\nval |= chs << 16;\r\nreturn val;\r\n}\r\nstatic bool same_amp_caps(struct hda_codec *codec, hda_nid_t nid1,\r\nhda_nid_t nid2, int dir)\r\n{\r\nif (!(get_wcaps(codec, nid1) & (1 << (dir + 1))))\r\nreturn !(get_wcaps(codec, nid2) & (1 << (dir + 1)));\r\nreturn (query_amp_caps(codec, nid1, dir) ==\r\nquery_amp_caps(codec, nid2, dir));\r\n}\r\nstatic hda_nid_t look_for_out_mute_nid(struct hda_codec *codec,\r\nstruct nid_path *path)\r\n{\r\nint i;\r\nfor (i = path->depth - 1; i >= 0; i--) {\r\nif (nid_has_mute(codec, path->path[i], HDA_OUTPUT))\r\nreturn path->path[i];\r\nif (i != path->depth - 1 && i != 0 &&\r\nnid_has_mute(codec, path->path[i], HDA_INPUT))\r\nreturn path->path[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic hda_nid_t look_for_out_vol_nid(struct hda_codec *codec,\r\nstruct nid_path *path)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = path->depth - 1; i >= 0; i--) {\r\nhda_nid_t nid = path->path[i];\r\nif ((spec->out_vol_mask >> nid) & 1)\r\ncontinue;\r\nif (nid_has_volume(codec, nid, HDA_OUTPUT))\r\nreturn nid;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool has_amp_in(struct hda_codec *codec, struct nid_path *path, int idx)\r\n{\r\nhda_nid_t nid = path->path[idx];\r\nunsigned int caps = get_wcaps(codec, nid);\r\nunsigned int type = get_wcaps_type(caps);\r\nif (!(caps & AC_WCAP_IN_AMP))\r\nreturn false;\r\nif (type == AC_WID_PIN && idx > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool has_amp_out(struct hda_codec *codec, struct nid_path *path, int idx)\r\n{\r\nhda_nid_t nid = path->path[idx];\r\nunsigned int caps = get_wcaps(codec, nid);\r\nunsigned int type = get_wcaps_type(caps);\r\nif (!(caps & AC_WCAP_OUT_AMP))\r\nreturn false;\r\nif (type == AC_WID_PIN && !idx)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool is_active_nid(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int dir, unsigned int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint type = get_wcaps_type(get_wcaps(codec, nid));\r\nint i, n;\r\nif (nid == codec->core.afg)\r\nreturn true;\r\nfor (n = 0; n < spec->paths.used; n++) {\r\nstruct nid_path *path = snd_array_elem(&spec->paths, n);\r\nif (!path->active)\r\ncontinue;\r\nif (codec->power_save_node) {\r\nif (!path->stream_enabled)\r\ncontinue;\r\nif (!(path->pin_enabled || path->pin_fixed) &&\r\ntype != AC_WID_AUD_OUT && type != AC_WID_AUD_IN)\r\ncontinue;\r\n}\r\nfor (i = 0; i < path->depth; i++) {\r\nif (path->path[i] == nid) {\r\nif (dir == HDA_OUTPUT || idx == -1 ||\r\npath->idx[i] == idx)\r\nreturn true;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic int get_amp_val_to_activate(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, unsigned int caps, bool enable)\r\n{\r\nunsigned int val = 0;\r\nif (caps & AC_AMPCAP_NUM_STEPS) {\r\nif (enable)\r\nval = (caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT;\r\n}\r\nif (caps & (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) {\r\nif (!enable)\r\nval |= HDA_AMP_MUTE;\r\n}\r\nreturn val;\r\n}\r\nstatic bool is_stereo_amps(struct hda_codec *codec, hda_nid_t nid, int dir)\r\n{\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nhda_nid_t conn;\r\nif (wcaps & AC_WCAP_STEREO)\r\nreturn true;\r\nif (dir != HDA_INPUT || get_wcaps_type(wcaps) != AC_WID_AUD_MIX)\r\nreturn false;\r\nif (snd_hda_get_num_conns(codec, nid) != 1)\r\nreturn false;\r\nif (snd_hda_get_connections(codec, nid, &conn, 1) < 0)\r\nreturn false;\r\nreturn !!(get_wcaps(codec, conn) & AC_WCAP_STEREO);\r\n}\r\nstatic void init_amp(struct hda_codec *codec, hda_nid_t nid, int dir, int idx)\r\n{\r\nunsigned int caps = query_amp_caps(codec, nid, dir);\r\nint val = get_amp_val_to_activate(codec, nid, dir, caps, false);\r\nif (is_stereo_amps(codec, nid, dir))\r\nsnd_hda_codec_amp_init_stereo(codec, nid, dir, idx, 0xff, val);\r\nelse\r\nsnd_hda_codec_amp_init(codec, nid, 0, dir, idx, 0xff, val);\r\n}\r\nstatic int update_amp(struct hda_codec *codec, hda_nid_t nid, int dir, int idx,\r\nunsigned int mask, unsigned int val)\r\n{\r\nif (is_stereo_amps(codec, nid, dir))\r\nreturn snd_hda_codec_amp_stereo(codec, nid, dir, idx,\r\nmask, val);\r\nelse\r\nreturn snd_hda_codec_amp_update(codec, nid, 0, dir, idx,\r\nmask, val);\r\n}\r\nstatic unsigned int get_amp_mask_to_modify(struct hda_codec *codec,\r\nhda_nid_t nid, int dir, int idx,\r\nunsigned int caps)\r\n{\r\nunsigned int mask = 0xff;\r\nif (caps & (AC_AMPCAP_MUTE | AC_AMPCAP_MIN_MUTE)) {\r\nif (is_ctl_associated(codec, nid, dir, idx, NID_PATH_MUTE_CTL))\r\nmask &= ~0x80;\r\n}\r\nif (caps & AC_AMPCAP_NUM_STEPS) {\r\nif (is_ctl_associated(codec, nid, dir, idx, NID_PATH_VOL_CTL) ||\r\nis_ctl_associated(codec, nid, dir, idx, NID_PATH_BOOST_CTL))\r\nmask &= ~0x7f;\r\n}\r\nreturn mask;\r\n}\r\nstatic void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nint idx, int idx_to_check, bool enable)\r\n{\r\nunsigned int caps;\r\nunsigned int mask, val;\r\ncaps = query_amp_caps(codec, nid, dir);\r\nval = get_amp_val_to_activate(codec, nid, dir, caps, enable);\r\nmask = get_amp_mask_to_modify(codec, nid, dir, idx_to_check, caps);\r\nif (!mask)\r\nreturn;\r\nval &= mask;\r\nupdate_amp(codec, nid, dir, idx, mask, val);\r\n}\r\nstatic void check_and_activate_amp(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx, int idx_to_check,\r\nbool enable)\r\n{\r\nif (!enable && is_active_nid(codec, nid, dir, idx_to_check))\r\nreturn;\r\nactivate_amp(codec, nid, dir, idx, idx_to_check, enable);\r\n}\r\nstatic void activate_amp_out(struct hda_codec *codec, struct nid_path *path,\r\nint i, bool enable)\r\n{\r\nhda_nid_t nid = path->path[i];\r\ninit_amp(codec, nid, HDA_OUTPUT, 0);\r\ncheck_and_activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);\r\n}\r\nstatic void activate_amp_in(struct hda_codec *codec, struct nid_path *path,\r\nint i, bool enable, bool add_aamix)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst hda_nid_t *conn;\r\nint n, nums, idx;\r\nint type;\r\nhda_nid_t nid = path->path[i];\r\nnums = snd_hda_get_conn_list(codec, nid, &conn);\r\ntype = get_wcaps_type(get_wcaps(codec, nid));\r\nif (type == AC_WID_PIN ||\r\n(type == AC_WID_AUD_IN && codec->single_adc_amp)) {\r\nnums = 1;\r\nidx = 0;\r\n} else\r\nidx = path->idx[i];\r\nfor (n = 0; n < nums; n++)\r\ninit_amp(codec, nid, HDA_INPUT, n);\r\nfor (n = 0; n < nums; n++) {\r\nif (n != idx) {\r\nif (conn[n] != spec->mixer_merge_nid)\r\ncontinue;\r\nif (!add_aamix) {\r\nactivate_amp(codec, nid, HDA_INPUT, n, n, false);\r\ncontinue;\r\n}\r\n}\r\ncheck_and_activate_amp(codec, nid, HDA_INPUT, n, idx, enable);\r\n}\r\n}\r\nstatic hda_nid_t path_power_update(struct hda_codec *codec,\r\nstruct nid_path *path,\r\nbool allow_powerdown)\r\n{\r\nhda_nid_t nid, changed = 0;\r\nint i, state, power;\r\nfor (i = 0; i < path->depth; i++) {\r\nnid = path->path[i];\r\nif (!(get_wcaps(codec, nid) & AC_WCAP_POWER))\r\ncontinue;\r\nif (nid == codec->core.afg)\r\ncontinue;\r\nif (!allow_powerdown || is_active_nid_for_any(codec, nid))\r\nstate = AC_PWRST_D0;\r\nelse\r\nstate = AC_PWRST_D3;\r\npower = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_POWER_STATE, 0);\r\nif (power != (state | (state << 4))) {\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_POWER_STATE, state);\r\nchanged = nid;\r\n#if 0\r\nif (state == AC_PWRST_D0)\r\nsnd_hdac_regmap_sync_node(&codec->core, nid);\r\n#endif\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic void sync_power_state_change(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nif (nid) {\r\nmsleep(10);\r\nsnd_hda_codec_read(codec, nid, 0, AC_VERB_GET_POWER_STATE, 0);\r\n}\r\n}\r\nvoid snd_hda_activate_path(struct hda_codec *codec, struct nid_path *path,\r\nbool enable, bool add_aamix)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\npath->active = enable;\r\nif (enable && (spec->power_down_unused || codec->power_save_node))\r\npath_power_update(codec, path, codec->power_save_node);\r\nfor (i = path->depth - 1; i >= 0; i--) {\r\nhda_nid_t nid = path->path[i];\r\nif (enable && path->multi[i])\r\nsnd_hda_codec_update_cache(codec, nid, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\npath->idx[i]);\r\nif (has_amp_in(codec, path, i))\r\nactivate_amp_in(codec, path, i, enable, add_aamix);\r\nif (has_amp_out(codec, path, i))\r\nactivate_amp_out(codec, path, i, enable);\r\n}\r\n}\r\nstatic void path_power_down_sync(struct hda_codec *codec, struct nid_path *path)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (!(spec->power_down_unused || codec->power_save_node) || path->active)\r\nreturn;\r\nsync_power_state_change(codec, path_power_update(codec, path, true));\r\n}\r\nstatic void set_pin_eapd(struct hda_codec *codec, hda_nid_t pin, bool enable)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->own_eapd_ctl ||\r\n!(snd_hda_query_pin_caps(codec, pin) & AC_PINCAP_EAPD))\r\nreturn;\r\nif (spec->keep_eapd_on && !enable)\r\nreturn;\r\nif (codec->inv_eapd)\r\nenable = !enable;\r\nsnd_hda_codec_update_cache(codec, pin, 0,\r\nAC_VERB_SET_EAPD_BTLENABLE,\r\nenable ? 0x02 : 0x00);\r\n}\r\nstatic void resume_path_from_idx(struct hda_codec *codec, int path_idx)\r\n{\r\nstruct nid_path *path = snd_hda_get_path_from_idx(codec, path_idx);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, path->active, false);\r\n}\r\nstatic struct snd_kcontrol_new *\r\nadd_control(struct hda_gen_spec *spec, int type, const char *name,\r\nint cidx, unsigned long val)\r\n{\r\nstruct snd_kcontrol_new *knew;\r\nknew = snd_hda_gen_add_kctl(spec, name, &control_templates[type]);\r\nif (!knew)\r\nreturn NULL;\r\nknew->index = cidx;\r\nif (get_amp_nid_(val))\r\nknew->subdevice = HDA_SUBDEV_AMP_FLAG;\r\nknew->private_value = val;\r\nreturn knew;\r\n}\r\nstatic int add_control_with_pfx(struct hda_gen_spec *spec, int type,\r\nconst char *pfx, const char *dir,\r\nconst char *sfx, int cidx, unsigned long val)\r\n{\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nsnprintf(name, sizeof(name), "%s %s %s", pfx, dir, sfx);\r\nif (!add_control(spec, type, name, cidx, val))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int add_vol_ctl(struct hda_codec *codec, const char *pfx, int cidx,\r\nunsigned int chs, struct nid_path *path)\r\n{\r\nunsigned int val;\r\nif (!path)\r\nreturn 0;\r\nval = path->ctls[NID_PATH_VOL_CTL];\r\nif (!val)\r\nreturn 0;\r\nval = amp_val_replace_channels(val, chs);\r\nreturn __add_pb_vol_ctrl(codec->spec, HDA_CTL_WIDGET_VOL, pfx, cidx, val);\r\n}\r\nstatic int get_default_ch_nums(struct hda_codec *codec, struct nid_path *path,\r\nint type)\r\n{\r\nint chs = 1;\r\nif (path) {\r\nhda_nid_t nid = get_amp_nid_(path->ctls[type]);\r\nif (nid && (get_wcaps(codec, nid) & AC_WCAP_STEREO))\r\nchs = 3;\r\n}\r\nreturn chs;\r\n}\r\nstatic int add_stereo_vol(struct hda_codec *codec, const char *pfx, int cidx,\r\nstruct nid_path *path)\r\n{\r\nint chs = get_default_ch_nums(codec, path, NID_PATH_VOL_CTL);\r\nreturn add_vol_ctl(codec, pfx, cidx, chs, path);\r\n}\r\nstatic int add_sw_ctl(struct hda_codec *codec, const char *pfx, int cidx,\r\nunsigned int chs, struct nid_path *path)\r\n{\r\nunsigned int val;\r\nint type = HDA_CTL_WIDGET_MUTE;\r\nif (!path)\r\nreturn 0;\r\nval = path->ctls[NID_PATH_MUTE_CTL];\r\nif (!val)\r\nreturn 0;\r\nval = amp_val_replace_channels(val, chs);\r\nif (get_amp_direction_(val) == HDA_INPUT) {\r\nhda_nid_t nid = get_amp_nid_(val);\r\nint nums = snd_hda_get_num_conns(codec, nid);\r\nif (nums > 1) {\r\ntype = HDA_CTL_BIND_MUTE;\r\nval |= nums << 19;\r\n}\r\n}\r\nreturn __add_pb_sw_ctrl(codec->spec, type, pfx, cidx, val);\r\n}\r\nstatic int add_stereo_sw(struct hda_codec *codec, const char *pfx,\r\nint cidx, struct nid_path *path)\r\n{\r\nint chs = get_default_ch_nums(codec, path, NID_PATH_MUTE_CTL);\r\nreturn add_sw_ctl(codec, pfx, cidx, chs, path);\r\n}\r\nstatic void sync_auto_mute_bits(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->auto_mute_via_amp) {\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nbool enabled = !((spec->mute_bits >> nid) & 1);\r\nucontrol->value.integer.value[0] &= enabled;\r\nucontrol->value.integer.value[1] &= enabled;\r\n}\r\n}\r\nstatic int hda_gen_mixer_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nsync_auto_mute_bits(kcontrol, ucontrol);\r\nreturn snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\n}\r\nstatic int hda_gen_bind_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nsync_auto_mute_bits(kcontrol, ucontrol);\r\nreturn snd_hda_mixer_bind_switch_put(kcontrol, ucontrol);\r\n}\r\nstatic bool path_has_mixer(struct hda_codec *codec, int path_idx, int ctl_type)\r\n{\r\nstruct nid_path *path = snd_hda_get_path_from_idx(codec, path_idx);\r\nreturn path && path->ctls[ctl_type];\r\n}\r\nstatic const char *get_line_out_pfx(struct hda_codec *codec, int ch,\r\nint *index, int ctl_type)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\n*index = 0;\r\nif (cfg->line_outs == 1 && !spec->multi_ios &&\r\n!cfg->hp_outs && !cfg->speaker_outs)\r\nreturn spec->vmaster_mute.hook ? "PCM" : "Master";\r\nif (spec->multiout.num_dacs == 1 && !spec->mixer_nid &&\r\n!spec->multiout.hp_out_nid[0] && !spec->multiout.extra_out_nid[0])\r\nreturn spec->vmaster_mute.hook ? "PCM" : "Master";\r\nif (ch >= cfg->line_outs)\r\nreturn channel_name[ch];\r\nswitch (cfg->line_out_type) {\r\ncase AUTO_PIN_SPEAKER_OUT:\r\nif (!ch && cfg->hp_outs &&\r\n!path_has_mixer(codec, spec->hp_paths[0], ctl_type))\r\nbreak;\r\nif (cfg->line_outs == 1)\r\nreturn "Speaker";\r\nif (cfg->line_outs == 2)\r\nreturn ch ? "Bass Speaker" : "Speaker";\r\nbreak;\r\ncase AUTO_PIN_HP_OUT:\r\nif (!ch && cfg->speaker_outs &&\r\n!path_has_mixer(codec, spec->speaker_paths[0], ctl_type))\r\nbreak;\r\nif (ch && spec->multi_ios)\r\nbreak;\r\n*index = ch;\r\nreturn "Headphone";\r\ncase AUTO_PIN_LINE_OUT:\r\nif (!ch && cfg->speaker_outs && cfg->hp_outs) {\r\nbool hp_lo_shared = !path_has_mixer(codec, spec->hp_paths[0], ctl_type);\r\nbool spk_lo_shared = !path_has_mixer(codec, spec->speaker_paths[0], ctl_type);\r\nif (hp_lo_shared && spk_lo_shared)\r\nreturn spec->vmaster_mute.hook ? "PCM" : "Master";\r\nif (hp_lo_shared)\r\nreturn "Headphone+LO";\r\nif (spk_lo_shared)\r\nreturn "Speaker+LO";\r\n}\r\n}\r\nif (cfg->line_outs == 1 && !spec->multi_ios)\r\nreturn "Line Out";\r\nif (ch >= ARRAY_SIZE(channel_name)) {\r\nsnd_BUG();\r\nreturn "PCM";\r\n}\r\nreturn channel_name[ch];\r\n}\r\nstatic int assign_out_path_ctls(struct hda_codec *codec, struct nid_path *path)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nunsigned int val;\r\nint badness = 0;\r\nif (!path)\r\nreturn BAD_SHARED_VOL * 2;\r\nif (path->ctls[NID_PATH_VOL_CTL] ||\r\npath->ctls[NID_PATH_MUTE_CTL])\r\nreturn 0;\r\nnid = look_for_out_vol_nid(codec, path);\r\nif (nid) {\r\nval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nif (spec->dac_min_mute)\r\nval |= HDA_AMP_VAL_MIN_MUTE;\r\nif (is_ctl_used(codec, val, NID_PATH_VOL_CTL))\r\nbadness += BAD_SHARED_VOL;\r\nelse\r\npath->ctls[NID_PATH_VOL_CTL] = val;\r\n} else\r\nbadness += BAD_SHARED_VOL;\r\nnid = look_for_out_mute_nid(codec, path);\r\nif (nid) {\r\nunsigned int wid_type = get_wcaps_type(get_wcaps(codec, nid));\r\nif (wid_type == AC_WID_PIN || wid_type == AC_WID_AUD_OUT ||\r\nnid_has_mute(codec, nid, HDA_OUTPUT))\r\nval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nelse\r\nval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_INPUT);\r\nif (is_ctl_used(codec, val, NID_PATH_MUTE_CTL))\r\nbadness += BAD_SHARED_VOL;\r\nelse\r\npath->ctls[NID_PATH_MUTE_CTL] = val;\r\n} else\r\nbadness += BAD_SHARED_VOL;\r\nreturn badness;\r\n}\r\nstatic hda_nid_t get_primary_out(struct hda_codec *codec, int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nif (cfg->line_outs > idx)\r\nreturn spec->private_dac_nids[idx];\r\nidx -= cfg->line_outs;\r\nif (spec->multi_ios > idx)\r\nreturn spec->multi_io[idx].dac;\r\nreturn 0;\r\n}\r\nstatic inline hda_nid_t try_dac(struct hda_codec *codec,\r\nhda_nid_t dac, hda_nid_t pin)\r\n{\r\nreturn is_reachable_path(codec, dac, pin) ? dac : 0;\r\n}\r\nstatic int try_assign_dacs(struct hda_codec *codec, int num_outs,\r\nconst hda_nid_t *pins, hda_nid_t *dacs,\r\nint *path_idx,\r\nconst struct badness_table *bad)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i, j;\r\nint badness = 0;\r\nhda_nid_t dac;\r\nif (!num_outs)\r\nreturn 0;\r\nfor (i = 0; i < num_outs; i++) {\r\nstruct nid_path *path;\r\nhda_nid_t pin = pins[i];\r\npath = snd_hda_get_path_from_idx(codec, path_idx[i]);\r\nif (path) {\r\nbadness += assign_out_path_ctls(codec, path);\r\ncontinue;\r\n}\r\ndacs[i] = get_preferred_dac(codec, pin);\r\nif (dacs[i]) {\r\nif (is_dac_already_used(codec, dacs[i]))\r\nbadness += bad->shared_primary;\r\n}\r\nif (!dacs[i])\r\ndacs[i] = look_for_dac(codec, pin, false);\r\nif (!dacs[i] && !i) {\r\nfor (j = 1; j < num_outs; j++) {\r\nif (is_reachable_path(codec, dacs[j], pin)) {\r\ndacs[0] = dacs[j];\r\ndacs[j] = 0;\r\ninvalidate_nid_path(codec, path_idx[j]);\r\npath_idx[j] = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\ndac = dacs[i];\r\nif (!dac) {\r\nif (num_outs > 2)\r\ndac = try_dac(codec, get_primary_out(codec, i), pin);\r\nif (!dac)\r\ndac = try_dac(codec, dacs[0], pin);\r\nif (!dac)\r\ndac = try_dac(codec, get_primary_out(codec, i), pin);\r\nif (dac) {\r\nif (!i)\r\nbadness += bad->shared_primary;\r\nelse if (i == 1)\r\nbadness += bad->shared_surr;\r\nelse\r\nbadness += bad->shared_clfe;\r\n} else if (is_reachable_path(codec, spec->private_dac_nids[0], pin)) {\r\ndac = spec->private_dac_nids[0];\r\nbadness += bad->shared_surr_main;\r\n} else if (!i)\r\nbadness += bad->no_primary_dac;\r\nelse\r\nbadness += bad->no_dac;\r\n}\r\nif (!dac)\r\ncontinue;\r\npath = snd_hda_add_new_path(codec, dac, pin, -spec->mixer_nid);\r\nif (!path && !i && spec->mixer_nid) {\r\npath = snd_hda_add_new_path(codec, dac, pin, 0);\r\n}\r\nif (!path) {\r\ndac = dacs[i] = 0;\r\nbadness += bad->no_dac;\r\n} else {\r\npath->active = true;\r\npath_idx[i] = snd_hda_get_path_idx(codec, path);\r\nbadness += assign_out_path_ctls(codec, path);\r\n}\r\n}\r\nreturn badness;\r\n}\r\nstatic hda_nid_t get_dac_if_single(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nhda_nid_t nid_found = 0;\r\nfor (i = 0; i < spec->num_all_dacs; i++) {\r\nhda_nid_t nid = spec->all_dacs[i];\r\nif (!nid || is_dac_already_used(codec, nid))\r\ncontinue;\r\nif (is_reachable_path(codec, nid, pin)) {\r\nif (nid_found)\r\nreturn 0;\r\nnid_found = nid;\r\n}\r\n}\r\nreturn nid_found;\r\n}\r\nstatic bool can_be_multiio_pin(struct hda_codec *codec,\r\nunsigned int location, hda_nid_t nid)\r\n{\r\nunsigned int defcfg, caps;\r\ndefcfg = snd_hda_codec_get_pincfg(codec, nid);\r\nif (get_defcfg_connect(defcfg) != AC_JACK_PORT_COMPLEX)\r\nreturn false;\r\nif (location && get_defcfg_location(defcfg) != location)\r\nreturn false;\r\ncaps = snd_hda_query_pin_caps(codec, nid);\r\nif (!(caps & AC_PINCAP_OUT))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int count_multiio_pins(struct hda_codec *codec, hda_nid_t reference_pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int defcfg = snd_hda_codec_get_pincfg(codec, reference_pin);\r\nunsigned int location = get_defcfg_location(defcfg);\r\nint type, i;\r\nint num_pins = 0;\r\nfor (type = AUTO_PIN_LINE_IN; type >= AUTO_PIN_MIC; type--) {\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nif (cfg->inputs[i].type != type)\r\ncontinue;\r\nif (can_be_multiio_pin(codec, location,\r\ncfg->inputs[i].pin))\r\nnum_pins++;\r\n}\r\n}\r\nreturn num_pins;\r\n}\r\nstatic int fill_multi_ios(struct hda_codec *codec,\r\nhda_nid_t reference_pin,\r\nbool hardwired)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint type, i, j, num_pins, old_pins;\r\nunsigned int defcfg = snd_hda_codec_get_pincfg(codec, reference_pin);\r\nunsigned int location = get_defcfg_location(defcfg);\r\nint badness = 0;\r\nstruct nid_path *path;\r\nold_pins = spec->multi_ios;\r\nif (old_pins >= 2)\r\ngoto end_fill;\r\nnum_pins = count_multiio_pins(codec, reference_pin);\r\nif (num_pins < 2)\r\ngoto end_fill;\r\nfor (type = AUTO_PIN_LINE_IN; type >= AUTO_PIN_MIC; type--) {\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t nid = cfg->inputs[i].pin;\r\nhda_nid_t dac = 0;\r\nif (cfg->inputs[i].type != type)\r\ncontinue;\r\nif (!can_be_multiio_pin(codec, location, nid))\r\ncontinue;\r\nfor (j = 0; j < spec->multi_ios; j++) {\r\nif (nid == spec->multi_io[j].pin)\r\nbreak;\r\n}\r\nif (j < spec->multi_ios)\r\ncontinue;\r\nif (hardwired)\r\ndac = get_dac_if_single(codec, nid);\r\nelse if (!dac)\r\ndac = look_for_dac(codec, nid, false);\r\nif (!dac) {\r\nbadness++;\r\ncontinue;\r\n}\r\npath = snd_hda_add_new_path(codec, dac, nid,\r\n-spec->mixer_nid);\r\nif (!path) {\r\nbadness++;\r\ncontinue;\r\n}\r\nspec->multi_io[spec->multi_ios].pin = nid;\r\nspec->multi_io[spec->multi_ios].dac = dac;\r\nspec->out_paths[cfg->line_outs + spec->multi_ios] =\r\nsnd_hda_get_path_idx(codec, path);\r\nspec->multi_ios++;\r\nif (spec->multi_ios >= 2)\r\nbreak;\r\n}\r\n}\r\nend_fill:\r\nif (badness)\r\nbadness = BAD_MULTI_IO;\r\nif (old_pins == spec->multi_ios) {\r\nif (hardwired)\r\nreturn 1;\r\nelse\r\nreturn badness;\r\n}\r\nif (!hardwired && spec->multi_ios < 2) {\r\nspec->paths.used -= spec->multi_ios - old_pins;\r\nspec->multi_ios = old_pins;\r\nreturn badness;\r\n}\r\nfor (i = old_pins; i < spec->multi_ios; i++) {\r\npath = snd_hda_get_path_from_idx(codec, spec->out_paths[cfg->line_outs + i]);\r\nbadness += assign_out_path_ctls(codec, path);\r\n}\r\nreturn badness;\r\n}\r\nstatic bool map_singles(struct hda_codec *codec, int outs,\r\nconst hda_nid_t *pins, hda_nid_t *dacs, int *path_idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nbool found = false;\r\nfor (i = 0; i < outs; i++) {\r\nstruct nid_path *path;\r\nhda_nid_t dac;\r\nif (dacs[i])\r\ncontinue;\r\ndac = get_dac_if_single(codec, pins[i]);\r\nif (!dac)\r\ncontinue;\r\npath = snd_hda_add_new_path(codec, dac, pins[i],\r\n-spec->mixer_nid);\r\nif (!path && !i && spec->mixer_nid)\r\npath = snd_hda_add_new_path(codec, dac, pins[i], 0);\r\nif (path) {\r\ndacs[i] = dac;\r\nfound = true;\r\npath->active = true;\r\npath_idx[i] = snd_hda_get_path_idx(codec, path);\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic inline bool has_aamix_out_paths(struct hda_gen_spec *spec)\r\n{\r\nreturn spec->aamix_out_paths[0] || spec->aamix_out_paths[1] ||\r\nspec->aamix_out_paths[2];\r\n}\r\nstatic int check_aamix_out_path(struct hda_codec *codec, int path_idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nhda_nid_t path_dac, dac, pin;\r\npath = snd_hda_get_path_from_idx(codec, path_idx);\r\nif (!path || !path->depth ||\r\nis_nid_contained(path, spec->mixer_nid))\r\nreturn 0;\r\npath_dac = path->path[0];\r\ndac = spec->private_dac_nids[0];\r\npin = path->path[path->depth - 1];\r\npath = snd_hda_add_new_path(codec, dac, pin, spec->mixer_nid);\r\nif (!path) {\r\nif (dac != path_dac)\r\ndac = path_dac;\r\nelse if (spec->multiout.hp_out_nid[0])\r\ndac = spec->multiout.hp_out_nid[0];\r\nelse if (spec->multiout.extra_out_nid[0])\r\ndac = spec->multiout.extra_out_nid[0];\r\nelse\r\ndac = 0;\r\nif (dac)\r\npath = snd_hda_add_new_path(codec, dac, pin,\r\nspec->mixer_nid);\r\n}\r\nif (!path)\r\nreturn 0;\r\npath->active = false;\r\npath->pin_fixed = true;\r\nreturn snd_hda_get_path_idx(codec, path);\r\n}\r\nstatic bool indep_hp_possible(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstruct nid_path *path;\r\nint i, idx;\r\nif (cfg->line_out_type == AUTO_PIN_HP_OUT)\r\nidx = spec->out_paths[0];\r\nelse\r\nidx = spec->hp_paths[0];\r\npath = snd_hda_get_path_from_idx(codec, idx);\r\nif (!path)\r\nreturn false;\r\nif (!spec->mixer_nid || !is_nid_contained(path, spec->mixer_nid))\r\nreturn true;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nif (spec->out_paths[i] == idx)\r\nbreak;\r\npath = snd_hda_get_path_from_idx(codec, spec->out_paths[i]);\r\nif (path && is_nid_contained(path, spec->mixer_nid))\r\nreturn false;\r\n}\r\nfor (i = 0; i < cfg->speaker_outs; i++) {\r\npath = snd_hda_get_path_from_idx(codec, spec->speaker_paths[i]);\r\nif (path && is_nid_contained(path, spec->mixer_nid))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void refill_shared_dacs(struct hda_codec *codec, int num_outs,\r\nhda_nid_t *dacs, int *path_idx)\r\n{\r\nstruct nid_path *path;\r\nint i;\r\nfor (i = 0; i < num_outs; i++) {\r\nif (dacs[i])\r\ncontinue;\r\npath = snd_hda_get_path_from_idx(codec, path_idx[i]);\r\nif (!path)\r\ncontinue;\r\ndacs[i] = path->path[0];\r\n}\r\n}\r\nstatic int fill_and_eval_dacs(struct hda_codec *codec,\r\nbool fill_hardwired,\r\nbool fill_mio_first)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i, err, badness;\r\nspec->multiout.num_dacs = cfg->line_outs;\r\nspec->multiout.dac_nids = spec->private_dac_nids;\r\nmemset(spec->private_dac_nids, 0, sizeof(spec->private_dac_nids));\r\nmemset(spec->multiout.hp_out_nid, 0, sizeof(spec->multiout.hp_out_nid));\r\nmemset(spec->multiout.extra_out_nid, 0, sizeof(spec->multiout.extra_out_nid));\r\nspec->multi_ios = 0;\r\nsnd_array_free(&spec->paths);\r\nmemset(spec->out_paths, 0, sizeof(spec->out_paths));\r\nmemset(spec->hp_paths, 0, sizeof(spec->hp_paths));\r\nmemset(spec->speaker_paths, 0, sizeof(spec->speaker_paths));\r\nmemset(spec->aamix_out_paths, 0, sizeof(spec->aamix_out_paths));\r\nmemset(spec->digout_paths, 0, sizeof(spec->digout_paths));\r\nmemset(spec->input_paths, 0, sizeof(spec->input_paths));\r\nmemset(spec->loopback_paths, 0, sizeof(spec->loopback_paths));\r\nmemset(&spec->digin_path, 0, sizeof(spec->digin_path));\r\nbadness = 0;\r\nif (fill_hardwired) {\r\nbool mapped;\r\ndo {\r\nmapped = map_singles(codec, cfg->line_outs,\r\ncfg->line_out_pins,\r\nspec->private_dac_nids,\r\nspec->out_paths);\r\nmapped |= map_singles(codec, cfg->hp_outs,\r\ncfg->hp_pins,\r\nspec->multiout.hp_out_nid,\r\nspec->hp_paths);\r\nmapped |= map_singles(codec, cfg->speaker_outs,\r\ncfg->speaker_pins,\r\nspec->multiout.extra_out_nid,\r\nspec->speaker_paths);\r\nif (!spec->no_multi_io &&\r\nfill_mio_first && cfg->line_outs == 1 &&\r\ncfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = fill_multi_ios(codec, cfg->line_out_pins[0], true);\r\nif (!err)\r\nmapped = true;\r\n}\r\n} while (mapped);\r\n}\r\nbadness += try_assign_dacs(codec, cfg->line_outs, cfg->line_out_pins,\r\nspec->private_dac_nids, spec->out_paths,\r\nspec->main_out_badness);\r\nif (!spec->no_multi_io && fill_mio_first &&\r\ncfg->line_outs == 1 && cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = fill_multi_ios(codec, cfg->line_out_pins[0], false);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\r\nerr = try_assign_dacs(codec, cfg->hp_outs, cfg->hp_pins,\r\nspec->multiout.hp_out_nid,\r\nspec->hp_paths,\r\nspec->extra_out_badness);\r\nif (err < 0)\r\nreturn err;\r\nbadness += err;\r\n}\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = try_assign_dacs(codec, cfg->speaker_outs,\r\ncfg->speaker_pins,\r\nspec->multiout.extra_out_nid,\r\nspec->speaker_paths,\r\nspec->extra_out_badness);\r\nif (err < 0)\r\nreturn err;\r\nbadness += err;\r\n}\r\nif (!spec->no_multi_io &&\r\ncfg->line_outs == 1 && cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = fill_multi_ios(codec, cfg->line_out_pins[0], false);\r\nif (err < 0)\r\nreturn err;\r\nbadness += err;\r\n}\r\nif (spec->mixer_nid) {\r\nspec->aamix_out_paths[0] =\r\ncheck_aamix_out_path(codec, spec->out_paths[0]);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nspec->aamix_out_paths[1] =\r\ncheck_aamix_out_path(codec, spec->hp_paths[0]);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nspec->aamix_out_paths[2] =\r\ncheck_aamix_out_path(codec, spec->speaker_paths[0]);\r\n}\r\nif (!spec->no_multi_io &&\r\ncfg->hp_outs && cfg->line_out_type == AUTO_PIN_SPEAKER_OUT)\r\nif (count_multiio_pins(codec, cfg->hp_pins[0]) >= 2)\r\nspec->multi_ios = 1;\r\nspec->multiout.num_dacs = 0;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nif (spec->private_dac_nids[i])\r\nspec->multiout.num_dacs++;\r\nelse {\r\nmemmove(spec->private_dac_nids + i,\r\nspec->private_dac_nids + i + 1,\r\nsizeof(hda_nid_t) * (cfg->line_outs - i - 1));\r\nspec->private_dac_nids[cfg->line_outs - 1] = 0;\r\n}\r\n}\r\nspec->ext_channel_count = spec->min_channel_count =\r\nspec->multiout.num_dacs * 2;\r\nif (spec->multi_ios == 2) {\r\nfor (i = 0; i < 2; i++)\r\nspec->private_dac_nids[spec->multiout.num_dacs++] =\r\nspec->multi_io[i].dac;\r\n} else if (spec->multi_ios) {\r\nspec->multi_ios = 0;\r\nbadness += BAD_MULTI_IO;\r\n}\r\nif (spec->indep_hp && !indep_hp_possible(codec))\r\nbadness += BAD_NO_INDEP_HP;\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nrefill_shared_dacs(codec, cfg->hp_outs,\r\nspec->multiout.hp_out_nid,\r\nspec->hp_paths);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nrefill_shared_dacs(codec, cfg->speaker_outs,\r\nspec->multiout.extra_out_nid,\r\nspec->speaker_paths);\r\nreturn badness;\r\n}\r\nstatic inline void print_nid_path_idx(struct hda_codec *codec,\r\nconst char *pfx, int idx)\r\n{\r\nstruct nid_path *path;\r\npath = snd_hda_get_path_from_idx(codec, idx);\r\nif (path)\r\nprint_nid_path(codec, pfx, path);\r\n}\r\nstatic void debug_show_configs(struct hda_codec *codec,\r\nstruct auto_pin_cfg *cfg)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstatic const char * const lo_type[3] = { "LO", "SP", "HP" };\r\nint i;\r\ndebug_badness("multi_outs = %x/%x/%x/%x : %x/%x/%x/%x (type %s)\n",\r\ncfg->line_out_pins[0], cfg->line_out_pins[1],\r\ncfg->line_out_pins[2], cfg->line_out_pins[3],\r\nspec->multiout.dac_nids[0],\r\nspec->multiout.dac_nids[1],\r\nspec->multiout.dac_nids[2],\r\nspec->multiout.dac_nids[3],\r\nlo_type[cfg->line_out_type]);\r\nfor (i = 0; i < cfg->line_outs; i++)\r\nprint_nid_path_idx(codec, " out", spec->out_paths[i]);\r\nif (spec->multi_ios > 0)\r\ndebug_badness("multi_ios(%d) = %x/%x : %x/%x\n",\r\nspec->multi_ios,\r\nspec->multi_io[0].pin, spec->multi_io[1].pin,\r\nspec->multi_io[0].dac, spec->multi_io[1].dac);\r\nfor (i = 0; i < spec->multi_ios; i++)\r\nprint_nid_path_idx(codec, " mio",\r\nspec->out_paths[cfg->line_outs + i]);\r\nif (cfg->hp_outs)\r\ndebug_badness("hp_outs = %x/%x/%x/%x : %x/%x/%x/%x\n",\r\ncfg->hp_pins[0], cfg->hp_pins[1],\r\ncfg->hp_pins[2], cfg->hp_pins[3],\r\nspec->multiout.hp_out_nid[0],\r\nspec->multiout.hp_out_nid[1],\r\nspec->multiout.hp_out_nid[2],\r\nspec->multiout.hp_out_nid[3]);\r\nfor (i = 0; i < cfg->hp_outs; i++)\r\nprint_nid_path_idx(codec, " hp ", spec->hp_paths[i]);\r\nif (cfg->speaker_outs)\r\ndebug_badness("spk_outs = %x/%x/%x/%x : %x/%x/%x/%x\n",\r\ncfg->speaker_pins[0], cfg->speaker_pins[1],\r\ncfg->speaker_pins[2], cfg->speaker_pins[3],\r\nspec->multiout.extra_out_nid[0],\r\nspec->multiout.extra_out_nid[1],\r\nspec->multiout.extra_out_nid[2],\r\nspec->multiout.extra_out_nid[3]);\r\nfor (i = 0; i < cfg->speaker_outs; i++)\r\nprint_nid_path_idx(codec, " spk", spec->speaker_paths[i]);\r\nfor (i = 0; i < 3; i++)\r\nprint_nid_path_idx(codec, " mix", spec->aamix_out_paths[i]);\r\n}\r\nstatic void fill_all_dac_nids(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nspec->num_all_dacs = 0;\r\nmemset(spec->all_dacs, 0, sizeof(spec->all_dacs));\r\nfor_each_hda_codec_node(nid, codec) {\r\nif (get_wcaps_type(get_wcaps(codec, nid)) != AC_WID_AUD_OUT)\r\ncontinue;\r\nif (spec->num_all_dacs >= ARRAY_SIZE(spec->all_dacs)) {\r\ncodec_err(codec, "Too many DACs!\n");\r\nbreak;\r\n}\r\nspec->all_dacs[spec->num_all_dacs++] = nid;\r\n}\r\n}\r\nstatic int parse_output_paths(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstruct auto_pin_cfg *best_cfg;\r\nunsigned int val;\r\nint best_badness = INT_MAX;\r\nint badness;\r\nbool fill_hardwired = true, fill_mio_first = true;\r\nbool best_wired = true, best_mio = true;\r\nbool hp_spk_swapped = false;\r\nbest_cfg = kmalloc(sizeof(*best_cfg), GFP_KERNEL);\r\nif (!best_cfg)\r\nreturn -ENOMEM;\r\n*best_cfg = *cfg;\r\nfor (;;) {\r\nbadness = fill_and_eval_dacs(codec, fill_hardwired,\r\nfill_mio_first);\r\nif (badness < 0) {\r\nkfree(best_cfg);\r\nreturn badness;\r\n}\r\ndebug_badness("==> lo_type=%d, wired=%d, mio=%d, badness=0x%x\n",\r\ncfg->line_out_type, fill_hardwired, fill_mio_first,\r\nbadness);\r\ndebug_show_configs(codec, cfg);\r\nif (badness < best_badness) {\r\nbest_badness = badness;\r\n*best_cfg = *cfg;\r\nbest_wired = fill_hardwired;\r\nbest_mio = fill_mio_first;\r\n}\r\nif (!badness)\r\nbreak;\r\nfill_mio_first = !fill_mio_first;\r\nif (!fill_mio_first)\r\ncontinue;\r\nfill_hardwired = !fill_hardwired;\r\nif (!fill_hardwired)\r\ncontinue;\r\nif (hp_spk_swapped)\r\nbreak;\r\nhp_spk_swapped = true;\r\nif (cfg->speaker_outs > 0 &&\r\ncfg->line_out_type == AUTO_PIN_HP_OUT) {\r\ncfg->hp_outs = cfg->line_outs;\r\nmemcpy(cfg->hp_pins, cfg->line_out_pins,\r\nsizeof(cfg->hp_pins));\r\ncfg->line_outs = cfg->speaker_outs;\r\nmemcpy(cfg->line_out_pins, cfg->speaker_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->speaker_outs = 0;\r\nmemset(cfg->speaker_pins, 0, sizeof(cfg->speaker_pins));\r\ncfg->line_out_type = AUTO_PIN_SPEAKER_OUT;\r\nfill_hardwired = true;\r\ncontinue;\r\n}\r\nif (cfg->hp_outs > 0 &&\r\ncfg->line_out_type == AUTO_PIN_SPEAKER_OUT) {\r\ncfg->speaker_outs = cfg->line_outs;\r\nmemcpy(cfg->speaker_pins, cfg->line_out_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->line_outs = cfg->hp_outs;\r\nmemcpy(cfg->line_out_pins, cfg->hp_pins,\r\nsizeof(cfg->hp_pins));\r\ncfg->hp_outs = 0;\r\nmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\r\ncfg->line_out_type = AUTO_PIN_HP_OUT;\r\nfill_hardwired = true;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (badness) {\r\ndebug_badness("==> restoring best_cfg\n");\r\n*cfg = *best_cfg;\r\nfill_and_eval_dacs(codec, best_wired, best_mio);\r\n}\r\ndebug_badness("==> Best config: lo_type=%d, wired=%d, mio=%d\n",\r\ncfg->line_out_type, best_wired, best_mio);\r\ndebug_show_configs(codec, cfg);\r\nif (cfg->line_out_pins[0]) {\r\nstruct nid_path *path;\r\npath = snd_hda_get_path_from_idx(codec, spec->out_paths[0]);\r\nif (path)\r\nspec->vmaster_nid = look_for_out_vol_nid(codec, path);\r\nif (spec->vmaster_nid) {\r\nsnd_hda_set_vmaster_tlv(codec, spec->vmaster_nid,\r\nHDA_OUTPUT, spec->vmaster_tlv);\r\nif (spec->dac_min_mute)\r\nspec->vmaster_tlv[3] |= TLV_DB_SCALE_MUTE;\r\n}\r\n}\r\nif (spec->prefer_hp_amp || cfg->line_out_type == AUTO_PIN_HP_OUT)\r\nval = PIN_HP;\r\nelse\r\nval = PIN_OUT;\r\nset_pin_targets(codec, cfg->line_outs, cfg->line_out_pins, val);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nset_pin_targets(codec, cfg->hp_outs, cfg->hp_pins, PIN_HP);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nval = spec->prefer_hp_amp ? PIN_HP : PIN_OUT;\r\nset_pin_targets(codec, cfg->speaker_outs,\r\ncfg->speaker_pins, val);\r\n}\r\nif (spec->indep_hp && !indep_hp_possible(codec))\r\nspec->indep_hp = 0;\r\nkfree(best_cfg);\r\nreturn 0;\r\n}\r\nstatic int create_multi_out_ctls(struct hda_codec *codec,\r\nconst struct auto_pin_cfg *cfg)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i, err, noutputs;\r\nnoutputs = cfg->line_outs;\r\nif (spec->multi_ios > 0 && cfg->line_outs < 3)\r\nnoutputs += spec->multi_ios;\r\nfor (i = 0; i < noutputs; i++) {\r\nconst char *name;\r\nint index;\r\nstruct nid_path *path;\r\npath = snd_hda_get_path_from_idx(codec, spec->out_paths[i]);\r\nif (!path)\r\ncontinue;\r\nname = get_line_out_pfx(codec, i, &index, NID_PATH_VOL_CTL);\r\nif (!name || !strcmp(name, "CLFE")) {\r\nerr = add_vol_ctl(codec, "Center", 0, 1, path);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_vol_ctl(codec, "LFE", 0, 2, path);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = add_stereo_vol(codec, name, index, path);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nname = get_line_out_pfx(codec, i, &index, NID_PATH_MUTE_CTL);\r\nif (!name || !strcmp(name, "CLFE")) {\r\nerr = add_sw_ctl(codec, "Center", 0, 1, path);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_sw_ctl(codec, "LFE", 0, 2, path);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = add_stereo_sw(codec, name, index, path);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_extra_out(struct hda_codec *codec, int path_idx,\r\nconst char *pfx, int cidx)\r\n{\r\nstruct nid_path *path;\r\nint err;\r\npath = snd_hda_get_path_from_idx(codec, path_idx);\r\nif (!path)\r\nreturn 0;\r\nerr = add_stereo_vol(codec, pfx, cidx, path);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_stereo_sw(codec, pfx, cidx, path);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int create_extra_outs(struct hda_codec *codec, int num_pins,\r\nconst int *paths, const char *pfx)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nconst char *name;\r\nchar tmp[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint err, idx = 0;\r\nif (num_pins == 2 && i == 1 && !strcmp(pfx, "Speaker"))\r\nname = "Bass Speaker";\r\nelse if (num_pins >= 3) {\r\nsnprintf(tmp, sizeof(tmp), "%s %s",\r\npfx, channel_name[i]);\r\nname = tmp;\r\n} else {\r\nname = pfx;\r\nidx = i;\r\n}\r\nerr = create_extra_out(codec, paths[i], name, idx);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_hp_out_ctls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn create_extra_outs(codec, spec->autocfg.hp_outs,\r\nspec->hp_paths,\r\n"Headphone");\r\n}\r\nstatic int create_speaker_out_ctls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn create_extra_outs(codec, spec->autocfg.speaker_outs,\r\nspec->speaker_paths,\r\n"Speaker");\r\n}\r\nstatic int indep_hp_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\r\n}\r\nstatic int indep_hp_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->indep_hp_enabled;\r\nreturn 0;\r\n}\r\nstatic int indep_hp_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nunsigned int select = ucontrol->value.enumerated.item[0];\r\nint ret = 0;\r\nmutex_lock(&spec->pcm_mutex);\r\nif (spec->active_streams) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (spec->indep_hp_enabled != select) {\r\nhda_nid_t *dacp;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\r\ndacp = &spec->private_dac_nids[0];\r\nelse\r\ndacp = &spec->multiout.hp_out_nid[0];\r\nif (spec->have_aamix_ctl) {\r\nif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\r\nupdate_aamix_paths(codec, spec->aamix_mode,\r\nspec->out_paths[0],\r\nspec->aamix_out_paths[0],\r\nspec->autocfg.line_out_type);\r\nelse\r\nupdate_aamix_paths(codec, spec->aamix_mode,\r\nspec->hp_paths[0],\r\nspec->aamix_out_paths[1],\r\nAUTO_PIN_HP_OUT);\r\n}\r\nspec->indep_hp_enabled = select;\r\nif (spec->indep_hp_enabled)\r\n*dacp = 0;\r\nelse\r\n*dacp = spec->alt_dac_nid;\r\ncall_hp_automute(codec, NULL);\r\nret = 1;\r\n}\r\nunlock:\r\nmutex_unlock(&spec->pcm_mutex);\r\nreturn ret;\r\n}\r\nstatic int create_indep_hp_ctls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t dac;\r\nif (!spec->indep_hp)\r\nreturn 0;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\r\ndac = spec->multiout.dac_nids[0];\r\nelse\r\ndac = spec->multiout.hp_out_nid[0];\r\nif (!dac) {\r\nspec->indep_hp = 0;\r\nreturn 0;\r\n}\r\nspec->indep_hp_enabled = false;\r\nspec->alt_dac_nid = dac;\r\nif (!snd_hda_gen_add_kctl(spec, NULL, &indep_hp_ctl))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ch_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint chs;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = spec->multi_ios + 1;\r\nif (uinfo->value.enumerated.item > spec->multi_ios)\r\nuinfo->value.enumerated.item = spec->multi_ios;\r\nchs = uinfo->value.enumerated.item * 2 + spec->min_channel_count;\r\nsprintf(uinfo->value.enumerated.name, "%dch", chs);\r\nreturn 0;\r\n}\r\nstatic int ch_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] =\r\n(spec->ext_channel_count - spec->min_channel_count) / 2;\r\nreturn 0;\r\n}\r\nstatic inline struct nid_path *\r\nget_multiio_path(struct hda_codec *codec, int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_get_path_from_idx(codec,\r\nspec->out_paths[spec->autocfg.line_outs + idx]);\r\n}\r\nstatic bool aamix_default(struct hda_gen_spec *spec)\r\n{\r\nreturn !spec->have_aamix_ctl || spec->aamix_mode;\r\n}\r\nstatic int set_multi_io(struct hda_codec *codec, int idx, bool output)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t nid = spec->multi_io[idx].pin;\r\nstruct nid_path *path;\r\npath = get_multiio_path(codec, idx);\r\nif (!path)\r\nreturn -EINVAL;\r\nif (path->active == output)\r\nreturn 0;\r\nif (output) {\r\nset_pin_target(codec, nid, PIN_OUT, true);\r\nsnd_hda_activate_path(codec, path, true, aamix_default(spec));\r\nset_pin_eapd(codec, nid, true);\r\n} else {\r\nset_pin_eapd(codec, nid, false);\r\nsnd_hda_activate_path(codec, path, false, aamix_default(spec));\r\nset_pin_target(codec, nid, spec->multi_io[idx].ctl_in, true);\r\npath_power_down_sync(codec, path);\r\n}\r\nupdate_automute_all(codec);\r\nreturn 0;\r\n}\r\nstatic int ch_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i, ch;\r\nch = ucontrol->value.enumerated.item[0];\r\nif (ch < 0 || ch > spec->multi_ios)\r\nreturn -EINVAL;\r\nif (ch == (spec->ext_channel_count - spec->min_channel_count) / 2)\r\nreturn 0;\r\nspec->ext_channel_count = ch * 2 + spec->min_channel_count;\r\nfor (i = 0; i < spec->multi_ios; i++)\r\nset_multi_io(codec, i, i < ch);\r\nspec->multiout.max_channels = max(spec->ext_channel_count,\r\nspec->const_channel_count);\r\nif (spec->need_dac_fix)\r\nspec->multiout.num_dacs = spec->multiout.max_channels / 2;\r\nreturn 1;\r\n}\r\nstatic int create_multi_channel_mode(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->multi_ios > 0) {\r\nif (!snd_hda_gen_add_kctl(spec, NULL, &channel_mode_enum))\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int loopback_mixing_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->aamix_mode;\r\nreturn 0;\r\n}\r\nstatic void update_aamix_paths(struct hda_codec *codec, bool do_mix,\r\nint nomix_path_idx, int mix_path_idx,\r\nint out_type)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *nomix_path, *mix_path;\r\nnomix_path = snd_hda_get_path_from_idx(codec, nomix_path_idx);\r\nmix_path = snd_hda_get_path_from_idx(codec, mix_path_idx);\r\nif (!nomix_path || !mix_path)\r\nreturn;\r\nif (out_type == AUTO_PIN_HP_OUT && spec->indep_hp_enabled &&\r\nmix_path->path[0] != spec->alt_dac_nid)\r\ndo_mix = false;\r\nif (do_mix) {\r\nsnd_hda_activate_path(codec, nomix_path, false, true);\r\nsnd_hda_activate_path(codec, mix_path, true, true);\r\npath_power_down_sync(codec, nomix_path);\r\n} else {\r\nsnd_hda_activate_path(codec, mix_path, false, false);\r\nsnd_hda_activate_path(codec, nomix_path, true, false);\r\npath_power_down_sync(codec, mix_path);\r\n}\r\n}\r\nstatic void update_output_paths(struct hda_codec *codec, int num_outs,\r\nconst int *paths)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nint i;\r\nfor (i = 0; i < num_outs; i++) {\r\npath = snd_hda_get_path_from_idx(codec, paths[i]);\r\nif (path)\r\nsnd_hda_activate_path(codec, path, path->active,\r\nspec->aamix_mode);\r\n}\r\n}\r\nstatic int loopback_mixing_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int val = ucontrol->value.enumerated.item[0];\r\nif (val == spec->aamix_mode)\r\nreturn 0;\r\nspec->aamix_mode = val;\r\nif (has_aamix_out_paths(spec)) {\r\nupdate_aamix_paths(codec, val, spec->out_paths[0],\r\nspec->aamix_out_paths[0],\r\ncfg->line_out_type);\r\nupdate_aamix_paths(codec, val, spec->hp_paths[0],\r\nspec->aamix_out_paths[1],\r\nAUTO_PIN_HP_OUT);\r\nupdate_aamix_paths(codec, val, spec->speaker_paths[0],\r\nspec->aamix_out_paths[2],\r\nAUTO_PIN_SPEAKER_OUT);\r\n} else {\r\nupdate_output_paths(codec, cfg->line_outs, spec->out_paths);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nupdate_output_paths(codec, cfg->hp_outs, spec->hp_paths);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nupdate_output_paths(codec, cfg->speaker_outs,\r\nspec->speaker_paths);\r\n}\r\nreturn 1;\r\n}\r\nstatic int create_loopback_mixing_ctl(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (!spec->mixer_nid)\r\nreturn 0;\r\nif (!snd_hda_gen_add_kctl(spec, NULL, &loopback_mixing_enum))\r\nreturn -ENOMEM;\r\nspec->have_aamix_ctl = 1;\r\nreturn 0;\r\n}\r\nstatic void update_hp_mic(struct hda_codec *codec, int adc_mux, bool force)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nbool as_mic;\r\nunsigned int val;\r\nhda_nid_t pin;\r\npin = spec->hp_mic_pin;\r\nas_mic = spec->cur_mux[adc_mux] == spec->hp_mic_mux_idx;\r\nif (!force) {\r\nval = snd_hda_codec_get_pin_target(codec, pin);\r\nif (as_mic) {\r\nif (val & PIN_IN)\r\nreturn;\r\n} else {\r\nif (val & PIN_OUT)\r\nreturn;\r\n}\r\n}\r\nval = snd_hda_get_default_vref(codec, pin);\r\nif (val == AC_PINCTL_VREF_HIZ && spec->shared_mic_vref_pin) {\r\nconst hda_nid_t vref_pin = spec->shared_mic_vref_pin;\r\nunsigned int vref_val = snd_hda_get_default_vref(codec, vref_pin);\r\nif (vref_val != AC_PINCTL_VREF_HIZ)\r\nsnd_hda_set_pin_ctl_cache(codec, vref_pin,\r\nPIN_IN | (as_mic ? vref_val : 0));\r\n}\r\nif (!spec->hp_mic_jack_modes) {\r\nif (as_mic)\r\nval |= PIN_IN;\r\nelse\r\nval = PIN_HP;\r\nset_pin_target(codec, pin, val, true);\r\ncall_hp_automute(codec, NULL);\r\n}\r\n}\r\nstatic int create_hp_mic(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int defcfg;\r\nhda_nid_t nid;\r\nif (!spec->hp_mic) {\r\nif (spec->suppress_hp_mic_detect)\r\nreturn 0;\r\nif (cfg->num_inputs > 1)\r\nreturn 0;\r\nelse if (cfg->num_inputs == 1) {\r\ndefcfg = snd_hda_codec_get_pincfg(codec, cfg->inputs[0].pin);\r\nif (snd_hda_get_input_pin_attr(defcfg) != INPUT_PIN_ATTR_INT)\r\nreturn 0;\r\n}\r\n}\r\nspec->hp_mic = 0;\r\nif (cfg->num_inputs >= AUTO_CFG_MAX_INS)\r\nreturn 0;\r\nnid = 0;\r\nif (cfg->line_out_type == AUTO_PIN_HP_OUT && cfg->line_outs > 0)\r\nnid = cfg->line_out_pins[0];\r\nelse if (cfg->hp_outs > 0)\r\nnid = cfg->hp_pins[0];\r\nif (!nid)\r\nreturn 0;\r\nif (!(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_IN))\r\nreturn 0;\r\ncfg->inputs[cfg->num_inputs].pin = nid;\r\ncfg->inputs[cfg->num_inputs].type = AUTO_PIN_MIC;\r\ncfg->inputs[cfg->num_inputs].is_headphone_mic = 1;\r\ncfg->num_inputs++;\r\nspec->hp_mic = 1;\r\nspec->hp_mic_pin = nid;\r\nspec->suppress_auto_mic = 1;\r\ncodec_dbg(codec, "Enable shared I/O jack on NID 0x%x\n", nid);\r\nreturn 0;\r\n}\r\nstatic int out_jack_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_enum_helper_info(kcontrol, uinfo, 2, out_jack_texts);\r\n}\r\nstatic int out_jack_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nif (snd_hda_codec_get_pin_target(codec, nid) == PIN_HP)\r\nucontrol->value.enumerated.item[0] = 1;\r\nelse\r\nucontrol->value.enumerated.item[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int out_jack_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int val;\r\nval = ucontrol->value.enumerated.item[0] ? PIN_HP : PIN_OUT;\r\nif (snd_hda_codec_get_pin_target(codec, nid) == val)\r\nreturn 0;\r\nsnd_hda_set_pin_ctl_cache(codec, nid, val);\r\nreturn 1;\r\n}\r\nstatic bool find_kctl_name(struct hda_codec *codec, const char *name, int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->kctls.used; i++) {\r\nstruct snd_kcontrol_new *kctl = snd_array_elem(&spec->kctls, i);\r\nif (!strcmp(kctl->name, name) && kctl->index == idx)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void get_jack_mode_name(struct hda_codec *codec, hda_nid_t pin,\r\nchar *name, size_t name_len)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint idx = 0;\r\nsnd_hda_get_pin_label(codec, pin, &spec->autocfg, name, name_len, &idx);\r\nstrlcat(name, " Jack Mode", name_len);\r\nfor (; find_kctl_name(codec, name, idx); idx++)\r\n;\r\n}\r\nstatic int get_out_jack_num_items(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->add_jack_modes) {\r\nunsigned int pincap = snd_hda_query_pin_caps(codec, pin);\r\nif ((pincap & AC_PINCAP_OUT) && (pincap & AC_PINCAP_HP_DRV))\r\nreturn 2;\r\n}\r\nreturn 1;\r\n}\r\nstatic int create_out_jack_modes(struct hda_codec *codec, int num_pins,\r\nhda_nid_t *pins)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nhda_nid_t pin = pins[i];\r\nif (pin == spec->hp_mic_pin)\r\ncontinue;\r\nif (get_out_jack_num_items(codec, pin) > 1) {\r\nstruct snd_kcontrol_new *knew;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nget_jack_mode_name(codec, pin, name, sizeof(name));\r\nknew = snd_hda_gen_add_kctl(spec, name,\r\n&out_jack_mode_enum);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->private_value = pin;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int get_vref_caps(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nunsigned int pincap;\r\npincap = snd_hda_query_pin_caps(codec, pin);\r\npincap = (pincap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\npincap &= ~(AC_PINCAP_VREF_GRD | AC_PINCAP_VREF_100);\r\nreturn pincap;\r\n}\r\nstatic int get_vref_idx(unsigned int vref_caps, unsigned int item_idx)\r\n{\r\nunsigned int i, n = 0;\r\nfor (i = 0; i < NUM_VREFS; i++) {\r\nif (vref_caps & (1 << i)) {\r\nif (n == item_idx)\r\nreturn i;\r\nn++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cvt_from_vref_idx(unsigned int vref_caps, unsigned int idx)\r\n{\r\nunsigned int i, n = 0;\r\nfor (i = 0; i < NUM_VREFS; i++) {\r\nif (i == idx)\r\nreturn n;\r\nif (vref_caps & (1 << i))\r\nn++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int in_jack_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\nsnd_hda_enum_helper_info(kcontrol, uinfo, hweight32(vref_caps),\r\nvref_texts);\r\nstrcpy(uinfo->value.enumerated.name,\r\nvref_texts[get_vref_idx(vref_caps, uinfo->value.enumerated.item)]);\r\nreturn 0;\r\n}\r\nstatic int in_jack_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\nunsigned int idx;\r\nidx = snd_hda_codec_get_pin_target(codec, nid) & AC_PINCTL_VREFEN;\r\nucontrol->value.enumerated.item[0] = cvt_from_vref_idx(vref_caps, idx);\r\nreturn 0;\r\n}\r\nstatic int in_jack_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\nunsigned int val, idx;\r\nval = snd_hda_codec_get_pin_target(codec, nid);\r\nidx = cvt_from_vref_idx(vref_caps, val & AC_PINCTL_VREFEN);\r\nif (idx == ucontrol->value.enumerated.item[0])\r\nreturn 0;\r\nval &= ~AC_PINCTL_VREFEN;\r\nval |= get_vref_idx(vref_caps, ucontrol->value.enumerated.item[0]);\r\nsnd_hda_set_pin_ctl_cache(codec, nid, val);\r\nreturn 1;\r\n}\r\nstatic int get_in_jack_num_items(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint nitems = 0;\r\nif (spec->add_jack_modes)\r\nnitems = hweight32(get_vref_caps(codec, pin));\r\nreturn nitems ? nitems : 1;\r\n}\r\nstatic int create_in_jack_mode(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct snd_kcontrol_new *knew;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nunsigned int defcfg;\r\nif (pin == spec->hp_mic_pin)\r\nreturn 0;\r\ndefcfg = snd_hda_codec_get_pincfg(codec, pin);\r\nif (snd_hda_get_input_pin_attr(defcfg) == INPUT_PIN_ATTR_INT)\r\nreturn 0;\r\nif (get_in_jack_num_items(codec, pin) <= 1)\r\nreturn 0;\r\nget_jack_mode_name(codec, pin, name, sizeof(name));\r\nknew = snd_hda_gen_add_kctl(spec, name, &in_jack_mode_enum);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->private_value = pin;\r\nreturn 0;\r\n}\r\nstatic int hp_mic_jack_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nint out_jacks = get_out_jack_num_items(codec, nid);\r\nint in_jacks = get_in_jack_num_items(codec, nid);\r\nconst char *text = NULL;\r\nint idx;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = out_jacks + in_jacks;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nidx = uinfo->value.enumerated.item;\r\nif (idx < out_jacks) {\r\nif (out_jacks > 1)\r\ntext = out_jack_texts[idx];\r\nelse\r\ntext = "Headphone Out";\r\n} else {\r\nidx -= out_jacks;\r\nif (in_jacks > 1) {\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\ntext = vref_texts[get_vref_idx(vref_caps, idx)];\r\n} else\r\ntext = "Mic In";\r\n}\r\nstrcpy(uinfo->value.enumerated.name, text);\r\nreturn 0;\r\n}\r\nstatic int get_cur_hp_mic_jack_mode(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nint out_jacks = get_out_jack_num_items(codec, nid);\r\nint in_jacks = get_in_jack_num_items(codec, nid);\r\nunsigned int val = snd_hda_codec_get_pin_target(codec, nid);\r\nint idx = 0;\r\nif (val & PIN_OUT) {\r\nif (out_jacks > 1 && val == PIN_HP)\r\nidx = 1;\r\n} else if (val & PIN_IN) {\r\nidx = out_jacks;\r\nif (in_jacks > 1) {\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\nval &= AC_PINCTL_VREFEN;\r\nidx += cvt_from_vref_idx(vref_caps, val);\r\n}\r\n}\r\nreturn idx;\r\n}\r\nstatic int hp_mic_jack_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nucontrol->value.enumerated.item[0] =\r\nget_cur_hp_mic_jack_mode(codec, nid);\r\nreturn 0;\r\n}\r\nstatic int hp_mic_jack_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nint out_jacks = get_out_jack_num_items(codec, nid);\r\nint in_jacks = get_in_jack_num_items(codec, nid);\r\nunsigned int val, oldval, idx;\r\noldval = get_cur_hp_mic_jack_mode(codec, nid);\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (oldval == idx)\r\nreturn 0;\r\nif (idx < out_jacks) {\r\nif (out_jacks > 1)\r\nval = idx ? PIN_HP : PIN_OUT;\r\nelse\r\nval = PIN_HP;\r\n} else {\r\nidx -= out_jacks;\r\nif (in_jacks > 1) {\r\nunsigned int vref_caps = get_vref_caps(codec, nid);\r\nval = snd_hda_codec_get_pin_target(codec, nid);\r\nval &= ~(AC_PINCTL_VREFEN | PIN_HP);\r\nval |= get_vref_idx(vref_caps, idx) | PIN_IN;\r\n} else\r\nval = snd_hda_get_default_vref(codec, nid) | PIN_IN;\r\n}\r\nsnd_hda_set_pin_ctl_cache(codec, nid, val);\r\ncall_hp_automute(codec, NULL);\r\nreturn 1;\r\n}\r\nstatic int create_hp_mic_jack_mode(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct snd_kcontrol_new *knew;\r\nknew = snd_hda_gen_add_kctl(spec, "Headphone Mic Jack Mode",\r\n&hp_mic_jack_mode_enum);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->private_value = pin;\r\nspec->hp_mic_jack_modes = 1;\r\nreturn 0;\r\n}\r\nstatic int add_loopback_list(struct hda_gen_spec *spec, hda_nid_t mix, int idx)\r\n{\r\nstruct hda_amp_list *list;\r\nlist = snd_array_new(&spec->loopback_list);\r\nif (!list)\r\nreturn -ENOMEM;\r\nlist->nid = mix;\r\nlist->dir = HDA_INPUT;\r\nlist->idx = idx;\r\nspec->loopback.amplist = spec->loopback_list.list;\r\nreturn 0;\r\n}\r\nstatic bool look_for_mix_leaf_ctls(struct hda_codec *codec, hda_nid_t mix_nid,\r\nhda_nid_t pin, unsigned int *mix_val,\r\nunsigned int *mute_val)\r\n{\r\nint idx, num_conns;\r\nconst hda_nid_t *list;\r\nhda_nid_t nid;\r\nidx = snd_hda_get_conn_index(codec, mix_nid, pin, true);\r\nif (idx < 0)\r\nreturn false;\r\n*mix_val = *mute_val = 0;\r\nif (nid_has_volume(codec, mix_nid, HDA_INPUT))\r\n*mix_val = HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT);\r\nif (nid_has_mute(codec, mix_nid, HDA_INPUT))\r\n*mute_val = HDA_COMPOSE_AMP_VAL(mix_nid, 3, idx, HDA_INPUT);\r\nif (*mix_val && *mute_val)\r\nreturn true;\r\nnum_conns = snd_hda_get_conn_list(codec, mix_nid, &list);\r\nif (num_conns < idx)\r\nreturn false;\r\nnid = list[idx];\r\nif (!*mix_val && nid_has_volume(codec, nid, HDA_OUTPUT) &&\r\n!is_ctl_associated(codec, nid, HDA_OUTPUT, 0, NID_PATH_VOL_CTL))\r\n*mix_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nif (!*mute_val && nid_has_mute(codec, nid, HDA_OUTPUT) &&\r\n!is_ctl_associated(codec, nid, HDA_OUTPUT, 0, NID_PATH_MUTE_CTL))\r\n*mute_val = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nreturn *mix_val || *mute_val;\r\n}\r\nstatic int new_analog_input(struct hda_codec *codec, int input_idx,\r\nhda_nid_t pin, const char *ctlname, int ctlidx,\r\nhda_nid_t mix_nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nunsigned int mix_val, mute_val;\r\nint err, idx;\r\nif (!look_for_mix_leaf_ctls(codec, mix_nid, pin, &mix_val, &mute_val))\r\nreturn 0;\r\npath = snd_hda_add_new_path(codec, pin, mix_nid, 0);\r\nif (!path)\r\nreturn -EINVAL;\r\nprint_nid_path(codec, "loopback", path);\r\nspec->loopback_paths[input_idx] = snd_hda_get_path_idx(codec, path);\r\nidx = path->idx[path->depth - 1];\r\nif (mix_val) {\r\nerr = __add_pb_vol_ctrl(spec, HDA_CTL_WIDGET_VOL, ctlname, ctlidx, mix_val);\r\nif (err < 0)\r\nreturn err;\r\npath->ctls[NID_PATH_VOL_CTL] = mix_val;\r\n}\r\nif (mute_val) {\r\nerr = __add_pb_sw_ctrl(spec, HDA_CTL_WIDGET_MUTE, ctlname, ctlidx, mute_val);\r\nif (err < 0)\r\nreturn err;\r\npath->ctls[NID_PATH_MUTE_CTL] = mute_val;\r\n}\r\npath->active = true;\r\npath->stream_enabled = true;\r\nerr = add_loopback_list(spec, mix_nid, idx);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->mixer_nid != spec->mixer_merge_nid &&\r\n!spec->loopback_merge_path) {\r\npath = snd_hda_add_new_path(codec, spec->mixer_nid,\r\nspec->mixer_merge_nid, 0);\r\nif (path) {\r\nprint_nid_path(codec, "loopback-merge", path);\r\npath->active = true;\r\npath->pin_fixed = true;\r\npath->stream_enabled = true;\r\nspec->loopback_merge_path =\r\nsnd_hda_get_path_idx(codec, path);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_input_pin(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int pincap = snd_hda_query_pin_caps(codec, nid);\r\nreturn (pincap & AC_PINCAP_IN) != 0;\r\n}\r\nstatic int fill_adc_nids(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nhda_nid_t *adc_nids = spec->adc_nids;\r\nint max_nums = ARRAY_SIZE(spec->adc_nids);\r\nint nums = 0;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int caps = get_wcaps(codec, nid);\r\nint type = get_wcaps_type(caps);\r\nif (type != AC_WID_AUD_IN || (caps & AC_WCAP_DIGITAL))\r\ncontinue;\r\nadc_nids[nums] = nid;\r\nif (++nums >= max_nums)\r\nbreak;\r\n}\r\nspec->num_adc_nids = nums;\r\nspec->num_all_adcs = nums;\r\nmemcpy(spec->all_adcs, spec->adc_nids, nums * sizeof(hda_nid_t));\r\nreturn nums;\r\n}\r\nstatic int check_dyn_adc_switch(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nunsigned int ok_bits;\r\nint i, n, nums;\r\nnums = 0;\r\nok_bits = 0;\r\nfor (n = 0; n < spec->num_adc_nids; n++) {\r\nfor (i = 0; i < imux->num_items; i++) {\r\nif (!spec->input_paths[i][n])\r\nbreak;\r\n}\r\nif (i >= imux->num_items) {\r\nok_bits |= (1 << n);\r\nnums++;\r\n}\r\n}\r\nif (!ok_bits) {\r\nfor (i = 0; i < imux->num_items; i++) {\r\nfor (n = 0; n < spec->num_adc_nids; n++) {\r\nif (spec->input_paths[i][n]) {\r\nspec->dyn_adc_idx[i] = n;\r\nbreak;\r\n}\r\n}\r\n}\r\ncodec_dbg(codec, "enabling ADC switching\n");\r\nspec->dyn_adc_switch = 1;\r\n} else if (nums != spec->num_adc_nids) {\r\nnums = 0;\r\nfor (n = 0; n < spec->num_adc_nids; n++) {\r\nif (!(ok_bits & (1 << n)))\r\ncontinue;\r\nif (n != nums) {\r\nspec->adc_nids[nums] = spec->adc_nids[n];\r\nfor (i = 0; i < imux->num_items; i++) {\r\ninvalidate_nid_path(codec,\r\nspec->input_paths[i][nums]);\r\nspec->input_paths[i][nums] =\r\nspec->input_paths[i][n];\r\n}\r\n}\r\nnums++;\r\n}\r\nspec->num_adc_nids = nums;\r\n}\r\nif (imux->num_items == 1 ||\r\n(imux->num_items == 2 && spec->hp_mic)) {\r\ncodec_dbg(codec, "reducing to a single ADC\n");\r\nspec->num_adc_nids = 1;\r\n}\r\nif (!spec->dyn_adc_switch && spec->multi_cap_vol)\r\nspec->num_adc_nids = 1;\r\nreturn 0;\r\n}\r\nstatic int parse_capture_source(struct hda_codec *codec, hda_nid_t pin,\r\nint cfg_idx, int num_adcs,\r\nconst char *label, int anchor)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nint imux_idx = imux->num_items;\r\nbool imux_added = false;\r\nint c;\r\nfor (c = 0; c < num_adcs; c++) {\r\nstruct nid_path *path;\r\nhda_nid_t adc = spec->adc_nids[c];\r\nif (!is_reachable_path(codec, pin, adc))\r\ncontinue;\r\npath = snd_hda_add_new_path(codec, pin, adc, anchor);\r\nif (!path)\r\ncontinue;\r\nprint_nid_path(codec, "input", path);\r\nspec->input_paths[imux_idx][c] =\r\nsnd_hda_get_path_idx(codec, path);\r\nif (!imux_added) {\r\nif (spec->hp_mic_pin == pin)\r\nspec->hp_mic_mux_idx = imux->num_items;\r\nspec->imux_pins[imux->num_items] = pin;\r\nsnd_hda_add_imux_item(codec, imux, label, cfg_idx, NULL);\r\nimux_added = true;\r\nif (spec->dyn_adc_switch)\r\nspec->dyn_adc_idx[imux_idx] = c;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_input_pin_labels(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t pin = cfg->inputs[i].pin;\r\nconst char *label;\r\nint j, idx;\r\nif (!is_input_pin(codec, pin))\r\ncontinue;\r\nlabel = hda_get_autocfg_input_label(codec, cfg, i);\r\nidx = 0;\r\nfor (j = i - 1; j >= 0; j--) {\r\nif (spec->input_labels[j] &&\r\n!strcmp(spec->input_labels[j], label)) {\r\nidx = spec->input_label_idxs[j] + 1;\r\nbreak;\r\n}\r\n}\r\nspec->input_labels[i] = label;\r\nspec->input_label_idxs[i] = idx;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_input_ctls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t mixer = spec->mixer_nid;\r\nint num_adcs;\r\nint i, err;\r\nunsigned int val;\r\nnum_adcs = fill_adc_nids(codec);\r\nif (num_adcs < 0)\r\nreturn 0;\r\nerr = fill_input_pin_labels(codec);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t pin;\r\npin = cfg->inputs[i].pin;\r\nif (!is_input_pin(codec, pin))\r\ncontinue;\r\nval = PIN_IN;\r\nif (cfg->inputs[i].type == AUTO_PIN_MIC)\r\nval |= snd_hda_get_default_vref(codec, pin);\r\nif (pin != spec->hp_mic_pin &&\r\n!snd_hda_codec_get_pin_target(codec, pin))\r\nset_pin_target(codec, pin, val, false);\r\nif (mixer) {\r\nif (is_reachable_path(codec, pin, mixer)) {\r\nerr = new_analog_input(codec, i, pin,\r\nspec->input_labels[i],\r\nspec->input_label_idxs[i],\r\nmixer);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nerr = parse_capture_source(codec, pin, i, num_adcs,\r\nspec->input_labels[i], -mixer);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->add_jack_modes) {\r\nerr = create_in_jack_mode(codec, pin);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (mixer && spec->add_stereo_mix_input == HDA_HINT_STEREO_MIX_ENABLE) {\r\nerr = parse_capture_source(codec, mixer, CFG_IDX_MIX, num_adcs,\r\n"Stereo Mix", 0);\r\nif (err < 0)\r\nreturn err;\r\nelse\r\nspec->suppress_auto_mic = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct nid_path *get_input_path(struct hda_codec *codec, int adc_idx, int imux_idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (imux_idx < 0 || imux_idx >= HDA_MAX_NUM_INPUTS) {\r\nsnd_BUG();\r\nreturn NULL;\r\n}\r\nif (spec->dyn_adc_switch)\r\nadc_idx = spec->dyn_adc_idx[imux_idx];\r\nif (adc_idx < 0 || adc_idx >= AUTO_CFG_MAX_INS) {\r\nsnd_BUG();\r\nreturn NULL;\r\n}\r\nreturn snd_hda_get_path_from_idx(codec, spec->input_paths[imux_idx][adc_idx]);\r\n}\r\nstatic int mux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(&spec->input_mux, uinfo);\r\n}\r\nstatic int mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nucontrol->value.enumerated.item[0] = spec->cur_mux[adc_idx];\r\nreturn 0;\r\n}\r\nstatic int mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int adc_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nreturn mux_select(codec, adc_idx,\r\nucontrol->value.enumerated.item[0]);\r\n}\r\nstatic int cap_put_caller(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nput_call_t func, int type)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux;\r\nstruct nid_path *path;\r\nint i, adc_idx, err = 0;\r\nimux = &spec->input_mux;\r\nadc_idx = kcontrol->id.index;\r\nmutex_lock(&codec->control_mutex);\r\nfor (i = 0; i < imux->num_items; i++) {\r\npath = get_input_path(codec, adc_idx, i);\r\nif (!path || !path->ctls[type])\r\ncontinue;\r\nkcontrol->private_value = path->ctls[type];\r\nerr = func(kcontrol, ucontrol);\r\nif (err < 0)\r\nbreak;\r\n}\r\nmutex_unlock(&codec->control_mutex);\r\nif (err >= 0 && spec->cap_sync_hook)\r\nspec->cap_sync_hook(codec, kcontrol, ucontrol);\r\nreturn err;\r\n}\r\nstatic int cap_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nreturn cap_put_caller(kcontrol, ucontrol,\r\nsnd_hda_mixer_amp_volume_put,\r\nNID_PATH_VOL_CTL);\r\n}\r\nstatic int cap_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nreturn cap_put_caller(kcontrol, ucontrol,\r\nsnd_hda_mixer_amp_switch_put,\r\nNID_PATH_MUTE_CTL);\r\n}\r\nstatic int parse_capvol_in_path(struct hda_codec *codec, struct nid_path *path)\r\n{\r\nhda_nid_t nid;\r\nint i, depth;\r\npath->ctls[NID_PATH_VOL_CTL] = path->ctls[NID_PATH_MUTE_CTL] = 0;\r\nfor (depth = 0; depth < 3; depth++) {\r\nif (depth >= path->depth)\r\nreturn -EINVAL;\r\ni = path->depth - depth - 1;\r\nnid = path->path[i];\r\nif (!path->ctls[NID_PATH_VOL_CTL]) {\r\nif (nid_has_volume(codec, nid, HDA_OUTPUT))\r\npath->ctls[NID_PATH_VOL_CTL] =\r\nHDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nelse if (nid_has_volume(codec, nid, HDA_INPUT)) {\r\nint idx = path->idx[i];\r\nif (!depth && codec->single_adc_amp)\r\nidx = 0;\r\npath->ctls[NID_PATH_VOL_CTL] =\r\nHDA_COMPOSE_AMP_VAL(nid, 3, idx, HDA_INPUT);\r\n}\r\n}\r\nif (!path->ctls[NID_PATH_MUTE_CTL]) {\r\nif (nid_has_mute(codec, nid, HDA_OUTPUT))\r\npath->ctls[NID_PATH_MUTE_CTL] =\r\nHDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nelse if (nid_has_mute(codec, nid, HDA_INPUT)) {\r\nint idx = path->idx[i];\r\nif (!depth && codec->single_adc_amp)\r\nidx = 0;\r\npath->ctls[NID_PATH_MUTE_CTL] =\r\nHDA_COMPOSE_AMP_VAL(nid, 3, idx, HDA_INPUT);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic bool is_inv_dmic_pin(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int val;\r\nint i;\r\nif (!spec->inv_dmic_split)\r\nreturn false;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nif (cfg->inputs[i].pin != nid)\r\ncontinue;\r\nif (cfg->inputs[i].type != AUTO_PIN_MIC)\r\nreturn false;\r\nval = snd_hda_codec_get_pincfg(codec, nid);\r\nreturn snd_hda_get_input_pin_attr(val) == INPUT_PIN_ATTR_INT;\r\n}\r\nreturn false;\r\n}\r\nstatic int cap_single_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint ret;\r\nret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nif (spec->cap_sync_hook)\r\nspec->cap_sync_hook(codec, kcontrol, ucontrol);\r\nreturn ret;\r\n}\r\nstatic int add_single_cap_ctl(struct hda_codec *codec, const char *label,\r\nint idx, bool is_switch, unsigned int ctl,\r\nbool inv_dmic)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nchar tmpname[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint type = is_switch ? HDA_CTL_WIDGET_MUTE : HDA_CTL_WIDGET_VOL;\r\nconst char *sfx = is_switch ? "Switch" : "Volume";\r\nunsigned int chs = inv_dmic ? 1 : 3;\r\nstruct snd_kcontrol_new *knew;\r\nif (!ctl)\r\nreturn 0;\r\nif (label)\r\nsnprintf(tmpname, sizeof(tmpname),\r\n"%s Capture %s", label, sfx);\r\nelse\r\nsnprintf(tmpname, sizeof(tmpname),\r\n"Capture %s", sfx);\r\nknew = add_control(spec, type, tmpname, idx,\r\namp_val_replace_channels(ctl, chs));\r\nif (!knew)\r\nreturn -ENOMEM;\r\nif (is_switch)\r\nknew->put = cap_single_sw_put;\r\nif (!inv_dmic)\r\nreturn 0;\r\nif (label)\r\nsnprintf(tmpname, sizeof(tmpname),\r\n"Inverted %s Capture %s", label, sfx);\r\nelse\r\nsnprintf(tmpname, sizeof(tmpname),\r\n"Inverted Capture %s", sfx);\r\nknew = add_control(spec, type, tmpname, idx,\r\namp_val_replace_channels(ctl, 2));\r\nif (!knew)\r\nreturn -ENOMEM;\r\nif (is_switch)\r\nknew->put = cap_single_sw_put;\r\nreturn 0;\r\n}\r\nstatic int create_single_cap_vol_ctl(struct hda_codec *codec, int idx,\r\nunsigned int vol_ctl, unsigned int sw_ctl,\r\nbool inv_dmic)\r\n{\r\nint err;\r\nerr = add_single_cap_ctl(codec, NULL, idx, false, vol_ctl, inv_dmic);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_single_cap_ctl(codec, NULL, idx, true, sw_ctl, inv_dmic);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int create_bind_cap_vol_ctl(struct hda_codec *codec, int idx,\r\nunsigned int vol_ctl, unsigned int sw_ctl)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct snd_kcontrol_new *knew;\r\nif (vol_ctl) {\r\nknew = snd_hda_gen_add_kctl(spec, NULL, &cap_vol_temp);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->index = idx;\r\nknew->private_value = vol_ctl;\r\nknew->subdevice = HDA_SUBDEV_AMP_FLAG;\r\n}\r\nif (sw_ctl) {\r\nknew = snd_hda_gen_add_kctl(spec, NULL, &cap_sw_temp);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->index = idx;\r\nknew->private_value = sw_ctl;\r\nknew->subdevice = HDA_SUBDEV_AMP_FLAG;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int get_first_cap_ctl(struct hda_codec *codec, int idx, int type)\r\n{\r\nstruct nid_path *path;\r\nunsigned int ctl;\r\nint i;\r\npath = get_input_path(codec, 0, idx);\r\nif (!path)\r\nreturn 0;\r\nctl = path->ctls[type];\r\nif (!ctl)\r\nreturn 0;\r\nfor (i = 0; i < idx - 1; i++) {\r\npath = get_input_path(codec, 0, i);\r\nif (path && path->ctls[type] == ctl)\r\nreturn 0;\r\n}\r\nreturn ctl;\r\n}\r\nstatic int create_multi_cap_vol_ctl(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nint i, err, type;\r\nfor (i = 0; i < imux->num_items; i++) {\r\nbool inv_dmic;\r\nint idx;\r\nidx = imux->items[i].index;\r\nif (idx >= spec->autocfg.num_inputs)\r\ncontinue;\r\ninv_dmic = is_inv_dmic_pin(codec, spec->imux_pins[i]);\r\nfor (type = 0; type < 2; type++) {\r\nerr = add_single_cap_ctl(codec,\r\nspec->input_labels[idx],\r\nspec->input_label_idxs[idx],\r\ntype,\r\nget_first_cap_ctl(codec, i, type),\r\ninv_dmic);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_capture_mixers(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nint i, n, nums, err;\r\nif (spec->dyn_adc_switch)\r\nnums = 1;\r\nelse\r\nnums = spec->num_adc_nids;\r\nif (!spec->auto_mic && imux->num_items > 1) {\r\nstruct snd_kcontrol_new *knew;\r\nconst char *name;\r\nname = nums > 1 ? "Input Source" : "Capture Source";\r\nknew = snd_hda_gen_add_kctl(spec, name, &cap_src_temp);\r\nif (!knew)\r\nreturn -ENOMEM;\r\nknew->count = nums;\r\n}\r\nfor (n = 0; n < nums; n++) {\r\nbool multi = false;\r\nbool multi_cap_vol = spec->multi_cap_vol;\r\nbool inv_dmic = false;\r\nint vol, sw;\r\nvol = sw = 0;\r\nfor (i = 0; i < imux->num_items; i++) {\r\nstruct nid_path *path;\r\npath = get_input_path(codec, n, i);\r\nif (!path)\r\ncontinue;\r\nparse_capvol_in_path(codec, path);\r\nif (!vol)\r\nvol = path->ctls[NID_PATH_VOL_CTL];\r\nelse if (vol != path->ctls[NID_PATH_VOL_CTL]) {\r\nmulti = true;\r\nif (!same_amp_caps(codec, vol,\r\npath->ctls[NID_PATH_VOL_CTL], HDA_INPUT))\r\nmulti_cap_vol = true;\r\n}\r\nif (!sw)\r\nsw = path->ctls[NID_PATH_MUTE_CTL];\r\nelse if (sw != path->ctls[NID_PATH_MUTE_CTL]) {\r\nmulti = true;\r\nif (!same_amp_caps(codec, sw,\r\npath->ctls[NID_PATH_MUTE_CTL], HDA_INPUT))\r\nmulti_cap_vol = true;\r\n}\r\nif (is_inv_dmic_pin(codec, spec->imux_pins[i]))\r\ninv_dmic = true;\r\n}\r\nif (!multi)\r\nerr = create_single_cap_vol_ctl(codec, n, vol, sw,\r\ninv_dmic);\r\nelse if (!multi_cap_vol && !inv_dmic)\r\nerr = create_bind_cap_vol_ctl(codec, n, vol, sw);\r\nelse\r\nerr = create_multi_cap_vol_ctl(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool check_boost_vol(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx)\r\n{\r\nunsigned int step;\r\nif (!nid_has_volume(codec, nid, dir) ||\r\nis_ctl_associated(codec, nid, dir, idx, NID_PATH_VOL_CTL) ||\r\nis_ctl_associated(codec, nid, dir, idx, NID_PATH_BOOST_CTL))\r\nreturn false;\r\nstep = (query_amp_caps(codec, nid, dir) & AC_AMPCAP_STEP_SIZE)\r\n>> AC_AMPCAP_STEP_SIZE_SHIFT;\r\nif (step < 0x20)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic unsigned int look_for_boost_amp(struct hda_codec *codec,\r\nstruct nid_path *path)\r\n{\r\nunsigned int val = 0;\r\nhda_nid_t nid;\r\nint depth;\r\nfor (depth = 0; depth < 3; depth++) {\r\nif (depth >= path->depth - 1)\r\nbreak;\r\nnid = path->path[depth];\r\nif (depth && check_boost_vol(codec, nid, HDA_OUTPUT, 0)) {\r\nval = HDA_COMPOSE_AMP_VAL(nid, 3, 0, HDA_OUTPUT);\r\nbreak;\r\n} else if (check_boost_vol(codec, nid, HDA_INPUT,\r\npath->idx[depth])) {\r\nval = HDA_COMPOSE_AMP_VAL(nid, 3, path->idx[depth],\r\nHDA_INPUT);\r\nbreak;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic int parse_mic_boost(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nint i;\r\nif (!spec->num_adc_nids)\r\nreturn 0;\r\nfor (i = 0; i < imux->num_items; i++) {\r\nstruct nid_path *path;\r\nunsigned int val;\r\nint idx;\r\nchar boost_label[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nidx = imux->items[i].index;\r\nif (idx >= imux->num_items)\r\ncontinue;\r\nif (cfg->inputs[idx].type > AUTO_PIN_LINE_IN)\r\ncontinue;\r\npath = get_input_path(codec, 0, i);\r\nif (!path)\r\ncontinue;\r\nval = look_for_boost_amp(codec, path);\r\nif (!val)\r\ncontinue;\r\nsnprintf(boost_label, sizeof(boost_label),\r\n"%s Boost Volume", spec->input_labels[idx]);\r\nif (!add_control(spec, HDA_CTL_WIDGET_VOL, boost_label,\r\nspec->input_label_idxs[idx], val))\r\nreturn -ENOMEM;\r\npath->ctls[NID_PATH_BOOST_CTL] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic void parse_digital(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nint i, nums;\r\nhda_nid_t dig_nid, pin;\r\nnums = 0;\r\nfor (i = 0; i < spec->autocfg.dig_outs; i++) {\r\npin = spec->autocfg.dig_out_pins[i];\r\ndig_nid = look_for_dac(codec, pin, true);\r\nif (!dig_nid)\r\ncontinue;\r\npath = snd_hda_add_new_path(codec, dig_nid, pin, 0);\r\nif (!path)\r\ncontinue;\r\nprint_nid_path(codec, "digout", path);\r\npath->active = true;\r\npath->pin_fixed = true;\r\nspec->digout_paths[i] = snd_hda_get_path_idx(codec, path);\r\nset_pin_target(codec, pin, PIN_OUT, false);\r\nif (!nums) {\r\nspec->multiout.dig_out_nid = dig_nid;\r\nspec->dig_out_type = spec->autocfg.dig_out_type[0];\r\n} else {\r\nspec->multiout.slave_dig_outs = spec->slave_dig_outs;\r\nif (nums >= ARRAY_SIZE(spec->slave_dig_outs) - 1)\r\nbreak;\r\nspec->slave_dig_outs[nums - 1] = dig_nid;\r\n}\r\nnums++;\r\n}\r\nif (spec->autocfg.dig_in_pin) {\r\npin = spec->autocfg.dig_in_pin;\r\nfor_each_hda_codec_node(dig_nid, codec) {\r\nunsigned int wcaps = get_wcaps(codec, dig_nid);\r\nif (get_wcaps_type(wcaps) != AC_WID_AUD_IN)\r\ncontinue;\r\nif (!(wcaps & AC_WCAP_DIGITAL))\r\ncontinue;\r\npath = snd_hda_add_new_path(codec, pin, dig_nid, 0);\r\nif (path) {\r\nprint_nid_path(codec, "digin", path);\r\npath->active = true;\r\npath->pin_fixed = true;\r\nspec->dig_in_nid = dig_nid;\r\nspec->digin_path = snd_hda_get_path_idx(codec, path);\r\nset_pin_target(codec, pin, PIN_IN, false);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int mux_select(struct hda_codec *codec, unsigned int adc_idx,\r\nunsigned int idx)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux;\r\nstruct nid_path *old_path, *path;\r\nimux = &spec->input_mux;\r\nif (!imux->num_items)\r\nreturn 0;\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nif (spec->cur_mux[adc_idx] == idx)\r\nreturn 0;\r\nold_path = get_input_path(codec, adc_idx, spec->cur_mux[adc_idx]);\r\nif (!old_path)\r\nreturn 0;\r\nif (old_path->active)\r\nsnd_hda_activate_path(codec, old_path, false, false);\r\nspec->cur_mux[adc_idx] = idx;\r\nif (spec->hp_mic)\r\nupdate_hp_mic(codec, adc_idx, false);\r\nif (spec->dyn_adc_switch)\r\ndyn_adc_pcm_resetup(codec, idx);\r\npath = get_input_path(codec, adc_idx, idx);\r\nif (!path)\r\nreturn 0;\r\nif (path->active)\r\nreturn 0;\r\nsnd_hda_activate_path(codec, path, true, false);\r\nif (spec->cap_sync_hook)\r\nspec->cap_sync_hook(codec, NULL, NULL);\r\npath_power_down_sync(codec, old_path);\r\nreturn 1;\r\n}\r\nstatic hda_nid_t set_path_power(struct hda_codec *codec, hda_nid_t nid,\r\nint pin_state, int stream_state)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t last, changed = 0;\r\nstruct nid_path *path;\r\nint n;\r\nfor (n = 0; n < spec->paths.used; n++) {\r\npath = snd_array_elem(&spec->paths, n);\r\nif (!path->depth)\r\ncontinue;\r\nif (path->path[0] == nid ||\r\npath->path[path->depth - 1] == nid) {\r\nbool pin_old = path->pin_enabled;\r\nbool stream_old = path->stream_enabled;\r\nif (pin_state >= 0)\r\npath->pin_enabled = pin_state;\r\nif (stream_state >= 0)\r\npath->stream_enabled = stream_state;\r\nif ((!path->pin_fixed && path->pin_enabled != pin_old)\r\n|| path->stream_enabled != stream_old) {\r\nlast = path_power_update(codec, path, true);\r\nif (last)\r\nchanged = last;\r\n}\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic bool detect_pin_state(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nif (!is_jack_detectable(codec, pin))\r\nreturn true;\r\nreturn snd_hda_jack_detect_state(codec, pin) != HDA_JACK_NOT_PRESENT;\r\n}\r\nstatic hda_nid_t set_pin_power_jack(struct hda_codec *codec, hda_nid_t pin,\r\nint power)\r\n{\r\nbool on;\r\nif (!codec->power_save_node)\r\nreturn 0;\r\non = detect_pin_state(codec, pin);\r\nif (power >= 0 && on != power)\r\nreturn 0;\r\nreturn set_path_power(codec, pin, on, -1);\r\n}\r\nstatic void pin_power_callback(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack,\r\nbool on)\r\n{\r\nif (jack && jack->nid)\r\nsync_power_state_change(codec,\r\nset_pin_power_jack(codec, jack->nid, on));\r\n}\r\nstatic void pin_power_up_callback(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\npin_power_callback(codec, jack, true);\r\n}\r\nstatic void pin_power_down_callback(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\npin_power_callback(codec, jack, false);\r\n}\r\nstatic void add_pin_power_ctls(struct hda_codec *codec, int num_pins,\r\nconst hda_nid_t *pins, bool on)\r\n{\r\nint i;\r\nhda_jack_callback_fn cb =\r\non ? pin_power_up_callback : pin_power_down_callback;\r\nfor (i = 0; i < num_pins && pins[i]; i++) {\r\nif (is_jack_detectable(codec, pins[i]))\r\nsnd_hda_jack_detect_enable_callback(codec, pins[i], cb);\r\nelse\r\nset_path_power(codec, pins[i], true, -1);\r\n}\r\n}\r\nstatic void add_all_pin_power_ctls(struct hda_codec *codec, bool on)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nif (!codec->power_save_node)\r\nreturn;\r\nadd_pin_power_ctls(codec, cfg->line_outs, cfg->line_out_pins, on);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nadd_pin_power_ctls(codec, cfg->hp_outs, cfg->hp_pins, on);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nadd_pin_power_ctls(codec, cfg->speaker_outs, cfg->speaker_pins, on);\r\nfor (i = 0; i < cfg->num_inputs; i++)\r\nadd_pin_power_ctls(codec, 1, &cfg->inputs[i].pin, on);\r\n}\r\nstatic void sync_pin_power_ctls(struct hda_codec *codec, int num_pins,\r\nconst hda_nid_t *pins)\r\n{\r\nint i;\r\nfor (i = 0; i < num_pins && pins[i]; i++)\r\nif (is_jack_detectable(codec, pins[i]))\r\nset_pin_power_jack(codec, pins[i], -1);\r\n}\r\nstatic void sync_all_pin_power_ctls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nif (!codec->power_save_node)\r\nreturn;\r\nsync_pin_power_ctls(codec, cfg->line_outs, cfg->line_out_pins);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nsync_pin_power_ctls(codec, cfg->hp_outs, cfg->hp_pins);\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nsync_pin_power_ctls(codec, cfg->speaker_outs, cfg->speaker_pins);\r\nfor (i = 0; i < cfg->num_inputs; i++)\r\nsync_pin_power_ctls(codec, 1, &cfg->inputs[i].pin);\r\n}\r\nstatic int add_fake_paths(struct hda_codec *codec, hda_nid_t nid,\r\nint num_pins, const hda_nid_t *pins)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nif (!pins[i])\r\nbreak;\r\nif (get_nid_path(codec, nid, pins[i], 0))\r\ncontinue;\r\npath = snd_array_new(&spec->paths);\r\nif (!path)\r\nreturn -ENOMEM;\r\nmemset(path, 0, sizeof(*path));\r\npath->depth = 2;\r\npath->path[0] = nid;\r\npath->path[1] = pins[i];\r\npath->active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_fake_beep_paths(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t nid = spec->beep_nid;\r\nint err;\r\nif (!codec->power_save_node || !nid)\r\nreturn 0;\r\nerr = add_fake_paths(codec, nid, cfg->line_outs, cfg->line_out_pins);\r\nif (err < 0)\r\nreturn err;\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\r\nerr = add_fake_paths(codec, nid, cfg->hp_outs, cfg->hp_pins);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = add_fake_paths(codec, nid, cfg->speaker_outs,\r\ncfg->speaker_pins);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void beep_power_hook(struct hda_beep *beep, bool on)\r\n{\r\nset_path_power(beep->codec, beep->nid, -1, on);\r\n}\r\nint snd_hda_gen_fix_pin_power(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct nid_path *path;\r\npath = snd_array_new(&spec->paths);\r\nif (!path)\r\nreturn -ENOMEM;\r\nmemset(path, 0, sizeof(*path));\r\npath->depth = 1;\r\npath->path[0] = pin;\r\npath->active = true;\r\npath->pin_fixed = true;\r\npath->stream_enabled = true;\r\nreturn 0;\r\n}\r\nstatic bool detect_jacks(struct hda_codec *codec, int num_pins, hda_nid_t *pins)\r\n{\r\nint i;\r\nbool present = false;\r\nfor (i = 0; i < num_pins; i++) {\r\nhda_nid_t nid = pins[i];\r\nif (!nid)\r\nbreak;\r\nif (snd_hda_codec_get_pin_target(codec, nid) & AC_PINCTL_IN_EN)\r\ncontinue;\r\nif (snd_hda_jack_detect_state(codec, nid) == HDA_JACK_PRESENT)\r\npresent = true;\r\n}\r\nreturn present;\r\n}\r\nstatic void do_automute(struct hda_codec *codec, int num_pins, hda_nid_t *pins,\r\nint *paths, bool mute)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < num_pins; i++) {\r\nhda_nid_t nid = pins[i];\r\nunsigned int val, oldval;\r\nif (!nid)\r\nbreak;\r\noldval = snd_hda_codec_get_pin_target(codec, nid);\r\nif (oldval & PIN_IN)\r\ncontinue;\r\nif (spec->auto_mute_via_amp) {\r\nstruct nid_path *path;\r\nhda_nid_t mute_nid;\r\npath = snd_hda_get_path_from_idx(codec, paths[i]);\r\nif (!path)\r\ncontinue;\r\nmute_nid = get_amp_nid_(path->ctls[NID_PATH_MUTE_CTL]);\r\nif (!mute_nid)\r\ncontinue;\r\nif (mute)\r\nspec->mute_bits |= (1ULL << mute_nid);\r\nelse\r\nspec->mute_bits &= ~(1ULL << mute_nid);\r\ncontinue;\r\n} else {\r\nif (spec->keep_vref_in_automute)\r\nval = oldval & ~PIN_HP;\r\nelse\r\nval = 0;\r\nif (!mute)\r\nval |= oldval;\r\nupdate_pin_ctl(codec, nid, val);\r\n}\r\nset_pin_eapd(codec, nid, !mute);\r\nif (codec->power_save_node) {\r\nbool on = !mute;\r\nif (on)\r\non = detect_pin_state(codec, nid);\r\nset_path_power(codec, nid, on, -1);\r\n}\r\n}\r\n}\r\nvoid snd_hda_gen_update_outputs(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint *paths;\r\nint on;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_HP_OUT)\r\npaths = spec->out_paths;\r\nelse\r\npaths = spec->hp_paths;\r\ndo_automute(codec, ARRAY_SIZE(spec->autocfg.hp_pins),\r\nspec->autocfg.hp_pins, paths, spec->master_mute);\r\nif (!spec->automute_speaker)\r\non = 0;\r\nelse\r\non = spec->hp_jack_present | spec->line_jack_present;\r\non |= spec->master_mute;\r\nspec->speaker_muted = on;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\r\npaths = spec->out_paths;\r\nelse\r\npaths = spec->speaker_paths;\r\ndo_automute(codec, ARRAY_SIZE(spec->autocfg.speaker_pins),\r\nspec->autocfg.speaker_pins, paths, on);\r\nif (spec->autocfg.line_out_pins[0] == spec->autocfg.hp_pins[0] ||\r\nspec->autocfg.line_out_pins[0] == spec->autocfg.speaker_pins[0])\r\nreturn;\r\nif (!spec->automute_lo)\r\non = 0;\r\nelse\r\non = spec->hp_jack_present;\r\non |= spec->master_mute;\r\nspec->line_out_muted = on;\r\npaths = spec->out_paths;\r\ndo_automute(codec, ARRAY_SIZE(spec->autocfg.line_out_pins),\r\nspec->autocfg.line_out_pins, paths, on);\r\n}\r\nstatic void call_update_outputs(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->automute_hook)\r\nspec->automute_hook(codec);\r\nelse\r\nsnd_hda_gen_update_outputs(codec);\r\nif (spec->auto_mute_via_amp && !codec->bus->shutdown)\r\nsnd_ctl_sync_vmaster(spec->vmaster_mute.sw_kctl, false);\r\n}\r\nvoid snd_hda_gen_hp_automute(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t *pins = spec->autocfg.hp_pins;\r\nint num_pins = ARRAY_SIZE(spec->autocfg.hp_pins);\r\nif (spec->indep_hp_enabled) {\r\npins++;\r\nnum_pins--;\r\n}\r\nspec->hp_jack_present = detect_jacks(codec, num_pins, pins);\r\nif (!spec->detect_hp || (!spec->automute_speaker && !spec->automute_lo))\r\nreturn;\r\ncall_update_outputs(codec);\r\n}\r\nvoid snd_hda_gen_line_automute(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT)\r\nreturn;\r\nif (spec->autocfg.line_out_pins[0] == spec->autocfg.hp_pins[0])\r\nreturn;\r\nspec->line_jack_present =\r\ndetect_jacks(codec, ARRAY_SIZE(spec->autocfg.line_out_pins),\r\nspec->autocfg.line_out_pins);\r\nif (!spec->automute_speaker || !spec->detect_lo)\r\nreturn;\r\ncall_update_outputs(codec);\r\n}\r\nvoid snd_hda_gen_mic_autoswitch(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nif (!spec->auto_mic)\r\nreturn;\r\nfor (i = spec->am_num_entries - 1; i > 0; i--) {\r\nhda_nid_t pin = spec->am_entry[i].pin;\r\nif (snd_hda_codec_get_pin_target(codec, pin) & AC_PINCTL_OUT_EN)\r\ncontinue;\r\nif (snd_hda_jack_detect_state(codec, pin) == HDA_JACK_PRESENT) {\r\nmux_select(codec, 0, spec->am_entry[i].idx);\r\nreturn;\r\n}\r\n}\r\nmux_select(codec, 0, spec->am_entry[0].idx);\r\n}\r\nstatic void call_hp_automute(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->hp_automute_hook)\r\nspec->hp_automute_hook(codec, jack);\r\nelse\r\nsnd_hda_gen_hp_automute(codec, jack);\r\n}\r\nstatic void call_line_automute(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->line_automute_hook)\r\nspec->line_automute_hook(codec, jack);\r\nelse\r\nsnd_hda_gen_line_automute(codec, jack);\r\n}\r\nstatic void call_mic_autoswitch(struct hda_codec *codec,\r\nstruct hda_jack_callback *jack)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->mic_autoswitch_hook)\r\nspec->mic_autoswitch_hook(codec, jack);\r\nelse\r\nsnd_hda_gen_mic_autoswitch(codec, jack);\r\n}\r\nstatic void update_automute_all(struct hda_codec *codec)\r\n{\r\ncall_hp_automute(codec, NULL);\r\ncall_line_automute(codec, NULL);\r\ncall_mic_autoswitch(codec, NULL);\r\n}\r\nstatic int automute_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstatic const char * const texts3[] = {\r\n"Disabled", "Speaker Only", "Line Out+Speaker"\r\n};\r\nif (spec->automute_speaker_possible && spec->automute_lo_possible)\r\nreturn snd_hda_enum_helper_info(kcontrol, uinfo, 3, texts3);\r\nreturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\r\n}\r\nstatic int automute_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nunsigned int val = 0;\r\nif (spec->automute_speaker)\r\nval++;\r\nif (spec->automute_lo)\r\nval++;\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int automute_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_gen_spec *spec = codec->spec;\r\nswitch (ucontrol->value.enumerated.item[0]) {\r\ncase 0:\r\nif (!spec->automute_speaker && !spec->automute_lo)\r\nreturn 0;\r\nspec->automute_speaker = 0;\r\nspec->automute_lo = 0;\r\nbreak;\r\ncase 1:\r\nif (spec->automute_speaker_possible) {\r\nif (!spec->automute_lo && spec->automute_speaker)\r\nreturn 0;\r\nspec->automute_speaker = 1;\r\nspec->automute_lo = 0;\r\n} else if (spec->automute_lo_possible) {\r\nif (spec->automute_lo)\r\nreturn 0;\r\nspec->automute_lo = 1;\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase 2:\r\nif (!spec->automute_lo_possible || !spec->automute_speaker_possible)\r\nreturn -EINVAL;\r\nif (spec->automute_speaker && spec->automute_lo)\r\nreturn 0;\r\nspec->automute_speaker = 1;\r\nspec->automute_lo = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncall_update_outputs(codec);\r\nreturn 1;\r\n}\r\nstatic int add_automute_mode_enum(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (!snd_hda_gen_add_kctl(spec, NULL, &automute_mode_enum))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int check_auto_mute_availability(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint present = 0;\r\nint i, err;\r\nif (spec->suppress_auto_mute)\r\nreturn 0;\r\nif (cfg->hp_pins[0])\r\npresent++;\r\nif (cfg->line_out_pins[0])\r\npresent++;\r\nif (cfg->speaker_pins[0])\r\npresent++;\r\nif (present < 2)\r\nreturn 0;\r\nif (!cfg->speaker_pins[0] &&\r\ncfg->line_out_type == AUTO_PIN_SPEAKER_OUT) {\r\nmemcpy(cfg->speaker_pins, cfg->line_out_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->speaker_outs = cfg->line_outs;\r\n}\r\nif (!cfg->hp_pins[0] &&\r\ncfg->line_out_type == AUTO_PIN_HP_OUT) {\r\nmemcpy(cfg->hp_pins, cfg->line_out_pins,\r\nsizeof(cfg->hp_pins));\r\ncfg->hp_outs = cfg->line_outs;\r\n}\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\nhda_nid_t nid = cfg->hp_pins[i];\r\nif (!is_jack_detectable(codec, nid))\r\ncontinue;\r\ncodec_dbg(codec, "Enable HP auto-muting on NID 0x%x\n", nid);\r\nsnd_hda_jack_detect_enable_callback(codec, nid,\r\ncall_hp_automute);\r\nspec->detect_hp = 1;\r\n}\r\nif (cfg->line_out_type == AUTO_PIN_LINE_OUT && cfg->line_outs) {\r\nif (cfg->speaker_outs)\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nhda_nid_t nid = cfg->line_out_pins[i];\r\nif (!is_jack_detectable(codec, nid))\r\ncontinue;\r\ncodec_dbg(codec, "Enable Line-Out auto-muting on NID 0x%x\n", nid);\r\nsnd_hda_jack_detect_enable_callback(codec, nid,\r\ncall_line_automute);\r\nspec->detect_lo = 1;\r\n}\r\nspec->automute_lo_possible = spec->detect_hp;\r\n}\r\nspec->automute_speaker_possible = cfg->speaker_outs &&\r\n(spec->detect_hp || spec->detect_lo);\r\nspec->automute_lo = spec->automute_lo_possible;\r\nspec->automute_speaker = spec->automute_speaker_possible;\r\nif (spec->automute_speaker_possible || spec->automute_lo_possible) {\r\nerr = add_automute_mode_enum(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool auto_mic_check_imux(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nconst struct hda_input_mux *imux;\r\nint i;\r\nimux = &spec->input_mux;\r\nfor (i = 0; i < spec->am_num_entries; i++) {\r\nspec->am_entry[i].idx =\r\nfind_idx_in_nid_list(spec->am_entry[i].pin,\r\nspec->imux_pins, imux->num_items);\r\nif (spec->am_entry[i].idx < 0)\r\nreturn false;\r\n}\r\nfor (i = 1; i < spec->am_num_entries; i++)\r\nsnd_hda_jack_detect_enable_callback(codec,\r\nspec->am_entry[i].pin,\r\ncall_mic_autoswitch);\r\nreturn true;\r\n}\r\nstatic int compare_attr(const void *ap, const void *bp)\r\n{\r\nconst struct automic_entry *a = ap;\r\nconst struct automic_entry *b = bp;\r\nreturn (int)(a->attr - b->attr);\r\n}\r\nstatic int check_auto_mic_availability(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int types;\r\nint i, num_pins;\r\nif (spec->suppress_auto_mic)\r\nreturn 0;\r\ntypes = 0;\r\nnum_pins = 0;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t nid = cfg->inputs[i].pin;\r\nunsigned int attr;\r\nattr = snd_hda_codec_get_pincfg(codec, nid);\r\nattr = snd_hda_get_input_pin_attr(attr);\r\nif (types & (1 << attr))\r\nreturn 0;\r\nswitch (attr) {\r\ncase INPUT_PIN_ATTR_INT:\r\nif (cfg->inputs[i].type != AUTO_PIN_MIC)\r\nreturn 0;\r\nbreak;\r\ncase INPUT_PIN_ATTR_UNUSED:\r\nreturn 0;\r\ndefault:\r\nif (cfg->inputs[i].type > AUTO_PIN_LINE_IN)\r\nreturn 0;\r\nif (!spec->line_in_auto_switch &&\r\ncfg->inputs[i].type != AUTO_PIN_MIC)\r\nreturn 0;\r\nif (!is_jack_detectable(codec, nid))\r\nreturn 0;\r\nbreak;\r\n}\r\nif (num_pins >= MAX_AUTO_MIC_PINS)\r\nreturn 0;\r\ntypes |= (1 << attr);\r\nspec->am_entry[num_pins].pin = nid;\r\nspec->am_entry[num_pins].attr = attr;\r\nnum_pins++;\r\n}\r\nif (num_pins < 2)\r\nreturn 0;\r\nspec->am_num_entries = num_pins;\r\nsort(spec->am_entry, num_pins, sizeof(spec->am_entry[0]),\r\ncompare_attr, NULL);\r\nif (!auto_mic_check_imux(codec))\r\nreturn 0;\r\nspec->auto_mic = 1;\r\nspec->num_adc_nids = 1;\r\nspec->cur_mux[0] = spec->am_entry[0].idx;\r\ncodec_dbg(codec, "Enable auto-mic switch on NID 0x%x/0x%x/0x%x\n",\r\nspec->am_entry[0].pin,\r\nspec->am_entry[1].pin,\r\nspec->am_entry[2].pin);\r\nreturn 0;\r\n}\r\nunsigned int snd_hda_gen_path_power_filter(struct hda_codec *codec,\r\nhda_nid_t nid,\r\nunsigned int power_state)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (!spec->power_down_unused && !codec->power_save_node)\r\nreturn power_state;\r\nif (power_state != AC_PWRST_D0 || nid == codec->core.afg)\r\nreturn power_state;\r\nif (get_wcaps_type(get_wcaps(codec, nid)) >= AC_WID_POWER)\r\nreturn power_state;\r\nif (is_active_nid_for_any(codec, nid))\r\nreturn power_state;\r\nreturn AC_PWRST_D3;\r\n}\r\nstatic void mute_all_mixer_nid(struct hda_codec *codec, hda_nid_t mix)\r\n{\r\nint i, nums;\r\nconst hda_nid_t *conn;\r\nbool has_amp;\r\nnums = snd_hda_get_conn_list(codec, mix, &conn);\r\nhas_amp = nid_has_mute(codec, mix, HDA_INPUT);\r\nfor (i = 0; i < nums; i++) {\r\nif (has_amp)\r\nupdate_amp(codec, mix, HDA_INPUT, i,\r\n0xff, HDA_AMP_MUTE);\r\nelse if (nid_has_volume(codec, conn[i], HDA_OUTPUT))\r\nupdate_amp(codec, conn[i], HDA_OUTPUT, 0,\r\n0xff, HDA_AMP_MUTE);\r\n}\r\n}\r\nvoid snd_hda_gen_stream_pm(struct hda_codec *codec, hda_nid_t nid, bool on)\r\n{\r\nif (codec->power_save_node)\r\nset_path_power(codec, nid, -1, on);\r\n}\r\nint snd_hda_gen_parse_auto_config(struct hda_codec *codec,\r\nstruct auto_pin_cfg *cfg)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err;\r\nparse_user_hints(codec);\r\nif (spec->mixer_nid && !spec->mixer_merge_nid)\r\nspec->mixer_merge_nid = spec->mixer_nid;\r\nif (cfg != &spec->autocfg) {\r\nspec->autocfg = *cfg;\r\ncfg = &spec->autocfg;\r\n}\r\nif (!spec->main_out_badness)\r\nspec->main_out_badness = &hda_main_out_badness;\r\nif (!spec->extra_out_badness)\r\nspec->extra_out_badness = &hda_extra_out_badness;\r\nfill_all_dac_nids(codec);\r\nif (!cfg->line_outs) {\r\nif (cfg->dig_outs || cfg->dig_in_pin) {\r\nspec->multiout.max_channels = 2;\r\nspec->no_analog = 1;\r\ngoto dig_only;\r\n}\r\nif (!cfg->num_inputs && !cfg->dig_in_pin)\r\nreturn 0;\r\n}\r\nif (!spec->no_primary_hp &&\r\ncfg->line_out_type == AUTO_PIN_SPEAKER_OUT &&\r\ncfg->line_outs <= cfg->hp_outs) {\r\ncfg->speaker_outs = cfg->line_outs;\r\nmemcpy(cfg->speaker_pins, cfg->line_out_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->line_outs = cfg->hp_outs;\r\nmemcpy(cfg->line_out_pins, cfg->hp_pins, sizeof(cfg->hp_pins));\r\ncfg->hp_outs = 0;\r\nmemset(cfg->hp_pins, 0, sizeof(cfg->hp_pins));\r\ncfg->line_out_type = AUTO_PIN_HP_OUT;\r\n}\r\nerr = parse_output_paths(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_multi_channel_mode(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_multi_out_ctls(codec, cfg);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_hp_out_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_speaker_out_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_indep_hp_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_loopback_mixing_ctl(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_hp_mic(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_input_ctls(codec);\r\nif (err < 0)\r\nreturn err;\r\nadd_all_pin_power_ctls(codec, false);\r\nspec->const_channel_count = spec->ext_channel_count;\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT)\r\nspec->const_channel_count = max(spec->const_channel_count,\r\ncfg->speaker_outs * 2);\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT)\r\nspec->const_channel_count = max(spec->const_channel_count,\r\ncfg->hp_outs * 2);\r\nspec->multiout.max_channels = max(spec->ext_channel_count,\r\nspec->const_channel_count);\r\nerr = check_auto_mute_availability(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = check_dyn_adc_switch(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = check_auto_mic_availability(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (!spec->auto_mic && spec->mixer_nid &&\r\nspec->add_stereo_mix_input == HDA_HINT_STEREO_MIX_AUTO &&\r\nspec->input_mux.num_items > 1) {\r\nerr = parse_capture_source(codec, spec->mixer_nid,\r\nCFG_IDX_MIX, spec->num_all_adcs,\r\n"Stereo Mix", 0);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = create_capture_mixers(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_mic_boost(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->hp_mic_pin &&\r\n(spec->auto_mic || spec->input_mux.num_items == 1 ||\r\nspec->add_jack_modes)) {\r\nerr = create_hp_mic_jack_mode(codec, spec->hp_mic_pin);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->add_jack_modes) {\r\nif (cfg->line_out_type != AUTO_PIN_SPEAKER_OUT) {\r\nerr = create_out_jack_modes(codec, cfg->line_outs,\r\ncfg->line_out_pins);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cfg->line_out_type != AUTO_PIN_HP_OUT) {\r\nerr = create_out_jack_modes(codec, cfg->hp_outs,\r\ncfg->hp_pins);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nadd_all_pin_power_ctls(codec, true);\r\nif (spec->mixer_nid)\r\nmute_all_mixer_nid(codec, spec->mixer_nid);\r\ndig_only:\r\nparse_digital(codec);\r\nif (spec->power_down_unused || codec->power_save_node) {\r\nif (!codec->power_filter)\r\ncodec->power_filter = snd_hda_gen_path_power_filter;\r\nif (!codec->patch_ops.stream_pm)\r\ncodec->patch_ops.stream_pm = snd_hda_gen_stream_pm;\r\n}\r\nif (!spec->no_analog && spec->beep_nid) {\r\nerr = snd_hda_attach_beep_device(codec, spec->beep_nid);\r\nif (err < 0)\r\nreturn err;\r\nif (codec->beep && codec->power_save_node) {\r\nerr = add_fake_beep_paths(codec);\r\nif (err < 0)\r\nreturn err;\r\ncodec->beep->power_hook = beep_power_hook;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint snd_hda_gen_build_controls(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err;\r\nif (spec->kctls.used) {\r\nerr = snd_hda_add_new_ctls(codec, spec->kctls.list);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->multiout.dig_out_nid) {\r\nerr = snd_hda_create_dig_out_ctls(codec,\r\nspec->multiout.dig_out_nid,\r\nspec->multiout.dig_out_nid,\r\nspec->pcm_rec[1]->pcm_type);\r\nif (err < 0)\r\nreturn err;\r\nif (!spec->no_analog) {\r\nerr = snd_hda_create_spdif_share_sw(codec,\r\n&spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\nspec->multiout.share_spdif = 1;\r\n}\r\n}\r\nif (spec->dig_in_nid) {\r\nerr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in_nid);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!spec->no_analog &&\r\n!snd_hda_find_mixer_ctl(codec, "Master Playback Volume")) {\r\nerr = snd_hda_add_vmaster(codec, "Master Playback Volume",\r\nspec->vmaster_tlv, slave_pfxs,\r\n"Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!spec->no_analog &&\r\n!snd_hda_find_mixer_ctl(codec, "Master Playback Switch")) {\r\nerr = __snd_hda_add_vmaster(codec, "Master Playback Switch",\r\nNULL, slave_pfxs,\r\n"Playback Switch",\r\ntrue, &spec->vmaster_mute.sw_kctl);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->vmaster_mute.hook) {\r\nsnd_hda_add_vmaster_hook(codec, &spec->vmaster_mute,\r\nspec->vmaster_mute_enum);\r\nsnd_hda_sync_vmaster_hook(&spec->vmaster_mute);\r\n}\r\n}\r\nfree_kctls(spec);\r\nerr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void call_pcm_playback_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->pcm_playback_hook)\r\nspec->pcm_playback_hook(hinfo, codec, substream, action);\r\n}\r\nstatic void call_pcm_capture_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->pcm_capture_hook)\r\nspec->pcm_capture_hook(hinfo, codec, substream, action);\r\n}\r\nstatic int playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err;\r\nmutex_lock(&spec->pcm_mutex);\r\nerr = snd_hda_multi_out_analog_open(codec,\r\n&spec->multiout, substream,\r\nhinfo);\r\nif (!err) {\r\nspec->active_streams |= 1 << STREAM_MULTI_OUT;\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_OPEN);\r\n}\r\nmutex_unlock(&spec->pcm_mutex);\r\nreturn err;\r\n}\r\nstatic int playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_multi_out_analog_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\nif (!err)\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_PREPARE);\r\nreturn err;\r\n}\r\nstatic int playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\r\nif (!err)\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLEANUP);\r\nreturn err;\r\n}\r\nstatic int playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nmutex_lock(&spec->pcm_mutex);\r\nspec->active_streams &= ~(1 << STREAM_MULTI_OUT);\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLOSE);\r\nmutex_unlock(&spec->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\ncall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_OPEN);\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\r\ncall_pcm_capture_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_PREPARE);\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\ncall_pcm_capture_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLEANUP);\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\ncall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_CLOSE);\r\nreturn 0;\r\n}\r\nstatic int alt_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint err = 0;\r\nmutex_lock(&spec->pcm_mutex);\r\nif (spec->indep_hp && !spec->indep_hp_enabled)\r\nerr = -EBUSY;\r\nelse\r\nspec->active_streams |= 1 << STREAM_INDEP_HP;\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_OPEN);\r\nmutex_unlock(&spec->pcm_mutex);\r\nreturn err;\r\n}\r\nstatic int alt_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nmutex_lock(&spec->pcm_mutex);\r\nspec->active_streams &= ~(1 << STREAM_INDEP_HP);\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLOSE);\r\nmutex_unlock(&spec->pcm_mutex);\r\nreturn 0;\r\n}\r\nstatic int alt_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_PREPARE);\r\nreturn 0;\r\n}\r\nstatic int alt_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\ncall_pcm_playback_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLEANUP);\r\nreturn 0;\r\n}\r\nstatic int dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\n}\r\nstatic int dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int alt_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, spec->adc_nids[substream->number + 1],\r\nstream_tag, 0, format);\r\ncall_pcm_capture_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_PREPARE);\r\nreturn 0;\r\n}\r\nstatic int alt_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec,\r\nspec->adc_nids[substream->number + 1]);\r\ncall_pcm_capture_hook(hinfo, codec, substream,\r\nHDA_GEN_PCM_ACT_CLEANUP);\r\nreturn 0;\r\n}\r\nstatic bool dyn_adc_pcm_resetup(struct hda_codec *codec, int cur)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nhda_nid_t new_adc = spec->adc_nids[spec->dyn_adc_idx[cur]];\r\nif (spec->cur_adc && spec->cur_adc != new_adc) {\r\n__snd_hda_codec_cleanup_stream(codec, spec->cur_adc, 1);\r\nspec->cur_adc = new_adc;\r\nsnd_hda_codec_setup_stream(codec, new_adc,\r\nspec->cur_adc_stream_tag, 0,\r\nspec->cur_adc_format);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int dyn_adc_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nspec->cur_adc = spec->adc_nids[spec->dyn_adc_idx[spec->cur_mux[0]]];\r\nspec->cur_adc_stream_tag = stream_tag;\r\nspec->cur_adc_format = format;\r\nsnd_hda_codec_setup_stream(codec, spec->cur_adc, stream_tag, 0, format);\r\ncall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_PREPARE);\r\nreturn 0;\r\n}\r\nstatic int dyn_adc_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->cur_adc);\r\nspec->cur_adc = 0;\r\ncall_pcm_capture_hook(hinfo, codec, substream, HDA_GEN_PCM_ACT_CLEANUP);\r\nreturn 0;\r\n}\r\nstatic void fill_pcm_stream_name(char *str, size_t len, const char *sfx,\r\nconst char *chip_name)\r\n{\r\nchar *p;\r\nif (*str)\r\nreturn;\r\nstrlcpy(str, chip_name, len);\r\nfor (p = strchr(str, ' '); p; p = strchr(p + 1, ' ')) {\r\nif (!isalnum(p[1])) {\r\n*p = 0;\r\nbreak;\r\n}\r\n}\r\nstrlcat(str, sfx, len);\r\n}\r\nstatic void setup_pcm_stream(struct hda_pcm_stream *str,\r\nconst struct hda_pcm_stream *default_str,\r\nconst struct hda_pcm_stream *spec_str,\r\nhda_nid_t nid)\r\n{\r\n*str = *default_str;\r\nif (nid)\r\nstr->nid = nid;\r\nif (spec_str) {\r\nif (spec_str->substreams)\r\nstr->substreams = spec_str->substreams;\r\nif (spec_str->channels_min)\r\nstr->channels_min = spec_str->channels_min;\r\nif (spec_str->channels_max)\r\nstr->channels_max = spec_str->channels_max;\r\nif (spec_str->rates)\r\nstr->rates = spec_str->rates;\r\nif (spec_str->formats)\r\nstr->formats = spec_str->formats;\r\nif (spec_str->maxbps)\r\nstr->maxbps = spec_str->maxbps;\r\n}\r\n}\r\nint snd_hda_gen_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_pcm *info;\r\nbool have_multi_adcs;\r\nif (spec->no_analog)\r\ngoto skip_analog;\r\nfill_pcm_stream_name(spec->stream_name_analog,\r\nsizeof(spec->stream_name_analog),\r\n" Analog", codec->core.chip_name);\r\ninfo = snd_hda_codec_pcm_new(codec, "%s", spec->stream_name_analog);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->pcm_rec[0] = info;\r\nif (spec->multiout.num_dacs > 0) {\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\r\n&pcm_analog_playback,\r\nspec->stream_analog_playback,\r\nspec->multiout.dac_nids[0]);\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\nif (spec->autocfg.line_out_type == AUTO_PIN_SPEAKER_OUT &&\r\nspec->autocfg.line_outs == 2)\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].chmap =\r\nsnd_pcm_2_1_chmaps;\r\n}\r\nif (spec->num_adc_nids) {\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\r\n(spec->dyn_adc_switch ?\r\n&dyn_adc_pcm_analog_capture : &pcm_analog_capture),\r\nspec->stream_analog_capture,\r\nspec->adc_nids[0]);\r\n}\r\nskip_analog:\r\nif (spec->multiout.dig_out_nid || spec->dig_in_nid) {\r\nfill_pcm_stream_name(spec->stream_name_digital,\r\nsizeof(spec->stream_name_digital),\r\n" Digital", codec->core.chip_name);\r\ninfo = snd_hda_codec_pcm_new(codec, "%s",\r\nspec->stream_name_digital);\r\nif (!info)\r\nreturn -ENOMEM;\r\ncodec->slave_dig_outs = spec->multiout.slave_dig_outs;\r\nspec->pcm_rec[1] = info;\r\nif (spec->dig_out_type)\r\ninfo->pcm_type = spec->dig_out_type;\r\nelse\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->multiout.dig_out_nid)\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\r\n&pcm_digital_playback,\r\nspec->stream_digital_playback,\r\nspec->multiout.dig_out_nid);\r\nif (spec->dig_in_nid)\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\r\n&pcm_digital_capture,\r\nspec->stream_digital_capture,\r\nspec->dig_in_nid);\r\n}\r\nif (spec->no_analog)\r\nreturn 0;\r\nhave_multi_adcs = (spec->num_adc_nids > 1) &&\r\n!spec->dyn_adc_switch && !spec->auto_mic;\r\nif (spec->alt_dac_nid || have_multi_adcs) {\r\nfill_pcm_stream_name(spec->stream_name_alt_analog,\r\nsizeof(spec->stream_name_alt_analog),\r\n" Alt Analog", codec->core.chip_name);\r\ninfo = snd_hda_codec_pcm_new(codec, "%s",\r\nspec->stream_name_alt_analog);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->pcm_rec[2] = info;\r\nif (spec->alt_dac_nid)\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\r\n&pcm_analog_alt_playback,\r\nspec->stream_analog_alt_playback,\r\nspec->alt_dac_nid);\r\nelse\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_PLAYBACK],\r\n&pcm_null_stream, NULL, 0);\r\nif (have_multi_adcs) {\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\r\n&pcm_analog_alt_capture,\r\nspec->stream_analog_alt_capture,\r\nspec->adc_nids[1]);\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams =\r\nspec->num_adc_nids - 1;\r\n} else {\r\nsetup_pcm_stream(&info->stream[SNDRV_PCM_STREAM_CAPTURE],\r\n&pcm_null_stream, NULL, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_output_and_unmute(struct hda_codec *codec, int path_idx)\r\n{\r\nstruct nid_path *path;\r\nhda_nid_t pin;\r\npath = snd_hda_get_path_from_idx(codec, path_idx);\r\nif (!path || !path->depth)\r\nreturn;\r\npin = path->path[path->depth - 1];\r\nrestore_pin_ctl(codec, pin);\r\nsnd_hda_activate_path(codec, path, path->active,\r\naamix_default(codec->spec));\r\nset_pin_eapd(codec, pin, path->active);\r\n}\r\nstatic void init_multi_out(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->autocfg.line_outs; i++)\r\nset_output_and_unmute(codec, spec->out_paths[i]);\r\n}\r\nstatic void __init_extra_out(struct hda_codec *codec, int num_outs, int *paths)\r\n{\r\nint i;\r\nfor (i = 0; i < num_outs; i++)\r\nset_output_and_unmute(codec, paths[i]);\r\n}\r\nstatic void init_extra_out(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->autocfg.line_out_type != AUTO_PIN_HP_OUT)\r\n__init_extra_out(codec, spec->autocfg.hp_outs, spec->hp_paths);\r\nif (spec->autocfg.line_out_type != AUTO_PIN_SPEAKER_OUT)\r\n__init_extra_out(codec, spec->autocfg.speaker_outs,\r\nspec->speaker_paths);\r\n}\r\nstatic void init_multi_io(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->multi_ios; i++) {\r\nhda_nid_t pin = spec->multi_io[i].pin;\r\nstruct nid_path *path;\r\npath = get_multiio_path(codec, i);\r\nif (!path)\r\ncontinue;\r\nif (!spec->multi_io[i].ctl_in)\r\nspec->multi_io[i].ctl_in =\r\nsnd_hda_codec_get_pin_target(codec, pin);\r\nsnd_hda_activate_path(codec, path, path->active,\r\naamix_default(spec));\r\n}\r\n}\r\nstatic void init_aamix_paths(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (!spec->have_aamix_ctl)\r\nreturn;\r\nif (!has_aamix_out_paths(spec))\r\nreturn;\r\nupdate_aamix_paths(codec, spec->aamix_mode, spec->out_paths[0],\r\nspec->aamix_out_paths[0],\r\nspec->autocfg.line_out_type);\r\nupdate_aamix_paths(codec, spec->aamix_mode, spec->hp_paths[0],\r\nspec->aamix_out_paths[1],\r\nAUTO_PIN_HP_OUT);\r\nupdate_aamix_paths(codec, spec->aamix_mode, spec->speaker_paths[0],\r\nspec->aamix_out_paths[2],\r\nAUTO_PIN_SPEAKER_OUT);\r\n}\r\nstatic void init_analog_input(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t nid = cfg->inputs[i].pin;\r\nif (is_input_pin(codec, nid))\r\nrestore_pin_ctl(codec, nid);\r\nif (spec->mixer_nid) {\r\nresume_path_from_idx(codec, spec->loopback_paths[i]);\r\nresume_path_from_idx(codec, spec->loopback_merge_path);\r\n}\r\n}\r\n}\r\nstatic void init_input_src(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nstruct nid_path *path;\r\nint i, c, nums;\r\nif (spec->dyn_adc_switch)\r\nnums = 1;\r\nelse\r\nnums = spec->num_adc_nids;\r\nfor (c = 0; c < nums; c++) {\r\nfor (i = 0; i < imux->num_items; i++) {\r\npath = get_input_path(codec, c, i);\r\nif (path) {\r\nbool active = path->active;\r\nif (i == spec->cur_mux[c])\r\nactive = true;\r\nsnd_hda_activate_path(codec, path, active, false);\r\n}\r\n}\r\nif (spec->hp_mic)\r\nupdate_hp_mic(codec, c, true);\r\n}\r\nif (spec->cap_sync_hook)\r\nspec->cap_sync_hook(codec, NULL, NULL);\r\n}\r\nstatic void init_digital(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nint i;\r\nhda_nid_t pin;\r\nfor (i = 0; i < spec->autocfg.dig_outs; i++)\r\nset_output_and_unmute(codec, spec->digout_paths[i]);\r\npin = spec->autocfg.dig_in_pin;\r\nif (pin) {\r\nrestore_pin_ctl(codec, pin);\r\nresume_path_from_idx(codec, spec->digin_path);\r\n}\r\n}\r\nstatic void clear_unsol_on_unused_pins(struct hda_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nhda_nid_t nid = pin->nid;\r\nif (is_jack_detectable(codec, nid) &&\r\n!snd_hda_jack_tbl_get(codec, nid))\r\nsnd_hda_codec_update_cache(codec, nid, 0,\r\nAC_VERB_SET_UNSOLICITED_ENABLE, 0);\r\n}\r\n}\r\nint snd_hda_gen_init(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nif (spec->init_hook)\r\nspec->init_hook(codec);\r\nsnd_hda_apply_verbs(codec);\r\ninit_multi_out(codec);\r\ninit_extra_out(codec);\r\ninit_multi_io(codec);\r\ninit_aamix_paths(codec);\r\ninit_analog_input(codec);\r\ninit_input_src(codec);\r\ninit_digital(codec);\r\nclear_unsol_on_unused_pins(codec);\r\nsync_all_pin_power_ctls(codec);\r\nupdate_automute_all(codec);\r\nregcache_sync(codec->core.regmap);\r\nif (spec->vmaster_mute.sw_kctl && spec->vmaster_mute.hook)\r\nsnd_hda_sync_vmaster_hook(&spec->vmaster_mute);\r\nhda_call_check_power_status(codec, 0x01);\r\nreturn 0;\r\n}\r\nvoid snd_hda_gen_free(struct hda_codec *codec)\r\n{\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_FREE);\r\nsnd_hda_gen_spec_free(codec->spec);\r\nkfree(codec->spec);\r\ncodec->spec = NULL;\r\n}\r\nint snd_hda_gen_check_power_status(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_gen_spec *spec = codec->spec;\r\nreturn snd_hda_check_amp_list_power(codec, &spec->loopback, nid);\r\n}\r\nstatic int snd_hda_parse_generic_codec(struct hda_codec *codec)\r\n{\r\nstruct hda_gen_spec *spec;\r\nint err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\nsnd_hda_gen_spec_init(spec);\r\ncodec->spec = spec;\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->autocfg, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->autocfg);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = generic_patch_ops;\r\nreturn 0;\r\nerror:\r\nsnd_hda_gen_free(codec);\r\nreturn err;\r\n}
