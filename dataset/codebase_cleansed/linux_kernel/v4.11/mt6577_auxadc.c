static inline void mt6577_auxadc_mod_reg(void __iomem *reg,\r\nu32 or_mask, u32 and_mask)\r\n{\r\nu32 val;\r\nval = readl(reg);\r\nval |= or_mask;\r\nval &= ~and_mask;\r\nwritel(val, reg);\r\n}\r\nstatic int mt6577_auxadc_read(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nu32 val;\r\nvoid __iomem *reg_channel;\r\nint ret;\r\nstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\r\nreg_channel = adc_dev->reg_base + MT6577_AUXADC_DAT0 +\r\nchan->channel * 0x04;\r\nmutex_lock(&adc_dev->lock);\r\nmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_CON1,\r\n0, 1 << chan->channel);\r\nret = readl_poll_timeout(reg_channel, val,\r\n((val & MT6577_AUXADC_RDY0) == 0),\r\nMT6577_AUXADC_SLEEP_US,\r\nMT6577_AUXADC_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(indio_dev->dev.parent,\r\n"wait for channel[%d] ready bit clear time out\n",\r\nchan->channel);\r\ngoto err_timeout;\r\n}\r\nmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_CON1,\r\n1 << chan->channel, 0);\r\nudelay(MT6577_AUXADC_SAMPLE_READY_US);\r\nret = readl_poll_timeout(adc_dev->reg_base + MT6577_AUXADC_CON2, val,\r\n((val & MT6577_AUXADC_STA) == 0),\r\nMT6577_AUXADC_SLEEP_US,\r\nMT6577_AUXADC_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(indio_dev->dev.parent,\r\n"wait for auxadc idle time out\n");\r\ngoto err_timeout;\r\n}\r\nret = readl_poll_timeout(reg_channel, val,\r\n((val & MT6577_AUXADC_RDY0) != 0),\r\nMT6577_AUXADC_SLEEP_US,\r\nMT6577_AUXADC_TIMEOUT_US);\r\nif (ret < 0) {\r\ndev_err(indio_dev->dev.parent,\r\n"wait for channel[%d] data ready time out\n",\r\nchan->channel);\r\ngoto err_timeout;\r\n}\r\nval = readl(reg_channel) & MT6577_AUXADC_DAT_MASK;\r\nmutex_unlock(&adc_dev->lock);\r\nreturn val;\r\nerr_timeout:\r\nmutex_unlock(&adc_dev->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mt6577_auxadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong info)\r\n{\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\n*val = mt6577_auxadc_read(indio_dev, chan);\r\nif (*val < 0) {\r\ndev_err(indio_dev->dev.parent,\r\n"failed to sample data on channel[%d]\n",\r\nchan->channel);\r\nreturn *val;\r\n}\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mt6577_auxadc_probe(struct platform_device *pdev)\r\n{\r\nstruct mt6577_auxadc_device *adc_dev;\r\nunsigned long adc_clk_rate;\r\nstruct resource *res;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*adc_dev));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nadc_dev = iio_priv(indio_dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->info = &mt6577_auxadc_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = mt6577_auxadc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mt6577_auxadc_iio_channels);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nadc_dev->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(adc_dev->reg_base)) {\r\ndev_err(&pdev->dev, "failed to get auxadc base address\n");\r\nreturn PTR_ERR(adc_dev->reg_base);\r\n}\r\nadc_dev->adc_clk = devm_clk_get(&pdev->dev, "main");\r\nif (IS_ERR(adc_dev->adc_clk)) {\r\ndev_err(&pdev->dev, "failed to get auxadc clock\n");\r\nreturn PTR_ERR(adc_dev->adc_clk);\r\n}\r\nret = clk_prepare_enable(adc_dev->adc_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable auxadc clock\n");\r\nreturn ret;\r\n}\r\nadc_clk_rate = clk_get_rate(adc_dev->adc_clk);\r\nif (!adc_clk_rate) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "null clock rate\n");\r\ngoto err_disable_clk;\r\n}\r\nmutex_init(&adc_dev->lock);\r\nmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\r\nMT6577_AUXADC_PDN_EN, 0);\r\nmdelay(MT6577_AUXADC_POWER_READY_MS);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register iio device\n");\r\ngoto err_power_off;\r\n}\r\nreturn 0;\r\nerr_power_off:\r\nmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\r\n0, MT6577_AUXADC_PDN_EN);\r\nerr_disable_clk:\r\nclk_disable_unprepare(adc_dev->adc_clk);\r\nreturn ret;\r\n}\r\nstatic int mt6577_auxadc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct mt6577_auxadc_device *adc_dev = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nmt6577_auxadc_mod_reg(adc_dev->reg_base + MT6577_AUXADC_MISC,\r\n0, MT6577_AUXADC_PDN_EN);\r\nclk_disable_unprepare(adc_dev->adc_clk);\r\nreturn 0;\r\n}
