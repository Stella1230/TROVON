static struct tipc_monitor *tipc_monitor(struct net *net, int bearer_id)\r\n{\r\nreturn tipc_net(net)->monitors[bearer_id];\r\n}\r\nstatic int dom_rec_len(struct tipc_mon_domain *dom, u16 mcnt)\r\n{\r\nreturn ((void *)&dom->members - (void *)dom) + (mcnt * sizeof(u32));\r\n}\r\nstatic int dom_size(int peers)\r\n{\r\nint i = 0;\r\nwhile ((i * i) < peers)\r\ni++;\r\nreturn i < MAX_MON_DOMAIN ? i : MAX_MON_DOMAIN;\r\n}\r\nstatic void map_set(u64 *up_map, int i, unsigned int v)\r\n{\r\n*up_map &= ~(1ULL << i);\r\n*up_map |= ((u64)v << i);\r\n}\r\nstatic int map_get(u64 up_map, int i)\r\n{\r\nreturn (up_map & (1 << i)) >> i;\r\n}\r\nstatic struct tipc_peer *peer_prev(struct tipc_peer *peer)\r\n{\r\nreturn list_last_entry(&peer->list, struct tipc_peer, list);\r\n}\r\nstatic struct tipc_peer *peer_nxt(struct tipc_peer *peer)\r\n{\r\nreturn list_first_entry(&peer->list, struct tipc_peer, list);\r\n}\r\nstatic struct tipc_peer *peer_head(struct tipc_peer *peer)\r\n{\r\nwhile (!peer->is_head)\r\npeer = peer_prev(peer);\r\nreturn peer;\r\n}\r\nstatic struct tipc_peer *get_peer(struct tipc_monitor *mon, u32 addr)\r\n{\r\nstruct tipc_peer *peer;\r\nunsigned int thash = tipc_hashfn(addr);\r\nhlist_for_each_entry(peer, &mon->peers[thash], hash) {\r\nif (peer->addr == addr)\r\nreturn peer;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct tipc_peer *get_self(struct net *net, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nreturn mon->self;\r\n}\r\nstatic inline bool tipc_mon_is_active(struct net *net, struct tipc_monitor *mon)\r\n{\r\nstruct tipc_net *tn = tipc_net(net);\r\nreturn mon->peer_cnt > tn->mon_threshold;\r\n}\r\nstatic void mon_identify_lost_members(struct tipc_peer *peer,\r\nstruct tipc_mon_domain *dom_bef,\r\nint applied_bef)\r\n{\r\nstruct tipc_peer *member = peer;\r\nstruct tipc_mon_domain *dom_aft = peer->domain;\r\nint applied_aft = peer->applied;\r\nint i;\r\nfor (i = 0; i < applied_bef; i++) {\r\nmember = peer_nxt(member);\r\nif (!member->is_up || !map_get(dom_bef->up_map, i))\r\ncontinue;\r\nif (member->is_local)\r\ncontinue;\r\nif (!applied_aft || (applied_aft < i)) {\r\nmember->down_cnt = 1;\r\ncontinue;\r\n}\r\nif (!map_get(dom_aft->up_map, i))\r\nmember->down_cnt++;\r\n}\r\n}\r\nstatic void mon_apply_domain(struct tipc_monitor *mon,\r\nstruct tipc_peer *peer)\r\n{\r\nstruct tipc_mon_domain *dom = peer->domain;\r\nstruct tipc_peer *member;\r\nu32 addr;\r\nint i;\r\nif (!dom || !peer->is_up)\r\nreturn;\r\npeer->applied = 0;\r\nmember = peer_nxt(peer);\r\nfor (i = 0; i < dom->member_cnt; i++) {\r\naddr = dom->members[i];\r\nif (addr != member->addr)\r\nreturn;\r\npeer->applied++;\r\nmember = peer_nxt(member);\r\n}\r\n}\r\nstatic void mon_update_local_domain(struct tipc_monitor *mon)\r\n{\r\nstruct tipc_peer *self = mon->self;\r\nstruct tipc_mon_domain *cache = &mon->cache;\r\nstruct tipc_mon_domain *dom = self->domain;\r\nstruct tipc_peer *peer = self;\r\nu64 prev_up_map = dom->up_map;\r\nu16 member_cnt, i;\r\nbool diff;\r\nmember_cnt = dom_size(mon->peer_cnt) - 1;\r\nself->applied = member_cnt;\r\ndom->len = dom_rec_len(dom, member_cnt);\r\ndiff = dom->member_cnt != member_cnt;\r\ndom->member_cnt = member_cnt;\r\nfor (i = 0; i < member_cnt; i++) {\r\npeer = peer_nxt(peer);\r\ndiff |= dom->members[i] != peer->addr;\r\ndom->members[i] = peer->addr;\r\nmap_set(&dom->up_map, i, peer->is_up);\r\ncache->members[i] = htonl(peer->addr);\r\n}\r\ndiff |= dom->up_map != prev_up_map;\r\nif (!diff)\r\nreturn;\r\ndom->gen = ++mon->dom_gen;\r\ncache->len = htons(dom->len);\r\ncache->gen = htons(dom->gen);\r\ncache->member_cnt = htons(member_cnt);\r\ncache->up_map = cpu_to_be64(dom->up_map);\r\nmon_apply_domain(mon, self);\r\n}\r\nstatic void mon_update_neighbors(struct tipc_monitor *mon,\r\nstruct tipc_peer *peer)\r\n{\r\nint dz, i;\r\ndz = dom_size(mon->peer_cnt);\r\nfor (i = 0; i < dz; i++) {\r\nmon_apply_domain(mon, peer);\r\npeer = peer_prev(peer);\r\n}\r\n}\r\nstatic void mon_assign_roles(struct tipc_monitor *mon, struct tipc_peer *head)\r\n{\r\nstruct tipc_peer *peer = peer_nxt(head);\r\nstruct tipc_peer *self = mon->self;\r\nint i = 0;\r\nfor (; peer != self; peer = peer_nxt(peer)) {\r\npeer->is_local = false;\r\nif (i++ < head->applied) {\r\npeer->is_head = false;\r\nif (head == self)\r\npeer->is_local = true;\r\ncontinue;\r\n}\r\nif (!peer->is_up)\r\ncontinue;\r\nif (peer->is_head)\r\nbreak;\r\nhead = peer;\r\nhead->is_head = true;\r\ni = 0;\r\n}\r\nmon->list_gen++;\r\n}\r\nvoid tipc_mon_remove_peer(struct net *net, u32 addr, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *self = get_self(net, bearer_id);\r\nstruct tipc_peer *peer, *prev, *head;\r\nwrite_lock_bh(&mon->lock);\r\npeer = get_peer(mon, addr);\r\nif (!peer)\r\ngoto exit;\r\nprev = peer_prev(peer);\r\nlist_del(&peer->list);\r\nhlist_del(&peer->hash);\r\nkfree(peer->domain);\r\nkfree(peer);\r\nmon->peer_cnt--;\r\nhead = peer_head(prev);\r\nif (head == self)\r\nmon_update_local_domain(mon);\r\nmon_update_neighbors(mon, prev);\r\nif (!tipc_mon_is_active(net, mon)) {\r\nlist_for_each_entry(peer, &self->list, list) {\r\nkfree(peer->domain);\r\npeer->domain = NULL;\r\npeer->applied = 0;\r\n}\r\n}\r\nmon_assign_roles(mon, head);\r\nexit:\r\nwrite_unlock_bh(&mon->lock);\r\n}\r\nstatic bool tipc_mon_add_peer(struct tipc_monitor *mon, u32 addr,\r\nstruct tipc_peer **peer)\r\n{\r\nstruct tipc_peer *self = mon->self;\r\nstruct tipc_peer *cur, *prev, *p;\r\np = kzalloc(sizeof(*p), GFP_ATOMIC);\r\n*peer = p;\r\nif (!p)\r\nreturn false;\r\np->addr = addr;\r\nINIT_LIST_HEAD(&p->list);\r\nhlist_add_head(&p->hash, &mon->peers[tipc_hashfn(addr)]);\r\nprev = self;\r\nlist_for_each_entry(cur, &self->list, list) {\r\nif ((addr > prev->addr) && (addr < cur->addr))\r\nbreak;\r\nif (((addr < cur->addr) || (addr > prev->addr)) &&\r\n(prev->addr > cur->addr))\r\nbreak;\r\nprev = cur;\r\n}\r\nlist_add_tail(&p->list, &cur->list);\r\nmon->peer_cnt++;\r\nmon_update_neighbors(mon, p);\r\nreturn true;\r\n}\r\nvoid tipc_mon_peer_up(struct net *net, u32 addr, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *self = get_self(net, bearer_id);\r\nstruct tipc_peer *peer, *head;\r\nwrite_lock_bh(&mon->lock);\r\npeer = get_peer(mon, addr);\r\nif (!peer && !tipc_mon_add_peer(mon, addr, &peer))\r\ngoto exit;\r\npeer->is_up = true;\r\nhead = peer_head(peer);\r\nif (head == self)\r\nmon_update_local_domain(mon);\r\nmon_assign_roles(mon, head);\r\nexit:\r\nwrite_unlock_bh(&mon->lock);\r\n}\r\nvoid tipc_mon_peer_down(struct net *net, u32 addr, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *self = get_self(net, bearer_id);\r\nstruct tipc_peer *peer, *head;\r\nstruct tipc_mon_domain *dom;\r\nint applied;\r\nwrite_lock_bh(&mon->lock);\r\npeer = get_peer(mon, addr);\r\nif (!peer) {\r\npr_warn("Mon: unknown link %x/%u DOWN\n", addr, bearer_id);\r\ngoto exit;\r\n}\r\napplied = peer->applied;\r\npeer->applied = 0;\r\ndom = peer->domain;\r\npeer->domain = NULL;\r\nif (peer->is_head)\r\nmon_identify_lost_members(peer, dom, applied);\r\nkfree(dom);\r\npeer->is_up = false;\r\npeer->is_head = false;\r\npeer->is_local = false;\r\npeer->down_cnt = 0;\r\nhead = peer_head(peer);\r\nif (head == self)\r\nmon_update_local_domain(mon);\r\nmon_assign_roles(mon, head);\r\nexit:\r\nwrite_unlock_bh(&mon->lock);\r\n}\r\nvoid tipc_mon_rcv(struct net *net, void *data, u16 dlen, u32 addr,\r\nstruct tipc_mon_state *state, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_mon_domain *arrv_dom = data;\r\nstruct tipc_mon_domain dom_bef;\r\nstruct tipc_mon_domain *dom;\r\nstruct tipc_peer *peer;\r\nu16 new_member_cnt = ntohs(arrv_dom->member_cnt);\r\nint new_dlen = dom_rec_len(arrv_dom, new_member_cnt);\r\nu16 new_gen = ntohs(arrv_dom->gen);\r\nu16 acked_gen = ntohs(arrv_dom->ack_gen);\r\nbool probing = state->probing;\r\nint i, applied_bef;\r\nstate->probing = false;\r\nif (dlen < dom_rec_len(arrv_dom, 0))\r\nreturn;\r\nif (dlen != dom_rec_len(arrv_dom, new_member_cnt))\r\nreturn;\r\nif ((dlen < new_dlen) || ntohs(arrv_dom->len) != new_dlen)\r\nreturn;\r\nif (!state->synched) {\r\nstate->peer_gen = new_gen - 1;\r\nstate->acked_gen = acked_gen;\r\nstate->synched = true;\r\n}\r\nif (more(acked_gen, state->acked_gen))\r\nstate->acked_gen = acked_gen;\r\nif (!more(new_gen, state->peer_gen) && !probing)\r\nreturn;\r\nwrite_lock_bh(&mon->lock);\r\npeer = get_peer(mon, addr);\r\nif (!peer || !peer->is_up)\r\ngoto exit;\r\npeer->down_cnt = 0;\r\nif (!more(new_gen, state->peer_gen))\r\ngoto exit;\r\nstate->peer_gen = new_gen;\r\ndom_bef.member_cnt = 0;\r\ndom = peer->domain;\r\nif (dom)\r\nmemcpy(&dom_bef, dom, dom->len);\r\nif (!dom || (dom->len < new_dlen)) {\r\nkfree(dom);\r\ndom = kmalloc(new_dlen, GFP_ATOMIC);\r\npeer->domain = dom;\r\nif (!dom)\r\ngoto exit;\r\n}\r\ndom->len = new_dlen;\r\ndom->gen = new_gen;\r\ndom->member_cnt = new_member_cnt;\r\ndom->up_map = be64_to_cpu(arrv_dom->up_map);\r\nfor (i = 0; i < new_member_cnt; i++)\r\ndom->members[i] = ntohl(arrv_dom->members[i]);\r\napplied_bef = peer->applied;\r\nmon_apply_domain(mon, peer);\r\nmon_identify_lost_members(peer, &dom_bef, applied_bef);\r\nmon_assign_roles(mon, peer_head(peer));\r\nexit:\r\nwrite_unlock_bh(&mon->lock);\r\n}\r\nvoid tipc_mon_prep(struct net *net, void *data, int *dlen,\r\nstruct tipc_mon_state *state, int bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_mon_domain *dom = data;\r\nu16 gen = mon->dom_gen;\r\nu16 len;\r\nif (!tipc_mon_is_active(net, mon))\r\nreturn;\r\nif (likely(state->acked_gen == gen)) {\r\nlen = dom_rec_len(dom, 0);\r\n*dlen = len;\r\ndom->len = htons(len);\r\ndom->gen = htons(gen);\r\ndom->ack_gen = htons(state->peer_gen);\r\ndom->member_cnt = 0;\r\nreturn;\r\n}\r\nread_lock_bh(&mon->lock);\r\nlen = ntohs(mon->cache.len);\r\n*dlen = len;\r\nmemcpy(data, &mon->cache, len);\r\nread_unlock_bh(&mon->lock);\r\ndom->ack_gen = htons(state->peer_gen);\r\n}\r\nvoid tipc_mon_get_state(struct net *net, u32 addr,\r\nstruct tipc_mon_state *state,\r\nint bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *peer;\r\nif (!state->probing &&\r\n(state->list_gen == mon->list_gen) &&\r\n(state->acked_gen == mon->dom_gen))\r\nreturn;\r\nread_lock_bh(&mon->lock);\r\npeer = get_peer(mon, addr);\r\nif (peer) {\r\nstate->probing = state->acked_gen != mon->dom_gen;\r\nstate->probing |= peer->down_cnt;\r\nstate->reset |= peer->down_cnt >= MAX_PEER_DOWN_EVENTS;\r\nstate->monitoring = peer->is_local;\r\nstate->monitoring |= peer->is_head;\r\nstate->list_gen = mon->list_gen;\r\n}\r\nread_unlock_bh(&mon->lock);\r\n}\r\nstatic void mon_timeout(unsigned long m)\r\n{\r\nstruct tipc_monitor *mon = (void *)m;\r\nstruct tipc_peer *self;\r\nint best_member_cnt = dom_size(mon->peer_cnt) - 1;\r\nwrite_lock_bh(&mon->lock);\r\nself = mon->self;\r\nif (self && (best_member_cnt != self->applied)) {\r\nmon_update_local_domain(mon);\r\nmon_assign_roles(mon, self);\r\n}\r\nwrite_unlock_bh(&mon->lock);\r\nmod_timer(&mon->timer, jiffies + mon->timer_intv);\r\n}\r\nint tipc_mon_create(struct net *net, int bearer_id)\r\n{\r\nstruct tipc_net *tn = tipc_net(net);\r\nstruct tipc_monitor *mon;\r\nstruct tipc_peer *self;\r\nstruct tipc_mon_domain *dom;\r\nif (tn->monitors[bearer_id])\r\nreturn 0;\r\nmon = kzalloc(sizeof(*mon), GFP_ATOMIC);\r\nself = kzalloc(sizeof(*self), GFP_ATOMIC);\r\ndom = kzalloc(sizeof(*dom), GFP_ATOMIC);\r\nif (!mon || !self || !dom) {\r\nkfree(mon);\r\nkfree(self);\r\nkfree(dom);\r\nreturn -ENOMEM;\r\n}\r\ntn->monitors[bearer_id] = mon;\r\nrwlock_init(&mon->lock);\r\nmon->net = net;\r\nmon->peer_cnt = 1;\r\nmon->self = self;\r\nself->domain = dom;\r\nself->addr = tipc_own_addr(net);\r\nself->is_up = true;\r\nself->is_head = true;\r\nINIT_LIST_HEAD(&self->list);\r\nsetup_timer(&mon->timer, mon_timeout, (unsigned long)mon);\r\nmon->timer_intv = msecs_to_jiffies(MON_TIMEOUT + (tn->random & 0xffff));\r\nmod_timer(&mon->timer, jiffies + mon->timer_intv);\r\nreturn 0;\r\n}\r\nvoid tipc_mon_delete(struct net *net, int bearer_id)\r\n{\r\nstruct tipc_net *tn = tipc_net(net);\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *self = get_self(net, bearer_id);\r\nstruct tipc_peer *peer, *tmp;\r\nwrite_lock_bh(&mon->lock);\r\ntn->monitors[bearer_id] = NULL;\r\nlist_for_each_entry_safe(peer, tmp, &self->list, list) {\r\nlist_del(&peer->list);\r\nhlist_del(&peer->hash);\r\nkfree(peer->domain);\r\nkfree(peer);\r\n}\r\nmon->self = NULL;\r\nwrite_unlock_bh(&mon->lock);\r\ndel_timer_sync(&mon->timer);\r\nkfree(self->domain);\r\nkfree(self);\r\nkfree(mon);\r\n}\r\nint tipc_nl_monitor_set_threshold(struct net *net, u32 cluster_size)\r\n{\r\nstruct tipc_net *tn = tipc_net(net);\r\nif (cluster_size > TIPC_CLUSTER_SIZE)\r\nreturn -EINVAL;\r\ntn->mon_threshold = cluster_size;\r\nreturn 0;\r\n}\r\nint tipc_nl_monitor_get_threshold(struct net *net)\r\n{\r\nstruct tipc_net *tn = tipc_net(net);\r\nreturn tn->mon_threshold;\r\n}\r\nint __tipc_nl_add_monitor_peer(struct tipc_peer *peer, struct tipc_nl_msg *msg)\r\n{\r\nstruct tipc_mon_domain *dom = peer->domain;\r\nstruct nlattr *attrs;\r\nvoid *hdr;\r\nhdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\r\nNLM_F_MULTI, TIPC_NL_MON_PEER_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nattrs = nla_nest_start(msg->skb, TIPC_NLA_MON_PEER);\r\nif (!attrs)\r\ngoto msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_ADDR, peer->addr))\r\ngoto attr_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_APPLIED, peer->applied))\r\ngoto attr_msg_full;\r\nif (peer->is_up)\r\nif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_UP))\r\ngoto attr_msg_full;\r\nif (peer->is_local)\r\nif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_LOCAL))\r\ngoto attr_msg_full;\r\nif (peer->is_head)\r\nif (nla_put_flag(msg->skb, TIPC_NLA_MON_PEER_HEAD))\r\ngoto attr_msg_full;\r\nif (dom) {\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEER_DOMGEN, dom->gen))\r\ngoto attr_msg_full;\r\nif (nla_put_u64_64bit(msg->skb, TIPC_NLA_MON_PEER_UPMAP,\r\ndom->up_map, TIPC_NLA_MON_PEER_PAD))\r\ngoto attr_msg_full;\r\nif (nla_put(msg->skb, TIPC_NLA_MON_PEER_MEMBERS,\r\ndom->member_cnt * sizeof(u32), &dom->members))\r\ngoto attr_msg_full;\r\n}\r\nnla_nest_end(msg->skb, attrs);\r\ngenlmsg_end(msg->skb, hdr);\r\nreturn 0;\r\nattr_msg_full:\r\nnla_nest_cancel(msg->skb, attrs);\r\nmsg_full:\r\ngenlmsg_cancel(msg->skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nint tipc_nl_add_monitor_peer(struct net *net, struct tipc_nl_msg *msg,\r\nu32 bearer_id, u32 *prev_node)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nstruct tipc_peer *peer;\r\nif (!mon)\r\nreturn -EINVAL;\r\nread_lock_bh(&mon->lock);\r\npeer = mon->self;\r\ndo {\r\nif (*prev_node) {\r\nif (peer->addr == *prev_node)\r\n*prev_node = 0;\r\nelse\r\ncontinue;\r\n}\r\nif (__tipc_nl_add_monitor_peer(peer, msg)) {\r\n*prev_node = peer->addr;\r\nread_unlock_bh(&mon->lock);\r\nreturn -EMSGSIZE;\r\n}\r\n} while ((peer = peer_nxt(peer)) != mon->self);\r\nread_unlock_bh(&mon->lock);\r\nreturn 0;\r\n}\r\nint __tipc_nl_add_monitor(struct net *net, struct tipc_nl_msg *msg,\r\nu32 bearer_id)\r\n{\r\nstruct tipc_monitor *mon = tipc_monitor(net, bearer_id);\r\nchar bearer_name[TIPC_MAX_BEARER_NAME];\r\nstruct nlattr *attrs;\r\nvoid *hdr;\r\nint ret;\r\nret = tipc_bearer_get_name(net, bearer_name, bearer_id);\r\nif (ret || !mon)\r\nreturn -EINVAL;\r\nhdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\r\nNLM_F_MULTI, TIPC_NL_MON_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nattrs = nla_nest_start(msg->skb, TIPC_NLA_MON);\r\nif (!attrs)\r\ngoto msg_full;\r\nread_lock_bh(&mon->lock);\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_REF, bearer_id))\r\ngoto attr_msg_full;\r\nif (tipc_mon_is_active(net, mon))\r\nif (nla_put_flag(msg->skb, TIPC_NLA_MON_ACTIVE))\r\ngoto attr_msg_full;\r\nif (nla_put_string(msg->skb, TIPC_NLA_MON_BEARER_NAME, bearer_name))\r\ngoto attr_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_PEERCNT, mon->peer_cnt))\r\ngoto attr_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_MON_LISTGEN, mon->list_gen))\r\ngoto attr_msg_full;\r\nread_unlock_bh(&mon->lock);\r\nnla_nest_end(msg->skb, attrs);\r\ngenlmsg_end(msg->skb, hdr);\r\nreturn 0;\r\nattr_msg_full:\r\nread_unlock_bh(&mon->lock);\r\nnla_nest_cancel(msg->skb, attrs);\r\nmsg_full:\r\ngenlmsg_cancel(msg->skb, hdr);\r\nreturn -EMSGSIZE;\r\n}
