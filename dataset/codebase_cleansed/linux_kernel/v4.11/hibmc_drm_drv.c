static int hibmc_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct hibmc_drm_private *priv =\r\n(struct hibmc_drm_private *)dev->dev_private;\r\nwritel(HIBMC_RAW_INTERRUPT_EN_VBLANK(1),\r\npriv->mmio + HIBMC_RAW_INTERRUPT_EN);\r\nreturn 0;\r\n}\r\nstatic void hibmc_disable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct hibmc_drm_private *priv =\r\n(struct hibmc_drm_private *)dev->dev_private;\r\nwritel(HIBMC_RAW_INTERRUPT_EN_VBLANK(0),\r\npriv->mmio + HIBMC_RAW_INTERRUPT_EN);\r\n}\r\nirqreturn_t hibmc_drm_interrupt(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)arg;\r\nstruct hibmc_drm_private *priv =\r\n(struct hibmc_drm_private *)dev->dev_private;\r\nu32 status;\r\nstatus = readl(priv->mmio + HIBMC_RAW_INTERRUPT);\r\nif (status & HIBMC_RAW_INTERRUPT_VBLANK(1)) {\r\nwritel(HIBMC_RAW_INTERRUPT_VBLANK(1),\r\npriv->mmio + HIBMC_RAW_INTERRUPT);\r\ndrm_handle_vblank(dev, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __maybe_unused hibmc_pm_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nstruct hibmc_drm_private *priv = drm_dev->dev_private;\r\ndrm_kms_helper_poll_disable(drm_dev);\r\npriv->suspend_state = drm_atomic_helper_suspend(drm_dev);\r\nif (IS_ERR(priv->suspend_state)) {\r\nDRM_ERROR("drm_atomic_helper_suspend failed: %ld\n",\r\nPTR_ERR(priv->suspend_state));\r\ndrm_kms_helper_poll_enable(drm_dev);\r\nreturn PTR_ERR(priv->suspend_state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused hibmc_pm_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nstruct hibmc_drm_private *priv = drm_dev->dev_private;\r\ndrm_atomic_helper_resume(drm_dev, priv->suspend_state);\r\ndrm_kms_helper_poll_enable(drm_dev);\r\nreturn 0;\r\n}\r\nstatic int hibmc_kms_init(struct hibmc_drm_private *priv)\r\n{\r\nint ret;\r\ndrm_mode_config_init(priv->dev);\r\npriv->mode_config_initialized = true;\r\npriv->dev->mode_config.min_width = 0;\r\npriv->dev->mode_config.min_height = 0;\r\npriv->dev->mode_config.max_width = 1920;\r\npriv->dev->mode_config.max_height = 1440;\r\npriv->dev->mode_config.fb_base = priv->fb_base;\r\npriv->dev->mode_config.preferred_depth = 24;\r\npriv->dev->mode_config.prefer_shadow = 0;\r\npriv->dev->mode_config.funcs = (void *)&hibmc_mode_funcs;\r\nret = hibmc_de_init(priv);\r\nif (ret) {\r\nDRM_ERROR("failed to init de: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = hibmc_vdac_init(priv);\r\nif (ret) {\r\nDRM_ERROR("failed to init vdac: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hibmc_kms_fini(struct hibmc_drm_private *priv)\r\n{\r\nif (priv->mode_config_initialized) {\r\ndrm_mode_config_cleanup(priv->dev);\r\npriv->mode_config_initialized = false;\r\n}\r\n}\r\nvoid hibmc_set_power_mode(struct hibmc_drm_private *priv,\r\nunsigned int power_mode)\r\n{\r\nunsigned int control_value = 0;\r\nvoid __iomem *mmio = priv->mmio;\r\nunsigned int input = 1;\r\nif (power_mode > HIBMC_PW_MODE_CTL_MODE_SLEEP)\r\nreturn;\r\nif (power_mode == HIBMC_PW_MODE_CTL_MODE_SLEEP)\r\ninput = 0;\r\ncontrol_value = readl(mmio + HIBMC_POWER_MODE_CTRL);\r\ncontrol_value &= ~(HIBMC_PW_MODE_CTL_MODE_MASK |\r\nHIBMC_PW_MODE_CTL_OSC_INPUT_MASK);\r\ncontrol_value |= HIBMC_FIELD(HIBMC_PW_MODE_CTL_MODE, power_mode);\r\ncontrol_value |= HIBMC_FIELD(HIBMC_PW_MODE_CTL_OSC_INPUT, input);\r\nwritel(control_value, mmio + HIBMC_POWER_MODE_CTRL);\r\n}\r\nvoid hibmc_set_current_gate(struct hibmc_drm_private *priv, unsigned int gate)\r\n{\r\nunsigned int gate_reg;\r\nunsigned int mode;\r\nvoid __iomem *mmio = priv->mmio;\r\nmode = (readl(mmio + HIBMC_POWER_MODE_CTRL) &\r\nHIBMC_PW_MODE_CTL_MODE_MASK) >> HIBMC_PW_MODE_CTL_MODE_SHIFT;\r\nswitch (mode) {\r\ncase HIBMC_PW_MODE_CTL_MODE_MODE0:\r\ngate_reg = HIBMC_MODE0_GATE;\r\nbreak;\r\ncase HIBMC_PW_MODE_CTL_MODE_MODE1:\r\ngate_reg = HIBMC_MODE1_GATE;\r\nbreak;\r\ndefault:\r\ngate_reg = HIBMC_MODE0_GATE;\r\nbreak;\r\n}\r\nwritel(gate, mmio + gate_reg);\r\n}\r\nstatic void hibmc_hw_config(struct hibmc_drm_private *priv)\r\n{\r\nunsigned int reg;\r\nhibmc_set_power_mode(priv, HIBMC_PW_MODE_CTL_MODE_MODE0);\r\nreg = readl(priv->mmio + HIBMC_CURRENT_GATE);\r\nreg &= ~HIBMC_CURR_GATE_DISPLAY_MASK;\r\nreg &= ~HIBMC_CURR_GATE_LOCALMEM_MASK;\r\nreg |= HIBMC_CURR_GATE_DISPLAY(1);\r\nreg |= HIBMC_CURR_GATE_LOCALMEM(1);\r\nhibmc_set_current_gate(priv, reg);\r\nreg = readl(priv->mmio + HIBMC_MISC_CTRL);\r\nreg &= ~HIBMC_MSCCTL_LOCALMEM_RESET_MASK;\r\nreg |= HIBMC_MSCCTL_LOCALMEM_RESET(0);\r\nwritel(reg, priv->mmio + HIBMC_MISC_CTRL);\r\nreg &= ~HIBMC_MSCCTL_LOCALMEM_RESET_MASK;\r\nreg |= HIBMC_MSCCTL_LOCALMEM_RESET(1);\r\nwritel(reg, priv->mmio + HIBMC_MISC_CTRL);\r\n}\r\nstatic int hibmc_hw_map(struct hibmc_drm_private *priv)\r\n{\r\nstruct drm_device *dev = priv->dev;\r\nstruct pci_dev *pdev = dev->pdev;\r\nresource_size_t addr, size, ioaddr, iosize;\r\nioaddr = pci_resource_start(pdev, 1);\r\niosize = pci_resource_len(pdev, 1);\r\npriv->mmio = devm_ioremap_nocache(dev->dev, ioaddr, iosize);\r\nif (!priv->mmio) {\r\nDRM_ERROR("Cannot map mmio region\n");\r\nreturn -ENOMEM;\r\n}\r\naddr = pci_resource_start(pdev, 0);\r\nsize = pci_resource_len(pdev, 0);\r\npriv->fb_map = devm_ioremap(dev->dev, addr, size);\r\nif (!priv->fb_map) {\r\nDRM_ERROR("Cannot map framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->fb_base = addr;\r\npriv->fb_size = size;\r\nreturn 0;\r\n}\r\nstatic int hibmc_hw_init(struct hibmc_drm_private *priv)\r\n{\r\nint ret;\r\nret = hibmc_hw_map(priv);\r\nif (ret)\r\nreturn ret;\r\nhibmc_hw_config(priv);\r\nreturn 0;\r\n}\r\nstatic int hibmc_unload(struct drm_device *dev)\r\n{\r\nstruct hibmc_drm_private *priv = dev->dev_private;\r\nhibmc_fbdev_fini(priv);\r\nif (dev->irq_enabled)\r\ndrm_irq_uninstall(dev);\r\nif (priv->msi_enabled)\r\npci_disable_msi(dev->pdev);\r\ndrm_vblank_cleanup(dev);\r\nhibmc_kms_fini(priv);\r\nhibmc_mm_fini(priv);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nstatic int hibmc_load(struct drm_device *dev)\r\n{\r\nstruct hibmc_drm_private *priv;\r\nint ret;\r\npriv = devm_kzalloc(dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nDRM_ERROR("no memory to allocate for hibmc_drm_private\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dev_private = priv;\r\npriv->dev = dev;\r\nret = hibmc_hw_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = hibmc_mm_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = hibmc_kms_init(priv);\r\nif (ret)\r\ngoto err;\r\nret = drm_vblank_init(dev, dev->mode_config.num_crtc);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize vblank: %d\n", ret);\r\ngoto err;\r\n}\r\npriv->msi_enabled = 0;\r\nret = pci_enable_msi(dev->pdev);\r\nif (ret) {\r\nDRM_WARN("enabling MSI failed: %d\n", ret);\r\n} else {\r\npriv->msi_enabled = 1;\r\nret = drm_irq_install(dev, dev->pdev->irq);\r\nif (ret)\r\nDRM_WARN("install irq failed: %d\n", ret);\r\n}\r\ndrm_mode_config_reset(dev);\r\nret = hibmc_fbdev_init(priv);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize fbdev: %d\n", ret);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nhibmc_unload(dev);\r\nDRM_ERROR("failed to initialize drm driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hibmc_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct drm_device *dev;\r\nint ret;\r\ndev = drm_dev_alloc(&hibmc_driver, &pdev->dev);\r\nif (IS_ERR(dev)) {\r\nDRM_ERROR("failed to allocate drm_device\n");\r\nreturn PTR_ERR(dev);\r\n}\r\ndev->pdev = pdev;\r\npci_set_drvdata(pdev, dev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\nDRM_ERROR("failed to enable pci device: %d\n", ret);\r\ngoto err_free;\r\n}\r\nret = hibmc_load(dev);\r\nif (ret) {\r\nDRM_ERROR("failed to load hibmc: %d\n", ret);\r\ngoto err_disable;\r\n}\r\nret = drm_dev_register(dev, 0);\r\nif (ret) {\r\nDRM_ERROR("failed to register drv for userspace access: %d\n",\r\nret);\r\ngoto err_unload;\r\n}\r\nreturn 0;\r\nerr_unload:\r\nhibmc_unload(dev);\r\nerr_disable:\r\npci_disable_device(pdev);\r\nerr_free:\r\ndrm_dev_unref(dev);\r\nreturn ret;\r\n}\r\nstatic void hibmc_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\ndrm_dev_unregister(dev);\r\nhibmc_unload(dev);\r\ndrm_dev_unref(dev);\r\n}\r\nstatic int __init hibmc_init(void)\r\n{\r\nreturn pci_register_driver(&hibmc_pci_driver);\r\n}\r\nstatic void __exit hibmc_exit(void)\r\n{\r\nreturn pci_unregister_driver(&hibmc_pci_driver);\r\n}
