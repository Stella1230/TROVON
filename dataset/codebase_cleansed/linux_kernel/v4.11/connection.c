struct ptlrpc_connection *\r\nptlrpc_connection_get(lnet_process_id_t peer, lnet_nid_t self,\r\nstruct obd_uuid *uuid)\r\n{\r\nstruct ptlrpc_connection *conn, *conn2;\r\nconn = cfs_hash_lookup(conn_hash, &peer);\r\nif (conn)\r\ngoto out;\r\nconn = kzalloc(sizeof(*conn), GFP_NOFS);\r\nif (!conn)\r\nreturn NULL;\r\nconn->c_peer = peer;\r\nconn->c_self = self;\r\nINIT_HLIST_NODE(&conn->c_hash);\r\natomic_set(&conn->c_refcount, 1);\r\nif (uuid)\r\nobd_str2uuid(&conn->c_remote_uuid, uuid->uuid);\r\nconn2 = cfs_hash_findadd_unique(conn_hash, &peer, &conn->c_hash);\r\nif (conn != conn2) {\r\nkfree(conn);\r\nconn = conn2;\r\n}\r\nout:\r\nCDEBUG(D_INFO, "conn=%p refcount %d to %s\n",\r\nconn, atomic_read(&conn->c_refcount),\r\nlibcfs_nid2str(conn->c_peer.nid));\r\nreturn conn;\r\n}\r\nint ptlrpc_connection_put(struct ptlrpc_connection *conn)\r\n{\r\nint rc = 0;\r\nif (!conn)\r\nreturn rc;\r\nLASSERT(atomic_read(&conn->c_refcount) > 1);\r\nif (atomic_dec_return(&conn->c_refcount) == 1)\r\nrc = 1;\r\nCDEBUG(D_INFO, "PUT conn=%p refcount %d to %s\n",\r\nconn, atomic_read(&conn->c_refcount),\r\nlibcfs_nid2str(conn->c_peer.nid));\r\nreturn rc;\r\n}\r\nstruct ptlrpc_connection *\r\nptlrpc_connection_addref(struct ptlrpc_connection *conn)\r\n{\r\natomic_inc(&conn->c_refcount);\r\nCDEBUG(D_INFO, "conn=%p refcount %d to %s\n",\r\nconn, atomic_read(&conn->c_refcount),\r\nlibcfs_nid2str(conn->c_peer.nid));\r\nreturn conn;\r\n}\r\nint ptlrpc_connection_init(void)\r\n{\r\nconn_hash = cfs_hash_create("CONN_HASH",\r\nHASH_CONN_CUR_BITS,\r\nHASH_CONN_MAX_BITS,\r\nHASH_CONN_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&conn_hash_ops, CFS_HASH_DEFAULT);\r\nif (!conn_hash)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ptlrpc_connection_fini(void)\r\n{\r\ncfs_hash_putref(conn_hash);\r\n}\r\nstatic unsigned int\r\nconn_hashfn(struct cfs_hash *hs, const void *key, unsigned int mask)\r\n{\r\nreturn cfs_hash_djb2_hash(key, sizeof(lnet_process_id_t), mask);\r\n}\r\nstatic int\r\nconn_keycmp(const void *key, struct hlist_node *hnode)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nconst lnet_process_id_t *conn_key;\r\nLASSERT(key);\r\nconn_key = key;\r\nconn = hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\nreturn conn_key->nid == conn->c_peer.nid &&\r\nconn_key->pid == conn->c_peer.pid;\r\n}\r\nstatic void *\r\nconn_key(struct hlist_node *hnode)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nconn = hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\nreturn &conn->c_peer;\r\n}\r\nstatic void *\r\nconn_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\n}\r\nstatic void\r\nconn_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nconn = hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\natomic_inc(&conn->c_refcount);\r\n}\r\nstatic void\r\nconn_put_locked(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nconn = hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\natomic_dec(&conn->c_refcount);\r\n}\r\nstatic void\r\nconn_exit(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nconn = hlist_entry(hnode, struct ptlrpc_connection, c_hash);\r\nLASSERTF(atomic_read(&conn->c_refcount) == 0,\r\n"Busy connection with %d refs\n",\r\natomic_read(&conn->c_refcount));\r\nkfree(conn);\r\n}
