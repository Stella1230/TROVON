static irqreturn_t mtk_disp_ovl_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mtk_disp_ovl *priv = dev_id;\r\nstruct mtk_ddp_comp *ovl = &priv->ddp_comp;\r\nwritel(0x0, ovl->regs + DISP_REG_OVL_INTSTA);\r\nif (!priv->crtc)\r\nreturn IRQ_NONE;\r\nmtk_crtc_ddp_irq(priv->crtc, ovl);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mtk_ovl_enable_vblank(struct mtk_ddp_comp *comp,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct mtk_disp_ovl *priv = container_of(comp, struct mtk_disp_ovl,\r\nddp_comp);\r\npriv->crtc = crtc;\r\nwritel(0x0, comp->regs + DISP_REG_OVL_INTSTA);\r\nwritel_relaxed(OVL_FME_CPL_INT, comp->regs + DISP_REG_OVL_INTEN);\r\n}\r\nstatic void mtk_ovl_disable_vblank(struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_disp_ovl *priv = container_of(comp, struct mtk_disp_ovl,\r\nddp_comp);\r\npriv->crtc = NULL;\r\nwritel_relaxed(0x0, comp->regs + DISP_REG_OVL_INTEN);\r\n}\r\nstatic void mtk_ovl_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel_relaxed(0x1, comp->regs + DISP_REG_OVL_EN);\r\n}\r\nstatic void mtk_ovl_stop(struct mtk_ddp_comp *comp)\r\n{\r\nwritel_relaxed(0x0, comp->regs + DISP_REG_OVL_EN);\r\n}\r\nstatic void mtk_ovl_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh,\r\nunsigned int bpc)\r\n{\r\nif (w != 0 && h != 0)\r\nwritel_relaxed(h << 16 | w, comp->regs + DISP_REG_OVL_ROI_SIZE);\r\nwritel_relaxed(0x0, comp->regs + DISP_REG_OVL_ROI_BGCLR);\r\nwritel(0x1, comp->regs + DISP_REG_OVL_RST);\r\nwritel(0x0, comp->regs + DISP_REG_OVL_RST);\r\n}\r\nstatic void mtk_ovl_layer_on(struct mtk_ddp_comp *comp, unsigned int idx)\r\n{\r\nunsigned int reg;\r\nwritel(0x1, comp->regs + DISP_REG_OVL_RDMA_CTRL(idx));\r\nwritel(OVL_RDMA_MEM_GMC, comp->regs + DISP_REG_OVL_RDMA_GMC(idx));\r\nreg = readl(comp->regs + DISP_REG_OVL_SRC_CON);\r\nreg = reg | BIT(idx);\r\nwritel(reg, comp->regs + DISP_REG_OVL_SRC_CON);\r\n}\r\nstatic void mtk_ovl_layer_off(struct mtk_ddp_comp *comp, unsigned int idx)\r\n{\r\nunsigned int reg;\r\nreg = readl(comp->regs + DISP_REG_OVL_SRC_CON);\r\nreg = reg & ~BIT(idx);\r\nwritel(reg, comp->regs + DISP_REG_OVL_SRC_CON);\r\nwritel(0x0, comp->regs + DISP_REG_OVL_RDMA_CTRL(idx));\r\n}\r\nstatic unsigned int ovl_fmt_convert(unsigned int fmt)\r\n{\r\nswitch (fmt) {\r\ndefault:\r\ncase DRM_FORMAT_RGB565:\r\nreturn OVL_CON_CLRFMT_RGB565;\r\ncase DRM_FORMAT_BGR565:\r\nreturn OVL_CON_CLRFMT_RGB565 | OVL_CON_BYTE_SWAP;\r\ncase DRM_FORMAT_RGB888:\r\nreturn OVL_CON_CLRFMT_RGB888;\r\ncase DRM_FORMAT_BGR888:\r\nreturn OVL_CON_CLRFMT_RGB888 | OVL_CON_BYTE_SWAP;\r\ncase DRM_FORMAT_RGBX8888:\r\ncase DRM_FORMAT_RGBA8888:\r\nreturn OVL_CON_CLRFMT_ARGB8888;\r\ncase DRM_FORMAT_BGRX8888:\r\ncase DRM_FORMAT_BGRA8888:\r\nreturn OVL_CON_CLRFMT_ARGB8888 | OVL_CON_BYTE_SWAP;\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_ARGB8888:\r\nreturn OVL_CON_CLRFMT_RGBA8888;\r\ncase DRM_FORMAT_XBGR8888:\r\ncase DRM_FORMAT_ABGR8888:\r\nreturn OVL_CON_CLRFMT_RGBA8888 | OVL_CON_BYTE_SWAP;\r\n}\r\n}\r\nstatic void mtk_ovl_layer_config(struct mtk_ddp_comp *comp, unsigned int idx,\r\nstruct mtk_plane_state *state)\r\n{\r\nstruct mtk_plane_pending_state *pending = &state->pending;\r\nunsigned int addr = pending->addr;\r\nunsigned int pitch = pending->pitch & 0xffff;\r\nunsigned int fmt = pending->format;\r\nunsigned int offset = (pending->y << 16) | pending->x;\r\nunsigned int src_size = (pending->height << 16) | pending->width;\r\nunsigned int con;\r\nif (!pending->enable)\r\nmtk_ovl_layer_off(comp, idx);\r\ncon = ovl_fmt_convert(fmt);\r\nif (idx != 0)\r\ncon |= OVL_CON_AEN | OVL_CON_ALPHA;\r\nwritel_relaxed(con, comp->regs + DISP_REG_OVL_CON(idx));\r\nwritel_relaxed(pitch, comp->regs + DISP_REG_OVL_PITCH(idx));\r\nwritel_relaxed(src_size, comp->regs + DISP_REG_OVL_SRC_SIZE(idx));\r\nwritel_relaxed(offset, comp->regs + DISP_REG_OVL_OFFSET(idx));\r\nwritel_relaxed(addr, comp->regs + DISP_REG_OVL_ADDR(idx));\r\nif (pending->enable)\r\nmtk_ovl_layer_on(comp, idx);\r\n}\r\nstatic int mtk_disp_ovl_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct mtk_disp_ovl *priv = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\nret = mtk_ddp_comp_register(drm_dev, &priv->ddp_comp);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register component %s: %d\n",\r\ndev->of_node->full_name, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_disp_ovl_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct mtk_disp_ovl *priv = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nmtk_ddp_comp_unregister(drm_dev, &priv->ddp_comp);\r\n}\r\nstatic int mtk_disp_ovl_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_disp_ovl *priv;\r\nint comp_id;\r\nint irq;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ncomp_id = mtk_ddp_comp_get_id(dev->of_node, MTK_DISP_OVL);\r\nif (comp_id < 0) {\r\ndev_err(dev, "Failed to identify by alias: %d\n", comp_id);\r\nreturn comp_id;\r\n}\r\nret = mtk_ddp_comp_init(dev, dev->of_node, &priv->ddp_comp, comp_id,\r\n&mtk_disp_ovl_funcs);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize component: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nret = devm_request_irq(dev, irq, mtk_disp_ovl_irq_handler,\r\nIRQF_TRIGGER_NONE, dev_name(dev), priv);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request irq %d: %d\n", irq, ret);\r\nreturn ret;\r\n}\r\nret = component_add(dev, &mtk_disp_ovl_component_ops);\r\nif (ret)\r\ndev_err(dev, "Failed to add component: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mtk_disp_ovl_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &mtk_disp_ovl_component_ops);\r\nreturn 0;\r\n}
