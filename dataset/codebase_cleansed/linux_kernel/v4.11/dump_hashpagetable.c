static int calculate_pagesize(struct pg_state *st, int ps, char s[])\r\n{\r\nstatic const char units[] = "BKMGTPE";\r\nconst char *unit = units;\r\nwhile (ps > 9 && unit[1]) {\r\nps -= 10;\r\nunit++;\r\n}\r\nseq_printf(st->seq, " %s_ps: %i%c\t", s, 1<<ps, *unit);\r\nreturn ps;\r\n}\r\nstatic void dump_flag_info(struct pg_state *st, const struct flag_info\r\n*flag, u64 pte, int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++, flag++) {\r\nconst char *s = NULL;\r\nu64 val;\r\nif (flag->mask == 0)\r\ncontinue;\r\nif (flag->is_val) {\r\nval = pte & flag->val;\r\nif (flag->shift)\r\nval = val >> flag->shift;\r\nseq_printf(st->seq, " %s:%llx", flag->set, val);\r\n} else {\r\nif ((pte & flag->mask) == flag->val)\r\ns = flag->set;\r\nelse\r\ns = flag->clear;\r\nif (s)\r\nseq_printf(st->seq, " %s", s);\r\n}\r\n}\r\n}\r\nstatic void dump_hpte_info(struct pg_state *st, unsigned long ea, u64 v, u64 r,\r\nunsigned long rpn, int bps, int aps, unsigned long lp)\r\n{\r\nint aps_index;\r\nwhile (ea >= st->marker[1].start_address) {\r\nst->marker++;\r\nseq_printf(st->seq, "---[ %s ]---\n", st->marker->name);\r\n}\r\nseq_printf(st->seq, "0x%lx:\t", ea);\r\nseq_printf(st->seq, "AVPN:%llx\t", HPTE_V_AVPN_VAL(v));\r\ndump_flag_info(st, v_flag_array, v, ARRAY_SIZE(v_flag_array));\r\nseq_printf(st->seq, " rpn: %lx\t", rpn);\r\ndump_flag_info(st, r_flag_array, r, ARRAY_SIZE(r_flag_array));\r\ncalculate_pagesize(st, bps, "base");\r\naps_index = calculate_pagesize(st, aps, "actual");\r\nif (aps_index != 2)\r\nseq_printf(st->seq, "LP enc: %lx", lp);\r\nseq_puts(st->seq, "\n");\r\n}\r\nstatic int native_find(unsigned long ea, int psize, bool primary, u64 *v, u64\r\n*r)\r\n{\r\nstruct hash_pte *hptep;\r\nunsigned long hash, vsid, vpn, hpte_group, want_v, hpte_v;\r\nint i, ssize = mmu_kernel_ssize;\r\nunsigned long shift = mmu_psize_defs[psize].shift;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nhash = hpt_hash(vpn, shift, ssize);\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nif (!primary)\r\nhash = ~hash;\r\nhpte_group = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + hpte_group;\r\nhpte_v = be64_to_cpu(hptep->v);\r\nif (HPTE_V_COMPARE(hpte_v, want_v) && (hpte_v & HPTE_V_VALID)) {\r\n*v = be64_to_cpu(hptep->v);\r\n*r = be64_to_cpu(hptep->r);\r\nreturn 0;\r\n}\r\n++hpte_group;\r\n}\r\nreturn -1;\r\n}\r\nstatic int pseries_find(unsigned long ea, int psize, bool primary, u64 *v, u64 *r)\r\n{\r\nstruct hash_pte ptes[4];\r\nunsigned long vsid, vpn, hash, hpte_group, want_v;\r\nint i, j, ssize = mmu_kernel_ssize;\r\nlong lpar_rc = 0;\r\nunsigned long shift = mmu_psize_defs[psize].shift;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nhash = hpt_hash(vpn, shift, ssize);\r\nwant_v = hpte_encode_avpn(vpn, psize, ssize);\r\nif (!primary)\r\nhash = ~hash;\r\nhpte_group = ((hash & htab_hash_mask) * HPTES_PER_GROUP) & ~0x7UL;\r\nfor (i = 0; i < HPTES_PER_GROUP; i += 4, hpte_group += 4) {\r\nlpar_rc = plpar_pte_read_4(0, hpte_group, (void *)ptes);\r\nif (lpar_rc != H_SUCCESS)\r\ncontinue;\r\nfor (j = 0; j < 4; j++) {\r\nif (HPTE_V_COMPARE(ptes[j].v, want_v) &&\r\n(ptes[j].v & HPTE_V_VALID)) {\r\n*v = ptes[j].v;\r\n*r = ptes[j].r;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void decode_r(int bps, unsigned long r, unsigned long *rpn, int *aps,\r\nunsigned long *lp_bits)\r\n{\r\nstruct mmu_psize_def entry;\r\nunsigned long arpn, mask, lp;\r\nint penc = -2, idx = 0, shift;\r\narpn = (r & HPTE_R_RPN) >> HPTE_R_RPN_SHIFT;\r\nlp = arpn & 0xff;\r\nentry = mmu_psize_defs[bps];\r\nwhile (idx < MMU_PAGE_COUNT) {\r\npenc = entry.penc[idx];\r\nif ((penc != -1) && (mmu_psize_defs[idx].shift)) {\r\nshift = mmu_psize_defs[idx].shift - HPTE_R_RPN_SHIFT;\r\nmask = (0x1 << (shift)) - 1;\r\nif ((lp & mask) == penc) {\r\n*aps = mmu_psize_to_shift(idx);\r\n*lp_bits = lp & mask;\r\n*rpn = arpn >> shift;\r\nreturn;\r\n}\r\n}\r\nidx++;\r\n}\r\n}\r\nstatic int base_hpte_find(unsigned long ea, int psize, bool primary, u64 *v,\r\nu64 *r)\r\n{\r\n#ifdef CONFIG_PPC_PSERIES\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\nreturn pseries_find(ea, psize, primary, v, r);\r\n#endif\r\nreturn native_find(ea, psize, primary, v, r);\r\n}\r\nstatic unsigned long hpte_find(struct pg_state *st, unsigned long ea, int psize)\r\n{\r\nunsigned long slot;\r\nu64 v = 0, r = 0;\r\nunsigned long rpn, lp_bits;\r\nint base_psize = 0, actual_psize = 0;\r\nif (ea <= PAGE_OFFSET)\r\nreturn -1;\r\nslot = base_hpte_find(ea, psize, true, &v, &r);\r\nif (slot == -1)\r\nslot = base_hpte_find(ea, psize, true, &v, &r);\r\nif (slot == -1)\r\nreturn -1;\r\nbase_psize = mmu_psize_to_shift(psize);\r\nif ((v & HPTE_V_LARGE) == HPTE_V_LARGE) {\r\ndecode_r(psize, r, &rpn, &actual_psize, &lp_bits);\r\n} else {\r\nactual_psize = 12;\r\nrpn = (r & HPTE_R_RPN) >> HPTE_R_RPN_SHIFT;\r\nlp_bits = -1;\r\n}\r\nif (actual_psize == -1)\r\nreturn -1;\r\ndump_hpte_info(st, ea, v, r, rpn, base_psize, actual_psize, lp_bits);\r\nreturn 0;\r\n}\r\nstatic void walk_pte(struct pg_state *st, pmd_t *pmd, unsigned long start)\r\n{\r\npte_t *pte = pte_offset_kernel(pmd, 0);\r\nunsigned long addr, pteval, psize;\r\nint i, status;\r\nfor (i = 0; i < PTRS_PER_PTE; i++, pte++) {\r\naddr = start + i * PAGE_SIZE;\r\npteval = pte_val(*pte);\r\nif (addr < VMALLOC_END)\r\npsize = mmu_vmalloc_psize;\r\nelse\r\npsize = mmu_io_psize;\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nif (((pteval & H_PAGE_COMBO) == H_PAGE_COMBO) ||\r\n((pteval & H_PAGE_4K_PFN) == H_PAGE_4K_PFN))\r\npsize = mmu_io_psize;\r\n#endif\r\nstatus = hpte_find(st, addr, psize);\r\nif (((pteval & H_PAGE_HASHPTE) != H_PAGE_HASHPTE)\r\n&& (status != -1)) {\r\nseq_printf(st->seq, "page probably bolted before linux"\r\n" pagetables were set: addr:%lx, pteval:%lx\n",\r\naddr, pteval);\r\n}\r\n}\r\n}\r\nstatic void walk_pmd(struct pg_state *st, pud_t *pud, unsigned long start)\r\n{\r\npmd_t *pmd = pmd_offset(pud, 0);\r\nunsigned long addr;\r\nunsigned int i;\r\nfor (i = 0; i < PTRS_PER_PMD; i++, pmd++) {\r\naddr = start + i * PMD_SIZE;\r\nif (!pmd_none(*pmd))\r\nwalk_pte(st, pmd, addr);\r\n}\r\n}\r\nstatic void walk_pud(struct pg_state *st, pgd_t *pgd, unsigned long start)\r\n{\r\npud_t *pud = pud_offset(pgd, 0);\r\nunsigned long addr;\r\nunsigned int i;\r\nfor (i = 0; i < PTRS_PER_PUD; i++, pud++) {\r\naddr = start + i * PUD_SIZE;\r\nif (!pud_none(*pud))\r\nwalk_pmd(st, pud, addr);\r\n}\r\n}\r\nstatic void walk_pagetables(struct pg_state *st)\r\n{\r\npgd_t *pgd = pgd_offset_k(0UL);\r\nunsigned int i;\r\nunsigned long addr;\r\nfor (i = 0; i < PTRS_PER_PGD; i++, pgd++) {\r\naddr = KERN_VIRT_START + i * PGDIR_SIZE;\r\nif (!pgd_none(*pgd))\r\nwalk_pud(st, pgd, addr);\r\n}\r\n}\r\nstatic void walk_linearmapping(struct pg_state *st)\r\n{\r\nunsigned long addr;\r\nunsigned long psize = 1 << mmu_psize_defs[mmu_linear_psize].shift;\r\nfor (addr = PAGE_OFFSET; addr < PAGE_OFFSET +\r\nmemblock_phys_mem_size(); addr += psize)\r\nhpte_find(st, addr, mmu_linear_psize);\r\n}\r\nstatic void walk_vmemmap(struct pg_state *st)\r\n{\r\n#ifdef CONFIG_SPARSEMEM_VMEMMAP\r\nstruct vmemmap_backing *ptr = vmemmap_list;\r\nwhile (ptr->list) {\r\nhpte_find(st, ptr->virt_addr, mmu_vmemmap_psize);\r\nptr = ptr->list;\r\n}\r\nseq_puts(st->seq, "---[ vmemmap end ]---\n");\r\n#endif\r\n}\r\nstatic void populate_markers(void)\r\n{\r\naddress_markers[0].start_address = PAGE_OFFSET;\r\naddress_markers[1].start_address = VMALLOC_START;\r\naddress_markers[2].start_address = VMALLOC_END;\r\naddress_markers[3].start_address = ISA_IO_BASE;\r\naddress_markers[4].start_address = ISA_IO_END;\r\naddress_markers[5].start_address = PHB_IO_BASE;\r\naddress_markers[6].start_address = PHB_IO_END;\r\naddress_markers[7].start_address = IOREMAP_BASE;\r\naddress_markers[8].start_address = IOREMAP_END;\r\n#ifdef CONFIG_PPC_STD_MMU_64\r\naddress_markers[9].start_address = H_VMEMMAP_BASE;\r\n#else\r\naddress_markers[9].start_address = VMEMMAP_BASE;\r\n#endif\r\n}\r\nstatic int ptdump_show(struct seq_file *m, void *v)\r\n{\r\nstruct pg_state st = {\r\n.seq = m,\r\n.start_address = PAGE_OFFSET,\r\n.marker = address_markers,\r\n};\r\nwalk_linearmapping(&st);\r\nwalk_pagetables(&st);\r\nwalk_vmemmap(&st);\r\nreturn 0;\r\n}\r\nstatic int ptdump_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ptdump_show, NULL);\r\n}\r\nstatic int ptdump_init(void)\r\n{\r\nstruct dentry *debugfs_file;\r\nif (!radix_enabled()) {\r\npopulate_markers();\r\ndebugfs_file = debugfs_create_file("kernel_hash_pagetable",\r\n0400, NULL, NULL, &ptdump_fops);\r\nreturn debugfs_file ? 0 : -ENOMEM;\r\n}\r\nreturn 0;\r\n}
