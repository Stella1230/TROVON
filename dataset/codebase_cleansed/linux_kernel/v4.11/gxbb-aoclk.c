static int gxbb_aoclk_do_reset(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct gxbb_aoclk_reset_controller *reset =\r\ncontainer_of(rcdev, struct gxbb_aoclk_reset_controller, reset);\r\nwritel(BIT(reset->data[id]), reset->base);\r\nreturn 0;\r\n}\r\nstatic int gxbb_aoclkc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret, clkid;\r\nstruct device *dev = &pdev->dev;\r\nstruct gxbb_aoclk_reset_controller *rstc;\r\nrstc = devm_kzalloc(dev, sizeof(*rstc), GFP_KERNEL);\r\nif (!rstc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nrstc->base = base;\r\nrstc->data = gxbb_aoclk_reset;\r\nrstc->reset.ops = &gxbb_aoclk_reset_ops;\r\nrstc->reset.nr_resets = ARRAY_SIZE(gxbb_aoclk_reset);\r\nrstc->reset.of_node = dev->of_node;\r\nret = devm_reset_controller_register(dev, &rstc->reset);\r\nfor (clkid = 0; clkid < gxbb_aoclk_onecell_data.num; clkid++) {\r\ngxbb_aoclk_gate[clkid]->reg = base;\r\nret = devm_clk_hw_register(dev,\r\ngxbb_aoclk_onecell_data.hws[clkid]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\r\n&gxbb_aoclk_onecell_data);\r\n}
