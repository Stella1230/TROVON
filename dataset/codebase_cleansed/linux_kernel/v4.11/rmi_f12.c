static int rmi_f12_read_sensor_tuning(struct f12_data *f12)\r\n{\r\nconst struct rmi_register_desc_item *item;\r\nstruct rmi_2d_sensor *sensor = &f12->sensor;\r\nstruct rmi_function *fn = sensor->fn;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nint ret;\r\nint offset;\r\nu8 buf[15];\r\nint pitch_x = 0;\r\nint pitch_y = 0;\r\nint rx_receivers = 0;\r\nint tx_receivers = 0;\r\nint sensor_flags = 0;\r\nitem = rmi_get_register_desc_item(&f12->control_reg_desc, 8);\r\nif (!item) {\r\ndev_err(&fn->dev,\r\n"F12 does not have the sensor tuning control register\n");\r\nreturn -ENODEV;\r\n}\r\noffset = rmi_register_desc_calc_reg_offset(&f12->control_reg_desc, 8);\r\nif (item->reg_size > sizeof(buf)) {\r\ndev_err(&fn->dev,\r\n"F12 control8 should be no bigger than %zd bytes, not: %ld\n",\r\nsizeof(buf), item->reg_size);\r\nreturn -ENODEV;\r\n}\r\nret = rmi_read_block(rmi_dev, fn->fd.control_base_addr + offset, buf,\r\nitem->reg_size);\r\nif (ret)\r\nreturn ret;\r\noffset = 0;\r\nif (rmi_register_desc_has_subpacket(item, 0)) {\r\nsensor->max_x = (buf[offset + 1] << 8) | buf[offset];\r\nsensor->max_y = (buf[offset + 3] << 8) | buf[offset + 2];\r\noffset += 4;\r\n}\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "%s: max_x: %d max_y: %d\n", __func__,\r\nsensor->max_x, sensor->max_y);\r\nif (rmi_register_desc_has_subpacket(item, 1)) {\r\npitch_x = (buf[offset + 1] << 8) | buf[offset];\r\npitch_y = (buf[offset + 3] << 8) | buf[offset + 2];\r\noffset += 4;\r\n}\r\nif (rmi_register_desc_has_subpacket(item, 2)) {\r\nsensor->axis_align.clip_x_low = buf[offset];\r\nsensor->axis_align.clip_x_high = sensor->max_x\r\n- buf[offset + 1];\r\nsensor->axis_align.clip_y_low = buf[offset + 2];\r\nsensor->axis_align.clip_y_high = sensor->max_y\r\n- buf[offset + 3];\r\noffset += 4;\r\n}\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "%s: x low: %d x high: %d y low: %d y high: %d\n",\r\n__func__,\r\nsensor->axis_align.clip_x_low, sensor->axis_align.clip_x_high,\r\nsensor->axis_align.clip_y_low, sensor->axis_align.clip_y_high);\r\nif (rmi_register_desc_has_subpacket(item, 3)) {\r\nrx_receivers = buf[offset];\r\ntx_receivers = buf[offset + 1];\r\noffset += 2;\r\n}\r\nif (rmi_register_desc_has_subpacket(item, 4)) {\r\nsensor_flags = buf[offset];\r\noffset += 1;\r\n}\r\nsensor->x_mm = (pitch_x * rx_receivers) >> 12;\r\nsensor->y_mm = (pitch_y * tx_receivers) >> 12;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "%s: x_mm: %d y_mm: %d\n", __func__,\r\nsensor->x_mm, sensor->y_mm);\r\nreturn 0;\r\n}\r\nstatic void rmi_f12_process_objects(struct f12_data *f12, u8 *data1, int size)\r\n{\r\nint i;\r\nstruct rmi_2d_sensor *sensor = &f12->sensor;\r\nint objects = f12->data1->num_subpackets;\r\nif ((f12->data1->num_subpackets * F12_DATA1_BYTES_PER_OBJ) > size)\r\nobjects = size / F12_DATA1_BYTES_PER_OBJ;\r\nfor (i = 0; i < objects; i++) {\r\nstruct rmi_2d_sensor_abs_object *obj = &sensor->objs[i];\r\nobj->type = RMI_2D_OBJECT_NONE;\r\nobj->mt_tool = MT_TOOL_FINGER;\r\nswitch (data1[0]) {\r\ncase RMI_F12_OBJECT_FINGER:\r\nobj->type = RMI_2D_OBJECT_FINGER;\r\nbreak;\r\ncase RMI_F12_OBJECT_STYLUS:\r\nobj->type = RMI_2D_OBJECT_STYLUS;\r\nobj->mt_tool = MT_TOOL_PEN;\r\nbreak;\r\ncase RMI_F12_OBJECT_PALM:\r\nobj->type = RMI_2D_OBJECT_PALM;\r\nobj->mt_tool = MT_TOOL_PALM;\r\nbreak;\r\ncase RMI_F12_OBJECT_UNCLASSIFIED:\r\nobj->type = RMI_2D_OBJECT_UNCLASSIFIED;\r\nbreak;\r\n}\r\nobj->x = (data1[2] << 8) | data1[1];\r\nobj->y = (data1[4] << 8) | data1[3];\r\nobj->z = data1[5];\r\nobj->wx = data1[6];\r\nobj->wy = data1[7];\r\nrmi_2d_sensor_abs_process(sensor, obj, i);\r\ndata1 += F12_DATA1_BYTES_PER_OBJ;\r\n}\r\nif (sensor->kernel_tracking)\r\ninput_mt_assign_slots(sensor->input,\r\nsensor->tracking_slots,\r\nsensor->tracking_pos,\r\nsensor->nbr_fingers,\r\nsensor->dmax);\r\nfor (i = 0; i < objects; i++)\r\nrmi_2d_sensor_abs_report(sensor, &sensor->objs[i], i);\r\n}\r\nstatic int rmi_f12_attention(struct rmi_function *fn,\r\nunsigned long *irq_nr_regs)\r\n{\r\nint retval;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\r\nstruct f12_data *f12 = dev_get_drvdata(&fn->dev);\r\nstruct rmi_2d_sensor *sensor = &f12->sensor;\r\nint valid_bytes = sensor->pkt_size;\r\nif (drvdata->attn_data.data) {\r\nif (sensor->attn_size > drvdata->attn_data.size)\r\nvalid_bytes = drvdata->attn_data.size;\r\nelse\r\nvalid_bytes = sensor->attn_size;\r\nmemcpy(sensor->data_pkt, drvdata->attn_data.data,\r\nvalid_bytes);\r\ndrvdata->attn_data.data += sensor->attn_size;\r\ndrvdata->attn_data.size -= sensor->attn_size;\r\n} else {\r\nretval = rmi_read_block(rmi_dev, f12->data_addr,\r\nsensor->data_pkt, sensor->pkt_size);\r\nif (retval < 0) {\r\ndev_err(&fn->dev, "Failed to read object data. Code: %d.\n",\r\nretval);\r\nreturn retval;\r\n}\r\n}\r\nif (f12->data1)\r\nrmi_f12_process_objects(f12,\r\n&sensor->data_pkt[f12->data1_offset], valid_bytes);\r\ninput_mt_sync_frame(sensor->input);\r\nreturn 0;\r\n}\r\nstatic int rmi_f12_write_control_regs(struct rmi_function *fn)\r\n{\r\nint ret;\r\nconst struct rmi_register_desc_item *item;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nstruct f12_data *f12 = dev_get_drvdata(&fn->dev);\r\nint control_size;\r\nchar buf[3];\r\nu16 control_offset = 0;\r\nu8 subpacket_offset = 0;\r\nif (f12->has_dribble\r\n&& (f12->sensor.dribble != RMI_REG_STATE_DEFAULT)) {\r\nitem = rmi_get_register_desc_item(&f12->control_reg_desc, 20);\r\nif (item) {\r\ncontrol_offset = rmi_register_desc_calc_reg_offset(\r\n&f12->control_reg_desc, 20);\r\ncontrol_size = min(item->reg_size, 3UL);\r\nret = rmi_read_block(rmi_dev, fn->fd.control_base_addr\r\n+ control_offset, buf, control_size);\r\nif (ret)\r\nreturn ret;\r\nif (rmi_register_desc_has_subpacket(item, 0))\r\nsubpacket_offset += 1;\r\nswitch (f12->sensor.dribble) {\r\ncase RMI_REG_STATE_OFF:\r\nbuf[subpacket_offset] &= ~BIT(2);\r\nbreak;\r\ncase RMI_REG_STATE_ON:\r\nbuf[subpacket_offset] |= BIT(2);\r\nbreak;\r\ncase RMI_REG_STATE_DEFAULT:\r\ndefault:\r\nbreak;\r\n}\r\nret = rmi_write_block(rmi_dev,\r\nfn->fd.control_base_addr + control_offset,\r\nbuf, control_size);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rmi_f12_config(struct rmi_function *fn)\r\n{\r\nstruct rmi_driver *drv = fn->rmi_dev->driver;\r\nint ret;\r\ndrv->set_irq_bits(fn->rmi_dev, fn->irq_mask);\r\nret = rmi_f12_write_control_regs(fn);\r\nif (ret)\r\ndev_warn(&fn->dev,\r\n"Failed to write F12 control registers: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int rmi_f12_probe(struct rmi_function *fn)\r\n{\r\nstruct f12_data *f12;\r\nint ret;\r\nstruct rmi_device *rmi_dev = fn->rmi_dev;\r\nchar buf;\r\nu16 query_addr = fn->fd.query_base_addr;\r\nconst struct rmi_register_desc_item *item;\r\nstruct rmi_2d_sensor *sensor;\r\nstruct rmi_device_platform_data *pdata = rmi_get_platform_data(rmi_dev);\r\nstruct rmi_driver_data *drvdata = dev_get_drvdata(&rmi_dev->dev);\r\nu16 data_offset = 0;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "%s\n", __func__);\r\nret = rmi_read(fn->rmi_dev, query_addr, &buf);\r\nif (ret < 0) {\r\ndev_err(&fn->dev, "Failed to read general info register: %d\n",\r\nret);\r\nreturn -ENODEV;\r\n}\r\n++query_addr;\r\nif (!(buf & BIT(0))) {\r\ndev_err(&fn->dev,\r\n"Behavior of F12 without register descriptors is undefined.\n");\r\nreturn -ENODEV;\r\n}\r\nf12 = devm_kzalloc(&fn->dev, sizeof(struct f12_data), GFP_KERNEL);\r\nif (!f12)\r\nreturn -ENOMEM;\r\nf12->has_dribble = !!(buf & BIT(3));\r\nif (fn->dev.of_node) {\r\nret = rmi_2d_sensor_of_probe(&fn->dev, &f12->sensor_pdata);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nf12->sensor_pdata = pdata->sensor_pdata;\r\n}\r\nret = rmi_read_register_desc(rmi_dev, query_addr,\r\n&f12->query_reg_desc);\r\nif (ret) {\r\ndev_err(&fn->dev,\r\n"Failed to read the Query Register Descriptor: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nquery_addr += 3;\r\nret = rmi_read_register_desc(rmi_dev, query_addr,\r\n&f12->control_reg_desc);\r\nif (ret) {\r\ndev_err(&fn->dev,\r\n"Failed to read the Control Register Descriptor: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nquery_addr += 3;\r\nret = rmi_read_register_desc(rmi_dev, query_addr,\r\n&f12->data_reg_desc);\r\nif (ret) {\r\ndev_err(&fn->dev,\r\n"Failed to read the Data Register Descriptor: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nquery_addr += 3;\r\nsensor = &f12->sensor;\r\nsensor->fn = fn;\r\nf12->data_addr = fn->fd.data_base_addr;\r\nsensor->pkt_size = rmi_register_desc_calc_size(&f12->data_reg_desc);\r\nsensor->axis_align =\r\nf12->sensor_pdata.axis_align;\r\nsensor->x_mm = f12->sensor_pdata.x_mm;\r\nsensor->y_mm = f12->sensor_pdata.y_mm;\r\nsensor->dribble = f12->sensor_pdata.dribble;\r\nif (sensor->sensor_type == rmi_sensor_default)\r\nsensor->sensor_type =\r\nf12->sensor_pdata.sensor_type;\r\nrmi_dbg(RMI_DEBUG_FN, &fn->dev, "%s: data packet size: %d\n", __func__,\r\nsensor->pkt_size);\r\nsensor->data_pkt = devm_kzalloc(&fn->dev, sensor->pkt_size, GFP_KERNEL);\r\nif (!sensor->data_pkt)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&fn->dev, f12);\r\nret = rmi_f12_read_sensor_tuning(f12);\r\nif (ret)\r\nreturn ret;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 0);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 1);\r\nif (item) {\r\nf12->data1 = item;\r\nf12->data1_offset = data_offset;\r\ndata_offset += item->reg_size;\r\nsensor->nbr_fingers = item->num_subpackets;\r\nsensor->report_abs = 1;\r\nsensor->attn_size += item->reg_size;\r\n}\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 2);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 3);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 4);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 5);\r\nif (item) {\r\nf12->data5 = item;\r\nf12->data5_offset = data_offset;\r\ndata_offset += item->reg_size;\r\nsensor->attn_size += item->reg_size;\r\n}\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 6);\r\nif (item && !drvdata->attn_data.data) {\r\nf12->data6 = item;\r\nf12->data6_offset = data_offset;\r\ndata_offset += item->reg_size;\r\n}\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 7);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 8);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 9);\r\nif (item && !drvdata->attn_data.data) {\r\nf12->data9 = item;\r\nf12->data9_offset = data_offset;\r\ndata_offset += item->reg_size;\r\nif (!sensor->report_abs)\r\nsensor->report_rel = 1;\r\n}\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 10);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 11);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 12);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 13);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 14);\r\nif (item && !drvdata->attn_data.data)\r\ndata_offset += item->reg_size;\r\nitem = rmi_get_register_desc_item(&f12->data_reg_desc, 15);\r\nif (item && !drvdata->attn_data.data) {\r\nf12->data15 = item;\r\nf12->data15_offset = data_offset;\r\ndata_offset += item->reg_size;\r\n}\r\nsensor->tracking_pos = devm_kzalloc(&fn->dev,\r\nsizeof(struct input_mt_pos) * sensor->nbr_fingers,\r\nGFP_KERNEL);\r\nsensor->tracking_slots = devm_kzalloc(&fn->dev,\r\nsizeof(int) * sensor->nbr_fingers, GFP_KERNEL);\r\nsensor->objs = devm_kzalloc(&fn->dev,\r\nsizeof(struct rmi_2d_sensor_abs_object)\r\n* sensor->nbr_fingers, GFP_KERNEL);\r\nif (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)\r\nreturn -ENOMEM;\r\nret = rmi_2d_sensor_configure_input(fn, sensor);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
