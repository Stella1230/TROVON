static inline bool nft_overquota(struct nft_quota *priv,\r\nconst struct sk_buff *skb)\r\n{\r\nreturn atomic64_add_return(skb->len, &priv->consumed) >= priv->quota;\r\n}\r\nstatic inline bool nft_quota_invert(struct nft_quota *priv)\r\n{\r\nreturn priv->flags & NFT_QUOTA_F_INV;\r\n}\r\nstatic inline void nft_quota_do_eval(struct nft_quota *priv,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nif (nft_overquota(priv, pkt->skb) ^ nft_quota_invert(priv))\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic void nft_quota_obj_eval(struct nft_object *obj,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_quota *priv = nft_obj_data(obj);\r\nbool overquota;\r\noverquota = nft_overquota(priv, pkt->skb);\r\nif (overquota ^ nft_quota_invert(priv))\r\nregs->verdict.code = NFT_BREAK;\r\nif (overquota &&\r\n!test_and_set_bit(NFT_QUOTA_DEPLETED_BIT, &priv->flags))\r\nnft_obj_notify(nft_net(pkt), obj->table, obj, 0, 0,\r\nNFT_MSG_NEWOBJ, nft_pf(pkt), 0, GFP_ATOMIC);\r\n}\r\nstatic int nft_quota_do_init(const struct nlattr * const tb[],\r\nstruct nft_quota *priv)\r\n{\r\nunsigned long flags = 0;\r\nu64 quota, consumed = 0;\r\nif (!tb[NFTA_QUOTA_BYTES])\r\nreturn -EINVAL;\r\nquota = be64_to_cpu(nla_get_be64(tb[NFTA_QUOTA_BYTES]));\r\nif (quota > S64_MAX)\r\nreturn -EOVERFLOW;\r\nif (tb[NFTA_QUOTA_CONSUMED]) {\r\nconsumed = be64_to_cpu(nla_get_be64(tb[NFTA_QUOTA_CONSUMED]));\r\nif (consumed > quota)\r\nreturn -EINVAL;\r\n}\r\nif (tb[NFTA_QUOTA_FLAGS]) {\r\nflags = ntohl(nla_get_be32(tb[NFTA_QUOTA_FLAGS]));\r\nif (flags & ~NFT_QUOTA_F_INV)\r\nreturn -EINVAL;\r\nif (flags & NFT_QUOTA_F_DEPLETED)\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->quota = quota;\r\npriv->flags = flags;\r\natomic64_set(&priv->consumed, consumed);\r\nreturn 0;\r\n}\r\nstatic int nft_quota_obj_init(const struct nlattr * const tb[],\r\nstruct nft_object *obj)\r\n{\r\nstruct nft_quota *priv = nft_obj_data(obj);\r\nreturn nft_quota_do_init(tb, priv);\r\n}\r\nstatic int nft_quota_do_dump(struct sk_buff *skb, struct nft_quota *priv,\r\nbool reset)\r\n{\r\nu64 consumed, consumed_cap;\r\nu32 flags = priv->flags;\r\nconsumed = atomic64_read(&priv->consumed);\r\nif (consumed >= priv->quota) {\r\nconsumed_cap = priv->quota;\r\nflags |= NFT_QUOTA_F_DEPLETED;\r\n} else {\r\nconsumed_cap = consumed;\r\n}\r\nif (nla_put_be64(skb, NFTA_QUOTA_BYTES, cpu_to_be64(priv->quota),\r\nNFTA_QUOTA_PAD) ||\r\nnla_put_be64(skb, NFTA_QUOTA_CONSUMED, cpu_to_be64(consumed_cap),\r\nNFTA_QUOTA_PAD) ||\r\nnla_put_be32(skb, NFTA_QUOTA_FLAGS, htonl(flags)))\r\ngoto nla_put_failure;\r\nif (reset) {\r\natomic64_sub(consumed, &priv->consumed);\r\nclear_bit(NFT_QUOTA_DEPLETED_BIT, &priv->flags);\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_quota_obj_dump(struct sk_buff *skb, struct nft_object *obj,\r\nbool reset)\r\n{\r\nstruct nft_quota *priv = nft_obj_data(obj);\r\nreturn nft_quota_do_dump(skb, priv, reset);\r\n}\r\nstatic void nft_quota_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_quota *priv = nft_expr_priv(expr);\r\nnft_quota_do_eval(priv, regs, pkt);\r\n}\r\nstatic int nft_quota_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_quota *priv = nft_expr_priv(expr);\r\nreturn nft_quota_do_init(tb, priv);\r\n}\r\nstatic int nft_quota_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nstruct nft_quota *priv = nft_expr_priv(expr);\r\nreturn nft_quota_do_dump(skb, priv, false);\r\n}\r\nstatic int __init nft_quota_module_init(void)\r\n{\r\nint err;\r\nerr = nft_register_obj(&nft_quota_obj);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_register_expr(&nft_quota_type);\r\nif (err < 0)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nnft_unregister_obj(&nft_quota_obj);\r\nreturn err;\r\n}\r\nstatic void __exit nft_quota_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_quota_type);\r\nnft_unregister_obj(&nft_quota_obj);\r\n}
