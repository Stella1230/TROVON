static bool skl_check_fw_status(struct sst_dsp *ctx, u32 status)\r\n{\r\nu32 cur_sts;\r\ncur_sts = sst_dsp_shim_read(ctx, SKL_ADSP_FW_STATUS) & SKL_FW_STS_MASK;\r\nreturn (cur_sts == status);\r\n}\r\nstatic int skl_transfer_firmware(struct sst_dsp *ctx,\r\nconst void *basefw, u32 base_fw_size)\r\n{\r\nint ret = 0;\r\nret = ctx->cl_dev.ops.cl_copy_to_dmabuf(ctx, basefw, base_fw_size);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sst_dsp_register_poll(ctx,\r\nSKL_ADSP_FW_STATUS,\r\nSKL_FW_STS_MASK,\r\nSKL_FW_RFW_START,\r\nSKL_BASEFW_TIMEOUT,\r\n"Firmware boot");\r\nctx->cl_dev.ops.cl_stop_dma(ctx);\r\nreturn ret;\r\n}\r\nstatic int skl_load_base_firmware(struct sst_dsp *ctx)\r\n{\r\nint ret = 0, i;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nstruct firmware stripped_fw;\r\nu32 reg;\r\nskl->boot_complete = false;\r\ninit_waitqueue_head(&skl->boot_wait);\r\nif (ctx->fw == NULL) {\r\nret = request_firmware(&ctx->fw, ctx->fw_name, ctx->dev);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Request firmware failed %d\n", ret);\r\nreturn -EIO;\r\n}\r\n}\r\nif (skl->is_first_boot) {\r\nret = snd_skl_parse_uuids(ctx, ctx->fw, SKL_ADSP_FW_BIN_HDR_OFFSET, 0);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "UUID parsing err: %d\n", ret);\r\nrelease_firmware(ctx->fw);\r\nskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\r\nreturn ret;\r\n}\r\n}\r\nstripped_fw.data = ctx->fw->data;\r\nstripped_fw.size = ctx->fw->size;\r\nskl_dsp_strip_extended_manifest(&stripped_fw);\r\nret = skl_dsp_boot(ctx);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Boot dsp core failed ret: %d\n", ret);\r\ngoto skl_load_base_firmware_failed;\r\n}\r\nret = skl_cldma_prepare(ctx);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "CL dma prepare failed : %d\n", ret);\r\ngoto skl_load_base_firmware_failed;\r\n}\r\nskl_ipc_int_enable(ctx);\r\nskl_ipc_op_int_enable(ctx);\r\nfor (i = SKL_INIT_TIMEOUT; i > 0; --i) {\r\nif (skl_check_fw_status(ctx, SKL_FW_INIT)) {\r\ndev_dbg(ctx->dev,\r\n"ROM loaded, we can continue with FW loading\n");\r\nbreak;\r\n}\r\nmdelay(1);\r\n}\r\nif (!i) {\r\nreg = sst_dsp_shim_read(ctx, SKL_ADSP_FW_STATUS);\r\ndev_err(ctx->dev,\r\n"Timeout waiting for ROM init done, reg:0x%x\n", reg);\r\nret = -EIO;\r\ngoto transfer_firmware_failed;\r\n}\r\nret = skl_transfer_firmware(ctx, stripped_fw.data, stripped_fw.size);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Transfer firmware failed%d\n", ret);\r\ngoto transfer_firmware_failed;\r\n} else {\r\nret = wait_event_timeout(skl->boot_wait, skl->boot_complete,\r\nmsecs_to_jiffies(SKL_IPC_BOOT_MSECS));\r\nif (ret == 0) {\r\ndev_err(ctx->dev, "DSP boot failed, FW Ready timed-out\n");\r\nret = -EIO;\r\ngoto transfer_firmware_failed;\r\n}\r\ndev_dbg(ctx->dev, "Download firmware successful%d\n", ret);\r\nskl->fw_loaded = true;\r\n}\r\nreturn 0;\r\ntransfer_firmware_failed:\r\nctx->cl_dev.ops.cl_cleanup_controller(ctx);\r\nskl_load_base_firmware_failed:\r\nskl_dsp_disable_core(ctx, SKL_DSP_CORE0_MASK);\r\nrelease_firmware(ctx->fw);\r\nctx->fw = NULL;\r\nreturn ret;\r\n}\r\nstatic int skl_set_dsp_D0(struct sst_dsp *ctx, unsigned int core_id)\r\n{\r\nint ret;\r\nstruct skl_ipc_dxstate_info dx;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\r\nif (core_id == SKL_DSP_CORE0_ID) {\r\nret = skl_load_base_firmware(ctx);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "unable to load firmware\n");\r\nreturn ret;\r\n}\r\n}\r\nif (core_id != SKL_DSP_CORE0_ID) {\r\nret = skl_dsp_enable_core(ctx, core_mask);\r\nif (ret < 0)\r\nreturn ret;\r\ndx.core_mask = core_mask;\r\ndx.dx_mask = core_mask;\r\nret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID,\r\nSKL_BASE_FW_MODULE_ID, &dx);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Failed to set dsp to D0:core id= %d\n",\r\ncore_id);\r\nskl_dsp_disable_core(ctx, core_mask);\r\n}\r\n}\r\nskl->cores.state[core_id] = SKL_DSP_RUNNING;\r\nreturn ret;\r\n}\r\nstatic int skl_set_dsp_D3(struct sst_dsp *ctx, unsigned int core_id)\r\n{\r\nint ret;\r\nstruct skl_ipc_dxstate_info dx;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nunsigned int core_mask = SKL_DSP_CORE_MASK(core_id);\r\ndx.core_mask = core_mask;\r\ndx.dx_mask = SKL_IPC_D3_MASK;\r\nret = skl_ipc_set_dx(&skl->ipc, SKL_INSTANCE_ID, SKL_BASE_FW_MODULE_ID, &dx);\r\nif (ret < 0)\r\ndev_err(ctx->dev, "set Dx core %d fail: %d\n", core_id, ret);\r\nif (core_id == SKL_DSP_CORE0_ID) {\r\nctx->cl_dev.ops.cl_cleanup_controller(ctx);\r\nskl_cldma_int_disable(ctx);\r\nskl_ipc_op_int_disable(ctx);\r\nskl_ipc_int_disable(ctx);\r\n}\r\nret = skl_dsp_disable_core(ctx, core_mask);\r\nif (ret < 0)\r\nreturn ret;\r\nskl->cores.state[core_id] = SKL_DSP_RESET;\r\nreturn ret;\r\n}\r\nstatic unsigned int skl_get_errorcode(struct sst_dsp *ctx)\r\n{\r\nreturn sst_dsp_shim_read(ctx, SKL_ADSP_ERROR_CODE);\r\n}\r\nstatic int skl_get_module(struct sst_dsp *ctx, u16 mod_id)\r\n{\r\nstruct skl_module_table *module;\r\nlist_for_each_entry(module, &ctx->module_list, list) {\r\nif (module->mod_info->mod_id == mod_id)\r\nreturn ++module->usage_cnt;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int skl_put_module(struct sst_dsp *ctx, u16 mod_id)\r\n{\r\nstruct skl_module_table *module;\r\nlist_for_each_entry(module, &ctx->module_list, list) {\r\nif (module->mod_info->mod_id == mod_id)\r\nreturn --module->usage_cnt;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct skl_module_table *skl_fill_module_table(struct sst_dsp *ctx,\r\nchar *mod_name, int mod_id)\r\n{\r\nconst struct firmware *fw;\r\nstruct skl_module_table *skl_module;\r\nunsigned int size;\r\nint ret;\r\nret = request_firmware(&fw, mod_name, ctx->dev);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Request Module %s failed :%d\n",\r\nmod_name, ret);\r\nreturn NULL;\r\n}\r\nskl_module = devm_kzalloc(ctx->dev, sizeof(*skl_module), GFP_KERNEL);\r\nif (skl_module == NULL) {\r\nrelease_firmware(fw);\r\nreturn NULL;\r\n}\r\nsize = sizeof(*skl_module->mod_info);\r\nskl_module->mod_info = devm_kzalloc(ctx->dev, size, GFP_KERNEL);\r\nif (skl_module->mod_info == NULL) {\r\nrelease_firmware(fw);\r\nreturn NULL;\r\n}\r\nskl_module->mod_info->mod_id = mod_id;\r\nskl_module->mod_info->fw = fw;\r\nlist_add(&skl_module->list, &ctx->module_list);\r\nreturn skl_module;\r\n}\r\nstatic struct skl_module_table *skl_module_get_from_id(\r\nstruct sst_dsp *ctx, u16 mod_id)\r\n{\r\nstruct skl_module_table *module;\r\nif (list_empty(&ctx->module_list)) {\r\ndev_err(ctx->dev, "Module list is empty\n");\r\nreturn NULL;\r\n}\r\nlist_for_each_entry(module, &ctx->module_list, list) {\r\nif (module->mod_info->mod_id == mod_id)\r\nreturn module;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int skl_transfer_module(struct sst_dsp *ctx,\r\nstruct skl_load_module_info *module)\r\n{\r\nint ret;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nret = ctx->cl_dev.ops.cl_copy_to_dmabuf(ctx, module->fw->data,\r\nmodule->fw->size);\r\nif (ret < 0)\r\nreturn ret;\r\nret = skl_ipc_load_modules(&skl->ipc, SKL_NUM_MODULES,\r\n(void *)&module->mod_id);\r\nif (ret < 0)\r\ndev_err(ctx->dev, "Failed to Load module: %d\n", ret);\r\nctx->cl_dev.ops.cl_stop_dma(ctx);\r\nreturn ret;\r\n}\r\nstatic int skl_load_module(struct sst_dsp *ctx, u16 mod_id, u8 *guid)\r\n{\r\nstruct skl_module_table *module_entry = NULL;\r\nint ret = 0;\r\nchar mod_name[64];\r\nuuid_le *uuid_mod;\r\nuuid_mod = (uuid_le *)guid;\r\nsnprintf(mod_name, sizeof(mod_name), "%s%pUL%s",\r\n"intel/dsp_fw_", uuid_mod, ".bin");\r\nmodule_entry = skl_module_get_from_id(ctx, mod_id);\r\nif (module_entry == NULL) {\r\nmodule_entry = skl_fill_module_table(ctx, mod_name, mod_id);\r\nif (module_entry == NULL) {\r\ndev_err(ctx->dev, "Failed to Load module\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!module_entry->usage_cnt) {\r\nret = skl_transfer_module(ctx, module_entry->mod_info);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Failed to Load module\n");\r\nreturn ret;\r\n}\r\n}\r\nret = skl_get_module(ctx, mod_id);\r\nreturn ret;\r\n}\r\nstatic int skl_unload_module(struct sst_dsp *ctx, u16 mod_id)\r\n{\r\nint usage_cnt;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nint ret = 0;\r\nusage_cnt = skl_put_module(ctx, mod_id);\r\nif (usage_cnt < 0) {\r\ndev_err(ctx->dev, "Module bad usage cnt!:%d\n", usage_cnt);\r\nreturn -EIO;\r\n}\r\nret = skl_ipc_unload_modules(&skl->ipc,\r\nSKL_NUM_MODULES, &mod_id);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "Failed to UnLoad module\n");\r\nskl_get_module(ctx, mod_id);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nvoid skl_clear_module_cnt(struct sst_dsp *ctx)\r\n{\r\nstruct skl_module_table *module;\r\nif (list_empty(&ctx->module_list))\r\nreturn;\r\nlist_for_each_entry(module, &ctx->module_list, list) {\r\nmodule->usage_cnt = 0;\r\n}\r\n}\r\nstatic void skl_clear_module_table(struct sst_dsp *ctx)\r\n{\r\nstruct skl_module_table *module, *tmp;\r\nif (list_empty(&ctx->module_list))\r\nreturn;\r\nlist_for_each_entry_safe(module, tmp, &ctx->module_list, list) {\r\nlist_del(&module->list);\r\nrelease_firmware(module->mod_info->fw);\r\n}\r\n}\r\nint skl_sst_dsp_init(struct device *dev, void __iomem *mmio_base, int irq,\r\nconst char *fw_name, struct skl_dsp_loader_ops dsp_ops, struct skl_sst **dsp)\r\n{\r\nstruct skl_sst *skl;\r\nstruct sst_dsp *sst;\r\nint ret;\r\nskl = devm_kzalloc(dev, sizeof(*skl), GFP_KERNEL);\r\nif (skl == NULL)\r\nreturn -ENOMEM;\r\nskl->dev = dev;\r\nskl_dev.thread_context = skl;\r\nINIT_LIST_HEAD(&skl->uuid_list);\r\nskl->dsp = skl_dsp_ctx_init(dev, &skl_dev, irq);\r\nif (!skl->dsp) {\r\ndev_err(skl->dev, "%s: no device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nsst = skl->dsp;\r\nsst->fw_name = fw_name;\r\nsst->addr.lpe = mmio_base;\r\nsst->addr.shim = mmio_base;\r\nsst_dsp_mailbox_init(sst, (SKL_ADSP_SRAM0_BASE + SKL_ADSP_W0_STAT_SZ),\r\nSKL_ADSP_W0_UP_SZ, SKL_ADSP_SRAM1_BASE, SKL_ADSP_W1_SZ);\r\nINIT_LIST_HEAD(&sst->module_list);\r\nsst->dsp_ops = dsp_ops;\r\nsst->fw_ops = skl_fw_ops;\r\nret = skl_ipc_init(dev, skl);\r\nif (ret)\r\nreturn ret;\r\nskl->cores.count = 2;\r\nskl->is_first_boot = true;\r\nif (dsp)\r\n*dsp = skl;\r\nreturn ret;\r\n}\r\nint skl_sst_init_fw(struct device *dev, struct skl_sst *ctx)\r\n{\r\nint ret;\r\nstruct sst_dsp *sst = ctx->dsp;\r\nret = sst->fw_ops.load_fw(sst);\r\nif (ret < 0) {\r\ndev_err(dev, "Load base fw failed : %d\n", ret);\r\nreturn ret;\r\n}\r\nskl_dsp_init_core_state(sst);\r\nctx->is_first_boot = false;\r\nreturn 0;\r\n}\r\nvoid skl_sst_dsp_cleanup(struct device *dev, struct skl_sst *ctx)\r\n{\r\nif (ctx->dsp->fw)\r\nrelease_firmware(ctx->dsp->fw);\r\nskl_clear_module_table(ctx->dsp);\r\nskl_freeup_uuid_list(ctx);\r\nskl_ipc_free(&ctx->ipc);\r\nctx->dsp->ops->free(ctx->dsp);\r\nif (ctx->boot_complete) {\r\nctx->dsp->cl_dev.ops.cl_cleanup_controller(ctx->dsp);\r\nskl_cldma_int_disable(ctx->dsp);\r\n}\r\n}
