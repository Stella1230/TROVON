int snd_info_check_reserved_words(const char *str)\r\n{\r\nstatic char *reserved[] =\r\n{\r\n"version",\r\n"meminfo",\r\n"memdebug",\r\n"detect",\r\n"devices",\r\n"oss",\r\n"cards",\r\n"timers",\r\n"synth",\r\n"pcm",\r\n"seq",\r\nNULL\r\n};\r\nchar **xstr = reserved;\r\nwhile (*xstr) {\r\nif (!strcmp(*xstr, str))\r\nreturn 0;\r\nxstr++;\r\n}\r\nif (!strncmp(str, "card", 4))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int alloc_info_private(struct snd_info_entry *entry,\r\nstruct snd_info_private_data **ret)\r\n{\r\nstruct snd_info_private_data *data;\r\nif (!entry || !entry->p)\r\nreturn -ENODEV;\r\nif (!try_module_get(entry->module))\r\nreturn -EFAULT;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nmodule_put(entry->module);\r\nreturn -ENOMEM;\r\n}\r\ndata->entry = entry;\r\n*ret = data;\r\nreturn 0;\r\n}\r\nstatic bool valid_pos(loff_t pos, size_t count)\r\n{\r\nif (pos < 0 || (long) pos != pos || (ssize_t) count < 0)\r\nreturn false;\r\nif ((unsigned long) pos + (unsigned long) count < (unsigned long) pos)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic loff_t snd_info_entry_llseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\nloff_t ret = -EINVAL, size;\r\ndata = file->private_data;\r\nentry = data->entry;\r\nmutex_lock(&entry->access);\r\nif (entry->c.ops->llseek) {\r\noffset = entry->c.ops->llseek(entry,\r\ndata->file_private_data,\r\nfile, offset, orig);\r\ngoto out;\r\n}\r\nsize = entry->size;\r\nswitch (orig) {\r\ncase SEEK_SET:\r\nbreak;\r\ncase SEEK_CUR:\r\noffset += file->f_pos;\r\nbreak;\r\ncase SEEK_END:\r\nif (!size)\r\ngoto out;\r\noffset += size;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif (offset < 0)\r\ngoto out;\r\nif (size && offset > size)\r\noffset = size;\r\nfile->f_pos = offset;\r\nret = offset;\r\nout:\r\nmutex_unlock(&entry->access);\r\nreturn ret;\r\n}\r\nstatic ssize_t snd_info_entry_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct snd_info_private_data *data = file->private_data;\r\nstruct snd_info_entry *entry = data->entry;\r\nsize_t size;\r\nloff_t pos;\r\npos = *offset;\r\nif (!valid_pos(pos, count))\r\nreturn -EIO;\r\nif (pos >= entry->size)\r\nreturn 0;\r\nsize = entry->size - pos;\r\nsize = min(count, size);\r\nsize = entry->c.ops->read(entry, data->file_private_data,\r\nfile, buffer, size, pos);\r\nif ((ssize_t) size > 0)\r\n*offset = pos + size;\r\nreturn size;\r\n}\r\nstatic ssize_t snd_info_entry_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct snd_info_private_data *data = file->private_data;\r\nstruct snd_info_entry *entry = data->entry;\r\nssize_t size = 0;\r\nloff_t pos;\r\npos = *offset;\r\nif (!valid_pos(pos, count))\r\nreturn -EIO;\r\nif (count > 0) {\r\nsize_t maxsize = entry->size - pos;\r\ncount = min(count, maxsize);\r\nsize = entry->c.ops->write(entry, data->file_private_data,\r\nfile, buffer, count, pos);\r\n}\r\nif (size > 0)\r\n*offset = pos + size;\r\nreturn size;\r\n}\r\nstatic unsigned int snd_info_entry_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct snd_info_private_data *data = file->private_data;\r\nstruct snd_info_entry *entry = data->entry;\r\nunsigned int mask = 0;\r\nif (entry->c.ops->poll)\r\nreturn entry->c.ops->poll(entry,\r\ndata->file_private_data,\r\nfile, wait);\r\nif (entry->c.ops->read)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (entry->c.ops->write)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic long snd_info_entry_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct snd_info_private_data *data = file->private_data;\r\nstruct snd_info_entry *entry = data->entry;\r\nif (!entry->c.ops->ioctl)\r\nreturn -ENOTTY;\r\nreturn entry->c.ops->ioctl(entry, data->file_private_data,\r\nfile, cmd, arg);\r\n}\r\nstatic int snd_info_entry_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct snd_info_private_data *data;\r\nstruct snd_info_entry *entry;\r\ndata = file->private_data;\r\nif (data == NULL)\r\nreturn 0;\r\nentry = data->entry;\r\nif (!entry->c.ops->mmap)\r\nreturn -ENXIO;\r\nreturn entry->c.ops->mmap(entry, data->file_private_data,\r\ninode, file, vma);\r\n}\r\nstatic int snd_info_entry_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_info_entry *entry = PDE_DATA(inode);\r\nstruct snd_info_private_data *data;\r\nint mode, err;\r\nmutex_lock(&info_mutex);\r\nerr = alloc_info_private(entry, &data);\r\nif (err < 0)\r\ngoto unlock;\r\nmode = file->f_flags & O_ACCMODE;\r\nif (((mode == O_RDONLY || mode == O_RDWR) && !entry->c.ops->read) ||\r\n((mode == O_WRONLY || mode == O_RDWR) && !entry->c.ops->write)) {\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nif (entry->c.ops->open) {\r\nerr = entry->c.ops->open(entry, mode, &data->file_private_data);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nfile->private_data = data;\r\nmutex_unlock(&info_mutex);\r\nreturn 0;\r\nerror:\r\nkfree(data);\r\nmodule_put(entry->module);\r\nunlock:\r\nmutex_unlock(&info_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_info_entry_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_info_private_data *data = file->private_data;\r\nstruct snd_info_entry *entry = data->entry;\r\nif (entry->c.ops->release)\r\nentry->c.ops->release(entry, file->f_flags & O_ACCMODE,\r\ndata->file_private_data);\r\nmodule_put(entry->module);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic ssize_t snd_info_text_entry_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct snd_info_private_data *data = m->private;\r\nstruct snd_info_entry *entry = data->entry;\r\nstruct snd_info_buffer *buf;\r\nloff_t pos;\r\nsize_t next;\r\nint err = 0;\r\nif (!entry->c.text.write)\r\nreturn -EIO;\r\npos = *offset;\r\nif (!valid_pos(pos, count))\r\nreturn -EIO;\r\nnext = pos + count;\r\nif (next > 16 * 1024)\r\nreturn -EIO;\r\nmutex_lock(&entry->access);\r\nbuf = data->wbuffer;\r\nif (!buf) {\r\ndata->wbuffer = buf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\n}\r\nif (next > buf->len) {\r\nchar *nbuf = krealloc(buf->buffer, PAGE_ALIGN(next),\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!nbuf) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nbuf->buffer = nbuf;\r\nbuf->len = PAGE_ALIGN(next);\r\n}\r\nif (copy_from_user(buf->buffer + pos, buffer, count)) {\r\nerr = -EFAULT;\r\ngoto error;\r\n}\r\nbuf->size = next;\r\nerror:\r\nmutex_unlock(&entry->access);\r\nif (err < 0)\r\nreturn err;\r\n*offset = next;\r\nreturn count;\r\n}\r\nstatic int snd_info_seq_show(struct seq_file *seq, void *p)\r\n{\r\nstruct snd_info_private_data *data = seq->private;\r\nstruct snd_info_entry *entry = data->entry;\r\nif (!entry->c.text.read) {\r\nreturn -EIO;\r\n} else {\r\ndata->rbuffer->buffer = (char *)seq;\r\nentry->c.text.read(entry, data->rbuffer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_info_text_entry_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_info_entry *entry = PDE_DATA(inode);\r\nstruct snd_info_private_data *data;\r\nint err;\r\nmutex_lock(&info_mutex);\r\nerr = alloc_info_private(entry, &data);\r\nif (err < 0)\r\ngoto unlock;\r\ndata->rbuffer = kzalloc(sizeof(*data->rbuffer), GFP_KERNEL);\r\nif (!data->rbuffer) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nif (entry->size)\r\nerr = single_open_size(file, snd_info_seq_show, data,\r\nentry->size);\r\nelse\r\nerr = single_open(file, snd_info_seq_show, data);\r\nif (err < 0)\r\ngoto error;\r\nmutex_unlock(&info_mutex);\r\nreturn 0;\r\nerror:\r\nkfree(data->rbuffer);\r\nkfree(data);\r\nmodule_put(entry->module);\r\nunlock:\r\nmutex_unlock(&info_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_info_text_entry_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nstruct snd_info_private_data *data = m->private;\r\nstruct snd_info_entry *entry = data->entry;\r\nif (data->wbuffer && entry->c.text.write)\r\nentry->c.text.write(entry, data->wbuffer);\r\nsingle_release(inode, file);\r\nkfree(data->rbuffer);\r\nif (data->wbuffer) {\r\nkfree(data->wbuffer->buffer);\r\nkfree(data->wbuffer);\r\n}\r\nmodule_put(entry->module);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic struct snd_info_entry *create_subdir(struct module *mod,\r\nconst char *name)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(mod, name, NULL);\r\nif (!entry)\r\nreturn NULL;\r\nentry->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nreturn NULL;\r\n}\r\nreturn entry;\r\n}\r\nint __init snd_info_init(void)\r\n{\r\nsnd_proc_root = snd_info_create_entry("asound", NULL);\r\nif (!snd_proc_root)\r\nreturn -ENOMEM;\r\nsnd_proc_root->mode = S_IFDIR | S_IRUGO | S_IXUGO;\r\nsnd_proc_root->p = proc_mkdir("asound", NULL);\r\nif (!snd_proc_root->p)\r\ngoto error;\r\n#ifdef CONFIG_SND_OSSEMUL\r\nsnd_oss_root = create_subdir(THIS_MODULE, "oss");\r\nif (!snd_oss_root)\r\ngoto error;\r\n#endif\r\n#if IS_ENABLED(CONFIG_SND_SEQUENCER)\r\nsnd_seq_root = create_subdir(THIS_MODULE, "seq");\r\nif (!snd_seq_root)\r\ngoto error;\r\n#endif\r\nif (snd_info_version_init() < 0 ||\r\nsnd_minor_info_init() < 0 ||\r\nsnd_minor_info_oss_init() < 0 ||\r\nsnd_card_info_init() < 0 ||\r\nsnd_info_minor_register() < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nsnd_info_free_entry(snd_proc_root);\r\nreturn -ENOMEM;\r\n}\r\nint __exit snd_info_done(void)\r\n{\r\nsnd_info_free_entry(snd_proc_root);\r\nreturn 0;\r\n}\r\nint snd_info_card_create(struct snd_card *card)\r\n{\r\nchar str[8];\r\nstruct snd_info_entry *entry;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nsprintf(str, "card%i", card->number);\r\nentry = create_subdir(card->module, str);\r\nif (!entry)\r\nreturn -ENOMEM;\r\ncard->proc_root = entry;\r\nreturn 0;\r\n}\r\nstatic int snd_info_register_recursive(struct snd_info_entry *entry)\r\n{\r\nstruct snd_info_entry *p;\r\nint err;\r\nif (!entry->p) {\r\nerr = snd_info_register(entry);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nlist_for_each_entry(p, &entry->children, list) {\r\nerr = snd_info_register_recursive(p);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_info_card_register(struct snd_card *card)\r\n{\r\nstruct proc_dir_entry *p;\r\nint err;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENXIO;\r\nerr = snd_info_register_recursive(card->proc_root);\r\nif (err < 0)\r\nreturn err;\r\nif (!strcmp(card->id, card->proc_root->name))\r\nreturn 0;\r\nif (card->proc_root_link)\r\nreturn 0;\r\np = proc_symlink(card->id, snd_proc_root->p, card->proc_root->name);\r\nif (!p)\r\nreturn -ENOMEM;\r\ncard->proc_root_link = p;\r\nreturn 0;\r\n}\r\nvoid snd_info_card_id_change(struct snd_card *card)\r\n{\r\nmutex_lock(&info_mutex);\r\nif (card->proc_root_link) {\r\nproc_remove(card->proc_root_link);\r\ncard->proc_root_link = NULL;\r\n}\r\nif (strcmp(card->id, card->proc_root->name))\r\ncard->proc_root_link = proc_symlink(card->id,\r\nsnd_proc_root->p,\r\ncard->proc_root->name);\r\nmutex_unlock(&info_mutex);\r\n}\r\nvoid snd_info_card_disconnect(struct snd_card *card)\r\n{\r\nif (!card)\r\nreturn;\r\nmutex_lock(&info_mutex);\r\nproc_remove(card->proc_root_link);\r\ncard->proc_root_link = NULL;\r\nif (card->proc_root)\r\nsnd_info_disconnect(card->proc_root);\r\nmutex_unlock(&info_mutex);\r\n}\r\nint snd_info_card_free(struct snd_card *card)\r\n{\r\nif (!card)\r\nreturn 0;\r\nsnd_info_free_entry(card->proc_root);\r\ncard->proc_root = NULL;\r\nreturn 0;\r\n}\r\nint snd_info_get_line(struct snd_info_buffer *buffer, char *line, int len)\r\n{\r\nint c = -1;\r\nif (snd_BUG_ON(!buffer || !buffer->buffer))\r\nreturn 1;\r\nif (len <= 0 || buffer->stop || buffer->error)\r\nreturn 1;\r\nwhile (!buffer->stop) {\r\nc = buffer->buffer[buffer->curr++];\r\nif (buffer->curr >= buffer->size)\r\nbuffer->stop = 1;\r\nif (c == '\n')\r\nbreak;\r\nif (len > 1) {\r\nlen--;\r\n*line++ = c;\r\n}\r\n}\r\n*line = '\0';\r\nreturn 0;\r\n}\r\nconst char *snd_info_get_str(char *dest, const char *src, int len)\r\n{\r\nint c;\r\nwhile (*src == ' ' || *src == '\t')\r\nsrc++;\r\nif (*src == '"' || *src == '\'') {\r\nc = *src++;\r\nwhile (--len > 0 && *src && *src != c) {\r\n*dest++ = *src++;\r\n}\r\nif (*src == c)\r\nsrc++;\r\n} else {\r\nwhile (--len > 0 && *src && *src != ' ' && *src != '\t') {\r\n*dest++ = *src++;\r\n}\r\n}\r\n*dest = 0;\r\nwhile (*src == ' ' || *src == '\t')\r\nsrc++;\r\nreturn src;\r\n}\r\nstatic struct snd_info_entry *\r\nsnd_info_create_entry(const char *name, struct snd_info_entry *parent)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn NULL;\r\nentry->name = kstrdup(name, GFP_KERNEL);\r\nif (entry->name == NULL) {\r\nkfree(entry);\r\nreturn NULL;\r\n}\r\nentry->mode = S_IFREG | S_IRUGO;\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nmutex_init(&entry->access);\r\nINIT_LIST_HEAD(&entry->children);\r\nINIT_LIST_HEAD(&entry->list);\r\nentry->parent = parent;\r\nif (parent)\r\nlist_add_tail(&entry->list, &parent->children);\r\nreturn entry;\r\n}\r\nstruct snd_info_entry *snd_info_create_module_entry(struct module * module,\r\nconst char *name,\r\nstruct snd_info_entry *parent)\r\n{\r\nstruct snd_info_entry *entry = snd_info_create_entry(name, parent);\r\nif (entry)\r\nentry->module = module;\r\nreturn entry;\r\n}\r\nstruct snd_info_entry *snd_info_create_card_entry(struct snd_card *card,\r\nconst char *name,\r\nstruct snd_info_entry * parent)\r\n{\r\nstruct snd_info_entry *entry = snd_info_create_entry(name, parent);\r\nif (entry) {\r\nentry->module = card->module;\r\nentry->card = card;\r\n}\r\nreturn entry;\r\n}\r\nstatic void snd_info_disconnect(struct snd_info_entry *entry)\r\n{\r\nstruct snd_info_entry *p;\r\nif (!entry->p)\r\nreturn;\r\nlist_for_each_entry(p, &entry->children, list)\r\nsnd_info_disconnect(p);\r\nproc_remove(entry->p);\r\nentry->p = NULL;\r\n}\r\nvoid snd_info_free_entry(struct snd_info_entry * entry)\r\n{\r\nstruct snd_info_entry *p, *n;\r\nif (!entry)\r\nreturn;\r\nif (entry->p) {\r\nmutex_lock(&info_mutex);\r\nsnd_info_disconnect(entry);\r\nmutex_unlock(&info_mutex);\r\n}\r\nlist_for_each_entry_safe(p, n, &entry->children, list)\r\nsnd_info_free_entry(p);\r\nlist_del(&entry->list);\r\nkfree(entry->name);\r\nif (entry->private_free)\r\nentry->private_free(entry);\r\nkfree(entry);\r\n}\r\nint snd_info_register(struct snd_info_entry * entry)\r\n{\r\nstruct proc_dir_entry *root, *p = NULL;\r\nif (snd_BUG_ON(!entry))\r\nreturn -ENXIO;\r\nroot = entry->parent == NULL ? snd_proc_root->p : entry->parent->p;\r\nmutex_lock(&info_mutex);\r\nif (S_ISDIR(entry->mode)) {\r\np = proc_mkdir_mode(entry->name, entry->mode, root);\r\nif (!p) {\r\nmutex_unlock(&info_mutex);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nconst struct file_operations *ops;\r\nif (entry->content == SNDRV_INFO_CONTENT_DATA)\r\nops = &snd_info_entry_operations;\r\nelse\r\nops = &snd_info_text_entry_ops;\r\np = proc_create_data(entry->name, entry->mode, root,\r\nops, entry);\r\nif (!p) {\r\nmutex_unlock(&info_mutex);\r\nreturn -ENOMEM;\r\n}\r\nproc_set_size(p, entry->size);\r\n}\r\nentry->p = p;\r\nmutex_unlock(&info_mutex);\r\nreturn 0;\r\n}\r\nstatic void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nsnd_iprintf(buffer,\r\n"Advanced Linux Sound Architecture Driver Version k%s.\n",\r\ninit_utsname()->release);\r\n}\r\nstatic int __init snd_info_version_init(void)\r\n{\r\nstruct snd_info_entry *entry;\r\nentry = snd_info_create_module_entry(THIS_MODULE, "version", NULL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->c.text.read = snd_info_version_read;\r\nreturn snd_info_register(entry);\r\n}
