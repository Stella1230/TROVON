static debug_info_t *qdio_get_dbf_entry(char *name)\r\n{\r\nstruct qdio_dbf_entry *entry;\r\ndebug_info_t *rc = NULL;\r\nmutex_lock(&qdio_dbf_list_mutex);\r\nlist_for_each_entry(entry, &qdio_dbf_list, dbf_list) {\r\nif (strcmp(entry->dbf_name, name) == 0) {\r\nrc = entry->dbf_info;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&qdio_dbf_list_mutex);\r\nreturn rc;\r\n}\r\nstatic void qdio_clear_dbf_list(void)\r\n{\r\nstruct qdio_dbf_entry *entry, *tmp;\r\nmutex_lock(&qdio_dbf_list_mutex);\r\nlist_for_each_entry_safe(entry, tmp, &qdio_dbf_list, dbf_list) {\r\nlist_del(&entry->dbf_list);\r\ndebug_unregister(entry->dbf_info);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&qdio_dbf_list_mutex);\r\n}\r\nint qdio_allocate_dbf(struct qdio_initialize *init_data,\r\nstruct qdio_irq *irq_ptr)\r\n{\r\nchar text[QDIO_DBF_NAME_LEN];\r\nstruct qdio_dbf_entry *new_entry;\r\nDBF_EVENT("qfmt:%1d", init_data->q_format);\r\nDBF_HEX(init_data->adapter_name, 8);\r\nDBF_EVENT("qpff%4x", init_data->qib_param_field_format);\r\nDBF_HEX(&init_data->qib_param_field, sizeof(void *));\r\nDBF_HEX(&init_data->input_slib_elements, sizeof(void *));\r\nDBF_HEX(&init_data->output_slib_elements, sizeof(void *));\r\nDBF_EVENT("niq:%1d noq:%1d", init_data->no_input_qs,\r\ninit_data->no_output_qs);\r\nDBF_HEX(&init_data->input_handler, sizeof(void *));\r\nDBF_HEX(&init_data->output_handler, sizeof(void *));\r\nDBF_HEX(&init_data->int_parm, sizeof(long));\r\nDBF_HEX(&init_data->input_sbal_addr_array, sizeof(void *));\r\nDBF_HEX(&init_data->output_sbal_addr_array, sizeof(void *));\r\nDBF_EVENT("irq:%8lx", (unsigned long)irq_ptr);\r\nsnprintf(text, QDIO_DBF_NAME_LEN, "qdio_%s",\r\ndev_name(&init_data->cdev->dev));\r\nirq_ptr->debug_area = qdio_get_dbf_entry(text);\r\nif (irq_ptr->debug_area)\r\nDBF_DEV_EVENT(DBF_ERR, irq_ptr, "dbf reused");\r\nelse {\r\nirq_ptr->debug_area = debug_register(text, 2, 1, 16);\r\nif (!irq_ptr->debug_area)\r\nreturn -ENOMEM;\r\nif (debug_register_view(irq_ptr->debug_area,\r\n&debug_hex_ascii_view)) {\r\ndebug_unregister(irq_ptr->debug_area);\r\nreturn -ENOMEM;\r\n}\r\ndebug_set_level(irq_ptr->debug_area, DBF_WARN);\r\nDBF_DEV_EVENT(DBF_ERR, irq_ptr, "dbf created");\r\nnew_entry = kzalloc(sizeof(struct qdio_dbf_entry), GFP_KERNEL);\r\nif (!new_entry) {\r\ndebug_unregister(irq_ptr->debug_area);\r\nreturn -ENOMEM;\r\n}\r\nstrlcpy(new_entry->dbf_name, text, QDIO_DBF_NAME_LEN);\r\nnew_entry->dbf_info = irq_ptr->debug_area;\r\nmutex_lock(&qdio_dbf_list_mutex);\r\nlist_add(&new_entry->dbf_list, &qdio_dbf_list);\r\nmutex_unlock(&qdio_dbf_list_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qstat_show(struct seq_file *m, void *v)\r\n{\r\nunsigned char state;\r\nstruct qdio_q *q = m->private;\r\nint i;\r\nif (!q)\r\nreturn 0;\r\nseq_printf(m, "Timestamp: %Lx Last AI: %Lx\n",\r\nq->timestamp, last_ai_time);\r\nseq_printf(m, "nr_used: %d ftc: %d last_move: %d\n",\r\natomic_read(&q->nr_buf_used),\r\nq->first_to_check, q->last_move);\r\nif (q->is_input_q) {\r\nseq_printf(m, "polling: %d ack start: %d ack count: %d\n",\r\nq->u.in.polling, q->u.in.ack_start,\r\nq->u.in.ack_count);\r\nseq_printf(m, "DSCI: %d IRQs disabled: %u\n",\r\n*(u32 *)q->irq_ptr->dsci,\r\ntest_bit(QDIO_QUEUE_IRQS_DISABLED,\r\n&q->u.in.queue_irq_state));\r\n}\r\nseq_printf(m, "SBAL states:\n");\r\nseq_printf(m, "|0 |8 |16 |24 |32 |40 |48 |56 63|\n");\r\nfor (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++) {\r\ndebug_get_buf_state(q, i, &state);\r\nswitch (state) {\r\ncase SLSB_P_INPUT_NOT_INIT:\r\ncase SLSB_P_OUTPUT_NOT_INIT:\r\nseq_printf(m, "N");\r\nbreak;\r\ncase SLSB_P_OUTPUT_PENDING:\r\nseq_printf(m, "P");\r\nbreak;\r\ncase SLSB_P_INPUT_PRIMED:\r\ncase SLSB_CU_OUTPUT_PRIMED:\r\nseq_printf(m, "+");\r\nbreak;\r\ncase SLSB_P_INPUT_ACK:\r\nseq_printf(m, "A");\r\nbreak;\r\ncase SLSB_P_INPUT_ERROR:\r\ncase SLSB_P_OUTPUT_ERROR:\r\nseq_printf(m, "x");\r\nbreak;\r\ncase SLSB_CU_INPUT_EMPTY:\r\ncase SLSB_P_OUTPUT_EMPTY:\r\nseq_printf(m, "-");\r\nbreak;\r\ncase SLSB_P_INPUT_HALTED:\r\ncase SLSB_P_OUTPUT_HALTED:\r\nseq_printf(m, ".");\r\nbreak;\r\ndefault:\r\nseq_printf(m, "?");\r\n}\r\nif (i == 63)\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, "|64 |72 |80 |88 |96 |104 |112 | 127|\n");\r\nseq_printf(m, "\nSBAL statistics:");\r\nif (!q->irq_ptr->perf_stat_enabled) {\r\nseq_printf(m, " disabled\n");\r\nreturn 0;\r\n}\r\nseq_printf(m, "\n1 2.. 4.. 8.. "\r\n"16.. 32.. 64.. 127\n");\r\nfor (i = 0; i < ARRAY_SIZE(q->q_stats.nr_sbals); i++)\r\nseq_printf(m, "%-10u ", q->q_stats.nr_sbals[i]);\r\nseq_printf(m, "\nError NOP Total\n%-10u %-10u %-10u\n\n",\r\nq->q_stats.nr_sbal_error, q->q_stats.nr_sbal_nop,\r\nq->q_stats.nr_sbal_total);\r\nreturn 0;\r\n}\r\nstatic int qstat_seq_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, qstat_show,\r\nfile_inode(filp)->i_private);\r\n}\r\nstatic int qperf_show(struct seq_file *m, void *v)\r\n{\r\nstruct qdio_irq *irq_ptr = m->private;\r\nunsigned int *stat;\r\nint i;\r\nif (!irq_ptr)\r\nreturn 0;\r\nif (!irq_ptr->perf_stat_enabled) {\r\nseq_printf(m, "disabled\n");\r\nreturn 0;\r\n}\r\nstat = (unsigned int *)&irq_ptr->perf_stat;\r\nfor (i = 0; i < ARRAY_SIZE(qperf_names); i++)\r\nseq_printf(m, "%26s:\t%u\n",\r\nqperf_names[i], *(stat + i));\r\nreturn 0;\r\n}\r\nstatic ssize_t qperf_seq_write(struct file *file, const char __user *ubuf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct qdio_irq *irq_ptr = seq->private;\r\nstruct qdio_q *q;\r\nunsigned long val;\r\nint ret, i;\r\nif (!irq_ptr)\r\nreturn 0;\r\nret = kstrtoul_from_user(ubuf, count, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nswitch (val) {\r\ncase 0:\r\nirq_ptr->perf_stat_enabled = 0;\r\nmemset(&irq_ptr->perf_stat, 0, sizeof(irq_ptr->perf_stat));\r\nfor_each_input_queue(irq_ptr, q, i)\r\nmemset(&q->q_stats, 0, sizeof(q->q_stats));\r\nfor_each_output_queue(irq_ptr, q, i)\r\nmemset(&q->q_stats, 0, sizeof(q->q_stats));\r\nbreak;\r\ncase 1:\r\nirq_ptr->perf_stat_enabled = 1;\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int qperf_seq_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, qperf_show,\r\nfile_inode(filp)->i_private);\r\n}\r\nstatic void setup_debugfs_entry(struct qdio_q *q)\r\n{\r\nchar name[QDIO_DEBUGFS_NAME_LEN];\r\nsnprintf(name, QDIO_DEBUGFS_NAME_LEN, "%s_%d",\r\nq->is_input_q ? "input" : "output",\r\nq->nr);\r\nq->debugfs_q = debugfs_create_file(name, S_IFREG | S_IRUGO | S_IWUSR,\r\nq->irq_ptr->debugfs_dev, q, &debugfs_fops);\r\nif (IS_ERR(q->debugfs_q))\r\nq->debugfs_q = NULL;\r\n}\r\nvoid qdio_setup_debug_entries(struct qdio_irq *irq_ptr, struct ccw_device *cdev)\r\n{\r\nstruct qdio_q *q;\r\nint i;\r\nirq_ptr->debugfs_dev = debugfs_create_dir(dev_name(&cdev->dev),\r\ndebugfs_root);\r\nif (IS_ERR(irq_ptr->debugfs_dev))\r\nirq_ptr->debugfs_dev = NULL;\r\nirq_ptr->debugfs_perf = debugfs_create_file("statistics",\r\nS_IFREG | S_IRUGO | S_IWUSR,\r\nirq_ptr->debugfs_dev, irq_ptr,\r\n&debugfs_perf_fops);\r\nif (IS_ERR(irq_ptr->debugfs_perf))\r\nirq_ptr->debugfs_perf = NULL;\r\nfor_each_input_queue(irq_ptr, q, i)\r\nsetup_debugfs_entry(q);\r\nfor_each_output_queue(irq_ptr, q, i)\r\nsetup_debugfs_entry(q);\r\n}\r\nvoid qdio_shutdown_debug_entries(struct qdio_irq *irq_ptr)\r\n{\r\nstruct qdio_q *q;\r\nint i;\r\nfor_each_input_queue(irq_ptr, q, i)\r\ndebugfs_remove(q->debugfs_q);\r\nfor_each_output_queue(irq_ptr, q, i)\r\ndebugfs_remove(q->debugfs_q);\r\ndebugfs_remove(irq_ptr->debugfs_perf);\r\ndebugfs_remove(irq_ptr->debugfs_dev);\r\n}\r\nint __init qdio_debug_init(void)\r\n{\r\ndebugfs_root = debugfs_create_dir("qdio", NULL);\r\nqdio_dbf_setup = debug_register("qdio_setup", 16, 1, 16);\r\ndebug_register_view(qdio_dbf_setup, &debug_hex_ascii_view);\r\ndebug_set_level(qdio_dbf_setup, DBF_INFO);\r\nDBF_EVENT("dbf created\n");\r\nqdio_dbf_error = debug_register("qdio_error", 4, 1, 16);\r\ndebug_register_view(qdio_dbf_error, &debug_hex_ascii_view);\r\ndebug_set_level(qdio_dbf_error, DBF_INFO);\r\nDBF_ERROR("dbf created\n");\r\nreturn 0;\r\n}\r\nvoid qdio_debug_exit(void)\r\n{\r\nqdio_clear_dbf_list();\r\ndebugfs_remove(debugfs_root);\r\ndebug_unregister(qdio_dbf_setup);\r\ndebug_unregister(qdio_dbf_error);\r\n}
