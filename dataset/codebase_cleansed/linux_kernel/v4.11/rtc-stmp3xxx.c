static void stmp3xxx_wdt_set_timeout(struct device *dev, u32 timeout)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nif (timeout) {\r\nwritel(timeout, rtc_data->io + STMP3XXX_RTC_WATCHDOG);\r\nwritel(STMP3XXX_RTC_CTRL_WATCHDOGEN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_SET);\r\nwritel(STMP3XXX_RTC_PERSISTENT1_FORCE_UPDATER,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT1 + STMP_OFFSET_REG_SET);\r\n} else {\r\nwritel(STMP3XXX_RTC_CTRL_WATCHDOGEN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\r\nwritel(STMP3XXX_RTC_PERSISTENT1_FORCE_UPDATER,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT1 + STMP_OFFSET_REG_CLR);\r\n}\r\n}\r\nstatic void stmp3xxx_wdt_register(struct platform_device *rtc_pdev)\r\n{\r\nint rc = -1;\r\nstruct platform_device *wdt_pdev =\r\nplatform_device_alloc("stmp3xxx_rtc_wdt", rtc_pdev->id);\r\nif (wdt_pdev) {\r\nwdt_pdev->dev.parent = &rtc_pdev->dev;\r\nwdt_pdev->dev.platform_data = &wdt_pdata;\r\nrc = platform_device_add(wdt_pdev);\r\n}\r\nif (rc)\r\ndev_err(&rtc_pdev->dev,\r\n"failed to register stmp3xxx_rtc_wdt\n");\r\n}\r\nstatic void stmp3xxx_wdt_register(struct platform_device *rtc_pdev)\r\n{\r\n}\r\nstatic int stmp3xxx_wait_time(struct stmp3xxx_rtc_data *rtc_data)\r\n{\r\nint timeout = 5000;\r\ndo {\r\nif (!(readl(rtc_data->io + STMP3XXX_RTC_STAT) &\r\n(0x80 << STMP3XXX_RTC_STAT_STALE_SHIFT)))\r\nreturn 0;\r\nudelay(1);\r\n} while (--timeout > 0);\r\nreturn (readl(rtc_data->io + STMP3XXX_RTC_STAT) &\r\n(0x80 << STMP3XXX_RTC_STAT_STALE_SHIFT)) ? -ETIME : 0;\r\n}\r\nstatic int stmp3xxx_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nint ret;\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nret = stmp3xxx_wait_time(rtc_data);\r\nif (ret)\r\nreturn ret;\r\nrtc_time_to_tm(readl(rtc_data->io + STMP3XXX_RTC_SECONDS), rtc_tm);\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_set_mmss(struct device *dev, unsigned long t)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nwritel(t, rtc_data->io + STMP3XXX_RTC_SECONDS);\r\nreturn stmp3xxx_wait_time(rtc_data);\r\n}\r\nstatic irqreturn_t stmp3xxx_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev_id);\r\nu32 status = readl(rtc_data->io + STMP3XXX_RTC_CTRL);\r\nif (status & STMP3XXX_RTC_CTRL_ALARM_IRQ) {\r\nwritel(STMP3XXX_RTC_CTRL_ALARM_IRQ,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\r\nrtc_update_irq(rtc_data->rtc, 1, RTC_AF | RTC_IRQF);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int stmp3xxx_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nif (enabled) {\r\nwritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\r\nSTMP_OFFSET_REG_SET);\r\nwritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_SET);\r\n} else {\r\nwritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\r\nSTMP_OFFSET_REG_CLR);\r\nwritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nrtc_time_to_tm(readl(rtc_data->io + STMP3XXX_RTC_ALARM), &alm->time);\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\r\n{\r\nunsigned long t;\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nrtc_tm_to_time(&alm->time, &t);\r\nwritel(t, rtc_data->io + STMP3XXX_RTC_ALARM);\r\nstmp3xxx_alarm_irq_enable(dev, alm->enabled);\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = platform_get_drvdata(pdev);\r\nif (!rtc_data)\r\nreturn 0;\r\nwritel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data;\r\nstruct resource *r;\r\nu32 rtc_stat;\r\nu32 pers0_set, pers0_clr;\r\nu32 crystalfreq = 0;\r\nint err;\r\nrtc_data = devm_kzalloc(&pdev->dev, sizeof(*rtc_data), GFP_KERNEL);\r\nif (!rtc_data)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "failed to get resource\n");\r\nreturn -ENXIO;\r\n}\r\nrtc_data->io = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!rtc_data->io) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nreturn -EIO;\r\n}\r\nrtc_data->irq_alarm = platform_get_irq(pdev, 0);\r\nrtc_stat = readl(rtc_data->io + STMP3XXX_RTC_STAT);\r\nif (!(rtc_stat & STMP3XXX_RTC_STAT_RTC_PRESENT)) {\r\ndev_err(&pdev->dev, "no device onboard\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, rtc_data);\r\nerr = stmp_reset_block(rtc_data->io);\r\nif (err) {\r\ndev_err(&pdev->dev, "stmp_reset_block failed: %d\n", err);\r\nreturn err;\r\n}\r\nif (rtc_stat & STMP3XXX_RTC_STAT_XTAL32000_PRESENT)\r\ncrystalfreq = 32000;\r\nelse if (rtc_stat & STMP3XXX_RTC_STAT_XTAL32768_PRESENT)\r\ncrystalfreq = 32768;\r\nof_property_read_u32(pdev->dev.of_node, "stmp,crystal-freq",\r\n&crystalfreq);\r\nswitch (crystalfreq) {\r\ncase 32000:\r\npers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL32_FREQ |\r\nSTMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\r\nSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\r\npers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP;\r\nbreak;\r\ncase 32768:\r\npers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\r\nSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\r\npers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP |\r\nSTMP3XXX_RTC_PERSISTENT0_XTAL32_FREQ;\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev,\r\n"invalid crystal-freq specified in device-tree. Assuming no crystal\n");\r\ncase 0:\r\npers0_set = STMP3XXX_RTC_PERSISTENT0_XTAL24MHZ_PWRUP;\r\npers0_clr = STMP3XXX_RTC_PERSISTENT0_XTAL32KHZ_PWRUP |\r\nSTMP3XXX_RTC_PERSISTENT0_CLOCKSOURCE;\r\n}\r\nwritel(pers0_set, rtc_data->io + STMP3XXX_RTC_PERSISTENT0 +\r\nSTMP_OFFSET_REG_SET);\r\nwritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE | pers0_clr,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT0 + STMP_OFFSET_REG_CLR);\r\nwritel(STMP3XXX_RTC_CTRL_ONEMSEC_IRQ_EN |\r\nSTMP3XXX_RTC_CTRL_ALARM_IRQ_EN,\r\nrtc_data->io + STMP3XXX_RTC_CTRL + STMP_OFFSET_REG_CLR);\r\nrtc_data->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&stmp3xxx_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc_data->rtc))\r\nreturn PTR_ERR(rtc_data->rtc);\r\nerr = devm_request_irq(&pdev->dev, rtc_data->irq_alarm,\r\nstmp3xxx_rtc_interrupt, 0, "RTC alarm", &pdev->dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ%d\n",\r\nrtc_data->irq_alarm);\r\nreturn err;\r\n}\r\nstmp3xxx_wdt_register(pdev);\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int stmp3xxx_rtc_resume(struct device *dev)\r\n{\r\nstruct stmp3xxx_rtc_data *rtc_data = dev_get_drvdata(dev);\r\nstmp_reset_block(rtc_data->io);\r\nwritel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |\r\nSTMP3XXX_RTC_PERSISTENT0_ALARM_WAKE,\r\nrtc_data->io + STMP3XXX_RTC_PERSISTENT0 + STMP_OFFSET_REG_CLR);\r\nreturn 0;\r\n}
