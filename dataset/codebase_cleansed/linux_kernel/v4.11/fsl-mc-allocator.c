static int __must_check fsl_mc_resource_pool_add_device(struct fsl_mc_bus\r\n*mc_bus,\r\nenum fsl_mc_pool_type\r\npool_type,\r\nstruct fsl_mc_device\r\n*mc_dev)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nint error = -EINVAL;\r\nif (WARN_ON(pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES))\r\ngoto out;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\ngoto out;\r\nif (WARN_ON(mc_dev->resource))\r\ngoto out;\r\nres_pool = &mc_bus->resource_pools[pool_type];\r\nif (WARN_ON(res_pool->type != pool_type))\r\ngoto out;\r\nif (WARN_ON(res_pool->mc_bus != mc_bus))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nif (WARN_ON(res_pool->max_count < 0))\r\ngoto out_unlock;\r\nif (WARN_ON(res_pool->free_count < 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto out_unlock;\r\nresource = devm_kzalloc(&mc_bus_dev->dev, sizeof(*resource),\r\nGFP_KERNEL);\r\nif (!resource) {\r\nerror = -ENOMEM;\r\ndev_err(&mc_bus_dev->dev,\r\n"Failed to allocate memory for fsl_mc_resource\n");\r\ngoto out_unlock;\r\n}\r\nresource->type = pool_type;\r\nresource->id = mc_dev->obj_desc.id;\r\nresource->data = mc_dev;\r\nresource->parent_pool = res_pool;\r\nINIT_LIST_HEAD(&resource->node);\r\nlist_add_tail(&resource->node, &res_pool->free_list);\r\nmc_dev->resource = resource;\r\nres_pool->free_count++;\r\nres_pool->max_count++;\r\nerror = 0;\r\nout_unlock:\r\nmutex_unlock(&res_pool->mutex);\r\nout:\r\nreturn error;\r\n}\r\nstatic int __must_check fsl_mc_resource_pool_remove_device(struct fsl_mc_device\r\n*mc_dev)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nint error = -EINVAL;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\ngoto out;\r\nresource = mc_dev->resource;\r\nif (WARN_ON(!resource || resource->data != mc_dev))\r\ngoto out;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nres_pool = resource->parent_pool;\r\nif (WARN_ON(res_pool != &mc_bus->resource_pools[resource->type]))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nif (WARN_ON(res_pool->max_count <= 0))\r\ngoto out_unlock;\r\nif (WARN_ON(res_pool->free_count <= 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto out_unlock;\r\nif (list_empty(&resource->node)) {\r\nerror = -EBUSY;\r\ndev_err(&mc_bus_dev->dev,\r\n"Device %s cannot be removed from resource pool\n",\r\ndev_name(&mc_dev->dev));\r\ngoto out_unlock;\r\n}\r\nlist_del_init(&resource->node);\r\nres_pool->free_count--;\r\nres_pool->max_count--;\r\ndevm_kfree(&mc_bus_dev->dev, resource);\r\nmc_dev->resource = NULL;\r\nerror = 0;\r\nout_unlock:\r\nmutex_unlock(&res_pool->mutex);\r\nout:\r\nreturn error;\r\n}\r\nstatic int __must_check object_type_to_pool_type(const char *object_type,\r\nenum fsl_mc_pool_type\r\n*pool_type)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(fsl_mc_pool_type_strings); i++) {\r\nif (strcmp(object_type, fsl_mc_pool_type_strings[i]) == 0) {\r\n*pool_type = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint __must_check fsl_mc_resource_allocate(struct fsl_mc_bus *mc_bus,\r\nenum fsl_mc_pool_type pool_type,\r\nstruct fsl_mc_resource **new_resource)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nint error = -EINVAL;\r\nBUILD_BUG_ON(ARRAY_SIZE(fsl_mc_pool_type_strings) !=\r\nFSL_MC_NUM_POOL_TYPES);\r\n*new_resource = NULL;\r\nif (WARN_ON(pool_type < 0 || pool_type >= FSL_MC_NUM_POOL_TYPES))\r\ngoto out;\r\nres_pool = &mc_bus->resource_pools[pool_type];\r\nif (WARN_ON(res_pool->mc_bus != mc_bus))\r\ngoto out;\r\nmutex_lock(&res_pool->mutex);\r\nresource = list_first_entry_or_null(&res_pool->free_list,\r\nstruct fsl_mc_resource, node);\r\nif (!resource) {\r\nWARN_ON(res_pool->free_count != 0);\r\nerror = -ENXIO;\r\ndev_err(&mc_bus_dev->dev,\r\n"No more resources of type %s left\n",\r\nfsl_mc_pool_type_strings[pool_type]);\r\ngoto out_unlock;\r\n}\r\nif (WARN_ON(resource->type != pool_type))\r\ngoto out_unlock;\r\nif (WARN_ON(resource->parent_pool != res_pool))\r\ngoto out_unlock;\r\nif (WARN_ON(res_pool->free_count <= 0 ||\r\nres_pool->free_count > res_pool->max_count))\r\ngoto out_unlock;\r\nlist_del_init(&resource->node);\r\nres_pool->free_count--;\r\nerror = 0;\r\nout_unlock:\r\nmutex_unlock(&res_pool->mutex);\r\n*new_resource = resource;\r\nout:\r\nreturn error;\r\n}\r\nvoid fsl_mc_resource_free(struct fsl_mc_resource *resource)\r\n{\r\nstruct fsl_mc_resource_pool *res_pool;\r\nres_pool = resource->parent_pool;\r\nif (WARN_ON(resource->type != res_pool->type))\r\nreturn;\r\nmutex_lock(&res_pool->mutex);\r\nif (WARN_ON(res_pool->free_count < 0 ||\r\nres_pool->free_count >= res_pool->max_count))\r\ngoto out_unlock;\r\nif (WARN_ON(!list_empty(&resource->node)))\r\ngoto out_unlock;\r\nlist_add_tail(&resource->node, &res_pool->free_list);\r\nres_pool->free_count++;\r\nout_unlock:\r\nmutex_unlock(&res_pool->mutex);\r\n}\r\nint __must_check fsl_mc_object_allocate(struct fsl_mc_device *mc_dev,\r\nenum fsl_mc_pool_type pool_type,\r\nstruct fsl_mc_device **new_mc_adev)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_device *mc_adev;\r\nint error = -EINVAL;\r\nstruct fsl_mc_resource *resource = NULL;\r\n*new_mc_adev = NULL;\r\nif (WARN_ON(mc_dev->flags & FSL_MC_IS_DPRC))\r\ngoto error;\r\nif (WARN_ON(!dev_is_fsl_mc(mc_dev->dev.parent)))\r\ngoto error;\r\nif (WARN_ON(pool_type == FSL_MC_POOL_DPMCP))\r\ngoto error;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nerror = fsl_mc_resource_allocate(mc_bus, pool_type, &resource);\r\nif (error < 0)\r\ngoto error;\r\nmc_adev = resource->data;\r\nif (WARN_ON(!mc_adev))\r\ngoto error;\r\n*new_mc_adev = mc_adev;\r\nreturn 0;\r\nerror:\r\nif (resource)\r\nfsl_mc_resource_free(resource);\r\nreturn error;\r\n}\r\nvoid fsl_mc_object_free(struct fsl_mc_device *mc_adev)\r\n{\r\nstruct fsl_mc_resource *resource;\r\nresource = mc_adev->resource;\r\nif (WARN_ON(resource->type == FSL_MC_POOL_DPMCP))\r\nreturn;\r\nif (WARN_ON(resource->data != mc_adev))\r\nreturn;\r\nfsl_mc_resource_free(resource);\r\n}\r\nint fsl_mc_populate_irq_pool(struct fsl_mc_bus *mc_bus,\r\nunsigned int irq_count)\r\n{\r\nunsigned int i;\r\nstruct msi_desc *msi_desc;\r\nstruct fsl_mc_device_irq *irq_resources;\r\nstruct fsl_mc_device_irq *mc_dev_irq;\r\nint error;\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[FSL_MC_POOL_IRQ];\r\nif (WARN_ON(irq_count == 0 ||\r\nirq_count > FSL_MC_IRQ_POOL_MAX_TOTAL_IRQS))\r\nreturn -EINVAL;\r\nerror = fsl_mc_msi_domain_alloc_irqs(&mc_bus_dev->dev, irq_count);\r\nif (error < 0)\r\nreturn error;\r\nirq_resources = devm_kzalloc(&mc_bus_dev->dev,\r\nsizeof(*irq_resources) * irq_count,\r\nGFP_KERNEL);\r\nif (!irq_resources) {\r\nerror = -ENOMEM;\r\ngoto cleanup_msi_irqs;\r\n}\r\nfor (i = 0; i < irq_count; i++) {\r\nmc_dev_irq = &irq_resources[i];\r\nmc_dev_irq->resource.type = res_pool->type;\r\nmc_dev_irq->resource.data = mc_dev_irq;\r\nmc_dev_irq->resource.parent_pool = res_pool;\r\nINIT_LIST_HEAD(&mc_dev_irq->resource.node);\r\nlist_add_tail(&mc_dev_irq->resource.node, &res_pool->free_list);\r\n}\r\nfor_each_msi_entry(msi_desc, &mc_bus_dev->dev) {\r\nmc_dev_irq = &irq_resources[msi_desc->fsl_mc.msi_index];\r\nmc_dev_irq->msi_desc = msi_desc;\r\nmc_dev_irq->resource.id = msi_desc->irq;\r\n}\r\nres_pool->max_count = irq_count;\r\nres_pool->free_count = irq_count;\r\nmc_bus->irq_resources = irq_resources;\r\nreturn 0;\r\ncleanup_msi_irqs:\r\nfsl_mc_msi_domain_free_irqs(&mc_bus_dev->dev);\r\nreturn error;\r\n}\r\nvoid fsl_mc_cleanup_irq_pool(struct fsl_mc_bus *mc_bus)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev = &mc_bus->mc_dev;\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[FSL_MC_POOL_IRQ];\r\nif (WARN_ON(!mc_bus->irq_resources))\r\nreturn;\r\nif (WARN_ON(res_pool->max_count == 0))\r\nreturn;\r\nif (WARN_ON(res_pool->free_count != res_pool->max_count))\r\nreturn;\r\nINIT_LIST_HEAD(&res_pool->free_list);\r\nres_pool->max_count = 0;\r\nres_pool->free_count = 0;\r\nmc_bus->irq_resources = NULL;\r\nfsl_mc_msi_domain_free_irqs(&mc_bus_dev->dev);\r\n}\r\nint __must_check fsl_mc_allocate_irqs(struct fsl_mc_device *mc_dev)\r\n{\r\nint i;\r\nint irq_count;\r\nint res_allocated_count = 0;\r\nint error = -EINVAL;\r\nstruct fsl_mc_device_irq **irqs = NULL;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_resource_pool *res_pool;\r\nif (WARN_ON(mc_dev->irqs))\r\nreturn -EINVAL;\r\nirq_count = mc_dev->obj_desc.irq_count;\r\nif (WARN_ON(irq_count == 0))\r\nreturn -EINVAL;\r\nif (strcmp(mc_dev->obj_desc.type, "dprc") == 0)\r\nmc_bus = to_fsl_mc_bus(mc_dev);\r\nelse\r\nmc_bus = to_fsl_mc_bus(to_fsl_mc_device(mc_dev->dev.parent));\r\nif (WARN_ON(!mc_bus->irq_resources))\r\nreturn -EINVAL;\r\nres_pool = &mc_bus->resource_pools[FSL_MC_POOL_IRQ];\r\nif (res_pool->free_count < irq_count) {\r\ndev_err(&mc_dev->dev,\r\n"Not able to allocate %u irqs for device\n", irq_count);\r\nreturn -ENOSPC;\r\n}\r\nirqs = devm_kzalloc(&mc_dev->dev, irq_count * sizeof(irqs[0]),\r\nGFP_KERNEL);\r\nif (!irqs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < irq_count; i++) {\r\nstruct fsl_mc_resource *resource;\r\nerror = fsl_mc_resource_allocate(mc_bus, FSL_MC_POOL_IRQ,\r\n&resource);\r\nif (error < 0)\r\ngoto error_resource_alloc;\r\nirqs[i] = to_fsl_mc_irq(resource);\r\nres_allocated_count++;\r\nWARN_ON(irqs[i]->mc_dev);\r\nirqs[i]->mc_dev = mc_dev;\r\nirqs[i]->dev_irq_index = i;\r\n}\r\nmc_dev->irqs = irqs;\r\nreturn 0;\r\nerror_resource_alloc:\r\nfor (i = 0; i < res_allocated_count; i++) {\r\nirqs[i]->mc_dev = NULL;\r\nfsl_mc_resource_free(&irqs[i]->resource);\r\n}\r\nreturn error;\r\n}\r\nvoid fsl_mc_free_irqs(struct fsl_mc_device *mc_dev)\r\n{\r\nint i;\r\nint irq_count;\r\nstruct fsl_mc_bus *mc_bus;\r\nstruct fsl_mc_device_irq **irqs = mc_dev->irqs;\r\nif (WARN_ON(!irqs))\r\nreturn;\r\nirq_count = mc_dev->obj_desc.irq_count;\r\nif (strcmp(mc_dev->obj_desc.type, "dprc") == 0)\r\nmc_bus = to_fsl_mc_bus(mc_dev);\r\nelse\r\nmc_bus = to_fsl_mc_bus(to_fsl_mc_device(mc_dev->dev.parent));\r\nif (WARN_ON(!mc_bus->irq_resources))\r\nreturn;\r\nfor (i = 0; i < irq_count; i++) {\r\nWARN_ON(!irqs[i]->mc_dev);\r\nirqs[i]->mc_dev = NULL;\r\nfsl_mc_resource_free(&irqs[i]->resource);\r\n}\r\nmc_dev->irqs = NULL;\r\n}\r\nvoid fsl_mc_init_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint pool_type;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++) {\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[pool_type];\r\nres_pool->type = pool_type;\r\nres_pool->max_count = 0;\r\nres_pool->free_count = 0;\r\nres_pool->mc_bus = mc_bus;\r\nINIT_LIST_HEAD(&res_pool->free_list);\r\nmutex_init(&res_pool->mutex);\r\n}\r\n}\r\nstatic void fsl_mc_cleanup_resource_pool(struct fsl_mc_device *mc_bus_dev,\r\nenum fsl_mc_pool_type pool_type)\r\n{\r\nstruct fsl_mc_resource *resource;\r\nstruct fsl_mc_resource *next;\r\nstruct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nstruct fsl_mc_resource_pool *res_pool =\r\n&mc_bus->resource_pools[pool_type];\r\nint free_count = 0;\r\nWARN_ON(res_pool->type != pool_type);\r\nWARN_ON(res_pool->free_count != res_pool->max_count);\r\nlist_for_each_entry_safe(resource, next, &res_pool->free_list, node) {\r\nfree_count++;\r\nWARN_ON(resource->type != res_pool->type);\r\nWARN_ON(resource->parent_pool != res_pool);\r\ndevm_kfree(&mc_bus_dev->dev, resource);\r\n}\r\nWARN_ON(free_count != res_pool->free_count);\r\n}\r\nvoid fsl_mc_cleanup_all_resource_pools(struct fsl_mc_device *mc_bus_dev)\r\n{\r\nint pool_type;\r\nfor (pool_type = 0; pool_type < FSL_MC_NUM_POOL_TYPES; pool_type++)\r\nfsl_mc_cleanup_resource_pool(mc_bus_dev, pool_type);\r\n}\r\nstatic int fsl_mc_allocator_probe(struct fsl_mc_device *mc_dev)\r\n{\r\nenum fsl_mc_pool_type pool_type;\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nint error;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\nreturn -EINVAL;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\nif (WARN_ON(!dev_is_fsl_mc(&mc_bus_dev->dev)))\r\nreturn -EINVAL;\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\nerror = object_type_to_pool_type(mc_dev->obj_desc.type, &pool_type);\r\nif (error < 0)\r\nreturn error;\r\nerror = fsl_mc_resource_pool_add_device(mc_bus, pool_type, mc_dev);\r\nif (error < 0)\r\nreturn error;\r\ndev_dbg(&mc_dev->dev,\r\n"Allocatable fsl-mc device bound to fsl_mc_allocator driver");\r\nreturn 0;\r\n}\r\nstatic int fsl_mc_allocator_remove(struct fsl_mc_device *mc_dev)\r\n{\r\nint error;\r\nif (WARN_ON(!FSL_MC_IS_ALLOCATABLE(mc_dev->obj_desc.type)))\r\nreturn -EINVAL;\r\nif (mc_dev->resource) {\r\nerror = fsl_mc_resource_pool_remove_device(mc_dev);\r\nif (error < 0)\r\nreturn error;\r\n}\r\ndev_dbg(&mc_dev->dev,\r\n"Allocatable fsl-mc device unbound from fsl_mc_allocator driver");\r\nreturn 0;\r\n}\r\nint __init fsl_mc_allocator_driver_init(void)\r\n{\r\nreturn fsl_mc_driver_register(&fsl_mc_allocator_driver);\r\n}\r\nvoid fsl_mc_allocator_driver_exit(void)\r\n{\r\nfsl_mc_driver_unregister(&fsl_mc_allocator_driver);\r\n}
