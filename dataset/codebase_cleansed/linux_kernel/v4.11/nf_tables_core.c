static noinline void __nft_trace_packet(struct nft_traceinfo *info,\r\nconst struct nft_chain *chain,\r\nint rulenum, enum nft_trace_types type)\r\n{\r\nconst struct nft_pktinfo *pkt = info->pkt;\r\nif (!info->trace || !pkt->skb->nf_trace)\r\nreturn;\r\ninfo->chain = chain;\r\ninfo->type = type;\r\nnft_trace_notify(info);\r\nnf_log_trace(nft_net(pkt), nft_pf(pkt), nft_hook(pkt), pkt->skb,\r\nnft_in(pkt), nft_out(pkt), &trace_loginfo,\r\n"TRACE: %s:%s:%s:%u ",\r\nchain->table->name, chain->name, comments[type], rulenum);\r\n}\r\nstatic inline void nft_trace_packet(struct nft_traceinfo *info,\r\nconst struct nft_chain *chain,\r\nconst struct nft_rule *rule,\r\nint rulenum,\r\nenum nft_trace_types type)\r\n{\r\nif (static_branch_unlikely(&nft_trace_enabled)) {\r\ninfo->rule = rule;\r\n__nft_trace_packet(info, chain, rulenum, type);\r\n}\r\n}\r\nstatic void nft_cmp_fast_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs)\r\n{\r\nconst struct nft_cmp_fast_expr *priv = nft_expr_priv(expr);\r\nu32 mask = nft_cmp_fast_mask(priv->len);\r\nif ((regs->data[priv->sreg] & mask) == priv->data)\r\nreturn;\r\nregs->verdict.code = NFT_BREAK;\r\n}\r\nstatic bool nft_payload_fast_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_payload *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nu32 *dest = &regs->data[priv->dreg];\r\nunsigned char *ptr;\r\nif (priv->base == NFT_PAYLOAD_NETWORK_HEADER)\r\nptr = skb_network_header(skb);\r\nelse {\r\nif (!pkt->tprot_set)\r\nreturn false;\r\nptr = skb_network_header(skb) + pkt->xt.thoff;\r\n}\r\nptr += priv->offset;\r\nif (unlikely(ptr + priv->len > skb_tail_pointer(skb)))\r\nreturn false;\r\n*dest = 0;\r\nif (priv->len == 2)\r\n*(u16 *)dest = *(u16 *)ptr;\r\nelse if (priv->len == 4)\r\n*(u32 *)dest = *(u32 *)ptr;\r\nelse\r\n*(u8 *)dest = *(u8 *)ptr;\r\nreturn true;\r\n}\r\nunsigned int\r\nnft_do_chain(struct nft_pktinfo *pkt, void *priv)\r\n{\r\nconst struct nft_chain *chain = priv, *basechain = chain;\r\nconst struct net *net = nft_net(pkt);\r\nconst struct nft_rule *rule;\r\nconst struct nft_expr *expr, *last;\r\nstruct nft_regs regs;\r\nunsigned int stackptr = 0;\r\nstruct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];\r\nstruct nft_stats *stats;\r\nint rulenum;\r\nunsigned int gencursor = nft_genmask_cur(net);\r\nstruct nft_traceinfo info;\r\ninfo.trace = false;\r\nif (static_branch_unlikely(&nft_trace_enabled))\r\nnft_trace_init(&info, pkt, &regs.verdict, basechain);\r\ndo_chain:\r\nrulenum = 0;\r\nrule = list_entry(&chain->rules, struct nft_rule, list);\r\nnext_rule:\r\nregs.verdict.code = NFT_CONTINUE;\r\nlist_for_each_entry_continue_rcu(rule, &chain->rules, list) {\r\nif (unlikely(rule->genmask & gencursor))\r\ncontinue;\r\nrulenum++;\r\nnft_rule_for_each_expr(expr, last, rule) {\r\nif (expr->ops == &nft_cmp_fast_ops)\r\nnft_cmp_fast_eval(expr, &regs);\r\nelse if (expr->ops != &nft_payload_fast_ops ||\r\n!nft_payload_fast_eval(expr, &regs, pkt))\r\nexpr->ops->eval(expr, &regs, pkt);\r\nif (regs.verdict.code != NFT_CONTINUE)\r\nbreak;\r\n}\r\nswitch (regs.verdict.code) {\r\ncase NFT_BREAK:\r\nregs.verdict.code = NFT_CONTINUE;\r\ncontinue;\r\ncase NFT_CONTINUE:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nswitch (regs.verdict.code & NF_VERDICT_MASK) {\r\ncase NF_ACCEPT:\r\ncase NF_DROP:\r\ncase NF_QUEUE:\r\ncase NF_STOLEN:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\nreturn regs.verdict.code;\r\n}\r\nswitch (regs.verdict.code) {\r\ncase NFT_JUMP:\r\nBUG_ON(stackptr >= NFT_JUMP_STACK_SIZE);\r\njumpstack[stackptr].chain = chain;\r\njumpstack[stackptr].rule = rule;\r\njumpstack[stackptr].rulenum = rulenum;\r\nstackptr++;\r\ncase NFT_GOTO:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RULE);\r\nchain = regs.verdict.chain;\r\ngoto do_chain;\r\ncase NFT_CONTINUE:\r\nrulenum++;\r\ncase NFT_RETURN:\r\nnft_trace_packet(&info, chain, rule,\r\nrulenum, NFT_TRACETYPE_RETURN);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\nif (stackptr > 0) {\r\nstackptr--;\r\nchain = jumpstack[stackptr].chain;\r\nrule = jumpstack[stackptr].rule;\r\nrulenum = jumpstack[stackptr].rulenum;\r\ngoto next_rule;\r\n}\r\nnft_trace_packet(&info, basechain, NULL, -1,\r\nNFT_TRACETYPE_POLICY);\r\nrcu_read_lock_bh();\r\nstats = this_cpu_ptr(rcu_dereference(nft_base_chain(basechain)->stats));\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->pkts++;\r\nstats->bytes += pkt->skb->len;\r\nu64_stats_update_end(&stats->syncp);\r\nrcu_read_unlock_bh();\r\nreturn nft_base_chain(basechain)->policy;\r\n}\r\nint __init nf_tables_core_module_init(void)\r\n{\r\nint err, i;\r\nfor (i = 0; i < ARRAY_SIZE(nft_basic_types); i++) {\r\nerr = nft_register_expr(nft_basic_types[i]);\r\nif (err)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nwhile (i-- > 0)\r\nnft_unregister_expr(nft_basic_types[i]);\r\nreturn err;\r\n}\r\nvoid nf_tables_core_module_exit(void)\r\n{\r\nint i;\r\ni = ARRAY_SIZE(nft_basic_types);\r\nwhile (i-- > 0)\r\nnft_unregister_expr(nft_basic_types[i]);\r\n}
