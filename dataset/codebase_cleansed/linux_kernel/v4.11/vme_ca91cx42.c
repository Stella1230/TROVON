static u32 ca91cx42_DMA_irqhandler(struct ca91cx42_driver *bridge)\r\n{\r\nwake_up(&bridge->dma_queue);\r\nreturn CA91CX42_LINT_DMA;\r\n}\r\nstatic u32 ca91cx42_LM_irqhandler(struct ca91cx42_driver *bridge, u32 stat)\r\n{\r\nint i;\r\nu32 serviced = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (stat & CA91CX42_LINT_LM[i]) {\r\nbridge->lm_callback[i](bridge->lm_data[i]);\r\nserviced |= CA91CX42_LINT_LM[i];\r\n}\r\n}\r\nreturn serviced;\r\n}\r\nstatic u32 ca91cx42_MB_irqhandler(struct ca91cx42_driver *bridge, int mbox_mask)\r\n{\r\nwake_up(&bridge->mbox_queue);\r\nreturn CA91CX42_LINT_MBOX;\r\n}\r\nstatic u32 ca91cx42_IACK_irqhandler(struct ca91cx42_driver *bridge)\r\n{\r\nwake_up(&bridge->iack_queue);\r\nreturn CA91CX42_LINT_SW_IACK;\r\n}\r\nstatic u32 ca91cx42_VERR_irqhandler(struct vme_bridge *ca91cx42_bridge)\r\n{\r\nint val;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nval = ioread32(bridge->base + DGCS);\r\nif (!(val & 0x00000800)) {\r\ndev_err(ca91cx42_bridge->parent, "ca91cx42_VERR_irqhandler DMA "\r\n"Read Error DGCS=%08X\n", val);\r\n}\r\nreturn CA91CX42_LINT_VERR;\r\n}\r\nstatic u32 ca91cx42_LERR_irqhandler(struct vme_bridge *ca91cx42_bridge)\r\n{\r\nint val;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nval = ioread32(bridge->base + DGCS);\r\nif (!(val & 0x00000800))\r\ndev_err(ca91cx42_bridge->parent, "ca91cx42_LERR_irqhandler DMA "\r\n"Read Error DGCS=%08X\n", val);\r\nreturn CA91CX42_LINT_LERR;\r\n}\r\nstatic u32 ca91cx42_VIRQ_irqhandler(struct vme_bridge *ca91cx42_bridge,\r\nint stat)\r\n{\r\nint vec, i, serviced = 0;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nfor (i = 7; i > 0; i--) {\r\nif (stat & (1 << i)) {\r\nvec = ioread32(bridge->base +\r\nCA91CX42_V_STATID[i]) & 0xff;\r\nvme_irq_handler(ca91cx42_bridge, i, vec);\r\nserviced |= (1 << i);\r\n}\r\n}\r\nreturn serviced;\r\n}\r\nstatic irqreturn_t ca91cx42_irqhandler(int irq, void *ptr)\r\n{\r\nu32 stat, enable, serviced = 0;\r\nstruct vme_bridge *ca91cx42_bridge;\r\nstruct ca91cx42_driver *bridge;\r\nca91cx42_bridge = ptr;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nenable = ioread32(bridge->base + LINT_EN);\r\nstat = ioread32(bridge->base + LINT_STAT);\r\nstat &= enable;\r\nif (unlikely(!stat))\r\nreturn IRQ_NONE;\r\nif (stat & CA91CX42_LINT_DMA)\r\nserviced |= ca91cx42_DMA_irqhandler(bridge);\r\nif (stat & (CA91CX42_LINT_LM0 | CA91CX42_LINT_LM1 | CA91CX42_LINT_LM2 |\r\nCA91CX42_LINT_LM3))\r\nserviced |= ca91cx42_LM_irqhandler(bridge, stat);\r\nif (stat & CA91CX42_LINT_MBOX)\r\nserviced |= ca91cx42_MB_irqhandler(bridge, stat);\r\nif (stat & CA91CX42_LINT_SW_IACK)\r\nserviced |= ca91cx42_IACK_irqhandler(bridge);\r\nif (stat & CA91CX42_LINT_VERR)\r\nserviced |= ca91cx42_VERR_irqhandler(ca91cx42_bridge);\r\nif (stat & CA91CX42_LINT_LERR)\r\nserviced |= ca91cx42_LERR_irqhandler(ca91cx42_bridge);\r\nif (stat & (CA91CX42_LINT_VIRQ1 | CA91CX42_LINT_VIRQ2 |\r\nCA91CX42_LINT_VIRQ3 | CA91CX42_LINT_VIRQ4 |\r\nCA91CX42_LINT_VIRQ5 | CA91CX42_LINT_VIRQ6 |\r\nCA91CX42_LINT_VIRQ7))\r\nserviced |= ca91cx42_VIRQ_irqhandler(ca91cx42_bridge, stat);\r\niowrite32(serviced, bridge->base + LINT_STAT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ca91cx42_irq_init(struct vme_bridge *ca91cx42_bridge)\r\n{\r\nint result, tmp;\r\nstruct pci_dev *pdev;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\npdev = to_pci_dev(ca91cx42_bridge->parent);\r\niowrite32(0, bridge->base + VINT_EN);\r\niowrite32(0, bridge->base + LINT_EN);\r\niowrite32(0x00FFFFFF, bridge->base + LINT_STAT);\r\nresult = request_irq(pdev->irq, ca91cx42_irqhandler, IRQF_SHARED,\r\ndriver_name, ca91cx42_bridge);\r\nif (result) {\r\ndev_err(&pdev->dev, "Can't get assigned pci irq vector %02X\n",\r\npdev->irq);\r\nreturn result;\r\n}\r\niowrite32(0, bridge->base + LINT_MAP0);\r\niowrite32(0, bridge->base + LINT_MAP1);\r\niowrite32(0, bridge->base + LINT_MAP2);\r\ntmp = CA91CX42_LINT_MBOX3 | CA91CX42_LINT_MBOX2 | CA91CX42_LINT_MBOX1 |\r\nCA91CX42_LINT_MBOX0 | CA91CX42_LINT_SW_IACK |\r\nCA91CX42_LINT_VERR | CA91CX42_LINT_LERR | CA91CX42_LINT_DMA;\r\niowrite32(tmp, bridge->base + LINT_EN);\r\nreturn 0;\r\n}\r\nstatic void ca91cx42_irq_exit(struct ca91cx42_driver *bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct vme_bridge *ca91cx42_bridge;\r\niowrite32(0, bridge->base + VINT_EN);\r\niowrite32(0, bridge->base + LINT_EN);\r\niowrite32(0x00FFFFFF, bridge->base + LINT_STAT);\r\nca91cx42_bridge = container_of((void *)bridge, struct vme_bridge,\r\ndriver_priv);\r\nfree_irq(pdev->irq, ca91cx42_bridge);\r\n}\r\nstatic int ca91cx42_iack_received(struct ca91cx42_driver *bridge, int level)\r\n{\r\nu32 tmp;\r\ntmp = ioread32(bridge->base + LINT_STAT);\r\nif (tmp & (1 << level))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void ca91cx42_irq_set(struct vme_bridge *ca91cx42_bridge, int level,\r\nint state, int sync)\r\n{\r\nstruct pci_dev *pdev;\r\nu32 tmp;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\ntmp = ioread32(bridge->base + LINT_EN);\r\nif (state == 0)\r\ntmp &= ~CA91CX42_LINT_VIRQ[level];\r\nelse\r\ntmp |= CA91CX42_LINT_VIRQ[level];\r\niowrite32(tmp, bridge->base + LINT_EN);\r\nif ((state == 0) && (sync != 0)) {\r\npdev = to_pci_dev(ca91cx42_bridge->parent);\r\nsynchronize_irq(pdev->irq);\r\n}\r\n}\r\nstatic int ca91cx42_irq_generate(struct vme_bridge *ca91cx42_bridge, int level,\r\nint statid)\r\n{\r\nu32 tmp;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nif (statid & 1)\r\nreturn -EINVAL;\r\nmutex_lock(&bridge->vme_int);\r\ntmp = ioread32(bridge->base + VINT_EN);\r\niowrite32(statid << 24, bridge->base + STATID);\r\ntmp = tmp | (1 << (level + 24));\r\niowrite32(tmp, bridge->base + VINT_EN);\r\nwait_event_interruptible(bridge->iack_queue,\r\nca91cx42_iack_received(bridge, level));\r\ntmp = ioread32(bridge->base + VINT_EN);\r\ntmp = tmp & ~(1 << (level + 24));\r\niowrite32(tmp, bridge->base + VINT_EN);\r\nmutex_unlock(&bridge->vme_int);\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_slave_set(struct vme_slave_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size,\r\ndma_addr_t pci_base, u32 aspace, u32 cycle)\r\n{\r\nunsigned int i, addr = 0, granularity;\r\nunsigned int temp_ctl = 0;\r\nunsigned int vme_bound, pci_offset;\r\nstruct vme_bridge *ca91cx42_bridge;\r\nstruct ca91cx42_driver *bridge;\r\nca91cx42_bridge = image->parent;\r\nbridge = ca91cx42_bridge->driver_priv;\r\ni = image->number;\r\nswitch (aspace) {\r\ncase VME_A16:\r\naddr |= CA91CX42_VSI_CTL_VAS_A16;\r\nbreak;\r\ncase VME_A24:\r\naddr |= CA91CX42_VSI_CTL_VAS_A24;\r\nbreak;\r\ncase VME_A32:\r\naddr |= CA91CX42_VSI_CTL_VAS_A32;\r\nbreak;\r\ncase VME_USER1:\r\naddr |= CA91CX42_VSI_CTL_VAS_USER1;\r\nbreak;\r\ncase VME_USER2:\r\naddr |= CA91CX42_VSI_CTL_VAS_USER2;\r\nbreak;\r\ncase VME_A64:\r\ncase VME_CRCSR:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\ndefault:\r\ndev_err(ca91cx42_bridge->parent, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nvme_bound = vme_base + size;\r\npci_offset = pci_base - vme_base;\r\nif ((i == 0) || (i == 4))\r\ngranularity = 0x1000;\r\nelse\r\ngranularity = 0x10000;\r\nif (vme_base & (granularity - 1)) {\r\ndev_err(ca91cx42_bridge->parent, "Invalid VME base "\r\n"alignment\n");\r\nreturn -EINVAL;\r\n}\r\nif (vme_bound & (granularity - 1)) {\r\ndev_err(ca91cx42_bridge->parent, "Invalid VME bound "\r\n"alignment\n");\r\nreturn -EINVAL;\r\n}\r\nif (pci_offset & (granularity - 1)) {\r\ndev_err(ca91cx42_bridge->parent, "Invalid PCI Offset "\r\n"alignment\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_ctl = ioread32(bridge->base + CA91CX42_VSI_CTL[i]);\r\ntemp_ctl &= ~CA91CX42_VSI_CTL_EN;\r\niowrite32(temp_ctl, bridge->base + CA91CX42_VSI_CTL[i]);\r\niowrite32(vme_base, bridge->base + CA91CX42_VSI_BS[i]);\r\niowrite32(vme_bound, bridge->base + CA91CX42_VSI_BD[i]);\r\niowrite32(pci_offset, bridge->base + CA91CX42_VSI_TO[i]);\r\ntemp_ctl &= ~CA91CX42_VSI_CTL_VAS_M;\r\ntemp_ctl |= addr;\r\ntemp_ctl &= ~(CA91CX42_VSI_CTL_PGM_M | CA91CX42_VSI_CTL_SUPER_M);\r\nif (cycle & VME_SUPER)\r\ntemp_ctl |= CA91CX42_VSI_CTL_SUPER_SUPR;\r\nif (cycle & VME_USER)\r\ntemp_ctl |= CA91CX42_VSI_CTL_SUPER_NPRIV;\r\nif (cycle & VME_PROG)\r\ntemp_ctl |= CA91CX42_VSI_CTL_PGM_PGM;\r\nif (cycle & VME_DATA)\r\ntemp_ctl |= CA91CX42_VSI_CTL_PGM_DATA;\r\niowrite32(temp_ctl, bridge->base + CA91CX42_VSI_CTL[i]);\r\nif (enabled)\r\ntemp_ctl |= CA91CX42_VSI_CTL_EN;\r\niowrite32(temp_ctl, bridge->base + CA91CX42_VSI_CTL[i]);\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_slave_get(struct vme_slave_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\ndma_addr_t *pci_base, u32 *aspace, u32 *cycle)\r\n{\r\nunsigned int i, granularity = 0, ctl = 0;\r\nunsigned long long vme_bound, pci_offset;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nif ((i == 0) || (i == 4))\r\ngranularity = 0x1000;\r\nelse\r\ngranularity = 0x10000;\r\nctl = ioread32(bridge->base + CA91CX42_VSI_CTL[i]);\r\n*vme_base = ioread32(bridge->base + CA91CX42_VSI_BS[i]);\r\nvme_bound = ioread32(bridge->base + CA91CX42_VSI_BD[i]);\r\npci_offset = ioread32(bridge->base + CA91CX42_VSI_TO[i]);\r\n*pci_base = (dma_addr_t)*vme_base + pci_offset;\r\n*size = (unsigned long long)((vme_bound - *vme_base) + granularity);\r\n*enabled = 0;\r\n*aspace = 0;\r\n*cycle = 0;\r\nif (ctl & CA91CX42_VSI_CTL_EN)\r\n*enabled = 1;\r\nif ((ctl & CA91CX42_VSI_CTL_VAS_M) == CA91CX42_VSI_CTL_VAS_A16)\r\n*aspace = VME_A16;\r\nif ((ctl & CA91CX42_VSI_CTL_VAS_M) == CA91CX42_VSI_CTL_VAS_A24)\r\n*aspace = VME_A24;\r\nif ((ctl & CA91CX42_VSI_CTL_VAS_M) == CA91CX42_VSI_CTL_VAS_A32)\r\n*aspace = VME_A32;\r\nif ((ctl & CA91CX42_VSI_CTL_VAS_M) == CA91CX42_VSI_CTL_VAS_USER1)\r\n*aspace = VME_USER1;\r\nif ((ctl & CA91CX42_VSI_CTL_VAS_M) == CA91CX42_VSI_CTL_VAS_USER2)\r\n*aspace = VME_USER2;\r\nif (ctl & CA91CX42_VSI_CTL_SUPER_SUPR)\r\n*cycle |= VME_SUPER;\r\nif (ctl & CA91CX42_VSI_CTL_SUPER_NPRIV)\r\n*cycle |= VME_USER;\r\nif (ctl & CA91CX42_VSI_CTL_PGM_PGM)\r\n*cycle |= VME_PROG;\r\nif (ctl & CA91CX42_VSI_CTL_PGM_DATA)\r\n*cycle |= VME_DATA;\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_alloc_resource(struct vme_master_resource *image,\r\nunsigned long long size)\r\n{\r\nunsigned long long existing_size;\r\nint retval = 0;\r\nstruct pci_dev *pdev;\r\nstruct vme_bridge *ca91cx42_bridge;\r\nca91cx42_bridge = image->parent;\r\nif (ca91cx42_bridge->parent == NULL) {\r\ndev_err(ca91cx42_bridge->parent, "Dev entry NULL\n");\r\nreturn -EINVAL;\r\n}\r\npdev = to_pci_dev(ca91cx42_bridge->parent);\r\nexisting_size = (unsigned long long)(image->bus_resource.end -\r\nimage->bus_resource.start);\r\nif (existing_size == (size - 1))\r\nreturn 0;\r\nif (existing_size != 0) {\r\niounmap(image->kern_base);\r\nimage->kern_base = NULL;\r\nkfree(image->bus_resource.name);\r\nrelease_resource(&image->bus_resource);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\n}\r\nif (image->bus_resource.name == NULL) {\r\nimage->bus_resource.name = kmalloc(VMENAMSIZ+3, GFP_ATOMIC);\r\nif (image->bus_resource.name == NULL) {\r\ndev_err(ca91cx42_bridge->parent, "Unable to allocate "\r\n"memory for resource name\n");\r\nretval = -ENOMEM;\r\ngoto err_name;\r\n}\r\n}\r\nsprintf((char *)image->bus_resource.name, "%s.%d",\r\nca91cx42_bridge->name, image->number);\r\nimage->bus_resource.start = 0;\r\nimage->bus_resource.end = (unsigned long)size;\r\nimage->bus_resource.flags = IORESOURCE_MEM;\r\nretval = pci_bus_alloc_resource(pdev->bus,\r\n&image->bus_resource, size, 0x10000, PCIBIOS_MIN_MEM,\r\n0, NULL, NULL);\r\nif (retval) {\r\ndev_err(ca91cx42_bridge->parent, "Failed to allocate mem "\r\n"resource for window %d size 0x%lx start 0x%lx\n",\r\nimage->number, (unsigned long)size,\r\n(unsigned long)image->bus_resource.start);\r\ngoto err_resource;\r\n}\r\nimage->kern_base = ioremap_nocache(\r\nimage->bus_resource.start, size);\r\nif (image->kern_base == NULL) {\r\ndev_err(ca91cx42_bridge->parent, "Failed to remap resource\n");\r\nretval = -ENOMEM;\r\ngoto err_remap;\r\n}\r\nreturn 0;\r\nerr_remap:\r\nrelease_resource(&image->bus_resource);\r\nerr_resource:\r\nkfree(image->bus_resource.name);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\nerr_name:\r\nreturn retval;\r\n}\r\nstatic void ca91cx42_free_resource(struct vme_master_resource *image)\r\n{\r\niounmap(image->kern_base);\r\nimage->kern_base = NULL;\r\nrelease_resource(&image->bus_resource);\r\nkfree(image->bus_resource.name);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\n}\r\nstatic int ca91cx42_master_set(struct vme_master_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size, u32 aspace,\r\nu32 cycle, u32 dwidth)\r\n{\r\nint retval = 0;\r\nunsigned int i, granularity = 0;\r\nunsigned int temp_ctl = 0;\r\nunsigned long long pci_bound, vme_offset, pci_base;\r\nstruct vme_bridge *ca91cx42_bridge;\r\nstruct ca91cx42_driver *bridge;\r\nca91cx42_bridge = image->parent;\r\nbridge = ca91cx42_bridge->driver_priv;\r\ni = image->number;\r\nif ((i == 0) || (i == 4))\r\ngranularity = 0x1000;\r\nelse\r\ngranularity = 0x10000;\r\nif (vme_base & (granularity - 1)) {\r\ndev_err(ca91cx42_bridge->parent, "Invalid VME Window "\r\n"alignment\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nif (size & (granularity - 1)) {\r\ndev_err(ca91cx42_bridge->parent, "Invalid VME Window "\r\n"alignment\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nspin_lock(&image->lock);\r\nretval = ca91cx42_alloc_resource(image, size);\r\nif (retval) {\r\nspin_unlock(&image->lock);\r\ndev_err(ca91cx42_bridge->parent, "Unable to allocate memory "\r\n"for resource name\n");\r\nretval = -ENOMEM;\r\ngoto err_res;\r\n}\r\npci_base = (unsigned long long)image->bus_resource.start;\r\npci_bound = pci_base + size;\r\nvme_offset = vme_base - pci_base;\r\ntemp_ctl = ioread32(bridge->base + CA91CX42_LSI_CTL[i]);\r\ntemp_ctl &= ~CA91CX42_LSI_CTL_EN;\r\niowrite32(temp_ctl, bridge->base + CA91CX42_LSI_CTL[i]);\r\ntemp_ctl &= ~CA91CX42_LSI_CTL_VCT_M;\r\nif (cycle & VME_BLT)\r\ntemp_ctl |= CA91CX42_LSI_CTL_VCT_BLT;\r\nif (cycle & VME_MBLT)\r\ntemp_ctl |= CA91CX42_LSI_CTL_VCT_MBLT;\r\ntemp_ctl &= ~CA91CX42_LSI_CTL_VDW_M;\r\nswitch (dwidth) {\r\ncase VME_D8:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VDW_D8;\r\nbreak;\r\ncase VME_D16:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VDW_D16;\r\nbreak;\r\ncase VME_D32:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VDW_D32;\r\nbreak;\r\ncase VME_D64:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VDW_D64;\r\nbreak;\r\ndefault:\r\nspin_unlock(&image->lock);\r\ndev_err(ca91cx42_bridge->parent, "Invalid data width\n");\r\nretval = -EINVAL;\r\ngoto err_dwidth;\r\nbreak;\r\n}\r\ntemp_ctl &= ~CA91CX42_LSI_CTL_VAS_M;\r\nswitch (aspace) {\r\ncase VME_A16:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_A16;\r\nbreak;\r\ncase VME_A24:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_A24;\r\nbreak;\r\ncase VME_A32:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_A32;\r\nbreak;\r\ncase VME_CRCSR:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_CRCSR;\r\nbreak;\r\ncase VME_USER1:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_USER1;\r\nbreak;\r\ncase VME_USER2:\r\ntemp_ctl |= CA91CX42_LSI_CTL_VAS_USER2;\r\nbreak;\r\ncase VME_A64:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\ndefault:\r\nspin_unlock(&image->lock);\r\ndev_err(ca91cx42_bridge->parent, "Invalid address space\n");\r\nretval = -EINVAL;\r\ngoto err_aspace;\r\nbreak;\r\n}\r\ntemp_ctl &= ~(CA91CX42_LSI_CTL_PGM_M | CA91CX42_LSI_CTL_SUPER_M);\r\nif (cycle & VME_SUPER)\r\ntemp_ctl |= CA91CX42_LSI_CTL_SUPER_SUPR;\r\nif (cycle & VME_PROG)\r\ntemp_ctl |= CA91CX42_LSI_CTL_PGM_PGM;\r\niowrite32(pci_base, bridge->base + CA91CX42_LSI_BS[i]);\r\niowrite32(pci_bound, bridge->base + CA91CX42_LSI_BD[i]);\r\niowrite32(vme_offset, bridge->base + CA91CX42_LSI_TO[i]);\r\niowrite32(temp_ctl, bridge->base + CA91CX42_LSI_CTL[i]);\r\nif (enabled)\r\ntemp_ctl |= CA91CX42_LSI_CTL_EN;\r\niowrite32(temp_ctl, bridge->base + CA91CX42_LSI_CTL[i]);\r\nspin_unlock(&image->lock);\r\nreturn 0;\r\nerr_aspace:\r\nerr_dwidth:\r\nca91cx42_free_resource(image);\r\nerr_res:\r\nerr_window:\r\nreturn retval;\r\n}\r\nstatic int __ca91cx42_master_get(struct vme_master_resource *image,\r\nint *enabled, unsigned long long *vme_base, unsigned long long *size,\r\nu32 *aspace, u32 *cycle, u32 *dwidth)\r\n{\r\nunsigned int i, ctl;\r\nunsigned long long pci_base, pci_bound, vme_offset;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nctl = ioread32(bridge->base + CA91CX42_LSI_CTL[i]);\r\npci_base = ioread32(bridge->base + CA91CX42_LSI_BS[i]);\r\nvme_offset = ioread32(bridge->base + CA91CX42_LSI_TO[i]);\r\npci_bound = ioread32(bridge->base + CA91CX42_LSI_BD[i]);\r\n*vme_base = pci_base + vme_offset;\r\n*size = (unsigned long long)(pci_bound - pci_base);\r\n*enabled = 0;\r\n*aspace = 0;\r\n*cycle = 0;\r\n*dwidth = 0;\r\nif (ctl & CA91CX42_LSI_CTL_EN)\r\n*enabled = 1;\r\nswitch (ctl & CA91CX42_LSI_CTL_VAS_M) {\r\ncase CA91CX42_LSI_CTL_VAS_A16:\r\n*aspace = VME_A16;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VAS_A24:\r\n*aspace = VME_A24;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VAS_A32:\r\n*aspace = VME_A32;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VAS_CRCSR:\r\n*aspace = VME_CRCSR;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VAS_USER1:\r\n*aspace = VME_USER1;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VAS_USER2:\r\n*aspace = VME_USER2;\r\nbreak;\r\n}\r\nif (ctl & CA91CX42_LSI_CTL_VCT_BLT)\r\n*cycle |= VME_BLT;\r\nelse\r\n*cycle |= VME_SCT;\r\nif (ctl & CA91CX42_LSI_CTL_SUPER_SUPR)\r\n*cycle |= VME_SUPER;\r\nelse\r\n*cycle |= VME_USER;\r\nif (ctl & CA91CX42_LSI_CTL_PGM_PGM)\r\n*cycle = VME_PROG;\r\nelse\r\n*cycle = VME_DATA;\r\nswitch (ctl & CA91CX42_LSI_CTL_VDW_M) {\r\ncase CA91CX42_LSI_CTL_VDW_D8:\r\n*dwidth = VME_D8;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VDW_D16:\r\n*dwidth = VME_D16;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VDW_D32:\r\n*dwidth = VME_D32;\r\nbreak;\r\ncase CA91CX42_LSI_CTL_VDW_D64:\r\n*dwidth = VME_D64;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_master_get(struct vme_master_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\r\nu32 *cycle, u32 *dwidth)\r\n{\r\nint retval;\r\nspin_lock(&image->lock);\r\nretval = __ca91cx42_master_get(image, enabled, vme_base, size, aspace,\r\ncycle, dwidth);\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t ca91cx42_master_read(struct vme_master_resource *image,\r\nvoid *buf, size_t count, loff_t offset)\r\n{\r\nssize_t retval;\r\nvoid __iomem *addr = image->kern_base + offset;\r\nunsigned int done = 0;\r\nunsigned int count32;\r\nif (count == 0)\r\nreturn 0;\r\nspin_lock(&image->lock);\r\nif ((uintptr_t)addr & 0x1) {\r\n*(u8 *)buf = ioread8(addr);\r\ndone += 1;\r\nif (done == count)\r\ngoto out;\r\n}\r\nif ((uintptr_t)(addr + done) & 0x2) {\r\nif ((count - done) < 2) {\r\n*(u8 *)(buf + done) = ioread8(addr + done);\r\ndone += 1;\r\ngoto out;\r\n} else {\r\n*(u16 *)(buf + done) = ioread16(addr + done);\r\ndone += 2;\r\n}\r\n}\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\n*(u32 *)(buf + done) = ioread32(addr + done);\r\ndone += 4;\r\n}\r\nif ((count - done) & 0x2) {\r\n*(u16 *)(buf + done) = ioread16(addr + done);\r\ndone += 2;\r\n}\r\nif ((count - done) & 0x1) {\r\n*(u8 *)(buf + done) = ioread8(addr + done);\r\ndone += 1;\r\n}\r\nout:\r\nretval = count;\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t ca91cx42_master_write(struct vme_master_resource *image,\r\nvoid *buf, size_t count, loff_t offset)\r\n{\r\nssize_t retval;\r\nvoid __iomem *addr = image->kern_base + offset;\r\nunsigned int done = 0;\r\nunsigned int count32;\r\nif (count == 0)\r\nreturn 0;\r\nspin_lock(&image->lock);\r\nif ((uintptr_t)addr & 0x1) {\r\niowrite8(*(u8 *)buf, addr);\r\ndone += 1;\r\nif (done == count)\r\ngoto out;\r\n}\r\nif ((uintptr_t)(addr + done) & 0x2) {\r\nif ((count - done) < 2) {\r\niowrite8(*(u8 *)(buf + done), addr + done);\r\ndone += 1;\r\ngoto out;\r\n} else {\r\niowrite16(*(u16 *)(buf + done), addr + done);\r\ndone += 2;\r\n}\r\n}\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\niowrite32(*(u32 *)(buf + done), addr + done);\r\ndone += 4;\r\n}\r\nif ((count - done) & 0x2) {\r\niowrite16(*(u16 *)(buf + done), addr + done);\r\ndone += 2;\r\n}\r\nif ((count - done) & 0x1) {\r\niowrite8(*(u8 *)(buf + done), addr + done);\r\ndone += 1;\r\n}\r\nout:\r\nretval = count;\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic unsigned int ca91cx42_master_rmw(struct vme_master_resource *image,\r\nunsigned int mask, unsigned int compare, unsigned int swap,\r\nloff_t offset)\r\n{\r\nu32 result;\r\nuintptr_t pci_addr;\r\nint i;\r\nstruct ca91cx42_driver *bridge;\r\nstruct device *dev;\r\nbridge = image->parent->driver_priv;\r\ndev = image->parent->parent;\r\ni = image->number;\r\nmutex_lock(&bridge->vme_rmw);\r\nspin_lock(&image->lock);\r\npci_addr = (uintptr_t)image->kern_base + offset;\r\nif (pci_addr & 0x3) {\r\ndev_err(dev, "RMW Address not 4-byte aligned\n");\r\nresult = -EINVAL;\r\ngoto out;\r\n}\r\niowrite32(0, bridge->base + SCYC_CTL);\r\niowrite32(mask, bridge->base + SCYC_EN);\r\niowrite32(compare, bridge->base + SCYC_CMP);\r\niowrite32(swap, bridge->base + SCYC_SWP);\r\niowrite32(pci_addr, bridge->base + SCYC_ADDR);\r\niowrite32(CA91CX42_SCYC_CTL_CYC_RMW, bridge->base + SCYC_CTL);\r\nresult = ioread32(image->kern_base + offset);\r\niowrite32(0, bridge->base + SCYC_CTL);\r\nout:\r\nspin_unlock(&image->lock);\r\nmutex_unlock(&bridge->vme_rmw);\r\nreturn result;\r\n}\r\nstatic int ca91cx42_dma_list_add(struct vme_dma_list *list,\r\nstruct vme_dma_attr *src, struct vme_dma_attr *dest, size_t count)\r\n{\r\nstruct ca91cx42_dma_entry *entry, *prev;\r\nstruct vme_dma_pci *pci_attr;\r\nstruct vme_dma_vme *vme_attr;\r\ndma_addr_t desc_ptr;\r\nint retval = 0;\r\nstruct device *dev;\r\ndev = list->parent->parent->parent;\r\nentry = kmalloc(sizeof(struct ca91cx42_dma_entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\ndev_err(dev, "Failed to allocate memory for dma resource "\r\n"structure\n");\r\nretval = -ENOMEM;\r\ngoto err_mem;\r\n}\r\nif ((unsigned long)&entry->descriptor & CA91CX42_DCPP_M) {\r\ndev_err(dev, "Descriptor not aligned to 16 byte boundary as "\r\n"required: %p\n", &entry->descriptor);\r\nretval = -EINVAL;\r\ngoto err_align;\r\n}\r\nmemset(&entry->descriptor, 0, sizeof(struct ca91cx42_dma_descriptor));\r\nif (dest->type == VME_DMA_VME) {\r\nentry->descriptor.dctl |= CA91CX42_DCTL_L2V;\r\nvme_attr = dest->private;\r\npci_attr = src->private;\r\n} else {\r\nvme_attr = src->private;\r\npci_attr = dest->private;\r\n}\r\nif ((vme_attr->aspace & ~(VME_A16 | VME_A24 | VME_A32 | VME_USER1 |\r\nVME_USER2)) != 0) {\r\ndev_err(dev, "Unsupported cycle type\n");\r\nretval = -EINVAL;\r\ngoto err_aspace;\r\n}\r\nif ((vme_attr->cycle & ~(VME_SCT | VME_BLT | VME_SUPER | VME_USER |\r\nVME_PROG | VME_DATA)) != 0) {\r\ndev_err(dev, "Unsupported cycle type\n");\r\nretval = -EINVAL;\r\ngoto err_cycle;\r\n}\r\nif (!(((src->type == VME_DMA_PCI) && (dest->type == VME_DMA_VME)) ||\r\n((src->type == VME_DMA_VME) && (dest->type == VME_DMA_PCI)))) {\r\ndev_err(dev, "Cannot perform transfer with this "\r\n"source-destination combination\n");\r\nretval = -EINVAL;\r\ngoto err_direct;\r\n}\r\nif (vme_attr->cycle & VME_BLT)\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VCT_BLT;\r\nswitch (vme_attr->dwidth) {\r\ncase VME_D8:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VDW_D8;\r\nbreak;\r\ncase VME_D16:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VDW_D16;\r\nbreak;\r\ncase VME_D32:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VDW_D32;\r\nbreak;\r\ncase VME_D64:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VDW_D64;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid data width\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (vme_attr->aspace) {\r\ncase VME_A16:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VAS_A16;\r\nbreak;\r\ncase VME_A24:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VAS_A24;\r\nbreak;\r\ncase VME_A32:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VAS_A32;\r\nbreak;\r\ncase VME_USER1:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VAS_USER1;\r\nbreak;\r\ncase VME_USER2:\r\nentry->descriptor.dctl |= CA91CX42_DCTL_VAS_USER2;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (vme_attr->cycle & VME_SUPER)\r\nentry->descriptor.dctl |= CA91CX42_DCTL_SUPER_SUPR;\r\nif (vme_attr->cycle & VME_PROG)\r\nentry->descriptor.dctl |= CA91CX42_DCTL_PGM_PGM;\r\nentry->descriptor.dtbc = count;\r\nentry->descriptor.dla = pci_attr->address;\r\nentry->descriptor.dva = vme_attr->address;\r\nentry->descriptor.dcpp = CA91CX42_DCPP_NULL;\r\nlist_add_tail(&entry->list, &list->entries);\r\nif (entry->list.prev != &list->entries) {\r\nprev = list_entry(entry->list.prev, struct ca91cx42_dma_entry,\r\nlist);\r\ndesc_ptr = virt_to_bus(&entry->descriptor);\r\nprev->descriptor.dcpp = desc_ptr & ~CA91CX42_DCPP_M;\r\n}\r\nreturn 0;\r\nerr_cycle:\r\nerr_aspace:\r\nerr_direct:\r\nerr_align:\r\nkfree(entry);\r\nerr_mem:\r\nreturn retval;\r\n}\r\nstatic int ca91cx42_dma_busy(struct vme_bridge *ca91cx42_bridge)\r\n{\r\nu32 tmp;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\ntmp = ioread32(bridge->base + DGCS);\r\nif (tmp & CA91CX42_DGCS_ACT)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int ca91cx42_dma_list_exec(struct vme_dma_list *list)\r\n{\r\nstruct vme_dma_resource *ctrlr;\r\nstruct ca91cx42_dma_entry *entry;\r\nint retval;\r\ndma_addr_t bus_addr;\r\nu32 val;\r\nstruct device *dev;\r\nstruct ca91cx42_driver *bridge;\r\nctrlr = list->parent;\r\nbridge = ctrlr->parent->driver_priv;\r\ndev = ctrlr->parent->parent;\r\nmutex_lock(&ctrlr->mtx);\r\nif (!(list_empty(&ctrlr->running))) {\r\nmutex_unlock(&ctrlr->mtx);\r\nreturn -EBUSY;\r\n} else {\r\nlist_add(&list->list, &ctrlr->running);\r\n}\r\nentry = list_first_entry(&list->entries, struct ca91cx42_dma_entry,\r\nlist);\r\nbus_addr = virt_to_bus(&entry->descriptor);\r\nmutex_unlock(&ctrlr->mtx);\r\niowrite32(0, bridge->base + DTBC);\r\niowrite32(bus_addr & ~CA91CX42_DCPP_M, bridge->base + DCPP);\r\nval = ioread32(bridge->base + DGCS);\r\nval &= (CA91CX42_DGCS_VON_M | CA91CX42_DGCS_VOFF_M);\r\nval |= (CA91CX42_DGCS_CHAIN | CA91CX42_DGCS_STOP | CA91CX42_DGCS_HALT |\r\nCA91CX42_DGCS_DONE | CA91CX42_DGCS_LERR | CA91CX42_DGCS_VERR |\r\nCA91CX42_DGCS_PERR);\r\niowrite32(val, bridge->base + DGCS);\r\nval |= CA91CX42_DGCS_GO;\r\niowrite32(val, bridge->base + DGCS);\r\nretval = wait_event_interruptible(bridge->dma_queue,\r\nca91cx42_dma_busy(ctrlr->parent));\r\nif (retval) {\r\nval = ioread32(bridge->base + DGCS);\r\niowrite32(val | CA91CX42_DGCS_STOP_REQ, bridge->base + DGCS);\r\nwait_event(bridge->dma_queue,\r\nca91cx42_dma_busy(ctrlr->parent));\r\nretval = -EINTR;\r\ngoto exit;\r\n}\r\nval = ioread32(bridge->base + DGCS);\r\nif (val & (CA91CX42_DGCS_LERR | CA91CX42_DGCS_VERR |\r\nCA91CX42_DGCS_PERR)) {\r\ndev_err(dev, "ca91c042: DMA Error. DGCS=%08X\n", val);\r\nval = ioread32(bridge->base + DCTL);\r\nretval = -EIO;\r\n}\r\nexit:\r\nmutex_lock(&ctrlr->mtx);\r\nlist_del(&list->list);\r\nmutex_unlock(&ctrlr->mtx);\r\nreturn retval;\r\n}\r\nstatic int ca91cx42_dma_list_empty(struct vme_dma_list *list)\r\n{\r\nstruct list_head *pos, *temp;\r\nstruct ca91cx42_dma_entry *entry;\r\nlist_for_each_safe(pos, temp, &list->entries) {\r\nlist_del(pos);\r\nentry = list_entry(pos, struct ca91cx42_dma_entry, list);\r\nkfree(entry);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_lm_set(struct vme_lm_resource *lm,\r\nunsigned long long lm_base, u32 aspace, u32 cycle)\r\n{\r\nu32 temp_base, lm_ctl = 0;\r\nint i;\r\nstruct ca91cx42_driver *bridge;\r\nstruct device *dev;\r\nbridge = lm->parent->driver_priv;\r\ndev = lm->parent->parent;\r\ntemp_base = (u32)lm_base;\r\nif (temp_base & 0xffff) {\r\ndev_err(dev, "Location monitor must be aligned to 64KB "\r\n"boundary");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&lm->mtx);\r\nfor (i = 0; i < lm->monitors; i++) {\r\nif (bridge->lm_callback[i] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(dev, "Location monitor callback attached, "\r\n"can't reset\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\nlm_ctl |= CA91CX42_LM_CTL_AS_A16;\r\nbreak;\r\ncase VME_A24:\r\nlm_ctl |= CA91CX42_LM_CTL_AS_A24;\r\nbreak;\r\ncase VME_A32:\r\nlm_ctl |= CA91CX42_LM_CTL_AS_A32;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&lm->mtx);\r\ndev_err(dev, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (cycle & VME_SUPER)\r\nlm_ctl |= CA91CX42_LM_CTL_SUPR;\r\nif (cycle & VME_USER)\r\nlm_ctl |= CA91CX42_LM_CTL_NPRIV;\r\nif (cycle & VME_PROG)\r\nlm_ctl |= CA91CX42_LM_CTL_PGM;\r\nif (cycle & VME_DATA)\r\nlm_ctl |= CA91CX42_LM_CTL_DATA;\r\niowrite32(lm_base, bridge->base + LM_BS);\r\niowrite32(lm_ctl, bridge->base + LM_CTL);\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_lm_get(struct vme_lm_resource *lm,\r\nunsigned long long *lm_base, u32 *aspace, u32 *cycle)\r\n{\r\nu32 lm_ctl, enabled = 0;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\n*lm_base = (unsigned long long)ioread32(bridge->base + LM_BS);\r\nlm_ctl = ioread32(bridge->base + LM_CTL);\r\nif (lm_ctl & CA91CX42_LM_CTL_EN)\r\nenabled = 1;\r\nif ((lm_ctl & CA91CX42_LM_CTL_AS_M) == CA91CX42_LM_CTL_AS_A16)\r\n*aspace = VME_A16;\r\nif ((lm_ctl & CA91CX42_LM_CTL_AS_M) == CA91CX42_LM_CTL_AS_A24)\r\n*aspace = VME_A24;\r\nif ((lm_ctl & CA91CX42_LM_CTL_AS_M) == CA91CX42_LM_CTL_AS_A32)\r\n*aspace = VME_A32;\r\n*cycle = 0;\r\nif (lm_ctl & CA91CX42_LM_CTL_SUPR)\r\n*cycle |= VME_SUPER;\r\nif (lm_ctl & CA91CX42_LM_CTL_NPRIV)\r\n*cycle |= VME_USER;\r\nif (lm_ctl & CA91CX42_LM_CTL_PGM)\r\n*cycle |= VME_PROG;\r\nif (lm_ctl & CA91CX42_LM_CTL_DATA)\r\n*cycle |= VME_DATA;\r\nmutex_unlock(&lm->mtx);\r\nreturn enabled;\r\n}\r\nstatic int ca91cx42_lm_attach(struct vme_lm_resource *lm, int monitor,\r\nvoid (*callback)(void *), void *data)\r\n{\r\nu32 lm_ctl, tmp;\r\nstruct ca91cx42_driver *bridge;\r\nstruct device *dev;\r\nbridge = lm->parent->driver_priv;\r\ndev = lm->parent->parent;\r\nmutex_lock(&lm->mtx);\r\nlm_ctl = ioread32(bridge->base + LM_CTL);\r\nif ((lm_ctl & (CA91CX42_LM_CTL_PGM | CA91CX42_LM_CTL_DATA)) == 0) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(dev, "Location monitor not properly configured\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->lm_callback[monitor] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(dev, "Existing callback attached\n");\r\nreturn -EBUSY;\r\n}\r\nbridge->lm_callback[monitor] = callback;\r\nbridge->lm_data[monitor] = data;\r\ntmp = ioread32(bridge->base + LINT_EN);\r\ntmp |= CA91CX42_LINT_LM[monitor];\r\niowrite32(tmp, bridge->base + LINT_EN);\r\nif ((lm_ctl & CA91CX42_LM_CTL_EN) == 0) {\r\nlm_ctl |= CA91CX42_LM_CTL_EN;\r\niowrite32(lm_ctl, bridge->base + LM_CTL);\r\n}\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_lm_detach(struct vme_lm_resource *lm, int monitor)\r\n{\r\nu32 tmp;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\ntmp = ioread32(bridge->base + LINT_EN);\r\ntmp &= ~CA91CX42_LINT_LM[monitor];\r\niowrite32(tmp, bridge->base + LINT_EN);\r\niowrite32(CA91CX42_LINT_LM[monitor],\r\nbridge->base + LINT_STAT);\r\nbridge->lm_callback[monitor] = NULL;\r\nbridge->lm_data[monitor] = NULL;\r\nif ((tmp & (CA91CX42_LINT_LM0 | CA91CX42_LINT_LM1 | CA91CX42_LINT_LM2 |\r\nCA91CX42_LINT_LM3)) == 0) {\r\ntmp = ioread32(bridge->base + LM_CTL);\r\ntmp &= ~CA91CX42_LM_CTL_EN;\r\niowrite32(tmp, bridge->base + LM_CTL);\r\n}\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int ca91cx42_slot_get(struct vme_bridge *ca91cx42_bridge)\r\n{\r\nu32 slot = 0;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nif (!geoid) {\r\nslot = ioread32(bridge->base + VCSR_BS);\r\nslot = ((slot & CA91CX42_VCSR_BS_SLOT_M) >> 27);\r\n} else\r\nslot = geoid;\r\nreturn (int)slot;\r\n}\r\nstatic void *ca91cx42_alloc_consistent(struct device *parent, size_t size,\r\ndma_addr_t *dma)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(parent);\r\nreturn pci_alloc_consistent(pdev, size, dma);\r\n}\r\nstatic void ca91cx42_free_consistent(struct device *parent, size_t size,\r\nvoid *vaddr, dma_addr_t dma)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = to_pci_dev(parent);\r\npci_free_consistent(pdev, size, vaddr, dma);\r\n}\r\nstatic int ca91cx42_crcsr_init(struct vme_bridge *ca91cx42_bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nunsigned int crcsr_addr;\r\nint tmp, slot;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\nslot = ca91cx42_slot_get(ca91cx42_bridge);\r\nif (geoid)\r\niowrite32(geoid << 27, bridge->base + VCSR_BS);\r\ndev_info(&pdev->dev, "CR/CSR Offset: %d\n", slot);\r\nif (slot == 0) {\r\ndev_err(&pdev->dev, "Slot number is unset, not configuring "\r\n"CR/CSR space\n");\r\nreturn -EINVAL;\r\n}\r\nbridge->crcsr_kernel = pci_zalloc_consistent(pdev, VME_CRCSR_BUF_SIZE,\r\n&bridge->crcsr_bus);\r\nif (bridge->crcsr_kernel == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for CR/CSR "\r\n"image\n");\r\nreturn -ENOMEM;\r\n}\r\ncrcsr_addr = slot * (512 * 1024);\r\niowrite32(bridge->crcsr_bus - crcsr_addr, bridge->base + VCSR_TO);\r\ntmp = ioread32(bridge->base + VCSR_CTL);\r\ntmp |= CA91CX42_VCSR_CTL_EN;\r\niowrite32(tmp, bridge->base + VCSR_CTL);\r\nreturn 0;\r\n}\r\nstatic void ca91cx42_crcsr_exit(struct vme_bridge *ca91cx42_bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nu32 tmp;\r\nstruct ca91cx42_driver *bridge;\r\nbridge = ca91cx42_bridge->driver_priv;\r\ntmp = ioread32(bridge->base + VCSR_CTL);\r\ntmp &= ~CA91CX42_VCSR_CTL_EN;\r\niowrite32(tmp, bridge->base + VCSR_CTL);\r\niowrite32(0, bridge->base + VCSR_TO);\r\npci_free_consistent(pdev, VME_CRCSR_BUF_SIZE, bridge->crcsr_kernel,\r\nbridge->crcsr_bus);\r\n}\r\nstatic int ca91cx42_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint retval, i;\r\nu32 data;\r\nstruct list_head *pos = NULL, *n;\r\nstruct vme_bridge *ca91cx42_bridge;\r\nstruct ca91cx42_driver *ca91cx42_device;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nstruct vme_dma_resource *dma_ctrlr;\r\nstruct vme_lm_resource *lm;\r\nca91cx42_bridge = kzalloc(sizeof(struct vme_bridge), GFP_KERNEL);\r\nif (ca91cx42_bridge == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for device "\r\n"structure\n");\r\nretval = -ENOMEM;\r\ngoto err_struct;\r\n}\r\nvme_init_bridge(ca91cx42_bridge);\r\nca91cx42_device = kzalloc(sizeof(struct ca91cx42_driver), GFP_KERNEL);\r\nif (ca91cx42_device == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for device "\r\n"structure\n");\r\nretval = -ENOMEM;\r\ngoto err_driver;\r\n}\r\nca91cx42_bridge->driver_priv = ca91cx42_device;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "Unable to enable device\n");\r\ngoto err_enable;\r\n}\r\nretval = pci_request_regions(pdev, driver_name);\r\nif (retval) {\r\ndev_err(&pdev->dev, "Unable to reserve resources\n");\r\ngoto err_resource;\r\n}\r\nca91cx42_device->base = ioremap_nocache(pci_resource_start(pdev, 0),\r\n4096);\r\nif (!ca91cx42_device->base) {\r\ndev_err(&pdev->dev, "Unable to remap CRG region\n");\r\nretval = -EIO;\r\ngoto err_remap;\r\n}\r\ndata = ioread32(ca91cx42_device->base + CA91CX42_PCI_ID) & 0x0000FFFF;\r\nif (data != PCI_VENDOR_ID_TUNDRA) {\r\ndev_err(&pdev->dev, "PCI_ID check failed\n");\r\nretval = -EIO;\r\ngoto err_test;\r\n}\r\ninit_waitqueue_head(&ca91cx42_device->dma_queue);\r\ninit_waitqueue_head(&ca91cx42_device->iack_queue);\r\nmutex_init(&ca91cx42_device->vme_int);\r\nmutex_init(&ca91cx42_device->vme_rmw);\r\nca91cx42_bridge->parent = &pdev->dev;\r\nstrcpy(ca91cx42_bridge->name, driver_name);\r\nretval = ca91cx42_irq_init(ca91cx42_bridge);\r\nif (retval != 0) {\r\ndev_err(&pdev->dev, "Chip Initialization failed.\n");\r\ngoto err_irq;\r\n}\r\nfor (i = 0; i < CA91C142_MAX_MASTER; i++) {\r\nmaster_image = kmalloc(sizeof(struct vme_master_resource),\r\nGFP_KERNEL);\r\nif (master_image == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"master resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_master;\r\n}\r\nmaster_image->parent = ca91cx42_bridge;\r\nspin_lock_init(&master_image->lock);\r\nmaster_image->locked = 0;\r\nmaster_image->number = i;\r\nmaster_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\r\nVME_CRCSR | VME_USER1 | VME_USER2;\r\nmaster_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_SUPER | VME_USER | VME_PROG | VME_DATA;\r\nmaster_image->width_attr = VME_D8 | VME_D16 | VME_D32 | VME_D64;\r\nmemset(&master_image->bus_resource, 0,\r\nsizeof(struct resource));\r\nmaster_image->kern_base = NULL;\r\nlist_add_tail(&master_image->list,\r\n&ca91cx42_bridge->master_resources);\r\n}\r\nfor (i = 0; i < CA91C142_MAX_SLAVE; i++) {\r\nslave_image = kmalloc(sizeof(struct vme_slave_resource),\r\nGFP_KERNEL);\r\nif (slave_image == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"slave resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_slave;\r\n}\r\nslave_image->parent = ca91cx42_bridge;\r\nmutex_init(&slave_image->mtx);\r\nslave_image->locked = 0;\r\nslave_image->number = i;\r\nslave_image->address_attr = VME_A24 | VME_A32 | VME_USER1 |\r\nVME_USER2;\r\nif (i == 0 || i == 4)\r\nslave_image->address_attr |= VME_A16;\r\nslave_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_SUPER | VME_USER | VME_PROG | VME_DATA;\r\nlist_add_tail(&slave_image->list,\r\n&ca91cx42_bridge->slave_resources);\r\n}\r\nfor (i = 0; i < CA91C142_MAX_DMA; i++) {\r\ndma_ctrlr = kmalloc(sizeof(struct vme_dma_resource),\r\nGFP_KERNEL);\r\nif (dma_ctrlr == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"dma resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_dma;\r\n}\r\ndma_ctrlr->parent = ca91cx42_bridge;\r\nmutex_init(&dma_ctrlr->mtx);\r\ndma_ctrlr->locked = 0;\r\ndma_ctrlr->number = i;\r\ndma_ctrlr->route_attr = VME_DMA_VME_TO_MEM |\r\nVME_DMA_MEM_TO_VME;\r\nINIT_LIST_HEAD(&dma_ctrlr->pending);\r\nINIT_LIST_HEAD(&dma_ctrlr->running);\r\nlist_add_tail(&dma_ctrlr->list,\r\n&ca91cx42_bridge->dma_resources);\r\n}\r\nlm = kmalloc(sizeof(struct vme_lm_resource), GFP_KERNEL);\r\nif (lm == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"location monitor resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_lm;\r\n}\r\nlm->parent = ca91cx42_bridge;\r\nmutex_init(&lm->mtx);\r\nlm->locked = 0;\r\nlm->number = 1;\r\nlm->monitors = 4;\r\nlist_add_tail(&lm->list, &ca91cx42_bridge->lm_resources);\r\nca91cx42_bridge->slave_get = ca91cx42_slave_get;\r\nca91cx42_bridge->slave_set = ca91cx42_slave_set;\r\nca91cx42_bridge->master_get = ca91cx42_master_get;\r\nca91cx42_bridge->master_set = ca91cx42_master_set;\r\nca91cx42_bridge->master_read = ca91cx42_master_read;\r\nca91cx42_bridge->master_write = ca91cx42_master_write;\r\nca91cx42_bridge->master_rmw = ca91cx42_master_rmw;\r\nca91cx42_bridge->dma_list_add = ca91cx42_dma_list_add;\r\nca91cx42_bridge->dma_list_exec = ca91cx42_dma_list_exec;\r\nca91cx42_bridge->dma_list_empty = ca91cx42_dma_list_empty;\r\nca91cx42_bridge->irq_set = ca91cx42_irq_set;\r\nca91cx42_bridge->irq_generate = ca91cx42_irq_generate;\r\nca91cx42_bridge->lm_set = ca91cx42_lm_set;\r\nca91cx42_bridge->lm_get = ca91cx42_lm_get;\r\nca91cx42_bridge->lm_attach = ca91cx42_lm_attach;\r\nca91cx42_bridge->lm_detach = ca91cx42_lm_detach;\r\nca91cx42_bridge->slot_get = ca91cx42_slot_get;\r\nca91cx42_bridge->alloc_consistent = ca91cx42_alloc_consistent;\r\nca91cx42_bridge->free_consistent = ca91cx42_free_consistent;\r\ndata = ioread32(ca91cx42_device->base + MISC_CTL);\r\ndev_info(&pdev->dev, "Board is%s the VME system controller\n",\r\n(data & CA91CX42_MISC_CTL_SYSCON) ? "" : " not");\r\ndev_info(&pdev->dev, "Slot ID is %d\n",\r\nca91cx42_slot_get(ca91cx42_bridge));\r\nif (ca91cx42_crcsr_init(ca91cx42_bridge, pdev))\r\ndev_err(&pdev->dev, "CR/CSR configuration failed.\n");\r\nretval = vme_register_bridge(ca91cx42_bridge);\r\nif (retval != 0) {\r\ndev_err(&pdev->dev, "Chip Registration failed.\n");\r\ngoto err_reg;\r\n}\r\npci_set_drvdata(pdev, ca91cx42_bridge);\r\nreturn 0;\r\nerr_reg:\r\nca91cx42_crcsr_exit(ca91cx42_bridge, pdev);\r\nerr_lm:\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->lm_resources) {\r\nlm = list_entry(pos, struct vme_lm_resource, list);\r\nlist_del(pos);\r\nkfree(lm);\r\n}\r\nerr_dma:\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->dma_resources) {\r\ndma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\r\nlist_del(pos);\r\nkfree(dma_ctrlr);\r\n}\r\nerr_slave:\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nerr_master:\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\nca91cx42_irq_exit(ca91cx42_device, pdev);\r\nerr_irq:\r\nerr_test:\r\niounmap(ca91cx42_device->base);\r\nerr_remap:\r\npci_release_regions(pdev);\r\nerr_resource:\r\npci_disable_device(pdev);\r\nerr_enable:\r\nkfree(ca91cx42_device);\r\nerr_driver:\r\nkfree(ca91cx42_bridge);\r\nerr_struct:\r\nreturn retval;\r\n}\r\nstatic void ca91cx42_remove(struct pci_dev *pdev)\r\n{\r\nstruct list_head *pos = NULL, *n;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nstruct vme_dma_resource *dma_ctrlr;\r\nstruct vme_lm_resource *lm;\r\nstruct ca91cx42_driver *bridge;\r\nstruct vme_bridge *ca91cx42_bridge = pci_get_drvdata(pdev);\r\nbridge = ca91cx42_bridge->driver_priv;\r\niowrite32(0, bridge->base + LINT_EN);\r\niowrite32(0x00800000, bridge->base + LSI0_CTL);\r\niowrite32(0x00800000, bridge->base + LSI1_CTL);\r\niowrite32(0x00800000, bridge->base + LSI2_CTL);\r\niowrite32(0x00800000, bridge->base + LSI3_CTL);\r\niowrite32(0x00800000, bridge->base + LSI4_CTL);\r\niowrite32(0x00800000, bridge->base + LSI5_CTL);\r\niowrite32(0x00800000, bridge->base + LSI6_CTL);\r\niowrite32(0x00800000, bridge->base + LSI7_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI0_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI1_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI2_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI3_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI4_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI5_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI6_CTL);\r\niowrite32(0x00F00000, bridge->base + VSI7_CTL);\r\nvme_unregister_bridge(ca91cx42_bridge);\r\nca91cx42_crcsr_exit(ca91cx42_bridge, pdev);\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->lm_resources) {\r\nlm = list_entry(pos, struct vme_lm_resource, list);\r\nlist_del(pos);\r\nkfree(lm);\r\n}\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->dma_resources) {\r\ndma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\r\nlist_del(pos);\r\nkfree(dma_ctrlr);\r\n}\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nlist_for_each_safe(pos, n, &ca91cx42_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\nca91cx42_irq_exit(bridge, pdev);\r\niounmap(bridge->base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(ca91cx42_bridge);\r\n}
