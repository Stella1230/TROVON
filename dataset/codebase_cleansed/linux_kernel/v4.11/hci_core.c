static ssize_t dut_mode_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hci_dev_test_flag(hdev, HCI_DUT_MODE) ? 'Y' : 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nstatic ssize_t dut_mode_write(struct file *file, const char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nstruct sk_buff *skb;\r\nchar buf[32];\r\nsize_t buf_size = min(count, (sizeof(buf)-1));\r\nbool enable;\r\nif (!test_bit(HCI_UP, &hdev->flags))\r\nreturn -ENETDOWN;\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = '\0';\r\nif (strtobool(buf, &enable))\r\nreturn -EINVAL;\r\nif (enable == hci_dev_test_flag(hdev, HCI_DUT_MODE))\r\nreturn -EALREADY;\r\nhci_req_sync_lock(hdev);\r\nif (enable)\r\nskb = __hci_cmd_sync(hdev, HCI_OP_ENABLE_DUT_MODE, 0, NULL,\r\nHCI_CMD_TIMEOUT);\r\nelse\r\nskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL,\r\nHCI_CMD_TIMEOUT);\r\nhci_req_sync_unlock(hdev);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nhci_dev_change_flag(hdev, HCI_DUT_MODE);\r\nreturn count;\r\n}\r\nstatic ssize_t vendor_diag_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[3];\r\nbuf[0] = hci_dev_test_flag(hdev, HCI_VENDOR_DIAG) ? 'Y' : 'N';\r\nbuf[1] = '\n';\r\nbuf[2] = '\0';\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\r\n}\r\nstatic ssize_t vendor_diag_write(struct file *file, const char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hci_dev *hdev = file->private_data;\r\nchar buf[32];\r\nsize_t buf_size = min(count, (sizeof(buf)-1));\r\nbool enable;\r\nint err;\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = '\0';\r\nif (strtobool(buf, &enable))\r\nreturn -EINVAL;\r\nif (test_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks) &&\r\n!test_bit(HCI_RUNNING, &hdev->flags))\r\ngoto done;\r\nhci_req_sync_lock(hdev);\r\nerr = hdev->set_diag(hdev, enable);\r\nhci_req_sync_unlock(hdev);\r\nif (err < 0)\r\nreturn err;\r\ndone:\r\nif (enable)\r\nhci_dev_set_flag(hdev, HCI_VENDOR_DIAG);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_VENDOR_DIAG);\r\nreturn count;\r\n}\r\nstatic void hci_debugfs_create_basic(struct hci_dev *hdev)\r\n{\r\ndebugfs_create_file("dut_mode", 0644, hdev->debugfs, hdev,\r\n&dut_mode_fops);\r\nif (hdev->set_diag)\r\ndebugfs_create_file("vendor_diag", 0644, hdev->debugfs, hdev,\r\n&vendor_diag_fops);\r\n}\r\nstatic int hci_reset_req(struct hci_request *req, unsigned long opt)\r\n{\r\nBT_DBG("%s %ld", req->hdev->name, opt);\r\nset_bit(HCI_RESET, &req->hdev->flags);\r\nhci_req_add(req, HCI_OP_RESET, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic void bredr_init(struct hci_request *req)\r\n{\r\nreq->hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_PACKET_BASED;\r\nhci_req_add(req, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_LOCAL_VERSION, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_BD_ADDR, 0, NULL);\r\n}\r\nstatic void amp_init1(struct hci_request *req)\r\n{\r\nreq->hdev->flow_ctl_mode = HCI_FLOW_CTL_MODE_BLOCK_BASED;\r\nhci_req_add(req, HCI_OP_READ_LOCAL_VERSION, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_LOCAL_COMMANDS, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_LOCAL_AMP_INFO, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_DATA_BLOCK_SIZE, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_FLOW_CONTROL_MODE, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_LOCATION_DATA, 0, NULL);\r\n}\r\nstatic int amp_init2(struct hci_request *req)\r\n{\r\nif (req->hdev->commands[14] & 0x20)\r\nhci_req_add(req, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int hci_init1_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nBT_DBG("%s %ld", hdev->name, opt);\r\nif (!test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks))\r\nhci_reset_req(req, 0);\r\nswitch (hdev->dev_type) {\r\ncase HCI_PRIMARY:\r\nbredr_init(req);\r\nbreak;\r\ncase HCI_AMP:\r\namp_init1(req);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown device type %d", hdev->dev_type);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bredr_setup(struct hci_request *req)\r\n{\r\n__le16 param;\r\n__u8 flt_type;\r\nhci_req_add(req, HCI_OP_READ_BUFFER_SIZE, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_LOCAL_NAME, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_VOICE_SETTING, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_NUM_SUPPORTED_IAC, 0, NULL);\r\nhci_req_add(req, HCI_OP_READ_CURRENT_IAC_LAP, 0, NULL);\r\nflt_type = HCI_FLT_CLEAR_ALL;\r\nhci_req_add(req, HCI_OP_SET_EVENT_FLT, 1, &flt_type);\r\nparam = cpu_to_le16(0x7d00);\r\nhci_req_add(req, HCI_OP_WRITE_CA_TIMEOUT, 2, &param);\r\n}\r\nstatic void le_setup(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nhci_req_add(req, HCI_OP_LE_READ_BUFFER_SIZE, 0, NULL);\r\nhci_req_add(req, HCI_OP_LE_READ_LOCAL_FEATURES, 0, NULL);\r\nhci_req_add(req, HCI_OP_LE_READ_SUPPORTED_STATES, 0, NULL);\r\nif (!lmp_bredr_capable(hdev))\r\nhci_dev_set_flag(hdev, HCI_LE_ENABLED);\r\n}\r\nstatic void hci_setup_event_mask(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 events[8] = { 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00 };\r\nif (hdev->hci_ver < BLUETOOTH_VER_1_2)\r\nreturn;\r\nif (lmp_bredr_capable(hdev)) {\r\nevents[4] |= 0x01;\r\n} else {\r\nmemset(events, 0, sizeof(events));\r\nevents[1] |= 0x20;\r\nevents[1] |= 0x40;\r\nevents[1] |= 0x80;\r\nif (hdev->commands[0] & 0x20) {\r\nevents[0] |= 0x10;\r\nevents[2] |= 0x04;\r\nevents[3] |= 0x02;\r\n}\r\nif (hdev->commands[2] & 0x80)\r\nevents[1] |= 0x08;\r\nif (hdev->le_features[0] & HCI_LE_ENCRYPTION) {\r\nevents[0] |= 0x80;\r\nevents[5] |= 0x80;\r\n}\r\n}\r\nif (lmp_inq_rssi_capable(hdev) ||\r\ntest_bit(HCI_QUIRK_FIXUP_INQUIRY_MODE, &hdev->quirks))\r\nevents[4] |= 0x02;\r\nif (lmp_ext_feat_capable(hdev))\r\nevents[4] |= 0x04;\r\nif (lmp_esco_capable(hdev)) {\r\nevents[5] |= 0x08;\r\nevents[5] |= 0x10;\r\n}\r\nif (lmp_sniffsubr_capable(hdev))\r\nevents[5] |= 0x20;\r\nif (lmp_pause_enc_capable(hdev))\r\nevents[5] |= 0x80;\r\nif (lmp_ext_inq_capable(hdev))\r\nevents[5] |= 0x40;\r\nif (lmp_no_flush_capable(hdev))\r\nevents[7] |= 0x01;\r\nif (lmp_lsto_capable(hdev))\r\nevents[6] |= 0x80;\r\nif (lmp_ssp_capable(hdev)) {\r\nevents[6] |= 0x01;\r\nevents[6] |= 0x02;\r\nevents[6] |= 0x04;\r\nevents[6] |= 0x08;\r\nevents[6] |= 0x10;\r\nevents[6] |= 0x20;\r\nevents[7] |= 0x04;\r\nevents[7] |= 0x08;\r\nevents[7] |= 0x10;\r\n}\r\nif (lmp_le_capable(hdev))\r\nevents[7] |= 0x20;\r\nhci_req_add(req, HCI_OP_SET_EVENT_MASK, sizeof(events), events);\r\n}\r\nstatic int hci_init2_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nif (hdev->dev_type == HCI_AMP)\r\nreturn amp_init2(req);\r\nif (lmp_bredr_capable(hdev))\r\nbredr_setup(req);\r\nelse\r\nhci_dev_clear_flag(hdev, HCI_BREDR_ENABLED);\r\nif (lmp_le_capable(hdev))\r\nle_setup(req);\r\nif (hdev->hci_ver > BLUETOOTH_VER_1_1 &&\r\n!test_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks))\r\nhci_req_add(req, HCI_OP_READ_LOCAL_COMMANDS, 0, NULL);\r\nif (lmp_ssp_capable(hdev)) {\r\nhdev->max_page = 0x01;\r\nif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {\r\nu8 mode = 0x01;\r\nhci_req_add(req, HCI_OP_WRITE_SSP_MODE,\r\nsizeof(mode), &mode);\r\n} else {\r\nstruct hci_cp_write_eir cp;\r\nmemset(hdev->eir, 0, sizeof(hdev->eir));\r\nmemset(&cp, 0, sizeof(cp));\r\nhci_req_add(req, HCI_OP_WRITE_EIR, sizeof(cp), &cp);\r\n}\r\n}\r\nif (lmp_inq_rssi_capable(hdev) ||\r\ntest_bit(HCI_QUIRK_FIXUP_INQUIRY_MODE, &hdev->quirks)) {\r\nu8 mode;\r\nmode = lmp_ext_inq_capable(hdev) ? 0x02 : 0x01;\r\nhci_req_add(req, HCI_OP_WRITE_INQUIRY_MODE, 1, &mode);\r\n}\r\nif (lmp_inq_tx_pwr_capable(hdev))\r\nhci_req_add(req, HCI_OP_READ_INQ_RSP_TX_POWER, 0, NULL);\r\nif (lmp_ext_feat_capable(hdev)) {\r\nstruct hci_cp_read_local_ext_features cp;\r\ncp.page = 0x01;\r\nhci_req_add(req, HCI_OP_READ_LOCAL_EXT_FEATURES,\r\nsizeof(cp), &cp);\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_LINK_SECURITY)) {\r\nu8 enable = 1;\r\nhci_req_add(req, HCI_OP_WRITE_AUTH_ENABLE, sizeof(enable),\r\n&enable);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hci_setup_link_policy(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_def_link_policy cp;\r\nu16 link_policy = 0;\r\nif (lmp_rswitch_capable(hdev))\r\nlink_policy |= HCI_LP_RSWITCH;\r\nif (lmp_hold_capable(hdev))\r\nlink_policy |= HCI_LP_HOLD;\r\nif (lmp_sniff_capable(hdev))\r\nlink_policy |= HCI_LP_SNIFF;\r\nif (lmp_park_capable(hdev))\r\nlink_policy |= HCI_LP_PARK;\r\ncp.policy = cpu_to_le16(link_policy);\r\nhci_req_add(req, HCI_OP_WRITE_DEF_LINK_POLICY, sizeof(cp), &cp);\r\n}\r\nstatic void hci_set_le_support(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_write_le_host_supported cp;\r\nif (!lmp_bredr_capable(hdev))\r\nreturn;\r\nmemset(&cp, 0, sizeof(cp));\r\nif (hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {\r\ncp.le = 0x01;\r\ncp.simul = 0x00;\r\n}\r\nif (cp.le != lmp_host_le_capable(hdev))\r\nhci_req_add(req, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(cp),\r\n&cp);\r\n}\r\nstatic void hci_set_event_mask_page_2(struct hci_request *req)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 events[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nif (lmp_csb_master_capable(hdev)) {\r\nevents[1] |= 0x40;\r\nevents[1] |= 0x80;\r\nevents[2] |= 0x10;\r\nevents[2] |= 0x20;\r\n}\r\nif (lmp_csb_slave_capable(hdev)) {\r\nevents[2] |= 0x01;\r\nevents[2] |= 0x02;\r\nevents[2] |= 0x04;\r\nevents[2] |= 0x08;\r\n}\r\nif (lmp_ping_capable(hdev) || hdev->le_features[0] & HCI_LE_PING)\r\nevents[2] |= 0x80;\r\nhci_req_add(req, HCI_OP_SET_EVENT_MASK_PAGE_2, sizeof(events), events);\r\n}\r\nstatic int hci_init3_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nu8 p;\r\nhci_setup_event_mask(req);\r\nif (hdev->commands[6] & 0x20 &&\r\n!test_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks)) {\r\nstruct hci_cp_read_stored_link_key cp;\r\nbacpy(&cp.bdaddr, BDADDR_ANY);\r\ncp.read_all = 0x01;\r\nhci_req_add(req, HCI_OP_READ_STORED_LINK_KEY, sizeof(cp), &cp);\r\n}\r\nif (hdev->commands[5] & 0x10)\r\nhci_setup_link_policy(req);\r\nif (hdev->commands[8] & 0x01)\r\nhci_req_add(req, HCI_OP_READ_PAGE_SCAN_ACTIVITY, 0, NULL);\r\nif (hdev->commands[13] & 0x01)\r\nhci_req_add(req, HCI_OP_READ_PAGE_SCAN_TYPE, 0, NULL);\r\nif (lmp_le_capable(hdev)) {\r\nu8 events[8];\r\nmemset(events, 0, sizeof(events));\r\nif (hdev->le_features[0] & HCI_LE_ENCRYPTION)\r\nevents[0] |= 0x10;\r\nif (hdev->le_features[0] & HCI_LE_CONN_PARAM_REQ_PROC)\r\nevents[0] |= 0x20;\r\nif (hdev->le_features[0] & HCI_LE_DATA_LEN_EXT)\r\nevents[0] |= 0x40;\r\nif (hdev->le_features[0] & HCI_LE_EXT_SCAN_POLICY)\r\nevents[1] |= 0x04;\r\nif (hdev->commands[26] & 0x08)\r\nevents[0] |= 0x02;\r\nif (hdev->commands[26] & 0x10)\r\nevents[0] |= 0x01;\r\nif (hdev->commands[27] & 0x04)\r\nevents[0] |= 0x04;\r\nif (hdev->commands[27] & 0x20)\r\nevents[0] |= 0x08;\r\nif (hdev->commands[34] & 0x02)\r\nevents[0] |= 0x80;\r\nif (hdev->commands[34] & 0x04)\r\nevents[1] |= 0x01;\r\nhci_req_add(req, HCI_OP_LE_SET_EVENT_MASK, sizeof(events),\r\nevents);\r\nif (hdev->commands[25] & 0x40) {\r\nhci_req_add(req, HCI_OP_LE_READ_ADV_TX_POWER, 0, NULL);\r\n}\r\nif (hdev->commands[26] & 0x40) {\r\nhci_req_add(req, HCI_OP_LE_READ_WHITE_LIST_SIZE,\r\n0, NULL);\r\n}\r\nif (hdev->commands[26] & 0x80) {\r\nhci_req_add(req, HCI_OP_LE_CLEAR_WHITE_LIST, 0, NULL);\r\n}\r\nif (hdev->le_features[0] & HCI_LE_DATA_LEN_EXT) {\r\nhci_req_add(req, HCI_OP_LE_READ_MAX_DATA_LEN, 0, NULL);\r\nhci_req_add(req, HCI_OP_LE_READ_DEF_DATA_LEN, 0, NULL);\r\n}\r\nhci_set_le_support(req);\r\n}\r\nfor (p = 2; p < HCI_MAX_PAGES && p <= hdev->max_page; p++) {\r\nstruct hci_cp_read_local_ext_features cp;\r\ncp.page = p;\r\nhci_req_add(req, HCI_OP_READ_LOCAL_EXT_FEATURES,\r\nsizeof(cp), &cp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hci_init4_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nif (hdev->commands[6] & 0x80 &&\r\n!test_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks)) {\r\nstruct hci_cp_delete_stored_link_key cp;\r\nbacpy(&cp.bdaddr, BDADDR_ANY);\r\ncp.delete_all = 0x01;\r\nhci_req_add(req, HCI_OP_DELETE_STORED_LINK_KEY,\r\nsizeof(cp), &cp);\r\n}\r\nif (hdev->commands[22] & 0x04)\r\nhci_set_event_mask_page_2(req);\r\nif (hdev->commands[29] & 0x20)\r\nhci_req_add(req, HCI_OP_READ_LOCAL_CODECS, 0, NULL);\r\nif (hdev->commands[30] & 0x08)\r\nhci_req_add(req, HCI_OP_GET_MWS_TRANSPORT_CONFIG, 0, NULL);\r\nif (lmp_sync_train_capable(hdev))\r\nhci_req_add(req, HCI_OP_READ_SYNC_TRAIN_PARAMS, 0, NULL);\r\nif (hci_dev_test_flag(hdev, HCI_SSP_ENABLED) &&\r\nbredr_sc_enabled(hdev)) {\r\nu8 support = 0x01;\r\nhci_req_add(req, HCI_OP_WRITE_SC_SUPPORT,\r\nsizeof(support), &support);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __hci_init(struct hci_dev *hdev)\r\n{\r\nint err;\r\nerr = __hci_req_sync(hdev, hci_init1_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (hci_dev_test_flag(hdev, HCI_SETUP))\r\nhci_debugfs_create_basic(hdev);\r\nerr = __hci_req_sync(hdev, hci_init2_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (hdev->dev_type != HCI_PRIMARY)\r\nreturn 0;\r\nerr = __hci_req_sync(hdev, hci_init3_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = __hci_req_sync(hdev, hci_init4_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\r\n!hci_dev_test_flag(hdev, HCI_CONFIG))\r\nreturn 0;\r\nhci_debugfs_create_common(hdev);\r\nif (lmp_bredr_capable(hdev))\r\nhci_debugfs_create_bredr(hdev);\r\nif (lmp_le_capable(hdev))\r\nhci_debugfs_create_le(hdev);\r\nreturn 0;\r\n}\r\nstatic int hci_init0_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_dev *hdev = req->hdev;\r\nBT_DBG("%s %ld", hdev->name, opt);\r\nif (!test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks))\r\nhci_reset_req(req, 0);\r\nhci_req_add(req, HCI_OP_READ_LOCAL_VERSION, 0, NULL);\r\nif (hdev->set_bdaddr)\r\nhci_req_add(req, HCI_OP_READ_BD_ADDR, 0, NULL);\r\nreturn 0;\r\n}\r\nstatic int __hci_unconf_init(struct hci_dev *hdev)\r\n{\r\nint err;\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\r\nreturn 0;\r\nerr = __hci_req_sync(hdev, hci_init0_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (hci_dev_test_flag(hdev, HCI_SETUP))\r\nhci_debugfs_create_basic(hdev);\r\nreturn 0;\r\n}\r\nstatic int hci_scan_req(struct hci_request *req, unsigned long opt)\r\n{\r\n__u8 scan = opt;\r\nBT_DBG("%s %x", req->hdev->name, scan);\r\nhci_req_add(req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);\r\nreturn 0;\r\n}\r\nstatic int hci_auth_req(struct hci_request *req, unsigned long opt)\r\n{\r\n__u8 auth = opt;\r\nBT_DBG("%s %x", req->hdev->name, auth);\r\nhci_req_add(req, HCI_OP_WRITE_AUTH_ENABLE, 1, &auth);\r\nreturn 0;\r\n}\r\nstatic int hci_encrypt_req(struct hci_request *req, unsigned long opt)\r\n{\r\n__u8 encrypt = opt;\r\nBT_DBG("%s %x", req->hdev->name, encrypt);\r\nhci_req_add(req, HCI_OP_WRITE_ENCRYPT_MODE, 1, &encrypt);\r\nreturn 0;\r\n}\r\nstatic int hci_linkpol_req(struct hci_request *req, unsigned long opt)\r\n{\r\n__le16 policy = cpu_to_le16(opt);\r\nBT_DBG("%s %x", req->hdev->name, policy);\r\nhci_req_add(req, HCI_OP_WRITE_DEF_LINK_POLICY, 2, &policy);\r\nreturn 0;\r\n}\r\nstruct hci_dev *hci_dev_get(int index)\r\n{\r\nstruct hci_dev *hdev = NULL, *d;\r\nBT_DBG("%d", index);\r\nif (index < 0)\r\nreturn NULL;\r\nread_lock(&hci_dev_list_lock);\r\nlist_for_each_entry(d, &hci_dev_list, list) {\r\nif (d->id == index) {\r\nhdev = hci_dev_hold(d);\r\nbreak;\r\n}\r\n}\r\nread_unlock(&hci_dev_list_lock);\r\nreturn hdev;\r\n}\r\nbool hci_discovery_active(struct hci_dev *hdev)\r\n{\r\nstruct discovery_state *discov = &hdev->discovery;\r\nswitch (discov->state) {\r\ncase DISCOVERY_FINDING:\r\ncase DISCOVERY_RESOLVING:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nvoid hci_discovery_set_state(struct hci_dev *hdev, int state)\r\n{\r\nint old_state = hdev->discovery.state;\r\nBT_DBG("%s state %u -> %u", hdev->name, hdev->discovery.state, state);\r\nif (old_state == state)\r\nreturn;\r\nhdev->discovery.state = state;\r\nswitch (state) {\r\ncase DISCOVERY_STOPPED:\r\nhci_update_background_scan(hdev);\r\nif (old_state != DISCOVERY_STARTING)\r\nmgmt_discovering(hdev, 0);\r\nbreak;\r\ncase DISCOVERY_STARTING:\r\nbreak;\r\ncase DISCOVERY_FINDING:\r\nmgmt_discovering(hdev, 1);\r\nbreak;\r\ncase DISCOVERY_RESOLVING:\r\nbreak;\r\ncase DISCOVERY_STOPPING:\r\nbreak;\r\n}\r\n}\r\nvoid hci_inquiry_cache_flush(struct hci_dev *hdev)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *p, *n;\r\nlist_for_each_entry_safe(p, n, &cache->all, all) {\r\nlist_del(&p->all);\r\nkfree(p);\r\n}\r\nINIT_LIST_HEAD(&cache->unknown);\r\nINIT_LIST_HEAD(&cache->resolve);\r\n}\r\nstruct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,\r\nbdaddr_t *bdaddr)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nBT_DBG("cache %p, %pMR", cache, bdaddr);\r\nlist_for_each_entry(e, &cache->all, all) {\r\nif (!bacmp(&e->data.bdaddr, bdaddr))\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstruct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,\r\nbdaddr_t *bdaddr)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nBT_DBG("cache %p, %pMR", cache, bdaddr);\r\nlist_for_each_entry(e, &cache->unknown, list) {\r\nif (!bacmp(&e->data.bdaddr, bdaddr))\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstruct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,\r\nbdaddr_t *bdaddr,\r\nint state)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *e;\r\nBT_DBG("cache %p bdaddr %pMR state %d", cache, bdaddr, state);\r\nlist_for_each_entry(e, &cache->resolve, list) {\r\nif (!bacmp(bdaddr, BDADDR_ANY) && e->name_state == state)\r\nreturn e;\r\nif (!bacmp(&e->data.bdaddr, bdaddr))\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nvoid hci_inquiry_cache_update_resolve(struct hci_dev *hdev,\r\nstruct inquiry_entry *ie)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct list_head *pos = &cache->resolve;\r\nstruct inquiry_entry *p;\r\nlist_del(&ie->list);\r\nlist_for_each_entry(p, &cache->resolve, list) {\r\nif (p->name_state != NAME_PENDING &&\r\nabs(p->data.rssi) >= abs(ie->data.rssi))\r\nbreak;\r\npos = &p->list;\r\n}\r\nlist_add(&ie->list, pos);\r\n}\r\nu32 hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,\r\nbool name_known)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_entry *ie;\r\nu32 flags = 0;\r\nBT_DBG("cache %p, %pMR", cache, &data->bdaddr);\r\nhci_remove_remote_oob_data(hdev, &data->bdaddr, BDADDR_BREDR);\r\nif (!data->ssp_mode)\r\nflags |= MGMT_DEV_FOUND_LEGACY_PAIRING;\r\nie = hci_inquiry_cache_lookup(hdev, &data->bdaddr);\r\nif (ie) {\r\nif (!ie->data.ssp_mode)\r\nflags |= MGMT_DEV_FOUND_LEGACY_PAIRING;\r\nif (ie->name_state == NAME_NEEDED &&\r\ndata->rssi != ie->data.rssi) {\r\nie->data.rssi = data->rssi;\r\nhci_inquiry_cache_update_resolve(hdev, ie);\r\n}\r\ngoto update;\r\n}\r\nie = kzalloc(sizeof(*ie), GFP_KERNEL);\r\nif (!ie) {\r\nflags |= MGMT_DEV_FOUND_CONFIRM_NAME;\r\ngoto done;\r\n}\r\nlist_add(&ie->all, &cache->all);\r\nif (name_known) {\r\nie->name_state = NAME_KNOWN;\r\n} else {\r\nie->name_state = NAME_NOT_KNOWN;\r\nlist_add(&ie->list, &cache->unknown);\r\n}\r\nupdate:\r\nif (name_known && ie->name_state != NAME_KNOWN &&\r\nie->name_state != NAME_PENDING) {\r\nie->name_state = NAME_KNOWN;\r\nlist_del(&ie->list);\r\n}\r\nmemcpy(&ie->data, data, sizeof(*data));\r\nie->timestamp = jiffies;\r\ncache->timestamp = jiffies;\r\nif (ie->name_state == NAME_NOT_KNOWN)\r\nflags |= MGMT_DEV_FOUND_CONFIRM_NAME;\r\ndone:\r\nreturn flags;\r\n}\r\nstatic int inquiry_cache_dump(struct hci_dev *hdev, int num, __u8 *buf)\r\n{\r\nstruct discovery_state *cache = &hdev->discovery;\r\nstruct inquiry_info *info = (struct inquiry_info *) buf;\r\nstruct inquiry_entry *e;\r\nint copied = 0;\r\nlist_for_each_entry(e, &cache->all, all) {\r\nstruct inquiry_data *data = &e->data;\r\nif (copied >= num)\r\nbreak;\r\nbacpy(&info->bdaddr, &data->bdaddr);\r\ninfo->pscan_rep_mode = data->pscan_rep_mode;\r\ninfo->pscan_period_mode = data->pscan_period_mode;\r\ninfo->pscan_mode = data->pscan_mode;\r\nmemcpy(info->dev_class, data->dev_class, 3);\r\ninfo->clock_offset = data->clock_offset;\r\ninfo++;\r\ncopied++;\r\n}\r\nBT_DBG("cache %p, copied %d", cache, copied);\r\nreturn copied;\r\n}\r\nstatic int hci_inq_req(struct hci_request *req, unsigned long opt)\r\n{\r\nstruct hci_inquiry_req *ir = (struct hci_inquiry_req *) opt;\r\nstruct hci_dev *hdev = req->hdev;\r\nstruct hci_cp_inquiry cp;\r\nBT_DBG("%s", hdev->name);\r\nif (test_bit(HCI_INQUIRY, &hdev->flags))\r\nreturn 0;\r\nmemcpy(&cp.lap, &ir->lap, 3);\r\ncp.length = ir->length;\r\ncp.num_rsp = ir->num_rsp;\r\nhci_req_add(req, HCI_OP_INQUIRY, sizeof(cp), &cp);\r\nreturn 0;\r\n}\r\nint hci_inquiry(void __user *arg)\r\n{\r\n__u8 __user *ptr = arg;\r\nstruct hci_inquiry_req ir;\r\nstruct hci_dev *hdev;\r\nint err = 0, do_inquiry = 0, max_rsp;\r\nlong timeo;\r\n__u8 *buf;\r\nif (copy_from_user(&ir, ptr, sizeof(ir)))\r\nreturn -EFAULT;\r\nhdev = hci_dev_get(ir.dev_id);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nerr = -EBUSY;\r\ngoto done;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (hdev->dev_type != HCI_PRIMARY) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nhci_dev_lock(hdev);\r\nif (inquiry_cache_age(hdev) > INQUIRY_CACHE_AGE_MAX ||\r\ninquiry_cache_empty(hdev) || ir.flags & IREQ_CACHE_FLUSH) {\r\nhci_inquiry_cache_flush(hdev);\r\ndo_inquiry = 1;\r\n}\r\nhci_dev_unlock(hdev);\r\ntimeo = ir.length * msecs_to_jiffies(2000);\r\nif (do_inquiry) {\r\nerr = hci_req_sync(hdev, hci_inq_req, (unsigned long) &ir,\r\ntimeo, NULL);\r\nif (err < 0)\r\ngoto done;\r\nif (wait_on_bit(&hdev->flags, HCI_INQUIRY,\r\nTASK_INTERRUPTIBLE))\r\nreturn -EINTR;\r\n}\r\nmax_rsp = (ir.num_rsp == 0) ? 255 : ir.num_rsp;\r\nbuf = kmalloc(sizeof(struct inquiry_info) * max_rsp, GFP_KERNEL);\r\nif (!buf) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nhci_dev_lock(hdev);\r\nir.num_rsp = inquiry_cache_dump(hdev, max_rsp, buf);\r\nhci_dev_unlock(hdev);\r\nBT_DBG("num_rsp %d", ir.num_rsp);\r\nif (!copy_to_user(ptr, &ir, sizeof(ir))) {\r\nptr += sizeof(ir);\r\nif (copy_to_user(ptr, buf, sizeof(struct inquiry_info) *\r\nir.num_rsp))\r\nerr = -EFAULT;\r\n} else\r\nerr = -EFAULT;\r\nkfree(buf);\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic int hci_dev_do_open(struct hci_dev *hdev)\r\n{\r\nint ret = 0;\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nhci_req_sync_lock(hdev);\r\nif (hci_dev_test_flag(hdev, HCI_UNREGISTER)) {\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\r\n!hci_dev_test_flag(hdev, HCI_CONFIG)) {\r\nif (hci_dev_test_flag(hdev, HCI_RFKILLED)) {\r\nret = -ERFKILL;\r\ngoto done;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\r\nhdev->dev_type == HCI_PRIMARY &&\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY) &&\r\n!bacmp(&hdev->static_addr, BDADDR_ANY)) {\r\nret = -EADDRNOTAVAIL;\r\ngoto done;\r\n}\r\n}\r\nif (test_bit(HCI_UP, &hdev->flags)) {\r\nret = -EALREADY;\r\ngoto done;\r\n}\r\nif (hdev->open(hdev)) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nset_bit(HCI_RUNNING, &hdev->flags);\r\nhci_sock_dev_event(hdev, HCI_DEV_OPEN);\r\natomic_set(&hdev->cmd_cnt, 1);\r\nset_bit(HCI_INIT, &hdev->flags);\r\nif (hci_dev_test_flag(hdev, HCI_SETUP)) {\r\nhci_sock_dev_event(hdev, HCI_DEV_SETUP);\r\nif (hdev->setup)\r\nret = hdev->setup(hdev);\r\nif (test_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks) ||\r\ntest_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks))\r\nhci_dev_set_flag(hdev, HCI_UNCONFIGURED);\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\r\nret = __hci_unconf_init(hdev);\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_CONFIG)) {\r\nif (bacmp(&hdev->public_addr, BDADDR_ANY) &&\r\nhdev->set_bdaddr)\r\nret = hdev->set_bdaddr(hdev, &hdev->public_addr);\r\nelse\r\nret = -EADDRNOTAVAIL;\r\n}\r\nif (!ret) {\r\nif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\r\n!hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nret = __hci_init(hdev);\r\nif (!ret && hdev->post_init)\r\nret = hdev->post_init(hdev);\r\n}\r\n}\r\nif (test_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks) &&\r\nhci_dev_test_flag(hdev, HCI_VENDOR_DIAG) && hdev->set_diag)\r\nret = hdev->set_diag(hdev, true);\r\nclear_bit(HCI_INIT, &hdev->flags);\r\nif (!ret) {\r\nhci_dev_hold(hdev);\r\nhci_dev_set_flag(hdev, HCI_RPA_EXPIRED);\r\nset_bit(HCI_UP, &hdev->flags);\r\nhci_sock_dev_event(hdev, HCI_DEV_UP);\r\nhci_leds_update_powered(hdev, true);\r\nif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\r\n!hci_dev_test_flag(hdev, HCI_CONFIG) &&\r\n!hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\r\n!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\r\nhci_dev_test_flag(hdev, HCI_MGMT) &&\r\nhdev->dev_type == HCI_PRIMARY) {\r\nret = __hci_req_hci_power_on(hdev);\r\nmgmt_power_on(hdev, ret);\r\n}\r\n} else {\r\nflush_work(&hdev->tx_work);\r\nflush_work(&hdev->cmd_work);\r\nflush_work(&hdev->rx_work);\r\nskb_queue_purge(&hdev->cmd_q);\r\nskb_queue_purge(&hdev->rx_q);\r\nif (hdev->flush)\r\nhdev->flush(hdev);\r\nif (hdev->sent_cmd) {\r\nkfree_skb(hdev->sent_cmd);\r\nhdev->sent_cmd = NULL;\r\n}\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nhci_sock_dev_event(hdev, HCI_DEV_CLOSE);\r\nhdev->close(hdev);\r\nhdev->flags &= BIT(HCI_RAW);\r\n}\r\ndone:\r\nhci_req_sync_unlock(hdev);\r\nreturn ret;\r\n}\r\nint hci_dev_open(__u16 dev)\r\n{\r\nstruct hci_dev *hdev;\r\nint err;\r\nhdev = hci_dev_get(dev);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED) &&\r\n!hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF))\r\ncancel_delayed_work(&hdev->power_off);\r\nflush_workqueue(hdev->req_workqueue);\r\nif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\r\n!hci_dev_test_flag(hdev, HCI_MGMT))\r\nhci_dev_set_flag(hdev, HCI_BONDABLE);\r\nerr = hci_dev_do_open(hdev);\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic void hci_pend_le_actions_clear(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_params *p;\r\nlist_for_each_entry(p, &hdev->le_conn_params, list) {\r\nif (p->conn) {\r\nhci_conn_drop(p->conn);\r\nhci_conn_put(p->conn);\r\np->conn = NULL;\r\n}\r\nlist_del_init(&p->action);\r\n}\r\nBT_DBG("All LE pending actions cleared");\r\n}\r\nint hci_dev_do_close(struct hci_dev *hdev)\r\n{\r\nbool auto_off;\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nif (!hci_dev_test_flag(hdev, HCI_UNREGISTER) &&\r\n!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\r\ntest_bit(HCI_UP, &hdev->flags)) {\r\nif (hdev->shutdown)\r\nhdev->shutdown(hdev);\r\n}\r\ncancel_delayed_work(&hdev->power_off);\r\nhci_request_cancel_all(hdev);\r\nhci_req_sync_lock(hdev);\r\nif (!test_and_clear_bit(HCI_UP, &hdev->flags)) {\r\ncancel_delayed_work_sync(&hdev->cmd_timer);\r\nhci_req_sync_unlock(hdev);\r\nreturn 0;\r\n}\r\nhci_leds_update_powered(hdev, false);\r\nflush_work(&hdev->tx_work);\r\nflush_work(&hdev->rx_work);\r\nif (hdev->discov_timeout > 0) {\r\nhdev->discov_timeout = 0;\r\nhci_dev_clear_flag(hdev, HCI_DISCOVERABLE);\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\n}\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_SERVICE_CACHE))\r\ncancel_delayed_work(&hdev->service_cache);\r\nif (hci_dev_test_flag(hdev, HCI_MGMT))\r\ncancel_delayed_work_sync(&hdev->rpa_expired);\r\ndrain_workqueue(hdev->workqueue);\r\nhci_dev_lock(hdev);\r\nhci_discovery_set_state(hdev, DISCOVERY_STOPPED);\r\nauto_off = hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF);\r\nif (!auto_off && hdev->dev_type == HCI_PRIMARY &&\r\n!hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&\r\nhci_dev_test_flag(hdev, HCI_MGMT))\r\n__mgmt_power_off(hdev);\r\nhci_inquiry_cache_flush(hdev);\r\nhci_pend_le_actions_clear(hdev);\r\nhci_conn_hash_flush(hdev);\r\nhci_dev_unlock(hdev);\r\nsmp_unregister(hdev);\r\nhci_sock_dev_event(hdev, HCI_DEV_DOWN);\r\nif (hdev->flush)\r\nhdev->flush(hdev);\r\nskb_queue_purge(&hdev->cmd_q);\r\natomic_set(&hdev->cmd_cnt, 1);\r\nif (test_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks) &&\r\n!auto_off && !hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nset_bit(HCI_INIT, &hdev->flags);\r\n__hci_req_sync(hdev, hci_reset_req, 0, HCI_CMD_TIMEOUT, NULL);\r\nclear_bit(HCI_INIT, &hdev->flags);\r\n}\r\nflush_work(&hdev->cmd_work);\r\nskb_queue_purge(&hdev->rx_q);\r\nskb_queue_purge(&hdev->cmd_q);\r\nskb_queue_purge(&hdev->raw_q);\r\nif (hdev->sent_cmd) {\r\ncancel_delayed_work_sync(&hdev->cmd_timer);\r\nkfree_skb(hdev->sent_cmd);\r\nhdev->sent_cmd = NULL;\r\n}\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\nhci_sock_dev_event(hdev, HCI_DEV_CLOSE);\r\nhdev->close(hdev);\r\nhdev->flags &= BIT(HCI_RAW);\r\nhci_dev_clear_volatile_flags(hdev);\r\nhdev->amp_status = AMP_STATUS_POWERED_DOWN;\r\nmemset(hdev->eir, 0, sizeof(hdev->eir));\r\nmemset(hdev->dev_class, 0, sizeof(hdev->dev_class));\r\nbacpy(&hdev->random_addr, BDADDR_ANY);\r\nhci_req_sync_unlock(hdev);\r\nhci_dev_put(hdev);\r\nreturn 0;\r\n}\r\nint hci_dev_close(__u16 dev)\r\n{\r\nstruct hci_dev *hdev;\r\nint err;\r\nhdev = hci_dev_get(dev);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nerr = -EBUSY;\r\ngoto done;\r\n}\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF))\r\ncancel_delayed_work(&hdev->power_off);\r\nerr = hci_dev_do_close(hdev);\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic int hci_dev_do_reset(struct hci_dev *hdev)\r\n{\r\nint ret;\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nhci_req_sync_lock(hdev);\r\nskb_queue_purge(&hdev->rx_q);\r\nskb_queue_purge(&hdev->cmd_q);\r\ndrain_workqueue(hdev->workqueue);\r\nhci_dev_lock(hdev);\r\nhci_inquiry_cache_flush(hdev);\r\nhci_conn_hash_flush(hdev);\r\nhci_dev_unlock(hdev);\r\nif (hdev->flush)\r\nhdev->flush(hdev);\r\natomic_set(&hdev->cmd_cnt, 1);\r\nhdev->acl_cnt = 0; hdev->sco_cnt = 0; hdev->le_cnt = 0;\r\nret = __hci_req_sync(hdev, hci_reset_req, 0, HCI_INIT_TIMEOUT, NULL);\r\nhci_req_sync_unlock(hdev);\r\nreturn ret;\r\n}\r\nint hci_dev_reset(__u16 dev)\r\n{\r\nstruct hci_dev *hdev;\r\nint err;\r\nhdev = hci_dev_get(dev);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (!test_bit(HCI_UP, &hdev->flags)) {\r\nerr = -ENETDOWN;\r\ngoto done;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nerr = -EBUSY;\r\ngoto done;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nerr = hci_dev_do_reset(hdev);\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nint hci_dev_reset_stat(__u16 dev)\r\n{\r\nstruct hci_dev *hdev;\r\nint ret = 0;\r\nhdev = hci_dev_get(dev);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nret = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nmemset(&hdev->stat, 0, sizeof(struct hci_dev_stats));\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn ret;\r\n}\r\nstatic void hci_update_scan_state(struct hci_dev *hdev, u8 scan)\r\n{\r\nbool conn_changed, discov_changed;\r\nBT_DBG("%s scan 0x%02x", hdev->name, scan);\r\nif ((scan & SCAN_PAGE))\r\nconn_changed = !hci_dev_test_and_set_flag(hdev,\r\nHCI_CONNECTABLE);\r\nelse\r\nconn_changed = hci_dev_test_and_clear_flag(hdev,\r\nHCI_CONNECTABLE);\r\nif ((scan & SCAN_INQUIRY)) {\r\ndiscov_changed = !hci_dev_test_and_set_flag(hdev,\r\nHCI_DISCOVERABLE);\r\n} else {\r\nhci_dev_clear_flag(hdev, HCI_LIMITED_DISCOVERABLE);\r\ndiscov_changed = hci_dev_test_and_clear_flag(hdev,\r\nHCI_DISCOVERABLE);\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_MGMT))\r\nreturn;\r\nif (conn_changed || discov_changed) {\r\nhci_dev_set_flag(hdev, HCI_BREDR_ENABLED);\r\nif (hci_dev_test_flag(hdev, HCI_LE_ENABLED))\r\nhci_req_update_adv_data(hdev, hdev->cur_adv_instance);\r\nmgmt_new_settings(hdev);\r\n}\r\n}\r\nint hci_dev_cmd(unsigned int cmd, void __user *arg)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct hci_dev_req dr;\r\nint err = 0;\r\nif (copy_from_user(&dr, arg, sizeof(dr)))\r\nreturn -EFAULT;\r\nhdev = hci_dev_get(dr.dev_id);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nerr = -EBUSY;\r\ngoto done;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (hdev->dev_type != HCI_PRIMARY) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nif (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {\r\nerr = -EOPNOTSUPP;\r\ngoto done;\r\n}\r\nswitch (cmd) {\r\ncase HCISETAUTH:\r\nerr = hci_req_sync(hdev, hci_auth_req, dr.dev_opt,\r\nHCI_INIT_TIMEOUT, NULL);\r\nbreak;\r\ncase HCISETENCRYPT:\r\nif (!lmp_encrypt_capable(hdev)) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (!test_bit(HCI_AUTH, &hdev->flags)) {\r\nerr = hci_req_sync(hdev, hci_auth_req, dr.dev_opt,\r\nHCI_INIT_TIMEOUT, NULL);\r\nif (err)\r\nbreak;\r\n}\r\nerr = hci_req_sync(hdev, hci_encrypt_req, dr.dev_opt,\r\nHCI_INIT_TIMEOUT, NULL);\r\nbreak;\r\ncase HCISETSCAN:\r\nerr = hci_req_sync(hdev, hci_scan_req, dr.dev_opt,\r\nHCI_INIT_TIMEOUT, NULL);\r\nif (!err)\r\nhci_update_scan_state(hdev, dr.dev_opt);\r\nbreak;\r\ncase HCISETLINKPOL:\r\nerr = hci_req_sync(hdev, hci_linkpol_req, dr.dev_opt,\r\nHCI_INIT_TIMEOUT, NULL);\r\nbreak;\r\ncase HCISETLINKMODE:\r\nhdev->link_mode = ((__u16) dr.dev_opt) &\r\n(HCI_LM_MASTER | HCI_LM_ACCEPT);\r\nbreak;\r\ncase HCISETPTYPE:\r\nhdev->pkt_type = (__u16) dr.dev_opt;\r\nbreak;\r\ncase HCISETACLMTU:\r\nhdev->acl_mtu = *((__u16 *) &dr.dev_opt + 1);\r\nhdev->acl_pkts = *((__u16 *) &dr.dev_opt + 0);\r\nbreak;\r\ncase HCISETSCOMTU:\r\nhdev->sco_mtu = *((__u16 *) &dr.dev_opt + 1);\r\nhdev->sco_pkts = *((__u16 *) &dr.dev_opt + 0);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndone:\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nint hci_get_dev_list(void __user *arg)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct hci_dev_list_req *dl;\r\nstruct hci_dev_req *dr;\r\nint n = 0, size, err;\r\n__u16 dev_num;\r\nif (get_user(dev_num, (__u16 __user *) arg))\r\nreturn -EFAULT;\r\nif (!dev_num || dev_num > (PAGE_SIZE * 2) / sizeof(*dr))\r\nreturn -EINVAL;\r\nsize = sizeof(*dl) + dev_num * sizeof(*dr);\r\ndl = kzalloc(size, GFP_KERNEL);\r\nif (!dl)\r\nreturn -ENOMEM;\r\ndr = dl->dev_req;\r\nread_lock(&hci_dev_list_lock);\r\nlist_for_each_entry(hdev, &hci_dev_list, list) {\r\nunsigned long flags = hdev->flags;\r\nif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\r\nflags &= ~BIT(HCI_UP);\r\n(dr + n)->dev_id = hdev->id;\r\n(dr + n)->dev_opt = flags;\r\nif (++n >= dev_num)\r\nbreak;\r\n}\r\nread_unlock(&hci_dev_list_lock);\r\ndl->dev_num = n;\r\nsize = sizeof(*dl) + n * sizeof(*dr);\r\nerr = copy_to_user(arg, dl, size);\r\nkfree(dl);\r\nreturn err ? -EFAULT : 0;\r\n}\r\nint hci_get_dev_info(void __user *arg)\r\n{\r\nstruct hci_dev *hdev;\r\nstruct hci_dev_info di;\r\nunsigned long flags;\r\nint err = 0;\r\nif (copy_from_user(&di, arg, sizeof(di)))\r\nreturn -EFAULT;\r\nhdev = hci_dev_get(di.dev_id);\r\nif (!hdev)\r\nreturn -ENODEV;\r\nif (hci_dev_test_flag(hdev, HCI_AUTO_OFF))\r\nflags = hdev->flags & ~BIT(HCI_UP);\r\nelse\r\nflags = hdev->flags;\r\nstrcpy(di.name, hdev->name);\r\ndi.bdaddr = hdev->bdaddr;\r\ndi.type = (hdev->bus & 0x0f) | ((hdev->dev_type & 0x03) << 4);\r\ndi.flags = flags;\r\ndi.pkt_type = hdev->pkt_type;\r\nif (lmp_bredr_capable(hdev)) {\r\ndi.acl_mtu = hdev->acl_mtu;\r\ndi.acl_pkts = hdev->acl_pkts;\r\ndi.sco_mtu = hdev->sco_mtu;\r\ndi.sco_pkts = hdev->sco_pkts;\r\n} else {\r\ndi.acl_mtu = hdev->le_mtu;\r\ndi.acl_pkts = hdev->le_pkts;\r\ndi.sco_mtu = 0;\r\ndi.sco_pkts = 0;\r\n}\r\ndi.link_policy = hdev->link_policy;\r\ndi.link_mode = hdev->link_mode;\r\nmemcpy(&di.stat, &hdev->stat, sizeof(di.stat));\r\nmemcpy(&di.features, &hdev->features, sizeof(di.features));\r\nif (copy_to_user(arg, &di, sizeof(di)))\r\nerr = -EFAULT;\r\nhci_dev_put(hdev);\r\nreturn err;\r\n}\r\nstatic int hci_rfkill_set_block(void *data, bool blocked)\r\n{\r\nstruct hci_dev *hdev = data;\r\nBT_DBG("%p name %s blocked %d", hdev, hdev->name, blocked);\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL))\r\nreturn -EBUSY;\r\nif (blocked) {\r\nhci_dev_set_flag(hdev, HCI_RFKILLED);\r\nif (!hci_dev_test_flag(hdev, HCI_SETUP) &&\r\n!hci_dev_test_flag(hdev, HCI_CONFIG))\r\nhci_dev_do_close(hdev);\r\n} else {\r\nhci_dev_clear_flag(hdev, HCI_RFKILLED);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hci_power_on(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev, power_on);\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (test_bit(HCI_UP, &hdev->flags) &&\r\nhci_dev_test_flag(hdev, HCI_MGMT) &&\r\nhci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF)) {\r\ncancel_delayed_work(&hdev->power_off);\r\nhci_req_sync_lock(hdev);\r\nerr = __hci_req_hci_power_on(hdev);\r\nhci_req_sync_unlock(hdev);\r\nmgmt_power_on(hdev, err);\r\nreturn;\r\n}\r\nerr = hci_dev_do_open(hdev);\r\nif (err < 0) {\r\nhci_dev_lock(hdev);\r\nmgmt_set_powered_failed(hdev, err);\r\nhci_dev_unlock(hdev);\r\nreturn;\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_RFKILLED) ||\r\nhci_dev_test_flag(hdev, HCI_UNCONFIGURED) ||\r\n(hdev->dev_type == HCI_PRIMARY &&\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY) &&\r\n!bacmp(&hdev->static_addr, BDADDR_ANY))) {\r\nhci_dev_clear_flag(hdev, HCI_AUTO_OFF);\r\nhci_dev_do_close(hdev);\r\n} else if (hci_dev_test_flag(hdev, HCI_AUTO_OFF)) {\r\nqueue_delayed_work(hdev->req_workqueue, &hdev->power_off,\r\nHCI_AUTO_OFF_TIMEOUT);\r\n}\r\nif (hci_dev_test_and_clear_flag(hdev, HCI_SETUP)) {\r\nif (hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\r\nset_bit(HCI_RAW, &hdev->flags);\r\nmgmt_index_added(hdev);\r\n} else if (hci_dev_test_and_clear_flag(hdev, HCI_CONFIG)) {\r\nif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED))\r\nclear_bit(HCI_RAW, &hdev->flags);\r\nmgmt_index_added(hdev);\r\n}\r\n}\r\nstatic void hci_power_off(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev,\r\npower_off.work);\r\nBT_DBG("%s", hdev->name);\r\nhci_dev_do_close(hdev);\r\n}\r\nstatic void hci_error_reset(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev, error_reset);\r\nBT_DBG("%s", hdev->name);\r\nif (hdev->hw_error)\r\nhdev->hw_error(hdev, hdev->hw_error_code);\r\nelse\r\nBT_ERR("%s hardware error 0x%2.2x", hdev->name,\r\nhdev->hw_error_code);\r\nif (hci_dev_do_close(hdev))\r\nreturn;\r\nhci_dev_do_open(hdev);\r\n}\r\nvoid hci_uuids_clear(struct hci_dev *hdev)\r\n{\r\nstruct bt_uuid *uuid, *tmp;\r\nlist_for_each_entry_safe(uuid, tmp, &hdev->uuids, list) {\r\nlist_del(&uuid->list);\r\nkfree(uuid);\r\n}\r\n}\r\nvoid hci_link_keys_clear(struct hci_dev *hdev)\r\n{\r\nstruct link_key *key;\r\nlist_for_each_entry_rcu(key, &hdev->link_keys, list) {\r\nlist_del_rcu(&key->list);\r\nkfree_rcu(key, rcu);\r\n}\r\n}\r\nvoid hci_smp_ltks_clear(struct hci_dev *hdev)\r\n{\r\nstruct smp_ltk *k;\r\nlist_for_each_entry_rcu(k, &hdev->long_term_keys, list) {\r\nlist_del_rcu(&k->list);\r\nkfree_rcu(k, rcu);\r\n}\r\n}\r\nvoid hci_smp_irks_clear(struct hci_dev *hdev)\r\n{\r\nstruct smp_irk *k;\r\nlist_for_each_entry_rcu(k, &hdev->identity_resolving_keys, list) {\r\nlist_del_rcu(&k->list);\r\nkfree_rcu(k, rcu);\r\n}\r\n}\r\nstruct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)\r\n{\r\nstruct link_key *k;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(k, &hdev->link_keys, list) {\r\nif (bacmp(bdaddr, &k->bdaddr) == 0) {\r\nrcu_read_unlock();\r\nreturn k;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic bool hci_persistent_key(struct hci_dev *hdev, struct hci_conn *conn,\r\nu8 key_type, u8 old_key_type)\r\n{\r\nif (key_type < 0x03)\r\nreturn true;\r\nif (key_type == HCI_LK_DEBUG_COMBINATION)\r\nreturn false;\r\nif (key_type == HCI_LK_CHANGED_COMBINATION && old_key_type == 0xff)\r\nreturn false;\r\nif (!conn)\r\nreturn true;\r\nif (conn->type == LE_LINK)\r\nreturn true;\r\nif (conn->auth_type > 0x01 && conn->remote_auth > 0x01)\r\nreturn true;\r\nif (conn->auth_type == 0x02 || conn->auth_type == 0x03)\r\nreturn true;\r\nif (conn->remote_auth == 0x02 || conn->remote_auth == 0x03)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic u8 ltk_role(u8 type)\r\n{\r\nif (type == SMP_LTK)\r\nreturn HCI_ROLE_MASTER;\r\nreturn HCI_ROLE_SLAVE;\r\n}\r\nstruct smp_ltk *hci_find_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type, u8 role)\r\n{\r\nstruct smp_ltk *k;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(k, &hdev->long_term_keys, list) {\r\nif (addr_type != k->bdaddr_type || bacmp(bdaddr, &k->bdaddr))\r\ncontinue;\r\nif (smp_ltk_is_sc(k) || ltk_role(k->type) == role) {\r\nrcu_read_unlock();\r\nreturn k;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa)\r\n{\r\nstruct smp_irk *irk;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {\r\nif (!bacmp(&irk->rpa, rpa)) {\r\nrcu_read_unlock();\r\nreturn irk;\r\n}\r\n}\r\nlist_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {\r\nif (smp_irk_matches(hdev, irk->val, rpa)) {\r\nbacpy(&irk->rpa, rpa);\r\nrcu_read_unlock();\r\nreturn irk;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type)\r\n{\r\nstruct smp_irk *irk;\r\nif (addr_type == ADDR_LE_DEV_RANDOM && (bdaddr->b[5] & 0xc0) != 0xc0)\r\nreturn NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {\r\nif (addr_type == irk->addr_type &&\r\nbacmp(bdaddr, &irk->bdaddr) == 0) {\r\nrcu_read_unlock();\r\nreturn irk;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstruct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,\r\nbdaddr_t *bdaddr, u8 *val, u8 type,\r\nu8 pin_len, bool *persistent)\r\n{\r\nstruct link_key *key, *old_key;\r\nu8 old_key_type;\r\nold_key = hci_find_link_key(hdev, bdaddr);\r\nif (old_key) {\r\nold_key_type = old_key->type;\r\nkey = old_key;\r\n} else {\r\nold_key_type = conn ? conn->key_type : 0xff;\r\nkey = kzalloc(sizeof(*key), GFP_KERNEL);\r\nif (!key)\r\nreturn NULL;\r\nlist_add_rcu(&key->list, &hdev->link_keys);\r\n}\r\nBT_DBG("%s key for %pMR type %u", hdev->name, bdaddr, type);\r\nif (type == HCI_LK_CHANGED_COMBINATION &&\r\n(!conn || conn->remote_auth == 0xff) && old_key_type == 0xff) {\r\ntype = HCI_LK_COMBINATION;\r\nif (conn)\r\nconn->key_type = type;\r\n}\r\nbacpy(&key->bdaddr, bdaddr);\r\nmemcpy(key->val, val, HCI_LINK_KEY_SIZE);\r\nkey->pin_len = pin_len;\r\nif (type == HCI_LK_CHANGED_COMBINATION)\r\nkey->type = old_key_type;\r\nelse\r\nkey->type = type;\r\nif (persistent)\r\n*persistent = hci_persistent_key(hdev, conn, type,\r\nold_key_type);\r\nreturn key;\r\n}\r\nstruct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type, u8 type, u8 authenticated,\r\nu8 tk[16], u8 enc_size, __le16 ediv, __le64 rand)\r\n{\r\nstruct smp_ltk *key, *old_key;\r\nu8 role = ltk_role(type);\r\nold_key = hci_find_ltk(hdev, bdaddr, addr_type, role);\r\nif (old_key)\r\nkey = old_key;\r\nelse {\r\nkey = kzalloc(sizeof(*key), GFP_KERNEL);\r\nif (!key)\r\nreturn NULL;\r\nlist_add_rcu(&key->list, &hdev->long_term_keys);\r\n}\r\nbacpy(&key->bdaddr, bdaddr);\r\nkey->bdaddr_type = addr_type;\r\nmemcpy(key->val, tk, sizeof(key->val));\r\nkey->authenticated = authenticated;\r\nkey->ediv = ediv;\r\nkey->rand = rand;\r\nkey->enc_size = enc_size;\r\nkey->type = type;\r\nreturn key;\r\n}\r\nstruct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 addr_type, u8 val[16], bdaddr_t *rpa)\r\n{\r\nstruct smp_irk *irk;\r\nirk = hci_find_irk_by_addr(hdev, bdaddr, addr_type);\r\nif (!irk) {\r\nirk = kzalloc(sizeof(*irk), GFP_KERNEL);\r\nif (!irk)\r\nreturn NULL;\r\nbacpy(&irk->bdaddr, bdaddr);\r\nirk->addr_type = addr_type;\r\nlist_add_rcu(&irk->list, &hdev->identity_resolving_keys);\r\n}\r\nmemcpy(irk->val, val, 16);\r\nbacpy(&irk->rpa, rpa);\r\nreturn irk;\r\n}\r\nint hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)\r\n{\r\nstruct link_key *key;\r\nkey = hci_find_link_key(hdev, bdaddr);\r\nif (!key)\r\nreturn -ENOENT;\r\nBT_DBG("%s removing %pMR", hdev->name, bdaddr);\r\nlist_del_rcu(&key->list);\r\nkfree_rcu(key, rcu);\r\nreturn 0;\r\n}\r\nint hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type)\r\n{\r\nstruct smp_ltk *k;\r\nint removed = 0;\r\nlist_for_each_entry_rcu(k, &hdev->long_term_keys, list) {\r\nif (bacmp(bdaddr, &k->bdaddr) || k->bdaddr_type != bdaddr_type)\r\ncontinue;\r\nBT_DBG("%s removing %pMR", hdev->name, bdaddr);\r\nlist_del_rcu(&k->list);\r\nkfree_rcu(k, rcu);\r\nremoved++;\r\n}\r\nreturn removed ? 0 : -ENOENT;\r\n}\r\nvoid hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type)\r\n{\r\nstruct smp_irk *k;\r\nlist_for_each_entry_rcu(k, &hdev->identity_resolving_keys, list) {\r\nif (bacmp(bdaddr, &k->bdaddr) || k->addr_type != addr_type)\r\ncontinue;\r\nBT_DBG("%s removing %pMR", hdev->name, bdaddr);\r\nlist_del_rcu(&k->list);\r\nkfree_rcu(k, rcu);\r\n}\r\n}\r\nbool hci_bdaddr_is_paired(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct smp_ltk *k;\r\nstruct smp_irk *irk;\r\nu8 addr_type;\r\nif (type == BDADDR_BREDR) {\r\nif (hci_find_link_key(hdev, bdaddr))\r\nreturn true;\r\nreturn false;\r\n}\r\nif (type == BDADDR_LE_PUBLIC)\r\naddr_type = ADDR_LE_DEV_PUBLIC;\r\nelse\r\naddr_type = ADDR_LE_DEV_RANDOM;\r\nirk = hci_get_irk(hdev, bdaddr, addr_type);\r\nif (irk) {\r\nbdaddr = &irk->bdaddr;\r\naddr_type = irk->addr_type;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(k, &hdev->long_term_keys, list) {\r\nif (k->bdaddr_type == addr_type && !bacmp(bdaddr, &k->bdaddr)) {\r\nrcu_read_unlock();\r\nreturn true;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn false;\r\n}\r\nstatic void hci_cmd_timeout(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev,\r\ncmd_timer.work);\r\nif (hdev->sent_cmd) {\r\nstruct hci_command_hdr *sent = (void *) hdev->sent_cmd->data;\r\nu16 opcode = __le16_to_cpu(sent->opcode);\r\nBT_ERR("%s command 0x%4.4x tx timeout", hdev->name, opcode);\r\n} else {\r\nBT_ERR("%s command tx timeout", hdev->name);\r\n}\r\natomic_set(&hdev->cmd_cnt, 1);\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\n}\r\nstruct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,\r\nbdaddr_t *bdaddr, u8 bdaddr_type)\r\n{\r\nstruct oob_data *data;\r\nlist_for_each_entry(data, &hdev->remote_oob_data, list) {\r\nif (bacmp(bdaddr, &data->bdaddr) != 0)\r\ncontinue;\r\nif (data->bdaddr_type != bdaddr_type)\r\ncontinue;\r\nreturn data;\r\n}\r\nreturn NULL;\r\n}\r\nint hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 bdaddr_type)\r\n{\r\nstruct oob_data *data;\r\ndata = hci_find_remote_oob_data(hdev, bdaddr, bdaddr_type);\r\nif (!data)\r\nreturn -ENOENT;\r\nBT_DBG("%s removing %pMR (%u)", hdev->name, bdaddr, bdaddr_type);\r\nlist_del(&data->list);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nvoid hci_remote_oob_data_clear(struct hci_dev *hdev)\r\n{\r\nstruct oob_data *data, *n;\r\nlist_for_each_entry_safe(data, n, &hdev->remote_oob_data, list) {\r\nlist_del(&data->list);\r\nkfree(data);\r\n}\r\n}\r\nint hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 bdaddr_type, u8 *hash192, u8 *rand192,\r\nu8 *hash256, u8 *rand256)\r\n{\r\nstruct oob_data *data;\r\ndata = hci_find_remote_oob_data(hdev, bdaddr, bdaddr_type);\r\nif (!data) {\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nbacpy(&data->bdaddr, bdaddr);\r\ndata->bdaddr_type = bdaddr_type;\r\nlist_add(&data->list, &hdev->remote_oob_data);\r\n}\r\nif (hash192 && rand192) {\r\nmemcpy(data->hash192, hash192, sizeof(data->hash192));\r\nmemcpy(data->rand192, rand192, sizeof(data->rand192));\r\nif (hash256 && rand256)\r\ndata->present = 0x03;\r\n} else {\r\nmemset(data->hash192, 0, sizeof(data->hash192));\r\nmemset(data->rand192, 0, sizeof(data->rand192));\r\nif (hash256 && rand256)\r\ndata->present = 0x02;\r\nelse\r\ndata->present = 0x00;\r\n}\r\nif (hash256 && rand256) {\r\nmemcpy(data->hash256, hash256, sizeof(data->hash256));\r\nmemcpy(data->rand256, rand256, sizeof(data->rand256));\r\n} else {\r\nmemset(data->hash256, 0, sizeof(data->hash256));\r\nmemset(data->rand256, 0, sizeof(data->rand256));\r\nif (hash192 && rand192)\r\ndata->present = 0x01;\r\n}\r\nBT_DBG("%s for %pMR", hdev->name, bdaddr);\r\nreturn 0;\r\n}\r\nstruct adv_info *hci_find_adv_instance(struct hci_dev *hdev, u8 instance)\r\n{\r\nstruct adv_info *adv_instance;\r\nlist_for_each_entry(adv_instance, &hdev->adv_instances, list) {\r\nif (adv_instance->instance == instance)\r\nreturn adv_instance;\r\n}\r\nreturn NULL;\r\n}\r\nstruct adv_info *hci_get_next_instance(struct hci_dev *hdev, u8 instance)\r\n{\r\nstruct adv_info *cur_instance;\r\ncur_instance = hci_find_adv_instance(hdev, instance);\r\nif (!cur_instance)\r\nreturn NULL;\r\nif (cur_instance == list_last_entry(&hdev->adv_instances,\r\nstruct adv_info, list))\r\nreturn list_first_entry(&hdev->adv_instances,\r\nstruct adv_info, list);\r\nelse\r\nreturn list_next_entry(cur_instance, list);\r\n}\r\nint hci_remove_adv_instance(struct hci_dev *hdev, u8 instance)\r\n{\r\nstruct adv_info *adv_instance;\r\nadv_instance = hci_find_adv_instance(hdev, instance);\r\nif (!adv_instance)\r\nreturn -ENOENT;\r\nBT_DBG("%s removing %dMR", hdev->name, instance);\r\nif (hdev->cur_adv_instance == instance) {\r\nif (hdev->adv_instance_timeout) {\r\ncancel_delayed_work(&hdev->adv_instance_expire);\r\nhdev->adv_instance_timeout = 0;\r\n}\r\nhdev->cur_adv_instance = 0x00;\r\n}\r\nlist_del(&adv_instance->list);\r\nkfree(adv_instance);\r\nhdev->adv_instance_cnt--;\r\nreturn 0;\r\n}\r\nvoid hci_adv_instances_clear(struct hci_dev *hdev)\r\n{\r\nstruct adv_info *adv_instance, *n;\r\nif (hdev->adv_instance_timeout) {\r\ncancel_delayed_work(&hdev->adv_instance_expire);\r\nhdev->adv_instance_timeout = 0;\r\n}\r\nlist_for_each_entry_safe(adv_instance, n, &hdev->adv_instances, list) {\r\nlist_del(&adv_instance->list);\r\nkfree(adv_instance);\r\n}\r\nhdev->adv_instance_cnt = 0;\r\nhdev->cur_adv_instance = 0x00;\r\n}\r\nint hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,\r\nu16 adv_data_len, u8 *adv_data,\r\nu16 scan_rsp_len, u8 *scan_rsp_data,\r\nu16 timeout, u16 duration)\r\n{\r\nstruct adv_info *adv_instance;\r\nadv_instance = hci_find_adv_instance(hdev, instance);\r\nif (adv_instance) {\r\nmemset(adv_instance->adv_data, 0,\r\nsizeof(adv_instance->adv_data));\r\nmemset(adv_instance->scan_rsp_data, 0,\r\nsizeof(adv_instance->scan_rsp_data));\r\n} else {\r\nif (hdev->adv_instance_cnt >= HCI_MAX_ADV_INSTANCES ||\r\ninstance < 1 || instance > HCI_MAX_ADV_INSTANCES)\r\nreturn -EOVERFLOW;\r\nadv_instance = kzalloc(sizeof(*adv_instance), GFP_KERNEL);\r\nif (!adv_instance)\r\nreturn -ENOMEM;\r\nadv_instance->pending = true;\r\nadv_instance->instance = instance;\r\nlist_add(&adv_instance->list, &hdev->adv_instances);\r\nhdev->adv_instance_cnt++;\r\n}\r\nadv_instance->flags = flags;\r\nadv_instance->adv_data_len = adv_data_len;\r\nadv_instance->scan_rsp_len = scan_rsp_len;\r\nif (adv_data_len)\r\nmemcpy(adv_instance->adv_data, adv_data, adv_data_len);\r\nif (scan_rsp_len)\r\nmemcpy(adv_instance->scan_rsp_data,\r\nscan_rsp_data, scan_rsp_len);\r\nadv_instance->timeout = timeout;\r\nadv_instance->remaining_time = timeout;\r\nif (duration == 0)\r\nadv_instance->duration = HCI_DEFAULT_ADV_DURATION;\r\nelse\r\nadv_instance->duration = duration;\r\nBT_DBG("%s for %dMR", hdev->name, instance);\r\nreturn 0;\r\n}\r\nstruct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *bdaddr_list,\r\nbdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct bdaddr_list *b;\r\nlist_for_each_entry(b, bdaddr_list, list) {\r\nif (!bacmp(&b->bdaddr, bdaddr) && b->bdaddr_type == type)\r\nreturn b;\r\n}\r\nreturn NULL;\r\n}\r\nvoid hci_bdaddr_list_clear(struct list_head *bdaddr_list)\r\n{\r\nstruct bdaddr_list *b, *n;\r\nlist_for_each_entry_safe(b, n, bdaddr_list, list) {\r\nlist_del(&b->list);\r\nkfree(b);\r\n}\r\n}\r\nint hci_bdaddr_list_add(struct list_head *list, bdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct bdaddr_list *entry;\r\nif (!bacmp(bdaddr, BDADDR_ANY))\r\nreturn -EBADF;\r\nif (hci_bdaddr_list_lookup(list, bdaddr, type))\r\nreturn -EEXIST;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nbacpy(&entry->bdaddr, bdaddr);\r\nentry->bdaddr_type = type;\r\nlist_add(&entry->list, list);\r\nreturn 0;\r\n}\r\nint hci_bdaddr_list_del(struct list_head *list, bdaddr_t *bdaddr, u8 type)\r\n{\r\nstruct bdaddr_list *entry;\r\nif (!bacmp(bdaddr, BDADDR_ANY)) {\r\nhci_bdaddr_list_clear(list);\r\nreturn 0;\r\n}\r\nentry = hci_bdaddr_list_lookup(list, bdaddr, type);\r\nif (!entry)\r\nreturn -ENOENT;\r\nlist_del(&entry->list);\r\nkfree(entry);\r\nreturn 0;\r\n}\r\nstruct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,\r\nbdaddr_t *addr, u8 addr_type)\r\n{\r\nstruct hci_conn_params *params;\r\nlist_for_each_entry(params, &hdev->le_conn_params, list) {\r\nif (bacmp(&params->addr, addr) == 0 &&\r\nparams->addr_type == addr_type) {\r\nreturn params;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,\r\nbdaddr_t *addr, u8 addr_type)\r\n{\r\nstruct hci_conn_params *param;\r\nlist_for_each_entry(param, list, action) {\r\nif (bacmp(&param->addr, addr) == 0 &&\r\nparam->addr_type == addr_type)\r\nreturn param;\r\n}\r\nreturn NULL;\r\n}\r\nstruct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,\r\nbdaddr_t *addr, u8 addr_type)\r\n{\r\nstruct hci_conn_params *params;\r\nparams = hci_conn_params_lookup(hdev, addr, addr_type);\r\nif (params)\r\nreturn params;\r\nparams = kzalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params) {\r\nBT_ERR("Out of memory");\r\nreturn NULL;\r\n}\r\nbacpy(&params->addr, addr);\r\nparams->addr_type = addr_type;\r\nlist_add(&params->list, &hdev->le_conn_params);\r\nINIT_LIST_HEAD(&params->action);\r\nparams->conn_min_interval = hdev->le_conn_min_interval;\r\nparams->conn_max_interval = hdev->le_conn_max_interval;\r\nparams->conn_latency = hdev->le_conn_latency;\r\nparams->supervision_timeout = hdev->le_supv_timeout;\r\nparams->auto_connect = HCI_AUTO_CONN_DISABLED;\r\nBT_DBG("addr %pMR (type %u)", addr, addr_type);\r\nreturn params;\r\n}\r\nstatic void hci_conn_params_free(struct hci_conn_params *params)\r\n{\r\nif (params->conn) {\r\nhci_conn_drop(params->conn);\r\nhci_conn_put(params->conn);\r\n}\r\nlist_del(&params->action);\r\nlist_del(&params->list);\r\nkfree(params);\r\n}\r\nvoid hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type)\r\n{\r\nstruct hci_conn_params *params;\r\nparams = hci_conn_params_lookup(hdev, addr, addr_type);\r\nif (!params)\r\nreturn;\r\nhci_conn_params_free(params);\r\nhci_update_background_scan(hdev);\r\nBT_DBG("addr %pMR (type %u)", addr, addr_type);\r\n}\r\nvoid hci_conn_params_clear_disabled(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_params *params, *tmp;\r\nlist_for_each_entry_safe(params, tmp, &hdev->le_conn_params, list) {\r\nif (params->auto_connect != HCI_AUTO_CONN_DISABLED)\r\ncontinue;\r\nif (params->explicit_connect) {\r\nparams->auto_connect = HCI_AUTO_CONN_EXPLICIT;\r\ncontinue;\r\n}\r\nlist_del(&params->list);\r\nkfree(params);\r\n}\r\nBT_DBG("All LE disabled connection parameters were removed");\r\n}\r\nstatic void hci_conn_params_clear_all(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn_params *params, *tmp;\r\nlist_for_each_entry_safe(params, tmp, &hdev->le_conn_params, list)\r\nhci_conn_params_free(params);\r\nBT_DBG("All LE connection parameters were removed");\r\n}\r\nvoid hci_copy_identity_address(struct hci_dev *hdev, bdaddr_t *bdaddr,\r\nu8 *bdaddr_type)\r\n{\r\nif (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||\r\n!bacmp(&hdev->bdaddr, BDADDR_ANY) ||\r\n(!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&\r\nbacmp(&hdev->static_addr, BDADDR_ANY))) {\r\nbacpy(bdaddr, &hdev->static_addr);\r\n*bdaddr_type = ADDR_LE_DEV_RANDOM;\r\n} else {\r\nbacpy(bdaddr, &hdev->bdaddr);\r\n*bdaddr_type = ADDR_LE_DEV_PUBLIC;\r\n}\r\n}\r\nstruct hci_dev *hci_alloc_dev(void)\r\n{\r\nstruct hci_dev *hdev;\r\nhdev = kzalloc(sizeof(*hdev), GFP_KERNEL);\r\nif (!hdev)\r\nreturn NULL;\r\nhdev->pkt_type = (HCI_DM1 | HCI_DH1 | HCI_HV1);\r\nhdev->esco_type = (ESCO_HV1);\r\nhdev->link_mode = (HCI_LM_ACCEPT);\r\nhdev->num_iac = 0x01;\r\nhdev->io_capability = 0x03;\r\nhdev->manufacturer = 0xffff;\r\nhdev->inq_tx_power = HCI_TX_POWER_INVALID;\r\nhdev->adv_tx_power = HCI_TX_POWER_INVALID;\r\nhdev->adv_instance_cnt = 0;\r\nhdev->cur_adv_instance = 0x00;\r\nhdev->adv_instance_timeout = 0;\r\nhdev->sniff_max_interval = 800;\r\nhdev->sniff_min_interval = 80;\r\nhdev->le_adv_channel_map = 0x07;\r\nhdev->le_adv_min_interval = 0x0800;\r\nhdev->le_adv_max_interval = 0x0800;\r\nhdev->le_scan_interval = 0x0060;\r\nhdev->le_scan_window = 0x0030;\r\nhdev->le_conn_min_interval = 0x0028;\r\nhdev->le_conn_max_interval = 0x0038;\r\nhdev->le_conn_latency = 0x0000;\r\nhdev->le_supv_timeout = 0x002a;\r\nhdev->le_def_tx_len = 0x001b;\r\nhdev->le_def_tx_time = 0x0148;\r\nhdev->le_max_tx_len = 0x001b;\r\nhdev->le_max_tx_time = 0x0148;\r\nhdev->le_max_rx_len = 0x001b;\r\nhdev->le_max_rx_time = 0x0148;\r\nhdev->rpa_timeout = HCI_DEFAULT_RPA_TIMEOUT;\r\nhdev->discov_interleaved_timeout = DISCOV_INTERLEAVED_TIMEOUT;\r\nhdev->conn_info_min_age = DEFAULT_CONN_INFO_MIN_AGE;\r\nhdev->conn_info_max_age = DEFAULT_CONN_INFO_MAX_AGE;\r\nmutex_init(&hdev->lock);\r\nmutex_init(&hdev->req_lock);\r\nINIT_LIST_HEAD(&hdev->mgmt_pending);\r\nINIT_LIST_HEAD(&hdev->blacklist);\r\nINIT_LIST_HEAD(&hdev->whitelist);\r\nINIT_LIST_HEAD(&hdev->uuids);\r\nINIT_LIST_HEAD(&hdev->link_keys);\r\nINIT_LIST_HEAD(&hdev->long_term_keys);\r\nINIT_LIST_HEAD(&hdev->identity_resolving_keys);\r\nINIT_LIST_HEAD(&hdev->remote_oob_data);\r\nINIT_LIST_HEAD(&hdev->le_white_list);\r\nINIT_LIST_HEAD(&hdev->le_conn_params);\r\nINIT_LIST_HEAD(&hdev->pend_le_conns);\r\nINIT_LIST_HEAD(&hdev->pend_le_reports);\r\nINIT_LIST_HEAD(&hdev->conn_hash.list);\r\nINIT_LIST_HEAD(&hdev->adv_instances);\r\nINIT_WORK(&hdev->rx_work, hci_rx_work);\r\nINIT_WORK(&hdev->cmd_work, hci_cmd_work);\r\nINIT_WORK(&hdev->tx_work, hci_tx_work);\r\nINIT_WORK(&hdev->power_on, hci_power_on);\r\nINIT_WORK(&hdev->error_reset, hci_error_reset);\r\nINIT_DELAYED_WORK(&hdev->power_off, hci_power_off);\r\nskb_queue_head_init(&hdev->rx_q);\r\nskb_queue_head_init(&hdev->cmd_q);\r\nskb_queue_head_init(&hdev->raw_q);\r\ninit_waitqueue_head(&hdev->req_wait_q);\r\nINIT_DELAYED_WORK(&hdev->cmd_timer, hci_cmd_timeout);\r\nhci_request_setup(hdev);\r\nhci_init_sysfs(hdev);\r\ndiscovery_init(hdev);\r\nreturn hdev;\r\n}\r\nvoid hci_free_dev(struct hci_dev *hdev)\r\n{\r\nput_device(&hdev->dev);\r\n}\r\nint hci_register_dev(struct hci_dev *hdev)\r\n{\r\nint id, error;\r\nif (!hdev->open || !hdev->close || !hdev->send)\r\nreturn -EINVAL;\r\nswitch (hdev->dev_type) {\r\ncase HCI_PRIMARY:\r\nid = ida_simple_get(&hci_index_ida, 0, 0, GFP_KERNEL);\r\nbreak;\r\ncase HCI_AMP:\r\nid = ida_simple_get(&hci_index_ida, 1, 0, GFP_KERNEL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (id < 0)\r\nreturn id;\r\nsprintf(hdev->name, "hci%d", id);\r\nhdev->id = id;\r\nBT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);\r\nhdev->workqueue = alloc_workqueue("%s", WQ_HIGHPRI | WQ_UNBOUND |\r\nWQ_MEM_RECLAIM, 1, hdev->name);\r\nif (!hdev->workqueue) {\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nhdev->req_workqueue = alloc_workqueue("%s", WQ_HIGHPRI | WQ_UNBOUND |\r\nWQ_MEM_RECLAIM, 1, hdev->name);\r\nif (!hdev->req_workqueue) {\r\ndestroy_workqueue(hdev->workqueue);\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nif (!IS_ERR_OR_NULL(bt_debugfs))\r\nhdev->debugfs = debugfs_create_dir(hdev->name, bt_debugfs);\r\ndev_set_name(&hdev->dev, "%s", hdev->name);\r\nerror = device_add(&hdev->dev);\r\nif (error < 0)\r\ngoto err_wqueue;\r\nhci_leds_init(hdev);\r\nhdev->rfkill = rfkill_alloc(hdev->name, &hdev->dev,\r\nRFKILL_TYPE_BLUETOOTH, &hci_rfkill_ops,\r\nhdev);\r\nif (hdev->rfkill) {\r\nif (rfkill_register(hdev->rfkill) < 0) {\r\nrfkill_destroy(hdev->rfkill);\r\nhdev->rfkill = NULL;\r\n}\r\n}\r\nif (hdev->rfkill && rfkill_blocked(hdev->rfkill))\r\nhci_dev_set_flag(hdev, HCI_RFKILLED);\r\nhci_dev_set_flag(hdev, HCI_SETUP);\r\nhci_dev_set_flag(hdev, HCI_AUTO_OFF);\r\nif (hdev->dev_type == HCI_PRIMARY) {\r\nhci_dev_set_flag(hdev, HCI_BREDR_ENABLED);\r\n}\r\nwrite_lock(&hci_dev_list_lock);\r\nlist_add(&hdev->list, &hci_dev_list);\r\nwrite_unlock(&hci_dev_list_lock);\r\nif (test_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks))\r\nhci_dev_set_flag(hdev, HCI_UNCONFIGURED);\r\nhci_sock_dev_event(hdev, HCI_DEV_REG);\r\nhci_dev_hold(hdev);\r\nqueue_work(hdev->req_workqueue, &hdev->power_on);\r\nreturn id;\r\nerr_wqueue:\r\ndestroy_workqueue(hdev->workqueue);\r\ndestroy_workqueue(hdev->req_workqueue);\r\nerr:\r\nida_simple_remove(&hci_index_ida, hdev->id);\r\nreturn error;\r\n}\r\nvoid hci_unregister_dev(struct hci_dev *hdev)\r\n{\r\nint id;\r\nBT_DBG("%p name %s bus %d", hdev, hdev->name, hdev->bus);\r\nhci_dev_set_flag(hdev, HCI_UNREGISTER);\r\nid = hdev->id;\r\nwrite_lock(&hci_dev_list_lock);\r\nlist_del(&hdev->list);\r\nwrite_unlock(&hci_dev_list_lock);\r\ncancel_work_sync(&hdev->power_on);\r\nhci_dev_do_close(hdev);\r\nif (!test_bit(HCI_INIT, &hdev->flags) &&\r\n!hci_dev_test_flag(hdev, HCI_SETUP) &&\r\n!hci_dev_test_flag(hdev, HCI_CONFIG)) {\r\nhci_dev_lock(hdev);\r\nmgmt_index_removed(hdev);\r\nhci_dev_unlock(hdev);\r\n}\r\nBUG_ON(!list_empty(&hdev->mgmt_pending));\r\nhci_sock_dev_event(hdev, HCI_DEV_UNREG);\r\nif (hdev->rfkill) {\r\nrfkill_unregister(hdev->rfkill);\r\nrfkill_destroy(hdev->rfkill);\r\n}\r\ndevice_del(&hdev->dev);\r\ndebugfs_remove_recursive(hdev->debugfs);\r\nkfree_const(hdev->hw_info);\r\nkfree_const(hdev->fw_info);\r\ndestroy_workqueue(hdev->workqueue);\r\ndestroy_workqueue(hdev->req_workqueue);\r\nhci_dev_lock(hdev);\r\nhci_bdaddr_list_clear(&hdev->blacklist);\r\nhci_bdaddr_list_clear(&hdev->whitelist);\r\nhci_uuids_clear(hdev);\r\nhci_link_keys_clear(hdev);\r\nhci_smp_ltks_clear(hdev);\r\nhci_smp_irks_clear(hdev);\r\nhci_remote_oob_data_clear(hdev);\r\nhci_adv_instances_clear(hdev);\r\nhci_bdaddr_list_clear(&hdev->le_white_list);\r\nhci_conn_params_clear_all(hdev);\r\nhci_discovery_filter_clear(hdev);\r\nhci_dev_unlock(hdev);\r\nhci_dev_put(hdev);\r\nida_simple_remove(&hci_index_ida, id);\r\n}\r\nint hci_suspend_dev(struct hci_dev *hdev)\r\n{\r\nhci_sock_dev_event(hdev, HCI_DEV_SUSPEND);\r\nreturn 0;\r\n}\r\nint hci_resume_dev(struct hci_dev *hdev)\r\n{\r\nhci_sock_dev_event(hdev, HCI_DEV_RESUME);\r\nreturn 0;\r\n}\r\nint hci_reset_dev(struct hci_dev *hdev)\r\n{\r\nconst u8 hw_err[] = { HCI_EV_HARDWARE_ERROR, 0x01, 0x00 };\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(3, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhci_skb_pkt_type(skb) = HCI_EVENT_PKT;\r\nmemcpy(skb_put(skb, 3), hw_err, 3);\r\nreturn hci_recv_frame(hdev, skb);\r\n}\r\nint hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nif (!hdev || (!test_bit(HCI_UP, &hdev->flags)\r\n&& !test_bit(HCI_INIT, &hdev->flags))) {\r\nkfree_skb(skb);\r\nreturn -ENXIO;\r\n}\r\nif (hci_skb_pkt_type(skb) != HCI_EVENT_PKT &&\r\nhci_skb_pkt_type(skb) != HCI_ACLDATA_PKT &&\r\nhci_skb_pkt_type(skb) != HCI_SCODATA_PKT) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nbt_cb(skb)->incoming = 1;\r\n__net_timestamp(skb);\r\nskb_queue_tail(&hdev->rx_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->rx_work);\r\nreturn 0;\r\n}\r\nint hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nhci_skb_pkt_type(skb) = HCI_DIAG_PKT;\r\n__net_timestamp(skb);\r\nskb_queue_tail(&hdev->rx_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->rx_work);\r\nreturn 0;\r\n}\r\nvoid hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...)\r\n{\r\nva_list vargs;\r\nva_start(vargs, fmt);\r\nkfree_const(hdev->hw_info);\r\nhdev->hw_info = kvasprintf_const(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\n}\r\nvoid hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...)\r\n{\r\nva_list vargs;\r\nva_start(vargs, fmt);\r\nkfree_const(hdev->fw_info);\r\nhdev->fw_info = kvasprintf_const(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\n}\r\nint hci_register_cb(struct hci_cb *cb)\r\n{\r\nBT_DBG("%p name %s", cb, cb->name);\r\nmutex_lock(&hci_cb_list_lock);\r\nlist_add_tail(&cb->list, &hci_cb_list);\r\nmutex_unlock(&hci_cb_list_lock);\r\nreturn 0;\r\n}\r\nint hci_unregister_cb(struct hci_cb *cb)\r\n{\r\nBT_DBG("%p name %s", cb, cb->name);\r\nmutex_lock(&hci_cb_list_lock);\r\nlist_del(&cb->list);\r\nmutex_unlock(&hci_cb_list_lock);\r\nreturn 0;\r\n}\r\nstatic void hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nint err;\r\nBT_DBG("%s type %d len %d", hdev->name, hci_skb_pkt_type(skb),\r\nskb->len);\r\n__net_timestamp(skb);\r\nhci_send_to_monitor(hdev, skb);\r\nif (atomic_read(&hdev->promisc)) {\r\nhci_send_to_sock(hdev, skb);\r\n}\r\nskb_orphan(skb);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nerr = hdev->send(hdev, skb);\r\nif (err < 0) {\r\nBT_ERR("%s sending frame failed (%d)", hdev->name, err);\r\nkfree_skb(skb);\r\n}\r\n}\r\nint hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen,\r\nconst void *param)\r\n{\r\nstruct sk_buff *skb;\r\nBT_DBG("%s opcode 0x%4.4x plen %d", hdev->name, opcode, plen);\r\nskb = hci_prepare_cmd(hdev, opcode, plen, param);\r\nif (!skb) {\r\nBT_ERR("%s no memory for command", hdev->name);\r\nreturn -ENOMEM;\r\n}\r\nbt_cb(skb)->hci.req_flags |= HCI_REQ_START;\r\nskb_queue_tail(&hdev->cmd_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\nreturn 0;\r\n}\r\nvoid *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode)\r\n{\r\nstruct hci_command_hdr *hdr;\r\nif (!hdev->sent_cmd)\r\nreturn NULL;\r\nhdr = (void *) hdev->sent_cmd->data;\r\nif (hdr->opcode != cpu_to_le16(opcode))\r\nreturn NULL;\r\nBT_DBG("%s opcode 0x%4.4x", hdev->name, opcode);\r\nreturn hdev->sent_cmd->data + HCI_COMMAND_HDR_SIZE;\r\n}\r\nstruct sk_buff *hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,\r\nconst void *param, u32 timeout)\r\n{\r\nstruct sk_buff *skb;\r\nif (!test_bit(HCI_UP, &hdev->flags))\r\nreturn ERR_PTR(-ENETDOWN);\r\nbt_dev_dbg(hdev, "opcode 0x%4.4x plen %d", opcode, plen);\r\nhci_req_sync_lock(hdev);\r\nskb = __hci_cmd_sync(hdev, opcode, plen, param, timeout);\r\nhci_req_sync_unlock(hdev);\r\nreturn skb;\r\n}\r\nstatic void hci_add_acl_hdr(struct sk_buff *skb, __u16 handle, __u16 flags)\r\n{\r\nstruct hci_acl_hdr *hdr;\r\nint len = skb->len;\r\nskb_push(skb, HCI_ACL_HDR_SIZE);\r\nskb_reset_transport_header(skb);\r\nhdr = (struct hci_acl_hdr *)skb_transport_header(skb);\r\nhdr->handle = cpu_to_le16(hci_handle_pack(handle, flags));\r\nhdr->dlen = cpu_to_le16(len);\r\n}\r\nstatic void hci_queue_acl(struct hci_chan *chan, struct sk_buff_head *queue,\r\nstruct sk_buff *skb, __u16 flags)\r\n{\r\nstruct hci_conn *conn = chan->conn;\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct sk_buff *list;\r\nskb->len = skb_headlen(skb);\r\nskb->data_len = 0;\r\nhci_skb_pkt_type(skb) = HCI_ACLDATA_PKT;\r\nswitch (hdev->dev_type) {\r\ncase HCI_PRIMARY:\r\nhci_add_acl_hdr(skb, conn->handle, flags);\r\nbreak;\r\ncase HCI_AMP:\r\nhci_add_acl_hdr(skb, chan->handle, flags);\r\nbreak;\r\ndefault:\r\nBT_ERR("%s unknown dev_type %d", hdev->name, hdev->dev_type);\r\nreturn;\r\n}\r\nlist = skb_shinfo(skb)->frag_list;\r\nif (!list) {\r\nBT_DBG("%s nonfrag skb %p len %d", hdev->name, skb, skb->len);\r\nskb_queue_tail(queue, skb);\r\n} else {\r\nBT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);\r\nskb_shinfo(skb)->frag_list = NULL;\r\nspin_lock_bh(&queue->lock);\r\n__skb_queue_tail(queue, skb);\r\nflags &= ~ACL_START;\r\nflags |= ACL_CONT;\r\ndo {\r\nskb = list; list = list->next;\r\nhci_skb_pkt_type(skb) = HCI_ACLDATA_PKT;\r\nhci_add_acl_hdr(skb, conn->handle, flags);\r\nBT_DBG("%s frag %p len %d", hdev->name, skb, skb->len);\r\n__skb_queue_tail(queue, skb);\r\n} while (list);\r\nspin_unlock_bh(&queue->lock);\r\n}\r\n}\r\nvoid hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags)\r\n{\r\nstruct hci_dev *hdev = chan->conn->hdev;\r\nBT_DBG("%s chan %p flags 0x%4.4x", hdev->name, chan, flags);\r\nhci_queue_acl(chan, &chan->data_q, skb, flags);\r\nqueue_work(hdev->workqueue, &hdev->tx_work);\r\n}\r\nvoid hci_send_sco(struct hci_conn *conn, struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = conn->hdev;\r\nstruct hci_sco_hdr hdr;\r\nBT_DBG("%s len %d", hdev->name, skb->len);\r\nhdr.handle = cpu_to_le16(conn->handle);\r\nhdr.dlen = skb->len;\r\nskb_push(skb, HCI_SCO_HDR_SIZE);\r\nskb_reset_transport_header(skb);\r\nmemcpy(skb_transport_header(skb), &hdr, HCI_SCO_HDR_SIZE);\r\nhci_skb_pkt_type(skb) = HCI_SCODATA_PKT;\r\nskb_queue_tail(&conn->data_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->tx_work);\r\n}\r\nstatic struct hci_conn *hci_low_sent(struct hci_dev *hdev, __u8 type,\r\nint *quote)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *conn = NULL, *c;\r\nunsigned int num = 0, min = ~0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(c, &h->list, list) {\r\nif (c->type != type || skb_queue_empty(&c->data_q))\r\ncontinue;\r\nif (c->state != BT_CONNECTED && c->state != BT_CONFIG)\r\ncontinue;\r\nnum++;\r\nif (c->sent < min) {\r\nmin = c->sent;\r\nconn = c;\r\n}\r\nif (hci_conn_num(hdev, type) == num)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (conn) {\r\nint cnt, q;\r\nswitch (conn->type) {\r\ncase ACL_LINK:\r\ncnt = hdev->acl_cnt;\r\nbreak;\r\ncase SCO_LINK:\r\ncase ESCO_LINK:\r\ncnt = hdev->sco_cnt;\r\nbreak;\r\ncase LE_LINK:\r\ncnt = hdev->le_mtu ? hdev->le_cnt : hdev->acl_cnt;\r\nbreak;\r\ndefault:\r\ncnt = 0;\r\nBT_ERR("Unknown link type");\r\n}\r\nq = cnt / num;\r\n*quote = q ? q : 1;\r\n} else\r\n*quote = 0;\r\nBT_DBG("conn %p quote %d", conn, *quote);\r\nreturn conn;\r\n}\r\nstatic void hci_link_tx_to(struct hci_dev *hdev, __u8 type)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *c;\r\nBT_ERR("%s link tx timeout", hdev->name);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(c, &h->list, list) {\r\nif (c->type == type && c->sent) {\r\nBT_ERR("%s killing stalled connection %pMR",\r\nhdev->name, &c->dst);\r\nhci_disconnect(c, HCI_ERROR_REMOTE_USER_TERM);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic struct hci_chan *hci_chan_sent(struct hci_dev *hdev, __u8 type,\r\nint *quote)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_chan *chan = NULL;\r\nunsigned int num = 0, min = ~0, cur_prio = 0;\r\nstruct hci_conn *conn;\r\nint cnt, q, conn_num = 0;\r\nBT_DBG("%s", hdev->name);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(conn, &h->list, list) {\r\nstruct hci_chan *tmp;\r\nif (conn->type != type)\r\ncontinue;\r\nif (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)\r\ncontinue;\r\nconn_num++;\r\nlist_for_each_entry_rcu(tmp, &conn->chan_list, list) {\r\nstruct sk_buff *skb;\r\nif (skb_queue_empty(&tmp->data_q))\r\ncontinue;\r\nskb = skb_peek(&tmp->data_q);\r\nif (skb->priority < cur_prio)\r\ncontinue;\r\nif (skb->priority > cur_prio) {\r\nnum = 0;\r\nmin = ~0;\r\ncur_prio = skb->priority;\r\n}\r\nnum++;\r\nif (conn->sent < min) {\r\nmin = conn->sent;\r\nchan = tmp;\r\n}\r\n}\r\nif (hci_conn_num(hdev, type) == conn_num)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!chan)\r\nreturn NULL;\r\nswitch (chan->conn->type) {\r\ncase ACL_LINK:\r\ncnt = hdev->acl_cnt;\r\nbreak;\r\ncase AMP_LINK:\r\ncnt = hdev->block_cnt;\r\nbreak;\r\ncase SCO_LINK:\r\ncase ESCO_LINK:\r\ncnt = hdev->sco_cnt;\r\nbreak;\r\ncase LE_LINK:\r\ncnt = hdev->le_mtu ? hdev->le_cnt : hdev->acl_cnt;\r\nbreak;\r\ndefault:\r\ncnt = 0;\r\nBT_ERR("Unknown link type");\r\n}\r\nq = cnt / num;\r\n*quote = q ? q : 1;\r\nBT_DBG("chan %p quote %d", chan, *quote);\r\nreturn chan;\r\n}\r\nstatic void hci_prio_recalculate(struct hci_dev *hdev, __u8 type)\r\n{\r\nstruct hci_conn_hash *h = &hdev->conn_hash;\r\nstruct hci_conn *conn;\r\nint num = 0;\r\nBT_DBG("%s", hdev->name);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(conn, &h->list, list) {\r\nstruct hci_chan *chan;\r\nif (conn->type != type)\r\ncontinue;\r\nif (conn->state != BT_CONNECTED && conn->state != BT_CONFIG)\r\ncontinue;\r\nnum++;\r\nlist_for_each_entry_rcu(chan, &conn->chan_list, list) {\r\nstruct sk_buff *skb;\r\nif (chan->sent) {\r\nchan->sent = 0;\r\ncontinue;\r\n}\r\nif (skb_queue_empty(&chan->data_q))\r\ncontinue;\r\nskb = skb_peek(&chan->data_q);\r\nif (skb->priority >= HCI_PRIO_MAX - 1)\r\ncontinue;\r\nskb->priority = HCI_PRIO_MAX - 1;\r\nBT_DBG("chan %p skb %p promoted to %d", chan, skb,\r\nskb->priority);\r\n}\r\nif (hci_conn_num(hdev, type) == num)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic inline int __get_blocks(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nreturn DIV_ROUND_UP(skb->len - HCI_ACL_HDR_SIZE, hdev->block_len);\r\n}\r\nstatic void __check_timeout(struct hci_dev *hdev, unsigned int cnt)\r\n{\r\nif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nif (!cnt && time_after(jiffies, hdev->acl_last_tx +\r\nHCI_ACL_TX_TIMEOUT))\r\nhci_link_tx_to(hdev, ACL_LINK);\r\n}\r\n}\r\nstatic void hci_sched_acl_pkt(struct hci_dev *hdev)\r\n{\r\nunsigned int cnt = hdev->acl_cnt;\r\nstruct hci_chan *chan;\r\nstruct sk_buff *skb;\r\nint quote;\r\n__check_timeout(hdev, cnt);\r\nwhile (hdev->acl_cnt &&\r\n(chan = hci_chan_sent(hdev, ACL_LINK, &quote))) {\r\nu32 priority = (skb_peek(&chan->data_q))->priority;\r\nwhile (quote-- && (skb = skb_peek(&chan->data_q))) {\r\nBT_DBG("chan %p skb %p len %d priority %u", chan, skb,\r\nskb->len, skb->priority);\r\nif (skb->priority < priority)\r\nbreak;\r\nskb = skb_dequeue(&chan->data_q);\r\nhci_conn_enter_active_mode(chan->conn,\r\nbt_cb(skb)->force_active);\r\nhci_send_frame(hdev, skb);\r\nhdev->acl_last_tx = jiffies;\r\nhdev->acl_cnt--;\r\nchan->sent++;\r\nchan->conn->sent++;\r\n}\r\n}\r\nif (cnt != hdev->acl_cnt)\r\nhci_prio_recalculate(hdev, ACL_LINK);\r\n}\r\nstatic void hci_sched_acl_blk(struct hci_dev *hdev)\r\n{\r\nunsigned int cnt = hdev->block_cnt;\r\nstruct hci_chan *chan;\r\nstruct sk_buff *skb;\r\nint quote;\r\nu8 type;\r\n__check_timeout(hdev, cnt);\r\nBT_DBG("%s", hdev->name);\r\nif (hdev->dev_type == HCI_AMP)\r\ntype = AMP_LINK;\r\nelse\r\ntype = ACL_LINK;\r\nwhile (hdev->block_cnt > 0 &&\r\n(chan = hci_chan_sent(hdev, type, &quote))) {\r\nu32 priority = (skb_peek(&chan->data_q))->priority;\r\nwhile (quote > 0 && (skb = skb_peek(&chan->data_q))) {\r\nint blocks;\r\nBT_DBG("chan %p skb %p len %d priority %u", chan, skb,\r\nskb->len, skb->priority);\r\nif (skb->priority < priority)\r\nbreak;\r\nskb = skb_dequeue(&chan->data_q);\r\nblocks = __get_blocks(hdev, skb);\r\nif (blocks > hdev->block_cnt)\r\nreturn;\r\nhci_conn_enter_active_mode(chan->conn,\r\nbt_cb(skb)->force_active);\r\nhci_send_frame(hdev, skb);\r\nhdev->acl_last_tx = jiffies;\r\nhdev->block_cnt -= blocks;\r\nquote -= blocks;\r\nchan->sent += blocks;\r\nchan->conn->sent += blocks;\r\n}\r\n}\r\nif (cnt != hdev->block_cnt)\r\nhci_prio_recalculate(hdev, type);\r\n}\r\nstatic void hci_sched_acl(struct hci_dev *hdev)\r\n{\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_conn_num(hdev, ACL_LINK) && hdev->dev_type == HCI_PRIMARY)\r\nreturn;\r\nif (!hci_conn_num(hdev, AMP_LINK) && hdev->dev_type == HCI_AMP)\r\nreturn;\r\nswitch (hdev->flow_ctl_mode) {\r\ncase HCI_FLOW_CTL_MODE_PACKET_BASED:\r\nhci_sched_acl_pkt(hdev);\r\nbreak;\r\ncase HCI_FLOW_CTL_MODE_BLOCK_BASED:\r\nhci_sched_acl_blk(hdev);\r\nbreak;\r\n}\r\n}\r\nstatic void hci_sched_sco(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn *conn;\r\nstruct sk_buff *skb;\r\nint quote;\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_conn_num(hdev, SCO_LINK))\r\nreturn;\r\nwhile (hdev->sco_cnt && (conn = hci_low_sent(hdev, SCO_LINK, &quote))) {\r\nwhile (quote-- && (skb = skb_dequeue(&conn->data_q))) {\r\nBT_DBG("skb %p len %d", skb, skb->len);\r\nhci_send_frame(hdev, skb);\r\nconn->sent++;\r\nif (conn->sent == ~0)\r\nconn->sent = 0;\r\n}\r\n}\r\n}\r\nstatic void hci_sched_esco(struct hci_dev *hdev)\r\n{\r\nstruct hci_conn *conn;\r\nstruct sk_buff *skb;\r\nint quote;\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_conn_num(hdev, ESCO_LINK))\r\nreturn;\r\nwhile (hdev->sco_cnt && (conn = hci_low_sent(hdev, ESCO_LINK,\r\n&quote))) {\r\nwhile (quote-- && (skb = skb_dequeue(&conn->data_q))) {\r\nBT_DBG("skb %p len %d", skb, skb->len);\r\nhci_send_frame(hdev, skb);\r\nconn->sent++;\r\nif (conn->sent == ~0)\r\nconn->sent = 0;\r\n}\r\n}\r\n}\r\nstatic void hci_sched_le(struct hci_dev *hdev)\r\n{\r\nstruct hci_chan *chan;\r\nstruct sk_buff *skb;\r\nint quote, cnt, tmp;\r\nBT_DBG("%s", hdev->name);\r\nif (!hci_conn_num(hdev, LE_LINK))\r\nreturn;\r\nif (!hci_dev_test_flag(hdev, HCI_UNCONFIGURED)) {\r\nif (!hdev->le_cnt && hdev->le_pkts &&\r\ntime_after(jiffies, hdev->le_last_tx + HZ * 45))\r\nhci_link_tx_to(hdev, LE_LINK);\r\n}\r\ncnt = hdev->le_pkts ? hdev->le_cnt : hdev->acl_cnt;\r\ntmp = cnt;\r\nwhile (cnt && (chan = hci_chan_sent(hdev, LE_LINK, &quote))) {\r\nu32 priority = (skb_peek(&chan->data_q))->priority;\r\nwhile (quote-- && (skb = skb_peek(&chan->data_q))) {\r\nBT_DBG("chan %p skb %p len %d priority %u", chan, skb,\r\nskb->len, skb->priority);\r\nif (skb->priority < priority)\r\nbreak;\r\nskb = skb_dequeue(&chan->data_q);\r\nhci_send_frame(hdev, skb);\r\nhdev->le_last_tx = jiffies;\r\ncnt--;\r\nchan->sent++;\r\nchan->conn->sent++;\r\n}\r\n}\r\nif (hdev->le_pkts)\r\nhdev->le_cnt = cnt;\r\nelse\r\nhdev->acl_cnt = cnt;\r\nif (cnt != tmp)\r\nhci_prio_recalculate(hdev, LE_LINK);\r\n}\r\nstatic void hci_tx_work(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev, tx_work);\r\nstruct sk_buff *skb;\r\nBT_DBG("%s acl %d sco %d le %d", hdev->name, hdev->acl_cnt,\r\nhdev->sco_cnt, hdev->le_cnt);\r\nif (!hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nhci_sched_acl(hdev);\r\nhci_sched_sco(hdev);\r\nhci_sched_esco(hdev);\r\nhci_sched_le(hdev);\r\n}\r\nwhile ((skb = skb_dequeue(&hdev->raw_q)))\r\nhci_send_frame(hdev, skb);\r\n}\r\nstatic void hci_acldata_packet(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_acl_hdr *hdr = (void *) skb->data;\r\nstruct hci_conn *conn;\r\n__u16 handle, flags;\r\nskb_pull(skb, HCI_ACL_HDR_SIZE);\r\nhandle = __le16_to_cpu(hdr->handle);\r\nflags = hci_flags(handle);\r\nhandle = hci_handle(handle);\r\nBT_DBG("%s len %d handle 0x%4.4x flags 0x%4.4x", hdev->name, skb->len,\r\nhandle, flags);\r\nhdev->stat.acl_rx++;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\nhci_dev_unlock(hdev);\r\nif (conn) {\r\nhci_conn_enter_active_mode(conn, BT_POWER_FORCE_ACTIVE_OFF);\r\nl2cap_recv_acldata(conn, skb, flags);\r\nreturn;\r\n} else {\r\nBT_ERR("%s ACL packet for unknown connection handle %d",\r\nhdev->name, handle);\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic void hci_scodata_packet(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_sco_hdr *hdr = (void *) skb->data;\r\nstruct hci_conn *conn;\r\n__u16 handle;\r\nskb_pull(skb, HCI_SCO_HDR_SIZE);\r\nhandle = __le16_to_cpu(hdr->handle);\r\nBT_DBG("%s len %d handle 0x%4.4x", hdev->name, skb->len, handle);\r\nhdev->stat.sco_rx++;\r\nhci_dev_lock(hdev);\r\nconn = hci_conn_hash_lookup_handle(hdev, handle);\r\nhci_dev_unlock(hdev);\r\nif (conn) {\r\nsco_recv_scodata(conn, skb);\r\nreturn;\r\n} else {\r\nBT_ERR("%s SCO packet for unknown connection handle %d",\r\nhdev->name, handle);\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic bool hci_req_is_complete(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nskb = skb_peek(&hdev->cmd_q);\r\nif (!skb)\r\nreturn true;\r\nreturn (bt_cb(skb)->hci.req_flags & HCI_REQ_START);\r\n}\r\nstatic void hci_resend_last(struct hci_dev *hdev)\r\n{\r\nstruct hci_command_hdr *sent;\r\nstruct sk_buff *skb;\r\nu16 opcode;\r\nif (!hdev->sent_cmd)\r\nreturn;\r\nsent = (void *) hdev->sent_cmd->data;\r\nopcode = __le16_to_cpu(sent->opcode);\r\nif (opcode == HCI_OP_RESET)\r\nreturn;\r\nskb = skb_clone(hdev->sent_cmd, GFP_KERNEL);\r\nif (!skb)\r\nreturn;\r\nskb_queue_head(&hdev->cmd_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\n}\r\nvoid hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status,\r\nhci_req_complete_t *req_complete,\r\nhci_req_complete_skb_t *req_complete_skb)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nBT_DBG("opcode 0x%04x status 0x%02x", opcode, status);\r\nif (!hci_sent_cmd_data(hdev, opcode)) {\r\nif (test_bit(HCI_INIT, &hdev->flags) && opcode == HCI_OP_RESET)\r\nhci_resend_last(hdev);\r\nreturn;\r\n}\r\nif (!status && !hci_req_is_complete(hdev))\r\nreturn;\r\nif (bt_cb(hdev->sent_cmd)->hci.req_flags & HCI_REQ_SKB) {\r\n*req_complete_skb = bt_cb(hdev->sent_cmd)->hci.req_complete_skb;\r\nreturn;\r\n}\r\nif (bt_cb(hdev->sent_cmd)->hci.req_complete) {\r\n*req_complete = bt_cb(hdev->sent_cmd)->hci.req_complete;\r\nreturn;\r\n}\r\nspin_lock_irqsave(&hdev->cmd_q.lock, flags);\r\nwhile ((skb = __skb_dequeue(&hdev->cmd_q))) {\r\nif (bt_cb(skb)->hci.req_flags & HCI_REQ_START) {\r\n__skb_queue_head(&hdev->cmd_q, skb);\r\nbreak;\r\n}\r\nif (bt_cb(skb)->hci.req_flags & HCI_REQ_SKB)\r\n*req_complete_skb = bt_cb(skb)->hci.req_complete_skb;\r\nelse\r\n*req_complete = bt_cb(skb)->hci.req_complete;\r\nkfree_skb(skb);\r\n}\r\nspin_unlock_irqrestore(&hdev->cmd_q.lock, flags);\r\n}\r\nstatic void hci_rx_work(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev, rx_work);\r\nstruct sk_buff *skb;\r\nBT_DBG("%s", hdev->name);\r\nwhile ((skb = skb_dequeue(&hdev->rx_q))) {\r\nhci_send_to_monitor(hdev, skb);\r\nif (atomic_read(&hdev->promisc)) {\r\nhci_send_to_sock(hdev, skb);\r\n}\r\nif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nif (test_bit(HCI_INIT, &hdev->flags)) {\r\nswitch (hci_skb_pkt_type(skb)) {\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_SCODATA_PKT:\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\n}\r\nswitch (hci_skb_pkt_type(skb)) {\r\ncase HCI_EVENT_PKT:\r\nBT_DBG("%s Event packet", hdev->name);\r\nhci_event_packet(hdev, skb);\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nBT_DBG("%s ACL data packet", hdev->name);\r\nhci_acldata_packet(hdev, skb);\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nBT_DBG("%s SCO data packet", hdev->name);\r\nhci_scodata_packet(hdev, skb);\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void hci_cmd_work(struct work_struct *work)\r\n{\r\nstruct hci_dev *hdev = container_of(work, struct hci_dev, cmd_work);\r\nstruct sk_buff *skb;\r\nBT_DBG("%s cmd_cnt %d cmd queued %d", hdev->name,\r\natomic_read(&hdev->cmd_cnt), skb_queue_len(&hdev->cmd_q));\r\nif (atomic_read(&hdev->cmd_cnt)) {\r\nskb = skb_dequeue(&hdev->cmd_q);\r\nif (!skb)\r\nreturn;\r\nkfree_skb(hdev->sent_cmd);\r\nhdev->sent_cmd = skb_clone(skb, GFP_KERNEL);\r\nif (hdev->sent_cmd) {\r\natomic_dec(&hdev->cmd_cnt);\r\nhci_send_frame(hdev, skb);\r\nif (test_bit(HCI_RESET, &hdev->flags))\r\ncancel_delayed_work(&hdev->cmd_timer);\r\nelse\r\nschedule_delayed_work(&hdev->cmd_timer,\r\nHCI_CMD_TIMEOUT);\r\n} else {\r\nskb_queue_head(&hdev->cmd_q, skb);\r\nqueue_work(hdev->workqueue, &hdev->cmd_work);\r\n}\r\n}\r\n}
