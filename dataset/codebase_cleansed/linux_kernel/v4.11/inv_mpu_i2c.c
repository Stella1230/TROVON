static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct iio_dev *indio_dev = i2c_mux_priv(muxc);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nint ret = 0;\r\nmutex_lock(&indio_dev->mlock);\r\nif (!st->powerup_count) {\r\nret = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);\r\nif (ret)\r\ngoto write_error;\r\nusleep_range(INV_MPU6050_REG_UP_TIME_MIN,\r\nINV_MPU6050_REG_UP_TIME_MAX);\r\n}\r\nif (!ret) {\r\nst->powerup_count++;\r\nret = regmap_write(st->map, st->reg->int_pin_cfg,\r\nINV_MPU6050_INT_PIN_CFG |\r\nINV_MPU6050_BIT_BYPASS_EN);\r\n}\r\nwrite_error:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct iio_dev *indio_dev = i2c_mux_priv(muxc);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nmutex_lock(&indio_dev->mlock);\r\nregmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);\r\nst->powerup_count--;\r\nif (!st->powerup_count)\r\nregmap_write(st->map, st->reg->pwr_mgmt_1,\r\nINV_MPU6050_BIT_SLEEP);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn 0;\r\n}\r\nstatic const char *inv_mpu_match_acpi_device(struct device *dev, int *chip_id)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\n*chip_id = (int)id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic int inv_mpu_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct inv_mpu6050_state *st;\r\nint result, chip_type;\r\nstruct regmap *regmap;\r\nconst char *name;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EOPNOTSUPP;\r\nif (id) {\r\nchip_type = (int)id->driver_data;\r\nname = id->name;\r\n} else if (ACPI_HANDLE(&client->dev)) {\r\nname = inv_mpu_match_acpi_device(&client->dev, &chip_type);\r\nif (!name)\r\nreturn -ENODEV;\r\n} else {\r\nreturn -ENOSYS;\r\n}\r\nregmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "Failed to register i2c regmap %d\n",\r\n(int)PTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nresult = inv_mpu_core_probe(regmap, client->irq, name,\r\nNULL, chip_type);\r\nif (result < 0)\r\nreturn result;\r\nst = iio_priv(dev_get_drvdata(&client->dev));\r\nst->muxc = i2c_mux_alloc(client->adapter, &client->dev,\r\n1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,\r\ninv_mpu6050_select_bypass,\r\ninv_mpu6050_deselect_bypass);\r\nif (!st->muxc) {\r\nresult = -ENOMEM;\r\ngoto out_unreg_device;\r\n}\r\nst->muxc->priv = dev_get_drvdata(&client->dev);\r\nresult = i2c_mux_add_adapter(st->muxc, 0, 0, 0);\r\nif (result)\r\ngoto out_unreg_device;\r\nresult = inv_mpu_acpi_create_mux_client(client);\r\nif (result)\r\ngoto out_del_mux;\r\nreturn 0;\r\nout_del_mux:\r\ni2c_mux_del_adapters(st->muxc);\r\nout_unreg_device:\r\ninv_mpu_core_remove(&client->dev);\r\nreturn result;\r\n}\r\nstatic int inv_mpu_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\ninv_mpu_acpi_delete_mux_client(client);\r\ni2c_mux_del_adapters(st->muxc);\r\nreturn inv_mpu_core_remove(&client->dev);\r\n}
