static int rxkad_init_connection_security(struct rxrpc_connection *conn)\r\n{\r\nstruct crypto_skcipher *ci;\r\nstruct rxrpc_key_token *token;\r\nint ret;\r\n_enter("{%d},{%x}", conn->debug_id, key_serial(conn->params.key));\r\ntoken = conn->params.key->payload.data[0];\r\nconn->security_ix = token->security_index;\r\nci = crypto_alloc_skcipher("pcbc(fcrypt)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(ci)) {\r\n_debug("no cipher");\r\nret = PTR_ERR(ci);\r\ngoto error;\r\n}\r\nif (crypto_skcipher_setkey(ci, token->kad->session_key,\r\nsizeof(token->kad->session_key)) < 0)\r\nBUG();\r\nswitch (conn->params.security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nbreak;\r\ncase RXRPC_SECURITY_AUTH:\r\nconn->size_align = 8;\r\nconn->security_size = sizeof(struct rxkad_level1_hdr);\r\nbreak;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nconn->size_align = 8;\r\nconn->security_size = sizeof(struct rxkad_level2_hdr);\r\nbreak;\r\ndefault:\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nconn->cipher = ci;\r\nret = 0;\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int rxkad_prime_packet_security(struct rxrpc_connection *conn)\r\n{\r\nstruct rxrpc_key_token *token;\r\nSKCIPHER_REQUEST_ON_STACK(req, conn->cipher);\r\nstruct scatterlist sg;\r\nstruct rxrpc_crypt iv;\r\n__be32 *tmpbuf;\r\nsize_t tmpsize = 4 * sizeof(__be32);\r\n_enter("");\r\nif (!conn->params.key)\r\nreturn 0;\r\ntmpbuf = kmalloc(tmpsize, GFP_KERNEL);\r\nif (!tmpbuf)\r\nreturn -ENOMEM;\r\ntoken = conn->params.key->payload.data[0];\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\ntmpbuf[0] = htonl(conn->proto.epoch);\r\ntmpbuf[1] = htonl(conn->proto.cid);\r\ntmpbuf[2] = 0;\r\ntmpbuf[3] = htonl(conn->security_ix);\r\nsg_init_one(&sg, tmpbuf, tmpsize);\r\nskcipher_request_set_tfm(req, conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, tmpsize, iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\nmemcpy(&conn->csum_iv, tmpbuf + 2, sizeof(conn->csum_iv));\r\nkfree(tmpbuf);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_secure_packet_auth(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 data_size,\r\nvoid *sechdr)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxkad_level1_hdr hdr;\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg;\r\nu16 check;\r\nsp = rxrpc_skb(skb);\r\n_enter("");\r\ncheck = sp->hdr.seq ^ call->call_id;\r\ndata_size |= (u32)check << 16;\r\nhdr.data_size = htonl(data_size);\r\nmemcpy(sechdr, &hdr, sizeof(hdr));\r\nmemset(&iv, 0, sizeof(iv));\r\nsg_init_one(&sg, sechdr, 8);\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_secure_packet_encrypt(const struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nu32 data_size,\r\nvoid *sechdr)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_level2_hdr rxkhdr;\r\nstruct rxrpc_skb_priv *sp;\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[16];\r\nstruct sk_buff *trailer;\r\nunsigned int len;\r\nu16 check;\r\nint nsg;\r\nint err;\r\nsp = rxrpc_skb(skb);\r\n_enter("");\r\ncheck = sp->hdr.seq ^ call->call_id;\r\nrxkhdr.data_size = htonl(data_size | (u32)check << 16);\r\nrxkhdr.checksum = 0;\r\nmemcpy(sechdr, &rxkhdr, sizeof(rxkhdr));\r\ntoken = call->conn->params.key->payload.data[0];\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\nsg_init_one(&sg[0], sechdr, sizeof(rxkhdr));\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg[0], &sg[0], sizeof(rxkhdr), iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nerr = -ENOMEM;\r\nif (nsg < 0 || nsg > 16)\r\ngoto out;\r\nlen = data_size + call->conn->size_align - 1;\r\nlen &= ~(call->conn->size_align - 1);\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, 0, len);\r\nskcipher_request_set_crypt(req, sg, sg, len, iv.x);\r\ncrypto_skcipher_encrypt(req);\r\n_leave(" = 0");\r\nerr = 0;\r\nout:\r\nskcipher_request_zero(req);\r\nreturn err;\r\n}\r\nstatic int rxkad_secure_packet(struct rxrpc_call *call,\r\nstruct sk_buff *skb,\r\nsize_t data_size,\r\nvoid *sechdr)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg;\r\nu32 x, y;\r\nint ret;\r\nsp = rxrpc_skb(skb);\r\n_enter("{%d{%x}},{#%u},%zu,",\r\ncall->debug_id, key_serial(call->conn->params.key),\r\nsp->hdr.seq, data_size);\r\nif (!call->conn->cipher)\r\nreturn 0;\r\nret = key_validate(call->conn->params.key);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(&iv, call->conn->csum_iv.x, sizeof(iv));\r\nx = (call->cid & RXRPC_CHANNELMASK) << (32 - RXRPC_CIDSHIFT);\r\nx |= sp->hdr.seq & 0x3fffffff;\r\ncall->crypto_buf[0] = htonl(call->call_id);\r\ncall->crypto_buf[1] = htonl(x);\r\nsg_init_one(&sg, call->crypto_buf, 8);\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\ny = ntohl(call->crypto_buf[1]);\r\ny = (y >> 16) & 0xffff;\r\nif (y == 0)\r\ny = 1;\r\nsp->hdr.cksum = y;\r\nswitch (call->conn->params.security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nret = 0;\r\nbreak;\r\ncase RXRPC_SECURITY_AUTH:\r\nret = rxkad_secure_packet_auth(call, skb, data_size, sechdr);\r\nbreak;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nret = rxkad_secure_packet_encrypt(call, skb, data_size,\r\nsechdr);\r\nbreak;\r\ndefault:\r\nret = -EPERM;\r\nbreak;\r\n}\r\n_leave(" = %d [set %hx]", ret, y);\r\nreturn ret;\r\n}\r\nstatic int rxkad_verify_packet_1(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int offset, unsigned int len,\r\nrxrpc_seq_t seq)\r\n{\r\nstruct rxkad_level1_hdr sechdr;\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[16];\r\nstruct sk_buff *trailer;\r\nu32 data_size, buf;\r\nu16 check;\r\nint nsg;\r\n_enter("");\r\nif (len < 8) {\r\nrxrpc_abort_call("V1H", call, seq, RXKADSEALEDINCON, EPROTO);\r\ngoto protocol_error;\r\n}\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nif (nsg < 0 || nsg > 16)\r\ngoto nomem;\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, offset, 8);\r\nmemset(&iv, 0, sizeof(iv));\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, 8, iv.x);\r\ncrypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nif (skb_copy_bits(skb, offset, &sechdr, sizeof(sechdr)) < 0) {\r\nrxrpc_abort_call("XV1", call, seq, RXKADDATALEN, EPROTO);\r\ngoto protocol_error;\r\n}\r\noffset += sizeof(sechdr);\r\nlen -= sizeof(sechdr);\r\nbuf = ntohl(sechdr.data_size);\r\ndata_size = buf & 0xffff;\r\ncheck = buf >> 16;\r\ncheck ^= seq ^ call->call_id;\r\ncheck &= 0xffff;\r\nif (check != 0) {\r\nrxrpc_abort_call("V1C", call, seq, RXKADSEALEDINCON, EPROTO);\r\ngoto protocol_error;\r\n}\r\nif (data_size > len) {\r\nrxrpc_abort_call("V1L", call, seq, RXKADDATALEN, EPROTO);\r\ngoto protocol_error;\r\n}\r\n_leave(" = 0 [dlen=%x]", data_size);\r\nreturn 0;\r\nprotocol_error:\r\nrxrpc_send_abort_packet(call);\r\n_leave(" = -EPROTO");\r\nreturn -EPROTO;\r\nnomem:\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nstatic int rxkad_verify_packet_2(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int offset, unsigned int len,\r\nrxrpc_seq_t seq)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_level2_hdr sechdr;\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist _sg[4], *sg;\r\nstruct sk_buff *trailer;\r\nu32 data_size, buf;\r\nu16 check;\r\nint nsg;\r\n_enter(",{%d}", skb->len);\r\nif (len < 8) {\r\nrxrpc_abort_call("V2H", call, seq, RXKADSEALEDINCON, EPROTO);\r\ngoto protocol_error;\r\n}\r\nnsg = skb_cow_data(skb, 0, &trailer);\r\nif (nsg < 0)\r\ngoto nomem;\r\nsg = _sg;\r\nif (unlikely(nsg > 4)) {\r\nsg = kmalloc(sizeof(*sg) * nsg, GFP_NOIO);\r\nif (!sg)\r\ngoto nomem;\r\n}\r\nsg_init_table(sg, nsg);\r\nskb_to_sgvec(skb, sg, offset, len);\r\ntoken = call->conn->params.key->payload.data[0];\r\nmemcpy(&iv, token->kad->session_key, sizeof(iv));\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, len, iv.x);\r\ncrypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nif (sg != _sg)\r\nkfree(sg);\r\nif (skb_copy_bits(skb, offset, &sechdr, sizeof(sechdr)) < 0) {\r\nrxrpc_abort_call("XV2", call, seq, RXKADDATALEN, EPROTO);\r\ngoto protocol_error;\r\n}\r\noffset += sizeof(sechdr);\r\nlen -= sizeof(sechdr);\r\nbuf = ntohl(sechdr.data_size);\r\ndata_size = buf & 0xffff;\r\ncheck = buf >> 16;\r\ncheck ^= seq ^ call->call_id;\r\ncheck &= 0xffff;\r\nif (check != 0) {\r\nrxrpc_abort_call("V2C", call, seq, RXKADSEALEDINCON, EPROTO);\r\ngoto protocol_error;\r\n}\r\nif (data_size > len) {\r\nrxrpc_abort_call("V2L", call, seq, RXKADDATALEN, EPROTO);\r\ngoto protocol_error;\r\n}\r\n_leave(" = 0 [dlen=%x]", data_size);\r\nreturn 0;\r\nprotocol_error:\r\nrxrpc_send_abort_packet(call);\r\n_leave(" = -EPROTO");\r\nreturn -EPROTO;\r\nnomem:\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nstatic int rxkad_verify_packet(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int offset, unsigned int len,\r\nrxrpc_seq_t seq, u16 expected_cksum)\r\n{\r\nSKCIPHER_REQUEST_ON_STACK(req, call->conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg;\r\nu16 cksum;\r\nu32 x, y;\r\n_enter("{%d{%x}},{#%u}",\r\ncall->debug_id, key_serial(call->conn->params.key), seq);\r\nif (!call->conn->cipher)\r\nreturn 0;\r\nmemcpy(&iv, call->conn->csum_iv.x, sizeof(iv));\r\nx = (call->cid & RXRPC_CHANNELMASK) << (32 - RXRPC_CIDSHIFT);\r\nx |= seq & 0x3fffffff;\r\ncall->crypto_buf[0] = htonl(call->call_id);\r\ncall->crypto_buf[1] = htonl(x);\r\nsg_init_one(&sg, call->crypto_buf, 8);\r\nskcipher_request_set_tfm(req, call->conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\ny = ntohl(call->crypto_buf[1]);\r\ncksum = (y >> 16) & 0xffff;\r\nif (cksum == 0)\r\ncksum = 1;\r\nif (cksum != expected_cksum) {\r\nrxrpc_abort_call("VCK", call, seq, RXKADSEALEDINCON, EPROTO);\r\nrxrpc_send_abort_packet(call);\r\n_leave(" = -EPROTO [csum failed]");\r\nreturn -EPROTO;\r\n}\r\nswitch (call->conn->params.security_level) {\r\ncase RXRPC_SECURITY_PLAIN:\r\nreturn 0;\r\ncase RXRPC_SECURITY_AUTH:\r\nreturn rxkad_verify_packet_1(call, skb, offset, len, seq);\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nreturn rxkad_verify_packet_2(call, skb, offset, len, seq);\r\ndefault:\r\nreturn -ENOANO;\r\n}\r\n}\r\nstatic void rxkad_locate_data_1(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int *_offset, unsigned int *_len)\r\n{\r\nstruct rxkad_level1_hdr sechdr;\r\nif (skb_copy_bits(skb, *_offset, &sechdr, sizeof(sechdr)) < 0)\r\nBUG();\r\n*_offset += sizeof(sechdr);\r\n*_len = ntohl(sechdr.data_size) & 0xffff;\r\n}\r\nstatic void rxkad_locate_data_2(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int *_offset, unsigned int *_len)\r\n{\r\nstruct rxkad_level2_hdr sechdr;\r\nif (skb_copy_bits(skb, *_offset, &sechdr, sizeof(sechdr)) < 0)\r\nBUG();\r\n*_offset += sizeof(sechdr);\r\n*_len = ntohl(sechdr.data_size) & 0xffff;\r\n}\r\nstatic void rxkad_locate_data(struct rxrpc_call *call, struct sk_buff *skb,\r\nunsigned int *_offset, unsigned int *_len)\r\n{\r\nswitch (call->conn->params.security_level) {\r\ncase RXRPC_SECURITY_AUTH:\r\nrxkad_locate_data_1(call, skb, _offset, _len);\r\nreturn;\r\ncase RXRPC_SECURITY_ENCRYPT:\r\nrxkad_locate_data_2(call, skb, _offset, _len);\r\nreturn;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic int rxkad_issue_challenge(struct rxrpc_connection *conn)\r\n{\r\nstruct rxkad_challenge challenge;\r\nstruct rxrpc_wire_header whdr;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\nsize_t len;\r\nu32 serial;\r\nint ret;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->params.key));\r\nret = key_validate(conn->params.key);\r\nif (ret < 0)\r\nreturn ret;\r\nget_random_bytes(&conn->security_nonce, sizeof(conn->security_nonce));\r\nchallenge.version = htonl(2);\r\nchallenge.nonce = htonl(conn->security_nonce);\r\nchallenge.min_level = htonl(0);\r\nchallenge.__padding = 0;\r\nmsg.msg_name = &conn->params.peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(conn->params.peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nwhdr.epoch = htonl(conn->proto.epoch);\r\nwhdr.cid = htonl(conn->proto.cid);\r\nwhdr.callNumber = 0;\r\nwhdr.seq = 0;\r\nwhdr.type = RXRPC_PACKET_TYPE_CHALLENGE;\r\nwhdr.flags = conn->out_clientflag;\r\nwhdr.userStatus = 0;\r\nwhdr.securityIndex = conn->security_ix;\r\nwhdr._rsvd = 0;\r\nwhdr.serviceId = htons(conn->params.service_id);\r\niov[0].iov_base = &whdr;\r\niov[0].iov_len = sizeof(whdr);\r\niov[1].iov_base = &challenge;\r\niov[1].iov_len = sizeof(challenge);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nserial = atomic_inc_return(&conn->serial);\r\nwhdr.serial = htonl(serial);\r\n_proto("Tx CHALLENGE %%%u", serial);\r\nret = kernel_sendmsg(conn->params.local->socket, &msg, iov, 2, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxkad_send_response(struct rxrpc_connection *conn,\r\nstruct rxrpc_host_header *hdr,\r\nstruct rxkad_response *resp,\r\nconst struct rxkad_key *s2)\r\n{\r\nstruct rxrpc_wire_header whdr;\r\nstruct msghdr msg;\r\nstruct kvec iov[3];\r\nsize_t len;\r\nu32 serial;\r\nint ret;\r\n_enter("");\r\nmsg.msg_name = &conn->params.peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(conn->params.peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nmemset(&whdr, 0, sizeof(whdr));\r\nwhdr.epoch = htonl(hdr->epoch);\r\nwhdr.cid = htonl(hdr->cid);\r\nwhdr.type = RXRPC_PACKET_TYPE_RESPONSE;\r\nwhdr.flags = conn->out_clientflag;\r\nwhdr.securityIndex = hdr->securityIndex;\r\nwhdr.serviceId = htons(hdr->serviceId);\r\niov[0].iov_base = &whdr;\r\niov[0].iov_len = sizeof(whdr);\r\niov[1].iov_base = resp;\r\niov[1].iov_len = sizeof(*resp);\r\niov[2].iov_base = (void *)s2->ticket;\r\niov[2].iov_len = s2->ticket_len;\r\nlen = iov[0].iov_len + iov[1].iov_len + iov[2].iov_len;\r\nserial = atomic_inc_return(&conn->serial);\r\nwhdr.serial = htonl(serial);\r\n_proto("Tx RESPONSE %%%u", serial);\r\nret = kernel_sendmsg(conn->params.local->socket, &msg, iov, 3, len);\r\nif (ret < 0) {\r\n_debug("sendmsg failed: %d", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxkad_calc_response_checksum(struct rxkad_response *response)\r\n{\r\nu32 csum = 1000003;\r\nint loop;\r\nu8 *p = (u8 *) response;\r\nfor (loop = sizeof(*response); loop > 0; loop--)\r\ncsum = csum * 0x10204081 + *p++;\r\nresponse->encrypted.checksum = htonl(csum);\r\n}\r\nstatic void rxkad_encrypt_response(struct rxrpc_connection *conn,\r\nstruct rxkad_response *resp,\r\nconst struct rxkad_key *s2)\r\n{\r\nSKCIPHER_REQUEST_ON_STACK(req, conn->cipher);\r\nstruct rxrpc_crypt iv;\r\nstruct scatterlist sg[1];\r\nmemcpy(&iv, s2->session_key, sizeof(iv));\r\nsg_init_table(sg, 1);\r\nsg_set_buf(sg, &resp->encrypted, sizeof(resp->encrypted));\r\nskcipher_request_set_tfm(req, conn->cipher);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, sizeof(resp->encrypted), iv.x);\r\ncrypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\n}\r\nstatic int rxkad_respond_to_challenge(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nconst struct rxrpc_key_token *token;\r\nstruct rxkad_challenge challenge;\r\nstruct rxkad_response resp\r\n__attribute__((aligned(8)));\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nu32 version, nonce, min_level, abort_code;\r\nint ret;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->params.key));\r\nif (!conn->params.key) {\r\n_leave(" = -EPROTO [no key]");\r\nreturn -EPROTO;\r\n}\r\nret = key_validate(conn->params.key);\r\nif (ret < 0) {\r\n*_abort_code = RXKADEXPIRED;\r\nreturn ret;\r\n}\r\nabort_code = RXKADPACKETSHORT;\r\nif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\r\n&challenge, sizeof(challenge)) < 0)\r\ngoto protocol_error;\r\nversion = ntohl(challenge.version);\r\nnonce = ntohl(challenge.nonce);\r\nmin_level = ntohl(challenge.min_level);\r\n_proto("Rx CHALLENGE %%%u { v=%u n=%u ml=%u }",\r\nsp->hdr.serial, version, nonce, min_level);\r\nabort_code = RXKADINCONSISTENCY;\r\nif (version != RXKAD_VERSION)\r\ngoto protocol_error;\r\nabort_code = RXKADLEVELFAIL;\r\nif (conn->params.security_level < min_level)\r\ngoto protocol_error;\r\ntoken = conn->params.key->payload.data[0];\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.version = htonl(RXKAD_VERSION);\r\nresp.encrypted.epoch = htonl(conn->proto.epoch);\r\nresp.encrypted.cid = htonl(conn->proto.cid);\r\nresp.encrypted.securityIndex = htonl(conn->security_ix);\r\nresp.encrypted.inc_nonce = htonl(nonce + 1);\r\nresp.encrypted.level = htonl(conn->params.security_level);\r\nresp.kvno = htonl(token->kad->kvno);\r\nresp.ticket_len = htonl(token->kad->ticket_len);\r\nresp.encrypted.call_id[0] = htonl(conn->channels[0].call_counter);\r\nresp.encrypted.call_id[1] = htonl(conn->channels[1].call_counter);\r\nresp.encrypted.call_id[2] = htonl(conn->channels[2].call_counter);\r\nresp.encrypted.call_id[3] = htonl(conn->channels[3].call_counter);\r\nrxkad_calc_response_checksum(&resp);\r\nrxkad_encrypt_response(conn, &resp, token->kad);\r\nreturn rxkad_send_response(conn, &sp->hdr, &resp, token->kad);\r\nprotocol_error:\r\n*_abort_code = abort_code;\r\n_leave(" = -EPROTO [%d]", abort_code);\r\nreturn -EPROTO;\r\n}\r\nstatic int rxkad_decrypt_ticket(struct rxrpc_connection *conn,\r\nvoid *ticket, size_t ticket_len,\r\nstruct rxrpc_crypt *_session_key,\r\ntime_t *_expiry,\r\nu32 *_abort_code)\r\n{\r\nstruct skcipher_request *req;\r\nstruct rxrpc_crypt iv, key;\r\nstruct scatterlist sg[1];\r\nstruct in_addr addr;\r\nunsigned int life;\r\ntime_t issue, now;\r\nbool little_endian;\r\nint ret;\r\nu8 *p, *q, *name, *end;\r\n_enter("{%d},{%x}", conn->debug_id, key_serial(conn->server_key));\r\n*_expiry = 0;\r\nret = key_validate(conn->server_key);\r\nif (ret < 0) {\r\nswitch (ret) {\r\ncase -EKEYEXPIRED:\r\n*_abort_code = RXKADEXPIRED;\r\ngoto error;\r\ndefault:\r\n*_abort_code = RXKADNOAUTH;\r\ngoto error;\r\n}\r\n}\r\nASSERT(conn->server_key->payload.data[0] != NULL);\r\nASSERTCMP((unsigned long) ticket & 7UL, ==, 0);\r\nmemcpy(&iv, &conn->server_key->payload.data[2], sizeof(iv));\r\nreq = skcipher_request_alloc(conn->server_key->payload.data[0],\r\nGFP_NOFS);\r\nif (!req) {\r\n*_abort_code = RXKADNOAUTH;\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nsg_init_one(&sg[0], ticket, ticket_len);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, ticket_len, iv.x);\r\ncrypto_skcipher_decrypt(req);\r\nskcipher_request_free(req);\r\np = ticket;\r\nend = p + ticket_len;\r\n#define Z(size) \\r\n({ \\r\nu8 *__str = p; \\r\nq = memchr(p, 0, end - p); \\r\nif (!q || q - p > (size)) \\r\ngoto bad_ticket; \\r\nfor (; p < q; p++) \\r\nif (!isprint(*p)) \\r\ngoto bad_ticket; \\r\np++; \\r\n__str; \\r\n})\r\n_debug("KIV FLAGS: %x", *p);\r\nlittle_endian = *p & 1;\r\np++;\r\nname = Z(ANAME_SZ);\r\n_debug("KIV ANAME: %s", name);\r\nname = Z(INST_SZ);\r\n_debug("KIV INST : %s", name);\r\nname = Z(REALM_SZ);\r\n_debug("KIV REALM: %s", name);\r\nif (end - p < 4 + 8 + 4 + 2)\r\ngoto bad_ticket;\r\nmemcpy(&addr, p, sizeof(addr));\r\np += 4;\r\n_debug("KIV ADDR : %pI4", &addr);\r\nmemcpy(&key, p, sizeof(key));\r\np += 8;\r\n_debug("KIV KEY : %08x %08x", ntohl(key.n[0]), ntohl(key.n[1]));\r\nmemcpy(_session_key, &key, sizeof(key));\r\nlife = *p++ * 5 * 60;\r\n_debug("KIV LIFE : %u", life);\r\nif (little_endian) {\r\n__le32 stamp;\r\nmemcpy(&stamp, p, 4);\r\nissue = le32_to_cpu(stamp);\r\n} else {\r\n__be32 stamp;\r\nmemcpy(&stamp, p, 4);\r\nissue = be32_to_cpu(stamp);\r\n}\r\np += 4;\r\nnow = get_seconds();\r\n_debug("KIV ISSUE: %lx [%lx]", issue, now);\r\nif (issue > now) {\r\n*_abort_code = RXKADNOAUTH;\r\nret = -EKEYREJECTED;\r\ngoto error;\r\n}\r\nif (issue < now - life) {\r\n*_abort_code = RXKADEXPIRED;\r\nret = -EKEYEXPIRED;\r\ngoto error;\r\n}\r\n*_expiry = issue + life;\r\nname = Z(SNAME_SZ);\r\n_debug("KIV SNAME: %s", name);\r\nname = Z(INST_SZ);\r\n_debug("KIV SINST: %s", name);\r\nret = 0;\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nbad_ticket:\r\n*_abort_code = RXKADBADTICKET;\r\nret = -EBADMSG;\r\ngoto error;\r\n}\r\nstatic void rxkad_decrypt_response(struct rxrpc_connection *conn,\r\nstruct rxkad_response *resp,\r\nconst struct rxrpc_crypt *session_key)\r\n{\r\nSKCIPHER_REQUEST_ON_STACK(req, rxkad_ci);\r\nstruct scatterlist sg[1];\r\nstruct rxrpc_crypt iv;\r\n_enter(",,%08x%08x",\r\nntohl(session_key->n[0]), ntohl(session_key->n[1]));\r\nASSERT(rxkad_ci != NULL);\r\nmutex_lock(&rxkad_ci_mutex);\r\nif (crypto_skcipher_setkey(rxkad_ci, session_key->x,\r\nsizeof(*session_key)) < 0)\r\nBUG();\r\nmemcpy(&iv, session_key, sizeof(iv));\r\nsg_init_table(sg, 1);\r\nsg_set_buf(sg, &resp->encrypted, sizeof(resp->encrypted));\r\nskcipher_request_set_tfm(req, rxkad_ci);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, sg, sg, sizeof(resp->encrypted), iv.x);\r\ncrypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nmutex_unlock(&rxkad_ci_mutex);\r\n_leave("");\r\n}\r\nstatic int rxkad_verify_response(struct rxrpc_connection *conn,\r\nstruct sk_buff *skb,\r\nu32 *_abort_code)\r\n{\r\nstruct rxkad_response response\r\n__attribute__((aligned(8)));\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct rxrpc_crypt session_key;\r\ntime_t expiry;\r\nvoid *ticket;\r\nu32 abort_code, version, kvno, ticket_len, level;\r\n__be32 csum;\r\nint ret, i;\r\n_enter("{%d,%x}", conn->debug_id, key_serial(conn->server_key));\r\nabort_code = RXKADPACKETSHORT;\r\nif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\r\n&response, sizeof(response)) < 0)\r\ngoto protocol_error;\r\nif (!pskb_pull(skb, sizeof(response)))\r\nBUG();\r\nversion = ntohl(response.version);\r\nticket_len = ntohl(response.ticket_len);\r\nkvno = ntohl(response.kvno);\r\n_proto("Rx RESPONSE %%%u { v=%u kv=%u tl=%u }",\r\nsp->hdr.serial, version, kvno, ticket_len);\r\nabort_code = RXKADINCONSISTENCY;\r\nif (version != RXKAD_VERSION)\r\ngoto protocol_error;\r\nabort_code = RXKADTICKETLEN;\r\nif (ticket_len < 4 || ticket_len > MAXKRB5TICKETLEN)\r\ngoto protocol_error;\r\nabort_code = RXKADUNKNOWNKEY;\r\nif (kvno >= RXKAD_TKT_TYPE_KERBEROS_V5)\r\ngoto protocol_error;\r\nticket = kmalloc(ticket_len, GFP_NOFS);\r\nif (!ticket)\r\nreturn -ENOMEM;\r\nabort_code = RXKADPACKETSHORT;\r\nif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\r\nticket, ticket_len) < 0)\r\ngoto protocol_error_free;\r\nret = rxkad_decrypt_ticket(conn, ticket, ticket_len, &session_key,\r\n&expiry, &abort_code);\r\nif (ret < 0) {\r\n*_abort_code = abort_code;\r\nkfree(ticket);\r\nreturn ret;\r\n}\r\nrxkad_decrypt_response(conn, &response, &session_key);\r\nabort_code = RXKADSEALEDINCON;\r\nif (ntohl(response.encrypted.epoch) != conn->proto.epoch)\r\ngoto protocol_error_free;\r\nif (ntohl(response.encrypted.cid) != conn->proto.cid)\r\ngoto protocol_error_free;\r\nif (ntohl(response.encrypted.securityIndex) != conn->security_ix)\r\ngoto protocol_error_free;\r\ncsum = response.encrypted.checksum;\r\nresponse.encrypted.checksum = 0;\r\nrxkad_calc_response_checksum(&response);\r\nif (response.encrypted.checksum != csum)\r\ngoto protocol_error_free;\r\nspin_lock(&conn->channel_lock);\r\nfor (i = 0; i < RXRPC_MAXCALLS; i++) {\r\nstruct rxrpc_call *call;\r\nu32 call_id = ntohl(response.encrypted.call_id[i]);\r\nif (call_id > INT_MAX)\r\ngoto protocol_error_unlock;\r\nif (call_id < conn->channels[i].call_counter)\r\ngoto protocol_error_unlock;\r\nif (call_id > conn->channels[i].call_counter) {\r\ncall = rcu_dereference_protected(\r\nconn->channels[i].call,\r\nlockdep_is_held(&conn->channel_lock));\r\nif (call && call->state < RXRPC_CALL_COMPLETE)\r\ngoto protocol_error_unlock;\r\nconn->channels[i].call_counter = call_id;\r\n}\r\n}\r\nspin_unlock(&conn->channel_lock);\r\nabort_code = RXKADOUTOFSEQUENCE;\r\nif (ntohl(response.encrypted.inc_nonce) != conn->security_nonce + 1)\r\ngoto protocol_error_free;\r\nabort_code = RXKADLEVELFAIL;\r\nlevel = ntohl(response.encrypted.level);\r\nif (level > RXRPC_SECURITY_ENCRYPT)\r\ngoto protocol_error_free;\r\nconn->params.security_level = level;\r\nret = rxrpc_get_server_data_key(conn, &session_key, expiry, kvno);\r\nif (ret < 0) {\r\nkfree(ticket);\r\nreturn ret;\r\n}\r\nkfree(ticket);\r\n_leave(" = 0");\r\nreturn 0;\r\nprotocol_error_unlock:\r\nspin_unlock(&conn->channel_lock);\r\nprotocol_error_free:\r\nkfree(ticket);\r\nprotocol_error:\r\n*_abort_code = abort_code;\r\n_leave(" = -EPROTO [%d]", abort_code);\r\nreturn -EPROTO;\r\n}\r\nstatic void rxkad_clear(struct rxrpc_connection *conn)\r\n{\r\n_enter("");\r\nif (conn->cipher)\r\ncrypto_free_skcipher(conn->cipher);\r\n}\r\nstatic int rxkad_init(void)\r\n{\r\nrxkad_ci = crypto_alloc_skcipher("pcbc(fcrypt)", 0, CRYPTO_ALG_ASYNC);\r\nreturn PTR_ERR_OR_ZERO(rxkad_ci);\r\n}\r\nstatic void rxkad_exit(void)\r\n{\r\nif (rxkad_ci)\r\ncrypto_free_skcipher(rxkad_ci);\r\n}
