int __init irda_device_init( void)\r\n{\r\ndongles = hashbin_new(HB_NOLOCK);\r\nif (dongles == NULL) {\r\nnet_warn_ratelimited("IrDA: Can't allocate dongles hashbin!\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dongles->hb_spinlock);\r\ntasks = hashbin_new(HB_LOCK);\r\nif (tasks == NULL) {\r\nnet_warn_ratelimited("IrDA: Can't allocate tasks hashbin!\n");\r\nhashbin_delete(dongles, NULL);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void leftover_dongle(void *arg)\r\n{\r\nstruct dongle_reg *reg = arg;\r\nnet_warn_ratelimited("IrDA: Dongle type %x not unregistered\n",\r\nreg->type);\r\n}\r\nvoid irda_device_cleanup(void)\r\n{\r\nhashbin_delete(tasks, (FREE_FUNC) __irda_task_delete);\r\nhashbin_delete(dongles, leftover_dongle);\r\n}\r\nvoid irda_device_set_media_busy(struct net_device *dev, int status)\r\n{\r\nstruct irlap_cb *self;\r\npr_debug("%s(%s)\n", __func__, status ? "TRUE" : "FALSE");\r\nself = (struct irlap_cb *) dev->atalk_ptr;\r\nif (!self || self->magic != LAP_MAGIC)\r\nreturn;\r\nif (status) {\r\nself->media_busy = TRUE;\r\nif (status == SMALL)\r\nirlap_start_mbusy_timer(self, SMALLBUSY_TIMEOUT);\r\nelse\r\nirlap_start_mbusy_timer(self, MEDIABUSY_TIMEOUT);\r\npr_debug("Media busy!\n");\r\n} else {\r\nself->media_busy = FALSE;\r\nirlap_stop_mbusy_timer(self);\r\n}\r\n}\r\nint irda_device_is_receiving(struct net_device *dev)\r\n{\r\nstruct if_irda_req req;\r\nint ret;\r\nif (!dev->netdev_ops->ndo_do_ioctl) {\r\nnet_err_ratelimited("%s: do_ioctl not impl. by device driver\n",\r\n__func__);\r\nreturn -1;\r\n}\r\nret = (dev->netdev_ops->ndo_do_ioctl)(dev, (struct ifreq *) &req,\r\nSIOCGRECEIVING);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn req.ifr_receiving;\r\n}\r\nstatic void __irda_task_delete(struct irda_task *task)\r\n{\r\ndel_timer(&task->timer);\r\nkfree(task);\r\n}\r\nstatic void irda_task_delete(struct irda_task *task)\r\n{\r\nhashbin_remove(tasks, (long) task, NULL);\r\n__irda_task_delete(task);\r\n}\r\nstatic int irda_task_kick(struct irda_task *task)\r\n{\r\nint finished = TRUE;\r\nint count = 0;\r\nint timeout;\r\nIRDA_ASSERT(task != NULL, return -1;);\r\nIRDA_ASSERT(task->magic == IRDA_TASK_MAGIC, return -1;);\r\ndo {\r\ntimeout = task->function(task);\r\nif (count++ > 100) {\r\nnet_err_ratelimited("%s: error in task handler!\n",\r\n__func__);\r\nirda_task_delete(task);\r\nreturn TRUE;\r\n}\r\n} while ((timeout == 0) && (task->state != IRDA_TASK_DONE));\r\nif (timeout < 0) {\r\nnet_err_ratelimited("%s: Error executing task!\n", __func__);\r\nirda_task_delete(task);\r\nreturn TRUE;\r\n}\r\nif (task->state == IRDA_TASK_DONE) {\r\ndel_timer(&task->timer);\r\nif (task->finished)\r\ntask->finished(task);\r\nif (task->parent) {\r\nif (task->parent->state == IRDA_TASK_CHILD_WAIT) {\r\ntask->parent->state = IRDA_TASK_CHILD_DONE;\r\ndel_timer(&task->parent->timer);\r\nirda_task_kick(task->parent);\r\n}\r\n}\r\nirda_task_delete(task);\r\n} else if (timeout > 0) {\r\nirda_start_timer(&task->timer, timeout, (void *) task,\r\nirda_task_timer_expired);\r\nfinished = FALSE;\r\n} else {\r\npr_debug("%s(), not finished, and no timeout!\n",\r\n__func__);\r\nfinished = FALSE;\r\n}\r\nreturn finished;\r\n}\r\nstatic void irda_task_timer_expired(void *data)\r\n{\r\nstruct irda_task *task;\r\ntask = data;\r\nirda_task_kick(task);\r\n}\r\nstatic void irda_device_setup(struct net_device *dev)\r\n{\r\ndev->hard_header_len = 0;\r\ndev->addr_len = LAP_ALEN;\r\ndev->type = ARPHRD_IRDA;\r\ndev->tx_queue_len = 8;\r\nmemset(dev->broadcast, 0xff, LAP_ALEN);\r\ndev->mtu = 2048;\r\ndev->flags = IFF_NOARP;\r\n}\r\nstruct net_device *alloc_irdadev(int sizeof_priv)\r\n{\r\nreturn alloc_netdev(sizeof_priv, "irda%d", NET_NAME_UNKNOWN,\r\nirda_device_setup);\r\n}\r\nvoid irda_setup_dma(int channel, dma_addr_t buffer, int count, int mode)\r\n{\r\nunsigned long flags;\r\nflags = claim_dma_lock();\r\ndisable_dma(channel);\r\nclear_dma_ff(channel);\r\nset_dma_mode(channel, mode);\r\nset_dma_addr(channel, buffer);\r\nset_dma_count(channel, count);\r\nenable_dma(channel);\r\nrelease_dma_lock(flags);\r\n}
