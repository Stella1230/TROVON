int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\r\n{\r\nint n = 0;\r\nint i;\r\nif (1 == m->m_max_mds && m->m_info[0].state > 0)\r\nreturn 0;\r\nfor (i = 0; i < m->m_max_mds; i++)\r\nif (m->m_info[i].state > 0)\r\nn++;\r\nif (n == 0)\r\nreturn -1;\r\nn = prandom_u32() % n;\r\ni = 0;\r\nfor (i = 0; n > 0; i++, n--)\r\nwhile (m->m_info[i].state <= 0)\r\ni++;\r\nreturn i;\r\n}\r\nstatic int __decode_and_drop_compat_set(void **p, void* end)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nu32 n;\r\nceph_decode_need(p, end, sizeof(u64) + sizeof(u32), bad);\r\n*p += sizeof(u64);\r\nn = ceph_decode_32(p);\r\nwhile (n-- > 0) {\r\nu32 len;\r\nceph_decode_need(p, end, sizeof(u64) + sizeof(u32),\r\nbad);\r\n*p += sizeof(u64);\r\nlen = ceph_decode_32(p);\r\nceph_decode_need(p, end, len, bad);\r\n*p += len;\r\n}\r\n}\r\nreturn 0;\r\nbad:\r\nreturn -1;\r\n}\r\nstruct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\r\n{\r\nstruct ceph_mdsmap *m;\r\nconst void *start = *p;\r\nint i, j, n;\r\nint err = -EINVAL;\r\nu8 mdsmap_v, mdsmap_cv;\r\nu16 mdsmap_ev;\r\nm = kzalloc(sizeof(*m), GFP_NOFS);\r\nif (m == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nceph_decode_need(p, end, 1 + 1, bad);\r\nmdsmap_v = ceph_decode_8(p);\r\nmdsmap_cv = ceph_decode_8(p);\r\nif (mdsmap_v >= 4) {\r\nu32 mdsmap_len;\r\nceph_decode_32_safe(p, end, mdsmap_len, bad);\r\nif (end < *p + mdsmap_len)\r\ngoto bad;\r\nend = *p + mdsmap_len;\r\n}\r\nceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\r\nm->m_epoch = ceph_decode_32(p);\r\nm->m_client_epoch = ceph_decode_32(p);\r\nm->m_last_failure = ceph_decode_32(p);\r\nm->m_root = ceph_decode_32(p);\r\nm->m_session_timeout = ceph_decode_32(p);\r\nm->m_session_autoclose = ceph_decode_32(p);\r\nm->m_max_file_size = ceph_decode_64(p);\r\nm->m_max_mds = ceph_decode_32(p);\r\nm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\r\nif (m->m_info == NULL)\r\ngoto nomem;\r\nn = ceph_decode_32(p);\r\nfor (i = 0; i < n; i++) {\r\nu64 global_id;\r\nu32 namelen;\r\ns32 mds, inc, state;\r\nu64 state_seq;\r\nu8 info_v;\r\nvoid *info_end = NULL;\r\nstruct ceph_entity_addr addr;\r\nu32 num_export_targets;\r\nvoid *pexport_targets = NULL;\r\nstruct ceph_timespec laggy_since;\r\nstruct ceph_mds_info *info;\r\nceph_decode_need(p, end, sizeof(u64) + 1, bad);\r\nglobal_id = ceph_decode_64(p);\r\ninfo_v= ceph_decode_8(p);\r\nif (info_v >= 4) {\r\nu32 info_len;\r\nu8 info_cv;\r\nceph_decode_need(p, end, 1 + sizeof(u32), bad);\r\ninfo_cv = ceph_decode_8(p);\r\ninfo_len = ceph_decode_32(p);\r\ninfo_end = *p + info_len;\r\nif (info_end > end)\r\ngoto bad;\r\n}\r\nceph_decode_need(p, end, sizeof(u64) + sizeof(u32), bad);\r\n*p += sizeof(u64);\r\nnamelen = ceph_decode_32(p);\r\n*p += namelen;\r\nceph_decode_need(p, end,\r\n4*sizeof(u32) + sizeof(u64) +\r\nsizeof(addr) + sizeof(struct ceph_timespec),\r\nbad);\r\nmds = ceph_decode_32(p);\r\ninc = ceph_decode_32(p);\r\nstate = ceph_decode_32(p);\r\nstate_seq = ceph_decode_64(p);\r\nceph_decode_copy(p, &addr, sizeof(addr));\r\nceph_decode_addr(&addr);\r\nceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\r\n*p += sizeof(u32);\r\nceph_decode_32_safe(p, end, namelen, bad);\r\n*p += namelen;\r\nif (info_v >= 2) {\r\nceph_decode_32_safe(p, end, num_export_targets, bad);\r\npexport_targets = *p;\r\n*p += num_export_targets * sizeof(u32);\r\n} else {\r\nnum_export_targets = 0;\r\n}\r\nif (info_end && *p != info_end) {\r\nif (*p > info_end)\r\ngoto bad;\r\n*p = info_end;\r\n}\r\ndout("mdsmap_decode %d/%d %lld mds%d.%d %s %s\n",\r\ni+1, n, global_id, mds, inc,\r\nceph_pr_addr(&addr.in_addr),\r\nceph_mds_state_name(state));\r\nif (mds < 0 || mds >= m->m_max_mds || state <= 0)\r\ncontinue;\r\ninfo = &m->m_info[mds];\r\ninfo->global_id = global_id;\r\ninfo->state = state;\r\ninfo->addr = addr;\r\ninfo->laggy = (laggy_since.tv_sec != 0 ||\r\nlaggy_since.tv_nsec != 0);\r\ninfo->num_export_targets = num_export_targets;\r\nif (num_export_targets) {\r\ninfo->export_targets = kcalloc(num_export_targets,\r\nsizeof(u32), GFP_NOFS);\r\nif (info->export_targets == NULL)\r\ngoto nomem;\r\nfor (j = 0; j < num_export_targets; j++)\r\ninfo->export_targets[j] =\r\nceph_decode_32(&pexport_targets);\r\n} else {\r\ninfo->export_targets = NULL;\r\n}\r\n}\r\nceph_decode_32_safe(p, end, n, bad);\r\nm->m_num_data_pg_pools = n;\r\nm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\r\nif (!m->m_data_pg_pools)\r\ngoto nomem;\r\nceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\r\nfor (i = 0; i < n; i++)\r\nm->m_data_pg_pools[i] = ceph_decode_64(p);\r\nm->m_cas_pg_pool = ceph_decode_64(p);\r\nm->m_enabled = m->m_epoch > 1;\r\nmdsmap_ev = 1;\r\nif (mdsmap_v >= 2) {\r\nceph_decode_16_safe(p, end, mdsmap_ev, bad_ext);\r\n}\r\nif (mdsmap_ev >= 3) {\r\nif (__decode_and_drop_compat_set(p, end) < 0)\r\ngoto bad_ext;\r\n}\r\nif (mdsmap_ev < 5) {\r\n__decode_and_drop_type(p, end, u32, bad_ext);\r\n} else {\r\n__decode_and_drop_type(p, end, u64, bad_ext);\r\n}\r\n__decode_and_drop_type(p, end, struct ceph_timespec, bad_ext);\r\n__decode_and_drop_type(p, end, struct ceph_timespec, bad_ext);\r\n__decode_and_drop_type(p, end, u32, bad_ext);\r\n{\r\nint num_laggy = 0;\r\nceph_decode_32_safe(p, end, n, bad_ext);\r\nceph_decode_need(p, end, sizeof(u32) * n, bad_ext);\r\nfor (i = 0; i < n; i++) {\r\ns32 mds = ceph_decode_32(p);\r\nif (mds >= 0 && mds < m->m_max_mds) {\r\nif (m->m_info[mds].laggy)\r\nnum_laggy++;\r\n}\r\n}\r\nm->m_num_laggy = num_laggy;\r\n}\r\n__decode_and_drop_map(p, end, u32, u32, bad_ext);\r\n__decode_and_drop_map(p, end, u32, u64, bad_ext);\r\n__decode_and_drop_set(p, end, u32, bad_ext);\r\n__decode_and_drop_set(p, end, u32, bad_ext);\r\nif (mdsmap_ev >= 4) {\r\n__decode_and_drop_type(p, end, u32, bad_ext);\r\n}\r\nif (mdsmap_ev >= 6) {\r\n__decode_and_drop_type(p, end, u8, bad_ext);\r\n__decode_and_drop_type(p, end, u8, bad_ext);\r\n}\r\nif (mdsmap_ev >= 7) {\r\n__decode_and_drop_type(p, end, u8, bad_ext);\r\n}\r\nif (mdsmap_ev >= 8) {\r\nu32 name_len;\r\nceph_decode_8_safe(p, end, m->m_enabled, bad_ext);\r\nceph_decode_32_safe(p, end, name_len, bad_ext);\r\nceph_decode_need(p, end, name_len, bad_ext);\r\n*p += name_len;\r\n}\r\nif (mdsmap_ev >= 9) {\r\nsize_t need;\r\nceph_decode_32_safe(p, end, n, bad_ext);\r\nneed = sizeof(u32) * n;\r\nceph_decode_need(p, end, need, bad_ext);\r\n*p += need;\r\nm->m_damaged = n > 0;\r\n} else {\r\nm->m_damaged = false;\r\n}\r\nbad_ext:\r\n*p = end;\r\ndout("mdsmap_decode success epoch %u\n", m->m_epoch);\r\nreturn m;\r\nnomem:\r\nerr = -ENOMEM;\r\ngoto out_err;\r\nbad:\r\npr_err("corrupt mdsmap\n");\r\nprint_hex_dump(KERN_DEBUG, "mdsmap: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nstart, end - start, true);\r\nout_err:\r\nceph_mdsmap_destroy(m);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\r\n{\r\nint i;\r\nfor (i = 0; i < m->m_max_mds; i++)\r\nkfree(m->m_info[i].export_targets);\r\nkfree(m->m_info);\r\nkfree(m->m_data_pg_pools);\r\nkfree(m);\r\n}\r\nbool ceph_mdsmap_is_cluster_available(struct ceph_mdsmap *m)\r\n{\r\nint i, nr_active = 0;\r\nif (!m->m_enabled)\r\nreturn false;\r\nif (m->m_damaged)\r\nreturn false;\r\nif (m->m_num_laggy > 0)\r\nreturn false;\r\nfor (i = 0; i < m->m_max_mds; i++) {\r\nif (m->m_info[i].state == CEPH_MDS_STATE_ACTIVE)\r\nnr_active++;\r\n}\r\nreturn nr_active > 0;\r\n}
