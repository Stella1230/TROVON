static int mpu3050_i2c_bypass_select(struct i2c_mux_core *mux, u32 chan_id)\r\n{\r\nstruct mpu3050 *mpu3050 = i2c_mux_priv(mux);\r\npm_runtime_get_sync(mpu3050->dev);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_i2c_bypass_deselect(struct i2c_mux_core *mux, u32 chan_id)\r\n{\r\nstruct mpu3050 *mpu3050 = i2c_mux_priv(mux);\r\npm_runtime_mark_last_busy(mpu3050->dev);\r\npm_runtime_put_autosuspend(mpu3050->dev);\r\nreturn 0;\r\n}\r\nstatic int mpu3050_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regmap *regmap;\r\nconst char *name;\r\nstruct mpu3050 *mpu3050;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EOPNOTSUPP;\r\nif (id)\r\nname = id->name;\r\nelse\r\nreturn -ENODEV;\r\nregmap = devm_regmap_init_i2c(client, &mpu3050_i2c_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "Failed to register i2c regmap %d\n",\r\n(int)PTR_ERR(regmap));\r\nreturn PTR_ERR(regmap);\r\n}\r\nret = mpu3050_common_probe(&client->dev, regmap, client->irq, name);\r\nif (ret)\r\nreturn ret;\r\nmpu3050 = iio_priv(dev_get_drvdata(&client->dev));\r\nmpu3050->i2cmux = i2c_mux_alloc(client->adapter, &client->dev,\r\n1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,\r\nmpu3050_i2c_bypass_select,\r\nmpu3050_i2c_bypass_deselect);\r\nif (!mpu3050->i2cmux)\r\ndev_err(&client->dev, "failed to allocate I2C mux\n");\r\nelse {\r\nmpu3050->i2cmux->priv = mpu3050;\r\nret = i2c_mux_add_adapter(mpu3050->i2cmux, 0, 0, 0);\r\nif (ret)\r\ndev_err(&client->dev, "failed to add I2C mux\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpu3050_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(&client->dev);\r\nstruct mpu3050 *mpu3050 = iio_priv(indio_dev);\r\nif (mpu3050->i2cmux)\r\ni2c_mux_del_adapters(mpu3050->i2cmux);\r\nreturn mpu3050_common_remove(&client->dev);\r\n}
