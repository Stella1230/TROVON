static void acornfb_set_timing(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct vidc_timing vidc;\r\nu_int vcr, fsize;\r\nu_int ext_ctl, dat_ctl;\r\nu_int words_per_line;\r\nmemset(&vidc, 0, sizeof(vidc));\r\nvidc.h_sync_width = var->hsync_len - 8;\r\nvidc.h_border_start = vidc.h_sync_width + var->left_margin + 8 - 12;\r\nvidc.h_display_start = vidc.h_border_start + 12 - 18;\r\nvidc.h_display_end = vidc.h_display_start + var->xres;\r\nvidc.h_border_end = vidc.h_display_end + 18 - 12;\r\nvidc.h_cycle = vidc.h_border_end + var->right_margin + 12 - 8;\r\nvidc.h_interlace = vidc.h_cycle / 2;\r\nvidc.v_sync_width = var->vsync_len - 1;\r\nvidc.v_border_start = vidc.v_sync_width + var->upper_margin;\r\nvidc.v_display_start = vidc.v_border_start;\r\nvidc.v_display_end = vidc.v_display_start + var->yres;\r\nvidc.v_border_end = vidc.v_display_end;\r\nvidc.control = acornfb_default_control();\r\nvcr = var->vsync_len + var->upper_margin + var->yres +\r\nvar->lower_margin;\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nvidc.v_cycle = (vcr - 3) / 2;\r\nvidc.control |= VIDC20_CTRL_INT;\r\n} else\r\nvidc.v_cycle = vcr - 2;\r\nswitch (var->bits_per_pixel) {\r\ncase 1: vidc.control |= VIDC20_CTRL_1BPP; break;\r\ncase 2: vidc.control |= VIDC20_CTRL_2BPP; break;\r\ncase 4: vidc.control |= VIDC20_CTRL_4BPP; break;\r\ndefault:\r\ncase 8: vidc.control |= VIDC20_CTRL_8BPP; break;\r\ncase 16: vidc.control |= VIDC20_CTRL_16BPP; break;\r\ncase 32: vidc.control |= VIDC20_CTRL_32BPP; break;\r\n}\r\nacornfb_vidc20_find_rates(&vidc, var);\r\nfsize = var->vsync_len + var->upper_margin + var->lower_margin - 1;\r\nif (memcmp(&current_vidc, &vidc, sizeof(vidc))) {\r\ncurrent_vidc = vidc;\r\nvidc_writel(VIDC20_CTRL| vidc.control);\r\nvidc_writel(0xd0000000 | vidc.pll_ctl);\r\nvidc_writel(0x80000000 | vidc.h_cycle);\r\nvidc_writel(0x81000000 | vidc.h_sync_width);\r\nvidc_writel(0x82000000 | vidc.h_border_start);\r\nvidc_writel(0x83000000 | vidc.h_display_start);\r\nvidc_writel(0x84000000 | vidc.h_display_end);\r\nvidc_writel(0x85000000 | vidc.h_border_end);\r\nvidc_writel(0x86000000);\r\nvidc_writel(0x87000000 | vidc.h_interlace);\r\nvidc_writel(0x90000000 | vidc.v_cycle);\r\nvidc_writel(0x91000000 | vidc.v_sync_width);\r\nvidc_writel(0x92000000 | vidc.v_border_start);\r\nvidc_writel(0x93000000 | vidc.v_display_start);\r\nvidc_writel(0x94000000 | vidc.v_display_end);\r\nvidc_writel(0x95000000 | vidc.v_border_end);\r\nvidc_writel(0x96000000);\r\nvidc_writel(0x97000000);\r\n}\r\niomd_writel(fsize, IOMD_FSIZE);\r\next_ctl = acornfb_default_econtrol();\r\nif (var->sync & FB_SYNC_COMP_HIGH_ACT)\r\next_ctl |= VIDC20_ECTL_HS_NCSYNC | VIDC20_ECTL_VS_NCSYNC;\r\nelse {\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\next_ctl |= VIDC20_ECTL_HS_HSYNC;\r\nelse\r\next_ctl |= VIDC20_ECTL_HS_NHSYNC;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\next_ctl |= VIDC20_ECTL_VS_VSYNC;\r\nelse\r\next_ctl |= VIDC20_ECTL_VS_NVSYNC;\r\n}\r\nvidc_writel(VIDC20_ECTL | ext_ctl);\r\nwords_per_line = var->xres * var->bits_per_pixel / 32;\r\nif (current_par.using_vram && info->fix.smem_len == 2048*1024)\r\nwords_per_line /= 2;\r\ndat_ctl = VIDC20_DCTL_VRAM_DIS | VIDC20_DCTL_SNA | words_per_line;\r\nif (current_par.using_vram && current_par.vram_half_sam == 2048)\r\ndat_ctl |= VIDC20_DCTL_BUS_D63_0;\r\nelse\r\ndat_ctl |= VIDC20_DCTL_BUS_D31_0;\r\nvidc_writel(VIDC20_DCTL | dat_ctl);\r\n#ifdef DEBUG_MODE_SELECTION\r\nprintk(KERN_DEBUG "VIDC registers for %dx%dx%d:\n", var->xres,\r\nvar->yres, var->bits_per_pixel);\r\nprintk(KERN_DEBUG " H-cycle : %d\n", vidc.h_cycle);\r\nprintk(KERN_DEBUG " H-sync-width : %d\n", vidc.h_sync_width);\r\nprintk(KERN_DEBUG " H-border-start : %d\n", vidc.h_border_start);\r\nprintk(KERN_DEBUG " H-display-start : %d\n", vidc.h_display_start);\r\nprintk(KERN_DEBUG " H-display-end : %d\n", vidc.h_display_end);\r\nprintk(KERN_DEBUG " H-border-end : %d\n", vidc.h_border_end);\r\nprintk(KERN_DEBUG " H-interlace : %d\n", vidc.h_interlace);\r\nprintk(KERN_DEBUG " V-cycle : %d\n", vidc.v_cycle);\r\nprintk(KERN_DEBUG " V-sync-width : %d\n", vidc.v_sync_width);\r\nprintk(KERN_DEBUG " V-border-start : %d\n", vidc.v_border_start);\r\nprintk(KERN_DEBUG " V-display-start : %d\n", vidc.v_display_start);\r\nprintk(KERN_DEBUG " V-display-end : %d\n", vidc.v_display_end);\r\nprintk(KERN_DEBUG " V-border-end : %d\n", vidc.v_border_end);\r\nprintk(KERN_DEBUG " Ext Ctrl (C) : 0x%08X\n", ext_ctl);\r\nprintk(KERN_DEBUG " PLL Ctrl (D) : 0x%08X\n", vidc.pll_ctl);\r\nprintk(KERN_DEBUG " Ctrl (E) : 0x%08X\n", vidc.control);\r\nprintk(KERN_DEBUG " Data Ctrl (F) : 0x%08X\n", dat_ctl);\r\nprintk(KERN_DEBUG " Fsize : 0x%08X\n", fsize);\r\n#endif\r\n}\r\nstatic int\r\nacornfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nunion palette pal;\r\nif (regno >= current_par.palette_size)\r\nreturn 1;\r\nif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nu32 pseudo_val;\r\npseudo_val = regno << info->var.red.offset;\r\npseudo_val |= regno << info->var.green.offset;\r\npseudo_val |= regno << info->var.blue.offset;\r\n((u32 *)info->pseudo_palette)[regno] = pseudo_val;\r\n}\r\npal.p = 0;\r\npal.vidc20.red = red >> 8;\r\npal.vidc20.green = green >> 8;\r\npal.vidc20.blue = blue >> 8;\r\ncurrent_par.palette[regno] = pal;\r\nif (info->var.bits_per_pixel == 16) {\r\nint i;\r\npal.p = 0;\r\nvidc_writel(0x10000000);\r\nfor (i = 0; i < 256; i += 1) {\r\npal.vidc20.red = current_par.palette[ i & 31].vidc20.red;\r\npal.vidc20.green = current_par.palette[(i >> 1) & 31].vidc20.green;\r\npal.vidc20.blue = current_par.palette[(i >> 2) & 31].vidc20.blue;\r\nvidc_writel(pal.p);\r\n}\r\n} else {\r\nvidc_writel(0x10000000 | regno);\r\nvidc_writel(pal.p);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nacornfb_adjust_timing(struct fb_info *info, struct fb_var_screeninfo *var, u_int fontht)\r\n{\r\nu_int font_line_len, sam_size, min_size, size, nr_y;\r\nvar->xres = (var->xres + 1) & ~1;\r\nvar->xres_virtual = var->xres;\r\nvar->xoffset = 0;\r\nif (current_par.using_vram)\r\nsam_size = current_par.vram_half_sam * 2;\r\nelse\r\nsam_size = 16;\r\nfont_line_len = var->xres * var->bits_per_pixel * fontht / 8;\r\nmin_size = var->xres * var->yres * var->bits_per_pixel / 8;\r\nif (min_size > info->fix.smem_len)\r\nreturn -EINVAL;\r\nfor (size = info->fix.smem_len;\r\nnr_y = size / font_line_len, min_size <= size;\r\nsize -= sam_size) {\r\nif (nr_y * font_line_len == size)\r\nbreak;\r\n}\r\nnr_y *= fontht;\r\nif (var->accel_flags & FB_ACCELF_TEXT) {\r\nif (min_size > size) {\r\nsize = info->fix.smem_len;\r\nvar->yres_virtual = size / (font_line_len / fontht);\r\n} else\r\nvar->yres_virtual = nr_y;\r\n} else if (var->yres_virtual > nr_y)\r\nvar->yres_virtual = nr_y;\r\ncurrent_par.screen_end = info->fix.smem_start + size;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres = var->yres_virtual;\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual;\r\n} else {\r\nif (var->yoffset + var->yres > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\n}\r\nvar->hsync_len = (var->hsync_len + 1) & ~1;\r\n#if defined(HAS_VIDC20)\r\nif (var->left_margin & 1) {\r\nvar->left_margin += 1;\r\nvar->right_margin -= 1;\r\n}\r\nif (var->right_margin & 1)\r\nvar->right_margin += 1;\r\n#endif\r\nif (var->vsync_len < 1)\r\nvar->vsync_len = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nacornfb_validate_timing(struct fb_var_screeninfo *var,\r\nstruct fb_monspecs *monspecs)\r\n{\r\nunsigned long hs, vs;\r\nhs = 1953125000 / var->pixclock;\r\nhs = hs * 512 /\r\n(var->xres + var->left_margin + var->right_margin + var->hsync_len);\r\nvs = hs /\r\n(var->yres + var->upper_margin + var->lower_margin + var->vsync_len);\r\nreturn (vs >= monspecs->vfmin && vs <= monspecs->vfmax &&\r\nhs >= monspecs->hfmin && hs <= monspecs->hfmax) ? 0 : -EINVAL;\r\n}\r\nstatic inline void\r\nacornfb_update_dma(struct fb_info *info, struct fb_var_screeninfo *var)\r\n{\r\nu_int off = var->yoffset * info->fix.line_length;\r\n#if defined(HAS_MEMC)\r\nmemc_write(VDMA_INIT, off >> 2);\r\n#elif defined(HAS_IOMD)\r\niomd_writel(info->fix.smem_start + off, IOMD_VIDINIT);\r\n#endif\r\n}\r\nstatic int\r\nacornfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu_int fontht;\r\nint err;\r\nfontht = 8;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 1: case 2: case 4: case 8:\r\nvar->red.offset = 0;\r\nvar->red.length = var->bits_per_pixel;\r\nvar->green = var->red;\r\nvar->blue = var->red;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\n#ifdef HAS_VIDC20\r\ncase 16:\r\nvar->red.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 10;\r\nvar->blue.length = 5;\r\nvar->transp.offset = 15;\r\nvar->transp.length = 1;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.length = 4;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!acornfb_valid_pixrate(var))\r\nreturn -EINVAL;\r\nerr = acornfb_adjust_timing(info, var, fontht);\r\nif (err)\r\nreturn err;\r\nreturn acornfb_validate_timing(var, &info->monspecs);\r\n}\r\nstatic int acornfb_set_par(struct fb_info *info)\r\n{\r\nswitch (info->var.bits_per_pixel) {\r\ncase 1:\r\ncurrent_par.palette_size = 2;\r\ninfo->fix.visual = FB_VISUAL_MONO10;\r\nbreak;\r\ncase 2:\r\ncurrent_par.palette_size = 4;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 4:\r\ncurrent_par.palette_size = 16;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 8:\r\ncurrent_par.palette_size = VIDC_PALETTE_SIZE;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n#ifdef HAS_VIDC20\r\ncase 16:\r\ncurrent_par.palette_size = 32;\r\ninfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\r\nbreak;\r\ncase 32:\r\ncurrent_par.palette_size = VIDC_PALETTE_SIZE;\r\ninfo->fix.visual = FB_VISUAL_DIRECTCOLOR;\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\ninfo->fix.line_length = (info->var.xres * info->var.bits_per_pixel) / 8;\r\n#if defined(HAS_MEMC)\r\n{\r\nunsigned long size = info->fix.smem_len - VDMA_XFERSIZE;\r\nmemc_write(VDMA_START, 0);\r\nmemc_write(VDMA_END, size >> 2);\r\n}\r\n#elif defined(HAS_IOMD)\r\n{\r\nunsigned long start, size;\r\nu_int control;\r\nstart = info->fix.smem_start;\r\nsize = current_par.screen_end;\r\nif (current_par.using_vram) {\r\nsize -= current_par.vram_half_sam;\r\ncontrol = DMA_CR_E | (current_par.vram_half_sam / 256);\r\n} else {\r\nsize -= 16;\r\ncontrol = DMA_CR_E | DMA_CR_D | 16;\r\n}\r\niomd_writel(start, IOMD_VIDSTART);\r\niomd_writel(size, IOMD_VIDEND);\r\niomd_writel(control, IOMD_VIDCR);\r\n}\r\n#endif\r\nacornfb_update_dma(info, &info->var);\r\nacornfb_set_timing(info);\r\nreturn 0;\r\n}\r\nstatic int\r\nacornfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu_int y_bottom = var->yoffset;\r\nif (!(var->vmode & FB_VMODE_YWRAP))\r\ny_bottom += info->var.yres;\r\nif (y_bottom > info->var.yres_virtual)\r\nreturn -EINVAL;\r\nacornfb_update_dma(info, var);\r\nreturn 0;\r\n}\r\nstatic void acornfb_init_fbinfo(void)\r\n{\r\nstatic int first = 1;\r\nif (!first)\r\nreturn;\r\nfirst = 0;\r\nfb_info.fbops = &acornfb_ops;\r\nfb_info.flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nfb_info.pseudo_palette = current_par.pseudo_palette;\r\nstrcpy(fb_info.fix.id, "Acorn");\r\nfb_info.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb_info.fix.type_aux = 0;\r\nfb_info.fix.xpanstep = 0;\r\nfb_info.fix.ypanstep = 1;\r\nfb_info.fix.ywrapstep = 1;\r\nfb_info.fix.line_length = 0;\r\nfb_info.fix.accel = FB_ACCEL_NONE;\r\nmemset(&fb_info.var, 0, sizeof(fb_info.var));\r\n#if defined(HAS_VIDC20)\r\nfb_info.var.red.length = 8;\r\nfb_info.var.transp.length = 4;\r\n#endif\r\nfb_info.var.green = fb_info.var.red;\r\nfb_info.var.blue = fb_info.var.red;\r\nfb_info.var.nonstd = 0;\r\nfb_info.var.activate = FB_ACTIVATE_NOW;\r\nfb_info.var.height = -1;\r\nfb_info.var.width = -1;\r\nfb_info.var.vmode = FB_VMODE_NONINTERLACED;\r\nfb_info.var.accel_flags = FB_ACCELF_TEXT;\r\ncurrent_par.dram_size = 0;\r\ncurrent_par.montype = -1;\r\ncurrent_par.dpms = 0;\r\n}\r\nstatic void acornfb_parse_mon(char *opt)\r\n{\r\nchar *p = opt;\r\ncurrent_par.montype = -2;\r\nfb_info.monspecs.hfmin = simple_strtoul(p, &p, 0);\r\nif (*p == '-')\r\nfb_info.monspecs.hfmax = simple_strtoul(p + 1, &p, 0);\r\nelse\r\nfb_info.monspecs.hfmax = fb_info.monspecs.hfmin;\r\nif (*p != ':')\r\ngoto bad;\r\nfb_info.monspecs.vfmin = simple_strtoul(p + 1, &p, 0);\r\nif (*p == '-')\r\nfb_info.monspecs.vfmax = simple_strtoul(p + 1, &p, 0);\r\nelse\r\nfb_info.monspecs.vfmax = fb_info.monspecs.vfmin;\r\nif (*p != ':')\r\ngoto check_values;\r\nfb_info.monspecs.dpms = simple_strtoul(p + 1, &p, 0);\r\nif (*p != ':')\r\ngoto check_values;\r\nfb_info.var.width = simple_strtoul(p + 1, &p, 0);\r\nif (*p != ':')\r\ngoto check_values;\r\nfb_info.var.height = simple_strtoul(p + 1, NULL, 0);\r\ncheck_values:\r\nif (fb_info.monspecs.hfmax < fb_info.monspecs.hfmin ||\r\nfb_info.monspecs.vfmax < fb_info.monspecs.vfmin)\r\ngoto bad;\r\nreturn;\r\nbad:\r\nprintk(KERN_ERR "Acornfb: bad monitor settings: %s\n", opt);\r\ncurrent_par.montype = -1;\r\n}\r\nstatic void acornfb_parse_montype(char *opt)\r\n{\r\ncurrent_par.montype = -2;\r\nif (strncmp(opt, "tv", 2) == 0) {\r\nopt += 2;\r\ncurrent_par.montype = 0;\r\n} else if (strncmp(opt, "multi", 5) == 0) {\r\nopt += 5;\r\ncurrent_par.montype = 1;\r\n} else if (strncmp(opt, "hires", 5) == 0) {\r\nopt += 5;\r\ncurrent_par.montype = 2;\r\n} else if (strncmp(opt, "vga", 3) == 0) {\r\nopt += 3;\r\ncurrent_par.montype = 3;\r\n} else if (strncmp(opt, "svga", 4) == 0) {\r\nopt += 4;\r\ncurrent_par.montype = 4;\r\n} else if (strncmp(opt, "auto", 4) == 0) {\r\nopt += 4;\r\ncurrent_par.montype = -1;\r\n} else if (isdigit(*opt))\r\ncurrent_par.montype = simple_strtoul(opt, &opt, 0);\r\nif (current_par.montype == -2 ||\r\ncurrent_par.montype > NR_MONTYPES) {\r\nprintk(KERN_ERR "acornfb: unknown monitor type: %s\n",\r\nopt);\r\ncurrent_par.montype = -1;\r\n} else\r\nif (opt && *opt) {\r\nif (strcmp(opt, ",dpms") == 0)\r\ncurrent_par.dpms = 1;\r\nelse\r\nprintk(KERN_ERR\r\n"acornfb: unknown monitor option: %s\n",\r\nopt);\r\n}\r\n}\r\nstatic void acornfb_parse_dram(char *opt)\r\n{\r\nunsigned int size;\r\nsize = simple_strtoul(opt, &opt, 0);\r\nif (opt) {\r\nswitch (*opt) {\r\ncase 'M':\r\ncase 'm':\r\nsize *= 1024;\r\ncase 'K':\r\ncase 'k':\r\nsize *= 1024;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncurrent_par.dram_size = size;\r\n}\r\nstatic int acornfb_setup(char *options)\r\n{\r\nstruct options *optp;\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nacornfb_init_fbinfo();\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nfor (optp = opt_table; optp->name; optp++) {\r\nint optlen;\r\noptlen = strlen(optp->name);\r\nif (strncmp(opt, optp->name, optlen) == 0 &&\r\nopt[optlen] == ':') {\r\noptp->parse(opt + optlen + 1);\r\nbreak;\r\n}\r\n}\r\nif (!optp->name)\r\nprintk(KERN_ERR "acornfb: unknown parameter: %s\n",\r\nopt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acornfb_detect_monitortype(void)\r\n{\r\nreturn 4;\r\n}\r\nstatic inline void\r\nfree_unused_pages(unsigned int virtual_start, unsigned int virtual_end)\r\n{\r\nint mb_freed = 0;\r\nvirtual_start = PAGE_ALIGN(virtual_start);\r\nvirtual_end = PAGE_ALIGN(virtual_end);\r\nwhile (virtual_start < virtual_end) {\r\nstruct page *page;\r\npage = virt_to_page(virtual_start);\r\n__free_reserved_page(page);\r\nvirtual_start += PAGE_SIZE;\r\nmb_freed += PAGE_SIZE / 1024;\r\n}\r\nprintk("acornfb: freed %dK memory\n", mb_freed);\r\n}\r\nstatic int acornfb_probe(struct platform_device *dev)\r\n{\r\nunsigned long size;\r\nu_int h_sync, v_sync;\r\nint rc, i;\r\nchar *option = NULL;\r\nif (fb_get_options("acornfb", &option))\r\nreturn -ENODEV;\r\nacornfb_setup(option);\r\nacornfb_init_fbinfo();\r\ncurrent_par.dev = &dev->dev;\r\nif (current_par.montype == -1)\r\ncurrent_par.montype = acornfb_detect_monitortype();\r\nif (current_par.montype == -1 || current_par.montype > NR_MONTYPES)\r\ncurrent_par.montype = 4;\r\nif (current_par.montype >= 0) {\r\nfb_info.monspecs = monspecs[current_par.montype];\r\nfb_info.monspecs.dpms = current_par.dpms;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(modedb); i++) {\r\nunsigned long hs;\r\nhs = modedb[i].refresh *\r\n(modedb[i].yres + modedb[i].upper_margin +\r\nmodedb[i].lower_margin + modedb[i].vsync_len);\r\nif (modedb[i].xres == DEFAULT_XRES &&\r\nmodedb[i].yres == DEFAULT_YRES &&\r\nmodedb[i].refresh >= fb_info.monspecs.vfmin &&\r\nmodedb[i].refresh <= fb_info.monspecs.vfmax &&\r\nhs >= fb_info.monspecs.hfmin &&\r\nhs <= fb_info.monspecs.hfmax) {\r\nacornfb_default_mode = modedb[i];\r\nbreak;\r\n}\r\n}\r\nfb_info.screen_base = (char *)SCREEN_BASE;\r\nfb_info.fix.smem_start = SCREEN_START;\r\ncurrent_par.using_vram = 0;\r\nif (vram_size && !current_par.dram_size) {\r\nsize = vram_size;\r\ncurrent_par.vram_half_sam = vram_size / 1024;\r\ncurrent_par.using_vram = 1;\r\n} else if (current_par.dram_size)\r\nsize = current_par.dram_size;\r\nelse\r\nsize = MAX_SIZE;\r\nif (size > MAX_SIZE)\r\nsize = MAX_SIZE;\r\nsize = PAGE_ALIGN(size);\r\n#if defined(HAS_VIDC20)\r\nif (!current_par.using_vram) {\r\ndma_addr_t handle;\r\nvoid *base;\r\nbase = dma_alloc_wc(current_par.dev, size, &handle,\r\nGFP_KERNEL);\r\nif (base == NULL) {\r\nprintk(KERN_ERR "acornfb: unable to allocate screen "\r\n"memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfb_info.screen_base = base;\r\nfb_info.fix.smem_start = handle;\r\n}\r\n#endif\r\nfb_info.fix.smem_len = size;\r\ncurrent_par.palette_size = VIDC_PALETTE_SIZE;\r\ndo {\r\nrc = fb_find_mode(&fb_info.var, &fb_info, NULL, modedb,\r\nARRAY_SIZE(modedb),\r\n&acornfb_default_mode, DEFAULT_BPP);\r\nif (rc == 1)\r\nbreak;\r\nrc = fb_find_mode(&fb_info.var, &fb_info, NULL, NULL, 0,\r\n&acornfb_default_mode, DEFAULT_BPP);\r\nif (rc == 1)\r\nbreak;\r\nrc = fb_find_mode(&fb_info.var, &fb_info, NULL, modedb,\r\nARRAY_SIZE(modedb),\r\n&acornfb_default_mode, DEFAULT_BPP);\r\nif (rc)\r\nbreak;\r\nrc = fb_find_mode(&fb_info.var, &fb_info, NULL, NULL, 0,\r\n&acornfb_default_mode, DEFAULT_BPP);\r\n} while (0);\r\nif (rc == 0) {\r\nprintk("Acornfb: no valid mode found\n");\r\nreturn -EINVAL;\r\n}\r\nh_sync = 1953125000 / fb_info.var.pixclock;\r\nh_sync = h_sync * 512 / (fb_info.var.xres + fb_info.var.left_margin +\r\nfb_info.var.right_margin + fb_info.var.hsync_len);\r\nv_sync = h_sync / (fb_info.var.yres + fb_info.var.upper_margin +\r\nfb_info.var.lower_margin + fb_info.var.vsync_len);\r\nprintk(KERN_INFO "Acornfb: %dkB %cRAM, %s, using %dx%d, "\r\n"%d.%03dkHz, %dHz\n",\r\nfb_info.fix.smem_len / 1024,\r\ncurrent_par.using_vram ? 'V' : 'D',\r\nVIDC_NAME, fb_info.var.xres, fb_info.var.yres,\r\nh_sync / 1000, h_sync % 1000, v_sync);\r\nprintk(KERN_INFO "Acornfb: Monitor: %d.%03d-%d.%03dkHz, %d-%dHz%s\n",\r\nfb_info.monspecs.hfmin / 1000, fb_info.monspecs.hfmin % 1000,\r\nfb_info.monspecs.hfmax / 1000, fb_info.monspecs.hfmax % 1000,\r\nfb_info.monspecs.vfmin, fb_info.monspecs.vfmax,\r\nfb_info.monspecs.dpms ? ", DPMS" : "");\r\nif (fb_set_var(&fb_info, &fb_info.var))\r\nprintk(KERN_ERR "Acornfb: unable to set display parameters\n");\r\nif (register_framebuffer(&fb_info) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init acornfb_init(void)\r\n{\r\nreturn platform_driver_register(&acornfb_driver);\r\n}
