static int bcm63xx_detect_cfe(struct mtd_info *master)\r\n{\r\nchar buf[9];\r\nint ret;\r\nsize_t retlen;\r\nret = mtd_read(master, BCM963XX_CFE_VERSION_OFFSET, 5, &retlen,\r\n(void *)buf);\r\nbuf[retlen] = 0;\r\nif (ret)\r\nreturn ret;\r\nif (strncmp("cfe-v", buf, 5) == 0)\r\nreturn 0;\r\nret = mtd_read(master, BCM963XX_CFE_MAGIC_OFFSET, 8, &retlen,\r\n(void *)buf);\r\nbuf[retlen] = 0;\r\nreturn strncmp("CFE1CFE1", buf, 8);\r\n}\r\nstatic int bcm63xx_read_nvram(struct mtd_info *master,\r\nstruct bcm963xx_nvram *nvram)\r\n{\r\nu32 actual_crc, expected_crc;\r\nsize_t retlen;\r\nint ret;\r\nret = mtd_read(master, BCM963XX_NVRAM_OFFSET, BCM963XX_NVRAM_V5_SIZE,\r\n&retlen, (void *)nvram);\r\nif (ret)\r\nreturn ret;\r\nret = bcm963xx_nvram_checksum(nvram, &expected_crc, &actual_crc);\r\nif (ret)\r\npr_warn("nvram checksum failed, contents may be invalid (expected %08x, got %08x)\n",\r\nexpected_crc, actual_crc);\r\nif (!nvram->psi_size)\r\nnvram->psi_size = BCM963XX_DEFAULT_PSI_SIZE;\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_read_image_tag(struct mtd_info *master, const char *name,\r\nloff_t tag_offset, struct bcm_tag *buf)\r\n{\r\nint ret;\r\nsize_t retlen;\r\nu32 computed_crc;\r\nret = mtd_read(master, tag_offset, sizeof(*buf), &retlen, (void *)buf);\r\nif (ret)\r\nreturn ret;\r\nif (retlen != sizeof(*buf))\r\nreturn -EIO;\r\ncomputed_crc = crc32_le(IMAGETAG_CRC_START, (u8 *)buf,\r\noffsetof(struct bcm_tag, header_crc));\r\nif (computed_crc == buf->header_crc) {\r\nSTR_NULL_TERMINATE(buf->board_id);\r\nSTR_NULL_TERMINATE(buf->tag_version);\r\npr_info("%s: CFE image tag found at 0x%llx with version %s, board type %s\n",\r\nname, tag_offset, buf->tag_version, buf->board_id);\r\nreturn 0;\r\n}\r\npr_warn("%s: CFE image tag at 0x%llx CRC invalid (expected %08x, actual %08x)\n",\r\nname, tag_offset, buf->header_crc, computed_crc);\r\nreturn 1;\r\n}\r\nstatic int bcm63xx_parse_cfe_nor_partitions(struct mtd_info *master,\r\nconst struct mtd_partition **pparts, struct bcm963xx_nvram *nvram)\r\n{\r\nint nrparts = 3, curpart = 0;\r\nstruct bcm_tag *buf = NULL;\r\nstruct mtd_partition *parts;\r\nint ret;\r\nunsigned int rootfsaddr, kerneladdr, spareaddr;\r\nunsigned int rootfslen, kernellen, sparelen, totallen;\r\nunsigned int cfelen, nvramlen;\r\nunsigned int cfe_erasesize;\r\nint i;\r\nbool rootfs_first = false;\r\ncfe_erasesize = max_t(uint32_t, master->erasesize,\r\nBCM963XX_CFE_BLOCK_SIZE);\r\ncfelen = cfe_erasesize;\r\nnvramlen = nvram->psi_size * SZ_1K;\r\nnvramlen = roundup(nvramlen, cfe_erasesize);\r\nbuf = vmalloc(sizeof(struct bcm_tag));\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = bcm63xx_read_image_tag(master, "rootfs", cfelen, buf);\r\nif (!ret) {\r\nSTR_NULL_TERMINATE(buf->flash_image_start);\r\nif (kstrtouint(buf->flash_image_start, 10, &rootfsaddr) ||\r\nrootfsaddr < BCM963XX_EXTENDED_SIZE) {\r\npr_err("invalid rootfs address: %*ph\n",\r\n(int)sizeof(buf->flash_image_start),\r\nbuf->flash_image_start);\r\ngoto invalid_tag;\r\n}\r\nSTR_NULL_TERMINATE(buf->kernel_address);\r\nif (kstrtouint(buf->kernel_address, 10, &kerneladdr) ||\r\nkerneladdr < BCM963XX_EXTENDED_SIZE) {\r\npr_err("invalid kernel address: %*ph\n",\r\n(int)sizeof(buf->kernel_address),\r\nbuf->kernel_address);\r\ngoto invalid_tag;\r\n}\r\nSTR_NULL_TERMINATE(buf->kernel_length);\r\nif (kstrtouint(buf->kernel_length, 10, &kernellen)) {\r\npr_err("invalid kernel length: %*ph\n",\r\n(int)sizeof(buf->kernel_length),\r\nbuf->kernel_length);\r\ngoto invalid_tag;\r\n}\r\nSTR_NULL_TERMINATE(buf->total_length);\r\nif (kstrtouint(buf->total_length, 10, &totallen)) {\r\npr_err("invalid total length: %*ph\n",\r\n(int)sizeof(buf->total_length),\r\nbuf->total_length);\r\ngoto invalid_tag;\r\n}\r\nkerneladdr = kerneladdr - BCM963XX_EXTENDED_SIZE;\r\nrootfsaddr = rootfsaddr - BCM963XX_EXTENDED_SIZE;\r\nspareaddr = roundup(totallen, master->erasesize) + cfelen;\r\nif (rootfsaddr < kerneladdr) {\r\nrootfslen = kerneladdr - rootfsaddr;\r\nrootfs_first = true;\r\n} else {\r\nrootfsaddr = kerneladdr + kernellen;\r\nrootfslen = spareaddr - rootfsaddr;\r\n}\r\n} else if (ret > 0) {\r\ninvalid_tag:\r\nkernellen = 0;\r\nrootfslen = 0;\r\nrootfsaddr = 0;\r\nspareaddr = cfelen;\r\n} else {\r\ngoto out;\r\n}\r\nsparelen = master->size - spareaddr - nvramlen;\r\nif (rootfslen > 0)\r\nnrparts++;\r\nif (kernellen > 0)\r\nnrparts++;\r\nparts = kzalloc(sizeof(*parts) * nrparts + 10 * nrparts, GFP_KERNEL);\r\nif (!parts) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nparts[curpart].name = "CFE";\r\nparts[curpart].offset = 0;\r\nparts[curpart].size = cfelen;\r\ncurpart++;\r\nif (kernellen > 0) {\r\nint kernelpart = curpart;\r\nif (rootfslen > 0 && rootfs_first)\r\nkernelpart++;\r\nparts[kernelpart].name = "kernel";\r\nparts[kernelpart].offset = kerneladdr;\r\nparts[kernelpart].size = kernellen;\r\ncurpart++;\r\n}\r\nif (rootfslen > 0) {\r\nint rootfspart = curpart;\r\nif (kernellen > 0 && rootfs_first)\r\nrootfspart--;\r\nparts[rootfspart].name = "rootfs";\r\nparts[rootfspart].offset = rootfsaddr;\r\nparts[rootfspart].size = rootfslen;\r\nif (sparelen > 0 && !rootfs_first)\r\nparts[rootfspart].size += sparelen;\r\ncurpart++;\r\n}\r\nparts[curpart].name = "nvram";\r\nparts[curpart].offset = master->size - nvramlen;\r\nparts[curpart].size = nvramlen;\r\ncurpart++;\r\nparts[curpart].name = "linux";\r\nparts[curpart].offset = cfelen;\r\nparts[curpart].size = master->size - cfelen - nvramlen;\r\nfor (i = 0; i < nrparts; i++)\r\npr_info("Partition %d is %s offset %llx and length %llx\n", i,\r\nparts[i].name, parts[i].offset, parts[i].size);\r\npr_info("Spare partition is offset %x and length %x\n", spareaddr,\r\nsparelen);\r\n*pparts = parts;\r\nret = 0;\r\nout:\r\nvfree(buf);\r\nif (ret)\r\nreturn ret;\r\nreturn nrparts;\r\n}\r\nstatic int bcm63xx_parse_cfe_partitions(struct mtd_info *master,\r\nconst struct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct bcm963xx_nvram *nvram = NULL;\r\nint ret;\r\nif (bcm63xx_detect_cfe(master))\r\nreturn -EINVAL;\r\nnvram = vzalloc(sizeof(*nvram));\r\nif (!nvram)\r\nreturn -ENOMEM;\r\nret = bcm63xx_read_nvram(master, nvram);\r\nif (ret)\r\ngoto out;\r\nif (!mtd_type_is_nand(master))\r\nret = bcm63xx_parse_cfe_nor_partitions(master, pparts, nvram);\r\nelse\r\nret = -EINVAL;\r\nout:\r\nvfree(nvram);\r\nreturn ret;\r\n}
