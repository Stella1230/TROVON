static void tegra_kbc_report_released_keys(struct input_dev *input,\r\nunsigned short old_keycodes[],\r\nunsigned int old_num_keys,\r\nunsigned short new_keycodes[],\r\nunsigned int new_num_keys)\r\n{\r\nunsigned int i, j;\r\nfor (i = 0; i < old_num_keys; i++) {\r\nfor (j = 0; j < new_num_keys; j++)\r\nif (old_keycodes[i] == new_keycodes[j])\r\nbreak;\r\nif (j == new_num_keys)\r\ninput_report_key(input, old_keycodes[i], 0);\r\n}\r\n}\r\nstatic void tegra_kbc_report_pressed_keys(struct input_dev *input,\r\nunsigned char scancodes[],\r\nunsigned short keycodes[],\r\nunsigned int num_pressed_keys)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_pressed_keys; i++) {\r\ninput_event(input, EV_MSC, MSC_SCAN, scancodes[i]);\r\ninput_report_key(input, keycodes[i], 1);\r\n}\r\n}\r\nstatic void tegra_kbc_report_keys(struct tegra_kbc *kbc)\r\n{\r\nunsigned char scancodes[KBC_MAX_KPENT];\r\nunsigned short keycodes[KBC_MAX_KPENT];\r\nu32 val = 0;\r\nunsigned int i;\r\nunsigned int num_down = 0;\r\nbool fn_keypress = false;\r\nbool key_in_same_row = false;\r\nbool key_in_same_col = false;\r\nfor (i = 0; i < KBC_MAX_KPENT; i++) {\r\nif ((i % 4) == 0)\r\nval = readl(kbc->mmio + KBC_KP_ENT0_0 + i);\r\nif (val & 0x80) {\r\nunsigned int col = val & 0x07;\r\nunsigned int row = (val >> 3) & 0x0f;\r\nunsigned char scancode =\r\nMATRIX_SCAN_CODE(row, col, KBC_ROW_SHIFT);\r\nscancodes[num_down] = scancode;\r\nkeycodes[num_down] = kbc->keycode[scancode];\r\nif ((keycodes[num_down] == KEY_FN) && kbc->use_fn_map)\r\nfn_keypress = true;\r\nelse\r\nnum_down++;\r\n}\r\nval >>= 8;\r\n}\r\nif (kbc->use_ghost_filter && num_down >= 3) {\r\nfor (i = 0; i < num_down; i++) {\r\nunsigned int j;\r\nu8 curr_col = scancodes[i] & 0x07;\r\nu8 curr_row = scancodes[i] >> KBC_ROW_SHIFT;\r\nfor (j = i + 1; j < num_down; j++) {\r\nu8 col = scancodes[j] & 0x07;\r\nu8 row = scancodes[j] >> KBC_ROW_SHIFT;\r\nif (col == curr_col)\r\nkey_in_same_col = true;\r\nif (row == curr_row)\r\nkey_in_same_row = true;\r\n}\r\n}\r\n}\r\nif (fn_keypress) {\r\nfor (i = 0; i < num_down; i++) {\r\nscancodes[i] += kbc->max_keys;\r\nkeycodes[i] = kbc->keycode[scancodes[i]];\r\n}\r\n}\r\nif (key_in_same_col && key_in_same_row)\r\nreturn;\r\ntegra_kbc_report_released_keys(kbc->idev,\r\nkbc->current_keys, kbc->num_pressed_keys,\r\nkeycodes, num_down);\r\ntegra_kbc_report_pressed_keys(kbc->idev, scancodes, keycodes, num_down);\r\ninput_sync(kbc->idev);\r\nmemcpy(kbc->current_keys, keycodes, sizeof(kbc->current_keys));\r\nkbc->num_pressed_keys = num_down;\r\n}\r\nstatic void tegra_kbc_set_fifo_interrupt(struct tegra_kbc *kbc, bool enable)\r\n{\r\nu32 val;\r\nval = readl(kbc->mmio + KBC_CONTROL_0);\r\nif (enable)\r\nval |= KBC_CONTROL_FIFO_CNT_INT_EN;\r\nelse\r\nval &= ~KBC_CONTROL_FIFO_CNT_INT_EN;\r\nwritel(val, kbc->mmio + KBC_CONTROL_0);\r\n}\r\nstatic void tegra_kbc_keypress_timer(unsigned long data)\r\n{\r\nstruct tegra_kbc *kbc = (struct tegra_kbc *)data;\r\nunsigned long flags;\r\nu32 val;\r\nunsigned int i;\r\nspin_lock_irqsave(&kbc->lock, flags);\r\nval = (readl(kbc->mmio + KBC_INT_0) >> 4) & 0xf;\r\nif (val) {\r\nunsigned long dly;\r\ntegra_kbc_report_keys(kbc);\r\ndly = (val == 1) ? kbc->repoll_dly : 1;\r\nmod_timer(&kbc->timer, jiffies + msecs_to_jiffies(dly));\r\n} else {\r\nfor (i = 0; i < kbc->num_pressed_keys; i++)\r\ninput_report_key(kbc->idev, kbc->current_keys[i], 0);\r\ninput_sync(kbc->idev);\r\nkbc->num_pressed_keys = 0;\r\ntegra_kbc_set_fifo_interrupt(kbc, true);\r\n}\r\nspin_unlock_irqrestore(&kbc->lock, flags);\r\n}\r\nstatic irqreturn_t tegra_kbc_isr(int irq, void *args)\r\n{\r\nstruct tegra_kbc *kbc = args;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&kbc->lock, flags);\r\nval = readl(kbc->mmio + KBC_INT_0);\r\nwritel(val, kbc->mmio + KBC_INT_0);\r\nif (val & KBC_INT_FIFO_CNT_INT_STATUS) {\r\ntegra_kbc_set_fifo_interrupt(kbc, false);\r\nmod_timer(&kbc->timer, jiffies + kbc->cp_dly_jiffies);\r\n} else if (val & KBC_INT_KEYPRESS_INT_STATUS) {\r\nkbc->keypress_caused_wake = true;\r\n}\r\nspin_unlock_irqrestore(&kbc->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tegra_kbc_setup_wakekeys(struct tegra_kbc *kbc, bool filter)\r\n{\r\nint i;\r\nunsigned int rst_val;\r\nrst_val = (filter && !kbc->wakeup) ? ~0 : 0;\r\nfor (i = 0; i < kbc->hw_support->max_rows; i++)\r\nwritel(rst_val, kbc->mmio + KBC_ROW0_MASK_0 + i * 4);\r\n}\r\nstatic void tegra_kbc_config_pins(struct tegra_kbc *kbc)\r\n{\r\nint i;\r\nfor (i = 0; i < KBC_MAX_GPIO; i++) {\r\nu32 r_shft = 5 * (i % 6);\r\nu32 c_shft = 4 * (i % 8);\r\nu32 r_mask = 0x1f << r_shft;\r\nu32 c_mask = 0x0f << c_shft;\r\nu32 r_offs = (i / 6) * 4 + KBC_ROW_CFG0_0;\r\nu32 c_offs = (i / 8) * 4 + KBC_COL_CFG0_0;\r\nu32 row_cfg = readl(kbc->mmio + r_offs);\r\nu32 col_cfg = readl(kbc->mmio + c_offs);\r\nrow_cfg &= ~r_mask;\r\ncol_cfg &= ~c_mask;\r\nswitch (kbc->pin_cfg[i].type) {\r\ncase PIN_CFG_ROW:\r\nrow_cfg |= ((kbc->pin_cfg[i].num << 1) | 1) << r_shft;\r\nbreak;\r\ncase PIN_CFG_COL:\r\ncol_cfg |= ((kbc->pin_cfg[i].num << 1) | 1) << c_shft;\r\nbreak;\r\ncase PIN_CFG_IGNORE:\r\nbreak;\r\n}\r\nwritel(row_cfg, kbc->mmio + r_offs);\r\nwritel(col_cfg, kbc->mmio + c_offs);\r\n}\r\n}\r\nstatic int tegra_kbc_start(struct tegra_kbc *kbc)\r\n{\r\nunsigned int debounce_cnt;\r\nu32 val = 0;\r\nclk_prepare_enable(kbc->clk);\r\nreset_control_assert(kbc->rst);\r\nudelay(100);\r\nreset_control_deassert(kbc->rst);\r\nudelay(100);\r\ntegra_kbc_config_pins(kbc);\r\ntegra_kbc_setup_wakekeys(kbc, false);\r\nwritel(kbc->repeat_cnt, kbc->mmio + KBC_RPT_DLY_0);\r\ndebounce_cnt = min(kbc->debounce_cnt, KBC_MAX_DEBOUNCE_CNT);\r\nval = KBC_DEBOUNCE_CNT_SHIFT(debounce_cnt);\r\nval |= KBC_FIFO_TH_CNT_SHIFT(1);\r\nval |= KBC_CONTROL_FIFO_CNT_INT_EN;\r\nval |= KBC_CONTROL_KBC_EN;\r\nwritel(val, kbc->mmio + KBC_CONTROL_0);\r\nval = readl(kbc->mmio + KBC_INIT_DLY_0);\r\nkbc->cp_dly_jiffies = usecs_to_jiffies((val & 0xfffff) * 32);\r\nkbc->num_pressed_keys = 0;\r\nwhile (1) {\r\nval = readl(kbc->mmio + KBC_INT_0);\r\nval >>= 4;\r\nif (!val)\r\nbreak;\r\nval = readl(kbc->mmio + KBC_KP_ENT0_0);\r\nval = readl(kbc->mmio + KBC_KP_ENT1_0);\r\n}\r\nwritel(0x7, kbc->mmio + KBC_INT_0);\r\nenable_irq(kbc->irq);\r\nreturn 0;\r\n}\r\nstatic void tegra_kbc_stop(struct tegra_kbc *kbc)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&kbc->lock, flags);\r\nval = readl(kbc->mmio + KBC_CONTROL_0);\r\nval &= ~1;\r\nwritel(val, kbc->mmio + KBC_CONTROL_0);\r\nspin_unlock_irqrestore(&kbc->lock, flags);\r\ndisable_irq(kbc->irq);\r\ndel_timer_sync(&kbc->timer);\r\nclk_disable_unprepare(kbc->clk);\r\n}\r\nstatic int tegra_kbc_open(struct input_dev *dev)\r\n{\r\nstruct tegra_kbc *kbc = input_get_drvdata(dev);\r\nreturn tegra_kbc_start(kbc);\r\n}\r\nstatic void tegra_kbc_close(struct input_dev *dev)\r\n{\r\nstruct tegra_kbc *kbc = input_get_drvdata(dev);\r\nreturn tegra_kbc_stop(kbc);\r\n}\r\nstatic bool tegra_kbc_check_pin_cfg(const struct tegra_kbc *kbc,\r\nunsigned int *num_rows)\r\n{\r\nint i;\r\n*num_rows = 0;\r\nfor (i = 0; i < KBC_MAX_GPIO; i++) {\r\nconst struct tegra_kbc_pin_cfg *pin_cfg = &kbc->pin_cfg[i];\r\nswitch (pin_cfg->type) {\r\ncase PIN_CFG_ROW:\r\nif (pin_cfg->num >= kbc->hw_support->max_rows) {\r\ndev_err(kbc->dev,\r\n"pin_cfg[%d]: invalid row number %d\n",\r\ni, pin_cfg->num);\r\nreturn false;\r\n}\r\n(*num_rows)++;\r\nbreak;\r\ncase PIN_CFG_COL:\r\nif (pin_cfg->num >= kbc->hw_support->max_columns) {\r\ndev_err(kbc->dev,\r\n"pin_cfg[%d]: invalid column number %d\n",\r\ni, pin_cfg->num);\r\nreturn false;\r\n}\r\nbreak;\r\ncase PIN_CFG_IGNORE:\r\nbreak;\r\ndefault:\r\ndev_err(kbc->dev,\r\n"pin_cfg[%d]: invalid entry type %d\n",\r\npin_cfg->type, pin_cfg->num);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int tegra_kbc_parse_dt(struct tegra_kbc *kbc)\r\n{\r\nstruct device_node *np = kbc->dev->of_node;\r\nu32 prop;\r\nint i;\r\nu32 num_rows = 0;\r\nu32 num_cols = 0;\r\nu32 cols_cfg[KBC_MAX_GPIO];\r\nu32 rows_cfg[KBC_MAX_GPIO];\r\nint proplen;\r\nint ret;\r\nif (!of_property_read_u32(np, "nvidia,debounce-delay-ms", &prop))\r\nkbc->debounce_cnt = prop;\r\nif (!of_property_read_u32(np, "nvidia,repeat-delay-ms", &prop))\r\nkbc->repeat_cnt = prop;\r\nif (of_find_property(np, "nvidia,needs-ghost-filter", NULL))\r\nkbc->use_ghost_filter = true;\r\nif (of_property_read_bool(np, "wakeup-source") ||\r\nof_property_read_bool(np, "nvidia,wakeup-source"))\r\nkbc->wakeup = true;\r\nif (!of_get_property(np, "nvidia,kbc-row-pins", &proplen)) {\r\ndev_err(kbc->dev, "property nvidia,kbc-row-pins not found\n");\r\nreturn -ENOENT;\r\n}\r\nnum_rows = proplen / sizeof(u32);\r\nif (!of_get_property(np, "nvidia,kbc-col-pins", &proplen)) {\r\ndev_err(kbc->dev, "property nvidia,kbc-col-pins not found\n");\r\nreturn -ENOENT;\r\n}\r\nnum_cols = proplen / sizeof(u32);\r\nif (num_rows > kbc->hw_support->max_rows) {\r\ndev_err(kbc->dev,\r\n"Number of rows is more than supported by hardware\n");\r\nreturn -EINVAL;\r\n}\r\nif (num_cols > kbc->hw_support->max_columns) {\r\ndev_err(kbc->dev,\r\n"Number of cols is more than supported by hardware\n");\r\nreturn -EINVAL;\r\n}\r\nif (!of_get_property(np, "linux,keymap", &proplen)) {\r\ndev_err(kbc->dev, "property linux,keymap not found\n");\r\nreturn -ENOENT;\r\n}\r\nif (!num_rows || !num_cols || ((num_rows + num_cols) > KBC_MAX_GPIO)) {\r\ndev_err(kbc->dev,\r\n"keypad rows/columns not properly specified\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < kbc->num_rows_and_columns; i++)\r\nkbc->pin_cfg[i].type = PIN_CFG_IGNORE;\r\nret = of_property_read_u32_array(np, "nvidia,kbc-row-pins",\r\nrows_cfg, num_rows);\r\nif (ret < 0) {\r\ndev_err(kbc->dev, "Rows configurations are not proper\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_array(np, "nvidia,kbc-col-pins",\r\ncols_cfg, num_cols);\r\nif (ret < 0) {\r\ndev_err(kbc->dev, "Cols configurations are not proper\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_rows; i++) {\r\nkbc->pin_cfg[rows_cfg[i]].type = PIN_CFG_ROW;\r\nkbc->pin_cfg[rows_cfg[i]].num = i;\r\n}\r\nfor (i = 0; i < num_cols; i++) {\r\nkbc->pin_cfg[cols_cfg[i]].type = PIN_CFG_COL;\r\nkbc->pin_cfg[cols_cfg[i]].num = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_kbc_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_kbc *kbc;\r\nstruct resource *res;\r\nint err;\r\nint num_rows = 0;\r\nunsigned int debounce_cnt;\r\nunsigned int scan_time_rows;\r\nunsigned int keymap_rows;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(tegra_kbc_of_match, &pdev->dev);\r\nkbc = devm_kzalloc(&pdev->dev, sizeof(*kbc), GFP_KERNEL);\r\nif (!kbc) {\r\ndev_err(&pdev->dev, "failed to alloc memory for kbc\n");\r\nreturn -ENOMEM;\r\n}\r\nkbc->dev = &pdev->dev;\r\nkbc->hw_support = match->data;\r\nkbc->max_keys = kbc->hw_support->max_rows *\r\nkbc->hw_support->max_columns;\r\nkbc->num_rows_and_columns = kbc->hw_support->max_rows +\r\nkbc->hw_support->max_columns;\r\nkeymap_rows = kbc->max_keys;\r\nspin_lock_init(&kbc->lock);\r\nerr = tegra_kbc_parse_dt(kbc);\r\nif (err)\r\nreturn err;\r\nif (!tegra_kbc_check_pin_cfg(kbc, &num_rows))\r\nreturn -EINVAL;\r\nkbc->irq = platform_get_irq(pdev, 0);\r\nif (kbc->irq < 0) {\r\ndev_err(&pdev->dev, "failed to get keyboard IRQ\n");\r\nreturn -ENXIO;\r\n}\r\nkbc->idev = devm_input_allocate_device(&pdev->dev);\r\nif (!kbc->idev) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nsetup_timer(&kbc->timer, tegra_kbc_keypress_timer, (unsigned long)kbc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkbc->mmio = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(kbc->mmio))\r\nreturn PTR_ERR(kbc->mmio);\r\nkbc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kbc->clk)) {\r\ndev_err(&pdev->dev, "failed to get keyboard clock\n");\r\nreturn PTR_ERR(kbc->clk);\r\n}\r\nkbc->rst = devm_reset_control_get(&pdev->dev, "kbc");\r\nif (IS_ERR(kbc->rst)) {\r\ndev_err(&pdev->dev, "failed to get keyboard reset\n");\r\nreturn PTR_ERR(kbc->rst);\r\n}\r\ndebounce_cnt = min(kbc->debounce_cnt, KBC_MAX_DEBOUNCE_CNT);\r\nscan_time_rows = (KBC_ROW_SCAN_TIME + debounce_cnt) * num_rows;\r\nkbc->repoll_dly = KBC_ROW_SCAN_DLY + scan_time_rows + kbc->repeat_cnt;\r\nkbc->repoll_dly = DIV_ROUND_UP(kbc->repoll_dly, KBC_CYCLE_MS);\r\nkbc->idev->name = pdev->name;\r\nkbc->idev->id.bustype = BUS_HOST;\r\nkbc->idev->dev.parent = &pdev->dev;\r\nkbc->idev->open = tegra_kbc_open;\r\nkbc->idev->close = tegra_kbc_close;\r\nif (kbc->keymap_data && kbc->use_fn_map)\r\nkeymap_rows *= 2;\r\nerr = matrix_keypad_build_keymap(kbc->keymap_data, NULL,\r\nkeymap_rows,\r\nkbc->hw_support->max_columns,\r\nkbc->keycode, kbc->idev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to setup keymap\n");\r\nreturn err;\r\n}\r\n__set_bit(EV_REP, kbc->idev->evbit);\r\ninput_set_capability(kbc->idev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(kbc->idev, kbc);\r\nerr = devm_request_irq(&pdev->dev, kbc->irq, tegra_kbc_isr,\r\nIRQF_TRIGGER_HIGH, pdev->name, kbc);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to request keyboard IRQ\n");\r\nreturn err;\r\n}\r\ndisable_irq(kbc->irq);\r\nerr = input_register_device(kbc->idev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, kbc);\r\ndevice_init_wakeup(&pdev->dev, kbc->wakeup);\r\nreturn 0;\r\n}\r\nstatic void tegra_kbc_set_keypress_interrupt(struct tegra_kbc *kbc, bool enable)\r\n{\r\nu32 val;\r\nval = readl(kbc->mmio + KBC_CONTROL_0);\r\nif (enable)\r\nval |= KBC_CONTROL_KEYPRESS_INT_EN;\r\nelse\r\nval &= ~KBC_CONTROL_KEYPRESS_INT_EN;\r\nwritel(val, kbc->mmio + KBC_CONTROL_0);\r\n}\r\nstatic int tegra_kbc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_kbc *kbc = platform_get_drvdata(pdev);\r\nmutex_lock(&kbc->idev->mutex);\r\nif (device_may_wakeup(&pdev->dev)) {\r\ndisable_irq(kbc->irq);\r\ndel_timer_sync(&kbc->timer);\r\ntegra_kbc_set_fifo_interrupt(kbc, false);\r\nwritel(0x7, kbc->mmio + KBC_INT_0);\r\nkbc->cp_to_wkup_dly = readl(kbc->mmio + KBC_TO_CNT_0);\r\nwritel(0, kbc->mmio + KBC_TO_CNT_0);\r\ntegra_kbc_setup_wakekeys(kbc, true);\r\nmsleep(30);\r\nkbc->keypress_caused_wake = false;\r\ntegra_kbc_set_keypress_interrupt(kbc, true);\r\nenable_irq(kbc->irq);\r\nenable_irq_wake(kbc->irq);\r\n} else {\r\nif (kbc->idev->users)\r\ntegra_kbc_stop(kbc);\r\n}\r\nmutex_unlock(&kbc->idev->mutex);\r\nreturn 0;\r\n}\r\nstatic int tegra_kbc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tegra_kbc *kbc = platform_get_drvdata(pdev);\r\nint err = 0;\r\nmutex_lock(&kbc->idev->mutex);\r\nif (device_may_wakeup(&pdev->dev)) {\r\ndisable_irq_wake(kbc->irq);\r\ntegra_kbc_setup_wakekeys(kbc, false);\r\ntegra_kbc_set_keypress_interrupt(kbc, false);\r\nwritel(kbc->cp_to_wkup_dly, kbc->mmio + KBC_TO_CNT_0);\r\ntegra_kbc_set_fifo_interrupt(kbc, true);\r\nif (kbc->keypress_caused_wake && kbc->wakeup_key) {\r\ninput_report_key(kbc->idev, kbc->wakeup_key, 1);\r\ninput_sync(kbc->idev);\r\ninput_report_key(kbc->idev, kbc->wakeup_key, 0);\r\ninput_sync(kbc->idev);\r\n}\r\n} else {\r\nif (kbc->idev->users)\r\nerr = tegra_kbc_start(kbc);\r\n}\r\nmutex_unlock(&kbc->idev->mutex);\r\nreturn err;\r\n}
