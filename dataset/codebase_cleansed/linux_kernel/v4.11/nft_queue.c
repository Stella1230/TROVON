static void nft_queue_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_queue *priv = nft_expr_priv(expr);\r\nu32 queue = priv->queuenum;\r\nu32 ret;\r\nif (priv->queues_total > 1) {\r\nif (priv->flags & NFT_QUEUE_FLAG_CPU_FANOUT) {\r\nint cpu = raw_smp_processor_id();\r\nqueue = priv->queuenum + cpu % priv->queues_total;\r\n} else {\r\nqueue = nfqueue_hash(pkt->skb, queue,\r\npriv->queues_total, nft_pf(pkt),\r\njhash_initval);\r\n}\r\n}\r\nret = NF_QUEUE_NR(queue);\r\nif (priv->flags & NFT_QUEUE_FLAG_BYPASS)\r\nret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\r\nregs->verdict.code = ret;\r\n}\r\nstatic void nft_queue_sreg_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_queue *priv = nft_expr_priv(expr);\r\nu32 queue, ret;\r\nqueue = regs->data[priv->sreg_qnum];\r\nret = NF_QUEUE_NR(queue);\r\nif (priv->flags & NFT_QUEUE_FLAG_BYPASS)\r\nret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\r\nregs->verdict.code = ret;\r\n}\r\nstatic int nft_queue_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_queue *priv = nft_expr_priv(expr);\r\nu32 maxid;\r\npriv->queuenum = ntohs(nla_get_be16(tb[NFTA_QUEUE_NUM]));\r\nif (tb[NFTA_QUEUE_TOTAL])\r\npriv->queues_total = ntohs(nla_get_be16(tb[NFTA_QUEUE_TOTAL]));\r\nelse\r\npriv->queues_total = 1;\r\nif (priv->queues_total == 0)\r\nreturn -EINVAL;\r\nmaxid = priv->queues_total - 1 + priv->queuenum;\r\nif (maxid > U16_MAX)\r\nreturn -ERANGE;\r\nif (tb[NFTA_QUEUE_FLAGS]) {\r\npriv->flags = ntohs(nla_get_be16(tb[NFTA_QUEUE_FLAGS]));\r\nif (priv->flags & ~NFT_QUEUE_FLAG_MASK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_queue_sreg_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_queue *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->sreg_qnum = nft_parse_register(tb[NFTA_QUEUE_SREG_QNUM]);\r\nerr = nft_validate_register_load(priv->sreg_qnum, sizeof(u32));\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_QUEUE_FLAGS]) {\r\npriv->flags = ntohs(nla_get_be16(tb[NFTA_QUEUE_FLAGS]));\r\nif (priv->flags & ~NFT_QUEUE_FLAG_MASK)\r\nreturn -EINVAL;\r\nif (priv->flags & NFT_QUEUE_FLAG_CPU_FANOUT)\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_queue_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_queue *priv = nft_expr_priv(expr);\r\nif (nla_put_be16(skb, NFTA_QUEUE_NUM, htons(priv->queuenum)) ||\r\nnla_put_be16(skb, NFTA_QUEUE_TOTAL, htons(priv->queues_total)) ||\r\nnla_put_be16(skb, NFTA_QUEUE_FLAGS, htons(priv->flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int\r\nnft_queue_sreg_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_queue *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_QUEUE_SREG_QNUM, priv->sreg_qnum) ||\r\nnla_put_be16(skb, NFTA_QUEUE_FLAGS, htons(priv->flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_queue_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_QUEUE_NUM] && tb[NFTA_QUEUE_SREG_QNUM])\r\nreturn ERR_PTR(-EINVAL);\r\ninit_hashrandom(&jhash_initval);\r\nif (tb[NFTA_QUEUE_NUM])\r\nreturn &nft_queue_ops;\r\nif (tb[NFTA_QUEUE_SREG_QNUM])\r\nreturn &nft_queue_sreg_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_queue_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_queue_type);\r\n}\r\nstatic void __exit nft_queue_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_queue_type);\r\n}
