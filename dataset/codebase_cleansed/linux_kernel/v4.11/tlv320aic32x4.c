static inline int aic32x4_get_divs(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(aic32x4_divs); i++) {\r\nif ((aic32x4_divs[i].rate == rate)\r\n&& (aic32x4_divs[i].mclk == mclk)) {\r\nreturn i;\r\n}\r\n}\r\nprintk(KERN_ERR "aic32x4: master clock and sample rate is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int aic32x4_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase AIC32X4_FREQ_12000000:\r\ncase AIC32X4_FREQ_24000000:\r\ncase AIC32X4_FREQ_25000000:\r\naic32x4->sysclk = freq;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "aic32x4: invalid frequency to set DAI system clock\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int aic32x4_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 iface_reg_1;\r\nu8 iface_reg_2;\r\nu8 iface_reg_3;\r\niface_reg_1 = snd_soc_read(codec, AIC32X4_IFACE1);\r\niface_reg_1 = iface_reg_1 & ~(3 << 6 | 3 << 2);\r\niface_reg_2 = snd_soc_read(codec, AIC32X4_IFACE2);\r\niface_reg_2 = 0;\r\niface_reg_3 = snd_soc_read(codec, AIC32X4_IFACE3);\r\niface_reg_3 = iface_reg_3 & ~(1 << 3);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface_reg_1 |= AIC32X4_BCLKMASTER | AIC32X4_WCLKMASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aic32x4: invalid DAI master/slave interface\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface_reg_1 |= (AIC32X4_DSP_MODE << AIC32X4_PLLJ_SHIFT);\r\niface_reg_3 |= (1 << 3);\r\niface_reg_2 = 0x01;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface_reg_1 |= (AIC32X4_DSP_MODE << AIC32X4_PLLJ_SHIFT);\r\niface_reg_3 |= (1 << 3);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface_reg_1 |=\r\n(AIC32X4_RIGHT_JUSTIFIED_MODE << AIC32X4_PLLJ_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface_reg_1 |=\r\n(AIC32X4_LEFT_JUSTIFIED_MODE << AIC32X4_PLLJ_SHIFT);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aic32x4: invalid DAI interface format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AIC32X4_IFACE1, iface_reg_1);\r\nsnd_soc_write(codec, AIC32X4_IFACE2, iface_reg_2);\r\nsnd_soc_write(codec, AIC32X4_IFACE3, iface_reg_3);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nu8 data;\r\nint i;\r\ni = aic32x4_get_divs(aic32x4->sysclk, params_rate(params));\r\nif (i < 0) {\r\nprintk(KERN_ERR "aic32x4: sampling rate not supported\n");\r\nreturn i;\r\n}\r\nsnd_soc_write(codec, AIC32X4_CLKMUX, AIC32X4_PLLCLKIN);\r\nsnd_soc_write(codec, AIC32X4_IFACE3, AIC32X4_DACMOD2BCLK);\r\ndata = snd_soc_read(codec, AIC32X4_PLLPR);\r\ndata &= ~(7 << 4);\r\nsnd_soc_write(codec, AIC32X4_PLLPR,\r\n(data | (aic32x4_divs[i].p_val << 4) | 0x01));\r\nsnd_soc_write(codec, AIC32X4_PLLJ, aic32x4_divs[i].pll_j);\r\nsnd_soc_write(codec, AIC32X4_PLLDMSB, (aic32x4_divs[i].pll_d >> 8));\r\nsnd_soc_write(codec, AIC32X4_PLLDLSB,\r\n(aic32x4_divs[i].pll_d & 0xff));\r\ndata = snd_soc_read(codec, AIC32X4_NDAC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_NDAC, data | aic32x4_divs[i].ndac);\r\ndata = snd_soc_read(codec, AIC32X4_MDAC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_MDAC, data | aic32x4_divs[i].mdac);\r\nsnd_soc_write(codec, AIC32X4_DOSRMSB, aic32x4_divs[i].dosr >> 8);\r\nsnd_soc_write(codec, AIC32X4_DOSRLSB,\r\n(aic32x4_divs[i].dosr & 0xff));\r\ndata = snd_soc_read(codec, AIC32X4_NADC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_NADC, data | aic32x4_divs[i].nadc);\r\ndata = snd_soc_read(codec, AIC32X4_MADC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_MADC, data | aic32x4_divs[i].madc);\r\nsnd_soc_write(codec, AIC32X4_AOSR, aic32x4_divs[i].aosr);\r\ndata = snd_soc_read(codec, AIC32X4_BCLKN);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_BCLKN, data | aic32x4_divs[i].blck_N);\r\ndata = snd_soc_read(codec, AIC32X4_IFACE1);\r\ndata = data & ~(3 << 4);\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\ndata |= (AIC32X4_WORD_LEN_20BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\ncase 24:\r\ndata |= (AIC32X4_WORD_LEN_24BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\ncase 32:\r\ndata |= (AIC32X4_WORD_LEN_32BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, AIC32X4_IFACE1, data);\r\nif (params_channels(params) == 1) {\r\ndata = AIC32X4_RDAC2LCHN | AIC32X4_LDAC2LCHN;\r\n} else {\r\nif (aic32x4->swapdacs)\r\ndata = AIC32X4_RDAC2LCHN | AIC32X4_LDAC2RCHN;\r\nelse\r\ndata = AIC32X4_LDAC2LCHN | AIC32X4_RDAC2RCHN;\r\n}\r\nsnd_soc_update_bits(codec, AIC32X4_DACSETUP, AIC32X4_DAC_CHAN_MASK,\r\ndata);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dac_reg;\r\ndac_reg = snd_soc_read(codec, AIC32X4_DACMUTE) & ~AIC32X4_MUTEON;\r\nif (mute)\r\nsnd_soc_write(codec, AIC32X4_DACMUTE, dac_reg | AIC32X4_MUTEON);\r\nelse\r\nsnd_soc_write(codec, AIC32X4_DACMUTE, dac_reg);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nret = clk_prepare_enable(aic32x4->mclk);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable master clock\n");\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, AIC32X4_PLLPR,\r\nAIC32X4_PLLEN, AIC32X4_PLLEN);\r\nsnd_soc_update_bits(codec, AIC32X4_NDAC,\r\nAIC32X4_NDACEN, AIC32X4_NDACEN);\r\nsnd_soc_update_bits(codec, AIC32X4_MDAC,\r\nAIC32X4_MDACEN, AIC32X4_MDACEN);\r\nsnd_soc_update_bits(codec, AIC32X4_NADC,\r\nAIC32X4_NADCEN, AIC32X4_NADCEN);\r\nsnd_soc_update_bits(codec, AIC32X4_MADC,\r\nAIC32X4_MADCEN, AIC32X4_MADCEN);\r\nsnd_soc_update_bits(codec, AIC32X4_BCLKN,\r\nAIC32X4_BCLKEN, AIC32X4_BCLKEN);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, AIC32X4_BCLKN,\r\nAIC32X4_BCLKEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_MADC,\r\nAIC32X4_MADCEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_NADC,\r\nAIC32X4_NADCEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_MDAC,\r\nAIC32X4_MDACEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_NDAC,\r\nAIC32X4_NDACEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_PLLPR,\r\nAIC32X4_PLLEN, 0);\r\nclk_disable_unprepare(aic32x4->mclk);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic32x4_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nu32 tmp_reg;\r\nif (gpio_is_valid(aic32x4->rstn_gpio)) {\r\nndelay(10);\r\ngpio_set_value(aic32x4->rstn_gpio, 1);\r\n}\r\nsnd_soc_write(codec, AIC32X4_RESET, 0x01);\r\nif (aic32x4->power_cfg & AIC32X4_PWR_MICBIAS_2075_LDOIN) {\r\nsnd_soc_write(codec, AIC32X4_MICBIAS, AIC32X4_MICBIAS_LDOIN |\r\nAIC32X4_MICBIAS_2075V);\r\n}\r\nif (aic32x4->power_cfg & AIC32X4_PWR_AVDD_DVDD_WEAK_DISABLE)\r\nsnd_soc_write(codec, AIC32X4_PWRCFG, AIC32X4_AVDDWEAKDISABLE);\r\ntmp_reg = (aic32x4->power_cfg & AIC32X4_PWR_AIC32X4_LDO_ENABLE) ?\r\nAIC32X4_LDOCTLEN : 0;\r\nsnd_soc_write(codec, AIC32X4_LDOCTL, tmp_reg);\r\ntmp_reg = snd_soc_read(codec, AIC32X4_CMMODE);\r\nif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_LDOIN_RANGE_18_36)\r\ntmp_reg |= AIC32X4_LDOIN_18_36;\r\nif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_HP_LDOIN_POWERED)\r\ntmp_reg |= AIC32X4_LDOIN2HP;\r\nsnd_soc_write(codec, AIC32X4_CMMODE, tmp_reg);\r\nif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_LMIC_IN2R_10K)\r\nsnd_soc_write(codec, AIC32X4_LMICPGANIN,\r\nAIC32X4_LMICPGANIN_IN2R_10K);\r\nelse\r\nsnd_soc_write(codec, AIC32X4_LMICPGANIN,\r\nAIC32X4_LMICPGANIN_CM1L_10K);\r\nif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_RMIC_IN1L_10K)\r\nsnd_soc_write(codec, AIC32X4_RMICPGANIN,\r\nAIC32X4_RMICPGANIN_IN1L_10K);\r\nelse\r\nsnd_soc_write(codec, AIC32X4_RMICPGANIN,\r\nAIC32X4_RMICPGANIN_CM1R_10K);\r\ntmp_reg = snd_soc_read(codec, AIC32X4_ADCSETUP);\r\nsnd_soc_write(codec, AIC32X4_ADCSETUP, tmp_reg |\r\nAIC32X4_LADC_EN | AIC32X4_RADC_EN);\r\nsnd_soc_write(codec, AIC32X4_ADCSETUP, tmp_reg);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_parse_dt(struct aic32x4_priv *aic32x4,\r\nstruct device_node *np)\r\n{\r\naic32x4->swapdacs = false;\r\naic32x4->micpga_routing = 0;\r\naic32x4->rstn_gpio = of_get_named_gpio(np, "reset-gpios", 0);\r\nreturn 0;\r\n}\r\nstatic void aic32x4_disable_regulators(struct aic32x4_priv *aic32x4)\r\n{\r\nregulator_disable(aic32x4->supply_iov);\r\nif (!IS_ERR(aic32x4->supply_ldo))\r\nregulator_disable(aic32x4->supply_ldo);\r\nif (!IS_ERR(aic32x4->supply_dv))\r\nregulator_disable(aic32x4->supply_dv);\r\nif (!IS_ERR(aic32x4->supply_av))\r\nregulator_disable(aic32x4->supply_av);\r\n}\r\nstatic int aic32x4_setup_regulators(struct device *dev,\r\nstruct aic32x4_priv *aic32x4)\r\n{\r\nint ret = 0;\r\naic32x4->supply_ldo = devm_regulator_get_optional(dev, "ldoin");\r\naic32x4->supply_iov = devm_regulator_get(dev, "iov");\r\naic32x4->supply_dv = devm_regulator_get_optional(dev, "dv");\r\naic32x4->supply_av = devm_regulator_get_optional(dev, "av");\r\nif (IS_ERR(aic32x4->supply_iov)) {\r\ndev_err(dev, "Missing supply 'iov'\n");\r\nreturn PTR_ERR(aic32x4->supply_iov);\r\n}\r\nif (IS_ERR(aic32x4->supply_ldo)) {\r\nif (PTR_ERR(aic32x4->supply_ldo) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (IS_ERR(aic32x4->supply_dv)) {\r\ndev_err(dev, "Missing supply 'dv' or 'ldoin'\n");\r\nreturn PTR_ERR(aic32x4->supply_dv);\r\n}\r\nif (IS_ERR(aic32x4->supply_av)) {\r\ndev_err(dev, "Missing supply 'av' or 'ldoin'\n");\r\nreturn PTR_ERR(aic32x4->supply_av);\r\n}\r\n} else {\r\nif (IS_ERR(aic32x4->supply_dv) &&\r\nPTR_ERR(aic32x4->supply_dv) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (IS_ERR(aic32x4->supply_av) &&\r\nPTR_ERR(aic32x4->supply_av) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\n}\r\nret = regulator_enable(aic32x4->supply_iov);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator iov\n");\r\nreturn ret;\r\n}\r\nif (!IS_ERR(aic32x4->supply_ldo)) {\r\nret = regulator_enable(aic32x4->supply_ldo);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator ldo\n");\r\ngoto error_ldo;\r\n}\r\n}\r\nif (!IS_ERR(aic32x4->supply_dv)) {\r\nret = regulator_enable(aic32x4->supply_dv);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator dv\n");\r\ngoto error_dv;\r\n}\r\n}\r\nif (!IS_ERR(aic32x4->supply_av)) {\r\nret = regulator_enable(aic32x4->supply_av);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable regulator av\n");\r\ngoto error_av;\r\n}\r\n}\r\nif (!IS_ERR(aic32x4->supply_ldo) && IS_ERR(aic32x4->supply_av))\r\naic32x4->power_cfg |= AIC32X4_PWR_AIC32X4_LDO_ENABLE;\r\nreturn 0;\r\nerror_av:\r\nif (!IS_ERR(aic32x4->supply_dv))\r\nregulator_disable(aic32x4->supply_dv);\r\nerror_dv:\r\nif (!IS_ERR(aic32x4->supply_ldo))\r\nregulator_disable(aic32x4->supply_ldo);\r\nerror_ldo:\r\nregulator_disable(aic32x4->supply_iov);\r\nreturn ret;\r\n}\r\nint aic32x4_probe(struct device *dev, struct regmap *regmap)\r\n{\r\nstruct aic32x4_priv *aic32x4;\r\nstruct aic32x4_pdata *pdata = dev->platform_data;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\naic32x4 = devm_kzalloc(dev, sizeof(struct aic32x4_priv),\r\nGFP_KERNEL);\r\nif (aic32x4 == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, aic32x4);\r\nif (pdata) {\r\naic32x4->power_cfg = pdata->power_cfg;\r\naic32x4->swapdacs = pdata->swapdacs;\r\naic32x4->micpga_routing = pdata->micpga_routing;\r\naic32x4->rstn_gpio = pdata->rstn_gpio;\r\n} else if (np) {\r\nret = aic32x4_parse_dt(aic32x4, np);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse DT node\n");\r\nreturn ret;\r\n}\r\n} else {\r\naic32x4->power_cfg = 0;\r\naic32x4->swapdacs = false;\r\naic32x4->micpga_routing = 0;\r\naic32x4->rstn_gpio = -1;\r\n}\r\naic32x4->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(aic32x4->mclk)) {\r\ndev_err(dev, "Failed getting the mclk. The current implementation does not support the usage of this codec without mclk\n");\r\nreturn PTR_ERR(aic32x4->mclk);\r\n}\r\nif (gpio_is_valid(aic32x4->rstn_gpio)) {\r\nret = devm_gpio_request_one(dev, aic32x4->rstn_gpio,\r\nGPIOF_OUT_INIT_LOW, "tlv320aic32x4 rstn");\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nret = aic32x4_setup_regulators(dev, aic32x4);\r\nif (ret) {\r\ndev_err(dev, "Failed to setup regulators\n");\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(dev,\r\n&soc_codec_dev_aic32x4, &aic32x4_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to register codec\n");\r\naic32x4_disable_regulators(aic32x4);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint aic32x4_remove(struct device *dev)\r\n{\r\nstruct aic32x4_priv *aic32x4 = dev_get_drvdata(dev);\r\naic32x4_disable_regulators(aic32x4);\r\nsnd_soc_unregister_codec(dev);\r\nreturn 0;\r\n}
