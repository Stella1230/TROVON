u64 module_emit_plt_entry(struct module *mod, const Elf64_Rela *rela,\r\nElf64_Sym *sym)\r\n{\r\nstruct plt_entry *plt = (struct plt_entry *)mod->arch.plt->sh_addr;\r\nint i = mod->arch.plt_num_entries;\r\nu64 val = sym->st_value + rela->r_addend;\r\nif (rela->r_addend == 0 && sym->st_size != 0) {\r\nBUG_ON(sym->st_size < (u64)plt || sym->st_size >= (u64)&plt[i]);\r\nreturn sym->st_size;\r\n}\r\nmod->arch.plt_num_entries++;\r\nBUG_ON(mod->arch.plt_num_entries > mod->arch.plt_max_entries);\r\nplt[i] = (struct plt_entry){\r\ncpu_to_le32(0x92800010 | (((~val ) & 0xffff)) << 5),\r\ncpu_to_le32(0xf2a00010 | ((( val >> 16) & 0xffff)) << 5),\r\ncpu_to_le32(0xf2c00010 | ((( val >> 32) & 0xffff)) << 5),\r\ncpu_to_le32(0xd61f0200)\r\n};\r\nif (rela->r_addend == 0)\r\nsym->st_size = (u64)&plt[i];\r\nreturn (u64)&plt[i];\r\n}\r\nstatic int cmp_rela(const void *a, const void *b)\r\n{\r\nconst Elf64_Rela *x = a, *y = b;\r\nint i;\r\ni = cmp_3way(ELF64_R_TYPE(x->r_info), ELF64_R_TYPE(y->r_info));\r\nif (i == 0)\r\ni = cmp_3way(ELF64_R_SYM(x->r_info), ELF64_R_SYM(y->r_info));\r\nif (i == 0)\r\ni = cmp_3way(x->r_addend, y->r_addend);\r\nreturn i;\r\n}\r\nstatic bool duplicate_rel(const Elf64_Rela *rela, int num)\r\n{\r\nreturn num > 0 && cmp_rela(rela + num, rela + num - 1) == 0;\r\n}\r\nstatic unsigned int count_plts(Elf64_Sym *syms, Elf64_Rela *rela, int num)\r\n{\r\nunsigned int ret = 0;\r\nElf64_Sym *s;\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_AARCH64_JUMP26:\r\ncase R_AARCH64_CALL26:\r\ns = syms + ELF64_R_SYM(rela[i].r_info);\r\nif (s->st_shndx != SHN_UNDEF)\r\nbreak;\r\nif (rela[i].r_addend != 0 || !duplicate_rel(rela, i))\r\nret++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint module_frob_arch_sections(Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,\r\nchar *secstrings, struct module *mod)\r\n{\r\nunsigned long plt_max_entries = 0;\r\nElf64_Sym *syms = NULL;\r\nint i;\r\nfor (i = 0; i < ehdr->e_shnum; i++) {\r\nif (strcmp(".plt", secstrings + sechdrs[i].sh_name) == 0)\r\nmod->arch.plt = sechdrs + i;\r\nelse if (sechdrs[i].sh_type == SHT_SYMTAB)\r\nsyms = (Elf64_Sym *)sechdrs[i].sh_addr;\r\n}\r\nif (!mod->arch.plt) {\r\npr_err("%s: module PLT section missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nif (!syms) {\r\npr_err("%s: module symtab section missing\n", mod->name);\r\nreturn -ENOEXEC;\r\n}\r\nfor (i = 0; i < ehdr->e_shnum; i++) {\r\nElf64_Rela *rels = (void *)ehdr + sechdrs[i].sh_offset;\r\nint numrels = sechdrs[i].sh_size / sizeof(Elf64_Rela);\r\nElf64_Shdr *dstsec = sechdrs + sechdrs[i].sh_info;\r\nif (sechdrs[i].sh_type != SHT_RELA)\r\ncontinue;\r\nif (!(dstsec->sh_flags & SHF_EXECINSTR))\r\ncontinue;\r\nsort(rels, numrels, sizeof(Elf64_Rela), cmp_rela, NULL);\r\nplt_max_entries += count_plts(syms, rels, numrels);\r\n}\r\nmod->arch.plt->sh_type = SHT_NOBITS;\r\nmod->arch.plt->sh_flags = SHF_EXECINSTR | SHF_ALLOC;\r\nmod->arch.plt->sh_addralign = L1_CACHE_BYTES;\r\nmod->arch.plt->sh_size = plt_max_entries * sizeof(struct plt_entry);\r\nmod->arch.plt_num_entries = 0;\r\nmod->arch.plt_max_entries = plt_max_entries;\r\nreturn 0;\r\n}
