static int ti_sci_debug_show(struct seq_file *s, void *unused)\r\n{\r\nstruct ti_sci_info *info = s->private;\r\nmemcpy_fromio(info->debug_buffer, info->debug_region,\r\ninfo->debug_region_size);\r\nseq_puts(s, info->debug_buffer);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ti_sci_debug_show, inode->i_private);\r\n}\r\nstatic int ti_sci_debugfs_create(struct platform_device *pdev,\r\nstruct ti_sci_info *info)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nchar debug_name[50] = "ti_sci_debug@";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"debug_messages");\r\ninfo->debug_region = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(info->debug_region))\r\nreturn 0;\r\ninfo->debug_region_size = resource_size(res);\r\ninfo->debug_buffer = devm_kcalloc(dev, info->debug_region_size + 1,\r\nsizeof(char), GFP_KERNEL);\r\nif (!info->debug_buffer)\r\nreturn -ENOMEM;\r\ninfo->debug_buffer[info->debug_region_size] = 0;\r\ninfo->d = debugfs_create_file(strncat(debug_name, dev_name(dev),\r\nsizeof(debug_name)),\r\n0444, NULL, info, &ti_sci_debug_fops);\r\nif (IS_ERR(info->d))\r\nreturn PTR_ERR(info->d);\r\ndev_dbg(dev, "Debug region => %p, size = %zu bytes, resource: %pr\n",\r\ninfo->debug_region, info->debug_region_size, res);\r\nreturn 0;\r\n}\r\nstatic void ti_sci_debugfs_destroy(struct platform_device *pdev,\r\nstruct ti_sci_info *info)\r\n{\r\nif (IS_ERR(info->debug_region))\r\nreturn;\r\ndebugfs_remove(info->d);\r\n}\r\nstatic inline int ti_sci_debugfs_create(struct platform_device *dev,\r\nstruct ti_sci_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ti_sci_debugfs_destroy(struct platform_device *dev,\r\nstruct ti_sci_info *info)\r\n{\r\n}\r\nstatic inline void ti_sci_dump_header_dbg(struct device *dev,\r\nstruct ti_sci_msg_hdr *hdr)\r\n{\r\ndev_dbg(dev, "MSGHDR:type=0x%04x host=0x%02x seq=0x%02x flags=0x%08x\n",\r\nhdr->type, hdr->host, hdr->seq, hdr->flags);\r\n}\r\nstatic void ti_sci_rx_callback(struct mbox_client *cl, void *m)\r\n{\r\nstruct ti_sci_info *info = cl_to_ti_sci_info(cl);\r\nstruct device *dev = info->dev;\r\nstruct ti_sci_xfers_info *minfo = &info->minfo;\r\nstruct ti_msgmgr_message *mbox_msg = m;\r\nstruct ti_sci_msg_hdr *hdr = (struct ti_sci_msg_hdr *)mbox_msg->buf;\r\nstruct ti_sci_xfer *xfer;\r\nu8 xfer_id;\r\nxfer_id = hdr->seq;\r\nif (!test_bit(xfer_id, minfo->xfer_alloc_table)) {\r\ndev_err(dev, "Message for %d is not expected!\n", xfer_id);\r\nreturn;\r\n}\r\nxfer = &minfo->xfer_block[xfer_id];\r\nif (mbox_msg->len > info->desc->max_msg_size) {\r\ndev_err(dev, "Unable to handle %d xfer(max %d)\n",\r\nmbox_msg->len, info->desc->max_msg_size);\r\nti_sci_dump_header_dbg(dev, hdr);\r\nreturn;\r\n}\r\nif (mbox_msg->len < xfer->rx_len) {\r\ndev_err(dev, "Recv xfer %d < expected %d length\n",\r\nmbox_msg->len, xfer->rx_len);\r\nti_sci_dump_header_dbg(dev, hdr);\r\nreturn;\r\n}\r\nti_sci_dump_header_dbg(dev, hdr);\r\nmemcpy(xfer->xfer_buf, mbox_msg->buf, xfer->rx_len);\r\ncomplete(&xfer->done);\r\n}\r\nstatic struct ti_sci_xfer *ti_sci_get_one_xfer(struct ti_sci_info *info,\r\nu16 msg_type, u32 msg_flags,\r\nsize_t tx_message_size,\r\nsize_t rx_message_size)\r\n{\r\nstruct ti_sci_xfers_info *minfo = &info->minfo;\r\nstruct ti_sci_xfer *xfer;\r\nstruct ti_sci_msg_hdr *hdr;\r\nunsigned long flags;\r\nunsigned long bit_pos;\r\nu8 xfer_id;\r\nint ret;\r\nint timeout;\r\nif (rx_message_size > info->desc->max_msg_size ||\r\ntx_message_size > info->desc->max_msg_size ||\r\nrx_message_size < sizeof(*hdr) || tx_message_size < sizeof(*hdr))\r\nreturn ERR_PTR(-ERANGE);\r\ntimeout = msecs_to_jiffies(info->desc->max_rx_timeout_ms) * 5;\r\nret = down_timeout(&minfo->sem_xfer_count, timeout);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nspin_lock_irqsave(&minfo->xfer_lock, flags);\r\nbit_pos = find_first_zero_bit(minfo->xfer_alloc_table,\r\ninfo->desc->max_msgs);\r\nset_bit(bit_pos, minfo->xfer_alloc_table);\r\nspin_unlock_irqrestore(&minfo->xfer_lock, flags);\r\nxfer_id = (u8)bit_pos;\r\nxfer = &minfo->xfer_block[xfer_id];\r\nhdr = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\r\nxfer->tx_message.len = tx_message_size;\r\nxfer->rx_len = (u8)rx_message_size;\r\nreinit_completion(&xfer->done);\r\nhdr->seq = xfer_id;\r\nhdr->type = msg_type;\r\nhdr->host = info->desc->host_id;\r\nhdr->flags = msg_flags;\r\nreturn xfer;\r\n}\r\nstatic void ti_sci_put_one_xfer(struct ti_sci_xfers_info *minfo,\r\nstruct ti_sci_xfer *xfer)\r\n{\r\nunsigned long flags;\r\nstruct ti_sci_msg_hdr *hdr;\r\nu8 xfer_id;\r\nhdr = (struct ti_sci_msg_hdr *)xfer->tx_message.buf;\r\nxfer_id = hdr->seq;\r\nspin_lock_irqsave(&minfo->xfer_lock, flags);\r\nclear_bit(xfer_id, minfo->xfer_alloc_table);\r\nspin_unlock_irqrestore(&minfo->xfer_lock, flags);\r\nup(&minfo->sem_xfer_count);\r\n}\r\nstatic inline int ti_sci_do_xfer(struct ti_sci_info *info,\r\nstruct ti_sci_xfer *xfer)\r\n{\r\nint ret;\r\nint timeout;\r\nstruct device *dev = info->dev;\r\nret = mbox_send_message(info->chan_tx, &xfer->tx_message);\r\nif (ret < 0)\r\nreturn ret;\r\nret = 0;\r\ntimeout = msecs_to_jiffies(info->desc->max_rx_timeout_ms);\r\nif (!wait_for_completion_timeout(&xfer->done, timeout)) {\r\ndev_err(dev, "Mbox timedout in resp(caller: %pF)\n",\r\n(void *)_RET_IP_);\r\nret = -ETIMEDOUT;\r\n}\r\nmbox_client_txdone(info->chan_tx, ret);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_get_revision(struct ti_sci_info *info)\r\n{\r\nstruct device *dev = info->dev;\r\nstruct ti_sci_handle *handle = &info->handle;\r\nstruct ti_sci_version_info *ver = &handle->version;\r\nstruct ti_sci_msg_resp_version *rev_info;\r\nstruct ti_sci_xfer *xfer;\r\nint ret;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_VERSION,\r\n0x0, sizeof(struct ti_sci_msg_hdr),\r\nsizeof(*rev_info));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nrev_info = (struct ti_sci_msg_resp_version *)xfer->xfer_buf;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nver->abi_major = rev_info->abi_major;\r\nver->abi_minor = rev_info->abi_minor;\r\nver->firmware_revision = rev_info->firmware_revision;\r\nstrncpy(ver->firmware_description, rev_info->firmware_description,\r\nsizeof(ver->firmware_description));\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic inline bool ti_sci_is_response_ack(void *r)\r\n{\r\nstruct ti_sci_msg_hdr *hdr = r;\r\nreturn hdr->flags & TI_SCI_FLAG_RESP_GENERIC_ACK ? true : false;\r\n}\r\nstatic int ti_sci_set_device_state(const struct ti_sci_handle *handle,\r\nu32 id, u32 flags, u8 state)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_set_device_state *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_DEVICE_STATE,\r\nflags | TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_set_device_state *)xfer->xfer_buf;\r\nreq->id = id;\r\nreq->state = state;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_get_device_state(const struct ti_sci_handle *handle,\r\nu32 id, u32 *clcnt, u32 *resets,\r\nu8 *p_state, u8 *c_state)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_get_device_state *req;\r\nstruct ti_sci_msg_resp_get_device_state *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\nif (!clcnt && !resets && !p_state && !c_state)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_DEVICE_STATE,\r\n0, sizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_get_device_state *)xfer->xfer_buf;\r\nreq->id = id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_get_device_state *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp)) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nif (clcnt)\r\n*clcnt = resp->context_loss_count;\r\nif (resets)\r\n*resets = resp->resets;\r\nif (p_state)\r\n*p_state = resp->programmed_state;\r\nif (c_state)\r\n*c_state = resp->current_state;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_get_device(const struct ti_sci_handle *handle, u32 id)\r\n{\r\nreturn ti_sci_set_device_state(handle, id,\r\nMSG_FLAG_DEVICE_EXCLUSIVE,\r\nMSG_DEVICE_SW_STATE_ON);\r\n}\r\nstatic int ti_sci_cmd_idle_device(const struct ti_sci_handle *handle, u32 id)\r\n{\r\nreturn ti_sci_set_device_state(handle, id,\r\nMSG_FLAG_DEVICE_EXCLUSIVE,\r\nMSG_DEVICE_SW_STATE_RETENTION);\r\n}\r\nstatic int ti_sci_cmd_put_device(const struct ti_sci_handle *handle, u32 id)\r\n{\r\nreturn ti_sci_set_device_state(handle, id,\r\n0, MSG_DEVICE_SW_STATE_AUTO_OFF);\r\n}\r\nstatic int ti_sci_cmd_dev_is_valid(const struct ti_sci_handle *handle, u32 id)\r\n{\r\nu8 unused;\r\nreturn ti_sci_get_device_state(handle, id, NULL, NULL, NULL, &unused);\r\n}\r\nstatic int ti_sci_cmd_dev_get_clcnt(const struct ti_sci_handle *handle, u32 id,\r\nu32 *count)\r\n{\r\nreturn ti_sci_get_device_state(handle, id, count, NULL, NULL, NULL);\r\n}\r\nstatic int ti_sci_cmd_dev_is_idle(const struct ti_sci_handle *handle, u32 id,\r\nbool *r_state)\r\n{\r\nint ret;\r\nu8 state;\r\nif (!r_state)\r\nreturn -EINVAL;\r\nret = ti_sci_get_device_state(handle, id, NULL, NULL, &state, NULL);\r\nif (ret)\r\nreturn ret;\r\n*r_state = (state == MSG_DEVICE_SW_STATE_RETENTION);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_dev_is_stop(const struct ti_sci_handle *handle, u32 id,\r\nbool *r_state, bool *curr_state)\r\n{\r\nint ret;\r\nu8 p_state, c_state;\r\nif (!r_state && !curr_state)\r\nreturn -EINVAL;\r\nret =\r\nti_sci_get_device_state(handle, id, NULL, NULL, &p_state, &c_state);\r\nif (ret)\r\nreturn ret;\r\nif (r_state)\r\n*r_state = (p_state == MSG_DEVICE_SW_STATE_AUTO_OFF);\r\nif (curr_state)\r\n*curr_state = (c_state == MSG_DEVICE_HW_STATE_OFF);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_dev_is_on(const struct ti_sci_handle *handle, u32 id,\r\nbool *r_state, bool *curr_state)\r\n{\r\nint ret;\r\nu8 p_state, c_state;\r\nif (!r_state && !curr_state)\r\nreturn -EINVAL;\r\nret =\r\nti_sci_get_device_state(handle, id, NULL, NULL, &p_state, &c_state);\r\nif (ret)\r\nreturn ret;\r\nif (r_state)\r\n*r_state = (p_state == MSG_DEVICE_SW_STATE_ON);\r\nif (curr_state)\r\n*curr_state = (c_state == MSG_DEVICE_HW_STATE_ON);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_dev_is_trans(const struct ti_sci_handle *handle, u32 id,\r\nbool *curr_state)\r\n{\r\nint ret;\r\nu8 state;\r\nif (!curr_state)\r\nreturn -EINVAL;\r\nret = ti_sci_get_device_state(handle, id, NULL, NULL, NULL, &state);\r\nif (ret)\r\nreturn ret;\r\n*curr_state = (state == MSG_DEVICE_HW_STATE_TRANS);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_set_device_resets(const struct ti_sci_handle *handle,\r\nu32 id, u32 reset_state)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_set_device_resets *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_DEVICE_RESETS,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_set_device_resets *)xfer->xfer_buf;\r\nreq->id = id;\r\nreq->resets = reset_state;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_get_device_resets(const struct ti_sci_handle *handle,\r\nu32 id, u32 *reset_state)\r\n{\r\nreturn ti_sci_get_device_state(handle, id, NULL, reset_state, NULL,\r\nNULL);\r\n}\r\nstatic int ti_sci_set_clock_state(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id,\r\nu32 flags, u8 state)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_set_clock_state *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_STATE,\r\nflags | TI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_set_clock_state *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nreq->request_state = state;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_get_clock_state(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id,\r\nu8 *programmed_state, u8 *current_state)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_get_clock_state *req;\r\nstruct ti_sci_msg_resp_get_clock_state *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\nif (!programmed_state && !current_state)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_STATE,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_get_clock_state *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_get_clock_state *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp)) {\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nif (programmed_state)\r\n*programmed_state = resp->programmed_state;\r\nif (current_state)\r\n*current_state = resp->current_state;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_get_clock(const struct ti_sci_handle *handle, u32 dev_id,\r\nu8 clk_id, bool needs_ssc, bool can_change_freq,\r\nbool enable_input_term)\r\n{\r\nu32 flags = 0;\r\nflags |= needs_ssc ? MSG_FLAG_CLOCK_ALLOW_SSC : 0;\r\nflags |= can_change_freq ? MSG_FLAG_CLOCK_ALLOW_FREQ_CHANGE : 0;\r\nflags |= enable_input_term ? MSG_FLAG_CLOCK_INPUT_TERM : 0;\r\nreturn ti_sci_set_clock_state(handle, dev_id, clk_id, flags,\r\nMSG_CLOCK_SW_STATE_REQ);\r\n}\r\nstatic int ti_sci_cmd_idle_clock(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id)\r\n{\r\nreturn ti_sci_set_clock_state(handle, dev_id, clk_id, 0,\r\nMSG_CLOCK_SW_STATE_UNREQ);\r\n}\r\nstatic int ti_sci_cmd_put_clock(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id)\r\n{\r\nreturn ti_sci_set_clock_state(handle, dev_id, clk_id, 0,\r\nMSG_CLOCK_SW_STATE_AUTO);\r\n}\r\nstatic int ti_sci_cmd_clk_is_auto(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, bool *req_state)\r\n{\r\nu8 state = 0;\r\nint ret;\r\nif (!req_state)\r\nreturn -EINVAL;\r\nret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id, &state, NULL);\r\nif (ret)\r\nreturn ret;\r\n*req_state = (state == MSG_CLOCK_SW_STATE_AUTO);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_clk_is_on(const struct ti_sci_handle *handle, u32 dev_id,\r\nu8 clk_id, bool *req_state, bool *curr_state)\r\n{\r\nu8 c_state = 0, r_state = 0;\r\nint ret;\r\nif (!req_state && !curr_state)\r\nreturn -EINVAL;\r\nret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id,\r\n&r_state, &c_state);\r\nif (ret)\r\nreturn ret;\r\nif (req_state)\r\n*req_state = (r_state == MSG_CLOCK_SW_STATE_REQ);\r\nif (curr_state)\r\n*curr_state = (c_state == MSG_CLOCK_HW_STATE_READY);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_clk_is_off(const struct ti_sci_handle *handle, u32 dev_id,\r\nu8 clk_id, bool *req_state, bool *curr_state)\r\n{\r\nu8 c_state = 0, r_state = 0;\r\nint ret;\r\nif (!req_state && !curr_state)\r\nreturn -EINVAL;\r\nret = ti_sci_cmd_get_clock_state(handle, dev_id, clk_id,\r\n&r_state, &c_state);\r\nif (ret)\r\nreturn ret;\r\nif (req_state)\r\n*req_state = (r_state == MSG_CLOCK_SW_STATE_UNREQ);\r\nif (curr_state)\r\n*curr_state = (c_state == MSG_CLOCK_HW_STATE_NOT_READY);\r\nreturn 0;\r\n}\r\nstatic int ti_sci_cmd_clk_set_parent(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, u8 parent_id)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_set_clock_parent *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_PARENT,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_set_clock_parent *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nreq->parent_id = parent_id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_clk_get_parent(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, u8 *parent_id)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_get_clock_parent *req;\r\nstruct ti_sci_msg_resp_get_clock_parent *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle || !parent_id)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_PARENT,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_get_clock_parent *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_get_clock_parent *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp))\r\nret = -ENODEV;\r\nelse\r\n*parent_id = resp->parent_id;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_clk_get_num_parents(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id,\r\nu8 *num_parents)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_get_clock_num_parents *req;\r\nstruct ti_sci_msg_resp_get_clock_num_parents *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle || !num_parents)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_NUM_CLOCK_PARENTS,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_get_clock_num_parents *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_get_clock_num_parents *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp))\r\nret = -ENODEV;\r\nelse\r\n*num_parents = resp->num_parents;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_clk_get_match_freq(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, u64 min_freq,\r\nu64 target_freq, u64 max_freq,\r\nu64 *match_freq)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_query_clock_freq *req;\r\nstruct ti_sci_msg_resp_query_clock_freq *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle || !match_freq)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_QUERY_CLOCK_FREQ,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_query_clock_freq *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nreq->min_freq_hz = min_freq;\r\nreq->target_freq_hz = target_freq;\r\nreq->max_freq_hz = max_freq;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_query_clock_freq *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp))\r\nret = -ENODEV;\r\nelse\r\n*match_freq = resp->freq_hz;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_clk_set_freq(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, u64 min_freq,\r\nu64 target_freq, u64 max_freq)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_set_clock_freq *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SET_CLOCK_FREQ,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_set_clock_freq *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nreq->min_freq_hz = min_freq;\r\nreq->target_freq_hz = target_freq;\r\nreq->max_freq_hz = max_freq;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nret = ti_sci_is_response_ack(resp) ? 0 : -ENODEV;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_clk_get_freq(const struct ti_sci_handle *handle,\r\nu32 dev_id, u8 clk_id, u64 *freq)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_get_clock_freq *req;\r\nstruct ti_sci_msg_resp_get_clock_freq *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle || !freq)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_GET_CLOCK_FREQ,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_get_clock_freq *)xfer->xfer_buf;\r\nreq->dev_id = dev_id;\r\nreq->clk_id = clk_id;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_resp_get_clock_freq *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp))\r\nret = -ENODEV;\r\nelse\r\n*freq = resp->freq_hz;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_cmd_core_reboot(const struct ti_sci_handle *handle)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct ti_sci_msg_req_reboot *req;\r\nstruct ti_sci_msg_hdr *resp;\r\nstruct ti_sci_xfer *xfer;\r\nstruct device *dev;\r\nint ret = 0;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\ndev = info->dev;\r\nxfer = ti_sci_get_one_xfer(info, TI_SCI_MSG_SYS_RESET,\r\nTI_SCI_FLAG_REQ_ACK_ON_PROCESSED,\r\nsizeof(*req), sizeof(*resp));\r\nif (IS_ERR(xfer)) {\r\nret = PTR_ERR(xfer);\r\ndev_err(dev, "Message alloc failed(%d)\n", ret);\r\nreturn ret;\r\n}\r\nreq = (struct ti_sci_msg_req_reboot *)xfer->xfer_buf;\r\nret = ti_sci_do_xfer(info, xfer);\r\nif (ret) {\r\ndev_err(dev, "Mbox send fail %d\n", ret);\r\ngoto fail;\r\n}\r\nresp = (struct ti_sci_msg_hdr *)xfer->xfer_buf;\r\nif (!ti_sci_is_response_ack(resp))\r\nret = -ENODEV;\r\nelse\r\nret = 0;\r\nfail:\r\nti_sci_put_one_xfer(&info->minfo, xfer);\r\nreturn ret;\r\n}\r\nstatic void ti_sci_setup_ops(struct ti_sci_info *info)\r\n{\r\nstruct ti_sci_ops *ops = &info->handle.ops;\r\nstruct ti_sci_core_ops *core_ops = &ops->core_ops;\r\nstruct ti_sci_dev_ops *dops = &ops->dev_ops;\r\nstruct ti_sci_clk_ops *cops = &ops->clk_ops;\r\ncore_ops->reboot_device = ti_sci_cmd_core_reboot;\r\ndops->get_device = ti_sci_cmd_get_device;\r\ndops->idle_device = ti_sci_cmd_idle_device;\r\ndops->put_device = ti_sci_cmd_put_device;\r\ndops->is_valid = ti_sci_cmd_dev_is_valid;\r\ndops->get_context_loss_count = ti_sci_cmd_dev_get_clcnt;\r\ndops->is_idle = ti_sci_cmd_dev_is_idle;\r\ndops->is_stop = ti_sci_cmd_dev_is_stop;\r\ndops->is_on = ti_sci_cmd_dev_is_on;\r\ndops->is_transitioning = ti_sci_cmd_dev_is_trans;\r\ndops->set_device_resets = ti_sci_cmd_set_device_resets;\r\ndops->get_device_resets = ti_sci_cmd_get_device_resets;\r\ncops->get_clock = ti_sci_cmd_get_clock;\r\ncops->idle_clock = ti_sci_cmd_idle_clock;\r\ncops->put_clock = ti_sci_cmd_put_clock;\r\ncops->is_auto = ti_sci_cmd_clk_is_auto;\r\ncops->is_on = ti_sci_cmd_clk_is_on;\r\ncops->is_off = ti_sci_cmd_clk_is_off;\r\ncops->set_parent = ti_sci_cmd_clk_set_parent;\r\ncops->get_parent = ti_sci_cmd_clk_get_parent;\r\ncops->get_num_parents = ti_sci_cmd_clk_get_num_parents;\r\ncops->get_best_match_freq = ti_sci_cmd_clk_get_match_freq;\r\ncops->set_freq = ti_sci_cmd_clk_set_freq;\r\ncops->get_freq = ti_sci_cmd_clk_get_freq;\r\n}\r\nconst struct ti_sci_handle *ti_sci_get_handle(struct device *dev)\r\n{\r\nstruct device_node *ti_sci_np;\r\nstruct list_head *p;\r\nstruct ti_sci_handle *handle = NULL;\r\nstruct ti_sci_info *info;\r\nif (!dev) {\r\npr_err("I need a device pointer\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nti_sci_np = of_get_parent(dev->of_node);\r\nif (!ti_sci_np) {\r\ndev_err(dev, "No OF information\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmutex_lock(&ti_sci_list_mutex);\r\nlist_for_each(p, &ti_sci_list) {\r\ninfo = list_entry(p, struct ti_sci_info, node);\r\nif (ti_sci_np == info->dev->of_node) {\r\nhandle = &info->handle;\r\ninfo->users++;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ti_sci_list_mutex);\r\nof_node_put(ti_sci_np);\r\nif (!handle)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nreturn handle;\r\n}\r\nint ti_sci_put_handle(const struct ti_sci_handle *handle)\r\n{\r\nstruct ti_sci_info *info;\r\nif (IS_ERR(handle))\r\nreturn PTR_ERR(handle);\r\nif (!handle)\r\nreturn -EINVAL;\r\ninfo = handle_to_ti_sci_info(handle);\r\nmutex_lock(&ti_sci_list_mutex);\r\nif (!WARN_ON(!info->users))\r\ninfo->users--;\r\nmutex_unlock(&ti_sci_list_mutex);\r\nreturn 0;\r\n}\r\nstatic void devm_ti_sci_release(struct device *dev, void *res)\r\n{\r\nconst struct ti_sci_handle **ptr = res;\r\nconst struct ti_sci_handle *handle = *ptr;\r\nint ret;\r\nret = ti_sci_put_handle(handle);\r\nif (ret)\r\ndev_err(dev, "failed to put handle %d\n", ret);\r\n}\r\nconst struct ti_sci_handle *devm_ti_sci_get_handle(struct device *dev)\r\n{\r\nconst struct ti_sci_handle **ptr;\r\nconst struct ti_sci_handle *handle;\r\nptr = devres_alloc(devm_ti_sci_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\nhandle = ti_sci_get_handle(dev);\r\nif (!IS_ERR(handle)) {\r\n*ptr = handle;\r\ndevres_add(dev, ptr);\r\n} else {\r\ndevres_free(ptr);\r\n}\r\nreturn handle;\r\n}\r\nstatic int tisci_reboot_handler(struct notifier_block *nb, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nstruct ti_sci_info *info = reboot_to_ti_sci_info(nb);\r\nconst struct ti_sci_handle *handle = &info->handle;\r\nti_sci_cmd_core_reboot(handle);\r\nreturn NOTIFY_BAD;\r\n}\r\nstatic int ti_sci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nconst struct ti_sci_desc *desc;\r\nstruct ti_sci_xfer *xfer;\r\nstruct ti_sci_info *info = NULL;\r\nstruct ti_sci_xfers_info *minfo;\r\nstruct mbox_client *cl;\r\nint ret = -EINVAL;\r\nint i;\r\nint reboot = 0;\r\nof_id = of_match_device(ti_sci_of_match, dev);\r\nif (!of_id) {\r\ndev_err(dev, "OF data missing\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = of_id->data;\r\ninfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = dev;\r\ninfo->desc = desc;\r\nreboot = of_property_read_bool(dev->of_node,\r\n"ti,system-reboot-controller");\r\nINIT_LIST_HEAD(&info->node);\r\nminfo = &info->minfo;\r\nif (WARN_ON(desc->max_msgs >=\r\n1 << 8 * sizeof(((struct ti_sci_msg_hdr *)0)->seq)))\r\nreturn -EINVAL;\r\nminfo->xfer_block = devm_kcalloc(dev,\r\ndesc->max_msgs,\r\nsizeof(*minfo->xfer_block),\r\nGFP_KERNEL);\r\nif (!minfo->xfer_block)\r\nreturn -ENOMEM;\r\nminfo->xfer_alloc_table = devm_kzalloc(dev,\r\nBITS_TO_LONGS(desc->max_msgs)\r\n* sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!minfo->xfer_alloc_table)\r\nreturn -ENOMEM;\r\nbitmap_zero(minfo->xfer_alloc_table, desc->max_msgs);\r\nfor (i = 0, xfer = minfo->xfer_block; i < desc->max_msgs; i++, xfer++) {\r\nxfer->xfer_buf = devm_kcalloc(dev, 1, desc->max_msg_size,\r\nGFP_KERNEL);\r\nif (!xfer->xfer_buf)\r\nreturn -ENOMEM;\r\nxfer->tx_message.buf = xfer->xfer_buf;\r\ninit_completion(&xfer->done);\r\n}\r\nret = ti_sci_debugfs_create(pdev, info);\r\nif (ret)\r\ndev_warn(dev, "Failed to create debug file\n");\r\nplatform_set_drvdata(pdev, info);\r\ncl = &info->cl;\r\ncl->dev = dev;\r\ncl->tx_block = false;\r\ncl->rx_callback = ti_sci_rx_callback;\r\ncl->knows_txdone = true;\r\nspin_lock_init(&minfo->xfer_lock);\r\nsema_init(&minfo->sem_xfer_count, desc->max_msgs);\r\ninfo->chan_rx = mbox_request_channel_byname(cl, "rx");\r\nif (IS_ERR(info->chan_rx)) {\r\nret = PTR_ERR(info->chan_rx);\r\ngoto out;\r\n}\r\ninfo->chan_tx = mbox_request_channel_byname(cl, "tx");\r\nif (IS_ERR(info->chan_tx)) {\r\nret = PTR_ERR(info->chan_tx);\r\ngoto out;\r\n}\r\nret = ti_sci_cmd_get_revision(info);\r\nif (ret) {\r\ndev_err(dev, "Unable to communicate with TISCI(%d)\n", ret);\r\ngoto out;\r\n}\r\nti_sci_setup_ops(info);\r\nif (reboot) {\r\ninfo->nb.notifier_call = tisci_reboot_handler;\r\ninfo->nb.priority = 128;\r\nret = register_restart_handler(&info->nb);\r\nif (ret) {\r\ndev_err(dev, "reboot registration fail(%d)\n", ret);\r\nreturn ret;\r\n}\r\n}\r\ndev_info(dev, "ABI: %d.%d (firmware rev 0x%04x '%s')\n",\r\ninfo->handle.version.abi_major, info->handle.version.abi_minor,\r\ninfo->handle.version.firmware_revision,\r\ninfo->handle.version.firmware_description);\r\nmutex_lock(&ti_sci_list_mutex);\r\nlist_add_tail(&info->node, &ti_sci_list);\r\nmutex_unlock(&ti_sci_list_mutex);\r\nreturn of_platform_populate(dev->of_node, NULL, NULL, dev);\r\nout:\r\nif (!IS_ERR(info->chan_tx))\r\nmbox_free_channel(info->chan_tx);\r\nif (!IS_ERR(info->chan_rx))\r\nmbox_free_channel(info->chan_rx);\r\ndebugfs_remove(info->d);\r\nreturn ret;\r\n}\r\nstatic int ti_sci_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_sci_info *info;\r\nstruct device *dev = &pdev->dev;\r\nint ret = 0;\r\nof_platform_depopulate(dev);\r\ninfo = platform_get_drvdata(pdev);\r\nif (info->nb.notifier_call)\r\nunregister_restart_handler(&info->nb);\r\nmutex_lock(&ti_sci_list_mutex);\r\nif (info->users)\r\nret = -EBUSY;\r\nelse\r\nlist_del(&info->node);\r\nmutex_unlock(&ti_sci_list_mutex);\r\nif (!ret) {\r\nti_sci_debugfs_destroy(pdev, info);\r\nmbox_free_channel(info->chan_tx);\r\nmbox_free_channel(info->chan_rx);\r\n}\r\nreturn ret;\r\n}
