static int pnv_eeh_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nif (!firmware_has_feature(FW_FEATURE_OPAL)) {\r\npr_warn("%s: OPAL is required !\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\neeh_add_flag(EEH_PROBE_MODE_DEV);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (phb->model == PNV_PHB_MODEL_P7IOC)\r\neeh_add_flag(EEH_ENABLE_IO_FOR_LOG);\r\nif (phb->ioda.reserved_pe_idx != 0)\r\neeh_add_flag(EEH_VALID_PE_ZERO);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pnv_eeh_event(int irq, void *data)\r\n{\r\ndisable_irq_nosync(irq);\r\nif (eeh_enabled())\r\neeh_send_failure_event(NULL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t pnv_eeh_ei_write(struct file *filp,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct pci_controller *hose = filp->private_data;\r\nstruct eeh_dev *edev;\r\nstruct eeh_pe *pe;\r\nint pe_no, type, func;\r\nunsigned long addr, mask;\r\nchar buf[50];\r\nint ret;\r\nif (!eeh_ops || !eeh_ops->err_inject)\r\nreturn -ENXIO;\r\nret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);\r\nif (!ret)\r\nreturn -EFAULT;\r\nret = sscanf(buf, "%x:%x:%x:%lx:%lx",\r\n&pe_no, &type, &func, &addr, &mask);\r\nif (ret != 5)\r\nreturn -EINVAL;\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev)\r\nreturn -ENOMEM;\r\nedev->phb = hose;\r\nedev->pe_config_addr = pe_no;\r\npe = eeh_pe_get(edev);\r\nkfree(edev);\r\nif (!pe)\r\nreturn -ENODEV;\r\nret = eeh_ops->err_inject(pe, type, func, addr, mask);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int pnv_eeh_dbgfs_set(void *data, int offset, u64 val)\r\n{\r\nstruct pci_controller *hose = data;\r\nstruct pnv_phb *phb = hose->private_data;\r\nout_be64(phb->regs + offset, val);\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_dbgfs_get(void *data, int offset, u64 *val)\r\n{\r\nstruct pci_controller *hose = data;\r\nstruct pnv_phb *phb = hose->private_data;\r\n*val = in_be64(phb->regs + offset);\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_post_init(void)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nint ret = 0;\r\nif (!pnv_eeh_nb_init) {\r\neeh_event_irq = opal_event_request(ilog2(OPAL_EVENT_PCI_ERROR));\r\nif (eeh_event_irq < 0) {\r\npr_err("%s: Can't register OPAL event interrupt (%d)\n",\r\n__func__, eeh_event_irq);\r\nreturn eeh_event_irq;\r\n}\r\nret = request_irq(eeh_event_irq, pnv_eeh_event,\r\nIRQ_TYPE_LEVEL_HIGH, "opal-eeh", NULL);\r\nif (ret < 0) {\r\nirq_dispose_mapping(eeh_event_irq);\r\npr_err("%s: Can't request OPAL event interrupt (%d)\n",\r\n__func__, eeh_event_irq);\r\nreturn ret;\r\n}\r\npnv_eeh_nb_init = true;\r\n}\r\nif (!eeh_enabled())\r\ndisable_irq(eeh_event_irq);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nif (eeh_enabled())\r\nphb->flags |= PNV_PHB_FLAG_EEH;\r\nelse\r\nphb->flags &= ~PNV_PHB_FLAG_EEH;\r\n#ifdef CONFIG_DEBUG_FS\r\nif (phb->has_dbgfs || !phb->dbgfs)\r\ncontinue;\r\nphb->has_dbgfs = 1;\r\ndebugfs_create_file("err_injct", 0200,\r\nphb->dbgfs, hose,\r\n&pnv_eeh_ei_fops);\r\ndebugfs_create_file("err_injct_outbound", 0600,\r\nphb->dbgfs, hose,\r\n&pnv_eeh_dbgfs_ops_outb);\r\ndebugfs_create_file("err_injct_inboundA", 0600,\r\nphb->dbgfs, hose,\r\n&pnv_eeh_dbgfs_ops_inbA);\r\ndebugfs_create_file("err_injct_inboundB", 0600,\r\nphb->dbgfs, hose,\r\n&pnv_eeh_dbgfs_ops_inbB);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int pnv_eeh_find_cap(struct pci_dn *pdn, int cap)\r\n{\r\nint pos = PCI_CAPABILITY_LIST;\r\nint cnt = 48;\r\nu32 status, id;\r\nif (!pdn)\r\nreturn 0;\r\npnv_pci_cfg_read(pdn, PCI_STATUS, 2, &status);\r\nif (!(status & PCI_STATUS_CAP_LIST))\r\nreturn 0;\r\nwhile (cnt--) {\r\npnv_pci_cfg_read(pdn, pos, 1, &pos);\r\nif (pos < 0x40)\r\nbreak;\r\npos &= ~3;\r\npnv_pci_cfg_read(pdn, pos + PCI_CAP_LIST_ID, 1, &id);\r\nif (id == 0xff)\r\nbreak;\r\nif (id == cap)\r\nreturn pos;\r\npos += PCI_CAP_LIST_NEXT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_find_ecap(struct pci_dn *pdn, int cap)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nu32 header;\r\nint pos = 256, ttl = (4096 - 256) / 8;\r\nif (!edev || !edev->pcie_cap)\r\nreturn 0;\r\nif (pnv_pci_cfg_read(pdn, pos, 4, &header) != PCIBIOS_SUCCESSFUL)\r\nreturn 0;\r\nelse if (!header)\r\nreturn 0;\r\nwhile (ttl-- > 0) {\r\nif (PCI_EXT_CAP_ID(header) == cap && pos)\r\nreturn pos;\r\npos = PCI_EXT_CAP_NEXT(header);\r\nif (pos < 256)\r\nbreak;\r\nif (pnv_pci_cfg_read(pdn, pos, 4, &header) != PCIBIOS_SUCCESSFUL)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *pnv_eeh_probe(struct pci_dn *pdn, void *data)\r\n{\r\nstruct pci_controller *hose = pdn->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nuint32_t pcie_flags;\r\nint ret;\r\nif (!edev || edev->pe)\r\nreturn NULL;\r\nif ((pdn->class_code >> 8) == PCI_CLASS_BRIDGE_ISA)\r\nreturn NULL;\r\nedev->class_code = pdn->class_code;\r\nedev->mode &= 0xFFFFFF00;\r\nedev->pcix_cap = pnv_eeh_find_cap(pdn, PCI_CAP_ID_PCIX);\r\nedev->pcie_cap = pnv_eeh_find_cap(pdn, PCI_CAP_ID_EXP);\r\nedev->af_cap = pnv_eeh_find_cap(pdn, PCI_CAP_ID_AF);\r\nedev->aer_cap = pnv_eeh_find_ecap(pdn, PCI_EXT_CAP_ID_ERR);\r\nif ((edev->class_code >> 8) == PCI_CLASS_BRIDGE_PCI) {\r\nedev->mode |= EEH_DEV_BRIDGE;\r\nif (edev->pcie_cap) {\r\npnv_pci_cfg_read(pdn, edev->pcie_cap + PCI_EXP_FLAGS,\r\n2, &pcie_flags);\r\npcie_flags = (pcie_flags & PCI_EXP_FLAGS_TYPE) >> 4;\r\nif (pcie_flags == PCI_EXP_TYPE_ROOT_PORT)\r\nedev->mode |= EEH_DEV_ROOT_PORT;\r\nelse if (pcie_flags == PCI_EXP_TYPE_DOWNSTREAM)\r\nedev->mode |= EEH_DEV_DS_PORT;\r\n}\r\n}\r\nedev->config_addr = (pdn->busno << 8) | (pdn->devfn);\r\nedev->pe_config_addr = phb->ioda.pe_rmap[edev->config_addr];\r\nret = eeh_add_to_parent_pe(edev);\r\nif (ret) {\r\npr_warn("%s: Can't add PCI dev %04x:%02x:%02x.%01x to parent PE (%x)\n",\r\n__func__, hose->global_number, pdn->busno,\r\nPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn), ret);\r\nreturn NULL;\r\n}\r\nif ((pdn->vendor_id == PCI_VENDOR_ID_BROADCOM &&\r\npdn->device_id == 0x1657) ||\r\n(pdn->vendor_id == PCI_VENDOR_ID_BROADCOM &&\r\npdn->device_id == 0x168a) ||\r\n(pdn->vendor_id == PCI_VENDOR_ID_BROADCOM &&\r\npdn->device_id == 0x168e))\r\nedev->pe->state |= EEH_PE_CFG_RESTRICTED;\r\nif (!(edev->pe->state & EEH_PE_PRI_BUS)) {\r\nedev->pe->bus = pci_find_bus(hose->global_number,\r\npdn->busno);\r\nif (edev->pe->bus)\r\nedev->pe->state |= EEH_PE_PRI_BUS;\r\n}\r\neeh_add_flag(EEH_ENABLED);\r\neeh_save_bars(edev);\r\nreturn NULL;\r\n}\r\nstatic int pnv_eeh_set_option(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nbool freeze_pe = false;\r\nint opt;\r\ns64 rc;\r\nswitch (option) {\r\ncase EEH_OPT_DISABLE:\r\nreturn -EPERM;\r\ncase EEH_OPT_ENABLE:\r\nreturn 0;\r\ncase EEH_OPT_THAW_MMIO:\r\nopt = OPAL_EEH_ACTION_CLEAR_FREEZE_MMIO;\r\nbreak;\r\ncase EEH_OPT_THAW_DMA:\r\nopt = OPAL_EEH_ACTION_CLEAR_FREEZE_DMA;\r\nbreak;\r\ncase EEH_OPT_FREEZE_PE:\r\nfreeze_pe = true;\r\nopt = OPAL_EEH_ACTION_SET_FREEZE_ALL;\r\nbreak;\r\ndefault:\r\npr_warn("%s: Invalid option %d\n", __func__, option);\r\nreturn -EINVAL;\r\n}\r\nif (freeze_pe) {\r\nif (phb->freeze_pe) {\r\nphb->freeze_pe(phb, pe->addr);\r\nreturn 0;\r\n}\r\nrc = opal_pci_eeh_freeze_set(phb->opal_id, pe->addr, opt);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld freezing PHB#%x-PE#%x\n",\r\n__func__, rc, phb->hose->global_number,\r\npe->addr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nif (phb->unfreeze_pe)\r\nreturn phb->unfreeze_pe(phb, pe->addr, opt);\r\nrc = opal_pci_eeh_freeze_clear(phb->opal_id, pe->addr, opt);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld enable %d for PHB#%x-PE#%x\n",\r\n__func__, rc, option, phb->hose->global_number,\r\npe->addr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_get_pe_addr(struct eeh_pe *pe)\r\n{\r\nreturn pe->addr;\r\n}\r\nstatic void pnv_eeh_get_phb_diag(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\ns64 rc;\r\nrc = opal_pci_get_phb_diag_data2(phb->opal_id, pe->data,\r\nPNV_PCI_DIAG_BUF_SIZE);\r\nif (rc != OPAL_SUCCESS)\r\npr_warn("%s: Failure %lld getting PHB#%x diag-data\n",\r\n__func__, rc, pe->phb->global_number);\r\n}\r\nstatic int pnv_eeh_get_phb_state(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nu8 fstate;\r\n__be16 pcierr;\r\ns64 rc;\r\nint result = 0;\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id,\r\npe->addr,\r\n&fstate,\r\n&pcierr,\r\nNULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting PHB#%x state\n",\r\n__func__, rc, phb->hose->global_number);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (be16_to_cpu(pcierr) != OPAL_EEH_PHB_ERROR) {\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\n} else if (!(pe->state & EEH_PE_ISOLATED)) {\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\npnv_eeh_get_phb_diag(pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\n}\r\nreturn result;\r\n}\r\nstatic int pnv_eeh_get_pe_state(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nu8 fstate;\r\n__be16 pcierr;\r\ns64 rc;\r\nint result;\r\nif (pe->state & EEH_PE_RESET) {\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\nreturn result;\r\n}\r\nif (phb->get_pe_state) {\r\nfstate = phb->get_pe_state(phb, pe->addr);\r\n} else {\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id,\r\npe->addr,\r\n&fstate,\r\n&pcierr,\r\nNULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting PHB#%x-PE%x state\n",\r\n__func__, rc, phb->hose->global_number,\r\npe->addr);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\n}\r\nswitch (fstate) {\r\ncase OPAL_EEH_STOPPED_NOT_FROZEN:\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_MMIO_FREEZE:\r\nresult = (EEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_DMA_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_DMA_FREEZE:\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_MMIO_DMA_FREEZE:\r\nresult = 0;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_RESET:\r\nresult = EEH_STATE_RESET_ACTIVE;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_TEMP_UNAVAIL:\r\nresult = EEH_STATE_UNAVAILABLE;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_PERM_UNAVAIL:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\nbreak;\r\ndefault:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\npr_warn("%s: Invalid PHB#%x-PE#%x state %x\n",\r\n__func__, phb->hose->global_number,\r\npe->addr, fstate);\r\n}\r\nif (!(result & EEH_STATE_NOT_SUPPORT) &&\r\n!(result & EEH_STATE_UNAVAILABLE) &&\r\n!(result & EEH_STATE_MMIO_ACTIVE) &&\r\n!(result & EEH_STATE_DMA_ACTIVE) &&\r\n!(pe->state & EEH_PE_ISOLATED)) {\r\nif (phb->freeze_pe)\r\nphb->freeze_pe(phb, pe->addr);\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\npnv_eeh_get_phb_diag(pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\n}\r\nreturn result;\r\n}\r\nstatic int pnv_eeh_get_state(struct eeh_pe *pe, int *delay)\r\n{\r\nint ret;\r\nif (pe->type & EEH_PE_PHB)\r\nret = pnv_eeh_get_phb_state(pe);\r\nelse\r\nret = pnv_eeh_get_pe_state(pe);\r\nif (!delay)\r\nreturn ret;\r\n*delay = 0;\r\nif (ret & EEH_STATE_UNAVAILABLE)\r\n*delay = 1000;\r\nreturn ret;\r\n}\r\nstatic s64 pnv_eeh_poll(unsigned long id)\r\n{\r\ns64 rc = OPAL_HARDWARE;\r\nwhile (1) {\r\nrc = opal_pci_poll(id);\r\nif (rc <= 0)\r\nbreak;\r\nif (system_state < SYSTEM_RUNNING)\r\nudelay(1000 * rc);\r\nelse\r\nmsleep(rc);\r\n}\r\nreturn rc;\r\n}\r\nint pnv_eeh_phb_reset(struct pci_controller *hose, int option)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 rc = OPAL_HARDWARE;\r\npr_debug("%s: Reset PHB#%x, option=%d\n",\r\n__func__, hose->global_number, option);\r\nif (option == EEH_RESET_FUNDAMENTAL ||\r\noption == EEH_RESET_HOT)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_COMPLETE,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_DEACTIVATE)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_COMPLETE,\r\nOPAL_DEASSERT_RESET);\r\nif (rc < 0)\r\ngoto out;\r\nif (rc > 0)\r\nrc = pnv_eeh_poll(phb->opal_id);\r\nif (option == EEH_RESET_DEACTIVATE) {\r\nif (system_state < SYSTEM_RUNNING)\r\nudelay(1000 * EEH_PE_RST_SETTLE_TIME);\r\nelse\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\n}\r\nout:\r\nif (rc != OPAL_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_root_reset(struct pci_controller *hose, int option)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 rc = OPAL_HARDWARE;\r\npr_debug("%s: Reset PHB#%x, option=%d\n",\r\n__func__, hose->global_number, option);\r\nif (option == EEH_RESET_FUNDAMENTAL)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_FUNDAMENTAL,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_HOT)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_HOT,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_DEACTIVATE)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_HOT,\r\nOPAL_DEASSERT_RESET);\r\nif (rc < 0)\r\ngoto out;\r\nif (rc > 0)\r\nrc = pnv_eeh_poll(phb->opal_id);\r\nif (option == EEH_RESET_DEACTIVATE)\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nout:\r\nif (rc != OPAL_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int __pnv_eeh_bridge_reset(struct pci_dev *dev, int option)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nint aer = edev ? edev->aer_cap : 0;\r\nu32 ctrl;\r\npr_debug("%s: Reset PCI bus %04x:%02x with option %d\n",\r\n__func__, pci_domain_nr(dev->bus),\r\ndev->bus->number, option);\r\nswitch (option) {\r\ncase EEH_RESET_FUNDAMENTAL:\r\ncase EEH_RESET_HOT:\r\nif (aer) {\r\neeh_ops->read_config(pdn, aer + PCI_ERR_UNCOR_MASK,\r\n4, &ctrl);\r\nctrl |= PCI_ERR_UNC_SURPDN;\r\neeh_ops->write_config(pdn, aer + PCI_ERR_UNCOR_MASK,\r\n4, ctrl);\r\n}\r\neeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &ctrl);\r\nctrl |= PCI_BRIDGE_CTL_BUS_RESET;\r\neeh_ops->write_config(pdn, PCI_BRIDGE_CONTROL, 2, ctrl);\r\nmsleep(EEH_PE_RST_HOLD_TIME);\r\nbreak;\r\ncase EEH_RESET_DEACTIVATE:\r\neeh_ops->read_config(pdn, PCI_BRIDGE_CONTROL, 2, &ctrl);\r\nctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;\r\neeh_ops->write_config(pdn, PCI_BRIDGE_CONTROL, 2, ctrl);\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nif (aer) {\r\neeh_ops->read_config(pdn, aer + PCI_ERR_UNCOR_MASK,\r\n4, &ctrl);\r\nctrl &= ~PCI_ERR_UNC_SURPDN;\r\neeh_ops->write_config(pdn, aer + PCI_ERR_UNCOR_MASK,\r\n4, ctrl);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_bridge_reset(struct pci_dev *pdev, int option)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct device_node *dn = pci_device_to_OF_node(pdev);\r\nuint64_t id = PCI_SLOT_ID(phb->opal_id,\r\n(pdev->bus->number << 8) | pdev->devfn);\r\nuint8_t scope;\r\nint64_t rc;\r\nif (!dn || !of_get_property(dn, "ibm,reset-by-firmware", NULL))\r\nreturn __pnv_eeh_bridge_reset(pdev, option);\r\nswitch (option) {\r\ncase EEH_RESET_FUNDAMENTAL:\r\nscope = OPAL_RESET_PCI_FUNDAMENTAL;\r\nbreak;\r\ncase EEH_RESET_HOT:\r\nscope = OPAL_RESET_PCI_HOT;\r\nbreak;\r\ncase EEH_RESET_DEACTIVATE:\r\nreturn 0;\r\ndefault:\r\ndev_dbg(&pdev->dev, "%s: Unsupported reset %d\n",\r\n__func__, option);\r\nreturn -EINVAL;\r\n}\r\nrc = opal_pci_reset(id, scope, OPAL_ASSERT_RESET);\r\nif (rc <= OPAL_SUCCESS)\r\ngoto out;\r\nrc = pnv_eeh_poll(id);\r\nout:\r\nreturn (rc == OPAL_SUCCESS) ? 0 : -EIO;\r\n}\r\nvoid pnv_pci_reset_secondary_bus(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose;\r\nif (pci_is_root_bus(dev->bus)) {\r\nhose = pci_bus_to_host(dev->bus);\r\npnv_eeh_root_reset(hose, EEH_RESET_HOT);\r\npnv_eeh_root_reset(hose, EEH_RESET_DEACTIVATE);\r\n} else {\r\npnv_eeh_bridge_reset(dev, EEH_RESET_HOT);\r\npnv_eeh_bridge_reset(dev, EEH_RESET_DEACTIVATE);\r\n}\r\n}\r\nstatic void pnv_eeh_wait_for_pending(struct pci_dn *pdn, const char *type,\r\nint pos, u16 mask)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nint i, status = 0;\r\nfor (i = 0; i < 4; i++) {\r\neeh_ops->read_config(pdn, pos, 2, &status);\r\nif (!(status & mask))\r\nreturn;\r\nmsleep((1 << i) * 100);\r\n}\r\npr_warn("%s: Pending transaction while issuing %sFLR to %04x:%02x:%02x.%01x\n",\r\n__func__, type,\r\nedev->phb->global_number, pdn->busno,\r\nPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\r\n}\r\nstatic int pnv_eeh_do_flr(struct pci_dn *pdn, int option)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nu32 reg = 0;\r\nif (WARN_ON(!edev->pcie_cap))\r\nreturn -ENOTTY;\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCAP, 4, &reg);\r\nif (!(reg & PCI_EXP_DEVCAP_FLR))\r\nreturn -ENOTTY;\r\nswitch (option) {\r\ncase EEH_RESET_HOT:\r\ncase EEH_RESET_FUNDAMENTAL:\r\npnv_eeh_wait_for_pending(pdn, "",\r\nedev->pcie_cap + PCI_EXP_DEVSTA,\r\nPCI_EXP_DEVSTA_TRPND);\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n4, &reg);\r\nreg |= PCI_EXP_DEVCTL_BCR_FLR;\r\neeh_ops->write_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n4, reg);\r\nmsleep(EEH_PE_RST_HOLD_TIME);\r\nbreak;\r\ncase EEH_RESET_DEACTIVATE:\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n4, &reg);\r\nreg &= ~PCI_EXP_DEVCTL_BCR_FLR;\r\neeh_ops->write_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n4, reg);\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_do_af_flr(struct pci_dn *pdn, int option)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nu32 cap = 0;\r\nif (WARN_ON(!edev->af_cap))\r\nreturn -ENOTTY;\r\neeh_ops->read_config(pdn, edev->af_cap + PCI_AF_CAP, 1, &cap);\r\nif (!(cap & PCI_AF_CAP_TP) || !(cap & PCI_AF_CAP_FLR))\r\nreturn -ENOTTY;\r\nswitch (option) {\r\ncase EEH_RESET_HOT:\r\ncase EEH_RESET_FUNDAMENTAL:\r\npnv_eeh_wait_for_pending(pdn, "AF",\r\nedev->af_cap + PCI_AF_CTRL,\r\nPCI_AF_STATUS_TP << 8);\r\neeh_ops->write_config(pdn, edev->af_cap + PCI_AF_CTRL,\r\n1, PCI_AF_CTRL_FLR);\r\nmsleep(EEH_PE_RST_HOLD_TIME);\r\nbreak;\r\ncase EEH_RESET_DEACTIVATE:\r\neeh_ops->write_config(pdn, edev->af_cap + PCI_AF_CTRL, 1, 0);\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_reset_vf_pe(struct eeh_pe *pe, int option)\r\n{\r\nstruct eeh_dev *edev;\r\nstruct pci_dn *pdn;\r\nint ret;\r\nedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, list);\r\npdn = eeh_dev_to_pdn(edev);\r\nif (!pdn)\r\nreturn -ENXIO;\r\nret = pnv_eeh_do_flr(pdn, option);\r\nif (!ret)\r\nreturn ret;\r\nreturn pnv_eeh_do_af_flr(pdn, option);\r\n}\r\nstatic int pnv_eeh_reset(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb;\r\nstruct pci_bus *bus;\r\nint64_t rc;\r\nif (pe->type & EEH_PE_PHB)\r\nreturn pnv_eeh_phb_reset(hose, option);\r\nphb = hose->private_data;\r\nif (phb->model == PNV_PHB_MODEL_P7IOC &&\r\n(option == EEH_RESET_HOT ||\r\noption == EEH_RESET_FUNDAMENTAL)) {\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_ERROR,\r\nOPAL_ASSERT_RESET);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld clearing error injection registers\n",\r\n__func__, rc);\r\nreturn -EIO;\r\n}\r\n}\r\nif (pe->type & EEH_PE_VF)\r\nreturn pnv_eeh_reset_vf_pe(pe, option);\r\nbus = eeh_pe_bus_get(pe);\r\nif (!bus) {\r\npr_err("%s: Cannot find PCI bus for PHB#%x-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->addr);\r\nreturn -EIO;\r\n}\r\nif (pci_is_root_bus(bus) ||\r\npci_is_root_bus(bus->parent))\r\nreturn pnv_eeh_root_reset(hose, option);\r\nreturn pnv_eeh_bridge_reset(bus->self, option);\r\n}\r\nstatic int pnv_eeh_wait_state(struct eeh_pe *pe, int max_wait)\r\n{\r\nint ret;\r\nint mwait;\r\nwhile (1) {\r\nret = pnv_eeh_get_state(pe, &mwait);\r\nif (ret != EEH_STATE_UNAVAILABLE)\r\nreturn ret;\r\nif (max_wait <= 0) {\r\npr_warn("%s: Timeout getting PE#%x's state (%d)\n",\r\n__func__, pe->addr, max_wait);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nmax_wait -= mwait;\r\nmsleep(mwait);\r\n}\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nstatic int pnv_eeh_get_log(struct eeh_pe *pe, int severity,\r\nchar *drv_log, unsigned long len)\r\n{\r\nif (!eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_configure_bridge(struct eeh_pe *pe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_err_inject(struct eeh_pe *pe, int type, int func,\r\nunsigned long addr, unsigned long mask)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 rc;\r\nif (type != OPAL_ERR_INJECT_TYPE_IOA_BUS_ERR &&\r\ntype != OPAL_ERR_INJECT_TYPE_IOA_BUS_ERR64) {\r\npr_warn("%s: Invalid error type %d\n",\r\n__func__, type);\r\nreturn -ERANGE;\r\n}\r\nif (func < OPAL_ERR_INJECT_FUNC_IOA_LD_MEM_ADDR ||\r\nfunc > OPAL_ERR_INJECT_FUNC_IOA_DMA_WR_TARGET) {\r\npr_warn("%s: Invalid error function %d\n",\r\n__func__, func);\r\nreturn -ERANGE;\r\n}\r\nif (!opal_check_token(OPAL_PCI_ERR_INJECT)) {\r\npr_warn("%s: Firmware doesn't support error injection\n",\r\n__func__);\r\nreturn -ENXIO;\r\n}\r\nrc = opal_pci_err_inject(phb->opal_id, pe->addr,\r\ntype, func, addr, mask);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld injecting error "\r\n"%d-%d to PHB#%x-PE#%x\n",\r\n__func__, rc, type, func,\r\nhose->global_number, pe->addr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool pnv_eeh_cfg_blocked(struct pci_dn *pdn)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nif (!edev || !edev->pe)\r\nreturn false;\r\nif (edev->physfn && (edev->pe->state & EEH_PE_RESET))\r\nreturn false;\r\nif (edev->pe->state & EEH_PE_CFG_BLOCKED)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int pnv_eeh_read_config(struct pci_dn *pdn,\r\nint where, int size, u32 *val)\r\n{\r\nif (!pdn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (pnv_eeh_cfg_blocked(pdn)) {\r\n*val = 0xFFFFFFFF;\r\nreturn PCIBIOS_SET_FAILED;\r\n}\r\nreturn pnv_pci_cfg_read(pdn, where, size, val);\r\n}\r\nstatic int pnv_eeh_write_config(struct pci_dn *pdn,\r\nint where, int size, u32 val)\r\n{\r\nif (!pdn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (pnv_eeh_cfg_blocked(pdn))\r\nreturn PCIBIOS_SET_FAILED;\r\nreturn pnv_pci_cfg_write(pdn, where, size, val);\r\n}\r\nstatic void pnv_eeh_dump_hub_diag_common(struct OpalIoP7IOCErrorData *data)\r\n{\r\nif (data->gemXfir || data->gemRfir ||\r\ndata->gemRirqfir || data->gemMask || data->gemRwof)\r\npr_info(" GEM: %016llx %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->gemXfir),\r\nbe64_to_cpu(data->gemRfir),\r\nbe64_to_cpu(data->gemRirqfir),\r\nbe64_to_cpu(data->gemMask),\r\nbe64_to_cpu(data->gemRwof));\r\nif (data->lemFir || data->lemErrMask ||\r\ndata->lemAction0 || data->lemAction1 || data->lemWof)\r\npr_info(" LEM: %016llx %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->lemFir),\r\nbe64_to_cpu(data->lemErrMask),\r\nbe64_to_cpu(data->lemAction0),\r\nbe64_to_cpu(data->lemAction1),\r\nbe64_to_cpu(data->lemWof));\r\n}\r\nstatic void pnv_eeh_get_and_dump_hub_diag(struct pci_controller *hose)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct OpalIoP7IOCErrorData *data = &phb->diag.hub_diag;\r\nlong rc;\r\nrc = opal_pci_get_hub_diag_data(phb->hub_id, data, sizeof(*data));\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failed to get HUB#%llx diag-data (%ld)\n",\r\n__func__, phb->hub_id, rc);\r\nreturn;\r\n}\r\nswitch (be16_to_cpu(data->type)) {\r\ncase OPAL_P7IOC_DIAG_TYPE_RGC:\r\npr_info("P7IOC diag-data for RGC\n\n");\r\npnv_eeh_dump_hub_diag_common(data);\r\nif (data->rgc.rgcStatus || data->rgc.rgcLdcp)\r\npr_info(" RGC: %016llx %016llx\n",\r\nbe64_to_cpu(data->rgc.rgcStatus),\r\nbe64_to_cpu(data->rgc.rgcLdcp));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_BI:\r\npr_info("P7IOC diag-data for BI %s\n\n",\r\ndata->bi.biDownbound ? "Downbound" : "Upbound");\r\npnv_eeh_dump_hub_diag_common(data);\r\nif (data->bi.biLdcp0 || data->bi.biLdcp1 ||\r\ndata->bi.biLdcp2 || data->bi.biFenceStatus)\r\npr_info(" BI: %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->bi.biLdcp0),\r\nbe64_to_cpu(data->bi.biLdcp1),\r\nbe64_to_cpu(data->bi.biLdcp2),\r\nbe64_to_cpu(data->bi.biFenceStatus));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_CI:\r\npr_info("P7IOC diag-data for CI Port %d\n\n",\r\ndata->ci.ciPort);\r\npnv_eeh_dump_hub_diag_common(data);\r\nif (data->ci.ciPortStatus || data->ci.ciPortLdcp)\r\npr_info(" CI: %016llx %016llx\n",\r\nbe64_to_cpu(data->ci.ciPortStatus),\r\nbe64_to_cpu(data->ci.ciPortLdcp));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_MISC:\r\npr_info("P7IOC diag-data for MISC\n\n");\r\npnv_eeh_dump_hub_diag_common(data);\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_I2C:\r\npr_info("P7IOC diag-data for I2C\n\n");\r\npnv_eeh_dump_hub_diag_common(data);\r\nbreak;\r\ndefault:\r\npr_warn("%s: Invalid type of HUB#%llx diag-data (%d)\n",\r\n__func__, phb->hub_id, data->type);\r\n}\r\n}\r\nstatic int pnv_eeh_get_pe(struct pci_controller *hose,\r\nu16 pe_no, struct eeh_pe **pe)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *pnv_pe;\r\nstruct eeh_pe *dev_pe;\r\nstruct eeh_dev edev;\r\npnv_pe = &phb->ioda.pe_array[pe_no];\r\nif (pnv_pe->flags & PNV_IODA_PE_SLAVE) {\r\npnv_pe = pnv_pe->master;\r\nWARN_ON(!pnv_pe ||\r\n!(pnv_pe->flags & PNV_IODA_PE_MASTER));\r\npe_no = pnv_pe->pe_number;\r\n}\r\nmemset(&edev, 0, sizeof(struct eeh_dev));\r\nedev.phb = hose;\r\nedev.pe_config_addr = pe_no;\r\ndev_pe = eeh_pe_get(&edev);\r\nif (!dev_pe)\r\nreturn -EEXIST;\r\n*pe = dev_pe;\r\nif (!(dev_pe->state & EEH_PE_ISOLATED))\r\nphb->freeze_pe(phb, pe_no);\r\ndev_pe = dev_pe->parent;\r\nwhile (dev_pe && !(dev_pe->type & EEH_PE_PHB)) {\r\nint ret;\r\nint active_flags = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE);\r\nret = eeh_ops->get_state(dev_pe, NULL);\r\nif (ret <= 0 || (ret & active_flags) == active_flags) {\r\ndev_pe = dev_pe->parent;\r\ncontinue;\r\n}\r\n*pe = dev_pe;\r\nif (!(dev_pe->state & EEH_PE_ISOLATED))\r\nphb->freeze_pe(phb, dev_pe->addr);\r\ndev_pe = dev_pe->parent;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_next_error(struct eeh_pe **pe)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct eeh_pe *phb_pe, *parent_pe;\r\n__be64 frozen_pe_no;\r\n__be16 err_type, severity;\r\nint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\r\nlong rc;\r\nint state, ret = EEH_NEXT_ERR_NONE;\r\neeh_remove_event(NULL, false);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe || (phb_pe->state & EEH_PE_ISOLATED))\r\ncontinue;\r\nrc = opal_pci_next_error(phb->opal_id,\r\n&frozen_pe_no, &err_type, &severity);\r\nif (rc != OPAL_SUCCESS) {\r\npr_devel("%s: Invalid return value on "\r\n"PHB#%x (0x%lx) from opal_pci_next_error",\r\n__func__, hose->global_number, rc);\r\ncontinue;\r\n}\r\nif (be16_to_cpu(err_type) == OPAL_EEH_NO_ERROR ||\r\nbe16_to_cpu(severity) == OPAL_EEH_SEV_NO_ERROR) {\r\npr_devel("%s: No error found on PHB#%x\n",\r\n__func__, hose->global_number);\r\ncontinue;\r\n}\r\npr_devel("%s: Error (%d, %d, %llu) on PHB#%x\n",\r\n__func__, be16_to_cpu(err_type),\r\nbe16_to_cpu(severity), be64_to_cpu(frozen_pe_no),\r\nhose->global_number);\r\nswitch (be16_to_cpu(err_type)) {\r\ncase OPAL_EEH_IOC_ERROR:\r\nif (be16_to_cpu(severity) == OPAL_EEH_SEV_IOC_DEAD) {\r\npr_err("EEH: dead IOC detected\n");\r\nret = EEH_NEXT_ERR_DEAD_IOC;\r\n} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {\r\npr_info("EEH: IOC informative error "\r\n"detected\n");\r\npnv_eeh_get_and_dump_hub_diag(hose);\r\nret = EEH_NEXT_ERR_NONE;\r\n}\r\nbreak;\r\ncase OPAL_EEH_PHB_ERROR:\r\nif (be16_to_cpu(severity) == OPAL_EEH_SEV_PHB_DEAD) {\r\n*pe = phb_pe;\r\npr_err("EEH: dead PHB#%x detected, "\r\n"location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_DEAD_PHB;\r\n} else if (be16_to_cpu(severity) ==\r\nOPAL_EEH_SEV_PHB_FENCED) {\r\n*pe = phb_pe;\r\npr_err("EEH: Fenced PHB#%x detected, "\r\n"location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_FENCED_PHB;\r\n} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {\r\npr_info("EEH: PHB#%x informative error "\r\n"detected, location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\npnv_eeh_get_phb_diag(phb_pe);\r\npnv_pci_dump_phb_diag_data(hose, phb_pe->data);\r\nret = EEH_NEXT_ERR_NONE;\r\n}\r\nbreak;\r\ncase OPAL_EEH_PE_ERROR:\r\nif (pnv_eeh_get_pe(hose,\r\nbe64_to_cpu(frozen_pe_no), pe)) {\r\npr_info("EEH: Clear non-existing PHB#%x-PE#%llx\n",\r\nhose->global_number, be64_to_cpu(frozen_pe_no));\r\npr_info("EEH: PHB location: %s\n",\r\neeh_pe_loc_get(phb_pe));\r\nrc = opal_pci_get_phb_diag_data2(phb->opal_id,\r\nphb->diag.blob, PNV_PCI_DIAG_BUF_SIZE);\r\nif (rc == OPAL_SUCCESS)\r\npnv_pci_dump_phb_diag_data(hose,\r\nphb->diag.blob);\r\nopal_pci_eeh_freeze_clear(phb->opal_id,\r\nbe64_to_cpu(frozen_pe_no),\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\nret = EEH_NEXT_ERR_NONE;\r\n} else if ((*pe)->state & EEH_PE_ISOLATED ||\r\neeh_pe_passed(*pe)) {\r\nret = EEH_NEXT_ERR_NONE;\r\n} else {\r\npr_err("EEH: Frozen PE#%x "\r\n"on PHB#%x detected\n",\r\n(*pe)->addr,\r\n(*pe)->phb->global_number);\r\npr_err("EEH: PE location: %s, "\r\n"PHB location: %s\n",\r\neeh_pe_loc_get(*pe),\r\neeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_FROZEN_PE;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("%s: Unexpected error type %d\n",\r\n__func__, be16_to_cpu(err_type));\r\n}\r\nif ((ret == EEH_NEXT_ERR_FROZEN_PE ||\r\nret == EEH_NEXT_ERR_FENCED_PHB) &&\r\n!((*pe)->state & EEH_PE_ISOLATED)) {\r\neeh_pe_state_mark(*pe, EEH_PE_ISOLATED);\r\npnv_eeh_get_phb_diag(*pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data((*pe)->phb,\r\n(*pe)->data);\r\n}\r\nif (ret == EEH_NEXT_ERR_FROZEN_PE) {\r\nparent_pe = (*pe)->parent;\r\nwhile (parent_pe) {\r\nif (parent_pe->type & EEH_PE_PHB)\r\nbreak;\r\nstate = eeh_ops->get_state(parent_pe, NULL);\r\nif (state > 0 &&\r\n(state & active_flags) != active_flags)\r\n*pe = parent_pe;\r\nparent_pe = parent_pe->parent;\r\n}\r\neeh_pe_state_mark(*pe, EEH_PE_ISOLATED);\r\n}\r\nif (ret > EEH_NEXT_ERR_INF)\r\nbreak;\r\n}\r\nif (ret == EEH_NEXT_ERR_NONE && eeh_enabled())\r\nenable_irq(eeh_event_irq);\r\nreturn ret;\r\n}\r\nstatic int pnv_eeh_restore_vf_config(struct pci_dn *pdn)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nu32 devctl, cmd, cap2, aer_capctl;\r\nint old_mps;\r\nif (edev->pcie_cap) {\r\nold_mps = (ffs(pdn->mps) - 8) << 5;\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n2, &devctl);\r\ndevctl &= ~PCI_EXP_DEVCTL_PAYLOAD;\r\ndevctl |= old_mps;\r\neeh_ops->write_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n2, devctl);\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCAP2,\r\n4, &cap2);\r\nif (cap2 & 0x10) {\r\neeh_ops->read_config(pdn,\r\nedev->pcie_cap + PCI_EXP_DEVCTL2,\r\n4, &cap2);\r\ncap2 |= 0x10;\r\neeh_ops->write_config(pdn,\r\nedev->pcie_cap + PCI_EXP_DEVCTL2,\r\n4, cap2);\r\n}\r\n}\r\neeh_ops->read_config(pdn, PCI_COMMAND, 2, &cmd);\r\ncmd |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\neeh_ops->write_config(pdn, PCI_COMMAND, 2, cmd);\r\nif (edev->pcie_cap) {\r\neeh_ops->read_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n2, &devctl);\r\ndevctl &= ~PCI_EXP_DEVCTL_CERE;\r\ndevctl |= (PCI_EXP_DEVCTL_NFERE |\r\nPCI_EXP_DEVCTL_FERE |\r\nPCI_EXP_DEVCTL_URRE);\r\neeh_ops->write_config(pdn, edev->pcie_cap + PCI_EXP_DEVCTL,\r\n2, devctl);\r\n}\r\nif (edev->pcie_cap && edev->aer_cap) {\r\neeh_ops->read_config(pdn, edev->aer_cap + PCI_ERR_CAP,\r\n4, &aer_capctl);\r\naer_capctl |= (PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\r\neeh_ops->write_config(pdn, edev->aer_cap + PCI_ERR_CAP,\r\n4, aer_capctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pnv_eeh_restore_config(struct pci_dn *pdn)\r\n{\r\nstruct eeh_dev *edev = pdn_to_eeh_dev(pdn);\r\nstruct pnv_phb *phb;\r\ns64 ret;\r\nif (!edev)\r\nreturn -EEXIST;\r\nif (edev->physfn) {\r\nret = pnv_eeh_restore_vf_config(pdn);\r\n} else {\r\nphb = edev->phb->private_data;\r\nret = opal_pci_reinit(phb->opal_id,\r\nOPAL_REINIT_PCI_DEV, edev->config_addr);\r\n}\r\nif (ret) {\r\npr_warn("%s: Can't reinit PCI dev 0x%x (%lld)\n",\r\n__func__, edev->config_addr, ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid pcibios_bus_add_device(struct pci_dev *pdev)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nif (!pdev->is_virtfn)\r\nreturn;\r\neeh_add_device_early(pdn);\r\neeh_add_device_late(pdev);\r\neeh_sysfs_add_device(pdev);\r\n}\r\nstatic void pnv_pci_fixup_vf_mps(struct pci_dev *pdev)\r\n{\r\nstruct pci_dn *pdn = pci_get_pdn(pdev);\r\nint parent_mps;\r\nif (!pdev->is_virtfn)\r\nreturn;\r\nparent_mps = pcie_get_mps(pdev->physfn);\r\nif ((128 << pdev->pcie_mpss) >= parent_mps)\r\npcie_set_mps(pdev, parent_mps);\r\npdn->mps = pcie_get_mps(pdev);\r\n}\r\nstatic int __init eeh_powernv_init(void)\r\n{\r\nint ret = -EINVAL;\r\neeh_set_pe_aux_size(PNV_PCI_DIAG_BUF_SIZE);\r\nret = eeh_ops_register(&pnv_eeh_ops);\r\nif (!ret)\r\npr_info("EEH: PowerNV platform initialized\n");\r\nelse\r\npr_info("EEH: Failed to initialize PowerNV platform (%d)\n", ret);\r\nreturn ret;\r\n}
