static int netup_read_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,\r\nu8 *buf, int len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = addr,\r\n.flags = 0,\r\n.buf = &reg,\r\n.len = 1\r\n}, {\r\n.addr = addr,\r\n.flags = I2C_M_RD,\r\n.buf = buf,\r\n.len = len\r\n}\r\n};\r\nret = i2c_transfer(i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nci_dbg_print("%s: i2c read error, Reg = 0x%02x, Status = %d\n",\r\n__func__, reg, ret);\r\nreturn -1;\r\n}\r\nci_dbg_print("%s: i2c read Addr=0x%04x, Reg = 0x%02x, data = %02x\n",\r\n__func__, addr, reg, buf[0]);\r\nreturn 0;\r\n}\r\nstatic int netup_write_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,\r\nu8 *buf, int len)\r\n{\r\nint ret;\r\nu8 buffer[MAX_XFER_SIZE];\r\nstruct i2c_msg msg = {\r\n.addr = addr,\r\n.flags = 0,\r\n.buf = &buffer[0],\r\n.len = len + 1\r\n};\r\nif (1 + len > sizeof(buffer)) {\r\npr_warn("%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuffer[0] = reg;\r\nmemcpy(&buffer[1], buf, len);\r\nret = i2c_transfer(i2c_adap, &msg, 1);\r\nif (ret != 1) {\r\nci_dbg_print("%s: i2c write error, Reg=[0x%02x], Status=%d\n",\r\n__func__, reg, ret);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int netup_ci_get_mem(struct cx23885_dev *dev)\r\n{\r\nint mem;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1);\r\nfor (;;) {\r\nmem = cx_read(MC417_RWD);\r\nif ((mem & NETUP_ACK) == 0)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nudelay(1);\r\n}\r\ncx_set(MC417_RWD, NETUP_CTRL_OFF);\r\nreturn mem & 0xff;\r\n}\r\nstatic int netup_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot,\r\nu8 flag, u8 read, int addr, u8 data)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nstruct cx23885_tsport *port = state->priv;\r\nstruct cx23885_dev *dev = port->dev;\r\nu8 store;\r\nint mem;\r\nint ret;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nif (state->current_ci_flag != flag) {\r\nret = netup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &store, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nstore &= ~0x0c;\r\nstore |= flag;\r\nret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &store, 1);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nstate->current_ci_flag = flag;\r\nmutex_lock(&dev->gpio_lock);\r\ncx_write(MC417_OEN, NETUP_EN_ALL);\r\ncx_write(MC417_RWD, NETUP_CTRL_OFF |\r\nNETUP_ADLO | (0xff & addr));\r\ncx_clear(MC417_RWD, NETUP_ADLO);\r\ncx_write(MC417_RWD, NETUP_CTRL_OFF |\r\nNETUP_ADHI | (0xff & (addr >> 8)));\r\ncx_clear(MC417_RWD, NETUP_ADHI);\r\nif (read) {\r\ncx_write(MC417_OEN, NETUP_EN_ALL | NETUP_DATA);\r\n} else\r\ncx_write(MC417_RWD, NETUP_CTRL_OFF | data);\r\ncx_clear(MC417_RWD,\r\n(state->ci_i2c_addr == 0x40) ? NETUP_CS0 : NETUP_CS1);\r\ncx_clear(MC417_RWD, (read) ? NETUP_RD : NETUP_WR);\r\nmem = netup_ci_get_mem(dev);\r\nmutex_unlock(&dev->gpio_lock);\r\nif (!read)\r\nif (mem < 0)\r\nreturn -EREMOTEIO;\r\nci_dbg_print("%s: %s: chipaddr=[0x%x] addr=[0x%02x], %s=%x\n", __func__,\r\n(read) ? "read" : "write", state->ci_i2c_addr, addr,\r\n(flag == NETUP_CI_CTL) ? "ctl" : "mem",\r\n(read) ? mem : data);\r\nif (read)\r\nreturn mem;\r\nreturn 0;\r\n}\r\nint netup_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr)\r\n{\r\nreturn netup_ci_op_cam(en50221, slot, 0, NETUP_CI_RD, addr, 0);\r\n}\r\nint netup_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr, u8 data)\r\n{\r\nreturn netup_ci_op_cam(en50221, slot, 0, 0, addr, data);\r\n}\r\nint netup_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\r\nu8 addr)\r\n{\r\nreturn netup_ci_op_cam(en50221, slot, NETUP_CI_CTL,\r\nNETUP_CI_RD, addr, 0);\r\n}\r\nint netup_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\r\nu8 addr, u8 data)\r\n{\r\nreturn netup_ci_op_cam(en50221, slot, NETUP_CI_CTL, 0, addr, data);\r\n}\r\nint netup_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nu8 buf = 0x80;\r\nint ret;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nudelay(500);\r\nret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &buf, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nudelay(500);\r\nbuf = 0x00;\r\nret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &buf, 1);\r\nmsleep(1000);\r\ndvb_ca_en50221_camready_irq(&state->ca, 0);\r\nreturn 0;\r\n}\r\nint netup_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nreturn 0;\r\n}\r\nstatic int netup_ci_set_irq(struct dvb_ca_en50221 *en50221, u8 irq_mode)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nint ret;\r\nif (irq_mode == state->current_irq_mode)\r\nreturn 0;\r\nci_dbg_print("%s: chipaddr=[0x%x] setting ci IRQ to [0x%x] \n",\r\n__func__, state->ci_i2c_addr, irq_mode);\r\nret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0x1b, &irq_mode, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nstate->current_irq_mode = irq_mode;\r\nreturn 0;\r\n}\r\nint netup_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nu8 buf;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nnetup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &buf, 1);\r\nbuf |= 0x60;\r\nreturn netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &buf, 1);\r\n}\r\nstatic void netup_read_ci_status(struct work_struct *work)\r\n{\r\nstruct netup_ci_state *state =\r\ncontainer_of(work, struct netup_ci_state, work);\r\nu8 buf[33];\r\nint ret;\r\ndvb_ca_en50221_frda_irq(&state->ca, 0);\r\nif (time_after(jiffies, state->next_status_checked_time)\r\n|| !state->status) {\r\nret = netup_read_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &buf[0], 33);\r\nstate->next_status_checked_time = jiffies\r\n+ msecs_to_jiffies(1000);\r\nif (ret != 0)\r\nreturn;\r\nci_dbg_print("%s: Slot Status Addr=[0x%04x], Reg=[0x%02x], data=%02x, TS config = %02x\n",\r\n__func__, state->ci_i2c_addr, 0, buf[0], buf[0]);\r\nif (buf[0] & 1)\r\nstate->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\nelse\r\nstate->status = 0;\r\n}\r\n}\r\nint netup_ci_slot_status(struct cx23885_dev *dev, u32 pci_status)\r\n{\r\nstruct cx23885_tsport *port = NULL;\r\nstruct netup_ci_state *state = NULL;\r\nci_dbg_print("%s:\n", __func__);\r\nif (0 == (pci_status & (PCI_MSK_GPIO0 | PCI_MSK_GPIO1)))\r\nreturn 0;\r\nif (pci_status & PCI_MSK_GPIO0) {\r\nport = &dev->ts1;\r\nstate = port->port_priv;\r\nschedule_work(&state->work);\r\nci_dbg_print("%s: Wakeup CI0\n", __func__);\r\n}\r\nif (pci_status & PCI_MSK_GPIO1) {\r\nport = &dev->ts2;\r\nstate = port->port_priv;\r\nschedule_work(&state->work);\r\nci_dbg_print("%s: Wakeup CI1\n", __func__);\r\n}\r\nreturn 1;\r\n}\r\nint netup_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\r\nint slot, int open)\r\n{\r\nstruct netup_ci_state *state = en50221->data;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nnetup_ci_set_irq(en50221, open ? (NETUP_IRQ_DETAM | ci_irq_flags())\r\n: NETUP_IRQ_DETAM);\r\nreturn state->status;\r\n}\r\nint netup_ci_init(struct cx23885_tsport *port)\r\n{\r\nstruct netup_ci_state *state;\r\nu8 cimax_init[34] = {\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x44,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x44,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x02,\r\n0x01,\r\n0x00,\r\n0x00,\r\nci_irq_flags() | NETUP_IRQ_DETAM,\r\n0x05,\r\n0x00,\r\n0x04,\r\n0x00,\r\n0x33,\r\n0x31,\r\n};\r\nint ret;\r\nci_dbg_print("%s\n", __func__);\r\nstate = kzalloc(sizeof(struct netup_ci_state), GFP_KERNEL);\r\nif (!state) {\r\nci_dbg_print("%s: Unable create CI structure!\n", __func__);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nport->port_priv = state;\r\nswitch (port->nr) {\r\ncase 1:\r\nstate->ci_i2c_addr = 0x40;\r\nbreak;\r\ncase 2:\r\nstate->ci_i2c_addr = 0x41;\r\nbreak;\r\n}\r\nstate->i2c_adap = &port->dev->i2c_bus[0].i2c_adap;\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = netup_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = netup_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = netup_ci_read_cam_ctl;\r\nstate->ca.write_cam_control = netup_ci_write_cam_ctl;\r\nstate->ca.slot_reset = netup_ci_slot_reset;\r\nstate->ca.slot_shutdown = netup_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = netup_ci_slot_ts_ctl;\r\nstate->ca.poll_slot_status = netup_poll_ci_slot_status;\r\nstate->ca.data = state;\r\nstate->priv = port;\r\nstate->current_irq_mode = ci_irq_flags() | NETUP_IRQ_DETAM;\r\nret = netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0, &cimax_init[0], 34);\r\nret |= netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0x1f, &cimax_init[0x18], 1);\r\nret |= netup_write_i2c(state->i2c_adap, state->ci_i2c_addr,\r\n0x18, &cimax_init[0x18], 1);\r\nif (0 != ret)\r\ngoto err;\r\nret = dvb_ca_en50221_init(&port->frontends.adapter,\r\n&state->ca,\r\n0,\r\n1);\r\nif (0 != ret)\r\ngoto err;\r\nINIT_WORK(&state->work, netup_read_ci_status);\r\nschedule_work(&state->work);\r\nci_dbg_print("%s: CI initialized!\n", __func__);\r\nreturn 0;\r\nerr:\r\nci_dbg_print("%s: Cannot initialize CI: Error %d.\n", __func__, ret);\r\nkfree(state);\r\nreturn ret;\r\n}\r\nvoid netup_ci_exit(struct cx23885_tsport *port)\r\n{\r\nstruct netup_ci_state *state;\r\nif (NULL == port)\r\nreturn;\r\nstate = (struct netup_ci_state *)port->port_priv;\r\nif (NULL == state)\r\nreturn;\r\nif (NULL == state->ca.data)\r\nreturn;\r\ndvb_ca_en50221_release(&state->ca);\r\nkfree(state);\r\n}
