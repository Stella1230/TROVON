static ssize_t show_label(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nif (tdata->is_pkg_data)\r\nreturn sprintf(buf, "Package id %u\n", pdata->pkg_id);\r\nreturn sprintf(buf, "Core %u\n", tdata->cpu_core_id);\r\n}\r\nstatic ssize_t show_crit_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nu32 eax, edx;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nmutex_lock(&tdata->update_lock);\r\nrdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\r\nmutex_unlock(&tdata->update_lock);\r\nreturn sprintf(buf, "%d\n", (eax >> 5) & 1);\r\n}\r\nstatic ssize_t show_tjmax(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", pdata->core_data[attr->index]->tjmax);\r\n}\r\nstatic ssize_t show_ttarget(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", pdata->core_data[attr->index]->ttarget);\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nu32 eax, edx;\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct platform_data *pdata = dev_get_drvdata(dev);\r\nstruct temp_data *tdata = pdata->core_data[attr->index];\r\nmutex_lock(&tdata->update_lock);\r\nif (!tdata->valid || time_after(jiffies, tdata->last_updated + HZ)) {\r\nrdmsr_on_cpu(tdata->cpu, tdata->status_reg, &eax, &edx);\r\ntdata->temp = tdata->tjmax - ((eax >> 16) & 0x7f) * 1000;\r\ntdata->valid = 1;\r\ntdata->last_updated = jiffies;\r\n}\r\nmutex_unlock(&tdata->update_lock);\r\nreturn sprintf(buf, "%d\n", tdata->temp);\r\n}\r\nstatic int adjust_tjmax(struct cpuinfo_x86 *c, u32 id, struct device *dev)\r\n{\r\nint tjmax = 100000;\r\nint tjmax_ee = 85000;\r\nint usemsr_ee = 1;\r\nint err;\r\nu32 eax, edx;\r\nint i;\r\nstruct pci_dev *host_bridge = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\r\nif (host_bridge && host_bridge->vendor == PCI_VENDOR_ID_INTEL) {\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_pci_table); i++) {\r\nif (host_bridge->device == tjmax_pci_table[i].device)\r\nreturn tjmax_pci_table[i].tjmax;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_table); i++) {\r\nif (strstr(c->x86_model_id, tjmax_table[i].id))\r\nreturn tjmax_table[i].tjmax;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(tjmax_model_table); i++) {\r\nconst struct tjmax_model *tm = &tjmax_model_table[i];\r\nif (c->x86_model == tm->model &&\r\n(tm->mask == ANY || c->x86_mask == tm->mask))\r\nreturn tm->tjmax;\r\n}\r\nif (c->x86_model == 0xf && c->x86_mask < 4)\r\nusemsr_ee = 0;\r\nif (c->x86_model > 0xe && usemsr_ee) {\r\nu8 platform_id;\r\nerr = rdmsr_safe_on_cpu(id, 0x17, &eax, &edx);\r\nif (err) {\r\ndev_warn(dev,\r\n"Unable to access MSR 0x17, assuming desktop"\r\n" CPU\n");\r\nusemsr_ee = 0;\r\n} else if (c->x86_model < 0x17 && !(eax & 0x10000000)) {\r\nusemsr_ee = 0;\r\n} else {\r\nplatform_id = (edx >> 18) & 0x7;\r\nif (c->x86_model == 0x17 &&\r\n(platform_id == 5 || platform_id == 7)) {\r\ntjmax_ee = 90000;\r\ntjmax = 105000;\r\n}\r\n}\r\n}\r\nif (usemsr_ee) {\r\nerr = rdmsr_safe_on_cpu(id, 0xee, &eax, &edx);\r\nif (err) {\r\ndev_warn(dev,\r\n"Unable to access MSR 0xEE, for Tjmax, left"\r\n" at default\n");\r\n} else if (eax & 0x40000000) {\r\ntjmax = tjmax_ee;\r\n}\r\n} else if (tjmax == 100000) {\r\ndev_warn(dev, "Using relative temperature scale!\n");\r\n}\r\nreturn tjmax;\r\n}\r\nstatic bool cpu_has_tjmax(struct cpuinfo_x86 *c)\r\n{\r\nu8 model = c->x86_model;\r\nreturn model > 0xe &&\r\nmodel != 0x1c &&\r\nmodel != 0x26 &&\r\nmodel != 0x27 &&\r\nmodel != 0x35 &&\r\nmodel != 0x36;\r\n}\r\nstatic int get_tjmax(struct cpuinfo_x86 *c, u32 id, struct device *dev)\r\n{\r\nint err;\r\nu32 eax, edx;\r\nu32 val;\r\nerr = rdmsr_safe_on_cpu(id, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err) {\r\nif (cpu_has_tjmax(c))\r\ndev_warn(dev, "Unable to read TjMax from CPU %u\n", id);\r\n} else {\r\nval = (eax >> 16) & 0xff;\r\nif (val) {\r\ndev_dbg(dev, "TjMax is %d degrees C\n", val);\r\nreturn val * 1000;\r\n}\r\n}\r\nif (force_tjmax) {\r\ndev_notice(dev, "TjMax forced to %d degrees C by user\n",\r\nforce_tjmax);\r\nreturn force_tjmax * 1000;\r\n}\r\nreturn adjust_tjmax(c, id, dev);\r\n}\r\nstatic int create_core_attrs(struct temp_data *tdata, struct device *dev,\r\nint attr_no)\r\n{\r\nint i;\r\nstatic ssize_t (*const rd_ptr[TOTAL_ATTRS]) (struct device *dev,\r\nstruct device_attribute *devattr, char *buf) = {\r\nshow_label, show_crit_alarm, show_temp, show_tjmax,\r\nshow_ttarget };\r\nstatic const char *const suffixes[TOTAL_ATTRS] = {\r\n"label", "crit_alarm", "input", "crit", "max"\r\n};\r\nfor (i = 0; i < tdata->attr_size; i++) {\r\nsnprintf(tdata->attr_name[i], CORETEMP_NAME_LENGTH,\r\n"temp%d_%s", attr_no, suffixes[i]);\r\nsysfs_attr_init(&tdata->sd_attrs[i].dev_attr.attr);\r\ntdata->sd_attrs[i].dev_attr.attr.name = tdata->attr_name[i];\r\ntdata->sd_attrs[i].dev_attr.attr.mode = S_IRUGO;\r\ntdata->sd_attrs[i].dev_attr.show = rd_ptr[i];\r\ntdata->sd_attrs[i].index = attr_no;\r\ntdata->attrs[i] = &tdata->sd_attrs[i].dev_attr.attr;\r\n}\r\ntdata->attr_group.attrs = tdata->attrs;\r\nreturn sysfs_create_group(&dev->kobj, &tdata->attr_group);\r\n}\r\nstatic int chk_ucode_version(unsigned int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nif (c->x86_model == 0xe && c->x86_mask < 0xc && c->microcode < 0x39) {\r\npr_err("Errata AE18 not fixed, update BIOS or microcode of the CPU!\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct platform_device *coretemp_get_pdev(unsigned int cpu)\r\n{\r\nint pkgid = topology_logical_package_id(cpu);\r\nif (pkgid >= 0 && pkgid < max_packages)\r\nreturn pkg_devices[pkgid];\r\nreturn NULL;\r\n}\r\nstatic struct temp_data *init_temp_data(unsigned int cpu, int pkg_flag)\r\n{\r\nstruct temp_data *tdata;\r\ntdata = kzalloc(sizeof(struct temp_data), GFP_KERNEL);\r\nif (!tdata)\r\nreturn NULL;\r\ntdata->status_reg = pkg_flag ? MSR_IA32_PACKAGE_THERM_STATUS :\r\nMSR_IA32_THERM_STATUS;\r\ntdata->is_pkg_data = pkg_flag;\r\ntdata->cpu = cpu;\r\ntdata->cpu_core_id = TO_CORE_ID(cpu);\r\ntdata->attr_size = MAX_CORE_ATTRS;\r\nmutex_init(&tdata->update_lock);\r\nreturn tdata;\r\n}\r\nstatic int create_core_data(struct platform_device *pdev, unsigned int cpu,\r\nint pkg_flag)\r\n{\r\nstruct temp_data *tdata;\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nu32 eax, edx;\r\nint err, attr_no;\r\nattr_no = pkg_flag ? PKG_SYSFS_ATTR_NO : TO_ATTR_NO(cpu);\r\nif (attr_no > MAX_CORE_DATA - 1)\r\nreturn -ERANGE;\r\ntdata = init_temp_data(cpu, pkg_flag);\r\nif (!tdata)\r\nreturn -ENOMEM;\r\nerr = rdmsr_safe_on_cpu(cpu, tdata->status_reg, &eax, &edx);\r\nif (err)\r\ngoto exit_free;\r\ntdata->tjmax = get_tjmax(c, cpu, &pdev->dev);\r\nif (c->x86_model > 0xe && c->x86_model != 0x1c) {\r\nerr = rdmsr_safe_on_cpu(cpu, MSR_IA32_TEMPERATURE_TARGET,\r\n&eax, &edx);\r\nif (!err) {\r\ntdata->ttarget\r\n= tdata->tjmax - ((eax >> 8) & 0xff) * 1000;\r\ntdata->attr_size++;\r\n}\r\n}\r\npdata->core_data[attr_no] = tdata;\r\nerr = create_core_attrs(tdata, pdata->hwmon_dev, attr_no);\r\nif (err)\r\ngoto exit_free;\r\nreturn 0;\r\nexit_free:\r\npdata->core_data[attr_no] = NULL;\r\nkfree(tdata);\r\nreturn err;\r\n}\r\nstatic void\r\ncoretemp_add_core(struct platform_device *pdev, unsigned int cpu, int pkg_flag)\r\n{\r\nif (create_core_data(pdev, cpu, pkg_flag))\r\ndev_err(&pdev->dev, "Adding Core %u failed\n", cpu);\r\n}\r\nstatic void coretemp_remove_core(struct platform_data *pdata, int indx)\r\n{\r\nstruct temp_data *tdata = pdata->core_data[indx];\r\nsysfs_remove_group(&pdata->hwmon_dev->kobj, &tdata->attr_group);\r\nkfree(pdata->core_data[indx]);\r\npdata->core_data[indx] = NULL;\r\n}\r\nstatic int coretemp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct platform_data *pdata;\r\npdata = devm_kzalloc(dev, sizeof(struct platform_data), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->pkg_id = pdev->id;\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->hwmon_dev = devm_hwmon_device_register_with_groups(dev, DRVNAME,\r\npdata, NULL);\r\nreturn PTR_ERR_OR_ZERO(pdata->hwmon_dev);\r\n}\r\nstatic int coretemp_remove(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = MAX_CORE_DATA - 1; i >= 0; --i)\r\nif (pdata->core_data[i])\r\ncoretemp_remove_core(pdata, i);\r\nreturn 0;\r\n}\r\nstatic struct platform_device *coretemp_device_add(unsigned int cpu)\r\n{\r\nint err, pkgid = topology_logical_package_id(cpu);\r\nstruct platform_device *pdev;\r\nif (pkgid < 0)\r\nreturn ERR_PTR(-ENOMEM);\r\npdev = platform_device_alloc(DRVNAME, pkgid);\r\nif (!pdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\nplatform_device_put(pdev);\r\nreturn ERR_PTR(err);\r\n}\r\npkg_devices[pkgid] = pdev;\r\nreturn pdev;\r\n}\r\nstatic int coretemp_cpu_online(unsigned int cpu)\r\n{\r\nstruct platform_device *pdev = coretemp_get_pdev(cpu);\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nstruct platform_data *pdata;\r\nif (!cpu_has(c, X86_FEATURE_DTHERM))\r\nreturn -ENODEV;\r\nif (!pdev) {\r\nif (chk_ucode_version(cpu))\r\nreturn -EINVAL;\r\npdev = coretemp_device_add(cpu);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nif (cpu_has(c, X86_FEATURE_PTS))\r\ncoretemp_add_core(pdev, cpu, 1);\r\n}\r\npdata = platform_get_drvdata(pdev);\r\nif (!cpumask_intersects(&pdata->cpumask, topology_sibling_cpumask(cpu)))\r\ncoretemp_add_core(pdev, cpu, 0);\r\ncpumask_set_cpu(cpu, &pdata->cpumask);\r\nreturn 0;\r\n}\r\nstatic int coretemp_cpu_offline(unsigned int cpu)\r\n{\r\nstruct platform_device *pdev = coretemp_get_pdev(cpu);\r\nstruct platform_data *pd;\r\nstruct temp_data *tdata;\r\nint indx, target;\r\nif (!pdev)\r\nreturn 0;\r\nindx = TO_ATTR_NO(cpu);\r\nif (indx > MAX_CORE_DATA - 1)\r\nreturn 0;\r\npd = platform_get_drvdata(pdev);\r\ntdata = pd->core_data[indx];\r\ncpumask_clear_cpu(cpu, &pd->cpumask);\r\ntarget = cpumask_any_and(&pd->cpumask, topology_sibling_cpumask(cpu));\r\nif (target >= nr_cpu_ids) {\r\ncoretemp_remove_core(pd, indx);\r\n} else if (tdata && tdata->cpu == cpu) {\r\nmutex_lock(&tdata->update_lock);\r\ntdata->cpu = target;\r\nmutex_unlock(&tdata->update_lock);\r\n}\r\nif (cpumask_empty(&pd->cpumask)) {\r\npkg_devices[topology_logical_package_id(cpu)] = NULL;\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\ntdata = pd->core_data[PKG_SYSFS_ATTR_NO];\r\nif (tdata && tdata->cpu == cpu) {\r\ntarget = cpumask_first(&pd->cpumask);\r\nmutex_lock(&tdata->update_lock);\r\ntdata->cpu = target;\r\nmutex_unlock(&tdata->update_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init coretemp_init(void)\r\n{\r\nint err;\r\nif (!x86_match_cpu(coretemp_ids))\r\nreturn -ENODEV;\r\nmax_packages = topology_max_packages();\r\npkg_devices = kzalloc(max_packages * sizeof(struct platform_device *),\r\nGFP_KERNEL);\r\nif (!pkg_devices)\r\nreturn -ENOMEM;\r\nerr = platform_driver_register(&coretemp_driver);\r\nif (err)\r\nreturn err;\r\nerr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "hwmon/coretemp:online",\r\ncoretemp_cpu_online, coretemp_cpu_offline);\r\nif (err < 0)\r\ngoto outdrv;\r\ncoretemp_hp_online = err;\r\nreturn 0;\r\noutdrv:\r\nplatform_driver_unregister(&coretemp_driver);\r\nkfree(pkg_devices);\r\nreturn err;\r\n}\r\nstatic void __exit coretemp_exit(void)\r\n{\r\ncpuhp_remove_state(coretemp_hp_online);\r\nplatform_driver_unregister(&coretemp_driver);\r\nkfree(pkg_devices);\r\n}
