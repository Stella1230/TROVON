const struct tcphdr *nf_reject_ip_tcphdr_get(struct sk_buff *oldskb,\r\nstruct tcphdr *_oth, int hook)\r\n{\r\nconst struct tcphdr *oth;\r\nif (ip_hdr(oldskb)->frag_off & htons(IP_OFFSET))\r\nreturn NULL;\r\nif (ip_hdr(oldskb)->protocol != IPPROTO_TCP)\r\nreturn NULL;\r\noth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),\r\nsizeof(struct tcphdr), _oth);\r\nif (oth == NULL)\r\nreturn NULL;\r\nif (oth->rst)\r\nreturn NULL;\r\nif (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))\r\nreturn NULL;\r\nreturn oth;\r\n}\r\nstruct iphdr *nf_reject_iphdr_put(struct sk_buff *nskb,\r\nconst struct sk_buff *oldskb,\r\n__u8 protocol, int ttl)\r\n{\r\nstruct iphdr *niph, *oiph = ip_hdr(oldskb);\r\nskb_reset_network_header(nskb);\r\nniph = (struct iphdr *)skb_put(nskb, sizeof(struct iphdr));\r\nniph->version = 4;\r\nniph->ihl = sizeof(struct iphdr) / 4;\r\nniph->tos = 0;\r\nniph->id = 0;\r\nniph->frag_off = htons(IP_DF);\r\nniph->protocol = protocol;\r\nniph->check = 0;\r\nniph->saddr = oiph->daddr;\r\nniph->daddr = oiph->saddr;\r\nniph->ttl = ttl;\r\nnskb->protocol = htons(ETH_P_IP);\r\nreturn niph;\r\n}\r\nvoid nf_reject_ip_tcphdr_put(struct sk_buff *nskb, const struct sk_buff *oldskb,\r\nconst struct tcphdr *oth)\r\n{\r\nstruct iphdr *niph = ip_hdr(nskb);\r\nstruct tcphdr *tcph;\r\nskb_reset_transport_header(nskb);\r\ntcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));\r\nmemset(tcph, 0, sizeof(*tcph));\r\ntcph->source = oth->dest;\r\ntcph->dest = oth->source;\r\ntcph->doff = sizeof(struct tcphdr) / 4;\r\nif (oth->ack) {\r\ntcph->seq = oth->ack_seq;\r\n} else {\r\ntcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +\r\noldskb->len - ip_hdrlen(oldskb) -\r\n(oth->doff << 2));\r\ntcph->ack = 1;\r\n}\r\ntcph->rst = 1;\r\ntcph->check = ~tcp_v4_check(sizeof(struct tcphdr), niph->saddr,\r\nniph->daddr, 0);\r\nnskb->ip_summed = CHECKSUM_PARTIAL;\r\nnskb->csum_start = (unsigned char *)tcph - nskb->head;\r\nnskb->csum_offset = offsetof(struct tcphdr, check);\r\n}\r\nvoid nf_send_reset(struct net *net, struct sk_buff *oldskb, int hook)\r\n{\r\nstruct sk_buff *nskb;\r\nconst struct iphdr *oiph;\r\nstruct iphdr *niph;\r\nconst struct tcphdr *oth;\r\nstruct tcphdr _oth;\r\noth = nf_reject_ip_tcphdr_get(oldskb, &_oth, hook);\r\nif (!oth)\r\nreturn;\r\nif (skb_rtable(oldskb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\r\nreturn;\r\noiph = ip_hdr(oldskb);\r\nnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +\r\nLL_MAX_HEADER, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_dst_set_noref(nskb, skb_dst(oldskb));\r\nnskb->mark = IP4_REPLY_MARK(net, oldskb->mark);\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,\r\nip4_dst_hoplimit(skb_dst(nskb)));\r\nnf_reject_ip_tcphdr_put(nskb, oldskb, oth);\r\nif (ip_route_me_harder(net, nskb, RTN_UNSPEC))\r\ngoto free_nskb;\r\nif (nskb->len > dst_mtu(skb_dst(nskb)))\r\ngoto free_nskb;\r\nnf_ct_attach(nskb, oldskb);\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (oldskb->nf_bridge) {\r\nstruct ethhdr *oeth = eth_hdr(oldskb);\r\nnskb->dev = nf_bridge_get_physindev(oldskb);\r\nniph->tot_len = htons(nskb->len);\r\nip_send_check(niph);\r\nif (dev_hard_header(nskb, nskb->dev, ntohs(nskb->protocol),\r\noeth->h_source, oeth->h_dest, nskb->len) < 0)\r\ngoto free_nskb;\r\ndev_queue_xmit(nskb);\r\n} else\r\n#endif\r\nip_local_out(net, nskb->sk, nskb);\r\nreturn;\r\nfree_nskb:\r\nkfree_skb(nskb);\r\n}\r\nvoid nf_send_unreach(struct sk_buff *skb_in, int code, int hook)\r\n{\r\nstruct iphdr *iph = ip_hdr(skb_in);\r\nu8 proto;\r\nif (skb_in->csum_bad || iph->frag_off & htons(IP_OFFSET))\r\nreturn;\r\nif (skb_csum_unnecessary(skb_in)) {\r\nicmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);\r\nreturn;\r\n}\r\nif (iph->protocol == IPPROTO_TCP || iph->protocol == IPPROTO_UDP)\r\nproto = iph->protocol;\r\nelse\r\nproto = 0;\r\nif (nf_ip_checksum(skb_in, hook, ip_hdrlen(skb_in), proto) == 0)\r\nicmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);\r\n}
