static int vxlan_get_options(const struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct vxlan_dev *vxlan = netdev_priv(vport->dev);\r\n__be16 dst_port = vxlan->cfg.dst_port;\r\nif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(dst_port)))\r\nreturn -EMSGSIZE;\r\nif (vxlan->flags & VXLAN_F_GBP) {\r\nstruct nlattr *exts;\r\nexts = nla_nest_start(skb, OVS_TUNNEL_ATTR_EXTENSION);\r\nif (!exts)\r\nreturn -EMSGSIZE;\r\nif (vxlan->flags & VXLAN_F_GBP &&\r\nnla_put_flag(skb, OVS_VXLAN_EXT_GBP))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, exts);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vxlan_configure_exts(struct vport *vport, struct nlattr *attr,\r\nstruct vxlan_config *conf)\r\n{\r\nstruct nlattr *exts[OVS_VXLAN_EXT_MAX + 1];\r\nint err;\r\nif (nla_len(attr) < sizeof(struct nlattr))\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(exts, OVS_VXLAN_EXT_MAX, attr, exts_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (exts[OVS_VXLAN_EXT_GBP])\r\nconf->flags |= VXLAN_F_GBP;\r\nreturn 0;\r\n}\r\nstatic struct vport *vxlan_tnl_create(const struct vport_parms *parms)\r\n{\r\nstruct net *net = ovs_dp_get_net(parms->dp);\r\nstruct nlattr *options = parms->options;\r\nstruct net_device *dev;\r\nstruct vport *vport;\r\nstruct nlattr *a;\r\nint err;\r\nstruct vxlan_config conf = {\r\n.no_share = true,\r\n.flags = VXLAN_F_COLLECT_METADATA | VXLAN_F_UDP_ZERO_CSUM6_RX,\r\n.mtu = IP_MAX_MTU,\r\n};\r\nif (!options) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\r\nif (a && nla_len(a) == sizeof(u16)) {\r\nconf.dst_port = htons(nla_get_u16(a));\r\n} else {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nvport = ovs_vport_alloc(0, &ovs_vxlan_netdev_vport_ops, parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_EXTENSION);\r\nif (a) {\r\nerr = vxlan_configure_exts(vport, a, &conf);\r\nif (err) {\r\novs_vport_free(vport);\r\ngoto error;\r\n}\r\n}\r\nrtnl_lock();\r\ndev = vxlan_dev_create(net, parms->name, NET_NAME_USER, &conf);\r\nif (IS_ERR(dev)) {\r\nrtnl_unlock();\r\novs_vport_free(vport);\r\nreturn ERR_CAST(dev);\r\n}\r\nerr = dev_change_flags(dev, dev->flags | IFF_UP);\r\nif (err < 0) {\r\nrtnl_delete_link(dev);\r\nrtnl_unlock();\r\novs_vport_free(vport);\r\ngoto error;\r\n}\r\nrtnl_unlock();\r\nreturn vport;\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct vport *vxlan_create(const struct vport_parms *parms)\r\n{\r\nstruct vport *vport;\r\nvport = vxlan_tnl_create(parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\nreturn ovs_netdev_link(vport, parms->name);\r\n}\r\nstatic int __init ovs_vxlan_tnl_init(void)\r\n{\r\nreturn ovs_vport_ops_register(&ovs_vxlan_netdev_vport_ops);\r\n}\r\nstatic void __exit ovs_vxlan_tnl_exit(void)\r\n{\r\novs_vport_ops_unregister(&ovs_vxlan_netdev_vport_ops);\r\n}
