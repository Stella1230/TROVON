static int pmic_gpio_read(struct pmic_gpio_state *state,\r\nstruct pmic_gpio_pad *pad, unsigned int addr)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(state->map, pad->base + addr, &val);\r\nif (ret < 0)\r\ndev_err(state->dev, "read 0x%x failed\n", addr);\r\nelse\r\nret = val;\r\nreturn ret;\r\n}\r\nstatic int pmic_gpio_write(struct pmic_gpio_state *state,\r\nstruct pmic_gpio_pad *pad, unsigned int addr,\r\nunsigned int val)\r\n{\r\nint ret;\r\nret = regmap_write(state->map, pad->base + addr, val);\r\nif (ret < 0)\r\ndev_err(state->dev, "write 0x%x failed\n", addr);\r\nreturn ret;\r\n}\r\nstatic int pmic_gpio_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn pctldev->desc->npins;\r\n}\r\nstatic const char *pmic_gpio_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned pin)\r\n{\r\nreturn pctldev->desc->pins[pin].name;\r\n}\r\nstatic int pmic_gpio_get_group_pins(struct pinctrl_dev *pctldev, unsigned pin,\r\nconst unsigned **pins, unsigned *num_pins)\r\n{\r\n*pins = &pctldev->desc->pins[pin].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int pmic_gpio_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(pmic_gpio_functions);\r\n}\r\nstatic const char *pmic_gpio_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nreturn pmic_gpio_functions[function];\r\n}\r\nstatic int pmic_gpio_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char *const **groups,\r\nunsigned *const num_qgroups)\r\n{\r\n*groups = pmic_gpio_groups;\r\n*num_qgroups = pctldev->desc->npins;\r\nreturn 0;\r\n}\r\nstatic int pmic_gpio_set_mux(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned pin)\r\n{\r\nstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_gpio_pad *pad;\r\nunsigned int val;\r\nint ret;\r\npad = pctldev->desc->pins[pin].drv_data;\r\npad->function = function;\r\nval = 0;\r\nif (pad->output_enabled) {\r\nif (pad->input_enabled)\r\nval = 2;\r\nelse\r\nval = 1;\r\n}\r\nval = val << PMIC_GPIO_REG_MODE_DIR_SHIFT;\r\nval |= pad->function << PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\r\nval |= pad->out_value & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\r\nret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_MODE_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pad->is_enabled << PMIC_GPIO_REG_MASTER_EN_SHIFT;\r\nreturn pmic_gpio_write(state, pad, PMIC_GPIO_REG_EN_CTL, val);\r\n}\r\nstatic int pmic_gpio_config_get(struct pinctrl_dev *pctldev,\r\nunsigned int pin, unsigned long *config)\r\n{\r\nunsigned param = pinconf_to_config_param(*config);\r\nstruct pmic_gpio_pad *pad;\r\nunsigned arg;\r\npad = pctldev->desc->pins[pin].drv_data;\r\nswitch (param) {\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\narg = pad->buffer_type == PMIC_GPIO_OUT_BUF_CMOS;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\narg = pad->buffer_type == PMIC_GPIO_OUT_BUF_OPEN_DRAIN_NMOS;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_SOURCE:\r\narg = pad->buffer_type == PMIC_GPIO_OUT_BUF_OPEN_DRAIN_PMOS;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = pad->pullup == PMIC_GPIO_PULL_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\narg = pad->pullup = PMIC_GPIO_PULL_DISABLE;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = pad->pullup == PMIC_GPIO_PULL_UP_30;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\narg = !pad->is_enabled;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\narg = pad->power_source;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = pad->input_enabled;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\narg = pad->out_value;\r\nbreak;\r\ncase PMIC_GPIO_CONF_PULL_UP:\r\narg = pad->pullup;\r\nbreak;\r\ncase PMIC_GPIO_CONF_STRENGTH:\r\narg = pad->strength;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int pmic_gpio_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned nconfs)\r\n{\r\nstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_gpio_pad *pad;\r\nunsigned param, arg;\r\nunsigned int val;\r\nint i, ret;\r\npad = pctldev->desc->pins[pin].drv_data;\r\nfor (i = 0; i < nconfs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\npad->buffer_type = PMIC_GPIO_OUT_BUF_CMOS;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!pad->have_buffer)\r\nreturn -EINVAL;\r\npad->buffer_type = PMIC_GPIO_OUT_BUF_OPEN_DRAIN_NMOS;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_SOURCE:\r\nif (!pad->have_buffer)\r\nreturn -EINVAL;\r\npad->buffer_type = PMIC_GPIO_OUT_BUF_OPEN_DRAIN_PMOS;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\npad->pullup = PMIC_GPIO_PULL_DISABLE;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\npad->pullup = PMIC_GPIO_PULL_UP_30;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (arg)\r\npad->pullup = PMIC_GPIO_PULL_DOWN;\r\nelse\r\npad->pullup = PMIC_GPIO_PULL_DISABLE;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\npad->is_enabled = false;\r\nbreak;\r\ncase PIN_CONFIG_POWER_SOURCE:\r\nif (arg > pad->num_sources)\r\nreturn -EINVAL;\r\npad->power_source = arg;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\npad->input_enabled = arg ? true : false;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\npad->output_enabled = true;\r\npad->out_value = arg;\r\nbreak;\r\ncase PMIC_GPIO_CONF_PULL_UP:\r\nif (arg > PMIC_GPIO_PULL_UP_1P5_30)\r\nreturn -EINVAL;\r\npad->pullup = arg;\r\nbreak;\r\ncase PMIC_GPIO_CONF_STRENGTH:\r\nif (arg > PMIC_GPIO_STRENGTH_LOW)\r\nreturn -EINVAL;\r\npad->strength = arg;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nval = pad->power_source << PMIC_GPIO_REG_VIN_SHIFT;\r\nret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_VIN_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pad->pullup << PMIC_GPIO_REG_PULL_SHIFT;\r\nret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_PULL_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = pad->buffer_type << PMIC_GPIO_REG_OUT_TYPE_SHIFT;\r\nval |= pad->strength << PMIC_GPIO_REG_OUT_STRENGTH_SHIFT;\r\nret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_OUT_CTL, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = 0;\r\nif (pad->output_enabled) {\r\nif (pad->input_enabled)\r\nval = 2;\r\nelse\r\nval = 1;\r\n}\r\nval = val << PMIC_GPIO_REG_MODE_DIR_SHIFT;\r\nval |= pad->function << PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\r\nval |= pad->out_value & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\r\nreturn pmic_gpio_write(state, pad, PMIC_GPIO_REG_MODE_CTL, val);\r\n}\r\nstatic void pmic_gpio_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\nstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\r\nstruct pmic_gpio_pad *pad;\r\nint ret, val;\r\nstatic const char *const biases[] = {\r\n"pull-up 30uA", "pull-up 1.5uA", "pull-up 31.5uA",\r\n"pull-up 1.5uA + 30uA boost", "pull-down 10uA", "no pull"\r\n};\r\nstatic const char *const buffer_types[] = {\r\n"push-pull", "open-drain", "open-source"\r\n};\r\nstatic const char *const strengths[] = {\r\n"no", "high", "medium", "low"\r\n};\r\npad = pctldev->desc->pins[pin].drv_data;\r\nseq_printf(s, " gpio%-2d:", pin + PMIC_GPIO_PHYSICAL_OFFSET);\r\nval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_EN_CTL);\r\nif (val < 0 || !(val >> PMIC_GPIO_REG_MASTER_EN_SHIFT)) {\r\nseq_puts(s, " ---");\r\n} else {\r\nif (pad->input_enabled) {\r\nret = pmic_gpio_read(state, pad, PMIC_MPP_REG_RT_STS);\r\nif (ret < 0)\r\nreturn;\r\nret &= PMIC_MPP_REG_RT_STS_VAL_MASK;\r\npad->out_value = ret;\r\n}\r\nseq_printf(s, " %-4s", pad->output_enabled ? "out" : "in");\r\nseq_printf(s, " %-7s", pmic_gpio_functions[pad->function]);\r\nseq_printf(s, " vin-%d", pad->power_source);\r\nseq_printf(s, " %-27s", biases[pad->pullup]);\r\nseq_printf(s, " %-10s", buffer_types[pad->buffer_type]);\r\nseq_printf(s, " %-4s", pad->out_value ? "high" : "low");\r\nseq_printf(s, " %-7s", strengths[pad->strength]);\r\n}\r\n}\r\nstatic int pmic_gpio_direction_input(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_ENABLE, 1);\r\nreturn pmic_gpio_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned pin, int val)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, val);\r\nreturn pmic_gpio_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_gpio_get(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nstruct pmic_gpio_pad *pad;\r\nint ret;\r\npad = state->ctrl->desc->pins[pin].drv_data;\r\nif (!pad->is_enabled)\r\nreturn -EINVAL;\r\nif (pad->input_enabled) {\r\nret = pmic_gpio_read(state, pad, PMIC_MPP_REG_RT_STS);\r\nif (ret < 0)\r\nreturn ret;\r\npad->out_value = ret & PMIC_MPP_REG_RT_STS_VAL_MASK;\r\n}\r\nreturn !!pad->out_value;\r\n}\r\nstatic void pmic_gpio_set(struct gpio_chip *chip, unsigned pin, int value)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nunsigned long config;\r\nconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, value);\r\npmic_gpio_config_set(state->ctrl, pin, &config, 1);\r\n}\r\nstatic int pmic_gpio_of_xlate(struct gpio_chip *chip,\r\nconst struct of_phandle_args *gpio_desc,\r\nu32 *flags)\r\n{\r\nif (chip->of_gpio_n_cells < 2)\r\nreturn -EINVAL;\r\nif (flags)\r\n*flags = gpio_desc->args[1];\r\nreturn gpio_desc->args[0] - PMIC_GPIO_PHYSICAL_OFFSET;\r\n}\r\nstatic int pmic_gpio_to_irq(struct gpio_chip *chip, unsigned pin)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nstruct pmic_gpio_pad *pad;\r\npad = state->ctrl->desc->pins[pin].drv_data;\r\nreturn pad->irq;\r\n}\r\nstatic void pmic_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct pmic_gpio_state *state = gpiochip_get_data(chip);\r\nunsigned i;\r\nfor (i = 0; i < chip->ngpio; i++) {\r\npmic_gpio_config_dbg_show(state->ctrl, s, i);\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic int pmic_gpio_populate(struct pmic_gpio_state *state,\r\nstruct pmic_gpio_pad *pad)\r\n{\r\nint type, subtype, val, dir;\r\ntype = pmic_gpio_read(state, pad, PMIC_GPIO_REG_TYPE);\r\nif (type < 0)\r\nreturn type;\r\nif (type != PMIC_GPIO_TYPE) {\r\ndev_err(state->dev, "incorrect block type 0x%x at 0x%x\n",\r\ntype, pad->base);\r\nreturn -ENODEV;\r\n}\r\nsubtype = pmic_gpio_read(state, pad, PMIC_GPIO_REG_SUBTYPE);\r\nif (subtype < 0)\r\nreturn subtype;\r\nswitch (subtype) {\r\ncase PMIC_GPIO_SUBTYPE_GPIO_4CH:\r\npad->have_buffer = true;\r\ncase PMIC_GPIO_SUBTYPE_GPIOC_4CH:\r\npad->num_sources = 4;\r\nbreak;\r\ncase PMIC_GPIO_SUBTYPE_GPIO_8CH:\r\npad->have_buffer = true;\r\ncase PMIC_GPIO_SUBTYPE_GPIOC_8CH:\r\npad->num_sources = 8;\r\nbreak;\r\ndefault:\r\ndev_err(state->dev, "unknown GPIO type 0x%x\n", subtype);\r\nreturn -ENODEV;\r\n}\r\nval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_MODE_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->out_value = val & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\r\ndir = val >> PMIC_GPIO_REG_MODE_DIR_SHIFT;\r\ndir &= PMIC_GPIO_REG_MODE_DIR_MASK;\r\nswitch (dir) {\r\ncase 0:\r\npad->input_enabled = true;\r\npad->output_enabled = false;\r\nbreak;\r\ncase 1:\r\npad->input_enabled = false;\r\npad->output_enabled = true;\r\nbreak;\r\ncase 2:\r\npad->input_enabled = true;\r\npad->output_enabled = true;\r\nbreak;\r\ndefault:\r\ndev_err(state->dev, "unknown GPIO direction\n");\r\nreturn -ENODEV;\r\n}\r\npad->function = val >> PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\r\npad->function &= PMIC_GPIO_REG_MODE_FUNCTION_MASK;\r\nval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_VIN_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->power_source = val >> PMIC_GPIO_REG_VIN_SHIFT;\r\npad->power_source &= PMIC_GPIO_REG_VIN_MASK;\r\nval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_PULL_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->pullup = val >> PMIC_GPIO_REG_PULL_SHIFT;\r\npad->pullup &= PMIC_GPIO_REG_PULL_MASK;\r\nval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_OUT_CTL);\r\nif (val < 0)\r\nreturn val;\r\npad->strength = val >> PMIC_GPIO_REG_OUT_STRENGTH_SHIFT;\r\npad->strength &= PMIC_GPIO_REG_OUT_STRENGTH_MASK;\r\npad->buffer_type = val >> PMIC_GPIO_REG_OUT_TYPE_SHIFT;\r\npad->buffer_type &= PMIC_GPIO_REG_OUT_TYPE_MASK;\r\npad->is_enabled = true;\r\nreturn 0;\r\n}\r\nstatic int pmic_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pinctrl_pin_desc *pindesc;\r\nstruct pinctrl_desc *pctrldesc;\r\nstruct pmic_gpio_pad *pad, *pads;\r\nstruct pmic_gpio_state *state;\r\nint ret, npins, i;\r\nu32 reg;\r\nret = of_property_read_u32(dev->of_node, "reg", &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "missing base address");\r\nreturn ret;\r\n}\r\nnpins = platform_irq_count(pdev);\r\nif (!npins)\r\nreturn -EINVAL;\r\nif (npins < 0)\r\nreturn npins;\r\nBUG_ON(npins > ARRAY_SIZE(pmic_gpio_groups));\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, state);\r\nstate->dev = &pdev->dev;\r\nstate->map = dev_get_regmap(dev->parent, NULL);\r\npindesc = devm_kcalloc(dev, npins, sizeof(*pindesc), GFP_KERNEL);\r\nif (!pindesc)\r\nreturn -ENOMEM;\r\npads = devm_kcalloc(dev, npins, sizeof(*pads), GFP_KERNEL);\r\nif (!pads)\r\nreturn -ENOMEM;\r\npctrldesc = devm_kzalloc(dev, sizeof(*pctrldesc), GFP_KERNEL);\r\nif (!pctrldesc)\r\nreturn -ENOMEM;\r\npctrldesc->pctlops = &pmic_gpio_pinctrl_ops;\r\npctrldesc->pmxops = &pmic_gpio_pinmux_ops;\r\npctrldesc->confops = &pmic_gpio_pinconf_ops;\r\npctrldesc->owner = THIS_MODULE;\r\npctrldesc->name = dev_name(dev);\r\npctrldesc->pins = pindesc;\r\npctrldesc->npins = npins;\r\npctrldesc->num_custom_params = ARRAY_SIZE(pmic_gpio_bindings);\r\npctrldesc->custom_params = pmic_gpio_bindings;\r\n#ifdef CONFIG_DEBUG_FS\r\npctrldesc->custom_conf_items = pmic_conf_items;\r\n#endif\r\nfor (i = 0; i < npins; i++, pindesc++) {\r\npad = &pads[i];\r\npindesc->drv_data = pad;\r\npindesc->number = i;\r\npindesc->name = pmic_gpio_groups[i];\r\npad->irq = platform_get_irq(pdev, i);\r\nif (pad->irq < 0)\r\nreturn pad->irq;\r\npad->base = reg + i * PMIC_GPIO_ADDRESS_RANGE;\r\nret = pmic_gpio_populate(state, pad);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nstate->chip = pmic_gpio_gpio_template;\r\nstate->chip.parent = dev;\r\nstate->chip.base = -1;\r\nstate->chip.ngpio = npins;\r\nstate->chip.label = dev_name(dev);\r\nstate->chip.of_gpio_n_cells = 2;\r\nstate->chip.can_sleep = false;\r\nstate->ctrl = devm_pinctrl_register(dev, pctrldesc, state);\r\nif (IS_ERR(state->ctrl))\r\nreturn PTR_ERR(state->ctrl);\r\nret = gpiochip_add_data(&state->chip, state);\r\nif (ret) {\r\ndev_err(state->dev, "can't add gpio chip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&state->chip, dev_name(dev), 0, 0, npins);\r\nif (ret) {\r\ndev_err(dev, "failed to add pin range\n");\r\ngoto err_range;\r\n}\r\nreturn 0;\r\nerr_range:\r\ngpiochip_remove(&state->chip);\r\nreturn ret;\r\n}\r\nstatic int pmic_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct pmic_gpio_state *state = platform_get_drvdata(pdev);\r\ngpiochip_remove(&state->chip);\r\nreturn 0;\r\n}
