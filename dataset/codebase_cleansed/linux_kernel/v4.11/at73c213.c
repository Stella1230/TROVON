static int\r\nsnd_at73c213_write_reg(struct snd_at73c213 *chip, u8 reg, u8 val)\r\n{\r\nstruct spi_message msg;\r\nstruct spi_transfer msg_xfer = {\r\n.len = 2,\r\n.cs_change = 0,\r\n};\r\nint retval;\r\nspi_message_init(&msg);\r\nchip->spi_wbuffer[0] = reg;\r\nchip->spi_wbuffer[1] = val;\r\nmsg_xfer.tx_buf = chip->spi_wbuffer;\r\nmsg_xfer.rx_buf = chip->spi_rbuffer;\r\nspi_message_add_tail(&msg_xfer, &msg);\r\nretval = spi_sync(chip->spi, &msg);\r\nif (!retval)\r\nchip->reg_image[reg] = val;\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_set_bitrate(struct snd_at73c213 *chip)\r\n{\r\nunsigned long ssc_rate = clk_get_rate(chip->ssc->clk);\r\nunsigned long dac_rate_new, ssc_div;\r\nint status;\r\nunsigned long ssc_div_max, ssc_div_min;\r\nint max_tries;\r\nssc_div = ssc_rate / (BITRATE_TARGET * 2 * 16);\r\nssc_div_min = ssc_rate / (BITRATE_MAX * 2 * 16);\r\nssc_div_max = ssc_rate / (BITRATE_MIN * 2 * 16);\r\nmax_tries = (ssc_div_max - ssc_div_min) / 2;\r\nif (max_tries < 1)\r\nmax_tries = 1;\r\nssc_div = (ssc_div + 1) & ~1UL;\r\nif ((ssc_rate / (ssc_div * 2 * 16)) < BITRATE_MIN) {\r\nssc_div -= 2;\r\nif ((ssc_rate / (ssc_div * 2 * 16)) > BITRATE_MAX)\r\nreturn -ENXIO;\r\n}\r\ndo {\r\nif ((ssc_rate / (ssc_div * 2 * 16)) < BITRATE_MIN)\r\nreturn -ENXIO;\r\ndac_rate_new = 8 * (ssc_rate / ssc_div);\r\nstatus = clk_round_rate(chip->board->dac_clk, dac_rate_new);\r\nif (status <= 0)\r\nreturn status;\r\nif ((status/256) == (dac_rate_new/256))\r\ngoto set_rate;\r\nssc_div += 2;\r\n} while (--max_tries);\r\nreturn -ENXIO;\r\nset_rate:\r\nstatus = clk_set_rate(chip->board->dac_clk, status);\r\nif (status < 0)\r\nreturn status;\r\nssc_writel(chip->ssc->regs, CMR, ssc_div/2);\r\nchip->bitrate = ssc_rate / (ssc_div * 16 * 2);\r\ndev_info(&chip->spi->dev,\r\n"at73c213: supported bitrate is %lu (%lu divider)\n",\r\nchip->bitrate, ssc_div);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nsnd_at73c213_playback_hw.rate_min = chip->bitrate;\r\nsnd_at73c213_playback_hw.rate_max = chip->bitrate;\r\nruntime->hw = snd_at73c213_playback_hw;\r\nchip->substream = substream;\r\nclk_enable(chip->ssc->clk);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nchip->substream = NULL;\r\nclk_disable(chip->ssc->clk);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nint channels = params_channels(hw_params);\r\nint val;\r\nval = ssc_readl(chip->ssc->regs, TFMR);\r\nval = SSC_BFINS(TFMR_DATNB, channels - 1, val);\r\nssc_writel(chip->ssc->regs, TFMR, val);\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_at73c213_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_at73c213_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint block_size;\r\nblock_size = frames_to_bytes(runtime, runtime->period_size);\r\nchip->period = 0;\r\nssc_writel(chip->ssc->regs, PDC_TPR,\r\n(long)runtime->dma_addr);\r\nssc_writel(chip->ssc->regs, PDC_TCR,\r\nruntime->period_size * runtime->channels);\r\nssc_writel(chip->ssc->regs, PDC_TNPR,\r\n(long)runtime->dma_addr + block_size);\r\nssc_writel(chip->ssc->regs, PDC_TNCR,\r\nruntime->period_size * runtime->channels);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nint retval = 0;\r\nspin_lock(&chip->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nssc_writel(chip->ssc->regs, IER, SSC_BIT(IER_ENDTX));\r\nssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTEN));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nssc_writel(chip->ssc->regs, PDC_PTCR, SSC_BIT(PDC_PTCR_TXTDIS));\r\nssc_writel(chip->ssc->regs, IDR, SSC_BIT(IDR_ENDTX));\r\nbreak;\r\ndefault:\r\ndev_dbg(&chip->spi->dev, "spurious command %x\n", cmd);\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->lock);\r\nreturn retval;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_at73c213_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_at73c213 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t pos;\r\nunsigned long bytes;\r\nbytes = ssc_readl(chip->ssc->regs, PDC_TPR)\r\n- (unsigned long)runtime->dma_addr;\r\npos = bytes_to_frames(runtime, bytes);\r\nif (pos >= runtime->buffer_size)\r\npos -= runtime->buffer_size;\r\nreturn pos;\r\n}\r\nstatic int snd_at73c213_pcm_new(struct snd_at73c213 *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint retval;\r\nretval = snd_pcm_new(chip->card, chip->card->shortname,\r\ndevice, 1, 0, &pcm);\r\nif (retval < 0)\r\ngoto out;\r\npcm->private_data = chip;\r\npcm->info_flags = SNDRV_PCM_INFO_BLOCK_TRANSFER;\r\nstrcpy(pcm->name, "at73c213");\r\nchip->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &at73c213_playback_ops);\r\nretval = snd_pcm_lib_preallocate_pages_for_all(chip->pcm,\r\nSNDRV_DMA_TYPE_DEV, &chip->ssc->pdev->dev,\r\n64 * 1024, 64 * 1024);\r\nout:\r\nreturn retval;\r\n}\r\nstatic irqreturn_t snd_at73c213_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_at73c213 *chip = dev_id;\r\nstruct snd_pcm_runtime *runtime = chip->substream->runtime;\r\nu32 status;\r\nint offset;\r\nint block_size;\r\nint next_period;\r\nint retval = IRQ_NONE;\r\nspin_lock(&chip->lock);\r\nblock_size = frames_to_bytes(runtime, runtime->period_size);\r\nstatus = ssc_readl(chip->ssc->regs, IMR);\r\nif (status & SSC_BIT(IMR_ENDTX)) {\r\nchip->period++;\r\nif (chip->period == runtime->periods)\r\nchip->period = 0;\r\nnext_period = chip->period + 1;\r\nif (next_period == runtime->periods)\r\nnext_period = 0;\r\noffset = block_size * next_period;\r\nssc_writel(chip->ssc->regs, PDC_TNPR,\r\n(long)runtime->dma_addr + offset);\r\nssc_writel(chip->ssc->regs, PDC_TNCR,\r\nruntime->period_size * runtime->channels);\r\nretval = IRQ_HANDLED;\r\n}\r\nssc_readl(chip->ssc->regs, IMR);\r\nspin_unlock(&chip->lock);\r\nif (status & SSC_BIT(IMR_ENDTX))\r\nsnd_pcm_period_elapsed(chip->substream);\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_mono_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nmutex_lock(&chip->mixer_lock);\r\nucontrol->value.integer.value[0] =\r\n(chip->reg_image[reg] >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] =\r\nmask - ucontrol->value.integer.value[0];\r\nmutex_unlock(&chip->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_mono_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change, retval;\r\nunsigned short val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nmutex_lock(&chip->mixer_lock);\r\nval = (chip->reg_image[reg] & ~(mask << shift)) | val;\r\nchange = val != chip->reg_image[reg];\r\nretval = snd_at73c213_write_reg(chip, reg, val);\r\nmutex_unlock(&chip->mixer_lock);\r\nif (retval)\r\nreturn retval;\r\nreturn change;\r\n}\r\nstatic int snd_at73c213_stereo_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nif (mask == 1)\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nelse\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_stereo_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nmutex_lock(&chip->mixer_lock);\r\nucontrol->value.integer.value[0] =\r\n(chip->reg_image[left_reg] >> shift_left) & mask;\r\nucontrol->value.integer.value[1] =\r\n(chip->reg_image[right_reg] >> shift_right) & mask;\r\nif (invert) {\r\nucontrol->value.integer.value[0] =\r\nmask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] =\r\nmask - ucontrol->value.integer.value[1];\r\n}\r\nmutex_unlock(&chip->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_stereo_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change, retval;\r\nunsigned short val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nmutex_lock(&chip->mixer_lock);\r\nval1 = (chip->reg_image[left_reg] & ~(mask << shift_left)) | val1;\r\nval2 = (chip->reg_image[right_reg] & ~(mask << shift_right)) | val2;\r\nchange = val1 != chip->reg_image[left_reg]\r\n|| val2 != chip->reg_image[right_reg];\r\nretval = snd_at73c213_write_reg(chip, left_reg, val1);\r\nif (retval) {\r\nmutex_unlock(&chip->mixer_lock);\r\ngoto out;\r\n}\r\nretval = snd_at73c213_write_reg(chip, right_reg, val2);\r\nif (retval) {\r\nmutex_unlock(&chip->mixer_lock);\r\ngoto out;\r\n}\r\nmutex_unlock(&chip->mixer_lock);\r\nreturn change;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_mono_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nmutex_lock(&chip->mixer_lock);\r\nucontrol->value.integer.value[0] =\r\n(chip->reg_image[reg] >> shift) & 0x01;\r\nif (invert)\r\nucontrol->value.integer.value[0] =\r\n0x01 - ucontrol->value.integer.value[0];\r\nmutex_unlock(&chip->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_mono_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_at73c213 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change, retval;\r\nunsigned short val;\r\nif (ucontrol->value.integer.value[0])\r\nval = mask;\r\nelse\r\nval = 0;\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nmutex_lock(&chip->mixer_lock);\r\nval |= (chip->reg_image[reg] & ~(mask << shift));\r\nchange = val != chip->reg_image[reg];\r\nretval = snd_at73c213_write_reg(chip, reg, val);\r\nmutex_unlock(&chip->mixer_lock);\r\nif (retval)\r\nreturn retval;\r\nreturn change;\r\n}\r\nstatic int snd_at73c213_pa_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = ((kcontrol->private_value >> 16) & 0xff) - 1;\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_line_capture_volume_info(\r\nstruct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 14;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_aux_capture_volume_info(\r\nstruct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 14;\r\nuinfo->value.integer.max = 31;\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_mixer(struct snd_at73c213 *chip)\r\n{\r\nstruct snd_card *card;\r\nint errval, idx;\r\nif (chip == NULL || chip->pcm == NULL)\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nstrcpy(card->mixername, chip->pcm->name);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_at73c213_controls); idx++) {\r\nerrval = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_at73c213_controls[idx],\r\nchip));\r\nif (errval < 0)\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nfor (idx = 1; idx < ARRAY_SIZE(snd_at73c213_controls) + 1; idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_find_numid(card, idx);\r\nif (kctl)\r\nsnd_ctl_remove(card, kctl);\r\n}\r\nreturn errval;\r\n}\r\nstatic int snd_at73c213_ssc_init(struct snd_at73c213 *chip)\r\n{\r\nssc_writel(chip->ssc->regs, TCMR,\r\nSSC_BF(TCMR_CKO, 1)\r\n| SSC_BF(TCMR_START, 4)\r\n| SSC_BF(TCMR_STTDLY, 1)\r\n| SSC_BF(TCMR_PERIOD, 16 - 1));\r\nssc_writel(chip->ssc->regs, TFMR,\r\nSSC_BF(TFMR_DATLEN, 16 - 1)\r\n| SSC_BIT(TFMR_MSBF)\r\n| SSC_BF(TFMR_DATNB, 1)\r\n| SSC_BF(TFMR_FSLEN, 16 - 1)\r\n| SSC_BF(TFMR_FSOS, 1));\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_chip_init(struct snd_at73c213 *chip)\r\n{\r\nint retval;\r\nunsigned char dac_ctrl = 0;\r\nretval = snd_at73c213_set_bitrate(chip);\r\nif (retval)\r\ngoto out;\r\nclk_enable(chip->board->dac_clk);\r\nretval = snd_at73c213_write_reg(chip, DAC_RST, 0x04);\r\nif (retval)\r\ngoto out_clk;\r\nmsleep(1);\r\nretval = snd_at73c213_write_reg(chip, DAC_RST, 0x03);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_PRECH, 0xff);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, PA_CTRL, (1<<PA_CTRL_APAPRECH));\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_CTRL,\r\n(1<<DAC_CTRL_ONLNOL) | (1<<DAC_CTRL_ONLNOR));\r\nif (retval)\r\ngoto out_clk;\r\nmsleep(50);\r\nretval = snd_at73c213_write_reg(chip, PA_CTRL,\r\n(1<<PA_CTRL_APALP) | 0x0f);\r\nif (retval)\r\ngoto out_clk;\r\nmsleep(450);\r\nretval = snd_at73c213_write_reg(chip, DAC_PRECH, (1<<DAC_PRECH_ONMSTR));\r\nif (retval)\r\ngoto out_clk;\r\nmsleep(1);\r\ndac_ctrl = (1<<DAC_CTRL_ONDACL) | (1<<DAC_CTRL_ONDACR)\r\n| (1<<DAC_CTRL_ONLNOL) | (1<<DAC_CTRL_ONLNOR);\r\nretval = snd_at73c213_write_reg(chip, DAC_CTRL, dac_ctrl);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_LMPG, 0x3f);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_RMPG, 0x3f);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_LLOG, 0x3f);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_RLOG, 0x3f);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_LLIG, 0x11);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_RLIG, 0x11);\r\nif (retval)\r\ngoto out_clk;\r\nretval = snd_at73c213_write_reg(chip, DAC_AUXG, 0x11);\r\nif (retval)\r\ngoto out_clk;\r\nssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));\r\ngoto out;\r\nout_clk:\r\nclk_disable(chip->board->dac_clk);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_at73c213 *chip = device->device_data;\r\nssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\r\nif (chip->irq >= 0) {\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_dev_init(struct snd_card *card,\r\nstruct spi_device *spi)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_at73c213_dev_free,\r\n};\r\nstruct snd_at73c213 *chip = get_chip(card);\r\nint irq, retval;\r\nirq = chip->ssc->irq;\r\nif (irq < 0)\r\nreturn irq;\r\nspin_lock_init(&chip->lock);\r\nmutex_init(&chip->mixer_lock);\r\nchip->card = card;\r\nchip->irq = -1;\r\nclk_enable(chip->ssc->clk);\r\nretval = request_irq(irq, snd_at73c213_interrupt, 0, "at73c213", chip);\r\nif (retval) {\r\ndev_dbg(&chip->spi->dev, "unable to request irq %d\n", irq);\r\ngoto out;\r\n}\r\nchip->irq = irq;\r\nmemcpy(&chip->reg_image, &snd_at73c213_original_image,\r\nsizeof(snd_at73c213_original_image));\r\nretval = snd_at73c213_ssc_init(chip);\r\nif (retval)\r\ngoto out_irq;\r\nretval = snd_at73c213_chip_init(chip);\r\nif (retval)\r\ngoto out_irq;\r\nretval = snd_at73c213_pcm_new(chip, 0);\r\nif (retval)\r\ngoto out_irq;\r\nretval = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (retval)\r\ngoto out_irq;\r\nretval = snd_at73c213_mixer(chip);\r\nif (retval)\r\ngoto out_snd_dev;\r\ngoto out;\r\nout_snd_dev:\r\nsnd_device_free(card, chip);\r\nout_irq:\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\nout:\r\nclk_disable(chip->ssc->clk);\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_probe(struct spi_device *spi)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_at73c213 *chip;\r\nstruct at73c213_board_info *board;\r\nint retval;\r\nchar id[16];\r\nboard = spi->dev.platform_data;\r\nif (!board) {\r\ndev_dbg(&spi->dev, "no platform_data\n");\r\nreturn -ENXIO;\r\n}\r\nif (!board->dac_clk) {\r\ndev_dbg(&spi->dev, "no DAC clk\n");\r\nreturn -ENXIO;\r\n}\r\nif (IS_ERR(board->dac_clk)) {\r\ndev_dbg(&spi->dev, "no DAC clk\n");\r\nreturn PTR_ERR(board->dac_clk);\r\n}\r\nsnprintf(id, sizeof id, "at73c213_%d", board->ssc_id);\r\nretval = snd_card_new(&spi->dev, -1, id, THIS_MODULE,\r\nsizeof(struct snd_at73c213), &card);\r\nif (retval < 0)\r\ngoto out;\r\nchip = card->private_data;\r\nchip->spi = spi;\r\nchip->board = board;\r\nchip->ssc = ssc_request(board->ssc_id);\r\nif (IS_ERR(chip->ssc)) {\r\ndev_dbg(&spi->dev, "could not get ssc%d device\n",\r\nboard->ssc_id);\r\nretval = PTR_ERR(chip->ssc);\r\ngoto out_card;\r\n}\r\nretval = snd_at73c213_dev_init(card, spi);\r\nif (retval)\r\ngoto out_ssc;\r\nstrcpy(card->driver, "at73c213");\r\nstrcpy(card->shortname, board->shortname);\r\nsprintf(card->longname, "%s on irq %d", card->shortname, chip->irq);\r\nretval = snd_card_register(card);\r\nif (retval)\r\ngoto out_ssc;\r\ndev_set_drvdata(&spi->dev, card);\r\ngoto out;\r\nout_ssc:\r\nssc_free(chip->ssc);\r\nout_card:\r\nsnd_card_free(card);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int snd_at73c213_remove(struct spi_device *spi)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(&spi->dev);\r\nstruct snd_at73c213 *chip = card->private_data;\r\nint retval;\r\nclk_enable(chip->ssc->clk);\r\nssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\r\nclk_disable(chip->ssc->clk);\r\nretval = snd_at73c213_write_reg(chip, DAC_LMPG, 0x3f);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_RMPG, 0x3f);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_LLOG, 0x3f);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_RLOG, 0x3f);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_LLIG, 0x11);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_RLIG, 0x11);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_AUXG, 0x11);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, PA_CTRL,\r\nchip->reg_image[PA_CTRL] | 0x0f);\r\nif (retval)\r\ngoto out;\r\nmsleep(10);\r\nretval = snd_at73c213_write_reg(chip, PA_CTRL,\r\n(1 << PA_CTRL_APALP) | 0x0f);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_CTRL, 0x0c);\r\nif (retval)\r\ngoto out;\r\nmsleep(2);\r\nretval = snd_at73c213_write_reg(chip, DAC_CTRL, 0x00);\r\nif (retval)\r\ngoto out;\r\nretval = snd_at73c213_write_reg(chip, DAC_PRECH, 0x00);\r\nif (retval)\r\ngoto out;\r\nout:\r\nclk_disable(chip->board->dac_clk);\r\nssc_free(chip->ssc);\r\nsnd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_at73c213 *chip = card->private_data;\r\nssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXDIS));\r\nclk_disable(chip->ssc->clk);\r\nclk_disable(chip->board->dac_clk);\r\nreturn 0;\r\n}\r\nstatic int snd_at73c213_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_at73c213 *chip = card->private_data;\r\nclk_enable(chip->board->dac_clk);\r\nclk_enable(chip->ssc->clk);\r\nssc_writel(chip->ssc->regs, CR, SSC_BIT(CR_TXEN));\r\nreturn 0;\r\n}
