static int lpc18xx_otp_read(void *context, unsigned int offset,\r\nvoid *val, size_t bytes)\r\n{\r\nstruct lpc18xx_otp *otp = context;\r\nunsigned int count = bytes >> 2;\r\nu32 index = offset >> 2;\r\nu32 *buf = val;\r\nint i;\r\nif (count > (LPC18XX_OTP_SIZE - index))\r\ncount = LPC18XX_OTP_SIZE - index;\r\nfor (i = index; i < (index + count); i++)\r\n*buf++ = readl(otp->base + i * LPC18XX_OTP_WORD_SIZE);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_otp_probe(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem;\r\nstruct lpc18xx_otp *otp;\r\nstruct resource *res;\r\notp = devm_kzalloc(&pdev->dev, sizeof(*otp), GFP_KERNEL);\r\nif (!otp)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\notp->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(otp->base))\r\nreturn PTR_ERR(otp->base);\r\nlpc18xx_otp_nvmem_config.size = LPC18XX_OTP_SIZE;\r\nlpc18xx_otp_nvmem_config.dev = &pdev->dev;\r\nlpc18xx_otp_nvmem_config.priv = otp;\r\nnvmem = nvmem_register(&lpc18xx_otp_nvmem_config);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_otp_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
