static int mpc8572_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nu32 val;\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\r\nu32 out_mask, out_shadow;\r\nout_mask = gc->read_reg(mpc8xxx_gc->regs + GPIO_DIR);\r\nval = gc->read_reg(mpc8xxx_gc->regs + GPIO_DAT) & ~out_mask;\r\nout_shadow = gc->bgpio_data & out_mask;\r\nreturn !!((val | out_shadow) & gc->pin2mask(gc, gpio));\r\n}\r\nstatic int mpc5121_gpio_dir_out(struct gpio_chip *gc,\r\nunsigned int gpio, int val)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\r\nif (gpio >= 28)\r\nreturn -EINVAL;\r\nreturn mpc8xxx_gc->direction_output(gc, gpio, val);\r\n}\r\nstatic int mpc5125_gpio_dir_out(struct gpio_chip *gc,\r\nunsigned int gpio, int val)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\r\nif (gpio <= 3)\r\nreturn -EINVAL;\r\nreturn mpc8xxx_gc->direction_output(gc, gpio, val);\r\n}\r\nstatic int mpc8xxx_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = gpiochip_get_data(gc);\r\nif (mpc8xxx_gc->irq && offset < MPC8XXX_GPIO_PINS)\r\nreturn irq_create_mapping(mpc8xxx_gc->irq, offset);\r\nelse\r\nreturn -ENXIO;\r\n}\r\nstatic void mpc8xxx_gpio_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\nunsigned int mask;\r\nmask = gc->read_reg(mpc8xxx_gc->regs + GPIO_IER)\r\n& gc->read_reg(mpc8xxx_gc->regs + GPIO_IMR);\r\nif (mask)\r\ngeneric_handle_irq(irq_linear_revmap(mpc8xxx_gc->irq,\r\n32 - ffs(mask)));\r\nif (chip->irq_eoi)\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic void mpc8xxx_irq_unmask(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_IMR,\r\ngc->read_reg(mpc8xxx_gc->regs + GPIO_IMR)\r\n| gc->pin2mask(gc, irqd_to_hwirq(d)));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\n}\r\nstatic void mpc8xxx_irq_mask(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_IMR,\r\ngc->read_reg(mpc8xxx_gc->regs + GPIO_IMR)\r\n& ~(gc->pin2mask(gc, irqd_to_hwirq(d))));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\n}\r\nstatic void mpc8xxx_irq_ack(struct irq_data *d)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_IER,\r\ngc->pin2mask(gc, irqd_to_hwirq(d)));\r\n}\r\nstatic int mpc8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\nunsigned long flags;\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_ICR,\r\ngc->read_reg(mpc8xxx_gc->regs + GPIO_ICR)\r\n| gc->pin2mask(gc, irqd_to_hwirq(d)));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_ICR,\r\ngc->read_reg(mpc8xxx_gc->regs + GPIO_ICR)\r\n& ~(gc->pin2mask(gc, irqd_to_hwirq(d))));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc512x_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = irq_data_get_irq_chip_data(d);\r\nstruct gpio_chip *gc = &mpc8xxx_gc->gc;\r\nunsigned long gpio = irqd_to_hwirq(d);\r\nvoid __iomem *reg;\r\nunsigned int shift;\r\nunsigned long flags;\r\nif (gpio < 16) {\r\nreg = mpc8xxx_gc->regs + GPIO_ICR;\r\nshift = (15 - gpio) * 2;\r\n} else {\r\nreg = mpc8xxx_gc->regs + GPIO_ICR2;\r\nshift = (15 - (gpio % 16)) * 2;\r\n}\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift))\r\n| (2 << shift));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift))\r\n| (1 << shift));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nraw_spin_lock_irqsave(&mpc8xxx_gc->lock, flags);\r\ngc->write_reg(reg, (gc->read_reg(reg) & ~(3 << shift)));\r\nraw_spin_unlock_irqrestore(&mpc8xxx_gc->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_gpio_irq_map(struct irq_domain *h, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_data(irq, h->host_data);\r\nirq_set_chip_and_handler(irq, &mpc8xxx_irq_chip, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc;\r\nstruct gpio_chip *gc;\r\nconst struct mpc8xxx_gpio_devtype *devtype =\r\nof_device_get_match_data(&pdev->dev);\r\nint ret;\r\nmpc8xxx_gc = devm_kzalloc(&pdev->dev, sizeof(*mpc8xxx_gc), GFP_KERNEL);\r\nif (!mpc8xxx_gc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mpc8xxx_gc);\r\nraw_spin_lock_init(&mpc8xxx_gc->lock);\r\nmpc8xxx_gc->regs = of_iomap(np, 0);\r\nif (!mpc8xxx_gc->regs)\r\nreturn -ENOMEM;\r\ngc = &mpc8xxx_gc->gc;\r\nif (of_property_read_bool(np, "little-endian")) {\r\nret = bgpio_init(gc, &pdev->dev, 4,\r\nmpc8xxx_gc->regs + GPIO_DAT,\r\nNULL, NULL,\r\nmpc8xxx_gc->regs + GPIO_DIR, NULL,\r\nBGPIOF_BIG_ENDIAN);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&pdev->dev, "GPIO registers are LITTLE endian\n");\r\n} else {\r\nret = bgpio_init(gc, &pdev->dev, 4,\r\nmpc8xxx_gc->regs + GPIO_DAT,\r\nNULL, NULL,\r\nmpc8xxx_gc->regs + GPIO_DIR, NULL,\r\nBGPIOF_BIG_ENDIAN\r\n| BGPIOF_BIG_ENDIAN_BYTE_ORDER);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&pdev->dev, "GPIO registers are BIG endian\n");\r\n}\r\nmpc8xxx_gc->direction_output = gc->direction_output;\r\nif (!devtype)\r\ndevtype = &mpc8xxx_gpio_devtype_default;\r\nmpc8xxx_irq_chip.irq_set_type = devtype->irq_set_type;\r\nif (devtype->gpio_dir_out)\r\ngc->direction_output = devtype->gpio_dir_out;\r\nif (devtype->gpio_get)\r\ngc->get = devtype->gpio_get;\r\ngc->to_irq = mpc8xxx_gpio_to_irq;\r\nret = gpiochip_add_data(gc, mpc8xxx_gc);\r\nif (ret) {\r\npr_err("%s: GPIO chip registration failed with status %d\n",\r\nnp->full_name, ret);\r\ngoto err;\r\n}\r\nmpc8xxx_gc->irqn = irq_of_parse_and_map(np, 0);\r\nif (!mpc8xxx_gc->irqn)\r\nreturn 0;\r\nmpc8xxx_gc->irq = irq_domain_add_linear(np, MPC8XXX_GPIO_PINS,\r\n&mpc8xxx_gpio_irq_ops, mpc8xxx_gc);\r\nif (!mpc8xxx_gc->irq)\r\nreturn 0;\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_IER, 0xffffffff);\r\ngc->write_reg(mpc8xxx_gc->regs + GPIO_IMR, 0);\r\nirq_set_chained_handler_and_data(mpc8xxx_gc->irqn,\r\nmpc8xxx_gpio_irq_cascade, mpc8xxx_gc);\r\nreturn 0;\r\nerr:\r\niounmap(mpc8xxx_gc->regs);\r\nreturn ret;\r\n}\r\nstatic int mpc8xxx_remove(struct platform_device *pdev)\r\n{\r\nstruct mpc8xxx_gpio_chip *mpc8xxx_gc = platform_get_drvdata(pdev);\r\nif (mpc8xxx_gc->irq) {\r\nirq_set_chained_handler_and_data(mpc8xxx_gc->irqn, NULL, NULL);\r\nirq_domain_remove(mpc8xxx_gc->irq);\r\n}\r\ngpiochip_remove(&mpc8xxx_gc->gc);\r\niounmap(mpc8xxx_gc->regs);\r\nreturn 0;\r\n}\r\nstatic int __init mpc8xxx_init(void)\r\n{\r\nreturn platform_driver_register(&mpc8xxx_plat_driver);\r\n}
