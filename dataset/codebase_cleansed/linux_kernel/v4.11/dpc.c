int vnt_rx_data(struct vnt_private *priv, struct vnt_rcb *ptr_rcb,\r\nunsigned long bytes_received)\r\n{\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct ieee80211_supported_band *sband;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_rx_status rx_status = { 0 };\r\nstruct ieee80211_hdr *hdr;\r\n__le16 fc;\r\nu8 *rsr, *new_rsr, *rssi, *frame;\r\n__le64 *tsf_time;\r\nu32 frame_size;\r\nint ii, r;\r\nu8 *rx_rate, *sq, *sq_3;\r\nu32 wbk_status;\r\nu8 *skb_data;\r\nu16 *pay_load_len;\r\nu16 pay_load_with_padding;\r\nu8 rate_idx = 0;\r\nu8 rate[MAX_RATE] = {2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108};\r\nlong rx_dbm;\r\nskb = ptr_rcb->skb;\r\nwbk_status = *((u32 *)(skb->data));\r\nframe_size = wbk_status >> 16;\r\nframe_size += 4;\r\nif (bytes_received != frame_size) {\r\ndev_dbg(&priv->usb->dev, "------- WRONG Length 1\n");\r\nreturn false;\r\n}\r\nif ((bytes_received > 2372) || (bytes_received <= 40)) {\r\ndev_dbg(&priv->usb->dev, "------ WRONG Length 2\n");\r\nreturn false;\r\n}\r\nskb_data = (u8 *)skb->data;\r\nrx_rate = skb_data + 5;\r\npay_load_len = (u16 *)(skb_data + 6);\r\nif (((bytes_received - (*pay_load_len)) > 27) ||\r\n((bytes_received - (*pay_load_len)) < 24) ||\r\n(bytes_received < (*pay_load_len))) {\r\ndev_dbg(&priv->usb->dev, "Wrong PLCP Length %x\n",\r\n*pay_load_len);\r\nreturn false;\r\n}\r\nsband = hw->wiphy->bands[hw->conf.chandef.chan->band];\r\nfor (r = RATE_1M; r < MAX_RATE; r++) {\r\nif (*rx_rate == rate[r])\r\nbreak;\r\n}\r\npriv->rx_rate = r;\r\nfor (ii = 0; ii < sband->n_bitrates; ii++) {\r\nif (sband->bitrates[ii].hw_value == r) {\r\nrate_idx = ii;\r\nbreak;\r\n}\r\n}\r\nif (ii == sband->n_bitrates) {\r\ndev_dbg(&priv->usb->dev, "Wrong RxRate %x\n", *rx_rate);\r\nreturn false;\r\n}\r\npay_load_with_padding = ((*pay_load_len / 4) +\r\n((*pay_load_len % 4) ? 1 : 0)) * 4;\r\ntsf_time = (__le64 *)(skb_data + 8 + pay_load_with_padding);\r\npriv->tsf_time = le64_to_cpu(*tsf_time);\r\nif (priv->bb_type == BB_TYPE_11G) {\r\nsq_3 = skb_data + 8 + pay_load_with_padding + 12;\r\nsq = sq_3;\r\n} else {\r\nsq = skb_data + 8 + pay_load_with_padding + 8;\r\nsq_3 = sq;\r\n}\r\nnew_rsr = skb_data + 8 + pay_load_with_padding + 9;\r\nrssi = skb_data + 8 + pay_load_with_padding + 10;\r\nrsr = skb_data + 8 + pay_load_with_padding + 11;\r\nif (*rsr & (RSR_IVLDTYP | RSR_IVLDLEN))\r\nreturn false;\r\nframe_size = *pay_load_len;\r\nvnt_rf_rssi_to_dbm(priv, *rssi, &rx_dbm);\r\npriv->bb_pre_ed_rssi = (u8)rx_dbm + 1;\r\npriv->current_rssi = priv->bb_pre_ed_rssi;\r\nframe = skb_data + 8;\r\nskb_pull(skb, 8);\r\nskb_trim(skb, frame_size);\r\nrx_status.mactime = priv->tsf_time;\r\nrx_status.band = hw->conf.chandef.chan->band;\r\nrx_status.signal = rx_dbm;\r\nrx_status.flag = 0;\r\nrx_status.freq = hw->conf.chandef.chan->center_freq;\r\nif (!(*rsr & RSR_CRCOK))\r\nrx_status.flag |= RX_FLAG_FAILED_FCS_CRC;\r\nhdr = (struct ieee80211_hdr *)(skb->data);\r\nfc = hdr->frame_control;\r\nrx_status.rate_idx = rate_idx;\r\nif (ieee80211_has_protected(fc)) {\r\nif (priv->local_id > REV_ID_VT3253_A1) {\r\nrx_status.flag |= RX_FLAG_DECRYPTED;\r\nif (!(*new_rsr & NEWRSR_DECRYPTOK)) {\r\ndev_kfree_skb(skb);\r\nreturn true;\r\n}\r\n}\r\n}\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(priv->hw, skb);\r\nreturn true;\r\n}
