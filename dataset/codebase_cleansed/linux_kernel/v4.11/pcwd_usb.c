static void usb_pcwd_intr_done(struct urb *urb)\r\n{\r\nstruct usb_pcwd_private *usb_pcwd =\r\n(struct usb_pcwd_private *)urb->context;\r\nunsigned char *data = usb_pcwd->intr_buffer;\r\nstruct device *dev = &usb_pcwd->interface->dev;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d",\r\n__func__, urb->status);\r\ngoto resubmit;\r\n}\r\ndev_dbg(dev, "received following data cmd=0x%02x msb=0x%02x lsb=0x%02x",\r\ndata[0], data[1], data[2]);\r\nusb_pcwd->cmd_command = data[0];\r\nusb_pcwd->cmd_data_msb = data[1];\r\nusb_pcwd->cmd_data_lsb = data[2];\r\natomic_set(&usb_pcwd->cmd_received, 1);\r\nresubmit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\npr_err("can't resubmit intr, usb_submit_urb failed with result %d\n",\r\nretval);\r\n}\r\nstatic int usb_pcwd_send_command(struct usb_pcwd_private *usb_pcwd,\r\nunsigned char cmd, unsigned char *msb, unsigned char *lsb)\r\n{\r\nint got_response, count;\r\nunsigned char *buf;\r\nif ((!usb_pcwd) || (!usb_pcwd->exists))\r\nreturn -1;\r\nbuf = kmalloc(6, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn 0;\r\nbuf[0] = cmd;\r\nbuf[1] = *msb;\r\nbuf[2] = *lsb;\r\nbuf[3] = buf[4] = buf[5] = 0;\r\ndev_dbg(&usb_pcwd->interface->dev,\r\n"sending following data cmd=0x%02x msb=0x%02x lsb=0x%02x",\r\nbuf[0], buf[1], buf[2]);\r\natomic_set(&usb_pcwd->cmd_received, 0);\r\nif (usb_control_msg(usb_pcwd->udev, usb_sndctrlpipe(usb_pcwd->udev, 0),\r\nHID_REQ_SET_REPORT, HID_DT_REPORT,\r\n0x0200, usb_pcwd->interface_number, buf, 6,\r\nUSB_COMMAND_TIMEOUT) != 6) {\r\ndev_dbg(&usb_pcwd->interface->dev,\r\n"usb_pcwd_send_command: error in usb_control_msg for cmd 0x%x 0x%x 0x%x\n",\r\ncmd, *msb, *lsb);\r\n}\r\ngot_response = 0;\r\nfor (count = 0; (count < USB_COMMAND_TIMEOUT) && (!got_response);\r\ncount++) {\r\nmdelay(1);\r\nif (atomic_read(&usb_pcwd->cmd_received))\r\ngot_response = 1;\r\n}\r\nif ((got_response) && (cmd == usb_pcwd->cmd_command)) {\r\n*msb = usb_pcwd->cmd_data_msb;\r\n*lsb = usb_pcwd->cmd_data_lsb;\r\n}\r\nkfree(buf);\r\nreturn got_response;\r\n}\r\nstatic int usb_pcwd_start(struct usb_pcwd_private *usb_pcwd)\r\n{\r\nunsigned char msb = 0x00;\r\nunsigned char lsb = 0x00;\r\nint retval;\r\nretval = usb_pcwd_send_command(usb_pcwd, CMD_ENABLE_WATCHDOG,\r\n&msb, &lsb);\r\nif ((retval == 0) || (lsb == 0)) {\r\npr_err("Card did not acknowledge enable attempt\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_stop(struct usb_pcwd_private *usb_pcwd)\r\n{\r\nunsigned char msb = 0xA5;\r\nunsigned char lsb = 0xC3;\r\nint retval;\r\nretval = usb_pcwd_send_command(usb_pcwd, CMD_DISABLE_WATCHDOG,\r\n&msb, &lsb);\r\nif ((retval == 0) || (lsb != 0)) {\r\npr_err("Card did not acknowledge disable attempt\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_keepalive(struct usb_pcwd_private *usb_pcwd)\r\n{\r\nunsigned char dummy;\r\nusb_pcwd_send_command(usb_pcwd, CMD_TRIGGER, &dummy, &dummy);\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_set_heartbeat(struct usb_pcwd_private *usb_pcwd, int t)\r\n{\r\nunsigned char msb = t / 256;\r\nunsigned char lsb = t % 256;\r\nif ((t < 0x0001) || (t > 0xFFFF))\r\nreturn -EINVAL;\r\nusb_pcwd_send_command(usb_pcwd, CMD_WRITE_WATCHDOG_TIMEOUT, &msb, &lsb);\r\nheartbeat = t;\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_get_temperature(struct usb_pcwd_private *usb_pcwd,\r\nint *temperature)\r\n{\r\nunsigned char msb, lsb;\r\nusb_pcwd_send_command(usb_pcwd, CMD_READ_TEMP, &msb, &lsb);\r\n*temperature = (lsb * 9 / 5) + 32;\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_get_timeleft(struct usb_pcwd_private *usb_pcwd,\r\nint *time_left)\r\n{\r\nunsigned char msb, lsb;\r\nusb_pcwd_send_command(usb_pcwd, CMD_READ_WATCHDOG_TIMEOUT, &msb, &lsb);\r\n*time_left = (msb << 8) + lsb;\r\nreturn 0;\r\n}\r\nstatic ssize_t usb_pcwd_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_release = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_release = 42;\r\n}\r\n}\r\nusb_pcwd_keepalive(usb_pcwd_device);\r\n}\r\nreturn len;\r\n}\r\nstatic long usb_pcwd_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = DRIVER_NAME,\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_GETTEMP:\r\n{\r\nint temperature;\r\nif (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))\r\nreturn -EFAULT;\r\nreturn put_user(temperature, p);\r\n}\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint new_options, retval = -EINVAL;\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nusb_pcwd_stop(usb_pcwd_device);\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nusb_pcwd_start(usb_pcwd_device);\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nusb_pcwd_keepalive(usb_pcwd_device);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\n{\r\nint new_heartbeat;\r\nif (get_user(new_heartbeat, p))\r\nreturn -EFAULT;\r\nif (usb_pcwd_set_heartbeat(usb_pcwd_device, new_heartbeat))\r\nreturn -EINVAL;\r\nusb_pcwd_keepalive(usb_pcwd_device);\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(heartbeat, p);\r\ncase WDIOC_GETTIMELEFT:\r\n{\r\nint time_left;\r\nif (usb_pcwd_get_timeleft(usb_pcwd_device, &time_left))\r\nreturn -EFAULT;\r\nreturn put_user(time_left, p);\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int usb_pcwd_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &is_active))\r\nreturn -EBUSY;\r\nusb_pcwd_start(usb_pcwd_device);\r\nusb_pcwd_keepalive(usb_pcwd_device);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int usb_pcwd_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_release == 42) {\r\nusb_pcwd_stop(usb_pcwd_device);\r\n} else {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nusb_pcwd_keepalive(usb_pcwd_device);\r\n}\r\nexpect_release = 0;\r\nclear_bit(0, &is_active);\r\nreturn 0;\r\n}\r\nstatic ssize_t usb_pcwd_temperature_read(struct file *file, char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint temperature;\r\nif (usb_pcwd_get_temperature(usb_pcwd_device, &temperature))\r\nreturn -EFAULT;\r\nif (copy_to_user(data, &temperature, 1))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic int usb_pcwd_temperature_open(struct inode *inode, struct file *file)\r\n{\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int usb_pcwd_temperature_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usb_pcwd_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nusb_pcwd_stop(usb_pcwd_device);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic inline void usb_pcwd_delete(struct usb_pcwd_private *usb_pcwd)\r\n{\r\nusb_free_urb(usb_pcwd->intr_urb);\r\nif (usb_pcwd->intr_buffer != NULL)\r\nusb_free_coherent(usb_pcwd->udev, usb_pcwd->intr_size,\r\nusb_pcwd->intr_buffer, usb_pcwd->intr_dma);\r\nkfree(usb_pcwd);\r\n}\r\nstatic int usb_pcwd_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_pcwd_private *usb_pcwd = NULL;\r\nint pipe;\r\nint retval = -ENOMEM;\r\nint got_fw_rev;\r\nunsigned char fw_rev_major, fw_rev_minor;\r\nchar fw_ver_str[20];\r\nunsigned char option_switches, dummy;\r\ncards_found++;\r\nif (cards_found > 1) {\r\npr_err("This driver only supports 1 device\n");\r\nreturn -ENODEV;\r\n}\r\niface_desc = interface->cur_altsetting;\r\nif (!(iface_desc->desc.bInterfaceClass == USB_CLASS_HID)) {\r\npr_err("The device isn't a Human Interface Device\n");\r\nreturn -ENODEV;\r\n}\r\nendpoint = &iface_desc->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint)) {\r\npr_err("Couldn't find an INTR & IN endpoint\n");\r\nreturn -ENODEV;\r\n}\r\npipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\r\nusb_pcwd = kzalloc(sizeof(struct usb_pcwd_private), GFP_KERNEL);\r\nif (usb_pcwd == NULL)\r\ngoto error;\r\nusb_pcwd_device = usb_pcwd;\r\nmutex_init(&usb_pcwd->mtx);\r\nusb_pcwd->udev = udev;\r\nusb_pcwd->interface = interface;\r\nusb_pcwd->interface_number = iface_desc->desc.bInterfaceNumber;\r\nusb_pcwd->intr_size = (le16_to_cpu(endpoint->wMaxPacketSize) > 8 ?\r\nle16_to_cpu(endpoint->wMaxPacketSize) : 8);\r\nusb_pcwd->intr_buffer = usb_alloc_coherent(udev, usb_pcwd->intr_size,\r\nGFP_ATOMIC, &usb_pcwd->intr_dma);\r\nif (!usb_pcwd->intr_buffer) {\r\npr_err("Out of memory\n");\r\ngoto error;\r\n}\r\nusb_pcwd->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!usb_pcwd->intr_urb)\r\ngoto error;\r\nusb_fill_int_urb(usb_pcwd->intr_urb, udev, pipe,\r\nusb_pcwd->intr_buffer, usb_pcwd->intr_size,\r\nusb_pcwd_intr_done, usb_pcwd, endpoint->bInterval);\r\nusb_pcwd->intr_urb->transfer_dma = usb_pcwd->intr_dma;\r\nusb_pcwd->intr_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (usb_submit_urb(usb_pcwd->intr_urb, GFP_KERNEL)) {\r\npr_err("Problem registering interrupt URB\n");\r\nretval = -EIO;\r\ngoto error;\r\n}\r\nusb_pcwd->exists = 1;\r\nusb_pcwd_stop(usb_pcwd);\r\ngot_fw_rev = usb_pcwd_send_command(usb_pcwd, CMD_GET_FIRMWARE_VERSION,\r\n&fw_rev_major, &fw_rev_minor);\r\nif (got_fw_rev)\r\nsprintf(fw_ver_str, "%u.%02u", fw_rev_major, fw_rev_minor);\r\nelse\r\nsprintf(fw_ver_str, "<card no answer>");\r\npr_info("Found card (Firmware: %s) with temp option\n", fw_ver_str);\r\nusb_pcwd_send_command(usb_pcwd, CMD_GET_DIP_SWITCH_SETTINGS, &dummy,\r\n&option_switches);\r\npr_info("Option switches (0x%02x): Temperature Reset Enable=%s, Power On Delay=%s\n",\r\noption_switches,\r\n((option_switches & 0x10) ? "ON" : "OFF"),\r\n((option_switches & 0x08) ? "ON" : "OFF"));\r\nif (heartbeat == 0)\r\nheartbeat = heartbeat_tbl[(option_switches & 0x07)];\r\nif (usb_pcwd_set_heartbeat(usb_pcwd, heartbeat)) {\r\nusb_pcwd_set_heartbeat(usb_pcwd, WATCHDOG_HEARTBEAT);\r\npr_info("heartbeat value must be 0<heartbeat<65536, using %d\n",\r\nWATCHDOG_HEARTBEAT);\r\n}\r\nretval = register_reboot_notifier(&usb_pcwd_notifier);\r\nif (retval != 0) {\r\npr_err("cannot register reboot notifier (err=%d)\n", retval);\r\ngoto error;\r\n}\r\nretval = misc_register(&usb_pcwd_temperature_miscdev);\r\nif (retval != 0) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nTEMP_MINOR, retval);\r\ngoto err_out_unregister_reboot;\r\n}\r\nretval = misc_register(&usb_pcwd_miscdev);\r\nif (retval != 0) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, retval);\r\ngoto err_out_misc_deregister;\r\n}\r\nusb_set_intfdata(interface, usb_pcwd);\r\npr_info("initialized. heartbeat=%d sec (nowayout=%d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\nerr_out_misc_deregister:\r\nmisc_deregister(&usb_pcwd_temperature_miscdev);\r\nerr_out_unregister_reboot:\r\nunregister_reboot_notifier(&usb_pcwd_notifier);\r\nerror:\r\nif (usb_pcwd)\r\nusb_pcwd_delete(usb_pcwd);\r\nusb_pcwd_device = NULL;\r\nreturn retval;\r\n}\r\nstatic void usb_pcwd_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_pcwd_private *usb_pcwd;\r\nmutex_lock(&disconnect_mutex);\r\nusb_pcwd = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nmutex_lock(&usb_pcwd->mtx);\r\nif (!nowayout)\r\nusb_pcwd_stop(usb_pcwd);\r\nusb_pcwd->exists = 0;\r\nmisc_deregister(&usb_pcwd_miscdev);\r\nmisc_deregister(&usb_pcwd_temperature_miscdev);\r\nunregister_reboot_notifier(&usb_pcwd_notifier);\r\nmutex_unlock(&usb_pcwd->mtx);\r\nusb_pcwd_delete(usb_pcwd);\r\ncards_found--;\r\nmutex_unlock(&disconnect_mutex);\r\npr_info("USB PC Watchdog disconnected\n");\r\n}
