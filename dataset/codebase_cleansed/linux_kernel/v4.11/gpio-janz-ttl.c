static int ttl_get_value(struct gpio_chip *gpio, unsigned offset)\r\n{\r\nstruct ttl_module *mod = dev_get_drvdata(gpio->parent);\r\nu8 *shadow;\r\nint ret;\r\nif (offset < 8) {\r\nshadow = &mod->porta_shadow;\r\n} else if (offset < 16) {\r\nshadow = &mod->portb_shadow;\r\noffset -= 8;\r\n} else {\r\nshadow = &mod->portc_shadow;\r\noffset -= 16;\r\n}\r\nspin_lock(&mod->lock);\r\nret = *shadow & (1 << offset);\r\nspin_unlock(&mod->lock);\r\nreturn !!ret;\r\n}\r\nstatic void ttl_set_value(struct gpio_chip *gpio, unsigned offset, int value)\r\n{\r\nstruct ttl_module *mod = dev_get_drvdata(gpio->parent);\r\nvoid __iomem *port;\r\nu8 *shadow;\r\nif (offset < 8) {\r\nport = &mod->regs->porta;\r\nshadow = &mod->porta_shadow;\r\n} else if (offset < 16) {\r\nport = &mod->regs->portb;\r\nshadow = &mod->portb_shadow;\r\noffset -= 8;\r\n} else {\r\nport = &mod->regs->portc;\r\nshadow = &mod->portc_shadow;\r\noffset -= 16;\r\n}\r\nspin_lock(&mod->lock);\r\nif (value)\r\n*shadow |= (1 << offset);\r\nelse\r\n*shadow &= ~(1 << offset);\r\niowrite16be(*shadow, port);\r\nspin_unlock(&mod->lock);\r\n}\r\nstatic void ttl_write_reg(struct ttl_module *mod, u8 reg, u16 val)\r\n{\r\niowrite16be(reg, &mod->regs->control);\r\niowrite16be(val, &mod->regs->control);\r\n}\r\nstatic void ttl_setup_device(struct ttl_module *mod)\r\n{\r\niowrite16be(0x0000, &mod->regs->control);\r\niowrite16be(0x0001, &mod->regs->control);\r\niowrite16be(0x0000, &mod->regs->control);\r\nttl_write_reg(mod, PORTA_IOCTL, 0x00ff);\r\nttl_write_reg(mod, PORTB_IOCTL, 0x00ff);\r\nttl_write_reg(mod, PORTC_IOCTL, 0x000f);\r\nttl_write_reg(mod, PORTA_DIRECTION, 0x0000);\r\nttl_write_reg(mod, PORTB_DIRECTION, 0x0000);\r\nttl_write_reg(mod, PORTC_DIRECTION, 0x0000);\r\niowrite16be(0x0000, &mod->regs->porta);\r\niowrite16be(0x0000, &mod->regs->portb);\r\niowrite16be(0x0000, &mod->regs->portc);\r\nttl_write_reg(mod, MASTER_CONF_CTL, CONF_PAE | CONF_PBE | CONF_PCE);\r\n}\r\nstatic int ttl_probe(struct platform_device *pdev)\r\n{\r\nstruct janz_platform_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct ttl_module *mod;\r\nstruct gpio_chip *gpio;\r\nstruct resource *res;\r\nint ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(dev, "no platform data\n");\r\nreturn -ENXIO;\r\n}\r\nmod = devm_kzalloc(dev, sizeof(*mod), GFP_KERNEL);\r\nif (!mod)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mod);\r\nspin_lock_init(&mod->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmod->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mod->regs))\r\nreturn PTR_ERR(mod->regs);\r\nttl_setup_device(mod);\r\ngpio = &mod->gpio;\r\ngpio->parent = &pdev->dev;\r\ngpio->label = pdev->name;\r\ngpio->get = ttl_get_value;\r\ngpio->set = ttl_set_value;\r\ngpio->owner = THIS_MODULE;\r\ngpio->base = -1;\r\ngpio->ngpio = 20;\r\nret = devm_gpiochip_add_data(dev, gpio, NULL);\r\nif (ret) {\r\ndev_err(dev, "unable to add GPIO chip\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
