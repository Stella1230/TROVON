static int tunnel_key_act(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_tunnel_key *t = to_tunnel_key(a);\r\nstruct tcf_tunnel_key_params *params;\r\nint action;\r\nrcu_read_lock();\r\nparams = rcu_dereference(t->params);\r\ntcf_lastuse_update(&t->tcf_tm);\r\nbstats_cpu_update(this_cpu_ptr(t->common.cpu_bstats), skb);\r\naction = params->action;\r\nswitch (params->tcft_action) {\r\ncase TCA_TUNNEL_KEY_ACT_RELEASE:\r\nskb_dst_drop(skb);\r\nbreak;\r\ncase TCA_TUNNEL_KEY_ACT_SET:\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst_clone(&params->tcft_enc_metadata->dst));\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Bad tunnel_key action %d.\n",\r\nparams->tcft_action);\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn action;\r\n}\r\nstatic int tunnel_key_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a,\r\nint ovr, int bind)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, tunnel_key_net_id);\r\nstruct nlattr *tb[TCA_TUNNEL_KEY_MAX + 1];\r\nstruct tcf_tunnel_key_params *params_old;\r\nstruct tcf_tunnel_key_params *params_new;\r\nstruct metadata_dst *metadata = NULL;\r\nstruct tc_tunnel_key *parm;\r\nstruct tcf_tunnel_key *t;\r\nbool exists = false;\r\n__be16 dst_port = 0;\r\n__be64 key_id;\r\nint ret = 0;\r\nint err;\r\nif (!nla)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_TUNNEL_KEY_MAX, nla, tunnel_key_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[TCA_TUNNEL_KEY_PARMS])\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_TUNNEL_KEY_PARMS]);\r\nexists = tcf_hash_check(tn, parm->index, a, bind);\r\nif (exists && bind)\r\nreturn 0;\r\nswitch (parm->t_action) {\r\ncase TCA_TUNNEL_KEY_ACT_RELEASE:\r\nbreak;\r\ncase TCA_TUNNEL_KEY_ACT_SET:\r\nif (!tb[TCA_TUNNEL_KEY_ENC_KEY_ID]) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nkey_id = key32_to_tunnel_id(nla_get_be32(tb[TCA_TUNNEL_KEY_ENC_KEY_ID]));\r\nif (tb[TCA_TUNNEL_KEY_ENC_DST_PORT])\r\ndst_port = nla_get_be16(tb[TCA_TUNNEL_KEY_ENC_DST_PORT]);\r\nif (tb[TCA_TUNNEL_KEY_ENC_IPV4_SRC] &&\r\ntb[TCA_TUNNEL_KEY_ENC_IPV4_DST]) {\r\n__be32 saddr;\r\n__be32 daddr;\r\nsaddr = nla_get_in_addr(tb[TCA_TUNNEL_KEY_ENC_IPV4_SRC]);\r\ndaddr = nla_get_in_addr(tb[TCA_TUNNEL_KEY_ENC_IPV4_DST]);\r\nmetadata = __ip_tun_set_dst(saddr, daddr, 0, 0,\r\ndst_port, TUNNEL_KEY,\r\nkey_id, 0);\r\n} else if (tb[TCA_TUNNEL_KEY_ENC_IPV6_SRC] &&\r\ntb[TCA_TUNNEL_KEY_ENC_IPV6_DST]) {\r\nstruct in6_addr saddr;\r\nstruct in6_addr daddr;\r\nsaddr = nla_get_in6_addr(tb[TCA_TUNNEL_KEY_ENC_IPV6_SRC]);\r\ndaddr = nla_get_in6_addr(tb[TCA_TUNNEL_KEY_ENC_IPV6_DST]);\r\nmetadata = __ipv6_tun_set_dst(&saddr, &daddr, 0, 0, dst_port,\r\n0, TUNNEL_KEY,\r\nkey_id, 0);\r\n}\r\nif (!metadata) {\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nmetadata->u.tun_info.mode |= IP_TUNNEL_INFO_TX;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\nif (!exists) {\r\nret = tcf_hash_create(tn, parm->index, est, a,\r\n&act_tunnel_key_ops, bind, true);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\ntcf_hash_release(*a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\nt = to_tunnel_key(*a);\r\nASSERT_RTNL();\r\nparams_new = kzalloc(sizeof(*params_new), GFP_KERNEL);\r\nif (unlikely(!params_new)) {\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_release(*a, bind);\r\nreturn -ENOMEM;\r\n}\r\nparams_old = rtnl_dereference(t->params);\r\nparams_new->action = parm->action;\r\nparams_new->tcft_action = parm->t_action;\r\nparams_new->tcft_enc_metadata = metadata;\r\nrcu_assign_pointer(t->params, params_new);\r\nif (params_old)\r\nkfree_rcu(params_old, rcu);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(tn, *a);\r\nreturn ret;\r\nerr_out:\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn ret;\r\n}\r\nstatic void tunnel_key_release(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_tunnel_key *t = to_tunnel_key(a);\r\nstruct tcf_tunnel_key_params *params;\r\nparams = rcu_dereference_protected(t->params, 1);\r\nif (params->tcft_action == TCA_TUNNEL_KEY_ACT_SET)\r\ndst_release(&params->tcft_enc_metadata->dst);\r\nkfree_rcu(params, rcu);\r\n}\r\nstatic int tunnel_key_dump_addresses(struct sk_buff *skb,\r\nconst struct ip_tunnel_info *info)\r\n{\r\nunsigned short family = ip_tunnel_info_af(info);\r\nif (family == AF_INET) {\r\n__be32 saddr = info->key.u.ipv4.src;\r\n__be32 daddr = info->key.u.ipv4.dst;\r\nif (!nla_put_in_addr(skb, TCA_TUNNEL_KEY_ENC_IPV4_SRC, saddr) &&\r\n!nla_put_in_addr(skb, TCA_TUNNEL_KEY_ENC_IPV4_DST, daddr))\r\nreturn 0;\r\n}\r\nif (family == AF_INET6) {\r\nconst struct in6_addr *saddr6 = &info->key.u.ipv6.src;\r\nconst struct in6_addr *daddr6 = &info->key.u.ipv6.dst;\r\nif (!nla_put_in6_addr(skb,\r\nTCA_TUNNEL_KEY_ENC_IPV6_SRC, saddr6) &&\r\n!nla_put_in6_addr(skb,\r\nTCA_TUNNEL_KEY_ENC_IPV6_DST, daddr6))\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tunnel_key_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_tunnel_key *t = to_tunnel_key(a);\r\nstruct tcf_tunnel_key_params *params;\r\nstruct tc_tunnel_key opt = {\r\n.index = t->tcf_index,\r\n.refcnt = t->tcf_refcnt - ref,\r\n.bindcnt = t->tcf_bindcnt - bind,\r\n};\r\nstruct tcf_t tm;\r\nparams = rtnl_dereference(t->params);\r\nopt.t_action = params->tcft_action;\r\nopt.action = params->action;\r\nif (nla_put(skb, TCA_TUNNEL_KEY_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nif (params->tcft_action == TCA_TUNNEL_KEY_ACT_SET) {\r\nstruct ip_tunnel_key *key =\r\n&params->tcft_enc_metadata->u.tun_info.key;\r\n__be32 key_id = tunnel_id_to_key32(key->tun_id);\r\nif (nla_put_be32(skb, TCA_TUNNEL_KEY_ENC_KEY_ID, key_id) ||\r\ntunnel_key_dump_addresses(skb,\r\n&params->tcft_enc_metadata->u.tun_info) ||\r\nnla_put_be16(skb, TCA_TUNNEL_KEY_ENC_DST_PORT, key->tp_dst))\r\ngoto nla_put_failure;\r\n}\r\ntcf_tm_dump(&tm, &t->tcf_tm);\r\nif (nla_put_64bit(skb, TCA_TUNNEL_KEY_TM, sizeof(tm),\r\n&tm, TCA_TUNNEL_KEY_PAD))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int tunnel_key_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, tunnel_key_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tunnel_key_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, tunnel_key_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int tunnel_key_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, tunnel_key_net_id);\r\nreturn tc_action_net_init(tn, &act_tunnel_key_ops, TUNNEL_KEY_TAB_MASK);\r\n}\r\nstatic void __net_exit tunnel_key_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, tunnel_key_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int __init tunnel_key_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_tunnel_key_ops, &tunnel_key_net_ops);\r\n}\r\nstatic void __exit tunnel_key_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_tunnel_key_ops, &tunnel_key_net_ops);\r\n}
