static struct psr_drv *find_psr_by_crtc(struct drm_crtc *crtc)\r\n{\r\nstruct rockchip_drm_private *drm_drv = crtc->dev->dev_private;\r\nstruct psr_drv *psr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&drm_drv->psr_list_lock, flags);\r\nlist_for_each_entry(psr, &drm_drv->psr_list, list) {\r\nif (psr->encoder->crtc == crtc)\r\ngoto out;\r\n}\r\npsr = ERR_PTR(-ENODEV);\r\nout:\r\nspin_unlock_irqrestore(&drm_drv->psr_list_lock, flags);\r\nreturn psr;\r\n}\r\nstatic void psr_set_state_locked(struct psr_drv *psr, enum psr_state state)\r\n{\r\nif (state == psr->state || !psr->active)\r\nreturn;\r\nif (state == PSR_DISABLE && psr->state == PSR_FLUSH) {\r\npsr->state = state;\r\nreturn;\r\n}\r\npsr->state = state;\r\nswitch (psr->state) {\r\ncase PSR_ENABLE:\r\npsr->set(psr->encoder, true);\r\nbreak;\r\ncase PSR_DISABLE:\r\ncase PSR_FLUSH:\r\npsr->set(psr->encoder, false);\r\nbreak;\r\n}\r\n}\r\nstatic void psr_set_state(struct psr_drv *psr, enum psr_state state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&psr->lock, flags);\r\npsr_set_state_locked(psr, state);\r\nspin_unlock_irqrestore(&psr->lock, flags);\r\n}\r\nstatic void psr_flush_handler(unsigned long data)\r\n{\r\nstruct psr_drv *psr = (struct psr_drv *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&psr->lock, flags);\r\nif (psr->state == PSR_FLUSH)\r\npsr_set_state_locked(psr, PSR_ENABLE);\r\nspin_unlock_irqrestore(&psr->lock, flags);\r\n}\r\nint rockchip_drm_psr_activate(struct drm_crtc *crtc)\r\n{\r\nstruct psr_drv *psr = find_psr_by_crtc(crtc);\r\nunsigned long flags;\r\nif (IS_ERR(psr))\r\nreturn PTR_ERR(psr);\r\nspin_lock_irqsave(&psr->lock, flags);\r\npsr->active = true;\r\nspin_unlock_irqrestore(&psr->lock, flags);\r\nreturn 0;\r\n}\r\nint rockchip_drm_psr_deactivate(struct drm_crtc *crtc)\r\n{\r\nstruct psr_drv *psr = find_psr_by_crtc(crtc);\r\nunsigned long flags;\r\nif (IS_ERR(psr))\r\nreturn PTR_ERR(psr);\r\nspin_lock_irqsave(&psr->lock, flags);\r\npsr->active = false;\r\nspin_unlock_irqrestore(&psr->lock, flags);\r\ndel_timer_sync(&psr->flush_timer);\r\nreturn 0;\r\n}\r\nstatic void rockchip_drm_do_flush(struct psr_drv *psr)\r\n{\r\nmod_timer(&psr->flush_timer,\r\nround_jiffies_up(jiffies + PSR_FLUSH_TIMEOUT));\r\npsr_set_state(psr, PSR_FLUSH);\r\n}\r\nint rockchip_drm_psr_flush(struct drm_crtc *crtc)\r\n{\r\nstruct psr_drv *psr = find_psr_by_crtc(crtc);\r\nif (IS_ERR(psr))\r\nreturn PTR_ERR(psr);\r\nrockchip_drm_do_flush(psr);\r\nreturn 0;\r\n}\r\nvoid rockchip_drm_psr_flush_all(struct drm_device *dev)\r\n{\r\nstruct rockchip_drm_private *drm_drv = dev->dev_private;\r\nstruct psr_drv *psr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&drm_drv->psr_list_lock, flags);\r\nlist_for_each_entry(psr, &drm_drv->psr_list, list)\r\nrockchip_drm_do_flush(psr);\r\nspin_unlock_irqrestore(&drm_drv->psr_list_lock, flags);\r\n}\r\nint rockchip_drm_psr_register(struct drm_encoder *encoder,\r\nvoid (*psr_set)(struct drm_encoder *, bool enable))\r\n{\r\nstruct rockchip_drm_private *drm_drv = encoder->dev->dev_private;\r\nstruct psr_drv *psr;\r\nunsigned long flags;\r\nif (!encoder || !psr_set)\r\nreturn -EINVAL;\r\npsr = kzalloc(sizeof(struct psr_drv), GFP_KERNEL);\r\nif (!psr)\r\nreturn -ENOMEM;\r\nsetup_timer(&psr->flush_timer, psr_flush_handler, (unsigned long)psr);\r\nspin_lock_init(&psr->lock);\r\npsr->active = true;\r\npsr->state = PSR_DISABLE;\r\npsr->encoder = encoder;\r\npsr->set = psr_set;\r\nspin_lock_irqsave(&drm_drv->psr_list_lock, flags);\r\nlist_add_tail(&psr->list, &drm_drv->psr_list);\r\nspin_unlock_irqrestore(&drm_drv->psr_list_lock, flags);\r\nreturn 0;\r\n}\r\nvoid rockchip_drm_psr_unregister(struct drm_encoder *encoder)\r\n{\r\nstruct rockchip_drm_private *drm_drv = encoder->dev->dev_private;\r\nstruct psr_drv *psr, *n;\r\nunsigned long flags;\r\nspin_lock_irqsave(&drm_drv->psr_list_lock, flags);\r\nlist_for_each_entry_safe(psr, n, &drm_drv->psr_list, list) {\r\nif (psr->encoder == encoder) {\r\ndel_timer(&psr->flush_timer);\r\nlist_del(&psr->list);\r\nkfree(psr);\r\n}\r\n}\r\nspin_unlock_irqrestore(&drm_drv->psr_list_lock, flags);\r\n}
