static void leadtek_eeprom(struct cx88_core *core, u8 *eeprom_data)\r\n{\r\nif (eeprom_data[4] != 0x7d ||\r\neeprom_data[5] != 0x10 ||\r\neeprom_data[7] != 0x66) {\r\npr_warn("Leadtek eeprom invalid.\n");\r\nreturn;\r\n}\r\nswitch (eeprom_data[6]) {\r\ncase 0x13:\r\ncase 0x21:\r\ncase 0x31:\r\ncase 0x37:\r\ncase 0x3d:\r\ncore->board.tuner_type = TUNER_PHILIPS_FM1236_MK3;\r\nbreak;\r\ndefault:\r\ncore->board.tuner_type = TUNER_PHILIPS_FM1216ME_MK3;\r\nbreak;\r\n}\r\npr_info("Leadtek Winfast 2000XP Expert config: tuner=%d, eeprom[0]=0x%02x\n",\r\ncore->board.tuner_type, eeprom_data[0]);\r\n}\r\nstatic void hauppauge_eeprom(struct cx88_core *core, u8 *eeprom_data)\r\n{\r\nstruct tveeprom tv;\r\ntveeprom_hauppauge_analog(&core->i2c_client, &tv, eeprom_data);\r\ncore->board.tuner_type = tv.tuner_type;\r\ncore->tuner_formats = tv.tuner_formats;\r\ncore->board.radio.type = tv.has_radio ? CX88_RADIO : 0;\r\ncore->model = tv.model;\r\nswitch (tv.model) {\r\ncase 14009:\r\ncase 14019:\r\ncase 14029:\r\ncase 14109:\r\ncase 14129:\r\ncase 14559:\r\ncase 14569:\r\ncase 14659:\r\ncase 14669:\r\ncase 28552:\r\ncase 34519:\r\ncase 69009:\r\ncase 69100:\r\ncase 69500:\r\ncase 69559:\r\ncase 69569:\r\ncase 90002:\r\ncase 92001:\r\ncase 92002:\r\ncase 90003:\r\ncase 90500:\r\ncase 90501:\r\ncase 92000:\r\ncase 92900:\r\ncase 94009:\r\ncase 94501:\r\ncase 96009:\r\ncase 96019:\r\ncase 96559:\r\ncase 96569:\r\ncase 96659:\r\ncase 98559:\r\nbreak;\r\ncase CX88_BOARD_SAMSUNG_SMT_7020:\r\ncx_set(MO_GP0_IO, 0x008989FF);\r\nbreak;\r\ndefault:\r\npr_warn("warning: unknown hauppauge model #%d\n", tv.model);\r\nbreak;\r\n}\r\npr_info("hauppauge eeprom: model=%d\n", tv.model);\r\n}\r\nstatic void gdi_eeprom(struct cx88_core *core, u8 *eeprom_data)\r\n{\r\nconst char *name = (eeprom_data[0x0d] < ARRAY_SIZE(gdi_tuner))\r\n? gdi_tuner[eeprom_data[0x0d]].name : NULL;\r\npr_info("GDI: tuner=%s\n", name ? name : "unknown");\r\nif (!name)\r\nreturn;\r\ncore->board.tuner_type = gdi_tuner[eeprom_data[0x0d]].id;\r\ncore->board.radio.type = gdi_tuner[eeprom_data[0x0d]].fm ?\r\nCX88_RADIO : 0;\r\n}\r\nstatic int cx88_dvico_xc2028_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\r\ncx_set(MO_GP0_IO, 0x00001000);\r\ncx_clear(MO_GP0_IO, 0x00000010);\r\nmsleep(100);\r\ncx_set(MO_GP0_IO, 0x00000010);\r\nmsleep(100);\r\nbreak;\r\ndefault:\r\ncx_write(MO_GP0_IO, 0x101000);\r\nmdelay(5);\r\ncx_set(MO_GP0_IO, 0x101010);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx88_xc3028_geniatech_tuner_callback(struct cx88_core *core,\r\nint command, int mode)\r\n{\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\nswitch (INPUT(core->input).type) {\r\ncase CX88_RADIO:\r\nbreak;\r\ncase CX88_VMUX_DVB:\r\ncx_write(MO_GP1_IO, 0x030302);\r\nmdelay(50);\r\nbreak;\r\ndefault:\r\ncx_write(MO_GP1_IO, 0x030301);\r\nmdelay(50);\r\n}\r\ncx_write(MO_GP1_IO, 0x101010);\r\nmdelay(50);\r\ncx_write(MO_GP1_IO, 0x101000);\r\nmdelay(50);\r\ncx_write(MO_GP1_IO, 0x101010);\r\nmdelay(50);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx88_xc3028_winfast1800h_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\ncx_set(MO_GP1_IO, 0x1010);\r\nmdelay(50);\r\ncx_clear(MO_GP1_IO, 0x10);\r\nmdelay(75);\r\ncx_set(MO_GP1_IO, 0x10);\r\nmdelay(75);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx88_xc4000_winfast2000h_plus_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (command) {\r\ncase XC4000_TUNER_RESET:\r\ncx_set(MO_GP1_IO, 0x1010);\r\nmdelay(50);\r\ncx_clear(MO_GP1_IO, 0x10);\r\nmdelay(75);\r\ncx_set(MO_GP1_IO, 0x10);\r\nmdelay(75);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx88_pv_8000gt_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\ncx_write(MO_GP2_IO, 0xcf7);\r\nmdelay(50);\r\ncx_write(MO_GP2_IO, 0xef5);\r\nmdelay(50);\r\ncx_write(MO_GP2_IO, 0xcf7);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dvico_fusionhdtv_hybrid_init(struct cx88_core *core)\r\n{\r\nstruct i2c_msg msg = { .addr = 0x45, .flags = 0 };\r\nint i, err;\r\nstatic u8 init_bufs[13][5] = {\r\n{ 0x10, 0x00, 0x20, 0x01, 0x03 },\r\n{ 0x10, 0x10, 0x01, 0x00, 0x21 },\r\n{ 0x10, 0x10, 0x10, 0x00, 0xCA },\r\n{ 0x10, 0x10, 0x12, 0x00, 0x08 },\r\n{ 0x10, 0x10, 0x13, 0x00, 0x0A },\r\n{ 0x10, 0x10, 0x16, 0x01, 0xC0 },\r\n{ 0x10, 0x10, 0x22, 0x01, 0x3D },\r\n{ 0x10, 0x10, 0x73, 0x01, 0x2E },\r\n{ 0x10, 0x10, 0x72, 0x00, 0xC5 },\r\n{ 0x10, 0x10, 0x71, 0x01, 0x97 },\r\n{ 0x10, 0x10, 0x70, 0x00, 0x0F },\r\n{ 0x10, 0x10, 0xB0, 0x00, 0x01 },\r\n{ 0x03, 0x0C },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_bufs); i++) {\r\nmsg.buf = init_bufs[i];\r\nmsg.len = (i != 12 ? 5 : 2);\r\nerr = i2c_transfer(&core->i2c_adap, &msg, 1);\r\nif (err != 1) {\r\npr_warn("dvico_fusionhdtv_hybrid_init buf %d failed (err = %d)!\n",\r\ni, err);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int cx88_xc2028_tuner_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_POWERCOLOR_REAL_ANGEL:\r\ncase CX88_BOARD_GENIATECH_X8000_MT:\r\ncase CX88_BOARD_KWORLD_ATSC_120:\r\nreturn cx88_xc3028_geniatech_tuner_callback(core,\r\ncommand, arg);\r\ncase CX88_BOARD_PROLINK_PV_8000GT:\r\ncase CX88_BOARD_PROLINK_PV_GLOBAL_XTREME:\r\nreturn cx88_pv_8000gt_callback(core, command, arg);\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PRO:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\r\nreturn cx88_dvico_xc2028_callback(core, command, arg);\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\r\ncase CX88_BOARD_WINFAST_DTV1800H:\r\nreturn cx88_xc3028_winfast1800h_callback(core, command, arg);\r\n}\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\nswitch (INPUT(core->input).type) {\r\ncase CX88_RADIO:\r\ndprintk(1, "setting GPIO to radio!\n");\r\ncx_write(MO_GP0_IO, 0x4ff);\r\nmdelay(250);\r\ncx_write(MO_GP2_IO, 0xff);\r\nmdelay(250);\r\nbreak;\r\ncase CX88_VMUX_DVB:\r\ndefault:\r\ndprintk(1, "setting GPIO to TV!\n");\r\nbreak;\r\n}\r\ncx_write(MO_GP1_IO, 0x101010);\r\nmdelay(250);\r\ncx_write(MO_GP1_IO, 0x101000);\r\nmdelay(250);\r\ncx_write(MO_GP1_IO, 0x101010);\r\nmdelay(250);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx88_xc4000_tuner_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_WINFAST_DTV1800H_XC4000:\r\ncase CX88_BOARD_WINFAST_DTV2000H_PLUS:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43:\r\nreturn cx88_xc4000_winfast2000h_plus_callback(core,\r\ncommand, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cx88_xc5000_tuner_callback(struct cx88_core *core,\r\nint command, int arg)\r\n{\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_PINNACLE_PCTV_HD_800i:\r\nif (command == 0) {\r\nreturn 0;\r\n}\r\ndprintk(1, "xc5000: unknown tuner callback command.\n");\r\nreturn -EINVAL;\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD:\r\nif (command == 0) {\r\ncx_clear(MO_GP0_IO, 0x00000010);\r\nusleep_range(10000, 20000);\r\ncx_set(MO_GP0_IO, 0x00000010);\r\nreturn 0;\r\n}\r\ndprintk(1, "xc5000: unknown tuner callback command.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint cx88_tuner_callback(void *priv, int component, int command, int arg)\r\n{\r\nstruct i2c_algo_bit_data *i2c_algo = priv;\r\nstruct cx88_core *core;\r\nif (!i2c_algo) {\r\npr_err("Error - i2c private data undefined.\n");\r\nreturn -EINVAL;\r\n}\r\ncore = i2c_algo->data;\r\nif (!core) {\r\npr_err("Error - device struct undefined.\n");\r\nreturn -EINVAL;\r\n}\r\nif (component != DVB_FRONTEND_COMPONENT_TUNER)\r\nreturn -EINVAL;\r\nswitch (core->board.tuner_type) {\r\ncase TUNER_XC2028:\r\ndprintk(1, "Calling XC2028/3028 callback\n");\r\nreturn cx88_xc2028_tuner_callback(core, command, arg);\r\ncase TUNER_XC4000:\r\ndprintk(1, "Calling XC4000 callback\n");\r\nreturn cx88_xc4000_tuner_callback(core, command, arg);\r\ncase TUNER_XC5000:\r\ndprintk(1, "Calling XC5000 callback\n");\r\nreturn cx88_xc5000_tuner_callback(core, command, arg);\r\n}\r\npr_err("Error: Calling callback for tuner %d\n",\r\ncore->board.tuner_type);\r\nreturn -EINVAL;\r\n}\r\nstatic void cx88_card_list(struct cx88_core *core, struct pci_dev *pci)\r\n{\r\nint i;\r\nif (!pci->subsystem_vendor && !pci->subsystem_device) {\r\npr_err("Your board has no valid PCI Subsystem ID and thus can't\n");\r\npr_err("be autodetected. Please pass card=<n> insmod option to\n");\r\npr_err("workaround that. Redirect complaints to the vendor of\n");\r\npr_err("the TV card\n");\r\n} else {\r\npr_err("Your board isn't known (yet) to the driver. You can\n");\r\npr_err("try to pick one of the existing card configs via\n");\r\npr_err("card=<n> insmod option. Updating to the latest\n");\r\npr_err("version might help as well.\n");\r\n}\r\npr_err("Here is a list of valid choices for the card=<n> insmod option:\n");\r\nfor (i = 0; i < ARRAY_SIZE(cx88_boards); i++)\r\npr_err(" card=%d -> %s\n", i, cx88_boards[i].name);\r\n}\r\nstatic void cx88_card_setup_pre_i2c(struct cx88_core *core)\r\n{\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\ncx_write(MO_GP0_IO, 0x0000ef88);\r\nudelay(1000);\r\ncx_clear(MO_GP0_IO, 0x00000088);\r\nudelay(50);\r\ncx_set(MO_GP0_IO, 0x00000088);\r\nudelay(1000);\r\nbreak;\r\ncase CX88_BOARD_PROLINK_PV_GLOBAL_XTREME:\r\ncase CX88_BOARD_PROLINK_PV_8000GT:\r\ncx_write(MO_GP2_IO, 0xcf7);\r\nmdelay(50);\r\ncx_write(MO_GP2_IO, 0xef5);\r\nmdelay(50);\r\ncx_write(MO_GP2_IO, 0xcf7);\r\nusleep_range(10000, 20000);\r\nbreak;\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD:\r\ncx_set(MO_GP0_IO, 0x00001010);\r\nbreak;\r\ncase CX88_BOARD_WINFAST_DTV2000H_J:\r\ncase CX88_BOARD_HAUPPAUGE_HVR3000:\r\ncase CX88_BOARD_HAUPPAUGE_HVR4000:\r\ncx_write(MO_GP0_IO, core->board.input[0].gpio0);\r\nudelay(1000);\r\ncx_clear(MO_GP0_IO, 0x00000080);\r\nudelay(50);\r\ncx_set(MO_GP0_IO, 0x00000080);\r\nudelay(1000);\r\nbreak;\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\r\ncase CX88_BOARD_WINFAST_DTV1800H:\r\ncx88_xc3028_winfast1800h_callback(core, XC2028_TUNER_RESET, 0);\r\nbreak;\r\ncase CX88_BOARD_WINFAST_DTV1800H_XC4000:\r\ncase CX88_BOARD_WINFAST_DTV2000H_PLUS:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36:\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43:\r\ncx88_xc4000_winfast2000h_plus_callback(core,\r\nXC4000_TUNER_RESET, 0);\r\nbreak;\r\ncase CX88_BOARD_TWINHAN_VP1027_DVBS:\r\ncx_write(MO_GP0_IO, 0x00003230);\r\ncx_write(MO_GP0_IO, 0x00003210);\r\nusleep_range(10000, 20000);\r\ncx_write(MO_GP0_IO, 0x00001230);\r\nbreak;\r\n}\r\n}\r\nvoid cx88_setup_xc3028(struct cx88_core *core, struct xc2028_ctrl *ctl)\r\n{\r\nmemset(ctl, 0, sizeof(*ctl));\r\nctl->fname = XC2028_DEFAULT_FIRMWARE;\r\nctl->max_len = 64;\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_POWERCOLOR_REAL_ANGEL:\r\nif (core->i2c_algo.udelay < 16)\r\ncore->i2c_algo.udelay = 16;\r\nbreak;\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PRO:\r\ncase CX88_BOARD_WINFAST_DTV1800H:\r\nctl->demod = XC3028_FE_ZARLINK456;\r\nbreak;\r\ncase CX88_BOARD_KWORLD_ATSC_120:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:\r\nctl->demod = XC3028_FE_OREN538;\r\nbreak;\r\ncase CX88_BOARD_GENIATECH_X8000_MT:\r\nctl->disable_power_mgmt = 1;\r\nbreak;\r\ncase CX88_BOARD_WINFAST_TV2000_XP_GLOBAL:\r\ncase CX88_BOARD_PROLINK_PV_GLOBAL_XTREME:\r\ncase CX88_BOARD_PROLINK_PV_8000GT:\r\nbreak;\r\ncase CX88_BOARD_PINNACLE_HYBRID_PCTV:\r\ncase CX88_BOARD_TERRATEC_CINERGY_HT_PCI_MKII:\r\nctl->demod = XC3028_FE_ZARLINK456;\r\nctl->mts = 1;\r\nbreak;\r\ndefault:\r\nctl->demod = XC3028_FE_OREN538;\r\nctl->mts = 1;\r\n}\r\n}\r\nstatic void cx88_card_setup(struct cx88_core *core)\r\n{\r\nstatic u8 eeprom[256];\r\nstruct tuner_setup tun_setup;\r\nunsigned int mode_mask = T_RADIO | T_ANALOG_TV;\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\nif (!core->i2c_rc) {\r\ncore->i2c_client.addr = 0xa0 >> 1;\r\ntveeprom_read(&core->i2c_client, eeprom, sizeof(eeprom));\r\n}\r\nswitch (core->boardnr) {\r\ncase CX88_BOARD_HAUPPAUGE:\r\ncase CX88_BOARD_HAUPPAUGE_ROSLYN:\r\nif (!core->i2c_rc)\r\nhauppauge_eeprom(core, eeprom + 8);\r\nbreak;\r\ncase CX88_BOARD_GDI:\r\nif (!core->i2c_rc)\r\ngdi_eeprom(core, eeprom);\r\nbreak;\r\ncase CX88_BOARD_LEADTEK_PVR2000:\r\ncase CX88_BOARD_WINFAST_DV2000:\r\ncase CX88_BOARD_WINFAST2000XP_EXPERT:\r\nif (!core->i2c_rc)\r\nleadtek_eeprom(core, eeprom);\r\nbreak;\r\ncase CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:\r\ncase CX88_BOARD_HAUPPAUGE_NOVASE2_S1:\r\ncase CX88_BOARD_HAUPPAUGE_DVB_T1:\r\ncase CX88_BOARD_HAUPPAUGE_HVR1100:\r\ncase CX88_BOARD_HAUPPAUGE_HVR1100LP:\r\ncase CX88_BOARD_HAUPPAUGE_HVR3000:\r\ncase CX88_BOARD_HAUPPAUGE_HVR1300:\r\ncase CX88_BOARD_HAUPPAUGE_HVR4000:\r\ncase CX88_BOARD_HAUPPAUGE_HVR4000LITE:\r\ncase CX88_BOARD_HAUPPAUGE_IRONLY:\r\nif (!core->i2c_rc)\r\nhauppauge_eeprom(core, eeprom);\r\nbreak;\r\ncase CX88_BOARD_KWORLD_DVBS_100:\r\ncx_write(MO_GP0_IO, 0x000007f8);\r\ncx_write(MO_GP1_IO, 0x00000001);\r\nbreak;\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PRO:\r\ncx_write(MO_GP0_IO, 0x00111100);\r\nusleep_range(10000, 20000);\r\ncx_write(MO_GP0_IO, 0x00111111);\r\nbreak;\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:\r\ncx_set(MO_GP0_IO, 0x00004040);\r\ncx_clear(MO_GP0_IO, 0x00000040);\r\nmsleep(1000);\r\ncx_set(MO_GP0_IO, 0x00004040);\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:\r\ncase CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID:\r\ncx_set(MO_GP0_IO, 0x00000101);\r\ncx_clear(MO_GP0_IO, 0x00000001);\r\nusleep_range(10000, 20000);\r\ncx_set(MO_GP0_IO, 0x00000101);\r\nif (!core->i2c_rc &&\r\ncore->boardnr == CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID)\r\ndvico_fusionhdtv_hybrid_init(core);\r\nbreak;\r\ncase CX88_BOARD_KWORLD_DVB_T:\r\ncase CX88_BOARD_DNTV_LIVE_DVB_T:\r\ncx_set(MO_GP0_IO, 0x00000707);\r\ncx_set(MO_GP2_IO, 0x00000101);\r\ncx_clear(MO_GP2_IO, 0x00000001);\r\nusleep_range(10000, 20000);\r\ncx_clear(MO_GP0_IO, 0x00000007);\r\ncx_set(MO_GP2_IO, 0x00000101);\r\nbreak;\r\ncase CX88_BOARD_DNTV_LIVE_DVB_T_PRO:\r\ncx_write(MO_GP0_IO, 0x00080808);\r\nbreak;\r\ncase CX88_BOARD_ATI_HDTVWONDER:\r\nif (!core->i2c_rc) {\r\nint i;\r\nstatic const u8 buffer[][2] = {\r\n{0x10, 0x12},\r\n{0x13, 0x04},\r\n{0x16, 0x00},\r\n{0x14, 0x04},\r\n{0x17, 0x00}\r\n};\r\ncore->i2c_client.addr = 0x0a;\r\nfor (i = 0; i < ARRAY_SIZE(buffer); i++)\r\nif (i2c_master_send(&core->i2c_client,\r\nbuffer[i], 2) != 2)\r\npr_warn("Unable to enable tuner(%i).\n",\r\ni);\r\n}\r\nbreak;\r\ncase CX88_BOARD_MSI_TVANYWHERE_MASTER:\r\n{\r\nstruct v4l2_priv_tun_config tea5767_cfg;\r\nstruct tea5767_ctrl ctl;\r\nmemset(&ctl, 0, sizeof(ctl));\r\nctl.high_cut = 1;\r\nctl.st_noise = 1;\r\nctl.deemph_75 = 1;\r\nctl.xtal_freq = TEA5767_HIGH_LO_13MHz;\r\ntea5767_cfg.tuner = TUNER_TEA5767;\r\ntea5767_cfg.priv = &ctl;\r\ncall_all(core, tuner, s_config, &tea5767_cfg);\r\nbreak;\r\n}\r\ncase CX88_BOARD_TEVII_S420:\r\ncase CX88_BOARD_TEVII_S460:\r\ncase CX88_BOARD_TEVII_S464:\r\ncase CX88_BOARD_OMICOM_SS4_PCI:\r\ncase CX88_BOARD_TBS_8910:\r\ncase CX88_BOARD_TBS_8920:\r\ncase CX88_BOARD_PROF_6200:\r\ncase CX88_BOARD_PROF_7300:\r\ncase CX88_BOARD_PROF_7301:\r\ncase CX88_BOARD_SATTRADE_ST4200:\r\ncx_write(MO_GP0_IO, 0x8000);\r\nmsleep(100);\r\ncx_write(MO_SRST_IO, 0);\r\nusleep_range(10000, 20000);\r\ncx_write(MO_GP0_IO, 0x8080);\r\nmsleep(100);\r\ncx_write(MO_SRST_IO, 1);\r\nmsleep(100);\r\nbreak;\r\n}\r\nif (core->board.radio_type != UNSET) {\r\ntun_setup.mode_mask = T_RADIO;\r\ntun_setup.type = core->board.radio_type;\r\ntun_setup.addr = core->board.radio_addr;\r\ntun_setup.tuner_callback = cx88_tuner_callback;\r\ncall_all(core, tuner, s_type_addr, &tun_setup);\r\nmode_mask &= ~T_RADIO;\r\n}\r\nif (core->board.tuner_type != UNSET) {\r\ntun_setup.mode_mask = mode_mask;\r\ntun_setup.type = core->board.tuner_type;\r\ntun_setup.addr = core->board.tuner_addr;\r\ntun_setup.tuner_callback = cx88_tuner_callback;\r\ncall_all(core, tuner, s_type_addr, &tun_setup);\r\n}\r\nif (core->board.tda9887_conf) {\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &core->board.tda9887_conf;\r\ncall_all(core, tuner, s_config, &tda9887_cfg);\r\n}\r\nif (core->board.tuner_type == TUNER_XC2028) {\r\nstruct v4l2_priv_tun_config xc2028_cfg;\r\nstruct xc2028_ctrl ctl;\r\ncx88_setup_xc3028(core, &ctl);\r\nmemset(&xc2028_cfg, 0, sizeof(xc2028_cfg));\r\nxc2028_cfg.tuner = TUNER_XC2028;\r\nxc2028_cfg.priv = &ctl;\r\ndprintk(1, "Asking xc2028/3028 to load firmware %s\n",\r\nctl.fname);\r\ncall_all(core, tuner, s_config, &xc2028_cfg);\r\n}\r\ncall_all(core, core, s_power, 0);\r\n}\r\nstatic int cx88_pci_quirks(const char *name, struct pci_dev *pci)\r\n{\r\nunsigned int lat = UNSET;\r\nu8 ctrl = 0;\r\nu8 value;\r\nif (pci_pci_problems & PCIPCI_TRITON) {\r\npr_info("quirk: PCIPCI_TRITON -- set TBFX\n");\r\nctrl |= CX88X_EN_TBFX;\r\n}\r\nif (pci_pci_problems & PCIPCI_NATOMA) {\r\npr_info("quirk: PCIPCI_NATOMA -- set TBFX\n");\r\nctrl |= CX88X_EN_TBFX;\r\n}\r\nif (pci_pci_problems & PCIPCI_VIAETBF) {\r\npr_info("quirk: PCIPCI_VIAETBF -- set TBFX\n");\r\nctrl |= CX88X_EN_TBFX;\r\n}\r\nif (pci_pci_problems & PCIPCI_VSFX) {\r\npr_info("quirk: PCIPCI_VSFX -- set VSFX\n");\r\nctrl |= CX88X_EN_VSFX;\r\n}\r\n#ifdef PCIPCI_ALIMAGIK\r\nif (pci_pci_problems & PCIPCI_ALIMAGIK) {\r\npr_info("quirk: PCIPCI_ALIMAGIK -- latency fixup\n");\r\nlat = 0x0A;\r\n}\r\n#endif\r\nif (latency != UNSET)\r\nlat = latency;\r\nif (ctrl) {\r\npci_read_config_byte(pci, CX88X_DEVCTRL, &value);\r\nvalue |= ctrl;\r\npci_write_config_byte(pci, CX88X_DEVCTRL, value);\r\n}\r\nif (lat != UNSET) {\r\npr_info("setting pci latency timer to %d\n", latency);\r\npci_write_config_byte(pci, PCI_LATENCY_TIMER, latency);\r\n}\r\nreturn 0;\r\n}\r\nint cx88_get_resources(const struct cx88_core *core, struct pci_dev *pci)\r\n{\r\nif (request_mem_region(pci_resource_start(pci, 0),\r\npci_resource_len(pci, 0),\r\ncore->name))\r\nreturn 0;\r\npr_err("func %d: Can't get MMIO memory @ 0x%llx, subsystem: %04x:%04x\n",\r\nPCI_FUNC(pci->devfn),\r\n(unsigned long long)pci_resource_start(pci, 0),\r\npci->subsystem_vendor, pci->subsystem_device);\r\nreturn -EBUSY;\r\n}\r\nstruct cx88_core *cx88_core_create(struct pci_dev *pci, int nr)\r\n{\r\nstruct cx88_core *core;\r\nint i;\r\ncore = kzalloc(sizeof(*core), GFP_KERNEL);\r\nif (!core)\r\nreturn NULL;\r\natomic_inc(&core->refcount);\r\ncore->pci_bus = pci->bus->number;\r\ncore->pci_slot = PCI_SLOT(pci->devfn);\r\ncore->pci_irqmask = PCI_INT_RISC_RD_BERRINT | PCI_INT_RISC_WR_BERRINT |\r\nPCI_INT_BRDG_BERRINT | PCI_INT_SRC_DMA_BERRINT |\r\nPCI_INT_DST_DMA_BERRINT | PCI_INT_IPB_DMA_BERRINT;\r\nmutex_init(&core->lock);\r\ncore->nr = nr;\r\nsprintf(core->name, "cx88[%d]", core->nr);\r\ncore->tvnorm = V4L2_STD_NTSC_M;\r\ncore->width = 320;\r\ncore->height = 240;\r\ncore->field = V4L2_FIELD_INTERLACED;\r\nstrcpy(core->v4l2_dev.name, core->name);\r\nif (v4l2_device_register(NULL, &core->v4l2_dev)) {\r\nkfree(core);\r\nreturn NULL;\r\n}\r\nif (v4l2_ctrl_handler_init(&core->video_hdl, 13)) {\r\nv4l2_device_unregister(&core->v4l2_dev);\r\nkfree(core);\r\nreturn NULL;\r\n}\r\nif (v4l2_ctrl_handler_init(&core->audio_hdl, 13)) {\r\nv4l2_ctrl_handler_free(&core->video_hdl);\r\nv4l2_device_unregister(&core->v4l2_dev);\r\nkfree(core);\r\nreturn NULL;\r\n}\r\nif (cx88_get_resources(core, pci) != 0) {\r\nv4l2_ctrl_handler_free(&core->video_hdl);\r\nv4l2_ctrl_handler_free(&core->audio_hdl);\r\nv4l2_device_unregister(&core->v4l2_dev);\r\nkfree(core);\r\nreturn NULL;\r\n}\r\ncx88_pci_quirks(core->name, pci);\r\ncore->lmmio = ioremap(pci_resource_start(pci, 0),\r\npci_resource_len(pci, 0));\r\ncore->bmmio = (u8 __iomem *)core->lmmio;\r\nif (!core->lmmio) {\r\nrelease_mem_region(pci_resource_start(pci, 0),\r\npci_resource_len(pci, 0));\r\nv4l2_ctrl_handler_free(&core->video_hdl);\r\nv4l2_ctrl_handler_free(&core->audio_hdl);\r\nv4l2_device_unregister(&core->v4l2_dev);\r\nkfree(core);\r\nreturn NULL;\r\n}\r\ncore->boardnr = UNSET;\r\nif (card[core->nr] < ARRAY_SIZE(cx88_boards))\r\ncore->boardnr = card[core->nr];\r\nfor (i = 0; core->boardnr == UNSET && i < ARRAY_SIZE(cx88_subids); i++)\r\nif (pci->subsystem_vendor == cx88_subids[i].subvendor &&\r\npci->subsystem_device == cx88_subids[i].subdevice)\r\ncore->boardnr = cx88_subids[i].card;\r\nif (core->boardnr == UNSET) {\r\ncore->boardnr = CX88_BOARD_UNKNOWN;\r\ncx88_card_list(core, pci);\r\n}\r\ncore->board = cx88_boards[core->boardnr];\r\nif (!core->board.num_frontends && (core->board.mpeg & CX88_MPEG_DVB))\r\ncore->board.num_frontends = 1;\r\npr_info("subsystem: %04x:%04x, board: %s [card=%d,%s], frontend(s): %d\n",\r\npci->subsystem_vendor, pci->subsystem_device, core->board.name,\r\ncore->boardnr, card[core->nr] == core->boardnr ?\r\n"insmod option" : "autodetected",\r\ncore->board.num_frontends);\r\nif (tuner[core->nr] != UNSET)\r\ncore->board.tuner_type = tuner[core->nr];\r\nif (radio[core->nr] != UNSET)\r\ncore->board.radio_type = radio[core->nr];\r\ndprintk(1, "TV tuner type %d, Radio tuner type %d\n",\r\ncore->board.tuner_type, core->board.radio_type);\r\ncx88_reset(core);\r\ncx88_card_setup_pre_i2c(core);\r\ncx88_i2c_init(core, pci);\r\nif (core->board.tuner_type != UNSET) {\r\nstatic const unsigned short tv_addrs[] = {\r\n0x42, 0x43, 0x4a, 0x4b,\r\n0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\r\n0x68, 0x69, 0x6a, 0x6c, 0x6d, 0x6e,\r\nI2C_CLIENT_END\r\n};\r\nint has_demod = (core->board.tda9887_conf & TDA9887_PRESENT);\r\nv4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,\r\n"tuner", 0,\r\nv4l2_i2c_tuner_addrs(ADDRS_RADIO));\r\nif (has_demod)\r\nv4l2_i2c_new_subdev(&core->v4l2_dev,\r\n&core->i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(ADDRS_DEMOD));\r\nif (core->board.tuner_addr == ADDR_UNSET) {\r\nv4l2_i2c_new_subdev(&core->v4l2_dev,\r\n&core->i2c_adap, "tuner",\r\n0, has_demod ? tv_addrs + 4 : tv_addrs);\r\n} else {\r\nv4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,\r\n"tuner", core->board.tuner_addr,\r\nNULL);\r\n}\r\n}\r\ncx88_card_setup(core);\r\nif (!disable_ir) {\r\ncx88_i2c_init_ir(core);\r\ncx88_ir_init(core, pci);\r\n}\r\nreturn core;\r\n}
