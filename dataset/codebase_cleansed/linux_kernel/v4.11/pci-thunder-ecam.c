static void set_val(u32 v, int where, int size, u32 *val)\r\n{\r\nint shift = (where & 3) * 8;\r\npr_debug("set_val %04x: %08x\n", (unsigned)(where & ~3), v);\r\nv >>= shift;\r\nif (size == 1)\r\nv &= 0xff;\r\nelse if (size == 2)\r\nv &= 0xffff;\r\n*val = v;\r\n}\r\nstatic int handle_ea_bar(u32 e0, int bar, struct pci_bus *bus,\r\nunsigned int devfn, int where, int size, u32 *val)\r\n{\r\nvoid __iomem *addr;\r\nu32 v;\r\nint where_a = where & 0xc;\r\nif (where_a == 0) {\r\nset_val(e0, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0x4) {\r\naddr = bus->ops->map_bus(bus, devfn, bar);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nv &= ~0xf;\r\nv |= 2;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0x8) {\r\nu32 barl_orig;\r\nu32 barl_rb;\r\naddr = bus->ops->map_bus(bus, devfn, bar);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nbarl_orig = readl(addr + 0);\r\nwritel(0xffffffff, addr + 0);\r\nbarl_rb = readl(addr + 0);\r\nwritel(barl_orig, addr + 0);\r\nv = ~barl_rb & ~3;\r\nv |= 0xc;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xc) {\r\naddr = bus->ops->map_bus(bus, devfn, bar + 4);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic int thunder_ecam_p2_config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct pci_config_window *cfg = bus->sysdata;\r\nint where_a = where & ~3;\r\nvoid __iomem *addr;\r\nu32 node_bits;\r\nu32 v;\r\nswitch (where_a) {\r\ncase 0xa8:\r\ncase 0xbc:\r\ncase 0xd0:\r\ncase 0xe4:\r\nbreak;\r\ndefault:\r\nreturn pci_generic_config_read(bus, devfn, where, size, val);\r\n}\r\naddr = bus->ops->map_bus(bus, devfn, where_a);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nnode_bits = (cfg->res.start >> 32) & (1 << 12);\r\nv |= node_bits;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int thunder_ecam_config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nu32 v;\r\nu32 vendor_device;\r\nu32 class_rev;\r\nvoid __iomem *addr;\r\nint cfg_type;\r\nint where_a = where & ~3;\r\naddr = bus->ops->map_bus(bus, devfn, 0xc);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\ncfg_type = (v >> 16) & 0x7f;\r\naddr = bus->ops->map_bus(bus, devfn, 8);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nclass_rev = readl(addr);\r\nif (class_rev == 0xffffffff)\r\ngoto no_emulation;\r\nif ((class_rev & 0xff) >= 8) {\r\nif (cfg_type)\r\ngoto no_emulation;\r\nreturn thunder_ecam_p2_config_read(bus, devfn, where,\r\nsize, val);\r\n}\r\nif (cfg_type == 0 &&\r\n((where >= 0x10 && where < 0x2c) ||\r\n(where >= 0x1a4 && where < 0x1bc))) {\r\n*val = 0;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\naddr = bus->ops->map_bus(bus, devfn, 0);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nvendor_device = readl(addr);\r\nif (vendor_device == 0xffffffff)\r\ngoto no_emulation;\r\npr_debug("%04x:%04x - Fix pass#: %08x, where: %03x, devfn: %03x\n",\r\nvendor_device & 0xffff, vendor_device >> 16, class_rev,\r\n(unsigned) where, devfn);\r\nif (cfg_type == 0) {\r\nbool has_msix;\r\nbool is_nic = (vendor_device == 0xa01e177d);\r\nbool is_tns = (vendor_device == 0xa01f177d);\r\naddr = bus->ops->map_bus(bus, devfn, 0x70);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nhas_msix = (v & 0xff00) != 0;\r\nif (!has_msix && where_a == 0x70) {\r\nv |= 0xbc00;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xb0) {\r\naddr = bus->ops->map_bus(bus, devfn, where_a);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nif (v & 0xff00)\r\npr_err("Bad MSIX cap header: %08x\n", v);\r\nv |= 0xbc00;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xbc) {\r\nif (is_nic)\r\nv = 0x40014;\r\nelse if (is_tns)\r\nv = 0x30014;\r\nelse if (has_msix)\r\nv = 0x20014;\r\nelse\r\nv = 0x10014;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a >= 0xc0 && where_a < 0xd0)\r\nreturn handle_ea_bar(0x80ff0003,\r\n0x10, bus, devfn, where,\r\nsize, val);\r\nif (where_a >= 0xd0 && where_a < 0xe0 && has_msix)\r\nreturn handle_ea_bar(0x80ff0043,\r\n0x20, bus, devfn, where,\r\nsize, val);\r\nif (where_a >= 0xe0 && where_a < 0xf0 && is_tns)\r\nreturn handle_ea_bar(0x80ff0023,\r\n0x18, bus, devfn, where,\r\nsize, val);\r\nif (where_a >= 0xe0 && where_a < 0xf0 && is_nic)\r\nreturn handle_ea_bar(0x80ff0493,\r\n0x1a4, bus, devfn, where,\r\nsize, val);\r\nif (where_a >= 0xf0 && where_a < 0x100 && is_nic)\r\nreturn handle_ea_bar(0x80ff04d3,\r\n0x1b4, bus, devfn, where,\r\nsize, val);\r\n} else if (cfg_type == 1) {\r\nbool is_rsl_bridge = devfn == 0x08;\r\nbool is_rad_bridge = devfn == 0xa0;\r\nbool is_zip_bridge = devfn == 0xa8;\r\nbool is_dfa_bridge = devfn == 0xb0;\r\nbool is_nic_bridge = devfn == 0x10;\r\nif (where_a == 0x70) {\r\naddr = bus->ops->map_bus(bus, devfn, where_a);\r\nif (!addr) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nv = readl(addr);\r\nif (v & 0xff00)\r\npr_err("Bad PCIe cap header: %08x\n", v);\r\nv |= 0xbc00;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xbc) {\r\nif (is_nic_bridge)\r\nv = 0x10014;\r\nelse\r\nv = 0x00014;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xc0) {\r\nif (is_rsl_bridge || is_nic_bridge)\r\nv = 0x0101;\r\nelse if (is_rad_bridge)\r\nv = 0x0202;\r\nelse if (is_zip_bridge)\r\nv = 0x0303;\r\nelse if (is_dfa_bridge)\r\nv = 0x0404;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xc4 && is_nic_bridge) {\r\nv = 0x80ff0564;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xc8 && is_nic_bridge) {\r\nv = 0x00000002;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xcc && is_nic_bridge) {\r\nv = 0xfffffffe;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xd0 && is_nic_bridge) {\r\nv = 0x00008430;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nif (where_a == 0xd4 && is_nic_bridge) {\r\nv = 0x0000000f;\r\nset_val(v, where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\n}\r\nno_emulation:\r\nreturn pci_generic_config_read(bus, devfn, where, size, val);\r\n}\r\nstatic int thunder_ecam_config_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nif ((where >= 0x10 && where < 0x2c) ||\r\n(where >= 0x1a4 && where < 0x1bc))\r\nreturn PCIBIOS_SUCCESSFUL;\r\nreturn pci_generic_config_write(bus, devfn, where, size, val);\r\n}\r\nstatic int thunder_ecam_probe(struct platform_device *pdev)\r\n{\r\nreturn pci_host_common_probe(pdev, &pci_thunder_ecam_ops);\r\n}
