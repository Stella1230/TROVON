static int max1027_read_single_value(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val)\r\n{\r\nint ret;\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\nif (iio_buffer_enabled(indio_dev)) {\r\ndev_warn(&indio_dev->dev, "trigger mode already enabled");\r\nreturn -EBUSY;\r\n}\r\nst->reg = MAX1027_SETUP_REG | MAX1027_REF_MODE2 | MAX1027_CKS_MODE2;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev,\r\n"Failed to configure setup register\n");\r\nreturn ret;\r\n}\r\nst->reg = MAX1027_CONV_REG | MAX1027_CHAN(chan->channel) |\r\nMAX1027_NOSCAN;\r\nif (chan->type == IIO_TEMP)\r\nst->reg |= MAX1027_TEMP;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev,\r\n"Failed to configure conversion register\n");\r\nreturn ret;\r\n}\r\nmdelay(1);\r\nret = spi_read(st->spi, st->buffer, (chan->type == IIO_TEMP) ? 4 : 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = be16_to_cpu(st->buffer[0]);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int max1027_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret = 0;\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\nmutex_lock(&st->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = max1027_read_single_value(indio_dev, chan, val);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = 1;\r\n*val2 = 8;\r\nret = IIO_VAL_FRACTIONAL;\r\nbreak;\r\ncase IIO_VOLTAGE:\r\n*val = 2500;\r\n*val2 = 10;\r\nret = IIO_VAL_FRACTIONAL_LOG2;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int max1027_debugfs_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\nu8 *val = (u8 *)st->buffer;\r\nif (readval != NULL)\r\nreturn -EINVAL;\r\n*val = (u8)writeval;\r\nreturn spi_write(st->spi, val, 1);\r\n}\r\nstatic int max1027_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\nif (st->trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int max1027_set_trigger_state(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\nint ret;\r\nif (state) {\r\nst->reg = MAX1027_SETUP_REG | MAX1027_CKS_MODE0 |\r\nMAX1027_REF_MODE2;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nst->reg = MAX1027_CONV_REG | MAX1027_CHAN(0) |\r\nMAX1027_SCAN_N_M | MAX1027_TEMP;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nst->reg = MAX1027_SETUP_REG | MAX1027_CKS_MODE2 |\r\nMAX1027_REF_MODE2;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t max1027_trigger_handler(int irq, void *private)\r\n{\r\nstruct iio_poll_func *pf = (struct iio_poll_func *)private;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct max1027_state *st = iio_priv(indio_dev);\r\npr_debug("%s(irq=%d, private=0x%p)\n", __func__, irq, private);\r\nspi_read(st->spi, st->buffer, indio_dev->masklength * 2);\r\niio_push_to_buffers(indio_dev, st->buffer);\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max1027_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct iio_dev *indio_dev;\r\nstruct max1027_state *st;\r\npr_debug("%s: probe(spi = 0x%p)\n", __func__, spi);\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL) {\r\npr_err("Can't allocate iio device\n");\r\nreturn -ENOMEM;\r\n}\r\nspi_set_drvdata(spi, indio_dev);\r\nst = iio_priv(indio_dev);\r\nst->spi = spi;\r\nst->info = &max1027_chip_info_tbl[spi_get_device_id(spi)->driver_data];\r\nmutex_init(&st->lock);\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->dev.of_node = spi->dev.of_node;\r\nindio_dev->info = &max1027_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->info->channels;\r\nindio_dev->num_channels = st->info->num_channels;\r\nindio_dev->available_scan_masks = st->info->available_scan_masks;\r\nst->buffer = devm_kmalloc(&indio_dev->dev,\r\nindio_dev->num_channels * 2,\r\nGFP_KERNEL);\r\nif (st->buffer == NULL) {\r\ndev_err(&indio_dev->dev, "Can't allocate buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\r\n&max1027_trigger_handler, NULL);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev, "Failed to setup buffer\n");\r\nreturn ret;\r\n}\r\nst->trig = devm_iio_trigger_alloc(&spi->dev, "%s-trigger",\r\nindio_dev->name);\r\nif (st->trig == NULL) {\r\nret = -ENOMEM;\r\ndev_err(&indio_dev->dev, "Failed to allocate iio trigger\n");\r\ngoto fail_trigger_alloc;\r\n}\r\nst->trig->ops = &max1027_trigger_ops;\r\nst->trig->dev.parent = &spi->dev;\r\niio_trigger_set_drvdata(st->trig, indio_dev);\r\niio_trigger_register(st->trig);\r\nret = devm_request_threaded_irq(&spi->dev, spi->irq,\r\niio_trigger_generic_data_rdy_poll,\r\nNULL,\r\nIRQF_TRIGGER_FALLING,\r\nspi->dev.driver->name, st->trig);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev, "Failed to allocate IRQ.\n");\r\ngoto fail_dev_register;\r\n}\r\nst->reg = MAX1027_AVG_REG;\r\nret = spi_write(st->spi, &st->reg, 1);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev, "Failed to configure averaging register\n");\r\ngoto fail_dev_register;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev, "Failed to register iio device\n");\r\ngoto fail_dev_register;\r\n}\r\nreturn 0;\r\nfail_dev_register:\r\nfail_trigger_alloc:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int max1027_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\npr_debug("%s: remove(spi = 0x%p)\n", __func__, spi);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn 0;\r\n}
