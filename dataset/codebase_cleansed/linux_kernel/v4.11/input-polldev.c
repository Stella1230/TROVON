static void input_polldev_queue_work(struct input_polled_dev *dev)\r\n{\r\nunsigned long delay;\r\ndelay = msecs_to_jiffies(dev->poll_interval);\r\nif (delay >= HZ)\r\ndelay = round_jiffies_relative(delay);\r\nqueue_delayed_work(system_freezable_wq, &dev->work, delay);\r\n}\r\nstatic void input_polled_device_work(struct work_struct *work)\r\n{\r\nstruct input_polled_dev *dev =\r\ncontainer_of(work, struct input_polled_dev, work.work);\r\ndev->poll(dev);\r\ninput_polldev_queue_work(dev);\r\n}\r\nstatic int input_open_polled_device(struct input_dev *input)\r\n{\r\nstruct input_polled_dev *dev = input_get_drvdata(input);\r\nif (dev->open)\r\ndev->open(dev);\r\nif (dev->poll_interval > 0) {\r\ndev->poll(dev);\r\ninput_polldev_queue_work(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void input_close_polled_device(struct input_dev *input)\r\n{\r\nstruct input_polled_dev *dev = input_get_drvdata(input);\r\ncancel_delayed_work_sync(&dev->work);\r\nif (dev->close)\r\ndev->close(dev);\r\n}\r\nstatic ssize_t input_polldev_get_poll(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct input_polled_dev *polldev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", polldev->poll_interval);\r\n}\r\nstatic ssize_t input_polldev_set_poll(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct input_polled_dev *polldev = dev_get_drvdata(dev);\r\nstruct input_dev *input = polldev->input;\r\nunsigned int interval;\r\nint err;\r\nerr = kstrtouint(buf, 0, &interval);\r\nif (err)\r\nreturn err;\r\nif (interval < polldev->poll_interval_min)\r\nreturn -EINVAL;\r\nif (interval > polldev->poll_interval_max)\r\nreturn -EINVAL;\r\nmutex_lock(&input->mutex);\r\npolldev->poll_interval = interval;\r\nif (input->users) {\r\ncancel_delayed_work_sync(&polldev->work);\r\nif (polldev->poll_interval > 0)\r\ninput_polldev_queue_work(polldev);\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t input_polldev_get_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct input_polled_dev *polldev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", polldev->poll_interval_max);\r\n}\r\nstatic ssize_t input_polldev_get_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct input_polled_dev *polldev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", polldev->poll_interval_min);\r\n}\r\nstruct input_polled_dev *input_allocate_polled_device(void)\r\n{\r\nstruct input_polled_dev *dev;\r\ndev = kzalloc(sizeof(struct input_polled_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\ndev->input = input_allocate_device();\r\nif (!dev->input) {\r\nkfree(dev);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nstatic int devm_input_polldev_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct input_polled_devres *devres = res;\r\nreturn devres->polldev == data;\r\n}\r\nstatic void devm_input_polldev_release(struct device *dev, void *res)\r\n{\r\nstruct input_polled_devres *devres = res;\r\nstruct input_polled_dev *polldev = devres->polldev;\r\ndev_dbg(dev, "%s: dropping reference/freeing %s\n",\r\n__func__, dev_name(&polldev->input->dev));\r\ninput_put_device(polldev->input);\r\nkfree(polldev);\r\n}\r\nstatic void devm_input_polldev_unregister(struct device *dev, void *res)\r\n{\r\nstruct input_polled_devres *devres = res;\r\nstruct input_polled_dev *polldev = devres->polldev;\r\ndev_dbg(dev, "%s: unregistering device %s\n",\r\n__func__, dev_name(&polldev->input->dev));\r\ninput_unregister_device(polldev->input);\r\n}\r\nstruct input_polled_dev *devm_input_allocate_polled_device(struct device *dev)\r\n{\r\nstruct input_polled_dev *polldev;\r\nstruct input_polled_devres *devres;\r\ndevres = devres_alloc(devm_input_polldev_release, sizeof(*devres),\r\nGFP_KERNEL);\r\nif (!devres)\r\nreturn NULL;\r\npolldev = input_allocate_polled_device();\r\nif (!polldev) {\r\ndevres_free(devres);\r\nreturn NULL;\r\n}\r\npolldev->input->dev.parent = dev;\r\npolldev->devres_managed = true;\r\ndevres->polldev = polldev;\r\ndevres_add(dev, devres);\r\nreturn polldev;\r\n}\r\nvoid input_free_polled_device(struct input_polled_dev *dev)\r\n{\r\nif (dev) {\r\nif (dev->devres_managed)\r\nWARN_ON(devres_destroy(dev->input->dev.parent,\r\ndevm_input_polldev_release,\r\ndevm_input_polldev_match,\r\ndev));\r\ninput_put_device(dev->input);\r\nkfree(dev);\r\n}\r\n}\r\nint input_register_polled_device(struct input_polled_dev *dev)\r\n{\r\nstruct input_polled_devres *devres = NULL;\r\nstruct input_dev *input = dev->input;\r\nint error;\r\nif (dev->devres_managed) {\r\ndevres = devres_alloc(devm_input_polldev_unregister,\r\nsizeof(*devres), GFP_KERNEL);\r\nif (!devres)\r\nreturn -ENOMEM;\r\ndevres->polldev = dev;\r\n}\r\ninput_set_drvdata(input, dev);\r\nINIT_DELAYED_WORK(&dev->work, input_polled_device_work);\r\nif (!dev->poll_interval)\r\ndev->poll_interval = 500;\r\nif (!dev->poll_interval_max)\r\ndev->poll_interval_max = dev->poll_interval;\r\ninput->open = input_open_polled_device;\r\ninput->close = input_close_polled_device;\r\ninput->dev.groups = input_polldev_attribute_groups;\r\nerror = input_register_device(input);\r\nif (error) {\r\ndevres_free(devres);\r\nreturn error;\r\n}\r\ninput_get_device(input);\r\nif (dev->devres_managed) {\r\ndev_dbg(input->dev.parent, "%s: registering %s with devres.\n",\r\n__func__, dev_name(&input->dev));\r\ndevres_add(input->dev.parent, devres);\r\n}\r\nreturn 0;\r\n}\r\nvoid input_unregister_polled_device(struct input_polled_dev *dev)\r\n{\r\nif (dev->devres_managed)\r\nWARN_ON(devres_destroy(dev->input->dev.parent,\r\ndevm_input_polldev_unregister,\r\ndevm_input_polldev_match,\r\ndev));\r\ninput_unregister_device(dev->input);\r\n}
