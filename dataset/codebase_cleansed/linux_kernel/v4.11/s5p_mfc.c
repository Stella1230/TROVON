void clear_work_bit(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nspin_lock(&dev->condlock);\r\n__clear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock(&dev->condlock);\r\n}\r\nvoid set_work_bit(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nspin_lock(&dev->condlock);\r\n__set_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock(&dev->condlock);\r\n}\r\nvoid clear_work_bit_irqsave(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\n__clear_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\n}\r\nvoid set_work_bit_irqsave(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\n__set_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\n}\r\nint s5p_mfc_get_new_ctx(struct s5p_mfc_dev *dev)\r\n{\r\nunsigned long flags;\r\nint ctx;\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nctx = dev->curr_ctx;\r\ndo {\r\nctx = (ctx + 1) % MFC_NUM_CONTEXTS;\r\nif (ctx == dev->curr_ctx) {\r\nif (!test_bit(ctx, &dev->ctx_work_bits))\r\nctx = -EAGAIN;\r\nbreak;\r\n}\r\n} while (!test_bit(ctx, &dev->ctx_work_bits));\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\nreturn ctx;\r\n}\r\nstatic void wake_up_ctx(struct s5p_mfc_ctx *ctx, unsigned int reason,\r\nunsigned int err)\r\n{\r\nctx->int_cond = 1;\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nwake_up(&ctx->queue);\r\n}\r\nstatic void wake_up_dev(struct s5p_mfc_dev *dev, unsigned int reason,\r\nunsigned int err)\r\n{\r\ndev->int_cond = 1;\r\ndev->int_type = reason;\r\ndev->int_err = err;\r\nwake_up(&dev->queue);\r\n}\r\nvoid s5p_mfc_cleanup_queue(struct list_head *lh, struct vb2_queue *vq)\r\n{\r\nstruct s5p_mfc_buf *b;\r\nint i;\r\nwhile (!list_empty(lh)) {\r\nb = list_entry(lh->next, struct s5p_mfc_buf, list);\r\nfor (i = 0; i < b->b->vb2_buf.num_planes; i++)\r\nvb2_set_plane_payload(&b->b->vb2_buf, i, 0);\r\nvb2_buffer_done(&b->b->vb2_buf, VB2_BUF_STATE_ERROR);\r\nlist_del(&b->list);\r\n}\r\n}\r\nstatic void s5p_mfc_watchdog(unsigned long arg)\r\n{\r\nstruct s5p_mfc_dev *dev = (struct s5p_mfc_dev *)arg;\r\nif (test_bit(0, &dev->hw_lock))\r\natomic_inc(&dev->watchdog_cnt);\r\nif (atomic_read(&dev->watchdog_cnt) >= MFC_WATCHDOG_CNT) {\r\nmfc_err("Time out during waiting for HW\n");\r\nschedule_work(&dev->watchdog_work);\r\n}\r\ndev->watchdog_timer.expires = jiffies +\r\nmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\r\nadd_timer(&dev->watchdog_timer);\r\n}\r\nstatic void s5p_mfc_watchdog_worker(struct work_struct *work)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nstruct s5p_mfc_ctx *ctx;\r\nunsigned long flags;\r\nint mutex_locked;\r\nint i, ret;\r\ndev = container_of(work, struct s5p_mfc_dev, watchdog_work);\r\nmfc_err("Driver timeout error handling\n");\r\nmutex_locked = mutex_trylock(&dev->mfc_mutex);\r\nif (!mutex_locked)\r\nmfc_err("Error: some instance may be closing/opening\n");\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\ns5p_mfc_clock_off();\r\nfor (i = 0; i < MFC_NUM_CONTEXTS; i++) {\r\nctx = dev->ctx[i];\r\nif (!ctx)\r\ncontinue;\r\nctx->state = MFCINST_ERROR;\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nclear_work_bit(ctx);\r\nwake_up_ctx(ctx, S5P_MFC_R2H_CMD_ERR_RET, 0);\r\n}\r\nclear_bit(0, &dev->hw_lock);\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\ns5p_mfc_deinit_hw(dev);\r\nif (dev->num_inst > 0) {\r\nret = s5p_mfc_load_firmware(dev);\r\nif (ret) {\r\nmfc_err("Failed to reload FW\n");\r\ngoto unlock;\r\n}\r\ns5p_mfc_clock_on();\r\nret = s5p_mfc_init_hw(dev);\r\nif (ret)\r\nmfc_err("Failed to reinit FW\n");\r\n}\r\nunlock:\r\nif (mutex_locked)\r\nmutex_unlock(&dev->mfc_mutex);\r\n}\r\nstatic void s5p_mfc_handle_frame_all_extracted(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_buf *dst_buf;\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nctx->state = MFCINST_FINISHED;\r\nctx->sequence++;\r\nwhile (!list_empty(&ctx->dst_queue)) {\r\ndst_buf = list_entry(ctx->dst_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nmfc_debug(2, "Cleaning up buffer: %d\n",\r\ndst_buf->b->vb2_buf.index);\r\nvb2_set_plane_payload(&dst_buf->b->vb2_buf, 0, 0);\r\nvb2_set_plane_payload(&dst_buf->b->vb2_buf, 1, 0);\r\nlist_del(&dst_buf->list);\r\ndst_buf->flags |= MFC_BUF_FLAG_EOS;\r\nctx->dst_queue_cnt--;\r\ndst_buf->b->sequence = (ctx->sequence++);\r\nif (s5p_mfc_hw_call(dev->mfc_ops, get_pic_type_top, ctx) ==\r\ns5p_mfc_hw_call(dev->mfc_ops, get_pic_type_bot, ctx))\r\ndst_buf->b->field = V4L2_FIELD_NONE;\r\nelse\r\ndst_buf->b->field = V4L2_FIELD_INTERLACED;\r\ndst_buf->b->flags |= V4L2_BUF_FLAG_LAST;\r\nctx->dec_dst_flag &= ~(1 << dst_buf->b->vb2_buf.index);\r\nvb2_buffer_done(&dst_buf->b->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame_copy_time(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_buf, *src_buf;\r\nsize_t dec_y_addr;\r\nunsigned int frame_type;\r\nframe_type = s5p_mfc_hw_call(dev->mfc_ops, get_dec_frame_type, dev);\r\nif (frame_type == S5P_FIMV_DECODE_FRAME_SKIPPED)\r\nreturn;\r\ndec_y_addr = s5p_mfc_hw_call(dev->mfc_ops, get_dec_y_adr, dev);\r\nsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf, list);\r\nlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\r\nif (vb2_dma_contig_plane_dma_addr(&dst_buf->b->vb2_buf, 0)\r\n== dec_y_addr) {\r\ndst_buf->b->timecode =\r\nsrc_buf->b->timecode;\r\ndst_buf->b->vb2_buf.timestamp =\r\nsrc_buf->b->vb2_buf.timestamp;\r\ndst_buf->b->flags &=\r\n~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_buf->b->flags |=\r\nsrc_buf->b->flags\r\n& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nswitch (frame_type) {\r\ncase S5P_FIMV_DECODE_FRAME_I_FRAME:\r\ndst_buf->b->flags |=\r\nV4L2_BUF_FLAG_KEYFRAME;\r\nbreak;\r\ncase S5P_FIMV_DECODE_FRAME_P_FRAME:\r\ndst_buf->b->flags |=\r\nV4L2_BUF_FLAG_PFRAME;\r\nbreak;\r\ncase S5P_FIMV_DECODE_FRAME_B_FRAME:\r\ndst_buf->b->flags |=\r\nV4L2_BUF_FLAG_BFRAME;\r\nbreak;\r\ndefault:\r\nmfc_debug(2, "Unexpected frame type: %d\n",\r\nframe_type);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame_new(struct s5p_mfc_ctx *ctx, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *dst_buf;\r\nsize_t dspl_y_addr;\r\nunsigned int frame_type;\r\ndspl_y_addr = s5p_mfc_hw_call(dev->mfc_ops, get_dspl_y_adr, dev);\r\nif (IS_MFCV6_PLUS(dev))\r\nframe_type = s5p_mfc_hw_call(dev->mfc_ops,\r\nget_disp_frame_type, ctx);\r\nelse\r\nframe_type = s5p_mfc_hw_call(dev->mfc_ops,\r\nget_dec_frame_type, dev);\r\nif (frame_type == S5P_FIMV_DECODE_FRAME_SKIPPED) {\r\nif (!ctx->after_packed_pb)\r\nctx->sequence++;\r\nctx->after_packed_pb = 0;\r\nreturn;\r\n}\r\nctx->sequence++;\r\nlist_for_each_entry(dst_buf, &ctx->dst_queue, list) {\r\nif (vb2_dma_contig_plane_dma_addr(&dst_buf->b->vb2_buf, 0)\r\n== dspl_y_addr) {\r\nlist_del(&dst_buf->list);\r\nctx->dst_queue_cnt--;\r\ndst_buf->b->sequence = ctx->sequence;\r\nif (s5p_mfc_hw_call(dev->mfc_ops,\r\nget_pic_type_top, ctx) ==\r\ns5p_mfc_hw_call(dev->mfc_ops,\r\nget_pic_type_bot, ctx))\r\ndst_buf->b->field = V4L2_FIELD_NONE;\r\nelse\r\ndst_buf->b->field =\r\nV4L2_FIELD_INTERLACED;\r\nvb2_set_plane_payload(&dst_buf->b->vb2_buf, 0,\r\nctx->luma_size);\r\nvb2_set_plane_payload(&dst_buf->b->vb2_buf, 1,\r\nctx->chroma_size);\r\nclear_bit(dst_buf->b->vb2_buf.index,\r\n&ctx->dec_dst_flag);\r\nvb2_buffer_done(&dst_buf->b->vb2_buf, err ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void s5p_mfc_handle_frame(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned int dst_frame_status;\r\nunsigned int dec_frame_status;\r\nstruct s5p_mfc_buf *src_buf;\r\nunsigned int res_change;\r\ndst_frame_status = s5p_mfc_hw_call(dev->mfc_ops, get_dspl_status, dev)\r\n& S5P_FIMV_DEC_STATUS_DECODING_STATUS_MASK;\r\ndec_frame_status = s5p_mfc_hw_call(dev->mfc_ops, get_dec_status, dev)\r\n& S5P_FIMV_DEC_STATUS_DECODING_STATUS_MASK;\r\nres_change = (s5p_mfc_hw_call(dev->mfc_ops, get_dspl_status, dev)\r\n& S5P_FIMV_DEC_STATUS_RESOLUTION_MASK)\r\n>> S5P_FIMV_DEC_STATUS_RESOLUTION_SHIFT;\r\nmfc_debug(2, "Frame Status: %x\n", dst_frame_status);\r\nif (ctx->state == MFCINST_RES_CHANGE_INIT)\r\nctx->state = MFCINST_RES_CHANGE_FLUSH;\r\nif (res_change == S5P_FIMV_RES_INCREASE ||\r\nres_change == S5P_FIMV_RES_DECREASE) {\r\nctx->state = MFCINST_RES_CHANGE_INIT;\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nwake_up_ctx(ctx, reason, err);\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nreturn;\r\n}\r\nif (ctx->dpb_flush_flag)\r\nctx->dpb_flush_flag = 0;\r\nif (dst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_EMPTY) {\r\nif (ctx->state == MFCINST_RES_CHANGE_FLUSH) {\r\nstatic const struct v4l2_event ev_src_ch = {\r\n.type = V4L2_EVENT_SOURCE_CHANGE,\r\n.u.src_change.changes =\r\nV4L2_EVENT_SRC_CH_RESOLUTION,\r\n};\r\ns5p_mfc_handle_frame_all_extracted(ctx);\r\nctx->state = MFCINST_RES_CHANGE_END;\r\nv4l2_event_queue_fh(&ctx->fh, &ev_src_ch);\r\ngoto leave_handle_frame;\r\n} else {\r\ns5p_mfc_handle_frame_all_extracted(ctx);\r\n}\r\n}\r\nif (dec_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY)\r\ns5p_mfc_handle_frame_copy_time(ctx);\r\nif (dst_frame_status == S5P_FIMV_DEC_STATUS_DISPLAY_ONLY ||\r\ndst_frame_status == S5P_FIMV_DEC_STATUS_DECODING_DISPLAY) {\r\ns5p_mfc_handle_frame_new(ctx, err);\r\n} else {\r\nmfc_debug(2, "No frame decode\n");\r\n}\r\nif (dst_frame_status != S5P_FIMV_DEC_STATUS_DISPLAY_ONLY\r\n&& !list_empty(&ctx->src_queue)) {\r\nsrc_buf = list_entry(ctx->src_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nctx->consumed_stream += s5p_mfc_hw_call(dev->mfc_ops,\r\nget_consumed_stream, dev);\r\nif (ctx->codec_mode != S5P_MFC_CODEC_H264_DEC &&\r\nctx->codec_mode != S5P_MFC_CODEC_VP8_DEC &&\r\nctx->consumed_stream + STUFF_BYTE <\r\nsrc_buf->b->vb2_buf.planes[0].bytesused) {\r\nmfc_debug(2, "Running again the same buffer\n");\r\nctx->after_packed_pb = 1;\r\n} else {\r\nmfc_debug(2, "MFC needs next buffer\n");\r\nctx->consumed_stream = 0;\r\nif (src_buf->flags & MFC_BUF_FLAG_EOS)\r\nctx->state = MFCINST_FINISHING;\r\nlist_del(&src_buf->list);\r\nctx->src_queue_cnt--;\r\nif (s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) > 0)\r\nvb2_buffer_done(&src_buf->b->vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\nelse\r\nvb2_buffer_done(&src_buf->b->vb2_buf,\r\nVB2_BUF_STATE_DONE);\r\n}\r\n}\r\nleave_handle_frame:\r\nif ((ctx->src_queue_cnt == 0 && ctx->state != MFCINST_FINISHING)\r\n|| ctx->dst_queue_cnt < ctx->pb_count)\r\nclear_work_bit(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nwake_up_ctx(ctx, reason, err);\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\nif (test_bit(0, &dev->enter_suspend))\r\nwake_up_dev(dev, reason, err);\r\nelse\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n}\r\nstatic void s5p_mfc_handle_error(struct s5p_mfc_dev *dev,\r\nstruct s5p_mfc_ctx *ctx, unsigned int reason, unsigned int err)\r\n{\r\nmfc_err("Interrupt Error: %08x\n", err);\r\nif (ctx != NULL) {\r\nswitch (ctx->state) {\r\ncase MFCINST_RES_CHANGE_INIT:\r\ncase MFCINST_RES_CHANGE_FLUSH:\r\ncase MFCINST_RES_CHANGE_END:\r\ncase MFCINST_FINISHING:\r\ncase MFCINST_FINISHED:\r\ncase MFCINST_RUNNING:\r\nclear_work_bit(ctx);\r\nctx->state = MFCINST_ERROR;\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nwake_up_ctx(ctx, reason, err);\r\nbreak;\r\ndefault:\r\nclear_work_bit(ctx);\r\nctx->state = MFCINST_ERROR;\r\nwake_up_ctx(ctx, reason, err);\r\nbreak;\r\n}\r\n}\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\ns5p_mfc_clock_off();\r\nwake_up_dev(dev, reason, err);\r\n}\r\nstatic void s5p_mfc_handle_seq_done(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nif (ctx == NULL)\r\nreturn;\r\ndev = ctx->dev;\r\nif (ctx->c_ops->post_seq_start) {\r\nif (ctx->c_ops->post_seq_start(ctx))\r\nmfc_err("post_seq_start() failed\n");\r\n} else {\r\nctx->img_width = s5p_mfc_hw_call(dev->mfc_ops, get_img_width,\r\ndev);\r\nctx->img_height = s5p_mfc_hw_call(dev->mfc_ops, get_img_height,\r\ndev);\r\ns5p_mfc_hw_call(dev->mfc_ops, dec_calc_dpb_size, ctx);\r\nctx->pb_count = s5p_mfc_hw_call(dev->mfc_ops, get_dpb_count,\r\ndev);\r\nctx->mv_count = s5p_mfc_hw_call(dev->mfc_ops, get_mv_count,\r\ndev);\r\nif (ctx->img_width == 0 || ctx->img_height == 0)\r\nctx->state = MFCINST_ERROR;\r\nelse\r\nctx->state = MFCINST_HEAD_PARSED;\r\nif ((ctx->codec_mode == S5P_MFC_CODEC_H264_DEC ||\r\nctx->codec_mode == S5P_MFC_CODEC_H264_MVC_DEC) &&\r\n!list_empty(&ctx->src_queue)) {\r\nstruct s5p_mfc_buf *src_buf;\r\nsrc_buf = list_entry(ctx->src_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nif (s5p_mfc_hw_call(dev->mfc_ops, get_consumed_stream,\r\ndev) <\r\nsrc_buf->b->vb2_buf.planes[0].bytesused)\r\nctx->head_processed = 0;\r\nelse\r\nctx->head_processed = 1;\r\n} else {\r\nctx->head_processed = 1;\r\n}\r\n}\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nclear_work_bit(ctx);\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nwake_up_ctx(ctx, reason, err);\r\n}\r\nstatic void s5p_mfc_handle_init_buffers(struct s5p_mfc_ctx *ctx,\r\nunsigned int reason, unsigned int err)\r\n{\r\nstruct s5p_mfc_buf *src_buf;\r\nstruct s5p_mfc_dev *dev;\r\nif (ctx == NULL)\r\nreturn;\r\ndev = ctx->dev;\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nctx->int_cond = 1;\r\nclear_work_bit(ctx);\r\nif (err == 0) {\r\nctx->state = MFCINST_RUNNING;\r\nif (!ctx->dpb_flush_flag && ctx->head_processed) {\r\nif (!list_empty(&ctx->src_queue)) {\r\nsrc_buf = list_entry(ctx->src_queue.next,\r\nstruct s5p_mfc_buf, list);\r\nlist_del(&src_buf->list);\r\nctx->src_queue_cnt--;\r\nvb2_buffer_done(&src_buf->b->vb2_buf,\r\nVB2_BUF_STATE_DONE);\r\n}\r\n} else {\r\nctx->dpb_flush_flag = 0;\r\n}\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\nwake_up(&ctx->queue);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n} else {\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\nwake_up(&ctx->queue);\r\n}\r\n}\r\nstatic void s5p_mfc_handle_stream_complete(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct s5p_mfc_buf *mb_entry;\r\nmfc_debug(2, "Stream completed\n");\r\nctx->state = MFCINST_FINISHED;\r\nif (!list_empty(&ctx->dst_queue)) {\r\nmb_entry = list_entry(ctx->dst_queue.next, struct s5p_mfc_buf,\r\nlist);\r\nlist_del(&mb_entry->list);\r\nctx->dst_queue_cnt--;\r\nvb2_set_plane_payload(&mb_entry->b->vb2_buf, 0, 0);\r\nvb2_buffer_done(&mb_entry->b->vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nclear_work_bit(ctx);\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\nwake_up(&ctx->queue);\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n}\r\nstatic irqreturn_t s5p_mfc_irq(int irq, void *priv)\r\n{\r\nstruct s5p_mfc_dev *dev = priv;\r\nstruct s5p_mfc_ctx *ctx;\r\nunsigned int reason;\r\nunsigned int err;\r\nmfc_debug_enter();\r\natomic_set(&dev->watchdog_cnt, 0);\r\nspin_lock(&dev->irqlock);\r\nctx = dev->ctx[dev->curr_ctx];\r\nreason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\r\nerr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\r\nmfc_debug(1, "Int reason: %d (err: %08x)\n", reason, err);\r\nswitch (reason) {\r\ncase S5P_MFC_R2H_CMD_ERR_RET:\r\nif (ctx->state == MFCINST_RUNNING &&\r\n(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\r\ndev->warn_start ||\r\nerr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\r\nerr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\r\nerr == S5P_FIMV_ERR_TIMEOUT))\r\ns5p_mfc_handle_frame(ctx, reason, err);\r\nelse\r\ns5p_mfc_handle_error(dev, ctx, reason, err);\r\nclear_bit(0, &dev->enter_suspend);\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\r\ncase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\r\ncase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\r\nif (ctx->c_ops->post_frame_start) {\r\nif (ctx->c_ops->post_frame_start(ctx))\r\nmfc_err("post_frame_start() failed\n");\r\nif (ctx->state == MFCINST_FINISHING &&\r\nlist_empty(&ctx->ref_queue)) {\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\ns5p_mfc_handle_stream_complete(ctx);\r\nbreak;\r\n}\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nwake_up_ctx(ctx, reason, err);\r\nWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\r\ns5p_mfc_clock_off();\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\n} else {\r\ns5p_mfc_handle_frame(ctx, reason, err);\r\n}\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\r\ns5p_mfc_handle_seq_done(ctx, reason, err);\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\r\nctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\r\nctx->state = MFCINST_GOT_INST;\r\nclear_work_bit(ctx);\r\nwake_up(&ctx->queue);\r\ngoto irq_cleanup_hw;\r\ncase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\r\nclear_work_bit(ctx);\r\nctx->inst_no = MFC_NO_INSTANCE_SET;\r\nctx->state = MFCINST_FREE;\r\nwake_up(&ctx->queue);\r\ngoto irq_cleanup_hw;\r\ncase S5P_MFC_R2H_CMD_SYS_INIT_RET:\r\ncase S5P_MFC_R2H_CMD_FW_STATUS_RET:\r\ncase S5P_MFC_R2H_CMD_SLEEP_RET:\r\ncase S5P_MFC_R2H_CMD_WAKEUP_RET:\r\nif (ctx)\r\nclear_work_bit(ctx);\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nwake_up_dev(dev, reason, err);\r\nclear_bit(0, &dev->hw_lock);\r\nclear_bit(0, &dev->enter_suspend);\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\r\ns5p_mfc_handle_init_buffers(ctx, reason, err);\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\ns5p_mfc_handle_stream_complete(ctx);\r\nbreak;\r\ncase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\r\nclear_work_bit(ctx);\r\nctx->state = MFCINST_RUNNING;\r\nwake_up(&ctx->queue);\r\ngoto irq_cleanup_hw;\r\ndefault:\r\nmfc_debug(2, "Unknown int reason\n");\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\n}\r\nspin_unlock(&dev->irqlock);\r\nmfc_debug_leave();\r\nreturn IRQ_HANDLED;\r\nirq_cleanup_hw:\r\ns5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\r\nctx->int_type = reason;\r\nctx->int_err = err;\r\nctx->int_cond = 1;\r\nif (test_and_clear_bit(0, &dev->hw_lock) == 0)\r\nmfc_err("Failed to unlock hw\n");\r\ns5p_mfc_clock_off();\r\ns5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\r\nspin_unlock(&dev->irqlock);\r\nmfc_debug(2, "Exit via irq_cleanup_hw\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5p_mfc_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = NULL;\r\nstruct vb2_queue *q;\r\nint ret = 0;\r\nmfc_debug_enter();\r\nif (mutex_lock_interruptible(&dev->mfc_mutex))\r\nreturn -ERESTARTSYS;\r\ndev->num_inst++;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nv4l2_fh_init(&ctx->fh, vdev);\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->dev = dev;\r\nINIT_LIST_HEAD(&ctx->src_queue);\r\nINIT_LIST_HEAD(&ctx->dst_queue);\r\nctx->src_queue_cnt = 0;\r\nctx->dst_queue_cnt = 0;\r\nctx->num = 0;\r\nwhile (dev->ctx[ctx->num]) {\r\nctx->num++;\r\nif (ctx->num >= MFC_NUM_CONTEXTS) {\r\nmfc_debug(2, "Too many open contexts\n");\r\nret = -EBUSY;\r\ngoto err_no_ctx;\r\n}\r\n}\r\nclear_work_bit_irqsave(ctx);\r\ndev->ctx[ctx->num] = ctx;\r\nif (vdev == dev->vfd_dec) {\r\nctx->type = MFCINST_DECODER;\r\nctx->c_ops = get_dec_codec_ops();\r\ns5p_mfc_dec_init(ctx);\r\nret = s5p_mfc_dec_ctrls_setup(ctx);\r\nif (ret) {\r\nmfc_err("Failed to setup mfc controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\n} else if (vdev == dev->vfd_enc) {\r\nctx->type = MFCINST_ENCODER;\r\nctx->c_ops = get_enc_codec_ops();\r\nINIT_LIST_HEAD(&ctx->ref_queue);\r\nctx->ref_queue_cnt = 0;\r\ns5p_mfc_enc_init(ctx);\r\nret = s5p_mfc_enc_ctrls_setup(ctx);\r\nif (ret) {\r\nmfc_err("Failed to setup mfc controls\n");\r\ngoto err_ctrls_setup;\r\n}\r\n} else {\r\nret = -ENOENT;\r\ngoto err_bad_node;\r\n}\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nctx->inst_no = MFC_NO_INSTANCE_SET;\r\nif (dev->num_inst == 1) {\r\ndev->watchdog_timer.expires = jiffies +\r\nmsecs_to_jiffies(MFC_WATCHDOG_INTERVAL);\r\nadd_timer(&dev->watchdog_timer);\r\nret = s5p_mfc_power_on();\r\nif (ret < 0) {\r\nmfc_err("power on failed\n");\r\ngoto err_pwr_enable;\r\n}\r\ns5p_mfc_clock_on();\r\nret = s5p_mfc_load_firmware(dev);\r\nif (ret) {\r\ns5p_mfc_clock_off();\r\ngoto err_load_fw;\r\n}\r\nret = s5p_mfc_init_hw(dev);\r\ns5p_mfc_clock_off();\r\nif (ret)\r\ngoto err_init_hw;\r\n}\r\nq = &ctx->vq_dst;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\nq->drv_priv = &ctx->fh;\r\nq->lock = &dev->mfc_mutex;\r\nif (vdev == dev->vfd_dec) {\r\nq->io_modes = VB2_MMAP;\r\nq->ops = get_dec_queue_ops();\r\n} else if (vdev == dev->vfd_enc) {\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = get_enc_queue_ops();\r\n} else {\r\nret = -ENOENT;\r\ngoto err_queue_init;\r\n}\r\nq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nmfc_err("Failed to initialize videobuf2 queue(capture)\n");\r\ngoto err_queue_init;\r\n}\r\nq = &ctx->vq_src;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nq->io_modes = VB2_MMAP;\r\nq->drv_priv = &ctx->fh;\r\nq->lock = &dev->mfc_mutex;\r\nif (vdev == dev->vfd_dec) {\r\nq->io_modes = VB2_MMAP;\r\nq->ops = get_dec_queue_ops();\r\n} else if (vdev == dev->vfd_enc) {\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = get_enc_queue_ops();\r\n} else {\r\nret = -ENOENT;\r\ngoto err_queue_init;\r\n}\r\nq->allow_zero_bytesused = 1;\r\nq->dma_attrs = DMA_ATTR_ALLOC_SINGLE_PAGES;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nmfc_err("Failed to initialize videobuf2 queue(output)\n");\r\ngoto err_queue_init;\r\n}\r\ninit_waitqueue_head(&ctx->queue);\r\nmutex_unlock(&dev->mfc_mutex);\r\nmfc_debug_leave();\r\nreturn ret;\r\nerr_queue_init:\r\nif (dev->num_inst == 1)\r\ns5p_mfc_deinit_hw(dev);\r\nerr_init_hw:\r\nerr_load_fw:\r\nerr_pwr_enable:\r\nif (dev->num_inst == 1) {\r\nif (s5p_mfc_power_off() < 0)\r\nmfc_err("power off failed\n");\r\ndel_timer_sync(&dev->watchdog_timer);\r\n}\r\nerr_ctrls_setup:\r\ns5p_mfc_dec_ctrls_delete(ctx);\r\nerr_bad_node:\r\ndev->ctx[ctx->num] = NULL;\r\nerr_no_ctx:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nerr_alloc:\r\ndev->num_inst--;\r\nmutex_unlock(&dev->mfc_mutex);\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int s5p_mfc_release(struct file *file)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmfc_debug_enter();\r\nif (dev)\r\nmutex_lock(&dev->mfc_mutex);\r\nvb2_queue_release(&ctx->vq_src);\r\nvb2_queue_release(&ctx->vq_dst);\r\nif (dev) {\r\ns5p_mfc_clock_on();\r\nclear_work_bit_irqsave(ctx);\r\nif (ctx->state != MFCINST_FREE && ctx->state != MFCINST_INIT) {\r\nmfc_debug(2, "Has to free instance\n");\r\ns5p_mfc_close_mfc_inst(dev, ctx);\r\n}\r\nif (dev->curr_ctx == ctx->num)\r\nclear_bit(0, &dev->hw_lock);\r\ndev->num_inst--;\r\nif (dev->num_inst == 0) {\r\nmfc_debug(2, "Last instance\n");\r\ns5p_mfc_deinit_hw(dev);\r\ndel_timer_sync(&dev->watchdog_timer);\r\ns5p_mfc_clock_off();\r\nif (s5p_mfc_power_off() < 0)\r\nmfc_err("Power off failed\n");\r\n} else {\r\nmfc_debug(2, "Shutting down clock\n");\r\ns5p_mfc_clock_off();\r\n}\r\n}\r\nif (dev)\r\ndev->ctx[ctx->num] = NULL;\r\ns5p_mfc_dec_ctrls_delete(ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nif (dev)\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nmfc_debug_leave();\r\nif (dev)\r\nmutex_unlock(&dev->mfc_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int s5p_mfc_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nstruct vb2_queue *src_q, *dst_q;\r\nstruct vb2_buffer *src_vb = NULL, *dst_vb = NULL;\r\nunsigned int rc = 0;\r\nunsigned long flags;\r\nmutex_lock(&dev->mfc_mutex);\r\nsrc_q = &ctx->vq_src;\r\ndst_q = &ctx->vq_dst;\r\nif ((!src_q->streaming || list_empty(&src_q->queued_list))\r\n&& (!dst_q->streaming || list_empty(&dst_q->queued_list))) {\r\nrc = POLLERR;\r\ngoto end;\r\n}\r\nmutex_unlock(&dev->mfc_mutex);\r\npoll_wait(file, &ctx->fh.wait, wait);\r\npoll_wait(file, &src_q->done_wq, wait);\r\npoll_wait(file, &dst_q->done_wq, wait);\r\nmutex_lock(&dev->mfc_mutex);\r\nif (v4l2_event_pending(&ctx->fh))\r\nrc |= POLLPRI;\r\nspin_lock_irqsave(&src_q->done_lock, flags);\r\nif (!list_empty(&src_q->done_list))\r\nsrc_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (src_vb && (src_vb->state == VB2_BUF_STATE_DONE\r\n|| src_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&src_q->done_lock, flags);\r\nspin_lock_irqsave(&dst_q->done_lock, flags);\r\nif (!list_empty(&dst_q->done_list))\r\ndst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nif (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE\r\n|| dst_vb->state == VB2_BUF_STATE_ERROR))\r\nrc |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&dst_q->done_lock, flags);\r\nend:\r\nmutex_unlock(&dev->mfc_mutex);\r\nreturn rc;\r\n}\r\nstatic int s5p_mfc_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nint ret;\r\nif (mutex_lock_interruptible(&dev->mfc_mutex))\r\nreturn -ERESTARTSYS;\r\nif (offset < DST_QUEUE_OFF_BASE) {\r\nmfc_debug(2, "mmaping source\n");\r\nret = vb2_mmap(&ctx->vq_src, vma);\r\n} else {\r\nmfc_debug(2, "mmaping destination\n");\r\nvma->vm_pgoff -= (DST_QUEUE_OFF_BASE >> PAGE_SHIFT);\r\nret = vb2_mmap(&ctx->vq_dst, vma);\r\n}\r\nmutex_unlock(&dev->mfc_mutex);\r\nreturn ret;\r\n}\r\nstatic void s5p_mfc_memdev_release(struct device *dev)\r\n{\r\nof_reserved_mem_device_release(dev);\r\n}\r\nstatic struct device *s5p_mfc_alloc_memdev(struct device *dev,\r\nconst char *name, unsigned int idx)\r\n{\r\nstruct device *child;\r\nint ret;\r\nchild = devm_kzalloc(dev, sizeof(struct device), GFP_KERNEL);\r\nif (!child)\r\nreturn NULL;\r\ndevice_initialize(child);\r\ndev_set_name(child, "%s:%s", dev_name(dev), name);\r\nchild->parent = dev;\r\nchild->bus = dev->bus;\r\nchild->coherent_dma_mask = dev->coherent_dma_mask;\r\nchild->dma_mask = dev->dma_mask;\r\nchild->release = s5p_mfc_memdev_release;\r\nif (device_add(child) == 0) {\r\nret = of_reserved_mem_device_init_by_idx(child, dev->of_node,\r\nidx);\r\nif (ret == 0)\r\nreturn child;\r\ndevice_del(child);\r\n}\r\nput_device(child);\r\nreturn NULL;\r\n}\r\nstatic int s5p_mfc_configure_dma_memory(struct s5p_mfc_dev *mfc_dev)\r\n{\r\nstruct device *dev = &mfc_dev->plat_dev->dev;\r\nif (exynos_is_iommu_available(dev)) {\r\nint ret = exynos_configure_iommu(dev, S5P_MFC_IOMMU_DMA_BASE,\r\nS5P_MFC_IOMMU_DMA_SIZE);\r\nif (ret == 0)\r\nmfc_dev->mem_dev_l = mfc_dev->mem_dev_r = dev;\r\nreturn ret;\r\n}\r\nmfc_dev->mem_dev_l = s5p_mfc_alloc_memdev(dev, "left",\r\nMFC_BANK1_ALLOC_CTX);\r\nif (!mfc_dev->mem_dev_l)\r\nreturn -ENODEV;\r\nmfc_dev->mem_dev_r = s5p_mfc_alloc_memdev(dev, "right",\r\nMFC_BANK2_ALLOC_CTX);\r\nif (!mfc_dev->mem_dev_r) {\r\ndevice_unregister(mfc_dev->mem_dev_l);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_unconfigure_dma_memory(struct s5p_mfc_dev *mfc_dev)\r\n{\r\nstruct device *dev = &mfc_dev->plat_dev->dev;\r\nif (exynos_is_iommu_available(dev)) {\r\nexynos_unconfigure_iommu(dev);\r\nreturn;\r\n}\r\ndevice_unregister(mfc_dev->mem_dev_l);\r\ndevice_unregister(mfc_dev->mem_dev_r);\r\n}\r\nstatic int s5p_mfc_probe(struct platform_device *pdev)\r\n{\r\nstruct s5p_mfc_dev *dev;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint ret;\r\npr_debug("%s++\n", __func__);\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "Not enough memory for MFC device\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&dev->irqlock);\r\nspin_lock_init(&dev->condlock);\r\ndev->plat_dev = pdev;\r\nif (!dev->plat_dev) {\r\ndev_err(&pdev->dev, "No platform data specified\n");\r\nreturn -ENODEV;\r\n}\r\ndev->variant = mfc_get_drv_data(pdev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->regs_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->regs_base))\r\nreturn PTR_ERR(dev->regs_base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get irq resource\n");\r\nreturn -ENOENT;\r\n}\r\ndev->irq = res->start;\r\nret = devm_request_irq(&pdev->dev, dev->irq, s5p_mfc_irq,\r\n0, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to install irq (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = s5p_mfc_configure_dma_memory(dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to configure DMA memory\n");\r\nreturn ret;\r\n}\r\nret = s5p_mfc_init_pm(dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get mfc clock source\n");\r\ngoto err_dma;\r\n}\r\nvb2_dma_contig_set_max_seg_size(dev->mem_dev_l, DMA_BIT_MASK(32));\r\nvb2_dma_contig_set_max_seg_size(dev->mem_dev_r, DMA_BIT_MASK(32));\r\nmutex_init(&dev->mfc_mutex);\r\nret = s5p_mfc_alloc_firmware(dev);\r\nif (ret)\r\ngoto err_res;\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret)\r\ngoto err_v4l2_dev_reg;\r\ninit_waitqueue_head(&dev->queue);\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto err_dec_alloc;\r\n}\r\nvfd->fops = &s5p_mfc_fops;\r\nvfd->ioctl_ops = get_dec_v4l2_ioctl_ops();\r\nvfd->release = video_device_release;\r\nvfd->lock = &dev->mfc_mutex;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->vfl_dir = VFL_DIR_M2M;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", S5P_MFC_DEC_NAME);\r\ndev->vfd_dec = vfd;\r\nvideo_set_drvdata(vfd, dev);\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto err_enc_alloc;\r\n}\r\nvfd->fops = &s5p_mfc_fops;\r\nvfd->ioctl_ops = get_enc_v4l2_ioctl_ops();\r\nvfd->release = video_device_release;\r\nvfd->lock = &dev->mfc_mutex;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->vfl_dir = VFL_DIR_M2M;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", S5P_MFC_ENC_NAME);\r\ndev->vfd_enc = vfd;\r\nvideo_set_drvdata(vfd, dev);\r\nplatform_set_drvdata(pdev, dev);\r\ndev->hw_lock = 0;\r\nINIT_WORK(&dev->watchdog_work, s5p_mfc_watchdog_worker);\r\natomic_set(&dev->watchdog_cnt, 0);\r\ninit_timer(&dev->watchdog_timer);\r\ndev->watchdog_timer.data = (unsigned long)dev;\r\ndev->watchdog_timer.function = s5p_mfc_watchdog;\r\ns5p_mfc_init_hw_ops(dev);\r\ns5p_mfc_init_hw_cmds(dev);\r\ns5p_mfc_init_regs(dev);\r\nret = video_register_device(dev->vfd_dec, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\ngoto err_dec_reg;\r\n}\r\nv4l2_info(&dev->v4l2_dev,\r\n"decoder registered as /dev/video%d\n", dev->vfd_dec->num);\r\nret = video_register_device(dev->vfd_enc, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev, "Failed to register video device\n");\r\ngoto err_enc_reg;\r\n}\r\nv4l2_info(&dev->v4l2_dev,\r\n"encoder registered as /dev/video%d\n", dev->vfd_enc->num);\r\npr_debug("%s--\n", __func__);\r\nreturn 0;\r\nerr_enc_reg:\r\nvideo_unregister_device(dev->vfd_dec);\r\nerr_dec_reg:\r\nvideo_device_release(dev->vfd_enc);\r\nerr_enc_alloc:\r\nvideo_device_release(dev->vfd_dec);\r\nerr_dec_alloc:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2_dev_reg:\r\ns5p_mfc_release_firmware(dev);\r\nerr_res:\r\ns5p_mfc_final_pm(dev);\r\nerr_dma:\r\ns5p_mfc_unconfigure_dma_memory(dev);\r\npr_debug("%s-- with error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int s5p_mfc_remove(struct platform_device *pdev)\r\n{\r\nstruct s5p_mfc_dev *dev = platform_get_drvdata(pdev);\r\nstruct s5p_mfc_ctx *ctx;\r\nint i;\r\nv4l2_info(&dev->v4l2_dev, "Removing %s\n", pdev->name);\r\nmutex_lock(&dev->mfc_mutex);\r\nfor (i = 0; i < MFC_NUM_CONTEXTS; i++) {\r\nctx = dev->ctx[i];\r\nif (!ctx)\r\ncontinue;\r\nctx->dev = NULL;\r\n}\r\nmutex_unlock(&dev->mfc_mutex);\r\ndel_timer_sync(&dev->watchdog_timer);\r\nflush_work(&dev->watchdog_work);\r\nvideo_unregister_device(dev->vfd_enc);\r\nvideo_unregister_device(dev->vfd_dec);\r\nvideo_device_release(dev->vfd_enc);\r\nvideo_device_release(dev->vfd_dec);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\ns5p_mfc_release_firmware(dev);\r\ns5p_mfc_unconfigure_dma_memory(dev);\r\nvb2_dma_contig_clear_max_seg_size(dev->mem_dev_l);\r\nvb2_dma_contig_clear_max_seg_size(dev->mem_dev_r);\r\ns5p_mfc_final_pm(dev);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\nint ret;\r\nif (m_dev->num_inst == 0)\r\nreturn 0;\r\nif (test_and_set_bit(0, &m_dev->enter_suspend) != 0) {\r\nmfc_err("Error: going to suspend for a second time\n");\r\nreturn -EIO;\r\n}\r\nwhile (test_and_set_bit(0, &m_dev->hw_lock) != 0) {\r\nret = wait_event_interruptible_timeout(m_dev->queue,\r\nm_dev->int_cond, msecs_to_jiffies(MFC_INT_TIMEOUT));\r\nif (ret == 0) {\r\nmfc_err("Waiting for hardware to finish timed out\n");\r\nclear_bit(0, &m_dev->enter_suspend);\r\nreturn -EIO;\r\n}\r\n}\r\nret = s5p_mfc_sleep(m_dev);\r\nif (ret) {\r\nclear_bit(0, &m_dev->enter_suspend);\r\nclear_bit(0, &m_dev->hw_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5p_mfc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct s5p_mfc_dev *m_dev = platform_get_drvdata(pdev);\r\nif (m_dev->num_inst == 0)\r\nreturn 0;\r\nreturn s5p_mfc_wakeup(m_dev);\r\n}\r\nstatic void *mfc_get_drv_data(struct platform_device *pdev)\r\n{\r\nstruct s5p_mfc_variant *driver_data = NULL;\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(exynos_mfc_match, pdev->dev.of_node);\r\nif (match)\r\ndriver_data = (struct s5p_mfc_variant *)match->data;\r\nreturn driver_data;\r\n}
