int sis_wait_for_ctrl_ready(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nunsigned long timeout;\r\nu32 status;\r\ntimeout = (SIS_CTRL_READY_TIMEOUT_SECS * HZ) + jiffies;\r\nwhile (1) {\r\nstatus = readl(&ctrl_info->registers->sis_firmware_status);\r\nif (status != ~0) {\r\nif (status & SIS_CTRL_KERNEL_PANIC) {\r\ndev_err(&ctrl_info->pci_dev->dev,\r\n"controller is offline: status code 0x%x\n",\r\nreadl(\r\n&ctrl_info->registers->sis_mailbox[7]));\r\nreturn -ENODEV;\r\n}\r\nif (status & SIS_CTRL_KERNEL_UP)\r\nbreak;\r\n}\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmsleep(SIS_CTRL_READY_POLL_INTERVAL_MSECS);\r\n}\r\nreturn 0;\r\n}\r\nbool sis_is_firmware_running(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nbool running;\r\nu32 status;\r\nstatus = readl(&ctrl_info->registers->sis_firmware_status);\r\nif (status & SIS_CTRL_KERNEL_PANIC)\r\nrunning = false;\r\nelse\r\nrunning = true;\r\nif (!running)\r\ndev_err(&ctrl_info->pci_dev->dev,\r\n"controller is offline: status code 0x%x\n",\r\nreadl(&ctrl_info->registers->sis_mailbox[7]));\r\nreturn running;\r\n}\r\nstatic int sis_send_sync_cmd(struct pqi_ctrl_info *ctrl_info,\r\nu32 cmd, struct sis_sync_cmd_params *params)\r\n{\r\nstruct pqi_ctrl_registers __iomem *registers;\r\nunsigned int i;\r\nunsigned long timeout;\r\nu32 doorbell;\r\nu32 cmd_status;\r\nregisters = ctrl_info->registers;\r\nwritel(cmd, &registers->sis_mailbox[0]);\r\nfor (i = 1; i <= 4; i++)\r\nwritel(params->mailbox[i], &registers->sis_mailbox[i]);\r\nwritel(SIS_CLEAR_CTRL_TO_HOST_DOORBELL,\r\n&registers->sis_ctrl_to_host_doorbell_clear);\r\nwritel(~0, &registers->sis_interrupt_mask);\r\nreadl(&registers->sis_interrupt_mask);\r\nwritel(SIS_CMD_READY, &registers->sis_host_to_ctrl_doorbell);\r\ntimeout = (SIS_CMD_COMPLETE_TIMEOUT_SECS * HZ) + jiffies;\r\nwhile (1) {\r\nmsleep(SIS_CMD_COMPLETE_POLL_INTERVAL_MSECS);\r\ndoorbell = readl(&registers->sis_ctrl_to_host_doorbell);\r\nif (doorbell & SIS_CMD_COMPLETE)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\n}\r\ncmd_status = readl(&registers->sis_mailbox[0]);\r\nif (cmd_status != SIS_CMD_STATUS_SUCCESS) {\r\ndev_err(&ctrl_info->pci_dev->dev,\r\n"SIS command failed for command 0x%x: status = 0x%x\n",\r\ncmd, cmd_status);\r\nreturn -EINVAL;\r\n}\r\nparams->mailbox[0] = cmd_status;\r\nfor (i = 1; i < ARRAY_SIZE(params->mailbox); i++)\r\nparams->mailbox[i] = readl(&registers->sis_mailbox[i]);\r\nreturn 0;\r\n}\r\nint sis_get_ctrl_properties(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nint rc;\r\nu32 properties;\r\nu32 extended_properties;\r\nstruct sis_sync_cmd_params params;\r\nmemset(&params, 0, sizeof(params));\r\nrc = sis_send_sync_cmd(ctrl_info, SIS_CMD_GET_ADAPTER_PROPERTIES,\r\n&params);\r\nif (rc)\r\nreturn rc;\r\nproperties = params.mailbox[1];\r\nif (!(properties & SIS_EXTENDED_PROPERTIES_SUPPORTED))\r\nreturn -ENODEV;\r\nextended_properties = params.mailbox[4];\r\nif ((extended_properties & SIS_REQUIRED_EXTENDED_PROPERTIES) !=\r\nSIS_REQUIRED_EXTENDED_PROPERTIES)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nint sis_get_pqi_capabilities(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nint rc;\r\nstruct sis_sync_cmd_params params;\r\nmemset(&params, 0, sizeof(params));\r\nrc = sis_send_sync_cmd(ctrl_info, SIS_CMD_GET_PQI_CAPABILITIES,\r\n&params);\r\nif (rc)\r\nreturn rc;\r\nctrl_info->max_sg_entries = params.mailbox[1];\r\nctrl_info->max_transfer_size = params.mailbox[2];\r\nctrl_info->max_outstanding_requests = params.mailbox[3];\r\nctrl_info->config_table_offset = params.mailbox[4];\r\nctrl_info->config_table_length = params.mailbox[5];\r\nreturn 0;\r\n}\r\nint sis_init_base_struct_addr(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nint rc;\r\nvoid *base_struct_unaligned;\r\nstruct sis_base_struct *base_struct;\r\nstruct sis_sync_cmd_params params;\r\nunsigned long error_buffer_paddr;\r\ndma_addr_t bus_address;\r\nbase_struct_unaligned = kzalloc(sizeof(*base_struct)\r\n+ SIS_BASE_STRUCT_ALIGNMENT - 1, GFP_KERNEL);\r\nif (!base_struct_unaligned)\r\nreturn -ENOMEM;\r\nbase_struct = PTR_ALIGN(base_struct_unaligned,\r\nSIS_BASE_STRUCT_ALIGNMENT);\r\nerror_buffer_paddr = (unsigned long)ctrl_info->error_buffer_dma_handle;\r\nput_unaligned_le32(SIS_BASE_STRUCT_REVISION, &base_struct->revision);\r\nput_unaligned_le32(lower_32_bits(error_buffer_paddr),\r\n&base_struct->error_buffer_paddr_low);\r\nput_unaligned_le32(upper_32_bits(error_buffer_paddr),\r\n&base_struct->error_buffer_paddr_high);\r\nput_unaligned_le32(PQI_ERROR_BUFFER_ELEMENT_LENGTH,\r\n&base_struct->error_buffer_element_length);\r\nput_unaligned_le32(ctrl_info->max_io_slots,\r\n&base_struct->error_buffer_num_elements);\r\nbus_address = pci_map_single(ctrl_info->pci_dev, base_struct,\r\nsizeof(*base_struct), PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(ctrl_info->pci_dev, bus_address)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nparams.mailbox[1] = lower_32_bits((u64)bus_address);\r\nparams.mailbox[2] = upper_32_bits((u64)bus_address);\r\nparams.mailbox[3] = sizeof(*base_struct);\r\nrc = sis_send_sync_cmd(ctrl_info, SIS_CMD_INIT_BASE_STRUCT_ADDRESS,\r\n&params);\r\npci_unmap_single(ctrl_info->pci_dev, bus_address, sizeof(*base_struct),\r\nPCI_DMA_TODEVICE);\r\nout:\r\nkfree(base_struct_unaligned);\r\nreturn rc;\r\n}\r\nvoid sis_enable_msix(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nu32 doorbell_register;\r\ndoorbell_register =\r\nreadl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);\r\ndoorbell_register |= SIS_ENABLE_MSIX;\r\nwritel(doorbell_register,\r\n&ctrl_info->registers->sis_host_to_ctrl_doorbell);\r\n}\r\nvoid sis_disable_msix(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nu32 doorbell_register;\r\ndoorbell_register =\r\nreadl(&ctrl_info->registers->sis_host_to_ctrl_doorbell);\r\ndoorbell_register &= ~SIS_ENABLE_MSIX;\r\nwritel(doorbell_register,\r\n&ctrl_info->registers->sis_host_to_ctrl_doorbell);\r\n}\r\nvoid sis_soft_reset(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nwritel(SIS_SOFT_RESET,\r\n&ctrl_info->registers->sis_host_to_ctrl_doorbell);\r\n}\r\nint sis_reenable_sis_mode(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nint rc;\r\nunsigned long timeout;\r\nstruct pqi_ctrl_registers __iomem *registers;\r\nu32 doorbell;\r\nregisters = ctrl_info->registers;\r\nwritel(SIS_REENABLE_SIS_MODE,\r\n&registers->sis_host_to_ctrl_doorbell);\r\nrc = 0;\r\ntimeout = (SIS_MODE_READY_TIMEOUT_SECS * HZ) + jiffies;\r\nwhile (1) {\r\ndoorbell = readl(&registers->sis_ctrl_to_host_doorbell);\r\nif ((doorbell & SIS_REENABLE_SIS_MODE) == 0)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\nrc = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nif (rc)\r\ndev_err(&ctrl_info->pci_dev->dev,\r\n"re-enabling SIS mode failed\n");\r\nreturn rc;\r\n}\r\nvoid sis_write_driver_scratch(struct pqi_ctrl_info *ctrl_info, u32 value)\r\n{\r\nwritel(value, &ctrl_info->registers->sis_driver_scratch);\r\n}\r\nu32 sis_read_driver_scratch(struct pqi_ctrl_info *ctrl_info)\r\n{\r\nreturn readl(&ctrl_info->registers->sis_driver_scratch);\r\n}
