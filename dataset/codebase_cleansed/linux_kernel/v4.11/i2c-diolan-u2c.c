static int diolan_usb_transfer(struct i2c_diolan_u2c *dev)\r\n{\r\nint ret = 0;\r\nint actual;\r\nint i;\r\nif (!dev->olen || !dev->ocount)\r\nreturn -EINVAL;\r\nret = usb_bulk_msg(dev->usb_dev,\r\nusb_sndbulkpipe(dev->usb_dev, dev->ep_out),\r\ndev->obuffer, dev->olen, &actual,\r\nDIOLAN_USB_TIMEOUT);\r\nif (!ret) {\r\nfor (i = 0; i < dev->ocount; i++) {\r\nint tmpret;\r\ntmpret = usb_bulk_msg(dev->usb_dev,\r\nusb_rcvbulkpipe(dev->usb_dev,\r\ndev->ep_in),\r\ndev->ibuffer,\r\nsizeof(dev->ibuffer), &actual,\r\nDIOLAN_USB_TIMEOUT);\r\nif (ret < 0)\r\ncontinue;\r\nret = tmpret;\r\nif (ret == 0 && actual > 0) {\r\nswitch (dev->ibuffer[actual - 1]) {\r\ncase RESP_NACK:\r\nret = i == 1 ? -ENXIO : -EIO;\r\nbreak;\r\ncase RESP_TIMEOUT:\r\nret = -ETIMEDOUT;\r\nbreak;\r\ncase RESP_OK:\r\nret = actual - 1;\r\nbreak;\r\ndefault:\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\ndev->olen = 0;\r\ndev->ocount = 0;\r\nreturn ret;\r\n}\r\nstatic int diolan_write_cmd(struct i2c_diolan_u2c *dev, bool flush)\r\n{\r\nif (flush || dev->olen >= DIOLAN_FLUSH_LEN)\r\nreturn diolan_usb_transfer(dev);\r\nreturn 0;\r\n}\r\nstatic int diolan_usb_cmd(struct i2c_diolan_u2c *dev, u8 command, bool flush)\r\n{\r\ndev->obuffer[dev->olen++] = command;\r\ndev->ocount++;\r\nreturn diolan_write_cmd(dev, flush);\r\n}\r\nstatic int diolan_usb_cmd_data(struct i2c_diolan_u2c *dev, u8 command, u8 data,\r\nbool flush)\r\n{\r\ndev->obuffer[dev->olen++] = command;\r\ndev->obuffer[dev->olen++] = data;\r\ndev->ocount++;\r\nreturn diolan_write_cmd(dev, flush);\r\n}\r\nstatic int diolan_usb_cmd_data2(struct i2c_diolan_u2c *dev, u8 command, u8 d1,\r\nu8 d2, bool flush)\r\n{\r\ndev->obuffer[dev->olen++] = command;\r\ndev->obuffer[dev->olen++] = d1;\r\ndev->obuffer[dev->olen++] = d2;\r\ndev->ocount++;\r\nreturn diolan_write_cmd(dev, flush);\r\n}\r\nstatic void diolan_flush_input(struct i2c_diolan_u2c *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nint actual = 0;\r\nint ret;\r\nret = usb_bulk_msg(dev->usb_dev,\r\nusb_rcvbulkpipe(dev->usb_dev, dev->ep_in),\r\ndev->ibuffer, sizeof(dev->ibuffer), &actual,\r\nDIOLAN_USB_TIMEOUT);\r\nif (ret < 0 || actual == 0)\r\nbreak;\r\n}\r\nif (i == 10)\r\ndev_err(&dev->interface->dev, "Failed to flush input buffer\n");\r\n}\r\nstatic int diolan_i2c_start(struct i2c_diolan_u2c *dev)\r\n{\r\nreturn diolan_usb_cmd(dev, CMD_I2C_START, false);\r\n}\r\nstatic int diolan_i2c_repeated_start(struct i2c_diolan_u2c *dev)\r\n{\r\nreturn diolan_usb_cmd(dev, CMD_I2C_REPEATED_START, false);\r\n}\r\nstatic int diolan_i2c_stop(struct i2c_diolan_u2c *dev)\r\n{\r\nreturn diolan_usb_cmd(dev, CMD_I2C_STOP, true);\r\n}\r\nstatic int diolan_i2c_get_byte_ack(struct i2c_diolan_u2c *dev, bool ack,\r\nu8 *byte)\r\n{\r\nint ret;\r\nret = diolan_usb_cmd_data(dev, CMD_I2C_GET_BYTE_ACK, ack, true);\r\nif (ret > 0)\r\n*byte = dev->ibuffer[0];\r\nelse if (ret == 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstatic int diolan_i2c_put_byte_ack(struct i2c_diolan_u2c *dev, u8 byte)\r\n{\r\nreturn diolan_usb_cmd_data(dev, CMD_I2C_PUT_BYTE_ACK, byte, false);\r\n}\r\nstatic int diolan_set_speed(struct i2c_diolan_u2c *dev, u8 speed)\r\n{\r\nreturn diolan_usb_cmd_data(dev, CMD_I2C_SET_SPEED, speed, true);\r\n}\r\nstatic int diolan_set_clock_synch(struct i2c_diolan_u2c *dev, bool enable)\r\n{\r\nreturn diolan_usb_cmd_data(dev, CMD_I2C_SET_CLK_SYNC, enable, true);\r\n}\r\nstatic int diolan_set_clock_synch_timeout(struct i2c_diolan_u2c *dev, int ms)\r\n{\r\nint to_val = ms * 10;\r\nreturn diolan_usb_cmd_data2(dev, CMD_I2C_SET_CLK_SYNC_TO,\r\nto_val & 0xff, (to_val >> 8) & 0xff, true);\r\n}\r\nstatic void diolan_fw_version(struct i2c_diolan_u2c *dev)\r\n{\r\nint ret;\r\nret = diolan_usb_cmd(dev, CMD_GET_FW_VERSION, true);\r\nif (ret >= 2)\r\ndev_info(&dev->interface->dev,\r\n"Diolan U2C firmware version %u.%u\n",\r\n(unsigned int)dev->ibuffer[0],\r\n(unsigned int)dev->ibuffer[1]);\r\n}\r\nstatic void diolan_get_serial(struct i2c_diolan_u2c *dev)\r\n{\r\nint ret;\r\nu32 serial;\r\nret = diolan_usb_cmd(dev, CMD_GET_SERIAL, true);\r\nif (ret >= 4) {\r\nserial = le32_to_cpu(*(u32 *)dev->ibuffer);\r\ndev_info(&dev->interface->dev,\r\n"Diolan U2C serial number %u\n", serial);\r\n}\r\n}\r\nstatic int diolan_init(struct i2c_diolan_u2c *dev)\r\n{\r\nint speed, ret;\r\nif (frequency >= 200000) {\r\nspeed = U2C_I2C_SPEED_FAST;\r\nfrequency = U2C_I2C_FREQ_FAST;\r\n} else if (frequency >= 100000 || frequency == 0) {\r\nspeed = U2C_I2C_SPEED_STD;\r\nfrequency = U2C_I2C_FREQ_STD;\r\n} else {\r\nspeed = U2C_I2C_SPEED(frequency);\r\nif (speed > U2C_I2C_SPEED_2KHZ)\r\nspeed = U2C_I2C_SPEED_2KHZ;\r\nfrequency = U2C_I2C_FREQ(speed);\r\n}\r\ndev_info(&dev->interface->dev,\r\n"Diolan U2C at USB bus %03d address %03d speed %d Hz\n",\r\ndev->usb_dev->bus->busnum, dev->usb_dev->devnum, frequency);\r\ndiolan_flush_input(dev);\r\ndiolan_fw_version(dev);\r\ndiolan_get_serial(dev);\r\nret = diolan_set_speed(dev, speed);\r\nif (ret < 0)\r\nreturn ret;\r\nret = diolan_set_clock_synch(dev, speed != U2C_I2C_SPEED_FAST);\r\nif (ret < 0)\r\nreturn ret;\r\nif (speed != U2C_I2C_SPEED_FAST)\r\nret = diolan_set_clock_synch_timeout(dev, DIOLAN_SYNC_TIMEOUT);\r\nreturn ret;\r\n}\r\nstatic int diolan_usb_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct i2c_diolan_u2c *dev = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *pmsg;\r\nint i, j;\r\nint ret, sret;\r\nret = diolan_i2c_start(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < num; i++) {\r\npmsg = &msgs[i];\r\nif (i) {\r\nret = diolan_i2c_repeated_start(dev);\r\nif (ret < 0)\r\ngoto abort;\r\n}\r\nif (pmsg->flags & I2C_M_RD) {\r\nret =\r\ndiolan_i2c_put_byte_ack(dev, (pmsg->addr << 1) | 1);\r\nif (ret < 0)\r\ngoto abort;\r\nfor (j = 0; j < pmsg->len; j++) {\r\nu8 byte;\r\nbool ack = j < pmsg->len - 1;\r\nif (j == 0 && (pmsg->flags & I2C_M_RECV_LEN))\r\nack = true;\r\nret = diolan_i2c_get_byte_ack(dev, ack, &byte);\r\nif (ret < 0)\r\ngoto abort;\r\nif (j == 0 && (pmsg->flags & I2C_M_RECV_LEN)) {\r\nif (byte == 0\r\n|| byte > I2C_SMBUS_BLOCK_MAX) {\r\nret = -EPROTO;\r\ngoto abort;\r\n}\r\npmsg->len += byte;\r\n}\r\npmsg->buf[j] = byte;\r\n}\r\n} else {\r\nret = diolan_i2c_put_byte_ack(dev, pmsg->addr << 1);\r\nif (ret < 0)\r\ngoto abort;\r\nfor (j = 0; j < pmsg->len; j++) {\r\nret = diolan_i2c_put_byte_ack(dev,\r\npmsg->buf[j]);\r\nif (ret < 0)\r\ngoto abort;\r\n}\r\n}\r\n}\r\nret = num;\r\nabort:\r\nsret = diolan_i2c_stop(dev);\r\nif (sret < 0 && ret >= 0)\r\nret = sret;\r\nreturn ret;\r\n}\r\nstatic u32 diolan_usb_func(struct i2c_adapter *a)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_FUNC_SMBUS_BLOCK_PROC_CALL;\r\n}\r\nstatic void diolan_u2c_free(struct i2c_diolan_u2c *dev)\r\n{\r\nusb_put_dev(dev->usb_dev);\r\nkfree(dev);\r\n}\r\nstatic int diolan_u2c_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *hostif = interface->cur_altsetting;\r\nstruct i2c_diolan_u2c *dev;\r\nint ret;\r\nif (hostif->desc.bInterfaceNumber != 0\r\n|| hostif->desc.bNumEndpoints < 2)\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ndev->ep_out = hostif->endpoint[0].desc.bEndpointAddress;\r\ndev->ep_in = hostif->endpoint[1].desc.bEndpointAddress;\r\ndev->usb_dev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\nusb_set_intfdata(interface, dev);\r\ndev->adapter.owner = THIS_MODULE;\r\ndev->adapter.class = I2C_CLASS_HWMON;\r\ndev->adapter.algo = &diolan_usb_algorithm;\r\ni2c_set_adapdata(&dev->adapter, dev);\r\nsnprintf(dev->adapter.name, sizeof(dev->adapter.name),\r\nDRIVER_NAME " at bus %03d device %03d",\r\ndev->usb_dev->bus->busnum, dev->usb_dev->devnum);\r\ndev->adapter.dev.parent = &dev->interface->dev;\r\nret = diolan_init(dev);\r\nif (ret < 0) {\r\ndev_err(&interface->dev, "failed to initialize adapter\n");\r\ngoto error_free;\r\n}\r\nret = i2c_add_adapter(&dev->adapter);\r\nif (ret < 0)\r\ngoto error_free;\r\ndev_dbg(&interface->dev, "connected " DRIVER_NAME "\n");\r\nreturn 0;\r\nerror_free:\r\nusb_set_intfdata(interface, NULL);\r\ndiolan_u2c_free(dev);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void diolan_u2c_disconnect(struct usb_interface *interface)\r\n{\r\nstruct i2c_diolan_u2c *dev = usb_get_intfdata(interface);\r\ni2c_del_adapter(&dev->adapter);\r\nusb_set_intfdata(interface, NULL);\r\ndiolan_u2c_free(dev);\r\ndev_dbg(&interface->dev, "disconnected\n");\r\n}
