static inline int get_real_i2c_port(struct cx231xx *dev, int bus_nr)\r\n{\r\nif (bus_nr == 1)\r\nreturn dev->port_3_switch_enabled ? I2C_1_MUX_3 : I2C_1_MUX_1;\r\nreturn bus_nr;\r\n}\r\nstatic inline bool is_tuner(struct cx231xx *dev, struct cx231xx_i2c *bus,\r\nconst struct i2c_msg *msg, int tuner_type)\r\n{\r\nint i2c_port = get_real_i2c_port(dev, bus->nr);\r\nif (i2c_port != dev->board.tuner_i2c_master)\r\nreturn false;\r\nif (msg->addr != dev->board.tuner_addr)\r\nreturn false;\r\nif (dev->tuner_type != tuner_type)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int cx231xx_i2c_send_bytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg)\r\n{\r\nstruct cx231xx_i2c *bus = i2c_adap->algo_data;\r\nstruct cx231xx *dev = bus->dev;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nint status = 0;\r\nu16 size = 0;\r\nu8 loop = 0;\r\nu8 saddr_len = 1;\r\nu8 *buf_ptr = NULL;\r\nu16 saddr = 0;\r\nu8 need_gpio = 0;\r\nif (is_tuner(dev, bus, msg, TUNER_XC5000)) {\r\nsize = msg->len;\r\nif (size == 2) {\r\nreturn 0;\r\n} else if (size == 4) {\r\nif (msg->len >= 2)\r\nsaddr = msg->buf[0] << 8 | msg->buf[1];\r\nelse if (msg->len == 1)\r\nsaddr = msg->buf[0];\r\nswitch (saddr) {\r\ncase 0x0000:\r\nneed_gpio = 1;\r\ndev->xc_fw_load_done = 1;\r\nbreak;\r\ncase 0x000D:\r\ncase 0x0001:\r\ncase 0x0002:\r\ncase 0x0003:\r\nneed_gpio = 1;\r\nbreak;\r\ndefault:\r\nif (dev->xc_fw_load_done)\r\nneed_gpio = 1;\r\nbreak;\r\n}\r\nif (need_gpio) {\r\ndprintk1(1,\r\n"GPIO WRITE: addr 0x%x, len %d, saddr 0x%x\n",\r\nmsg->addr, msg->len, saddr);\r\nreturn dev->cx231xx_gpio_i2c_write(dev,\r\nmsg->addr,\r\nmsg->buf,\r\nmsg->len);\r\n}\r\n}\r\nsaddr_len = 1;\r\nsize -= saddr_len;\r\nbuf_ptr = (u8 *) (msg->buf + 1);\r\ndo {\r\nreq_data.dev_addr = msg->addr;\r\nreq_data.direction = msg->flags;\r\nreq_data.saddr_len = saddr_len;\r\nreq_data.saddr_dat = msg->buf[0];\r\nreq_data.buf_size = size > 16 ? 16 : size;\r\nreq_data.p_buffer = (u8 *) (buf_ptr + loop * 16);\r\nbus->i2c_nostop = (size > 16) ? 1 : 0;\r\nbus->i2c_reserve = (loop == 0) ? 0 : 1;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\nloop++;\r\nif (size >= 16)\r\nsize -= 16;\r\nelse\r\nsize = 0;\r\n} while (size > 0);\r\nbus->i2c_nostop = 0;\r\nbus->i2c_reserve = 0;\r\n} else {\r\nreq_data.dev_addr = msg->addr;\r\nreq_data.direction = msg->flags;\r\nreq_data.saddr_len = 0;\r\nreq_data.saddr_dat = 0;\r\nreq_data.buf_size = msg->len;\r\nreq_data.p_buffer = msg->buf;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\n}\r\nreturn status < 0 ? status : 0;\r\n}\r\nstatic int cx231xx_i2c_recv_bytes(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg)\r\n{\r\nstruct cx231xx_i2c *bus = i2c_adap->algo_data;\r\nstruct cx231xx *dev = bus->dev;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nint status = 0;\r\nu16 saddr = 0;\r\nu8 need_gpio = 0;\r\nif (is_tuner(dev, bus, msg, TUNER_XC5000)) {\r\nif (msg->len == 2)\r\nsaddr = msg->buf[0] << 8 | msg->buf[1];\r\nelse if (msg->len == 1)\r\nsaddr = msg->buf[0];\r\nif (dev->xc_fw_load_done) {\r\nswitch (saddr) {\r\ncase 0x0009:\r\ndprintk1(1,\r\n"GPIO R E A D: Special case BUSY check \n");\r\nmsg->buf[0] = 0;\r\nif (msg->len == 2)\r\nmsg->buf[1] = 0;\r\nreturn 0;\r\ncase 0x0004:\r\nneed_gpio = 1;\r\nbreak;\r\n}\r\nif (need_gpio) {\r\ndprintk1(1,\r\n"GPIO R E A D: addr 0x%x, len %d, saddr 0x%x\n",\r\nmsg->addr, msg->len,\r\nmsg->buf[0] << 8 | msg->buf[1]);\r\nstatus =\r\ndev->cx231xx_gpio_i2c_write(dev, msg->addr,\r\nmsg->buf,\r\nmsg->len);\r\nstatus =\r\ndev->cx231xx_gpio_i2c_read(dev, msg->addr,\r\nmsg->buf,\r\nmsg->len);\r\nreturn status;\r\n}\r\n}\r\nreq_data.dev_addr = msg->addr;\r\nreq_data.direction = msg->flags;\r\nreq_data.saddr_len = msg->len;\r\nreq_data.saddr_dat = msg->buf[0] << 8 | msg->buf[1];\r\nreq_data.buf_size = msg->len;\r\nreq_data.p_buffer = msg->buf;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\n} else {\r\nreq_data.dev_addr = msg->addr;\r\nreq_data.direction = msg->flags;\r\nreq_data.saddr_len = 0;\r\nreq_data.saddr_dat = 0;\r\nreq_data.buf_size = msg->len;\r\nreq_data.p_buffer = msg->buf;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\n}\r\nreturn status < 0 ? status : 0;\r\n}\r\nstatic int cx231xx_i2c_recv_bytes_with_saddr(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg1,\r\nconst struct i2c_msg *msg2)\r\n{\r\nstruct cx231xx_i2c *bus = i2c_adap->algo_data;\r\nstruct cx231xx *dev = bus->dev;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nint status = 0;\r\nu16 saddr = 0;\r\nu8 need_gpio = 0;\r\nif (msg1->len == 2)\r\nsaddr = msg1->buf[0] << 8 | msg1->buf[1];\r\nelse if (msg1->len == 1)\r\nsaddr = msg1->buf[0];\r\nif (is_tuner(dev, bus, msg2, TUNER_XC5000)) {\r\nif ((msg2->len < 16)) {\r\ndprintk1(1,\r\n"i2c_read: addr 0x%x, len %d, saddr 0x%x, len %d\n",\r\nmsg2->addr, msg2->len, saddr, msg1->len);\r\nswitch (saddr) {\r\ncase 0x0008:\r\nneed_gpio = 1;\r\nbreak;\r\ncase 0x0004:\r\nneed_gpio = 1;\r\nbreak;\r\n}\r\nif (need_gpio) {\r\nstatus =\r\ndev->cx231xx_gpio_i2c_write(dev, msg1->addr,\r\nmsg1->buf,\r\nmsg1->len);\r\nstatus =\r\ndev->cx231xx_gpio_i2c_read(dev, msg2->addr,\r\nmsg2->buf,\r\nmsg2->len);\r\nreturn status;\r\n}\r\n}\r\n}\r\nreq_data.dev_addr = msg2->addr;\r\nreq_data.direction = msg2->flags;\r\nreq_data.saddr_len = msg1->len;\r\nreq_data.saddr_dat = saddr;\r\nreq_data.buf_size = msg2->len;\r\nreq_data.p_buffer = msg2->buf;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\nreturn status < 0 ? status : 0;\r\n}\r\nstatic int cx231xx_i2c_check_for_device(struct i2c_adapter *i2c_adap,\r\nconst struct i2c_msg *msg)\r\n{\r\nstruct cx231xx_i2c *bus = i2c_adap->algo_data;\r\nstruct cx231xx *dev = bus->dev;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nint status = 0;\r\nu8 buf[1];\r\nreq_data.dev_addr = msg->addr;\r\nreq_data.direction = I2C_M_RD;\r\nreq_data.saddr_len = 0;\r\nreq_data.saddr_dat = 0;\r\nreq_data.buf_size = 1;\r\nreq_data.p_buffer = buf;\r\nstatus = dev->cx231xx_send_usb_command(bus, &req_data);\r\nreturn status < 0 ? status : 0;\r\n}\r\nstatic int cx231xx_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct cx231xx_i2c *bus = i2c_adap->algo_data;\r\nstruct cx231xx *dev = bus->dev;\r\nint addr, rc, i, byte;\r\nif (num <= 0)\r\nreturn 0;\r\nmutex_lock(&dev->i2c_lock);\r\nfor (i = 0; i < num; i++) {\r\naddr = msgs[i].addr;\r\ndprintk2(2, "%s %s addr=0x%x len=%d:",\r\n(msgs[i].flags & I2C_M_RD) ? "read" : "write",\r\ni == num - 1 ? "stop" : "nonstop", addr, msgs[i].len);\r\nif (!msgs[i].len) {\r\nrc = cx231xx_i2c_check_for_device(i2c_adap, &msgs[i]);\r\nif (rc < 0) {\r\ndprintk2(2, " no device\n");\r\nmutex_unlock(&dev->i2c_lock);\r\nreturn rc;\r\n}\r\n} else if (msgs[i].flags & I2C_M_RD) {\r\nrc = cx231xx_i2c_recv_bytes(i2c_adap, &msgs[i]);\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\n}\r\n} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&\r\nmsgs[i].addr == msgs[i + 1].addr\r\n&& (msgs[i].len <= 2) && (bus->nr < 3)) {\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\nprintk(KERN_CONT "\n");\r\n}\r\ndprintk2(2, "plus %s %s addr=0x%x len=%d:",\r\n(msgs[i+1].flags & I2C_M_RD) ? "read" : "write",\r\ni+1 == num - 1 ? "stop" : "nonstop", addr, msgs[i+1].len);\r\nrc = cx231xx_i2c_recv_bytes_with_saddr(i2c_adap,\r\n&msgs[i],\r\n&msgs[i + 1]);\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i+1].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i+1].buf[byte]);\r\n}\r\ni++;\r\n} else {\r\nif (i2c_debug >= 2) {\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\n}\r\nrc = cx231xx_i2c_send_bytes(i2c_adap, &msgs[i]);\r\n}\r\nif (rc < 0)\r\ngoto err;\r\nif (i2c_debug >= 2)\r\nprintk(KERN_CONT "\n");\r\n}\r\nmutex_unlock(&dev->i2c_lock);\r\nreturn num;\r\nerr:\r\ndprintk2(2, " ERROR: %i\n", rc);\r\nmutex_unlock(&dev->i2c_lock);\r\nreturn rc;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\r\n}\r\nvoid cx231xx_do_i2c_scan(struct cx231xx *dev, int i2c_port)\r\n{\r\nunsigned char buf;\r\nint i, rc;\r\nstruct i2c_client client;\r\nif (!i2c_scan)\r\nreturn;\r\ndev->i2c_scan_running = true;\r\nmemset(&client, 0, sizeof(client));\r\nclient.adapter = cx231xx_get_i2c_adap(dev, i2c_port);\r\nfor (i = 0; i < 128; i++) {\r\nclient.addr = i;\r\nrc = i2c_master_recv(&client, &buf, 0);\r\nif (rc < 0)\r\ncontinue;\r\ndev_info(dev->dev,\r\n"i2c scan: found device @ port %d addr 0x%x [%s]\n",\r\ni2c_port,\r\ni << 1,\r\ni2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\ndev->i2c_scan_running = false;\r\n}\r\nint cx231xx_i2c_register(struct cx231xx_i2c *bus)\r\n{\r\nstruct cx231xx *dev = bus->dev;\r\nBUG_ON(!dev->cx231xx_send_usb_command);\r\nbus->i2c_adap = cx231xx_adap_template;\r\nbus->i2c_adap.dev.parent = dev->dev;\r\nsnprintf(bus->i2c_adap.name, sizeof(bus->i2c_adap.name), "%s-%d", bus->dev->name, bus->nr);\r\nbus->i2c_adap.algo_data = bus;\r\ni2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);\r\ni2c_add_adapter(&bus->i2c_adap);\r\nif (0 != bus->i2c_rc)\r\ndev_warn(dev->dev,\r\n"i2c bus %d register FAILED\n", bus->nr);\r\nreturn bus->i2c_rc;\r\n}\r\nint cx231xx_i2c_unregister(struct cx231xx_i2c *bus)\r\n{\r\ni2c_del_adapter(&bus->i2c_adap);\r\nreturn 0;\r\n}\r\nstatic int cx231xx_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan_id)\r\n{\r\nstruct cx231xx *dev = i2c_mux_priv(muxc);\r\nreturn cx231xx_enable_i2c_port_3(dev, chan_id);\r\n}\r\nint cx231xx_i2c_mux_create(struct cx231xx *dev)\r\n{\r\ndev->muxc = i2c_mux_alloc(&dev->i2c_bus[1].i2c_adap, dev->dev, 2, 0, 0,\r\ncx231xx_i2c_mux_select, NULL);\r\nif (!dev->muxc)\r\nreturn -ENOMEM;\r\ndev->muxc->priv = dev;\r\nreturn 0;\r\n}\r\nint cx231xx_i2c_mux_register(struct cx231xx *dev, int mux_no)\r\n{\r\nint rc;\r\nrc = i2c_mux_add_adapter(dev->muxc,\r\n0,\r\nmux_no ,\r\n0 );\r\nif (rc)\r\ndev_warn(dev->dev,\r\n"i2c mux %d register FAILED\n", mux_no);\r\nreturn rc;\r\n}\r\nvoid cx231xx_i2c_mux_unregister(struct cx231xx *dev)\r\n{\r\ni2c_mux_del_adapters(dev->muxc);\r\n}\r\nstruct i2c_adapter *cx231xx_get_i2c_adap(struct cx231xx *dev, int i2c_port)\r\n{\r\nswitch (i2c_port) {\r\ncase I2C_0:\r\nreturn &dev->i2c_bus[0].i2c_adap;\r\ncase I2C_1:\r\nreturn &dev->i2c_bus[1].i2c_adap;\r\ncase I2C_2:\r\nreturn &dev->i2c_bus[2].i2c_adap;\r\ncase I2C_1_MUX_1:\r\nreturn dev->muxc->adapter[0];\r\ncase I2C_1_MUX_3:\r\nreturn dev->muxc->adapter[1];\r\ndefault:\r\nBUG();\r\n}\r\n}
