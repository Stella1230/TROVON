static inline struct vc4_dpi_encoder *\r\nto_vc4_dpi_encoder(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct vc4_dpi_encoder, base.base);\r\n}\r\nstatic inline struct vc4_dpi_connector *\r\nto_vc4_dpi_connector(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct vc4_dpi_connector, base);\r\n}\r\nstatic void vc4_dpi_dump_regs(struct vc4_dpi *dpi)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dpi_regs); i++) {\r\nDRM_INFO("0x%04x (%s): 0x%08x\n",\r\ndpi_regs[i].reg, dpi_regs[i].name,\r\nDPI_READ(dpi_regs[i].reg));\r\n}\r\n}\r\nint vc4_dpi_debugfs_regs(struct seq_file *m, void *unused)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nstruct vc4_dpi *dpi = vc4->dpi;\r\nint i;\r\nif (!dpi)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(dpi_regs); i++) {\r\nseq_printf(m, "%s (0x%04x): 0x%08x\n",\r\ndpi_regs[i].name, dpi_regs[i].reg,\r\nDPI_READ(dpi_regs[i].reg));\r\n}\r\nreturn 0;\r\n}\r\nstatic enum drm_connector_status\r\nvc4_dpi_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct vc4_dpi_connector *vc4_connector =\r\nto_vc4_dpi_connector(connector);\r\nstruct vc4_dpi *dpi = vc4_connector->dpi;\r\nif (dpi->panel)\r\nreturn connector_status_connected;\r\nelse\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void vc4_dpi_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int vc4_dpi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct vc4_dpi_connector *vc4_connector =\r\nto_vc4_dpi_connector(connector);\r\nstruct vc4_dpi *dpi = vc4_connector->dpi;\r\nif (dpi->panel)\r\nreturn drm_panel_get_modes(dpi->panel);\r\nreturn 0;\r\n}\r\nstatic struct drm_connector *vc4_dpi_connector_init(struct drm_device *dev,\r\nstruct vc4_dpi *dpi)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct vc4_dpi_connector *dpi_connector;\r\ndpi_connector = devm_kzalloc(dev->dev, sizeof(*dpi_connector),\r\nGFP_KERNEL);\r\nif (!dpi_connector)\r\nreturn ERR_PTR(-ENOMEM);\r\nconnector = &dpi_connector->base;\r\ndpi_connector->encoder = dpi->encoder;\r\ndpi_connector->dpi = dpi;\r\ndrm_connector_init(dev, connector, &vc4_dpi_connector_funcs,\r\nDRM_MODE_CONNECTOR_DPI);\r\ndrm_connector_helper_add(connector, &vc4_dpi_connector_helper_funcs);\r\nconnector->polled = 0;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\ndrm_mode_connector_attach_encoder(connector, dpi->encoder);\r\nreturn connector;\r\n}\r\nstatic void vc4_dpi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct vc4_dpi_encoder *vc4_encoder = to_vc4_dpi_encoder(encoder);\r\nstruct vc4_dpi *dpi = vc4_encoder->dpi;\r\ndrm_panel_disable(dpi->panel);\r\nclk_disable_unprepare(dpi->pixel_clock);\r\ndrm_panel_unprepare(dpi->panel);\r\n}\r\nstatic void vc4_dpi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_display_mode *mode = &encoder->crtc->mode;\r\nstruct vc4_dpi_encoder *vc4_encoder = to_vc4_dpi_encoder(encoder);\r\nstruct vc4_dpi *dpi = vc4_encoder->dpi;\r\nu32 dpi_c = DPI_ENABLE | DPI_OUTPUT_ENABLE_MODE;\r\nint ret;\r\nret = drm_panel_prepare(dpi->panel);\r\nif (ret) {\r\nDRM_ERROR("Panel failed to prepare\n");\r\nreturn;\r\n}\r\nif (dpi->connector->display_info.num_bus_formats) {\r\nu32 bus_format = dpi->connector->display_info.bus_formats[0];\r\nswitch (bus_format) {\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\ndpi_c |= VC4_SET_FIELD(DPI_FORMAT_24BIT_888_RGB,\r\nDPI_FORMAT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_BGR888_1X24:\r\ndpi_c |= VC4_SET_FIELD(DPI_FORMAT_24BIT_888_RGB,\r\nDPI_FORMAT);\r\ndpi_c |= VC4_SET_FIELD(DPI_ORDER_BGR, DPI_ORDER);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\r\ndpi_c |= VC4_SET_FIELD(DPI_FORMAT_18BIT_666_RGB_2,\r\nDPI_FORMAT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB666_1X18:\r\ndpi_c |= VC4_SET_FIELD(DPI_FORMAT_18BIT_666_RGB_1,\r\nDPI_FORMAT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB565_1X16:\r\ndpi_c |= VC4_SET_FIELD(DPI_FORMAT_16BIT_565_RGB_3,\r\nDPI_FORMAT);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown media bus format %d\n", bus_format);\r\nbreak;\r\n}\r\n}\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\ndpi_c |= DPI_HSYNC_INVERT;\r\nelse if (!(mode->flags & DRM_MODE_FLAG_PHSYNC))\r\ndpi_c |= DPI_HSYNC_DISABLE;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\ndpi_c |= DPI_VSYNC_INVERT;\r\nelse if (!(mode->flags & DRM_MODE_FLAG_PVSYNC))\r\ndpi_c |= DPI_VSYNC_DISABLE;\r\nDPI_WRITE(DPI_C, dpi_c);\r\nret = clk_set_rate(dpi->pixel_clock, mode->clock * 1000);\r\nif (ret)\r\nDRM_ERROR("Failed to set clock rate: %d\n", ret);\r\nret = clk_prepare_enable(dpi->pixel_clock);\r\nif (ret)\r\nDRM_ERROR("Failed to set clock rate: %d\n", ret);\r\nret = drm_panel_enable(dpi->panel);\r\nif (ret) {\r\nDRM_ERROR("Panel failed to enable\n");\r\ndrm_panel_unprepare(dpi->panel);\r\nreturn;\r\n}\r\n}\r\nstatic bool vc4_dpi_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nif (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct drm_panel *vc4_dpi_get_panel(struct device *dev)\r\n{\r\nstruct device_node *endpoint, *panel_node;\r\nstruct device_node *np = dev->of_node;\r\nstruct drm_panel *panel;\r\nendpoint = of_graph_get_next_endpoint(np, NULL);\r\nif (!endpoint) {\r\ndev_err(dev, "no endpoint to fetch DPI panel\n");\r\nreturn NULL;\r\n}\r\npanel_node = of_graph_get_remote_port_parent(endpoint);\r\nof_node_put(endpoint);\r\nif (!panel_node) {\r\ndev_err(dev, "no valid panel node\n");\r\nreturn NULL;\r\n}\r\npanel = of_drm_find_panel(panel_node);\r\nof_node_put(panel_node);\r\nreturn panel;\r\n}\r\nstatic int vc4_dpi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\nstruct vc4_dpi *dpi;\r\nstruct vc4_dpi_encoder *vc4_dpi_encoder;\r\nint ret;\r\ndpi = devm_kzalloc(dev, sizeof(*dpi), GFP_KERNEL);\r\nif (!dpi)\r\nreturn -ENOMEM;\r\nvc4_dpi_encoder = devm_kzalloc(dev, sizeof(*vc4_dpi_encoder),\r\nGFP_KERNEL);\r\nif (!vc4_dpi_encoder)\r\nreturn -ENOMEM;\r\nvc4_dpi_encoder->base.type = VC4_ENCODER_TYPE_DPI;\r\nvc4_dpi_encoder->dpi = dpi;\r\ndpi->encoder = &vc4_dpi_encoder->base.base;\r\ndpi->pdev = pdev;\r\ndpi->regs = vc4_ioremap_regs(pdev, 0);\r\nif (IS_ERR(dpi->regs))\r\nreturn PTR_ERR(dpi->regs);\r\nvc4_dpi_dump_regs(dpi);\r\nif (DPI_READ(DPI_ID) != DPI_ID_VALUE) {\r\ndev_err(dev, "Port returned 0x%08x for ID instead of 0x%08x\n",\r\nDPI_READ(DPI_ID), DPI_ID_VALUE);\r\nreturn -ENODEV;\r\n}\r\ndpi->core_clock = devm_clk_get(dev, "core");\r\nif (IS_ERR(dpi->core_clock)) {\r\nret = PTR_ERR(dpi->core_clock);\r\nif (ret != -EPROBE_DEFER)\r\nDRM_ERROR("Failed to get core clock: %d\n", ret);\r\nreturn ret;\r\n}\r\ndpi->pixel_clock = devm_clk_get(dev, "pixel");\r\nif (IS_ERR(dpi->pixel_clock)) {\r\nret = PTR_ERR(dpi->pixel_clock);\r\nif (ret != -EPROBE_DEFER)\r\nDRM_ERROR("Failed to get pixel clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(dpi->core_clock);\r\nif (ret)\r\nDRM_ERROR("Failed to turn on core clock: %d\n", ret);\r\ndpi->panel = vc4_dpi_get_panel(dev);\r\ndrm_encoder_init(drm, dpi->encoder, &vc4_dpi_encoder_funcs,\r\nDRM_MODE_ENCODER_DPI, NULL);\r\ndrm_encoder_helper_add(dpi->encoder, &vc4_dpi_encoder_helper_funcs);\r\ndpi->connector = vc4_dpi_connector_init(drm, dpi);\r\nif (IS_ERR(dpi->connector)) {\r\nret = PTR_ERR(dpi->connector);\r\ngoto err_destroy_encoder;\r\n}\r\nif (dpi->panel)\r\ndrm_panel_attach(dpi->panel, dpi->connector);\r\ndev_set_drvdata(dev, dpi);\r\nvc4->dpi = dpi;\r\nreturn 0;\r\nerr_destroy_encoder:\r\ndrm_encoder_cleanup(dpi->encoder);\r\nclk_disable_unprepare(dpi->core_clock);\r\nreturn ret;\r\n}\r\nstatic void vc4_dpi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(master);\r\nstruct vc4_dev *vc4 = to_vc4_dev(drm);\r\nstruct vc4_dpi *dpi = dev_get_drvdata(dev);\r\nif (dpi->panel)\r\ndrm_panel_detach(dpi->panel);\r\nvc4_dpi_connector_destroy(dpi->connector);\r\ndrm_encoder_cleanup(dpi->encoder);\r\nclk_disable_unprepare(dpi->core_clock);\r\nvc4->dpi = NULL;\r\n}\r\nstatic int vc4_dpi_dev_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &vc4_dpi_ops);\r\n}\r\nstatic int vc4_dpi_dev_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &vc4_dpi_ops);\r\nreturn 0;\r\n}
