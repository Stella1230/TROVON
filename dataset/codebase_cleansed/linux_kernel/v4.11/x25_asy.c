static struct x25_asy *x25_asy_alloc(void)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct x25_asy *sl;\r\nint i;\r\nif (x25_asy_devs == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < x25_asy_maxdev; i++) {\r\ndev = x25_asy_devs[i];\r\nif (dev == NULL)\r\nbreak;\r\nsl = netdev_priv(dev);\r\nif (!test_and_set_bit(SLF_INUSE, &sl->flags))\r\nreturn sl;\r\n}\r\nif (i >= x25_asy_maxdev)\r\nreturn NULL;\r\nif (!dev) {\r\nchar name[IFNAMSIZ];\r\nsprintf(name, "x25asy%d", i);\r\ndev = alloc_netdev(sizeof(struct x25_asy), name,\r\nNET_NAME_UNKNOWN, x25_asy_setup);\r\nif (!dev)\r\nreturn NULL;\r\nsl = netdev_priv(dev);\r\ndev->base_addr = i;\r\nif (register_netdev(dev) == 0) {\r\nset_bit(SLF_INUSE, &sl->flags);\r\nx25_asy_devs[i] = dev;\r\nreturn sl;\r\n} else {\r\npr_warn("%s(): register_netdev() failure\n", __func__);\r\nfree_netdev(dev);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void x25_asy_free(struct x25_asy *sl)\r\n{\r\nkfree(sl->rbuff);\r\nsl->rbuff = NULL;\r\nkfree(sl->xbuff);\r\nsl->xbuff = NULL;\r\nif (!test_and_clear_bit(SLF_INUSE, &sl->flags))\r\nnetdev_err(sl->dev, "x25_asy_free for already free unit\n");\r\n}\r\nstatic int x25_asy_change_mtu(struct net_device *dev, int newmtu)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nunsigned char *xbuff, *rbuff;\r\nint len;\r\nlen = 2 * newmtu;\r\nxbuff = kmalloc(len + 4, GFP_ATOMIC);\r\nrbuff = kmalloc(len + 4, GFP_ATOMIC);\r\nif (xbuff == NULL || rbuff == NULL) {\r\nkfree(xbuff);\r\nkfree(rbuff);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_bh(&sl->lock);\r\nxbuff = xchg(&sl->xbuff, xbuff);\r\nif (sl->xleft) {\r\nif (sl->xleft <= len) {\r\nmemcpy(sl->xbuff, sl->xhead, sl->xleft);\r\n} else {\r\nsl->xleft = 0;\r\ndev->stats.tx_dropped++;\r\n}\r\n}\r\nsl->xhead = sl->xbuff;\r\nrbuff = xchg(&sl->rbuff, rbuff);\r\nif (sl->rcount) {\r\nif (sl->rcount <= len) {\r\nmemcpy(sl->rbuff, rbuff, sl->rcount);\r\n} else {\r\nsl->rcount = 0;\r\ndev->stats.rx_over_errors++;\r\nset_bit(SLF_ERROR, &sl->flags);\r\n}\r\n}\r\ndev->mtu = newmtu;\r\nsl->buffsize = len;\r\nspin_unlock_bh(&sl->lock);\r\nkfree(xbuff);\r\nkfree(rbuff);\r\nreturn 0;\r\n}\r\nstatic inline void x25_asy_lock(struct x25_asy *sl)\r\n{\r\nnetif_stop_queue(sl->dev);\r\n}\r\nstatic inline void x25_asy_unlock(struct x25_asy *sl)\r\n{\r\nnetif_wake_queue(sl->dev);\r\n}\r\nstatic void x25_asy_bump(struct x25_asy *sl)\r\n{\r\nstruct net_device *dev = sl->dev;\r\nstruct sk_buff *skb;\r\nint count;\r\nint err;\r\ncount = sl->rcount;\r\ndev->stats.rx_bytes += count;\r\nskb = dev_alloc_skb(count+1);\r\nif (skb == NULL) {\r\nnetdev_warn(sl->dev, "memory squeeze, dropping packet\n");\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_push(skb, 1);\r\nmemcpy(skb_put(skb, count), sl->rbuff, count);\r\nskb->protocol = x25_type_trans(skb, sl->dev);\r\nerr = lapb_data_received(skb->dev, skb);\r\nif (err != LAPB_OK) {\r\nkfree_skb(skb);\r\nprintk(KERN_DEBUG "x25_asy: data received err - %d\n", err);\r\n} else {\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\n}\r\nstatic void x25_asy_encaps(struct x25_asy *sl, unsigned char *icp, int len)\r\n{\r\nunsigned char *p;\r\nint actual, count, mtu = sl->dev->mtu;\r\nif (len > mtu) {\r\nlen = mtu;\r\nprintk(KERN_DEBUG "%s: truncating oversized transmit packet!\n",\r\nsl->dev->name);\r\nsl->dev->stats.tx_dropped++;\r\nx25_asy_unlock(sl);\r\nreturn;\r\n}\r\np = icp;\r\ncount = x25_asy_esc(p, sl->xbuff, len);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nactual = sl->tty->ops->write(sl->tty, sl->xbuff, count);\r\nsl->xleft = count - actual;\r\nsl->xhead = sl->xbuff + actual;\r\nclear_bit(SLF_OUTWAIT, &sl->flags);\r\n}\r\nstatic void x25_asy_write_wakeup(struct tty_struct *tty)\r\n{\r\nint actual;\r\nstruct x25_asy *sl = tty->disc_data;\r\nif (!sl || sl->magic != X25_ASY_MAGIC || !netif_running(sl->dev))\r\nreturn;\r\nif (sl->xleft <= 0) {\r\nsl->dev->stats.tx_packets++;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nx25_asy_unlock(sl);\r\nreturn;\r\n}\r\nactual = tty->ops->write(tty, sl->xhead, sl->xleft);\r\nsl->xleft -= actual;\r\nsl->xhead += actual;\r\n}\r\nstatic void x25_asy_timeout(struct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nspin_lock(&sl->lock);\r\nif (netif_queue_stopped(dev)) {\r\nnetdev_warn(dev, "transmit timed out, %s?\n",\r\n(tty_chars_in_buffer(sl->tty) || sl->xleft) ?\r\n"bad line quality" : "driver error");\r\nsl->xleft = 0;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nx25_asy_unlock(sl);\r\n}\r\nspin_unlock(&sl->lock);\r\n}\r\nstatic netdev_tx_t x25_asy_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nint err;\r\nif (!netif_running(sl->dev)) {\r\nnetdev_err(dev, "xmit call when iface is down\n");\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nswitch (skb->data[0]) {\r\ncase X25_IFACE_DATA:\r\nbreak;\r\ncase X25_IFACE_CONNECT:\r\nerr = lapb_connect_request(dev);\r\nif (err != LAPB_OK)\r\nnetdev_err(dev, "lapb_connect_request error: %d\n",\r\nerr);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\ncase X25_IFACE_DISCONNECT:\r\nerr = lapb_disconnect_request(dev);\r\nif (err != LAPB_OK)\r\nnetdev_err(dev, "lapb_disconnect_request error: %d\n",\r\nerr);\r\ndefault:\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nskb_pull(skb, 1);\r\nerr = lapb_data_request(dev, skb);\r\nif (err != LAPB_OK) {\r\nnetdev_err(dev, "lapb_data_request error: %d\n", err);\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int x25_asy_data_indication(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nreturn netif_rx(skb);\r\n}\r\nstatic void x25_asy_data_transmit(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nspin_lock(&sl->lock);\r\nif (netif_queue_stopped(sl->dev) || sl->tty == NULL) {\r\nspin_unlock(&sl->lock);\r\nnetdev_err(dev, "tbusy drop\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (skb != NULL) {\r\nx25_asy_lock(sl);\r\ndev->stats.tx_bytes += skb->len;\r\nx25_asy_encaps(sl, skb->data, skb->len);\r\ndev_kfree_skb(skb);\r\n}\r\nspin_unlock(&sl->lock);\r\n}\r\nstatic void x25_asy_connected(struct net_device *dev, int reason)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\nskb = dev_alloc_skb(1);\r\nif (skb == NULL) {\r\nnetdev_err(dev, "out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_CONNECT;\r\nskb->protocol = x25_type_trans(skb, sl->dev);\r\nnetif_rx(skb);\r\n}\r\nstatic void x25_asy_disconnected(struct net_device *dev, int reason)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\nskb = dev_alloc_skb(1);\r\nif (skb == NULL) {\r\nnetdev_err(dev, "out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_DISCONNECT;\r\nskb->protocol = x25_type_trans(skb, sl->dev);\r\nnetif_rx(skb);\r\n}\r\nstatic int x25_asy_open(struct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nunsigned long len;\r\nint err;\r\nif (sl->tty == NULL)\r\nreturn -ENODEV;\r\nlen = dev->mtu * 2;\r\nsl->rbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (sl->rbuff == NULL)\r\ngoto norbuff;\r\nsl->xbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (sl->xbuff == NULL)\r\ngoto noxbuff;\r\nsl->buffsize = len;\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nsl->flags &= (1 << SLF_INUSE);\r\nnetif_start_queue(dev);\r\nerr = lapb_register(dev, &x25_asy_callbacks);\r\nif (err == LAPB_OK)\r\nreturn 0;\r\nkfree(sl->xbuff);\r\nnoxbuff:\r\nkfree(sl->rbuff);\r\nnorbuff:\r\nreturn -ENOMEM;\r\n}\r\nstatic int x25_asy_close(struct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nspin_lock(&sl->lock);\r\nif (sl->tty)\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nnetif_stop_queue(dev);\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nspin_unlock(&sl->lock);\r\nreturn 0;\r\n}\r\nstatic void x25_asy_receive_buf(struct tty_struct *tty,\r\nconst unsigned char *cp, char *fp, int count)\r\n{\r\nstruct x25_asy *sl = tty->disc_data;\r\nif (!sl || sl->magic != X25_ASY_MAGIC || !netif_running(sl->dev))\r\nreturn;\r\nwhile (count--) {\r\nif (fp && *fp++) {\r\nif (!test_and_set_bit(SLF_ERROR, &sl->flags))\r\nsl->dev->stats.rx_errors++;\r\ncp++;\r\ncontinue;\r\n}\r\nx25_asy_unesc(sl, *cp++);\r\n}\r\n}\r\nstatic int x25_asy_open_tty(struct tty_struct *tty)\r\n{\r\nstruct x25_asy *sl;\r\nint err;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nsl = x25_asy_alloc();\r\nif (sl == NULL)\r\nreturn -ENFILE;\r\nsl->tty = tty;\r\ntty->disc_data = sl;\r\ntty->receive_room = 65536;\r\ntty_driver_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nsl->dev->type = ARPHRD_X25;\r\nerr = x25_asy_open(sl->dev);\r\nif (err) {\r\nx25_asy_free(sl);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void x25_asy_close_tty(struct tty_struct *tty)\r\n{\r\nstruct x25_asy *sl = tty->disc_data;\r\nint err;\r\nif (!sl || sl->magic != X25_ASY_MAGIC)\r\nreturn;\r\nrtnl_lock();\r\nif (sl->dev->flags & IFF_UP)\r\ndev_close(sl->dev);\r\nrtnl_unlock();\r\nerr = lapb_unregister(sl->dev);\r\nif (err != LAPB_OK)\r\npr_err("x25_asy_close: lapb_unregister error: %d\n",\r\nerr);\r\ntty->disc_data = NULL;\r\nsl->tty = NULL;\r\nx25_asy_free(sl);\r\n}\r\nstatic int x25_asy_esc(unsigned char *s, unsigned char *d, int len)\r\n{\r\nunsigned char *ptr = d;\r\nunsigned char c;\r\n*ptr++ = X25_END;\r\nwhile (len-- > 0) {\r\nswitch (c = *s++) {\r\ncase X25_END:\r\n*ptr++ = X25_ESC;\r\n*ptr++ = X25_ESCAPE(X25_END);\r\nbreak;\r\ncase X25_ESC:\r\n*ptr++ = X25_ESC;\r\n*ptr++ = X25_ESCAPE(X25_ESC);\r\nbreak;\r\ndefault:\r\n*ptr++ = c;\r\nbreak;\r\n}\r\n}\r\n*ptr++ = X25_END;\r\nreturn ptr - d;\r\n}\r\nstatic void x25_asy_unesc(struct x25_asy *sl, unsigned char s)\r\n{\r\nswitch (s) {\r\ncase X25_END:\r\nif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\r\nsl->rcount > 2)\r\nx25_asy_bump(sl);\r\nclear_bit(SLF_ESCAPE, &sl->flags);\r\nsl->rcount = 0;\r\nreturn;\r\ncase X25_ESC:\r\nset_bit(SLF_ESCAPE, &sl->flags);\r\nreturn;\r\ncase X25_ESCAPE(X25_ESC):\r\ncase X25_ESCAPE(X25_END):\r\nif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\r\ns = X25_UNESCAPE(s);\r\nbreak;\r\n}\r\nif (!test_bit(SLF_ERROR, &sl->flags)) {\r\nif (sl->rcount < sl->buffsize) {\r\nsl->rbuff[sl->rcount++] = s;\r\nreturn;\r\n}\r\nsl->dev->stats.rx_over_errors++;\r\nset_bit(SLF_ERROR, &sl->flags);\r\n}\r\n}\r\nstatic int x25_asy_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct x25_asy *sl = tty->disc_data;\r\nif (!sl || sl->magic != X25_ASY_MAGIC)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\nif (copy_to_user((void __user *)arg, sl->dev->name,\r\nstrlen(sl->dev->name) + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCSIFHWADDR:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn tty_mode_ioctl(tty, file, cmd, arg);\r\n}\r\n}\r\nstatic long x25_asy_compat_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ncase SIOCSIFHWADDR:\r\nreturn x25_asy_ioctl(tty, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int x25_asy_open_dev(struct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nif (sl->tty == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void x25_asy_setup(struct net_device *dev)\r\n{\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nsl->magic = X25_ASY_MAGIC;\r\nsl->dev = dev;\r\nspin_lock_init(&sl->lock);\r\nset_bit(SLF_INUSE, &sl->flags);\r\ndev->mtu = SL_MTU;\r\ndev->min_mtu = 0;\r\ndev->max_mtu = 65534;\r\ndev->netdev_ops = &x25_asy_netdev_ops;\r\ndev->watchdog_timeo = HZ*20;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->type = ARPHRD_X25;\r\ndev->tx_queue_len = 10;\r\ndev->flags = IFF_NOARP;\r\n}\r\nstatic int __init init_x25_asy(void)\r\n{\r\nif (x25_asy_maxdev < 4)\r\nx25_asy_maxdev = 4;\r\npr_info("X.25 async: version 0.00 ALPHA (dynamic channels, max=%d)\n",\r\nx25_asy_maxdev);\r\nx25_asy_devs = kcalloc(x25_asy_maxdev, sizeof(struct net_device *),\r\nGFP_KERNEL);\r\nif (!x25_asy_devs)\r\nreturn -ENOMEM;\r\nreturn tty_register_ldisc(N_X25, &x25_ldisc);\r\n}\r\nstatic void __exit exit_x25_asy(void)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nfor (i = 0; i < x25_asy_maxdev; i++) {\r\ndev = x25_asy_devs[i];\r\nif (dev) {\r\nstruct x25_asy *sl = netdev_priv(dev);\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty)\r\ntty_hangup(sl->tty);\r\nspin_unlock_bh(&sl->lock);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\nkfree(x25_asy_devs);\r\ntty_unregister_ldisc(N_X25);\r\n}
