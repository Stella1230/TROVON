static void do_hcall(struct lg_cpu *cpu, struct hcall_args *args)\r\n{\r\nswitch (args->arg0) {\r\ncase LHCALL_FLUSH_ASYNC:\r\nbreak;\r\ncase LHCALL_SEND_INTERRUPTS:\r\nbreak;\r\ncase LHCALL_LGUEST_INIT:\r\nkill_guest(cpu, "already have lguest_data");\r\nbreak;\r\ncase LHCALL_SHUTDOWN: {\r\nchar msg[128];\r\n__lgread(cpu, msg, args->arg1, sizeof(msg));\r\nmsg[sizeof(msg)-1] = '\0';\r\nkill_guest(cpu, "CRASH: %s", msg);\r\nif (args->arg2 == LGUEST_SHUTDOWN_RESTART)\r\ncpu->lg->dead = ERR_PTR(-ERESTART);\r\nbreak;\r\n}\r\ncase LHCALL_FLUSH_TLB:\r\nif (args->arg1)\r\nguest_pagetable_clear_all(cpu);\r\nelse\r\nguest_pagetable_flush_user(cpu);\r\nbreak;\r\ncase LHCALL_NEW_PGTABLE:\r\nguest_new_pagetable(cpu, args->arg1);\r\nbreak;\r\ncase LHCALL_SET_STACK:\r\nguest_set_stack(cpu, args->arg1, args->arg2, args->arg3);\r\nbreak;\r\ncase LHCALL_SET_PTE:\r\n#ifdef CONFIG_X86_PAE\r\nguest_set_pte(cpu, args->arg1, args->arg2,\r\n__pte(args->arg3 | (u64)args->arg4 << 32));\r\n#else\r\nguest_set_pte(cpu, args->arg1, args->arg2, __pte(args->arg3));\r\n#endif\r\nbreak;\r\ncase LHCALL_SET_PGD:\r\nguest_set_pgd(cpu->lg, args->arg1, args->arg2);\r\nbreak;\r\n#ifdef CONFIG_X86_PAE\r\ncase LHCALL_SET_PMD:\r\nguest_set_pmd(cpu->lg, args->arg1, args->arg2);\r\nbreak;\r\n#endif\r\ncase LHCALL_SET_CLOCKEVENT:\r\nguest_set_clockevent(cpu, args->arg1);\r\nbreak;\r\ncase LHCALL_HALT:\r\ncpu->halted = 1;\r\nbreak;\r\ndefault:\r\nif (lguest_arch_do_hcall(cpu, args))\r\nkill_guest(cpu, "Bad hypercall %li\n", args->arg0);\r\n}\r\n}\r\nstatic void do_async_hcalls(struct lg_cpu *cpu)\r\n{\r\nunsigned int i;\r\nu8 st[LHCALL_RING_SIZE];\r\nif (copy_from_user(&st, &cpu->lg->lguest_data->hcall_status, sizeof(st)))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(st); i++) {\r\nstruct hcall_args args;\r\nunsigned int n = cpu->next_hcall;\r\nif (st[n] == 0xFF)\r\nbreak;\r\nif (++cpu->next_hcall == LHCALL_RING_SIZE)\r\ncpu->next_hcall = 0;\r\nif (copy_from_user(&args, &cpu->lg->lguest_data->hcalls[n],\r\nsizeof(struct hcall_args))) {\r\nkill_guest(cpu, "Fetching async hypercalls");\r\nbreak;\r\n}\r\ndo_hcall(cpu, &args);\r\nif (put_user(0xFF, &cpu->lg->lguest_data->hcall_status[n])) {\r\nkill_guest(cpu, "Writing result for async hypercall");\r\nbreak;\r\n}\r\nif (cpu->pending.trap)\r\nbreak;\r\n}\r\n}\r\nstatic void initialize(struct lg_cpu *cpu)\r\n{\r\nif (cpu->hcall->arg0 != LHCALL_LGUEST_INIT) {\r\nkill_guest(cpu, "hypercall %li before INIT", cpu->hcall->arg0);\r\nreturn;\r\n}\r\nif (lguest_arch_init_hypercalls(cpu))\r\nkill_guest(cpu, "bad guest page %p", cpu->lg->lguest_data);\r\nif (get_user(cpu->lg->noirq_iret, &cpu->lg->lguest_data->noirq_iret))\r\nkill_guest(cpu, "bad guest page %p", cpu->lg->lguest_data);\r\nwrite_timestamp(cpu);\r\npage_table_guest_data_init(cpu);\r\nguest_pagetable_clear_all(cpu);\r\n}\r\nvoid do_hypercalls(struct lg_cpu *cpu)\r\n{\r\nif (unlikely(!cpu->lg->lguest_data)) {\r\ninitialize(cpu);\r\ncpu->hcall = NULL;\r\nreturn;\r\n}\r\ndo_async_hcalls(cpu);\r\nif (!cpu->pending.trap) {\r\ndo_hcall(cpu, cpu->hcall);\r\ncpu->hcall = NULL;\r\n}\r\n}\r\nvoid write_timestamp(struct lg_cpu *cpu)\r\n{\r\nstruct timespec now;\r\nktime_get_real_ts(&now);\r\nif (copy_to_user(&cpu->lg->lguest_data->time,\r\n&now, sizeof(struct timespec)))\r\nkill_guest(cpu, "Writing timestamp");\r\n}
