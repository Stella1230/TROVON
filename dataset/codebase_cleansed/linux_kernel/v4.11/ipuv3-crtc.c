static inline struct ipu_crtc *to_ipu_crtc(struct drm_crtc *crtc)\r\n{\r\nreturn container_of(crtc, struct ipu_crtc, base);\r\n}\r\nstatic void ipu_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nipu_dc_enable(ipu);\r\nipu_dc_enable_channel(ipu_crtc->dc);\r\nipu_di_enable(ipu_crtc->di);\r\n}\r\nstatic void ipu_crtc_atomic_disable(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nipu_dc_disable_channel(ipu_crtc->dc);\r\nipu_di_disable(ipu_crtc->di);\r\ndrm_atomic_helper_disable_planes_on_crtc(old_crtc_state, false);\r\nipu_dc_disable(ipu);\r\nspin_lock_irq(&crtc->dev->event_lock);\r\nif (crtc->state->event) {\r\ndrm_crtc_send_vblank_event(crtc, crtc->state->event);\r\ncrtc->state->event = NULL;\r\n}\r\nspin_unlock_irq(&crtc->dev->event_lock);\r\ndrm_crtc_vblank_off(crtc);\r\n}\r\nstatic void imx_drm_crtc_reset(struct drm_crtc *crtc)\r\n{\r\nstruct imx_crtc_state *state;\r\nif (crtc->state) {\r\nif (crtc->state->mode_blob)\r\ndrm_property_unreference_blob(crtc->state->mode_blob);\r\nstate = to_imx_crtc_state(crtc->state);\r\nmemset(state, 0, sizeof(*state));\r\n} else {\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn;\r\ncrtc->state = &state->base;\r\n}\r\nstate->base.crtc = crtc;\r\n}\r\nstatic struct drm_crtc_state *imx_drm_crtc_duplicate_state(struct drm_crtc *crtc)\r\n{\r\nstruct imx_crtc_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\n__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\r\nWARN_ON(state->base.crtc != crtc);\r\nstate->base.crtc = crtc;\r\nreturn &state->base;\r\n}\r\nstatic void imx_drm_crtc_destroy_state(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\n__drm_atomic_helper_crtc_destroy_state(state);\r\nkfree(to_imx_crtc_state(state));\r\n}\r\nstatic void imx_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nimx_drm_remove_crtc(to_ipu_crtc(crtc)->imx_crtc);\r\n}\r\nstatic irqreturn_t ipu_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_id;\r\ndrm_crtc_handle_vblank(&ipu_crtc->base);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct videomode vm;\r\nint ret;\r\ndrm_display_mode_to_videomode(adjusted_mode, &vm);\r\nret = ipu_di_adjust_videomode(ipu_crtc->di, &vm);\r\nif (ret)\r\nreturn false;\r\nif ((vm.vsync_len == 0) || (vm.hsync_len == 0))\r\nreturn false;\r\ndrm_display_mode_from_videomode(&vm, adjusted_mode);\r\nreturn true;\r\n}\r\nstatic int ipu_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nu32 primary_plane_mask = 1 << drm_plane_index(crtc->primary);\r\nif (state->active && (primary_plane_mask & state->plane_mask) == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ipu_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\ndrm_crtc_vblank_on(crtc);\r\nspin_lock_irq(&crtc->dev->event_lock);\r\nif (crtc->state->event) {\r\nWARN_ON(drm_crtc_vblank_get(crtc));\r\ndrm_crtc_arm_vblank_event(crtc, crtc->state->event);\r\ncrtc->state->event = NULL;\r\n}\r\nspin_unlock_irq(&crtc->dev->event_lock);\r\n}\r\nstatic void ipu_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_encoder *encoder;\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\r\nstruct imx_crtc_state *imx_crtc_state = to_imx_crtc_state(crtc->state);\r\nstruct ipu_di_signal_cfg sig_cfg = {};\r\nunsigned long encoder_types = 0;\r\ndev_dbg(ipu_crtc->dev, "%s: mode->hdisplay: %d\n", __func__,\r\nmode->hdisplay);\r\ndev_dbg(ipu_crtc->dev, "%s: mode->vdisplay: %d\n", __func__,\r\nmode->vdisplay);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc == crtc)\r\nencoder_types |= BIT(encoder->encoder_type);\r\n}\r\ndev_dbg(ipu_crtc->dev, "%s: attached to encoder types 0x%lx\n",\r\n__func__, encoder_types);\r\nif (encoder_types & (BIT(DRM_MODE_ENCODER_DAC) |\r\nBIT(DRM_MODE_ENCODER_LVDS)))\r\nsig_cfg.clkflags = IPU_DI_CLKMODE_SYNC | IPU_DI_CLKMODE_EXT;\r\nelse if (encoder_types & BIT(DRM_MODE_ENCODER_TVDAC))\r\nsig_cfg.clkflags = IPU_DI_CLKMODE_EXT;\r\nelse\r\nsig_cfg.clkflags = 0;\r\nsig_cfg.enable_pol = !(imx_crtc_state->bus_flags & DRM_BUS_FLAG_DE_LOW);\r\nsig_cfg.clk_pol = !!(imx_crtc_state->bus_flags &\r\nDRM_BUS_FLAG_PIXDATA_POSEDGE);\r\nsig_cfg.bus_format = imx_crtc_state->bus_format;\r\nsig_cfg.v_to_h_sync = 0;\r\nsig_cfg.hsync_pin = imx_crtc_state->di_hsync_pin;\r\nsig_cfg.vsync_pin = imx_crtc_state->di_vsync_pin;\r\ndrm_display_mode_to_videomode(mode, &sig_cfg.mode);\r\nipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di,\r\nmode->flags & DRM_MODE_FLAG_INTERLACE,\r\nimx_crtc_state->bus_format, mode->hdisplay);\r\nipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);\r\n}\r\nstatic int ipu_enable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nenable_irq(ipu_crtc->irq);\r\nreturn 0;\r\n}\r\nstatic void ipu_disable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\ndisable_irq_nosync(ipu_crtc->irq);\r\n}\r\nstatic void ipu_put_resources(struct ipu_crtc *ipu_crtc)\r\n{\r\nif (!IS_ERR_OR_NULL(ipu_crtc->dc))\r\nipu_dc_put(ipu_crtc->dc);\r\nif (!IS_ERR_OR_NULL(ipu_crtc->di))\r\nipu_di_put(ipu_crtc->di);\r\n}\r\nstatic int ipu_get_resources(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint ret;\r\nipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);\r\nif (IS_ERR(ipu_crtc->dc)) {\r\nret = PTR_ERR(ipu_crtc->dc);\r\ngoto err_out;\r\n}\r\nipu_crtc->di = ipu_di_get(ipu, pdata->di);\r\nif (IS_ERR(ipu_crtc->di)) {\r\nret = PTR_ERR(ipu_crtc->di);\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic int ipu_crtc_init(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata, struct drm_device *drm)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint dp = -EINVAL;\r\nint ret;\r\nret = ipu_get_resources(ipu_crtc, pdata);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting resources failed with %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (pdata->dp >= 0)\r\ndp = IPU_DP_FLOW_SYNC_BG;\r\nipu_crtc->plane[0] = ipu_plane_init(drm, ipu, pdata->dma[0], dp, 0,\r\nDRM_PLANE_TYPE_PRIMARY);\r\nif (IS_ERR(ipu_crtc->plane[0])) {\r\nret = PTR_ERR(ipu_crtc->plane[0]);\r\ngoto err_put_resources;\r\n}\r\nret = imx_drm_add_crtc(drm, &ipu_crtc->base, &ipu_crtc->imx_crtc,\r\n&ipu_crtc->plane[0]->base, &ipu_crtc_helper_funcs,\r\npdata->of_node);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "adding crtc failed with %d.\n", ret);\r\ngoto err_put_resources;\r\n}\r\nret = ipu_plane_get_resources(ipu_crtc->plane[0]);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting plane 0 resources failed with %d.\n",\r\nret);\r\ngoto err_remove_crtc;\r\n}\r\nif (pdata->dp >= 0 && pdata->dma[1] > 0) {\r\nipu_crtc->plane[1] = ipu_plane_init(drm, ipu, pdata->dma[1],\r\nIPU_DP_FLOW_SYNC_FG,\r\ndrm_crtc_mask(&ipu_crtc->base),\r\nDRM_PLANE_TYPE_OVERLAY);\r\nif (IS_ERR(ipu_crtc->plane[1])) {\r\nipu_crtc->plane[1] = NULL;\r\n} else {\r\nret = ipu_plane_get_resources(ipu_crtc->plane[1]);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting plane 1 "\r\n"resources failed with %d.\n", ret);\r\ngoto err_put_plane0_res;\r\n}\r\n}\r\n}\r\nipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);\r\nret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,\r\n"imx_drm", ipu_crtc);\r\nif (ret < 0) {\r\ndev_err(ipu_crtc->dev, "irq request failed with %d.\n", ret);\r\ngoto err_put_plane1_res;\r\n}\r\ndisable_irq(ipu_crtc->irq);\r\nreturn 0;\r\nerr_put_plane1_res:\r\nif (ipu_crtc->plane[1])\r\nipu_plane_put_resources(ipu_crtc->plane[1]);\r\nerr_put_plane0_res:\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\nerr_remove_crtc:\r\nimx_drm_remove_crtc(ipu_crtc->imx_crtc);\r\nerr_put_resources:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic int ipu_drm_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct ipu_client_platformdata *pdata = dev->platform_data;\r\nstruct drm_device *drm = data;\r\nstruct ipu_crtc *ipu_crtc;\r\nint ret;\r\nipu_crtc = devm_kzalloc(dev, sizeof(*ipu_crtc), GFP_KERNEL);\r\nif (!ipu_crtc)\r\nreturn -ENOMEM;\r\nipu_crtc->dev = dev;\r\nret = ipu_crtc_init(ipu_crtc, pdata, drm);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, ipu_crtc);\r\nreturn 0;\r\n}\r\nstatic void ipu_drm_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_get_drvdata(dev);\r\nipu_put_resources(ipu_crtc);\r\nif (ipu_crtc->plane[1])\r\nipu_plane_put_resources(ipu_crtc->plane[1]);\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\n}\r\nstatic int ipu_drm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nif (!dev->platform_data)\r\nreturn -EINVAL;\r\nret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nreturn component_add(dev, &ipu_crtc_ops);\r\n}\r\nstatic int ipu_drm_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &ipu_crtc_ops);\r\nreturn 0;\r\n}
