static void __init sun8i_a23_mbus_setup(struct device_node *node)\r\n{\r\nint num_parents = of_clk_get_parent_count(node);\r\nconst char **parents;\r\nconst char *clk_name = node->name;\r\nstruct resource res;\r\nstruct clk_divider *div;\r\nstruct clk_gate *gate;\r\nstruct clk_mux *mux;\r\nstruct clk *clk;\r\nvoid __iomem *reg;\r\nint err;\r\nparents = kcalloc(num_parents, sizeof(*parents), GFP_KERNEL);\r\nif (!parents)\r\nreturn;\r\nreg = of_io_request_and_map(node, 0, of_node_full_name(node));\r\nif (IS_ERR(reg)) {\r\npr_err("Could not get registers for sun8i-mbus-clk\n");\r\ngoto err_free_parents;\r\n}\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\ngoto err_unmap;\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\ngoto err_free_div;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\ngoto err_free_mux;\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nof_clk_parent_fill(node, parents, num_parents);\r\ngate->reg = reg;\r\ngate->bit_idx = SUN8I_MBUS_ENABLE;\r\ngate->lock = &sun8i_a23_mbus_lock;\r\ndiv->reg = reg;\r\ndiv->shift = SUN8I_MBUS_DIV_SHIFT;\r\ndiv->width = SUN8I_MBUS_DIV_WIDTH;\r\ndiv->lock = &sun8i_a23_mbus_lock;\r\nmux->reg = reg;\r\nmux->shift = SUN8I_MBUS_MUX_SHIFT;\r\nmux->mask = SUN8I_MBUS_MUX_MASK;\r\nmux->lock = &sun8i_a23_mbus_lock;\r\nclk = clk_register_composite(NULL, clk_name, parents, num_parents,\r\n&mux->hw, &clk_mux_ops,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops,\r\n0);\r\nif (IS_ERR(clk))\r\ngoto err_free_gate;\r\nerr = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (err)\r\ngoto err_unregister_clk;\r\nkfree(parents);\r\n__clk_get(clk);\r\nclk_prepare_enable(clk);\r\nreturn;\r\nerr_unregister_clk:\r\nclk_unregister(clk);\r\nerr_free_gate:\r\nkfree(gate);\r\nerr_free_mux:\r\nkfree(mux);\r\nerr_free_div:\r\nkfree(div);\r\nerr_unmap:\r\niounmap(reg);\r\nof_address_to_resource(node, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\nerr_free_parents:\r\nkfree(parents);\r\n}
