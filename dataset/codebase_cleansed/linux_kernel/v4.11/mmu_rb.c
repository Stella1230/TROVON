static unsigned long mmu_node_start(struct mmu_rb_node *node)\r\n{\r\nreturn node->addr & PAGE_MASK;\r\n}\r\nstatic unsigned long mmu_node_last(struct mmu_rb_node *node)\r\n{\r\nreturn PAGE_ALIGN(node->addr + node->len) - 1;\r\n}\r\nint hfi1_mmu_rb_register(void *ops_arg, struct mm_struct *mm,\r\nstruct mmu_rb_ops *ops,\r\nstruct workqueue_struct *wq,\r\nstruct mmu_rb_handler **handler)\r\n{\r\nstruct mmu_rb_handler *handlr;\r\nint ret;\r\nhandlr = kmalloc(sizeof(*handlr), GFP_KERNEL);\r\nif (!handlr)\r\nreturn -ENOMEM;\r\nhandlr->root = RB_ROOT;\r\nhandlr->ops = ops;\r\nhandlr->ops_arg = ops_arg;\r\nINIT_HLIST_NODE(&handlr->mn.hlist);\r\nspin_lock_init(&handlr->lock);\r\nhandlr->mn.ops = &mn_opts;\r\nhandlr->mm = mm;\r\nINIT_WORK(&handlr->del_work, handle_remove);\r\nINIT_LIST_HEAD(&handlr->del_list);\r\nINIT_LIST_HEAD(&handlr->lru_list);\r\nhandlr->wq = wq;\r\nret = mmu_notifier_register(&handlr->mn, handlr->mm);\r\nif (ret) {\r\nkfree(handlr);\r\nreturn ret;\r\n}\r\n*handler = handlr;\r\nreturn 0;\r\n}\r\nvoid hfi1_mmu_rb_unregister(struct mmu_rb_handler *handler)\r\n{\r\nstruct mmu_rb_node *rbnode;\r\nstruct rb_node *node;\r\nunsigned long flags;\r\nstruct list_head del_list;\r\nmmu_notifier_unregister(&handler->mn, handler->mm);\r\nflush_work(&handler->del_work);\r\nINIT_LIST_HEAD(&del_list);\r\nspin_lock_irqsave(&handler->lock, flags);\r\nwhile ((node = rb_first(&handler->root))) {\r\nrbnode = rb_entry(node, struct mmu_rb_node, node);\r\nrb_erase(node, &handler->root);\r\nlist_move(&rbnode->list, &del_list);\r\n}\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\ndo_remove(handler, &del_list);\r\nkfree(handler);\r\n}\r\nint hfi1_mmu_rb_insert(struct mmu_rb_handler *handler,\r\nstruct mmu_rb_node *mnode)\r\n{\r\nstruct mmu_rb_node *node;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&handler->lock, flags);\r\nhfi1_cdbg(MMU, "Inserting node addr 0x%llx, len %u", mnode->addr,\r\nmnode->len);\r\nnode = __mmu_rb_search(handler, mnode->addr, mnode->len);\r\nif (node) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\n__mmu_int_rb_insert(mnode, &handler->root);\r\nlist_add(&mnode->list, &handler->lru_list);\r\nret = handler->ops->insert(handler->ops_arg, mnode);\r\nif (ret) {\r\n__mmu_int_rb_remove(mnode, &handler->root);\r\nlist_del(&mnode->list);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct mmu_rb_node *__mmu_rb_search(struct mmu_rb_handler *handler,\r\nunsigned long addr,\r\nunsigned long len)\r\n{\r\nstruct mmu_rb_node *node = NULL;\r\nhfi1_cdbg(MMU, "Searching for addr 0x%llx, len %u", addr, len);\r\nif (!handler->ops->filter) {\r\nnode = __mmu_int_rb_iter_first(&handler->root, addr,\r\n(addr + len) - 1);\r\n} else {\r\nfor (node = __mmu_int_rb_iter_first(&handler->root, addr,\r\n(addr + len) - 1);\r\nnode;\r\nnode = __mmu_int_rb_iter_next(node, addr,\r\n(addr + len) - 1)) {\r\nif (handler->ops->filter(node, addr, len))\r\nreturn node;\r\n}\r\n}\r\nreturn node;\r\n}\r\nstruct mmu_rb_node *hfi1_mmu_rb_extract(struct mmu_rb_handler *handler,\r\nunsigned long addr, unsigned long len)\r\n{\r\nstruct mmu_rb_node *node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&handler->lock, flags);\r\nnode = __mmu_rb_search(handler, addr, len);\r\nif (node) {\r\n__mmu_int_rb_remove(node, &handler->root);\r\nlist_del(&node->list);\r\n}\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\nreturn node;\r\n}\r\nvoid hfi1_mmu_rb_evict(struct mmu_rb_handler *handler, void *evict_arg)\r\n{\r\nstruct mmu_rb_node *rbnode, *ptr;\r\nstruct list_head del_list;\r\nunsigned long flags;\r\nbool stop = false;\r\nINIT_LIST_HEAD(&del_list);\r\nspin_lock_irqsave(&handler->lock, flags);\r\nlist_for_each_entry_safe_reverse(rbnode, ptr, &handler->lru_list,\r\nlist) {\r\nif (handler->ops->evict(handler->ops_arg, rbnode, evict_arg,\r\n&stop)) {\r\n__mmu_int_rb_remove(rbnode, &handler->root);\r\nlist_move(&rbnode->list, &del_list);\r\n}\r\nif (stop)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\nwhile (!list_empty(&del_list)) {\r\nrbnode = list_first_entry(&del_list, struct mmu_rb_node, list);\r\nlist_del(&rbnode->list);\r\nhandler->ops->remove(handler->ops_arg, rbnode);\r\n}\r\n}\r\nvoid hfi1_mmu_rb_remove(struct mmu_rb_handler *handler,\r\nstruct mmu_rb_node *node)\r\n{\r\nunsigned long flags;\r\nhfi1_cdbg(MMU, "Removing node addr 0x%llx, len %u", node->addr,\r\nnode->len);\r\nspin_lock_irqsave(&handler->lock, flags);\r\n__mmu_int_rb_remove(node, &handler->root);\r\nlist_del(&node->list);\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\nhandler->ops->remove(handler->ops_arg, node);\r\n}\r\nstatic inline void mmu_notifier_page(struct mmu_notifier *mn,\r\nstruct mm_struct *mm, unsigned long addr)\r\n{\r\nmmu_notifier_mem_invalidate(mn, mm, addr, addr + PAGE_SIZE);\r\n}\r\nstatic inline void mmu_notifier_range_start(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nmmu_notifier_mem_invalidate(mn, mm, start, end);\r\n}\r\nstatic void mmu_notifier_mem_invalidate(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct mmu_rb_handler *handler =\r\ncontainer_of(mn, struct mmu_rb_handler, mn);\r\nstruct rb_root *root = &handler->root;\r\nstruct mmu_rb_node *node, *ptr = NULL;\r\nunsigned long flags;\r\nbool added = false;\r\nspin_lock_irqsave(&handler->lock, flags);\r\nfor (node = __mmu_int_rb_iter_first(root, start, end - 1);\r\nnode; node = ptr) {\r\nptr = __mmu_int_rb_iter_next(node, start, end - 1);\r\nhfi1_cdbg(MMU, "Invalidating node addr 0x%llx, len %u",\r\nnode->addr, node->len);\r\nif (handler->ops->invalidate(handler->ops_arg, node)) {\r\n__mmu_int_rb_remove(node, root);\r\nlist_move(&node->list, &handler->del_list);\r\nadded = true;\r\n}\r\n}\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\nif (added)\r\nqueue_work(handler->wq, &handler->del_work);\r\n}\r\nstatic void do_remove(struct mmu_rb_handler *handler,\r\nstruct list_head *del_list)\r\n{\r\nstruct mmu_rb_node *node;\r\nwhile (!list_empty(del_list)) {\r\nnode = list_first_entry(del_list, struct mmu_rb_node, list);\r\nlist_del(&node->list);\r\nhandler->ops->remove(handler->ops_arg, node);\r\n}\r\n}\r\nstatic void handle_remove(struct work_struct *work)\r\n{\r\nstruct mmu_rb_handler *handler = container_of(work,\r\nstruct mmu_rb_handler,\r\ndel_work);\r\nstruct list_head del_list;\r\nunsigned long flags;\r\nspin_lock_irqsave(&handler->lock, flags);\r\nlist_replace_init(&handler->del_list, &del_list);\r\nspin_unlock_irqrestore(&handler->lock, flags);\r\ndo_remove(handler, &del_list);\r\n}
