static int mscan_set_mode(struct net_device *dev, u8 mode)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nint ret = 0;\r\nint i;\r\nu8 canctl1;\r\nif (mode != MSCAN_NORMAL_MODE) {\r\nif (priv->tx_active) {\r\n#\r\nout_8(&regs->cantarq, priv->tx_active);\r\nout_8(&regs->cantier, 0);\r\n}\r\ncanctl1 = in_8(&regs->canctl1);\r\nif ((mode & MSCAN_SLPRQ) && !(canctl1 & MSCAN_SLPAK)) {\r\nsetbits8(&regs->canctl0, MSCAN_SLPRQ);\r\nfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\r\nif (in_8(&regs->canctl1) & MSCAN_SLPAK)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (i >= MSCAN_SET_MODE_RETRIES)\r\nnetdev_dbg(dev,\r\n"device failed to enter sleep mode. "\r\n"We proceed anyhow.\n");\r\nelse\r\npriv->can.state = CAN_STATE_SLEEPING;\r\n}\r\nif ((mode & MSCAN_INITRQ) && !(canctl1 & MSCAN_INITAK)) {\r\nsetbits8(&regs->canctl0, MSCAN_INITRQ);\r\nfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\r\nif (in_8(&regs->canctl1) & MSCAN_INITAK)\r\nbreak;\r\n}\r\nif (i >= MSCAN_SET_MODE_RETRIES)\r\nret = -ENODEV;\r\n}\r\nif (!ret)\r\npriv->can.state = CAN_STATE_STOPPED;\r\nif (mode & MSCAN_CSWAI)\r\nsetbits8(&regs->canctl0, MSCAN_CSWAI);\r\n} else {\r\ncanctl1 = in_8(&regs->canctl1);\r\nif (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {\r\nclrbits8(&regs->canctl0, MSCAN_SLPRQ | MSCAN_INITRQ);\r\nfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\r\ncanctl1 = in_8(&regs->canctl1);\r\nif (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))\r\nbreak;\r\n}\r\nif (i >= MSCAN_SET_MODE_RETRIES)\r\nret = -ENODEV;\r\nelse\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mscan_start(struct net_device *dev)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nu8 canrflg;\r\nint err;\r\nout_8(&regs->canrier, 0);\r\nINIT_LIST_HEAD(&priv->tx_head);\r\npriv->prev_buf_id = 0;\r\npriv->cur_pri = 0;\r\npriv->tx_active = 0;\r\npriv->shadow_canrier = 0;\r\npriv->flags = 0;\r\nif (priv->type == MSCAN_TYPE_MPC5121) {\r\nif (in_8(&regs->canmisc) & MSCAN_BOHOLD)\r\nout_8(&regs->canmisc, MSCAN_BOHOLD);\r\n}\r\nerr = mscan_set_mode(dev, MSCAN_NORMAL_MODE);\r\nif (err)\r\nreturn err;\r\ncanrflg = in_8(&regs->canrflg);\r\npriv->shadow_statflg = canrflg & MSCAN_STAT_MSK;\r\npriv->can.state = state_map[max(MSCAN_STATE_RX(canrflg),\r\nMSCAN_STATE_TX(canrflg))];\r\nout_8(&regs->cantier, 0);\r\nout_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int mscan_restart(struct net_device *dev)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nif (priv->type == MSCAN_TYPE_MPC5121) {\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nWARN(!(in_8(&regs->canmisc) & MSCAN_BOHOLD),\r\n"bus-off state expected\n");\r\nout_8(&regs->canmisc, MSCAN_BOHOLD);\r\nout_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);\r\n} else {\r\nif (priv->can.state <= CAN_STATE_BUS_OFF)\r\nmscan_set_mode(dev, MSCAN_INIT_MODE);\r\nreturn mscan_start(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct can_frame *frame = (struct can_frame *)skb->data;\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nint i, rtr, buf_id;\r\nu32 can_id;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nout_8(&regs->cantier, 0);\r\ni = ~priv->tx_active & MSCAN_TXE;\r\nbuf_id = ffs(i) - 1;\r\nswitch (hweight8(i)) {\r\ncase 0:\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, "Tx Ring full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\ncase 1:\r\nnetif_stop_queue(dev);\r\ncase 2:\r\nif (buf_id < priv->prev_buf_id) {\r\npriv->cur_pri++;\r\nif (priv->cur_pri == 0xff) {\r\nset_bit(F_TX_WAIT_ALL, &priv->flags);\r\nnetif_stop_queue(dev);\r\n}\r\n}\r\nset_bit(F_TX_PROGRESS, &priv->flags);\r\nbreak;\r\n}\r\npriv->prev_buf_id = buf_id;\r\nout_8(&regs->cantbsel, i);\r\nrtr = frame->can_id & CAN_RTR_FLAG;\r\nif (frame->can_id & CAN_EFF_FLAG) {\r\ncan_id = (frame->can_id & CAN_EFF_MASK)\r\n<< (MSCAN_EFF_RTR_SHIFT + 1);\r\nif (rtr)\r\ncan_id |= 1 << MSCAN_EFF_RTR_SHIFT;\r\nout_be16(&regs->tx.idr3_2, can_id);\r\ncan_id >>= 16;\r\ncan_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0)\r\n| MSCAN_EFF_FLAGS;\r\n} else {\r\ncan_id = (frame->can_id & CAN_SFF_MASK)\r\n<< (MSCAN_SFF_RTR_SHIFT + 1);\r\nif (rtr)\r\ncan_id |= 1 << MSCAN_SFF_RTR_SHIFT;\r\n}\r\nout_be16(&regs->tx.idr1_0, can_id);\r\nif (!rtr) {\r\nvoid __iomem *data = &regs->tx.dsr1_0;\r\nu16 *payload = (u16 *)frame->data;\r\nfor (i = 0; i < frame->can_dlc / 2; i++) {\r\nout_be16(data, *payload++);\r\ndata += 2 + _MSCAN_RESERVED_DSR_SIZE;\r\n}\r\nif (frame->can_dlc & 1)\r\nout_8(data, frame->data[frame->can_dlc - 1]);\r\n}\r\nout_8(&regs->tx.dlr, frame->can_dlc);\r\nout_8(&regs->tx.tbpr, priv->cur_pri);\r\nout_8(&regs->cantflg, 1 << buf_id);\r\nif (!test_bit(F_TX_PROGRESS, &priv->flags))\r\nnetif_trans_update(dev);\r\nlist_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);\r\ncan_put_echo_skb(skb, dev, buf_id);\r\npriv->tx_active |= 1 << buf_id;\r\nout_8(&regs->cantier, priv->tx_active);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic enum can_state get_new_state(struct net_device *dev, u8 canrflg)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nif (unlikely(canrflg & MSCAN_CSCIF))\r\nreturn state_map[max(MSCAN_STATE_RX(canrflg),\r\nMSCAN_STATE_TX(canrflg))];\r\nreturn priv->can.state;\r\n}\r\nstatic void mscan_get_rx_frame(struct net_device *dev, struct can_frame *frame)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nu32 can_id;\r\nint i;\r\ncan_id = in_be16(&regs->rx.idr1_0);\r\nif (can_id & (1 << 3)) {\r\nframe->can_id = CAN_EFF_FLAG;\r\ncan_id = ((can_id << 16) | in_be16(&regs->rx.idr3_2));\r\ncan_id = ((can_id & 0xffe00000) |\r\n((can_id & 0x7ffff) << 2)) >> 2;\r\n} else {\r\ncan_id >>= 4;\r\nframe->can_id = 0;\r\n}\r\nframe->can_id |= can_id >> 1;\r\nif (can_id & 1)\r\nframe->can_id |= CAN_RTR_FLAG;\r\nframe->can_dlc = get_can_dlc(in_8(&regs->rx.dlr) & 0xf);\r\nif (!(frame->can_id & CAN_RTR_FLAG)) {\r\nvoid __iomem *data = &regs->rx.dsr1_0;\r\nu16 *payload = (u16 *)frame->data;\r\nfor (i = 0; i < frame->can_dlc / 2; i++) {\r\n*payload++ = in_be16(data);\r\ndata += 2 + _MSCAN_RESERVED_DSR_SIZE;\r\n}\r\nif (frame->can_dlc & 1)\r\nframe->data[frame->can_dlc - 1] = in_8(data);\r\n}\r\nout_8(&regs->canrflg, MSCAN_RXF);\r\n}\r\nstatic void mscan_get_err_frame(struct net_device *dev, struct can_frame *frame,\r\nu8 canrflg)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nstruct net_device_stats *stats = &dev->stats;\r\nenum can_state new_state;\r\nnetdev_dbg(dev, "error interrupt (canrflg=%#x)\n", canrflg);\r\nframe->can_id = CAN_ERR_FLAG;\r\nif (canrflg & MSCAN_OVRIF) {\r\nframe->can_id |= CAN_ERR_CRTL;\r\nframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\n} else {\r\nframe->data[1] = 0;\r\n}\r\nnew_state = get_new_state(dev, canrflg);\r\nif (new_state != priv->can.state) {\r\ncan_change_state(dev, frame,\r\nstate_map[MSCAN_STATE_TX(canrflg)],\r\nstate_map[MSCAN_STATE_RX(canrflg)]);\r\nif (priv->can.state == CAN_STATE_BUS_OFF) {\r\nif (priv->type != MSCAN_TYPE_MPC5121) {\r\nout_8(&regs->cantier, 0);\r\nout_8(&regs->canrier, 0);\r\nsetbits8(&regs->canctl0,\r\nMSCAN_SLPRQ | MSCAN_INITRQ);\r\n}\r\ncan_bus_off(dev);\r\n}\r\n}\r\npriv->shadow_statflg = canrflg & MSCAN_STAT_MSK;\r\nframe->can_dlc = CAN_ERR_DLC;\r\nout_8(&regs->canrflg, MSCAN_ERR_IF);\r\n}\r\nstatic int mscan_rx_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);\r\nstruct net_device *dev = napi->dev;\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nstruct net_device_stats *stats = &dev->stats;\r\nint npackets = 0;\r\nint ret = 1;\r\nstruct sk_buff *skb;\r\nstruct can_frame *frame;\r\nu8 canrflg;\r\nwhile (npackets < quota) {\r\ncanrflg = in_8(&regs->canrflg);\r\nif (!(canrflg & (MSCAN_RXF | MSCAN_ERR_IF)))\r\nbreak;\r\nskb = alloc_can_skb(dev, &frame);\r\nif (!skb) {\r\nif (printk_ratelimit())\r\nnetdev_notice(dev, "packet dropped\n");\r\nstats->rx_dropped++;\r\nout_8(&regs->canrflg, canrflg);\r\ncontinue;\r\n}\r\nif (canrflg & MSCAN_RXF)\r\nmscan_get_rx_frame(dev, frame);\r\nelse if (canrflg & MSCAN_ERR_IF)\r\nmscan_get_err_frame(dev, frame, canrflg);\r\nstats->rx_packets++;\r\nstats->rx_bytes += frame->can_dlc;\r\nnpackets++;\r\nnetif_receive_skb(skb);\r\n}\r\nif (!(in_8(&regs->canrflg) & (MSCAN_RXF | MSCAN_ERR_IF))) {\r\nnapi_complete(&priv->napi);\r\nclear_bit(F_RX_PROGRESS, &priv->flags);\r\nif (priv->can.state < CAN_STATE_BUS_OFF)\r\nout_8(&regs->canrier, priv->shadow_canrier);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t mscan_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nstruct net_device_stats *stats = &dev->stats;\r\nu8 cantier, cantflg, canrflg;\r\nirqreturn_t ret = IRQ_NONE;\r\ncantier = in_8(&regs->cantier) & MSCAN_TXE;\r\ncantflg = in_8(&regs->cantflg) & cantier;\r\nif (cantier && cantflg) {\r\nstruct list_head *tmp, *pos;\r\nlist_for_each_safe(pos, tmp, &priv->tx_head) {\r\nstruct tx_queue_entry *entry =\r\nlist_entry(pos, struct tx_queue_entry, list);\r\nu8 mask = entry->mask;\r\nif (!(cantflg & mask))\r\ncontinue;\r\nout_8(&regs->cantbsel, mask);\r\nstats->tx_bytes += in_8(&regs->tx.dlr);\r\nstats->tx_packets++;\r\ncan_get_echo_skb(dev, entry->id);\r\npriv->tx_active &= ~mask;\r\nlist_del(pos);\r\n}\r\nif (list_empty(&priv->tx_head)) {\r\nclear_bit(F_TX_WAIT_ALL, &priv->flags);\r\nclear_bit(F_TX_PROGRESS, &priv->flags);\r\npriv->cur_pri = 0;\r\n} else {\r\nnetif_trans_update(dev);\r\n}\r\nif (!test_bit(F_TX_WAIT_ALL, &priv->flags))\r\nnetif_wake_queue(dev);\r\nout_8(&regs->cantier, priv->tx_active);\r\nret = IRQ_HANDLED;\r\n}\r\ncanrflg = in_8(&regs->canrflg);\r\nif ((canrflg & ~MSCAN_STAT_MSK) &&\r\n!test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {\r\nif (canrflg & ~MSCAN_STAT_MSK) {\r\npriv->shadow_canrier = in_8(&regs->canrier);\r\nout_8(&regs->canrier, 0);\r\nnapi_schedule(&priv->napi);\r\nret = IRQ_HANDLED;\r\n} else {\r\nclear_bit(F_RX_PROGRESS, &priv->flags);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mscan_do_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nint ret = 0;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nret = mscan_restart(dev);\r\nif (ret)\r\nbreak;\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mscan_do_set_bittiming(struct net_device *dev)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nu8 btr0, btr1;\r\nbtr0 = BTR0_SET_BRP(bt->brp) | BTR0_SET_SJW(bt->sjw);\r\nbtr1 = (BTR1_SET_TSEG1(bt->prop_seg + bt->phase_seg1) |\r\nBTR1_SET_TSEG2(bt->phase_seg2) |\r\nBTR1_SET_SAM(priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES));\r\nnetdev_info(dev, "setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);\r\nout_8(&regs->canbtr0, btr0);\r\nout_8(&regs->canbtr1, btr1);\r\nreturn 0;\r\n}\r\nstatic int mscan_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nbec->txerr = in_8(&regs->cantxerr);\r\nbec->rxerr = in_8(&regs->canrxerr);\r\nreturn 0;\r\n}\r\nstatic int mscan_open(struct net_device *dev)\r\n{\r\nint ret;\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nif (priv->clk_ipg) {\r\nret = clk_prepare_enable(priv->clk_ipg);\r\nif (ret)\r\ngoto exit_retcode;\r\n}\r\nif (priv->clk_can) {\r\nret = clk_prepare_enable(priv->clk_can);\r\nif (ret)\r\ngoto exit_dis_ipg_clock;\r\n}\r\nret = open_candev(dev);\r\nif (ret)\r\ngoto exit_dis_can_clock;\r\nnapi_enable(&priv->napi);\r\nret = request_irq(dev->irq, mscan_isr, 0, dev->name, dev);\r\nif (ret < 0) {\r\nnetdev_err(dev, "failed to attach interrupt\n");\r\ngoto exit_napi_disable;\r\n}\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nsetbits8(&regs->canctl1, MSCAN_LISTEN);\r\nelse\r\nclrbits8(&regs->canctl1, MSCAN_LISTEN);\r\nret = mscan_start(dev);\r\nif (ret)\r\ngoto exit_free_irq;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nexit_free_irq:\r\nfree_irq(dev->irq, dev);\r\nexit_napi_disable:\r\nnapi_disable(&priv->napi);\r\nclose_candev(dev);\r\nexit_dis_can_clock:\r\nif (priv->clk_can)\r\nclk_disable_unprepare(priv->clk_can);\r\nexit_dis_ipg_clock:\r\nif (priv->clk_ipg)\r\nclk_disable_unprepare(priv->clk_ipg);\r\nexit_retcode:\r\nreturn ret;\r\n}\r\nstatic int mscan_close(struct net_device *dev)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nout_8(&regs->cantier, 0);\r\nout_8(&regs->canrier, 0);\r\nmscan_set_mode(dev, MSCAN_INIT_MODE);\r\nclose_candev(dev);\r\nfree_irq(dev->irq, dev);\r\nif (priv->clk_can)\r\nclk_disable_unprepare(priv->clk_can);\r\nif (priv->clk_ipg)\r\nclk_disable_unprepare(priv->clk_ipg);\r\nreturn 0;\r\n}\r\nint register_mscandev(struct net_device *dev, int mscan_clksrc)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nu8 ctl1;\r\nctl1 = in_8(&regs->canctl1);\r\nif (mscan_clksrc)\r\nctl1 |= MSCAN_CLKSRC;\r\nelse\r\nctl1 &= ~MSCAN_CLKSRC;\r\nif (priv->type == MSCAN_TYPE_MPC5121) {\r\npriv->can.do_get_berr_counter = mscan_get_berr_counter;\r\nctl1 |= MSCAN_BORM;\r\n}\r\nctl1 |= MSCAN_CANE;\r\nout_8(&regs->canctl1, ctl1);\r\nudelay(100);\r\nout_be16(&regs->canidar1_0, 0);\r\nout_be16(&regs->canidar3_2, 0);\r\nout_be16(&regs->canidar5_4, 0);\r\nout_be16(&regs->canidar7_6, 0);\r\nout_be16(&regs->canidmr1_0, 0xffff);\r\nout_be16(&regs->canidmr3_2, 0xffff);\r\nout_be16(&regs->canidmr5_4, 0xffff);\r\nout_be16(&regs->canidmr7_6, 0xffff);\r\nout_8(&regs->canidac, MSCAN_AF_32BIT);\r\nmscan_set_mode(dev, MSCAN_INIT_MODE);\r\nreturn register_candev(dev);\r\n}\r\nvoid unregister_mscandev(struct net_device *dev)\r\n{\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs __iomem *regs = priv->reg_base;\r\nmscan_set_mode(dev, MSCAN_INIT_MODE);\r\nclrbits8(&regs->canctl1, MSCAN_CANE);\r\nunregister_candev(dev);\r\n}\r\nstruct net_device *alloc_mscandev(void)\r\n{\r\nstruct net_device *dev;\r\nstruct mscan_priv *priv;\r\nint i;\r\ndev = alloc_candev(sizeof(struct mscan_priv), MSCAN_ECHO_SKB_MAX);\r\nif (!dev)\r\nreturn NULL;\r\npriv = netdev_priv(dev);\r\ndev->netdev_ops = &mscan_netdev_ops;\r\ndev->flags |= IFF_ECHO;\r\nnetif_napi_add(dev, &priv->napi, mscan_rx_poll, 8);\r\npriv->can.bittiming_const = &mscan_bittiming_const;\r\npriv->can.do_set_bittiming = mscan_do_set_bittiming;\r\npriv->can.do_set_mode = mscan_do_set_mode;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_LISTENONLY;\r\nfor (i = 0; i < TX_QUEUE_SIZE; i++) {\r\npriv->tx_queue[i].id = i;\r\npriv->tx_queue[i].mask = 1 << i;\r\n}\r\nreturn dev;\r\n}
