static void ieee80211_offchannel_ps_enable(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\r\nlocal->offchannel_ps_enabled = false;\r\ndel_timer_sync(&local->dynamic_ps_timer);\r\ndel_timer_sync(&ifmgd->bcn_mon_timer);\r\ndel_timer_sync(&ifmgd->conn_mon_timer);\r\ncancel_work_sync(&local->dynamic_ps_enable_work);\r\nif (local->hw.conf.flags & IEEE80211_CONF_PS) {\r\nlocal->offchannel_ps_enabled = true;\r\nlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n}\r\nif (!local->offchannel_ps_enabled ||\r\n!ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))\r\nieee80211_send_nullfunc(local, sdata, true);\r\n}\r\nstatic void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nif (!local->ps_sdata)\r\nieee80211_send_nullfunc(local, sdata, false);\r\nelse if (local->offchannel_ps_enabled) {\r\nlocal->hw.conf.flags |= IEEE80211_CONF_PS;\r\nieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\r\n} else if (local->hw.conf.dynamic_ps_timeout > 0) {\r\nieee80211_send_nullfunc(local, sdata, false);\r\nmod_timer(&local->dynamic_ps_timer, jiffies +\r\nmsecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\r\n}\r\nieee80211_sta_reset_beacon_monitor(sdata);\r\nieee80211_sta_reset_conn_monitor(sdata);\r\n}\r\nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nif (WARN_ON(local->use_chanctx))\r\nreturn;\r\nieee80211_stop_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\r\nIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\r\nfalse);\r\nieee80211_flush_queues(local, NULL, false);\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE ||\r\nsdata->vif.type == NL80211_IFTYPE_NAN)\r\ncontinue;\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nset_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nif (sdata->vif.bss_conf.enable_beacon) {\r\nset_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\r\n&sdata->state);\r\nsdata->vif.bss_conf.enable_beacon = false;\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\n}\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_enable(sdata);\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\n}\r\nvoid ieee80211_offchannel_return(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_sub_if_data *sdata;\r\nif (WARN_ON(local->use_chanctx))\r\nreturn;\r\nmutex_lock(&local->iflist_mtx);\r\nlist_for_each_entry(sdata, &local->interfaces, list) {\r\nif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)\r\ncontinue;\r\nif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\r\nclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\r\nif (!ieee80211_sdata_running(sdata))\r\ncontinue;\r\nif (sdata->vif.type == NL80211_IFTYPE_STATION &&\r\nsdata->u.mgd.associated)\r\nieee80211_offchannel_ps_disable(sdata);\r\nif (test_and_clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\r\n&sdata->state)) {\r\nsdata->vif.bss_conf.enable_beacon = true;\r\nieee80211_bss_info_change_notify(\r\nsdata, BSS_CHANGED_BEACON_ENABLED);\r\n}\r\n}\r\nmutex_unlock(&local->iflist_mtx);\r\nieee80211_wake_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\r\nIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\r\nfalse);\r\n}\r\nstatic void ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc)\r\n{\r\nif (roc->frame) {\r\ncfg80211_mgmt_tx_status(&roc->sdata->wdev, roc->mgmt_tx_cookie,\r\nroc->frame->data, roc->frame->len,\r\nfalse, GFP_KERNEL);\r\nieee80211_free_txskb(&roc->sdata->local->hw, roc->frame);\r\n}\r\nif (!roc->mgmt_tx_cookie)\r\ncfg80211_remain_on_channel_expired(&roc->sdata->wdev,\r\nroc->cookie, roc->chan,\r\nGFP_KERNEL);\r\nlist_del(&roc->list);\r\nkfree(roc);\r\n}\r\nstatic unsigned long ieee80211_end_finished_rocs(struct ieee80211_local *local,\r\nunsigned long now)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp;\r\nlong remaining_dur_min = LONG_MAX;\r\nlockdep_assert_held(&local->mtx);\r\nlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\r\nlong remaining;\r\nif (!roc->started)\r\nbreak;\r\nremaining = roc->start_time +\r\nmsecs_to_jiffies(roc->duration) -\r\nnow;\r\nif (roc->abort || roc->hw_begun || remaining <= 0)\r\nieee80211_roc_notify_destroy(roc);\r\nelse\r\nremaining_dur_min = min(remaining_dur_min, remaining);\r\n}\r\nreturn remaining_dur_min;\r\n}\r\nstatic bool ieee80211_recalc_sw_work(struct ieee80211_local *local,\r\nunsigned long now)\r\n{\r\nlong dur = ieee80211_end_finished_rocs(local, now);\r\nif (dur == LONG_MAX)\r\nreturn false;\r\nmod_delayed_work(local->workqueue, &local->roc_work, dur);\r\nreturn true;\r\n}\r\nstatic void ieee80211_handle_roc_started(struct ieee80211_roc_work *roc,\r\nunsigned long start_time)\r\n{\r\nif (WARN_ON(roc->notified))\r\nreturn;\r\nroc->start_time = start_time;\r\nroc->started = true;\r\nif (roc->mgmt_tx_cookie) {\r\nif (!WARN_ON(!roc->frame)) {\r\nieee80211_tx_skb_tid_band(roc->sdata, roc->frame, 7,\r\nroc->chan->band);\r\nroc->frame = NULL;\r\n}\r\n} else {\r\ncfg80211_ready_on_channel(&roc->sdata->wdev, roc->cookie,\r\nroc->chan, roc->req_duration,\r\nGFP_KERNEL);\r\n}\r\nroc->notified = true;\r\n}\r\nstatic void ieee80211_hw_roc_start(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_start);\r\nstruct ieee80211_roc_work *roc;\r\nmutex_lock(&local->mtx);\r\nlist_for_each_entry(roc, &local->roc_list, list) {\r\nif (!roc->started)\r\nbreak;\r\nroc->hw_begun = true;\r\nieee80211_handle_roc_started(roc, local->hw_roc_start_time);\r\n}\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\nlocal->hw_roc_start_time = jiffies;\r\ntrace_api_ready_on_channel(local);\r\nieee80211_queue_work(hw, &local->hw_roc_start);\r\n}\r\nstatic void _ieee80211_start_next_roc(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp;\r\nenum ieee80211_roc_type type;\r\nu32 min_dur, max_dur;\r\nlockdep_assert_held(&local->mtx);\r\nif (WARN_ON(list_empty(&local->roc_list)))\r\nreturn;\r\nroc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\r\nlist);\r\nif (WARN_ON(roc->started))\r\nreturn;\r\nmin_dur = roc->duration;\r\nmax_dur = roc->duration;\r\ntype = roc->type;\r\nlist_for_each_entry(tmp, &local->roc_list, list) {\r\nif (tmp == roc)\r\ncontinue;\r\nif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\r\nbreak;\r\nmax_dur = max(tmp->duration, max_dur);\r\nmin_dur = min(tmp->duration, min_dur);\r\ntype = max(tmp->type, type);\r\n}\r\nif (local->ops->remain_on_channel) {\r\nint ret = drv_remain_on_channel(local, roc->sdata, roc->chan,\r\nmax_dur, type);\r\nif (ret) {\r\nwiphy_warn(local->hw.wiphy,\r\n"failed to start next HW ROC (%d)\n", ret);\r\nlist_for_each_entry(tmp, &local->roc_list, list) {\r\nif (tmp->sdata != roc->sdata ||\r\ntmp->chan != roc->chan)\r\nbreak;\r\ntmp->started = true;\r\ntmp->abort = true;\r\n}\r\nieee80211_queue_work(&local->hw, &local->hw_roc_done);\r\nreturn;\r\n}\r\nlist_for_each_entry(tmp, &local->roc_list, list) {\r\nif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\r\nbreak;\r\ntmp->started = true;\r\n}\r\n} else {\r\nroc->on_channel = roc->chan == local->_oper_chandef.chan &&\r\nlocal->_oper_chandef.width != NL80211_CHAN_WIDTH_5 &&\r\nlocal->_oper_chandef.width != NL80211_CHAN_WIDTH_10;\r\nieee80211_recalc_idle(local);\r\nif (!roc->on_channel) {\r\nieee80211_offchannel_stop_vifs(local);\r\nlocal->tmp_channel = roc->chan;\r\nieee80211_hw_config(local, 0);\r\n}\r\nieee80211_queue_delayed_work(&local->hw, &local->roc_work,\r\nmsecs_to_jiffies(min_dur));\r\nlist_for_each_entry(tmp, &local->roc_list, list) {\r\nif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\r\nbreak;\r\ntmp->on_channel = roc->on_channel;\r\nieee80211_handle_roc_started(tmp, jiffies);\r\n}\r\n}\r\n}\r\nvoid ieee80211_start_next_roc(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_roc_work *roc;\r\nlockdep_assert_held(&local->mtx);\r\nif (list_empty(&local->roc_list)) {\r\nieee80211_run_deferred_scan(local);\r\nreturn;\r\n}\r\nif (local->in_reconfig)\r\nreturn;\r\nroc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\r\nlist);\r\nif (WARN_ON_ONCE(roc->started))\r\nreturn;\r\nif (local->ops->remain_on_channel) {\r\n_ieee80211_start_next_roc(local);\r\n} else {\r\nieee80211_queue_delayed_work(&local->hw, &local->roc_work,\r\nround_jiffies_relative(HZ/2));\r\n}\r\n}\r\nstatic void __ieee80211_roc_work(struct ieee80211_local *local)\r\n{\r\nstruct ieee80211_roc_work *roc;\r\nbool on_channel;\r\nlockdep_assert_held(&local->mtx);\r\nif (WARN_ON(local->ops->remain_on_channel))\r\nreturn;\r\nroc = list_first_entry_or_null(&local->roc_list,\r\nstruct ieee80211_roc_work, list);\r\nif (!roc)\r\nreturn;\r\nif (!roc->started) {\r\nWARN_ON(local->use_chanctx);\r\n_ieee80211_start_next_roc(local);\r\n} else {\r\non_channel = roc->on_channel;\r\nif (ieee80211_recalc_sw_work(local, jiffies))\r\nreturn;\r\nif (!on_channel) {\r\nieee80211_flush_queues(local, NULL, false);\r\nlocal->tmp_channel = NULL;\r\nieee80211_hw_config(local, 0);\r\nieee80211_offchannel_return(local);\r\n}\r\nieee80211_recalc_idle(local);\r\nieee80211_start_next_roc(local);\r\n}\r\n}\r\nstatic void ieee80211_roc_work(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, roc_work.work);\r\nmutex_lock(&local->mtx);\r\n__ieee80211_roc_work(local);\r\nmutex_unlock(&local->mtx);\r\n}\r\nstatic void ieee80211_hw_roc_done(struct work_struct *work)\r\n{\r\nstruct ieee80211_local *local =\r\ncontainer_of(work, struct ieee80211_local, hw_roc_done);\r\nmutex_lock(&local->mtx);\r\nieee80211_end_finished_rocs(local, jiffies);\r\nieee80211_start_next_roc(local);\r\nmutex_unlock(&local->mtx);\r\n}\r\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)\r\n{\r\nstruct ieee80211_local *local = hw_to_local(hw);\r\ntrace_api_remain_on_channel_expired(local);\r\nieee80211_queue_work(hw, &local->hw_roc_done);\r\n}\r\nstatic bool\r\nieee80211_coalesce_hw_started_roc(struct ieee80211_local *local,\r\nstruct ieee80211_roc_work *new_roc,\r\nstruct ieee80211_roc_work *cur_roc)\r\n{\r\nunsigned long now = jiffies;\r\nunsigned long remaining;\r\nif (WARN_ON(!cur_roc->started))\r\nreturn false;\r\nif (!cur_roc->hw_begun && new_roc->duration > cur_roc->duration)\r\nreturn false;\r\nremaining = cur_roc->start_time +\r\nmsecs_to_jiffies(cur_roc->duration) -\r\nnow;\r\nif (new_roc->duration > jiffies_to_msecs(remaining))\r\nreturn false;\r\nlist_add(&new_roc->list, &cur_roc->list);\r\nif (cur_roc->hw_begun) {\r\nnew_roc->hw_begun = true;\r\nieee80211_handle_roc_started(new_roc, now);\r\n}\r\nreturn true;\r\n}\r\nstatic int ieee80211_start_roc_work(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata,\r\nstruct ieee80211_channel *channel,\r\nunsigned int duration, u64 *cookie,\r\nstruct sk_buff *txskb,\r\nenum ieee80211_roc_type type)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp;\r\nbool queued = false, combine_started = true;\r\nint ret;\r\nlockdep_assert_held(&local->mtx);\r\nif (local->use_chanctx && !local->ops->remain_on_channel)\r\nreturn -EOPNOTSUPP;\r\nroc = kzalloc(sizeof(*roc), GFP_KERNEL);\r\nif (!roc)\r\nreturn -ENOMEM;\r\nif (!duration)\r\nduration = 10;\r\nroc->chan = channel;\r\nroc->duration = duration;\r\nroc->req_duration = duration;\r\nroc->frame = txskb;\r\nroc->type = type;\r\nroc->sdata = sdata;\r\nif (!txskb) {\r\nroc->cookie = ieee80211_mgmt_tx_cookie(local);\r\n*cookie = roc->cookie;\r\n} else {\r\nroc->mgmt_tx_cookie = *cookie;\r\n}\r\nif (list_empty(&local->roc_list) &&\r\n!local->scanning && !ieee80211_is_radar_required(local)) {\r\nif (!local->ops->remain_on_channel) {\r\nlist_add_tail(&roc->list, &local->roc_list);\r\nieee80211_queue_delayed_work(&local->hw,\r\n&local->roc_work, 0);\r\n} else {\r\nret = drv_remain_on_channel(local, sdata, channel,\r\nduration, type);\r\nif (ret) {\r\nkfree(roc);\r\nreturn ret;\r\n}\r\nroc->started = true;\r\nlist_add_tail(&roc->list, &local->roc_list);\r\n}\r\nreturn 0;\r\n}\r\nlist_for_each_entry(tmp, &local->roc_list, list) {\r\nif (tmp->chan != channel || tmp->sdata != sdata)\r\ncontinue;\r\nif (!tmp->started) {\r\nlist_add(&roc->list, &tmp->list);\r\nqueued = true;\r\nbreak;\r\n}\r\nif (!combine_started)\r\ncontinue;\r\nif (!local->ops->remain_on_channel) {\r\nunsigned long now = jiffies;\r\nu32 elapsed = jiffies_to_msecs(now - tmp->start_time);\r\nstruct wiphy *wiphy = local->hw.wiphy;\r\nu32 max_roc = wiphy->max_remain_on_channel_duration;\r\nif (elapsed + roc->duration > max_roc) {\r\ncombine_started = false;\r\ncontinue;\r\n}\r\nlist_add(&roc->list, &tmp->list);\r\nqueued = true;\r\nroc->on_channel = tmp->on_channel;\r\nieee80211_handle_roc_started(roc, now);\r\nieee80211_recalc_sw_work(local, now);\r\nbreak;\r\n}\r\nqueued = ieee80211_coalesce_hw_started_roc(local, roc, tmp);\r\nif (queued)\r\nbreak;\r\ncombine_started = false;\r\n}\r\nif (!queued)\r\nlist_add_tail(&roc->list, &local->roc_list);\r\nreturn 0;\r\n}\r\nint ieee80211_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct ieee80211_channel *chan,\r\nunsigned int duration, u64 *cookie)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\r\nstruct ieee80211_local *local = sdata->local;\r\nint ret;\r\nmutex_lock(&local->mtx);\r\nret = ieee80211_start_roc_work(local, sdata, chan,\r\nduration, cookie, NULL,\r\nIEEE80211_ROC_TYPE_NORMAL);\r\nmutex_unlock(&local->mtx);\r\nreturn ret;\r\n}\r\nstatic int ieee80211_cancel_roc(struct ieee80211_local *local,\r\nu64 cookie, bool mgmt_tx)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp, *found = NULL;\r\nint ret;\r\nif (!cookie)\r\nreturn -ENOENT;\r\nmutex_lock(&local->mtx);\r\nlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\r\nif (!mgmt_tx && roc->cookie != cookie)\r\ncontinue;\r\nelse if (mgmt_tx && roc->mgmt_tx_cookie != cookie)\r\ncontinue;\r\nfound = roc;\r\nbreak;\r\n}\r\nif (!found) {\r\nmutex_unlock(&local->mtx);\r\nreturn -ENOENT;\r\n}\r\nif (!found->started) {\r\nieee80211_roc_notify_destroy(found);\r\ngoto out_unlock;\r\n}\r\nif (local->ops->remain_on_channel) {\r\nret = drv_cancel_remain_on_channel(local);\r\nif (WARN_ON_ONCE(ret)) {\r\nmutex_unlock(&local->mtx);\r\nreturn ret;\r\n}\r\nlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\r\nif (!roc->started)\r\nbreak;\r\nif (roc == found)\r\nfound = NULL;\r\nieee80211_roc_notify_destroy(roc);\r\n}\r\nWARN_ON(found);\r\nieee80211_start_next_roc(local);\r\n} else {\r\nfound->abort = true;\r\nmod_delayed_work(local->workqueue, &local->roc_work, 0);\r\n}\r\nout_unlock:\r\nmutex_unlock(&local->mtx);\r\nreturn 0;\r\n}\r\nint ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev, u64 cookie)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\r\nstruct ieee80211_local *local = sdata->local;\r\nreturn ieee80211_cancel_roc(local, cookie, false);\r\n}\r\nint ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct cfg80211_mgmt_tx_params *params, u64 *cookie)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct sta_info *sta;\r\nconst struct ieee80211_mgmt *mgmt = (void *)params->buf;\r\nbool need_offchan = false;\r\nu32 flags;\r\nint ret;\r\nu8 *data;\r\nif (params->dont_wait_for_ack)\r\nflags = IEEE80211_TX_CTL_NO_ACK;\r\nelse\r\nflags = IEEE80211_TX_INTFL_NL80211_FRAME_TX |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\nif (params->no_cck)\r\nflags |= IEEE80211_TX_CTL_NO_CCK_RATE;\r\nswitch (sdata->vif.type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (!sdata->vif.bss_conf.ibss_joined)\r\nneed_offchan = true;\r\n#ifdef CONFIG_MAC80211_MESH\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nif (ieee80211_vif_is_mesh(&sdata->vif) &&\r\n!sdata->u.mesh.mesh_id_len)\r\nneed_offchan = true;\r\n#endif\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nif (sdata->vif.type != NL80211_IFTYPE_ADHOC &&\r\n!ieee80211_vif_is_mesh(&sdata->vif) &&\r\n!rcu_access_pointer(sdata->bss->beacon))\r\nneed_offchan = true;\r\nif (!ieee80211_is_action(mgmt->frame_control) ||\r\nmgmt->u.action.category == WLAN_CATEGORY_PUBLIC ||\r\nmgmt->u.action.category == WLAN_CATEGORY_SELF_PROTECTED ||\r\nmgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)\r\nbreak;\r\nrcu_read_lock();\r\nsta = sta_info_get_bss(sdata, mgmt->da);\r\nrcu_read_unlock();\r\nif (!sta)\r\nreturn -ENOLINK;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nsdata_lock(sdata);\r\nif (!sdata->u.mgd.associated ||\r\n(params->offchan && params->wait &&\r\nlocal->ops->remain_on_channel &&\r\nmemcmp(sdata->u.mgd.associated->bssid,\r\nmgmt->bssid, ETH_ALEN)))\r\nneed_offchan = true;\r\nsdata_unlock(sdata);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nneed_offchan = true;\r\nbreak;\r\ncase NL80211_IFTYPE_NAN:\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (need_offchan && !params->chan)\r\nreturn -EINVAL;\r\nmutex_lock(&local->mtx);\r\nif (!need_offchan) {\r\nstruct ieee80211_chanctx_conf *chanctx_conf;\r\nrcu_read_lock();\r\nchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\r\nif (chanctx_conf) {\r\nneed_offchan = params->chan &&\r\n(params->chan !=\r\nchanctx_conf->def.chan);\r\n} else if (!params->chan) {\r\nret = -EINVAL;\r\nrcu_read_unlock();\r\ngoto out_unlock;\r\n} else {\r\nneed_offchan = true;\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (need_offchan && !params->offchan) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nskb = dev_alloc_skb(local->hw.extra_tx_headroom + params->len);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\ndata = skb_put(skb, params->len);\r\nmemcpy(data, params->buf, params->len);\r\nif (sdata->vif.csa_active &&\r\n(sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\r\nsdata->vif.type == NL80211_IFTYPE_ADHOC) &&\r\nparams->n_csa_offsets) {\r\nint i;\r\nstruct beacon_data *beacon = NULL;\r\nrcu_read_lock();\r\nif (sdata->vif.type == NL80211_IFTYPE_AP)\r\nbeacon = rcu_dereference(sdata->u.ap.beacon);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\r\nbeacon = rcu_dereference(sdata->u.ibss.presp);\r\nelse if (ieee80211_vif_is_mesh(&sdata->vif))\r\nbeacon = rcu_dereference(sdata->u.mesh.beacon);\r\nif (beacon)\r\nfor (i = 0; i < params->n_csa_offsets; i++)\r\ndata[params->csa_offsets[i]] =\r\nbeacon->csa_current_counter;\r\nrcu_read_unlock();\r\n}\r\nIEEE80211_SKB_CB(skb)->flags = flags;\r\nskb->dev = sdata->dev;\r\nif (!params->dont_wait_for_ack) {\r\nret = ieee80211_attach_ack_skb(local, skb, cookie, GFP_KERNEL);\r\nif (ret) {\r\nkfree_skb(skb);\r\ngoto out_unlock;\r\n}\r\n} else {\r\n*cookie = 0xffffffff;\r\n}\r\nif (!need_offchan) {\r\nieee80211_tx_skb(sdata, skb);\r\nret = 0;\r\ngoto out_unlock;\r\n}\r\nIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_TX_OFFCHAN |\r\nIEEE80211_TX_INTFL_OFFCHAN_TX_OK;\r\nif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\r\nIEEE80211_SKB_CB(skb)->hw_queue =\r\nlocal->hw.offchannel_tx_hw_queue;\r\nret = ieee80211_start_roc_work(local, sdata, params->chan,\r\nparams->wait, cookie, skb,\r\nIEEE80211_ROC_TYPE_MGMT_TX);\r\nif (ret)\r\nieee80211_free_txskb(&local->hw, skb);\r\nout_unlock:\r\nmutex_unlock(&local->mtx);\r\nreturn ret;\r\n}\r\nint ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev, u64 cookie)\r\n{\r\nstruct ieee80211_local *local = wiphy_priv(wiphy);\r\nreturn ieee80211_cancel_roc(local, cookie, true);\r\n}\r\nvoid ieee80211_roc_setup(struct ieee80211_local *local)\r\n{\r\nINIT_WORK(&local->hw_roc_start, ieee80211_hw_roc_start);\r\nINIT_WORK(&local->hw_roc_done, ieee80211_hw_roc_done);\r\nINIT_DELAYED_WORK(&local->roc_work, ieee80211_roc_work);\r\nINIT_LIST_HEAD(&local->roc_list);\r\n}\r\nvoid ieee80211_roc_purge(struct ieee80211_local *local,\r\nstruct ieee80211_sub_if_data *sdata)\r\n{\r\nstruct ieee80211_roc_work *roc, *tmp;\r\nbool work_to_do = false;\r\nmutex_lock(&local->mtx);\r\nlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\r\nif (sdata && roc->sdata != sdata)\r\ncontinue;\r\nif (roc->started) {\r\nif (local->ops->remain_on_channel) {\r\ndrv_cancel_remain_on_channel(local);\r\nieee80211_roc_notify_destroy(roc);\r\n} else {\r\nroc->abort = true;\r\nwork_to_do = true;\r\n}\r\n} else {\r\nieee80211_roc_notify_destroy(roc);\r\n}\r\n}\r\nif (work_to_do)\r\n__ieee80211_roc_work(local);\r\nmutex_unlock(&local->mtx);\r\n}
