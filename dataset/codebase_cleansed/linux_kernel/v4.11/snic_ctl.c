void\r\nsnic_handle_link(struct work_struct *work)\r\n{\r\nstruct snic *snic = container_of(work, struct snic, link_work);\r\nif (snic->config.xpt_type == SNIC_DAS)\r\nreturn;\r\nsnic->link_status = svnic_dev_link_status(snic->vdev);\r\nsnic->link_down_cnt = svnic_dev_link_down_cnt(snic->vdev);\r\nSNIC_HOST_INFO(snic->shost, "Link Event: Link %s.\n",\r\n((snic->link_status) ? "Up" : "Down"));\r\nSNIC_ASSERT_NOT_IMPL(1);\r\n}\r\nstatic int\r\nsnic_ver_enc(const char *s)\r\n{\r\nint v[4] = {0};\r\nint i = 0, x = 0;\r\nchar c;\r\nconst char *p = s;\r\nif ((strlen(s) > 15) || (strlen(s) < 7))\r\ngoto end;\r\nwhile ((c = *p++)) {\r\nif (c == '.') {\r\ni++;\r\ncontinue;\r\n}\r\nif (i > 3 || !isdigit(c))\r\ngoto end;\r\nv[i] = v[i] * 10 + (c - '0');\r\n}\r\nfor (i = 3; i >= 0; i--)\r\nif (v[i] > 0xff)\r\ngoto end;\r\nx |= (v[0] << 24) | v[1] << 16 | v[2] << 8 | v[3];\r\nend:\r\nif (x == 0) {\r\nSNIC_ERR("Invalid version string [%s].\n", s);\r\nreturn -1;\r\n}\r\nreturn x;\r\n}\r\nint\r\nsnic_queue_exch_ver_req(struct snic *snic)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_host_req *req = NULL;\r\nu32 ver = 0;\r\nint ret = 0;\r\nSNIC_HOST_INFO(snic->shost, "Exch Ver Req Preparing...\n");\r\nrqi = snic_req_init(snic, 0);\r\nif (!rqi) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Queuing Exch Ver Req failed, err = %d\n",\r\nret);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nreq = rqi_to_req(rqi);\r\nsnic_io_hdr_enc(&req->hdr, SNIC_REQ_EXCH_VER, 0, SCSI_NO_TAG,\r\nsnic->config.hid, 0, (ulong)rqi);\r\nver = snic_ver_enc(SNIC_DRV_VERSION);\r\nreq->u.exch_ver.drvr_ver = cpu_to_le32(ver);\r\nreq->u.exch_ver.os_type = cpu_to_le32(SNIC_OS_LINUX);\r\nsnic_handle_untagged_req(snic, rqi);\r\nret = snic_queue_wq_desc(snic, req, sizeof(*req));\r\nif (ret) {\r\nsnic_release_untagged_req(snic, rqi);\r\nSNIC_HOST_ERR(snic->shost,\r\n"Queuing Exch Ver Req failed, err = %d\n",\r\nret);\r\ngoto error;\r\n}\r\nSNIC_HOST_INFO(snic->shost, "Exch Ver Req is issued. ret = %d\n", ret);\r\nerror:\r\nreturn ret;\r\n}\r\nint\r\nsnic_io_exch_ver_cmpl_handler(struct snic *snic, struct snic_fw_req *fwreq)\r\n{\r\nstruct snic_req_info *rqi = NULL;\r\nstruct snic_exch_ver_rsp *exv_cmpl = &fwreq->u.exch_ver_cmpl;\r\nu8 typ, hdr_stat;\r\nu32 cmnd_id, hid, max_sgs;\r\nulong ctx = 0;\r\nunsigned long flags;\r\nint ret = 0;\r\nSNIC_HOST_INFO(snic->shost, "Exch Ver Compl Received.\n");\r\nsnic_io_hdr_dec(&fwreq->hdr, &typ, &hdr_stat, &cmnd_id, &hid, &ctx);\r\nSNIC_BUG_ON(snic->config.hid != hid);\r\nrqi = (struct snic_req_info *) ctx;\r\nif (hdr_stat) {\r\nSNIC_HOST_ERR(snic->shost,\r\n"Exch Ver Completed w/ err status %d\n",\r\nhdr_stat);\r\ngoto exch_cmpl_end;\r\n}\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nsnic->fwinfo.fw_ver = le32_to_cpu(exv_cmpl->version);\r\nsnic->fwinfo.hid = le32_to_cpu(exv_cmpl->hid);\r\nsnic->fwinfo.max_concur_ios = le32_to_cpu(exv_cmpl->max_concur_ios);\r\nsnic->fwinfo.max_sgs_per_cmd = le32_to_cpu(exv_cmpl->max_sgs_per_cmd);\r\nsnic->fwinfo.max_io_sz = le32_to_cpu(exv_cmpl->max_io_sz);\r\nsnic->fwinfo.max_tgts = le32_to_cpu(exv_cmpl->max_tgts);\r\nsnic->fwinfo.io_tmo = le16_to_cpu(exv_cmpl->io_timeout);\r\nSNIC_HOST_INFO(snic->shost,\r\n"vers %u hid %u max_concur_ios %u max_sgs_per_cmd %u max_io_sz %u max_tgts %u fw tmo %u\n",\r\nsnic->fwinfo.fw_ver,\r\nsnic->fwinfo.hid,\r\nsnic->fwinfo.max_concur_ios,\r\nsnic->fwinfo.max_sgs_per_cmd,\r\nsnic->fwinfo.max_io_sz,\r\nsnic->fwinfo.max_tgts,\r\nsnic->fwinfo.io_tmo);\r\nSNIC_HOST_INFO(snic->shost,\r\n"HBA Capabilities = 0x%x\n",\r\nle32_to_cpu(exv_cmpl->hba_cap));\r\nmax_sgs = snic->fwinfo.max_sgs_per_cmd;\r\nif (max_sgs && max_sgs < SNIC_MAX_SG_DESC_CNT) {\r\nsnic->shost->sg_tablesize = max_sgs;\r\nSNIC_HOST_INFO(snic->shost, "Max SGs set to %d\n",\r\nsnic->shost->sg_tablesize);\r\n} else if (max_sgs > snic->shost->sg_tablesize) {\r\nSNIC_HOST_INFO(snic->shost,\r\n"Target type %d Supports Larger Max SGList %d than driver's Max SG List %d.\n",\r\nsnic->config.xpt_type, max_sgs,\r\nsnic->shost->sg_tablesize);\r\n}\r\nif (snic->shost->can_queue > snic->fwinfo.max_concur_ios)\r\nsnic->shost->can_queue = snic->fwinfo.max_concur_ios;\r\nsnic->shost->max_sectors = snic->fwinfo.max_io_sz >> 9;\r\nif (snic->fwinfo.wait)\r\ncomplete(snic->fwinfo.wait);\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nexch_cmpl_end:\r\nsnic_release_untagged_req(snic, rqi);\r\nSNIC_HOST_INFO(snic->shost, "Exch_cmpl Done, hdr_stat %d.\n", hdr_stat);\r\nreturn ret;\r\n}\r\nint\r\nsnic_get_conf(struct snic *snic)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(wait);\r\nunsigned long flags;\r\nint ret;\r\nint nr_retries = 3;\r\nSNIC_HOST_INFO(snic->shost, "Retrieving snic params.\n");\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nmemset(&snic->fwinfo, 0, sizeof(snic->fwinfo));\r\nsnic->fwinfo.wait = &wait;\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\nmsleep(50);\r\ndo {\r\nret = snic_queue_exch_ver_req(snic);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion_timeout(&wait, msecs_to_jiffies(2000));\r\nspin_lock_irqsave(&snic->snic_lock, flags);\r\nret = (snic->fwinfo.fw_ver != 0) ? 0 : -ETIMEDOUT;\r\nif (ret)\r\nSNIC_HOST_ERR(snic->shost,\r\n"Failed to retrieve snic params,\n");\r\nif (ret == 0 || nr_retries == 1)\r\nsnic->fwinfo.wait = NULL;\r\nspin_unlock_irqrestore(&snic->snic_lock, flags);\r\n} while (ret && --nr_retries);\r\nreturn ret;\r\n}
