blkcnt_t dirty_cnt(struct inode *inode)\r\n{\r\nblkcnt_t cnt = 0;\r\nstruct vvp_object *vob = cl_inode2vvp(inode);\r\nvoid *results[1];\r\nif (inode->i_mapping)\r\ncnt += radix_tree_gang_lookup_tag(&inode->i_mapping->page_tree,\r\nresults, 0, 1,\r\nPAGECACHE_TAG_DIRTY);\r\nif (cnt == 0 && atomic_read(&vob->vob_mmap_cnt) > 0)\r\ncnt = 1;\r\nreturn (cnt > 0) ? 1 : 0;\r\n}\r\nint cl_glimpse_lock(const struct lu_env *env, struct cl_io *io,\r\nstruct inode *inode, struct cl_object *clob, int agl)\r\n{\r\nconst struct lu_fid *fid = lu_object_fid(&clob->co_lu);\r\nstruct cl_lock *lock = vvp_env_lock(env);\r\nstruct cl_lock_descr *descr = &lock->cll_descr;\r\nint result = 0;\r\nCDEBUG(D_DLMTRACE, "Glimpsing inode " DFID "\n", PFID(fid));\r\n*descr = whole_file;\r\ndescr->cld_obj = clob;\r\ndescr->cld_mode = CLM_READ;\r\ndescr->cld_enq_flags = CEF_ASYNC | CEF_MUST;\r\nif (agl)\r\ndescr->cld_enq_flags |= CEF_AGL;\r\nresult = cl_lock_request(env, io, lock);\r\nif (result < 0)\r\nreturn result;\r\nif (!agl) {\r\nll_merge_attr(env, inode);\r\nif (i_size_read(inode) > 0 && !inode->i_blocks) {\r\ninode->i_blocks = dirty_cnt(inode);\r\n}\r\n}\r\ncl_lock_release(env, lock);\r\nreturn result;\r\n}\r\nstatic int cl_io_get(struct inode *inode, struct lu_env **envout,\r\nstruct cl_io **ioout, int *refcheck)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_io *io;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct cl_object *clob = lli->lli_clob;\r\nint result;\r\nif (S_ISREG(inode->i_mode)) {\r\nenv = cl_env_get(refcheck);\r\nif (!IS_ERR(env)) {\r\nio = vvp_env_thread_io(env);\r\nio->ci_obj = clob;\r\n*envout = env;\r\n*ioout = io;\r\nresult = 1;\r\n} else {\r\nresult = PTR_ERR(env);\r\n}\r\n} else {\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nint cl_glimpse_size0(struct inode *inode, int agl)\r\n{\r\nstruct lu_env *env = NULL;\r\nstruct cl_io *io = NULL;\r\nint result;\r\nint refcheck;\r\nresult = cl_io_get(inode, &env, &io, &refcheck);\r\nif (result > 0) {\r\nagain:\r\nio->ci_verify_layout = 1;\r\nresult = cl_io_init(env, io, CIT_MISC, io->ci_obj);\r\nif (result > 0)\r\nresult = io->ci_result;\r\nelse if (result == 0)\r\nresult = cl_glimpse_lock(env, io, inode, io->ci_obj,\r\nagl);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_GLIMPSE_DELAY, 2);\r\ncl_io_fini(env, io);\r\nif (unlikely(io->ci_need_restart))\r\ngoto again;\r\ncl_env_put(env, &refcheck);\r\n}\r\nreturn result;\r\n}
