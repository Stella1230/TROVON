static struct phy_led_trigger *phy_speed_to_led_trigger(struct phy_device *phy,\r\nunsigned int speed)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < phy->phy_num_led_triggers; i++) {\r\nif (phy->phy_led_triggers[i].speed == speed)\r\nreturn &phy->phy_led_triggers[i];\r\n}\r\nreturn NULL;\r\n}\r\nvoid phy_led_trigger_change_speed(struct phy_device *phy)\r\n{\r\nstruct phy_led_trigger *plt;\r\nif (!phy->link)\r\ngoto out_change_speed;\r\nif (phy->speed == 0)\r\nreturn;\r\nplt = phy_speed_to_led_trigger(phy, phy->speed);\r\nif (!plt) {\r\nnetdev_alert(phy->attached_dev,\r\n"No phy led trigger registered for speed(%d)\n",\r\nphy->speed);\r\ngoto out_change_speed;\r\n}\r\nif (plt != phy->last_triggered) {\r\nled_trigger_event(&phy->last_triggered->trigger, LED_OFF);\r\nled_trigger_event(&plt->trigger, LED_FULL);\r\nphy->last_triggered = plt;\r\n}\r\nreturn;\r\nout_change_speed:\r\nif (phy->last_triggered) {\r\nled_trigger_event(&phy->last_triggered->trigger,\r\nLED_OFF);\r\nphy->last_triggered = NULL;\r\n}\r\n}\r\nstatic int phy_led_trigger_register(struct phy_device *phy,\r\nstruct phy_led_trigger *plt,\r\nunsigned int speed)\r\n{\r\nchar name_suffix[PHY_LED_TRIGGER_SPEED_SUFFIX_SIZE];\r\nplt->speed = speed;\r\nif (speed < SPEED_1000)\r\nsnprintf(name_suffix, sizeof(name_suffix), "%dMbps", speed);\r\nelse if (speed == SPEED_2500)\r\nsnprintf(name_suffix, sizeof(name_suffix), "2.5Gbps");\r\nelse\r\nsnprintf(name_suffix, sizeof(name_suffix), "%dGbps",\r\nDIV_ROUND_CLOSEST(speed, 1000));\r\nsnprintf(plt->name, sizeof(plt->name), PHY_ID_FMT ":%s",\r\nphy->mdio.bus->id, phy->mdio.addr, name_suffix);\r\nplt->trigger.name = plt->name;\r\nreturn led_trigger_register(&plt->trigger);\r\n}\r\nstatic void phy_led_trigger_unregister(struct phy_led_trigger *plt)\r\n{\r\nled_trigger_unregister(&plt->trigger);\r\n}\r\nint phy_led_triggers_register(struct phy_device *phy)\r\n{\r\nint i, err;\r\nunsigned int speeds[50];\r\nphy->phy_num_led_triggers = phy_supported_speeds(phy, speeds,\r\nARRAY_SIZE(speeds));\r\nif (!phy->phy_num_led_triggers)\r\nreturn 0;\r\nphy->phy_led_triggers = devm_kzalloc(&phy->mdio.dev,\r\nsizeof(struct phy_led_trigger) *\r\nphy->phy_num_led_triggers,\r\nGFP_KERNEL);\r\nif (!phy->phy_led_triggers) {\r\nerr = -ENOMEM;\r\ngoto out_clear;\r\n}\r\nfor (i = 0; i < phy->phy_num_led_triggers; i++) {\r\nerr = phy_led_trigger_register(phy, &phy->phy_led_triggers[i],\r\nspeeds[i]);\r\nif (err)\r\ngoto out_unreg;\r\n}\r\nphy->last_triggered = NULL;\r\nphy_led_trigger_change_speed(phy);\r\nreturn 0;\r\nout_unreg:\r\nwhile (i--)\r\nphy_led_trigger_unregister(&phy->phy_led_triggers[i]);\r\ndevm_kfree(&phy->mdio.dev, phy->phy_led_triggers);\r\nout_clear:\r\nphy->phy_num_led_triggers = 0;\r\nreturn err;\r\n}\r\nvoid phy_led_triggers_unregister(struct phy_device *phy)\r\n{\r\nint i;\r\nfor (i = 0; i < phy->phy_num_led_triggers; i++)\r\nphy_led_trigger_unregister(&phy->phy_led_triggers[i]);\r\n}
