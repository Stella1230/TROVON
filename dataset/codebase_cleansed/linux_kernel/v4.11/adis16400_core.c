static ssize_t adis16400_show_serial_number(struct file *file,\r\nchar __user *userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct adis16400_state *st = file->private_data;\r\nu16 lot1, lot2, serial_number;\r\nchar buf[16];\r\nsize_t len;\r\nint ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID1, &lot1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID2, &lot2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16334_SERIAL_NUMBER,\r\n&serial_number);\r\nif (ret < 0)\r\nreturn ret;\r\nlen = snprintf(buf, sizeof(buf), "%.4x-%.4x-%.4x\n", lot1, lot2,\r\nserial_number);\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\r\n}\r\nstatic int adis16400_show_product_id(void *arg, u64 *val)\r\n{\r\nstruct adis16400_state *st = arg;\r\nuint16_t prod_id;\r\nint ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16400_PRODUCT_ID, &prod_id);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = prod_id;\r\nreturn 0;\r\n}\r\nstatic int adis16400_show_flash_count(void *arg, u64 *val)\r\n{\r\nstruct adis16400_state *st = arg;\r\nuint16_t flash_count;\r\nint ret;\r\nret = adis_read_reg_16(&st->adis, ADIS16400_FLASH_CNT, &flash_count);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = flash_count;\r\nreturn 0;\r\n}\r\nstatic int adis16400_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nif (st->variant->flags & ADIS16400_HAS_SERIAL_NUMBER)\r\ndebugfs_create_file("serial_number", 0400,\r\nindio_dev->debugfs_dentry, st,\r\n&adis16400_serial_number_fops);\r\nif (st->variant->flags & ADIS16400_HAS_PROD_ID)\r\ndebugfs_create_file("product_id", 0400,\r\nindio_dev->debugfs_dentry, st,\r\n&adis16400_product_id_fops);\r\ndebugfs_create_file("flash_count", 0400, indio_dev->debugfs_dentry,\r\nst, &adis16400_flash_count_fops);\r\nreturn 0;\r\n}\r\nstatic int adis16400_debugfs_init(struct iio_dev *indio_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int adis16334_get_freq(struct adis16400_state *st)\r\n{\r\nint ret;\r\nuint16_t t;\r\nret = adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &t);\r\nif (ret < 0)\r\nreturn ret;\r\nt >>= ADIS16334_RATE_DIV_SHIFT;\r\nreturn 819200 >> t;\r\n}\r\nstatic int adis16334_set_freq(struct adis16400_state *st, unsigned int freq)\r\n{\r\nunsigned int t;\r\nif (freq < 819200)\r\nt = ilog2(819200 / freq);\r\nelse\r\nt = 0;\r\nif (t > 0x31)\r\nt = 0x31;\r\nt <<= ADIS16334_RATE_DIV_SHIFT;\r\nt |= ADIS16334_RATE_INT_CLK;\r\nreturn adis_write_reg_16(&st->adis, ADIS16400_SMPL_PRD, t);\r\n}\r\nstatic int adis16400_get_freq(struct adis16400_state *st)\r\n{\r\nint sps, ret;\r\nuint16_t t;\r\nret = adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &t);\r\nif (ret < 0)\r\nreturn ret;\r\nsps = (t & ADIS16400_SMPL_PRD_TIME_BASE) ? 52851 : 1638404;\r\nsps /= (t & ADIS16400_SMPL_PRD_DIV_MASK) + 1;\r\nreturn sps;\r\n}\r\nstatic int adis16400_set_freq(struct adis16400_state *st, unsigned int freq)\r\n{\r\nunsigned int t;\r\nuint8_t val = 0;\r\nt = 1638404 / freq;\r\nif (t >= 128) {\r\nval |= ADIS16400_SMPL_PRD_TIME_BASE;\r\nt = 52851 / freq;\r\nif (t >= 128)\r\nt = 127;\r\n} else if (t != 0) {\r\nt--;\r\n}\r\nval |= t;\r\nif (t >= 0x0A || (val & ADIS16400_SMPL_PRD_TIME_BASE))\r\nst->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;\r\nelse\r\nst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\r\nreturn adis_write_reg_8(&st->adis, ADIS16400_SMPL_PRD, val);\r\n}\r\nstatic int adis16400_set_filter(struct iio_dev *indio_dev, int sps, int val)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nuint16_t val16;\r\nint i, ret;\r\nfor (i = ARRAY_SIZE(adis16400_3db_divisors) - 1; i >= 1; i--) {\r\nif (sps / adis16400_3db_divisors[i] >= val)\r\nbreak;\r\n}\r\nret = adis_read_reg_16(&st->adis, ADIS16400_SENS_AVG, &val16);\r\nif (ret < 0)\r\nreturn ret;\r\nret = adis_write_reg_16(&st->adis, ADIS16400_SENS_AVG,\r\n(val16 & ~0x07) | i);\r\nreturn ret;\r\n}\r\nstatic int adis16400_stop_device(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nint ret;\r\nret = adis_write_reg_16(&st->adis, ADIS16400_SLP_CNT,\r\nADIS16400_SLP_CNT_POWER_OFF);\r\nif (ret)\r\ndev_err(&indio_dev->dev,\r\n"problem with turning device off: SLP_CNT");\r\nreturn ret;\r\n}\r\nstatic int adis16400_initial_setup(struct iio_dev *indio_dev)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nuint16_t prod_id, smp_prd;\r\nunsigned int device_id;\r\nint ret;\r\nif (st->variant->flags & ADIS16400_HAS_SLOW_MODE)\r\nst->adis.spi->max_speed_hz = ADIS16400_SPI_SLOW;\r\nelse\r\nst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\r\nst->adis.spi->mode = SPI_MODE_3;\r\nspi_setup(st->adis.spi);\r\nret = adis_initial_startup(&st->adis);\r\nif (ret)\r\nreturn ret;\r\nif (st->variant->flags & ADIS16400_HAS_PROD_ID) {\r\nret = adis_read_reg_16(&st->adis,\r\nADIS16400_PRODUCT_ID, &prod_id);\r\nif (ret)\r\ngoto err_ret;\r\nret = sscanf(indio_dev->name, "adis%u\n", &device_id);\r\nif (ret != 1) {\r\nret = -EINVAL;\r\ngoto err_ret;\r\n}\r\nif (prod_id != device_id)\r\ndev_warn(&indio_dev->dev, "Device ID(%u) and product ID(%u) do not match.",\r\ndevice_id, prod_id);\r\ndev_info(&indio_dev->dev, "%s: prod_id 0x%04x at CS%d (irq %d)\n",\r\nindio_dev->name, prod_id,\r\nst->adis.spi->chip_select, st->adis.spi->irq);\r\n}\r\nif (st->variant->flags & ADIS16400_HAS_SLOW_MODE) {\r\nret = adis_read_reg_16(&st->adis, ADIS16400_SMPL_PRD, &smp_prd);\r\nif (ret)\r\ngoto err_ret;\r\nif ((smp_prd & ADIS16400_SMPL_PRD_DIV_MASK) < 0x0A) {\r\nst->adis.spi->max_speed_hz = ADIS16400_SPI_FAST;\r\nspi_setup(st->adis.spi);\r\n}\r\n}\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int adis16400_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long info)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nint ret, sps;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis_write_reg_16(&st->adis,\r\nadis16400_addresses[chan->scan_index], val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nmutex_lock(&indio_dev->mlock);\r\nst->filt_int = val;\r\nsps = st->variant->get_freq(st);\r\nif (sps < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn sps;\r\n}\r\nret = adis16400_set_filter(indio_dev, sps,\r\nval * 1000 + val2 / 1000);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nsps = val * 1000 + val2 / 1000;\r\nif (sps <= 0)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = st->variant->set_freq(st, sps);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int adis16400_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long info)\r\n{\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\nint16_t val16;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn adis_single_conversion(indio_dev, chan, 0, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = 0;\r\n*val2 = st->variant->gyro_scale_micro;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_VOLTAGE:\r\n*val = 0;\r\nif (chan->channel == 0) {\r\n*val = 2;\r\n*val2 = 418000;\r\n} else {\r\n*val = 0;\r\n*val2 = 805800;\r\n}\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_ACCEL:\r\n*val = 0;\r\n*val2 = st->variant->accel_scale_micro;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_MAGN:\r\n*val = 0;\r\n*val2 = 500;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = st->variant->temp_scale_nano / 1000000;\r\n*val2 = (st->variant->temp_scale_nano % 1000000);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_PRESSURE:\r\n*val = 0;\r\n*val2 = 2000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis_read_reg_16(&st->adis,\r\nadis16400_addresses[chan->scan_index], &val16);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret)\r\nreturn ret;\r\nval16 = sign_extend32(val16, 11);\r\n*val = val16;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = st->variant->temp_offset;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY:\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis_read_reg_16(&st->adis,\r\nADIS16400_SENS_AVG,\r\n&val16);\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nret = st->variant->get_freq(st);\r\nif (ret >= 0) {\r\nret /= adis16400_3db_divisors[val16 & 0x07];\r\n*val = ret / 1000;\r\n*val2 = (ret % 1000) * 1000;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nret = st->variant->get_freq(st);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret / 1000;\r\n*val2 = (ret % 1000) * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void adis16400_setup_chan_mask(struct adis16400_state *st)\r\n{\r\nconst struct adis16400_chip_info *chip_info = st->variant;\r\nunsigned i;\r\nfor (i = 0; i < chip_info->num_channels; i++) {\r\nconst struct iio_chan_spec *ch = &chip_info->channels[i];\r\nif (ch->scan_index >= 0 &&\r\nch->scan_index != ADIS16400_SCAN_TIMESTAMP)\r\nst->avail_scan_mask[0] |= BIT(ch->scan_index);\r\n}\r\n}\r\nstatic int adis16400_probe(struct spi_device *spi)\r\n{\r\nstruct adis16400_state *st;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->variant = &adis16400_chips[spi_get_device_id(spi)->driver_data];\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->channels = st->variant->channels;\r\nindio_dev->num_channels = st->variant->num_channels;\r\nindio_dev->info = &adis16400_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (!(st->variant->flags & ADIS16400_NO_BURST)) {\r\nadis16400_setup_chan_mask(st);\r\nindio_dev->available_scan_masks = st->avail_scan_mask;\r\n}\r\nret = adis_init(&st->adis, indio_dev, spi, &adis16400_data);\r\nif (ret)\r\nreturn ret;\r\nret = adis_setup_buffer_and_trigger(&st->adis, indio_dev,\r\nadis16400_trigger_handler);\r\nif (ret)\r\nreturn ret;\r\nret = adis16400_initial_setup(indio_dev);\r\nif (ret)\r\ngoto error_cleanup_buffer;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_cleanup_buffer;\r\nadis16400_debugfs_init(indio_dev);\r\nreturn 0;\r\nerror_cleanup_buffer:\r\nadis_cleanup_buffer_and_trigger(&st->adis, indio_dev);\r\nreturn ret;\r\n}\r\nstatic int adis16400_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct adis16400_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nadis16400_stop_device(indio_dev);\r\nadis_cleanup_buffer_and_trigger(&st->adis, indio_dev);\r\nreturn 0;\r\n}
