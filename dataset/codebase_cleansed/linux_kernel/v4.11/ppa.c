static inline ppa_struct *ppa_dev(struct Scsi_Host *host)\r\n{\r\nreturn *(ppa_struct **)&host->hostdata;\r\n}\r\nstatic void got_it(ppa_struct *dev)\r\n{\r\ndev->base = dev->dev->port->base;\r\nif (dev->cur_cmd)\r\ndev->cur_cmd->SCp.phase = 1;\r\nelse\r\nwake_up(dev->waiting);\r\n}\r\nstatic void ppa_wakeup(void *ref)\r\n{\r\nppa_struct *dev = (ppa_struct *) ref;\r\nunsigned long flags;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nif (dev->wanted) {\r\nparport_claim(dev->dev);\r\ngot_it(dev);\r\ndev->wanted = 0;\r\n}\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\nreturn;\r\n}\r\nstatic int ppa_pb_claim(ppa_struct *dev)\r\n{\r\nunsigned long flags;\r\nint res = 1;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nif (parport_claim(dev->dev) == 0) {\r\ngot_it(dev);\r\nres = 0;\r\n}\r\ndev->wanted = res;\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\nreturn res;\r\n}\r\nstatic void ppa_pb_dismiss(ppa_struct *dev)\r\n{\r\nunsigned long flags;\r\nint wanted;\r\nspin_lock_irqsave(&arbitration_lock, flags);\r\nwanted = dev->wanted;\r\ndev->wanted = 0;\r\nspin_unlock_irqrestore(&arbitration_lock, flags);\r\nif (!wanted)\r\nparport_release(dev->dev);\r\n}\r\nstatic inline void ppa_pb_release(ppa_struct *dev)\r\n{\r\nparport_release(dev->dev);\r\n}\r\nstatic inline int ppa_write_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nppa_struct *dev = ppa_dev(host);\r\nunsigned long x;\r\nif ((length > 5) && (strncmp(buffer, "mode=", 5) == 0)) {\r\nx = simple_strtoul(buffer + 5, NULL, 0);\r\ndev->mode = x;\r\nreturn length;\r\n}\r\nif ((length > 10) && (strncmp(buffer, "recon_tmo=", 10) == 0)) {\r\nx = simple_strtoul(buffer + 10, NULL, 0);\r\ndev->recon_tmo = x;\r\nprintk(KERN_INFO "ppa: recon_tmo set to %ld\n", x);\r\nreturn length;\r\n}\r\nprintk(KERN_WARNING "ppa /proc: invalid variable\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int ppa_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nppa_struct *dev = ppa_dev(host);\r\nseq_printf(m, "Version : %s\n", PPA_VERSION);\r\nseq_printf(m, "Parport : %s\n", dev->dev->port->name);\r\nseq_printf(m, "Mode : %s\n", PPA_MODE_STRING[dev->mode]);\r\n#if PPA_DEBUG > 0\r\nseq_printf(m, "recon_tmo : %lu\n", dev->recon_tmo);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic unsigned char ppa_wait(ppa_struct *dev)\r\n{\r\nint k;\r\nunsigned short ppb = dev->base;\r\nunsigned char r;\r\nk = PPA_SPIN_TMO;\r\nfor (r = r_str(ppb); ((r & 0xc0) != 0xc0) && (k); k--) {\r\nudelay(1);\r\nr = r_str(ppb);\r\n}\r\nif (k)\r\nreturn (r & 0xf0);\r\nppa_fail(dev, DID_TIME_OUT);\r\nprintk(KERN_WARNING "ppa timeout in ppa_wait\n");\r\nreturn 0;\r\n}\r\nstatic inline void epp_reset(unsigned short ppb)\r\n{\r\nint i;\r\ni = r_str(ppb);\r\nw_str(ppb, i);\r\nw_str(ppb, i & 0xfe);\r\n}\r\nstatic inline void ecp_sync(ppa_struct *dev)\r\n{\r\nint i, ppb_hi = dev->dev->port->base_hi;\r\nif (ppb_hi == 0)\r\nreturn;\r\nif ((r_ecr(ppb_hi) & 0xe0) == 0x60) {\r\nfor (i = 0; i < 100; i++) {\r\nif (r_ecr(ppb_hi) & 0x01)\r\nreturn;\r\nudelay(5);\r\n}\r\nprintk(KERN_WARNING "ppa: ECP sync failed as data still present in FIFO.\n");\r\n}\r\n}\r\nstatic int ppa_byte_out(unsigned short base, const char *buffer, int len)\r\n{\r\nint i;\r\nfor (i = len; i; i--) {\r\nw_dtr(base, *buffer++);\r\nw_ctr(base, 0xe);\r\nw_ctr(base, 0xc);\r\n}\r\nreturn 1;\r\n}\r\nstatic int ppa_byte_in(unsigned short base, char *buffer, int len)\r\n{\r\nint i;\r\nfor (i = len; i; i--) {\r\n*buffer++ = r_dtr(base);\r\nw_ctr(base, 0x27);\r\nw_ctr(base, 0x25);\r\n}\r\nreturn 1;\r\n}\r\nstatic int ppa_nibble_in(unsigned short base, char *buffer, int len)\r\n{\r\nfor (; len; len--) {\r\nunsigned char h;\r\nw_ctr(base, 0x4);\r\nh = r_str(base) & 0xf0;\r\nw_ctr(base, 0x6);\r\n*buffer++ = h | ((r_str(base) & 0xf0) >> 4);\r\n}\r\nreturn 1;\r\n}\r\nstatic int ppa_out(ppa_struct *dev, char *buffer, int len)\r\n{\r\nint r;\r\nunsigned short ppb = dev->base;\r\nr = ppa_wait(dev);\r\nif ((r & 0x50) != 0x40) {\r\nppa_fail(dev, DID_ERROR);\r\nreturn 0;\r\n}\r\nswitch (dev->mode) {\r\ncase PPA_NIBBLE:\r\ncase PPA_PS2:\r\nr = ppa_byte_out(ppb, buffer, len);\r\nbreak;\r\ncase PPA_EPP_32:\r\ncase PPA_EPP_16:\r\ncase PPA_EPP_8:\r\nepp_reset(ppb);\r\nw_ctr(ppb, 0x4);\r\n#ifdef CONFIG_SCSI_IZIP_EPP16\r\nif (!(((long) buffer | len) & 0x01))\r\noutsw(ppb + 4, buffer, len >> 1);\r\n#else\r\nif (!(((long) buffer | len) & 0x03))\r\noutsl(ppb + 4, buffer, len >> 2);\r\n#endif\r\nelse\r\noutsb(ppb + 4, buffer, len);\r\nw_ctr(ppb, 0xc);\r\nr = !(r_str(ppb) & 0x01);\r\nw_ctr(ppb, 0xc);\r\necp_sync(dev);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "PPA: bug in ppa_out()\n");\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int ppa_in(ppa_struct *dev, char *buffer, int len)\r\n{\r\nint r;\r\nunsigned short ppb = dev->base;\r\nr = ppa_wait(dev);\r\nif ((r & 0x50) != 0x50) {\r\nppa_fail(dev, DID_ERROR);\r\nreturn 0;\r\n}\r\nswitch (dev->mode) {\r\ncase PPA_NIBBLE:\r\nr = ppa_nibble_in(ppb, buffer, len);\r\nw_ctr(ppb, 0xc);\r\nbreak;\r\ncase PPA_PS2:\r\nw_ctr(ppb, 0x25);\r\nr = ppa_byte_in(ppb, buffer, len);\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0xc);\r\nbreak;\r\ncase PPA_EPP_32:\r\ncase PPA_EPP_16:\r\ncase PPA_EPP_8:\r\nepp_reset(ppb);\r\nw_ctr(ppb, 0x24);\r\n#ifdef CONFIG_SCSI_IZIP_EPP16\r\nif (!(((long) buffer | len) & 0x01))\r\ninsw(ppb + 4, buffer, len >> 1);\r\n#else\r\nif (!(((long) buffer | len) & 0x03))\r\ninsl(ppb + 4, buffer, len >> 2);\r\n#endif\r\nelse\r\ninsb(ppb + 4, buffer, len);\r\nw_ctr(ppb, 0x2c);\r\nr = !(r_str(ppb) & 0x01);\r\nw_ctr(ppb, 0x2c);\r\necp_sync(dev);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "PPA: bug in ppa_ins()\n");\r\nr = 0;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic inline void ppa_d_pulse(unsigned short ppb, unsigned char b)\r\n{\r\nw_dtr(ppb, b);\r\nw_ctr(ppb, 0xc);\r\nw_ctr(ppb, 0xe);\r\nw_ctr(ppb, 0xc);\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0xc);\r\n}\r\nstatic void ppa_disconnect(ppa_struct *dev)\r\n{\r\nunsigned short ppb = dev->base;\r\nppa_d_pulse(ppb, 0);\r\nppa_d_pulse(ppb, 0x3c);\r\nppa_d_pulse(ppb, 0x20);\r\nppa_d_pulse(ppb, 0xf);\r\n}\r\nstatic inline void ppa_c_pulse(unsigned short ppb, unsigned char b)\r\n{\r\nw_dtr(ppb, b);\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0x6);\r\nw_ctr(ppb, 0x4);\r\nw_ctr(ppb, 0xc);\r\n}\r\nstatic inline void ppa_connect(ppa_struct *dev, int flag)\r\n{\r\nunsigned short ppb = dev->base;\r\nppa_c_pulse(ppb, 0);\r\nppa_c_pulse(ppb, 0x3c);\r\nppa_c_pulse(ppb, 0x20);\r\nif ((flag == CONNECT_EPP_MAYBE) && IN_EPP_MODE(dev->mode))\r\nppa_c_pulse(ppb, 0xcf);\r\nelse\r\nppa_c_pulse(ppb, 0x8f);\r\n}\r\nstatic int ppa_select(ppa_struct *dev, int target)\r\n{\r\nint k;\r\nunsigned short ppb = dev->base;\r\nk = PPA_SELECT_TMO;\r\ndo {\r\nk--;\r\nudelay(1);\r\n} while ((r_str(ppb) & 0x40) && (k));\r\nif (!k)\r\nreturn 0;\r\nw_dtr(ppb, (1 << target));\r\nw_ctr(ppb, 0xe);\r\nw_ctr(ppb, 0xc);\r\nw_dtr(ppb, 0x80);\r\nw_ctr(ppb, 0x8);\r\nk = PPA_SELECT_TMO;\r\ndo {\r\nk--;\r\nudelay(1);\r\n}\r\nwhile (!(r_str(ppb) & 0x40) && (k));\r\nif (!k)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ppa_init(ppa_struct *dev)\r\n{\r\nint retv;\r\nunsigned short ppb = dev->base;\r\nppa_disconnect(dev);\r\nppa_connect(dev, CONNECT_NORMAL);\r\nretv = 2;\r\nw_ctr(ppb, 0xe);\r\nif ((r_str(ppb) & 0x08) == 0x08)\r\nretv--;\r\nw_ctr(ppb, 0xc);\r\nif ((r_str(ppb) & 0x08) == 0x00)\r\nretv--;\r\nif (!retv)\r\nppa_reset_pulse(ppb);\r\nudelay(1000);\r\nppa_disconnect(dev);\r\nudelay(1000);\r\nif (retv)\r\nreturn -EIO;\r\nreturn device_check(dev);\r\n}\r\nstatic inline int ppa_send_command(struct scsi_cmnd *cmd)\r\n{\r\nppa_struct *dev = ppa_dev(cmd->device->host);\r\nint k;\r\nw_ctr(dev->base, 0x0c);\r\nfor (k = 0; k < cmd->cmd_len; k++)\r\nif (!ppa_out(dev, &cmd->cmnd[k], 1))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ppa_completion(struct scsi_cmnd *cmd)\r\n{\r\nppa_struct *dev = ppa_dev(cmd->device->host);\r\nunsigned short ppb = dev->base;\r\nunsigned long start_jiffies = jiffies;\r\nunsigned char r, v;\r\nint fast, bulk, status;\r\nv = cmd->cmnd[0];\r\nbulk = ((v == READ_6) ||\r\n(v == READ_10) || (v == WRITE_6) || (v == WRITE_10));\r\nr = (r_str(ppb) & 0xf0);\r\nwhile (r != (unsigned char) 0xf0) {\r\nif (time_after(jiffies, start_jiffies + 1))\r\nreturn 0;\r\nif ((cmd->SCp.this_residual <= 0)) {\r\nppa_fail(dev, DID_ERROR);\r\nreturn -1;\r\n}\r\nif ((r & 0xc0) != 0xc0) {\r\nunsigned long k = dev->recon_tmo;\r\nfor (; k && ((r = (r_str(ppb) & 0xf0)) & 0xc0) != 0xc0;\r\nk--)\r\nudelay(1);\r\nif (!k)\r\nreturn 0;\r\n}\r\nfast = (bulk && (cmd->SCp.this_residual >= PPA_BURST_SIZE))\r\n? PPA_BURST_SIZE : 1;\r\nif (r == (unsigned char) 0xc0)\r\nstatus = ppa_out(dev, cmd->SCp.ptr, fast);\r\nelse\r\nstatus = ppa_in(dev, cmd->SCp.ptr, fast);\r\ncmd->SCp.ptr += fast;\r\ncmd->SCp.this_residual -= fast;\r\nif (!status) {\r\nppa_fail(dev, DID_BUS_BUSY);\r\nreturn -1;\r\n}\r\nif (cmd->SCp.buffer && !cmd->SCp.this_residual) {\r\nif (cmd->SCp.buffers_residual--) {\r\ncmd->SCp.buffer++;\r\ncmd->SCp.this_residual =\r\ncmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\n}\r\n}\r\nr = (r_str(ppb) & 0xf0);\r\nif (!(r & 0x80))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void ppa_interrupt(struct work_struct *work)\r\n{\r\nppa_struct *dev = container_of(work, ppa_struct, ppa_tq.work);\r\nstruct scsi_cmnd *cmd = dev->cur_cmd;\r\nif (!cmd) {\r\nprintk(KERN_ERR "PPA: bug in ppa_interrupt\n");\r\nreturn;\r\n}\r\nif (ppa_engine(dev, cmd)) {\r\nschedule_delayed_work(&dev->ppa_tq, 1);\r\nreturn;\r\n}\r\n#if PPA_DEBUG > 0\r\nswitch ((cmd->result >> 16) & 0xff) {\r\ncase DID_OK:\r\nbreak;\r\ncase DID_NO_CONNECT:\r\nprintk(KERN_DEBUG "ppa: no device at SCSI ID %i\n", cmd->device->target);\r\nbreak;\r\ncase DID_BUS_BUSY:\r\nprintk(KERN_DEBUG "ppa: BUS BUSY - EPP timeout detected\n");\r\nbreak;\r\ncase DID_TIME_OUT:\r\nprintk(KERN_DEBUG "ppa: unknown timeout\n");\r\nbreak;\r\ncase DID_ABORT:\r\nprintk(KERN_DEBUG "ppa: told to abort\n");\r\nbreak;\r\ncase DID_PARITY:\r\nprintk(KERN_DEBUG "ppa: parity error (???)\n");\r\nbreak;\r\ncase DID_ERROR:\r\nprintk(KERN_DEBUG "ppa: internal driver error\n");\r\nbreak;\r\ncase DID_RESET:\r\nprintk(KERN_DEBUG "ppa: told to reset device\n");\r\nbreak;\r\ncase DID_BAD_INTR:\r\nprintk(KERN_WARNING "ppa: bad interrupt (???)\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "ppa: bad return code (%02x)\n",\r\n(cmd->result >> 16) & 0xff);\r\n}\r\n#endif\r\nif (cmd->SCp.phase > 1)\r\nppa_disconnect(dev);\r\nppa_pb_dismiss(dev);\r\ndev->cur_cmd = NULL;\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int ppa_engine(ppa_struct *dev, struct scsi_cmnd *cmd)\r\n{\r\nunsigned short ppb = dev->base;\r\nunsigned char l = 0, h = 0;\r\nint retv;\r\nif (dev->failed)\r\nreturn 0;\r\nswitch (cmd->SCp.phase) {\r\ncase 0:\r\nif (time_after(jiffies, dev->jstart + HZ)) {\r\nppa_fail(dev, DID_BUS_BUSY);\r\nreturn 0;\r\n}\r\nreturn 1;\r\ncase 1:\r\n{\r\nint retv = 2;\r\nppa_connect(dev, CONNECT_EPP_MAYBE);\r\nw_ctr(ppb, 0xe);\r\nif ((r_str(ppb) & 0x08) == 0x08)\r\nretv--;\r\nw_ctr(ppb, 0xc);\r\nif ((r_str(ppb) & 0x08) == 0x00)\r\nretv--;\r\nif (retv) {\r\nif (time_after(jiffies, dev->jstart + (1 * HZ))) {\r\nprintk(KERN_ERR "ppa: Parallel port cable is unplugged.\n");\r\nppa_fail(dev, DID_BUS_BUSY);\r\nreturn 0;\r\n} else {\r\nppa_disconnect(dev);\r\nreturn 1;\r\n}\r\n}\r\ncmd->SCp.phase++;\r\n}\r\ncase 2:\r\nif (!ppa_select(dev, scmd_id(cmd))) {\r\nppa_fail(dev, DID_NO_CONNECT);\r\nreturn 0;\r\n}\r\ncmd->SCp.phase++;\r\ncase 3:\r\nw_ctr(ppb, 0x0c);\r\nif (!(r_str(ppb) & 0x80))\r\nreturn 1;\r\nif (!ppa_send_command(cmd))\r\nreturn 0;\r\ncmd->SCp.phase++;\r\ncase 4:\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.this_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\n}\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.phase++;\r\ncase 5:\r\nw_ctr(ppb, 0x0c);\r\nif (!(r_str(ppb) & 0x80))\r\nreturn 1;\r\nretv = ppa_completion(cmd);\r\nif (retv == -1)\r\nreturn 0;\r\nif (retv == 0)\r\nreturn 1;\r\ncmd->SCp.phase++;\r\ncase 6:\r\ncmd->result = DID_OK << 16;\r\nif (ppa_wait(dev) != (unsigned char) 0xf0) {\r\nppa_fail(dev, DID_ERROR);\r\nreturn 0;\r\n}\r\nif (ppa_in(dev, &l, 1)) {\r\nif (ppa_wait(dev) == (unsigned char) 0xf0)\r\nppa_in(dev, &h, 1);\r\ncmd->result =\r\n(DID_OK << 16) + (h << 8) + (l & STATUS_MASK);\r\n}\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "ppa: Invalid scsi phase\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ppa_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nppa_struct *dev = ppa_dev(cmd->device->host);\r\nif (dev->cur_cmd) {\r\nprintk(KERN_ERR "PPA: bug in ppa_queuecommand\n");\r\nreturn 0;\r\n}\r\ndev->failed = 0;\r\ndev->jstart = jiffies;\r\ndev->cur_cmd = cmd;\r\ncmd->scsi_done = done;\r\ncmd->result = DID_ERROR << 16;\r\ncmd->SCp.phase = 0;\r\nschedule_delayed_work(&dev->ppa_tq, 0);\r\nppa_pb_claim(dev);\r\nreturn 0;\r\n}\r\nint ppa_abort(struct scsi_cmnd *cmd)\r\n{\r\nppa_struct *dev = ppa_dev(cmd->device->host);\r\nswitch (cmd->SCp.phase) {\r\ncase 0:\r\ncase 1:\r\ndev->cur_cmd = NULL;\r\nreturn SUCCESS;\r\nbreak;\r\ndefault:\r\nreturn FAILED;\r\nbreak;\r\n}\r\n}\r\nstatic void ppa_reset_pulse(unsigned int base)\r\n{\r\nw_dtr(base, 0x40);\r\nw_ctr(base, 0x8);\r\nudelay(30);\r\nw_ctr(base, 0xc);\r\n}\r\nstatic int ppa_reset(struct scsi_cmnd *cmd)\r\n{\r\nppa_struct *dev = ppa_dev(cmd->device->host);\r\nif (cmd->SCp.phase)\r\nppa_disconnect(dev);\r\ndev->cur_cmd = NULL;\r\nppa_connect(dev, CONNECT_NORMAL);\r\nppa_reset_pulse(dev->base);\r\nmdelay(1);\r\nppa_disconnect(dev);\r\nmdelay(1);\r\nreturn SUCCESS;\r\n}\r\nstatic int device_check(ppa_struct *dev)\r\n{\r\nstatic u8 cmd[6] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\r\nint loop, old_mode, status, k, ppb = dev->base;\r\nunsigned char l;\r\nold_mode = dev->mode;\r\nfor (loop = 0; loop < 8; loop++) {\r\nif ((ppb & 0x0007) == 0x0000)\r\ndev->mode = PPA_EPP_32;\r\nsecond_pass:\r\nppa_connect(dev, CONNECT_EPP_MAYBE);\r\nif (!ppa_select(dev, loop)) {\r\nppa_disconnect(dev);\r\ncontinue;\r\n}\r\nprintk(KERN_INFO "ppa: Found device at ID %i, Attempting to use %s\n",\r\nloop, PPA_MODE_STRING[dev->mode]);\r\nstatus = 1;\r\nw_ctr(ppb, 0x0c);\r\nfor (l = 0; (l < 6) && (status); l++)\r\nstatus = ppa_out(dev, cmd, 1);\r\nif (!status) {\r\nppa_disconnect(dev);\r\nppa_connect(dev, CONNECT_EPP_MAYBE);\r\nw_dtr(ppb, 0x40);\r\nw_ctr(ppb, 0x08);\r\nudelay(30);\r\nw_ctr(ppb, 0x0c);\r\nudelay(1000);\r\nppa_disconnect(dev);\r\nudelay(1000);\r\nif (dev->mode == PPA_EPP_32) {\r\ndev->mode = old_mode;\r\ngoto second_pass;\r\n}\r\nreturn -EIO;\r\n}\r\nw_ctr(ppb, 0x0c);\r\nk = 1000000;\r\ndo {\r\nl = r_str(ppb);\r\nk--;\r\nudelay(1);\r\n} while (!(l & 0x80) && (k));\r\nl &= 0xf0;\r\nif (l != 0xf0) {\r\nppa_disconnect(dev);\r\nppa_connect(dev, CONNECT_EPP_MAYBE);\r\nppa_reset_pulse(ppb);\r\nudelay(1000);\r\nppa_disconnect(dev);\r\nudelay(1000);\r\nif (dev->mode == PPA_EPP_32) {\r\ndev->mode = old_mode;\r\ngoto second_pass;\r\n}\r\nreturn -EIO;\r\n}\r\nppa_disconnect(dev);\r\nprintk(KERN_INFO "ppa: Communication established with ID %i using %s\n",\r\nloop, PPA_MODE_STRING[dev->mode]);\r\nppa_connect(dev, CONNECT_EPP_MAYBE);\r\nppa_reset_pulse(ppb);\r\nudelay(1000);\r\nppa_disconnect(dev);\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ppa_adjust_queue(struct scsi_device *device)\r\n{\r\nblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\r\nreturn 0;\r\n}\r\nstatic inline ppa_struct *find_parent(void)\r\n{\r\nppa_struct *dev, *par = NULL;\r\nunsigned int cnt = 0;\r\nif (list_empty(&ppa_hosts))\r\nreturn NULL;\r\nlist_for_each_entry(dev, &ppa_hosts, list) {\r\nif (dev->dev_no != cnt)\r\nreturn par;\r\ncnt++;\r\npar = dev;\r\n}\r\nreturn par;\r\n}\r\nstatic int __ppa_attach(struct parport *pb)\r\n{\r\nstruct Scsi_Host *host;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waiting);\r\nDEFINE_WAIT(wait);\r\nppa_struct *dev, *temp;\r\nint ports;\r\nint modes, ppb, ppb_hi;\r\nint err = -ENOMEM;\r\nstruct pardev_cb ppa_cb;\r\ndev = kzalloc(sizeof(ppa_struct), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->base = -1;\r\ndev->mode = PPA_AUTODETECT;\r\ndev->recon_tmo = PPA_RECON_TMO;\r\ninit_waitqueue_head(&waiting);\r\ntemp = find_parent();\r\nif (temp)\r\ndev->dev_no = temp->dev_no + 1;\r\nmemset(&ppa_cb, 0, sizeof(ppa_cb));\r\nppa_cb.private = dev;\r\nppa_cb.wakeup = ppa_wakeup;\r\ndev->dev = parport_register_dev_model(pb, "ppa", &ppa_cb, dev->dev_no);\r\nif (!dev->dev)\r\ngoto out;\r\nerr = -EBUSY;\r\ndev->waiting = &waiting;\r\nprepare_to_wait(&waiting, &wait, TASK_UNINTERRUPTIBLE);\r\nif (ppa_pb_claim(dev))\r\nschedule_timeout(3 * HZ);\r\nif (dev->wanted) {\r\nprintk(KERN_ERR "ppa%d: failed to claim parport because "\r\n"a pardevice is owning the port for too long "\r\n"time!\n", pb->number);\r\nppa_pb_dismiss(dev);\r\ndev->waiting = NULL;\r\nfinish_wait(&waiting, &wait);\r\ngoto out1;\r\n}\r\ndev->waiting = NULL;\r\nfinish_wait(&waiting, &wait);\r\nppb = dev->base = dev->dev->port->base;\r\nppb_hi = dev->dev->port->base_hi;\r\nw_ctr(ppb, 0x0c);\r\nmodes = dev->dev->port->modes;\r\ndev->mode = PPA_NIBBLE;\r\nif (modes & PARPORT_MODE_TRISTATE)\r\ndev->mode = PPA_PS2;\r\nif (modes & PARPORT_MODE_ECP) {\r\nw_ecr(ppb_hi, 0x20);\r\ndev->mode = PPA_PS2;\r\n}\r\nif ((modes & PARPORT_MODE_EPP) && (modes & PARPORT_MODE_ECP))\r\nw_ecr(ppb_hi, 0x80);\r\nerr = ppa_init(dev);\r\nppa_pb_release(dev);\r\nif (err)\r\ngoto out1;\r\nif (dev->mode == PPA_NIBBLE || dev->mode == PPA_PS2)\r\nports = 3;\r\nelse\r\nports = 8;\r\nINIT_DELAYED_WORK(&dev->ppa_tq, ppa_interrupt);\r\nerr = -ENOMEM;\r\nhost = scsi_host_alloc(&ppa_template, sizeof(ppa_struct *));\r\nif (!host)\r\ngoto out1;\r\nhost->io_port = pb->base;\r\nhost->n_io_port = ports;\r\nhost->dma_channel = -1;\r\nhost->unique_id = pb->number;\r\n*(ppa_struct **)&host->hostdata = dev;\r\ndev->host = host;\r\nlist_add_tail(&dev->list, &ppa_hosts);\r\nerr = scsi_add_host(host, NULL);\r\nif (err)\r\ngoto out2;\r\nscsi_scan_host(host);\r\nreturn 0;\r\nout2:\r\nlist_del_init(&dev->list);\r\nscsi_host_put(host);\r\nout1:\r\nparport_unregister_device(dev->dev);\r\nout:\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void ppa_attach(struct parport *pb)\r\n{\r\n__ppa_attach(pb);\r\n}\r\nstatic void ppa_detach(struct parport *pb)\r\n{\r\nppa_struct *dev;\r\nlist_for_each_entry(dev, &ppa_hosts, list) {\r\nif (dev->dev->port == pb) {\r\nlist_del_init(&dev->list);\r\nscsi_remove_host(dev->host);\r\nscsi_host_put(dev->host);\r\nparport_unregister_device(dev->dev);\r\nkfree(dev);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __init ppa_driver_init(void)\r\n{\r\nprintk(KERN_INFO "ppa: Version %s\n", PPA_VERSION);\r\nreturn parport_register_driver(&ppa_driver);\r\n}\r\nstatic void __exit ppa_driver_exit(void)\r\n{\r\nparport_unregister_driver(&ppa_driver);\r\n}
