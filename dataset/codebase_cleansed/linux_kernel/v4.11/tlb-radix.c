static inline void __tlbiel_pid(unsigned long pid, int set,\r\nunsigned long ric)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nrb = PPC_BIT(53);\r\nrb |= set << PPC_BITLSHIFT(51);\r\nrs = ((unsigned long)pid) << PPC_BITLSHIFT(31);\r\nprs = 1;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIEL(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("ptesync": : :"memory");\r\n}\r\nstatic inline void _tlbiel_pid(unsigned long pid, unsigned long ric)\r\n{\r\nint set;\r\nfor (set = 0; set < POWER9_TLB_SETS_RADIX ; set++) {\r\n__tlbiel_pid(pid, set, ric);\r\n}\r\nasm volatile(PPC_INVALIDATE_ERAT "; isync" : : :"memory");\r\n}\r\nstatic inline void _tlbie_pid(unsigned long pid, unsigned long ric)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nrb = PPC_BIT(53);\r\nrs = pid << PPC_BITLSHIFT(31);\r\nprs = 1;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nstatic inline void _tlbiel_va(unsigned long va, unsigned long pid,\r\nunsigned long ap, unsigned long ric)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nrb = va & ~(PPC_BITMASK(52, 63));\r\nrb |= ap << PPC_BITLSHIFT(58);\r\nrs = pid << PPC_BITLSHIFT(31);\r\nprs = 1;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIEL(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("ptesync": : :"memory");\r\n}\r\nstatic inline void _tlbie_va(unsigned long va, unsigned long pid,\r\nunsigned long ap, unsigned long ric)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nrb = va & ~(PPC_BITMASK(52, 63));\r\nrb |= ap << PPC_BITLSHIFT(58);\r\nrs = pid << PPC_BITLSHIFT(31);\r\nprs = 1;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nvoid radix__local_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nunsigned long pid;\r\npreempt_disable();\r\npid = mm->context.id;\r\nif (pid != MMU_NO_CONTEXT)\r\n_tlbiel_pid(pid, RIC_FLUSH_ALL);\r\npreempt_enable();\r\n}\r\nvoid radix__local_flush_tlb_pwc(struct mmu_gather *tlb, unsigned long addr)\r\n{\r\nunsigned long pid;\r\nstruct mm_struct *mm = tlb->mm;\r\npreempt_disable();\r\npid = mm->context.id;\r\nif (pid != MMU_NO_CONTEXT)\r\n_tlbiel_pid(pid, RIC_FLUSH_PWC);\r\npreempt_enable();\r\n}\r\nvoid radix__local_flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,\r\nint psize)\r\n{\r\nunsigned long pid;\r\nunsigned long ap = mmu_get_ap(psize);\r\npreempt_disable();\r\npid = mm ? mm->context.id : 0;\r\nif (pid != MMU_NO_CONTEXT)\r\n_tlbiel_va(vmaddr, pid, ap, RIC_FLUSH_TLB);\r\npreempt_enable();\r\n}\r\nvoid radix__local_flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr)\r\n{\r\n#ifdef CONFIG_HUGETLB_PAGE\r\nif (vma && is_vm_hugetlb_page(vma))\r\nreturn __local_flush_hugetlb_page(vma, vmaddr);\r\n#endif\r\nradix__local_flush_tlb_page_psize(vma ? vma->vm_mm : NULL, vmaddr,\r\nmmu_virtual_psize);\r\n}\r\nvoid radix__flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nunsigned long pid;\r\npreempt_disable();\r\npid = mm->context.id;\r\nif (unlikely(pid == MMU_NO_CONTEXT))\r\ngoto no_context;\r\nif (!mm_is_thread_local(mm)) {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\n_tlbie_pid(pid, RIC_FLUSH_ALL);\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n} else\r\n_tlbiel_pid(pid, RIC_FLUSH_ALL);\r\nno_context:\r\npreempt_enable();\r\n}\r\nvoid radix__flush_tlb_pwc(struct mmu_gather *tlb, unsigned long addr)\r\n{\r\nunsigned long pid;\r\nstruct mm_struct *mm = tlb->mm;\r\npreempt_disable();\r\npid = mm->context.id;\r\nif (unlikely(pid == MMU_NO_CONTEXT))\r\ngoto no_context;\r\nif (!mm_is_thread_local(mm)) {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\n_tlbie_pid(pid, RIC_FLUSH_PWC);\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n} else\r\n_tlbiel_pid(pid, RIC_FLUSH_PWC);\r\nno_context:\r\npreempt_enable();\r\n}\r\nvoid radix__flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,\r\nint psize)\r\n{\r\nunsigned long pid;\r\nunsigned long ap = mmu_get_ap(psize);\r\npreempt_disable();\r\npid = mm ? mm->context.id : 0;\r\nif (unlikely(pid == MMU_NO_CONTEXT))\r\ngoto bail;\r\nif (!mm_is_thread_local(mm)) {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\n_tlbie_va(vmaddr, pid, ap, RIC_FLUSH_TLB);\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n} else\r\n_tlbiel_va(vmaddr, pid, ap, RIC_FLUSH_TLB);\r\nbail:\r\npreempt_enable();\r\n}\r\nvoid radix__flush_tlb_page(struct vm_area_struct *vma, unsigned long vmaddr)\r\n{\r\n#ifdef CONFIG_HUGETLB_PAGE\r\nif (vma && is_vm_hugetlb_page(vma))\r\nreturn flush_hugetlb_page(vma, vmaddr);\r\n#endif\r\nradix__flush_tlb_page_psize(vma ? vma->vm_mm : NULL, vmaddr,\r\nmmu_virtual_psize);\r\n}\r\nvoid radix__flush_tlb_kernel_range(unsigned long start, unsigned long end)\r\n{\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\n_tlbie_pid(0, RIC_FLUSH_ALL);\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nvoid radix__flush_tlb_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nradix__flush_tlb_mm(mm);\r\n}\r\nstatic int radix_get_mmu_psize(int page_size)\r\n{\r\nint psize;\r\nif (page_size == (1UL << mmu_psize_defs[mmu_virtual_psize].shift))\r\npsize = mmu_virtual_psize;\r\nelse if (page_size == (1UL << mmu_psize_defs[MMU_PAGE_2M].shift))\r\npsize = MMU_PAGE_2M;\r\nelse if (page_size == (1UL << mmu_psize_defs[MMU_PAGE_1G].shift))\r\npsize = MMU_PAGE_1G;\r\nelse\r\nreturn -1;\r\nreturn psize;\r\n}\r\nvoid radix__tlb_flush(struct mmu_gather *tlb)\r\n{\r\nint psize = 0;\r\nstruct mm_struct *mm = tlb->mm;\r\nint page_size = tlb->page_size;\r\npsize = radix_get_mmu_psize(page_size);\r\nif (psize != -1 && !tlb->fullmm && !tlb->need_flush_all)\r\nradix__flush_tlb_range_psize(mm, tlb->start, tlb->end, psize);\r\nelse\r\nradix__flush_tlb_mm(mm);\r\n}\r\nvoid radix__flush_tlb_range_psize(struct mm_struct *mm, unsigned long start,\r\nunsigned long end, int psize)\r\n{\r\nunsigned long pid;\r\nunsigned long addr;\r\nint local = mm_is_thread_local(mm);\r\nunsigned long ap = mmu_get_ap(psize);\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nunsigned long page_size = 1UL << mmu_psize_defs[psize].shift;\r\npreempt_disable();\r\npid = mm ? mm->context.id : 0;\r\nif (unlikely(pid == MMU_NO_CONTEXT))\r\ngoto err_out;\r\nif (end == TLB_FLUSH_ALL ||\r\n(end - start) > tlb_single_page_flush_ceiling * page_size) {\r\nif (local)\r\n_tlbiel_pid(pid, RIC_FLUSH_TLB);\r\nelse\r\n_tlbie_pid(pid, RIC_FLUSH_TLB);\r\ngoto err_out;\r\n}\r\nfor (addr = start; addr < end; addr += page_size) {\r\nif (local)\r\n_tlbiel_va(addr, pid, ap, RIC_FLUSH_TLB);\r\nelse {\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\n_tlbie_va(addr, pid, ap, RIC_FLUSH_TLB);\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\n}\r\nerr_out:\r\npreempt_enable();\r\n}\r\nvoid radix__flush_tlb_lpid_va(unsigned long lpid, unsigned long gpa,\r\nunsigned long page_size)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nunsigned long ap;\r\nunsigned long ric = RIC_FLUSH_TLB;\r\nap = mmu_get_ap(radix_get_mmu_psize(page_size));\r\nrb = gpa & ~(PPC_BITMASK(52, 63));\r\nrb |= ap << PPC_BITLSHIFT(58);\r\nrs = lpid & ((1UL << 32) - 1);\r\nprs = 0;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nvoid radix__flush_tlb_lpid(unsigned long lpid)\r\n{\r\nunsigned long rb,rs,prs,r;\r\nunsigned long ric = RIC_FLUSH_ALL;\r\nrb = 0x2 << PPC_BITLSHIFT(53);\r\nrs = lpid & ((1UL << 32) - 1);\r\nprs = 0;\r\nr = 1;\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(rs) : "memory");\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nvoid radix__flush_pmd_tlb_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nradix__flush_tlb_range_psize(vma->vm_mm, start, end, MMU_PAGE_2M);\r\n}\r\nvoid radix__flush_tlb_all(void)\r\n{\r\nunsigned long rb,prs,r,rs;\r\nunsigned long ric = RIC_FLUSH_ALL;\r\nrb = 0x3 << PPC_BITLSHIFT(53);\r\nprs = 0;\r\nr = 1;\r\nrs = 1 & ((1UL << 32) - 1);\r\nasm volatile("ptesync": : :"memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(1), "i"(ric), "r"(rs) : "memory");\r\nasm volatile(PPC_TLBIE_5(%0, %4, %3, %2, %1)\r\n: : "r"(rb), "i"(r), "i"(prs), "i"(ric), "r"(0) : "memory");\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nvoid radix__flush_tlb_pte_p9_dd1(unsigned long old_pte, struct mm_struct *mm,\r\nunsigned long address)\r\n{\r\nif (!cpu_has_feature(CPU_FTR_POWER9_DD1)) {\r\nVM_WARN_ON(1);\r\nreturn;\r\n}\r\nif (old_pte & _PAGE_LARGE)\r\nradix__flush_tlb_page_psize(mm, address, MMU_PAGE_2M);\r\nelse\r\nradix__flush_tlb_page_psize(mm, address, mmu_virtual_psize);\r\n}
