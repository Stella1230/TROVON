static irqreturn_t pruss_handler(int irq, struct uio_info *info)\r\n{\r\nstruct uio_pruss_dev *gdev = info->priv;\r\nint intr_bit = (irq - gdev->hostirq_start + 2);\r\nint val, intr_mask = (1 << intr_bit);\r\nvoid __iomem *base = gdev->prussio_vaddr + gdev->pintc_base;\r\nvoid __iomem *intren_reg = base + PINTC_HIER;\r\nvoid __iomem *intrdis_reg = base + PINTC_HIDISR;\r\nvoid __iomem *intrstat_reg = base + PINTC_HIPIR + (intr_bit << 2);\r\nval = ioread32(intren_reg);\r\nif (!(val & intr_mask) && (ioread32(intrstat_reg) & HIPIR_NOPEND))\r\nreturn IRQ_NONE;\r\niowrite32(intr_bit, intrdis_reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pruss_cleanup(struct device *dev, struct uio_pruss_dev *gdev)\r\n{\r\nint cnt;\r\nstruct uio_info *p = gdev->info;\r\nfor (cnt = 0; cnt < MAX_PRUSS_EVT; cnt++, p++) {\r\nuio_unregister_device(p);\r\nkfree(p->name);\r\n}\r\niounmap(gdev->prussio_vaddr);\r\nif (gdev->ddr_vaddr) {\r\ndma_free_coherent(dev, extram_pool_sz, gdev->ddr_vaddr,\r\ngdev->ddr_paddr);\r\n}\r\nif (gdev->sram_vaddr)\r\ngen_pool_free(gdev->sram_pool,\r\ngdev->sram_vaddr,\r\nsram_pool_sz);\r\nkfree(gdev->info);\r\nclk_disable(gdev->pruss_clk);\r\nclk_put(gdev->pruss_clk);\r\nkfree(gdev);\r\n}\r\nstatic int pruss_probe(struct platform_device *pdev)\r\n{\r\nstruct uio_info *p;\r\nstruct uio_pruss_dev *gdev;\r\nstruct resource *regs_prussio;\r\nstruct device *dev = &pdev->dev;\r\nint ret = -ENODEV, cnt = 0, len;\r\nstruct uio_pruss_pdata *pdata = dev_get_platdata(dev);\r\ngdev = kzalloc(sizeof(struct uio_pruss_dev), GFP_KERNEL);\r\nif (!gdev)\r\nreturn -ENOMEM;\r\ngdev->info = kzalloc(sizeof(*p) * MAX_PRUSS_EVT, GFP_KERNEL);\r\nif (!gdev->info) {\r\nkfree(gdev);\r\nreturn -ENOMEM;\r\n}\r\ngdev->pruss_clk = clk_get(dev, "pruss");\r\nif (IS_ERR(gdev->pruss_clk)) {\r\ndev_err(dev, "Failed to get clock\n");\r\nret = PTR_ERR(gdev->pruss_clk);\r\nkfree(gdev->info);\r\nkfree(gdev);\r\nreturn ret;\r\n} else {\r\nret = clk_enable(gdev->pruss_clk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable clock\n");\r\nclk_put(gdev->pruss_clk);\r\nkfree(gdev->info);\r\nkfree(gdev);\r\nreturn ret;\r\n}\r\n}\r\nregs_prussio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs_prussio) {\r\ndev_err(dev, "No PRUSS I/O resource specified\n");\r\ngoto out_free;\r\n}\r\nif (!regs_prussio->start) {\r\ndev_err(dev, "Invalid memory resource\n");\r\ngoto out_free;\r\n}\r\nif (pdata->sram_pool) {\r\ngdev->sram_pool = pdata->sram_pool;\r\ngdev->sram_vaddr =\r\n(unsigned long)gen_pool_dma_alloc(gdev->sram_pool,\r\nsram_pool_sz, &gdev->sram_paddr);\r\nif (!gdev->sram_vaddr) {\r\ndev_err(dev, "Could not allocate SRAM pool\n");\r\ngoto out_free;\r\n}\r\n}\r\ngdev->ddr_vaddr = dma_alloc_coherent(dev, extram_pool_sz,\r\n&(gdev->ddr_paddr), GFP_KERNEL | GFP_DMA);\r\nif (!gdev->ddr_vaddr) {\r\ndev_err(dev, "Could not allocate external memory\n");\r\ngoto out_free;\r\n}\r\nlen = resource_size(regs_prussio);\r\ngdev->prussio_vaddr = ioremap(regs_prussio->start, len);\r\nif (!gdev->prussio_vaddr) {\r\ndev_err(dev, "Can't remap PRUSS I/O address range\n");\r\ngoto out_free;\r\n}\r\ngdev->pintc_base = pdata->pintc_base;\r\ngdev->hostirq_start = platform_get_irq(pdev, 0);\r\nfor (cnt = 0, p = gdev->info; cnt < MAX_PRUSS_EVT; cnt++, p++) {\r\np->mem[0].addr = regs_prussio->start;\r\np->mem[0].size = resource_size(regs_prussio);\r\np->mem[0].memtype = UIO_MEM_PHYS;\r\np->mem[1].addr = gdev->sram_paddr;\r\np->mem[1].size = sram_pool_sz;\r\np->mem[1].memtype = UIO_MEM_PHYS;\r\np->mem[2].addr = gdev->ddr_paddr;\r\np->mem[2].size = extram_pool_sz;\r\np->mem[2].memtype = UIO_MEM_PHYS;\r\np->name = kasprintf(GFP_KERNEL, "pruss_evt%d", cnt);\r\np->version = DRV_VERSION;\r\np->irq = gdev->hostirq_start + cnt;\r\np->handler = pruss_handler;\r\np->priv = gdev;\r\nret = uio_register_device(dev, p);\r\nif (ret < 0)\r\ngoto out_free;\r\n}\r\nplatform_set_drvdata(pdev, gdev);\r\nreturn 0;\r\nout_free:\r\npruss_cleanup(dev, gdev);\r\nreturn ret;\r\n}\r\nstatic int pruss_remove(struct platform_device *dev)\r\n{\r\nstruct uio_pruss_dev *gdev = platform_get_drvdata(dev);\r\npruss_cleanup(&dev->dev, gdev);\r\nreturn 0;\r\n}
