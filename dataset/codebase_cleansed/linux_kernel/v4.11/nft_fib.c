int nft_fib_validate(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nunsigned int hooks;\r\nswitch (priv->result) {\r\ncase NFT_FIB_RESULT_OIF:\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nhooks = (1 << NF_INET_PRE_ROUTING);\r\nbreak;\r\ncase NFT_FIB_RESULT_ADDRTYPE:\r\nif (priv->flags & NFTA_FIB_F_IIF)\r\nhooks = (1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_IN) |\r\n(1 << NF_INET_FORWARD);\r\nelse if (priv->flags & NFTA_FIB_F_OIF)\r\nhooks = (1 << NF_INET_LOCAL_OUT) |\r\n(1 << NF_INET_POST_ROUTING) |\r\n(1 << NF_INET_FORWARD);\r\nelse\r\nhooks = (1 << NF_INET_LOCAL_IN) |\r\n(1 << NF_INET_LOCAL_OUT) |\r\n(1 << NF_INET_FORWARD) |\r\n(1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_POST_ROUTING);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn nft_chain_validate_hooks(ctx->chain, hooks);\r\n}\r\nint nft_fib_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_fib *priv = nft_expr_priv(expr);\r\nunsigned int len;\r\nint err;\r\nif (!tb[NFTA_FIB_DREG] || !tb[NFTA_FIB_RESULT] || !tb[NFTA_FIB_FLAGS])\r\nreturn -EINVAL;\r\npriv->flags = ntohl(nla_get_be32(tb[NFTA_FIB_FLAGS]));\r\nif (priv->flags == 0 || (priv->flags & ~NFTA_FIB_F_ALL))\r\nreturn -EINVAL;\r\nif ((priv->flags & (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR)) ==\r\n(NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR))\r\nreturn -EINVAL;\r\nif ((priv->flags & (NFTA_FIB_F_IIF | NFTA_FIB_F_OIF)) ==\r\n(NFTA_FIB_F_IIF | NFTA_FIB_F_OIF))\r\nreturn -EINVAL;\r\nif ((priv->flags & (NFTA_FIB_F_SADDR | NFTA_FIB_F_DADDR)) == 0)\r\nreturn -EINVAL;\r\npriv->result = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\r\npriv->dreg = nft_parse_register(tb[NFTA_FIB_DREG]);\r\nswitch (priv->result) {\r\ncase NFT_FIB_RESULT_OIF:\r\nif (priv->flags & NFTA_FIB_F_OIF)\r\nreturn -EINVAL;\r\nlen = sizeof(int);\r\nbreak;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nif (priv->flags & NFTA_FIB_F_OIF)\r\nreturn -EINVAL;\r\nlen = IFNAMSIZ;\r\nbreak;\r\ncase NFT_FIB_RESULT_ADDRTYPE:\r\nlen = sizeof(u32);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = nft_validate_register_store(ctx, priv->dreg, NULL,\r\nNFT_DATA_VALUE, len);\r\nif (err < 0)\r\nreturn err;\r\nreturn nft_fib_validate(ctx, expr, NULL);\r\n}\r\nint nft_fib_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_FIB_DREG, priv->dreg))\r\nreturn -1;\r\nif (nla_put_be32(skb, NFTA_FIB_RESULT, htonl(priv->result)))\r\nreturn -1;\r\nif (nla_put_be32(skb, NFTA_FIB_FLAGS, htonl(priv->flags)))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid nft_fib_store_result(void *reg, enum nft_fib_result r,\r\nconst struct nft_pktinfo *pkt, int index)\r\n{\r\nstruct net_device *dev;\r\nu32 *dreg = reg;\r\nswitch (r) {\r\ncase NFT_FIB_RESULT_OIF:\r\n*dreg = index;\r\nbreak;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\ndev = dev_get_by_index_rcu(nft_net(pkt), index);\r\nstrncpy(reg, dev ? dev->name : "", IFNAMSIZ);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\n*dreg = 0;\r\nbreak;\r\n}\r\n}
