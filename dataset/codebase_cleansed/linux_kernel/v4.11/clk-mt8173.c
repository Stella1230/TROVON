static void __init mtk_clk_enable_critical(void)\r\n{\r\nif (!mt8173_top_clk_data || !mt8173_pll_clk_data)\r\nreturn;\r\nclk_prepare_enable(mt8173_pll_clk_data->clks[CLK_APMIXED_ARMCA15PLL]);\r\nclk_prepare_enable(mt8173_pll_clk_data->clks[CLK_APMIXED_ARMCA7PLL]);\r\nclk_prepare_enable(mt8173_top_clk_data->clks[CLK_TOP_MEM_SEL]);\r\nclk_prepare_enable(mt8173_top_clk_data->clks[CLK_TOP_DDRPHYCFG_SEL]);\r\nclk_prepare_enable(mt8173_top_clk_data->clks[CLK_TOP_CCI400_SEL]);\r\nclk_prepare_enable(mt8173_top_clk_data->clks[CLK_TOP_RTC_SEL]);\r\n}\r\nstatic void __init mtk_topckgen_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nvoid __iomem *base;\r\nint r;\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\npr_err("%s(): ioremap failed\n", __func__);\r\nreturn;\r\n}\r\nmt8173_top_clk_data = clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);\r\nmtk_clk_register_fixed_clks(fixed_clks, ARRAY_SIZE(fixed_clks), clk_data);\r\nmtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), clk_data);\r\nmtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes), base,\r\n&mt8173_clk_lock, clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\nmtk_clk_enable_critical();\r\n}\r\nstatic void __init mtk_infrasys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_INFRA_NR_CLK);\r\nmtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),\r\nclk_data);\r\nmtk_clk_register_factors(infra_divs, ARRAY_SIZE(infra_divs), clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\nmtk_register_reset_controller(node, 2, 0x30);\r\n}\r\nstatic void __init mtk_pericfg_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nvoid __iomem *base;\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\npr_err("%s(): ioremap failed\n", __func__);\r\nreturn;\r\n}\r\nclk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);\r\nmtk_clk_register_gates(node, peri_gates, ARRAY_SIZE(peri_gates),\r\nclk_data);\r\nmtk_clk_register_composites(peri_clks, ARRAY_SIZE(peri_clks), base,\r\n&mt8173_clk_lock, clk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\nmtk_register_reset_controller(node, 2, 0);\r\n}\r\nstatic void __init mtk_apmixedsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nint r, i;\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\npr_err("%s(): ioremap failed\n", __func__);\r\nreturn;\r\n}\r\nmt8173_pll_clk_data = clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);\r\nif (!clk_data) {\r\niounmap(base);\r\nreturn;\r\n}\r\nmtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);\r\nfor (i = 0; i < ARRAY_SIZE(apmixed_usb); i++) {\r\nconst struct mtk_clk_usb *cku = &apmixed_usb[i];\r\nclk = mtk_clk_register_ref2usb_tx(cku->name, cku->parent,\r\nbase + cku->reg_ofs);\r\nif (IS_ERR(clk)) {\r\npr_err("Failed to register clk %s: %ld\n", cku->name,\r\nPTR_ERR(clk));\r\ncontinue;\r\n}\r\nclk_data->clks[cku->id] = clk;\r\n}\r\nclk = clk_register_divider(NULL, "hdmi_ref", "tvdpll_594m", 0,\r\nbase + 0x40, 16, 3, CLK_DIVIDER_POWER_OF_TWO,\r\nNULL);\r\nclk_data->clks[CLK_APMIXED_HDMI_REF] = clk;\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\nmtk_clk_enable_critical();\r\n}\r\nstatic void __init mtk_imgsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_IMG_NR_CLK);\r\nmtk_clk_register_gates(node, img_clks, ARRAY_SIZE(img_clks),\r\nclk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}\r\nstatic void __init mtk_mmsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_MM_NR_CLK);\r\nmtk_clk_register_gates(node, mm_clks, ARRAY_SIZE(mm_clks),\r\nclk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}\r\nstatic void __init mtk_vdecsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_VDEC_NR_CLK);\r\nmtk_clk_register_gates(node, vdec_clks, ARRAY_SIZE(vdec_clks),\r\nclk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}\r\nstatic void __init mtk_vencsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_VENC_NR_CLK);\r\nmtk_clk_register_gates(node, venc_clks, ARRAY_SIZE(venc_clks),\r\nclk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}\r\nstatic void __init mtk_vencltsys_init(struct device_node *node)\r\n{\r\nstruct clk_onecell_data *clk_data;\r\nint r;\r\nclk_data = mtk_alloc_clk_data(CLK_VENCLT_NR_CLK);\r\nmtk_clk_register_gates(node, venclt_clks, ARRAY_SIZE(venclt_clks),\r\nclk_data);\r\nr = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\r\nif (r)\r\npr_err("%s(): could not register clock provider: %d\n",\r\n__func__, r);\r\n}
