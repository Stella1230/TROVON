static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\r\nsize_t *_dp, size_t *_len,\r\nconst char **_errmsg)\r\n{\r\nunsigned char tag, tmp;\r\nsize_t dp = *_dp, len, n;\r\nint indef_level = 1;\r\nnext_tag:\r\nif (unlikely(datalen - dp < 2)) {\r\nif (datalen == dp)\r\ngoto missing_eoc;\r\ngoto data_overrun_error;\r\n}\r\ntag = data[dp++];\r\nif (tag == ASN1_EOC) {\r\nif (data[dp++] != 0)\r\ngoto invalid_eoc;\r\nif (--indef_level <= 0) {\r\n*_len = dp - *_dp;\r\n*_dp = dp;\r\nreturn 0;\r\n}\r\ngoto next_tag;\r\n}\r\nif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\r\ndo {\r\nif (unlikely(datalen - dp < 2))\r\ngoto data_overrun_error;\r\ntmp = data[dp++];\r\n} while (tmp & 0x80);\r\n}\r\nlen = data[dp++];\r\nif (len <= 0x7f)\r\ngoto check_length;\r\nif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\r\nif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\r\ngoto indefinite_len_primitive;\r\nindef_level++;\r\ngoto next_tag;\r\n}\r\nn = len - 0x80;\r\nif (unlikely(n > sizeof(len) - 1))\r\ngoto length_too_long;\r\nif (unlikely(n > datalen - dp))\r\ngoto data_overrun_error;\r\nlen = 0;\r\nfor (; n > 0; n--) {\r\nlen <<= 8;\r\nlen |= data[dp++];\r\n}\r\ncheck_length:\r\nif (len > datalen - dp)\r\ngoto data_overrun_error;\r\ndp += len;\r\ngoto next_tag;\r\nlength_too_long:\r\n*_errmsg = "Unsupported length";\r\ngoto error;\r\nindefinite_len_primitive:\r\n*_errmsg = "Indefinite len primitive not permitted";\r\ngoto error;\r\ninvalid_eoc:\r\n*_errmsg = "Invalid length EOC";\r\ngoto error;\r\ndata_overrun_error:\r\n*_errmsg = "Data overrun error";\r\ngoto error;\r\nmissing_eoc:\r\n*_errmsg = "Missing EOC in indefinite len cons";\r\nerror:\r\n*_dp = dp;\r\nreturn -1;\r\n}\r\nint asn1_ber_decoder(const struct asn1_decoder *decoder,\r\nvoid *context,\r\nconst unsigned char *data,\r\nsize_t datalen)\r\n{\r\nconst unsigned char *machine = decoder->machine;\r\nconst asn1_action_t *actions = decoder->actions;\r\nsize_t machlen = decoder->machlen;\r\nenum asn1_opcode op;\r\nunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\r\nconst char *errmsg;\r\nsize_t pc = 0, dp = 0, tdp = 0, len = 0;\r\nint ret;\r\nunsigned char flags = 0;\r\n#define FLAG_INDEFINITE_LENGTH 0x01\r\n#define FLAG_MATCHED 0x02\r\n#define FLAG_LAST_MATCHED 0x04\r\n#define FLAG_CONS 0x20\r\n#define NR_CONS_STACK 10\r\nunsigned short cons_dp_stack[NR_CONS_STACK];\r\nunsigned short cons_datalen_stack[NR_CONS_STACK];\r\nunsigned char cons_hdrlen_stack[NR_CONS_STACK];\r\n#define NR_JUMP_STACK 10\r\nunsigned char jump_stack[NR_JUMP_STACK];\r\nif (datalen > 65535)\r\nreturn -EMSGSIZE;\r\nnext_op:\r\npr_debug("next_op: pc=\e[32m%zu\e[m/%zu dp=\e[33m%zu\e[m/%zu C=%d J=%d\n",\r\npc, machlen, dp, datalen, csp, jsp);\r\nif (unlikely(pc >= machlen))\r\ngoto machine_overrun_error;\r\nop = machine[pc];\r\nif (unlikely(pc + asn1_op_lengths[op] > machlen))\r\ngoto machine_overrun_error;\r\nif (op <= ASN1_OP__MATCHES_TAG) {\r\nunsigned char tmp;\r\nif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\r\n(op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\r\nflags &= ~FLAG_LAST_MATCHED;\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\n}\r\nflags = 0;\r\nhdr = 2;\r\nif (unlikely(dp >= datalen - 1))\r\ngoto data_overrun_error;\r\ntag = data[dp++];\r\nif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\r\ngoto long_tag_not_supported;\r\nif (op & ASN1_OP_MATCH__ANY) {\r\npr_debug("- any %02x\n", tag);\r\n} else {\r\noptag = machine[pc + 1];\r\nflags |= optag & FLAG_CONS;\r\ntmp = optag ^ tag;\r\ntmp &= ~(optag & ASN1_CONS_BIT);\r\npr_debug("- match? %02x %02x %02x\n", tag, optag, tmp);\r\nif (tmp != 0) {\r\nif (op & ASN1_OP_MATCH__SKIP) {\r\npc += asn1_op_lengths[op];\r\ndp--;\r\ngoto next_op;\r\n}\r\ngoto tag_mismatch;\r\n}\r\n}\r\nflags |= FLAG_MATCHED;\r\nlen = data[dp++];\r\nif (len > 0x7f) {\r\nif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\r\nif (unlikely(!(tag & ASN1_CONS_BIT)))\r\ngoto indefinite_len_primitive;\r\nflags |= FLAG_INDEFINITE_LENGTH;\r\nif (unlikely(2 > datalen - dp))\r\ngoto data_overrun_error;\r\n} else {\r\nint n = len - 0x80;\r\nif (unlikely(n > 2))\r\ngoto length_too_long;\r\nif (unlikely(dp >= datalen - n))\r\ngoto data_overrun_error;\r\nhdr += n;\r\nfor (len = 0; n > 0; n--) {\r\nlen <<= 8;\r\nlen |= data[dp++];\r\n}\r\nif (unlikely(len > datalen - dp))\r\ngoto data_overrun_error;\r\n}\r\n}\r\nif (flags & FLAG_CONS) {\r\nif (unlikely(csp >= NR_CONS_STACK))\r\ngoto cons_stack_overflow;\r\ncons_dp_stack[csp] = dp;\r\ncons_hdrlen_stack[csp] = hdr;\r\nif (!(flags & FLAG_INDEFINITE_LENGTH)) {\r\ncons_datalen_stack[csp] = datalen;\r\ndatalen = dp + len;\r\n} else {\r\ncons_datalen_stack[csp] = 0;\r\n}\r\ncsp++;\r\n}\r\npr_debug("- TAG: %02x %zu%s\n",\r\ntag, len, flags & FLAG_CONS ? " CONS" : "");\r\ntdp = dp;\r\n}\r\nswitch (op) {\r\ncase ASN1_OP_MATCH_ANY_ACT:\r\ncase ASN1_OP_MATCH_ANY_ACT_OR_SKIP:\r\ncase ASN1_OP_COND_MATCH_ANY_ACT:\r\ncase ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:\r\nret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\r\nif (ret < 0)\r\nreturn ret;\r\ngoto skip_data;\r\ncase ASN1_OP_MATCH_ACT:\r\ncase ASN1_OP_MATCH_ACT_OR_SKIP:\r\ncase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\r\nret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\r\nif (ret < 0)\r\nreturn ret;\r\ngoto skip_data;\r\ncase ASN1_OP_MATCH:\r\ncase ASN1_OP_MATCH_OR_SKIP:\r\ncase ASN1_OP_MATCH_ANY:\r\ncase ASN1_OP_MATCH_ANY_OR_SKIP:\r\ncase ASN1_OP_COND_MATCH_OR_SKIP:\r\ncase ASN1_OP_COND_MATCH_ANY:\r\ncase ASN1_OP_COND_MATCH_ANY_OR_SKIP:\r\nskip_data:\r\nif (!(flags & FLAG_CONS)) {\r\nif (flags & FLAG_INDEFINITE_LENGTH) {\r\nret = asn1_find_indefinite_length(\r\ndata, datalen, &dp, &len, &errmsg);\r\nif (ret < 0)\r\ngoto error;\r\n} else {\r\ndp += len;\r\n}\r\npr_debug("- LEAF: %zu\n", len);\r\n}\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\ncase ASN1_OP_MATCH_JUMP:\r\ncase ASN1_OP_MATCH_JUMP_OR_SKIP:\r\ncase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\r\npr_debug("- MATCH_JUMP\n");\r\nif (unlikely(jsp == NR_JUMP_STACK))\r\ngoto jump_stack_overflow;\r\njump_stack[jsp++] = pc + asn1_op_lengths[op];\r\npc = machine[pc + 2];\r\ngoto next_op;\r\ncase ASN1_OP_COND_FAIL:\r\nif (unlikely(!(flags & FLAG_MATCHED)))\r\ngoto tag_mismatch;\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\ncase ASN1_OP_COMPLETE:\r\nif (unlikely(jsp != 0 || csp != 0)) {\r\npr_err("ASN.1 decoder error: Stacks not empty at completion (%u, %u)\n",\r\njsp, csp);\r\nreturn -EBADMSG;\r\n}\r\nreturn 0;\r\ncase ASN1_OP_END_SET:\r\ncase ASN1_OP_END_SET_ACT:\r\nif (unlikely(!(flags & FLAG_MATCHED)))\r\ngoto tag_mismatch;\r\ncase ASN1_OP_END_SEQ:\r\ncase ASN1_OP_END_SET_OF:\r\ncase ASN1_OP_END_SEQ_OF:\r\ncase ASN1_OP_END_SEQ_ACT:\r\ncase ASN1_OP_END_SET_OF_ACT:\r\ncase ASN1_OP_END_SEQ_OF_ACT:\r\nif (unlikely(csp <= 0))\r\ngoto cons_stack_underflow;\r\ncsp--;\r\ntdp = cons_dp_stack[csp];\r\nhdr = cons_hdrlen_stack[csp];\r\nlen = datalen;\r\ndatalen = cons_datalen_stack[csp];\r\npr_debug("- end cons t=%zu dp=%zu l=%zu/%zu\n",\r\ntdp, dp, len, datalen);\r\nif (datalen == 0) {\r\ndatalen = len;\r\nif (unlikely(datalen - dp < 2))\r\ngoto data_overrun_error;\r\nif (data[dp++] != 0) {\r\nif (op & ASN1_OP_END__OF) {\r\ndp--;\r\ncsp++;\r\npc = machine[pc + 1];\r\npr_debug("- continue\n");\r\ngoto next_op;\r\n}\r\ngoto missing_eoc;\r\n}\r\nif (data[dp++] != 0)\r\ngoto invalid_eoc;\r\nlen = dp - tdp - 2;\r\n} else {\r\nif (dp < len && (op & ASN1_OP_END__OF)) {\r\ndatalen = len;\r\ncsp++;\r\npc = machine[pc + 1];\r\npr_debug("- continue\n");\r\ngoto next_op;\r\n}\r\nif (dp != len)\r\ngoto cons_length_error;\r\nlen -= tdp;\r\npr_debug("- cons len l=%zu d=%zu\n", len, dp - tdp);\r\n}\r\nif (op & ASN1_OP_END__ACT) {\r\nunsigned char act;\r\nif (op & ASN1_OP_END__OF)\r\nact = machine[pc + 2];\r\nelse\r\nact = machine[pc + 1];\r\nret = actions[act](context, hdr, 0, data + tdp, len);\r\n}\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\ncase ASN1_OP_MAYBE_ACT:\r\nif (!(flags & FLAG_LAST_MATCHED)) {\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\n}\r\ncase ASN1_OP_ACT:\r\nret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\r\nif (ret < 0)\r\nreturn ret;\r\npc += asn1_op_lengths[op];\r\ngoto next_op;\r\ncase ASN1_OP_RETURN:\r\nif (unlikely(jsp <= 0))\r\ngoto jump_stack_underflow;\r\npc = jump_stack[--jsp];\r\nflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\r\ngoto next_op;\r\ndefault:\r\nbreak;\r\n}\r\npr_err("ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\n",\r\nop, pc);\r\nreturn -EBADMSG;\r\ndata_overrun_error:\r\nerrmsg = "Data overrun error";\r\ngoto error;\r\nmachine_overrun_error:\r\nerrmsg = "Machine overrun error";\r\ngoto error;\r\njump_stack_underflow:\r\nerrmsg = "Jump stack underflow";\r\ngoto error;\r\njump_stack_overflow:\r\nerrmsg = "Jump stack overflow";\r\ngoto error;\r\ncons_stack_underflow:\r\nerrmsg = "Cons stack underflow";\r\ngoto error;\r\ncons_stack_overflow:\r\nerrmsg = "Cons stack overflow";\r\ngoto error;\r\ncons_length_error:\r\nerrmsg = "Cons length error";\r\ngoto error;\r\nmissing_eoc:\r\nerrmsg = "Missing EOC in indefinite len cons";\r\ngoto error;\r\ninvalid_eoc:\r\nerrmsg = "Invalid length EOC";\r\ngoto error;\r\nlength_too_long:\r\nerrmsg = "Unsupported length";\r\ngoto error;\r\nindefinite_len_primitive:\r\nerrmsg = "Indefinite len primitive not permitted";\r\ngoto error;\r\ntag_mismatch:\r\nerrmsg = "Unexpected tag";\r\ngoto error;\r\nlong_tag_not_supported:\r\nerrmsg = "Long tag not supported";\r\nerror:\r\npr_debug("\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\n",\r\nerrmsg, pc, dp, optag, tag, len);\r\nreturn -EBADMSG;\r\n}
