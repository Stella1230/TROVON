static inline int at76_is_intersil(enum board_type board)\r\n{\r\nreturn (board == BOARD_503_ISL3861 || board == BOARD_503_ISL3863);\r\n}\r\nstatic inline int at76_is_503rfmd(enum board_type board)\r\n{\r\nreturn (board == BOARD_503 || board == BOARD_503_ACC);\r\n}\r\nstatic inline int at76_is_505a(enum board_type board)\r\n{\r\nreturn (board == BOARD_505A || board == BOARD_505AMX);\r\n}\r\nstatic int at76_load_int_fw_block(struct usb_device *udev, int blockno,\r\nvoid *block, int size)\r\n{\r\nreturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,\r\nUSB_TYPE_CLASS | USB_DIR_OUT |\r\nUSB_RECIP_INTERFACE, blockno, 0, block, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\n}\r\nstatic int at76_dfu_get_status(struct usb_device *udev,\r\nstruct dfu_status *status)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATUS,\r\nUSB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\r\n0, 0, status, sizeof(struct dfu_status),\r\nUSB_CTRL_GET_TIMEOUT);\r\nreturn ret;\r\n}\r\nstatic int at76_dfu_get_state(struct usb_device *udev, u8 *state)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), DFU_GETSTATE,\r\nUSB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\r\n0, 0, state, 1, USB_CTRL_GET_TIMEOUT);\r\nreturn ret;\r\n}\r\nstatic inline unsigned long at76_get_timeout(struct dfu_status *s)\r\n{\r\nreturn msecs_to_jiffies((s->poll_timeout[2] << 16)\r\n| (s->poll_timeout[1] << 8)\r\n| (s->poll_timeout[0]));\r\n}\r\nstatic int at76_usbdfu_download(struct usb_device *udev, u8 *buf, u32 size,\r\nint manifest_sync_timeout)\r\n{\r\nint ret = 0;\r\nint need_dfu_state = 1;\r\nint is_done = 0;\r\nu32 dfu_timeout = 0;\r\nint bsize = 0;\r\nint blockno = 0;\r\nstruct dfu_status *dfu_stat_buf = NULL;\r\nu8 *dfu_state = NULL;\r\nu8 *block = NULL;\r\nat76_dbg(DBG_DFU, "%s( %p, %u, %d)", __func__, buf, size,\r\nmanifest_sync_timeout);\r\nif (!size) {\r\ndev_err(&udev->dev, "FW buffer length invalid!\n");\r\nreturn -EINVAL;\r\n}\r\ndfu_stat_buf = kmalloc(sizeof(struct dfu_status), GFP_KERNEL);\r\nif (!dfu_stat_buf) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nblock = kmalloc(FW_BLOCK_SIZE, GFP_KERNEL);\r\nif (!block) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\ndfu_state = kmalloc(sizeof(u8), GFP_KERNEL);\r\nif (!dfu_state) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\n*dfu_state = 0;\r\ndo {\r\nif (need_dfu_state) {\r\nret = at76_dfu_get_state(udev, dfu_state);\r\nif (ret < 0) {\r\ndev_err(&udev->dev,\r\n"cannot get DFU state: %d\n", ret);\r\ngoto exit;\r\n}\r\nneed_dfu_state = 0;\r\n}\r\nswitch (*dfu_state) {\r\ncase STATE_DFU_DOWNLOAD_SYNC:\r\nat76_dbg(DBG_DFU, "STATE_DFU_DOWNLOAD_SYNC");\r\nret = at76_dfu_get_status(udev, dfu_stat_buf);\r\nif (ret >= 0) {\r\n*dfu_state = dfu_stat_buf->state;\r\ndfu_timeout = at76_get_timeout(dfu_stat_buf);\r\nneed_dfu_state = 0;\r\n} else\r\ndev_err(&udev->dev,\r\n"at76_dfu_get_status returned %d\n",\r\nret);\r\nbreak;\r\ncase STATE_DFU_DOWNLOAD_BUSY:\r\nat76_dbg(DBG_DFU, "STATE_DFU_DOWNLOAD_BUSY");\r\nneed_dfu_state = 1;\r\nat76_dbg(DBG_DFU, "DFU: Resetting device");\r\nschedule_timeout_interruptible(dfu_timeout);\r\nbreak;\r\ncase STATE_DFU_DOWNLOAD_IDLE:\r\nat76_dbg(DBG_DFU, "DOWNLOAD...");\r\ncase STATE_DFU_IDLE:\r\nat76_dbg(DBG_DFU, "DFU IDLE");\r\nbsize = min_t(int, size, FW_BLOCK_SIZE);\r\nmemcpy(block, buf, bsize);\r\nat76_dbg(DBG_DFU, "int fw, size left = %5d, "\r\n"bsize = %4d, blockno = %2d", size, bsize,\r\nblockno);\r\nret =\r\nat76_load_int_fw_block(udev, blockno, block, bsize);\r\nbuf += bsize;\r\nsize -= bsize;\r\nblockno++;\r\nif (ret != bsize)\r\ndev_err(&udev->dev,\r\n"at76_load_int_fw_block returned %d\n",\r\nret);\r\nneed_dfu_state = 1;\r\nbreak;\r\ncase STATE_DFU_MANIFEST_SYNC:\r\nat76_dbg(DBG_DFU, "STATE_DFU_MANIFEST_SYNC");\r\nret = at76_dfu_get_status(udev, dfu_stat_buf);\r\nif (ret < 0)\r\nbreak;\r\n*dfu_state = dfu_stat_buf->state;\r\ndfu_timeout = at76_get_timeout(dfu_stat_buf);\r\nneed_dfu_state = 0;\r\nif (manifest_sync_timeout > 0)\r\ndfu_timeout = manifest_sync_timeout;\r\nat76_dbg(DBG_DFU, "DFU: Waiting for manifest phase");\r\nschedule_timeout_interruptible(dfu_timeout);\r\nbreak;\r\ncase STATE_DFU_MANIFEST:\r\nat76_dbg(DBG_DFU, "STATE_DFU_MANIFEST");\r\nis_done = 1;\r\nbreak;\r\ncase STATE_DFU_MANIFEST_WAIT_RESET:\r\nat76_dbg(DBG_DFU, "STATE_DFU_MANIFEST_WAIT_RESET");\r\nis_done = 1;\r\nbreak;\r\ncase STATE_DFU_UPLOAD_IDLE:\r\nat76_dbg(DBG_DFU, "STATE_DFU_UPLOAD_IDLE");\r\nbreak;\r\ncase STATE_DFU_ERROR:\r\nat76_dbg(DBG_DFU, "STATE_DFU_ERROR");\r\nret = -EPIPE;\r\nbreak;\r\ndefault:\r\nat76_dbg(DBG_DFU, "DFU UNKNOWN STATE (%d)", *dfu_state);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} while (!is_done && (ret >= 0));\r\nexit:\r\nkfree(dfu_state);\r\nkfree(block);\r\nkfree(dfu_stat_buf);\r\nif (ret >= 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void at76_ledtrig_tx_timerfunc(unsigned long data)\r\n{\r\nstatic int tx_lastactivity;\r\nif (tx_lastactivity != tx_activity) {\r\ntx_lastactivity = tx_activity;\r\nled_trigger_event(ledtrig_tx, LED_FULL);\r\nmod_timer(&ledtrig_tx_timer, jiffies + HZ / 4);\r\n} else\r\nled_trigger_event(ledtrig_tx, LED_OFF);\r\n}\r\nstatic void at76_ledtrig_tx_activity(void)\r\n{\r\ntx_activity++;\r\nif (!timer_pending(&ledtrig_tx_timer))\r\nmod_timer(&ledtrig_tx_timer, jiffies + HZ / 4);\r\n}\r\nstatic int at76_remap(struct usb_device *udev)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0a,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT |\r\nUSB_RECIP_INTERFACE, 0, 0, NULL, 0,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int at76_get_op_mode(struct usb_device *udev)\r\n{\r\nint ret;\r\nu8 saved;\r\nu8 *op_mode;\r\nop_mode = kmalloc(1, GFP_NOIO);\r\nif (!op_mode)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\r\nUSB_TYPE_VENDOR | USB_DIR_IN |\r\nUSB_RECIP_INTERFACE, 0x01, 0, op_mode, 1,\r\nUSB_CTRL_GET_TIMEOUT);\r\nsaved = *op_mode;\r\nkfree(op_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret < 1)\r\nreturn -EIO;\r\nelse\r\nreturn saved;\r\n}\r\nstatic inline int at76_load_ext_fw_block(struct usb_device *udev, int blockno,\r\nvoid *block, int size)\r\n{\r\nreturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\n0x0802, blockno, block, size,\r\nUSB_CTRL_GET_TIMEOUT);\r\n}\r\nstatic inline int at76_get_hw_cfg(struct usb_device *udev,\r\nunion at76_hwcfg *buf, int buf_size)\r\n{\r\nreturn usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\r\nUSB_TYPE_VENDOR | USB_DIR_IN |\r\nUSB_RECIP_INTERFACE, 0x0a02, 0,\r\nbuf, buf_size, USB_CTRL_GET_TIMEOUT);\r\n}\r\nstatic inline int at76_get_hw_cfg_intersil(struct usb_device *udev,\r\nunion at76_hwcfg *buf, int buf_size)\r\n{\r\nreturn usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\r\nUSB_TYPE_VENDOR | USB_DIR_IN |\r\nUSB_RECIP_INTERFACE, 0x0902, 0,\r\nbuf, buf_size, USB_CTRL_GET_TIMEOUT);\r\n}\r\nstatic int at76_get_hw_config(struct at76_priv *priv)\r\n{\r\nint ret;\r\nunion at76_hwcfg *hwcfg = kmalloc(sizeof(*hwcfg), GFP_KERNEL);\r\nif (!hwcfg)\r\nreturn -ENOMEM;\r\nif (at76_is_intersil(priv->board_type)) {\r\nret = at76_get_hw_cfg_intersil(priv->udev, hwcfg,\r\nsizeof(hwcfg->i));\r\nif (ret < 0)\r\ngoto exit;\r\nmemcpy(priv->mac_addr, hwcfg->i.mac_addr, ETH_ALEN);\r\npriv->regulatory_domain = hwcfg->i.regulatory_domain;\r\n} else if (at76_is_503rfmd(priv->board_type)) {\r\nret = at76_get_hw_cfg(priv->udev, hwcfg, sizeof(hwcfg->r3));\r\nif (ret < 0)\r\ngoto exit;\r\nmemcpy(priv->mac_addr, hwcfg->r3.mac_addr, ETH_ALEN);\r\npriv->regulatory_domain = hwcfg->r3.regulatory_domain;\r\n} else {\r\nret = at76_get_hw_cfg(priv->udev, hwcfg, sizeof(hwcfg->r5));\r\nif (ret < 0)\r\ngoto exit;\r\nmemcpy(priv->mac_addr, hwcfg->r5.mac_addr, ETH_ALEN);\r\npriv->regulatory_domain = hwcfg->r5.regulatory_domain;\r\n}\r\nexit:\r\nkfree(hwcfg);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy, "cannot get HW Config (error %d)\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic struct reg_domain const *at76_get_reg_domain(u16 code)\r\n{\r\nint i;\r\nstatic struct reg_domain const fd_tab[] = {\r\n{ 0x10, "FCC (USA)", 0x7ff },\r\n{ 0x20, "IC (Canada)", 0x7ff },\r\n{ 0x30, "ETSI (most of Europe)", 0x1fff },\r\n{ 0x31, "Spain", 0x600 },\r\n{ 0x32, "France", 0x1e00 },\r\n{ 0x40, "MKK (Japan)", 0x2000 },\r\n{ 0x41, "MKK1 (Japan)", 0x3fff },\r\n{ 0x50, "Israel", 0x3fc },\r\n{ 0x00, "<unknown>", 0xffffffff }\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(fd_tab) - 1; i++)\r\nif (code == fd_tab[i].code)\r\nbreak;\r\nreturn &fd_tab[i];\r\n}\r\nstatic inline int at76_get_mib(struct usb_device *udev, u16 mib, void *buf,\r\nint buf_size)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,\r\nUSB_TYPE_VENDOR | USB_DIR_IN |\r\nUSB_RECIP_INTERFACE, mib << 8, 0, buf, buf_size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (ret >= 0 && ret != buf_size)\r\nreturn -EIO;\r\nreturn ret;\r\n}\r\nstatic inline int at76_get_cmd_status(struct usb_device *udev, u8 cmd)\r\n{\r\nu8 *stat_buf;\r\nint ret;\r\nstat_buf = kmalloc(40, GFP_NOIO);\r\nif (!stat_buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x22,\r\nUSB_TYPE_VENDOR | USB_DIR_IN |\r\nUSB_RECIP_INTERFACE, cmd, 0, stat_buf,\r\n40, USB_CTRL_GET_TIMEOUT);\r\nif (ret >= 0)\r\nret = stat_buf[5];\r\nkfree(stat_buf);\r\nreturn ret;\r\n}\r\nstatic const char *at76_get_cmd_string(u8 cmd_status)\r\n{\r\nswitch (cmd_status) {\r\nMAKE_CMD_CASE(CMD_SET_MIB);\r\nMAKE_CMD_CASE(CMD_GET_MIB);\r\nMAKE_CMD_CASE(CMD_SCAN);\r\nMAKE_CMD_CASE(CMD_JOIN);\r\nMAKE_CMD_CASE(CMD_START_IBSS);\r\nMAKE_CMD_CASE(CMD_RADIO_ON);\r\nMAKE_CMD_CASE(CMD_RADIO_OFF);\r\nMAKE_CMD_CASE(CMD_STARTUP);\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic int at76_set_card_command(struct usb_device *udev, u8 cmd, void *buf,\r\nint buf_size)\r\n{\r\nint ret;\r\nstruct at76_command *cmd_buf = kmalloc(sizeof(struct at76_command) +\r\nbuf_size, GFP_KERNEL);\r\nif (!cmd_buf)\r\nreturn -ENOMEM;\r\ncmd_buf->cmd = cmd;\r\ncmd_buf->reserved = 0;\r\ncmd_buf->size = cpu_to_le16(buf_size);\r\nmemcpy(cmd_buf->data, buf, buf_size);\r\nat76_dbg_dump(DBG_CMD, cmd_buf, sizeof(struct at76_command) + buf_size,\r\n"issuing command %s (0x%02x)",\r\nat76_get_cmd_string(cmd), cmd);\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,\r\n0, 0, cmd_buf,\r\nsizeof(struct at76_command) + buf_size,\r\nUSB_CTRL_GET_TIMEOUT);\r\nkfree(cmd_buf);\r\nreturn ret;\r\n}\r\nstatic const char *at76_get_cmd_status_string(u8 cmd_status)\r\n{\r\nswitch (cmd_status) {\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_IDLE);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_COMPLETE);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_UNKNOWN);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_INVALID_PARAMETER);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_FUNCTION_NOT_SUPPORTED);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_TIME_OUT);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_IN_PROGRESS);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_HOST_FAILURE);\r\nMAKE_CMD_STATUS_CASE(CMD_STATUS_SCAN_FAILED);\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic int at76_wait_completion(struct at76_priv *priv, int cmd)\r\n{\r\nint status = 0;\r\nunsigned long timeout = jiffies + CMD_COMPLETION_TIMEOUT;\r\ndo {\r\nstatus = at76_get_cmd_status(priv->udev, cmd);\r\nif (status < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_cmd_status failed: %d\n",\r\nstatus);\r\nbreak;\r\n}\r\nat76_dbg(DBG_WAIT_COMPLETE,\r\n"%s: Waiting on cmd %d, status = %d (%s)",\r\nwiphy_name(priv->hw->wiphy), cmd, status,\r\nat76_get_cmd_status_string(status));\r\nif (status != CMD_STATUS_IN_PROGRESS\r\n&& status != CMD_STATUS_IDLE)\r\nbreak;\r\nschedule_timeout_interruptible(HZ / 10);\r\nif (time_after(jiffies, timeout)) {\r\nwiphy_err(priv->hw->wiphy,\r\n"completion timeout for command %d\n", cmd);\r\nstatus = -ETIMEDOUT;\r\nbreak;\r\n}\r\n} while (1);\r\nreturn status;\r\n}\r\nstatic int at76_set_mib(struct at76_priv *priv, struct set_mib_buffer *buf)\r\n{\r\nint ret;\r\nret = at76_set_card_command(priv->udev, CMD_SET_MIB, buf,\r\noffsetof(struct set_mib_buffer,\r\ndata) + buf->size);\r\nif (ret < 0)\r\nreturn ret;\r\nret = at76_wait_completion(priv, CMD_SET_MIB);\r\nif (ret != CMD_STATUS_COMPLETE) {\r\nwiphy_info(priv->hw->wiphy,\r\n"set_mib: at76_wait_completion failed with %d\n",\r\nret);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int at76_set_radio(struct at76_priv *priv, int enable)\r\n{\r\nint ret;\r\nint cmd;\r\nif (priv->radio_on == enable)\r\nreturn 0;\r\ncmd = enable ? CMD_RADIO_ON : CMD_RADIO_OFF;\r\nret = at76_set_card_command(priv->udev, cmd, NULL, 0);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_set_card_command(%d) failed: %d\n", cmd, ret);\r\nelse\r\nret = 1;\r\npriv->radio_on = enable;\r\nreturn ret;\r\n}\r\nstatic int at76_set_pm_mode(struct at76_priv *priv)\r\n{\r\nint ret = 0;\r\npriv->mib_buf.type = MIB_MAC_MGMT;\r\npriv->mib_buf.size = 1;\r\npriv->mib_buf.index = offsetof(struct mib_mac_mgmt, power_mgmt_mode);\r\npriv->mib_buf.data.byte = priv->pm_mode;\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy, "set_mib (pm_mode) failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int at76_set_preamble(struct at76_priv *priv, u8 type)\r\n{\r\nint ret = 0;\r\npriv->mib_buf.type = MIB_LOCAL;\r\npriv->mib_buf.size = 1;\r\npriv->mib_buf.index = offsetof(struct mib_local, preamble_type);\r\npriv->mib_buf.data.byte = type;\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy, "set_mib (preamble) failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int at76_set_frag(struct at76_priv *priv, u16 size)\r\n{\r\nint ret = 0;\r\npriv->mib_buf.type = MIB_MAC;\r\npriv->mib_buf.size = 2;\r\npriv->mib_buf.index = offsetof(struct mib_mac, frag_threshold);\r\npriv->mib_buf.data.word = cpu_to_le16(size);\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy,\r\n"set_mib (frag threshold) failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int at76_set_rts(struct at76_priv *priv, u16 size)\r\n{\r\nint ret = 0;\r\npriv->mib_buf.type = MIB_MAC;\r\npriv->mib_buf.size = 2;\r\npriv->mib_buf.index = offsetof(struct mib_mac, rts_threshold);\r\npriv->mib_buf.data.word = cpu_to_le16(size);\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy, "set_mib (rts) failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int at76_set_autorate_fallback(struct at76_priv *priv, int onoff)\r\n{\r\nint ret = 0;\r\npriv->mib_buf.type = MIB_LOCAL;\r\npriv->mib_buf.size = 1;\r\npriv->mib_buf.index = offsetof(struct mib_local, txautorate_fallback);\r\npriv->mib_buf.data.byte = onoff;\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy,\r\n"set_mib (autorate fallback) failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void at76_dump_mib_mac_addr(struct at76_priv *priv)\r\n{\r\nint i;\r\nint ret;\r\nstruct mib_mac_addr *m = kmalloc(sizeof(struct mib_mac_addr),\r\nGFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_MAC_ADDR, m,\r\nsizeof(struct mib_mac_addr));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (MAC_ADDR) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB MAC_ADDR: mac_addr %pM res 0x%x 0x%x",\r\nwiphy_name(priv->hw->wiphy),\r\nm->mac_addr, m->res[0], m->res[1]);\r\nfor (i = 0; i < ARRAY_SIZE(m->group_addr); i++)\r\nat76_dbg(DBG_MIB, "%s: MIB MAC_ADDR: group addr %d: %pM, "\r\n"status %d", wiphy_name(priv->hw->wiphy), i,\r\nm->group_addr[i], m->group_addr_status[i]);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_mac_wep(struct at76_priv *priv)\r\n{\r\nint i;\r\nint ret;\r\nint key_len;\r\nstruct mib_mac_wep *m = kmalloc(sizeof(struct mib_mac_wep), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_MAC_WEP, m,\r\nsizeof(struct mib_mac_wep));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (MAC_WEP) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB MAC_WEP: priv_invoked %u def_key_id %u "\r\n"key_len %u excl_unencr %u wep_icv_err %u wep_excluded %u "\r\n"encr_level %u key %d", wiphy_name(priv->hw->wiphy),\r\nm->privacy_invoked, m->wep_default_key_id,\r\nm->wep_key_mapping_len, m->exclude_unencrypted,\r\nle32_to_cpu(m->wep_icv_error_count),\r\nle32_to_cpu(m->wep_excluded_count), m->encryption_level,\r\nm->wep_default_key_id);\r\nkey_len = (m->encryption_level == 1) ?\r\nWEP_SMALL_KEY_LEN : WEP_LARGE_KEY_LEN;\r\nfor (i = 0; i < WEP_KEYS; i++)\r\nat76_dbg(DBG_MIB, "%s: MIB MAC_WEP: key %d: %*phD",\r\nwiphy_name(priv->hw->wiphy), i,\r\nkey_len, m->wep_default_keyvalue[i]);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_mac_mgmt(struct at76_priv *priv)\r\n{\r\nint ret;\r\nstruct mib_mac_mgmt *m = kmalloc(sizeof(struct mib_mac_mgmt),\r\nGFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_MAC_MGMT, m,\r\nsizeof(struct mib_mac_mgmt));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (MAC_MGMT) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB MAC_MGMT: beacon_period %d CFP_max_duration "\r\n"%d medium_occupancy_limit %d station_id 0x%x ATIM_window %d "\r\n"CFP_mode %d privacy_opt_impl %d DTIM_period %d CFP_period %d "\r\n"current_bssid %pM current_essid %*phD current_bss_type %d "\r\n"pm_mode %d ibss_change %d res %d "\r\n"multi_domain_capability_implemented %d "\r\n"international_roaming %d country_string %.3s",\r\nwiphy_name(priv->hw->wiphy), le16_to_cpu(m->beacon_period),\r\nle16_to_cpu(m->CFP_max_duration),\r\nle16_to_cpu(m->medium_occupancy_limit),\r\nle16_to_cpu(m->station_id), le16_to_cpu(m->ATIM_window),\r\nm->CFP_mode, m->privacy_option_implemented, m->DTIM_period,\r\nm->CFP_period, m->current_bssid,\r\nIW_ESSID_MAX_SIZE, m->current_essid,\r\nm->current_bss_type, m->power_mgmt_mode, m->ibss_change,\r\nm->res, m->multi_domain_capability_implemented,\r\nm->multi_domain_capability_enabled, m->country_string);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_mac(struct at76_priv *priv)\r\n{\r\nint ret;\r\nstruct mib_mac *m = kmalloc(sizeof(struct mib_mac), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_MAC, m, sizeof(struct mib_mac));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (MAC) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB MAC: max_tx_msdu_lifetime %d "\r\n"max_rx_lifetime %d frag_threshold %d rts_threshold %d "\r\n"cwmin %d cwmax %d short_retry_time %d long_retry_time %d "\r\n"scan_type %d scan_channel %d probe_delay %u "\r\n"min_channel_time %d max_channel_time %d listen_int %d "\r\n"desired_ssid %*phD desired_bssid %pM desired_bsstype %d",\r\nwiphy_name(priv->hw->wiphy),\r\nle32_to_cpu(m->max_tx_msdu_lifetime),\r\nle32_to_cpu(m->max_rx_lifetime),\r\nle16_to_cpu(m->frag_threshold), le16_to_cpu(m->rts_threshold),\r\nle16_to_cpu(m->cwmin), le16_to_cpu(m->cwmax),\r\nm->short_retry_time, m->long_retry_time, m->scan_type,\r\nm->scan_channel, le16_to_cpu(m->probe_delay),\r\nle16_to_cpu(m->min_channel_time),\r\nle16_to_cpu(m->max_channel_time),\r\nle16_to_cpu(m->listen_interval),\r\nIW_ESSID_MAX_SIZE, m->desired_ssid,\r\nm->desired_bssid, m->desired_bsstype);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_phy(struct at76_priv *priv)\r\n{\r\nint ret;\r\nstruct mib_phy *m = kmalloc(sizeof(struct mib_phy), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_PHY, m, sizeof(struct mib_phy));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (PHY) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB PHY: ed_threshold %d slot_time %d "\r\n"sifs_time %d preamble_length %d plcp_header_length %d "\r\n"mpdu_max_length %d cca_mode_supported %d operation_rate_set "\r\n"0x%x 0x%x 0x%x 0x%x channel_id %d current_cca_mode %d "\r\n"phy_type %d current_reg_domain %d",\r\nwiphy_name(priv->hw->wiphy), le32_to_cpu(m->ed_threshold),\r\nle16_to_cpu(m->slot_time), le16_to_cpu(m->sifs_time),\r\nle16_to_cpu(m->preamble_length),\r\nle16_to_cpu(m->plcp_header_length),\r\nle16_to_cpu(m->mpdu_max_length),\r\nle16_to_cpu(m->cca_mode_supported), m->operation_rate_set[0],\r\nm->operation_rate_set[1], m->operation_rate_set[2],\r\nm->operation_rate_set[3], m->channel_id, m->current_cca_mode,\r\nm->phy_type, m->current_reg_domain);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_local(struct at76_priv *priv)\r\n{\r\nint ret;\r\nstruct mib_local *m = kmalloc(sizeof(*m), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_LOCAL, m, sizeof(*m));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (LOCAL) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB LOCAL: beacon_enable %d "\r\n"txautorate_fallback %d ssid_size %d promiscuous_mode %d "\r\n"preamble_type %d", wiphy_name(priv->hw->wiphy),\r\nm->beacon_enable,\r\nm->txautorate_fallback, m->ssid_size, m->promiscuous_mode,\r\nm->preamble_type);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic void at76_dump_mib_mdomain(struct at76_priv *priv)\r\n{\r\nint ret;\r\nstruct mib_mdomain *m = kmalloc(sizeof(struct mib_mdomain), GFP_KERNEL);\r\nif (!m)\r\nreturn;\r\nret = at76_get_mib(priv->udev, MIB_MDOMAIN, m,\r\nsizeof(struct mib_mdomain));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"at76_get_mib (MDOMAIN) failed: %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_MIB, "%s: MIB MDOMAIN: channel_list %*phD",\r\nwiphy_name(priv->hw->wiphy),\r\n(int)sizeof(m->channel_list), m->channel_list);\r\nat76_dbg(DBG_MIB, "%s: MIB MDOMAIN: tx_powerlevel %*phD",\r\nwiphy_name(priv->hw->wiphy),\r\n(int)sizeof(m->tx_powerlevel), m->tx_powerlevel);\r\nexit:\r\nkfree(m);\r\n}\r\nstatic int at76_start_monitor(struct at76_priv *priv)\r\n{\r\nstruct at76_req_scan scan;\r\nint ret;\r\nmemset(&scan, 0, sizeof(struct at76_req_scan));\r\neth_broadcast_addr(scan.bssid);\r\nscan.channel = priv->channel;\r\nscan.scan_type = SCAN_TYPE_PASSIVE;\r\nscan.international_scan = 0;\r\nscan.min_channel_time = cpu_to_le16(priv->scan_min_time);\r\nscan.max_channel_time = cpu_to_le16(priv->scan_max_time);\r\nscan.probe_delay = cpu_to_le16(0);\r\nret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));\r\nif (ret >= 0)\r\nret = at76_get_cmd_status(priv->udev, CMD_SCAN);\r\nreturn ret;\r\n}\r\nstatic inline int at76_calc_padding(int wlen)\r\n{\r\nwlen += AT76_TX_HDRLEN;\r\nwlen = wlen % 64;\r\nif (wlen < 50)\r\nreturn 50 - wlen;\r\nif (wlen >= 61)\r\nreturn 64 + 50 - wlen;\r\nreturn 0;\r\n}\r\nstatic void at76_rx_callback(struct urb *urb)\r\n{\r\nstruct at76_priv *priv = urb->context;\r\npriv->rx_tasklet.data = (unsigned long)urb;\r\ntasklet_schedule(&priv->rx_tasklet);\r\n}\r\nstatic int at76_submit_rx_urb(struct at76_priv *priv)\r\n{\r\nint ret;\r\nint size;\r\nstruct sk_buff *skb = priv->rx_skb;\r\nif (!priv->rx_urb) {\r\nwiphy_err(priv->hw->wiphy, "%s: priv->rx_urb is NULL\n",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nif (!skb) {\r\nskb = dev_alloc_skb(sizeof(struct at76_rx_buffer));\r\nif (!skb) {\r\nwiphy_err(priv->hw->wiphy,\r\n"cannot allocate rx skbuff\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\npriv->rx_skb = skb;\r\n} else {\r\nskb_push(skb, skb_headroom(skb));\r\nskb_trim(skb, 0);\r\n}\r\nsize = skb_tailroom(skb);\r\nusb_fill_bulk_urb(priv->rx_urb, priv->udev, priv->rx_pipe,\r\nskb_put(skb, size), size, at76_rx_callback, priv);\r\nret = usb_submit_urb(priv->rx_urb, GFP_ATOMIC);\r\nif (ret < 0) {\r\nif (ret == -ENODEV)\r\nat76_dbg(DBG_DEVSTART,\r\n"usb_submit_urb returned -ENODEV");\r\nelse\r\nwiphy_err(priv->hw->wiphy,\r\n"rx, usb_submit_urb failed: %d\n", ret);\r\n}\r\nexit:\r\nif (ret < 0 && ret != -ENODEV)\r\nwiphy_err(priv->hw->wiphy,\r\n"cannot submit rx urb - please unload the driver and/or power cycle the device\n");\r\nreturn ret;\r\n}\r\nstatic int at76_load_external_fw(struct usb_device *udev, struct fwentry *fwe)\r\n{\r\nint ret;\r\nint op_mode;\r\nint blockno = 0;\r\nint bsize;\r\nu8 *block;\r\nu8 *buf = fwe->extfw;\r\nint size = fwe->extfw_size;\r\nif (!buf || !size)\r\nreturn -ENOENT;\r\nop_mode = at76_get_op_mode(udev);\r\nat76_dbg(DBG_DEVSTART, "opmode %d", op_mode);\r\nif (op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {\r\ndev_err(&udev->dev, "unexpected opmode %d\n", op_mode);\r\nreturn -EINVAL;\r\n}\r\nblock = kmalloc(FW_BLOCK_SIZE, GFP_KERNEL);\r\nif (!block)\r\nreturn -ENOMEM;\r\nat76_dbg(DBG_DEVSTART, "downloading external firmware");\r\ndo {\r\nbsize = min_t(int, size, FW_BLOCK_SIZE);\r\nmemcpy(block, buf, bsize);\r\nat76_dbg(DBG_DEVSTART,\r\n"ext fw, size left = %5d, bsize = %4d, blockno = %2d",\r\nsize, bsize, blockno);\r\nret = at76_load_ext_fw_block(udev, blockno, block, bsize);\r\nif (ret != bsize) {\r\ndev_err(&udev->dev,\r\n"loading %dth firmware block failed: %d\n",\r\nblockno, ret);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nbuf += bsize;\r\nsize -= bsize;\r\nblockno++;\r\n} while (bsize > 0);\r\nif (at76_is_505a(fwe->board_type)) {\r\nat76_dbg(DBG_DEVSTART, "200 ms delay for 505a");\r\nschedule_timeout_interruptible(HZ / 5 + 1);\r\n}\r\nexit:\r\nkfree(block);\r\nif (ret < 0)\r\ndev_err(&udev->dev,\r\n"downloading external firmware failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int at76_load_internal_fw(struct usb_device *udev, struct fwentry *fwe)\r\n{\r\nint ret;\r\nint need_remap = !at76_is_505a(fwe->board_type);\r\nret = at76_usbdfu_download(udev, fwe->intfw, fwe->intfw_size,\r\nneed_remap ? 0 : 2 * HZ);\r\nif (ret < 0) {\r\ndev_err(&udev->dev,\r\n"downloading internal fw failed with %d\n", ret);\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_DEVSTART, "sending REMAP");\r\nif (need_remap) {\r\nret = at76_remap(udev);\r\nif (ret < 0) {\r\ndev_err(&udev->dev,\r\n"sending REMAP failed with %d\n", ret);\r\ngoto exit;\r\n}\r\n}\r\nat76_dbg(DBG_DEVSTART, "sleeping for 2 seconds");\r\nschedule_timeout_interruptible(2 * HZ + 1);\r\nusb_reset_device(udev);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int at76_startup_device(struct at76_priv *priv)\r\n{\r\nstruct at76_card_config *ccfg = &priv->card_config;\r\nint ret;\r\nat76_dbg(DBG_PARAMS,\r\n"%s param: ssid %.*s (%*phD) mode %s ch %d wep %s key %d "\r\n"keylen %d", wiphy_name(priv->hw->wiphy), priv->essid_size,\r\npriv->essid, IW_ESSID_MAX_SIZE, priv->essid,\r\npriv->iw_mode == IW_MODE_ADHOC ? "adhoc" : "infra",\r\npriv->channel, priv->wep_enabled ? "enabled" : "disabled",\r\npriv->wep_key_id, priv->wep_keys_len[priv->wep_key_id]);\r\nat76_dbg(DBG_PARAMS,\r\n"%s param: preamble %s rts %d retry %d frag %d "\r\n"txrate %s auth_mode %d", wiphy_name(priv->hw->wiphy),\r\npreambles[priv->preamble_type], priv->rts_threshold,\r\npriv->short_retry_limit, priv->frag_threshold,\r\npriv->txrate == TX_RATE_1MBIT ? "1MBit" : priv->txrate ==\r\nTX_RATE_2MBIT ? "2MBit" : priv->txrate ==\r\nTX_RATE_5_5MBIT ? "5.5MBit" : priv->txrate ==\r\nTX_RATE_11MBIT ? "11MBit" : priv->txrate ==\r\nTX_RATE_AUTO ? "auto" : "<invalid>", priv->auth_mode);\r\nat76_dbg(DBG_PARAMS,\r\n"%s param: pm_mode %d pm_period %d auth_mode %s "\r\n"scan_times %d %d scan_mode %s",\r\nwiphy_name(priv->hw->wiphy), priv->pm_mode, priv->pm_period,\r\npriv->auth_mode == WLAN_AUTH_OPEN ? "open" : "shared_secret",\r\npriv->scan_min_time, priv->scan_max_time,\r\npriv->scan_mode == SCAN_TYPE_ACTIVE ? "active" : "passive");\r\nmemset(ccfg, 0, sizeof(struct at76_card_config));\r\nccfg->promiscuous_mode = 0;\r\nccfg->short_retry_limit = priv->short_retry_limit;\r\nif (priv->wep_enabled) {\r\nif (priv->wep_keys_len[priv->wep_key_id] > WEP_SMALL_KEY_LEN)\r\nccfg->encryption_type = 2;\r\nelse\r\nccfg->encryption_type = 1;\r\nccfg->exclude_unencrypted = 1;\r\n} else {\r\nccfg->exclude_unencrypted = 0;\r\nccfg->encryption_type = 0;\r\n}\r\nccfg->rts_threshold = cpu_to_le16(priv->rts_threshold);\r\nccfg->fragmentation_threshold = cpu_to_le16(priv->frag_threshold);\r\nmemcpy(ccfg->basic_rate_set, hw_rates, 4);\r\nccfg->auto_rate_fallback = (priv->txrate == TX_RATE_AUTO ? 1 : 0);\r\nccfg->channel = priv->channel;\r\nccfg->privacy_invoked = priv->wep_enabled;\r\nmemcpy(ccfg->current_ssid, priv->essid, IW_ESSID_MAX_SIZE);\r\nccfg->ssid_len = priv->essid_size;\r\nccfg->wep_default_key_id = priv->wep_key_id;\r\nmemcpy(ccfg->wep_default_key_value, priv->wep_keys,\r\nsizeof(priv->wep_keys));\r\nccfg->short_preamble = priv->preamble_type;\r\nccfg->beacon_period = cpu_to_le16(priv->beacon_period);\r\nret = at76_set_card_command(priv->udev, CMD_STARTUP, &priv->card_config,\r\nsizeof(struct at76_card_config));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy, "at76_set_card_command failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nat76_wait_completion(priv, CMD_STARTUP);\r\neth_zero_addr(priv->bssid);\r\npriv->scanning = false;\r\nif (at76_set_radio(priv, 1) == 1)\r\nat76_wait_completion(priv, CMD_RADIO_ON);\r\nret = at76_set_preamble(priv, priv->preamble_type);\r\nif (ret < 0)\r\nreturn ret;\r\nret = at76_set_frag(priv, priv->frag_threshold);\r\nif (ret < 0)\r\nreturn ret;\r\nret = at76_set_rts(priv, priv->rts_threshold);\r\nif (ret < 0)\r\nreturn ret;\r\nret = at76_set_autorate_fallback(priv,\r\npriv->txrate == TX_RATE_AUTO ? 1 : 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = at76_set_pm_mode(priv);\r\nif (ret < 0)\r\nreturn ret;\r\nif (at76_debug & DBG_MIB) {\r\nat76_dump_mib_mac(priv);\r\nat76_dump_mib_mac_addr(priv);\r\nat76_dump_mib_mac_mgmt(priv);\r\nat76_dump_mib_mac_wep(priv);\r\nat76_dump_mib_mdomain(priv);\r\nat76_dump_mib_phy(priv);\r\nat76_dump_mib_local(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic void at76_work_set_promisc(struct work_struct *work)\r\n{\r\nstruct at76_priv *priv = container_of(work, struct at76_priv,\r\nwork_set_promisc);\r\nint ret = 0;\r\nif (priv->device_unplugged)\r\nreturn;\r\nmutex_lock(&priv->mtx);\r\npriv->mib_buf.type = MIB_LOCAL;\r\npriv->mib_buf.size = 1;\r\npriv->mib_buf.index = offsetof(struct mib_local, promiscuous_mode);\r\npriv->mib_buf.data.byte = priv->promisc ? 1 : 0;\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy,\r\n"set_mib (promiscuous_mode) failed: %d\n", ret);\r\nmutex_unlock(&priv->mtx);\r\n}\r\nstatic void at76_work_submit_rx(struct work_struct *work)\r\n{\r\nstruct at76_priv *priv = container_of(work, struct at76_priv,\r\nwork_submit_rx);\r\nmutex_lock(&priv->mtx);\r\nat76_submit_rx_urb(priv);\r\nmutex_unlock(&priv->mtx);\r\n}\r\nstatic inline int at76_guess_freq(struct at76_priv *priv)\r\n{\r\nsize_t el_off;\r\nconst u8 *el;\r\nint channel = priv->channel;\r\nint len = priv->rx_skb->len;\r\nstruct ieee80211_hdr *hdr = (void *)priv->rx_skb->data;\r\nif (!priv->scanning)\r\ngoto exit;\r\nif (len < 24)\r\ngoto exit;\r\nif (ieee80211_is_probe_resp(hdr->frame_control)) {\r\nel_off = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\r\nel = ((struct ieee80211_mgmt *)hdr)->u.probe_resp.variable;\r\n} else if (ieee80211_is_beacon(hdr->frame_control)) {\r\nel_off = offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nel = ((struct ieee80211_mgmt *)hdr)->u.beacon.variable;\r\n} else {\r\ngoto exit;\r\n}\r\nlen -= el_off;\r\nel = cfg80211_find_ie(WLAN_EID_DS_PARAMS, el, len);\r\nif (el && el[1] > 0)\r\nchannel = el[2];\r\nexit:\r\nreturn ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\r\n}\r\nstatic void at76_rx_tasklet(unsigned long param)\r\n{\r\nstruct urb *urb = (struct urb *)param;\r\nstruct at76_priv *priv = urb->context;\r\nstruct at76_rx_buffer *buf;\r\nstruct ieee80211_rx_status rx_status = { 0 };\r\nif (priv->device_unplugged) {\r\nat76_dbg(DBG_DEVSTART, "device unplugged");\r\nat76_dbg(DBG_DEVSTART, "urb status %d", urb->status);\r\nreturn;\r\n}\r\nif (!priv->rx_skb || !priv->rx_skb->data)\r\nreturn;\r\nbuf = (struct at76_rx_buffer *)priv->rx_skb->data;\r\nif (urb->status != 0) {\r\nif (urb->status != -ENOENT && urb->status != -ECONNRESET)\r\nat76_dbg(DBG_URB,\r\n"%s %s: - nonzero Rx bulk status received: %d",\r\n__func__, wiphy_name(priv->hw->wiphy),\r\nurb->status);\r\nreturn;\r\n}\r\nat76_dbg(DBG_RX_ATMEL_HDR,\r\n"%s: rx frame: rate %d rssi %d noise %d link %d",\r\nwiphy_name(priv->hw->wiphy), buf->rx_rate, buf->rssi,\r\nbuf->noise_level, buf->link_quality);\r\nskb_pull(priv->rx_skb, AT76_RX_HDRLEN);\r\nskb_trim(priv->rx_skb, le16_to_cpu(buf->wlength));\r\nat76_dbg_dump(DBG_RX_DATA, priv->rx_skb->data,\r\npriv->rx_skb->len, "RX: len=%d", priv->rx_skb->len);\r\nrx_status.signal = buf->rssi;\r\nrx_status.flag |= RX_FLAG_DECRYPTED;\r\nrx_status.flag |= RX_FLAG_IV_STRIPPED;\r\nrx_status.band = NL80211_BAND_2GHZ;\r\nrx_status.freq = at76_guess_freq(priv);\r\nat76_dbg(DBG_MAC80211, "calling ieee80211_rx_irqsafe(): %d/%d",\r\npriv->rx_skb->len, priv->rx_skb->data_len);\r\nmemcpy(IEEE80211_SKB_RXCB(priv->rx_skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(priv->hw, priv->rx_skb);\r\npriv->rx_skb = NULL;\r\nat76_submit_rx_urb(priv);\r\n}\r\nstatic struct fwentry *at76_load_firmware(struct usb_device *udev,\r\nenum board_type board_type)\r\n{\r\nint ret;\r\nchar *str;\r\nstruct at76_fw_header *fwh;\r\nstruct fwentry *fwe = &firmwares[board_type];\r\nmutex_lock(&fw_mutex);\r\nif (fwe->loaded) {\r\nat76_dbg(DBG_FW, "re-using previously loaded fw");\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_FW, "downloading firmware %s", fwe->fwname);\r\nret = request_firmware(&fwe->fw, fwe->fwname, &udev->dev);\r\nif (ret < 0) {\r\ndev_err(&udev->dev, "firmware %s not found!\n",\r\nfwe->fwname);\r\ndev_err(&udev->dev,\r\n"you may need to download the firmware from http://developer.berlios.de/projects/at76c503a/\n");\r\ngoto exit;\r\n}\r\nat76_dbg(DBG_FW, "got it.");\r\nfwh = (struct at76_fw_header *)(fwe->fw->data);\r\nif (fwe->fw->size <= sizeof(*fwh)) {\r\ndev_err(&udev->dev,\r\n"firmware is too short (0x%zx)\n", fwe->fw->size);\r\ngoto exit;\r\n}\r\nfwe->board_type = le32_to_cpu(fwh->board_type);\r\nif (fwe->board_type != board_type) {\r\ndev_err(&udev->dev,\r\n"board type mismatch, requested %u, got %u\n",\r\nboard_type, fwe->board_type);\r\ngoto exit;\r\n}\r\nfwe->fw_version.major = fwh->major;\r\nfwe->fw_version.minor = fwh->minor;\r\nfwe->fw_version.patch = fwh->patch;\r\nfwe->fw_version.build = fwh->build;\r\nstr = (char *)fwh + le32_to_cpu(fwh->str_offset);\r\nfwe->intfw = (u8 *)fwh + le32_to_cpu(fwh->int_fw_offset);\r\nfwe->intfw_size = le32_to_cpu(fwh->int_fw_len);\r\nfwe->extfw = (u8 *)fwh + le32_to_cpu(fwh->ext_fw_offset);\r\nfwe->extfw_size = le32_to_cpu(fwh->ext_fw_len);\r\nfwe->loaded = 1;\r\ndev_printk(KERN_DEBUG, &udev->dev,\r\n"using firmware %s (version %d.%d.%d-%d)\n",\r\nfwe->fwname, fwh->major, fwh->minor, fwh->patch, fwh->build);\r\nat76_dbg(DBG_DEVSTART, "board %u, int %d:%d, ext %d:%d", board_type,\r\nle32_to_cpu(fwh->int_fw_offset), le32_to_cpu(fwh->int_fw_len),\r\nle32_to_cpu(fwh->ext_fw_offset), le32_to_cpu(fwh->ext_fw_len));\r\nat76_dbg(DBG_DEVSTART, "firmware id %s", str);\r\nexit:\r\nmutex_unlock(&fw_mutex);\r\nif (fwe->loaded)\r\nreturn fwe;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int at76_join(struct at76_priv *priv)\r\n{\r\nstruct at76_req_join join;\r\nint ret;\r\nmemset(&join, 0, sizeof(struct at76_req_join));\r\nmemcpy(join.essid, priv->essid, priv->essid_size);\r\njoin.essid_size = priv->essid_size;\r\nmemcpy(join.bssid, priv->bssid, ETH_ALEN);\r\njoin.bss_type = INFRASTRUCTURE_MODE;\r\njoin.channel = priv->channel;\r\njoin.timeout = cpu_to_le16(2000);\r\nat76_dbg(DBG_MAC80211, "%s: sending CMD_JOIN", __func__);\r\nret = at76_set_card_command(priv->udev, CMD_JOIN, &join,\r\nsizeof(struct at76_req_join));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy, "at76_set_card_command failed: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nret = at76_wait_completion(priv, CMD_JOIN);\r\nat76_dbg(DBG_MAC80211, "%s: CMD_JOIN returned: 0x%02x", __func__, ret);\r\nif (ret != CMD_STATUS_COMPLETE) {\r\nwiphy_err(priv->hw->wiphy, "at76_wait_completion failed: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nat76_set_pm_mode(priv);\r\nreturn 0;\r\n}\r\nstatic void at76_work_join_bssid(struct work_struct *work)\r\n{\r\nstruct at76_priv *priv = container_of(work, struct at76_priv,\r\nwork_join_bssid);\r\nif (priv->device_unplugged)\r\nreturn;\r\nmutex_lock(&priv->mtx);\r\nif (is_valid_ether_addr(priv->bssid))\r\nat76_join(priv);\r\nmutex_unlock(&priv->mtx);\r\n}\r\nstatic void at76_mac80211_tx_callback(struct urb *urb)\r\n{\r\nstruct at76_priv *priv = urb->context;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(priv->tx_skb);\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\nswitch (urb->status) {\r\ncase 0:\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\nbreak;\r\ndefault:\r\nat76_dbg(DBG_URB, "%s - nonzero tx status received: %d",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\nmemset(&info->status, 0, sizeof(info->status));\r\nieee80211_tx_status_irqsafe(priv->hw, priv->tx_skb);\r\npriv->tx_skb = NULL;\r\nieee80211_wake_queues(priv->hw);\r\n}\r\nstatic void at76_mac80211_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nstruct at76_tx_buffer *tx_buffer = priv->bulk_out_buffer;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\r\nint padding, submit_len, ret;\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\nif (priv->tx_urb->status == -EINPROGRESS) {\r\nwiphy_err(priv->hw->wiphy,\r\n"%s called while tx urb is pending\n", __func__);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (mgmt->frame_control & cpu_to_le16(IEEE80211_STYPE_AUTH)) {\r\nif (!ether_addr_equal_64bits(priv->bssid, mgmt->bssid)) {\r\nmemcpy(priv->bssid, mgmt->bssid, ETH_ALEN);\r\nieee80211_queue_work(hw, &priv->work_join_bssid);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\n}\r\nieee80211_stop_queues(hw);\r\nat76_ledtrig_tx_activity();\r\nWARN_ON(priv->tx_skb != NULL);\r\npriv->tx_skb = skb;\r\npadding = at76_calc_padding(skb->len);\r\nsubmit_len = AT76_TX_HDRLEN + skb->len + padding;\r\nmemset(tx_buffer, 0, sizeof(*tx_buffer));\r\ntx_buffer->padding = padding;\r\ntx_buffer->wlength = cpu_to_le16(skb->len);\r\ntx_buffer->tx_rate = ieee80211_get_tx_rate(hw, info)->hw_value;\r\nmemset(tx_buffer->reserved, 0, sizeof(tx_buffer->reserved));\r\nmemcpy(tx_buffer->packet, skb->data, skb->len);\r\nat76_dbg(DBG_TX_DATA, "%s tx: wlen 0x%x pad 0x%x rate %d hdr",\r\nwiphy_name(priv->hw->wiphy), le16_to_cpu(tx_buffer->wlength),\r\ntx_buffer->padding, tx_buffer->tx_rate);\r\nat76_dbg_dump(DBG_TX_DATA_CONTENT, tx_buffer, submit_len,\r\n"%s(): tx_buffer %d bytes:", __func__, submit_len);\r\nusb_fill_bulk_urb(priv->tx_urb, priv->udev, priv->tx_pipe, tx_buffer,\r\nsubmit_len, at76_mac80211_tx_callback, priv);\r\nret = usb_submit_urb(priv->tx_urb, GFP_ATOMIC);\r\nif (ret) {\r\nwiphy_err(priv->hw->wiphy, "error in tx submit urb: %d\n", ret);\r\nif (ret == -EINVAL)\r\nwiphy_err(priv->hw->wiphy,\r\n"-EINVAL: tx urb %p hcpriv %p complete %p\n",\r\npriv->tx_urb,\r\npriv->tx_urb->hcpriv, priv->tx_urb->complete);\r\n}\r\n}\r\nstatic int at76_mac80211_start(struct ieee80211_hw *hw)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nint ret;\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\nmutex_lock(&priv->mtx);\r\nret = at76_submit_rx_urb(priv);\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy, "open: submit_rx_urb failed: %d\n",\r\nret);\r\ngoto error;\r\n}\r\nat76_startup_device(priv);\r\nat76_start_monitor(priv);\r\nerror:\r\nmutex_unlock(&priv->mtx);\r\nreturn 0;\r\n}\r\nstatic void at76_mac80211_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\ncancel_delayed_work(&priv->dwork_hw_scan);\r\ncancel_work_sync(&priv->work_join_bssid);\r\ncancel_work_sync(&priv->work_set_promisc);\r\nmutex_lock(&priv->mtx);\r\nif (!priv->device_unplugged) {\r\nat76_set_radio(priv, 0);\r\nusb_kill_urb(priv->rx_urb);\r\n}\r\nmutex_unlock(&priv->mtx);\r\n}\r\nstatic int at76_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nint ret = 0;\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\nmutex_lock(&priv->mtx);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\npriv->iw_mode = IW_MODE_INFRA;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\nexit:\r\nmutex_unlock(&priv->mtx);\r\nreturn ret;\r\n}\r\nstatic void at76_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nat76_dbg(DBG_MAC80211, "%s()", __func__);\r\n}\r\nstatic void at76_dwork_hw_scan(struct work_struct *work)\r\n{\r\nstruct at76_priv *priv = container_of(work, struct at76_priv,\r\ndwork_hw_scan.work);\r\nstruct cfg80211_scan_info info = {\r\n.aborted = false,\r\n};\r\nint ret;\r\nif (priv->device_unplugged)\r\nreturn;\r\nmutex_lock(&priv->mtx);\r\nret = at76_get_cmd_status(priv->udev, CMD_SCAN);\r\nat76_dbg(DBG_MAC80211, "%s: CMD_SCAN status 0x%02x", __func__, ret);\r\nif (ret != CMD_STATUS_COMPLETE) {\r\nieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,\r\nSCAN_POLL_INTERVAL);\r\nmutex_unlock(&priv->mtx);\r\nreturn;\r\n}\r\nif (is_valid_ether_addr(priv->bssid))\r\nat76_join(priv);\r\npriv->scanning = false;\r\nmutex_unlock(&priv->mtx);\r\nieee80211_scan_completed(priv->hw, &info);\r\nieee80211_wake_queues(priv->hw);\r\n}\r\nstatic int at76_hw_scan(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_scan_request *hw_req)\r\n{\r\nstruct cfg80211_scan_request *req = &hw_req->req;\r\nstruct at76_priv *priv = hw->priv;\r\nstruct at76_req_scan scan;\r\nu8 *ssid = NULL;\r\nint ret, len = 0;\r\nat76_dbg(DBG_MAC80211, "%s():", __func__);\r\nif (priv->device_unplugged)\r\nreturn 0;\r\nmutex_lock(&priv->mtx);\r\nieee80211_stop_queues(hw);\r\nmemset(&scan, 0, sizeof(struct at76_req_scan));\r\neth_broadcast_addr(scan.bssid);\r\nif (req->n_ssids) {\r\nscan.scan_type = SCAN_TYPE_ACTIVE;\r\nssid = req->ssids[0].ssid;\r\nlen = req->ssids[0].ssid_len;\r\n} else {\r\nscan.scan_type = SCAN_TYPE_PASSIVE;\r\n}\r\nif (len) {\r\nmemcpy(scan.essid, ssid, len);\r\nscan.essid_size = len;\r\n}\r\nscan.min_channel_time = cpu_to_le16(priv->scan_min_time);\r\nscan.max_channel_time = cpu_to_le16(priv->scan_max_time);\r\nscan.probe_delay = cpu_to_le16(priv->scan_min_time * 1000);\r\nscan.international_scan = 0;\r\nat76_dbg(DBG_MAC80211, "%s: sending CMD_SCAN", __func__);\r\nret = at76_set_card_command(priv->udev, CMD_SCAN, &scan, sizeof(scan));\r\nif (ret < 0) {\r\nwiphy_err(priv->hw->wiphy, "CMD_SCAN failed: %d\n", ret);\r\ngoto exit;\r\n}\r\npriv->scanning = true;\r\nieee80211_queue_delayed_work(priv->hw, &priv->dwork_hw_scan,\r\nSCAN_POLL_INTERVAL);\r\nexit:\r\nmutex_unlock(&priv->mtx);\r\nreturn 0;\r\n}\r\nstatic int at76_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nat76_dbg(DBG_MAC80211, "%s(): channel %d",\r\n__func__, hw->conf.chandef.chan->hw_value);\r\nat76_dbg_dump(DBG_MAC80211, priv->bssid, ETH_ALEN, "bssid:");\r\nmutex_lock(&priv->mtx);\r\npriv->channel = hw->conf.chandef.chan->hw_value;\r\nif (is_valid_ether_addr(priv->bssid))\r\nat76_join(priv);\r\nelse\r\nat76_start_monitor(priv);\r\nmutex_unlock(&priv->mtx);\r\nreturn 0;\r\n}\r\nstatic void at76_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *conf,\r\nu32 changed)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nat76_dbg(DBG_MAC80211, "%s():", __func__);\r\nif (!(changed & BSS_CHANGED_BSSID))\r\nreturn;\r\nat76_dbg_dump(DBG_MAC80211, conf->bssid, ETH_ALEN, "bssid:");\r\nmutex_lock(&priv->mtx);\r\nmemcpy(priv->bssid, conf->bssid, ETH_ALEN);\r\nif (is_valid_ether_addr(priv->bssid))\r\nat76_join(priv);\r\nmutex_unlock(&priv->mtx);\r\n}\r\nstatic void at76_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags, u64 multicast)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nint flags;\r\nat76_dbg(DBG_MAC80211, "%s(): changed_flags=0x%08x "\r\n"total_flags=0x%08x",\r\n__func__, changed_flags, *total_flags);\r\nflags = changed_flags & AT76_SUPPORTED_FILTERS;\r\n*total_flags = AT76_SUPPORTED_FILTERS;\r\nif (priv->device_unplugged)\r\nreturn;\r\nif (flags && !priv->promisc) {\r\npriv->promisc = 1;\r\n} else if (!flags && priv->promisc) {\r\npriv->promisc = 0;\r\n} else\r\nreturn;\r\nieee80211_queue_work(hw, &priv->work_set_promisc);\r\n}\r\nstatic int at76_set_wep(struct at76_priv *priv)\r\n{\r\nint ret = 0;\r\nstruct mib_mac_wep *mib_data = &priv->mib_buf.data.wep_mib;\r\npriv->mib_buf.type = MIB_MAC_WEP;\r\npriv->mib_buf.size = sizeof(struct mib_mac_wep);\r\npriv->mib_buf.index = 0;\r\nmemset(mib_data, 0, sizeof(*mib_data));\r\nif (priv->wep_enabled) {\r\nif (priv->wep_keys_len[priv->wep_key_id] > WEP_SMALL_KEY_LEN)\r\nmib_data->encryption_level = 2;\r\nelse\r\nmib_data->encryption_level = 1;\r\nmib_data->exclude_unencrypted = 1;\r\n} else {\r\nmib_data->exclude_unencrypted = 0;\r\nmib_data->encryption_level = 0;\r\n}\r\nmib_data->privacy_invoked = priv->wep_enabled;\r\nmib_data->wep_default_key_id = priv->wep_key_id;\r\nmemcpy(mib_data->wep_default_keyvalue, priv->wep_keys,\r\nsizeof(priv->wep_keys));\r\nret = at76_set_mib(priv, &priv->mib_buf);\r\nif (ret < 0)\r\nwiphy_err(priv->hw->wiphy,\r\n"set_mib (wep) failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int at76_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct at76_priv *priv = hw->priv;\r\nint i;\r\nat76_dbg(DBG_MAC80211, "%s(): cmd %d key->cipher %d key->keyidx %d "\r\n"key->keylen %d",\r\n__func__, cmd, key->cipher, key->keyidx, key->keylen);\r\nif ((key->cipher != WLAN_CIPHER_SUITE_WEP40) &&\r\n(key->cipher != WLAN_CIPHER_SUITE_WEP104))\r\nreturn -EOPNOTSUPP;\r\nkey->hw_key_idx = key->keyidx;\r\nmutex_lock(&priv->mtx);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nmemcpy(priv->wep_keys[key->keyidx], key->key, key->keylen);\r\npriv->wep_keys_len[key->keyidx] = key->keylen;\r\npriv->wep_key_id = key->keyidx;\r\nbreak;\r\ncase DISABLE_KEY:\r\ndefault:\r\npriv->wep_keys_len[key->keyidx] = 0;\r\nbreak;\r\n}\r\npriv->wep_enabled = 0;\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (priv->wep_keys_len[i] != 0)\r\npriv->wep_enabled = 1;\r\n}\r\nat76_set_wep(priv);\r\nmutex_unlock(&priv->mtx);\r\nreturn 0;\r\n}\r\nstatic struct at76_priv *at76_alloc_new_device(struct usb_device *udev)\r\n{\r\nstruct ieee80211_hw *hw;\r\nstruct at76_priv *priv;\r\nhw = ieee80211_alloc_hw(sizeof(struct at76_priv), &at76_ops);\r\nif (!hw) {\r\nprintk(KERN_ERR DRIVER_NAME ": could not register"\r\n" ieee80211_hw\n");\r\nreturn NULL;\r\n}\r\npriv = hw->priv;\r\npriv->hw = hw;\r\npriv->udev = udev;\r\nmutex_init(&priv->mtx);\r\nINIT_WORK(&priv->work_set_promisc, at76_work_set_promisc);\r\nINIT_WORK(&priv->work_submit_rx, at76_work_submit_rx);\r\nINIT_WORK(&priv->work_join_bssid, at76_work_join_bssid);\r\nINIT_DELAYED_WORK(&priv->dwork_hw_scan, at76_dwork_hw_scan);\r\ntasklet_init(&priv->rx_tasklet, at76_rx_tasklet, 0);\r\npriv->pm_mode = AT76_PM_OFF;\r\npriv->pm_period = 0;\r\nreturn priv;\r\n}\r\nstatic int at76_alloc_urbs(struct at76_priv *priv,\r\nstruct usb_interface *interface)\r\n{\r\nstruct usb_endpoint_descriptor *endpoint, *ep_in, *ep_out;\r\nint i;\r\nint buffer_size;\r\nstruct usb_host_interface *iface_desc;\r\nat76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __func__);\r\nat76_dbg(DBG_URB, "%s: NumEndpoints %d ", __func__,\r\ninterface->altsetting[0].desc.bNumEndpoints);\r\nep_in = NULL;\r\nep_out = NULL;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nat76_dbg(DBG_URB, "%s: %d. endpoint: addr 0x%x attr 0x%x",\r\n__func__, i, endpoint->bEndpointAddress,\r\nendpoint->bmAttributes);\r\nif (!ep_in && usb_endpoint_is_bulk_in(endpoint))\r\nep_in = endpoint;\r\nif (!ep_out && usb_endpoint_is_bulk_out(endpoint))\r\nep_out = endpoint;\r\n}\r\nif (!ep_in || !ep_out) {\r\ndev_err(&interface->dev, "bulk endpoints missing\n");\r\nreturn -ENXIO;\r\n}\r\npriv->rx_pipe = usb_rcvbulkpipe(priv->udev, ep_in->bEndpointAddress);\r\npriv->tx_pipe = usb_sndbulkpipe(priv->udev, ep_out->bEndpointAddress);\r\npriv->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\npriv->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->rx_urb || !priv->tx_urb) {\r\ndev_err(&interface->dev, "cannot allocate URB\n");\r\nreturn -ENOMEM;\r\n}\r\nbuffer_size = sizeof(struct at76_tx_buffer) + MAX_PADDING_SIZE;\r\npriv->bulk_out_buffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!priv->bulk_out_buffer)\r\nreturn -ENOMEM;\r\nat76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __func__);\r\nreturn 0;\r\n}\r\nstatic int at76_init_new_device(struct at76_priv *priv,\r\nstruct usb_interface *interface)\r\n{\r\nstruct wiphy *wiphy;\r\nsize_t len;\r\nint ret;\r\nat76_dbg(DBG_DEVSTART, "USB interface: %d endpoints",\r\ninterface->cur_altsetting->desc.bNumEndpoints);\r\nret = at76_alloc_urbs(priv, interface);\r\nif (ret < 0)\r\ngoto exit;\r\nret = at76_get_hw_config(priv);\r\nif (ret < 0) {\r\ndev_err(&interface->dev, "cannot get MAC address\n");\r\ngoto exit;\r\n}\r\npriv->domain = at76_get_reg_domain(priv->regulatory_domain);\r\npriv->channel = DEF_CHANNEL;\r\npriv->iw_mode = IW_MODE_INFRA;\r\npriv->rts_threshold = DEF_RTS_THRESHOLD;\r\npriv->frag_threshold = DEF_FRAG_THRESHOLD;\r\npriv->short_retry_limit = DEF_SHORT_RETRY_LIMIT;\r\npriv->txrate = TX_RATE_AUTO;\r\npriv->preamble_type = PREAMBLE_TYPE_LONG;\r\npriv->beacon_period = 100;\r\npriv->auth_mode = WLAN_AUTH_OPEN;\r\npriv->scan_min_time = DEF_SCAN_MIN_TIME;\r\npriv->scan_max_time = DEF_SCAN_MAX_TIME;\r\npriv->scan_mode = SCAN_TYPE_ACTIVE;\r\npriv->device_unplugged = 0;\r\nwiphy = priv->hw->wiphy;\r\npriv->hw->wiphy->max_scan_ssids = 1;\r\npriv->hw->wiphy->max_scan_ie_len = 0;\r\npriv->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\npriv->hw->wiphy->bands[NL80211_BAND_2GHZ] = &at76_supported_band;\r\nieee80211_hw_set(priv->hw, RX_INCLUDES_FCS);\r\nieee80211_hw_set(priv->hw, SIGNAL_UNSPEC);\r\npriv->hw->max_signal = 100;\r\nSET_IEEE80211_DEV(priv->hw, &interface->dev);\r\nSET_IEEE80211_PERM_ADDR(priv->hw, priv->mac_addr);\r\nlen = sizeof(wiphy->fw_version);\r\nsnprintf(wiphy->fw_version, len, "%d.%d.%d-%d",\r\npriv->fw_version.major, priv->fw_version.minor,\r\npriv->fw_version.patch, priv->fw_version.build);\r\nwiphy->hw_version = priv->board_type;\r\nret = ieee80211_register_hw(priv->hw);\r\nif (ret) {\r\nprintk(KERN_ERR "cannot register mac80211 hw (status %d)!\n",\r\nret);\r\ngoto exit;\r\n}\r\npriv->mac80211_registered = 1;\r\nwiphy_info(priv->hw->wiphy, "USB %s, MAC %pM, firmware %d.%d.%d-%d\n",\r\ndev_name(&interface->dev), priv->mac_addr,\r\npriv->fw_version.major, priv->fw_version.minor,\r\npriv->fw_version.patch, priv->fw_version.build);\r\nwiphy_info(priv->hw->wiphy, "regulatory domain 0x%02x: %s\n",\r\npriv->regulatory_domain, priv->domain->name);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void at76_delete_device(struct at76_priv *priv)\r\n{\r\nat76_dbg(DBG_PROC_ENTRY, "%s: ENTER", __func__);\r\npriv->device_unplugged = 1;\r\ntasklet_kill(&priv->rx_tasklet);\r\nif (priv->mac80211_registered)\r\nieee80211_unregister_hw(priv->hw);\r\nif (priv->tx_urb) {\r\nusb_kill_urb(priv->tx_urb);\r\nusb_free_urb(priv->tx_urb);\r\n}\r\nif (priv->rx_urb) {\r\nusb_kill_urb(priv->rx_urb);\r\nusb_free_urb(priv->rx_urb);\r\n}\r\nat76_dbg(DBG_PROC_ENTRY, "%s: unlinked urbs", __func__);\r\nkfree(priv->bulk_out_buffer);\r\ndel_timer_sync(&ledtrig_tx_timer);\r\nkfree_skb(priv->rx_skb);\r\nat76_dbg(DBG_PROC_ENTRY, "%s: before freeing priv/ieee80211_hw",\r\n__func__);\r\nieee80211_free_hw(priv->hw);\r\nat76_dbg(DBG_PROC_ENTRY, "%s: EXIT", __func__);\r\n}\r\nstatic int at76_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret;\r\nstruct at76_priv *priv;\r\nstruct fwentry *fwe;\r\nstruct usb_device *udev;\r\nint op_mode;\r\nint need_ext_fw = 0;\r\nstruct mib_fw_version *fwv = NULL;\r\nint board_type = (int)id->driver_info;\r\nudev = usb_get_dev(interface_to_usbdev(interface));\r\nfwv = kmalloc(sizeof(*fwv), GFP_KERNEL);\r\nif (!fwv) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nfwe = at76_load_firmware(udev, board_type);\r\nif (!fwe) {\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\nop_mode = at76_get_op_mode(udev);\r\nat76_dbg(DBG_DEVSTART, "opmode %d", op_mode);\r\nif (op_mode == OPMODE_HW_CONFIG_MODE) {\r\ndev_err(&interface->dev,\r\n"cannot handle a device in HW_CONFIG_MODE\n");\r\nret = -EBUSY;\r\ngoto exit;\r\n}\r\nif (op_mode != OPMODE_NORMAL_NIC_WITH_FLASH\r\n&& op_mode != OPMODE_NORMAL_NIC_WITHOUT_FLASH) {\r\ndev_printk(KERN_DEBUG, &interface->dev,\r\n"downloading internal firmware\n");\r\nret = at76_load_internal_fw(udev, fwe);\r\nif (ret < 0) {\r\ndev_err(&interface->dev,\r\n"error %d downloading internal firmware\n",\r\nret);\r\n}\r\ngoto exit;\r\n}\r\nif ((fwe->fw_version.major > 0 || fwe->fw_version.minor >= 100)\r\n|| (op_mode == OPMODE_NORMAL_NIC_WITH_FLASH)) {\r\nret = at76_get_mib(udev, MIB_FW_VERSION, fwv, sizeof(*fwv));\r\nif (ret < 0 || (fwv->major | fwv->minor) == 0)\r\nneed_ext_fw = 1;\r\n} else\r\nneed_ext_fw = 1;\r\nif (need_ext_fw) {\r\ndev_printk(KERN_DEBUG, &interface->dev,\r\n"downloading external firmware\n");\r\nret = at76_load_external_fw(udev, fwe);\r\nif (ret < 0)\r\ngoto exit;\r\nret = at76_get_mib(udev, MIB_FW_VERSION, fwv, sizeof(*fwv));\r\nif (ret < 0) {\r\ndev_err(&interface->dev,\r\n"error %d getting firmware version\n", ret);\r\ngoto exit;\r\n}\r\n}\r\npriv = at76_alloc_new_device(udev);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nusb_set_intfdata(interface, priv);\r\nmemcpy(&priv->fw_version, fwv, sizeof(struct mib_fw_version));\r\npriv->board_type = board_type;\r\nret = at76_init_new_device(priv, interface);\r\nif (ret < 0)\r\nat76_delete_device(priv);\r\nexit:\r\nkfree(fwv);\r\nif (ret < 0)\r\nusb_put_dev(udev);\r\nreturn ret;\r\n}\r\nstatic void at76_disconnect(struct usb_interface *interface)\r\n{\r\nstruct at76_priv *priv;\r\npriv = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!priv)\r\nreturn;\r\nwiphy_info(priv->hw->wiphy, "disconnecting\n");\r\nat76_delete_device(priv);\r\nusb_put_dev(priv->udev);\r\ndev_info(&interface->dev, "disconnected\n");\r\n}\r\nstatic int __init at76_mod_init(void)\r\n{\r\nint result;\r\nprintk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION " loading\n");\r\nmutex_init(&fw_mutex);\r\nresult = usb_register(&at76_driver);\r\nif (result < 0)\r\nprintk(KERN_ERR DRIVER_NAME\r\n": usb_register failed (status %d)\n", result);\r\nled_trigger_register_simple("at76_usb-tx", &ledtrig_tx);\r\nreturn result;\r\n}\r\nstatic void __exit at76_mod_exit(void)\r\n{\r\nint i;\r\nprintk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION " unloading\n");\r\nusb_deregister(&at76_driver);\r\nfor (i = 0; i < ARRAY_SIZE(firmwares); i++)\r\nrelease_firmware(firmwares[i].fw);\r\nled_trigger_unregister_simple(ledtrig_tx);\r\n}
