static u32 uartlite_inbe32(void __iomem *addr)\r\n{\r\nreturn ioread32be(addr);\r\n}\r\nstatic void uartlite_outbe32(u32 val, void __iomem *addr)\r\n{\r\niowrite32be(val, addr);\r\n}\r\nstatic u32 uartlite_inle32(void __iomem *addr)\r\n{\r\nreturn ioread32(addr);\r\n}\r\nstatic void uartlite_outle32(u32 val, void __iomem *addr)\r\n{\r\niowrite32(val, addr);\r\n}\r\nstatic inline u32 uart_in32(u32 offset, struct uart_port *port)\r\n{\r\nconst struct uartlite_reg_ops *reg_ops = port->private_data;\r\nreturn reg_ops->in(port->membase + offset);\r\n}\r\nstatic inline void uart_out32(u32 val, u32 offset, struct uart_port *port)\r\n{\r\nconst struct uartlite_reg_ops *reg_ops = port->private_data;\r\nreg_ops->out(val, port->membase + offset);\r\n}\r\nstatic int ulite_receive(struct uart_port *port, int stat)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned char ch = 0;\r\nchar flag = TTY_NORMAL;\r\nif ((stat & (ULITE_STATUS_RXVALID | ULITE_STATUS_OVERRUN\r\n| ULITE_STATUS_FRAME)) == 0)\r\nreturn 0;\r\nif (stat & ULITE_STATUS_RXVALID) {\r\nport->icount.rx++;\r\nch = uart_in32(ULITE_RX, port);\r\nif (stat & ULITE_STATUS_PARITY)\r\nport->icount.parity++;\r\n}\r\nif (stat & ULITE_STATUS_OVERRUN)\r\nport->icount.overrun++;\r\nif (stat & ULITE_STATUS_FRAME)\r\nport->icount.frame++;\r\nif (stat & port->ignore_status_mask & ULITE_STATUS_PARITY)\r\nstat &= ~ULITE_STATUS_RXVALID;\r\nstat &= port->read_status_mask;\r\nif (stat & ULITE_STATUS_PARITY)\r\nflag = TTY_PARITY;\r\nstat &= ~port->ignore_status_mask;\r\nif (stat & ULITE_STATUS_RXVALID)\r\ntty_insert_flip_char(tport, ch, flag);\r\nif (stat & ULITE_STATUS_FRAME)\r\ntty_insert_flip_char(tport, 0, TTY_FRAME);\r\nif (stat & ULITE_STATUS_OVERRUN)\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nreturn 1;\r\n}\r\nstatic int ulite_transmit(struct uart_port *port, int stat)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (stat & ULITE_STATUS_TXFULL)\r\nreturn 0;\r\nif (port->x_char) {\r\nuart_out32(port->x_char, ULITE_TX, port);\r\nport->x_char = 0;\r\nport->icount.tx++;\r\nreturn 1;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn 0;\r\nuart_out32(xmit->buf[xmit->tail], ULITE_TX, port);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);\r\nport->icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nreturn 1;\r\n}\r\nstatic irqreturn_t ulite_isr(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nint stat, busy, n = 0;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&port->lock, flags);\r\nstat = uart_in32(ULITE_STATUS, port);\r\nbusy = ulite_receive(port, stat);\r\nbusy |= ulite_transmit(port, stat);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nn++;\r\n} while (busy);\r\nif (n > 1) {\r\ntty_flip_buffer_push(&port->state->port);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nstatic unsigned int ulite_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\nret = uart_in32(ULITE_STATUS, port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret & ULITE_STATUS_TXEMPTY ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int ulite_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void ulite_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void ulite_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void ulite_start_tx(struct uart_port *port)\r\n{\r\nulite_transmit(port, uart_in32(ULITE_STATUS, port));\r\n}\r\nstatic void ulite_stop_rx(struct uart_port *port)\r\n{\r\nport->ignore_status_mask = ULITE_STATUS_RXVALID | ULITE_STATUS_PARITY\r\n| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\r\n}\r\nstatic void ulite_break_ctl(struct uart_port *port, int ctl)\r\n{\r\n}\r\nstatic int ulite_startup(struct uart_port *port)\r\n{\r\nint ret;\r\nret = request_irq(port->irq, ulite_isr, IRQF_SHARED | IRQF_TRIGGER_RISING,\r\n"uartlite", port);\r\nif (ret)\r\nreturn ret;\r\nuart_out32(ULITE_CONTROL_RST_RX | ULITE_CONTROL_RST_TX,\r\nULITE_CONTROL, port);\r\nuart_out32(ULITE_CONTROL_IE, ULITE_CONTROL, port);\r\nreturn 0;\r\n}\r\nstatic void ulite_shutdown(struct uart_port *port)\r\n{\r\nuart_out32(0, ULITE_CONTROL, port);\r\nuart_in32(ULITE_CONTROL, port);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void ulite_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = ULITE_STATUS_RXVALID | ULITE_STATUS_OVERRUN\r\n| ULITE_STATUS_TXFULL;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |=\r\nULITE_STATUS_PARITY | ULITE_STATUS_FRAME;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= ULITE_STATUS_PARITY\r\n| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |=\r\nULITE_STATUS_RXVALID | ULITE_STATUS_PARITY\r\n| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 460800);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *ulite_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_UARTLITE ? "uartlite" : NULL;\r\n}\r\nstatic void ulite_release_port(struct uart_port *port)\r\n{\r\nrelease_mem_region(port->mapbase, ULITE_REGION);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\nstatic int ulite_request_port(struct uart_port *port)\r\n{\r\nint ret;\r\npr_debug("ulite console: port=%p; port->mapbase=%llx\n",\r\nport, (unsigned long long) port->mapbase);\r\nif (!request_mem_region(port->mapbase, ULITE_REGION, "uartlite")) {\r\ndev_err(port->dev, "Memory region busy\n");\r\nreturn -EBUSY;\r\n}\r\nport->membase = ioremap(port->mapbase, ULITE_REGION);\r\nif (!port->membase) {\r\ndev_err(port->dev, "Unable to map registers\n");\r\nrelease_mem_region(port->mapbase, ULITE_REGION);\r\nreturn -EBUSY;\r\n}\r\nport->private_data = (void *)&uartlite_be;\r\nret = uart_in32(ULITE_CONTROL, port);\r\nuart_out32(ULITE_CONTROL_RST_TX, ULITE_CONTROL, port);\r\nret = uart_in32(ULITE_STATUS, port);\r\nif ((ret & ULITE_STATUS_TXEMPTY) != ULITE_STATUS_TXEMPTY)\r\nport->private_data = (void *)&uartlite_le;\r\nreturn 0;\r\n}\r\nstatic void ulite_config_port(struct uart_port *port, int flags)\r\n{\r\nif (!ulite_request_port(port))\r\nport->type = PORT_UARTLITE;\r\n}\r\nstatic int ulite_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ulite_get_poll_char(struct uart_port *port)\r\n{\r\nif (!(uart_in32(ULITE_STATUS, port) & ULITE_STATUS_RXVALID))\r\nreturn NO_POLL_CHAR;\r\nreturn uart_in32(ULITE_RX, port);\r\n}\r\nstatic void ulite_put_poll_char(struct uart_port *port, unsigned char ch)\r\n{\r\nwhile (uart_in32(ULITE_STATUS, port) & ULITE_STATUS_TXFULL)\r\ncpu_relax();\r\nuart_out32(ch, ULITE_TX, port);\r\n}\r\nstatic void ulite_console_wait_tx(struct uart_port *port)\r\n{\r\nu8 val;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nwhile (1) {\r\nval = uart_in32(ULITE_STATUS, port);\r\nif ((val & ULITE_STATUS_TXFULL) == 0)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(port->dev,\r\n"timeout waiting for TX buffer empty\n");\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic void ulite_console_putchar(struct uart_port *port, int ch)\r\n{\r\nulite_console_wait_tx(port);\r\nuart_out32(ch, ULITE_TX, port);\r\n}\r\nstatic void ulite_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &ulite_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\nif (oops_in_progress) {\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\n} else\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = uart_in32(ULITE_STATUS, port) & ULITE_STATUS_IE;\r\nuart_out32(0, ULITE_CONTROL, port);\r\nuart_console_write(port, s, count, ulite_console_putchar);\r\nulite_console_wait_tx(port);\r\nif (ier)\r\nuart_out32(ULITE_CONTROL_IE, ULITE_CONTROL, port);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int ulite_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= ULITE_NR_UARTS)\r\nreturn -EINVAL;\r\nport = &ulite_ports[co->index];\r\nif (!port->mapbase) {\r\npr_debug("console on ttyUL%i not present\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nif (!port->membase) {\r\nif (ulite_request_port(port))\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init ulite_console_init(void)\r\n{\r\nregister_console(&ulite_console);\r\nreturn 0;\r\n}\r\nstatic void early_uartlite_putc(struct uart_port *port, int c)\r\n{\r\nunsigned retries = 1000000;\r\nwhile (--retries && (readl(port->membase + 8) & (1 << 3)))\r\n;\r\nif (retries)\r\nwritel(c & 0xff, port->membase + 4);\r\n}\r\nstatic void early_uartlite_write(struct console *console,\r\nconst char *s, unsigned n)\r\n{\r\nstruct earlycon_device *device = console->data;\r\nuart_console_write(&device->port, s, n, early_uartlite_putc);\r\n}\r\nstatic int __init early_uartlite_setup(struct earlycon_device *device,\r\nconst char *options)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = early_uartlite_write;\r\nreturn 0;\r\n}\r\nstatic int ulite_assign(struct device *dev, int id, u32 base, int irq)\r\n{\r\nstruct uart_port *port;\r\nint rc;\r\nif (id < 0) {\r\nfor (id = 0; id < ULITE_NR_UARTS; id++)\r\nif (ulite_ports[id].mapbase == 0)\r\nbreak;\r\n}\r\nif (id < 0 || id >= ULITE_NR_UARTS) {\r\ndev_err(dev, "%s%i too large\n", ULITE_NAME, id);\r\nreturn -EINVAL;\r\n}\r\nif ((ulite_ports[id].mapbase) && (ulite_ports[id].mapbase != base)) {\r\ndev_err(dev, "cannot assign to %s%i; it is already in use\n",\r\nULITE_NAME, id);\r\nreturn -EBUSY;\r\n}\r\nport = &ulite_ports[id];\r\nspin_lock_init(&port->lock);\r\nport->fifosize = 16;\r\nport->regshift = 2;\r\nport->iotype = UPIO_MEM;\r\nport->iobase = 1;\r\nport->mapbase = base;\r\nport->membase = NULL;\r\nport->ops = &ulite_ops;\r\nport->irq = irq;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->dev = dev;\r\nport->type = PORT_UNKNOWN;\r\nport->line = id;\r\ndev_set_drvdata(dev, port);\r\nrc = uart_add_one_port(&ulite_uart_driver, port);\r\nif (rc) {\r\ndev_err(dev, "uart_add_one_port() failed; err=%i\n", rc);\r\nport->mapbase = 0;\r\ndev_set_drvdata(dev, NULL);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ulite_release(struct device *dev)\r\n{\r\nstruct uart_port *port = dev_get_drvdata(dev);\r\nint rc = 0;\r\nif (port) {\r\nrc = uart_remove_one_port(&ulite_uart_driver, port);\r\ndev_set_drvdata(dev, NULL);\r\nport->mapbase = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ulite_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint irq;\r\nint id = pdev->id;\r\n#ifdef CONFIG_OF\r\nconst __be32 *prop;\r\nprop = of_get_property(pdev->dev.of_node, "port-number", NULL);\r\nif (prop)\r\nid = be32_to_cpup(prop);\r\n#endif\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -ENXIO;\r\nreturn ulite_assign(&pdev->dev, id, res->start, irq);\r\n}\r\nstatic int ulite_remove(struct platform_device *pdev)\r\n{\r\nreturn ulite_release(&pdev->dev);\r\n}\r\nstatic int __init ulite_init(void)\r\n{\r\nint ret;\r\npr_debug("uartlite: calling uart_register_driver()\n");\r\nret = uart_register_driver(&ulite_uart_driver);\r\nif (ret)\r\ngoto err_uart;\r\npr_debug("uartlite: calling platform_driver_register()\n");\r\nret = platform_driver_register(&ulite_platform_driver);\r\nif (ret)\r\ngoto err_plat;\r\nreturn 0;\r\nerr_plat:\r\nuart_unregister_driver(&ulite_uart_driver);\r\nerr_uart:\r\npr_err("registering uartlite driver failed: err=%i", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit ulite_exit(void)\r\n{\r\nplatform_driver_unregister(&ulite_platform_driver);\r\nuart_unregister_driver(&ulite_uart_driver);\r\n}
