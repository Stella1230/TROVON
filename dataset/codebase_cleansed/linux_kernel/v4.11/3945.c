static int\r\nil3945_send_led_cmd(struct il_priv *il, struct il_led_cmd *led_cmd)\r\n{\r\nstruct il_host_cmd cmd = {\r\n.id = C_LEDS,\r\n.len = sizeof(struct il_led_cmd),\r\n.data = led_cmd,\r\n.flags = CMD_ASYNC,\r\n.callback = NULL,\r\n};\r\nreturn il_send_cmd(il, &cmd);\r\n}\r\nstatic inline u8\r\nil3945_get_prev_ieee_rate(u8 rate_idx)\r\n{\r\nu8 rate = il3945_rates[rate_idx].prev_ieee;\r\nif (rate == RATE_INVALID)\r\nrate = rate_idx;\r\nreturn rate;\r\n}\r\nvoid\r\nil3945_disable_events(struct il_priv *il)\r\n{\r\nint i;\r\nu32 base;\r\nu32 disable_ptr;\r\nu32 array_size;\r\nstatic const u32 evt_disable[IL_EVT_DISABLE_SIZE] = {\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n0x00000000,\r\n};\r\nbase = le32_to_cpu(il->card_alive.log_event_table_ptr);\r\nif (!il3945_hw_valid_rtc_data_addr(base)) {\r\nIL_ERR("Invalid event log pointer 0x%08X\n", base);\r\nreturn;\r\n}\r\ndisable_ptr = il_read_targ_mem(il, base + (4 * sizeof(u32)));\r\narray_size = il_read_targ_mem(il, base + (5 * sizeof(u32)));\r\nif (IL_EVT_DISABLE && array_size == IL_EVT_DISABLE_SIZE) {\r\nD_INFO("Disabling selected uCode log events at 0x%x\n",\r\ndisable_ptr);\r\nfor (i = 0; i < IL_EVT_DISABLE_SIZE; i++)\r\nil_write_targ_mem(il, disable_ptr + (i * sizeof(u32)),\r\nevt_disable[i]);\r\n} else {\r\nD_INFO("Selected uCode log events may be disabled\n");\r\nD_INFO(" by writing \"1\"s into disable bitmap\n");\r\nD_INFO(" in SRAM at 0x%x, size %d u32s\n", disable_ptr,\r\narray_size);\r\n}\r\n}\r\nstatic int\r\nil3945_hwrate_to_plcp_idx(u8 plcp)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < RATE_COUNT_3945; idx++)\r\nif (il3945_rates[idx].plcp == plcp)\r\nreturn idx;\r\nreturn -1;\r\n}\r\nstatic const char *\r\nil3945_get_tx_fail_reason(u32 status)\r\n{\r\nswitch (status & TX_STATUS_MSK) {\r\ncase TX_3945_STATUS_SUCCESS:\r\nreturn "SUCCESS";\r\nTX_STATUS_ENTRY(SHORT_LIMIT);\r\nTX_STATUS_ENTRY(LONG_LIMIT);\r\nTX_STATUS_ENTRY(FIFO_UNDERRUN);\r\nTX_STATUS_ENTRY(MGMNT_ABORT);\r\nTX_STATUS_ENTRY(NEXT_FRAG);\r\nTX_STATUS_ENTRY(LIFE_EXPIRE);\r\nTX_STATUS_ENTRY(DEST_PS);\r\nTX_STATUS_ENTRY(ABORTED);\r\nTX_STATUS_ENTRY(BT_RETRY);\r\nTX_STATUS_ENTRY(STA_INVALID);\r\nTX_STATUS_ENTRY(FRAG_DROPPED);\r\nTX_STATUS_ENTRY(TID_DISABLE);\r\nTX_STATUS_ENTRY(FRAME_FLUSHED);\r\nTX_STATUS_ENTRY(INSUFFICIENT_CF_POLL);\r\nTX_STATUS_ENTRY(TX_LOCKED);\r\nTX_STATUS_ENTRY(NO_BEACON_ON_RADAR);\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic inline const char *\r\nil3945_get_tx_fail_reason(u32 status)\r\n{\r\nreturn "";\r\n}\r\nint\r\nil3945_rs_next_rate(struct il_priv *il, int rate)\r\n{\r\nint next_rate = il3945_get_prev_ieee_rate(rate);\r\nswitch (il->band) {\r\ncase NL80211_BAND_5GHZ:\r\nif (rate == RATE_12M_IDX)\r\nnext_rate = RATE_9M_IDX;\r\nelse if (rate == RATE_6M_IDX)\r\nnext_rate = RATE_6M_IDX;\r\nbreak;\r\ncase NL80211_BAND_2GHZ:\r\nif (!(il->_3945.sta_supp_rates & IL_OFDM_RATES_MASK) &&\r\nil_is_associated(il)) {\r\nif (rate == RATE_11M_IDX)\r\nnext_rate = RATE_5M_IDX;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn next_rate;\r\n}\r\nstatic void\r\nil3945_tx_queue_reclaim(struct il_priv *il, int txq_id, int idx)\r\n{\r\nstruct il_tx_queue *txq = &il->txq[txq_id];\r\nstruct il_queue *q = &txq->q;\r\nstruct sk_buff *skb;\r\nBUG_ON(txq_id == IL39_CMD_QUEUE_NUM);\r\nfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\r\nq->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\r\nskb = txq->skbs[txq->q.read_ptr];\r\nieee80211_tx_status_irqsafe(il->hw, skb);\r\ntxq->skbs[txq->q.read_ptr] = NULL;\r\nil->ops->txq_free_tfd(il, txq);\r\n}\r\nif (il_queue_space(q) > q->low_mark && txq_id >= 0 &&\r\ntxq_id != IL39_CMD_QUEUE_NUM && il->mac80211_registered)\r\nil_wake_queue(il, txq);\r\n}\r\nstatic void\r\nil3945_hdl_tx(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nu16 sequence = le16_to_cpu(pkt->hdr.sequence);\r\nint txq_id = SEQ_TO_QUEUE(sequence);\r\nint idx = SEQ_TO_IDX(sequence);\r\nstruct il_tx_queue *txq = &il->txq[txq_id];\r\nstruct ieee80211_tx_info *info;\r\nstruct il3945_tx_resp *tx_resp = (void *)&pkt->u.raw[0];\r\nu32 status = le32_to_cpu(tx_resp->status);\r\nint rate_idx;\r\nint fail;\r\nif (idx >= txq->q.n_bd || il_queue_used(&txq->q, idx) == 0) {\r\nIL_ERR("Read idx for DMA queue txq_id (%d) idx %d "\r\n"is out of range [0-%d] %d %d\n", txq_id, idx,\r\ntxq->q.n_bd, txq->q.write_ptr, txq->q.read_ptr);\r\nreturn;\r\n}\r\nif (unlikely((status & TX_STATUS_MSK) == TX_STATUS_FAIL_PASSIVE_NO_RX) &&\r\nil->iw_mode == NL80211_IFTYPE_STATION) {\r\nil_stop_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\r\nD_INFO("Stopped queues - RX waiting on passive channel\n");\r\n}\r\ntxq->time_stamp = jiffies;\r\ninfo = IEEE80211_SKB_CB(txq->skbs[txq->q.read_ptr]);\r\nieee80211_tx_info_clear_status(info);\r\nrate_idx = il3945_hwrate_to_plcp_idx(tx_resp->rate);\r\nif (info->band == NL80211_BAND_5GHZ)\r\nrate_idx -= IL_FIRST_OFDM_RATE;\r\nfail = tx_resp->failure_frame;\r\ninfo->status.rates[0].idx = rate_idx;\r\ninfo->status.rates[0].count = fail + 1;\r\ninfo->flags |=\r\n((status & TX_STATUS_MSK) ==\r\nTX_STATUS_SUCCESS) ? IEEE80211_TX_STAT_ACK : 0;\r\nD_TX("Tx queue %d Status %s (0x%08x) plcp rate %d retries %d\n", txq_id,\r\nil3945_get_tx_fail_reason(status), status, tx_resp->rate,\r\ntx_resp->failure_frame);\r\nD_TX_REPLY("Tx queue reclaim %d\n", idx);\r\nil3945_tx_queue_reclaim(il, txq_id, idx);\r\nif (status & TX_ABORT_REQUIRED_MSK)\r\nIL_ERR("TODO: Implement Tx ABORT REQUIRED!!!\n");\r\n}\r\nstatic void\r\nil3945_accumulative_stats(struct il_priv *il, __le32 * stats)\r\n{\r\nint i;\r\n__le32 *prev_stats;\r\nu32 *accum_stats;\r\nu32 *delta, *max_delta;\r\nprev_stats = (__le32 *) &il->_3945.stats;\r\naccum_stats = (u32 *) &il->_3945.accum_stats;\r\ndelta = (u32 *) &il->_3945.delta_stats;\r\nmax_delta = (u32 *) &il->_3945.max_delta;\r\nfor (i = sizeof(__le32); i < sizeof(struct il3945_notif_stats);\r\ni +=\r\nsizeof(__le32), stats++, prev_stats++, delta++, max_delta++,\r\naccum_stats++) {\r\nif (le32_to_cpu(*stats) > le32_to_cpu(*prev_stats)) {\r\n*delta =\r\n(le32_to_cpu(*stats) - le32_to_cpu(*prev_stats));\r\n*accum_stats += *delta;\r\nif (*delta > *max_delta)\r\n*max_delta = *delta;\r\n}\r\n}\r\nil->_3945.accum_stats.general.temperature =\r\nil->_3945.stats.general.temperature;\r\nil->_3945.accum_stats.general.ttl_timestamp =\r\nil->_3945.stats.general.ttl_timestamp;\r\n}\r\nvoid\r\nil3945_hdl_stats(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nD_RX("Statistics notification received (%d vs %d).\n",\r\n(int)sizeof(struct il3945_notif_stats),\r\nle32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK);\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nil3945_accumulative_stats(il, (__le32 *) &pkt->u.raw);\r\n#endif\r\nmemcpy(&il->_3945.stats, pkt->u.raw, sizeof(il->_3945.stats));\r\n}\r\nvoid\r\nil3945_hdl_c_stats(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\n__le32 *flag = (__le32 *) &pkt->u.raw;\r\nif (le32_to_cpu(*flag) & UCODE_STATS_CLEAR_MSK) {\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nmemset(&il->_3945.accum_stats, 0,\r\nsizeof(struct il3945_notif_stats));\r\nmemset(&il->_3945.delta_stats, 0,\r\nsizeof(struct il3945_notif_stats));\r\nmemset(&il->_3945.max_delta, 0,\r\nsizeof(struct il3945_notif_stats));\r\n#endif\r\nD_RX("Statistics have been cleared\n");\r\n}\r\nil3945_hdl_stats(il, rxb);\r\n}\r\nstatic int\r\nil3945_is_network_packet(struct il_priv *il, struct ieee80211_hdr *header)\r\n{\r\nswitch (il->iw_mode) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn ether_addr_equal_64bits(header->addr3, il->bssid);\r\ncase NL80211_IFTYPE_STATION:\r\nreturn ether_addr_equal_64bits(header->addr2, il->bssid);\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic void\r\nil3945_pass_packet_to_mac80211(struct il_priv *il, struct il_rx_buf *rxb,\r\nstruct ieee80211_rx_status *stats)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)IL_RX_DATA(pkt);\r\nstruct il3945_rx_frame_hdr *rx_hdr = IL_RX_HDR(pkt);\r\nstruct il3945_rx_frame_end *rx_end = IL_RX_END(pkt);\r\nu32 len = le16_to_cpu(rx_hdr->len);\r\nstruct sk_buff *skb;\r\n__le16 fc = hdr->frame_control;\r\nu32 fraglen = PAGE_SIZE << il->hw_params.rx_page_order;\r\nif (unlikely(len + IL39_RX_FRAME_SIZE > fraglen)) {\r\nD_DROP("Corruption detected!\n");\r\nreturn;\r\n}\r\nif (unlikely(!il->is_open)) {\r\nD_DROP("Dropping packet while interface is not open.\n");\r\nreturn;\r\n}\r\nif (unlikely(test_bit(IL_STOP_REASON_PASSIVE, &il->stop_reason))) {\r\nil_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\r\nD_INFO("Woke queues - frame received on passive channel\n");\r\n}\r\nskb = dev_alloc_skb(SMALL_PACKET_SIZE);\r\nif (!skb) {\r\nIL_ERR("dev_alloc_skb failed\n");\r\nreturn;\r\n}\r\nif (!il3945_mod_params.sw_crypto)\r\nil_set_decrypted_flag(il, (struct ieee80211_hdr *)pkt,\r\nle32_to_cpu(rx_end->status), stats);\r\nif (len <= SMALL_PACKET_SIZE) {\r\nmemcpy(skb_put(skb, len), rx_hdr->payload, len);\r\n} else {\r\nskb_add_rx_frag(skb, 0, rxb->page,\r\n(void *)rx_hdr->payload - (void *)pkt, len,\r\nfraglen);\r\nil->alloc_rxb_page--;\r\nrxb->page = NULL;\r\n}\r\nil_update_stats(il, false, fc, len);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\r\nieee80211_rx(il->hw, skb);\r\n}\r\nstatic void\r\nil3945_hdl_rx(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct ieee80211_hdr *header;\r\nstruct ieee80211_rx_status rx_status = {};\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il3945_rx_frame_stats *rx_stats = IL_RX_STATS(pkt);\r\nstruct il3945_rx_frame_hdr *rx_hdr = IL_RX_HDR(pkt);\r\nstruct il3945_rx_frame_end *rx_end = IL_RX_END(pkt);\r\nu16 rx_stats_sig_avg __maybe_unused = le16_to_cpu(rx_stats->sig_avg);\r\nu16 rx_stats_noise_diff __maybe_unused =\r\nle16_to_cpu(rx_stats->noise_diff);\r\nu8 network_packet;\r\nrx_status.flag = 0;\r\nrx_status.mactime = le64_to_cpu(rx_end->timestamp);\r\nrx_status.band =\r\n(rx_hdr->\r\nphy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ? NL80211_BAND_2GHZ :\r\nNL80211_BAND_5GHZ;\r\nrx_status.freq =\r\nieee80211_channel_to_frequency(le16_to_cpu(rx_hdr->channel),\r\nrx_status.band);\r\nrx_status.rate_idx = il3945_hwrate_to_plcp_idx(rx_hdr->rate);\r\nif (rx_status.band == NL80211_BAND_5GHZ)\r\nrx_status.rate_idx -= IL_FIRST_OFDM_RATE;\r\nrx_status.antenna =\r\n(le16_to_cpu(rx_hdr->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK) >>\r\n4;\r\nif (rx_hdr->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\r\nrx_status.flag |= RX_FLAG_SHORTPRE;\r\nif ((unlikely(rx_stats->phy_count > 20))) {\r\nD_DROP("dsp size out of range [0,20]: %d\n",\r\nrx_stats->phy_count);\r\nreturn;\r\n}\r\nif (!(rx_end->status & RX_RES_STATUS_NO_CRC32_ERROR) ||\r\n!(rx_end->status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\r\nD_RX("Bad CRC or FIFO: 0x%08X.\n", rx_end->status);\r\nreturn;\r\n}\r\nrx_status.signal = rx_stats->rssi - IL39_RSSI_OFFSET;\r\nD_STATS("Rssi %d sig_avg %d noise_diff %d\n", rx_status.signal,\r\nrx_stats_sig_avg, rx_stats_noise_diff);\r\nheader = (struct ieee80211_hdr *)IL_RX_DATA(pkt);\r\nnetwork_packet = il3945_is_network_packet(il, header);\r\nD_STATS("[%c] %d RSSI:%d Signal:%u, Rate:%u\n",\r\nnetwork_packet ? '*' : ' ', le16_to_cpu(rx_hdr->channel),\r\nrx_status.signal, rx_status.signal, rx_status.rate_idx);\r\nif (network_packet) {\r\nil->_3945.last_beacon_time =\r\nle32_to_cpu(rx_end->beacon_timestamp);\r\nil->_3945.last_tsf = le64_to_cpu(rx_end->timestamp);\r\nil->_3945.last_rx_rssi = rx_status.signal;\r\n}\r\nil3945_pass_packet_to_mac80211(il, rxb, &rx_status);\r\n}\r\nint\r\nil3945_hw_txq_attach_buf_to_tfd(struct il_priv *il, struct il_tx_queue *txq,\r\ndma_addr_t addr, u16 len, u8 reset, u8 pad)\r\n{\r\nint count;\r\nstruct il_queue *q;\r\nstruct il3945_tfd *tfd, *tfd_tmp;\r\nq = &txq->q;\r\ntfd_tmp = (struct il3945_tfd *)txq->tfds;\r\ntfd = &tfd_tmp[q->write_ptr];\r\nif (reset)\r\nmemset(tfd, 0, sizeof(*tfd));\r\ncount = TFD_CTL_COUNT_GET(le32_to_cpu(tfd->control_flags));\r\nif (count >= NUM_TFD_CHUNKS || count < 0) {\r\nIL_ERR("Error can not send more than %d chunks\n",\r\nNUM_TFD_CHUNKS);\r\nreturn -EINVAL;\r\n}\r\ntfd->tbs[count].addr = cpu_to_le32(addr);\r\ntfd->tbs[count].len = cpu_to_le32(len);\r\ncount++;\r\ntfd->control_flags =\r\ncpu_to_le32(TFD_CTL_COUNT_SET(count) | TFD_CTL_PAD_SET(pad));\r\nreturn 0;\r\n}\r\nvoid\r\nil3945_hw_txq_free_tfd(struct il_priv *il, struct il_tx_queue *txq)\r\n{\r\nstruct il3945_tfd *tfd_tmp = (struct il3945_tfd *)txq->tfds;\r\nint idx = txq->q.read_ptr;\r\nstruct il3945_tfd *tfd = &tfd_tmp[idx];\r\nstruct pci_dev *dev = il->pci_dev;\r\nint i;\r\nint counter;\r\ncounter = TFD_CTL_COUNT_GET(le32_to_cpu(tfd->control_flags));\r\nif (counter > NUM_TFD_CHUNKS) {\r\nIL_ERR("Too many chunks: %i\n", counter);\r\nreturn;\r\n}\r\nif (counter)\r\npci_unmap_single(dev, dma_unmap_addr(&txq->meta[idx], mapping),\r\ndma_unmap_len(&txq->meta[idx], len),\r\nPCI_DMA_TODEVICE);\r\nfor (i = 1; i < counter; i++)\r\npci_unmap_single(dev, le32_to_cpu(tfd->tbs[i].addr),\r\nle32_to_cpu(tfd->tbs[i].len),\r\nPCI_DMA_TODEVICE);\r\nif (txq->skbs) {\r\nstruct sk_buff *skb = txq->skbs[txq->q.read_ptr];\r\nif (skb) {\r\ndev_kfree_skb_any(skb);\r\ntxq->skbs[txq->q.read_ptr] = NULL;\r\n}\r\n}\r\n}\r\nvoid\r\nil3945_hw_build_tx_cmd_rate(struct il_priv *il, struct il_device_cmd *cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_hdr *hdr, int sta_id)\r\n{\r\nu16 hw_value = ieee80211_get_tx_rate(il->hw, info)->hw_value;\r\nu16 rate_idx = min(hw_value & 0xffff, RATE_COUNT_3945 - 1);\r\nu16 rate_mask;\r\nint rate;\r\nconst u8 rts_retry_limit = 7;\r\nu8 data_retry_limit;\r\n__le32 tx_flags;\r\n__le16 fc = hdr->frame_control;\r\nstruct il3945_tx_cmd *tx_cmd = (struct il3945_tx_cmd *)cmd->cmd.payload;\r\nrate = il3945_rates[rate_idx].plcp;\r\ntx_flags = tx_cmd->tx_flags;\r\nrate_mask = RATES_MASK_3945;\r\nif (ieee80211_is_probe_resp(fc))\r\ndata_retry_limit = 3;\r\nelse\r\ndata_retry_limit = IL_DEFAULT_TX_RETRY;\r\ntx_cmd->data_retry_limit = data_retry_limit;\r\ntx_cmd->rts_retry_limit = min(data_retry_limit, rts_retry_limit);\r\ntx_cmd->rate = rate;\r\ntx_cmd->tx_flags = tx_flags;\r\ntx_cmd->supp_rates[0] =\r\n((rate_mask & IL_OFDM_RATES_MASK) >> IL_FIRST_OFDM_RATE) & 0xFF;\r\ntx_cmd->supp_rates[1] = (rate_mask & 0xF);\r\nD_RATE("Tx sta id: %d, rate: %d (plcp), flags: 0x%4X "\r\n"cck/ofdm mask: 0x%x/0x%x\n", sta_id, tx_cmd->rate,\r\nle32_to_cpu(tx_cmd->tx_flags), tx_cmd->supp_rates[1],\r\ntx_cmd->supp_rates[0]);\r\n}\r\nstatic u8\r\nil3945_sync_sta(struct il_priv *il, int sta_id, u16 tx_rate)\r\n{\r\nunsigned long flags_spin;\r\nstruct il_station_entry *station;\r\nif (sta_id == IL_INVALID_STATION)\r\nreturn IL_INVALID_STATION;\r\nspin_lock_irqsave(&il->sta_lock, flags_spin);\r\nstation = &il->stations[sta_id];\r\nstation->sta.sta.modify_mask = STA_MODIFY_TX_RATE_MSK;\r\nstation->sta.rate_n_flags = cpu_to_le16(tx_rate);\r\nstation->sta.mode = STA_CONTROL_MODIFY_MSK;\r\nil_send_add_sta(il, &station->sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&il->sta_lock, flags_spin);\r\nD_RATE("SCALE sync station %d to rate %d\n", sta_id, tx_rate);\r\nreturn sta_id;\r\n}\r\nstatic void\r\nil3945_set_pwr_vmain(struct il_priv *il)\r\n{\r\nil_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\r\nAPMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\r\n~APMG_PS_CTRL_MSK_PWR_SRC);\r\n_il_poll_bit(il, CSR_GPIO_IN, CSR_GPIO_IN_VAL_VMAIN_PWR_SRC,\r\nCSR_GPIO_IN_BIT_AUX_POWER, 5000);\r\n}\r\nstatic int\r\nil3945_rx_init(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nil_wr(il, FH39_RCSR_RBD_BASE(0), rxq->bd_dma);\r\nil_wr(il, FH39_RCSR_RPTR_ADDR(0), rxq->rb_stts_dma);\r\nil_wr(il, FH39_RCSR_WPTR(0), 0);\r\nil_wr(il, FH39_RCSR_CONFIG(0),\r\nFH39_RCSR_RX_CONFIG_REG_VAL_DMA_CHNL_EN_ENABLE |\r\nFH39_RCSR_RX_CONFIG_REG_VAL_RDRBD_EN_ENABLE |\r\nFH39_RCSR_RX_CONFIG_REG_BIT_WR_STTS_EN |\r\nFH39_RCSR_RX_CONFIG_REG_VAL_MAX_FRAG_SIZE_128 | (RX_QUEUE_SIZE_LOG\r\n<<\r\nFH39_RCSR_RX_CONFIG_REG_POS_RBDC_SIZE)\r\n| FH39_RCSR_RX_CONFIG_REG_VAL_IRQ_DEST_INT_HOST | (1 <<\r\nFH39_RCSR_RX_CONFIG_REG_POS_IRQ_RBTH)\r\n| FH39_RCSR_RX_CONFIG_REG_VAL_MSG_MODE_FH);\r\nil_rd(il, FH39_RSSR_CTRL);\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_tx_reset(struct il_priv *il)\r\n{\r\nil_wr_prph(il, ALM_SCD_MODE_REG, 0x2);\r\nil_wr_prph(il, ALM_SCD_ARASTAT_REG, 0x01);\r\nil_wr_prph(il, ALM_SCD_TXFACT_REG, 0x3f);\r\nil_wr_prph(il, ALM_SCD_SBYP_MODE_1_REG, 0x010000);\r\nil_wr_prph(il, ALM_SCD_SBYP_MODE_2_REG, 0x030002);\r\nil_wr_prph(il, ALM_SCD_TXF4MF_REG, 0x000004);\r\nil_wr_prph(il, ALM_SCD_TXF5MF_REG, 0x000005);\r\nil_wr(il, FH39_TSSR_CBB_BASE, il->_3945.shared_phys);\r\nil_wr(il, FH39_TSSR_MSG_CONFIG,\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_SNOOP_RD_TXPD_ON |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RD_TXPD_ON |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_MAX_FRAG_SIZE_128B |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_SNOOP_RD_TFD_ON |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RD_CBB_ON |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_ORDER_RSP_WAIT_TH |\r\nFH39_TSSR_TX_MSG_CONFIG_REG_VAL_RSP_WAIT_TH);\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_txq_ctx_reset(struct il_priv *il)\r\n{\r\nint rc, txq_id;\r\nil3945_hw_txq_ctx_free(il);\r\nrc = il_alloc_txq_mem(il);\r\nif (rc)\r\nreturn rc;\r\nrc = il3945_tx_reset(il);\r\nif (rc)\r\ngoto error;\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\r\nrc = il_tx_queue_init(il, txq_id);\r\nif (rc) {\r\nIL_ERR("Tx %d queue init failed\n", txq_id);\r\ngoto error;\r\n}\r\n}\r\nreturn rc;\r\nerror:\r\nil3945_hw_txq_ctx_free(il);\r\nreturn rc;\r\n}\r\nstatic int\r\nil3945_apm_init(struct il_priv *il)\r\n{\r\nint ret = il_apm_init(il);\r\nil_wr_prph(il, APMG_RTC_INT_MSK_REG, 0x0);\r\nil_wr_prph(il, APMG_RTC_INT_STT_REG, 0xFFFFFFFF);\r\nil_set_bits_prph(il, APMG_PS_CTRL_REG, APMG_PS_CTRL_VAL_RESET_REQ);\r\nudelay(5);\r\nil_clear_bits_prph(il, APMG_PS_CTRL_REG, APMG_PS_CTRL_VAL_RESET_REQ);\r\nreturn ret;\r\n}\r\nstatic void\r\nil3945_nic_config(struct il_priv *il)\r\n{\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nunsigned long flags;\r\nu8 rev_id = il->pci_dev->revision;\r\nspin_lock_irqsave(&il->lock, flags);\r\nD_INFO("HW Revision ID = 0x%X\n", rev_id);\r\nif (rev_id & PCI_CFG_REV_ID_BIT_RTP)\r\nD_INFO("RTP type\n");\r\nelse if (rev_id & PCI_CFG_REV_ID_BIT_BASIC_SKU) {\r\nD_INFO("3945 RADIO-MB type\n");\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BIT_3945_MB);\r\n} else {\r\nD_INFO("3945 RADIO-MM type\n");\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BIT_3945_MM);\r\n}\r\nif (EEPROM_SKU_CAP_OP_MODE_MRC == eeprom->sku_cap) {\r\nD_INFO("SKU OP mode is mrc\n");\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BIT_SKU_MRC);\r\n} else\r\nD_INFO("SKU OP mode is basic\n");\r\nif ((eeprom->board_revision & 0xF0) == 0xD0) {\r\nD_INFO("3945ABG revision is 0x%X\n", eeprom->board_revision);\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BIT_BOARD_TYPE);\r\n} else {\r\nD_INFO("3945ABG revision is 0x%X\n", eeprom->board_revision);\r\nil_clear_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BIT_BOARD_TYPE);\r\n}\r\nif (eeprom->almgor_m_version <= 1) {\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_A);\r\nD_INFO("Card M type A version is 0x%X\n",\r\neeprom->almgor_m_version);\r\n} else {\r\nD_INFO("Card M type B version is 0x%X\n",\r\neeprom->almgor_m_version);\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR39_HW_IF_CONFIG_REG_BITS_SILICON_TYPE_B);\r\n}\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (eeprom->sku_cap & EEPROM_SKU_CAP_SW_RF_KILL_ENABLE)\r\nD_RF_KILL("SW RF KILL supported in EEPROM.\n");\r\nif (eeprom->sku_cap & EEPROM_SKU_CAP_HW_RF_KILL_ENABLE)\r\nD_RF_KILL("HW RF KILL supported in EEPROM.\n");\r\n}\r\nint\r\nil3945_hw_nic_init(struct il_priv *il)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil3945_apm_init(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil3945_set_pwr_vmain(il);\r\nil3945_nic_config(il);\r\nif (!rxq->bd) {\r\nrc = il_rx_queue_alloc(il);\r\nif (rc) {\r\nIL_ERR("Unable to initialize Rx queue\n");\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nil3945_rx_queue_reset(il, rxq);\r\nil3945_rx_replenish(il);\r\nil3945_rx_init(il, rxq);\r\nil_wr(il, FH39_RCSR_WPTR(0), rxq->write & ~7);\r\nrc = il3945_txq_ctx_reset(il);\r\nif (rc)\r\nreturn rc;\r\nset_bit(S_INIT, &il->status);\r\nreturn 0;\r\n}\r\nvoid\r\nil3945_hw_txq_ctx_free(struct il_priv *il)\r\n{\r\nint txq_id;\r\nif (il->txq) {\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\r\nif (txq_id == IL39_CMD_QUEUE_NUM)\r\nil_cmd_queue_free(il);\r\nelse\r\nil_tx_queue_free(il, txq_id);\r\n}\r\nil_free_txq_mem(il);\r\n}\r\nvoid\r\nil3945_hw_txq_ctx_stop(struct il_priv *il)\r\n{\r\nint txq_id;\r\n_il_wr_prph(il, ALM_SCD_MODE_REG, 0);\r\n_il_wr_prph(il, ALM_SCD_TXFACT_REG, 0);\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\r\n_il_wr(il, FH39_TCSR_CONFIG(txq_id), 0x0);\r\n_il_poll_bit(il, FH39_TSSR_TX_STATUS,\r\nFH39_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(txq_id),\r\nFH39_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(txq_id),\r\n1000);\r\n}\r\n}\r\nstatic int\r\nil3945_hw_reg_adjust_power_by_temp(int new_reading, int old_reading)\r\n{\r\nreturn (new_reading - old_reading) * (-11) / 100;\r\n}\r\nstatic inline int\r\nil3945_hw_reg_temp_out_of_range(int temperature)\r\n{\r\nreturn (temperature < -260 || temperature > 25) ? 1 : 0;\r\n}\r\nint\r\nil3945_hw_get_temperature(struct il_priv *il)\r\n{\r\nreturn _il_rd(il, CSR_UCODE_DRV_GP2);\r\n}\r\nstatic int\r\nil3945_hw_reg_txpower_get_temperature(struct il_priv *il)\r\n{\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nint temperature;\r\ntemperature = il3945_hw_get_temperature(il);\r\nD_INFO("Temperature: %d\n", temperature + IL_TEMP_CONVERT);\r\nif (il3945_hw_reg_temp_out_of_range(temperature)) {\r\nIL_ERR("Error bad temperature value %d\n", temperature);\r\nif (il->last_temperature > 100)\r\ntemperature = eeprom->groups[2].temperature;\r\nelse\r\ntemperature = il->last_temperature;\r\n}\r\nreturn temperature;\r\n}\r\nstatic int\r\nil3945_is_temp_calib_needed(struct il_priv *il)\r\n{\r\nint temp_diff;\r\nil->temperature = il3945_hw_reg_txpower_get_temperature(il);\r\ntemp_diff = il->temperature - il->last_temperature;\r\nif (temp_diff < 0) {\r\nD_POWER("Getting cooler, delta %d,\n", temp_diff);\r\ntemp_diff = -temp_diff;\r\n} else if (temp_diff == 0)\r\nD_POWER("Same temp,\n");\r\nelse\r\nD_POWER("Getting warmer, delta %d,\n", temp_diff);\r\nif (temp_diff < IL_TEMPERATURE_LIMIT_TIMER) {\r\nD_POWER("Timed thermal calib not needed\n");\r\nreturn 0;\r\n}\r\nD_POWER("Timed thermal calib needed\n");\r\nil->last_temperature = il->temperature;\r\nreturn 1;\r\n}\r\nstatic inline u8\r\nil3945_hw_reg_fix_power_idx(int idx)\r\n{\r\nif (idx < 0)\r\nreturn 0;\r\nif (idx >= IL_MAX_GAIN_ENTRIES)\r\nreturn IL_MAX_GAIN_ENTRIES - 1;\r\nreturn (u8) idx;\r\n}\r\nstatic void\r\nil3945_hw_reg_set_scan_power(struct il_priv *il, u32 scan_tbl_idx, s32 rate_idx,\r\nconst s8 *clip_pwrs,\r\nstruct il_channel_info *ch_info, int band_idx)\r\n{\r\nstruct il3945_scan_power_info *scan_power_info;\r\ns8 power;\r\nu8 power_idx;\r\nscan_power_info = &ch_info->scan_pwr_info[scan_tbl_idx];\r\npower = min(ch_info->scan_power, clip_pwrs[RATE_6M_IDX_TBL]);\r\npower = min(power, il->tx_power_user_lmt);\r\nscan_power_info->requested_power = power;\r\npower_idx =\r\nch_info->power_info[rate_idx].power_table_idx - (power -\r\nch_info->\r\npower_info\r\n[RATE_6M_IDX_TBL].\r\nrequested_power) *\r\n2;\r\npower_idx = il3945_hw_reg_fix_power_idx(power_idx);\r\nscan_power_info->power_table_idx = power_idx;\r\nscan_power_info->tpc.tx_gain =\r\npower_gain_table[band_idx][power_idx].tx_gain;\r\nscan_power_info->tpc.dsp_atten =\r\npower_gain_table[band_idx][power_idx].dsp_atten;\r\n}\r\nstatic int\r\nil3945_send_tx_power(struct il_priv *il)\r\n{\r\nint rate_idx, i;\r\nconst struct il_channel_info *ch_info = NULL;\r\nstruct il3945_txpowertable_cmd txpower = {\r\n.channel = il->active.channel,\r\n};\r\nu16 chan;\r\nif (WARN_ONCE\r\n(test_bit(S_SCAN_HW, &il->status),\r\n"TX Power requested while scanning!\n"))\r\nreturn -EAGAIN;\r\nchan = le16_to_cpu(il->active.channel);\r\ntxpower.band = (il->band == NL80211_BAND_5GHZ) ? 0 : 1;\r\nch_info = il_get_channel_info(il, il->band, chan);\r\nif (!ch_info) {\r\nIL_ERR("Failed to get channel info for channel %d [%d]\n", chan,\r\nil->band);\r\nreturn -EINVAL;\r\n}\r\nif (!il_is_channel_valid(ch_info)) {\r\nD_POWER("Not calling TX_PWR_TBL_CMD on " "non-Tx channel.\n");\r\nreturn 0;\r\n}\r\nfor (rate_idx = IL_FIRST_OFDM_RATE, i = 0;\r\nrate_idx <= IL39_LAST_OFDM_RATE; rate_idx++, i++) {\r\ntxpower.power[i].tpc = ch_info->power_info[i].tpc;\r\ntxpower.power[i].rate = il3945_rates[rate_idx].plcp;\r\nD_POWER("ch %d:%d rf %d dsp %3d rate code 0x%02x\n",\r\nle16_to_cpu(txpower.channel), txpower.band,\r\ntxpower.power[i].tpc.tx_gain,\r\ntxpower.power[i].tpc.dsp_atten, txpower.power[i].rate);\r\n}\r\nfor (rate_idx = IL_FIRST_CCK_RATE; rate_idx <= IL_LAST_CCK_RATE;\r\nrate_idx++, i++) {\r\ntxpower.power[i].tpc = ch_info->power_info[i].tpc;\r\ntxpower.power[i].rate = il3945_rates[rate_idx].plcp;\r\nD_POWER("ch %d:%d rf %d dsp %3d rate code 0x%02x\n",\r\nle16_to_cpu(txpower.channel), txpower.band,\r\ntxpower.power[i].tpc.tx_gain,\r\ntxpower.power[i].tpc.dsp_atten, txpower.power[i].rate);\r\n}\r\nreturn il_send_cmd_pdu(il, C_TX_PWR_TBL,\r\nsizeof(struct il3945_txpowertable_cmd),\r\n&txpower);\r\n}\r\nstatic int\r\nil3945_hw_reg_set_new_power(struct il_priv *il, struct il_channel_info *ch_info)\r\n{\r\nstruct il3945_channel_power_info *power_info;\r\nint power_changed = 0;\r\nint i;\r\nconst s8 *clip_pwrs;\r\nint power;\r\nclip_pwrs = il->_3945.clip_groups[ch_info->group_idx].clip_powers;\r\npower_info = ch_info->power_info;\r\nfor (i = RATE_6M_IDX_TBL; i <= RATE_54M_IDX_TBL; i++, ++power_info) {\r\nint delta_idx;\r\npower = min(ch_info->curr_txpow, clip_pwrs[i]);\r\nif (power == power_info->requested_power)\r\ncontinue;\r\ndelta_idx = (power - power_info->requested_power) * 2;\r\npower_info->base_power_idx -= delta_idx;\r\npower_info->requested_power = power;\r\npower_changed = 1;\r\n}\r\nif (power_changed) {\r\npower =\r\nch_info->power_info[RATE_12M_IDX_TBL].requested_power +\r\nIL_CCK_FROM_OFDM_POWER_DIFF;\r\nfor (i = RATE_1M_IDX_TBL; i <= RATE_11M_IDX_TBL; i++) {\r\npower_info->requested_power = power;\r\npower_info->base_power_idx =\r\nch_info->power_info[RATE_12M_IDX_TBL].\r\nbase_power_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\r\n++power_info;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_hw_reg_get_ch_txpower_limit(struct il_channel_info *ch_info)\r\n{\r\ns8 max_power;\r\n#if 0\r\nif (ch_info->tgd_data.max_power != 0)\r\nmax_power =\r\nmin(ch_info->tgd_data.max_power,\r\nch_info->eeprom.max_power_avg);\r\nelse\r\n#endif\r\nmax_power = ch_info->eeprom.max_power_avg;\r\nreturn min(max_power, ch_info->max_power_avg);\r\n}\r\nstatic int\r\nil3945_hw_reg_comp_txpower_temp(struct il_priv *il)\r\n{\r\nstruct il_channel_info *ch_info = NULL;\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nint delta_idx;\r\nconst s8 *clip_pwrs;\r\nu8 a_band;\r\nu8 rate_idx;\r\nu8 scan_tbl_idx;\r\nu8 i;\r\nint ref_temp;\r\nint temperature = il->temperature;\r\nif (il->disable_tx_power_cal || test_bit(S_SCANNING, &il->status)) {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < il->channel_count; i++) {\r\nch_info = &il->channel_info[i];\r\na_band = il_is_channel_a_band(ch_info);\r\nref_temp = (s16) eeprom->groups[ch_info->group_idx].temperature;\r\ndelta_idx =\r\nil3945_hw_reg_adjust_power_by_temp(temperature, ref_temp);\r\nfor (rate_idx = 0; rate_idx < RATE_COUNT_3945; rate_idx++) {\r\nint power_idx =\r\nch_info->power_info[rate_idx].base_power_idx;\r\npower_idx += delta_idx;\r\npower_idx = il3945_hw_reg_fix_power_idx(power_idx);\r\nch_info->power_info[rate_idx].power_table_idx =\r\n(u8) power_idx;\r\nch_info->power_info[rate_idx].tpc =\r\npower_gain_table[a_band][power_idx];\r\n}\r\nclip_pwrs =\r\nil->_3945.clip_groups[ch_info->group_idx].clip_powers;\r\nfor (scan_tbl_idx = 0; scan_tbl_idx < IL_NUM_SCAN_RATES;\r\nscan_tbl_idx++) {\r\ns32 actual_idx =\r\n(scan_tbl_idx ==\r\n0) ? RATE_1M_IDX_TBL : RATE_6M_IDX_TBL;\r\nil3945_hw_reg_set_scan_power(il, scan_tbl_idx,\r\nactual_idx, clip_pwrs,\r\nch_info, a_band);\r\n}\r\n}\r\nreturn il->ops->send_tx_power(il);\r\n}\r\nint\r\nil3945_hw_reg_set_txpower(struct il_priv *il, s8 power)\r\n{\r\nstruct il_channel_info *ch_info;\r\ns8 max_power;\r\nu8 a_band;\r\nu8 i;\r\nif (il->tx_power_user_lmt == power) {\r\nD_POWER("Requested Tx power same as current " "limit: %ddBm.\n",\r\npower);\r\nreturn 0;\r\n}\r\nD_POWER("Setting upper limit clamp to %ddBm.\n", power);\r\nil->tx_power_user_lmt = power;\r\nfor (i = 0; i < il->channel_count; i++) {\r\nch_info = &il->channel_info[i];\r\na_band = il_is_channel_a_band(ch_info);\r\nmax_power = il3945_hw_reg_get_ch_txpower_limit(ch_info);\r\nmax_power = min(power, max_power);\r\nif (max_power != ch_info->curr_txpow) {\r\nch_info->curr_txpow = max_power;\r\nil3945_hw_reg_set_new_power(il, ch_info);\r\n}\r\n}\r\nil3945_is_temp_calib_needed(il);\r\nil3945_hw_reg_comp_txpower_temp(il);\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_send_rxon_assoc(struct il_priv *il)\r\n{\r\nint rc = 0;\r\nstruct il_rx_pkt *pkt;\r\nstruct il3945_rxon_assoc_cmd rxon_assoc;\r\nstruct il_host_cmd cmd = {\r\n.id = C_RXON_ASSOC,\r\n.len = sizeof(rxon_assoc),\r\n.flags = CMD_WANT_SKB,\r\n.data = &rxon_assoc,\r\n};\r\nconst struct il_rxon_cmd *rxon1 = &il->staging;\r\nconst struct il_rxon_cmd *rxon2 = &il->active;\r\nif (rxon1->flags == rxon2->flags &&\r\nrxon1->filter_flags == rxon2->filter_flags &&\r\nrxon1->cck_basic_rates == rxon2->cck_basic_rates &&\r\nrxon1->ofdm_basic_rates == rxon2->ofdm_basic_rates) {\r\nD_INFO("Using current RXON_ASSOC. Not resending.\n");\r\nreturn 0;\r\n}\r\nrxon_assoc.flags = il->staging.flags;\r\nrxon_assoc.filter_flags = il->staging.filter_flags;\r\nrxon_assoc.ofdm_basic_rates = il->staging.ofdm_basic_rates;\r\nrxon_assoc.cck_basic_rates = il->staging.cck_basic_rates;\r\nrxon_assoc.reserved = 0;\r\nrc = il_send_cmd_sync(il, &cmd);\r\nif (rc)\r\nreturn rc;\r\npkt = (struct il_rx_pkt *)cmd.reply_page;\r\nif (pkt->hdr.flags & IL_CMD_FAILED_MSK) {\r\nIL_ERR("Bad return from C_RXON_ASSOC command\n");\r\nrc = -EIO;\r\n}\r\nil_free_pages(il, cmd.reply_page);\r\nreturn rc;\r\n}\r\nint\r\nil3945_commit_rxon(struct il_priv *il)\r\n{\r\nstruct il3945_rxon_cmd *active_rxon = (void *)&il->active;\r\nstruct il3945_rxon_cmd *staging_rxon = (void *)&il->staging;\r\nint rc = 0;\r\nbool new_assoc = !!(staging_rxon->filter_flags & RXON_FILTER_ASSOC_MSK);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn -EINVAL;\r\nif (!il_is_alive(il))\r\nreturn -1;\r\nstaging_rxon->flags |= RXON_FLG_TSF2HOST_MSK;\r\nstaging_rxon->flags &= ~(RXON_FLG_DIS_DIV_MSK | RXON_FLG_ANT_SEL_MSK);\r\nstaging_rxon->flags |= il3945_get_antenna_flags(il);\r\nrc = il_check_rxon_cmd(il);\r\nif (rc) {\r\nIL_ERR("Invalid RXON configuration. Not committing.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!il_full_rxon_required(il)) {\r\nrc = il_send_rxon_assoc(il);\r\nif (rc) {\r\nIL_ERR("Error setting RXON_ASSOC "\r\n"configuration (%d).\n", rc);\r\nreturn rc;\r\n}\r\nmemcpy(active_rxon, staging_rxon, sizeof(*active_rxon));\r\nil_set_tx_power(il, il->tx_power_next, false);\r\nreturn 0;\r\n}\r\nif (il_is_associated(il) && new_assoc) {\r\nD_INFO("Toggling associated bit on current RXON\n");\r\nactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\nactive_rxon->reserved4 = 0;\r\nactive_rxon->reserved5 = 0;\r\nrc = il_send_cmd_pdu(il, C_RXON, sizeof(struct il3945_rxon_cmd),\r\n&il->active);\r\nif (rc) {\r\nactive_rxon->filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nIL_ERR("Error clearing ASSOC_MSK on current "\r\n"configuration (%d).\n", rc);\r\nreturn rc;\r\n}\r\nil_clear_ucode_stations(il);\r\nil_restore_stations(il);\r\n}\r\nD_INFO("Sending RXON\n" "* with%s RXON_FILTER_ASSOC_MSK\n"\r\n"* channel = %d\n" "* bssid = %pM\n", (new_assoc ? "" : "out"),\r\nle16_to_cpu(staging_rxon->channel), staging_rxon->bssid_addr);\r\nstaging_rxon->reserved4 = 0;\r\nstaging_rxon->reserved5 = 0;\r\nil_set_rxon_hwcrypto(il, !il3945_mod_params.sw_crypto);\r\nrc = il_send_cmd_pdu(il, C_RXON, sizeof(struct il3945_rxon_cmd),\r\nstaging_rxon);\r\nif (rc) {\r\nIL_ERR("Error setting new configuration (%d).\n", rc);\r\nreturn rc;\r\n}\r\nmemcpy(active_rxon, staging_rxon, sizeof(*active_rxon));\r\nif (!new_assoc) {\r\nil_clear_ucode_stations(il);\r\nil_restore_stations(il);\r\n}\r\nrc = il_set_tx_power(il, il->tx_power_next, true);\r\nif (rc) {\r\nIL_ERR("Error setting Tx power (%d).\n", rc);\r\nreturn rc;\r\n}\r\nrc = il3945_init_hw_rate_table(il);\r\nif (rc) {\r\nIL_ERR("Error setting HW rate table: %02X\n", rc);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nil3945_reg_txpower_periodic(struct il_priv *il)\r\n{\r\nif (!il3945_is_temp_calib_needed(il))\r\ngoto reschedule;\r\nil3945_hw_reg_comp_txpower_temp(il);\r\nreschedule:\r\nqueue_delayed_work(il->workqueue, &il->_3945.thermal_periodic,\r\nREG_RECALIB_PERIOD * HZ);\r\n}\r\nstatic void\r\nil3945_bg_reg_txpower_periodic(struct work_struct *work)\r\n{\r\nstruct il_priv *il = container_of(work, struct il_priv,\r\n_3945.thermal_periodic.work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status) || il->txq == NULL)\r\ngoto out;\r\nil3945_reg_txpower_periodic(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic u16\r\nil3945_hw_reg_get_ch_grp_idx(struct il_priv *il,\r\nconst struct il_channel_info *ch_info)\r\n{\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nstruct il3945_eeprom_txpower_group *ch_grp = &eeprom->groups[0];\r\nu8 group;\r\nu16 group_idx = 0;\r\nu8 grp_channel;\r\nif (il_is_channel_a_band(ch_info)) {\r\nfor (group = 1; group < 5; group++) {\r\ngrp_channel = ch_grp[group].group_channel;\r\nif (ch_info->channel <= grp_channel) {\r\ngroup_idx = group;\r\nbreak;\r\n}\r\n}\r\nif (group == 5)\r\ngroup_idx = 4;\r\n} else\r\ngroup_idx = 0;\r\nD_POWER("Chnl %d mapped to grp %d\n", ch_info->channel, group_idx);\r\nreturn group_idx;\r\n}\r\nstatic int\r\nil3945_hw_reg_get_matched_power_idx(struct il_priv *il, s8 requested_power,\r\ns32 setting_idx, s32 *new_idx)\r\n{\r\nconst struct il3945_eeprom_txpower_group *chnl_grp = NULL;\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\ns32 idx0, idx1;\r\ns32 power = 2 * requested_power;\r\ns32 i;\r\nconst struct il3945_eeprom_txpower_sample *samples;\r\ns32 gains0, gains1;\r\ns32 res;\r\ns32 denominator;\r\nchnl_grp = &eeprom->groups[setting_idx];\r\nsamples = chnl_grp->samples;\r\nfor (i = 0; i < 5; i++) {\r\nif (power == samples[i].power) {\r\n*new_idx = samples[i].gain_idx;\r\nreturn 0;\r\n}\r\n}\r\nif (power > samples[1].power) {\r\nidx0 = 0;\r\nidx1 = 1;\r\n} else if (power > samples[2].power) {\r\nidx0 = 1;\r\nidx1 = 2;\r\n} else if (power > samples[3].power) {\r\nidx0 = 2;\r\nidx1 = 3;\r\n} else {\r\nidx0 = 3;\r\nidx1 = 4;\r\n}\r\ndenominator = (s32) samples[idx1].power - (s32) samples[idx0].power;\r\nif (denominator == 0)\r\nreturn -EINVAL;\r\ngains0 = (s32) samples[idx0].gain_idx * (1 << 19);\r\ngains1 = (s32) samples[idx1].gain_idx * (1 << 19);\r\nres =\r\ngains0 + (gains1 - gains0) * ((s32) power -\r\n(s32) samples[idx0].power) /\r\ndenominator + (1 << 18);\r\n*new_idx = res >> 19;\r\nreturn 0;\r\n}\r\nstatic void\r\nil3945_hw_reg_init_channel_groups(struct il_priv *il)\r\n{\r\nu32 i;\r\ns32 rate_idx;\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nconst struct il3945_eeprom_txpower_group *group;\r\nD_POWER("Initializing factory calib info from EEPROM\n");\r\nfor (i = 0; i < IL_NUM_TX_CALIB_GROUPS; i++) {\r\ns8 *clip_pwrs;\r\ns8 satur_pwr;\r\ngroup = &eeprom->groups[i];\r\nif (group->saturation_power < 40) {\r\nIL_WARN("Error: saturation power is %d, "\r\n"less than minimum expected 40\n",\r\ngroup->saturation_power);\r\nreturn;\r\n}\r\nclip_pwrs = (s8 *) il->_3945.clip_groups[i].clip_powers;\r\nsatur_pwr = (s8) (group->saturation_power >> 1);\r\nfor (rate_idx = 0; rate_idx < RATE_COUNT_3945;\r\nrate_idx++, clip_pwrs++) {\r\nswitch (rate_idx) {\r\ncase RATE_36M_IDX_TBL:\r\nif (i == 0)\r\n*clip_pwrs = satur_pwr;\r\nelse\r\n*clip_pwrs = satur_pwr - 5;\r\nbreak;\r\ncase RATE_48M_IDX_TBL:\r\nif (i == 0)\r\n*clip_pwrs = satur_pwr - 7;\r\nelse\r\n*clip_pwrs = satur_pwr - 10;\r\nbreak;\r\ncase RATE_54M_IDX_TBL:\r\nif (i == 0)\r\n*clip_pwrs = satur_pwr - 9;\r\nelse\r\n*clip_pwrs = satur_pwr - 12;\r\nbreak;\r\ndefault:\r\n*clip_pwrs = satur_pwr;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nint\r\nil3945_txpower_set_from_eeprom(struct il_priv *il)\r\n{\r\nstruct il_channel_info *ch_info = NULL;\r\nstruct il3945_channel_power_info *pwr_info;\r\nstruct il3945_eeprom *eeprom = (struct il3945_eeprom *)il->eeprom;\r\nint delta_idx;\r\nu8 rate_idx;\r\nu8 scan_tbl_idx;\r\nconst s8 *clip_pwrs;\r\nu8 gain, dsp_atten;\r\ns8 power;\r\nu8 pwr_idx, base_pwr_idx, a_band;\r\nu8 i;\r\nint temperature;\r\ntemperature = il3945_hw_reg_txpower_get_temperature(il);\r\nil->last_temperature = temperature;\r\nil3945_hw_reg_init_channel_groups(il);\r\nfor (i = 0, ch_info = il->channel_info; i < il->channel_count;\r\ni++, ch_info++) {\r\na_band = il_is_channel_a_band(ch_info);\r\nif (!il_is_channel_valid(ch_info))\r\ncontinue;\r\nch_info->group_idx = il3945_hw_reg_get_ch_grp_idx(il, ch_info);\r\nclip_pwrs =\r\nil->_3945.clip_groups[ch_info->group_idx].clip_powers;\r\ndelta_idx =\r\nil3945_hw_reg_adjust_power_by_temp(temperature,\r\neeprom->groups[ch_info->\r\ngroup_idx].\r\ntemperature);\r\nD_POWER("Delta idx for channel %d: %d [%d]\n", ch_info->channel,\r\ndelta_idx, temperature + IL_TEMP_CONVERT);\r\nfor (rate_idx = 0; rate_idx < IL_OFDM_RATES; rate_idx++) {\r\ns32 uninitialized_var(power_idx);\r\nint rc;\r\ns8 pwr = min(ch_info->max_power_avg,\r\nclip_pwrs[rate_idx]);\r\npwr_info = &ch_info->power_info[rate_idx];\r\nrc = il3945_hw_reg_get_matched_power_idx(il, pwr,\r\nch_info->\r\ngroup_idx,\r\n&power_idx);\r\nif (rc) {\r\nIL_ERR("Invalid power idx\n");\r\nreturn rc;\r\n}\r\npwr_info->base_power_idx = (u8) power_idx;\r\npower_idx += delta_idx;\r\npower_idx = il3945_hw_reg_fix_power_idx(power_idx);\r\npwr_info->requested_power = pwr;\r\npwr_info->power_table_idx = (u8) power_idx;\r\npwr_info->tpc.tx_gain =\r\npower_gain_table[a_band][power_idx].tx_gain;\r\npwr_info->tpc.dsp_atten =\r\npower_gain_table[a_band][power_idx].dsp_atten;\r\n}\r\npwr_info = &ch_info->power_info[RATE_12M_IDX_TBL];\r\npower = pwr_info->requested_power + IL_CCK_FROM_OFDM_POWER_DIFF;\r\npwr_idx = pwr_info->power_table_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\r\nbase_pwr_idx =\r\npwr_info->base_power_idx + IL_CCK_FROM_OFDM_IDX_DIFF;\r\npwr_idx = il3945_hw_reg_fix_power_idx(pwr_idx);\r\ngain = power_gain_table[a_band][pwr_idx].tx_gain;\r\ndsp_atten = power_gain_table[a_band][pwr_idx].dsp_atten;\r\nfor (rate_idx = 0; rate_idx < IL_CCK_RATES; rate_idx++) {\r\npwr_info =\r\n&ch_info->power_info[rate_idx + IL_OFDM_RATES];\r\npwr_info->requested_power = power;\r\npwr_info->power_table_idx = pwr_idx;\r\npwr_info->base_power_idx = base_pwr_idx;\r\npwr_info->tpc.tx_gain = gain;\r\npwr_info->tpc.dsp_atten = dsp_atten;\r\n}\r\nfor (scan_tbl_idx = 0; scan_tbl_idx < IL_NUM_SCAN_RATES;\r\nscan_tbl_idx++) {\r\ns32 actual_idx =\r\n(scan_tbl_idx ==\r\n0) ? RATE_1M_IDX_TBL : RATE_6M_IDX_TBL;\r\nil3945_hw_reg_set_scan_power(il, scan_tbl_idx,\r\nactual_idx, clip_pwrs,\r\nch_info, a_band);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nil3945_hw_rxq_stop(struct il_priv *il)\r\n{\r\nint ret;\r\n_il_wr(il, FH39_RCSR_CONFIG(0), 0);\r\nret = _il_poll_bit(il, FH39_RSSR_STATUS,\r\nFH39_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\r\nFH39_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\r\n1000);\r\nif (ret < 0)\r\nIL_ERR("Can't stop Rx DMA.\n");\r\nreturn 0;\r\n}\r\nint\r\nil3945_hw_tx_queue_init(struct il_priv *il, struct il_tx_queue *txq)\r\n{\r\nint txq_id = txq->q.id;\r\nstruct il3945_shared *shared_data = il->_3945.shared_virt;\r\nshared_data->tx_base_ptr[txq_id] = cpu_to_le32((u32) txq->q.dma_addr);\r\nil_wr(il, FH39_CBCC_CTRL(txq_id), 0);\r\nil_wr(il, FH39_CBCC_BASE(txq_id), 0);\r\nil_wr(il, FH39_TCSR_CONFIG(txq_id),\r\nFH39_TCSR_TX_CONFIG_REG_VAL_CIRQ_RTC_NOINT |\r\nFH39_TCSR_TX_CONFIG_REG_VAL_MSG_MODE_TXF |\r\nFH39_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_IFTFD |\r\nFH39_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE_VAL |\r\nFH39_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE);\r\n_il_rd(il, FH39_TSSR_CBB_BASE);\r\nreturn 0;\r\n}\r\nstatic u16\r\nil3945_get_hcmd_size(u8 cmd_id, u16 len)\r\n{\r\nswitch (cmd_id) {\r\ncase C_RXON:\r\nreturn sizeof(struct il3945_rxon_cmd);\r\ncase C_POWER_TBL:\r\nreturn sizeof(struct il3945_powertable_cmd);\r\ndefault:\r\nreturn len;\r\n}\r\n}\r\nstatic u16\r\nil3945_build_addsta_hcmd(const struct il_addsta_cmd *cmd, u8 * data)\r\n{\r\nstruct il3945_addsta_cmd *addsta = (struct il3945_addsta_cmd *)data;\r\naddsta->mode = cmd->mode;\r\nmemcpy(&addsta->sta, &cmd->sta, sizeof(struct sta_id_modify));\r\nmemcpy(&addsta->key, &cmd->key, sizeof(struct il4965_keyinfo));\r\naddsta->station_flags = cmd->station_flags;\r\naddsta->station_flags_msk = cmd->station_flags_msk;\r\naddsta->tid_disable_tx = cpu_to_le16(0);\r\naddsta->rate_n_flags = cmd->rate_n_flags;\r\naddsta->add_immediate_ba_tid = cmd->add_immediate_ba_tid;\r\naddsta->remove_immediate_ba_tid = cmd->remove_immediate_ba_tid;\r\naddsta->add_immediate_ba_ssn = cmd->add_immediate_ba_ssn;\r\nreturn (u16) sizeof(struct il3945_addsta_cmd);\r\n}\r\nstatic int\r\nil3945_add_bssid_station(struct il_priv *il, const u8 * addr, u8 * sta_id_r)\r\n{\r\nint ret;\r\nu8 sta_id;\r\nunsigned long flags;\r\nif (sta_id_r)\r\n*sta_id_r = IL_INVALID_STATION;\r\nret = il_add_station_common(il, addr, 0, NULL, &sta_id);\r\nif (ret) {\r\nIL_ERR("Unable to add station %pM\n", addr);\r\nreturn ret;\r\n}\r\nif (sta_id_r)\r\n*sta_id_r = sta_id;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].used |= IL_STA_LOCAL;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_manage_ibss_station(struct il_priv *il, struct ieee80211_vif *vif,\r\nbool add)\r\n{\r\nstruct il_vif_priv *vif_priv = (void *)vif->drv_priv;\r\nint ret;\r\nif (add) {\r\nret =\r\nil3945_add_bssid_station(il, vif->bss_conf.bssid,\r\n&vif_priv->ibss_bssid_sta_id);\r\nif (ret)\r\nreturn ret;\r\nil3945_sync_sta(il, vif_priv->ibss_bssid_sta_id,\r\n(il->band ==\r\nNL80211_BAND_5GHZ) ? RATE_6M_PLCP :\r\nRATE_1M_PLCP);\r\nil3945_rate_scale_init(il->hw, vif_priv->ibss_bssid_sta_id);\r\nreturn 0;\r\n}\r\nreturn il_remove_station(il, vif_priv->ibss_bssid_sta_id,\r\nvif->bss_conf.bssid);\r\n}\r\nint\r\nil3945_init_hw_rate_table(struct il_priv *il)\r\n{\r\nint rc, i, idx, prev_idx;\r\nstruct il3945_rate_scaling_cmd rate_cmd = {\r\n.reserved = {0, 0, 0},\r\n};\r\nstruct il3945_rate_scaling_info *table = rate_cmd.table;\r\nfor (i = 0; i < ARRAY_SIZE(il3945_rates); i++) {\r\nidx = il3945_rates[i].table_rs_idx;\r\ntable[idx].rate_n_flags = cpu_to_le16(il3945_rates[i].plcp);\r\ntable[idx].try_cnt = il->retry_rate;\r\nprev_idx = il3945_get_prev_ieee_rate(i);\r\ntable[idx].next_rate_idx = il3945_rates[prev_idx].table_rs_idx;\r\n}\r\nswitch (il->band) {\r\ncase NL80211_BAND_5GHZ:\r\nD_RATE("Select A mode rate scale\n");\r\nfor (i = RATE_1M_IDX_TBL; i <= RATE_11M_IDX_TBL; i++)\r\ntable[i].next_rate_idx =\r\nil3945_rates[IL_FIRST_OFDM_RATE].table_rs_idx;\r\ntable[RATE_12M_IDX_TBL].next_rate_idx = RATE_9M_IDX_TBL;\r\ntable[RATE_6M_IDX_TBL].next_rate_idx =\r\nil3945_rates[IL_FIRST_OFDM_RATE].table_rs_idx;\r\nbreak;\r\ncase NL80211_BAND_2GHZ:\r\nD_RATE("Select B/G mode rate scale\n");\r\nif (!(il->_3945.sta_supp_rates & IL_OFDM_RATES_MASK) &&\r\nil_is_associated(il)) {\r\nidx = IL_FIRST_CCK_RATE;\r\nfor (i = RATE_6M_IDX_TBL; i <= RATE_54M_IDX_TBL; i++)\r\ntable[i].next_rate_idx =\r\nil3945_rates[idx].table_rs_idx;\r\nidx = RATE_11M_IDX_TBL;\r\ntable[idx].next_rate_idx = RATE_5M_IDX_TBL;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nrate_cmd.table_id = 0;\r\nrc = il_send_cmd_pdu(il, C_RATE_SCALE, sizeof(rate_cmd), &rate_cmd);\r\nif (rc)\r\nreturn rc;\r\nrate_cmd.table_id = 1;\r\nreturn il_send_cmd_pdu(il, C_RATE_SCALE, sizeof(rate_cmd), &rate_cmd);\r\n}\r\nint\r\nil3945_hw_set_hw_params(struct il_priv *il)\r\n{\r\nmemset((void *)&il->hw_params, 0, sizeof(struct il_hw_params));\r\nil->_3945.shared_virt =\r\ndma_alloc_coherent(&il->pci_dev->dev, sizeof(struct il3945_shared),\r\n&il->_3945.shared_phys, GFP_KERNEL);\r\nif (!il->_3945.shared_virt)\r\nreturn -ENOMEM;\r\nil->hw_params.bcast_id = IL3945_BROADCAST_ID;\r\nil->hw_params.max_txq_num = il->cfg->num_of_queues;\r\nil->hw_params.tfd_size = sizeof(struct il3945_tfd);\r\nil->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_3K);\r\nil->hw_params.max_rxq_size = RX_QUEUE_SIZE;\r\nil->hw_params.max_rxq_log = RX_QUEUE_SIZE_LOG;\r\nil->hw_params.max_stations = IL3945_STATION_COUNT;\r\nil->sta_key_max_num = STA_KEY_MAX_NUM;\r\nil->hw_params.rx_wrt_ptr_reg = FH39_RSCSR_CHNL0_WPTR;\r\nil->hw_params.max_beacon_itrvl = IL39_MAX_UCODE_BEACON_INTERVAL;\r\nil->hw_params.beacon_time_tsf_bits = IL3945_EXT_BEACON_TIME_POS;\r\nreturn 0;\r\n}\r\nunsigned int\r\nil3945_hw_get_beacon_cmd(struct il_priv *il, struct il3945_frame *frame,\r\nu8 rate)\r\n{\r\nstruct il3945_tx_beacon_cmd *tx_beacon_cmd;\r\nunsigned int frame_size;\r\ntx_beacon_cmd = (struct il3945_tx_beacon_cmd *)&frame->u;\r\nmemset(tx_beacon_cmd, 0, sizeof(*tx_beacon_cmd));\r\ntx_beacon_cmd->tx.sta_id = il->hw_params.bcast_id;\r\ntx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nframe_size =\r\nil3945_fill_beacon_frame(il, tx_beacon_cmd->frame,\r\nsizeof(frame->u) - sizeof(*tx_beacon_cmd));\r\nBUG_ON(frame_size > MAX_MPDU_SIZE);\r\ntx_beacon_cmd->tx.len = cpu_to_le16((u16) frame_size);\r\ntx_beacon_cmd->tx.rate = rate;\r\ntx_beacon_cmd->tx.tx_flags =\r\n(TX_CMD_FLG_SEQ_CTL_MSK | TX_CMD_FLG_TSF_MSK);\r\ntx_beacon_cmd->tx.supp_rates[0] =\r\n(IL_OFDM_BASIC_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF;\r\ntx_beacon_cmd->tx.supp_rates[1] = (IL_CCK_BASIC_RATES_MASK & 0xF);\r\nreturn sizeof(struct il3945_tx_beacon_cmd) + frame_size;\r\n}\r\nvoid\r\nil3945_hw_handler_setup(struct il_priv *il)\r\n{\r\nil->handlers[C_TX] = il3945_hdl_tx;\r\nil->handlers[N_3945_RX] = il3945_hdl_rx;\r\n}\r\nvoid\r\nil3945_hw_setup_deferred_work(struct il_priv *il)\r\n{\r\nINIT_DELAYED_WORK(&il->_3945.thermal_periodic,\r\nil3945_bg_reg_txpower_periodic);\r\n}\r\nvoid\r\nil3945_hw_cancel_deferred_work(struct il_priv *il)\r\n{\r\ncancel_delayed_work(&il->_3945.thermal_periodic);\r\n}\r\nstatic int\r\nil3945_verify_bsm(struct il_priv *il)\r\n{\r\n__le32 *image = il->ucode_boot.v_addr;\r\nu32 len = il->ucode_boot.len;\r\nu32 reg;\r\nu32 val;\r\nD_INFO("Begin verify bsm\n");\r\nval = il_rd_prph(il, BSM_WR_DWCOUNT_REG);\r\nfor (reg = BSM_SRAM_LOWER_BOUND; reg < BSM_SRAM_LOWER_BOUND + len;\r\nreg += sizeof(u32), image++) {\r\nval = il_rd_prph(il, reg);\r\nif (val != le32_to_cpu(*image)) {\r\nIL_ERR("BSM uCode verification failed at "\r\n"addr 0x%08X+%u (of %u), is 0x%x, s/b 0x%x\n",\r\nBSM_SRAM_LOWER_BOUND, reg - BSM_SRAM_LOWER_BOUND,\r\nlen, val, le32_to_cpu(*image));\r\nreturn -EIO;\r\n}\r\n}\r\nD_INFO("BSM bootstrap uCode image OK\n");\r\nreturn 0;\r\n}\r\nstatic int\r\nil3945_eeprom_acquire_semaphore(struct il_priv *il)\r\n{\r\n_il_clear_bit(il, CSR_EEPROM_GP, CSR_EEPROM_GP_IF_OWNER_MSK);\r\nreturn 0;\r\n}\r\nstatic void\r\nil3945_eeprom_release_semaphore(struct il_priv *il)\r\n{\r\nreturn;\r\n}\r\nstatic int\r\nil3945_load_bsm(struct il_priv *il)\r\n{\r\n__le32 *image = il->ucode_boot.v_addr;\r\nu32 len = il->ucode_boot.len;\r\ndma_addr_t pinst;\r\ndma_addr_t pdata;\r\nu32 inst_len;\r\nu32 data_len;\r\nint rc;\r\nint i;\r\nu32 done;\r\nu32 reg_offset;\r\nD_INFO("Begin load bsm\n");\r\nif (len > IL39_MAX_BSM_SIZE)\r\nreturn -EINVAL;\r\npinst = il->ucode_init.p_addr;\r\npdata = il->ucode_init_data.p_addr;\r\ninst_len = il->ucode_init.len;\r\ndata_len = il->ucode_init_data.len;\r\nil_wr_prph(il, BSM_DRAM_INST_PTR_REG, pinst);\r\nil_wr_prph(il, BSM_DRAM_DATA_PTR_REG, pdata);\r\nil_wr_prph(il, BSM_DRAM_INST_BYTECOUNT_REG, inst_len);\r\nil_wr_prph(il, BSM_DRAM_DATA_BYTECOUNT_REG, data_len);\r\nfor (reg_offset = BSM_SRAM_LOWER_BOUND;\r\nreg_offset < BSM_SRAM_LOWER_BOUND + len;\r\nreg_offset += sizeof(u32), image++)\r\n_il_wr_prph(il, reg_offset, le32_to_cpu(*image));\r\nrc = il3945_verify_bsm(il);\r\nif (rc)\r\nreturn rc;\r\nil_wr_prph(il, BSM_WR_MEM_SRC_REG, 0x0);\r\nil_wr_prph(il, BSM_WR_MEM_DST_REG, IL39_RTC_INST_LOWER_BOUND);\r\nil_wr_prph(il, BSM_WR_DWCOUNT_REG, len / sizeof(u32));\r\nil_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START);\r\nfor (i = 0; i < 100; i++) {\r\ndone = il_rd_prph(il, BSM_WR_CTRL_REG);\r\nif (!(done & BSM_WR_CTRL_REG_BIT_START))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i < 100)\r\nD_INFO("BSM write complete, poll %d iterations\n", i);\r\nelse {\r\nIL_ERR("BSM write did not complete!\n");\r\nreturn -EIO;\r\n}\r\nil_wr_prph(il, BSM_WR_CTRL_REG, BSM_WR_CTRL_REG_BIT_START_EN);\r\nreturn 0;\r\n}
