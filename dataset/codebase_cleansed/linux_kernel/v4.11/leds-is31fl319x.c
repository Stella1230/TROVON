static int is31fl319x_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct is31fl319x_led *led = container_of(cdev, struct is31fl319x_led,\r\ncdev);\r\nstruct is31fl319x_chip *is31 = led->chip;\r\nint chan = led - is31->leds;\r\nint ret;\r\nint i;\r\nu8 ctrl1 = 0, ctrl2 = 0;\r\ndev_dbg(&is31->client->dev, "%s %d: %d\n", __func__, chan, brightness);\r\nmutex_lock(&is31->lock);\r\nret = regmap_write(is31->regmap, IS31FL319X_PWM(chan), brightness);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < is31->cdef->num_leds; i++) {\r\nunsigned int pwm_value;\r\nbool on;\r\nret = regmap_read(is31->regmap, IS31FL319X_PWM(i), &pwm_value);\r\ndev_dbg(&is31->client->dev, "%s read %d: ret=%d: %d\n",\r\n__func__, i, ret, pwm_value);\r\non = ret >= 0 && pwm_value > LED_OFF;\r\nif (i < 3)\r\nctrl1 |= on << i;\r\nelse if (i < 6)\r\nctrl1 |= on << (i + 1);\r\nelse\r\nctrl2 |= on << (i - 6);\r\n}\r\nif (ctrl1 > 0 || ctrl2 > 0) {\r\ndev_dbg(&is31->client->dev, "power up %02x %02x\n",\r\nctrl1, ctrl2);\r\nregmap_write(is31->regmap, IS31FL319X_CTRL1, ctrl1);\r\nregmap_write(is31->regmap, IS31FL319X_CTRL2, ctrl2);\r\nregmap_write(is31->regmap, IS31FL319X_DATA_UPDATE, 0x00);\r\nret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x01);\r\n} else {\r\ndev_dbg(&is31->client->dev, "power down\n");\r\nret = regmap_write(is31->regmap, IS31FL319X_SHUTDOWN, 0x00);\r\n}\r\nout:\r\nmutex_unlock(&is31->lock);\r\nreturn ret;\r\n}\r\nstatic int is31fl319x_parse_child_dt(const struct device *dev,\r\nconst struct device_node *child,\r\nstruct is31fl319x_led *led)\r\n{\r\nstruct led_classdev *cdev = &led->cdev;\r\nint ret;\r\nif (of_property_read_string(child, "label", &cdev->name))\r\ncdev->name = child->name;\r\nret = of_property_read_string(child, "linux,default-trigger",\r\n&cdev->default_trigger);\r\nif (ret < 0 && ret != -EINVAL)\r\nreturn ret;\r\nled->max_microamp = IS31FL319X_CURRENT_DEFAULT;\r\nret = of_property_read_u32(child, "led-max-microamp",\r\n&led->max_microamp);\r\nif (!ret) {\r\nif (led->max_microamp < IS31FL319X_CURRENT_MIN)\r\nreturn -EINVAL;\r\nled->max_microamp = min(led->max_microamp,\r\nIS31FL319X_CURRENT_MAX);\r\n}\r\nreturn 0;\r\n}\r\nstatic int is31fl319x_parse_dt(struct device *dev,\r\nstruct is31fl319x_chip *is31)\r\n{\r\nstruct device_node *np = dev->of_node, *child;\r\nconst struct of_device_id *of_dev_id;\r\nint count;\r\nint ret;\r\nif (!np)\r\nreturn -ENODEV;\r\nof_dev_id = of_match_device(of_is31fl319x_match, dev);\r\nif (!of_dev_id) {\r\ndev_err(dev, "Failed to match device with supported chips\n");\r\nreturn -EINVAL;\r\n}\r\nis31->cdef = of_dev_id->data;\r\ncount = of_get_child_count(np);\r\ndev_dbg(dev, "probe %s with %d leds defined in DT\n",\r\nof_dev_id->compatible, count);\r\nif (!count || count > is31->cdef->num_leds) {\r\ndev_err(dev, "Number of leds defined must be between 1 and %u\n",\r\nis31->cdef->num_leds);\r\nreturn -ENODEV;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nstruct is31fl319x_led *led;\r\nu32 reg;\r\nret = of_property_read_u32(child, "reg", &reg);\r\nif (ret) {\r\ndev_err(dev, "Failed to read led 'reg' property\n");\r\ngoto put_child_node;\r\n}\r\nif (reg < 1 || reg > is31->cdef->num_leds) {\r\ndev_err(dev, "invalid led reg %u\n", reg);\r\nret = -EINVAL;\r\ngoto put_child_node;\r\n}\r\nled = &is31->leds[reg - 1];\r\nif (led->configured) {\r\ndev_err(dev, "led %u is already configured\n", reg);\r\nret = -EINVAL;\r\ngoto put_child_node;\r\n}\r\nret = is31fl319x_parse_child_dt(dev, child, led);\r\nif (ret) {\r\ndev_err(dev, "led %u DT parsing failed\n", reg);\r\ngoto put_child_node;\r\n}\r\nled->configured = true;\r\n}\r\nis31->audio_gain_db = 0;\r\nret = of_property_read_u32(np, "audio-gain-db", &is31->audio_gain_db);\r\nif (!ret)\r\nis31->audio_gain_db = min(is31->audio_gain_db,\r\nIS31FL319X_AUDIO_GAIN_DB_MAX);\r\nreturn 0;\r\nput_child_node:\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nstatic bool is31fl319x_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn false;\r\n}\r\nstatic bool is31fl319x_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase IS31FL319X_DATA_UPDATE:\r\ncase IS31FL319X_TIME_UPDATE:\r\ncase IS31FL319X_RESET:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic inline int is31fl319x_microamp_to_cs(struct device *dev, u32 microamp)\r\n{\r\nu32 step = microamp / IS31FL319X_CURRENT_STEP;\r\nreturn ((IS31FL319X_CONFIG2_CS_STEP_REF - step) &\r\nIS31FL319X_CONFIG2_CS_MASK) <<\r\nIS31FL319X_CONFIG2_CS_SHIFT;\r\n}\r\nstatic inline int is31fl319x_db_to_gain(u32 dezibel)\r\n{\r\nreturn dezibel / IS31FL319X_AUDIO_GAIN_DB_STEP;\r\n}\r\nstatic int is31fl319x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct is31fl319x_chip *is31;\r\nstruct device *dev = &client->dev;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(dev->parent);\r\nint err;\r\nint i = 0;\r\nu32 aggregated_led_microamp = IS31FL319X_CURRENT_MAX;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\r\nreturn -EIO;\r\nis31 = devm_kzalloc(&client->dev, sizeof(*is31), GFP_KERNEL);\r\nif (!is31)\r\nreturn -ENOMEM;\r\nmutex_init(&is31->lock);\r\nerr = is31fl319x_parse_dt(&client->dev, is31);\r\nif (err)\r\ngoto free_mutex;\r\nis31->client = client;\r\nis31->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(is31->regmap)) {\r\ndev_err(&client->dev, "failed to allocate register map\n");\r\nerr = PTR_ERR(is31->regmap);\r\ngoto free_mutex;\r\n}\r\ni2c_set_clientdata(client, is31);\r\nerr = regmap_write(is31->regmap, IS31FL319X_RESET, 0x00);\r\nif (err < 0) {\r\ndev_err(&client->dev, "no response from chip write: err = %d\n",\r\nerr);\r\nerr = -EIO;\r\ngoto free_mutex;\r\n}\r\nfor (i = 0; i < is31->cdef->num_leds; i++)\r\nif (is31->leds[i].configured &&\r\nis31->leds[i].max_microamp < aggregated_led_microamp)\r\naggregated_led_microamp = is31->leds[i].max_microamp;\r\nregmap_write(is31->regmap, IS31FL319X_CONFIG2,\r\nis31fl319x_microamp_to_cs(dev, aggregated_led_microamp) |\r\nis31fl319x_db_to_gain(is31->audio_gain_db));\r\nfor (i = 0; i < is31->cdef->num_leds; i++) {\r\nstruct is31fl319x_led *led = &is31->leds[i];\r\nif (!led->configured)\r\ncontinue;\r\nled->chip = is31;\r\nled->cdev.brightness_set_blocking = is31fl319x_brightness_set;\r\nerr = devm_led_classdev_register(&client->dev, &led->cdev);\r\nif (err < 0)\r\ngoto free_mutex;\r\n}\r\nreturn 0;\r\nfree_mutex:\r\nmutex_destroy(&is31->lock);\r\nreturn err;\r\n}\r\nstatic int is31fl319x_remove(struct i2c_client *client)\r\n{\r\nstruct is31fl319x_chip *is31 = i2c_get_clientdata(client);\r\nmutex_destroy(&is31->lock);\r\nreturn 0;\r\n}
