unsigned long long ubi_next_sqnum(struct ubi_device *ubi)\r\n{\r\nunsigned long long sqnum;\r\nspin_lock(&ubi->ltree_lock);\r\nsqnum = ubi->global_sqnum++;\r\nspin_unlock(&ubi->ltree_lock);\r\nreturn sqnum;\r\n}\r\nstatic int ubi_get_compat(const struct ubi_device *ubi, int vol_id)\r\n{\r\nif (vol_id == UBI_LAYOUT_VOLUME_ID)\r\nreturn UBI_LAYOUT_VOLUME_COMPAT;\r\nreturn 0;\r\n}\r\nvoid ubi_eba_get_ldesc(struct ubi_volume *vol, int lnum,\r\nstruct ubi_eba_leb_desc *ldesc)\r\n{\r\nldesc->lnum = lnum;\r\nldesc->pnum = vol->eba_tbl->entries[lnum].pnum;\r\n}\r\nstruct ubi_eba_table *ubi_eba_create_table(struct ubi_volume *vol,\r\nint nentries)\r\n{\r\nstruct ubi_eba_table *tbl;\r\nint err = -ENOMEM;\r\nint i;\r\ntbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\r\nif (!tbl)\r\nreturn ERR_PTR(-ENOMEM);\r\ntbl->entries = kmalloc_array(nentries, sizeof(*tbl->entries),\r\nGFP_KERNEL);\r\nif (!tbl->entries)\r\ngoto err;\r\nfor (i = 0; i < nentries; i++)\r\ntbl->entries[i].pnum = UBI_LEB_UNMAPPED;\r\nreturn tbl;\r\nerr:\r\nkfree(tbl->entries);\r\nkfree(tbl);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ubi_eba_destroy_table(struct ubi_eba_table *tbl)\r\n{\r\nif (!tbl)\r\nreturn;\r\nkfree(tbl->entries);\r\nkfree(tbl);\r\n}\r\nvoid ubi_eba_copy_table(struct ubi_volume *vol, struct ubi_eba_table *dst,\r\nint nentries)\r\n{\r\nstruct ubi_eba_table *src;\r\nint i;\r\nubi_assert(dst && vol && vol->eba_tbl);\r\nsrc = vol->eba_tbl;\r\nfor (i = 0; i < nentries; i++)\r\ndst->entries[i].pnum = src->entries[i].pnum;\r\n}\r\nvoid ubi_eba_replace_table(struct ubi_volume *vol, struct ubi_eba_table *tbl)\r\n{\r\nubi_eba_destroy_table(vol->eba_tbl);\r\nvol->eba_tbl = tbl;\r\n}\r\nstatic struct ubi_ltree_entry *ltree_lookup(struct ubi_device *ubi, int vol_id,\r\nint lnum)\r\n{\r\nstruct rb_node *p;\r\np = ubi->ltree.rb_node;\r\nwhile (p) {\r\nstruct ubi_ltree_entry *le;\r\nle = rb_entry(p, struct ubi_ltree_entry, rb);\r\nif (vol_id < le->vol_id)\r\np = p->rb_left;\r\nelse if (vol_id > le->vol_id)\r\np = p->rb_right;\r\nelse {\r\nif (lnum < le->lnum)\r\np = p->rb_left;\r\nelse if (lnum > le->lnum)\r\np = p->rb_right;\r\nelse\r\nreturn le;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ubi_ltree_entry *ltree_add_entry(struct ubi_device *ubi,\r\nint vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le, *le1, *le_free;\r\nle = kmalloc(sizeof(struct ubi_ltree_entry), GFP_NOFS);\r\nif (!le)\r\nreturn ERR_PTR(-ENOMEM);\r\nle->users = 0;\r\ninit_rwsem(&le->mutex);\r\nle->vol_id = vol_id;\r\nle->lnum = lnum;\r\nspin_lock(&ubi->ltree_lock);\r\nle1 = ltree_lookup(ubi, vol_id, lnum);\r\nif (le1) {\r\nle_free = le;\r\nle = le1;\r\n} else {\r\nstruct rb_node **p, *parent = NULL;\r\nle_free = NULL;\r\np = &ubi->ltree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nle1 = rb_entry(parent, struct ubi_ltree_entry, rb);\r\nif (vol_id < le1->vol_id)\r\np = &(*p)->rb_left;\r\nelse if (vol_id > le1->vol_id)\r\np = &(*p)->rb_right;\r\nelse {\r\nubi_assert(lnum != le1->lnum);\r\nif (lnum < le1->lnum)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\n}\r\nrb_link_node(&le->rb, parent, p);\r\nrb_insert_color(&le->rb, &ubi->ltree);\r\n}\r\nle->users += 1;\r\nspin_unlock(&ubi->ltree_lock);\r\nkfree(le_free);\r\nreturn le;\r\n}\r\nstatic int leb_read_lock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\ndown_read(&le->mutex);\r\nreturn 0;\r\n}\r\nstatic void leb_read_unlock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nspin_lock(&ubi->ltree_lock);\r\nle = ltree_lookup(ubi, vol_id, lnum);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nup_read(&le->mutex);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\n}\r\nstatic int leb_write_lock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\ndown_write(&le->mutex);\r\nreturn 0;\r\n}\r\nstatic int leb_write_trylock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nle = ltree_add_entry(ubi, vol_id, lnum);\r\nif (IS_ERR(le))\r\nreturn PTR_ERR(le);\r\nif (down_write_trylock(&le->mutex))\r\nreturn 0;\r\nspin_lock(&ubi->ltree_lock);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\nreturn 1;\r\n}\r\nstatic void leb_write_unlock(struct ubi_device *ubi, int vol_id, int lnum)\r\n{\r\nstruct ubi_ltree_entry *le;\r\nspin_lock(&ubi->ltree_lock);\r\nle = ltree_lookup(ubi, vol_id, lnum);\r\nle->users -= 1;\r\nubi_assert(le->users >= 0);\r\nup_write(&le->mutex);\r\nif (le->users == 0) {\r\nrb_erase(&le->rb, &ubi->ltree);\r\nkfree(le);\r\n}\r\nspin_unlock(&ubi->ltree_lock);\r\n}\r\nbool ubi_eba_is_mapped(struct ubi_volume *vol, int lnum)\r\n{\r\nreturn vol->eba_tbl->entries[lnum].pnum >= 0;\r\n}\r\nint ubi_eba_unmap_leb(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum)\r\n{\r\nint err, pnum, vol_id = vol->vol_id;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl->entries[lnum].pnum;\r\nif (pnum < 0)\r\ngoto out_unlock;\r\ndbg_eba("erase LEB %d:%d, PEB %d", vol_id, lnum, pnum);\r\ndown_read(&ubi->fm_eba_sem);\r\nvol->eba_tbl->entries[lnum].pnum = UBI_LEB_UNMAPPED;\r\nup_read(&ubi->fm_eba_sem);\r\nerr = ubi_wl_put_peb(ubi, vol_id, lnum, pnum, 0);\r\nout_unlock:\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nint ubi_eba_read_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\r\nvoid *buf, int offset, int len, int check)\r\n{\r\nint err, pnum, scrub = 0, vol_id = vol->vol_id;\r\nstruct ubi_vid_io_buf *vidb;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t uninitialized_var(crc);\r\nerr = leb_read_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl->entries[lnum].pnum;\r\nif (pnum < 0) {\r\ndbg_eba("read %d bytes from offset %d of LEB %d:%d (unmapped)",\r\nlen, offset, vol_id, lnum);\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nubi_assert(vol->vol_type != UBI_STATIC_VOLUME);\r\nmemset(buf, 0xFF, len);\r\nreturn 0;\r\n}\r\ndbg_eba("read %d bytes from offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\ncheck = 0;\r\nretry:\r\nif (check) {\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\r\nif (!vidb) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nerr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nif (err > 0) {\r\nif (err == UBI_IO_BAD_HDR_EBADMSG ||\r\nerr == UBI_IO_BAD_HDR) {\r\nubi_warn(ubi, "corrupted VID header at PEB %d, LEB %d:%d",\r\npnum, vol_id, lnum);\r\nerr = -EBADMSG;\r\n} else {\r\nif (ubi->fast_attach) {\r\nerr = -EBADMSG;\r\n} else {\r\nerr = -EINVAL;\r\nubi_ro_mode(ubi);\r\n}\r\n}\r\n}\r\ngoto out_free;\r\n} else if (err == UBI_IO_BITFLIPS)\r\nscrub = 1;\r\nubi_assert(lnum < be32_to_cpu(vid_hdr->used_ebs));\r\nubi_assert(len == be32_to_cpu(vid_hdr->data_size));\r\ncrc = be32_to_cpu(vid_hdr->data_crc);\r\nubi_free_vid_buf(vidb);\r\n}\r\nerr = ubi_io_read_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nif (err == UBI_IO_BITFLIPS)\r\nscrub = 1;\r\nelse if (mtd_is_eccerr(err)) {\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\ngoto out_unlock;\r\nscrub = 1;\r\nif (!check) {\r\nubi_msg(ubi, "force data checking");\r\ncheck = 1;\r\ngoto retry;\r\n}\r\n} else\r\ngoto out_unlock;\r\n}\r\nif (check) {\r\nuint32_t crc1 = crc32(UBI_CRC32_INIT, buf, len);\r\nif (crc1 != crc) {\r\nubi_warn(ubi, "CRC error: calculated %#08x, must be %#08x",\r\ncrc1, crc);\r\nerr = -EBADMSG;\r\ngoto out_unlock;\r\n}\r\n}\r\nif (scrub)\r\nerr = ubi_wl_scrub_peb(ubi, pnum);\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\nout_free:\r\nubi_free_vid_buf(vidb);\r\nout_unlock:\r\nleb_read_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nint ubi_eba_read_leb_sg(struct ubi_device *ubi, struct ubi_volume *vol,\r\nstruct ubi_sgl *sgl, int lnum, int offset, int len,\r\nint check)\r\n{\r\nint to_read;\r\nint ret;\r\nstruct scatterlist *sg;\r\nfor (;;) {\r\nubi_assert(sgl->list_pos < UBI_MAX_SG_COUNT);\r\nsg = &sgl->sg[sgl->list_pos];\r\nif (len < sg->length - sgl->page_pos)\r\nto_read = len;\r\nelse\r\nto_read = sg->length - sgl->page_pos;\r\nret = ubi_eba_read_leb(ubi, vol, lnum,\r\nsg_virt(sg) + sgl->page_pos, offset,\r\nto_read, check);\r\nif (ret < 0)\r\nreturn ret;\r\noffset += to_read;\r\nlen -= to_read;\r\nif (!len) {\r\nsgl->page_pos += to_read;\r\nif (sgl->page_pos == sg->length) {\r\nsgl->list_pos++;\r\nsgl->page_pos = 0;\r\n}\r\nbreak;\r\n}\r\nsgl->list_pos++;\r\nsgl->page_pos = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int try_recover_peb(struct ubi_volume *vol, int pnum, int lnum,\r\nconst void *buf, int offset, int len,\r\nstruct ubi_vid_io_buf *vidb, bool *retry)\r\n{\r\nstruct ubi_device *ubi = vol->ubi;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nint new_pnum, err, vol_id = vol->vol_id, data_size;\r\nuint32_t crc;\r\n*retry = false;\r\nnew_pnum = ubi_wl_get_peb(ubi);\r\nif (new_pnum < 0) {\r\nerr = new_pnum;\r\ngoto out_put;\r\n}\r\nubi_msg(ubi, "recover PEB %d, move data to PEB %d",\r\npnum, new_pnum);\r\nerr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nif (err > 0)\r\nerr = -EIO;\r\ngoto out_put;\r\n}\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nubi_assert(vid_hdr->vol_type == UBI_VID_DYNAMIC);\r\nmutex_lock(&ubi->buf_mutex);\r\nmemset(ubi->peb_buf + offset, 0xFF, len);\r\nif (offset > 0) {\r\nerr = ubi_io_read_data(ubi, ubi->peb_buf, pnum, 0, offset);\r\nif (err && err != UBI_IO_BITFLIPS)\r\ngoto out_unlock;\r\n}\r\n*retry = true;\r\nmemcpy(ubi->peb_buf + offset, buf, len);\r\ndata_size = offset + len;\r\ncrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nvid_hdr->copy_flag = 1;\r\nvid_hdr->data_size = cpu_to_be32(data_size);\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\nerr = ubi_io_write_vid_hdr(ubi, new_pnum, vidb);\r\nif (err)\r\ngoto out_unlock;\r\nerr = ubi_io_write_data(ubi, ubi->peb_buf, new_pnum, 0, data_size);\r\nout_unlock:\r\nmutex_unlock(&ubi->buf_mutex);\r\nif (!err)\r\nvol->eba_tbl->entries[lnum].pnum = new_pnum;\r\nout_put:\r\nup_read(&ubi->fm_eba_sem);\r\nif (!err) {\r\nubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\r\nubi_msg(ubi, "data was successfully recovered");\r\n} else if (new_pnum >= 0) {\r\nubi_wl_put_peb(ubi, vol_id, lnum, new_pnum, 1);\r\nubi_warn(ubi, "failed to write to PEB %d", new_pnum);\r\n}\r\nreturn err;\r\n}\r\nstatic int recover_peb(struct ubi_device *ubi, int pnum, int vol_id, int lnum,\r\nconst void *buf, int offset, int len)\r\n{\r\nint err, idx = vol_id2idx(ubi, vol_id), tries;\r\nstruct ubi_volume *vol = ubi->volumes[idx];\r\nstruct ubi_vid_io_buf *vidb;\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\r\nif (!vidb)\r\nreturn -ENOMEM;\r\nfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\r\nbool retry;\r\nerr = try_recover_peb(vol, pnum, lnum, buf, offset, len, vidb,\r\n&retry);\r\nif (!err || !retry)\r\nbreak;\r\nubi_msg(ubi, "try again");\r\n}\r\nubi_free_vid_buf(vidb);\r\nreturn err;\r\n}\r\nstatic int try_write_vid_and_data(struct ubi_volume *vol, int lnum,\r\nstruct ubi_vid_io_buf *vidb, const void *buf,\r\nint offset, int len)\r\n{\r\nstruct ubi_device *ubi = vol->ubi;\r\nint pnum, opnum, err, vol_id = vol->vol_id;\r\npnum = ubi_wl_get_peb(ubi);\r\nif (pnum < 0) {\r\nerr = pnum;\r\ngoto out_put;\r\n}\r\nopnum = vol->eba_tbl->entries[lnum].pnum;\r\ndbg_eba("write VID hdr and %d bytes at offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nerr = ubi_io_write_vid_hdr(ubi, pnum, vidb);\r\nif (err) {\r\nubi_warn(ubi, "failed to write VID header to LEB %d:%d, PEB %d",\r\nvol_id, lnum, pnum);\r\ngoto out_put;\r\n}\r\nif (len) {\r\nerr = ubi_io_write_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nubi_warn(ubi,\r\n"failed to write %d bytes at offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\ngoto out_put;\r\n}\r\n}\r\nvol->eba_tbl->entries[lnum].pnum = pnum;\r\nout_put:\r\nup_read(&ubi->fm_eba_sem);\r\nif (err && pnum >= 0)\r\nerr = ubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\r\nelse if (!err && opnum >= 0)\r\nerr = ubi_wl_put_peb(ubi, vol_id, lnum, opnum, 0);\r\nreturn err;\r\n}\r\nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\r\nconst void *buf, int offset, int len)\r\n{\r\nint err, pnum, tries, vol_id = vol->vol_id;\r\nstruct ubi_vid_io_buf *vidb;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\nreturn err;\r\npnum = vol->eba_tbl->entries[lnum].pnum;\r\nif (pnum >= 0) {\r\ndbg_eba("write %d bytes at offset %d of LEB %d:%d, PEB %d",\r\nlen, offset, vol_id, lnum, pnum);\r\nerr = ubi_io_write_data(ubi, buf, pnum, offset, len);\r\nif (err) {\r\nubi_warn(ubi, "failed to write data to PEB %d", pnum);\r\nif (err == -EIO && ubi->bad_allowed)\r\nerr = recover_peb(ubi, pnum, vol_id, lnum, buf,\r\noffset, len);\r\n}\r\ngoto out;\r\n}\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\r\nif (!vidb) {\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn -ENOMEM;\r\n}\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nvid_hdr->vol_type = UBI_VID_DYNAMIC;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\nfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\r\nerr = try_write_vid_and_data(vol, lnum, vidb, buf, offset, len);\r\nif (err != -EIO || !ubi->bad_allowed)\r\nbreak;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nubi_msg(ubi, "try another PEB");\r\n}\r\nubi_free_vid_buf(vidb);\r\nout:\r\nif (err)\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nint ubi_eba_write_leb_st(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum, const void *buf, int len, int used_ebs)\r\n{\r\nint err, tries, data_size = len, vol_id = vol->vol_id;\r\nstruct ubi_vid_io_buf *vidb;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t crc;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nif (lnum == used_ebs - 1)\r\nlen = ALIGN(data_size, ubi->min_io_size);\r\nelse\r\nubi_assert(!(len & (ubi->min_io_size - 1)));\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\r\nif (!vidb)\r\nreturn -ENOMEM;\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\ngoto out;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\ncrc = crc32(UBI_CRC32_INIT, buf, data_size);\r\nvid_hdr->vol_type = UBI_VID_STATIC;\r\nvid_hdr->data_size = cpu_to_be32(data_size);\r\nvid_hdr->used_ebs = cpu_to_be32(used_ebs);\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\nubi_assert(vol->eba_tbl->entries[lnum].pnum < 0);\r\nfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\r\nerr = try_write_vid_and_data(vol, lnum, vidb, buf, 0, len);\r\nif (err != -EIO || !ubi->bad_allowed)\r\nbreak;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nubi_msg(ubi, "try another PEB");\r\n}\r\nif (err)\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nout:\r\nubi_free_vid_buf(vidb);\r\nreturn err;\r\n}\r\nint ubi_eba_atomic_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\r\nint lnum, const void *buf, int len)\r\n{\r\nint err, tries, vol_id = vol->vol_id;\r\nstruct ubi_vid_io_buf *vidb;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nuint32_t crc;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nif (len == 0) {\r\nerr = ubi_eba_unmap_leb(ubi, vol, lnum);\r\nif (err)\r\nreturn err;\r\nreturn ubi_eba_write_leb(ubi, vol, lnum, NULL, 0, 0);\r\n}\r\nvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\r\nif (!vidb)\r\nreturn -ENOMEM;\r\nvid_hdr = ubi_get_vid_hdr(vidb);\r\nmutex_lock(&ubi->alc_mutex);\r\nerr = leb_write_lock(ubi, vol_id, lnum);\r\nif (err)\r\ngoto out_mutex;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nvid_hdr->vol_id = cpu_to_be32(vol_id);\r\nvid_hdr->lnum = cpu_to_be32(lnum);\r\nvid_hdr->compat = ubi_get_compat(ubi, vol_id);\r\nvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\r\ncrc = crc32(UBI_CRC32_INIT, buf, len);\r\nvid_hdr->vol_type = UBI_VID_DYNAMIC;\r\nvid_hdr->data_size = cpu_to_be32(len);\r\nvid_hdr->copy_flag = 1;\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\ndbg_eba("change LEB %d:%d", vol_id, lnum);\r\nfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\r\nerr = try_write_vid_and_data(vol, lnum, vidb, buf, 0, len);\r\nif (err != -EIO || !ubi->bad_allowed)\r\nbreak;\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nubi_msg(ubi, "try another PEB");\r\n}\r\nif (err)\r\nubi_ro_mode(ubi);\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nout_mutex:\r\nmutex_unlock(&ubi->alc_mutex);\r\nubi_free_vid_buf(vidb);\r\nreturn err;\r\n}\r\nstatic int is_error_sane(int err)\r\n{\r\nif (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_HDR ||\r\nerr == UBI_IO_BAD_HDR_EBADMSG || err == -ETIMEDOUT)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,\r\nstruct ubi_vid_io_buf *vidb)\r\n{\r\nint err, vol_id, lnum, data_size, aldata_size, idx;\r\nstruct ubi_vid_hdr *vid_hdr = ubi_get_vid_hdr(vidb);\r\nstruct ubi_volume *vol;\r\nuint32_t crc;\r\nubi_assert(rwsem_is_locked(&ubi->fm_eba_sem));\r\nvol_id = be32_to_cpu(vid_hdr->vol_id);\r\nlnum = be32_to_cpu(vid_hdr->lnum);\r\ndbg_wl("copy LEB %d:%d, PEB %d to PEB %d", vol_id, lnum, from, to);\r\nif (vid_hdr->vol_type == UBI_VID_STATIC) {\r\ndata_size = be32_to_cpu(vid_hdr->data_size);\r\naldata_size = ALIGN(data_size, ubi->min_io_size);\r\n} else\r\ndata_size = aldata_size =\r\nubi->leb_size - be32_to_cpu(vid_hdr->data_pad);\r\nidx = vol_id2idx(ubi, vol_id);\r\nspin_lock(&ubi->volumes_lock);\r\nvol = ubi->volumes[idx];\r\nspin_unlock(&ubi->volumes_lock);\r\nif (!vol) {\r\ndbg_wl("volume %d is being removed, cancel", vol_id);\r\nreturn MOVE_CANCEL_RACE;\r\n}\r\nerr = leb_write_trylock(ubi, vol_id, lnum);\r\nif (err) {\r\ndbg_wl("contention on LEB %d:%d, cancel", vol_id, lnum);\r\nreturn MOVE_RETRY;\r\n}\r\nif (vol->eba_tbl->entries[lnum].pnum != from) {\r\ndbg_wl("LEB %d:%d is no longer mapped to PEB %d, mapped to PEB %d, cancel",\r\nvol_id, lnum, from, vol->eba_tbl->entries[lnum].pnum);\r\nerr = MOVE_CANCEL_RACE;\r\ngoto out_unlock_leb;\r\n}\r\nmutex_lock(&ubi->buf_mutex);\r\ndbg_wl("read %d bytes of data", aldata_size);\r\nerr = ubi_io_read_data(ubi, ubi->peb_buf, from, 0, aldata_size);\r\nif (err && err != UBI_IO_BITFLIPS) {\r\nubi_warn(ubi, "error %d while reading data from PEB %d",\r\nerr, from);\r\nerr = MOVE_SOURCE_RD_ERR;\r\ngoto out_unlock_buf;\r\n}\r\nif (vid_hdr->vol_type == UBI_VID_DYNAMIC)\r\naldata_size = data_size =\r\nubi_calc_data_len(ubi, ubi->peb_buf, data_size);\r\ncond_resched();\r\ncrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\r\ncond_resched();\r\nif (data_size > 0) {\r\nvid_hdr->copy_flag = 1;\r\nvid_hdr->data_size = cpu_to_be32(data_size);\r\nvid_hdr->data_crc = cpu_to_be32(crc);\r\n}\r\nvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\r\nerr = ubi_io_write_vid_hdr(ubi, to, vidb);\r\nif (err) {\r\nif (err == -EIO)\r\nerr = MOVE_TARGET_WR_ERR;\r\ngoto out_unlock_buf;\r\n}\r\ncond_resched();\r\nerr = ubi_io_read_vid_hdr(ubi, to, vidb, 1);\r\nif (err) {\r\nif (err != UBI_IO_BITFLIPS) {\r\nubi_warn(ubi, "error %d while reading VID header back from PEB %d",\r\nerr, to);\r\nif (is_error_sane(err))\r\nerr = MOVE_TARGET_RD_ERR;\r\n} else\r\nerr = MOVE_TARGET_BITFLIPS;\r\ngoto out_unlock_buf;\r\n}\r\nif (data_size > 0) {\r\nerr = ubi_io_write_data(ubi, ubi->peb_buf, to, 0, aldata_size);\r\nif (err) {\r\nif (err == -EIO)\r\nerr = MOVE_TARGET_WR_ERR;\r\ngoto out_unlock_buf;\r\n}\r\ncond_resched();\r\n}\r\nubi_assert(vol->eba_tbl->entries[lnum].pnum == from);\r\nvol->eba_tbl->entries[lnum].pnum = to;\r\nout_unlock_buf:\r\nmutex_unlock(&ubi->buf_mutex);\r\nout_unlock_leb:\r\nleb_write_unlock(ubi, vol_id, lnum);\r\nreturn err;\r\n}\r\nstatic void print_rsvd_warning(struct ubi_device *ubi,\r\nstruct ubi_attach_info *ai)\r\n{\r\nif (ai->max_sqnum > (1 << 18)) {\r\nint min = ubi->beb_rsvd_level / 10;\r\nif (!min)\r\nmin = 1;\r\nif (ubi->beb_rsvd_pebs > min)\r\nreturn;\r\n}\r\nubi_warn(ubi, "cannot reserve enough PEBs for bad PEB handling, reserved %d, need %d",\r\nubi->beb_rsvd_pebs, ubi->beb_rsvd_level);\r\nif (ubi->corr_peb_count)\r\nubi_warn(ubi, "%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\n}\r\nint self_check_eba(struct ubi_device *ubi, struct ubi_attach_info *ai_fastmap,\r\nstruct ubi_attach_info *ai_scan)\r\n{\r\nint i, j, num_volumes, ret = 0;\r\nint **scan_eba, **fm_eba;\r\nstruct ubi_ainf_volume *av;\r\nstruct ubi_volume *vol;\r\nstruct ubi_ainf_peb *aeb;\r\nstruct rb_node *rb;\r\nnum_volumes = ubi->vtbl_slots + UBI_INT_VOL_COUNT;\r\nscan_eba = kmalloc(sizeof(*scan_eba) * num_volumes, GFP_KERNEL);\r\nif (!scan_eba)\r\nreturn -ENOMEM;\r\nfm_eba = kmalloc(sizeof(*fm_eba) * num_volumes, GFP_KERNEL);\r\nif (!fm_eba) {\r\nkfree(scan_eba);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < num_volumes; i++) {\r\nvol = ubi->volumes[i];\r\nif (!vol)\r\ncontinue;\r\nscan_eba[i] = kmalloc(vol->reserved_pebs * sizeof(**scan_eba),\r\nGFP_KERNEL);\r\nif (!scan_eba[i]) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfm_eba[i] = kmalloc(vol->reserved_pebs * sizeof(**fm_eba),\r\nGFP_KERNEL);\r\nif (!fm_eba[i]) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nfor (j = 0; j < vol->reserved_pebs; j++)\r\nscan_eba[i][j] = fm_eba[i][j] = UBI_LEB_UNMAPPED;\r\nav = ubi_find_av(ai_scan, idx2vol_id(ubi, i));\r\nif (!av)\r\ncontinue;\r\nubi_rb_for_each_entry(rb, aeb, &av->root, u.rb)\r\nscan_eba[i][aeb->lnum] = aeb->pnum;\r\nav = ubi_find_av(ai_fastmap, idx2vol_id(ubi, i));\r\nif (!av)\r\ncontinue;\r\nubi_rb_for_each_entry(rb, aeb, &av->root, u.rb)\r\nfm_eba[i][aeb->lnum] = aeb->pnum;\r\nfor (j = 0; j < vol->reserved_pebs; j++) {\r\nif (scan_eba[i][j] != fm_eba[i][j]) {\r\nif (scan_eba[i][j] == UBI_LEB_UNMAPPED ||\r\nfm_eba[i][j] == UBI_LEB_UNMAPPED)\r\ncontinue;\r\nubi_err(ubi, "LEB:%i:%i is PEB:%i instead of %i!",\r\nvol->vol_id, j, fm_eba[i][j],\r\nscan_eba[i][j]);\r\nubi_assert(0);\r\n}\r\n}\r\n}\r\nout_free:\r\nfor (i = 0; i < num_volumes; i++) {\r\nif (!ubi->volumes[i])\r\ncontinue;\r\nkfree(scan_eba[i]);\r\nkfree(fm_eba[i]);\r\n}\r\nkfree(scan_eba);\r\nkfree(fm_eba);\r\nreturn ret;\r\n}\r\nint ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)\r\n{\r\nint i, err, num_volumes;\r\nstruct ubi_ainf_volume *av;\r\nstruct ubi_volume *vol;\r\nstruct ubi_ainf_peb *aeb;\r\nstruct rb_node *rb;\r\ndbg_eba("initialize EBA sub-system");\r\nspin_lock_init(&ubi->ltree_lock);\r\nmutex_init(&ubi->alc_mutex);\r\nubi->ltree = RB_ROOT;\r\nubi->global_sqnum = ai->max_sqnum + 1;\r\nnum_volumes = ubi->vtbl_slots + UBI_INT_VOL_COUNT;\r\nfor (i = 0; i < num_volumes; i++) {\r\nstruct ubi_eba_table *tbl;\r\nvol = ubi->volumes[i];\r\nif (!vol)\r\ncontinue;\r\ncond_resched();\r\ntbl = ubi_eba_create_table(vol, vol->reserved_pebs);\r\nif (IS_ERR(tbl)) {\r\nerr = PTR_ERR(tbl);\r\ngoto out_free;\r\n}\r\nubi_eba_replace_table(vol, tbl);\r\nav = ubi_find_av(ai, idx2vol_id(ubi, i));\r\nif (!av)\r\ncontinue;\r\nubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\r\nif (aeb->lnum >= vol->reserved_pebs) {\r\nubi_move_aeb_to_list(av, aeb, &ai->erase);\r\n} else {\r\nstruct ubi_eba_entry *entry;\r\nentry = &vol->eba_tbl->entries[aeb->lnum];\r\nentry->pnum = aeb->pnum;\r\n}\r\n}\r\n}\r\nif (ubi->avail_pebs < EBA_RESERVED_PEBS) {\r\nubi_err(ubi, "no enough physical eraseblocks (%d, need %d)",\r\nubi->avail_pebs, EBA_RESERVED_PEBS);\r\nif (ubi->corr_peb_count)\r\nubi_err(ubi, "%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\nerr = -ENOSPC;\r\ngoto out_free;\r\n}\r\nubi->avail_pebs -= EBA_RESERVED_PEBS;\r\nubi->rsvd_pebs += EBA_RESERVED_PEBS;\r\nif (ubi->bad_allowed) {\r\nubi_calculate_reserved(ubi);\r\nif (ubi->avail_pebs < ubi->beb_rsvd_level) {\r\nubi->beb_rsvd_pebs = ubi->avail_pebs;\r\nprint_rsvd_warning(ubi, ai);\r\n} else\r\nubi->beb_rsvd_pebs = ubi->beb_rsvd_level;\r\nubi->avail_pebs -= ubi->beb_rsvd_pebs;\r\nubi->rsvd_pebs += ubi->beb_rsvd_pebs;\r\n}\r\ndbg_eba("EBA sub-system is initialized");\r\nreturn 0;\r\nout_free:\r\nfor (i = 0; i < num_volumes; i++) {\r\nif (!ubi->volumes[i])\r\ncontinue;\r\nubi_eba_replace_table(ubi->volumes[i], NULL);\r\n}\r\nreturn err;\r\n}
