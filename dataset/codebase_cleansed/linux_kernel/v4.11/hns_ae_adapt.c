static struct hns_mac_cb *hns_get_mac_cb(struct hnae_handle *handle)\r\n{\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nreturn vf_cb->mac_cb;\r\n}\r\nstatic struct dsaf_device *hns_ae_get_dsaf_dev(struct hnae_ae_dev *dev)\r\n{\r\nreturn container_of(dev, struct dsaf_device, ae_dev);\r\n}\r\nstatic struct hns_ppe_cb *hns_get_ppe_cb(struct hnae_handle *handle)\r\n{\r\nint ppe_index;\r\nstruct ppe_common_cb *ppe_comm;\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nppe_comm = vf_cb->dsaf_dev->ppe_common[0];\r\nppe_index = vf_cb->port_index;\r\nreturn &ppe_comm->ppe_cb[ppe_index];\r\n}\r\nstatic int hns_ae_get_q_num_per_vf(\r\nstruct dsaf_device *dsaf_dev, int port)\r\n{\r\nreturn dsaf_dev->rcb_common[0]->max_q_per_vf;\r\n}\r\nstatic int hns_ae_get_vf_num_per_port(\r\nstruct dsaf_device *dsaf_dev, int port)\r\n{\r\nreturn dsaf_dev->rcb_common[0]->max_vfn;\r\n}\r\nstatic struct ring_pair_cb *hns_ae_get_base_ring_pair(\r\nstruct dsaf_device *dsaf_dev, int port)\r\n{\r\nstruct rcb_common_cb *rcb_comm = dsaf_dev->rcb_common[0];\r\nint q_num = rcb_comm->max_q_per_vf;\r\nint vf_num = rcb_comm->max_vfn;\r\nreturn &rcb_comm->ring_pair_cb[port * q_num * vf_num];\r\n}\r\nstatic struct ring_pair_cb *hns_ae_get_ring_pair(struct hnae_queue *q)\r\n{\r\nreturn container_of(q, struct ring_pair_cb, q);\r\n}\r\nstruct hnae_handle *hns_ae_get_handle(struct hnae_ae_dev *dev,\r\nu32 port_id)\r\n{\r\nint vfnum_per_port;\r\nint qnum_per_vf;\r\nint i;\r\nstruct dsaf_device *dsaf_dev;\r\nstruct hnae_handle *ae_handle;\r\nstruct ring_pair_cb *ring_pair_cb;\r\nstruct hnae_vf_cb *vf_cb;\r\ndsaf_dev = hns_ae_get_dsaf_dev(dev);\r\nring_pair_cb = hns_ae_get_base_ring_pair(dsaf_dev, port_id);\r\nvfnum_per_port = hns_ae_get_vf_num_per_port(dsaf_dev, port_id);\r\nqnum_per_vf = hns_ae_get_q_num_per_vf(dsaf_dev, port_id);\r\nvf_cb = kzalloc(sizeof(*vf_cb) +\r\nqnum_per_vf * sizeof(struct hnae_queue *), GFP_KERNEL);\r\nif (unlikely(!vf_cb)) {\r\ndev_err(dsaf_dev->dev, "malloc vf_cb fail!\n");\r\nae_handle = ERR_PTR(-ENOMEM);\r\ngoto handle_err;\r\n}\r\nae_handle = &vf_cb->ae_handle;\r\nae_handle->owner_dev = dsaf_dev->dev;\r\nae_handle->dev = dev;\r\nae_handle->q_num = qnum_per_vf;\r\nfor (ae_handle->vf_id = 0;\r\nae_handle->vf_id < vfnum_per_port; ae_handle->vf_id++) {\r\nif (!ring_pair_cb->used_by_vf)\r\nbreak;\r\nring_pair_cb += qnum_per_vf;\r\n}\r\nif (ae_handle->vf_id >= vfnum_per_port) {\r\ndev_err(dsaf_dev->dev, "malloc queue fail!\n");\r\nae_handle = ERR_PTR(-EINVAL);\r\ngoto vf_id_err;\r\n}\r\nae_handle->qs = (struct hnae_queue **)(&ae_handle->qs + 1);\r\nfor (i = 0; i < qnum_per_vf; i++) {\r\nae_handle->qs[i] = &ring_pair_cb->q;\r\nae_handle->qs[i]->rx_ring.q = ae_handle->qs[i];\r\nae_handle->qs[i]->tx_ring.q = ae_handle->qs[i];\r\nring_pair_cb->used_by_vf = 1;\r\nring_pair_cb++;\r\n}\r\nvf_cb->dsaf_dev = dsaf_dev;\r\nvf_cb->port_index = port_id;\r\nvf_cb->mac_cb = dsaf_dev->mac_cb[port_id];\r\nae_handle->phy_if = vf_cb->mac_cb->phy_if;\r\nae_handle->phy_dev = vf_cb->mac_cb->phy_dev;\r\nae_handle->if_support = vf_cb->mac_cb->if_support;\r\nae_handle->port_type = vf_cb->mac_cb->mac_type;\r\nae_handle->media_type = vf_cb->mac_cb->media_type;\r\nae_handle->dport_id = port_id;\r\nreturn ae_handle;\r\nvf_id_err:\r\nkfree(vf_cb);\r\nhandle_err:\r\nreturn ae_handle;\r\n}\r\nstatic void hns_ae_put_handle(struct hnae_handle *handle)\r\n{\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nint i;\r\nvf_cb->mac_cb = NULL;\r\nkfree(vf_cb);\r\nfor (i = 0; i < handle->q_num; i++)\r\nhns_ae_get_ring_pair(handle->qs[i])->used_by_vf = 0;\r\n}\r\nstatic void hns_ae_ring_enable_all(struct hnae_handle *handle, int val)\r\n{\r\nint q_num = handle->q_num;\r\nint i;\r\nfor (i = 0; i < q_num; i++)\r\nhns_rcb_ring_enable_hw(handle->qs[i], val);\r\n}\r\nstatic void hns_ae_init_queue(struct hnae_queue *q)\r\n{\r\nstruct ring_pair_cb *ring =\r\ncontainer_of(q, struct ring_pair_cb, q);\r\nhns_rcb_init_hw(ring);\r\n}\r\nstatic void hns_ae_fini_queue(struct hnae_queue *q)\r\n{\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(q->handle);\r\nif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nhns_rcb_reset_ring_hw(q);\r\n}\r\nstatic int hns_ae_set_mac_address(struct hnae_handle *handle, void *p)\r\n{\r\nint ret;\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nif (!p || !is_valid_ether_addr((const u8 *)p)) {\r\ndev_err(handle->owner_dev, "is not valid ether addr !\n");\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nret = hns_mac_change_vf_addr(mac_cb, handle->vf_id, p);\r\nif (ret != 0) {\r\ndev_err(handle->owner_dev,\r\n"set_mac_address fail, ret=%d!\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hns_ae_add_uc_address(struct hnae_handle *handle,\r\nconst unsigned char *addr)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nif (mac_cb->mac_type != HNAE_PORT_SERVICE)\r\nreturn -ENOSPC;\r\nreturn hns_mac_add_uc_addr(mac_cb, handle->vf_id, addr);\r\n}\r\nstatic int hns_ae_rm_uc_address(struct hnae_handle *handle,\r\nconst unsigned char *addr)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nif (mac_cb->mac_type != HNAE_PORT_SERVICE)\r\nreturn -ENOSPC;\r\nreturn hns_mac_rm_uc_addr(mac_cb, handle->vf_id, addr);\r\n}\r\nstatic int hns_ae_set_multicast_one(struct hnae_handle *handle, void *addr)\r\n{\r\nint ret;\r\nchar *mac_addr = (char *)addr;\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nu8 port_num;\r\nassert(mac_cb);\r\nif (mac_cb->mac_type != HNAE_PORT_SERVICE)\r\nreturn 0;\r\nret = hns_mac_set_multi(mac_cb, mac_cb->mac_id, mac_addr, true);\r\nif (ret) {\r\ndev_err(handle->owner_dev,\r\n"mac add mul_mac:%pM port%d fail, ret = %#x!\n",\r\nmac_addr, mac_cb->mac_id, ret);\r\nreturn ret;\r\n}\r\nret = hns_mac_get_inner_port_num(mac_cb, handle->vf_id, &port_num);\r\nif (ret)\r\nreturn ret;\r\nret = hns_mac_set_multi(mac_cb, port_num, mac_addr, true);\r\nif (ret)\r\ndev_err(handle->owner_dev,\r\n"mac add mul_mac:%pM port%d fail, ret = %#x!\n",\r\nmac_addr, DSAF_BASE_INNER_PORT_NUM, ret);\r\nreturn ret;\r\n}\r\nstatic int hns_ae_clr_multicast(struct hnae_handle *handle)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nif (mac_cb->mac_type != HNAE_PORT_SERVICE)\r\nreturn 0;\r\nreturn hns_mac_clr_multicast(mac_cb, handle->vf_id);\r\n}\r\nstatic int hns_ae_set_mtu(struct hnae_handle *handle, int new_mtu)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nreturn hns_mac_set_mtu(mac_cb, new_mtu);\r\n}\r\nstatic void hns_ae_set_tso_stats(struct hnae_handle *handle, int enable)\r\n{\r\nstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\r\nhns_ppe_set_tso_enable(ppe_cb, enable);\r\n}\r\nstatic int hns_ae_start(struct hnae_handle *handle)\r\n{\r\nint ret;\r\nint k;\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nret = hns_mac_vm_config_bc_en(mac_cb, 0, true);\r\nif (ret)\r\nreturn ret;\r\nfor (k = 0; k < handle->q_num; k++) {\r\nif (AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver))\r\nhns_rcb_int_clr_hw(handle->qs[k],\r\nRCB_INT_FLAG_TX | RCB_INT_FLAG_RX);\r\nelse\r\nhns_rcbv2_int_clr_hw(handle->qs[k],\r\nRCB_INT_FLAG_TX | RCB_INT_FLAG_RX);\r\n}\r\nhns_ae_ring_enable_all(handle, 1);\r\nmsleep(100);\r\nhns_mac_start(mac_cb);\r\nreturn 0;\r\n}\r\nvoid hns_ae_stop(struct hnae_handle *handle)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nhns_rcb_wait_fbd_clean(handle->qs, handle->q_num, RCB_INT_FLAG_TX);\r\nmsleep(20);\r\nhns_mac_stop(mac_cb);\r\nusleep_range(10000, 20000);\r\nhns_ae_ring_enable_all(handle, 0);\r\n(void)hns_mac_vm_config_bc_en(mac_cb, 0, false);\r\n}\r\nstatic void hns_ae_reset(struct hnae_handle *handle)\r\n{\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nif (vf_cb->mac_cb->mac_type == HNAE_PORT_DEBUG) {\r\nhns_mac_reset(vf_cb->mac_cb);\r\nhns_ppe_reset_common(vf_cb->dsaf_dev, 0);\r\n}\r\n}\r\nvoid hns_ae_toggle_ring_irq(struct hnae_ring *ring, u32 mask)\r\n{\r\nu32 flag;\r\nif (is_tx_ring(ring))\r\nflag = RCB_INT_FLAG_TX;\r\nelse\r\nflag = RCB_INT_FLAG_RX;\r\nhns_rcb_int_ctrl_hw(ring->q, flag, mask);\r\n}\r\nstatic void hns_aev2_toggle_ring_irq(struct hnae_ring *ring, u32 mask)\r\n{\r\nu32 flag;\r\nif (is_tx_ring(ring))\r\nflag = RCB_INT_FLAG_TX;\r\nelse\r\nflag = RCB_INT_FLAG_RX;\r\nhns_rcbv2_int_ctrl_hw(ring->q, flag, mask);\r\n}\r\nstatic int hns_ae_get_link_status(struct hnae_handle *handle)\r\n{\r\nu32 link_status;\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nhns_mac_get_link_status(mac_cb, &link_status);\r\nreturn !!link_status;\r\n}\r\nstatic int hns_ae_get_mac_info(struct hnae_handle *handle,\r\nu8 *auto_neg, u16 *speed, u8 *duplex)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nreturn hns_mac_get_port_info(mac_cb, auto_neg, speed, duplex);\r\n}\r\nstatic void hns_ae_adjust_link(struct hnae_handle *handle, int speed,\r\nint duplex)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nhns_mac_adjust_link(mac_cb, speed, duplex);\r\n}\r\nstatic void hns_ae_get_ring_bdnum_limit(struct hnae_queue *queue,\r\nu32 *uplimit)\r\n{\r\n*uplimit = HNS_RCB_RING_MAX_PENDING_BD;\r\n}\r\nstatic void hns_ae_get_pauseparam(struct hnae_handle *handle,\r\nu32 *auto_neg, u32 *rx_en, u32 *tx_en)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nhns_mac_get_autoneg(mac_cb, auto_neg);\r\nhns_mac_get_pauseparam(mac_cb, rx_en, tx_en);\r\nif (handle->port_type == HNAE_PORT_SERVICE)\r\nhns_dsaf_get_rx_mac_pause_en(dsaf_dev, mac_cb->mac_id, rx_en);\r\n}\r\nstatic int hns_ae_set_autoneg(struct hnae_handle *handle, u8 enable)\r\n{\r\nassert(handle);\r\nreturn hns_mac_set_autoneg(hns_get_mac_cb(handle), enable);\r\n}\r\nstatic void hns_ae_set_promisc_mode(struct hnae_handle *handle, u32 en)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nhns_dsaf_set_promisc_mode(hns_ae_get_dsaf_dev(handle->dev), en);\r\nhns_mac_set_promisc(mac_cb, (u8)!!en);\r\n}\r\nstatic int hns_ae_get_autoneg(struct hnae_handle *handle)\r\n{\r\nu32 auto_neg;\r\nassert(handle);\r\nhns_mac_get_autoneg(hns_get_mac_cb(handle), &auto_neg);\r\nreturn auto_neg;\r\n}\r\nstatic int hns_ae_set_pauseparam(struct hnae_handle *handle,\r\nu32 autoneg, u32 rx_en, u32 tx_en)\r\n{\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nint ret;\r\nret = hns_mac_set_autoneg(mac_cb, autoneg);\r\nif (ret)\r\nreturn ret;\r\nif (handle->port_type == HNAE_PORT_SERVICE) {\r\nret = hns_dsaf_set_rx_mac_pause_en(dsaf_dev,\r\nmac_cb->mac_id, rx_en);\r\nif (ret)\r\nreturn ret;\r\nrx_en = 0;\r\n}\r\nreturn hns_mac_set_pauseparam(mac_cb, rx_en, tx_en);\r\n}\r\nstatic void hns_ae_get_coalesce_usecs(struct hnae_handle *handle,\r\nu32 *tx_usecs, u32 *rx_usecs)\r\n{\r\nstruct ring_pair_cb *ring_pair =\r\ncontainer_of(handle->qs[0], struct ring_pair_cb, q);\r\n*tx_usecs = hns_rcb_get_coalesce_usecs(ring_pair->rcb_common,\r\nring_pair->port_id_in_comm);\r\n*rx_usecs = hns_rcb_get_coalesce_usecs(ring_pair->rcb_common,\r\nring_pair->port_id_in_comm);\r\n}\r\nstatic void hns_ae_get_rx_max_coalesced_frames(struct hnae_handle *handle,\r\nu32 *tx_frames, u32 *rx_frames)\r\n{\r\nstruct ring_pair_cb *ring_pair =\r\ncontainer_of(handle->qs[0], struct ring_pair_cb, q);\r\n*tx_frames = hns_rcb_get_coalesced_frames(ring_pair->rcb_common,\r\nring_pair->port_id_in_comm);\r\n*rx_frames = hns_rcb_get_coalesced_frames(ring_pair->rcb_common,\r\nring_pair->port_id_in_comm);\r\n}\r\nstatic int hns_ae_set_coalesce_usecs(struct hnae_handle *handle,\r\nu32 timeout)\r\n{\r\nstruct ring_pair_cb *ring_pair =\r\ncontainer_of(handle->qs[0], struct ring_pair_cb, q);\r\nreturn hns_rcb_set_coalesce_usecs(\r\nring_pair->rcb_common, ring_pair->port_id_in_comm, timeout);\r\n}\r\nstatic int hns_ae_set_coalesce_frames(struct hnae_handle *handle,\r\nu32 coalesce_frames)\r\n{\r\nstruct ring_pair_cb *ring_pair =\r\ncontainer_of(handle->qs[0], struct ring_pair_cb, q);\r\nreturn hns_rcb_set_coalesced_frames(\r\nring_pair->rcb_common,\r\nring_pair->port_id_in_comm, coalesce_frames);\r\n}\r\nstatic void hns_ae_get_coalesce_range(struct hnae_handle *handle,\r\nu32 *tx_frames_low, u32 *rx_frames_low,\r\nu32 *tx_frames_high, u32 *rx_frames_high,\r\nu32 *tx_usecs_low, u32 *rx_usecs_low,\r\nu32 *tx_usecs_high, u32 *rx_usecs_high)\r\n{\r\nstruct dsaf_device *dsaf_dev;\r\ndsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\r\n*tx_frames_low = HNS_RCB_MIN_COALESCED_FRAMES;\r\n*rx_frames_low = HNS_RCB_MIN_COALESCED_FRAMES;\r\n*tx_frames_high =\r\n(dsaf_dev->desc_num - 1 > HNS_RCB_MAX_COALESCED_FRAMES) ?\r\nHNS_RCB_MAX_COALESCED_FRAMES : dsaf_dev->desc_num - 1;\r\n*rx_frames_high =\r\n(dsaf_dev->desc_num - 1 > HNS_RCB_MAX_COALESCED_FRAMES) ?\r\nHNS_RCB_MAX_COALESCED_FRAMES : dsaf_dev->desc_num - 1;\r\n*tx_usecs_low = 0;\r\n*rx_usecs_low = 0;\r\n*tx_usecs_high = HNS_RCB_MAX_COALESCED_USECS;\r\n*rx_usecs_high = HNS_RCB_MAX_COALESCED_USECS;\r\n}\r\nvoid hns_ae_update_stats(struct hnae_handle *handle,\r\nstruct net_device_stats *net_stats)\r\n{\r\nint port;\r\nint idx;\r\nstruct dsaf_device *dsaf_dev;\r\nstruct hns_mac_cb *mac_cb;\r\nstruct hns_ppe_cb *ppe_cb;\r\nstruct hnae_queue *queue;\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nu64 tx_bytes = 0, rx_bytes = 0, tx_packets = 0, rx_packets = 0;\r\nu64 rx_errors = 0, tx_errors = 0, tx_dropped = 0;\r\nu64 rx_missed_errors = 0;\r\ndsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\r\nif (!dsaf_dev)\r\nreturn;\r\nport = vf_cb->port_index;\r\nppe_cb = hns_get_ppe_cb(handle);\r\nmac_cb = hns_get_mac_cb(handle);\r\nfor (idx = 0; idx < handle->q_num; idx++) {\r\nqueue = handle->qs[idx];\r\nhns_rcb_update_stats(queue);\r\ntx_bytes += queue->tx_ring.stats.tx_bytes;\r\ntx_packets += queue->tx_ring.stats.tx_pkts;\r\nrx_bytes += queue->rx_ring.stats.rx_bytes;\r\nrx_packets += queue->rx_ring.stats.rx_pkts;\r\nrx_errors += queue->rx_ring.stats.err_pkt_len\r\n+ queue->rx_ring.stats.l2_err\r\n+ queue->rx_ring.stats.l3l4_csum_err;\r\n}\r\nhns_ppe_update_stats(ppe_cb);\r\nrx_missed_errors = ppe_cb->hw_stats.rx_drop_no_buf;\r\ntx_errors += ppe_cb->hw_stats.tx_err_checksum\r\n+ ppe_cb->hw_stats.tx_err_fifo_empty;\r\nif (mac_cb->mac_type == HNAE_PORT_SERVICE) {\r\nhns_dsaf_update_stats(dsaf_dev, port);\r\nrx_missed_errors += dsaf_dev->hw_stats[port].bp_drop;\r\nrx_missed_errors += dsaf_dev->hw_stats[port].pad_drop;\r\nrx_missed_errors += dsaf_dev->hw_stats[port].crc_false;\r\nport = port + DSAF_PPE_INODE_BASE;\r\nhns_dsaf_update_stats(dsaf_dev, port);\r\ntx_dropped += dsaf_dev->hw_stats[port].bp_drop;\r\ntx_dropped += dsaf_dev->hw_stats[port].pad_drop;\r\ntx_dropped += dsaf_dev->hw_stats[port].crc_false;\r\ntx_dropped += dsaf_dev->hw_stats[port].rslt_drop;\r\ntx_dropped += dsaf_dev->hw_stats[port].vlan_drop;\r\ntx_dropped += dsaf_dev->hw_stats[port].stp_drop;\r\n}\r\nhns_mac_update_stats(mac_cb);\r\nrx_errors += mac_cb->hw_stats.rx_fifo_overrun_err;\r\ntx_errors += mac_cb->hw_stats.tx_bad_pkts\r\n+ mac_cb->hw_stats.tx_fragment_err\r\n+ mac_cb->hw_stats.tx_jabber_err\r\n+ mac_cb->hw_stats.tx_underrun_err\r\n+ mac_cb->hw_stats.tx_crc_err;\r\nnet_stats->tx_bytes = tx_bytes;\r\nnet_stats->tx_packets = tx_packets;\r\nnet_stats->rx_bytes = rx_bytes;\r\nnet_stats->rx_dropped = 0;\r\nnet_stats->rx_packets = rx_packets;\r\nnet_stats->rx_errors = rx_errors;\r\nnet_stats->tx_errors = tx_errors;\r\nnet_stats->tx_dropped = tx_dropped;\r\nnet_stats->rx_missed_errors = rx_missed_errors;\r\nnet_stats->rx_crc_errors = mac_cb->hw_stats.rx_fcs_err;\r\nnet_stats->rx_frame_errors = mac_cb->hw_stats.rx_align_err;\r\nnet_stats->rx_fifo_errors = mac_cb->hw_stats.rx_fifo_overrun_err;\r\nnet_stats->rx_length_errors = mac_cb->hw_stats.rx_len_err;\r\nnet_stats->multicast = mac_cb->hw_stats.rx_mc_pkts;\r\n}\r\nvoid hns_ae_get_stats(struct hnae_handle *handle, u64 *data)\r\n{\r\nint idx;\r\nstruct hns_mac_cb *mac_cb;\r\nstruct hns_ppe_cb *ppe_cb;\r\nu64 *p = data;\r\nstruct hnae_vf_cb *vf_cb;\r\nif (!handle || !data) {\r\npr_err("hns_ae_get_stats NULL handle or data pointer!\n");\r\nreturn;\r\n}\r\nvf_cb = hns_ae_get_vf_cb(handle);\r\nmac_cb = hns_get_mac_cb(handle);\r\nppe_cb = hns_get_ppe_cb(handle);\r\nfor (idx = 0; idx < handle->q_num; idx++) {\r\nhns_rcb_get_stats(handle->qs[idx], p);\r\np += hns_rcb_get_ring_sset_count((int)ETH_SS_STATS);\r\n}\r\nhns_ppe_get_stats(ppe_cb, p);\r\np += hns_ppe_get_sset_count((int)ETH_SS_STATS);\r\nhns_mac_get_stats(mac_cb, p);\r\np += hns_mac_get_sset_count(mac_cb, (int)ETH_SS_STATS);\r\nif (mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nhns_dsaf_get_stats(vf_cb->dsaf_dev, p, vf_cb->port_index);\r\n}\r\nvoid hns_ae_get_strings(struct hnae_handle *handle,\r\nu32 stringset, u8 *data)\r\n{\r\nint port;\r\nint idx;\r\nstruct hns_mac_cb *mac_cb;\r\nstruct hns_ppe_cb *ppe_cb;\r\nstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\r\nu8 *p = data;\r\nstruct hnae_vf_cb *vf_cb;\r\nassert(handle);\r\nvf_cb = hns_ae_get_vf_cb(handle);\r\nport = vf_cb->port_index;\r\nmac_cb = hns_get_mac_cb(handle);\r\nppe_cb = hns_get_ppe_cb(handle);\r\nfor (idx = 0; idx < handle->q_num; idx++) {\r\nhns_rcb_get_strings(stringset, p, idx);\r\np += ETH_GSTRING_LEN * hns_rcb_get_ring_sset_count(stringset);\r\n}\r\nhns_ppe_get_strings(ppe_cb, stringset, p);\r\np += ETH_GSTRING_LEN * hns_ppe_get_sset_count(stringset);\r\nhns_mac_get_strings(mac_cb, stringset, p);\r\np += ETH_GSTRING_LEN * hns_mac_get_sset_count(mac_cb, stringset);\r\nif (mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nhns_dsaf_get_strings(stringset, p, port, dsaf_dev);\r\n}\r\nint hns_ae_get_sset_count(struct hnae_handle *handle, int stringset)\r\n{\r\nu32 sset_count = 0;\r\nstruct hns_mac_cb *mac_cb;\r\nstruct dsaf_device *dsaf_dev = hns_ae_get_dsaf_dev(handle->dev);\r\nassert(handle);\r\nmac_cb = hns_get_mac_cb(handle);\r\nsset_count += hns_rcb_get_ring_sset_count(stringset) * handle->q_num;\r\nsset_count += hns_ppe_get_sset_count(stringset);\r\nsset_count += hns_mac_get_sset_count(mac_cb, stringset);\r\nif (mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nsset_count += hns_dsaf_get_sset_count(dsaf_dev, stringset);\r\nreturn sset_count;\r\n}\r\nstatic int hns_ae_config_loopback(struct hnae_handle *handle,\r\nenum hnae_loop loop, int en)\r\n{\r\nint ret;\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nstruct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);\r\nstruct dsaf_device *dsaf_dev = mac_cb->dsaf_dev;\r\nswitch (loop) {\r\ncase MAC_INTERNALLOOP_PHY:\r\nret = 0;\r\nbreak;\r\ncase MAC_INTERNALLOOP_SERDES:\r\nret = dsaf_dev->misc_op->cfg_serdes_loopback(vf_cb->mac_cb,\r\n!!en);\r\nbreak;\r\ncase MAC_INTERNALLOOP_MAC:\r\nret = hns_mac_config_mac_loopback(vf_cb->mac_cb, loop, en);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nvoid hns_ae_update_led_status(struct hnae_handle *handle)\r\n{\r\nstruct hns_mac_cb *mac_cb;\r\nassert(handle);\r\nmac_cb = hns_get_mac_cb(handle);\r\nif (!mac_cb->cpld_ctrl)\r\nreturn;\r\nhns_set_led_opt(mac_cb);\r\n}\r\nint hns_ae_cpld_set_led_id(struct hnae_handle *handle,\r\nenum hnae_led_state status)\r\n{\r\nstruct hns_mac_cb *mac_cb;\r\nassert(handle);\r\nmac_cb = hns_get_mac_cb(handle);\r\nreturn hns_cpld_led_set_id(mac_cb, status);\r\n}\r\nvoid hns_ae_get_regs(struct hnae_handle *handle, void *data)\r\n{\r\nu32 *p = data;\r\nint i;\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\nstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\r\nhns_ppe_get_regs(ppe_cb, p);\r\np += hns_ppe_get_regs_count();\r\nhns_rcb_get_common_regs(vf_cb->dsaf_dev->rcb_common[0], p);\r\np += hns_rcb_get_common_regs_count();\r\nfor (i = 0; i < handle->q_num; i++) {\r\nhns_rcb_get_ring_regs(handle->qs[i], p);\r\np += hns_rcb_get_ring_regs_count();\r\n}\r\nhns_mac_get_regs(vf_cb->mac_cb, p);\r\np += hns_mac_get_regs_count(vf_cb->mac_cb);\r\nif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\r\nhns_dsaf_get_regs(vf_cb->dsaf_dev, vf_cb->port_index, p);\r\n}\r\nint hns_ae_get_regs_len(struct hnae_handle *handle)\r\n{\r\nu32 total_num;\r\nstruct hnae_vf_cb *vf_cb = hns_ae_get_vf_cb(handle);\r\ntotal_num = hns_ppe_get_regs_count();\r\ntotal_num += hns_rcb_get_common_regs_count();\r\ntotal_num += hns_rcb_get_ring_regs_count() * handle->q_num;\r\ntotal_num += hns_mac_get_regs_count(vf_cb->mac_cb);\r\nif (vf_cb->mac_cb->mac_type == HNAE_PORT_SERVICE)\r\ntotal_num += hns_dsaf_get_regs_count();\r\nreturn total_num;\r\n}\r\nstatic u32 hns_ae_get_rss_key_size(struct hnae_handle *handle)\r\n{\r\nreturn HNS_PPEV2_RSS_KEY_SIZE;\r\n}\r\nstatic u32 hns_ae_get_rss_indir_size(struct hnae_handle *handle)\r\n{\r\nreturn HNS_PPEV2_RSS_IND_TBL_SIZE;\r\n}\r\nstatic int hns_ae_get_rss(struct hnae_handle *handle, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\r\nif (hfunc)\r\n*hfunc = ETH_RSS_HASH_TOP;\r\nif (key)\r\nmemcpy(key, ppe_cb->rss_key, HNS_PPEV2_RSS_KEY_SIZE);\r\nmemcpy(indir, ppe_cb->rss_indir_table,\r\nHNS_PPEV2_RSS_IND_TBL_SIZE * sizeof(*indir));\r\nreturn 0;\r\n}\r\nstatic int hns_ae_set_rss(struct hnae_handle *handle, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct hns_ppe_cb *ppe_cb = hns_get_ppe_cb(handle);\r\nif (key)\r\nhns_ppe_set_rss_key(ppe_cb, (u32 *)key);\r\nmemcpy(ppe_cb->rss_indir_table, indir,\r\nHNS_PPEV2_RSS_IND_TBL_SIZE * sizeof(*indir));\r\nhns_ppe_set_indir_table(ppe_cb, ppe_cb->rss_indir_table);\r\nreturn 0;\r\n}\r\nint hns_dsaf_ae_init(struct dsaf_device *dsaf_dev)\r\n{\r\nstruct hnae_ae_dev *ae_dev = &dsaf_dev->ae_dev;\r\nstatic atomic_t id = ATOMIC_INIT(-1);\r\nswitch (dsaf_dev->dsaf_ver) {\r\ncase AE_VERSION_1:\r\nhns_dsaf_ops.toggle_ring_irq = hns_ae_toggle_ring_irq;\r\nbreak;\r\ncase AE_VERSION_2:\r\nhns_dsaf_ops.toggle_ring_irq = hns_aev2_toggle_ring_irq;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnprintf(ae_dev->name, AE_NAME_SIZE, "%s%d", DSAF_DEVICE_NAME,\r\n(int)atomic_inc_return(&id));\r\nae_dev->ops = &hns_dsaf_ops;\r\nae_dev->dev = dsaf_dev->dev;\r\nreturn hnae_ae_register(ae_dev, THIS_MODULE);\r\n}\r\nvoid hns_dsaf_ae_uninit(struct dsaf_device *dsaf_dev)\r\n{\r\nhnae_ae_unregister(&dsaf_dev->ae_dev);\r\n}
