int hci_uart_register_proto(const struct hci_uart_proto *p)\r\n{\r\nif (p->id >= HCI_UART_MAX_PROTO)\r\nreturn -EINVAL;\r\nif (hup[p->id])\r\nreturn -EEXIST;\r\nhup[p->id] = p;\r\nBT_INFO("HCI UART protocol %s registered", p->name);\r\nreturn 0;\r\n}\r\nint hci_uart_unregister_proto(const struct hci_uart_proto *p)\r\n{\r\nif (p->id >= HCI_UART_MAX_PROTO)\r\nreturn -EINVAL;\r\nif (!hup[p->id])\r\nreturn -EINVAL;\r\nhup[p->id] = NULL;\r\nreturn 0;\r\n}\r\nstatic const struct hci_uart_proto *hci_uart_get_proto(unsigned int id)\r\n{\r\nif (id >= HCI_UART_MAX_PROTO)\r\nreturn NULL;\r\nreturn hup[id];\r\n}\r\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\r\n{\r\nstruct hci_dev *hdev = hu->hdev;\r\nswitch (pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\n}\r\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\r\n{\r\nstruct sk_buff *skb = hu->tx_skb;\r\nif (!skb)\r\nskb = hu->proto->dequeue(hu);\r\nelse\r\nhu->tx_skb = NULL;\r\nreturn skb;\r\n}\r\nint hci_uart_tx_wakeup(struct hci_uart *hu)\r\n{\r\nif (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state)) {\r\nset_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\r\nreturn 0;\r\n}\r\nBT_DBG("");\r\nschedule_work(&hu->write_work);\r\nreturn 0;\r\n}\r\nstatic void hci_uart_write_work(struct work_struct *work)\r\n{\r\nstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\r\nstruct tty_struct *tty = hu->tty;\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct sk_buff *skb;\r\nrestart:\r\nclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\r\nwhile ((skb = hci_uart_dequeue(hu))) {\r\nint len;\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nlen = tty->ops->write(tty, skb->data, skb->len);\r\nhdev->stat.byte_tx += len;\r\nskb_pull(skb, len);\r\nif (skb->len) {\r\nhu->tx_skb = skb;\r\nbreak;\r\n}\r\nhci_uart_tx_complete(hu, hci_skb_pkt_type(skb));\r\nkfree_skb(skb);\r\n}\r\nif (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))\r\ngoto restart;\r\nclear_bit(HCI_UART_SENDING, &hu->tx_state);\r\n}\r\nstatic void hci_uart_init_work(struct work_struct *work)\r\n{\r\nstruct hci_uart *hu = container_of(work, struct hci_uart, init_ready);\r\nint err;\r\nif (!test_and_clear_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn;\r\nerr = hci_register_dev(hu->hdev);\r\nif (err < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hu->hdev);\r\nhu->hdev = NULL;\r\nhu->proto->close(hu);\r\n}\r\nset_bit(HCI_UART_REGISTERED, &hu->flags);\r\n}\r\nint hci_uart_init_ready(struct hci_uart *hu)\r\n{\r\nif (!test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn -EALREADY;\r\nschedule_work(&hu->init_ready);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_open(struct hci_dev *hdev)\r\n{\r\nBT_DBG("%s %p", hdev->name, hdev);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_flush(struct hci_dev *hdev)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct tty_struct *tty = hu->tty;\r\nBT_DBG("hdev %p tty %p", hdev, tty);\r\nif (hu->tx_skb) {\r\nkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\r\n}\r\ntty_ldisc_flush(tty);\r\ntty_driver_flush_buffer(tty);\r\nif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\r\nhu->proto->flush(hu);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_close(struct hci_dev *hdev)\r\n{\r\nBT_DBG("hdev %p", hdev);\r\nhci_uart_flush(hdev);\r\nhdev->flush = NULL;\r\nreturn 0;\r\n}\r\nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nBT_DBG("%s: type %d len %d", hdev->name, hci_skb_pkt_type(skb),\r\nskb->len);\r\nhu->proto->enqueue(hu, skb);\r\nhci_uart_tx_wakeup(hu);\r\nreturn 0;\r\n}\r\nvoid hci_uart_set_flow_control(struct hci_uart *hu, bool enable)\r\n{\r\nstruct tty_struct *tty = hu->tty;\r\nstruct ktermios ktermios;\r\nint status;\r\nunsigned int set = 0;\r\nunsigned int clear = 0;\r\nif (enable) {\r\nktermios = tty->termios;\r\nktermios.c_cflag &= ~CRTSCTS;\r\nstatus = tty_set_termios(tty, &ktermios);\r\nBT_DBG("Disabling hardware flow control: %s",\r\nstatus ? "failed" : "success");\r\nstatus = tty->driver->ops->tiocmget(tty);\r\nBT_DBG("Current tiocm 0x%x", status);\r\nset &= ~(TIOCM_OUT2 | TIOCM_RTS);\r\nclear = ~set;\r\nset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\r\nTIOCM_OUT2 | TIOCM_LOOP;\r\nclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\r\nTIOCM_OUT2 | TIOCM_LOOP;\r\nstatus = tty->driver->ops->tiocmset(tty, set, clear);\r\nBT_DBG("Clearing RTS: %s", status ? "failed" : "success");\r\n} else {\r\nstatus = tty->driver->ops->tiocmget(tty);\r\nBT_DBG("Current tiocm 0x%x", status);\r\nset |= (TIOCM_OUT2 | TIOCM_RTS);\r\nclear = ~set;\r\nset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\r\nTIOCM_OUT2 | TIOCM_LOOP;\r\nclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\r\nTIOCM_OUT2 | TIOCM_LOOP;\r\nstatus = tty->driver->ops->tiocmset(tty, set, clear);\r\nBT_DBG("Setting RTS: %s", status ? "failed" : "success");\r\nktermios = tty->termios;\r\nktermios.c_cflag |= CRTSCTS;\r\nstatus = tty_set_termios(tty, &ktermios);\r\nBT_DBG("Enabling hardware flow control: %s",\r\nstatus ? "failed" : "success");\r\n}\r\n}\r\nvoid hci_uart_set_speeds(struct hci_uart *hu, unsigned int init_speed,\r\nunsigned int oper_speed)\r\n{\r\nhu->init_speed = init_speed;\r\nhu->oper_speed = oper_speed;\r\n}\r\nvoid hci_uart_init_tty(struct hci_uart *hu)\r\n{\r\nstruct tty_struct *tty = hu->tty;\r\nstruct ktermios ktermios;\r\nktermios = tty->termios;\r\nktermios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP |\r\nINLCR | IGNCR | ICRNL | IXON);\r\nktermios.c_oflag &= ~OPOST;\r\nktermios.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);\r\nktermios.c_cflag &= ~(CSIZE | PARENB);\r\nktermios.c_cflag |= CS8;\r\nktermios.c_cflag |= CRTSCTS;\r\ntty_set_termios(tty, &ktermios);\r\n}\r\nvoid hci_uart_set_baudrate(struct hci_uart *hu, unsigned int speed)\r\n{\r\nstruct tty_struct *tty = hu->tty;\r\nstruct ktermios ktermios;\r\nktermios = tty->termios;\r\nktermios.c_cflag &= ~CBAUD;\r\ntty_termios_encode_baud_rate(&ktermios, speed, speed);\r\ntty_set_termios(tty, &ktermios);\r\nBT_DBG("%s: New tty speeds: %d/%d", hu->hdev->name,\r\ntty->termios.c_ispeed, tty->termios.c_ospeed);\r\n}\r\nstatic int hci_uart_setup(struct hci_dev *hdev)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct hci_rp_read_local_version *ver;\r\nstruct sk_buff *skb;\r\nunsigned int speed;\r\nint err;\r\nif (hu->init_speed)\r\nspeed = hu->init_speed;\r\nelse if (hu->proto->init_speed)\r\nspeed = hu->proto->init_speed;\r\nelse\r\nspeed = 0;\r\nif (speed)\r\nhci_uart_set_baudrate(hu, speed);\r\nif (hu->oper_speed)\r\nspeed = hu->oper_speed;\r\nelse if (hu->proto->oper_speed)\r\nspeed = hu->proto->oper_speed;\r\nelse\r\nspeed = 0;\r\nif (hu->proto->set_baudrate && speed) {\r\nerr = hu->proto->set_baudrate(hu, speed);\r\nif (!err)\r\nhci_uart_set_baudrate(hu, speed);\r\n}\r\nif (hu->proto->setup)\r\nreturn hu->proto->setup(hu);\r\nif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\r\nreturn 0;\r\nskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\r\nHCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nBT_ERR("%s: Reading local version information failed (%ld)",\r\nhdev->name, PTR_ERR(skb));\r\nreturn 0;\r\n}\r\nif (skb->len != sizeof(*ver)) {\r\nBT_ERR("%s: Event length mismatch for version information",\r\nhdev->name);\r\ngoto done;\r\n}\r\nver = (struct hci_rp_read_local_version *)skb->data;\r\nswitch (le16_to_cpu(ver->manufacturer)) {\r\n#ifdef CONFIG_BT_HCIUART_INTEL\r\ncase 2:\r\nhdev->set_bdaddr = btintel_set_bdaddr;\r\nbtintel_check_bdaddr(hdev);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCM\r\ncase 15:\r\nhdev->set_bdaddr = btbcm_set_bdaddr;\r\nbtbcm_check_bdaddr(hdev);\r\nbreak;\r\n#endif\r\n}\r\ndone:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_tty_open(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu;\r\nBT_DBG("tty %p", tty);\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nhu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);\r\nif (!hu) {\r\nBT_ERR("Can't allocate control structure");\r\nreturn -ENFILE;\r\n}\r\ntty->disc_data = hu;\r\nhu->tty = tty;\r\ntty->receive_room = 65536;\r\nINIT_WORK(&hu->init_ready, hci_uart_init_work);\r\nINIT_WORK(&hu->write_work, hci_uart_write_work);\r\ntty_driver_flush_buffer(tty);\r\nreturn 0;\r\n}\r\nstatic void hci_uart_tty_close(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu = tty->disc_data;\r\nstruct hci_dev *hdev;\r\nBT_DBG("tty %p", tty);\r\ntty->disc_data = NULL;\r\nif (!hu)\r\nreturn;\r\nhdev = hu->hdev;\r\nif (hdev)\r\nhci_uart_close(hdev);\r\ncancel_work_sync(&hu->write_work);\r\nif (test_and_clear_bit(HCI_UART_PROTO_READY, &hu->flags)) {\r\nif (hdev) {\r\nif (test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\n}\r\nhu->proto->close(hu);\r\n}\r\nclear_bit(HCI_UART_PROTO_SET, &hu->flags);\r\nkfree(hu);\r\n}\r\nstatic void hci_uart_tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct hci_uart *hu = tty->disc_data;\r\nBT_DBG("");\r\nif (!hu)\r\nreturn;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (tty != hu->tty)\r\nreturn;\r\nif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,\r\nchar *flags, int count)\r\n{\r\nstruct hci_uart *hu = tty->disc_data;\r\nif (!hu || tty != hu->tty)\r\nreturn;\r\nif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\r\nreturn;\r\nhu->proto->recv(hu, data, count);\r\nif (hu->hdev)\r\nhu->hdev->stat.byte_rx += count;\r\ntty_unthrottle(tty);\r\n}\r\nstatic int hci_uart_register_dev(struct hci_uart *hu)\r\n{\r\nstruct hci_dev *hdev;\r\nBT_DBG("");\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\nhu->hdev = hdev;\r\nhdev->bus = HCI_UART;\r\nhci_set_drvdata(hdev, hu);\r\nif (hu->proto->setup)\r\nhdev->manufacturer = hu->proto->manufacturer;\r\nhdev->open = hci_uart_open;\r\nhdev->close = hci_uart_close;\r\nhdev->flush = hci_uart_flush;\r\nhdev->send = hci_uart_send_frame;\r\nhdev->setup = hci_uart_setup;\r\nSET_HCIDEV_DEV(hdev, hu->tty->dev);\r\nif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\r\nif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\r\nif (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))\r\nset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\r\nif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\r\nhdev->dev_type = HCI_AMP;\r\nelse\r\nhdev->dev_type = HCI_PRIMARY;\r\nif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\r\nreturn 0;\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\nhci_free_dev(hdev);\r\nreturn -ENODEV;\r\n}\r\nset_bit(HCI_UART_REGISTERED, &hu->flags);\r\nreturn 0;\r\n}\r\nstatic int hci_uart_set_proto(struct hci_uart *hu, int id)\r\n{\r\nconst struct hci_uart_proto *p;\r\nint err;\r\np = hci_uart_get_proto(id);\r\nif (!p)\r\nreturn -EPROTONOSUPPORT;\r\nerr = p->open(hu);\r\nif (err)\r\nreturn err;\r\nhu->proto = p;\r\nset_bit(HCI_UART_PROTO_READY, &hu->flags);\r\nerr = hci_uart_register_dev(hu);\r\nif (err) {\r\nclear_bit(HCI_UART_PROTO_READY, &hu->flags);\r\np->close(hu);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hci_uart_set_flags(struct hci_uart *hu, unsigned long flags)\r\n{\r\nunsigned long valid_flags = BIT(HCI_UART_RAW_DEVICE) |\r\nBIT(HCI_UART_RESET_ON_INIT) |\r\nBIT(HCI_UART_CREATE_AMP) |\r\nBIT(HCI_UART_INIT_PENDING) |\r\nBIT(HCI_UART_EXT_CONFIG) |\r\nBIT(HCI_UART_VND_DETECT);\r\nif (flags & ~valid_flags)\r\nreturn -EINVAL;\r\nhu->hdev_flags = flags;\r\nreturn 0;\r\n}\r\nstatic int hci_uart_tty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hci_uart *hu = tty->disc_data;\r\nint err = 0;\r\nBT_DBG("");\r\nif (!hu)\r\nreturn -EBADF;\r\nswitch (cmd) {\r\ncase HCIUARTSETPROTO:\r\nif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\r\nerr = hci_uart_set_proto(hu, arg);\r\nif (err)\r\nclear_bit(HCI_UART_PROTO_SET, &hu->flags);\r\n} else\r\nerr = -EBUSY;\r\nbreak;\r\ncase HCIUARTGETPROTO:\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nerr = hu->proto->id;\r\nelse\r\nerr = -EUNATCH;\r\nbreak;\r\ncase HCIUARTGETDEVICE:\r\nif (test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nerr = hu->hdev->id;\r\nelse\r\nerr = -EUNATCH;\r\nbreak;\r\ncase HCIUARTSETFLAGS:\r\nif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\r\nerr = -EBUSY;\r\nelse\r\nerr = hci_uart_set_flags(hu, arg);\r\nbreak;\r\ncase HCIUARTGETFLAGS:\r\nerr = hu->hdev_flags;\r\nbreak;\r\ndefault:\r\nerr = n_tty_ioctl_helper(tty, file, cmd, arg);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *data, size_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int hci_uart_tty_poll(struct tty_struct *tty,\r\nstruct file *filp, poll_table *wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init hci_uart_init(void)\r\n{\r\nstatic struct tty_ldisc_ops hci_uart_ldisc;\r\nint err;\r\nBT_INFO("HCI UART driver ver %s", VERSION);\r\nmemset(&hci_uart_ldisc, 0, sizeof(hci_uart_ldisc));\r\nhci_uart_ldisc.magic = TTY_LDISC_MAGIC;\r\nhci_uart_ldisc.name = "n_hci";\r\nhci_uart_ldisc.open = hci_uart_tty_open;\r\nhci_uart_ldisc.close = hci_uart_tty_close;\r\nhci_uart_ldisc.read = hci_uart_tty_read;\r\nhci_uart_ldisc.write = hci_uart_tty_write;\r\nhci_uart_ldisc.ioctl = hci_uart_tty_ioctl;\r\nhci_uart_ldisc.poll = hci_uart_tty_poll;\r\nhci_uart_ldisc.receive_buf = hci_uart_tty_receive;\r\nhci_uart_ldisc.write_wakeup = hci_uart_tty_wakeup;\r\nhci_uart_ldisc.owner = THIS_MODULE;\r\nerr = tty_register_ldisc(N_HCI, &hci_uart_ldisc);\r\nif (err) {\r\nBT_ERR("HCI line discipline registration failed. (%d)", err);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_BT_HCIUART_H4\r\nh4_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCSP\r\nbcsp_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_LL\r\nll_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_ATH3K\r\nath_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_3WIRE\r\nh5_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_INTEL\r\nintel_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCM\r\nbcm_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_QCA\r\nqca_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_AG6XX\r\nag6xx_init();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_MRVL\r\nmrvl_init();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit hci_uart_exit(void)\r\n{\r\nint err;\r\n#ifdef CONFIG_BT_HCIUART_H4\r\nh4_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCSP\r\nbcsp_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_LL\r\nll_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_ATH3K\r\nath_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_3WIRE\r\nh5_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_INTEL\r\nintel_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_BCM\r\nbcm_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_QCA\r\nqca_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_AG6XX\r\nag6xx_deinit();\r\n#endif\r\n#ifdef CONFIG_BT_HCIUART_MRVL\r\nmrvl_deinit();\r\n#endif\r\nerr = tty_unregister_ldisc(N_HCI);\r\nif (err)\r\nBT_ERR("Can't unregister HCI line discipline (%d)", err);\r\n}
