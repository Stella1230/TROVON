static unsigned long\r\naxxia_pllclk_recalc(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct axxia_clk *aclk = to_axxia_clk(hw);\r\nstruct axxia_pllclk *pll = to_axxia_pllclk(aclk);\r\nunsigned long rate, fbdiv, refdiv, postdiv;\r\nu32 control;\r\nregmap_read(aclk->regmap, pll->reg, &control);\r\npostdiv = ((control >> 0) & 0xf) + 1;\r\nfbdiv = ((control >> 4) & 0xfff) + 3;\r\nrefdiv = ((control >> 16) & 0x1f) + 1;\r\nrate = (parent_rate / (refdiv * postdiv)) * fbdiv;\r\nreturn rate;\r\n}\r\nstatic unsigned long\r\naxxia_divclk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct axxia_clk *aclk = to_axxia_clk(hw);\r\nstruct axxia_divclk *divclk = to_axxia_divclk(aclk);\r\nu32 ctrl, div;\r\nregmap_read(aclk->regmap, divclk->reg, &ctrl);\r\ndiv = 1 + ((ctrl >> divclk->shift) & ((1 << divclk->width)-1));\r\nreturn parent_rate / div;\r\n}\r\nstatic u8 axxia_clkmux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct axxia_clk *aclk = to_axxia_clk(hw);\r\nstruct axxia_clkmux *mux = to_axxia_clkmux(aclk);\r\nu32 ctrl, parent;\r\nregmap_read(aclk->regmap, mux->reg, &ctrl);\r\nparent = (ctrl >> mux->shift) & ((1 << mux->width) - 1);\r\nreturn (u8) parent;\r\n}\r\nstatic struct clk_hw *\r\nof_clk_axmclk_get(struct of_phandle_args *clkspec, void *unused)\r\n{\r\nunsigned int idx = clkspec->args[0];\r\nif (idx >= ARRAY_SIZE(axmclk_clocks)) {\r\npr_err("%s: invalid index %u\n", __func__, idx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn &axmclk_clocks[idx]->hw;\r\n}\r\nstatic int axmclk_probe(struct platform_device *pdev)\r\n{\r\nvoid __iomem *base;\r\nstruct resource *res;\r\nint i, ret;\r\nstruct device *dev = &pdev->dev;\r\nstruct regmap *regmap;\r\nsize_t num_clks;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = devm_regmap_init_mmio(dev, base, &axmclk_regmap_config);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nnum_clks = ARRAY_SIZE(axmclk_clocks);\r\npr_info("axmclk: supporting %zu clocks\n", num_clks);\r\nfor (i = 0; i < num_clks; i++) {\r\naxmclk_clocks[i]->regmap = regmap;\r\nret = devm_clk_hw_register(dev, &axmclk_clocks[i]->hw);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn of_clk_add_hw_provider(dev->of_node, of_clk_axmclk_get, NULL);\r\n}\r\nstatic int axmclk_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}\r\nstatic int __init axmclk_init(void)\r\n{\r\nreturn platform_driver_register(&axmclk_driver);\r\n}\r\nstatic void __exit axmclk_exit(void)\r\n{\r\nplatform_driver_unregister(&axmclk_driver);\r\n}
