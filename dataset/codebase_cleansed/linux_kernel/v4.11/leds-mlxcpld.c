static enum\r\nmlxcpld_led_platform_types mlxcpld_led_platform_check_sys_type(void)\r\n{\r\nconst char *mlx_product_name;\r\nint i;\r\nmlx_product_name = dmi_get_system_info(DMI_PRODUCT_NAME);\r\nif (!mlx_product_name)\r\nreturn MLXCPLD_LED_PLATFORM_DEFAULT;\r\nfor (i = 1; i < ARRAY_SIZE(mlx_product_names); i++) {\r\nif (strstr(mlx_product_name, mlx_product_names[i]))\r\nreturn i;\r\n}\r\nreturn MLXCPLD_LED_PLATFORM_DEFAULT;\r\n}\r\nstatic void mlxcpld_led_bus_access_func(u16 base, u8 offset, u8 rw_flag,\r\nu8 *data)\r\n{\r\nu32 addr = base + offset;\r\nif (rw_flag == 0)\r\noutb(*data, addr);\r\nelse\r\n*data = inb(addr);\r\n}\r\nstatic void mlxcpld_led_store_hw(u8 mask, u8 off, u8 vset)\r\n{\r\nu8 nib, val;\r\nspin_lock(&mlxcpld_led->lock);\r\nmlxcpld_led_bus_access_func(MLXPLAT_CPLD_LPC_REG_BASE_ADRR, off, 1,\r\n&val);\r\nnib = (mask == 0xf0) ? vset : (vset << 4);\r\nval = (val & mask) | nib;\r\nmlxcpld_led_bus_access_func(MLXPLAT_CPLD_LPC_REG_BASE_ADRR, off, 0,\r\n&val);\r\nspin_unlock(&mlxcpld_led->lock);\r\n}\r\nstatic void mlxcpld_led_brightness_set(struct led_classdev *led,\r\nenum led_brightness value)\r\n{\r\nstruct mlxcpld_led_priv *pled = cdev_to_priv(led);\r\nif (value) {\r\nmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\r\npled->param.base_color);\r\nreturn;\r\n}\r\nmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\r\nMLXCPLD_LED_IS_OFF);\r\n}\r\nstatic int mlxcpld_led_blink_set(struct led_classdev *led,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct mlxcpld_led_priv *pled = cdev_to_priv(led);\r\nif (!(*delay_on == 0 && *delay_off == 0) &&\r\n!(*delay_on == MLXCPLD_LED_BLINK_3HZ &&\r\n*delay_off == MLXCPLD_LED_BLINK_3HZ) &&\r\n!(*delay_on == MLXCPLD_LED_BLINK_6HZ &&\r\n*delay_off == MLXCPLD_LED_BLINK_6HZ))\r\nreturn -EINVAL;\r\nif (*delay_on == MLXCPLD_LED_BLINK_6HZ)\r\nmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\r\npled->param.base_color +\r\nMLXCPLD_LED_OFFSET_FULL);\r\nelse\r\nmlxcpld_led_store_hw(pled->param.mask, pled->param.offset,\r\npled->param.base_color +\r\nMLXCPLD_LED_OFFSET_HALF);\r\nreturn 0;\r\n}\r\nstatic int mlxcpld_led_config(struct device *dev,\r\nstruct mlxcpld_led_pdata *cpld)\r\n{\r\nint i;\r\nint err;\r\ncpld->pled = devm_kzalloc(dev, sizeof(struct mlxcpld_led_priv) *\r\ncpld->num_led_instances, GFP_KERNEL);\r\nif (!cpld->pled)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < cpld->num_led_instances; i++) {\r\ncpld->pled[i].cdev.name = cpld->profile[i].name;\r\ncpld->pled[i].cdev.brightness = cpld->profile[i].brightness;\r\ncpld->pled[i].cdev.max_brightness = 1;\r\ncpld->pled[i].cdev.brightness_set = mlxcpld_led_brightness_set;\r\ncpld->pled[i].cdev.blink_set = mlxcpld_led_blink_set;\r\ncpld->pled[i].cdev.flags = LED_CORE_SUSPENDRESUME;\r\nerr = devm_led_classdev_register(dev, &cpld->pled[i].cdev);\r\nif (err)\r\nreturn err;\r\ncpld->pled[i].param.offset = mlxcpld_led->profile[i].offset;\r\ncpld->pled[i].param.mask = mlxcpld_led->profile[i].mask;\r\ncpld->pled[i].param.base_color =\r\nmlxcpld_led->profile[i].base_color;\r\nif (mlxcpld_led->profile[i].brightness)\r\nmlxcpld_led_brightness_set(&cpld->pled[i].cdev,\r\nmlxcpld_led->profile[i].brightness);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mlxcpld_led_probe(struct platform_device *pdev)\r\n{\r\nenum mlxcpld_led_platform_types mlxcpld_led_plat =\r\nmlxcpld_led_platform_check_sys_type();\r\nmlxcpld_led = devm_kzalloc(&pdev->dev, sizeof(*mlxcpld_led),\r\nGFP_KERNEL);\r\nif (!mlxcpld_led)\r\nreturn -ENOMEM;\r\nmlxcpld_led->pdev = pdev;\r\nswitch (mlxcpld_led_plat) {\r\ncase MLXCPLD_LED_PLATFORM_MSN2100:\r\nmlxcpld_led->profile = mlxcpld_led_msn2100_profile;\r\nmlxcpld_led->num_led_instances =\r\nARRAY_SIZE(mlxcpld_led_msn2100_profile);\r\nbreak;\r\ndefault:\r\nmlxcpld_led->profile = mlxcpld_led_default_profile;\r\nmlxcpld_led->num_led_instances =\r\nARRAY_SIZE(mlxcpld_led_default_profile);\r\nbreak;\r\n}\r\nspin_lock_init(&mlxcpld_led->lock);\r\nreturn mlxcpld_led_config(&pdev->dev, mlxcpld_led);\r\n}\r\nstatic int __init mlxcpld_led_init(void)\r\n{\r\nstruct platform_device *pdev;\r\nint err;\r\nif (!dmi_match(DMI_CHASSIS_VENDOR, "Mellanox Technologies Ltd."))\r\nreturn -ENODEV;\r\npdev = platform_device_register_simple(KBUILD_MODNAME, -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\npr_err("Device allocation failed\n");\r\nreturn PTR_ERR(pdev);\r\n}\r\nerr = platform_driver_probe(&mlxcpld_led_driver, mlxcpld_led_probe);\r\nif (err) {\r\npr_err("Probe platform driver failed\n");\r\nplatform_device_unregister(pdev);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit mlxcpld_led_exit(void)\r\n{\r\nplatform_device_unregister(mlxcpld_led->pdev);\r\nplatform_driver_unregister(&mlxcpld_led_driver);\r\n}
