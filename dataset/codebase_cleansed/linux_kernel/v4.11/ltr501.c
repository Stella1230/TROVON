static int ltr501_match_samp_freq(const struct ltr501_samp_table *tab,\r\nint len, int val, int val2)\r\n{\r\nint i, freq;\r\nfreq = val * 1000000 + val2;\r\nfor (i = 0; i < len; i++) {\r\nif (tab[i].freq_val == freq)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_als_read_samp_freq(struct ltr501_data *data,\r\nint *val, int *val2)\r\n{\r\nint ret, i;\r\nret = regmap_field_read(data->reg_als_rate, &i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i < 0 || i >= ARRAY_SIZE(ltr501_als_samp_table))\r\nreturn -EINVAL;\r\n*val = ltr501_als_samp_table[i].freq_val / 1000000;\r\n*val2 = ltr501_als_samp_table[i].freq_val % 1000000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int ltr501_ps_read_samp_freq(struct ltr501_data *data,\r\nint *val, int *val2)\r\n{\r\nint ret, i;\r\nret = regmap_field_read(data->reg_ps_rate, &i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i < 0 || i >= ARRAY_SIZE(ltr501_ps_samp_table))\r\nreturn -EINVAL;\r\n*val = ltr501_ps_samp_table[i].freq_val / 1000000;\r\n*val2 = ltr501_ps_samp_table[i].freq_val % 1000000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int ltr501_als_write_samp_freq(struct ltr501_data *data,\r\nint val, int val2)\r\n{\r\nint i, ret;\r\ni = ltr501_match_samp_freq(ltr501_als_samp_table,\r\nARRAY_SIZE(ltr501_als_samp_table),\r\nval, val2);\r\nif (i < 0)\r\nreturn i;\r\nmutex_lock(&data->lock_als);\r\nret = regmap_field_write(data->reg_als_rate, i);\r\nmutex_unlock(&data->lock_als);\r\nreturn ret;\r\n}\r\nstatic int ltr501_ps_write_samp_freq(struct ltr501_data *data,\r\nint val, int val2)\r\n{\r\nint i, ret;\r\ni = ltr501_match_samp_freq(ltr501_ps_samp_table,\r\nARRAY_SIZE(ltr501_ps_samp_table),\r\nval, val2);\r\nif (i < 0)\r\nreturn i;\r\nmutex_lock(&data->lock_ps);\r\nret = regmap_field_write(data->reg_ps_rate, i);\r\nmutex_unlock(&data->lock_ps);\r\nreturn ret;\r\n}\r\nstatic int ltr501_als_read_samp_period(struct ltr501_data *data, int *val)\r\n{\r\nint ret, i;\r\nret = regmap_field_read(data->reg_als_rate, &i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i < 0 || i >= ARRAY_SIZE(ltr501_als_samp_table))\r\nreturn -EINVAL;\r\n*val = ltr501_als_samp_table[i].time_val;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int ltr501_ps_read_samp_period(struct ltr501_data *data, int *val)\r\n{\r\nint ret, i;\r\nret = regmap_field_read(data->reg_ps_rate, &i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (i < 0 || i >= ARRAY_SIZE(ltr501_ps_samp_table))\r\nreturn -EINVAL;\r\n*val = ltr501_ps_samp_table[i].time_val;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic unsigned long ltr501_calculate_lux(u16 vis_data, u16 ir_data)\r\n{\r\nunsigned long ratio, lux;\r\nif (vis_data == 0)\r\nreturn 0;\r\nratio = DIV_ROUND_UP(ir_data * 100, ir_data + vis_data);\r\nif (ratio < 45)\r\nlux = LTR501_LUX_CONV(1774, vis_data, -1105, ir_data);\r\nelse if (ratio >= 45 && ratio < 64)\r\nlux = LTR501_LUX_CONV(3772, vis_data, 1336, ir_data);\r\nelse if (ratio >= 64 && ratio < 85)\r\nlux = LTR501_LUX_CONV(1690, vis_data, 169, ir_data);\r\nelse\r\nlux = 0;\r\nreturn lux / 1000;\r\n}\r\nstatic int ltr501_drdy(struct ltr501_data *data, u8 drdy_mask)\r\n{\r\nint tries = 100;\r\nint ret, status;\r\nwhile (tries--) {\r\nret = regmap_read(data->regmap, LTR501_ALS_PS_STATUS, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((status & drdy_mask) == drdy_mask)\r\nreturn 0;\r\nmsleep(25);\r\n}\r\ndev_err(&data->client->dev, "ltr501_drdy() failed, data not ready\n");\r\nreturn -EIO;\r\n}\r\nstatic int ltr501_set_it_time(struct ltr501_data *data, int it)\r\n{\r\nint ret, i, index = -1, status;\r\nfor (i = 0; i < ARRAY_SIZE(int_time_mapping); i++) {\r\nif (int_time_mapping[i] == it) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index < 0)\r\nreturn -EINVAL;\r\nret = regmap_read(data->regmap, LTR501_ALS_CONTR, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nif (status & LTR501_CONTR_ALS_GAIN_MASK) {\r\nif (index > 1)\r\nreturn -EINVAL;\r\n} else\r\nif (index == 1)\r\nreturn -EINVAL;\r\nreturn regmap_field_write(data->reg_it, index);\r\n}\r\nstatic int ltr501_read_it_time(struct ltr501_data *data, int *val, int *val2)\r\n{\r\nint ret, index;\r\nret = regmap_field_read(data->reg_it, &index);\r\nif (ret < 0)\r\nreturn ret;\r\nif (index < 0 || index >= ARRAY_SIZE(int_time_mapping))\r\nreturn -EINVAL;\r\n*val2 = int_time_mapping[index];\r\n*val = 0;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int ltr501_read_als(struct ltr501_data *data, __le16 buf[2])\r\n{\r\nint ret;\r\nret = ltr501_drdy(data, LTR501_STATUS_ALS_RDY);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_bulk_read(data->regmap, LTR501_ALS_DATA1,\r\nbuf, 2 * sizeof(__le16));\r\n}\r\nstatic int ltr501_read_ps(struct ltr501_data *data)\r\n{\r\nint ret, status;\r\nret = ltr501_drdy(data, LTR501_STATUS_PS_RDY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_bulk_read(data->regmap, LTR501_PS_DATA,\r\n&status, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn status;\r\n}\r\nstatic int ltr501_read_intr_prst(struct ltr501_data *data,\r\nenum iio_chan_type type,\r\nint *val2)\r\n{\r\nint ret, samp_period, prst;\r\nswitch (type) {\r\ncase IIO_INTENSITY:\r\nret = regmap_field_read(data->reg_als_prst, &prst);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ltr501_als_read_samp_period(data, &samp_period);\r\nif (ret < 0)\r\nreturn ret;\r\n*val2 = samp_period * prst;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_PROXIMITY:\r\nret = regmap_field_read(data->reg_ps_prst, &prst);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ltr501_ps_read_samp_period(data, &samp_period);\r\nif (ret < 0)\r\nreturn ret;\r\n*val2 = samp_period * prst;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_write_intr_prst(struct ltr501_data *data,\r\nenum iio_chan_type type,\r\nint val, int val2)\r\n{\r\nint ret, samp_period, new_val;\r\nunsigned long period;\r\nif (val < 0 || val2 < 0)\r\nreturn -EINVAL;\r\nperiod = ((val * 1000000) + val2);\r\nswitch (type) {\r\ncase IIO_INTENSITY:\r\nret = ltr501_als_read_samp_period(data, &samp_period);\r\nif (ret < 0)\r\nreturn ret;\r\nif (period < samp_period)\r\nreturn -EINVAL;\r\nnew_val = DIV_ROUND_UP(period, samp_period);\r\nif (new_val < 0 || new_val > 0x0f)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock_als);\r\nret = regmap_field_write(data->reg_als_prst, new_val);\r\nmutex_unlock(&data->lock_als);\r\nif (ret >= 0)\r\ndata->als_period = period;\r\nreturn ret;\r\ncase IIO_PROXIMITY:\r\nret = ltr501_ps_read_samp_period(data, &samp_period);\r\nif (ret < 0)\r\nreturn ret;\r\nif (period < samp_period)\r\nreturn -EINVAL;\r\nnew_val = DIV_ROUND_UP(period, samp_period);\r\nif (new_val < 0 || new_val > 0x0f)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock_ps);\r\nret = regmap_field_write(data->reg_ps_prst, new_val);\r\nmutex_unlock(&data->lock_ps);\r\nif (ret >= 0)\r\ndata->ps_period = period;\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\n__le16 buf[2];\r\nint ret, i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->lock_als);\r\nret = ltr501_read_als(data, buf);\r\nmutex_unlock(&data->lock_als);\r\niio_device_release_direct_mode(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ltr501_calculate_lux(le16_to_cpu(buf[1]),\r\nle16_to_cpu(buf[0]));\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_RAW:\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nmutex_lock(&data->lock_als);\r\nret = ltr501_read_als(data, buf);\r\nmutex_unlock(&data->lock_als);\r\nif (ret < 0)\r\nbreak;\r\n*val = le16_to_cpu(chan->address == LTR501_ALS_DATA1 ?\r\nbuf[0] : buf[1]);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nmutex_lock(&data->lock_ps);\r\nret = ltr501_read_ps(data);\r\nmutex_unlock(&data->lock_ps);\r\nif (ret < 0)\r\nbreak;\r\n*val = ret & LTR501_PS_DATA_MASK;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\ni = (data->als_contr & data->chip_info->als_gain_mask)\r\n>> data->chip_info->als_gain_shift;\r\n*val = data->chip_info->als_gain[i].scale;\r\n*val2 = data->chip_info->als_gain[i].uscale;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_PROXIMITY:\r\ni = (data->ps_contr & LTR501_CONTR_PS_GAIN_MASK) >>\r\nLTR501_CONTR_PS_GAIN_SHIFT;\r\n*val = data->chip_info->ps_gain[i].scale;\r\n*val2 = data->chip_info->ps_gain[i].uscale;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nreturn ltr501_read_it_time(data, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nreturn ltr501_als_read_samp_freq(data, val, val2);\r\ncase IIO_PROXIMITY:\r\nreturn ltr501_ps_read_samp_freq(data, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_get_gain_index(struct ltr501_gain *gain, int size,\r\nint val, int val2)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nif (val == gain[i].scale && val2 == gain[i].uscale)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic int ltr501_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint i, ret, freq_val, freq_val2;\r\nstruct ltr501_chip_info *info = data->chip_info;\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\ni = ltr501_get_gain_index(info->als_gain,\r\ninfo->als_gain_tbl_size,\r\nval, val2);\r\nif (i < 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata->als_contr &= ~info->als_gain_mask;\r\ndata->als_contr |= i << info->als_gain_shift;\r\nret = regmap_write(data->regmap, LTR501_ALS_CONTR,\r\ndata->als_contr);\r\nbreak;\r\ncase IIO_PROXIMITY:\r\ni = ltr501_get_gain_index(info->ps_gain,\r\ninfo->ps_gain_tbl_size,\r\nval, val2);\r\nif (i < 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata->ps_contr &= ~LTR501_CONTR_PS_GAIN_MASK;\r\ndata->ps_contr |= i << LTR501_CONTR_PS_GAIN_SHIFT;\r\nret = regmap_write(data->regmap, LTR501_PS_CONTR,\r\ndata->ps_contr);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nif (val != 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_lock(&data->lock_als);\r\nret = ltr501_set_it_time(data, val2);\r\nmutex_unlock(&data->lock_als);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nret = ltr501_als_read_samp_freq(data, &freq_val,\r\n&freq_val2);\r\nif (ret < 0)\r\nbreak;\r\nret = ltr501_als_write_samp_freq(data, val, val2);\r\nif (ret < 0)\r\nbreak;\r\nret = ltr501_write_intr_prst(data, chan->type,\r\n0, data->als_period);\r\nif (ret < 0)\r\nret = ltr501_als_write_samp_freq(data, freq_val,\r\nfreq_val2);\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nret = ltr501_ps_read_samp_freq(data, &freq_val,\r\n&freq_val2);\r\nif (ret < 0)\r\nbreak;\r\nret = ltr501_ps_write_samp_freq(data, val, val2);\r\nif (ret < 0)\r\nbreak;\r\nret = ltr501_write_intr_prst(data, chan->type,\r\n0, data->ps_period);\r\nif (ret < 0)\r\nret = ltr501_ps_write_samp_freq(data, freq_val,\r\nfreq_val2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ltr501_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint ret, thresh_data;\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nret = regmap_bulk_read(data->regmap,\r\nLTR501_ALS_THRESH_UP,\r\n&thresh_data, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = thresh_data & LTR501_ALS_THRESH_MASK;\r\nreturn IIO_VAL_INT;\r\ncase IIO_EV_DIR_FALLING:\r\nret = regmap_bulk_read(data->regmap,\r\nLTR501_ALS_THRESH_LOW,\r\n&thresh_data, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = thresh_data & LTR501_ALS_THRESH_MASK;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_PROXIMITY:\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nret = regmap_bulk_read(data->regmap,\r\nLTR501_PS_THRESH_UP,\r\n&thresh_data, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = thresh_data & LTR501_PS_THRESH_MASK;\r\nreturn IIO_VAL_INT;\r\ncase IIO_EV_DIR_FALLING:\r\nret = regmap_bulk_read(data->regmap,\r\nLTR501_PS_THRESH_LOW,\r\n&thresh_data, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = thresh_data & LTR501_PS_THRESH_MASK;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nif (val > LTR501_ALS_THRESH_MASK)\r\nreturn -EINVAL;\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nmutex_lock(&data->lock_als);\r\nret = regmap_bulk_write(data->regmap,\r\nLTR501_ALS_THRESH_UP,\r\n&val, 2);\r\nmutex_unlock(&data->lock_als);\r\nreturn ret;\r\ncase IIO_EV_DIR_FALLING:\r\nmutex_lock(&data->lock_als);\r\nret = regmap_bulk_write(data->regmap,\r\nLTR501_ALS_THRESH_LOW,\r\n&val, 2);\r\nmutex_unlock(&data->lock_als);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_PROXIMITY:\r\nif (val > LTR501_PS_THRESH_MASK)\r\nreturn -EINVAL;\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nmutex_lock(&data->lock_ps);\r\nret = regmap_bulk_write(data->regmap,\r\nLTR501_PS_THRESH_UP,\r\n&val, 2);\r\nmutex_unlock(&data->lock_ps);\r\nreturn ret;\r\ncase IIO_EV_DIR_FALLING:\r\nmutex_lock(&data->lock_ps);\r\nret = regmap_bulk_write(data->regmap,\r\nLTR501_PS_THRESH_LOW,\r\n&val, 2);\r\nmutex_unlock(&data->lock_ps);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_read_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nint ret;\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\nreturn ltr501_read_thresh(indio_dev, chan, type, dir,\r\ninfo, val, val2);\r\ncase IIO_EV_INFO_PERIOD:\r\nret = ltr501_read_intr_prst(iio_priv(indio_dev),\r\nchan->type, val2);\r\n*val = *val2 / 1000000;\r\n*val2 = *val2 % 1000000;\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_write_event(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir,\r\nenum iio_event_info info,\r\nint val, int val2)\r\n{\r\nswitch (info) {\r\ncase IIO_EV_INFO_VALUE:\r\nif (val2 != 0)\r\nreturn -EINVAL;\r\nreturn ltr501_write_thresh(indio_dev, chan, type, dir,\r\ninfo, val, val2);\r\ncase IIO_EV_INFO_PERIOD:\r\nreturn ltr501_write_intr_prst(iio_priv(indio_dev), chan->type,\r\nval, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_read_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint ret, status;\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nret = regmap_field_read(data->reg_als_intr, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn status;\r\ncase IIO_PROXIMITY:\r\nret = regmap_field_read(data->reg_ps_intr, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn status;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ltr501_write_event_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint ret;\r\nif (state != 1 && state != 0)\r\nreturn -EINVAL;\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\nmutex_lock(&data->lock_als);\r\nret = regmap_field_write(data->reg_als_intr, state);\r\nmutex_unlock(&data->lock_als);\r\nreturn ret;\r\ncase IIO_PROXIMITY:\r\nmutex_lock(&data->lock_ps);\r\nret = regmap_field_write(data->reg_ps_intr, state);\r\nmutex_unlock(&data->lock_ps);\r\nreturn ret;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ltr501_show_proximity_scale_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ltr501_data *data = iio_priv(dev_to_iio_dev(dev));\r\nstruct ltr501_chip_info *info = data->chip_info;\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < info->ps_gain_tbl_size; i++) {\r\nif (info->ps_gain[i].scale == LTR501_RESERVED_GAIN)\r\ncontinue;\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d.%06d ",\r\ninfo->ps_gain[i].scale,\r\ninfo->ps_gain[i].uscale);\r\n}\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t ltr501_show_intensity_scale_avail(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ltr501_data *data = iio_priv(dev_to_iio_dev(dev));\r\nstruct ltr501_chip_info *info = data->chip_info;\r\nssize_t len = 0;\r\nint i;\r\nfor (i = 0; i < info->als_gain_tbl_size; i++) {\r\nif (info->als_gain[i].scale == LTR501_RESERVED_GAIN)\r\ncontinue;\r\nlen += scnprintf(buf + len, PAGE_SIZE - len, "%d.%06d ",\r\ninfo->als_gain[i].scale,\r\ninfo->als_gain[i].uscale);\r\n}\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic int ltr501_write_contr(struct ltr501_data *data, u8 als_val, u8 ps_val)\r\n{\r\nint ret;\r\nret = regmap_write(data->regmap, LTR501_ALS_CONTR, als_val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn regmap_write(data->regmap, LTR501_PS_CONTR, ps_val);\r\n}\r\nstatic irqreturn_t ltr501_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nu16 buf[8];\r\n__le16 als_buf[2];\r\nu8 mask = 0;\r\nint j = 0;\r\nint ret, psdata;\r\nmemset(buf, 0, sizeof(buf));\r\nif (test_bit(0, indio_dev->active_scan_mask) ||\r\ntest_bit(1, indio_dev->active_scan_mask))\r\nmask |= LTR501_STATUS_ALS_RDY;\r\nif (test_bit(2, indio_dev->active_scan_mask))\r\nmask |= LTR501_STATUS_PS_RDY;\r\nret = ltr501_drdy(data, mask);\r\nif (ret < 0)\r\ngoto done;\r\nif (mask & LTR501_STATUS_ALS_RDY) {\r\nret = regmap_bulk_read(data->regmap, LTR501_ALS_DATA1,\r\n(u8 *)als_buf, sizeof(als_buf));\r\nif (ret < 0)\r\nreturn ret;\r\nif (test_bit(0, indio_dev->active_scan_mask))\r\nbuf[j++] = le16_to_cpu(als_buf[1]);\r\nif (test_bit(1, indio_dev->active_scan_mask))\r\nbuf[j++] = le16_to_cpu(als_buf[0]);\r\n}\r\nif (mask & LTR501_STATUS_PS_RDY) {\r\nret = regmap_bulk_read(data->regmap, LTR501_PS_DATA,\r\n&psdata, 2);\r\nif (ret < 0)\r\ngoto done;\r\nbuf[j++] = psdata & LTR501_PS_DATA_MASK;\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, buf,\r\niio_get_time_ns(indio_dev));\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ltr501_interrupt_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct ltr501_data *data = iio_priv(indio_dev);\r\nint ret, status;\r\nret = regmap_read(data->regmap, LTR501_ALS_PS_STATUS, &status);\r\nif (ret < 0) {\r\ndev_err(&data->client->dev,\r\n"irq read int reg failed\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & LTR501_STATUS_ALS_INTR)\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\niio_get_time_ns(indio_dev));\r\nif (status & LTR501_STATUS_PS_INTR)\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\niio_get_time_ns(indio_dev));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ltr501_init(struct ltr501_data *data)\r\n{\r\nint ret, status;\r\nret = regmap_read(data->regmap, LTR501_ALS_CONTR, &status);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->als_contr = status | data->chip_info->als_mode_active;\r\nret = regmap_read(data->regmap, LTR501_PS_CONTR, &status);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->ps_contr = status | LTR501_CONTR_ACTIVE;\r\nret = ltr501_read_intr_prst(data, IIO_INTENSITY, &data->als_period);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ltr501_read_intr_prst(data, IIO_PROXIMITY, &data->ps_period);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ltr501_write_contr(data, data->als_contr, data->ps_contr);\r\n}\r\nstatic bool ltr501_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase LTR501_ALS_DATA1:\r\ncase LTR501_ALS_DATA0:\r\ncase LTR501_ALS_PS_STATUS:\r\ncase LTR501_PS_DATA:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int ltr501_powerdown(struct ltr501_data *data)\r\n{\r\nreturn ltr501_write_contr(data, data->als_contr &\r\n~data->chip_info->als_mode_active,\r\ndata->ps_contr & ~LTR501_CONTR_ACTIVE);\r\n}\r\nstatic const char *ltr501_match_acpi_device(struct device *dev, int *chip_idx)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\n*chip_idx = id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic int ltr501_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ltr501_data *data;\r\nstruct iio_dev *indio_dev;\r\nstruct regmap *regmap;\r\nint ret, partid, chip_idx = 0;\r\nconst char *name = NULL;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nregmap = devm_regmap_init_i2c(client, &ltr501_regmap_config);\r\nif (IS_ERR(regmap)) {\r\ndev_err(&client->dev, "Regmap initialization failed.\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->regmap = regmap;\r\nmutex_init(&data->lock_als);\r\nmutex_init(&data->lock_ps);\r\ndata->reg_it = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_it);\r\nif (IS_ERR(data->reg_it)) {\r\ndev_err(&client->dev, "Integ time reg field init failed.\n");\r\nreturn PTR_ERR(data->reg_it);\r\n}\r\ndata->reg_als_intr = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_als_intr);\r\nif (IS_ERR(data->reg_als_intr)) {\r\ndev_err(&client->dev, "ALS intr mode reg field init failed\n");\r\nreturn PTR_ERR(data->reg_als_intr);\r\n}\r\ndata->reg_ps_intr = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_ps_intr);\r\nif (IS_ERR(data->reg_ps_intr)) {\r\ndev_err(&client->dev, "PS intr mode reg field init failed.\n");\r\nreturn PTR_ERR(data->reg_ps_intr);\r\n}\r\ndata->reg_als_rate = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_als_rate);\r\nif (IS_ERR(data->reg_als_rate)) {\r\ndev_err(&client->dev, "ALS samp rate field init failed.\n");\r\nreturn PTR_ERR(data->reg_als_rate);\r\n}\r\ndata->reg_ps_rate = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_ps_rate);\r\nif (IS_ERR(data->reg_ps_rate)) {\r\ndev_err(&client->dev, "PS samp rate field init failed.\n");\r\nreturn PTR_ERR(data->reg_ps_rate);\r\n}\r\ndata->reg_als_prst = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_als_prst);\r\nif (IS_ERR(data->reg_als_prst)) {\r\ndev_err(&client->dev, "ALS prst reg field init failed\n");\r\nreturn PTR_ERR(data->reg_als_prst);\r\n}\r\ndata->reg_ps_prst = devm_regmap_field_alloc(&client->dev, regmap,\r\nreg_field_ps_prst);\r\nif (IS_ERR(data->reg_ps_prst)) {\r\ndev_err(&client->dev, "PS prst reg field init failed.\n");\r\nreturn PTR_ERR(data->reg_ps_prst);\r\n}\r\nret = regmap_read(data->regmap, LTR501_PART_ID, &partid);\r\nif (ret < 0)\r\nreturn ret;\r\nif (id) {\r\nname = id->name;\r\nchip_idx = id->driver_data;\r\n} else if (ACPI_HANDLE(&client->dev)) {\r\nname = ltr501_match_acpi_device(&client->dev, &chip_idx);\r\n} else {\r\nreturn -ENODEV;\r\n}\r\ndata->chip_info = &ltr501_chip_info_tbl[chip_idx];\r\nif ((partid >> 4) != data->chip_info->partid)\r\nreturn -ENODEV;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->info = data->chip_info->info;\r\nindio_dev->channels = data->chip_info->channels;\r\nindio_dev->num_channels = data->chip_info->no_channels;\r\nindio_dev->name = name;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = ltr501_init(data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (client->irq > 0) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, ltr501_interrupt_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"ltr501_thresh_event",\r\nindio_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "request irq (%d) failed\n",\r\nclient->irq);\r\nreturn ret;\r\n}\r\n} else {\r\nindio_dev->info = data->chip_info->info_no_irq;\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nltr501_trigger_handler, NULL);\r\nif (ret)\r\ngoto powerdown_on_error;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_unreg_buffer;\r\nreturn 0;\r\nerror_unreg_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\npowerdown_on_error:\r\nltr501_powerdown(data);\r\nreturn ret;\r\n}\r\nstatic int ltr501_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nltr501_powerdown(iio_priv(indio_dev));\r\nreturn 0;\r\n}\r\nstatic int ltr501_suspend(struct device *dev)\r\n{\r\nstruct ltr501_data *data = iio_priv(i2c_get_clientdata(\r\nto_i2c_client(dev)));\r\nreturn ltr501_powerdown(data);\r\n}\r\nstatic int ltr501_resume(struct device *dev)\r\n{\r\nstruct ltr501_data *data = iio_priv(i2c_get_clientdata(\r\nto_i2c_client(dev)));\r\nreturn ltr501_write_contr(data, data->als_contr,\r\ndata->ps_contr);\r\n}
