static int get_ifindex(const struct net_device *dev)\r\n{\r\nreturn dev ? dev->ifindex : 0;\r\n}\r\nstatic int nft_fib6_flowi_init(struct flowi6 *fl6, const struct nft_fib *priv,\r\nconst struct nft_pktinfo *pkt,\r\nconst struct net_device *dev)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(pkt->skb);\r\nint lookup_flags = 0;\r\nif (priv->flags & NFTA_FIB_F_DADDR) {\r\nfl6->daddr = iph->daddr;\r\nfl6->saddr = iph->saddr;\r\n} else {\r\nfl6->daddr = iph->saddr;\r\nfl6->saddr = iph->daddr;\r\n}\r\nif (ipv6_addr_type(&fl6->daddr) & IPV6_ADDR_LINKLOCAL) {\r\nlookup_flags |= RT6_LOOKUP_F_IFACE;\r\nfl6->flowi6_oif = get_ifindex(dev ? dev : pkt->skb->dev);\r\n}\r\nif (ipv6_addr_type(&fl6->saddr) & IPV6_ADDR_UNICAST)\r\nlookup_flags |= RT6_LOOKUP_F_HAS_SADDR;\r\nif (priv->flags & NFTA_FIB_F_MARK)\r\nfl6->flowi6_mark = pkt->skb->mark;\r\nfl6->flowlabel = (*(__be32 *)iph) & IPV6_FLOWINFO_MASK;\r\nreturn lookup_flags;\r\n}\r\nstatic u32 __nft_fib6_eval_type(const struct nft_fib *priv,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct net_device *dev = NULL;\r\nconst struct nf_ipv6_ops *v6ops;\r\nconst struct nf_afinfo *afinfo;\r\nint route_err, addrtype;\r\nstruct rt6_info *rt;\r\nstruct flowi6 fl6 = {\r\n.flowi6_iif = LOOPBACK_IFINDEX,\r\n.flowi6_proto = pkt->tprot,\r\n};\r\nu32 ret = 0;\r\nafinfo = nf_get_afinfo(NFPROTO_IPV6);\r\nif (!afinfo)\r\nreturn RTN_UNREACHABLE;\r\nif (priv->flags & NFTA_FIB_F_IIF)\r\ndev = nft_in(pkt);\r\nelse if (priv->flags & NFTA_FIB_F_OIF)\r\ndev = nft_out(pkt);\r\nnft_fib6_flowi_init(&fl6, priv, pkt, dev);\r\nv6ops = nf_get_ipv6_ops();\r\nif (dev && v6ops && v6ops->chk_addr(nft_net(pkt), &fl6.daddr, dev, true))\r\nret = RTN_LOCAL;\r\nroute_err = afinfo->route(nft_net(pkt), (struct dst_entry **)&rt,\r\nflowi6_to_flowi(&fl6), false);\r\nif (route_err)\r\ngoto err;\r\nif (rt->rt6i_flags & RTF_REJECT) {\r\nroute_err = rt->dst.error;\r\ndst_release(&rt->dst);\r\ngoto err;\r\n}\r\nif (ipv6_anycast_destination((struct dst_entry *)rt, &fl6.daddr))\r\nret = RTN_ANYCAST;\r\nelse if (!dev && rt->rt6i_flags & RTF_LOCAL)\r\nret = RTN_LOCAL;\r\ndst_release(&rt->dst);\r\nif (ret)\r\nreturn ret;\r\naddrtype = ipv6_addr_type(&fl6.daddr);\r\nif (addrtype & IPV6_ADDR_MULTICAST)\r\nreturn RTN_MULTICAST;\r\nif (addrtype & IPV6_ADDR_UNICAST)\r\nreturn RTN_UNICAST;\r\nreturn RTN_UNSPEC;\r\nerr:\r\nswitch (route_err) {\r\ncase -EINVAL:\r\nreturn RTN_BLACKHOLE;\r\ncase -EACCES:\r\nreturn RTN_PROHIBIT;\r\ncase -EAGAIN:\r\nreturn RTN_THROW;\r\ndefault:\r\nbreak;\r\n}\r\nreturn RTN_UNREACHABLE;\r\n}\r\nvoid nft_fib6_eval_type(const struct nft_expr *expr, struct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nu32 *dest = &regs->data[priv->dreg];\r\n*dest = __nft_fib6_eval_type(priv, pkt);\r\n}\r\nvoid nft_fib6_eval(const struct nft_expr *expr, struct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nconst struct net_device *oif = NULL;\r\nu32 *dest = &regs->data[priv->dreg];\r\nstruct flowi6 fl6 = {\r\n.flowi6_iif = LOOPBACK_IFINDEX,\r\n.flowi6_proto = pkt->tprot,\r\n};\r\nstruct rt6_info *rt;\r\nint lookup_flags;\r\nif (priv->flags & NFTA_FIB_F_IIF)\r\noif = nft_in(pkt);\r\nelse if (priv->flags & NFTA_FIB_F_OIF)\r\noif = nft_out(pkt);\r\nlookup_flags = nft_fib6_flowi_init(&fl6, priv, pkt, oif);\r\nif (nft_hook(pkt) == NF_INET_PRE_ROUTING &&\r\nnft_fib_is_loopback(pkt->skb, nft_in(pkt))) {\r\nnft_fib_store_result(dest, priv->result, pkt,\r\nnft_in(pkt)->ifindex);\r\nreturn;\r\n}\r\n*dest = 0;\r\nagain:\r\nrt = (void *)ip6_route_lookup(nft_net(pkt), &fl6, lookup_flags);\r\nif (rt->dst.error)\r\ngoto put_rt_err;\r\nif (rt->rt6i_flags & (RTF_REJECT | RTF_ANYCAST | RTF_LOCAL))\r\ngoto put_rt_err;\r\nif (oif && oif != rt->rt6i_idev->dev) {\r\nif ((lookup_flags & RT6_LOOKUP_F_IFACE) == 0) {\r\nlookup_flags |= RT6_LOOKUP_F_IFACE;\r\nfl6.flowi6_oif = oif->ifindex;\r\nip6_rt_put(rt);\r\ngoto again;\r\n}\r\n}\r\nswitch (priv->result) {\r\ncase NFT_FIB_RESULT_OIF:\r\n*dest = rt->rt6i_idev->dev->ifindex;\r\nbreak;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nstrncpy((char *)dest, rt->rt6i_idev->dev->name, IFNAMSIZ);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\nput_rt_err:\r\nip6_rt_put(rt);\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_fib6_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_fib_result result;\r\nif (!tb[NFTA_FIB_RESULT])\r\nreturn ERR_PTR(-EINVAL);\r\nresult = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\r\nswitch (result) {\r\ncase NFT_FIB_RESULT_OIF:\r\nreturn &nft_fib6_ops;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nreturn &nft_fib6_ops;\r\ncase NFT_FIB_RESULT_ADDRTYPE:\r\nreturn &nft_fib6_type_ops;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\n}\r\nstatic int __init nft_fib6_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_fib6_type);\r\n}\r\nstatic void __exit nft_fib6_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_fib6_type);\r\n}
