static struct brcmf_msgbuf_pktids *\r\nbrcmf_msgbuf_init_pktids(u32 nr_array_entries,\r\nenum dma_data_direction direction)\r\n{\r\nstruct brcmf_msgbuf_pktid *array;\r\nstruct brcmf_msgbuf_pktids *pktids;\r\narray = kcalloc(nr_array_entries, sizeof(*array), GFP_KERNEL);\r\nif (!array)\r\nreturn NULL;\r\npktids = kzalloc(sizeof(*pktids), GFP_KERNEL);\r\nif (!pktids) {\r\nkfree(array);\r\nreturn NULL;\r\n}\r\npktids->array = array;\r\npktids->array_size = nr_array_entries;\r\nreturn pktids;\r\n}\r\nstatic int\r\nbrcmf_msgbuf_alloc_pktid(struct device *dev,\r\nstruct brcmf_msgbuf_pktids *pktids,\r\nstruct sk_buff *skb, u16 data_offset,\r\ndma_addr_t *physaddr, u32 *idx)\r\n{\r\nstruct brcmf_msgbuf_pktid *array;\r\nu32 count;\r\narray = pktids->array;\r\n*physaddr = dma_map_single(dev, skb->data + data_offset,\r\nskb->len - data_offset, pktids->direction);\r\nif (dma_mapping_error(dev, *physaddr)) {\r\nbrcmf_err("dma_map_single failed !!\n");\r\nreturn -ENOMEM;\r\n}\r\n*idx = pktids->last_allocated_idx;\r\ncount = 0;\r\ndo {\r\n(*idx)++;\r\nif (*idx == pktids->array_size)\r\n*idx = 0;\r\nif (array[*idx].allocated.counter == 0)\r\nif (atomic_cmpxchg(&array[*idx].allocated, 0, 1) == 0)\r\nbreak;\r\ncount++;\r\n} while (count < pktids->array_size);\r\nif (count == pktids->array_size)\r\nreturn -ENOMEM;\r\narray[*idx].data_offset = data_offset;\r\narray[*idx].physaddr = *physaddr;\r\narray[*idx].skb = skb;\r\npktids->last_allocated_idx = *idx;\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *\r\nbrcmf_msgbuf_get_pktid(struct device *dev, struct brcmf_msgbuf_pktids *pktids,\r\nu32 idx)\r\n{\r\nstruct brcmf_msgbuf_pktid *pktid;\r\nstruct sk_buff *skb;\r\nif (idx >= pktids->array_size) {\r\nbrcmf_err("Invalid packet id %d (max %d)\n", idx,\r\npktids->array_size);\r\nreturn NULL;\r\n}\r\nif (pktids->array[idx].allocated.counter) {\r\npktid = &pktids->array[idx];\r\ndma_unmap_single(dev, pktid->physaddr,\r\npktid->skb->len - pktid->data_offset,\r\npktids->direction);\r\nskb = pktid->skb;\r\npktid->allocated.counter = 0;\r\nreturn skb;\r\n} else {\r\nbrcmf_err("Invalid packet id %d (not in use)\n", idx);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nbrcmf_msgbuf_release_array(struct device *dev,\r\nstruct brcmf_msgbuf_pktids *pktids)\r\n{\r\nstruct brcmf_msgbuf_pktid *array;\r\nstruct brcmf_msgbuf_pktid *pktid;\r\nu32 count;\r\narray = pktids->array;\r\ncount = 0;\r\ndo {\r\nif (array[count].allocated.counter) {\r\npktid = &array[count];\r\ndma_unmap_single(dev, pktid->physaddr,\r\npktid->skb->len - pktid->data_offset,\r\npktids->direction);\r\nbrcmu_pkt_buf_free_skb(pktid->skb);\r\n}\r\ncount++;\r\n} while (count < pktids->array_size);\r\nkfree(array);\r\nkfree(pktids);\r\n}\r\nstatic void brcmf_msgbuf_release_pktids(struct brcmf_msgbuf *msgbuf)\r\n{\r\nif (msgbuf->rx_pktids)\r\nbrcmf_msgbuf_release_array(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids);\r\nif (msgbuf->tx_pktids)\r\nbrcmf_msgbuf_release_array(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->tx_pktids);\r\n}\r\nstatic int brcmf_msgbuf_tx_ioctl(struct brcmf_pub *drvr, int ifidx,\r\nuint cmd, void *buf, uint len)\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct brcmf_commonring *commonring;\r\nstruct msgbuf_ioctl_req_hdr *request;\r\nu16 buf_len;\r\nvoid *ret_ptr;\r\nint err;\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\r\nbrcmf_commonring_lock(commonring);\r\nret_ptr = brcmf_commonring_reserve_for_write(commonring);\r\nif (!ret_ptr) {\r\nbrcmf_err("Failed to reserve space in commonring\n");\r\nbrcmf_commonring_unlock(commonring);\r\nreturn -ENOMEM;\r\n}\r\nmsgbuf->reqid++;\r\nrequest = (struct msgbuf_ioctl_req_hdr *)ret_ptr;\r\nrequest->msg.msgtype = MSGBUF_TYPE_IOCTLPTR_REQ;\r\nrequest->msg.ifidx = (u8)ifidx;\r\nrequest->msg.flags = 0;\r\nrequest->msg.request_id = cpu_to_le32(BRCMF_IOCTL_REQ_PKTID);\r\nrequest->cmd = cpu_to_le32(cmd);\r\nrequest->output_buf_len = cpu_to_le16(len);\r\nrequest->trans_id = cpu_to_le16(msgbuf->reqid);\r\nbuf_len = min_t(u16, len, BRCMF_TX_IOCTL_MAX_MSG_SIZE);\r\nrequest->input_buf_len = cpu_to_le16(buf_len);\r\nrequest->req_buf_addr.high_addr = cpu_to_le32(msgbuf->ioctbuf_phys_hi);\r\nrequest->req_buf_addr.low_addr = cpu_to_le32(msgbuf->ioctbuf_phys_lo);\r\nif (buf)\r\nmemcpy(msgbuf->ioctbuf, buf, buf_len);\r\nelse\r\nmemset(msgbuf->ioctbuf, 0, buf_len);\r\nerr = brcmf_commonring_write_complete(commonring);\r\nbrcmf_commonring_unlock(commonring);\r\nreturn err;\r\n}\r\nstatic int brcmf_msgbuf_ioctl_resp_wait(struct brcmf_msgbuf *msgbuf)\r\n{\r\nreturn wait_event_timeout(msgbuf->ioctl_resp_wait,\r\nmsgbuf->ctl_completed,\r\nMSGBUF_IOCTL_RESP_TIMEOUT);\r\n}\r\nstatic void brcmf_msgbuf_ioctl_resp_wake(struct brcmf_msgbuf *msgbuf)\r\n{\r\nmsgbuf->ctl_completed = true;\r\nwake_up(&msgbuf->ioctl_resp_wait);\r\n}\r\nstatic int brcmf_msgbuf_query_dcmd(struct brcmf_pub *drvr, int ifidx,\r\nuint cmd, void *buf, uint len)\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct sk_buff *skb = NULL;\r\nint timeout;\r\nint err;\r\nbrcmf_dbg(MSGBUF, "ifidx=%d, cmd=%d, len=%d\n", ifidx, cmd, len);\r\nmsgbuf->ctl_completed = false;\r\nerr = brcmf_msgbuf_tx_ioctl(drvr, ifidx, cmd, buf, len);\r\nif (err)\r\nreturn err;\r\ntimeout = brcmf_msgbuf_ioctl_resp_wait(msgbuf);\r\nif (!timeout) {\r\nbrcmf_err("Timeout on response for query command\n");\r\nreturn -EIO;\r\n}\r\nskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids,\r\nmsgbuf->ioctl_resp_pktid);\r\nif (msgbuf->ioctl_resp_ret_len != 0) {\r\nif (!skb)\r\nreturn -EBADF;\r\nmemcpy(buf, skb->data, (len < msgbuf->ioctl_resp_ret_len) ?\r\nlen : msgbuf->ioctl_resp_ret_len);\r\n}\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn msgbuf->ioctl_resp_status;\r\n}\r\nstatic int brcmf_msgbuf_set_dcmd(struct brcmf_pub *drvr, int ifidx,\r\nuint cmd, void *buf, uint len)\r\n{\r\nreturn brcmf_msgbuf_query_dcmd(drvr, ifidx, cmd, buf, len);\r\n}\r\nstatic int brcmf_msgbuf_hdrpull(struct brcmf_pub *drvr, bool do_fws,\r\nstruct sk_buff *skb, struct brcmf_if **ifp)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void brcmf_msgbuf_rxreorder(struct brcmf_if *ifp, struct sk_buff *skb)\r\n{\r\n}\r\nstatic void\r\nbrcmf_msgbuf_remove_flowring(struct brcmf_msgbuf *msgbuf, u16 flowid)\r\n{\r\nu32 dma_sz;\r\nvoid *dma_buf;\r\nbrcmf_dbg(MSGBUF, "Removing flowring %d\n", flowid);\r\ndma_sz = BRCMF_H2D_TXFLOWRING_MAX_ITEM * BRCMF_H2D_TXFLOWRING_ITEMSIZE;\r\ndma_buf = msgbuf->flowrings[flowid]->buf_addr;\r\ndma_free_coherent(msgbuf->drvr->bus_if->dev, dma_sz, dma_buf,\r\nmsgbuf->flowring_dma_handle[flowid]);\r\nbrcmf_flowring_delete(msgbuf->flow, flowid);\r\n}\r\nstatic struct brcmf_msgbuf_work_item *\r\nbrcmf_msgbuf_dequeue_work(struct brcmf_msgbuf *msgbuf)\r\n{\r\nstruct brcmf_msgbuf_work_item *work = NULL;\r\nulong flags;\r\nspin_lock_irqsave(&msgbuf->flowring_work_lock, flags);\r\nif (!list_empty(&msgbuf->work_queue)) {\r\nwork = list_first_entry(&msgbuf->work_queue,\r\nstruct brcmf_msgbuf_work_item, queue);\r\nlist_del(&work->queue);\r\n}\r\nspin_unlock_irqrestore(&msgbuf->flowring_work_lock, flags);\r\nreturn work;\r\n}\r\nstatic u32\r\nbrcmf_msgbuf_flowring_create_worker(struct brcmf_msgbuf *msgbuf,\r\nstruct brcmf_msgbuf_work_item *work)\r\n{\r\nstruct msgbuf_tx_flowring_create_req *create;\r\nstruct brcmf_commonring *commonring;\r\nvoid *ret_ptr;\r\nu32 flowid;\r\nvoid *dma_buf;\r\nu32 dma_sz;\r\nu64 address;\r\nint err;\r\nflowid = work->flowid;\r\ndma_sz = BRCMF_H2D_TXFLOWRING_MAX_ITEM * BRCMF_H2D_TXFLOWRING_ITEMSIZE;\r\ndma_buf = dma_alloc_coherent(msgbuf->drvr->bus_if->dev, dma_sz,\r\n&msgbuf->flowring_dma_handle[flowid],\r\nGFP_KERNEL);\r\nif (!dma_buf) {\r\nbrcmf_err("dma_alloc_coherent failed\n");\r\nbrcmf_flowring_delete(msgbuf->flow, flowid);\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\n}\r\nbrcmf_commonring_config(msgbuf->flowrings[flowid],\r\nBRCMF_H2D_TXFLOWRING_MAX_ITEM,\r\nBRCMF_H2D_TXFLOWRING_ITEMSIZE, dma_buf);\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\r\nbrcmf_commonring_lock(commonring);\r\nret_ptr = brcmf_commonring_reserve_for_write(commonring);\r\nif (!ret_ptr) {\r\nbrcmf_err("Failed to reserve space in commonring\n");\r\nbrcmf_commonring_unlock(commonring);\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\n}\r\ncreate = (struct msgbuf_tx_flowring_create_req *)ret_ptr;\r\ncreate->msg.msgtype = MSGBUF_TYPE_FLOW_RING_CREATE;\r\ncreate->msg.ifidx = work->ifidx;\r\ncreate->msg.request_id = 0;\r\ncreate->tid = brcmf_flowring_tid(msgbuf->flow, flowid);\r\ncreate->flow_ring_id = cpu_to_le16(flowid +\r\nBRCMF_H2D_MSGRING_FLOWRING_IDSTART);\r\nmemcpy(create->sa, work->sa, ETH_ALEN);\r\nmemcpy(create->da, work->da, ETH_ALEN);\r\naddress = (u64)msgbuf->flowring_dma_handle[flowid];\r\ncreate->flow_ring_addr.high_addr = cpu_to_le32(address >> 32);\r\ncreate->flow_ring_addr.low_addr = cpu_to_le32(address & 0xffffffff);\r\ncreate->max_items = cpu_to_le16(BRCMF_H2D_TXFLOWRING_MAX_ITEM);\r\ncreate->len_item = cpu_to_le16(BRCMF_H2D_TXFLOWRING_ITEMSIZE);\r\nbrcmf_dbg(MSGBUF, "Send Flow Create Req flow ID %d for peer %pM prio %d ifindex %d\n",\r\nflowid, work->da, create->tid, work->ifidx);\r\nerr = brcmf_commonring_write_complete(commonring);\r\nbrcmf_commonring_unlock(commonring);\r\nif (err) {\r\nbrcmf_err("Failed to write commonring\n");\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\n}\r\nreturn flowid;\r\n}\r\nstatic void brcmf_msgbuf_flowring_worker(struct work_struct *work)\r\n{\r\nstruct brcmf_msgbuf *msgbuf;\r\nstruct brcmf_msgbuf_work_item *create;\r\nmsgbuf = container_of(work, struct brcmf_msgbuf, flowring_work);\r\nwhile ((create = brcmf_msgbuf_dequeue_work(msgbuf))) {\r\nbrcmf_msgbuf_flowring_create_worker(msgbuf, create);\r\nkfree(create);\r\n}\r\n}\r\nstatic u32 brcmf_msgbuf_flowring_create(struct brcmf_msgbuf *msgbuf, int ifidx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_msgbuf_work_item *create;\r\nstruct ethhdr *eh = (struct ethhdr *)(skb->data);\r\nu32 flowid;\r\nulong flags;\r\ncreate = kzalloc(sizeof(*create), GFP_ATOMIC);\r\nif (create == NULL)\r\nreturn BRCMF_FLOWRING_INVALID_ID;\r\nflowid = brcmf_flowring_create(msgbuf->flow, eh->h_dest,\r\nskb->priority, ifidx);\r\nif (flowid == BRCMF_FLOWRING_INVALID_ID) {\r\nkfree(create);\r\nreturn flowid;\r\n}\r\ncreate->flowid = flowid;\r\ncreate->ifidx = ifidx;\r\nmemcpy(create->sa, eh->h_source, ETH_ALEN);\r\nmemcpy(create->da, eh->h_dest, ETH_ALEN);\r\nspin_lock_irqsave(&msgbuf->flowring_work_lock, flags);\r\nlist_add_tail(&create->queue, &msgbuf->work_queue);\r\nspin_unlock_irqrestore(&msgbuf->flowring_work_lock, flags);\r\nschedule_work(&msgbuf->flowring_work);\r\nreturn flowid;\r\n}\r\nstatic void brcmf_msgbuf_txflow(struct brcmf_msgbuf *msgbuf, u16 flowid)\r\n{\r\nstruct brcmf_flowring *flow = msgbuf->flow;\r\nstruct brcmf_commonring *commonring;\r\nvoid *ret_ptr;\r\nu32 count;\r\nstruct sk_buff *skb;\r\ndma_addr_t physaddr;\r\nu32 pktid;\r\nstruct msgbuf_tx_msghdr *tx_msghdr;\r\nu64 address;\r\ncommonring = msgbuf->flowrings[flowid];\r\nif (!brcmf_commonring_write_available(commonring))\r\nreturn;\r\nbrcmf_commonring_lock(commonring);\r\ncount = BRCMF_MSGBUF_TX_FLUSH_CNT2 - BRCMF_MSGBUF_TX_FLUSH_CNT1;\r\nwhile (brcmf_flowring_qlen(flow, flowid)) {\r\nskb = brcmf_flowring_dequeue(flow, flowid);\r\nif (skb == NULL) {\r\nbrcmf_err("No SKB, but qlen %d\n",\r\nbrcmf_flowring_qlen(flow, flowid));\r\nbreak;\r\n}\r\nskb_orphan(skb);\r\nif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->tx_pktids, skb, ETH_HLEN,\r\n&physaddr, &pktid)) {\r\nbrcmf_flowring_reinsert(flow, flowid, skb);\r\nbrcmf_err("No PKTID available !!\n");\r\nbreak;\r\n}\r\nret_ptr = brcmf_commonring_reserve_for_write(commonring);\r\nif (!ret_ptr) {\r\nbrcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->tx_pktids, pktid);\r\nbrcmf_flowring_reinsert(flow, flowid, skb);\r\nbreak;\r\n}\r\ncount++;\r\ntx_msghdr = (struct msgbuf_tx_msghdr *)ret_ptr;\r\ntx_msghdr->msg.msgtype = MSGBUF_TYPE_TX_POST;\r\ntx_msghdr->msg.request_id = cpu_to_le32(pktid);\r\ntx_msghdr->msg.ifidx = brcmf_flowring_ifidx_get(flow, flowid);\r\ntx_msghdr->flags = BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_3;\r\ntx_msghdr->flags |= (skb->priority & 0x07) <<\r\nBRCMF_MSGBUF_PKT_FLAGS_PRIO_SHIFT;\r\ntx_msghdr->seg_cnt = 1;\r\nmemcpy(tx_msghdr->txhdr, skb->data, ETH_HLEN);\r\ntx_msghdr->data_len = cpu_to_le16(skb->len - ETH_HLEN);\r\naddress = (u64)physaddr;\r\ntx_msghdr->data_buf_addr.high_addr = cpu_to_le32(address >> 32);\r\ntx_msghdr->data_buf_addr.low_addr =\r\ncpu_to_le32(address & 0xffffffff);\r\ntx_msghdr->metadata_buf_len = 0;\r\ntx_msghdr->metadata_buf_addr.high_addr = 0;\r\ntx_msghdr->metadata_buf_addr.low_addr = 0;\r\natomic_inc(&commonring->outstanding_tx);\r\nif (count >= BRCMF_MSGBUF_TX_FLUSH_CNT2) {\r\nbrcmf_commonring_write_complete(commonring);\r\ncount = 0;\r\n}\r\n}\r\nif (count)\r\nbrcmf_commonring_write_complete(commonring);\r\nbrcmf_commonring_unlock(commonring);\r\n}\r\nstatic void brcmf_msgbuf_txflow_worker(struct work_struct *worker)\r\n{\r\nstruct brcmf_msgbuf *msgbuf;\r\nu32 flowid;\r\nmsgbuf = container_of(worker, struct brcmf_msgbuf, txflow_work);\r\nfor_each_set_bit(flowid, msgbuf->flow_map, msgbuf->max_flowrings) {\r\nclear_bit(flowid, msgbuf->flow_map);\r\nbrcmf_msgbuf_txflow(msgbuf, flowid);\r\n}\r\n}\r\nstatic int brcmf_msgbuf_schedule_txdata(struct brcmf_msgbuf *msgbuf, u32 flowid,\r\nbool force)\r\n{\r\nstruct brcmf_commonring *commonring;\r\nset_bit(flowid, msgbuf->flow_map);\r\ncommonring = msgbuf->flowrings[flowid];\r\nif ((force) || (atomic_read(&commonring->outstanding_tx) <\r\nBRCMF_MSGBUF_DELAY_TXWORKER_THRS))\r\nqueue_work(msgbuf->txflow_wq, &msgbuf->txflow_work);\r\nreturn 0;\r\n}\r\nstatic int brcmf_msgbuf_tx_queue_data(struct brcmf_pub *drvr, int ifidx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct brcmf_flowring *flow = msgbuf->flow;\r\nstruct ethhdr *eh = (struct ethhdr *)(skb->data);\r\nu32 flowid;\r\nu32 queue_count;\r\nbool force;\r\nflowid = brcmf_flowring_lookup(flow, eh->h_dest, skb->priority, ifidx);\r\nif (flowid == BRCMF_FLOWRING_INVALID_ID) {\r\nflowid = brcmf_msgbuf_flowring_create(msgbuf, ifidx, skb);\r\nif (flowid == BRCMF_FLOWRING_INVALID_ID)\r\nreturn -ENOMEM;\r\n}\r\nqueue_count = brcmf_flowring_enqueue(flow, flowid, skb);\r\nforce = ((queue_count % BRCMF_MSGBUF_TRICKLE_TXWORKER_THRS) == 0);\r\nbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, force);\r\nreturn 0;\r\n}\r\nstatic void\r\nbrcmf_msgbuf_configure_addr_mode(struct brcmf_pub *drvr, int ifidx,\r\nenum proto_addr_mode addr_mode)\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nbrcmf_flowring_configure_addr_mode(msgbuf->flow, ifidx, addr_mode);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_delete_peer(struct brcmf_pub *drvr, int ifidx, u8 peer[ETH_ALEN])\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nbrcmf_flowring_delete_peer(msgbuf->flow, ifidx, peer);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_add_tdls_peer(struct brcmf_pub *drvr, int ifidx, u8 peer[ETH_ALEN])\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nbrcmf_flowring_add_tdls_peer(msgbuf->flow, ifidx, peer);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_process_ioctl_complete(struct brcmf_msgbuf *msgbuf, void *buf)\r\n{\r\nstruct msgbuf_ioctl_resp_hdr *ioctl_resp;\r\nioctl_resp = (struct msgbuf_ioctl_resp_hdr *)buf;\r\nmsgbuf->ioctl_resp_status =\r\n(s16)le16_to_cpu(ioctl_resp->compl_hdr.status);\r\nmsgbuf->ioctl_resp_ret_len = le16_to_cpu(ioctl_resp->resp_len);\r\nmsgbuf->ioctl_resp_pktid = le32_to_cpu(ioctl_resp->msg.request_id);\r\nbrcmf_msgbuf_ioctl_resp_wake(msgbuf);\r\nif (msgbuf->cur_ioctlrespbuf)\r\nmsgbuf->cur_ioctlrespbuf--;\r\nbrcmf_msgbuf_rxbuf_ioctlresp_post(msgbuf);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_process_txstatus(struct brcmf_msgbuf *msgbuf, void *buf)\r\n{\r\nstruct brcmf_commonring *commonring;\r\nstruct msgbuf_tx_status *tx_status;\r\nu32 idx;\r\nstruct sk_buff *skb;\r\nu16 flowid;\r\ntx_status = (struct msgbuf_tx_status *)buf;\r\nidx = le32_to_cpu(tx_status->msg.request_id);\r\nflowid = le16_to_cpu(tx_status->compl_hdr.flow_ring_id);\r\nflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\r\nskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->tx_pktids, idx);\r\nif (!skb)\r\nreturn;\r\nset_bit(flowid, msgbuf->txstatus_done_map);\r\ncommonring = msgbuf->flowrings[flowid];\r\natomic_dec(&commonring->outstanding_tx);\r\nbrcmf_txfinalize(brcmf_get_ifp(msgbuf->drvr, tx_status->msg.ifidx),\r\nskb, true);\r\n}\r\nstatic u32 brcmf_msgbuf_rxbuf_data_post(struct brcmf_msgbuf *msgbuf, u32 count)\r\n{\r\nstruct brcmf_commonring *commonring;\r\nvoid *ret_ptr;\r\nstruct sk_buff *skb;\r\nu16 alloced;\r\nu32 pktlen;\r\ndma_addr_t physaddr;\r\nstruct msgbuf_rx_bufpost *rx_bufpost;\r\nu64 address;\r\nu32 pktid;\r\nu32 i;\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_RXPOST_SUBMIT];\r\nret_ptr = brcmf_commonring_reserve_for_write_multiple(commonring,\r\ncount,\r\n&alloced);\r\nif (!ret_ptr) {\r\nbrcmf_dbg(MSGBUF, "Failed to reserve space in commonring\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < alloced; i++) {\r\nrx_bufpost = (struct msgbuf_rx_bufpost *)ret_ptr;\r\nmemset(rx_bufpost, 0, sizeof(*rx_bufpost));\r\nskb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_PKT_SIZE);\r\nif (skb == NULL) {\r\nbrcmf_err("Failed to alloc SKB\n");\r\nbrcmf_commonring_write_cancel(commonring, alloced - i);\r\nbreak;\r\n}\r\npktlen = skb->len;\r\nif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids, skb, 0,\r\n&physaddr, &pktid)) {\r\ndev_kfree_skb_any(skb);\r\nbrcmf_err("No PKTID available !!\n");\r\nbrcmf_commonring_write_cancel(commonring, alloced - i);\r\nbreak;\r\n}\r\nif (msgbuf->rx_metadata_offset) {\r\naddress = (u64)physaddr;\r\nrx_bufpost->metadata_buf_len =\r\ncpu_to_le16(msgbuf->rx_metadata_offset);\r\nrx_bufpost->metadata_buf_addr.high_addr =\r\ncpu_to_le32(address >> 32);\r\nrx_bufpost->metadata_buf_addr.low_addr =\r\ncpu_to_le32(address & 0xffffffff);\r\nskb_pull(skb, msgbuf->rx_metadata_offset);\r\npktlen = skb->len;\r\nphysaddr += msgbuf->rx_metadata_offset;\r\n}\r\nrx_bufpost->msg.msgtype = MSGBUF_TYPE_RXBUF_POST;\r\nrx_bufpost->msg.request_id = cpu_to_le32(pktid);\r\naddress = (u64)physaddr;\r\nrx_bufpost->data_buf_len = cpu_to_le16((u16)pktlen);\r\nrx_bufpost->data_buf_addr.high_addr =\r\ncpu_to_le32(address >> 32);\r\nrx_bufpost->data_buf_addr.low_addr =\r\ncpu_to_le32(address & 0xffffffff);\r\nret_ptr += brcmf_commonring_len_item(commonring);\r\n}\r\nif (i)\r\nbrcmf_commonring_write_complete(commonring);\r\nreturn i;\r\n}\r\nstatic void\r\nbrcmf_msgbuf_rxbuf_data_fill(struct brcmf_msgbuf *msgbuf)\r\n{\r\nu32 fillbufs;\r\nu32 retcount;\r\nfillbufs = msgbuf->max_rxbufpost - msgbuf->rxbufpost;\r\nwhile (fillbufs) {\r\nretcount = brcmf_msgbuf_rxbuf_data_post(msgbuf, fillbufs);\r\nif (!retcount)\r\nbreak;\r\nmsgbuf->rxbufpost += retcount;\r\nfillbufs -= retcount;\r\n}\r\n}\r\nstatic void\r\nbrcmf_msgbuf_update_rxbufpost_count(struct brcmf_msgbuf *msgbuf, u16 rxcnt)\r\n{\r\nmsgbuf->rxbufpost -= rxcnt;\r\nif (msgbuf->rxbufpost <= (msgbuf->max_rxbufpost -\r\nBRCMF_MSGBUF_RXBUFPOST_THRESHOLD))\r\nbrcmf_msgbuf_rxbuf_data_fill(msgbuf);\r\n}\r\nstatic u32\r\nbrcmf_msgbuf_rxbuf_ctrl_post(struct brcmf_msgbuf *msgbuf, bool event_buf,\r\nu32 count)\r\n{\r\nstruct brcmf_commonring *commonring;\r\nvoid *ret_ptr;\r\nstruct sk_buff *skb;\r\nu16 alloced;\r\nu32 pktlen;\r\ndma_addr_t physaddr;\r\nstruct msgbuf_rx_ioctl_resp_or_event *rx_bufpost;\r\nu64 address;\r\nu32 pktid;\r\nu32 i;\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\r\nbrcmf_commonring_lock(commonring);\r\nret_ptr = brcmf_commonring_reserve_for_write_multiple(commonring,\r\ncount,\r\n&alloced);\r\nif (!ret_ptr) {\r\nbrcmf_err("Failed to reserve space in commonring\n");\r\nbrcmf_commonring_unlock(commonring);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < alloced; i++) {\r\nrx_bufpost = (struct msgbuf_rx_ioctl_resp_or_event *)ret_ptr;\r\nmemset(rx_bufpost, 0, sizeof(*rx_bufpost));\r\nskb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_PKT_SIZE);\r\nif (skb == NULL) {\r\nbrcmf_err("Failed to alloc SKB\n");\r\nbrcmf_commonring_write_cancel(commonring, alloced - i);\r\nbreak;\r\n}\r\npktlen = skb->len;\r\nif (brcmf_msgbuf_alloc_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids, skb, 0,\r\n&physaddr, &pktid)) {\r\ndev_kfree_skb_any(skb);\r\nbrcmf_err("No PKTID available !!\n");\r\nbrcmf_commonring_write_cancel(commonring, alloced - i);\r\nbreak;\r\n}\r\nif (event_buf)\r\nrx_bufpost->msg.msgtype = MSGBUF_TYPE_EVENT_BUF_POST;\r\nelse\r\nrx_bufpost->msg.msgtype =\r\nMSGBUF_TYPE_IOCTLRESP_BUF_POST;\r\nrx_bufpost->msg.request_id = cpu_to_le32(pktid);\r\naddress = (u64)physaddr;\r\nrx_bufpost->host_buf_len = cpu_to_le16((u16)pktlen);\r\nrx_bufpost->host_buf_addr.high_addr =\r\ncpu_to_le32(address >> 32);\r\nrx_bufpost->host_buf_addr.low_addr =\r\ncpu_to_le32(address & 0xffffffff);\r\nret_ptr += brcmf_commonring_len_item(commonring);\r\n}\r\nif (i)\r\nbrcmf_commonring_write_complete(commonring);\r\nbrcmf_commonring_unlock(commonring);\r\nreturn i;\r\n}\r\nstatic void brcmf_msgbuf_rxbuf_ioctlresp_post(struct brcmf_msgbuf *msgbuf)\r\n{\r\nu32 count;\r\ncount = msgbuf->max_ioctlrespbuf - msgbuf->cur_ioctlrespbuf;\r\ncount = brcmf_msgbuf_rxbuf_ctrl_post(msgbuf, false, count);\r\nmsgbuf->cur_ioctlrespbuf += count;\r\n}\r\nstatic void brcmf_msgbuf_rxbuf_event_post(struct brcmf_msgbuf *msgbuf)\r\n{\r\nu32 count;\r\ncount = msgbuf->max_eventbuf - msgbuf->cur_eventbuf;\r\ncount = brcmf_msgbuf_rxbuf_ctrl_post(msgbuf, true, count);\r\nmsgbuf->cur_eventbuf += count;\r\n}\r\nstatic void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)\r\n{\r\nstruct msgbuf_rx_event *event;\r\nu32 idx;\r\nu16 buflen;\r\nstruct sk_buff *skb;\r\nstruct brcmf_if *ifp;\r\nevent = (struct msgbuf_rx_event *)buf;\r\nidx = le32_to_cpu(event->msg.request_id);\r\nbuflen = le16_to_cpu(event->event_data_len);\r\nif (msgbuf->cur_eventbuf)\r\nmsgbuf->cur_eventbuf--;\r\nbrcmf_msgbuf_rxbuf_event_post(msgbuf);\r\nskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids, idx);\r\nif (!skb)\r\nreturn;\r\nif (msgbuf->rx_dataoffset)\r\nskb_pull(skb, msgbuf->rx_dataoffset);\r\nskb_trim(skb, buflen);\r\nifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);\r\nif (!ifp || !ifp->ndev) {\r\nbrcmf_err("Received pkt for invalid ifidx %d\n",\r\nevent->msg.ifidx);\r\ngoto exit;\r\n}\r\nskb->protocol = eth_type_trans(skb, ifp->ndev);\r\nbrcmf_fweh_process_skb(ifp->drvr, skb);\r\nexit:\r\nbrcmu_pkt_buf_free_skb(skb);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_process_rx_complete(struct brcmf_msgbuf *msgbuf, void *buf)\r\n{\r\nstruct msgbuf_rx_complete *rx_complete;\r\nstruct sk_buff *skb;\r\nu16 data_offset;\r\nu16 buflen;\r\nu32 idx;\r\nstruct brcmf_if *ifp;\r\nbrcmf_msgbuf_update_rxbufpost_count(msgbuf, 1);\r\nrx_complete = (struct msgbuf_rx_complete *)buf;\r\ndata_offset = le16_to_cpu(rx_complete->data_offset);\r\nbuflen = le16_to_cpu(rx_complete->data_len);\r\nidx = le32_to_cpu(rx_complete->msg.request_id);\r\nskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\r\nmsgbuf->rx_pktids, idx);\r\nif (!skb)\r\nreturn;\r\nif (data_offset)\r\nskb_pull(skb, data_offset);\r\nelse if (msgbuf->rx_dataoffset)\r\nskb_pull(skb, msgbuf->rx_dataoffset);\r\nskb_trim(skb, buflen);\r\nifp = brcmf_get_ifp(msgbuf->drvr, rx_complete->msg.ifidx);\r\nif (!ifp || !ifp->ndev) {\r\nbrcmf_err("Received pkt for invalid ifidx %d\n",\r\nrx_complete->msg.ifidx);\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn;\r\n}\r\nskb->protocol = eth_type_trans(skb, ifp->ndev);\r\nbrcmf_netif_rx(ifp, skb);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_process_flow_ring_create_response(struct brcmf_msgbuf *msgbuf,\r\nvoid *buf)\r\n{\r\nstruct msgbuf_flowring_create_resp *flowring_create_resp;\r\nu16 status;\r\nu16 flowid;\r\nflowring_create_resp = (struct msgbuf_flowring_create_resp *)buf;\r\nflowid = le16_to_cpu(flowring_create_resp->compl_hdr.flow_ring_id);\r\nflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\r\nstatus = le16_to_cpu(flowring_create_resp->compl_hdr.status);\r\nif (status) {\r\nbrcmf_err("Flowring creation failed, code %d\n", status);\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\nreturn;\r\n}\r\nbrcmf_dbg(MSGBUF, "Flowring %d Create response status %d\n", flowid,\r\nstatus);\r\nbrcmf_flowring_open(msgbuf->flow, flowid);\r\nbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, true);\r\n}\r\nstatic void\r\nbrcmf_msgbuf_process_flow_ring_delete_response(struct brcmf_msgbuf *msgbuf,\r\nvoid *buf)\r\n{\r\nstruct msgbuf_flowring_delete_resp *flowring_delete_resp;\r\nu16 status;\r\nu16 flowid;\r\nflowring_delete_resp = (struct msgbuf_flowring_delete_resp *)buf;\r\nflowid = le16_to_cpu(flowring_delete_resp->compl_hdr.flow_ring_id);\r\nflowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;\r\nstatus = le16_to_cpu(flowring_delete_resp->compl_hdr.status);\r\nif (status) {\r\nbrcmf_err("Flowring deletion failed, code %d\n", status);\r\nbrcmf_flowring_delete(msgbuf->flow, flowid);\r\nreturn;\r\n}\r\nbrcmf_dbg(MSGBUF, "Flowring %d Delete response status %d\n", flowid,\r\nstatus);\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\n}\r\nstatic void brcmf_msgbuf_process_msgtype(struct brcmf_msgbuf *msgbuf, void *buf)\r\n{\r\nstruct msgbuf_common_hdr *msg;\r\nmsg = (struct msgbuf_common_hdr *)buf;\r\nswitch (msg->msgtype) {\r\ncase MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT\n");\r\nbrcmf_msgbuf_process_flow_ring_create_response(msgbuf, buf);\r\nbreak;\r\ncase MSGBUF_TYPE_FLOW_RING_DELETE_CMPLT:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_FLOW_RING_DELETE_CMPLT\n");\r\nbrcmf_msgbuf_process_flow_ring_delete_response(msgbuf, buf);\r\nbreak;\r\ncase MSGBUF_TYPE_IOCTLPTR_REQ_ACK:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_IOCTLPTR_REQ_ACK\n");\r\nbreak;\r\ncase MSGBUF_TYPE_IOCTL_CMPLT:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_IOCTL_CMPLT\n");\r\nbrcmf_msgbuf_process_ioctl_complete(msgbuf, buf);\r\nbreak;\r\ncase MSGBUF_TYPE_WL_EVENT:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_WL_EVENT\n");\r\nbrcmf_msgbuf_process_event(msgbuf, buf);\r\nbreak;\r\ncase MSGBUF_TYPE_TX_STATUS:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_TX_STATUS\n");\r\nbrcmf_msgbuf_process_txstatus(msgbuf, buf);\r\nbreak;\r\ncase MSGBUF_TYPE_RX_CMPLT:\r\nbrcmf_dbg(MSGBUF, "MSGBUF_TYPE_RX_CMPLT\n");\r\nbrcmf_msgbuf_process_rx_complete(msgbuf, buf);\r\nbreak;\r\ndefault:\r\nbrcmf_err("Unsupported msgtype %d\n", msg->msgtype);\r\nbreak;\r\n}\r\n}\r\nstatic void brcmf_msgbuf_process_rx(struct brcmf_msgbuf *msgbuf,\r\nstruct brcmf_commonring *commonring)\r\n{\r\nvoid *buf;\r\nu16 count;\r\nu16 processed;\r\nagain:\r\nbuf = brcmf_commonring_get_read_ptr(commonring, &count);\r\nif (buf == NULL)\r\nreturn;\r\nprocessed = 0;\r\nwhile (count) {\r\nbrcmf_msgbuf_process_msgtype(msgbuf,\r\nbuf + msgbuf->rx_dataoffset);\r\nbuf += brcmf_commonring_len_item(commonring);\r\nprocessed++;\r\nif (processed == BRCMF_MSGBUF_UPDATE_RX_PTR_THRS) {\r\nbrcmf_commonring_read_complete(commonring, processed);\r\nprocessed = 0;\r\n}\r\ncount--;\r\n}\r\nif (processed)\r\nbrcmf_commonring_read_complete(commonring, processed);\r\nif (commonring->r_ptr == 0)\r\ngoto again;\r\n}\r\nint brcmf_proto_msgbuf_rx_trigger(struct device *dev)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct brcmf_commonring *commonring;\r\nvoid *buf;\r\nu32 flowid;\r\nint qlen;\r\nbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_RX_COMPLETE];\r\nbrcmf_msgbuf_process_rx(msgbuf, buf);\r\nbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_TX_COMPLETE];\r\nbrcmf_msgbuf_process_rx(msgbuf, buf);\r\nbuf = msgbuf->commonrings[BRCMF_D2H_MSGRING_CONTROL_COMPLETE];\r\nbrcmf_msgbuf_process_rx(msgbuf, buf);\r\nfor_each_set_bit(flowid, msgbuf->txstatus_done_map,\r\nmsgbuf->max_flowrings) {\r\nclear_bit(flowid, msgbuf->txstatus_done_map);\r\ncommonring = msgbuf->flowrings[flowid];\r\nqlen = brcmf_flowring_qlen(msgbuf->flow, flowid);\r\nif ((qlen > BRCMF_MSGBUF_TRICKLE_TXWORKER_THRS) ||\r\n((qlen) && (atomic_read(&commonring->outstanding_tx) <\r\nBRCMF_MSGBUF_TRICKLE_TXWORKER_THRS)))\r\nbrcmf_msgbuf_schedule_txdata(msgbuf, flowid, true);\r\n}\r\nreturn 0;\r\n}\r\nvoid brcmf_msgbuf_delete_flowring(struct brcmf_pub *drvr, u16 flowid)\r\n{\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct msgbuf_tx_flowring_delete_req *delete;\r\nstruct brcmf_commonring *commonring;\r\nvoid *ret_ptr;\r\nu8 ifidx;\r\nint err;\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\r\nbrcmf_commonring_lock(commonring);\r\nret_ptr = brcmf_commonring_reserve_for_write(commonring);\r\nif (!ret_ptr) {\r\nbrcmf_err("FW unaware, flowring will be removed !!\n");\r\nbrcmf_commonring_unlock(commonring);\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\nreturn;\r\n}\r\ndelete = (struct msgbuf_tx_flowring_delete_req *)ret_ptr;\r\nifidx = brcmf_flowring_ifidx_get(msgbuf->flow, flowid);\r\ndelete->msg.msgtype = MSGBUF_TYPE_FLOW_RING_DELETE;\r\ndelete->msg.ifidx = ifidx;\r\ndelete->msg.request_id = 0;\r\ndelete->flow_ring_id = cpu_to_le16(flowid +\r\nBRCMF_H2D_MSGRING_FLOWRING_IDSTART);\r\ndelete->reason = 0;\r\nbrcmf_dbg(MSGBUF, "Send Flow Delete Req flow ID %d, ifindex %d\n",\r\nflowid, ifidx);\r\nerr = brcmf_commonring_write_complete(commonring);\r\nbrcmf_commonring_unlock(commonring);\r\nif (err) {\r\nbrcmf_err("Failed to submit RING_DELETE, flowring will be removed\n");\r\nbrcmf_msgbuf_remove_flowring(msgbuf, flowid);\r\n}\r\n}\r\nstatic int brcmf_msgbuf_stats_read(struct seq_file *seq, void *data)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nstruct brcmf_msgbuf *msgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\nstruct brcmf_commonring *commonring;\r\nu16 i;\r\nstruct brcmf_flowring_ring *ring;\r\nstruct brcmf_flowring_hash *hash;\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];\r\nseq_printf(seq, "h2d_ctl_submit: rp %4u, wp %4u, depth %4u\n",\r\ncommonring->r_ptr, commonring->w_ptr, commonring->depth);\r\ncommonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_RXPOST_SUBMIT];\r\nseq_printf(seq, "h2d_rx_submit: rp %4u, wp %4u, depth %4u\n",\r\ncommonring->r_ptr, commonring->w_ptr, commonring->depth);\r\ncommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_CONTROL_COMPLETE];\r\nseq_printf(seq, "d2h_ctl_cmplt: rp %4u, wp %4u, depth %4u\n",\r\ncommonring->r_ptr, commonring->w_ptr, commonring->depth);\r\ncommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_TX_COMPLETE];\r\nseq_printf(seq, "d2h_tx_cmplt: rp %4u, wp %4u, depth %4u\n",\r\ncommonring->r_ptr, commonring->w_ptr, commonring->depth);\r\ncommonring = msgbuf->commonrings[BRCMF_D2H_MSGRING_RX_COMPLETE];\r\nseq_printf(seq, "d2h_rx_cmplt: rp %4u, wp %4u, depth %4u\n",\r\ncommonring->r_ptr, commonring->w_ptr, commonring->depth);\r\nseq_printf(seq, "\nh2d_flowrings: depth %u\n",\r\nBRCMF_H2D_TXFLOWRING_MAX_ITEM);\r\nseq_puts(seq, "Active flowrings:\n");\r\nhash = msgbuf->flow->hash;\r\nfor (i = 0; i < msgbuf->flow->nrofrings; i++) {\r\nif (!msgbuf->flow->rings[i])\r\ncontinue;\r\nring = msgbuf->flow->rings[i];\r\nif (ring->status != RING_OPEN)\r\ncontinue;\r\ncommonring = msgbuf->flowrings[i];\r\nhash = &msgbuf->flow->hash[ring->hash_id];\r\nseq_printf(seq, "id %3u: rp %4u, wp %4u, qlen %4u, blocked %u\n"\r\n" ifidx %u, fifo %u, da %pM\n",\r\ni, commonring->r_ptr, commonring->w_ptr,\r\nskb_queue_len(&ring->skblist), ring->blocked,\r\nhash->ifidx, hash->fifo, hash->mac);\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_msgbuf_stats_read(struct seq_file *seq, void *data)\r\n{\r\nreturn 0;\r\n}\r\nint brcmf_proto_msgbuf_attach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_bus_msgbuf *if_msgbuf;\r\nstruct brcmf_msgbuf *msgbuf;\r\nu64 address;\r\nu32 count;\r\nif_msgbuf = drvr->bus_if->msgbuf;\r\nif (if_msgbuf->max_flowrings >= BRCMF_FLOWRING_HASHSIZE) {\r\nbrcmf_err("driver not configured for this many flowrings %d\n",\r\nif_msgbuf->max_flowrings);\r\nif_msgbuf->max_flowrings = BRCMF_FLOWRING_HASHSIZE - 1;\r\n}\r\nmsgbuf = kzalloc(sizeof(*msgbuf), GFP_KERNEL);\r\nif (!msgbuf)\r\ngoto fail;\r\nmsgbuf->txflow_wq = create_singlethread_workqueue("msgbuf_txflow");\r\nif (msgbuf->txflow_wq == NULL) {\r\nbrcmf_err("workqueue creation failed\n");\r\ngoto fail;\r\n}\r\nINIT_WORK(&msgbuf->txflow_work, brcmf_msgbuf_txflow_worker);\r\ncount = BITS_TO_LONGS(if_msgbuf->max_flowrings);\r\ncount = count * sizeof(unsigned long);\r\nmsgbuf->flow_map = kzalloc(count, GFP_KERNEL);\r\nif (!msgbuf->flow_map)\r\ngoto fail;\r\nmsgbuf->txstatus_done_map = kzalloc(count, GFP_KERNEL);\r\nif (!msgbuf->txstatus_done_map)\r\ngoto fail;\r\nmsgbuf->drvr = drvr;\r\nmsgbuf->ioctbuf = dma_alloc_coherent(drvr->bus_if->dev,\r\nBRCMF_TX_IOCTL_MAX_MSG_SIZE,\r\n&msgbuf->ioctbuf_handle,\r\nGFP_KERNEL);\r\nif (!msgbuf->ioctbuf)\r\ngoto fail;\r\naddress = (u64)msgbuf->ioctbuf_handle;\r\nmsgbuf->ioctbuf_phys_hi = address >> 32;\r\nmsgbuf->ioctbuf_phys_lo = address & 0xffffffff;\r\ndrvr->proto->hdrpull = brcmf_msgbuf_hdrpull;\r\ndrvr->proto->query_dcmd = brcmf_msgbuf_query_dcmd;\r\ndrvr->proto->set_dcmd = brcmf_msgbuf_set_dcmd;\r\ndrvr->proto->tx_queue_data = brcmf_msgbuf_tx_queue_data;\r\ndrvr->proto->configure_addr_mode = brcmf_msgbuf_configure_addr_mode;\r\ndrvr->proto->delete_peer = brcmf_msgbuf_delete_peer;\r\ndrvr->proto->add_tdls_peer = brcmf_msgbuf_add_tdls_peer;\r\ndrvr->proto->rxreorder = brcmf_msgbuf_rxreorder;\r\ndrvr->proto->pd = msgbuf;\r\ninit_waitqueue_head(&msgbuf->ioctl_resp_wait);\r\nmsgbuf->commonrings =\r\n(struct brcmf_commonring **)if_msgbuf->commonrings;\r\nmsgbuf->flowrings = (struct brcmf_commonring **)if_msgbuf->flowrings;\r\nmsgbuf->max_flowrings = if_msgbuf->max_flowrings;\r\nmsgbuf->flowring_dma_handle = kzalloc(msgbuf->max_flowrings *\r\nsizeof(*msgbuf->flowring_dma_handle), GFP_KERNEL);\r\nif (!msgbuf->flowring_dma_handle)\r\ngoto fail;\r\nmsgbuf->rx_dataoffset = if_msgbuf->rx_dataoffset;\r\nmsgbuf->max_rxbufpost = if_msgbuf->max_rxbufpost;\r\nmsgbuf->max_ioctlrespbuf = BRCMF_MSGBUF_MAX_IOCTLRESPBUF_POST;\r\nmsgbuf->max_eventbuf = BRCMF_MSGBUF_MAX_EVENTBUF_POST;\r\nmsgbuf->tx_pktids = brcmf_msgbuf_init_pktids(NR_TX_PKTIDS,\r\nDMA_TO_DEVICE);\r\nif (!msgbuf->tx_pktids)\r\ngoto fail;\r\nmsgbuf->rx_pktids = brcmf_msgbuf_init_pktids(NR_RX_PKTIDS,\r\nDMA_FROM_DEVICE);\r\nif (!msgbuf->rx_pktids)\r\ngoto fail;\r\nmsgbuf->flow = brcmf_flowring_attach(drvr->bus_if->dev,\r\nif_msgbuf->max_flowrings);\r\nif (!msgbuf->flow)\r\ngoto fail;\r\nbrcmf_dbg(MSGBUF, "Feeding buffers, rx data %d, rx event %d, rx ioctl resp %d\n",\r\nmsgbuf->max_rxbufpost, msgbuf->max_eventbuf,\r\nmsgbuf->max_ioctlrespbuf);\r\ncount = 0;\r\ndo {\r\nbrcmf_msgbuf_rxbuf_data_fill(msgbuf);\r\nif (msgbuf->max_rxbufpost != msgbuf->rxbufpost)\r\nmsleep(10);\r\nelse\r\nbreak;\r\ncount++;\r\n} while (count < 10);\r\nbrcmf_msgbuf_rxbuf_event_post(msgbuf);\r\nbrcmf_msgbuf_rxbuf_ioctlresp_post(msgbuf);\r\nINIT_WORK(&msgbuf->flowring_work, brcmf_msgbuf_flowring_worker);\r\nspin_lock_init(&msgbuf->flowring_work_lock);\r\nINIT_LIST_HEAD(&msgbuf->work_queue);\r\nbrcmf_debugfs_add_entry(drvr, "msgbuf_stats", brcmf_msgbuf_stats_read);\r\nreturn 0;\r\nfail:\r\nif (msgbuf) {\r\nkfree(msgbuf->flow_map);\r\nkfree(msgbuf->txstatus_done_map);\r\nbrcmf_msgbuf_release_pktids(msgbuf);\r\nkfree(msgbuf->flowring_dma_handle);\r\nif (msgbuf->ioctbuf)\r\ndma_free_coherent(drvr->bus_if->dev,\r\nBRCMF_TX_IOCTL_MAX_MSG_SIZE,\r\nmsgbuf->ioctbuf,\r\nmsgbuf->ioctbuf_handle);\r\nkfree(msgbuf);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid brcmf_proto_msgbuf_detach(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_msgbuf *msgbuf;\r\nstruct brcmf_msgbuf_work_item *work;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (drvr->proto->pd) {\r\nmsgbuf = (struct brcmf_msgbuf *)drvr->proto->pd;\r\ncancel_work_sync(&msgbuf->flowring_work);\r\nwhile (!list_empty(&msgbuf->work_queue)) {\r\nwork = list_first_entry(&msgbuf->work_queue,\r\nstruct brcmf_msgbuf_work_item,\r\nqueue);\r\nlist_del(&work->queue);\r\nkfree(work);\r\n}\r\nkfree(msgbuf->flow_map);\r\nkfree(msgbuf->txstatus_done_map);\r\nif (msgbuf->txflow_wq)\r\ndestroy_workqueue(msgbuf->txflow_wq);\r\nbrcmf_flowring_detach(msgbuf->flow);\r\ndma_free_coherent(drvr->bus_if->dev,\r\nBRCMF_TX_IOCTL_MAX_MSG_SIZE,\r\nmsgbuf->ioctbuf, msgbuf->ioctbuf_handle);\r\nbrcmf_msgbuf_release_pktids(msgbuf);\r\nkfree(msgbuf->flowring_dma_handle);\r\nkfree(msgbuf);\r\ndrvr->proto->pd = NULL;\r\n}\r\n}
