static int set_tdm_framer(const char *tdm_framer_type)\r\n{\r\nif (strcmp(tdm_framer_type, "e1") == 0)\r\nreturn TDM_FRAMER_E1;\r\nelse if (strcmp(tdm_framer_type, "t1") == 0)\r\nreturn TDM_FRAMER_T1;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic void set_si_param(struct ucc_tdm *utdm, struct ucc_tdm_info *ut_info)\r\n{\r\nstruct si_mode_info *si_info = &ut_info->si_info;\r\nif (utdm->tdm_mode == TDM_INTERNAL_LOOPBACK) {\r\nsi_info->simr_crt = 1;\r\nsi_info->simr_rfsd = 0;\r\n}\r\n}\r\nint ucc_of_parse_tdm(struct device_node *np, struct ucc_tdm *utdm,\r\nstruct ucc_tdm_info *ut_info)\r\n{\r\nconst char *sprop;\r\nint ret = 0;\r\nu32 val;\r\nstruct resource *res;\r\nstruct device_node *np2;\r\nstatic int siram_init_flag;\r\nstruct platform_device *pdev;\r\nsprop = of_get_property(np, "fsl,rx-sync-clock", NULL);\r\nif (sprop) {\r\nut_info->uf_info.rx_sync = qe_clock_source(sprop);\r\nif ((ut_info->uf_info.rx_sync < QE_CLK_NONE) ||\r\n(ut_info->uf_info.rx_sync > QE_RSYNC_PIN)) {\r\npr_err("QE-TDM: Invalid rx-sync-clock property\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npr_err("QE-TDM: Invalid rx-sync-clock property\n");\r\nreturn -EINVAL;\r\n}\r\nsprop = of_get_property(np, "fsl,tx-sync-clock", NULL);\r\nif (sprop) {\r\nut_info->uf_info.tx_sync = qe_clock_source(sprop);\r\nif ((ut_info->uf_info.tx_sync < QE_CLK_NONE) ||\r\n(ut_info->uf_info.tx_sync > QE_TSYNC_PIN)) {\r\npr_err("QE-TDM: Invalid tx-sync-clock property\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npr_err("QE-TDM: Invalid tx-sync-clock property\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(np, "fsl,tx-timeslot-mask", 0, &val);\r\nif (ret) {\r\npr_err("QE-TDM: Invalid tx-timeslot-mask property\n");\r\nreturn -EINVAL;\r\n}\r\nutdm->tx_ts_mask = val;\r\nret = of_property_read_u32_index(np, "fsl,rx-timeslot-mask", 0, &val);\r\nif (ret) {\r\nret = -EINVAL;\r\npr_err("QE-TDM: Invalid rx-timeslot-mask property\n");\r\nreturn ret;\r\n}\r\nutdm->rx_ts_mask = val;\r\nret = of_property_read_u32_index(np, "fsl,tdm-id", 0, &val);\r\nif (ret) {\r\nret = -EINVAL;\r\npr_err("QE-TDM: No fsl,tdm-id property for this UCC\n");\r\nreturn ret;\r\n}\r\nutdm->tdm_port = val;\r\nut_info->uf_info.tdm_num = utdm->tdm_port;\r\nif (of_property_read_bool(np, "fsl,tdm-internal-loopback"))\r\nutdm->tdm_mode = TDM_INTERNAL_LOOPBACK;\r\nelse\r\nutdm->tdm_mode = TDM_NORMAL;\r\nsprop = of_get_property(np, "fsl,tdm-framer-type", NULL);\r\nif (!sprop) {\r\nret = -EINVAL;\r\npr_err("QE-TDM: No tdm-framer-type property for UCC\n");\r\nreturn ret;\r\n}\r\nret = set_tdm_framer(sprop);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nutdm->tdm_framer_type = ret;\r\nret = of_property_read_u32_index(np, "fsl,siram-entry-id", 0, &val);\r\nif (ret) {\r\nret = -EINVAL;\r\npr_err("QE-TDM: No siram entry id for UCC\n");\r\nreturn ret;\r\n}\r\nutdm->siram_entry_id = val;\r\nset_si_param(utdm, ut_info);\r\nnp2 = of_find_compatible_node(NULL, NULL, "fsl,t1040-qe-si");\r\nif (!np2)\r\nreturn -EINVAL;\r\npdev = of_find_device_by_node(np2);\r\nif (!pdev) {\r\npr_err("%s: failed to lookup pdev\n", np2->name);\r\nof_node_put(np2);\r\nreturn -EINVAL;\r\n}\r\nof_node_put(np2);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nutdm->si_regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(utdm->si_regs)) {\r\nret = PTR_ERR(utdm->si_regs);\r\ngoto err_miss_siram_property;\r\n}\r\nnp2 = of_find_compatible_node(NULL, NULL, "fsl,t1040-qe-siram");\r\nif (!np2) {\r\nret = -EINVAL;\r\ngoto err_miss_siram_property;\r\n}\r\npdev = of_find_device_by_node(np2);\r\nif (!pdev) {\r\nret = -EINVAL;\r\npr_err("%s: failed to lookup pdev\n", np2->name);\r\nof_node_put(np2);\r\ngoto err_miss_siram_property;\r\n}\r\nof_node_put(np2);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nutdm->siram = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(utdm->siram)) {\r\nret = PTR_ERR(utdm->siram);\r\ngoto err_miss_siram_property;\r\n}\r\nif (siram_init_flag == 0) {\r\nmemset_io(utdm->siram, 0, resource_size(res));\r\nsiram_init_flag = 1;\r\n}\r\nreturn ret;\r\nerr_miss_siram_property:\r\ndevm_iounmap(&pdev->dev, utdm->si_regs);\r\nreturn ret;\r\n}\r\nvoid ucc_tdm_init(struct ucc_tdm *utdm, struct ucc_tdm_info *ut_info)\r\n{\r\nstruct si1 __iomem *si_regs;\r\nu16 __iomem *siram;\r\nu16 siram_entry_valid;\r\nu16 siram_entry_closed;\r\nu16 ucc_num;\r\nu8 csel;\r\nu16 sixmr;\r\nu16 tdm_port;\r\nu32 siram_entry_id;\r\nu32 mask;\r\nint i;\r\nsi_regs = utdm->si_regs;\r\nsiram = utdm->siram;\r\nucc_num = ut_info->uf_info.ucc_num;\r\ntdm_port = utdm->tdm_port;\r\nsiram_entry_id = utdm->siram_entry_id;\r\nif (utdm->tdm_framer_type == TDM_FRAMER_T1)\r\nutdm->num_of_ts = 24;\r\nif (utdm->tdm_framer_type == TDM_FRAMER_E1)\r\nutdm->num_of_ts = 32;\r\ncsel = (ucc_num < 4) ? ucc_num + 9 : ucc_num - 3;\r\nsiram_entry_valid = SIR_CSEL(csel) | SIR_BYTE | SIR_CNT(0);\r\nsiram_entry_closed = SIR_IDLE | SIR_BYTE | SIR_CNT(0);\r\nfor (i = 0; i < utdm->num_of_ts; i++) {\r\nmask = 0x01 << i;\r\nif (utdm->tx_ts_mask & mask)\r\niowrite16be(siram_entry_valid,\r\n&siram[siram_entry_id * 32 + i]);\r\nelse\r\niowrite16be(siram_entry_closed,\r\n&siram[siram_entry_id * 32 + i]);\r\nif (utdm->rx_ts_mask & mask)\r\niowrite16be(siram_entry_valid,\r\n&siram[siram_entry_id * 32 + 0x200 + i]);\r\nelse\r\niowrite16be(siram_entry_closed,\r\n&siram[siram_entry_id * 32 + 0x200 + i]);\r\n}\r\nsetbits16(&siram[(siram_entry_id * 32) + (utdm->num_of_ts - 1)],\r\nSIR_LAST);\r\nsetbits16(&siram[(siram_entry_id * 32) + 0x200 + (utdm->num_of_ts - 1)],\r\nSIR_LAST);\r\nsixmr = SIMR_SAD(siram_entry_id);\r\nsixmr &= ~SIMR_SDM_MASK;\r\nif (utdm->tdm_mode == TDM_INTERNAL_LOOPBACK)\r\nsixmr |= SIMR_SDM_INTERNAL_LOOPBACK;\r\nelse\r\nsixmr |= SIMR_SDM_NORMAL;\r\nsixmr |= SIMR_RFSD(ut_info->si_info.simr_rfsd) |\r\nSIMR_TFSD(ut_info->si_info.simr_tfsd);\r\nif (ut_info->si_info.simr_crt)\r\nsixmr |= SIMR_CRT;\r\nif (ut_info->si_info.simr_sl)\r\nsixmr |= SIMR_SL;\r\nif (ut_info->si_info.simr_ce)\r\nsixmr |= SIMR_CE;\r\nif (ut_info->si_info.simr_fe)\r\nsixmr |= SIMR_FE;\r\nif (ut_info->si_info.simr_gm)\r\nsixmr |= SIMR_GM;\r\nswitch (tdm_port) {\r\ncase 0:\r\niowrite16be(sixmr, &si_regs->sixmr1[0]);\r\nbreak;\r\ncase 1:\r\niowrite16be(sixmr, &si_regs->sixmr1[1]);\r\nbreak;\r\ncase 2:\r\niowrite16be(sixmr, &si_regs->sixmr1[2]);\r\nbreak;\r\ncase 3:\r\niowrite16be(sixmr, &si_regs->sixmr1[3]);\r\nbreak;\r\ndefault:\r\npr_err("QE-TDM: can not find tdm sixmr reg\n");\r\nbreak;\r\n}\r\n}
