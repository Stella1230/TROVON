static inline void vsp1_hsit_write(struct vsp1_hsit *hsit,\r\nstruct vsp1_dl_list *dl, u32 reg, u32 data)\r\n{\r\nvsp1_dl_list_write(dl, reg, data);\r\n}\r\nstatic int hsit_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\nif ((code->pad == HSIT_PAD_SINK && !hsit->inverse) |\r\n(code->pad == HSIT_PAD_SOURCE && hsit->inverse))\r\ncode->code = MEDIA_BUS_FMT_ARGB8888_1X32;\r\nelse\r\ncode->code = MEDIA_BUS_FMT_AHSV8888_1X32;\r\nreturn 0;\r\n}\r\nstatic int hsit_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nreturn vsp1_subdev_enum_frame_size(subdev, cfg, fse, HSIT_MIN_SIZE,\r\nHSIT_MIN_SIZE, HSIT_MAX_SIZE,\r\nHSIT_MAX_SIZE);\r\n}\r\nstatic int hsit_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nmutex_lock(&hsit->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&hsit->entity, cfg, fmt->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nformat = vsp1_entity_get_pad_format(&hsit->entity, config, fmt->pad);\r\nif (fmt->pad == HSIT_PAD_SOURCE) {\r\nfmt->format = *format;\r\ngoto done;\r\n}\r\nformat->code = hsit->inverse ? MEDIA_BUS_FMT_AHSV8888_1X32\r\n: MEDIA_BUS_FMT_ARGB8888_1X32;\r\nformat->width = clamp_t(unsigned int, fmt->format.width,\r\nHSIT_MIN_SIZE, HSIT_MAX_SIZE);\r\nformat->height = clamp_t(unsigned int, fmt->format.height,\r\nHSIT_MIN_SIZE, HSIT_MAX_SIZE);\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->format = *format;\r\nformat = vsp1_entity_get_pad_format(&hsit->entity, config,\r\nHSIT_PAD_SOURCE);\r\n*format = fmt->format;\r\nformat->code = hsit->inverse ? MEDIA_BUS_FMT_ARGB8888_1X32\r\n: MEDIA_BUS_FMT_AHSV8888_1X32;\r\ndone:\r\nmutex_unlock(&hsit->entity.lock);\r\nreturn ret;\r\n}\r\nstatic void hsit_configure(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl,\r\nenum vsp1_entity_params params)\r\n{\r\nstruct vsp1_hsit *hsit = to_hsit(&entity->subdev);\r\nif (params != VSP1_ENTITY_PARAMS_INIT)\r\nreturn;\r\nif (hsit->inverse)\r\nvsp1_hsit_write(hsit, dl, VI6_HSI_CTRL, VI6_HSI_CTRL_EN);\r\nelse\r\nvsp1_hsit_write(hsit, dl, VI6_HST_CTRL, VI6_HST_CTRL_EN);\r\n}\r\nstruct vsp1_hsit *vsp1_hsit_create(struct vsp1_device *vsp1, bool inverse)\r\n{\r\nstruct vsp1_hsit *hsit;\r\nint ret;\r\nhsit = devm_kzalloc(vsp1->dev, sizeof(*hsit), GFP_KERNEL);\r\nif (hsit == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nhsit->inverse = inverse;\r\nhsit->entity.ops = &hsit_entity_ops;\r\nif (inverse)\r\nhsit->entity.type = VSP1_ENTITY_HSI;\r\nelse\r\nhsit->entity.type = VSP1_ENTITY_HST;\r\nret = vsp1_entity_init(vsp1, &hsit->entity, inverse ? "hsi" : "hst",\r\n2, &hsit_ops,\r\nMEDIA_ENT_F_PROC_VIDEO_PIXEL_ENC_CONV);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nreturn hsit;\r\n}
