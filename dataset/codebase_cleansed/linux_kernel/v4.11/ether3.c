static inline void ether3_outb(int v, void __iomem *r)\r\n{\r\nwriteb(v, r);\r\nudelay(1);\r\n}\r\nstatic inline void ether3_outw(int v, void __iomem *r)\r\n{\r\nwritew(v, r);\r\nudelay(1);\r\n}\r\nstatic int\r\nether3_setbuffer(struct net_device *dev, buffer_rw_t read, int start)\r\n{\r\nint timeout = 1000;\r\nether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\r\nether3_outw(priv(dev)->regs.command | CMD_FIFOWRITE, REG_COMMAND);\r\nwhile ((ether3_inw(REG_STATUS) & STAT_FIFOEMPTY) == 0) {\r\nif (!timeout--) {\r\nprintk("%s: setbuffer broken\n", dev->name);\r\npriv(dev)->broken = 1;\r\nreturn 1;\r\n}\r\nudelay(1);\r\n}\r\nif (read == buffer_read) {\r\nether3_outw(start, REG_DMAADDR);\r\nether3_outw(priv(dev)->regs.command | CMD_FIFOREAD, REG_COMMAND);\r\n} else {\r\nether3_outw(priv(dev)->regs.command | CMD_FIFOWRITE, REG_COMMAND);\r\nether3_outw(start, REG_DMAADDR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ether3_ledoff(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO, REG_CONFIG2);\r\n}\r\nstatic inline void ether3_ledon(struct net_device *dev)\r\n{\r\ndel_timer(&priv(dev)->timer);\r\npriv(dev)->timer.expires = jiffies + HZ / 50;\r\npriv(dev)->timer.data = (unsigned long)dev;\r\npriv(dev)->timer.function = ether3_ledoff;\r\nadd_timer(&priv(dev)->timer);\r\nif (priv(dev)->regs.config2 & CFG2_CTRLO)\r\nether3_outw(priv(dev)->regs.config2 &= ~CFG2_CTRLO, REG_CONFIG2);\r\n}\r\nstatic int\r\nether3_addr(char *addr, struct expansion_card *ec)\r\n{\r\nstruct in_chunk_dir cd;\r\nchar *s;\r\nif (ecard_readchunk(&cd, ec, 0xf5, 0) && (s = strchr(cd.d.string, '('))) {\r\nint i;\r\nfor (i = 0; i<6; i++) {\r\naddr[i] = simple_strtoul(s + 1, &s, 0x10);\r\nif (*s != (i==5?')' : ':' ))\r\nbreak;\r\n}\r\nif (i == 6)\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "ether3: Couldn't read a valid MAC address from card.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nether3_ramtest(struct net_device *dev, unsigned char byte)\r\n{\r\nunsigned char *buffer = kmalloc(RX_END, GFP_KERNEL);\r\nint i,ret = 0;\r\nint max_errors = 4;\r\nint bad = -1;\r\nif (!buffer)\r\nreturn 1;\r\nmemset(buffer, byte, RX_END);\r\nether3_setbuffer(dev, buffer_write, 0);\r\nether3_writebuffer(dev, buffer, TX_END);\r\nether3_setbuffer(dev, buffer_write, RX_START);\r\nether3_writebuffer(dev, buffer + RX_START, RX_LEN);\r\nmemset(buffer, byte ^ 0xff, RX_END);\r\nether3_setbuffer(dev, buffer_read, 0);\r\nether3_readbuffer(dev, buffer, TX_END);\r\nether3_setbuffer(dev, buffer_read, RX_START);\r\nether3_readbuffer(dev, buffer + RX_START, RX_LEN);\r\nfor (i = 0; i < RX_END; i++) {\r\nif (buffer[i] != byte) {\r\nif (max_errors > 0 && bad != buffer[i]) {\r\nprintk("%s: RAM failed with (%02X instead of %02X) at 0x%04X",\r\ndev->name, buffer[i], byte, i);\r\nret = 2;\r\nmax_errors--;\r\nbad = i;\r\n}\r\n} else {\r\nif (bad != -1) {\r\nif (bad != i - 1)\r\nprintk(" - 0x%04X\n", i - 1);\r\nprintk("\n");\r\nbad = -1;\r\n}\r\n}\r\n}\r\nif (bad != -1)\r\nprintk(" - 0xffff\n");\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int ether3_init_2(struct net_device *dev)\r\n{\r\nint i;\r\npriv(dev)->regs.config1 = CFG1_RECVCOMPSTAT0|CFG1_DMABURST8;\r\npriv(dev)->regs.config2 = CFG2_CTRLO|CFG2_RECVCRC|CFG2_ERRENCRC;\r\npriv(dev)->regs.command = 0;\r\nether3_outw(priv(dev)->regs.config1 | CFG1_BUFSELSTAT0, REG_CONFIG1);\r\nfor (i = 0; i < 6; i++)\r\nether3_outb(dev->dev_addr[i], REG_BUFWIN);\r\nif (dev->flags & IFF_PROMISC)\r\npriv(dev)->regs.config1 |= CFG1_RECVPROMISC;\r\nelse if (dev->flags & IFF_MULTICAST)\r\npriv(dev)->regs.config1 |= CFG1_RECVSPECBRMULTI;\r\nelse\r\npriv(dev)->regs.config1 |= CFG1_RECVSPECBROAD;\r\nether3_outw(priv(dev)->regs.config1 | CFG1_TRANSEND, REG_CONFIG1);\r\nether3_outw((TX_END>>8) - 1, REG_BUFWIN);\r\nether3_outw(priv(dev)->rx_head, REG_RECVPTR);\r\nether3_outw(0, REG_TRANSMITPTR);\r\nether3_outw(priv(dev)->rx_head >> 8, REG_RECVEND);\r\nether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\r\nether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\r\nether3_outw(priv(dev)->regs.command, REG_COMMAND);\r\ni = ether3_ramtest(dev, 0x5A);\r\nif(i)\r\nreturn i;\r\ni = ether3_ramtest(dev, 0x1E);\r\nif(i)\r\nreturn i;\r\nether3_setbuffer(dev, buffer_write, 0);\r\nether3_writelong(dev, 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nether3_init_for_open(struct net_device *dev)\r\n{\r\nint i;\r\nether3_outw(CFG2_RESET, REG_CONFIG2);\r\nudelay(4);\r\npriv(dev)->regs.command = 0;\r\nether3_outw(CMD_RXOFF|CMD_TXOFF, REG_COMMAND);\r\nwhile (ether3_inw(REG_STATUS) & (STAT_RXON|STAT_TXON))\r\nbarrier();\r\nether3_outw(priv(dev)->regs.config1 | CFG1_BUFSELSTAT0, REG_CONFIG1);\r\nfor (i = 0; i < 6; i++)\r\nether3_outb(dev->dev_addr[i], REG_BUFWIN);\r\npriv(dev)->tx_head = 0;\r\npriv(dev)->tx_tail = 0;\r\npriv(dev)->regs.config2 |= CFG2_CTRLO;\r\npriv(dev)->rx_head = RX_START;\r\nether3_outw(priv(dev)->regs.config1 | CFG1_TRANSEND, REG_CONFIG1);\r\nether3_outw((TX_END>>8) - 1, REG_BUFWIN);\r\nether3_outw(priv(dev)->rx_head, REG_RECVPTR);\r\nether3_outw(priv(dev)->rx_head >> 8, REG_RECVEND);\r\nether3_outw(0, REG_TRANSMITPTR);\r\nether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\r\nether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\r\nether3_setbuffer(dev, buffer_write, 0);\r\nether3_writelong(dev, 0);\r\npriv(dev)->regs.command = CMD_ENINTRX | CMD_ENINTTX;\r\nether3_outw(priv(dev)->regs.command | CMD_RXON, REG_COMMAND);\r\n}\r\nstatic inline int\r\nether3_probe_bus_8(struct net_device *dev, int val)\r\n{\r\nint write_low, write_high, read_low, read_high;\r\nwrite_low = val & 255;\r\nwrite_high = val >> 8;\r\nprintk(KERN_DEBUG "ether3_probe: write8 [%02X:%02X]", write_high, write_low);\r\nether3_outb(write_low, REG_RECVPTR);\r\nether3_outb(write_high, REG_RECVPTR + 4);\r\nread_low = ether3_inb(REG_RECVPTR);\r\nread_high = ether3_inb(REG_RECVPTR + 4);\r\nprintk(", read8 [%02X:%02X]\n", read_high, read_low);\r\nreturn read_low == write_low && read_high == write_high;\r\n}\r\nstatic inline int\r\nether3_probe_bus_16(struct net_device *dev, int val)\r\n{\r\nint read_val;\r\nether3_outw(val, REG_RECVPTR);\r\nread_val = ether3_inw(REG_RECVPTR);\r\nprintk(KERN_DEBUG "ether3_probe: write16 [%04X], read16 [%04X]\n", val, read_val);\r\nreturn read_val == val;\r\n}\r\nstatic int\r\nether3_open(struct net_device *dev)\r\n{\r\nif (request_irq(dev->irq, ether3_interrupt, 0, "ether3", dev))\r\nreturn -EAGAIN;\r\nether3_init_for_open(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nether3_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\ndisable_irq(dev->irq);\r\nether3_outw(CMD_RXOFF|CMD_TXOFF, REG_COMMAND);\r\npriv(dev)->regs.command = 0;\r\nwhile (ether3_inw(REG_STATUS) & (STAT_RXON|STAT_TXON))\r\nbarrier();\r\nether3_outb(0x80, REG_CONFIG2 + 4);\r\nether3_outw(0, REG_COMMAND);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void ether3_setmulticastlist(struct net_device *dev)\r\n{\r\npriv(dev)->regs.config1 &= ~CFG1_RECVPROMISC;\r\nif (dev->flags & IFF_PROMISC) {\r\npriv(dev)->regs.config1 |= CFG1_RECVPROMISC;\r\n} else if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev)) {\r\npriv(dev)->regs.config1 |= CFG1_RECVSPECBRMULTI;\r\n} else\r\npriv(dev)->regs.config1 |= CFG1_RECVSPECBROAD;\r\nether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\r\n}\r\nstatic void ether3_timeout(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\ndel_timer(&priv(dev)->timer);\r\nlocal_irq_save(flags);\r\nprintk(KERN_ERR "%s: transmit timed out, network cable problem?\n", dev->name);\r\nprintk(KERN_ERR "%s: state: { status=%04X cfg1=%04X cfg2=%04X }\n", dev->name,\r\nether3_inw(REG_STATUS), ether3_inw(REG_CONFIG1), ether3_inw(REG_CONFIG2));\r\nprintk(KERN_ERR "%s: { rpr=%04X rea=%04X tpr=%04X }\n", dev->name,\r\nether3_inw(REG_RECVPTR), ether3_inw(REG_RECVEND), ether3_inw(REG_TRANSMITPTR));\r\nprintk(KERN_ERR "%s: tx head=%X tx tail=%X\n", dev->name,\r\npriv(dev)->tx_head, priv(dev)->tx_tail);\r\nether3_setbuffer(dev, buffer_read, priv(dev)->tx_tail);\r\nprintk(KERN_ERR "%s: packet status = %08X\n", dev->name, ether3_readlong(dev));\r\nlocal_irq_restore(flags);\r\npriv(dev)->regs.config2 |= CFG2_CTRLO;\r\ndev->stats.tx_errors += 1;\r\nether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\r\npriv(dev)->tx_head = priv(dev)->tx_tail = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nether3_sendpacket(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nunsigned int length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\r\nunsigned int ptr, next_ptr;\r\nif (priv(dev)->broken) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nlength = (length + 1) & ~1;\r\nif (length != skb->len) {\r\nif (skb_padto(skb, length))\r\ngoto out;\r\n}\r\nnext_ptr = (priv(dev)->tx_head + 1) & 15;\r\nlocal_irq_save(flags);\r\nif (priv(dev)->tx_tail == next_ptr) {\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nptr = 0x600 * priv(dev)->tx_head;\r\npriv(dev)->tx_head = next_ptr;\r\nnext_ptr *= 0x600;\r\n#define TXHDR_FLAGS (TXHDR_TRANSMIT|TXHDR_CHAINCONTINUE|TXHDR_DATAFOLLOWS|TXHDR_ENSUCCESS)\r\nether3_setbuffer(dev, buffer_write, next_ptr);\r\nether3_writelong(dev, 0);\r\nether3_setbuffer(dev, buffer_write, ptr);\r\nether3_writelong(dev, 0);\r\nether3_writebuffer(dev, skb->data, length);\r\nether3_writeword(dev, htons(next_ptr));\r\nether3_writeword(dev, TXHDR_CHAINCONTINUE >> 16);\r\nether3_setbuffer(dev, buffer_write, ptr);\r\nether3_writeword(dev, htons((ptr + length + 4)));\r\nether3_writeword(dev, TXHDR_FLAGS >> 16);\r\nether3_ledon(dev);\r\nif (!(ether3_inw(REG_STATUS) & STAT_TXON)) {\r\nether3_outw(ptr, REG_TRANSMITPTR);\r\nether3_outw(priv(dev)->regs.command | CMD_TXON, REG_COMMAND);\r\n}\r\nnext_ptr = (priv(dev)->tx_head + 1) & 15;\r\nlocal_irq_restore(flags);\r\ndev_kfree_skb(skb);\r\nif (priv(dev)->tx_tail == next_ptr)\r\nnetif_stop_queue(dev);\r\nout:\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t\r\nether3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nunsigned int status, handled = IRQ_NONE;\r\n#if NET_DEBUG > 1\r\nif(net_debug & DEBUG_INT)\r\nprintk("eth3irq: %d ", irq);\r\n#endif\r\nstatus = ether3_inw(REG_STATUS);\r\nif (status & STAT_INTRX) {\r\nether3_outw(CMD_ACKINTRX | priv(dev)->regs.command, REG_COMMAND);\r\nether3_rx(dev, 12);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (status & STAT_INTTX) {\r\nether3_outw(CMD_ACKINTTX | priv(dev)->regs.command, REG_COMMAND);\r\nether3_tx(dev);\r\nhandled = IRQ_HANDLED;\r\n}\r\n#if NET_DEBUG > 1\r\nif(net_debug & DEBUG_INT)\r\nprintk("done\n");\r\n#endif\r\nreturn handled;\r\n}\r\nstatic int ether3_rx(struct net_device *dev, unsigned int maxcnt)\r\n{\r\nunsigned int next_ptr = priv(dev)->rx_head, received = 0;\r\nether3_ledon(dev);\r\ndo {\r\nunsigned int this_ptr, status;\r\nunsigned char addrs[16];\r\n{\r\nunsigned int temp_ptr;\r\nether3_setbuffer(dev, buffer_read, next_ptr);\r\ntemp_ptr = ether3_readword(dev);\r\nstatus = ether3_readword(dev);\r\nif ((status & (RXSTAT_DONE | RXHDR_CHAINCONTINUE | RXHDR_RECEIVE)) !=\r\n(RXSTAT_DONE | RXHDR_CHAINCONTINUE) || !temp_ptr)\r\nbreak;\r\nthis_ptr = next_ptr + 4;\r\nnext_ptr = ntohs(temp_ptr);\r\n}\r\nether3_setbuffer(dev, buffer_read, this_ptr);\r\nether3_readbuffer(dev, addrs+2, 12);\r\nif (next_ptr < RX_START || next_ptr >= RX_END) {\r\nint i;\r\nprintk("%s: bad next pointer @%04X: ", dev->name, priv(dev)->rx_head);\r\nprintk("%02X %02X %02X %02X ", next_ptr >> 8, next_ptr & 255, status & 255, status >> 8);\r\nfor (i = 2; i < 14; i++)\r\nprintk("%02X ", addrs[i]);\r\nprintk("\n");\r\nnext_ptr = priv(dev)->rx_head;\r\nbreak;\r\n}\r\nif (!(*(unsigned long *)&dev->dev_addr[0] ^ *(unsigned long *)&addrs[2+6]) &&\r\n!(*(unsigned short *)&dev->dev_addr[4] ^ *(unsigned short *)&addrs[2+10])) {\r\nmaxcnt ++;\r\nether3_outw(next_ptr >> 8, REG_RECVEND);\r\n} else\r\nif (!(status & (RXSTAT_OVERSIZE|RXSTAT_CRCERROR|RXSTAT_DRIBBLEERROR|RXSTAT_SHORTPACKET))) {\r\nunsigned int length = next_ptr - this_ptr;\r\nstruct sk_buff *skb;\r\nif (next_ptr <= this_ptr)\r\nlength += RX_END - RX_START;\r\nskb = netdev_alloc_skb(dev, length + 2);\r\nif (skb) {\r\nunsigned char *buf;\r\nskb_reserve(skb, 2);\r\nbuf = skb_put(skb, length);\r\nether3_readbuffer(dev, buf + 12, length - 12);\r\nether3_outw(next_ptr >> 8, REG_RECVEND);\r\n*(unsigned short *)(buf + 0) = *(unsigned short *)(addrs + 2);\r\n*(unsigned long *)(buf + 2) = *(unsigned long *)(addrs + 4);\r\n*(unsigned long *)(buf + 6) = *(unsigned long *)(addrs + 8);\r\n*(unsigned short *)(buf + 10) = *(unsigned short *)(addrs + 12);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nreceived ++;\r\n} else {\r\nether3_outw(next_ptr >> 8, REG_RECVEND);\r\ndev->stats.rx_dropped++;\r\ngoto done;\r\n}\r\n} else {\r\nstruct net_device_stats *stats = &dev->stats;\r\nether3_outw(next_ptr >> 8, REG_RECVEND);\r\nif (status & RXSTAT_OVERSIZE) stats->rx_over_errors ++;\r\nif (status & RXSTAT_CRCERROR) stats->rx_crc_errors ++;\r\nif (status & RXSTAT_DRIBBLEERROR) stats->rx_fifo_errors ++;\r\nif (status & RXSTAT_SHORTPACKET) stats->rx_length_errors ++;\r\nstats->rx_errors++;\r\n}\r\n}\r\nwhile (-- maxcnt);\r\ndone:\r\ndev->stats.rx_packets += received;\r\npriv(dev)->rx_head = next_ptr;\r\nif (!(ether3_inw(REG_STATUS) & STAT_RXON)) {\r\ndev->stats.rx_dropped++;\r\nether3_outw(next_ptr, REG_RECVPTR);\r\nether3_outw(priv(dev)->regs.command | CMD_RXON, REG_COMMAND);\r\n}\r\nreturn maxcnt;\r\n}\r\nstatic void ether3_tx(struct net_device *dev)\r\n{\r\nunsigned int tx_tail = priv(dev)->tx_tail;\r\nint max_work = 14;\r\ndo {\r\nunsigned long status;\r\nether3_setbuffer(dev, buffer_read, tx_tail * 0x600);\r\nstatus = ether3_readlong(dev);\r\nif ((status & (TXSTAT_DONE | TXHDR_TRANSMIT)) !=\r\n(TXSTAT_DONE | TXHDR_TRANSMIT))\r\nbreak;\r\nif (!(status & (TXSTAT_BABBLED | TXSTAT_16COLLISIONS)))\r\ndev->stats.tx_packets++;\r\nelse {\r\ndev->stats.tx_errors++;\r\nif (status & TXSTAT_16COLLISIONS)\r\ndev->stats.collisions += 16;\r\nif (status & TXSTAT_BABBLED)\r\ndev->stats.tx_fifo_errors++;\r\n}\r\ntx_tail = (tx_tail + 1) & 15;\r\n} while (--max_work);\r\nif (priv(dev)->tx_tail != tx_tail) {\r\npriv(dev)->tx_tail = tx_tail;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic void ether3_banner(void)\r\n{\r\nstatic unsigned version_printed = 0;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\n}\r\nstatic int\r\nether3_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nconst struct ether3_data *data = id->data;\r\nstruct net_device *dev;\r\nint bus_type, ret;\r\nether3_banner();\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\ndev = alloc_etherdev(sizeof(struct dev_priv));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nSET_NETDEV_DEV(dev, &ec->dev);\r\npriv(dev)->base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\r\nif (!priv(dev)->base) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nec->irqaddr = priv(dev)->base + data->base_offset;\r\nec->irqmask = 0xf0;\r\npriv(dev)->seeq = priv(dev)->base + data->base_offset;\r\ndev->irq = ec->irq;\r\nether3_addr(dev->dev_addr, ec);\r\ninit_timer(&priv(dev)->timer);\r\nether3_outb(0x80, REG_CONFIG2 + 4);\r\nbus_type = BUS_UNKNOWN;\r\nudelay(4);\r\nif (ether3_probe_bus_8(dev, 0x100) &&\r\nether3_probe_bus_8(dev, 0x201))\r\nbus_type = BUS_8;\r\nif (bus_type == BUS_UNKNOWN &&\r\nether3_probe_bus_16(dev, 0x101) &&\r\nether3_probe_bus_16(dev, 0x201))\r\nbus_type = BUS_16;\r\nswitch (bus_type) {\r\ncase BUS_UNKNOWN:\r\nprintk(KERN_ERR "%s: unable to identify bus width\n", dev->name);\r\nret = -ENODEV;\r\ngoto free;\r\ncase BUS_8:\r\nprintk(KERN_ERR "%s: %s found, but is an unsupported "\r\n"8-bit card\n", dev->name, data->name);\r\nret = -ENODEV;\r\ngoto free;\r\ndefault:\r\nbreak;\r\n}\r\nif (ether3_init_2(dev)) {\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\ndev->netdev_ops = &ether3_netdev_ops;\r\ndev->watchdog_timeo = 5 * HZ / 100;\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto free;\r\nprintk("%s: %s in slot %d, %pM\n",\r\ndev->name, data->name, ec->slot_no, dev->dev_addr);\r\necard_set_drvdata(ec, dev);\r\nreturn 0;\r\nfree:\r\nfree_netdev(dev);\r\nrelease:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ether3_remove(struct expansion_card *ec)\r\n{\r\nstruct net_device *dev = ecard_get_drvdata(ec);\r\necard_set_drvdata(ec, NULL);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init ether3_init(void)\r\n{\r\nreturn ecard_register_driver(&ether3_driver);\r\n}\r\nstatic void __exit ether3_exit(void)\r\n{\r\necard_remove_driver(&ether3_driver);\r\n}
