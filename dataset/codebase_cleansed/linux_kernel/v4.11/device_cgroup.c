static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)\r\n{\r\nreturn s ? container_of(s, struct dev_cgroup, css) : NULL;\r\n}\r\nstatic inline struct dev_cgroup *task_devcgroup(struct task_struct *task)\r\n{\r\nreturn css_to_devcgroup(task_css(task, devices_cgrp_id));\r\n}\r\nstatic int dev_exceptions_copy(struct list_head *dest, struct list_head *orig)\r\n{\r\nstruct dev_exception_item *ex, *tmp, *new;\r\nlockdep_assert_held(&devcgroup_mutex);\r\nlist_for_each_entry(ex, orig, list) {\r\nnew = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\r\nif (!new)\r\ngoto free_and_exit;\r\nlist_add_tail(&new->list, dest);\r\n}\r\nreturn 0;\r\nfree_and_exit:\r\nlist_for_each_entry_safe(ex, tmp, dest, list) {\r\nlist_del(&ex->list);\r\nkfree(ex);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int dev_exception_add(struct dev_cgroup *dev_cgroup,\r\nstruct dev_exception_item *ex)\r\n{\r\nstruct dev_exception_item *excopy, *walk;\r\nlockdep_assert_held(&devcgroup_mutex);\r\nexcopy = kmemdup(ex, sizeof(*ex), GFP_KERNEL);\r\nif (!excopy)\r\nreturn -ENOMEM;\r\nlist_for_each_entry(walk, &dev_cgroup->exceptions, list) {\r\nif (walk->type != ex->type)\r\ncontinue;\r\nif (walk->major != ex->major)\r\ncontinue;\r\nif (walk->minor != ex->minor)\r\ncontinue;\r\nwalk->access |= ex->access;\r\nkfree(excopy);\r\nexcopy = NULL;\r\n}\r\nif (excopy != NULL)\r\nlist_add_tail_rcu(&excopy->list, &dev_cgroup->exceptions);\r\nreturn 0;\r\n}\r\nstatic void dev_exception_rm(struct dev_cgroup *dev_cgroup,\r\nstruct dev_exception_item *ex)\r\n{\r\nstruct dev_exception_item *walk, *tmp;\r\nlockdep_assert_held(&devcgroup_mutex);\r\nlist_for_each_entry_safe(walk, tmp, &dev_cgroup->exceptions, list) {\r\nif (walk->type != ex->type)\r\ncontinue;\r\nif (walk->major != ex->major)\r\ncontinue;\r\nif (walk->minor != ex->minor)\r\ncontinue;\r\nwalk->access &= ~ex->access;\r\nif (!walk->access) {\r\nlist_del_rcu(&walk->list);\r\nkfree_rcu(walk, rcu);\r\n}\r\n}\r\n}\r\nstatic void __dev_exception_clean(struct dev_cgroup *dev_cgroup)\r\n{\r\nstruct dev_exception_item *ex, *tmp;\r\nlist_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {\r\nlist_del_rcu(&ex->list);\r\nkfree_rcu(ex, rcu);\r\n}\r\n}\r\nstatic void dev_exception_clean(struct dev_cgroup *dev_cgroup)\r\n{\r\nlockdep_assert_held(&devcgroup_mutex);\r\n__dev_exception_clean(dev_cgroup);\r\n}\r\nstatic inline bool is_devcg_online(const struct dev_cgroup *devcg)\r\n{\r\nreturn (devcg->behavior != DEVCG_DEFAULT_NONE);\r\n}\r\nstatic int devcgroup_online(struct cgroup_subsys_state *css)\r\n{\r\nstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\r\nstruct dev_cgroup *parent_dev_cgroup = css_to_devcgroup(css->parent);\r\nint ret = 0;\r\nmutex_lock(&devcgroup_mutex);\r\nif (parent_dev_cgroup == NULL)\r\ndev_cgroup->behavior = DEVCG_DEFAULT_ALLOW;\r\nelse {\r\nret = dev_exceptions_copy(&dev_cgroup->exceptions,\r\n&parent_dev_cgroup->exceptions);\r\nif (!ret)\r\ndev_cgroup->behavior = parent_dev_cgroup->behavior;\r\n}\r\nmutex_unlock(&devcgroup_mutex);\r\nreturn ret;\r\n}\r\nstatic void devcgroup_offline(struct cgroup_subsys_state *css)\r\n{\r\nstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\r\nmutex_lock(&devcgroup_mutex);\r\ndev_cgroup->behavior = DEVCG_DEFAULT_NONE;\r\nmutex_unlock(&devcgroup_mutex);\r\n}\r\nstatic struct cgroup_subsys_state *\r\ndevcgroup_css_alloc(struct cgroup_subsys_state *parent_css)\r\n{\r\nstruct dev_cgroup *dev_cgroup;\r\ndev_cgroup = kzalloc(sizeof(*dev_cgroup), GFP_KERNEL);\r\nif (!dev_cgroup)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&dev_cgroup->exceptions);\r\ndev_cgroup->behavior = DEVCG_DEFAULT_NONE;\r\nreturn &dev_cgroup->css;\r\n}\r\nstatic void devcgroup_css_free(struct cgroup_subsys_state *css)\r\n{\r\nstruct dev_cgroup *dev_cgroup = css_to_devcgroup(css);\r\n__dev_exception_clean(dev_cgroup);\r\nkfree(dev_cgroup);\r\n}\r\nstatic void set_access(char *acc, short access)\r\n{\r\nint idx = 0;\r\nmemset(acc, 0, ACCLEN);\r\nif (access & ACC_READ)\r\nacc[idx++] = 'r';\r\nif (access & ACC_WRITE)\r\nacc[idx++] = 'w';\r\nif (access & ACC_MKNOD)\r\nacc[idx++] = 'm';\r\n}\r\nstatic char type_to_char(short type)\r\n{\r\nif (type == DEV_ALL)\r\nreturn 'a';\r\nif (type == DEV_CHAR)\r\nreturn 'c';\r\nif (type == DEV_BLOCK)\r\nreturn 'b';\r\nreturn 'X';\r\n}\r\nstatic void set_majmin(char *str, unsigned m)\r\n{\r\nif (m == ~0)\r\nstrcpy(str, "*");\r\nelse\r\nsprintf(str, "%u", m);\r\n}\r\nstatic int devcgroup_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct dev_cgroup *devcgroup = css_to_devcgroup(seq_css(m));\r\nstruct dev_exception_item *ex;\r\nchar maj[MAJMINLEN], min[MAJMINLEN], acc[ACCLEN];\r\nrcu_read_lock();\r\nif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\r\nset_access(acc, ACC_MASK);\r\nset_majmin(maj, ~0);\r\nset_majmin(min, ~0);\r\nseq_printf(m, "%c %s:%s %s\n", type_to_char(DEV_ALL),\r\nmaj, min, acc);\r\n} else {\r\nlist_for_each_entry_rcu(ex, &devcgroup->exceptions, list) {\r\nset_access(acc, ex->access);\r\nset_majmin(maj, ex->major);\r\nset_majmin(min, ex->minor);\r\nseq_printf(m, "%c %s:%s %s\n", type_to_char(ex->type),\r\nmaj, min, acc);\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic bool match_exception(struct list_head *exceptions, short type,\r\nu32 major, u32 minor, short access)\r\n{\r\nstruct dev_exception_item *ex;\r\nlist_for_each_entry_rcu(ex, exceptions, list) {\r\nif ((type & DEV_BLOCK) && !(ex->type & DEV_BLOCK))\r\ncontinue;\r\nif ((type & DEV_CHAR) && !(ex->type & DEV_CHAR))\r\ncontinue;\r\nif (ex->major != ~0 && ex->major != major)\r\ncontinue;\r\nif (ex->minor != ~0 && ex->minor != minor)\r\ncontinue;\r\nif (access & (~ex->access))\r\ncontinue;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool match_exception_partial(struct list_head *exceptions, short type,\r\nu32 major, u32 minor, short access)\r\n{\r\nstruct dev_exception_item *ex;\r\nlist_for_each_entry_rcu(ex, exceptions, list) {\r\nif ((type & DEV_BLOCK) && !(ex->type & DEV_BLOCK))\r\ncontinue;\r\nif ((type & DEV_CHAR) && !(ex->type & DEV_CHAR))\r\ncontinue;\r\nif (ex->major != ~0 && major != ~0 && ex->major != major)\r\ncontinue;\r\nif (ex->minor != ~0 && minor != ~0 && ex->minor != minor)\r\ncontinue;\r\nif (!(access & ex->access))\r\ncontinue;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool verify_new_ex(struct dev_cgroup *dev_cgroup,\r\nstruct dev_exception_item *refex,\r\nenum devcg_behavior behavior)\r\n{\r\nbool match = false;\r\nRCU_LOCKDEP_WARN(!rcu_read_lock_held() &&\r\n!lockdep_is_held(&devcgroup_mutex),\r\n"device_cgroup:verify_new_ex called without proper synchronization");\r\nif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW) {\r\nif (behavior == DEVCG_DEFAULT_ALLOW) {\r\nreturn true;\r\n} else {\r\nmatch = match_exception_partial(&dev_cgroup->exceptions,\r\nrefex->type,\r\nrefex->major,\r\nrefex->minor,\r\nrefex->access);\r\nif (match)\r\nreturn false;\r\nreturn true;\r\n}\r\n} else {\r\nmatch = match_exception(&dev_cgroup->exceptions, refex->type,\r\nrefex->major, refex->minor,\r\nrefex->access);\r\nif (match)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic int parent_has_perm(struct dev_cgroup *childcg,\r\nstruct dev_exception_item *ex)\r\n{\r\nstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\r\nif (!parent)\r\nreturn 1;\r\nreturn verify_new_ex(parent, ex, childcg->behavior);\r\n}\r\nstatic bool parent_allows_removal(struct dev_cgroup *childcg,\r\nstruct dev_exception_item *ex)\r\n{\r\nstruct dev_cgroup *parent = css_to_devcgroup(childcg->css.parent);\r\nif (!parent)\r\nreturn true;\r\nif (childcg->behavior == DEVCG_DEFAULT_DENY)\r\nreturn true;\r\nreturn !match_exception_partial(&parent->exceptions, ex->type,\r\nex->major, ex->minor, ex->access);\r\n}\r\nstatic inline int may_allow_all(struct dev_cgroup *parent)\r\n{\r\nif (!parent)\r\nreturn 1;\r\nreturn parent->behavior == DEVCG_DEFAULT_ALLOW;\r\n}\r\nstatic void revalidate_active_exceptions(struct dev_cgroup *devcg)\r\n{\r\nstruct dev_exception_item *ex;\r\nstruct list_head *this, *tmp;\r\nlist_for_each_safe(this, tmp, &devcg->exceptions) {\r\nex = container_of(this, struct dev_exception_item, list);\r\nif (!parent_has_perm(devcg, ex))\r\ndev_exception_rm(devcg, ex);\r\n}\r\n}\r\nstatic int propagate_exception(struct dev_cgroup *devcg_root,\r\nstruct dev_exception_item *ex)\r\n{\r\nstruct cgroup_subsys_state *pos;\r\nint rc = 0;\r\nrcu_read_lock();\r\ncss_for_each_descendant_pre(pos, &devcg_root->css) {\r\nstruct dev_cgroup *devcg = css_to_devcgroup(pos);\r\nif (pos == &devcg_root->css || !is_devcg_online(devcg))\r\ncontinue;\r\nrcu_read_unlock();\r\nif (devcg_root->behavior == DEVCG_DEFAULT_ALLOW &&\r\ndevcg->behavior == DEVCG_DEFAULT_ALLOW) {\r\nrc = dev_exception_add(devcg, ex);\r\nif (rc)\r\nbreak;\r\n} else {\r\ndev_exception_rm(devcg, ex);\r\n}\r\nrevalidate_active_exceptions(devcg);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic int devcgroup_update_access(struct dev_cgroup *devcgroup,\r\nint filetype, char *buffer)\r\n{\r\nconst char *b;\r\nchar temp[12];\r\nint count, rc = 0;\r\nstruct dev_exception_item ex;\r\nstruct dev_cgroup *parent = css_to_devcgroup(devcgroup->css.parent);\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmemset(&ex, 0, sizeof(ex));\r\nb = buffer;\r\nswitch (*b) {\r\ncase 'a':\r\nswitch (filetype) {\r\ncase DEVCG_ALLOW:\r\nif (css_has_online_children(&devcgroup->css))\r\nreturn -EINVAL;\r\nif (!may_allow_all(parent))\r\nreturn -EPERM;\r\ndev_exception_clean(devcgroup);\r\ndevcgroup->behavior = DEVCG_DEFAULT_ALLOW;\r\nif (!parent)\r\nbreak;\r\nrc = dev_exceptions_copy(&devcgroup->exceptions,\r\n&parent->exceptions);\r\nif (rc)\r\nreturn rc;\r\nbreak;\r\ncase DEVCG_DENY:\r\nif (css_has_online_children(&devcgroup->css))\r\nreturn -EINVAL;\r\ndev_exception_clean(devcgroup);\r\ndevcgroup->behavior = DEVCG_DEFAULT_DENY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ncase 'b':\r\nex.type = DEV_BLOCK;\r\nbreak;\r\ncase 'c':\r\nex.type = DEV_CHAR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nb++;\r\nif (!isspace(*b))\r\nreturn -EINVAL;\r\nb++;\r\nif (*b == '*') {\r\nex.major = ~0;\r\nb++;\r\n} else if (isdigit(*b)) {\r\nmemset(temp, 0, sizeof(temp));\r\nfor (count = 0; count < sizeof(temp) - 1; count++) {\r\ntemp[count] = *b;\r\nb++;\r\nif (!isdigit(*b))\r\nbreak;\r\n}\r\nrc = kstrtou32(temp, 10, &ex.major);\r\nif (rc)\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (*b != ':')\r\nreturn -EINVAL;\r\nb++;\r\nif (*b == '*') {\r\nex.minor = ~0;\r\nb++;\r\n} else if (isdigit(*b)) {\r\nmemset(temp, 0, sizeof(temp));\r\nfor (count = 0; count < sizeof(temp) - 1; count++) {\r\ntemp[count] = *b;\r\nb++;\r\nif (!isdigit(*b))\r\nbreak;\r\n}\r\nrc = kstrtou32(temp, 10, &ex.minor);\r\nif (rc)\r\nreturn -EINVAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (!isspace(*b))\r\nreturn -EINVAL;\r\nfor (b++, count = 0; count < 3; count++, b++) {\r\nswitch (*b) {\r\ncase 'r':\r\nex.access |= ACC_READ;\r\nbreak;\r\ncase 'w':\r\nex.access |= ACC_WRITE;\r\nbreak;\r\ncase 'm':\r\nex.access |= ACC_MKNOD;\r\nbreak;\r\ncase '\n':\r\ncase '\0':\r\ncount = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (filetype) {\r\ncase DEVCG_ALLOW:\r\nif (devcgroup->behavior == DEVCG_DEFAULT_ALLOW) {\r\nif (!parent_allows_removal(devcgroup, &ex))\r\nreturn -EPERM;\r\ndev_exception_rm(devcgroup, &ex);\r\nbreak;\r\n}\r\nif (!parent_has_perm(devcgroup, &ex))\r\nreturn -EPERM;\r\nrc = dev_exception_add(devcgroup, &ex);\r\nbreak;\r\ncase DEVCG_DENY:\r\nif (devcgroup->behavior == DEVCG_DEFAULT_DENY)\r\ndev_exception_rm(devcgroup, &ex);\r\nelse\r\nrc = dev_exception_add(devcgroup, &ex);\r\nif (rc)\r\nbreak;\r\nrc = propagate_exception(devcgroup, &ex);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t devcgroup_access_write(struct kernfs_open_file *of,\r\nchar *buf, size_t nbytes, loff_t off)\r\n{\r\nint retval;\r\nmutex_lock(&devcgroup_mutex);\r\nretval = devcgroup_update_access(css_to_devcgroup(of_css(of)),\r\nof_cft(of)->private, strstrip(buf));\r\nmutex_unlock(&devcgroup_mutex);\r\nreturn retval ?: nbytes;\r\n}\r\nstatic int __devcgroup_check_permission(short type, u32 major, u32 minor,\r\nshort access)\r\n{\r\nstruct dev_cgroup *dev_cgroup;\r\nbool rc;\r\nrcu_read_lock();\r\ndev_cgroup = task_devcgroup(current);\r\nif (dev_cgroup->behavior == DEVCG_DEFAULT_ALLOW)\r\nrc = !match_exception_partial(&dev_cgroup->exceptions,\r\ntype, major, minor, access);\r\nelse\r\nrc = match_exception(&dev_cgroup->exceptions, type, major,\r\nminor, access);\r\nrcu_read_unlock();\r\nif (!rc)\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nint __devcgroup_inode_permission(struct inode *inode, int mask)\r\n{\r\nshort type, access = 0;\r\nif (S_ISBLK(inode->i_mode))\r\ntype = DEV_BLOCK;\r\nif (S_ISCHR(inode->i_mode))\r\ntype = DEV_CHAR;\r\nif (mask & MAY_WRITE)\r\naccess |= ACC_WRITE;\r\nif (mask & MAY_READ)\r\naccess |= ACC_READ;\r\nreturn __devcgroup_check_permission(type, imajor(inode), iminor(inode),\r\naccess);\r\n}\r\nint devcgroup_inode_mknod(int mode, dev_t dev)\r\n{\r\nshort type;\r\nif (!S_ISBLK(mode) && !S_ISCHR(mode))\r\nreturn 0;\r\nif (S_ISBLK(mode))\r\ntype = DEV_BLOCK;\r\nelse\r\ntype = DEV_CHAR;\r\nreturn __devcgroup_check_permission(type, MAJOR(dev), MINOR(dev),\r\nACC_MKNOD);\r\n}
