static int\r\nfcloop_parse_options(struct fcloop_ctrl_options *opts,\r\nconst char *buf)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nchar *options, *o, *p;\r\nint token, ret = 0;\r\nu64 token64;\r\noptions = o = kstrdup(buf, GFP_KERNEL);\r\nif (!options)\r\nreturn -ENOMEM;\r\nwhile ((p = strsep(&o, ",\n")) != NULL) {\r\nif (!*p)\r\ncontinue;\r\ntoken = match_token(p, opt_tokens, args);\r\nopts->mask |= token;\r\nswitch (token) {\r\ncase NVMF_OPT_WWNN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->wwnn = token64;\r\nbreak;\r\ncase NVMF_OPT_WWPN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->wwpn = token64;\r\nbreak;\r\ncase NVMF_OPT_ROLES:\r\nif (match_int(args, &token)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->roles = token;\r\nbreak;\r\ncase NVMF_OPT_FCADDR:\r\nif (match_hex(args, &token)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->fcaddr = token;\r\nbreak;\r\ncase NVMF_OPT_LPWWNN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->lpwwnn = token64;\r\nbreak;\r\ncase NVMF_OPT_LPWWPN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\nopts->lpwwpn = token64;\r\nbreak;\r\ndefault:\r\npr_warn("unknown parameter or missing value '%s'\n", p);\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\n}\r\nout_free_options:\r\nkfree(options);\r\nreturn ret;\r\n}\r\nstatic int\r\nfcloop_parse_nm_options(struct device *dev, u64 *nname, u64 *pname,\r\nconst char *buf)\r\n{\r\nsubstring_t args[MAX_OPT_ARGS];\r\nchar *options, *o, *p;\r\nint token, ret = 0;\r\nu64 token64;\r\n*nname = -1;\r\n*pname = -1;\r\noptions = o = kstrdup(buf, GFP_KERNEL);\r\nif (!options)\r\nreturn -ENOMEM;\r\nwhile ((p = strsep(&o, ",\n")) != NULL) {\r\nif (!*p)\r\ncontinue;\r\ntoken = match_token(p, opt_tokens, args);\r\nswitch (token) {\r\ncase NVMF_OPT_WWNN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\n*nname = token64;\r\nbreak;\r\ncase NVMF_OPT_WWPN:\r\nif (match_u64(args, &token64)) {\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\n*pname = token64;\r\nbreak;\r\ndefault:\r\npr_warn("unknown parameter or missing value '%s'\n", p);\r\nret = -EINVAL;\r\ngoto out_free_options;\r\n}\r\n}\r\nout_free_options:\r\nkfree(options);\r\nif (!ret) {\r\nif (*nname == -1)\r\nreturn -EINVAL;\r\nif (*pname == -1)\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline struct fcloop_lsreq *\r\ntgt_ls_req_to_lsreq(struct nvmefc_tgt_ls_req *tgt_lsreq)\r\n{\r\nreturn container_of(tgt_lsreq, struct fcloop_lsreq, tgt_ls_req);\r\n}\r\nstatic inline struct fcloop_fcpreq *\r\ntgt_fcp_req_to_fcpreq(struct nvmefc_tgt_fcp_req *tgt_fcpreq)\r\n{\r\nreturn container_of(tgt_fcpreq, struct fcloop_fcpreq, tgt_fcp_req);\r\n}\r\nstatic int\r\nfcloop_create_queue(struct nvme_fc_local_port *localport,\r\nunsigned int qidx, u16 qsize,\r\nvoid **handle)\r\n{\r\n*handle = localport;\r\nreturn 0;\r\n}\r\nstatic void\r\nfcloop_delete_queue(struct nvme_fc_local_port *localport,\r\nunsigned int idx, void *handle)\r\n{\r\n}\r\nstatic void\r\nfcloop_tgt_lsrqst_done_work(struct work_struct *work)\r\n{\r\nstruct fcloop_lsreq *tls_req =\r\ncontainer_of(work, struct fcloop_lsreq, work);\r\nstruct fcloop_tport *tport = tls_req->tport;\r\nstruct nvmefc_ls_req *lsreq = tls_req->lsreq;\r\nif (tport->remoteport)\r\nlsreq->done(lsreq, tls_req->status);\r\n}\r\nstatic int\r\nfcloop_ls_req(struct nvme_fc_local_port *localport,\r\nstruct nvme_fc_remote_port *remoteport,\r\nstruct nvmefc_ls_req *lsreq)\r\n{\r\nstruct fcloop_lsreq *tls_req = lsreq->private;\r\nstruct fcloop_rport *rport = remoteport->private;\r\nint ret = 0;\r\ntls_req->lsreq = lsreq;\r\nINIT_WORK(&tls_req->work, fcloop_tgt_lsrqst_done_work);\r\nif (!rport->targetport) {\r\ntls_req->status = -ECONNREFUSED;\r\nschedule_work(&tls_req->work);\r\nreturn ret;\r\n}\r\ntls_req->status = 0;\r\ntls_req->tport = rport->targetport->private;\r\nret = nvmet_fc_rcv_ls_req(rport->targetport, &tls_req->tgt_ls_req,\r\nlsreq->rqstaddr, lsreq->rqstlen);\r\nreturn ret;\r\n}\r\nstatic int\r\nfcloop_xmt_ls_rsp(struct nvmet_fc_target_port *tport,\r\nstruct nvmefc_tgt_ls_req *tgt_lsreq)\r\n{\r\nstruct fcloop_lsreq *tls_req = tgt_ls_req_to_lsreq(tgt_lsreq);\r\nstruct nvmefc_ls_req *lsreq = tls_req->lsreq;\r\nmemcpy(lsreq->rspaddr, tgt_lsreq->rspbuf,\r\n((lsreq->rsplen < tgt_lsreq->rsplen) ?\r\nlsreq->rsplen : tgt_lsreq->rsplen));\r\ntgt_lsreq->done(tgt_lsreq);\r\nschedule_work(&tls_req->work);\r\nreturn 0;\r\n}\r\nstatic void\r\nfcloop_tgt_fcprqst_done_work(struct work_struct *work)\r\n{\r\nstruct fcloop_fcpreq *tfcp_req =\r\ncontainer_of(work, struct fcloop_fcpreq, work);\r\nstruct fcloop_tport *tport = tfcp_req->tport;\r\nstruct nvmefc_fcp_req *fcpreq = tfcp_req->fcpreq;\r\nif (tport->remoteport) {\r\nfcpreq->status = tfcp_req->status;\r\nfcpreq->done(fcpreq);\r\n}\r\n}\r\nstatic int\r\nfcloop_fcp_req(struct nvme_fc_local_port *localport,\r\nstruct nvme_fc_remote_port *remoteport,\r\nvoid *hw_queue_handle,\r\nstruct nvmefc_fcp_req *fcpreq)\r\n{\r\nstruct fcloop_fcpreq *tfcp_req = fcpreq->private;\r\nstruct fcloop_rport *rport = remoteport->private;\r\nint ret = 0;\r\nINIT_WORK(&tfcp_req->work, fcloop_tgt_fcprqst_done_work);\r\nif (!rport->targetport) {\r\ntfcp_req->status = NVME_SC_FC_TRANSPORT_ERROR;\r\nschedule_work(&tfcp_req->work);\r\nreturn ret;\r\n}\r\ntfcp_req->fcpreq = fcpreq;\r\ntfcp_req->tport = rport->targetport->private;\r\nret = nvmet_fc_rcv_fcp_req(rport->targetport, &tfcp_req->tgt_fcp_req,\r\nfcpreq->cmdaddr, fcpreq->cmdlen);\r\nreturn ret;\r\n}\r\nstatic void\r\nfcloop_fcp_copy_data(u8 op, struct scatterlist *data_sg,\r\nstruct scatterlist *io_sg, u32 offset, u32 length)\r\n{\r\nvoid *data_p, *io_p;\r\nu32 data_len, io_len, tlen;\r\nio_p = sg_virt(io_sg);\r\nio_len = io_sg->length;\r\nfor ( ; offset; ) {\r\ntlen = min_t(u32, offset, io_len);\r\noffset -= tlen;\r\nio_len -= tlen;\r\nif (!io_len) {\r\nio_sg = sg_next(io_sg);\r\nio_p = sg_virt(io_sg);\r\nio_len = io_sg->length;\r\n} else\r\nio_p += tlen;\r\n}\r\ndata_p = sg_virt(data_sg);\r\ndata_len = data_sg->length;\r\nfor ( ; length; ) {\r\ntlen = min_t(u32, io_len, data_len);\r\ntlen = min_t(u32, tlen, length);\r\nif (op == NVMET_FCOP_WRITEDATA)\r\nmemcpy(data_p, io_p, tlen);\r\nelse\r\nmemcpy(io_p, data_p, tlen);\r\nlength -= tlen;\r\nio_len -= tlen;\r\nif ((!io_len) && (length)) {\r\nio_sg = sg_next(io_sg);\r\nio_p = sg_virt(io_sg);\r\nio_len = io_sg->length;\r\n} else\r\nio_p += tlen;\r\ndata_len -= tlen;\r\nif ((!data_len) && (length)) {\r\ndata_sg = sg_next(data_sg);\r\ndata_p = sg_virt(data_sg);\r\ndata_len = data_sg->length;\r\n} else\r\ndata_p += tlen;\r\n}\r\n}\r\nstatic int\r\nfcloop_fcp_op(struct nvmet_fc_target_port *tgtport,\r\nstruct nvmefc_tgt_fcp_req *tgt_fcpreq)\r\n{\r\nstruct fcloop_fcpreq *tfcp_req = tgt_fcp_req_to_fcpreq(tgt_fcpreq);\r\nstruct nvmefc_fcp_req *fcpreq = tfcp_req->fcpreq;\r\nu32 rsplen = 0, xfrlen = 0;\r\nint fcp_err = 0;\r\nu8 op = tgt_fcpreq->op;\r\nswitch (op) {\r\ncase NVMET_FCOP_WRITEDATA:\r\nxfrlen = tgt_fcpreq->transfer_length;\r\nfcloop_fcp_copy_data(op, tgt_fcpreq->sg, fcpreq->first_sgl,\r\ntgt_fcpreq->offset, xfrlen);\r\nfcpreq->transferred_length += xfrlen;\r\nbreak;\r\ncase NVMET_FCOP_READDATA:\r\ncase NVMET_FCOP_READDATA_RSP:\r\nxfrlen = tgt_fcpreq->transfer_length;\r\nfcloop_fcp_copy_data(op, tgt_fcpreq->sg, fcpreq->first_sgl,\r\ntgt_fcpreq->offset, xfrlen);\r\nfcpreq->transferred_length += xfrlen;\r\nif (op == NVMET_FCOP_READDATA)\r\nbreak;\r\ncase NVMET_FCOP_RSP:\r\nrsplen = ((fcpreq->rsplen < tgt_fcpreq->rsplen) ?\r\nfcpreq->rsplen : tgt_fcpreq->rsplen);\r\nmemcpy(fcpreq->rspaddr, tgt_fcpreq->rspaddr, rsplen);\r\nif (rsplen < tgt_fcpreq->rsplen)\r\nfcp_err = -E2BIG;\r\nfcpreq->rcv_rsplen = rsplen;\r\nfcpreq->status = 0;\r\ntfcp_req->status = 0;\r\nbreak;\r\ncase NVMET_FCOP_ABORT:\r\ntfcp_req->status = NVME_SC_FC_TRANSPORT_ABORTED;\r\nbreak;\r\ndefault:\r\nfcp_err = -EINVAL;\r\nbreak;\r\n}\r\ntgt_fcpreq->transferred_length = xfrlen;\r\ntgt_fcpreq->fcp_error = fcp_err;\r\ntgt_fcpreq->done(tgt_fcpreq);\r\nif ((!fcp_err) && (op == NVMET_FCOP_RSP ||\r\nop == NVMET_FCOP_READDATA_RSP ||\r\nop == NVMET_FCOP_ABORT))\r\nschedule_work(&tfcp_req->work);\r\nreturn 0;\r\n}\r\nstatic void\r\nfcloop_ls_abort(struct nvme_fc_local_port *localport,\r\nstruct nvme_fc_remote_port *remoteport,\r\nstruct nvmefc_ls_req *lsreq)\r\n{\r\n}\r\nstatic void\r\nfcloop_fcp_abort(struct nvme_fc_local_port *localport,\r\nstruct nvme_fc_remote_port *remoteport,\r\nvoid *hw_queue_handle,\r\nstruct nvmefc_fcp_req *fcpreq)\r\n{\r\n}\r\nstatic void\r\nfcloop_localport_delete(struct nvme_fc_local_port *localport)\r\n{\r\nstruct fcloop_lport *lport = localport->private;\r\ncomplete(&lport->unreg_done);\r\n}\r\nstatic void\r\nfcloop_remoteport_delete(struct nvme_fc_remote_port *remoteport)\r\n{\r\nstruct fcloop_rport *rport = remoteport->private;\r\ncomplete(&rport->nport->rport_unreg_done);\r\n}\r\nstatic void\r\nfcloop_targetport_delete(struct nvmet_fc_target_port *targetport)\r\n{\r\nstruct fcloop_tport *tport = targetport->private;\r\ncomplete(&tport->nport->tport_unreg_done);\r\n}\r\nstatic ssize_t\r\nfcloop_create_local_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nvme_fc_port_info pinfo;\r\nstruct fcloop_ctrl_options *opts;\r\nstruct nvme_fc_local_port *localport;\r\nstruct fcloop_lport *lport;\r\nint ret;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn -ENOMEM;\r\nret = fcloop_parse_options(opts, buf);\r\nif (ret)\r\ngoto out_free_opts;\r\nif ((opts->mask & LPORT_OPTS) != LPORT_OPTS) {\r\nret = -EINVAL;\r\ngoto out_free_opts;\r\n}\r\npinfo.node_name = opts->wwnn;\r\npinfo.port_name = opts->wwpn;\r\npinfo.port_role = opts->roles;\r\npinfo.port_id = opts->fcaddr;\r\nret = nvme_fc_register_localport(&pinfo, &fctemplate, NULL, &localport);\r\nif (!ret) {\r\nunsigned long flags;\r\nlport = localport->private;\r\nlport->localport = localport;\r\nINIT_LIST_HEAD(&lport->lport_list);\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_add_tail(&lport->lport_list, &fcloop_lports);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nret = count;\r\n}\r\nout_free_opts:\r\nkfree(opts);\r\nreturn ret ? ret : count;\r\n}\r\nstatic void\r\n__unlink_local_port(struct fcloop_lport *lport)\r\n{\r\nlist_del(&lport->lport_list);\r\n}\r\nstatic int\r\n__wait_localport_unreg(struct fcloop_lport *lport)\r\n{\r\nint ret;\r\ninit_completion(&lport->unreg_done);\r\nret = nvme_fc_unregister_localport(lport->localport);\r\nwait_for_completion(&lport->unreg_done);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nfcloop_delete_local_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcloop_lport *tlport, *lport = NULL;\r\nu64 nodename, portname;\r\nunsigned long flags;\r\nint ret;\r\nret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_for_each_entry(tlport, &fcloop_lports, lport_list) {\r\nif (tlport->localport->node_name == nodename &&\r\ntlport->localport->port_name == portname) {\r\nlport = tlport;\r\n__unlink_local_port(lport);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nif (!lport)\r\nreturn -ENOENT;\r\nret = __wait_localport_unreg(lport);\r\nreturn ret ? ret : count;\r\n}\r\nstatic void\r\nfcloop_nport_free(struct kref *ref)\r\n{\r\nstruct fcloop_nport *nport =\r\ncontainer_of(ref, struct fcloop_nport, ref);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_del(&nport->nport_list);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nkfree(nport);\r\n}\r\nstatic void\r\nfcloop_nport_put(struct fcloop_nport *nport)\r\n{\r\nkref_put(&nport->ref, fcloop_nport_free);\r\n}\r\nstatic int\r\nfcloop_nport_get(struct fcloop_nport *nport)\r\n{\r\nreturn kref_get_unless_zero(&nport->ref);\r\n}\r\nstatic struct fcloop_nport *\r\nfcloop_alloc_nport(const char *buf, size_t count, bool remoteport)\r\n{\r\nstruct fcloop_nport *newnport, *nport = NULL;\r\nstruct fcloop_lport *tmplport, *lport = NULL;\r\nstruct fcloop_ctrl_options *opts;\r\nunsigned long flags;\r\nu32 opts_mask = (remoteport) ? RPORT_OPTS : TGTPORT_OPTS;\r\nint ret;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn NULL;\r\nret = fcloop_parse_options(opts, buf);\r\nif (ret)\r\ngoto out_free_opts;\r\nif ((opts->mask & opts_mask) != opts_mask) {\r\nret = -EINVAL;\r\ngoto out_free_opts;\r\n}\r\nnewnport = kzalloc(sizeof(*newnport), GFP_KERNEL);\r\nif (!newnport)\r\ngoto out_free_opts;\r\nINIT_LIST_HEAD(&newnport->nport_list);\r\nnewnport->node_name = opts->wwnn;\r\nnewnport->port_name = opts->wwpn;\r\nif (opts->mask & NVMF_OPT_ROLES)\r\nnewnport->port_role = opts->roles;\r\nif (opts->mask & NVMF_OPT_FCADDR)\r\nnewnport->port_id = opts->fcaddr;\r\nkref_init(&newnport->ref);\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_for_each_entry(tmplport, &fcloop_lports, lport_list) {\r\nif (tmplport->localport->node_name == opts->wwnn &&\r\ntmplport->localport->port_name == opts->wwpn)\r\ngoto out_invalid_opts;\r\nif (tmplport->localport->node_name == opts->lpwwnn &&\r\ntmplport->localport->port_name == opts->lpwwpn)\r\nlport = tmplport;\r\n}\r\nif (remoteport) {\r\nif (!lport)\r\ngoto out_invalid_opts;\r\nnewnport->lport = lport;\r\n}\r\nlist_for_each_entry(nport, &fcloop_nports, nport_list) {\r\nif (nport->node_name == opts->wwnn &&\r\nnport->port_name == opts->wwpn) {\r\nif ((remoteport && nport->rport) ||\r\n(!remoteport && nport->tport)) {\r\nnport = NULL;\r\ngoto out_invalid_opts;\r\n}\r\nfcloop_nport_get(nport);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nif (remoteport)\r\nnport->lport = lport;\r\nif (opts->mask & NVMF_OPT_ROLES)\r\nnport->port_role = opts->roles;\r\nif (opts->mask & NVMF_OPT_FCADDR)\r\nnport->port_id = opts->fcaddr;\r\ngoto out_free_newnport;\r\n}\r\n}\r\nlist_add_tail(&newnport->nport_list, &fcloop_nports);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nkfree(opts);\r\nreturn newnport;\r\nout_invalid_opts:\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nout_free_newnport:\r\nkfree(newnport);\r\nout_free_opts:\r\nkfree(opts);\r\nreturn nport;\r\n}\r\nstatic ssize_t\r\nfcloop_create_remote_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nvme_fc_remote_port *remoteport;\r\nstruct fcloop_nport *nport;\r\nstruct fcloop_rport *rport;\r\nstruct nvme_fc_port_info pinfo;\r\nint ret;\r\nnport = fcloop_alloc_nport(buf, count, true);\r\nif (!nport)\r\nreturn -EIO;\r\npinfo.node_name = nport->node_name;\r\npinfo.port_name = nport->port_name;\r\npinfo.port_role = nport->port_role;\r\npinfo.port_id = nport->port_id;\r\nret = nvme_fc_register_remoteport(nport->lport->localport,\r\n&pinfo, &remoteport);\r\nif (ret || !remoteport) {\r\nfcloop_nport_put(nport);\r\nreturn ret;\r\n}\r\nrport = remoteport->private;\r\nrport->remoteport = remoteport;\r\nrport->targetport = (nport->tport) ? nport->tport->targetport : NULL;\r\nif (nport->tport) {\r\nnport->tport->remoteport = remoteport;\r\nnport->tport->lport = nport->lport;\r\n}\r\nrport->nport = nport;\r\nrport->lport = nport->lport;\r\nnport->rport = rport;\r\nreturn count;\r\n}\r\nstatic struct fcloop_rport *\r\n__unlink_remote_port(struct fcloop_nport *nport)\r\n{\r\nstruct fcloop_rport *rport = nport->rport;\r\nif (rport && nport->tport)\r\nnport->tport->remoteport = NULL;\r\nnport->rport = NULL;\r\nreturn rport;\r\n}\r\nstatic int\r\n__wait_remoteport_unreg(struct fcloop_nport *nport, struct fcloop_rport *rport)\r\n{\r\nint ret;\r\nif (!rport)\r\nreturn -EALREADY;\r\ninit_completion(&nport->rport_unreg_done);\r\nret = nvme_fc_unregister_remoteport(rport->remoteport);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&nport->rport_unreg_done);\r\nfcloop_nport_put(nport);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nfcloop_delete_remote_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcloop_nport *nport = NULL, *tmpport;\r\nstatic struct fcloop_rport *rport;\r\nu64 nodename, portname;\r\nunsigned long flags;\r\nint ret;\r\nret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_for_each_entry(tmpport, &fcloop_nports, nport_list) {\r\nif (tmpport->node_name == nodename &&\r\ntmpport->port_name == portname && tmpport->rport) {\r\nnport = tmpport;\r\nrport = __unlink_remote_port(nport);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nif (!nport)\r\nreturn -ENOENT;\r\nret = __wait_remoteport_unreg(nport, rport);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t\r\nfcloop_create_target_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct nvmet_fc_target_port *targetport;\r\nstruct fcloop_nport *nport;\r\nstruct fcloop_tport *tport;\r\nstruct nvmet_fc_port_info tinfo;\r\nint ret;\r\nnport = fcloop_alloc_nport(buf, count, false);\r\nif (!nport)\r\nreturn -EIO;\r\ntinfo.node_name = nport->node_name;\r\ntinfo.port_name = nport->port_name;\r\ntinfo.port_id = nport->port_id;\r\nret = nvmet_fc_register_targetport(&tinfo, &tgttemplate, NULL,\r\n&targetport);\r\nif (ret) {\r\nfcloop_nport_put(nport);\r\nreturn ret;\r\n}\r\ntport = targetport->private;\r\ntport->targetport = targetport;\r\ntport->remoteport = (nport->rport) ? nport->rport->remoteport : NULL;\r\nif (nport->rport)\r\nnport->rport->targetport = targetport;\r\ntport->nport = nport;\r\ntport->lport = nport->lport;\r\nnport->tport = tport;\r\nreturn count;\r\n}\r\nstatic struct fcloop_tport *\r\n__unlink_target_port(struct fcloop_nport *nport)\r\n{\r\nstruct fcloop_tport *tport = nport->tport;\r\nif (tport && nport->rport)\r\nnport->rport->targetport = NULL;\r\nnport->tport = NULL;\r\nreturn tport;\r\n}\r\nstatic int\r\n__wait_targetport_unreg(struct fcloop_nport *nport, struct fcloop_tport *tport)\r\n{\r\nint ret;\r\nif (!tport)\r\nreturn -EALREADY;\r\ninit_completion(&nport->tport_unreg_done);\r\nret = nvmet_fc_unregister_targetport(tport->targetport);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&nport->tport_unreg_done);\r\nfcloop_nport_put(nport);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nfcloop_delete_target_port(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fcloop_nport *nport = NULL, *tmpport;\r\nstruct fcloop_tport *tport;\r\nu64 nodename, portname;\r\nunsigned long flags;\r\nint ret;\r\nret = fcloop_parse_nm_options(dev, &nodename, &portname, buf);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nlist_for_each_entry(tmpport, &fcloop_nports, nport_list) {\r\nif (tmpport->node_name == nodename &&\r\ntmpport->port_name == portname && tmpport->tport) {\r\nnport = tmpport;\r\ntport = __unlink_target_port(nport);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nif (!nport)\r\nreturn -ENOENT;\r\nret = __wait_targetport_unreg(nport, tport);\r\nreturn ret ? ret : count;\r\n}\r\nstatic int __init fcloop_init(void)\r\n{\r\nint ret;\r\nfcloop_class = class_create(THIS_MODULE, "fcloop");\r\nif (IS_ERR(fcloop_class)) {\r\npr_err("couldn't register class fcloop\n");\r\nret = PTR_ERR(fcloop_class);\r\nreturn ret;\r\n}\r\nfcloop_device = device_create_with_groups(\r\nfcloop_class, NULL, MKDEV(0, 0), NULL,\r\nfcloop_dev_attr_groups, "ctl");\r\nif (IS_ERR(fcloop_device)) {\r\npr_err("couldn't create ctl device!\n");\r\nret = PTR_ERR(fcloop_device);\r\ngoto out_destroy_class;\r\n}\r\nget_device(fcloop_device);\r\nreturn 0;\r\nout_destroy_class:\r\nclass_destroy(fcloop_class);\r\nreturn ret;\r\n}\r\nstatic void __exit fcloop_exit(void)\r\n{\r\nstruct fcloop_lport *lport;\r\nstruct fcloop_nport *nport;\r\nstruct fcloop_tport *tport;\r\nstruct fcloop_rport *rport;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\nfor (;;) {\r\nnport = list_first_entry_or_null(&fcloop_nports,\r\ntypeof(*nport), nport_list);\r\nif (!nport)\r\nbreak;\r\ntport = __unlink_target_port(nport);\r\nrport = __unlink_remote_port(nport);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nret = __wait_targetport_unreg(nport, tport);\r\nif (ret)\r\npr_warn("%s: Failed deleting target port\n", __func__);\r\nret = __wait_remoteport_unreg(nport, rport);\r\nif (ret)\r\npr_warn("%s: Failed deleting remote port\n", __func__);\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\n}\r\nfor (;;) {\r\nlport = list_first_entry_or_null(&fcloop_lports,\r\ntypeof(*lport), lport_list);\r\nif (!lport)\r\nbreak;\r\n__unlink_local_port(lport);\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nret = __wait_localport_unreg(lport);\r\nif (ret)\r\npr_warn("%s: Failed deleting local port\n", __func__);\r\nspin_lock_irqsave(&fcloop_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&fcloop_lock, flags);\r\nput_device(fcloop_device);\r\ndevice_destroy(fcloop_class, MKDEV(0, 0));\r\nclass_destroy(fcloop_class);\r\n}
