static int lpc24xx_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\r\nrtc_writel(rtc, LPC24XX_CCR, LPC178X_CCALEN);\r\nrtc_writel(rtc, LPC24XX_SEC, tm->tm_sec);\r\nrtc_writel(rtc, LPC24XX_MIN, tm->tm_min);\r\nrtc_writel(rtc, LPC24XX_HOUR, tm->tm_hour);\r\nrtc_writel(rtc, LPC24XX_DOW, tm->tm_wday);\r\nrtc_writel(rtc, LPC24XX_DOM, tm->tm_mday);\r\nrtc_writel(rtc, LPC24XX_DOY, tm->tm_yday);\r\nrtc_writel(rtc, LPC24XX_MONTH, tm->tm_mon);\r\nrtc_writel(rtc, LPC24XX_YEAR, tm->tm_year);\r\nrtc_writel(rtc, LPC24XX_CCR, LPC24XX_CLKEN | LPC178X_CCALEN);\r\nreturn 0;\r\n}\r\nstatic int lpc24xx_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\r\nu32 ct0, ct1, ct2;\r\nct0 = rtc_readl(rtc, LPC24XX_CTIME0);\r\nct1 = rtc_readl(rtc, LPC24XX_CTIME1);\r\nct2 = rtc_readl(rtc, LPC24XX_CTIME2);\r\ntm->tm_sec = CT0_SECS(ct0);\r\ntm->tm_min = CT0_MINS(ct0);\r\ntm->tm_hour = CT0_HOURS(ct0);\r\ntm->tm_wday = CT0_DOW(ct0);\r\ntm->tm_mon = CT1_MONTH(ct1);\r\ntm->tm_mday = CT1_DOM(ct1);\r\ntm->tm_year = CT1_YEAR(ct1);\r\ntm->tm_yday = CT2_DOY(ct2);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int lpc24xx_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &wkalrm->time;\r\ntm->tm_sec = rtc_readl(rtc, LPC24XX_ALSEC);\r\ntm->tm_min = rtc_readl(rtc, LPC24XX_ALMIN);\r\ntm->tm_hour = rtc_readl(rtc, LPC24XX_ALHOUR);\r\ntm->tm_mday = rtc_readl(rtc, LPC24XX_ALDOM);\r\ntm->tm_wday = rtc_readl(rtc, LPC24XX_ALDOW);\r\ntm->tm_yday = rtc_readl(rtc, LPC24XX_ALDOY);\r\ntm->tm_mon = rtc_readl(rtc, LPC24XX_ALMON);\r\ntm->tm_year = rtc_readl(rtc, LPC24XX_ALYEAR);\r\nwkalrm->enabled = rtc_readl(rtc, LPC24XX_AMR) == 0;\r\nwkalrm->pending = !!(rtc_readl(rtc, LPC24XX_ILR) & LPC24XX_RTCCIF);\r\nreturn rtc_valid_tm(&wkalrm->time);\r\n}\r\nstatic int lpc24xx_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &wkalrm->time;\r\nrtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\r\nrtc_writel(rtc, LPC24XX_ALSEC, tm->tm_sec);\r\nrtc_writel(rtc, LPC24XX_ALMIN, tm->tm_min);\r\nrtc_writel(rtc, LPC24XX_ALHOUR, tm->tm_hour);\r\nrtc_writel(rtc, LPC24XX_ALDOM, tm->tm_mday);\r\nrtc_writel(rtc, LPC24XX_ALDOW, tm->tm_wday);\r\nrtc_writel(rtc, LPC24XX_ALDOY, tm->tm_yday);\r\nrtc_writel(rtc, LPC24XX_ALMON, tm->tm_mon);\r\nrtc_writel(rtc, LPC24XX_ALYEAR, tm->tm_year);\r\nif (wkalrm->enabled)\r\nrtc_writel(rtc, LPC24XX_AMR, 0);\r\nreturn 0;\r\n}\r\nstatic int lpc24xx_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct lpc24xx_rtc *rtc = dev_get_drvdata(dev);\r\nif (enable)\r\nrtc_writel(rtc, LPC24XX_AMR, 0);\r\nelse\r\nrtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lpc24xx_rtc_interrupt(int irq, void *data)\r\n{\r\nunsigned long events = RTC_IRQF;\r\nstruct lpc24xx_rtc *rtc = data;\r\nu32 rtc_iir;\r\nrtc_iir = rtc_readl(rtc, LPC24XX_ILR);\r\nif (rtc_iir & LPC24XX_RTCALF) {\r\nevents |= RTC_AF;\r\nrtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\r\n}\r\nrtc_writel(rtc, LPC24XX_ILR, rtc_iir);\r\nrtc_update_irq(rtc->rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc24xx_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc24xx_rtc *rtc;\r\nstruct resource *res;\r\nint irq, ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->rtc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->rtc_base))\r\nreturn PTR_ERR(rtc->rtc_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "can't get interrupt resource\n");\r\nreturn irq;\r\n}\r\nrtc->clk_rtc = devm_clk_get(&pdev->dev, "rtc");\r\nif (IS_ERR(rtc->clk_rtc)) {\r\ndev_err(&pdev->dev, "error getting rtc clock\n");\r\nreturn PTR_ERR(rtc->clk_rtc);\r\n}\r\nrtc->clk_reg = devm_clk_get(&pdev->dev, "reg");\r\nif (IS_ERR(rtc->clk_reg)) {\r\ndev_err(&pdev->dev, "error getting reg clock\n");\r\nreturn PTR_ERR(rtc->clk_reg);\r\n}\r\nret = clk_prepare_enable(rtc->clk_rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable rtc clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(rtc->clk_reg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable reg clock\n");\r\ngoto disable_rtc_clk;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc_writel(rtc, LPC24XX_ILR, LPC24XX_RTCCIF | LPC24XX_RTCALF);\r\nrtc_writel(rtc, LPC24XX_CCR, LPC24XX_CLKEN | LPC178X_CCALEN);\r\nret = devm_request_irq(&pdev->dev, irq, lpc24xx_rtc_interrupt, 0,\r\npdev->name, rtc);\r\nif (ret < 0) {\r\ndev_warn(&pdev->dev, "can't request interrupt\n");\r\ngoto disable_clks;\r\n}\r\nrtc->rtc = devm_rtc_device_register(&pdev->dev, "lpc24xx-rtc",\r\n&lpc24xx_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\ndev_err(&pdev->dev, "can't register rtc device\n");\r\nret = PTR_ERR(rtc->rtc);\r\ngoto disable_clks;\r\n}\r\nreturn 0;\r\ndisable_clks:\r\nclk_disable_unprepare(rtc->clk_reg);\r\ndisable_rtc_clk:\r\nclk_disable_unprepare(rtc->clk_rtc);\r\nreturn ret;\r\n}\r\nstatic int lpc24xx_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc24xx_rtc *rtc = platform_get_drvdata(pdev);\r\nrtc_writel(rtc, LPC24XX_AMR, LPC24XX_ALARM_DISABLE);\r\nrtc_writel(rtc, LPC24XX_CIIR, 0);\r\nrtc_writel(rtc, LPC24XX_CCR, LPC178X_CCALEN);\r\nclk_disable_unprepare(rtc->clk_rtc);\r\nclk_disable_unprepare(rtc->clk_reg);\r\nreturn 0;\r\n}
