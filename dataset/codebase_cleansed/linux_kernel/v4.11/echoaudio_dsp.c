static int wait_handshake(struct echoaudio *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < HANDSHAKE_TIMEOUT; i++) {\r\nbarrier();\r\nif (chip->comm_page->handshake) {\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ndev_err(chip->card->dev, "wait_handshake(): Timeout waiting for DSP\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int send_vector(struct echoaudio *chip, u32 command)\r\n{\r\nint i;\r\nwmb();\r\nfor (i = 0; i < VECTOR_BUSY_TIMEOUT; i++) {\r\nif (!(get_dsp_register(chip, CHI32_VECTOR_REG) &\r\nCHI32_VECTOR_BUSY)) {\r\nset_dsp_register(chip, CHI32_VECTOR_REG, command);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ndev_err(chip->card->dev, "timeout on send_vector\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int write_dsp(struct echoaudio *chip, u32 data)\r\n{\r\nu32 status, i;\r\nfor (i = 0; i < 10000000; i++) {\r\nstatus = get_dsp_register(chip, CHI32_STATUS_REG);\r\nif ((status & CHI32_STATUS_HOST_WRITE_EMPTY) != 0) {\r\nset_dsp_register(chip, CHI32_DATA_REG, data);\r\nwmb();\r\nreturn 0;\r\n}\r\nudelay(1);\r\ncond_resched();\r\n}\r\nchip->bad_board = true;\r\ndev_dbg(chip->card->dev, "write_dsp: Set bad_board to true\n");\r\nreturn -EIO;\r\n}\r\nstatic int read_dsp(struct echoaudio *chip, u32 *data)\r\n{\r\nu32 status, i;\r\nfor (i = 0; i < READ_DSP_TIMEOUT; i++) {\r\nstatus = get_dsp_register(chip, CHI32_STATUS_REG);\r\nif ((status & CHI32_STATUS_HOST_READ_FULL) != 0) {\r\n*data = get_dsp_register(chip, CHI32_DATA_REG);\r\nreturn 0;\r\n}\r\nudelay(1);\r\ncond_resched();\r\n}\r\nchip->bad_board = true;\r\ndev_err(chip->card->dev, "read_dsp: Set bad_board to true\n");\r\nreturn -EIO;\r\n}\r\nstatic int read_sn(struct echoaudio *chip)\r\n{\r\nint i;\r\nu32 sn[6];\r\nfor (i = 0; i < 5; i++) {\r\nif (read_dsp(chip, &sn[i])) {\r\ndev_err(chip->card->dev,\r\n"Failed to read serial number\n");\r\nreturn -EIO;\r\n}\r\n}\r\ndev_dbg(chip->card->dev,\r\n"Read serial number %08x %08x %08x %08x %08x\n",\r\nsn[0], sn[1], sn[2], sn[3], sn[4]);\r\nreturn 0;\r\n}\r\nstatic inline int check_asic_status(struct echoaudio *chip)\r\n{\r\nchip->asic_loaded = true;\r\nreturn 0;\r\n}\r\nstatic int load_asic_generic(struct echoaudio *chip, u32 cmd, short asic)\r\n{\r\nconst struct firmware *fw;\r\nint err;\r\nu32 i, size;\r\nu8 *code;\r\nerr = get_firmware(&fw, chip, asic);\r\nif (err < 0) {\r\ndev_warn(chip->card->dev, "Firmware not found !\n");\r\nreturn err;\r\n}\r\ncode = (u8 *)fw->data;\r\nsize = fw->size;\r\nif (write_dsp(chip, cmd) < 0)\r\ngoto la_error;\r\nif (write_dsp(chip, size) < 0)\r\ngoto la_error;\r\nfor (i = 0; i < size; i++) {\r\nif (write_dsp(chip, code[i]) < 0)\r\ngoto la_error;\r\n}\r\nfree_firmware(fw, chip);\r\nreturn 0;\r\nla_error:\r\ndev_err(chip->card->dev, "failed on write_dsp\n");\r\nfree_firmware(fw, chip);\r\nreturn -EIO;\r\n}\r\nstatic int install_resident_loader(struct echoaudio *chip)\r\n{\r\nu32 address;\r\nint index, words, i;\r\nu16 *code;\r\nu32 status;\r\nconst struct firmware *fw;\r\nif (chip->device_id != DEVICE_ID_56361)\r\nreturn 0;\r\nstatus = get_dsp_register(chip, CHI32_STATUS_REG);\r\nif (status & CHI32_STATUS_REG_HF5) {\r\ndev_dbg(chip->card->dev,\r\n"Resident loader already installed; status is 0x%x\n",\r\nstatus);\r\nreturn 0;\r\n}\r\ni = get_firmware(&fw, chip, FW_361_LOADER);\r\nif (i < 0) {\r\ndev_warn(chip->card->dev, "Firmware not found !\n");\r\nreturn i;\r\n}\r\nset_dsp_register(chip, CHI32_CONTROL_REG,\r\nget_dsp_register(chip, CHI32_CONTROL_REG) | 0x900);\r\ncode = (u16 *)fw->data;\r\nindex = code[0];\r\nindex += 3;\r\nwords = code[index++];\r\naddress = ((u32)code[index] << 16) + code[index + 1];\r\nindex += 2;\r\nif (write_dsp(chip, words)) {\r\ndev_err(chip->card->dev,\r\n"install_resident_loader: Failed to write word count!\n");\r\ngoto irl_error;\r\n}\r\nif (write_dsp(chip, address)) {\r\ndev_err(chip->card->dev,\r\n"install_resident_loader: Failed to write DSP address!\n");\r\ngoto irl_error;\r\n}\r\nfor (i = 0; i < words; i++) {\r\nu32 data;\r\ndata = ((u32)code[index] << 16) + code[index + 1];\r\nif (write_dsp(chip, data)) {\r\ndev_err(chip->card->dev,\r\n"install_resident_loader: Failed to write DSP code\n");\r\ngoto irl_error;\r\n}\r\nindex += 2;\r\n}\r\nfor (i = 0; i < 200; i++) {\r\nudelay(50);\r\nstatus = get_dsp_register(chip, CHI32_STATUS_REG);\r\nif (status & CHI32_STATUS_REG_HF5)\r\nbreak;\r\n}\r\nif (i == 200) {\r\ndev_err(chip->card->dev, "Resident loader failed to set HF5\n");\r\ngoto irl_error;\r\n}\r\ndev_dbg(chip->card->dev, "Resident loader successfully installed\n");\r\nfree_firmware(fw, chip);\r\nreturn 0;\r\nirl_error:\r\nfree_firmware(fw, chip);\r\nreturn -EIO;\r\n}\r\nstatic int load_dsp(struct echoaudio *chip, u16 *code)\r\n{\r\nu32 address, data;\r\nint index, words, i;\r\nif (chip->dsp_code == code) {\r\ndev_warn(chip->card->dev, "DSP is already loaded!\n");\r\nreturn 0;\r\n}\r\nchip->bad_board = true;\r\nchip->dsp_code = NULL;\r\nchip->asic_loaded = false;\r\ndev_dbg(chip->card->dev, "load_dsp: Set bad_board to true\n");\r\n#ifdef DSP_56361\r\nif ((i = install_resident_loader(chip)) < 0)\r\nreturn i;\r\n#endif\r\nif (send_vector(chip, DSP_VC_RESET) < 0) {\r\ndev_err(chip->card->dev,\r\n"LoadDsp: send_vector DSP_VC_RESET failed, Critical Failure\n");\r\nreturn -EIO;\r\n}\r\nudelay(10);\r\nfor (i = 0; i < 1000; i++) {\r\nif (get_dsp_register(chip, CHI32_STATUS_REG) &\r\nCHI32_STATUS_REG_HF3)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == 1000) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: Timeout waiting for CHI32_STATUS_REG_HF3\n");\r\nreturn -EIO;\r\n}\r\nset_dsp_register(chip, CHI32_CONTROL_REG,\r\nget_dsp_register(chip, CHI32_CONTROL_REG) | 0x900);\r\nindex = code[0];\r\nfor (;;) {\r\nint block_type, mem_type;\r\nindex++;\r\nblock_type = code[index];\r\nif (block_type == 4)\r\nbreak;\r\nindex++;\r\nmem_type = code[index++];\r\nwords = code[index++];\r\nif (words == 0)\r\nbreak;\r\naddress = ((u32)code[index] << 16) + code[index + 1];\r\nindex += 2;\r\nif (write_dsp(chip, words) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: failed to write number of DSP words\n");\r\nreturn -EIO;\r\n}\r\nif (write_dsp(chip, address) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: failed to write DSP address\n");\r\nreturn -EIO;\r\n}\r\nif (write_dsp(chip, mem_type) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: failed to write DSP memory type\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < words; i++, index+=2) {\r\ndata = ((u32)code[index] << 16) + code[index + 1];\r\nif (write_dsp(chip, data) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: failed to write DSP data\n");\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nif (write_dsp(chip, 0) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: Failed to write final zero\n");\r\nreturn -EIO;\r\n}\r\nudelay(10);\r\nfor (i = 0; i < 5000; i++) {\r\nif (get_dsp_register(chip, CHI32_STATUS_REG) &\r\nCHI32_STATUS_REG_HF4) {\r\nset_dsp_register(chip, CHI32_CONTROL_REG,\r\nget_dsp_register(chip, CHI32_CONTROL_REG) & ~0x1b00);\r\nif (write_dsp(chip, DSP_FNC_SET_COMMPAGE_ADDR) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: Failed to write DSP_FNC_SET_COMMPAGE_ADDR\n");\r\nreturn -EIO;\r\n}\r\nif (write_dsp(chip, chip->comm_page_phys) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: Failed to write comm page address\n");\r\nreturn -EIO;\r\n}\r\nif (read_sn(chip) < 0) {\r\ndev_err(chip->card->dev,\r\n"load_dsp: Failed to read serial number\n");\r\nreturn -EIO;\r\n}\r\nchip->dsp_code = code;\r\nchip->bad_board = false;\r\nreturn 0;\r\n}\r\nudelay(100);\r\n}\r\ndev_err(chip->card->dev,\r\n"load_dsp: DSP load timed out waiting for HF4\n");\r\nreturn -EIO;\r\n}\r\nstatic int load_firmware(struct echoaudio *chip)\r\n{\r\nconst struct firmware *fw;\r\nint box_type, err;\r\nif (snd_BUG_ON(!chip->comm_page))\r\nreturn -EPERM;\r\nif (chip->dsp_code) {\r\nif ((box_type = check_asic_status(chip)) >= 0)\r\nreturn box_type;\r\nchip->dsp_code = NULL;\r\n}\r\nerr = get_firmware(&fw, chip, chip->dsp_code_to_load);\r\nif (err < 0)\r\nreturn err;\r\nerr = load_dsp(chip, (u16 *)fw->data);\r\nfree_firmware(fw, chip);\r\nif (err < 0)\r\nreturn err;\r\nif ((box_type = load_asic(chip)) < 0)\r\nreturn box_type;\r\nreturn box_type;\r\n}\r\nstatic int set_nominal_level(struct echoaudio *chip, u16 index, char consumer)\r\n{\r\nif (snd_BUG_ON(index >= num_busses_out(chip) + num_busses_in(chip)))\r\nreturn -EINVAL;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->nominal_level[index] = consumer;\r\nif (consumer)\r\nchip->comm_page->nominal_level_mask |= cpu_to_le32(1 << index);\r\nelse\r\nchip->comm_page->nominal_level_mask &= ~cpu_to_le32(1 << index);\r\nreturn 0;\r\n}\r\nstatic int set_output_gain(struct echoaudio *chip, u16 channel, s8 gain)\r\n{\r\nif (snd_BUG_ON(channel >= num_busses_out(chip)))\r\nreturn -EINVAL;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->output_gain[channel] = gain;\r\nchip->comm_page->line_out_level[channel] = gain;\r\nreturn 0;\r\n}\r\nstatic int set_monitor_gain(struct echoaudio *chip, u16 output, u16 input,\r\ns8 gain)\r\n{\r\nif (snd_BUG_ON(output >= num_busses_out(chip) ||\r\ninput >= num_busses_in(chip)))\r\nreturn -EINVAL;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->monitor_gain[output][input] = gain;\r\nchip->comm_page->monitors[monitor_index(chip, output, input)] = gain;\r\nreturn 0;\r\n}\r\nstatic int update_output_line_level(struct echoaudio *chip)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_OUTVOL);\r\n}\r\nstatic int update_input_line_level(struct echoaudio *chip)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_INGAIN);\r\n}\r\nstatic void set_meters_on(struct echoaudio *chip, char on)\r\n{\r\nif (on && !chip->meters_enabled) {\r\nsend_vector(chip, DSP_VC_METERS_ON);\r\nchip->meters_enabled = 1;\r\n} else if (!on && chip->meters_enabled) {\r\nsend_vector(chip, DSP_VC_METERS_OFF);\r\nchip->meters_enabled = 0;\r\nmemset((s8 *)chip->comm_page->vu_meter, ECHOGAIN_MUTED,\r\nDSP_MAXPIPES);\r\nmemset((s8 *)chip->comm_page->peak_meter, ECHOGAIN_MUTED,\r\nDSP_MAXPIPES);\r\n}\r\n}\r\nstatic void get_audio_meters(struct echoaudio *chip, long *meters)\r\n{\r\nint i, m, n;\r\nm = 0;\r\nn = 0;\r\nfor (i = 0; i < num_busses_out(chip); i++, m++) {\r\nmeters[n++] = chip->comm_page->vu_meter[m];\r\nmeters[n++] = chip->comm_page->peak_meter[m];\r\n}\r\nfor (; n < 32; n++)\r\nmeters[n] = 0;\r\n#ifdef ECHOCARD_ECHO3G\r\nm = E3G_MAX_OUTPUTS;\r\n#endif\r\nfor (i = 0; i < num_busses_in(chip); i++, m++) {\r\nmeters[n++] = chip->comm_page->vu_meter[m];\r\nmeters[n++] = chip->comm_page->peak_meter[m];\r\n}\r\nfor (; n < 64; n++)\r\nmeters[n] = 0;\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nfor (i = 0; i < num_pipes_out(chip); i++, m++) {\r\nmeters[n++] = chip->comm_page->vu_meter[m];\r\nmeters[n++] = chip->comm_page->peak_meter[m];\r\n}\r\n#endif\r\nfor (; n < 96; n++)\r\nmeters[n] = 0;\r\n}\r\nstatic int restore_dsp_rettings(struct echoaudio *chip)\r\n{\r\nint i, o, err;\r\nif ((err = check_asic_status(chip)) < 0)\r\nreturn err;\r\nchip->comm_page->gd_clock_state = GD_CLOCK_UNDEF;\r\nchip->comm_page->gd_spdif_status = GD_SPDIF_STATUS_UNDEF;\r\nchip->comm_page->handshake = 0xffffffff;\r\nfor (i = 0; i < num_busses_out(chip); i++) {\r\nerr = set_output_gain(chip, i, chip->output_gain[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#ifdef ECHOCARD_HAS_VMIXER\r\nfor (i = 0; i < num_pipes_out(chip); i++)\r\nfor (o = 0; o < num_busses_out(chip); o++) {\r\nerr = set_vmixer_gain(chip, o, i,\r\nchip->vmixer_gain[o][i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (update_vmixer_level(chip) < 0)\r\nreturn -EIO;\r\n#endif\r\n#ifdef ECHOCARD_HAS_MONITOR\r\nfor (o = 0; o < num_busses_out(chip); o++)\r\nfor (i = 0; i < num_busses_in(chip); i++) {\r\nerr = set_monitor_gain(chip, o, i,\r\nchip->monitor_gain[o][i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#endif\r\n#ifdef ECHOCARD_HAS_INPUT_GAIN\r\nfor (i = 0; i < num_busses_in(chip); i++) {\r\nerr = set_input_gain(chip, i, chip->input_gain[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#endif\r\nerr = update_output_line_level(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = update_input_line_level(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = set_sample_rate(chip, chip->sample_rate);\r\nif (err < 0)\r\nreturn err;\r\nif (chip->meters_enabled) {\r\nerr = send_vector(chip, DSP_VC_METERS_ON);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n#ifdef ECHOCARD_HAS_DIGITAL_MODE_SWITCH\r\nif (set_digital_mode(chip, chip->digital_mode) < 0)\r\nreturn -EIO;\r\n#endif\r\n#ifdef ECHOCARD_HAS_DIGITAL_IO\r\nif (set_professional_spdif(chip, chip->professional_spdif) < 0)\r\nreturn -EIO;\r\n#endif\r\n#ifdef ECHOCARD_HAS_PHANTOM_POWER\r\nif (set_phantom_power(chip, chip->phantom_power) < 0)\r\nreturn -EIO;\r\n#endif\r\n#ifdef ECHOCARD_HAS_EXTERNAL_CLOCK\r\nif (set_input_clock(chip, chip->input_clock) < 0)\r\nreturn -EIO;\r\n#endif\r\n#ifdef ECHOCARD_HAS_OUTPUT_CLOCK_SWITCH\r\nif (set_output_clock(chip, chip->output_clock) < 0)\r\nreturn -EIO;\r\n#endif\r\nif (wait_handshake(chip) < 0)\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nif (send_vector(chip, DSP_VC_UPDATE_FLAGS) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void set_audio_format(struct echoaudio *chip, u16 pipe_index,\r\nconst struct audioformat *format)\r\n{\r\nu16 dsp_format;\r\ndsp_format = DSP_AUDIOFORM_SS_16LE;\r\nif (format->interleave > 2) {\r\nswitch (format->bits_per_sample) {\r\ncase 16:\r\ndsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_16LE;\r\nbreak;\r\ncase 24:\r\ndsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_24LE;\r\nbreak;\r\ncase 32:\r\ndsp_format = DSP_AUDIOFORM_SUPER_INTERLEAVE_32LE;\r\nbreak;\r\n}\r\ndsp_format |= format->interleave;\r\n} else if (format->data_are_bigendian) {\r\nswitch (format->interleave) {\r\ncase 1:\r\ndsp_format = DSP_AUDIOFORM_MM_32BE;\r\nbreak;\r\n#ifdef ECHOCARD_HAS_STEREO_BIG_ENDIAN32\r\ncase 2:\r\ndsp_format = DSP_AUDIOFORM_SS_32BE;\r\nbreak;\r\n#endif\r\n}\r\n} else if (format->interleave == 1 &&\r\nformat->bits_per_sample == 32 && !format->mono_to_stereo) {\r\ndsp_format = DSP_AUDIOFORM_MM_32LE;\r\n} else {\r\nswitch (format->bits_per_sample) {\r\ncase 8:\r\nif (format->interleave == 2)\r\ndsp_format = DSP_AUDIOFORM_SS_8;\r\nelse\r\ndsp_format = DSP_AUDIOFORM_MS_8;\r\nbreak;\r\ndefault:\r\ncase 16:\r\nif (format->interleave == 2)\r\ndsp_format = DSP_AUDIOFORM_SS_16LE;\r\nelse\r\ndsp_format = DSP_AUDIOFORM_MS_16LE;\r\nbreak;\r\ncase 24:\r\nif (format->interleave == 2)\r\ndsp_format = DSP_AUDIOFORM_SS_24LE;\r\nelse\r\ndsp_format = DSP_AUDIOFORM_MS_24LE;\r\nbreak;\r\ncase 32:\r\nif (format->interleave == 2)\r\ndsp_format = DSP_AUDIOFORM_SS_32LE;\r\nelse\r\ndsp_format = DSP_AUDIOFORM_MS_32LE;\r\nbreak;\r\n}\r\n}\r\ndev_dbg(chip->card->dev,\r\n"set_audio_format[%d] = %x\n", pipe_index, dsp_format);\r\nchip->comm_page->audio_format[pipe_index] = cpu_to_le16(dsp_format);\r\n}\r\nstatic int start_transport(struct echoaudio *chip, u32 channel_mask,\r\nu32 cyclic_mask)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->cmd_start |= cpu_to_le32(channel_mask);\r\nif (chip->comm_page->cmd_start) {\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_START_TRANSFER);\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->active_mask |= channel_mask;\r\nchip->comm_page->cmd_start = 0;\r\nreturn 0;\r\n}\r\ndev_err(chip->card->dev, "start_transport: No pipes to start!\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int pause_transport(struct echoaudio *chip, u32 channel_mask)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);\r\nchip->comm_page->cmd_reset = 0;\r\nif (chip->comm_page->cmd_stop) {\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_STOP_TRANSFER);\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->active_mask &= ~channel_mask;\r\nchip->comm_page->cmd_stop = 0;\r\nchip->comm_page->cmd_reset = 0;\r\nreturn 0;\r\n}\r\ndev_warn(chip->card->dev, "pause_transport: No pipes to stop!\n");\r\nreturn 0;\r\n}\r\nstatic int stop_transport(struct echoaudio *chip, u32 channel_mask)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->cmd_stop |= cpu_to_le32(channel_mask);\r\nchip->comm_page->cmd_reset |= cpu_to_le32(channel_mask);\r\nif (chip->comm_page->cmd_reset) {\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_STOP_TRANSFER);\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->active_mask &= ~channel_mask;\r\nchip->comm_page->cmd_stop = 0;\r\nchip->comm_page->cmd_reset = 0;\r\nreturn 0;\r\n}\r\ndev_warn(chip->card->dev, "stop_transport: No pipes to stop!\n");\r\nreturn 0;\r\n}\r\nstatic inline int is_pipe_allocated(struct echoaudio *chip, u16 pipe_index)\r\n{\r\nreturn (chip->pipe_alloc_mask & (1 << pipe_index));\r\n}\r\nstatic int rest_in_peace(struct echoaudio *chip)\r\n{\r\nstop_transport(chip, chip->active_mask);\r\nset_meters_on(chip, false);\r\n#ifdef ECHOCARD_HAS_MIDI\r\nenable_midi_input(chip, false);\r\n#endif\r\nif (chip->dsp_code) {\r\nchip->dsp_code = NULL;\r\nreturn send_vector(chip, DSP_VC_GO_COMATOSE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_dsp_comm_page(struct echoaudio *chip)\r\n{\r\nif (offsetof(struct comm_page, midi_output) != 0xbe0) {\r\ndev_err(chip->card->dev,\r\n"init_dsp_comm_page() - Invalid struct comm_page structure\n");\r\nreturn -EPERM;\r\n}\r\nchip->card_name = ECHOCARD_NAME;\r\nchip->bad_board = true;\r\nchip->dsp_code = NULL;\r\nchip->asic_loaded = false;\r\nmemset(chip->comm_page, 0, sizeof(struct comm_page));\r\nchip->comm_page->comm_size =\r\ncpu_to_le32(sizeof(struct comm_page));\r\nchip->comm_page->handshake = 0xffffffff;\r\nchip->comm_page->midi_out_free_count =\r\ncpu_to_le32(DSP_MIDI_OUT_FIFO_SIZE);\r\nchip->comm_page->sample_rate = cpu_to_le32(44100);\r\nmemset(chip->comm_page->monitors, ECHOGAIN_MUTED, MONITOR_ARRAY_SIZE);\r\nmemset(chip->comm_page->vmixer, ECHOGAIN_MUTED, VMIXER_ARRAY_SIZE);\r\nreturn 0;\r\n}\r\nstatic int init_line_levels(struct echoaudio *chip)\r\n{\r\nmemset(chip->output_gain, ECHOGAIN_MUTED, sizeof(chip->output_gain));\r\nmemset(chip->input_gain, ECHOGAIN_MUTED, sizeof(chip->input_gain));\r\nmemset(chip->monitor_gain, ECHOGAIN_MUTED, sizeof(chip->monitor_gain));\r\nmemset(chip->vmixer_gain, ECHOGAIN_MUTED, sizeof(chip->vmixer_gain));\r\nchip->input_clock = ECHO_CLOCK_INTERNAL;\r\nchip->output_clock = ECHO_CLOCK_WORD;\r\nchip->sample_rate = 44100;\r\nreturn restore_dsp_rettings(chip);\r\n}\r\nstatic int service_irq(struct echoaudio *chip)\r\n{\r\nint st;\r\nif (get_dsp_register(chip, CHI32_STATUS_REG) & CHI32_STATUS_IRQ) {\r\nst = 0;\r\n#ifdef ECHOCARD_HAS_MIDI\r\nif (chip->comm_page->midi_input[0])\r\nst = midi_service_irq(chip);\r\n#endif\r\nchip->comm_page->midi_input[0] = 0;\r\nsend_vector(chip, DSP_VC_ACK_INT);\r\nreturn st;\r\n}\r\nreturn -1;\r\n}\r\nstatic int allocate_pipes(struct echoaudio *chip, struct audiopipe *pipe,\r\nint pipe_index, int interleave)\r\n{\r\nint i;\r\nu32 channel_mask;\r\nchar is_cyclic;\r\ndev_dbg(chip->card->dev,\r\n"allocate_pipes: ch=%d int=%d\n", pipe_index, interleave);\r\nif (chip->bad_board)\r\nreturn -EIO;\r\nis_cyclic = 1;\r\nfor (channel_mask = i = 0; i < interleave; i++)\r\nchannel_mask |= 1 << (pipe_index + i);\r\nif (chip->pipe_alloc_mask & channel_mask) {\r\ndev_err(chip->card->dev,\r\n"allocate_pipes: channel already open\n");\r\nreturn -EAGAIN;\r\n}\r\nchip->comm_page->position[pipe_index] = 0;\r\nchip->pipe_alloc_mask |= channel_mask;\r\nif (is_cyclic)\r\nchip->pipe_cyclic_mask |= channel_mask;\r\npipe->index = pipe_index;\r\npipe->interleave = interleave;\r\npipe->state = PIPE_STATE_STOPPED;\r\npipe->dma_counter = &chip->comm_page->position[pipe_index];\r\n*pipe->dma_counter = 0;\r\nreturn pipe_index;\r\n}\r\nstatic int free_pipes(struct echoaudio *chip, struct audiopipe *pipe)\r\n{\r\nu32 channel_mask;\r\nint i;\r\nif (snd_BUG_ON(!is_pipe_allocated(chip, pipe->index)))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(pipe->state != PIPE_STATE_STOPPED))\r\nreturn -EINVAL;\r\nfor (channel_mask = i = 0; i < pipe->interleave; i++)\r\nchannel_mask |= 1 << (pipe->index + i);\r\nchip->pipe_alloc_mask &= ~channel_mask;\r\nchip->pipe_cyclic_mask &= ~channel_mask;\r\nreturn 0;\r\n}\r\nstatic int sglist_init(struct echoaudio *chip, struct audiopipe *pipe)\r\n{\r\npipe->sglist_head = 0;\r\nmemset(pipe->sgpage.area, 0, PAGE_SIZE);\r\nchip->comm_page->sglist_addr[pipe->index].addr =\r\ncpu_to_le32(pipe->sgpage.addr);\r\nreturn 0;\r\n}\r\nstatic int sglist_add_mapping(struct echoaudio *chip, struct audiopipe *pipe,\r\ndma_addr_t address, size_t length)\r\n{\r\nint head = pipe->sglist_head;\r\nstruct sg_entry *list = (struct sg_entry *)pipe->sgpage.area;\r\nif (head < MAX_SGLIST_ENTRIES - 1) {\r\nlist[head].addr = cpu_to_le32(address);\r\nlist[head].size = cpu_to_le32(length);\r\npipe->sglist_head++;\r\n} else {\r\ndev_err(chip->card->dev, "SGlist: too many fragments\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int sglist_add_irq(struct echoaudio *chip, struct audiopipe *pipe)\r\n{\r\nreturn sglist_add_mapping(chip, pipe, 0, 0);\r\n}\r\nstatic inline int sglist_wrap(struct echoaudio *chip, struct audiopipe *pipe)\r\n{\r\nreturn sglist_add_mapping(chip, pipe, pipe->sgpage.addr, 0);\r\n}
