void iwl_mvm_te_clear_data(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_time_event_data *te_data)\r\n{\r\nlockdep_assert_held(&mvm->time_event_lock);\r\nif (!te_data->vif)\r\nreturn;\r\nlist_del(&te_data->list);\r\nte_data->running = false;\r\nte_data->uid = 0;\r\nte_data->id = TE_MAX;\r\nte_data->vif = NULL;\r\n}\r\nvoid iwl_mvm_roc_done_wk(struct work_struct *wk)\r\n{\r\nstruct iwl_mvm *mvm = container_of(wk, struct iwl_mvm, roc_done_wk);\r\nu32 queues = 0;\r\nif (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status)) {\r\nqueues |= BIT(IWL_MVM_OFFCHANNEL_QUEUE);\r\niwl_mvm_unref(mvm, IWL_MVM_REF_ROC);\r\n}\r\nif (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status)) {\r\nqueues |= BIT(mvm->aux_queue);\r\niwl_mvm_unref(mvm, IWL_MVM_REF_ROC_AUX);\r\n}\r\nsynchronize_net();\r\niwl_mvm_flush_tx_path(mvm, queues, CMD_ASYNC);\r\n}\r\nstatic void iwl_mvm_roc_finished(struct iwl_mvm *mvm)\r\n{\r\nschedule_work(&mvm->roc_done_wk);\r\n}\r\nstatic void iwl_mvm_csa_noa_start(struct iwl_mvm *mvm)\r\n{\r\nstruct ieee80211_vif *csa_vif;\r\nrcu_read_lock();\r\ncsa_vif = rcu_dereference(mvm->csa_vif);\r\nif (!csa_vif || !csa_vif->csa_active)\r\ngoto out_unlock;\r\nIWL_DEBUG_TE(mvm, "CSA NOA started\n");\r\nif (!ieee80211_csa_is_complete(csa_vif)) {\r\nIWL_WARN(mvm, "CSA NOA started too early\n");\r\ngoto out_unlock;\r\n}\r\nieee80211_csa_finish(csa_vif);\r\nrcu_read_unlock();\r\nRCU_INIT_POINTER(mvm->csa_vif, NULL);\r\nreturn;\r\nout_unlock:\r\nrcu_read_unlock();\r\n}\r\nstatic bool iwl_mvm_te_check_disconnect(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nconst char *errmsg)\r\n{\r\nif (vif->type != NL80211_IFTYPE_STATION)\r\nreturn false;\r\nif (vif->bss_conf.assoc && vif->bss_conf.dtim_period)\r\nreturn false;\r\nif (errmsg)\r\nIWL_ERR(mvm, "%s\n", errmsg);\r\niwl_mvm_connection_loss(mvm, vif, errmsg);\r\nreturn true;\r\n}\r\nstatic void\r\niwl_mvm_te_handle_notify_csa(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_time_event_data *te_data,\r\nstruct iwl_time_event_notif *notif)\r\n{\r\nstruct ieee80211_vif *vif = te_data->vif;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nif (!notif->status)\r\nIWL_DEBUG_TE(mvm, "CSA time event failed to start\n");\r\nswitch (te_data->vif->type) {\r\ncase NL80211_IFTYPE_AP:\r\nif (!notif->status)\r\nmvmvif->csa_failed = true;\r\niwl_mvm_csa_noa_start(mvm);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nif (!notif->status) {\r\niwl_mvm_connection_loss(mvm, vif,\r\n"CSA TE failed to start");\r\nbreak;\r\n}\r\niwl_mvm_csa_client_absent(mvm, te_data->vif);\r\nieee80211_chswitch_done(te_data->vif, true);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\niwl_mvm_te_clear_data(mvm, te_data);\r\n}\r\nstatic void iwl_mvm_te_check_trigger(struct iwl_mvm *mvm,\r\nstruct iwl_time_event_notif *notif,\r\nstruct iwl_mvm_time_event_data *te_data)\r\n{\r\nstruct iwl_fw_dbg_trigger_tlv *trig;\r\nstruct iwl_fw_dbg_trigger_time_event *te_trig;\r\nint i;\r\nif (!iwl_fw_dbg_trigger_enabled(mvm->fw, FW_DBG_TRIGGER_TIME_EVENT))\r\nreturn;\r\ntrig = iwl_fw_dbg_get_trigger(mvm->fw, FW_DBG_TRIGGER_TIME_EVENT);\r\nte_trig = (void *)trig->data;\r\nif (!iwl_fw_dbg_trigger_check_stop(mvm, te_data->vif, trig))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(te_trig->time_events); i++) {\r\nu32 trig_te_id = le32_to_cpu(te_trig->time_events[i].id);\r\nu32 trig_action_bitmap =\r\nle32_to_cpu(te_trig->time_events[i].action_bitmap);\r\nu32 trig_status_bitmap =\r\nle32_to_cpu(te_trig->time_events[i].status_bitmap);\r\nif (trig_te_id != te_data->id ||\r\n!(trig_action_bitmap & le32_to_cpu(notif->action)) ||\r\n!(trig_status_bitmap & BIT(le32_to_cpu(notif->status))))\r\ncontinue;\r\niwl_mvm_fw_dbg_collect_trig(mvm, trig,\r\n"Time event %d Action 0x%x received status: %d",\r\nte_data->id,\r\nle32_to_cpu(notif->action),\r\nle32_to_cpu(notif->status));\r\nbreak;\r\n}\r\n}\r\nstatic void iwl_mvm_te_handle_notif(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_time_event_data *te_data,\r\nstruct iwl_time_event_notif *notif)\r\n{\r\nlockdep_assert_held(&mvm->time_event_lock);\r\nIWL_DEBUG_TE(mvm, "Handle time event notif - UID = 0x%x action %d\n",\r\nle32_to_cpu(notif->unique_id),\r\nle32_to_cpu(notif->action));\r\niwl_mvm_te_check_trigger(mvm, notif, te_data);\r\nif (!le32_to_cpu(notif->status)) {\r\nconst char *msg;\r\nif (notif->action & cpu_to_le32(TE_V2_NOTIF_HOST_EVENT_START))\r\nmsg = "Time Event start notification failure";\r\nelse\r\nmsg = "Time Event end notification failure";\r\nIWL_DEBUG_TE(mvm, "%s\n", msg);\r\nif (iwl_mvm_te_check_disconnect(mvm, te_data->vif, msg)) {\r\niwl_mvm_te_clear_data(mvm, te_data);\r\nreturn;\r\n}\r\n}\r\nif (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_END) {\r\nIWL_DEBUG_TE(mvm,\r\n"TE ended - current time %lu, estimated end %lu\n",\r\njiffies, te_data->end_jiffies);\r\nswitch (te_data->vif->type) {\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nieee80211_remain_on_channel_expired(mvm->hw);\r\niwl_mvm_roc_finished(mvm);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\niwl_mvm_te_check_disconnect(mvm, te_data->vif,\r\n"No association and the time event is over already...");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\niwl_mvm_te_clear_data(mvm, te_data);\r\n} else if (le32_to_cpu(notif->action) & TE_V2_NOTIF_HOST_EVENT_START) {\r\nte_data->running = true;\r\nte_data->end_jiffies = TU_TO_EXP_TIME(te_data->duration);\r\nif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE) {\r\nset_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status);\r\niwl_mvm_ref(mvm, IWL_MVM_REF_ROC);\r\nieee80211_ready_on_channel(mvm->hw);\r\n} else if (te_data->id == TE_CHANNEL_SWITCH_PERIOD) {\r\niwl_mvm_te_handle_notify_csa(mvm, te_data, notif);\r\n}\r\n} else {\r\nIWL_WARN(mvm, "Got TE with unknown action\n");\r\n}\r\n}\r\nstatic int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,\r\nstruct iwl_time_event_notif *notif)\r\n{\r\nstruct iwl_mvm_time_event_data *te_data, *tmp;\r\nbool aux_roc_te = false;\r\nlist_for_each_entry_safe(te_data, tmp, &mvm->aux_roc_te_list, list) {\r\nif (le32_to_cpu(notif->unique_id) == te_data->uid) {\r\naux_roc_te = true;\r\nbreak;\r\n}\r\n}\r\nif (!aux_roc_te)\r\nreturn -EINVAL;\r\niwl_mvm_te_check_trigger(mvm, notif, te_data);\r\nIWL_DEBUG_TE(mvm,\r\n"Aux ROC time event notification - UID = 0x%x action %d (error = %d)\n",\r\nle32_to_cpu(notif->unique_id),\r\nle32_to_cpu(notif->action), le32_to_cpu(notif->status));\r\nif (!le32_to_cpu(notif->status) ||\r\nle32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_END) {\r\nieee80211_remain_on_channel_expired(mvm->hw);\r\niwl_mvm_roc_finished(mvm);\r\nlist_del(&te_data->list);\r\nte_data->running = false;\r\nte_data->vif = NULL;\r\nte_data->uid = 0;\r\nte_data->id = TE_MAX;\r\n} else if (le32_to_cpu(notif->action) == TE_V2_NOTIF_HOST_EVENT_START) {\r\nset_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status);\r\nte_data->running = true;\r\niwl_mvm_ref(mvm, IWL_MVM_REF_ROC_AUX);\r\nieee80211_ready_on_channel(mvm->hw);\r\n} else {\r\nIWL_DEBUG_TE(mvm,\r\n"ERROR: Unknown Aux ROC Time Event (action = %d)\n",\r\nle32_to_cpu(notif->action));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid iwl_mvm_rx_time_event_notif(struct iwl_mvm *mvm,\r\nstruct iwl_rx_cmd_buffer *rxb)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_time_event_notif *notif = (void *)pkt->data;\r\nstruct iwl_mvm_time_event_data *te_data, *tmp;\r\nIWL_DEBUG_TE(mvm, "Time event notification - UID = 0x%x action %d\n",\r\nle32_to_cpu(notif->unique_id),\r\nle32_to_cpu(notif->action));\r\nspin_lock_bh(&mvm->time_event_lock);\r\nif (!iwl_mvm_aux_roc_te_handle_notif(mvm, notif))\r\ngoto unlock;\r\nlist_for_each_entry_safe(te_data, tmp, &mvm->time_event_list, list) {\r\nif (le32_to_cpu(notif->unique_id) == te_data->uid)\r\niwl_mvm_te_handle_notif(mvm, te_data, notif);\r\n}\r\nunlock:\r\nspin_unlock_bh(&mvm->time_event_lock);\r\n}\r\nstatic bool iwl_mvm_te_notif(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_mvm *mvm =\r\ncontainer_of(notif_wait, struct iwl_mvm, notif_wait);\r\nstruct iwl_mvm_time_event_data *te_data = data;\r\nstruct iwl_time_event_notif *resp;\r\nint resp_len = iwl_rx_packet_payload_len(pkt);\r\nif (WARN_ON(pkt->hdr.cmd != TIME_EVENT_NOTIFICATION))\r\nreturn true;\r\nif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\r\nIWL_ERR(mvm, "Invalid TIME_EVENT_NOTIFICATION response\n");\r\nreturn true;\r\n}\r\nresp = (void *)pkt->data;\r\nif (le32_to_cpu(resp->unique_id) != te_data->uid)\r\nreturn false;\r\nIWL_DEBUG_TE(mvm, "TIME_EVENT_NOTIFICATION response - UID = 0x%x\n",\r\nte_data->uid);\r\nif (!resp->status)\r\nIWL_ERR(mvm,\r\n"TIME_EVENT_NOTIFICATION received but not executed\n");\r\nreturn true;\r\n}\r\nstatic bool iwl_mvm_time_event_response(struct iwl_notif_wait_data *notif_wait,\r\nstruct iwl_rx_packet *pkt, void *data)\r\n{\r\nstruct iwl_mvm *mvm =\r\ncontainer_of(notif_wait, struct iwl_mvm, notif_wait);\r\nstruct iwl_mvm_time_event_data *te_data = data;\r\nstruct iwl_time_event_resp *resp;\r\nint resp_len = iwl_rx_packet_payload_len(pkt);\r\nif (WARN_ON(pkt->hdr.cmd != TIME_EVENT_CMD))\r\nreturn true;\r\nif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\r\nIWL_ERR(mvm, "Invalid TIME_EVENT_CMD response\n");\r\nreturn true;\r\n}\r\nresp = (void *)pkt->data;\r\nif (WARN_ON_ONCE(le32_to_cpu(resp->id) != te_data->id))\r\nreturn false;\r\nte_data->uid = le32_to_cpu(resp->unique_id);\r\nIWL_DEBUG_TE(mvm, "TIME_EVENT_CMD response - UID = 0x%x\n",\r\nte_data->uid);\r\nreturn true;\r\n}\r\nstatic int iwl_mvm_time_event_send_add(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nstruct iwl_mvm_time_event_data *te_data,\r\nstruct iwl_time_event_cmd *te_cmd)\r\n{\r\nstatic const u16 time_event_response[] = { TIME_EVENT_CMD };\r\nstruct iwl_notification_wait wait_time_event;\r\nint ret;\r\nlockdep_assert_held(&mvm->mutex);\r\nIWL_DEBUG_TE(mvm, "Add new TE, duration %d TU\n",\r\nle32_to_cpu(te_cmd->duration));\r\nspin_lock_bh(&mvm->time_event_lock);\r\nif (WARN_ON(te_data->id != TE_MAX)) {\r\nspin_unlock_bh(&mvm->time_event_lock);\r\nreturn -EIO;\r\n}\r\nte_data->vif = vif;\r\nte_data->duration = le32_to_cpu(te_cmd->duration);\r\nte_data->id = le32_to_cpu(te_cmd->id);\r\nlist_add_tail(&te_data->list, &mvm->time_event_list);\r\nspin_unlock_bh(&mvm->time_event_lock);\r\niwl_init_notification_wait(&mvm->notif_wait, &wait_time_event,\r\ntime_event_response,\r\nARRAY_SIZE(time_event_response),\r\niwl_mvm_time_event_response, te_data);\r\nret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,\r\nsizeof(*te_cmd), te_cmd);\r\nif (ret) {\r\nIWL_ERR(mvm, "Couldn't send TIME_EVENT_CMD: %d\n", ret);\r\niwl_remove_notification(&mvm->notif_wait, &wait_time_event);\r\ngoto out_clear_te;\r\n}\r\nret = iwl_wait_notification(&mvm->notif_wait, &wait_time_event, 1);\r\nWARN_ON_ONCE(ret);\r\nif (ret) {\r\nout_clear_te:\r\nspin_lock_bh(&mvm->time_event_lock);\r\niwl_mvm_te_clear_data(mvm, te_data);\r\nspin_unlock_bh(&mvm->time_event_lock);\r\n}\r\nreturn ret;\r\n}\r\nvoid iwl_mvm_protect_session(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nu32 duration, u32 min_duration,\r\nu32 max_delay, bool wait_for_notif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\r\nconst u16 te_notif_response[] = { TIME_EVENT_NOTIFICATION };\r\nstruct iwl_notification_wait wait_te_notif;\r\nstruct iwl_time_event_cmd time_cmd = {};\r\nlockdep_assert_held(&mvm->mutex);\r\nif (te_data->running &&\r\ntime_after(te_data->end_jiffies, TU_TO_EXP_TIME(min_duration))) {\r\nIWL_DEBUG_TE(mvm, "We have enough time in the current TE: %u\n",\r\njiffies_to_msecs(te_data->end_jiffies - jiffies));\r\nreturn;\r\n}\r\nif (te_data->running) {\r\nIWL_DEBUG_TE(mvm, "extend 0x%x: only %u ms left\n",\r\nte_data->uid,\r\njiffies_to_msecs(te_data->end_jiffies - jiffies));\r\niwl_mvm_stop_session_protection(mvm, vif);\r\n}\r\ntime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\r\ntime_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\ntime_cmd.id = cpu_to_le32(TE_BSS_STA_AGGRESSIVE_ASSOC);\r\ntime_cmd.apply_time = cpu_to_le32(0);\r\ntime_cmd.max_frags = TE_V2_FRAG_NONE;\r\ntime_cmd.max_delay = cpu_to_le32(max_delay);\r\ntime_cmd.interval = cpu_to_le32(1);\r\ntime_cmd.duration = cpu_to_le32(duration);\r\ntime_cmd.repeat = 1;\r\ntime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\r\nTE_V2_NOTIF_HOST_EVENT_END |\r\nT2_V2_START_IMMEDIATELY);\r\nif (!wait_for_notif) {\r\niwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\r\nreturn;\r\n}\r\niwl_init_notification_wait(&mvm->notif_wait, &wait_te_notif,\r\nte_notif_response,\r\nARRAY_SIZE(te_notif_response),\r\niwl_mvm_te_notif, te_data);\r\nif (iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd)) {\r\nIWL_ERR(mvm, "Failed to add TE to protect session\n");\r\niwl_remove_notification(&mvm->notif_wait, &wait_te_notif);\r\n} else if (iwl_wait_notification(&mvm->notif_wait, &wait_te_notif,\r\nTU_TO_JIFFIES(max_delay))) {\r\nIWL_ERR(mvm, "Failed to protect session until TE\n");\r\n}\r\n}\r\nstatic bool __iwl_mvm_remove_time_event(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_time_event_data *te_data,\r\nu32 *uid)\r\n{\r\nu32 id;\r\nspin_lock_bh(&mvm->time_event_lock);\r\n*uid = te_data->uid;\r\nid = te_data->id;\r\niwl_mvm_te_clear_data(mvm, te_data);\r\nspin_unlock_bh(&mvm->time_event_lock);\r\nif (id == TE_MAX) {\r\nIWL_DEBUG_TE(mvm, "TE 0x%x has already ended\n", *uid);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void iwl_mvm_remove_aux_roc_te(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_vif *mvmvif,\r\nstruct iwl_mvm_time_event_data *te_data)\r\n{\r\nstruct iwl_hs20_roc_req aux_cmd = {};\r\nu32 uid;\r\nint ret;\r\nif (!__iwl_mvm_remove_time_event(mvm, te_data, &uid))\r\nreturn;\r\naux_cmd.event_unique_id = cpu_to_le32(uid);\r\naux_cmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);\r\naux_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\nIWL_DEBUG_TE(mvm, "Removing BSS AUX ROC TE 0x%x\n",\r\nle32_to_cpu(aux_cmd.event_unique_id));\r\nret = iwl_mvm_send_cmd_pdu(mvm, HOT_SPOT_CMD, 0,\r\nsizeof(aux_cmd), &aux_cmd);\r\nif (WARN_ON(ret))\r\nreturn;\r\n}\r\nvoid iwl_mvm_remove_time_event(struct iwl_mvm *mvm,\r\nstruct iwl_mvm_vif *mvmvif,\r\nstruct iwl_mvm_time_event_data *te_data)\r\n{\r\nstruct iwl_time_event_cmd time_cmd = {};\r\nu32 uid;\r\nint ret;\r\nif (!__iwl_mvm_remove_time_event(mvm, te_data, &uid))\r\nreturn;\r\ntime_cmd.id = cpu_to_le32(uid);\r\ntime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE);\r\ntime_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\nIWL_DEBUG_TE(mvm, "Removing TE 0x%x\n", le32_to_cpu(time_cmd.id));\r\nret = iwl_mvm_send_cmd_pdu(mvm, TIME_EVENT_CMD, 0,\r\nsizeof(time_cmd), &time_cmd);\r\nif (WARN_ON(ret))\r\nreturn;\r\n}\r\nvoid iwl_mvm_stop_session_protection(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\r\nlockdep_assert_held(&mvm->mutex);\r\niwl_mvm_remove_time_event(mvm, mvmvif, te_data);\r\n}\r\nint iwl_mvm_start_p2p_roc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\r\nint duration, enum ieee80211_roc_type type)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\r\nstruct iwl_time_event_cmd time_cmd = {};\r\nlockdep_assert_held(&mvm->mutex);\r\nif (te_data->running) {\r\nIWL_WARN(mvm, "P2P_DEVICE remain on channel already running\n");\r\nreturn -EBUSY;\r\n}\r\nflush_work(&mvm->roc_done_wk);\r\ntime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\r\ntime_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\nswitch (type) {\r\ncase IEEE80211_ROC_TYPE_NORMAL:\r\ntime_cmd.id = cpu_to_le32(IWL_MVM_ROC_TE_TYPE_NORMAL);\r\nbreak;\r\ncase IEEE80211_ROC_TYPE_MGMT_TX:\r\ntime_cmd.id = cpu_to_le32(IWL_MVM_ROC_TE_TYPE_MGMT_TX);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Got an invalid ROC type\n");\r\nreturn -EINVAL;\r\n}\r\ntime_cmd.apply_time = cpu_to_le32(0);\r\ntime_cmd.interval = cpu_to_le32(1);\r\ntime_cmd.max_frags = min(MSEC_TO_TU(duration)/50, TE_V2_FRAG_ENDLESS);\r\ntime_cmd.max_delay = cpu_to_le32(MSEC_TO_TU(duration/2));\r\ntime_cmd.duration = cpu_to_le32(MSEC_TO_TU(duration));\r\ntime_cmd.repeat = 1;\r\ntime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\r\nTE_V2_NOTIF_HOST_EVENT_END |\r\nT2_V2_START_IMMEDIATELY);\r\nreturn iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\r\n}\r\nstatic struct iwl_mvm_time_event_data *iwl_mvm_get_roc_te(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_time_event_data *te_data;\r\nlockdep_assert_held(&mvm->mutex);\r\nspin_lock_bh(&mvm->time_event_lock);\r\nlist_for_each_entry(te_data, &mvm->time_event_list, list) {\r\nif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE)\r\ngoto out;\r\n}\r\nte_data = list_first_entry_or_null(&mvm->aux_roc_te_list,\r\nstruct iwl_mvm_time_event_data,\r\nlist);\r\nout:\r\nspin_unlock_bh(&mvm->time_event_lock);\r\nreturn te_data;\r\n}\r\nvoid iwl_mvm_cleanup_roc_te(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_time_event_data *te_data;\r\nu32 uid;\r\nte_data = iwl_mvm_get_roc_te(mvm);\r\nif (te_data)\r\n__iwl_mvm_remove_time_event(mvm, te_data, &uid);\r\n}\r\nvoid iwl_mvm_stop_roc(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_vif *mvmvif;\r\nstruct iwl_mvm_time_event_data *te_data;\r\nte_data = iwl_mvm_get_roc_te(mvm);\r\nif (!te_data) {\r\nIWL_WARN(mvm, "No remain on channel event\n");\r\nreturn;\r\n}\r\nmvmvif = iwl_mvm_vif_from_mac80211(te_data->vif);\r\nif (te_data->vif->type == NL80211_IFTYPE_P2P_DEVICE)\r\niwl_mvm_remove_time_event(mvm, mvmvif, te_data);\r\nelse\r\niwl_mvm_remove_aux_roc_te(mvm, mvmvif, te_data);\r\niwl_mvm_roc_finished(mvm);\r\n}\r\nint iwl_mvm_schedule_csa_period(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nu32 duration, u32 apply_time)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm_time_event_data *te_data = &mvmvif->time_event_data;\r\nstruct iwl_time_event_cmd time_cmd = {};\r\nlockdep_assert_held(&mvm->mutex);\r\nif (te_data->running) {\r\nIWL_DEBUG_TE(mvm, "CS period is already scheduled\n");\r\nreturn -EBUSY;\r\n}\r\ntime_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\r\ntime_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color));\r\ntime_cmd.id = cpu_to_le32(TE_CHANNEL_SWITCH_PERIOD);\r\ntime_cmd.apply_time = cpu_to_le32(apply_time);\r\ntime_cmd.max_frags = TE_V2_FRAG_NONE;\r\ntime_cmd.duration = cpu_to_le32(duration);\r\ntime_cmd.repeat = 1;\r\ntime_cmd.interval = cpu_to_le32(1);\r\ntime_cmd.policy = cpu_to_le16(TE_V2_NOTIF_HOST_EVENT_START |\r\nTE_V2_ABSENCE);\r\nreturn iwl_mvm_time_event_send_add(mvm, vif, te_data, &time_cmd);\r\n}
