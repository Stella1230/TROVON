static void\r\nph_command(struct IsdnCardState *cs, unsigned int command)\r\n{\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_command (%#x) in (%#x)", command,\r\ncs->dc.isac.ph_state);\r\ncs->writeisac(cs, IPACX_CIX0, (command << 4) | 0x0E);\r\n}\r\nstatic inline void\r\ncic_int(struct IsdnCardState *cs)\r\n{\r\nu_char event;\r\nevent = cs->readisac(cs, IPACX_CIR0) >> 4;\r\nif (cs->debug & L1_DEB_ISAC) debugl1(cs, "cic_int(event=%#x)", event);\r\ncs->dc.isac.ph_state = event;\r\nschedule_event(cs, D_L1STATECHANGE);\r\n}\r\nstatic void\r\ndch_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_char cda1_cr;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX) LogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE) dlogframe(cs, skb, 0);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD) Logl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD) Logl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\ndch_fill_fifo(cs);\r\n}\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX) LogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE) dlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD) Logl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\ndch_fill_fifo(cs);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD) debugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\nclear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\nset_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\ncase (HW_ENABLE | REQUEST):\r\nif ((cs->dc.isac.ph_state == IPACX_IND_RES) ||\r\n(cs->dc.isac.ph_state == IPACX_IND_DR) ||\r\n(cs->dc.isac.ph_state == IPACX_IND_DC))\r\nph_command(cs, IPACX_CMD_TIM);\r\nelse\r\nph_command(cs, IPACX_CMD_RES);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nph_command(cs, IPACX_CMD_AR8);\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\ncs->writeisac(cs, IPACX_CDA_TSDP10, 0x80);\r\ncs->writeisac(cs, IPACX_CDA_TSDP11, 0x81);\r\ncda1_cr = cs->readisac(cs, IPACX_CDA1_CR);\r\n(void) cs->readisac(cs, IPACX_CDA2_CR);\r\nif ((long)arg & 1) {\r\ncs->writeisac(cs, IPACX_CDA1_CR, cda1_cr | 0x0a);\r\n}\r\nelse {\r\ncs->writeisac(cs, IPACX_CDA1_CR, cda1_cr & ~0x0a);\r\n}\r\nif ((long)arg & 2) {\r\ncs->writeisac(cs, IPACX_CDA1_CR, cda1_cr | 0x14);\r\n}\r\nelse {\r\ncs->writeisac(cs, IPACX_CDA1_CR, cda1_cr & ~0x14);\r\n}\r\nbreak;\r\ncase (HW_DEACTIVATE | RESPONSE):\r\nskb_queue_purge(&cs->rq);\r\nskb_queue_purge(&cs->sq);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN) debugl1(cs, "dch_l2l1 unknown %04x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *st;\r\nint rbchd, stard;\r\nif (test_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\nrbchd = cs->readisac(cs, IPACX_RBCHD);\r\nstard = cs->readisac(cs, IPACX_STARD);\r\nif (cs->debug)\r\ndebugl1(cs, "D-Channel Busy RBCHD %02x STARD %02x", rbchd, stard);\r\nif (!(stard & 0x40)) {\r\nset_bit(FLG_L1_DBUSY, &cs->HW_Flags);\r\nfor (st = cs->stlist; st; st = st->next) {\r\nst->l1.l1l2(st, PH_PAUSE | INDICATION, NULL);\r\n}\r\n} else {\r\nclear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags);\r\nif (cs->tx_skb) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ISAC D-Channel Busy no skb\n");\r\ndebugl1(cs, "D-Channel Busy no skb");\r\n}\r\ncs->writeisac(cs, IPACX_CMDRD, 0x01);\r\n}\r\n}\r\n}\r\nstatic void\r\ndch_empty_fifo(struct IsdnCardState *cs, int count)\r\n{\r\nu_char *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "dch_empty_fifo()");\r\nif ((cs->rcvidx + count) >= MAX_DFRAME_LEN_L1) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "dch_empty_fifo() incoming message too large");\r\ncs->writeisac(cs, IPACX_CMDRD, 0x80);\r\ncs->rcvidx = 0;\r\nreturn;\r\n}\r\nptr = cs->rcvbuf + cs->rcvidx;\r\ncs->rcvidx += count;\r\ncs->readisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, IPACX_CMDRD, 0x80);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "dch_empty_fifo() cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", cs->dlog);\r\n}\r\n}\r\nstatic void\r\ndch_fill_fifo(struct IsdnCardState *cs)\r\n{\r\nint count;\r\nu_char cmd, *ptr;\r\nif ((cs->debug & L1_DEB_ISAC) && !(cs->debug & L1_DEB_ISAC_FIFO))\r\ndebugl1(cs, "dch_fill_fifo()");\r\nif (!cs->tx_skb) return;\r\ncount = cs->tx_skb->len;\r\nif (count <= 0) return;\r\nif (count > D_FIFO_SIZE) {\r\ncount = D_FIFO_SIZE;\r\ncmd = 0x08;\r\n} else {\r\ncmd = 0x0A;\r\n}\r\nptr = cs->tx_skb->data;\r\nskb_pull(cs->tx_skb, count);\r\ncs->tx_cnt += count;\r\ncs->writeisacfifo(cs, ptr, count);\r\ncs->writeisac(cs, IPACX_CMDRD, cmd);\r\nif (test_and_set_bit(FLG_DBUSY_TIMER, &cs->HW_Flags)) {\r\ndebugl1(cs, "dch_fill_fifo dbusytimer running");\r\ndel_timer(&cs->dbusytimer);\r\n}\r\ninit_timer(&cs->dbusytimer);\r\ncs->dbusytimer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ)/1000);\r\nadd_timer(&cs->dbusytimer);\r\nif (cs->debug & L1_DEB_ISAC_FIFO) {\r\nchar *t = cs->dlog;\r\nt += sprintf(t, "dch_fill_fifo() cnt %d", count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", cs->dlog);\r\n}\r\n}\r\nstatic inline void\r\ndch_int(struct IsdnCardState *cs)\r\n{\r\nstruct sk_buff *skb;\r\nu_char istad, rstad;\r\nint count;\r\nistad = cs->readisac(cs, IPACX_ISTAD);\r\nif (istad & 0x80) {\r\nrstad = cs->readisac(cs, IPACX_RSTAD);\r\nif ((rstad & 0xf0) != 0xa0) {\r\nif (!(rstad & 0x80))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "dch_int(): invalid frame");\r\nif ((rstad & 0x40))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "dch_int(): RDO");\r\nif (!(rstad & 0x20))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "dch_int(): CRC error");\r\ncs->writeisac(cs, IPACX_CMDRD, 0x80);\r\n} else {\r\ncount = cs->readisac(cs, IPACX_RBCLD);\r\nif (count) count--;\r\ncount &= D_FIFO_SIZE - 1;\r\nif (count == 0) count = D_FIFO_SIZE;\r\ndch_empty_fifo(cs, count);\r\nif ((count = cs->rcvidx) > 0) {\r\ncs->rcvidx = 0;\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "HiSax dch_int(): receive out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, count), cs->rcvbuf, count);\r\nskb_queue_tail(&cs->rq, skb);\r\n}\r\n}\r\n}\r\ncs->rcvidx = 0;\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\nif (istad & 0x40) {\r\ndch_empty_fifo(cs, D_FIFO_SIZE);\r\n}\r\nif (istad & 0x20) {\r\nif (cs->debug & L1_DEB_WARN) debugl1(cs, "dch_int(): RFO");\r\ncs->writeisac(cs, IPACX_CMDRD, 0x40);\r\n}\r\nif (istad & 0x10) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\ndch_fill_fifo(cs);\r\ngoto afterXPR;\r\n}\r\nelse {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\ncs->tx_cnt = 0;\r\n}\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\ncs->tx_cnt = 0;\r\ndch_fill_fifo(cs);\r\n}\r\nelse {\r\nschedule_event(cs, D_XMTBUFREADY);\r\n}\r\n}\r\nafterXPR:\r\nif (istad & 0x0C) {\r\nif (cs->debug & L1_DEB_WARN) debugl1(cs, "dch_int(): XDU");\r\nif (cs->tx_skb) {\r\nskb_push(cs->tx_skb, cs->tx_cnt);\r\ncs->tx_cnt = 0;\r\ndch_fill_fifo(cs);\r\n} else {\r\nprintk(KERN_WARNING "HiSax: ISAC XDU no skb\n");\r\ndebugl1(cs, "ISAC XDU no skb");\r\n}\r\n}\r\n}\r\nstatic void\r\ndch_setstack(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = dch_l2l1;\r\n}\r\nstatic void\r\ndch_init(struct IsdnCardState *cs)\r\n{\r\nprintk(KERN_INFO "HiSax: IPACX ISDN driver v0.1.0\n");\r\ncs->setstack_d = dch_setstack;\r\ncs->dbusytimer.function = (void *) dbusy_timer_handler;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\ncs->writeisac(cs, IPACX_TR_CONF0, 0x00);\r\ncs->writeisac(cs, IPACX_TR_CONF2, 0x00);\r\ncs->writeisac(cs, IPACX_MODED, 0xC9);\r\ncs->writeisac(cs, IPACX_MON_CR, 0x00);\r\n}\r\nstatic void\r\nbch_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\nset_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->hw.hscx.count = 0;\r\nbch_fill_fifo(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "HiSax bch_l2l1(): this shouldn't happen\n");\r\n} else {\r\nset_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->tx_skb = skb;\r\nbcs->hw.hscx.count = 0;\r\nbch_fill_fifo(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\nclear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\nset_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nset_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nbch_mode(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nclear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nclear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbch_mode(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbch_empty_fifo(struct BCState *bcs, int count)\r\n{\r\nu_char *ptr, hscx;\r\nstruct IsdnCardState *cs;\r\nint cnt;\r\ncs = bcs->cs;\r\nhscx = bcs->hw.hscx.hscx;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "bch_empty_fifo()");\r\nif (bcs->hw.hscx.rcvidx + count > HSCX_BUFMAX) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_empty_fifo() incoming packet too large");\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x80);\r\nbcs->hw.hscx.rcvidx = 0;\r\nreturn;\r\n}\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\ncnt = count;\r\nwhile (cnt--) *ptr++ = cs->BC_Read_Reg(cs, hscx, IPACX_RFIFOB);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x80);\r\nptr = bcs->hw.hscx.rcvbuf + bcs->hw.hscx.rcvidx;\r\nbcs->hw.hscx.rcvidx += count;\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "bch_empty_fifo() B-%d cnt %d", hscx, count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", bcs->blog);\r\n}\r\n}\r\nstatic void\r\nbch_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs;\r\nint more, count, cnt;\r\nu_char *ptr, *p, hscx;\r\ncs = bcs->cs;\r\nif ((cs->debug & L1_DEB_HSCX) && !(cs->debug & L1_DEB_HSCX_FIFO))\r\ndebugl1(cs, "bch_fill_fifo()");\r\nif (!bcs->tx_skb) return;\r\nif (bcs->tx_skb->len <= 0) return;\r\nhscx = bcs->hw.hscx.hscx;\r\nmore = (bcs->mode == L1_MODE_TRANS) ? 1 : 0;\r\nif (bcs->tx_skb->len > B_FIFO_SIZE) {\r\nmore = 1;\r\ncount = B_FIFO_SIZE;\r\n} else {\r\ncount = bcs->tx_skb->len;\r\n}\r\ncnt = count;\r\np = ptr = bcs->tx_skb->data;\r\nskb_pull(bcs->tx_skb, count);\r\nbcs->tx_cnt -= count;\r\nbcs->hw.hscx.count += count;\r\nwhile (cnt--) cs->BC_Write_Reg(cs, hscx, IPACX_XFIFOB, *p++);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, (more ? 0x08 : 0x0a));\r\nif (cs->debug & L1_DEB_HSCX_FIFO) {\r\nchar *t = bcs->blog;\r\nt += sprintf(t, "%s() B-%d cnt %d", __func__, hscx, count);\r\nQuickHex(t, ptr, count);\r\ndebugl1(cs, "%s", bcs->blog);\r\n}\r\n}\r\nstatic void\r\nbch_int(struct IsdnCardState *cs, u_char hscx)\r\n{\r\nu_char istab;\r\nstruct BCState *bcs;\r\nstruct sk_buff *skb;\r\nint count;\r\nu_char rstab;\r\nbcs = cs->bcs + hscx;\r\nistab = cs->BC_Read_Reg(cs, hscx, IPACX_ISTAB);\r\nif (!test_bit(BC_FLG_INIT, &bcs->Flag)) return;\r\nif (istab & 0x80) {\r\nrstab = cs->BC_Read_Reg(cs, hscx, IPACX_RSTAB);\r\nif ((rstab & 0xf0) != 0xa0) {\r\nif (!(rstab & 0x80))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_int() B-%d: invalid frame", hscx);\r\nif ((rstab & 0x40) && (bcs->mode != L1_MODE_NULL))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_int() B-%d: RDO mode=%d", hscx, bcs->mode);\r\nif (!(rstab & 0x20))\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_int() B-%d: CRC error", hscx);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x80);\r\n}\r\nelse {\r\ncount = cs->BC_Read_Reg(cs, hscx, IPACX_RBCLB) & (B_FIFO_SIZE - 1);\r\nif (count == 0) count = B_FIFO_SIZE;\r\nbch_empty_fifo(bcs, count);\r\nif ((count = bcs->hw.hscx.rcvidx - 1) > 0) {\r\nif (cs->debug & L1_DEB_HSCX_FIFO)\r\ndebugl1(cs, "bch_int Frame %d", count);\r\nif (!(skb = dev_alloc_skb(count)))\r\nprintk(KERN_WARNING "HiSax bch_int(): receive frame out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, count), bcs->hw.hscx.rcvbuf, count);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\n}\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\nif (istab & 0x40) {\r\nbch_empty_fifo(bcs, B_FIFO_SIZE);\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nif (!(skb = dev_alloc_skb(B_FIFO_SIZE)))\r\nprintk(KERN_WARNING "HiSax bch_int(): receive transparent out of memory\n");\r\nelse {\r\nmemcpy(skb_put(skb, B_FIFO_SIZE), bcs->hw.hscx.rcvbuf, B_FIFO_SIZE);\r\nskb_queue_tail(&bcs->rqueue, skb);\r\n}\r\nbcs->hw.hscx.rcvidx = 0;\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\n}\r\nif (istab & 0x20) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_int() B-%d: RFO error", hscx);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x40);\r\n}\r\nif (istab & 0x10) {\r\nif (bcs->tx_skb) {\r\nif (bcs->tx_skb->len) {\r\nbch_fill_fifo(bcs);\r\ngoto afterXPR;\r\n} else {\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->hw.hscx.count;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\n}\r\ndev_kfree_skb_irq(bcs->tx_skb);\r\nbcs->hw.hscx.count = 0;\r\nbcs->tx_skb = NULL;\r\n}\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nbcs->hw.hscx.count = 0;\r\nset_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbch_fill_fifo(bcs);\r\n} else {\r\nclear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\nafterXPR:\r\nif (istab & 0x04) {\r\nif (bcs->mode == L1_MODE_TRANS) {\r\nbch_fill_fifo(bcs);\r\n}\r\nelse {\r\nif (bcs->tx_skb) {\r\nskb_push(bcs->tx_skb, bcs->hw.hscx.count);\r\nbcs->tx_cnt += bcs->hw.hscx.count;\r\nbcs->hw.hscx.count = 0;\r\n}\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x01);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "bch_int() B-%d XDU error", hscx);\r\n}\r\n}\r\n}\r\nstatic void\r\nbch_mode(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint hscx = bcs->hw.hscx.hscx;\r\nbc = bc ? 1 : 0;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "mode_bch() switch B-%d mode %d chan %d", hscx, mode, bc);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nif (!hscx)\r\n{\r\ncs->writeisac(cs, IPACX_BCHA_TSDP_BC1, 0x80 | bc);\r\ncs->writeisac(cs, IPACX_BCHA_CR, 0x88);\r\n}\r\nelse\r\n{\r\ncs->writeisac(cs, IPACX_BCHB_TSDP_BC1, 0x80 | bc);\r\ncs->writeisac(cs, IPACX_BCHB_CR, 0x88);\r\n}\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MODEB, 0xC0);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_EXMB, 0x30);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MASKB, 0xFF);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x41);\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MODEB, 0x88);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_EXMB, 0x00);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x41);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MASKB, _MASKB_IMASK);\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MODEB, 0xC8);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_EXMB, 0x01);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_CMDRB, 0x41);\r\ncs->BC_Write_Reg(cs, hscx, IPACX_MASKB, _MASKB_IMASK);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbch_close_state(struct BCState *bcs)\r\n{\r\nbch_mode(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nkfree(bcs->blog);\r\nbcs->blog = NULL;\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\nclear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nbch_open_state(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nif (!(bcs->hw.hscx.rcvbuf = kmalloc(HSCX_BUFMAX, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax open_bchstate(): No memory for hscx.rcvbuf\n");\r\nclear_bit(BC_FLG_INIT, &bcs->Flag);\r\nreturn (1);\r\n}\r\nif (!(bcs->blog = kmalloc(MAX_BLOG_SPACE, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING\r\n"HiSax open_bchstate: No memory for bcs->blog\n");\r\nclear_bit(BC_FLG_INIT, &bcs->Flag);\r\nkfree(bcs->hw.hscx.rcvbuf);\r\nbcs->hw.hscx.rcvbuf = NULL;\r\nreturn (2);\r\n}\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\nclear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->hw.hscx.rcvidx = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nbch_setstack(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (bch_open_state(st->l1.hardware, bcs)) return (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = bch_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\nbch_init(struct IsdnCardState *cs, int hscx)\r\n{\r\ncs->bcs[hscx].BC_SetStack = bch_setstack;\r\ncs->bcs[hscx].BC_Close = bch_close_state;\r\ncs->bcs[hscx].hw.hscx.hscx = hscx;\r\ncs->bcs[hscx].cs = cs;\r\nbch_mode(cs->bcs + hscx, 0, hscx);\r\n}\r\nvoid\r\ninterrupt_ipacx(struct IsdnCardState *cs)\r\n{\r\nu_char ista;\r\nwhile ((ista = cs->readisac(cs, IPACX_ISTA))) {\r\nif (ista & 0x80) bch_int(cs, 0);\r\nif (ista & 0x40) bch_int(cs, 1);\r\nif (ista & 0x01) dch_int(cs);\r\nif (ista & 0x10) cic_int(cs);\r\n}\r\n}\r\nstatic void\r\nclear_pending_ints(struct IsdnCardState *cs)\r\n{\r\nint ista;\r\ncs->writeisac(cs, IPACX_MASK, 0xff);\r\ncs->writeisac(cs, IPACX_MASKD, 0xff);\r\ncs->BC_Write_Reg(cs, 0, IPACX_MASKB, 0xff);\r\ncs->BC_Write_Reg(cs, 1, IPACX_MASKB, 0xff);\r\nista = cs->readisac(cs, IPACX_ISTA);\r\nif (ista & 0x80) cs->BC_Read_Reg(cs, 0, IPACX_ISTAB);\r\nif (ista & 0x40) cs->BC_Read_Reg(cs, 1, IPACX_ISTAB);\r\nif (ista & 0x10) cs->readisac(cs, IPACX_CIR0);\r\nif (ista & 0x01) cs->readisac(cs, IPACX_ISTAD);\r\n}\r\nvoid\r\ninit_ipacx(struct IsdnCardState *cs, int part)\r\n{\r\nif (part & 1) {\r\nclear_pending_ints(cs);\r\nbch_init(cs, 0);\r\nbch_init(cs, 1);\r\ndch_init(cs);\r\n}\r\nif (part & 2) {\r\ncs->BC_Write_Reg(cs, 0, IPACX_MASKB, _MASKB_IMASK);\r\ncs->BC_Write_Reg(cs, 1, IPACX_MASKB, _MASKB_IMASK);\r\ncs->writeisac(cs, IPACX_MASKD, _MASKD_IMASK);\r\ncs->writeisac(cs, IPACX_MASK, _MASK_IMASK);\r\ncs->writeisac(cs, IPACX_CMDRD, 0x41);\r\ncs->BC_Write_Reg(cs, 0, IPACX_CMDRB, 0x41);\r\ncs->BC_Write_Reg(cs, 1, IPACX_CMDRB, 0x41);\r\nph_command(cs, IPACX_CMD_RES);\r\n}\r\n}
