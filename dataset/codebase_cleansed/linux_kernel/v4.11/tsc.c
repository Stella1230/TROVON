int perf_read_tsc_conversion(const struct perf_event_mmap_page *pc,\r\nstruct perf_tsc_conversion *tc)\r\n{\r\nbool cap_user_time_zero;\r\nu32 seq;\r\nint i = 0;\r\nwhile (1) {\r\nseq = pc->lock;\r\nrmb();\r\ntc->time_mult = pc->time_mult;\r\ntc->time_shift = pc->time_shift;\r\ntc->time_zero = pc->time_zero;\r\ncap_user_time_zero = pc->cap_user_time_zero;\r\nrmb();\r\nif (pc->lock == seq && !(seq & 1))\r\nbreak;\r\nif (++i > 10000) {\r\npr_debug("failed to get perf_event_mmap_page lock\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!cap_user_time_zero)\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nu64 rdtsc(void)\r\n{\r\nunsigned int low, high;\r\nasm volatile("rdtsc" : "=a" (low), "=d" (high));\r\nreturn low | ((u64)high) << 32;\r\n}\r\nint perf_event__synth_time_conv(const struct perf_event_mmap_page *pc,\r\nstruct perf_tool *tool,\r\nperf_event__handler_t process,\r\nstruct machine *machine)\r\n{\r\nunion perf_event event = {\r\n.time_conv = {\r\n.header = {\r\n.type = PERF_RECORD_TIME_CONV,\r\n.size = sizeof(struct time_conv_event),\r\n},\r\n},\r\n};\r\nstruct perf_tsc_conversion tc;\r\nint err;\r\nif (!pc)\r\nreturn 0;\r\nerr = perf_read_tsc_conversion(pc, &tc);\r\nif (err == -EOPNOTSUPP)\r\nreturn 0;\r\nif (err)\r\nreturn err;\r\npr_debug2("Synthesizing TSC conversion information\n");\r\nevent.time_conv.time_mult = tc.time_mult;\r\nevent.time_conv.time_shift = tc.time_shift;\r\nevent.time_conv.time_zero = tc.time_zero;\r\nreturn process(tool, &event, NULL, machine);\r\n}
