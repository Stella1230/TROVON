static bool cs42l42_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L42_PAGE_REGISTER:\r\ncase CS42L42_DEVID_AB:\r\ncase CS42L42_DEVID_CD:\r\ncase CS42L42_DEVID_E:\r\ncase CS42L42_FABID:\r\ncase CS42L42_REVID:\r\ncase CS42L42_FRZ_CTL:\r\ncase CS42L42_SRC_CTL:\r\ncase CS42L42_MCLK_STATUS:\r\ncase CS42L42_MCLK_CTL:\r\ncase CS42L42_SFTRAMP_RATE:\r\ncase CS42L42_I2C_DEBOUNCE:\r\ncase CS42L42_I2C_STRETCH:\r\ncase CS42L42_I2C_TIMEOUT:\r\ncase CS42L42_PWR_CTL1:\r\ncase CS42L42_PWR_CTL2:\r\ncase CS42L42_PWR_CTL3:\r\ncase CS42L42_RSENSE_CTL1:\r\ncase CS42L42_RSENSE_CTL2:\r\ncase CS42L42_OSC_SWITCH:\r\ncase CS42L42_OSC_SWITCH_STATUS:\r\ncase CS42L42_RSENSE_CTL3:\r\ncase CS42L42_TSENSE_CTL:\r\ncase CS42L42_TSRS_INT_DISABLE:\r\ncase CS42L42_TRSENSE_STATUS:\r\ncase CS42L42_HSDET_CTL1:\r\ncase CS42L42_HSDET_CTL2:\r\ncase CS42L42_HS_SWITCH_CTL:\r\ncase CS42L42_HS_DET_STATUS:\r\ncase CS42L42_HS_CLAMP_DISABLE:\r\ncase CS42L42_MCLK_SRC_SEL:\r\ncase CS42L42_SPDIF_CLK_CFG:\r\ncase CS42L42_FSYNC_PW_LOWER:\r\ncase CS42L42_FSYNC_PW_UPPER:\r\ncase CS42L42_FSYNC_P_LOWER:\r\ncase CS42L42_FSYNC_P_UPPER:\r\ncase CS42L42_ASP_CLK_CFG:\r\ncase CS42L42_ASP_FRM_CFG:\r\ncase CS42L42_FS_RATE_EN:\r\ncase CS42L42_IN_ASRC_CLK:\r\ncase CS42L42_OUT_ASRC_CLK:\r\ncase CS42L42_PLL_DIV_CFG1:\r\ncase CS42L42_ADC_OVFL_STATUS:\r\ncase CS42L42_MIXER_STATUS:\r\ncase CS42L42_SRC_STATUS:\r\ncase CS42L42_ASP_RX_STATUS:\r\ncase CS42L42_ASP_TX_STATUS:\r\ncase CS42L42_CODEC_STATUS:\r\ncase CS42L42_DET_INT_STATUS1:\r\ncase CS42L42_DET_INT_STATUS2:\r\ncase CS42L42_SRCPL_INT_STATUS:\r\ncase CS42L42_VPMON_STATUS:\r\ncase CS42L42_PLL_LOCK_STATUS:\r\ncase CS42L42_TSRS_PLUG_STATUS:\r\ncase CS42L42_ADC_OVFL_INT_MASK:\r\ncase CS42L42_MIXER_INT_MASK:\r\ncase CS42L42_SRC_INT_MASK:\r\ncase CS42L42_ASP_RX_INT_MASK:\r\ncase CS42L42_ASP_TX_INT_MASK:\r\ncase CS42L42_CODEC_INT_MASK:\r\ncase CS42L42_SRCPL_INT_MASK:\r\ncase CS42L42_VPMON_INT_MASK:\r\ncase CS42L42_PLL_LOCK_INT_MASK:\r\ncase CS42L42_TSRS_PLUG_INT_MASK:\r\ncase CS42L42_PLL_CTL1:\r\ncase CS42L42_PLL_DIV_FRAC0:\r\ncase CS42L42_PLL_DIV_FRAC1:\r\ncase CS42L42_PLL_DIV_FRAC2:\r\ncase CS42L42_PLL_DIV_INT:\r\ncase CS42L42_PLL_CTL3:\r\ncase CS42L42_PLL_CAL_RATIO:\r\ncase CS42L42_PLL_CTL4:\r\ncase CS42L42_LOAD_DET_RCSTAT:\r\ncase CS42L42_LOAD_DET_DONE:\r\ncase CS42L42_LOAD_DET_EN:\r\ncase CS42L42_HSBIAS_SC_AUTOCTL:\r\ncase CS42L42_WAKE_CTL:\r\ncase CS42L42_ADC_DISABLE_MUTE:\r\ncase CS42L42_TIPSENSE_CTL:\r\ncase CS42L42_MISC_DET_CTL:\r\ncase CS42L42_MIC_DET_CTL1:\r\ncase CS42L42_MIC_DET_CTL2:\r\ncase CS42L42_DET_STATUS1:\r\ncase CS42L42_DET_STATUS2:\r\ncase CS42L42_DET_INT1_MASK:\r\ncase CS42L42_DET_INT2_MASK:\r\ncase CS42L42_HS_BIAS_CTL:\r\ncase CS42L42_ADC_CTL:\r\ncase CS42L42_ADC_VOLUME:\r\ncase CS42L42_ADC_WNF_HPF_CTL:\r\ncase CS42L42_DAC_CTL1:\r\ncase CS42L42_DAC_CTL2:\r\ncase CS42L42_HP_CTL:\r\ncase CS42L42_CLASSH_CTL:\r\ncase CS42L42_MIXER_CHA_VOL:\r\ncase CS42L42_MIXER_ADC_VOL:\r\ncase CS42L42_MIXER_CHB_VOL:\r\ncase CS42L42_EQ_COEF_IN0:\r\ncase CS42L42_EQ_COEF_IN1:\r\ncase CS42L42_EQ_COEF_IN2:\r\ncase CS42L42_EQ_COEF_IN3:\r\ncase CS42L42_EQ_COEF_RW:\r\ncase CS42L42_EQ_COEF_OUT0:\r\ncase CS42L42_EQ_COEF_OUT1:\r\ncase CS42L42_EQ_COEF_OUT2:\r\ncase CS42L42_EQ_COEF_OUT3:\r\ncase CS42L42_EQ_INIT_STAT:\r\ncase CS42L42_EQ_START_FILT:\r\ncase CS42L42_EQ_MUTE_CTL:\r\ncase CS42L42_SP_RX_CH_SEL:\r\ncase CS42L42_SP_RX_ISOC_CTL:\r\ncase CS42L42_SP_RX_FS:\r\ncase CS42l42_SPDIF_CH_SEL:\r\ncase CS42L42_SP_TX_ISOC_CTL:\r\ncase CS42L42_SP_TX_FS:\r\ncase CS42L42_SPDIF_SW_CTL1:\r\ncase CS42L42_SRC_SDIN_FS:\r\ncase CS42L42_SRC_SDOUT_FS:\r\ncase CS42L42_SPDIF_CTL1:\r\ncase CS42L42_SPDIF_CTL2:\r\ncase CS42L42_SPDIF_CTL3:\r\ncase CS42L42_SPDIF_CTL4:\r\ncase CS42L42_ASP_TX_SZ_EN:\r\ncase CS42L42_ASP_TX_CH_EN:\r\ncase CS42L42_ASP_TX_CH_AP_RES:\r\ncase CS42L42_ASP_TX_CH1_BIT_MSB:\r\ncase CS42L42_ASP_TX_CH1_BIT_LSB:\r\ncase CS42L42_ASP_TX_HIZ_DLY_CFG:\r\ncase CS42L42_ASP_TX_CH2_BIT_MSB:\r\ncase CS42L42_ASP_TX_CH2_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI0_EN:\r\ncase CS42L42_ASP_RX_DAI0_CH1_AP_RES:\r\ncase CS42L42_ASP_RX_DAI0_CH1_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI0_CH1_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI0_CH2_AP_RES:\r\ncase CS42L42_ASP_RX_DAI0_CH2_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI0_CH2_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI0_CH3_AP_RES:\r\ncase CS42L42_ASP_RX_DAI0_CH3_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI0_CH3_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI0_CH4_AP_RES:\r\ncase CS42L42_ASP_RX_DAI0_CH4_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI0_CH4_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI1_CH1_AP_RES:\r\ncase CS42L42_ASP_RX_DAI1_CH1_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI1_CH1_BIT_LSB:\r\ncase CS42L42_ASP_RX_DAI1_CH2_AP_RES:\r\ncase CS42L42_ASP_RX_DAI1_CH2_BIT_MSB:\r\ncase CS42L42_ASP_RX_DAI1_CH2_BIT_LSB:\r\ncase CS42L42_SUB_REVID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool cs42l42_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS42L42_DEVID_AB:\r\ncase CS42L42_DEVID_CD:\r\ncase CS42L42_DEVID_E:\r\ncase CS42L42_MCLK_STATUS:\r\ncase CS42L42_TRSENSE_STATUS:\r\ncase CS42L42_HS_DET_STATUS:\r\ncase CS42L42_ADC_OVFL_STATUS:\r\ncase CS42L42_MIXER_STATUS:\r\ncase CS42L42_SRC_STATUS:\r\ncase CS42L42_ASP_RX_STATUS:\r\ncase CS42L42_ASP_TX_STATUS:\r\ncase CS42L42_CODEC_STATUS:\r\ncase CS42L42_DET_INT_STATUS1:\r\ncase CS42L42_DET_INT_STATUS2:\r\ncase CS42L42_SRCPL_INT_STATUS:\r\ncase CS42L42_VPMON_STATUS:\r\ncase CS42L42_PLL_LOCK_STATUS:\r\ncase CS42L42_TSRS_PLUG_STATUS:\r\ncase CS42L42_LOAD_DET_RCSTAT:\r\ncase CS42L42_LOAD_DET_DONE:\r\ncase CS42L42_DET_STATUS1:\r\ncase CS42L42_DET_STATUS2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs42l42_hpdrv_evt(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nif (event & SND_SOC_DAPM_POST_PMU) {\r\nsnd_soc_update_bits(codec, CS42L42_ASP_RX_DAI0_EN,\r\nCS42L42_ASP_RX0_CH_EN_MASK,\r\n(CS42L42_ASP_RX0_CH1_EN |\r\nCS42L42_ASP_RX0_CH2_EN) <<\r\nCS42L42_ASP_RX0_CH_EN_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L42_PWR_CTL1,\r\nCS42L42_ASP_DAI_PDN_MASK | CS42L42_MIXER_PDN_MASK |\r\nCS42L42_HP_PDN_MASK, 0);\r\n} else if (event & SND_SOC_DAPM_PRE_PMD) {\r\nsnd_soc_update_bits(codec, CS42L42_ASP_RX_DAI0_EN,\r\nCS42L42_ASP_RX0_CH_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, CS42L42_PWR_CTL1,\r\nCS42L42_ASP_DAI_PDN_MASK | CS42L42_MIXER_PDN_MASK |\r\nCS42L42_HP_PDN_MASK,\r\nCS42L42_ASP_DAI_PDN_MASK | CS42L42_MIXER_PDN_MASK |\r\nCS42L42_HP_PDN_MASK);\r\n} else {\r\ndev_err(codec->dev, "Invalid event 0x%x\n", event);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l42_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct cs42l42_private *cs42l42 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nregcache_cache_only(cs42l42->regmap, false);\r\nregcache_sync(cs42l42->regmap);\r\nret = regulator_bulk_enable(\r\nARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to enable regulators: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregcache_cache_only(cs42l42->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs42l42_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l42_private *cs42l42 =\r\n(struct cs42l42_private *)snd_soc_codec_get_drvdata(codec);\r\ncs42l42->codec = codec;\r\nreturn 0;\r\n}\r\nstatic int cs42l42_pll_config(struct snd_soc_codec *codec)\r\n{\r\nstruct cs42l42_private *cs42l42 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nu32 fsync;\r\nfor (i = 0; i < ARRAY_SIZE(pll_ratio_table); i++) {\r\nif (pll_ratio_table[i].sclk == cs42l42->sclk) {\r\nsnd_soc_update_bits(codec, CS42L42_MCLK_CTL,\r\nCS42L42_INTERNAL_FS_MASK,\r\n((pll_ratio_table[i].mclk_int !=\r\n12000000) &&\r\n(pll_ratio_table[i].mclk_int !=\r\n24000000)) <<\r\nCS42L42_INTERNAL_FS_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L42_MCLK_SRC_SEL,\r\nCS42L42_MCLK_SRC_SEL_MASK |\r\nCS42L42_MCLKDIV_MASK,\r\n(pll_ratio_table[i].mclk_src_sel\r\n<< CS42L42_MCLK_SRC_SEL_SHIFT) |\r\n(pll_ratio_table[i].mclk_div <<\r\nCS42L42_MCLKDIV_SHIFT));\r\nfsync = cs42l42->sclk / cs42l42->srate;\r\nif (((fsync * cs42l42->srate) != cs42l42->sclk)\r\n|| ((fsync % 2) != 0)) {\r\ndev_err(codec->dev,\r\n"Unsupported sclk %d/sample rate %d\n",\r\ncs42l42->sclk,\r\ncs42l42->srate);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nCS42L42_FSYNC_P_LOWER,\r\nCS42L42_FSYNC_PERIOD_MASK,\r\nCS42L42_FRAC0_VAL(fsync - 1) <<\r\nCS42L42_FSYNC_PERIOD_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_FSYNC_P_UPPER,\r\nCS42L42_FSYNC_PERIOD_MASK,\r\nCS42L42_FRAC1_VAL(fsync - 1) <<\r\nCS42L42_FSYNC_PERIOD_SHIFT);\r\nfsync = fsync / 2;\r\nsnd_soc_update_bits(codec,\r\nCS42L42_FSYNC_PW_LOWER,\r\nCS42L42_FSYNC_PULSE_WIDTH_MASK,\r\nCS42L42_FRAC0_VAL(fsync - 1) <<\r\nCS42L42_FSYNC_PULSE_WIDTH_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_FSYNC_PW_UPPER,\r\nCS42L42_FSYNC_PULSE_WIDTH_MASK,\r\nCS42L42_FRAC1_VAL(fsync - 1) <<\r\nCS42L42_FSYNC_PULSE_WIDTH_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_ASP_FRM_CFG,\r\nCS42L42_ASP_5050_MASK,\r\nCS42L42_ASP_5050_MASK);\r\nsnd_soc_update_bits(codec, CS42L42_ASP_FRM_CFG,\r\nCS42L42_ASP_FSD_MASK,\r\nCS42L42_ASP_FSD_1_0 <<\r\nCS42L42_ASP_FSD_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L42_FS_RATE_EN,\r\nCS42L42_FS_EN_MASK,\r\n(CS42L42_FS_EN_IASRC_96K |\r\nCS42L42_FS_EN_OASRC_96K) <<\r\nCS42L42_FS_EN_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L42_IN_ASRC_CLK,\r\nCS42L42_CLK_IASRC_SEL_MASK,\r\nCS42L42_CLK_IASRC_SEL_12 <<\r\nCS42L42_CLK_IASRC_SEL_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_OUT_ASRC_CLK,\r\nCS42L42_CLK_OASRC_SEL_MASK,\r\nCS42L42_CLK_OASRC_SEL_12 <<\r\nCS42L42_CLK_OASRC_SEL_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_ASP_RX_DAI0_CH1_AP_RES,\r\nCS42L42_ASP_RX_CH_AP_MASK |\r\nCS42L42_ASP_RX_CH_RES_MASK,\r\n(CS42L42_ASP_RX_CH_AP_LOW <<\r\nCS42L42_ASP_RX_CH_AP_SHIFT) |\r\n(CS42L42_ASP_RX_CH_RES_32 <<\r\nCS42L42_ASP_RX_CH_RES_SHIFT));\r\nsnd_soc_update_bits(codec,\r\nCS42L42_ASP_RX_DAI0_CH2_AP_RES,\r\nCS42L42_ASP_RX_CH_AP_MASK |\r\nCS42L42_ASP_RX_CH_RES_MASK,\r\n(CS42L42_ASP_RX_CH_AP_HI <<\r\nCS42L42_ASP_RX_CH_AP_SHIFT) |\r\n(CS42L42_ASP_RX_CH_RES_32 <<\r\nCS42L42_ASP_RX_CH_RES_SHIFT));\r\nif (pll_ratio_table[i].mclk_src_sel == 0) {\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_CTL1,\r\nCS42L42_PLL_START_MASK, 0);\r\n} else {\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_DIV_CFG1,\r\nCS42L42_SCLK_PREDIV_MASK,\r\npll_ratio_table[i].sclk_prediv\r\n<< CS42L42_SCLK_PREDIV_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_DIV_INT,\r\nCS42L42_PLL_DIV_INT_MASK,\r\npll_ratio_table[i].pll_div_int\r\n<< CS42L42_PLL_DIV_INT_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_DIV_FRAC0,\r\nCS42L42_PLL_DIV_FRAC_MASK,\r\nCS42L42_FRAC0_VAL(\r\npll_ratio_table[i].pll_div_frac)\r\n<< CS42L42_PLL_DIV_FRAC_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_DIV_FRAC1,\r\nCS42L42_PLL_DIV_FRAC_MASK,\r\nCS42L42_FRAC1_VAL(\r\npll_ratio_table[i].pll_div_frac)\r\n<< CS42L42_PLL_DIV_FRAC_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_DIV_FRAC2,\r\nCS42L42_PLL_DIV_FRAC_MASK,\r\nCS42L42_FRAC2_VAL(\r\npll_ratio_table[i].pll_div_frac)\r\n<< CS42L42_PLL_DIV_FRAC_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_CTL4,\r\nCS42L42_PLL_MODE_MASK,\r\npll_ratio_table[i].pll_mode\r\n<< CS42L42_PLL_MODE_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_CTL3,\r\nCS42L42_PLL_DIVOUT_MASK,\r\npll_ratio_table[i].pll_divout\r\n<< CS42L42_PLL_DIVOUT_SHIFT);\r\nsnd_soc_update_bits(codec,\r\nCS42L42_PLL_CAL_RATIO,\r\nCS42L42_PLL_CAL_RATIO_MASK,\r\npll_ratio_table[i].pll_cal_ratio\r\n<< CS42L42_PLL_CAL_RATIO_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs42l42_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu32 asp_cfg_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nasp_cfg_val |= CS42L42_ASP_MASTER_MODE <<\r\nCS42L42_ASP_MODE_SHIFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nasp_cfg_val |= CS42L42_ASP_SLAVE_MODE <<\r\nCS42L42_ASP_MODE_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nasp_cfg_val |= CS42L42_ASP_POL_INV <<\r\nCS42L42_ASP_LCPOL_IN_SHIFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nasp_cfg_val |= CS42L42_ASP_POL_INV <<\r\nCS42L42_ASP_SCPOL_IN_DAC_SHIFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nasp_cfg_val |= CS42L42_ASP_POL_INV <<\r\nCS42L42_ASP_LCPOL_IN_SHIFT;\r\nasp_cfg_val |= CS42L42_ASP_POL_INV <<\r\nCS42L42_ASP_SCPOL_IN_DAC_SHIFT;\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, CS42L42_ASP_CLK_CFG,\r\nCS42L42_ASP_MODE_MASK |\r\nCS42L42_ASP_SCPOL_IN_DAC_MASK |\r\nCS42L42_ASP_LCPOL_IN_MASK, asp_cfg_val);\r\nreturn 0;\r\n}\r\nstatic int cs42l42_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l42_private *cs42l42 = snd_soc_codec_get_drvdata(codec);\r\nint retval;\r\ncs42l42->srate = params_rate(params);\r\ncs42l42->swidth = params_width(params);\r\nretval = cs42l42_pll_config(codec);\r\nreturn retval;\r\n}\r\nstatic int cs42l42_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct cs42l42_private *cs42l42 = snd_soc_codec_get_drvdata(codec);\r\ncs42l42->sclk = freq;\r\nreturn 0;\r\n}\r\nstatic int cs42l42_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int regval;\r\nu8 fullScaleVol;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, CS42L42_OSC_SWITCH,\r\nCS42L42_SCLK_PRESENT_MASK, 0);\r\nsnd_soc_update_bits(codec, CS42L42_PLL_CTL1,\r\nCS42L42_PLL_START_MASK,\r\n0 << CS42L42_PLL_START_SHIFT);\r\nsnd_soc_update_bits(codec, CS42L42_HP_CTL,\r\nCS42L42_HP_ANA_AMUTE_MASK |\r\nCS42L42_HP_ANA_BMUTE_MASK,\r\nCS42L42_HP_ANA_AMUTE_MASK |\r\nCS42L42_HP_ANA_BMUTE_MASK);\r\n} else {\r\nsnd_soc_update_bits(codec, CS42L42_PLL_CTL1,\r\nCS42L42_PLL_START_MASK,\r\n1 << CS42L42_PLL_START_SHIFT);\r\nregval = snd_soc_read(codec, CS42L42_LOAD_DET_RCSTAT);\r\nif (((regval & CS42L42_RLA_STAT_MASK) >>\r\nCS42L42_RLA_STAT_SHIFT) == CS42L42_RLA_STAT_15_OHM) {\r\nfullScaleVol = CS42L42_HP_FULL_SCALE_VOL_MASK;\r\n} else {\r\nfullScaleVol = 0;\r\n}\r\nsnd_soc_update_bits(codec, CS42L42_HP_CTL,\r\nCS42L42_HP_ANA_AMUTE_MASK |\r\nCS42L42_HP_ANA_BMUTE_MASK |\r\nCS42L42_HP_FULL_SCALE_VOL_MASK, fullScaleVol);\r\nsnd_soc_update_bits(codec, CS42L42_OSC_SWITCH,\r\nCS42L42_SCLK_PRESENT_MASK,\r\nCS42L42_SCLK_PRESENT_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs42l42_process_hs_type_detect(struct cs42l42_private *cs42l42)\r\n{\r\nunsigned int hs_det_status;\r\nunsigned int int_status;\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_CODEC_INT_MASK,\r\nCS42L42_PDN_DONE_MASK |\r\nCS42L42_HSDET_AUTO_DONE_MASK,\r\n(1 << CS42L42_PDN_DONE_SHIFT) |\r\n(1 << CS42L42_HSDET_AUTO_DONE_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSDET_CTL2,\r\nCS42L42_HSDET_CTRL_MASK |\r\nCS42L42_HSDET_SET_MASK |\r\nCS42L42_HSBIAS_REF_MASK |\r\nCS42L42_HSDET_AUTO_TIME_MASK,\r\n(2 << CS42L42_HSDET_CTRL_SHIFT) |\r\n(2 << CS42L42_HSDET_SET_SHIFT) |\r\n(0 << CS42L42_HSBIAS_REF_SHIFT) |\r\n(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\r\nregmap_read(cs42l42->regmap, CS42L42_HS_DET_STATUS, &hs_det_status);\r\ncs42l42->hs_type = (hs_det_status & CS42L42_HSDET_TYPE_MASK) >>\r\nCS42L42_HSDET_TYPE_SHIFT;\r\nif ((cs42l42->hs_type == CS42L42_PLUG_CTIA) ||\r\n(cs42l42->hs_type == CS42L42_PLUG_OMTP)) {\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSBIAS_SC_AUTOCTL,\r\nCS42L42_HSBIAS_SENSE_EN_MASK |\r\nCS42L42_AUTO_HSBIAS_HIZ_MASK |\r\nCS42L42_TIP_SENSE_EN_MASK |\r\nCS42L42_HSBIAS_SENSE_TRIP_MASK,\r\n(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\r\n(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\r\n(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\r\n(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MIC_DET_CTL1,\r\nCS42L42_LATCH_TO_VP_MASK |\r\nCS42L42_EVENT_STAT_SEL_MASK |\r\nCS42L42_HS_DET_LEVEL_MASK,\r\n(1 << CS42L42_LATCH_TO_VP_SHIFT) |\r\n(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\r\n(cs42l42->bias_thresholds[0] <<\r\nCS42L42_HS_DET_LEVEL_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSBIAS_SC_AUTOCTL,\r\nCS42L42_HSBIAS_SENSE_EN_MASK |\r\nCS42L42_AUTO_HSBIAS_HIZ_MASK |\r\nCS42L42_TIP_SENSE_EN_MASK |\r\nCS42L42_HSBIAS_SENSE_TRIP_MASK,\r\n(1 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\r\n(1 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\r\n(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\r\n(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MISC_DET_CTL,\r\nCS42L42_DETECT_MODE_MASK |\r\nCS42L42_HSBIAS_CTL_MASK |\r\nCS42L42_PDN_MIC_LVL_DET_MASK,\r\n(0 << CS42L42_DETECT_MODE_SHIFT) |\r\n(3 << CS42L42_HSBIAS_CTL_SHIFT) |\r\n(0 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\r\nmsleep(cs42l42->btn_det_init_dbnce);\r\nregmap_read(cs42l42->regmap, CS42L42_DET_INT_STATUS2,\r\n&int_status);\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DET_INT2_MASK,\r\nCS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK |\r\nCS42L42_M_SHORT_RLS_MASK |\r\nCS42L42_M_SHORT_DET_MASK,\r\n(0 << CS42L42_M_DETECT_TF_SHIFT) |\r\n(0 << CS42L42_M_DETECT_FT_SHIFT) |\r\n(0 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\r\n(1 << CS42L42_M_SHORT_RLS_SHIFT) |\r\n(1 << CS42L42_M_SHORT_DET_SHIFT));\r\n} else {\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MISC_DET_CTL,\r\nCS42L42_DETECT_MODE_MASK |\r\nCS42L42_HSBIAS_CTL_MASK |\r\nCS42L42_PDN_MIC_LVL_DET_MASK,\r\n(0 << CS42L42_DETECT_MODE_SHIFT) |\r\n(1 << CS42L42_HSBIAS_CTL_SHIFT) |\r\n(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\r\n}\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DAC_CTL2,\r\nCS42L42_HPOUT_PULLDOWN_MASK |\r\nCS42L42_HPOUT_LOAD_MASK |\r\nCS42L42_HPOUT_CLAMP_MASK |\r\nCS42L42_DAC_HPF_EN_MASK |\r\nCS42L42_DAC_MON_EN_MASK,\r\n(0 << CS42L42_HPOUT_PULLDOWN_SHIFT) |\r\n(0 << CS42L42_HPOUT_LOAD_SHIFT) |\r\n(0 << CS42L42_HPOUT_CLAMP_SHIFT) |\r\n(1 << CS42L42_DAC_HPF_EN_SHIFT) |\r\n(0 << CS42L42_DAC_MON_EN_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_TSRS_PLUG_INT_MASK,\r\nCS42L42_RS_PLUG_MASK |\r\nCS42L42_RS_UNPLUG_MASK |\r\nCS42L42_TS_PLUG_MASK |\r\nCS42L42_TS_UNPLUG_MASK,\r\n(1 << CS42L42_RS_PLUG_SHIFT) |\r\n(1 << CS42L42_RS_UNPLUG_SHIFT) |\r\n(0 << CS42L42_TS_PLUG_SHIFT) |\r\n(0 << CS42L42_TS_UNPLUG_SHIFT));\r\n}\r\nstatic void cs42l42_init_hs_type_detect(struct cs42l42_private *cs42l42)\r\n{\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_TSRS_PLUG_INT_MASK,\r\nCS42L42_RS_PLUG_MASK |\r\nCS42L42_RS_UNPLUG_MASK |\r\nCS42L42_TS_PLUG_MASK |\r\nCS42L42_TS_UNPLUG_MASK,\r\n(1 << CS42L42_RS_PLUG_SHIFT) |\r\n(1 << CS42L42_RS_UNPLUG_SHIFT) |\r\n(1 << CS42L42_TS_PLUG_SHIFT) |\r\n(1 << CS42L42_TS_UNPLUG_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MISC_DET_CTL,\r\nCS42L42_DETECT_MODE_MASK |\r\nCS42L42_HSBIAS_CTL_MASK |\r\nCS42L42_PDN_MIC_LVL_DET_MASK,\r\n(0 << CS42L42_DETECT_MODE_SHIFT) |\r\n(1 << CS42L42_HSBIAS_CTL_SHIFT) |\r\n(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSBIAS_SC_AUTOCTL,\r\nCS42L42_HSBIAS_SENSE_EN_MASK |\r\nCS42L42_AUTO_HSBIAS_HIZ_MASK |\r\nCS42L42_TIP_SENSE_EN_MASK |\r\nCS42L42_HSBIAS_SENSE_TRIP_MASK,\r\n(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\r\n(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\r\n(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\r\n(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSDET_CTL2,\r\nCS42L42_HSDET_CTRL_MASK |\r\nCS42L42_HSDET_SET_MASK |\r\nCS42L42_HSBIAS_REF_MASK |\r\nCS42L42_HSDET_AUTO_TIME_MASK,\r\n(0 << CS42L42_HSDET_CTRL_SHIFT) |\r\n(2 << CS42L42_HSDET_SET_SHIFT) |\r\n(0 << CS42L42_HSBIAS_REF_SHIFT) |\r\n(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DAC_CTL2,\r\nCS42L42_HPOUT_PULLDOWN_MASK |\r\nCS42L42_HPOUT_LOAD_MASK |\r\nCS42L42_HPOUT_CLAMP_MASK |\r\nCS42L42_DAC_HPF_EN_MASK |\r\nCS42L42_DAC_MON_EN_MASK,\r\n(8 << CS42L42_HPOUT_PULLDOWN_SHIFT) |\r\n(0 << CS42L42_HPOUT_LOAD_SHIFT) |\r\n(1 << CS42L42_HPOUT_CLAMP_SHIFT) |\r\n(1 << CS42L42_DAC_HPF_EN_SHIFT) |\r\n(1 << CS42L42_DAC_MON_EN_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MISC_DET_CTL,\r\nCS42L42_DETECT_MODE_MASK |\r\nCS42L42_HSBIAS_CTL_MASK |\r\nCS42L42_PDN_MIC_LVL_DET_MASK,\r\n(0 << CS42L42_DETECT_MODE_SHIFT) |\r\n(3 << CS42L42_HSBIAS_CTL_SHIFT) |\r\n(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\r\nmsleep(cs42l42->hs_bias_ramp_time);\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_CODEC_INT_MASK,\r\nCS42L42_PDN_DONE_MASK |\r\nCS42L42_HSDET_AUTO_DONE_MASK,\r\n(1 << CS42L42_PDN_DONE_SHIFT) |\r\n(0 << CS42L42_HSDET_AUTO_DONE_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSDET_CTL2,\r\nCS42L42_HSDET_CTRL_MASK |\r\nCS42L42_HSDET_SET_MASK |\r\nCS42L42_HSBIAS_REF_MASK |\r\nCS42L42_HSDET_AUTO_TIME_MASK,\r\n(3 << CS42L42_HSDET_CTRL_SHIFT) |\r\n(2 << CS42L42_HSDET_SET_SHIFT) |\r\n(0 << CS42L42_HSBIAS_REF_SHIFT) |\r\n(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\r\n}\r\nstatic void cs42l42_cancel_hs_type_detect(struct cs42l42_private *cs42l42)\r\n{\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DET_INT2_MASK,\r\nCS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK |\r\nCS42L42_M_SHORT_RLS_MASK |\r\nCS42L42_M_SHORT_DET_MASK,\r\n(1 << CS42L42_M_DETECT_TF_SHIFT) |\r\n(1 << CS42L42_M_DETECT_FT_SHIFT) |\r\n(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\r\n(1 << CS42L42_M_SHORT_RLS_SHIFT) |\r\n(1 << CS42L42_M_SHORT_DET_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MISC_DET_CTL,\r\nCS42L42_DETECT_MODE_MASK |\r\nCS42L42_HSBIAS_CTL_MASK |\r\nCS42L42_PDN_MIC_LVL_DET_MASK,\r\n(0 << CS42L42_DETECT_MODE_SHIFT) |\r\n(1 << CS42L42_HSBIAS_CTL_SHIFT) |\r\n(1 << CS42L42_PDN_MIC_LVL_DET_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSBIAS_SC_AUTOCTL,\r\nCS42L42_HSBIAS_SENSE_EN_MASK |\r\nCS42L42_AUTO_HSBIAS_HIZ_MASK |\r\nCS42L42_TIP_SENSE_EN_MASK |\r\nCS42L42_HSBIAS_SENSE_TRIP_MASK,\r\n(0 << CS42L42_HSBIAS_SENSE_EN_SHIFT) |\r\n(0 << CS42L42_AUTO_HSBIAS_HIZ_SHIFT) |\r\n(0 << CS42L42_TIP_SENSE_EN_SHIFT) |\r\n(3 << CS42L42_HSBIAS_SENSE_TRIP_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HSDET_CTL2,\r\nCS42L42_HSDET_CTRL_MASK |\r\nCS42L42_HSDET_SET_MASK |\r\nCS42L42_HSBIAS_REF_MASK |\r\nCS42L42_HSDET_AUTO_TIME_MASK,\r\n(0 << CS42L42_HSDET_CTRL_SHIFT) |\r\n(2 << CS42L42_HSDET_SET_SHIFT) |\r\n(0 << CS42L42_HSBIAS_REF_SHIFT) |\r\n(3 << CS42L42_HSDET_AUTO_TIME_SHIFT));\r\n}\r\nstatic void cs42l42_handle_button_press(struct cs42l42_private *cs42l42)\r\n{\r\nint bias_level;\r\nunsigned int detect_status;\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DET_INT2_MASK,\r\nCS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK |\r\nCS42L42_M_SHORT_RLS_MASK |\r\nCS42L42_M_SHORT_DET_MASK,\r\n(1 << CS42L42_M_DETECT_TF_SHIFT) |\r\n(1 << CS42L42_M_DETECT_FT_SHIFT) |\r\n(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\r\n(1 << CS42L42_M_SHORT_RLS_SHIFT) |\r\n(1 << CS42L42_M_SHORT_DET_SHIFT));\r\nusleep_range(cs42l42->btn_det_event_dbnce * 1000,\r\ncs42l42->btn_det_event_dbnce * 2000);\r\nbias_level = 1;\r\ndo {\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MIC_DET_CTL1,\r\nCS42L42_LATCH_TO_VP_MASK |\r\nCS42L42_EVENT_STAT_SEL_MASK |\r\nCS42L42_HS_DET_LEVEL_MASK,\r\n(1 << CS42L42_LATCH_TO_VP_SHIFT) |\r\n(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\r\n(cs42l42->bias_thresholds[bias_level] <<\r\nCS42L42_HS_DET_LEVEL_SHIFT));\r\nregmap_read(cs42l42->regmap, CS42L42_DET_STATUS2,\r\n&detect_status);\r\n} while ((detect_status & CS42L42_HS_TRUE_MASK) &&\r\n(++bias_level < CS42L42_NUM_BIASES));\r\nswitch (bias_level) {\r\ncase 1:\r\ndev_dbg(cs42l42->codec->dev, "Function C button press\n");\r\nbreak;\r\ncase 2:\r\ndev_dbg(cs42l42->codec->dev, "Function B button press\n");\r\nbreak;\r\ncase 3:\r\ndev_dbg(cs42l42->codec->dev, "Function D button press\n");\r\nbreak;\r\ncase 4:\r\ndev_dbg(cs42l42->codec->dev, "Function A button press\n");\r\nbreak;\r\n}\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_MIC_DET_CTL1,\r\nCS42L42_LATCH_TO_VP_MASK |\r\nCS42L42_EVENT_STAT_SEL_MASK |\r\nCS42L42_HS_DET_LEVEL_MASK,\r\n(1 << CS42L42_LATCH_TO_VP_SHIFT) |\r\n(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\r\n(cs42l42->bias_thresholds[0] << CS42L42_HS_DET_LEVEL_SHIFT));\r\nregmap_read(cs42l42->regmap, CS42L42_DET_INT_STATUS2,\r\n&detect_status);\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_DET_INT2_MASK,\r\nCS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK |\r\nCS42L42_M_SHORT_RLS_MASK |\r\nCS42L42_M_SHORT_DET_MASK,\r\n(0 << CS42L42_M_DETECT_TF_SHIFT) |\r\n(0 << CS42L42_M_DETECT_FT_SHIFT) |\r\n(0 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\r\n(1 << CS42L42_M_SHORT_RLS_SHIFT) |\r\n(1 << CS42L42_M_SHORT_DET_SHIFT));\r\n}\r\nstatic irqreturn_t cs42l42_irq_thread(int irq, void *data)\r\n{\r\nstruct cs42l42_private *cs42l42 = (struct cs42l42_private *)data;\r\nstruct snd_soc_codec *codec = cs42l42->codec;\r\nunsigned int stickies[12];\r\nunsigned int masks[12];\r\nunsigned int current_plug_status;\r\nunsigned int current_button_status;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(stickies); i++) {\r\nregmap_read(cs42l42->regmap, irq_params_table[i].status_addr,\r\n&(stickies[i]));\r\nregmap_read(cs42l42->regmap, irq_params_table[i].mask_addr,\r\n&(masks[i]));\r\nstickies[i] = stickies[i] & (~masks[i]) &\r\nirq_params_table[i].mask;\r\n}\r\ncurrent_plug_status = (stickies[11] &\r\n(CS42L42_TS_PLUG_MASK | CS42L42_TS_UNPLUG_MASK)) >>\r\nCS42L42_TS_PLUG_SHIFT;\r\ncurrent_button_status = stickies[7] &\r\n(CS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK);\r\nif ((~masks[5]) & irq_params_table[5].mask) {\r\nif (stickies[5] & CS42L42_HSDET_AUTO_DONE_MASK) {\r\ncs42l42_process_hs_type_detect(cs42l42);\r\ndev_dbg(codec->dev,\r\n"Auto detect done (%d)\n",\r\ncs42l42->hs_type);\r\n}\r\n}\r\nif ((~masks[11]) & irq_params_table[11].mask) {\r\nswitch (current_plug_status) {\r\ncase CS42L42_TS_PLUG:\r\nif (cs42l42->plug_state != CS42L42_TS_PLUG) {\r\ncs42l42->plug_state = CS42L42_TS_PLUG;\r\ncs42l42_init_hs_type_detect(cs42l42);\r\n}\r\nbreak;\r\ncase CS42L42_TS_UNPLUG:\r\nif (cs42l42->plug_state != CS42L42_TS_UNPLUG) {\r\ncs42l42->plug_state = CS42L42_TS_UNPLUG;\r\ncs42l42_cancel_hs_type_detect(cs42l42);\r\ndev_dbg(codec->dev,\r\n"Unplug event\n");\r\n}\r\nbreak;\r\ndefault:\r\nif (cs42l42->plug_state != CS42L42_TS_TRANS)\r\ncs42l42->plug_state = CS42L42_TS_TRANS;\r\n}\r\n}\r\nif ((~masks[7]) & irq_params_table[7].mask) {\r\nif (!(current_button_status &\r\nCS42L42_M_HSBIAS_HIZ_MASK)) {\r\nif (current_button_status &\r\nCS42L42_M_DETECT_TF_MASK) {\r\ndev_dbg(codec->dev,\r\n"Button released\n");\r\n} else if (current_button_status &\r\nCS42L42_M_DETECT_FT_MASK) {\r\ncs42l42_handle_button_press(cs42l42);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cs42l42_set_interrupt_masks(struct cs42l42_private *cs42l42)\r\n{\r\nregmap_update_bits(cs42l42->regmap, CS42L42_ADC_OVFL_INT_MASK,\r\nCS42L42_ADC_OVFL_MASK,\r\n(1 << CS42L42_ADC_OVFL_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_MIXER_INT_MASK,\r\nCS42L42_MIX_CHB_OVFL_MASK |\r\nCS42L42_MIX_CHA_OVFL_MASK |\r\nCS42L42_EQ_OVFL_MASK |\r\nCS42L42_EQ_BIQUAD_OVFL_MASK,\r\n(1 << CS42L42_MIX_CHB_OVFL_SHIFT) |\r\n(1 << CS42L42_MIX_CHA_OVFL_SHIFT) |\r\n(1 << CS42L42_EQ_OVFL_SHIFT) |\r\n(1 << CS42L42_EQ_BIQUAD_OVFL_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_SRC_INT_MASK,\r\nCS42L42_SRC_ILK_MASK |\r\nCS42L42_SRC_OLK_MASK |\r\nCS42L42_SRC_IUNLK_MASK |\r\nCS42L42_SRC_OUNLK_MASK,\r\n(1 << CS42L42_SRC_ILK_SHIFT) |\r\n(1 << CS42L42_SRC_OLK_SHIFT) |\r\n(1 << CS42L42_SRC_IUNLK_SHIFT) |\r\n(1 << CS42L42_SRC_OUNLK_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_ASP_RX_INT_MASK,\r\nCS42L42_ASPRX_NOLRCK_MASK |\r\nCS42L42_ASPRX_EARLY_MASK |\r\nCS42L42_ASPRX_LATE_MASK |\r\nCS42L42_ASPRX_ERROR_MASK |\r\nCS42L42_ASPRX_OVLD_MASK,\r\n(1 << CS42L42_ASPRX_NOLRCK_SHIFT) |\r\n(1 << CS42L42_ASPRX_EARLY_SHIFT) |\r\n(1 << CS42L42_ASPRX_LATE_SHIFT) |\r\n(1 << CS42L42_ASPRX_ERROR_SHIFT) |\r\n(1 << CS42L42_ASPRX_OVLD_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_ASP_TX_INT_MASK,\r\nCS42L42_ASPTX_NOLRCK_MASK |\r\nCS42L42_ASPTX_EARLY_MASK |\r\nCS42L42_ASPTX_LATE_MASK |\r\nCS42L42_ASPTX_SMERROR_MASK,\r\n(1 << CS42L42_ASPTX_NOLRCK_SHIFT) |\r\n(1 << CS42L42_ASPTX_EARLY_SHIFT) |\r\n(1 << CS42L42_ASPTX_LATE_SHIFT) |\r\n(1 << CS42L42_ASPTX_SMERROR_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_CODEC_INT_MASK,\r\nCS42L42_PDN_DONE_MASK |\r\nCS42L42_HSDET_AUTO_DONE_MASK,\r\n(1 << CS42L42_PDN_DONE_SHIFT) |\r\n(1 << CS42L42_HSDET_AUTO_DONE_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_SRCPL_INT_MASK,\r\nCS42L42_SRCPL_ADC_LK_MASK |\r\nCS42L42_SRCPL_DAC_LK_MASK |\r\nCS42L42_SRCPL_ADC_UNLK_MASK |\r\nCS42L42_SRCPL_DAC_UNLK_MASK,\r\n(1 << CS42L42_SRCPL_ADC_LK_SHIFT) |\r\n(1 << CS42L42_SRCPL_DAC_LK_SHIFT) |\r\n(1 << CS42L42_SRCPL_ADC_UNLK_SHIFT) |\r\n(1 << CS42L42_SRCPL_DAC_UNLK_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_DET_INT1_MASK,\r\nCS42L42_TIP_SENSE_UNPLUG_MASK |\r\nCS42L42_TIP_SENSE_PLUG_MASK |\r\nCS42L42_HSBIAS_SENSE_MASK,\r\n(1 << CS42L42_TIP_SENSE_UNPLUG_SHIFT) |\r\n(1 << CS42L42_TIP_SENSE_PLUG_SHIFT) |\r\n(1 << CS42L42_HSBIAS_SENSE_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_DET_INT2_MASK,\r\nCS42L42_M_DETECT_TF_MASK |\r\nCS42L42_M_DETECT_FT_MASK |\r\nCS42L42_M_HSBIAS_HIZ_MASK |\r\nCS42L42_M_SHORT_RLS_MASK |\r\nCS42L42_M_SHORT_DET_MASK,\r\n(1 << CS42L42_M_DETECT_TF_SHIFT) |\r\n(1 << CS42L42_M_DETECT_FT_SHIFT) |\r\n(1 << CS42L42_M_HSBIAS_HIZ_SHIFT) |\r\n(1 << CS42L42_M_SHORT_RLS_SHIFT) |\r\n(1 << CS42L42_M_SHORT_DET_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_VPMON_INT_MASK,\r\nCS42L42_VPMON_MASK,\r\n(1 << CS42L42_VPMON_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_PLL_LOCK_INT_MASK,\r\nCS42L42_PLL_LOCK_MASK,\r\n(1 << CS42L42_PLL_LOCK_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_TSRS_PLUG_INT_MASK,\r\nCS42L42_RS_PLUG_MASK |\r\nCS42L42_RS_UNPLUG_MASK |\r\nCS42L42_TS_PLUG_MASK |\r\nCS42L42_TS_UNPLUG_MASK,\r\n(1 << CS42L42_RS_PLUG_SHIFT) |\r\n(1 << CS42L42_RS_UNPLUG_SHIFT) |\r\n(0 << CS42L42_TS_PLUG_SHIFT) |\r\n(0 << CS42L42_TS_UNPLUG_SHIFT));\r\n}\r\nstatic void cs42l42_setup_hs_type_detect(struct cs42l42_private *cs42l42)\r\n{\r\nunsigned int reg;\r\ncs42l42->hs_type = CS42L42_PLUG_INVALID;\r\nregmap_update_bits(cs42l42->regmap, CS42L42_MIC_DET_CTL1,\r\nCS42L42_LATCH_TO_VP_MASK |\r\nCS42L42_EVENT_STAT_SEL_MASK |\r\nCS42L42_HS_DET_LEVEL_MASK,\r\n(1 << CS42L42_LATCH_TO_VP_SHIFT) |\r\n(0 << CS42L42_EVENT_STAT_SEL_SHIFT) |\r\n(cs42l42->bias_thresholds[0] <<\r\nCS42L42_HS_DET_LEVEL_SHIFT));\r\nregmap_update_bits(cs42l42->regmap,\r\nCS42L42_HS_CLAMP_DISABLE,\r\nCS42L42_HS_CLAMP_DISABLE_MASK,\r\n(1 << CS42L42_HS_CLAMP_DISABLE_SHIFT));\r\nregmap_update_bits(cs42l42->regmap, CS42L42_TIPSENSE_CTL,\r\nCS42L42_TIP_SENSE_CTRL_MASK |\r\nCS42L42_TIP_SENSE_INV_MASK |\r\nCS42L42_TIP_SENSE_DEBOUNCE_MASK,\r\n(3 << CS42L42_TIP_SENSE_CTRL_SHIFT) |\r\n(0 << CS42L42_TIP_SENSE_INV_SHIFT) |\r\n(2 << CS42L42_TIP_SENSE_DEBOUNCE_SHIFT));\r\nregmap_read(cs42l42->regmap,\r\nCS42L42_TSRS_PLUG_STATUS,\r\n&reg);\r\ncs42l42->plug_state = (((char) reg) &\r\n(CS42L42_TS_PLUG_MASK | CS42L42_TS_UNPLUG_MASK)) >>\r\nCS42L42_TS_PLUG_SHIFT;\r\n}\r\nstatic int cs42l42_handle_device_data(struct i2c_client *i2c_client,\r\nstruct cs42l42_private *cs42l42)\r\n{\r\nstruct device_node *np = i2c_client->dev.of_node;\r\nunsigned int val;\r\nunsigned int thresholds[CS42L42_NUM_BIASES];\r\nint ret;\r\nint i;\r\nret = of_property_read_u32(np, "cirrus,ts-inv", &val);\r\nif (!ret) {\r\nswitch (val) {\r\ncase CS42L42_TS_INV_EN:\r\ncase CS42L42_TS_INV_DIS:\r\ncs42l42->ts_inv = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,ts-inv DT value %d\n",\r\nval);\r\ncs42l42->ts_inv = CS42L42_TS_INV_DIS;\r\n}\r\n} else {\r\ncs42l42->ts_inv = CS42L42_TS_INV_DIS;\r\n}\r\nregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\r\nCS42L42_TS_INV_MASK,\r\n(cs42l42->ts_inv << CS42L42_TS_INV_SHIFT));\r\nret = of_property_read_u32(np, "cirrus,ts-dbnc-rise", &val);\r\nif (!ret) {\r\nswitch (val) {\r\ncase CS42L42_TS_DBNCE_0:\r\ncase CS42L42_TS_DBNCE_125:\r\ncase CS42L42_TS_DBNCE_250:\r\ncase CS42L42_TS_DBNCE_500:\r\ncase CS42L42_TS_DBNCE_750:\r\ncase CS42L42_TS_DBNCE_1000:\r\ncase CS42L42_TS_DBNCE_1250:\r\ncase CS42L42_TS_DBNCE_1500:\r\ncs42l42->ts_dbnc_rise = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,ts-dbnc-rise DT value %d\n",\r\nval);\r\ncs42l42->ts_dbnc_rise = CS42L42_TS_DBNCE_1000;\r\n}\r\n} else {\r\ncs42l42->ts_dbnc_rise = CS42L42_TS_DBNCE_1000;\r\n}\r\nregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\r\nCS42L42_TS_RISE_DBNCE_TIME_MASK,\r\n(cs42l42->ts_dbnc_rise <<\r\nCS42L42_TS_RISE_DBNCE_TIME_SHIFT));\r\nret = of_property_read_u32(np, "cirrus,ts-dbnc-fall", &val);\r\nif (!ret) {\r\nswitch (val) {\r\ncase CS42L42_TS_DBNCE_0:\r\ncase CS42L42_TS_DBNCE_125:\r\ncase CS42L42_TS_DBNCE_250:\r\ncase CS42L42_TS_DBNCE_500:\r\ncase CS42L42_TS_DBNCE_750:\r\ncase CS42L42_TS_DBNCE_1000:\r\ncase CS42L42_TS_DBNCE_1250:\r\ncase CS42L42_TS_DBNCE_1500:\r\ncs42l42->ts_dbnc_fall = val;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,ts-dbnc-fall DT value %d\n",\r\nval);\r\ncs42l42->ts_dbnc_fall = CS42L42_TS_DBNCE_0;\r\n}\r\n} else {\r\ncs42l42->ts_dbnc_fall = CS42L42_TS_DBNCE_0;\r\n}\r\nregmap_update_bits(cs42l42->regmap, CS42L42_TSENSE_CTL,\r\nCS42L42_TS_FALL_DBNCE_TIME_MASK,\r\n(cs42l42->ts_dbnc_fall <<\r\nCS42L42_TS_FALL_DBNCE_TIME_SHIFT));\r\nret = of_property_read_u32(np, "cirrus,btn-det-init-dbnce", &val);\r\nif (!ret) {\r\nif ((val >= CS42L42_BTN_DET_INIT_DBNCE_MIN) &&\r\n(val <= CS42L42_BTN_DET_INIT_DBNCE_MAX))\r\ncs42l42->btn_det_init_dbnce = val;\r\nelse {\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,btn-det-init-dbnce DT value %d\n",\r\nval);\r\ncs42l42->btn_det_init_dbnce =\r\nCS42L42_BTN_DET_INIT_DBNCE_DEFAULT;\r\n}\r\n} else {\r\ncs42l42->btn_det_init_dbnce =\r\nCS42L42_BTN_DET_INIT_DBNCE_DEFAULT;\r\n}\r\nret = of_property_read_u32(np, "cirrus,btn-det-event-dbnce", &val);\r\nif (!ret) {\r\nif ((val >= CS42L42_BTN_DET_EVENT_DBNCE_MIN) &&\r\n(val <= CS42L42_BTN_DET_EVENT_DBNCE_MAX))\r\ncs42l42->btn_det_event_dbnce = val;\r\nelse {\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,btn-det-event-dbnce DT value %d\n", val);\r\ncs42l42->btn_det_event_dbnce =\r\nCS42L42_BTN_DET_EVENT_DBNCE_DEFAULT;\r\n}\r\n} else {\r\ncs42l42->btn_det_event_dbnce =\r\nCS42L42_BTN_DET_EVENT_DBNCE_DEFAULT;\r\n}\r\nret = of_property_read_u32_array(np, "cirrus,bias-lvls",\r\n(u32 *)thresholds, CS42L42_NUM_BIASES);\r\nif (!ret) {\r\nfor (i = 0; i < CS42L42_NUM_BIASES; i++) {\r\nif ((thresholds[i] >= CS42L42_HS_DET_LEVEL_MIN) &&\r\n(thresholds[i] <= CS42L42_HS_DET_LEVEL_MAX))\r\ncs42l42->bias_thresholds[i] = thresholds[i];\r\nelse {\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,bias-lvls[%d] DT value %d\n", i,\r\nthresholds[i]);\r\ncs42l42->bias_thresholds[i] =\r\nthreshold_defaults[i];\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < CS42L42_NUM_BIASES; i++)\r\ncs42l42->bias_thresholds[i] = threshold_defaults[i];\r\n}\r\nret = of_property_read_u32(np, "cirrus,hs-bias-ramp-rate", &val);\r\nif (!ret) {\r\nswitch (val) {\r\ncase CS42L42_HSBIAS_RAMP_FAST_RISE_SLOW_FALL:\r\ncs42l42->hs_bias_ramp_rate = val;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME0;\r\nbreak;\r\ncase CS42L42_HSBIAS_RAMP_FAST:\r\ncs42l42->hs_bias_ramp_rate = val;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME1;\r\nbreak;\r\ncase CS42L42_HSBIAS_RAMP_SLOW:\r\ncs42l42->hs_bias_ramp_rate = val;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\r\nbreak;\r\ncase CS42L42_HSBIAS_RAMP_SLOWEST:\r\ncs42l42->hs_bias_ramp_rate = val;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME3;\r\nbreak;\r\ndefault:\r\ndev_err(&i2c_client->dev,\r\n"Wrong cirrus,hs-bias-ramp-rate DT value %d\n",\r\nval);\r\ncs42l42->hs_bias_ramp_rate = CS42L42_HSBIAS_RAMP_SLOW;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\r\n}\r\n} else {\r\ncs42l42->hs_bias_ramp_rate = CS42L42_HSBIAS_RAMP_SLOW;\r\ncs42l42->hs_bias_ramp_time = CS42L42_HSBIAS_RAMP_TIME2;\r\n}\r\nregmap_update_bits(cs42l42->regmap, CS42L42_HS_BIAS_CTL,\r\nCS42L42_HSBIAS_RAMP_MASK,\r\n(cs42l42->hs_bias_ramp_rate <<\r\nCS42L42_HSBIAS_RAMP_SHIFT));\r\nreturn 0;\r\n}\r\nstatic int cs42l42_i2c_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct cs42l42_private *cs42l42;\r\nint ret, i;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\ncs42l42 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs42l42_private),\r\nGFP_KERNEL);\r\nif (!cs42l42)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c_client, cs42l42);\r\ncs42l42->regmap = devm_regmap_init_i2c(i2c_client, &cs42l42_regmap);\r\nif (IS_ERR(cs42l42->regmap)) {\r\nret = PTR_ERR(cs42l42->regmap);\r\ndev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cs42l42->supplies); i++)\r\ncs42l42->supplies[i].supply = cs42l42_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c_client->dev,\r\nARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c_client->dev,\r\n"Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs42l42->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\r\n"reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(cs42l42->reset_gpio))\r\nreturn PTR_ERR(cs42l42->reset_gpio);\r\nif (cs42l42->reset_gpio) {\r\ndev_dbg(&i2c_client->dev, "Found reset GPIO\n");\r\ngpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\r\n}\r\nmdelay(3);\r\nret = devm_request_threaded_irq(&i2c_client->dev,\r\ni2c_client->irq,\r\nNULL, cs42l42_irq_thread,\r\nIRQF_ONESHOT | IRQF_TRIGGER_LOW,\r\n"cs42l42", cs42l42);\r\nif (ret != 0)\r\ndev_err(&i2c_client->dev,\r\n"Failed to request IRQ: %d\n", ret);\r\nret = regmap_read(cs42l42->regmap, CS42L42_DEVID_AB, &reg);\r\ndevid = (reg & 0xFF) << 12;\r\nret = regmap_read(cs42l42->regmap, CS42L42_DEVID_CD, &reg);\r\ndevid |= (reg & 0xFF) << 4;\r\nret = regmap_read(cs42l42->regmap, CS42L42_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS42L42_CHIP_ID) {\r\nret = -ENODEV;\r\ndev_err(&i2c_client->dev,\r\n"CS42L42 Device ID (%X). Expected %X\n",\r\ndevid, CS42L42_CHIP_ID);\r\nreturn ret;\r\n}\r\nret = regmap_read(cs42l42->regmap, CS42L42_REVID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c_client->dev, "Get Revision ID failed\n");\r\nreturn ret;\r\n}\r\ndev_info(&i2c_client->dev,\r\n"Cirrus Logic CS42L42, Revision: %02X\n", reg & 0xFF);\r\nregmap_update_bits(cs42l42->regmap, CS42L42_PWR_CTL1,\r\nCS42L42_ASP_DAO_PDN_MASK |\r\nCS42L42_ASP_DAI_PDN_MASK |\r\nCS42L42_MIXER_PDN_MASK |\r\nCS42L42_EQ_PDN_MASK |\r\nCS42L42_HP_PDN_MASK |\r\nCS42L42_ADC_PDN_MASK |\r\nCS42L42_PDN_ALL_MASK,\r\n(1 << CS42L42_ASP_DAO_PDN_SHIFT) |\r\n(1 << CS42L42_ASP_DAI_PDN_SHIFT) |\r\n(1 << CS42L42_MIXER_PDN_SHIFT) |\r\n(1 << CS42L42_EQ_PDN_SHIFT) |\r\n(1 << CS42L42_HP_PDN_SHIFT) |\r\n(1 << CS42L42_ADC_PDN_SHIFT) |\r\n(0 << CS42L42_PDN_ALL_SHIFT));\r\nif (i2c_client->dev.of_node) {\r\nret = cs42l42_handle_device_data(i2c_client, cs42l42);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ncs42l42_setup_hs_type_detect(cs42l42);\r\ncs42l42_set_interrupt_masks(cs42l42);\r\nret = snd_soc_register_codec(&i2c_client->dev,\r\n&soc_codec_dev_cs42l42, &cs42l42_dai, 1);\r\nif (ret < 0)\r\ngoto err_disable;\r\nreturn 0;\r\nerr_disable:\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs42l42_i2c_remove(struct i2c_client *i2c_client)\r\n{\r\nstruct cs42l42_private *cs42l42 = i2c_get_clientdata(i2c_client);\r\nsnd_soc_unregister_codec(&i2c_client->dev);\r\nif (cs42l42->reset_gpio)\r\ngpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int cs42l42_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\r\nregcache_cache_only(cs42l42->regmap, true);\r\nregcache_mark_dirty(cs42l42->regmap);\r\nif (cs42l42->reset_gpio)\r\ngpiod_set_value_cansleep(cs42l42->reset_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs42l42_runtime_resume(struct device *dev)\r\n{\r\nstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs42l42->supplies),\r\ncs42l42->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (cs42l42->reset_gpio)\r\ngpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\r\nregcache_cache_only(cs42l42->regmap, false);\r\nregcache_sync(cs42l42->regmap);\r\nreturn 0;\r\n}
