static void hns_roce_ib_cq_comp(struct hns_roce_cq *hr_cq)\r\n{\r\nstruct ib_cq *ibcq = &hr_cq->ib_cq;\r\nibcq->comp_handler(ibcq, ibcq->cq_context);\r\n}\r\nstatic void hns_roce_ib_cq_event(struct hns_roce_cq *hr_cq,\r\nenum hns_roce_event event_type)\r\n{\r\nstruct hns_roce_dev *hr_dev;\r\nstruct ib_event event;\r\nstruct ib_cq *ibcq;\r\nibcq = &hr_cq->ib_cq;\r\nhr_dev = to_hr_dev(ibcq->device);\r\nif (event_type != HNS_ROCE_EVENT_TYPE_CQ_ID_INVALID &&\r\nevent_type != HNS_ROCE_EVENT_TYPE_CQ_ACCESS_ERROR &&\r\nevent_type != HNS_ROCE_EVENT_TYPE_CQ_OVERFLOW) {\r\ndev_err(&hr_dev->pdev->dev,\r\n"hns_roce_ib: Unexpected event type 0x%x on CQ %06lx\n",\r\nevent_type, hr_cq->cqn);\r\nreturn;\r\n}\r\nif (ibcq->event_handler) {\r\nevent.device = ibcq->device;\r\nevent.event = IB_EVENT_CQ_ERR;\r\nevent.element.cq = ibcq;\r\nibcq->event_handler(&event, ibcq->cq_context);\r\n}\r\n}\r\nstatic int hns_roce_sw2hw_cq(struct hns_roce_dev *dev,\r\nstruct hns_roce_cmd_mailbox *mailbox,\r\nunsigned long cq_num)\r\n{\r\nreturn hns_roce_cmd_mbox(dev, mailbox->dma, 0, cq_num, 0,\r\nHNS_ROCE_CMD_SW2HW_CQ, HNS_ROCE_CMD_TIMEOUT_MSECS);\r\n}\r\nstatic int hns_roce_cq_alloc(struct hns_roce_dev *hr_dev, int nent,\r\nstruct hns_roce_mtt *hr_mtt,\r\nstruct hns_roce_uar *hr_uar,\r\nstruct hns_roce_cq *hr_cq, int vector)\r\n{\r\nstruct hns_roce_cmd_mailbox *mailbox = NULL;\r\nstruct hns_roce_cq_table *cq_table = NULL;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\ndma_addr_t dma_handle;\r\nu64 *mtts = NULL;\r\nint ret = 0;\r\ncq_table = &hr_dev->cq_table;\r\nmtts = hns_roce_table_find(&hr_dev->mr_table.mtt_table,\r\nhr_mtt->first_seg, &dma_handle);\r\nif (!mtts) {\r\ndev_err(dev, "CQ alloc.Failed to find cq buf addr.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vector >= hr_dev->caps.num_comp_vectors) {\r\ndev_err(dev, "CQ alloc.Invalid vector.\n");\r\nreturn -EINVAL;\r\n}\r\nhr_cq->vector = vector;\r\nret = hns_roce_bitmap_alloc(&cq_table->bitmap, &hr_cq->cqn);\r\nif (ret == -1) {\r\ndev_err(dev, "CQ alloc.Failed to alloc index.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = hns_roce_table_get(hr_dev, &cq_table->table, hr_cq->cqn);\r\nif (ret) {\r\ndev_err(dev, "CQ alloc.Failed to get context mem.\n");\r\ngoto err_out;\r\n}\r\nspin_lock_irq(&cq_table->lock);\r\nret = radix_tree_insert(&cq_table->tree, hr_cq->cqn, hr_cq);\r\nspin_unlock_irq(&cq_table->lock);\r\nif (ret) {\r\ndev_err(dev, "CQ alloc.Failed to radix_tree_insert.\n");\r\ngoto err_put;\r\n}\r\nmailbox = hns_roce_alloc_cmd_mailbox(hr_dev);\r\nif (IS_ERR(mailbox)) {\r\nret = PTR_ERR(mailbox);\r\ngoto err_radix;\r\n}\r\nhr_dev->hw->write_cqc(hr_dev, hr_cq, mailbox->buf, mtts, dma_handle,\r\nnent, vector);\r\nret = hns_roce_sw2hw_cq(hr_dev, mailbox, hr_cq->cqn);\r\nhns_roce_free_cmd_mailbox(hr_dev, mailbox);\r\nif (ret) {\r\ndev_err(dev, "CQ alloc.Failed to cmd mailbox.\n");\r\ngoto err_radix;\r\n}\r\nhr_cq->cons_index = 0;\r\nhr_cq->uar = hr_uar;\r\natomic_set(&hr_cq->refcount, 1);\r\ninit_completion(&hr_cq->free);\r\nreturn 0;\r\nerr_radix:\r\nspin_lock_irq(&cq_table->lock);\r\nradix_tree_delete(&cq_table->tree, hr_cq->cqn);\r\nspin_unlock_irq(&cq_table->lock);\r\nerr_put:\r\nhns_roce_table_put(hr_dev, &cq_table->table, hr_cq->cqn);\r\nerr_out:\r\nhns_roce_bitmap_free(&cq_table->bitmap, hr_cq->cqn, BITMAP_NO_RR);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_hw2sw_cq(struct hns_roce_dev *dev,\r\nstruct hns_roce_cmd_mailbox *mailbox,\r\nunsigned long cq_num)\r\n{\r\nreturn hns_roce_cmd_mbox(dev, 0, mailbox ? mailbox->dma : 0, cq_num,\r\nmailbox ? 0 : 1, HNS_ROCE_CMD_HW2SW_CQ,\r\nHNS_ROCE_CMD_TIMEOUT_MSECS);\r\n}\r\nvoid hns_roce_free_cq(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq)\r\n{\r\nstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nint ret;\r\nret = hns_roce_hw2sw_cq(hr_dev, NULL, hr_cq->cqn);\r\nif (ret)\r\ndev_err(dev, "HW2SW_CQ failed (%d) for CQN %06lx\n", ret,\r\nhr_cq->cqn);\r\nsynchronize_irq(hr_dev->eq_table.eq[hr_cq->vector].irq);\r\nif (atomic_dec_and_test(&hr_cq->refcount))\r\ncomplete(&hr_cq->free);\r\nwait_for_completion(&hr_cq->free);\r\nspin_lock_irq(&cq_table->lock);\r\nradix_tree_delete(&cq_table->tree, hr_cq->cqn);\r\nspin_unlock_irq(&cq_table->lock);\r\nhns_roce_table_put(hr_dev, &cq_table->table, hr_cq->cqn);\r\nhns_roce_bitmap_free(&cq_table->bitmap, hr_cq->cqn, BITMAP_NO_RR);\r\n}\r\nstatic int hns_roce_ib_get_cq_umem(struct hns_roce_dev *hr_dev,\r\nstruct ib_ucontext *context,\r\nstruct hns_roce_cq_buf *buf,\r\nstruct ib_umem **umem, u64 buf_addr, int cqe)\r\n{\r\nint ret;\r\n*umem = ib_umem_get(context, buf_addr, cqe * hr_dev->caps.cq_entry_sz,\r\nIB_ACCESS_LOCAL_WRITE, 1);\r\nif (IS_ERR(*umem))\r\nreturn PTR_ERR(*umem);\r\nret = hns_roce_mtt_init(hr_dev, ib_umem_page_count(*umem),\r\nilog2((unsigned int)(*umem)->page_size),\r\n&buf->hr_mtt);\r\nif (ret)\r\ngoto err_buf;\r\nret = hns_roce_ib_umem_write_mtt(hr_dev, &buf->hr_mtt, *umem);\r\nif (ret)\r\ngoto err_mtt;\r\nreturn 0;\r\nerr_mtt:\r\nhns_roce_mtt_cleanup(hr_dev, &buf->hr_mtt);\r\nerr_buf:\r\nib_umem_release(*umem);\r\nreturn ret;\r\n}\r\nstatic int hns_roce_ib_alloc_cq_buf(struct hns_roce_dev *hr_dev,\r\nstruct hns_roce_cq_buf *buf, u32 nent)\r\n{\r\nint ret;\r\nret = hns_roce_buf_alloc(hr_dev, nent * hr_dev->caps.cq_entry_sz,\r\nPAGE_SIZE * 2, &buf->hr_buf);\r\nif (ret)\r\ngoto out;\r\nret = hns_roce_mtt_init(hr_dev, buf->hr_buf.npages,\r\nbuf->hr_buf.page_shift, &buf->hr_mtt);\r\nif (ret)\r\ngoto err_buf;\r\nret = hns_roce_buf_write_mtt(hr_dev, &buf->hr_mtt, &buf->hr_buf);\r\nif (ret)\r\ngoto err_mtt;\r\nreturn 0;\r\nerr_mtt:\r\nhns_roce_mtt_cleanup(hr_dev, &buf->hr_mtt);\r\nerr_buf:\r\nhns_roce_buf_free(hr_dev, nent * hr_dev->caps.cq_entry_sz,\r\n&buf->hr_buf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void hns_roce_ib_free_cq_buf(struct hns_roce_dev *hr_dev,\r\nstruct hns_roce_cq_buf *buf, int cqe)\r\n{\r\nhns_roce_buf_free(hr_dev, (cqe + 1) * hr_dev->caps.cq_entry_sz,\r\n&buf->hr_buf);\r\n}\r\nstruct ib_cq *hns_roce_ib_create_cq(struct ib_device *ib_dev,\r\nconst struct ib_cq_init_attr *attr,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct hns_roce_ib_create_cq ucmd;\r\nstruct hns_roce_cq *hr_cq = NULL;\r\nstruct hns_roce_uar *uar = NULL;\r\nint vector = attr->comp_vector;\r\nint cq_entries = attr->cqe;\r\nint ret = 0;\r\nif (cq_entries < 1 || cq_entries > hr_dev->caps.max_cqes) {\r\ndev_err(dev, "Creat CQ failed. entries=%d, max=%d\n",\r\ncq_entries, hr_dev->caps.max_cqes);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nhr_cq = kmalloc(sizeof(*hr_cq), GFP_KERNEL);\r\nif (!hr_cq)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (cq_entries < HNS_ROCE_MIN_CQE_NUM)\r\ncq_entries = HNS_ROCE_MIN_CQE_NUM;\r\ncq_entries = roundup_pow_of_two((unsigned int)cq_entries);\r\nhr_cq->ib_cq.cqe = cq_entries - 1;\r\nspin_lock_init(&hr_cq->lock);\r\nif (context) {\r\nif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\r\ndev_err(dev, "Failed to copy_from_udata.\n");\r\nret = -EFAULT;\r\ngoto err_cq;\r\n}\r\nret = hns_roce_ib_get_cq_umem(hr_dev, context, &hr_cq->hr_buf,\r\n&hr_cq->umem, ucmd.buf_addr,\r\ncq_entries);\r\nif (ret) {\r\ndev_err(dev, "Failed to get_cq_umem.\n");\r\ngoto err_cq;\r\n}\r\nuar = &to_hr_ucontext(context)->uar;\r\n} else {\r\nret = hns_roce_ib_alloc_cq_buf(hr_dev, &hr_cq->hr_buf,\r\ncq_entries);\r\nif (ret) {\r\ndev_err(dev, "Failed to alloc_cq_buf.\n");\r\ngoto err_cq;\r\n}\r\nuar = &hr_dev->priv_uar;\r\nhr_cq->cq_db_l = hr_dev->reg_base + ROCEE_DB_OTHERS_L_0_REG +\r\n0x1000 * uar->index;\r\n}\r\nret = hns_roce_cq_alloc(hr_dev, cq_entries, &hr_cq->hr_buf.hr_mtt, uar,\r\nhr_cq, vector);\r\nif (ret) {\r\ndev_err(dev, "Creat CQ .Failed to cq_alloc.\n");\r\ngoto err_mtt;\r\n}\r\nif (!context)\r\n*hr_cq->tptr_addr = 0;\r\nhr_cq->comp = hns_roce_ib_cq_comp;\r\nhr_cq->event = hns_roce_ib_cq_event;\r\nhr_cq->cq_depth = cq_entries;\r\nif (context) {\r\nif (ib_copy_to_udata(udata, &hr_cq->cqn, sizeof(u64))) {\r\nret = -EFAULT;\r\ngoto err_cqc;\r\n}\r\n}\r\nreturn &hr_cq->ib_cq;\r\nerr_cqc:\r\nhns_roce_free_cq(hr_dev, hr_cq);\r\nerr_mtt:\r\nhns_roce_mtt_cleanup(hr_dev, &hr_cq->hr_buf.hr_mtt);\r\nif (context)\r\nib_umem_release(hr_cq->umem);\r\nelse\r\nhns_roce_ib_free_cq_buf(hr_dev, &hr_cq->hr_buf,\r\nhr_cq->ib_cq.cqe);\r\nerr_cq:\r\nkfree(hr_cq);\r\nreturn ERR_PTR(ret);\r\n}\r\nint hns_roce_ib_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct hns_roce_dev *hr_dev = to_hr_dev(ib_cq->device);\r\nstruct hns_roce_cq *hr_cq = to_hr_cq(ib_cq);\r\nint ret = 0;\r\nif (hr_dev->hw->destroy_cq) {\r\nret = hr_dev->hw->destroy_cq(ib_cq);\r\n} else {\r\nhns_roce_free_cq(hr_dev, hr_cq);\r\nhns_roce_mtt_cleanup(hr_dev, &hr_cq->hr_buf.hr_mtt);\r\nif (ib_cq->uobject)\r\nib_umem_release(hr_cq->umem);\r\nelse\r\nhns_roce_ib_free_cq_buf(hr_dev, &hr_cq->hr_buf,\r\nib_cq->cqe);\r\nkfree(hr_cq);\r\n}\r\nreturn ret;\r\n}\r\nvoid hns_roce_cq_completion(struct hns_roce_dev *hr_dev, u32 cqn)\r\n{\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct hns_roce_cq *cq;\r\ncq = radix_tree_lookup(&hr_dev->cq_table.tree,\r\ncqn & (hr_dev->caps.num_cqs - 1));\r\nif (!cq) {\r\ndev_warn(dev, "Completion event for bogus CQ 0x%08x\n", cqn);\r\nreturn;\r\n}\r\ncq->comp(cq);\r\n}\r\nvoid hns_roce_cq_event(struct hns_roce_dev *hr_dev, u32 cqn, int event_type)\r\n{\r\nstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\r\nstruct device *dev = &hr_dev->pdev->dev;\r\nstruct hns_roce_cq *cq;\r\ncq = radix_tree_lookup(&cq_table->tree,\r\ncqn & (hr_dev->caps.num_cqs - 1));\r\nif (cq)\r\natomic_inc(&cq->refcount);\r\nif (!cq) {\r\ndev_warn(dev, "Async event for bogus CQ %08x\n", cqn);\r\nreturn;\r\n}\r\ncq->event(cq, (enum hns_roce_event)event_type);\r\nif (atomic_dec_and_test(&cq->refcount))\r\ncomplete(&cq->free);\r\n}\r\nint hns_roce_init_cq_table(struct hns_roce_dev *hr_dev)\r\n{\r\nstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\r\nspin_lock_init(&cq_table->lock);\r\nINIT_RADIX_TREE(&cq_table->tree, GFP_ATOMIC);\r\nreturn hns_roce_bitmap_init(&cq_table->bitmap, hr_dev->caps.num_cqs,\r\nhr_dev->caps.num_cqs - 1,\r\nhr_dev->caps.reserved_cqs, 0);\r\n}\r\nvoid hns_roce_cleanup_cq_table(struct hns_roce_dev *hr_dev)\r\n{\r\nhns_roce_bitmap_cleanup(&hr_dev->cq_table.bitmap);\r\n}
