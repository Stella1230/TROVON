static bool is_smaller(const struct v4l2_rect *r1, const struct v4l2_rect *r2)\r\n{\r\nreturn r1->width < r2->width || r1->height < r2->height;\r\n}\r\nstatic bool is_inside(const struct v4l2_rect *r1, const struct v4l2_rect *r2)\r\n{\r\nreturn r1->left > r2->left || r1->top > r2->top ||\r\nr1->left + r1->width < r2->left + r2->width ||\r\nr1->top + r1->height < r2->top + r2->height;\r\n}\r\nint soc_camera_client_g_rect(struct v4l2_subdev *sd, struct v4l2_rect *rect)\r\n{\r\nstruct v4l2_subdev_selection sdsel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = V4L2_SEL_TGT_CROP,\r\n};\r\nint ret;\r\nret = v4l2_subdev_call(sd, pad, get_selection, NULL, &sdsel);\r\nif (!ret) {\r\n*rect = sdsel.r;\r\nreturn ret;\r\n}\r\nsdsel.target = V4L2_SEL_TGT_CROP_DEFAULT;\r\nret = v4l2_subdev_call(sd, pad, get_selection, NULL, &sdsel);\r\nif (!ret)\r\n*rect = sdsel.r;\r\nreturn ret;\r\n}\r\nstatic void update_subrect(struct v4l2_rect *rect, struct v4l2_rect *subrect)\r\n{\r\nif (rect->width < subrect->width)\r\nsubrect->width = rect->width;\r\nif (rect->height < subrect->height)\r\nsubrect->height = rect->height;\r\nif (rect->left > subrect->left)\r\nsubrect->left = rect->left;\r\nelse if (rect->left + rect->width >\r\nsubrect->left + subrect->width)\r\nsubrect->left = rect->left + rect->width -\r\nsubrect->width;\r\nif (rect->top > subrect->top)\r\nsubrect->top = rect->top;\r\nelse if (rect->top + rect->height >\r\nsubrect->top + subrect->height)\r\nsubrect->top = rect->top + rect->height -\r\nsubrect->height;\r\n}\r\nint soc_camera_client_s_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_selection *sel, struct v4l2_selection *cam_sel,\r\nstruct v4l2_rect *target_rect, struct v4l2_rect *subrect)\r\n{\r\nstruct v4l2_subdev_selection sdsel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = sel->target,\r\n.flags = sel->flags,\r\n.r = sel->r,\r\n};\r\nstruct v4l2_subdev_selection bounds = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = V4L2_SEL_TGT_CROP_BOUNDS,\r\n};\r\nstruct v4l2_rect *rect = &sel->r, *cam_rect = &cam_sel->r;\r\nstruct device *dev = sd->v4l2_dev->dev;\r\nint ret;\r\nunsigned int width, height;\r\nv4l2_subdev_call(sd, pad, set_selection, NULL, &sdsel);\r\nsel->r = sdsel.r;\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!memcmp(rect, cam_rect, sizeof(*rect))) {\r\ndev_dbg(dev, "Camera S_SELECTION successful for %dx%d@%d:%d\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\n*target_rect = *cam_rect;\r\nreturn 0;\r\n}\r\ndev_geo(dev, "Fix camera S_SELECTION for %dx%d@%d:%d to %dx%d@%d:%d\n",\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top,\r\nrect->width, rect->height, rect->left, rect->top);\r\nret = v4l2_subdev_call(sd, pad, get_selection, NULL, &bounds);\r\nif (ret < 0)\r\nreturn ret;\r\nsoc_camera_limit_side(&rect->left, &rect->width, sdsel.r.left, 2,\r\nbounds.r.width);\r\nsoc_camera_limit_side(&rect->top, &rect->height, sdsel.r.top, 4,\r\nbounds.r.height);\r\nwidth = max_t(unsigned int, cam_rect->width, 2);\r\nheight = max_t(unsigned int, cam_rect->height, 2);\r\nwhile (!ret && (is_smaller(cam_rect, rect) ||\r\nis_inside(cam_rect, rect)) &&\r\n(bounds.r.width > width || bounds.r.height > height)) {\r\nwidth *= 2;\r\nheight *= 2;\r\ncam_rect->width = width;\r\ncam_rect->height = height;\r\nif (cam_rect->left > rect->left)\r\ncam_rect->left = bounds.r.left;\r\nif (cam_rect->left + cam_rect->width < rect->left + rect->width)\r\ncam_rect->width = rect->left + rect->width -\r\ncam_rect->left;\r\nif (cam_rect->top > rect->top)\r\ncam_rect->top = bounds.r.top;\r\nif (cam_rect->top + cam_rect->height < rect->top + rect->height)\r\ncam_rect->height = rect->top + rect->height -\r\ncam_rect->top;\r\nsdsel.r = *cam_rect;\r\nv4l2_subdev_call(sd, pad, set_selection, NULL, &sdsel);\r\n*cam_rect = sdsel.r;\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_SELECTION %d for %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (is_smaller(cam_rect, rect) || is_inside(cam_rect, rect)) {\r\nsdsel.r = bounds.r;\r\nv4l2_subdev_call(sd, pad, set_selection, NULL, &sdsel);\r\n*cam_rect = sdsel.r;\r\nret = soc_camera_client_g_rect(sd, cam_rect);\r\ndev_geo(dev, "Camera S_SELECTION %d for max %dx%d@%d:%d\n", ret,\r\ncam_rect->width, cam_rect->height,\r\ncam_rect->left, cam_rect->top);\r\n}\r\nif (!ret) {\r\n*target_rect = *cam_rect;\r\nupdate_subrect(target_rect, subrect);\r\n}\r\nreturn ret;\r\n}\r\nstatic int client_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nunsigned int max_width, unsigned int max_height,\r\nstruct v4l2_subdev_format *format, bool host_can_scale)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nunsigned int width = mf->width, height = mf->height, tmp_w, tmp_h;\r\nstruct v4l2_subdev_selection sdsel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = V4L2_SEL_TGT_CROP_BOUNDS,\r\n};\r\nbool host_1to1;\r\nint ret;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), pad,\r\nset_fmt, NULL, format);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "camera scaled to %ux%u\n", mf->width, mf->height);\r\nif (width == mf->width && height == mf->height) {\r\nhost_1to1 = true;\r\ngoto update_cache;\r\n}\r\nhost_1to1 = false;\r\nif (!host_can_scale)\r\ngoto update_cache;\r\nret = v4l2_subdev_call(sd, pad, get_selection, NULL, &sdsel);\r\nif (ret < 0)\r\nreturn ret;\r\nif (max_width > sdsel.r.width)\r\nmax_width = sdsel.r.width;\r\nif (max_height > sdsel.r.height)\r\nmax_height = sdsel.r.height;\r\ntmp_w = mf->width;\r\ntmp_h = mf->height;\r\nwhile ((width > tmp_w || height > tmp_h) &&\r\ntmp_w < max_width && tmp_h < max_height) {\r\ntmp_w = min(2 * tmp_w, max_width);\r\ntmp_h = min(2 * tmp_h, max_height);\r\nmf->width = tmp_w;\r\nmf->height = tmp_h;\r\nret = v4l2_device_call_until_err(sd->v4l2_dev,\r\nsoc_camera_grp_id(icd), pad,\r\nset_fmt, NULL, format);\r\ndev_geo(dev, "Camera scaled to %ux%u\n",\r\nmf->width, mf->height);\r\nif (ret < 0) {\r\ndev_err(dev, "Client failed to set format: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nupdate_cache:\r\nret = soc_camera_client_g_rect(sd, rect);\r\nif (ret < 0)\r\nreturn ret;\r\nif (host_1to1)\r\n*subrect = *rect;\r\nelse\r\nupdate_subrect(rect, subrect);\r\nreturn 0;\r\n}\r\nint soc_camera_client_scale(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nstruct v4l2_mbus_framefmt *mf,\r\nunsigned int *width, unsigned int *height,\r\nbool host_can_scale, unsigned int shift)\r\n{\r\nstruct device *dev = icd->parent;\r\nstruct v4l2_subdev_format fmt_tmp = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.format = *mf,\r\n};\r\nstruct v4l2_mbus_framefmt *mf_tmp = &fmt_tmp.format;\r\nunsigned int scale_h, scale_v;\r\nint ret;\r\nret = client_set_fmt(icd, rect, subrect, *width, *height,\r\n&fmt_tmp, host_can_scale);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_geo(dev, "5: camera scaled to %ux%u\n",\r\nmf_tmp->width, mf_tmp->height);\r\nscale_h = soc_camera_calc_scale(rect->width, shift, mf_tmp->width);\r\nscale_v = soc_camera_calc_scale(rect->height, shift, mf_tmp->height);\r\nmf->width = mf_tmp->width;\r\nmf->height = mf_tmp->height;\r\nmf->colorspace = mf_tmp->colorspace;\r\n*width = soc_camera_shift_scale(subrect->width, shift, scale_h);\r\n*height = soc_camera_shift_scale(subrect->height, shift, scale_v);\r\ndev_geo(dev, "8: new client sub-window %ux%u\n", *width, *height);\r\nreturn 0;\r\n}\r\nvoid soc_camera_calc_client_output(struct soc_camera_device *icd,\r\nstruct v4l2_rect *rect, struct v4l2_rect *subrect,\r\nconst struct v4l2_pix_format *pix, struct v4l2_mbus_framefmt *mf,\r\nunsigned int shift)\r\n{\r\nstruct device *dev = icd->parent;\r\nunsigned int scale_v, scale_h;\r\nif (subrect->width == rect->width &&\r\nsubrect->height == rect->height) {\r\nmf->width = pix->width;\r\nmf->height = pix->height;\r\nreturn;\r\n}\r\ndev_geo(dev, "2: subwin %ux%u@%u:%u\n",\r\nsubrect->width, subrect->height,\r\nsubrect->left, subrect->top);\r\nscale_h = soc_camera_calc_scale(subrect->width, shift, pix->width);\r\nscale_v = soc_camera_calc_scale(subrect->height, shift, pix->height);\r\ndev_geo(dev, "3: scales %u:%u\n", scale_h, scale_v);\r\nmf->width = soc_camera_shift_scale(rect->width, shift, scale_h);\r\nmf->height = soc_camera_shift_scale(rect->height, shift, scale_v);\r\n}
