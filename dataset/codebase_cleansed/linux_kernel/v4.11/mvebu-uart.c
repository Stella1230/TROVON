static unsigned int mvebu_uart_tx_empty(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nunsigned int st;\r\nspin_lock_irqsave(&port->lock, flags);\r\nst = readl(port->membase + UART_STAT);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn (st & STAT_TX_FIFO_EMP) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int mvebu_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void mvebu_uart_set_mctrl(struct uart_port *port,\r\nunsigned int mctrl)\r\n{\r\n}\r\nstatic void mvebu_uart_stop_tx(struct uart_port *port)\r\n{\r\nunsigned int ctl = readl(port->membase + UART_CTRL);\r\nctl &= ~CTRL_TX_RDY_INT;\r\nwritel(ctl, port->membase + UART_CTRL);\r\n}\r\nstatic void mvebu_uart_start_tx(struct uart_port *port)\r\n{\r\nunsigned int ctl = readl(port->membase + UART_CTRL);\r\nctl |= CTRL_TX_RDY_INT;\r\nwritel(ctl, port->membase + UART_CTRL);\r\n}\r\nstatic void mvebu_uart_stop_rx(struct uart_port *port)\r\n{\r\nunsigned int ctl = readl(port->membase + UART_CTRL);\r\nctl &= ~CTRL_RX_INT;\r\nwritel(ctl, port->membase + UART_CTRL);\r\n}\r\nstatic void mvebu_uart_break_ctl(struct uart_port *port, int brk)\r\n{\r\nunsigned int ctl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nctl = readl(port->membase + UART_CTRL);\r\nif (brk == -1)\r\nctl |= CTRL_SND_BRK_SEQ;\r\nelse\r\nctl &= ~CTRL_SND_BRK_SEQ;\r\nwritel(ctl, port->membase + UART_CTRL);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void mvebu_uart_rx_chars(struct uart_port *port, unsigned int status)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned char ch = 0;\r\nchar flag = 0;\r\ndo {\r\nif (status & STAT_RX_RDY) {\r\nch = readl(port->membase + UART_RBR);\r\nch &= 0xff;\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (status & STAT_PAR_ERR)\r\nport->icount.parity++;\r\n}\r\nif (status & STAT_BRK_DET) {\r\nport->icount.brk++;\r\nstatus &= ~(STAT_FRM_ERR | STAT_PAR_ERR);\r\nif (uart_handle_break(port))\r\ngoto ignore_char;\r\n}\r\nif (status & STAT_OVR_ERR)\r\nport->icount.overrun++;\r\nif (status & STAT_FRM_ERR)\r\nport->icount.frame++;\r\nif (uart_handle_sysrq_char(port, ch))\r\ngoto ignore_char;\r\nif (status & port->ignore_status_mask & STAT_PAR_ERR)\r\nstatus &= ~STAT_RX_RDY;\r\nstatus &= port->read_status_mask;\r\nif (status & STAT_PAR_ERR)\r\nflag = TTY_PARITY;\r\nstatus &= ~port->ignore_status_mask;\r\nif (status & STAT_RX_RDY)\r\ntty_insert_flip_char(tport, ch, flag);\r\nif (status & STAT_BRK_DET)\r\ntty_insert_flip_char(tport, 0, TTY_BREAK);\r\nif (status & STAT_FRM_ERR)\r\ntty_insert_flip_char(tport, 0, TTY_FRAME);\r\nif (status & STAT_OVR_ERR)\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nignore_char:\r\nstatus = readl(port->membase + UART_STAT);\r\n} while (status & (STAT_RX_RDY | STAT_BRK_DET));\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic void mvebu_uart_tx_chars(struct uart_port *port, unsigned int status)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int count;\r\nunsigned int st;\r\nif (port->x_char) {\r\nwritel(port->x_char, port->membase + UART_TSH);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nmvebu_uart_stop_tx(port);\r\nreturn;\r\n}\r\nfor (count = 0; count < port->fifosize; count++) {\r\nwritel(xmit->buf[xmit->tail], port->membase + UART_TSH);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nst = readl(port->membase + UART_STAT);\r\nif (st & STAT_TX_FIFO_FUL)\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nmvebu_uart_stop_tx(port);\r\n}\r\nstatic irqreturn_t mvebu_uart_isr(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = (struct uart_port *)dev_id;\r\nunsigned int st = readl(port->membase + UART_STAT);\r\nif (st & (STAT_RX_RDY | STAT_OVR_ERR | STAT_FRM_ERR | STAT_BRK_DET))\r\nmvebu_uart_rx_chars(port, st);\r\nif (st & STAT_TX_RDY)\r\nmvebu_uart_tx_chars(port, st);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mvebu_uart_startup(struct uart_port *port)\r\n{\r\nint ret;\r\nwritel(CTRL_TXFIFO_RST | CTRL_RXFIFO_RST,\r\nport->membase + UART_CTRL);\r\nudelay(1);\r\nwritel(CTRL_RX_INT, port->membase + UART_CTRL);\r\nret = request_irq(port->irq, mvebu_uart_isr, port->irqflags, "serial",\r\nport);\r\nif (ret) {\r\ndev_err(port->dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvebu_uart_shutdown(struct uart_port *port)\r\n{\r\nwritel(0, port->membase + UART_CTRL);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void mvebu_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = STAT_RX_RDY | STAT_OVR_ERR |\r\nSTAT_TX_RDY | STAT_TX_FIFO_FUL;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= STAT_FRM_ERR | STAT_PAR_ERR;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nSTAT_FRM_ERR | STAT_PAR_ERR | STAT_OVR_ERR;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= STAT_RX_RDY | STAT_BRK_ERR;\r\nif (old)\r\ntty_termios_copy_hw(termios, old);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, 460800);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *mvebu_uart_type(struct uart_port *port)\r\n{\r\nreturn MVEBU_UART_TYPE;\r\n}\r\nstatic void mvebu_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int mvebu_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mvebu_uart_get_poll_char(struct uart_port *port)\r\n{\r\nunsigned int st = readl(port->membase + UART_STAT);\r\nif (!(st & STAT_RX_RDY))\r\nreturn NO_POLL_CHAR;\r\nreturn readl(port->membase + UART_RBR);\r\n}\r\nstatic void mvebu_uart_put_poll_char(struct uart_port *port, unsigned char c)\r\n{\r\nunsigned int st;\r\nfor (;;) {\r\nst = readl(port->membase + UART_STAT);\r\nif (!(st & STAT_TX_FIFO_FUL))\r\nbreak;\r\nudelay(1);\r\n}\r\nwritel(c, port->membase + UART_TSH);\r\n}\r\nstatic void mvebu_uart_putc(struct uart_port *port, int c)\r\n{\r\nunsigned int st;\r\nfor (;;) {\r\nst = readl(port->membase + UART_STAT);\r\nif (!(st & STAT_TX_FIFO_FUL))\r\nbreak;\r\n}\r\nwritel(c, port->membase + UART_TSH);\r\nfor (;;) {\r\nst = readl(port->membase + UART_STAT);\r\nif (st & STAT_TX_FIFO_EMP)\r\nbreak;\r\n}\r\n}\r\nstatic void mvebu_uart_putc_early_write(struct console *con,\r\nconst char *s,\r\nunsigned n)\r\n{\r\nstruct earlycon_device *dev = con->data;\r\nuart_console_write(&dev->port, s, n, mvebu_uart_putc);\r\n}\r\nstatic int __init\r\nmvebu_uart_early_console_setup(struct earlycon_device *device,\r\nconst char *opt)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->con->write = mvebu_uart_putc_early_write;\r\nreturn 0;\r\n}\r\nstatic void wait_for_xmitr(struct uart_port *port)\r\n{\r\nu32 val;\r\nreadl_poll_timeout_atomic(port->membase + UART_STAT, val,\r\n(val & STAT_TX_EMP), 1, 10000);\r\n}\r\nstatic void mvebu_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwait_for_xmitr(port);\r\nwritel(ch, port->membase + UART_TSH);\r\n}\r\nstatic void mvebu_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port = &mvebu_uart_ports[co->index];\r\nunsigned long flags;\r\nunsigned int ier;\r\nint locked = 1;\r\nif (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nier = readl(port->membase + UART_CTRL) &\r\n(CTRL_RX_INT | CTRL_TX_RDY_INT);\r\nwritel(0, port->membase + UART_CTRL);\r\nuart_console_write(port, s, count, mvebu_uart_console_putchar);\r\nwait_for_xmitr(port);\r\nif (ier)\r\nwritel(ier, port->membase + UART_CTRL);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int mvebu_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index < 0 || co->index >= MVEBU_NR_UARTS)\r\nreturn -EINVAL;\r\nport = &mvebu_uart_ports[co->index];\r\nif (!port->mapbase || !port->membase) {\r\npr_debug("console on ttyMV%i not present\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init mvebu_uart_console_init(void)\r\n{\r\nregister_console(&mvebu_uart_console);\r\nreturn 0;\r\n}\r\nstatic int mvebu_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *reg = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nstruct uart_port *port;\r\nstruct mvebu_uart_data *data;\r\nint ret;\r\nif (!reg || !irq) {\r\ndev_err(&pdev->dev, "no registers/irq defined\n");\r\nreturn -EINVAL;\r\n}\r\nport = &mvebu_uart_ports[0];\r\nspin_lock_init(&port->lock);\r\nport->dev = &pdev->dev;\r\nport->type = PORT_MVEBU;\r\nport->ops = &mvebu_uart_ops;\r\nport->regshift = 0;\r\nport->fifosize = 32;\r\nport->iotype = UPIO_MEM32;\r\nport->flags = UPF_FIXED_PORT;\r\nport->line = 0;\r\nport->irq = irq->start;\r\nport->irqflags = 0;\r\nport->mapbase = reg->start;\r\nport->membase = devm_ioremap_resource(&pdev->dev, reg);\r\nif (IS_ERR(port->membase))\r\nreturn -PTR_ERR(port->membase);\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_uart_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->port = port;\r\nport->private_data = data;\r\nplatform_set_drvdata(pdev, data);\r\nret = uart_add_one_port(&mvebu_uart_driver, port);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int __init mvebu_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&mvebu_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&mvebu_uart_platform_driver);\r\nif (ret)\r\nuart_unregister_driver(&mvebu_uart_driver);\r\nreturn ret;\r\n}
