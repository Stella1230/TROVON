static inline unsigned int norm_maxw(struct em28xx *dev)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (dev->board.is_webcam)\r\nreturn v4l2->sensor_xres;\r\nif (dev->board.max_range_640_480)\r\nreturn 640;\r\nreturn 720;\r\n}\r\nstatic inline unsigned int norm_maxh(struct em28xx *dev)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (dev->board.is_webcam)\r\nreturn v4l2->sensor_yres;\r\nif (dev->board.max_range_640_480)\r\nreturn 480;\r\nreturn (v4l2->norm & V4L2_STD_625_50) ? 576 : 480;\r\n}\r\nstatic int em28xx_vbi_supported(struct em28xx *dev)\r\n{\r\nif (disable_vbi == 1)\r\nreturn 0;\r\nif (dev->board.is_webcam)\r\nreturn 0;\r\nif (dev->chip_id == CHIP_ID_EM2860 ||\r\ndev->chip_id == CHIP_ID_EM2883)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void em28xx_wake_i2c(struct em28xx *dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2->v4l2_dev;\r\nv4l2_device_call_all(v4l2_dev, 0, core, reset, 0);\r\nv4l2_device_call_all(v4l2_dev, 0, video, s_routing,\r\nINPUT(dev->ctl_input)->vmux, 0, 0);\r\n}\r\nstatic int em28xx_colorlevels_set_default(struct em28xx *dev)\r\n{\r\nem28xx_write_reg(dev, EM28XX_R20_YGAIN, CONTRAST_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R21_YOFFSET, BRIGHTNESS_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R22_UVGAIN, SATURATION_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R23_UOFFSET, BLUE_BALANCE_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R24_VOFFSET, RED_BALANCE_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R25_SHARPNESS, SHARPNESS_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R14_GAMMA, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R15_RGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R16_GGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R17_BGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R18_ROFFSET, 0x00);\r\nem28xx_write_reg(dev, EM28XX_R19_GOFFSET, 0x00);\r\nreturn em28xx_write_reg(dev, EM28XX_R1A_BOFFSET, 0x00);\r\n}\r\nstatic int em28xx_set_outfmt(struct em28xx *dev)\r\n{\r\nint ret;\r\nu8 fmt, vinctrl;\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nfmt = v4l2->format->reg;\r\nif (!dev->is_em25xx)\r\nfmt |= 0x20;\r\nret = em28xx_write_reg(dev, EM28XX_R27_OUTFMT, fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_reg(dev, EM28XX_R10_VINMODE, v4l2->vinmode);\r\nif (ret < 0)\r\nreturn ret;\r\nvinctrl = v4l2->vinctl;\r\nif (em28xx_vbi_supported(dev) == 1) {\r\nvinctrl |= EM28XX_VINCTRL_VBI_RAW;\r\nem28xx_write_reg(dev, EM28XX_R34_VBI_START_H, 0x00);\r\nem28xx_write_reg(dev, EM28XX_R36_VBI_WIDTH, v4l2->vbi_width/4);\r\nem28xx_write_reg(dev, EM28XX_R37_VBI_HEIGHT, v4l2->vbi_height);\r\nif (v4l2->norm & V4L2_STD_525_60) {\r\nem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x09);\r\n} else if (v4l2->norm & V4L2_STD_625_50) {\r\nem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x07);\r\n}\r\n}\r\nreturn em28xx_write_reg(dev, EM28XX_R11_VINCTRL, vinctrl);\r\n}\r\nstatic int em28xx_accumulator_set(struct em28xx *dev, u8 xmin, u8 xmax,\r\nu8 ymin, u8 ymax)\r\n{\r\nem28xx_videodbg("em28xx Scale: (%d,%d)-(%d,%d)\n",\r\nxmin, ymin, xmax, ymax);\r\nem28xx_write_regs(dev, EM28XX_R28_XMIN, &xmin, 1);\r\nem28xx_write_regs(dev, EM28XX_R29_XMAX, &xmax, 1);\r\nem28xx_write_regs(dev, EM28XX_R2A_YMIN, &ymin, 1);\r\nreturn em28xx_write_regs(dev, EM28XX_R2B_YMAX, &ymax, 1);\r\n}\r\nstatic void em28xx_capture_area_set(struct em28xx *dev, u8 hstart, u8 vstart,\r\nu16 width, u16 height)\r\n{\r\nu8 cwidth = width >> 2;\r\nu8 cheight = height >> 2;\r\nu8 overflow = (height >> 9 & 0x02) | (width >> 10 & 0x01);\r\nem28xx_videodbg("capture area set to (%d,%d): %dx%d\n",\r\nhstart, vstart,\r\n((overflow & 2) << 9 | cwidth << 2),\r\n((overflow & 1) << 10 | cheight << 2));\r\nem28xx_write_regs(dev, EM28XX_R1C_HSTART, &hstart, 1);\r\nem28xx_write_regs(dev, EM28XX_R1D_VSTART, &vstart, 1);\r\nem28xx_write_regs(dev, EM28XX_R1E_CWIDTH, &cwidth, 1);\r\nem28xx_write_regs(dev, EM28XX_R1F_CHEIGHT, &cheight, 1);\r\nem28xx_write_regs(dev, EM28XX_R1B_OFLOW, &overflow, 1);\r\nif (dev->is_em25xx) {\r\nem28xx_write_reg(dev, 0x34, width >> 4);\r\nem28xx_write_reg(dev, 0x35, height >> 4);\r\n}\r\n}\r\nstatic int em28xx_scaler_set(struct em28xx *dev, u16 h, u16 v)\r\n{\r\nu8 mode = 0x00;\r\nif (dev->board.is_em2800) {\r\nmode = (v ? 0x20 : 0x00) | (h ? 0x10 : 0x00);\r\n} else {\r\nu8 buf[2];\r\nbuf[0] = h;\r\nbuf[1] = h >> 8;\r\nem28xx_write_regs(dev, EM28XX_R30_HSCALELOW, (char *)buf, 2);\r\nbuf[0] = v;\r\nbuf[1] = v >> 8;\r\nem28xx_write_regs(dev, EM28XX_R32_VSCALELOW, (char *)buf, 2);\r\nmode = (h || v) ? 0x30 : 0x00;\r\n}\r\nreturn em28xx_write_reg(dev, EM28XX_R26_COMPR, mode);\r\n}\r\nstatic int em28xx_resolution_set(struct em28xx *dev)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nint width = norm_maxw(dev);\r\nint height = norm_maxh(dev);\r\nv4l2->vbi_width = 720;\r\nif (v4l2->norm & V4L2_STD_525_60)\r\nv4l2->vbi_height = 12;\r\nelse\r\nv4l2->vbi_height = 18;\r\nem28xx_set_outfmt(dev);\r\nem28xx_accumulator_set(dev, 1, (width - 4) >> 2, 1, (height - 4) >> 2);\r\nif (em28xx_vbi_supported(dev) == 1)\r\nem28xx_capture_area_set(dev, 0, 2, width, height);\r\nelse\r\nem28xx_capture_area_set(dev, 0, 0, width, height);\r\nreturn em28xx_scaler_set(dev, v4l2->hscale, v4l2->vscale);\r\n}\r\nstatic int em28xx_set_alternate(struct em28xx *dev)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint errCode;\r\nint i;\r\nunsigned int min_pkt_size = v4l2->width * 2 + 4;\r\ndev->alt = 0;\r\nif ((alt > 0) && (alt < dev->num_alt)) {\r\nem28xx_videodbg("alternate forced to %d\n", dev->alt);\r\ndev->alt = alt;\r\ngoto set_alt;\r\n}\r\nif (dev->analog_xfer_bulk)\r\ngoto set_alt;\r\nif (v4l2->width * 2 * v4l2->height > 720 * 240 * 2)\r\nmin_pkt_size *= 2;\r\nfor (i = 0; i < dev->num_alt; i++) {\r\nif (dev->alt_max_pkt_size_isoc[i] >= min_pkt_size) {\r\ndev->alt = i;\r\nbreak;\r\n} else if (dev->alt_max_pkt_size_isoc[i] >\r\ndev->alt_max_pkt_size_isoc[dev->alt])\r\ndev->alt = i;\r\n}\r\nset_alt:\r\nif (dev->analog_xfer_bulk) {\r\ndev->max_pkt_size = 512;\r\ndev->packet_multiplier = EM28XX_BULK_PACKET_MULTIPLIER;\r\n} else {\r\nem28xx_videodbg("minimum isoc packet size: %u (alt=%d)\n",\r\nmin_pkt_size, dev->alt);\r\ndev->max_pkt_size =\r\ndev->alt_max_pkt_size_isoc[dev->alt];\r\ndev->packet_multiplier = EM28XX_NUM_ISOC_PACKETS;\r\n}\r\nem28xx_videodbg("setting alternate %d with wMaxPacketSize=%u\n",\r\ndev->alt, dev->max_pkt_size);\r\nerrCode = usb_set_interface(udev, dev->ifnum, dev->alt);\r\nif (errCode < 0) {\r\ndev_err(&dev->intf->dev,\r\n"cannot change alternate number to %d (error=%i)\n",\r\ndev->alt, errCode);\r\nreturn errCode;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void finish_buffer(struct em28xx *dev,\r\nstruct em28xx_buffer *buf)\r\n{\r\nem28xx_isocdbg("[%p/%d] wakeup\n", buf, buf->top_field);\r\nbuf->vb.sequence = dev->v4l2->field_count++;\r\nif (dev->v4l2->progressive)\r\nbuf->vb.field = V4L2_FIELD_NONE;\r\nelse\r\nbuf->vb.field = V4L2_FIELD_INTERLACED;\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic void em28xx_copy_video(struct em28xx *dev,\r\nstruct em28xx_buffer *buf,\r\nunsigned char *usb_buf,\r\nunsigned long len)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nvoid *fieldstart, *startwrite, *startread;\r\nint linesdone, currlinedone, offset, lencopy, remain;\r\nint bytesperline = v4l2->width << 1;\r\nif (buf->pos + len > buf->length)\r\nlen = buf->length - buf->pos;\r\nstartread = usb_buf;\r\nremain = len;\r\nif (v4l2->progressive || buf->top_field)\r\nfieldstart = buf->vb_buf;\r\nelse\r\nfieldstart = buf->vb_buf + bytesperline;\r\nlinesdone = buf->pos / bytesperline;\r\ncurrlinedone = buf->pos % bytesperline;\r\nif (v4l2->progressive)\r\noffset = linesdone * bytesperline + currlinedone;\r\nelse\r\noffset = linesdone * bytesperline * 2 + currlinedone;\r\nstartwrite = fieldstart + offset;\r\nlencopy = bytesperline - currlinedone;\r\nlencopy = lencopy > remain ? remain : lencopy;\r\nif ((char *)startwrite + lencopy > (char *)buf->vb_buf + buf->length) {\r\nem28xx_isocdbg("Overflow of %zu bytes past buffer end (1)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)buf->vb_buf + buf->length));\r\nremain = (char *)buf->vb_buf + buf->length -\r\n(char *)startwrite;\r\nlencopy = remain;\r\n}\r\nif (lencopy <= 0)\r\nreturn;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\nwhile (remain > 0) {\r\nif (v4l2->progressive)\r\nstartwrite += lencopy;\r\nelse\r\nstartwrite += lencopy + bytesperline;\r\nstartread += lencopy;\r\nif (bytesperline > remain)\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline;\r\nif ((char *)startwrite + lencopy > (char *)buf->vb_buf +\r\nbuf->length) {\r\nem28xx_isocdbg("Overflow of %zu bytes past buffer end(2)\n",\r\n((char *)startwrite + lencopy) -\r\n((char *)buf->vb_buf + buf->length));\r\nlencopy = remain = (char *)buf->vb_buf + buf->length -\r\n(char *)startwrite;\r\n}\r\nif (lencopy <= 0)\r\nbreak;\r\nmemcpy(startwrite, startread, lencopy);\r\nremain -= lencopy;\r\n}\r\nbuf->pos += len;\r\n}\r\nstatic void em28xx_copy_vbi(struct em28xx *dev,\r\nstruct em28xx_buffer *buf,\r\nunsigned char *usb_buf,\r\nunsigned long len)\r\n{\r\nunsigned int offset;\r\nif (buf->pos + len > buf->length)\r\nlen = buf->length - buf->pos;\r\noffset = buf->pos;\r\nif (buf->top_field == 0)\r\noffset += dev->v4l2->vbi_width * dev->v4l2->vbi_height;\r\nmemcpy(buf->vb_buf + offset, usb_buf, len);\r\nbuf->pos += len;\r\n}\r\nstatic inline void print_err_status(struct em28xx *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\nem28xx_isocdbg("URB status %d [%s].\n", status, errmsg);\r\n} else {\r\nem28xx_isocdbg("URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline struct em28xx_buffer *get_next_buf(struct em28xx *dev,\r\nstruct em28xx_dmaqueue *dma_q)\r\n{\r\nstruct em28xx_buffer *buf;\r\nif (list_empty(&dma_q->active)) {\r\nem28xx_isocdbg("No active queue to serve\n");\r\nreturn NULL;\r\n}\r\nbuf = list_entry(dma_q->active.next, struct em28xx_buffer, list);\r\nlist_del(&buf->list);\r\nbuf->pos = 0;\r\nbuf->vb_buf = buf->mem;\r\nreturn buf;\r\n}\r\nstatic struct em28xx_buffer *\r\nfinish_field_prepare_next(struct em28xx *dev,\r\nstruct em28xx_buffer *buf,\r\nstruct em28xx_dmaqueue *dma_q)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (v4l2->progressive || v4l2->top_field) {\r\nif (buf != NULL)\r\nfinish_buffer(dev, buf);\r\nbuf = get_next_buf(dev, dma_q);\r\n}\r\nif (buf != NULL) {\r\nbuf->top_field = v4l2->top_field;\r\nbuf->pos = 0;\r\n}\r\nreturn buf;\r\n}\r\nstatic inline void process_frame_data_em28xx(struct em28xx *dev,\r\nunsigned char *data_pkt,\r\nunsigned int data_len)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct em28xx_buffer *buf = dev->usb_ctl.vid_buf;\r\nstruct em28xx_buffer *vbi_buf = dev->usb_ctl.vbi_buf;\r\nstruct em28xx_dmaqueue *dma_q = &dev->vidq;\r\nstruct em28xx_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nif (data_len >= 4) {\r\nif (data_pkt[0] == 0x88 && data_pkt[1] == 0x88 &&\r\ndata_pkt[2] == 0x88 && data_pkt[3] == 0x88) {\r\ndata_pkt += 4;\r\ndata_len -= 4;\r\n} else if (data_pkt[0] == 0x33 && data_pkt[1] == 0x95) {\r\nv4l2->capture_type = 0;\r\nv4l2->vbi_read = 0;\r\nem28xx_isocdbg("VBI START HEADER !!!\n");\r\nv4l2->top_field = !(data_pkt[2] & 1);\r\ndata_pkt += 4;\r\ndata_len -= 4;\r\n} else if (data_pkt[0] == 0x22 && data_pkt[1] == 0x5a) {\r\nv4l2->capture_type = 2;\r\nem28xx_isocdbg("VIDEO START HEADER !!!\n");\r\nv4l2->top_field = !(data_pkt[2] & 1);\r\ndata_pkt += 4;\r\ndata_len -= 4;\r\n}\r\n}\r\nif (v4l2->capture_type == 0) {\r\nvbi_buf = finish_field_prepare_next(dev, vbi_buf, vbi_dma_q);\r\ndev->usb_ctl.vbi_buf = vbi_buf;\r\nv4l2->capture_type = 1;\r\n}\r\nif (v4l2->capture_type == 1) {\r\nint vbi_size = v4l2->vbi_width * v4l2->vbi_height;\r\nint vbi_data_len = ((v4l2->vbi_read + data_len) > vbi_size) ?\r\n(vbi_size - v4l2->vbi_read) : data_len;\r\nif (vbi_buf != NULL)\r\nem28xx_copy_vbi(dev, vbi_buf, data_pkt, vbi_data_len);\r\nv4l2->vbi_read += vbi_data_len;\r\nif (vbi_data_len < data_len) {\r\nv4l2->capture_type = 2;\r\ndata_pkt += vbi_data_len;\r\ndata_len -= vbi_data_len;\r\n}\r\n}\r\nif (v4l2->capture_type == 2) {\r\nbuf = finish_field_prepare_next(dev, buf, dma_q);\r\ndev->usb_ctl.vid_buf = buf;\r\nv4l2->capture_type = 3;\r\n}\r\nif (v4l2->capture_type == 3 && buf != NULL && data_len > 0)\r\nem28xx_copy_video(dev, buf, data_pkt, data_len);\r\n}\r\nstatic inline void process_frame_data_em25xx(struct em28xx *dev,\r\nunsigned char *data_pkt,\r\nunsigned int data_len)\r\n{\r\nstruct em28xx_buffer *buf = dev->usb_ctl.vid_buf;\r\nstruct em28xx_dmaqueue *dmaq = &dev->vidq;\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nbool frame_end = false;\r\nif (data_len >= 2) {\r\nif ((data_pkt[0] == EM25XX_FRMDATAHDR_BYTE1) &&\r\n((data_pkt[1] & ~EM25XX_FRMDATAHDR_BYTE2_MASK) == 0x00)) {\r\nv4l2->top_field = !(data_pkt[1] &\r\nEM25XX_FRMDATAHDR_BYTE2_FRAME_ID);\r\nframe_end = data_pkt[1] &\r\nEM25XX_FRMDATAHDR_BYTE2_FRAME_END;\r\ndata_pkt += 2;\r\ndata_len -= 2;\r\n}\r\nif (dev->analog_xfer_bulk && frame_end) {\r\nbuf = finish_field_prepare_next(dev, buf, dmaq);\r\ndev->usb_ctl.vid_buf = buf;\r\n}\r\n}\r\nif (buf != NULL && data_len > 0)\r\nem28xx_copy_video(dev, buf, data_pkt, data_len);\r\nif (!dev->analog_xfer_bulk && frame_end) {\r\nbuf = finish_field_prepare_next(dev, buf, dmaq);\r\ndev->usb_ctl.vid_buf = buf;\r\n}\r\n}\r\nstatic inline int em28xx_urb_data_copy(struct em28xx *dev, struct urb *urb)\r\n{\r\nint xfer_bulk, num_packets, i;\r\nunsigned char *usb_data_pkt;\r\nunsigned int usb_data_len;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->disconnected)\r\nreturn 0;\r\nif (urb->status < 0)\r\nprint_err_status(dev, -1, urb->status);\r\nxfer_bulk = usb_pipebulk(urb->pipe);\r\nif (xfer_bulk)\r\nnum_packets = 1;\r\nelse\r\nnum_packets = urb->number_of_packets;\r\nfor (i = 0; i < num_packets; i++) {\r\nif (xfer_bulk) {\r\nusb_data_len = urb->actual_length;\r\nusb_data_pkt = urb->transfer_buffer;\r\n} else {\r\nif (urb->iso_frame_desc[i].status < 0) {\r\nprint_err_status(dev, i,\r\nurb->iso_frame_desc[i].status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\nusb_data_len = urb->iso_frame_desc[i].actual_length;\r\nif (usb_data_len > dev->max_pkt_size) {\r\nem28xx_isocdbg("packet bigger than packet size");\r\ncontinue;\r\n}\r\nusb_data_pkt = urb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset;\r\n}\r\nif (usb_data_len == 0) {\r\ncontinue;\r\n}\r\nif (dev->is_em25xx)\r\nprocess_frame_data_em25xx(dev,\r\nusb_data_pkt, usb_data_len);\r\nelse\r\nprocess_frame_data_em28xx(dev,\r\nusb_data_pkt, usb_data_len);\r\n}\r\nreturn 1;\r\n}\r\nstatic int get_ressource(enum v4l2_buf_type f_type)\r\n{\r\nswitch (f_type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn EM28XX_RESOURCE_VIDEO;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nreturn EM28XX_RESOURCE_VBI;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int res_get(struct em28xx *dev, enum v4l2_buf_type f_type)\r\n{\r\nint res_type = get_ressource(f_type);\r\nif (dev->resources & res_type) {\r\nreturn -EBUSY;\r\n}\r\ndev->resources |= res_type;\r\nem28xx_videodbg("res: get %d\n", res_type);\r\nreturn 0;\r\n}\r\nstatic void res_free(struct em28xx *dev, enum v4l2_buf_type f_type)\r\n{\r\nint res_type = get_ressource(f_type);\r\ndev->resources &= ~res_type;\r\nem28xx_videodbg("res: put %d\n", res_type);\r\n}\r\nstatic void em28xx_v4l2_media_release(struct em28xx *dev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nint i;\r\nfor (i = 0; i < MAX_EM28XX_INPUT; i++) {\r\nif (!INPUT(i)->type)\r\nreturn;\r\nmedia_device_unregister_entity(&dev->input_ent[i]);\r\n}\r\n#endif\r\n}\r\nstatic int em28xx_enable_analog_tuner(struct em28xx *dev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct media_device *mdev = dev->media_dev;\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct media_entity *source;\r\nstruct media_link *link, *found_link = NULL;\r\nint ret, active_links = 0;\r\nif (!mdev || !v4l2->decoder)\r\nreturn 0;\r\nlist_for_each_entry(link, &v4l2->decoder->links, list) {\r\nif (link->sink->entity == v4l2->decoder) {\r\nfound_link = link;\r\nif (link->flags & MEDIA_LNK_FL_ENABLED)\r\nactive_links++;\r\nbreak;\r\n}\r\n}\r\nif (active_links == 1 || !found_link)\r\nreturn 0;\r\nsource = found_link->source->entity;\r\nlist_for_each_entry(link, &source->links, list) {\r\nstruct media_entity *sink;\r\nint flags = 0;\r\nsink = link->sink->entity;\r\nif (sink == v4l2->decoder)\r\nflags = MEDIA_LNK_FL_ENABLED;\r\nret = media_entity_setup_link(link, flags);\r\nif (ret) {\r\ndev_err(&dev->intf->dev,\r\n"Couldn't change link %s->%s to %s. Error %d\n",\r\nsource->name, sink->name,\r\nflags ? "enabled" : "disabled",\r\nret);\r\nreturn ret;\r\n} else\r\nem28xx_videodbg("link %s->%s was %s\n",\r\nsource->name, sink->name,\r\nflags ? "ENABLED" : "disabled");\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void em28xx_v4l2_create_entities(struct em28xx *dev)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nint ret, i;\r\nv4l2->video_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(&v4l2->vdev.entity, 1, &v4l2->video_pad);\r\nif (ret < 0)\r\ndev_err(&dev->intf->dev,\r\n"failed to initialize video media entity!\n");\r\nif (em28xx_vbi_supported(dev)) {\r\nv4l2->vbi_pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_pads_init(&v4l2->vbi_dev.entity, 1,\r\n&v4l2->vbi_pad);\r\nif (ret < 0)\r\ndev_err(&dev->intf->dev,\r\n"failed to initialize vbi media entity!\n");\r\n}\r\nif (dev->board.is_webcam)\r\nreturn;\r\nfor (i = 0; i < MAX_EM28XX_INPUT; i++) {\r\nstruct media_entity *ent = &dev->input_ent[i];\r\nif (!INPUT(i)->type)\r\nbreak;\r\nent->name = iname[INPUT(i)->type];\r\nent->flags = MEDIA_ENT_FL_CONNECTOR;\r\ndev->input_pad[i].flags = MEDIA_PAD_FL_SOURCE;\r\nswitch (INPUT(i)->type) {\r\ncase EM28XX_VMUX_COMPOSITE:\r\nent->function = MEDIA_ENT_F_CONN_COMPOSITE;\r\nbreak;\r\ncase EM28XX_VMUX_SVIDEO:\r\nent->function = MEDIA_ENT_F_CONN_SVIDEO;\r\nbreak;\r\ndefault:\r\nif (dev->tuner_type != TUNER_ABSENT)\r\nent->function = MEDIA_ENT_F_CONN_RF;\r\nbreak;\r\n}\r\nret = media_entity_pads_init(ent, 1, &dev->input_pad[i]);\r\nif (ret < 0)\r\ndev_err(&dev->intf->dev,\r\n"failed to initialize input pad[%d]!\n", i);\r\nret = media_device_register_entity(dev->media_dev, ent);\r\nif (ret < 0)\r\ndev_err(&dev->intf->dev,\r\n"failed to register input entity %d!\n", i);\r\n}\r\n#endif\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct em28xx *dev = vb2_get_drv_priv(vq);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nunsigned long size =\r\n(v4l2->width * v4l2->height * v4l2->format->depth + 7) >> 3;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nem28xx_enable_analog_tuner(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nbuffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct em28xx *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nunsigned long size;\r\nem28xx_videodbg("%s, field=%d\n", __func__, vbuf->field);\r\nsize = (v4l2->width * v4l2->height * v4l2->format->depth + 7) >> 3;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nem28xx_videodbg("%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nint em28xx_start_analog_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct em28xx *dev = vb2_get_drv_priv(vq);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct v4l2_frequency f;\r\nstruct v4l2_fh *owner;\r\nint rc = 0;\r\nem28xx_videodbg("%s\n", __func__);\r\nrc = res_get(dev, vq->type);\r\nif (rc)\r\nreturn rc;\r\nif (v4l2->streaming_users == 0) {\r\nem28xx_set_alternate(dev);\r\nem28xx_wake_i2c(dev);\r\nv4l2->capture_type = -1;\r\nrc = em28xx_init_usb_xfer(dev, EM28XX_ANALOG_MODE,\r\ndev->analog_xfer_bulk,\r\nEM28XX_NUM_BUFS,\r\ndev->max_pkt_size,\r\ndev->packet_multiplier,\r\nem28xx_urb_data_copy);\r\nif (rc < 0)\r\nreturn rc;\r\nmemset(&f, 0, sizeof(f));\r\nf.frequency = v4l2->frequency;\r\nowner = (struct v4l2_fh *)vq->owner;\r\nif (owner && owner->vdev->vfl_type == VFL_TYPE_RADIO)\r\nf.type = V4L2_TUNER_RADIO;\r\nelse\r\nf.type = V4L2_TUNER_ANALOG_TV;\r\nv4l2_device_call_all(&v4l2->v4l2_dev,\r\n0, tuner, s_frequency, &f);\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 1);\r\n}\r\nv4l2->streaming_users++;\r\nreturn rc;\r\n}\r\nstatic void em28xx_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct em28xx *dev = vb2_get_drv_priv(vq);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct em28xx_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\nem28xx_videodbg("%s\n", __func__);\r\nres_free(dev, vq->type);\r\nif (v4l2->streaming_users-- == 1) {\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 0);\r\nem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\r\n}\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->usb_ctl.vid_buf != NULL) {\r\nvb2_buffer_done(&dev->usb_ctl.vid_buf->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\ndev->usb_ctl.vid_buf = NULL;\r\n}\r\nwhile (!list_empty(&vidq->active)) {\r\nstruct em28xx_buffer *buf;\r\nbuf = list_entry(vidq->active.next, struct em28xx_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nvoid em28xx_stop_vbi_streaming(struct vb2_queue *vq)\r\n{\r\nstruct em28xx *dev = vb2_get_drv_priv(vq);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct em28xx_dmaqueue *vbiq = &dev->vbiq;\r\nunsigned long flags = 0;\r\nem28xx_videodbg("%s\n", __func__);\r\nres_free(dev, vq->type);\r\nif (v4l2->streaming_users-- == 1) {\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_stream, 0);\r\nem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\r\n}\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (dev->usb_ctl.vbi_buf != NULL) {\r\nvb2_buffer_done(&dev->usb_ctl.vbi_buf->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\ndev->usb_ctl.vbi_buf = NULL;\r\n}\r\nwhile (!list_empty(&vbiq->active)) {\r\nstruct em28xx_buffer *buf;\r\nbuf = list_entry(vbiq->active.next, struct em28xx_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic void\r\nbuffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct em28xx *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct em28xx_buffer *buf =\r\ncontainer_of(vbuf, struct em28xx_buffer, vb);\r\nstruct em28xx_dmaqueue *vidq = &dev->vidq;\r\nunsigned long flags = 0;\r\nem28xx_videodbg("%s\n", __func__);\r\nbuf->mem = vb2_plane_vaddr(vb, 0);\r\nbuf->length = vb2_plane_size(vb, 0);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nlist_add_tail(&buf->list, &vidq->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int em28xx_vb2_setup(struct em28xx *dev)\r\n{\r\nint rc;\r\nstruct vb2_queue *q;\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nq = &v4l2->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct em28xx_buffer);\r\nq->ops = &em28xx_video_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nrc = vb2_queue_init(q);\r\nif (rc < 0)\r\nreturn rc;\r\nq = &v4l2->vb_vbiq;\r\nq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nq->io_modes = VB2_READ | VB2_MMAP | VB2_USERPTR;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct em28xx_buffer);\r\nq->ops = &em28xx_vbi_qops;\r\nq->mem_ops = &vb2_vmalloc_memops;\r\nrc = vb2_queue_init(q);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic void video_mux(struct em28xx *dev, int index)\r\n{\r\nstruct v4l2_device *v4l2_dev = &dev->v4l2->v4l2_dev;\r\ndev->ctl_input = index;\r\ndev->ctl_ainput = INPUT(index)->amux;\r\ndev->ctl_aoutput = INPUT(index)->aout;\r\nif (!dev->ctl_aoutput)\r\ndev->ctl_aoutput = EM28XX_AOUT_MASTER;\r\nv4l2_device_call_all(v4l2_dev, 0, video, s_routing,\r\nINPUT(index)->vmux, 0, 0);\r\nif (dev->board.has_msp34xx) {\r\nif (dev->i2s_speed) {\r\nv4l2_device_call_all(v4l2_dev, 0, audio,\r\ns_i2s_clock_freq, dev->i2s_speed);\r\n}\r\nv4l2_device_call_all(v4l2_dev, 0, audio, s_routing,\r\ndev->ctl_ainput,\r\nMSP_OUTPUT(MSP_SC_IN_DSP_SCART1), 0);\r\n}\r\nif (dev->board.adecoder != EM28XX_NOADECODER) {\r\nv4l2_device_call_all(v4l2_dev, 0, audio, s_routing,\r\ndev->ctl_ainput, dev->ctl_aoutput, 0);\r\n}\r\nem28xx_audio_analog_set(dev);\r\n}\r\nstatic void em28xx_ctrl_notify(struct v4l2_ctrl *ctrl, void *priv)\r\n{\r\nstruct em28xx *dev = priv;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->mute = ctrl->val;\r\nem28xx_audio_analog_set(dev);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->volume = ctrl->val;\r\nem28xx_audio_analog_set(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int em28xx_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct em28xx_v4l2 *v4l2 =\r\ncontainer_of(ctrl->handler, struct em28xx_v4l2, ctrl_handler);\r\nstruct em28xx *dev = v4l2->dev;\r\nint ret = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->mute = ctrl->val;\r\nret = em28xx_audio_analog_set(dev);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->volume = ctrl->val;\r\nret = em28xx_audio_analog_set(dev);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nret = em28xx_write_reg(dev, EM28XX_R20_YGAIN, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\nret = em28xx_write_reg(dev, EM28XX_R21_YOFFSET, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nret = em28xx_write_reg(dev, EM28XX_R22_UVGAIN, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nret = em28xx_write_reg(dev, EM28XX_R23_UOFFSET, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nret = em28xx_write_reg(dev, EM28XX_R24_VOFFSET, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nret = em28xx_write_reg(dev, EM28XX_R25_SHARPNESS, ctrl->val);\r\nbreak;\r\n}\r\nreturn (ret < 0) ? ret : 0;\r\n}\r\nstatic void size_to_scale(struct em28xx *dev,\r\nunsigned int width, unsigned int height,\r\nunsigned int *hscale, unsigned int *vscale)\r\n{\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\n*hscale = (((unsigned long)maxw) << 12) / width - 4096L;\r\nif (*hscale > EM28XX_HVSCALE_MAX)\r\n*hscale = EM28XX_HVSCALE_MAX;\r\n*vscale = (((unsigned long)maxh) << 12) / height - 4096L;\r\nif (*vscale > EM28XX_HVSCALE_MAX)\r\n*vscale = EM28XX_HVSCALE_MAX;\r\n}\r\nstatic void scale_to_size(struct em28xx *dev,\r\nunsigned int hscale, unsigned int vscale,\r\nunsigned int *width, unsigned int *height)\r\n{\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\n*width = (((unsigned long)maxw) << 12) / (hscale + 4096L);\r\n*height = (((unsigned long)maxh) << 12) / (vscale + 4096L);\r\nif (*width < 1)\r\n*width = 1;\r\nif (*height < 1)\r\n*height = 1;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nf->fmt.pix.width = v4l2->width;\r\nf->fmt.pix.height = v4l2->height;\r\nf->fmt.pix.pixelformat = v4l2->format->fourcc;\r\nf->fmt.pix.bytesperline = (v4l2->width * v4l2->format->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * v4l2->height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (v4l2->progressive)\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\nf->fmt.pix.field = v4l2->interlaced_fieldmode ?\r\nV4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\r\nreturn 0;\r\n}\r\nstatic struct em28xx_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(format); i++)\r\nif (format[i].fourcc == fourcc)\r\nreturn &format[i];\r\nreturn NULL;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nunsigned int width = f->fmt.pix.width;\r\nunsigned int height = f->fmt.pix.height;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nunsigned int hscale, vscale;\r\nstruct em28xx_fmt *fmt;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\nem28xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (dev->board.is_em2800) {\r\nheight = height > (3 * maxh / 4) ? maxh : maxh / 2;\r\nwidth = width > (3 * maxw / 4) ? maxw : maxw / 2;\r\nif (width == maxw && height == maxh)\r\nwidth /= 2;\r\n} else {\r\nv4l_bound_align_image(&width, 48, maxw, 1, &height, 32, maxh,\r\n1, 0);\r\n}\r\nif (width < 1)\r\nwidth = 1;\r\nif (height < 1)\r\nheight = 1;\r\nsize_to_scale(dev, width, height, &hscale, &vscale);\r\nscale_to_size(dev, hscale, vscale, &width, &height);\r\nf->fmt.pix.width = width;\r\nf->fmt.pix.height = height;\r\nf->fmt.pix.pixelformat = fmt->fourcc;\r\nf->fmt.pix.bytesperline = (width * fmt->depth + 7) >> 3;\r\nf->fmt.pix.sizeimage = f->fmt.pix.bytesperline * height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (v4l2->progressive)\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\nf->fmt.pix.field = v4l2->interlaced_fieldmode ?\r\nV4L2_FIELD_INTERLACED : V4L2_FIELD_TOP;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int em28xx_set_video_format(struct em28xx *dev, unsigned int fourcc,\r\nunsigned width, unsigned height)\r\n{\r\nstruct em28xx_fmt *fmt;\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nfmt = format_by_fourcc(fourcc);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nv4l2->format = fmt;\r\nv4l2->width = width;\r\nv4l2->height = height;\r\nsize_to_scale(dev, v4l2->width, v4l2->height,\r\n&v4l2->hscale, &v4l2->vscale);\r\nem28xx_resolution_set(dev);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (vb2_is_busy(&v4l2->vb_vidq))\r\nreturn -EBUSY;\r\nvidioc_try_fmt_vid_cap(file, priv, f);\r\nreturn em28xx_set_video_format(dev, f->fmt.pix.pixelformat,\r\nf->fmt.pix.width, f->fmt.pix.height);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\n*norm = dev->v4l2->norm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *norm)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, video, querystd, norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id norm)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct v4l2_format f;\r\nif (norm == v4l2->norm)\r\nreturn 0;\r\nif (v4l2->streaming_users > 0)\r\nreturn -EBUSY;\r\nv4l2->norm = norm;\r\nf.fmt.pix.width = 720;\r\nf.fmt.pix.height = (norm & V4L2_STD_525_60) ? 480 : 576;\r\nvidioc_try_fmt_vid_cap(file, priv, &f);\r\nv4l2->width = f.fmt.pix.width;\r\nv4l2->height = f.fmt.pix.height;\r\nsize_to_scale(dev, v4l2->width, v4l2->height,\r\n&v4l2->hscale, &v4l2->vscale);\r\nem28xx_resolution_set(dev);\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_std, v4l2->norm);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *p)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nint rc = 0;\r\np->parm.capture.readbuffers = EM28XX_MIN_BUF;\r\nif (dev->board.is_webcam)\r\nrc = v4l2_device_call_until_err(&v4l2->v4l2_dev, 0,\r\nvideo, g_parm, p);\r\nelse\r\nv4l2_video_std_frame_period(v4l2->norm,\r\n&p->parm.capture.timeperframe);\r\nreturn rc;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *p)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\np->parm.capture.readbuffers = EM28XX_MIN_BUF;\r\nreturn v4l2_device_call_until_err(&dev->v4l2->v4l2_dev,\r\n0, video, s_parm, p);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\nif ((EM28XX_VMUX_TELEVISION == INPUT(n)->type))\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->std = dev->v4l2->vdev.tvnorms;\r\nif (dev->board.is_webcam)\r\ni->capabilities = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\n*i = dev->ctl_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (i >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(i)->type)\r\nreturn -EINVAL;\r\nvideo_mux(dev, i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nswitch (a->index) {\r\ncase EM28XX_AMUX_VIDEO:\r\nstrcpy(a->name, "Television");\r\nbreak;\r\ncase EM28XX_AMUX_LINE_IN:\r\nstrcpy(a->name, "Line In");\r\nbreak;\r\ncase EM28XX_AMUX_VIDEO2:\r\nstrcpy(a->name, "Television alt");\r\nbreak;\r\ncase EM28XX_AMUX_PHONE:\r\nstrcpy(a->name, "Phone");\r\nbreak;\r\ncase EM28XX_AMUX_MIC:\r\nstrcpy(a->name, "Mic");\r\nbreak;\r\ncase EM28XX_AMUX_CD:\r\nstrcpy(a->name, "CD");\r\nbreak;\r\ncase EM28XX_AMUX_AUX:\r\nstrcpy(a->name, "Aux");\r\nbreak;\r\ncase EM28XX_AMUX_PCM_OUT:\r\nstrcpy(a->name, "PCM");\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\na->index = dev->ctl_ainput;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *a)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (a->index >= MAX_EM28XX_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(a->index)->type)\r\nreturn -EINVAL;\r\ndev->ctl_ainput = INPUT(a->index)->amux;\r\ndev->ctl_aoutput = INPUT(a->index)->aout;\r\nif (!dev->ctl_aoutput)\r\ndev->ctl_aoutput = EM28XX_AOUT_MASTER;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Tuner");\r\nv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nf->frequency = v4l2->frequency;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_frequency new_freq = *f;\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, s_frequency, f);\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, g_frequency, &new_freq);\r\nv4l2->frequency = new_freq.frequency;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_chip_info(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_info *chip)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (chip->match.addr > 1)\r\nreturn -EINVAL;\r\nif (chip->match.addr == 1)\r\nstrlcpy(chip->name, "ac97", sizeof(chip->name));\r\nelse\r\nstrlcpy(chip->name,\r\ndev->v4l2->v4l2_dev.name, sizeof(chip->name));\r\nreturn 0;\r\n}\r\nstatic int em28xx_reg_len(int reg)\r\n{\r\nswitch (reg) {\r\ncase EM28XX_R40_AC97LSB:\r\ncase EM28XX_R30_HSCALELOW:\r\ncase EM28XX_R32_VSCALELOW:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nint ret;\r\nif (reg->match.addr > 1)\r\nreturn -EINVAL;\r\nif (reg->match.addr) {\r\nret = em28xx_read_ac97(dev, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nreg->size = em28xx_reg_len(reg->reg);\r\nif (reg->size == 1) {\r\nret = em28xx_read_reg(dev, reg->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = ret;\r\n} else {\r\n__le16 val = 0;\r\nret = dev->em28xx_read_reg_req_len(dev, USB_REQ_GET_STATUS,\r\nreg->reg, (char *)&val, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreg->val = le16_to_cpu(val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\n__le16 buf;\r\nif (reg->match.addr > 1)\r\nreturn -EINVAL;\r\nif (reg->match.addr)\r\nreturn em28xx_write_ac97(dev, reg->reg, reg->val);\r\nbuf = cpu_to_le16(reg->val);\r\nreturn em28xx_write_regs(dev, reg->reg, (char *)&buf,\r\nem28xx_reg_len(reg->reg));\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nstrlcpy(cap->driver, "em28xx", sizeof(cap->driver));\r\nstrlcpy(cap->card, em28xx_boards[dev->model].name, sizeof(cap->card));\r\nusb_make_path(udev, cap->bus_info, sizeof(cap->bus_info));\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER)\r\ncap->device_caps = V4L2_CAP_READWRITE |\r\nV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse if (vdev->vfl_type == VFL_TYPE_RADIO)\r\ncap->device_caps = V4L2_CAP_RADIO;\r\nelse\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_VBI_CAPTURE;\r\nif (dev->int_audio_type != EM28XX_INT_AUDIO_NONE)\r\ncap->device_caps |= V4L2_CAP_AUDIO;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS |\r\nV4L2_CAP_READWRITE | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nif (video_is_registered(&v4l2->vbi_dev))\r\ncap->capabilities |= V4L2_CAP_VBI_CAPTURE;\r\nif (video_is_registered(&v4l2->radio_dev))\r\ncap->capabilities |= V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(format)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, format[f->index].name, sizeof(f->description));\r\nf->pixelformat = format[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_fmt *fmt;\r\nunsigned int maxw = norm_maxw(dev);\r\nunsigned int maxh = norm_maxh(dev);\r\nfmt = format_by_fourcc(fsize->pixel_format);\r\nif (!fmt) {\r\nem28xx_videodbg("Fourcc format (%08x) invalid.\n",\r\nfsize->pixel_format);\r\nreturn -EINVAL;\r\n}\r\nif (dev->board.is_em2800) {\r\nif (fsize->index > 1)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = maxw / (1 + fsize->index);\r\nfsize->discrete.height = maxh / (1 + fsize->index);\r\nreturn 0;\r\n}\r\nif (fsize->index != 0)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nscale_to_size(dev, EM28XX_HVSCALE_MAX, EM28XX_HVSCALE_MAX,\r\n&fsize->stepwise.min_width, &fsize->stepwise.min_height);\r\nif (fsize->stepwise.min_width < 48)\r\nfsize->stepwise.min_width = 48;\r\nif (fsize->stepwise.min_height < 38)\r\nfsize->stepwise.min_height = 38;\r\nfsize->stepwise.max_width = maxw;\r\nfsize->stepwise.max_height = maxh;\r\nfsize->stepwise.step_width = 1;\r\nfsize->stepwise.step_height = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *format)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nformat->fmt.vbi.samples_per_line = v4l2->vbi_width;\r\nformat->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nformat->fmt.vbi.offset = 0;\r\nformat->fmt.vbi.flags = 0;\r\nformat->fmt.vbi.sampling_rate = 6750000 * 4 / 2;\r\nformat->fmt.vbi.count[0] = v4l2->vbi_height;\r\nformat->fmt.vbi.count[1] = v4l2->vbi_height;\r\nmemset(format->fmt.vbi.reserved, 0, sizeof(format->fmt.vbi.reserved));\r\nif (v4l2->norm & V4L2_STD_525_60) {\r\nformat->fmt.vbi.start[0] = 10;\r\nformat->fmt.vbi.start[1] = 273;\r\n} else if (v4l2->norm & V4L2_STD_625_50) {\r\nformat->fmt.vbi.start[0] = 6;\r\nformat->fmt.vbi.start[1] = 318;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (unlikely(t->index > 0))\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct em28xx *dev = video_drvdata(file);\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nv4l2_device_call_all(&dev->v4l2->v4l2_dev, 0, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic void em28xx_free_v4l2(struct kref *ref)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = container_of(ref, struct em28xx_v4l2, ref);\r\nv4l2->dev->v4l2 = NULL;\r\nkfree(v4l2);\r\n}\r\nstatic int em28xx_v4l2_open(struct file *filp)\r\n{\r\nstruct video_device *vdev = video_devdata(filp);\r\nstruct em28xx *dev = video_drvdata(filp);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nenum v4l2_buf_type fh_type = 0;\r\nint ret;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nfh_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nfh_type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nem28xx_videodbg("open dev=%s type=%s users=%d\n",\r\nvideo_device_node_name(vdev), v4l2_type_names[fh_type],\r\nv4l2->users);\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(filp);\r\nif (ret) {\r\ndev_err(&dev->intf->dev,\r\n"%s: v4l2_fh_open() returned error %d\n",\r\n__func__, ret);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nif (v4l2->users == 0) {\r\nem28xx_set_mode(dev, EM28XX_ANALOG_MODE);\r\nif (vdev->vfl_type != VFL_TYPE_RADIO)\r\nem28xx_resolution_set(dev);\r\nem28xx_wake_i2c(dev);\r\n}\r\nif (vdev->vfl_type == VFL_TYPE_RADIO) {\r\nem28xx_videodbg("video_open: setting radio device\n");\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, tuner, s_radio);\r\n}\r\nkref_get(&dev->ref);\r\nkref_get(&v4l2->ref);\r\nv4l2->users++;\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int em28xx_v4l2_fini(struct em28xx *dev)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nif (!dev->has_video) {\r\nreturn 0;\r\n}\r\nif (v4l2 == NULL)\r\nreturn 0;\r\ndev_info(&dev->intf->dev, "Closing video extension\n");\r\nmutex_lock(&dev->lock);\r\nv4l2_device_disconnect(&v4l2->v4l2_dev);\r\nem28xx_uninit_usb_xfer(dev, EM28XX_ANALOG_MODE);\r\nem28xx_v4l2_media_release(dev);\r\nif (video_is_registered(&v4l2->radio_dev)) {\r\ndev_info(&dev->intf->dev, "V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->radio_dev));\r\nvideo_unregister_device(&v4l2->radio_dev);\r\n}\r\nif (video_is_registered(&v4l2->vbi_dev)) {\r\ndev_info(&dev->intf->dev, "V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->vbi_dev));\r\nvideo_unregister_device(&v4l2->vbi_dev);\r\n}\r\nif (video_is_registered(&v4l2->vdev)) {\r\ndev_info(&dev->intf->dev, "V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->vdev));\r\nvideo_unregister_device(&v4l2->vdev);\r\n}\r\nv4l2_ctrl_handler_free(&v4l2->ctrl_handler);\r\nv4l2_device_unregister(&v4l2->v4l2_dev);\r\nif (v4l2->clk) {\r\nv4l2_clk_unregister_fixed(v4l2->clk);\r\nv4l2->clk = NULL;\r\n}\r\nkref_put(&v4l2->ref, em28xx_free_v4l2);\r\nmutex_unlock(&dev->lock);\r\nkref_put(&dev->ref, em28xx_free_device);\r\nreturn 0;\r\n}\r\nstatic int em28xx_v4l2_suspend(struct em28xx *dev)\r\n{\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nif (!dev->has_video)\r\nreturn 0;\r\ndev_info(&dev->intf->dev, "Suspending video extension\n");\r\nem28xx_stop_urbs(dev);\r\nreturn 0;\r\n}\r\nstatic int em28xx_v4l2_resume(struct em28xx *dev)\r\n{\r\nif (dev->is_audio_only)\r\nreturn 0;\r\nif (!dev->has_video)\r\nreturn 0;\r\ndev_info(&dev->intf->dev, "Resuming video extension\n");\r\nreturn 0;\r\n}\r\nstatic int em28xx_v4l2_close(struct file *filp)\r\n{\r\nstruct em28xx *dev = video_drvdata(filp);\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint errCode;\r\nem28xx_videodbg("users=%d\n", v4l2->users);\r\nvb2_fop_release(filp);\r\nmutex_lock(&dev->lock);\r\nif (v4l2->users == 1) {\r\nif (dev->disconnected)\r\ngoto exit;\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, core, s_power, 0);\r\nem28xx_set_mode(dev, EM28XX_SUSPEND);\r\ndev->alt = 0;\r\nem28xx_videodbg("setting alternate 0\n");\r\nerrCode = usb_set_interface(udev, 0, 0);\r\nif (errCode < 0) {\r\ndev_err(&dev->intf->dev,\r\n"cannot change alternate number to 0 (error=%i)\n",\r\nerrCode);\r\n}\r\n}\r\nexit:\r\nv4l2->users--;\r\nkref_put(&v4l2->ref, em28xx_free_v4l2);\r\nmutex_unlock(&dev->lock);\r\nkref_put(&dev->ref, em28xx_free_device);\r\nreturn 0;\r\n}\r\nstatic void em28xx_vdev_init(struct em28xx *dev,\r\nstruct video_device *vfd,\r\nconst struct video_device *template,\r\nconst char *type_name)\r\n{\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2->v4l2_dev;\r\nvfd->lock = &dev->lock;\r\nif (dev->board.is_webcam)\r\nvfd->tvnorms = 0;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s",\r\ndev_name(&dev->intf->dev), type_name);\r\nvideo_set_drvdata(vfd, dev);\r\n}\r\nstatic void em28xx_tuner_setup(struct em28xx *dev, unsigned short tuner_addr)\r\n{\r\nstruct em28xx_v4l2 *v4l2 = dev->v4l2;\r\nstruct v4l2_device *v4l2_dev = &v4l2->v4l2_dev;\r\nstruct tuner_setup tun_setup;\r\nstruct v4l2_frequency f;\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\ntun_setup.mode_mask = T_ANALOG_TV | T_RADIO;\r\ntun_setup.tuner_callback = em28xx_tuner_callback;\r\nif (dev->board.radio.type) {\r\ntun_setup.type = dev->board.radio.type;\r\ntun_setup.addr = dev->board.radio_addr;\r\nv4l2_device_call_all(v4l2_dev,\r\n0, tuner, s_type_addr, &tun_setup);\r\n}\r\nif ((dev->tuner_type != TUNER_ABSENT) && (dev->tuner_type)) {\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = tuner_addr;\r\nv4l2_device_call_all(v4l2_dev,\r\n0, tuner, s_type_addr, &tun_setup);\r\n}\r\nif (dev->board.tda9887_conf) {\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &dev->board.tda9887_conf;\r\nv4l2_device_call_all(v4l2_dev,\r\n0, tuner, s_config, &tda9887_cfg);\r\n}\r\nif (dev->tuner_type == TUNER_XC2028) {\r\nstruct v4l2_priv_tun_config xc2028_cfg;\r\nstruct xc2028_ctrl ctl;\r\nmemset(&xc2028_cfg, 0, sizeof(xc2028_cfg));\r\nmemset(&ctl, 0, sizeof(ctl));\r\nem28xx_setup_xc3028(dev, &ctl);\r\nxc2028_cfg.tuner = TUNER_XC2028;\r\nxc2028_cfg.priv = &ctl;\r\nv4l2_device_call_all(v4l2_dev, 0, tuner, s_config, &xc2028_cfg);\r\n}\r\nf.tuner = 0;\r\nf.type = V4L2_TUNER_ANALOG_TV;\r\nf.frequency = 9076;\r\nv4l2->frequency = f.frequency;\r\nv4l2_device_call_all(v4l2_dev, 0, tuner, s_frequency, &f);\r\n}\r\nstatic int em28xx_v4l2_init(struct em28xx *dev)\r\n{\r\nu8 val;\r\nint ret;\r\nunsigned int maxw;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct em28xx_v4l2 *v4l2;\r\nif (dev->is_audio_only) {\r\nreturn 0;\r\n}\r\nif (!dev->has_video) {\r\nreturn 0;\r\n}\r\ndev_info(&dev->intf->dev, "Registering V4L2 extension\n");\r\nmutex_lock(&dev->lock);\r\nv4l2 = kzalloc(sizeof(struct em28xx_v4l2), GFP_KERNEL);\r\nif (!v4l2) {\r\nmutex_unlock(&dev->lock);\r\nreturn -ENOMEM;\r\n}\r\nkref_init(&v4l2->ref);\r\nv4l2->dev = dev;\r\ndev->v4l2 = v4l2;\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nv4l2->v4l2_dev.mdev = dev->media_dev;\r\n#endif\r\nret = v4l2_device_register(&dev->intf->dev, &v4l2->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"Call to v4l2_device_register() failed!\n");\r\ngoto err;\r\n}\r\nhdl = &v4l2->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 8);\r\nv4l2->v4l2_dev.ctrl_handler = hdl;\r\nif (dev->board.is_webcam)\r\nv4l2->progressive = true;\r\nv4l2->vinmode = 0x10;\r\nv4l2->vinctl = EM28XX_VINCTRL_INTERLACED |\r\nEM28XX_VINCTRL_CCIR656_ENABLE;\r\nif (dev->board.has_msp34xx)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"msp3400", 0, msp3400_addrs);\r\nif (dev->board.decoder == EM28XX_SAA711X)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"saa7115_auto", 0, saa711x_addrs);\r\nif (dev->board.decoder == EM28XX_TVP5150)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tvp5150", 0, tvp5150_addrs);\r\nif (dev->board.adecoder == EM28XX_TVAUDIO)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tvaudio", dev->board.tvaudio_addr, NULL);\r\nif (dev->board.tuner_type != TUNER_ABSENT) {\r\nunsigned short tuner_addr = dev->board.tuner_addr;\r\nint has_demod = (dev->board.tda9887_conf & TDA9887_PRESENT);\r\nif (dev->board.radio.type)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tuner", dev->board.radio_addr,\r\nNULL);\r\nif (has_demod)\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tuner", 0,\r\nv4l2_i2c_tuner_addrs(ADDRS_DEMOD));\r\nif (tuner_addr == 0) {\r\nenum v4l2_i2c_tuner_type type =\r\nhas_demod ? ADDRS_TV_WITH_DEMOD : ADDRS_TV;\r\nstruct v4l2_subdev *sd;\r\nsd = v4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tuner", 0,\r\nv4l2_i2c_tuner_addrs(type));\r\nif (sd)\r\ntuner_addr = v4l2_i2c_subdev_addr(sd);\r\n} else {\r\nv4l2_i2c_new_subdev(&v4l2->v4l2_dev,\r\n&dev->i2c_adap[dev->def_i2c_bus],\r\n"tuner", tuner_addr, NULL);\r\n}\r\nem28xx_tuner_setup(dev, tuner_addr);\r\n}\r\nif (dev->em28xx_sensor != EM28XX_NOSENSOR)\r\nem28xx_init_camera(dev);\r\nret = em28xx_audio_setup(dev);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"%s: Error while setting audio - error [%d]!\n",\r\n__func__, ret);\r\ngoto unregister_dev;\r\n}\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, 0, 0x1f, 1, 0x1f);\r\n} else {\r\nv4l2_ctrl_notify(v4l2_ctrl_find(hdl, V4L2_CID_AUDIO_MUTE),\r\nem28xx_ctrl_notify, dev);\r\nv4l2_ctrl_notify(v4l2_ctrl_find(hdl, V4L2_CID_AUDIO_VOLUME),\r\nem28xx_ctrl_notify, dev);\r\n}\r\nem28xx_wake_i2c(dev);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\nif (dev->board.has_msp34xx) {\r\nret = em28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xf7);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"%s: em28xx_write_reg - msp34xx(1) failed! error [%d]\n",\r\n__func__, ret);\r\ngoto unregister_dev;\r\n}\r\nmsleep(3);\r\nret = em28xx_write_reg(dev, EM2820_R08_GPIO_CTRL, 0xff);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"%s: em28xx_write_reg - msp34xx(2) failed! error [%d]\n",\r\n__func__, ret);\r\ngoto unregister_dev;\r\n}\r\nmsleep(3);\r\n}\r\nv4l2->norm = V4L2_STD_PAL;\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, video, s_std, v4l2->norm);\r\nv4l2->interlaced_fieldmode = EM28XX_INTERLACED_DEFAULT;\r\nv4l2->format = &format[0];\r\nmaxw = norm_maxw(dev);\r\nif (dev->board.is_em2800)\r\nmaxw /= 2;\r\nem28xx_set_video_format(dev, format[0].fourcc,\r\nmaxw, norm_maxh(dev));\r\nvideo_mux(dev, 0);\r\ndev->mute = 1;\r\ndev->volume = 0x1f;\r\nval = (u8)em28xx_read_reg(dev, EM28XX_R0F_XCLK);\r\nem28xx_write_reg(dev, EM28XX_R0F_XCLK,\r\n(EM28XX_XCLK_AUDIO_UNMUTE | val));\r\nem28xx_set_outfmt(dev);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_CONTRAST))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_CONTRAST,\r\n0, 0x1f, 1, CONTRAST_DEFAULT);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_BRIGHTNESS))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS,\r\n-0x80, 0x7f, 1, BRIGHTNESS_DEFAULT);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_SATURATION))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_SATURATION,\r\n0, 0x1f, 1, SATURATION_DEFAULT);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_BLUE_BALANCE))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE,\r\n-0x30, 0x30, 1, BLUE_BALANCE_DEFAULT);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_RED_BALANCE))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_RED_BALANCE,\r\n-0x30, 0x30, 1, RED_BALANCE_DEFAULT);\r\nif (NULL == v4l2_ctrl_find(hdl, V4L2_CID_SHARPNESS))\r\nv4l2_ctrl_new_std(hdl, &em28xx_ctrl_ops,\r\nV4L2_CID_SHARPNESS,\r\n0, 0x0f, 1, SHARPNESS_DEFAULT);\r\nem28xx_colorlevels_set_default(dev);\r\nv4l2_ctrl_handler_setup(hdl);\r\nret = hdl->error;\r\nif (ret)\r\ngoto unregister_dev;\r\nem28xx_vdev_init(dev, &v4l2->vdev, &em28xx_video_template, "video");\r\nmutex_init(&v4l2->vb_queue_lock);\r\nmutex_init(&v4l2->vb_vbi_queue_lock);\r\nv4l2->vdev.queue = &v4l2->vb_vidq;\r\nv4l2->vdev.queue->lock = &v4l2->vb_queue_lock;\r\nif (dev->board.is_webcam) {\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_QUERYSTD);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_STD);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_STD);\r\n} else {\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_PARM);\r\n}\r\nif (dev->tuner_type == TUNER_ABSENT) {\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_FREQUENCY);\r\n}\r\nif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE) {\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_G_AUDIO);\r\nv4l2_disable_ioctl(&v4l2->vdev, VIDIOC_S_AUDIO);\r\n}\r\nret = video_register_device(&v4l2->vdev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->devno]);\r\nif (ret) {\r\ndev_err(&dev->intf->dev,\r\n"unable to register video device (error=%i).\n", ret);\r\ngoto unregister_dev;\r\n}\r\nif (em28xx_vbi_supported(dev) == 1) {\r\nem28xx_vdev_init(dev, &v4l2->vbi_dev, &em28xx_video_template,\r\n"vbi");\r\nv4l2->vbi_dev.queue = &v4l2->vb_vbiq;\r\nv4l2->vbi_dev.queue->lock = &v4l2->vb_vbi_queue_lock;\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_PARM);\r\nif (dev->tuner_type == TUNER_ABSENT) {\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_TUNER);\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_TUNER);\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_FREQUENCY);\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_FREQUENCY);\r\n}\r\nif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE) {\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_G_AUDIO);\r\nv4l2_disable_ioctl(&v4l2->vbi_dev, VIDIOC_S_AUDIO);\r\n}\r\nret = video_register_device(&v4l2->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->devno]);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"unable to register vbi device\n");\r\ngoto unregister_dev;\r\n}\r\n}\r\nif (em28xx_boards[dev->model].radio.type == EM28XX_RADIO) {\r\nem28xx_vdev_init(dev, &v4l2->radio_dev, &em28xx_radio_template,\r\n"radio");\r\nret = video_register_device(&v4l2->radio_dev, VFL_TYPE_RADIO,\r\nradio_nr[dev->devno]);\r\nif (ret < 0) {\r\ndev_err(&dev->intf->dev,\r\n"can't register radio device\n");\r\ngoto unregister_dev;\r\n}\r\ndev_info(&dev->intf->dev,\r\n"Registered radio device as %s\n",\r\nvideo_device_node_name(&v4l2->radio_dev));\r\n}\r\nem28xx_v4l2_create_entities(dev);\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nret = v4l2_mc_create_media_graph(dev->media_dev);\r\nif (ret) {\r\ndev_err(&dev->intf->dev,\r\n"failed to create media graph\n");\r\nem28xx_v4l2_media_release(dev);\r\ngoto unregister_dev;\r\n}\r\n#endif\r\ndev_info(&dev->intf->dev,\r\n"V4L2 video device registered as %s\n",\r\nvideo_device_node_name(&v4l2->vdev));\r\nif (video_is_registered(&v4l2->vbi_dev))\r\ndev_info(&dev->intf->dev,\r\n"V4L2 VBI device registered as %s\n",\r\nvideo_device_node_name(&v4l2->vbi_dev));\r\nv4l2_device_call_all(&v4l2->v4l2_dev, 0, core, s_power, 0);\r\nem28xx_vb2_setup(dev);\r\ndev_info(&dev->intf->dev,\r\n"V4L2 extension successfully initialized\n");\r\nkref_get(&dev->ref);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\nunregister_dev:\r\nif (video_is_registered(&v4l2->radio_dev)) {\r\ndev_info(&dev->intf->dev,\r\n"V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->radio_dev));\r\nvideo_unregister_device(&v4l2->radio_dev);\r\n}\r\nif (video_is_registered(&v4l2->vbi_dev)) {\r\ndev_info(&dev->intf->dev,\r\n"V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->vbi_dev));\r\nvideo_unregister_device(&v4l2->vbi_dev);\r\n}\r\nif (video_is_registered(&v4l2->vdev)) {\r\ndev_info(&dev->intf->dev,\r\n"V4L2 device %s deregistered\n",\r\nvideo_device_node_name(&v4l2->vdev));\r\nvideo_unregister_device(&v4l2->vdev);\r\n}\r\nv4l2_ctrl_handler_free(&v4l2->ctrl_handler);\r\nv4l2_device_unregister(&v4l2->v4l2_dev);\r\nerr:\r\ndev->v4l2 = NULL;\r\nkref_put(&v4l2->ref, em28xx_free_v4l2);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int __init em28xx_video_register(void)\r\n{\r\nreturn em28xx_register_extension(&v4l2_ops);\r\n}\r\nstatic void __exit em28xx_video_unregister(void)\r\n{\r\nem28xx_unregister_extension(&v4l2_ops);\r\n}
