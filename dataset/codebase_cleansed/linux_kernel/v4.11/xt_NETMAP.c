static unsigned int\r\nnetmap_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct nf_nat_range *range = par->targinfo;\r\nstruct nf_nat_range newrange;\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nunion nf_inet_addr new_addr, netmask;\r\nunsigned int i;\r\nct = nf_ct_get(skb, &ctinfo);\r\nfor (i = 0; i < ARRAY_SIZE(range->min_addr.ip6); i++)\r\nnetmask.ip6[i] = ~(range->min_addr.ip6[i] ^\r\nrange->max_addr.ip6[i]);\r\nif (xt_hooknum(par) == NF_INET_PRE_ROUTING ||\r\nxt_hooknum(par) == NF_INET_LOCAL_OUT)\r\nnew_addr.in6 = ipv6_hdr(skb)->daddr;\r\nelse\r\nnew_addr.in6 = ipv6_hdr(skb)->saddr;\r\nfor (i = 0; i < ARRAY_SIZE(new_addr.ip6); i++) {\r\nnew_addr.ip6[i] &= ~netmask.ip6[i];\r\nnew_addr.ip6[i] |= range->min_addr.ip6[i] &\r\nnetmask.ip6[i];\r\n}\r\nnewrange.flags = range->flags | NF_NAT_RANGE_MAP_IPS;\r\nnewrange.min_addr = new_addr;\r\nnewrange.max_addr = new_addr;\r\nnewrange.min_proto = range->min_proto;\r\nnewrange.max_proto = range->max_proto;\r\nreturn nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));\r\n}\r\nstatic int netmap_tg6_checkentry(const struct xt_tgchk_param *par)\r\n{\r\nconst struct nf_nat_range *range = par->targinfo;\r\nif (!(range->flags & NF_NAT_RANGE_MAP_IPS))\r\nreturn -EINVAL;\r\nreturn nf_ct_netns_get(par->net, par->family);\r\n}\r\nstatic void netmap_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nnf_ct_netns_put(par->net, par->family);\r\n}\r\nstatic unsigned int\r\nnetmap_tg4(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\n__be32 new_ip, netmask;\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nstruct nf_nat_range newrange;\r\nNF_CT_ASSERT(xt_hooknum(par) == NF_INET_PRE_ROUTING ||\r\nxt_hooknum(par) == NF_INET_POST_ROUTING ||\r\nxt_hooknum(par) == NF_INET_LOCAL_OUT ||\r\nxt_hooknum(par) == NF_INET_LOCAL_IN);\r\nct = nf_ct_get(skb, &ctinfo);\r\nnetmask = ~(mr->range[0].min_ip ^ mr->range[0].max_ip);\r\nif (xt_hooknum(par) == NF_INET_PRE_ROUTING ||\r\nxt_hooknum(par) == NF_INET_LOCAL_OUT)\r\nnew_ip = ip_hdr(skb)->daddr & ~netmask;\r\nelse\r\nnew_ip = ip_hdr(skb)->saddr & ~netmask;\r\nnew_ip |= mr->range[0].min_ip & netmask;\r\nmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\r\nmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\r\nnewrange.flags = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\r\nnewrange.min_addr.ip = new_ip;\r\nnewrange.max_addr.ip = new_ip;\r\nnewrange.min_proto = mr->range[0].min;\r\nnewrange.max_proto = mr->range[0].max;\r\nreturn nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));\r\n}\r\nstatic int netmap_tg4_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;\r\nif (!(mr->range[0].flags & NF_NAT_RANGE_MAP_IPS)) {\r\npr_debug("bad MAP_IPS.\n");\r\nreturn -EINVAL;\r\n}\r\nif (mr->rangesize != 1) {\r\npr_debug("bad rangesize %u.\n", mr->rangesize);\r\nreturn -EINVAL;\r\n}\r\nreturn nf_ct_netns_get(par->net, par->family);\r\n}\r\nstatic int __init netmap_tg_init(void)\r\n{\r\nreturn xt_register_targets(netmap_tg_reg, ARRAY_SIZE(netmap_tg_reg));\r\n}\r\nstatic void netmap_tg_exit(void)\r\n{\r\nxt_unregister_targets(netmap_tg_reg, ARRAY_SIZE(netmap_tg_reg));\r\n}
