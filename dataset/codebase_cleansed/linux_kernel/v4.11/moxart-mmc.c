static inline void moxart_init_sg(struct moxart_host *host,\r\nstruct mmc_data *data)\r\n{\r\nhost->cur_sg = data->sg;\r\nhost->num_sg = data->sg_len;\r\nhost->data_remain = host->cur_sg->length;\r\nif (host->data_remain > host->data_len)\r\nhost->data_remain = host->data_len;\r\n}\r\nstatic inline int moxart_next_sg(struct moxart_host *host)\r\n{\r\nint remain;\r\nstruct mmc_data *data = host->mrq->cmd->data;\r\nhost->cur_sg++;\r\nhost->num_sg--;\r\nif (host->num_sg > 0) {\r\nhost->data_remain = host->cur_sg->length;\r\nremain = host->data_len - data->bytes_xfered;\r\nif (remain > 0 && remain < host->data_remain)\r\nhost->data_remain = remain;\r\n}\r\nreturn host->num_sg;\r\n}\r\nstatic int moxart_wait_for_status(struct moxart_host *host,\r\nu32 mask, u32 *status)\r\n{\r\nint ret = -ETIMEDOUT;\r\nu32 i;\r\nfor (i = 0; i < MAX_RETRIES; i++) {\r\n*status = readl(host->base + REG_STATUS);\r\nif (!(*status & mask)) {\r\nudelay(5);\r\ncontinue;\r\n}\r\nwritel(*status & mask, host->base + REG_CLEAR);\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret)\r\ndev_err(mmc_dev(host->mmc), "timed out waiting for status\n");\r\nreturn ret;\r\n}\r\nstatic void moxart_send_command(struct moxart_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 status, cmdctrl;\r\nwritel(RSP_TIMEOUT | RSP_CRC_OK |\r\nRSP_CRC_FAIL | CMD_SENT, host->base + REG_CLEAR);\r\nwritel(cmd->arg, host->base + REG_ARGUMENT);\r\ncmdctrl = cmd->opcode & CMD_IDX_MASK;\r\nif (cmdctrl == SD_APP_SET_BUS_WIDTH || cmdctrl == SD_APP_OP_COND ||\r\ncmdctrl == SD_APP_SEND_SCR || cmdctrl == SD_APP_SD_STATUS ||\r\ncmdctrl == SD_APP_SEND_NUM_WR_BLKS)\r\ncmdctrl |= CMD_APP_CMD;\r\nif (cmd->flags & MMC_RSP_PRESENT)\r\ncmdctrl |= CMD_NEED_RSP;\r\nif (cmd->flags & MMC_RSP_136)\r\ncmdctrl |= CMD_LONG_RSP;\r\nwritel(cmdctrl | CMD_EN, host->base + REG_COMMAND);\r\nif (moxart_wait_for_status(host, MASK_RSP, &status) == -ETIMEDOUT)\r\ncmd->error = -ETIMEDOUT;\r\nif (status & RSP_TIMEOUT) {\r\ncmd->error = -ETIMEDOUT;\r\nreturn;\r\n}\r\nif (status & RSP_CRC_FAIL) {\r\ncmd->error = -EIO;\r\nreturn;\r\n}\r\nif (status & RSP_CRC_OK) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] = readl(host->base + REG_RESPONSE0);\r\ncmd->resp[2] = readl(host->base + REG_RESPONSE1);\r\ncmd->resp[1] = readl(host->base + REG_RESPONSE2);\r\ncmd->resp[0] = readl(host->base + REG_RESPONSE3);\r\n} else {\r\ncmd->resp[0] = readl(host->base + REG_RESPONSE0);\r\n}\r\n}\r\n}\r\nstatic void moxart_dma_complete(void *param)\r\n{\r\nstruct moxart_host *host = param;\r\ncomplete(&host->dma_complete);\r\n}\r\nstatic void moxart_transfer_dma(struct mmc_data *data, struct moxart_host *host)\r\n{\r\nu32 len, dir_data, dir_slave;\r\nlong dma_time;\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\nstruct dma_chan *dma_chan;\r\nif (host->data_len == data->bytes_xfered)\r\nreturn;\r\nif (data->flags & MMC_DATA_WRITE) {\r\ndma_chan = host->dma_chan_tx;\r\ndir_data = DMA_TO_DEVICE;\r\ndir_slave = DMA_MEM_TO_DEV;\r\n} else {\r\ndma_chan = host->dma_chan_rx;\r\ndir_data = DMA_FROM_DEVICE;\r\ndir_slave = DMA_DEV_TO_MEM;\r\n}\r\nlen = dma_map_sg(dma_chan->device->dev, data->sg,\r\ndata->sg_len, dir_data);\r\nif (len > 0) {\r\ndesc = dmaengine_prep_slave_sg(dma_chan, data->sg,\r\nlen, dir_slave,\r\nDMA_PREP_INTERRUPT |\r\nDMA_CTRL_ACK);\r\n} else {\r\ndev_err(mmc_dev(host->mmc), "dma_map_sg returned zero length\n");\r\n}\r\nif (desc) {\r\nhost->tx_desc = desc;\r\ndesc->callback = moxart_dma_complete;\r\ndesc->callback_param = host;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(dma_chan);\r\n}\r\ndata->bytes_xfered += host->data_remain;\r\ndma_time = wait_for_completion_interruptible_timeout(\r\n&host->dma_complete, host->timeout);\r\ndma_unmap_sg(dma_chan->device->dev,\r\ndata->sg, data->sg_len,\r\ndir_data);\r\n}\r\nstatic void moxart_transfer_pio(struct moxart_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->cmd->data;\r\nu32 *sgp, len = 0, remain, status;\r\nif (host->data_len == data->bytes_xfered)\r\nreturn;\r\nsgp = sg_virt(host->cur_sg);\r\nremain = host->data_remain;\r\nif (data->flags & MMC_DATA_WRITE) {\r\nwhile (remain > 0) {\r\nif (moxart_wait_for_status(host, FIFO_URUN, &status)\r\n== -ETIMEDOUT) {\r\ndata->error = -ETIMEDOUT;\r\ncomplete(&host->pio_complete);\r\nreturn;\r\n}\r\nfor (len = 0; len < remain && len < host->fifo_width;) {\r\niowrite32(*sgp, host->base + REG_DATA_WINDOW);\r\nsgp++;\r\nlen += 4;\r\n}\r\nremain -= len;\r\n}\r\n} else {\r\nwhile (remain > 0) {\r\nif (moxart_wait_for_status(host, FIFO_ORUN, &status)\r\n== -ETIMEDOUT) {\r\ndata->error = -ETIMEDOUT;\r\ncomplete(&host->pio_complete);\r\nreturn;\r\n}\r\nfor (len = 0; len < remain && len < host->fifo_width;) {\r\nif (data->mrq->cmd->opcode == SD_APP_SEND_SCR)\r\n*sgp = ioread32be(host->base +\r\nREG_DATA_WINDOW);\r\nelse\r\n*sgp = ioread32(host->base +\r\nREG_DATA_WINDOW);\r\nsgp++;\r\nlen += 4;\r\n}\r\nremain -= len;\r\n}\r\n}\r\ndata->bytes_xfered += host->data_remain - remain;\r\nhost->data_remain = remain;\r\nif (host->data_len != data->bytes_xfered)\r\nmoxart_next_sg(host);\r\nelse\r\ncomplete(&host->pio_complete);\r\n}\r\nstatic void moxart_prepare_data(struct moxart_host *host)\r\n{\r\nstruct mmc_data *data = host->mrq->cmd->data;\r\nu32 datactrl;\r\nint blksz_bits;\r\nif (!data)\r\nreturn;\r\nhost->data_len = data->blocks * data->blksz;\r\nblksz_bits = ffs(data->blksz) - 1;\r\nBUG_ON(1 << blksz_bits != data->blksz);\r\nmoxart_init_sg(host, data);\r\ndatactrl = DCR_DATA_EN | (blksz_bits & DCR_BLK_SIZE);\r\nif (data->flags & MMC_DATA_WRITE)\r\ndatactrl |= DCR_DATA_WRITE;\r\nif ((host->data_len > host->fifo_width) && host->have_dma)\r\ndatactrl |= DCR_DMA_EN;\r\nwritel(DCR_DATA_FIFO_RESET, host->base + REG_DATA_CONTROL);\r\nwritel(MASK_DATA | FIFO_URUN | FIFO_ORUN, host->base + REG_CLEAR);\r\nwritel(host->rate, host->base + REG_DATA_TIMER);\r\nwritel(host->data_len, host->base + REG_DATA_LENGTH);\r\nwritel(datactrl, host->base + REG_DATA_CONTROL);\r\n}\r\nstatic void moxart_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct moxart_host *host = mmc_priv(mmc);\r\nlong pio_time;\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&host->lock, flags);\r\ninit_completion(&host->dma_complete);\r\ninit_completion(&host->pio_complete);\r\nhost->mrq = mrq;\r\nif (readl(host->base + REG_STATUS) & CARD_DETECT) {\r\nmrq->cmd->error = -ETIMEDOUT;\r\ngoto request_done;\r\n}\r\nmoxart_prepare_data(host);\r\nmoxart_send_command(host, host->mrq->cmd);\r\nif (mrq->cmd->data) {\r\nif ((host->data_len > host->fifo_width) && host->have_dma) {\r\nwritel(CARD_CHANGE, host->base + REG_INTERRUPT_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmoxart_transfer_dma(mrq->cmd->data, host);\r\nspin_lock_irqsave(&host->lock, flags);\r\n} else {\r\nwritel(MASK_INTR_PIO, host->base + REG_INTERRUPT_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\npio_time = wait_for_completion_interruptible_timeout(\r\n&host->pio_complete, host->timeout);\r\nspin_lock_irqsave(&host->lock, flags);\r\n}\r\nif (host->is_removed) {\r\ndev_err(mmc_dev(host->mmc), "card removed\n");\r\nmrq->cmd->error = -ETIMEDOUT;\r\ngoto request_done;\r\n}\r\nif (moxart_wait_for_status(host, MASK_DATA, &status)\r\n== -ETIMEDOUT) {\r\nmrq->cmd->data->error = -ETIMEDOUT;\r\ngoto request_done;\r\n}\r\nif (status & DATA_CRC_FAIL)\r\nmrq->cmd->data->error = -ETIMEDOUT;\r\nif (mrq->cmd->data->stop)\r\nmoxart_send_command(host, mrq->cmd->data->stop);\r\n}\r\nrequest_done:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic irqreturn_t moxart_irq(int irq, void *devid)\r\n{\r\nstruct moxart_host *host = (struct moxart_host *)devid;\r\nu32 status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nstatus = readl(host->base + REG_STATUS);\r\nif (status & CARD_CHANGE) {\r\nhost->is_removed = status & CARD_DETECT;\r\nif (host->is_removed && host->have_dma) {\r\ndmaengine_terminate_all(host->dma_chan_tx);\r\ndmaengine_terminate_all(host->dma_chan_rx);\r\n}\r\nhost->mrq = NULL;\r\nwritel(MASK_INTR_PIO, host->base + REG_CLEAR);\r\nwritel(CARD_CHANGE, host->base + REG_INTERRUPT_MASK);\r\nmmc_detect_change(host->mmc, 0);\r\n}\r\nif (status & (FIFO_ORUN | FIFO_URUN) && host->mrq)\r\nmoxart_transfer_pio(host);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void moxart_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct moxart_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu8 power, div;\r\nu32 ctrl;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (ios->clock) {\r\nfor (div = 0; div < CLK_DIV_MASK; ++div) {\r\nif (ios->clock >= host->sysclk / (2 * (div + 1)))\r\nbreak;\r\n}\r\nctrl = CLK_SD | div;\r\nhost->rate = host->sysclk / (2 * (div + 1));\r\nif (host->rate > host->sysclk)\r\nctrl |= CLK_HISPD;\r\nwritel(ctrl, host->base + REG_CLOCK_CONTROL);\r\n}\r\nif (ios->power_mode == MMC_POWER_OFF) {\r\nwritel(readl(host->base + REG_POWER_CONTROL) & ~SD_POWER_ON,\r\nhost->base + REG_POWER_CONTROL);\r\n} else {\r\nif (ios->vdd < MIN_POWER)\r\npower = 0;\r\nelse\r\npower = ios->vdd - MIN_POWER;\r\nwritel(SD_POWER_ON | (u32) power,\r\nhost->base + REG_POWER_CONTROL);\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_4:\r\nwritel(BUS_WIDTH_4, host->base + REG_BUS_WIDTH);\r\nbreak;\r\ncase MMC_BUS_WIDTH_8:\r\nwritel(BUS_WIDTH_8, host->base + REG_BUS_WIDTH);\r\nbreak;\r\ndefault:\r\nwritel(BUS_WIDTH_1, host->base + REG_BUS_WIDTH);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic int moxart_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct moxart_host *host = mmc_priv(mmc);\r\nreturn !!(readl(host->base + REG_STATUS) & WRITE_PROT);\r\n}\r\nstatic int moxart_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource res_mmc;\r\nstruct mmc_host *mmc;\r\nstruct moxart_host *host = NULL;\r\nstruct dma_slave_config cfg;\r\nstruct clk *clk;\r\nvoid __iomem *reg_mmc;\r\nint irq, ret;\r\nu32 i;\r\nmmc = mmc_alloc_host(sizeof(struct moxart_host), dev);\r\nif (!mmc) {\r\ndev_err(dev, "mmc_alloc_host failed\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = of_address_to_resource(node, 0, &res_mmc);\r\nif (ret) {\r\ndev_err(dev, "of_address_to_resource failed\n");\r\ngoto out;\r\n}\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "irq_of_parse_and_map failed\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nclk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nreg_mmc = devm_ioremap_resource(dev, &res_mmc);\r\nif (IS_ERR(reg_mmc)) {\r\nret = PTR_ERR(reg_mmc);\r\ngoto out;\r\n}\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto out;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->base = reg_mmc;\r\nhost->reg_phys = res_mmc.start;\r\nhost->timeout = msecs_to_jiffies(1000);\r\nhost->sysclk = clk_get_rate(clk);\r\nhost->fifo_width = readl(host->base + REG_FEATURE) << 2;\r\nhost->dma_chan_tx = dma_request_slave_channel_reason(dev, "tx");\r\nhost->dma_chan_rx = dma_request_slave_channel_reason(dev, "rx");\r\nspin_lock_init(&host->lock);\r\nmmc->ops = &moxart_ops;\r\nmmc->f_max = DIV_ROUND_CLOSEST(host->sysclk, 2);\r\nmmc->f_min = DIV_ROUND_CLOSEST(host->sysclk, CLK_DIV_MASK * 2);\r\nmmc->ocr_avail = 0xffff00;\r\nif (IS_ERR(host->dma_chan_tx) || IS_ERR(host->dma_chan_rx)) {\r\nif (PTR_ERR(host->dma_chan_tx) == -EPROBE_DEFER ||\r\nPTR_ERR(host->dma_chan_rx) == -EPROBE_DEFER) {\r\nret = -EPROBE_DEFER;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "PIO mode transfer enabled\n");\r\nhost->have_dma = false;\r\n} else {\r\ndev_dbg(dev, "DMA channels found (%p,%p)\n",\r\nhost->dma_chan_tx, host->dma_chan_rx);\r\nhost->have_dma = true;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\ncfg.src_addr = 0;\r\ncfg.dst_addr = host->reg_phys + REG_DATA_WINDOW;\r\ndmaengine_slave_config(host->dma_chan_tx, &cfg);\r\ncfg.direction = DMA_DEV_TO_MEM;\r\ncfg.src_addr = host->reg_phys + REG_DATA_WINDOW;\r\ncfg.dst_addr = 0;\r\ndmaengine_slave_config(host->dma_chan_rx, &cfg);\r\n}\r\nswitch ((readl(host->base + REG_BUS_WIDTH) >> 3) & 3) {\r\ncase 1:\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nbreak;\r\ncase 2:\r\nmmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwritel(0, host->base + REG_INTERRUPT_MASK);\r\nwritel(CMD_SDC_RESET, host->base + REG_COMMAND);\r\nfor (i = 0; i < MAX_RETRIES; i++) {\r\nif (!(readl(host->base + REG_COMMAND) & CMD_SDC_RESET))\r\nbreak;\r\nudelay(5);\r\n}\r\nret = devm_request_irq(dev, irq, moxart_irq, 0, "moxart-mmc", host);\r\nif (ret)\r\ngoto out;\r\ndev_set_drvdata(dev, mmc);\r\nmmc_add_host(mmc);\r\ndev_dbg(dev, "IRQ=%d, FIFO is %d bytes\n", irq, host->fifo_width);\r\nreturn 0;\r\nout:\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int moxart_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(&pdev->dev);\r\nstruct moxart_host *host = mmc_priv(mmc);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nif (mmc) {\r\nif (!IS_ERR(host->dma_chan_tx))\r\ndma_release_channel(host->dma_chan_tx);\r\nif (!IS_ERR(host->dma_chan_rx))\r\ndma_release_channel(host->dma_chan_rx);\r\nmmc_remove_host(mmc);\r\nmmc_free_host(mmc);\r\nwritel(0, host->base + REG_INTERRUPT_MASK);\r\nwritel(0, host->base + REG_POWER_CONTROL);\r\nwritel(readl(host->base + REG_CLOCK_CONTROL) | CLK_OFF,\r\nhost->base + REG_CLOCK_CONTROL);\r\n}\r\nreturn 0;\r\n}
