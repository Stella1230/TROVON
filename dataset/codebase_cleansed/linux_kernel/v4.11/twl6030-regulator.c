static inline int\r\ntwlreg_read(struct twlreg_info *info, unsigned slave_subgp, unsigned offset)\r\n{\r\nu8 value;\r\nint status;\r\nstatus = twl_i2c_read_u8(slave_subgp,\r\n&value, info->base + offset);\r\nreturn (status < 0) ? status : value;\r\n}\r\nstatic inline int\r\ntwlreg_write(struct twlreg_info *info, unsigned slave_subgp, unsigned offset,\r\nu8 value)\r\n{\r\nreturn twl_i2c_write_u8(slave_subgp,\r\nvalue, info->base + offset);\r\n}\r\nstatic int twlreg_grp(struct regulator_dev *rdev)\r\n{\r\nreturn twlreg_read(rdev_get_drvdata(rdev), TWL_MODULE_PM_RECEIVER,\r\nVREG_GRP);\r\n}\r\nstatic int twl6030reg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0, val;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS))) {\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\ngrp &= P1_GRP_6030;\r\n} else {\r\ngrp = 1;\r\n}\r\nval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\r\nval = TWL6030_CFG_STATE_APP(val);\r\nreturn grp && (val == TWL6030_CFG_STATE_ON);\r\n}\r\nstatic int twl6030reg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint ret;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\r\ngrp << TWL6030_CFG_STATE_GRP_SHIFT |\r\nTWL6030_CFG_STATE_ON);\r\nreturn ret;\r\n}\r\nstatic int twl6030reg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint ret;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = P1_GRP_6030 | P2_GRP_6030 | P3_GRP_6030;\r\nret = twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE,\r\n(grp) << TWL6030_CFG_STATE_GRP_SHIFT |\r\nTWL6030_CFG_STATE_OFF);\r\nreturn ret;\r\n}\r\nstatic int twl6030reg_get_status(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint val;\r\nval = twlreg_grp(rdev);\r\nif (val < 0)\r\nreturn val;\r\nval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);\r\nswitch (TWL6030_CFG_STATE_APP(val)) {\r\ncase TWL6030_CFG_STATE_ON:\r\nreturn REGULATOR_STATUS_NORMAL;\r\ncase TWL6030_CFG_STATE_SLEEP:\r\nreturn REGULATOR_STATUS_STANDBY;\r\ncase TWL6030_CFG_STATE_OFF:\r\ncase TWL6030_CFG_STATE_OFF2:\r\ndefault:\r\nbreak;\r\n}\r\nreturn REGULATOR_STATUS_OFF;\r\n}\r\nstatic int twl6030reg_set_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint grp = 0;\r\nint val;\r\nif (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))\r\ngrp = twlreg_grp(rdev);\r\nif (grp < 0)\r\nreturn grp;\r\nval = grp << TWL6030_CFG_STATE_GRP_SHIFT;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nval |= TWL6030_CFG_STATE_ON;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval |= TWL6030_CFG_STATE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_STATE, val);\r\n}\r\nstatic int twl6030coresmps_set_voltage(struct regulator_dev *rdev, int min_uV,\r\nint max_uV, unsigned *selector)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int twl6030coresmps_get_voltage(struct regulator_dev *rdev)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int twl6030ldo_list_voltage(struct regulator_dev *rdev, unsigned sel)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nswitch (sel) {\r\ncase 0:\r\nreturn 0;\r\ncase 1 ... 24:\r\nreturn (info->min_mV + 100 * (sel - 1)) * 1000;\r\ncase 25 ... 30:\r\nreturn -EINVAL;\r\ncase 31:\r\nreturn 2750000;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int\r\ntwl6030ldo_set_voltage_sel(struct regulator_dev *rdev, unsigned selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE,\r\nselector);\r\n}\r\nstatic int twl6030ldo_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE);\r\nreturn vsel;\r\n}\r\nstatic int twl6030smps_list_voltage(struct regulator_dev *rdev, unsigned index)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint voltage = 0;\r\nswitch (info->flags) {\r\ncase SMPS_OFFSET_EN:\r\nvoltage = 100000;\r\ncase 0:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 1350 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 1500 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 1800 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 1900 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 2100 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage += (600000 + (12500 * (index - 1)));\r\n}\r\nbreak;\r\ncase SMPS_EXTENDED_EN:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 2084 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 2315 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 2778 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 2932 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 3241 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage = (1852000 + (38600 * (index - 1)));\r\n}\r\nbreak;\r\ncase SMPS_OFFSET_EN | SMPS_EXTENDED_EN:\r\nswitch (index) {\r\ncase 0:\r\nvoltage = 0;\r\nbreak;\r\ncase 58:\r\nvoltage = 4167 * 1000;\r\nbreak;\r\ncase 59:\r\nvoltage = 2315 * 1000;\r\nbreak;\r\ncase 60:\r\nvoltage = 2778 * 1000;\r\nbreak;\r\ncase 61:\r\nvoltage = 2932 * 1000;\r\nbreak;\r\ncase 62:\r\nvoltage = 3241 * 1000;\r\nbreak;\r\ndefault:\r\nvoltage = (2161000 + (38600 * (index - 1)));\r\n}\r\nbreak;\r\n}\r\nreturn voltage;\r\n}\r\nstatic int twl6030smps_map_voltage(struct regulator_dev *rdev, int min_uV,\r\nint max_uV)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nint vsel = 0;\r\nswitch (info->flags) {\r\ncase 0:\r\nif (min_uV == 0)\r\nvsel = 0;\r\nelse if ((min_uV >= 600000) && (min_uV <= 1300000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 600000, 12500);\r\nvsel++;\r\n}\r\nelse if ((min_uV > 1900000) && (min_uV <= 2100000))\r\nvsel = 62;\r\nelse if ((min_uV > 1800000) && (min_uV <= 1900000))\r\nvsel = 61;\r\nelse if ((min_uV > 1500000) && (min_uV <= 1800000))\r\nvsel = 60;\r\nelse if ((min_uV > 1350000) && (min_uV <= 1500000))\r\nvsel = 59;\r\nelse if ((min_uV > 1300000) && (min_uV <= 1350000))\r\nvsel = 58;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SMPS_OFFSET_EN:\r\nif (min_uV == 0)\r\nvsel = 0;\r\nelse if ((min_uV >= 700000) && (min_uV <= 1420000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 700000, 12500);\r\nvsel++;\r\n}\r\nelse if ((min_uV > 1900000) && (min_uV <= 2100000))\r\nvsel = 62;\r\nelse if ((min_uV > 1800000) && (min_uV <= 1900000))\r\nvsel = 61;\r\nelse if ((min_uV > 1500000) && (min_uV <= 1800000))\r\nvsel = 60;\r\nelse if ((min_uV > 1350000) && (min_uV <= 1500000))\r\nvsel = 59;\r\nelse if ((min_uV > 1300000) && (min_uV <= 1350000))\r\nvsel = 58;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SMPS_EXTENDED_EN:\r\nif (min_uV == 0) {\r\nvsel = 0;\r\n} else if ((min_uV >= 1852000) && (max_uV <= 4013600)) {\r\nvsel = DIV_ROUND_UP(min_uV - 1852000, 38600);\r\nvsel++;\r\n}\r\nbreak;\r\ncase SMPS_OFFSET_EN|SMPS_EXTENDED_EN:\r\nif (min_uV == 0) {\r\nvsel = 0;\r\n} else if ((min_uV >= 2161000) && (min_uV <= 4321000)) {\r\nvsel = DIV_ROUND_UP(min_uV - 2161000, 38600);\r\nvsel++;\r\n}\r\nbreak;\r\n}\r\nreturn vsel;\r\n}\r\nstatic int twl6030smps_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS,\r\nselector);\r\n}\r\nstatic int twl6030smps_get_voltage_sel(struct regulator_dev *rdev)\r\n{\r\nstruct twlreg_info *info = rdev_get_drvdata(rdev);\r\nreturn twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_VOLTAGE_SMPS);\r\n}\r\nstatic u8 twl_get_smps_offset(void)\r\n{\r\nu8 value;\r\ntwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\r\nTWL6030_SMPS_OFFSET);\r\nreturn value;\r\n}\r\nstatic u8 twl_get_smps_mult(void)\r\n{\r\nu8 value;\r\ntwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &value,\r\nTWL6030_SMPS_MULT);\r\nreturn value;\r\n}\r\nstatic int twlreg_probe(struct platform_device *pdev)\r\n{\r\nint id;\r\nstruct twlreg_info *info;\r\nconst struct twlreg_info *template;\r\nstruct regulator_init_data *initdata;\r\nstruct regulation_constraints *c;\r\nstruct regulator_dev *rdev;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nmatch = of_match_device(twl_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\ntemplate = match->data;\r\nif (!template)\r\nreturn -ENODEV;\r\nid = template->desc.id;\r\ninitdata = of_get_regulator_init_data(&pdev->dev, pdev->dev.of_node,\r\n&template->desc);\r\nif (!initdata)\r\nreturn -EINVAL;\r\ninfo = devm_kmemdup(&pdev->dev, template, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nc = &initdata->constraints;\r\nc->valid_modes_mask &= REGULATOR_MODE_NORMAL | REGULATOR_MODE_STANDBY;\r\nc->valid_ops_mask &= REGULATOR_CHANGE_VOLTAGE\r\n| REGULATOR_CHANGE_MODE\r\n| REGULATOR_CHANGE_STATUS;\r\nswitch (id) {\r\ncase TWL6032_REG_SMPS3:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS3)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS3)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\ncase TWL6032_REG_SMPS4:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_SMPS4)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_SMPS4)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\ncase TWL6032_REG_VIO:\r\nif (twl_get_smps_mult() & SMPS_MULTOFFSET_VIO)\r\ninfo->flags |= SMPS_EXTENDED_EN;\r\nif (twl_get_smps_offset() & SMPS_MULTOFFSET_VIO)\r\ninfo->flags |= SMPS_OFFSET_EN;\r\nbreak;\r\n}\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = initdata;\r\nconfig.driver_data = info;\r\nconfig.of_node = pdev->dev.of_node;\r\nrdev = devm_regulator_register(&pdev->dev, &info->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "can't register %s, %ld\n",\r\ninfo->desc.name, PTR_ERR(rdev));\r\nreturn PTR_ERR(rdev);\r\n}\r\nplatform_set_drvdata(pdev, rdev);\r\nreturn 0;\r\n}\r\nstatic int __init twlreg_init(void)\r\n{\r\nreturn platform_driver_register(&twlreg_driver);\r\n}\r\nstatic void __exit twlreg_exit(void)\r\n{\r\nplatform_driver_unregister(&twlreg_driver);\r\n}
