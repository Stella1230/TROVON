static inline struct tc_data *aux_to_tc(struct drm_dp_aux *a)\r\n{\r\nreturn container_of(a, struct tc_data, aux);\r\n}\r\nstatic inline struct tc_data *bridge_to_tc(struct drm_bridge *b)\r\n{\r\nreturn container_of(b, struct tc_data, bridge);\r\n}\r\nstatic inline struct tc_data *connector_to_tc(struct drm_connector *c)\r\n{\r\nreturn container_of(c, struct tc_data, connector);\r\n}\r\nstatic inline int tc_poll_timeout(struct regmap *map, unsigned int addr,\r\nunsigned int cond_mask,\r\nunsigned int cond_value,\r\nunsigned long sleep_us, u64 timeout_us)\r\n{\r\nktime_t timeout = ktime_add_us(ktime_get(), timeout_us);\r\nunsigned int val;\r\nint ret;\r\nfor (;;) {\r\nret = regmap_read(map, addr, &val);\r\nif (ret)\r\nbreak;\r\nif ((val & cond_mask) == cond_value)\r\nbreak;\r\nif (timeout_us && ktime_compare(ktime_get(), timeout) > 0) {\r\nret = regmap_read(map, addr, &val);\r\nbreak;\r\n}\r\nif (sleep_us)\r\nusleep_range((sleep_us >> 2) + 1, sleep_us);\r\n}\r\nreturn ret ?: (((val & cond_mask) == cond_value) ? 0 : -ETIMEDOUT);\r\n}\r\nstatic int tc_aux_wait_busy(struct tc_data *tc, unsigned int timeout_ms)\r\n{\r\nreturn tc_poll_timeout(tc->regmap, DP0_AUXSTATUS, AUX_BUSY, 0,\r\n1000, 1000 * timeout_ms);\r\n}\r\nstatic int tc_aux_get_status(struct tc_data *tc, u8 *reply)\r\n{\r\nint ret;\r\nu32 value;\r\nret = regmap_read(tc->regmap, DP0_AUXSTATUS, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nif (value & AUX_BUSY) {\r\nif (value & AUX_TIMEOUT) {\r\ndev_err(tc->dev, "i2c access timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn -EBUSY;\r\n}\r\n*reply = (value & AUX_STATUS_MASK) >> AUX_STATUS_SHIFT;\r\nreturn 0;\r\n}\r\nstatic ssize_t tc_aux_transfer(struct drm_dp_aux *aux,\r\nstruct drm_dp_aux_msg *msg)\r\n{\r\nstruct tc_data *tc = aux_to_tc(aux);\r\nsize_t size = min_t(size_t, 8, msg->size);\r\nu8 request = msg->request & ~DP_AUX_I2C_MOT;\r\nu8 *buf = msg->buffer;\r\nu32 tmp = 0;\r\nint i = 0;\r\nint ret;\r\nif (size == 0)\r\nreturn 0;\r\nret = tc_aux_wait_busy(tc, 100);\r\nif (ret)\r\ngoto err;\r\nif (request == DP_AUX_I2C_WRITE || request == DP_AUX_NATIVE_WRITE) {\r\nwhile (i < size) {\r\nif (request == DP_AUX_NATIVE_WRITE)\r\ntmp = tmp | (buf[i] << (8 * (i & 0x3)));\r\nelse\r\ntmp = (tmp << 8) | buf[i];\r\ni++;\r\nif (((i % 4) == 0) || (i == size)) {\r\ntc_write(DP0_AUXWDATA(i >> 2), tmp);\r\ntmp = 0;\r\n}\r\n}\r\n} else if (request != DP_AUX_I2C_READ &&\r\nrequest != DP_AUX_NATIVE_READ) {\r\nreturn -EINVAL;\r\n}\r\ntc_write(DP0_AUXADDR, msg->address);\r\ntc_write(DP0_AUXCFG0, ((size - 1) << 8) | request);\r\nret = tc_aux_wait_busy(tc, 100);\r\nif (ret)\r\ngoto err;\r\nret = tc_aux_get_status(tc, &msg->reply);\r\nif (ret)\r\ngoto err;\r\nif (request == DP_AUX_I2C_READ || request == DP_AUX_NATIVE_READ) {\r\nwhile (i < size) {\r\nif ((i % 4) == 0)\r\ntc_read(DP0_AUXRDATA(i >> 2), &tmp);\r\nbuf[i] = tmp & 0xff;\r\ntmp = tmp >> 8;\r\ni++;\r\n}\r\n}\r\nreturn size;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic u32 tc_srcctrl(struct tc_data *tc)\r\n{\r\nu32 reg = DP0_SRCCTRL_NOTP | DP0_SRCCTRL_LANESKEW;\r\nif (tc->link.scrambler_dis)\r\nreg |= DP0_SRCCTRL_SCRMBLDIS;\r\nif (tc->link.coding8b10b)\r\nreg |= DP0_SRCCTRL_EN810B;\r\nif (tc->link.spread)\r\nreg |= DP0_SRCCTRL_SSCG;\r\nif (tc->link.base.num_lanes == 2)\r\nreg |= DP0_SRCCTRL_LANES_2;\r\nif (tc->link.base.rate != 162000)\r\nreg |= DP0_SRCCTRL_BW27;\r\nreturn reg;\r\n}\r\nstatic void tc_wait_pll_lock(struct tc_data *tc)\r\n{\r\nusleep_range(3000, 6000);\r\n}\r\nstatic int tc_pxl_pll_en(struct tc_data *tc, u32 refclk, u32 pixelclock)\r\n{\r\nint ret;\r\nint i_pre, best_pre = 1;\r\nint i_post, best_post = 1;\r\nint div, best_div = 1;\r\nint mul, best_mul = 1;\r\nint delta, best_delta;\r\nint ext_div[] = {1, 2, 3, 5, 7};\r\nint best_pixelclock = 0;\r\nint vco_hi = 0;\r\ndev_dbg(tc->dev, "PLL: requested %d pixelclock, ref %d\n", pixelclock,\r\nrefclk);\r\nbest_delta = pixelclock;\r\nfor (i_pre = 0; i_pre < ARRAY_SIZE(ext_div); i_pre++) {\r\nif (refclk / ext_div[i_pre] < 1000000)\r\ncontinue;\r\nfor (i_post = 0; i_post < ARRAY_SIZE(ext_div); i_post++) {\r\nfor (div = 1; div <= 16; div++) {\r\nu32 clk;\r\nu64 tmp;\r\ntmp = pixelclock * ext_div[i_pre] *\r\next_div[i_post] * div;\r\ndo_div(tmp, refclk);\r\nmul = tmp;\r\nif ((mul < 1) || (mul > 128))\r\ncontinue;\r\nclk = (refclk / ext_div[i_pre] / div) * mul;\r\nif ((clk > 650000000) || (clk < 150000000))\r\ncontinue;\r\nclk = clk / ext_div[i_post];\r\ndelta = clk - pixelclock;\r\nif (abs(delta) < abs(best_delta)) {\r\nbest_pre = i_pre;\r\nbest_post = i_post;\r\nbest_div = div;\r\nbest_mul = mul;\r\nbest_delta = delta;\r\nbest_pixelclock = clk;\r\n}\r\n}\r\n}\r\n}\r\nif (best_pixelclock == 0) {\r\ndev_err(tc->dev, "Failed to calc clock for %d pixelclock\n",\r\npixelclock);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(tc->dev, "PLL: got %d, delta %d\n", best_pixelclock,\r\nbest_delta);\r\ndev_dbg(tc->dev, "PLL: %d / %d / %d * %d / %d\n", refclk,\r\next_div[best_pre], best_div, best_mul, ext_div[best_post]);\r\nif (refclk / ext_div[best_pre] / best_div * best_mul >= 300000000)\r\nvco_hi = 1;\r\nif (best_div == 16)\r\nbest_div = 0;\r\nif (best_mul == 128)\r\nbest_mul = 0;\r\ntc_write(PXL_PLLCTRL, PLLBYP | PLLEN);\r\ntc_write(PXL_PLLPARAM,\r\n(vco_hi << 24) |\r\n(ext_div[best_pre] << 20) |\r\n(ext_div[best_post] << 16) |\r\nIN_SEL_REFCLK |\r\n(best_div << 8) |\r\n(best_mul << 0));\r\ntc_write(PXL_PLLCTRL, PLLUPDATE | PLLEN);\r\ntc_wait_pll_lock(tc);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tc_pxl_pll_dis(struct tc_data *tc)\r\n{\r\nreturn regmap_write(tc->regmap, PXL_PLLCTRL, PLLBYP);\r\n}\r\nstatic int tc_stream_clock_calc(struct tc_data *tc)\r\n{\r\nint ret;\r\ntc_write(DP0_VIDMNGEN1, 32768);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tc_aux_link_setup(struct tc_data *tc)\r\n{\r\nunsigned long rate;\r\nu32 value;\r\nint ret;\r\nrate = clk_get_rate(tc->refclk);\r\nswitch (rate) {\r\ncase 38400000:\r\nvalue = REF_FREQ_38M4;\r\nbreak;\r\ncase 26000000:\r\nvalue = REF_FREQ_26M;\r\nbreak;\r\ncase 19200000:\r\nvalue = REF_FREQ_19M2;\r\nbreak;\r\ncase 13000000:\r\nvalue = REF_FREQ_13M;\r\nbreak;\r\ndefault:\r\ndev_err(tc->dev, "Invalid refclk rate: %lu Hz\n", rate);\r\nreturn -EINVAL;\r\n}\r\nvalue |= SYSCLK_SEL_LSCLK | LSCLK_DIV_2;\r\ntc_write(SYS_PLLPARAM, value);\r\ntc_write(DP_PHY_CTRL, BGREN | PWR_SW_EN | BIT(2) | PHY_A0_EN);\r\ntc_write(DP0_PLLCTRL, PLLUPDATE | PLLEN);\r\ntc_wait_pll_lock(tc);\r\ntc_write(DP1_PLLCTRL, PLLUPDATE | PLLEN);\r\ntc_wait_pll_lock(tc);\r\nret = tc_poll_timeout(tc->regmap, DP_PHY_CTRL, PHY_RDY, PHY_RDY, 1,\r\n1000);\r\nif (ret == -ETIMEDOUT) {\r\ndev_err(tc->dev, "Timeout waiting for PHY to become ready");\r\nreturn ret;\r\n} else if (ret)\r\ngoto err;\r\ntc_write(DP0_AUXCFG1, AUX_RX_FILTER_EN |\r\n(0x06 << 8) |\r\n(0x3f << 0));\r\nreturn 0;\r\nerr:\r\ndev_err(tc->dev, "tc_aux_link_setup failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tc_get_display_props(struct tc_data *tc)\r\n{\r\nint ret;\r\nu8 tmp[8];\r\nret = drm_dp_link_probe(&tc->aux, &tc->link.base);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\nif ((tc->link.base.rate != 162000) && (tc->link.base.rate != 270000))\r\ngoto err_dpcd_inval;\r\nret = drm_dp_dpcd_readb(&tc->aux, DP_MAX_DOWNSPREAD, tmp);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\ntc->link.spread = tmp[0] & BIT(0);\r\nret = drm_dp_dpcd_readb(&tc->aux, DP_MAIN_LINK_CHANNEL_CODING, tmp);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\ntc->link.coding8b10b = tmp[0] & BIT(0);\r\ntc->link.scrambler_dis = 0;\r\nret = drm_dp_dpcd_readb(&tc->aux, DP_EDP_CONFIGURATION_SET, tmp);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\ntc->link.assr = tmp[0] & DP_ALTERNATE_SCRAMBLER_RESET_ENABLE;\r\ndev_dbg(tc->dev, "DPCD rev: %d.%d, rate: %s, lanes: %d, framing: %s\n",\r\ntc->link.base.revision >> 4, tc->link.base.revision & 0x0f,\r\n(tc->link.base.rate == 162000) ? "1.62Gbps" : "2.7Gbps",\r\ntc->link.base.num_lanes,\r\n(tc->link.base.capabilities & DP_LINK_CAP_ENHANCED_FRAMING) ?\r\n"enhanced" : "non-enhanced");\r\ndev_dbg(tc->dev, "ANSI 8B/10B: %d\n", tc->link.coding8b10b);\r\ndev_dbg(tc->dev, "Display ASSR: %d, TC358767 ASSR: %d\n",\r\ntc->link.assr, tc->assr);\r\nreturn 0;\r\nerr_dpcd_read:\r\ndev_err(tc->dev, "failed to read DPCD: %d\n", ret);\r\nreturn ret;\r\nerr_dpcd_inval:\r\ndev_err(tc->dev, "invalid DPCD\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int tc_set_video_mode(struct tc_data *tc, struct drm_display_mode *mode)\r\n{\r\nint ret;\r\nint vid_sync_dly;\r\nint max_tu_symbol;\r\nint left_margin = mode->htotal - mode->hsync_end;\r\nint right_margin = mode->hsync_start - mode->hdisplay;\r\nint hsync_len = mode->hsync_end - mode->hsync_start;\r\nint upper_margin = mode->vtotal - mode->vsync_end;\r\nint lower_margin = mode->vsync_start - mode->vdisplay;\r\nint vsync_len = mode->vsync_end - mode->vsync_start;\r\ndev_dbg(tc->dev, "set mode %dx%d\n",\r\nmode->hdisplay, mode->vdisplay);\r\ndev_dbg(tc->dev, "H margin %d,%d sync %d\n",\r\nleft_margin, right_margin, hsync_len);\r\ndev_dbg(tc->dev, "V margin %d,%d sync %d\n",\r\nupper_margin, lower_margin, vsync_len);\r\ndev_dbg(tc->dev, "total: %dx%d\n", mode->htotal, mode->vtotal);\r\ntc_write(VPCTRL0, (0x40 << 20) |\r\nOPXLFMT_RGB888 | FRMSYNC_DISABLED | MSF_DISABLED);\r\ntc_write(HTIM01, (left_margin << 16) |\r\n(hsync_len << 0));\r\ntc_write(HTIM02, (right_margin << 16) |\r\n(mode->hdisplay << 0));\r\ntc_write(VTIM01, (upper_margin << 16) |\r\n(vsync_len << 0));\r\ntc_write(VTIM02, (lower_margin << 16) |\r\n(mode->vdisplay << 0));\r\ntc_write(VFUEN0, VFUEN);\r\ntc_write(TSTCTL,\r\n(120 << 24) |\r\n(20 << 16) |\r\n(99 << 8) |\r\n(1 << 4) |\r\n(2 << 0) |\r\n0);\r\nvid_sync_dly = hsync_len + left_margin + mode->hdisplay;\r\ntc_write(DP0_VIDSYNCDELAY,\r\n(0x003e << 16) |\r\n(vid_sync_dly << 0));\r\ntc_write(DP0_TOTALVAL, (mode->vtotal << 16) | (mode->htotal));\r\ntc_write(DP0_STARTVAL,\r\n((upper_margin + vsync_len) << 16) |\r\n((left_margin + hsync_len) << 0));\r\ntc_write(DP0_ACTIVEVAL, (mode->vdisplay << 16) | (mode->hdisplay));\r\ntc_write(DP0_SYNCVAL, (vsync_len << 16) | (hsync_len << 0));\r\ntc_write(DPIPXLFMT, VS_POL_ACTIVE_LOW | HS_POL_ACTIVE_LOW |\r\nDE_POL_ACTIVE_HIGH | SUB_CFG_TYPE_CONFIG1 | DPI_BPP_RGB888);\r\nmax_tu_symbol = TU_SIZE_RECOMMENDED - 1;\r\ntc_write(DP0_MISC, (max_tu_symbol << 23) | TU_SIZE_RECOMMENDED | BPC_8);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tc_link_training(struct tc_data *tc, int pattern)\r\n{\r\nconst char * const *errors;\r\nu32 srcctrl = tc_srcctrl(tc) | DP0_SRCCTRL_SCRMBLDIS |\r\nDP0_SRCCTRL_AUTOCORRECT;\r\nint timeout;\r\nint retry;\r\nu32 value;\r\nint ret;\r\nif (pattern == DP_TRAINING_PATTERN_1) {\r\nsrcctrl |= DP0_SRCCTRL_TP1;\r\nerrors = training_pattern1_errors;\r\n} else {\r\nsrcctrl |= DP0_SRCCTRL_TP2;\r\nerrors = training_pattern2_errors;\r\n}\r\ntc_write(DP0_SNKLTCTRL, DP_LINK_SCRAMBLING_DISABLE | pattern);\r\ntc_write(DP0_LTLOOPCTRL,\r\n(0x0f << 28) |\r\n(0x0f << 24) |\r\n(0x0d << 0));\r\nretry = 5;\r\ndo {\r\ntc_write(DP0_SRCCTRL, srcctrl);\r\ntc_write(DP0CTL, DP_EN);\r\ntimeout = 1000;\r\ndo {\r\ntc_read(DP0_LTSTAT, &value);\r\nudelay(1);\r\n} while ((!(value & LT_LOOPDONE)) && (--timeout));\r\nif (timeout == 0) {\r\ndev_err(tc->dev, "Link training timeout!\n");\r\n} else {\r\nint pattern = (value >> 11) & 0x3;\r\nint error = (value >> 8) & 0x7;\r\ndev_dbg(tc->dev,\r\n"Link training phase %d done after %d uS: %s\n",\r\npattern, 1000 - timeout, errors[error]);\r\nif (pattern == DP_TRAINING_PATTERN_1 && error == 0)\r\nbreak;\r\nif (pattern == DP_TRAINING_PATTERN_2) {\r\nvalue &= LT_CHANNEL1_EQ_BITS |\r\nLT_INTERLANE_ALIGN_DONE |\r\nLT_CHANNEL0_EQ_BITS;\r\nif ((tc->link.base.num_lanes == 2) &&\r\n(value == (LT_CHANNEL1_EQ_BITS |\r\nLT_INTERLANE_ALIGN_DONE |\r\nLT_CHANNEL0_EQ_BITS)))\r\nbreak;\r\nif ((tc->link.base.num_lanes == 1) &&\r\n(value == (LT_INTERLANE_ALIGN_DONE |\r\nLT_CHANNEL0_EQ_BITS)))\r\nbreak;\r\n}\r\n}\r\ntc_write(DP0CTL, 0);\r\nusleep_range(10, 20);\r\n} while (--retry);\r\nif (retry == 0) {\r\ndev_err(tc->dev, "Failed to finish training phase %d\n",\r\npattern);\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tc_main_link_setup(struct tc_data *tc)\r\n{\r\nstruct drm_dp_aux *aux = &tc->aux;\r\nstruct device *dev = tc->dev;\r\nunsigned int rate;\r\nu32 dp_phy_ctrl;\r\nint timeout;\r\nbool aligned;\r\nbool ready;\r\nu32 value;\r\nint ret;\r\nu8 tmp[8];\r\nif (!tc->mode)\r\nreturn -EINVAL;\r\ntc_write(DP0_SRCCTRL, DP0_SRCCTRL_SCRMBLDIS | DP0_SRCCTRL_EN810B |\r\nDP0_SRCCTRL_LANESKEW | DP0_SRCCTRL_LANES_2 |\r\nDP0_SRCCTRL_BW27 | DP0_SRCCTRL_AUTOCORRECT);\r\ntc_write(0x07a0, 0x00003083);\r\nrate = clk_get_rate(tc->refclk);\r\nswitch (rate) {\r\ncase 38400000:\r\nvalue = REF_FREQ_38M4;\r\nbreak;\r\ncase 26000000:\r\nvalue = REF_FREQ_26M;\r\nbreak;\r\ncase 19200000:\r\nvalue = REF_FREQ_19M2;\r\nbreak;\r\ncase 13000000:\r\nvalue = REF_FREQ_13M;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvalue |= SYSCLK_SEL_LSCLK | LSCLK_DIV_2;\r\ntc_write(SYS_PLLPARAM, value);\r\ndp_phy_ctrl = BGREN | PWR_SW_EN | BIT(2) | PHY_A0_EN | PHY_M0_EN;\r\ntc_write(DP_PHY_CTRL, dp_phy_ctrl);\r\nmsleep(100);\r\ntc_write(DP0_PLLCTRL, PLLUPDATE | PLLEN);\r\ntc_wait_pll_lock(tc);\r\ntc_write(DP1_PLLCTRL, PLLUPDATE | PLLEN);\r\ntc_wait_pll_lock(tc);\r\nif (tc_test_pattern) {\r\nret = tc_pxl_pll_en(tc, clk_get_rate(tc->refclk),\r\n1000 * tc->mode->clock);\r\nif (ret)\r\ngoto err;\r\n}\r\ndp_phy_ctrl |= DP_PHY_RST | PHY_M1_RST | PHY_M0_RST;\r\ntc_write(DP_PHY_CTRL, dp_phy_ctrl);\r\nusleep_range(100, 200);\r\ndp_phy_ctrl &= ~(DP_PHY_RST | PHY_M1_RST | PHY_M0_RST);\r\ntc_write(DP_PHY_CTRL, dp_phy_ctrl);\r\ntimeout = 1000;\r\ndo {\r\ntc_read(DP_PHY_CTRL, &value);\r\nudelay(1);\r\n} while ((!(value & PHY_RDY)) && (--timeout));\r\nif (timeout == 0) {\r\ndev_err(dev, "timeout waiting for phy become ready");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = regmap_update_bits(tc->regmap, DP0_MISC, BPC_8, BPC_8);\r\nif (ret)\r\ngoto err;\r\nif (tc->assr != tc->link.assr) {\r\ndev_dbg(dev, "Trying to set display to ASSR: %d\n",\r\ntc->assr);\r\ntmp[0] = tc->assr;\r\nret = drm_dp_dpcd_writeb(aux, DP_EDP_CONFIGURATION_SET, tmp[0]);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\nret = drm_dp_dpcd_readb(aux, DP_EDP_CONFIGURATION_SET, tmp);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\nif (tmp[0] != tc->assr) {\r\ndev_dbg(dev, "Failed to switch display ASSR to %d, falling back to unscrambled mode\n",\r\ntc->assr);\r\ntc->link.scrambler_dis = 1;\r\n}\r\n}\r\nret = drm_dp_link_configure(aux, &tc->link.base);\r\nif (ret < 0)\r\ngoto err_dpcd_write;\r\ntmp[0] = tc->link.spread ? DP_SPREAD_AMP_0_5 : 0x00;\r\ntmp[1] = tc->link.coding8b10b ? DP_SET_ANSI_8B10B : 0x00;\r\nret = drm_dp_dpcd_write(aux, DP_DOWNSPREAD_CTRL, tmp, 2);\r\nif (ret < 0)\r\ngoto err_dpcd_write;\r\nret = tc_link_training(tc, DP_TRAINING_PATTERN_1);\r\nif (ret)\r\ngoto err;\r\nret = tc_link_training(tc, DP_TRAINING_PATTERN_2);\r\nif (ret)\r\ngoto err;\r\ntmp[0] = tc->link.scrambler_dis ? DP_LINK_SCRAMBLING_DISABLE : 0x00;\r\nret = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET, tmp[0]);\r\nif (ret < 0)\r\ngoto err_dpcd_write;\r\ntc_write(DP0_SRCCTRL, tc_srcctrl(tc) | DP0_SRCCTRL_AUTOCORRECT);\r\ntimeout = 100;\r\ndo {\r\nudelay(1);\r\nret = drm_dp_dpcd_read_link_status(aux, tmp + 2);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\nready = (tmp[2] == ((DP_CHANNEL_EQ_BITS << 4) |\r\nDP_CHANNEL_EQ_BITS));\r\naligned = tmp[4] & DP_INTERLANE_ALIGN_DONE;\r\n} while ((--timeout) && !(ready && aligned));\r\nif (timeout == 0) {\r\nret = drm_dp_dpcd_read(aux, DP_SINK_COUNT, tmp, 2);\r\nif (ret < 0)\r\ngoto err_dpcd_read;\r\ndev_info(dev, "0x0200 SINK_COUNT: 0x%02x\n", tmp[0]);\r\ndev_info(dev, "0x0201 DEVICE_SERVICE_IRQ_VECTOR: 0x%02x\n",\r\ntmp[1]);\r\ndev_info(dev, "0x0202 LANE0_1_STATUS: 0x%02x\n", tmp[2]);\r\ndev_info(dev, "0x0204 LANE_ALIGN_STATUS_UPDATED: 0x%02x\n",\r\ntmp[4]);\r\ndev_info(dev, "0x0205 SINK_STATUS: 0x%02x\n", tmp[5]);\r\ndev_info(dev, "0x0206 ADJUST_REQUEST_LANE0_1: 0x%02x\n",\r\ntmp[6]);\r\nif (!ready)\r\ndev_err(dev, "Lane0/1 not ready\n");\r\nif (!aligned)\r\ndev_err(dev, "Lane0/1 not aligned\n");\r\nreturn -EAGAIN;\r\n}\r\nret = tc_set_video_mode(tc, tc->mode);\r\nif (ret)\r\ngoto err;\r\nret = tc_stream_clock_calc(tc);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr_dpcd_read:\r\ndev_err(tc->dev, "Failed to read DPCD: %d\n", ret);\r\nreturn ret;\r\nerr_dpcd_write:\r\ndev_err(tc->dev, "Failed to write DPCD: %d\n", ret);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int tc_main_link_stream(struct tc_data *tc, int state)\r\n{\r\nint ret;\r\nu32 value;\r\ndev_dbg(tc->dev, "stream: %d\n", state);\r\nif (state) {\r\nvalue = VID_MN_GEN | DP_EN;\r\nif (tc->link.base.capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\r\nvalue |= EF_EN;\r\ntc_write(DP0CTL, value);\r\nusleep_range(500, 1000);\r\nvalue |= VID_EN;\r\ntc_write(DP0CTL, value);\r\nvalue = DP0_AUDSRC_NO_INPUT;\r\nif (tc_test_pattern)\r\nvalue |= DP0_VIDSRC_COLOR_BAR;\r\nelse\r\nvalue |= DP0_VIDSRC_DPI_RX;\r\ntc_write(SYSCTRL, value);\r\n} else {\r\ntc_write(DP0CTL, 0);\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void tc_bridge_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\ndrm_panel_prepare(tc->panel);\r\n}\r\nstatic void tc_bridge_enable(struct drm_bridge *bridge)\r\n{\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\nint ret;\r\nret = tc_main_link_setup(tc);\r\nif (ret < 0) {\r\ndev_err(tc->dev, "main link setup error: %d\n", ret);\r\nreturn;\r\n}\r\nret = tc_main_link_stream(tc, 1);\r\nif (ret < 0) {\r\ndev_err(tc->dev, "main link stream start error: %d\n", ret);\r\nreturn;\r\n}\r\ndrm_panel_enable(tc->panel);\r\n}\r\nstatic void tc_bridge_disable(struct drm_bridge *bridge)\r\n{\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\nint ret;\r\ndrm_panel_disable(tc->panel);\r\nret = tc_main_link_stream(tc, 0);\r\nif (ret < 0)\r\ndev_err(tc->dev, "main link stream stop error: %d\n", ret);\r\n}\r\nstatic void tc_bridge_post_disable(struct drm_bridge *bridge)\r\n{\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\ndrm_panel_unprepare(tc->panel);\r\n}\r\nstatic bool tc_bridge_mode_fixup(struct drm_bridge *bridge,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adj)\r\n{\r\nadj->flags = mode->flags;\r\nadj->flags |= (DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC);\r\nadj->flags &= ~(DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\r\nreturn true;\r\n}\r\nstatic int tc_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void tc_bridge_mode_set(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj)\r\n{\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\ntc->mode = mode;\r\n}\r\nstatic int tc_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tc_data *tc = connector_to_tc(connector);\r\nstruct edid *edid;\r\nunsigned int count;\r\nif (tc->panel && tc->panel->funcs && tc->panel->funcs->get_modes) {\r\ncount = tc->panel->funcs->get_modes(tc->panel);\r\nif (count > 0)\r\nreturn count;\r\n}\r\nedid = drm_get_edid(connector, &tc->aux.ddc);\r\nkfree(tc->edid);\r\ntc->edid = edid;\r\nif (!edid)\r\nreturn 0;\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ncount = drm_add_edid_modes(connector, edid);\r\nreturn count;\r\n}\r\nstatic void tc_connector_set_polling(struct tc_data *tc,\r\nstruct drm_connector *connector)\r\n{\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\n}\r\nstatic struct drm_encoder *\r\ntc_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct tc_data *tc = connector_to_tc(connector);\r\nreturn tc->bridge.encoder;\r\n}\r\nstatic int tc_bridge_attach(struct drm_bridge *bridge)\r\n{\r\nu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nstruct tc_data *tc = bridge_to_tc(bridge);\r\nstruct drm_device *drm = bridge->dev;\r\nint ret;\r\ndrm_connector_helper_add(&tc->connector, &tc_connector_helper_funcs);\r\nret = drm_connector_init(drm, &tc->connector, &tc_connector_funcs,\r\nDRM_MODE_CONNECTOR_eDP);\r\nif (ret)\r\nreturn ret;\r\nif (tc->panel)\r\ndrm_panel_attach(tc->panel, &tc->connector);\r\ndrm_display_info_set_bus_formats(&tc->connector.display_info,\r\n&bus_format, 1);\r\ndrm_mode_connector_attach_encoder(&tc->connector, tc->bridge.encoder);\r\nreturn 0;\r\n}\r\nstatic bool tc_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg != SYSCTRL;\r\n}\r\nstatic bool tc_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn (reg != TC_IDREG) &&\r\n(reg != DP0_LTSTAT) &&\r\n(reg != DP0_SNKLTCHGREQ);\r\n}\r\nstatic int tc_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device_node *ep;\r\nstruct tc_data *tc;\r\nint ret;\r\ntc = devm_kzalloc(dev, sizeof(*tc), GFP_KERNEL);\r\nif (!tc)\r\nreturn -ENOMEM;\r\ntc->dev = dev;\r\nep = of_graph_get_endpoint_by_regs(dev->of_node, 2, -1);\r\nif (ep) {\r\nstruct device_node *remote;\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote) {\r\ndev_warn(dev, "endpoint %s not connected\n",\r\nep->full_name);\r\nof_node_put(ep);\r\nreturn -ENODEV;\r\n}\r\nof_node_put(ep);\r\ntc->panel = of_drm_find_panel(remote);\r\nif (tc->panel) {\r\ndev_dbg(dev, "found panel %s\n", remote->full_name);\r\n} else {\r\ndev_dbg(dev, "waiting for panel %s\n",\r\nremote->full_name);\r\nof_node_put(remote);\r\nreturn -EPROBE_DEFER;\r\n}\r\nof_node_put(remote);\r\n}\r\ntc->sd_gpio = devm_gpiod_get_optional(dev, "shutdown", GPIOD_OUT_HIGH);\r\nif (IS_ERR(tc->sd_gpio))\r\nreturn PTR_ERR(tc->sd_gpio);\r\nif (tc->sd_gpio) {\r\ngpiod_set_value_cansleep(tc->sd_gpio, 0);\r\nusleep_range(5000, 10000);\r\n}\r\ntc->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(tc->reset_gpio))\r\nreturn PTR_ERR(tc->reset_gpio);\r\nif (tc->reset_gpio) {\r\ngpiod_set_value_cansleep(tc->reset_gpio, 1);\r\nusleep_range(5000, 10000);\r\n}\r\ntc->refclk = devm_clk_get(dev, "ref");\r\nif (IS_ERR(tc->refclk)) {\r\nret = PTR_ERR(tc->refclk);\r\ndev_err(dev, "Failed to get refclk: %d\n", ret);\r\nreturn ret;\r\n}\r\ntc->regmap = devm_regmap_init_i2c(client, &tc_regmap_config);\r\nif (IS_ERR(tc->regmap)) {\r\nret = PTR_ERR(tc->regmap);\r\ndev_err(dev, "Failed to initialize regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(tc->regmap, TC_IDREG, &tc->rev);\r\nif (ret) {\r\ndev_err(tc->dev, "can not read device ID: %d\n", ret);\r\nreturn ret;\r\n}\r\nif ((tc->rev != 0x6601) && (tc->rev != 0x6603)) {\r\ndev_err(tc->dev, "invalid device ID: 0x%08x\n", tc->rev);\r\nreturn -EINVAL;\r\n}\r\ntc->assr = (tc->rev == 0x6601);\r\nret = tc_aux_link_setup(tc);\r\nif (ret)\r\nreturn ret;\r\ntc->aux.name = "TC358767 AUX i2c adapter";\r\ntc->aux.dev = tc->dev;\r\ntc->aux.transfer = tc_aux_transfer;\r\nret = drm_dp_aux_register(&tc->aux);\r\nif (ret)\r\nreturn ret;\r\nret = tc_get_display_props(tc);\r\nif (ret)\r\ngoto err_unregister_aux;\r\ntc_connector_set_polling(tc, &tc->connector);\r\ntc->bridge.funcs = &tc_bridge_funcs;\r\ntc->bridge.of_node = dev->of_node;\r\nret = drm_bridge_add(&tc->bridge);\r\nif (ret) {\r\ndev_err(dev, "Failed to add drm_bridge: %d\n", ret);\r\ngoto err_unregister_aux;\r\n}\r\ni2c_set_clientdata(client, tc);\r\nreturn 0;\r\nerr_unregister_aux:\r\ndrm_dp_aux_unregister(&tc->aux);\r\nreturn ret;\r\n}\r\nstatic int tc_remove(struct i2c_client *client)\r\n{\r\nstruct tc_data *tc = i2c_get_clientdata(client);\r\ndrm_bridge_remove(&tc->bridge);\r\ndrm_dp_aux_unregister(&tc->aux);\r\ntc_pxl_pll_dis(tc);\r\nreturn 0;\r\n}
