static inline int is_double_byte_mode(struct fsl_dspi *dspi)\r\n{\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_CTAR(0), &val);\r\nreturn ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;\r\n}\r\nstatic void dspi_tx_dma_callback(void *arg)\r\n{\r\nstruct fsl_dspi *dspi = arg;\r\nstruct fsl_dspi_dma *dma = dspi->dma;\r\ncomplete(&dma->cmd_tx_complete);\r\n}\r\nstatic void dspi_rx_dma_callback(void *arg)\r\n{\r\nstruct fsl_dspi *dspi = arg;\r\nstruct fsl_dspi_dma *dma = dspi->dma;\r\nint rx_word;\r\nint i;\r\nu16 d;\r\nrx_word = is_double_byte_mode(dspi);\r\nif (!(dspi->dataflags & TRAN_STATE_RX_VOID)) {\r\nfor (i = 0; i < dma->curr_xfer_len; i++) {\r\nd = dspi->dma->rx_dma_buf[i];\r\nrx_word ? (*(u16 *)dspi->rx = d) :\r\n(*(u8 *)dspi->rx = d);\r\ndspi->rx += rx_word + 1;\r\n}\r\n}\r\ncomplete(&dma->cmd_rx_complete);\r\n}\r\nstatic int dspi_next_xfer_dma_submit(struct fsl_dspi *dspi)\r\n{\r\nstruct fsl_dspi_dma *dma = dspi->dma;\r\nstruct device *dev = &dspi->pdev->dev;\r\nint time_left;\r\nint tx_word;\r\nint i;\r\ntx_word = is_double_byte_mode(dspi);\r\nfor (i = 0; i < dma->curr_xfer_len; i++) {\r\ndspi->dma->tx_dma_buf[i] = dspi_data_to_pushr(dspi, tx_word);\r\nif ((dspi->cs_change) && (!dspi->len))\r\ndspi->dma->tx_dma_buf[i] &= ~SPI_PUSHR_CONT;\r\n}\r\ndma->tx_desc = dmaengine_prep_slave_single(dma->chan_tx,\r\ndma->tx_dma_phys,\r\ndma->curr_xfer_len *\r\nDMA_SLAVE_BUSWIDTH_4_BYTES,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma->tx_desc) {\r\ndev_err(dev, "Not able to get desc for DMA xfer\n");\r\nreturn -EIO;\r\n}\r\ndma->tx_desc->callback = dspi_tx_dma_callback;\r\ndma->tx_desc->callback_param = dspi;\r\nif (dma_submit_error(dmaengine_submit(dma->tx_desc))) {\r\ndev_err(dev, "DMA submit failed\n");\r\nreturn -EINVAL;\r\n}\r\ndma->rx_desc = dmaengine_prep_slave_single(dma->chan_rx,\r\ndma->rx_dma_phys,\r\ndma->curr_xfer_len *\r\nDMA_SLAVE_BUSWIDTH_4_BYTES,\r\nDMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma->rx_desc) {\r\ndev_err(dev, "Not able to get desc for DMA xfer\n");\r\nreturn -EIO;\r\n}\r\ndma->rx_desc->callback = dspi_rx_dma_callback;\r\ndma->rx_desc->callback_param = dspi;\r\nif (dma_submit_error(dmaengine_submit(dma->rx_desc))) {\r\ndev_err(dev, "DMA submit failed\n");\r\nreturn -EINVAL;\r\n}\r\nreinit_completion(&dspi->dma->cmd_rx_complete);\r\nreinit_completion(&dspi->dma->cmd_tx_complete);\r\ndma_async_issue_pending(dma->chan_rx);\r\ndma_async_issue_pending(dma->chan_tx);\r\ntime_left = wait_for_completion_timeout(&dspi->dma->cmd_tx_complete,\r\nDMA_COMPLETION_TIMEOUT);\r\nif (time_left == 0) {\r\ndev_err(dev, "DMA tx timeout\n");\r\ndmaengine_terminate_all(dma->chan_tx);\r\ndmaengine_terminate_all(dma->chan_rx);\r\nreturn -ETIMEDOUT;\r\n}\r\ntime_left = wait_for_completion_timeout(&dspi->dma->cmd_rx_complete,\r\nDMA_COMPLETION_TIMEOUT);\r\nif (time_left == 0) {\r\ndev_err(dev, "DMA rx timeout\n");\r\ndmaengine_terminate_all(dma->chan_tx);\r\ndmaengine_terminate_all(dma->chan_rx);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dspi_dma_xfer(struct fsl_dspi *dspi)\r\n{\r\nstruct fsl_dspi_dma *dma = dspi->dma;\r\nstruct device *dev = &dspi->pdev->dev;\r\nint curr_remaining_bytes;\r\nint bytes_per_buffer;\r\nint word = 1;\r\nint ret = 0;\r\nif (is_double_byte_mode(dspi))\r\nword = 2;\r\ncurr_remaining_bytes = dspi->len;\r\nbytes_per_buffer = DSPI_DMA_BUFSIZE / DSPI_FIFO_SIZE;\r\nwhile (curr_remaining_bytes) {\r\ndma->curr_xfer_len = curr_remaining_bytes / word;\r\nif (dma->curr_xfer_len > bytes_per_buffer)\r\ndma->curr_xfer_len = bytes_per_buffer;\r\nret = dspi_next_xfer_dma_submit(dspi);\r\nif (ret) {\r\ndev_err(dev, "DMA transfer failed\n");\r\ngoto exit;\r\n} else {\r\ncurr_remaining_bytes -= dma->curr_xfer_len * word;\r\nif (curr_remaining_bytes < 0)\r\ncurr_remaining_bytes = 0;\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int dspi_request_dma(struct fsl_dspi *dspi, phys_addr_t phy_addr)\r\n{\r\nstruct fsl_dspi_dma *dma;\r\nstruct dma_slave_config cfg;\r\nstruct device *dev = &dspi->pdev->dev;\r\nint ret;\r\ndma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\r\nif (!dma)\r\nreturn -ENOMEM;\r\ndma->chan_rx = dma_request_slave_channel(dev, "rx");\r\nif (!dma->chan_rx) {\r\ndev_err(dev, "rx dma channel not available\n");\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\ndma->chan_tx = dma_request_slave_channel(dev, "tx");\r\nif (!dma->chan_tx) {\r\ndev_err(dev, "tx dma channel not available\n");\r\nret = -ENODEV;\r\ngoto err_tx_channel;\r\n}\r\ndma->tx_dma_buf = dma_alloc_coherent(dev, DSPI_DMA_BUFSIZE,\r\n&dma->tx_dma_phys, GFP_KERNEL);\r\nif (!dma->tx_dma_buf) {\r\nret = -ENOMEM;\r\ngoto err_tx_dma_buf;\r\n}\r\ndma->rx_dma_buf = dma_alloc_coherent(dev, DSPI_DMA_BUFSIZE,\r\n&dma->rx_dma_phys, GFP_KERNEL);\r\nif (!dma->rx_dma_buf) {\r\nret = -ENOMEM;\r\ngoto err_rx_dma_buf;\r\n}\r\ncfg.src_addr = phy_addr + SPI_POPR;\r\ncfg.dst_addr = phy_addr + SPI_PUSHR;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.src_maxburst = 1;\r\ncfg.dst_maxburst = 1;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\nret = dmaengine_slave_config(dma->chan_rx, &cfg);\r\nif (ret) {\r\ndev_err(dev, "can't configure rx dma channel\n");\r\nret = -EINVAL;\r\ngoto err_slave_config;\r\n}\r\ncfg.direction = DMA_MEM_TO_DEV;\r\nret = dmaengine_slave_config(dma->chan_tx, &cfg);\r\nif (ret) {\r\ndev_err(dev, "can't configure tx dma channel\n");\r\nret = -EINVAL;\r\ngoto err_slave_config;\r\n}\r\ndspi->dma = dma;\r\ninit_completion(&dma->cmd_tx_complete);\r\ninit_completion(&dma->cmd_rx_complete);\r\nreturn 0;\r\nerr_slave_config:\r\ndma_free_coherent(dev, DSPI_DMA_BUFSIZE,\r\ndma->rx_dma_buf, dma->rx_dma_phys);\r\nerr_rx_dma_buf:\r\ndma_free_coherent(dev, DSPI_DMA_BUFSIZE,\r\ndma->tx_dma_buf, dma->tx_dma_phys);\r\nerr_tx_dma_buf:\r\ndma_release_channel(dma->chan_tx);\r\nerr_tx_channel:\r\ndma_release_channel(dma->chan_rx);\r\ndevm_kfree(dev, dma);\r\ndspi->dma = NULL;\r\nreturn ret;\r\n}\r\nstatic void dspi_release_dma(struct fsl_dspi *dspi)\r\n{\r\nstruct fsl_dspi_dma *dma = dspi->dma;\r\nstruct device *dev = &dspi->pdev->dev;\r\nif (dma) {\r\nif (dma->chan_tx) {\r\ndma_unmap_single(dev, dma->tx_dma_phys,\r\nDSPI_DMA_BUFSIZE, DMA_TO_DEVICE);\r\ndma_release_channel(dma->chan_tx);\r\n}\r\nif (dma->chan_rx) {\r\ndma_unmap_single(dev, dma->rx_dma_phys,\r\nDSPI_DMA_BUFSIZE, DMA_FROM_DEVICE);\r\ndma_release_channel(dma->chan_rx);\r\n}\r\n}\r\n}\r\nstatic void hz_to_spi_baud(char *pbr, char *br, int speed_hz,\r\nunsigned long clkrate)\r\n{\r\nint pbr_tbl[4] = {2, 3, 5, 7};\r\nint brs[16] = { 2, 4, 6, 8,\r\n16, 32, 64, 128,\r\n256, 512, 1024, 2048,\r\n4096, 8192, 16384, 32768 };\r\nint scale_needed, scale, minscale = INT_MAX;\r\nint i, j;\r\nscale_needed = clkrate / speed_hz;\r\nif (clkrate % speed_hz)\r\nscale_needed++;\r\nfor (i = 0; i < ARRAY_SIZE(brs); i++)\r\nfor (j = 0; j < ARRAY_SIZE(pbr_tbl); j++) {\r\nscale = brs[i] * pbr_tbl[j];\r\nif (scale >= scale_needed) {\r\nif (scale < minscale) {\r\nminscale = scale;\r\n*br = i;\r\n*pbr = j;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (minscale == INT_MAX) {\r\npr_warn("Can not find valid baud rate,speed_hz is %d,clkrate is %ld, we use the max prescaler value.\n",\r\nspeed_hz, clkrate);\r\n*pbr = ARRAY_SIZE(pbr_tbl) - 1;\r\n*br = ARRAY_SIZE(brs) - 1;\r\n}\r\n}\r\nstatic void ns_delay_scale(char *psc, char *sc, int delay_ns,\r\nunsigned long clkrate)\r\n{\r\nint pscale_tbl[4] = {1, 3, 5, 7};\r\nint scale_needed, scale, minscale = INT_MAX;\r\nint i, j;\r\nu32 remainder;\r\nscale_needed = div_u64_rem((u64)delay_ns * clkrate, NSEC_PER_SEC,\r\n&remainder);\r\nif (remainder)\r\nscale_needed++;\r\nfor (i = 0; i < ARRAY_SIZE(pscale_tbl); i++)\r\nfor (j = 0; j <= SPI_CTAR_SCALE_BITS; j++) {\r\nscale = pscale_tbl[i] * (2 << j);\r\nif (scale >= scale_needed) {\r\nif (scale < minscale) {\r\nminscale = scale;\r\n*psc = i;\r\n*sc = j;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (minscale == INT_MAX) {\r\npr_warn("Cannot find correct scale values for %dns delay at clkrate %ld, using max prescaler value",\r\ndelay_ns, clkrate);\r\n*psc = ARRAY_SIZE(pscale_tbl) - 1;\r\n*sc = SPI_CTAR_SCALE_BITS;\r\n}\r\n}\r\nstatic u32 dspi_data_to_pushr(struct fsl_dspi *dspi, int tx_word)\r\n{\r\nu16 d16;\r\nif (!(dspi->dataflags & TRAN_STATE_TX_VOID))\r\nd16 = tx_word ? *(u16 *)dspi->tx : *(u8 *)dspi->tx;\r\nelse\r\nd16 = dspi->void_write_data;\r\ndspi->tx += tx_word + 1;\r\ndspi->len -= tx_word + 1;\r\nreturn SPI_PUSHR_TXDATA(d16) |\r\nSPI_PUSHR_PCS(dspi->cs) |\r\nSPI_PUSHR_CTAS(0) |\r\nSPI_PUSHR_CONT;\r\n}\r\nstatic void dspi_data_from_popr(struct fsl_dspi *dspi, int rx_word)\r\n{\r\nu16 d;\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_POPR, &val);\r\nd = SPI_POPR_RXDATA(val);\r\nif (!(dspi->dataflags & TRAN_STATE_RX_VOID))\r\nrx_word ? (*(u16 *)dspi->rx = d) : (*(u8 *)dspi->rx = d);\r\ndspi->rx += rx_word + 1;\r\n}\r\nstatic int dspi_eoq_write(struct fsl_dspi *dspi)\r\n{\r\nint tx_count = 0;\r\nint tx_word;\r\nu32 dspi_pushr = 0;\r\ntx_word = is_double_byte_mode(dspi);\r\nwhile (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {\r\nif (tx_word && (dspi->len == 1)) {\r\ndspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));\r\ntx_word = 0;\r\n}\r\ndspi_pushr = dspi_data_to_pushr(dspi, tx_word);\r\nif (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\nif ((dspi->cs_change) && (!dspi->len))\r\ndspi_pushr &= ~SPI_PUSHR_CONT;\r\n} else if (tx_word && (dspi->len == 1))\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\nregmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);\r\ntx_count++;\r\n}\r\nreturn tx_count * (tx_word + 1);\r\n}\r\nstatic int dspi_eoq_read(struct fsl_dspi *dspi)\r\n{\r\nint rx_count = 0;\r\nint rx_word = is_double_byte_mode(dspi);\r\nwhile ((dspi->rx < dspi->rx_end)\r\n&& (rx_count < DSPI_FIFO_SIZE)) {\r\nif (rx_word && (dspi->rx_end - dspi->rx) == 1)\r\nrx_word = 0;\r\ndspi_data_from_popr(dspi, rx_word);\r\nrx_count++;\r\n}\r\nreturn rx_count;\r\n}\r\nstatic int dspi_tcfq_write(struct fsl_dspi *dspi)\r\n{\r\nint tx_word;\r\nu32 dspi_pushr = 0;\r\ntx_word = is_double_byte_mode(dspi);\r\nif (tx_word && (dspi->len == 1)) {\r\ndspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));\r\ntx_word = 0;\r\n}\r\ndspi_pushr = dspi_data_to_pushr(dspi, tx_word);\r\nif ((dspi->cs_change) && (!dspi->len))\r\ndspi_pushr &= ~SPI_PUSHR_CONT;\r\nregmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);\r\nreturn tx_word + 1;\r\n}\r\nstatic void dspi_tcfq_read(struct fsl_dspi *dspi)\r\n{\r\nint rx_word = is_double_byte_mode(dspi);\r\nif (rx_word && (dspi->rx_end - dspi->rx) == 1)\r\nrx_word = 0;\r\ndspi_data_from_popr(dspi, rx_word);\r\n}\r\nstatic int dspi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *message)\r\n{\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = message->spi;\r\nstruct spi_transfer *transfer;\r\nint status = 0;\r\nenum dspi_trans_mode trans_mode;\r\nu32 spi_tcr;\r\nregmap_read(dspi->regmap, SPI_TCR, &spi_tcr);\r\ndspi->spi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);\r\nmessage->actual_length = 0;\r\nlist_for_each_entry(transfer, &message->transfers, transfer_list) {\r\ndspi->cur_transfer = transfer;\r\ndspi->cur_msg = message;\r\ndspi->cur_chip = spi_get_ctldata(spi);\r\ndspi->cs = spi->chip_select;\r\ndspi->cs_change = 0;\r\nif (list_is_last(&dspi->cur_transfer->transfer_list,\r\n&dspi->cur_msg->transfers) || transfer->cs_change)\r\ndspi->cs_change = 1;\r\ndspi->void_write_data = dspi->cur_chip->void_write_data;\r\ndspi->dataflags = 0;\r\ndspi->tx = (void *)transfer->tx_buf;\r\ndspi->tx_end = dspi->tx + transfer->len;\r\ndspi->rx = transfer->rx_buf;\r\ndspi->rx_end = dspi->rx + transfer->len;\r\ndspi->len = transfer->len;\r\nif (!dspi->rx)\r\ndspi->dataflags |= TRAN_STATE_RX_VOID;\r\nif (!dspi->tx)\r\ndspi->dataflags |= TRAN_STATE_TX_VOID;\r\nregmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);\r\nregmap_update_bits(dspi->regmap, SPI_MCR,\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);\r\nregmap_write(dspi->regmap, SPI_CTAR(0),\r\ndspi->cur_chip->ctar_val);\r\ntrans_mode = dspi->devtype_data->trans_mode;\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\nregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);\r\ndspi_eoq_write(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\nregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_TCFQE);\r\ndspi_tcfq_write(dspi);\r\nbreak;\r\ncase DSPI_DMA_MODE:\r\nregmap_write(dspi->regmap, SPI_RSER,\r\nSPI_RSER_TFFFE | SPI_RSER_TFFFD |\r\nSPI_RSER_RFDFE | SPI_RSER_RFDFD);\r\nstatus = dspi_dma_xfer(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",\r\ntrans_mode);\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nif (trans_mode != DSPI_DMA_MODE) {\r\nif (wait_event_interruptible(dspi->waitq,\r\ndspi->waitflags))\r\ndev_err(&dspi->pdev->dev,\r\n"wait transfer complete fail!\n");\r\ndspi->waitflags = 0;\r\n}\r\nif (transfer->delay_usecs)\r\nudelay(transfer->delay_usecs);\r\n}\r\nout:\r\nmessage->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int dspi_setup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip;\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(spi->master);\r\nu32 cs_sck_delay = 0, sck_cs_delay = 0;\r\nunsigned char br = 0, pbr = 0, pcssck = 0, cssck = 0;\r\nunsigned char pasc = 0, asc = 0, fmsz = 0;\r\nunsigned long clkrate;\r\nif ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {\r\nfmsz = spi->bits_per_word - 1;\r\n} else {\r\npr_err("Invalid wordsize\n");\r\nreturn -ENODEV;\r\n}\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\n}\r\nof_property_read_u32(spi->dev.of_node, "fsl,spi-cs-sck-delay",\r\n&cs_sck_delay);\r\nof_property_read_u32(spi->dev.of_node, "fsl,spi-sck-cs-delay",\r\n&sck_cs_delay);\r\nchip->mcr_val = SPI_MCR_MASTER | SPI_MCR_PCSIS |\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF;\r\nchip->void_write_data = 0;\r\nclkrate = clk_get_rate(dspi->clk);\r\nhz_to_spi_baud(&pbr, &br, spi->max_speed_hz, clkrate);\r\nns_delay_scale(&pcssck, &cssck, cs_sck_delay, clkrate);\r\nns_delay_scale(&pasc, &asc, sck_cs_delay, clkrate);\r\nchip->ctar_val = SPI_CTAR_FMSZ(fmsz)\r\n| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)\r\n| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)\r\n| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)\r\n| SPI_CTAR_PCSSCK(pcssck)\r\n| SPI_CTAR_CSSCK(cssck)\r\n| SPI_CTAR_PASC(pasc)\r\n| SPI_CTAR_ASC(asc)\r\n| SPI_CTAR_PBR(pbr)\r\n| SPI_CTAR_BR(br);\r\nspi_set_ctldata(spi, chip);\r\nreturn 0;\r\n}\r\nstatic void dspi_cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata((struct spi_device *)spi);\r\ndev_dbg(&spi->dev, "spi_device %u.%u cleanup\n",\r\nspi->master->bus_num, spi->chip_select);\r\nkfree(chip);\r\n}\r\nstatic irqreturn_t dspi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fsl_dspi *dspi = (struct fsl_dspi *)dev_id;\r\nstruct spi_message *msg = dspi->cur_msg;\r\nenum dspi_trans_mode trans_mode;\r\nu32 spi_sr, spi_tcr;\r\nu32 spi_tcnt, tcnt_diff;\r\nint tx_word;\r\nregmap_read(dspi->regmap, SPI_SR, &spi_sr);\r\nregmap_write(dspi->regmap, SPI_SR, spi_sr);\r\nif (spi_sr & (SPI_SR_EOQF | SPI_SR_TCFQF)) {\r\ntx_word = is_double_byte_mode(dspi);\r\nregmap_read(dspi->regmap, SPI_TCR, &spi_tcr);\r\nspi_tcnt = SPI_TCR_GET_TCNT(spi_tcr);\r\ntcnt_diff = ((spi_tcnt + SPI_TCR_TCNT_MAX) - dspi->spi_tcnt)\r\n% SPI_TCR_TCNT_MAX;\r\ntcnt_diff *= (tx_word + 1);\r\nif (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)\r\ntcnt_diff--;\r\nmsg->actual_length += tcnt_diff;\r\ndspi->spi_tcnt = spi_tcnt;\r\ntrans_mode = dspi->devtype_data->trans_mode;\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\ndspi_eoq_read(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\ndspi_tcfq_read(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev, "unsupported trans_mode %u\n",\r\ntrans_mode);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!dspi->len) {\r\nif (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM) {\r\nregmap_update_bits(dspi->regmap,\r\nSPI_CTAR(0),\r\nSPI_FRAME_BITS_MASK,\r\nSPI_FRAME_BITS(16));\r\ndspi->dataflags &= ~TRAN_STATE_WORD_ODD_NUM;\r\n}\r\ndspi->waitflags = 1;\r\nwake_up_interruptible(&dspi->waitq);\r\n} else {\r\nswitch (trans_mode) {\r\ncase DSPI_EOQ_MODE:\r\ndspi_eoq_write(dspi);\r\nbreak;\r\ncase DSPI_TCFQ_MODE:\r\ndspi_tcfq_write(dspi);\r\nbreak;\r\ndefault:\r\ndev_err(&dspi->pdev->dev,\r\n"unsupported trans_mode %u\n",\r\ntrans_mode);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dspi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable_unprepare(dspi->clk);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int dspi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nint ret;\r\npinctrl_pm_select_default_state(dev);\r\nret = clk_prepare_enable(dspi->clk);\r\nif (ret)\r\nreturn ret;\r\nspi_master_resume(master);\r\nreturn 0;\r\n}\r\nstatic void dspi_init(struct fsl_dspi *dspi)\r\n{\r\nregmap_write(dspi->regmap, SPI_SR, SPI_SR_CLEAR);\r\n}\r\nstatic int dspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct fsl_dspi *dspi;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret = 0, cs_num, bus_num;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\ndspi = spi_master_get_devdata(master);\r\ndspi->pdev = pdev;\r\ndspi->master = master;\r\nmaster->transfer = NULL;\r\nmaster->setup = dspi_setup;\r\nmaster->transfer_one_message = dspi_transfer_one_message;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->cleanup = dspi_cleanup;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(4) | SPI_BPW_MASK(8) |\r\nSPI_BPW_MASK(16);\r\nret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get spi-num-chipselects\n");\r\ngoto out_master_put;\r\n}\r\nmaster->num_chipselect = cs_num;\r\nret = of_property_read_u32(np, "bus-num", &bus_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get bus-num\n");\r\ngoto out_master_put;\r\n}\r\nmaster->bus_num = bus_num;\r\ndspi->devtype_data = of_device_get_match_data(&pdev->dev);\r\nif (!dspi->devtype_data) {\r\ndev_err(&pdev->dev, "can't get devtype_data\n");\r\nret = -EFAULT;\r\ngoto out_master_put;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto out_master_put;\r\n}\r\ndspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, NULL, base,\r\n&dspi_regmap_config);\r\nif (IS_ERR(dspi->regmap)) {\r\ndev_err(&pdev->dev, "failed to init regmap: %ld\n",\r\nPTR_ERR(dspi->regmap));\r\nreturn PTR_ERR(dspi->regmap);\r\n}\r\ndspi_init(dspi);\r\ndspi->irq = platform_get_irq(pdev, 0);\r\nif (dspi->irq < 0) {\r\ndev_err(&pdev->dev, "can't get platform irq\n");\r\nret = dspi->irq;\r\ngoto out_master_put;\r\n}\r\nret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,\r\npdev->name, dspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Unable to attach DSPI interrupt\n");\r\ngoto out_master_put;\r\n}\r\ndspi->clk = devm_clk_get(&pdev->dev, "dspi");\r\nif (IS_ERR(dspi->clk)) {\r\nret = PTR_ERR(dspi->clk);\r\ndev_err(&pdev->dev, "unable to get clock\n");\r\ngoto out_master_put;\r\n}\r\nret = clk_prepare_enable(dspi->clk);\r\nif (ret)\r\ngoto out_master_put;\r\nif (dspi->devtype_data->trans_mode == DSPI_DMA_MODE) {\r\nif (dspi_request_dma(dspi, res->start)) {\r\ndev_err(&pdev->dev, "can't get dma channels\n");\r\ngoto out_clk_put;\r\n}\r\n}\r\nmaster->max_speed_hz =\r\nclk_get_rate(dspi->clk) / dspi->devtype_data->max_clock_factor;\r\ninit_waitqueue_head(&dspi->waitq);\r\nplatform_set_drvdata(pdev, master);\r\nret = spi_register_master(master);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Problem registering DSPI master\n");\r\ngoto out_clk_put;\r\n}\r\nreturn ret;\r\nout_clk_put:\r\nclk_disable_unprepare(dspi->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int dspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\ndspi_release_dma(dspi);\r\nclk_disable_unprepare(dspi->clk);\r\nspi_unregister_master(dspi->master);\r\nreturn 0;\r\n}
