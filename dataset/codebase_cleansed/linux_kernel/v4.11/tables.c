void acpi_table_print_madt_entry(struct acpi_subtable_header *header)\r\n{\r\nif (!header)\r\nreturn;\r\nswitch (header->type) {\r\ncase ACPI_MADT_TYPE_LOCAL_APIC:\r\n{\r\nstruct acpi_madt_local_apic *p =\r\n(struct acpi_madt_local_apic *)header;\r\npr_debug("LAPIC (acpi_id[0x%02x] lapic_id[0x%02x] %s)\n",\r\np->processor_id, p->id,\r\n(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_LOCAL_X2APIC:\r\n{\r\nstruct acpi_madt_local_x2apic *p =\r\n(struct acpi_madt_local_x2apic *)header;\r\npr_debug("X2APIC (apic_id[0x%02x] uid[0x%02x] %s)\n",\r\np->local_apic_id, p->uid,\r\n(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_IO_APIC:\r\n{\r\nstruct acpi_madt_io_apic *p =\r\n(struct acpi_madt_io_apic *)header;\r\npr_debug("IOAPIC (id[0x%02x] address[0x%08x] gsi_base[%d])\n",\r\np->id, p->address, p->global_irq_base);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_INTERRUPT_OVERRIDE:\r\n{\r\nstruct acpi_madt_interrupt_override *p =\r\n(struct acpi_madt_interrupt_override *)header;\r\npr_info("INT_SRC_OVR (bus %d bus_irq %d global_irq %d %s %s)\n",\r\np->bus, p->source_irq, p->global_irq,\r\nmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\r\nmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2]);\r\nif (p->inti_flags &\r\n~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK))\r\npr_info("INT_SRC_OVR unexpected reserved flags: 0x%x\n",\r\np->inti_flags &\r\n~(ACPI_MADT_POLARITY_MASK | ACPI_MADT_TRIGGER_MASK));\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_NMI_SOURCE:\r\n{\r\nstruct acpi_madt_nmi_source *p =\r\n(struct acpi_madt_nmi_source *)header;\r\npr_info("NMI_SRC (%s %s global_irq %d)\n",\r\nmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\r\nmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\r\np->global_irq);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_LOCAL_APIC_NMI:\r\n{\r\nstruct acpi_madt_local_apic_nmi *p =\r\n(struct acpi_madt_local_apic_nmi *)header;\r\npr_info("LAPIC_NMI (acpi_id[0x%02x] %s %s lint[0x%x])\n",\r\np->processor_id,\r\nmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK ],\r\nmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\r\np->lint);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_LOCAL_X2APIC_NMI:\r\n{\r\nu16 polarity, trigger;\r\nstruct acpi_madt_local_x2apic_nmi *p =\r\n(struct acpi_madt_local_x2apic_nmi *)header;\r\npolarity = p->inti_flags & ACPI_MADT_POLARITY_MASK;\r\ntrigger = (p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2;\r\npr_info("X2APIC_NMI (uid[0x%02x] %s %s lint[0x%x])\n",\r\np->uid,\r\nmps_inti_flags_polarity[polarity],\r\nmps_inti_flags_trigger[trigger],\r\np->lint);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE:\r\n{\r\nstruct acpi_madt_local_apic_override *p =\r\n(struct acpi_madt_local_apic_override *)header;\r\npr_info("LAPIC_ADDR_OVR (address[%p])\n",\r\n(void *)(unsigned long)p->address);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_IO_SAPIC:\r\n{\r\nstruct acpi_madt_io_sapic *p =\r\n(struct acpi_madt_io_sapic *)header;\r\npr_debug("IOSAPIC (id[0x%x] address[%p] gsi_base[%d])\n",\r\np->id, (void *)(unsigned long)p->address,\r\np->global_irq_base);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_LOCAL_SAPIC:\r\n{\r\nstruct acpi_madt_local_sapic *p =\r\n(struct acpi_madt_local_sapic *)header;\r\npr_debug("LSAPIC (acpi_id[0x%02x] lsapic_id[0x%02x] lsapic_eid[0x%02x] %s)\n",\r\np->processor_id, p->id, p->eid,\r\n(p->lapic_flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_INTERRUPT_SOURCE:\r\n{\r\nstruct acpi_madt_interrupt_source *p =\r\n(struct acpi_madt_interrupt_source *)header;\r\npr_info("PLAT_INT_SRC (%s %s type[0x%x] id[0x%04x] eid[0x%x] iosapic_vector[0x%x] global_irq[0x%x]\n",\r\nmps_inti_flags_polarity[p->inti_flags & ACPI_MADT_POLARITY_MASK],\r\nmps_inti_flags_trigger[(p->inti_flags & ACPI_MADT_TRIGGER_MASK) >> 2],\r\np->type, p->id, p->eid, p->io_sapic_vector,\r\np->global_irq);\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_GENERIC_INTERRUPT:\r\n{\r\nstruct acpi_madt_generic_interrupt *p =\r\n(struct acpi_madt_generic_interrupt *)header;\r\npr_debug("GICC (acpi_id[0x%04x] address[%llx] MPIDR[0x%llx] %s)\n",\r\np->uid, p->base_address,\r\np->arm_mpidr,\r\n(p->flags & ACPI_MADT_ENABLED) ? "enabled" : "disabled");\r\n}\r\nbreak;\r\ncase ACPI_MADT_TYPE_GENERIC_DISTRIBUTOR:\r\n{\r\nstruct acpi_madt_generic_distributor *p =\r\n(struct acpi_madt_generic_distributor *)header;\r\npr_debug("GIC Distributor (gic_id[0x%04x] address[%llx] gsi_base[%d])\n",\r\np->gic_id, p->base_address,\r\np->global_irq_base);\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Found unsupported MADT entry (type = 0x%x)\n",\r\nheader->type);\r\nbreak;\r\n}\r\n}\r\nstatic int __init\r\nacpi_parse_entries_array(char *id, unsigned long table_size,\r\nstruct acpi_table_header *table_header,\r\nstruct acpi_subtable_proc *proc, int proc_num,\r\nunsigned int max_entries)\r\n{\r\nstruct acpi_subtable_header *entry;\r\nunsigned long table_end;\r\nint count = 0;\r\nint errs = 0;\r\nint i;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (!id)\r\nreturn -EINVAL;\r\nif (!table_size)\r\nreturn -EINVAL;\r\nif (!table_header) {\r\npr_warn("%4.4s not present\n", id);\r\nreturn -ENODEV;\r\n}\r\ntable_end = (unsigned long)table_header + table_header->length;\r\nentry = (struct acpi_subtable_header *)\r\n((unsigned long)table_header + table_size);\r\nwhile (((unsigned long)entry) + sizeof(struct acpi_subtable_header) <\r\ntable_end) {\r\nif (max_entries && count >= max_entries)\r\nbreak;\r\nfor (i = 0; i < proc_num; i++) {\r\nif (entry->type != proc[i].id)\r\ncontinue;\r\nif (!proc[i].handler ||\r\n(!errs && proc[i].handler(entry, table_end))) {\r\nerrs++;\r\ncontinue;\r\n}\r\nproc[i].count++;\r\nbreak;\r\n}\r\nif (i != proc_num)\r\ncount++;\r\nif (entry->length == 0) {\r\npr_err("[%4.4s:0x%02x] Invalid zero length\n", id, proc->id);\r\nreturn -EINVAL;\r\n}\r\nentry = (struct acpi_subtable_header *)\r\n((unsigned long)entry + entry->length);\r\n}\r\nif (max_entries && count > max_entries) {\r\npr_warn("[%4.4s:0x%02x] found the maximum %i entries\n",\r\nid, proc->id, count);\r\n}\r\nreturn errs ? -EINVAL : count;\r\n}\r\nint __init\r\nacpi_parse_entries(char *id,\r\nunsigned long table_size,\r\nacpi_tbl_entry_handler handler,\r\nstruct acpi_table_header *table_header,\r\nint entry_id, unsigned int max_entries)\r\n{\r\nstruct acpi_subtable_proc proc = {\r\n.id = entry_id,\r\n.handler = handler,\r\n};\r\nreturn acpi_parse_entries_array(id, table_size, table_header,\r\n&proc, 1, max_entries);\r\n}\r\nint __init\r\nacpi_table_parse_entries_array(char *id,\r\nunsigned long table_size,\r\nstruct acpi_subtable_proc *proc, int proc_num,\r\nunsigned int max_entries)\r\n{\r\nstruct acpi_table_header *table_header = NULL;\r\nint count;\r\nu32 instance = 0;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (!id)\r\nreturn -EINVAL;\r\nif (!strncmp(id, ACPI_SIG_MADT, 4))\r\ninstance = acpi_apic_instance;\r\nacpi_get_table(id, instance, &table_header);\r\nif (!table_header) {\r\npr_warn("%4.4s not present\n", id);\r\nreturn -ENODEV;\r\n}\r\ncount = acpi_parse_entries_array(id, table_size, table_header,\r\nproc, proc_num, max_entries);\r\nacpi_put_table(table_header);\r\nreturn count;\r\n}\r\nint __init\r\nacpi_table_parse_entries(char *id,\r\nunsigned long table_size,\r\nint entry_id,\r\nacpi_tbl_entry_handler handler,\r\nunsigned int max_entries)\r\n{\r\nstruct acpi_subtable_proc proc = {\r\n.id = entry_id,\r\n.handler = handler,\r\n};\r\nreturn acpi_table_parse_entries_array(id, table_size, &proc, 1,\r\nmax_entries);\r\n}\r\nint __init\r\nacpi_table_parse_madt(enum acpi_madt_type id,\r\nacpi_tbl_entry_handler handler, unsigned int max_entries)\r\n{\r\nreturn acpi_table_parse_entries(ACPI_SIG_MADT,\r\nsizeof(struct acpi_table_madt), id,\r\nhandler, max_entries);\r\n}\r\nint __init acpi_table_parse(char *id, acpi_tbl_table_handler handler)\r\n{\r\nstruct acpi_table_header *table = NULL;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nif (!id || !handler)\r\nreturn -EINVAL;\r\nif (strncmp(id, ACPI_SIG_MADT, 4) == 0)\r\nacpi_get_table(id, acpi_apic_instance, &table);\r\nelse\r\nacpi_get_table(id, 0, &table);\r\nif (table) {\r\nhandler(table);\r\nacpi_put_table(table);\r\nreturn 0;\r\n} else\r\nreturn -ENODEV;\r\n}\r\nstatic void __init check_multiple_madt(void)\r\n{\r\nstruct acpi_table_header *table = NULL;\r\nacpi_get_table(ACPI_SIG_MADT, 2, &table);\r\nif (table) {\r\npr_warn("BIOS bug: multiple APIC/MADT found, using %d\n",\r\nacpi_apic_instance);\r\npr_warn("If \"acpi_apic_instance=%d\" works better, "\r\n"notify linux-acpi@vger.kernel.org\n",\r\nacpi_apic_instance ? 0 : 2);\r\nacpi_put_table(table);\r\n} else\r\nacpi_apic_instance = 0;\r\nreturn;\r\n}\r\nstatic void acpi_table_taint(struct acpi_table_header *table)\r\n{\r\npr_warn("Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",\r\ntable->signature, table->oem_table_id);\r\nadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);\r\n}\r\nstatic u8 __init acpi_table_checksum(u8 *buffer, u32 length)\r\n{\r\nu8 sum = 0;\r\nu8 *end = buffer + length;\r\nwhile (buffer < end)\r\nsum = (u8) (sum + *(buffer++));\r\nreturn sum;\r\n}\r\nvoid __init acpi_table_upgrade(void)\r\n{\r\nvoid *data = (void *)initrd_start;\r\nsize_t size = initrd_end - initrd_start;\r\nint sig, no, table_nr = 0, total_offset = 0;\r\nlong offset = 0;\r\nstruct acpi_table_header *table;\r\nchar cpio_path[32] = "kernel/firmware/acpi/";\r\nstruct cpio_data file;\r\nif (data == NULL || size == 0)\r\nreturn;\r\nfor (no = 0; no < NR_ACPI_INITRD_TABLES; no++) {\r\nfile = find_cpio_data(cpio_path, data, size, &offset);\r\nif (!file.data)\r\nbreak;\r\ndata += offset;\r\nsize -= offset;\r\nif (file.size < sizeof(struct acpi_table_header)) {\r\npr_err("ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\ntable = file.data;\r\nfor (sig = 0; table_sigs[sig]; sig++)\r\nif (!memcmp(table->signature, table_sigs[sig], 4))\r\nbreak;\r\nif (!table_sigs[sig]) {\r\npr_err("ACPI OVERRIDE: Unknown signature [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\nif (file.size != table->length) {\r\npr_err("ACPI OVERRIDE: File length does not match table length [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\nif (acpi_table_checksum(file.data, table->length)) {\r\npr_err("ACPI OVERRIDE: Bad table checksum [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\npr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",\r\ntable->signature, cpio_path, file.name, table->length);\r\nall_tables_size += table->length;\r\nacpi_initrd_files[table_nr].data = file.data;\r\nacpi_initrd_files[table_nr].size = file.size;\r\ntable_nr++;\r\n}\r\nif (table_nr == 0)\r\nreturn;\r\nacpi_tables_addr =\r\nmemblock_find_in_range(0, ACPI_TABLE_UPGRADE_MAX_PHYS,\r\nall_tables_size, PAGE_SIZE);\r\nif (!acpi_tables_addr) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nmemblock_reserve(acpi_tables_addr, all_tables_size);\r\narch_reserve_mem_area(acpi_tables_addr, all_tables_size);\r\nfor (no = 0; no < table_nr; no++) {\r\nunsigned char *src_p = acpi_initrd_files[no].data;\r\nphys_addr_t size = acpi_initrd_files[no].size;\r\nphys_addr_t dest_addr = acpi_tables_addr + total_offset;\r\nphys_addr_t slop, clen;\r\nchar *dest_p;\r\ntotal_offset += size;\r\nwhile (size) {\r\nslop = dest_addr & ~PAGE_MASK;\r\nclen = size;\r\nif (clen > MAP_CHUNK_SIZE - slop)\r\nclen = MAP_CHUNK_SIZE - slop;\r\ndest_p = early_memremap(dest_addr & PAGE_MASK,\r\nclen + slop);\r\nmemcpy(dest_p + slop, src_p, clen);\r\nearly_memunmap(dest_p, clen + slop);\r\nsrc_p += clen;\r\ndest_addr += clen;\r\nsize -= clen;\r\n}\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_table_initrd_override(struct acpi_table_header *existing_table,\r\nacpi_physical_address *address, u32 *length)\r\n{\r\nint table_offset = 0;\r\nint table_index = 0;\r\nstruct acpi_table_header *table;\r\nu32 table_length;\r\n*length = 0;\r\n*address = 0;\r\nif (!acpi_tables_addr)\r\nreturn AE_OK;\r\nwhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\r\ntable = acpi_os_map_memory(acpi_tables_addr + table_offset,\r\nACPI_HEADER_SIZE);\r\nif (table_offset + table->length > all_tables_size) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\nWARN_ON(1);\r\nreturn AE_OK;\r\n}\r\ntable_length = table->length;\r\nif (memcmp(existing_table->signature, table->signature, 4) ||\r\nmemcmp(table->oem_id, existing_table->oem_id,\r\nACPI_OEM_ID_SIZE) ||\r\nmemcmp(table->oem_table_id, existing_table->oem_table_id,\r\nACPI_OEM_TABLE_ID_SIZE)) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\ngoto next_table;\r\n}\r\nif (test_and_set_bit(table_index, acpi_initrd_installed) ||\r\nexisting_table->oem_revision >= table->oem_revision) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\ngoto next_table;\r\n}\r\n*length = table_length;\r\n*address = acpi_tables_addr + table_offset;\r\npr_info("Table Upgrade: override [%4.4s-%6.6s-%8.8s]\n",\r\ntable->signature, table->oem_id,\r\ntable->oem_table_id);\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\nbreak;\r\nnext_table:\r\ntable_offset += table_length;\r\ntable_index++;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic void __init acpi_table_initrd_scan(void)\r\n{\r\nint table_offset = 0;\r\nint table_index = 0;\r\nu32 table_length;\r\nstruct acpi_table_header *table;\r\nif (!acpi_tables_addr)\r\nreturn;\r\nwhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\r\ntable = acpi_os_map_memory(acpi_tables_addr + table_offset,\r\nACPI_HEADER_SIZE);\r\nif (table_offset + table->length > all_tables_size) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ntable_length = table->length;\r\nif (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||\r\nACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\ngoto next_table;\r\n}\r\nif (test_and_set_bit(table_index, acpi_initrd_installed)) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\ngoto next_table;\r\n}\r\npr_info("Table Upgrade: install [%4.4s-%6.6s-%8.8s]\n",\r\ntable->signature, table->oem_id,\r\ntable->oem_table_id);\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\nacpi_install_table(acpi_tables_addr + table_offset, TRUE);\r\nnext_table:\r\ntable_offset += table_length;\r\ntable_index++;\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_table_initrd_override(struct acpi_table_header *existing_table,\r\nacpi_physical_address *address,\r\nu32 *table_length)\r\n{\r\n*table_length = 0;\r\n*address = 0;\r\nreturn AE_OK;\r\n}\r\nstatic void __init acpi_table_initrd_scan(void)\r\n{\r\n}\r\nacpi_status\r\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\r\nacpi_physical_address *address,\r\nu32 *table_length)\r\n{\r\nreturn acpi_table_initrd_override(existing_table, address,\r\ntable_length);\r\n}\r\nacpi_status\r\nacpi_os_table_override(struct acpi_table_header *existing_table,\r\nstruct acpi_table_header **new_table)\r\n{\r\nif (!existing_table || !new_table)\r\nreturn AE_BAD_PARAMETER;\r\n*new_table = NULL;\r\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\r\nif (strncmp(existing_table->signature, "DSDT", 4) == 0)\r\n*new_table = (struct acpi_table_header *)AmlCode;\r\n#endif\r\nif (*new_table != NULL)\r\nacpi_table_taint(existing_table);\r\nreturn AE_OK;\r\n}\r\nint __init acpi_table_init(void)\r\n{\r\nacpi_status status;\r\nif (acpi_verify_table_checksum) {\r\npr_info("Early table checksum verification enabled\n");\r\nacpi_gbl_verify_table_checksum = TRUE;\r\n} else {\r\npr_info("Early table checksum verification disabled\n");\r\nacpi_gbl_verify_table_checksum = FALSE;\r\n}\r\nstatus = acpi_initialize_tables(initial_tables, ACPI_MAX_TABLES, 0);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nacpi_table_initrd_scan();\r\ncheck_multiple_madt();\r\nreturn 0;\r\n}\r\nstatic int __init acpi_parse_apic_instance(char *str)\r\n{\r\nif (!str)\r\nreturn -EINVAL;\r\nif (kstrtoint(str, 0, &acpi_apic_instance))\r\nreturn -EINVAL;\r\npr_notice("Shall use APIC/MADT table %d\n", acpi_apic_instance);\r\nreturn 0;\r\n}\r\nstatic int __init acpi_force_table_verification_setup(char *s)\r\n{\r\nacpi_verify_table_checksum = true;\r\nreturn 0;\r\n}\r\nstatic int __init acpi_force_32bit_fadt_addr(char *s)\r\n{\r\npr_info("Forcing 32 Bit FADT addresses\n");\r\nacpi_gbl_use32_bit_fadt_addresses = TRUE;\r\nreturn 0;\r\n}
