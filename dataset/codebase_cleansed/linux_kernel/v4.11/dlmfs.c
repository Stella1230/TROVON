static int param_set_dlmfs_capabilities(const char *val,\r\nstruct kernel_param *kp)\r\n{\r\nprintk(KERN_ERR "%s: readonly parameter\n", kp->name);\r\nreturn -EINVAL;\r\n}\r\nstatic int param_get_dlmfs_capabilities(char *buffer,\r\nstruct kernel_param *kp)\r\n{\r\nreturn strlcpy(buffer, DLMFS_CAPABILITIES,\r\nstrlen(DLMFS_CAPABILITIES) + 1);\r\n}\r\nstatic int dlmfs_decode_open_flags(int open_flags,\r\nint *level,\r\nint *flags)\r\n{\r\nif (open_flags & (O_WRONLY|O_RDWR))\r\n*level = DLM_LOCK_EX;\r\nelse\r\n*level = DLM_LOCK_PR;\r\n*flags = 0;\r\nif (open_flags & O_NONBLOCK)\r\n*flags |= DLM_LKF_NOQUEUE;\r\nreturn 0;\r\n}\r\nstatic int dlmfs_file_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nint status, level, flags;\r\nstruct dlmfs_filp_private *fp = NULL;\r\nstruct dlmfs_inode_private *ip;\r\nif (S_ISDIR(inode->i_mode))\r\nBUG();\r\nmlog(0, "open called on inode %lu, flags 0x%x\n", inode->i_ino,\r\nfile->f_flags);\r\nstatus = dlmfs_decode_open_flags(file->f_flags, &level, &flags);\r\nif (status < 0)\r\ngoto bail;\r\nfile->f_flags &= ~O_APPEND;\r\nfp = kmalloc(sizeof(*fp), GFP_NOFS);\r\nif (!fp) {\r\nstatus = -ENOMEM;\r\ngoto bail;\r\n}\r\nfp->fp_lock_level = level;\r\nip = DLMFS_I(inode);\r\nstatus = user_dlm_cluster_lock(&ip->ip_lockres, level, flags);\r\nif (status < 0) {\r\nif (flags & DLM_LKF_NOQUEUE && status == -EAGAIN)\r\nstatus = -ETXTBSY;\r\nkfree(fp);\r\ngoto bail;\r\n}\r\nfile->private_data = fp;\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlmfs_file_release(struct inode *inode,\r\nstruct file *file)\r\n{\r\nint level, status;\r\nstruct dlmfs_inode_private *ip = DLMFS_I(inode);\r\nstruct dlmfs_filp_private *fp = file->private_data;\r\nif (S_ISDIR(inode->i_mode))\r\nBUG();\r\nmlog(0, "close called on inode %lu\n", inode->i_ino);\r\nstatus = 0;\r\nif (fp) {\r\nlevel = fp->fp_lock_level;\r\nif (level != DLM_LOCK_IV)\r\nuser_dlm_cluster_unlock(&ip->ip_lockres, level);\r\nkfree(fp);\r\nfile->private_data = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nint error;\r\nstruct inode *inode = d_inode(dentry);\r\nattr->ia_valid &= ~ATTR_SIZE;\r\nerror = setattr_prepare(dentry, attr);\r\nif (error)\r\nreturn error;\r\nsetattr_copy(inode, attr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic unsigned int dlmfs_file_poll(struct file *file, poll_table *wait)\r\n{\r\nint event = 0;\r\nstruct inode *inode = file_inode(file);\r\nstruct dlmfs_inode_private *ip = DLMFS_I(inode);\r\npoll_wait(file, &ip->ip_lockres.l_event, wait);\r\nspin_lock(&ip->ip_lockres.l_lock);\r\nif (ip->ip_lockres.l_flags & USER_LOCK_BLOCKED)\r\nevent = POLLIN | POLLRDNORM;\r\nspin_unlock(&ip->ip_lockres.l_lock);\r\nreturn event;\r\n}\r\nstatic ssize_t dlmfs_file_read(struct file *filp,\r\nchar __user *buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nint bytes_left;\r\nssize_t readlen, got;\r\nchar *lvb_buf;\r\nstruct inode *inode = file_inode(filp);\r\nmlog(0, "inode %lu, count = %zu, *ppos = %llu\n",\r\ninode->i_ino, count, *ppos);\r\nif (*ppos >= i_size_read(inode))\r\nreturn 0;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nif ((count + *ppos) > i_size_read(inode))\r\nreadlen = i_size_read(inode) - *ppos;\r\nelse\r\nreadlen = count;\r\nlvb_buf = kmalloc(readlen, GFP_NOFS);\r\nif (!lvb_buf)\r\nreturn -ENOMEM;\r\ngot = user_dlm_read_lvb(inode, lvb_buf, readlen);\r\nif (got) {\r\nBUG_ON(got != readlen);\r\nbytes_left = __copy_to_user(buf, lvb_buf, readlen);\r\nreadlen -= bytes_left;\r\n} else\r\nreadlen = 0;\r\nkfree(lvb_buf);\r\n*ppos = *ppos + readlen;\r\nmlog(0, "read %zd bytes\n", readlen);\r\nreturn readlen;\r\n}\r\nstatic ssize_t dlmfs_file_write(struct file *filp,\r\nconst char __user *buf,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nint bytes_left;\r\nssize_t writelen;\r\nchar *lvb_buf;\r\nstruct inode *inode = file_inode(filp);\r\nmlog(0, "inode %lu, count = %zu, *ppos = %llu\n",\r\ninode->i_ino, count, *ppos);\r\nif (*ppos >= i_size_read(inode))\r\nreturn -ENOSPC;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nif ((count + *ppos) > i_size_read(inode))\r\nwritelen = i_size_read(inode) - *ppos;\r\nelse\r\nwritelen = count - *ppos;\r\nlvb_buf = kmalloc(writelen, GFP_NOFS);\r\nif (!lvb_buf)\r\nreturn -ENOMEM;\r\nbytes_left = copy_from_user(lvb_buf, buf, writelen);\r\nwritelen -= bytes_left;\r\nif (writelen)\r\nuser_dlm_write_lvb(inode, lvb_buf, writelen);\r\nkfree(lvb_buf);\r\n*ppos = *ppos + writelen;\r\nmlog(0, "wrote %zd bytes\n", writelen);\r\nreturn writelen;\r\n}\r\nstatic void dlmfs_init_once(void *foo)\r\n{\r\nstruct dlmfs_inode_private *ip =\r\n(struct dlmfs_inode_private *) foo;\r\nip->ip_conn = NULL;\r\nip->ip_parent = NULL;\r\ninode_init_once(&ip->ip_vfs_inode);\r\n}\r\nstatic struct inode *dlmfs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct dlmfs_inode_private *ip;\r\nip = kmem_cache_alloc(dlmfs_inode_cache, GFP_NOFS);\r\nif (!ip)\r\nreturn NULL;\r\nreturn &ip->ip_vfs_inode;\r\n}\r\nstatic void dlmfs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(dlmfs_inode_cache, DLMFS_I(inode));\r\n}\r\nstatic void dlmfs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, dlmfs_i_callback);\r\n}\r\nstatic void dlmfs_evict_inode(struct inode *inode)\r\n{\r\nint status;\r\nstruct dlmfs_inode_private *ip;\r\nclear_inode(inode);\r\nmlog(0, "inode %lu\n", inode->i_ino);\r\nip = DLMFS_I(inode);\r\nif (S_ISREG(inode->i_mode)) {\r\nstatus = user_dlm_destroy_lock(&ip->ip_lockres);\r\nif (status < 0)\r\nmlog_errno(status);\r\niput(ip->ip_parent);\r\ngoto clear_fields;\r\n}\r\nmlog(0, "we're a directory, ip->ip_conn = 0x%p\n", ip->ip_conn);\r\nif (ip->ip_conn)\r\nuser_dlm_unregister(ip->ip_conn);\r\nclear_fields:\r\nip->ip_parent = NULL;\r\nip->ip_conn = NULL;\r\n}\r\nstatic struct inode *dlmfs_get_root_inode(struct super_block *sb)\r\n{\r\nstruct inode *inode = new_inode(sb);\r\numode_t mode = S_IFDIR | 0755;\r\nif (inode) {\r\ninode->i_ino = get_next_ino();\r\ninode_init_owner(inode, NULL, mode);\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\r\ninc_nlink(inode);\r\ninode->i_fop = &simple_dir_operations;\r\ninode->i_op = &dlmfs_root_inode_operations;\r\n}\r\nreturn inode;\r\n}\r\nstatic struct inode *dlmfs_get_inode(struct inode *parent,\r\nstruct dentry *dentry,\r\numode_t mode)\r\n{\r\nstruct super_block *sb = parent->i_sb;\r\nstruct inode * inode = new_inode(sb);\r\nstruct dlmfs_inode_private *ip;\r\nif (!inode)\r\nreturn NULL;\r\ninode->i_ino = get_next_ino();\r\ninode_init_owner(inode, parent, mode);\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\r\nip = DLMFS_I(inode);\r\nip->ip_conn = DLMFS_I(parent)->ip_conn;\r\nswitch (mode & S_IFMT) {\r\ndefault:\r\nBUG();\r\nbreak;\r\ncase S_IFREG:\r\ninode->i_op = &dlmfs_file_inode_operations;\r\ninode->i_fop = &dlmfs_file_operations;\r\ni_size_write(inode, DLM_LVB_LEN);\r\nuser_dlm_lock_res_init(&ip->ip_lockres, dentry);\r\nip->ip_parent = igrab(parent);\r\nBUG_ON(!ip->ip_parent);\r\nbreak;\r\ncase S_IFDIR:\r\ninode->i_op = &dlmfs_dir_inode_operations;\r\ninode->i_fop = &simple_dir_operations;\r\ninc_nlink(inode);\r\nbreak;\r\n}\r\nreturn inode;\r\n}\r\nstatic int dlmfs_mkdir(struct inode * dir,\r\nstruct dentry * dentry,\r\numode_t mode)\r\n{\r\nint status;\r\nstruct inode *inode = NULL;\r\nconst struct qstr *domain = &dentry->d_name;\r\nstruct dlmfs_inode_private *ip;\r\nstruct ocfs2_cluster_connection *conn;\r\nmlog(0, "mkdir %.*s\n", domain->len, domain->name);\r\nif (domain->len >= GROUP_NAME_MAX) {\r\nstatus = -EINVAL;\r\nmlog(ML_ERROR, "invalid domain name for directory.\n");\r\ngoto bail;\r\n}\r\ninode = dlmfs_get_inode(dir, dentry, mode | S_IFDIR);\r\nif (!inode) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nip = DLMFS_I(inode);\r\nconn = user_dlm_register(domain);\r\nif (IS_ERR(conn)) {\r\nstatus = PTR_ERR(conn);\r\nmlog(ML_ERROR, "Error %d could not register domain \"%.*s\"\n",\r\nstatus, domain->len, domain->name);\r\ngoto bail;\r\n}\r\nip->ip_conn = conn;\r\ninc_nlink(dir);\r\nd_instantiate(dentry, inode);\r\ndget(dentry);\r\nstatus = 0;\r\nbail:\r\nif (status < 0)\r\niput(inode);\r\nreturn status;\r\n}\r\nstatic int dlmfs_create(struct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\nbool excl)\r\n{\r\nint status = 0;\r\nstruct inode *inode;\r\nconst struct qstr *name = &dentry->d_name;\r\nmlog(0, "create %.*s\n", name->len, name->name);\r\nif (name->len >= USER_DLM_LOCK_ID_MAX_LEN ||\r\nname->name[0] == '$') {\r\nstatus = -EINVAL;\r\nmlog(ML_ERROR, "invalid lock name, %.*s\n", name->len,\r\nname->name);\r\ngoto bail;\r\n}\r\ninode = dlmfs_get_inode(dir, dentry, mode | S_IFREG);\r\nif (!inode) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nd_instantiate(dentry, inode);\r\ndget(dentry);\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlmfs_unlink(struct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nint status;\r\nstruct inode *inode = d_inode(dentry);\r\nmlog(0, "unlink inode %lu\n", inode->i_ino);\r\nstatus = user_dlm_destroy_lock(&DLMFS_I(inode)->ip_lockres);\r\nif (status < 0) {\r\nmlog(ML_ERROR, "unlink %pd, error %d from destroy\n",\r\ndentry, status);\r\ngoto bail;\r\n}\r\nstatus = simple_unlink(dir, dentry);\r\nbail:\r\nreturn status;\r\n}\r\nstatic int dlmfs_fill_super(struct super_block * sb,\r\nvoid * data,\r\nint silent)\r\n{\r\nsb->s_maxbytes = MAX_LFS_FILESIZE;\r\nsb->s_blocksize = PAGE_SIZE;\r\nsb->s_blocksize_bits = PAGE_SHIFT;\r\nsb->s_magic = DLMFS_MAGIC;\r\nsb->s_op = &dlmfs_ops;\r\nsb->s_root = d_make_root(dlmfs_get_root_inode(sb));\r\nif (!sb->s_root)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic struct dentry *dlmfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_nodev(fs_type, flags, data, dlmfs_fill_super);\r\n}\r\nstatic int __init init_dlmfs_fs(void)\r\n{\r\nint status;\r\nint cleanup_inode = 0, cleanup_worker = 0;\r\ndlmfs_inode_cache = kmem_cache_create("dlmfs_inode_cache",\r\nsizeof(struct dlmfs_inode_private),\r\n0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD|SLAB_ACCOUNT),\r\ndlmfs_init_once);\r\nif (!dlmfs_inode_cache) {\r\nstatus = -ENOMEM;\r\ngoto bail;\r\n}\r\ncleanup_inode = 1;\r\nuser_dlm_worker = alloc_workqueue("user_dlm", WQ_MEM_RECLAIM, 0);\r\nif (!user_dlm_worker) {\r\nstatus = -ENOMEM;\r\ngoto bail;\r\n}\r\ncleanup_worker = 1;\r\nuser_dlm_set_locking_protocol();\r\nstatus = register_filesystem(&dlmfs_fs_type);\r\nbail:\r\nif (status) {\r\nif (cleanup_inode)\r\nkmem_cache_destroy(dlmfs_inode_cache);\r\nif (cleanup_worker)\r\ndestroy_workqueue(user_dlm_worker);\r\n} else\r\nprintk("OCFS2 User DLM kernel interface loaded\n");\r\nreturn status;\r\n}\r\nstatic void __exit exit_dlmfs_fs(void)\r\n{\r\nunregister_filesystem(&dlmfs_fs_type);\r\nflush_workqueue(user_dlm_worker);\r\ndestroy_workqueue(user_dlm_worker);\r\nrcu_barrier();\r\nkmem_cache_destroy(dlmfs_inode_cache);\r\n}
