static void lov_pool_getref(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\natomic_inc(&pool->pool_refcount);\r\n}\r\nvoid lov_pool_putref(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\nif (atomic_dec_and_test(&pool->pool_refcount)) {\r\nLASSERT(hlist_unhashed(&pool->pool_hash));\r\nLASSERT(list_empty(&pool->pool_list));\r\nLASSERT(!pool->pool_debugfs_entry);\r\nlov_ost_pool_free(&pool->pool_obds);\r\nkfree(pool);\r\n}\r\n}\r\nstatic void lov_pool_putref_locked(struct pool_desc *pool)\r\n{\r\nCDEBUG(D_INFO, "pool %p\n", pool);\r\nLASSERT(atomic_read(&pool->pool_refcount) > 1);\r\natomic_dec(&pool->pool_refcount);\r\n}\r\nstatic __u32 pool_hashfn(struct cfs_hash *hash_body, const void *key,\r\nunsigned int mask)\r\n{\r\nint i;\r\n__u32 result;\r\nchar *poolname;\r\nresult = 0;\r\npoolname = (char *)key;\r\nfor (i = 0; i < LOV_MAXPOOLNAME; i++) {\r\nif (poolname[i] == '\0')\r\nbreak;\r\nresult = (result << 4) ^ (result >> 28) ^ poolname[i];\r\n}\r\nreturn (result % mask);\r\n}\r\nstatic void *pool_key(struct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nreturn pool->pool_name;\r\n}\r\nstatic int pool_hashkey_keycmp(const void *key, struct hlist_node *compared_hnode)\r\n{\r\nchar *pool_name;\r\nstruct pool_desc *pool;\r\npool_name = (char *)key;\r\npool = hlist_entry(compared_hnode, struct pool_desc, pool_hash);\r\nreturn !strncmp(pool_name, pool->pool_name, LOV_MAXPOOLNAME);\r\n}\r\nstatic void *pool_hashobject(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct pool_desc, pool_hash);\r\n}\r\nstatic void pool_hashrefcount_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nlov_pool_getref(pool);\r\n}\r\nstatic void pool_hashrefcount_put_locked(struct cfs_hash *hs,\r\nstruct hlist_node *hnode)\r\n{\r\nstruct pool_desc *pool;\r\npool = hlist_entry(hnode, struct pool_desc, pool_hash);\r\nlov_pool_putref_locked(pool);\r\n}\r\nstatic void *pool_proc_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)s->private;\r\nint prev_idx;\r\nLASSERTF(iter->magic == POOL_IT_MAGIC, "%08X\n", iter->magic);\r\nif (*pos >= pool_tgt_count(iter->pool))\r\nreturn NULL;\r\nprev_idx = iter->idx;\r\ndown_read(&pool_tgt_rw_sem(iter->pool));\r\niter->idx++;\r\nif (iter->idx == pool_tgt_count(iter->pool)) {\r\niter->idx = prev_idx;\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\nreturn NULL;\r\n}\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\n(*pos)++;\r\nreturn iter;\r\n}\r\nstatic void *pool_proc_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct pool_desc *pool = (struct pool_desc *)s->private;\r\nstruct pool_iterator *iter;\r\nlov_pool_getref(pool);\r\nif ((pool_tgt_count(pool) == 0) ||\r\n(*pos >= pool_tgt_count(pool))) {\r\nlov_pool_putref(pool);\r\nreturn NULL;\r\n}\r\niter = kzalloc(sizeof(*iter), GFP_NOFS);\r\nif (!iter)\r\nreturn ERR_PTR(-ENOMEM);\r\niter->magic = POOL_IT_MAGIC;\r\niter->pool = pool;\r\niter->idx = 0;\r\ns->private = iter;\r\nif (*pos > 0) {\r\nloff_t i;\r\nvoid *ptr;\r\ni = 0;\r\ndo {\r\nptr = pool_proc_next(s, &iter, &i);\r\n} while ((i < *pos) && ptr);\r\nreturn ptr;\r\n}\r\nreturn iter;\r\n}\r\nstatic void pool_proc_stop(struct seq_file *s, void *v)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)s->private;\r\nif ((iter) && (iter->magic == POOL_IT_MAGIC)) {\r\ns->private = iter->pool;\r\nlov_pool_putref(iter->pool);\r\nkfree(iter);\r\n}\r\n}\r\nstatic int pool_proc_show(struct seq_file *s, void *v)\r\n{\r\nstruct pool_iterator *iter = (struct pool_iterator *)v;\r\nstruct lov_tgt_desc *tgt;\r\nLASSERTF(iter->magic == POOL_IT_MAGIC, "%08X\n", iter->magic);\r\nLASSERT(iter->pool);\r\nLASSERT(iter->idx <= pool_tgt_count(iter->pool));\r\ndown_read(&pool_tgt_rw_sem(iter->pool));\r\ntgt = pool_tgt(iter->pool, iter->idx);\r\nup_read(&pool_tgt_rw_sem(iter->pool));\r\nif (tgt)\r\nseq_printf(s, "%s\n", obd_uuid2str(&tgt->ltd_uuid));\r\nreturn 0;\r\n}\r\nstatic int pool_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint rc;\r\nrc = seq_open(file, &pool_proc_ops);\r\nif (!rc) {\r\nstruct seq_file *s = file->private_data;\r\ns->private = inode->i_private;\r\n}\r\nreturn rc;\r\n}\r\nint lov_ost_pool_init(struct ost_pool *op, unsigned int count)\r\n{\r\nif (count == 0)\r\ncount = LOV_POOL_INIT_COUNT;\r\nop->op_array = NULL;\r\nop->op_count = 0;\r\ninit_rwsem(&op->op_rw_sem);\r\nop->op_size = count;\r\nop->op_array = kcalloc(op->op_size, sizeof(op->op_array[0]), GFP_NOFS);\r\nif (!op->op_array) {\r\nop->op_size = 0;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint lov_ost_pool_extend(struct ost_pool *op, unsigned int min_count)\r\n{\r\n__u32 *new;\r\nint new_size;\r\nLASSERT(min_count != 0);\r\nif (op->op_count < op->op_size)\r\nreturn 0;\r\nnew_size = max(min_count, 2 * op->op_size);\r\nnew = kcalloc(new_size, sizeof(op->op_array[0]), GFP_NOFS);\r\nif (!new)\r\nreturn -ENOMEM;\r\nmemcpy(new, op->op_array, op->op_size * sizeof(op->op_array[0]));\r\nkfree(op->op_array);\r\nop->op_array = new;\r\nop->op_size = new_size;\r\nreturn 0;\r\n}\r\nint lov_ost_pool_add(struct ost_pool *op, __u32 idx, unsigned int min_count)\r\n{\r\nint rc = 0, i;\r\ndown_write(&op->op_rw_sem);\r\nrc = lov_ost_pool_extend(op, min_count);\r\nif (rc)\r\ngoto out;\r\nfor (i = 0; i < op->op_count; i++) {\r\nif (op->op_array[i] == idx) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nop->op_array[op->op_count] = idx;\r\nop->op_count++;\r\nout:\r\nup_write(&op->op_rw_sem);\r\nreturn rc;\r\n}\r\nint lov_ost_pool_remove(struct ost_pool *op, __u32 idx)\r\n{\r\nint i;\r\ndown_write(&op->op_rw_sem);\r\nfor (i = 0; i < op->op_count; i++) {\r\nif (op->op_array[i] == idx) {\r\nmemmove(&op->op_array[i], &op->op_array[i + 1],\r\n(op->op_count - i - 1) * sizeof(op->op_array[0]));\r\nop->op_count--;\r\nup_write(&op->op_rw_sem);\r\nreturn 0;\r\n}\r\n}\r\nup_write(&op->op_rw_sem);\r\nreturn -EINVAL;\r\n}\r\nint lov_ost_pool_free(struct ost_pool *op)\r\n{\r\nif (op->op_size == 0)\r\nreturn 0;\r\ndown_write(&op->op_rw_sem);\r\nkfree(op->op_array);\r\nop->op_array = NULL;\r\nop->op_count = 0;\r\nop->op_size = 0;\r\nup_write(&op->op_rw_sem);\r\nreturn 0;\r\n}\r\nint lov_pool_new(struct obd_device *obd, char *poolname)\r\n{\r\nstruct lov_obd *lov;\r\nstruct pool_desc *new_pool;\r\nint rc;\r\nlov = &obd->u.lov;\r\nif (strlen(poolname) > LOV_MAXPOOLNAME)\r\nreturn -ENAMETOOLONG;\r\nnew_pool = kzalloc(sizeof(*new_pool), GFP_NOFS);\r\nif (!new_pool)\r\nreturn -ENOMEM;\r\nstrlcpy(new_pool->pool_name, poolname, sizeof(new_pool->pool_name));\r\nnew_pool->pool_lobd = obd;\r\natomic_set(&new_pool->pool_refcount, 1);\r\nrc = lov_ost_pool_init(&new_pool->pool_obds, 0);\r\nif (rc)\r\ngoto out_err;\r\nINIT_HLIST_NODE(&new_pool->pool_hash);\r\nlov_pool_getref(new_pool);\r\nnew_pool->pool_debugfs_entry = ldebugfs_add_simple(\r\nlov->lov_pool_debugfs_entry,\r\npoolname, new_pool,\r\n&pool_proc_operations);\r\nif (IS_ERR_OR_NULL(new_pool->pool_debugfs_entry)) {\r\nCWARN("Cannot add debugfs pool entry "LOV_POOLNAMEF"\n",\r\npoolname);\r\nnew_pool->pool_debugfs_entry = NULL;\r\nlov_pool_putref(new_pool);\r\n}\r\nCDEBUG(D_INFO, "pool %p - proc %p\n",\r\nnew_pool, new_pool->pool_debugfs_entry);\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_add_tail(&new_pool->pool_list, &lov->lov_pool_list);\r\nlov->lov_pool_count++;\r\nspin_unlock(&obd->obd_dev_lock);\r\nrc = cfs_hash_add_unique(lov->lov_pools_hash_body, poolname,\r\n&new_pool->pool_hash);\r\nif (rc) {\r\nrc = -EEXIST;\r\ngoto out_err;\r\n}\r\nCDEBUG(D_CONFIG, LOV_POOLNAMEF" is pool #%d\n",\r\npoolname, lov->lov_pool_count);\r\nreturn 0;\r\nout_err:\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_del_init(&new_pool->pool_list);\r\nlov->lov_pool_count--;\r\nspin_unlock(&obd->obd_dev_lock);\r\nldebugfs_remove(&new_pool->pool_debugfs_entry);\r\nlov_ost_pool_free(&new_pool->pool_obds);\r\nkfree(new_pool);\r\nreturn rc;\r\n}\r\nint lov_pool_del(struct obd_device *obd, char *poolname)\r\n{\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nlov = &obd->u.lov;\r\npool = cfs_hash_del_key(lov->lov_pools_hash_body, poolname);\r\nif (!pool)\r\nreturn -ENOENT;\r\nif (!IS_ERR_OR_NULL(pool->pool_debugfs_entry)) {\r\nCDEBUG(D_INFO, "proc entry %p\n", pool->pool_debugfs_entry);\r\nldebugfs_remove(&pool->pool_debugfs_entry);\r\nlov_pool_putref(pool);\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_del_init(&pool->pool_list);\r\nlov->lov_pool_count--;\r\nspin_unlock(&obd->obd_dev_lock);\r\nlov_pool_putref(pool);\r\nreturn 0;\r\n}\r\nint lov_pool_add(struct obd_device *obd, char *poolname, char *ostname)\r\n{\r\nstruct obd_uuid ost_uuid;\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nunsigned int lov_idx;\r\nint rc;\r\nlov = &obd->u.lov;\r\npool = cfs_hash_lookup(lov->lov_pools_hash_body, poolname);\r\nif (!pool)\r\nreturn -ENOENT;\r\nobd_str2uuid(&ost_uuid, ostname);\r\nobd_getref(obd);\r\nfor (lov_idx = 0; lov_idx < lov->desc.ld_tgt_count; lov_idx++) {\r\nif (!lov->lov_tgts[lov_idx])\r\ncontinue;\r\nif (obd_uuid_equals(&ost_uuid,\r\n&lov->lov_tgts[lov_idx]->ltd_uuid))\r\nbreak;\r\n}\r\nif (lov_idx == lov->desc.ld_tgt_count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = lov_ost_pool_add(&pool->pool_obds, lov_idx, lov->lov_tgt_size);\r\nif (rc)\r\ngoto out;\r\nCDEBUG(D_CONFIG, "Added %s to "LOV_POOLNAMEF" as member %d\n",\r\nostname, poolname, pool_tgt_count(pool));\r\nout:\r\nobd_putref(obd);\r\nlov_pool_putref(pool);\r\nreturn rc;\r\n}\r\nint lov_pool_remove(struct obd_device *obd, char *poolname, char *ostname)\r\n{\r\nstruct obd_uuid ost_uuid;\r\nstruct lov_obd *lov;\r\nstruct pool_desc *pool;\r\nunsigned int lov_idx;\r\nint rc = 0;\r\nlov = &obd->u.lov;\r\npool = cfs_hash_lookup(lov->lov_pools_hash_body, poolname);\r\nif (!pool)\r\nreturn -ENOENT;\r\nobd_str2uuid(&ost_uuid, ostname);\r\nobd_getref(obd);\r\nfor (lov_idx = 0; lov_idx < lov->desc.ld_tgt_count; lov_idx++) {\r\nif (!lov->lov_tgts[lov_idx])\r\ncontinue;\r\nif (obd_uuid_equals(&ost_uuid,\r\n&lov->lov_tgts[lov_idx]->ltd_uuid))\r\nbreak;\r\n}\r\nif (lov_idx == lov->desc.ld_tgt_count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlov_ost_pool_remove(&pool->pool_obds, lov_idx);\r\nCDEBUG(D_CONFIG, "%s removed from "LOV_POOLNAMEF"\n", ostname,\r\npoolname);\r\nout:\r\nobd_putref(obd);\r\nlov_pool_putref(pool);\r\nreturn rc;\r\n}
