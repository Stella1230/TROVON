void snd_pmac_beep_stop(struct snd_pmac *chip)\r\n{\r\nstruct pmac_beep *beep = chip->beep;\r\nif (beep && beep->running) {\r\nbeep->running = 0;\r\nsnd_pmac_beep_dma_stop(chip);\r\n}\r\n}\r\nstatic int snd_pmac_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct snd_pmac *chip;\r\nstruct pmac_beep *beep;\r\nunsigned long flags;\r\nint beep_speed = 0;\r\nint srate;\r\nint period, ncycles, nsamples;\r\nint i, j, f;\r\nshort *p;\r\nif (type != EV_SND)\r\nreturn -1;\r\nswitch (code) {\r\ncase SND_BELL: if (hz) hz = 1000;\r\ncase SND_TONE: break;\r\ndefault: return -1;\r\n}\r\nchip = input_get_drvdata(dev);\r\nif (! chip || (beep = chip->beep) == NULL)\r\nreturn -1;\r\nif (! hz) {\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (beep->running)\r\nsnd_pmac_beep_stop(chip);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nbeep_speed = snd_pmac_rate_index(chip, &chip->playback, BEEP_SRATE);\r\nsrate = chip->freq_table[beep_speed];\r\nif (hz <= srate / BEEP_BUFLEN || hz > srate / 2)\r\nhz = 1000;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->playback.running || chip->capture.running || beep->running) {\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nbeep->running = 1;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (hz == beep->hz && beep->volume == beep->volume_play) {\r\nnsamples = beep->nsamples;\r\n} else {\r\nperiod = srate * 256 / hz;\r\nncycles = BEEP_BUFLEN * 256 / period;\r\nnsamples = (period * ncycles) >> 8;\r\nf = ncycles * 65536 / nsamples;\r\nj = 0;\r\np = beep->buf;\r\nfor (i = 0; i < nsamples; ++i, p += 2) {\r\np[0] = p[1] = beep_wform[j >> 8] * beep->volume;\r\nj = (j + f) & 0xffff;\r\n}\r\nbeep->hz = hz;\r\nbeep->volume_play = beep->volume;\r\nbeep->nsamples = nsamples;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_pmac_beep_dma_start(chip, beep->nsamples * 4, beep->addr, beep_speed);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_info_beep(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_get_beep(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nif (snd_BUG_ON(!chip->beep))\r\nreturn -ENXIO;\r\nucontrol->value.integer.value[0] = chip->beep->volume;\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_put_beep(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int oval, nval;\r\nif (snd_BUG_ON(!chip->beep))\r\nreturn -ENXIO;\r\noval = chip->beep->volume;\r\nnval = ucontrol->value.integer.value[0];\r\nif (nval > 100)\r\nreturn -EINVAL;\r\nchip->beep->volume = nval;\r\nreturn oval != chip->beep->volume;\r\n}\r\nint snd_pmac_attach_beep(struct snd_pmac *chip)\r\n{\r\nstruct pmac_beep *beep;\r\nstruct input_dev *input_dev;\r\nstruct snd_kcontrol *beep_ctl;\r\nvoid *dmabuf;\r\nint err = -ENOMEM;\r\nbeep = kzalloc(sizeof(*beep), GFP_KERNEL);\r\nif (! beep)\r\nreturn -ENOMEM;\r\ndmabuf = dma_alloc_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\r\n&beep->addr, GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (! dmabuf || ! input_dev)\r\ngoto fail1;\r\ninput_dev->name = "PowerMac Beep";\r\ninput_dev->phys = "powermac/beep";\r\ninput_dev->id.bustype = BUS_ADB;\r\ninput_dev->id.vendor = 0x001f;\r\ninput_dev->id.product = 0x0001;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->evbit[0] = BIT_MASK(EV_SND);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ninput_dev->event = snd_pmac_beep_event;\r\ninput_dev->dev.parent = &chip->pdev->dev;\r\ninput_set_drvdata(input_dev, chip);\r\nbeep->dev = input_dev;\r\nbeep->buf = dmabuf;\r\nbeep->volume = BEEP_VOLUME;\r\nbeep->running = 0;\r\nbeep_ctl = snd_ctl_new1(&snd_pmac_beep_mixer, chip);\r\nerr = snd_ctl_add(chip->card, beep_ctl);\r\nif (err < 0)\r\ngoto fail1;\r\nchip->beep = beep;\r\nerr = input_register_device(beep->dev);\r\nif (err)\r\ngoto fail2;\r\nreturn 0;\r\nfail2: snd_ctl_remove(chip->card, beep_ctl);\r\nfail1: input_free_device(input_dev);\r\nif (dmabuf)\r\ndma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\r\ndmabuf, beep->addr);\r\nkfree(beep);\r\nreturn err;\r\n}\r\nvoid snd_pmac_detach_beep(struct snd_pmac *chip)\r\n{\r\nif (chip->beep) {\r\ninput_unregister_device(chip->beep->dev);\r\ndma_free_coherent(&chip->pdev->dev, BEEP_BUFLEN * 4,\r\nchip->beep->buf, chip->beep->addr);\r\nkfree(chip->beep);\r\nchip->beep = NULL;\r\n}\r\n}
