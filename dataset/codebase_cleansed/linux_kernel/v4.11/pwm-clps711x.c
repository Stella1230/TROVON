static inline struct clps711x_chip *to_clps711x_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct clps711x_chip, chip);\r\n}\r\nstatic void clps711x_pwm_update_val(struct clps711x_chip *priv, u32 n, u32 v)\r\n{\r\nu32 shift = (n + 1) * 4;\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntmp = readl(priv->pmpcon);\r\ntmp &= ~(0xf << shift);\r\ntmp |= v << shift;\r\nwritel(tmp, priv->pmpcon);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic unsigned int clps711x_get_duty(struct pwm_device *pwm, unsigned int v)\r\n{\r\nreturn DIV_ROUND_CLOSEST(v * 0xf, pwm_get_period(pwm));\r\n}\r\nstatic int clps711x_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct clps711x_chip *priv = to_clps711x_chip(chip);\r\nunsigned int freq = clk_get_rate(priv->clk);\r\nif (!freq)\r\nreturn -EINVAL;\r\npwm->args.period = DIV_ROUND_CLOSEST(NSEC_PER_SEC, freq);\r\nreturn 0;\r\n}\r\nstatic int clps711x_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct clps711x_chip *priv = to_clps711x_chip(chip);\r\nunsigned int duty;\r\nif (period_ns != pwm_get_period(pwm))\r\nreturn -EINVAL;\r\nduty = clps711x_get_duty(pwm, duty_ns);\r\nclps711x_pwm_update_val(priv, pwm->hwpwm, duty);\r\nreturn 0;\r\n}\r\nstatic int clps711x_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct clps711x_chip *priv = to_clps711x_chip(chip);\r\nunsigned int duty;\r\nduty = clps711x_get_duty(pwm, pwm_get_duty_cycle(pwm));\r\nclps711x_pwm_update_val(priv, pwm->hwpwm, duty);\r\nreturn 0;\r\n}\r\nstatic void clps711x_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct clps711x_chip *priv = to_clps711x_chip(chip);\r\nclps711x_pwm_update_val(priv, pwm->hwpwm, 0);\r\n}\r\nstatic struct pwm_device *clps711x_pwm_xlate(struct pwm_chip *chip,\r\nconst struct of_phandle_args *args)\r\n{\r\nif (args->args[0] >= chip->npwm)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn pwm_request_from_chip(chip, args->args[0], NULL);\r\n}\r\nstatic int clps711x_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct clps711x_chip *priv;\r\nstruct resource *res;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->pmpcon = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->pmpcon))\r\nreturn PTR_ERR(priv->pmpcon);\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\npriv->chip.ops = &clps711x_pwm_ops;\r\npriv->chip.dev = &pdev->dev;\r\npriv->chip.base = -1;\r\npriv->chip.npwm = 2;\r\npriv->chip.of_xlate = clps711x_pwm_xlate;\r\npriv->chip.of_pwm_n_cells = 1;\r\nspin_lock_init(&priv->lock);\r\nplatform_set_drvdata(pdev, priv);\r\nreturn pwmchip_add(&priv->chip);\r\n}\r\nstatic int clps711x_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct clps711x_chip *priv = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&priv->chip);\r\n}
