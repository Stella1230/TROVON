static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,\r\nu64 goal, u64 limit)\r\n{\r\nvoid *ptr;\r\nu64 addr;\r\nulong flags = choose_memblock_flags();\r\nif (limit > memblock.current_limit)\r\nlimit = memblock.current_limit;\r\nagain:\r\naddr = memblock_find_in_range_node(size, align, goal, limit, nid,\r\nflags);\r\nif (!addr && (flags & MEMBLOCK_MIRROR)) {\r\nflags &= ~MEMBLOCK_MIRROR;\r\npr_warn("Could not allocate %pap bytes of mirrored memory\n",\r\n&size);\r\ngoto again;\r\n}\r\nif (!addr)\r\nreturn NULL;\r\nif (memblock_reserve(addr, size))\r\nreturn NULL;\r\nptr = phys_to_virt(addr);\r\nmemset(ptr, 0, size);\r\nkmemleak_alloc(ptr, size, 0, 0);\r\nreturn ptr;\r\n}\r\nvoid __init free_bootmem_late(unsigned long addr, unsigned long size)\r\n{\r\nunsigned long cursor, end;\r\nkmemleak_free_part_phys(addr, size);\r\ncursor = PFN_UP(addr);\r\nend = PFN_DOWN(addr + size);\r\nfor (; cursor < end; cursor++) {\r\n__free_pages_bootmem(pfn_to_page(cursor), cursor, 0);\r\ntotalram_pages++;\r\n}\r\n}\r\nstatic void __init __free_pages_memory(unsigned long start, unsigned long end)\r\n{\r\nint order;\r\nwhile (start < end) {\r\norder = min(MAX_ORDER - 1UL, __ffs(start));\r\nwhile (start + (1UL << order) > end)\r\norder--;\r\n__free_pages_bootmem(pfn_to_page(start), start, order);\r\nstart += (1UL << order);\r\n}\r\n}\r\nstatic unsigned long __init __free_memory_core(phys_addr_t start,\r\nphys_addr_t end)\r\n{\r\nunsigned long start_pfn = PFN_UP(start);\r\nunsigned long end_pfn = min_t(unsigned long,\r\nPFN_DOWN(end), max_low_pfn);\r\nif (start_pfn > end_pfn)\r\nreturn 0;\r\n__free_pages_memory(start_pfn, end_pfn);\r\nreturn end_pfn - start_pfn;\r\n}\r\nstatic unsigned long __init free_low_memory_core_early(void)\r\n{\r\nunsigned long count = 0;\r\nphys_addr_t start, end;\r\nu64 i;\r\nmemblock_clear_hotplug(0, -1);\r\nfor_each_reserved_mem_region(i, &start, &end)\r\nreserve_bootmem_region(start, end);\r\nfor_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &start, &end,\r\nNULL)\r\ncount += __free_memory_core(start, end);\r\n#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK\r\n{\r\nphys_addr_t size;\r\nsize = get_allocated_memblock_reserved_regions_info(&start);\r\nif (size)\r\ncount += __free_memory_core(start, start + size);\r\nsize = get_allocated_memblock_memory_regions_info(&start);\r\nif (size)\r\ncount += __free_memory_core(start, start + size);\r\n}\r\n#endif\r\nreturn count;\r\n}\r\nvoid reset_node_managed_pages(pg_data_t *pgdat)\r\n{\r\nstruct zone *z;\r\nfor (z = pgdat->node_zones; z < pgdat->node_zones + MAX_NR_ZONES; z++)\r\nz->managed_pages = 0;\r\n}\r\nvoid __init reset_all_zones_managed_pages(void)\r\n{\r\nstruct pglist_data *pgdat;\r\nif (reset_managed_pages_done)\r\nreturn;\r\nfor_each_online_pgdat(pgdat)\r\nreset_node_managed_pages(pgdat);\r\nreset_managed_pages_done = 1;\r\n}\r\nunsigned long __init free_all_bootmem(void)\r\n{\r\nunsigned long pages;\r\nreset_all_zones_managed_pages();\r\npages = free_low_memory_core_early();\r\ntotalram_pages += pages;\r\nreturn pages;\r\n}\r\nvoid __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,\r\nunsigned long size)\r\n{\r\nmemblock_free(physaddr, size);\r\n}\r\nvoid __init free_bootmem(unsigned long addr, unsigned long size)\r\n{\r\nmemblock_free(addr, size);\r\n}\r\nstatic void * __init ___alloc_bootmem_nopanic(unsigned long size,\r\nunsigned long align,\r\nunsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc(size, GFP_NOWAIT);\r\nrestart:\r\nptr = __alloc_memory_core_early(NUMA_NO_NODE, size, align, goal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nif (goal != 0) {\r\ngoal = 0;\r\ngoto restart;\r\n}\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nunsigned long limit = -1UL;\r\nreturn ___alloc_bootmem_nopanic(size, align, goal, limit);\r\n}\r\nstatic void * __init ___alloc_bootmem(unsigned long size, unsigned long align,\r\nunsigned long goal, unsigned long limit)\r\n{\r\nvoid *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);\r\nif (mem)\r\nreturn mem;\r\npr_alert("bootmem alloc of %lu bytes failed!\n", size);\r\npanic("Out of memory");\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nunsigned long limit = -1UL;\r\nreturn ___alloc_bootmem(size, align, goal, limit);\r\n}\r\nvoid * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,\r\nunsigned long size,\r\nunsigned long align,\r\nunsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nagain:\r\nptr = __alloc_memory_core_early(pgdat->node_id, size, align,\r\ngoal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nptr = __alloc_memory_core_early(NUMA_NO_NODE, size, align,\r\ngoal, limit);\r\nif (ptr)\r\nreturn ptr;\r\nif (goal) {\r\ngoal = 0;\r\ngoto again;\r\n}\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, 0);\r\n}\r\nstatic void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal,\r\nunsigned long limit)\r\n{\r\nvoid *ptr;\r\nptr = ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, limit);\r\nif (ptr)\r\nreturn ptr;\r\npr_alert("bootmem alloc of %lu bytes failed!\n", size);\r\npanic("Out of memory");\r\nreturn NULL;\r\n}\r\nvoid * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node(pgdat, size, align, goal, 0);\r\n}\r\nvoid * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nreturn __alloc_bootmem_node(pgdat, size, align, goal);\r\n}\r\nvoid * __init __alloc_bootmem_low(unsigned long size, unsigned long align,\r\nunsigned long goal)\r\n{\r\nreturn ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);\r\n}\r\nvoid * __init __alloc_bootmem_low_nopanic(unsigned long size,\r\nunsigned long align,\r\nunsigned long goal)\r\n{\r\nreturn ___alloc_bootmem_nopanic(size, align, goal,\r\nARCH_LOW_ADDRESS_LIMIT);\r\n}\r\nvoid * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,\r\nunsigned long align, unsigned long goal)\r\n{\r\nif (WARN_ON_ONCE(slab_is_available()))\r\nreturn kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);\r\nreturn ___alloc_bootmem_node(pgdat, size, align, goal,\r\nARCH_LOW_ADDRESS_LIMIT);\r\n}
