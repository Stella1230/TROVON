static u64 igb_ptp_read_82576(const struct cyclecounter *cc)\r\n{\r\nstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\r\nstruct e1000_hw *hw = &igb->hw;\r\nu64 val;\r\nu32 lo, hi;\r\nlo = rd32(E1000_SYSTIML);\r\nhi = rd32(E1000_SYSTIMH);\r\nval = ((u64) hi) << 32;\r\nval |= lo;\r\nreturn val;\r\n}\r\nstatic u64 igb_ptp_read_82580(const struct cyclecounter *cc)\r\n{\r\nstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\r\nstruct e1000_hw *hw = &igb->hw;\r\nu32 lo, hi;\r\nu64 val;\r\nrd32(E1000_SYSTIMR);\r\nlo = rd32(E1000_SYSTIML);\r\nhi = rd32(E1000_SYSTIMH);\r\nval = ((u64) hi) << 32;\r\nval |= lo;\r\nreturn val;\r\n}\r\nstatic void igb_ptp_read_i210(struct igb_adapter *adapter,\r\nstruct timespec64 *ts)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 sec, nsec;\r\nrd32(E1000_SYSTIMR);\r\nnsec = rd32(E1000_SYSTIML);\r\nsec = rd32(E1000_SYSTIMH);\r\nts->tv_sec = sec;\r\nts->tv_nsec = nsec;\r\n}\r\nstatic void igb_ptp_write_i210(struct igb_adapter *adapter,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nwr32(E1000_SYSTIML, ts->tv_nsec);\r\nwr32(E1000_SYSTIMH, (u32)ts->tv_sec);\r\n}\r\nstatic void igb_ptp_systim_to_hwtstamp(struct igb_adapter *adapter,\r\nstruct skb_shared_hwtstamps *hwtstamps,\r\nu64 systim)\r\n{\r\nunsigned long flags;\r\nu64 ns;\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82576:\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_cyc2time(&adapter->tc, systim);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ns_to_ktime(ns);\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ktime_set(systim >> 32,\r\nsystim & 0xFFFFFFFF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int igb_ptp_adjfreq_82576(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nstruct e1000_hw *hw = &igb->hw;\r\nint neg_adj = 0;\r\nu64 rate;\r\nu32 incvalue;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nrate = ppb;\r\nrate <<= 14;\r\nrate = div_u64(rate, 1953125);\r\nincvalue = 16 << IGB_82576_TSYNC_SHIFT;\r\nif (neg_adj)\r\nincvalue -= rate;\r\nelse\r\nincvalue += rate;\r\nwr32(E1000_TIMINCA, INCPERIOD_82576 | (incvalue & INCVALUE_82576_MASK));\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjfine_82580(struct ptp_clock_info *ptp, long scaled_ppm)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nstruct e1000_hw *hw = &igb->hw;\r\nint neg_adj = 0;\r\nu64 rate;\r\nu32 inca;\r\nif (scaled_ppm < 0) {\r\nneg_adj = 1;\r\nscaled_ppm = -scaled_ppm;\r\n}\r\nrate = scaled_ppm;\r\nrate <<= 13;\r\nrate = div_u64(rate, 15625);\r\ninca = rate & INCVALUE_MASK;\r\nif (neg_adj)\r\ninca |= ISGN;\r\nwr32(E1000_TIMINCA, inca);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjtime_82576(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntimecounter_adjtime(&igb->tc, delta);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjtime_i210(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nstruct timespec64 now, then = ns_to_timespec64(delta);\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_read_i210(igb, &now);\r\nnow = timespec64_add(now, then);\r\nigb_ptp_write_i210(igb, (const struct timespec64 *)&now);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_gettime_82576(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nu64 ns;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nns = timecounter_read(&igb->tc);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_gettime_i210(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_read_i210(igb, ts);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_settime_82576(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nu64 ns;\r\nns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntimecounter_init(&igb->tc, &igb->cc, ns);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_settime_i210(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_write_i210(igb, ts);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void igb_pin_direction(int pin, int input, u32 *ctrl, u32 *ctrl_ext)\r\n{\r\nu32 *ptr = pin < 2 ? ctrl : ctrl_ext;\r\nstatic const u32 mask[IGB_N_SDP] = {\r\nE1000_CTRL_SDP0_DIR,\r\nE1000_CTRL_SDP1_DIR,\r\nE1000_CTRL_EXT_SDP2_DIR,\r\nE1000_CTRL_EXT_SDP3_DIR,\r\n};\r\nif (input)\r\n*ptr &= ~mask[pin];\r\nelse\r\n*ptr |= mask[pin];\r\n}\r\nstatic void igb_pin_extts(struct igb_adapter *igb, int chan, int pin)\r\n{\r\nstatic const u32 aux0_sel_sdp[IGB_N_SDP] = {\r\nAUX0_SEL_SDP0, AUX0_SEL_SDP1, AUX0_SEL_SDP2, AUX0_SEL_SDP3,\r\n};\r\nstatic const u32 aux1_sel_sdp[IGB_N_SDP] = {\r\nAUX1_SEL_SDP0, AUX1_SEL_SDP1, AUX1_SEL_SDP2, AUX1_SEL_SDP3,\r\n};\r\nstatic const u32 ts_sdp_en[IGB_N_SDP] = {\r\nTS_SDP0_EN, TS_SDP1_EN, TS_SDP2_EN, TS_SDP3_EN,\r\n};\r\nstruct e1000_hw *hw = &igb->hw;\r\nu32 ctrl, ctrl_ext, tssdp = 0;\r\nctrl = rd32(E1000_CTRL);\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\ntssdp = rd32(E1000_TSSDP);\r\nigb_pin_direction(pin, 1, &ctrl, &ctrl_ext);\r\ntssdp &= ~ts_sdp_en[pin];\r\nif (chan == 1) {\r\ntssdp &= ~AUX1_SEL_SDP3;\r\ntssdp |= aux1_sel_sdp[pin] | AUX1_TS_SDP_EN;\r\n} else {\r\ntssdp &= ~AUX0_SEL_SDP3;\r\ntssdp |= aux0_sel_sdp[pin] | AUX0_TS_SDP_EN;\r\n}\r\nwr32(E1000_TSSDP, tssdp);\r\nwr32(E1000_CTRL, ctrl);\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\n}\r\nstatic void igb_pin_perout(struct igb_adapter *igb, int chan, int pin, int freq)\r\n{\r\nstatic const u32 aux0_sel_sdp[IGB_N_SDP] = {\r\nAUX0_SEL_SDP0, AUX0_SEL_SDP1, AUX0_SEL_SDP2, AUX0_SEL_SDP3,\r\n};\r\nstatic const u32 aux1_sel_sdp[IGB_N_SDP] = {\r\nAUX1_SEL_SDP0, AUX1_SEL_SDP1, AUX1_SEL_SDP2, AUX1_SEL_SDP3,\r\n};\r\nstatic const u32 ts_sdp_en[IGB_N_SDP] = {\r\nTS_SDP0_EN, TS_SDP1_EN, TS_SDP2_EN, TS_SDP3_EN,\r\n};\r\nstatic const u32 ts_sdp_sel_tt0[IGB_N_SDP] = {\r\nTS_SDP0_SEL_TT0, TS_SDP1_SEL_TT0,\r\nTS_SDP2_SEL_TT0, TS_SDP3_SEL_TT0,\r\n};\r\nstatic const u32 ts_sdp_sel_tt1[IGB_N_SDP] = {\r\nTS_SDP0_SEL_TT1, TS_SDP1_SEL_TT1,\r\nTS_SDP2_SEL_TT1, TS_SDP3_SEL_TT1,\r\n};\r\nstatic const u32 ts_sdp_sel_fc0[IGB_N_SDP] = {\r\nTS_SDP0_SEL_FC0, TS_SDP1_SEL_FC0,\r\nTS_SDP2_SEL_FC0, TS_SDP3_SEL_FC0,\r\n};\r\nstatic const u32 ts_sdp_sel_fc1[IGB_N_SDP] = {\r\nTS_SDP0_SEL_FC1, TS_SDP1_SEL_FC1,\r\nTS_SDP2_SEL_FC1, TS_SDP3_SEL_FC1,\r\n};\r\nstatic const u32 ts_sdp_sel_clr[IGB_N_SDP] = {\r\nTS_SDP0_SEL_FC1, TS_SDP1_SEL_FC1,\r\nTS_SDP2_SEL_FC1, TS_SDP3_SEL_FC1,\r\n};\r\nstruct e1000_hw *hw = &igb->hw;\r\nu32 ctrl, ctrl_ext, tssdp = 0;\r\nctrl = rd32(E1000_CTRL);\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\ntssdp = rd32(E1000_TSSDP);\r\nigb_pin_direction(pin, 0, &ctrl, &ctrl_ext);\r\nif ((tssdp & AUX0_SEL_SDP3) == aux0_sel_sdp[pin])\r\ntssdp &= ~AUX0_TS_SDP_EN;\r\nif ((tssdp & AUX1_SEL_SDP3) == aux1_sel_sdp[pin])\r\ntssdp &= ~AUX1_TS_SDP_EN;\r\ntssdp &= ~ts_sdp_sel_clr[pin];\r\nif (freq) {\r\nif (chan == 1)\r\ntssdp |= ts_sdp_sel_fc1[pin];\r\nelse\r\ntssdp |= ts_sdp_sel_fc0[pin];\r\n} else {\r\nif (chan == 1)\r\ntssdp |= ts_sdp_sel_tt1[pin];\r\nelse\r\ntssdp |= ts_sdp_sel_tt0[pin];\r\n}\r\ntssdp |= ts_sdp_en[pin];\r\nwr32(E1000_TSSDP, tssdp);\r\nwr32(E1000_CTRL, ctrl);\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\n}\r\nstatic int igb_ptp_feature_enable_i210(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct igb_adapter *igb =\r\ncontainer_of(ptp, struct igb_adapter, ptp_caps);\r\nstruct e1000_hw *hw = &igb->hw;\r\nu32 tsauxc, tsim, tsauxc_mask, tsim_mask, trgttiml, trgttimh, freqout;\r\nunsigned long flags;\r\nstruct timespec64 ts;\r\nint use_freq = 0, pin = -1;\r\ns64 ns;\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nif (on) {\r\npin = ptp_find_pin(igb->ptp_clock, PTP_PF_EXTTS,\r\nrq->extts.index);\r\nif (pin < 0)\r\nreturn -EBUSY;\r\n}\r\nif (rq->extts.index == 1) {\r\ntsauxc_mask = TSAUXC_EN_TS1;\r\ntsim_mask = TSINTR_AUTT1;\r\n} else {\r\ntsauxc_mask = TSAUXC_EN_TS0;\r\ntsim_mask = TSINTR_AUTT0;\r\n}\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntsauxc = rd32(E1000_TSAUXC);\r\ntsim = rd32(E1000_TSIM);\r\nif (on) {\r\nigb_pin_extts(igb, rq->extts.index, pin);\r\ntsauxc |= tsauxc_mask;\r\ntsim |= tsim_mask;\r\n} else {\r\ntsauxc &= ~tsauxc_mask;\r\ntsim &= ~tsim_mask;\r\n}\r\nwr32(E1000_TSAUXC, tsauxc);\r\nwr32(E1000_TSIM, tsim);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\ncase PTP_CLK_REQ_PEROUT:\r\nif (on) {\r\npin = ptp_find_pin(igb->ptp_clock, PTP_PF_PEROUT,\r\nrq->perout.index);\r\nif (pin < 0)\r\nreturn -EBUSY;\r\n}\r\nts.tv_sec = rq->perout.period.sec;\r\nts.tv_nsec = rq->perout.period.nsec;\r\nns = timespec64_to_ns(&ts);\r\nns = ns >> 1;\r\nif (on && ((ns <= 70000000LL) || (ns == 125000000LL) ||\r\n(ns == 250000000LL) || (ns == 500000000LL))) {\r\nif (ns < 8LL)\r\nreturn -EINVAL;\r\nuse_freq = 1;\r\n}\r\nts = ns_to_timespec64(ns);\r\nif (rq->perout.index == 1) {\r\nif (use_freq) {\r\ntsauxc_mask = TSAUXC_EN_CLK1 | TSAUXC_ST1;\r\ntsim_mask = 0;\r\n} else {\r\ntsauxc_mask = TSAUXC_EN_TT1;\r\ntsim_mask = TSINTR_TT1;\r\n}\r\ntrgttiml = E1000_TRGTTIML1;\r\ntrgttimh = E1000_TRGTTIMH1;\r\nfreqout = E1000_FREQOUT1;\r\n} else {\r\nif (use_freq) {\r\ntsauxc_mask = TSAUXC_EN_CLK0 | TSAUXC_ST0;\r\ntsim_mask = 0;\r\n} else {\r\ntsauxc_mask = TSAUXC_EN_TT0;\r\ntsim_mask = TSINTR_TT0;\r\n}\r\ntrgttiml = E1000_TRGTTIML0;\r\ntrgttimh = E1000_TRGTTIMH0;\r\nfreqout = E1000_FREQOUT0;\r\n}\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntsauxc = rd32(E1000_TSAUXC);\r\ntsim = rd32(E1000_TSIM);\r\nif (rq->perout.index == 1) {\r\ntsauxc &= ~(TSAUXC_EN_TT1 | TSAUXC_EN_CLK1 | TSAUXC_ST1);\r\ntsim &= ~TSINTR_TT1;\r\n} else {\r\ntsauxc &= ~(TSAUXC_EN_TT0 | TSAUXC_EN_CLK0 | TSAUXC_ST0);\r\ntsim &= ~TSINTR_TT0;\r\n}\r\nif (on) {\r\nint i = rq->perout.index;\r\nigb_pin_perout(igb, i, pin, use_freq);\r\nigb->perout[i].start.tv_sec = rq->perout.start.sec;\r\nigb->perout[i].start.tv_nsec = rq->perout.start.nsec;\r\nigb->perout[i].period.tv_sec = ts.tv_sec;\r\nigb->perout[i].period.tv_nsec = ts.tv_nsec;\r\nwr32(trgttimh, rq->perout.start.sec);\r\nwr32(trgttiml, rq->perout.start.nsec);\r\nif (use_freq)\r\nwr32(freqout, ns);\r\ntsauxc |= tsauxc_mask;\r\ntsim |= tsim_mask;\r\n}\r\nwr32(E1000_TSAUXC, tsauxc);\r\nwr32(E1000_TSIM, tsim);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\ncase PTP_CLK_REQ_PPS:\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntsim = rd32(E1000_TSIM);\r\nif (on)\r\ntsim |= TSINTR_SYS_WRAP;\r\nelse\r\ntsim &= ~TSINTR_SYS_WRAP;\r\nigb->pps_sys_wrap_on = !!on;\r\nwr32(E1000_TSIM, tsim);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int igb_ptp_feature_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int igb_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\r\nenum ptp_pin_function func, unsigned int chan)\r\n{\r\nswitch (func) {\r\ncase PTP_PF_NONE:\r\ncase PTP_PF_EXTTS:\r\ncase PTP_PF_PEROUT:\r\nbreak;\r\ncase PTP_PF_PHYSYNC:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void igb_ptp_tx_work(struct work_struct *work)\r\n{\r\nstruct igb_adapter *adapter = container_of(work, struct igb_adapter,\r\nptp_tx_work);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tsynctxctl;\r\nif (!adapter->ptp_tx_skb)\r\nreturn;\r\nif (time_is_before_jiffies(adapter->ptp_tx_start +\r\nIGB_PTP_TX_TIMEOUT)) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\r\nadapter->tx_hwtstamp_timeouts++;\r\ndev_warn(&adapter->pdev->dev, "clearing Tx timestamp hang\n");\r\nreturn;\r\n}\r\ntsynctxctl = rd32(E1000_TSYNCTXCTL);\r\nif (tsynctxctl & E1000_TSYNCTXCTL_VALID)\r\nigb_ptp_tx_hwtstamp(adapter);\r\nelse\r\nschedule_work(&adapter->ptp_tx_work);\r\n}\r\nstatic void igb_ptp_overflow_check(struct work_struct *work)\r\n{\r\nstruct igb_adapter *igb =\r\ncontainer_of(work, struct igb_adapter, ptp_overflow_work.work);\r\nstruct timespec64 ts;\r\nigb->ptp_caps.gettime64(&igb->ptp_caps, &ts);\r\npr_debug("igb overflow check at %lld.%09lu\n",\r\n(long long) ts.tv_sec, ts.tv_nsec);\r\nschedule_delayed_work(&igb->ptp_overflow_work,\r\nIGB_SYSTIM_OVERFLOW_PERIOD);\r\n}\r\nvoid igb_ptp_rx_hang(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tsyncrxctl = rd32(E1000_TSYNCRXCTL);\r\nunsigned long rx_event;\r\nif (hw->mac.type != e1000_82576)\r\nreturn;\r\nif (!(tsyncrxctl & E1000_TSYNCRXCTL_VALID)) {\r\nadapter->last_rx_ptp_check = jiffies;\r\nreturn;\r\n}\r\nrx_event = adapter->last_rx_ptp_check;\r\nif (time_after(adapter->last_rx_timestamp, rx_event))\r\nrx_event = adapter->last_rx_timestamp;\r\nif (time_is_before_jiffies(rx_event + 5 * HZ)) {\r\nrd32(E1000_RXSTMPH);\r\nadapter->last_rx_ptp_check = jiffies;\r\nadapter->rx_hwtstamp_cleared++;\r\ndev_warn(&adapter->pdev->dev, "clearing Rx timestamp hang\n");\r\n}\r\n}\r\nstatic void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 regval;\r\nint adjust = 0;\r\nregval = rd32(E1000_TXSTMPL);\r\nregval |= (u64)rd32(E1000_TXSTMPH) << 32;\r\nigb_ptp_systim_to_hwtstamp(adapter, &shhwtstamps, regval);\r\nif (adapter->hw.mac.type == e1000_i210) {\r\nswitch (adapter->link_speed) {\r\ncase SPEED_10:\r\nadjust = IGB_I210_TX_LATENCY_10;\r\nbreak;\r\ncase SPEED_100:\r\nadjust = IGB_I210_TX_LATENCY_100;\r\nbreak;\r\ncase SPEED_1000:\r\nadjust = IGB_I210_TX_LATENCY_1000;\r\nbreak;\r\n}\r\n}\r\nshhwtstamps.hwtstamp =\r\nktime_add_ns(shhwtstamps.hwtstamp, adjust);\r\nskb_tstamp_tx(adapter->ptp_tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\r\n}\r\nvoid igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector,\r\nunsigned char *va,\r\nstruct sk_buff *skb)\r\n{\r\n__le64 *regval = (__le64 *)va;\r\nstruct igb_adapter *adapter = q_vector->adapter;\r\nint adjust = 0;\r\nigb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb),\r\nle64_to_cpu(regval[1]));\r\nif (adapter->hw.mac.type == e1000_i210) {\r\nswitch (adapter->link_speed) {\r\ncase SPEED_10:\r\nadjust = IGB_I210_RX_LATENCY_10;\r\nbreak;\r\ncase SPEED_100:\r\nadjust = IGB_I210_RX_LATENCY_100;\r\nbreak;\r\ncase SPEED_1000:\r\nadjust = IGB_I210_RX_LATENCY_1000;\r\nbreak;\r\n}\r\n}\r\nskb_hwtstamps(skb)->hwtstamp =\r\nktime_sub_ns(skb_hwtstamps(skb)->hwtstamp, adjust);\r\n}\r\nvoid igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,\r\nstruct sk_buff *skb)\r\n{\r\nstruct igb_adapter *adapter = q_vector->adapter;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu64 regval;\r\nint adjust = 0;\r\nif (!(rd32(E1000_TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\r\nreturn;\r\nregval = rd32(E1000_RXSTMPL);\r\nregval |= (u64)rd32(E1000_RXSTMPH) << 32;\r\nigb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);\r\nif (adapter->hw.mac.type == e1000_i210) {\r\nswitch (adapter->link_speed) {\r\ncase SPEED_10:\r\nadjust = IGB_I210_RX_LATENCY_10;\r\nbreak;\r\ncase SPEED_100:\r\nadjust = IGB_I210_RX_LATENCY_100;\r\nbreak;\r\ncase SPEED_1000:\r\nadjust = IGB_I210_RX_LATENCY_1000;\r\nbreak;\r\n}\r\n}\r\nskb_hwtstamps(skb)->hwtstamp =\r\nktime_sub_ns(skb_hwtstamps(skb)->hwtstamp, adjust);\r\nadapter->last_rx_timestamp = jiffies;\r\n}\r\nint igb_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct hwtstamp_config *config = &adapter->tstamp_config;\r\nreturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int igb_ptp_set_timestamp_mode(struct igb_adapter *adapter,\r\nstruct hwtstamp_config *config)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\r\nu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\r\nu32 tsync_rx_cfg = 0;\r\nbool is_l4 = false;\r\nbool is_l2 = false;\r\nu32 regval;\r\nif (config->flags)\r\nreturn -EINVAL;\r\nswitch (config->tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ntsync_tx_ctl = 0;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config->rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntsync_rx_ctl = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\r\nconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nis_l2 = true;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_ALL:\r\nif (hw->mac.type != e1000_82576) {\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\r\nconfig->rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\n}\r\ndefault:\r\nconfig->rx_filter = HWTSTAMP_FILTER_NONE;\r\nreturn -ERANGE;\r\n}\r\nif (hw->mac.type == e1000_82575) {\r\nif (tsync_rx_ctl | tsync_tx_ctl)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif ((hw->mac.type >= e1000_82580) && tsync_rx_ctl) {\r\ntsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\r\nconfig->rx_filter = HWTSTAMP_FILTER_ALL;\r\nis_l2 = true;\r\nis_l4 = true;\r\nif ((hw->mac.type == e1000_i210) ||\r\n(hw->mac.type == e1000_i211)) {\r\nregval = rd32(E1000_RXPBS);\r\nregval |= E1000_RXPBS_CFG_TS_EN;\r\nwr32(E1000_RXPBS, regval);\r\n}\r\n}\r\nregval = rd32(E1000_TSYNCTXCTL);\r\nregval &= ~E1000_TSYNCTXCTL_ENABLED;\r\nregval |= tsync_tx_ctl;\r\nwr32(E1000_TSYNCTXCTL, regval);\r\nregval = rd32(E1000_TSYNCRXCTL);\r\nregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\r\nregval |= tsync_rx_ctl;\r\nwr32(E1000_TSYNCRXCTL, regval);\r\nwr32(E1000_TSYNCRXCFG, tsync_rx_cfg);\r\nif (is_l2)\r\nwr32(E1000_ETQF(IGB_ETQF_FILTER_1588),\r\n(E1000_ETQF_FILTER_ENABLE |\r\nE1000_ETQF_1588 |\r\nETH_P_1588));\r\nelse\r\nwr32(E1000_ETQF(IGB_ETQF_FILTER_1588), 0);\r\nif (is_l4) {\r\nu32 ftqf = (IPPROTO_UDP\r\n| E1000_FTQF_VF_BP\r\n| E1000_FTQF_1588_TIME_STAMP\r\n| E1000_FTQF_MASK);\r\nftqf &= ~E1000_FTQF_MASK_PROTO_BP;\r\nwr32(E1000_IMIR(3), htons(PTP_EV_PORT));\r\nwr32(E1000_IMIREXT(3),\r\n(E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_BP));\r\nif (hw->mac.type == e1000_82576) {\r\nwr32(E1000_SPQF(3), htons(PTP_EV_PORT));\r\nftqf &= ~E1000_FTQF_MASK_SOURCE_PORT_BP;\r\n}\r\nwr32(E1000_FTQF(3), ftqf);\r\n} else {\r\nwr32(E1000_FTQF(3), E1000_FTQF_MASK);\r\n}\r\nwrfl();\r\nregval = rd32(E1000_TXSTMPL);\r\nregval = rd32(E1000_TXSTMPH);\r\nregval = rd32(E1000_RXSTMPL);\r\nregval = rd32(E1000_RXSTMPH);\r\nreturn 0;\r\n}\r\nint igb_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct hwtstamp_config config;\r\nint err;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nerr = igb_ptp_set_timestamp_mode(adapter, &config);\r\nif (err)\r\nreturn err;\r\nmemcpy(&adapter->tstamp_config, &config,\r\nsizeof(adapter->tstamp_config));\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nvoid igb_ptp_init(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nint i;\r\nswitch (hw->mac.type) {\r\ncase e1000_82576:\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 999999881;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = igb_ptp_adjfreq_82576;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\r\nadapter->ptp_caps.gettime64 = igb_ptp_gettime_82576;\r\nadapter->ptp_caps.settime64 = igb_ptp_settime_82576;\r\nadapter->ptp_caps.enable = igb_ptp_feature_enable;\r\nadapter->cc.read = igb_ptp_read_82576;\r\nadapter->cc.mask = CYCLECOUNTER_MASK(64);\r\nadapter->cc.mult = 1;\r\nadapter->cc.shift = IGB_82576_TSYNC_SHIFT;\r\nadapter->ptp_flags |= IGB_PTP_OVERFLOW_CHECK;\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 62499999;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfine = igb_ptp_adjfine_82580;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\r\nadapter->ptp_caps.gettime64 = igb_ptp_gettime_82576;\r\nadapter->ptp_caps.settime64 = igb_ptp_settime_82576;\r\nadapter->ptp_caps.enable = igb_ptp_feature_enable;\r\nadapter->cc.read = igb_ptp_read_82580;\r\nadapter->cc.mask = CYCLECOUNTER_MASK(IGB_NBITS_82580);\r\nadapter->cc.mult = 1;\r\nadapter->cc.shift = 0;\r\nadapter->ptp_flags |= IGB_PTP_OVERFLOW_CHECK;\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nfor (i = 0; i < IGB_N_SDP; i++) {\r\nstruct ptp_pin_desc *ppd = &adapter->sdp_config[i];\r\nsnprintf(ppd->name, sizeof(ppd->name), "SDP%d", i);\r\nppd->index = i;\r\nppd->func = PTP_PF_NONE;\r\n}\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 62499999;\r\nadapter->ptp_caps.n_ext_ts = IGB_N_EXTTS;\r\nadapter->ptp_caps.n_per_out = IGB_N_PEROUT;\r\nadapter->ptp_caps.n_pins = IGB_N_SDP;\r\nadapter->ptp_caps.pps = 1;\r\nadapter->ptp_caps.pin_config = adapter->sdp_config;\r\nadapter->ptp_caps.adjfine = igb_ptp_adjfine_82580;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_i210;\r\nadapter->ptp_caps.gettime64 = igb_ptp_gettime_i210;\r\nadapter->ptp_caps.settime64 = igb_ptp_settime_i210;\r\nadapter->ptp_caps.enable = igb_ptp_feature_enable_i210;\r\nadapter->ptp_caps.verify = igb_ptp_verify_pin;\r\nbreak;\r\ndefault:\r\nadapter->ptp_clock = NULL;\r\nreturn;\r\n}\r\nspin_lock_init(&adapter->tmreg_lock);\r\nINIT_WORK(&adapter->ptp_tx_work, igb_ptp_tx_work);\r\nif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\r\nINIT_DELAYED_WORK(&adapter->ptp_overflow_work,\r\nigb_ptp_overflow_check);\r\nadapter->tstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\r\nadapter->tstamp_config.tx_type = HWTSTAMP_TX_OFF;\r\nigb_ptp_reset(adapter);\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\r\n&adapter->pdev->dev);\r\nif (IS_ERR(adapter->ptp_clock)) {\r\nadapter->ptp_clock = NULL;\r\ndev_err(&adapter->pdev->dev, "ptp_clock_register failed\n");\r\n} else if (adapter->ptp_clock) {\r\ndev_info(&adapter->pdev->dev, "added PHC on %s\n",\r\nadapter->netdev->name);\r\nadapter->ptp_flags |= IGB_PTP_ENABLED;\r\n}\r\n}\r\nvoid igb_ptp_suspend(struct igb_adapter *adapter)\r\n{\r\nif (!(adapter->ptp_flags & IGB_PTP_ENABLED))\r\nreturn;\r\nif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\r\ncancel_delayed_work_sync(&adapter->ptp_overflow_work);\r\ncancel_work_sync(&adapter->ptp_tx_work);\r\nif (adapter->ptp_tx_skb) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nclear_bit_unlock(__IGB_PTP_TX_IN_PROGRESS, &adapter->state);\r\n}\r\n}\r\nvoid igb_ptp_stop(struct igb_adapter *adapter)\r\n{\r\nigb_ptp_suspend(adapter);\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\ndev_info(&adapter->pdev->dev, "removed PHC on %s\n",\r\nadapter->netdev->name);\r\nadapter->ptp_flags &= ~IGB_PTP_ENABLED;\r\n}\r\n}\r\nvoid igb_ptp_reset(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunsigned long flags;\r\nigb_ptp_set_timestamp_mode(adapter, &adapter->tstamp_config);\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82576:\r\nwr32(E1000_TIMINCA, INCPERIOD_82576 | INCVALUE_82576);\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nwr32(E1000_TSAUXC, 0x0);\r\nwr32(E1000_TSSDP, 0x0);\r\nwr32(E1000_TSIM,\r\nTSYNC_INTERRUPTS |\r\n(adapter->pps_sys_wrap_on ? TSINTR_SYS_WRAP : 0));\r\nwr32(E1000_IMS, E1000_IMS_TS);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211)) {\r\nstruct timespec64 ts = ktime_to_timespec64(ktime_get_real());\r\nigb_ptp_write_i210(adapter, &ts);\r\n} else {\r\ntimecounter_init(&adapter->tc, &adapter->cc,\r\nktime_to_ns(ktime_get_real()));\r\n}\r\nout:\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nwrfl();\r\nif (adapter->ptp_flags & IGB_PTP_OVERFLOW_CHECK)\r\nschedule_delayed_work(&adapter->ptp_overflow_work,\r\nIGB_SYSTIM_OVERFLOW_PERIOD);\r\n}
