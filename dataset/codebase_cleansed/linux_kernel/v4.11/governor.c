static struct cpuidle_governor * __cpuidle_find_governor(const char *str)\r\n{\r\nstruct cpuidle_governor *gov;\r\nlist_for_each_entry(gov, &cpuidle_governors, governor_list)\r\nif (!strncasecmp(str, gov->name, CPUIDLE_NAME_LEN))\r\nreturn gov;\r\nreturn NULL;\r\n}\r\nint cpuidle_switch_governor(struct cpuidle_governor *gov)\r\n{\r\nstruct cpuidle_device *dev;\r\nif (gov == cpuidle_curr_governor)\r\nreturn 0;\r\ncpuidle_uninstall_idle_handler();\r\nif (cpuidle_curr_governor) {\r\nlist_for_each_entry(dev, &cpuidle_detected_devices, device_list)\r\ncpuidle_disable_device(dev);\r\n}\r\ncpuidle_curr_governor = gov;\r\nif (gov) {\r\nlist_for_each_entry(dev, &cpuidle_detected_devices, device_list)\r\ncpuidle_enable_device(dev);\r\ncpuidle_install_idle_handler();\r\nprintk(KERN_INFO "cpuidle: using governor %s\n", gov->name);\r\n}\r\nreturn 0;\r\n}\r\nint cpuidle_register_governor(struct cpuidle_governor *gov)\r\n{\r\nint ret = -EEXIST;\r\nif (!gov || !gov->select)\r\nreturn -EINVAL;\r\nif (cpuidle_disabled())\r\nreturn -ENODEV;\r\nmutex_lock(&cpuidle_lock);\r\nif (__cpuidle_find_governor(gov->name) == NULL) {\r\nret = 0;\r\nlist_add_tail(&gov->governor_list, &cpuidle_governors);\r\nif (!cpuidle_curr_governor ||\r\ncpuidle_curr_governor->rating < gov->rating)\r\ncpuidle_switch_governor(gov);\r\n}\r\nmutex_unlock(&cpuidle_lock);\r\nreturn ret;\r\n}
