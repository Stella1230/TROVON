static void spdif_irq_dpll_lock(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 locked;\r\nregmap_read(regmap, REG_SPDIF_SRPC, &locked);\r\nlocked &= SRPC_DPLL_LOCKED;\r\ndev_dbg(&pdev->dev, "isr: Rx dpll %s \n",\r\nlocked ? "locked" : "loss lock");\r\nspdif_priv->dpll_locked = locked ? true : false;\r\n}\r\nstatic void spdif_irq_sym_error(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\ndev_dbg(&pdev->dev, "isr: receiver found illegal symbol\n");\r\nif (!spdif_priv->dpll_locked)\r\nregmap_update_bits(regmap, REG_SPDIF_SIE, INT_SYM_ERR, 0);\r\n}\r\nstatic void spdif_irq_uqrx_full(struct fsl_spdif_priv *spdif_priv, char name)\r\n{\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 *pos, size, val, reg;\r\nswitch (name) {\r\ncase 'U':\r\npos = &ctrl->upos;\r\nsize = SPDIF_UBITS_SIZE;\r\nreg = REG_SPDIF_SRU;\r\nbreak;\r\ncase 'Q':\r\npos = &ctrl->qpos;\r\nsize = SPDIF_QSUB_SIZE;\r\nreg = REG_SPDIF_SRQ;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unsupported channel name\n");\r\nreturn;\r\n}\r\ndev_dbg(&pdev->dev, "isr: %c Channel receive register full\n", name);\r\nif (*pos >= size * 2) {\r\n*pos = 0;\r\n} else if (unlikely((*pos % size) + 3 > size)) {\r\ndev_err(&pdev->dev, "User bit receive buffer overflow\n");\r\nreturn;\r\n}\r\nregmap_read(regmap, reg, &val);\r\nctrl->subcode[*pos++] = val >> 16;\r\nctrl->subcode[*pos++] = val >> 8;\r\nctrl->subcode[*pos++] = val;\r\n}\r\nstatic void spdif_irq_uq_sync(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\ndev_dbg(&pdev->dev, "isr: U/Q Channel sync found\n");\r\nif (ctrl->qpos == 0)\r\nreturn;\r\nctrl->ready_buf = (ctrl->qpos - 1) / SPDIF_QSUB_SIZE + 1;\r\n}\r\nstatic void spdif_irq_uq_err(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 val;\r\ndev_dbg(&pdev->dev, "isr: U/Q Channel framing error\n");\r\nregmap_read(regmap, REG_SPDIF_SRU, &val);\r\nregmap_read(regmap, REG_SPDIF_SRQ, &val);\r\nctrl->ready_buf = 0;\r\nctrl->upos = 0;\r\nctrl->qpos = 0;\r\n}\r\nstatic u32 spdif_intr_status_clear(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 val, val2;\r\nregmap_read(regmap, REG_SPDIF_SIS, &val);\r\nregmap_read(regmap, REG_SPDIF_SIE, &val2);\r\nregmap_write(regmap, REG_SPDIF_SIC, val & val2);\r\nreturn val;\r\n}\r\nstatic irqreturn_t spdif_isr(int irq, void *devid)\r\n{\r\nstruct fsl_spdif_priv *spdif_priv = (struct fsl_spdif_priv *)devid;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 sis;\r\nsis = spdif_intr_status_clear(spdif_priv);\r\nif (sis & INT_DPLL_LOCKED)\r\nspdif_irq_dpll_lock(spdif_priv);\r\nif (sis & INT_TXFIFO_UNOV)\r\ndev_dbg(&pdev->dev, "isr: Tx FIFO under/overrun\n");\r\nif (sis & INT_TXFIFO_RESYNC)\r\ndev_dbg(&pdev->dev, "isr: Tx FIFO resync\n");\r\nif (sis & INT_CNEW)\r\ndev_dbg(&pdev->dev, "isr: cstatus new\n");\r\nif (sis & INT_VAL_NOGOOD)\r\ndev_dbg(&pdev->dev, "isr: validity flag no good\n");\r\nif (sis & INT_SYM_ERR)\r\nspdif_irq_sym_error(spdif_priv);\r\nif (sis & INT_BIT_ERR)\r\ndev_dbg(&pdev->dev, "isr: receiver found parity bit error\n");\r\nif (sis & INT_URX_FUL)\r\nspdif_irq_uqrx_full(spdif_priv, 'U');\r\nif (sis & INT_URX_OV)\r\ndev_dbg(&pdev->dev, "isr: U Channel receive register overrun\n");\r\nif (sis & INT_QRX_FUL)\r\nspdif_irq_uqrx_full(spdif_priv, 'Q');\r\nif (sis & INT_QRX_OV)\r\ndev_dbg(&pdev->dev, "isr: Q Channel receive register overrun\n");\r\nif (sis & INT_UQ_SYNC)\r\nspdif_irq_uq_sync(spdif_priv);\r\nif (sis & INT_UQ_ERR)\r\nspdif_irq_uq_err(spdif_priv);\r\nif (sis & INT_RXFIFO_UNOV)\r\ndev_dbg(&pdev->dev, "isr: Rx FIFO under/overrun\n");\r\nif (sis & INT_RXFIFO_RESYNC)\r\ndev_dbg(&pdev->dev, "isr: Rx FIFO resync\n");\r\nif (sis & INT_LOSS_LOCK)\r\nspdif_irq_dpll_lock(spdif_priv);\r\nif (sis & INT_TX_EM)\r\ndev_dbg(&pdev->dev, "isr: Tx FIFO empty\n");\r\nif (sis & INT_RXFIFO_FUL)\r\ndev_dbg(&pdev->dev, "isr: Rx FIFO full\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spdif_softreset(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 val, cycle = 1000;\r\nregcache_cache_bypass(regmap, true);\r\nregmap_write(regmap, REG_SPDIF_SCR, SCR_SOFT_RESET);\r\ndo {\r\nregmap_read(regmap, REG_SPDIF_SCR, &val);\r\n} while ((val & SCR_SOFT_RESET) && cycle--);\r\nregcache_cache_bypass(regmap, false);\r\nregcache_mark_dirty(regmap);\r\nregcache_sync(regmap);\r\nif (cycle)\r\nreturn 0;\r\nelse\r\nreturn -EBUSY;\r\n}\r\nstatic void spdif_set_cstatus(struct spdif_mixer_control *ctrl,\r\nu8 mask, u8 cstatus)\r\n{\r\nctrl->ch_status[3] &= ~mask;\r\nctrl->ch_status[3] |= cstatus & mask;\r\n}\r\nstatic void spdif_write_channel_status(struct fsl_spdif_priv *spdif_priv)\r\n{\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 ch_status;\r\nch_status = (bitrev8(ctrl->ch_status[0]) << 16) |\r\n(bitrev8(ctrl->ch_status[1]) << 8) |\r\nbitrev8(ctrl->ch_status[2]);\r\nregmap_write(regmap, REG_SPDIF_STCSCH, ch_status);\r\ndev_dbg(&pdev->dev, "STCSCH: 0x%06x\n", ch_status);\r\nch_status = bitrev8(ctrl->ch_status[3]) << 16;\r\nregmap_write(regmap, REG_SPDIF_STCSCL, ch_status);\r\ndev_dbg(&pdev->dev, "STCSCL: 0x%06x\n", ch_status);\r\n}\r\nstatic int spdif_set_rx_clksrc(struct fsl_spdif_priv *spdif_priv,\r\nenum spdif_gainsel gainsel, int dpll_locked)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu8 clksrc = spdif_priv->rxclk_src;\r\nif (clksrc >= SRPC_CLKSRC_MAX || gainsel >= GAINSEL_MULTI_MAX)\r\nreturn -EINVAL;\r\nregmap_update_bits(regmap, REG_SPDIF_SRPC,\r\nSRPC_CLKSRC_SEL_MASK | SRPC_GAINSEL_MASK,\r\nSRPC_CLKSRC_SEL_SET(clksrc) | SRPC_GAINSEL_SET(gainsel));\r\nreturn 0;\r\n}\r\nstatic int spdif_set_sample_rate(struct snd_pcm_substream *substream,\r\nint sample_rate)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nunsigned long csfs = 0;\r\nu32 stc, mask, rate;\r\nu8 clk, txclk_df, sysclk_df;\r\nint ret;\r\nswitch (sample_rate) {\r\ncase 32000:\r\nrate = SPDIF_TXRATE_32000;\r\ncsfs = IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\nrate = SPDIF_TXRATE_44100;\r\ncsfs = IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\nrate = SPDIF_TXRATE_48000;\r\ncsfs = IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 96000:\r\nrate = SPDIF_TXRATE_96000;\r\ncsfs = IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 192000:\r\nrate = SPDIF_TXRATE_192000;\r\ncsfs = IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unsupported sample rate %d\n", sample_rate);\r\nreturn -EINVAL;\r\n}\r\nclk = spdif_priv->txclk_src[rate];\r\nif (clk >= STC_TXCLK_SRC_MAX) {\r\ndev_err(&pdev->dev, "tx clock source is out of range\n");\r\nreturn -EINVAL;\r\n}\r\ntxclk_df = spdif_priv->txclk_df[rate];\r\nif (txclk_df == 0) {\r\ndev_err(&pdev->dev, "the txclk_df can't be zero\n");\r\nreturn -EINVAL;\r\n}\r\nsysclk_df = spdif_priv->sysclk_df[rate];\r\nif (clk != STC_TXCLK_SPDIF_ROOT)\r\ngoto clk_set_bypass;\r\nret = clk_set_rate(spdif_priv->txclk[rate],\r\n64 * sample_rate * txclk_df);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to set tx clock rate\n");\r\nreturn ret;\r\n}\r\nclk_set_bypass:\r\ndev_dbg(&pdev->dev, "expected clock rate = %d\n",\r\n(64 * sample_rate * txclk_df * sysclk_df));\r\ndev_dbg(&pdev->dev, "actual clock rate = %ld\n",\r\nclk_get_rate(spdif_priv->txclk[rate]));\r\nspdif_set_cstatus(ctrl, IEC958_AES3_CON_FS, csfs);\r\nstc = STC_TXCLK_ALL_EN | STC_TXCLK_SRC_SET(clk) |\r\nSTC_TXCLK_DF(txclk_df) | STC_SYSCLK_DF(sysclk_df);\r\nmask = STC_TXCLK_ALL_EN_MASK | STC_TXCLK_SRC_MASK |\r\nSTC_TXCLK_DF_MASK | STC_SYSCLK_DF_MASK;\r\nregmap_update_bits(regmap, REG_SPDIF_STC, mask, stc);\r\ndev_dbg(&pdev->dev, "set sample rate to %dHz for %dHz playback\n",\r\nspdif_priv->txrate[rate], sample_rate);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 scr, mask;\r\nint i;\r\nint ret;\r\nif (!cpu_dai->active) {\r\nret = clk_prepare_enable(spdif_priv->coreclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable core clock\n");\r\nreturn ret;\r\n}\r\nif (!IS_ERR(spdif_priv->spbaclk)) {\r\nret = clk_prepare_enable(spdif_priv->spbaclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable spba clock\n");\r\ngoto err_spbaclk;\r\n}\r\n}\r\nret = spdif_softreset(spdif_priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to soft reset\n");\r\ngoto err;\r\n}\r\nregmap_update_bits(regmap, REG_SPDIF_SIE, 0xffffff, 0);\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nscr = SCR_TXFIFO_AUTOSYNC | SCR_TXFIFO_CTRL_NORMAL |\r\nSCR_TXSEL_NORMAL | SCR_USRC_SEL_CHIP |\r\nSCR_TXFIFO_FSEL_IF8;\r\nmask = SCR_TXFIFO_AUTOSYNC_MASK | SCR_TXFIFO_CTRL_MASK |\r\nSCR_TXSEL_MASK | SCR_USRC_SEL_MASK |\r\nSCR_TXFIFO_FSEL_MASK;\r\nfor (i = 0; i < SPDIF_TXRATE_MAX; i++) {\r\nret = clk_prepare_enable(spdif_priv->txclk[i]);\r\nif (ret)\r\ngoto disable_txclk;\r\n}\r\n} else {\r\nscr = SCR_RXFIFO_FSEL_IF8 | SCR_RXFIFO_AUTOSYNC;\r\nmask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK|\r\nSCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK;\r\nret = clk_prepare_enable(spdif_priv->rxclk);\r\nif (ret)\r\ngoto err;\r\n}\r\nregmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);\r\nregmap_update_bits(regmap, REG_SPDIF_SCR, SCR_LOW_POWER, 0);\r\nreturn 0;\r\ndisable_txclk:\r\nfor (i--; i >= 0; i--)\r\nclk_disable_unprepare(spdif_priv->txclk[i]);\r\nerr:\r\nif (!IS_ERR(spdif_priv->spbaclk))\r\nclk_disable_unprepare(spdif_priv->spbaclk);\r\nerr_spbaclk:\r\nclk_disable_unprepare(spdif_priv->coreclk);\r\nreturn ret;\r\n}\r\nstatic void fsl_spdif_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 scr, mask, i;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nscr = 0;\r\nmask = SCR_TXFIFO_AUTOSYNC_MASK | SCR_TXFIFO_CTRL_MASK |\r\nSCR_TXSEL_MASK | SCR_USRC_SEL_MASK |\r\nSCR_TXFIFO_FSEL_MASK;\r\nfor (i = 0; i < SPDIF_TXRATE_MAX; i++)\r\nclk_disable_unprepare(spdif_priv->txclk[i]);\r\n} else {\r\nscr = SCR_RXFIFO_OFF | SCR_RXFIFO_CTL_ZERO;\r\nmask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK|\r\nSCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK;\r\nclk_disable_unprepare(spdif_priv->rxclk);\r\n}\r\nregmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);\r\nif (!cpu_dai->active) {\r\nspdif_intr_status_clear(spdif_priv);\r\nregmap_update_bits(regmap, REG_SPDIF_SCR,\r\nSCR_LOW_POWER, SCR_LOW_POWER);\r\nif (!IS_ERR(spdif_priv->spbaclk))\r\nclk_disable_unprepare(spdif_priv->spbaclk);\r\nclk_disable_unprepare(spdif_priv->coreclk);\r\n}\r\n}\r\nstatic int fsl_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu32 sample_rate = params_rate(params);\r\nint ret = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nret = spdif_set_sample_rate(substream, sample_rate);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: set sample rate failed: %d\n",\r\n__func__, sample_rate);\r\nreturn ret;\r\n}\r\nspdif_set_cstatus(ctrl, IEC958_AES3_CON_CLOCK,\r\nIEC958_AES3_CON_CLOCK_1000PPM);\r\nspdif_write_channel_status(spdif_priv);\r\n} else {\r\nret = spdif_set_rx_clksrc(spdif_priv, SPDIF_DEFAULT_GAINSEL, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsl_spdif_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nu32 intr = SIE_INTR_FOR(tx);\r\nu32 dmaen = SCR_DMA_xX_EN(tx);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nregmap_update_bits(regmap, REG_SPDIF_SIE, intr, intr);\r\nregmap_update_bits(regmap, REG_SPDIF_SCR, dmaen, dmaen);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nregmap_update_bits(regmap, REG_SPDIF_SCR, dmaen, 0);\r\nregmap_update_bits(regmap, REG_SPDIF_SIE, intr, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_pb_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *uvalue)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nuvalue->value.iec958.status[0] = ctrl->ch_status[0];\r\nuvalue->value.iec958.status[1] = ctrl->ch_status[1];\r\nuvalue->value.iec958.status[2] = ctrl->ch_status[2];\r\nuvalue->value.iec958.status[3] = ctrl->ch_status[3];\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_pb_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *uvalue)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nctrl->ch_status[0] = uvalue->value.iec958.status[0];\r\nctrl->ch_status[1] = uvalue->value.iec958.status[1];\r\nctrl->ch_status[2] = uvalue->value.iec958.status[2];\r\nctrl->ch_status[3] = uvalue->value.iec958.status[3];\r\nspdif_write_channel_status(spdif_priv);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_capture_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 cstatus, val;\r\nregmap_read(regmap, REG_SPDIF_SIS, &val);\r\nif (!(val & INT_CNEW))\r\nreturn -EAGAIN;\r\nregmap_read(regmap, REG_SPDIF_SRCSH, &cstatus);\r\nucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;\r\nucontrol->value.iec958.status[1] = (cstatus >> 8) & 0xFF;\r\nucontrol->value.iec958.status[2] = cstatus & 0xFF;\r\nregmap_read(regmap, REG_SPDIF_SRCSL, &cstatus);\r\nucontrol->value.iec958.status[3] = (cstatus >> 16) & 0xFF;\r\nucontrol->value.iec958.status[4] = (cstatus >> 8) & 0xFF;\r\nucontrol->value.iec958.status[5] = cstatus & 0xFF;\r\nregmap_write(regmap, REG_SPDIF_SIC, INT_CNEW);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_subcode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nunsigned long flags;\r\nint ret = -EAGAIN;\r\nspin_lock_irqsave(&ctrl->ctl_lock, flags);\r\nif (ctrl->ready_buf) {\r\nint idx = (ctrl->ready_buf - 1) * SPDIF_UBITS_SIZE;\r\nmemcpy(&ucontrol->value.iec958.subcode[0],\r\n&ctrl->subcode[idx], SPDIF_UBITS_SIZE);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&ctrl->ctl_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fsl_spdif_qinfo(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = SPDIF_QSUB_SIZE;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_qget(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\r\nunsigned long flags;\r\nint ret = -EAGAIN;\r\nspin_lock_irqsave(&ctrl->ctl_lock, flags);\r\nif (ctrl->ready_buf) {\r\nint idx = (ctrl->ready_buf - 1) * SPDIF_QSUB_SIZE;\r\nmemcpy(&ucontrol->value.bytes.data[0],\r\n&ctrl->qsub[idx], SPDIF_QSUB_SIZE);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&ctrl->ctl_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int fsl_spdif_vbit_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_vbit_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 val;\r\nregmap_read(regmap, REG_SPDIF_SIS, &val);\r\nucontrol->value.integer.value[0] = (val & INT_VAL_NOGOOD) != 0;\r\nregmap_write(regmap, REG_SPDIF_SIC, INT_VAL_NOGOOD);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_rxrate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 16000;\r\nuinfo->value.integer.max = 96000;\r\nreturn 0;\r\n}\r\nstatic int spdif_get_rxclk_rate(struct fsl_spdif_priv *spdif_priv,\r\nenum spdif_gainsel gainsel)\r\n{\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nu64 tmpval64, busclk_freq = 0;\r\nu32 freqmeas, phaseconf;\r\nu8 clksrc;\r\nregmap_read(regmap, REG_SPDIF_SRFM, &freqmeas);\r\nregmap_read(regmap, REG_SPDIF_SRPC, &phaseconf);\r\nclksrc = (phaseconf >> SRPC_CLKSRC_SEL_OFFSET) & 0xf;\r\nif (srpc_dpll_locked[clksrc] && (phaseconf & SRPC_DPLL_LOCKED))\r\nbusclk_freq = clk_get_rate(spdif_priv->sysclk);\r\ntmpval64 = (u64) busclk_freq * freqmeas;\r\ndo_div(tmpval64, gainsel_multi[gainsel] * 1024);\r\ndo_div(tmpval64, 128 * 1024);\r\ndev_dbg(&pdev->dev, "FreqMeas: %d\n", freqmeas);\r\ndev_dbg(&pdev->dev, "BusclkFreq: %lld\n", busclk_freq);\r\ndev_dbg(&pdev->dev, "RxRate: %lld\n", tmpval64);\r\nreturn (int)tmpval64;\r\n}\r\nstatic int fsl_spdif_rxrate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nint rate = 0;\r\nif (spdif_priv->dpll_locked)\r\nrate = spdif_get_rxclk_rate(spdif_priv, SPDIF_DEFAULT_GAINSEL);\r\nucontrol->value.integer.value[0] = rate;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_usync_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_usync_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 val;\r\nregmap_read(regmap, REG_SPDIF_SRCD, &val);\r\nucontrol->value.integer.value[0] = (val & SRCD_CD_USER) != 0;\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_usync_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regmap = spdif_priv->regmap;\r\nu32 val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;\r\nregmap_update_bits(regmap, REG_SPDIF_SRCD, SRCD_CD_USER, val);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct fsl_spdif_priv *spdif_private = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &spdif_private->dma_params_tx,\r\n&spdif_private->dma_params_rx);\r\nsnd_soc_add_dai_controls(dai, fsl_spdif_ctrls, ARRAY_SIZE(fsl_spdif_ctrls));\r\nreturn 0;\r\n}\r\nstatic bool fsl_spdif_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_SPDIF_SCR:\r\ncase REG_SPDIF_SRCD:\r\ncase REG_SPDIF_SRPC:\r\ncase REG_SPDIF_SIE:\r\ncase REG_SPDIF_SIS:\r\ncase REG_SPDIF_SRL:\r\ncase REG_SPDIF_SRR:\r\ncase REG_SPDIF_SRCSH:\r\ncase REG_SPDIF_SRCSL:\r\ncase REG_SPDIF_SRU:\r\ncase REG_SPDIF_SRQ:\r\ncase REG_SPDIF_STCSCH:\r\ncase REG_SPDIF_STCSCL:\r\ncase REG_SPDIF_SRFM:\r\ncase REG_SPDIF_STC:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_spdif_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_SPDIF_SRPC:\r\ncase REG_SPDIF_SIS:\r\ncase REG_SPDIF_SRL:\r\ncase REG_SPDIF_SRR:\r\ncase REG_SPDIF_SRCSH:\r\ncase REG_SPDIF_SRCSL:\r\ncase REG_SPDIF_SRU:\r\ncase REG_SPDIF_SRQ:\r\ncase REG_SPDIF_SRFM:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_spdif_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase REG_SPDIF_SCR:\r\ncase REG_SPDIF_SRCD:\r\ncase REG_SPDIF_SRPC:\r\ncase REG_SPDIF_SIE:\r\ncase REG_SPDIF_SIC:\r\ncase REG_SPDIF_STL:\r\ncase REG_SPDIF_STR:\r\ncase REG_SPDIF_STCSCH:\r\ncase REG_SPDIF_STCSCL:\r\ncase REG_SPDIF_STC:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic u32 fsl_spdif_txclk_caldiv(struct fsl_spdif_priv *spdif_priv,\r\nstruct clk *clk, u64 savesub,\r\nenum spdif_txrate index, bool round)\r\n{\r\nconst u32 rate[] = { 32000, 44100, 48000, 96000, 192000 };\r\nbool is_sysclk = clk_is_match(clk, spdif_priv->sysclk);\r\nu64 rate_ideal, rate_actual, sub;\r\nu32 sysclk_dfmin, sysclk_dfmax;\r\nu32 txclk_df, sysclk_df, arate;\r\nsysclk_dfmin = is_sysclk ? 2 : 1;\r\nsysclk_dfmax = is_sysclk ? 512 : 1;\r\nfor (sysclk_df = sysclk_dfmin; sysclk_df <= sysclk_dfmax; sysclk_df++) {\r\nfor (txclk_df = 1; txclk_df <= 128; txclk_df++) {\r\nrate_ideal = rate[index] * txclk_df * 64;\r\nif (round)\r\nrate_actual = clk_round_rate(clk, rate_ideal);\r\nelse\r\nrate_actual = clk_get_rate(clk);\r\narate = rate_actual / 64;\r\narate /= txclk_df * sysclk_df;\r\nif (arate == rate[index]) {\r\nsavesub = 0;\r\nspdif_priv->txclk_df[index] = txclk_df;\r\nspdif_priv->sysclk_df[index] = sysclk_df;\r\nspdif_priv->txrate[index] = arate;\r\ngoto out;\r\n} else if (arate / rate[index] == 1) {\r\nsub = (u64)(arate - rate[index]) * 100000;\r\ndo_div(sub, rate[index]);\r\nif (sub >= savesub)\r\ncontinue;\r\nsavesub = sub;\r\nspdif_priv->txclk_df[index] = txclk_df;\r\nspdif_priv->sysclk_df[index] = sysclk_df;\r\nspdif_priv->txrate[index] = arate;\r\n} else if (rate[index] / arate == 1) {\r\nsub = (u64)(rate[index] - arate) * 100000;\r\ndo_div(sub, rate[index]);\r\nif (sub >= savesub)\r\ncontinue;\r\nsavesub = sub;\r\nspdif_priv->txclk_df[index] = txclk_df;\r\nspdif_priv->sysclk_df[index] = sysclk_df;\r\nspdif_priv->txrate[index] = arate;\r\n}\r\n}\r\n}\r\nout:\r\nreturn savesub;\r\n}\r\nstatic int fsl_spdif_probe_txclk(struct fsl_spdif_priv *spdif_priv,\r\nenum spdif_txrate index)\r\n{\r\nconst u32 rate[] = { 32000, 44100, 48000, 96000, 192000 };\r\nstruct platform_device *pdev = spdif_priv->pdev;\r\nstruct device *dev = &pdev->dev;\r\nu64 savesub = 100000, ret;\r\nstruct clk *clk;\r\nchar tmp[16];\r\nint i;\r\nfor (i = 0; i < STC_TXCLK_SRC_MAX; i++) {\r\nsprintf(tmp, "rxtx%d", i);\r\nclk = devm_clk_get(&pdev->dev, tmp);\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "no rxtx%d clock in devicetree\n", i);\r\nreturn PTR_ERR(clk);\r\n}\r\nif (!clk_get_rate(clk))\r\ncontinue;\r\nret = fsl_spdif_txclk_caldiv(spdif_priv, clk, savesub, index,\r\ni == STC_TXCLK_SPDIF_ROOT);\r\nif (savesub == ret)\r\ncontinue;\r\nsavesub = ret;\r\nspdif_priv->txclk[index] = clk;\r\nspdif_priv->txclk_src[index] = i;\r\nif (savesub < 100)\r\nbreak;\r\n}\r\ndev_dbg(&pdev->dev, "use rxtx%d as tx clock source for %dHz sample rate\n",\r\nspdif_priv->txclk_src[index], rate[index]);\r\ndev_dbg(&pdev->dev, "use txclk df %d for %dHz sample rate\n",\r\nspdif_priv->txclk_df[index], rate[index]);\r\nif (clk_is_match(spdif_priv->txclk[index], spdif_priv->sysclk))\r\ndev_dbg(&pdev->dev, "use sysclk df %d for %dHz sample rate\n",\r\nspdif_priv->sysclk_df[index], rate[index]);\r\ndev_dbg(&pdev->dev, "the best rate for %dHz sample rate is %dHz\n",\r\nrate[index], spdif_priv->txrate[index]);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct fsl_spdif_priv *spdif_priv;\r\nstruct spdif_mixer_control *ctrl;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint irq, ret, i;\r\nif (!np)\r\nreturn -ENODEV;\r\nspdif_priv = devm_kzalloc(&pdev->dev, sizeof(*spdif_priv), GFP_KERNEL);\r\nif (!spdif_priv)\r\nreturn -ENOMEM;\r\nspdif_priv->pdev = pdev;\r\nmemcpy(&spdif_priv->cpu_dai_drv, &fsl_spdif_dai, sizeof(fsl_spdif_dai));\r\nspdif_priv->cpu_dai_drv.name = dev_name(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nspdif_priv->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"core", regs, &fsl_spdif_regmap_config);\r\nif (IS_ERR(spdif_priv->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nreturn PTR_ERR(spdif_priv->regmap);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, spdif_isr, 0,\r\ndev_name(&pdev->dev), spdif_priv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not claim irq %u\n", irq);\r\nreturn ret;\r\n}\r\nspdif_priv->sysclk = devm_clk_get(&pdev->dev, "rxtx5");\r\nif (IS_ERR(spdif_priv->sysclk)) {\r\ndev_err(&pdev->dev, "no sys clock (rxtx5) in devicetree\n");\r\nreturn PTR_ERR(spdif_priv->sysclk);\r\n}\r\nspdif_priv->coreclk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(spdif_priv->coreclk)) {\r\ndev_err(&pdev->dev, "no core clock in devicetree\n");\r\nreturn PTR_ERR(spdif_priv->coreclk);\r\n}\r\nspdif_priv->spbaclk = devm_clk_get(&pdev->dev, "spba");\r\nif (IS_ERR(spdif_priv->spbaclk))\r\ndev_warn(&pdev->dev, "no spba clock in devicetree\n");\r\nspdif_priv->rxclk = devm_clk_get(&pdev->dev, "rxtx1");\r\nif (IS_ERR(spdif_priv->rxclk)) {\r\ndev_err(&pdev->dev, "no rxtx1 clock in devicetree\n");\r\nreturn PTR_ERR(spdif_priv->rxclk);\r\n}\r\nspdif_priv->rxclk_src = DEFAULT_RXCLK_SRC;\r\nfor (i = 0; i < SPDIF_TXRATE_MAX; i++) {\r\nret = fsl_spdif_probe_txclk(spdif_priv, i);\r\nif (ret)\r\nreturn ret;\r\n}\r\nctrl = &spdif_priv->fsl_spdif_control;\r\nspin_lock_init(&ctrl->ctl_lock);\r\nctrl->ch_status[0] = IEC958_AES0_CON_NOT_COPYRIGHT |\r\nIEC958_AES0_CON_EMPHASIS_5015;\r\nctrl->ch_status[1] = IEC958_AES1_CON_DIGDIGCONV_ID;\r\nctrl->ch_status[2] = 0x00;\r\nctrl->ch_status[3] = IEC958_AES3_CON_FS_44100 |\r\nIEC958_AES3_CON_CLOCK_1000PPM;\r\nspdif_priv->dpll_locked = false;\r\nspdif_priv->dma_params_tx.maxburst = FSL_SPDIF_TXFIFO_WML;\r\nspdif_priv->dma_params_rx.maxburst = FSL_SPDIF_RXFIFO_WML;\r\nspdif_priv->dma_params_tx.addr = res->start + REG_SPDIF_STL;\r\nspdif_priv->dma_params_rx.addr = res->start + REG_SPDIF_SRL;\r\ndev_set_drvdata(&pdev->dev, spdif_priv);\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_spdif_component,\r\n&spdif_priv->cpu_dai_drv, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DAI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = imx_pcm_dma_init(pdev, IMX_SPDIF_DMABUF_SIZE);\r\nif (ret)\r\ndev_err(&pdev->dev, "imx_pcm_dma_init failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fsl_spdif_suspend(struct device *dev)\r\n{\r\nstruct fsl_spdif_priv *spdif_priv = dev_get_drvdata(dev);\r\nregmap_read(spdif_priv->regmap, REG_SPDIF_SRPC,\r\n&spdif_priv->regcache_srpc);\r\nregcache_cache_only(spdif_priv->regmap, true);\r\nregcache_mark_dirty(spdif_priv->regmap);\r\nreturn 0;\r\n}\r\nstatic int fsl_spdif_resume(struct device *dev)\r\n{\r\nstruct fsl_spdif_priv *spdif_priv = dev_get_drvdata(dev);\r\nregcache_cache_only(spdif_priv->regmap, false);\r\nregmap_update_bits(spdif_priv->regmap, REG_SPDIF_SRPC,\r\nSRPC_CLKSRC_SEL_MASK | SRPC_GAINSEL_MASK,\r\nspdif_priv->regcache_srpc);\r\nreturn regcache_sync(spdif_priv->regmap);\r\n}
