static int acp_sw_init(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nadev->acp.parent = adev->dev;\r\nadev->acp.cgs_device =\r\namdgpu_cgs_create_device(adev);\r\nif (!adev->acp.cgs_device)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int acp_sw_fini(void *handle)\r\n{\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (adev->acp.cgs_device)\r\namdgpu_cgs_destroy_device(adev->acp.cgs_device);\r\nreturn 0;\r\n}\r\nstatic int acp_suspend_tile(void *cgs_dev, int tile)\r\n{\r\nu32 val = 0;\r\nu32 count = 0;\r\nif ((tile < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {\r\npr_err("Invalid ACP tile : %d to suspend\n", tile);\r\nreturn -1;\r\n}\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0 + tile);\r\nval &= ACP_TILE_ON_MASK;\r\nif (val == 0x0) {\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);\r\nval = val | (1 << tile);\r\ncgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);\r\ncgs_write_register(cgs_dev, mmACP_PGFSM_CONFIG_REG,\r\n0x500 + tile);\r\ncount = ACP_TIMEOUT_LOOP;\r\nwhile (true) {\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0\r\n+ tile);\r\nval = val & ACP_TILE_ON_MASK;\r\nif (val == ACP_TILE_OFF_MASK)\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Timeout reading ACP PGFSM status\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);\r\nval |= ACP_TILE_OFF_RETAIN_REG_MASK;\r\ncgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_resume_tile(void *cgs_dev, int tile)\r\n{\r\nu32 val = 0;\r\nu32 count = 0;\r\nif ((tile < ACP_TILE_P1) || (tile > ACP_TILE_DSP2)) {\r\npr_err("Invalid ACP tile to resume\n");\r\nreturn -1;\r\n}\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0 + tile);\r\nval = val & ACP_TILE_ON_MASK;\r\nif (val != 0x0) {\r\ncgs_write_register(cgs_dev, mmACP_PGFSM_CONFIG_REG,\r\n0x600 + tile);\r\ncount = ACP_TIMEOUT_LOOP;\r\nwhile (true) {\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_READ_REG_0\r\n+ tile);\r\nval = val & ACP_TILE_ON_MASK;\r\nif (val == 0x0)\r\nbreak;\r\nif (--count == 0) {\r\npr_err("Timeout reading ACP PGFSM status\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(100);\r\n}\r\nval = cgs_read_register(cgs_dev, mmACP_PGFSM_RETAIN_REG);\r\nif (tile == ACP_TILE_P1)\r\nval = val & (ACP_TILE_P1_MASK);\r\nelse if (tile == ACP_TILE_P2)\r\nval = val & (ACP_TILE_P2_MASK);\r\ncgs_write_register(cgs_dev, mmACP_PGFSM_RETAIN_REG, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_poweroff(struct generic_pm_domain *genpd)\r\n{\r\nint i, ret;\r\nstruct acp_pm_domain *apd;\r\napd = container_of(genpd, struct acp_pm_domain, gpd);\r\nif (apd != NULL) {\r\nfor (i = 4; i >= 0 ; i--) {\r\nret = acp_suspend_tile(apd->cgs_dev, ACP_TILE_P1 + i);\r\nif (ret)\r\npr_err("ACP tile %d tile suspend failed\n", i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_poweron(struct generic_pm_domain *genpd)\r\n{\r\nint i, ret;\r\nstruct acp_pm_domain *apd;\r\napd = container_of(genpd, struct acp_pm_domain, gpd);\r\nif (apd != NULL) {\r\nfor (i = 0; i < 2; i++) {\r\nret = acp_resume_tile(apd->cgs_dev, ACP_TILE_P1 + i);\r\nif (ret) {\r\npr_err("ACP tile %d resume failed\n", i);\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nret = acp_suspend_tile(apd->cgs_dev, ACP_TILE_DSP0 + i);\r\nif (ret)\r\npr_err("ACP DSP %d suspend failed\n", i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct device *get_mfd_cell_dev(const char *device_name, int r)\r\n{\r\nchar auto_dev_name[25];\r\nstruct device *dev;\r\nsnprintf(auto_dev_name, sizeof(auto_dev_name),\r\n"%s.%d.auto", device_name, r);\r\ndev = bus_find_device_by_name(&platform_bus_type, NULL, auto_dev_name);\r\ndev_info(dev, "device %s added to pm domain\n", auto_dev_name);\r\nreturn dev;\r\n}\r\nstatic int acp_hw_init(void *handle)\r\n{\r\nint r, i;\r\nuint64_t acp_base;\r\nstruct device *dev;\r\nstruct i2s_platform_data *i2s_pdata;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nconst struct amdgpu_ip_block *ip_block =\r\namdgpu_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\r\nif (!ip_block)\r\nreturn -EINVAL;\r\nr = amd_acp_hw_init(adev->acp.cgs_device,\r\nip_block->version->major, ip_block->version->minor);\r\nif (r == -ENODEV)\r\nreturn 0;\r\nelse if (r)\r\nreturn r;\r\nr = cgs_get_pci_resource(adev->acp.cgs_device, CGS_RESOURCE_TYPE_MMIO,\r\n0x5289, 0, &acp_base);\r\nif (r == -ENODEV)\r\nreturn 0;\r\nelse if (r)\r\nreturn r;\r\nadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\r\nif (adev->acp.acp_genpd == NULL)\r\nreturn -ENOMEM;\r\nadev->acp.acp_genpd->gpd.name = "ACP_AUDIO";\r\nadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\r\nadev->acp.acp_genpd->gpd.power_on = acp_poweron;\r\nadev->acp.acp_genpd->cgs_dev = adev->acp.cgs_device;\r\npm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\r\nadev->acp.acp_cell = kzalloc(sizeof(struct mfd_cell) * ACP_DEVS,\r\nGFP_KERNEL);\r\nif (adev->acp.acp_cell == NULL)\r\nreturn -ENOMEM;\r\nadev->acp.acp_res = kzalloc(sizeof(struct resource) * 4, GFP_KERNEL);\r\nif (adev->acp.acp_res == NULL) {\r\nkfree(adev->acp.acp_cell);\r\nreturn -ENOMEM;\r\n}\r\ni2s_pdata = kzalloc(sizeof(struct i2s_platform_data) * 2, GFP_KERNEL);\r\nif (i2s_pdata == NULL) {\r\nkfree(adev->acp.acp_res);\r\nkfree(adev->acp.acp_cell);\r\nreturn -ENOMEM;\r\n}\r\ni2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\r\ni2s_pdata[0].cap = DWC_I2S_PLAY;\r\ni2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\r\ni2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\r\ni2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\r\ni2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\r\nDW_I2S_QUIRK_COMP_PARAM1;\r\ni2s_pdata[1].cap = DWC_I2S_RECORD;\r\ni2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\r\ni2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\r\ni2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\r\nadev->acp.acp_res[0].name = "acp2x_dma";\r\nadev->acp.acp_res[0].flags = IORESOURCE_MEM;\r\nadev->acp.acp_res[0].start = acp_base;\r\nadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\r\nadev->acp.acp_res[1].name = "acp2x_dw_i2s_play";\r\nadev->acp.acp_res[1].flags = IORESOURCE_MEM;\r\nadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\r\nadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\r\nadev->acp.acp_res[2].name = "acp2x_dw_i2s_cap";\r\nadev->acp.acp_res[2].flags = IORESOURCE_MEM;\r\nadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\r\nadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\r\nadev->acp.acp_res[3].name = "acp2x_dma_irq";\r\nadev->acp.acp_res[3].flags = IORESOURCE_IRQ;\r\nadev->acp.acp_res[3].start = amdgpu_irq_create_mapping(adev, 162);\r\nadev->acp.acp_res[3].end = adev->acp.acp_res[3].start;\r\nadev->acp.acp_cell[0].name = "acp_audio_dma";\r\nadev->acp.acp_cell[0].num_resources = 4;\r\nadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\r\nadev->acp.acp_cell[1].name = "designware-i2s";\r\nadev->acp.acp_cell[1].num_resources = 1;\r\nadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\r\nadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\r\nadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\r\nadev->acp.acp_cell[2].name = "designware-i2s";\r\nadev->acp.acp_cell[2].num_resources = 1;\r\nadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\r\nadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\r\nadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\r\nr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\r\nACP_DEVS);\r\nif (r)\r\nreturn r;\r\nfor (i = 0; i < ACP_DEVS ; i++) {\r\ndev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\r\nr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\r\nif (r) {\r\ndev_err(dev, "Failed to add dev to genpd\n");\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acp_hw_fini(void *handle)\r\n{\r\nint i, ret;\r\nstruct device *dev;\r\nstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\r\nif (!adev->acp.acp_genpd)\r\nreturn 0;\r\nfor (i = 0; i < ACP_DEVS ; i++) {\r\ndev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\r\nret = pm_genpd_remove_device(&adev->acp.acp_genpd->gpd, dev);\r\nif (ret)\r\ndev_err(dev, "remove dev from genpd failed\n");\r\n}\r\nmfd_remove_devices(adev->acp.parent);\r\nkfree(adev->acp.acp_res);\r\nkfree(adev->acp.acp_genpd);\r\nkfree(adev->acp.acp_cell);\r\nreturn 0;\r\n}\r\nstatic int acp_suspend(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acp_resume(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acp_early_init(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool acp_is_idle(void *handle)\r\n{\r\nreturn true;\r\n}\r\nstatic int acp_wait_for_idle(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acp_soft_reset(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acp_set_clockgating_state(void *handle,\r\nenum amd_clockgating_state state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acp_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nreturn 0;\r\n}
