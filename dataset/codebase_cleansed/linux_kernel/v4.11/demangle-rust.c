bool\r\nrust_is_mangled(const char *sym)\r\n{\r\nsize_t len, len_without_hash;\r\nif (!sym)\r\nreturn false;\r\nlen = strlen(sym);\r\nif (len <= hash_prefix_len + hash_len)\r\nreturn false;\r\nlen_without_hash = len - (hash_prefix_len + hash_len);\r\nif (!is_prefixed_hash(sym + len_without_hash))\r\nreturn false;\r\nreturn looks_like_rust(sym, len_without_hash);\r\n}\r\nstatic bool is_prefixed_hash(const char *str)\r\n{\r\nconst char *end;\r\nbool seen[16];\r\nsize_t i;\r\nint count;\r\nif (strncmp(str, hash_prefix, hash_prefix_len))\r\nreturn false;\r\nstr += hash_prefix_len;\r\nmemset(seen, false, sizeof(seen));\r\nfor (end = str + hash_len; str < end; str++)\r\nif (*str >= '0' && *str <= '9')\r\nseen[*str - '0'] = true;\r\nelse if (*str >= 'a' && *str <= 'f')\r\nseen[*str - 'a' + 10] = true;\r\nelse\r\nreturn false;\r\ncount = 0;\r\nfor (i = 0; i < 16; i++)\r\nif (seen[i])\r\ncount++;\r\nreturn count >= 5 && count <= 15;\r\n}\r\nstatic bool looks_like_rust(const char *str, size_t len)\r\n{\r\nconst char *end = str + len;\r\nwhile (str < end)\r\nswitch (*str) {\r\ncase '$':\r\nif (!strncmp(str, "$C$", 3))\r\nstr += 3;\r\nelse if (!strncmp(str, "$SP$", 4)\r\n|| !strncmp(str, "$BP$", 4)\r\n|| !strncmp(str, "$RF$", 4)\r\n|| !strncmp(str, "$LT$", 4)\r\n|| !strncmp(str, "$GT$", 4)\r\n|| !strncmp(str, "$LP$", 4)\r\n|| !strncmp(str, "$RP$", 4))\r\nstr += 4;\r\nelse if (!strncmp(str, "$u20$", 5)\r\n|| !strncmp(str, "$u27$", 5)\r\n|| !strncmp(str, "$u5b$", 5)\r\n|| !strncmp(str, "$u5d$", 5)\r\n|| !strncmp(str, "$u7e$", 5))\r\nstr += 5;\r\nelse\r\nreturn false;\r\nbreak;\r\ncase '.':\r\nif (!strncmp(str, "...", 3))\r\nreturn false;\r\ncase 'a' ... 'z':\r\ncase 'A' ... 'Z':\r\ncase '0' ... '9':\r\ncase '_':\r\ncase ':':\r\nstr++;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid\r\nrust_demangle_sym(char *sym)\r\n{\r\nconst char *in;\r\nchar *out;\r\nconst char *end;\r\nif (!sym)\r\nreturn;\r\nin = sym;\r\nout = sym;\r\nend = sym + strlen(sym) - (hash_prefix_len + hash_len);\r\nwhile (in < end)\r\nswitch (*in) {\r\ncase '$':\r\nif (!(unescape(&in, &out, "$C$", ',')\r\n|| unescape(&in, &out, "$SP$", '@')\r\n|| unescape(&in, &out, "$BP$", '*')\r\n|| unescape(&in, &out, "$RF$", '&')\r\n|| unescape(&in, &out, "$LT$", '<')\r\n|| unescape(&in, &out, "$GT$", '>')\r\n|| unescape(&in, &out, "$LP$", '(')\r\n|| unescape(&in, &out, "$RP$", ')')\r\n|| unescape(&in, &out, "$u20$", ' ')\r\n|| unescape(&in, &out, "$u27$", '\'')\r\n|| unescape(&in, &out, "$u5b$", '[')\r\n|| unescape(&in, &out, "$u5d$", ']')\r\n|| unescape(&in, &out, "$u7e$", '~'))) {\r\npr_err("demangle-rust: unexpected escape sequence");\r\ngoto done;\r\n}\r\nbreak;\r\ncase '_':\r\nif ((in == sym || in[-1] == ':') && in[1] == '$')\r\nin++;\r\nelse\r\n*out++ = *in++;\r\nbreak;\r\ncase '.':\r\nif (in[1] == '.') {\r\n*out++ = ':';\r\n*out++ = ':';\r\nin += 2;\r\n} else {\r\n*out++ = '-';\r\nin++;\r\n}\r\nbreak;\r\ncase 'a' ... 'z':\r\ncase 'A' ... 'Z':\r\ncase '0' ... '9':\r\ncase ':':\r\n*out++ = *in++;\r\nbreak;\r\ndefault:\r\npr_err("demangle-rust: unexpected character '%c' in symbol\n",\r\n*in);\r\ngoto done;\r\n}\r\ndone:\r\n*out = '\0';\r\n}\r\nstatic bool unescape(const char **in, char **out, const char *seq, char value)\r\n{\r\nsize_t len = strlen(seq);\r\nif (strncmp(*in, seq, len))\r\nreturn false;\r\n**out = value;\r\n*in += len;\r\n*out += 1;\r\nreturn true;\r\n}
