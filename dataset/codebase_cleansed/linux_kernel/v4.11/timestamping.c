static unsigned int classify(const struct sk_buff *skb)\r\n{\r\nif (likely(skb->dev && skb->dev->phydev &&\r\nskb->dev->phydev->drv))\r\nreturn ptp_classify_raw(skb);\r\nelse\r\nreturn PTP_CLASS_NONE;\r\n}\r\nvoid skb_clone_tx_timestamp(struct sk_buff *skb)\r\n{\r\nstruct phy_device *phydev;\r\nstruct sk_buff *clone;\r\nunsigned int type;\r\nif (!skb->sk)\r\nreturn;\r\ntype = classify(skb);\r\nif (type == PTP_CLASS_NONE)\r\nreturn;\r\nphydev = skb->dev->phydev;\r\nif (likely(phydev->drv->txtstamp)) {\r\nclone = skb_clone_sk(skb);\r\nif (!clone)\r\nreturn;\r\nphydev->drv->txtstamp(phydev, clone, type);\r\n}\r\n}\r\nbool skb_defer_rx_timestamp(struct sk_buff *skb)\r\n{\r\nstruct phy_device *phydev;\r\nunsigned int type;\r\nif (!skb->dev || !skb->dev->phydev || !skb->dev->phydev->drv)\r\nreturn false;\r\nif (skb_headroom(skb) < ETH_HLEN)\r\nreturn false;\r\n__skb_push(skb, ETH_HLEN);\r\ntype = ptp_classify_raw(skb);\r\n__skb_pull(skb, ETH_HLEN);\r\nif (type == PTP_CLASS_NONE)\r\nreturn false;\r\nphydev = skb->dev->phydev;\r\nif (likely(phydev->drv->rxtstamp))\r\nreturn phydev->drv->rxtstamp(phydev, skb, type);\r\nreturn false;\r\n}
