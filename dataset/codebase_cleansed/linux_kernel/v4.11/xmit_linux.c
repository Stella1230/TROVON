uint rtw_remainder_len(struct pkt_file *pfile)\r\n{\r\nreturn pfile->buf_len - ((size_t)(pfile->cur_addr) -\r\n(size_t)(pfile->buf_start));\r\n}\r\nvoid _rtw_open_pktfile(struct sk_buff *pktptr, struct pkt_file *pfile)\r\n{\r\npfile->pkt = pktptr;\r\npfile->cur_addr = pktptr->data;\r\npfile->buf_start = pktptr->data;\r\npfile->pkt_len = pktptr->len;\r\npfile->buf_len = pktptr->len;\r\npfile->cur_buffer = pfile->buf_start;\r\n}\r\nuint _rtw_pktfile_read(struct pkt_file *pfile, u8 *rmem, uint rlen)\r\n{\r\nuint len = 0;\r\nlen = rtw_remainder_len(pfile);\r\nlen = min(rlen, len);\r\nif (rmem)\r\nskb_copy_bits(pfile->pkt, pfile->buf_len-pfile->pkt_len, rmem, len);\r\npfile->cur_addr += len;\r\npfile->pkt_len -= len;\r\nreturn len;\r\n}\r\nint rtw_os_xmit_resource_alloc(struct adapter *padapter, struct xmit_buf *pxmitbuf, u32 alloc_sz)\r\n{\r\nint i;\r\npxmitbuf->pallocated_buf = kzalloc(alloc_sz, GFP_KERNEL);\r\nif (pxmitbuf->pallocated_buf == NULL)\r\nreturn _FAIL;\r\npxmitbuf->pbuf = PTR_ALIGN(pxmitbuf->pallocated_buf, XMITBUF_ALIGN_SZ);\r\npxmitbuf->dma_transfer_addr = 0;\r\nfor (i = 0; i < 8; i++) {\r\npxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (pxmitbuf->pxmit_urb[i] == NULL) {\r\nDBG_88E("pxmitbuf->pxmit_urb[i]==NULL");\r\nreturn _FAIL;\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nvoid rtw_os_xmit_resource_free(struct xmit_buf *pxmitbuf)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nusb_free_urb(pxmitbuf->pxmit_urb[i]);\r\nkfree(pxmitbuf->pallocated_buf);\r\n}\r\nvoid rtw_os_pkt_complete(struct adapter *padapter, struct sk_buff *pkt)\r\n{\r\nu16 queue;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nqueue = skb_get_queue_mapping(pkt);\r\nif (padapter->registrypriv.wifi_spec) {\r\nif (__netif_subqueue_stopped(padapter->pnetdev, queue) &&\r\n(pxmitpriv->hwxmits[queue].accnt < WMM_XMIT_THRESHOLD))\r\nnetif_wake_subqueue(padapter->pnetdev, queue);\r\n} else {\r\nif (__netif_subqueue_stopped(padapter->pnetdev, queue))\r\nnetif_wake_subqueue(padapter->pnetdev, queue);\r\n}\r\ndev_kfree_skb_any(pkt);\r\n}\r\nvoid rtw_os_xmit_complete(struct adapter *padapter, struct xmit_frame *pxframe)\r\n{\r\nif (pxframe->pkt)\r\nrtw_os_pkt_complete(padapter, pxframe->pkt);\r\npxframe->pkt = NULL;\r\n}\r\nvoid rtw_os_xmit_schedule(struct adapter *padapter)\r\n{\r\nstruct xmit_priv *pxmitpriv;\r\nif (!padapter)\r\nreturn;\r\npxmitpriv = &padapter->xmitpriv;\r\nspin_lock_bh(&pxmitpriv->lock);\r\nif (rtw_txframes_pending(padapter))\r\ntasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\r\nspin_unlock_bh(&pxmitpriv->lock);\r\n}\r\nstatic void rtw_check_xmit_resource(struct adapter *padapter, struct sk_buff *pkt)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu16 queue;\r\nqueue = skb_get_queue_mapping(pkt);\r\nif (padapter->registrypriv.wifi_spec) {\r\nif (pxmitpriv->hwxmits[queue].accnt > WMM_XMIT_THRESHOLD)\r\nnetif_stop_subqueue(padapter->pnetdev, queue);\r\n} else {\r\nif (pxmitpriv->free_xmitframe_cnt <= 4) {\r\nif (!netif_tx_queue_stopped(netdev_get_tx_queue(padapter->pnetdev, queue)))\r\nnetif_stop_subqueue(padapter->pnetdev, queue);\r\n}\r\n}\r\n}\r\nstatic int rtw_mlcst2unicst(struct adapter *padapter, struct sk_buff *skb)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct list_head *phead, *plist;\r\nstruct sk_buff *newskb;\r\nstruct sta_info *psta = NULL;\r\ns32 res;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nplist = plist->next;\r\nif (!memcmp(psta->hwaddr, &skb->data[6], 6))\r\ncontinue;\r\nnewskb = skb_copy(skb, GFP_ATOMIC);\r\nif (newskb) {\r\nmemcpy(newskb->data, psta->hwaddr, 6);\r\nres = rtw_xmit(padapter, &newskb);\r\nif (res < 0) {\r\nDBG_88E("%s()-%d: rtw_xmit() return error!\n", __func__, __LINE__);\r\npxmitpriv->tx_drop++;\r\ndev_kfree_skb_any(newskb);\r\n} else {\r\npxmitpriv->tx_pkts++;\r\n}\r\n} else {\r\nDBG_88E("%s-%d: skb_copy() failed!\n", __func__, __LINE__);\r\npxmitpriv->tx_drop++;\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nreturn false;\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\ndev_kfree_skb_any(skb);\r\nreturn true;\r\n}\r\nint rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(pnetdev);\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\ns32 res = 0;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));\r\nif (rtw_if_up(padapter) == false) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));\r\ngoto drop_packet;\r\n}\r\nrtw_check_xmit_resource(padapter, pkt);\r\nif (!rtw_mc2u_disable && check_fwstate(pmlmepriv, WIFI_AP_STATE) &&\r\n(IP_MCAST_MAC(pkt->data) || ICMPV6_MCAST_MAC(pkt->data)) &&\r\n(padapter->registrypriv.wifi_spec == 0)) {\r\nif (pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4)) {\r\nres = rtw_mlcst2unicst(padapter, pkt);\r\nif (res)\r\ngoto exit;\r\n}\r\n}\r\nres = rtw_xmit(padapter, &pkt);\r\nif (res < 0)\r\ngoto drop_packet;\r\npxmitpriv->tx_pkts++;\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_info_, ("rtw_xmit_entry: tx_pkts=%d\n", (u32)pxmitpriv->tx_pkts));\r\ngoto exit;\r\ndrop_packet:\r\npxmitpriv->tx_drop++;\r\ndev_kfree_skb_any(pkt);\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));\r\nexit:\r\nreturn 0;\r\n}
