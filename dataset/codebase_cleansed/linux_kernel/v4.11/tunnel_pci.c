static void tb_pci_init_path(struct tb_path *path)\r\n{\r\npath->egress_fc_enable = TB_PATH_SOURCE | TB_PATH_INTERNAL;\r\npath->egress_shared_buffer = TB_PATH_NONE;\r\npath->ingress_fc_enable = TB_PATH_ALL;\r\npath->ingress_shared_buffer = TB_PATH_NONE;\r\npath->priority = 3;\r\npath->weight = 1;\r\npath->drop_packages = 0;\r\npath->nfc_credits = 0;\r\n}\r\nstruct tb_pci_tunnel *tb_pci_alloc(struct tb *tb, struct tb_port *up,\r\nstruct tb_port *down)\r\n{\r\nstruct tb_pci_tunnel *tunnel = kzalloc(sizeof(*tunnel), GFP_KERNEL);\r\nif (!tunnel)\r\ngoto err;\r\ntunnel->tb = tb;\r\ntunnel->down_port = down;\r\ntunnel->up_port = up;\r\nINIT_LIST_HEAD(&tunnel->list);\r\ntunnel->path_to_up = tb_path_alloc(up->sw->tb, 2);\r\nif (!tunnel->path_to_up)\r\ngoto err;\r\ntunnel->path_to_down = tb_path_alloc(up->sw->tb, 2);\r\nif (!tunnel->path_to_down)\r\ngoto err;\r\ntb_pci_init_path(tunnel->path_to_up);\r\ntb_pci_init_path(tunnel->path_to_down);\r\ntunnel->path_to_up->hops[0].in_port = down;\r\ntunnel->path_to_up->hops[0].in_hop_index = 8;\r\ntunnel->path_to_up->hops[0].in_counter_index = -1;\r\ntunnel->path_to_up->hops[0].out_port = tb_upstream_port(up->sw)->remote;\r\ntunnel->path_to_up->hops[0].next_hop_index = 8;\r\ntunnel->path_to_up->hops[1].in_port = tb_upstream_port(up->sw);\r\ntunnel->path_to_up->hops[1].in_hop_index = 8;\r\ntunnel->path_to_up->hops[1].in_counter_index = -1;\r\ntunnel->path_to_up->hops[1].out_port = up;\r\ntunnel->path_to_up->hops[1].next_hop_index = 8;\r\ntunnel->path_to_down->hops[0].in_port = up;\r\ntunnel->path_to_down->hops[0].in_hop_index = 8;\r\ntunnel->path_to_down->hops[0].in_counter_index = -1;\r\ntunnel->path_to_down->hops[0].out_port = tb_upstream_port(up->sw);\r\ntunnel->path_to_down->hops[0].next_hop_index = 8;\r\ntunnel->path_to_down->hops[1].in_port =\r\ntb_upstream_port(up->sw)->remote;\r\ntunnel->path_to_down->hops[1].in_hop_index = 8;\r\ntunnel->path_to_down->hops[1].in_counter_index = -1;\r\ntunnel->path_to_down->hops[1].out_port = down;\r\ntunnel->path_to_down->hops[1].next_hop_index = 8;\r\nreturn tunnel;\r\nerr:\r\nif (tunnel) {\r\nif (tunnel->path_to_down)\r\ntb_path_free(tunnel->path_to_down);\r\nif (tunnel->path_to_up)\r\ntb_path_free(tunnel->path_to_up);\r\nkfree(tunnel);\r\n}\r\nreturn NULL;\r\n}\r\nvoid tb_pci_free(struct tb_pci_tunnel *tunnel)\r\n{\r\nif (tunnel->path_to_up->activated || tunnel->path_to_down->activated) {\r\ntb_tunnel_WARN(tunnel, "trying to free an activated tunnel\n");\r\nreturn;\r\n}\r\ntb_path_free(tunnel->path_to_up);\r\ntb_path_free(tunnel->path_to_down);\r\nkfree(tunnel);\r\n}\r\nbool tb_pci_is_invalid(struct tb_pci_tunnel *tunnel)\r\n{\r\nWARN_ON(!tunnel->path_to_up->activated);\r\nWARN_ON(!tunnel->path_to_down->activated);\r\nreturn tb_path_is_invalid(tunnel->path_to_up)\r\n|| tb_path_is_invalid(tunnel->path_to_down);\r\n}\r\nstatic int tb_pci_port_active(struct tb_port *port, bool active)\r\n{\r\nu32 word = active ? 0x80000000 : 0x0;\r\nint cap = tb_find_cap(port, TB_CFG_PORT, TB_CAP_PCIE);\r\nif (cap <= 0) {\r\ntb_port_warn(port, "TB_CAP_PCIE not found: %d\n", cap);\r\nreturn cap ? cap : -ENXIO;\r\n}\r\nreturn tb_port_write(port, &word, TB_CFG_PORT, cap, 1);\r\n}\r\nint tb_pci_restart(struct tb_pci_tunnel *tunnel)\r\n{\r\nint res;\r\ntunnel->path_to_up->activated = false;\r\ntunnel->path_to_down->activated = false;\r\ntb_tunnel_info(tunnel, "activating\n");\r\nres = tb_path_activate(tunnel->path_to_up);\r\nif (res)\r\ngoto err;\r\nres = tb_path_activate(tunnel->path_to_down);\r\nif (res)\r\ngoto err;\r\nres = tb_pci_port_active(tunnel->down_port, true);\r\nif (res)\r\ngoto err;\r\nres = tb_pci_port_active(tunnel->up_port, true);\r\nif (res)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ntb_tunnel_warn(tunnel, "activation failed\n");\r\ntb_pci_deactivate(tunnel);\r\nreturn res;\r\n}\r\nint tb_pci_activate(struct tb_pci_tunnel *tunnel)\r\n{\r\nint res;\r\nif (tunnel->path_to_up->activated || tunnel->path_to_down->activated) {\r\ntb_tunnel_WARN(tunnel,\r\n"trying to activate an already activated tunnel\n");\r\nreturn -EINVAL;\r\n}\r\nres = tb_pci_restart(tunnel);\r\nif (res)\r\nreturn res;\r\nlist_add(&tunnel->list, &tunnel->tb->tunnel_list);\r\nreturn 0;\r\n}\r\nvoid tb_pci_deactivate(struct tb_pci_tunnel *tunnel)\r\n{\r\ntb_tunnel_info(tunnel, "deactivating\n");\r\ntb_pci_port_active(tunnel->up_port, false);\r\ntb_pci_port_active(tunnel->down_port, false);\r\nif (tunnel->path_to_down->activated)\r\ntb_path_deactivate(tunnel->path_to_down);\r\nif (tunnel->path_to_up->activated)\r\ntb_path_deactivate(tunnel->path_to_up);\r\nlist_del_init(&tunnel->list);\r\n}
