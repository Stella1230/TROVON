bool nouveau_is_optimus(void) {\r\nreturn nouveau_dsm_priv.optimus_detected;\r\n}\r\nbool nouveau_is_v1_dsm(void) {\r\nreturn nouveau_dsm_priv.dsm_detected;\r\n}\r\nstatic int nouveau_optimus_dsm(acpi_handle handle, int func, int arg, uint32_t *result)\r\n{\r\nint i;\r\nunion acpi_object *obj;\r\nchar args_buff[4];\r\nunion acpi_object argv4 = {\r\n.buffer.type = ACPI_TYPE_BUFFER,\r\n.buffer.length = 4,\r\n.buffer.pointer = args_buff\r\n};\r\nfor (i = 0; i < 4; i++)\r\nargs_buff[i] = (arg >> i * 8) & 0xFF;\r\n*result = 0;\r\nobj = acpi_evaluate_dsm_typed(handle, nouveau_op_dsm_muid, 0x00000100,\r\nfunc, &argv4, ACPI_TYPE_BUFFER);\r\nif (!obj) {\r\nacpi_handle_info(handle, "failed to evaluate _DSM\n");\r\nreturn AE_ERROR;\r\n} else {\r\nif (obj->buffer.length == 4) {\r\n*result |= obj->buffer.pointer[0];\r\n*result |= (obj->buffer.pointer[1] << 8);\r\n*result |= (obj->buffer.pointer[2] << 16);\r\n*result |= (obj->buffer.pointer[3] << 24);\r\n}\r\nACPI_FREE(obj);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nouveau_dsm_get_optimus_functions(acpi_handle handle)\r\n{\r\nint result;\r\nif (nouveau_optimus_dsm(handle, 0, 0, &result))\r\nreturn 0;\r\nif (result & 1 && result & (1 << NOUVEAU_DSM_OPTIMUS_CAPS))\r\nreturn result;\r\nreturn 0;\r\n}\r\nstatic int nouveau_dsm(acpi_handle handle, int func, int arg)\r\n{\r\nint ret = 0;\r\nunion acpi_object *obj;\r\nunion acpi_object argv4 = {\r\n.integer.type = ACPI_TYPE_INTEGER,\r\n.integer.value = arg,\r\n};\r\nobj = acpi_evaluate_dsm_typed(handle, nouveau_dsm_muid, 0x00000102,\r\nfunc, &argv4, ACPI_TYPE_INTEGER);\r\nif (!obj) {\r\nacpi_handle_info(handle, "failed to evaluate _DSM\n");\r\nreturn AE_ERROR;\r\n} else {\r\nif (obj->integer.value == 0x80000002)\r\nret = -ENODEV;\r\nACPI_FREE(obj);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nouveau_dsm_switch_mux(acpi_handle handle, int mux_id)\r\n{\r\nmxm_wmi_call_mxmx(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\r\nmxm_wmi_call_mxds(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\r\nreturn nouveau_dsm(handle, NOUVEAU_DSM_LED, mux_id);\r\n}\r\nstatic int nouveau_dsm_set_discrete_state(acpi_handle handle, enum vga_switcheroo_state state)\r\n{\r\nint arg;\r\nif (state == VGA_SWITCHEROO_ON)\r\narg = NOUVEAU_DSM_POWER_SPEED;\r\nelse\r\narg = NOUVEAU_DSM_POWER_STAMINA;\r\nnouveau_dsm(handle, NOUVEAU_DSM_POWER, arg);\r\nreturn 0;\r\n}\r\nstatic int nouveau_dsm_switchto(enum vga_switcheroo_client_id id)\r\n{\r\nif (!nouveau_dsm_priv.dsm_detected)\r\nreturn 0;\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_STAMINA);\r\nelse\r\nreturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_SPEED);\r\n}\r\nstatic int nouveau_dsm_power_state(enum vga_switcheroo_client_id id,\r\nenum vga_switcheroo_state state)\r\n{\r\nif (id == VGA_SWITCHEROO_IGD)\r\nreturn 0;\r\nif (!nouveau_dsm_priv.dsm_detected)\r\nreturn 0;\r\nreturn nouveau_dsm_set_discrete_state(nouveau_dsm_priv.dhandle, state);\r\n}\r\nstatic int nouveau_dsm_get_client_id(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL)\r\nreturn VGA_SWITCHEROO_IGD;\r\nif (pdev->bus->number == 0)\r\nreturn VGA_SWITCHEROO_IGD;\r\nreturn VGA_SWITCHEROO_DIS;\r\n}\r\nstatic bool nouveau_pr3_present(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *parent_pdev = pci_upstream_bridge(pdev);\r\nstruct acpi_device *parent_adev;\r\nif (!parent_pdev)\r\nreturn false;\r\nif (!parent_pdev->bridge_d3) {\r\npci_d3cold_disable(pdev);\r\nreturn false;\r\n}\r\nparent_adev = ACPI_COMPANION(&parent_pdev->dev);\r\nif (!parent_adev)\r\nreturn false;\r\nreturn parent_adev->power.flags.power_resources &&\r\nacpi_has_method(parent_adev->handle, "_PR3");\r\n}\r\nstatic void nouveau_dsm_pci_probe(struct pci_dev *pdev, acpi_handle *dhandle_out,\r\nbool *has_mux, bool *has_opt,\r\nbool *has_opt_flags, bool *has_pr3)\r\n{\r\nacpi_handle dhandle;\r\nbool supports_mux;\r\nint optimus_funcs;\r\ndhandle = ACPI_HANDLE(&pdev->dev);\r\nif (!dhandle)\r\nreturn;\r\nif (!acpi_has_method(dhandle, "_DSM"))\r\nreturn;\r\nsupports_mux = acpi_check_dsm(dhandle, nouveau_dsm_muid, 0x00000102,\r\n1 << NOUVEAU_DSM_POWER);\r\noptimus_funcs = nouveau_dsm_get_optimus_functions(dhandle);\r\nif (!supports_mux && !optimus_funcs)\r\nreturn;\r\n*dhandle_out = dhandle;\r\n*has_mux = supports_mux;\r\n*has_opt = !!optimus_funcs;\r\n*has_opt_flags = optimus_funcs & (1 << NOUVEAU_DSM_OPTIMUS_FLAGS);\r\n*has_pr3 = false;\r\nif (optimus_funcs) {\r\nuint32_t result;\r\nnouveau_optimus_dsm(dhandle, NOUVEAU_DSM_OPTIMUS_CAPS, 0,\r\n&result);\r\ndev_info(&pdev->dev, "optimus capabilities: %s, status %s%s\n",\r\n(result & OPTIMUS_ENABLED) ? "enabled" : "disabled",\r\n(result & OPTIMUS_DYNAMIC_PWR_CAP) ? "dynamic power, " : "",\r\n(result & OPTIMUS_HDA_CODEC_MASK) ? "hda bios codec supported" : "");\r\n*has_pr3 = nouveau_pr3_present(pdev);\r\n}\r\n}\r\nstatic bool nouveau_dsm_detect(void)\r\n{\r\nchar acpi_method_name[255] = { 0 };\r\nstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\r\nstruct pci_dev *pdev = NULL;\r\nacpi_handle dhandle = NULL;\r\nbool has_mux = false;\r\nbool has_optimus = false;\r\nbool has_optimus_flags = false;\r\nbool has_power_resources = false;\r\nint vga_count = 0;\r\nbool guid_valid;\r\nbool ret = false;\r\nguid_valid = mxm_wmi_supported();\r\nif (guid_valid)\r\nprintk("MXM: GUID detected in BIOS\n");\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\r\nvga_count++;\r\nnouveau_dsm_pci_probe(pdev, &dhandle, &has_mux, &has_optimus,\r\n&has_optimus_flags, &has_power_resources);\r\n}\r\nwhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_3D << 8, pdev)) != NULL) {\r\nvga_count++;\r\nnouveau_dsm_pci_probe(pdev, &dhandle, &has_mux, &has_optimus,\r\n&has_optimus_flags, &has_power_resources);\r\n}\r\nif (has_optimus) {\r\nnouveau_dsm_priv.dhandle = dhandle;\r\nacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\r\n&buffer);\r\nprintk(KERN_INFO "VGA switcheroo: detected Optimus DSM method %s handle\n",\r\nacpi_method_name);\r\nif (has_power_resources)\r\npr_info("nouveau: detected PR support, will not use DSM\n");\r\nnouveau_dsm_priv.optimus_detected = true;\r\nnouveau_dsm_priv.optimus_flags_detected = has_optimus_flags;\r\nnouveau_dsm_priv.optimus_skip_dsm = has_power_resources;\r\nret = true;\r\n} else if (vga_count == 2 && has_mux && guid_valid) {\r\nnouveau_dsm_priv.dhandle = dhandle;\r\nacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\r\n&buffer);\r\nprintk(KERN_INFO "VGA switcheroo: detected DSM switching method %s handle\n",\r\nacpi_method_name);\r\nnouveau_dsm_priv.dsm_detected = true;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nvoid nouveau_register_dsm_handler(void)\r\n{\r\nbool r;\r\nr = nouveau_dsm_detect();\r\nif (!r)\r\nreturn;\r\nvga_switcheroo_register_handler(&nouveau_dsm_handler, 0);\r\n}\r\nvoid nouveau_switcheroo_optimus_dsm(void)\r\n{\r\nu32 result = 0;\r\nif (!nouveau_dsm_priv.optimus_detected || nouveau_dsm_priv.optimus_skip_dsm)\r\nreturn;\r\nif (nouveau_dsm_priv.optimus_flags_detected)\r\nnouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_FLAGS,\r\n0x3, &result);\r\nnouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_CAPS,\r\nNOUVEAU_DSM_OPTIMUS_SET_POWERDOWN, &result);\r\n}\r\nvoid nouveau_unregister_dsm_handler(void)\r\n{\r\nif (nouveau_dsm_priv.optimus_detected || nouveau_dsm_priv.dsm_detected)\r\nvga_switcheroo_unregister_handler();\r\n}\r\nvoid nouveau_register_dsm_handler(void) {}\r\nvoid nouveau_unregister_dsm_handler(void) {}\r\nvoid nouveau_switcheroo_optimus_dsm(void) {}\r\nstatic int nouveau_rom_call(acpi_handle rom_handle, uint8_t *bios,\r\nint offset, int len)\r\n{\r\nacpi_status status;\r\nunion acpi_object rom_arg_elements[2], *obj;\r\nstruct acpi_object_list rom_arg;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\r\nrom_arg.count = 2;\r\nrom_arg.pointer = &rom_arg_elements[0];\r\nrom_arg_elements[0].type = ACPI_TYPE_INTEGER;\r\nrom_arg_elements[0].integer.value = offset;\r\nrom_arg_elements[1].type = ACPI_TYPE_INTEGER;\r\nrom_arg_elements[1].integer.value = len;\r\nstatus = acpi_evaluate_object(rom_handle, NULL, &rom_arg, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_INFO "failed to evaluate ROM got %s\n", acpi_format_exception(status));\r\nreturn -ENODEV;\r\n}\r\nobj = (union acpi_object *)buffer.pointer;\r\nlen = min(len, (int)obj->buffer.length);\r\nmemcpy(bios+offset, obj->buffer.pointer, len);\r\nkfree(buffer.pointer);\r\nreturn len;\r\n}\r\nbool nouveau_acpi_rom_supported(struct device *dev)\r\n{\r\nacpi_status status;\r\nacpi_handle dhandle, rom_handle;\r\ndhandle = ACPI_HANDLE(dev);\r\nif (!dhandle)\r\nreturn false;\r\nstatus = acpi_get_handle(dhandle, "_ROM", &rom_handle);\r\nif (ACPI_FAILURE(status))\r\nreturn false;\r\nnouveau_dsm_priv.rom_handle = rom_handle;\r\nreturn true;\r\n}\r\nint nouveau_acpi_get_bios_chunk(uint8_t *bios, int offset, int len)\r\n{\r\nreturn nouveau_rom_call(nouveau_dsm_priv.rom_handle, bios, offset, len);\r\n}\r\nvoid *\r\nnouveau_acpi_edid(struct drm_device *dev, struct drm_connector *connector)\r\n{\r\nstruct acpi_device *acpidev;\r\nacpi_handle handle;\r\nint type, ret;\r\nvoid *edid;\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\ncase DRM_MODE_CONNECTOR_eDP:\r\ntype = ACPI_VIDEO_DISPLAY_LCD;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nhandle = ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle)\r\nreturn NULL;\r\nret = acpi_bus_get_device(handle, &acpidev);\r\nif (ret)\r\nreturn NULL;\r\nret = acpi_video_get_edid(acpidev, type, -1, &edid);\r\nif (ret < 0)\r\nreturn NULL;\r\nreturn kmemdup(edid, EDID_LENGTH, GFP_KERNEL);\r\n}
