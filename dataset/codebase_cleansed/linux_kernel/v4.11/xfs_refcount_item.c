static inline struct xfs_cui_log_item *CUI_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_cui_log_item, cui_item);\r\n}\r\nvoid\r\nxfs_cui_item_free(\r\nstruct xfs_cui_log_item *cuip)\r\n{\r\nif (cuip->cui_format.cui_nextents > XFS_CUI_MAX_FAST_EXTENTS)\r\nkmem_free(cuip);\r\nelse\r\nkmem_zone_free(xfs_cui_zone, cuip);\r\n}\r\nSTATIC void\r\nxfs_cui_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\nstruct xfs_cui_log_item *cuip = CUI_ITEM(lip);\r\n*nvecs += 1;\r\n*nbytes += xfs_cui_log_format_sizeof(cuip->cui_format.cui_nextents);\r\n}\r\nSTATIC void\r\nxfs_cui_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_cui_log_item *cuip = CUI_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(atomic_read(&cuip->cui_next_extent) ==\r\ncuip->cui_format.cui_nextents);\r\ncuip->cui_format.cui_type = XFS_LI_CUI;\r\ncuip->cui_format.cui_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_CUI_FORMAT, &cuip->cui_format,\r\nxfs_cui_log_format_sizeof(cuip->cui_format.cui_nextents));\r\n}\r\nSTATIC void\r\nxfs_cui_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_cui_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\nstruct xfs_cui_log_item *cuip = CUI_ITEM(lip);\r\nxfs_cui_release(cuip);\r\n}\r\nSTATIC uint\r\nxfs_cui_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_cui_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_cui_item_free(CUI_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_cui_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_cui_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_cui_log_item *\r\nxfs_cui_init(\r\nstruct xfs_mount *mp,\r\nuint nextents)\r\n{\r\nstruct xfs_cui_log_item *cuip;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_CUI_MAX_FAST_EXTENTS)\r\ncuip = kmem_zalloc(xfs_cui_log_item_sizeof(nextents),\r\nKM_SLEEP);\r\nelse\r\ncuip = kmem_zone_zalloc(xfs_cui_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &cuip->cui_item, XFS_LI_CUI, &xfs_cui_item_ops);\r\ncuip->cui_format.cui_nextents = nextents;\r\ncuip->cui_format.cui_id = (uintptr_t)(void *)cuip;\r\natomic_set(&cuip->cui_next_extent, 0);\r\natomic_set(&cuip->cui_refcount, 2);\r\nreturn cuip;\r\n}\r\nvoid\r\nxfs_cui_release(\r\nstruct xfs_cui_log_item *cuip)\r\n{\r\nif (atomic_dec_and_test(&cuip->cui_refcount)) {\r\nxfs_trans_ail_remove(&cuip->cui_item, SHUTDOWN_LOG_IO_ERROR);\r\nxfs_cui_item_free(cuip);\r\n}\r\n}\r\nstatic inline struct xfs_cud_log_item *CUD_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_cud_log_item, cud_item);\r\n}\r\nSTATIC void\r\nxfs_cud_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += sizeof(struct xfs_cud_log_format);\r\n}\r\nSTATIC void\r\nxfs_cud_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_cud_log_item *cudp = CUD_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\ncudp->cud_format.cud_type = XFS_LI_CUD;\r\ncudp->cud_format.cud_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_CUD_FORMAT, &cudp->cud_format,\r\nsizeof(struct xfs_cud_log_format));\r\n}\r\nSTATIC void\r\nxfs_cud_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_cud_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\n}\r\nSTATIC uint\r\nxfs_cud_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_cud_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_cud_log_item *cudp = CUD_ITEM(lip);\r\nif (lip->li_flags & XFS_LI_ABORTED) {\r\nxfs_cui_release(cudp->cud_cuip);\r\nkmem_zone_free(xfs_cud_zone, cudp);\r\n}\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_cud_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_cud_log_item *cudp = CUD_ITEM(lip);\r\nxfs_cui_release(cudp->cud_cuip);\r\nkmem_zone_free(xfs_cud_zone, cudp);\r\nreturn (xfs_lsn_t)-1;\r\n}\r\nSTATIC void\r\nxfs_cud_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_cud_log_item *\r\nxfs_cud_init(\r\nstruct xfs_mount *mp,\r\nstruct xfs_cui_log_item *cuip)\r\n{\r\nstruct xfs_cud_log_item *cudp;\r\ncudp = kmem_zone_zalloc(xfs_cud_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &cudp->cud_item, XFS_LI_CUD, &xfs_cud_item_ops);\r\ncudp->cud_cuip = cuip;\r\ncudp->cud_format.cud_cui_id = cuip->cui_format.cui_id;\r\nreturn cudp;\r\n}\r\nint\r\nxfs_cui_recover(\r\nstruct xfs_mount *mp,\r\nstruct xfs_cui_log_item *cuip)\r\n{\r\nint i;\r\nint error = 0;\r\nunsigned int refc_type;\r\nstruct xfs_phys_extent *refc;\r\nxfs_fsblock_t startblock_fsb;\r\nbool op_ok;\r\nstruct xfs_cud_log_item *cudp;\r\nstruct xfs_trans *tp;\r\nstruct xfs_btree_cur *rcur = NULL;\r\nenum xfs_refcount_intent_type type;\r\nxfs_fsblock_t firstfsb;\r\nxfs_fsblock_t new_fsb;\r\nxfs_extlen_t new_len;\r\nstruct xfs_bmbt_irec irec;\r\nstruct xfs_defer_ops dfops;\r\nbool requeue_only = false;\r\nASSERT(!test_bit(XFS_CUI_RECOVERED, &cuip->cui_flags));\r\nfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\r\nrefc = &cuip->cui_format.cui_extents[i];\r\nstartblock_fsb = XFS_BB_TO_FSB(mp,\r\nXFS_FSB_TO_DADDR(mp, refc->pe_startblock));\r\nswitch (refc->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK) {\r\ncase XFS_REFCOUNT_INCREASE:\r\ncase XFS_REFCOUNT_DECREASE:\r\ncase XFS_REFCOUNT_ALLOC_COW:\r\ncase XFS_REFCOUNT_FREE_COW:\r\nop_ok = true;\r\nbreak;\r\ndefault:\r\nop_ok = false;\r\nbreak;\r\n}\r\nif (!op_ok || startblock_fsb == 0 ||\r\nrefc->pe_len == 0 ||\r\nstartblock_fsb >= mp->m_sb.sb_dblocks ||\r\nrefc->pe_len >= mp->m_sb.sb_agblocks ||\r\n(refc->pe_flags & ~XFS_REFCOUNT_EXTENT_FLAGS)) {\r\nset_bit(XFS_CUI_RECOVERED, &cuip->cui_flags);\r\nxfs_cui_release(cuip);\r\nreturn -EIO;\r\n}\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\ncudp = xfs_trans_get_cud(tp, cuip);\r\nxfs_defer_init(&dfops, &firstfsb);\r\nfor (i = 0; i < cuip->cui_format.cui_nextents; i++) {\r\nrefc = &cuip->cui_format.cui_extents[i];\r\nrefc_type = refc->pe_flags & XFS_REFCOUNT_EXTENT_TYPE_MASK;\r\nswitch (refc_type) {\r\ncase XFS_REFCOUNT_INCREASE:\r\ncase XFS_REFCOUNT_DECREASE:\r\ncase XFS_REFCOUNT_ALLOC_COW:\r\ncase XFS_REFCOUNT_FREE_COW:\r\ntype = refc_type;\r\nbreak;\r\ndefault:\r\nerror = -EFSCORRUPTED;\r\ngoto abort_error;\r\n}\r\nif (requeue_only) {\r\nnew_fsb = refc->pe_startblock;\r\nnew_len = refc->pe_len;\r\n} else\r\nerror = xfs_trans_log_finish_refcount_update(tp, cudp,\r\n&dfops, type, refc->pe_startblock, refc->pe_len,\r\n&new_fsb, &new_len, &rcur);\r\nif (error)\r\ngoto abort_error;\r\nif (new_len > 0) {\r\nirec.br_startblock = new_fsb;\r\nirec.br_blockcount = new_len;\r\nswitch (type) {\r\ncase XFS_REFCOUNT_INCREASE:\r\nerror = xfs_refcount_increase_extent(\r\ntp->t_mountp, &dfops, &irec);\r\nbreak;\r\ncase XFS_REFCOUNT_DECREASE:\r\nerror = xfs_refcount_decrease_extent(\r\ntp->t_mountp, &dfops, &irec);\r\nbreak;\r\ncase XFS_REFCOUNT_ALLOC_COW:\r\nerror = xfs_refcount_alloc_cow_extent(\r\ntp->t_mountp, &dfops,\r\nirec.br_startblock,\r\nirec.br_blockcount);\r\nbreak;\r\ncase XFS_REFCOUNT_FREE_COW:\r\nerror = xfs_refcount_free_cow_extent(\r\ntp->t_mountp, &dfops,\r\nirec.br_startblock,\r\nirec.br_blockcount);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\nif (error)\r\ngoto abort_error;\r\nrequeue_only = true;\r\n}\r\n}\r\nxfs_refcount_finish_one_cleanup(tp, rcur, error);\r\nerror = xfs_defer_finish(&tp, &dfops, NULL);\r\nif (error)\r\ngoto abort_defer;\r\nset_bit(XFS_CUI_RECOVERED, &cuip->cui_flags);\r\nerror = xfs_trans_commit(tp);\r\nreturn error;\r\nabort_error:\r\nxfs_refcount_finish_one_cleanup(tp, rcur, error);\r\nabort_defer:\r\nxfs_defer_cancel(&dfops);\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}
