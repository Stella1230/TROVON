struct host1x_job *host1x_job_alloc(struct host1x_channel *ch,\r\nu32 num_cmdbufs, u32 num_relocs,\r\nu32 num_waitchks)\r\n{\r\nstruct host1x_job *job = NULL;\r\nunsigned int num_unpins = num_cmdbufs + num_relocs;\r\nu64 total;\r\nvoid *mem;\r\ntotal = sizeof(struct host1x_job) +\r\n(u64)num_relocs * sizeof(struct host1x_reloc) +\r\n(u64)num_unpins * sizeof(struct host1x_job_unpin_data) +\r\n(u64)num_waitchks * sizeof(struct host1x_waitchk) +\r\n(u64)num_cmdbufs * sizeof(struct host1x_job_gather) +\r\n(u64)num_unpins * sizeof(dma_addr_t) +\r\n(u64)num_unpins * sizeof(u32 *);\r\nif (total > ULONG_MAX)\r\nreturn NULL;\r\nmem = job = kzalloc(total, GFP_KERNEL);\r\nif (!job)\r\nreturn NULL;\r\nkref_init(&job->ref);\r\njob->channel = ch;\r\nmem += sizeof(struct host1x_job);\r\njob->relocarray = num_relocs ? mem : NULL;\r\nmem += num_relocs * sizeof(struct host1x_reloc);\r\njob->unpins = num_unpins ? mem : NULL;\r\nmem += num_unpins * sizeof(struct host1x_job_unpin_data);\r\njob->waitchk = num_waitchks ? mem : NULL;\r\nmem += num_waitchks * sizeof(struct host1x_waitchk);\r\njob->gathers = num_cmdbufs ? mem : NULL;\r\nmem += num_cmdbufs * sizeof(struct host1x_job_gather);\r\njob->addr_phys = num_unpins ? mem : NULL;\r\njob->reloc_addr_phys = job->addr_phys;\r\njob->gather_addr_phys = &job->addr_phys[num_relocs];\r\nreturn job;\r\n}\r\nstruct host1x_job *host1x_job_get(struct host1x_job *job)\r\n{\r\nkref_get(&job->ref);\r\nreturn job;\r\n}\r\nstatic void job_free(struct kref *ref)\r\n{\r\nstruct host1x_job *job = container_of(ref, struct host1x_job, ref);\r\nkfree(job);\r\n}\r\nvoid host1x_job_put(struct host1x_job *job)\r\n{\r\nkref_put(&job->ref, job_free);\r\n}\r\nvoid host1x_job_add_gather(struct host1x_job *job, struct host1x_bo *bo,\r\nu32 words, u32 offset)\r\n{\r\nstruct host1x_job_gather *cur_gather = &job->gathers[job->num_gathers];\r\ncur_gather->words = words;\r\ncur_gather->bo = bo;\r\ncur_gather->offset = offset;\r\njob->num_gathers++;\r\n}\r\nstatic void host1x_syncpt_patch_offset(struct host1x_syncpt *sp,\r\nstruct host1x_bo *h, u32 offset)\r\n{\r\nvoid *patch_addr = NULL;\r\npatch_addr = host1x_bo_kmap(h, offset >> PAGE_SHIFT);\r\nif (patch_addr) {\r\nhost1x_syncpt_patch_wait(sp,\r\npatch_addr + (offset & ~PAGE_MASK));\r\nhost1x_bo_kunmap(h, offset >> PAGE_SHIFT, patch_addr);\r\n} else\r\npr_err("Could not map cmdbuf for wait check\n");\r\n}\r\nstatic int do_waitchks(struct host1x_job *job, struct host1x *host,\r\nstruct host1x_bo *patch)\r\n{\r\nint i;\r\nfor (i = 0; i < job->num_waitchk; i++) {\r\nstruct host1x_waitchk *wait = &job->waitchk[i];\r\nstruct host1x_syncpt *sp =\r\nhost1x_syncpt_get(host, wait->syncpt_id);\r\nif (wait->syncpt_id > host1x_syncpt_nb_pts(host))\r\ncontinue;\r\nif (patch != wait->bo)\r\ncontinue;\r\ntrace_host1x_syncpt_wait_check(wait->bo, wait->offset,\r\nwait->syncpt_id, wait->thresh,\r\nhost1x_syncpt_read_min(sp));\r\nif (host1x_syncpt_is_expired(sp, wait->thresh)) {\r\ndev_dbg(host->dev,\r\n"drop WAIT id %u (%s) thresh 0x%x, min 0x%x\n",\r\nwait->syncpt_id, sp->name, wait->thresh,\r\nhost1x_syncpt_read_min(sp));\r\nhost1x_syncpt_patch_offset(sp, patch, wait->offset);\r\n}\r\nwait->bo = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pin_job(struct host1x_job *job)\r\n{\r\nunsigned int i;\r\njob->num_unpins = 0;\r\nfor (i = 0; i < job->num_relocs; i++) {\r\nstruct host1x_reloc *reloc = &job->relocarray[i];\r\nstruct sg_table *sgt;\r\ndma_addr_t phys_addr;\r\nreloc->target.bo = host1x_bo_get(reloc->target.bo);\r\nif (!reloc->target.bo)\r\ngoto unpin;\r\nphys_addr = host1x_bo_pin(reloc->target.bo, &sgt);\r\nif (!phys_addr)\r\ngoto unpin;\r\njob->addr_phys[job->num_unpins] = phys_addr;\r\njob->unpins[job->num_unpins].bo = reloc->target.bo;\r\njob->unpins[job->num_unpins].sgt = sgt;\r\njob->num_unpins++;\r\n}\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nstruct sg_table *sgt;\r\ndma_addr_t phys_addr;\r\ng->bo = host1x_bo_get(g->bo);\r\nif (!g->bo)\r\ngoto unpin;\r\nphys_addr = host1x_bo_pin(g->bo, &sgt);\r\nif (!phys_addr)\r\ngoto unpin;\r\njob->addr_phys[job->num_unpins] = phys_addr;\r\njob->unpins[job->num_unpins].bo = g->bo;\r\njob->unpins[job->num_unpins].sgt = sgt;\r\njob->num_unpins++;\r\n}\r\nreturn job->num_unpins;\r\nunpin:\r\nhost1x_job_unpin(job);\r\nreturn 0;\r\n}\r\nstatic int do_relocs(struct host1x_job *job, struct host1x_bo *cmdbuf)\r\n{\r\nint i = 0;\r\nu32 last_page = ~0;\r\nvoid *cmdbuf_page_addr = NULL;\r\nfor (i = 0; i < job->num_relocs; i++) {\r\nstruct host1x_reloc *reloc = &job->relocarray[i];\r\nu32 reloc_addr = (job->reloc_addr_phys[i] +\r\nreloc->target.offset) >> reloc->shift;\r\nu32 *target;\r\nif (cmdbuf != reloc->cmdbuf.bo)\r\ncontinue;\r\nif (last_page != reloc->cmdbuf.offset >> PAGE_SHIFT) {\r\nif (cmdbuf_page_addr)\r\nhost1x_bo_kunmap(cmdbuf, last_page,\r\ncmdbuf_page_addr);\r\ncmdbuf_page_addr = host1x_bo_kmap(cmdbuf,\r\nreloc->cmdbuf.offset >> PAGE_SHIFT);\r\nlast_page = reloc->cmdbuf.offset >> PAGE_SHIFT;\r\nif (unlikely(!cmdbuf_page_addr)) {\r\npr_err("Could not map cmdbuf for relocation\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ntarget = cmdbuf_page_addr + (reloc->cmdbuf.offset & ~PAGE_MASK);\r\n*target = reloc_addr;\r\n}\r\nif (cmdbuf_page_addr)\r\nhost1x_bo_kunmap(cmdbuf, last_page, cmdbuf_page_addr);\r\nreturn 0;\r\n}\r\nstatic bool check_reloc(struct host1x_reloc *reloc, struct host1x_bo *cmdbuf,\r\nunsigned int offset)\r\n{\r\noffset *= sizeof(u32);\r\nif (reloc->cmdbuf.bo != cmdbuf || reloc->cmdbuf.offset != offset)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int check_register(struct host1x_firewall *fw, unsigned long offset)\r\n{\r\nif (fw->job->is_addr_reg(fw->dev, fw->class, offset)) {\r\nif (!fw->num_relocs)\r\nreturn -EINVAL;\r\nif (!check_reloc(fw->reloc, fw->cmdbuf, fw->offset))\r\nreturn -EINVAL;\r\nfw->num_relocs--;\r\nfw->reloc++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_mask(struct host1x_firewall *fw)\r\n{\r\nu32 mask = fw->mask;\r\nu32 reg = fw->reg;\r\nint ret;\r\nwhile (mask) {\r\nif (fw->words == 0)\r\nreturn -EINVAL;\r\nif (mask & 1) {\r\nret = check_register(fw, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nfw->words--;\r\nfw->offset++;\r\n}\r\nmask >>= 1;\r\nreg++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_incr(struct host1x_firewall *fw)\r\n{\r\nu32 count = fw->count;\r\nu32 reg = fw->reg;\r\nint ret;\r\nwhile (count) {\r\nif (fw->words == 0)\r\nreturn -EINVAL;\r\nret = check_register(fw, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreg++;\r\nfw->words--;\r\nfw->offset++;\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_nonincr(struct host1x_firewall *fw)\r\n{\r\nu32 count = fw->count;\r\nint ret;\r\nwhile (count) {\r\nif (fw->words == 0)\r\nreturn -EINVAL;\r\nret = check_register(fw, fw->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nfw->words--;\r\nfw->offset++;\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int validate(struct host1x_firewall *fw, struct host1x_job_gather *g)\r\n{\r\nu32 *cmdbuf_base = (u32 *)fw->job->gather_copy_mapped +\r\n(g->offset / sizeof(u32));\r\nint err = 0;\r\nif (!fw->job->is_addr_reg)\r\nreturn 0;\r\nfw->words = g->words;\r\nfw->cmdbuf = g->bo;\r\nfw->offset = 0;\r\nwhile (fw->words && !err) {\r\nu32 word = cmdbuf_base[fw->offset];\r\nu32 opcode = (word & 0xf0000000) >> 28;\r\nfw->mask = 0;\r\nfw->reg = 0;\r\nfw->count = 0;\r\nfw->words--;\r\nfw->offset++;\r\nswitch (opcode) {\r\ncase 0:\r\nfw->class = word >> 6 & 0x3ff;\r\nfw->mask = word & 0x3f;\r\nfw->reg = word >> 16 & 0xfff;\r\nerr = check_mask(fw);\r\nif (err)\r\ngoto out;\r\nbreak;\r\ncase 1:\r\nfw->reg = word >> 16 & 0xfff;\r\nfw->count = word & 0xffff;\r\nerr = check_incr(fw);\r\nif (err)\r\ngoto out;\r\nbreak;\r\ncase 2:\r\nfw->reg = word >> 16 & 0xfff;\r\nfw->count = word & 0xffff;\r\nerr = check_nonincr(fw);\r\nif (err)\r\ngoto out;\r\nbreak;\r\ncase 3:\r\nfw->mask = word & 0xffff;\r\nfw->reg = word >> 16 & 0xfff;\r\nerr = check_mask(fw);\r\nif (err)\r\ngoto out;\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ncase 14:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic inline int copy_gathers(struct host1x_job *job, struct device *dev)\r\n{\r\nstruct host1x_firewall fw;\r\nsize_t size = 0;\r\nsize_t offset = 0;\r\nint i;\r\nfw.job = job;\r\nfw.dev = dev;\r\nfw.reloc = job->relocarray;\r\nfw.num_relocs = job->num_relocs;\r\nfw.class = 0;\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nsize += g->words * sizeof(u32);\r\n}\r\njob->gather_copy_mapped = dma_alloc_wc(dev, size, &job->gather_copy,\r\nGFP_KERNEL);\r\nif (!job->gather_copy_mapped) {\r\njob->gather_copy_mapped = NULL;\r\nreturn -ENOMEM;\r\n}\r\njob->gather_copy_size = size;\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nvoid *gather;\r\ngather = host1x_bo_mmap(g->bo);\r\nmemcpy(job->gather_copy_mapped + offset, gather + g->offset,\r\ng->words * sizeof(u32));\r\nhost1x_bo_munmap(g->bo, gather);\r\ng->base = job->gather_copy;\r\ng->offset = offset;\r\nif (validate(&fw, g))\r\nreturn -EINVAL;\r\noffset += g->words * sizeof(u32);\r\n}\r\nif (fw.num_relocs)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint host1x_job_pin(struct host1x_job *job, struct device *dev)\r\n{\r\nint err;\r\nunsigned int i, j;\r\nstruct host1x *host = dev_get_drvdata(dev->parent);\r\nDECLARE_BITMAP(waitchk_mask, host1x_syncpt_nb_pts(host));\r\nbitmap_zero(waitchk_mask, host1x_syncpt_nb_pts(host));\r\nfor (i = 0; i < job->num_waitchk; i++) {\r\nu32 syncpt_id = job->waitchk[i].syncpt_id;\r\nif (syncpt_id < host1x_syncpt_nb_pts(host))\r\nset_bit(syncpt_id, waitchk_mask);\r\n}\r\nfor_each_set_bit(i, waitchk_mask, host1x_syncpt_nb_pts(host))\r\nhost1x_syncpt_load(host->syncpt + i);\r\nerr = pin_job(job);\r\nif (!err)\r\ngoto out;\r\nfor (i = 0; i < job->num_gathers; i++) {\r\nstruct host1x_job_gather *g = &job->gathers[i];\r\nif (g->handled)\r\ncontinue;\r\ng->base = job->gather_addr_phys[i];\r\nfor (j = i + 1; j < job->num_gathers; j++) {\r\nif (job->gathers[j].bo == g->bo) {\r\njob->gathers[j].handled = true;\r\njob->gathers[j].base = g->base;\r\n}\r\n}\r\nerr = do_relocs(job, g->bo);\r\nif (err)\r\nbreak;\r\nerr = do_waitchks(job, host, g->bo);\r\nif (err)\r\nbreak;\r\n}\r\nif (IS_ENABLED(CONFIG_TEGRA_HOST1X_FIREWALL) && !err) {\r\nerr = copy_gathers(job, dev);\r\nif (err) {\r\nhost1x_job_unpin(job);\r\nreturn err;\r\n}\r\n}\r\nout:\r\nwmb();\r\nreturn err;\r\n}\r\nvoid host1x_job_unpin(struct host1x_job *job)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < job->num_unpins; i++) {\r\nstruct host1x_job_unpin_data *unpin = &job->unpins[i];\r\nhost1x_bo_unpin(unpin->bo, unpin->sgt);\r\nhost1x_bo_put(unpin->bo);\r\n}\r\njob->num_unpins = 0;\r\nif (job->gather_copy_size)\r\ndma_free_wc(job->channel->dev, job->gather_copy_size,\r\njob->gather_copy_mapped, job->gather_copy);\r\n}\r\nvoid host1x_job_dump(struct device *dev, struct host1x_job *job)\r\n{\r\ndev_dbg(dev, " SYNCPT_ID %d\n", job->syncpt_id);\r\ndev_dbg(dev, " SYNCPT_VAL %d\n", job->syncpt_end);\r\ndev_dbg(dev, " FIRST_GET 0x%x\n", job->first_get);\r\ndev_dbg(dev, " TIMEOUT %d\n", job->timeout);\r\ndev_dbg(dev, " NUM_SLOTS %d\n", job->num_slots);\r\ndev_dbg(dev, " NUM_HANDLES %d\n", job->num_unpins);\r\n}
