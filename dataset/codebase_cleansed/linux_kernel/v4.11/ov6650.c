static int ov6650_reg_read(struct i2c_client *client, u8 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 data = reg;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsg.flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n*val = data;\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "Failed reading register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nstatic int ov6650_reg_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret;\r\nunsigned char data[2] = { reg, val };\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = data,\r\n};\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nudelay(100);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed writing register 0x%02x!\n", reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ov6650_reg_rmw(struct i2c_client *client, u8 reg, u8 set, u8 mask)\r\n{\r\nu8 val;\r\nint ret;\r\nret = ov6650_reg_read(client, reg, &val);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"[Read]-Modify-Write of register 0x%02x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nval &= ~mask;\r\nval |= set;\r\nret = ov6650_reg_write(client, reg, val);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"Read-Modify-[Write] of register 0x%02x failed!\n",\r\nreg);\r\nreturn ret;\r\n}\r\nstatic struct ov6650 *to_ov6650(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ov6650, subdev);\r\n}\r\nstatic int ov6650_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ov6550_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov6650 *priv = container_of(ctrl->handler, struct ov6650, hdl);\r\nstruct v4l2_subdev *sd = &priv->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nuint8_t reg, reg2;\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nret = ov6650_reg_read(client, REG_GAIN, &reg);\r\nif (!ret)\r\npriv->gain->val = reg;\r\nreturn ret;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = ov6650_reg_read(client, REG_BLUE, &reg);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_RED, &reg2);\r\nif (!ret) {\r\npriv->blue->val = reg;\r\npriv->red->val = reg2;\r\n}\r\nreturn ret;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nret = ov6650_reg_read(client, REG_AECH, &reg);\r\nif (!ret)\r\npriv->exposure->val = reg;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov6550_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ov6650 *priv = container_of(ctrl->handler, struct ov6650, hdl);\r\nstruct v4l2_subdev *sd = &priv->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTOGAIN:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->val ? COMB_AGC : 0, COMB_AGC);\r\nif (!ret && !ctrl->val)\r\nret = ov6650_reg_write(client, REG_GAIN, priv->gain->val);\r\nreturn ret;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nret = ov6650_reg_rmw(client, REG_COMB,\r\nctrl->val ? COMB_AWB : 0, COMB_AWB);\r\nif (!ret && !ctrl->val) {\r\nret = ov6650_reg_write(client, REG_BLUE, priv->blue->val);\r\nif (!ret)\r\nret = ov6650_reg_write(client, REG_RED,\r\npriv->red->val);\r\n}\r\nreturn ret;\r\ncase V4L2_CID_SATURATION:\r\nreturn ov6650_reg_rmw(client, REG_SAT, SET_SAT(ctrl->val),\r\nSAT_MASK);\r\ncase V4L2_CID_HUE:\r\nreturn ov6650_reg_rmw(client, REG_HUE, SET_HUE(ctrl->val),\r\nHUE_MASK);\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn ov6650_reg_write(client, REG_BRT, ctrl->val);\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nret = ov6650_reg_rmw(client, REG_COMB, ctrl->val ==\r\nV4L2_EXPOSURE_AUTO ? COMB_AEC : 0, COMB_AEC);\r\nif (!ret && ctrl->val == V4L2_EXPOSURE_MANUAL)\r\nret = ov6650_reg_write(client, REG_AECH,\r\npriv->exposure->val);\r\nreturn ret;\r\ncase V4L2_CID_GAMMA:\r\nreturn ov6650_reg_write(client, REG_GAM1, ctrl->val);\r\ncase V4L2_CID_VFLIP:\r\nreturn ov6650_reg_rmw(client, REG_COMB,\r\nctrl->val ? COMB_FLIP_V : 0, COMB_FLIP_V);\r\ncase V4L2_CID_HFLIP:\r\nreturn ov6650_reg_rmw(client, REG_COMB,\r\nctrl->val ? COMB_FLIP_H : 0, COMB_FLIP_H);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ov6650_get_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nu8 val;\r\nif (reg->reg & ~0xff)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nret = ov6650_reg_read(client, reg->reg, &val);\r\nif (!ret)\r\nreg->val = (__u64)val;\r\nreturn ret;\r\n}\r\nstatic int ov6650_set_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg & ~0xff || reg->val & ~0xff)\r\nreturn -EINVAL;\r\nreturn ov6650_reg_write(client, reg->reg, reg->val);\r\n}\r\nstatic int ov6650_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nreturn soc_camera_set_power(&client->dev, ssdd, priv->clk, on);\r\n}\r\nstatic int ov6650_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nsel->r.left = DEF_HSTRT << 1;\r\nsel->r.top = DEF_VSTRT << 1;\r\nsel->r.width = W_CIF;\r\nsel->r.height = H_CIF;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r = priv->rect;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ov6650_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_rect rect = sel->r;\r\nint ret;\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\r\nsel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nrect.left = ALIGN(rect.left, 2);\r\nrect.width = ALIGN(rect.width, 2);\r\nrect.top = ALIGN(rect.top, 2);\r\nrect.height = ALIGN(rect.height, 2);\r\nsoc_camera_limit_side(&rect.left, &rect.width,\r\nDEF_HSTRT << 1, 2, W_CIF);\r\nsoc_camera_limit_side(&rect.top, &rect.height,\r\nDEF_VSTRT << 1, 2, H_CIF);\r\nret = ov6650_reg_write(client, REG_HSTRT, rect.left >> 1);\r\nif (!ret) {\r\npriv->rect.left = rect.left;\r\nret = ov6650_reg_write(client, REG_HSTOP,\r\n(rect.left + rect.width) >> 1);\r\n}\r\nif (!ret) {\r\npriv->rect.width = rect.width;\r\nret = ov6650_reg_write(client, REG_VSTRT, rect.top >> 1);\r\n}\r\nif (!ret) {\r\npriv->rect.top = rect.top;\r\nret = ov6650_reg_write(client, REG_VSTOP,\r\n(rect.top + rect.height) >> 1);\r\n}\r\nif (!ret)\r\npriv->rect.height = rect.height;\r\nreturn ret;\r\n}\r\nstatic int ov6650_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->width = priv->rect.width >> priv->half_scale;\r\nmf->height = priv->rect.height >> priv->half_scale;\r\nmf->code = priv->code;\r\nmf->colorspace = priv->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic bool is_unscaled_ok(int width, int height, struct v4l2_rect *rect)\r\n{\r\nreturn width > rect->width >> 1 || height > rect->height >> 1;\r\n}\r\nstatic u8 to_clkrc(struct v4l2_fract *timeperframe,\r\nunsigned long pclk_limit, unsigned long pclk_max)\r\n{\r\nunsigned long pclk;\r\nif (timeperframe->numerator && timeperframe->denominator)\r\npclk = pclk_max * timeperframe->denominator /\r\n(FRAME_RATE_MAX * timeperframe->numerator);\r\nelse\r\npclk = pclk_max;\r\nif (pclk_limit && pclk_limit < pclk)\r\npclk = pclk_limit;\r\nreturn (pclk_max - 1) / pclk;\r\n}\r\nstatic int ov6650_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_device *icd = v4l2_get_subdev_hostdata(sd);\r\nstruct soc_camera_sense *sense = icd->sense;\r\nstruct ov6650 *priv = to_ov6650(client);\r\nbool half_scale = !is_unscaled_ok(mf->width, mf->height, &priv->rect);\r\nstruct v4l2_subdev_selection sel = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.target = V4L2_SEL_TGT_CROP,\r\n.r.left = priv->rect.left + (priv->rect.width >> 1) -\r\n(mf->width >> (1 - half_scale)),\r\n.r.top = priv->rect.top + (priv->rect.height >> 1) -\r\n(mf->height >> (1 - half_scale)),\r\n.r.width = mf->width << half_scale,\r\n.r.height = mf->height << half_scale,\r\n};\r\nu32 code = mf->code;\r\nunsigned long mclk, pclk;\r\nu8 coma_set = 0, coma_mask = 0, coml_set, coml_mask, clkrc;\r\nint ret;\r\nswitch (code) {\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ndev_dbg(&client->dev, "pixel format GREY8_1X8\n");\r\ncoma_mask |= COMA_RGB | COMA_WORD_SWAP | COMA_BYTE_SWAP;\r\ncoma_set |= COMA_BW;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ndev_dbg(&client->dev, "pixel format YUYV8_2X8_LE\n");\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_BYTE_SWAP;\r\ncoma_set |= COMA_WORD_SWAP;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ndev_dbg(&client->dev, "pixel format YVYU8_2X8_LE (untested)\n");\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP |\r\nCOMA_BYTE_SWAP;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ndev_dbg(&client->dev, "pixel format YUYV8_2X8_BE\n");\r\nif (half_scale) {\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\r\ncoma_set |= COMA_BYTE_SWAP;\r\n} else {\r\ncoma_mask |= COMA_RGB | COMA_BW;\r\ncoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\n}\r\nbreak;\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ndev_dbg(&client->dev, "pixel format YVYU8_2X8_BE (untested)\n");\r\nif (half_scale) {\r\ncoma_mask |= COMA_RGB | COMA_BW;\r\ncoma_set |= COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\n} else {\r\ncoma_mask |= COMA_RGB | COMA_BW | COMA_WORD_SWAP;\r\ncoma_set |= COMA_BYTE_SWAP;\r\n}\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ndev_dbg(&client->dev, "pixel format SBGGR8_1X8 (untested)\n");\r\ncoma_mask |= COMA_BW | COMA_BYTE_SWAP | COMA_WORD_SWAP;\r\ncoma_set |= COMA_RAW_RGB | COMA_RGB;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Pixel format not handled: 0x%x\n", code);\r\nreturn -EINVAL;\r\n}\r\npriv->code = code;\r\nif (code == MEDIA_BUS_FMT_Y8_1X8 ||\r\ncode == MEDIA_BUS_FMT_SBGGR8_1X8) {\r\ncoml_mask = COML_ONE_CHANNEL;\r\ncoml_set = 0;\r\npriv->pclk_max = 4000000;\r\n} else {\r\ncoml_mask = 0;\r\ncoml_set = COML_ONE_CHANNEL;\r\npriv->pclk_max = 8000000;\r\n}\r\nif (code == MEDIA_BUS_FMT_SBGGR8_1X8)\r\npriv->colorspace = V4L2_COLORSPACE_SRGB;\r\nelse if (code != 0)\r\npriv->colorspace = V4L2_COLORSPACE_JPEG;\r\nif (half_scale) {\r\ndev_dbg(&client->dev, "max resolution: QCIF\n");\r\ncoma_set |= COMA_QCIF;\r\npriv->pclk_max /= 2;\r\n} else {\r\ndev_dbg(&client->dev, "max resolution: CIF\n");\r\ncoma_mask |= COMA_QCIF;\r\n}\r\npriv->half_scale = half_scale;\r\nif (sense) {\r\nif (sense->master_clock == 8000000) {\r\ndev_dbg(&client->dev, "8MHz input clock\n");\r\nclkrc = CLKRC_6MHz;\r\n} else if (sense->master_clock == 12000000) {\r\ndev_dbg(&client->dev, "12MHz input clock\n");\r\nclkrc = CLKRC_12MHz;\r\n} else if (sense->master_clock == 16000000) {\r\ndev_dbg(&client->dev, "16MHz input clock\n");\r\nclkrc = CLKRC_16MHz;\r\n} else if (sense->master_clock == 24000000) {\r\ndev_dbg(&client->dev, "24MHz input clock\n");\r\nclkrc = CLKRC_24MHz;\r\n} else {\r\ndev_err(&client->dev,\r\n"unsupported input clock, check platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmclk = sense->master_clock;\r\npriv->pclk_limit = sense->pixel_clock_max;\r\n} else {\r\nclkrc = CLKRC_24MHz;\r\nmclk = 24000000;\r\npriv->pclk_limit = 0;\r\ndev_dbg(&client->dev, "using default 24MHz input clock\n");\r\n}\r\nclkrc |= to_clkrc(&priv->tpf, priv->pclk_limit, priv->pclk_max);\r\npclk = priv->pclk_max / GET_CLKRC_DIV(clkrc);\r\ndev_dbg(&client->dev, "pixel clock divider: %ld.%ld\n",\r\nmclk / pclk, 10 * mclk % pclk / pclk);\r\nret = ov6650_set_selection(sd, NULL, &sel);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COMA, coma_set, coma_mask);\r\nif (!ret)\r\nret = ov6650_reg_write(client, REG_CLKRC, clkrc);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COML, coml_set, coml_mask);\r\nif (!ret) {\r\nmf->colorspace = priv->colorspace;\r\nmf->width = priv->rect.width >> half_scale;\r\nmf->height = priv->rect.height >> half_scale;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nif (is_unscaled_ok(mf->width, mf->height, &priv->rect))\r\nv4l_bound_align_image(&mf->width, 2, W_CIF, 1,\r\n&mf->height, 2, H_CIF, 1, 0);\r\nmf->field = V4L2_FIELD_NONE;\r\nswitch (mf->code) {\r\ncase MEDIA_BUS_FMT_Y10_1X10:\r\nmf->code = MEDIA_BUS_FMT_Y8_1X8;\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\ndefault:\r\nmf->code = MEDIA_BUS_FMT_SBGGR8_1X8;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\n}\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn ov6650_s_fmt(sd, mf);\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nstatic int ov6650_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index >= ARRAY_SIZE(ov6650_codes))\r\nreturn -EINVAL;\r\ncode->code = ov6650_codes[code->index];\r\nreturn 0;\r\n}\r\nstatic int ov6650_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(cp, 0, sizeof(*cp));\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = GET_CLKRC_DIV(to_clkrc(&priv->tpf,\r\npriv->pclk_limit, priv->pclk_max));\r\ncp->timeperframe.denominator = FRAME_RATE_MAX;\r\ndev_dbg(&client->dev, "Frame interval: %u/%u s\n",\r\ncp->timeperframe.numerator, cp->timeperframe.denominator);\r\nreturn 0;\r\n}\r\nstatic int ov6650_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ov6650 *priv = to_ov6650(client);\r\nstruct v4l2_captureparm *cp = &parms->parm.capture;\r\nstruct v4l2_fract *tpf = &cp->timeperframe;\r\nint div, ret;\r\nu8 clkrc;\r\nif (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cp->extendedmode != 0)\r\nreturn -EINVAL;\r\nif (tpf->numerator == 0 || tpf->denominator == 0)\r\ndiv = 1;\r\nelse\r\ndiv = (tpf->numerator * FRAME_RATE_MAX) / tpf->denominator;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > GET_CLKRC_DIV(CLKRC_DIV_MASK))\r\ndiv = GET_CLKRC_DIV(CLKRC_DIV_MASK);\r\npriv->tpf.numerator = div;\r\npriv->tpf.denominator = FRAME_RATE_MAX;\r\nclkrc = to_clkrc(&priv->tpf, priv->pclk_limit, priv->pclk_max);\r\nret = ov6650_reg_rmw(client, REG_CLKRC, clkrc, CLKRC_DIV_MASK);\r\nif (!ret) {\r\ntpf->numerator = GET_CLKRC_DIV(clkrc);\r\ntpf->denominator = FRAME_RATE_MAX;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_reset(struct i2c_client *client)\r\n{\r\nint ret;\r\ndev_dbg(&client->dev, "reset\n");\r\nret = ov6650_reg_rmw(client, REG_COMA, COMA_RESET, 0);\r\nif (ret)\r\ndev_err(&client->dev,\r\n"An error occurred while entering soft reset!\n");\r\nreturn ret;\r\n}\r\nstatic int ov6650_prog_dflt(struct i2c_client *client)\r\n{\r\nint ret;\r\ndev_dbg(&client->dev, "initializing\n");\r\nret = ov6650_reg_write(client, REG_COMA, 0);\r\nif (!ret)\r\nret = ov6650_reg_rmw(client, REG_COMB, 0, COMB_BAND_FILTER);\r\nreturn ret;\r\n}\r\nstatic int ov6650_video_probe(struct i2c_client *client)\r\n{\r\nstruct ov6650 *priv = to_ov6650(client);\r\nu8 pidh, pidl, midh, midl;\r\nint ret;\r\nret = ov6650_s_power(&priv->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ov6650_reg_read(client, REG_PIDH, &pidh);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_PIDL, &pidl);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_MIDH, &midh);\r\nif (!ret)\r\nret = ov6650_reg_read(client, REG_MIDL, &midl);\r\nif (ret)\r\ngoto done;\r\nif ((pidh != OV6650_PIDH) || (pidl != OV6650_PIDL)) {\r\ndev_err(&client->dev, "Product ID error 0x%02x:0x%02x\n",\r\npidh, pidl);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\ndev_info(&client->dev,\r\n"ov6650 Product ID 0x%02x:0x%02x Manufacturer ID 0x%02x:0x%02x\n",\r\npidh, pidl, midh, midl);\r\nret = ov6650_reset(client);\r\nif (!ret)\r\nret = ov6650_prog_dflt(client);\r\nif (!ret)\r\nret = v4l2_ctrl_handler_setup(&priv->hdl);\r\ndone:\r\nov6650_s_power(&priv->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int ov6650_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_MASTER |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int ov6650_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nunsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nint ret;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\nret = ov6650_reg_rmw(client, REG_COMJ, COMJ_PCLK_RISING, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMJ, 0, COMJ_PCLK_RISING);\r\nif (ret)\r\nreturn ret;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nret = ov6650_reg_rmw(client, REG_COMF, COMF_HREF_LOW, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMF, 0, COMF_HREF_LOW);\r\nif (ret)\r\nreturn ret;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\nret = ov6650_reg_rmw(client, REG_COMJ, COMJ_VSYNC_HIGH, 0);\r\nelse\r\nret = ov6650_reg_rmw(client, REG_COMJ, 0, COMJ_VSYNC_HIGH);\r\nreturn ret;\r\n}\r\nstatic int ov6650_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct ov6650 *priv;\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nint ret;\r\nif (!ssdd) {\r\ndev_err(&client->dev, "Missing platform_data for driver\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&client->dev,\r\n"Failed to allocate memory for private data!\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &ov6650_subdev_ops);\r\nv4l2_ctrl_handler_init(&priv->hdl, 13);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\npriv->autogain = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\npriv->gain = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 0x3f, 1, DEF_GAIN);\r\npriv->autowb = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\npriv->blue = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 0xff, 1, DEF_BLUE);\r\npriv->red = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 0xff, 1, DEF_RED);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0xf, 1, 0x8);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_HUE, 0, HUE_MASK, 1, DEF_HUE);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x80);\r\npriv->autoexposure = v4l2_ctrl_new_std_menu(&priv->hdl,\r\n&ov6550_ctrl_ops, V4L2_CID_EXPOSURE_AUTO,\r\nV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\r\npriv->exposure = v4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 0xff, 1, DEF_AECH);\r\nv4l2_ctrl_new_std(&priv->hdl, &ov6550_ctrl_ops,\r\nV4L2_CID_GAMMA, 0, 0xff, 1, 0x12);\r\npriv->subdev.ctrl_handler = &priv->hdl;\r\nif (priv->hdl.error)\r\nreturn priv->hdl.error;\r\nv4l2_ctrl_auto_cluster(2, &priv->autogain, 0, true);\r\nv4l2_ctrl_auto_cluster(3, &priv->autowb, 0, true);\r\nv4l2_ctrl_auto_cluster(2, &priv->autoexposure,\r\nV4L2_EXPOSURE_MANUAL, true);\r\npriv->rect.left = DEF_HSTRT << 1;\r\npriv->rect.top = DEF_VSTRT << 1;\r\npriv->rect.width = W_CIF;\r\npriv->rect.height = H_CIF;\r\npriv->half_scale = false;\r\npriv->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\npriv->colorspace = V4L2_COLORSPACE_JPEG;\r\npriv->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ngoto eclkget;\r\n}\r\nret = ov6650_video_probe(client);\r\nif (ret) {\r\nv4l2_clk_put(priv->clk);\r\neclkget:\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ov6650_remove(struct i2c_client *client)\r\n{\r\nstruct ov6650 *priv = to_ov6650(client);\r\nv4l2_clk_put(priv->clk);\r\nv4l2_device_unregister_subdev(&priv->subdev);\r\nv4l2_ctrl_handler_free(&priv->hdl);\r\nreturn 0;\r\n}
