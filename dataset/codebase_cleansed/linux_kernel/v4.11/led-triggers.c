ssize_t led_trigger_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct led_trigger *trig;\r\nint ret = count;\r\nmutex_lock(&led_cdev->led_access);\r\nif (led_sysfs_is_disabled(led_cdev)) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (sysfs_streq(buf, "none")) {\r\nled_trigger_remove(led_cdev);\r\ngoto unlock;\r\n}\r\ndown_read(&triggers_list_lock);\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (sysfs_streq(buf, trig->name)) {\r\ndown_write(&led_cdev->trigger_lock);\r\nled_trigger_set(led_cdev, trig);\r\nup_write(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\ngoto unlock;\r\n}\r\n}\r\nret = -EINVAL;\r\nup_read(&triggers_list_lock);\r\nunlock:\r\nmutex_unlock(&led_cdev->led_access);\r\nreturn ret;\r\n}\r\nssize_t led_trigger_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct led_trigger *trig;\r\nint len = 0;\r\ndown_read(&triggers_list_lock);\r\ndown_read(&led_cdev->trigger_lock);\r\nif (!led_cdev->trigger)\r\nlen += scnprintf(buf+len, PAGE_SIZE - len, "[none] ");\r\nelse\r\nlen += scnprintf(buf+len, PAGE_SIZE - len, "none ");\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (led_cdev->trigger && !strcmp(led_cdev->trigger->name,\r\ntrig->name))\r\nlen += scnprintf(buf+len, PAGE_SIZE - len, "[%s] ",\r\ntrig->name);\r\nelse\r\nlen += scnprintf(buf+len, PAGE_SIZE - len, "%s ",\r\ntrig->name);\r\n}\r\nup_read(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\nlen += scnprintf(len+buf, PAGE_SIZE - len, "\n");\r\nreturn len;\r\n}\r\nvoid led_trigger_set(struct led_classdev *led_cdev, struct led_trigger *trig)\r\n{\r\nunsigned long flags;\r\nchar *event = NULL;\r\nchar *envp[2];\r\nconst char *name;\r\nif (!led_cdev->trigger && !trig)\r\nreturn;\r\nname = trig ? trig->name : "none";\r\nevent = kasprintf(GFP_KERNEL, "TRIGGER=%s", name);\r\nif (led_cdev->trigger) {\r\nwrite_lock_irqsave(&led_cdev->trigger->leddev_list_lock, flags);\r\nlist_del(&led_cdev->trig_list);\r\nwrite_unlock_irqrestore(&led_cdev->trigger->leddev_list_lock,\r\nflags);\r\ncancel_work_sync(&led_cdev->set_brightness_work);\r\nled_stop_software_blink(led_cdev);\r\nif (led_cdev->trigger->deactivate)\r\nled_cdev->trigger->deactivate(led_cdev);\r\nled_cdev->trigger = NULL;\r\nled_set_brightness(led_cdev, LED_OFF);\r\n}\r\nif (trig) {\r\nwrite_lock_irqsave(&trig->leddev_list_lock, flags);\r\nlist_add_tail(&led_cdev->trig_list, &trig->led_cdevs);\r\nwrite_unlock_irqrestore(&trig->leddev_list_lock, flags);\r\nled_cdev->trigger = trig;\r\nif (trig->activate)\r\ntrig->activate(led_cdev);\r\n}\r\nif (event) {\r\nenvp[0] = event;\r\nenvp[1] = NULL;\r\nif (kobject_uevent_env(&led_cdev->dev->kobj, KOBJ_CHANGE, envp))\r\ndev_err(led_cdev->dev,\r\n"%s: Error sending uevent\n", __func__);\r\nkfree(event);\r\n}\r\n}\r\nvoid led_trigger_remove(struct led_classdev *led_cdev)\r\n{\r\ndown_write(&led_cdev->trigger_lock);\r\nled_trigger_set(led_cdev, NULL);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nvoid led_trigger_set_default(struct led_classdev *led_cdev)\r\n{\r\nstruct led_trigger *trig;\r\nif (!led_cdev->default_trigger)\r\nreturn;\r\ndown_read(&triggers_list_lock);\r\ndown_write(&led_cdev->trigger_lock);\r\nlist_for_each_entry(trig, &trigger_list, next_trig) {\r\nif (!strcmp(led_cdev->default_trigger, trig->name))\r\nled_trigger_set(led_cdev, trig);\r\n}\r\nup_write(&led_cdev->trigger_lock);\r\nup_read(&triggers_list_lock);\r\n}\r\nvoid led_trigger_rename_static(const char *name, struct led_trigger *trig)\r\n{\r\nBUG_ON(name == trig->name);\r\ndown_write(&triggers_list_lock);\r\nstrcpy((char *)trig->name, name);\r\nup_write(&triggers_list_lock);\r\n}\r\nint led_trigger_register(struct led_trigger *trig)\r\n{\r\nstruct led_classdev *led_cdev;\r\nstruct led_trigger *_trig;\r\nrwlock_init(&trig->leddev_list_lock);\r\nINIT_LIST_HEAD(&trig->led_cdevs);\r\ndown_write(&triggers_list_lock);\r\nlist_for_each_entry(_trig, &trigger_list, next_trig) {\r\nif (!strcmp(_trig->name, trig->name)) {\r\nup_write(&triggers_list_lock);\r\nreturn -EEXIST;\r\n}\r\n}\r\nlist_add_tail(&trig->next_trig, &trigger_list);\r\nup_write(&triggers_list_lock);\r\ndown_read(&leds_list_lock);\r\nlist_for_each_entry(led_cdev, &leds_list, node) {\r\ndown_write(&led_cdev->trigger_lock);\r\nif (!led_cdev->trigger && led_cdev->default_trigger &&\r\n!strcmp(led_cdev->default_trigger, trig->name))\r\nled_trigger_set(led_cdev, trig);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nup_read(&leds_list_lock);\r\nreturn 0;\r\n}\r\nvoid led_trigger_unregister(struct led_trigger *trig)\r\n{\r\nstruct led_classdev *led_cdev;\r\nif (list_empty_careful(&trig->next_trig))\r\nreturn;\r\ndown_write(&triggers_list_lock);\r\nlist_del_init(&trig->next_trig);\r\nup_write(&triggers_list_lock);\r\ndown_read(&leds_list_lock);\r\nlist_for_each_entry(led_cdev, &leds_list, node) {\r\ndown_write(&led_cdev->trigger_lock);\r\nif (led_cdev->trigger == trig)\r\nled_trigger_set(led_cdev, NULL);\r\nup_write(&led_cdev->trigger_lock);\r\n}\r\nup_read(&leds_list_lock);\r\n}\r\nstatic void devm_led_trigger_release(struct device *dev, void *res)\r\n{\r\nled_trigger_unregister(*(struct led_trigger **)res);\r\n}\r\nint devm_led_trigger_register(struct device *dev,\r\nstruct led_trigger *trig)\r\n{\r\nstruct led_trigger **dr;\r\nint rc;\r\ndr = devres_alloc(devm_led_trigger_release, sizeof(*dr),\r\nGFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\n*dr = trig;\r\nrc = led_trigger_register(trig);\r\nif (rc)\r\ndevres_free(dr);\r\nelse\r\ndevres_add(dev, dr);\r\nreturn rc;\r\n}\r\nvoid led_trigger_event(struct led_trigger *trig,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_classdev *led_cdev;\r\nif (!trig)\r\nreturn;\r\nread_lock(&trig->leddev_list_lock);\r\nlist_for_each_entry(led_cdev, &trig->led_cdevs, trig_list)\r\nled_set_brightness(led_cdev, brightness);\r\nread_unlock(&trig->leddev_list_lock);\r\n}\r\nstatic void led_trigger_blink_setup(struct led_trigger *trig,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off,\r\nint oneshot,\r\nint invert)\r\n{\r\nstruct led_classdev *led_cdev;\r\nif (!trig)\r\nreturn;\r\nread_lock(&trig->leddev_list_lock);\r\nlist_for_each_entry(led_cdev, &trig->led_cdevs, trig_list) {\r\nif (oneshot)\r\nled_blink_set_oneshot(led_cdev, delay_on, delay_off,\r\ninvert);\r\nelse\r\nled_blink_set(led_cdev, delay_on, delay_off);\r\n}\r\nread_unlock(&trig->leddev_list_lock);\r\n}\r\nvoid led_trigger_blink(struct led_trigger *trig,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nled_trigger_blink_setup(trig, delay_on, delay_off, 0, 0);\r\n}\r\nvoid led_trigger_blink_oneshot(struct led_trigger *trig,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off,\r\nint invert)\r\n{\r\nled_trigger_blink_setup(trig, delay_on, delay_off, 1, invert);\r\n}\r\nvoid led_trigger_register_simple(const char *name, struct led_trigger **tp)\r\n{\r\nstruct led_trigger *trig;\r\nint err;\r\ntrig = kzalloc(sizeof(struct led_trigger), GFP_KERNEL);\r\nif (trig) {\r\ntrig->name = name;\r\nerr = led_trigger_register(trig);\r\nif (err < 0) {\r\nkfree(trig);\r\ntrig = NULL;\r\npr_warn("LED trigger %s failed to register (%d)\n",\r\nname, err);\r\n}\r\n} else {\r\npr_warn("LED trigger %s failed to register (no memory)\n",\r\nname);\r\n}\r\n*tp = trig;\r\n}\r\nvoid led_trigger_unregister_simple(struct led_trigger *trig)\r\n{\r\nif (trig)\r\nled_trigger_unregister(trig);\r\nkfree(trig);\r\n}
