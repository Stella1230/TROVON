struct qaob *qdio_allocate_aob(void)\r\n{\r\nreturn kmem_cache_zalloc(qdio_aob_cache, GFP_ATOMIC);\r\n}\r\nvoid qdio_release_aob(struct qaob *aob)\r\n{\r\nkmem_cache_free(qdio_aob_cache, aob);\r\n}\r\nvoid qdio_free_buffers(struct qdio_buffer **buf, unsigned int count)\r\n{\r\nint pos;\r\nfor (pos = 0; pos < count; pos += QBUFF_PER_PAGE)\r\nfree_page((unsigned long) buf[pos]);\r\n}\r\nint qdio_alloc_buffers(struct qdio_buffer **buf, unsigned int count)\r\n{\r\nint pos;\r\nfor (pos = 0; pos < count; pos += QBUFF_PER_PAGE) {\r\nbuf[pos] = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!buf[pos]) {\r\nqdio_free_buffers(buf, count);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (pos = 0; pos < count; pos++)\r\nif (pos % QBUFF_PER_PAGE)\r\nbuf[pos] = buf[pos - 1] + 1;\r\nreturn 0;\r\n}\r\nvoid qdio_reset_buffers(struct qdio_buffer **buf, unsigned int count)\r\n{\r\nint pos;\r\nfor (pos = 0; pos < count; pos++)\r\nmemset(buf[pos], 0, sizeof(struct qdio_buffer));\r\n}\r\nstatic inline int qebsm_possible(void)\r\n{\r\nreturn css_general_characteristics.qebsm;\r\n}\r\nstatic void set_impl_params(struct qdio_irq *irq_ptr,\r\nunsigned int qib_param_field_format,\r\nunsigned char *qib_param_field,\r\nunsigned long *input_slib_elements,\r\nunsigned long *output_slib_elements)\r\n{\r\nstruct qdio_q *q;\r\nint i, j;\r\nif (!irq_ptr)\r\nreturn;\r\nirq_ptr->qib.pfmt = qib_param_field_format;\r\nif (qib_param_field)\r\nmemcpy(irq_ptr->qib.parm, qib_param_field,\r\nQDIO_MAX_BUFFERS_PER_Q);\r\nif (!input_slib_elements)\r\ngoto output;\r\nfor_each_input_queue(irq_ptr, q, i) {\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\r\nq->slib->slibe[j].parms =\r\ninput_slib_elements[i * QDIO_MAX_BUFFERS_PER_Q + j];\r\n}\r\noutput:\r\nif (!output_slib_elements)\r\nreturn;\r\nfor_each_output_queue(irq_ptr, q, i) {\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\r\nq->slib->slibe[j].parms =\r\noutput_slib_elements[i * QDIO_MAX_BUFFERS_PER_Q + j];\r\n}\r\n}\r\nstatic int __qdio_allocate_qs(struct qdio_q **irq_ptr_qs, int nr_queues)\r\n{\r\nstruct qdio_q *q;\r\nint i;\r\nfor (i = 0; i < nr_queues; i++) {\r\nq = kmem_cache_alloc(qdio_q_cache, GFP_KERNEL);\r\nif (!q)\r\nreturn -ENOMEM;\r\nq->slib = (struct slib *) __get_free_page(GFP_KERNEL);\r\nif (!q->slib) {\r\nkmem_cache_free(qdio_q_cache, q);\r\nreturn -ENOMEM;\r\n}\r\nirq_ptr_qs[i] = q;\r\n}\r\nreturn 0;\r\n}\r\nint qdio_allocate_qs(struct qdio_irq *irq_ptr, int nr_input_qs, int nr_output_qs)\r\n{\r\nint rc;\r\nrc = __qdio_allocate_qs(irq_ptr->input_qs, nr_input_qs);\r\nif (rc)\r\nreturn rc;\r\nrc = __qdio_allocate_qs(irq_ptr->output_qs, nr_output_qs);\r\nreturn rc;\r\n}\r\nstatic void setup_queues_misc(struct qdio_q *q, struct qdio_irq *irq_ptr,\r\nqdio_handler_t *handler, int i)\r\n{\r\nstruct slib *slib = q->slib;\r\nmemset(q, 0, sizeof(*q));\r\nmemset(slib, 0, PAGE_SIZE);\r\nq->slib = slib;\r\nq->irq_ptr = irq_ptr;\r\nq->mask = 1 << (31 - i);\r\nq->nr = i;\r\nq->handler = handler;\r\n}\r\nstatic void setup_storage_lists(struct qdio_q *q, struct qdio_irq *irq_ptr,\r\nvoid **sbals_array, int i)\r\n{\r\nstruct qdio_q *prev;\r\nint j;\r\nDBF_HEX(&q, sizeof(void *));\r\nq->sl = (struct sl *)((char *)q->slib + PAGE_SIZE / 2);\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\r\nq->sbal[j] = *sbals_array++;\r\nif (i > 0) {\r\nprev = (q->is_input_q) ? irq_ptr->input_qs[i - 1]\r\n: irq_ptr->output_qs[i - 1];\r\nprev->slib->nsliba = (unsigned long)q->slib;\r\n}\r\nq->slib->sla = (unsigned long)q->sl;\r\nq->slib->slsba = (unsigned long)&q->slsb.val[0];\r\nfor (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; j++)\r\nq->sl->element[j].sbal = (unsigned long)q->sbal[j];\r\n}\r\nstatic void setup_queues(struct qdio_irq *irq_ptr,\r\nstruct qdio_initialize *qdio_init)\r\n{\r\nstruct qdio_q *q;\r\nvoid **input_sbal_array = qdio_init->input_sbal_addr_array;\r\nvoid **output_sbal_array = qdio_init->output_sbal_addr_array;\r\nstruct qdio_outbuf_state *output_sbal_state_array =\r\nqdio_init->output_sbal_state_array;\r\nint i;\r\nfor_each_input_queue(irq_ptr, q, i) {\r\nDBF_EVENT("inq:%1d", i);\r\nsetup_queues_misc(q, irq_ptr, qdio_init->input_handler, i);\r\nq->is_input_q = 1;\r\nq->u.in.queue_start_poll = qdio_init->queue_start_poll_array ?\r\nqdio_init->queue_start_poll_array[i] : NULL;\r\nsetup_storage_lists(q, irq_ptr, input_sbal_array, i);\r\ninput_sbal_array += QDIO_MAX_BUFFERS_PER_Q;\r\nif (is_thinint_irq(irq_ptr)) {\r\ntasklet_init(&q->tasklet, tiqdio_inbound_processing,\r\n(unsigned long) q);\r\n} else {\r\ntasklet_init(&q->tasklet, qdio_inbound_processing,\r\n(unsigned long) q);\r\n}\r\n}\r\nfor_each_output_queue(irq_ptr, q, i) {\r\nDBF_EVENT("outq:%1d", i);\r\nsetup_queues_misc(q, irq_ptr, qdio_init->output_handler, i);\r\nq->u.out.sbal_state = output_sbal_state_array;\r\noutput_sbal_state_array += QDIO_MAX_BUFFERS_PER_Q;\r\nq->is_input_q = 0;\r\nq->u.out.scan_threshold = qdio_init->scan_threshold;\r\nsetup_storage_lists(q, irq_ptr, output_sbal_array, i);\r\noutput_sbal_array += QDIO_MAX_BUFFERS_PER_Q;\r\ntasklet_init(&q->tasklet, qdio_outbound_processing,\r\n(unsigned long) q);\r\nsetup_timer(&q->u.out.timer, (void(*)(unsigned long))\r\n&qdio_outbound_timer, (unsigned long)q);\r\n}\r\n}\r\nstatic void process_ac_flags(struct qdio_irq *irq_ptr, unsigned char qdioac)\r\n{\r\nif (qdioac & AC1_SIGA_INPUT_NEEDED)\r\nirq_ptr->siga_flag.input = 1;\r\nif (qdioac & AC1_SIGA_OUTPUT_NEEDED)\r\nirq_ptr->siga_flag.output = 1;\r\nif (qdioac & AC1_SIGA_SYNC_NEEDED)\r\nirq_ptr->siga_flag.sync = 1;\r\nif (!(qdioac & AC1_AUTOMATIC_SYNC_ON_THININT))\r\nirq_ptr->siga_flag.sync_after_ai = 1;\r\nif (!(qdioac & AC1_AUTOMATIC_SYNC_ON_OUT_PCI))\r\nirq_ptr->siga_flag.sync_out_after_pci = 1;\r\n}\r\nstatic void check_and_setup_qebsm(struct qdio_irq *irq_ptr,\r\nunsigned char qdioac, unsigned long token)\r\n{\r\nif (!(irq_ptr->qib.rflags & QIB_RFLAGS_ENABLE_QEBSM))\r\ngoto no_qebsm;\r\nif (!(qdioac & AC1_SC_QEBSM_AVAILABLE) ||\r\n(!(qdioac & AC1_SC_QEBSM_ENABLED)))\r\ngoto no_qebsm;\r\nirq_ptr->sch_token = token;\r\nDBF_EVENT("V=V:1");\r\nDBF_EVENT("%8lx", irq_ptr->sch_token);\r\nreturn;\r\nno_qebsm:\r\nirq_ptr->sch_token = 0;\r\nirq_ptr->qib.rflags &= ~QIB_RFLAGS_ENABLE_QEBSM;\r\nDBF_EVENT("noV=V");\r\n}\r\nint qdio_setup_get_ssqd(struct qdio_irq *irq_ptr,\r\nstruct subchannel_id *schid,\r\nstruct qdio_ssqd_desc *data)\r\n{\r\nstruct chsc_ssqd_area *ssqd;\r\nint rc;\r\nDBF_EVENT("getssqd:%4x", schid->sch_no);\r\nif (!irq_ptr) {\r\nssqd = (struct chsc_ssqd_area *)__get_free_page(GFP_KERNEL);\r\nif (!ssqd)\r\nreturn -ENOMEM;\r\n} else {\r\nssqd = (struct chsc_ssqd_area *)irq_ptr->chsc_page;\r\n}\r\nrc = chsc_ssqd(*schid, ssqd);\r\nif (rc)\r\ngoto out;\r\nif (!(ssqd->qdio_ssqd.flags & CHSC_FLAG_QDIO_CAPABILITY) ||\r\n!(ssqd->qdio_ssqd.flags & CHSC_FLAG_VALIDITY) ||\r\n(ssqd->qdio_ssqd.sch != schid->sch_no))\r\nrc = -EINVAL;\r\nif (!rc)\r\nmemcpy(data, &ssqd->qdio_ssqd, sizeof(*data));\r\nout:\r\nif (!irq_ptr)\r\nfree_page((unsigned long)ssqd);\r\nreturn rc;\r\n}\r\nvoid qdio_setup_ssqd_info(struct qdio_irq *irq_ptr)\r\n{\r\nunsigned char qdioac;\r\nint rc;\r\nrc = qdio_setup_get_ssqd(irq_ptr, &irq_ptr->schid, &irq_ptr->ssqd_desc);\r\nif (rc) {\r\nDBF_ERROR("%4x ssqd ERR", irq_ptr->schid.sch_no);\r\nDBF_ERROR("rc:%x", rc);\r\nqdioac = AC1_SIGA_INPUT_NEEDED | AC1_SIGA_OUTPUT_NEEDED |\r\nAC1_SIGA_SYNC_NEEDED;\r\n} else\r\nqdioac = irq_ptr->ssqd_desc.qdioac1;\r\ncheck_and_setup_qebsm(irq_ptr, qdioac, irq_ptr->ssqd_desc.sch_token);\r\nprocess_ac_flags(irq_ptr, qdioac);\r\nDBF_EVENT("ac 1:%2x 2:%4x", qdioac, irq_ptr->ssqd_desc.qdioac2);\r\nDBF_EVENT("3:%4x qib:%4x", irq_ptr->ssqd_desc.qdioac3, irq_ptr->qib.ac);\r\n}\r\nvoid qdio_release_memory(struct qdio_irq *irq_ptr)\r\n{\r\nstruct qdio_q *q;\r\nint i;\r\nfor (i = 0; i < QDIO_MAX_QUEUES_PER_IRQ; i++) {\r\nq = irq_ptr->input_qs[i];\r\nif (q) {\r\nfree_page((unsigned long) q->slib);\r\nkmem_cache_free(qdio_q_cache, q);\r\n}\r\n}\r\nfor (i = 0; i < QDIO_MAX_QUEUES_PER_IRQ; i++) {\r\nq = irq_ptr->output_qs[i];\r\nif (q) {\r\nif (q->u.out.use_cq) {\r\nint n;\r\nfor (n = 0; n < QDIO_MAX_BUFFERS_PER_Q; ++n) {\r\nstruct qaob *aob = q->u.out.aobs[n];\r\nif (aob) {\r\nqdio_release_aob(aob);\r\nq->u.out.aobs[n] = NULL;\r\n}\r\n}\r\nqdio_disable_async_operation(&q->u.out);\r\n}\r\nfree_page((unsigned long) q->slib);\r\nkmem_cache_free(qdio_q_cache, q);\r\n}\r\n}\r\nfree_page((unsigned long) irq_ptr->qdr);\r\nfree_page(irq_ptr->chsc_page);\r\nfree_page((unsigned long) irq_ptr);\r\n}\r\nstatic void __qdio_allocate_fill_qdr(struct qdio_irq *irq_ptr,\r\nstruct qdio_q **irq_ptr_qs,\r\nint i, int nr)\r\n{\r\nirq_ptr->qdr->qdf0[i + nr].sliba =\r\n(unsigned long)irq_ptr_qs[i]->slib;\r\nirq_ptr->qdr->qdf0[i + nr].sla =\r\n(unsigned long)irq_ptr_qs[i]->sl;\r\nirq_ptr->qdr->qdf0[i + nr].slsba =\r\n(unsigned long)&irq_ptr_qs[i]->slsb.val[0];\r\nirq_ptr->qdr->qdf0[i + nr].akey = PAGE_DEFAULT_KEY >> 4;\r\nirq_ptr->qdr->qdf0[i + nr].bkey = PAGE_DEFAULT_KEY >> 4;\r\nirq_ptr->qdr->qdf0[i + nr].ckey = PAGE_DEFAULT_KEY >> 4;\r\nirq_ptr->qdr->qdf0[i + nr].dkey = PAGE_DEFAULT_KEY >> 4;\r\n}\r\nstatic void setup_qdr(struct qdio_irq *irq_ptr,\r\nstruct qdio_initialize *qdio_init)\r\n{\r\nint i;\r\nirq_ptr->qdr->qfmt = qdio_init->q_format;\r\nirq_ptr->qdr->ac = qdio_init->qdr_ac;\r\nirq_ptr->qdr->iqdcnt = qdio_init->no_input_qs;\r\nirq_ptr->qdr->oqdcnt = qdio_init->no_output_qs;\r\nirq_ptr->qdr->iqdsz = sizeof(struct qdesfmt0) / 4;\r\nirq_ptr->qdr->oqdsz = sizeof(struct qdesfmt0) / 4;\r\nirq_ptr->qdr->qiba = (unsigned long)&irq_ptr->qib;\r\nirq_ptr->qdr->qkey = PAGE_DEFAULT_KEY >> 4;\r\nfor (i = 0; i < qdio_init->no_input_qs; i++)\r\n__qdio_allocate_fill_qdr(irq_ptr, irq_ptr->input_qs, i, 0);\r\nfor (i = 0; i < qdio_init->no_output_qs; i++)\r\n__qdio_allocate_fill_qdr(irq_ptr, irq_ptr->output_qs, i,\r\nqdio_init->no_input_qs);\r\n}\r\nstatic void setup_qib(struct qdio_irq *irq_ptr,\r\nstruct qdio_initialize *init_data)\r\n{\r\nif (qebsm_possible())\r\nirq_ptr->qib.rflags |= QIB_RFLAGS_ENABLE_QEBSM;\r\nirq_ptr->qib.rflags |= init_data->qib_rflags;\r\nirq_ptr->qib.qfmt = init_data->q_format;\r\nif (init_data->no_input_qs)\r\nirq_ptr->qib.isliba =\r\n(unsigned long)(irq_ptr->input_qs[0]->slib);\r\nif (init_data->no_output_qs)\r\nirq_ptr->qib.osliba =\r\n(unsigned long)(irq_ptr->output_qs[0]->slib);\r\nmemcpy(irq_ptr->qib.ebcnam, init_data->adapter_name, 8);\r\n}\r\nint qdio_setup_irq(struct qdio_initialize *init_data)\r\n{\r\nstruct ciw *ciw;\r\nstruct qdio_irq *irq_ptr = init_data->cdev->private->qdio_data;\r\nint rc;\r\nmemset(&irq_ptr->qib, 0, sizeof(irq_ptr->qib));\r\nmemset(&irq_ptr->siga_flag, 0, sizeof(irq_ptr->siga_flag));\r\nmemset(&irq_ptr->ccw, 0, sizeof(irq_ptr->ccw));\r\nmemset(&irq_ptr->ssqd_desc, 0, sizeof(irq_ptr->ssqd_desc));\r\nmemset(&irq_ptr->perf_stat, 0, sizeof(irq_ptr->perf_stat));\r\nirq_ptr->debugfs_dev = irq_ptr->debugfs_perf = NULL;\r\nirq_ptr->sch_token = irq_ptr->state = irq_ptr->perf_stat_enabled = 0;\r\nmemset(irq_ptr->qdr, 0, sizeof(struct qdr));\r\nirq_ptr->int_parm = init_data->int_parm;\r\nirq_ptr->nr_input_qs = init_data->no_input_qs;\r\nirq_ptr->nr_output_qs = init_data->no_output_qs;\r\nirq_ptr->cdev = init_data->cdev;\r\nccw_device_get_schid(irq_ptr->cdev, &irq_ptr->schid);\r\nsetup_queues(irq_ptr, init_data);\r\nsetup_qib(irq_ptr, init_data);\r\nqdio_setup_thinint(irq_ptr);\r\nset_impl_params(irq_ptr, init_data->qib_param_field_format,\r\ninit_data->qib_param_field,\r\ninit_data->input_slib_elements,\r\ninit_data->output_slib_elements);\r\nsetup_qdr(irq_ptr, init_data);\r\nciw = ccw_device_get_ciw(init_data->cdev, CIW_TYPE_EQUEUE);\r\nif (!ciw) {\r\nDBF_ERROR("%4x NO EQ", irq_ptr->schid.sch_no);\r\nrc = -EINVAL;\r\ngoto out_err;\r\n}\r\nirq_ptr->equeue = *ciw;\r\nciw = ccw_device_get_ciw(init_data->cdev, CIW_TYPE_AQUEUE);\r\nif (!ciw) {\r\nDBF_ERROR("%4x NO AQ", irq_ptr->schid.sch_no);\r\nrc = -EINVAL;\r\ngoto out_err;\r\n}\r\nirq_ptr->aqueue = *ciw;\r\nirq_ptr->orig_handler = init_data->cdev->handler;\r\ninit_data->cdev->handler = qdio_int_handler;\r\nreturn 0;\r\nout_err:\r\nqdio_release_memory(irq_ptr);\r\nreturn rc;\r\n}\r\nvoid qdio_print_subchannel_info(struct qdio_irq *irq_ptr,\r\nstruct ccw_device *cdev)\r\n{\r\nchar s[80];\r\nsnprintf(s, 80, "qdio: %s %s on SC %x using "\r\n"AI:%d QEBSM:%d PRI:%d TDD:%d SIGA:%s%s%s%s%s\n",\r\ndev_name(&cdev->dev),\r\n(irq_ptr->qib.qfmt == QDIO_QETH_QFMT) ? "OSA" :\r\n((irq_ptr->qib.qfmt == QDIO_ZFCP_QFMT) ? "ZFCP" : "HS"),\r\nirq_ptr->schid.sch_no,\r\nis_thinint_irq(irq_ptr),\r\n(irq_ptr->sch_token) ? 1 : 0,\r\n(irq_ptr->qib.ac & QIB_AC_OUTBOUND_PCI_SUPPORTED) ? 1 : 0,\r\ncss_general_characteristics.aif_tdd,\r\n(irq_ptr->siga_flag.input) ? "R" : " ",\r\n(irq_ptr->siga_flag.output) ? "W" : " ",\r\n(irq_ptr->siga_flag.sync) ? "S" : " ",\r\n(irq_ptr->siga_flag.sync_after_ai) ? "A" : " ",\r\n(irq_ptr->siga_flag.sync_out_after_pci) ? "P" : " ");\r\nprintk(KERN_INFO "%s", s);\r\n}\r\nint qdio_enable_async_operation(struct qdio_output_q *outq)\r\n{\r\noutq->aobs = kzalloc(sizeof(struct qaob *) * QDIO_MAX_BUFFERS_PER_Q,\r\nGFP_ATOMIC);\r\nif (!outq->aobs) {\r\noutq->use_cq = 0;\r\nreturn -ENOMEM;\r\n}\r\noutq->use_cq = 1;\r\nreturn 0;\r\n}\r\nvoid qdio_disable_async_operation(struct qdio_output_q *q)\r\n{\r\nkfree(q->aobs);\r\nq->aobs = NULL;\r\nq->use_cq = 0;\r\n}\r\nint __init qdio_setup_init(void)\r\n{\r\nint rc;\r\nqdio_q_cache = kmem_cache_create("qdio_q", sizeof(struct qdio_q),\r\n256, 0, NULL);\r\nif (!qdio_q_cache)\r\nreturn -ENOMEM;\r\nqdio_aob_cache = kmem_cache_create("qdio_aob",\r\nsizeof(struct qaob),\r\nsizeof(struct qaob),\r\n0,\r\nNULL);\r\nif (!qdio_aob_cache) {\r\nrc = -ENOMEM;\r\ngoto free_qdio_q_cache;\r\n}\r\nDBF_EVENT("thinint:%1d",\r\n(css_general_characteristics.aif_osa) ? 1 : 0);\r\nDBF_EVENT("cssQEBSM:%1d", (qebsm_possible()) ? 1 : 0);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nfree_qdio_q_cache:\r\nkmem_cache_destroy(qdio_q_cache);\r\ngoto out;\r\n}\r\nvoid qdio_setup_exit(void)\r\n{\r\nkmem_cache_destroy(qdio_aob_cache);\r\nkmem_cache_destroy(qdio_q_cache);\r\n}
