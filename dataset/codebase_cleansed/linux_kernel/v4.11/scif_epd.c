void scif_cleanup_ep_qp(struct scif_endpt *ep)\r\n{\r\nstruct scif_qp *qp = ep->qp_info.qp;\r\nif (qp->outbound_q.rb_base) {\r\nscif_iounmap((void *)qp->outbound_q.rb_base,\r\nqp->outbound_q.size, ep->remote_dev);\r\nqp->outbound_q.rb_base = NULL;\r\n}\r\nif (qp->remote_qp) {\r\nscif_iounmap((void *)qp->remote_qp,\r\nsizeof(struct scif_qp), ep->remote_dev);\r\nqp->remote_qp = NULL;\r\n}\r\nif (qp->local_qp) {\r\nscif_unmap_single(qp->local_qp, ep->remote_dev,\r\nsizeof(struct scif_qp));\r\nqp->local_qp = 0x0;\r\n}\r\nif (qp->local_buf) {\r\nscif_unmap_single(qp->local_buf, ep->remote_dev,\r\nSCIF_ENDPT_QP_SIZE);\r\nqp->local_buf = 0;\r\n}\r\n}\r\nvoid scif_teardown_ep(void *endpt)\r\n{\r\nstruct scif_endpt *ep = endpt;\r\nstruct scif_qp *qp = ep->qp_info.qp;\r\nif (qp) {\r\nspin_lock(&ep->lock);\r\nscif_cleanup_ep_qp(ep);\r\nspin_unlock(&ep->lock);\r\nkfree(qp->inbound_q.rb_base);\r\nkfree(qp);\r\n}\r\n}\r\nvoid scif_add_epd_to_zombie_list(struct scif_endpt *ep, bool eplock_held)\r\n{\r\nif (!eplock_held)\r\nmutex_lock(&scif_info.eplock);\r\nspin_lock(&ep->lock);\r\nep->state = SCIFEP_ZOMBIE;\r\nspin_unlock(&ep->lock);\r\nlist_add_tail(&ep->list, &scif_info.zombie);\r\nscif_info.nr_zombies++;\r\nif (!eplock_held)\r\nmutex_unlock(&scif_info.eplock);\r\nschedule_work(&scif_info.misc_work);\r\n}\r\nstatic struct scif_endpt *scif_find_listen_ep(u16 port)\r\n{\r\nstruct scif_endpt *ep = NULL;\r\nstruct list_head *pos, *tmpq;\r\nmutex_lock(&scif_info.eplock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.listen) {\r\nep = list_entry(pos, struct scif_endpt, list);\r\nif (ep->port.port == port) {\r\nmutex_unlock(&scif_info.eplock);\r\nreturn ep;\r\n}\r\n}\r\nmutex_unlock(&scif_info.eplock);\r\nreturn NULL;\r\n}\r\nvoid scif_cleanup_zombie_epd(void)\r\n{\r\nstruct list_head *pos, *tmpq;\r\nstruct scif_endpt *ep;\r\nmutex_lock(&scif_info.eplock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.zombie) {\r\nep = list_entry(pos, struct scif_endpt, list);\r\nif (scif_rma_ep_can_uninit(ep)) {\r\nlist_del(pos);\r\nscif_info.nr_zombies--;\r\nput_iova_domain(&ep->rma_info.iovad);\r\nkfree(ep);\r\n}\r\n}\r\nmutex_unlock(&scif_info.eplock);\r\n}\r\nvoid scif_cnctreq(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = NULL;\r\nstruct scif_conreq *conreq;\r\nconreq = kmalloc(sizeof(*conreq), GFP_KERNEL);\r\nif (!conreq)\r\ngoto conreq_sendrej;\r\nep = scif_find_listen_ep(msg->dst.port);\r\nif (!ep)\r\ngoto conreq_sendrej_free;\r\nelse\r\nspin_lock(&ep->lock);\r\nif (ep->backlog <= ep->conreqcnt) {\r\nspin_unlock(&ep->lock);\r\ngoto conreq_sendrej_free;\r\n}\r\nconreq->msg = *msg;\r\nlist_add_tail(&conreq->list, &ep->conlist);\r\nep->conreqcnt++;\r\nwake_up_interruptible(&ep->conwq);\r\nspin_unlock(&ep->lock);\r\nreturn;\r\nconreq_sendrej_free:\r\nkfree(conreq);\r\nconreq_sendrej:\r\nmsg->uop = SCIF_CNCT_REJ;\r\nscif_nodeqp_send(&scif_dev[msg->src.node], msg);\r\n}\r\nvoid scif_cnctgnt(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nif (SCIFEP_CONNECTING == ep->state) {\r\nep->peer.node = msg->src.node;\r\nep->peer.port = msg->src.port;\r\nep->qp_info.gnt_pld = msg->payload[1];\r\nep->remote_ep = msg->payload[2];\r\nep->state = SCIFEP_MAPPING;\r\nwake_up(&ep->conwq);\r\n}\r\nspin_unlock(&ep->lock);\r\n}\r\nvoid scif_cnctgnt_ack(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nmutex_lock(&scif_info.connlock);\r\nspin_lock(&ep->lock);\r\nep->state = SCIFEP_CONNECTED;\r\nlist_add_tail(&ep->list, &scif_info.connected);\r\nwake_up(&ep->conwq);\r\nspin_unlock(&ep->lock);\r\nmutex_unlock(&scif_info.connlock);\r\n}\r\nvoid scif_cnctgnt_nack(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nep->state = SCIFEP_CLOSING;\r\nwake_up(&ep->conwq);\r\nspin_unlock(&ep->lock);\r\n}\r\nvoid scif_cnctrej(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nif (SCIFEP_CONNECTING == ep->state) {\r\nep->state = SCIFEP_BOUND;\r\nwake_up(&ep->conwq);\r\n}\r\nspin_unlock(&ep->lock);\r\n}\r\nvoid scif_discnct(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = NULL;\r\nstruct scif_endpt *tmpep;\r\nstruct list_head *pos, *tmpq;\r\nmutex_lock(&scif_info.connlock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.connected) {\r\ntmpep = list_entry(pos, struct scif_endpt, list);\r\nif (((u64)tmpep == msg->payload[1]) &&\r\n((u64)tmpep->remote_ep == msg->payload[0])) {\r\nlist_del(pos);\r\nep = tmpep;\r\nspin_lock(&ep->lock);\r\nbreak;\r\n}\r\n}\r\nif (!ep) {\r\nmutex_unlock(&scif_info.connlock);\r\ngoto discnct_ack;\r\n}\r\nep->state = SCIFEP_DISCONNECTED;\r\nlist_add_tail(&ep->list, &scif_info.disconnected);\r\nwake_up_interruptible(&ep->sendwq);\r\nwake_up_interruptible(&ep->recvwq);\r\nspin_unlock(&ep->lock);\r\nmutex_unlock(&scif_info.connlock);\r\ndiscnct_ack:\r\nmsg->uop = SCIF_DISCNT_ACK;\r\nscif_nodeqp_send(&scif_dev[msg->src.node], msg);\r\n}\r\nvoid scif_discnt_ack(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nep->state = SCIFEP_DISCONNECTED;\r\nspin_unlock(&ep->lock);\r\ncomplete(&ep->discon);\r\n}\r\nvoid scif_clientsend(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nif (SCIFEP_CONNECTED == ep->state)\r\nwake_up_interruptible(&ep->recvwq);\r\nspin_unlock(&ep->lock);\r\n}\r\nvoid scif_clientrcvd(struct scif_dev *scifdev, struct scifmsg *msg)\r\n{\r\nstruct scif_endpt *ep = (struct scif_endpt *)msg->payload[0];\r\nspin_lock(&ep->lock);\r\nif (SCIFEP_CONNECTED == ep->state)\r\nwake_up_interruptible(&ep->sendwq);\r\nspin_unlock(&ep->lock);\r\n}
