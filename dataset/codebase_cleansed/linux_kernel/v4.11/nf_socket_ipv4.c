static int\r\nextract_icmp4_fields(const struct sk_buff *skb, u8 *protocol,\r\n__be32 *raddr, __be32 *laddr,\r\n__be16 *rport, __be16 *lport)\r\n{\r\nunsigned int outside_hdrlen = ip_hdrlen(skb);\r\nstruct iphdr *inside_iph, _inside_iph;\r\nstruct icmphdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nswitch (icmph->type) {\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_REDIRECT:\r\ncase ICMP_TIME_EXCEEDED:\r\ncase ICMP_PARAMETERPROB:\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr),\r\nsizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\nif (inside_iph->protocol != IPPROTO_TCP &&\r\ninside_iph->protocol != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr) +\r\n(inside_iph->ihl << 2),\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_iph->protocol;\r\n*laddr = inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nnf_socket_get_sock_v4(struct net *net, struct sk_buff *skb, const int doff,\r\nconst u8 protocol,\r\nconst __be32 saddr, const __be32 daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn inet_lookup(net, &tcp_hashinfo, skb, doff,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp4_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstruct sock *nf_sk_lookup_slow_v4(struct net *net, const struct sk_buff *skb,\r\nconst struct net_device *indev)\r\n{\r\n__be32 uninitialized_var(daddr), uninitialized_var(saddr);\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct sk_buff *data_skb = NULL;\r\nu8 uninitialized_var(protocol);\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn const *ct;\r\n#endif\r\nint doff = 0;\r\nif (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {\r\nstruct udphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NULL;\r\nprotocol = iph->protocol;\r\nsaddr = iph->saddr;\r\nsport = hp->source;\r\ndaddr = iph->daddr;\r\ndport = hp->dest;\r\ndata_skb = (struct sk_buff *)skb;\r\ndoff = iph->protocol == IPPROTO_TCP ?\r\nip_hdrlen(skb) + __tcp_hdrlen((struct tcphdr *)hp) :\r\nip_hdrlen(skb) + sizeof(*hp);\r\n} else if (iph->protocol == IPPROTO_ICMP) {\r\nif (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn NULL;\r\n} else {\r\nreturn NULL;\r\n}\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct) &&\r\n((iph->protocol != IPPROTO_ICMP &&\r\nctinfo == IP_CT_ESTABLISHED_REPLY) ||\r\n(iph->protocol == IPPROTO_ICMP &&\r\nctinfo == IP_CT_RELATED_REPLY)) &&\r\n(ct->status & IPS_SRC_NAT_DONE)) {\r\ndaddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\r\ndport = (iph->protocol == IPPROTO_TCP) ?\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;\r\n}\r\n#endif\r\nreturn nf_socket_get_sock_v4(net, data_skb, doff, protocol, saddr,\r\ndaddr, sport, dport, indev);\r\n}
