static struct mt9t112_priv *to_mt9t112(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client),\r\nstruct mt9t112_priv,\r\nsubdev);\r\n}\r\nstatic int __mt9t112_reg_read(const struct i2c_client *client, u16 command)\r\n{\r\nstruct i2c_msg msg[2];\r\nu8 buf[2];\r\nint ret;\r\ncommand = swab16(command);\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = (u8 *)&command;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = 2;\r\nmsg[1].buf = buf;\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nmemcpy(&ret, buf, 2);\r\nreturn swab16(ret);\r\n}\r\nstatic int __mt9t112_reg_write(const struct i2c_client *client,\r\nu16 command, u16 data)\r\n{\r\nstruct i2c_msg msg;\r\nu8 buf[4];\r\nint ret;\r\ncommand = swab16(command);\r\ndata = swab16(data);\r\nmemcpy(buf + 0, &command, 2);\r\nmemcpy(buf + 2, &data, 2);\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 4;\r\nmsg.buf = buf;\r\nret = i2c_transfer(client->adapter, &msg, 1);\r\nif (ret >= 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int __mt9t112_reg_mask_set(const struct i2c_client *client,\r\nu16 command,\r\nu16 mask,\r\nu16 set)\r\n{\r\nint val = __mt9t112_reg_read(client, command);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\nreturn __mt9t112_reg_write(client, command, val);\r\n}\r\nstatic int __mt9t112_mcu_read(const struct i2c_client *client, u16 command)\r\n{\r\nint ret;\r\nret = __mt9t112_reg_write(client, 0x098E, command);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __mt9t112_reg_read(client, 0x0990);\r\n}\r\nstatic int __mt9t112_mcu_write(const struct i2c_client *client,\r\nu16 command, u16 data)\r\n{\r\nint ret;\r\nret = __mt9t112_reg_write(client, 0x098E, command);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn __mt9t112_reg_write(client, 0x0990, data);\r\n}\r\nstatic int __mt9t112_mcu_mask_set(const struct i2c_client *client,\r\nu16 command,\r\nu16 mask,\r\nu16 set)\r\n{\r\nint val = __mt9t112_mcu_read(client, command);\r\nif (val < 0)\r\nreturn val;\r\nval &= ~mask;\r\nval |= set & mask;\r\nreturn __mt9t112_mcu_write(client, command, val);\r\n}\r\nstatic int mt9t112_reset(const struct i2c_client *client)\r\n{\r\nint ret;\r\nmt9t112_reg_mask_set(ret, client, 0x001a, 0x0001, 0x0001);\r\nmsleep(1);\r\nmt9t112_reg_mask_set(ret, client, 0x001a, 0x0001, 0x0000);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_clock_info(const struct i2c_client *client, u32 ext)\r\n{\r\nint m, n, p1, p2, p3, p4, p5, p6, p7;\r\nu32 vco, clk;\r\nchar *enable;\r\next /= 1000;\r\nmt9t112_reg_read(n, client, 0x0012);\r\np1 = n & 0x000f;\r\nn = n >> 4;\r\np2 = n & 0x000f;\r\nn = n >> 4;\r\np3 = n & 0x000f;\r\nmt9t112_reg_read(n, client, 0x002a);\r\np4 = n & 0x000f;\r\nn = n >> 4;\r\np5 = n & 0x000f;\r\nn = n >> 4;\r\np6 = n & 0x000f;\r\nmt9t112_reg_read(n, client, 0x002c);\r\np7 = n & 0x000f;\r\nmt9t112_reg_read(n, client, 0x0010);\r\nm = n & 0x00ff;\r\nn = (n >> 8) & 0x003f;\r\nenable = ((6000 > ext) || (54000 < ext)) ? "X" : "";\r\ndev_dbg(&client->dev, "EXTCLK : %10u K %s\n", ext, enable);\r\nvco = 2 * m * ext / (n+1);\r\nenable = ((384000 > vco) || (768000 < vco)) ? "X" : "";\r\ndev_dbg(&client->dev, "VCO : %10u K %s\n", vco, enable);\r\nclk = vco / (p1+1) / (p2+1);\r\nenable = (96000 < clk) ? "X" : "";\r\ndev_dbg(&client->dev, "PIXCLK : %10u K %s\n", clk, enable);\r\nclk = vco / (p3+1);\r\nenable = (768000 < clk) ? "X" : "";\r\ndev_dbg(&client->dev, "MIPICLK : %10u K %s\n", clk, enable);\r\nclk = vco / (p6+1);\r\nenable = (96000 < clk) ? "X" : "";\r\ndev_dbg(&client->dev, "MCU CLK : %10u K %s\n", clk, enable);\r\nclk = vco / (p5+1);\r\nenable = (54000 < clk) ? "X" : "";\r\ndev_dbg(&client->dev, "SOC CLK : %10u K %s\n", clk, enable);\r\nclk = vco / (p4+1);\r\nenable = (70000 < clk) ? "X" : "";\r\ndev_dbg(&client->dev, "Sensor CLK : %10u K %s\n", clk, enable);\r\nclk = vco / (p7+1);\r\ndev_dbg(&client->dev, "External sensor : %10u K\n", clk);\r\nclk = ext / (n+1);\r\nenable = ((2000 > clk) || (24000 < clk)) ? "X" : "";\r\ndev_dbg(&client->dev, "PFD : %10u K %s\n", clk, enable);\r\nreturn 0;\r\n}\r\nstatic void mt9t112_frame_check(u32 *width, u32 *height, u32 *left, u32 *top)\r\n{\r\nsoc_camera_limit_side(left, width, 0, 0, MAX_WIDTH);\r\nsoc_camera_limit_side(top, height, 0, 0, MAX_HEIGHT);\r\n}\r\nstatic int mt9t112_set_a_frame_size(const struct i2c_client *client,\r\nu16 width,\r\nu16 height)\r\n{\r\nint ret;\r\nu16 wstart = (MAX_WIDTH - width) / 2;\r\nu16 hstart = (MAX_HEIGHT - height) / 2;\r\nmt9t112_mcu_write(ret, client, VAR(26, 0), width);\r\nmt9t112_mcu_write(ret, client, VAR(26, 2), height);\r\nmt9t112_mcu_write(ret, client, VAR(18, 43), 8 + width);\r\nmt9t112_mcu_write(ret, client, VAR(18, 45), 8 + height);\r\nmt9t112_mcu_write(ret, client, VAR(18, 2), 4 + hstart);\r\nmt9t112_mcu_write(ret, client, VAR(18, 4), 4 + wstart);\r\nmt9t112_mcu_write(ret, client, VAR(18, 6), 11 + height + hstart);\r\nmt9t112_mcu_write(ret, client, VAR(18, 8), 11 + width + wstart);\r\nmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x06);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_set_pll_dividers(const struct i2c_client *client,\r\nu8 m, u8 n,\r\nu8 p1, u8 p2, u8 p3,\r\nu8 p4, u8 p5, u8 p6,\r\nu8 p7)\r\n{\r\nint ret;\r\nu16 val;\r\nval = (n << 8) |\r\n(m << 0);\r\nmt9t112_reg_mask_set(ret, client, 0x0010, 0x3fff, val);\r\nval = ((p3 & 0x0F) << 8) |\r\n((p2 & 0x0F) << 4) |\r\n((p1 & 0x0F) << 0);\r\nmt9t112_reg_mask_set(ret, client, 0x0012, 0x0fff, val);\r\nval = (0x7 << 12) |\r\n((p6 & 0x0F) << 8) |\r\n((p5 & 0x0F) << 4) |\r\n((p4 & 0x0F) << 0);\r\nmt9t112_reg_mask_set(ret, client, 0x002A, 0x7fff, val);\r\nval = (0x1 << 12) |\r\n((p7 & 0x0F) << 0);\r\nmt9t112_reg_mask_set(ret, client, 0x002C, 0x100f, val);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_init_pll(const struct i2c_client *client)\r\n{\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nint data, i, ret;\r\nmt9t112_reg_mask_set(ret, client, 0x0014, 0x003, 0x0001);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x2145);\r\nmt9t112_set_pll_dividers(client,\r\npriv->info->divider.m,\r\npriv->info->divider.n,\r\npriv->info->divider.p1,\r\npriv->info->divider.p2,\r\npriv->info->divider.p3,\r\npriv->info->divider.p4,\r\npriv->info->divider.p5,\r\npriv->info->divider.p6,\r\npriv->info->divider.p7);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x2525);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x2527);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x3427);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x3027);\r\nmdelay(10);\r\nmt9t112_reg_write(ret, client, 0x0014, 0x3046);\r\nmt9t112_reg_write(ret, client, 0x0016, 0x0400);\r\nmt9t112_reg_write(ret, client, 0x0022, 0x0190);\r\nmt9t112_reg_write(ret, client, 0x3B84, 0x0212);\r\nmt9t112_reg_write(ret, client, 0x002E, 0x0500);\r\nmt9t112_reg_mask_set(ret, client, 0x0018, 0x0002, 0x0002);\r\nmt9t112_reg_mask_set(ret, client, 0x3B82, 0x0004, 0x0004);\r\nmt9t112_reg_mask_set(ret, client, 0x0018, 0x0004, 0x0004);\r\nmt9t112_reg_mask_set(ret, client, 0x0018, 0x0001, 0);\r\nmdelay(50);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0001);\r\nmdelay(1);\r\nfor (i = 0; i < 100; i++) {\r\nmt9t112_reg_read(data, client, 0x0018);\r\nif (!(0x4000 & data))\r\nbreak;\r\nmdelay(10);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9t112_init_setting(const struct i2c_client *client)\r\n{\r\nint ret;\r\nmt9t112_mcu_mask_set(ret, client, VAR(26, 160), 0x0040, 0x0000);\r\nmt9t112_mcu_write(ret, client, VAR(18, 12), 0x0024);\r\nmt9t112_mcu_write(ret, client, VAR(18, 15), 0x00CC);\r\nmt9t112_mcu_write(ret, client, VAR(18, 17), 0x01f1);\r\nmt9t112_mcu_write(ret, client, VAR(18, 19), 0x00fF);\r\nmt9t112_mcu_write(ret, client, VAR(18, 29), 0x032D);\r\nmt9t112_mcu_write(ret, client, VAR(18, 31), 0x073a);\r\nmt9t112_mcu_write(ret, client, VAR(18, 37), 0x07d0);\r\nmt9t112_mcu_mask_set(ret, client, VAR(27, 160), 0x0040, 0x0000);\r\nmt9t112_mcu_write(ret, client, VAR(18, 74), 0x004);\r\nmt9t112_mcu_write(ret, client, VAR(18, 76), 0x004);\r\nmt9t112_mcu_write(ret, client, VAR(18, 78), 0x60B);\r\nmt9t112_mcu_write(ret, client, VAR(18, 80), 0x80B);\r\nmt9t112_mcu_write(ret, client, VAR(18, 87), 0x008C);\r\nmt9t112_mcu_write(ret, client, VAR(18, 89), 0x01F1);\r\nmt9t112_mcu_write(ret, client, VAR(18, 91), 0x00FF);\r\nmt9t112_mcu_write(ret, client, VAR(18, 101), 0x0668);\r\nmt9t112_mcu_write(ret, client, VAR(18, 103), 0x0AF0);\r\nmt9t112_mcu_write(ret, client, VAR(18, 109), 0x0AF0);\r\nmt9t112_mcu_write(ret, client, VAR8(8, 5), 0x01);\r\nmt9t112_mcu_write(ret, client, VAR(27, 17), 0x0003);\r\nmt9t112_mcu_write(ret, client, VAR(26, 17), 0x0003);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 165), 0x25);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 166), 0x28);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 167), 0x2C);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 168), 0x2F);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 68), 0xBA);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 303), 0x00);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 69), 0x9B);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 301), 0x00);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 140), 0x82);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 304), 0x00);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 141), 0x6D);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 302), 0x00);\r\nmt9t112_mcu_write(ret, client, VAR8(8, 2), 0x10);\r\nmt9t112_mcu_write(ret, client, VAR8(8, 9), 0x02);\r\nmt9t112_mcu_write(ret, client, VAR8(8, 10), 0x03);\r\nmt9t112_mcu_write(ret, client, VAR8(8, 12), 0x0A);\r\nmt9t112_mcu_write(ret, client, VAR(18, 70), 0x0014);\r\nmt9t112_mcu_write(ret, client, VAR(18, 142), 0x0014);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x0044), 133);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x0045), 110);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x008c), 130);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x008d), 108);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x00A5), 27);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x00a6), 30);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x00a7), 32);\r\nmt9t112_mcu_write(ret, client, VAR8(18, 0x00a8), 35);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_auto_focus_setting(const struct i2c_client *client)\r\n{\r\nint ret;\r\nmt9t112_mcu_write(ret, client, VAR(12, 13), 0x000F);\r\nmt9t112_mcu_write(ret, client, VAR(12, 23), 0x0F0F);\r\nmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x06);\r\nmt9t112_reg_write(ret, client, 0x0614, 0x0000);\r\nmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x05);\r\nmt9t112_mcu_write(ret, client, VAR8(12, 2), 0x02);\r\nmt9t112_mcu_write(ret, client, VAR(12, 3), 0x0002);\r\nmt9t112_mcu_write(ret, client, VAR(17, 3), 0x8001);\r\nmt9t112_mcu_write(ret, client, VAR(17, 11), 0x0025);\r\nmt9t112_mcu_write(ret, client, VAR(17, 13), 0x0193);\r\nmt9t112_mcu_write(ret, client, VAR8(17, 33), 0x18);\r\nmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x05);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_auto_focus_trigger(const struct i2c_client *client)\r\n{\r\nint ret;\r\nmt9t112_mcu_write(ret, client, VAR8(12, 25), 0x01);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_init_camera(const struct i2c_client *client)\r\n{\r\nint ret;\r\nECHECKER(ret, mt9t112_reset(client));\r\nECHECKER(ret, mt9t112_init_pll(client));\r\nECHECKER(ret, mt9t112_init_setting(client));\r\nECHECKER(ret, mt9t112_auto_focus_setting(client));\r\nmt9t112_reg_mask_set(ret, client, 0x0018, 0x0004, 0);\r\nmt9t112_reg_write(ret, client, 0x3084, 0x2409);\r\nmt9t112_reg_write(ret, client, 0x3092, 0x0A49);\r\nmt9t112_reg_write(ret, client, 0x3094, 0x4949);\r\nmt9t112_reg_write(ret, client, 0x3096, 0x4950);\r\nmt9t112_mcu_write(ret, client, VAR(26, 160), 0x0A2E);\r\nmt9t112_mcu_write(ret, client, VAR(27, 160), 0x0A2E);\r\nmt9t112_mcu_write(ret, client, VAR(27, 144), 0x0CB4);\r\nmt9t112_mcu_write(ret, client, VAR8(27, 142), 0x01);\r\nmt9t112_reg_write(ret, client, 0x316C, 0x350F);\r\nmt9t112_reg_write(ret, client, 0x1E, 0x777);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nreg->size = 2;\r\nmt9t112_reg_read(ret, client, reg->reg);\r\nreg->val = (__u64)ret;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nmt9t112_reg_write(ret, client, reg->reg, reg->val);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nreturn soc_camera_set_power(&client->dev, ssdd, priv->clk, on);\r\n}\r\nstatic int mt9t112_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nint ret = 0;\r\nif (!enable) {\r\nmt9t112_set_a_frame_size(client, VGA_WIDTH, VGA_HEIGHT);\r\nreturn ret;\r\n}\r\nif (!(priv->flags & INIT_DONE)) {\r\nu16 param = PCLK_RISING & priv->flags ? 0x0001 : 0x0000;\r\nECHECKER(ret, mt9t112_init_camera(client));\r\nmt9t112_reg_write(ret, client, 0x3C20, param);\r\nmdelay(5);\r\npriv->flags |= INIT_DONE;\r\n}\r\nmt9t112_mcu_write(ret, client, VAR(26, 7), priv->format->fmt);\r\nmt9t112_mcu_write(ret, client, VAR(26, 9), priv->format->order);\r\nmt9t112_mcu_write(ret, client, VAR8(1, 0), 0x06);\r\nmt9t112_set_a_frame_size(client,\r\npriv->frame.width,\r\npriv->frame.height);\r\nECHECKER(ret, mt9t112_auto_focus_trigger(client));\r\ndev_dbg(&client->dev, "format : %d\n", priv->format->code);\r\ndev_dbg(&client->dev, "size : %d x %d\n",\r\npriv->frame.width,\r\npriv->frame.height);\r\nCLOCK_INFO(client, EXT_CLOCK);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_set_params(struct mt9t112_priv *priv,\r\nconst struct v4l2_rect *rect,\r\nu32 code)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->num_formats; i++)\r\nif (mt9t112_cfmts[i].code == code)\r\nbreak;\r\nif (i == priv->num_formats)\r\nreturn -EINVAL;\r\npriv->frame = *rect;\r\nmt9t112_frame_check(&priv->frame.width, &priv->frame.height,\r\n&priv->frame.left, &priv->frame.top);\r\npriv->format = mt9t112_cfmts + i;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = MAX_WIDTH;\r\nsel->r.height = MAX_HEIGHT;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = VGA_WIDTH;\r\nsel->r.height = VGA_HEIGHT;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r = priv->frame;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mt9t112_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nconst struct v4l2_rect *rect = &sel->r;\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||\r\nsel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nreturn mt9t112_set_params(priv, rect, priv->format->code);\r\n}\r\nstatic int mt9t112_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->width = priv->frame.width;\r\nmf->height = priv->frame.height;\r\nmf->colorspace = priv->format->colorspace;\r\nmf->code = priv->format->code;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nstruct v4l2_rect rect = {\r\n.width = mf->width,\r\n.height = mf->height,\r\n.left = priv->frame.left,\r\n.top = priv->frame.top,\r\n};\r\nint ret;\r\nret = mt9t112_set_params(priv, &rect, mf->code);\r\nif (!ret)\r\nmf->colorspace = priv->format->colorspace;\r\nreturn ret;\r\n}\r\nstatic int mt9t112_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nunsigned int top, left;\r\nint i;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nfor (i = 0; i < priv->num_formats; i++)\r\nif (mt9t112_cfmts[i].code == mf->code)\r\nbreak;\r\nif (i == priv->num_formats) {\r\nmf->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\n} else {\r\nmf->colorspace = mt9t112_cfmts[i].colorspace;\r\n}\r\nmt9t112_frame_check(&mf->width, &mf->height, &left, &top);\r\nmf->field = V4L2_FIELD_NONE;\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn mt9t112_s_fmt(sd, mf);\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nif (code->pad || code->index >= priv->num_formats)\r\nreturn -EINVAL;\r\ncode->code = mt9t112_cfmts[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int mt9t112_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nif (soc_camera_apply_board_flags(ssdd, cfg) & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\npriv->flags |= PCLK_RISING;\r\nreturn 0;\r\n}\r\nstatic int mt9t112_camera_probe(struct i2c_client *client)\r\n{\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nconst char *devname;\r\nint chipid;\r\nint ret;\r\nret = mt9t112_s_power(&priv->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nmt9t112_reg_read(chipid, client, 0x0000);\r\nswitch (chipid) {\r\ncase 0x2680:\r\ndevname = "mt9t111";\r\npriv->num_formats = 1;\r\nbreak;\r\ncase 0x2682:\r\ndevname = "mt9t112";\r\npriv->num_formats = ARRAY_SIZE(mt9t112_cfmts);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Product ID error %04x\n", chipid);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\ndev_info(&client->dev, "%s chip ID %04x\n", devname, chipid);\r\ndone:\r\nmt9t112_s_power(&priv->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9t112_priv *priv;\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct v4l2_rect rect = {\r\n.width = VGA_WIDTH,\r\n.height = VGA_HEIGHT,\r\n.left = (MAX_WIDTH - VGA_WIDTH) / 2,\r\n.top = (MAX_HEIGHT - VGA_HEIGHT) / 2,\r\n};\r\nint ret;\r\nif (!ssdd || !ssdd->drv_priv) {\r\ndev_err(&client->dev, "mt9t112: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->info = ssdd->drv_priv;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &mt9t112_subdev_ops);\r\npriv->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\nret = mt9t112_camera_probe(client);\r\nif (!ret)\r\nmt9t112_set_params(priv, &rect, MEDIA_BUS_FMT_UYVY8_2X8);\r\nelse\r\nv4l2_clk_put(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int mt9t112_remove(struct i2c_client *client)\r\n{\r\nstruct mt9t112_priv *priv = to_mt9t112(client);\r\nv4l2_clk_put(priv->clk);\r\nreturn 0;\r\n}
