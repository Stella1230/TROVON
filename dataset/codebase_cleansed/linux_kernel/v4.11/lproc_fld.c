static int\r\nfld_debugfs_targets_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct lu_client_fld *fld = (struct lu_client_fld *)m->private;\r\nstruct lu_fld_target *target;\r\nspin_lock(&fld->lcf_lock);\r\nlist_for_each_entry(target, &fld->lcf_targets, ft_chain)\r\nseq_printf(m, "%s\n", fld_target_name(target));\r\nspin_unlock(&fld->lcf_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nfld_debugfs_hash_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct lu_client_fld *fld = (struct lu_client_fld *)m->private;\r\nspin_lock(&fld->lcf_lock);\r\nseq_printf(m, "%s\n", fld->lcf_hash->fh_name);\r\nspin_unlock(&fld->lcf_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nfld_debugfs_hash_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct lu_client_fld *fld;\r\nstruct lu_fld_hash *hash = NULL;\r\nchar fh_name[8];\r\nint i;\r\nif (count > sizeof(fh_name))\r\nreturn -ENAMETOOLONG;\r\nif (copy_from_user(fh_name, buffer, count) != 0)\r\nreturn -EFAULT;\r\nfld = ((struct seq_file *)file->private_data)->private;\r\nfor (i = 0; fld_hash[i].fh_name; i++) {\r\nif (count != strlen(fld_hash[i].fh_name))\r\ncontinue;\r\nif (!strncmp(fld_hash[i].fh_name, fh_name, count)) {\r\nhash = &fld_hash[i];\r\nbreak;\r\n}\r\n}\r\nif (hash) {\r\nspin_lock(&fld->lcf_lock);\r\nfld->lcf_hash = hash;\r\nspin_unlock(&fld->lcf_lock);\r\nCDEBUG(D_INFO, "%s: Changed hash to \"%s\"\n",\r\nfld->lcf_name, hash->fh_name);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nfld_debugfs_cache_flush_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct lu_client_fld *fld = file->private_data;\r\nfld_cache_flush(fld->lcf_cache);\r\nCDEBUG(D_INFO, "%s: Lookup cache is flushed\n", fld->lcf_name);\r\nreturn count;\r\n}\r\nstatic int\r\nfld_debugfs_cache_flush_release(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}
