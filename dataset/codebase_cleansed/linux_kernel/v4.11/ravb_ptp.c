static int ravb_ptp_tcr_request(struct ravb_private *priv, u32 request)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nint error;\r\nerror = ravb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\r\nif (error)\r\nreturn error;\r\nravb_modify(ndev, GCCR, request, request);\r\nreturn ravb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\r\n}\r\nstatic int ravb_ptp_time_read(struct ravb_private *priv, struct timespec64 *ts)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nint error;\r\nerror = ravb_ptp_tcr_request(priv, GCCR_TCR_CAPTURE);\r\nif (error)\r\nreturn error;\r\nts->tv_nsec = ravb_read(ndev, GCT0);\r\nts->tv_sec = ravb_read(ndev, GCT1) |\r\n((s64)ravb_read(ndev, GCT2) << 32);\r\nreturn 0;\r\n}\r\nstatic int ravb_ptp_time_write(struct ravb_private *priv,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nint error;\r\nu32 gccr;\r\nerror = ravb_ptp_tcr_request(priv, GCCR_TCR_RESET);\r\nif (error)\r\nreturn error;\r\ngccr = ravb_read(ndev, GCCR);\r\nif (gccr & GCCR_LTO)\r\nreturn -EBUSY;\r\nravb_write(ndev, ts->tv_nsec, GTO0);\r\nravb_write(ndev, ts->tv_sec, GTO1);\r\nravb_write(ndev, (ts->tv_sec >> 32) & 0xffff, GTO2);\r\nravb_write(ndev, gccr | GCCR_LTO, GCCR);\r\nreturn 0;\r\n}\r\nstatic int ravb_ptp_update_compare(struct ravb_private *priv, u32 ns)\r\n{\r\nstruct net_device *ndev = priv->ndev;\r\nu32 gti_ns_plus_1 = (priv->ptp.current_addend >> 20) + 1;\r\nu32 gccr;\r\nif (ns < gti_ns_plus_1)\r\nns = gti_ns_plus_1;\r\nelse if (ns > 0 - gti_ns_plus_1)\r\nns = 0 - gti_ns_plus_1;\r\ngccr = ravb_read(ndev, GCCR);\r\nif (gccr & GCCR_LPTC)\r\nreturn -EBUSY;\r\nravb_write(ndev, ns, GPTC);\r\nravb_write(ndev, gccr | GCCR_LPTC, GCCR);\r\nreturn 0;\r\n}\r\nstatic int ravb_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nstruct net_device *ndev = priv->ndev;\r\nunsigned long flags;\r\nu32 diff, addend;\r\nbool neg_adj = false;\r\nu32 gccr;\r\nif (ppb < 0) {\r\nneg_adj = true;\r\nppb = -ppb;\r\n}\r\naddend = priv->ptp.default_addend;\r\ndiff = div_u64((u64)addend * ppb, NSEC_PER_SEC);\r\naddend = neg_adj ? addend - diff : addend + diff;\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->ptp.current_addend = addend;\r\ngccr = ravb_read(ndev, GCCR);\r\nif (gccr & GCCR_LTI) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nravb_write(ndev, addend & GTI_TIV, GTI);\r\nravb_write(ndev, gccr | GCCR_LTI, GCCR);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ravb_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nstruct timespec64 ts;\r\nunsigned long flags;\r\nint error;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nerror = ravb_ptp_time_read(priv, &ts);\r\nif (!error) {\r\nu64 now = ktime_to_ns(timespec64_to_ktime(ts));\r\nts = ns_to_timespec64(now + delta);\r\nerror = ravb_ptp_time_write(priv, &ts);\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn error;\r\n}\r\nstatic int ravb_ptp_gettime64(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nunsigned long flags;\r\nint error;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nerror = ravb_ptp_time_read(priv, ts);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn error;\r\n}\r\nstatic int ravb_ptp_settime64(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nunsigned long flags;\r\nint error;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nerror = ravb_ptp_time_write(priv, ts);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn error;\r\n}\r\nstatic int ravb_ptp_extts(struct ptp_clock_info *ptp,\r\nstruct ptp_extts_request *req, int on)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nstruct net_device *ndev = priv->ndev;\r\nunsigned long flags;\r\nif (req->index)\r\nreturn -EINVAL;\r\nif (priv->ptp.extts[req->index] == on)\r\nreturn 0;\r\npriv->ptp.extts[req->index] = on;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->chip_id == RCAR_GEN2)\r\nravb_modify(ndev, GIC, GIC_PTCE, on ? GIC_PTCE : 0);\r\nelse if (on)\r\nravb_write(ndev, GIE_PTCS, GIE);\r\nelse\r\nravb_write(ndev, GID_PTCD, GID);\r\nmmiowb();\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ravb_ptp_perout(struct ptp_clock_info *ptp,\r\nstruct ptp_perout_request *req, int on)\r\n{\r\nstruct ravb_private *priv = container_of(ptp, struct ravb_private,\r\nptp.info);\r\nstruct net_device *ndev = priv->ndev;\r\nstruct ravb_ptp_perout *perout;\r\nunsigned long flags;\r\nint error = 0;\r\nif (req->index)\r\nreturn -EINVAL;\r\nif (on) {\r\nu64 start_ns;\r\nu64 period_ns;\r\nstart_ns = req->start.sec * NSEC_PER_SEC + req->start.nsec;\r\nperiod_ns = req->period.sec * NSEC_PER_SEC + req->period.nsec;\r\nif (start_ns > U32_MAX) {\r\nnetdev_warn(ndev,\r\n"ptp: start value (nsec) is over limit. Maximum size of start is only 32 bits\n");\r\nreturn -ERANGE;\r\n}\r\nif (period_ns > U32_MAX) {\r\nnetdev_warn(ndev,\r\n"ptp: period value (nsec) is over limit. Maximum size of period is only 32 bits\n");\r\nreturn -ERANGE;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nperout = &priv->ptp.perout[req->index];\r\nperout->target = (u32)start_ns;\r\nperout->period = (u32)period_ns;\r\nerror = ravb_ptp_update_compare(priv, (u32)start_ns);\r\nif (!error) {\r\nif (priv->chip_id == RCAR_GEN2)\r\nravb_modify(ndev, GIC, GIC_PTME, GIC_PTME);\r\nelse\r\nravb_write(ndev, GIE_PTMS0, GIE);\r\n}\r\n} else {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nperout = &priv->ptp.perout[req->index];\r\nperout->period = 0;\r\nif (priv->chip_id == RCAR_GEN2)\r\nravb_modify(ndev, GIC, GIC_PTME, 0);\r\nelse\r\nravb_write(ndev, GID_PTMD0, GID);\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn error;\r\n}\r\nstatic int ravb_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *req, int on)\r\n{\r\nswitch (req->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nreturn ravb_ptp_extts(ptp, &req->extts, on);\r\ncase PTP_CLK_REQ_PEROUT:\r\nreturn ravb_ptp_perout(ptp, &req->perout, on);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nvoid ravb_ptp_interrupt(struct net_device *ndev)\r\n{\r\nstruct ravb_private *priv = netdev_priv(ndev);\r\nu32 gis = ravb_read(ndev, GIS);\r\ngis &= ravb_read(ndev, GIC);\r\nif (gis & GIS_PTCF) {\r\nstruct ptp_clock_event event;\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 0;\r\nevent.timestamp = ravb_read(ndev, GCPT);\r\nptp_clock_event(priv->ptp.clock, &event);\r\n}\r\nif (gis & GIS_PTMF) {\r\nstruct ravb_ptp_perout *perout = priv->ptp.perout;\r\nif (perout->period) {\r\nperout->target += perout->period;\r\nravb_ptp_update_compare(priv, perout->target);\r\n}\r\n}\r\nravb_write(ndev, ~gis, GIS);\r\n}\r\nvoid ravb_ptp_init(struct net_device *ndev, struct platform_device *pdev)\r\n{\r\nstruct ravb_private *priv = netdev_priv(ndev);\r\nunsigned long flags;\r\npriv->ptp.info = ravb_ptp_info;\r\npriv->ptp.default_addend = ravb_read(ndev, GTI);\r\npriv->ptp.current_addend = priv->ptp.default_addend;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nravb_wait(ndev, GCCR, GCCR_TCR, GCCR_TCR_NOREQ);\r\nravb_modify(ndev, GCCR, GCCR_TCSS, GCCR_TCSS_ADJGPTP);\r\nmmiowb();\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\npriv->ptp.clock = ptp_clock_register(&priv->ptp.info, &pdev->dev);\r\n}\r\nvoid ravb_ptp_stop(struct net_device *ndev)\r\n{\r\nstruct ravb_private *priv = netdev_priv(ndev);\r\nravb_write(ndev, 0, GIC);\r\nravb_write(ndev, 0, GIS);\r\nptp_clock_unregister(priv->ptp.clock);\r\n}
