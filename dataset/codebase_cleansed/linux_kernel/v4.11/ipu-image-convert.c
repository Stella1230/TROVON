static const struct ipu_image_pixfmt *get_format(u32 fourcc)\r\n{\r\nconst struct ipu_image_pixfmt *ret = NULL;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(image_convert_formats); i++) {\r\nif (image_convert_formats[i].fourcc == fourcc) {\r\nret = &image_convert_formats[i];\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void dump_format(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *ic_image)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\ndev_dbg(priv->ipu->dev,\r\n"task %u: ctx %p: %s format: %dx%d (%dx%d tiles of size %dx%d), %c%c%c%c\n",\r\nchan->ic_task, ctx,\r\nic_image->type == IMAGE_CONVERT_OUT ? "Output" : "Input",\r\nic_image->base.pix.width, ic_image->base.pix.height,\r\nic_image->num_cols, ic_image->num_rows,\r\nic_image->tile[0].width, ic_image->tile[0].height,\r\nic_image->fmt->fourcc & 0xff,\r\n(ic_image->fmt->fourcc >> 8) & 0xff,\r\n(ic_image->fmt->fourcc >> 16) & 0xff,\r\n(ic_image->fmt->fourcc >> 24) & 0xff);\r\n}\r\nint ipu_image_convert_enum_format(int index, u32 *fourcc)\r\n{\r\nconst struct ipu_image_pixfmt *fmt;\r\nif (index >= (int)ARRAY_SIZE(image_convert_formats))\r\nreturn -EINVAL;\r\nfmt = &image_convert_formats[index];\r\n*fourcc = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic void free_dma_buf(struct ipu_image_convert_priv *priv,\r\nstruct ipu_image_convert_dma_buf *buf)\r\n{\r\nif (buf->virt)\r\ndma_free_coherent(priv->ipu->dev,\r\nbuf->len, buf->virt, buf->phys);\r\nbuf->virt = NULL;\r\nbuf->phys = 0;\r\n}\r\nstatic int alloc_dma_buf(struct ipu_image_convert_priv *priv,\r\nstruct ipu_image_convert_dma_buf *buf,\r\nint size)\r\n{\r\nbuf->len = PAGE_ALIGN(size);\r\nbuf->virt = dma_alloc_coherent(priv->ipu->dev, buf->len, &buf->phys,\r\nGFP_DMA | GFP_KERNEL);\r\nif (!buf->virt) {\r\ndev_err(priv->ipu->dev, "failed to alloc dma buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int num_stripes(int dim)\r\n{\r\nif (dim <= 1024)\r\nreturn 1;\r\nelse if (dim <= 2048)\r\nreturn 2;\r\nelse\r\nreturn 4;\r\n}\r\nstatic void calc_tile_dimensions(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *image)\r\n{\r\nint i;\r\nfor (i = 0; i < ctx->num_tiles; i++) {\r\nstruct ipu_image_tile *tile = &image->tile[i];\r\ntile->height = image->base.pix.height / image->num_rows;\r\ntile->width = image->base.pix.width / image->num_cols;\r\ntile->size = ((tile->height * image->fmt->bpp) >> 3) *\r\ntile->width;\r\nif (image->fmt->planar) {\r\ntile->stride = tile->width;\r\ntile->rot_stride = tile->height;\r\n} else {\r\ntile->stride =\r\n(image->fmt->bpp * tile->width) >> 3;\r\ntile->rot_stride =\r\n(image->fmt->bpp * tile->height) >> 3;\r\n}\r\n}\r\n}\r\nstatic int transform_tile_index(struct ipu_image_convert_ctx *ctx,\r\nint src_row, int src_col)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_image *s_image = &ctx->in;\r\nstruct ipu_image_convert_image *d_image = &ctx->out;\r\nint dst_row, dst_col;\r\nif (ctx->rot_mode == IPU_ROTATE_NONE)\r\nreturn src_row * s_image->num_cols + src_col;\r\nsrc_row = src_row * 2 - (s_image->num_rows - 1);\r\nsrc_col = src_col * 2 - (s_image->num_cols - 1);\r\nif (ctx->rot_mode & IPU_ROT_BIT_90) {\r\ndst_col = -src_row;\r\ndst_row = src_col;\r\n} else {\r\ndst_col = src_col;\r\ndst_row = src_row;\r\n}\r\nif (ctx->rot_mode & IPU_ROT_BIT_HFLIP)\r\ndst_col = -dst_col;\r\nif (ctx->rot_mode & IPU_ROT_BIT_VFLIP)\r\ndst_row = -dst_row;\r\ndev_dbg(priv->ipu->dev, "task %u: ctx %p: [%d,%d] --> [%d,%d]\n",\r\nchan->ic_task, ctx, src_col, src_row, dst_col, dst_row);\r\ndst_row += d_image->num_rows - 1;\r\ndst_col += d_image->num_cols - 1;\r\ndst_row /= 2;\r\ndst_col /= 2;\r\nreturn dst_row * d_image->num_cols + dst_col;\r\n}\r\nstatic void calc_out_tile_map(struct ipu_image_convert_ctx *ctx)\r\n{\r\nstruct ipu_image_convert_image *s_image = &ctx->in;\r\nunsigned int row, col, tile = 0;\r\nfor (row = 0; row < s_image->num_rows; row++) {\r\nfor (col = 0; col < s_image->num_cols; col++) {\r\nctx->out_tile_map[tile] =\r\ntransform_tile_index(ctx, row, col);\r\ntile++;\r\n}\r\n}\r\n}\r\nstatic void calc_tile_offsets_planar(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *image)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nconst struct ipu_image_pixfmt *fmt = image->fmt;\r\nunsigned int row, col, tile = 0;\r\nu32 H, w, h, y_stride, uv_stride;\r\nu32 uv_row_off, uv_col_off, uv_off, u_off, v_off, tmp;\r\nu32 y_row_off, y_col_off, y_off;\r\nu32 y_size, uv_size;\r\nH = image->base.pix.height;\r\ny_stride = image->stride;\r\nuv_stride = y_stride / fmt->uv_width_dec;\r\nif (fmt->uv_packed)\r\nuv_stride *= 2;\r\ny_size = H * y_stride;\r\nuv_size = y_size / (fmt->uv_width_dec * fmt->uv_height_dec);\r\nfor (row = 0; row < image->num_rows; row++) {\r\nw = image->tile[tile].width;\r\nh = image->tile[tile].height;\r\ny_row_off = row * h * y_stride;\r\nuv_row_off = (row * h * uv_stride) / fmt->uv_height_dec;\r\nfor (col = 0; col < image->num_cols; col++) {\r\ny_col_off = col * w;\r\nuv_col_off = y_col_off / fmt->uv_width_dec;\r\nif (fmt->uv_packed)\r\nuv_col_off *= 2;\r\ny_off = y_row_off + y_col_off;\r\nuv_off = uv_row_off + uv_col_off;\r\nu_off = y_size - y_off + uv_off;\r\nv_off = (fmt->uv_packed) ? 0 : u_off + uv_size;\r\nif (fmt->uv_swapped) {\r\ntmp = u_off;\r\nu_off = v_off;\r\nv_off = tmp;\r\n}\r\nimage->tile[tile].offset = y_off;\r\nimage->tile[tile].u_off = u_off;\r\nimage->tile[tile++].v_off = v_off;\r\ndev_dbg(priv->ipu->dev,\r\n"task %u: ctx %p: %s@[%d,%d]: y_off %08x, u_off %08x, v_off %08x\n",\r\nchan->ic_task, ctx,\r\nimage->type == IMAGE_CONVERT_IN ?\r\n"Input" : "Output", row, col,\r\ny_off, u_off, v_off);\r\n}\r\n}\r\n}\r\nstatic void calc_tile_offsets_packed(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *image)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nconst struct ipu_image_pixfmt *fmt = image->fmt;\r\nunsigned int row, col, tile = 0;\r\nu32 w, h, bpp, stride;\r\nu32 row_off, col_off;\r\nstride = image->stride;\r\nbpp = fmt->bpp;\r\nfor (row = 0; row < image->num_rows; row++) {\r\nw = image->tile[tile].width;\r\nh = image->tile[tile].height;\r\nrow_off = row * h * stride;\r\nfor (col = 0; col < image->num_cols; col++) {\r\ncol_off = (col * w * bpp) >> 3;\r\nimage->tile[tile].offset = row_off + col_off;\r\nimage->tile[tile].u_off = 0;\r\nimage->tile[tile++].v_off = 0;\r\ndev_dbg(priv->ipu->dev,\r\n"task %u: ctx %p: %s@[%d,%d]: phys %08x\n",\r\nchan->ic_task, ctx,\r\nimage->type == IMAGE_CONVERT_IN ?\r\n"Input" : "Output", row, col,\r\nrow_off + col_off);\r\n}\r\n}\r\n}\r\nstatic void calc_tile_offsets(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *image)\r\n{\r\nif (image->fmt->planar)\r\ncalc_tile_offsets_planar(ctx, image);\r\nelse\r\ncalc_tile_offsets_packed(ctx, image);\r\n}\r\nstatic int get_run_count(struct ipu_image_convert_ctx *ctx,\r\nstruct list_head *q)\r\n{\r\nstruct ipu_image_convert_run *run;\r\nint count = 0;\r\nlockdep_assert_held(&ctx->chan->irqlock);\r\nlist_for_each_entry(run, q, list) {\r\nif (run->ctx == ctx)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void convert_stop(struct ipu_image_convert_run *run)\r\n{\r\nstruct ipu_image_convert_ctx *ctx = run->ctx;\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\ndev_dbg(priv->ipu->dev, "%s: task %u: stopping ctx %p run %p\n",\r\n__func__, chan->ic_task, ctx, run);\r\nipu_ic_task_disable(chan->ic);\r\nipu_idmac_disable_channel(chan->in_chan);\r\nipu_idmac_disable_channel(chan->out_chan);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\nipu_idmac_disable_channel(chan->rotation_in_chan);\r\nipu_idmac_disable_channel(chan->rotation_out_chan);\r\nipu_idmac_unlink(chan->out_chan, chan->rotation_in_chan);\r\n}\r\nipu_ic_disable(chan->ic);\r\n}\r\nstatic void init_idmac_channel(struct ipu_image_convert_ctx *ctx,\r\nstruct ipuv3_channel *channel,\r\nstruct ipu_image_convert_image *image,\r\nenum ipu_rotate_mode rot_mode,\r\nbool rot_swap_width_height)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nunsigned int burst_size;\r\nu32 width, height, stride;\r\ndma_addr_t addr0, addr1 = 0;\r\nstruct ipu_image tile_image;\r\nunsigned int tile_idx[2];\r\nif (image->type == IMAGE_CONVERT_OUT) {\r\ntile_idx[0] = ctx->out_tile_map[0];\r\ntile_idx[1] = ctx->out_tile_map[1];\r\n} else {\r\ntile_idx[0] = 0;\r\ntile_idx[1] = 1;\r\n}\r\nif (rot_swap_width_height) {\r\nwidth = image->tile[0].height;\r\nheight = image->tile[0].width;\r\nstride = image->tile[0].rot_stride;\r\naddr0 = ctx->rot_intermediate[0].phys;\r\nif (ctx->double_buffering)\r\naddr1 = ctx->rot_intermediate[1].phys;\r\n} else {\r\nwidth = image->tile[0].width;\r\nheight = image->tile[0].height;\r\nstride = image->stride;\r\naddr0 = image->base.phys0 +\r\nimage->tile[tile_idx[0]].offset;\r\nif (ctx->double_buffering)\r\naddr1 = image->base.phys0 +\r\nimage->tile[tile_idx[1]].offset;\r\n}\r\nipu_cpmem_zero(channel);\r\nmemset(&tile_image, 0, sizeof(tile_image));\r\ntile_image.pix.width = tile_image.rect.width = width;\r\ntile_image.pix.height = tile_image.rect.height = height;\r\ntile_image.pix.bytesperline = stride;\r\ntile_image.pix.pixelformat = image->fmt->fourcc;\r\ntile_image.phys0 = addr0;\r\ntile_image.phys1 = addr1;\r\nipu_cpmem_set_image(channel, &tile_image);\r\nif (image->fmt->planar && !rot_swap_width_height)\r\nipu_cpmem_set_uv_offset(channel,\r\nimage->tile[tile_idx[0]].u_off,\r\nimage->tile[tile_idx[0]].v_off);\r\nif (rot_mode)\r\nipu_cpmem_set_rotation(channel, rot_mode);\r\nif (channel == chan->rotation_in_chan ||\r\nchannel == chan->rotation_out_chan) {\r\nburst_size = 8;\r\nipu_cpmem_set_block_mode(channel);\r\n} else\r\nburst_size = (width % 16) ? 8 : 16;\r\nipu_cpmem_set_burstsize(channel, burst_size);\r\nipu_ic_task_idma_init(chan->ic, channel, width, height,\r\nburst_size, rot_mode);\r\nipu_cpmem_set_axi_id(channel, 1);\r\nipu_idmac_set_double_buffer(channel, ctx->double_buffering);\r\n}\r\nstatic int convert_start(struct ipu_image_convert_run *run)\r\n{\r\nstruct ipu_image_convert_ctx *ctx = run->ctx;\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_image *s_image = &ctx->in;\r\nstruct ipu_image_convert_image *d_image = &ctx->out;\r\nenum ipu_color_space src_cs, dest_cs;\r\nunsigned int dest_width, dest_height;\r\nint ret;\r\ndev_dbg(priv->ipu->dev, "%s: task %u: starting ctx %p run %p\n",\r\n__func__, chan->ic_task, ctx, run);\r\nsrc_cs = ipu_pixelformat_to_colorspace(s_image->fmt->fourcc);\r\ndest_cs = ipu_pixelformat_to_colorspace(d_image->fmt->fourcc);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\ndest_width = d_image->tile[0].height;\r\ndest_height = d_image->tile[0].width;\r\n} else {\r\ndest_width = d_image->tile[0].width;\r\ndest_height = d_image->tile[0].height;\r\n}\r\nret = ipu_ic_task_init(chan->ic,\r\ns_image->tile[0].width,\r\ns_image->tile[0].height,\r\ndest_width,\r\ndest_height,\r\nsrc_cs, dest_cs);\r\nif (ret) {\r\ndev_err(priv->ipu->dev, "ipu_ic_task_init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\ninit_idmac_channel(ctx, chan->in_chan, s_image,\r\nIPU_ROTATE_NONE, false);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\ninit_idmac_channel(ctx, chan->out_chan, d_image,\r\nIPU_ROTATE_NONE, true);\r\ninit_idmac_channel(ctx, chan->rotation_in_chan, d_image,\r\nctx->rot_mode, true);\r\ninit_idmac_channel(ctx, chan->rotation_out_chan, d_image,\r\nIPU_ROTATE_NONE, false);\r\nipu_idmac_link(chan->out_chan, chan->rotation_in_chan);\r\n} else {\r\ninit_idmac_channel(ctx, chan->out_chan, d_image,\r\nctx->rot_mode, false);\r\n}\r\nipu_ic_enable(chan->ic);\r\nipu_idmac_select_buffer(chan->in_chan, 0);\r\nipu_idmac_select_buffer(chan->out_chan, 0);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode))\r\nipu_idmac_select_buffer(chan->rotation_out_chan, 0);\r\nif (ctx->double_buffering) {\r\nipu_idmac_select_buffer(chan->in_chan, 1);\r\nipu_idmac_select_buffer(chan->out_chan, 1);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode))\r\nipu_idmac_select_buffer(chan->rotation_out_chan, 1);\r\n}\r\nipu_idmac_enable_channel(chan->in_chan);\r\nipu_idmac_enable_channel(chan->out_chan);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\nipu_idmac_enable_channel(chan->rotation_in_chan);\r\nipu_idmac_enable_channel(chan->rotation_out_chan);\r\n}\r\nipu_ic_task_enable(chan->ic);\r\nipu_cpmem_dump(chan->in_chan);\r\nipu_cpmem_dump(chan->out_chan);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\nipu_cpmem_dump(chan->rotation_in_chan);\r\nipu_cpmem_dump(chan->rotation_out_chan);\r\n}\r\nipu_dump(priv->ipu);\r\nreturn 0;\r\n}\r\nstatic int do_run(struct ipu_image_convert_run *run)\r\n{\r\nstruct ipu_image_convert_ctx *ctx = run->ctx;\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nlockdep_assert_held(&chan->irqlock);\r\nctx->in.base.phys0 = run->in_phys;\r\nctx->out.base.phys0 = run->out_phys;\r\nctx->cur_buf_num = 0;\r\nctx->next_tile = 1;\r\nlist_del(&run->list);\r\nchan->current_run = run;\r\nreturn convert_start(run);\r\n}\r\nstatic void run_next(struct ipu_image_convert_chan *chan)\r\n{\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_run *run, *tmp;\r\nint ret;\r\nlockdep_assert_held(&chan->irqlock);\r\nlist_for_each_entry_safe(run, tmp, &chan->pending_q, list) {\r\nif (run->ctx->aborting) {\r\ndev_dbg(priv->ipu->dev,\r\n"%s: task %u: skipping aborting ctx %p run %p\n",\r\n__func__, chan->ic_task, run->ctx, run);\r\ncontinue;\r\n}\r\nret = do_run(run);\r\nif (!ret)\r\nbreak;\r\nrun->status = ret;\r\nlist_add_tail(&run->list, &chan->done_q);\r\nchan->current_run = NULL;\r\n}\r\n}\r\nstatic void empty_done_q(struct ipu_image_convert_chan *chan)\r\n{\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_run *run;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nwhile (!list_empty(&chan->done_q)) {\r\nrun = list_entry(chan->done_q.next,\r\nstruct ipu_image_convert_run,\r\nlist);\r\nlist_del(&run->list);\r\ndev_dbg(priv->ipu->dev,\r\n"%s: task %u: completing ctx %p run %p with %d\n",\r\n__func__, chan->ic_task, run->ctx, run, run->status);\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nrun->ctx->complete(run, run->ctx->complete_context);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\n}\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\n}\r\nstatic irqreturn_t do_bh(int irq, void *dev_id)\r\n{\r\nstruct ipu_image_convert_chan *chan = dev_id;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_ctx *ctx;\r\nunsigned long flags;\r\ndev_dbg(priv->ipu->dev, "%s: task %u: enter\n", __func__,\r\nchan->ic_task);\r\nempty_done_q(chan);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nlist_for_each_entry(ctx, &chan->ctx_list, list) {\r\nif (ctx->aborting) {\r\ndev_dbg(priv->ipu->dev,\r\n"%s: task %u: signaling abort for ctx %p\n",\r\n__func__, chan->ic_task, ctx);\r\ncomplete(&ctx->aborted);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\ndev_dbg(priv->ipu->dev, "%s: task %u: exit\n", __func__,\r\nchan->ic_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t do_irq(struct ipu_image_convert_run *run)\r\n{\r\nstruct ipu_image_convert_ctx *ctx = run->ctx;\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_tile *src_tile, *dst_tile;\r\nstruct ipu_image_convert_image *s_image = &ctx->in;\r\nstruct ipu_image_convert_image *d_image = &ctx->out;\r\nstruct ipuv3_channel *outch;\r\nunsigned int dst_idx;\r\nlockdep_assert_held(&chan->irqlock);\r\noutch = ipu_rot_mode_is_irt(ctx->rot_mode) ?\r\nchan->rotation_out_chan : chan->out_chan;\r\nif (ctx->aborting && !ctx->double_buffering) {\r\nconvert_stop(run);\r\nrun->status = -EIO;\r\ngoto done;\r\n}\r\nif (ctx->next_tile == ctx->num_tiles) {\r\nconvert_stop(run);\r\nrun->status = 0;\r\ngoto done;\r\n}\r\nif (!ctx->double_buffering) {\r\nsrc_tile = &s_image->tile[ctx->next_tile];\r\ndst_idx = ctx->out_tile_map[ctx->next_tile];\r\ndst_tile = &d_image->tile[dst_idx];\r\nipu_cpmem_set_buffer(chan->in_chan, 0,\r\ns_image->base.phys0 + src_tile->offset);\r\nipu_cpmem_set_buffer(outch, 0,\r\nd_image->base.phys0 + dst_tile->offset);\r\nif (s_image->fmt->planar)\r\nipu_cpmem_set_uv_offset(chan->in_chan,\r\nsrc_tile->u_off,\r\nsrc_tile->v_off);\r\nif (d_image->fmt->planar)\r\nipu_cpmem_set_uv_offset(outch,\r\ndst_tile->u_off,\r\ndst_tile->v_off);\r\nipu_idmac_select_buffer(chan->in_chan, 0);\r\nipu_idmac_select_buffer(outch, 0);\r\n} else if (ctx->next_tile < ctx->num_tiles - 1) {\r\nsrc_tile = &s_image->tile[ctx->next_tile + 1];\r\ndst_idx = ctx->out_tile_map[ctx->next_tile + 1];\r\ndst_tile = &d_image->tile[dst_idx];\r\nipu_cpmem_set_buffer(chan->in_chan, ctx->cur_buf_num,\r\ns_image->base.phys0 + src_tile->offset);\r\nipu_cpmem_set_buffer(outch, ctx->cur_buf_num,\r\nd_image->base.phys0 + dst_tile->offset);\r\nipu_idmac_select_buffer(chan->in_chan, ctx->cur_buf_num);\r\nipu_idmac_select_buffer(outch, ctx->cur_buf_num);\r\nctx->cur_buf_num ^= 1;\r\n}\r\nctx->next_tile++;\r\nreturn IRQ_HANDLED;\r\ndone:\r\nlist_add_tail(&run->list, &chan->done_q);\r\nchan->current_run = NULL;\r\nrun_next(chan);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t norotate_irq(int irq, void *data)\r\n{\r\nstruct ipu_image_convert_chan *chan = data;\r\nstruct ipu_image_convert_ctx *ctx;\r\nstruct ipu_image_convert_run *run;\r\nunsigned long flags;\r\nirqreturn_t ret;\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nrun = chan->current_run;\r\nif (!run) {\r\nret = IRQ_NONE;\r\ngoto out;\r\n}\r\nctx = run->ctx;\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nret = do_irq(run);\r\nout:\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t rotate_irq(int irq, void *data)\r\n{\r\nstruct ipu_image_convert_chan *chan = data;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_ctx *ctx;\r\nstruct ipu_image_convert_run *run;\r\nunsigned long flags;\r\nirqreturn_t ret;\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nrun = chan->current_run;\r\nif (!run) {\r\nret = IRQ_NONE;\r\ngoto out;\r\n}\r\nctx = run->ctx;\r\nif (!ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\ndev_err(priv->ipu->dev, "Unexpected rotation interrupt\n");\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nret = do_irq(run);\r\nout:\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nreturn ret;\r\n}\r\nstatic void force_abort(struct ipu_image_convert_ctx *ctx)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_run *run;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nrun = chan->current_run;\r\nif (run && run->ctx == ctx) {\r\nconvert_stop(run);\r\nrun->status = -EIO;\r\nlist_add_tail(&run->list, &chan->done_q);\r\nchan->current_run = NULL;\r\nrun_next(chan);\r\n}\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nempty_done_q(chan);\r\n}\r\nstatic void release_ipu_resources(struct ipu_image_convert_chan *chan)\r\n{\r\nif (chan->out_eof_irq >= 0)\r\nfree_irq(chan->out_eof_irq, chan);\r\nif (chan->rot_out_eof_irq >= 0)\r\nfree_irq(chan->rot_out_eof_irq, chan);\r\nif (!IS_ERR_OR_NULL(chan->in_chan))\r\nipu_idmac_put(chan->in_chan);\r\nif (!IS_ERR_OR_NULL(chan->out_chan))\r\nipu_idmac_put(chan->out_chan);\r\nif (!IS_ERR_OR_NULL(chan->rotation_in_chan))\r\nipu_idmac_put(chan->rotation_in_chan);\r\nif (!IS_ERR_OR_NULL(chan->rotation_out_chan))\r\nipu_idmac_put(chan->rotation_out_chan);\r\nif (!IS_ERR_OR_NULL(chan->ic))\r\nipu_ic_put(chan->ic);\r\nchan->in_chan = chan->out_chan = chan->rotation_in_chan =\r\nchan->rotation_out_chan = NULL;\r\nchan->out_eof_irq = chan->rot_out_eof_irq = -1;\r\n}\r\nstatic int get_ipu_resources(struct ipu_image_convert_chan *chan)\r\n{\r\nconst struct ipu_image_convert_dma_chan *dma = chan->dma_ch;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nint ret;\r\nchan->ic = ipu_ic_get(priv->ipu, chan->ic_task);\r\nif (IS_ERR(chan->ic)) {\r\ndev_err(priv->ipu->dev, "could not acquire IC\n");\r\nret = PTR_ERR(chan->ic);\r\ngoto err;\r\n}\r\nchan->in_chan = ipu_idmac_get(priv->ipu, dma->in);\r\nchan->out_chan = ipu_idmac_get(priv->ipu, dma->out);\r\nif (IS_ERR(chan->in_chan) || IS_ERR(chan->out_chan)) {\r\ndev_err(priv->ipu->dev, "could not acquire idmac channels\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nchan->rotation_in_chan = ipu_idmac_get(priv->ipu, dma->rot_in);\r\nchan->rotation_out_chan = ipu_idmac_get(priv->ipu, dma->rot_out);\r\nif (IS_ERR(chan->rotation_in_chan) || IS_ERR(chan->rotation_out_chan)) {\r\ndev_err(priv->ipu->dev,\r\n"could not acquire idmac rotation channels\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nchan->out_eof_irq = ipu_idmac_channel_irq(priv->ipu,\r\nchan->out_chan,\r\nIPU_IRQ_EOF);\r\nret = request_threaded_irq(chan->out_eof_irq, norotate_irq, do_bh,\r\n0, "ipu-ic", chan);\r\nif (ret < 0) {\r\ndev_err(priv->ipu->dev, "could not acquire irq %d\n",\r\nchan->out_eof_irq);\r\nchan->out_eof_irq = -1;\r\ngoto err;\r\n}\r\nchan->rot_out_eof_irq = ipu_idmac_channel_irq(priv->ipu,\r\nchan->rotation_out_chan,\r\nIPU_IRQ_EOF);\r\nret = request_threaded_irq(chan->rot_out_eof_irq, rotate_irq, do_bh,\r\n0, "ipu-ic", chan);\r\nif (ret < 0) {\r\ndev_err(priv->ipu->dev, "could not acquire irq %d\n",\r\nchan->rot_out_eof_irq);\r\nchan->rot_out_eof_irq = -1;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nrelease_ipu_resources(chan);\r\nreturn ret;\r\n}\r\nstatic int fill_image(struct ipu_image_convert_ctx *ctx,\r\nstruct ipu_image_convert_image *ic_image,\r\nstruct ipu_image *image,\r\nenum ipu_image_convert_type type)\r\n{\r\nstruct ipu_image_convert_priv *priv = ctx->chan->priv;\r\nic_image->base = *image;\r\nic_image->type = type;\r\nic_image->fmt = get_format(image->pix.pixelformat);\r\nif (!ic_image->fmt) {\r\ndev_err(priv->ipu->dev, "pixelformat not supported for %s\n",\r\ntype == IMAGE_CONVERT_OUT ? "Output" : "Input");\r\nreturn -EINVAL;\r\n}\r\nif (ic_image->fmt->planar)\r\nic_image->stride = ic_image->base.pix.width;\r\nelse\r\nic_image->stride = ic_image->base.pix.bytesperline;\r\ncalc_tile_dimensions(ctx, ic_image);\r\ncalc_tile_offsets(ctx, ic_image);\r\nreturn 0;\r\n}\r\nstatic unsigned int clamp_align(unsigned int x, unsigned int min,\r\nunsigned int max, unsigned int align)\r\n{\r\nunsigned int mask = ~((1 << align) - 1);\r\nx = clamp(x, (min + ~mask) & mask, max & mask);\r\nif (align)\r\nx = (x + (1 << (align - 1))) & mask;\r\nreturn x;\r\n}\r\nstatic inline u32 tile_width_align(const struct ipu_image_pixfmt *fmt)\r\n{\r\nreturn fmt->planar ? 8 * fmt->uv_width_dec : 8;\r\n}\r\nstatic inline u32 tile_height_align(enum ipu_image_convert_type type,\r\nenum ipu_rotate_mode rot_mode)\r\n{\r\nreturn (type == IMAGE_CONVERT_OUT &&\r\nipu_rot_mode_is_irt(rot_mode)) ? 8 : 2;\r\n}\r\nvoid ipu_image_convert_adjust(struct ipu_image *in, struct ipu_image *out,\r\nenum ipu_rotate_mode rot_mode)\r\n{\r\nconst struct ipu_image_pixfmt *infmt, *outfmt;\r\nunsigned int num_in_rows, num_in_cols;\r\nunsigned int num_out_rows, num_out_cols;\r\nu32 w_align, h_align;\r\ninfmt = get_format(in->pix.pixelformat);\r\noutfmt = get_format(out->pix.pixelformat);\r\nif (!infmt) {\r\nin->pix.pixelformat = V4L2_PIX_FMT_RGB24;\r\ninfmt = get_format(V4L2_PIX_FMT_RGB24);\r\n}\r\nif (!outfmt) {\r\nout->pix.pixelformat = V4L2_PIX_FMT_RGB24;\r\noutfmt = get_format(V4L2_PIX_FMT_RGB24);\r\n}\r\nin->pix.field = out->pix.field = V4L2_FIELD_NONE;\r\nif (ipu_rot_mode_is_irt(rot_mode)) {\r\nout->pix.height = max_t(__u32, out->pix.height,\r\nin->pix.width / 4);\r\nout->pix.width = max_t(__u32, out->pix.width,\r\nin->pix.height / 4);\r\n} else {\r\nout->pix.width = max_t(__u32, out->pix.width,\r\nin->pix.width / 4);\r\nout->pix.height = max_t(__u32, out->pix.height,\r\nin->pix.height / 4);\r\n}\r\nnum_out_rows = num_stripes(out->pix.height);\r\nnum_out_cols = num_stripes(out->pix.width);\r\nif (ipu_rot_mode_is_irt(rot_mode)) {\r\nnum_in_rows = num_out_cols;\r\nnum_in_cols = num_out_rows;\r\n} else {\r\nnum_in_rows = num_out_rows;\r\nnum_in_cols = num_out_cols;\r\n}\r\nw_align = ilog2(tile_width_align(infmt) * num_in_cols);\r\nh_align = ilog2(tile_height_align(IMAGE_CONVERT_IN, rot_mode) *\r\nnum_in_rows);\r\nin->pix.width = clamp_align(in->pix.width, MIN_W, MAX_W, w_align);\r\nin->pix.height = clamp_align(in->pix.height, MIN_H, MAX_H, h_align);\r\nw_align = ilog2(tile_width_align(outfmt) * num_out_cols);\r\nh_align = ilog2(tile_height_align(IMAGE_CONVERT_OUT, rot_mode) *\r\nnum_out_rows);\r\nout->pix.width = clamp_align(out->pix.width, MIN_W, MAX_W, w_align);\r\nout->pix.height = clamp_align(out->pix.height, MIN_H, MAX_H, h_align);\r\nin->pix.bytesperline = (in->pix.width * infmt->bpp) >> 3;\r\nin->pix.sizeimage = in->pix.height * in->pix.bytesperline;\r\nout->pix.bytesperline = (out->pix.width * outfmt->bpp) >> 3;\r\nout->pix.sizeimage = out->pix.height * out->pix.bytesperline;\r\n}\r\nint ipu_image_convert_verify(struct ipu_image *in, struct ipu_image *out,\r\nenum ipu_rotate_mode rot_mode)\r\n{\r\nstruct ipu_image testin, testout;\r\ntestin = *in;\r\ntestout = *out;\r\nipu_image_convert_adjust(&testin, &testout, rot_mode);\r\nif (testin.pix.width != in->pix.width ||\r\ntestin.pix.height != in->pix.height ||\r\ntestout.pix.width != out->pix.width ||\r\ntestout.pix.height != out->pix.height)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstruct ipu_image_convert_ctx *\r\nipu_image_convert_prepare(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\r\nstruct ipu_image *in, struct ipu_image *out,\r\nenum ipu_rotate_mode rot_mode,\r\nipu_image_convert_cb_t complete,\r\nvoid *complete_context)\r\n{\r\nstruct ipu_image_convert_priv *priv = ipu->image_convert_priv;\r\nstruct ipu_image_convert_image *s_image, *d_image;\r\nstruct ipu_image_convert_chan *chan;\r\nstruct ipu_image_convert_ctx *ctx;\r\nunsigned long flags;\r\nbool get_res;\r\nint ret;\r\nif (!in || !out || !complete ||\r\n(ic_task != IC_TASK_VIEWFINDER &&\r\nic_task != IC_TASK_POST_PROCESSOR))\r\nreturn ERR_PTR(-EINVAL);\r\nret = ipu_image_convert_verify(in, out, rot_mode);\r\nif (ret) {\r\ndev_err(priv->ipu->dev, "%s: in/out formats invalid\n",\r\n__func__);\r\nreturn ERR_PTR(ret);\r\n}\r\nchan = &priv->chan[ic_task];\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev_dbg(priv->ipu->dev, "%s: task %u: ctx %p\n", __func__,\r\nchan->ic_task, ctx);\r\nctx->chan = chan;\r\ninit_completion(&ctx->aborted);\r\ns_image = &ctx->in;\r\nd_image = &ctx->out;\r\nd_image->num_rows = num_stripes(out->pix.height);\r\nd_image->num_cols = num_stripes(out->pix.width);\r\nif (ipu_rot_mode_is_irt(rot_mode)) {\r\ns_image->num_rows = d_image->num_cols;\r\ns_image->num_cols = d_image->num_rows;\r\n} else {\r\ns_image->num_rows = d_image->num_rows;\r\ns_image->num_cols = d_image->num_cols;\r\n}\r\nctx->num_tiles = d_image->num_cols * d_image->num_rows;\r\nctx->rot_mode = rot_mode;\r\nret = fill_image(ctx, s_image, in, IMAGE_CONVERT_IN);\r\nif (ret)\r\ngoto out_free;\r\nret = fill_image(ctx, d_image, out, IMAGE_CONVERT_OUT);\r\nif (ret)\r\ngoto out_free;\r\ncalc_out_tile_map(ctx);\r\ndump_format(ctx, s_image);\r\ndump_format(ctx, d_image);\r\nctx->complete = complete;\r\nctx->complete_context = complete_context;\r\nctx->double_buffering = (ctx->num_tiles > 1 &&\r\n!s_image->fmt->planar &&\r\n!d_image->fmt->planar);\r\nif (ipu_rot_mode_is_irt(ctx->rot_mode)) {\r\nret = alloc_dma_buf(priv, &ctx->rot_intermediate[0],\r\nd_image->tile[0].size);\r\nif (ret)\r\ngoto out_free;\r\nif (ctx->double_buffering) {\r\nret = alloc_dma_buf(priv,\r\n&ctx->rot_intermediate[1],\r\nd_image->tile[0].size);\r\nif (ret)\r\ngoto out_free_dmabuf0;\r\n}\r\n}\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nget_res = list_empty(&chan->ctx_list);\r\nlist_add_tail(&ctx->list, &chan->ctx_list);\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nif (get_res) {\r\nret = get_ipu_resources(chan);\r\nif (ret)\r\ngoto out_free_dmabuf1;\r\n}\r\nreturn ctx;\r\nout_free_dmabuf1:\r\nfree_dma_buf(priv, &ctx->rot_intermediate[1]);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nlist_del(&ctx->list);\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nout_free_dmabuf0:\r\nfree_dma_buf(priv, &ctx->rot_intermediate[0]);\r\nout_free:\r\nkfree(ctx);\r\nreturn ERR_PTR(ret);\r\n}\r\nint ipu_image_convert_queue(struct ipu_image_convert_run *run)\r\n{\r\nstruct ipu_image_convert_chan *chan;\r\nstruct ipu_image_convert_priv *priv;\r\nstruct ipu_image_convert_ctx *ctx;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!run || !run->ctx || !run->in_phys || !run->out_phys)\r\nreturn -EINVAL;\r\nctx = run->ctx;\r\nchan = ctx->chan;\r\npriv = chan->priv;\r\ndev_dbg(priv->ipu->dev, "%s: task %u: ctx %p run %p\n", __func__,\r\nchan->ic_task, ctx, run);\r\nINIT_LIST_HEAD(&run->list);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nif (ctx->aborting) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nlist_add_tail(&run->list, &chan->pending_q);\r\nif (!chan->current_run) {\r\nret = do_run(run);\r\nif (ret)\r\nchan->current_run = NULL;\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nreturn ret;\r\n}\r\nvoid ipu_image_convert_abort(struct ipu_image_convert_ctx *ctx)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nstruct ipu_image_convert_run *run, *active_run, *tmp;\r\nunsigned long flags;\r\nint run_count, ret;\r\nbool need_abort;\r\nreinit_completion(&ctx->aborted);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nlist_for_each_entry_safe(run, tmp, &chan->pending_q, list) {\r\nif (run->ctx != ctx)\r\ncontinue;\r\nrun->status = -EIO;\r\nlist_move_tail(&run->list, &chan->done_q);\r\n}\r\nrun_count = get_run_count(ctx, &chan->done_q);\r\nactive_run = (chan->current_run && chan->current_run->ctx == ctx) ?\r\nchan->current_run : NULL;\r\nneed_abort = (run_count || active_run);\r\nctx->aborting = need_abort;\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nif (!need_abort) {\r\ndev_dbg(priv->ipu->dev,\r\n"%s: task %u: no abort needed for ctx %p\n",\r\n__func__, chan->ic_task, ctx);\r\nreturn;\r\n}\r\ndev_dbg(priv->ipu->dev,\r\n"%s: task %u: wait for completion: %d runs, active run %p\n",\r\n__func__, chan->ic_task, run_count, active_run);\r\nret = wait_for_completion_timeout(&ctx->aborted,\r\nmsecs_to_jiffies(10000));\r\nif (ret == 0) {\r\ndev_warn(priv->ipu->dev, "%s: timeout\n", __func__);\r\nforce_abort(ctx);\r\n}\r\nctx->aborting = false;\r\n}\r\nvoid ipu_image_convert_unprepare(struct ipu_image_convert_ctx *ctx)\r\n{\r\nstruct ipu_image_convert_chan *chan = ctx->chan;\r\nstruct ipu_image_convert_priv *priv = chan->priv;\r\nunsigned long flags;\r\nbool put_res;\r\nipu_image_convert_abort(ctx);\r\ndev_dbg(priv->ipu->dev, "%s: task %u: removing ctx %p\n", __func__,\r\nchan->ic_task, ctx);\r\nspin_lock_irqsave(&chan->irqlock, flags);\r\nlist_del(&ctx->list);\r\nput_res = list_empty(&chan->ctx_list);\r\nspin_unlock_irqrestore(&chan->irqlock, flags);\r\nif (put_res)\r\nrelease_ipu_resources(chan);\r\nfree_dma_buf(priv, &ctx->rot_intermediate[1]);\r\nfree_dma_buf(priv, &ctx->rot_intermediate[0]);\r\nkfree(ctx);\r\n}\r\nstruct ipu_image_convert_run *\r\nipu_image_convert(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\r\nstruct ipu_image *in, struct ipu_image *out,\r\nenum ipu_rotate_mode rot_mode,\r\nipu_image_convert_cb_t complete,\r\nvoid *complete_context)\r\n{\r\nstruct ipu_image_convert_ctx *ctx;\r\nstruct ipu_image_convert_run *run;\r\nint ret;\r\nctx = ipu_image_convert_prepare(ipu, ic_task, in, out, rot_mode,\r\ncomplete, complete_context);\r\nif (IS_ERR(ctx))\r\nreturn ERR_CAST(ctx);\r\nrun = kzalloc(sizeof(*run), GFP_KERNEL);\r\nif (!run) {\r\nipu_image_convert_unprepare(ctx);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrun->ctx = ctx;\r\nrun->in_phys = in->phys0;\r\nrun->out_phys = out->phys0;\r\nret = ipu_image_convert_queue(run);\r\nif (ret) {\r\nipu_image_convert_unprepare(ctx);\r\nkfree(run);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn run;\r\n}\r\nstatic void image_convert_sync_complete(struct ipu_image_convert_run *run,\r\nvoid *data)\r\n{\r\nstruct completion *comp = data;\r\ncomplete(comp);\r\n}\r\nint ipu_image_convert_sync(struct ipu_soc *ipu, enum ipu_ic_task ic_task,\r\nstruct ipu_image *in, struct ipu_image *out,\r\nenum ipu_rotate_mode rot_mode)\r\n{\r\nstruct ipu_image_convert_run *run;\r\nstruct completion comp;\r\nint ret;\r\ninit_completion(&comp);\r\nrun = ipu_image_convert(ipu, ic_task, in, out, rot_mode,\r\nimage_convert_sync_complete, &comp);\r\nif (IS_ERR(run))\r\nreturn PTR_ERR(run);\r\nret = wait_for_completion_timeout(&comp, msecs_to_jiffies(10000));\r\nret = (ret == 0) ? -ETIMEDOUT : 0;\r\nipu_image_convert_unprepare(run->ctx);\r\nkfree(run);\r\nreturn ret;\r\n}\r\nint ipu_image_convert_init(struct ipu_soc *ipu, struct device *dev)\r\n{\r\nstruct ipu_image_convert_priv *priv;\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nipu->image_convert_priv = priv;\r\npriv->ipu = ipu;\r\nfor (i = 0; i < IC_NUM_TASKS; i++) {\r\nstruct ipu_image_convert_chan *chan = &priv->chan[i];\r\nchan->ic_task = i;\r\nchan->priv = priv;\r\nchan->dma_ch = &image_convert_dma_chan[i];\r\nchan->out_eof_irq = -1;\r\nchan->rot_out_eof_irq = -1;\r\nspin_lock_init(&chan->irqlock);\r\nINIT_LIST_HEAD(&chan->ctx_list);\r\nINIT_LIST_HEAD(&chan->pending_q);\r\nINIT_LIST_HEAD(&chan->done_q);\r\n}\r\nreturn 0;\r\n}\r\nvoid ipu_image_convert_exit(struct ipu_soc *ipu)\r\n{\r\n}
