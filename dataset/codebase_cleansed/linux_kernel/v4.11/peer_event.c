static struct rxrpc_peer *rxrpc_lookup_peer_icmp_rcu(struct rxrpc_local *local,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct sock_exterr_skb *serr = SKB_EXT_ERR(skb);\r\nstruct sockaddr_rxrpc srx;\r\n_enter("");\r\nmemset(&srx, 0, sizeof(srx));\r\nsrx.transport_type = local->srx.transport_type;\r\nsrx.transport.family = local->srx.transport.family;\r\nswitch (srx.transport.family) {\r\ncase AF_INET:\r\nsrx.transport.sin.sin_port = serr->port;\r\nsrx.transport_len = sizeof(struct sockaddr_in);\r\nswitch (serr->ee.ee_origin) {\r\ncase SO_EE_ORIGIN_ICMP:\r\n_net("Rx ICMP");\r\nmemcpy(&srx.transport.sin.sin_addr,\r\nskb_network_header(skb) + serr->addr_offset,\r\nsizeof(struct in_addr));\r\nbreak;\r\ncase SO_EE_ORIGIN_ICMP6:\r\n_net("Rx ICMP6 on v4 sock");\r\nmemcpy(&srx.transport.sin.sin_addr,\r\nskb_network_header(skb) + serr->addr_offset + 12,\r\nsizeof(struct in_addr));\r\nbreak;\r\ndefault:\r\nmemcpy(&srx.transport.sin.sin_addr, &ip_hdr(skb)->saddr,\r\nsizeof(struct in_addr));\r\nbreak;\r\n}\r\nbreak;\r\n#ifdef CONFIG_AF_RXRPC_IPV6\r\ncase AF_INET6:\r\nsrx.transport.sin6.sin6_port = serr->port;\r\nsrx.transport_len = sizeof(struct sockaddr_in6);\r\nswitch (serr->ee.ee_origin) {\r\ncase SO_EE_ORIGIN_ICMP6:\r\n_net("Rx ICMP6");\r\nmemcpy(&srx.transport.sin6.sin6_addr,\r\nskb_network_header(skb) + serr->addr_offset,\r\nsizeof(struct in6_addr));\r\nbreak;\r\ncase SO_EE_ORIGIN_ICMP:\r\n_net("Rx ICMP on v6 sock");\r\nmemcpy(srx.transport.sin6.sin6_addr.s6_addr + 12,\r\nskb_network_header(skb) + serr->addr_offset,\r\nsizeof(struct in_addr));\r\nbreak;\r\ndefault:\r\nmemcpy(&srx.transport.sin6.sin6_addr,\r\n&ipv6_hdr(skb)->saddr,\r\nsizeof(struct in6_addr));\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\nreturn rxrpc_lookup_peer_rcu(local, &srx);\r\n}\r\nstatic void rxrpc_adjust_mtu(struct rxrpc_peer *peer, struct sock_exterr_skb *serr)\r\n{\r\nu32 mtu = serr->ee.ee_info;\r\n_net("Rx ICMP Fragmentation Needed (%d)", mtu);\r\nif (mtu > 0 && peer->if_mtu == 65535 && mtu < peer->if_mtu) {\r\npeer->if_mtu = mtu;\r\n_net("I/F MTU %u", mtu);\r\n}\r\nif (mtu == 0) {\r\nmtu = peer->if_mtu;\r\nif (mtu > 1500) {\r\nmtu >>= 1;\r\nif (mtu < 1500)\r\nmtu = 1500;\r\n} else {\r\nmtu -= 100;\r\nif (mtu < peer->hdrsize)\r\nmtu = peer->hdrsize + 4;\r\n}\r\n}\r\nif (mtu < peer->mtu) {\r\nspin_lock_bh(&peer->lock);\r\npeer->mtu = mtu;\r\npeer->maxdata = peer->mtu - peer->hdrsize;\r\nspin_unlock_bh(&peer->lock);\r\n_net("Net MTU %u (maxdata %u)",\r\npeer->mtu, peer->maxdata);\r\n}\r\n}\r\nvoid rxrpc_error_report(struct sock *sk)\r\n{\r\nstruct sock_exterr_skb *serr;\r\nstruct rxrpc_local *local = sk->sk_user_data;\r\nstruct rxrpc_peer *peer;\r\nstruct sk_buff *skb;\r\n_enter("%p{%d}", sk, local->debug_id);\r\nskb = sock_dequeue_err_skb(sk);\r\nif (!skb) {\r\n_leave("UDP socket errqueue empty");\r\nreturn;\r\n}\r\nrxrpc_new_skb(skb, rxrpc_skb_rx_received);\r\nserr = SKB_EXT_ERR(skb);\r\nif (!skb->len && serr->ee.ee_origin == SO_EE_ORIGIN_TIMESTAMPING) {\r\n_leave("UDP empty message");\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\nreturn;\r\n}\r\nrcu_read_lock();\r\npeer = rxrpc_lookup_peer_icmp_rcu(local, skb);\r\nif (peer && !rxrpc_get_peer_maybe(peer))\r\npeer = NULL;\r\nif (!peer) {\r\nrcu_read_unlock();\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\n_leave(" [no peer]");\r\nreturn;\r\n}\r\nif ((serr->ee.ee_origin == SO_EE_ORIGIN_ICMP &&\r\nserr->ee.ee_type == ICMP_DEST_UNREACH &&\r\nserr->ee.ee_code == ICMP_FRAG_NEEDED)) {\r\nrxrpc_adjust_mtu(peer, serr);\r\nrcu_read_unlock();\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\nrxrpc_put_peer(peer);\r\n_leave(" [MTU update]");\r\nreturn;\r\n}\r\nrxrpc_store_error(peer, serr);\r\nrcu_read_unlock();\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\nrxrpc_queue_work(&peer->error_distributor);\r\n_leave("");\r\n}\r\nstatic void rxrpc_store_error(struct rxrpc_peer *peer,\r\nstruct sock_exterr_skb *serr)\r\n{\r\nstruct sock_extended_err *ee;\r\nint err;\r\n_enter("");\r\nee = &serr->ee;\r\n_net("Rx Error o=%d t=%d c=%d e=%d",\r\nee->ee_origin, ee->ee_type, ee->ee_code, ee->ee_errno);\r\nerr = ee->ee_errno;\r\nswitch (ee->ee_origin) {\r\ncase SO_EE_ORIGIN_ICMP:\r\nswitch (ee->ee_type) {\r\ncase ICMP_DEST_UNREACH:\r\nswitch (ee->ee_code) {\r\ncase ICMP_NET_UNREACH:\r\n_net("Rx Received ICMP Network Unreachable");\r\nbreak;\r\ncase ICMP_HOST_UNREACH:\r\n_net("Rx Received ICMP Host Unreachable");\r\nbreak;\r\ncase ICMP_PORT_UNREACH:\r\n_net("Rx Received ICMP Port Unreachable");\r\nbreak;\r\ncase ICMP_NET_UNKNOWN:\r\n_net("Rx Received ICMP Unknown Network");\r\nbreak;\r\ncase ICMP_HOST_UNKNOWN:\r\n_net("Rx Received ICMP Unknown Host");\r\nbreak;\r\ndefault:\r\n_net("Rx Received ICMP DestUnreach code=%u",\r\nee->ee_code);\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\n_net("Rx Received ICMP TTL Exceeded");\r\nbreak;\r\ndefault:\r\n_proto("Rx Received ICMP error { type=%u code=%u }",\r\nee->ee_type, ee->ee_code);\r\nbreak;\r\n}\r\nbreak;\r\ncase SO_EE_ORIGIN_NONE:\r\ncase SO_EE_ORIGIN_LOCAL:\r\n_proto("Rx Received local error { error=%d }", err);\r\nerr += RXRPC_LOCAL_ERROR_OFFSET;\r\nbreak;\r\ncase SO_EE_ORIGIN_ICMP6:\r\ndefault:\r\n_proto("Rx Received error report { orig=%u }", ee->ee_origin);\r\nbreak;\r\n}\r\npeer->error_report = err;\r\n}\r\nvoid rxrpc_peer_error_distributor(struct work_struct *work)\r\n{\r\nstruct rxrpc_peer *peer =\r\ncontainer_of(work, struct rxrpc_peer, error_distributor);\r\nstruct rxrpc_call *call;\r\nenum rxrpc_call_completion compl;\r\nint error;\r\n_enter("");\r\nerror = READ_ONCE(peer->error_report);\r\nif (error < RXRPC_LOCAL_ERROR_OFFSET) {\r\ncompl = RXRPC_CALL_NETWORK_ERROR;\r\n} else {\r\ncompl = RXRPC_CALL_LOCAL_ERROR;\r\nerror -= RXRPC_LOCAL_ERROR_OFFSET;\r\n}\r\n_debug("ISSUE ERROR %s %d", rxrpc_call_completions[compl], error);\r\nspin_lock_bh(&peer->lock);\r\nwhile (!hlist_empty(&peer->error_targets)) {\r\ncall = hlist_entry(peer->error_targets.first,\r\nstruct rxrpc_call, error_link);\r\nhlist_del_init(&call->error_link);\r\nrxrpc_see_call(call);\r\nif (rxrpc_set_call_completion(call, compl, 0, error))\r\nrxrpc_notify_socket(call);\r\n}\r\nspin_unlock_bh(&peer->lock);\r\nrxrpc_put_peer(peer);\r\n_leave("");\r\n}\r\nvoid rxrpc_peer_add_rtt(struct rxrpc_call *call, enum rxrpc_rtt_rx_trace why,\r\nrxrpc_serial_t send_serial, rxrpc_serial_t resp_serial,\r\nktime_t send_time, ktime_t resp_time)\r\n{\r\nstruct rxrpc_peer *peer = call->peer;\r\ns64 rtt;\r\nu64 sum = peer->rtt_sum, avg;\r\nu8 cursor = peer->rtt_cursor, usage = peer->rtt_usage;\r\nrtt = ktime_to_ns(ktime_sub(resp_time, send_time));\r\nif (rtt < 0)\r\nreturn;\r\nsum -= peer->rtt_cache[cursor];\r\nsum += rtt;\r\npeer->rtt_cache[cursor] = rtt;\r\npeer->rtt_cursor = (cursor + 1) & (RXRPC_RTT_CACHE_SIZE - 1);\r\npeer->rtt_sum = sum;\r\nif (usage < RXRPC_RTT_CACHE_SIZE) {\r\nusage++;\r\npeer->rtt_usage = usage;\r\n}\r\nif (usage == RXRPC_RTT_CACHE_SIZE) {\r\navg = sum / RXRPC_RTT_CACHE_SIZE;\r\n} else {\r\navg = sum;\r\ndo_div(avg, usage);\r\n}\r\npeer->rtt = avg;\r\ntrace_rxrpc_rtt_rx(call, why, send_serial, resp_serial, rtt,\r\nusage, avg);\r\n}
