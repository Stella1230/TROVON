static __init int malta_scon(void)\r\n{\r\nint scon = MIPS_REVISION_SCONID;\r\nif (scon != MIPS_REVISION_SCON_OTHER)\r\nreturn scon;\r\nswitch (MIPS_REVISION_CORID) {\r\ncase MIPS_REVISION_CORID_QED_RM5261:\r\ncase MIPS_REVISION_CORID_CORE_LV:\r\ncase MIPS_REVISION_CORID_CORE_FPGA:\r\ncase MIPS_REVISION_CORID_CORE_FPGAR2:\r\nreturn MIPS_REVISION_SCON_GT64120;\r\ncase MIPS_REVISION_CORID_CORE_EMUL_BON:\r\ncase MIPS_REVISION_CORID_BONITO64:\r\ncase MIPS_REVISION_CORID_CORE_20K:\r\nreturn MIPS_REVISION_SCON_BONITO;\r\ncase MIPS_REVISION_CORID_CORE_MSC:\r\ncase MIPS_REVISION_CORID_CORE_FPGA2:\r\ncase MIPS_REVISION_CORID_CORE_24K:\r\nreturn MIPS_REVISION_SCON_SOCIT;\r\ncase MIPS_REVISION_CORID_CORE_FPGA3:\r\ncase MIPS_REVISION_CORID_CORE_FPGA4:\r\ncase MIPS_REVISION_CORID_CORE_FPGA5:\r\ncase MIPS_REVISION_CORID_CORE_EMUL_MSC:\r\ndefault:\r\nreturn MIPS_REVISION_SCON_ROCIT;\r\n}\r\n}\r\nstatic unsigned __init gen_fdt_mem_array(__be32 *mem_array, unsigned long size,\r\nenum mem_map map)\r\n{\r\nunsigned long size_preio;\r\nunsigned entries;\r\nentries = 1;\r\nmem_array[0] = cpu_to_be32(PHYS_OFFSET);\r\nif (IS_ENABLED(CONFIG_EVA)) {\r\nmem_array[1] = cpu_to_be32(size);\r\ngoto done;\r\n}\r\nsize_preio = min_t(unsigned long, size, SZ_256M);\r\nmem_array[1] = cpu_to_be32(size_preio);\r\nsize -= size_preio;\r\nif (!size)\r\ngoto done;\r\nif (map == MEM_MAP_V2) {\r\nif (size <= SZ_256M)\r\ngoto done;\r\nsize -= SZ_256M;\r\nentries++;\r\nmem_array[2] = cpu_to_be32(PHYS_OFFSET + SZ_512M);\r\nmem_array[3] = cpu_to_be32(size);\r\n} else {\r\nentries++;\r\nmem_array[2] = cpu_to_be32(PHYS_OFFSET + SZ_2G + SZ_256M);\r\nmem_array[3] = cpu_to_be32(size);\r\n}\r\ndone:\r\nBUG_ON(entries > MAX_MEM_ARRAY_ENTRIES);\r\nreturn entries;\r\n}\r\nstatic void __init append_memory(void *fdt, int root_off)\r\n{\r\n__be32 mem_array[2 * MAX_MEM_ARRAY_ENTRIES];\r\nunsigned long memsize;\r\nunsigned mem_entries;\r\nint i, err, mem_off;\r\nenum mem_map mem_map;\r\nu32 config;\r\nchar *var, param_name[10], *var_names[] = {\r\n"ememsize", "memsize",\r\n};\r\nmem_off = fdt_path_offset(fdt, "/memory");\r\nif (mem_off >= 0)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(var_names); i++) {\r\nvar = fw_getenv(var_names[i]);\r\nif (!var)\r\ncontinue;\r\nerr = kstrtoul(var, 0, &physical_memsize);\r\nif (!err)\r\nbreak;\r\npr_warn("Failed to read the '%s' env variable '%s'\n",\r\nvar_names[i], var);\r\n}\r\nif (!physical_memsize) {\r\npr_warn("The bootloader didn't provide memsize: defaulting to 32MB\n");\r\nphysical_memsize = 32 << 20;\r\n}\r\nif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)) {\r\nphysical_memsize -= PAGE_SIZE;\r\n}\r\nmemsize = physical_memsize;\r\nfor (i = 0; i < ARRAY_SIZE(var_names); i++) {\r\nsnprintf(param_name, sizeof(param_name), "%s=", var_names[i]);\r\nvar = strstr(arcs_cmdline, param_name);\r\nif (!var)\r\ncontinue;\r\nmemsize = memparse(var + strlen(param_name), NULL);\r\n}\r\nphysical_memsize = max_t(unsigned long, physical_memsize, memsize);\r\nif (malta_scon() == MIPS_REVISION_SCON_ROCIT) {\r\nconfig = readl((void __iomem *)CKSEG1ADDR(ROCIT_CONFIG_GEN1));\r\nmem_map = config & ROCIT_CONFIG_GEN1_MEMMAP_MASK;\r\nmem_map >>= ROCIT_CONFIG_GEN1_MEMMAP_SHIFT;\r\n} else {\r\nmem_map = MEM_MAP_V1;\r\n}\r\nif (mem_map > MEM_MAP_V2)\r\npanic("Unsupported physical memory map v%u detected",\r\n(unsigned int)mem_map);\r\nmem_off = fdt_add_subnode(fdt, root_off, "memory");\r\nif (mem_off < 0)\r\npanic("Unable to add memory node to DT: %d", mem_off);\r\nerr = fdt_setprop_string(fdt, mem_off, "device_type", "memory");\r\nif (err)\r\npanic("Unable to set memory node device_type: %d", err);\r\nmem_entries = gen_fdt_mem_array(mem_array, physical_memsize, mem_map);\r\nerr = fdt_setprop(fdt, mem_off, "reg", mem_array,\r\nmem_entries * 2 * sizeof(mem_array[0]));\r\nif (err)\r\npanic("Unable to set memory regs property: %d", err);\r\nmem_entries = gen_fdt_mem_array(mem_array, memsize, mem_map);\r\nerr = fdt_setprop(fdt, mem_off, "linux,usable-memory", mem_array,\r\nmem_entries * 2 * sizeof(mem_array[0]));\r\nif (err)\r\npanic("Unable to set linux,usable-memory property: %d", err);\r\n}\r\nstatic void __init remove_gic(void *fdt)\r\n{\r\nint err, gic_off, i8259_off, cpu_off;\r\nvoid __iomem *biu_base;\r\nuint32_t cpu_phandle, sc_cfg;\r\nerr = mips_cm_probe();\r\nif (!err && (read_gcr_gic_status() & CM_GCR_GIC_STATUS_GICEX_MSK))\r\nreturn;\r\nif (malta_scon() == MIPS_REVISION_SCON_ROCIT) {\r\nbiu_base = ioremap_nocache(MSC01_BIU_REG_BASE,\r\nMSC01_BIU_ADDRSPACE_SZ);\r\nsc_cfg = __raw_readl(biu_base + MSC01_SC_CFG_OFS);\r\nif (sc_cfg & MSC01_SC_CFG_GICPRES_MSK) {\r\nsc_cfg |= BIT(MSC01_SC_CFG_GICENA_SHF);\r\n__raw_writel(sc_cfg, biu_base + MSC01_SC_CFG_OFS);\r\nreturn;\r\n}\r\n}\r\ngic_off = fdt_node_offset_by_compatible(fdt, -1, "mti,gic");\r\nif (gic_off < 0) {\r\npr_warn("malta-dtshim: unable to find DT GIC node: %d\n",\r\ngic_off);\r\nreturn;\r\n}\r\nerr = fdt_nop_node(fdt, gic_off);\r\nif (err)\r\npr_warn("malta-dtshim: unable to nop GIC node\n");\r\ni8259_off = fdt_node_offset_by_compatible(fdt, -1, "intel,i8259");\r\nif (i8259_off < 0) {\r\npr_warn("malta-dtshim: unable to find DT i8259 node: %d\n",\r\ni8259_off);\r\nreturn;\r\n}\r\ncpu_off = fdt_node_offset_by_compatible(fdt, -1,\r\n"mti,cpu-interrupt-controller");\r\nif (cpu_off < 0) {\r\npr_warn("malta-dtshim: unable to find CPU intc node: %d\n",\r\ncpu_off);\r\nreturn;\r\n}\r\ncpu_phandle = fdt_get_phandle(fdt, cpu_off);\r\nif (!cpu_phandle) {\r\npr_warn("malta-dtshim: unable to get CPU intc phandle\n");\r\nreturn;\r\n}\r\nerr = fdt_setprop_u32(fdt, i8259_off, "interrupt-parent", cpu_phandle);\r\nif (err) {\r\npr_warn("malta-dtshim: unable to set i8259 interrupt-parent: %d\n",\r\nerr);\r\nreturn;\r\n}\r\nerr = fdt_setprop_u32(fdt, i8259_off, "interrupts", 2);\r\nif (err) {\r\npr_warn("malta-dtshim: unable to set i8259 interrupts: %d\n",\r\nerr);\r\nreturn;\r\n}\r\n}\r\nvoid __init *malta_dt_shim(void *fdt)\r\n{\r\nint root_off, len, err;\r\nconst char *compat;\r\nif (fdt_check_header(fdt))\r\npanic("Corrupt DT");\r\nerr = fdt_open_into(fdt, fdt_buf, sizeof(fdt_buf));\r\nif (err)\r\npanic("Unable to open FDT: %d", err);\r\nroot_off = fdt_path_offset(fdt_buf, "/");\r\nif (root_off < 0)\r\npanic("No / node in DT");\r\ncompat = fdt_getprop(fdt_buf, root_off, "compatible", &len);\r\nif (!compat)\r\npanic("No root compatible property in DT: %d", len);\r\nif (strncmp(compat, "mti,malta", len))\r\nreturn fdt;\r\nappend_memory(fdt_buf, root_off);\r\nremove_gic(fdt_buf);\r\nerr = fdt_pack(fdt_buf);\r\nif (err)\r\npanic("Unable to pack FDT: %d\n", err);\r\nreturn fdt_buf;\r\n}
