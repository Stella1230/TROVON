static inline u32 __smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)\r\n{\r\nif (pdata->config.flags & SMSC911X_USE_32BIT)\r\nreturn readl(pdata->ioaddr + reg);\r\nif (pdata->config.flags & SMSC911X_USE_16BIT)\r\nreturn ((readw(pdata->ioaddr + reg) & 0xFFFF) |\r\n((readw(pdata->ioaddr + reg + 2) & 0xFFFF) << 16));\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic inline u32\r\n__smsc911x_reg_read_shift(struct smsc911x_data *pdata, u32 reg)\r\n{\r\nif (pdata->config.flags & SMSC911X_USE_32BIT)\r\nreturn readl(pdata->ioaddr + __smsc_shift(pdata, reg));\r\nif (pdata->config.flags & SMSC911X_USE_16BIT)\r\nreturn (readw(pdata->ioaddr +\r\n__smsc_shift(pdata, reg)) & 0xFFFF) |\r\n((readw(pdata->ioaddr +\r\n__smsc_shift(pdata, reg + 2)) & 0xFFFF) << 16);\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic inline u32 smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)\r\n{\r\nu32 data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\ndata = pdata->ops->reg_read(pdata, reg);\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void __smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,\r\nu32 val)\r\n{\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\nwritel(val, pdata->ioaddr + reg);\r\nreturn;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwritew(val & 0xFFFF, pdata->ioaddr + reg);\r\nwritew((val >> 16) & 0xFFFF, pdata->ioaddr + reg + 2);\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic inline void\r\n__smsc911x_reg_write_shift(struct smsc911x_data *pdata, u32 reg, u32 val)\r\n{\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\nwritel(val, pdata->ioaddr + __smsc_shift(pdata, reg));\r\nreturn;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwritew(val & 0xFFFF,\r\npdata->ioaddr + __smsc_shift(pdata, reg));\r\nwritew((val >> 16) & 0xFFFF,\r\npdata->ioaddr + __smsc_shift(pdata, reg + 2));\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic inline void smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg,\r\nu32 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\npdata->ops->reg_write(pdata, reg, val);\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\n}\r\nstatic inline void\r\nsmsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,\r\nunsigned int wordcount)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\nif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\r\nwhile (wordcount--)\r\n__smsc911x_reg_write(pdata, TX_DATA_FIFO,\r\nswab32(*buf++));\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\niowrite32_rep(pdata->ioaddr + TX_DATA_FIFO, buf, wordcount);\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwhile (wordcount--)\r\n__smsc911x_reg_write(pdata, TX_DATA_FIFO, *buf++);\r\ngoto out;\r\n}\r\nBUG();\r\nout:\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\n}\r\nstatic inline void\r\nsmsc911x_tx_writefifo_shift(struct smsc911x_data *pdata, unsigned int *buf,\r\nunsigned int wordcount)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\nif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\r\nwhile (wordcount--)\r\n__smsc911x_reg_write_shift(pdata, TX_DATA_FIFO,\r\nswab32(*buf++));\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\niowrite32_rep(pdata->ioaddr + __smsc_shift(pdata,\r\nTX_DATA_FIFO), buf, wordcount);\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwhile (wordcount--)\r\n__smsc911x_reg_write_shift(pdata,\r\nTX_DATA_FIFO, *buf++);\r\ngoto out;\r\n}\r\nBUG();\r\nout:\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\n}\r\nstatic inline void\r\nsmsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,\r\nunsigned int wordcount)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\nif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\r\nwhile (wordcount--)\r\n*buf++ = swab32(__smsc911x_reg_read(pdata,\r\nRX_DATA_FIFO));\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\nioread32_rep(pdata->ioaddr + RX_DATA_FIFO, buf, wordcount);\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwhile (wordcount--)\r\n*buf++ = __smsc911x_reg_read(pdata, RX_DATA_FIFO);\r\ngoto out;\r\n}\r\nBUG();\r\nout:\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\n}\r\nstatic inline void\r\nsmsc911x_rx_readfifo_shift(struct smsc911x_data *pdata, unsigned int *buf,\r\nunsigned int wordcount)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdata->dev_lock, flags);\r\nif (pdata->config.flags & SMSC911X_SWAP_FIFO) {\r\nwhile (wordcount--)\r\n*buf++ = swab32(__smsc911x_reg_read_shift(pdata,\r\nRX_DATA_FIFO));\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_32BIT) {\r\nioread32_rep(pdata->ioaddr + __smsc_shift(pdata,\r\nRX_DATA_FIFO), buf, wordcount);\r\ngoto out;\r\n}\r\nif (pdata->config.flags & SMSC911X_USE_16BIT) {\r\nwhile (wordcount--)\r\n*buf++ = __smsc911x_reg_read_shift(pdata,\r\nRX_DATA_FIFO);\r\ngoto out;\r\n}\r\nBUG();\r\nout:\r\nspin_unlock_irqrestore(&pdata->dev_lock, flags);\r\n}\r\nstatic int smsc911x_enable_resources(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nint ret = 0;\r\nret = regulator_bulk_enable(ARRAY_SIZE(pdata->supplies),\r\npdata->supplies);\r\nif (ret)\r\nnetdev_err(ndev, "failed to enable regulators %d\n",\r\nret);\r\nif (!IS_ERR(pdata->clk)) {\r\nret = clk_prepare_enable(pdata->clk);\r\nif (ret < 0)\r\nnetdev_err(ndev, "failed to enable clock %d\n", ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int smsc911x_disable_resources(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nint ret = 0;\r\nret = regulator_bulk_disable(ARRAY_SIZE(pdata->supplies),\r\npdata->supplies);\r\nif (!IS_ERR(pdata->clk))\r\nclk_disable_unprepare(pdata->clk);\r\nreturn ret;\r\n}\r\nstatic int smsc911x_request_resources(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nint ret = 0;\r\npdata->supplies[0].supply = "vdd33a";\r\npdata->supplies[1].supply = "vddvario";\r\nret = regulator_bulk_get(&pdev->dev,\r\nARRAY_SIZE(pdata->supplies),\r\npdata->supplies);\r\nif (ret) {\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nnetdev_err(ndev, "couldn't get regulators %d\n",\r\nret);\r\n}\r\npdata->reset_gpiod = devm_gpiod_get_optional(&pdev->dev,\r\n"reset",\r\nGPIOD_OUT_LOW);\r\npdata->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pdata->clk))\r\ndev_dbg(&pdev->dev, "couldn't get clock %li\n",\r\nPTR_ERR(pdata->clk));\r\nreturn ret;\r\n}\r\nstatic void smsc911x_free_resources(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nregulator_bulk_free(ARRAY_SIZE(pdata->supplies),\r\npdata->supplies);\r\nif (!IS_ERR(pdata->clk)) {\r\nclk_put(pdata->clk);\r\npdata->clk = NULL;\r\n}\r\n}\r\nstatic int smsc911x_mac_complete(struct smsc911x_data *pdata)\r\n{\r\nint i;\r\nu32 val;\r\nSMSC_ASSERT_MAC_LOCK(pdata);\r\nfor (i = 0; i < 40; i++) {\r\nval = smsc911x_reg_read(pdata, MAC_CSR_CMD);\r\nif (!(val & MAC_CSR_CMD_CSR_BUSY_))\r\nreturn 0;\r\n}\r\nSMSC_WARN(pdata, hw, "Timed out waiting for MAC not BUSY. "\r\n"MAC_CSR_CMD: 0x%08X", val);\r\nreturn -EIO;\r\n}\r\nstatic u32 smsc911x_mac_read(struct smsc911x_data *pdata, unsigned int offset)\r\n{\r\nunsigned int temp;\r\nSMSC_ASSERT_MAC_LOCK(pdata);\r\ntemp = smsc911x_reg_read(pdata, MAC_CSR_CMD);\r\nif (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {\r\nSMSC_WARN(pdata, hw, "MAC busy at entry");\r\nreturn 0xFFFFFFFF;\r\n}\r\nsmsc911x_reg_write(pdata, MAC_CSR_CMD, ((offset & 0xFF) |\r\nMAC_CSR_CMD_CSR_BUSY_ | MAC_CSR_CMD_R_NOT_W_));\r\ntemp = smsc911x_reg_read(pdata, BYTE_TEST);\r\nif (likely(smsc911x_mac_complete(pdata) == 0))\r\nreturn smsc911x_reg_read(pdata, MAC_CSR_DATA);\r\nSMSC_WARN(pdata, hw, "MAC busy after read");\r\nreturn 0xFFFFFFFF;\r\n}\r\nstatic void smsc911x_mac_write(struct smsc911x_data *pdata,\r\nunsigned int offset, u32 val)\r\n{\r\nunsigned int temp;\r\nSMSC_ASSERT_MAC_LOCK(pdata);\r\ntemp = smsc911x_reg_read(pdata, MAC_CSR_CMD);\r\nif (unlikely(temp & MAC_CSR_CMD_CSR_BUSY_)) {\r\nSMSC_WARN(pdata, hw,\r\n"smsc911x_mac_write failed, MAC busy at entry");\r\nreturn;\r\n}\r\nsmsc911x_reg_write(pdata, MAC_CSR_DATA, val);\r\nsmsc911x_reg_write(pdata, MAC_CSR_CMD, ((offset & 0xFF) |\r\nMAC_CSR_CMD_CSR_BUSY_));\r\ntemp = smsc911x_reg_read(pdata, BYTE_TEST);\r\nif (likely(smsc911x_mac_complete(pdata) == 0))\r\nreturn;\r\nSMSC_WARN(pdata, hw, "smsc911x_mac_write failed, MAC busy after write");\r\n}\r\nstatic int smsc911x_mii_read(struct mii_bus *bus, int phyaddr, int regidx)\r\n{\r\nstruct smsc911x_data *pdata = (struct smsc911x_data *)bus->priv;\r\nunsigned long flags;\r\nunsigned int addr;\r\nint i, reg;\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nif (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\r\nSMSC_WARN(pdata, hw, "MII is busy in smsc911x_mii_read???");\r\nreg = -EIO;\r\ngoto out;\r\n}\r\naddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6);\r\nsmsc911x_mac_write(pdata, MII_ACC, addr);\r\nfor (i = 0; i < 100; i++)\r\nif (!(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\r\nreg = smsc911x_mac_read(pdata, MII_DATA);\r\ngoto out;\r\n}\r\nSMSC_WARN(pdata, hw, "Timed out waiting for MII read to finish");\r\nreg = -EIO;\r\nout:\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nreturn reg;\r\n}\r\nstatic int smsc911x_mii_write(struct mii_bus *bus, int phyaddr, int regidx,\r\nu16 val)\r\n{\r\nstruct smsc911x_data *pdata = (struct smsc911x_data *)bus->priv;\r\nunsigned long flags;\r\nunsigned int addr;\r\nint i, reg;\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nif (unlikely(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\r\nSMSC_WARN(pdata, hw, "MII is busy in smsc911x_mii_write???");\r\nreg = -EIO;\r\ngoto out;\r\n}\r\nsmsc911x_mac_write(pdata, MII_DATA, val);\r\naddr = ((phyaddr & 0x1F) << 11) | ((regidx & 0x1F) << 6) |\r\nMII_ACC_MII_WRITE_;\r\nsmsc911x_mac_write(pdata, MII_ACC, addr);\r\nfor (i = 0; i < 100; i++)\r\nif (!(smsc911x_mac_read(pdata, MII_ACC) & MII_ACC_MII_BUSY_)) {\r\nreg = 0;\r\ngoto out;\r\n}\r\nSMSC_WARN(pdata, hw, "Timed out waiting for MII write to finish");\r\nreg = -EIO;\r\nout:\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nreturn reg;\r\n}\r\nstatic void smsc911x_phy_enable_external(struct smsc911x_data *pdata)\r\n{\r\nunsigned int hwcfg = smsc911x_reg_read(pdata, HW_CFG);\r\nhwcfg &= (~HW_CFG_PHY_CLK_SEL_);\r\nhwcfg |= HW_CFG_PHY_CLK_SEL_CLK_DIS_;\r\nsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\r\nudelay(10);\r\nhwcfg |= HW_CFG_EXT_PHY_EN_;\r\nsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\r\nhwcfg &= (~HW_CFG_PHY_CLK_SEL_);\r\nhwcfg |= HW_CFG_PHY_CLK_SEL_EXT_PHY_;\r\nsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\r\nudelay(10);\r\nhwcfg |= HW_CFG_SMI_SEL_;\r\nsmsc911x_reg_write(pdata, HW_CFG, hwcfg);\r\n}\r\nstatic void smsc911x_phy_initialise_external(struct smsc911x_data *pdata)\r\n{\r\nunsigned int hwcfg = smsc911x_reg_read(pdata, HW_CFG);\r\nif (pdata->config.flags & SMSC911X_FORCE_INTERNAL_PHY) {\r\nSMSC_TRACE(pdata, hw, "Forcing internal PHY");\r\npdata->using_extphy = 0;\r\n} else if (pdata->config.flags & SMSC911X_FORCE_EXTERNAL_PHY) {\r\nSMSC_TRACE(pdata, hw, "Forcing external PHY");\r\nsmsc911x_phy_enable_external(pdata);\r\npdata->using_extphy = 1;\r\n} else if (hwcfg & HW_CFG_EXT_PHY_DET_) {\r\nSMSC_TRACE(pdata, hw,\r\n"HW_CFG EXT_PHY_DET set, using external PHY");\r\nsmsc911x_phy_enable_external(pdata);\r\npdata->using_extphy = 1;\r\n} else {\r\nSMSC_TRACE(pdata, hw,\r\n"HW_CFG EXT_PHY_DET clear, using internal PHY");\r\npdata->using_extphy = 0;\r\n}\r\n}\r\nstatic unsigned int smsc911x_tx_get_txstatus(struct smsc911x_data *pdata)\r\n{\r\nunsigned int result =\r\nsmsc911x_reg_read(pdata, TX_FIFO_INF) & TX_FIFO_INF_TSUSED_;\r\nif (result != 0)\r\nresult = smsc911x_reg_read(pdata, TX_STATUS_FIFO);\r\nreturn result;\r\n}\r\nstatic unsigned int smsc911x_rx_get_rxstatus(struct smsc911x_data *pdata)\r\n{\r\nunsigned int result =\r\nsmsc911x_reg_read(pdata, RX_FIFO_INF) & RX_FIFO_INF_RXSUSED_;\r\nif (result != 0)\r\nresult = smsc911x_reg_read(pdata, RX_STATUS_FIFO);\r\nreturn result;\r\n}\r\nstatic int smsc911x_phy_check_loopbackpkt(struct smsc911x_data *pdata)\r\n{\r\nunsigned int tries;\r\nu32 wrsz;\r\nu32 rdsz;\r\nulong bufp;\r\nfor (tries = 0; tries < 10; tries++) {\r\nunsigned int txcmd_a;\r\nunsigned int txcmd_b;\r\nunsigned int status;\r\nunsigned int pktlength;\r\nunsigned int i;\r\nmemset(pdata->loopback_rx_pkt, 0, MIN_PACKET_SIZE);\r\ntxcmd_a = (u32)((ulong)pdata->loopback_tx_pkt & 0x03) << 16;\r\ntxcmd_a |= TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;\r\ntxcmd_a |= MIN_PACKET_SIZE;\r\ntxcmd_b = MIN_PACKET_SIZE << 16 | MIN_PACKET_SIZE;\r\nsmsc911x_reg_write(pdata, TX_DATA_FIFO, txcmd_a);\r\nsmsc911x_reg_write(pdata, TX_DATA_FIFO, txcmd_b);\r\nbufp = (ulong)pdata->loopback_tx_pkt & (~0x3);\r\nwrsz = MIN_PACKET_SIZE + 3;\r\nwrsz += (u32)((ulong)pdata->loopback_tx_pkt & 0x3);\r\nwrsz >>= 2;\r\npdata->ops->tx_writefifo(pdata, (unsigned int *)bufp, wrsz);\r\ni = 60;\r\ndo {\r\nudelay(5);\r\nstatus = smsc911x_tx_get_txstatus(pdata);\r\n} while ((i--) && (!status));\r\nif (!status) {\r\nSMSC_WARN(pdata, hw,\r\n"Failed to transmit during loopback test");\r\ncontinue;\r\n}\r\nif (status & TX_STS_ES_) {\r\nSMSC_WARN(pdata, hw,\r\n"Transmit encountered errors during loopback test");\r\ncontinue;\r\n}\r\ni = 60;\r\ndo {\r\nudelay(5);\r\nstatus = smsc911x_rx_get_rxstatus(pdata);\r\n} while ((i--) && (!status));\r\nif (!status) {\r\nSMSC_WARN(pdata, hw,\r\n"Failed to receive during loopback test");\r\ncontinue;\r\n}\r\nif (status & RX_STS_ES_) {\r\nSMSC_WARN(pdata, hw,\r\n"Receive encountered errors during loopback test");\r\ncontinue;\r\n}\r\npktlength = ((status & 0x3FFF0000UL) >> 16);\r\nbufp = (ulong)pdata->loopback_rx_pkt;\r\nrdsz = pktlength + 3;\r\nrdsz += (u32)((ulong)pdata->loopback_rx_pkt & 0x3);\r\nrdsz >>= 2;\r\npdata->ops->rx_readfifo(pdata, (unsigned int *)bufp, rdsz);\r\nif (pktlength != (MIN_PACKET_SIZE + 4)) {\r\nSMSC_WARN(pdata, hw, "Unexpected packet size "\r\n"during loop back test, size=%d, will retry",\r\npktlength);\r\n} else {\r\nunsigned int j;\r\nint mismatch = 0;\r\nfor (j = 0; j < MIN_PACKET_SIZE; j++) {\r\nif (pdata->loopback_tx_pkt[j]\r\n!= pdata->loopback_rx_pkt[j]) {\r\nmismatch = 1;\r\nbreak;\r\n}\r\n}\r\nif (!mismatch) {\r\nSMSC_TRACE(pdata, hw, "Successfully verified "\r\n"loopback packet");\r\nreturn 0;\r\n} else {\r\nSMSC_WARN(pdata, hw, "Data mismatch "\r\n"during loop back test, will retry");\r\n}\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int smsc911x_phy_reset(struct smsc911x_data *pdata)\r\n{\r\nunsigned int temp;\r\nunsigned int i = 100000;\r\ntemp = smsc911x_reg_read(pdata, PMT_CTRL);\r\nsmsc911x_reg_write(pdata, PMT_CTRL, temp | PMT_CTRL_PHY_RST_);\r\ndo {\r\nmsleep(1);\r\ntemp = smsc911x_reg_read(pdata, PMT_CTRL);\r\n} while ((i--) && (temp & PMT_CTRL_PHY_RST_));\r\nif (unlikely(temp & PMT_CTRL_PHY_RST_)) {\r\nSMSC_WARN(pdata, hw, "PHY reset failed to complete");\r\nreturn -EIO;\r\n}\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int smsc911x_phy_loopbacktest(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nstruct phy_device *phy_dev = dev->phydev;\r\nint result = -EIO;\r\nunsigned int i, val;\r\nunsigned long flags;\r\neth_broadcast_addr(pdata->loopback_tx_pkt);\r\nfor (i = 6; i < 12; i++)\r\npdata->loopback_tx_pkt[i] = (char)i;\r\npdata->loopback_tx_pkt[12] = 0x00;\r\npdata->loopback_tx_pkt[13] = 0x00;\r\nfor (i = 14; i < MIN_PACKET_SIZE; i++)\r\npdata->loopback_tx_pkt[i] = (char)i;\r\nval = smsc911x_reg_read(pdata, HW_CFG);\r\nval &= HW_CFG_TX_FIF_SZ_;\r\nval |= HW_CFG_SF_;\r\nsmsc911x_reg_write(pdata, HW_CFG, val);\r\nsmsc911x_reg_write(pdata, TX_CFG, TX_CFG_TX_ON_);\r\nsmsc911x_reg_write(pdata, RX_CFG,\r\n(u32)((ulong)pdata->loopback_rx_pkt & 0x03) << 8);\r\nfor (i = 0; i < 10; i++) {\r\nsmsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr,\r\nMII_BMCR, BMCR_LOOPBACK | BMCR_FULLDPLX);\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nsmsc911x_mac_write(pdata, MAC_CR, MAC_CR_FDPX_\r\n| MAC_CR_TXEN_ | MAC_CR_RXEN_);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nif (smsc911x_phy_check_loopbackpkt(pdata) == 0) {\r\nresult = 0;\r\nbreak;\r\n}\r\npdata->resetcount++;\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nsmsc911x_mac_write(pdata, MAC_CR, 0);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nsmsc911x_phy_reset(pdata);\r\n}\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nsmsc911x_mac_write(pdata, MAC_CR, 0);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nsmsc911x_mii_write(phy_dev->mdio.bus, phy_dev->mdio.addr, MII_BMCR, 0);\r\nsmsc911x_reg_write(pdata, TX_CFG, 0);\r\nsmsc911x_reg_write(pdata, RX_CFG, 0);\r\nreturn result;\r\n}\r\nstatic void smsc911x_phy_update_flowcontrol(struct smsc911x_data *pdata)\r\n{\r\nstruct net_device *ndev = pdata->dev;\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nu32 afc = smsc911x_reg_read(pdata, AFC_CFG);\r\nu32 flow;\r\nunsigned long flags;\r\nif (phy_dev->duplex == DUPLEX_FULL) {\r\nu16 lcladv = phy_read(phy_dev, MII_ADVERTISE);\r\nu16 rmtadv = phy_read(phy_dev, MII_LPA);\r\nu8 cap = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\r\nif (cap & FLOW_CTRL_RX)\r\nflow = 0xFFFF0002;\r\nelse\r\nflow = 0;\r\nif (cap & FLOW_CTRL_TX)\r\nafc |= 0xF;\r\nelse\r\nafc &= ~0xF;\r\nSMSC_TRACE(pdata, hw, "rx pause %s, tx pause %s",\r\n(cap & FLOW_CTRL_RX ? "enabled" : "disabled"),\r\n(cap & FLOW_CTRL_TX ? "enabled" : "disabled"));\r\n} else {\r\nSMSC_TRACE(pdata, hw, "half duplex");\r\nflow = 0;\r\nafc |= 0xF;\r\n}\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nsmsc911x_mac_write(pdata, FLOW, flow);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nsmsc911x_reg_write(pdata, AFC_CFG, afc);\r\n}\r\nstatic void smsc911x_phy_adjust_link(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nstruct phy_device *phy_dev = dev->phydev;\r\nunsigned long flags;\r\nint carrier;\r\nif (phy_dev->duplex != pdata->last_duplex) {\r\nunsigned int mac_cr;\r\nSMSC_TRACE(pdata, hw, "duplex state has changed");\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nmac_cr = smsc911x_mac_read(pdata, MAC_CR);\r\nif (phy_dev->duplex) {\r\nSMSC_TRACE(pdata, hw,\r\n"configuring for full duplex mode");\r\nmac_cr |= MAC_CR_FDPX_;\r\n} else {\r\nSMSC_TRACE(pdata, hw,\r\n"configuring for half duplex mode");\r\nmac_cr &= ~MAC_CR_FDPX_;\r\n}\r\nsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\nsmsc911x_phy_update_flowcontrol(pdata);\r\npdata->last_duplex = phy_dev->duplex;\r\n}\r\ncarrier = netif_carrier_ok(dev);\r\nif (carrier != pdata->last_carrier) {\r\nSMSC_TRACE(pdata, hw, "carrier state has changed");\r\nif (carrier) {\r\nSMSC_TRACE(pdata, hw, "configuring for carrier OK");\r\nif ((pdata->gpio_orig_setting & GPIO_CFG_LED1_EN_) &&\r\n(!pdata->using_extphy)) {\r\npdata->gpio_setting = pdata->gpio_orig_setting;\r\nsmsc911x_reg_write(pdata, GPIO_CFG,\r\npdata->gpio_setting);\r\n}\r\n} else {\r\nSMSC_TRACE(pdata, hw, "configuring for no carrier");\r\npdata->gpio_setting = smsc911x_reg_read(pdata,\r\nGPIO_CFG);\r\nif ((pdata->gpio_setting & GPIO_CFG_LED1_EN_) &&\r\n(!pdata->using_extphy)) {\r\npdata->gpio_orig_setting = pdata->gpio_setting;\r\npdata->gpio_setting &= ~GPIO_CFG_LED1_EN_;\r\npdata->gpio_setting |= (GPIO_CFG_GPIOBUF0_\r\n| GPIO_CFG_GPIODIR0_\r\n| GPIO_CFG_GPIOD0_);\r\nsmsc911x_reg_write(pdata, GPIO_CFG,\r\npdata->gpio_setting);\r\n}\r\n}\r\npdata->last_carrier = carrier;\r\n}\r\n}\r\nstatic int smsc911x_mii_probe(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nint ret;\r\nphydev = phy_find_first(pdata->mii_bus);\r\nif (!phydev) {\r\nnetdev_err(dev, "no PHY found\n");\r\nreturn -ENODEV;\r\n}\r\nSMSC_TRACE(pdata, probe, "PHY: addr %d, phy_id 0x%08X",\r\nphydev->mdio.addr, phydev->phy_id);\r\nret = phy_connect_direct(dev, phydev, &smsc911x_phy_adjust_link,\r\npdata->config.phy_interface);\r\nif (ret) {\r\nnetdev_err(dev, "Could not attach to PHY\n");\r\nreturn ret;\r\n}\r\nphy_attached_info(phydev);\r\nphydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphydev->advertising = phydev->supported;\r\npdata->last_duplex = -1;\r\npdata->last_carrier = -1;\r\n#ifdef USE_PHY_WORK_AROUND\r\nif (smsc911x_phy_loopbacktest(dev) < 0) {\r\nSMSC_WARN(pdata, hw, "Failed Loop Back Test");\r\nphy_disconnect(phydev);\r\nreturn -ENODEV;\r\n}\r\nSMSC_TRACE(pdata, hw, "Passed Loop Back Test");\r\n#endif\r\nSMSC_TRACE(pdata, hw, "phy initialised successfully");\r\nreturn 0;\r\n}\r\nstatic int smsc911x_mii_init(struct platform_device *pdev,\r\nstruct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nint err = -ENXIO;\r\npdata->mii_bus = mdiobus_alloc();\r\nif (!pdata->mii_bus) {\r\nerr = -ENOMEM;\r\ngoto err_out_1;\r\n}\r\npdata->mii_bus->name = SMSC_MDIONAME;\r\nsnprintf(pdata->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, pdev->id);\r\npdata->mii_bus->priv = pdata;\r\npdata->mii_bus->read = smsc911x_mii_read;\r\npdata->mii_bus->write = smsc911x_mii_write;\r\npdata->mii_bus->parent = &pdev->dev;\r\nswitch (pdata->idrev & 0xFFFF0000) {\r\ncase 0x01170000:\r\ncase 0x01150000:\r\ncase 0x117A0000:\r\ncase 0x115A0000:\r\nsmsc911x_phy_initialise_external(pdata);\r\nbreak;\r\ndefault:\r\nSMSC_TRACE(pdata, hw, "External PHY is not supported, "\r\n"using internal PHY");\r\npdata->using_extphy = 0;\r\nbreak;\r\n}\r\nif (!pdata->using_extphy) {\r\npdata->mii_bus->phy_mask = ~(1 << 1);\r\n}\r\nif (mdiobus_register(pdata->mii_bus)) {\r\nSMSC_WARN(pdata, probe, "Error registering mii bus");\r\ngoto err_out_free_bus_2;\r\n}\r\nreturn 0;\r\nerr_out_free_bus_2:\r\nmdiobus_free(pdata->mii_bus);\r\nerr_out_1:\r\nreturn err;\r\n}\r\nstatic unsigned int smsc911x_tx_get_txstatcount(struct smsc911x_data *pdata)\r\n{\r\nreturn (smsc911x_reg_read(pdata, TX_FIFO_INF)\r\n& TX_FIFO_INF_TSUSED_) >> 16;\r\n}\r\nstatic void smsc911x_tx_update_txcounters(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned int tx_stat;\r\nwhile ((tx_stat = smsc911x_tx_get_txstatus(pdata)) != 0) {\r\nif (unlikely(tx_stat & 0x80000000)) {\r\nSMSC_WARN(pdata, hw, "Packet tag reserved bit is high");\r\n} else {\r\nif (unlikely(tx_stat & TX_STS_ES_)) {\r\ndev->stats.tx_errors++;\r\n} else {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += (tx_stat >> 16);\r\n}\r\nif (unlikely(tx_stat & TX_STS_EXCESS_COL_)) {\r\ndev->stats.collisions += 16;\r\ndev->stats.tx_aborted_errors += 1;\r\n} else {\r\ndev->stats.collisions +=\r\n((tx_stat >> 3) & 0xF);\r\n}\r\nif (unlikely(tx_stat & TX_STS_LOST_CARRIER_))\r\ndev->stats.tx_carrier_errors += 1;\r\nif (unlikely(tx_stat & TX_STS_LATE_COL_)) {\r\ndev->stats.collisions++;\r\ndev->stats.tx_aborted_errors++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nsmsc911x_rx_counterrors(struct net_device *dev, unsigned int rxstat)\r\n{\r\nint crc_err = 0;\r\nif (unlikely(rxstat & RX_STS_ES_)) {\r\ndev->stats.rx_errors++;\r\nif (unlikely(rxstat & RX_STS_CRC_ERR_)) {\r\ndev->stats.rx_crc_errors++;\r\ncrc_err = 1;\r\n}\r\n}\r\nif (likely(!crc_err)) {\r\nif (unlikely((rxstat & RX_STS_FRAME_TYPE_) &&\r\n(rxstat & RX_STS_LENGTH_ERR_)))\r\ndev->stats.rx_length_errors++;\r\nif (rxstat & RX_STS_MCAST_)\r\ndev->stats.multicast++;\r\n}\r\n}\r\nstatic void\r\nsmsc911x_rx_fastforward(struct smsc911x_data *pdata, unsigned int pktwords)\r\n{\r\nif (likely(pktwords >= 4)) {\r\nunsigned int timeout = 500;\r\nunsigned int val;\r\nsmsc911x_reg_write(pdata, RX_DP_CTRL, RX_DP_CTRL_RX_FFWD_);\r\ndo {\r\nudelay(1);\r\nval = smsc911x_reg_read(pdata, RX_DP_CTRL);\r\n} while ((val & RX_DP_CTRL_RX_FFWD_) && --timeout);\r\nif (unlikely(timeout == 0))\r\nSMSC_WARN(pdata, hw, "Timed out waiting for "\r\n"RX FFWD to finish, RX_DP_CTRL: 0x%08X", val);\r\n} else {\r\nunsigned int temp;\r\nwhile (pktwords--)\r\ntemp = smsc911x_reg_read(pdata, RX_DATA_FIFO);\r\n}\r\n}\r\nstatic int smsc911x_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct smsc911x_data *pdata =\r\ncontainer_of(napi, struct smsc911x_data, napi);\r\nstruct net_device *dev = pdata->dev;\r\nint npackets = 0;\r\nwhile (npackets < budget) {\r\nunsigned int pktlength;\r\nunsigned int pktwords;\r\nstruct sk_buff *skb;\r\nunsigned int rxstat = smsc911x_rx_get_rxstatus(pdata);\r\nif (!rxstat) {\r\nunsigned int temp;\r\nsmsc911x_reg_write(pdata, INT_STS, INT_STS_RSFL_);\r\nnapi_complete(napi);\r\ntemp = smsc911x_reg_read(pdata, INT_EN);\r\ntemp |= INT_EN_RSFL_EN_;\r\nsmsc911x_reg_write(pdata, INT_EN, temp);\r\nbreak;\r\n}\r\nnpackets++;\r\npktlength = ((rxstat & 0x3FFF0000) >> 16);\r\npktwords = (pktlength + NET_IP_ALIGN + 3) >> 2;\r\nsmsc911x_rx_counterrors(dev, rxstat);\r\nif (unlikely(rxstat & RX_STS_ES_)) {\r\nSMSC_WARN(pdata, rx_err,\r\n"Discarding packet with error bit set");\r\nsmsc911x_rx_fastforward(pdata, pktwords);\r\ndev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb = netdev_alloc_skb(dev, pktwords << 2);\r\nif (unlikely(!skb)) {\r\nSMSC_WARN(pdata, rx_err,\r\n"Unable to allocate skb for rx packet");\r\nsmsc911x_rx_fastforward(pdata, pktwords);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\npdata->ops->rx_readfifo(pdata,\r\n(unsigned int *)skb->data, pktwords);\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nskb_put(skb, pktlength - 4);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb_checksum_none_assert(skb);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += (pktlength - 4);\r\n}\r\nreturn npackets;\r\n}\r\nstatic unsigned int smsc911x_hash(char addr[ETH_ALEN])\r\n{\r\nreturn (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;\r\n}\r\nstatic void smsc911x_rx_multicast_update(struct smsc911x_data *pdata)\r\n{\r\nunsigned int mac_cr;\r\nSMSC_ASSERT_MAC_LOCK(pdata);\r\nmac_cr = smsc911x_mac_read(pdata, MAC_CR);\r\nmac_cr |= pdata->set_bits_mask;\r\nmac_cr &= ~(pdata->clear_bits_mask);\r\nsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\r\nsmsc911x_mac_write(pdata, HASHH, pdata->hashhi);\r\nsmsc911x_mac_write(pdata, HASHL, pdata->hashlo);\r\nSMSC_TRACE(pdata, hw, "maccr 0x%08X, HASHH 0x%08X, HASHL 0x%08X",\r\nmac_cr, pdata->hashhi, pdata->hashlo);\r\n}\r\nstatic void smsc911x_rx_multicast_update_workaround(struct smsc911x_data *pdata)\r\n{\r\nunsigned int mac_cr;\r\nspin_lock(&pdata->mac_lock);\r\nif (smsc911x_mac_read(pdata, MAC_CR) & MAC_CR_RXEN_)\r\nSMSC_WARN(pdata, drv, "Rx not stopped");\r\nsmsc911x_rx_multicast_update(pdata);\r\nmac_cr = smsc911x_mac_read(pdata, MAC_CR);\r\nmac_cr |= MAC_CR_RXEN_;\r\nsmsc911x_mac_write(pdata, MAC_CR, mac_cr);\r\npdata->multicast_update_pending = 0;\r\nspin_unlock(&pdata->mac_lock);\r\n}\r\nstatic int smsc911x_phy_general_power_up(struct smsc911x_data *pdata)\r\n{\r\nstruct net_device *ndev = pdata->dev;\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nint rc = 0;\r\nif (!phy_dev)\r\nreturn rc;\r\nrc = phy_read(phy_dev, MII_BMCR);\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed reading PHY control reg");\r\nreturn rc;\r\n}\r\nif (rc & BMCR_PDOWN) {\r\nrc = phy_write(phy_dev, MII_BMCR, rc & ~BMCR_PDOWN);\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed writing PHY control reg");\r\nreturn rc;\r\n}\r\nusleep_range(1000, 1500);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc911x_phy_disable_energy_detect(struct smsc911x_data *pdata)\r\n{\r\nstruct net_device *ndev = pdata->dev;\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nint rc = 0;\r\nif (!phy_dev)\r\nreturn rc;\r\nrc = phy_read(phy_dev, MII_LAN83C185_CTRL_STATUS);\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed reading PHY control reg");\r\nreturn rc;\r\n}\r\nif (rc & MII_LAN83C185_EDPWRDOWN) {\r\nrc = phy_write(phy_dev, MII_LAN83C185_CTRL_STATUS,\r\nrc & (~MII_LAN83C185_EDPWRDOWN));\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed writing PHY control reg");\r\nreturn rc;\r\n}\r\nmdelay(2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc911x_phy_enable_energy_detect(struct smsc911x_data *pdata)\r\n{\r\nstruct net_device *ndev = pdata->dev;\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nint rc = 0;\r\nif (!phy_dev)\r\nreturn rc;\r\nrc = phy_read(phy_dev, MII_LAN83C185_CTRL_STATUS);\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed reading PHY control reg");\r\nreturn rc;\r\n}\r\nif (!(rc & MII_LAN83C185_EDPWRDOWN)) {\r\nrc = phy_write(phy_dev, MII_LAN83C185_CTRL_STATUS,\r\nrc | MII_LAN83C185_EDPWRDOWN);\r\nif (rc < 0) {\r\nSMSC_WARN(pdata, drv, "Failed writing PHY control reg");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc911x_soft_reset(struct smsc911x_data *pdata)\r\n{\r\nunsigned int timeout;\r\nunsigned int temp;\r\nint ret;\r\nret = smsc911x_phy_general_power_up(pdata);\r\nif (ret) {\r\nSMSC_WARN(pdata, drv, "Failed to power-up the PHY chip");\r\nreturn ret;\r\n}\r\nif (pdata->generation == 4) {\r\nret = smsc911x_phy_disable_energy_detect(pdata);\r\nif (ret) {\r\nSMSC_WARN(pdata, drv, "Failed to wakeup the PHY chip");\r\nreturn ret;\r\n}\r\n}\r\nsmsc911x_reg_write(pdata, HW_CFG, HW_CFG_SRST_);\r\ntimeout = 10;\r\ndo {\r\nudelay(10);\r\ntemp = smsc911x_reg_read(pdata, HW_CFG);\r\n} while ((--timeout) && (temp & HW_CFG_SRST_));\r\nif (unlikely(temp & HW_CFG_SRST_)) {\r\nSMSC_WARN(pdata, drv, "Failed to complete reset");\r\nreturn -EIO;\r\n}\r\nif (pdata->generation == 4) {\r\nret = smsc911x_phy_enable_energy_detect(pdata);\r\nif (ret) {\r\nSMSC_WARN(pdata, drv, "Failed to wakeup the PHY chip");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsmsc911x_set_hw_mac_address(struct smsc911x_data *pdata, u8 dev_addr[6])\r\n{\r\nu32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];\r\nu32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\r\n(dev_addr[1] << 8) | dev_addr[0];\r\nSMSC_ASSERT_MAC_LOCK(pdata);\r\nsmsc911x_mac_write(pdata, ADDRH, mac_high16);\r\nsmsc911x_mac_write(pdata, ADDRL, mac_low32);\r\n}\r\nstatic void smsc911x_disable_irq_chip(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nsmsc911x_reg_write(pdata, INT_EN, 0);\r\nsmsc911x_reg_write(pdata, INT_STS, 0xFFFFFFFF);\r\n}\r\nstatic irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nu32 intsts = smsc911x_reg_read(pdata, INT_STS);\r\nu32 inten = smsc911x_reg_read(pdata, INT_EN);\r\nint serviced = IRQ_NONE;\r\nu32 temp;\r\nif (unlikely(intsts & inten & INT_STS_SW_INT_)) {\r\ntemp = smsc911x_reg_read(pdata, INT_EN);\r\ntemp &= (~INT_EN_SW_INT_EN_);\r\nsmsc911x_reg_write(pdata, INT_EN, temp);\r\nsmsc911x_reg_write(pdata, INT_STS, INT_STS_SW_INT_);\r\npdata->software_irq_signal = 1;\r\nsmp_wmb();\r\nserviced = IRQ_HANDLED;\r\n}\r\nif (unlikely(intsts & inten & INT_STS_RXSTOP_INT_)) {\r\nSMSC_TRACE(pdata, intr, "RX Stop interrupt");\r\nsmsc911x_reg_write(pdata, INT_STS, INT_STS_RXSTOP_INT_);\r\nif (pdata->multicast_update_pending)\r\nsmsc911x_rx_multicast_update_workaround(pdata);\r\nserviced = IRQ_HANDLED;\r\n}\r\nif (intsts & inten & INT_STS_TDFA_) {\r\ntemp = smsc911x_reg_read(pdata, FIFO_INT);\r\ntemp |= FIFO_INT_TX_AVAIL_LEVEL_;\r\nsmsc911x_reg_write(pdata, FIFO_INT, temp);\r\nsmsc911x_reg_write(pdata, INT_STS, INT_STS_TDFA_);\r\nnetif_wake_queue(dev);\r\nserviced = IRQ_HANDLED;\r\n}\r\nif (unlikely(intsts & inten & INT_STS_RXE_)) {\r\nSMSC_TRACE(pdata, intr, "RX Error interrupt");\r\nsmsc911x_reg_write(pdata, INT_STS, INT_STS_RXE_);\r\nserviced = IRQ_HANDLED;\r\n}\r\nif (likely(intsts & inten & INT_STS_RSFL_)) {\r\nif (likely(napi_schedule_prep(&pdata->napi))) {\r\ntemp = smsc911x_reg_read(pdata, INT_EN);\r\ntemp &= (~INT_EN_RSFL_EN_);\r\nsmsc911x_reg_write(pdata, INT_EN, temp);\r\n__napi_schedule(&pdata->napi);\r\n} else {\r\nSMSC_WARN(pdata, rx_err, "napi_schedule_prep failed");\r\n}\r\nserviced = IRQ_HANDLED;\r\n}\r\nreturn serviced;\r\n}\r\nstatic int smsc911x_open(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned int timeout;\r\nunsigned int temp;\r\nunsigned int intcfg;\r\nint retval;\r\nint irq_flags;\r\nif (!dev->phydev) {\r\nretval = smsc911x_mii_probe(dev);\r\nif (retval < 0) {\r\nSMSC_WARN(pdata, probe, "Error starting phy");\r\ngoto out;\r\n}\r\n}\r\nretval = smsc911x_soft_reset(pdata);\r\nif (retval) {\r\nSMSC_WARN(pdata, hw, "soft reset failed");\r\ngoto mii_free_out;\r\n}\r\nsmsc911x_reg_write(pdata, HW_CFG, 0x00050000);\r\nsmsc911x_reg_write(pdata, AFC_CFG, 0x006E3740);\r\nspin_lock_irq(&pdata->mac_lock);\r\nsmsc911x_mac_write(pdata, VLAN1, ETH_P_8021Q);\r\nspin_unlock_irq(&pdata->mac_lock);\r\ntimeout = 50;\r\nwhile ((smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) &&\r\n--timeout) {\r\nudelay(10);\r\n}\r\nif (unlikely(timeout == 0))\r\nSMSC_WARN(pdata, ifup,\r\n"Timed out waiting for EEPROM busy bit to clear");\r\nsmsc911x_reg_write(pdata, GPIO_CFG, 0x70070000);\r\nspin_lock_irq(&pdata->mac_lock);\r\nsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\r\nspin_unlock_irq(&pdata->mac_lock);\r\nsmsc911x_disable_irq_chip(dev);\r\nintcfg = ((10 << 24) | INT_CFG_IRQ_EN_);\r\nif (pdata->config.irq_polarity) {\r\nSMSC_TRACE(pdata, ifup, "irq polarity: active high");\r\nintcfg |= INT_CFG_IRQ_POL_;\r\n} else {\r\nSMSC_TRACE(pdata, ifup, "irq polarity: active low");\r\n}\r\nif (pdata->config.irq_type) {\r\nSMSC_TRACE(pdata, ifup, "irq type: push-pull");\r\nintcfg |= INT_CFG_IRQ_TYPE_;\r\n} else {\r\nSMSC_TRACE(pdata, ifup, "irq type: open drain");\r\n}\r\nsmsc911x_reg_write(pdata, INT_CFG, intcfg);\r\nSMSC_TRACE(pdata, ifup, "Testing irq handler using IRQ %d", dev->irq);\r\npdata->software_irq_signal = 0;\r\nsmp_wmb();\r\nirq_flags = irq_get_trigger_type(dev->irq);\r\nretval = request_irq(dev->irq, smsc911x_irqhandler,\r\nirq_flags | IRQF_SHARED, dev->name, dev);\r\nif (retval) {\r\nSMSC_WARN(pdata, probe,\r\n"Unable to claim requested irq: %d", dev->irq);\r\ngoto mii_free_out;\r\n}\r\ntemp = smsc911x_reg_read(pdata, INT_EN);\r\ntemp |= INT_EN_SW_INT_EN_;\r\nsmsc911x_reg_write(pdata, INT_EN, temp);\r\ntimeout = 1000;\r\nwhile (timeout--) {\r\nif (pdata->software_irq_signal)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!pdata->software_irq_signal) {\r\nnetdev_warn(dev, "ISR failed signaling test (IRQ %d)\n",\r\ndev->irq);\r\nretval = -ENODEV;\r\ngoto irq_stop_out;\r\n}\r\nSMSC_TRACE(pdata, ifup, "IRQ handler passed test using IRQ %d",\r\ndev->irq);\r\nnetdev_info(dev, "SMSC911x/921x identified at %#08lx, IRQ: %d\n",\r\n(unsigned long)pdata->ioaddr, dev->irq);\r\npdata->last_duplex = -1;\r\npdata->last_carrier = -1;\r\nphy_start(dev->phydev);\r\ntemp = smsc911x_reg_read(pdata, HW_CFG);\r\ntemp &= (HW_CFG_TX_FIF_SZ_|0x00000FFF);\r\ntemp |= HW_CFG_SF_;\r\nsmsc911x_reg_write(pdata, HW_CFG, temp);\r\ntemp = smsc911x_reg_read(pdata, FIFO_INT);\r\ntemp |= FIFO_INT_TX_AVAIL_LEVEL_;\r\ntemp &= ~(FIFO_INT_RX_STS_LEVEL_);\r\nsmsc911x_reg_write(pdata, FIFO_INT, temp);\r\nsmsc911x_reg_write(pdata, RX_CFG, (NET_IP_ALIGN << 8));\r\nnapi_enable(&pdata->napi);\r\ntemp = smsc911x_reg_read(pdata, INT_EN);\r\ntemp |= (INT_EN_TDFA_EN_ | INT_EN_RSFL_EN_ | INT_EN_RXSTOP_INT_EN_);\r\nsmsc911x_reg_write(pdata, INT_EN, temp);\r\nspin_lock_irq(&pdata->mac_lock);\r\ntemp = smsc911x_mac_read(pdata, MAC_CR);\r\ntemp |= (MAC_CR_TXEN_ | MAC_CR_RXEN_ | MAC_CR_HBDIS_);\r\nsmsc911x_mac_write(pdata, MAC_CR, temp);\r\nspin_unlock_irq(&pdata->mac_lock);\r\nsmsc911x_reg_write(pdata, TX_CFG, TX_CFG_TX_ON_);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nirq_stop_out:\r\nfree_irq(dev->irq, dev);\r\nmii_free_out:\r\nphy_disconnect(dev->phydev);\r\ndev->phydev = NULL;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int smsc911x_stop(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned int temp;\r\ntemp = smsc911x_reg_read(pdata, INT_CFG);\r\ntemp &= ~INT_CFG_IRQ_EN_;\r\nsmsc911x_reg_write(pdata, INT_CFG, temp);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&pdata->napi);\r\ndev->stats.rx_dropped += smsc911x_reg_read(pdata, RX_DROP);\r\nsmsc911x_tx_update_txcounters(dev);\r\nfree_irq(dev->irq, dev);\r\nif (dev->phydev) {\r\nphy_stop(dev->phydev);\r\nphy_disconnect(dev->phydev);\r\ndev->phydev = NULL;\r\n}\r\nnetif_carrier_off(dev);\r\nSMSC_TRACE(pdata, ifdown, "Interface stopped");\r\nreturn 0;\r\n}\r\nstatic int smsc911x_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned int freespace;\r\nunsigned int tx_cmd_a;\r\nunsigned int tx_cmd_b;\r\nunsigned int temp;\r\nu32 wrsz;\r\nulong bufp;\r\nfreespace = smsc911x_reg_read(pdata, TX_FIFO_INF) & TX_FIFO_INF_TDFREE_;\r\nif (unlikely(freespace < TX_FIFO_LOW_THRESHOLD))\r\nSMSC_WARN(pdata, tx_err,\r\n"Tx data fifo low, space available: %d", freespace);\r\ntx_cmd_a = (u32)((ulong)skb->data & 0x03) << 16;\r\ntx_cmd_a |= TX_CMD_A_FIRST_SEG_ | TX_CMD_A_LAST_SEG_;\r\ntx_cmd_a |= (unsigned int)skb->len;\r\ntx_cmd_b = ((unsigned int)skb->len) << 16;\r\ntx_cmd_b |= (unsigned int)skb->len;\r\nsmsc911x_reg_write(pdata, TX_DATA_FIFO, tx_cmd_a);\r\nsmsc911x_reg_write(pdata, TX_DATA_FIFO, tx_cmd_b);\r\nbufp = (ulong)skb->data & (~0x3);\r\nwrsz = (u32)skb->len + 3;\r\nwrsz += (u32)((ulong)skb->data & 0x3);\r\nwrsz >>= 2;\r\npdata->ops->tx_writefifo(pdata, (unsigned int *)bufp, wrsz);\r\nfreespace -= (skb->len + 32);\r\nskb_tx_timestamp(skb);\r\ndev_consume_skb_any(skb);\r\nif (unlikely(smsc911x_tx_get_txstatcount(pdata) >= 30))\r\nsmsc911x_tx_update_txcounters(dev);\r\nif (freespace < TX_FIFO_LOW_THRESHOLD) {\r\nnetif_stop_queue(dev);\r\ntemp = smsc911x_reg_read(pdata, FIFO_INT);\r\ntemp &= 0x00FFFFFF;\r\ntemp |= 0x32000000;\r\nsmsc911x_reg_write(pdata, FIFO_INT, temp);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct net_device_stats *smsc911x_get_stats(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nsmsc911x_tx_update_txcounters(dev);\r\ndev->stats.rx_dropped += smsc911x_reg_read(pdata, RX_DROP);\r\nreturn &dev->stats;\r\n}\r\nstatic void smsc911x_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned long flags;\r\nif (dev->flags & IFF_PROMISC) {\r\npdata->set_bits_mask = MAC_CR_PRMS_;\r\npdata->clear_bits_mask = (MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\r\npdata->hashhi = 0;\r\npdata->hashlo = 0;\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\npdata->set_bits_mask = MAC_CR_MCPAS_;\r\npdata->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_HPFILT_);\r\npdata->hashhi = 0;\r\npdata->hashlo = 0;\r\n} else if (!netdev_mc_empty(dev)) {\r\nunsigned int hash_high = 0;\r\nunsigned int hash_low = 0;\r\nstruct netdev_hw_addr *ha;\r\npdata->set_bits_mask = MAC_CR_HPFILT_;\r\npdata->clear_bits_mask = (MAC_CR_PRMS_ | MAC_CR_MCPAS_);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunsigned int bitnum = smsc911x_hash(ha->addr);\r\nunsigned int mask = 0x01 << (bitnum & 0x1F);\r\nif (bitnum & 0x20)\r\nhash_high |= mask;\r\nelse\r\nhash_low |= mask;\r\n}\r\npdata->hashhi = hash_high;\r\npdata->hashlo = hash_low;\r\n} else {\r\npdata->set_bits_mask = 0;\r\npdata->clear_bits_mask =\r\n(MAC_CR_PRMS_ | MAC_CR_MCPAS_ | MAC_CR_HPFILT_);\r\npdata->hashhi = 0;\r\npdata->hashlo = 0;\r\n}\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\nif (pdata->generation <= 1) {\r\nif (!pdata->multicast_update_pending) {\r\nunsigned int temp;\r\nSMSC_TRACE(pdata, hw, "scheduling mcast update");\r\npdata->multicast_update_pending = 1;\r\ntemp = smsc911x_mac_read(pdata, MAC_CR);\r\ntemp &= ~(MAC_CR_RXEN_);\r\nsmsc911x_mac_write(pdata, MAC_CR, temp);\r\n} else {\r\n}\r\n} else {\r\nsmsc911x_rx_multicast_update(pdata);\r\n}\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\n}\r\nstatic void smsc911x_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nsmsc911x_irqhandler(0, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int smsc911x_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (pdata->generation <= 1 && netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nspin_lock_irq(&pdata->mac_lock);\r\nsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\r\nspin_unlock_irq(&pdata->mac_lock);\r\nnetdev_info(dev, "MAC Address: %pM\n", dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int smsc911x_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nif (!netif_running(dev) || !dev->phydev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(dev->phydev, ifr, cmd);\r\n}\r\nstatic void smsc911x_ethtool_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, SMSC_CHIPNAME, sizeof(info->driver));\r\nstrlcpy(info->version, SMSC_DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, dev_name(dev->dev.parent),\r\nsizeof(info->bus_info));\r\n}\r\nstatic u32 smsc911x_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nreturn pdata->msg_enable;\r\n}\r\nstatic void smsc911x_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\npdata->msg_enable = level;\r\n}\r\nstatic int smsc911x_ethtool_getregslen(struct net_device *dev)\r\n{\r\nreturn (((E2P_DATA - ID_REV) / 4 + 1) + (WUCSR - MAC_CR) + 1 + 32) *\r\nsizeof(u32);\r\n}\r\nstatic void\r\nsmsc911x_ethtool_getregs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *buf)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nstruct phy_device *phy_dev = dev->phydev;\r\nunsigned long flags;\r\nunsigned int i;\r\nunsigned int j = 0;\r\nu32 *data = buf;\r\nregs->version = pdata->idrev;\r\nfor (i = ID_REV; i <= E2P_DATA; i += (sizeof(u32)))\r\ndata[j++] = smsc911x_reg_read(pdata, i);\r\nfor (i = MAC_CR; i <= WUCSR; i++) {\r\nspin_lock_irqsave(&pdata->mac_lock, flags);\r\ndata[j++] = smsc911x_mac_read(pdata, i);\r\nspin_unlock_irqrestore(&pdata->mac_lock, flags);\r\n}\r\nfor (i = 0; i <= 31; i++)\r\ndata[j++] = smsc911x_mii_read(phy_dev->mdio.bus,\r\nphy_dev->mdio.addr, i);\r\n}\r\nstatic void smsc911x_eeprom_enable_access(struct smsc911x_data *pdata)\r\n{\r\nunsigned int temp = smsc911x_reg_read(pdata, GPIO_CFG);\r\ntemp &= ~GPIO_CFG_EEPR_EN_;\r\nsmsc911x_reg_write(pdata, GPIO_CFG, temp);\r\nmsleep(1);\r\n}\r\nstatic int smsc911x_eeprom_send_cmd(struct smsc911x_data *pdata, u32 op)\r\n{\r\nint timeout = 100;\r\nu32 e2cmd;\r\nSMSC_TRACE(pdata, drv, "op 0x%08x", op);\r\nif (smsc911x_reg_read(pdata, E2P_CMD) & E2P_CMD_EPC_BUSY_) {\r\nSMSC_WARN(pdata, drv, "Busy at start");\r\nreturn -EBUSY;\r\n}\r\ne2cmd = op | E2P_CMD_EPC_BUSY_;\r\nsmsc911x_reg_write(pdata, E2P_CMD, e2cmd);\r\ndo {\r\nmsleep(1);\r\ne2cmd = smsc911x_reg_read(pdata, E2P_CMD);\r\n} while ((e2cmd & E2P_CMD_EPC_BUSY_) && (--timeout));\r\nif (!timeout) {\r\nSMSC_TRACE(pdata, drv, "TIMED OUT");\r\nreturn -EAGAIN;\r\n}\r\nif (e2cmd & E2P_CMD_EPC_TIMEOUT_) {\r\nSMSC_TRACE(pdata, drv, "Error occurred during eeprom operation");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsc911x_eeprom_read_location(struct smsc911x_data *pdata,\r\nu8 address, u8 *data)\r\n{\r\nu32 op = E2P_CMD_EPC_CMD_READ_ | address;\r\nint ret;\r\nSMSC_TRACE(pdata, drv, "address 0x%x", address);\r\nret = smsc911x_eeprom_send_cmd(pdata, op);\r\nif (!ret)\r\ndata[address] = smsc911x_reg_read(pdata, E2P_DATA);\r\nreturn ret;\r\n}\r\nstatic int smsc911x_eeprom_write_location(struct smsc911x_data *pdata,\r\nu8 address, u8 data)\r\n{\r\nu32 op = E2P_CMD_EPC_CMD_ERASE_ | address;\r\nu32 temp;\r\nint ret;\r\nSMSC_TRACE(pdata, drv, "address 0x%x, data 0x%x", address, data);\r\nret = smsc911x_eeprom_send_cmd(pdata, op);\r\nif (!ret) {\r\nop = E2P_CMD_EPC_CMD_WRITE_ | address;\r\nsmsc911x_reg_write(pdata, E2P_DATA, (u32)data);\r\ntemp = smsc911x_reg_read(pdata, BYTE_TEST);\r\nret = smsc911x_eeprom_send_cmd(pdata, op);\r\n}\r\nreturn ret;\r\n}\r\nstatic int smsc911x_ethtool_get_eeprom_len(struct net_device *dev)\r\n{\r\nreturn SMSC911X_EEPROM_SIZE;\r\n}\r\nstatic int smsc911x_ethtool_get_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nu8 eeprom_data[SMSC911X_EEPROM_SIZE];\r\nint len;\r\nint i;\r\nsmsc911x_eeprom_enable_access(pdata);\r\nlen = min(eeprom->len, SMSC911X_EEPROM_SIZE);\r\nfor (i = 0; i < len; i++) {\r\nint ret = smsc911x_eeprom_read_location(pdata, i, eeprom_data);\r\nif (ret < 0) {\r\neeprom->len = 0;\r\nreturn ret;\r\n}\r\n}\r\nmemcpy(data, &eeprom_data[eeprom->offset], len);\r\neeprom->len = len;\r\nreturn 0;\r\n}\r\nstatic int smsc911x_ethtool_set_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *eeprom, u8 *data)\r\n{\r\nint ret;\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nsmsc911x_eeprom_enable_access(pdata);\r\nsmsc911x_eeprom_send_cmd(pdata, E2P_CMD_EPC_CMD_EWEN_);\r\nret = smsc911x_eeprom_write_location(pdata, eeprom->offset, *data);\r\nsmsc911x_eeprom_send_cmd(pdata, E2P_CMD_EPC_CMD_EWDS_);\r\neeprom->len = 1;\r\nreturn ret;\r\n}\r\nstatic void smsc911x_read_mac_address(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nu32 mac_high16 = smsc911x_mac_read(pdata, ADDRH);\r\nu32 mac_low32 = smsc911x_mac_read(pdata, ADDRL);\r\ndev->dev_addr[0] = (u8)(mac_low32);\r\ndev->dev_addr[1] = (u8)(mac_low32 >> 8);\r\ndev->dev_addr[2] = (u8)(mac_low32 >> 16);\r\ndev->dev_addr[3] = (u8)(mac_low32 >> 24);\r\ndev->dev_addr[4] = (u8)(mac_high16);\r\ndev->dev_addr[5] = (u8)(mac_high16 >> 8);\r\n}\r\nstatic int smsc911x_init(struct net_device *dev)\r\n{\r\nstruct smsc911x_data *pdata = netdev_priv(dev);\r\nunsigned int byte_test, mask;\r\nunsigned int to = 100;\r\nSMSC_TRACE(pdata, probe, "Driver Parameters:");\r\nSMSC_TRACE(pdata, probe, "LAN base: 0x%08lX",\r\n(unsigned long)pdata->ioaddr);\r\nSMSC_TRACE(pdata, probe, "IRQ: %d", dev->irq);\r\nSMSC_TRACE(pdata, probe, "PHY will be autodetected.");\r\nspin_lock_init(&pdata->dev_lock);\r\nspin_lock_init(&pdata->mac_lock);\r\nif (pdata->ioaddr == NULL) {\r\nSMSC_WARN(pdata, probe, "pdata->ioaddr: 0x00000000");\r\nreturn -ENODEV;\r\n}\r\nmask = PMT_CTRL_READY_ | swahw32(PMT_CTRL_READY_);\r\nwhile (!(smsc911x_reg_read(pdata, PMT_CTRL) & mask) && --to)\r\nudelay(1000);\r\nif (to == 0) {\r\nnetdev_err(dev, "Device not READY in 100ms aborting\n");\r\nreturn -ENODEV;\r\n}\r\nbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\r\nSMSC_TRACE(pdata, probe, "BYTE_TEST: 0x%08X", byte_test);\r\nif (byte_test == 0x43218765) {\r\nSMSC_TRACE(pdata, probe, "BYTE_TEST looks swapped, "\r\n"applying WORD_SWAP");\r\nsmsc911x_reg_write(pdata, WORD_SWAP, 0xffffffff);\r\nbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\r\nbyte_test = smsc911x_reg_read(pdata, BYTE_TEST);\r\n}\r\nif (byte_test != 0x87654321) {\r\nSMSC_WARN(pdata, drv, "BYTE_TEST: 0x%08X", byte_test);\r\nif (((byte_test >> 16) & 0xFFFF) == (byte_test & 0xFFFF)) {\r\nSMSC_WARN(pdata, probe,\r\n"top 16 bits equal to bottom 16 bits");\r\nSMSC_TRACE(pdata, probe,\r\n"This may mean the chip is set "\r\n"for 32 bit while the bus is reading 16 bit");\r\n}\r\nreturn -ENODEV;\r\n}\r\npdata->generation = 0;\r\npdata->idrev = smsc911x_reg_read(pdata, ID_REV);\r\nswitch (pdata->idrev & 0xFFFF0000) {\r\ncase 0x01180000:\r\ncase 0x01170000:\r\ncase 0x01160000:\r\ncase 0x01150000:\r\ncase 0x218A0000:\r\npdata->generation = pdata->idrev & 0x0000FFFF;\r\nbreak;\r\ncase 0x118A0000:\r\ncase 0x117A0000:\r\ncase 0x116A0000:\r\ncase 0x115A0000:\r\npdata->generation = 3;\r\nbreak;\r\ncase 0x92100000:\r\ncase 0x92110000:\r\ncase 0x92200000:\r\ncase 0x92210000:\r\npdata->generation = 4;\r\nbreak;\r\ndefault:\r\nSMSC_WARN(pdata, probe, "LAN911x not identified, idrev: 0x%08X",\r\npdata->idrev);\r\nreturn -ENODEV;\r\n}\r\nSMSC_TRACE(pdata, probe,\r\n"LAN911x identified, idrev: 0x%08X, generation: %d",\r\npdata->idrev, pdata->generation);\r\nif (pdata->generation == 0)\r\nSMSC_WARN(pdata, probe,\r\n"This driver is not intended for this chip revision");\r\nif (pdata->config.flags & SMSC911X_SAVE_MAC_ADDRESS) {\r\nspin_lock_irq(&pdata->mac_lock);\r\nsmsc911x_read_mac_address(dev);\r\nspin_unlock_irq(&pdata->mac_lock);\r\n}\r\nif (smsc911x_phy_reset(pdata) || smsc911x_soft_reset(pdata))\r\nreturn -ENODEV;\r\ndev->flags |= IFF_MULTICAST;\r\nnetif_napi_add(dev, &pdata->napi, smsc911x_poll, SMSC_NAPI_WEIGHT);\r\ndev->netdev_ops = &smsc911x_netdev_ops;\r\ndev->ethtool_ops = &smsc911x_ethtool_ops;\r\nreturn 0;\r\n}\r\nstatic int smsc911x_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct smsc911x_data *pdata;\r\nstruct resource *res;\r\ndev = platform_get_drvdata(pdev);\r\nBUG_ON(!dev);\r\npdata = netdev_priv(dev);\r\nBUG_ON(!pdata);\r\nBUG_ON(!pdata->ioaddr);\r\nWARN_ON(dev->phydev);\r\nSMSC_TRACE(pdata, ifdown, "Stopping driver");\r\nmdiobus_unregister(pdata->mii_bus);\r\nmdiobus_free(pdata->mii_bus);\r\nunregister_netdev(dev);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"smsc911x-memory");\r\nif (!res)\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\niounmap(pdata->ioaddr);\r\n(void)smsc911x_disable_resources(pdev);\r\nsmsc911x_free_resources(pdev);\r\nfree_netdev(dev);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int smsc911x_probe_config(struct smsc911x_platform_config *config,\r\nstruct device *dev)\r\n{\r\nint phy_interface;\r\nu32 width = 0;\r\nint err;\r\nphy_interface = device_get_phy_mode(dev);\r\nif (phy_interface < 0)\r\nphy_interface = PHY_INTERFACE_MODE_NA;\r\nconfig->phy_interface = phy_interface;\r\ndevice_get_mac_address(dev, config->mac, ETH_ALEN);\r\nerr = device_property_read_u32(dev, "reg-io-width", &width);\r\nif (err == -ENXIO)\r\nreturn err;\r\nif (!err && width == 4)\r\nconfig->flags |= SMSC911X_USE_32BIT;\r\nelse\r\nconfig->flags |= SMSC911X_USE_16BIT;\r\ndevice_property_read_u32(dev, "reg-shift", &config->shift);\r\nif (device_property_present(dev, "smsc,irq-active-high"))\r\nconfig->irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_HIGH;\r\nif (device_property_present(dev, "smsc,irq-push-pull"))\r\nconfig->irq_type = SMSC911X_IRQ_TYPE_PUSH_PULL;\r\nif (device_property_present(dev, "smsc,force-internal-phy"))\r\nconfig->flags |= SMSC911X_FORCE_INTERNAL_PHY;\r\nif (device_property_present(dev, "smsc,force-external-phy"))\r\nconfig->flags |= SMSC911X_FORCE_EXTERNAL_PHY;\r\nif (device_property_present(dev, "smsc,save-mac-address"))\r\nconfig->flags |= SMSC911X_SAVE_MAC_ADDRESS;\r\nreturn 0;\r\n}\r\nstatic int smsc911x_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct smsc911x_data *pdata;\r\nstruct smsc911x_platform_config *config = dev_get_platdata(&pdev->dev);\r\nstruct resource *res;\r\nint res_size, irq;\r\nint retval;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"smsc911x-memory");\r\nif (!res)\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\npr_warn("Could not allocate resource\n");\r\nretval = -ENODEV;\r\ngoto out_0;\r\n}\r\nres_size = resource_size(res);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq == -EPROBE_DEFER) {\r\nretval = -EPROBE_DEFER;\r\ngoto out_0;\r\n} else if (irq <= 0) {\r\npr_warn("Could not allocate irq resource\n");\r\nretval = -ENODEV;\r\ngoto out_0;\r\n}\r\nif (!request_mem_region(res->start, res_size, SMSC_CHIPNAME)) {\r\nretval = -EBUSY;\r\ngoto out_0;\r\n}\r\ndev = alloc_etherdev(sizeof(struct smsc911x_data));\r\nif (!dev) {\r\nretval = -ENOMEM;\r\ngoto out_release_io_1;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npdata = netdev_priv(dev);\r\ndev->irq = irq;\r\npdata->ioaddr = ioremap_nocache(res->start, res_size);\r\npdata->dev = dev;\r\npdata->msg_enable = ((1 << debug) - 1);\r\nplatform_set_drvdata(pdev, dev);\r\nretval = smsc911x_request_resources(pdev);\r\nif (retval)\r\ngoto out_request_resources_fail;\r\nretval = smsc911x_enable_resources(pdev);\r\nif (retval)\r\ngoto out_enable_resources_fail;\r\nif (pdata->ioaddr == NULL) {\r\nSMSC_WARN(pdata, probe, "Error smsc911x base address invalid");\r\nretval = -ENOMEM;\r\ngoto out_disable_resources;\r\n}\r\nretval = smsc911x_probe_config(&pdata->config, &pdev->dev);\r\nif (retval && config) {\r\nmemcpy(&pdata->config, config, sizeof(pdata->config));\r\nretval = 0;\r\n}\r\nif (retval) {\r\nSMSC_WARN(pdata, probe, "Error smsc911x config not found");\r\ngoto out_disable_resources;\r\n}\r\npdata->ops = &standard_smsc911x_ops;\r\nif (pdata->config.shift)\r\npdata->ops = &shifted_smsc911x_ops;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nretval = smsc911x_init(dev);\r\nif (retval < 0)\r\ngoto out_disable_resources;\r\nnetif_carrier_off(dev);\r\nretval = smsc911x_mii_init(pdev, dev);\r\nif (retval) {\r\nSMSC_WARN(pdata, probe, "Error %i initialising mii", retval);\r\ngoto out_disable_resources;\r\n}\r\nretval = register_netdev(dev);\r\nif (retval) {\r\nSMSC_WARN(pdata, probe, "Error %i registering device", retval);\r\ngoto out_disable_resources;\r\n} else {\r\nSMSC_TRACE(pdata, probe,\r\n"Network interface: \"%s\"", dev->name);\r\n}\r\nspin_lock_irq(&pdata->mac_lock);\r\nif (is_valid_ether_addr(dev->dev_addr)) {\r\nsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\r\nSMSC_TRACE(pdata, probe,\r\n"MAC Address is specified by configuration");\r\n} else if (is_valid_ether_addr(pdata->config.mac)) {\r\nmemcpy(dev->dev_addr, pdata->config.mac, ETH_ALEN);\r\nSMSC_TRACE(pdata, probe,\r\n"MAC Address specified by platform data");\r\n} else {\r\nsmsc_get_mac(dev);\r\nif (is_valid_ether_addr(dev->dev_addr)) {\r\nSMSC_TRACE(pdata, probe,\r\n"Mac Address is read from LAN911x EEPROM");\r\n} else {\r\neth_hw_addr_random(dev);\r\nsmsc911x_set_hw_mac_address(pdata, dev->dev_addr);\r\nSMSC_TRACE(pdata, probe,\r\n"MAC Address is set to eth_random_addr");\r\n}\r\n}\r\nspin_unlock_irq(&pdata->mac_lock);\r\nnetdev_info(dev, "MAC Address: %pM\n", dev->dev_addr);\r\nreturn 0;\r\nout_disable_resources:\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\n(void)smsc911x_disable_resources(pdev);\r\nout_enable_resources_fail:\r\nsmsc911x_free_resources(pdev);\r\nout_request_resources_fail:\r\niounmap(pdata->ioaddr);\r\nfree_netdev(dev);\r\nout_release_io_1:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout_0:\r\nreturn retval;\r\n}\r\nstatic int smsc911x_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nsmsc911x_reg_write(pdata, PMT_CTRL,\r\nPMT_CTRL_PM_MODE_D1_ | PMT_CTRL_WOL_EN_ |\r\nPMT_CTRL_ED_EN_ | PMT_CTRL_PME_EN_);\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\nreturn 0;\r\n}\r\nstatic int smsc911x_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct smsc911x_data *pdata = netdev_priv(ndev);\r\nunsigned int to = 100;\r\npm_runtime_enable(dev);\r\npm_runtime_resume(dev);\r\nsmsc911x_reg_write(pdata, BYTE_TEST, 0);\r\nwhile (!(smsc911x_reg_read(pdata, PMT_CTRL) & PMT_CTRL_READY_) && --to)\r\nudelay(1000);\r\nreturn (to == 0) ? -EIO : 0;\r\n}\r\nstatic int __init smsc911x_init_module(void)\r\n{\r\nSMSC_INITIALIZE();\r\nreturn platform_driver_register(&smsc911x_driver);\r\n}\r\nstatic void __exit smsc911x_cleanup_module(void)\r\n{\r\nplatform_driver_unregister(&smsc911x_driver);\r\n}
