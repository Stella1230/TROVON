static bool atmel_spi_is_v2(struct atmel_spi *as)\r\n{\r\nreturn as->caps.is_spi2;\r\n}\r\nstatic void cs_activate(struct atmel_spi *as, struct spi_device *spi)\r\n{\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nunsigned active = spi->mode & SPI_CS_HIGH;\r\nu32 mr;\r\nif (atmel_spi_is_v2(as)) {\r\nspi_writel(as, CSR0 + 4 * spi->chip_select, asd->csr);\r\nspi_writel(as, CSR0, asd->csr);\r\nif (as->caps.has_wdrbt) {\r\nspi_writel(as, MR,\r\nSPI_BF(PCS, ~(0x01 << spi->chip_select))\r\n| SPI_BIT(WDRBT)\r\n| SPI_BIT(MODFDIS)\r\n| SPI_BIT(MSTR));\r\n} else {\r\nspi_writel(as, MR,\r\nSPI_BF(PCS, ~(0x01 << spi->chip_select))\r\n| SPI_BIT(MODFDIS)\r\n| SPI_BIT(MSTR));\r\n}\r\nmr = spi_readl(as, MR);\r\nif (as->use_cs_gpios)\r\ngpio_set_value(asd->npcs_pin, active);\r\n} else {\r\nu32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;\r\nint i;\r\nu32 csr;\r\nfor (i = 0; i < spi->master->num_chipselect; i++) {\r\ncsr = spi_readl(as, CSR0 + 4 * i);\r\nif ((csr ^ cpol) & SPI_BIT(CPOL))\r\nspi_writel(as, CSR0 + 4 * i,\r\ncsr ^ SPI_BIT(CPOL));\r\n}\r\nmr = spi_readl(as, MR);\r\nmr = SPI_BFINS(PCS, ~(1 << spi->chip_select), mr);\r\nif (as->use_cs_gpios && spi->chip_select != 0)\r\ngpio_set_value(asd->npcs_pin, active);\r\nspi_writel(as, MR, mr);\r\n}\r\ndev_dbg(&spi->dev, "activate %u%s, mr %08x\n",\r\nasd->npcs_pin, active ? " (high)" : "",\r\nmr);\r\n}\r\nstatic void cs_deactivate(struct atmel_spi *as, struct spi_device *spi)\r\n{\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nunsigned active = spi->mode & SPI_CS_HIGH;\r\nu32 mr;\r\nmr = spi_readl(as, MR);\r\nif (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {\r\nmr = SPI_BFINS(PCS, 0xf, mr);\r\nspi_writel(as, MR, mr);\r\n}\r\ndev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",\r\nasd->npcs_pin, active ? " (low)" : "",\r\nmr);\r\nif (!as->use_cs_gpios)\r\nspi_writel(as, CR, SPI_BIT(LASTXFER));\r\nelse if (atmel_spi_is_v2(as) || spi->chip_select != 0)\r\ngpio_set_value(asd->npcs_pin, !active);\r\n}\r\nstatic void atmel_spi_lock(struct atmel_spi *as) __acquires(&as->lock\r\nstatic void atmel_spi_unlock(struct atmel_spi *as) __releases(&as->lock\r\nstatic inline bool atmel_spi_use_dma(struct atmel_spi *as,\r\nstruct spi_transfer *xfer)\r\n{\r\nreturn as->use_dma && xfer->len >= DMA_MIN_BYTES;\r\n}\r\nstatic bool atmel_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nreturn atmel_spi_use_dma(as, xfer);\r\n}\r\nstatic int atmel_spi_dma_slave_config(struct atmel_spi *as,\r\nstruct dma_slave_config *slave_config,\r\nu8 bits_per_word)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(as->pdev);\r\nint err = 0;\r\nif (bits_per_word > 8) {\r\nslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nslave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\n} else {\r\nslave_config->dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config->src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\n}\r\nslave_config->dst_addr = (dma_addr_t)as->phybase + SPI_TDR;\r\nslave_config->src_addr = (dma_addr_t)as->phybase + SPI_RDR;\r\nslave_config->src_maxburst = 1;\r\nslave_config->dst_maxburst = 1;\r\nslave_config->device_fc = false;\r\nslave_config->direction = DMA_MEM_TO_DEV;\r\nif (dmaengine_slave_config(master->dma_tx, slave_config)) {\r\ndev_err(&as->pdev->dev,\r\n"failed to configure tx dma channel\n");\r\nerr = -EINVAL;\r\n}\r\nslave_config->direction = DMA_DEV_TO_MEM;\r\nif (dmaengine_slave_config(master->dma_rx, slave_config)) {\r\ndev_err(&as->pdev->dev,\r\n"failed to configure rx dma channel\n");\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int atmel_spi_configure_dma(struct spi_master *master,\r\nstruct atmel_spi *as)\r\n{\r\nstruct dma_slave_config slave_config;\r\nstruct device *dev = &as->pdev->dev;\r\nint err;\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nmaster->dma_tx = dma_request_slave_channel_reason(dev, "tx");\r\nif (IS_ERR(master->dma_tx)) {\r\nerr = PTR_ERR(master->dma_tx);\r\nif (err == -EPROBE_DEFER) {\r\ndev_warn(dev, "no DMA channel available at the moment\n");\r\ngoto error_clear;\r\n}\r\ndev_err(dev,\r\n"DMA TX channel not available, SPI unable to use DMA\n");\r\nerr = -EBUSY;\r\ngoto error_clear;\r\n}\r\nmaster->dma_rx = dma_request_slave_channel(dev, "rx");\r\nif (!master->dma_rx) {\r\ndev_err(dev,\r\n"DMA RX channel not available, SPI unable to use DMA\n");\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\nerr = atmel_spi_dma_slave_config(as, &slave_config, 8);\r\nif (err)\r\ngoto error;\r\ndev_info(&as->pdev->dev,\r\n"Using %s (tx) and %s (rx) for DMA transfers\n",\r\ndma_chan_name(master->dma_tx),\r\ndma_chan_name(master->dma_rx));\r\nreturn 0;\r\nerror:\r\nif (master->dma_rx)\r\ndma_release_channel(master->dma_rx);\r\nif (!IS_ERR(master->dma_tx))\r\ndma_release_channel(master->dma_tx);\r\nerror_clear:\r\nmaster->dma_tx = master->dma_rx = NULL;\r\nreturn err;\r\n}\r\nstatic void atmel_spi_stop_dma(struct spi_master *master)\r\n{\r\nif (master->dma_rx)\r\ndmaengine_terminate_all(master->dma_rx);\r\nif (master->dma_tx)\r\ndmaengine_terminate_all(master->dma_tx);\r\n}\r\nstatic void atmel_spi_release_dma(struct spi_master *master)\r\n{\r\nif (master->dma_rx) {\r\ndma_release_channel(master->dma_rx);\r\nmaster->dma_rx = NULL;\r\n}\r\nif (master->dma_tx) {\r\ndma_release_channel(master->dma_tx);\r\nmaster->dma_tx = NULL;\r\n}\r\n}\r\nstatic void dma_callback(void *data)\r\n{\r\nstruct spi_master *master = data;\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\ncomplete(&as->xfer_completion);\r\n}\r\nstatic void atmel_spi_next_xfer_single(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nunsigned long xfer_pos = xfer->len - as->current_remaining_bytes;\r\ndev_vdbg(master->dev.parent, "atmel_spi_next_xfer_pio\n");\r\nspi_readl(as, RDR);\r\nwhile (spi_readl(as, SR) & SPI_BIT(RDRF)) {\r\nspi_readl(as, RDR);\r\ncpu_relax();\r\n}\r\nif (xfer->bits_per_word > 8)\r\nspi_writel(as, TDR, *(u16 *)(xfer->tx_buf + xfer_pos));\r\nelse\r\nspi_writel(as, TDR, *(u8 *)(xfer->tx_buf + xfer_pos));\r\ndev_dbg(master->dev.parent,\r\n" start pio xfer %p: len %u tx %p rx %p bitpw %d\n",\r\nxfer, xfer->len, xfer->tx_buf, xfer->rx_buf,\r\nxfer->bits_per_word);\r\nspi_writel(as, IER, SPI_BIT(RDRF) | SPI_BIT(OVRES));\r\n}\r\nstatic void atmel_spi_next_xfer_fifo(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nu32 current_remaining_data, num_data;\r\nu32 offset = xfer->len - as->current_remaining_bytes;\r\nconst u16 *words = (const u16 *)((u8 *)xfer->tx_buf + offset);\r\nconst u8 *bytes = (const u8 *)((u8 *)xfer->tx_buf + offset);\r\nu16 td0, td1;\r\nu32 fifomr;\r\ndev_vdbg(master->dev.parent, "atmel_spi_next_xfer_fifo\n");\r\ncurrent_remaining_data = ((xfer->bits_per_word > 8) ?\r\n((u32)as->current_remaining_bytes >> 1) :\r\n(u32)as->current_remaining_bytes);\r\nnum_data = min(current_remaining_data, as->fifo_size);\r\nspi_writel(as, CR, SPI_BIT(RXFCLR) | SPI_BIT(TXFCLR));\r\nwhile (spi_readl(as, FLR))\r\ncpu_relax();\r\nfifomr = spi_readl(as, FMR);\r\nspi_writel(as, FMR, SPI_BFINS(RXFTHRES, num_data, fifomr));\r\n(void)spi_readl(as, SR);\r\nwhile (num_data >= 2) {\r\nif (xfer->bits_per_word > 8) {\r\ntd0 = *words++;\r\ntd1 = *words++;\r\n} else {\r\ntd0 = *bytes++;\r\ntd1 = *bytes++;\r\n}\r\nspi_writel(as, TDR, (td1 << 16) | td0);\r\nnum_data -= 2;\r\n}\r\nif (num_data) {\r\nif (xfer->bits_per_word > 8)\r\ntd0 = *words++;\r\nelse\r\ntd0 = *bytes++;\r\nspi_writew(as, TDR, td0);\r\nnum_data--;\r\n}\r\ndev_dbg(master->dev.parent,\r\n" start fifo xfer %p: len %u tx %p rx %p bitpw %d\n",\r\nxfer, xfer->len, xfer->tx_buf, xfer->rx_buf,\r\nxfer->bits_per_word);\r\nspi_writel(as, IER, SPI_BIT(RXFTHF) | SPI_BIT(OVRES));\r\n}\r\nstatic void atmel_spi_next_xfer_pio(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nif (as->fifo_size)\r\natmel_spi_next_xfer_fifo(master, xfer);\r\nelse\r\natmel_spi_next_xfer_single(master, xfer);\r\n}\r\nstatic int atmel_spi_next_xfer_dma_submit(struct spi_master *master,\r\nstruct spi_transfer *xfer,\r\nu32 *plen)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct dma_chan *rxchan = master->dma_rx;\r\nstruct dma_chan *txchan = master->dma_tx;\r\nstruct dma_async_tx_descriptor *rxdesc;\r\nstruct dma_async_tx_descriptor *txdesc;\r\nstruct dma_slave_config slave_config;\r\ndma_cookie_t cookie;\r\ndev_vdbg(master->dev.parent, "atmel_spi_next_xfer_dma_submit\n");\r\nif (!rxchan || !txchan)\r\nreturn -ENODEV;\r\natmel_spi_unlock(as);\r\n*plen = xfer->len;\r\nif (atmel_spi_dma_slave_config(as, &slave_config,\r\nxfer->bits_per_word))\r\ngoto err_exit;\r\nrxdesc = dmaengine_prep_slave_sg(rxchan,\r\nxfer->rx_sg.sgl, xfer->rx_sg.nents,\r\nDMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!rxdesc)\r\ngoto err_dma;\r\ntxdesc = dmaengine_prep_slave_sg(txchan,\r\nxfer->tx_sg.sgl, xfer->tx_sg.nents,\r\nDMA_TO_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc)\r\ngoto err_dma;\r\ndev_dbg(master->dev.parent,\r\n" start dma xfer %p: len %u tx %p/%08llx rx %p/%08llx\n",\r\nxfer, xfer->len, xfer->tx_buf, (unsigned long long)xfer->tx_dma,\r\nxfer->rx_buf, (unsigned long long)xfer->rx_dma);\r\nspi_writel(as, IER, SPI_BIT(OVRES));\r\nrxdesc->callback = dma_callback;\r\nrxdesc->callback_param = master;\r\ncookie = rxdesc->tx_submit(rxdesc);\r\nif (dma_submit_error(cookie))\r\ngoto err_dma;\r\ncookie = txdesc->tx_submit(txdesc);\r\nif (dma_submit_error(cookie))\r\ngoto err_dma;\r\nrxchan->device->device_issue_pending(rxchan);\r\ntxchan->device->device_issue_pending(txchan);\r\natmel_spi_lock(as);\r\nreturn 0;\r\nerr_dma:\r\nspi_writel(as, IDR, SPI_BIT(OVRES));\r\natmel_spi_stop_dma(master);\r\nerr_exit:\r\natmel_spi_lock(as);\r\nreturn -ENOMEM;\r\n}\r\nstatic void atmel_spi_next_xfer_data(struct spi_master *master,\r\nstruct spi_transfer *xfer,\r\ndma_addr_t *tx_dma,\r\ndma_addr_t *rx_dma,\r\nu32 *plen)\r\n{\r\n*rx_dma = xfer->rx_dma + xfer->len - *plen;\r\n*tx_dma = xfer->tx_dma + xfer->len - *plen;\r\nif (*plen > master->max_dma_len)\r\n*plen = master->max_dma_len;\r\n}\r\nstatic int atmel_spi_set_xfer_speed(struct atmel_spi *as,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nu32 scbr, csr;\r\nunsigned long bus_hz;\r\nbus_hz = as->spi_clk;\r\nif (!atmel_spi_is_v2(as))\r\nbus_hz /= 2;\r\nscbr = DIV_ROUND_UP(bus_hz, xfer->speed_hz);\r\nif (scbr >= (1 << SPI_SCBR_SIZE)) {\r\ndev_err(&spi->dev,\r\n"setup: %d Hz too slow, scbr %u; min %ld Hz\n",\r\nxfer->speed_hz, scbr, bus_hz/255);\r\nreturn -EINVAL;\r\n}\r\nif (scbr == 0) {\r\ndev_err(&spi->dev,\r\n"setup: %d Hz too high, scbr %u; max %ld Hz\n",\r\nxfer->speed_hz, scbr, bus_hz);\r\nreturn -EINVAL;\r\n}\r\ncsr = spi_readl(as, CSR0 + 4 * spi->chip_select);\r\ncsr = SPI_BFINS(SCBR, scbr, csr);\r\nspi_writel(as, CSR0 + 4 * spi->chip_select, csr);\r\nreturn 0;\r\n}\r\nstatic void atmel_spi_pdc_next_xfer(struct spi_master *master,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nu32 len;\r\ndma_addr_t tx_dma, rx_dma;\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nlen = as->current_remaining_bytes;\r\natmel_spi_next_xfer_data(master, xfer, &tx_dma, &rx_dma, &len);\r\nas->current_remaining_bytes -= len;\r\nspi_writel(as, RPR, rx_dma);\r\nspi_writel(as, TPR, tx_dma);\r\nif (msg->spi->bits_per_word > 8)\r\nlen >>= 1;\r\nspi_writel(as, RCR, len);\r\nspi_writel(as, TCR, len);\r\ndev_dbg(&msg->spi->dev,\r\n" start xfer %p: len %u tx %p/%08llx rx %p/%08llx\n",\r\nxfer, xfer->len, xfer->tx_buf,\r\n(unsigned long long)xfer->tx_dma, xfer->rx_buf,\r\n(unsigned long long)xfer->rx_dma);\r\nif (as->current_remaining_bytes) {\r\nlen = as->current_remaining_bytes;\r\natmel_spi_next_xfer_data(master, xfer, &tx_dma, &rx_dma, &len);\r\nas->current_remaining_bytes -= len;\r\nspi_writel(as, RNPR, rx_dma);\r\nspi_writel(as, TNPR, tx_dma);\r\nif (msg->spi->bits_per_word > 8)\r\nlen >>= 1;\r\nspi_writel(as, RNCR, len);\r\nspi_writel(as, TNCR, len);\r\ndev_dbg(&msg->spi->dev,\r\n" next xfer %p: len %u tx %p/%08llx rx %p/%08llx\n",\r\nxfer, xfer->len, xfer->tx_buf,\r\n(unsigned long long)xfer->tx_dma, xfer->rx_buf,\r\n(unsigned long long)xfer->rx_dma);\r\n}\r\nspi_writel(as, IER, SPI_BIT(RXBUFF) | SPI_BIT(OVRES));\r\nspi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));\r\n}\r\nstatic int\r\natmel_spi_dma_map_xfer(struct atmel_spi *as, struct spi_transfer *xfer)\r\n{\r\nstruct device *dev = &as->pdev->dev;\r\nxfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;\r\nif (xfer->tx_buf) {\r\nvoid *nonconst_tx = (void *)xfer->tx_buf;\r\nxfer->tx_dma = dma_map_single(dev,\r\nnonconst_tx, xfer->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, xfer->tx_dma))\r\nreturn -ENOMEM;\r\n}\r\nif (xfer->rx_buf) {\r\nxfer->rx_dma = dma_map_single(dev,\r\nxfer->rx_buf, xfer->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, xfer->rx_dma)) {\r\nif (xfer->tx_buf)\r\ndma_unmap_single(dev,\r\nxfer->tx_dma, xfer->len,\r\nDMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_spi_dma_unmap_xfer(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (xfer->tx_dma != INVALID_DMA_ADDRESS)\r\ndma_unmap_single(master->dev.parent, xfer->tx_dma,\r\nxfer->len, DMA_TO_DEVICE);\r\nif (xfer->rx_dma != INVALID_DMA_ADDRESS)\r\ndma_unmap_single(master->dev.parent, xfer->rx_dma,\r\nxfer->len, DMA_FROM_DEVICE);\r\n}\r\nstatic void atmel_spi_disable_pdc_transfer(struct atmel_spi *as)\r\n{\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\n}\r\nstatic void\r\natmel_spi_pump_single_data(struct atmel_spi *as, struct spi_transfer *xfer)\r\n{\r\nu8 *rxp;\r\nu16 *rxp16;\r\nunsigned long xfer_pos = xfer->len - as->current_remaining_bytes;\r\nif (xfer->bits_per_word > 8) {\r\nrxp16 = (u16 *)(((u8 *)xfer->rx_buf) + xfer_pos);\r\n*rxp16 = spi_readl(as, RDR);\r\n} else {\r\nrxp = ((u8 *)xfer->rx_buf) + xfer_pos;\r\n*rxp = spi_readl(as, RDR);\r\n}\r\nif (xfer->bits_per_word > 8) {\r\nif (as->current_remaining_bytes > 2)\r\nas->current_remaining_bytes -= 2;\r\nelse\r\nas->current_remaining_bytes = 0;\r\n} else {\r\nas->current_remaining_bytes--;\r\n}\r\n}\r\nstatic void\r\natmel_spi_pump_fifo_data(struct atmel_spi *as, struct spi_transfer *xfer)\r\n{\r\nu32 fifolr = spi_readl(as, FLR);\r\nu32 num_bytes, num_data = SPI_BFEXT(RXFL, fifolr);\r\nu32 offset = xfer->len - as->current_remaining_bytes;\r\nu16 *words = (u16 *)((u8 *)xfer->rx_buf + offset);\r\nu8 *bytes = (u8 *)((u8 *)xfer->rx_buf + offset);\r\nu16 rd;\r\nnum_bytes = ((xfer->bits_per_word > 8) ?\r\n(num_data << 1) :\r\nnum_data);\r\nif (as->current_remaining_bytes > num_bytes)\r\nas->current_remaining_bytes -= num_bytes;\r\nelse\r\nas->current_remaining_bytes = 0;\r\nif (xfer->bits_per_word > 8)\r\nas->current_remaining_bytes &= ~0x1;\r\nwhile (num_data) {\r\nrd = spi_readl(as, RDR);\r\nif (xfer->bits_per_word > 8)\r\n*words++ = rd;\r\nelse\r\n*bytes++ = rd;\r\nnum_data--;\r\n}\r\n}\r\nstatic void\r\natmel_spi_pump_pio_data(struct atmel_spi *as, struct spi_transfer *xfer)\r\n{\r\nif (as->fifo_size)\r\natmel_spi_pump_fifo_data(as, xfer);\r\nelse\r\natmel_spi_pump_single_data(as, xfer);\r\n}\r\nstatic irqreturn_t\r\natmel_spi_pio_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nu32 status, pending, imr;\r\nstruct spi_transfer *xfer;\r\nint ret = IRQ_NONE;\r\nimr = spi_readl(as, IMR);\r\nstatus = spi_readl(as, SR);\r\npending = status & imr;\r\nif (pending & SPI_BIT(OVRES)) {\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, SPI_BIT(OVRES));\r\ndev_warn(master->dev.parent, "overrun\n");\r\nas->done_status = -EIO;\r\nsmp_wmb();\r\nspi_readl(as, SR);\r\ncomplete(&as->xfer_completion);\r\n} else if (pending & (SPI_BIT(RDRF) | SPI_BIT(RXFTHF))) {\r\natmel_spi_lock(as);\r\nif (as->current_remaining_bytes) {\r\nret = IRQ_HANDLED;\r\nxfer = as->current_transfer;\r\natmel_spi_pump_pio_data(as, xfer);\r\nif (!as->current_remaining_bytes)\r\nspi_writel(as, IDR, pending);\r\ncomplete(&as->xfer_completion);\r\n}\r\natmel_spi_unlock(as);\r\n} else {\r\nWARN_ONCE(pending, "IRQ not handled, pending = %x\n", pending);\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, pending);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\natmel_spi_pdc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nu32 status, pending, imr;\r\nint ret = IRQ_NONE;\r\nimr = spi_readl(as, IMR);\r\nstatus = spi_readl(as, SR);\r\npending = status & imr;\r\nif (pending & SPI_BIT(OVRES)) {\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX)\r\n| SPI_BIT(OVRES)));\r\nspi_readl(as, SR);\r\nas->done_status = -EIO;\r\ncomplete(&as->xfer_completion);\r\n} else if (pending & (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX))) {\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, pending);\r\ncomplete(&as->xfer_completion);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_spi_setup(struct spi_device *spi)\r\n{\r\nstruct atmel_spi *as;\r\nstruct atmel_spi_device *asd;\r\nu32 csr;\r\nunsigned int bits = spi->bits_per_word;\r\nunsigned int npcs_pin;\r\nas = spi_master_get_devdata(spi->master);\r\nif (!atmel_spi_is_v2(as)\r\n&& spi->chip_select == 0\r\n&& (spi->mode & SPI_CS_HIGH)) {\r\ndev_dbg(&spi->dev, "setup: can't be active-high\n");\r\nreturn -EINVAL;\r\n}\r\ncsr = SPI_BF(BITS, bits - 8);\r\nif (spi->mode & SPI_CPOL)\r\ncsr |= SPI_BIT(CPOL);\r\nif (!(spi->mode & SPI_CPHA))\r\ncsr |= SPI_BIT(NCPHA);\r\nif (!as->use_cs_gpios)\r\ncsr |= SPI_BIT(CSAAT);\r\ncsr |= SPI_BF(DLYBS, 0);\r\ncsr |= SPI_BF(DLYBCT, 0);\r\nnpcs_pin = (unsigned long)spi->controller_data;\r\nif (!as->use_cs_gpios)\r\nnpcs_pin = spi->chip_select;\r\nelse if (gpio_is_valid(spi->cs_gpio))\r\nnpcs_pin = spi->cs_gpio;\r\nasd = spi->controller_state;\r\nif (!asd) {\r\nasd = kzalloc(sizeof(struct atmel_spi_device), GFP_KERNEL);\r\nif (!asd)\r\nreturn -ENOMEM;\r\nif (as->use_cs_gpios)\r\ngpio_direction_output(npcs_pin,\r\n!(spi->mode & SPI_CS_HIGH));\r\nasd->npcs_pin = npcs_pin;\r\nspi->controller_state = asd;\r\n}\r\nasd->csr = csr;\r\ndev_dbg(&spi->dev,\r\n"setup: bpw %u mode 0x%x -> csr%d %08x\n",\r\nbits, spi->mode, spi->chip_select, csr);\r\nif (!atmel_spi_is_v2(as))\r\nspi_writel(as, CSR0 + 4 * spi->chip_select, csr);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_one_transfer(struct spi_master *master,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct atmel_spi *as;\r\nstruct spi_device *spi = msg->spi;\r\nu8 bits;\r\nu32 len;\r\nstruct atmel_spi_device *asd;\r\nint timeout;\r\nint ret;\r\nunsigned long dma_timeout;\r\nas = spi_master_get_devdata(master);\r\nif (!(xfer->tx_buf || xfer->rx_buf) && xfer->len) {\r\ndev_dbg(&spi->dev, "missing rx or tx buf\n");\r\nreturn -EINVAL;\r\n}\r\nasd = spi->controller_state;\r\nbits = (asd->csr >> 4) & 0xf;\r\nif (bits != xfer->bits_per_word - 8) {\r\ndev_dbg(&spi->dev,\r\n"you can't yet change bits_per_word in transfers\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\nif ((!msg->is_dma_mapped)\r\n&& as->use_pdc) {\r\nif (atmel_spi_dma_map_xfer(as, xfer) < 0)\r\nreturn -ENOMEM;\r\n}\r\natmel_spi_set_xfer_speed(as, msg->spi, xfer);\r\nas->done_status = 0;\r\nas->current_transfer = xfer;\r\nas->current_remaining_bytes = xfer->len;\r\nwhile (as->current_remaining_bytes) {\r\nreinit_completion(&as->xfer_completion);\r\nif (as->use_pdc) {\r\natmel_spi_pdc_next_xfer(master, msg, xfer);\r\n} else if (atmel_spi_use_dma(as, xfer)) {\r\nlen = as->current_remaining_bytes;\r\nret = atmel_spi_next_xfer_dma_submit(master,\r\nxfer, &len);\r\nif (ret) {\r\ndev_err(&spi->dev,\r\n"unable to use DMA, fallback to PIO\n");\r\natmel_spi_next_xfer_pio(master, xfer);\r\n} else {\r\nas->current_remaining_bytes -= len;\r\nif (as->current_remaining_bytes < 0)\r\nas->current_remaining_bytes = 0;\r\n}\r\n} else {\r\natmel_spi_next_xfer_pio(master, xfer);\r\n}\r\natmel_spi_unlock(as);\r\ndma_timeout = wait_for_completion_timeout(&as->xfer_completion,\r\nSPI_DMA_TIMEOUT);\r\natmel_spi_lock(as);\r\nif (WARN_ON(dma_timeout == 0)) {\r\ndev_err(&spi->dev, "spi transfer timeout\n");\r\nas->done_status = -EIO;\r\n}\r\nif (as->done_status)\r\nbreak;\r\n}\r\nif (as->done_status) {\r\nif (as->use_pdc) {\r\ndev_warn(master->dev.parent,\r\n"overrun (%u/%u remaining)\n",\r\nspi_readl(as, TCR), spi_readl(as, RCR));\r\nspi_writel(as, RNCR, 0);\r\nspi_writel(as, TNCR, 0);\r\nspi_writel(as, RCR, 0);\r\nspi_writel(as, TCR, 0);\r\nfor (timeout = 1000; timeout; timeout--)\r\nif (spi_readl(as, SR) & SPI_BIT(TXEMPTY))\r\nbreak;\r\nif (!timeout)\r\ndev_warn(master->dev.parent,\r\n"timeout waiting for TXEMPTY");\r\nwhile (spi_readl(as, SR) & SPI_BIT(RDRF))\r\nspi_readl(as, RDR);\r\nspi_readl(as, SR);\r\n} else if (atmel_spi_use_dma(as, xfer)) {\r\natmel_spi_stop_dma(master);\r\n}\r\nif (!msg->is_dma_mapped\r\n&& as->use_pdc)\r\natmel_spi_dma_unmap_xfer(master, xfer);\r\nreturn 0;\r\n} else {\r\nmsg->actual_length += xfer->len;\r\n}\r\nif (!msg->is_dma_mapped\r\n&& as->use_pdc)\r\natmel_spi_dma_unmap_xfer(master, xfer);\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nif (xfer->cs_change) {\r\nif (list_is_last(&xfer->transfer_list,\r\n&msg->transfers)) {\r\nas->keep_cs = true;\r\n} else {\r\nas->cs_active = !as->cs_active;\r\nif (as->cs_active)\r\ncs_activate(as, msg->spi);\r\nelse\r\ncs_deactivate(as, msg->spi);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct atmel_spi *as;\r\nstruct spi_transfer *xfer;\r\nstruct spi_device *spi = msg->spi;\r\nint ret = 0;\r\nas = spi_master_get_devdata(master);\r\ndev_dbg(&spi->dev, "new message %p submitted for %s\n",\r\nmsg, dev_name(&spi->dev));\r\natmel_spi_lock(as);\r\ncs_activate(as, spi);\r\nas->cs_active = true;\r\nas->keep_cs = false;\r\nmsg->status = 0;\r\nmsg->actual_length = 0;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nret = atmel_spi_one_transfer(master, msg, xfer);\r\nif (ret)\r\ngoto msg_done;\r\n}\r\nif (as->use_pdc)\r\natmel_spi_disable_pdc_transfer(as);\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\ndev_dbg(&spi->dev,\r\n" xfer %p: len %u tx %p/%pad rx %p/%pad\n",\r\nxfer, xfer->len,\r\nxfer->tx_buf, &xfer->tx_dma,\r\nxfer->rx_buf, &xfer->rx_dma);\r\n}\r\nmsg_done:\r\nif (!as->keep_cs)\r\ncs_deactivate(as, msg->spi);\r\natmel_spi_unlock(as);\r\nmsg->status = as->done_status;\r\nspi_finalize_current_message(spi->master);\r\nreturn ret;\r\n}\r\nstatic void atmel_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nif (!asd)\r\nreturn;\r\nspi->controller_state = NULL;\r\nkfree(asd);\r\n}\r\nstatic inline unsigned int atmel_get_version(struct atmel_spi *as)\r\n{\r\nreturn spi_readl(as, VERSION) & 0x00000fff;\r\n}\r\nstatic void atmel_get_caps(struct atmel_spi *as)\r\n{\r\nunsigned int version;\r\nversion = atmel_get_version(as);\r\ndev_info(&as->pdev->dev, "version: 0x%x\n", version);\r\nas->caps.is_spi2 = version > 0x121;\r\nas->caps.has_wdrbt = version >= 0x210;\r\nas->caps.has_dma_support = version >= 0x212;\r\n}\r\nstatic int atmel_spi_gpio_cs(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct device_node *np = master->dev.of_node;\r\nint i;\r\nint ret = 0;\r\nint nb = 0;\r\nif (!as->use_cs_gpios)\r\nreturn 0;\r\nif (!np)\r\nreturn 0;\r\nnb = of_gpio_named_count(np, "cs-gpios");\r\nfor (i = 0; i < nb; i++) {\r\nint cs_gpio = of_get_named_gpio(pdev->dev.of_node,\r\n"cs-gpios", i);\r\nif (cs_gpio == -EPROBE_DEFER)\r\nreturn cs_gpio;\r\nif (gpio_is_valid(cs_gpio)) {\r\nret = devm_gpio_request(&pdev->dev, cs_gpio,\r\ndev_name(&pdev->dev));\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nint irq;\r\nstruct clk *clk;\r\nint ret;\r\nstruct spi_master *master;\r\nstruct atmel_spi *as;\r\npinctrl_pm_select_default_state(&pdev->dev);\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nclk = devm_clk_get(&pdev->dev, "spi_clk");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nret = -ENOMEM;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*as));\r\nif (!master)\r\ngoto out_free;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = master->dev.of_node ? 0 : 4;\r\nmaster->setup = atmel_spi_setup;\r\nmaster->flags = (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX);\r\nmaster->transfer_one_message = atmel_spi_transfer_one_message;\r\nmaster->cleanup = atmel_spi_cleanup;\r\nmaster->auto_runtime_pm = true;\r\nmaster->max_dma_len = SPI_MAX_DMA_XFER;\r\nmaster->can_dma = atmel_spi_can_dma;\r\nplatform_set_drvdata(pdev, master);\r\nas = spi_master_get_devdata(master);\r\nspin_lock_init(&as->lock);\r\nas->pdev = pdev;\r\nas->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(as->regs)) {\r\nret = PTR_ERR(as->regs);\r\ngoto out_unmap_regs;\r\n}\r\nas->phybase = regs->start;\r\nas->irq = irq;\r\nas->clk = clk;\r\ninit_completion(&as->xfer_completion);\r\natmel_get_caps(as);\r\nas->use_cs_gpios = true;\r\nif (atmel_spi_is_v2(as) &&\r\npdev->dev.of_node &&\r\n!of_get_property(pdev->dev.of_node, "cs-gpios", NULL)) {\r\nas->use_cs_gpios = false;\r\nmaster->num_chipselect = 4;\r\n}\r\nret = atmel_spi_gpio_cs(pdev);\r\nif (ret)\r\ngoto out_unmap_regs;\r\nas->use_dma = false;\r\nas->use_pdc = false;\r\nif (as->caps.has_dma_support) {\r\nret = atmel_spi_configure_dma(master, as);\r\nif (ret == 0) {\r\nas->use_dma = true;\r\n} else if (ret == -EPROBE_DEFER) {\r\nreturn ret;\r\n}\r\n} else {\r\nas->use_pdc = true;\r\n}\r\nif (as->caps.has_dma_support && !as->use_dma)\r\ndev_info(&pdev->dev, "Atmel SPI Controller using PIO only\n");\r\nif (as->use_pdc) {\r\nret = devm_request_irq(&pdev->dev, irq, atmel_spi_pdc_interrupt,\r\n0, dev_name(&pdev->dev), master);\r\n} else {\r\nret = devm_request_irq(&pdev->dev, irq, atmel_spi_pio_interrupt,\r\n0, dev_name(&pdev->dev), master);\r\n}\r\nif (ret)\r\ngoto out_unmap_regs;\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\ngoto out_free_irq;\r\nas->spi_clk = clk_get_rate(clk);\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nif (as->caps.has_wdrbt) {\r\nspi_writel(as, MR, SPI_BIT(WDRBT) | SPI_BIT(MODFDIS)\r\n| SPI_BIT(MSTR));\r\n} else {\r\nspi_writel(as, MR, SPI_BIT(MSTR) | SPI_BIT(MODFDIS));\r\n}\r\nif (as->use_pdc)\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nspi_writel(as, CR, SPI_BIT(SPIEN));\r\nas->fifo_size = 0;\r\nif (!of_property_read_u32(pdev->dev.of_node, "atmel,fifo-size",\r\n&as->fifo_size)) {\r\ndev_info(&pdev->dev, "Using FIFO (%u data)\n", as->fifo_size);\r\nspi_writel(as, CR, SPI_BIT(FIFOEN));\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret)\r\ngoto out_free_dma;\r\ndev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",\r\n(unsigned long)regs->start, irq);\r\nreturn 0;\r\nout_free_dma:\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\nif (as->use_dma)\r\natmel_spi_release_dma(master);\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nclk_disable_unprepare(clk);\r\nout_free_irq:\r\nout_unmap_regs:\r\nout_free:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int atmel_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\npm_runtime_get_sync(&pdev->dev);\r\nspin_lock_irq(&as->lock);\r\nif (as->use_dma) {\r\natmel_spi_stop_dma(master);\r\natmel_spi_release_dma(master);\r\n}\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_readl(as, SR);\r\nspin_unlock_irq(&as->lock);\r\nclk_disable_unprepare(as->clk);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nclk_disable_unprepare(as->clk);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\npinctrl_pm_select_default_state(dev);\r\nreturn clk_prepare_enable(as->clk);\r\n}\r\nstatic int atmel_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret) {\r\ndev_warn(dev, "cannot suspend master\n");\r\nreturn ret;\r\n}\r\nif (!pm_runtime_suspended(dev))\r\natmel_spi_runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nif (!pm_runtime_suspended(dev)) {\r\nret = atmel_spi_runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = spi_master_resume(master);\r\nif (ret)\r\ndev_err(dev, "problem starting queue (%d)\n", ret);\r\nreturn ret;\r\n}
