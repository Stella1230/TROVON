static int h4_open(struct hci_uart *hu)\r\n{\r\nstruct h4_struct *h4;\r\nBT_DBG("hu %p", hu);\r\nh4 = kzalloc(sizeof(*h4), GFP_KERNEL);\r\nif (!h4)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&h4->txq);\r\nhu->priv = h4;\r\nreturn 0;\r\n}\r\nstatic int h4_flush(struct hci_uart *hu)\r\n{\r\nstruct h4_struct *h4 = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&h4->txq);\r\nreturn 0;\r\n}\r\nstatic int h4_close(struct hci_uart *hu)\r\n{\r\nstruct h4_struct *h4 = hu->priv;\r\nhu->priv = NULL;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&h4->txq);\r\nkfree_skb(h4->rx_skb);\r\nhu->priv = NULL;\r\nkfree(h4);\r\nreturn 0;\r\n}\r\nstatic int h4_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct h4_struct *h4 = hu->priv;\r\nBT_DBG("hu %p skb %p", hu, skb);\r\nmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\r\nskb_queue_tail(&h4->txq, skb);\r\nreturn 0;\r\n}\r\nstatic int h4_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct h4_struct *h4 = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nh4->rx_skb = h4_recv_buf(hu->hdev, h4->rx_skb, data, count,\r\nh4_recv_pkts, ARRAY_SIZE(h4_recv_pkts));\r\nif (IS_ERR(h4->rx_skb)) {\r\nint err = PTR_ERR(h4->rx_skb);\r\nBT_ERR("%s: Frame reassembly failed (%d)", hu->hdev->name, err);\r\nh4->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic struct sk_buff *h4_dequeue(struct hci_uart *hu)\r\n{\r\nstruct h4_struct *h4 = hu->priv;\r\nreturn skb_dequeue(&h4->txq);\r\n}\r\nint __init h4_init(void)\r\n{\r\nreturn hci_uart_register_proto(&h4p);\r\n}\r\nint __exit h4_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&h4p);\r\n}\r\nstruct sk_buff *h4_recv_buf(struct hci_dev *hdev, struct sk_buff *skb,\r\nconst unsigned char *buffer, int count,\r\nconst struct h4_recv_pkt *pkts, int pkts_count)\r\n{\r\nwhile (count) {\r\nint i, len;\r\nif (!skb) {\r\nfor (i = 0; i < pkts_count; i++) {\r\nif (buffer[0] != (&pkts[i])->type)\r\ncontinue;\r\nskb = bt_skb_alloc((&pkts[i])->maxlen,\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nhci_skb_pkt_type(skb) = (&pkts[i])->type;\r\nhci_skb_expect(skb) = (&pkts[i])->hlen;\r\nbreak;\r\n}\r\nif (!skb)\r\nreturn ERR_PTR(-EILSEQ);\r\ncount -= 1;\r\nbuffer += 1;\r\n}\r\nlen = min_t(uint, hci_skb_expect(skb) - skb->len, count);\r\nmemcpy(skb_put(skb, len), buffer, len);\r\ncount -= len;\r\nbuffer += len;\r\nif (skb->len < hci_skb_expect(skb))\r\ncontinue;\r\nfor (i = 0; i < pkts_count; i++) {\r\nif (hci_skb_pkt_type(skb) == (&pkts[i])->type)\r\nbreak;\r\n}\r\nif (i >= pkts_count) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EILSEQ);\r\n}\r\nif (skb->len == (&pkts[i])->hlen) {\r\nu16 dlen;\r\nswitch ((&pkts[i])->lsize) {\r\ncase 0:\r\ndlen = 0;\r\nbreak;\r\ncase 1:\r\ndlen = skb->data[(&pkts[i])->loff];\r\nhci_skb_expect(skb) += dlen;\r\nif (skb_tailroom(skb) < dlen) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EMSGSIZE);\r\n}\r\nbreak;\r\ncase 2:\r\ndlen = get_unaligned_le16(skb->data +\r\n(&pkts[i])->loff);\r\nhci_skb_expect(skb) += dlen;\r\nif (skb_tailroom(skb) < dlen) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EMSGSIZE);\r\n}\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nreturn ERR_PTR(-EILSEQ);\r\n}\r\nif (!dlen) {\r\n(&pkts[i])->recv(hdev, skb);\r\nskb = NULL;\r\n}\r\n} else {\r\n(&pkts[i])->recv(hdev, skb);\r\nskb = NULL;\r\n}\r\n}\r\nreturn skb;\r\n}
