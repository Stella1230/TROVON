static void\r\ncleanup(void)\r\n{\r\nif (!mmap_failed)\r\nmunmap(ehdr_curr, sb.st_size);\r\nclose(fd_map);\r\n}\r\nstatic void *mmap_file(char const *fname)\r\n{\r\nvoid *addr;\r\nfd_map = open(fname, O_RDWR);\r\nif (fd_map < 0 || fstat(fd_map, &sb) < 0) {\r\nperror(fname);\r\nfail_file();\r\n}\r\nif (!S_ISREG(sb.st_mode)) {\r\nfprintf(stderr, "not a regular file: %s\n", fname);\r\nfail_file();\r\n}\r\naddr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_SHARED,\r\nfd_map, 0);\r\nif (addr == MAP_FAILED) {\r\nmmap_failed = 1;\r\nfprintf(stderr, "Could not mmap file: %s\n", fname);\r\nfail_file();\r\n}\r\nreturn addr;\r\n}\r\nstatic uint64_t r8be(const uint64_t *x)\r\n{\r\nreturn get_unaligned_be64(x);\r\n}\r\nstatic uint32_t rbe(const uint32_t *x)\r\n{\r\nreturn get_unaligned_be32(x);\r\n}\r\nstatic uint16_t r2be(const uint16_t *x)\r\n{\r\nreturn get_unaligned_be16(x);\r\n}\r\nstatic uint64_t r8le(const uint64_t *x)\r\n{\r\nreturn get_unaligned_le64(x);\r\n}\r\nstatic uint32_t rle(const uint32_t *x)\r\n{\r\nreturn get_unaligned_le32(x);\r\n}\r\nstatic uint16_t r2le(const uint16_t *x)\r\n{\r\nreturn get_unaligned_le16(x);\r\n}\r\nstatic void w8be(uint64_t val, uint64_t *x)\r\n{\r\nput_unaligned_be64(val, x);\r\n}\r\nstatic void wbe(uint32_t val, uint32_t *x)\r\n{\r\nput_unaligned_be32(val, x);\r\n}\r\nstatic void w2be(uint16_t val, uint16_t *x)\r\n{\r\nput_unaligned_be16(val, x);\r\n}\r\nstatic void w8le(uint64_t val, uint64_t *x)\r\n{\r\nput_unaligned_le64(val, x);\r\n}\r\nstatic void wle(uint32_t val, uint32_t *x)\r\n{\r\nput_unaligned_le32(val, x);\r\n}\r\nstatic void w2le(uint16_t val, uint16_t *x)\r\n{\r\nput_unaligned_le16(val, x);\r\n}\r\nstatic inline int is_shndx_special(unsigned int i)\r\n{\r\nreturn i != SHN_XINDEX && i >= SHN_LORESERVE && i <= SHN_HIRESERVE;\r\n}\r\nstatic inline unsigned int get_secindex(unsigned int shndx,\r\nunsigned int sym_offs,\r\nconst Elf32_Word *symtab_shndx_start)\r\n{\r\nif (is_shndx_special(shndx))\r\nreturn SPECIAL(shndx);\r\nif (shndx != SHN_XINDEX)\r\nreturn shndx;\r\nreturn r(&symtab_shndx_start[sym_offs]);\r\n}\r\nstatic int compare_relative_table(const void *a, const void *b)\r\n{\r\nint32_t av = (int32_t)r(a);\r\nint32_t bv = (int32_t)r(b);\r\nif (av < bv)\r\nreturn -1;\r\nif (av > bv)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void x86_sort_relative_table(char *extab_image, int image_size)\r\n{\r\nint i;\r\ni = 0;\r\nwhile (i < image_size) {\r\nuint32_t *loc = (uint32_t *)(extab_image + i);\r\nw(r(loc) + i, loc);\r\nw(r(loc + 1) + i + 4, loc + 1);\r\nw(r(loc + 2) + i + 8, loc + 2);\r\ni += sizeof(uint32_t) * 3;\r\n}\r\nqsort(extab_image, image_size / 12, 12, compare_relative_table);\r\ni = 0;\r\nwhile (i < image_size) {\r\nuint32_t *loc = (uint32_t *)(extab_image + i);\r\nw(r(loc) - i, loc);\r\nw(r(loc + 1) - (i + 4), loc + 1);\r\nw(r(loc + 2) - (i + 8), loc + 2);\r\ni += sizeof(uint32_t) * 3;\r\n}\r\n}\r\nstatic void sort_relative_table(char *extab_image, int image_size)\r\n{\r\nint i;\r\ni = 0;\r\nwhile (i < image_size) {\r\nuint32_t *loc = (uint32_t *)(extab_image + i);\r\nw(r(loc) + i, loc);\r\ni += 4;\r\n}\r\nqsort(extab_image, image_size / 8, 8, compare_relative_table);\r\ni = 0;\r\nwhile (i < image_size) {\r\nuint32_t *loc = (uint32_t *)(extab_image + i);\r\nw(r(loc) - i, loc);\r\ni += 4;\r\n}\r\n}\r\nstatic void\r\ndo_file(char const *const fname)\r\n{\r\ntable_sort_t custom_sort;\r\nElf32_Ehdr *ehdr = mmap_file(fname);\r\nehdr_curr = ehdr;\r\nswitch (ehdr->e_ident[EI_DATA]) {\r\ndefault:\r\nfprintf(stderr, "unrecognized ELF data encoding %d: %s\n",\r\nehdr->e_ident[EI_DATA], fname);\r\nfail_file();\r\nbreak;\r\ncase ELFDATA2LSB:\r\nr = rle;\r\nr2 = r2le;\r\nr8 = r8le;\r\nw = wle;\r\nw2 = w2le;\r\nw8 = w8le;\r\nbreak;\r\ncase ELFDATA2MSB:\r\nr = rbe;\r\nr2 = r2be;\r\nr8 = r8be;\r\nw = wbe;\r\nw2 = w2be;\r\nw8 = w8be;\r\nbreak;\r\n}\r\nif (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0\r\n|| (r2(&ehdr->e_type) != ET_EXEC && r2(&ehdr->e_type) != ET_DYN)\r\n|| ehdr->e_ident[EI_VERSION] != EV_CURRENT) {\r\nfprintf(stderr, "unrecognized ET_EXEC/ET_DYN file %s\n", fname);\r\nfail_file();\r\n}\r\ncustom_sort = NULL;\r\nswitch (r2(&ehdr->e_machine)) {\r\ndefault:\r\nfprintf(stderr, "unrecognized e_machine %d %s\n",\r\nr2(&ehdr->e_machine), fname);\r\nfail_file();\r\nbreak;\r\ncase EM_386:\r\ncase EM_X86_64:\r\ncustom_sort = x86_sort_relative_table;\r\nbreak;\r\ncase EM_S390:\r\ncase EM_AARCH64:\r\ncase EM_PARISC:\r\ncase EM_PPC:\r\ncase EM_PPC64:\r\ncustom_sort = sort_relative_table;\r\nbreak;\r\ncase EM_ARCOMPACT:\r\ncase EM_ARCV2:\r\ncase EM_ARM:\r\ncase EM_MICROBLAZE:\r\ncase EM_MIPS:\r\ncase EM_XTENSA:\r\nbreak;\r\n}\r\nswitch (ehdr->e_ident[EI_CLASS]) {\r\ndefault:\r\nfprintf(stderr, "unrecognized ELF class %d %s\n",\r\nehdr->e_ident[EI_CLASS], fname);\r\nfail_file();\r\nbreak;\r\ncase ELFCLASS32:\r\nif (r2(&ehdr->e_ehsize) != sizeof(Elf32_Ehdr)\r\n|| r2(&ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {\r\nfprintf(stderr,\r\n"unrecognized ET_EXEC/ET_DYN file: %s\n", fname);\r\nfail_file();\r\n}\r\ndo32(ehdr, fname, custom_sort);\r\nbreak;\r\ncase ELFCLASS64: {\r\nElf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;\r\nif (r2(&ghdr->e_ehsize) != sizeof(Elf64_Ehdr)\r\n|| r2(&ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {\r\nfprintf(stderr,\r\n"unrecognized ET_EXEC/ET_DYN file: %s\n", fname);\r\nfail_file();\r\n}\r\ndo64(ghdr, fname, custom_sort);\r\nbreak;\r\n}\r\n}\r\ncleanup();\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nint n_error = 0;\r\nint i;\r\nif (argc < 2) {\r\nfprintf(stderr, "usage: sortextable vmlinux...\n");\r\nreturn 0;\r\n}\r\nfor (i = 1; i < argc; i++) {\r\nchar *file = argv[i];\r\nint const sjval = setjmp(jmpenv);\r\nswitch (sjval) {\r\ndefault:\r\nfprintf(stderr, "internal error: %s\n", file);\r\nexit(1);\r\nbreak;\r\ncase SJ_SETJMP:\r\nfd_map = -1;\r\nehdr_curr = NULL;\r\nmmap_failed = 1;\r\ndo_file(file);\r\nbreak;\r\ncase SJ_FAIL:\r\n++n_error;\r\nbreak;\r\ncase SJ_SUCCEED:\r\nbreak;\r\n}\r\n}\r\nreturn !!n_error;\r\n}
