static int alloc_ila_locks(struct ila_net *ilan)\r\n{\r\nunsigned int i, size;\r\nunsigned int nr_pcpus = num_possible_cpus();\r\nnr_pcpus = min_t(unsigned int, nr_pcpus, 32UL);\r\nsize = roundup_pow_of_two(nr_pcpus * LOCKS_PER_CPU);\r\nif (sizeof(spinlock_t) != 0) {\r\n#ifdef CONFIG_NUMA\r\nif (size * sizeof(spinlock_t) > PAGE_SIZE)\r\nilan->locks = vmalloc(size * sizeof(spinlock_t));\r\nelse\r\n#endif\r\nilan->locks = kmalloc_array(size, sizeof(spinlock_t),\r\nGFP_KERNEL);\r\nif (!ilan->locks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < size; i++)\r\nspin_lock_init(&ilan->locks[i]);\r\n}\r\nilan->locks_mask = size - 1;\r\nreturn 0;\r\n}\r\nstatic __always_inline void __ila_hash_secret_init(void)\r\n{\r\nnet_get_random_once(&hashrnd, sizeof(hashrnd));\r\n}\r\nstatic inline u32 ila_locator_hash(struct ila_locator loc)\r\n{\r\nu32 *v = (u32 *)loc.v32;\r\nreturn jhash_2words(v[0], v[1], hashrnd);\r\n}\r\nstatic inline spinlock_t *ila_get_lock(struct ila_net *ilan,\r\nstruct ila_locator loc)\r\n{\r\nreturn &ilan->locks[ila_locator_hash(loc) & ilan->locks_mask];\r\n}\r\nstatic inline int ila_cmp_wildcards(struct ila_map *ila,\r\nstruct ila_addr *iaddr, int ifindex)\r\n{\r\nreturn (ila->xp.ifindex && ila->xp.ifindex != ifindex);\r\n}\r\nstatic inline int ila_cmp_params(struct ila_map *ila,\r\nstruct ila_xlat_params *xp)\r\n{\r\nreturn (ila->xp.ifindex != xp->ifindex);\r\n}\r\nstatic int ila_cmpfn(struct rhashtable_compare_arg *arg,\r\nconst void *obj)\r\n{\r\nconst struct ila_map *ila = obj;\r\nreturn (ila->xp.ip.locator_match.v64 != *(__be64 *)arg->key);\r\n}\r\nstatic inline int ila_order(struct ila_map *ila)\r\n{\r\nint score = 0;\r\nif (ila->xp.ifindex)\r\nscore += 1 << 1;\r\nreturn score;\r\n}\r\nstatic int parse_nl_config(struct genl_info *info,\r\nstruct ila_xlat_params *xp)\r\n{\r\nmemset(xp, 0, sizeof(*xp));\r\nif (info->attrs[ILA_ATTR_LOCATOR])\r\nxp->ip.locator.v64 = (__force __be64)nla_get_u64(\r\ninfo->attrs[ILA_ATTR_LOCATOR]);\r\nif (info->attrs[ILA_ATTR_LOCATOR_MATCH])\r\nxp->ip.locator_match.v64 = (__force __be64)nla_get_u64(\r\ninfo->attrs[ILA_ATTR_LOCATOR_MATCH]);\r\nif (info->attrs[ILA_ATTR_CSUM_MODE])\r\nxp->ip.csum_mode = nla_get_u8(info->attrs[ILA_ATTR_CSUM_MODE]);\r\nif (info->attrs[ILA_ATTR_IFINDEX])\r\nxp->ifindex = nla_get_s32(info->attrs[ILA_ATTR_IFINDEX]);\r\nreturn 0;\r\n}\r\nstatic inline struct ila_map *ila_lookup_wildcards(struct ila_addr *iaddr,\r\nint ifindex,\r\nstruct ila_net *ilan)\r\n{\r\nstruct ila_map *ila;\r\nila = rhashtable_lookup_fast(&ilan->rhash_table, &iaddr->loc,\r\nrht_params);\r\nwhile (ila) {\r\nif (!ila_cmp_wildcards(ila, iaddr, ifindex))\r\nreturn ila;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct ila_map *ila_lookup_by_params(struct ila_xlat_params *xp,\r\nstruct ila_net *ilan)\r\n{\r\nstruct ila_map *ila;\r\nila = rhashtable_lookup_fast(&ilan->rhash_table,\r\n&xp->ip.locator_match,\r\nrht_params);\r\nwhile (ila) {\r\nif (!ila_cmp_params(ila, xp))\r\nreturn ila;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void ila_release(struct ila_map *ila)\r\n{\r\nkfree_rcu(ila, rcu);\r\n}\r\nstatic void ila_free_cb(void *ptr, void *arg)\r\n{\r\nstruct ila_map *ila = (struct ila_map *)ptr, *next;\r\nwhile (ila) {\r\nnext = rcu_access_pointer(ila->next);\r\nila_release(ila);\r\nila = next;\r\n}\r\n}\r\nstatic unsigned int\r\nila_nf_input(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nila_xlat_addr(skb, false);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic int ila_add_mapping(struct net *net, struct ila_xlat_params *xp)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_map *ila, *head;\r\nspinlock_t *lock = ila_get_lock(ilan, xp->ip.locator_match);\r\nint err = 0, order;\r\nif (!ilan->hooks_registered) {\r\nerr = nf_register_net_hooks(net, ila_nf_hook_ops,\r\nARRAY_SIZE(ila_nf_hook_ops));\r\nif (err)\r\nreturn err;\r\nilan->hooks_registered = true;\r\n}\r\nila = kzalloc(sizeof(*ila), GFP_KERNEL);\r\nif (!ila)\r\nreturn -ENOMEM;\r\nila_init_saved_csum(&xp->ip);\r\nila->xp = *xp;\r\norder = ila_order(ila);\r\nspin_lock(lock);\r\nhead = rhashtable_lookup_fast(&ilan->rhash_table,\r\n&xp->ip.locator_match,\r\nrht_params);\r\nif (!head) {\r\nerr = rhashtable_lookup_insert_fast(&ilan->rhash_table,\r\n&ila->node, rht_params);\r\n} else {\r\nstruct ila_map *tila = head, *prev = NULL;\r\ndo {\r\nif (!ila_cmp_params(tila, xp)) {\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nif (order > ila_order(tila))\r\nbreak;\r\nprev = tila;\r\ntila = rcu_dereference_protected(tila->next,\r\nlockdep_is_held(lock));\r\n} while (tila);\r\nif (prev) {\r\nRCU_INIT_POINTER(ila->next, tila);\r\nrcu_assign_pointer(prev->next, ila);\r\n} else {\r\nRCU_INIT_POINTER(ila->next, head);\r\nerr = rhashtable_replace_fast(&ilan->rhash_table,\r\n&head->node,\r\n&ila->node, rht_params);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock(lock);\r\nif (err)\r\nkfree(ila);\r\nreturn err;\r\n}\r\nstatic int ila_del_mapping(struct net *net, struct ila_xlat_params *xp)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_map *ila, *head, *prev;\r\nspinlock_t *lock = ila_get_lock(ilan, xp->ip.locator_match);\r\nint err = -ENOENT;\r\nspin_lock(lock);\r\nhead = rhashtable_lookup_fast(&ilan->rhash_table,\r\n&xp->ip.locator_match, rht_params);\r\nila = head;\r\nprev = NULL;\r\nwhile (ila) {\r\nif (ila_cmp_params(ila, xp)) {\r\nprev = ila;\r\nila = rcu_dereference_protected(ila->next,\r\nlockdep_is_held(lock));\r\ncontinue;\r\n}\r\nerr = 0;\r\nif (prev) {\r\nrcu_assign_pointer(prev->next, ila->next);\r\n} else {\r\nhead = rcu_dereference_protected(ila->next,\r\nlockdep_is_held(lock));\r\nif (head) {\r\nerr = rhashtable_replace_fast(\r\n&ilan->rhash_table, &ila->node,\r\n&head->node, rht_params);\r\nif (err)\r\ngoto out;\r\n} else {\r\nerr = rhashtable_remove_fast(&ilan->rhash_table,\r\n&ila->node,\r\nrht_params);\r\n}\r\n}\r\nila_release(ila);\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(lock);\r\nreturn err;\r\n}\r\nstatic int ila_nl_cmd_add_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_xlat_params p;\r\nint err;\r\nerr = parse_nl_config(info, &p);\r\nif (err)\r\nreturn err;\r\nreturn ila_add_mapping(net, &p);\r\n}\r\nstatic int ila_nl_cmd_del_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_xlat_params xp;\r\nint err;\r\nerr = parse_nl_config(info, &xp);\r\nif (err)\r\nreturn err;\r\nila_del_mapping(net, &xp);\r\nreturn 0;\r\n}\r\nstatic int ila_fill_info(struct ila_map *ila, struct sk_buff *msg)\r\n{\r\nif (nla_put_u64_64bit(msg, ILA_ATTR_LOCATOR,\r\n(__force u64)ila->xp.ip.locator.v64,\r\nILA_ATTR_PAD) ||\r\nnla_put_u64_64bit(msg, ILA_ATTR_LOCATOR_MATCH,\r\n(__force u64)ila->xp.ip.locator_match.v64,\r\nILA_ATTR_PAD) ||\r\nnla_put_s32(msg, ILA_ATTR_IFINDEX, ila->xp.ifindex) ||\r\nnla_put_u32(msg, ILA_ATTR_CSUM_MODE, ila->xp.ip.csum_mode))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int ila_dump_info(struct ila_map *ila,\r\nu32 portid, u32 seq, u32 flags,\r\nstruct sk_buff *skb, u8 cmd)\r\n{\r\nvoid *hdr;\r\nhdr = genlmsg_put(skb, portid, seq, &ila_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -ENOMEM;\r\nif (ila_fill_info(ila, skb) < 0)\r\ngoto nla_put_failure;\r\ngenlmsg_end(skb, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int ila_nl_cmd_get_mapping(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct net *net = genl_info_net(info);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct sk_buff *msg;\r\nstruct ila_xlat_params xp;\r\nstruct ila_map *ila;\r\nint ret;\r\nret = parse_nl_config(info, &xp);\r\nif (ret)\r\nreturn ret;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nrcu_read_lock();\r\nila = ila_lookup_by_params(&xp, ilan);\r\nif (ila) {\r\nret = ila_dump_info(ila,\r\ninfo->snd_portid,\r\ninfo->snd_seq, 0, msg,\r\ninfo->genlhdr->cmd);\r\n}\r\nrcu_read_unlock();\r\nif (ret < 0)\r\ngoto out_free;\r\nreturn genlmsg_reply(msg, info);\r\nout_free:\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic int ila_nl_dump_start(struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(cb->skb->sk);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args[0];\r\nif (!iter) {\r\niter = kmalloc(sizeof(*iter), GFP_KERNEL);\r\nif (!iter)\r\nreturn -ENOMEM;\r\ncb->args[0] = (long)iter;\r\n}\r\nreturn rhashtable_walk_init(&ilan->rhash_table, &iter->rhiter,\r\nGFP_KERNEL);\r\n}\r\nstatic int ila_nl_dump_done(struct netlink_callback *cb)\r\n{\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args[0];\r\nrhashtable_walk_exit(&iter->rhiter);\r\nkfree(iter);\r\nreturn 0;\r\n}\r\nstatic int ila_nl_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args[0];\r\nstruct rhashtable_iter *rhiter = &iter->rhiter;\r\nstruct ila_map *ila;\r\nint ret;\r\nret = rhashtable_walk_start(rhiter);\r\nif (ret && ret != -EAGAIN)\r\ngoto done;\r\nfor (;;) {\r\nila = rhashtable_walk_next(rhiter);\r\nif (IS_ERR(ila)) {\r\nif (PTR_ERR(ila) == -EAGAIN)\r\ncontinue;\r\nret = PTR_ERR(ila);\r\ngoto done;\r\n} else if (!ila) {\r\nbreak;\r\n}\r\nwhile (ila) {\r\nret = ila_dump_info(ila, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nskb, ILA_CMD_GET);\r\nif (ret)\r\ngoto done;\r\nila = rcu_access_pointer(ila->next);\r\n}\r\n}\r\nret = skb->len;\r\ndone:\r\nrhashtable_walk_stop(rhiter);\r\nreturn ret;\r\n}\r\nstatic __net_init int ila_init_net(struct net *net)\r\n{\r\nint err;\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nerr = alloc_ila_locks(ilan);\r\nif (err)\r\nreturn err;\r\nrhashtable_init(&ilan->rhash_table, &rht_params);\r\nreturn 0;\r\n}\r\nstatic __net_exit void ila_exit_net(struct net *net)\r\n{\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nrhashtable_free_and_destroy(&ilan->rhash_table, ila_free_cb, NULL);\r\nkvfree(ilan->locks);\r\nif (ilan->hooks_registered)\r\nnf_unregister_net_hooks(net, ila_nf_hook_ops,\r\nARRAY_SIZE(ila_nf_hook_ops));\r\n}\r\nstatic int ila_xlat_addr(struct sk_buff *skb, bool set_csum_neutral)\r\n{\r\nstruct ila_map *ila;\r\nstruct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ila_net *ilan = net_generic(net, ila_net_id);\r\nstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\r\nif (!ila_addr_is_ila(iaddr)) {\r\nreturn 0;\r\n}\r\nrcu_read_lock();\r\nila = ila_lookup_wildcards(iaddr, skb->dev->ifindex, ilan);\r\nif (ila)\r\nila_update_ipv6_locator(skb, &ila->xp.ip, set_csum_neutral);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint __init ila_xlat_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_device(&ila_net_ops);\r\nif (ret)\r\ngoto exit;\r\nret = genl_register_family(&ila_nl_family);\r\nif (ret < 0)\r\ngoto unregister;\r\nreturn 0;\r\nunregister:\r\nunregister_pernet_device(&ila_net_ops);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid ila_xlat_fini(void)\r\n{\r\ngenl_unregister_family(&ila_nl_family);\r\nunregister_pernet_device(&ila_net_ops);\r\n}
