static int asd_map_memio(struct asd_ha_struct *asd_ha)\r\n{\r\nint err, i;\r\nstruct asd_ha_addrspace *io_handle;\r\nasd_ha->iospace = 0;\r\nfor (i = 0; i < 3; i += 2) {\r\nio_handle = &asd_ha->io_handle[i==0?0:1];\r\nio_handle->start = pci_resource_start(asd_ha->pcidev, i);\r\nio_handle->len = pci_resource_len(asd_ha->pcidev, i);\r\nio_handle->flags = pci_resource_flags(asd_ha->pcidev, i);\r\nerr = -ENODEV;\r\nif (!io_handle->start || !io_handle->len) {\r\nasd_printk("MBAR%d start or length for %s is 0.\n",\r\ni==0?0:1, pci_name(asd_ha->pcidev));\r\ngoto Err;\r\n}\r\nerr = pci_request_region(asd_ha->pcidev, i, ASD_DRIVER_NAME);\r\nif (err) {\r\nasd_printk("couldn't reserve memory region for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Err;\r\n}\r\nio_handle->addr = ioremap(io_handle->start, io_handle->len);\r\nif (!io_handle->addr) {\r\nasd_printk("couldn't map MBAR%d of %s\n", i==0?0:1,\r\npci_name(asd_ha->pcidev));\r\nerr = -ENOMEM;\r\ngoto Err_unreq;\r\n}\r\n}\r\nreturn 0;\r\nErr_unreq:\r\npci_release_region(asd_ha->pcidev, i);\r\nErr:\r\nif (i > 0) {\r\nio_handle = &asd_ha->io_handle[0];\r\niounmap(io_handle->addr);\r\npci_release_region(asd_ha->pcidev, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic void asd_unmap_memio(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_ha_addrspace *io_handle;\r\nio_handle = &asd_ha->io_handle[1];\r\niounmap(io_handle->addr);\r\npci_release_region(asd_ha->pcidev, 2);\r\nio_handle = &asd_ha->io_handle[0];\r\niounmap(io_handle->addr);\r\npci_release_region(asd_ha->pcidev, 0);\r\n}\r\nstatic int asd_map_ioport(struct asd_ha_struct *asd_ha)\r\n{\r\nint i = PCI_IOBAR_OFFSET, err;\r\nstruct asd_ha_addrspace *io_handle = &asd_ha->io_handle[0];\r\nasd_ha->iospace = 1;\r\nio_handle->start = pci_resource_start(asd_ha->pcidev, i);\r\nio_handle->len = pci_resource_len(asd_ha->pcidev, i);\r\nio_handle->flags = pci_resource_flags(asd_ha->pcidev, i);\r\nio_handle->addr = (void __iomem *) io_handle->start;\r\nif (!io_handle->start || !io_handle->len) {\r\nasd_printk("couldn't get IO ports for %s\n",\r\npci_name(asd_ha->pcidev));\r\nreturn -ENODEV;\r\n}\r\nerr = pci_request_region(asd_ha->pcidev, i, ASD_DRIVER_NAME);\r\nif (err) {\r\nasd_printk("couldn't reserve io space for %s\n",\r\npci_name(asd_ha->pcidev));\r\n}\r\nreturn err;\r\n}\r\nstatic void asd_unmap_ioport(struct asd_ha_struct *asd_ha)\r\n{\r\npci_release_region(asd_ha->pcidev, PCI_IOBAR_OFFSET);\r\n}\r\nstatic int asd_map_ha(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nu16 cmd_reg;\r\nerr = pci_read_config_word(asd_ha->pcidev, PCI_COMMAND, &cmd_reg);\r\nif (err) {\r\nasd_printk("couldn't read command register of %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Err;\r\n}\r\nerr = -ENODEV;\r\nif (cmd_reg & PCI_COMMAND_MEMORY) {\r\nif ((err = asd_map_memio(asd_ha)))\r\ngoto Err;\r\n} else if (cmd_reg & PCI_COMMAND_IO) {\r\nif ((err = asd_map_ioport(asd_ha)))\r\ngoto Err;\r\nasd_printk("%s ioport mapped -- upgrade your hardware\n",\r\npci_name(asd_ha->pcidev));\r\n} else {\r\nasd_printk("no proper device access to %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Err;\r\n}\r\nreturn 0;\r\nErr:\r\nreturn err;\r\n}\r\nstatic void asd_unmap_ha(struct asd_ha_struct *asd_ha)\r\n{\r\nif (asd_ha->iospace)\r\nasd_unmap_ioport(asd_ha);\r\nelse\r\nasd_unmap_memio(asd_ha);\r\n}\r\nstatic int asd_common_setup(struct asd_ha_struct *asd_ha)\r\n{\r\nint err, i;\r\nasd_ha->revision_id = asd_ha->pcidev->revision;\r\nerr = -ENODEV;\r\nif (asd_ha->revision_id < AIC9410_DEV_REV_B0) {\r\nasd_printk("%s is revision %s (%X), which is not supported\n",\r\npci_name(asd_ha->pcidev),\r\nasd_dev_rev[asd_ha->revision_id],\r\nasd_ha->revision_id);\r\ngoto Err;\r\n}\r\nasd_ha->hw_prof.max_scbs = 512;\r\nasd_ha->hw_prof.max_ddbs = ASD_MAX_DDBS;\r\nasd_ha->hw_prof.num_phys = ASD_MAX_PHYS;\r\nasd_ha->hw_prof.enabled_phys = 0xFF;\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nasd_ha->hw_prof.phy_desc[i].max_sas_lrate =\r\nSAS_LINK_RATE_3_0_GBPS;\r\nasd_ha->hw_prof.phy_desc[i].min_sas_lrate =\r\nSAS_LINK_RATE_1_5_GBPS;\r\nasd_ha->hw_prof.phy_desc[i].max_sata_lrate =\r\nSAS_LINK_RATE_1_5_GBPS;\r\nasd_ha->hw_prof.phy_desc[i].min_sata_lrate =\r\nSAS_LINK_RATE_1_5_GBPS;\r\n}\r\nreturn 0;\r\nErr:\r\nreturn err;\r\n}\r\nstatic int asd_aic9410_setup(struct asd_ha_struct *asd_ha)\r\n{\r\nint err = asd_common_setup(asd_ha);\r\nif (err)\r\nreturn err;\r\nasd_ha->hw_prof.addr_range = 8;\r\nasd_ha->hw_prof.port_name_base = 0;\r\nasd_ha->hw_prof.dev_name_base = 8;\r\nasd_ha->hw_prof.sata_name_base = 16;\r\nreturn 0;\r\n}\r\nstatic int asd_aic9405_setup(struct asd_ha_struct *asd_ha)\r\n{\r\nint err = asd_common_setup(asd_ha);\r\nif (err)\r\nreturn err;\r\nasd_ha->hw_prof.addr_range = 4;\r\nasd_ha->hw_prof.port_name_base = 0;\r\nasd_ha->hw_prof.dev_name_base = 4;\r\nasd_ha->hw_prof.sata_name_base = 8;\r\nreturn 0;\r\n}\r\nstatic ssize_t asd_show_dev_rev(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nasd_dev_rev[asd_ha->revision_id]);\r\n}\r\nstatic ssize_t asd_show_dev_bios_build(struct device *dev,\r\nstruct device_attribute *attr,char *buf)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", asd_ha->hw_prof.bios.bld);\r\n}\r\nstatic ssize_t asd_show_dev_pcba_sn(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", asd_ha->hw_prof.pcba_sn);\r\n}\r\nstatic ssize_t asd_store_update_bios(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\r\nchar *cmd_ptr, *filename_ptr;\r\nstruct bios_file_header header, *hdr_ptr;\r\nint res, i;\r\nu32 csum = 0;\r\nint flash_command = FLASH_CMD_NONE;\r\nint err = 0;\r\ncmd_ptr = kzalloc(count*2, GFP_KERNEL);\r\nif (!cmd_ptr) {\r\nerr = FAIL_OUT_MEMORY;\r\ngoto out;\r\n}\r\nfilename_ptr = cmd_ptr + count;\r\nres = sscanf(buf, "%s %s", cmd_ptr, filename_ptr);\r\nif (res != 2) {\r\nerr = FAIL_PARAMETERS;\r\ngoto out1;\r\n}\r\nfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {\r\nif (!memcmp(flash_command_table[i].command,\r\ncmd_ptr, strlen(cmd_ptr))) {\r\nflash_command = flash_command_table[i].code;\r\nbreak;\r\n}\r\n}\r\nif (flash_command == FLASH_CMD_NONE) {\r\nerr = FAIL_PARAMETERS;\r\ngoto out1;\r\n}\r\nif (asd_ha->bios_status == FLASH_IN_PROGRESS) {\r\nerr = FLASH_IN_PROGRESS;\r\ngoto out1;\r\n}\r\nerr = request_firmware(&asd_ha->bios_image,\r\nfilename_ptr,\r\n&asd_ha->pcidev->dev);\r\nif (err) {\r\nasd_printk("Failed to load bios image file %s, error %d\n",\r\nfilename_ptr, err);\r\nerr = FAIL_OPEN_BIOS_FILE;\r\ngoto out1;\r\n}\r\nhdr_ptr = (struct bios_file_header *)asd_ha->bios_image->data;\r\nif ((hdr_ptr->contrl_id.vendor != asd_ha->pcidev->vendor ||\r\nhdr_ptr->contrl_id.device != asd_ha->pcidev->device) &&\r\n(hdr_ptr->contrl_id.sub_vendor != asd_ha->pcidev->vendor ||\r\nhdr_ptr->contrl_id.sub_device != asd_ha->pcidev->device)) {\r\nASD_DPRINTK("The PCI vendor or device id does not match\n");\r\nASD_DPRINTK("vendor=%x dev=%x sub_vendor=%x sub_dev=%x"\r\n" pci vendor=%x pci dev=%x\n",\r\nhdr_ptr->contrl_id.vendor,\r\nhdr_ptr->contrl_id.device,\r\nhdr_ptr->contrl_id.sub_vendor,\r\nhdr_ptr->contrl_id.sub_device,\r\nasd_ha->pcidev->vendor,\r\nasd_ha->pcidev->device);\r\nerr = FAIL_CHECK_PCI_ID;\r\ngoto out2;\r\n}\r\nif (hdr_ptr->filelen != asd_ha->bios_image->size) {\r\nerr = FAIL_FILE_SIZE;\r\ngoto out2;\r\n}\r\nfor (i = 0; i < hdr_ptr->filelen; i++)\r\ncsum += asd_ha->bios_image->data[i];\r\nif ((csum & 0x0000ffff) != hdr_ptr->checksum) {\r\nASD_DPRINTK("BIOS file checksum mismatch\n");\r\nerr = FAIL_CHECK_SUM;\r\ngoto out2;\r\n}\r\nif (flash_command == FLASH_CMD_UPDATE) {\r\nasd_ha->bios_status = FLASH_IN_PROGRESS;\r\nerr = asd_write_flash_seg(asd_ha,\r\n&asd_ha->bios_image->data[sizeof(*hdr_ptr)],\r\n0, hdr_ptr->filelen-sizeof(*hdr_ptr));\r\nif (!err)\r\nerr = asd_verify_flash_seg(asd_ha,\r\n&asd_ha->bios_image->data[sizeof(*hdr_ptr)],\r\n0, hdr_ptr->filelen-sizeof(*hdr_ptr));\r\n} else {\r\nasd_ha->bios_status = FLASH_IN_PROGRESS;\r\nerr = asd_verify_flash_seg(asd_ha,\r\n&asd_ha->bios_image->data[sizeof(header)],\r\n0, hdr_ptr->filelen-sizeof(header));\r\n}\r\nout2:\r\nrelease_firmware(asd_ha->bios_image);\r\nout1:\r\nkfree(cmd_ptr);\r\nout:\r\nasd_ha->bios_status = err;\r\nif (!err)\r\nreturn count;\r\nelse\r\nreturn -err;\r\n}\r\nstatic ssize_t asd_show_update_bios(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\r\nfor (i = 0; flash_error_table[i].err_code != 0; i++) {\r\nif (flash_error_table[i].err_code == asd_ha->bios_status)\r\nbreak;\r\n}\r\nif (asd_ha->bios_status != FLASH_IN_PROGRESS)\r\nasd_ha->bios_status = FLASH_OK;\r\nreturn snprintf(buf, PAGE_SIZE, "status=%x %s\n",\r\nflash_error_table[i].err_code,\r\nflash_error_table[i].reason);\r\n}\r\nstatic int asd_create_dev_attrs(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nerr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_revision);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\r\nif (err)\r\ngoto err_rev;\r\nerr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\r\nif (err)\r\ngoto err_biosb;\r\nerr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_update_bios);\r\nif (err)\r\ngoto err_update_bios;\r\nreturn 0;\r\nerr_update_bios:\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\r\nerr_biosb:\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\r\nerr_rev:\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_revision);\r\nreturn err;\r\n}\r\nstatic void asd_remove_dev_attrs(struct asd_ha_struct *asd_ha)\r\n{\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_revision);\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\r\ndevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_update_bios);\r\n}\r\nstatic int asd_create_ha_caches(struct asd_ha_struct *asd_ha)\r\n{\r\nasd_ha->scb_pool = dma_pool_create(ASD_DRIVER_NAME "_scb_pool",\r\n&asd_ha->pcidev->dev,\r\nsizeof(struct scb),\r\n8, 0);\r\nif (!asd_ha->scb_pool) {\r\nasd_printk("couldn't create scb pool\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void asd_free_edbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint i;\r\nfor (i = 0; i < seq->num_edbs; i++)\r\nasd_free_coherent(asd_ha, seq->edb_arr[i]);\r\nkfree(seq->edb_arr);\r\nseq->edb_arr = NULL;\r\n}\r\nstatic void asd_free_escbs(struct asd_ha_struct *asd_ha)\r\n{\r\nstruct asd_seq_data *seq = &asd_ha->seq;\r\nint i;\r\nfor (i = 0; i < seq->num_escbs; i++) {\r\nif (!list_empty(&seq->escb_arr[i]->list))\r\nlist_del_init(&seq->escb_arr[i]->list);\r\nasd_ascb_free(seq->escb_arr[i]);\r\n}\r\nkfree(seq->escb_arr);\r\nseq->escb_arr = NULL;\r\n}\r\nstatic void asd_destroy_ha_caches(struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nif (asd_ha->hw_prof.ddb_ext)\r\nasd_free_coherent(asd_ha, asd_ha->hw_prof.ddb_ext);\r\nif (asd_ha->hw_prof.scb_ext)\r\nasd_free_coherent(asd_ha, asd_ha->hw_prof.scb_ext);\r\nif (asd_ha->hw_prof.ddb_bitmap)\r\nkfree(asd_ha->hw_prof.ddb_bitmap);\r\nasd_ha->hw_prof.ddb_bitmap = NULL;\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nstruct asd_phy *phy = &asd_ha->phys[i];\r\nasd_free_coherent(asd_ha, phy->id_frm_tok);\r\n}\r\nif (asd_ha->seq.escb_arr)\r\nasd_free_escbs(asd_ha);\r\nif (asd_ha->seq.edb_arr)\r\nasd_free_edbs(asd_ha);\r\nif (asd_ha->hw_prof.ue.area) {\r\nkfree(asd_ha->hw_prof.ue.area);\r\nasd_ha->hw_prof.ue.area = NULL;\r\n}\r\nif (asd_ha->seq.tc_index_array) {\r\nkfree(asd_ha->seq.tc_index_array);\r\nkfree(asd_ha->seq.tc_index_bitmap);\r\nasd_ha->seq.tc_index_array = NULL;\r\nasd_ha->seq.tc_index_bitmap = NULL;\r\n}\r\nif (asd_ha->seq.actual_dl) {\r\nasd_free_coherent(asd_ha, asd_ha->seq.actual_dl);\r\nasd_ha->seq.actual_dl = NULL;\r\nasd_ha->seq.dl = NULL;\r\n}\r\nif (asd_ha->seq.next_scb.vaddr) {\r\ndma_pool_free(asd_ha->scb_pool, asd_ha->seq.next_scb.vaddr,\r\nasd_ha->seq.next_scb.dma_handle);\r\nasd_ha->seq.next_scb.vaddr = NULL;\r\n}\r\ndma_pool_destroy(asd_ha->scb_pool);\r\nasd_ha->scb_pool = NULL;\r\n}\r\nstatic int asd_create_global_caches(void)\r\n{\r\nif (!asd_dma_token_cache) {\r\nasd_dma_token_cache\r\n= kmem_cache_create(ASD_DRIVER_NAME "_dma_token",\r\nsizeof(struct asd_dma_tok),\r\n0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!asd_dma_token_cache) {\r\nasd_printk("couldn't create dma token cache\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!asd_ascb_cache) {\r\nasd_ascb_cache = kmem_cache_create(ASD_DRIVER_NAME "_ascb",\r\nsizeof(struct asd_ascb),\r\n0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!asd_ascb_cache) {\r\nasd_printk("couldn't create ascb cache\n");\r\ngoto Err;\r\n}\r\n}\r\nreturn 0;\r\nErr:\r\nkmem_cache_destroy(asd_dma_token_cache);\r\nasd_dma_token_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void asd_destroy_global_caches(void)\r\n{\r\nif (asd_dma_token_cache)\r\nkmem_cache_destroy(asd_dma_token_cache);\r\nasd_dma_token_cache = NULL;\r\nif (asd_ascb_cache)\r\nkmem_cache_destroy(asd_ascb_cache);\r\nasd_ascb_cache = NULL;\r\n}\r\nstatic int asd_register_sas_ha(struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nstruct asd_sas_phy **sas_phys =\r\nkcalloc(ASD_MAX_PHYS, sizeof(*sas_phys), GFP_KERNEL);\r\nstruct asd_sas_port **sas_ports =\r\nkcalloc(ASD_MAX_PHYS, sizeof(*sas_ports), GFP_KERNEL);\r\nif (!sas_phys || !sas_ports) {\r\nkfree(sas_phys);\r\nkfree(sas_ports);\r\nreturn -ENOMEM;\r\n}\r\nasd_ha->sas_ha.sas_ha_name = (char *) asd_ha->name;\r\nasd_ha->sas_ha.lldd_module = THIS_MODULE;\r\nasd_ha->sas_ha.sas_addr = &asd_ha->hw_prof.sas_addr[0];\r\nfor (i = 0; i < ASD_MAX_PHYS; i++) {\r\nsas_phys[i] = &asd_ha->phys[i].sas_phy;\r\nsas_ports[i] = &asd_ha->ports[i];\r\n}\r\nasd_ha->sas_ha.sas_phy = sas_phys;\r\nasd_ha->sas_ha.sas_port= sas_ports;\r\nasd_ha->sas_ha.num_phys= ASD_MAX_PHYS;\r\nreturn sas_register_ha(&asd_ha->sas_ha);\r\n}\r\nstatic int asd_unregister_sas_ha(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nscsi_remove_host(asd_ha->sas_ha.core.shost);\r\nerr = sas_unregister_ha(&asd_ha->sas_ha);\r\nsas_remove_host(asd_ha->sas_ha.core.shost);\r\nscsi_host_put(asd_ha->sas_ha.core.shost);\r\nkfree(asd_ha->sas_ha.sas_phy);\r\nkfree(asd_ha->sas_ha.sas_port);\r\nreturn err;\r\n}\r\nstatic int asd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nconst struct asd_pcidev_struct *asd_dev;\r\nunsigned asd_id = (unsigned) id->driver_data;\r\nstruct asd_ha_struct *asd_ha;\r\nstruct Scsi_Host *shost;\r\nint err;\r\nif (asd_id >= ARRAY_SIZE(asd_pcidev_data)) {\r\nasd_printk("wrong driver_data in PCI table\n");\r\nreturn -ENODEV;\r\n}\r\nif ((err = pci_enable_device(dev))) {\r\nasd_printk("couldn't enable device %s\n", pci_name(dev));\r\nreturn err;\r\n}\r\npci_set_master(dev);\r\nerr = -ENOMEM;\r\nshost = scsi_host_alloc(&aic94xx_sht, sizeof(void *));\r\nif (!shost)\r\ngoto Err;\r\nasd_dev = &asd_pcidev_data[asd_id];\r\nasd_ha = kzalloc(sizeof(*asd_ha), GFP_KERNEL);\r\nif (!asd_ha) {\r\nasd_printk("out of memory\n");\r\ngoto Err_put;\r\n}\r\nasd_ha->pcidev = dev;\r\nasd_ha->sas_ha.dev = &asd_ha->pcidev->dev;\r\nasd_ha->sas_ha.lldd_ha = asd_ha;\r\nasd_ha->bios_status = FLASH_OK;\r\nasd_ha->name = asd_dev->name;\r\nasd_printk("found %s, device %s\n", asd_ha->name, pci_name(dev));\r\nSHOST_TO_SAS_HA(shost) = &asd_ha->sas_ha;\r\nasd_ha->sas_ha.core.shost = shost;\r\nshost->transportt = aic94xx_transport_template;\r\nshost->max_id = ~0;\r\nshost->max_lun = ~0;\r\nshost->max_cmd_len = 16;\r\nerr = scsi_add_host(shost, &dev->dev);\r\nif (err)\r\ngoto Err_free;\r\nerr = asd_dev->setup(asd_ha);\r\nif (err)\r\ngoto Err_remove;\r\nerr = -ENODEV;\r\nif (!pci_set_dma_mask(dev, DMA_BIT_MASK(64))\r\n&& !pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(64)))\r\n;\r\nelse if (!pci_set_dma_mask(dev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(32)))\r\n;\r\nelse {\r\nasd_printk("no suitable DMA mask for %s\n", pci_name(dev));\r\ngoto Err_remove;\r\n}\r\npci_set_drvdata(dev, asd_ha);\r\nerr = asd_map_ha(asd_ha);\r\nif (err)\r\ngoto Err_remove;\r\nerr = asd_create_ha_caches(asd_ha);\r\nif (err)\r\ngoto Err_unmap;\r\nerr = asd_init_hw(asd_ha);\r\nif (err)\r\ngoto Err_free_cache;\r\nasd_printk("device %s: SAS addr %llx, PCBA SN %s, %d phys, %d enabled "\r\n"phys, flash %s, BIOS %s%d\n",\r\npci_name(dev), SAS_ADDR(asd_ha->hw_prof.sas_addr),\r\nasd_ha->hw_prof.pcba_sn, asd_ha->hw_prof.max_phys,\r\nasd_ha->hw_prof.num_phys,\r\nasd_ha->hw_prof.flash.present ? "present" : "not present",\r\nasd_ha->hw_prof.bios.present ? "build " : "not present",\r\nasd_ha->hw_prof.bios.bld);\r\nshost->can_queue = asd_ha->seq.can_queue;\r\nif (use_msi)\r\npci_enable_msi(asd_ha->pcidev);\r\nerr = request_irq(asd_ha->pcidev->irq, asd_hw_isr, IRQF_SHARED,\r\nASD_DRIVER_NAME, asd_ha);\r\nif (err) {\r\nasd_printk("couldn't get irq %d for %s\n",\r\nasd_ha->pcidev->irq, pci_name(asd_ha->pcidev));\r\ngoto Err_irq;\r\n}\r\nasd_enable_ints(asd_ha);\r\nerr = asd_init_post_escbs(asd_ha);\r\nif (err) {\r\nasd_printk("couldn't post escbs for %s\n",\r\npci_name(asd_ha->pcidev));\r\ngoto Err_escbs;\r\n}\r\nASD_DPRINTK("escbs posted\n");\r\nerr = asd_create_dev_attrs(asd_ha);\r\nif (err)\r\ngoto Err_dev_attrs;\r\nerr = asd_register_sas_ha(asd_ha);\r\nif (err)\r\ngoto Err_reg_sas;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nErr_reg_sas:\r\nasd_remove_dev_attrs(asd_ha);\r\nErr_dev_attrs:\r\nErr_escbs:\r\nasd_disable_ints(asd_ha);\r\nfree_irq(dev->irq, asd_ha);\r\nErr_irq:\r\nif (use_msi)\r\npci_disable_msi(dev);\r\nasd_chip_hardrst(asd_ha);\r\nErr_free_cache:\r\nasd_destroy_ha_caches(asd_ha);\r\nErr_unmap:\r\nasd_unmap_ha(asd_ha);\r\nErr_remove:\r\nscsi_remove_host(shost);\r\nErr_free:\r\nkfree(asd_ha);\r\nErr_put:\r\nscsi_host_put(shost);\r\nErr:\r\npci_disable_device(dev);\r\nreturn err;\r\n}\r\nstatic void asd_free_queues(struct asd_ha_struct *asd_ha)\r\n{\r\nunsigned long flags;\r\nLIST_HEAD(pending);\r\nstruct list_head *n, *pos;\r\nspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\r\nasd_ha->seq.pending = 0;\r\nlist_splice_init(&asd_ha->seq.pend_q, &pending);\r\nspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\r\nif (!list_empty(&pending))\r\nASD_DPRINTK("Uh-oh! Pending is not empty!\n");\r\nlist_for_each_safe(pos, n, &pending) {\r\nstruct asd_ascb *ascb = list_entry(pos, struct asd_ascb, list);\r\ndel_timer_sync(&ascb->timer);\r\nWARN_ON(ascb->scb->header.opcode != CONTROL_PHY);\r\nlist_del_init(pos);\r\nASD_DPRINTK("freeing from pending\n");\r\nasd_ascb_free(ascb);\r\n}\r\n}\r\nstatic void asd_turn_off_leds(struct asd_ha_struct *asd_ha)\r\n{\r\nu8 phy_mask = asd_ha->hw_prof.enabled_phys;\r\nu8 i;\r\nfor_each_phy(phy_mask, phy_mask, i) {\r\nasd_turn_led(asd_ha, i, 0);\r\nasd_control_led(asd_ha, i, 0);\r\n}\r\n}\r\nstatic void asd_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct asd_ha_struct *asd_ha = pci_get_drvdata(dev);\r\nif (!asd_ha)\r\nreturn;\r\nasd_unregister_sas_ha(asd_ha);\r\nasd_disable_ints(asd_ha);\r\nasd_remove_dev_attrs(asd_ha);\r\nfree_irq(dev->irq, asd_ha);\r\nif (use_msi)\r\npci_disable_msi(asd_ha->pcidev);\r\nasd_turn_off_leds(asd_ha);\r\nasd_chip_hardrst(asd_ha);\r\nasd_free_queues(asd_ha);\r\nasd_destroy_ha_caches(asd_ha);\r\nasd_unmap_ha(asd_ha);\r\nkfree(asd_ha);\r\npci_disable_device(dev);\r\nreturn;\r\n}\r\nstatic void asd_scan_start(struct Scsi_Host *shost)\r\n{\r\nstruct asd_ha_struct *asd_ha;\r\nint err;\r\nasd_ha = SHOST_TO_SAS_HA(shost)->lldd_ha;\r\nerr = asd_enable_phys(asd_ha, asd_ha->hw_prof.enabled_phys);\r\nif (err)\r\nasd_printk("Couldn't enable phys, err:%d\n", err);\r\n}\r\nstatic int asd_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nif (time < HZ)\r\nreturn 0;\r\nsas_drain_work(SHOST_TO_SAS_HA(shost));\r\nreturn 1;\r\n}\r\nstatic ssize_t asd_version_show(struct device_driver *driver, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ASD_DRIVER_VERSION);\r\n}\r\nstatic int asd_create_driver_attrs(struct device_driver *driver)\r\n{\r\nreturn driver_create_file(driver, &driver_attr_version);\r\n}\r\nstatic void asd_remove_driver_attrs(struct device_driver *driver)\r\n{\r\ndriver_remove_file(driver, &driver_attr_version);\r\n}\r\nstatic int __init aic94xx_init(void)\r\n{\r\nint err;\r\nasd_printk("%s version %s loaded\n", ASD_DRIVER_DESCRIPTION,\r\nASD_DRIVER_VERSION);\r\nerr = asd_create_global_caches();\r\nif (err)\r\nreturn err;\r\naic94xx_transport_template =\r\nsas_domain_attach_transport(&aic94xx_transport_functions);\r\nif (!aic94xx_transport_template)\r\ngoto out_destroy_caches;\r\nerr = pci_register_driver(&aic94xx_pci_driver);\r\nif (err)\r\ngoto out_release_transport;\r\nerr = asd_create_driver_attrs(&aic94xx_pci_driver.driver);\r\nif (err)\r\ngoto out_unregister_pcidrv;\r\nreturn err;\r\nout_unregister_pcidrv:\r\npci_unregister_driver(&aic94xx_pci_driver);\r\nout_release_transport:\r\nsas_release_transport(aic94xx_transport_template);\r\nout_destroy_caches:\r\nasd_destroy_global_caches();\r\nreturn err;\r\n}\r\nstatic void __exit aic94xx_exit(void)\r\n{\r\nasd_remove_driver_attrs(&aic94xx_pci_driver.driver);\r\npci_unregister_driver(&aic94xx_pci_driver);\r\nsas_release_transport(aic94xx_transport_template);\r\nasd_release_firmware();\r\nasd_destroy_global_caches();\r\nasd_printk("%s version %s unloaded\n", ASD_DRIVER_DESCRIPTION,\r\nASD_DRIVER_VERSION);\r\n}
