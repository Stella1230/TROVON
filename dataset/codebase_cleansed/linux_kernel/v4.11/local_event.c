static void rxrpc_send_version_request(struct rxrpc_local *local,\r\nstruct rxrpc_host_header *hdr,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxrpc_wire_header whdr;\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct sockaddr_rxrpc srx;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\nsize_t len;\r\nint ret;\r\n_enter("");\r\nif (rxrpc_extract_addr_from_skb(&srx, skb) < 0)\r\nreturn;\r\nmsg.msg_name = &srx.transport;\r\nmsg.msg_namelen = srx.transport_len;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nwhdr.epoch = htonl(sp->hdr.epoch);\r\nwhdr.cid = htonl(sp->hdr.cid);\r\nwhdr.callNumber = htonl(sp->hdr.callNumber);\r\nwhdr.seq = 0;\r\nwhdr.serial = 0;\r\nwhdr.type = RXRPC_PACKET_TYPE_VERSION;\r\nwhdr.flags = RXRPC_LAST_PACKET | (~hdr->flags & RXRPC_CLIENT_INITIATED);\r\nwhdr.userStatus = 0;\r\nwhdr.securityIndex = 0;\r\nwhdr._rsvd = 0;\r\nwhdr.serviceId = htons(sp->hdr.serviceId);\r\niov[0].iov_base = &whdr;\r\niov[0].iov_len = sizeof(whdr);\r\niov[1].iov_base = (char *)rxrpc_version_string;\r\niov[1].iov_len = sizeof(rxrpc_version_string);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\n_proto("Tx VERSION (reply)");\r\nret = kernel_sendmsg(local->socket, &msg, iov, 2, len);\r\nif (ret < 0)\r\n_debug("sendmsg failed: %d", ret);\r\n_leave("");\r\n}\r\nvoid rxrpc_process_local_events(struct rxrpc_local *local)\r\n{\r\nstruct sk_buff *skb;\r\nchar v;\r\n_enter("");\r\nskb = skb_dequeue(&local->event_queue);\r\nif (skb) {\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nrxrpc_see_skb(skb, rxrpc_skb_rx_seen);\r\n_debug("{%d},{%u}", local->debug_id, sp->hdr.type);\r\nswitch (sp->hdr.type) {\r\ncase RXRPC_PACKET_TYPE_VERSION:\r\nif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\r\n&v, 1) < 0)\r\nreturn;\r\n_proto("Rx VERSION { %02x }", v);\r\nif (v == 0)\r\nrxrpc_send_version_request(local, &sp->hdr, skb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrxrpc_free_skb(skb, rxrpc_skb_rx_freed);\r\n}\r\n_leave("");\r\n}
