static void img_i2c_writel(struct img_i2c *i2c, u32 offset, u32 value)\r\n{\r\nwritel(value, i2c->base + offset);\r\n}\r\nstatic u32 img_i2c_readl(struct img_i2c *i2c, u32 offset)\r\n{\r\nreturn readl(i2c->base + offset);\r\n}\r\nstatic void img_i2c_wr_rd_fence(struct img_i2c *i2c)\r\n{\r\nif (i2c->need_wr_rd_fence) {\r\nimg_i2c_writel(i2c, SCB_CORE_REV_REG, 0);\r\nimg_i2c_writel(i2c, SCB_CORE_REV_REG, 0);\r\n}\r\n}\r\nstatic void img_i2c_switch_mode(struct img_i2c *i2c, enum img_i2c_mode mode)\r\n{\r\ni2c->mode = mode;\r\ni2c->int_enable = img_i2c_int_enable_by_mode[mode];\r\ni2c->line_status = 0;\r\n}\r\nstatic void img_i2c_raw_op(struct img_i2c *i2c)\r\n{\r\ni2c->raw_timeout = 0;\r\nimg_i2c_writel(i2c, SCB_OVERRIDE_REG,\r\nOVERRIDE_SCLKEN_OVR |\r\nOVERRIDE_SDATEN_OVR |\r\nOVERRIDE_MASTER |\r\nOVERRIDE_LINE_OVR_EN |\r\nOVERRIDE_DIRECT |\r\n((i2c->at_cur_cmd & OVERRIDE_CMD_MASK) << OVERRIDE_CMD_SHIFT) |\r\n(i2c->at_cur_data << OVERRIDE_DATA_SHIFT));\r\n}\r\nstatic const char *img_i2c_atomic_op_name(unsigned int cmd)\r\n{\r\nif (unlikely(cmd >= ARRAY_SIZE(img_i2c_atomic_cmd_names)))\r\nreturn "UNKNOWN";\r\nreturn img_i2c_atomic_cmd_names[cmd];\r\n}\r\nstatic void img_i2c_atomic_op(struct img_i2c *i2c, int cmd, u8 data)\r\n{\r\ni2c->at_cur_cmd = cmd;\r\ni2c->at_cur_data = data;\r\nif (cmd == CMD_GEN_DATA && i2c->mode == MODE_ATOMIC) {\r\nu32 line_status = img_i2c_readl(i2c, SCB_STATUS_REG);\r\nif (line_status & LINESTAT_SDAT_LINE_STATUS && !(data & 0x80)) {\r\nimg_i2c_switch_mode(i2c, MODE_RAW);\r\nimg_i2c_raw_op(i2c);\r\nreturn;\r\n}\r\n}\r\ndev_dbg(i2c->adap.dev.parent,\r\n"atomic cmd=%s (%d) data=%#x\n",\r\nimg_i2c_atomic_op_name(cmd), cmd, data);\r\ni2c->at_t_done = (cmd == CMD_RET_DATA || cmd == CMD_RET_ACK);\r\ni2c->at_slave_event = false;\r\ni2c->line_status = 0;\r\nimg_i2c_writel(i2c, SCB_OVERRIDE_REG,\r\n((cmd & OVERRIDE_CMD_MASK) << OVERRIDE_CMD_SHIFT) |\r\nOVERRIDE_MASTER |\r\nOVERRIDE_DIRECT |\r\n(data << OVERRIDE_DATA_SHIFT));\r\n}\r\nstatic void img_i2c_atomic_start(struct img_i2c *i2c)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_ATOMIC);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\nimg_i2c_atomic_op(i2c, CMD_GEN_START, 0x00);\r\n}\r\nstatic void img_i2c_soft_reset(struct img_i2c *i2c)\r\n{\r\ni2c->t_halt = false;\r\nimg_i2c_writel(i2c, SCB_CONTROL_REG, 0);\r\nimg_i2c_writel(i2c, SCB_CONTROL_REG,\r\nSCB_CONTROL_CLK_ENABLE | SCB_CONTROL_SOFT_RESET);\r\n}\r\nstatic void img_i2c_transaction_halt(struct img_i2c *i2c, bool t_halt)\r\n{\r\nu32 val;\r\nif (i2c->t_halt == t_halt)\r\nreturn;\r\ni2c->t_halt = t_halt;\r\nval = img_i2c_readl(i2c, SCB_CONTROL_REG);\r\nif (t_halt)\r\nval |= SCB_CONTROL_TRANSACTION_HALT;\r\nelse\r\nval &= ~SCB_CONTROL_TRANSACTION_HALT;\r\nimg_i2c_writel(i2c, SCB_CONTROL_REG, val);\r\n}\r\nstatic void img_i2c_read_fifo(struct img_i2c *i2c)\r\n{\r\nwhile (i2c->msg.len) {\r\nu32 fifo_status;\r\nu8 data;\r\nimg_i2c_wr_rd_fence(i2c);\r\nfifo_status = img_i2c_readl(i2c, SCB_FIFO_STATUS_REG);\r\nif (fifo_status & FIFO_READ_EMPTY)\r\nbreak;\r\ndata = img_i2c_readl(i2c, SCB_READ_DATA_REG);\r\n*i2c->msg.buf = data;\r\nimg_i2c_writel(i2c, SCB_READ_FIFO_REG, 0xff);\r\ni2c->msg.len--;\r\ni2c->msg.buf++;\r\n}\r\n}\r\nstatic void img_i2c_write_fifo(struct img_i2c *i2c)\r\n{\r\nwhile (i2c->msg.len) {\r\nu32 fifo_status;\r\nimg_i2c_wr_rd_fence(i2c);\r\nfifo_status = img_i2c_readl(i2c, SCB_FIFO_STATUS_REG);\r\nif (fifo_status & FIFO_WRITE_FULL)\r\nbreak;\r\nimg_i2c_writel(i2c, SCB_WRITE_DATA_REG, *i2c->msg.buf);\r\ni2c->msg.len--;\r\ni2c->msg.buf++;\r\n}\r\nif (!i2c->msg.len)\r\ni2c->int_enable &= ~INT_FIFO_EMPTYING;\r\n}\r\nstatic void img_i2c_read(struct img_i2c *i2c)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_AUTOMATIC);\r\nif (!i2c->last_msg)\r\ni2c->int_enable |= INT_SLAVE_EVENT;\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\nimg_i2c_writel(i2c, SCB_READ_ADDR_REG, i2c->msg.addr);\r\nimg_i2c_writel(i2c, SCB_READ_COUNT_REG, i2c->msg.len);\r\nmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\r\n}\r\nstatic void img_i2c_write(struct img_i2c *i2c)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_AUTOMATIC);\r\nif (!i2c->last_msg)\r\ni2c->int_enable |= INT_SLAVE_EVENT;\r\nimg_i2c_writel(i2c, SCB_WRITE_ADDR_REG, i2c->msg.addr);\r\nimg_i2c_writel(i2c, SCB_WRITE_COUNT_REG, i2c->msg.len);\r\nmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\r\nimg_i2c_write_fifo(i2c);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\n}\r\nstatic void img_i2c_complete_transaction(struct img_i2c *i2c, int status)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_INACTIVE);\r\nif (status) {\r\ni2c->msg_status = status;\r\nimg_i2c_transaction_halt(i2c, false);\r\n}\r\ncomplete(&i2c->msg_complete);\r\n}\r\nstatic unsigned int img_i2c_raw_atomic_delay_handler(struct img_i2c *i2c,\r\nu32 int_status, u32 line_status)\r\n{\r\nimg_i2c_atomic_op(i2c, i2c->at_cur_cmd, i2c->at_cur_data);\r\nimg_i2c_switch_mode(i2c, MODE_ATOMIC);\r\nreturn 0;\r\n}\r\nstatic unsigned int img_i2c_raw(struct img_i2c *i2c, u32 int_status,\r\nu32 line_status)\r\n{\r\nif (int_status & INT_TIMING) {\r\nif (i2c->raw_timeout == 0)\r\nreturn img_i2c_raw_atomic_delay_handler(i2c,\r\nint_status, line_status);\r\n--i2c->raw_timeout;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int img_i2c_sequence(struct img_i2c *i2c, u32 int_status)\r\n{\r\nstatic const unsigned int continue_bits[] = {\r\n[CMD_GEN_START] = LINESTAT_START_BIT_DET,\r\n[CMD_GEN_DATA] = LINESTAT_INPUT_HELD_V,\r\n[CMD_RET_ACK] = LINESTAT_ACK_DET | LINESTAT_NACK_DET,\r\n[CMD_RET_DATA] = LINESTAT_INPUT_HELD_V,\r\n[CMD_GEN_STOP] = LINESTAT_STOP_BIT_DET,\r\n};\r\nint next_cmd = -1;\r\nu8 next_data = 0x00;\r\nif (int_status & INT_SLAVE_EVENT)\r\ni2c->at_slave_event = true;\r\nif (int_status & INT_TRANSACTION_DONE)\r\ni2c->at_t_done = true;\r\nif (!i2c->at_slave_event || !i2c->at_t_done)\r\nreturn 0;\r\nif (i2c->at_cur_cmd >= 0 &&\r\ni2c->at_cur_cmd < ARRAY_SIZE(continue_bits)) {\r\nunsigned int cont_bits = continue_bits[i2c->at_cur_cmd];\r\nif (cont_bits) {\r\ncont_bits |= LINESTAT_ABORT_DET;\r\nif (!(i2c->line_status & cont_bits))\r\nreturn 0;\r\n}\r\n}\r\nnext_cmd = *i2c->seq;\r\nif (!next_cmd) {\r\nimg_i2c_writel(i2c, SCB_OVERRIDE_REG, 0);\r\nreturn ISR_COMPLETE(0);\r\n}\r\nif (next_cmd == CMD_GEN_DATA) {\r\n++i2c->seq;\r\nnext_data = *i2c->seq;\r\n}\r\n++i2c->seq;\r\nimg_i2c_atomic_op(i2c, next_cmd, next_data);\r\nreturn 0;\r\n}\r\nstatic void img_i2c_reset_start(struct img_i2c *i2c)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_SEQUENCE);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\ni2c->seq = img_i2c_reset_seq;\r\ni2c->at_slave_event = true;\r\ni2c->at_t_done = true;\r\ni2c->at_cur_cmd = -1;\r\nimg_i2c_sequence(i2c, 0);\r\n}\r\nstatic void img_i2c_stop_start(struct img_i2c *i2c)\r\n{\r\nimg_i2c_switch_mode(i2c, MODE_SEQUENCE);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\ni2c->seq = img_i2c_stop_seq;\r\ni2c->at_slave_event = true;\r\ni2c->at_t_done = true;\r\ni2c->at_cur_cmd = -1;\r\nimg_i2c_sequence(i2c, 0);\r\n}\r\nstatic unsigned int img_i2c_atomic(struct img_i2c *i2c,\r\nu32 int_status,\r\nu32 line_status)\r\n{\r\nint next_cmd = -1;\r\nu8 next_data = 0x00;\r\nif (int_status & INT_SLAVE_EVENT)\r\ni2c->at_slave_event = true;\r\nif (int_status & INT_TRANSACTION_DONE)\r\ni2c->at_t_done = true;\r\nif (!i2c->at_slave_event || !i2c->at_t_done)\r\ngoto next_atomic_cmd;\r\nif (i2c->line_status & LINESTAT_ABORT_DET) {\r\ndev_dbg(i2c->adap.dev.parent, "abort condition detected\n");\r\nnext_cmd = CMD_GEN_STOP;\r\ni2c->msg_status = -EIO;\r\ngoto next_atomic_cmd;\r\n}\r\nswitch (i2c->at_cur_cmd) {\r\ncase CMD_GEN_START:\r\nnext_cmd = CMD_GEN_DATA;\r\nnext_data = i2c_8bit_addr_from_msg(&i2c->msg);\r\nbreak;\r\ncase CMD_GEN_DATA:\r\nif (i2c->line_status & LINESTAT_INPUT_HELD_V)\r\nnext_cmd = CMD_RET_ACK;\r\nbreak;\r\ncase CMD_RET_ACK:\r\nif (i2c->line_status & LINESTAT_ACK_DET ||\r\n(i2c->line_status & LINESTAT_NACK_DET &&\r\ni2c->msg.flags & I2C_M_IGNORE_NAK)) {\r\nif (i2c->msg.len == 0) {\r\nnext_cmd = CMD_GEN_STOP;\r\n} else if (i2c->msg.flags & I2C_M_RD) {\r\nnext_cmd = CMD_RET_DATA;\r\n} else {\r\nnext_cmd = CMD_GEN_DATA;\r\nnext_data = *i2c->msg.buf;\r\n--i2c->msg.len;\r\n++i2c->msg.buf;\r\n}\r\n} else if (i2c->line_status & LINESTAT_NACK_DET) {\r\ni2c->msg_status = -EIO;\r\nnext_cmd = CMD_GEN_STOP;\r\n}\r\nbreak;\r\ncase CMD_RET_DATA:\r\nif (i2c->line_status & LINESTAT_INPUT_HELD_V) {\r\n*i2c->msg.buf = (i2c->line_status &\r\nLINESTAT_INPUT_DATA)\r\n>> LINESTAT_INPUT_DATA_SHIFT;\r\n--i2c->msg.len;\r\n++i2c->msg.buf;\r\nif (i2c->msg.len)\r\nnext_cmd = CMD_GEN_ACK;\r\nelse\r\nnext_cmd = CMD_GEN_NACK;\r\n}\r\nbreak;\r\ncase CMD_GEN_ACK:\r\nif (i2c->line_status & LINESTAT_ACK_DET) {\r\nnext_cmd = CMD_RET_DATA;\r\n} else {\r\ni2c->msg_status = -EIO;\r\nnext_cmd = CMD_GEN_STOP;\r\n}\r\nbreak;\r\ncase CMD_GEN_NACK:\r\nnext_cmd = CMD_GEN_STOP;\r\nbreak;\r\ncase CMD_GEN_STOP:\r\nimg_i2c_writel(i2c, SCB_OVERRIDE_REG, 0);\r\nreturn ISR_COMPLETE(0);\r\ndefault:\r\ndev_err(i2c->adap.dev.parent, "bad atomic command %d\n",\r\ni2c->at_cur_cmd);\r\ni2c->msg_status = -EIO;\r\nnext_cmd = CMD_GEN_STOP;\r\nbreak;\r\n}\r\nnext_atomic_cmd:\r\nif (next_cmd != -1) {\r\nif (next_cmd == CMD_GEN_STOP && !i2c->msg_status &&\r\n!i2c->last_msg)\r\nreturn ISR_COMPLETE(0);\r\nimg_i2c_atomic_op(i2c, next_cmd, next_data);\r\n}\r\nreturn 0;\r\n}\r\nstatic void img_i2c_check_timer(unsigned long arg)\r\n{\r\nstruct img_i2c *i2c = (struct img_i2c *)arg;\r\nunsigned long flags;\r\nunsigned int line_status;\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nline_status = img_i2c_readl(i2c, SCB_STATUS_REG);\r\nif (line_status & LINESTAT_ABORT_DET) {\r\ndev_dbg(i2c->adap.dev.parent,\r\n"abort condition detected by check timer\n");\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG,\r\ni2c->int_enable | INT_SLAVE_EVENT);\r\n}\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\n}\r\nstatic unsigned int img_i2c_auto(struct img_i2c *i2c,\r\nunsigned int int_status,\r\nunsigned int line_status)\r\n{\r\nif (int_status & (INT_WRITE_ACK_ERR | INT_ADDR_ACK_ERR))\r\nreturn ISR_COMPLETE(EIO);\r\nif (line_status & LINESTAT_ABORT_DET) {\r\ndev_dbg(i2c->adap.dev.parent, "abort condition detected\n");\r\nif ((i2c->msg.flags & I2C_M_RD) &&\r\n(int_status & INT_FIFO_FULL_FILLING))\r\nimg_i2c_read_fifo(i2c);\r\ni2c->msg_status = -EIO;\r\nimg_i2c_stop_start(i2c);\r\nreturn 0;\r\n}\r\nif (!i2c->last_msg && line_status & LINESTAT_START_BIT_DET) {\r\nimg_i2c_transaction_halt(i2c, !i2c->last_msg);\r\ni2c->int_enable &= ~INT_SLAVE_EVENT;\r\n}\r\nmod_timer(&i2c->check_timer, jiffies + msecs_to_jiffies(1));\r\nif (int_status & INT_STOP_DETECTED) {\r\nif (i2c->msg.flags & I2C_M_RD)\r\nimg_i2c_read_fifo(i2c);\r\nreturn ISR_COMPLETE(0);\r\n}\r\nif (i2c->msg.flags & I2C_M_RD) {\r\nif (int_status & (INT_FIFO_FULL_FILLING | INT_MASTER_HALTED)) {\r\nimg_i2c_read_fifo(i2c);\r\nif (i2c->msg.len == 0)\r\nreturn ISR_WAITSTOP;\r\n}\r\n} else {\r\nif (int_status & (INT_FIFO_EMPTY | INT_MASTER_HALTED)) {\r\nif ((int_status & INT_FIFO_EMPTY) &&\r\ni2c->msg.len == 0)\r\nreturn ISR_WAITSTOP;\r\nimg_i2c_write_fifo(i2c);\r\n}\r\n}\r\nif (int_status & INT_MASTER_HALTED) {\r\nimg_i2c_transaction_halt(i2c, false);\r\nimg_i2c_transaction_halt(i2c, !i2c->last_msg);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t img_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct img_i2c *i2c = (struct img_i2c *)dev_id;\r\nu32 int_status, line_status;\r\nunsigned int hret;\r\nint_status = img_i2c_readl(i2c, SCB_INT_STATUS_REG);\r\nimg_i2c_writel(i2c, SCB_INT_CLEAR_REG, int_status);\r\nline_status = img_i2c_readl(i2c, SCB_STATUS_REG);\r\nif (line_status & LINESTAT_LATCHED) {\r\nimg_i2c_writel(i2c, SCB_CLEAR_REG,\r\n(line_status & LINESTAT_LATCHED)\r\n>> LINESTAT_CLEAR_SHIFT);\r\nimg_i2c_wr_rd_fence(i2c);\r\n}\r\nspin_lock(&i2c->lock);\r\ni2c->line_status &= ~LINESTAT_INPUT_DATA;\r\ni2c->line_status |= line_status;\r\nif ((int_status & INT_SCLK_LOW_TIMEOUT) &&\r\n!(int_status & (INT_SLAVE_EVENT |\r\nINT_FIFO_EMPTY |\r\nINT_FIFO_FULL))) {\r\ndev_crit(i2c->adap.dev.parent,\r\n"fatal: clock low timeout occurred %s addr 0x%02x\n",\r\n(i2c->msg.flags & I2C_M_RD) ? "reading" : "writing",\r\ni2c->msg.addr);\r\nhret = ISR_FATAL(EIO);\r\ngoto out;\r\n}\r\nif (i2c->mode == MODE_ATOMIC)\r\nhret = img_i2c_atomic(i2c, int_status, line_status);\r\nelse if (i2c->mode == MODE_AUTOMATIC)\r\nhret = img_i2c_auto(i2c, int_status, line_status);\r\nelse if (i2c->mode == MODE_SEQUENCE)\r\nhret = img_i2c_sequence(i2c, int_status);\r\nelse if (i2c->mode == MODE_WAITSTOP && (int_status & INT_SLAVE_EVENT) &&\r\n(line_status & LINESTAT_STOP_BIT_DET))\r\nhret = ISR_COMPLETE(0);\r\nelse if (i2c->mode == MODE_RAW)\r\nhret = img_i2c_raw(i2c, int_status, line_status);\r\nelse\r\nhret = 0;\r\nimg_i2c_writel(i2c, SCB_INT_CLEAR_REG, int_status & INT_LEVEL);\r\nout:\r\nif (hret & ISR_WAITSTOP) {\r\nif (!i2c->last_msg || i2c->line_status & LINESTAT_STOP_BIT_DET)\r\nhret = ISR_COMPLETE(0);\r\nelse\r\nimg_i2c_switch_mode(i2c, MODE_WAITSTOP);\r\n}\r\nif (hret & ISR_COMPLETE_M) {\r\nint status = -(hret & ISR_STATUS_M);\r\nimg_i2c_complete_transaction(i2c, status);\r\nif (hret & ISR_FATAL_M)\r\nimg_i2c_switch_mode(i2c, MODE_FATAL);\r\n}\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\nspin_unlock(&i2c->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int img_i2c_reset_bus(struct img_i2c *i2c)\r\n{\r\nunsigned long flags;\r\nunsigned long time_left;\r\nspin_lock_irqsave(&i2c->lock, flags);\r\nreinit_completion(&i2c->msg_complete);\r\nimg_i2c_reset_start(i2c);\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\ntime_left = wait_for_completion_timeout(&i2c->msg_complete,\r\nIMG_I2C_TIMEOUT);\r\nif (time_left == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int img_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct img_i2c *i2c = i2c_get_adapdata(adap);\r\nbool atomic = false;\r\nint i, ret;\r\nunsigned long time_left;\r\nif (i2c->mode == MODE_SUSPEND) {\r\nWARN(1, "refusing to service transaction in suspended state\n");\r\nreturn -EIO;\r\n}\r\nif (i2c->mode == MODE_FATAL)\r\nreturn -EIO;\r\nfor (i = 0; i < num; i++) {\r\nif (!msgs[i].len && msgs[i].flags & I2C_M_RD)\r\nreturn -EIO;\r\nif (!msgs[i].len ||\r\n(msgs[i].flags & I2C_M_IGNORE_NAK))\r\natomic = true;\r\n}\r\nret = clk_prepare_enable(i2c->scb_clk);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < num; i++) {\r\nstruct i2c_msg *msg = &msgs[i];\r\nunsigned long flags;\r\nspin_lock_irqsave(&i2c->lock, flags);\r\ni2c->msg = *msg;\r\ni2c->msg_status = 0;\r\ni2c->last_msg = (i == num - 1);\r\nreinit_completion(&i2c->msg_complete);\r\nimg_i2c_writel(i2c, SCB_INT_CLEAR_REG, ~0);\r\nimg_i2c_writel(i2c, SCB_CLEAR_REG, ~0);\r\nif (atomic) {\r\nimg_i2c_atomic_start(i2c);\r\n} else {\r\nimg_i2c_transaction_halt(i2c, !i2c->last_msg);\r\nif (msg->flags & I2C_M_RD)\r\nimg_i2c_read(i2c);\r\nelse\r\nimg_i2c_write(i2c);\r\nimg_i2c_transaction_halt(i2c, false);\r\nimg_i2c_transaction_halt(i2c, !i2c->last_msg);\r\n}\r\nspin_unlock_irqrestore(&i2c->lock, flags);\r\ntime_left = wait_for_completion_timeout(&i2c->msg_complete,\r\nIMG_I2C_TIMEOUT);\r\ndel_timer_sync(&i2c->check_timer);\r\nif (time_left == 0) {\r\ndev_err(adap->dev.parent, "i2c transfer timed out\n");\r\ni2c->msg_status = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (i2c->msg_status)\r\nbreak;\r\n}\r\nclk_disable_unprepare(i2c->scb_clk);\r\nreturn i2c->msg_status ? i2c->msg_status : num;\r\n}\r\nstatic u32 img_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int img_i2c_init(struct img_i2c *i2c)\r\n{\r\nunsigned int clk_khz, bitrate_khz, clk_period, tckh, tckl, tsdh;\r\nunsigned int i, ret, data, prescale, inc, int_bitrate, filt;\r\nstruct img_i2c_timings timing;\r\nu32 rev;\r\nret = clk_prepare_enable(i2c->scb_clk);\r\nif (ret)\r\nreturn ret;\r\nrev = img_i2c_readl(i2c, SCB_CORE_REV_REG);\r\nif ((rev & 0x00ffffff) < 0x00020200) {\r\ndev_info(i2c->adap.dev.parent,\r\n"Unknown hardware revision (%d.%d.%d.%d)\n",\r\n(rev >> 24) & 0xff, (rev >> 16) & 0xff,\r\n(rev >> 8) & 0xff, rev & 0xff);\r\nclk_disable_unprepare(i2c->scb_clk);\r\nreturn -EINVAL;\r\n}\r\ni2c->need_wr_rd_fence = true;\r\ntiming = timings[0];\r\nfor (i = 0; i < ARRAY_SIZE(timings); i++) {\r\nif (i2c->bitrate <= timings[i].max_bitrate) {\r\ntiming = timings[i];\r\nbreak;\r\n}\r\n}\r\nif (i2c->bitrate > timings[ARRAY_SIZE(timings) - 1].max_bitrate) {\r\ndev_warn(i2c->adap.dev.parent,\r\n"requested bitrate (%u) is higher than the max bitrate supported (%u)\n",\r\ni2c->bitrate,\r\ntimings[ARRAY_SIZE(timings) - 1].max_bitrate);\r\ntiming = timings[ARRAY_SIZE(timings) - 1];\r\ni2c->bitrate = timing.max_bitrate;\r\n}\r\nbitrate_khz = i2c->bitrate / 1000;\r\nclk_khz = clk_get_rate(i2c->scb_clk) / 1000;\r\nprescale = SCB_OPT_INC * clk_khz / (256 * 16 * bitrate_khz);\r\nprescale = clamp_t(unsigned int, prescale, 1, 8);\r\nclk_khz /= prescale;\r\ninc = (256 * 16 * bitrate_khz) / clk_khz;\r\nif (clk_khz < 20000) {\r\nfilt = SCB_FILT_DISABLE;\r\n} else if (clk_khz < 40000) {\r\nfilt = SCB_FILT_BYPASS;\r\n} else {\r\nfilt = (64000 / ((clk_khz / 1000) * SCB_FILT_GLITCH));\r\nif (64000 % ((clk_khz / 1000) * SCB_FILT_GLITCH))\r\ninc++;\r\nif (filt > SCB_FILT_INC_MASK)\r\nfilt = SCB_FILT_INC_MASK;\r\nfilt = (filt & SCB_FILT_INC_MASK) << SCB_FILT_INC_SHIFT;\r\n}\r\ndata = filt | ((inc & SCB_INC_MASK) << SCB_INC_SHIFT) | (prescale - 1);\r\nimg_i2c_writel(i2c, SCB_CLK_SET_REG, data);\r\nclk_period = (256 * 1000000) / (clk_khz * inc);\r\nint_bitrate = 1000000 / (bitrate_khz * clk_period);\r\nif ((1000000 % (bitrate_khz * clk_period)) >=\r\n((bitrate_khz * clk_period) / 2))\r\nint_bitrate++;\r\ntckh = int_bitrate / 2;\r\ntckl = int_bitrate - tckh;\r\ndata = DIV_ROUND_UP(timing.tckl, clk_period);\r\nif (tckl < data) {\r\ntckl = data;\r\ntckh = int_bitrate - tckl;\r\n}\r\nif (tckh > 0)\r\n--tckh;\r\nif (tckl > 0)\r\n--tckl;\r\nimg_i2c_writel(i2c, SCB_TIME_TCKH_REG, tckh);\r\nimg_i2c_writel(i2c, SCB_TIME_TCKL_REG, tckl);\r\ntsdh = DIV_ROUND_UP(timing.tsdh, clk_period);\r\nif (tsdh > 1)\r\ndata = tsdh - 1;\r\nelse\r\ndata = 0x01;\r\nimg_i2c_writel(i2c, SCB_TIME_TSDH_REG, data);\r\ntsdh = data;\r\ndata = timing.tpl / clk_period;\r\nif (data > 0)\r\n--data;\r\nimg_i2c_writel(i2c, SCB_TIME_TPL_REG, data);\r\ndata = timing.tph / clk_period;\r\nif (data > 0)\r\n--data;\r\nimg_i2c_writel(i2c, SCB_TIME_TPH_REG, data);\r\nimg_i2c_writel(i2c, SCB_TIME_TSDL_REG, data + tsdh + 2);\r\ndata = timing.tp2s / clk_period;\r\nif (data > 0)\r\n--data;\r\nimg_i2c_writel(i2c, SCB_TIME_TP2S_REG, data);\r\nimg_i2c_writel(i2c, SCB_TIME_TBI_REG, TIMEOUT_TBI);\r\nimg_i2c_writel(i2c, SCB_TIME_TSL_REG, TIMEOUT_TSL);\r\nimg_i2c_writel(i2c, SCB_TIME_TDL_REG, TIMEOUT_TDL);\r\nimg_i2c_soft_reset(i2c);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, 0);\r\nimg_i2c_writel(i2c, SCB_INT_CLEAR_REG, ~0);\r\nimg_i2c_writel(i2c, SCB_CLEAR_REG, ~0);\r\nimg_i2c_writel(i2c, SCB_INT_MASK_REG, i2c->int_enable);\r\nret = img_i2c_reset_bus(i2c);\r\nclk_disable_unprepare(i2c->scb_clk);\r\nreturn ret;\r\n}\r\nstatic int img_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct img_i2c *i2c;\r\nstruct resource *res;\r\nint irq, ret;\r\nu32 val;\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(struct img_i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c->base))\r\nreturn PTR_ERR(i2c->base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "can't get irq number\n");\r\nreturn irq;\r\n}\r\ni2c->sys_clk = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(i2c->sys_clk)) {\r\ndev_err(&pdev->dev, "can't get system clock\n");\r\nreturn PTR_ERR(i2c->sys_clk);\r\n}\r\ni2c->scb_clk = devm_clk_get(&pdev->dev, "scb");\r\nif (IS_ERR(i2c->scb_clk)) {\r\ndev_err(&pdev->dev, "can't get core clock\n");\r\nreturn PTR_ERR(i2c->scb_clk);\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, img_i2c_isr, 0,\r\npdev->name, i2c);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't request irq %d\n", irq);\r\nreturn ret;\r\n}\r\ninit_timer(&i2c->check_timer);\r\ni2c->check_timer.function = img_i2c_check_timer;\r\ni2c->check_timer.data = (unsigned long)i2c;\r\ni2c->bitrate = timings[0].max_bitrate;\r\nif (!of_property_read_u32(node, "clock-frequency", &val))\r\ni2c->bitrate = val;\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = node;\r\ni2c->adap.owner = THIS_MODULE;\r\ni2c->adap.algo = &img_i2c_algo;\r\ni2c->adap.retries = 5;\r\ni2c->adap.nr = pdev->id;\r\nsnprintf(i2c->adap.name, sizeof(i2c->adap.name), "IMG SCB I2C");\r\nimg_i2c_switch_mode(i2c, MODE_INACTIVE);\r\nspin_lock_init(&i2c->lock);\r\ninit_completion(&i2c->msg_complete);\r\nplatform_set_drvdata(pdev, i2c);\r\nret = clk_prepare_enable(i2c->sys_clk);\r\nif (ret)\r\nreturn ret;\r\nret = img_i2c_init(i2c);\r\nif (ret)\r\ngoto disable_clk;\r\nret = i2c_add_numbered_adapter(&i2c->adap);\r\nif (ret < 0)\r\ngoto disable_clk;\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(i2c->sys_clk);\r\nreturn ret;\r\n}\r\nstatic int img_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct img_i2c *i2c = platform_get_drvdata(dev);\r\ni2c_del_adapter(&i2c->adap);\r\nclk_disable_unprepare(i2c->sys_clk);\r\nreturn 0;\r\n}\r\nstatic int img_i2c_suspend(struct device *dev)\r\n{\r\nstruct img_i2c *i2c = dev_get_drvdata(dev);\r\nimg_i2c_switch_mode(i2c, MODE_SUSPEND);\r\nclk_disable_unprepare(i2c->sys_clk);\r\nreturn 0;\r\n}\r\nstatic int img_i2c_resume(struct device *dev)\r\n{\r\nstruct img_i2c *i2c = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(i2c->sys_clk);\r\nif (ret)\r\nreturn ret;\r\nimg_i2c_init(i2c);\r\nreturn 0;\r\n}
