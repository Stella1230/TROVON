static void zcomp_strm_free(struct zcomp_strm *zstrm)\r\n{\r\nif (!IS_ERR_OR_NULL(zstrm->tfm))\r\ncrypto_free_comp(zstrm->tfm);\r\nfree_pages((unsigned long)zstrm->buffer, 1);\r\nkfree(zstrm);\r\n}\r\nstatic struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)\r\n{\r\nstruct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);\r\nif (!zstrm)\r\nreturn NULL;\r\nzstrm->tfm = crypto_alloc_comp(comp->name, 0, 0);\r\nzstrm->buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);\r\nif (IS_ERR_OR_NULL(zstrm->tfm) || !zstrm->buffer) {\r\nzcomp_strm_free(zstrm);\r\nzstrm = NULL;\r\n}\r\nreturn zstrm;\r\n}\r\nbool zcomp_available_algorithm(const char *comp)\r\n{\r\nint i = 0;\r\nwhile (backends[i]) {\r\nif (sysfs_streq(comp, backends[i]))\r\nreturn true;\r\ni++;\r\n}\r\nreturn crypto_has_comp(comp, 0, 0) == 1;\r\n}\r\nssize_t zcomp_available_show(const char *comp, char *buf)\r\n{\r\nbool known_algorithm = false;\r\nssize_t sz = 0;\r\nint i = 0;\r\nfor (; backends[i]; i++) {\r\nif (!strcmp(comp, backends[i])) {\r\nknown_algorithm = true;\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"[%s] ", backends[i]);\r\n} else {\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"%s ", backends[i]);\r\n}\r\n}\r\nif (!known_algorithm && crypto_has_comp(comp, 0, 0) == 1)\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz - 2,\r\n"[%s] ", comp);\r\nsz += scnprintf(buf + sz, PAGE_SIZE - sz, "\n");\r\nreturn sz;\r\n}\r\nstruct zcomp_strm *zcomp_stream_get(struct zcomp *comp)\r\n{\r\nreturn *get_cpu_ptr(comp->stream);\r\n}\r\nvoid zcomp_stream_put(struct zcomp *comp)\r\n{\r\nput_cpu_ptr(comp->stream);\r\n}\r\nint zcomp_compress(struct zcomp_strm *zstrm,\r\nconst void *src, unsigned int *dst_len)\r\n{\r\n*dst_len = PAGE_SIZE * 2;\r\nreturn crypto_comp_compress(zstrm->tfm,\r\nsrc, PAGE_SIZE,\r\nzstrm->buffer, dst_len);\r\n}\r\nint zcomp_decompress(struct zcomp_strm *zstrm,\r\nconst void *src, unsigned int src_len, void *dst)\r\n{\r\nunsigned int dst_len = PAGE_SIZE;\r\nreturn crypto_comp_decompress(zstrm->tfm,\r\nsrc, src_len,\r\ndst, &dst_len);\r\n}\r\nint zcomp_cpu_up_prepare(unsigned int cpu, struct hlist_node *node)\r\n{\r\nstruct zcomp *comp = hlist_entry(node, struct zcomp, node);\r\nstruct zcomp_strm *zstrm;\r\nif (WARN_ON(*per_cpu_ptr(comp->stream, cpu)))\r\nreturn 0;\r\nzstrm = zcomp_strm_alloc(comp);\r\nif (IS_ERR_OR_NULL(zstrm)) {\r\npr_err("Can't allocate a compression stream\n");\r\nreturn -ENOMEM;\r\n}\r\n*per_cpu_ptr(comp->stream, cpu) = zstrm;\r\nreturn 0;\r\n}\r\nint zcomp_cpu_dead(unsigned int cpu, struct hlist_node *node)\r\n{\r\nstruct zcomp *comp = hlist_entry(node, struct zcomp, node);\r\nstruct zcomp_strm *zstrm;\r\nzstrm = *per_cpu_ptr(comp->stream, cpu);\r\nif (!IS_ERR_OR_NULL(zstrm))\r\nzcomp_strm_free(zstrm);\r\n*per_cpu_ptr(comp->stream, cpu) = NULL;\r\nreturn 0;\r\n}\r\nstatic int zcomp_init(struct zcomp *comp)\r\n{\r\nint ret;\r\ncomp->stream = alloc_percpu(struct zcomp_strm *);\r\nif (!comp->stream)\r\nreturn -ENOMEM;\r\nret = cpuhp_state_add_instance(CPUHP_ZCOMP_PREPARE, &comp->node);\r\nif (ret < 0)\r\ngoto cleanup;\r\nreturn 0;\r\ncleanup:\r\nfree_percpu(comp->stream);\r\nreturn ret;\r\n}\r\nvoid zcomp_destroy(struct zcomp *comp)\r\n{\r\ncpuhp_state_remove_instance(CPUHP_ZCOMP_PREPARE, &comp->node);\r\nfree_percpu(comp->stream);\r\nkfree(comp);\r\n}\r\nstruct zcomp *zcomp_create(const char *compress)\r\n{\r\nstruct zcomp *comp;\r\nint error;\r\nif (!zcomp_available_algorithm(compress))\r\nreturn ERR_PTR(-EINVAL);\r\ncomp = kzalloc(sizeof(struct zcomp), GFP_KERNEL);\r\nif (!comp)\r\nreturn ERR_PTR(-ENOMEM);\r\ncomp->name = compress;\r\nerror = zcomp_init(comp);\r\nif (error) {\r\nkfree(comp);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn comp;\r\n}
