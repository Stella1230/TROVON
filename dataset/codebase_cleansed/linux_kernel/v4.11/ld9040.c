static void ld9040_regulator_enable(struct ld9040 *lcd)\r\n{\r\nint ret = 0;\r\nstruct lcd_platform_data *pd = NULL;\r\npd = lcd->lcd_pd;\r\nmutex_lock(&lcd->lock);\r\nif (!lcd->enabled) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(supplies), supplies);\r\nif (ret)\r\ngoto out;\r\nlcd->enabled = true;\r\n}\r\nmsleep(pd->power_on_delay);\r\nout:\r\nmutex_unlock(&lcd->lock);\r\n}\r\nstatic void ld9040_regulator_disable(struct ld9040 *lcd)\r\n{\r\nint ret = 0;\r\nmutex_lock(&lcd->lock);\r\nif (lcd->enabled) {\r\nret = regulator_bulk_disable(ARRAY_SIZE(supplies), supplies);\r\nif (ret)\r\ngoto out;\r\nlcd->enabled = false;\r\n}\r\nout:\r\nmutex_unlock(&lcd->lock);\r\n}\r\nstatic int ld9040_spi_write_byte(struct ld9040 *lcd, int addr, int data)\r\n{\r\nu16 buf[1];\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = buf,\r\n};\r\nbuf[0] = (addr << 8) | data;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nreturn spi_sync(lcd->spi, &msg);\r\n}\r\nstatic int ld9040_spi_write(struct ld9040 *lcd, unsigned char address,\r\nunsigned char command)\r\n{\r\nint ret = 0;\r\nif (address != DATA_ONLY)\r\nret = ld9040_spi_write_byte(lcd, 0x0, address);\r\nif (command != COMMAND_ONLY)\r\nret = ld9040_spi_write_byte(lcd, 0x1, command);\r\nreturn ret;\r\n}\r\nstatic int ld9040_panel_send_sequence(struct ld9040 *lcd,\r\nconst unsigned short *wbuf)\r\n{\r\nint ret = 0, i = 0;\r\nwhile ((wbuf[i] & DEFMASK) != ENDDEF) {\r\nif ((wbuf[i] & DEFMASK) != SLEEPMSEC) {\r\nret = ld9040_spi_write(lcd, wbuf[i], wbuf[i+1]);\r\nif (ret)\r\nbreak;\r\n} else {\r\nmsleep(wbuf[i+1]);\r\n}\r\ni += 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int _ld9040_gamma_ctl(struct ld9040 *lcd, const unsigned int *gamma)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nret = ld9040_panel_send_sequence(lcd, seq_gamma_start);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to disable gamma table updating.\n");\r\ngoto gamma_err;\r\n}\r\nfor (i = 0 ; i < GAMMA_TABLE_COUNT; i++) {\r\nret = ld9040_spi_write(lcd, DATA_ONLY, gamma[i]);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to set gamma table.\n");\r\ngoto gamma_err;\r\n}\r\n}\r\nret = ld9040_panel_send_sequence(lcd, seq_gamma_ctrl);\r\nif (ret)\r\ndev_err(lcd->dev, "failed to update gamma table.\n");\r\ngamma_err:\r\nreturn ret;\r\n}\r\nstatic int ld9040_gamma_ctl(struct ld9040 *lcd, int gamma)\r\n{\r\nreturn _ld9040_gamma_ctl(lcd, gamma_table.gamma_22_table[gamma]);\r\n}\r\nstatic int ld9040_ldi_init(struct ld9040 *lcd)\r\n{\r\nint ret, i;\r\nstatic const unsigned short *init_seq[] = {\r\nseq_user_setting,\r\nseq_panel_condition,\r\nseq_display_ctrl,\r\nseq_manual_pwr,\r\nseq_elvss_on,\r\nseq_gtcon,\r\nseq_gamma_set1,\r\nseq_gamma_ctrl,\r\nseq_sleep_out,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_seq); i++) {\r\nret = ld9040_panel_send_sequence(lcd, init_seq[i]);\r\nusleep_range(300, 310);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ld9040_ldi_enable(struct ld9040 *lcd)\r\n{\r\nreturn ld9040_panel_send_sequence(lcd, seq_display_on);\r\n}\r\nstatic int ld9040_ldi_disable(struct ld9040 *lcd)\r\n{\r\nint ret;\r\nret = ld9040_panel_send_sequence(lcd, seq_display_off);\r\nret = ld9040_panel_send_sequence(lcd, seq_sleep_in);\r\nreturn ret;\r\n}\r\nstatic int ld9040_power_is_on(int power)\r\n{\r\nreturn power <= FB_BLANK_NORMAL;\r\n}\r\nstatic int ld9040_power_on(struct ld9040 *lcd)\r\n{\r\nint ret = 0;\r\nstruct lcd_platform_data *pd;\r\npd = lcd->lcd_pd;\r\nld9040_regulator_enable(lcd);\r\nif (!pd->reset) {\r\ndev_err(lcd->dev, "reset is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\npd->reset(lcd->ld);\r\nmsleep(pd->reset_delay);\r\nret = ld9040_ldi_init(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to initialize ldi.\n");\r\nreturn ret;\r\n}\r\nret = ld9040_ldi_enable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "failed to enable ldi.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ld9040_power_off(struct ld9040 *lcd)\r\n{\r\nint ret;\r\nstruct lcd_platform_data *pd;\r\npd = lcd->lcd_pd;\r\nret = ld9040_ldi_disable(lcd);\r\nif (ret) {\r\ndev_err(lcd->dev, "lcd setting failed.\n");\r\nreturn -EIO;\r\n}\r\nmsleep(pd->power_off_delay);\r\nld9040_regulator_disable(lcd);\r\nreturn 0;\r\n}\r\nstatic int ld9040_power(struct ld9040 *lcd, int power)\r\n{\r\nint ret = 0;\r\nif (ld9040_power_is_on(power) && !ld9040_power_is_on(lcd->power))\r\nret = ld9040_power_on(lcd);\r\nelse if (!ld9040_power_is_on(power) && ld9040_power_is_on(lcd->power))\r\nret = ld9040_power_off(lcd);\r\nif (!ret)\r\nlcd->power = power;\r\nreturn ret;\r\n}\r\nstatic int ld9040_set_power(struct lcd_device *ld, int power)\r\n{\r\nstruct ld9040 *lcd = lcd_get_data(ld);\r\nif (power != FB_BLANK_UNBLANK && power != FB_BLANK_POWERDOWN &&\r\npower != FB_BLANK_NORMAL) {\r\ndev_err(lcd->dev, "power value should be 0, 1 or 4.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ld9040_power(lcd, power);\r\n}\r\nstatic int ld9040_get_power(struct lcd_device *ld)\r\n{\r\nstruct ld9040 *lcd = lcd_get_data(ld);\r\nreturn lcd->power;\r\n}\r\nstatic int ld9040_set_brightness(struct backlight_device *bd)\r\n{\r\nint ret = 0, brightness = bd->props.brightness;\r\nstruct ld9040 *lcd = bl_get_data(bd);\r\nif (brightness < MIN_BRIGHTNESS ||\r\nbrightness > bd->props.max_brightness) {\r\ndev_err(&bd->dev, "lcd brightness should be %d to %d.\n",\r\nMIN_BRIGHTNESS, MAX_BRIGHTNESS);\r\nreturn -EINVAL;\r\n}\r\nret = ld9040_gamma_ctl(lcd, bd->props.brightness);\r\nif (ret) {\r\ndev_err(&bd->dev, "lcd brightness setting failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ld9040_probe(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\nstruct ld9040 *lcd = NULL;\r\nstruct lcd_device *ld = NULL;\r\nstruct backlight_device *bd = NULL;\r\nstruct backlight_properties props;\r\nlcd = devm_kzalloc(&spi->dev, sizeof(struct ld9040), GFP_KERNEL);\r\nif (!lcd)\r\nreturn -ENOMEM;\r\nspi->bits_per_word = 9;\r\nret = spi_setup(spi);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "spi setup failed.\n");\r\nreturn ret;\r\n}\r\nlcd->spi = spi;\r\nlcd->dev = &spi->dev;\r\nlcd->lcd_pd = dev_get_platdata(&spi->dev);\r\nif (!lcd->lcd_pd) {\r\ndev_err(&spi->dev, "platform data is NULL.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&lcd->lock);\r\nret = devm_regulator_bulk_get(lcd->dev, ARRAY_SIZE(supplies), supplies);\r\nif (ret) {\r\ndev_err(lcd->dev, "Failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\nld = devm_lcd_device_register(&spi->dev, "ld9040", &spi->dev, lcd,\r\n&ld9040_lcd_ops);\r\nif (IS_ERR(ld))\r\nreturn PTR_ERR(ld);\r\nlcd->ld = ld;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nbd = devm_backlight_device_register(&spi->dev, "ld9040-bl", &spi->dev,\r\nlcd, &ld9040_backlight_ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\nbd->props.brightness = MAX_BRIGHTNESS;\r\nlcd->bd = bd;\r\nif (!lcd->lcd_pd->lcd_enabled) {\r\nlcd->power = FB_BLANK_POWERDOWN;\r\nld9040_power(lcd, FB_BLANK_UNBLANK);\r\n} else {\r\nlcd->power = FB_BLANK_UNBLANK;\r\n}\r\nspi_set_drvdata(spi, lcd);\r\ndev_info(&spi->dev, "ld9040 panel driver has been probed.\n");\r\nreturn 0;\r\n}\r\nstatic int ld9040_remove(struct spi_device *spi)\r\n{\r\nstruct ld9040 *lcd = spi_get_drvdata(spi);\r\nld9040_power(lcd, FB_BLANK_POWERDOWN);\r\nreturn 0;\r\n}\r\nstatic int ld9040_suspend(struct device *dev)\r\n{\r\nstruct ld9040 *lcd = dev_get_drvdata(dev);\r\ndev_dbg(dev, "lcd->power = %d\n", lcd->power);\r\nreturn ld9040_power(lcd, FB_BLANK_POWERDOWN);\r\n}\r\nstatic int ld9040_resume(struct device *dev)\r\n{\r\nstruct ld9040 *lcd = dev_get_drvdata(dev);\r\nlcd->power = FB_BLANK_POWERDOWN;\r\nreturn ld9040_power(lcd, FB_BLANK_UNBLANK);\r\n}\r\nstatic void ld9040_shutdown(struct spi_device *spi)\r\n{\r\nstruct ld9040 *lcd = spi_get_drvdata(spi);\r\nld9040_power(lcd, FB_BLANK_POWERDOWN);\r\n}
