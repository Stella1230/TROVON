int\r\nksocknal_lib_get_conn_addrs(struct ksock_conn *conn)\r\n{\r\nint rc = lnet_sock_getaddr(conn->ksnc_sock, 1, &conn->ksnc_ipaddr,\r\n&conn->ksnc_port);\r\nLASSERT(!conn->ksnc_closing);\r\nif (rc) {\r\nCERROR("Error %d getting sock peer IP\n", rc);\r\nreturn rc;\r\n}\r\nrc = lnet_sock_getaddr(conn->ksnc_sock, 0, &conn->ksnc_myipaddr, NULL);\r\nif (rc) {\r\nCERROR("Error %d getting sock local IP\n", rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nksocknal_lib_zc_capable(struct ksock_conn *conn)\r\n{\r\nint caps = conn->ksnc_sock->sk->sk_route_caps;\r\nif (conn->ksnc_proto == &ksocknal_protocol_v1x)\r\nreturn 0;\r\nreturn ((caps & NETIF_F_SG) && (caps & NETIF_F_CSUM_MASK));\r\n}\r\nint\r\nksocknal_lib_send_iov(struct ksock_conn *conn, struct ksock_tx *tx)\r\n{\r\nstruct msghdr msg = {.msg_flags = MSG_DONTWAIT};\r\nstruct socket *sock = conn->ksnc_sock;\r\nint nob, i;\r\nif (*ksocknal_tunables.ksnd_enable_csum &&\r\nconn->ksnc_proto == &ksocknal_protocol_v2x &&\r\ntx->tx_nob == tx->tx_resid &&\r\n!tx->tx_msg.ksm_csum)\r\nksocknal_lib_csum_tx(tx);\r\nfor (nob = i = 0; i < tx->tx_niov; i++)\r\nnob += tx->tx_iov[i].iov_len;\r\nif (!list_empty(&conn->ksnc_tx_queue) ||\r\nnob < tx->tx_resid)\r\nmsg.msg_flags |= MSG_MORE;\r\niov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC,\r\ntx->tx_iov, tx->tx_niov, nob);\r\nreturn sock_sendmsg(sock, &msg);\r\n}\r\nint\r\nksocknal_lib_send_kiov(struct ksock_conn *conn, struct ksock_tx *tx)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nlnet_kiov_t *kiov = tx->tx_kiov;\r\nint rc;\r\nint nob;\r\nLASSERT(tx->tx_lnetmsg);\r\nif (tx->tx_msg.ksm_zc_cookies[0]) {\r\nstruct sock *sk = sock->sk;\r\nstruct page *page = kiov->bv_page;\r\nint offset = kiov->bv_offset;\r\nint fragsize = kiov->bv_len;\r\nint msgflg = MSG_DONTWAIT;\r\nCDEBUG(D_NET, "page %p + offset %x for %d\n",\r\npage, offset, kiov->bv_len);\r\nif (!list_empty(&conn->ksnc_tx_queue) ||\r\nfragsize < tx->tx_resid)\r\nmsgflg |= MSG_MORE;\r\nif (sk->sk_prot->sendpage) {\r\nrc = sk->sk_prot->sendpage(sk, page,\r\noffset, fragsize, msgflg);\r\n} else {\r\nrc = tcp_sendpage(sk, page, offset, fragsize, msgflg);\r\n}\r\n} else {\r\nstruct msghdr msg = {.msg_flags = MSG_DONTWAIT};\r\nint i;\r\nfor (nob = i = 0; i < tx->tx_nkiov; i++)\r\nnob += kiov[i].bv_len;\r\nif (!list_empty(&conn->ksnc_tx_queue) ||\r\nnob < tx->tx_resid)\r\nmsg.msg_flags |= MSG_MORE;\r\niov_iter_bvec(&msg.msg_iter, WRITE | ITER_BVEC,\r\nkiov, tx->tx_nkiov, nob);\r\nrc = sock_sendmsg(sock, &msg);\r\n}\r\nreturn rc;\r\n}\r\nvoid\r\nksocknal_lib_eager_ack(struct ksock_conn *conn)\r\n{\r\nint opt = 1;\r\nstruct socket *sock = conn->ksnc_sock;\r\nkernel_setsockopt(sock, SOL_TCP, TCP_QUICKACK, (char *)&opt,\r\nsizeof(opt));\r\n}\r\nint\r\nksocknal_lib_recv_iov(struct ksock_conn *conn)\r\n{\r\nunsigned int niov = conn->ksnc_rx_niov;\r\nstruct kvec *iov = conn->ksnc_rx_iov;\r\nstruct msghdr msg = {\r\n.msg_flags = 0\r\n};\r\nint nob;\r\nint i;\r\nint rc;\r\nint fragnob;\r\nint sum;\r\n__u32 saved_csum;\r\nLASSERT(niov > 0);\r\nfor (nob = i = 0; i < niov; i++)\r\nnob += iov[i].iov_len;\r\nLASSERT(nob <= conn->ksnc_rx_nob_wanted);\r\niov_iter_kvec(&msg.msg_iter, READ | ITER_KVEC, iov, niov, nob);\r\nrc = sock_recvmsg(conn->ksnc_sock, &msg, MSG_DONTWAIT);\r\nsaved_csum = 0;\r\nif (conn->ksnc_proto == &ksocknal_protocol_v2x) {\r\nsaved_csum = conn->ksnc_msg.ksm_csum;\r\nconn->ksnc_msg.ksm_csum = 0;\r\n}\r\nif (saved_csum) {\r\nfor (i = 0, sum = rc; sum > 0; i++, sum -= fragnob) {\r\nLASSERT(i < niov);\r\nfragnob = iov[i].iov_len;\r\nif (fragnob > sum)\r\nfragnob = sum;\r\nconn->ksnc_rx_csum = ksocknal_csum(conn->ksnc_rx_csum,\r\niov[i].iov_base,\r\nfragnob);\r\n}\r\nconn->ksnc_msg.ksm_csum = saved_csum;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nksocknal_lib_recv_kiov(struct ksock_conn *conn)\r\n{\r\nunsigned int niov = conn->ksnc_rx_nkiov;\r\nlnet_kiov_t *kiov = conn->ksnc_rx_kiov;\r\nstruct msghdr msg = {\r\n.msg_flags = 0\r\n};\r\nint nob;\r\nint i;\r\nint rc;\r\nvoid *base;\r\nint sum;\r\nint fragnob;\r\nfor (nob = i = 0; i < niov; i++)\r\nnob += kiov[i].bv_len;\r\nLASSERT(nob <= conn->ksnc_rx_nob_wanted);\r\niov_iter_bvec(&msg.msg_iter, READ | ITER_BVEC, kiov, niov, nob);\r\nrc = sock_recvmsg(conn->ksnc_sock, &msg, MSG_DONTWAIT);\r\nif (conn->ksnc_msg.ksm_csum) {\r\nfor (i = 0, sum = rc; sum > 0; i++, sum -= fragnob) {\r\nLASSERT(i < niov);\r\nbase = kmap(kiov[i].bv_page) + kiov[i].bv_offset;\r\nfragnob = kiov[i].bv_len;\r\nif (fragnob > sum)\r\nfragnob = sum;\r\nconn->ksnc_rx_csum = ksocknal_csum(conn->ksnc_rx_csum,\r\nbase, fragnob);\r\nkunmap(kiov[i].bv_page);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nvoid\r\nksocknal_lib_csum_tx(struct ksock_tx *tx)\r\n{\r\nint i;\r\n__u32 csum;\r\nvoid *base;\r\nLASSERT(tx->tx_iov[0].iov_base == &tx->tx_msg);\r\nLASSERT(tx->tx_conn);\r\nLASSERT(tx->tx_conn->ksnc_proto == &ksocknal_protocol_v2x);\r\ntx->tx_msg.ksm_csum = 0;\r\ncsum = ksocknal_csum(~0, tx->tx_iov[0].iov_base,\r\ntx->tx_iov[0].iov_len);\r\nif (tx->tx_kiov) {\r\nfor (i = 0; i < tx->tx_nkiov; i++) {\r\nbase = kmap(tx->tx_kiov[i].bv_page) +\r\ntx->tx_kiov[i].bv_offset;\r\ncsum = ksocknal_csum(csum, base, tx->tx_kiov[i].bv_len);\r\nkunmap(tx->tx_kiov[i].bv_page);\r\n}\r\n} else {\r\nfor (i = 1; i < tx->tx_niov; i++)\r\ncsum = ksocknal_csum(csum, tx->tx_iov[i].iov_base,\r\ntx->tx_iov[i].iov_len);\r\n}\r\nif (*ksocknal_tunables.ksnd_inject_csum_error) {\r\ncsum++;\r\n*ksocknal_tunables.ksnd_inject_csum_error = 0;\r\n}\r\ntx->tx_msg.ksm_csum = csum;\r\n}\r\nint\r\nksocknal_lib_get_conn_tunables(struct ksock_conn *conn, int *txmem,\r\nint *rxmem, int *nagle)\r\n{\r\nstruct socket *sock = conn->ksnc_sock;\r\nint len;\r\nint rc;\r\nrc = ksocknal_connsock_addref(conn);\r\nif (rc) {\r\nLASSERT(conn->ksnc_closing);\r\n*txmem = *rxmem = *nagle = 0;\r\nreturn -ESHUTDOWN;\r\n}\r\nrc = lnet_sock_getbuf(sock, txmem, rxmem);\r\nif (!rc) {\r\nlen = sizeof(*nagle);\r\nrc = kernel_getsockopt(sock, SOL_TCP, TCP_NODELAY,\r\n(char *)nagle, &len);\r\n}\r\nksocknal_connsock_decref(conn);\r\nif (!rc)\r\n*nagle = !*nagle;\r\nelse\r\n*txmem = *rxmem = *nagle = 0;\r\nreturn rc;\r\n}\r\nint\r\nksocknal_lib_setup_sock(struct socket *sock)\r\n{\r\nint rc;\r\nint option;\r\nint keep_idle;\r\nint keep_intvl;\r\nint keep_count;\r\nint do_keepalive;\r\nstruct linger linger;\r\nsock->sk->sk_allocation = GFP_NOFS;\r\nlinger.l_onoff = 0;\r\nlinger.l_linger = 0;\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_LINGER, (char *)&linger,\r\nsizeof(linger));\r\nif (rc) {\r\nCERROR("Can't set SO_LINGER: %d\n", rc);\r\nreturn rc;\r\n}\r\noption = -1;\r\nrc = kernel_setsockopt(sock, SOL_TCP, TCP_LINGER2, (char *)&option,\r\nsizeof(option));\r\nif (rc) {\r\nCERROR("Can't set SO_LINGER2: %d\n", rc);\r\nreturn rc;\r\n}\r\nif (!*ksocknal_tunables.ksnd_nagle) {\r\noption = 1;\r\nrc = kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY,\r\n(char *)&option, sizeof(option));\r\nif (rc) {\r\nCERROR("Can't disable nagle: %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = lnet_sock_setbuf(sock, *ksocknal_tunables.ksnd_tx_buffer_size,\r\n*ksocknal_tunables.ksnd_rx_buffer_size);\r\nif (rc) {\r\nCERROR("Can't set buffer tx %d, rx %d buffers: %d\n",\r\n*ksocknal_tunables.ksnd_tx_buffer_size,\r\n*ksocknal_tunables.ksnd_rx_buffer_size, rc);\r\nreturn rc;\r\n}\r\nkeep_idle = *ksocknal_tunables.ksnd_keepalive_idle;\r\nkeep_count = *ksocknal_tunables.ksnd_keepalive_count;\r\nkeep_intvl = *ksocknal_tunables.ksnd_keepalive_intvl;\r\ndo_keepalive = (keep_idle > 0 && keep_count > 0 && keep_intvl > 0);\r\noption = (do_keepalive ? 1 : 0);\r\nrc = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char *)&option,\r\nsizeof(option));\r\nif (rc) {\r\nCERROR("Can't set SO_KEEPALIVE: %d\n", rc);\r\nreturn rc;\r\n}\r\nif (!do_keepalive)\r\nreturn 0;\r\nrc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPIDLE, (char *)&keep_idle,\r\nsizeof(keep_idle));\r\nif (rc) {\r\nCERROR("Can't set TCP_KEEPIDLE: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPINTVL,\r\n(char *)&keep_intvl, sizeof(keep_intvl));\r\nif (rc) {\r\nCERROR("Can't set TCP_KEEPINTVL: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = kernel_setsockopt(sock, SOL_TCP, TCP_KEEPCNT, (char *)&keep_count,\r\nsizeof(keep_count));\r\nif (rc) {\r\nCERROR("Can't set TCP_KEEPCNT: %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nksocknal_lib_push_conn(struct ksock_conn *conn)\r\n{\r\nstruct sock *sk;\r\nstruct tcp_sock *tp;\r\nint nonagle;\r\nint val = 1;\r\nint rc;\r\nrc = ksocknal_connsock_addref(conn);\r\nif (rc)\r\nreturn;\r\nsk = conn->ksnc_sock->sk;\r\ntp = tcp_sk(sk);\r\nlock_sock(sk);\r\nnonagle = tp->nonagle;\r\ntp->nonagle = 1;\r\nrelease_sock(sk);\r\nrc = kernel_setsockopt(conn->ksnc_sock, SOL_TCP, TCP_NODELAY,\r\n(char *)&val, sizeof(val));\r\nLASSERT(!rc);\r\nlock_sock(sk);\r\ntp->nonagle = nonagle;\r\nrelease_sock(sk);\r\nksocknal_connsock_decref(conn);\r\n}\r\nstatic void\r\nksocknal_data_ready(struct sock *sk)\r\n{\r\nstruct ksock_conn *conn;\r\nLASSERT(!in_irq());\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nLASSERT(sk->sk_data_ready != &ksocknal_data_ready);\r\nsk->sk_data_ready(sk);\r\n} else {\r\nksocknal_read_callback(conn);\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\n}\r\nstatic void\r\nksocknal_write_space(struct sock *sk)\r\n{\r\nstruct ksock_conn *conn;\r\nint wspace;\r\nint min_wpace;\r\nLASSERT(!in_irq());\r\nread_lock(&ksocknal_data.ksnd_global_lock);\r\nconn = sk->sk_user_data;\r\nwspace = sk_stream_wspace(sk);\r\nmin_wpace = sk_stream_min_wspace(sk);\r\nCDEBUG(D_NET, "sk %p wspace %d low water %d conn %p%s%s%s\n",\r\nsk, wspace, min_wpace, conn,\r\n!conn ? "" : (conn->ksnc_tx_ready ?\r\n" ready" : " blocked"),\r\n!conn ? "" : (conn->ksnc_tx_scheduled ?\r\n" scheduled" : " idle"),\r\n!conn ? "" : (list_empty(&conn->ksnc_tx_queue) ?\r\n" empty" : " queued"));\r\nif (!conn) {\r\nLASSERT(sk->sk_write_space != &ksocknal_write_space);\r\nsk->sk_write_space(sk);\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\nreturn;\r\n}\r\nif (wspace >= min_wpace) {\r\nksocknal_write_callback(conn);\r\nclear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\n}\r\nread_unlock(&ksocknal_data.ksnd_global_lock);\r\n}\r\nvoid\r\nksocknal_lib_save_callback(struct socket *sock, struct ksock_conn *conn)\r\n{\r\nconn->ksnc_saved_data_ready = sock->sk->sk_data_ready;\r\nconn->ksnc_saved_write_space = sock->sk->sk_write_space;\r\n}\r\nvoid\r\nksocknal_lib_set_callback(struct socket *sock, struct ksock_conn *conn)\r\n{\r\nsock->sk->sk_user_data = conn;\r\nsock->sk->sk_data_ready = ksocknal_data_ready;\r\nsock->sk->sk_write_space = ksocknal_write_space;\r\n}\r\nvoid\r\nksocknal_lib_reset_callback(struct socket *sock, struct ksock_conn *conn)\r\n{\r\nsock->sk->sk_data_ready = conn->ksnc_saved_data_ready;\r\nsock->sk->sk_write_space = conn->ksnc_saved_write_space;\r\nsock->sk->sk_user_data = NULL;\r\n}\r\nint\r\nksocknal_lib_memory_pressure(struct ksock_conn *conn)\r\n{\r\nint rc = 0;\r\nstruct ksock_sched *sched;\r\nsched = conn->ksnc_scheduler;\r\nspin_lock_bh(&sched->kss_lock);\r\nif (!test_bit(SOCK_NOSPACE, &conn->ksnc_sock->flags) &&\r\n!conn->ksnc_tx_ready) {\r\nrc = -ENOMEM;\r\n}\r\nspin_unlock_bh(&sched->kss_lock);\r\nreturn rc;\r\n}
