static inline int system_refcount(struct event_subsystem *system)\r\n{\r\nreturn system->ref_count;\r\n}\r\nstatic int system_refcount_inc(struct event_subsystem *system)\r\n{\r\nreturn system->ref_count++;\r\n}\r\nstatic int system_refcount_dec(struct event_subsystem *system)\r\n{\r\nreturn --system->ref_count;\r\n}\r\nstatic struct list_head *\r\ntrace_get_fields(struct trace_event_call *event_call)\r\n{\r\nif (!event_call->class->get_fields)\r\nreturn &event_call->class->fields;\r\nreturn event_call->class->get_fields(event_call);\r\n}\r\nstatic struct ftrace_event_field *\r\n__find_event_field(struct list_head *head, char *name)\r\n{\r\nstruct ftrace_event_field *field;\r\nlist_for_each_entry(field, head, link) {\r\nif (!strcmp(field->name, name))\r\nreturn field;\r\n}\r\nreturn NULL;\r\n}\r\nstruct ftrace_event_field *\r\ntrace_find_event_field(struct trace_event_call *call, char *name)\r\n{\r\nstruct ftrace_event_field *field;\r\nstruct list_head *head;\r\nhead = trace_get_fields(call);\r\nfield = __find_event_field(head, name);\r\nif (field)\r\nreturn field;\r\nfield = __find_event_field(&ftrace_generic_fields, name);\r\nif (field)\r\nreturn field;\r\nreturn __find_event_field(&ftrace_common_fields, name);\r\n}\r\nstatic int __trace_define_field(struct list_head *head, const char *type,\r\nconst char *name, int offset, int size,\r\nint is_signed, int filter_type)\r\n{\r\nstruct ftrace_event_field *field;\r\nfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\r\nif (!field)\r\nreturn -ENOMEM;\r\nfield->name = name;\r\nfield->type = type;\r\nif (filter_type == FILTER_OTHER)\r\nfield->filter_type = filter_assign_type(type);\r\nelse\r\nfield->filter_type = filter_type;\r\nfield->offset = offset;\r\nfield->size = size;\r\nfield->is_signed = is_signed;\r\nlist_add(&field->link, head);\r\nreturn 0;\r\n}\r\nint trace_define_field(struct trace_event_call *call, const char *type,\r\nconst char *name, int offset, int size, int is_signed,\r\nint filter_type)\r\n{\r\nstruct list_head *head;\r\nif (WARN_ON(!call->class))\r\nreturn 0;\r\nhead = trace_get_fields(call);\r\nreturn __trace_define_field(head, type, name, offset, size,\r\nis_signed, filter_type);\r\n}\r\nstatic int trace_define_generic_fields(void)\r\n{\r\nint ret;\r\n__generic_field(int, CPU, FILTER_CPU);\r\n__generic_field(int, cpu, FILTER_CPU);\r\n__generic_field(char *, COMM, FILTER_COMM);\r\n__generic_field(char *, comm, FILTER_COMM);\r\nreturn ret;\r\n}\r\nstatic int trace_define_common_fields(void)\r\n{\r\nint ret;\r\nstruct trace_entry ent;\r\n__common_field(unsigned short, type);\r\n__common_field(unsigned char, flags);\r\n__common_field(unsigned char, preempt_count);\r\n__common_field(int, pid);\r\nreturn ret;\r\n}\r\nstatic void trace_destroy_fields(struct trace_event_call *call)\r\n{\r\nstruct ftrace_event_field *field, *next;\r\nstruct list_head *head;\r\nhead = trace_get_fields(call);\r\nlist_for_each_entry_safe(field, next, head, link) {\r\nlist_del(&field->link);\r\nkmem_cache_free(field_cachep, field);\r\n}\r\n}\r\nint trace_event_get_offsets(struct trace_event_call *call)\r\n{\r\nstruct ftrace_event_field *tail;\r\nstruct list_head *head;\r\nhead = trace_get_fields(call);\r\ntail = list_first_entry(head, struct ftrace_event_field, link);\r\nreturn tail->offset + tail->size;\r\n}\r\nint trace_event_raw_init(struct trace_event_call *call)\r\n{\r\nint id;\r\nid = register_trace_event(&call->event);\r\nif (!id)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nbool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\r\n{\r\nstruct trace_array *tr = trace_file->tr;\r\nstruct trace_array_cpu *data;\r\nstruct trace_pid_list *pid_list;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nif (!pid_list)\r\nreturn false;\r\ndata = this_cpu_ptr(tr->trace_buffer.data);\r\nreturn data->ignore_pid;\r\n}\r\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\r\nstruct trace_event_file *trace_file,\r\nunsigned long len)\r\n{\r\nstruct trace_event_call *event_call = trace_file->event_call;\r\nif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\r\ntrace_event_ignore_this_pid(trace_file))\r\nreturn NULL;\r\nlocal_save_flags(fbuffer->flags);\r\nfbuffer->pc = preempt_count();\r\nif (IS_ENABLED(CONFIG_PREEMPT))\r\nfbuffer->pc--;\r\nfbuffer->trace_file = trace_file;\r\nfbuffer->event =\r\ntrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\r\nevent_call->event.type, len,\r\nfbuffer->flags, fbuffer->pc);\r\nif (!fbuffer->event)\r\nreturn NULL;\r\nfbuffer->entry = ring_buffer_event_data(fbuffer->event);\r\nreturn fbuffer->entry;\r\n}\r\nint trace_event_reg(struct trace_event_call *call,\r\nenum trace_reg type, void *data)\r\n{\r\nstruct trace_event_file *file = data;\r\nWARN_ON(!(call->flags & TRACE_EVENT_FL_TRACEPOINT));\r\nswitch (type) {\r\ncase TRACE_REG_REGISTER:\r\nreturn tracepoint_probe_register(call->tp,\r\ncall->class->probe,\r\nfile);\r\ncase TRACE_REG_UNREGISTER:\r\ntracepoint_probe_unregister(call->tp,\r\ncall->class->probe,\r\nfile);\r\nreturn 0;\r\n#ifdef CONFIG_PERF_EVENTS\r\ncase TRACE_REG_PERF_REGISTER:\r\nreturn tracepoint_probe_register(call->tp,\r\ncall->class->perf_probe,\r\ncall);\r\ncase TRACE_REG_PERF_UNREGISTER:\r\ntracepoint_probe_unregister(call->tp,\r\ncall->class->perf_probe,\r\ncall);\r\nreturn 0;\r\ncase TRACE_REG_PERF_OPEN:\r\ncase TRACE_REG_PERF_CLOSE:\r\ncase TRACE_REG_PERF_ADD:\r\ncase TRACE_REG_PERF_DEL:\r\nreturn 0;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nvoid trace_event_enable_cmd_record(bool enable)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_array *tr;\r\nmutex_lock(&event_mutex);\r\ndo_for_each_event_file(tr, file) {\r\nif (!(file->flags & EVENT_FILE_FL_ENABLED))\r\ncontinue;\r\nif (enable) {\r\ntracing_start_cmdline_record();\r\nset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\r\n} else {\r\ntracing_stop_cmdline_record();\r\nclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\r\n}\r\n} while_for_each_event_file();\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\r\nint enable, int soft_disable)\r\n{\r\nstruct trace_event_call *call = file->event_call;\r\nstruct trace_array *tr = file->tr;\r\nunsigned long file_flags = file->flags;\r\nint ret = 0;\r\nint disable;\r\nswitch (enable) {\r\ncase 0:\r\nif (soft_disable) {\r\nif (atomic_dec_return(&file->sm_ref) > 0)\r\nbreak;\r\ndisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\r\nclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\r\n} else\r\ndisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\r\nif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\r\nclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\r\nif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\r\ntracing_stop_cmdline_record();\r\nclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\r\n}\r\ncall->class->reg(call, TRACE_REG_UNREGISTER, file);\r\n}\r\nif (file->flags & EVENT_FILE_FL_SOFT_MODE)\r\nset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\r\nelse\r\nclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\r\nbreak;\r\ncase 1:\r\nif (!soft_disable)\r\nclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\r\nelse {\r\nif (atomic_inc_return(&file->sm_ref) > 1)\r\nbreak;\r\nset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\r\n}\r\nif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\r\nif (soft_disable)\r\nset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\r\nif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\r\ntracing_start_cmdline_record();\r\nset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\r\n}\r\nret = call->class->reg(call, TRACE_REG_REGISTER, file);\r\nif (ret) {\r\ntracing_stop_cmdline_record();\r\npr_info("event trace: Could not enable event "\r\n"%s\n", trace_event_name(call));\r\nbreak;\r\n}\r\nset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\r\ncall->flags |= TRACE_EVENT_FL_WAS_ENABLED;\r\n}\r\nbreak;\r\n}\r\nif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\r\n(file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\r\nif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\r\ntrace_buffered_event_enable();\r\nelse\r\ntrace_buffered_event_disable();\r\n}\r\nreturn ret;\r\n}\r\nint trace_event_enable_disable(struct trace_event_file *file,\r\nint enable, int soft_disable)\r\n{\r\nreturn __ftrace_event_enable_disable(file, enable, soft_disable);\r\n}\r\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\r\nint enable)\r\n{\r\nreturn __ftrace_event_enable_disable(file, enable, 0);\r\n}\r\nstatic void ftrace_clear_events(struct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nmutex_lock(&event_mutex);\r\nlist_for_each_entry(file, &tr->events, list) {\r\nftrace_event_enable_disable(file, 0);\r\n}\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic void\r\nevent_filter_pid_sched_process_exit(void *data, struct task_struct *task)\r\n{\r\nstruct trace_pid_list *pid_list;\r\nstruct trace_array *tr = data;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\ntrace_filter_add_remove_task(pid_list, NULL, task);\r\n}\r\nstatic void\r\nevent_filter_pid_sched_process_fork(void *data,\r\nstruct task_struct *self,\r\nstruct task_struct *task)\r\n{\r\nstruct trace_pid_list *pid_list;\r\nstruct trace_array *tr = data;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\ntrace_filter_add_remove_task(pid_list, self, task);\r\n}\r\nvoid trace_event_follow_fork(struct trace_array *tr, bool enable)\r\n{\r\nif (enable) {\r\nregister_trace_prio_sched_process_fork(event_filter_pid_sched_process_fork,\r\ntr, INT_MIN);\r\nregister_trace_prio_sched_process_exit(event_filter_pid_sched_process_exit,\r\ntr, INT_MAX);\r\n} else {\r\nunregister_trace_sched_process_fork(event_filter_pid_sched_process_fork,\r\ntr);\r\nunregister_trace_sched_process_exit(event_filter_pid_sched_process_exit,\r\ntr);\r\n}\r\n}\r\nstatic void\r\nevent_filter_pid_sched_switch_probe_pre(void *data, bool preempt,\r\nstruct task_struct *prev, struct task_struct *next)\r\n{\r\nstruct trace_array *tr = data;\r\nstruct trace_pid_list *pid_list;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nthis_cpu_write(tr->trace_buffer.data->ignore_pid,\r\ntrace_ignore_this_task(pid_list, prev) &&\r\ntrace_ignore_this_task(pid_list, next));\r\n}\r\nstatic void\r\nevent_filter_pid_sched_switch_probe_post(void *data, bool preempt,\r\nstruct task_struct *prev, struct task_struct *next)\r\n{\r\nstruct trace_array *tr = data;\r\nstruct trace_pid_list *pid_list;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nthis_cpu_write(tr->trace_buffer.data->ignore_pid,\r\ntrace_ignore_this_task(pid_list, next));\r\n}\r\nstatic void\r\nevent_filter_pid_sched_wakeup_probe_pre(void *data, struct task_struct *task)\r\n{\r\nstruct trace_array *tr = data;\r\nstruct trace_pid_list *pid_list;\r\nif (!this_cpu_read(tr->trace_buffer.data->ignore_pid))\r\nreturn;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nthis_cpu_write(tr->trace_buffer.data->ignore_pid,\r\ntrace_ignore_this_task(pid_list, task));\r\n}\r\nstatic void\r\nevent_filter_pid_sched_wakeup_probe_post(void *data, struct task_struct *task)\r\n{\r\nstruct trace_array *tr = data;\r\nstruct trace_pid_list *pid_list;\r\nif (this_cpu_read(tr->trace_buffer.data->ignore_pid))\r\nreturn;\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nthis_cpu_write(tr->trace_buffer.data->ignore_pid,\r\ntrace_ignore_this_task(pid_list, current));\r\n}\r\nstatic void __ftrace_clear_event_pids(struct trace_array *tr)\r\n{\r\nstruct trace_pid_list *pid_list;\r\nstruct trace_event_file *file;\r\nint cpu;\r\npid_list = rcu_dereference_protected(tr->filtered_pids,\r\nlockdep_is_held(&event_mutex));\r\nif (!pid_list)\r\nreturn;\r\nunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\r\nunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\r\nunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\r\nunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\r\nunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\r\nunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\r\nunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\r\nunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\r\nlist_for_each_entry(file, &tr->events, list) {\r\nclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\r\n}\r\nfor_each_possible_cpu(cpu)\r\nper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\r\nrcu_assign_pointer(tr->filtered_pids, NULL);\r\nsynchronize_sched();\r\ntrace_free_pid_list(pid_list);\r\n}\r\nstatic void ftrace_clear_event_pids(struct trace_array *tr)\r\n{\r\nmutex_lock(&event_mutex);\r\n__ftrace_clear_event_pids(tr);\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic void __put_system(struct event_subsystem *system)\r\n{\r\nstruct event_filter *filter = system->filter;\r\nWARN_ON_ONCE(system_refcount(system) == 0);\r\nif (system_refcount_dec(system))\r\nreturn;\r\nlist_del(&system->list);\r\nif (filter) {\r\nkfree(filter->filter_string);\r\nkfree(filter);\r\n}\r\nkfree_const(system->name);\r\nkfree(system);\r\n}\r\nstatic void __get_system(struct event_subsystem *system)\r\n{\r\nWARN_ON_ONCE(system_refcount(system) == 0);\r\nsystem_refcount_inc(system);\r\n}\r\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\r\n{\r\nWARN_ON_ONCE(dir->ref_count == 0);\r\ndir->ref_count++;\r\n__get_system(dir->subsystem);\r\n}\r\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\r\n{\r\nWARN_ON_ONCE(dir->ref_count == 0);\r\nWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\r\n__put_system(dir->subsystem);\r\nif (!--dir->ref_count)\r\nkfree(dir);\r\n}\r\nstatic void put_system(struct trace_subsystem_dir *dir)\r\n{\r\nmutex_lock(&event_mutex);\r\n__put_system_dir(dir);\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic void remove_subsystem(struct trace_subsystem_dir *dir)\r\n{\r\nif (!dir)\r\nreturn;\r\nif (!--dir->nr_events) {\r\ntracefs_remove_recursive(dir->entry);\r\nlist_del(&dir->list);\r\n__put_system_dir(dir);\r\n}\r\n}\r\nstatic void remove_event_file_dir(struct trace_event_file *file)\r\n{\r\nstruct dentry *dir = file->dir;\r\nstruct dentry *child;\r\nif (dir) {\r\nspin_lock(&dir->d_lock);\r\nlist_for_each_entry(child, &dir->d_subdirs, d_child) {\r\nif (d_really_is_positive(child))\r\nd_inode(child)->i_private = NULL;\r\n}\r\nspin_unlock(&dir->d_lock);\r\ntracefs_remove_recursive(dir);\r\n}\r\nlist_del(&file->list);\r\nremove_subsystem(file->system);\r\nfree_event_filter(file->filter);\r\nkmem_cache_free(file_cachep, file);\r\n}\r\nstatic int\r\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\r\nconst char *sub, const char *event, int set)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_event_call *call;\r\nconst char *name;\r\nint ret = -EINVAL;\r\nint eret = 0;\r\nlist_for_each_entry(file, &tr->events, list) {\r\ncall = file->event_call;\r\nname = trace_event_name(call);\r\nif (!name || !call->class || !call->class->reg)\r\ncontinue;\r\nif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\r\ncontinue;\r\nif (match &&\r\nstrcmp(match, name) != 0 &&\r\nstrcmp(match, call->class->system) != 0)\r\ncontinue;\r\nif (sub && strcmp(sub, call->class->system) != 0)\r\ncontinue;\r\nif (event && strcmp(event, name) != 0)\r\ncontinue;\r\nret = ftrace_event_enable_disable(file, set);\r\nif (ret && !eret)\r\neret = ret;\r\nret = eret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\r\nconst char *sub, const char *event, int set)\r\n{\r\nint ret;\r\nmutex_lock(&event_mutex);\r\nret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\n}\r\nstatic int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\r\n{\r\nchar *event = NULL, *sub = NULL, *match;\r\nint ret;\r\nmatch = strsep(&buf, ":");\r\nif (buf) {\r\nsub = match;\r\nevent = buf;\r\nmatch = NULL;\r\nif (!strlen(sub) || strcmp(sub, "*") == 0)\r\nsub = NULL;\r\nif (!strlen(event) || strcmp(event, "*") == 0)\r\nevent = NULL;\r\n}\r\nret = __ftrace_set_clr_event(tr, match, sub, event, set);\r\nif (buf)\r\n*(buf - 1) = ':';\r\nreturn ret;\r\n}\r\nint trace_set_clr_event(const char *system, const char *event, int set)\r\n{\r\nstruct trace_array *tr = top_trace_array();\r\nif (!tr)\r\nreturn -ENODEV;\r\nreturn __ftrace_set_clr_event(tr, NULL, system, event, set);\r\n}\r\nstatic ssize_t\r\nftrace_event_write(struct file *file, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nstruct trace_parser parser;\r\nstruct seq_file *m = file->private_data;\r\nstruct trace_array *tr = m->private;\r\nssize_t read, ret;\r\nif (!cnt)\r\nreturn 0;\r\nret = tracing_update_buffers();\r\nif (ret < 0)\r\nreturn ret;\r\nif (trace_parser_get_init(&parser, EVENT_BUF_SIZE + 1))\r\nreturn -ENOMEM;\r\nread = trace_get_user(&parser, ubuf, cnt, ppos);\r\nif (read >= 0 && trace_parser_loaded((&parser))) {\r\nint set = 1;\r\nif (*parser.buffer == '!')\r\nset = 0;\r\nparser.buffer[parser.idx] = 0;\r\nret = ftrace_set_clr_event(tr, parser.buffer + !set, set);\r\nif (ret)\r\ngoto out_put;\r\n}\r\nret = read;\r\nout_put:\r\ntrace_parser_put(&parser);\r\nreturn ret;\r\n}\r\nstatic void *\r\nt_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct trace_event_file *file = v;\r\nstruct trace_event_call *call;\r\nstruct trace_array *tr = m->private;\r\n(*pos)++;\r\nlist_for_each_entry_continue(file, &tr->events, list) {\r\ncall = file->event_call;\r\nif (call->class && call->class->reg &&\r\n!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\r\nreturn file;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *t_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_array *tr = m->private;\r\nloff_t l;\r\nmutex_lock(&event_mutex);\r\nfile = list_entry(&tr->events, struct trace_event_file, list);\r\nfor (l = 0; l <= *pos; ) {\r\nfile = t_next(m, file, &l);\r\nif (!file)\r\nbreak;\r\n}\r\nreturn file;\r\n}\r\nstatic void *\r\ns_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct trace_event_file *file = v;\r\nstruct trace_array *tr = m->private;\r\n(*pos)++;\r\nlist_for_each_entry_continue(file, &tr->events, list) {\r\nif (file->flags & EVENT_FILE_FL_ENABLED)\r\nreturn file;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *s_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_array *tr = m->private;\r\nloff_t l;\r\nmutex_lock(&event_mutex);\r\nfile = list_entry(&tr->events, struct trace_event_file, list);\r\nfor (l = 0; l <= *pos; ) {\r\nfile = s_next(m, file, &l);\r\nif (!file)\r\nbreak;\r\n}\r\nreturn file;\r\n}\r\nstatic int t_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_event_file *file = v;\r\nstruct trace_event_call *call = file->event_call;\r\nif (strcmp(call->class->system, TRACE_SYSTEM) != 0)\r\nseq_printf(m, "%s:", call->class->system);\r\nseq_printf(m, "%s\n", trace_event_name(call));\r\nreturn 0;\r\n}\r\nstatic void t_stop(struct seq_file *m, void *p)\r\n{\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic void *\r\np_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct trace_array *tr = m->private;\r\nstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->filtered_pids);\r\nreturn trace_pid_next(pid_list, v, pos);\r\n}\r\nstatic void *p_start(struct seq_file *m, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nstruct trace_pid_list *pid_list;\r\nstruct trace_array *tr = m->private;\r\nmutex_lock(&event_mutex);\r\nrcu_read_lock_sched();\r\npid_list = rcu_dereference_sched(tr->filtered_pids);\r\nif (!pid_list)\r\nreturn NULL;\r\nreturn trace_pid_start(pid_list, pos);\r\n}\r\nstatic void p_stop(struct seq_file *m, void *p)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock_sched();\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic ssize_t\r\nevent_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_event_file *file;\r\nunsigned long flags;\r\nchar buf[4] = "0";\r\nmutex_lock(&event_mutex);\r\nfile = event_file_data(filp);\r\nif (likely(file))\r\nflags = file->flags;\r\nmutex_unlock(&event_mutex);\r\nif (!file)\r\nreturn -ENODEV;\r\nif (flags & EVENT_FILE_FL_ENABLED &&\r\n!(flags & EVENT_FILE_FL_SOFT_DISABLED))\r\nstrcpy(buf, "1");\r\nif (flags & EVENT_FILE_FL_SOFT_DISABLED ||\r\nflags & EVENT_FILE_FL_SOFT_MODE)\r\nstrcat(buf, "*");\r\nstrcat(buf, "\n");\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, strlen(buf));\r\n}\r\nstatic ssize_t\r\nevent_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_event_file *file;\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul_from_user(ubuf, cnt, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = tracing_update_buffers();\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (val) {\r\ncase 0:\r\ncase 1:\r\nret = -ENODEV;\r\nmutex_lock(&event_mutex);\r\nfile = event_file_data(filp);\r\nif (likely(file))\r\nret = ftrace_event_enable_disable(file, val);\r\nmutex_unlock(&event_mutex);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*ppos += cnt;\r\nreturn ret ? ret : cnt;\r\n}\r\nstatic ssize_t\r\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nconst char set_to_char[4] = { '?', '0', '1', 'X' };\r\nstruct trace_subsystem_dir *dir = filp->private_data;\r\nstruct event_subsystem *system = dir->subsystem;\r\nstruct trace_event_call *call;\r\nstruct trace_event_file *file;\r\nstruct trace_array *tr = dir->tr;\r\nchar buf[2];\r\nint set = 0;\r\nint ret;\r\nmutex_lock(&event_mutex);\r\nlist_for_each_entry(file, &tr->events, list) {\r\ncall = file->event_call;\r\nif (!trace_event_name(call) || !call->class || !call->class->reg)\r\ncontinue;\r\nif (system && strcmp(call->class->system, system->name) != 0)\r\ncontinue;\r\nset |= (1 << !!(file->flags & EVENT_FILE_FL_ENABLED));\r\nif (set == 3)\r\nbreak;\r\n}\r\nmutex_unlock(&event_mutex);\r\nbuf[0] = set_to_char[set];\r\nbuf[1] = '\n';\r\nret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nsystem_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_subsystem_dir *dir = filp->private_data;\r\nstruct event_subsystem *system = dir->subsystem;\r\nconst char *name = NULL;\r\nunsigned long val;\r\nssize_t ret;\r\nret = kstrtoul_from_user(ubuf, cnt, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nret = tracing_update_buffers();\r\nif (ret < 0)\r\nreturn ret;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nif (system)\r\nname = system->name;\r\nret = __ftrace_set_clr_event(dir->tr, NULL, name, NULL, val);\r\nif (ret)\r\ngoto out;\r\nret = cnt;\r\nout:\r\n*ppos += cnt;\r\nreturn ret;\r\n}\r\nstatic void *f_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct trace_event_call *call = event_file_data(m->private);\r\nstruct list_head *common_head = &ftrace_common_fields;\r\nstruct list_head *head = trace_get_fields(call);\r\nstruct list_head *node = v;\r\n(*pos)++;\r\nswitch ((unsigned long)v) {\r\ncase FORMAT_HEADER:\r\nnode = common_head;\r\nbreak;\r\ncase FORMAT_FIELD_SEPERATOR:\r\nnode = head;\r\nbreak;\r\ncase FORMAT_PRINTFMT:\r\nreturn NULL;\r\n}\r\nnode = node->prev;\r\nif (node == common_head)\r\nreturn (void *)FORMAT_FIELD_SEPERATOR;\r\nelse if (node == head)\r\nreturn (void *)FORMAT_PRINTFMT;\r\nelse\r\nreturn node;\r\n}\r\nstatic int f_show(struct seq_file *m, void *v)\r\n{\r\nstruct trace_event_call *call = event_file_data(m->private);\r\nstruct ftrace_event_field *field;\r\nconst char *array_descriptor;\r\nswitch ((unsigned long)v) {\r\ncase FORMAT_HEADER:\r\nseq_printf(m, "name: %s\n", trace_event_name(call));\r\nseq_printf(m, "ID: %d\n", call->event.type);\r\nseq_puts(m, "format:\n");\r\nreturn 0;\r\ncase FORMAT_FIELD_SEPERATOR:\r\nseq_putc(m, '\n');\r\nreturn 0;\r\ncase FORMAT_PRINTFMT:\r\nseq_printf(m, "\nprint fmt: %s\n",\r\ncall->print_fmt);\r\nreturn 0;\r\n}\r\nfield = list_entry(v, struct ftrace_event_field, link);\r\narray_descriptor = strchr(field->type, '[');\r\nif (!strncmp(field->type, "__data_loc", 10))\r\narray_descriptor = NULL;\r\nif (!array_descriptor)\r\nseq_printf(m, "\tfield:%s %s;\toffset:%u;\tsize:%u;\tsigned:%d;\n",\r\nfield->type, field->name, field->offset,\r\nfield->size, !!field->is_signed);\r\nelse\r\nseq_printf(m, "\tfield:%.*s %s%s;\toffset:%u;\tsize:%u;\tsigned:%d;\n",\r\n(int)(array_descriptor - field->type),\r\nfield->type, field->name,\r\narray_descriptor, field->offset,\r\nfield->size, !!field->is_signed);\r\nreturn 0;\r\n}\r\nstatic void *f_start(struct seq_file *m, loff_t *pos)\r\n{\r\nvoid *p = (void *)FORMAT_HEADER;\r\nloff_t l = 0;\r\nmutex_lock(&event_mutex);\r\nif (!event_file_data(m->private))\r\nreturn ERR_PTR(-ENODEV);\r\nwhile (l < *pos && p)\r\np = f_next(m, p, &l);\r\nreturn p;\r\n}\r\nstatic void f_stop(struct seq_file *m, void *p)\r\n{\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic int trace_format_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m;\r\nint ret;\r\nret = seq_open(file, &trace_format_seq_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nm = file->private_data;\r\nm->private = file;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nevent_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\r\n{\r\nint id = (long)event_file_data(filp);\r\nchar buf[32];\r\nint len;\r\nif (*ppos)\r\nreturn 0;\r\nif (unlikely(!id))\r\nreturn -ENODEV;\r\nlen = sprintf(buf, "%d\n", id);\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\r\n}\r\nstatic ssize_t\r\nevent_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_seq *s;\r\nint r = -ENODEV;\r\nif (*ppos)\r\nreturn 0;\r\ns = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ntrace_seq_init(s);\r\nmutex_lock(&event_mutex);\r\nfile = event_file_data(filp);\r\nif (file)\r\nprint_event_filter(file, s);\r\nmutex_unlock(&event_mutex);\r\nif (file)\r\nr = simple_read_from_buffer(ubuf, cnt, ppos,\r\ns->buffer, trace_seq_used(s));\r\nkfree(s);\r\nreturn r;\r\n}\r\nstatic ssize_t\r\nevent_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_event_file *file;\r\nchar *buf;\r\nint err = -ENODEV;\r\nif (cnt >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = memdup_user_nul(ubuf, cnt);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nmutex_lock(&event_mutex);\r\nfile = event_file_data(filp);\r\nif (file)\r\nerr = apply_event_filter(file, buf);\r\nmutex_unlock(&event_mutex);\r\nkfree(buf);\r\nif (err < 0)\r\nreturn err;\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic int subsystem_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct event_subsystem *system = NULL;\r\nstruct trace_subsystem_dir *dir = NULL;\r\nstruct trace_array *tr;\r\nint ret;\r\nif (tracing_is_disabled())\r\nreturn -ENODEV;\r\nmutex_lock(&trace_types_lock);\r\nmutex_lock(&event_mutex);\r\nlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\r\nlist_for_each_entry(dir, &tr->systems, list) {\r\nif (dir == inode->i_private) {\r\nif (dir->nr_events) {\r\n__get_system_dir(dir);\r\nsystem = dir->subsystem;\r\n}\r\ngoto exit_loop;\r\n}\r\n}\r\n}\r\nexit_loop:\r\nmutex_unlock(&event_mutex);\r\nmutex_unlock(&trace_types_lock);\r\nif (!system)\r\nreturn -ENODEV;\r\nWARN_ON(!dir);\r\nif (trace_array_get(tr) < 0) {\r\nput_system(dir);\r\nreturn -ENODEV;\r\n}\r\nret = tracing_open_generic(inode, filp);\r\nif (ret < 0) {\r\ntrace_array_put(tr);\r\nput_system(dir);\r\n}\r\nreturn ret;\r\n}\r\nstatic int system_tr_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct trace_subsystem_dir *dir;\r\nstruct trace_array *tr = inode->i_private;\r\nint ret;\r\nif (tracing_is_disabled())\r\nreturn -ENODEV;\r\nif (trace_array_get(tr) < 0)\r\nreturn -ENODEV;\r\ndir = kzalloc(sizeof(*dir), GFP_KERNEL);\r\nif (!dir) {\r\ntrace_array_put(tr);\r\nreturn -ENOMEM;\r\n}\r\ndir->tr = tr;\r\nret = tracing_open_generic(inode, filp);\r\nif (ret < 0) {\r\ntrace_array_put(tr);\r\nkfree(dir);\r\nreturn ret;\r\n}\r\nfilp->private_data = dir;\r\nreturn 0;\r\n}\r\nstatic int subsystem_release(struct inode *inode, struct file *file)\r\n{\r\nstruct trace_subsystem_dir *dir = file->private_data;\r\ntrace_array_put(dir->tr);\r\nif (dir->subsystem)\r\nput_system(dir);\r\nelse\r\nkfree(dir);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsubsystem_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_subsystem_dir *dir = filp->private_data;\r\nstruct event_subsystem *system = dir->subsystem;\r\nstruct trace_seq *s;\r\nint r;\r\nif (*ppos)\r\nreturn 0;\r\ns = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ntrace_seq_init(s);\r\nprint_subsystem_event_filter(system, s);\r\nr = simple_read_from_buffer(ubuf, cnt, ppos,\r\ns->buffer, trace_seq_used(s));\r\nkfree(s);\r\nreturn r;\r\n}\r\nstatic ssize_t\r\nsubsystem_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\r\nloff_t *ppos)\r\n{\r\nstruct trace_subsystem_dir *dir = filp->private_data;\r\nchar *buf;\r\nint err;\r\nif (cnt >= PAGE_SIZE)\r\nreturn -EINVAL;\r\nbuf = memdup_user_nul(ubuf, cnt);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nerr = apply_subsystem_event_filter(dir, buf);\r\nkfree(buf);\r\nif (err < 0)\r\nreturn err;\r\n*ppos += cnt;\r\nreturn cnt;\r\n}\r\nstatic ssize_t\r\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\r\n{\r\nint (*func)(struct trace_seq *s) = filp->private_data;\r\nstruct trace_seq *s;\r\nint r;\r\nif (*ppos)\r\nreturn 0;\r\ns = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ntrace_seq_init(s);\r\nfunc(s);\r\nr = simple_read_from_buffer(ubuf, cnt, ppos,\r\ns->buffer, trace_seq_used(s));\r\nkfree(s);\r\nreturn r;\r\n}\r\nstatic void ignore_task_cpu(void *data)\r\n{\r\nstruct trace_array *tr = data;\r\nstruct trace_pid_list *pid_list;\r\npid_list = rcu_dereference_protected(tr->filtered_pids,\r\nmutex_is_locked(&event_mutex));\r\nthis_cpu_write(tr->trace_buffer.data->ignore_pid,\r\ntrace_ignore_this_task(pid_list, current));\r\n}\r\nstatic ssize_t\r\nftrace_event_pid_write(struct file *filp, const char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nstruct seq_file *m = filp->private_data;\r\nstruct trace_array *tr = m->private;\r\nstruct trace_pid_list *filtered_pids = NULL;\r\nstruct trace_pid_list *pid_list;\r\nstruct trace_event_file *file;\r\nssize_t ret;\r\nif (!cnt)\r\nreturn 0;\r\nret = tracing_update_buffers();\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&event_mutex);\r\nfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\r\nlockdep_is_held(&event_mutex));\r\nret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\r\nif (ret < 0)\r\ngoto out;\r\nrcu_assign_pointer(tr->filtered_pids, pid_list);\r\nlist_for_each_entry(file, &tr->events, list) {\r\nset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\r\n}\r\nif (filtered_pids) {\r\nsynchronize_sched();\r\ntrace_free_pid_list(filtered_pids);\r\n} else if (pid_list) {\r\nregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\r\ntr, INT_MAX);\r\nregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\r\ntr, 0);\r\nregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\r\ntr, INT_MAX);\r\nregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\r\ntr, 0);\r\nregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\r\ntr, INT_MAX);\r\nregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\r\ntr, 0);\r\nregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\r\ntr, INT_MAX);\r\nregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\r\ntr, 0);\r\n}\r\non_each_cpu(ignore_task_cpu, tr, 1);\r\nout:\r\nmutex_unlock(&event_mutex);\r\nif (ret > 0)\r\n*ppos += ret;\r\nreturn ret;\r\n}\r\nstatic int\r\nftrace_event_open(struct inode *inode, struct file *file,\r\nconst struct seq_operations *seq_ops)\r\n{\r\nstruct seq_file *m;\r\nint ret;\r\nret = seq_open(file, seq_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nm = file->private_data;\r\nm->private = inode->i_private;\r\nreturn ret;\r\n}\r\nstatic int ftrace_event_release(struct inode *inode, struct file *file)\r\n{\r\nstruct trace_array *tr = inode->i_private;\r\ntrace_array_put(tr);\r\nreturn seq_release(inode, file);\r\n}\r\nstatic int\r\nftrace_event_avail_open(struct inode *inode, struct file *file)\r\n{\r\nconst struct seq_operations *seq_ops = &show_event_seq_ops;\r\nreturn ftrace_event_open(inode, file, seq_ops);\r\n}\r\nstatic int\r\nftrace_event_set_open(struct inode *inode, struct file *file)\r\n{\r\nconst struct seq_operations *seq_ops = &show_set_event_seq_ops;\r\nstruct trace_array *tr = inode->i_private;\r\nint ret;\r\nif (trace_array_get(tr) < 0)\r\nreturn -ENODEV;\r\nif ((file->f_mode & FMODE_WRITE) &&\r\n(file->f_flags & O_TRUNC))\r\nftrace_clear_events(tr);\r\nret = ftrace_event_open(inode, file, seq_ops);\r\nif (ret < 0)\r\ntrace_array_put(tr);\r\nreturn ret;\r\n}\r\nstatic int\r\nftrace_event_set_pid_open(struct inode *inode, struct file *file)\r\n{\r\nconst struct seq_operations *seq_ops = &show_set_pid_seq_ops;\r\nstruct trace_array *tr = inode->i_private;\r\nint ret;\r\nif (trace_array_get(tr) < 0)\r\nreturn -ENODEV;\r\nif ((file->f_mode & FMODE_WRITE) &&\r\n(file->f_flags & O_TRUNC))\r\nftrace_clear_event_pids(tr);\r\nret = ftrace_event_open(inode, file, seq_ops);\r\nif (ret < 0)\r\ntrace_array_put(tr);\r\nreturn ret;\r\n}\r\nstatic struct event_subsystem *\r\ncreate_new_subsystem(const char *name)\r\n{\r\nstruct event_subsystem *system;\r\nsystem = kmalloc(sizeof(*system), GFP_KERNEL);\r\nif (!system)\r\nreturn NULL;\r\nsystem->ref_count = 1;\r\nsystem->name = kstrdup_const(name, GFP_KERNEL);\r\nif (!system->name)\r\ngoto out_free;\r\nsystem->filter = NULL;\r\nsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\r\nif (!system->filter)\r\ngoto out_free;\r\nlist_add(&system->list, &event_subsystems);\r\nreturn system;\r\nout_free:\r\nkfree_const(system->name);\r\nkfree(system);\r\nreturn NULL;\r\n}\r\nstatic struct dentry *\r\nevent_subsystem_dir(struct trace_array *tr, const char *name,\r\nstruct trace_event_file *file, struct dentry *parent)\r\n{\r\nstruct trace_subsystem_dir *dir;\r\nstruct event_subsystem *system;\r\nstruct dentry *entry;\r\nlist_for_each_entry(dir, &tr->systems, list) {\r\nsystem = dir->subsystem;\r\nif (strcmp(system->name, name) == 0) {\r\ndir->nr_events++;\r\nfile->system = dir;\r\nreturn dir->entry;\r\n}\r\n}\r\nlist_for_each_entry(system, &event_subsystems, list) {\r\nif (strcmp(system->name, name) == 0)\r\nbreak;\r\n}\r\nif (&system->list == &event_subsystems)\r\nsystem = NULL;\r\ndir = kmalloc(sizeof(*dir), GFP_KERNEL);\r\nif (!dir)\r\ngoto out_fail;\r\nif (!system) {\r\nsystem = create_new_subsystem(name);\r\nif (!system)\r\ngoto out_free;\r\n} else\r\n__get_system(system);\r\ndir->entry = tracefs_create_dir(name, parent);\r\nif (!dir->entry) {\r\npr_warn("Failed to create system directory %s\n", name);\r\n__put_system(system);\r\ngoto out_free;\r\n}\r\ndir->tr = tr;\r\ndir->ref_count = 1;\r\ndir->nr_events = 1;\r\ndir->subsystem = system;\r\nfile->system = dir;\r\nentry = tracefs_create_file("filter", 0644, dir->entry, dir,\r\n&ftrace_subsystem_filter_fops);\r\nif (!entry) {\r\nkfree(system->filter);\r\nsystem->filter = NULL;\r\npr_warn("Could not create tracefs '%s/filter' entry\n", name);\r\n}\r\ntrace_create_file("enable", 0644, dir->entry, dir,\r\n&ftrace_system_enable_fops);\r\nlist_add(&dir->list, &tr->systems);\r\nreturn dir->entry;\r\nout_free:\r\nkfree(dir);\r\nout_fail:\r\nif (!dir || !system)\r\npr_warn("No memory to create event subsystem %s\n", name);\r\nreturn NULL;\r\n}\r\nstatic int\r\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\r\n{\r\nstruct trace_event_call *call = file->event_call;\r\nstruct trace_array *tr = file->tr;\r\nstruct list_head *head;\r\nstruct dentry *d_events;\r\nconst char *name;\r\nint ret;\r\nif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\r\nd_events = event_subsystem_dir(tr, call->class->system, file, parent);\r\nif (!d_events)\r\nreturn -ENOMEM;\r\n} else\r\nd_events = parent;\r\nname = trace_event_name(call);\r\nfile->dir = tracefs_create_dir(name, d_events);\r\nif (!file->dir) {\r\npr_warn("Could not create tracefs '%s' directory\n", name);\r\nreturn -1;\r\n}\r\nif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\r\ntrace_create_file("enable", 0644, file->dir, file,\r\n&ftrace_enable_fops);\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (call->event.type && call->class->reg)\r\ntrace_create_file("id", 0444, file->dir,\r\n(void *)(long)call->event.type,\r\n&ftrace_event_id_fops);\r\n#endif\r\nhead = trace_get_fields(call);\r\nif (list_empty(head)) {\r\nret = call->class->define_fields(call);\r\nif (ret < 0) {\r\npr_warn("Could not initialize trace point events/%s\n",\r\nname);\r\nreturn -1;\r\n}\r\n}\r\ntrace_create_file("filter", 0644, file->dir, file,\r\n&ftrace_event_filter_fops);\r\nif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\r\ntrace_create_file("trigger", 0644, file->dir, file,\r\n&event_trigger_fops);\r\n#ifdef CONFIG_HIST_TRIGGERS\r\ntrace_create_file("hist", 0444, file->dir, file,\r\n&event_hist_fops);\r\n#endif\r\ntrace_create_file("format", 0444, file->dir, call,\r\n&ftrace_event_format_fops);\r\nreturn 0;\r\n}\r\nstatic void remove_event_from_tracers(struct trace_event_call *call)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_array *tr;\r\ndo_for_each_event_file_safe(tr, file) {\r\nif (file->event_call != call)\r\ncontinue;\r\nremove_event_file_dir(file);\r\nbreak;\r\n} while_for_each_event_file();\r\n}\r\nstatic void event_remove(struct trace_event_call *call)\r\n{\r\nstruct trace_array *tr;\r\nstruct trace_event_file *file;\r\ndo_for_each_event_file(tr, file) {\r\nif (file->event_call != call)\r\ncontinue;\r\nftrace_event_enable_disable(file, 0);\r\nbreak;\r\n} while_for_each_event_file();\r\nif (call->event.funcs)\r\n__unregister_trace_event(&call->event);\r\nremove_event_from_tracers(call);\r\nlist_del(&call->list);\r\n}\r\nstatic int event_init(struct trace_event_call *call)\r\n{\r\nint ret = 0;\r\nconst char *name;\r\nname = trace_event_name(call);\r\nif (WARN_ON(!name))\r\nreturn -EINVAL;\r\nif (call->class->raw_init) {\r\nret = call->class->raw_init(call);\r\nif (ret < 0 && ret != -ENOSYS)\r\npr_warn("Could not initialize trace events/%s\n", name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\n__register_event(struct trace_event_call *call, struct module *mod)\r\n{\r\nint ret;\r\nret = event_init(call);\r\nif (ret < 0)\r\nreturn ret;\r\nlist_add(&call->list, &ftrace_events);\r\ncall->mod = mod;\r\nreturn 0;\r\n}\r\nstatic char *enum_replace(char *ptr, struct trace_enum_map *map, int len)\r\n{\r\nint rlen;\r\nint elen;\r\nelen = snprintf(ptr, 0, "%ld", map->enum_value);\r\nif (len < elen)\r\nreturn NULL;\r\nsnprintf(ptr, elen + 1, "%ld", map->enum_value);\r\nrlen = strlen(ptr + len);\r\nmemmove(ptr + elen, ptr + len, rlen);\r\nptr[elen + rlen] = 0;\r\nreturn ptr + elen;\r\n}\r\nstatic void update_event_printk(struct trace_event_call *call,\r\nstruct trace_enum_map *map)\r\n{\r\nchar *ptr;\r\nint quote = 0;\r\nint len = strlen(map->enum_string);\r\nfor (ptr = call->print_fmt; *ptr; ptr++) {\r\nif (*ptr == '\\') {\r\nptr++;\r\nif (!*ptr)\r\nbreak;\r\ncontinue;\r\n}\r\nif (*ptr == '"') {\r\nquote ^= 1;\r\ncontinue;\r\n}\r\nif (quote)\r\ncontinue;\r\nif (isdigit(*ptr)) {\r\ndo {\r\nptr++;\r\n} while (isalnum(*ptr));\r\nif (!*ptr)\r\nbreak;\r\ncontinue;\r\n}\r\nif (isalpha(*ptr) || *ptr == '_') {\r\nif (strncmp(map->enum_string, ptr, len) == 0 &&\r\n!isalnum(ptr[len]) && ptr[len] != '_') {\r\nptr = enum_replace(ptr, map, len);\r\nif (WARN_ON_ONCE(!ptr))\r\nreturn;\r\ncontinue;\r\n}\r\nskip_more:\r\ndo {\r\nptr++;\r\n} while (isalnum(*ptr) || *ptr == '_');\r\nif (!*ptr)\r\nbreak;\r\nif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\r\nptr += *ptr == '.' ? 1 : 2;\r\nif (!*ptr)\r\nbreak;\r\ngoto skip_more;\r\n}\r\ncontinue;\r\n}\r\n}\r\n}\r\nvoid trace_event_enum_update(struct trace_enum_map **map, int len)\r\n{\r\nstruct trace_event_call *call, *p;\r\nconst char *last_system = NULL;\r\nint last_i;\r\nint i;\r\ndown_write(&trace_event_sem);\r\nlist_for_each_entry_safe(call, p, &ftrace_events, list) {\r\nif (!last_system || call->class->system != last_system) {\r\nlast_i = 0;\r\nlast_system = call->class->system;\r\n}\r\nfor (i = last_i; i < len; i++) {\r\nif (call->class->system == map[i]->system) {\r\nif (!last_i)\r\nlast_i = i;\r\nupdate_event_printk(call, map[i]);\r\n}\r\n}\r\n}\r\nup_write(&trace_event_sem);\r\n}\r\nstatic struct trace_event_file *\r\ntrace_create_new_event(struct trace_event_call *call,\r\nstruct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\r\nif (!file)\r\nreturn NULL;\r\nfile->event_call = call;\r\nfile->tr = tr;\r\natomic_set(&file->sm_ref, 0);\r\natomic_set(&file->tm_ref, 0);\r\nINIT_LIST_HEAD(&file->triggers);\r\nlist_add(&file->list, &tr->events);\r\nreturn file;\r\n}\r\nstatic int\r\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nfile = trace_create_new_event(call, tr);\r\nif (!file)\r\nreturn -ENOMEM;\r\nreturn event_create_dir(tr->event_dir, file);\r\n}\r\nstatic __init int\r\n__trace_early_add_new_event(struct trace_event_call *call,\r\nstruct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nfile = trace_create_new_event(call, tr);\r\nif (!file)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint trace_add_event_call(struct trace_event_call *call)\r\n{\r\nint ret;\r\nmutex_lock(&trace_types_lock);\r\nmutex_lock(&event_mutex);\r\nret = __register_event(call, NULL);\r\nif (ret >= 0)\r\n__add_event_to_tracers(call);\r\nmutex_unlock(&event_mutex);\r\nmutex_unlock(&trace_types_lock);\r\nreturn ret;\r\n}\r\nstatic void __trace_remove_event_call(struct trace_event_call *call)\r\n{\r\nevent_remove(call);\r\ntrace_destroy_fields(call);\r\nfree_event_filter(call->filter);\r\ncall->filter = NULL;\r\n}\r\nstatic int probe_remove_event_call(struct trace_event_call *call)\r\n{\r\nstruct trace_array *tr;\r\nstruct trace_event_file *file;\r\n#ifdef CONFIG_PERF_EVENTS\r\nif (call->perf_refcount)\r\nreturn -EBUSY;\r\n#endif\r\ndo_for_each_event_file(tr, file) {\r\nif (file->event_call != call)\r\ncontinue;\r\nif (file->flags & EVENT_FILE_FL_ENABLED)\r\nreturn -EBUSY;\r\nbreak;\r\n} while_for_each_event_file();\r\n__trace_remove_event_call(call);\r\nreturn 0;\r\n}\r\nint trace_remove_event_call(struct trace_event_call *call)\r\n{\r\nint ret;\r\nmutex_lock(&trace_types_lock);\r\nmutex_lock(&event_mutex);\r\ndown_write(&trace_event_sem);\r\nret = probe_remove_event_call(call);\r\nup_write(&trace_event_sem);\r\nmutex_unlock(&event_mutex);\r\nmutex_unlock(&trace_types_lock);\r\nreturn ret;\r\n}\r\nstatic void trace_module_add_events(struct module *mod)\r\n{\r\nstruct trace_event_call **call, **start, **end;\r\nif (!mod->num_trace_events)\r\nreturn;\r\nif (trace_module_has_bad_taint(mod)) {\r\npr_err("%s: module has bad taint, not creating trace events\n",\r\nmod->name);\r\nreturn;\r\n}\r\nstart = mod->trace_events;\r\nend = mod->trace_events + mod->num_trace_events;\r\nfor_each_event(call, start, end) {\r\n__register_event(*call, mod);\r\n__add_event_to_tracers(*call);\r\n}\r\n}\r\nstatic void trace_module_remove_events(struct module *mod)\r\n{\r\nstruct trace_event_call *call, *p;\r\nbool clear_trace = false;\r\ndown_write(&trace_event_sem);\r\nlist_for_each_entry_safe(call, p, &ftrace_events, list) {\r\nif (call->mod == mod) {\r\nif (call->flags & TRACE_EVENT_FL_WAS_ENABLED)\r\nclear_trace = true;\r\n__trace_remove_event_call(call);\r\n}\r\n}\r\nup_write(&trace_event_sem);\r\nif (clear_trace)\r\ntracing_reset_all_online_cpus();\r\n}\r\nstatic int trace_module_notify(struct notifier_block *self,\r\nunsigned long val, void *data)\r\n{\r\nstruct module *mod = data;\r\nmutex_lock(&trace_types_lock);\r\nmutex_lock(&event_mutex);\r\nswitch (val) {\r\ncase MODULE_STATE_COMING:\r\ntrace_module_add_events(mod);\r\nbreak;\r\ncase MODULE_STATE_GOING:\r\ntrace_module_remove_events(mod);\r\nbreak;\r\n}\r\nmutex_unlock(&event_mutex);\r\nmutex_unlock(&trace_types_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\n__trace_add_event_dirs(struct trace_array *tr)\r\n{\r\nstruct trace_event_call *call;\r\nint ret;\r\nlist_for_each_entry(call, &ftrace_events, list) {\r\nret = __trace_add_new_event(call, tr);\r\nif (ret < 0)\r\npr_warn("Could not create directory for event %s\n",\r\ntrace_event_name(call));\r\n}\r\n}\r\nstruct trace_event_file *\r\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\r\n{\r\nstruct trace_event_file *file;\r\nstruct trace_event_call *call;\r\nconst char *name;\r\nlist_for_each_entry(file, &tr->events, list) {\r\ncall = file->event_call;\r\nname = trace_event_name(call);\r\nif (!name || !call->class || !call->class->reg)\r\ncontinue;\r\nif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\r\ncontinue;\r\nif (strcmp(event, name) == 0 &&\r\nstrcmp(system, call->class->system) == 0)\r\nreturn file;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nevent_enable_probe(unsigned long ip, unsigned long parent_ip, void **_data)\r\n{\r\nstruct event_probe_data **pdata = (struct event_probe_data **)_data;\r\nstruct event_probe_data *data = *pdata;\r\nif (!data)\r\nreturn;\r\nif (data->enable)\r\nclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\r\nelse\r\nset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\r\n}\r\nstatic void\r\nevent_enable_count_probe(unsigned long ip, unsigned long parent_ip, void **_data)\r\n{\r\nstruct event_probe_data **pdata = (struct event_probe_data **)_data;\r\nstruct event_probe_data *data = *pdata;\r\nif (!data)\r\nreturn;\r\nif (!data->count)\r\nreturn;\r\nif (data->enable == !(data->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\r\nreturn;\r\nif (data->count != -1)\r\n(data->count)--;\r\nevent_enable_probe(ip, parent_ip, _data);\r\n}\r\nstatic int\r\nevent_enable_print(struct seq_file *m, unsigned long ip,\r\nstruct ftrace_probe_ops *ops, void *_data)\r\n{\r\nstruct event_probe_data *data = _data;\r\nseq_printf(m, "%ps:", (void *)ip);\r\nseq_printf(m, "%s:%s:%s",\r\ndata->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\r\ndata->file->event_call->class->system,\r\ntrace_event_name(data->file->event_call));\r\nif (data->count == -1)\r\nseq_puts(m, ":unlimited\n");\r\nelse\r\nseq_printf(m, ":count=%ld\n", data->count);\r\nreturn 0;\r\n}\r\nstatic int\r\nevent_enable_init(struct ftrace_probe_ops *ops, unsigned long ip,\r\nvoid **_data)\r\n{\r\nstruct event_probe_data **pdata = (struct event_probe_data **)_data;\r\nstruct event_probe_data *data = *pdata;\r\ndata->ref++;\r\nreturn 0;\r\n}\r\nstatic void\r\nevent_enable_free(struct ftrace_probe_ops *ops, unsigned long ip,\r\nvoid **_data)\r\n{\r\nstruct event_probe_data **pdata = (struct event_probe_data **)_data;\r\nstruct event_probe_data *data = *pdata;\r\nif (WARN_ON_ONCE(data->ref <= 0))\r\nreturn;\r\ndata->ref--;\r\nif (!data->ref) {\r\n__ftrace_event_enable_disable(data->file, 0, 1);\r\nmodule_put(data->file->event_call->mod);\r\nkfree(data);\r\n}\r\n*pdata = NULL;\r\n}\r\nstatic int\r\nevent_enable_func(struct ftrace_hash *hash,\r\nchar *glob, char *cmd, char *param, int enabled)\r\n{\r\nstruct trace_array *tr = top_trace_array();\r\nstruct trace_event_file *file;\r\nstruct ftrace_probe_ops *ops;\r\nstruct event_probe_data *data;\r\nconst char *system;\r\nconst char *event;\r\nchar *number;\r\nbool enable;\r\nint ret;\r\nif (!tr)\r\nreturn -ENODEV;\r\nif (!enabled || !param)\r\nreturn -EINVAL;\r\nsystem = strsep(&param, ":");\r\nif (!param)\r\nreturn -EINVAL;\r\nevent = strsep(&param, ":");\r\nmutex_lock(&event_mutex);\r\nret = -EINVAL;\r\nfile = find_event_file(tr, system, event);\r\nif (!file)\r\ngoto out;\r\nenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\r\nif (enable)\r\nops = param ? &event_enable_count_probe_ops : &event_enable_probe_ops;\r\nelse\r\nops = param ? &event_disable_count_probe_ops : &event_disable_probe_ops;\r\nif (glob[0] == '!') {\r\nunregister_ftrace_function_probe_func(glob+1, ops);\r\nret = 0;\r\ngoto out;\r\n}\r\nret = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\ndata->enable = enable;\r\ndata->count = -1;\r\ndata->file = file;\r\nif (!param)\r\ngoto out_reg;\r\nnumber = strsep(&param, ":");\r\nret = -EINVAL;\r\nif (!strlen(number))\r\ngoto out_free;\r\nret = kstrtoul(number, 0, &data->count);\r\nif (ret)\r\ngoto out_free;\r\nout_reg:\r\nret = try_module_get(file->event_call->mod);\r\nif (!ret) {\r\nret = -EBUSY;\r\ngoto out_free;\r\n}\r\nret = __ftrace_event_enable_disable(file, 1, 1);\r\nif (ret < 0)\r\ngoto out_put;\r\nret = register_ftrace_function_probe(glob, ops, data);\r\nif (!ret) {\r\nret = -ENOENT;\r\ngoto out_disable;\r\n} else if (ret < 0)\r\ngoto out_disable;\r\nret = 0;\r\nout:\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\nout_disable:\r\n__ftrace_event_enable_disable(file, 0, 1);\r\nout_put:\r\nmodule_put(file->event_call->mod);\r\nout_free:\r\nkfree(data);\r\ngoto out;\r\n}\r\nstatic __init int register_event_cmds(void)\r\n{\r\nint ret;\r\nret = register_ftrace_command(&event_enable_cmd);\r\nif (WARN_ON(ret < 0))\r\nreturn ret;\r\nret = register_ftrace_command(&event_disable_cmd);\r\nif (WARN_ON(ret < 0))\r\nunregister_ftrace_command(&event_enable_cmd);\r\nreturn ret;\r\n}\r\nstatic inline int register_event_cmds(void) { return 0; }\r\nstatic __init void\r\n__trace_early_add_event_dirs(struct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nint ret;\r\nlist_for_each_entry(file, &tr->events, list) {\r\nret = event_create_dir(tr->event_dir, file);\r\nif (ret < 0)\r\npr_warn("Could not create directory for event %s\n",\r\ntrace_event_name(file->event_call));\r\n}\r\n}\r\nstatic __init void\r\n__trace_early_add_events(struct trace_array *tr)\r\n{\r\nstruct trace_event_call *call;\r\nint ret;\r\nlist_for_each_entry(call, &ftrace_events, list) {\r\nif (WARN_ON_ONCE(call->mod))\r\ncontinue;\r\nret = __trace_early_add_new_event(call, tr);\r\nif (ret < 0)\r\npr_warn("Could not create early event %s\n",\r\ntrace_event_name(call));\r\n}\r\n}\r\nstatic void\r\n__trace_remove_event_dirs(struct trace_array *tr)\r\n{\r\nstruct trace_event_file *file, *next;\r\nlist_for_each_entry_safe(file, next, &tr->events, list)\r\nremove_event_file_dir(file);\r\n}\r\nstatic void __add_event_to_tracers(struct trace_event_call *call)\r\n{\r\nstruct trace_array *tr;\r\nlist_for_each_entry(tr, &ftrace_trace_arrays, list)\r\n__trace_add_new_event(call, tr);\r\n}\r\nstatic __init int setup_trace_event(char *str)\r\n{\r\nstrlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);\r\nring_buffer_expanded = true;\r\ntracing_selftest_disabled = true;\r\nreturn 1;\r\n}\r\nstatic int\r\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\r\n{\r\nstruct dentry *d_events;\r\nstruct dentry *entry;\r\nentry = tracefs_create_file("set_event", 0644, parent,\r\ntr, &ftrace_set_event_fops);\r\nif (!entry) {\r\npr_warn("Could not create tracefs 'set_event' entry\n");\r\nreturn -ENOMEM;\r\n}\r\nd_events = tracefs_create_dir("events", parent);\r\nif (!d_events) {\r\npr_warn("Could not create tracefs 'events' directory\n");\r\nreturn -ENOMEM;\r\n}\r\nentry = trace_create_file("enable", 0644, d_events,\r\ntr, &ftrace_tr_enable_fops);\r\nif (!entry) {\r\npr_warn("Could not create tracefs 'enable' entry\n");\r\nreturn -ENOMEM;\r\n}\r\nentry = tracefs_create_file("set_event_pid", 0644, parent,\r\ntr, &ftrace_set_event_pid_fops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'set_event_pid' entry\n");\r\nentry = trace_create_file("header_page", 0444, d_events,\r\nring_buffer_print_page_header,\r\n&ftrace_show_header_fops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'header_page' entry\n");\r\nentry = trace_create_file("header_event", 0444, d_events,\r\nring_buffer_print_entry_header,\r\n&ftrace_show_header_fops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'header_event' entry\n");\r\ntr->event_dir = d_events;\r\nreturn 0;\r\n}\r\nint event_trace_add_tracer(struct dentry *parent, struct trace_array *tr)\r\n{\r\nint ret;\r\nmutex_lock(&event_mutex);\r\nret = create_event_toplevel_files(parent, tr);\r\nif (ret)\r\ngoto out_unlock;\r\ndown_write(&trace_event_sem);\r\n__trace_add_event_dirs(tr);\r\nup_write(&trace_event_sem);\r\nout_unlock:\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\n}\r\nstatic __init int\r\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\r\n{\r\nint ret;\r\nmutex_lock(&event_mutex);\r\nret = create_event_toplevel_files(parent, tr);\r\nif (ret)\r\ngoto out_unlock;\r\ndown_write(&trace_event_sem);\r\n__trace_early_add_event_dirs(tr);\r\nup_write(&trace_event_sem);\r\nout_unlock:\r\nmutex_unlock(&event_mutex);\r\nreturn ret;\r\n}\r\nint event_trace_del_tracer(struct trace_array *tr)\r\n{\r\nmutex_lock(&event_mutex);\r\nclear_event_triggers(tr);\r\n__ftrace_clear_event_pids(tr);\r\n__ftrace_set_clr_event_nolock(tr, NULL, NULL, NULL, 0);\r\nsynchronize_sched();\r\ndown_write(&trace_event_sem);\r\n__trace_remove_event_dirs(tr);\r\ntracefs_remove_recursive(tr->event_dir);\r\nup_write(&trace_event_sem);\r\ntr->event_dir = NULL;\r\nmutex_unlock(&event_mutex);\r\nreturn 0;\r\n}\r\nstatic __init int event_trace_memsetup(void)\r\n{\r\nfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\r\nfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\r\nreturn 0;\r\n}\r\nstatic __init void\r\nearly_enable_events(struct trace_array *tr, bool disable_first)\r\n{\r\nchar *buf = bootup_event_buf;\r\nchar *token;\r\nint ret;\r\nwhile (true) {\r\ntoken = strsep(&buf, ",");\r\nif (!token)\r\nbreak;\r\nif (*token) {\r\nif (disable_first)\r\nftrace_set_clr_event(tr, token, 0);\r\nret = ftrace_set_clr_event(tr, token, 1);\r\nif (ret)\r\npr_warn("Failed to enable trace event: %s\n", token);\r\n}\r\nif (buf)\r\n*(buf - 1) = ',';\r\n}\r\n}\r\nstatic __init int event_trace_enable(void)\r\n{\r\nstruct trace_array *tr = top_trace_array();\r\nstruct trace_event_call **iter, *call;\r\nint ret;\r\nif (!tr)\r\nreturn -ENODEV;\r\nfor_each_event(iter, __start_ftrace_events, __stop_ftrace_events) {\r\ncall = *iter;\r\nret = event_init(call);\r\nif (!ret)\r\nlist_add(&call->list, &ftrace_events);\r\n}\r\n__trace_early_add_events(tr);\r\nearly_enable_events(tr, false);\r\ntrace_printk_start_comm();\r\nregister_event_cmds();\r\nregister_trigger_cmds();\r\nreturn 0;\r\n}\r\nstatic __init int event_trace_enable_again(void)\r\n{\r\nstruct trace_array *tr;\r\ntr = top_trace_array();\r\nif (!tr)\r\nreturn -ENODEV;\r\nearly_enable_events(tr, true);\r\nreturn 0;\r\n}\r\nstatic __init int event_trace_init(void)\r\n{\r\nstruct trace_array *tr;\r\nstruct dentry *d_tracer;\r\nstruct dentry *entry;\r\nint ret;\r\ntr = top_trace_array();\r\nif (!tr)\r\nreturn -ENODEV;\r\nd_tracer = tracing_init_dentry();\r\nif (IS_ERR(d_tracer))\r\nreturn 0;\r\nentry = tracefs_create_file("available_events", 0444, d_tracer,\r\ntr, &ftrace_avail_fops);\r\nif (!entry)\r\npr_warn("Could not create tracefs 'available_events' entry\n");\r\nif (trace_define_generic_fields())\r\npr_warn("tracing: Failed to allocated generic fields");\r\nif (trace_define_common_fields())\r\npr_warn("tracing: Failed to allocate common fields");\r\nret = early_event_add_tracer(d_tracer, tr);\r\nif (ret)\r\nreturn ret;\r\n#ifdef CONFIG_MODULES\r\nret = register_module_notifier(&trace_module_nb);\r\nif (ret)\r\npr_warn("Failed to register trace events module notifier\n");\r\n#endif\r\nreturn 0;\r\n}\r\nvoid __init trace_event_init(void)\r\n{\r\nevent_trace_memsetup();\r\ninit_ftrace_syscalls();\r\nevent_trace_enable();\r\n}\r\nstatic __init void test_work(struct work_struct *dummy)\r\n{\r\nspin_lock(&test_spinlock);\r\nspin_lock_irq(&test_spinlock_irq);\r\nudelay(1);\r\nspin_unlock_irq(&test_spinlock_irq);\r\nspin_unlock(&test_spinlock);\r\nmutex_lock(&test_mutex);\r\nmsleep(1);\r\nmutex_unlock(&test_mutex);\r\n}\r\nstatic __init int event_test_thread(void *unused)\r\n{\r\nvoid *test_malloc;\r\ntest_malloc = kmalloc(1234, GFP_KERNEL);\r\nif (!test_malloc)\r\npr_info("failed to kmalloc\n");\r\nschedule_on_each_cpu(test_work);\r\nkfree(test_malloc);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!kthread_should_stop()) {\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nreturn 0;\r\n}\r\nstatic __init void event_test_stuff(void)\r\n{\r\nstruct task_struct *test_thread;\r\ntest_thread = kthread_run(event_test_thread, NULL, "test-events");\r\nmsleep(1);\r\nkthread_stop(test_thread);\r\n}\r\nstatic __init void event_trace_self_tests(void)\r\n{\r\nstruct trace_subsystem_dir *dir;\r\nstruct trace_event_file *file;\r\nstruct trace_event_call *call;\r\nstruct event_subsystem *system;\r\nstruct trace_array *tr;\r\nint ret;\r\ntr = top_trace_array();\r\nif (!tr)\r\nreturn;\r\npr_info("Running tests on trace events:\n");\r\nlist_for_each_entry(file, &tr->events, list) {\r\ncall = file->event_call;\r\nif (!call->class || !call->class->probe)\r\ncontinue;\r\n#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS\r\nif (call->class->system &&\r\nstrcmp(call->class->system, "syscalls") == 0)\r\ncontinue;\r\n#endif\r\npr_info("Testing event %s: ", trace_event_name(call));\r\nif (file->flags & EVENT_FILE_FL_ENABLED) {\r\npr_warn("Enabled event during self test!\n");\r\nWARN_ON_ONCE(1);\r\ncontinue;\r\n}\r\nftrace_event_enable_disable(file, 1);\r\nevent_test_stuff();\r\nftrace_event_enable_disable(file, 0);\r\npr_cont("OK\n");\r\n}\r\npr_info("Running tests on trace event systems:\n");\r\nlist_for_each_entry(dir, &tr->systems, list) {\r\nsystem = dir->subsystem;\r\nif (strcmp(system->name, "ftrace") == 0)\r\ncontinue;\r\npr_info("Testing event system %s: ", system->name);\r\nret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 1);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error enabling system %s\n",\r\nsystem->name);\r\ncontinue;\r\n}\r\nevent_test_stuff();\r\nret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 0);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error disabling system %s\n",\r\nsystem->name);\r\ncontinue;\r\n}\r\npr_cont("OK\n");\r\n}\r\npr_info("Running tests on all trace events:\n");\r\npr_info("Testing all events: ");\r\nret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 1);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error enabling all events\n");\r\nreturn;\r\n}\r\nevent_test_stuff();\r\nret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 0);\r\nif (WARN_ON_ONCE(ret)) {\r\npr_warn("error disabling all events\n");\r\nreturn;\r\n}\r\npr_cont("OK\n");\r\n}\r\nstatic void __init\r\nfunction_test_events_call(unsigned long ip, unsigned long parent_ip,\r\nstruct ftrace_ops *op, struct pt_regs *pt_regs)\r\n{\r\nstruct ring_buffer_event *event;\r\nstruct ring_buffer *buffer;\r\nstruct ftrace_entry *entry;\r\nunsigned long flags;\r\nlong disabled;\r\nint cpu;\r\nint pc;\r\npc = preempt_count();\r\npreempt_disable_notrace();\r\ncpu = raw_smp_processor_id();\r\ndisabled = atomic_inc_return(&per_cpu(ftrace_test_event_disable, cpu));\r\nif (disabled != 1)\r\ngoto out;\r\nlocal_save_flags(flags);\r\nevent = trace_event_buffer_lock_reserve(&buffer, &event_trace_file,\r\nTRACE_FN, sizeof(*entry),\r\nflags, pc);\r\nif (!event)\r\ngoto out;\r\nentry = ring_buffer_event_data(event);\r\nentry->ip = ip;\r\nentry->parent_ip = parent_ip;\r\nevent_trigger_unlock_commit(&event_trace_file, buffer, event,\r\nentry, flags, pc);\r\nout:\r\natomic_dec(&per_cpu(ftrace_test_event_disable, cpu));\r\npreempt_enable_notrace();\r\n}\r\nstatic __init void event_trace_self_test_with_function(void)\r\n{\r\nint ret;\r\nevent_trace_file.tr = top_trace_array();\r\nif (WARN_ON(!event_trace_file.tr))\r\nreturn;\r\nret = register_ftrace_function(&trace_ops);\r\nif (WARN_ON(ret < 0)) {\r\npr_info("Failed to enable function tracer for event tests\n");\r\nreturn;\r\n}\r\npr_info("Running tests again, along with the function tracer\n");\r\nevent_trace_self_tests();\r\nunregister_ftrace_function(&trace_ops);\r\n}\r\nstatic __init void event_trace_self_test_with_function(void)\r\n{\r\n}\r\nstatic __init int event_trace_self_tests_init(void)\r\n{\r\nif (!tracing_selftest_disabled) {\r\nevent_trace_self_tests();\r\nevent_trace_self_test_with_function();\r\n}\r\nreturn 0;\r\n}
