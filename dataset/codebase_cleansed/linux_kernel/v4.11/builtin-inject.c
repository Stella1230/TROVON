static int output_bytes(struct perf_inject *inject, void *buf, size_t sz)\r\n{\r\nssize_t size;\r\nsize = perf_data_file__write(&inject->output, buf, sz);\r\nif (size < 0)\r\nreturn -errno;\r\ninject->bytes_written += size;\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe_synth(struct perf_tool *tool,\r\nunion perf_event *event)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject,\r\ntool);\r\nreturn output_bytes(inject, event, event->header.size);\r\n}\r\nstatic int perf_event__repipe_oe_synth(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct ordered_events *oe __maybe_unused)\r\n{\r\nreturn perf_event__repipe_synth(tool, event);\r\n}\r\nstatic int perf_event__drop_oe(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct ordered_events *oe __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe_op2_synth(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session\r\n__maybe_unused)\r\n{\r\nreturn perf_event__repipe_synth(tool, event);\r\n}\r\nstatic int perf_event__repipe_attr(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_evlist **pevlist)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject,\r\ntool);\r\nint ret;\r\nret = perf_event__process_attr(tool, event, pevlist);\r\nif (ret)\r\nreturn ret;\r\nif (!inject->output.is_pipe)\r\nreturn 0;\r\nreturn perf_event__repipe_synth(tool, event);\r\n}\r\nstatic int copy_bytes(struct perf_inject *inject, int fd, off_t size)\r\n{\r\nchar buf[4096];\r\nssize_t ssz;\r\nint ret;\r\nwhile (size > 0) {\r\nssz = read(fd, buf, min(size, (off_t)sizeof(buf)));\r\nif (ssz < 0)\r\nreturn -errno;\r\nret = output_bytes(inject, buf, ssz);\r\nif (ret)\r\nreturn ret;\r\nsize -= ssz;\r\n}\r\nreturn 0;\r\n}\r\nstatic s64 perf_event__repipe_auxtrace(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject,\r\ntool);\r\nint ret;\r\ninject->have_auxtrace = true;\r\nif (!inject->output.is_pipe) {\r\noff_t offset;\r\noffset = lseek(inject->output.fd, 0, SEEK_CUR);\r\nif (offset == -1)\r\nreturn -errno;\r\nret = auxtrace_index__auxtrace_event(&session->auxtrace_index,\r\nevent, offset);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (perf_data_file__is_pipe(session->file) || !session->one_mmap) {\r\nret = output_bytes(inject, event, event->header.size);\r\nif (ret < 0)\r\nreturn ret;\r\nret = copy_bytes(inject, perf_data_file__fd(session->file),\r\nevent->auxtrace.size);\r\n} else {\r\nret = output_bytes(inject, event,\r\nevent->header.size + event->auxtrace.size);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn event->auxtrace.size;\r\n}\r\nstatic s64\r\nperf_event__repipe_auxtrace(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_session *session __maybe_unused)\r\n{\r\npr_err("AUX area tracing not supported\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int perf_event__repipe(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nreturn perf_event__repipe_synth(tool, event);\r\n}\r\nstatic int perf_event__drop(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int perf_event__drop_aux(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nif (!inject->aux_id)\r\ninject->aux_id = sample->id;\r\nreturn 0;\r\n}\r\nstatic int perf_event__repipe_sample(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nif (evsel->handler) {\r\ninject_handler f = evsel->handler;\r\nreturn f(tool, event, sample, evsel, machine);\r\n}\r\nbuild_id__mark_dso_hit(tool, event, sample, evsel, machine);\r\nreturn perf_event__repipe_synth(tool, event);\r\n}\r\nstatic int perf_event__repipe_mmap(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_mmap(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__jit_repipe_mmap(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nu64 n = 0;\r\nint ret;\r\nret = jit_process(inject->session, &inject->output, machine,\r\nevent->mmap.filename, sample->pid, &n);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret) {\r\ninject->bytes_written += n;\r\nreturn 0;\r\n}\r\nreturn perf_event__repipe_mmap(tool, event, sample, machine);\r\n}\r\nstatic int perf_event__repipe_mmap2(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_mmap2(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__jit_repipe_mmap2(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nu64 n = 0;\r\nint ret;\r\nret = jit_process(inject->session, &inject->output, machine,\r\nevent->mmap2.filename, sample->pid, &n);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret) {\r\ninject->bytes_written += n;\r\nreturn 0;\r\n}\r\nreturn perf_event__repipe_mmap2(tool, event, sample, machine);\r\n}\r\nstatic int perf_event__repipe_fork(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_fork(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_comm(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_comm(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_exit(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nint err;\r\nerr = perf_event__process_exit(tool, event, sample, machine);\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_tracing_data(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nperf_event__repipe_synth(tool, event);\r\nerr = perf_event__process_tracing_data(tool, event, session);\r\nreturn err;\r\n}\r\nstatic int perf_event__repipe_id_index(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_session *session)\r\n{\r\nint err;\r\nperf_event__repipe_synth(tool, event);\r\nerr = perf_event__process_id_index(tool, event, session);\r\nreturn err;\r\n}\r\nstatic int dso__read_build_id(struct dso *dso)\r\n{\r\nif (dso->has_build_id)\r\nreturn 0;\r\nif (filename__read_build_id(dso->long_name, dso->build_id,\r\nsizeof(dso->build_id)) > 0) {\r\ndso->has_build_id = true;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int dso__inject_build_id(struct dso *dso, struct perf_tool *tool,\r\nstruct machine *machine)\r\n{\r\nu16 misc = PERF_RECORD_MISC_USER;\r\nint err;\r\nif (dso__read_build_id(dso) < 0) {\r\npr_debug("no build_id found for %s\n", dso->long_name);\r\nreturn -1;\r\n}\r\nif (dso->kernel)\r\nmisc = PERF_RECORD_MISC_KERNEL;\r\nerr = perf_event__synthesize_build_id(tool, dso, misc, perf_event__repipe,\r\nmachine);\r\nif (err) {\r\npr_err("Can't synthesize build_id event for %s\n", dso->long_name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_event__inject_buildid(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread;\r\nthread = machine__findnew_thread(machine, sample->pid, sample->tid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\ngoto repipe;\r\n}\r\nthread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, sample->ip, &al);\r\nif (al.map != NULL) {\r\nif (!al.map->dso->hit) {\r\nal.map->dso->hit = 1;\r\nif (map__load(al.map) >= 0) {\r\ndso__inject_build_id(al.map->dso, tool, machine);\r\n} else {\r\n#ifdef HAVE_LIBELF_SUPPORT\r\npr_warning("no symbols found in %s, maybe "\r\n"install a debug package?\n",\r\nal.map->dso->long_name);\r\n#endif\r\n}\r\n}\r\n}\r\nthread__put(thread);\r\nrepipe:\r\nperf_event__repipe(tool, event, sample, machine);\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_process_exit(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nstruct event_entry *ent;\r\nlist_for_each_entry(ent, &inject->samples, node) {\r\nif (sample->tid == ent->tid) {\r\nlist_del_init(&ent->node);\r\nfree(ent);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_switch(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nstruct event_entry *ent;\r\nperf_inject__sched_process_exit(tool, event, sample, evsel, machine);\r\nent = malloc(event->header.size + sizeof(struct event_entry));\r\nif (ent == NULL) {\r\ncolor_fprintf(stderr, PERF_COLOR_RED,\r\n"Not enough memory to process sched switch event!");\r\nreturn -1;\r\n}\r\nent->tid = sample->tid;\r\nmemcpy(&ent->event, event, event->header.size);\r\nlist_add(&ent->node, &inject->samples);\r\nreturn 0;\r\n}\r\nstatic int perf_inject__sched_stat(struct perf_tool *tool,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct event_entry *ent;\r\nunion perf_event *event_sw;\r\nstruct perf_sample sample_sw;\r\nstruct perf_inject *inject = container_of(tool, struct perf_inject, tool);\r\nu32 pid = perf_evsel__intval(evsel, sample, "pid");\r\nlist_for_each_entry(ent, &inject->samples, node) {\r\nif (pid == ent->tid)\r\ngoto found;\r\n}\r\nreturn 0;\r\nfound:\r\nevent_sw = &ent->event[0];\r\nperf_evsel__parse_sample(evsel, event_sw, &sample_sw);\r\nsample_sw.period = sample->period;\r\nsample_sw.time = sample->time;\r\nperf_event__synthesize_sample(event_sw, evsel->attr.sample_type,\r\nevsel->attr.read_format, &sample_sw,\r\nfalse);\r\nbuild_id__mark_dso_hit(tool, event_sw, &sample_sw, evsel, machine);\r\nreturn perf_event__repipe(tool, event_sw, &sample_sw, machine);\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\nsession_done = 1;\r\n}\r\nstatic int perf_evsel__check_stype(struct perf_evsel *evsel,\r\nu64 sample_type, const char *sample_msg)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nconst char *name = perf_evsel__name(evsel);\r\nif (!(attr->sample_type & sample_type)) {\r\npr_err("Samples for %s event do not have %s attribute set.",\r\nname, sample_msg);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drop_sample(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event __maybe_unused,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic void strip_init(struct perf_inject *inject)\r\n{\r\nstruct perf_evlist *evlist = inject->session->evlist;\r\nstruct perf_evsel *evsel;\r\ninject->tool.context_switch = perf_event__drop;\r\nevlist__for_each_entry(evlist, evsel)\r\nevsel->handler = drop_sample;\r\n}\r\nstatic bool has_tracking(struct perf_evsel *evsel)\r\n{\r\nreturn evsel->attr.mmap || evsel->attr.mmap2 || evsel->attr.comm ||\r\nevsel->attr.task;\r\n}\r\nstatic bool ok_to_remove(struct perf_evlist *evlist,\r\nstruct perf_evsel *evsel_to_remove)\r\n{\r\nstruct perf_evsel *evsel;\r\nint cnt = 0;\r\nbool ok = false;\r\nif (!has_tracking(evsel_to_remove))\r\nreturn true;\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (evsel->handler != drop_sample) {\r\ncnt += 1;\r\nif ((evsel->attr.sample_type & COMPAT_MASK) ==\r\n(evsel_to_remove->attr.sample_type & COMPAT_MASK))\r\nok = true;\r\n}\r\n}\r\nreturn ok && cnt == 1;\r\n}\r\nstatic void strip_fini(struct perf_inject *inject)\r\n{\r\nstruct perf_evlist *evlist = inject->session->evlist;\r\nstruct perf_evsel *evsel, *tmp;\r\nevlist__for_each_entry_safe(evlist, tmp, evsel) {\r\nif (evsel->handler == drop_sample &&\r\nok_to_remove(evlist, evsel)) {\r\npr_debug("Deleting %s\n", perf_evsel__name(evsel));\r\nperf_evlist__remove(evlist, evsel);\r\nperf_evsel__delete(evsel);\r\n}\r\n}\r\n}\r\nstatic int __cmd_inject(struct perf_inject *inject)\r\n{\r\nint ret = -EINVAL;\r\nstruct perf_session *session = inject->session;\r\nstruct perf_data_file *file_out = &inject->output;\r\nint fd = perf_data_file__fd(file_out);\r\nu64 output_data_offset;\r\nsignal(SIGINT, sig_handler);\r\nif (inject->build_ids || inject->sched_stat ||\r\ninject->itrace_synth_opts.set) {\r\ninject->tool.mmap = perf_event__repipe_mmap;\r\ninject->tool.mmap2 = perf_event__repipe_mmap2;\r\ninject->tool.fork = perf_event__repipe_fork;\r\ninject->tool.tracing_data = perf_event__repipe_tracing_data;\r\n}\r\noutput_data_offset = session->header.data_offset;\r\nif (inject->build_ids) {\r\ninject->tool.sample = perf_event__inject_buildid;\r\n} else if (inject->sched_stat) {\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(session->evlist, evsel) {\r\nconst char *name = perf_evsel__name(evsel);\r\nif (!strcmp(name, "sched:sched_switch")) {\r\nif (perf_evsel__check_stype(evsel, PERF_SAMPLE_TID, "TID"))\r\nreturn -EINVAL;\r\nevsel->handler = perf_inject__sched_switch;\r\n} else if (!strcmp(name, "sched:sched_process_exit"))\r\nevsel->handler = perf_inject__sched_process_exit;\r\nelse if (!strncmp(name, "sched:sched_stat_", 17))\r\nevsel->handler = perf_inject__sched_stat;\r\n}\r\n} else if (inject->itrace_synth_opts.set) {\r\nsession->itrace_synth_opts = &inject->itrace_synth_opts;\r\ninject->itrace_synth_opts.inject = true;\r\ninject->tool.comm = perf_event__repipe_comm;\r\ninject->tool.exit = perf_event__repipe_exit;\r\ninject->tool.id_index = perf_event__repipe_id_index;\r\ninject->tool.auxtrace_info = perf_event__process_auxtrace_info;\r\ninject->tool.auxtrace = perf_event__process_auxtrace;\r\ninject->tool.aux = perf_event__drop_aux;\r\ninject->tool.itrace_start = perf_event__drop_aux,\r\ninject->tool.ordered_events = true;\r\ninject->tool.ordering_requires_timestamps = true;\r\noutput_data_offset = 4096;\r\nif (inject->strip)\r\nstrip_init(inject);\r\n}\r\nif (!inject->itrace_synth_opts.set)\r\nauxtrace_index__free(&session->auxtrace_index);\r\nif (!file_out->is_pipe)\r\nlseek(fd, output_data_offset, SEEK_SET);\r\nret = perf_session__process_events(session);\r\nif (!file_out->is_pipe) {\r\nif (inject->build_ids)\r\nperf_header__set_feat(&session->header,\r\nHEADER_BUILD_ID);\r\nif (perf_header__has_feat(&session->header, HEADER_BUILD_ID) &&\r\ninject->have_auxtrace && !inject->itrace_synth_opts.set)\r\ndsos__hit_all(session);\r\nif (inject->itrace_synth_opts.set) {\r\nstruct perf_evsel *evsel;\r\nperf_header__clear_feat(&session->header,\r\nHEADER_AUXTRACE);\r\nif (inject->itrace_synth_opts.last_branch)\r\nperf_header__set_feat(&session->header,\r\nHEADER_BRANCH_STACK);\r\nevsel = perf_evlist__id2evsel_strict(session->evlist,\r\ninject->aux_id);\r\nif (evsel) {\r\npr_debug("Deleting %s\n",\r\nperf_evsel__name(evsel));\r\nperf_evlist__remove(session->evlist, evsel);\r\nperf_evsel__delete(evsel);\r\n}\r\nif (inject->strip)\r\nstrip_fini(inject);\r\n}\r\nsession->header.data_offset = output_data_offset;\r\nsession->header.data_size = inject->bytes_written;\r\nperf_session__write_header(session, session->evlist, fd, true);\r\n}\r\nreturn ret;\r\n}\r\nint cmd_inject(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct perf_inject inject = {\r\n.tool = {\r\n.sample = perf_event__repipe_sample,\r\n.mmap = perf_event__repipe,\r\n.mmap2 = perf_event__repipe,\r\n.comm = perf_event__repipe,\r\n.fork = perf_event__repipe,\r\n.exit = perf_event__repipe,\r\n.lost = perf_event__repipe,\r\n.lost_samples = perf_event__repipe,\r\n.aux = perf_event__repipe,\r\n.itrace_start = perf_event__repipe,\r\n.context_switch = perf_event__repipe,\r\n.read = perf_event__repipe_sample,\r\n.throttle = perf_event__repipe,\r\n.unthrottle = perf_event__repipe,\r\n.attr = perf_event__repipe_attr,\r\n.tracing_data = perf_event__repipe_op2_synth,\r\n.auxtrace_info = perf_event__repipe_op2_synth,\r\n.auxtrace = perf_event__repipe_auxtrace,\r\n.auxtrace_error = perf_event__repipe_op2_synth,\r\n.time_conv = perf_event__repipe_op2_synth,\r\n.finished_round = perf_event__repipe_oe_synth,\r\n.build_id = perf_event__repipe_op2_synth,\r\n.id_index = perf_event__repipe_op2_synth,\r\n},\r\n.input_name = "-",\r\n.samples = LIST_HEAD_INIT(inject.samples),\r\n.output = {\r\n.path = "-",\r\n.mode = PERF_DATA_MODE_WRITE,\r\n},\r\n};\r\nstruct perf_data_file file = {\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nint ret;\r\nstruct option options[] = {\r\nOPT_BOOLEAN('b', "build-ids", &inject.build_ids,\r\n"Inject build-ids into the output stream"),\r\nOPT_STRING('i', "input", &inject.input_name, "file",\r\n"input file name"),\r\nOPT_STRING('o', "output", &inject.output.path, "file",\r\n"output file name"),\r\nOPT_BOOLEAN('s', "sched-stat", &inject.sched_stat,\r\n"Merge sched-stat and sched-switch for getting events "\r\n"where and how long tasks slept"),\r\n#ifdef HAVE_JITDUMP\r\nOPT_BOOLEAN('j', "jit", &inject.jit_mode, "merge jitdump files into perf.data file"),\r\n#endif\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show build ids, etc)"),\r\nOPT_STRING(0, "kallsyms", &symbol_conf.kallsyms_name, "file",\r\n"kallsyms pathname"),\r\nOPT_BOOLEAN('f', "force", &file.force, "don't complain, do it"),\r\nOPT_CALLBACK_OPTARG(0, "itrace", &inject.itrace_synth_opts,\r\nNULL, "opts", "Instruction Tracing options",\r\nitrace_parse_synth_opts),\r\nOPT_BOOLEAN(0, "strip", &inject.strip,\r\n"strip non-synthesized events (use with --itrace)"),\r\nOPT_END()\r\n};\r\nconst char * const inject_usage[] = {\r\n"perf inject [<options>]",\r\nNULL\r\n};\r\n#ifndef HAVE_JITDUMP\r\nset_option_nobuild(options, 'j', "jit", "NO_LIBELF=1", true);\r\n#endif\r\nargc = parse_options(argc, argv, options, inject_usage, 0);\r\nif (argc)\r\nusage_with_options(inject_usage, options);\r\nif (inject.strip && !inject.itrace_synth_opts.set) {\r\npr_err("--strip option requires --itrace option\n");\r\nreturn -1;\r\n}\r\nif (perf_data_file__open(&inject.output)) {\r\nperror("failed to create output file");\r\nreturn -1;\r\n}\r\ninject.tool.ordered_events = inject.sched_stat;\r\nfile.path = inject.input_name;\r\ninject.session = perf_session__new(&file, true, &inject.tool);\r\nif (inject.session == NULL)\r\nreturn -1;\r\nif (inject.build_ids) {\r\ninject.tool.ordered_events = true;\r\ninject.tool.ordering_requires_timestamps = true;\r\n}\r\n#ifdef HAVE_JITDUMP\r\nif (inject.jit_mode) {\r\ninject.tool.mmap2 = perf_event__jit_repipe_mmap2;\r\ninject.tool.mmap = perf_event__jit_repipe_mmap;\r\ninject.tool.ordered_events = true;\r\ninject.tool.ordering_requires_timestamps = true;\r\ninject.tool.finished_round = perf_event__drop_oe;\r\n}\r\n#endif\r\nret = symbol__init(&inject.session->header.env);\r\nif (ret < 0)\r\ngoto out_delete;\r\nret = __cmd_inject(&inject);\r\nout_delete:\r\nperf_session__delete(inject.session);\r\nreturn ret;\r\n}
