static void mpc512x_clk_determine_soc(void)\r\n{\r\nif (of_machine_is_compatible("fsl,mpc5121")) {\r\nsoc = MPC512x_SOC_MPC5121;\r\nreturn;\r\n}\r\nif (of_machine_is_compatible("fsl,mpc5123")) {\r\nsoc = MPC512x_SOC_MPC5123;\r\nreturn;\r\n}\r\nif (of_machine_is_compatible("fsl,mpc5125")) {\r\nsoc = MPC512x_SOC_MPC5125;\r\nreturn;\r\n}\r\n}\r\nstatic bool soc_has_mbx(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5121)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool soc_has_axe(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_viu(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_spdif(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_pata(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_sata(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_pci(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool soc_has_fec2(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int soc_max_pscnum(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn 10;\r\nreturn 12;\r\n}\r\nstatic bool soc_has_sdhc2(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool soc_has_nfc_5125(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool soc_has_outclk(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool soc_has_cpmf_0_bypass(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool soc_has_mclk_mux0_canin(void)\r\n{\r\nif (soc == MPC512x_SOC_MPC5125)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline struct clk *mpc512x_clk_fixed(const char *name, int rate)\r\n{\r\nreturn clk_register_fixed_rate(NULL, name, NULL, 0, rate);\r\n}\r\nstatic inline struct clk *mpc512x_clk_factor(\r\nconst char *name, const char *parent_name,\r\nint mul, int div)\r\n{\r\nint clkflags;\r\nclkflags = CLK_SET_RATE_PARENT;\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, clkflags,\r\nmul, div);\r\n}\r\nstatic inline struct clk *mpc512x_clk_divider(\r\nconst char *name, const char *parent_name, u8 clkflags,\r\nu32 __iomem *reg, u8 pos, u8 len, int divflags)\r\n{\r\nreturn clk_register_divider(NULL, name, parent_name, clkflags,\r\nreg, pos, len, divflags, &clklock);\r\n}\r\nstatic inline struct clk *mpc512x_clk_divtable(\r\nconst char *name, const char *parent_name,\r\nu32 __iomem *reg, u8 pos, u8 len,\r\nconst struct clk_div_table *divtab)\r\n{\r\nu8 divflags;\r\ndivflags = 0;\r\nreturn clk_register_divider_table(NULL, name, parent_name, 0,\r\nreg, pos, len, divflags,\r\ndivtab, &clklock);\r\n}\r\nstatic inline struct clk *mpc512x_clk_gated(\r\nconst char *name, const char *parent_name,\r\nu32 __iomem *reg, u8 pos)\r\n{\r\nint clkflags;\r\nclkflags = CLK_SET_RATE_PARENT;\r\nreturn clk_register_gate(NULL, name, parent_name, clkflags,\r\nreg, pos, 0, &clklock);\r\n}\r\nstatic inline struct clk *mpc512x_clk_muxed(const char *name,\r\nconst char **parent_names, int parent_count,\r\nu32 __iomem *reg, u8 pos, u8 len)\r\n{\r\nint clkflags;\r\nu8 muxflags;\r\nclkflags = CLK_SET_RATE_PARENT;\r\nmuxflags = 0;\r\nreturn clk_register_mux(NULL, name,\r\nparent_names, parent_count, clkflags,\r\nreg, pos, len, muxflags, &clklock);\r\n}\r\nstatic inline int get_bit_field(uint32_t __iomem *reg, uint8_t pos, uint8_t len)\r\n{\r\nuint32_t val;\r\nval = in_be32(reg);\r\nval >>= pos;\r\nval &= (1 << len) - 1;\r\nreturn val;\r\n}\r\nstatic int get_spmf_mult(void)\r\n{\r\nstatic int spmf_to_mult[] = {\r\n68, 1, 12, 16, 20, 24, 28, 32,\r\n36, 40, 44, 48, 52, 56, 60, 64,\r\n};\r\nint spmf;\r\nspmf = get_bit_field(&clkregs->spmr, 24, 4);\r\nreturn spmf_to_mult[spmf];\r\n}\r\nstatic int get_sys_div_x2(void)\r\n{\r\nstatic int sysdiv_code_to_x2[] = {\r\n4, 5, 6, 7, 8, 9, 10, 14,\r\n12, 16, 18, 22, 20, 24, 26, 30,\r\n28, 32, 34, 38, 36, 40, 42, 46,\r\n44, 48, 50, 54, 52, 56, 58, 62,\r\n60, 64, 66,\r\n};\r\nint divcode;\r\ndivcode = get_bit_field(&clkregs->scfr2, 26, 6);\r\nreturn sysdiv_code_to_x2[divcode];\r\n}\r\nstatic int get_cpmf_mult_x2(void)\r\n{\r\nstatic int cpmf_to_mult_x36[] = {\r\n72, 2, 2, 3, 4, 5, 6, 7,\r\n};\r\nstatic int cpmf_to_mult_0by[] = {\r\n2, 2, 2, 3, 4, 5, 6, 7,\r\n};\r\nint *cpmf_to_mult;\r\nint cpmf;\r\ncpmf = get_bit_field(&clkregs->spmr, 16, 4);\r\nif (soc_has_cpmf_0_bypass())\r\ncpmf_to_mult = cpmf_to_mult_0by;\r\nelse\r\ncpmf_to_mult = cpmf_to_mult_x36;\r\nreturn cpmf_to_mult[cpmf];\r\n}\r\nstatic int get_freq_from_dt(char *propname)\r\n{\r\nstruct device_node *np;\r\nconst unsigned int *prop;\r\nint val;\r\nval = 0;\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-immr");\r\nif (np) {\r\nprop = of_get_property(np, propname, NULL);\r\nif (prop)\r\nval = *prop;\r\nof_node_put(np);\r\n}\r\nreturn val;\r\n}\r\nstatic void mpc512x_clk_preset_data(void)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < ARRAY_SIZE(clks); i++)\r\nclks[i] = ERR_PTR(-ENODEV);\r\n}\r\nstatic void mpc512x_clk_setup_ref_clock(struct device_node *np, int bus_freq,\r\nint *sys_mul, int *sys_div,\r\nint *ips_div)\r\n{\r\nstruct clk *osc_clk;\r\nint calc_freq;\r\n*sys_mul = get_spmf_mult();\r\n*sys_mul *= 2;\r\n*sys_div = get_sys_div_x2();\r\n*ips_div = get_bit_field(&clkregs->scfr1, 23, 3);\r\nosc_clk = of_clk_get_by_name(np, "osc");\r\nif (!IS_ERR(osc_clk)) {\r\nclks[MPC512x_CLK_REF] = mpc512x_clk_factor("ref", "osc", 1, 1);\r\ncalc_freq = clk_get_rate(clks[MPC512x_CLK_REF]);\r\ncalc_freq *= *sys_mul;\r\ncalc_freq /= *sys_div;\r\ncalc_freq /= 2;\r\ncalc_freq /= *ips_div;\r\nif (bus_freq && calc_freq != bus_freq)\r\npr_warn("calc rate %d != OF spec %d\n",\r\ncalc_freq, bus_freq);\r\n} else {\r\ncalc_freq = bus_freq;\r\ncalc_freq *= *ips_div;\r\ncalc_freq *= 2;\r\ncalc_freq *= *sys_div;\r\ncalc_freq /= *sys_mul;\r\nclks[MPC512x_CLK_REF] = mpc512x_clk_fixed("ref", calc_freq);\r\n}\r\n}\r\nstatic void mpc512x_clk_setup_mclk(struct mclk_setup_data *entry, size_t idx)\r\n{\r\nsize_t clks_idx_pub, clks_idx_int;\r\nu32 __iomem *mccr_reg;\r\nint div;\r\nswitch (entry->type) {\r\ncase MCLK_TYPE_PSC:\r\nclks_idx_pub = MPC512x_CLK_PSC0_MCLK + idx;\r\nclks_idx_int = MPC512x_CLK_MCLKS_FIRST\r\n+ (idx) * MCLK_MAX_IDX;\r\nmccr_reg = &clkregs->psc_ccr[idx];\r\nbreak;\r\ncase MCLK_TYPE_MSCAN:\r\nclks_idx_pub = MPC512x_CLK_MSCAN0_MCLK + idx;\r\nclks_idx_int = MPC512x_CLK_MCLKS_FIRST\r\n+ (NR_PSCS + idx) * MCLK_MAX_IDX;\r\nmccr_reg = &clkregs->mscan_ccr[idx];\r\nbreak;\r\ncase MCLK_TYPE_SPDIF:\r\nclks_idx_pub = MPC512x_CLK_SPDIF_MCLK;\r\nclks_idx_int = MPC512x_CLK_MCLKS_FIRST\r\n+ (NR_PSCS + NR_MSCANS) * MCLK_MAX_IDX;\r\nmccr_reg = &clkregs->spccr;\r\nbreak;\r\ncase MCLK_TYPE_OUTCLK:\r\nclks_idx_pub = MPC512x_CLK_OUT0_CLK + idx;\r\nclks_idx_int = MPC512x_CLK_MCLKS_FIRST\r\n+ (NR_PSCS + NR_MSCANS + NR_SPDIFS + idx)\r\n* MCLK_MAX_IDX;\r\nmccr_reg = &clkregs->out_ccr[idx];\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ndiv = clk_get_rate(clks[MPC512x_CLK_SYS]);\r\ndiv /= clk_get_rate(clks[MPC512x_CLK_IPS]);\r\nout_be32(mccr_reg, (0 << 16));\r\nout_be32(mccr_reg, (0 << 16) | ((div - 1) << 17));\r\nout_be32(mccr_reg, (1 << 16) | ((div - 1) << 17));\r\nclks[clks_idx_int + MCLK_IDX_MUX0] = mpc512x_clk_muxed(\r\nentry->name_mux0,\r\nsoc_has_mclk_mux0_canin()\r\n? &parent_names_mux0_canin[0]\r\n: &parent_names_mux0_spdif[0],\r\nARRAY_SIZE(parent_names_mux0_spdif),\r\nmccr_reg, 14, 2);\r\nclks[clks_idx_int + MCLK_IDX_EN0] = mpc512x_clk_gated(\r\nentry->name_en0, entry->name_mux0,\r\nmccr_reg, 16);\r\nclks[clks_idx_int + MCLK_IDX_DIV0] = mpc512x_clk_divider(\r\nentry->name_div0,\r\nentry->name_en0, CLK_SET_RATE_GATE,\r\nmccr_reg, 17, 15, 0);\r\nif (entry->has_mclk1) {\r\nclks[clks_idx_pub] = mpc512x_clk_muxed(\r\nentry->name_mclk,\r\n&entry->parent_names_mux1[0],\r\nARRAY_SIZE(entry->parent_names_mux1),\r\nmccr_reg, 7, 1);\r\n} else {\r\nclks[clks_idx_pub] = mpc512x_clk_factor(\r\nentry->name_mclk,\r\nentry->parent_names_mux1[0],\r\n1, 1);\r\n}\r\n}\r\nstatic void mpc512x_clk_setup_clock_tree(struct device_node *np, int busfreq)\r\n{\r\nint sys_mul, sys_div, ips_div;\r\nint mul, div;\r\nsize_t mclk_idx;\r\nint freq;\r\nmpc512x_clk_setup_ref_clock(np, busfreq, &sys_mul, &sys_div, &ips_div);\r\nclks[MPC512x_CLK_SYS] = mpc512x_clk_factor("sys", "ref",\r\nsys_mul, sys_div);\r\nclks[MPC512x_CLK_CSB] = mpc512x_clk_factor("csb", "sys", 1, 2);\r\nclks[MPC512x_CLK_IPS] = mpc512x_clk_divtable("ips", "csb",\r\n&clkregs->scfr1, 23, 3,\r\ndivtab_2346);\r\nclks[MPC512x_CLK_DDR_UG] = mpc512x_clk_factor("ddr-ug", "sys", 1, 2);\r\nclks[MPC512x_CLK_SDHC_x4] = mpc512x_clk_factor("sdhc-x4", "csb", 2, 1);\r\nclks[MPC512x_CLK_SDHC_UG] = mpc512x_clk_divider("sdhc-ug", "sdhc-x4", 0,\r\n&clkregs->scfr2, 1, 7,\r\nCLK_DIVIDER_ONE_BASED);\r\nif (soc_has_sdhc2()) {\r\nclks[MPC512x_CLK_SDHC2_UG] = mpc512x_clk_divider(\r\n"sdhc2-ug", "sdhc-x4", 0, &clkregs->scfr2,\r\n9, 7, CLK_DIVIDER_ONE_BASED);\r\n}\r\nclks[MPC512x_CLK_DIU_x4] = mpc512x_clk_factor("diu-x4", "csb", 4, 1);\r\nclks[MPC512x_CLK_DIU_UG] = mpc512x_clk_divider("diu-ug", "diu-x4", 0,\r\n&clkregs->scfr1, 0, 8,\r\nCLK_DIVIDER_ONE_BASED);\r\nmul = get_cpmf_mult_x2();\r\ndiv = 2;\r\nclks[MPC512x_CLK_E300] = mpc512x_clk_factor("e300", "csb", mul, div);\r\nif (soc_has_mbx()) {\r\nclks[MPC512x_CLK_MBX_BUS_UG] = mpc512x_clk_factor(\r\n"mbx-bus-ug", "csb", 1, 2);\r\nclks[MPC512x_CLK_MBX_UG] = mpc512x_clk_divtable(\r\n"mbx-ug", "mbx-bus-ug", &clkregs->scfr1,\r\n14, 3, divtab_1234);\r\nclks[MPC512x_CLK_MBX_3D_UG] = mpc512x_clk_factor(\r\n"mbx-3d-ug", "mbx-ug", 1, 1);\r\n}\r\nif (soc_has_pci()) {\r\nclks[MPC512x_CLK_PCI_UG] = mpc512x_clk_divtable(\r\n"pci-ug", "csb", &clkregs->scfr1,\r\n20, 3, divtab_2346);\r\n}\r\nif (soc_has_nfc_5125()) {\r\nclks[MPC512x_CLK_NFC_UG] = ERR_PTR(-ENOTSUPP);\r\n} else {\r\nclks[MPC512x_CLK_NFC_UG] = mpc512x_clk_divtable(\r\n"nfc-ug", "ips", &clkregs->scfr1,\r\n8, 3, divtab_1234);\r\n}\r\nclks[MPC512x_CLK_LPC_UG] = mpc512x_clk_divtable("lpc-ug", "ips",\r\n&clkregs->scfr1, 11, 3,\r\ndivtab_1234);\r\nclks[MPC512x_CLK_LPC] = mpc512x_clk_gated("lpc", "lpc-ug",\r\n&clkregs->sccr1, 30);\r\nclks[MPC512x_CLK_NFC] = mpc512x_clk_gated("nfc", "nfc-ug",\r\n&clkregs->sccr1, 29);\r\nif (soc_has_pata()) {\r\nclks[MPC512x_CLK_PATA] = mpc512x_clk_gated(\r\n"pata", "ips", &clkregs->sccr1, 28);\r\n}\r\nfor (mclk_idx = 0; mclk_idx < soc_max_pscnum(); mclk_idx++) {\r\nchar name[12];\r\nsnprintf(name, sizeof(name), "psc%d", mclk_idx);\r\nclks[MPC512x_CLK_PSC0 + mclk_idx] = mpc512x_clk_gated(\r\nname, "ips", &clkregs->sccr1, 27 - mclk_idx);\r\nmpc512x_clk_setup_mclk(&mclk_psc_data[mclk_idx], mclk_idx);\r\n}\r\nclks[MPC512x_CLK_PSC_FIFO] = mpc512x_clk_gated("psc-fifo", "ips",\r\n&clkregs->sccr1, 15);\r\nif (soc_has_sata()) {\r\nclks[MPC512x_CLK_SATA] = mpc512x_clk_gated(\r\n"sata", "ips", &clkregs->sccr1, 14);\r\n}\r\nclks[MPC512x_CLK_FEC] = mpc512x_clk_gated("fec", "ips",\r\n&clkregs->sccr1, 13);\r\nif (soc_has_pci()) {\r\nclks[MPC512x_CLK_PCI] = mpc512x_clk_gated(\r\n"pci", "pci-ug", &clkregs->sccr1, 11);\r\n}\r\nclks[MPC512x_CLK_DDR] = mpc512x_clk_gated("ddr", "ddr-ug",\r\n&clkregs->sccr1, 10);\r\nif (soc_has_fec2()) {\r\nclks[MPC512x_CLK_FEC2] = mpc512x_clk_gated(\r\n"fec2", "ips", &clkregs->sccr1, 9);\r\n}\r\nclks[MPC512x_CLK_DIU] = mpc512x_clk_gated("diu", "diu-ug",\r\n&clkregs->sccr2, 31);\r\nif (soc_has_axe()) {\r\nclks[MPC512x_CLK_AXE] = mpc512x_clk_gated(\r\n"axe", "csb", &clkregs->sccr2, 30);\r\n}\r\nclks[MPC512x_CLK_MEM] = mpc512x_clk_gated("mem", "ips",\r\n&clkregs->sccr2, 29);\r\nclks[MPC512x_CLK_USB1] = mpc512x_clk_gated("usb1", "csb",\r\n&clkregs->sccr2, 28);\r\nclks[MPC512x_CLK_USB2] = mpc512x_clk_gated("usb2", "csb",\r\n&clkregs->sccr2, 27);\r\nclks[MPC512x_CLK_I2C] = mpc512x_clk_gated("i2c", "ips",\r\n&clkregs->sccr2, 26);\r\nclks[MPC512x_CLK_BDLC] = mpc512x_clk_gated("bdlc", "ips",\r\n&clkregs->sccr2, 25);\r\nfor (mclk_idx = 0; mclk_idx < ARRAY_SIZE(mclk_mscan_data); mclk_idx++)\r\nmpc512x_clk_setup_mclk(&mclk_mscan_data[mclk_idx], mclk_idx);\r\nclks[MPC512x_CLK_SDHC] = mpc512x_clk_gated("sdhc", "sdhc-ug",\r\n&clkregs->sccr2, 24);\r\nif (soc_has_spdif()) {\r\nclks[MPC512x_CLK_SPDIF] = mpc512x_clk_gated(\r\n"spdif", "ips", &clkregs->sccr2, 23);\r\nmpc512x_clk_setup_mclk(&mclk_spdif_data[0], 0);\r\n}\r\nif (soc_has_mbx()) {\r\nclks[MPC512x_CLK_MBX_BUS] = mpc512x_clk_gated(\r\n"mbx-bus", "mbx-bus-ug", &clkregs->sccr2, 22);\r\nclks[MPC512x_CLK_MBX] = mpc512x_clk_gated(\r\n"mbx", "mbx-ug", &clkregs->sccr2, 21);\r\nclks[MPC512x_CLK_MBX_3D] = mpc512x_clk_gated(\r\n"mbx-3d", "mbx-3d-ug", &clkregs->sccr2, 20);\r\n}\r\nclks[MPC512x_CLK_IIM] = mpc512x_clk_gated("iim", "csb",\r\n&clkregs->sccr2, 19);\r\nif (soc_has_viu()) {\r\nclks[MPC512x_CLK_VIU] = mpc512x_clk_gated(\r\n"viu", "csb", &clkregs->sccr2, 18);\r\n}\r\nif (soc_has_sdhc2()) {\r\nclks[MPC512x_CLK_SDHC2] = mpc512x_clk_gated(\r\n"sdhc-2", "sdhc2-ug", &clkregs->sccr2, 17);\r\n}\r\nif (soc_has_outclk()) {\r\nsize_t idx;\r\nfor (idx = 0; idx < ARRAY_SIZE(mclk_outclk_data); idx++)\r\nmpc512x_clk_setup_mclk(&mclk_outclk_data[idx], idx);\r\n}\r\nfreq = get_freq_from_dt("psc_mclk_in");\r\nif (!freq)\r\nfreq = 25000000;\r\nclks[MPC512x_CLK_PSC_MCLK_IN] = mpc512x_clk_fixed("psc_mclk_in", freq);\r\nif (soc_has_mclk_mux0_canin()) {\r\nfreq = get_freq_from_dt("can_clk_in");\r\nclks[MPC512x_CLK_CAN_CLK_IN] = mpc512x_clk_fixed(\r\n"can_clk_in", freq);\r\n} else {\r\nfreq = get_freq_from_dt("spdif_tx_in");\r\nclks[MPC512x_CLK_SPDIF_TX_IN] = mpc512x_clk_fixed(\r\n"spdif_tx_in", freq);\r\nfreq = get_freq_from_dt("spdif_rx_in");\r\nclks[MPC512x_CLK_SPDIF_TX_IN] = mpc512x_clk_fixed(\r\n"spdif_rx_in", freq);\r\n}\r\nclks[MPC512x_CLK_AC97] = mpc512x_clk_fixed("ac97", 24567000);\r\nclk_prepare_enable(clks[MPC512x_CLK_DUMMY]);\r\nclk_prepare_enable(clks[MPC512x_CLK_E300]);\r\nclk_prepare_enable(clks[MPC512x_CLK_DDR]);\r\nclk_prepare_enable(clks[MPC512x_CLK_MEM]);\r\nclk_prepare_enable(clks[MPC512x_CLK_IPS]);\r\nclk_prepare_enable(clks[MPC512x_CLK_LPC]);\r\n}\r\nstatic void mpc5121_clk_register_of_provider(struct device_node *np)\r\n{\r\nclk_data.clks = clks;\r\nclk_data.clk_num = MPC512x_CLK_LAST_PUBLIC + 1;\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\n}\r\nstatic void mpc5121_clk_provide_migration_support(void)\r\n{\r\nclk_prepare_enable(clks[MPC512x_CLK_PSC3_MCLK]);\r\nif (of_find_compatible_node(NULL, "pci", "fsl,mpc5121-pci"))\r\nclk_prepare_enable(clks[MPC512x_CLK_PCI]);\r\n}\r\nstatic void mpc5121_clk_provide_backwards_compat(void)\r\n{\r\nenum did_reg_flags {\r\nDID_REG_PSC = BIT(0),\r\nDID_REG_PSCFIFO = BIT(1),\r\nDID_REG_NFC = BIT(2),\r\nDID_REG_CAN = BIT(3),\r\nDID_REG_I2C = BIT(4),\r\nDID_REG_DIU = BIT(5),\r\nDID_REG_VIU = BIT(6),\r\nDID_REG_FEC = BIT(7),\r\nDID_REG_USB = BIT(8),\r\nDID_REG_PATA = BIT(9),\r\n};\r\nint did_register;\r\nstruct device_node *np;\r\nstruct resource res;\r\nint idx;\r\nchar devname[32];\r\ndid_register = 0;\r\nFOR_NODES(mpc512x_select_psc_compat()) {\r\nNODE_PREP;\r\nidx = (res.start >> 8) & 0xf;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_PSC0 + idx], 0, PSC);\r\nNODE_CHK("mclk", clks[MPC512x_CLK_PSC0_MCLK + idx], 0, PSC);\r\n}\r\nFOR_NODES("fsl,mpc5121-psc-fifo") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_PSC_FIFO], 1, PSCFIFO);\r\n}\r\nFOR_NODES("fsl,mpc5121-nfc") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_NFC], 0, NFC);\r\n}\r\nFOR_NODES("fsl,mpc5121-mscan") {\r\nNODE_PREP;\r\nidx = 0;\r\nidx += (res.start & 0x2000) ? 2 : 0;\r\nidx += (res.start & 0x0080) ? 1 : 0;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_BDLC], 0, CAN);\r\nNODE_CHK("mclk", clks[MPC512x_CLK_MSCAN0_MCLK + idx], 0, CAN);\r\n}\r\nif (did_register & DID_REG_CAN) {\r\nclk_register_clkdev(clks[MPC512x_CLK_IPS], "ips", NULL);\r\nclk_register_clkdev(clks[MPC512x_CLK_SYS], "sys", NULL);\r\nclk_register_clkdev(clks[MPC512x_CLK_REF], "ref", NULL);\r\n}\r\nFOR_NODES("fsl,mpc5121-i2c") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_I2C], 0, I2C);\r\n}\r\nif (did_register & DID_REG_I2C)\r\nclk_prepare_enable(clks[MPC512x_CLK_I2C]);\r\nFOR_NODES("fsl,mpc5121-diu") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_DIU], 1, DIU);\r\n}\r\nFOR_NODES("fsl,mpc5121-viu") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_VIU], 0, VIU);\r\n}\r\nFOR_NODES("fsl,mpc5121-fec") {\r\nNODE_PREP;\r\nNODE_CHK("per", clks[MPC512x_CLK_FEC], 0, FEC);\r\n}\r\nFOR_NODES("fsl,mpc5121-fec-mdio") {\r\nNODE_PREP;\r\nNODE_CHK("per", clks[MPC512x_CLK_FEC], 0, FEC);\r\n}\r\nFOR_NODES("fsl,mpc5125-fec") {\r\nNODE_PREP;\r\nif (res.start & 0x4000)\r\nidx = MPC512x_CLK_FEC2;\r\nelse\r\nidx = MPC512x_CLK_FEC;\r\nNODE_CHK("per", clks[idx], 0, FEC);\r\n}\r\nFOR_NODES("fsl,mpc5121-usb2-dr") {\r\nNODE_PREP;\r\nidx = (res.start & 0x4000) ? 1 : 0;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_USB1 + idx], 0, USB);\r\n}\r\nFOR_NODES("fsl,mpc5121-pata") {\r\nNODE_PREP;\r\nNODE_CHK("ipg", clks[MPC512x_CLK_PATA], 0, PATA);\r\n}\r\nif (did_register) {\r\npr_notice("device tree lacks clock specs, adding fallbacks (0x%x,%s%s%s%s%s%s%s%s%s%s)\n",\r\ndid_register,\r\n(did_register & DID_REG_PSC) ? " PSC" : "",\r\n(did_register & DID_REG_PSCFIFO) ? " PSCFIFO" : "",\r\n(did_register & DID_REG_NFC) ? " NFC" : "",\r\n(did_register & DID_REG_CAN) ? " CAN" : "",\r\n(did_register & DID_REG_I2C) ? " I2C" : "",\r\n(did_register & DID_REG_DIU) ? " DIU" : "",\r\n(did_register & DID_REG_VIU) ? " VIU" : "",\r\n(did_register & DID_REG_FEC) ? " FEC" : "",\r\n(did_register & DID_REG_USB) ? " USB" : "",\r\n(did_register & DID_REG_PATA) ? " PATA" : "");\r\n} else {\r\npr_debug("device tree has clock specs, no fallbacks added\n");\r\n}\r\n}\r\nint __init mpc5121_clk_init(void)\r\n{\r\nstruct device_node *clk_np;\r\nint busfreq;\r\nclk_np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-clock");\r\nif (!clk_np)\r\nreturn -ENODEV;\r\nclkregs = of_iomap(clk_np, 0);\r\nWARN_ON(!clkregs);\r\nmpc512x_clk_determine_soc();\r\nmpc512x_clk_preset_data();\r\nclks[MPC512x_CLK_DUMMY] = mpc512x_clk_fixed("dummy", 0);\r\nbusfreq = get_freq_from_dt("bus-frequency");\r\nmpc512x_clk_setup_clock_tree(clk_np, busfreq);\r\nmpc5121_clk_register_of_provider(clk_np);\r\nmpc5121_clk_provide_migration_support();\r\nmpc5121_clk_provide_backwards_compat();\r\nreturn 0;\r\n}
