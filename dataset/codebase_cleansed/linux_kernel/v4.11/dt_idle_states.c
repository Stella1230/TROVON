static int init_state_node(struct cpuidle_state *idle_state,\r\nconst struct of_device_id *matches,\r\nstruct device_node *state_node)\r\n{\r\nint err;\r\nconst struct of_device_id *match_id;\r\nconst char *desc;\r\nmatch_id = of_match_node(matches, state_node);\r\nif (!match_id)\r\nreturn -ENODEV;\r\nidle_state->enter = match_id->data;\r\nidle_state->enter_freeze = match_id->data;\r\nerr = of_property_read_u32(state_node, "wakeup-latency-us",\r\n&idle_state->exit_latency);\r\nif (err) {\r\nu32 entry_latency, exit_latency;\r\nerr = of_property_read_u32(state_node, "entry-latency-us",\r\n&entry_latency);\r\nif (err) {\r\npr_debug(" * %s missing entry-latency-us property\n",\r\nstate_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nerr = of_property_read_u32(state_node, "exit-latency-us",\r\n&exit_latency);\r\nif (err) {\r\npr_debug(" * %s missing exit-latency-us property\n",\r\nstate_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nidle_state->exit_latency = entry_latency + exit_latency;\r\n}\r\nerr = of_property_read_u32(state_node, "min-residency-us",\r\n&idle_state->target_residency);\r\nif (err) {\r\npr_debug(" * %s missing min-residency-us property\n",\r\nstate_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nerr = of_property_read_string(state_node, "idle-state-name", &desc);\r\nif (err)\r\ndesc = state_node->name;\r\nidle_state->flags = 0;\r\nif (of_property_read_bool(state_node, "local-timer-stop"))\r\nidle_state->flags |= CPUIDLE_FLAG_TIMER_STOP;\r\nstrncpy(idle_state->name, state_node->name, CPUIDLE_NAME_LEN - 1);\r\nstrncpy(idle_state->desc, desc, CPUIDLE_DESC_LEN - 1);\r\nreturn 0;\r\n}\r\nstatic bool idle_state_valid(struct device_node *state_node, unsigned int idx,\r\nconst cpumask_t *cpumask)\r\n{\r\nint cpu;\r\nstruct device_node *cpu_node, *curr_state_node;\r\nbool valid = true;\r\nfor (cpu = cpumask_next(cpumask_first(cpumask), cpumask);\r\ncpu < nr_cpu_ids; cpu = cpumask_next(cpu, cpumask)) {\r\ncpu_node = of_cpu_device_node_get(cpu);\r\ncurr_state_node = of_parse_phandle(cpu_node, "cpu-idle-states",\r\nidx);\r\nif (state_node != curr_state_node)\r\nvalid = false;\r\nof_node_put(curr_state_node);\r\nof_node_put(cpu_node);\r\nif (!valid)\r\nbreak;\r\n}\r\nreturn valid;\r\n}\r\nint dt_init_idle_driver(struct cpuidle_driver *drv,\r\nconst struct of_device_id *matches,\r\nunsigned int start_idx)\r\n{\r\nstruct cpuidle_state *idle_state;\r\nstruct device_node *state_node, *cpu_node;\r\nint i, err = 0;\r\nconst cpumask_t *cpumask;\r\nunsigned int state_idx = start_idx;\r\nif (state_idx >= CPUIDLE_STATE_MAX)\r\nreturn -EINVAL;\r\ncpumask = drv->cpumask ? : cpu_possible_mask;\r\ncpu_node = of_cpu_device_node_get(cpumask_first(cpumask));\r\nfor (i = 0; ; i++) {\r\nstate_node = of_parse_phandle(cpu_node, "cpu-idle-states", i);\r\nif (!state_node)\r\nbreak;\r\nif (!of_device_is_available(state_node))\r\ncontinue;\r\nif (!idle_state_valid(state_node, i, cpumask)) {\r\npr_warn("%s idle state not valid, bailing out\n",\r\nstate_node->full_name);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (state_idx == CPUIDLE_STATE_MAX) {\r\npr_warn("State index reached static CPU idle driver states array size\n");\r\nbreak;\r\n}\r\nidle_state = &drv->states[state_idx++];\r\nerr = init_state_node(idle_state, matches, state_node);\r\nif (err) {\r\npr_err("Parsing idle state node %s failed with err %d\n",\r\nstate_node->full_name, err);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nof_node_put(state_node);\r\n}\r\nof_node_put(state_node);\r\nof_node_put(cpu_node);\r\nif (err)\r\nreturn err;\r\nif (i)\r\ndrv->state_count = state_idx;\r\nreturn i;\r\n}
