static bool cyapa_sort_pip_hid_descriptor_data(struct cyapa *cyapa,\r\nu8 *buf, int len)\r\n{\r\nif (len != PIP_HID_DESCRIPTOR_SIZE)\r\nreturn false;\r\nif (buf[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_APP_REPORT_ID ||\r\nbuf[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_BL_REPORT_ID)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int cyapa_get_pip_fixed_info(struct cyapa *cyapa,\r\nstruct pip_fixed_info *pip_info, bool is_bootloader)\r\n{\r\nu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\r\nint resp_len;\r\nu16 product_family;\r\nint error;\r\nif (is_bootloader) {\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\npip_get_bl_info, sizeof(pip_get_bl_info),\r\nresp_data, &resp_len,\r\n2000, cyapa_sort_tsg_pip_bl_resp_data,\r\nfalse);\r\nif (error || resp_len < PIP_BL_GET_INFO_RESP_LENGTH)\r\nreturn error ? error : -EIO;\r\npip_info->family_id = resp_data[8];\r\npip_info->silicon_id_low = resp_data[10];\r\npip_info->silicon_id_high = resp_data[11];\r\nreturn 0;\r\n}\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\npip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\r\nresp_data, &resp_len,\r\n2000, cyapa_pip_sort_system_info_data, false);\r\nif (error || resp_len < PIP_READ_SYS_INFO_RESP_LENGTH)\r\nreturn error ? error : -EIO;\r\nproduct_family = get_unaligned_le16(&resp_data[7]);\r\nif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\r\nPIP_PRODUCT_FAMILY_TRACKPAD)\r\nreturn -EINVAL;\r\npip_info->family_id = resp_data[19];\r\npip_info->silicon_id_low = resp_data[21];\r\npip_info->silicon_id_high = resp_data[22];\r\nreturn 0;\r\n}\r\nint cyapa_pip_state_parse(struct cyapa *cyapa, u8 *reg_data, int len)\r\n{\r\nu8 cmd[] = { 0x01, 0x00};\r\nstruct pip_fixed_info pip_info;\r\nu8 resp_data[PIP_HID_DESCRIPTOR_SIZE];\r\nint resp_len;\r\nbool is_bootloader;\r\nint error;\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\ncyapa_pip_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_ON);\r\ncyapa_empty_pip_output_data(cyapa, NULL, NULL, NULL);\r\nresp_len = PIP_HID_DESCRIPTOR_SIZE;\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\ncmd, sizeof(cmd),\r\nresp_data, &resp_len,\r\n300,\r\ncyapa_sort_pip_hid_descriptor_data,\r\nfalse);\r\nif (error)\r\nreturn error;\r\nif (resp_data[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_BL_REPORT_ID)\r\nis_bootloader = true;\r\nelse if (resp_data[PIP_RESP_REPORT_ID_OFFSET] == PIP_HID_APP_REPORT_ID)\r\nis_bootloader = false;\r\nelse\r\nreturn -EAGAIN;\r\nmemset(&pip_info, 0, sizeof(struct pip_fixed_info));\r\nerror = cyapa_get_pip_fixed_info(cyapa, &pip_info, is_bootloader);\r\nif (error)\r\nreturn error;\r\nif (pip_info.family_id == 0x9B && pip_info.silicon_id_high == 0x0B) {\r\ncyapa->gen = CYAPA_GEN6;\r\ncyapa->state = is_bootloader ? CYAPA_STATE_GEN6_BL\r\n: CYAPA_STATE_GEN6_APP;\r\n} else if (pip_info.family_id == 0x91 &&\r\npip_info.silicon_id_high == 0x02) {\r\ncyapa->gen = CYAPA_GEN5;\r\ncyapa->state = is_bootloader ? CYAPA_STATE_GEN5_BL\r\n: CYAPA_STATE_GEN5_APP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_read_sys_info(struct cyapa *cyapa)\r\n{\r\nu8 resp_data[PIP_READ_SYS_INFO_RESP_LENGTH];\r\nint resp_len;\r\nu16 product_family;\r\nu8 rotat_align;\r\nint error;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\npip_read_sys_info, PIP_READ_SYS_INFO_CMD_LENGTH,\r\nresp_data, &resp_len,\r\n2000, cyapa_pip_sort_system_info_data, false);\r\nif (error || resp_len < sizeof(resp_data))\r\nreturn error ? error : -EIO;\r\nproduct_family = get_unaligned_le16(&resp_data[7]);\r\nif ((product_family & PIP_PRODUCT_FAMILY_MASK) !=\r\nPIP_PRODUCT_FAMILY_TRACKPAD)\r\nreturn -EINVAL;\r\ncyapa->platform_ver = (resp_data[67] >> PIP_BL_PLATFORM_VER_SHIFT) &\r\nPIP_BL_PLATFORM_VER_MASK;\r\ncyapa->fw_maj_ver = resp_data[9];\r\ncyapa->fw_min_ver = resp_data[10];\r\ncyapa->electrodes_x = resp_data[33];\r\ncyapa->electrodes_y = resp_data[34];\r\ncyapa->physical_size_x = get_unaligned_le16(&resp_data[35]) / 100;\r\ncyapa->physical_size_y = get_unaligned_le16(&resp_data[37]) / 100;\r\ncyapa->max_abs_x = get_unaligned_le16(&resp_data[39]);\r\ncyapa->max_abs_y = get_unaligned_le16(&resp_data[41]);\r\ncyapa->max_z = get_unaligned_le16(&resp_data[43]);\r\ncyapa->x_origin = resp_data[45] & 0x01;\r\ncyapa->y_origin = resp_data[46] & 0x01;\r\ncyapa->btn_capability = (resp_data[70] << 3) & CAPABILITY_BTN_MASK;\r\nmemcpy(&cyapa->product_id[0], &resp_data[51], 5);\r\ncyapa->product_id[5] = '-';\r\nmemcpy(&cyapa->product_id[6], &resp_data[56], 6);\r\ncyapa->product_id[12] = '-';\r\nmemcpy(&cyapa->product_id[13], &resp_data[62], 2);\r\ncyapa->product_id[15] = '\0';\r\nrotat_align = resp_data[68];\r\ncyapa->electrodes_rx =\r\nrotat_align ? cyapa->electrodes_y : cyapa->electrodes_x;\r\ncyapa->aligned_electrodes_rx = (cyapa->electrodes_rx + 3) & ~3u;\r\nif (!cyapa->electrodes_x || !cyapa->electrodes_y ||\r\n!cyapa->physical_size_x || !cyapa->physical_size_y ||\r\n!cyapa->max_abs_x || !cyapa->max_abs_y || !cyapa->max_z)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_bl_read_app_info(struct cyapa *cyapa)\r\n{\r\nu8 resp_data[PIP_BL_APP_INFO_RESP_LENGTH];\r\nint resp_len;\r\nint error;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\npip_bl_read_app_info, PIP_BL_READ_APP_INFO_CMD_LENGTH,\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_bl_resp_data, false);\r\nif (error || resp_len < PIP_BL_APP_INFO_RESP_LENGTH ||\r\n!PIP_CMD_COMPLETE_SUCCESS(resp_data))\r\nreturn error ? error : -EIO;\r\ncyapa->fw_maj_ver = resp_data[8];\r\ncyapa->fw_min_ver = resp_data[9];\r\ncyapa->platform_ver = (resp_data[12] >> PIP_BL_PLATFORM_VER_SHIFT) &\r\nPIP_BL_PLATFORM_VER_MASK;\r\nmemcpy(&cyapa->product_id[0], &resp_data[13], 5);\r\ncyapa->product_id[5] = '-';\r\nmemcpy(&cyapa->product_id[6], &resp_data[18], 6);\r\ncyapa->product_id[12] = '-';\r\nmemcpy(&cyapa->product_id[13], &resp_data[24], 2);\r\ncyapa->product_id[15] = '\0';\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_config_dev_irq(struct cyapa *cyapa, u8 cmd_code)\r\n{\r\nu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, cmd_code };\r\nu8 resp_data[6];\r\nint resp_len;\r\nint error;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_app_resp_data, false);\r\nif (error || !VALID_CMD_RESP_HEADER(resp_data, cmd_code) ||\r\n!PIP_CMD_COMPLETE_SUCCESS(resp_data)\r\n)\r\nreturn error < 0 ? error : -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_set_proximity(struct cyapa *cyapa, bool enable)\r\n{\r\nint error;\r\ncyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\r\nerror = cyapa_pip_set_proximity(cyapa, enable);\r\ncyapa_gen6_config_dev_irq(cyapa, GEN6_ENABLE_CMD_IRQ);\r\nreturn error;\r\n}\r\nstatic int cyapa_gen6_change_power_state(struct cyapa *cyapa, u8 power_mode)\r\n{\r\nu8 cmd[] = { 0x04, 0x00, 0x06, 0x00, 0x2f, 0x00, 0x46, power_mode };\r\nu8 resp_data[6];\r\nint resp_len;\r\nint error;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_app_resp_data, false);\r\nif (error || !VALID_CMD_RESP_HEADER(resp_data, 0x46))\r\nreturn error < 0 ? error : -EINVAL;\r\nif (resp_data[5] != power_mode)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_set_interval_setting(struct cyapa *cyapa,\r\nstruct gen6_interval_setting *interval_setting)\r\n{\r\nstruct gen6_set_interval_cmd {\r\n__le16 addr;\r\n__le16 length;\r\nu8 report_id;\r\nu8 rsvd;\r\nu8 cmd_code;\r\n__le16 active_interval;\r\n__le16 lp1_interval;\r\n__le16 lp2_interval;\r\n} __packed set_interval_cmd;\r\nu8 resp_data[11];\r\nint resp_len;\r\nint error;\r\nmemset(&set_interval_cmd, 0, sizeof(set_interval_cmd));\r\nput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &set_interval_cmd.addr);\r\nput_unaligned_le16(sizeof(set_interval_cmd) - 2,\r\n&set_interval_cmd.length);\r\nset_interval_cmd.report_id = PIP_APP_CMD_REPORT_ID;\r\nset_interval_cmd.cmd_code = GEN6_SET_POWER_MODE_INTERVAL;\r\nput_unaligned_le16(interval_setting->active_interval,\r\n&set_interval_cmd.active_interval);\r\nput_unaligned_le16(interval_setting->lp1_interval,\r\n&set_interval_cmd.lp1_interval);\r\nput_unaligned_le16(interval_setting->lp2_interval,\r\n&set_interval_cmd.lp2_interval);\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\n(u8 *)&set_interval_cmd, sizeof(set_interval_cmd),\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_app_resp_data, false);\r\nif (error ||\r\n!VALID_CMD_RESP_HEADER(resp_data, GEN6_SET_POWER_MODE_INTERVAL))\r\nreturn error < 0 ? error : -EINVAL;\r\ninterval_setting->active_interval = get_unaligned_le16(&resp_data[5]);\r\ninterval_setting->lp1_interval = get_unaligned_le16(&resp_data[7]);\r\ninterval_setting->lp2_interval = get_unaligned_le16(&resp_data[9]);\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_get_interval_setting(struct cyapa *cyapa,\r\nstruct gen6_interval_setting *interval_setting)\r\n{\r\nu8 cmd[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00,\r\nGEN6_GET_POWER_MODE_INTERVAL };\r\nu8 resp_data[11];\r\nint resp_len;\r\nint error;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa, cmd, sizeof(cmd),\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_app_resp_data, false);\r\nif (error ||\r\n!VALID_CMD_RESP_HEADER(resp_data, GEN6_GET_POWER_MODE_INTERVAL))\r\nreturn error < 0 ? error : -EINVAL;\r\ninterval_setting->active_interval = get_unaligned_le16(&resp_data[5]);\r\ninterval_setting->lp1_interval = get_unaligned_le16(&resp_data[7]);\r\ninterval_setting->lp2_interval = get_unaligned_le16(&resp_data[9]);\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen6_deep_sleep(struct cyapa *cyapa, u8 state)\r\n{\r\nu8 ping[] = { 0x04, 0x00, 0x05, 0x00, 0x2f, 0x00, 0x00 };\r\nif (state == PIP_DEEP_SLEEP_STATE_ON)\r\ncyapa_i2c_pip_write(cyapa, ping, sizeof(ping));\r\nreturn cyapa_pip_deep_sleep(cyapa, state);\r\n}\r\nstatic int cyapa_gen6_set_power_mode(struct cyapa *cyapa,\r\nu8 power_mode, u16 sleep_time, enum cyapa_pm_stage pm_stage)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nstruct gen6_interval_setting *interval_setting =\r\n&cyapa->gen6_interval_setting;\r\nu8 lp_mode;\r\nint error;\r\nif (cyapa->state != CYAPA_STATE_GEN6_APP)\r\nreturn 0;\r\nif (PIP_DEV_GET_PWR_STATE(cyapa) == UNINIT_PWR_MODE) {\r\nPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\r\n}\r\nif (PIP_DEV_UNINIT_SLEEP_TIME(cyapa) &&\r\nPIP_DEV_GET_PWR_STATE(cyapa) != PWR_MODE_OFF)\r\nPIP_DEV_SET_SLEEP_TIME(cyapa, UNINIT_SLEEP_TIME);\r\nif (PIP_DEV_GET_PWR_STATE(cyapa) == power_mode) {\r\nif (power_mode == PWR_MODE_OFF ||\r\npower_mode == PWR_MODE_FULL_ACTIVE ||\r\npower_mode == PWR_MODE_BTN_ONLY ||\r\nPIP_DEV_GET_SLEEP_TIME(cyapa) == sleep_time) {\r\nreturn 0;\r\n}\r\n}\r\nif (power_mode == PWR_MODE_OFF) {\r\ncyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\r\nerror = cyapa_gen6_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_OFF);\r\nif (error) {\r\ndev_err(dev, "enter deep sleep fail: %d\n", error);\r\nreturn error;\r\n}\r\nPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_OFF);\r\nreturn 0;\r\n}\r\nif (PIP_DEV_GET_PWR_STATE(cyapa) == PWR_MODE_OFF) {\r\nerror = cyapa_gen6_deep_sleep(cyapa, PIP_DEEP_SLEEP_STATE_ON);\r\nif (error) {\r\ndev_err(dev, "deep sleep wake fail: %d\n", error);\r\nreturn error;\r\n}\r\n}\r\ncyapa_gen6_config_dev_irq(cyapa, GEN6_DISABLE_CMD_IRQ);\r\nif (power_mode == PWR_MODE_FULL_ACTIVE) {\r\nerror = cyapa_gen6_change_power_state(cyapa,\r\nGEN6_POWER_MODE_ACTIVE);\r\nif (error) {\r\ndev_err(dev, "change to active fail: %d\n", error);\r\ngoto out;\r\n}\r\nPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_FULL_ACTIVE);\r\ncyapa_gen6_get_interval_setting(cyapa, interval_setting);\r\n} else if (power_mode == PWR_MODE_BTN_ONLY) {\r\nerror = cyapa_gen6_change_power_state(cyapa,\r\nGEN6_POWER_MODE_BTN_ONLY);\r\nif (error) {\r\ndev_err(dev, "fail to button only mode: %d\n", error);\r\ngoto out;\r\n}\r\nPIP_DEV_SET_PWR_STATE(cyapa, PWR_MODE_BTN_ONLY);\r\n} else {\r\nif (interval_setting->lp1_interval == sleep_time) {\r\nlp_mode = GEN6_POWER_MODE_LP_MODE1;\r\n} else if (interval_setting->lp2_interval == sleep_time) {\r\nlp_mode = GEN6_POWER_MODE_LP_MODE2;\r\n} else {\r\nif (interval_setting->lp1_interval == 0) {\r\ninterval_setting->lp1_interval = sleep_time;\r\nlp_mode = GEN6_POWER_MODE_LP_MODE1;\r\n} else {\r\ninterval_setting->lp2_interval = sleep_time;\r\nlp_mode = GEN6_POWER_MODE_LP_MODE2;\r\n}\r\ncyapa_gen6_set_interval_setting(cyapa,\r\ninterval_setting);\r\n}\r\nerror = cyapa_gen6_change_power_state(cyapa, lp_mode);\r\nif (error) {\r\ndev_err(dev, "set power state to 0x%02x failed: %d\n",\r\nlp_mode, error);\r\ngoto out;\r\n}\r\nPIP_DEV_SET_SLEEP_TIME(cyapa, sleep_time);\r\nPIP_DEV_SET_PWR_STATE(cyapa,\r\ncyapa_sleep_time_to_pwr_cmd(sleep_time));\r\n}\r\nout:\r\ncyapa_gen6_config_dev_irq(cyapa, GEN6_ENABLE_CMD_IRQ);\r\nreturn error;\r\n}\r\nstatic int cyapa_gen6_initialize(struct cyapa *cyapa)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cyapa_pip_retrieve_data_structure(struct cyapa *cyapa,\r\nu16 read_offset, u16 read_len, u8 data_id,\r\nu8 *data, int *data_buf_lens)\r\n{\r\nstruct retrieve_data_struct_cmd {\r\nstruct pip_app_cmd_head head;\r\n__le16 read_offset;\r\n__le16 read_length;\r\nu8 data_id;\r\n} __packed cmd;\r\nu8 resp_data[GEN6_MAX_RX_NUM + 10];\r\nint resp_len;\r\nint error;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nput_unaligned_le16(PIP_OUTPUT_REPORT_ADDR, &cmd.head.addr);\r\nput_unaligned_le16(sizeof(cmd), &cmd.head.length - 2);\r\ncmd.head.report_id = PIP_APP_CMD_REPORT_ID;\r\ncmd.head.cmd_code = PIP_RETRIEVE_DATA_STRUCTURE;\r\nput_unaligned_le16(read_offset, &cmd.read_offset);\r\nput_unaligned_le16(read_len, &cmd.read_length);\r\ncmd.data_id = data_id;\r\nresp_len = sizeof(resp_data);\r\nerror = cyapa_i2c_pip_cmd_irq_sync(cyapa,\r\n(u8 *)&cmd, sizeof(cmd),\r\nresp_data, &resp_len,\r\n500, cyapa_sort_tsg_pip_app_resp_data,\r\ntrue);\r\nif (error || !PIP_CMD_COMPLETE_SUCCESS(resp_data) ||\r\nresp_data[6] != data_id ||\r\n!VALID_CMD_RESP_HEADER(resp_data, PIP_RETRIEVE_DATA_STRUCTURE))\r\nreturn (error < 0) ? error : -EAGAIN;\r\nread_len = get_unaligned_le16(&resp_data[7]);\r\nif (*data_buf_lens < read_len) {\r\n*data_buf_lens = read_len;\r\nreturn -ENOBUFS;\r\n}\r\nmemcpy(data, &resp_data[10], read_len);\r\n*data_buf_lens = read_len;\r\nreturn 0;\r\n}\r\nstatic ssize_t cyapa_gen6_show_baseline(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nu8 data[GEN6_MAX_RX_NUM];\r\nint data_len;\r\nint size = 0;\r\nint i;\r\nint error;\r\nint resume_error;\r\nif (!cyapa_is_pip_app_mode(cyapa))\r\nreturn -EBUSY;\r\nerror = cyapa_pip_suspend_scanning(cyapa);\r\nif (error)\r\nreturn error;\r\ndata_len = sizeof(data);\r\nerror = cyapa_pip_retrieve_data_structure(cyapa, 0, data_len,\r\nGEN6_RETRIEVE_DATA_ID_RX_ATTENURATOR_IDAC,\r\ndata, &data_len);\r\nif (error)\r\ngoto resume_scanning;\r\nsize = scnprintf(buf, PAGE_SIZE, "%d %d %d %d %d %d ",\r\ndata[0],\r\ndata[1],\r\ndata[2],\r\ndata[3],\r\ndata[4],\r\ndata[5]\r\n);\r\ndata_len = sizeof(data);\r\nerror = cyapa_pip_retrieve_data_structure(cyapa, 0, data_len,\r\nGEN6_RETRIEVE_DATA_ID_ATTENURATOR_TRIM,\r\ndata, &data_len);\r\nif (error)\r\ngoto resume_scanning;\r\nfor (i = 0; i < data_len; i++)\r\nsize += scnprintf(buf + size, PAGE_SIZE - size, "%d ", data[i]);\r\nsize += scnprintf(buf + size, PAGE_SIZE - size, "\n");\r\nresume_scanning:\r\nresume_error = cyapa_pip_resume_scanning(cyapa);\r\nif (resume_error || error) {\r\nmemset(buf, 0, PAGE_SIZE);\r\nreturn resume_error ? resume_error : error;\r\n}\r\nreturn size;\r\n}\r\nstatic int cyapa_gen6_operational_check(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\nif (cyapa->gen != CYAPA_GEN6)\r\nreturn -ENODEV;\r\nswitch (cyapa->state) {\r\ncase CYAPA_STATE_GEN6_BL:\r\nerror = cyapa_pip_bl_exit(cyapa);\r\nif (error) {\r\ncyapa_gen6_bl_read_app_info(cyapa);\r\ngoto out;\r\n}\r\ncyapa->state = CYAPA_STATE_GEN6_APP;\r\ncase CYAPA_STATE_GEN6_APP:\r\nerror = cyapa_gen6_set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0, CYAPA_PM_ACTIVE);\r\nif (error)\r\ndev_warn(dev, "%s: failed to set power active mode.\n",\r\n__func__);\r\nerror = cyapa_pip_set_proximity(cyapa, true);\r\nif (error)\r\ndev_warn(dev, "%s: failed to enable proximity.\n",\r\n__func__);\r\nerror = cyapa_gen6_read_sys_info(cyapa);\r\nif (error)\r\ngoto out;\r\nif (memcmp(cyapa->product_id, product_id,\r\nstrlen(product_id)) != 0) {\r\ndev_err(dev, "%s: unknown product ID (%s)\n",\r\n__func__, cyapa->product_id);\r\nerror = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nerror = -EINVAL;\r\n}\r\nout:\r\nreturn error;\r\n}
