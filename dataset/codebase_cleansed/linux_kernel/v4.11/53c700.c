static inline __u8\r\nNCR_700_offset_period_to_sxfer(struct NCR_700_Host_Parameters *hostdata,\r\n__u8 offset, __u8 period)\r\n{\r\nint XFERP;\r\n__u8 min_xferp = (hostdata->chip710\r\n? NCR_710_MIN_XFERP : NCR_700_MIN_XFERP);\r\n__u8 max_offset = (hostdata->chip710\r\n? NCR_710_MAX_OFFSET : NCR_700_MAX_OFFSET);\r\nif(offset == 0)\r\nreturn 0;\r\nif(period < hostdata->min_period) {\r\nprintk(KERN_WARNING "53c700: Period %dns is less than this chip's minimum, setting to %d\n", period*4, NCR_700_MIN_PERIOD*4);\r\nperiod = hostdata->min_period;\r\n}\r\nXFERP = (period*4 * hostdata->sync_clock)/1000 - 4;\r\nif(offset > max_offset) {\r\nprintk(KERN_WARNING "53c700: Offset %d exceeds chip maximum, setting to %d\n",\r\noffset, max_offset);\r\noffset = max_offset;\r\n}\r\nif(XFERP < min_xferp) {\r\nXFERP = min_xferp;\r\n}\r\nreturn (offset & 0x0f) | (XFERP & 0x07)<<4;\r\n}\r\nstatic inline __u8\r\nNCR_700_get_SXFER(struct scsi_device *SDp)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];\r\nreturn NCR_700_offset_period_to_sxfer(hostdata,\r\nspi_offset(SDp->sdev_target),\r\nspi_period(SDp->sdev_target));\r\n}\r\nstruct Scsi_Host *\r\nNCR_700_detect(struct scsi_host_template *tpnt,\r\nstruct NCR_700_Host_Parameters *hostdata, struct device *dev)\r\n{\r\ndma_addr_t pScript, pSlots;\r\n__u8 *memory;\r\n__u32 *script;\r\nstruct Scsi_Host *host;\r\nstatic int banner = 0;\r\nint j;\r\nif(tpnt->sdev_attrs == NULL)\r\ntpnt->sdev_attrs = NCR_700_dev_attrs;\r\nmemory = dma_alloc_noncoherent(hostdata->dev, TOTAL_MEM_SIZE,\r\n&pScript, GFP_KERNEL);\r\nif(memory == NULL) {\r\nprintk(KERN_ERR "53c700: Failed to allocate memory for driver, detaching\n");\r\nreturn NULL;\r\n}\r\nscript = (__u32 *)memory;\r\nhostdata->msgin = memory + MSGIN_OFFSET;\r\nhostdata->msgout = memory + MSGOUT_OFFSET;\r\nhostdata->status = memory + STATUS_OFFSET;\r\nhostdata->slots = (struct NCR_700_command_slot *)(memory + SLOTS_OFFSET);\r\nhostdata->dev = dev;\r\npSlots = pScript + SLOTS_OFFSET;\r\ntpnt->queuecommand = NCR_700_queuecommand;\r\ntpnt->eh_abort_handler = NCR_700_abort;\r\ntpnt->eh_bus_reset_handler = NCR_700_bus_reset;\r\ntpnt->eh_host_reset_handler = NCR_700_host_reset;\r\ntpnt->can_queue = NCR_700_COMMAND_SLOTS_PER_HOST;\r\ntpnt->sg_tablesize = NCR_700_SG_SEGMENTS;\r\ntpnt->cmd_per_lun = NCR_700_CMD_PER_LUN;\r\ntpnt->use_clustering = ENABLE_CLUSTERING;\r\ntpnt->slave_configure = NCR_700_slave_configure;\r\ntpnt->slave_destroy = NCR_700_slave_destroy;\r\ntpnt->slave_alloc = NCR_700_slave_alloc;\r\ntpnt->change_queue_depth = NCR_700_change_queue_depth;\r\nif(tpnt->name == NULL)\r\ntpnt->name = "53c700";\r\nif(tpnt->proc_name == NULL)\r\ntpnt->proc_name = "53c700";\r\nhost = scsi_host_alloc(tpnt, 4);\r\nif (!host)\r\nreturn NULL;\r\nmemset(hostdata->slots, 0, sizeof(struct NCR_700_command_slot)\r\n* NCR_700_COMMAND_SLOTS_PER_HOST);\r\nfor (j = 0; j < NCR_700_COMMAND_SLOTS_PER_HOST; j++) {\r\ndma_addr_t offset = (dma_addr_t)((unsigned long)&hostdata->slots[j].SG[0]\r\n- (unsigned long)&hostdata->slots[0].SG[0]);\r\nhostdata->slots[j].pSG = (struct NCR_700_SG_List *)((unsigned long)(pSlots + offset));\r\nif(j == 0)\r\nhostdata->free_list = &hostdata->slots[j];\r\nelse\r\nhostdata->slots[j-1].ITL_forw = &hostdata->slots[j];\r\nhostdata->slots[j].state = NCR_700_SLOT_FREE;\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(SCRIPT); j++)\r\nscript[j] = bS_to_host(SCRIPT[j]);\r\nfor (j = 0; j < PATCHES; j++)\r\nscript[LABELPATCHES[j]] = bS_to_host(pScript + SCRIPT[LABELPATCHES[j]]);\r\nscript_patch_32(hostdata->dev, script, MessageLocation,\r\npScript + MSGOUT_OFFSET);\r\nscript_patch_32(hostdata->dev, script, StatusAddress,\r\npScript + STATUS_OFFSET);\r\nscript_patch_32(hostdata->dev, script, ReceiveMsgAddress,\r\npScript + MSGIN_OFFSET);\r\nhostdata->script = script;\r\nhostdata->pScript = pScript;\r\ndma_sync_single_for_device(hostdata->dev, pScript, sizeof(SCRIPT), DMA_TO_DEVICE);\r\nhostdata->state = NCR_700_HOST_FREE;\r\nhostdata->cmd = NULL;\r\nhost->max_id = 8;\r\nhost->max_lun = NCR_700_MAX_LUNS;\r\nBUG_ON(NCR_700_transport_template == NULL);\r\nhost->transportt = NCR_700_transport_template;\r\nhost->unique_id = (unsigned long)hostdata->base;\r\nhostdata->eh_complete = NULL;\r\nhost->hostdata[0] = (unsigned long)hostdata;\r\nNCR_700_writeb(0xff, host, CTEST9_REG);\r\nif (hostdata->chip710)\r\nhostdata->rev = (NCR_700_readb(host, CTEST8_REG)>>4) & 0x0f;\r\nelse\r\nhostdata->rev = (NCR_700_readb(host, CTEST7_REG)>>4) & 0x0f;\r\nhostdata->fast = (NCR_700_readb(host, CTEST9_REG) == 0);\r\nif (banner == 0) {\r\nprintk(KERN_NOTICE "53c700: Version " NCR_700_VERSION " By James.Bottomley@HansenPartnership.com\n");\r\nbanner = 1;\r\n}\r\nprintk(KERN_NOTICE "scsi%d: %s rev %d %s\n", host->host_no,\r\nhostdata->chip710 ? "53c710" :\r\n(hostdata->fast ? "53c700-66" : "53c700"),\r\nhostdata->rev, hostdata->differential ?\r\n"(Differential)" : "");\r\nNCR_700_chip_reset(host);\r\nif (scsi_add_host(host, dev)) {\r\ndev_printk(KERN_ERR, dev, "53c700: scsi_add_host failed\n");\r\nscsi_host_put(host);\r\nreturn NULL;\r\n}\r\nspi_signalling(host) = hostdata->differential ? SPI_SIGNAL_HVD :\r\nSPI_SIGNAL_SE;\r\nreturn host;\r\n}\r\nint\r\nNCR_700_release(struct Scsi_Host *host)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\ndma_free_noncoherent(hostdata->dev, TOTAL_MEM_SIZE,\r\nhostdata->script, hostdata->pScript);\r\nreturn 1;\r\n}\r\nstatic inline __u8\r\nNCR_700_identify(int can_disconnect, __u8 lun)\r\n{\r\nreturn IDENTIFY_BASE |\r\n((can_disconnect) ? 0x40 : 0) |\r\n(lun & NCR_700_LUN_MASK);\r\n}\r\nstatic inline int\r\nNCR_700_data_residual (struct Scsi_Host *host) {\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\nint count, synchronous = 0;\r\nunsigned int ddir;\r\nif(hostdata->chip710) {\r\ncount = ((NCR_700_readb(host, DFIFO_REG) & 0x7f) -\r\n(NCR_700_readl(host, DBC_REG) & 0x7f)) & 0x7f;\r\n} else {\r\ncount = ((NCR_700_readb(host, DFIFO_REG) & 0x3f) -\r\n(NCR_700_readl(host, DBC_REG) & 0x3f)) & 0x3f;\r\n}\r\nif(hostdata->fast)\r\nsynchronous = NCR_700_readb(host, SXFER_REG) & 0x0f;\r\nddir = NCR_700_readb(host, CTEST0_REG) & 0x01;\r\nif (ddir) {\r\nif (synchronous)\r\ncount += (NCR_700_readb(host, SSTAT2_REG) & 0xf0) >> 4;\r\nelse\r\nif (NCR_700_readb(host, SSTAT1_REG) & SIDL_REG_FULL)\r\n++count;\r\n} else {\r\n__u8 sstat = NCR_700_readb(host, SSTAT1_REG);\r\nif (sstat & SODL_REG_FULL)\r\n++count;\r\nif (synchronous && (sstat & SODR_REG_FULL))\r\n++count;\r\n}\r\n#ifdef NCR_700_DEBUG\r\nif(count)\r\nprintk("RESIDUAL IS %d (ddir %d)\n", count, ddir);\r\n#endif\r\nreturn count;\r\n}\r\nstatic inline char *\r\nsbcl_to_string(__u8 sbcl)\r\n{\r\nint i;\r\nstatic char ret[256];\r\nret[0]='\0';\r\nfor(i=0; i<8; i++) {\r\nif((1<<i) & sbcl)\r\nstrcat(ret, NCR_700_SBCL_bits[i]);\r\n}\r\nstrcat(ret, NCR_700_SBCL_to_phase[sbcl & 0x07]);\r\nreturn ret;\r\n}\r\nstatic inline __u8\r\nbitmap_to_number(__u8 bitmap)\r\n{\r\n__u8 i;\r\nfor(i=0; i<8 && !(bitmap &(1<<i)); i++)\r\n;\r\nreturn i;\r\n}\r\nSTATIC struct NCR_700_command_slot *\r\nfind_empty_slot(struct NCR_700_Host_Parameters *hostdata)\r\n{\r\nstruct NCR_700_command_slot *slot = hostdata->free_list;\r\nif(slot == NULL) {\r\nif(hostdata->command_slot_count != NCR_700_COMMAND_SLOTS_PER_HOST)\r\nprintk(KERN_ERR "SLOTS FULL, but count is %d, should be %d\n", hostdata->command_slot_count, NCR_700_COMMAND_SLOTS_PER_HOST);\r\nreturn NULL;\r\n}\r\nif(slot->state != NCR_700_SLOT_FREE)\r\nprintk(KERN_ERR "BUSY SLOT ON FREE LIST!!!\n");\r\nhostdata->free_list = slot->ITL_forw;\r\nslot->ITL_forw = NULL;\r\nslot->state = NCR_700_SLOT_BUSY;\r\nslot->flags = 0;\r\nhostdata->command_slot_count++;\r\nreturn slot;\r\n}\r\nSTATIC void\r\nfree_slot(struct NCR_700_command_slot *slot,\r\nstruct NCR_700_Host_Parameters *hostdata)\r\n{\r\nif((slot->state & NCR_700_SLOT_MASK) != NCR_700_SLOT_MAGIC) {\r\nprintk(KERN_ERR "53c700: SLOT %p is not MAGIC!!!\n", slot);\r\n}\r\nif(slot->state == NCR_700_SLOT_FREE) {\r\nprintk(KERN_ERR "53c700: SLOT %p is FREE!!!\n", slot);\r\n}\r\nslot->resume_offset = 0;\r\nslot->cmnd = NULL;\r\nslot->state = NCR_700_SLOT_FREE;\r\nslot->ITL_forw = hostdata->free_list;\r\nhostdata->free_list = slot;\r\nhostdata->command_slot_count--;\r\n}\r\nSTATIC void\r\nsave_for_reselection(struct NCR_700_Host_Parameters *hostdata,\r\nstruct scsi_cmnd *SCp, __u32 dsp)\r\n{\r\nif(SCp != NULL) {\r\nstruct NCR_700_command_slot *slot =\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\nslot->resume_offset = dsp;\r\n}\r\nhostdata->state = NCR_700_HOST_FREE;\r\nhostdata->cmd = NULL;\r\n}\r\nSTATIC inline void\r\nNCR_700_unmap(struct NCR_700_Host_Parameters *hostdata, struct scsi_cmnd *SCp,\r\nstruct NCR_700_command_slot *slot)\r\n{\r\nif(SCp->sc_data_direction != DMA_NONE &&\r\nSCp->sc_data_direction != DMA_BIDIRECTIONAL)\r\nscsi_dma_unmap(SCp);\r\n}\r\nSTATIC inline void\r\nNCR_700_scsi_done(struct NCR_700_Host_Parameters *hostdata,\r\nstruct scsi_cmnd *SCp, int result)\r\n{\r\nhostdata->state = NCR_700_HOST_FREE;\r\nhostdata->cmd = NULL;\r\nif(SCp != NULL) {\r\nstruct NCR_700_command_slot *slot =\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\ndma_unmap_single(hostdata->dev, slot->pCmd,\r\nMAX_COMMAND_SIZE, DMA_TO_DEVICE);\r\nif (slot->flags == NCR_700_FLAG_AUTOSENSE) {\r\nchar *cmnd = NCR_700_get_sense_cmnd(SCp->device);\r\ndma_unmap_single(hostdata->dev, slot->dma_handle,\r\nSCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nif (result == 0)\r\nresult = cmnd[7];\r\nSCp->cmd_len = cmnd[8];\r\n} else\r\nNCR_700_unmap(hostdata, SCp, slot);\r\nfree_slot(slot, hostdata);\r\n#ifdef NCR_700_DEBUG\r\nif(NCR_700_get_depth(SCp->device) == 0 ||\r\nNCR_700_get_depth(SCp->device) > SCp->device->queue_depth)\r\nprintk(KERN_ERR "Invalid depth in NCR_700_scsi_done(): %d\n",\r\nNCR_700_get_depth(SCp->device));\r\n#endif\r\nNCR_700_set_depth(SCp->device, NCR_700_get_depth(SCp->device) - 1);\r\nSCp->host_scribble = NULL;\r\nSCp->result = result;\r\nSCp->scsi_done(SCp);\r\n} else {\r\nprintk(KERN_ERR "53c700: SCSI DONE HAS NULL SCp\n");\r\n}\r\n}\r\nSTATIC void\r\nNCR_700_internal_bus_reset(struct Scsi_Host *host)\r\n{\r\nNCR_700_writeb(ASSERT_RST, host, SCNTL1_REG);\r\nudelay(50);\r\nNCR_700_writeb(0, host, SCNTL1_REG);\r\n}\r\nSTATIC void\r\nNCR_700_chip_setup(struct Scsi_Host *host)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\n__u8 min_period;\r\n__u8 min_xferp = (hostdata->chip710 ? NCR_710_MIN_XFERP : NCR_700_MIN_XFERP);\r\nif(hostdata->chip710) {\r\n__u8 burst_disable = 0;\r\n__u8 burst_length = 0;\r\nswitch (hostdata->burst_length) {\r\ncase 1:\r\nburst_length = BURST_LENGTH_1;\r\nbreak;\r\ncase 2:\r\nburst_length = BURST_LENGTH_2;\r\nbreak;\r\ncase 4:\r\nburst_length = BURST_LENGTH_4;\r\nbreak;\r\ncase 8:\r\nburst_length = BURST_LENGTH_8;\r\nbreak;\r\ndefault:\r\nburst_disable = BURST_DISABLE;\r\nbreak;\r\n}\r\nhostdata->dcntl_extra |= COMPAT_700_MODE;\r\nNCR_700_writeb(hostdata->dcntl_extra, host, DCNTL_REG);\r\nNCR_700_writeb(burst_length | hostdata->dmode_extra,\r\nhost, DMODE_710_REG);\r\nNCR_700_writeb(burst_disable | hostdata->ctest7_extra |\r\n(hostdata->differential ? DIFF : 0),\r\nhost, CTEST7_REG);\r\nNCR_700_writeb(BTB_TIMER_DISABLE, host, CTEST0_REG);\r\nNCR_700_writeb(FULL_ARBITRATION | ENABLE_PARITY | PARITY\r\n| AUTO_ATN, host, SCNTL0_REG);\r\n} else {\r\nNCR_700_writeb(BURST_LENGTH_8 | hostdata->dmode_extra,\r\nhost, DMODE_700_REG);\r\nNCR_700_writeb(hostdata->differential ?\r\nDIFF : 0, host, CTEST7_REG);\r\nif(hostdata->fast) {\r\nNCR_700_writeb(LAST_DIS_ENBL | ENABLE_ACTIVE_NEGATION\r\n| GENERATE_RECEIVE_PARITY, host,\r\nCTEST8_REG);\r\n} else {\r\nNCR_700_writeb(FULL_ARBITRATION | ENABLE_PARITY\r\n| PARITY | AUTO_ATN, host, SCNTL0_REG);\r\n}\r\n}\r\nNCR_700_writeb(1 << host->this_id, host, SCID_REG);\r\nNCR_700_writeb(0, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_OPERATION, host, SXFER_REG);\r\nNCR_700_writeb(PHASE_MM_INT | SEL_TIMEOUT_INT | GROSS_ERR_INT | UX_DISC_INT\r\n| RST_INT | PAR_ERR_INT | SELECT_INT, host, SIEN_REG);\r\nNCR_700_writeb(ABORT_INT | INT_INST_INT | ILGL_INST_INT, host, DIEN_REG);\r\nNCR_700_writeb(ENABLE_SELECT, host, SCNTL1_REG);\r\nif(hostdata->clock > 75) {\r\nprintk(KERN_ERR "53c700: Clock speed %dMHz is too high: 75Mhz is the maximum this chip can be driven at\n", hostdata->clock);\r\nDEBUG(("53c700: sync 2 async 3\n"));\r\nNCR_700_writeb(SYNC_DIV_2_0, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_DIV_3_0 | hostdata->dcntl_extra, host, DCNTL_REG);\r\nhostdata->sync_clock = hostdata->clock/2;\r\n} else if(hostdata->clock > 50 && hostdata->clock <= 75) {\r\nDEBUG(("53c700: sync 1.5 async 3\n"));\r\nNCR_700_writeb(SYNC_DIV_1_5, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_DIV_3_0 | hostdata->dcntl_extra, host, DCNTL_REG);\r\nhostdata->sync_clock = hostdata->clock*2;\r\nhostdata->sync_clock /= 3;\r\n} else if(hostdata->clock > 37 && hostdata->clock <= 50) {\r\nDEBUG(("53c700: sync 1 async 2\n"));\r\nNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_DIV_2_0 | hostdata->dcntl_extra, host, DCNTL_REG);\r\nhostdata->sync_clock = hostdata->clock;\r\n} else if(hostdata->clock > 25 && hostdata->clock <=37) {\r\nDEBUG(("53c700: sync 1 async 1.5\n"));\r\nNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_DIV_1_5 | hostdata->dcntl_extra, host, DCNTL_REG);\r\nhostdata->sync_clock = hostdata->clock;\r\n} else {\r\nDEBUG(("53c700: sync 1 async 1\n"));\r\nNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\r\nNCR_700_writeb(ASYNC_DIV_1_0 | hostdata->dcntl_extra, host, DCNTL_REG);\r\nhostdata->sync_clock = hostdata->clock;\r\n}\r\nmin_period = 1000*(4+min_xferp)/(4*hostdata->sync_clock);\r\nhostdata->min_period = NCR_700_MIN_PERIOD;\r\nif(min_period > NCR_700_MIN_PERIOD)\r\nhostdata->min_period = min_period;\r\n}\r\nSTATIC void\r\nNCR_700_chip_reset(struct Scsi_Host *host)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\nif(hostdata->chip710) {\r\nNCR_700_writeb(SOFTWARE_RESET_710, host, ISTAT_REG);\r\nudelay(100);\r\nNCR_700_writeb(0, host, ISTAT_REG);\r\n} else {\r\nNCR_700_writeb(SOFTWARE_RESET, host, DCNTL_REG);\r\nudelay(100);\r\nNCR_700_writeb(0, host, DCNTL_REG);\r\n}\r\nmdelay(1000);\r\nNCR_700_chip_setup(host);\r\n}\r\nSTATIC __u32\r\nprocess_extended_message(struct Scsi_Host *host,\r\nstruct NCR_700_Host_Parameters *hostdata,\r\nstruct scsi_cmnd *SCp, __u32 dsp, __u32 dsps)\r\n{\r\n__u32 resume_offset = dsp, temp = dsp + 8;\r\n__u8 pun = 0xff, lun = 0xff;\r\nif(SCp != NULL) {\r\npun = SCp->device->id;\r\nlun = SCp->device->lun;\r\n}\r\nswitch(hostdata->msgin[2]) {\r\ncase A_SDTR_MSG:\r\nif(SCp != NULL && NCR_700_is_flag_set(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION)) {\r\nstruct scsi_target *starget = SCp->device->sdev_target;\r\n__u8 period = hostdata->msgin[3];\r\n__u8 offset = hostdata->msgin[4];\r\nif(offset == 0 || period == 0) {\r\noffset = 0;\r\nperiod = 0;\r\n}\r\nspi_offset(starget) = offset;\r\nspi_period(starget) = period;\r\nif(NCR_700_is_flag_set(SCp->device, NCR_700_DEV_PRINT_SYNC_NEGOTIATION)) {\r\nspi_display_xfer_agreement(starget);\r\nNCR_700_clear_flag(SCp->device, NCR_700_DEV_PRINT_SYNC_NEGOTIATION);\r\n}\r\nNCR_700_set_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\r\nNCR_700_clear_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\r\nNCR_700_writeb(NCR_700_get_SXFER(SCp->device),\r\nhost, SXFER_REG);\r\n} else {\r\nshost_printk(KERN_WARNING, host,\r\n"Unexpected SDTR msg\n");\r\nhostdata->msgout[0] = A_REJECT_MSG;\r\ndma_cache_sync(hostdata->dev, hostdata->msgout, 1, DMA_TO_DEVICE);\r\nscript_patch_16(hostdata->dev, hostdata->script,\r\nMessageCount, 1);\r\nresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\r\n}\r\nbreak;\r\ncase A_WDTR_MSG:\r\nprintk(KERN_INFO "scsi%d: (%d:%d), Unsolicited WDTR after CMD, Rejecting\n",\r\nhost->host_no, pun, lun);\r\nhostdata->msgout[0] = A_REJECT_MSG;\r\ndma_cache_sync(hostdata->dev, hostdata->msgout, 1, DMA_TO_DEVICE);\r\nscript_patch_16(hostdata->dev, hostdata->script, MessageCount,\r\n1);\r\nresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "scsi%d (%d:%d): Unexpected message %s: ",\r\nhost->host_no, pun, lun,\r\nNCR_700_phase[(dsps & 0xf00) >> 8]);\r\nspi_print_msg(hostdata->msgin);\r\nprintk("\n");\r\nhostdata->msgout[0] = A_REJECT_MSG;\r\ndma_cache_sync(hostdata->dev, hostdata->msgout, 1, DMA_TO_DEVICE);\r\nscript_patch_16(hostdata->dev, hostdata->script, MessageCount,\r\n1);\r\nresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\r\n}\r\nNCR_700_writel(temp, host, TEMP_REG);\r\nreturn resume_offset;\r\n}\r\nSTATIC __u32\r\nprocess_message(struct Scsi_Host *host, struct NCR_700_Host_Parameters *hostdata,\r\nstruct scsi_cmnd *SCp, __u32 dsp, __u32 dsps)\r\n{\r\n__u32 temp = dsp + 8, resume_offset = dsp;\r\n__u8 pun = 0xff, lun = 0xff;\r\nif(SCp != NULL) {\r\npun = SCp->device->id;\r\nlun = SCp->device->lun;\r\n}\r\n#ifdef NCR_700_DEBUG\r\nprintk("scsi%d (%d:%d): message %s: ", host->host_no, pun, lun,\r\nNCR_700_phase[(dsps & 0xf00) >> 8]);\r\nspi_print_msg(hostdata->msgin);\r\nprintk("\n");\r\n#endif\r\nswitch(hostdata->msgin[0]) {\r\ncase A_EXTENDED_MSG:\r\nresume_offset = process_extended_message(host, hostdata, SCp,\r\ndsp, dsps);\r\nbreak;\r\ncase A_REJECT_MSG:\r\nif(SCp != NULL && NCR_700_is_flag_set(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION)) {\r\nspi_period(SCp->device->sdev_target) =\r\nspi_offset(SCp->device->sdev_target) = 0;\r\nNCR_700_set_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\r\nNCR_700_clear_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\r\n} else if(SCp != NULL && NCR_700_get_tag_neg_state(SCp->device) == NCR_700_DURING_TAG_NEGOTIATION) {\r\nscmd_printk(KERN_WARNING, SCp,\r\n"Rejected first tag queue attempt, turning off tag queueing\n");\r\nNCR_700_set_tag_neg_state(SCp->device, NCR_700_FINISHED_TAG_NEGOTIATION);\r\nhostdata->tag_negotiated &= ~(1<<scmd_id(SCp));\r\nSCp->device->tagged_supported = 0;\r\nSCp->device->simple_tags = 0;\r\nscsi_change_queue_depth(SCp->device, host->cmd_per_lun);\r\n} else {\r\nshost_printk(KERN_WARNING, host,\r\n"(%d:%d) Unexpected REJECT Message %s\n",\r\npun, lun,\r\nNCR_700_phase[(dsps & 0xf00) >> 8]);\r\n}\r\nbreak;\r\ncase A_PARITY_ERROR_MSG:\r\nprintk(KERN_ERR "scsi%d (%d:%d) Parity Error!\n", host->host_no,\r\npun, lun);\r\nNCR_700_internal_bus_reset(host);\r\nbreak;\r\ncase A_SIMPLE_TAG_MSG:\r\nprintk(KERN_INFO "scsi%d (%d:%d) SIMPLE TAG %d %s\n", host->host_no,\r\npun, lun, hostdata->msgin[1],\r\nNCR_700_phase[(dsps & 0xf00) >> 8]);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "scsi%d (%d:%d): Unexpected message %s: ",\r\nhost->host_no, pun, lun,\r\nNCR_700_phase[(dsps & 0xf00) >> 8]);\r\nspi_print_msg(hostdata->msgin);\r\nprintk("\n");\r\nhostdata->msgout[0] = A_REJECT_MSG;\r\ndma_cache_sync(hostdata->dev, hostdata->msgout, 1, DMA_TO_DEVICE);\r\nscript_patch_16(hostdata->dev, hostdata->script, MessageCount,\r\n1);\r\nresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\r\nbreak;\r\n}\r\nNCR_700_writel(temp, host, TEMP_REG);\r\ndma_cache_sync(hostdata->dev, hostdata->msgin, MSG_ARRAY_SIZE, DMA_FROM_DEVICE);\r\nreturn resume_offset;\r\n}\r\nSTATIC __u32\r\nprocess_script_interrupt(__u32 dsps, __u32 dsp, struct scsi_cmnd *SCp,\r\nstruct Scsi_Host *host,\r\nstruct NCR_700_Host_Parameters *hostdata)\r\n{\r\n__u32 resume_offset = 0;\r\n__u8 pun = 0xff, lun=0xff;\r\nif(SCp != NULL) {\r\npun = SCp->device->id;\r\nlun = SCp->device->lun;\r\n}\r\nif(dsps == A_GOOD_STATUS_AFTER_STATUS) {\r\nDEBUG((" COMMAND COMPLETE, status=%02x\n",\r\nhostdata->status[0]));\r\nif (NCR_700_get_tag_neg_state(SCp->device) == NCR_700_DURING_TAG_NEGOTIATION)\r\nNCR_700_set_tag_neg_state(SCp->device,\r\nNCR_700_FINISHED_TAG_NEGOTIATION);\r\nif(status_byte(hostdata->status[0]) == CHECK_CONDITION ||\r\nstatus_byte(hostdata->status[0]) == COMMAND_TERMINATED) {\r\nstruct NCR_700_command_slot *slot =\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\nif(slot->flags == NCR_700_FLAG_AUTOSENSE) {\r\nscmd_printk(KERN_ERR, SCp,\r\n"broken device is looping in contingent allegiance: ignoring\n");\r\nNCR_700_scsi_done(hostdata, SCp, hostdata->status[0]);\r\n} else {\r\nchar *cmnd =\r\nNCR_700_get_sense_cmnd(SCp->device);\r\n#ifdef NCR_DEBUG\r\nscsi_print_command(SCp);\r\nprintk(" cmd %p has status %d, requesting sense\n",\r\nSCp, hostdata->status[0]);\r\n#endif\r\nNCR_700_unmap(hostdata, SCp, slot);\r\ndma_unmap_single(hostdata->dev, slot->pCmd,\r\nMAX_COMMAND_SIZE,\r\nDMA_TO_DEVICE);\r\ncmnd[0] = REQUEST_SENSE;\r\ncmnd[1] = (lun & 0x7) << 5;\r\ncmnd[2] = 0;\r\ncmnd[3] = 0;\r\ncmnd[4] = SCSI_SENSE_BUFFERSIZE;\r\ncmnd[5] = 0;\r\ncmnd[6] = NCR_700_INTERNAL_SENSE_MAGIC;\r\ncmnd[7] = hostdata->status[0];\r\ncmnd[8] = SCp->cmd_len;\r\nSCp->cmd_len = 6;\r\nslot->pCmd = dma_map_single(hostdata->dev, cmnd, MAX_COMMAND_SIZE, DMA_TO_DEVICE);\r\nslot->dma_handle = dma_map_single(hostdata->dev, SCp->sense_buffer, SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nslot->SG[0].ins = bS_to_host(SCRIPT_MOVE_DATA_IN | SCSI_SENSE_BUFFERSIZE);\r\nslot->SG[0].pAddr = bS_to_host(slot->dma_handle);\r\nslot->SG[1].ins = bS_to_host(SCRIPT_RETURN);\r\nslot->SG[1].pAddr = 0;\r\nslot->resume_offset = hostdata->pScript;\r\ndma_cache_sync(hostdata->dev, slot->SG, sizeof(slot->SG[0])*2, DMA_TO_DEVICE);\r\ndma_cache_sync(hostdata->dev, SCp->sense_buffer, SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\r\nslot->state = NCR_700_SLOT_QUEUED;\r\nslot->flags = NCR_700_FLAG_AUTOSENSE;\r\nhostdata->state = NCR_700_HOST_FREE;\r\nhostdata->cmd = NULL;\r\n}\r\n} else {\r\nNCR_700_scsi_done(hostdata, SCp, hostdata->status[0]);\r\n}\r\n} else if((dsps & 0xfffff0f0) == A_UNEXPECTED_PHASE) {\r\n__u8 i = (dsps & 0xf00) >> 8;\r\nscmd_printk(KERN_ERR, SCp, "UNEXPECTED PHASE %s (%s)\n",\r\nNCR_700_phase[i],\r\nsbcl_to_string(NCR_700_readb(host, SBCL_REG)));\r\nscmd_printk(KERN_ERR, SCp, " len = %d, cmd =",\r\nSCp->cmd_len);\r\nscsi_print_command(SCp);\r\nNCR_700_internal_bus_reset(host);\r\n} else if((dsps & 0xfffff000) == A_FATAL) {\r\nint i = (dsps & 0xfff);\r\nprintk(KERN_ERR "scsi%d: (%d:%d) FATAL ERROR: %s\n",\r\nhost->host_no, pun, lun, NCR_700_fatal_messages[i]);\r\nif(dsps == A_FATAL_ILLEGAL_MSG_LENGTH) {\r\nprintk(KERN_ERR " msg begins %02x %02x\n",\r\nhostdata->msgin[0], hostdata->msgin[1]);\r\n}\r\nNCR_700_internal_bus_reset(host);\r\n} else if((dsps & 0xfffff0f0) == A_DISCONNECT) {\r\n#ifdef NCR_700_DEBUG\r\n__u8 i = (dsps & 0xf00) >> 8;\r\nprintk("scsi%d: (%d:%d), DISCONNECTED (%d) %s\n",\r\nhost->host_no, pun, lun,\r\ni, NCR_700_phase[i]);\r\n#endif\r\nsave_for_reselection(hostdata, SCp, dsp);\r\n} else if(dsps == A_RESELECTION_IDENTIFIED) {\r\n__u8 lun;\r\nstruct NCR_700_command_slot *slot;\r\n__u8 reselection_id = hostdata->reselection_id;\r\nstruct scsi_device *SDp;\r\nlun = hostdata->msgin[0] & 0x1f;\r\nhostdata->reselection_id = 0xff;\r\nDEBUG(("scsi%d: (%d:%d) RESELECTED!\n",\r\nhost->host_no, reselection_id, lun));\r\nSDp = __scsi_device_lookup(host, 0, reselection_id, lun);\r\nif(unlikely(SDp == NULL)) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) HAS NO device\n",\r\nhost->host_no, reselection_id, lun);\r\nBUG();\r\n}\r\nif(hostdata->msgin[1] == A_SIMPLE_TAG_MSG) {\r\nstruct scsi_cmnd *SCp;\r\nSCp = scsi_host_find_tag(SDp->host, hostdata->msgin[2]);\r\nif(unlikely(SCp == NULL)) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) no saved request for tag %d\n",\r\nhost->host_no, reselection_id, lun, hostdata->msgin[2]);\r\nBUG();\r\n}\r\nslot = (struct NCR_700_command_slot *)SCp->host_scribble;\r\nDDEBUG(KERN_DEBUG, SDp,\r\n"reselection is tag %d, slot %p(%d)\n",\r\nhostdata->msgin[2], slot, slot->tag);\r\n} else {\r\nstruct NCR_700_Device_Parameters *p = SDp->hostdata;\r\nstruct scsi_cmnd *SCp = p->current_cmnd;\r\nif(unlikely(SCp == NULL)) {\r\nsdev_printk(KERN_ERR, SDp,\r\n"no saved request for untagged cmd\n");\r\nBUG();\r\n}\r\nslot = (struct NCR_700_command_slot *)SCp->host_scribble;\r\n}\r\nif(slot == NULL) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) RESELECTED but no saved command (MSG = %02x %02x %02x)!!\n",\r\nhost->host_no, reselection_id, lun,\r\nhostdata->msgin[0], hostdata->msgin[1],\r\nhostdata->msgin[2]);\r\n} else {\r\nif(hostdata->state != NCR_700_HOST_BUSY)\r\nprintk(KERN_ERR "scsi%d: FATAL, host not busy during valid reselection!\n",\r\nhost->host_no);\r\nresume_offset = slot->resume_offset;\r\nhostdata->cmd = slot->cmnd;\r\nscript_patch_32_abs(hostdata->dev, hostdata->script,\r\nCommandAddress, slot->pCmd);\r\nscript_patch_16(hostdata->dev, hostdata->script,\r\nCommandCount, slot->cmnd->cmd_len);\r\nscript_patch_32_abs(hostdata->dev, hostdata->script,\r\nSGScriptStartAddress,\r\nto32bit(&slot->pSG[0].ins));\r\nNCR_700_writeb(NCR_700_get_SXFER(hostdata->cmd->device),\r\nhost, SXFER_REG);\r\ndma_cache_sync(hostdata->dev, hostdata->msgin,\r\nMSG_ARRAY_SIZE, DMA_FROM_DEVICE);\r\ndma_cache_sync(hostdata->dev, hostdata->msgout,\r\nMSG_ARRAY_SIZE, DMA_TO_DEVICE);\r\ndma_cache_sync(hostdata->dev, slot->cmnd->cmnd,\r\nslot->cmnd->cmd_len, DMA_TO_DEVICE);\r\n}\r\n} else if(dsps == A_RESELECTED_DURING_SELECTION) {\r\n__u8 reselection_id = NCR_700_readb(host, SFBR_REG);\r\nstruct NCR_700_command_slot *slot;\r\nreselection_id &= ~(1<<host->this_id);\r\nprintk(KERN_INFO "scsi%d: (%d:%d) RESELECTION DURING SELECTION, dsp=%08x[%04x] state=%d, count=%d\n",\r\nhost->host_no, reselection_id, lun, dsp, dsp - hostdata->pScript, hostdata->state, hostdata->command_slot_count);\r\n{\r\n__u32 SG = (__u32)bS_to_cpu(hostdata->script[A_SGScriptStartAddress_used[0]]);\r\nint i;\r\nfor(i=0; i< NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\r\nif(SG >= to32bit(&hostdata->slots[i].pSG[0])\r\n&& SG <= to32bit(&hostdata->slots[i].pSG[NCR_700_SG_SEGMENTS]))\r\nbreak;\r\n}\r\nprintk(KERN_INFO "IDENTIFIED SG segment as being %08x in slot %p, cmd %p, slot->resume_offset=%08x\n", SG, &hostdata->slots[i], hostdata->slots[i].cmnd, hostdata->slots[i].resume_offset);\r\nSCp = hostdata->slots[i].cmnd;\r\n}\r\nif(SCp != NULL) {\r\nslot = (struct NCR_700_command_slot *)SCp->host_scribble;\r\nslot->state = NCR_700_SLOT_QUEUED;\r\n}\r\nhostdata->cmd = NULL;\r\nif(reselection_id == 0) {\r\nif(hostdata->reselection_id == 0xff) {\r\nprintk(KERN_ERR "scsi%d: Invalid reselection during selection!!\n", host->host_no);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_ERR "scsi%d: script reselected and we took a selection interrupt\n",\r\nhost->host_no);\r\nreselection_id = hostdata->reselection_id;\r\n}\r\n} else {\r\nreselection_id = bitmap_to_number(reselection_id);\r\n}\r\nhostdata->reselection_id = reselection_id;\r\nhostdata->msgin[1] = 0;\r\ndma_cache_sync(hostdata->dev, hostdata->msgin,\r\nMSG_ARRAY_SIZE, DMA_BIDIRECTIONAL);\r\nif(hostdata->tag_negotiated & (1<<reselection_id)) {\r\nresume_offset = hostdata->pScript + Ent_GetReselectionWithTag;\r\n} else {\r\nresume_offset = hostdata->pScript + Ent_GetReselectionData;\r\n}\r\n} else if(dsps == A_COMPLETED_SELECTION_AS_TARGET) {\r\nDEBUG((" SELECTION COMPLETED\n"));\r\n} else if((dsps & 0xfffff0f0) == A_MSG_IN) {\r\nresume_offset = process_message(host, hostdata, SCp,\r\ndsp, dsps);\r\n} else if((dsps & 0xfffff000) == 0) {\r\n__u8 i = (dsps & 0xf0) >> 4, j = (dsps & 0xf00) >> 8;\r\nprintk(KERN_ERR "scsi%d: (%d:%d), unhandled script condition %s %s at %04x\n",\r\nhost->host_no, pun, lun, NCR_700_condition[i],\r\nNCR_700_phase[j], dsp - hostdata->pScript);\r\nif(SCp != NULL) {\r\nstruct scatterlist *sg;\r\nscsi_print_command(SCp);\r\nscsi_for_each_sg(SCp, sg, scsi_sg_count(SCp) + 1, i) {\r\nprintk(KERN_INFO " SG[%d].length = %d, move_insn=%08x, addr %08x\n", i, sg->length, ((struct NCR_700_command_slot *)SCp->host_scribble)->SG[i].ins, ((struct NCR_700_command_slot *)SCp->host_scribble)->SG[i].pAddr);\r\n}\r\n}\r\nNCR_700_internal_bus_reset(host);\r\n} else if((dsps & 0xfffff000) == A_DEBUG_INTERRUPT) {\r\nprintk(KERN_NOTICE "scsi%d (%d:%d) DEBUG INTERRUPT %d AT %08x[%04x], continuing\n",\r\nhost->host_no, pun, lun, dsps & 0xfff, dsp, dsp - hostdata->pScript);\r\nresume_offset = dsp;\r\n} else {\r\nprintk(KERN_ERR "scsi%d: (%d:%d), unidentified script interrupt 0x%x at %04x\n",\r\nhost->host_no, pun, lun, dsps, dsp - hostdata->pScript);\r\nNCR_700_internal_bus_reset(host);\r\n}\r\nreturn resume_offset;\r\n}\r\nSTATIC inline __u32\r\nprocess_selection(struct Scsi_Host *host, __u32 dsp)\r\n{\r\n__u8 id = 0;\r\nint count = 0;\r\n__u32 resume_offset = 0;\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\nstruct scsi_cmnd *SCp = hostdata->cmd;\r\n__u8 sbcl;\r\nfor(count = 0; count < 5; count++) {\r\nid = NCR_700_readb(host, hostdata->chip710 ?\r\nCTEST9_REG : SFBR_REG);\r\nid &= ~(1<<host->this_id);\r\nif(id != 0)\r\nbreak;\r\nudelay(5);\r\n}\r\nsbcl = NCR_700_readb(host, SBCL_REG);\r\nif((sbcl & SBCL_IO) == 0) {\r\nid = 0xff;\r\n} else {\r\nhostdata->reselection_id = id = bitmap_to_number(id);\r\nDEBUG(("scsi%d: Reselected by %d\n",\r\nhost->host_no, id));\r\n}\r\nif(hostdata->state == NCR_700_HOST_BUSY && SCp != NULL) {\r\nstruct NCR_700_command_slot *slot =\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\nDEBUG((" ID %d WARNING: RESELECTION OF BUSY HOST, saving cmd %p, slot %p, addr %x [%04x], resume %x!\n", id, hostdata->cmd, slot, dsp, dsp - hostdata->pScript, resume_offset));\r\nswitch(dsp - hostdata->pScript) {\r\ncase Ent_Disconnect1:\r\ncase Ent_Disconnect2:\r\nsave_for_reselection(hostdata, SCp, Ent_Disconnect2 + hostdata->pScript);\r\nbreak;\r\ncase Ent_Disconnect3:\r\ncase Ent_Disconnect4:\r\nsave_for_reselection(hostdata, SCp, Ent_Disconnect4 + hostdata->pScript);\r\nbreak;\r\ncase Ent_Disconnect5:\r\ncase Ent_Disconnect6:\r\nsave_for_reselection(hostdata, SCp, Ent_Disconnect6 + hostdata->pScript);\r\nbreak;\r\ncase Ent_Disconnect7:\r\ncase Ent_Disconnect8:\r\nsave_for_reselection(hostdata, SCp, Ent_Disconnect8 + hostdata->pScript);\r\nbreak;\r\ncase Ent_Finish1:\r\ncase Ent_Finish2:\r\nprocess_script_interrupt(A_GOOD_STATUS_AFTER_STATUS, dsp, SCp, host, hostdata);\r\nbreak;\r\ndefault:\r\nslot->state = NCR_700_SLOT_QUEUED;\r\nbreak;\r\n}\r\n}\r\nhostdata->state = NCR_700_HOST_BUSY;\r\nhostdata->cmd = NULL;\r\nhostdata->msgin[1] = 0;\r\ndma_cache_sync(hostdata->dev, hostdata->msgin, MSG_ARRAY_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif(id == 0xff) {\r\nresume_offset = hostdata->pScript + Ent_SelectedAsTarget;\r\n} else if(hostdata->tag_negotiated & (1<<id)) {\r\nresume_offset = hostdata->pScript + Ent_GetReselectionWithTag;\r\n} else {\r\nresume_offset = hostdata->pScript + Ent_GetReselectionData;\r\n}\r\nreturn resume_offset;\r\n}\r\nstatic inline void\r\nNCR_700_clear_fifo(struct Scsi_Host *host) {\r\nconst struct NCR_700_Host_Parameters *hostdata\r\n= (struct NCR_700_Host_Parameters *)host->hostdata[0];\r\nif(hostdata->chip710) {\r\nNCR_700_writeb(CLR_FIFO_710, host, CTEST8_REG);\r\n} else {\r\nNCR_700_writeb(CLR_FIFO, host, DFIFO_REG);\r\n}\r\n}\r\nstatic inline void\r\nNCR_700_flush_fifo(struct Scsi_Host *host) {\r\nconst struct NCR_700_Host_Parameters *hostdata\r\n= (struct NCR_700_Host_Parameters *)host->hostdata[0];\r\nif(hostdata->chip710) {\r\nNCR_700_writeb(FLUSH_DMA_FIFO_710, host, CTEST8_REG);\r\nudelay(10);\r\nNCR_700_writeb(0, host, CTEST8_REG);\r\n} else {\r\nNCR_700_writeb(FLUSH_DMA_FIFO, host, DFIFO_REG);\r\nudelay(10);\r\nNCR_700_writeb(0, host, DFIFO_REG);\r\n}\r\n}\r\nSTATIC int\r\nNCR_700_start_command(struct scsi_cmnd *SCp)\r\n{\r\nstruct NCR_700_command_slot *slot =\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\r\n__u16 count = 1;\r\nu8 lun = SCp->device->lun;\r\nif(hostdata->state != NCR_700_HOST_FREE) {\r\nslot->state = NCR_700_SLOT_QUEUED;\r\nDEBUG(("scsi%d: host busy, queueing command %p, slot %p\n",\r\nSCp->device->host->host_no, slot->cmnd, slot));\r\nreturn 0;\r\n}\r\nhostdata->state = NCR_700_HOST_BUSY;\r\nhostdata->cmd = SCp;\r\nslot->state = NCR_700_SLOT_BUSY;\r\nhostdata->msgout[0] = NCR_700_identify((SCp->cmnd[0] != REQUEST_SENSE &&\r\nslot->flags != NCR_700_FLAG_AUTOSENSE),\r\nlun);\r\nif(SCp->cmnd[0] == INQUIRY || SCp->cmnd[0] == REQUEST_SENSE ||\r\nslot->flags == NCR_700_FLAG_AUTOSENSE) {\r\nNCR_700_clear_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\r\n}\r\nif((hostdata->tag_negotiated & (1<<scmd_id(SCp)))\r\n&& (slot->tag != SCSI_NO_TAG && SCp->cmnd[0] != REQUEST_SENSE &&\r\nslot->flags != NCR_700_FLAG_AUTOSENSE)) {\r\ncount += spi_populate_tag_msg(&hostdata->msgout[count], SCp);\r\n}\r\nif(hostdata->fast &&\r\nNCR_700_is_flag_clear(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC)) {\r\ncount += spi_populate_sync_msg(&hostdata->msgout[count],\r\nspi_period(SCp->device->sdev_target),\r\nspi_offset(SCp->device->sdev_target));\r\nNCR_700_set_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\r\n}\r\nscript_patch_16(hostdata->dev, hostdata->script, MessageCount, count);\r\nscript_patch_ID(hostdata->dev, hostdata->script,\r\nDevice_ID, 1<<scmd_id(SCp));\r\nscript_patch_32_abs(hostdata->dev, hostdata->script, CommandAddress,\r\nslot->pCmd);\r\nscript_patch_16(hostdata->dev, hostdata->script, CommandCount,\r\nSCp->cmd_len);\r\nscript_patch_32_abs(hostdata->dev, hostdata->script,\r\nSGScriptStartAddress, to32bit(&slot->pSG[0].ins));\r\nNCR_700_clear_fifo(SCp->device->host);\r\nif(slot->resume_offset == 0)\r\nslot->resume_offset = hostdata->pScript;\r\ndma_cache_sync(hostdata->dev, hostdata->msgout, count, DMA_TO_DEVICE);\r\ndma_cache_sync(hostdata->dev, hostdata->msgin, MSG_ARRAY_SIZE,\r\nDMA_FROM_DEVICE);\r\ndma_cache_sync(hostdata->dev, SCp->cmnd, SCp->cmd_len, DMA_TO_DEVICE);\r\ndma_cache_sync(hostdata->dev, hostdata->status, 1, DMA_FROM_DEVICE);\r\nNCR_700_writeb(NCR_700_get_SXFER(SCp->device),\r\nSCp->device->host, SXFER_REG);\r\nNCR_700_writel(slot->temp, SCp->device->host, TEMP_REG);\r\nNCR_700_writel(slot->resume_offset, SCp->device->host, DSP_REG);\r\nreturn 1;\r\n}\r\nirqreturn_t\r\nNCR_700_intr(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *host = (struct Scsi_Host *)dev_id;\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)host->hostdata[0];\r\n__u8 istat;\r\n__u32 resume_offset = 0;\r\n__u8 pun = 0xff, lun = 0xff;\r\nunsigned long flags;\r\nint handled = 0;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nif((istat = NCR_700_readb(host, ISTAT_REG))\r\n& (SCSI_INT_PENDING | DMA_INT_PENDING)) {\r\n__u32 dsps;\r\n__u8 sstat0 = 0, dstat = 0;\r\n__u32 dsp;\r\nstruct scsi_cmnd *SCp = hostdata->cmd;\r\nenum NCR_700_Host_State state;\r\nhandled = 1;\r\nstate = hostdata->state;\r\nSCp = hostdata->cmd;\r\nif(istat & SCSI_INT_PENDING) {\r\nudelay(10);\r\nsstat0 = NCR_700_readb(host, SSTAT0_REG);\r\n}\r\nif(istat & DMA_INT_PENDING) {\r\nudelay(10);\r\ndstat = NCR_700_readb(host, DSTAT_REG);\r\n}\r\ndsps = NCR_700_readl(host, DSPS_REG);\r\ndsp = NCR_700_readl(host, DSP_REG);\r\nDEBUG(("scsi%d: istat %02x sstat0 %02x dstat %02x dsp %04x[%08x] dsps 0x%x\n",\r\nhost->host_no, istat, sstat0, dstat,\r\n(dsp - (__u32)(hostdata->pScript))/4,\r\ndsp, dsps));\r\nif(SCp != NULL) {\r\npun = SCp->device->id;\r\nlun = SCp->device->lun;\r\n}\r\nif(sstat0 & SCSI_RESET_DETECTED) {\r\nstruct scsi_device *SDp;\r\nint i;\r\nhostdata->state = NCR_700_HOST_BUSY;\r\nprintk(KERN_ERR "scsi%d: Bus Reset detected, executing command %p, slot %p, dsp %08x[%04x]\n",\r\nhost->host_no, SCp, SCp == NULL ? NULL : SCp->host_scribble, dsp, dsp - hostdata->pScript);\r\nscsi_report_bus_reset(host, 0);\r\n__shost_for_each_device(SDp, host)\r\nNCR_700_clear_flag(SDp, ~0);\r\nfor(i = 0; i < NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\r\nstruct scsi_cmnd *SCp;\r\nstruct NCR_700_command_slot *slot =\r\n&hostdata->slots[i];\r\nif(slot->state == NCR_700_SLOT_FREE)\r\ncontinue;\r\nSCp = slot->cmnd;\r\nprintk(KERN_ERR " failing command because of reset, slot %p, cmnd %p\n",\r\nslot, SCp);\r\nfree_slot(slot, hostdata);\r\nSCp->host_scribble = NULL;\r\nNCR_700_set_depth(SCp->device, 0);\r\nSCp->result = DID_RESET << 16;\r\nSCp->scsi_done(SCp);\r\n}\r\nmdelay(25);\r\nNCR_700_chip_setup(host);\r\nhostdata->state = NCR_700_HOST_FREE;\r\nhostdata->cmd = NULL;\r\nif(hostdata->eh_complete != NULL)\r\ncomplete(hostdata->eh_complete);\r\ngoto out_unlock;\r\n} else if(sstat0 & SELECTION_TIMEOUT) {\r\nDEBUG(("scsi%d: (%d:%d) selection timeout\n",\r\nhost->host_no, pun, lun));\r\nNCR_700_scsi_done(hostdata, SCp, DID_NO_CONNECT<<16);\r\n} else if(sstat0 & PHASE_MISMATCH) {\r\nstruct NCR_700_command_slot *slot = (SCp == NULL) ? NULL :\r\n(struct NCR_700_command_slot *)SCp->host_scribble;\r\nif(dsp == Ent_SendMessage + 8 + hostdata->pScript) {\r\n#ifdef NCR_700_DEBUG\r\n__u32 temp = NCR_700_readl(host, TEMP_REG);\r\nint count = (hostdata->script[Ent_SendMessage/4] & 0xffffff) - ((NCR_700_readl(host, DBC_REG) & 0xffffff) + NCR_700_data_residual(host));\r\nprintk("scsi%d (%d:%d) PHASE MISMATCH IN SEND MESSAGE %d remain, return %p[%04x], phase %s\n", host->host_no, pun, lun, count, (void *)temp, temp - hostdata->pScript, sbcl_to_string(NCR_700_readb(host, SBCL_REG)));\r\n#endif\r\nresume_offset = hostdata->pScript + Ent_SendMessagePhaseMismatch;\r\n} else if(dsp >= to32bit(&slot->pSG[0].ins) &&\r\ndsp <= to32bit(&slot->pSG[NCR_700_SG_SEGMENTS].ins)) {\r\nint data_transfer = NCR_700_readl(host, DBC_REG) & 0xffffff;\r\nint SGcount = (dsp - to32bit(&slot->pSG[0].ins))/sizeof(struct NCR_700_SG_List);\r\nint residual = NCR_700_data_residual(host);\r\nint i;\r\n#ifdef NCR_700_DEBUG\r\n__u32 naddr = NCR_700_readl(host, DNAD_REG);\r\nprintk("scsi%d: (%d:%d) Expected phase mismatch in slot->SG[%d], transferred 0x%x\n",\r\nhost->host_no, pun, lun,\r\nSGcount, data_transfer);\r\nscsi_print_command(SCp);\r\nif(residual) {\r\nprintk("scsi%d: (%d:%d) Expected phase mismatch in slot->SG[%d], transferred 0x%x, residual %d\n",\r\nhost->host_no, pun, lun,\r\nSGcount, data_transfer, residual);\r\n}\r\n#endif\r\ndata_transfer += residual;\r\nif(data_transfer != 0) {\r\nint count;\r\n__u32 pAddr;\r\nSGcount--;\r\ncount = (bS_to_cpu(slot->SG[SGcount].ins) & 0x00ffffff);\r\nDEBUG(("DATA TRANSFER MISMATCH, count = %d, transferred %d\n", count, count-data_transfer));\r\nslot->SG[SGcount].ins &= bS_to_host(0xff000000);\r\nslot->SG[SGcount].ins |= bS_to_host(data_transfer);\r\npAddr = bS_to_cpu(slot->SG[SGcount].pAddr);\r\npAddr += (count - data_transfer);\r\n#ifdef NCR_700_DEBUG\r\nif(pAddr != naddr) {\r\nprintk("scsi%d (%d:%d) transfer mismatch pAddr=%lx, naddr=%lx, data_transfer=%d, residual=%d\n", host->host_no, pun, lun, (unsigned long)pAddr, (unsigned long)naddr, data_transfer, residual);\r\n}\r\n#endif\r\nslot->SG[SGcount].pAddr = bS_to_host(pAddr);\r\n}\r\nfor(i=0; i<SGcount; i++) {\r\nslot->SG[i].ins = bS_to_host(SCRIPT_NOP);\r\nslot->SG[i].pAddr = 0;\r\n}\r\ndma_cache_sync(hostdata->dev, slot->SG, sizeof(slot->SG), DMA_TO_DEVICE);\r\nresume_offset = hostdata->pScript + Ent_MsgInDuringData;\r\nNCR_700_flush_fifo(host);\r\n} else {\r\n__u8 sbcl = NCR_700_readb(host, SBCL_REG);\r\nprintk(KERN_ERR "scsi%d: (%d:%d) phase mismatch at %04x, phase %s\n",\r\nhost->host_no, pun, lun, dsp - hostdata->pScript, sbcl_to_string(sbcl));\r\nNCR_700_internal_bus_reset(host);\r\n}\r\n} else if(sstat0 & SCSI_GROSS_ERROR) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) GROSS ERROR\n",\r\nhost->host_no, pun, lun);\r\nNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\r\n} else if(sstat0 & PARITY_ERROR) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) PARITY ERROR\n",\r\nhost->host_no, pun, lun);\r\nNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\r\n} else if(dstat & SCRIPT_INT_RECEIVED) {\r\nDEBUG(("scsi%d: (%d:%d) ====>SCRIPT INTERRUPT<====\n",\r\nhost->host_no, pun, lun));\r\nresume_offset = process_script_interrupt(dsps, dsp, SCp, host, hostdata);\r\n} else if(dstat & (ILGL_INST_DETECTED)) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) Illegal Instruction detected at 0x%08x[0x%x]!!!\n"\r\n" Please email James.Bottomley@HansenPartnership.com with the details\n",\r\nhost->host_no, pun, lun,\r\ndsp, dsp - hostdata->pScript);\r\nNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\r\n} else if(dstat & (WATCH_DOG_INTERRUPT|ABORTED)) {\r\nprintk(KERN_ERR "scsi%d: (%d:%d) serious DMA problem, dstat=%02x\n",\r\nhost->host_no, pun, lun, dstat);\r\nNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\r\n}\r\nif(sstat0 & SELECTED) {\r\nresume_offset = process_selection(host, dsp);\r\n}\r\n}\r\nif(resume_offset) {\r\nif(hostdata->state != NCR_700_HOST_BUSY) {\r\nprintk(KERN_ERR "scsi%d: Driver error: resume at 0x%08x [0x%04x] with non busy host!\n",\r\nhost->host_no, resume_offset, resume_offset - hostdata->pScript);\r\nhostdata->state = NCR_700_HOST_BUSY;\r\n}\r\nDEBUG(("Attempting to resume at %x\n", resume_offset));\r\nNCR_700_clear_fifo(host);\r\nNCR_700_writel(resume_offset, host, DSP_REG);\r\n}\r\nif(hostdata->state == NCR_700_HOST_FREE) {\r\nint i;\r\nfor(i = 0; i < NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\r\nint j = (i + hostdata->saved_slot_position)\r\n% NCR_700_COMMAND_SLOTS_PER_HOST;\r\nif(hostdata->slots[j].state != NCR_700_SLOT_QUEUED)\r\ncontinue;\r\nif(NCR_700_start_command(hostdata->slots[j].cmnd)) {\r\nDEBUG(("scsi%d: Issuing saved command slot %p, cmd %p\t\n",\r\nhost->host_no, &hostdata->slots[j],\r\nhostdata->slots[j].cmnd));\r\nhostdata->saved_slot_position = j + 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int\r\nNCR_700_queuecommand_lck(struct scsi_cmnd *SCp, void (*done)(struct scsi_cmnd *))\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\r\n__u32 move_ins;\r\nenum dma_data_direction direction;\r\nstruct NCR_700_command_slot *slot;\r\nif(hostdata->command_slot_count >= NCR_700_COMMAND_SLOTS_PER_HOST) {\r\nprintk(KERN_WARNING "scsi%d: Command depth has gone over queue depth\n", SCp->device->host->host_no);\r\nreturn 1;\r\n}\r\nif(NCR_700_get_depth(SCp->device) != 0\r\n&& (!(hostdata->tag_negotiated & (1<<scmd_id(SCp)))\r\n|| !(SCp->flags & SCMD_TAGGED))) {\r\nCDEBUG(KERN_ERR, SCp, "has non zero depth %d\n",\r\nNCR_700_get_depth(SCp->device));\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nif(NCR_700_get_depth(SCp->device) >= SCp->device->queue_depth) {\r\nCDEBUG(KERN_ERR, SCp, "has max tag depth %d\n",\r\nNCR_700_get_depth(SCp->device));\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nNCR_700_set_depth(SCp->device, NCR_700_get_depth(SCp->device) + 1);\r\nslot = find_empty_slot(hostdata);\r\nslot->cmnd = SCp;\r\nSCp->scsi_done = done;\r\nSCp->host_scribble = (unsigned char *)slot;\r\nSCp->SCp.ptr = NULL;\r\nSCp->SCp.buffer = NULL;\r\n#ifdef NCR_700_DEBUG\r\nprintk("53c700: scsi%d, command ", SCp->device->host->host_no);\r\nscsi_print_command(SCp);\r\n#endif\r\nif ((SCp->flags & SCMD_TAGGED)\r\n&& (hostdata->tag_negotiated &(1<<scmd_id(SCp))) == 0\r\n&& NCR_700_get_tag_neg_state(SCp->device) == NCR_700_START_TAG_NEGOTIATION) {\r\nscmd_printk(KERN_ERR, SCp, "Enabling Tag Command Queuing\n");\r\nhostdata->tag_negotiated |= (1<<scmd_id(SCp));\r\nNCR_700_set_tag_neg_state(SCp->device, NCR_700_DURING_TAG_NEGOTIATION);\r\n}\r\nif (!(SCp->flags & SCMD_TAGGED)\r\n&& (hostdata->tag_negotiated &(1<<scmd_id(SCp)))) {\r\nscmd_printk(KERN_INFO, SCp, "Disabling Tag Command Queuing\n");\r\nhostdata->tag_negotiated &= ~(1<<scmd_id(SCp));\r\n}\r\nif ((hostdata->tag_negotiated & (1<<scmd_id(SCp))) &&\r\nSCp->device->simple_tags) {\r\nslot->tag = SCp->request->tag;\r\nCDEBUG(KERN_DEBUG, SCp, "sending out tag %d, slot %p\n",\r\nslot->tag, slot);\r\n} else {\r\nstruct NCR_700_Device_Parameters *p = SCp->device->hostdata;\r\nslot->tag = SCSI_NO_TAG;\r\np->current_cmnd = SCp;\r\n}\r\nif(!scsi_sg_count(SCp) && !scsi_bufflen(SCp) &&\r\nSCp->sc_data_direction != DMA_NONE) {\r\n#ifdef NCR_700_DEBUG\r\nprintk("53c700: Command");\r\nscsi_print_command(SCp);\r\nprintk("Has wrong data direction %d\n", SCp->sc_data_direction);\r\n#endif\r\nSCp->sc_data_direction = DMA_NONE;\r\n}\r\nswitch (SCp->cmnd[0]) {\r\ncase REQUEST_SENSE:\r\nSCp->cmnd[6] = 0;\r\ndefault:\r\nswitch(SCp->sc_data_direction) {\r\ncase DMA_BIDIRECTIONAL:\r\ndefault:\r\nprintk(KERN_ERR "53c700: Unknown command for data direction ");\r\nscsi_print_command(SCp);\r\nmove_ins = 0;\r\nbreak;\r\ncase DMA_NONE:\r\nmove_ins = 0;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\nmove_ins = SCRIPT_MOVE_DATA_IN;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nmove_ins = SCRIPT_MOVE_DATA_OUT;\r\nbreak;\r\n}\r\n}\r\ndirection = SCp->sc_data_direction;\r\nif(move_ins != 0) {\r\nint i;\r\nint sg_count;\r\ndma_addr_t vPtr = 0;\r\nstruct scatterlist *sg;\r\n__u32 count = 0;\r\nsg_count = scsi_dma_map(SCp);\r\nBUG_ON(sg_count < 0);\r\nscsi_for_each_sg(SCp, sg, sg_count, i) {\r\nvPtr = sg_dma_address(sg);\r\ncount = sg_dma_len(sg);\r\nslot->SG[i].ins = bS_to_host(move_ins | count);\r\nDEBUG((" scatter block %d: move %d[%08x] from 0x%lx\n",\r\ni, count, slot->SG[i].ins, (unsigned long)vPtr));\r\nslot->SG[i].pAddr = bS_to_host(vPtr);\r\n}\r\nslot->SG[i].ins = bS_to_host(SCRIPT_RETURN);\r\nslot->SG[i].pAddr = 0;\r\ndma_cache_sync(hostdata->dev, slot->SG, sizeof(slot->SG), DMA_TO_DEVICE);\r\nDEBUG((" SETTING %p to %x\n",\r\n(&slot->pSG[i].ins),\r\nslot->SG[i].ins));\r\n}\r\nslot->resume_offset = 0;\r\nslot->pCmd = dma_map_single(hostdata->dev, SCp->cmnd,\r\nMAX_COMMAND_SIZE, DMA_TO_DEVICE);\r\nNCR_700_start_command(SCp);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nNCR_700_bus_reset(struct scsi_cmnd * SCp)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(complete);\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\r\nscmd_printk(KERN_INFO, SCp,\r\n"New error handler wants BUS reset, cmd %p\n\t", SCp);\r\nscsi_print_command(SCp);\r\nspin_lock_irq(SCp->device->host->host_lock);\r\nwhile (hostdata->eh_complete != NULL) {\r\nspin_unlock_irq(SCp->device->host->host_lock);\r\nmsleep_interruptible(100);\r\nspin_lock_irq(SCp->device->host->host_lock);\r\n}\r\nhostdata->eh_complete = &complete;\r\nNCR_700_internal_bus_reset(SCp->device->host);\r\nspin_unlock_irq(SCp->device->host->host_lock);\r\nwait_for_completion(&complete);\r\nspin_lock_irq(SCp->device->host->host_lock);\r\nhostdata->eh_complete = NULL;\r\nif(hostdata->fast)\r\nspi_schedule_dv_device(SCp->device);\r\nspin_unlock_irq(SCp->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nSTATIC int\r\nNCR_700_host_reset(struct scsi_cmnd * SCp)\r\n{\r\nscmd_printk(KERN_INFO, SCp, "New error handler wants HOST reset\n\t");\r\nscsi_print_command(SCp);\r\nspin_lock_irq(SCp->device->host->host_lock);\r\nNCR_700_internal_bus_reset(SCp->device->host);\r\nNCR_700_chip_reset(SCp->device->host);\r\nspin_unlock_irq(SCp->device->host->host_lock);\r\nreturn SUCCESS;\r\n}\r\nSTATIC void\r\nNCR_700_set_period(struct scsi_target *STp, int period)\r\n{\r\nstruct Scsi_Host *SHp = dev_to_shost(STp->dev.parent);\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SHp->hostdata[0];\r\nif(!hostdata->fast)\r\nreturn;\r\nif(period < hostdata->min_period)\r\nperiod = hostdata->min_period;\r\nspi_period(STp) = period;\r\nspi_flags(STp) &= ~(NCR_700_DEV_NEGOTIATED_SYNC |\r\nNCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\r\nspi_flags(STp) |= NCR_700_DEV_PRINT_SYNC_NEGOTIATION;\r\n}\r\nSTATIC void\r\nNCR_700_set_offset(struct scsi_target *STp, int offset)\r\n{\r\nstruct Scsi_Host *SHp = dev_to_shost(STp->dev.parent);\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SHp->hostdata[0];\r\nint max_offset = hostdata->chip710\r\n? NCR_710_MAX_OFFSET : NCR_700_MAX_OFFSET;\r\nif(!hostdata->fast)\r\nreturn;\r\nif(offset > max_offset)\r\noffset = max_offset;\r\nif(spi_offset(STp) == 0 && (spi_period(STp) < hostdata->min_period ||\r\nspi_period(STp) > 0xff))\r\nspi_period(STp) = hostdata->min_period;\r\nspi_offset(STp) = offset;\r\nspi_flags(STp) &= ~(NCR_700_DEV_NEGOTIATED_SYNC |\r\nNCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\r\nspi_flags(STp) |= NCR_700_DEV_PRINT_SYNC_NEGOTIATION;\r\n}\r\nSTATIC int\r\nNCR_700_slave_alloc(struct scsi_device *SDp)\r\n{\r\nSDp->hostdata = kzalloc(sizeof(struct NCR_700_Device_Parameters),\r\nGFP_KERNEL);\r\nif (!SDp->hostdata)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nNCR_700_slave_configure(struct scsi_device *SDp)\r\n{\r\nstruct NCR_700_Host_Parameters *hostdata =\r\n(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];\r\nif(SDp->tagged_supported) {\r\nscsi_change_queue_depth(SDp, NCR_700_DEFAULT_TAGS);\r\nNCR_700_set_tag_neg_state(SDp, NCR_700_START_TAG_NEGOTIATION);\r\n}\r\nif(hostdata->fast) {\r\nif (!spi_initial_dv(SDp->sdev_target))\r\nspi_dv_device(SDp);\r\n} else {\r\nspi_offset(SDp->sdev_target) = 0;\r\nspi_period(SDp->sdev_target) = 0;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC void\r\nNCR_700_slave_destroy(struct scsi_device *SDp)\r\n{\r\nkfree(SDp->hostdata);\r\nSDp->hostdata = NULL;\r\n}\r\nstatic int\r\nNCR_700_change_queue_depth(struct scsi_device *SDp, int depth)\r\n{\r\nif (depth > NCR_700_MAX_TAGS)\r\ndepth = NCR_700_MAX_TAGS;\r\nreturn scsi_change_queue_depth(SDp, depth);\r\n}\r\nstatic ssize_t\r\nNCR_700_show_active_tags(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *SDp = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%d\n", NCR_700_get_depth(SDp));\r\n}\r\nstatic int __init NCR_700_init(void)\r\n{\r\nNCR_700_transport_template = spi_attach_transport(&NCR_700_transport_functions);\r\nif(!NCR_700_transport_template)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit NCR_700_exit(void)\r\n{\r\nspi_release_transport(NCR_700_transport_template);\r\n}
