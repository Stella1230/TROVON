int\r\nxfs_refcount_lookup_le(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nint *stat)\r\n{\r\ntrace_xfs_refcount_lookup(cur->bc_mp, cur->bc_private.a.agno, bno,\r\nXFS_LOOKUP_LE);\r\ncur->bc_rec.rc.rc_startblock = bno;\r\ncur->bc_rec.rc.rc_blockcount = 0;\r\nreturn xfs_btree_lookup(cur, XFS_LOOKUP_LE, stat);\r\n}\r\nint\r\nxfs_refcount_lookup_ge(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t bno,\r\nint *stat)\r\n{\r\ntrace_xfs_refcount_lookup(cur->bc_mp, cur->bc_private.a.agno, bno,\r\nXFS_LOOKUP_GE);\r\ncur->bc_rec.rc.rc_startblock = bno;\r\ncur->bc_rec.rc.rc_blockcount = 0;\r\nreturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\r\n}\r\nstatic inline void\r\nxfs_refcount_btrec_to_irec(\r\nunion xfs_btree_rec *rec,\r\nstruct xfs_refcount_irec *irec)\r\n{\r\nirec->rc_startblock = be32_to_cpu(rec->refc.rc_startblock);\r\nirec->rc_blockcount = be32_to_cpu(rec->refc.rc_blockcount);\r\nirec->rc_refcount = be32_to_cpu(rec->refc.rc_refcount);\r\n}\r\nint\r\nxfs_refcount_get_rec(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *irec,\r\nint *stat)\r\n{\r\nunion xfs_btree_rec *rec;\r\nint error;\r\nerror = xfs_btree_get_rec(cur, &rec, stat);\r\nif (!error && *stat == 1) {\r\nxfs_refcount_btrec_to_irec(rec, irec);\r\ntrace_xfs_refcount_get(cur->bc_mp, cur->bc_private.a.agno,\r\nirec);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_update(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *irec)\r\n{\r\nunion xfs_btree_rec rec;\r\nint error;\r\ntrace_xfs_refcount_update(cur->bc_mp, cur->bc_private.a.agno, irec);\r\nrec.refc.rc_startblock = cpu_to_be32(irec->rc_startblock);\r\nrec.refc.rc_blockcount = cpu_to_be32(irec->rc_blockcount);\r\nrec.refc.rc_refcount = cpu_to_be32(irec->rc_refcount);\r\nerror = xfs_btree_update(cur, &rec);\r\nif (error)\r\ntrace_xfs_refcount_update_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_insert(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *irec,\r\nint *i)\r\n{\r\nint error;\r\ntrace_xfs_refcount_insert(cur->bc_mp, cur->bc_private.a.agno, irec);\r\ncur->bc_rec.rc.rc_startblock = irec->rc_startblock;\r\ncur->bc_rec.rc.rc_blockcount = irec->rc_blockcount;\r\ncur->bc_rec.rc.rc_refcount = irec->rc_refcount;\r\nerror = xfs_btree_insert(cur, i);\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, *i == 1, out_error);\r\nout_error:\r\nif (error)\r\ntrace_xfs_refcount_insert_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_delete(\r\nstruct xfs_btree_cur *cur,\r\nint *i)\r\n{\r\nstruct xfs_refcount_irec irec;\r\nint found_rec;\r\nint error;\r\nerror = xfs_refcount_get_rec(cur, &irec, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\ntrace_xfs_refcount_delete(cur->bc_mp, cur->bc_private.a.agno, &irec);\r\nerror = xfs_btree_delete(cur, i);\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, *i == 1, out_error);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_refcount_lookup_ge(cur, irec.rc_startblock, &found_rec);\r\nout_error:\r\nif (error)\r\ntrace_xfs_refcount_delete_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nstatic inline xfs_agblock_t\r\nxfs_refc_next(\r\nstruct xfs_refcount_irec *rc)\r\n{\r\nreturn rc->rc_startblock + rc->rc_blockcount;\r\n}\r\nSTATIC int\r\nxfs_refcount_split_extent(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t agbno,\r\nbool *shape_changed)\r\n{\r\nstruct xfs_refcount_irec rcext, tmp;\r\nint found_rec;\r\nint error;\r\n*shape_changed = false;\r\nerror = xfs_refcount_lookup_le(cur, agbno, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (!found_rec)\r\nreturn 0;\r\nerror = xfs_refcount_get_rec(cur, &rcext, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nif (rcext.rc_startblock == agbno || xfs_refc_next(&rcext) <= agbno)\r\nreturn 0;\r\n*shape_changed = true;\r\ntrace_xfs_refcount_split_extent(cur->bc_mp, cur->bc_private.a.agno,\r\n&rcext, agbno);\r\ntmp = rcext;\r\ntmp.rc_startblock = agbno;\r\ntmp.rc_blockcount -= (agbno - rcext.rc_startblock);\r\nerror = xfs_refcount_update(cur, &tmp);\r\nif (error)\r\ngoto out_error;\r\ntmp = rcext;\r\ntmp.rc_blockcount = agbno - rcext.rc_startblock;\r\nerror = xfs_refcount_insert(cur, &tmp, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_split_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_merge_center_extents(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *left,\r\nstruct xfs_refcount_irec *center,\r\nstruct xfs_refcount_irec *right,\r\nunsigned long long extlen,\r\nxfs_agblock_t *agbno,\r\nxfs_extlen_t *aglen)\r\n{\r\nint error;\r\nint found_rec;\r\ntrace_xfs_refcount_merge_center_extents(cur->bc_mp,\r\ncur->bc_private.a.agno, left, center, right);\r\nerror = xfs_refcount_lookup_ge(cur, center->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nif (center->rc_refcount > 1) {\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\n}\r\nerror = xfs_refcount_lookup_le(cur, left->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nleft->rc_blockcount = extlen;\r\nerror = xfs_refcount_update(cur, left);\r\nif (error)\r\ngoto out_error;\r\n*aglen = 0;\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_merge_center_extents_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_merge_left_extent(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *left,\r\nstruct xfs_refcount_irec *cleft,\r\nxfs_agblock_t *agbno,\r\nxfs_extlen_t *aglen)\r\n{\r\nint error;\r\nint found_rec;\r\ntrace_xfs_refcount_merge_left_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, left, cleft);\r\nif (cleft->rc_refcount > 1) {\r\nerror = xfs_refcount_lookup_le(cur, cleft->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\n}\r\nerror = xfs_refcount_lookup_le(cur, left->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nleft->rc_blockcount += cleft->rc_blockcount;\r\nerror = xfs_refcount_update(cur, left);\r\nif (error)\r\ngoto out_error;\r\n*agbno += cleft->rc_blockcount;\r\n*aglen -= cleft->rc_blockcount;\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_merge_left_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_merge_right_extent(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *right,\r\nstruct xfs_refcount_irec *cright,\r\nxfs_agblock_t *agbno,\r\nxfs_extlen_t *aglen)\r\n{\r\nint error;\r\nint found_rec;\r\ntrace_xfs_refcount_merge_right_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, cright, right);\r\nif (cright->rc_refcount > 1) {\r\nerror = xfs_refcount_lookup_le(cur, cright->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\n}\r\nerror = xfs_refcount_lookup_le(cur, right->rc_startblock,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nright->rc_startblock -= cright->rc_blockcount;\r\nright->rc_blockcount += cright->rc_blockcount;\r\nerror = xfs_refcount_update(cur, right);\r\nif (error)\r\ngoto out_error;\r\n*aglen -= cright->rc_blockcount;\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_merge_right_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_find_left_extents(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *left,\r\nstruct xfs_refcount_irec *cleft,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nint flags)\r\n{\r\nstruct xfs_refcount_irec tmp;\r\nint error;\r\nint found_rec;\r\nleft->rc_startblock = cleft->rc_startblock = NULLAGBLOCK;\r\nerror = xfs_refcount_lookup_le(cur, agbno - 1, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (!found_rec)\r\nreturn 0;\r\nerror = xfs_refcount_get_rec(cur, &tmp, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nif (xfs_refc_next(&tmp) != agbno)\r\nreturn 0;\r\nif ((flags & XFS_FIND_RCEXT_SHARED) && tmp.rc_refcount < 2)\r\nreturn 0;\r\nif ((flags & XFS_FIND_RCEXT_COW) && tmp.rc_refcount > 1)\r\nreturn 0;\r\n*left = tmp;\r\nerror = xfs_btree_increment(cur, 0, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (found_rec) {\r\nerror = xfs_refcount_get_rec(cur, &tmp, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\nif (tmp.rc_startblock == agbno)\r\n*cleft = tmp;\r\nelse {\r\ncleft->rc_startblock = agbno;\r\ncleft->rc_blockcount = min(aglen,\r\ntmp.rc_startblock - agbno);\r\ncleft->rc_refcount = 1;\r\n}\r\n} else {\r\ncleft->rc_startblock = agbno;\r\ncleft->rc_blockcount = aglen;\r\ncleft->rc_refcount = 1;\r\n}\r\ntrace_xfs_refcount_find_left_extent(cur->bc_mp, cur->bc_private.a.agno,\r\nleft, cleft, agbno);\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_find_left_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_find_right_extents(\r\nstruct xfs_btree_cur *cur,\r\nstruct xfs_refcount_irec *right,\r\nstruct xfs_refcount_irec *cright,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nint flags)\r\n{\r\nstruct xfs_refcount_irec tmp;\r\nint error;\r\nint found_rec;\r\nright->rc_startblock = cright->rc_startblock = NULLAGBLOCK;\r\nerror = xfs_refcount_lookup_ge(cur, agbno + aglen, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (!found_rec)\r\nreturn 0;\r\nerror = xfs_refcount_get_rec(cur, &tmp, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1, out_error);\r\nif (tmp.rc_startblock != agbno + aglen)\r\nreturn 0;\r\nif ((flags & XFS_FIND_RCEXT_SHARED) && tmp.rc_refcount < 2)\r\nreturn 0;\r\nif ((flags & XFS_FIND_RCEXT_COW) && tmp.rc_refcount > 1)\r\nreturn 0;\r\n*right = tmp;\r\nerror = xfs_btree_decrement(cur, 0, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (found_rec) {\r\nerror = xfs_refcount_get_rec(cur, &tmp, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, found_rec == 1,\r\nout_error);\r\nif (xfs_refc_next(&tmp) == agbno + aglen)\r\n*cright = tmp;\r\nelse {\r\ncright->rc_startblock = max(agbno, xfs_refc_next(&tmp));\r\ncright->rc_blockcount = right->rc_startblock -\r\ncright->rc_startblock;\r\ncright->rc_refcount = 1;\r\n}\r\n} else {\r\ncright->rc_startblock = agbno;\r\ncright->rc_blockcount = aglen;\r\ncright->rc_refcount = 1;\r\n}\r\ntrace_xfs_refcount_find_right_extent(cur->bc_mp, cur->bc_private.a.agno,\r\ncright, right, agbno + aglen);\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_find_right_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nstatic inline bool\r\nxfs_refc_valid(\r\nstruct xfs_refcount_irec *rc)\r\n{\r\nreturn rc->rc_startblock != NULLAGBLOCK;\r\n}\r\nSTATIC int\r\nxfs_refcount_merge_extents(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t *agbno,\r\nxfs_extlen_t *aglen,\r\nenum xfs_refc_adjust_op adjust,\r\nint flags,\r\nbool *shape_changed)\r\n{\r\nstruct xfs_refcount_irec left = {0}, cleft = {0};\r\nstruct xfs_refcount_irec cright = {0}, right = {0};\r\nint error;\r\nunsigned long long ulen;\r\nbool cequal;\r\n*shape_changed = false;\r\nerror = xfs_refcount_find_left_extents(cur, &left, &cleft, *agbno,\r\n*aglen, flags);\r\nif (error)\r\nreturn error;\r\nerror = xfs_refcount_find_right_extents(cur, &right, &cright, *agbno,\r\n*aglen, flags);\r\nif (error)\r\nreturn error;\r\nif (!xfs_refc_valid(&left) && !xfs_refc_valid(&right))\r\nreturn 0;\r\ncequal = (cleft.rc_startblock == cright.rc_startblock) &&\r\n(cleft.rc_blockcount == cright.rc_blockcount);\r\nulen = (unsigned long long)left.rc_blockcount + cleft.rc_blockcount +\r\nright.rc_blockcount;\r\nif (xfs_refc_valid(&left) && xfs_refc_valid(&right) &&\r\nxfs_refc_valid(&cleft) && xfs_refc_valid(&cright) && cequal &&\r\nleft.rc_refcount == cleft.rc_refcount + adjust &&\r\nright.rc_refcount == cleft.rc_refcount + adjust &&\r\nulen < MAXREFCEXTLEN) {\r\n*shape_changed = true;\r\nreturn xfs_refcount_merge_center_extents(cur, &left, &cleft,\r\n&right, ulen, agbno, aglen);\r\n}\r\nulen = (unsigned long long)left.rc_blockcount + cleft.rc_blockcount;\r\nif (xfs_refc_valid(&left) && xfs_refc_valid(&cleft) &&\r\nleft.rc_refcount == cleft.rc_refcount + adjust &&\r\nulen < MAXREFCEXTLEN) {\r\n*shape_changed = true;\r\nerror = xfs_refcount_merge_left_extent(cur, &left, &cleft,\r\nagbno, aglen);\r\nif (error)\r\nreturn error;\r\nif (cequal)\r\nreturn 0;\r\n}\r\nulen = (unsigned long long)right.rc_blockcount + cright.rc_blockcount;\r\nif (xfs_refc_valid(&right) && xfs_refc_valid(&cright) &&\r\nright.rc_refcount == cright.rc_refcount + adjust &&\r\nulen < MAXREFCEXTLEN) {\r\n*shape_changed = true;\r\nreturn xfs_refcount_merge_right_extent(cur, &right, &cright,\r\nagbno, aglen);\r\n}\r\nreturn error;\r\n}\r\nstatic bool\r\nxfs_refcount_still_have_space(\r\nstruct xfs_btree_cur *cur)\r\n{\r\nunsigned long overhead;\r\noverhead = cur->bc_private.a.priv.refc.shape_changes *\r\nxfs_allocfree_log_count(cur->bc_mp, 1);\r\noverhead *= cur->bc_mp->m_sb.sb_blocksize;\r\nif (cur->bc_private.a.priv.refc.nr_ops > 2 &&\r\nXFS_TEST_ERROR(false, cur->bc_mp,\r\nXFS_ERRTAG_REFCOUNT_CONTINUE_UPDATE,\r\nXFS_RANDOM_REFCOUNT_CONTINUE_UPDATE))\r\nreturn false;\r\nif (cur->bc_private.a.priv.refc.nr_ops == 0)\r\nreturn true;\r\nelse if (overhead > cur->bc_tp->t_log_res)\r\nreturn false;\r\nreturn cur->bc_tp->t_log_res - overhead >\r\ncur->bc_private.a.priv.refc.nr_ops * 32;\r\n}\r\nSTATIC int\r\nxfs_refcount_adjust_extents(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t *agbno,\r\nxfs_extlen_t *aglen,\r\nenum xfs_refc_adjust_op adj,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_refcount_irec ext, tmp;\r\nint error;\r\nint found_rec, found_tmp;\r\nxfs_fsblock_t fsbno;\r\nif (*aglen == 0)\r\nreturn 0;\r\nerror = xfs_refcount_lookup_ge(cur, *agbno, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nwhile (*aglen > 0 && xfs_refcount_still_have_space(cur)) {\r\nerror = xfs_refcount_get_rec(cur, &ext, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (!found_rec) {\r\next.rc_startblock = cur->bc_mp->m_sb.sb_agblocks;\r\next.rc_blockcount = 0;\r\next.rc_refcount = 0;\r\n}\r\nif (ext.rc_startblock != *agbno) {\r\ntmp.rc_startblock = *agbno;\r\ntmp.rc_blockcount = min(*aglen,\r\next.rc_startblock - *agbno);\r\ntmp.rc_refcount = 1 + adj;\r\ntrace_xfs_refcount_modify_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, &tmp);\r\nif (tmp.rc_refcount) {\r\nerror = xfs_refcount_insert(cur, &tmp,\r\n&found_tmp);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\nfound_tmp == 1, out_error);\r\ncur->bc_private.a.priv.refc.nr_ops++;\r\n} else {\r\nfsbno = XFS_AGB_TO_FSB(cur->bc_mp,\r\ncur->bc_private.a.agno,\r\ntmp.rc_startblock);\r\nxfs_bmap_add_free(cur->bc_mp, dfops, fsbno,\r\ntmp.rc_blockcount, oinfo);\r\n}\r\n(*agbno) += tmp.rc_blockcount;\r\n(*aglen) -= tmp.rc_blockcount;\r\nerror = xfs_refcount_lookup_ge(cur, *agbno,\r\n&found_rec);\r\nif (error)\r\ngoto out_error;\r\n}\r\nif (*aglen == 0 || !xfs_refcount_still_have_space(cur))\r\nbreak;\r\nif (ext.rc_refcount == MAXREFCOUNT)\r\ngoto skip;\r\next.rc_refcount += adj;\r\ntrace_xfs_refcount_modify_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, &ext);\r\nif (ext.rc_refcount > 1) {\r\nerror = xfs_refcount_update(cur, &ext);\r\nif (error)\r\ngoto out_error;\r\ncur->bc_private.a.priv.refc.nr_ops++;\r\n} else if (ext.rc_refcount == 1) {\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\nfound_rec == 1, out_error);\r\ncur->bc_private.a.priv.refc.nr_ops++;\r\ngoto advloop;\r\n} else {\r\nfsbno = XFS_AGB_TO_FSB(cur->bc_mp,\r\ncur->bc_private.a.agno,\r\next.rc_startblock);\r\nxfs_bmap_add_free(cur->bc_mp, dfops, fsbno,\r\next.rc_blockcount, oinfo);\r\n}\r\nskip:\r\nerror = xfs_btree_increment(cur, 0, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nadvloop:\r\n(*agbno) += ext.rc_blockcount;\r\n(*aglen) -= ext.rc_blockcount;\r\n}\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_modify_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_adjust(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nxfs_agblock_t *new_agbno,\r\nxfs_extlen_t *new_aglen,\r\nenum xfs_refc_adjust_op adj,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nbool shape_changed;\r\nint shape_changes = 0;\r\nint error;\r\n*new_agbno = agbno;\r\n*new_aglen = aglen;\r\nif (adj == XFS_REFCOUNT_ADJUST_INCREASE)\r\ntrace_xfs_refcount_increase(cur->bc_mp, cur->bc_private.a.agno,\r\nagbno, aglen);\r\nelse\r\ntrace_xfs_refcount_decrease(cur->bc_mp, cur->bc_private.a.agno,\r\nagbno, aglen);\r\nerror = xfs_refcount_split_extent(cur, agbno, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nif (shape_changed)\r\nshape_changes++;\r\nerror = xfs_refcount_split_extent(cur, agbno + aglen, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nif (shape_changed)\r\nshape_changes++;\r\nerror = xfs_refcount_merge_extents(cur, new_agbno, new_aglen, adj,\r\nXFS_FIND_RCEXT_SHARED, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nif (shape_changed)\r\nshape_changes++;\r\nif (shape_changes)\r\ncur->bc_private.a.priv.refc.shape_changes++;\r\nerror = xfs_refcount_adjust_extents(cur, new_agbno, new_aglen,\r\nadj, dfops, oinfo);\r\nif (error)\r\ngoto out_error;\r\nreturn 0;\r\nout_error:\r\ntrace_xfs_refcount_adjust_error(cur->bc_mp, cur->bc_private.a.agno,\r\nerror, _RET_IP_);\r\nreturn error;\r\n}\r\nvoid\r\nxfs_refcount_finish_one_cleanup(\r\nstruct xfs_trans *tp,\r\nstruct xfs_btree_cur *rcur,\r\nint error)\r\n{\r\nstruct xfs_buf *agbp;\r\nif (rcur == NULL)\r\nreturn;\r\nagbp = rcur->bc_private.a.agbp;\r\nxfs_btree_del_cursor(rcur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\r\nif (error)\r\nxfs_trans_brelse(tp, agbp);\r\n}\r\nint\r\nxfs_refcount_finish_one(\r\nstruct xfs_trans *tp,\r\nstruct xfs_defer_ops *dfops,\r\nenum xfs_refcount_intent_type type,\r\nxfs_fsblock_t startblock,\r\nxfs_extlen_t blockcount,\r\nxfs_fsblock_t *new_fsb,\r\nxfs_extlen_t *new_len,\r\nstruct xfs_btree_cur **pcur)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nstruct xfs_btree_cur *rcur;\r\nstruct xfs_buf *agbp = NULL;\r\nint error = 0;\r\nxfs_agnumber_t agno;\r\nxfs_agblock_t bno;\r\nxfs_agblock_t new_agbno;\r\nunsigned long nr_ops = 0;\r\nint shape_changes = 0;\r\nagno = XFS_FSB_TO_AGNO(mp, startblock);\r\nASSERT(agno != NULLAGNUMBER);\r\nbno = XFS_FSB_TO_AGBNO(mp, startblock);\r\ntrace_xfs_refcount_deferred(mp, XFS_FSB_TO_AGNO(mp, startblock),\r\ntype, XFS_FSB_TO_AGBNO(mp, startblock),\r\nblockcount);\r\nif (XFS_TEST_ERROR(false, mp,\r\nXFS_ERRTAG_REFCOUNT_FINISH_ONE,\r\nXFS_RANDOM_REFCOUNT_FINISH_ONE))\r\nreturn -EIO;\r\nrcur = *pcur;\r\nif (rcur != NULL && rcur->bc_private.a.agno != agno) {\r\nnr_ops = rcur->bc_private.a.priv.refc.nr_ops;\r\nshape_changes = rcur->bc_private.a.priv.refc.shape_changes;\r\nxfs_refcount_finish_one_cleanup(tp, rcur, 0);\r\nrcur = NULL;\r\n*pcur = NULL;\r\n}\r\nif (rcur == NULL) {\r\nerror = xfs_alloc_read_agf(tp->t_mountp, tp, agno,\r\nXFS_ALLOC_FLAG_FREEING, &agbp);\r\nif (error)\r\nreturn error;\r\nif (!agbp)\r\nreturn -EFSCORRUPTED;\r\nrcur = xfs_refcountbt_init_cursor(mp, tp, agbp, agno, dfops);\r\nif (!rcur) {\r\nerror = -ENOMEM;\r\ngoto out_cur;\r\n}\r\nrcur->bc_private.a.priv.refc.nr_ops = nr_ops;\r\nrcur->bc_private.a.priv.refc.shape_changes = shape_changes;\r\n}\r\n*pcur = rcur;\r\nswitch (type) {\r\ncase XFS_REFCOUNT_INCREASE:\r\nerror = xfs_refcount_adjust(rcur, bno, blockcount, &new_agbno,\r\nnew_len, XFS_REFCOUNT_ADJUST_INCREASE, dfops, NULL);\r\n*new_fsb = XFS_AGB_TO_FSB(mp, agno, new_agbno);\r\nbreak;\r\ncase XFS_REFCOUNT_DECREASE:\r\nerror = xfs_refcount_adjust(rcur, bno, blockcount, &new_agbno,\r\nnew_len, XFS_REFCOUNT_ADJUST_DECREASE, dfops, NULL);\r\n*new_fsb = XFS_AGB_TO_FSB(mp, agno, new_agbno);\r\nbreak;\r\ncase XFS_REFCOUNT_ALLOC_COW:\r\n*new_fsb = startblock + blockcount;\r\n*new_len = 0;\r\nerror = __xfs_refcount_cow_alloc(rcur, bno, blockcount, dfops);\r\nbreak;\r\ncase XFS_REFCOUNT_FREE_COW:\r\n*new_fsb = startblock + blockcount;\r\n*new_len = 0;\r\nerror = __xfs_refcount_cow_free(rcur, bno, blockcount, dfops);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\nerror = -EFSCORRUPTED;\r\n}\r\nif (!error && *new_len > 0)\r\ntrace_xfs_refcount_finish_one_leftover(mp, agno, type,\r\nbno, blockcount, new_agbno, *new_len);\r\nreturn error;\r\nout_cur:\r\nxfs_trans_brelse(tp, agbp);\r\nreturn error;\r\n}\r\nstatic int\r\n__xfs_refcount_add(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nenum xfs_refcount_intent_type type,\r\nxfs_fsblock_t startblock,\r\nxfs_extlen_t blockcount)\r\n{\r\nstruct xfs_refcount_intent *ri;\r\ntrace_xfs_refcount_defer(mp, XFS_FSB_TO_AGNO(mp, startblock),\r\ntype, XFS_FSB_TO_AGBNO(mp, startblock),\r\nblockcount);\r\nri = kmem_alloc(sizeof(struct xfs_refcount_intent),\r\nKM_SLEEP | KM_NOFS);\r\nINIT_LIST_HEAD(&ri->ri_list);\r\nri->ri_type = type;\r\nri->ri_startblock = startblock;\r\nri->ri_blockcount = blockcount;\r\nxfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_REFCOUNT, &ri->ri_list);\r\nreturn 0;\r\n}\r\nint\r\nxfs_refcount_increase_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_bmbt_irec *PREV)\r\n{\r\nif (!xfs_sb_version_hasreflink(&mp->m_sb))\r\nreturn 0;\r\nreturn __xfs_refcount_add(mp, dfops, XFS_REFCOUNT_INCREASE,\r\nPREV->br_startblock, PREV->br_blockcount);\r\n}\r\nint\r\nxfs_refcount_decrease_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_bmbt_irec *PREV)\r\n{\r\nif (!xfs_sb_version_hasreflink(&mp->m_sb))\r\nreturn 0;\r\nreturn __xfs_refcount_add(mp, dfops, XFS_REFCOUNT_DECREASE,\r\nPREV->br_startblock, PREV->br_blockcount);\r\n}\r\nint\r\nxfs_refcount_find_shared(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nxfs_agblock_t *fbno,\r\nxfs_extlen_t *flen,\r\nbool find_end_of_shared)\r\n{\r\nstruct xfs_refcount_irec tmp;\r\nint i;\r\nint have;\r\nint error;\r\ntrace_xfs_refcount_find_shared(cur->bc_mp, cur->bc_private.a.agno,\r\nagbno, aglen);\r\n*fbno = NULLAGBLOCK;\r\n*flen = 0;\r\nerror = xfs_refcount_lookup_le(cur, agbno, &have);\r\nif (error)\r\ngoto out_error;\r\nif (!have) {\r\nerror = xfs_btree_increment(cur, 0, &have);\r\nif (error)\r\ngoto out_error;\r\nif (!have)\r\ngoto done;\r\n}\r\nerror = xfs_refcount_get_rec(cur, &tmp, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, i == 1, out_error);\r\nif (tmp.rc_startblock + tmp.rc_blockcount <= agbno) {\r\nerror = xfs_btree_increment(cur, 0, &have);\r\nif (error)\r\ngoto out_error;\r\nif (!have)\r\ngoto done;\r\nerror = xfs_refcount_get_rec(cur, &tmp, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, i == 1, out_error);\r\n}\r\nif (tmp.rc_startblock >= agbno + aglen)\r\ngoto done;\r\nif (tmp.rc_startblock < agbno) {\r\ntmp.rc_blockcount -= (agbno - tmp.rc_startblock);\r\ntmp.rc_startblock = agbno;\r\n}\r\n*fbno = tmp.rc_startblock;\r\n*flen = min(tmp.rc_blockcount, agbno + aglen - *fbno);\r\nif (!find_end_of_shared)\r\ngoto done;\r\nwhile (*fbno + *flen < agbno + aglen) {\r\nerror = xfs_btree_increment(cur, 0, &have);\r\nif (error)\r\ngoto out_error;\r\nif (!have)\r\nbreak;\r\nerror = xfs_refcount_get_rec(cur, &tmp, &i);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp, i == 1, out_error);\r\nif (tmp.rc_startblock >= agbno + aglen ||\r\ntmp.rc_startblock != *fbno + *flen)\r\nbreak;\r\n*flen = min(*flen + tmp.rc_blockcount, agbno + aglen - *fbno);\r\n}\r\ndone:\r\ntrace_xfs_refcount_find_shared_result(cur->bc_mp,\r\ncur->bc_private.a.agno, *fbno, *flen);\r\nout_error:\r\nif (error)\r\ntrace_xfs_refcount_find_shared_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_adjust_cow_extents(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nenum xfs_refc_adjust_op adj,\r\nstruct xfs_defer_ops *dfops,\r\nstruct xfs_owner_info *oinfo)\r\n{\r\nstruct xfs_refcount_irec ext, tmp;\r\nint error;\r\nint found_rec, found_tmp;\r\nif (aglen == 0)\r\nreturn 0;\r\nerror = xfs_refcount_lookup_ge(cur, agbno, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_refcount_get_rec(cur, &ext, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nif (!found_rec) {\r\next.rc_startblock = cur->bc_mp->m_sb.sb_agblocks +\r\nXFS_REFC_COW_START;\r\next.rc_blockcount = 0;\r\next.rc_refcount = 0;\r\n}\r\nswitch (adj) {\r\ncase XFS_REFCOUNT_ADJUST_COW_ALLOC:\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\next.rc_startblock >= agbno + aglen, out_error);\r\ntmp.rc_startblock = agbno;\r\ntmp.rc_blockcount = aglen;\r\ntmp.rc_refcount = 1;\r\ntrace_xfs_refcount_modify_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, &tmp);\r\nerror = xfs_refcount_insert(cur, &tmp,\r\n&found_tmp);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\nfound_tmp == 1, out_error);\r\nbreak;\r\ncase XFS_REFCOUNT_ADJUST_COW_FREE:\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\next.rc_startblock == agbno, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\next.rc_blockcount == aglen, out_error);\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\next.rc_refcount == 1, out_error);\r\next.rc_refcount = 0;\r\ntrace_xfs_refcount_modify_extent(cur->bc_mp,\r\ncur->bc_private.a.agno, &ext);\r\nerror = xfs_refcount_delete(cur, &found_rec);\r\nif (error)\r\ngoto out_error;\r\nXFS_WANT_CORRUPTED_GOTO(cur->bc_mp,\r\nfound_rec == 1, out_error);\r\nbreak;\r\ndefault:\r\nASSERT(0);\r\n}\r\nreturn error;\r\nout_error:\r\ntrace_xfs_refcount_modify_extent_error(cur->bc_mp,\r\ncur->bc_private.a.agno, error, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_refcount_adjust_cow(\r\nstruct xfs_btree_cur *cur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nenum xfs_refc_adjust_op adj,\r\nstruct xfs_defer_ops *dfops)\r\n{\r\nbool shape_changed;\r\nint error;\r\nagbno += XFS_REFC_COW_START;\r\nerror = xfs_refcount_split_extent(cur, agbno, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_refcount_split_extent(cur, agbno + aglen, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_refcount_merge_extents(cur, &agbno, &aglen, adj,\r\nXFS_FIND_RCEXT_COW, &shape_changed);\r\nif (error)\r\ngoto out_error;\r\nerror = xfs_refcount_adjust_cow_extents(cur, agbno, aglen, adj,\r\ndfops, NULL);\r\nif (error)\r\ngoto out_error;\r\nreturn 0;\r\nout_error:\r\ntrace_xfs_refcount_adjust_cow_error(cur->bc_mp, cur->bc_private.a.agno,\r\nerror, _RET_IP_);\r\nreturn error;\r\n}\r\nSTATIC int\r\n__xfs_refcount_cow_alloc(\r\nstruct xfs_btree_cur *rcur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nstruct xfs_defer_ops *dfops)\r\n{\r\nint error;\r\ntrace_xfs_refcount_cow_increase(rcur->bc_mp, rcur->bc_private.a.agno,\r\nagbno, aglen);\r\nerror = xfs_refcount_adjust_cow(rcur, agbno, aglen,\r\nXFS_REFCOUNT_ADJUST_COW_ALLOC, dfops);\r\nif (error)\r\nreturn error;\r\nif (xfs_sb_version_hasrmapbt(&rcur->bc_mp->m_sb)) {\r\nerror = xfs_rmap_alloc_extent(rcur->bc_mp, dfops,\r\nrcur->bc_private.a.agno,\r\nagbno, aglen, XFS_RMAP_OWN_COW);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\n__xfs_refcount_cow_free(\r\nstruct xfs_btree_cur *rcur,\r\nxfs_agblock_t agbno,\r\nxfs_extlen_t aglen,\r\nstruct xfs_defer_ops *dfops)\r\n{\r\nint error;\r\ntrace_xfs_refcount_cow_decrease(rcur->bc_mp, rcur->bc_private.a.agno,\r\nagbno, aglen);\r\nerror = xfs_refcount_adjust_cow(rcur, agbno, aglen,\r\nXFS_REFCOUNT_ADJUST_COW_FREE, dfops);\r\nif (error)\r\nreturn error;\r\nif (xfs_sb_version_hasrmapbt(&rcur->bc_mp->m_sb)) {\r\nerror = xfs_rmap_free_extent(rcur->bc_mp, dfops,\r\nrcur->bc_private.a.agno,\r\nagbno, aglen, XFS_RMAP_OWN_COW);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_refcount_alloc_cow_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nxfs_fsblock_t fsb,\r\nxfs_extlen_t len)\r\n{\r\nif (!xfs_sb_version_hasreflink(&mp->m_sb))\r\nreturn 0;\r\nreturn __xfs_refcount_add(mp, dfops, XFS_REFCOUNT_ALLOC_COW,\r\nfsb, len);\r\n}\r\nint\r\nxfs_refcount_free_cow_extent(\r\nstruct xfs_mount *mp,\r\nstruct xfs_defer_ops *dfops,\r\nxfs_fsblock_t fsb,\r\nxfs_extlen_t len)\r\n{\r\nif (!xfs_sb_version_hasreflink(&mp->m_sb))\r\nreturn 0;\r\nreturn __xfs_refcount_add(mp, dfops, XFS_REFCOUNT_FREE_COW,\r\nfsb, len);\r\n}\r\nSTATIC int\r\nxfs_refcount_recover_extent(\r\nstruct xfs_btree_cur *cur,\r\nunion xfs_btree_rec *rec,\r\nvoid *priv)\r\n{\r\nstruct list_head *debris = priv;\r\nstruct xfs_refcount_recovery *rr;\r\nif (be32_to_cpu(rec->refc.rc_refcount) != 1)\r\nreturn -EFSCORRUPTED;\r\nrr = kmem_alloc(sizeof(struct xfs_refcount_recovery), KM_SLEEP);\r\nxfs_refcount_btrec_to_irec(rec, &rr->rr_rrec);\r\nlist_add_tail(&rr->rr_list, debris);\r\nreturn 0;\r\n}\r\nint\r\nxfs_refcount_recover_cow_leftovers(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno)\r\n{\r\nstruct xfs_trans *tp;\r\nstruct xfs_btree_cur *cur;\r\nstruct xfs_buf *agbp;\r\nstruct xfs_refcount_recovery *rr, *n;\r\nstruct list_head debris;\r\nunion xfs_btree_irec low;\r\nunion xfs_btree_irec high;\r\nstruct xfs_defer_ops dfops;\r\nxfs_fsblock_t fsb;\r\nxfs_agblock_t agbno;\r\nint error;\r\nif (mp->m_sb.sb_agblocks >= XFS_REFC_COW_START)\r\nreturn -EOPNOTSUPP;\r\nerror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\r\nif (error)\r\nreturn error;\r\ncur = xfs_refcountbt_init_cursor(mp, NULL, agbp, agno, NULL);\r\nINIT_LIST_HEAD(&debris);\r\nmemset(&low, 0, sizeof(low));\r\nmemset(&high, 0, sizeof(high));\r\nlow.rc.rc_startblock = XFS_REFC_COW_START;\r\nhigh.rc.rc_startblock = -1U;\r\nerror = xfs_btree_query_range(cur, &low, &high,\r\nxfs_refcount_recover_extent, &debris);\r\nif (error)\r\ngoto out_cursor;\r\nxfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\r\nxfs_buf_relse(agbp);\r\nlist_for_each_entry(rr, &debris, rr_list) {\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0, 0, &tp);\r\nif (error)\r\ngoto out_free;\r\ntrace_xfs_refcount_recover_extent(mp, agno, &rr->rr_rrec);\r\nxfs_defer_init(&dfops, &fsb);\r\nagbno = rr->rr_rrec.rc_startblock - XFS_REFC_COW_START;\r\nfsb = XFS_AGB_TO_FSB(mp, agno, agbno);\r\nerror = xfs_refcount_free_cow_extent(mp, &dfops, fsb,\r\nrr->rr_rrec.rc_blockcount);\r\nif (error)\r\ngoto out_defer;\r\nxfs_bmap_add_free(mp, &dfops, fsb,\r\nrr->rr_rrec.rc_blockcount, NULL);\r\nerror = xfs_defer_finish(&tp, &dfops, NULL);\r\nif (error)\r\ngoto out_defer;\r\nerror = xfs_trans_commit(tp);\r\nif (error)\r\ngoto out_free;\r\n}\r\nout_free:\r\nlist_for_each_entry_safe(rr, n, &debris, rr_list) {\r\nlist_del(&rr->rr_list);\r\nkmem_free(rr);\r\n}\r\nreturn error;\r\nout_cursor:\r\nxfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\r\nxfs_buf_relse(agbp);\r\ngoto out_free;\r\nout_defer:\r\nxfs_defer_cancel(&dfops);\r\nxfs_trans_cancel(tp);\r\ngoto out_free;\r\n}
