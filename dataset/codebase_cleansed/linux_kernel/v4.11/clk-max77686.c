static struct max77686_clk_init_data *to_max77686_clk_init_data(\r\nstruct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct max77686_clk_init_data, hw);\r\n}\r\nstatic int max77686_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\r\nreturn regmap_update_bits(max77686->regmap, max77686->clk_info->clk_reg,\r\nmax77686->clk_info->clk_enable_mask,\r\nmax77686->clk_info->clk_enable_mask);\r\n}\r\nstatic void max77686_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\r\nregmap_update_bits(max77686->regmap, max77686->clk_info->clk_reg,\r\nmax77686->clk_info->clk_enable_mask,\r\n~max77686->clk_info->clk_enable_mask);\r\n}\r\nstatic int max77686_clk_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk_init_data *max77686 = to_max77686_clk_init_data(hw);\r\nint ret;\r\nu32 val;\r\nret = regmap_read(max77686->regmap, max77686->clk_info->clk_reg, &val);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn val & max77686->clk_info->clk_enable_mask;\r\n}\r\nstatic unsigned long max77686_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn 32768;\r\n}\r\nstatic struct clk_hw *\r\nof_clk_max77686_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct max77686_clk_driver_data *drv_data = data;\r\nunsigned int idx = clkspec->args[0];\r\nif (idx >= drv_data->num_clks) {\r\npr_err("%s: invalid index %u\n", __func__, idx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn &drv_data->max_clk_data[idx].hw;\r\n}\r\nstatic int max77686_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device *parent = dev->parent;\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct max77686_clk_driver_data *drv_data;\r\nconst struct max77686_hw_clk_info *hw_clks;\r\nstruct regmap *regmap;\r\nint i, ret, num_clks;\r\ndrv_data = devm_kzalloc(dev, sizeof(*drv_data), GFP_KERNEL);\r\nif (!drv_data)\r\nreturn -ENOMEM;\r\nregmap = dev_get_regmap(parent, NULL);\r\nif (!regmap) {\r\ndev_err(dev, "Failed to get rtc regmap\n");\r\nreturn -ENODEV;\r\n}\r\ndrv_data->chip = id->driver_data;\r\nswitch (drv_data->chip) {\r\ncase CHIP_MAX77686:\r\nnum_clks = MAX77686_CLKS_NUM;\r\nhw_clks = max77686_hw_clks_info;\r\nbreak;\r\ncase CHIP_MAX77802:\r\nnum_clks = MAX77802_CLKS_NUM;\r\nhw_clks = max77802_hw_clks_info;\r\nbreak;\r\ncase CHIP_MAX77620:\r\nnum_clks = MAX77620_CLKS_NUM;\r\nhw_clks = max77620_hw_clks_info;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unknown Chip ID\n");\r\nreturn -EINVAL;\r\n}\r\ndrv_data->num_clks = num_clks;\r\ndrv_data->max_clk_data = devm_kcalloc(dev, num_clks,\r\nsizeof(*drv_data->max_clk_data),\r\nGFP_KERNEL);\r\nif (!drv_data->max_clk_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_clks; i++) {\r\nstruct max77686_clk_init_data *max_clk_data;\r\nconst char *clk_name;\r\nmax_clk_data = &drv_data->max_clk_data[i];\r\nmax_clk_data->regmap = regmap;\r\nmax_clk_data->clk_info = &hw_clks[i];\r\nmax_clk_data->clk_idata.flags = hw_clks[i].flags;\r\nmax_clk_data->clk_idata.ops = &max77686_clk_ops;\r\nif (parent->of_node &&\r\n!of_property_read_string_index(parent->of_node,\r\n"clock-output-names",\r\ni, &clk_name))\r\nmax_clk_data->clk_idata.name = clk_name;\r\nelse\r\nmax_clk_data->clk_idata.name = hw_clks[i].name;\r\nmax_clk_data->hw.init = &max_clk_data->clk_idata;\r\nret = devm_clk_hw_register(dev, &max_clk_data->hw);\r\nif (ret) {\r\ndev_err(dev, "Failed to clock register: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_hw_register_clkdev(&max_clk_data->hw,\r\nmax_clk_data->clk_idata.name, NULL);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to clkdev register: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (parent->of_node) {\r\nret = of_clk_add_hw_provider(parent->of_node, of_clk_max77686_get,\r\ndrv_data);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to register OF clock provider: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (drv_data->chip == CHIP_MAX77802) {\r\nret = regmap_update_bits(regmap, MAX77802_REG_32KHZ,\r\n1 << MAX77802_CLOCK_LOW_JITTER_SHIFT,\r\n1 << MAX77802_CLOCK_LOW_JITTER_SHIFT);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to config low-jitter: %d\n", ret);\r\ngoto remove_of_clk_provider;\r\n}\r\n}\r\nreturn 0;\r\nremove_of_clk_provider:\r\nif (parent->of_node)\r\nof_clk_del_provider(parent->of_node);\r\nreturn ret;\r\n}\r\nstatic int max77686_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct device *parent = pdev->dev.parent;\r\nif (parent->of_node)\r\nof_clk_del_provider(parent->of_node);\r\nreturn 0;\r\n}
