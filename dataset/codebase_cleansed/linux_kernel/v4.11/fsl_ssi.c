static bool fsl_ssi_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CCSR_SSI_SACCEN:\r\ncase CCSR_SSI_SACCDIS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool fsl_ssi_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CCSR_SSI_STX0:\r\ncase CCSR_SSI_STX1:\r\ncase CCSR_SSI_SRX0:\r\ncase CCSR_SSI_SRX1:\r\ncase CCSR_SSI_SISR:\r\ncase CCSR_SSI_SFCSR:\r\ncase CCSR_SSI_SACNT:\r\ncase CCSR_SSI_SACADD:\r\ncase CCSR_SSI_SACDAT:\r\ncase CCSR_SSI_SATAG:\r\ncase CCSR_SSI_SACCST:\r\ncase CCSR_SSI_SOR:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_ssi_precious_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CCSR_SSI_SRX0:\r\ncase CCSR_SSI_SRX1:\r\ncase CCSR_SSI_SISR:\r\ncase CCSR_SSI_SACADD:\r\ncase CCSR_SSI_SACDAT:\r\ncase CCSR_SSI_SATAG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool fsl_ssi_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CCSR_SSI_SRX0:\r\ncase CCSR_SSI_SRX1:\r\ncase CCSR_SSI_SACCST:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool fsl_ssi_is_ac97(struct fsl_ssi_private *ssi_private)\r\n{\r\nreturn (ssi_private->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\r\nSND_SOC_DAIFMT_AC97;\r\n}\r\nstatic bool fsl_ssi_is_i2s_master(struct fsl_ssi_private *ssi_private)\r\n{\r\nreturn (ssi_private->dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) ==\r\nSND_SOC_DAIFMT_CBS_CFS;\r\n}\r\nstatic bool fsl_ssi_is_i2s_cbm_cfs(struct fsl_ssi_private *ssi_private)\r\n{\r\nreturn (ssi_private->dai_fmt & SND_SOC_DAIFMT_MASTER_MASK) ==\r\nSND_SOC_DAIFMT_CBM_CFS;\r\n}\r\nstatic irqreturn_t fsl_ssi_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_id;\r\nstruct regmap *regs = ssi_private->regs;\r\n__be32 sisr;\r\n__be32 sisr2;\r\nregmap_read(regs, CCSR_SSI_SISR, &sisr);\r\nsisr2 = sisr & ssi_private->soc->sisr_write_mask;\r\nif (sisr2)\r\nregmap_write(regs, CCSR_SSI_SISR, sisr2);\r\nfsl_ssi_dbg_isr(&ssi_private->dbg_stats, sisr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fsl_ssi_rxtx_config(struct fsl_ssi_private *ssi_private,\r\nbool enable)\r\n{\r\nstruct regmap *regs = ssi_private->regs;\r\nstruct fsl_ssi_rxtx_reg_val *vals = &ssi_private->rxtx_reg_val;\r\nif (enable) {\r\nregmap_update_bits(regs, CCSR_SSI_SIER,\r\nvals->rx.sier | vals->tx.sier,\r\nvals->rx.sier | vals->tx.sier);\r\nregmap_update_bits(regs, CCSR_SSI_SRCR,\r\nvals->rx.srcr | vals->tx.srcr,\r\nvals->rx.srcr | vals->tx.srcr);\r\nregmap_update_bits(regs, CCSR_SSI_STCR,\r\nvals->rx.stcr | vals->tx.stcr,\r\nvals->rx.stcr | vals->tx.stcr);\r\n} else {\r\nregmap_update_bits(regs, CCSR_SSI_SRCR,\r\nvals->rx.srcr | vals->tx.srcr, 0);\r\nregmap_update_bits(regs, CCSR_SSI_STCR,\r\nvals->rx.stcr | vals->tx.stcr, 0);\r\nregmap_update_bits(regs, CCSR_SSI_SIER,\r\nvals->rx.sier | vals->tx.sier, 0);\r\n}\r\n}\r\nstatic void fsl_ssi_fifo_clear(struct fsl_ssi_private *ssi_private,\r\nbool is_rx)\r\n{\r\nif (is_rx) {\r\nregmap_update_bits(ssi_private->regs, CCSR_SSI_SOR,\r\nCCSR_SSI_SOR_RX_CLR, CCSR_SSI_SOR_RX_CLR);\r\n} else {\r\nregmap_update_bits(ssi_private->regs, CCSR_SSI_SOR,\r\nCCSR_SSI_SOR_TX_CLR, CCSR_SSI_SOR_TX_CLR);\r\n}\r\n}\r\nstatic void fsl_ssi_config(struct fsl_ssi_private *ssi_private, bool enable,\r\nstruct fsl_ssi_reg_val *vals)\r\n{\r\nstruct regmap *regs = ssi_private->regs;\r\nstruct fsl_ssi_reg_val *avals;\r\nint nr_active_streams;\r\nu32 scr_val;\r\nint keep_active;\r\nregmap_read(regs, CCSR_SSI_SCR, &scr_val);\r\nnr_active_streams = !!(scr_val & CCSR_SSI_SCR_TE) +\r\n!!(scr_val & CCSR_SSI_SCR_RE);\r\nif (nr_active_streams - 1 > 0)\r\nkeep_active = 1;\r\nelse\r\nkeep_active = 0;\r\nif (&ssi_private->rxtx_reg_val.rx == vals)\r\navals = &ssi_private->rxtx_reg_val.tx;\r\nelse\r\navals = &ssi_private->rxtx_reg_val.rx;\r\nif (!enable) {\r\nu32 scr = fsl_ssi_disable_val(vals->scr, avals->scr,\r\nkeep_active);\r\nregmap_update_bits(regs, CCSR_SSI_SCR, scr, 0);\r\n}\r\nif (ssi_private->soc->offline_config) {\r\nif ((enable && !nr_active_streams) ||\r\n(!enable && !keep_active))\r\nfsl_ssi_rxtx_config(ssi_private, enable);\r\ngoto config_done;\r\n}\r\nif (enable) {\r\nfsl_ssi_fifo_clear(ssi_private, vals->scr & CCSR_SSI_SCR_RE);\r\nregmap_update_bits(regs, CCSR_SSI_SRCR, vals->srcr, vals->srcr);\r\nregmap_update_bits(regs, CCSR_SSI_STCR, vals->stcr, vals->stcr);\r\nregmap_update_bits(regs, CCSR_SSI_SIER, vals->sier, vals->sier);\r\n} else {\r\nu32 sier;\r\nu32 srcr;\r\nu32 stcr;\r\nsier = fsl_ssi_disable_val(vals->sier, avals->sier,\r\nkeep_active);\r\nsrcr = fsl_ssi_disable_val(vals->srcr, avals->srcr,\r\nkeep_active);\r\nstcr = fsl_ssi_disable_val(vals->stcr, avals->stcr,\r\nkeep_active);\r\nregmap_update_bits(regs, CCSR_SSI_SRCR, srcr, 0);\r\nregmap_update_bits(regs, CCSR_SSI_STCR, stcr, 0);\r\nregmap_update_bits(regs, CCSR_SSI_SIER, sier, 0);\r\n}\r\nconfig_done:\r\nif (enable) {\r\nif (ssi_private->use_dma && (vals->scr & CCSR_SSI_SCR_TE)) {\r\nint i;\r\nint max_loop = 100;\r\nregmap_update_bits(regs, CCSR_SSI_SCR,\r\nCCSR_SSI_SCR_SSIEN, CCSR_SSI_SCR_SSIEN);\r\nfor (i = 0; i < max_loop; i++) {\r\nu32 sfcsr;\r\nregmap_read(regs, CCSR_SSI_SFCSR, &sfcsr);\r\nif (CCSR_SSI_SFCSR_TFCNT0(sfcsr))\r\nbreak;\r\n}\r\nif (i == max_loop) {\r\ndev_err(ssi_private->dev,\r\n"Timeout waiting TX FIFO filling\n");\r\n}\r\n}\r\nregmap_update_bits(regs, CCSR_SSI_SCR, vals->scr, vals->scr);\r\n}\r\n}\r\nstatic void fsl_ssi_rx_config(struct fsl_ssi_private *ssi_private, bool enable)\r\n{\r\nfsl_ssi_config(ssi_private, enable, &ssi_private->rxtx_reg_val.rx);\r\n}\r\nstatic void fsl_ssi_tx_config(struct fsl_ssi_private *ssi_private, bool enable)\r\n{\r\nfsl_ssi_config(ssi_private, enable, &ssi_private->rxtx_reg_val.tx);\r\n}\r\nstatic void fsl_ssi_setup_reg_vals(struct fsl_ssi_private *ssi_private)\r\n{\r\nstruct fsl_ssi_rxtx_reg_val *reg = &ssi_private->rxtx_reg_val;\r\nreg->rx.sier = CCSR_SSI_SIER_RFF0_EN;\r\nreg->rx.srcr = CCSR_SSI_SRCR_RFEN0;\r\nreg->rx.scr = 0;\r\nreg->tx.sier = CCSR_SSI_SIER_TFE0_EN;\r\nreg->tx.stcr = CCSR_SSI_STCR_TFEN0;\r\nreg->tx.scr = 0;\r\nif (!fsl_ssi_is_ac97(ssi_private)) {\r\nreg->rx.scr = CCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_RE;\r\nreg->rx.sier |= CCSR_SSI_SIER_RFF0_EN;\r\nreg->tx.scr = CCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_TE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TFE0_EN;\r\n}\r\nif (ssi_private->use_dma) {\r\nreg->rx.sier |= CCSR_SSI_SIER_RDMAE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TDMAE;\r\n} else {\r\nreg->rx.sier |= CCSR_SSI_SIER_RIE;\r\nreg->tx.sier |= CCSR_SSI_SIER_TIE;\r\n}\r\nreg->rx.sier |= FSLSSI_SIER_DBG_RX_FLAGS;\r\nreg->tx.sier |= FSLSSI_SIER_DBG_TX_FLAGS;\r\n}\r\nstatic void fsl_ssi_setup_ac97(struct fsl_ssi_private *ssi_private)\r\n{\r\nstruct regmap *regs = ssi_private->regs;\r\nregmap_write(regs, CCSR_SSI_STCCR,\r\nCCSR_SSI_SxCCR_WL(17) | CCSR_SSI_SxCCR_DC(13));\r\nregmap_write(regs, CCSR_SSI_SRCCR,\r\nCCSR_SSI_SxCCR_WL(17) | CCSR_SSI_SxCCR_DC(13));\r\nregmap_write(regs, CCSR_SSI_SACNT,\r\nCCSR_SSI_SACNT_AC97EN | CCSR_SSI_SACNT_FV);\r\nif (!ssi_private->soc->imx21regs) {\r\nregmap_write(regs, CCSR_SSI_SACCDIS, 0xff);\r\nregmap_write(regs, CCSR_SSI_SACCEN, 0x300);\r\n}\r\nregmap_update_bits(regs, CCSR_SSI_SCR,\r\nCCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_TE | CCSR_SSI_SCR_RE,\r\nCCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_TE | CCSR_SSI_SCR_RE);\r\nregmap_write(regs, CCSR_SSI_SOR, CCSR_SSI_SOR_WAIT(3));\r\n}\r\nstatic int fsl_ssi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private =\r\nsnd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nint ret;\r\nret = clk_prepare_enable(ssi_private->clk);\r\nif (ret)\r\nreturn ret;\r\nif (ssi_private->use_dual_fifo)\r\nsnd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private =\r\nsnd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nclk_disable_unprepare(ssi_private->clk);\r\n}\r\nstatic int fsl_ssi_set_bclk(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regs = ssi_private->regs;\r\nint synchronous = ssi_private->cpu_dai_drv.symmetric_rates, ret;\r\nu32 pm = 999, div2, psr, stccr, mask, afreq, factor, i;\r\nunsigned long clkrate, baudrate, tmprate;\r\nu64 sub, savesub = 100000;\r\nunsigned int freq;\r\nbool baudclk_is_used;\r\nif (ssi_private->bitclk_freq)\r\nfreq = ssi_private->bitclk_freq;\r\nelse\r\nfreq = params_channels(hw_params) * 32 * params_rate(hw_params);\r\nif (IS_ERR(ssi_private->baudclk))\r\nreturn -EINVAL;\r\nif (freq * 5 > clk_get_rate(ssi_private->clk)) {\r\ndev_err(cpu_dai->dev, "bitclk > ipgclk/5\n");\r\nreturn -EINVAL;\r\n}\r\nbaudclk_is_used = ssi_private->baudclk_streams & ~(BIT(substream->stream));\r\npsr = 0;\r\ndiv2 = 0;\r\nfactor = (div2 + 1) * (7 * psr + 1) * 2;\r\nfor (i = 0; i < 255; i++) {\r\ntmprate = freq * factor * (i + 1);\r\nif (baudclk_is_used)\r\nclkrate = clk_get_rate(ssi_private->baudclk);\r\nelse\r\nclkrate = clk_round_rate(ssi_private->baudclk, tmprate);\r\nclkrate /= factor;\r\nafreq = clkrate / (i + 1);\r\nif (freq == afreq)\r\nsub = 0;\r\nelse if (freq / afreq == 1)\r\nsub = freq - afreq;\r\nelse if (afreq / freq == 1)\r\nsub = afreq - freq;\r\nelse\r\ncontinue;\r\nsub *= 100000;\r\ndo_div(sub, freq);\r\nif (sub < savesub && !(i == 0 && psr == 0 && div2 == 0)) {\r\nbaudrate = tmprate;\r\nsavesub = sub;\r\npm = i;\r\n}\r\nif (savesub == 0)\r\nbreak;\r\n}\r\nif (pm == 999) {\r\ndev_err(cpu_dai->dev, "failed to handle the required sysclk\n");\r\nreturn -EINVAL;\r\n}\r\nstccr = CCSR_SSI_SxCCR_PM(pm + 1) | (div2 ? CCSR_SSI_SxCCR_DIV2 : 0) |\r\n(psr ? CCSR_SSI_SxCCR_PSR : 0);\r\nmask = CCSR_SSI_SxCCR_PM_MASK | CCSR_SSI_SxCCR_DIV2 |\r\nCCSR_SSI_SxCCR_PSR;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK || synchronous)\r\nregmap_update_bits(regs, CCSR_SSI_STCCR, mask, stccr);\r\nelse\r\nregmap_update_bits(regs, CCSR_SSI_SRCCR, mask, stccr);\r\nif (!baudclk_is_used) {\r\nret = clk_set_rate(ssi_private->baudclk, baudrate);\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "failed to set baudclk rate\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nssi_private->bitclk_freq = freq;\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regs = ssi_private->regs;\r\nunsigned int channels = params_channels(hw_params);\r\nunsigned int sample_size = params_width(hw_params);\r\nu32 wl = CCSR_SSI_SxCCR_WL(sample_size);\r\nint ret;\r\nu32 scr_val;\r\nint enabled;\r\nregmap_read(regs, CCSR_SSI_SCR, &scr_val);\r\nenabled = scr_val & CCSR_SSI_SCR_SSIEN;\r\nif (enabled && ssi_private->cpu_dai_drv.symmetric_rates)\r\nreturn 0;\r\nif (fsl_ssi_is_i2s_master(ssi_private)) {\r\nret = fsl_ssi_set_bclk(substream, cpu_dai, hw_params);\r\nif (ret)\r\nreturn ret;\r\nif (!(ssi_private->baudclk_streams & BIT(substream->stream))) {\r\nret = clk_prepare_enable(ssi_private->baudclk);\r\nif (ret)\r\nreturn ret;\r\nssi_private->baudclk_streams |= BIT(substream->stream);\r\n}\r\n}\r\nif (!fsl_ssi_is_ac97(ssi_private)) {\r\nu8 i2smode;\r\nif (fsl_ssi_is_i2s_cbm_cfs(ssi_private) && sample_size == 16)\r\ni2smode = CCSR_SSI_SCR_I2S_MODE_NORMAL |\r\nCCSR_SSI_SCR_NET;\r\nelse\r\ni2smode = ssi_private->i2s_mode;\r\nregmap_update_bits(regs, CCSR_SSI_SCR,\r\nCCSR_SSI_SCR_NET | CCSR_SSI_SCR_I2S_MODE_MASK,\r\nchannels == 1 ? 0 : i2smode);\r\n}\r\nif ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ||\r\nssi_private->cpu_dai_drv.symmetric_rates)\r\nregmap_update_bits(regs, CCSR_SSI_STCCR, CCSR_SSI_SxCCR_WL_MASK,\r\nwl);\r\nelse\r\nregmap_update_bits(regs, CCSR_SSI_SRCCR, CCSR_SSI_SxCCR_WL_MASK,\r\nwl);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_hw_free(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private =\r\nsnd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nif (fsl_ssi_is_i2s_master(ssi_private) &&\r\nssi_private->baudclk_streams & BIT(substream->stream)) {\r\nclk_disable_unprepare(ssi_private->baudclk);\r\nssi_private->baudclk_streams &= ~BIT(substream->stream);\r\n}\r\nreturn 0;\r\n}\r\nstatic int _fsl_ssi_set_dai_fmt(struct device *dev,\r\nstruct fsl_ssi_private *ssi_private,\r\nunsigned int fmt)\r\n{\r\nstruct regmap *regs = ssi_private->regs;\r\nu32 strcr = 0, stcr, srcr, scr, mask;\r\nu8 wm;\r\nssi_private->dai_fmt = fmt;\r\nif (fsl_ssi_is_i2s_master(ssi_private) && IS_ERR(ssi_private->baudclk)) {\r\ndev_err(dev, "baudclk is missing which is necessary for master mode\n");\r\nreturn -EINVAL;\r\n}\r\nfsl_ssi_setup_reg_vals(ssi_private);\r\nregmap_read(regs, CCSR_SSI_SCR, &scr);\r\nscr &= ~(CCSR_SSI_SCR_SYN | CCSR_SSI_SCR_I2S_MODE_MASK);\r\nscr |= CCSR_SSI_SCR_SYNC_TX_FS;\r\nmask = CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TFDIR | CCSR_SSI_STCR_TXDIR |\r\nCCSR_SSI_STCR_TSCKP | CCSR_SSI_STCR_TFSI | CCSR_SSI_STCR_TFSL |\r\nCCSR_SSI_STCR_TEFS;\r\nregmap_read(regs, CCSR_SSI_STCR, &stcr);\r\nregmap_read(regs, CCSR_SSI_SRCR, &srcr);\r\nstcr &= ~mask;\r\nsrcr &= ~mask;\r\nssi_private->i2s_mode = CCSR_SSI_SCR_NET;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregmap_update_bits(regs, CCSR_SSI_STCCR,\r\nCCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(2));\r\nregmap_update_bits(regs, CCSR_SSI_SRCCR,\r\nCCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(2));\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nssi_private->i2s_mode |= CCSR_SSI_SCR_I2S_MODE_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nssi_private->i2s_mode |= CCSR_SSI_SCR_I2S_MODE_SLAVE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstrcr |= CCSR_SSI_STCR_TFSI | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TEFS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nstrcr |= CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nstrcr |= CCSR_SSI_STCR_TFSL | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TEFS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nstrcr |= CCSR_SSI_STCR_TFSL | CCSR_SSI_STCR_TSCKP |\r\nCCSR_SSI_STCR_TXBIT0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_AC97:\r\nssi_private->i2s_mode |= CCSR_SSI_SCR_I2S_MODE_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nscr |= ssi_private->i2s_mode;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nstrcr ^= CCSR_SSI_STCR_TSCKP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nstrcr ^= CCSR_SSI_STCR_TFSI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nstrcr ^= CCSR_SSI_STCR_TSCKP;\r\nstrcr ^= CCSR_SSI_STCR_TFSI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nstrcr |= CCSR_SSI_STCR_TFDIR | CCSR_SSI_STCR_TXDIR;\r\nscr |= CCSR_SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nscr &= ~CCSR_SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nstrcr &= ~CCSR_SSI_STCR_TXDIR;\r\nstrcr |= CCSR_SSI_STCR_TFDIR;\r\nscr &= ~CCSR_SSI_SCR_SYS_CLK_EN;\r\nbreak;\r\ndefault:\r\nif (!fsl_ssi_is_ac97(ssi_private))\r\nreturn -EINVAL;\r\n}\r\nstcr |= strcr;\r\nsrcr |= strcr;\r\nif (ssi_private->cpu_dai_drv.symmetric_rates\r\n|| fsl_ssi_is_ac97(ssi_private)) {\r\nsrcr &= ~CCSR_SSI_SRCR_RXDIR;\r\nscr |= CCSR_SSI_SCR_SYN;\r\n}\r\nregmap_write(regs, CCSR_SSI_STCR, stcr);\r\nregmap_write(regs, CCSR_SSI_SRCR, srcr);\r\nregmap_write(regs, CCSR_SSI_SCR, scr);\r\nwm = ssi_private->fifo_watermark;\r\nregmap_write(regs, CCSR_SSI_SFCSR,\r\nCCSR_SSI_SFCSR_TFWM0(wm) | CCSR_SSI_SFCSR_RFWM0(wm) |\r\nCCSR_SSI_SFCSR_TFWM1(wm) | CCSR_SSI_SFCSR_RFWM1(wm));\r\nif (ssi_private->use_dual_fifo) {\r\nregmap_update_bits(regs, CCSR_SSI_SRCR, CCSR_SSI_SRCR_RFEN1,\r\nCCSR_SSI_SRCR_RFEN1);\r\nregmap_update_bits(regs, CCSR_SSI_STCR, CCSR_SSI_STCR_TFEN1,\r\nCCSR_SSI_STCR_TFEN1);\r\nregmap_update_bits(regs, CCSR_SSI_SCR, CCSR_SSI_SCR_TCH_EN,\r\nCCSR_SSI_SCR_TCH_EN);\r\n}\r\nif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_AC97)\r\nfsl_ssi_setup_ac97(ssi_private);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nreturn _fsl_ssi_set_dai_fmt(cpu_dai->dev, ssi_private, fmt);\r\n}\r\nstatic int fsl_ssi_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\r\nu32 rx_mask, int slots, int slot_width)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct regmap *regs = ssi_private->regs;\r\nu32 val;\r\nregmap_read(regs, CCSR_SSI_SCR, &val);\r\nval &= CCSR_SSI_SCR_I2S_MODE_MASK | CCSR_SSI_SCR_NET;\r\nif (val && slots < 2) {\r\ndev_err(cpu_dai->dev, "slot number should be >= 2 in I2S or NET\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(regs, CCSR_SSI_STCCR, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(slots));\r\nregmap_update_bits(regs, CCSR_SSI_SRCCR, CCSR_SSI_SxCCR_DC_MASK,\r\nCCSR_SSI_SxCCR_DC(slots));\r\nregmap_read(regs, CCSR_SSI_SCR, &val);\r\nval &= CCSR_SSI_SCR_SSIEN;\r\nregmap_update_bits(regs, CCSR_SSI_SCR, CCSR_SSI_SCR_SSIEN,\r\nCCSR_SSI_SCR_SSIEN);\r\nregmap_write(regs, CCSR_SSI_STMSK, ~tx_mask);\r\nregmap_write(regs, CCSR_SSI_SRMSK, ~rx_mask);\r\nregmap_update_bits(regs, CCSR_SSI_SCR, CCSR_SSI_SCR_SSIEN, val);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct regmap *regs = ssi_private->regs;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfsl_ssi_tx_config(ssi_private, true);\r\nelse\r\nfsl_ssi_rx_config(ssi_private, true);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfsl_ssi_tx_config(ssi_private, false);\r\nelse\r\nfsl_ssi_rx_config(ssi_private, false);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fsl_ssi_is_ac97(ssi_private)) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nregmap_write(regs, CCSR_SSI_SOR, CCSR_SSI_SOR_TX_CLR);\r\nelse\r\nregmap_write(regs, CCSR_SSI_SOR, CCSR_SSI_SOR_RX_CLR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(dai);\r\nif (ssi_private->soc->imx && ssi_private->use_dma) {\r\ndai->playback_dma_data = &ssi_private->dma_params_tx;\r\ndai->capture_dma_data = &ssi_private->dma_params_rx;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct regmap *regs = fsl_ac97_data->regs;\r\nunsigned int lreg;\r\nunsigned int lval;\r\nint ret;\r\nif (reg > 0x7f)\r\nreturn;\r\nret = clk_prepare_enable(fsl_ac97_data->clk);\r\nif (ret) {\r\npr_err("ac97 write clk_prepare_enable failed: %d\n",\r\nret);\r\nreturn;\r\n}\r\nlreg = reg << 12;\r\nregmap_write(regs, CCSR_SSI_SACADD, lreg);\r\nlval = val << 4;\r\nregmap_write(regs, CCSR_SSI_SACDAT, lval);\r\nregmap_update_bits(regs, CCSR_SSI_SACNT, CCSR_SSI_SACNT_RDWR_MASK,\r\nCCSR_SSI_SACNT_WR);\r\nudelay(100);\r\nclk_disable_unprepare(fsl_ac97_data->clk);\r\n}\r\nstatic unsigned short fsl_ssi_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct regmap *regs = fsl_ac97_data->regs;\r\nunsigned short val = -1;\r\nu32 reg_val;\r\nunsigned int lreg;\r\nint ret;\r\nret = clk_prepare_enable(fsl_ac97_data->clk);\r\nif (ret) {\r\npr_err("ac97 read clk_prepare_enable failed: %d\n",\r\nret);\r\nreturn -1;\r\n}\r\nlreg = (reg & 0x7f) << 12;\r\nregmap_write(regs, CCSR_SSI_SACADD, lreg);\r\nregmap_update_bits(regs, CCSR_SSI_SACNT, CCSR_SSI_SACNT_RDWR_MASK,\r\nCCSR_SSI_SACNT_RD);\r\nudelay(100);\r\nregmap_read(regs, CCSR_SSI_SACDAT, &reg_val);\r\nval = (reg_val >> 4) & 0xffff;\r\nclk_disable_unprepare(fsl_ac97_data->clk);\r\nreturn val;\r\n}\r\nstatic void make_lowercase(char *s)\r\n{\r\nchar *p = s;\r\nchar c;\r\nwhile ((c = *p)) {\r\nif ((c >= 'A') && (c <= 'Z'))\r\n*p = c + ('a' - 'A');\r\np++;\r\n}\r\n}\r\nstatic int fsl_ssi_imx_probe(struct platform_device *pdev,\r\nstruct fsl_ssi_private *ssi_private, void __iomem *iomem)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 dmas[4];\r\nint ret;\r\nif (ssi_private->has_ipg_clk_name)\r\nssi_private->clk = devm_clk_get(&pdev->dev, "ipg");\r\nelse\r\nssi_private->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssi_private->clk)) {\r\nret = PTR_ERR(ssi_private->clk);\r\ndev_err(&pdev->dev, "could not get clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!ssi_private->has_ipg_clk_name) {\r\nret = clk_prepare_enable(ssi_private->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "clk_prepare_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nssi_private->baudclk = devm_clk_get(&pdev->dev, "baud");\r\nif (IS_ERR(ssi_private->baudclk))\r\ndev_dbg(&pdev->dev, "could not get baud clock: %ld\n",\r\nPTR_ERR(ssi_private->baudclk));\r\nssi_private->dma_params_tx.maxburst = ssi_private->dma_maxburst;\r\nssi_private->dma_params_rx.maxburst = ssi_private->dma_maxburst;\r\nssi_private->dma_params_tx.addr = ssi_private->ssi_phys + CCSR_SSI_STX0;\r\nssi_private->dma_params_rx.addr = ssi_private->ssi_phys + CCSR_SSI_SRX0;\r\nret = of_property_read_u32_array(np, "dmas", dmas, 4);\r\nif (ssi_private->use_dma && !ret && dmas[2] == IMX_DMATYPE_SSI_DUAL) {\r\nssi_private->use_dual_fifo = true;\r\nssi_private->dma_params_tx.maxburst &= ~0x1;\r\nssi_private->dma_params_rx.maxburst &= ~0x1;\r\n}\r\nif (!ssi_private->use_dma) {\r\nssi_private->fiq_params.irq = ssi_private->irq;\r\nssi_private->fiq_params.base = iomem;\r\nssi_private->fiq_params.dma_params_rx =\r\n&ssi_private->dma_params_rx;\r\nssi_private->fiq_params.dma_params_tx =\r\n&ssi_private->dma_params_tx;\r\nret = imx_pcm_fiq_init(pdev, &ssi_private->fiq_params);\r\nif (ret)\r\ngoto error_pcm;\r\n} else {\r\nret = imx_pcm_dma_init(pdev, IMX_SSI_DMABUF_SIZE);\r\nif (ret)\r\ngoto error_pcm;\r\n}\r\nreturn 0;\r\nerror_pcm:\r\nif (!ssi_private->has_ipg_clk_name)\r\nclk_disable_unprepare(ssi_private->clk);\r\nreturn ret;\r\n}\r\nstatic void fsl_ssi_imx_clean(struct platform_device *pdev,\r\nstruct fsl_ssi_private *ssi_private)\r\n{\r\nif (!ssi_private->use_dma)\r\nimx_pcm_fiq_exit(pdev);\r\nif (!ssi_private->has_ipg_clk_name)\r\nclk_disable_unprepare(ssi_private->clk);\r\n}\r\nstatic int fsl_ssi_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private;\r\nint ret = 0;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id;\r\nconst char *p, *sprop;\r\nconst uint32_t *iprop;\r\nstruct resource *res;\r\nvoid __iomem *iomem;\r\nchar name[64];\r\nstruct regmap_config regconfig = fsl_ssi_regconfig;\r\nof_id = of_match_device(fsl_ssi_ids, &pdev->dev);\r\nif (!of_id || !of_id->data)\r\nreturn -EINVAL;\r\nssi_private = devm_kzalloc(&pdev->dev, sizeof(*ssi_private),\r\nGFP_KERNEL);\r\nif (!ssi_private) {\r\ndev_err(&pdev->dev, "could not allocate DAI object\n");\r\nreturn -ENOMEM;\r\n}\r\nssi_private->soc = of_id->data;\r\nssi_private->dev = &pdev->dev;\r\nsprop = of_get_property(np, "fsl,mode", NULL);\r\nif (sprop) {\r\nif (!strcmp(sprop, "ac97-slave"))\r\nssi_private->dai_fmt = SND_SOC_DAIFMT_AC97;\r\n}\r\nssi_private->use_dma = !of_property_read_bool(np,\r\n"fsl,fiq-stream-filter");\r\nif (fsl_ssi_is_ac97(ssi_private)) {\r\nmemcpy(&ssi_private->cpu_dai_drv, &fsl_ssi_ac97_dai,\r\nsizeof(fsl_ssi_ac97_dai));\r\nfsl_ac97_data = ssi_private;\r\nret = snd_soc_set_ac97_ops_of_reset(&fsl_ssi_ac97_ops, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not set AC'97 ops\n");\r\nreturn ret;\r\n}\r\n} else {\r\nmemcpy(&ssi_private->cpu_dai_drv, &fsl_ssi_dai_template,\r\nsizeof(fsl_ssi_dai_template));\r\n}\r\nssi_private->cpu_dai_drv.name = dev_name(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niomem = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(iomem))\r\nreturn PTR_ERR(iomem);\r\nssi_private->ssi_phys = res->start;\r\nif (ssi_private->soc->imx21regs) {\r\nregconfig.max_register = CCSR_SSI_SRMSK;\r\nregconfig.num_reg_defaults_raw =\r\nCCSR_SSI_SRMSK / sizeof(uint32_t) + 1;\r\n}\r\nret = of_property_match_string(np, "clock-names", "ipg");\r\nif (ret < 0) {\r\nssi_private->has_ipg_clk_name = false;\r\nssi_private->regs = devm_regmap_init_mmio(&pdev->dev, iomem,\r\n&regconfig);\r\n} else {\r\nssi_private->has_ipg_clk_name = true;\r\nssi_private->regs = devm_regmap_init_mmio_clk(&pdev->dev,\r\n"ipg", iomem, &regconfig);\r\n}\r\nif (IS_ERR(ssi_private->regs)) {\r\ndev_err(&pdev->dev, "Failed to init register map\n");\r\nreturn PTR_ERR(ssi_private->regs);\r\n}\r\nssi_private->irq = platform_get_irq(pdev, 0);\r\nif (ssi_private->irq < 0) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", pdev->name);\r\nreturn ssi_private->irq;\r\n}\r\nif (!of_find_property(np, "fsl,ssi-asynchronous", NULL)) {\r\nif (!fsl_ssi_is_ac97(ssi_private))\r\nssi_private->cpu_dai_drv.symmetric_rates = 1;\r\nssi_private->cpu_dai_drv.symmetric_channels = 1;\r\nssi_private->cpu_dai_drv.symmetric_samplebits = 1;\r\n}\r\niprop = of_get_property(np, "fsl,fifo-depth", NULL);\r\nif (iprop)\r\nssi_private->fifo_depth = be32_to_cpup(iprop);\r\nelse\r\nssi_private->fifo_depth = 8;\r\nswitch (ssi_private->fifo_depth) {\r\ncase 15:\r\nssi_private->fifo_watermark = 8;\r\nssi_private->dma_maxburst = 8;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nssi_private->fifo_watermark = ssi_private->fifo_depth - 2;\r\nssi_private->dma_maxburst = ssi_private->fifo_depth - 2;\r\nbreak;\r\n}\r\ndev_set_drvdata(&pdev->dev, ssi_private);\r\nif (ssi_private->soc->imx) {\r\nret = fsl_ssi_imx_probe(pdev, ssi_private, iomem);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &fsl_ssi_component,\r\n&ssi_private->cpu_dai_drv, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DAI: %d\n", ret);\r\ngoto error_asoc_register;\r\n}\r\nif (ssi_private->use_dma) {\r\nret = devm_request_irq(&pdev->dev, ssi_private->irq,\r\nfsl_ssi_isr, 0, dev_name(&pdev->dev),\r\nssi_private);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not claim irq %u\n",\r\nssi_private->irq);\r\ngoto error_asoc_register;\r\n}\r\n}\r\nret = fsl_ssi_debugfs_create(&ssi_private->dbg_stats, &pdev->dev);\r\nif (ret)\r\ngoto error_asoc_register;\r\nif (!of_get_property(np, "codec-handle", NULL))\r\ngoto done;\r\nsprop = of_get_property(of_find_node_by_path("/"), "compatible", NULL);\r\np = strrchr(sprop, ',');\r\nif (p)\r\nsprop = p + 1;\r\nsnprintf(name, sizeof(name), "snd-soc-%s", sprop);\r\nmake_lowercase(name);\r\nssi_private->pdev =\r\nplatform_device_register_data(&pdev->dev, name, 0, NULL, 0);\r\nif (IS_ERR(ssi_private->pdev)) {\r\nret = PTR_ERR(ssi_private->pdev);\r\ndev_err(&pdev->dev, "failed to register platform: %d\n", ret);\r\ngoto error_sound_card;\r\n}\r\ndone:\r\nif (ssi_private->dai_fmt)\r\n_fsl_ssi_set_dai_fmt(&pdev->dev, ssi_private,\r\nssi_private->dai_fmt);\r\nif (fsl_ssi_is_ac97(ssi_private)) {\r\nu32 ssi_idx;\r\nret = of_property_read_u32(np, "cell-index", &ssi_idx);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot get SSI index property\n");\r\ngoto error_sound_card;\r\n}\r\nssi_private->pdev =\r\nplatform_device_register_data(NULL,\r\n"ac97-codec", ssi_idx, NULL, 0);\r\nif (IS_ERR(ssi_private->pdev)) {\r\nret = PTR_ERR(ssi_private->pdev);\r\ndev_err(&pdev->dev,\r\n"failed to register AC97 codec platform: %d\n",\r\nret);\r\ngoto error_sound_card;\r\n}\r\n}\r\nreturn 0;\r\nerror_sound_card:\r\nfsl_ssi_debugfs_remove(&ssi_private->dbg_stats);\r\nerror_asoc_register:\r\nif (ssi_private->soc->imx)\r\nfsl_ssi_imx_clean(pdev, ssi_private);\r\nreturn ret;\r\n}\r\nstatic int fsl_ssi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_get_drvdata(&pdev->dev);\r\nfsl_ssi_debugfs_remove(&ssi_private->dbg_stats);\r\nif (ssi_private->pdev)\r\nplatform_device_unregister(ssi_private->pdev);\r\nif (ssi_private->soc->imx)\r\nfsl_ssi_imx_clean(pdev, ssi_private);\r\nif (fsl_ssi_is_ac97(ssi_private))\r\nsnd_soc_set_ac97_ops(NULL);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_suspend(struct device *dev)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_get_drvdata(dev);\r\nstruct regmap *regs = ssi_private->regs;\r\nregmap_read(regs, CCSR_SSI_SFCSR,\r\n&ssi_private->regcache_sfcsr);\r\nregmap_read(regs, CCSR_SSI_SACNT,\r\n&ssi_private->regcache_sacnt);\r\nregcache_cache_only(regs, true);\r\nregcache_mark_dirty(regs);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_resume(struct device *dev)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_get_drvdata(dev);\r\nstruct regmap *regs = ssi_private->regs;\r\nregcache_cache_only(regs, false);\r\nregmap_update_bits(regs, CCSR_SSI_SFCSR,\r\nCCSR_SSI_SFCSR_RFWM1_MASK | CCSR_SSI_SFCSR_TFWM1_MASK |\r\nCCSR_SSI_SFCSR_RFWM0_MASK | CCSR_SSI_SFCSR_TFWM0_MASK,\r\nssi_private->regcache_sfcsr);\r\nregmap_write(regs, CCSR_SSI_SACNT,\r\nssi_private->regcache_sacnt);\r\nreturn regcache_sync(regs);\r\n}
