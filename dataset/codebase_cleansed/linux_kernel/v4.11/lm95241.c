static int temp_from_reg_signed(u8 val_h, u8 val_l)\r\n{\r\ns16 val_hl = (val_h << 8) | val_l;\r\nreturn val_hl * 1000 / 256;\r\n}\r\nstatic int temp_from_reg_unsigned(u8 val_h, u8 val_l)\r\n{\r\nu16 val_hl = (val_h << 8) | val_l;\r\nreturn val_hl * 1000 / 256;\r\n}\r\nstatic struct lm95241_data *lm95241_update_device(struct device *dev)\r\n{\r\nstruct lm95241_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated\r\n+ msecs_to_jiffies(data->interval)) ||\r\n!data->valid) {\r\nint i;\r\ndev_dbg(dev, "Updating lm95241 data.\n");\r\nfor (i = 0; i < ARRAY_SIZE(lm95241_reg_address); i++)\r\ndata->temp[i]\r\n= i2c_smbus_read_byte_data(client,\r\nlm95241_reg_address[i]);\r\ndata->status = i2c_smbus_read_byte_data(client,\r\nLM95241_REG_R_STATUS);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int lm95241_read_chip(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct lm95241_data *data = dev_get_drvdata(dev);\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\n*val = data->interval;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95241_read_temp(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct lm95241_data *data = lm95241_update_device(dev);\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nif (!channel || (data->config & BIT(channel - 1)))\r\n*val = temp_from_reg_signed(data->temp[channel * 2],\r\ndata->temp[channel * 2 + 1]);\r\nelse\r\n*val = temp_from_reg_unsigned(data->temp[channel * 2],\r\ndata->temp[channel * 2 + 1]);\r\nreturn 0;\r\ncase hwmon_temp_min:\r\nif (channel == 1)\r\n*val = (data->config & R1DF_MASK) ? -128000 : 0;\r\nelse\r\n*val = (data->config & R2DF_MASK) ? -128000 : 0;\r\nreturn 0;\r\ncase hwmon_temp_max:\r\nif (channel == 1)\r\n*val = (data->config & R1DF_MASK) ? 127875 : 255875;\r\nelse\r\n*val = (data->config & R2DF_MASK) ? 127875 : 255875;\r\nreturn 0;\r\ncase hwmon_temp_type:\r\nif (channel == 1)\r\n*val = (data->model & R1MS_MASK) ? 1 : 2;\r\nelse\r\n*val = (data->model & R2MS_MASK) ? 1 : 2;\r\nreturn 0;\r\ncase hwmon_temp_fault:\r\nif (channel == 1)\r\n*val = !!(data->status & R1DM);\r\nelse\r\n*val = !!(data->status & R2DM);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95241_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm95241_read_chip(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm95241_read_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int lm95241_write_chip(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct lm95241_data *data = dev_get_drvdata(dev);\r\nint convrate;\r\nu8 config;\r\nint ret;\r\nmutex_lock(&data->update_lock);\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nconfig = data->config & ~CFG_CRMASK;\r\nif (val < 130) {\r\nconvrate = 76;\r\nconfig |= CFG_CR0076;\r\n} else if (val < 590) {\r\nconvrate = 182;\r\nconfig |= CFG_CR0182;\r\n} else if (val < 1850) {\r\nconvrate = 1000;\r\nconfig |= CFG_CR1000;\r\n} else {\r\nconvrate = 2700;\r\nconfig |= CFG_CR2700;\r\n}\r\ndata->interval = convrate;\r\ndata->config = config;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nLM95241_REG_RW_CONFIG, config);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int lm95241_write_temp(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct lm95241_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nmutex_lock(&data->update_lock);\r\nswitch (attr) {\r\ncase hwmon_temp_min:\r\nif (channel == 1) {\r\nif (val < 0)\r\ndata->config |= R1DF_MASK;\r\nelse\r\ndata->config &= ~R1DF_MASK;\r\n} else {\r\nif (val < 0)\r\ndata->config |= R2DF_MASK;\r\nelse\r\ndata->config &= ~R2DF_MASK;\r\n}\r\ndata->valid = 0;\r\nret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG,\r\ndata->config);\r\nbreak;\r\ncase hwmon_temp_max:\r\nif (channel == 1) {\r\nif (val <= 127875)\r\ndata->config |= R1DF_MASK;\r\nelse\r\ndata->config &= ~R1DF_MASK;\r\n} else {\r\nif (val <= 127875)\r\ndata->config |= R2DF_MASK;\r\nelse\r\ndata->config &= ~R2DF_MASK;\r\n}\r\ndata->valid = 0;\r\nret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG,\r\ndata->config);\r\nbreak;\r\ncase hwmon_temp_type:\r\nif (val != 1 && val != 2) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (channel == 1) {\r\ndata->trutherm &= ~(TT_MASK << TT1_SHIFT);\r\nif (val == 1) {\r\ndata->model |= R1MS_MASK;\r\ndata->trutherm |= (TT_ON << TT1_SHIFT);\r\n} else {\r\ndata->model &= ~R1MS_MASK;\r\ndata->trutherm |= (TT_OFF << TT1_SHIFT);\r\n}\r\n} else {\r\ndata->trutherm &= ~(TT_MASK << TT2_SHIFT);\r\nif (val == 1) {\r\ndata->model |= R2MS_MASK;\r\ndata->trutherm |= (TT_ON << TT2_SHIFT);\r\n} else {\r\ndata->model &= ~R2MS_MASK;\r\ndata->trutherm |= (TT_OFF << TT2_SHIFT);\r\n}\r\n}\r\nret = i2c_smbus_write_byte_data(client,\r\nLM95241_REG_RW_REMOTE_MODEL,\r\ndata->model);\r\nif (ret < 0)\r\nbreak;\r\nret = i2c_smbus_write_byte_data(client, LM95241_REG_RW_TRUTHERM,\r\ndata->trutherm);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int lm95241_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nreturn lm95241_write_chip(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn lm95241_write_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t lm95241_is_visible(const void *data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nreturn S_IRUGO | S_IWUSR;\r\n}\r\nbreak;\r\ncase hwmon_temp:\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nreturn S_IRUGO;\r\ncase hwmon_temp_fault:\r\nreturn S_IRUGO;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\ncase hwmon_temp_type:\r\nreturn S_IRUGO | S_IWUSR;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm95241_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nconst char *name;\r\nint mfg_id, chip_id;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nmfg_id = i2c_smbus_read_byte_data(new_client, LM95241_REG_R_MAN_ID);\r\nif (mfg_id != NATSEMI_MAN_ID)\r\nreturn -ENODEV;\r\nchip_id = i2c_smbus_read_byte_data(new_client, LM95241_REG_R_CHIP_ID);\r\nswitch (chip_id) {\r\ncase LM95231_CHIP_ID:\r\nname = "lm95231";\r\nbreak;\r\ncase LM95241_CHIP_ID:\r\nname = "lm95241";\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void lm95241_init_client(struct i2c_client *client,\r\nstruct lm95241_data *data)\r\n{\r\ndata->interval = 1000;\r\ndata->config = CFG_CR1000;\r\ndata->trutherm = (TT_OFF << TT1_SHIFT) | (TT_OFF << TT2_SHIFT);\r\ni2c_smbus_write_byte_data(client, LM95241_REG_RW_CONFIG, data->config);\r\ni2c_smbus_write_byte_data(client, LM95241_REG_RW_REM_FILTER,\r\nR1FE_MASK | R2FE_MASK);\r\ni2c_smbus_write_byte_data(client, LM95241_REG_RW_TRUTHERM,\r\ndata->trutherm);\r\ni2c_smbus_write_byte_data(client, LM95241_REG_RW_REMOTE_MODEL,\r\ndata->model);\r\n}\r\nstatic int lm95241_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct lm95241_data *data;\r\nstruct device *hwmon_dev;\r\ndata = devm_kzalloc(dev, sizeof(struct lm95241_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nlm95241_init_client(client, data);\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata,\r\n&lm95241_chip_info,\r\nNULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
