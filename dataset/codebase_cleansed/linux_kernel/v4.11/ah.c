static struct ib_ah *create_ib_ah(struct mlx5_ib_dev *dev,\r\nstruct mlx5_ib_ah *ah,\r\nstruct ib_ah_attr *ah_attr,\r\nenum rdma_link_layer ll)\r\n{\r\nif (ah_attr->ah_flags & IB_AH_GRH) {\r\nmemcpy(ah->av.rgid, &ah_attr->grh.dgid, 16);\r\nah->av.grh_gid_fl = cpu_to_be32(ah_attr->grh.flow_label |\r\n(1 << 30) |\r\nah_attr->grh.sgid_index << 20);\r\nah->av.hop_limit = ah_attr->grh.hop_limit;\r\nah->av.tclass = ah_attr->grh.traffic_class;\r\n}\r\nah->av.stat_rate_sl = (ah_attr->static_rate << 4);\r\nif (ll == IB_LINK_LAYER_ETHERNET) {\r\nmemcpy(ah->av.rmac, ah_attr->dmac, sizeof(ah_attr->dmac));\r\nah->av.udp_sport =\r\nmlx5_get_roce_udp_sport(dev,\r\nah_attr->port_num,\r\nah_attr->grh.sgid_index);\r\nah->av.stat_rate_sl |= (ah_attr->sl & 0x7) << 1;\r\n} else {\r\nah->av.rlid = cpu_to_be16(ah_attr->dlid);\r\nah->av.fl_mlid = ah_attr->src_path_bits & 0x7f;\r\nah->av.stat_rate_sl |= (ah_attr->sl & 0xf);\r\n}\r\nreturn &ah->ibah;\r\n}\r\nstruct ib_ah *mlx5_ib_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct mlx5_ib_ah *ah;\r\nstruct mlx5_ib_dev *dev = to_mdev(pd->device);\r\nenum rdma_link_layer ll;\r\nll = pd->device->get_link_layer(pd->device, ah_attr->port_num);\r\nif (ll == IB_LINK_LAYER_ETHERNET && !(ah_attr->ah_flags & IB_AH_GRH))\r\nreturn ERR_PTR(-EINVAL);\r\nif (ll == IB_LINK_LAYER_ETHERNET && udata) {\r\nint err;\r\nstruct mlx5_ib_create_ah_resp resp = {};\r\nu32 min_resp_len = offsetof(typeof(resp), dmac) +\r\nsizeof(resp.dmac);\r\nif (udata->outlen < min_resp_len)\r\nreturn ERR_PTR(-EINVAL);\r\nresp.response_length = min_resp_len;\r\nerr = ib_resolve_eth_dmac(pd->device, ah_attr);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nmemcpy(resp.dmac, ah_attr->dmac, ETH_ALEN);\r\nerr = ib_copy_to_udata(udata, &resp, resp.response_length);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nah = kzalloc(sizeof(*ah), GFP_ATOMIC);\r\nif (!ah)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn create_ib_ah(dev, ah, ah_attr, ll);\r\n}\r\nint mlx5_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)\r\n{\r\nstruct mlx5_ib_ah *ah = to_mah(ibah);\r\nu32 tmp;\r\nmemset(ah_attr, 0, sizeof(*ah_attr));\r\ntmp = be32_to_cpu(ah->av.grh_gid_fl);\r\nif (tmp & (1 << 30)) {\r\nah_attr->ah_flags = IB_AH_GRH;\r\nah_attr->grh.sgid_index = (tmp >> 20) & 0xff;\r\nah_attr->grh.flow_label = tmp & 0xfffff;\r\nmemcpy(&ah_attr->grh.dgid, ah->av.rgid, 16);\r\nah_attr->grh.hop_limit = ah->av.hop_limit;\r\nah_attr->grh.traffic_class = ah->av.tclass;\r\n}\r\nah_attr->dlid = be16_to_cpu(ah->av.rlid);\r\nah_attr->static_rate = ah->av.stat_rate_sl >> 4;\r\nah_attr->sl = ah->av.stat_rate_sl & 0xf;\r\nreturn 0;\r\n}\r\nint mlx5_ib_destroy_ah(struct ib_ah *ah)\r\n{\r\nkfree(to_mah(ah));\r\nreturn 0;\r\n}
