static void tcphy_cfg_24m(struct rockchip_typec_phy *tcphy)\r\n{\r\nu32 i, rdata;\r\nwritel(0x830, tcphy->base + PMA_CMN_CTRL1);\r\nfor (i = 0; i < 4; i++) {\r\nwritel(0x90, tcphy->base + XCVR_DIAG_LANE_FCM_EN_MGN(i));\r\nwritel(0x960, tcphy->base + TX_RCVDET_EN_TMR(i));\r\nwritel(0x30, tcphy->base + TX_RCVDET_ST_TMR(i));\r\n}\r\nrdata = readl(tcphy->base + CMN_DIAG_HSCLK_SEL);\r\nrdata &= ~CLK_PLL_MASK;\r\nrdata |= CLK_PLL_CONFIG;\r\nwritel(rdata, tcphy->base + CMN_DIAG_HSCLK_SEL);\r\n}\r\nstatic void tcphy_cfg_usb3_pll(struct rockchip_typec_phy *tcphy)\r\n{\r\nu32 i;\r\nfor (i = 0; i < ARRAY_SIZE(usb3_pll_cfg); i++)\r\nwritel(usb3_pll_cfg[i].value,\r\ntcphy->base + usb3_pll_cfg[i].addr);\r\n}\r\nstatic void tcphy_cfg_dp_pll(struct rockchip_typec_phy *tcphy)\r\n{\r\nu32 i;\r\nwritel(DP_PLL_CLOCK_ENABLE | DP_PLL_ENABLE | DP_PLL_DATA_RATE_RBR,\r\ntcphy->base + DP_CLK_CTL);\r\nfor (i = 0; i < ARRAY_SIZE(dp_pll_cfg); i++)\r\nwritel(dp_pll_cfg[i].value, tcphy->base + dp_pll_cfg[i].addr);\r\n}\r\nstatic void tcphy_tx_usb3_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\r\n{\r\nwritel(0x7799, tcphy->base + TX_PSC_A0(lane));\r\nwritel(0x7798, tcphy->base + TX_PSC_A1(lane));\r\nwritel(0x5098, tcphy->base + TX_PSC_A2(lane));\r\nwritel(0x5098, tcphy->base + TX_PSC_A3(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_000(lane));\r\nwritel(0xbf, tcphy->base + XCVR_DIAG_BIDI_CTRL(lane));\r\n}\r\nstatic void tcphy_rx_usb3_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\r\n{\r\nwritel(0xa6fd, tcphy->base + RX_PSC_A0(lane));\r\nwritel(0xa6fd, tcphy->base + RX_PSC_A1(lane));\r\nwritel(0xa410, tcphy->base + RX_PSC_A2(lane));\r\nwritel(0x2410, tcphy->base + RX_PSC_A3(lane));\r\nwritel(0x23ff, tcphy->base + RX_PSC_CAL(lane));\r\nwritel(0x13, tcphy->base + RX_SIGDET_HL_FILT_TMR(lane));\r\nwritel(0x03e7, tcphy->base + RX_REE_CTRL_DATA_MASK(lane));\r\nwritel(0x1004, tcphy->base + RX_DIAG_SIGDET_TUNE(lane));\r\nwritel(0x2010, tcphy->base + RX_PSC_RDY(lane));\r\nwritel(0xfb, tcphy->base + XCVR_DIAG_BIDI_CTRL(lane));\r\n}\r\nstatic void tcphy_dp_cfg_lane(struct rockchip_typec_phy *tcphy, u32 lane)\r\n{\r\nu16 rdata;\r\nwritel(0xbefc, tcphy->base + XCVR_PSM_RCTRL(lane));\r\nwritel(0x6799, tcphy->base + TX_PSC_A0(lane));\r\nwritel(0x6798, tcphy->base + TX_PSC_A1(lane));\r\nwritel(0x98, tcphy->base + TX_PSC_A2(lane));\r\nwritel(0x98, tcphy->base + TX_PSC_A3(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_000(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_001(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_010(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_011(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_100(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_101(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_110(lane));\r\nwritel(0, tcphy->base + TX_TXCC_MGNFS_MULT_111(lane));\r\nwritel(0, tcphy->base + TX_TXCC_CPOST_MULT_10(lane));\r\nwritel(0, tcphy->base + TX_TXCC_CPOST_MULT_01(lane));\r\nwritel(0, tcphy->base + TX_TXCC_CPOST_MULT_00(lane));\r\nwritel(0, tcphy->base + TX_TXCC_CPOST_MULT_11(lane));\r\nwritel(0x128, tcphy->base + TX_TXCC_CAL_SCLR_MULT(lane));\r\nwritel(0x400, tcphy->base + TX_DIAG_TX_DRV(lane));\r\nrdata = readl(tcphy->base + XCVR_DIAG_PLLDRC_CTRL(lane));\r\nrdata = (rdata & 0x8fff) | 0x6000;\r\nwritel(rdata, tcphy->base + XCVR_DIAG_PLLDRC_CTRL(lane));\r\n}\r\nstatic inline int property_enable(struct rockchip_typec_phy *tcphy,\r\nconst struct usb3phy_reg *reg, bool en)\r\n{\r\nu32 mask = 1 << reg->write_enable;\r\nu32 val = en << reg->enable_bit;\r\nreturn regmap_write(tcphy->grf_regs, reg->offset, val | mask);\r\n}\r\nstatic void tcphy_dp_aux_calibration(struct rockchip_typec_phy *tcphy)\r\n{\r\nu16 rdata, rdata2, val;\r\nrdata = readl(tcphy->base + TX_ANA_CTRL_REG_1);\r\nval = rdata & 0xdfff;\r\nwritel(val, tcphy->base + TX_ANA_CTRL_REG_1);\r\nrdata = readl(tcphy->base + TX_DIG_CTRL_REG_2);\r\nrdata = rdata & 0xffc0;\r\nrdata2 = readl(tcphy->base + CMN_TXPUCAL_CTRL);\r\nrdata2 = rdata2 & 0x3f;\r\nval = rdata | rdata2;\r\nwritel(val, tcphy->base + TX_DIG_CTRL_REG_2);\r\nusleep_range(1000, 1050);\r\nrdata = readl(tcphy->base + TX_ANA_CTRL_REG_1);\r\nval = rdata | 0x2000;\r\nwritel(val, tcphy->base + TX_ANA_CTRL_REG_1);\r\nusleep_range(150, 200);\r\nwritel(0, tcphy->base + PHY_DP_TX_CTL);\r\nwritel(0x100, tcphy->base + TX_ANA_CTRL_REG_2);\r\nwritel(0x300, tcphy->base + TX_ANA_CTRL_REG_2);\r\nwritel(0x2008, tcphy->base + TX_ANA_CTRL_REG_1);\r\nwritel(0x2018, tcphy->base + TX_ANA_CTRL_REG_1);\r\nwritel(0, tcphy->base + TX_ANA_CTRL_REG_5);\r\nwritel(0x1001, tcphy->base + TX_ANA_CTRL_REG_4);\r\nwritel(0x2098, tcphy->base + TX_ANA_CTRL_REG_1);\r\nwritel(0x2198, tcphy->base + TX_ANA_CTRL_REG_1);\r\nwritel(0x301, tcphy->base + TX_ANA_CTRL_REG_2);\r\nwritel(0x303, tcphy->base + TX_ANA_CTRL_REG_2);\r\nval = 0xa078;\r\nif (!tcphy->flip)\r\nval |= BIT(12);\r\nwritel(val, tcphy->base + TX_ANA_CTRL_REG_1);\r\nwritel(0, tcphy->base + TX_ANA_CTRL_REG_3);\r\nwritel(0, tcphy->base + TX_ANA_CTRL_REG_4);\r\nwritel(0, tcphy->base + TX_ANA_CTRL_REG_5);\r\nwritel(4, tcphy->base + TXDA_COEFF_CALC_CTRL);\r\nwritel(0, tcphy->base + TXDA_CYA_AUXDA_CYA);\r\nval = readl(tcphy->base + TX_DIG_CTRL_REG_2);\r\nval |= BIT(15);\r\nwritel(val, tcphy->base + TX_DIG_CTRL_REG_2);\r\n}\r\nstatic int tcphy_phy_init(struct rockchip_typec_phy *tcphy, u8 mode)\r\n{\r\nstruct rockchip_usb3phy_port_cfg *cfg = &tcphy->port_cfgs;\r\nint ret, i;\r\nu32 val;\r\nret = clk_prepare_enable(tcphy->clk_core);\r\nif (ret) {\r\ndev_err(tcphy->dev, "Failed to prepare_enable core clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(tcphy->clk_ref);\r\nif (ret) {\r\ndev_err(tcphy->dev, "Failed to prepare_enable ref clock\n");\r\ngoto err_clk_core;\r\n}\r\nreset_control_deassert(tcphy->tcphy_rst);\r\nproperty_enable(tcphy, &cfg->typec_conn_dir, tcphy->flip);\r\ntcphy_cfg_24m(tcphy);\r\nif (mode == MODE_DFP_DP) {\r\ntcphy_cfg_dp_pll(tcphy);\r\nfor (i = 0; i < 4; i++)\r\ntcphy_dp_cfg_lane(tcphy, i);\r\nwritel(PIN_ASSIGN_C_E, tcphy->base + PMA_LANE_CFG);\r\n} else {\r\ntcphy_cfg_usb3_pll(tcphy);\r\ntcphy_cfg_dp_pll(tcphy);\r\nif (tcphy->flip) {\r\ntcphy_tx_usb3_cfg_lane(tcphy, 3);\r\ntcphy_rx_usb3_cfg_lane(tcphy, 2);\r\ntcphy_dp_cfg_lane(tcphy, 0);\r\ntcphy_dp_cfg_lane(tcphy, 1);\r\n} else {\r\ntcphy_tx_usb3_cfg_lane(tcphy, 0);\r\ntcphy_rx_usb3_cfg_lane(tcphy, 1);\r\ntcphy_dp_cfg_lane(tcphy, 2);\r\ntcphy_dp_cfg_lane(tcphy, 3);\r\n}\r\nwritel(PIN_ASSIGN_D_F, tcphy->base + PMA_LANE_CFG);\r\n}\r\nwritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\r\nreset_control_deassert(tcphy->uphy_rst);\r\nret = readx_poll_timeout(readl, tcphy->base + PMA_CMN_CTRL1,\r\nval, val & CMN_READY, 10,\r\nPHY_MODE_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(tcphy->dev, "wait pma ready timeout\n");\r\nret = -ETIMEDOUT;\r\ngoto err_wait_pma;\r\n}\r\nreset_control_deassert(tcphy->pipe_rst);\r\nreturn 0;\r\nerr_wait_pma:\r\nreset_control_assert(tcphy->uphy_rst);\r\nreset_control_assert(tcphy->tcphy_rst);\r\nclk_disable_unprepare(tcphy->clk_ref);\r\nerr_clk_core:\r\nclk_disable_unprepare(tcphy->clk_core);\r\nreturn ret;\r\n}\r\nstatic void tcphy_phy_deinit(struct rockchip_typec_phy *tcphy)\r\n{\r\nreset_control_assert(tcphy->tcphy_rst);\r\nreset_control_assert(tcphy->uphy_rst);\r\nreset_control_assert(tcphy->pipe_rst);\r\nclk_disable_unprepare(tcphy->clk_core);\r\nclk_disable_unprepare(tcphy->clk_ref);\r\n}\r\nstatic int tcphy_get_mode(struct rockchip_typec_phy *tcphy)\r\n{\r\nstruct extcon_dev *edev = tcphy->extcon;\r\nunion extcon_property_value property;\r\nunsigned int id;\r\nbool dfp, ufp, dp;\r\nu8 mode;\r\nint ret;\r\nufp = extcon_get_state(edev, EXTCON_USB);\r\ndfp = extcon_get_state(edev, EXTCON_USB_HOST);\r\ndp = extcon_get_state(edev, EXTCON_DISP_DP);\r\nmode = MODE_DFP_USB;\r\nid = EXTCON_USB_HOST;\r\nif (ufp) {\r\nmode = MODE_UFP_USB;\r\nid = EXTCON_USB;\r\n} else if (dp) {\r\nmode = MODE_DFP_DP;\r\nid = EXTCON_DISP_DP;\r\nret = extcon_get_property(edev, id, EXTCON_PROP_USB_SS,\r\n&property);\r\nif (ret) {\r\ndev_err(tcphy->dev, "get superspeed property failed\n");\r\nreturn ret;\r\n}\r\nif (property.intval)\r\nmode |= MODE_DFP_USB;\r\n}\r\nret = extcon_get_property(edev, id, EXTCON_PROP_USB_TYPEC_POLARITY,\r\n&property);\r\nif (ret) {\r\ndev_err(tcphy->dev, "get polarity property failed\n");\r\nreturn ret;\r\n}\r\ntcphy->flip = property.intval ? 1 : 0;\r\nreturn mode;\r\n}\r\nstatic int rockchip_usb3_phy_power_on(struct phy *phy)\r\n{\r\nstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\r\nstruct rockchip_usb3phy_port_cfg *cfg = &tcphy->port_cfgs;\r\nconst struct usb3phy_reg *reg = &cfg->pipe_status;\r\nint timeout, new_mode, ret = 0;\r\nu32 val;\r\nmutex_lock(&tcphy->lock);\r\nnew_mode = tcphy_get_mode(tcphy);\r\nif (new_mode < 0) {\r\nret = new_mode;\r\ngoto unlock_ret;\r\n}\r\nif (!(new_mode & (MODE_DFP_USB | MODE_UFP_USB)))\r\ngoto unlock_ret;\r\nif (tcphy->mode == new_mode)\r\ngoto unlock_ret;\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ntcphy_phy_init(tcphy, new_mode);\r\nfor (timeout = 0; timeout < 100; timeout++) {\r\nregmap_read(tcphy->grf_regs, reg->offset, &val);\r\nif (!(val & BIT(reg->enable_bit))) {\r\ntcphy->mode |= new_mode & (MODE_DFP_USB | MODE_UFP_USB);\r\ngoto unlock_ret;\r\n}\r\nusleep_range(10, 20);\r\n}\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ntcphy_phy_deinit(tcphy);\r\nret = -ETIMEDOUT;\r\nunlock_ret:\r\nmutex_unlock(&tcphy->lock);\r\nreturn ret;\r\n}\r\nstatic int rockchip_usb3_phy_power_off(struct phy *phy)\r\n{\r\nstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\r\nmutex_lock(&tcphy->lock);\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ngoto unlock;\r\ntcphy->mode &= ~(MODE_UFP_USB | MODE_DFP_USB);\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ntcphy_phy_deinit(tcphy);\r\nunlock:\r\nmutex_unlock(&tcphy->lock);\r\nreturn 0;\r\n}\r\nstatic int rockchip_dp_phy_power_on(struct phy *phy)\r\n{\r\nstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\r\nint new_mode, ret = 0;\r\nu32 val;\r\nmutex_lock(&tcphy->lock);\r\nnew_mode = tcphy_get_mode(tcphy);\r\nif (new_mode < 0) {\r\nret = new_mode;\r\ngoto unlock_ret;\r\n}\r\nif (!(new_mode & MODE_DFP_DP)) {\r\nret = -ENODEV;\r\ngoto unlock_ret;\r\n}\r\nif (tcphy->mode == new_mode)\r\ngoto unlock_ret;\r\nif (new_mode == MODE_DFP_DP && tcphy->mode != MODE_DISCONNECT) {\r\ntcphy_phy_deinit(tcphy);\r\ntcphy_phy_init(tcphy, new_mode);\r\n} else if (tcphy->mode == MODE_DISCONNECT) {\r\ntcphy_phy_init(tcphy, new_mode);\r\n}\r\nret = readx_poll_timeout(readl, tcphy->base + DP_MODE_CTL,\r\nval, val & DP_MODE_A2, 1000,\r\nPHY_MODE_SET_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(tcphy->dev, "failed to wait TCPHY enter A2\n");\r\ngoto power_on_finish;\r\n}\r\ntcphy_dp_aux_calibration(tcphy);\r\nwritel(DP_MODE_ENTER_A0, tcphy->base + DP_MODE_CTL);\r\nret = readx_poll_timeout(readl, tcphy->base + DP_MODE_CTL,\r\nval, val & DP_MODE_A0, 1000,\r\nPHY_MODE_SET_TIMEOUT);\r\nif (ret < 0) {\r\nwritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\r\ndev_err(tcphy->dev, "failed to wait TCPHY enter A0\n");\r\ngoto power_on_finish;\r\n}\r\ntcphy->mode |= MODE_DFP_DP;\r\npower_on_finish:\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ntcphy_phy_deinit(tcphy);\r\nunlock_ret:\r\nmutex_unlock(&tcphy->lock);\r\nreturn ret;\r\n}\r\nstatic int rockchip_dp_phy_power_off(struct phy *phy)\r\n{\r\nstruct rockchip_typec_phy *tcphy = phy_get_drvdata(phy);\r\nmutex_lock(&tcphy->lock);\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ngoto unlock;\r\ntcphy->mode &= ~MODE_DFP_DP;\r\nwritel(DP_MODE_ENTER_A2, tcphy->base + DP_MODE_CTL);\r\nif (tcphy->mode == MODE_DISCONNECT)\r\ntcphy_phy_deinit(tcphy);\r\nunlock:\r\nmutex_unlock(&tcphy->lock);\r\nreturn 0;\r\n}\r\nstatic int tcphy_get_param(struct device *dev,\r\nstruct usb3phy_reg *reg,\r\nconst char *name)\r\n{\r\nu32 buffer[3];\r\nint ret;\r\nret = of_property_read_u32_array(dev->of_node, name, buffer, 3);\r\nif (ret) {\r\ndev_err(dev, "Can not parse %s\n", name);\r\nreturn ret;\r\n}\r\nreg->offset = buffer[0];\r\nreg->enable_bit = buffer[1];\r\nreg->write_enable = buffer[2];\r\nreturn 0;\r\n}\r\nstatic int tcphy_parse_dt(struct rockchip_typec_phy *tcphy,\r\nstruct device *dev)\r\n{\r\nstruct rockchip_usb3phy_port_cfg *cfg = &tcphy->port_cfgs;\r\nint ret;\r\nret = tcphy_get_param(dev, &cfg->typec_conn_dir,\r\n"rockchip,typec-conn-dir");\r\nif (ret)\r\nreturn ret;\r\nret = tcphy_get_param(dev, &cfg->usb3tousb2_en,\r\n"rockchip,usb3tousb2-en");\r\nif (ret)\r\nreturn ret;\r\nret = tcphy_get_param(dev, &cfg->external_psm,\r\n"rockchip,external-psm");\r\nif (ret)\r\nreturn ret;\r\nret = tcphy_get_param(dev, &cfg->pipe_status,\r\n"rockchip,pipe-status");\r\nif (ret)\r\nreturn ret;\r\ntcphy->grf_regs = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"rockchip,grf");\r\nif (IS_ERR(tcphy->grf_regs)) {\r\ndev_err(dev, "could not find grf dt node\n");\r\nreturn PTR_ERR(tcphy->grf_regs);\r\n}\r\ntcphy->clk_core = devm_clk_get(dev, "tcpdcore");\r\nif (IS_ERR(tcphy->clk_core)) {\r\ndev_err(dev, "could not get uphy core clock\n");\r\nreturn PTR_ERR(tcphy->clk_core);\r\n}\r\ntcphy->clk_ref = devm_clk_get(dev, "tcpdphy-ref");\r\nif (IS_ERR(tcphy->clk_ref)) {\r\ndev_err(dev, "could not get uphy ref clock\n");\r\nreturn PTR_ERR(tcphy->clk_ref);\r\n}\r\ntcphy->uphy_rst = devm_reset_control_get(dev, "uphy");\r\nif (IS_ERR(tcphy->uphy_rst)) {\r\ndev_err(dev, "no uphy_rst reset control found\n");\r\nreturn PTR_ERR(tcphy->uphy_rst);\r\n}\r\ntcphy->pipe_rst = devm_reset_control_get(dev, "uphy-pipe");\r\nif (IS_ERR(tcphy->pipe_rst)) {\r\ndev_err(dev, "no pipe_rst reset control found\n");\r\nreturn PTR_ERR(tcphy->pipe_rst);\r\n}\r\ntcphy->tcphy_rst = devm_reset_control_get(dev, "uphy-tcphy");\r\nif (IS_ERR(tcphy->tcphy_rst)) {\r\ndev_err(dev, "no tcphy_rst reset control found\n");\r\nreturn PTR_ERR(tcphy->tcphy_rst);\r\n}\r\nreturn 0;\r\n}\r\nstatic void typec_phy_pre_init(struct rockchip_typec_phy *tcphy)\r\n{\r\nstruct rockchip_usb3phy_port_cfg *cfg = &tcphy->port_cfgs;\r\nreset_control_assert(tcphy->tcphy_rst);\r\nreset_control_assert(tcphy->uphy_rst);\r\nreset_control_assert(tcphy->pipe_rst);\r\nproperty_enable(tcphy, &cfg->external_psm, 1);\r\nproperty_enable(tcphy, &cfg->usb3tousb2_en, 0);\r\ntcphy->mode = MODE_DISCONNECT;\r\n}\r\nstatic int rockchip_typec_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child_np;\r\nstruct rockchip_typec_phy *tcphy;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *res;\r\nint ret;\r\ntcphy = devm_kzalloc(dev, sizeof(*tcphy), GFP_KERNEL);\r\nif (!tcphy)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntcphy->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(tcphy->base))\r\nreturn PTR_ERR(tcphy->base);\r\nret = tcphy_parse_dt(tcphy, dev);\r\nif (ret)\r\nreturn ret;\r\ntcphy->dev = dev;\r\nplatform_set_drvdata(pdev, tcphy);\r\nmutex_init(&tcphy->lock);\r\ntypec_phy_pre_init(tcphy);\r\ntcphy->extcon = extcon_get_edev_by_phandle(dev, 0);\r\nif (IS_ERR(tcphy->extcon)) {\r\nif (PTR_ERR(tcphy->extcon) != -EPROBE_DEFER)\r\ndev_err(dev, "Invalid or missing extcon\n");\r\nreturn PTR_ERR(tcphy->extcon);\r\n}\r\npm_runtime_enable(dev);\r\nfor_each_available_child_of_node(np, child_np) {\r\nstruct phy *phy;\r\nif (!of_node_cmp(child_np->name, "dp-port"))\r\nphy = devm_phy_create(dev, child_np,\r\n&rockchip_dp_phy_ops);\r\nelse if (!of_node_cmp(child_np->name, "usb3-port"))\r\nphy = devm_phy_create(dev, child_np,\r\n&rockchip_usb3_phy_ops);\r\nelse\r\ncontinue;\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create phy: %s\n",\r\nchild_np->name);\r\nreturn PTR_ERR(phy);\r\n}\r\nphy_set_drvdata(phy, tcphy);\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nif (IS_ERR(phy_provider)) {\r\ndev_err(dev, "Failed to register phy provider\n");\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_typec_phy_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
