static const struct mrfld_family *mrfld_get_family(struct mrfld_pinctrl *mp,\r\nunsigned int pin)\r\n{\r\nconst struct mrfld_family *family;\r\nunsigned int i;\r\nfor (i = 0; i < mp->nfamilies; i++) {\r\nfamily = &mp->families[i];\r\nif (pin >= family->pin_base &&\r\npin < family->pin_base + family->npins)\r\nreturn family;\r\n}\r\ndev_warn(mp->dev, "failed to find family for pin %u\n", pin);\r\nreturn NULL;\r\n}\r\nstatic bool mrfld_buf_available(struct mrfld_pinctrl *mp, unsigned int pin)\r\n{\r\nconst struct mrfld_family *family;\r\nfamily = mrfld_get_family(mp, pin);\r\nif (!family)\r\nreturn false;\r\nreturn !family->protected;\r\n}\r\nstatic void __iomem *mrfld_get_bufcfg(struct mrfld_pinctrl *mp, unsigned int pin)\r\n{\r\nconst struct mrfld_family *family;\r\nunsigned int bufno;\r\nfamily = mrfld_get_family(mp, pin);\r\nif (!family)\r\nreturn NULL;\r\nbufno = pin_to_bufno(family, pin);\r\nreturn family->regs + BUFCFG_OFFSET + bufno * 4;\r\n}\r\nstatic int mrfld_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nreturn mp->ngroups;\r\n}\r\nstatic const char *mrfld_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned int group)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nreturn mp->groups[group].name;\r\n}\r\nstatic int mrfld_get_group_pins(struct pinctrl_dev *pctldev, unsigned int group,\r\nconst unsigned int **pins, unsigned int *npins)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = mp->groups[group].pins;\r\n*npins = mp->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void mrfld_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned int pin)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *bufcfg;\r\nu32 value, mode;\r\nif (!mrfld_buf_available(mp, pin)) {\r\nseq_puts(s, "not available");\r\nreturn;\r\n}\r\nbufcfg = mrfld_get_bufcfg(mp, pin);\r\nvalue = readl(bufcfg);\r\nmode = (value & BUFCFG_PINMODE_MASK) >> BUFCFG_PINMODE_SHIFT;\r\nif (!mode)\r\nseq_puts(s, "GPIO ");\r\nelse\r\nseq_printf(s, "mode %d ", mode);\r\nseq_printf(s, "0x%08x", value);\r\n}\r\nstatic int mrfld_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nreturn mp->nfunctions;\r\n}\r\nstatic const char *mrfld_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned int function)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nreturn mp->functions[function].name;\r\n}\r\nstatic int mrfld_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned int function,\r\nconst char * const **groups,\r\nunsigned int * const ngroups)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = mp->functions[function].groups;\r\n*ngroups = mp->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic void mrfld_update_bufcfg(struct mrfld_pinctrl *mp, unsigned int pin,\r\nu32 bits, u32 mask)\r\n{\r\nvoid __iomem *bufcfg;\r\nu32 value;\r\nbufcfg = mrfld_get_bufcfg(mp, pin);\r\nvalue = readl(bufcfg);\r\nvalue &= ~mask;\r\nvalue |= bits & mask;\r\nwritel(value, bufcfg);\r\n}\r\nstatic int mrfld_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned int function,\r\nunsigned int group)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct intel_pingroup *grp = &mp->groups[group];\r\nu32 bits = grp->mode << BUFCFG_PINMODE_SHIFT;\r\nu32 mask = BUFCFG_PINMODE_MASK;\r\nunsigned long flags;\r\nunsigned int i;\r\nfor (i = 0; i < grp->npins; i++) {\r\nif (!mrfld_buf_available(mp, grp->pins[i]))\r\nreturn -EBUSY;\r\n}\r\nraw_spin_lock_irqsave(&mp->lock, flags);\r\nfor (i = 0; i < grp->npins; i++)\r\nmrfld_update_bufcfg(mp, grp->pins[i], bits, mask);\r\nraw_spin_unlock_irqrestore(&mp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned int pin)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nu32 bits = BUFCFG_PINMODE_GPIO << BUFCFG_PINMODE_SHIFT;\r\nu32 mask = BUFCFG_PINMODE_MASK;\r\nunsigned long flags;\r\nif (!mrfld_buf_available(mp, pin))\r\nreturn -EBUSY;\r\nraw_spin_lock_irqsave(&mp->lock, flags);\r\nmrfld_update_bufcfg(mp, pin, bits, mask);\r\nraw_spin_unlock_irqrestore(&mp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nu32 value, term;\r\nu16 arg = 0;\r\nif (!mrfld_buf_available(mp, pin))\r\nreturn -ENOTSUPP;\r\nvalue = readl(mrfld_get_bufcfg(mp, pin));\r\nterm = (value & BUFCFG_PUPD_VAL_MASK) >> BUFCFG_PUPD_VAL_SHIFT;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (value & BUFCFG_Px_EN_MASK)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif ((value & BUFCFG_Px_EN_MASK) != BUFCFG_PU_EN)\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase BUFCFG_PUPD_VAL_910:\r\narg = 910;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_2K:\r\narg = 2000;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_20K:\r\narg = 20000;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_50K:\r\narg = 50000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif ((value & BUFCFG_Px_EN_MASK) != BUFCFG_PD_EN)\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase BUFCFG_PUPD_VAL_910:\r\narg = 910;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_2K:\r\narg = 2000;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_20K:\r\narg = 20000;\r\nbreak;\r\ncase BUFCFG_PUPD_VAL_50K:\r\narg = 50000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!(value & BUFCFG_OD_EN))\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nif (!(value & BUFCFG_SLEWSEL))\r\narg = 0;\r\nelse\r\narg = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int mrfld_config_set_pin(struct mrfld_pinctrl *mp, unsigned int pin,\r\nunsigned long config)\r\n{\r\nunsigned int param = pinconf_to_config_param(config);\r\nunsigned int arg = pinconf_to_config_argument(config);\r\nu32 bits = 0, mask = 0;\r\nunsigned long flags;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nmask |= BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nmask |= BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\r\nbits |= BUFCFG_PU_EN;\r\nswitch (arg) {\r\ncase 50000:\r\nbits |= BUFCFG_PUPD_VAL_50K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ncase 20000:\r\nbits |= BUFCFG_PUPD_VAL_20K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ncase 2000:\r\nbits |= BUFCFG_PUPD_VAL_2K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nmask |= BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\r\nbits |= BUFCFG_PD_EN;\r\nswitch (arg) {\r\ncase 50000:\r\nbits |= BUFCFG_PUPD_VAL_50K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ncase 20000:\r\nbits |= BUFCFG_PUPD_VAL_20K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ncase 2000:\r\nbits |= BUFCFG_PUPD_VAL_2K << BUFCFG_PUPD_VAL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nmask |= BUFCFG_OD_EN;\r\nif (arg)\r\nbits |= BUFCFG_OD_EN;\r\nbreak;\r\ncase PIN_CONFIG_SLEW_RATE:\r\nmask |= BUFCFG_SLEWSEL;\r\nif (arg)\r\nbits |= BUFCFG_SLEWSEL;\r\nbreak;\r\n}\r\nraw_spin_lock_irqsave(&mp->lock, flags);\r\nmrfld_update_bufcfg(mp, pin, bits, mask);\r\nraw_spin_unlock_irqrestore(&mp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mrfld_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned int nconfigs)\r\n{\r\nstruct mrfld_pinctrl *mp = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned int i;\r\nint ret;\r\nif (!mrfld_buf_available(mp, pin))\r\nreturn -ENOTSUPP;\r\nfor (i = 0; i < nconfigs; i++) {\r\nswitch (pinconf_to_config_param(configs[i])) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\ncase PIN_CONFIG_SLEW_RATE:\r\nret = mrfld_config_set_pin(mp, pin, configs[i]);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrfld_config_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *config)\r\n{\r\nconst unsigned int *pins;\r\nunsigned int npins;\r\nint ret;\r\nret = mrfld_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nret = mrfld_config_get(pctldev, pins[0], config);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mrfld_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *configs,\r\nunsigned int num_configs)\r\n{\r\nconst unsigned int *pins;\r\nunsigned int npins;\r\nint i, ret;\r\nret = mrfld_get_group_pins(pctldev, group, &pins, &npins);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < npins; i++) {\r\nret = mrfld_config_set(pctldev, pins[i], configs, num_configs);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrfld_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct mrfld_family *families;\r\nstruct mrfld_pinctrl *mp;\r\nstruct resource *mem;\r\nvoid __iomem *regs;\r\nsize_t nfamilies;\r\nunsigned int i;\r\nmp = devm_kzalloc(&pdev->dev, sizeof(*mp), GFP_KERNEL);\r\nif (!mp)\r\nreturn -ENOMEM;\r\nmp->dev = &pdev->dev;\r\nraw_spin_lock_init(&mp->lock);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nnfamilies = ARRAY_SIZE(mrfld_families),\r\nfamilies = devm_kmemdup(&pdev->dev, mrfld_families,\r\nsizeof(mrfld_families),\r\nGFP_KERNEL);\r\nif (!families)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nfamilies; i++) {\r\nstruct mrfld_family *family = &families[i];\r\nfamily->regs = regs + family->barno * MRFLD_FAMILY_LEN;\r\n}\r\nmp->families = families;\r\nmp->nfamilies = nfamilies;\r\nmp->functions = mrfld_functions;\r\nmp->nfunctions = ARRAY_SIZE(mrfld_functions);\r\nmp->groups = mrfld_groups;\r\nmp->ngroups = ARRAY_SIZE(mrfld_groups);\r\nmp->pctldesc = mrfld_pinctrl_desc;\r\nmp->pctldesc.name = dev_name(&pdev->dev);\r\nmp->pctldesc.pins = mrfld_pins;\r\nmp->pctldesc.npins = ARRAY_SIZE(mrfld_pins);\r\nmp->pctldev = devm_pinctrl_register(&pdev->dev, &mp->pctldesc, mp);\r\nif (IS_ERR(mp->pctldev)) {\r\ndev_err(&pdev->dev, "failed to register pinctrl driver\n");\r\nreturn PTR_ERR(mp->pctldev);\r\n}\r\nplatform_set_drvdata(pdev, mp);\r\nreturn 0;\r\n}\r\nstatic int __init mrfld_pinctrl_init(void)\r\n{\r\nreturn platform_driver_register(&mrfld_pinctrl_driver);\r\n}\r\nstatic void __exit mrfld_pinctrl_exit(void)\r\n{\r\nplatform_driver_unregister(&mrfld_pinctrl_driver);\r\n}
