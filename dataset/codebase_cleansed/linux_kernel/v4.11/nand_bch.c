int nand_bch_calculate_ecc(struct mtd_info *mtd, const unsigned char *buf,\r\nunsigned char *code)\r\n{\r\nconst struct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct nand_bch_control *nbc = chip->ecc.priv;\r\nunsigned int i;\r\nmemset(code, 0, chip->ecc.bytes);\r\nencode_bch(nbc->bch, buf, chip->ecc.size, code);\r\nfor (i = 0; i < chip->ecc.bytes; i++)\r\ncode[i] ^= nbc->eccmask[i];\r\nreturn 0;\r\n}\r\nint nand_bch_correct_data(struct mtd_info *mtd, unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc)\r\n{\r\nconst struct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct nand_bch_control *nbc = chip->ecc.priv;\r\nunsigned int *errloc = nbc->errloc;\r\nint i, count;\r\ncount = decode_bch(nbc->bch, NULL, chip->ecc.size, read_ecc, calc_ecc,\r\nNULL, errloc);\r\nif (count > 0) {\r\nfor (i = 0; i < count; i++) {\r\nif (errloc[i] < (chip->ecc.size*8))\r\nbuf[errloc[i] >> 3] ^= (1 << (errloc[i] & 7));\r\npr_debug("%s: corrected bitflip %u\n", __func__,\r\nerrloc[i]);\r\n}\r\n} else if (count < 0) {\r\nprintk(KERN_ERR "ecc unrecoverable error\n");\r\ncount = -EBADMSG;\r\n}\r\nreturn count;\r\n}\r\nstruct nand_bch_control *nand_bch_init(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand = mtd_to_nand(mtd);\r\nunsigned int m, t, eccsteps, i;\r\nstruct nand_bch_control *nbc = NULL;\r\nunsigned char *erased_page;\r\nunsigned int eccsize = nand->ecc.size;\r\nunsigned int eccbytes = nand->ecc.bytes;\r\nunsigned int eccstrength = nand->ecc.strength;\r\nif (!eccbytes && eccstrength) {\r\neccbytes = DIV_ROUND_UP(eccstrength * fls(8 * eccsize), 8);\r\nnand->ecc.bytes = eccbytes;\r\n}\r\nif (!eccsize || !eccbytes) {\r\nprintk(KERN_WARNING "ecc parameters not supplied\n");\r\ngoto fail;\r\n}\r\nm = fls(1+8*eccsize);\r\nt = (eccbytes*8)/m;\r\nnbc = kzalloc(sizeof(*nbc), GFP_KERNEL);\r\nif (!nbc)\r\ngoto fail;\r\nnbc->bch = init_bch(m, t, 0);\r\nif (!nbc->bch)\r\ngoto fail;\r\nif (nbc->bch->ecc_bytes != eccbytes) {\r\nprintk(KERN_WARNING "invalid eccbytes %u, should be %u\n",\r\neccbytes, nbc->bch->ecc_bytes);\r\ngoto fail;\r\n}\r\neccsteps = mtd->writesize/eccsize;\r\nif (!mtd->ooblayout) {\r\npr_warn("missing oob scheme");\r\ngoto fail;\r\n}\r\nif (8*(eccsize+eccbytes) >= (1 << m)) {\r\nprintk(KERN_WARNING "eccsize %u is too large\n", eccsize);\r\ngoto fail;\r\n}\r\nnand->ecc.steps = eccsteps;\r\nnand->ecc.total = eccsteps * eccbytes;\r\nif (mtd_ooblayout_count_eccbytes(mtd) != (eccsteps*eccbytes)) {\r\nprintk(KERN_WARNING "invalid ecc layout\n");\r\ngoto fail;\r\n}\r\nnbc->eccmask = kmalloc(eccbytes, GFP_KERNEL);\r\nnbc->errloc = kmalloc(t*sizeof(*nbc->errloc), GFP_KERNEL);\r\nif (!nbc->eccmask || !nbc->errloc)\r\ngoto fail;\r\nerased_page = kmalloc(eccsize, GFP_KERNEL);\r\nif (!erased_page)\r\ngoto fail;\r\nmemset(erased_page, 0xff, eccsize);\r\nmemset(nbc->eccmask, 0, eccbytes);\r\nencode_bch(nbc->bch, erased_page, eccsize, nbc->eccmask);\r\nkfree(erased_page);\r\nfor (i = 0; i < eccbytes; i++)\r\nnbc->eccmask[i] ^= 0xff;\r\nif (!eccstrength)\r\nnand->ecc.strength = (eccbytes * 8) / fls(8 * eccsize);\r\nreturn nbc;\r\nfail:\r\nnand_bch_free(nbc);\r\nreturn NULL;\r\n}\r\nvoid nand_bch_free(struct nand_bch_control *nbc)\r\n{\r\nif (nbc) {\r\nfree_bch(nbc->bch);\r\nkfree(nbc->errloc);\r\nkfree(nbc->eccmask);\r\nkfree(nbc);\r\n}\r\n}
