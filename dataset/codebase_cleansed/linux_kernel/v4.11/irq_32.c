unsigned long arch_local_irq_save(void)\r\n{\r\nunsigned long retval;\r\nunsigned long tmp;\r\n__asm__ __volatile__(\r\n"rd %%psr, %0\n\t"\r\n"or %0, %2, %1\n\t"\r\n"wr %1, 0, %%psr\n\t"\r\n"nop; nop; nop\n"\r\n: "=&r" (retval), "=r" (tmp)\r\n: "i" (PSR_PIL)\r\n: "memory");\r\nreturn retval;\r\n}\r\nvoid arch_local_irq_enable(void)\r\n{\r\nunsigned long tmp;\r\n__asm__ __volatile__(\r\n"rd %%psr, %0\n\t"\r\n"andn %0, %1, %0\n\t"\r\n"wr %0, 0, %%psr\n\t"\r\n"nop; nop; nop\n"\r\n: "=&r" (tmp)\r\n: "i" (PSR_PIL)\r\n: "memory");\r\n}\r\nvoid arch_local_irq_restore(unsigned long old_psr)\r\n{\r\nunsigned long tmp;\r\n__asm__ __volatile__(\r\n"rd %%psr, %0\n\t"\r\n"and %2, %1, %2\n\t"\r\n"andn %0, %1, %0\n\t"\r\n"wr %0, %2, %%psr\n\t"\r\n"nop; nop; nop\n"\r\n: "=&r" (tmp)\r\n: "i" (PSR_PIL), "r" (old_psr)\r\n: "memory");\r\n}\r\nunsigned int irq_alloc(unsigned int real_irq, unsigned int pil)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&irq_table_lock, flags);\r\nfor (i = 1; i < NR_IRQS; i++) {\r\nif (irq_table[i].real_irq == real_irq && irq_table[i].pil == pil)\r\ngoto found;\r\n}\r\nfor (i = 1; i < NR_IRQS; i++) {\r\nif (!irq_table[i].irq)\r\nbreak;\r\n}\r\nif (i < NR_IRQS) {\r\nirq_table[i].real_irq = real_irq;\r\nirq_table[i].irq = i;\r\nirq_table[i].pil = pil;\r\n} else {\r\nprintk(KERN_ERR "IRQ: Out of virtual IRQs.\n");\r\ni = 0;\r\n}\r\nfound:\r\nspin_unlock_irqrestore(&irq_table_lock, flags);\r\nreturn i;\r\n}\r\nvoid irq_link(unsigned int irq)\r\n{\r\nstruct irq_bucket *p;\r\nunsigned long flags;\r\nunsigned int pil;\r\nBUG_ON(irq >= NR_IRQS);\r\nspin_lock_irqsave(&irq_map_lock, flags);\r\np = &irq_table[irq];\r\npil = p->pil;\r\nBUG_ON(pil >= SUN4D_MAX_IRQ);\r\np->next = irq_map[pil];\r\nirq_map[pil] = p;\r\nspin_unlock_irqrestore(&irq_map_lock, flags);\r\n}\r\nvoid irq_unlink(unsigned int irq)\r\n{\r\nstruct irq_bucket *p, **pnext;\r\nunsigned long flags;\r\nBUG_ON(irq >= NR_IRQS);\r\nspin_lock_irqsave(&irq_map_lock, flags);\r\np = &irq_table[irq];\r\nBUG_ON(p->pil >= SUN4D_MAX_IRQ);\r\npnext = &irq_map[p->pil];\r\nwhile (*pnext != p)\r\npnext = &(*pnext)->next;\r\n*pnext = p->next;\r\nspin_unlock_irqrestore(&irq_map_lock, flags);\r\n}\r\nint arch_show_interrupts(struct seq_file *p, int prec)\r\n{\r\nint j;\r\n#ifdef CONFIG_SMP\r\nseq_printf(p, "RES: ");\r\nfor_each_online_cpu(j)\r\nseq_printf(p, "%10u ", cpu_data(j).irq_resched_count);\r\nseq_printf(p, " IPI rescheduling interrupts\n");\r\nseq_printf(p, "CAL: ");\r\nfor_each_online_cpu(j)\r\nseq_printf(p, "%10u ", cpu_data(j).irq_call_count);\r\nseq_printf(p, " IPI function call interrupts\n");\r\n#endif\r\nseq_printf(p, "NMI: ");\r\nfor_each_online_cpu(j)\r\nseq_printf(p, "%10u ", cpu_data(j).counter);\r\nseq_printf(p, " Non-maskable interrupts\n");\r\nreturn 0;\r\n}\r\nvoid handler_irq(unsigned int pil, struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs;\r\nstruct irq_bucket *p;\r\nBUG_ON(pil > 15);\r\nold_regs = set_irq_regs(regs);\r\nirq_enter();\r\np = irq_map[pil];\r\nwhile (p) {\r\nstruct irq_bucket *next = p->next;\r\ngeneric_handle_irq(p->irq);\r\np = next;\r\n}\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nint sparc_floppy_request_irq(unsigned int irq, irq_handler_t irq_handler)\r\n{\r\nunsigned int cpu_irq;\r\nint err;\r\nerr = request_irq(irq, irq_handler, 0, "floppy", NULL);\r\nif (err)\r\nreturn -1;\r\nfloppy_irq = irq;\r\ncpu_irq = (irq & (NR_IRQS - 1));\r\n#define INSTANTIATE(table) \\r\ntable[SP_TRAP_IRQ1+(cpu_irq-1)].inst_one = SPARC_RD_PSR_L0; \\r\ntable[SP_TRAP_IRQ1+(cpu_irq-1)].inst_two = \\r\nSPARC_BRANCH((unsigned long) floppy_hardint, \\r\n(unsigned long) &table[SP_TRAP_IRQ1+(cpu_irq-1)].inst_two);\\r\ntable[SP_TRAP_IRQ1+(cpu_irq-1)].inst_three = SPARC_RD_WIM_L3; \\r\ntable[SP_TRAP_IRQ1+(cpu_irq-1)].inst_four = SPARC_NOP;\r\nINSTANTIATE(sparc_ttable)\r\n#if defined CONFIG_SMP\r\nif (sparc_cpu_model != sparc_leon) {\r\nstruct tt_entry *trap_table;\r\ntrap_table = &trapbase_cpu1;\r\nINSTANTIATE(trap_table)\r\ntrap_table = &trapbase_cpu2;\r\nINSTANTIATE(trap_table)\r\ntrap_table = &trapbase_cpu3;\r\nINSTANTIATE(trap_table)\r\n}\r\n#endif\r\n#undef INSTANTIATE\r\nflush_cache_all();\r\nreturn 0;\r\n}\r\nvoid sparc_floppy_irq(int irq, void *dev_id, struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs;\r\nold_regs = set_irq_regs(regs);\r\nirq_enter();\r\ngeneric_handle_irq(floppy_irq);\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid __init init_IRQ(void)\r\n{\r\nswitch (sparc_cpu_model) {\r\ncase sun4m:\r\npcic_probe();\r\nif (pcic_present())\r\nsun4m_pci_init_IRQ();\r\nelse\r\nsun4m_init_IRQ();\r\nbreak;\r\ncase sun4d:\r\nsun4d_init_IRQ();\r\nbreak;\r\ncase sparc_leon:\r\nleon_init_IRQ();\r\nbreak;\r\ndefault:\r\nprom_printf("Cannot initialize IRQs on this Sun machine...");\r\nbreak;\r\n}\r\n}
