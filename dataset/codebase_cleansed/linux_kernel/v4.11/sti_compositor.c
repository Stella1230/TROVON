int sti_compositor_debugfs_init(struct sti_compositor *compo,\r\nstruct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < STI_MAX_VID; i++)\r\nif (compo->vid[i])\r\nvid_debugfs_init(compo->vid[i], minor);\r\nfor (i = 0; i < STI_MAX_MIXER; i++)\r\nif (compo->mixer[i])\r\nsti_mixer_debugfs_init(compo->mixer[i], minor);\r\nreturn 0;\r\n}\r\nstatic int sti_compositor_bind(struct device *dev,\r\nstruct device *master,\r\nvoid *data)\r\n{\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nunsigned int i, mixer_id = 0, vid_id = 0, crtc_id = 0;\r\nstruct sti_private *dev_priv = drm_dev->dev_private;\r\nstruct drm_plane *cursor = NULL;\r\nstruct drm_plane *primary = NULL;\r\nstruct sti_compositor_subdev_descriptor *desc = compo->data.subdev_desc;\r\nunsigned int array_size = compo->data.nb_subdev;\r\ndev_priv->compo = compo;\r\nfor (i = 0; i < array_size; i++) {\r\nswitch (desc[i].type) {\r\ncase STI_VID_SUBDEV:\r\ncompo->vid[vid_id++] =\r\nsti_vid_create(compo->dev, drm_dev, desc[i].id,\r\ncompo->regs + desc[i].offset);\r\nbreak;\r\ncase STI_MIXER_MAIN_SUBDEV:\r\ncase STI_MIXER_AUX_SUBDEV:\r\ncompo->mixer[mixer_id++] =\r\nsti_mixer_create(compo->dev, drm_dev, desc[i].id,\r\ncompo->regs + desc[i].offset);\r\nbreak;\r\ncase STI_GPD_SUBDEV:\r\ncase STI_CURSOR_SUBDEV:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknow subdev compoment type\n");\r\nreturn 1;\r\n}\r\n}\r\nfor (i = 0; i < array_size; i++) {\r\nenum drm_plane_type plane_type = DRM_PLANE_TYPE_OVERLAY;\r\nif (crtc_id < mixer_id)\r\nplane_type = DRM_PLANE_TYPE_PRIMARY;\r\nswitch (desc[i].type) {\r\ncase STI_MIXER_MAIN_SUBDEV:\r\ncase STI_MIXER_AUX_SUBDEV:\r\ncase STI_VID_SUBDEV:\r\nbreak;\r\ncase STI_CURSOR_SUBDEV:\r\ncursor = sti_cursor_create(drm_dev, compo->dev,\r\ndesc[i].id,\r\ncompo->regs + desc[i].offset,\r\n1);\r\nif (!cursor) {\r\nDRM_ERROR("Can't create CURSOR plane\n");\r\nbreak;\r\n}\r\nbreak;\r\ncase STI_GPD_SUBDEV:\r\nprimary = sti_gdp_create(drm_dev, compo->dev,\r\ndesc[i].id,\r\ncompo->regs + desc[i].offset,\r\n(1 << mixer_id) - 1,\r\nplane_type);\r\nif (!primary) {\r\nDRM_ERROR("Can't create GDP plane\n");\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown subdev compoment type\n");\r\nreturn 1;\r\n}\r\nif (crtc_id < mixer_id && primary) {\r\nsti_crtc_init(drm_dev, compo->mixer[crtc_id],\r\nprimary, cursor);\r\ncrtc_id++;\r\ncursor = NULL;\r\nprimary = NULL;\r\n}\r\n}\r\ndrm_vblank_init(drm_dev, crtc_id);\r\ndrm_dev->irq_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void sti_compositor_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\n}\r\nstatic int sti_compositor_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *vtg_np;\r\nstruct sti_compositor *compo;\r\nstruct resource *res;\r\nunsigned int i;\r\ncompo = devm_kzalloc(dev, sizeof(*compo), GFP_KERNEL);\r\nif (!compo) {\r\nDRM_ERROR("Failed to allocate compositor context\n");\r\nreturn -ENOMEM;\r\n}\r\ncompo->dev = dev;\r\nfor (i = 0; i < STI_MAX_MIXER; i++)\r\ncompo->vtg_vblank_nb[i].notifier_call = sti_crtc_vblank_cb;\r\nBUG_ON(!of_match_node(compositor_of_match, np)->data);\r\nmemcpy(&compo->data, of_match_node(compositor_of_match, np)->data,\r\nsizeof(struct sti_compositor_data));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENXIO;\r\n}\r\ncompo->regs = devm_ioremap(dev, res->start, resource_size(res));\r\nif (compo->regs == NULL) {\r\nDRM_ERROR("Register mapping failed\n");\r\nreturn -ENXIO;\r\n}\r\ncompo->clk_compo_main = devm_clk_get(dev, "compo_main");\r\nif (IS_ERR(compo->clk_compo_main)) {\r\nDRM_ERROR("Cannot get compo_main clock\n");\r\nreturn PTR_ERR(compo->clk_compo_main);\r\n}\r\ncompo->clk_compo_aux = devm_clk_get(dev, "compo_aux");\r\nif (IS_ERR(compo->clk_compo_aux)) {\r\nDRM_ERROR("Cannot get compo_aux clock\n");\r\nreturn PTR_ERR(compo->clk_compo_aux);\r\n}\r\ncompo->clk_pix_main = devm_clk_get(dev, "pix_main");\r\nif (IS_ERR(compo->clk_pix_main)) {\r\nDRM_ERROR("Cannot get pix_main clock\n");\r\nreturn PTR_ERR(compo->clk_pix_main);\r\n}\r\ncompo->clk_pix_aux = devm_clk_get(dev, "pix_aux");\r\nif (IS_ERR(compo->clk_pix_aux)) {\r\nDRM_ERROR("Cannot get pix_aux clock\n");\r\nreturn PTR_ERR(compo->clk_pix_aux);\r\n}\r\ncompo->rst_main = devm_reset_control_get_shared(dev, "compo-main");\r\nif (!IS_ERR(compo->rst_main))\r\nreset_control_deassert(compo->rst_main);\r\ncompo->rst_aux = devm_reset_control_get_shared(dev, "compo-aux");\r\nif (!IS_ERR(compo->rst_aux))\r\nreset_control_deassert(compo->rst_aux);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 0);\r\nif (vtg_np)\r\ncompo->vtg[STI_MIXER_MAIN] = of_vtg_find(vtg_np);\r\nof_node_put(vtg_np);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 1);\r\nif (vtg_np)\r\ncompo->vtg[STI_MIXER_AUX] = of_vtg_find(vtg_np);\r\nof_node_put(vtg_np);\r\nplatform_set_drvdata(pdev, compo);\r\nreturn component_add(&pdev->dev, &sti_compositor_ops);\r\n}\r\nstatic int sti_compositor_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_compositor_ops);\r\nreturn 0;\r\n}
