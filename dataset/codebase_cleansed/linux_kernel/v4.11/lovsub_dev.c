static int lovsub_device_init(const struct lu_env *env, struct lu_device *d,\r\nconst char *name, struct lu_device *next)\r\n{\r\nstruct lovsub_device *lsd = lu2lovsub_dev(d);\r\nstruct lu_device_type *ldt;\r\nint rc;\r\nnext->ld_site = d->ld_site;\r\nldt = next->ld_type;\r\nrc = ldt->ldt_ops->ldto_device_init(env, next, ldt->ldt_name, NULL);\r\nif (rc) {\r\nnext->ld_site = NULL;\r\nreturn rc;\r\n}\r\nlu_device_get(next);\r\nlu_ref_add(&next->ld_reference, "lu-stack", &lu_site_init);\r\nlsd->acid_next = lu2cl_dev(next);\r\nreturn rc;\r\n}\r\nstatic struct lu_device *lovsub_device_fini(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct lu_device *next;\r\nstruct lovsub_device *lsd;\r\nlsd = lu2lovsub_dev(d);\r\nnext = cl2lu_dev(lsd->acid_next);\r\nlsd->acid_super = NULL;\r\nlsd->acid_next = NULL;\r\nreturn next;\r\n}\r\nstatic struct lu_device *lovsub_device_free(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct lovsub_device *lsd = lu2lovsub_dev(d);\r\nstruct lu_device *next = cl2lu_dev(lsd->acid_next);\r\nif (atomic_read(&d->ld_ref) && d->ld_site) {\r\nLIBCFS_DEBUG_MSG_DATA_DECL(msgdata, D_ERROR, NULL);\r\nlu_site_print(env, d->ld_site, &msgdata, lu_cdebug_printer);\r\n}\r\ncl_device_fini(lu2cl_dev(d));\r\nkfree(lsd);\r\nreturn next;\r\n}\r\nstatic struct lu_device *lovsub_device_alloc(const struct lu_env *env,\r\nstruct lu_device_type *t,\r\nstruct lustre_cfg *cfg)\r\n{\r\nstruct lu_device *d;\r\nstruct lovsub_device *lsd;\r\nlsd = kzalloc(sizeof(*lsd), GFP_NOFS);\r\nif (lsd) {\r\nint result;\r\nresult = cl_device_init(&lsd->acid_cl, t);\r\nif (result == 0) {\r\nd = lovsub2lu_dev(lsd);\r\nd->ld_ops = &lovsub_lu_ops;\r\n} else {\r\nd = ERR_PTR(result);\r\n}\r\n} else {\r\nd = ERR_PTR(-ENOMEM);\r\n}\r\nreturn d;\r\n}
