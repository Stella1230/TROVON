static int dwc3_pci_quirks(struct dwc3_pci *dwc)\r\n{\r\nstruct platform_device *dwc3 = dwc->dwc3;\r\nstruct pci_dev *pdev = dwc->pci;\r\nif (pdev->vendor == PCI_VENDOR_ID_AMD &&\r\npdev->device == PCI_DEVICE_ID_AMD_NL_USB) {\r\nstruct property_entry properties[] = {\r\nPROPERTY_ENTRY_BOOL("snps,has-lpm-erratum"),\r\nPROPERTY_ENTRY_U8("snps,lpm-nyet-threshold", 0xf),\r\nPROPERTY_ENTRY_BOOL("snps,u2exit_lfps_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,u2ss_inp3_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,req_p1p2p3_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,del_p1p2p3_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,del_phy_power_chg_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,lfps_filter_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,rx_detect_poll_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,tx_de_emphasis_quirk"),\r\nPROPERTY_ENTRY_U8("snps,tx_de_emphasis", 1),\r\nPROPERTY_ENTRY_BOOL("snps,disable_scramble_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,dis_u3_susphy_quirk"),\r\nPROPERTY_ENTRY_BOOL("snps,dis_u2_susphy_quirk"),\r\nPROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),\r\n{ },\r\n};\r\nreturn platform_device_add_properties(dwc3, properties);\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\r\nint ret;\r\nstruct property_entry properties[] = {\r\nPROPERTY_ENTRY_STRING("dr_mode", "peripheral"),\r\nPROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),\r\n{ }\r\n};\r\nret = platform_device_add_properties(dwc3, properties);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pdev->device == PCI_DEVICE_ID_INTEL_BXT ||\r\npdev->device == PCI_DEVICE_ID_INTEL_BXT_M) {\r\nacpi_str_to_uuid(PCI_INTEL_BXT_DSM_UUID, dwc->uuid);\r\ndwc->has_dsm_for_pm = true;\r\n}\r\nif (pdev->device == PCI_DEVICE_ID_INTEL_BYT) {\r\nstruct gpio_desc *gpio;\r\nacpi_dev_add_driver_gpios(ACPI_COMPANION(&pdev->dev),\r\nacpi_dwc3_byt_gpios);\r\ngpio = gpiod_get_optional(&pdev->dev, "cs", GPIOD_OUT_LOW);\r\nif (IS_ERR(gpio))\r\nreturn PTR_ERR(gpio);\r\ngpiod_set_value_cansleep(gpio, 1);\r\ngpiod_put(gpio);\r\ngpio = gpiod_get_optional(&pdev->dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(gpio))\r\nreturn PTR_ERR(gpio);\r\nif (gpio) {\r\ngpiod_set_value_cansleep(gpio, 1);\r\ngpiod_put(gpio);\r\nusleep_range(10000, 11000);\r\n}\r\n}\r\n}\r\nif (pdev->vendor == PCI_VENDOR_ID_SYNOPSYS &&\r\n(pdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3 ||\r\npdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3_AXI ||\r\npdev->device == PCI_DEVICE_ID_SYNOPSYS_HAPSUSB31)) {\r\nstruct property_entry properties[] = {\r\nPROPERTY_ENTRY_BOOL("snps,usb3_lpm_capable"),\r\nPROPERTY_ENTRY_BOOL("snps,has-lpm-erratum"),\r\nPROPERTY_ENTRY_BOOL("snps,dis_enblslpm_quirk"),\r\nPROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),\r\n{ },\r\n};\r\nreturn platform_device_add_properties(dwc3, properties);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc3_pci_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct dwc3_pci *dwc;\r\nstruct resource res[2];\r\nint ret;\r\nstruct device *dev = &pci->dev;\r\nret = pcim_enable_device(pci);\r\nif (ret) {\r\ndev_err(dev, "failed to enable pci device\n");\r\nreturn -ENODEV;\r\n}\r\npci_set_master(pci);\r\ndwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\r\nif (!dwc)\r\nreturn -ENOMEM;\r\ndwc->dwc3 = platform_device_alloc("dwc3", PLATFORM_DEVID_AUTO);\r\nif (!dwc->dwc3)\r\nreturn -ENOMEM;\r\nmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\r\nres[0].start = pci_resource_start(pci, 0);\r\nres[0].end = pci_resource_end(pci, 0);\r\nres[0].name = "dwc_usb3";\r\nres[0].flags = IORESOURCE_MEM;\r\nres[1].start = pci->irq;\r\nres[1].name = "dwc_usb3";\r\nres[1].flags = IORESOURCE_IRQ;\r\nret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\r\nif (ret) {\r\ndev_err(dev, "couldn't add resources to dwc3 device\n");\r\nreturn ret;\r\n}\r\ndwc->pci = pci;\r\ndwc->dwc3->dev.parent = dev;\r\nACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\r\nret = dwc3_pci_quirks(dwc);\r\nif (ret)\r\ngoto err;\r\nret = platform_device_add(dwc->dwc3);\r\nif (ret) {\r\ndev_err(dev, "failed to register dwc3 device\n");\r\ngoto err;\r\n}\r\ndevice_init_wakeup(dev, true);\r\ndevice_set_run_wake(dev, true);\r\npci_set_drvdata(pci, dwc);\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr:\r\nplatform_device_put(dwc->dwc3);\r\nreturn ret;\r\n}\r\nstatic void dwc3_pci_remove(struct pci_dev *pci)\r\n{\r\nstruct dwc3_pci *dwc = pci_get_drvdata(pci);\r\ndevice_init_wakeup(&pci->dev, false);\r\npm_runtime_get(&pci->dev);\r\nacpi_dev_remove_driver_gpios(ACPI_COMPANION(&pci->dev));\r\nplatform_device_unregister(dwc->dwc3);\r\n}\r\nstatic int dwc3_pci_dsm(struct dwc3_pci *dwc, int param)\r\n{\r\nunion acpi_object *obj;\r\nunion acpi_object tmp;\r\nunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);\r\nif (!dwc->has_dsm_for_pm)\r\nreturn 0;\r\ntmp.type = ACPI_TYPE_INTEGER;\r\ntmp.integer.value = param;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(&dwc->pci->dev), dwc->uuid,\r\n1, PCI_INTEL_BXT_FUNC_PMU_PWR, &argv4);\r\nif (!obj) {\r\ndev_err(&dwc->pci->dev, "failed to evaluate _DSM\n");\r\nreturn -EIO;\r\n}\r\nACPI_FREE(obj);\r\nreturn 0;\r\n}\r\nstatic int dwc3_pci_runtime_suspend(struct device *dev)\r\n{\r\nstruct dwc3_pci *dwc = dev_get_drvdata(dev);\r\nif (device_run_wake(dev))\r\nreturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D3);\r\nreturn -EBUSY;\r\n}\r\nstatic int dwc3_pci_runtime_resume(struct device *dev)\r\n{\r\nstruct dwc3_pci *dwc = dev_get_drvdata(dev);\r\nstruct platform_device *dwc3 = dwc->dwc3;\r\nint ret;\r\nret = dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D0);\r\nif (ret)\r\nreturn ret;\r\nreturn pm_runtime_get(&dwc3->dev);\r\n}\r\nstatic int dwc3_pci_suspend(struct device *dev)\r\n{\r\nstruct dwc3_pci *dwc = dev_get_drvdata(dev);\r\nreturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D3);\r\n}\r\nstatic int dwc3_pci_resume(struct device *dev)\r\n{\r\nstruct dwc3_pci *dwc = dev_get_drvdata(dev);\r\nreturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D0);\r\n}
