static struct qm1d1c0042_state *cfg_to_state(struct qm1d1c0042_config *c)\r\n{\r\nreturn container_of(c, struct qm1d1c0042_state, cfg);\r\n}\r\nstatic int reg_write(struct qm1d1c0042_state *state, u8 reg, u8 val)\r\n{\r\nu8 wbuf[2] = { reg, val };\r\nint ret;\r\nret = i2c_master_send(state->i2c, wbuf, sizeof(wbuf));\r\nif (ret >= 0 && ret < sizeof(wbuf))\r\nret = -EIO;\r\nreturn (ret == sizeof(wbuf)) ? 0 : ret;\r\n}\r\nstatic int reg_read(struct qm1d1c0042_state *state, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = state->i2c->addr,\r\n.flags = 0,\r\n.buf = &reg,\r\n.len = 1,\r\n},\r\n{\r\n.addr = state->i2c->addr,\r\n.flags = I2C_M_RD,\r\n.buf = val,\r\n.len = 1,\r\n},\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret >= 0 && ret < ARRAY_SIZE(msgs))\r\nret = -EIO;\r\nreturn (ret == ARRAY_SIZE(msgs)) ? 0 : ret;\r\n}\r\nstatic int qm1d1c0042_set_srch_mode(struct qm1d1c0042_state *state, bool fast)\r\n{\r\nif (fast)\r\nstate->regs[0x03] |= 0x01;\r\nelse\r\nstate->regs[0x03] &= ~0x01 & 0xff;\r\nreturn reg_write(state, 0x03, state->regs[0x03]);\r\n}\r\nstatic int qm1d1c0042_wakeup(struct qm1d1c0042_state *state)\r\n{\r\nint ret;\r\nstate->regs[0x01] |= 1 << 3;\r\nstate->regs[0x01] &= (~(1 << 0)) & 0xff;\r\nstate->regs[0x05] &= (~(1 << 3)) & 0xff;\r\nret = reg_write(state, 0x01, state->regs[0x01]);\r\nif (ret == 0)\r\nret = reg_write(state, 0x05, state->regs[0x05]);\r\nif (ret < 0)\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, state->cfg.fe->dvb->num, state->cfg.fe->id);\r\nreturn ret;\r\n}\r\nstatic int qm1d1c0042_set_config(struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nstruct qm1d1c0042_config *cfg;\r\nstate = fe->tuner_priv;\r\ncfg = priv_cfg;\r\nif (cfg->fe)\r\nstate->cfg.fe = cfg->fe;\r\nif (cfg->xtal_freq != QM1D1C0042_CFG_XTAL_DFLT)\r\ndev_warn(&state->i2c->dev,\r\n"(%s) changing xtal_freq not supported. ", __func__);\r\nstate->cfg.xtal_freq = default_cfg.xtal_freq;\r\nstate->cfg.lpf = cfg->lpf;\r\nstate->cfg.fast_srch = cfg->fast_srch;\r\nif (cfg->lpf_wait != QM1D1C0042_CFG_WAIT_DFLT)\r\nstate->cfg.lpf_wait = cfg->lpf_wait;\r\nelse\r\nstate->cfg.lpf_wait = default_cfg.lpf_wait;\r\nif (cfg->fast_srch_wait != QM1D1C0042_CFG_WAIT_DFLT)\r\nstate->cfg.fast_srch_wait = cfg->fast_srch_wait;\r\nelse\r\nstate->cfg.fast_srch_wait = default_cfg.fast_srch_wait;\r\nif (cfg->normal_srch_wait != QM1D1C0042_CFG_WAIT_DFLT)\r\nstate->cfg.normal_srch_wait = cfg->normal_srch_wait;\r\nelse\r\nstate->cfg.normal_srch_wait = default_cfg.normal_srch_wait;\r\nreturn 0;\r\n}\r\nstatic int qm1d1c0042_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nu32 freq;\r\nint i, ret;\r\nu8 val, mask;\r\nu32 a, sd;\r\ns32 b;\r\nstate = fe->tuner_priv;\r\nfreq = fe->dtv_property_cache.frequency;\r\nstate->regs[0x08] &= 0xf0;\r\nstate->regs[0x08] |= 0x09;\r\nstate->regs[0x13] &= 0x9f;\r\nstate->regs[0x13] |= 0x20;\r\nval = state->regs[0x02] & 0x0f;\r\nfor (i = 0; i < 8; i++)\r\nif (freq < conv_table[i][0] && freq >= conv_table[i + 1][0]) {\r\nval |= conv_table[i][1] << 7;\r\nval |= conv_table[i][2] << 4;\r\nbreak;\r\n}\r\nret = reg_write(state, 0x02, val);\r\nif (ret < 0)\r\nreturn ret;\r\na = (freq + state->cfg.xtal_freq / 2) / state->cfg.xtal_freq;\r\nstate->regs[0x06] &= 0x40;\r\nstate->regs[0x06] |= (a - 12) / 4;\r\nret = reg_write(state, 0x06, state->regs[0x06]);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->regs[0x07] &= 0xf0;\r\nstate->regs[0x07] |= (a - 4 * ((a - 12) / 4 + 1) - 5) & 0x0f;\r\nret = reg_write(state, 0x07, state->regs[0x07]);\r\nif (ret < 0)\r\nreturn ret;\r\nval = state->regs[0x08];\r\nif (state->cfg.lpf) {\r\nval &= 0xf0;\r\nval |= 0x02;\r\n}\r\nret = reg_write(state, 0x08, val);\r\nif (ret < 0)\r\nreturn ret;\r\nb = (s32)div64_s64(((s64) freq) << 20, state->cfg.xtal_freq)\r\n- (((s64) a) << 20);\r\nif (b >= 0)\r\nsd = b;\r\nelse\r\nsd = (1 << 22) + b;\r\nstate->regs[0x09] &= 0xc0;\r\nstate->regs[0x09] |= (sd >> 16) & 0x3f;\r\nstate->regs[0x0a] = (sd >> 8) & 0xff;\r\nstate->regs[0x0b] = sd & 0xff;\r\nret = reg_write(state, 0x09, state->regs[0x09]);\r\nif (ret == 0)\r\nret = reg_write(state, 0x0a, state->regs[0x0a]);\r\nif (ret == 0)\r\nret = reg_write(state, 0x0b, state->regs[0x0b]);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!state->cfg.lpf) {\r\nret = reg_write(state, 0x13, state->regs[0x13]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmask = state->cfg.lpf ? 0x3f : 0x7f;\r\nval = state->regs[0x0c] & mask;\r\nret = reg_write(state, 0x0c, val);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(2000, 3000);\r\nval = state->regs[0x0c] | ~mask;\r\nret = reg_write(state, 0x0c, val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->cfg.lpf)\r\nmsleep(state->cfg.lpf_wait);\r\nelse if (state->regs[0x03] & 0x01)\r\nmsleep(state->cfg.fast_srch_wait);\r\nelse\r\nmsleep(state->cfg.normal_srch_wait);\r\nif (state->cfg.lpf) {\r\nret = reg_write(state, 0x08, 0x09);\r\nif (ret < 0)\r\nreturn ret;\r\nret = reg_write(state, 0x13, state->regs[0x13]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qm1d1c0042_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nint ret;\r\nstate = fe->tuner_priv;\r\nstate->regs[0x01] &= (~(1 << 3)) & 0xff;\r\nstate->regs[0x01] |= 1 << 0;\r\nstate->regs[0x05] |= 1 << 3;\r\nret = reg_write(state, 0x05, state->regs[0x05]);\r\nif (ret == 0)\r\nret = reg_write(state, 0x01, state->regs[0x01]);\r\nif (ret < 0)\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int qm1d1c0042_init(struct dvb_frontend *fe)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nu8 val;\r\nint i, ret;\r\nstate = fe->tuner_priv;\r\nreg_write(state, 0x01, 0x0c);\r\nreg_write(state, 0x01, 0x0c);\r\nret = reg_write(state, 0x01, 0x0c);\r\nif (ret < 0)\r\ngoto failed;\r\nusleep_range(2000, 3000);\r\nret = reg_write(state, 0x01, 0x1c);\r\nif (ret < 0)\r\ngoto failed;\r\nret = reg_read(state, 0x00, &val);\r\nif (ret < 0)\r\ngoto failed;\r\nfor (reg_index = 0; reg_index < QM1D1C0042_NUM_REG_ROWS;\r\nreg_index++) {\r\nif (val == reg_initval[reg_index][0x00])\r\nbreak;\r\n}\r\nif (reg_index >= QM1D1C0042_NUM_REG_ROWS)\r\ngoto failed;\r\nmemcpy(state->regs, reg_initval[reg_index], QM1D1C0042_NUM_REGS);\r\nusleep_range(2000, 3000);\r\nstate->regs[0x0c] |= 0x40;\r\nret = reg_write(state, 0x0c, state->regs[0x0c]);\r\nif (ret < 0)\r\ngoto failed;\r\nmsleep(state->cfg.lpf_wait);\r\nfor (i = 1; i <= 0x0c ; i++) {\r\nret = reg_write(state, i, state->regs[i]);\r\nif (ret < 0)\r\ngoto failed;\r\n}\r\nfor (i = 0x11; i < QM1D1C0042_NUM_REGS; i++) {\r\nret = reg_write(state, i, state->regs[i]);\r\nif (ret < 0)\r\ngoto failed;\r\n}\r\nret = qm1d1c0042_wakeup(state);\r\nif (ret < 0)\r\ngoto failed;\r\nret = qm1d1c0042_set_srch_mode(state, state->cfg.fast_srch);\r\nif (ret < 0)\r\ngoto failed;\r\nreturn ret;\r\nfailed:\r\ndev_warn(&state->i2c->dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int qm1d1c0042_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nstruct qm1d1c0042_config *cfg;\r\nstruct dvb_frontend *fe;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->i2c = client;\r\ncfg = client->dev.platform_data;\r\nfe = cfg->fe;\r\nfe->tuner_priv = state;\r\nqm1d1c0042_set_config(fe, cfg);\r\nmemcpy(&fe->ops.tuner_ops, &qm1d1c0042_ops, sizeof(qm1d1c0042_ops));\r\ni2c_set_clientdata(client, &state->cfg);\r\ndev_info(&client->dev, "Sharp QM1D1C0042 attached.\n");\r\nreturn 0;\r\n}\r\nstatic int qm1d1c0042_remove(struct i2c_client *client)\r\n{\r\nstruct qm1d1c0042_state *state;\r\nstate = cfg_to_state(i2c_get_clientdata(client));\r\nstate->cfg.fe->tuner_priv = NULL;\r\nkfree(state);\r\nreturn 0;\r\n}
