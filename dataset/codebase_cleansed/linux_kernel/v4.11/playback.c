static void change_volume(struct urb *urb_out, int volume[],\r\nint bytes_per_frame)\r\n{\r\nint chn = 0;\r\nif (volume[0] == 256 && volume[1] == 256)\r\nreturn;\r\nif (bytes_per_frame == 4) {\r\n__le16 *p, *buf_end;\r\np = (__le16 *)urb_out->transfer_buffer;\r\nbuf_end = p + urb_out->transfer_buffer_length / sizeof(*p);\r\nfor (; p < buf_end; ++p) {\r\nshort pv = le16_to_cpu(*p);\r\nint val = (pv * volume[chn & 1]) >> 8;\r\npv = clamp(val, -0x8000, 0x7fff);\r\n*p = cpu_to_le16(pv);\r\n++chn;\r\n}\r\n} else if (bytes_per_frame == 6) {\r\nunsigned char *p, *buf_end;\r\np = (unsigned char *)urb_out->transfer_buffer;\r\nbuf_end = p + urb_out->transfer_buffer_length;\r\nfor (; p < buf_end; p += 3) {\r\nint val;\r\nval = p[0] + (p[1] << 8) + ((signed char)p[2] << 16);\r\nval = (val * volume[chn & 1]) >> 8;\r\nval = clamp(val, -0x800000, 0x7fffff);\r\np[0] = val;\r\np[1] = val >> 8;\r\np[2] = val >> 16;\r\n++chn;\r\n}\r\n}\r\n}\r\nstatic void create_impulse_test_signal(struct snd_line6_pcm *line6pcm,\r\nstruct urb *urb_out, int bytes_per_frame)\r\n{\r\nint frames = urb_out->transfer_buffer_length / bytes_per_frame;\r\nif (bytes_per_frame == 4) {\r\nint i;\r\nshort *pi = (short *)line6pcm->prev_fbuf;\r\nshort *po = (short *)urb_out->transfer_buffer;\r\nfor (i = 0; i < frames; ++i) {\r\npo[0] = pi[0];\r\npo[1] = 0;\r\npi += 2;\r\npo += 2;\r\n}\r\n} else if (bytes_per_frame == 6) {\r\nint i, j;\r\nunsigned char *pi = line6pcm->prev_fbuf;\r\nunsigned char *po = urb_out->transfer_buffer;\r\nfor (i = 0; i < frames; ++i) {\r\nfor (j = 0; j < bytes_per_frame / 2; ++j)\r\npo[j] = pi[j];\r\nfor (; j < bytes_per_frame; ++j)\r\npo[j] = 0;\r\npi += bytes_per_frame;\r\npo += bytes_per_frame;\r\n}\r\n}\r\nif (--line6pcm->impulse_count <= 0) {\r\n((unsigned char *)(urb_out->transfer_buffer))[bytes_per_frame -\r\n1] =\r\nline6pcm->impulse_volume;\r\nline6pcm->impulse_count = line6pcm->impulse_period;\r\n}\r\n}\r\nstatic void add_monitor_signal(struct urb *urb_out, unsigned char *signal,\r\nint volume, int bytes_per_frame)\r\n{\r\nif (volume == 0)\r\nreturn;\r\nif (bytes_per_frame == 4) {\r\n__le16 *pi, *po, *buf_end;\r\npi = (__le16 *)signal;\r\npo = (__le16 *)urb_out->transfer_buffer;\r\nbuf_end = po + urb_out->transfer_buffer_length / sizeof(*po);\r\nfor (; po < buf_end; ++pi, ++po) {\r\nshort pov = le16_to_cpu(*po);\r\nshort piv = le16_to_cpu(*pi);\r\nint val = pov + ((piv * volume) >> 8);\r\npov = clamp(val, -0x8000, 0x7fff);\r\n*po = cpu_to_le16(pov);\r\n}\r\n}\r\n}\r\nstatic int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)\r\n{\r\nint index;\r\nint i, urb_size, urb_frames;\r\nint ret;\r\nconst int bytes_per_frame =\r\nline6pcm->properties->bytes_per_channel *\r\nline6pcm->properties->playback_hw.channels_max;\r\nconst int frame_increment =\r\nline6pcm->properties->rates.rats[0].num_min;\r\nconst int frame_factor =\r\nline6pcm->properties->rates.rats[0].den *\r\n(line6pcm->line6->intervals_per_second / LINE6_ISO_INTERVAL);\r\nstruct urb *urb_out;\r\nindex = find_first_zero_bit(&line6pcm->out.active_urbs,\r\nline6pcm->line6->iso_buffers);\r\nif (index < 0 || index >= line6pcm->line6->iso_buffers) {\r\ndev_err(line6pcm->line6->ifcdev, "no free URB found\n");\r\nreturn -EINVAL;\r\n}\r\nurb_out = line6pcm->out.urbs[index];\r\nurb_size = 0;\r\nfor (i = 0; i < LINE6_ISO_PACKETS; ++i) {\r\nint fsize = 0;\r\nstruct usb_iso_packet_descriptor *fout =\r\n&urb_out->iso_frame_desc[i];\r\nfsize = line6pcm->prev_fsize;\r\nif (fsize == 0) {\r\nint n;\r\nline6pcm->out.count += frame_increment;\r\nn = line6pcm->out.count / frame_factor;\r\nline6pcm->out.count -= n * frame_factor;\r\nfsize = n;\r\n}\r\nfsize *= bytes_per_frame;\r\nfout->offset = urb_size;\r\nfout->length = fsize;\r\nurb_size += fsize;\r\n}\r\nif (urb_size == 0) {\r\ndev_err(line6pcm->line6->ifcdev, "driver bug: urb_size = 0\n");\r\nreturn -EINVAL;\r\n}\r\nurb_frames = urb_size / bytes_per_frame;\r\nurb_out->transfer_buffer =\r\nline6pcm->out.buffer +\r\nindex * LINE6_ISO_PACKETS * line6pcm->max_packet_size_out;\r\nurb_out->transfer_buffer_length = urb_size;\r\nurb_out->context = line6pcm;\r\nif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running) &&\r\n!test_bit(LINE6_FLAG_PAUSE_PLAYBACK, &line6pcm->flags)) {\r\nstruct snd_pcm_runtime *runtime =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK)->runtime;\r\nif (line6pcm->out.pos + urb_frames > runtime->buffer_size) {\r\nint len;\r\nlen = runtime->buffer_size - line6pcm->out.pos;\r\nif (len > 0) {\r\nmemcpy(urb_out->transfer_buffer,\r\nruntime->dma_area +\r\nline6pcm->out.pos * bytes_per_frame,\r\nlen * bytes_per_frame);\r\nmemcpy(urb_out->transfer_buffer +\r\nlen * bytes_per_frame, runtime->dma_area,\r\n(urb_frames - len) * bytes_per_frame);\r\n} else\r\ndev_err(line6pcm->line6->ifcdev, "driver bug: len = %d\n",\r\nlen);\r\n} else {\r\nmemcpy(urb_out->transfer_buffer,\r\nruntime->dma_area +\r\nline6pcm->out.pos * bytes_per_frame,\r\nurb_out->transfer_buffer_length);\r\n}\r\nline6pcm->out.pos += urb_frames;\r\nif (line6pcm->out.pos >= runtime->buffer_size)\r\nline6pcm->out.pos -= runtime->buffer_size;\r\nchange_volume(urb_out, line6pcm->volume_playback,\r\nbytes_per_frame);\r\n} else {\r\nmemset(urb_out->transfer_buffer, 0,\r\nurb_out->transfer_buffer_length);\r\n}\r\nspin_lock_nested(&line6pcm->in.lock, SINGLE_DEPTH_NESTING);\r\nif (line6pcm->prev_fbuf) {\r\nif (test_bit(LINE6_STREAM_IMPULSE, &line6pcm->out.running)) {\r\ncreate_impulse_test_signal(line6pcm, urb_out,\r\nbytes_per_frame);\r\nif (test_bit(LINE6_STREAM_PCM, &line6pcm->in.running)) {\r\nline6_capture_copy(line6pcm,\r\nurb_out->transfer_buffer,\r\nurb_out->\r\ntransfer_buffer_length);\r\nline6_capture_check_period(line6pcm,\r\nurb_out->transfer_buffer_length);\r\n}\r\n} else {\r\nif (!(line6pcm->line6->properties->capabilities & LINE6_CAP_HWMON)\r\n&& line6pcm->out.running && line6pcm->in.running)\r\nadd_monitor_signal(urb_out, line6pcm->prev_fbuf,\r\nline6pcm->volume_monitor,\r\nbytes_per_frame);\r\n}\r\nline6pcm->prev_fbuf = NULL;\r\nline6pcm->prev_fsize = 0;\r\n}\r\nspin_unlock(&line6pcm->in.lock);\r\nret = usb_submit_urb(urb_out, GFP_ATOMIC);\r\nif (ret == 0)\r\nset_bit(index, &line6pcm->out.active_urbs);\r\nelse\r\ndev_err(line6pcm->line6->ifcdev,\r\n"URB out #%d submission failed (%d)\n", index, ret);\r\nreturn 0;\r\n}\r\nint line6_submit_audio_out_all_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nint ret = 0, i;\r\nfor (i = 0; i < line6pcm->line6->iso_buffers; ++i) {\r\nret = submit_audio_out_urb(line6pcm);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void audio_out_callback(struct urb *urb)\r\n{\r\nint i, index, length = 0, shutdown = 0;\r\nunsigned long flags;\r\nstruct snd_line6_pcm *line6pcm = (struct snd_line6_pcm *)urb->context;\r\nstruct snd_pcm_substream *substream =\r\nget_substream(line6pcm, SNDRV_PCM_STREAM_PLAYBACK);\r\nconst int bytes_per_frame =\r\nline6pcm->properties->bytes_per_channel *\r\nline6pcm->properties->playback_hw.channels_max;\r\n#if USE_CLEAR_BUFFER_WORKAROUND\r\nmemset(urb->transfer_buffer, 0, urb->transfer_buffer_length);\r\n#endif\r\nline6pcm->out.last_frame = urb->start_frame;\r\nfor (index = 0; index < line6pcm->line6->iso_buffers; index++)\r\nif (urb == line6pcm->out.urbs[index])\r\nbreak;\r\nif (index >= line6pcm->line6->iso_buffers)\r\nreturn;\r\nfor (i = 0; i < LINE6_ISO_PACKETS; i++)\r\nlength += urb->iso_frame_desc[i].length;\r\nspin_lock_irqsave(&line6pcm->out.lock, flags);\r\nif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running)) {\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nline6pcm->out.pos_done +=\r\nlength / bytes_per_frame;\r\nif (line6pcm->out.pos_done >= runtime->buffer_size)\r\nline6pcm->out.pos_done -= runtime->buffer_size;\r\n}\r\nclear_bit(index, &line6pcm->out.active_urbs);\r\nfor (i = 0; i < LINE6_ISO_PACKETS; i++)\r\nif (urb->iso_frame_desc[i].status == -EXDEV) {\r\nshutdown = 1;\r\nbreak;\r\n}\r\nif (test_and_clear_bit(index, &line6pcm->out.unlink_urbs))\r\nshutdown = 1;\r\nif (!shutdown) {\r\nsubmit_audio_out_urb(line6pcm);\r\nif (test_bit(LINE6_STREAM_PCM, &line6pcm->out.running)) {\r\nline6pcm->out.bytes += length;\r\nif (line6pcm->out.bytes >= line6pcm->out.period) {\r\nline6pcm->out.bytes %= line6pcm->out.period;\r\nspin_unlock(&line6pcm->out.lock);\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&line6pcm->out.lock);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&line6pcm->out.lock, flags);\r\n}\r\nstatic int snd_line6_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_line6_pcm *line6pcm = snd_pcm_substream_chip(substream);\r\nerr = snd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&line6pcm->properties->rates);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw = line6pcm->properties->playback_hw;\r\nreturn 0;\r\n}\r\nstatic int snd_line6_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nint line6_create_audio_out_urbs(struct snd_line6_pcm *line6pcm)\r\n{\r\nstruct usb_line6 *line6 = line6pcm->line6;\r\nint i;\r\nline6pcm->out.urbs = kzalloc(\r\nsizeof(struct urb *) * line6->iso_buffers, GFP_KERNEL);\r\nif (line6pcm->out.urbs == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < line6->iso_buffers; ++i) {\r\nstruct urb *urb;\r\nurb = line6pcm->out.urbs[i] =\r\nusb_alloc_urb(LINE6_ISO_PACKETS, GFP_KERNEL);\r\nif (urb == NULL)\r\nreturn -ENOMEM;\r\nurb->dev = line6->usbdev;\r\nurb->pipe =\r\nusb_sndisocpipe(line6->usbdev,\r\nline6->properties->ep_audio_w &\r\nUSB_ENDPOINT_NUMBER_MASK);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->start_frame = -1;\r\nurb->number_of_packets = LINE6_ISO_PACKETS;\r\nurb->interval = LINE6_ISO_INTERVAL;\r\nurb->error_count = 0;\r\nurb->complete = audio_out_callback;\r\n}\r\nreturn 0;\r\n}
