static void sclp_sync_callback(struct sclp_req *req, void *data)\r\n{\r\nstruct completion *completion = data;\r\ncomplete(completion);\r\n}\r\nint sclp_sync_request(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nreturn sclp_sync_request_timeout(cmd, sccb, 0);\r\n}\r\nint sclp_sync_request_timeout(sclp_cmdw_t cmd, void *sccb, int timeout)\r\n{\r\nstruct completion completion;\r\nstruct sclp_req *request;\r\nint rc;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (!request)\r\nreturn -ENOMEM;\r\nif (timeout)\r\nrequest->queue_timeout = timeout;\r\nrequest->command = cmd;\r\nrequest->sccb = sccb;\r\nrequest->status = SCLP_REQ_FILLED;\r\nrequest->callback = sclp_sync_callback;\r\nrequest->callback_data = &completion;\r\ninit_completion(&completion);\r\nrc = sclp_add_request(request);\r\nif (rc)\r\ngoto out;\r\nwait_for_completion(&completion);\r\nif (request->status != SCLP_REQ_DONE) {\r\npr_warn("sync request failed (cmd=0x%08x, status=0x%02x)\n",\r\ncmd, request->status);\r\nrc = -EIO;\r\n}\r\nout:\r\nkfree(request);\r\nreturn rc;\r\n}\r\nint _sclp_get_core_info(struct sclp_core_info *info)\r\n{\r\nint rc;\r\nstruct read_cpu_info_sccb *sccb;\r\nif (!SCLP_HAS_CPU_INFO)\r\nreturn -EOPNOTSUPP;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = sclp_sync_request_timeout(SCLP_CMDW_READ_CPU_INFO, sccb,\r\nSCLP_QUEUE_INTERVAL);\r\nif (rc)\r\ngoto out;\r\nif (sccb->header.response_code != 0x0010) {\r\npr_warn("readcpuinfo failed (response=0x%04x)\n",\r\nsccb->header.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nsclp_fill_core_info(info, sccb);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int do_core_configure(sclp_cmdw_t cmd)\r\n{\r\nstruct cpu_configure_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CPU_RECONFIG)\r\nreturn -EOPNOTSUPP;\r\nsccb = kzalloc(sizeof(*sccb), GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = sclp_sync_request_timeout(cmd, sccb, SCLP_QUEUE_INTERVAL);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\nbreak;\r\ndefault:\r\npr_warn("configure cpu failed (cmd=0x%08x, response=0x%04x)\n",\r\ncmd, sccb->header.response_code);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nkfree(sccb);\r\nreturn rc;\r\n}\r\nint sclp_core_configure(u8 core)\r\n{\r\nreturn do_core_configure(SCLP_CMDW_CONFIGURE_CPU | core << 8);\r\n}\r\nint sclp_core_deconfigure(u8 core)\r\n{\r\nreturn do_core_configure(SCLP_CMDW_DECONFIGURE_CPU | core << 8);\r\n}\r\nint arch_get_memory_phys_device(unsigned long start_pfn)\r\n{\r\nif (!sclp.rzm)\r\nreturn 0;\r\nreturn PFN_PHYS(start_pfn) >> ilog2(sclp.rzm);\r\n}\r\nstatic unsigned long long rn2addr(u16 rn)\r\n{\r\nreturn (unsigned long long) (rn - 1) * sclp.rzm;\r\n}\r\nstatic int do_assign_storage(sclp_cmdw_t cmd, u16 rn)\r\n{\r\nstruct assign_storage_sccb *sccb;\r\nint rc;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = PAGE_SIZE;\r\nsccb->rn = rn;\r\nrc = sclp_sync_request_timeout(cmd, sccb, SCLP_QUEUE_INTERVAL);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\nbreak;\r\ndefault:\r\npr_warn("assign storage failed (cmd=0x%08x, response=0x%04x, rn=0x%04x)\n",\r\ncmd, sccb->header.response_code, rn);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int sclp_assign_storage(u16 rn)\r\n{\r\nunsigned long long start;\r\nint rc;\r\nrc = do_assign_storage(0x000d0001, rn);\r\nif (rc)\r\nreturn rc;\r\nstart = rn2addr(rn);\r\nstorage_key_init_range(start, start + sclp.rzm);\r\nreturn 0;\r\n}\r\nstatic int sclp_unassign_storage(u16 rn)\r\n{\r\nreturn do_assign_storage(0x000c0001, rn);\r\n}\r\nstatic int sclp_attach_storage(u8 id)\r\n{\r\nstruct attach_storage_sccb *sccb;\r\nint rc;\r\nint i;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = PAGE_SIZE;\r\nrc = sclp_sync_request_timeout(0x00080001 | id << 8, sccb,\r\nSCLP_QUEUE_INTERVAL);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\nset_bit(id, sclp_storage_ids);\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (sccb->entries[i])\r\nsclp_unassign_storage(sccb->entries[i] >> 16);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int sclp_mem_change_state(unsigned long start, unsigned long size,\r\nint online)\r\n{\r\nstruct memory_increment *incr;\r\nunsigned long long istart;\r\nint rc = 0;\r\nlist_for_each_entry(incr, &sclp_mem_list, list) {\r\nistart = rn2addr(incr->rn);\r\nif (start + size - 1 < istart)\r\nbreak;\r\nif (start > istart + sclp.rzm - 1)\r\ncontinue;\r\nif (online)\r\nrc |= sclp_assign_storage(incr->rn);\r\nelse\r\nsclp_unassign_storage(incr->rn);\r\nif (rc == 0)\r\nincr->standby = online ? 0 : 1;\r\n}\r\nreturn rc ? -EIO : 0;\r\n}\r\nstatic bool contains_standby_increment(unsigned long start, unsigned long end)\r\n{\r\nstruct memory_increment *incr;\r\nunsigned long istart;\r\nlist_for_each_entry(incr, &sclp_mem_list, list) {\r\nistart = rn2addr(incr->rn);\r\nif (end - 1 < istart)\r\ncontinue;\r\nif (start > istart + sclp.rzm - 1)\r\ncontinue;\r\nif (incr->standby)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int sclp_mem_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nunsigned long start, size;\r\nstruct memory_notify *arg;\r\nunsigned char id;\r\nint rc = 0;\r\narg = data;\r\nstart = arg->start_pfn << PAGE_SHIFT;\r\nsize = arg->nr_pages << PAGE_SHIFT;\r\nmutex_lock(&sclp_mem_mutex);\r\nfor_each_clear_bit(id, sclp_storage_ids, sclp_max_storage_id + 1)\r\nsclp_attach_storage(id);\r\nswitch (action) {\r\ncase MEM_GOING_OFFLINE:\r\nif (contains_standby_increment(start, start + size))\r\nrc = -EPERM;\r\nbreak;\r\ncase MEM_ONLINE:\r\ncase MEM_CANCEL_OFFLINE:\r\nbreak;\r\ncase MEM_GOING_ONLINE:\r\nrc = sclp_mem_change_state(start, size, 1);\r\nbreak;\r\ncase MEM_CANCEL_ONLINE:\r\nsclp_mem_change_state(start, size, 0);\r\nbreak;\r\ncase MEM_OFFLINE:\r\nsclp_mem_change_state(start, size, 0);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (!rc)\r\nsclp_mem_state_changed = 1;\r\nmutex_unlock(&sclp_mem_mutex);\r\nreturn rc ? NOTIFY_BAD : NOTIFY_OK;\r\n}\r\nstatic void __init align_to_block_size(unsigned long long *start,\r\nunsigned long long *size,\r\nunsigned long long alignment)\r\n{\r\nunsigned long long start_align, size_align;\r\nstart_align = roundup(*start, alignment);\r\nsize_align = rounddown(*start + *size, alignment) - start_align;\r\npr_info("Standby memory at 0x%llx (%lluM of %lluM usable)\n",\r\n*start, size_align >> 20, *size >> 20);\r\n*start = start_align;\r\n*size = size_align;\r\n}\r\nstatic void __init add_memory_merged(u16 rn)\r\n{\r\nunsigned long long start, size, addr, block_size;\r\nstatic u16 first_rn, num;\r\nif (rn && first_rn && (first_rn + num == rn)) {\r\nnum++;\r\nreturn;\r\n}\r\nif (!first_rn)\r\ngoto skip_add;\r\nstart = rn2addr(first_rn);\r\nsize = (unsigned long long) num * sclp.rzm;\r\nif (start >= VMEM_MAX_PHYS)\r\ngoto skip_add;\r\nif (start + size > VMEM_MAX_PHYS)\r\nsize = VMEM_MAX_PHYS - start;\r\nif (memory_end_set && (start >= memory_end))\r\ngoto skip_add;\r\nif (memory_end_set && (start + size > memory_end))\r\nsize = memory_end - start;\r\nblock_size = memory_block_size_bytes();\r\nalign_to_block_size(&start, &size, block_size);\r\nif (!size)\r\ngoto skip_add;\r\nfor (addr = start; addr < start + size; addr += block_size)\r\nadd_memory(numa_pfn_to_nid(PFN_DOWN(addr)), addr, block_size);\r\nskip_add:\r\nfirst_rn = rn;\r\nnum = 1;\r\n}\r\nstatic void __init sclp_add_standby_memory(void)\r\n{\r\nstruct memory_increment *incr;\r\nlist_for_each_entry(incr, &sclp_mem_list, list)\r\nif (incr->standby)\r\nadd_memory_merged(incr->rn);\r\nadd_memory_merged(0);\r\n}\r\nstatic void __init insert_increment(u16 rn, int standby, int assigned)\r\n{\r\nstruct memory_increment *incr, *new_incr;\r\nstruct list_head *prev;\r\nu16 last_rn;\r\nnew_incr = kzalloc(sizeof(*new_incr), GFP_KERNEL);\r\nif (!new_incr)\r\nreturn;\r\nnew_incr->rn = rn;\r\nnew_incr->standby = standby;\r\nlast_rn = 0;\r\nprev = &sclp_mem_list;\r\nlist_for_each_entry(incr, &sclp_mem_list, list) {\r\nif (assigned && incr->rn > rn)\r\nbreak;\r\nif (!assigned && incr->rn - last_rn > 1)\r\nbreak;\r\nlast_rn = incr->rn;\r\nprev = &incr->list;\r\n}\r\nif (!assigned)\r\nnew_incr->rn = last_rn + 1;\r\nif (new_incr->rn > sclp.rnmax) {\r\nkfree(new_incr);\r\nreturn;\r\n}\r\nlist_add(&new_incr->list, prev);\r\n}\r\nstatic int sclp_mem_freeze(struct device *dev)\r\n{\r\nif (!sclp_mem_state_changed)\r\nreturn 0;\r\npr_err("Memory hotplug state changed, suspend refused.\n");\r\nreturn -EPERM;\r\n}\r\nstatic int __init sclp_detect_standby_memory(void)\r\n{\r\nstruct platform_device *sclp_pdev;\r\nstruct read_storage_sccb *sccb;\r\nint i, id, assigned, rc;\r\nif (OLDMEM_BASE)\r\nreturn 0;\r\nif ((sclp.facilities & 0xe00000000000ULL) != 0xe00000000000ULL)\r\nreturn 0;\r\nrc = -ENOMEM;\r\nsccb = (void *) __get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\ngoto out;\r\nassigned = 0;\r\nfor (id = 0; id <= sclp_max_storage_id; id++) {\r\nmemset(sccb, 0, PAGE_SIZE);\r\nsccb->header.length = PAGE_SIZE;\r\nrc = sclp_sync_request(0x00040001 | id << 8, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0010:\r\nset_bit(id, sclp_storage_ids);\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (!sccb->entries[i])\r\ncontinue;\r\nassigned++;\r\ninsert_increment(sccb->entries[i] >> 16, 0, 1);\r\n}\r\nbreak;\r\ncase 0x0310:\r\nbreak;\r\ncase 0x0410:\r\nfor (i = 0; i < sccb->assigned; i++) {\r\nif (!sccb->entries[i])\r\ncontinue;\r\nassigned++;\r\ninsert_increment(sccb->entries[i] >> 16, 1, 1);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EIO;\r\nbreak;\r\n}\r\nif (!rc)\r\nsclp_max_storage_id = sccb->max_id;\r\n}\r\nif (rc || list_empty(&sclp_mem_list))\r\ngoto out;\r\nfor (i = 1; i <= sclp.rnmax - assigned; i++)\r\ninsert_increment(0, 1, 0);\r\nrc = register_memory_notifier(&sclp_mem_nb);\r\nif (rc)\r\ngoto out;\r\nrc = platform_driver_register(&sclp_mem_pdrv);\r\nif (rc)\r\ngoto out;\r\nsclp_pdev = platform_device_register_simple("sclp_mem", -1, NULL, 0);\r\nrc = PTR_ERR_OR_ZERO(sclp_pdev);\r\nif (rc)\r\ngoto out_driver;\r\nsclp_add_standby_memory();\r\ngoto out;\r\nout_driver:\r\nplatform_driver_unregister(&sclp_mem_pdrv);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic int do_chp_configure(sclp_cmdw_t cmd)\r\n{\r\nstruct chp_cfg_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CHP_RECONFIG)\r\nreturn -EOPNOTSUPP;\r\nsccb = (struct chp_cfg_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = sclp_sync_request(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\nswitch (sccb->header.response_code) {\r\ncase 0x0020:\r\ncase 0x0120:\r\ncase 0x0440:\r\ncase 0x0450:\r\nbreak;\r\ndefault:\r\npr_warn("configure channel-path failed (cmd=0x%08x, response=0x%04x)\n",\r\ncmd, sccb->header.response_code);\r\nrc = -EIO;\r\nbreak;\r\n}\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nint sclp_chp_configure(struct chp_id chpid)\r\n{\r\nreturn do_chp_configure(SCLP_CMDW_CONFIGURE_CHPATH | chpid.id << 8);\r\n}\r\nint sclp_chp_deconfigure(struct chp_id chpid)\r\n{\r\nreturn do_chp_configure(SCLP_CMDW_DECONFIGURE_CHPATH | chpid.id << 8);\r\n}\r\nint sclp_chp_read_info(struct sclp_chp_info *info)\r\n{\r\nstruct chp_info_sccb *sccb;\r\nint rc;\r\nif (!SCLP_HAS_CHP_INFO)\r\nreturn -EOPNOTSUPP;\r\nsccb = (struct chp_info_sccb *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\nsccb->header.length = sizeof(*sccb);\r\nrc = sclp_sync_request(SCLP_CMDW_READ_CHPATH_INFORMATION, sccb);\r\nif (rc)\r\ngoto out;\r\nif (sccb->header.response_code != 0x0010) {\r\npr_warn("read channel-path info failed (response=0x%04x)\n",\r\nsccb->header.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmemcpy(info->recognized, sccb->recognized, SCLP_CHP_INFO_MASK_SIZE);\r\nmemcpy(info->standby, sccb->standby, SCLP_CHP_INFO_MASK_SIZE);\r\nmemcpy(info->configured, sccb->configured, SCLP_CHP_INFO_MASK_SIZE);\r\nout:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}
