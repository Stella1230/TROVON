static inline bool is_remote_lock(struct file *filp)\r\n{\r\nreturn likely(!(filp->f_path.dentry->d_sb->s_flags & MS_NOREMOTELOCK));\r\n}\r\nstatic bool lease_breaking(struct file_lock *fl)\r\n{\r\nreturn fl->fl_flags & (FL_UNLOCK_PENDING | FL_DOWNGRADE_PENDING);\r\n}\r\nstatic int target_leasetype(struct file_lock *fl)\r\n{\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\nreturn F_UNLCK;\r\nif (fl->fl_flags & FL_DOWNGRADE_PENDING)\r\nreturn F_RDLCK;\r\nreturn fl->fl_type;\r\n}\r\nstatic struct file_lock_context *\r\nlocks_get_lock_context(struct inode *inode, int type)\r\n{\r\nstruct file_lock_context *ctx;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (likely(ctx) || type == F_UNLCK)\r\ngoto out;\r\nctx = kmem_cache_alloc(flctx_cache, GFP_KERNEL);\r\nif (!ctx)\r\ngoto out;\r\nspin_lock_init(&ctx->flc_lock);\r\nINIT_LIST_HEAD(&ctx->flc_flock);\r\nINIT_LIST_HEAD(&ctx->flc_posix);\r\nINIT_LIST_HEAD(&ctx->flc_lease);\r\nif (cmpxchg(&inode->i_flctx, NULL, ctx)) {\r\nkmem_cache_free(flctx_cache, ctx);\r\nctx = smp_load_acquire(&inode->i_flctx);\r\n}\r\nout:\r\ntrace_locks_get_lock_context(inode, type, ctx);\r\nreturn ctx;\r\n}\r\nstatic void\r\nlocks_dump_ctx_list(struct list_head *list, char *list_type)\r\n{\r\nstruct file_lock *fl;\r\nlist_for_each_entry(fl, list, fl_list) {\r\npr_warn("%s: fl_owner=%p fl_flags=0x%x fl_type=0x%x fl_pid=%u\n", list_type, fl->fl_owner, fl->fl_flags, fl->fl_type, fl->fl_pid);\r\n}\r\n}\r\nstatic void\r\nlocks_check_ctx_lists(struct inode *inode)\r\n{\r\nstruct file_lock_context *ctx = inode->i_flctx;\r\nif (unlikely(!list_empty(&ctx->flc_flock) ||\r\n!list_empty(&ctx->flc_posix) ||\r\n!list_empty(&ctx->flc_lease))) {\r\npr_warn("Leaked locks on dev=0x%x:0x%x ino=0x%lx:\n",\r\nMAJOR(inode->i_sb->s_dev), MINOR(inode->i_sb->s_dev),\r\ninode->i_ino);\r\nlocks_dump_ctx_list(&ctx->flc_flock, "FLOCK");\r\nlocks_dump_ctx_list(&ctx->flc_posix, "POSIX");\r\nlocks_dump_ctx_list(&ctx->flc_lease, "LEASE");\r\n}\r\n}\r\nvoid\r\nlocks_free_lock_context(struct inode *inode)\r\n{\r\nstruct file_lock_context *ctx = inode->i_flctx;\r\nif (unlikely(ctx)) {\r\nlocks_check_ctx_lists(inode);\r\nkmem_cache_free(flctx_cache, ctx);\r\n}\r\n}\r\nstatic void locks_init_lock_heads(struct file_lock *fl)\r\n{\r\nINIT_HLIST_NODE(&fl->fl_link);\r\nINIT_LIST_HEAD(&fl->fl_list);\r\nINIT_LIST_HEAD(&fl->fl_block);\r\ninit_waitqueue_head(&fl->fl_wait);\r\n}\r\nstruct file_lock *locks_alloc_lock(void)\r\n{\r\nstruct file_lock *fl = kmem_cache_zalloc(filelock_cache, GFP_KERNEL);\r\nif (fl)\r\nlocks_init_lock_heads(fl);\r\nreturn fl;\r\n}\r\nvoid locks_release_private(struct file_lock *fl)\r\n{\r\nif (fl->fl_ops) {\r\nif (fl->fl_ops->fl_release_private)\r\nfl->fl_ops->fl_release_private(fl);\r\nfl->fl_ops = NULL;\r\n}\r\nif (fl->fl_lmops) {\r\nif (fl->fl_lmops->lm_put_owner) {\r\nfl->fl_lmops->lm_put_owner(fl->fl_owner);\r\nfl->fl_owner = NULL;\r\n}\r\nfl->fl_lmops = NULL;\r\n}\r\n}\r\nvoid locks_free_lock(struct file_lock *fl)\r\n{\r\nBUG_ON(waitqueue_active(&fl->fl_wait));\r\nBUG_ON(!list_empty(&fl->fl_list));\r\nBUG_ON(!list_empty(&fl->fl_block));\r\nBUG_ON(!hlist_unhashed(&fl->fl_link));\r\nlocks_release_private(fl);\r\nkmem_cache_free(filelock_cache, fl);\r\n}\r\nstatic void\r\nlocks_dispose_list(struct list_head *dispose)\r\n{\r\nstruct file_lock *fl;\r\nwhile (!list_empty(dispose)) {\r\nfl = list_first_entry(dispose, struct file_lock, fl_list);\r\nlist_del_init(&fl->fl_list);\r\nlocks_free_lock(fl);\r\n}\r\n}\r\nvoid locks_init_lock(struct file_lock *fl)\r\n{\r\nmemset(fl, 0, sizeof(struct file_lock));\r\nlocks_init_lock_heads(fl);\r\n}\r\nvoid locks_copy_conflock(struct file_lock *new, struct file_lock *fl)\r\n{\r\nnew->fl_owner = fl->fl_owner;\r\nnew->fl_pid = fl->fl_pid;\r\nnew->fl_file = NULL;\r\nnew->fl_flags = fl->fl_flags;\r\nnew->fl_type = fl->fl_type;\r\nnew->fl_start = fl->fl_start;\r\nnew->fl_end = fl->fl_end;\r\nnew->fl_lmops = fl->fl_lmops;\r\nnew->fl_ops = NULL;\r\nif (fl->fl_lmops) {\r\nif (fl->fl_lmops->lm_get_owner)\r\nfl->fl_lmops->lm_get_owner(fl->fl_owner);\r\n}\r\n}\r\nvoid locks_copy_lock(struct file_lock *new, struct file_lock *fl)\r\n{\r\nWARN_ON_ONCE(new->fl_ops);\r\nlocks_copy_conflock(new, fl);\r\nnew->fl_file = fl->fl_file;\r\nnew->fl_ops = fl->fl_ops;\r\nif (fl->fl_ops) {\r\nif (fl->fl_ops->fl_copy_lock)\r\nfl->fl_ops->fl_copy_lock(new, fl);\r\n}\r\n}\r\nstatic inline int flock_translate_cmd(int cmd) {\r\nif (cmd & LOCK_MAND)\r\nreturn cmd & (LOCK_MAND | LOCK_RW);\r\nswitch (cmd) {\r\ncase LOCK_SH:\r\nreturn F_RDLCK;\r\ncase LOCK_EX:\r\nreturn F_WRLCK;\r\ncase LOCK_UN:\r\nreturn F_UNLCK;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic struct file_lock *\r\nflock_make_lock(struct file *filp, unsigned int cmd)\r\n{\r\nstruct file_lock *fl;\r\nint type = flock_translate_cmd(cmd);\r\nif (type < 0)\r\nreturn ERR_PTR(type);\r\nfl = locks_alloc_lock();\r\nif (fl == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nfl->fl_file = filp;\r\nfl->fl_owner = filp;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_flags = FL_FLOCK;\r\nfl->fl_type = type;\r\nfl->fl_end = OFFSET_MAX;\r\nreturn fl;\r\n}\r\nstatic int assign_type(struct file_lock *fl, long type)\r\n{\r\nswitch (type) {\r\ncase F_RDLCK:\r\ncase F_WRLCK:\r\ncase F_UNLCK:\r\nfl->fl_type = type;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flock64_to_posix_lock(struct file *filp, struct file_lock *fl,\r\nstruct flock64 *l)\r\n{\r\nswitch (l->l_whence) {\r\ncase SEEK_SET:\r\nfl->fl_start = 0;\r\nbreak;\r\ncase SEEK_CUR:\r\nfl->fl_start = filp->f_pos;\r\nbreak;\r\ncase SEEK_END:\r\nfl->fl_start = i_size_read(file_inode(filp));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (l->l_start > OFFSET_MAX - fl->fl_start)\r\nreturn -EOVERFLOW;\r\nfl->fl_start += l->l_start;\r\nif (fl->fl_start < 0)\r\nreturn -EINVAL;\r\nif (l->l_len > 0) {\r\nif (l->l_len - 1 > OFFSET_MAX - fl->fl_start)\r\nreturn -EOVERFLOW;\r\nfl->fl_end = fl->fl_start + l->l_len - 1;\r\n} else if (l->l_len < 0) {\r\nif (fl->fl_start + l->l_len < 0)\r\nreturn -EINVAL;\r\nfl->fl_end = fl->fl_start - 1;\r\nfl->fl_start += l->l_len;\r\n} else\r\nfl->fl_end = OFFSET_MAX;\r\nfl->fl_owner = current->files;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = filp;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_ops = NULL;\r\nfl->fl_lmops = NULL;\r\nreturn assign_type(fl, l->l_type);\r\n}\r\nstatic int flock_to_posix_lock(struct file *filp, struct file_lock *fl,\r\nstruct flock *l)\r\n{\r\nstruct flock64 ll = {\r\n.l_type = l->l_type,\r\n.l_whence = l->l_whence,\r\n.l_start = l->l_start,\r\n.l_len = l->l_len,\r\n};\r\nreturn flock64_to_posix_lock(filp, fl, &ll);\r\n}\r\nstatic bool\r\nlease_break_callback(struct file_lock *fl)\r\n{\r\nkill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);\r\nreturn false;\r\n}\r\nstatic void\r\nlease_setup(struct file_lock *fl, void **priv)\r\n{\r\nstruct file *filp = fl->fl_file;\r\nstruct fasync_struct *fa = *priv;\r\nif (!fasync_insert_entry(fa->fa_fd, filp, &fl->fl_fasync, fa))\r\n*priv = NULL;\r\n__f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\r\n}\r\nstatic int lease_init(struct file *filp, long type, struct file_lock *fl)\r\n{\r\nif (assign_type(fl, type) != 0)\r\nreturn -EINVAL;\r\nfl->fl_owner = filp;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = filp;\r\nfl->fl_flags = FL_LEASE;\r\nfl->fl_start = 0;\r\nfl->fl_end = OFFSET_MAX;\r\nfl->fl_ops = NULL;\r\nfl->fl_lmops = &lease_manager_ops;\r\nreturn 0;\r\n}\r\nstatic struct file_lock *lease_alloc(struct file *filp, long type)\r\n{\r\nstruct file_lock *fl = locks_alloc_lock();\r\nint error = -ENOMEM;\r\nif (fl == NULL)\r\nreturn ERR_PTR(error);\r\nerror = lease_init(filp, type, fl);\r\nif (error) {\r\nlocks_free_lock(fl);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn fl;\r\n}\r\nstatic inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)\r\n{\r\nreturn ((fl1->fl_end >= fl2->fl_start) &&\r\n(fl2->fl_end >= fl1->fl_start));\r\n}\r\nstatic int posix_same_owner(struct file_lock *fl1, struct file_lock *fl2)\r\n{\r\nif (fl1->fl_lmops && fl1->fl_lmops->lm_compare_owner)\r\nreturn fl2->fl_lmops == fl1->fl_lmops &&\r\nfl1->fl_lmops->lm_compare_owner(fl1, fl2);\r\nreturn fl1->fl_owner == fl2->fl_owner;\r\n}\r\nstatic void locks_insert_global_locks(struct file_lock *fl)\r\n{\r\nstruct file_lock_list_struct *fll = this_cpu_ptr(&file_lock_list);\r\npercpu_rwsem_assert_held(&file_rwsem);\r\nspin_lock(&fll->lock);\r\nfl->fl_link_cpu = smp_processor_id();\r\nhlist_add_head(&fl->fl_link, &fll->hlist);\r\nspin_unlock(&fll->lock);\r\n}\r\nstatic void locks_delete_global_locks(struct file_lock *fl)\r\n{\r\nstruct file_lock_list_struct *fll;\r\npercpu_rwsem_assert_held(&file_rwsem);\r\nif (hlist_unhashed(&fl->fl_link))\r\nreturn;\r\nfll = per_cpu_ptr(&file_lock_list, fl->fl_link_cpu);\r\nspin_lock(&fll->lock);\r\nhlist_del_init(&fl->fl_link);\r\nspin_unlock(&fll->lock);\r\n}\r\nstatic unsigned long\r\nposix_owner_key(struct file_lock *fl)\r\n{\r\nif (fl->fl_lmops && fl->fl_lmops->lm_owner_key)\r\nreturn fl->fl_lmops->lm_owner_key(fl);\r\nreturn (unsigned long)fl->fl_owner;\r\n}\r\nstatic void locks_insert_global_blocked(struct file_lock *waiter)\r\n{\r\nlockdep_assert_held(&blocked_lock_lock);\r\nhash_add(blocked_hash, &waiter->fl_link, posix_owner_key(waiter));\r\n}\r\nstatic void locks_delete_global_blocked(struct file_lock *waiter)\r\n{\r\nlockdep_assert_held(&blocked_lock_lock);\r\nhash_del(&waiter->fl_link);\r\n}\r\nstatic void __locks_delete_block(struct file_lock *waiter)\r\n{\r\nlocks_delete_global_blocked(waiter);\r\nlist_del_init(&waiter->fl_block);\r\nwaiter->fl_next = NULL;\r\n}\r\nstatic void locks_delete_block(struct file_lock *waiter)\r\n{\r\nspin_lock(&blocked_lock_lock);\r\n__locks_delete_block(waiter);\r\nspin_unlock(&blocked_lock_lock);\r\n}\r\nstatic void __locks_insert_block(struct file_lock *blocker,\r\nstruct file_lock *waiter)\r\n{\r\nBUG_ON(!list_empty(&waiter->fl_block));\r\nwaiter->fl_next = blocker;\r\nlist_add_tail(&waiter->fl_block, &blocker->fl_block);\r\nif (IS_POSIX(blocker) && !IS_OFDLCK(blocker))\r\nlocks_insert_global_blocked(waiter);\r\n}\r\nstatic void locks_insert_block(struct file_lock *blocker,\r\nstruct file_lock *waiter)\r\n{\r\nspin_lock(&blocked_lock_lock);\r\n__locks_insert_block(blocker, waiter);\r\nspin_unlock(&blocked_lock_lock);\r\n}\r\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\r\n{\r\nif (list_empty(&blocker->fl_block))\r\nreturn;\r\nspin_lock(&blocked_lock_lock);\r\nwhile (!list_empty(&blocker->fl_block)) {\r\nstruct file_lock *waiter;\r\nwaiter = list_first_entry(&blocker->fl_block,\r\nstruct file_lock, fl_block);\r\n__locks_delete_block(waiter);\r\nif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\r\nwaiter->fl_lmops->lm_notify(waiter);\r\nelse\r\nwake_up(&waiter->fl_wait);\r\n}\r\nspin_unlock(&blocked_lock_lock);\r\n}\r\nstatic void\r\nlocks_insert_lock_ctx(struct file_lock *fl, struct list_head *before)\r\n{\r\nfl->fl_nspid = get_pid(task_tgid(current));\r\nlist_add_tail(&fl->fl_list, before);\r\nlocks_insert_global_locks(fl);\r\n}\r\nstatic void\r\nlocks_unlink_lock_ctx(struct file_lock *fl)\r\n{\r\nlocks_delete_global_locks(fl);\r\nlist_del_init(&fl->fl_list);\r\nif (fl->fl_nspid) {\r\nput_pid(fl->fl_nspid);\r\nfl->fl_nspid = NULL;\r\n}\r\nlocks_wake_up_blocks(fl);\r\n}\r\nstatic void\r\nlocks_delete_lock_ctx(struct file_lock *fl, struct list_head *dispose)\r\n{\r\nlocks_unlink_lock_ctx(fl);\r\nif (dispose)\r\nlist_add(&fl->fl_list, dispose);\r\nelse\r\nlocks_free_lock(fl);\r\n}\r\nstatic int locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (sys_fl->fl_type == F_WRLCK)\r\nreturn 1;\r\nif (caller_fl->fl_type == F_WRLCK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int posix_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (posix_same_owner(caller_fl, sys_fl))\r\nreturn (0);\r\nif (!locks_overlap(caller_fl, sys_fl))\r\nreturn 0;\r\nreturn (locks_conflict(caller_fl, sys_fl));\r\n}\r\nstatic int flock_locks_conflict(struct file_lock *caller_fl, struct file_lock *sys_fl)\r\n{\r\nif (caller_fl->fl_file == sys_fl->fl_file)\r\nreturn (0);\r\nif ((caller_fl->fl_type & LOCK_MAND) || (sys_fl->fl_type & LOCK_MAND))\r\nreturn 0;\r\nreturn (locks_conflict(caller_fl, sys_fl));\r\n}\r\nvoid\r\nposix_test_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nstruct file_lock *cfl;\r\nstruct file_lock_context *ctx;\r\nstruct inode *inode = locks_inode(filp);\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx || list_empty_careful(&ctx->flc_posix)) {\r\nfl->fl_type = F_UNLCK;\r\nreturn;\r\n}\r\nspin_lock(&ctx->flc_lock);\r\nlist_for_each_entry(cfl, &ctx->flc_posix, fl_list) {\r\nif (posix_locks_conflict(fl, cfl)) {\r\nlocks_copy_conflock(fl, cfl);\r\nif (cfl->fl_nspid)\r\nfl->fl_pid = pid_vnr(cfl->fl_nspid);\r\ngoto out;\r\n}\r\n}\r\nfl->fl_type = F_UNLCK;\r\nout:\r\nspin_unlock(&ctx->flc_lock);\r\nreturn;\r\n}\r\nstatic struct file_lock *what_owner_is_waiting_for(struct file_lock *block_fl)\r\n{\r\nstruct file_lock *fl;\r\nhash_for_each_possible(blocked_hash, fl, fl_link, posix_owner_key(block_fl)) {\r\nif (posix_same_owner(fl, block_fl))\r\nreturn fl->fl_next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int posix_locks_deadlock(struct file_lock *caller_fl,\r\nstruct file_lock *block_fl)\r\n{\r\nint i = 0;\r\nlockdep_assert_held(&blocked_lock_lock);\r\nif (IS_OFDLCK(caller_fl))\r\nreturn 0;\r\nwhile ((block_fl = what_owner_is_waiting_for(block_fl))) {\r\nif (i++ > MAX_DEADLK_ITERATIONS)\r\nreturn 0;\r\nif (posix_same_owner(caller_fl, block_fl))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int flock_lock_inode(struct inode *inode, struct file_lock *request)\r\n{\r\nstruct file_lock *new_fl = NULL;\r\nstruct file_lock *fl;\r\nstruct file_lock_context *ctx;\r\nint error = 0;\r\nbool found = false;\r\nLIST_HEAD(dispose);\r\nctx = locks_get_lock_context(inode, request->fl_type);\r\nif (!ctx) {\r\nif (request->fl_type != F_UNLCK)\r\nreturn -ENOMEM;\r\nreturn (request->fl_flags & FL_EXISTS) ? -ENOENT : 0;\r\n}\r\nif (!(request->fl_flags & FL_ACCESS) && (request->fl_type != F_UNLCK)) {\r\nnew_fl = locks_alloc_lock();\r\nif (!new_fl)\r\nreturn -ENOMEM;\r\n}\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto find_conflict;\r\nlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\r\nif (request->fl_file != fl->fl_file)\r\ncontinue;\r\nif (request->fl_type == fl->fl_type)\r\ngoto out;\r\nfound = true;\r\nlocks_delete_lock_ctx(fl, &dispose);\r\nbreak;\r\n}\r\nif (request->fl_type == F_UNLCK) {\r\nif ((request->fl_flags & FL_EXISTS) && !found)\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nfind_conflict:\r\nlist_for_each_entry(fl, &ctx->flc_flock, fl_list) {\r\nif (!flock_locks_conflict(request, fl))\r\ncontinue;\r\nerror = -EAGAIN;\r\nif (!(request->fl_flags & FL_SLEEP))\r\ngoto out;\r\nerror = FILE_LOCK_DEFERRED;\r\nlocks_insert_block(fl, request);\r\ngoto out;\r\n}\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto out;\r\nlocks_copy_lock(new_fl, request);\r\nlocks_insert_lock_ctx(new_fl, &ctx->flc_flock);\r\nnew_fl = NULL;\r\nerror = 0;\r\nout:\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nif (new_fl)\r\nlocks_free_lock(new_fl);\r\nlocks_dispose_list(&dispose);\r\nreturn error;\r\n}\r\nstatic int posix_lock_inode(struct inode *inode, struct file_lock *request,\r\nstruct file_lock *conflock)\r\n{\r\nstruct file_lock *fl, *tmp;\r\nstruct file_lock *new_fl = NULL;\r\nstruct file_lock *new_fl2 = NULL;\r\nstruct file_lock *left = NULL;\r\nstruct file_lock *right = NULL;\r\nstruct file_lock_context *ctx;\r\nint error;\r\nbool added = false;\r\nLIST_HEAD(dispose);\r\nctx = locks_get_lock_context(inode, request->fl_type);\r\nif (!ctx)\r\nreturn (request->fl_type == F_UNLCK) ? 0 : -ENOMEM;\r\nif (!(request->fl_flags & FL_ACCESS) &&\r\n(request->fl_type != F_UNLCK ||\r\nrequest->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\r\nnew_fl = locks_alloc_lock();\r\nnew_fl2 = locks_alloc_lock();\r\n}\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\nif (request->fl_type != F_UNLCK) {\r\nlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\r\nif (!posix_locks_conflict(request, fl))\r\ncontinue;\r\nif (conflock)\r\nlocks_copy_conflock(conflock, fl);\r\nerror = -EAGAIN;\r\nif (!(request->fl_flags & FL_SLEEP))\r\ngoto out;\r\nerror = -EDEADLK;\r\nspin_lock(&blocked_lock_lock);\r\nif (likely(!posix_locks_deadlock(request, fl))) {\r\nerror = FILE_LOCK_DEFERRED;\r\n__locks_insert_block(fl, request);\r\n}\r\nspin_unlock(&blocked_lock_lock);\r\ngoto out;\r\n}\r\n}\r\nerror = 0;\r\nif (request->fl_flags & FL_ACCESS)\r\ngoto out;\r\nlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\r\nif (posix_same_owner(request, fl))\r\nbreak;\r\n}\r\nlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, fl_list) {\r\nif (!posix_same_owner(request, fl))\r\nbreak;\r\nif (request->fl_type == fl->fl_type) {\r\nif (fl->fl_end < request->fl_start - 1)\r\ncontinue;\r\nif (fl->fl_start - 1 > request->fl_end)\r\nbreak;\r\nif (fl->fl_start > request->fl_start)\r\nfl->fl_start = request->fl_start;\r\nelse\r\nrequest->fl_start = fl->fl_start;\r\nif (fl->fl_end < request->fl_end)\r\nfl->fl_end = request->fl_end;\r\nelse\r\nrequest->fl_end = fl->fl_end;\r\nif (added) {\r\nlocks_delete_lock_ctx(fl, &dispose);\r\ncontinue;\r\n}\r\nrequest = fl;\r\nadded = true;\r\n} else {\r\nif (fl->fl_end < request->fl_start)\r\ncontinue;\r\nif (fl->fl_start > request->fl_end)\r\nbreak;\r\nif (request->fl_type == F_UNLCK)\r\nadded = true;\r\nif (fl->fl_start < request->fl_start)\r\nleft = fl;\r\nif (fl->fl_end > request->fl_end) {\r\nright = fl;\r\nbreak;\r\n}\r\nif (fl->fl_start >= request->fl_start) {\r\nif (added) {\r\nlocks_delete_lock_ctx(fl, &dispose);\r\ncontinue;\r\n}\r\nerror = -ENOLCK;\r\nif (!new_fl)\r\ngoto out;\r\nlocks_copy_lock(new_fl, request);\r\nrequest = new_fl;\r\nnew_fl = NULL;\r\nlocks_insert_lock_ctx(request, &fl->fl_list);\r\nlocks_delete_lock_ctx(fl, &dispose);\r\nadded = true;\r\n}\r\n}\r\n}\r\nerror = -ENOLCK;\r\nif (right && left == right && !new_fl2)\r\ngoto out;\r\nerror = 0;\r\nif (!added) {\r\nif (request->fl_type == F_UNLCK) {\r\nif (request->fl_flags & FL_EXISTS)\r\nerror = -ENOENT;\r\ngoto out;\r\n}\r\nif (!new_fl) {\r\nerror = -ENOLCK;\r\ngoto out;\r\n}\r\nlocks_copy_lock(new_fl, request);\r\nlocks_insert_lock_ctx(new_fl, &fl->fl_list);\r\nfl = new_fl;\r\nnew_fl = NULL;\r\n}\r\nif (right) {\r\nif (left == right) {\r\nleft = new_fl2;\r\nnew_fl2 = NULL;\r\nlocks_copy_lock(left, right);\r\nlocks_insert_lock_ctx(left, &fl->fl_list);\r\n}\r\nright->fl_start = request->fl_end + 1;\r\nlocks_wake_up_blocks(right);\r\n}\r\nif (left) {\r\nleft->fl_end = request->fl_start - 1;\r\nlocks_wake_up_blocks(left);\r\n}\r\nout:\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nif (new_fl)\r\nlocks_free_lock(new_fl);\r\nif (new_fl2)\r\nlocks_free_lock(new_fl2);\r\nlocks_dispose_list(&dispose);\r\ntrace_posix_lock_inode(inode, request, error);\r\nreturn error;\r\n}\r\nint posix_lock_file(struct file *filp, struct file_lock *fl,\r\nstruct file_lock *conflock)\r\n{\r\nreturn posix_lock_inode(locks_inode(filp), fl, conflock);\r\n}\r\nstatic int posix_lock_inode_wait(struct inode *inode, struct file_lock *fl)\r\n{\r\nint error;\r\nmight_sleep ();\r\nfor (;;) {\r\nerror = posix_lock_inode(inode, fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint locks_mandatory_locked(struct file *file)\r\n{\r\nint ret;\r\nstruct inode *inode = locks_inode(file);\r\nstruct file_lock_context *ctx;\r\nstruct file_lock *fl;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx || list_empty_careful(&ctx->flc_posix))\r\nreturn 0;\r\nspin_lock(&ctx->flc_lock);\r\nret = 0;\r\nlist_for_each_entry(fl, &ctx->flc_posix, fl_list) {\r\nif (fl->fl_owner != current->files &&\r\nfl->fl_owner != file) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&ctx->flc_lock);\r\nreturn ret;\r\n}\r\nint locks_mandatory_area(struct inode *inode, struct file *filp, loff_t start,\r\nloff_t end, unsigned char type)\r\n{\r\nstruct file_lock fl;\r\nint error;\r\nbool sleep = false;\r\nlocks_init_lock(&fl);\r\nfl.fl_pid = current->tgid;\r\nfl.fl_file = filp;\r\nfl.fl_flags = FL_POSIX | FL_ACCESS;\r\nif (filp && !(filp->f_flags & O_NONBLOCK))\r\nsleep = true;\r\nfl.fl_type = type;\r\nfl.fl_start = start;\r\nfl.fl_end = end;\r\nfor (;;) {\r\nif (filp) {\r\nfl.fl_owner = filp;\r\nfl.fl_flags &= ~FL_SLEEP;\r\nerror = posix_lock_inode(inode, &fl, NULL);\r\nif (!error)\r\nbreak;\r\n}\r\nif (sleep)\r\nfl.fl_flags |= FL_SLEEP;\r\nfl.fl_owner = current->files;\r\nerror = posix_lock_inode(inode, &fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl.fl_wait, !fl.fl_next);\r\nif (!error) {\r\nif (__mandatory_lock(inode))\r\ncontinue;\r\n}\r\nlocks_delete_block(&fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic void lease_clear_pending(struct file_lock *fl, int arg)\r\n{\r\nswitch (arg) {\r\ncase F_UNLCK:\r\nfl->fl_flags &= ~FL_UNLOCK_PENDING;\r\ncase F_RDLCK:\r\nfl->fl_flags &= ~FL_DOWNGRADE_PENDING;\r\n}\r\n}\r\nint lease_modify(struct file_lock *fl, int arg, struct list_head *dispose)\r\n{\r\nint error = assign_type(fl, arg);\r\nif (error)\r\nreturn error;\r\nlease_clear_pending(fl, arg);\r\nlocks_wake_up_blocks(fl);\r\nif (arg == F_UNLCK) {\r\nstruct file *filp = fl->fl_file;\r\nf_delown(filp);\r\nfilp->f_owner.signum = 0;\r\nfasync_helper(0, fl->fl_file, 0, &fl->fl_fasync);\r\nif (fl->fl_fasync != NULL) {\r\nprintk(KERN_ERR "locks_delete_lock: fasync == %p\n", fl->fl_fasync);\r\nfl->fl_fasync = NULL;\r\n}\r\nlocks_delete_lock_ctx(fl, dispose);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool past_time(unsigned long then)\r\n{\r\nif (!then)\r\nreturn false;\r\nreturn time_after(jiffies, then);\r\n}\r\nstatic void time_out_leases(struct inode *inode, struct list_head *dispose)\r\n{\r\nstruct file_lock_context *ctx = inode->i_flctx;\r\nstruct file_lock *fl, *tmp;\r\nlockdep_assert_held(&ctx->flc_lock);\r\nlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\r\ntrace_time_out_leases(inode, fl);\r\nif (past_time(fl->fl_downgrade_time))\r\nlease_modify(fl, F_RDLCK, dispose);\r\nif (past_time(fl->fl_break_time))\r\nlease_modify(fl, F_UNLCK, dispose);\r\n}\r\n}\r\nstatic bool leases_conflict(struct file_lock *lease, struct file_lock *breaker)\r\n{\r\nif ((breaker->fl_flags & FL_LAYOUT) != (lease->fl_flags & FL_LAYOUT))\r\nreturn false;\r\nif ((breaker->fl_flags & FL_DELEG) && (lease->fl_flags & FL_LEASE))\r\nreturn false;\r\nreturn locks_conflict(breaker, lease);\r\n}\r\nstatic bool\r\nany_leases_conflict(struct inode *inode, struct file_lock *breaker)\r\n{\r\nstruct file_lock_context *ctx = inode->i_flctx;\r\nstruct file_lock *fl;\r\nlockdep_assert_held(&ctx->flc_lock);\r\nlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\r\nif (leases_conflict(fl, breaker))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint __break_lease(struct inode *inode, unsigned int mode, unsigned int type)\r\n{\r\nint error = 0;\r\nstruct file_lock_context *ctx;\r\nstruct file_lock *new_fl, *fl, *tmp;\r\nunsigned long break_time;\r\nint want_write = (mode & O_ACCMODE) != O_RDONLY;\r\nLIST_HEAD(dispose);\r\nnew_fl = lease_alloc(NULL, want_write ? F_WRLCK : F_RDLCK);\r\nif (IS_ERR(new_fl))\r\nreturn PTR_ERR(new_fl);\r\nnew_fl->fl_flags = type;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx) {\r\nWARN_ON_ONCE(1);\r\nreturn error;\r\n}\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\ntime_out_leases(inode, &dispose);\r\nif (!any_leases_conflict(inode, new_fl))\r\ngoto out;\r\nbreak_time = 0;\r\nif (lease_break_time > 0) {\r\nbreak_time = jiffies + lease_break_time * HZ;\r\nif (break_time == 0)\r\nbreak_time++;\r\n}\r\nlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list) {\r\nif (!leases_conflict(fl, new_fl))\r\ncontinue;\r\nif (want_write) {\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\ncontinue;\r\nfl->fl_flags |= FL_UNLOCK_PENDING;\r\nfl->fl_break_time = break_time;\r\n} else {\r\nif (lease_breaking(fl))\r\ncontinue;\r\nfl->fl_flags |= FL_DOWNGRADE_PENDING;\r\nfl->fl_downgrade_time = break_time;\r\n}\r\nif (fl->fl_lmops->lm_break(fl))\r\nlocks_delete_lock_ctx(fl, &dispose);\r\n}\r\nif (list_empty(&ctx->flc_lease))\r\ngoto out;\r\nif (mode & O_NONBLOCK) {\r\ntrace_break_lease_noblock(inode, new_fl);\r\nerror = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nrestart:\r\nfl = list_first_entry(&ctx->flc_lease, struct file_lock, fl_list);\r\nbreak_time = fl->fl_break_time;\r\nif (break_time != 0)\r\nbreak_time -= jiffies;\r\nif (break_time == 0)\r\nbreak_time++;\r\nlocks_insert_block(fl, new_fl);\r\ntrace_break_lease_block(inode, new_fl);\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\nerror = wait_event_interruptible_timeout(new_fl->fl_wait,\r\n!new_fl->fl_next, break_time);\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\ntrace_break_lease_unblock(inode, new_fl);\r\nlocks_delete_block(new_fl);\r\nif (error >= 0) {\r\nif (error == 0)\r\ntime_out_leases(inode, &dispose);\r\nif (any_leases_conflict(inode, new_fl))\r\ngoto restart;\r\nerror = 0;\r\n}\r\nout:\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\nlocks_free_lock(new_fl);\r\nreturn error;\r\n}\r\nvoid lease_get_mtime(struct inode *inode, struct timespec *time)\r\n{\r\nbool has_lease = false;\r\nstruct file_lock_context *ctx;\r\nstruct file_lock *fl;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (ctx && !list_empty_careful(&ctx->flc_lease)) {\r\nspin_lock(&ctx->flc_lock);\r\nfl = list_first_entry_or_null(&ctx->flc_lease,\r\nstruct file_lock, fl_list);\r\nif (fl && (fl->fl_type == F_WRLCK))\r\nhas_lease = true;\r\nspin_unlock(&ctx->flc_lock);\r\n}\r\nif (has_lease)\r\n*time = current_time(inode);\r\nelse\r\n*time = inode->i_mtime;\r\n}\r\nint fcntl_getlease(struct file *filp)\r\n{\r\nstruct file_lock *fl;\r\nstruct inode *inode = locks_inode(filp);\r\nstruct file_lock_context *ctx;\r\nint type = F_UNLCK;\r\nLIST_HEAD(dispose);\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (ctx && !list_empty_careful(&ctx->flc_lease)) {\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\ntime_out_leases(inode, &dispose);\r\nlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\r\nif (fl->fl_file != filp)\r\ncontinue;\r\ntype = target_leasetype(fl);\r\nbreak;\r\n}\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\n}\r\nreturn type;\r\n}\r\nstatic int\r\ncheck_conflicting_open(const struct dentry *dentry, const long arg, int flags)\r\n{\r\nint ret = 0;\r\nstruct inode *inode = dentry->d_inode;\r\nif (flags & FL_LAYOUT)\r\nreturn 0;\r\nif ((arg == F_RDLCK) &&\r\n(atomic_read(&d_real_inode(dentry)->i_writecount) > 0))\r\nreturn -EAGAIN;\r\nif ((arg == F_WRLCK) && ((d_count(dentry) > 1) ||\r\n(atomic_read(&inode->i_count) > 1)))\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic int\r\ngeneric_add_lease(struct file *filp, long arg, struct file_lock **flp, void **priv)\r\n{\r\nstruct file_lock *fl, *my_fl = NULL, *lease;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct file_lock_context *ctx;\r\nbool is_deleg = (*flp)->fl_flags & FL_DELEG;\r\nint error;\r\nLIST_HEAD(dispose);\r\nlease = *flp;\r\ntrace_generic_add_lease(inode, lease);\r\nctx = locks_get_lock_context(inode, arg);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (is_deleg && !inode_trylock(inode))\r\nreturn -EAGAIN;\r\nif (is_deleg && arg == F_WRLCK) {\r\ninode_unlock(inode);\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\ntime_out_leases(inode, &dispose);\r\nerror = check_conflicting_open(dentry, arg, lease->fl_flags);\r\nif (error)\r\ngoto out;\r\nerror = -EAGAIN;\r\nlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\r\nif (fl->fl_file == filp &&\r\nfl->fl_owner == lease->fl_owner) {\r\nmy_fl = fl;\r\ncontinue;\r\n}\r\nif (arg == F_WRLCK)\r\ngoto out;\r\nif (fl->fl_flags & FL_UNLOCK_PENDING)\r\ngoto out;\r\n}\r\nif (my_fl != NULL) {\r\nlease = my_fl;\r\nerror = lease->fl_lmops->lm_change(lease, arg, &dispose);\r\nif (error)\r\ngoto out;\r\ngoto out_setup;\r\n}\r\nerror = -EINVAL;\r\nif (!leases_enable)\r\ngoto out;\r\nlocks_insert_lock_ctx(lease, &ctx->flc_lease);\r\nsmp_mb();\r\nerror = check_conflicting_open(dentry, arg, lease->fl_flags);\r\nif (error) {\r\nlocks_unlink_lock_ctx(lease);\r\ngoto out;\r\n}\r\nout_setup:\r\nif (lease->fl_lmops->lm_setup)\r\nlease->fl_lmops->lm_setup(lease, priv);\r\nout:\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\nif (is_deleg)\r\ninode_unlock(inode);\r\nif (!error && !my_fl)\r\n*flp = NULL;\r\nreturn error;\r\n}\r\nstatic int generic_delete_lease(struct file *filp, void *owner)\r\n{\r\nint error = -EAGAIN;\r\nstruct file_lock *fl, *victim = NULL;\r\nstruct inode *inode = locks_inode(filp);\r\nstruct file_lock_context *ctx;\r\nLIST_HEAD(dispose);\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx) {\r\ntrace_generic_delete_lease(inode, NULL);\r\nreturn error;\r\n}\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\nlist_for_each_entry(fl, &ctx->flc_lease, fl_list) {\r\nif (fl->fl_file == filp &&\r\nfl->fl_owner == owner) {\r\nvictim = fl;\r\nbreak;\r\n}\r\n}\r\ntrace_generic_delete_lease(inode, victim);\r\nif (victim)\r\nerror = fl->fl_lmops->lm_change(victim, F_UNLCK, &dispose);\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\nreturn error;\r\n}\r\nint generic_setlease(struct file *filp, long arg, struct file_lock **flp,\r\nvoid **priv)\r\n{\r\nstruct inode *inode = locks_inode(filp);\r\nint error;\r\nif ((!uid_eq(current_fsuid(), inode->i_uid)) && !capable(CAP_LEASE))\r\nreturn -EACCES;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EINVAL;\r\nerror = security_file_lock(filp, arg);\r\nif (error)\r\nreturn error;\r\nswitch (arg) {\r\ncase F_UNLCK:\r\nreturn generic_delete_lease(filp, *priv);\r\ncase F_RDLCK:\r\ncase F_WRLCK:\r\nif (!(*flp)->fl_lmops->lm_break) {\r\nWARN_ON_ONCE(1);\r\nreturn -ENOLCK;\r\n}\r\nreturn generic_add_lease(filp, arg, flp, priv);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint\r\nvfs_setlease(struct file *filp, long arg, struct file_lock **lease, void **priv)\r\n{\r\nif (filp->f_op->setlease && is_remote_lock(filp))\r\nreturn filp->f_op->setlease(filp, arg, lease, priv);\r\nelse\r\nreturn generic_setlease(filp, arg, lease, priv);\r\n}\r\nstatic int do_fcntl_add_lease(unsigned int fd, struct file *filp, long arg)\r\n{\r\nstruct file_lock *fl;\r\nstruct fasync_struct *new;\r\nint error;\r\nfl = lease_alloc(filp, arg);\r\nif (IS_ERR(fl))\r\nreturn PTR_ERR(fl);\r\nnew = fasync_alloc();\r\nif (!new) {\r\nlocks_free_lock(fl);\r\nreturn -ENOMEM;\r\n}\r\nnew->fa_fd = fd;\r\nerror = vfs_setlease(filp, arg, &fl, (void **)&new);\r\nif (fl)\r\nlocks_free_lock(fl);\r\nif (new)\r\nfasync_free(new);\r\nreturn error;\r\n}\r\nint fcntl_setlease(unsigned int fd, struct file *filp, long arg)\r\n{\r\nif (arg == F_UNLCK)\r\nreturn vfs_setlease(filp, F_UNLCK, NULL, (void **)&filp);\r\nreturn do_fcntl_add_lease(fd, filp, arg);\r\n}\r\nstatic int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl)\r\n{\r\nint error;\r\nmight_sleep();\r\nfor (;;) {\r\nerror = flock_lock_inode(inode, fl);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nint locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)\r\n{\r\nint res = 0;\r\nswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\r\ncase FL_POSIX:\r\nres = posix_lock_inode_wait(inode, fl);\r\nbreak;\r\ncase FL_FLOCK:\r\nres = flock_lock_inode_wait(inode, fl);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn res;\r\n}\r\nint vfs_test_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nif (filp->f_op->lock && is_remote_lock(filp))\r\nreturn filp->f_op->lock(filp, F_GETLK, fl);\r\nposix_test_lock(filp, fl);\r\nreturn 0;\r\n}\r\nstatic int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)\r\n{\r\nflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\r\n#if BITS_PER_LONG == 32\r\nif (fl->fl_start > OFFT_OFFSET_MAX)\r\nreturn -EOVERFLOW;\r\nif (fl->fl_end != OFFSET_MAX && fl->fl_end > OFFT_OFFSET_MAX)\r\nreturn -EOVERFLOW;\r\n#endif\r\nflock->l_start = fl->fl_start;\r\nflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\r\nfl->fl_end - fl->fl_start + 1;\r\nflock->l_whence = 0;\r\nflock->l_type = fl->fl_type;\r\nreturn 0;\r\n}\r\nstatic void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)\r\n{\r\nflock->l_pid = IS_OFDLCK(fl) ? -1 : fl->fl_pid;\r\nflock->l_start = fl->fl_start;\r\nflock->l_len = fl->fl_end == OFFSET_MAX ? 0 :\r\nfl->fl_end - fl->fl_start + 1;\r\nflock->l_whence = 0;\r\nflock->l_type = fl->fl_type;\r\n}\r\nint fcntl_getlk(struct file *filp, unsigned int cmd, struct flock __user *l)\r\n{\r\nstruct file_lock file_lock;\r\nstruct flock flock;\r\nint error;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\nerror = -EINVAL;\r\nif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\r\ngoto out;\r\nerror = flock_to_posix_lock(filp, &file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nif (cmd == F_OFD_GETLK) {\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_GETLK;\r\nfile_lock.fl_flags |= FL_OFDLCK;\r\nfile_lock.fl_owner = filp;\r\n}\r\nerror = vfs_test_lock(filp, &file_lock);\r\nif (error)\r\ngoto out;\r\nflock.l_type = file_lock.fl_type;\r\nif (file_lock.fl_type != F_UNLCK) {\r\nerror = posix_lock_to_flock(&flock, &file_lock);\r\nif (error)\r\ngoto rel_priv;\r\n}\r\nerror = -EFAULT;\r\nif (!copy_to_user(l, &flock, sizeof(flock)))\r\nerror = 0;\r\nrel_priv:\r\nlocks_release_private(&file_lock);\r\nout:\r\nreturn error;\r\n}\r\nint vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)\r\n{\r\nif (filp->f_op->lock && is_remote_lock(filp))\r\nreturn filp->f_op->lock(filp, cmd, fl);\r\nelse\r\nreturn posix_lock_file(filp, fl, conf);\r\n}\r\nstatic int do_lock_file_wait(struct file *filp, unsigned int cmd,\r\nstruct file_lock *fl)\r\n{\r\nint error;\r\nerror = security_file_lock(filp, fl->fl_type);\r\nif (error)\r\nreturn error;\r\nfor (;;) {\r\nerror = vfs_lock_file(filp, cmd, fl, NULL);\r\nif (error != FILE_LOCK_DEFERRED)\r\nbreak;\r\nerror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\r\nif (!error)\r\ncontinue;\r\nlocks_delete_block(fl);\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\ncheck_fmode_for_setlk(struct file_lock *fl)\r\n{\r\nswitch (fl->fl_type) {\r\ncase F_RDLCK:\r\nif (!(fl->fl_file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nbreak;\r\ncase F_WRLCK:\r\nif (!(fl->fl_file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\n}\r\nreturn 0;\r\n}\r\nint fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\r\nstruct flock __user *l)\r\n{\r\nstruct file_lock *file_lock = locks_alloc_lock();\r\nstruct flock flock;\r\nstruct inode *inode;\r\nstruct file *f;\r\nint error;\r\nif (file_lock == NULL)\r\nreturn -ENOLCK;\r\ninode = locks_inode(filp);\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\nif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\nerror = flock_to_posix_lock(filp, file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nerror = check_fmode_for_setlk(file_lock);\r\nif (error)\r\ngoto out;\r\nswitch (cmd) {\r\ncase F_OFD_SETLK:\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_SETLK;\r\nfile_lock->fl_flags |= FL_OFDLCK;\r\nfile_lock->fl_owner = filp;\r\nbreak;\r\ncase F_OFD_SETLKW:\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_SETLKW;\r\nfile_lock->fl_flags |= FL_OFDLCK;\r\nfile_lock->fl_owner = filp;\r\ncase F_SETLKW:\r\nfile_lock->fl_flags |= FL_SLEEP;\r\n}\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nif (!error && file_lock->fl_type != F_UNLCK &&\r\n!(file_lock->fl_flags & FL_OFDLCK)) {\r\nspin_lock(&current->files->file_lock);\r\nf = fcheck(fd);\r\nspin_unlock(&current->files->file_lock);\r\nif (f != filp) {\r\nfile_lock->fl_type = F_UNLCK;\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nWARN_ON_ONCE(error);\r\nerror = -EBADF;\r\n}\r\n}\r\nout:\r\ntrace_fcntl_setlk(inode, file_lock, error);\r\nlocks_free_lock(file_lock);\r\nreturn error;\r\n}\r\nint fcntl_getlk64(struct file *filp, unsigned int cmd, struct flock64 __user *l)\r\n{\r\nstruct file_lock file_lock;\r\nstruct flock64 flock;\r\nint error;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\nerror = -EINVAL;\r\nif ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))\r\ngoto out;\r\nerror = flock64_to_posix_lock(filp, &file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nif (cmd == F_OFD_GETLK) {\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_GETLK64;\r\nfile_lock.fl_flags |= FL_OFDLCK;\r\nfile_lock.fl_owner = filp;\r\n}\r\nerror = vfs_test_lock(filp, &file_lock);\r\nif (error)\r\ngoto out;\r\nflock.l_type = file_lock.fl_type;\r\nif (file_lock.fl_type != F_UNLCK)\r\nposix_lock_to_flock64(&flock, &file_lock);\r\nerror = -EFAULT;\r\nif (!copy_to_user(l, &flock, sizeof(flock)))\r\nerror = 0;\r\nlocks_release_private(&file_lock);\r\nout:\r\nreturn error;\r\n}\r\nint fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,\r\nstruct flock64 __user *l)\r\n{\r\nstruct file_lock *file_lock = locks_alloc_lock();\r\nstruct flock64 flock;\r\nstruct inode *inode;\r\nstruct file *f;\r\nint error;\r\nif (file_lock == NULL)\r\nreturn -ENOLCK;\r\nerror = -EFAULT;\r\nif (copy_from_user(&flock, l, sizeof(flock)))\r\ngoto out;\r\ninode = locks_inode(filp);\r\nif (mandatory_lock(inode) && mapping_writably_mapped(filp->f_mapping)) {\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\nerror = flock64_to_posix_lock(filp, file_lock, &flock);\r\nif (error)\r\ngoto out;\r\nerror = check_fmode_for_setlk(file_lock);\r\nif (error)\r\ngoto out;\r\nswitch (cmd) {\r\ncase F_OFD_SETLK:\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_SETLK64;\r\nfile_lock->fl_flags |= FL_OFDLCK;\r\nfile_lock->fl_owner = filp;\r\nbreak;\r\ncase F_OFD_SETLKW:\r\nerror = -EINVAL;\r\nif (flock.l_pid != 0)\r\ngoto out;\r\ncmd = F_SETLKW64;\r\nfile_lock->fl_flags |= FL_OFDLCK;\r\nfile_lock->fl_owner = filp;\r\ncase F_SETLKW64:\r\nfile_lock->fl_flags |= FL_SLEEP;\r\n}\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nif (!error && file_lock->fl_type != F_UNLCK &&\r\n!(file_lock->fl_flags & FL_OFDLCK)) {\r\nspin_lock(&current->files->file_lock);\r\nf = fcheck(fd);\r\nspin_unlock(&current->files->file_lock);\r\nif (f != filp) {\r\nfile_lock->fl_type = F_UNLCK;\r\nerror = do_lock_file_wait(filp, cmd, file_lock);\r\nWARN_ON_ONCE(error);\r\nerror = -EBADF;\r\n}\r\n}\r\nout:\r\nlocks_free_lock(file_lock);\r\nreturn error;\r\n}\r\nvoid locks_remove_posix(struct file *filp, fl_owner_t owner)\r\n{\r\nint error;\r\nstruct inode *inode = locks_inode(filp);\r\nstruct file_lock lock;\r\nstruct file_lock_context *ctx;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx || list_empty(&ctx->flc_posix))\r\nreturn;\r\nlock.fl_type = F_UNLCK;\r\nlock.fl_flags = FL_POSIX | FL_CLOSE;\r\nlock.fl_start = 0;\r\nlock.fl_end = OFFSET_MAX;\r\nlock.fl_owner = owner;\r\nlock.fl_pid = current->tgid;\r\nlock.fl_file = filp;\r\nlock.fl_ops = NULL;\r\nlock.fl_lmops = NULL;\r\nerror = vfs_lock_file(filp, F_SETLK, &lock, NULL);\r\nif (lock.fl_ops && lock.fl_ops->fl_release_private)\r\nlock.fl_ops->fl_release_private(&lock);\r\ntrace_locks_remove_posix(inode, &lock, error);\r\n}\r\nstatic void\r\nlocks_remove_flock(struct file *filp, struct file_lock_context *flctx)\r\n{\r\nstruct file_lock fl = {\r\n.fl_owner = filp,\r\n.fl_pid = current->tgid,\r\n.fl_file = filp,\r\n.fl_flags = FL_FLOCK,\r\n.fl_type = F_UNLCK,\r\n.fl_end = OFFSET_MAX,\r\n};\r\nstruct inode *inode = locks_inode(filp);\r\nif (list_empty(&flctx->flc_flock))\r\nreturn;\r\nif (filp->f_op->flock && is_remote_lock(filp))\r\nfilp->f_op->flock(filp, F_SETLKW, &fl);\r\nelse\r\nflock_lock_inode(inode, &fl);\r\nif (fl.fl_ops && fl.fl_ops->fl_release_private)\r\nfl.fl_ops->fl_release_private(&fl);\r\n}\r\nstatic void\r\nlocks_remove_lease(struct file *filp, struct file_lock_context *ctx)\r\n{\r\nstruct file_lock *fl, *tmp;\r\nLIST_HEAD(dispose);\r\nif (list_empty(&ctx->flc_lease))\r\nreturn;\r\npercpu_down_read_preempt_disable(&file_rwsem);\r\nspin_lock(&ctx->flc_lock);\r\nlist_for_each_entry_safe(fl, tmp, &ctx->flc_lease, fl_list)\r\nif (filp == fl->fl_file)\r\nlease_modify(fl, F_UNLCK, &dispose);\r\nspin_unlock(&ctx->flc_lock);\r\npercpu_up_read_preempt_enable(&file_rwsem);\r\nlocks_dispose_list(&dispose);\r\n}\r\nvoid locks_remove_file(struct file *filp)\r\n{\r\nstruct file_lock_context *ctx;\r\nctx = smp_load_acquire(&locks_inode(filp)->i_flctx);\r\nif (!ctx)\r\nreturn;\r\nlocks_remove_posix(filp, filp);\r\nlocks_remove_flock(filp, ctx);\r\nlocks_remove_lease(filp, ctx);\r\n}\r\nint\r\nposix_unblock_lock(struct file_lock *waiter)\r\n{\r\nint status = 0;\r\nspin_lock(&blocked_lock_lock);\r\nif (waiter->fl_next)\r\n__locks_delete_block(waiter);\r\nelse\r\nstatus = -ENOENT;\r\nspin_unlock(&blocked_lock_lock);\r\nreturn status;\r\n}\r\nint vfs_cancel_lock(struct file *filp, struct file_lock *fl)\r\n{\r\nif (filp->f_op->lock && is_remote_lock(filp))\r\nreturn filp->f_op->lock(filp, F_CANCELLK, fl);\r\nreturn 0;\r\n}\r\nstatic void lock_get_status(struct seq_file *f, struct file_lock *fl,\r\nloff_t id, char *pfx)\r\n{\r\nstruct inode *inode = NULL;\r\nunsigned int fl_pid;\r\nif (fl->fl_nspid) {\r\nstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\r\nfl_pid = pid_nr_ns(fl->fl_nspid, proc_pidns);\r\nif (fl_pid == 0)\r\nreturn;\r\n} else\r\nfl_pid = fl->fl_pid;\r\nif (fl->fl_file != NULL)\r\ninode = locks_inode(fl->fl_file);\r\nseq_printf(f, "%lld:%s ", id, pfx);\r\nif (IS_POSIX(fl)) {\r\nif (fl->fl_flags & FL_ACCESS)\r\nseq_puts(f, "ACCESS");\r\nelse if (IS_OFDLCK(fl))\r\nseq_puts(f, "OFDLCK");\r\nelse\r\nseq_puts(f, "POSIX ");\r\nseq_printf(f, " %s ",\r\n(inode == NULL) ? "*NOINODE*" :\r\nmandatory_lock(inode) ? "MANDATORY" : "ADVISORY ");\r\n} else if (IS_FLOCK(fl)) {\r\nif (fl->fl_type & LOCK_MAND) {\r\nseq_puts(f, "FLOCK MSNFS ");\r\n} else {\r\nseq_puts(f, "FLOCK ADVISORY ");\r\n}\r\n} else if (IS_LEASE(fl)) {\r\nif (fl->fl_flags & FL_DELEG)\r\nseq_puts(f, "DELEG ");\r\nelse\r\nseq_puts(f, "LEASE ");\r\nif (lease_breaking(fl))\r\nseq_puts(f, "BREAKING ");\r\nelse if (fl->fl_file)\r\nseq_puts(f, "ACTIVE ");\r\nelse\r\nseq_puts(f, "BREAKER ");\r\n} else {\r\nseq_puts(f, "UNKNOWN UNKNOWN ");\r\n}\r\nif (fl->fl_type & LOCK_MAND) {\r\nseq_printf(f, "%s ",\r\n(fl->fl_type & LOCK_READ)\r\n? (fl->fl_type & LOCK_WRITE) ? "RW " : "READ "\r\n: (fl->fl_type & LOCK_WRITE) ? "WRITE" : "NONE ");\r\n} else {\r\nseq_printf(f, "%s ",\r\n(lease_breaking(fl))\r\n? (fl->fl_type == F_UNLCK) ? "UNLCK" : "READ "\r\n: (fl->fl_type == F_WRLCK) ? "WRITE" : "READ ");\r\n}\r\nif (inode) {\r\nseq_printf(f, "%d %02x:%02x:%ld ", fl_pid,\r\nMAJOR(inode->i_sb->s_dev),\r\nMINOR(inode->i_sb->s_dev), inode->i_ino);\r\n} else {\r\nseq_printf(f, "%d <none>:0 ", fl_pid);\r\n}\r\nif (IS_POSIX(fl)) {\r\nif (fl->fl_end == OFFSET_MAX)\r\nseq_printf(f, "%Ld EOF\n", fl->fl_start);\r\nelse\r\nseq_printf(f, "%Ld %Ld\n", fl->fl_start, fl->fl_end);\r\n} else {\r\nseq_puts(f, "0 EOF\n");\r\n}\r\n}\r\nstatic int locks_show(struct seq_file *f, void *v)\r\n{\r\nstruct locks_iterator *iter = f->private;\r\nstruct file_lock *fl, *bfl;\r\nstruct pid_namespace *proc_pidns = file_inode(f->file)->i_sb->s_fs_info;\r\nfl = hlist_entry(v, struct file_lock, fl_link);\r\nif (fl->fl_nspid && !pid_nr_ns(fl->fl_nspid, proc_pidns))\r\nreturn 0;\r\nlock_get_status(f, fl, iter->li_pos, "");\r\nlist_for_each_entry(bfl, &fl->fl_block, fl_block)\r\nlock_get_status(f, bfl, iter->li_pos, " ->");\r\nreturn 0;\r\n}\r\nstatic void __show_fd_locks(struct seq_file *f,\r\nstruct list_head *head, int *id,\r\nstruct file *filp, struct files_struct *files)\r\n{\r\nstruct file_lock *fl;\r\nlist_for_each_entry(fl, head, fl_list) {\r\nif (filp != fl->fl_file)\r\ncontinue;\r\nif (fl->fl_owner != files &&\r\nfl->fl_owner != filp)\r\ncontinue;\r\n(*id)++;\r\nseq_puts(f, "lock:\t");\r\nlock_get_status(f, fl, *id, "");\r\n}\r\n}\r\nvoid show_fd_locks(struct seq_file *f,\r\nstruct file *filp, struct files_struct *files)\r\n{\r\nstruct inode *inode = locks_inode(filp);\r\nstruct file_lock_context *ctx;\r\nint id = 0;\r\nctx = smp_load_acquire(&inode->i_flctx);\r\nif (!ctx)\r\nreturn;\r\nspin_lock(&ctx->flc_lock);\r\n__show_fd_locks(f, &ctx->flc_flock, &id, filp, files);\r\n__show_fd_locks(f, &ctx->flc_posix, &id, filp, files);\r\n__show_fd_locks(f, &ctx->flc_lease, &id, filp, files);\r\nspin_unlock(&ctx->flc_lock);\r\n}\r\nstatic void *locks_start(struct seq_file *f, loff_t *pos)\r\n__acquires(&blocked_lock_lock\r\nstatic void *locks_next(struct seq_file *f, void *v, loff_t *pos)\r\n{\r\nstruct locks_iterator *iter = f->private;\r\n++iter->li_pos;\r\nreturn seq_hlist_next_percpu(v, &file_lock_list.hlist, &iter->li_cpu, pos);\r\n}\r\nstatic void locks_stop(struct seq_file *f, void *v)\r\n__releases(&blocked_lock_lock\r\nstatic int locks_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn seq_open_private(filp, &locks_seq_operations,\r\nsizeof(struct locks_iterator));\r\n}\r\nstatic int __init proc_locks_init(void)\r\n{\r\nproc_create("locks", 0, NULL, &proc_locks_operations);\r\nreturn 0;\r\n}\r\nstatic int __init filelock_init(void)\r\n{\r\nint i;\r\nflctx_cache = kmem_cache_create("file_lock_ctx",\r\nsizeof(struct file_lock_context), 0, SLAB_PANIC, NULL);\r\nfilelock_cache = kmem_cache_create("file_lock_cache",\r\nsizeof(struct file_lock), 0, SLAB_PANIC, NULL);\r\nfor_each_possible_cpu(i) {\r\nstruct file_lock_list_struct *fll = per_cpu_ptr(&file_lock_list, i);\r\nspin_lock_init(&fll->lock);\r\nINIT_HLIST_HEAD(&fll->hlist);\r\n}\r\nreturn 0;\r\n}
