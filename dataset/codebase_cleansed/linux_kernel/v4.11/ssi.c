int rsnd_ssi_use_busif(struct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_mod *mod = rsnd_io_to_mod_ssi(io);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint use_busif = 0;\r\nif (!rsnd_ssi_is_dma_mode(mod))\r\nreturn 0;\r\nif (!(rsnd_ssi_mode_flags(ssi) & RSND_SSI_NO_BUSIF))\r\nuse_busif = 1;\r\nif (rsnd_io_to_mod_src(io))\r\nuse_busif = 1;\r\nreturn use_busif;\r\n}\r\nstatic void rsnd_ssi_status_clear(struct rsnd_mod *mod)\r\n{\r\nrsnd_mod_write(mod, SSISR, 0);\r\n}\r\nstatic u32 rsnd_ssi_status_get(struct rsnd_mod *mod)\r\n{\r\nreturn rsnd_mod_read(mod, SSISR);\r\n}\r\nstatic void rsnd_ssi_status_check(struct rsnd_mod *mod,\r\nu32 bit)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nu32 status;\r\nint i;\r\nfor (i = 0; i < 1024; i++) {\r\nstatus = rsnd_ssi_status_get(mod);\r\nif (status & bit)\r\nreturn;\r\nudelay(50);\r\n}\r\ndev_warn(dev, "%s[%d] status check failed\n",\r\nrsnd_mod_name(mod), rsnd_mod_id(mod));\r\n}\r\nstatic u32 rsnd_ssi_multi_slaves(struct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_mod *mod;\r\nenum rsnd_mod_type types[] = {\r\nRSND_MOD_SSIM1,\r\nRSND_MOD_SSIM2,\r\nRSND_MOD_SSIM3,\r\n};\r\nint i, mask;\r\nmask = 0;\r\nfor (i = 0; i < ARRAY_SIZE(types); i++) {\r\nmod = rsnd_io_to_mod(io, types[i]);\r\nif (!mod)\r\ncontinue;\r\nmask |= 1 << rsnd_mod_id(mod);\r\n}\r\nreturn mask;\r\n}\r\nstatic u32 rsnd_ssi_run_mods(struct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_mod *ssi_mod = rsnd_io_to_mod_ssi(io);\r\nstruct rsnd_mod *ssi_parent_mod = rsnd_io_to_mod_ssip(io);\r\nreturn rsnd_ssi_multi_slaves_runtime(io) |\r\n1 << rsnd_mod_id(ssi_mod) |\r\n1 << rsnd_mod_id(ssi_parent_mod);\r\n}\r\nu32 rsnd_ssi_multi_slaves_runtime(struct rsnd_dai_stream *io)\r\n{\r\nif (rsnd_runtime_is_ssi_multi(io))\r\nreturn rsnd_ssi_multi_slaves(io);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_master_clk_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_io_to_priv(io);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_mod *ssi_parent_mod = rsnd_io_to_mod_ssip(io);\r\nint chan = rsnd_runtime_channel_for_ssi(io);\r\nint j, ret;\r\nint ssi_clk_mul_table[] = {\r\n1, 2, 4, 8, 16, 6, 12,\r\n};\r\nunsigned int main_rate;\r\nunsigned int rate = rsnd_io_is_play(io) ?\r\nrsnd_src_get_out_rate(priv, io) :\r\nrsnd_src_get_in_rate(priv, io);\r\nif (!rsnd_rdai_is_clk_master(rdai))\r\nreturn 0;\r\nif (ssi_parent_mod && !rsnd_ssi_is_parent(mod, io))\r\nreturn 0;\r\nif (rsnd_ssi_is_multi_slave(mod, io))\r\nreturn 0;\r\nif (ssi->usrcnt > 1) {\r\nif (ssi->rate != rate) {\r\ndev_err(dev, "SSI parent/child should use same rate\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(ssi_clk_mul_table); j++) {\r\nmain_rate = rate * 32 * chan * ssi_clk_mul_table[j];\r\nret = rsnd_adg_ssi_clk_try_start(mod, main_rate);\r\nif (0 == ret) {\r\nssi->cr_clk = FORCE | SWL_32 |\r\nSCKD | SWSD | CKDV(j);\r\nssi->wsr = CONT;\r\nssi->rate = rate;\r\ndev_dbg(dev, "%s[%d] outputs %u Hz\n",\r\nrsnd_mod_name(mod),\r\nrsnd_mod_id(mod), rate);\r\nreturn 0;\r\n}\r\n}\r\ndev_err(dev, "unsupported clock rate\n");\r\nreturn -EIO;\r\n}\r\nstatic void rsnd_ssi_master_clk_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct rsnd_mod *ssi_parent_mod = rsnd_io_to_mod_ssip(io);\r\nif (!rsnd_rdai_is_clk_master(rdai))\r\nreturn;\r\nif (ssi_parent_mod && !rsnd_ssi_is_parent(mod, io))\r\nreturn;\r\nif (ssi->usrcnt > 1)\r\nreturn;\r\nssi->cr_clk = 0;\r\nssi->rate = 0;\r\nrsnd_adg_ssi_clk_stop(mod);\r\n}\r\nstatic void rsnd_ssi_config_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nu32 cr_own;\r\nu32 cr_mode;\r\nu32 wsr;\r\nint is_tdm;\r\nis_tdm = rsnd_runtime_is_ssi_tdm(io);\r\ncr_own = FORCE | SWL_32 | PDTA;\r\nif (rdai->bit_clk_inv)\r\ncr_own |= SCKP;\r\nif (rdai->frm_clk_inv ^ is_tdm)\r\ncr_own |= SWSP;\r\nif (rdai->data_alignment)\r\ncr_own |= SDTA;\r\nif (rdai->sys_delay)\r\ncr_own |= DEL;\r\nif (rsnd_io_is_play(io))\r\ncr_own |= TRMD;\r\nswitch (runtime->sample_bits) {\r\ncase 16:\r\ncr_own |= DWL_16;\r\nbreak;\r\ncase 32:\r\ncr_own |= DWL_24;\r\nbreak;\r\n}\r\nif (rsnd_ssi_is_dma_mode(mod)) {\r\ncr_mode = UIEN | OIEN |\r\nDMEN;\r\n} else {\r\ncr_mode = DIEN;\r\n}\r\nwsr = ssi->wsr;\r\nif (is_tdm) {\r\nwsr |= WS_MODE;\r\ncr_own |= CHNL_8;\r\n}\r\nssi->cr_own = cr_own;\r\nssi->cr_mode = cr_mode;\r\nssi->wsr = wsr;\r\n}\r\nstatic void rsnd_ssi_register_setup(struct rsnd_mod *mod)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nrsnd_mod_write(mod, SSIWSR, ssi->wsr);\r\nrsnd_mod_write(mod, SSICR, ssi->cr_own |\r\nssi->cr_clk |\r\nssi->cr_mode);\r\n}\r\nstatic int rsnd_ssi_init(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint ret;\r\nif (!rsnd_ssi_is_run_mods(mod, io))\r\nreturn 0;\r\nssi->usrcnt++;\r\nrsnd_mod_power_on(mod);\r\nret = rsnd_ssi_master_clk_start(mod, io);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!rsnd_ssi_is_parent(mod, io))\r\nrsnd_ssi_config_init(mod, io);\r\nrsnd_ssi_register_setup(mod);\r\nrsnd_ssi_status_clear(mod);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_quit(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nif (!rsnd_ssi_is_run_mods(mod, io))\r\nreturn 0;\r\nif (!ssi->usrcnt) {\r\ndev_err(dev, "%s[%d] usrcnt error\n",\r\nrsnd_mod_name(mod), rsnd_mod_id(mod));\r\nreturn -EIO;\r\n}\r\nif (!rsnd_ssi_is_parent(mod, io))\r\nssi->cr_own = 0;\r\nrsnd_ssi_master_clk_stop(mod, io);\r\nrsnd_mod_power_off(mod);\r\nssi->usrcnt--;\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_hw_params(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint chan = params_channels(params);\r\nif (ssi->usrcnt) {\r\nif (ssi->chan != chan)\r\nreturn -EIO;\r\n}\r\nssi->chan = chan;\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_start(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nif (!rsnd_ssi_is_run_mods(mod, io))\r\nreturn 0;\r\nif (rsnd_ssi_multi_slaves_runtime(io))\r\nreturn 0;\r\nrsnd_mod_bset(mod, SSICR, EN, EN);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_stop(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nu32 cr;\r\nif (!rsnd_ssi_is_run_mods(mod, io))\r\nreturn 0;\r\nif (ssi->usrcnt > 1)\r\nreturn 0;\r\ncr = ssi->cr_own |\r\nssi->cr_clk;\r\nrsnd_mod_write(mod, SSICR, cr | EN);\r\nrsnd_ssi_status_check(mod, DIRQ);\r\nrsnd_mod_write(mod, SSICR, cr);\r\nrsnd_ssi_status_check(mod, IIRQ);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_irq(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv,\r\nint enable)\r\n{\r\nu32 val = 0;\r\nif (rsnd_is_gen1(priv))\r\nreturn 0;\r\nif (rsnd_ssi_is_parent(mod, io))\r\nreturn 0;\r\nif (!rsnd_ssi_is_run_mods(mod, io))\r\nreturn 0;\r\nif (enable)\r\nval = rsnd_ssi_is_dma_mode(mod) ? 0x0e000000 : 0x0f000000;\r\nrsnd_mod_write(mod, SSI_INT_ENABLE, val);\r\nreturn 0;\r\n}\r\nstatic void __rsnd_ssi_interrupt(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nint is_dma = rsnd_ssi_is_dma_mode(mod);\r\nu32 status;\r\nbool elapsed = false;\r\nbool stop = false;\r\nspin_lock(&priv->lock);\r\nif (!rsnd_io_is_working(io))\r\ngoto rsnd_ssi_interrupt_out;\r\nstatus = rsnd_ssi_status_get(mod);\r\nif (!is_dma && (status & DIRQ)) {\r\nstruct snd_pcm_runtime *runtime = rsnd_io_to_runtime(io);\r\nu32 *buf = (u32 *)(runtime->dma_area +\r\nrsnd_dai_pointer_offset(io, 0));\r\nif (rsnd_io_is_play(io))\r\nrsnd_mod_write(mod, SSITDR, *buf);\r\nelse\r\n*buf = rsnd_mod_read(mod, SSIRDR);\r\nelapsed = rsnd_dai_pointer_update(io, sizeof(*buf));\r\n}\r\nif (is_dma && (status & (UIRQ | OIRQ)))\r\nstop = true;\r\nrsnd_ssi_status_clear(mod);\r\nrsnd_ssi_interrupt_out:\r\nspin_unlock(&priv->lock);\r\nif (elapsed)\r\nrsnd_dai_period_elapsed(io);\r\nif (stop)\r\nsnd_pcm_stop_xrun(io->substream);\r\n}\r\nstatic irqreturn_t rsnd_ssi_interrupt(int irq, void *data)\r\n{\r\nstruct rsnd_mod *mod = data;\r\nrsnd_mod_interrupt(mod, __rsnd_ssi_interrupt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rsnd_ssi_parent_attach(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nif (!__rsnd_ssi_is_pin_sharing(mod))\r\nreturn;\r\nif (!rsnd_rdai_is_clk_master(rdai))\r\nreturn;\r\nswitch (rsnd_mod_id(mod)) {\r\ncase 1:\r\ncase 2:\r\nrsnd_dai_connect(rsnd_ssi_mod_get(priv, 0), io, RSND_MOD_SSIP);\r\nbreak;\r\ncase 4:\r\nrsnd_dai_connect(rsnd_ssi_mod_get(priv, 3), io, RSND_MOD_SSIP);\r\nbreak;\r\ncase 8:\r\nrsnd_dai_connect(rsnd_ssi_mod_get(priv, 7), io, RSND_MOD_SSIP);\r\nbreak;\r\n}\r\n}\r\nstatic int rsnd_ssi_pcm_new(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct snd_soc_pcm_runtime *rtd)\r\n{\r\nrsnd_ssi_parent_attach(mod, io);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_common_probe(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint ret;\r\nif (rsnd_ssi_is_multi_slave(mod, io))\r\nreturn 0;\r\nret = rsnd_ssiu_attach(io, mod);\r\nif (ret < 0)\r\nreturn ret;\r\nret = request_irq(ssi->irq,\r\nrsnd_ssi_interrupt,\r\nIRQF_SHARED,\r\ndev_name(dev), mod);\r\nreturn ret;\r\n}\r\nstatic int rsnd_ssi_dma_probe(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nint ret;\r\nif (rsnd_ssi_is_multi_slave(mod, io))\r\nreturn 0;\r\nret = rsnd_ssi_common_probe(mod, io, priv);\r\nif (ret)\r\nreturn ret;\r\nret = rsnd_dma_attach(io, mod, &ssi->dma);\r\nreturn ret;\r\n}\r\nstatic int rsnd_ssi_dma_remove(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nfree_irq(ssi->irq, mod);\r\nreturn 0;\r\n}\r\nstatic int rsnd_ssi_fallback(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io,\r\nstruct rsnd_priv *priv)\r\n{\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nmod->ops = &rsnd_ssi_pio_ops;\r\ndev_info(dev, "%s[%d] fallback to PIO mode\n",\r\nrsnd_mod_name(mod), rsnd_mod_id(mod));\r\nreturn 0;\r\n}\r\nstatic struct dma_chan *rsnd_ssi_dma_req(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod)\r\n{\r\nstruct rsnd_priv *priv = rsnd_mod_to_priv(mod);\r\nint is_play = rsnd_io_is_play(io);\r\nchar *name;\r\nif (rsnd_ssi_use_busif(io))\r\nname = is_play ? "rxu" : "txu";\r\nelse\r\nname = is_play ? "rx" : "tx";\r\nreturn rsnd_dma_request_channel(rsnd_ssi_of_node(priv),\r\nmod, name);\r\n}\r\nint rsnd_ssi_is_dma_mode(struct rsnd_mod *mod)\r\n{\r\nreturn mod->ops == &rsnd_ssi_dma_ops;\r\n}\r\nstatic void rsnd_ssi_connect(struct rsnd_mod *mod,\r\nstruct rsnd_dai_stream *io)\r\n{\r\nstruct rsnd_dai *rdai = rsnd_io_to_rdai(io);\r\nenum rsnd_mod_type types[] = {\r\nRSND_MOD_SSI,\r\nRSND_MOD_SSIM1,\r\nRSND_MOD_SSIM2,\r\nRSND_MOD_SSIM3,\r\n};\r\nenum rsnd_mod_type type;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(types); i++) {\r\ntype = types[i];\r\nif (!rsnd_io_to_mod(io, type)) {\r\nrsnd_dai_connect(mod, io, type);\r\nrsnd_set_slot(rdai, 2 * (i + 1), (i + 1));\r\nreturn;\r\n}\r\n}\r\n}\r\nvoid rsnd_parse_connect_ssi(struct rsnd_dai *rdai,\r\nstruct device_node *playback,\r\nstruct device_node *capture)\r\n{\r\nstruct rsnd_priv *priv = rsnd_rdai_to_priv(rdai);\r\nstruct device_node *node;\r\nstruct device_node *np;\r\nstruct rsnd_mod *mod;\r\nint i;\r\nnode = rsnd_ssi_of_node(priv);\r\nif (!node)\r\nreturn;\r\ni = 0;\r\nfor_each_child_of_node(node, np) {\r\nmod = rsnd_ssi_mod_get(priv, i);\r\nif (np == playback)\r\nrsnd_ssi_connect(mod, &rdai->playback);\r\nif (np == capture)\r\nrsnd_ssi_connect(mod, &rdai->capture);\r\ni++;\r\n}\r\nof_node_put(node);\r\n}\r\nstruct rsnd_mod *rsnd_ssi_mod_get(struct rsnd_priv *priv, int id)\r\n{\r\nif (WARN_ON(id < 0 || id >= rsnd_ssi_nr(priv)))\r\nid = 0;\r\nreturn rsnd_mod_get(rsnd_ssi_get(priv, id));\r\n}\r\nint __rsnd_ssi_is_pin_sharing(struct rsnd_mod *mod)\r\n{\r\nstruct rsnd_ssi *ssi = rsnd_mod_to_ssi(mod);\r\nreturn !!(rsnd_ssi_mode_flags(ssi) & RSND_SSI_CLK_PIN_SHARE);\r\n}\r\nstatic u32 *rsnd_ssi_get_status(struct rsnd_dai_stream *io,\r\nstruct rsnd_mod *mod,\r\nenum rsnd_mod_type type)\r\n{\r\nif (type == RSND_MOD_SSIP)\r\nreturn &io->parent_ssi_status;\r\nreturn rsnd_mod_get_status(io, mod, type);\r\n}\r\nint rsnd_ssi_probe(struct rsnd_priv *priv)\r\n{\r\nstruct device_node *node;\r\nstruct device_node *np;\r\nstruct device *dev = rsnd_priv_to_dev(priv);\r\nstruct rsnd_mod_ops *ops;\r\nstruct clk *clk;\r\nstruct rsnd_ssi *ssi;\r\nchar name[RSND_SSI_NAME_SIZE];\r\nint i, nr, ret;\r\nnode = rsnd_ssi_of_node(priv);\r\nif (!node)\r\nreturn -EINVAL;\r\nnr = of_get_child_count(node);\r\nif (!nr) {\r\nret = -EINVAL;\r\ngoto rsnd_ssi_probe_done;\r\n}\r\nssi = devm_kzalloc(dev, sizeof(*ssi) * nr, GFP_KERNEL);\r\nif (!ssi) {\r\nret = -ENOMEM;\r\ngoto rsnd_ssi_probe_done;\r\n}\r\npriv->ssi = ssi;\r\npriv->ssi_nr = nr;\r\ni = 0;\r\nfor_each_child_of_node(node, np) {\r\nssi = rsnd_ssi_get(priv, i);\r\nsnprintf(name, RSND_SSI_NAME_SIZE, "%s.%d",\r\nSSI_NAME, i);\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto rsnd_ssi_probe_done;\r\n}\r\nif (of_get_property(np, "shared-pin", NULL))\r\nssi->flags |= RSND_SSI_CLK_PIN_SHARE;\r\nif (of_get_property(np, "no-busif", NULL))\r\nssi->flags |= RSND_SSI_NO_BUSIF;\r\nssi->irq = irq_of_parse_and_map(np, 0);\r\nif (!ssi->irq) {\r\nret = -EINVAL;\r\ngoto rsnd_ssi_probe_done;\r\n}\r\nops = &rsnd_ssi_non_ops;\r\nif (of_property_read_bool(np, "pio-transfer"))\r\nops = &rsnd_ssi_pio_ops;\r\nelse\r\nops = &rsnd_ssi_dma_ops;\r\nret = rsnd_mod_init(priv, rsnd_mod_get(ssi), ops, clk,\r\nrsnd_ssi_get_status, RSND_MOD_SSI, i);\r\nif (ret)\r\ngoto rsnd_ssi_probe_done;\r\ni++;\r\n}\r\nret = 0;\r\nrsnd_ssi_probe_done:\r\nof_node_put(node);\r\nreturn ret;\r\n}\r\nvoid rsnd_ssi_remove(struct rsnd_priv *priv)\r\n{\r\nstruct rsnd_ssi *ssi;\r\nint i;\r\nfor_each_rsnd_ssi(ssi, priv, i) {\r\nrsnd_mod_quit(rsnd_mod_get(ssi));\r\n}\r\n}
