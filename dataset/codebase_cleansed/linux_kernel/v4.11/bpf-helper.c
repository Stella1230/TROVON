int bpf_resolve_jumps(struct bpf_labels *labels,\r\nstruct sock_filter *filter, size_t count)\r\n{\r\nsize_t i;\r\nif (count < 1 || count > BPF_MAXINSNS)\r\nreturn -1;\r\nfor (i = 0; i < count; ++i) {\r\nsize_t offset = count - i - 1;\r\nstruct sock_filter *instr = &filter[offset];\r\nif (instr->code != (BPF_JMP+BPF_JA))\r\ncontinue;\r\nswitch ((instr->jt<<8)|instr->jf) {\r\ncase (JUMP_JT<<8)|JUMP_JF:\r\nif (labels->labels[instr->k].location == 0xffffffff) {\r\nfprintf(stderr, "Unresolved label: '%s'\n",\r\nlabels->labels[instr->k].label);\r\nreturn 1;\r\n}\r\ninstr->k = labels->labels[instr->k].location -\r\n(offset + 1);\r\ninstr->jt = 0;\r\ninstr->jf = 0;\r\ncontinue;\r\ncase (LABEL_JT<<8)|LABEL_JF:\r\nif (labels->labels[instr->k].location != 0xffffffff) {\r\nfprintf(stderr, "Duplicate label use: '%s'\n",\r\nlabels->labels[instr->k].label);\r\nreturn 1;\r\n}\r\nlabels->labels[instr->k].location = offset;\r\ninstr->k = 0;\r\ninstr->jt = 0;\r\ninstr->jf = 0;\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\n__u32 seccomp_bpf_label(struct bpf_labels *labels, const char *label)\r\n{\r\nstruct __bpf_label *begin = labels->labels, *end;\r\nint id;\r\nif (labels->count == BPF_LABELS_MAX) {\r\nfprintf(stderr, "Too many labels\n");\r\nexit(1);\r\n}\r\nif (labels->count == 0) {\r\nbegin->label = label;\r\nbegin->location = 0xffffffff;\r\nlabels->count++;\r\nreturn 0;\r\n}\r\nend = begin + labels->count;\r\nfor (id = 0; begin < end; ++begin, ++id) {\r\nif (!strcmp(label, begin->label))\r\nreturn id;\r\n}\r\nbegin->label = label;\r\nbegin->location = 0xffffffff;\r\nlabels->count++;\r\nreturn id;\r\n}\r\nvoid seccomp_bpf_print(struct sock_filter *filter, size_t count)\r\n{\r\nstruct sock_filter *end = filter + count;\r\nfor ( ; filter < end; ++filter)\r\nprintf("{ code=%u,jt=%u,jf=%u,k=%u },\n",\r\nfilter->code, filter->jt, filter->jf, filter->k);\r\n}
