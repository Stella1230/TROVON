static int scarlett_ctl_switch_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = elem->channels;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_switch_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nint i, err, val;\r\nfor (i = 0; i < elem->channels; i++) {\r\nerr = snd_usb_get_cur_mix_value(elem, i, i, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = !val;\r\nucontrol->value.integer.value[i] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_switch_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nint i, changed = 0;\r\nint err, oval, val;\r\nfor (i = 0; i < elem->channels; i++) {\r\nerr = snd_usb_get_cur_mix_value(elem, i, i, &oval);\r\nif (err < 0)\r\nreturn err;\r\nval = ucontrol->value.integer.value[i];\r\nval = !val;\r\nif (oval != val) {\r\nerr = snd_usb_set_cur_mix_value(elem, i, i, val);\r\nif (err < 0)\r\nreturn err;\r\nchanged = 1;\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic int scarlett_ctl_resume(struct usb_mixer_elem_list *list)\r\n{\r\nstruct usb_mixer_elem_info *elem =\r\ncontainer_of(list, struct usb_mixer_elem_info, head);\r\nint i;\r\nfor (i = 0; i < elem->channels; i++)\r\nif (elem->cached & (1 << i))\r\nsnd_usb_set_cur_mix_value(elem, i, i,\r\nelem->cache_val[i]);\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = elem->channels;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = (int)kctl->private_value +\r\nSND_SCARLETT_LEVEL_BIAS;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nint i, err, val;\r\nfor (i = 0; i < elem->channels; i++) {\r\nerr = snd_usb_get_cur_mix_value(elem, i, i, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp(val / 256, -128, (int)kctl->private_value) +\r\nSND_SCARLETT_LEVEL_BIAS;\r\nucontrol->value.integer.value[i] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nint i, changed = 0;\r\nint err, oval, val;\r\nfor (i = 0; i < elem->channels; i++) {\r\nerr = snd_usb_get_cur_mix_value(elem, i, i, &oval);\r\nif (err < 0)\r\nreturn err;\r\nval = ucontrol->value.integer.value[i] -\r\nSND_SCARLETT_LEVEL_BIAS;\r\nval = val * 256;\r\nif (oval != val) {\r\nerr = snd_usb_set_cur_mix_value(elem, i, i, val);\r\nif (err < 0)\r\nreturn err;\r\nchanged = 1;\r\n}\r\n}\r\nreturn changed;\r\n}\r\nstatic void scarlett_generate_name(int i, char *dst, int offsets[])\r\n{\r\nif (i > offsets[SCARLETT_OFFSET_MIX])\r\nsprintf(dst, "Mix %c",\r\n'A'+(i - offsets[SCARLETT_OFFSET_MIX] - 1));\r\nelse if (i > offsets[SCARLETT_OFFSET_ADAT])\r\nsprintf(dst, "ADAT %d", i - offsets[SCARLETT_OFFSET_ADAT]);\r\nelse if (i > offsets[SCARLETT_OFFSET_SPDIF])\r\nsprintf(dst, "SPDIF %d", i - offsets[SCARLETT_OFFSET_SPDIF]);\r\nelse if (i > offsets[SCARLETT_OFFSET_ANALOG])\r\nsprintf(dst, "Analog %d", i - offsets[SCARLETT_OFFSET_ANALOG]);\r\nelse if (i > offsets[SCARLETT_OFFSET_PCM])\r\nsprintf(dst, "PCM %d", i - offsets[SCARLETT_OFFSET_PCM]);\r\nelse\r\nsprintf(dst, "Off");\r\n}\r\nstatic int scarlett_ctl_enum_dynamic_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\r\nunsigned int items = opt->len;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = elem->channels;\r\nuinfo->value.enumerated.items = items;\r\nif (uinfo->value.enumerated.item >= items)\r\nuinfo->value.enumerated.item = items - 1;\r\nscarlett_generate_name(uinfo->value.enumerated.item,\r\nuinfo->value.enumerated.name,\r\nopt->offsets);\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_enum_info(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\r\nreturn snd_ctl_enum_info(uinfo, elem->channels, opt->len,\r\n(const char * const *)opt->names);\r\n}\r\nstatic int scarlett_ctl_enum_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\r\nint err, val;\r\nerr = snd_usb_get_cur_mix_value(elem, 0, 0, &val);\r\nif (err < 0)\r\nreturn err;\r\nval = clamp(val - opt->start, 0, opt->len-1);\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_enum_put(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nstruct scarlett_mixer_elem_enum_info *opt = elem->private_data;\r\nint err, oval, val;\r\nerr = snd_usb_get_cur_mix_value(elem, 0, 0, &oval);\r\nif (err < 0)\r\nreturn err;\r\nval = ucontrol->value.integer.value[0];\r\nval = val + opt->start;\r\nif (val != oval) {\r\nsnd_usb_set_cur_mix_value(elem, 0, 0, val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_enum_resume(struct usb_mixer_elem_list *list)\r\n{\r\nstruct usb_mixer_elem_info *elem =\r\ncontainer_of(list, struct usb_mixer_elem_info, head);\r\nif (elem->cached)\r\nsnd_usb_set_cur_mix_value(elem, 0, 0, *elem->cache_val);\r\nreturn 0;\r\n}\r\nstatic int scarlett_ctl_meter_get(struct snd_kcontrol *kctl,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct usb_mixer_elem_info *elem = kctl->private_data;\r\nstruct snd_usb_audio *chip = elem->head.mixer->chip;\r\nunsigned char buf[2 * MAX_CHANNELS] = {0, };\r\nint wValue = (elem->control << 8) | elem->idx_off;\r\nint idx = snd_usb_ctrl_intf(chip) | (elem->head.id << 8);\r\nint err;\r\nerr = snd_usb_ctl_msg(chip->dev,\r\nusb_rcvctrlpipe(chip->dev, 0),\r\nUAC2_CS_MEM,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS |\r\nUSB_DIR_IN, wValue, idx, buf, elem->channels);\r\nif (err < 0)\r\nreturn err;\r\nucontrol->value.enumerated.item[0] = clamp((int)buf[0], 0, 1);\r\nreturn 0;\r\n}\r\nstatic int add_new_ctl(struct usb_mixer_interface *mixer,\r\nconst struct snd_kcontrol_new *ncontrol,\r\nusb_mixer_elem_resume_func_t resume,\r\nint index, int offset, int num,\r\nint val_type, int channels, const char *name,\r\nconst struct scarlett_mixer_elem_enum_info *opt,\r\nstruct usb_mixer_elem_info **elem_ret\r\n)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nstruct usb_mixer_elem_info *elem;\r\nint err;\r\nelem = kzalloc(sizeof(*elem), GFP_KERNEL);\r\nif (!elem)\r\nreturn -ENOMEM;\r\nelem->head.mixer = mixer;\r\nelem->head.resume = resume;\r\nelem->control = offset;\r\nelem->idx_off = num;\r\nelem->head.id = index;\r\nelem->val_type = val_type;\r\nelem->channels = channels;\r\nelem->private_data = (void *)opt;\r\nkctl = snd_ctl_new1(ncontrol, elem);\r\nif (!kctl) {\r\nkfree(elem);\r\nreturn -ENOMEM;\r\n}\r\nkctl->private_free = snd_usb_mixer_elem_free;\r\nstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\r\nerr = snd_usb_mixer_add_control(&elem->head, kctl);\r\nif (err < 0)\r\nreturn err;\r\nif (elem_ret)\r\n*elem_ret = elem;\r\nreturn 0;\r\n}\r\nstatic int add_output_ctls(struct usb_mixer_interface *mixer,\r\nint index, const char *name,\r\nconst struct scarlett_device_info *info)\r\n{\r\nint err;\r\nchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nstruct usb_mixer_elem_info *elem;\r\nsnprintf(mx, sizeof(mx), "Master %d (%s) Playback Switch",\r\nindex + 1, name);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_switch,\r\nscarlett_ctl_resume, 0x0a, 0x01,\r\n2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(mx, sizeof(mx), "Master %d (%s) Playback Volume",\r\nindex + 1, name);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_master,\r\nscarlett_ctl_resume, 0x0a, 0x02,\r\n2*index+1, USB_MIXER_S16, 2, mx, NULL, &elem);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(mx, sizeof(mx), "Master %dL (%s) Source Playback Enum",\r\nindex + 1, name);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\r\nscarlett_ctl_enum_resume, 0x33, 0x00,\r\n2*index, USB_MIXER_S16, 1, mx, &info->opt_master,\r\n&elem);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(mx, sizeof(mx), "Master %dR (%s) Source Playback Enum",\r\nindex + 1, name);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\r\nscarlett_ctl_enum_resume, 0x33, 0x00,\r\n2*index+1, USB_MIXER_S16, 1, mx, &info->opt_master,\r\n&elem);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int scarlett_controls_create_generic(struct usb_mixer_interface *mixer,\r\nstruct scarlett_device_info *info)\r\n{\r\nint i, err;\r\nchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nconst struct scarlett_mixer_control *ctl;\r\nstruct usb_mixer_elem_info *elem;\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_switch,\r\nscarlett_ctl_resume, 0x0a, 0x01, 0,\r\nUSB_MIXER_S16, 1, "Master Playback Switch", NULL,\r\n&elem);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_master,\r\nscarlett_ctl_resume, 0x0a, 0x02, 0,\r\nUSB_MIXER_S16, 1, "Master Playback Volume", NULL,\r\n&elem);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < info->num_controls; i++) {\r\nctl = &info->controls[i];\r\nswitch (ctl->type) {\r\ncase SCARLETT_OUTPUTS:\r\nerr = add_output_ctls(mixer, ctl->num, ctl->name, info);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SCARLETT_SWITCH_IMPEDANCE:\r\nsprintf(mx, "Input %d Impedance Switch", ctl->num);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\r\nscarlett_ctl_enum_resume, 0x01,\r\n0x09, ctl->num, USB_MIXER_S16, 1, mx,\r\n&opt_impedance, &elem);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase SCARLETT_SWITCH_PAD:\r\nsprintf(mx, "Input %d Pad Switch", ctl->num);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\r\nscarlett_ctl_enum_resume, 0x01,\r\n0x0b, ctl->num, USB_MIXER_S16, 1, mx,\r\n&opt_pad, &elem);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_scarlett_controls_create(struct usb_mixer_interface *mixer)\r\n{\r\nint err, i, o;\r\nchar mx[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nstruct scarlett_device_info *info;\r\nstruct usb_mixer_elem_info *elem;\r\nstatic char sample_rate_buffer[4] = { '\x80', '\xbb', '\x00', '\x00' };\r\nif (!mixer->protocol)\r\nreturn 0;\r\nswitch (mixer->chip->usb_id) {\r\ncase USB_ID(0x1235, 0x8012):\r\ninfo = &s6i6_info;\r\nbreak;\r\ncase USB_ID(0x1235, 0x8002):\r\ninfo = &s8i6_info;\r\nbreak;\r\ncase USB_ID(0x1235, 0x8004):\r\ninfo = &s18i6_info;\r\nbreak;\r\ncase USB_ID(0x1235, 0x8014):\r\ninfo = &s18i8_info;\r\nbreak;\r\ncase USB_ID(0x1235, 0x800c):\r\ninfo = &s18i20_info;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = scarlett_controls_create_generic(mixer, info);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < info->matrix_in; i++) {\r\nsnprintf(mx, sizeof(mx), "Matrix %02d Input Playback Route",\r\ni+1);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\r\nscarlett_ctl_enum_resume, 0x32,\r\n0x06, i, USB_MIXER_S16, 1, mx,\r\n&info->opt_matrix, &elem);\r\nif (err < 0)\r\nreturn err;\r\nfor (o = 0; o < info->matrix_out; o++) {\r\nsprintf(mx, "Matrix %02d Mix %c Playback Volume", i+1,\r\no+'A');\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl,\r\nscarlett_ctl_resume, 0x3c, 0x00,\r\n(i << 3) + (o & 0x07), USB_MIXER_S16,\r\n1, mx, NULL, &elem);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < info->input_len; i++) {\r\nsnprintf(mx, sizeof(mx), "Input Source %02d Capture Route",\r\ni+1);\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_dynamic_enum,\r\nscarlett_ctl_enum_resume, 0x34,\r\n0x00, i, USB_MIXER_S16, 1, mx,\r\n&info->opt_master, &elem);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_enum,\r\nscarlett_ctl_enum_resume, 0x28, 0x01, 0,\r\nUSB_MIXER_U8, 1, "Sample Clock Source",\r\n&opt_clock, &elem);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_new_ctl(mixer, &usb_scarlett_ctl_sync, NULL, 0x3c, 0x00, 2,\r\nUSB_MIXER_U8, 1, "Sample Clock Sync Status",\r\n&opt_sync, &elem);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_usb_ctl_msg(mixer->chip->dev,\r\nusb_sndctrlpipe(mixer->chip->dev, 0), UAC2_CS_CUR,\r\nUSB_RECIP_INTERFACE | USB_TYPE_CLASS |\r\nUSB_DIR_OUT, 0x0100, snd_usb_ctrl_intf(mixer->chip) |\r\n(0x29 << 8), sample_rate_buffer, 4);\r\nif (err < 0)\r\nreturn err;\r\nreturn err;\r\n}
