bool elf__needs_adjust_symbols(GElf_Ehdr ehdr)\r\n{\r\nreturn ehdr.e_type == ET_EXEC ||\r\nehdr.e_type == ET_REL ||\r\nehdr.e_type == ET_DYN;\r\n}\r\nint arch__choose_best_symbol(struct symbol *syma,\r\nstruct symbol *symb __maybe_unused)\r\n{\r\nchar *sym = syma->name;\r\nif (*sym == '.')\r\nsym++;\r\nif (strlen(sym) >= 3 && !strncmp(sym, "SyS", 3))\r\nreturn SYMBOL_B;\r\nif (strlen(sym) >= 10 && !strncmp(sym, "compat_SyS", 10))\r\nreturn SYMBOL_B;\r\nreturn SYMBOL_A;\r\n}\r\nint arch__compare_symbol_names(const char *namea, const char *nameb)\r\n{\r\nif (*namea == '.')\r\nnamea++;\r\nif (*nameb == '.')\r\nnameb++;\r\nreturn strcmp(namea, nameb);\r\n}\r\nvoid arch__sym_update(struct symbol *s, GElf_Sym *sym)\r\n{\r\ns->arch_sym = sym->st_other;\r\n}\r\nvoid arch__fix_tev_from_maps(struct perf_probe_event *pev,\r\nstruct probe_trace_event *tev, struct map *map,\r\nstruct symbol *sym)\r\n{\r\nint lep_offset;\r\nif (pev->point.offset || (!pev->uprobes && pev->point.retprobe) ||\r\n!map || !sym)\r\nreturn;\r\nlep_offset = PPC64_LOCAL_ENTRY_OFFSET(sym->arch_sym);\r\nif (map->dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS)\r\ntev->point.offset += PPC64LE_LEP_OFFSET;\r\nelse if (lep_offset) {\r\nif (pev->uprobes)\r\ntev->point.address += lep_offset;\r\nelse\r\ntev->point.offset += lep_offset;\r\n}\r\n}\r\nvoid arch__post_process_probe_trace_events(struct perf_probe_event *pev,\r\nint ntevs)\r\n{\r\nstruct probe_trace_event *tev;\r\nstruct map *map;\r\nstruct symbol *sym = NULL;\r\nstruct rb_node *tmp;\r\nint i = 0;\r\nmap = get_target_map(pev->target, pev->uprobes);\r\nif (!map || map__load(map) < 0)\r\nreturn;\r\nfor (i = 0; i < ntevs; i++) {\r\ntev = &pev->tevs[i];\r\nmap__for_each_symbol(map, sym, tmp) {\r\nif (map->unmap_ip(map, sym->start) == tev->point.address)\r\narch__fix_tev_from_maps(pev, tev, map, sym);\r\n}\r\n}\r\n}
