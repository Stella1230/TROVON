static inline void miphy28lp_set_reset(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nwriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\r\nval = RST_APPLI_SW | RST_CONF_SW;\r\nwriteb_relaxed(val, base + MIPHY_CONF_RESET);\r\nwriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\r\nif (miphy_phy->type == PHY_TYPE_PCIE) {\r\nval = AUTO_RST_RX | TERM_EN_SW;\r\nwriteb_relaxed(val, base + MIPHY_CONTROL);\r\n} else {\r\nval = AUTO_RST_RX | TERM_EN_SW | DIS_LINK_RST;\r\nwriteb_relaxed(val, base + MIPHY_CONTROL);\r\n}\r\n}\r\nstatic inline void miphy28lp_pll_calibration(struct miphy28lp_phy *miphy_phy,\r\nstruct pll_ratio *pll_ratio)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nwriteb_relaxed(0x1d, base + MIPHY_PLL_SPAREIN);\r\nwriteb_relaxed(pll_ratio->clk_ref, base + MIPHY_PLL_CLKREF_FREQ);\r\nwriteb_relaxed(pll_ratio->calset_1, base + MIPHY_PLL_CALSET_1);\r\nwriteb_relaxed(pll_ratio->calset_2, base + MIPHY_PLL_CALSET_2);\r\nwriteb_relaxed(pll_ratio->calset_3, base + MIPHY_PLL_CALSET_3);\r\nwriteb_relaxed(pll_ratio->calset_4, base + MIPHY_PLL_CALSET_4);\r\nwriteb_relaxed(pll_ratio->cal_ctrl, base + MIPHY_PLL_CALSET_CTRL);\r\nwriteb_relaxed(TX_SEL, base + MIPHY_BOUNDARY_SEL);\r\nval = (0x68 << 1) | TX_SLEW_CAL_MAN_EN;\r\nwriteb_relaxed(val, base + MIPHY_TX_CAL_MAN);\r\nval = VGA_OFFSET_POLARITY | CAL_OFFSET_THRESHOLD_64 | CAL_OFFSET_VGA_64;\r\nif (miphy_phy->type != PHY_TYPE_SATA)\r\nval |= OFFSET_COMPENSATION_EN;\r\nwriteb_relaxed(val, base + MIPHY_RX_CAL_OFFSET_CTRL);\r\nif (miphy_phy->type == PHY_TYPE_USB3) {\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\nwriteb_relaxed(0x70, base + MIPHY_RX_LOCK_STEP);\r\nwriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_SLEEP_OA);\r\nwriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_SLEEP_SEL);\r\nwriteb_relaxed(EN_FIRST_HALF, base + MIPHY_RX_SIGDET_WAIT_SEL);\r\nval = EN_DIGIT_SIGNAL_CHECK | EN_FIRST_HALF;\r\nwriteb_relaxed(val, base + MIPHY_RX_SIGDET_DATA_SEL);\r\n}\r\n}\r\nstatic inline void miphy28lp_sata_config_gen(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sata_pll_gen); i++) {\r\nstruct miphy28lp_pll_gen *gen = &sata_pll_gen[i];\r\nwriteb_relaxed(gen->bank, base + MIPHY_CONF);\r\nwriteb_relaxed(gen->speed, base + MIPHY_SPEED);\r\nwriteb_relaxed(gen->bias_boost_1, base + MIPHY_BIAS_BOOST_1);\r\nwriteb_relaxed(gen->bias_boost_2, base + MIPHY_BIAS_BOOST_2);\r\nwriteb_relaxed(gen->tx_ctrl_2, base + MIPHY_TX_CTRL_2);\r\nwriteb_relaxed(gen->tx_ctrl_3, base + MIPHY_TX_CTRL_3);\r\nwriteb_relaxed(gen->rx_buff_ctrl, base + MIPHY_RX_BUFFER_CTRL);\r\nwriteb_relaxed(gen->rx_vga_gain, base + MIPHY_RX_VGA_GAIN);\r\nwriteb_relaxed(gen->rx_equ_gain_1, base + MIPHY_RX_EQU_GAIN_1);\r\nwriteb_relaxed(gen->rx_equ_gain_2, base + MIPHY_RX_EQU_GAIN_2);\r\nwriteb_relaxed(gen->rx_equ_gain_3, base + MIPHY_RX_EQU_GAIN_3);\r\n}\r\n}\r\nstatic inline void miphy28lp_pcie_config_gen(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pcie_pll_gen); i++) {\r\nstruct miphy28lp_pll_gen *gen = &pcie_pll_gen[i];\r\nwriteb_relaxed(gen->bank, base + MIPHY_CONF);\r\nwriteb_relaxed(gen->speed, base + MIPHY_SPEED);\r\nwriteb_relaxed(gen->bias_boost_1, base + MIPHY_BIAS_BOOST_1);\r\nwriteb_relaxed(gen->bias_boost_2, base + MIPHY_BIAS_BOOST_2);\r\nwriteb_relaxed(gen->tx_ctrl_1, base + MIPHY_TX_CTRL_1);\r\nwriteb_relaxed(gen->tx_ctrl_2, base + MIPHY_TX_CTRL_2);\r\nwriteb_relaxed(gen->tx_ctrl_3, base + MIPHY_TX_CTRL_3);\r\nwriteb_relaxed(gen->rx_k_gain, base + MIPHY_RX_K_GAIN);\r\nwriteb_relaxed(gen->rx_buff_ctrl, base + MIPHY_RX_BUFFER_CTRL);\r\nwriteb_relaxed(gen->rx_vga_gain, base + MIPHY_RX_VGA_GAIN);\r\nwriteb_relaxed(gen->rx_equ_gain_1, base + MIPHY_RX_EQU_GAIN_1);\r\nwriteb_relaxed(gen->rx_equ_gain_2, base + MIPHY_RX_EQU_GAIN_2);\r\n}\r\n}\r\nstatic inline int miphy28lp_wait_compensation(struct miphy28lp_phy *miphy_phy)\r\n{\r\nunsigned long finish = jiffies + 5 * HZ;\r\nu8 val;\r\ndo {\r\nval = readb_relaxed(miphy_phy->base + MIPHY_COMP_FSM_6);\r\nif (time_after_eq(jiffies, finish))\r\nreturn -EBUSY;\r\ncpu_relax();\r\n} while (!(val & COMP_DONE));\r\nreturn 0;\r\n}\r\nstatic inline int miphy28lp_compensation(struct miphy28lp_phy *miphy_phy,\r\nstruct pll_ratio *pll_ratio)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nwriteb_relaxed(RST_PLL_SW | RST_COMP_SW, base + MIPHY_RESET);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_COMMON_MISC_2);\r\nwriteb_relaxed(pll_ratio->clk_ref, base + MIPHY_PLL_CLKREF_FREQ);\r\nwriteb_relaxed(COMP_START, base + MIPHY_COMP_FSM_1);\r\nif (miphy_phy->type == PHY_TYPE_PCIE)\r\nwriteb_relaxed(RST_PLL_SW, base + MIPHY_RESET);\r\nwriteb_relaxed(0x00, base + MIPHY_RESET);\r\nwriteb_relaxed(START_ACT_FILT, base + MIPHY_PLL_COMMON_MISC_2);\r\nwriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0x00, base + MIPHY_COMP_POSTP);\r\nif (miphy_phy->type == PHY_TYPE_PCIE)\r\nreturn miphy28lp_wait_compensation(miphy_phy);\r\nreturn 0;\r\n}\r\nstatic inline void miphy28_usb3_miphy_reset(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nwriteb_relaxed(RST_APPLI_SW, base + MIPHY_CONF_RESET);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\r\nwriteb_relaxed(RST_COMP_SW, base + MIPHY_RESET);\r\nval = RST_COMP_SW | RST_PLL_SW;\r\nwriteb_relaxed(val, base + MIPHY_RESET);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_COMMON_MISC_2);\r\nwriteb_relaxed(0x1e, base + MIPHY_PLL_CLKREF_FREQ);\r\nwriteb_relaxed(COMP_START, base + MIPHY_COMP_FSM_1);\r\nwriteb_relaxed(RST_PLL_SW, base + MIPHY_RESET);\r\nwriteb_relaxed(0x00, base + MIPHY_RESET);\r\nwriteb_relaxed(START_ACT_FILT, base + MIPHY_PLL_COMMON_MISC_2);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\nwriteb_relaxed(0x00, base + MIPHY_BOUNDARY_1);\r\nwriteb_relaxed(0x00, base + MIPHY_TST_BIAS_BOOST_2);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\nwriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0xa5, base + MIPHY_DEBUG_BUS);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\n}\r\nstatic void miphy_sata_tune_ssc(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nval = readb_relaxed(base + MIPHY_BOUNDARY_2);\r\nval |= SSC_EN_SW;\r\nwriteb_relaxed(val, base + MIPHY_BOUNDARY_2);\r\nval = readb_relaxed(base + MIPHY_BOUNDARY_SEL);\r\nval |= SSC_SEL;\r\nwriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\r\nfor (val = 0; val < MIPHY_SATA_BANK_NB; val++) {\r\nwriteb_relaxed(val, base + MIPHY_CONF);\r\nwriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\r\nwriteb_relaxed(0x6c, base + MIPHY_PLL_SBR_3);\r\nwriteb_relaxed(0x81, base + MIPHY_PLL_SBR_4);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\n}\r\n}\r\nstatic void miphy_pcie_tune_ssc(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nval = readb_relaxed(base + MIPHY_BOUNDARY_2);\r\nval |= SSC_EN_SW;\r\nwriteb_relaxed(val, base + MIPHY_BOUNDARY_2);\r\nval = readb_relaxed(base + MIPHY_BOUNDARY_SEL);\r\nval |= SSC_SEL;\r\nwriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\r\nfor (val = 0; val < MIPHY_PCIE_BANK_NB; val++) {\r\nwriteb_relaxed(val, base + MIPHY_CONF);\r\nwriteb_relaxed(0x69, base + MIPHY_PLL_SBR_3);\r\nwriteb_relaxed(0x21, base + MIPHY_PLL_SBR_4);\r\nwriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\r\nwriteb_relaxed(0x21, base + MIPHY_PLL_SBR_4);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(SET_NEW_CHANGE, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\n}\r\n}\r\nstatic inline void miphy_tune_tx_impedance(struct miphy28lp_phy *miphy_phy)\r\n{\r\nwriteb_relaxed(0x02, miphy_phy->base + MIPHY_COMP_POSTP);\r\n}\r\nstatic inline int miphy28lp_configure_sata(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nint err;\r\nu8 val;\r\nmiphy28lp_set_reset(miphy_phy);\r\nmiphy28lp_pll_calibration(miphy_phy, &sata_pll_ratio);\r\nmiphy28lp_sata_config_gen(miphy_phy);\r\nwriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\r\nerr = miphy28lp_compensation(miphy_phy, &sata_pll_ratio);\r\nif (err)\r\nreturn err;\r\nif (miphy_phy->px_rx_pol_inv) {\r\nval = readb_relaxed(miphy_phy->base + MIPHY_CONTROL);\r\nval |= PX_RX_POL;\r\nwriteb_relaxed(val, miphy_phy->base + MIPHY_CONTROL);\r\n}\r\nif (miphy_phy->ssc)\r\nmiphy_sata_tune_ssc(miphy_phy);\r\nif (miphy_phy->tx_impedance)\r\nmiphy_tune_tx_impedance(miphy_phy);\r\nreturn 0;\r\n}\r\nstatic inline int miphy28lp_configure_pcie(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nint err;\r\nmiphy28lp_set_reset(miphy_phy);\r\nmiphy28lp_pll_calibration(miphy_phy, &pcie_pll_ratio);\r\nmiphy28lp_pcie_config_gen(miphy_phy);\r\nwriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF_RESET);\r\nerr = miphy28lp_compensation(miphy_phy, &pcie_pll_ratio);\r\nif (err)\r\nreturn err;\r\nif (miphy_phy->ssc)\r\nmiphy_pcie_tune_ssc(miphy_phy);\r\nif (miphy_phy->tx_impedance)\r\nmiphy_tune_tx_impedance(miphy_phy);\r\nreturn 0;\r\n}\r\nstatic inline void miphy28lp_configure_usb3(struct miphy28lp_phy *miphy_phy)\r\n{\r\nvoid __iomem *base = miphy_phy->base;\r\nu8 val;\r\nmiphy28lp_set_reset(miphy_phy);\r\nmiphy28lp_pll_calibration(miphy_phy, &usb3_pll_ratio);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\nval = RX_SPDSEL_20DEC | TX_SPDSEL_20DEC;\r\nwriteb_relaxed(val, base + MIPHY_SPEED);\r\nwriteb_relaxed(0x1c, base + MIPHY_RX_LOCK_SETTINGS_OPT);\r\nwriteb_relaxed(0x51, base + MIPHY_RX_CAL_CTRL_1);\r\nwriteb_relaxed(0x70, base + MIPHY_RX_CAL_CTRL_2);\r\nval = OFFSET_COMPENSATION_EN | VGA_OFFSET_POLARITY |\r\nCAL_OFFSET_THRESHOLD_64 | CAL_OFFSET_VGA_64;\r\nwriteb_relaxed(val, base + MIPHY_RX_CAL_OFFSET_CTRL);\r\nwriteb_relaxed(0x22, base + MIPHY_RX_CAL_VGA_STEP);\r\nwriteb_relaxed(0x0e, base + MIPHY_RX_CAL_OPT_LENGTH);\r\nval = EQ_DC_GAIN | VGA_GAIN;\r\nwriteb_relaxed(val, base + MIPHY_RX_BUFFER_CTRL);\r\nwriteb_relaxed(0x78, base + MIPHY_RX_EQU_GAIN_1);\r\nwriteb_relaxed(0x1b, base + MIPHY_SYNCHAR_CONTROL);\r\nwriteb_relaxed(0x02, base + MIPHY_COMP_POSTP);\r\nval = SSC_SEL | GENSEL_SEL;\r\nwriteb_relaxed(val, base + MIPHY_BOUNDARY_SEL);\r\nwriteb_relaxed(0x00, base + MIPHY_BIAS_BOOST_1);\r\nwriteb_relaxed(0xa7, base + MIPHY_BIAS_BOOST_2);\r\nwriteb_relaxed(SSC_EN_SW, base + MIPHY_BOUNDARY_2);\r\nwriteb_relaxed(0x00, base + MIPHY_CONF);\r\nwriteb_relaxed(0x5a, base + MIPHY_PLL_SBR_3);\r\nwriteb_relaxed(0xa0, base + MIPHY_PLL_SBR_4);\r\nwriteb_relaxed(0x3c, base + MIPHY_PLL_SBR_2);\r\nwriteb_relaxed(0xa1, base + MIPHY_PLL_SBR_4);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0x02, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0x00, base + MIPHY_PLL_SBR_1);\r\nwriteb_relaxed(0xca, base + MIPHY_RX_K_GAIN);\r\nwriteb_relaxed(0x21, base + MIPHY_RX_POWER_CTRL_1);\r\nwriteb_relaxed(0x29, base + MIPHY_RX_POWER_CTRL_1);\r\nwriteb_relaxed(0x1a, base + MIPHY_RX_POWER_CTRL_2);\r\nmiphy28_usb3_miphy_reset(miphy_phy);\r\n}\r\nstatic inline int miphy_is_ready(struct miphy28lp_phy *miphy_phy)\r\n{\r\nunsigned long finish = jiffies + 5 * HZ;\r\nu8 mask = HFC_PLL | HFC_RDY;\r\nu8 val;\r\nif (miphy_phy->type == PHY_TYPE_SATA)\r\nmask |= PHY_RDY;\r\ndo {\r\nval = readb_relaxed(miphy_phy->base + MIPHY_STATUS_1);\r\nif ((val & mask) != mask)\r\ncpu_relax();\r\nelse\r\nreturn 0;\r\n} while (!time_after_eq(jiffies, finish));\r\nreturn -EBUSY;\r\n}\r\nstatic int miphy_osc_is_ready(struct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nunsigned long finish = jiffies + 5 * HZ;\r\nu32 val;\r\nif (!miphy_phy->osc_rdy)\r\nreturn 0;\r\nif (!miphy_phy->syscfg_reg[SYSCFG_STATUS])\r\nreturn -EINVAL;\r\ndo {\r\nregmap_read(miphy_dev->regmap,\r\nmiphy_phy->syscfg_reg[SYSCFG_STATUS], &val);\r\nif ((val & MIPHY_OSC_RDY) != MIPHY_OSC_RDY)\r\ncpu_relax();\r\nelse\r\nreturn 0;\r\n} while (!time_after_eq(jiffies, finish));\r\nreturn -EBUSY;\r\n}\r\nstatic int miphy28lp_get_resource_byname(struct device_node *child,\r\nchar *rname, struct resource *res)\r\n{\r\nint index;\r\nindex = of_property_match_string(child, "reg-names", rname);\r\nif (index < 0)\r\nreturn -ENODEV;\r\nreturn of_address_to_resource(child, index, res);\r\n}\r\nstatic int miphy28lp_get_one_addr(struct device *dev,\r\nstruct device_node *child, char *rname,\r\nvoid __iomem **base)\r\n{\r\nstruct resource res;\r\nint ret;\r\nret = miphy28lp_get_resource_byname(child, rname, &res);\r\nif (!ret) {\r\n*base = devm_ioremap(dev, res.start, resource_size(&res));\r\nif (!*base) {\r\ndev_err(dev, "failed to ioremap %s address region\n"\r\n, rname);\r\nreturn -ENOENT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int miphy28lp_setup(struct miphy28lp_phy *miphy_phy, u32 miphy_val)\r\n{\r\nint err;\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nif (!miphy_phy->syscfg_reg[SYSCFG_CTRL])\r\nreturn -EINVAL;\r\nerr = reset_control_assert(miphy_phy->miphy_rst);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "unable to bring out of miphy reset\n");\r\nreturn err;\r\n}\r\nif (miphy_phy->osc_force_ext)\r\nmiphy_val |= MIPHY_OSC_FORCE_EXT;\r\nregmap_update_bits(miphy_dev->regmap,\r\nmiphy_phy->syscfg_reg[SYSCFG_CTRL],\r\nMIPHY_CTRL_MASK, miphy_val);\r\nerr = reset_control_deassert(miphy_phy->miphy_rst);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "unable to bring out of miphy reset\n");\r\nreturn err;\r\n}\r\nreturn miphy_osc_is_ready(miphy_phy);\r\n}\r\nstatic int miphy28lp_init_sata(struct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nint err, sata_conf = SATA_CTRL_SELECT_SATA;\r\nif ((!miphy_phy->syscfg_reg[SYSCFG_SATA]) ||\r\n(!miphy_phy->syscfg_reg[SYSCFG_PCI]) ||\r\n(!miphy_phy->base))\r\nreturn -EINVAL;\r\ndev_info(miphy_dev->dev, "sata-up mode, addr 0x%p\n", miphy_phy->base);\r\nsata_conf |= ((miphy_phy->sata_gen - SATA_GEN1) << SATA_SPDMODE);\r\nregmap_update_bits(miphy_dev->regmap,\r\nmiphy_phy->syscfg_reg[SYSCFG_SATA],\r\nSATA_CTRL_MASK, sata_conf);\r\nregmap_update_bits(miphy_dev->regmap, miphy_phy->syscfg_reg[SYSCFG_PCI],\r\nPCIE_CTRL_MASK, SATA_CTRL_SELECT_PCIE);\r\nerr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_DEFAULT);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "SATA phy setup failed\n");\r\nreturn err;\r\n}\r\nmiphy28lp_configure_sata(miphy_phy);\r\nreturn miphy_is_ready(miphy_phy);\r\n}\r\nstatic int miphy28lp_init_pcie(struct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nint err;\r\nif ((!miphy_phy->syscfg_reg[SYSCFG_SATA]) ||\r\n(!miphy_phy->syscfg_reg[SYSCFG_PCI])\r\n|| (!miphy_phy->base) || (!miphy_phy->pipebase))\r\nreturn -EINVAL;\r\ndev_info(miphy_dev->dev, "pcie-up mode, addr 0x%p\n", miphy_phy->base);\r\nregmap_update_bits(miphy_dev->regmap,\r\nmiphy_phy->syscfg_reg[SYSCFG_SATA],\r\nSATA_CTRL_MASK, SATA_CTRL_SELECT_PCIE);\r\nregmap_update_bits(miphy_dev->regmap, miphy_phy->syscfg_reg[SYSCFG_PCI],\r\nPCIE_CTRL_MASK, SYSCFG_PCIE_PCIE_VAL);\r\nerr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_DEFAULT);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "PCIe phy setup failed\n");\r\nreturn err;\r\n}\r\nerr = miphy28lp_configure_pcie(miphy_phy);\r\nif (err)\r\nreturn err;\r\nwriteb_relaxed(0x68, miphy_phy->pipebase + 0x104);\r\nwriteb_relaxed(0x61, miphy_phy->pipebase + 0x105);\r\nwriteb_relaxed(0x68, miphy_phy->pipebase + 0x108);\r\nwriteb_relaxed(0x61, miphy_phy->pipebase + 0x109);\r\nwriteb_relaxed(0x68, miphy_phy->pipebase + 0x10c);\r\nwriteb_relaxed(0x60, miphy_phy->pipebase + 0x10d);\r\nreturn miphy_is_ready(miphy_phy);\r\n}\r\nstatic int miphy28lp_init_usb3(struct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nint err;\r\nif ((!miphy_phy->base) || (!miphy_phy->pipebase))\r\nreturn -EINVAL;\r\ndev_info(miphy_dev->dev, "usb3-up mode, addr 0x%p\n", miphy_phy->base);\r\nerr = miphy28lp_setup(miphy_phy, MIPHY_CTRL_SYNC_D_EN);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "USB3 phy setup failed\n");\r\nreturn err;\r\n}\r\nmiphy28lp_configure_usb3(miphy_phy);\r\nwriteb_relaxed(0x68, miphy_phy->pipebase + 0x23);\r\nwriteb_relaxed(0x61, miphy_phy->pipebase + 0x24);\r\nwriteb_relaxed(0x68, miphy_phy->pipebase + 0x26);\r\nwriteb_relaxed(0x61, miphy_phy->pipebase + 0x27);\r\nwriteb_relaxed(0x18, miphy_phy->pipebase + 0x29);\r\nwriteb_relaxed(0x61, miphy_phy->pipebase + 0x2a);\r\nwriteb_relaxed(0X67, miphy_phy->pipebase + 0x68);\r\nwriteb_relaxed(0x0d, miphy_phy->pipebase + 0x69);\r\nwriteb_relaxed(0X67, miphy_phy->pipebase + 0x6a);\r\nwriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6b);\r\nwriteb_relaxed(0X67, miphy_phy->pipebase + 0x6c);\r\nwriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6d);\r\nwriteb_relaxed(0X67, miphy_phy->pipebase + 0x6e);\r\nwriteb_relaxed(0X0d, miphy_phy->pipebase + 0x6f);\r\nreturn miphy_is_ready(miphy_phy);\r\n}\r\nstatic int miphy28lp_init(struct phy *phy)\r\n{\r\nstruct miphy28lp_phy *miphy_phy = phy_get_drvdata(phy);\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nint ret;\r\nmutex_lock(&miphy_dev->miphy_mutex);\r\nswitch (miphy_phy->type) {\r\ncase PHY_TYPE_SATA:\r\nret = miphy28lp_init_sata(miphy_phy);\r\nbreak;\r\ncase PHY_TYPE_PCIE:\r\nret = miphy28lp_init_pcie(miphy_phy);\r\nbreak;\r\ncase PHY_TYPE_USB3:\r\nret = miphy28lp_init_usb3(miphy_phy);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&miphy_dev->miphy_mutex);\r\nreturn ret;\r\n}\r\nstatic int miphy28lp_get_addr(struct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nstruct device_node *phynode = miphy_phy->phy->dev.of_node;\r\nint err;\r\nif ((miphy_phy->type != PHY_TYPE_SATA) &&\r\n(miphy_phy->type != PHY_TYPE_PCIE) &&\r\n(miphy_phy->type != PHY_TYPE_USB3)) {\r\nreturn -EINVAL;\r\n}\r\nerr = miphy28lp_get_one_addr(miphy_dev->dev, phynode,\r\nPHY_TYPE_name[miphy_phy->type - PHY_TYPE_SATA],\r\n&miphy_phy->base);\r\nif (err)\r\nreturn err;\r\nif ((miphy_phy->type == PHY_TYPE_PCIE) ||\r\n(miphy_phy->type == PHY_TYPE_USB3)) {\r\nerr = miphy28lp_get_one_addr(miphy_dev->dev, phynode, "pipew",\r\n&miphy_phy->pipebase);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct phy *miphy28lp_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = dev_get_drvdata(dev);\r\nstruct miphy28lp_phy *miphy_phy = NULL;\r\nstruct device_node *phynode = args->np;\r\nint ret, index = 0;\r\nif (args->args_count != 1) {\r\ndev_err(dev, "Invalid number of cells in 'phy' property\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfor (index = 0; index < miphy_dev->nphys; index++)\r\nif (phynode == miphy_dev->phys[index]->phy->dev.of_node) {\r\nmiphy_phy = miphy_dev->phys[index];\r\nbreak;\r\n}\r\nif (!miphy_phy) {\r\ndev_err(dev, "Failed to find appropriate phy\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmiphy_phy->type = args->args[0];\r\nret = miphy28lp_get_addr(miphy_phy);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nreturn miphy_phy->phy;\r\n}\r\nstatic int miphy28lp_probe_resets(struct device_node *node,\r\nstruct miphy28lp_phy *miphy_phy)\r\n{\r\nstruct miphy28lp_dev *miphy_dev = miphy_phy->phydev;\r\nint err;\r\nmiphy_phy->miphy_rst =\r\nof_reset_control_get_shared(node, "miphy-sw-rst");\r\nif (IS_ERR(miphy_phy->miphy_rst)) {\r\ndev_err(miphy_dev->dev,\r\n"miphy soft reset control not defined\n");\r\nreturn PTR_ERR(miphy_phy->miphy_rst);\r\n}\r\nerr = reset_control_deassert(miphy_phy->miphy_rst);\r\nif (err) {\r\ndev_err(miphy_dev->dev, "unable to bring out of miphy reset\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int miphy28lp_of_probe(struct device_node *np,\r\nstruct miphy28lp_phy *miphy_phy)\r\n{\r\nint i;\r\nu32 ctrlreg;\r\nmiphy_phy->osc_force_ext =\r\nof_property_read_bool(np, "st,osc-force-ext");\r\nmiphy_phy->osc_rdy = of_property_read_bool(np, "st,osc-rdy");\r\nmiphy_phy->px_rx_pol_inv =\r\nof_property_read_bool(np, "st,px_rx_pol_inv");\r\nmiphy_phy->ssc = of_property_read_bool(np, "st,ssc-on");\r\nmiphy_phy->tx_impedance =\r\nof_property_read_bool(np, "st,tx-impedance-comp");\r\nof_property_read_u32(np, "st,sata-gen", &miphy_phy->sata_gen);\r\nif (!miphy_phy->sata_gen)\r\nmiphy_phy->sata_gen = SATA_GEN1;\r\nfor (i = 0; i < SYSCFG_REG_MAX; i++) {\r\nif (!of_property_read_u32_index(np, "st,syscfg", i, &ctrlreg))\r\nmiphy_phy->syscfg_reg[i] = ctrlreg;\r\n}\r\nreturn 0;\r\n}\r\nstatic int miphy28lp_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *child, *np = pdev->dev.of_node;\r\nstruct miphy28lp_dev *miphy_dev;\r\nstruct phy_provider *provider;\r\nstruct phy *phy;\r\nint ret, port = 0;\r\nmiphy_dev = devm_kzalloc(&pdev->dev, sizeof(*miphy_dev), GFP_KERNEL);\r\nif (!miphy_dev)\r\nreturn -ENOMEM;\r\nmiphy_dev->nphys = of_get_child_count(np);\r\nmiphy_dev->phys = devm_kcalloc(&pdev->dev, miphy_dev->nphys,\r\nsizeof(*miphy_dev->phys), GFP_KERNEL);\r\nif (!miphy_dev->phys)\r\nreturn -ENOMEM;\r\nmiphy_dev->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(miphy_dev->regmap)) {\r\ndev_err(miphy_dev->dev, "No syscfg phandle specified\n");\r\nreturn PTR_ERR(miphy_dev->regmap);\r\n}\r\nmiphy_dev->dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, miphy_dev);\r\nmutex_init(&miphy_dev->miphy_mutex);\r\nfor_each_child_of_node(np, child) {\r\nstruct miphy28lp_phy *miphy_phy;\r\nmiphy_phy = devm_kzalloc(&pdev->dev, sizeof(*miphy_phy),\r\nGFP_KERNEL);\r\nif (!miphy_phy) {\r\nret = -ENOMEM;\r\ngoto put_child;\r\n}\r\nmiphy_dev->phys[port] = miphy_phy;\r\nphy = devm_phy_create(&pdev->dev, child, &miphy28lp_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(&pdev->dev, "failed to create PHY\n");\r\nret = PTR_ERR(phy);\r\ngoto put_child;\r\n}\r\nmiphy_dev->phys[port]->phy = phy;\r\nmiphy_dev->phys[port]->phydev = miphy_dev;\r\nret = miphy28lp_of_probe(child, miphy_phy);\r\nif (ret)\r\ngoto put_child;\r\nret = miphy28lp_probe_resets(child, miphy_dev->phys[port]);\r\nif (ret)\r\ngoto put_child;\r\nphy_set_drvdata(phy, miphy_dev->phys[port]);\r\nport++;\r\n}\r\nprovider = devm_of_phy_provider_register(&pdev->dev, miphy28lp_xlate);\r\nreturn PTR_ERR_OR_ZERO(provider);\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
