int octeon_setup_response_list(struct octeon_device *oct)\r\n{\r\nint i, ret = 0;\r\nstruct cavium_wq *cwq;\r\nfor (i = 0; i < MAX_RESPONSE_LISTS; i++) {\r\nINIT_LIST_HEAD(&oct->response_list[i].head);\r\nspin_lock_init(&oct->response_list[i].lock);\r\natomic_set(&oct->response_list[i].pending_req_count, 0);\r\n}\r\nspin_lock_init(&oct->cmd_resp_wqlock);\r\noct->dma_comp_wq.wq = alloc_workqueue("dma-comp", WQ_MEM_RECLAIM, 0);\r\nif (!oct->dma_comp_wq.wq) {\r\ndev_err(&oct->pci_dev->dev, "failed to create wq thread\n");\r\nreturn -ENOMEM;\r\n}\r\ncwq = &oct->dma_comp_wq;\r\nINIT_DELAYED_WORK(&cwq->wk.work, oct_poll_req_completion);\r\ncwq->wk.ctxptr = oct;\r\noct->cmd_resp_state = OCT_DRV_ONLINE;\r\nqueue_delayed_work(cwq->wq, &cwq->wk.work, msecs_to_jiffies(50));\r\nreturn ret;\r\n}\r\nvoid octeon_delete_response_list(struct octeon_device *oct)\r\n{\r\ncancel_delayed_work_sync(&oct->dma_comp_wq.wk.work);\r\ndestroy_workqueue(oct->dma_comp_wq.wq);\r\n}\r\nint lio_process_ordered_list(struct octeon_device *octeon_dev,\r\nu32 force_quit)\r\n{\r\nstruct octeon_response_list *ordered_sc_list;\r\nstruct octeon_soft_command *sc;\r\nint request_complete = 0;\r\nint resp_to_process = MAX_ORD_REQS_TO_PROCESS;\r\nu32 status;\r\nu64 status64;\r\nstruct octeon_instr_rdp *rdp;\r\nu64 rptr;\r\nordered_sc_list = &octeon_dev->response_list[OCTEON_ORDERED_SC_LIST];\r\ndo {\r\nspin_lock_bh(&ordered_sc_list->lock);\r\nif (ordered_sc_list->head.next == &ordered_sc_list->head) {\r\nspin_unlock_bh(&ordered_sc_list->lock);\r\nreturn 1;\r\n}\r\nsc = (struct octeon_soft_command *)ordered_sc_list->\r\nhead.next;\r\nif (OCTEON_CN23XX_PF(octeon_dev) ||\r\nOCTEON_CN23XX_VF(octeon_dev)) {\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.cmd3.rdp;\r\nrptr = sc->cmd.cmd3.rptr;\r\n} else {\r\nrdp = (struct octeon_instr_rdp *)&sc->cmd.cmd2.rdp;\r\nrptr = sc->cmd.cmd2.rptr;\r\n}\r\nstatus = OCTEON_REQUEST_PENDING;\r\ndma_sync_single_for_cpu(&octeon_dev->pci_dev->dev,\r\nrptr, rdp->rlen,\r\nDMA_FROM_DEVICE);\r\nstatus64 = *sc->status_word;\r\nif (status64 != COMPLETION_WORD_INIT) {\r\nif ((status64 & 0xff) != 0xff) {\r\nocteon_swap_8B_data(&status64, 1);\r\nif (((status64 & 0xff) != 0xff)) {\r\nstatus = (u32)(status64 &\r\n0xffffffffULL);\r\n}\r\n}\r\n} else if (force_quit || (sc->timeout &&\r\ntime_after(jiffies, (unsigned long)sc->timeout))) {\r\nstatus = OCTEON_REQUEST_TIMEOUT;\r\n}\r\nif (status != OCTEON_REQUEST_PENDING) {\r\nlist_del(&sc->node);\r\natomic_dec(&octeon_dev->response_list\r\n[OCTEON_ORDERED_SC_LIST].\r\npending_req_count);\r\nspin_unlock_bh\r\n(&ordered_sc_list->lock);\r\nif (sc->callback)\r\nsc->callback(octeon_dev, status,\r\nsc->callback_arg);\r\nrequest_complete++;\r\n} else {\r\nrequest_complete = 0;\r\nspin_unlock_bh\r\n(&ordered_sc_list->lock);\r\n}\r\nif (request_complete >= resp_to_process)\r\nbreak;\r\n} while (request_complete);\r\nreturn 0;\r\n}\r\nstatic void oct_poll_req_completion(struct work_struct *work)\r\n{\r\nstruct cavium_wk *wk = (struct cavium_wk *)work;\r\nstruct octeon_device *oct = (struct octeon_device *)wk->ctxptr;\r\nstruct cavium_wq *cwq = &oct->dma_comp_wq;\r\nlio_process_ordered_list(oct, 0);\r\nqueue_delayed_work(cwq->wq, &cwq->wk.work, msecs_to_jiffies(50));\r\n}
