static int nx_crypto_ctx_sha512_init(struct crypto_tfm *tfm)\r\n{\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(tfm);\r\nint err;\r\nerr = nx_crypto_ctx_sha_init(tfm);\r\nif (err)\r\nreturn err;\r\nnx_ctx_init(nx_ctx, HCOP_FC_SHA);\r\nnx_ctx->ap = &nx_ctx->props[NX_PROPS_SHA512];\r\nNX_CPB_SET_DIGEST_SIZE(nx_ctx->csbcpb, NX_DS_SHA512);\r\nreturn 0;\r\n}\r\nstatic int nx_sha512_init(struct shash_desc *desc)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nmemset(sctx, 0, sizeof *sctx);\r\nsctx->state[0] = __cpu_to_be64(SHA512_H0);\r\nsctx->state[1] = __cpu_to_be64(SHA512_H1);\r\nsctx->state[2] = __cpu_to_be64(SHA512_H2);\r\nsctx->state[3] = __cpu_to_be64(SHA512_H3);\r\nsctx->state[4] = __cpu_to_be64(SHA512_H4);\r\nsctx->state[5] = __cpu_to_be64(SHA512_H5);\r\nsctx->state[6] = __cpu_to_be64(SHA512_H6);\r\nsctx->state[7] = __cpu_to_be64(SHA512_H7);\r\nsctx->count[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int nx_sha512_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx->csbcpb;\r\nstruct nx_sg *out_sg;\r\nu64 to_process, leftover = 0, total;\r\nunsigned long irq_flags;\r\nint rc = 0;\r\nint data_len;\r\nu32 max_sg_len;\r\nu64 buf_len = (sctx->count[0] % SHA512_BLOCK_SIZE);\r\nspin_lock_irqsave(&nx_ctx->lock, irq_flags);\r\ntotal = (sctx->count[0] % SHA512_BLOCK_SIZE) + len;\r\nif (total < SHA512_BLOCK_SIZE) {\r\nmemcpy(sctx->buf + buf_len, data, len);\r\nsctx->count[0] += len;\r\ngoto out;\r\n}\r\nmemcpy(csbcpb->cpb.sha512.message_digest, sctx->state, SHA512_DIGEST_SIZE);\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_INTERMEDIATE;\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\r\nmax_sg_len = min_t(u64, nx_ctx->ap->sglen,\r\nnx_driver.of.max_sg_len/sizeof(struct nx_sg));\r\nmax_sg_len = min_t(u64, max_sg_len,\r\nnx_ctx->ap->databytelen/NX_PAGE_SIZE);\r\ndata_len = SHA512_DIGEST_SIZE;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, (u8 *)sctx->state,\r\n&data_len, max_sg_len);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nif (data_len != SHA512_DIGEST_SIZE) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndo {\r\nint used_sgs = 0;\r\nstruct nx_sg *in_sg = nx_ctx->in_sg;\r\nif (buf_len) {\r\ndata_len = buf_len;\r\nin_sg = nx_build_sg_list(in_sg,\r\n(u8 *) sctx->buf,\r\n&data_len, max_sg_len);\r\nif (data_len != buf_len) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nused_sgs = in_sg - nx_ctx->in_sg;\r\n}\r\nto_process = min_t(u64, total,\r\n(max_sg_len - 1 - used_sgs) * NX_PAGE_SIZE);\r\nto_process = to_process & ~(SHA512_BLOCK_SIZE - 1);\r\ndata_len = to_process - buf_len;\r\nin_sg = nx_build_sg_list(in_sg, (u8 *) data,\r\n&data_len, max_sg_len);\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nif (data_len != (to_process - buf_len)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nto_process = data_len + buf_len;\r\nleftover = total - to_process;\r\nmemcpy(csbcpb->cpb.sha512.input_partial_digest,\r\ncsbcpb->cpb.sha512.message_digest,\r\nSHA512_DIGEST_SIZE);\r\nif (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->sha512_ops));\r\ntotal -= to_process;\r\ndata += to_process - buf_len;\r\nbuf_len = 0;\r\n} while (leftover >= SHA512_BLOCK_SIZE);\r\nif (leftover)\r\nmemcpy(sctx->buf, data, leftover);\r\nsctx->count[0] += len;\r\nmemcpy(sctx->state, csbcpb->cpb.sha512.message_digest, SHA512_DIGEST_SIZE);\r\nout:\r\nspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\r\nreturn rc;\r\n}\r\nstatic int nx_sha512_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nstruct nx_crypto_ctx *nx_ctx = crypto_tfm_ctx(&desc->tfm->base);\r\nstruct nx_csbcpb *csbcpb = (struct nx_csbcpb *)nx_ctx->csbcpb;\r\nstruct nx_sg *in_sg, *out_sg;\r\nu32 max_sg_len;\r\nu64 count0;\r\nunsigned long irq_flags;\r\nint rc = 0;\r\nint len;\r\nspin_lock_irqsave(&nx_ctx->lock, irq_flags);\r\nmax_sg_len = min_t(u64, nx_ctx->ap->sglen,\r\nnx_driver.of.max_sg_len/sizeof(struct nx_sg));\r\nmax_sg_len = min_t(u64, max_sg_len,\r\nnx_ctx->ap->databytelen/NX_PAGE_SIZE);\r\nif (sctx->count[0] >= SHA512_BLOCK_SIZE) {\r\nmemcpy(csbcpb->cpb.sha512.input_partial_digest, sctx->state,\r\nSHA512_DIGEST_SIZE);\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\r\nNX_CPB_FDM(csbcpb) |= NX_FDM_CONTINUATION;\r\n} else {\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_CONTINUATION;\r\n}\r\nNX_CPB_FDM(csbcpb) &= ~NX_FDM_INTERMEDIATE;\r\ncount0 = sctx->count[0] * 8;\r\ncsbcpb->cpb.sha512.message_bit_length_lo = count0;\r\nlen = sctx->count[0] & (SHA512_BLOCK_SIZE - 1);\r\nin_sg = nx_build_sg_list(nx_ctx->in_sg, sctx->buf, &len,\r\nmax_sg_len);\r\nif (len != (sctx->count[0] & (SHA512_BLOCK_SIZE - 1))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlen = SHA512_DIGEST_SIZE;\r\nout_sg = nx_build_sg_list(nx_ctx->out_sg, out, &len,\r\nmax_sg_len);\r\nnx_ctx->op.inlen = (nx_ctx->in_sg - in_sg) * sizeof(struct nx_sg);\r\nnx_ctx->op.outlen = (nx_ctx->out_sg - out_sg) * sizeof(struct nx_sg);\r\nif (!nx_ctx->op.outlen) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = nx_hcall_sync(nx_ctx, &nx_ctx->op,\r\ndesc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&(nx_ctx->stats->sha512_ops));\r\natomic64_add(sctx->count[0], &(nx_ctx->stats->sha512_bytes));\r\nmemcpy(out, csbcpb->cpb.sha512.message_digest, SHA512_DIGEST_SIZE);\r\nout:\r\nspin_unlock_irqrestore(&nx_ctx->lock, irq_flags);\r\nreturn rc;\r\n}\r\nstatic int nx_sha512_export(struct shash_desc *desc, void *out)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(out, sctx, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int nx_sha512_import(struct shash_desc *desc, const void *in)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(sctx, in, sizeof(*sctx));\r\nreturn 0;\r\n}
