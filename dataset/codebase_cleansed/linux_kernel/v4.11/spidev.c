static ssize_t\r\nspidev_sync(struct spidev_data *spidev, struct spi_message *message)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nint status;\r\nstruct spi_device *spi;\r\nspin_lock_irq(&spidev->spi_lock);\r\nspi = spidev->spi;\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (spi == NULL)\r\nstatus = -ESHUTDOWN;\r\nelse\r\nstatus = spi_sync(spi, message);\r\nif (status == 0)\r\nstatus = message->actual_length;\r\nreturn status;\r\n}\r\nstatic inline ssize_t\r\nspidev_sync_write(struct spidev_data *spidev, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.tx_buf = spidev->tx_buffer,\r\n.len = len,\r\n.speed_hz = spidev->speed_hz,\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nreturn spidev_sync(spidev, &m);\r\n}\r\nstatic inline ssize_t\r\nspidev_sync_read(struct spidev_data *spidev, size_t len)\r\n{\r\nstruct spi_transfer t = {\r\n.rx_buf = spidev->rx_buffer,\r\n.len = len,\r\n.speed_hz = spidev->speed_hz,\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nreturn spidev_sync(spidev, &m);\r\n}\r\nstatic ssize_t\r\nspidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)\r\n{\r\nstruct spidev_data *spidev;\r\nssize_t status = 0;\r\nif (count > bufsiz)\r\nreturn -EMSGSIZE;\r\nspidev = filp->private_data;\r\nmutex_lock(&spidev->buf_lock);\r\nstatus = spidev_sync_read(spidev, count);\r\nif (status > 0) {\r\nunsigned long missing;\r\nmissing = copy_to_user(buf, spidev->rx_buffer, status);\r\nif (missing == status)\r\nstatus = -EFAULT;\r\nelse\r\nstatus = status - missing;\r\n}\r\nmutex_unlock(&spidev->buf_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t\r\nspidev_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct spidev_data *spidev;\r\nssize_t status = 0;\r\nunsigned long missing;\r\nif (count > bufsiz)\r\nreturn -EMSGSIZE;\r\nspidev = filp->private_data;\r\nmutex_lock(&spidev->buf_lock);\r\nmissing = copy_from_user(spidev->tx_buffer, buf, count);\r\nif (missing == 0)\r\nstatus = spidev_sync_write(spidev, count);\r\nelse\r\nstatus = -EFAULT;\r\nmutex_unlock(&spidev->buf_lock);\r\nreturn status;\r\n}\r\nstatic int spidev_message(struct spidev_data *spidev,\r\nstruct spi_ioc_transfer *u_xfers, unsigned n_xfers)\r\n{\r\nstruct spi_message msg;\r\nstruct spi_transfer *k_xfers;\r\nstruct spi_transfer *k_tmp;\r\nstruct spi_ioc_transfer *u_tmp;\r\nunsigned n, total, tx_total, rx_total;\r\nu8 *tx_buf, *rx_buf;\r\nint status = -EFAULT;\r\nspi_message_init(&msg);\r\nk_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);\r\nif (k_xfers == NULL)\r\nreturn -ENOMEM;\r\ntx_buf = spidev->tx_buffer;\r\nrx_buf = spidev->rx_buffer;\r\ntotal = 0;\r\ntx_total = 0;\r\nrx_total = 0;\r\nfor (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;\r\nn;\r\nn--, k_tmp++, u_tmp++) {\r\nk_tmp->len = u_tmp->len;\r\ntotal += k_tmp->len;\r\nif (total > INT_MAX || k_tmp->len > INT_MAX) {\r\nstatus = -EMSGSIZE;\r\ngoto done;\r\n}\r\nif (u_tmp->rx_buf) {\r\nrx_total += k_tmp->len;\r\nif (rx_total > bufsiz) {\r\nstatus = -EMSGSIZE;\r\ngoto done;\r\n}\r\nk_tmp->rx_buf = rx_buf;\r\nif (!access_ok(VERIFY_WRITE, (u8 __user *)\r\n(uintptr_t) u_tmp->rx_buf,\r\nu_tmp->len))\r\ngoto done;\r\nrx_buf += k_tmp->len;\r\n}\r\nif (u_tmp->tx_buf) {\r\ntx_total += k_tmp->len;\r\nif (tx_total > bufsiz) {\r\nstatus = -EMSGSIZE;\r\ngoto done;\r\n}\r\nk_tmp->tx_buf = tx_buf;\r\nif (copy_from_user(tx_buf, (const u8 __user *)\r\n(uintptr_t) u_tmp->tx_buf,\r\nu_tmp->len))\r\ngoto done;\r\ntx_buf += k_tmp->len;\r\n}\r\nk_tmp->cs_change = !!u_tmp->cs_change;\r\nk_tmp->tx_nbits = u_tmp->tx_nbits;\r\nk_tmp->rx_nbits = u_tmp->rx_nbits;\r\nk_tmp->bits_per_word = u_tmp->bits_per_word;\r\nk_tmp->delay_usecs = u_tmp->delay_usecs;\r\nk_tmp->speed_hz = u_tmp->speed_hz;\r\nif (!k_tmp->speed_hz)\r\nk_tmp->speed_hz = spidev->speed_hz;\r\n#ifdef VERBOSE\r\ndev_dbg(&spidev->spi->dev,\r\n" xfer len %u %s%s%s%dbits %u usec %uHz\n",\r\nu_tmp->len,\r\nu_tmp->rx_buf ? "rx " : "",\r\nu_tmp->tx_buf ? "tx " : "",\r\nu_tmp->cs_change ? "cs " : "",\r\nu_tmp->bits_per_word ? : spidev->spi->bits_per_word,\r\nu_tmp->delay_usecs,\r\nu_tmp->speed_hz ? : spidev->spi->max_speed_hz);\r\n#endif\r\nspi_message_add_tail(k_tmp, &msg);\r\n}\r\nstatus = spidev_sync(spidev, &msg);\r\nif (status < 0)\r\ngoto done;\r\nrx_buf = spidev->rx_buffer;\r\nfor (n = n_xfers, u_tmp = u_xfers; n; n--, u_tmp++) {\r\nif (u_tmp->rx_buf) {\r\nif (__copy_to_user((u8 __user *)\r\n(uintptr_t) u_tmp->rx_buf, rx_buf,\r\nu_tmp->len)) {\r\nstatus = -EFAULT;\r\ngoto done;\r\n}\r\nrx_buf += u_tmp->len;\r\n}\r\n}\r\nstatus = total;\r\ndone:\r\nkfree(k_xfers);\r\nreturn status;\r\n}\r\nstatic struct spi_ioc_transfer *\r\nspidev_get_ioc_message(unsigned int cmd, struct spi_ioc_transfer __user *u_ioc,\r\nunsigned *n_ioc)\r\n{\r\nstruct spi_ioc_transfer *ioc;\r\nu32 tmp;\r\nif (_IOC_TYPE(cmd) != SPI_IOC_MAGIC\r\n|| _IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))\r\n|| _IOC_DIR(cmd) != _IOC_WRITE)\r\nreturn ERR_PTR(-ENOTTY);\r\ntmp = _IOC_SIZE(cmd);\r\nif ((tmp % sizeof(struct spi_ioc_transfer)) != 0)\r\nreturn ERR_PTR(-EINVAL);\r\n*n_ioc = tmp / sizeof(struct spi_ioc_transfer);\r\nif (*n_ioc == 0)\r\nreturn NULL;\r\nioc = kmalloc(tmp, GFP_KERNEL);\r\nif (!ioc)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (__copy_from_user(ioc, u_ioc, tmp)) {\r\nkfree(ioc);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nreturn ioc;\r\n}\r\nstatic long\r\nspidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nint retval = 0;\r\nstruct spidev_data *spidev;\r\nstruct spi_device *spi;\r\nu32 tmp;\r\nunsigned n_ioc;\r\nstruct spi_ioc_transfer *ioc;\r\nif (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)\r\nreturn -ENOTTY;\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nerr = !access_ok(VERIFY_WRITE,\r\n(void __user *)arg, _IOC_SIZE(cmd));\r\nif (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE)\r\nerr = !access_ok(VERIFY_READ,\r\n(void __user *)arg, _IOC_SIZE(cmd));\r\nif (err)\r\nreturn -EFAULT;\r\nspidev = filp->private_data;\r\nspin_lock_irq(&spidev->spi_lock);\r\nspi = spi_dev_get(spidev->spi);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (spi == NULL)\r\nreturn -ESHUTDOWN;\r\nmutex_lock(&spidev->buf_lock);\r\nswitch (cmd) {\r\ncase SPI_IOC_RD_MODE:\r\nretval = __put_user(spi->mode & SPI_MODE_MASK,\r\n(__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_MODE32:\r\nretval = __put_user(spi->mode & SPI_MODE_MASK,\r\n(__u32 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_LSB_FIRST:\r\nretval = __put_user((spi->mode & SPI_LSB_FIRST) ? 1 : 0,\r\n(__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_BITS_PER_WORD:\r\nretval = __put_user(spi->bits_per_word, (__u8 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_RD_MAX_SPEED_HZ:\r\nretval = __put_user(spidev->speed_hz, (__u32 __user *)arg);\r\nbreak;\r\ncase SPI_IOC_WR_MODE:\r\ncase SPI_IOC_WR_MODE32:\r\nif (cmd == SPI_IOC_WR_MODE)\r\nretval = __get_user(tmp, (u8 __user *)arg);\r\nelse\r\nretval = __get_user(tmp, (u32 __user *)arg);\r\nif (retval == 0) {\r\nu32 save = spi->mode;\r\nif (tmp & ~SPI_MODE_MASK) {\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\ntmp |= spi->mode & ~SPI_MODE_MASK;\r\nspi->mode = (u16)tmp;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->mode = save;\r\nelse\r\ndev_dbg(&spi->dev, "spi mode %x\n", tmp);\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_LSB_FIRST:\r\nretval = __get_user(tmp, (__u8 __user *)arg);\r\nif (retval == 0) {\r\nu32 save = spi->mode;\r\nif (tmp)\r\nspi->mode |= SPI_LSB_FIRST;\r\nelse\r\nspi->mode &= ~SPI_LSB_FIRST;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->mode = save;\r\nelse\r\ndev_dbg(&spi->dev, "%csb first\n",\r\ntmp ? 'l' : 'm');\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_BITS_PER_WORD:\r\nretval = __get_user(tmp, (__u8 __user *)arg);\r\nif (retval == 0) {\r\nu8 save = spi->bits_per_word;\r\nspi->bits_per_word = tmp;\r\nretval = spi_setup(spi);\r\nif (retval < 0)\r\nspi->bits_per_word = save;\r\nelse\r\ndev_dbg(&spi->dev, "%d bits per word\n", tmp);\r\n}\r\nbreak;\r\ncase SPI_IOC_WR_MAX_SPEED_HZ:\r\nretval = __get_user(tmp, (__u32 __user *)arg);\r\nif (retval == 0) {\r\nu32 save = spi->max_speed_hz;\r\nspi->max_speed_hz = tmp;\r\nretval = spi_setup(spi);\r\nif (retval >= 0)\r\nspidev->speed_hz = tmp;\r\nelse\r\ndev_dbg(&spi->dev, "%d Hz (max)\n", tmp);\r\nspi->max_speed_hz = save;\r\n}\r\nbreak;\r\ndefault:\r\nioc = spidev_get_ioc_message(cmd,\r\n(struct spi_ioc_transfer __user *)arg, &n_ioc);\r\nif (IS_ERR(ioc)) {\r\nretval = PTR_ERR(ioc);\r\nbreak;\r\n}\r\nif (!ioc)\r\nbreak;\r\nretval = spidev_message(spidev, ioc, n_ioc);\r\nkfree(ioc);\r\nbreak;\r\n}\r\nmutex_unlock(&spidev->buf_lock);\r\nspi_dev_put(spi);\r\nreturn retval;\r\n}\r\nstatic long\r\nspidev_compat_ioc_message(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct spi_ioc_transfer __user *u_ioc;\r\nint retval = 0;\r\nstruct spidev_data *spidev;\r\nstruct spi_device *spi;\r\nunsigned n_ioc, n;\r\nstruct spi_ioc_transfer *ioc;\r\nu_ioc = (struct spi_ioc_transfer __user *) compat_ptr(arg);\r\nif (!access_ok(VERIFY_READ, u_ioc, _IOC_SIZE(cmd)))\r\nreturn -EFAULT;\r\nspidev = filp->private_data;\r\nspin_lock_irq(&spidev->spi_lock);\r\nspi = spi_dev_get(spidev->spi);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (spi == NULL)\r\nreturn -ESHUTDOWN;\r\nmutex_lock(&spidev->buf_lock);\r\nioc = spidev_get_ioc_message(cmd, u_ioc, &n_ioc);\r\nif (IS_ERR(ioc)) {\r\nretval = PTR_ERR(ioc);\r\ngoto done;\r\n}\r\nif (!ioc)\r\ngoto done;\r\nfor (n = 0; n < n_ioc; n++) {\r\nioc[n].rx_buf = (uintptr_t) compat_ptr(ioc[n].rx_buf);\r\nioc[n].tx_buf = (uintptr_t) compat_ptr(ioc[n].tx_buf);\r\n}\r\nretval = spidev_message(spidev, ioc, n_ioc);\r\nkfree(ioc);\r\ndone:\r\nmutex_unlock(&spidev->buf_lock);\r\nspi_dev_put(spi);\r\nreturn retval;\r\n}\r\nstatic long\r\nspidev_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nif (_IOC_TYPE(cmd) == SPI_IOC_MAGIC\r\n&& _IOC_NR(cmd) == _IOC_NR(SPI_IOC_MESSAGE(0))\r\n&& _IOC_DIR(cmd) == _IOC_WRITE)\r\nreturn spidev_compat_ioc_message(filp, cmd, arg);\r\nreturn spidev_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int spidev_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct spidev_data *spidev;\r\nint status = -ENXIO;\r\nmutex_lock(&device_list_lock);\r\nlist_for_each_entry(spidev, &device_list, device_entry) {\r\nif (spidev->devt == inode->i_rdev) {\r\nstatus = 0;\r\nbreak;\r\n}\r\n}\r\nif (status) {\r\npr_debug("spidev: nothing for minor %d\n", iminor(inode));\r\ngoto err_find_dev;\r\n}\r\nif (!spidev->tx_buffer) {\r\nspidev->tx_buffer = kmalloc(bufsiz, GFP_KERNEL);\r\nif (!spidev->tx_buffer) {\r\ndev_dbg(&spidev->spi->dev, "open/ENOMEM\n");\r\nstatus = -ENOMEM;\r\ngoto err_find_dev;\r\n}\r\n}\r\nif (!spidev->rx_buffer) {\r\nspidev->rx_buffer = kmalloc(bufsiz, GFP_KERNEL);\r\nif (!spidev->rx_buffer) {\r\ndev_dbg(&spidev->spi->dev, "open/ENOMEM\n");\r\nstatus = -ENOMEM;\r\ngoto err_alloc_rx_buf;\r\n}\r\n}\r\nspidev->users++;\r\nfilp->private_data = spidev;\r\nnonseekable_open(inode, filp);\r\nmutex_unlock(&device_list_lock);\r\nreturn 0;\r\nerr_alloc_rx_buf:\r\nkfree(spidev->tx_buffer);\r\nspidev->tx_buffer = NULL;\r\nerr_find_dev:\r\nmutex_unlock(&device_list_lock);\r\nreturn status;\r\n}\r\nstatic int spidev_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct spidev_data *spidev;\r\nmutex_lock(&device_list_lock);\r\nspidev = filp->private_data;\r\nfilp->private_data = NULL;\r\nspidev->users--;\r\nif (!spidev->users) {\r\nint dofree;\r\nkfree(spidev->tx_buffer);\r\nspidev->tx_buffer = NULL;\r\nkfree(spidev->rx_buffer);\r\nspidev->rx_buffer = NULL;\r\nspin_lock_irq(&spidev->spi_lock);\r\nif (spidev->spi)\r\nspidev->speed_hz = spidev->spi->max_speed_hz;\r\ndofree = (spidev->spi == NULL);\r\nspin_unlock_irq(&spidev->spi_lock);\r\nif (dofree)\r\nkfree(spidev);\r\n}\r\nmutex_unlock(&device_list_lock);\r\nreturn 0;\r\n}\r\nstatic void spidev_probe_acpi(struct spi_device *spi)\r\n{\r\nconst struct acpi_device_id *id;\r\nif (!has_acpi_companion(&spi->dev))\r\nreturn;\r\nid = acpi_match_device(spidev_acpi_ids, &spi->dev);\r\nif (WARN_ON(!id))\r\nreturn;\r\nif (id->driver_data == SPIDEV_ACPI_DUMMY)\r\ndev_warn(&spi->dev, "do not use this driver in production systems!\n");\r\n}\r\nstatic inline void spidev_probe_acpi(struct spi_device *spi) {}\r\nstatic int spidev_probe(struct spi_device *spi)\r\n{\r\nstruct spidev_data *spidev;\r\nint status;\r\nunsigned long minor;\r\nif (spi->dev.of_node && !of_match_device(spidev_dt_ids, &spi->dev)) {\r\ndev_err(&spi->dev, "buggy DT: spidev listed directly in DT\n");\r\nWARN_ON(spi->dev.of_node &&\r\n!of_match_device(spidev_dt_ids, &spi->dev));\r\n}\r\nspidev_probe_acpi(spi);\r\nspidev = kzalloc(sizeof(*spidev), GFP_KERNEL);\r\nif (!spidev)\r\nreturn -ENOMEM;\r\nspidev->spi = spi;\r\nspin_lock_init(&spidev->spi_lock);\r\nmutex_init(&spidev->buf_lock);\r\nINIT_LIST_HEAD(&spidev->device_entry);\r\nmutex_lock(&device_list_lock);\r\nminor = find_first_zero_bit(minors, N_SPI_MINORS);\r\nif (minor < N_SPI_MINORS) {\r\nstruct device *dev;\r\nspidev->devt = MKDEV(SPIDEV_MAJOR, minor);\r\ndev = device_create(spidev_class, &spi->dev, spidev->devt,\r\nspidev, "spidev%d.%d",\r\nspi->master->bus_num, spi->chip_select);\r\nstatus = PTR_ERR_OR_ZERO(dev);\r\n} else {\r\ndev_dbg(&spi->dev, "no minor number available!\n");\r\nstatus = -ENODEV;\r\n}\r\nif (status == 0) {\r\nset_bit(minor, minors);\r\nlist_add(&spidev->device_entry, &device_list);\r\n}\r\nmutex_unlock(&device_list_lock);\r\nspidev->speed_hz = spi->max_speed_hz;\r\nif (status == 0)\r\nspi_set_drvdata(spi, spidev);\r\nelse\r\nkfree(spidev);\r\nreturn status;\r\n}\r\nstatic int spidev_remove(struct spi_device *spi)\r\n{\r\nstruct spidev_data *spidev = spi_get_drvdata(spi);\r\nspin_lock_irq(&spidev->spi_lock);\r\nspidev->spi = NULL;\r\nspin_unlock_irq(&spidev->spi_lock);\r\nmutex_lock(&device_list_lock);\r\nlist_del(&spidev->device_entry);\r\ndevice_destroy(spidev_class, spidev->devt);\r\nclear_bit(MINOR(spidev->devt), minors);\r\nif (spidev->users == 0)\r\nkfree(spidev);\r\nmutex_unlock(&device_list_lock);\r\nreturn 0;\r\n}\r\nstatic int __init spidev_init(void)\r\n{\r\nint status;\r\nBUILD_BUG_ON(N_SPI_MINORS > 256);\r\nstatus = register_chrdev(SPIDEV_MAJOR, "spi", &spidev_fops);\r\nif (status < 0)\r\nreturn status;\r\nspidev_class = class_create(THIS_MODULE, "spidev");\r\nif (IS_ERR(spidev_class)) {\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\nreturn PTR_ERR(spidev_class);\r\n}\r\nstatus = spi_register_driver(&spidev_spi_driver);\r\nif (status < 0) {\r\nclass_destroy(spidev_class);\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit spidev_exit(void)\r\n{\r\nspi_unregister_driver(&spidev_spi_driver);\r\nclass_destroy(spidev_class);\r\nunregister_chrdev(SPIDEV_MAJOR, spidev_spi_driver.driver.name);\r\n}
