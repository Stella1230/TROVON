void impd1_tweak_control(struct device *dev, u32 mask, u32 val)\r\n{\r\nstruct impd1_module *impd1 = dev_get_drvdata(dev);\r\nu32 cur;\r\nval &= mask;\r\ncur = readl(impd1->base + IMPD1_CTRL) & ~mask;\r\nwritel(cur | val, impd1->base + IMPD1_CTRL);\r\n}\r\nstatic void impd1fb_clcd_disable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK, 0);\r\n}\r\nstatic void impd1fb_clcd_enable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK,\r\nfb->panel->connector | IMPD1_CTRL_DISP_ENABLE);\r\n}\r\nstatic int impd1fb_clcd_setup(struct clcd_fb *fb)\r\n{\r\nunsigned long framebase = fb->dev->res.start + 0x01000000;\r\nunsigned long framesize = SZ_1M;\r\nint ret = 0;\r\nfb->panel = &PANELTYPE;\r\nif (!request_mem_region(framebase, framesize, "clcd framebuffer")) {\r\nprintk(KERN_ERR "IM-PD1: unable to reserve framebuffer\n");\r\nreturn -EBUSY;\r\n}\r\nfb->fb.screen_base = ioremap(framebase, framesize);\r\nif (!fb->fb.screen_base) {\r\nprintk(KERN_ERR "IM-PD1: unable to map framebuffer\n");\r\nret = -ENOMEM;\r\ngoto free_buffer;\r\n}\r\nfb->fb.fix.smem_start = framebase;\r\nfb->fb.fix.smem_len = framesize;\r\nreturn 0;\r\nfree_buffer:\r\nrelease_mem_region(framebase, framesize);\r\nreturn ret;\r\n}\r\nstatic int impd1fb_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nunsigned long start, size;\r\nstart = vma->vm_pgoff + (fb->fb.fix.smem_start >> PAGE_SHIFT);\r\nsize = vma->vm_end - vma->vm_start;\r\nreturn remap_pfn_range(vma, vma->vm_start, start, size,\r\nvma->vm_page_prot);\r\n}\r\nstatic void impd1fb_clcd_remove(struct clcd_fb *fb)\r\n{\r\niounmap(fb->fb.screen_base);\r\nrelease_mem_region(fb->fb.fix.smem_start, fb->fb.fix.smem_len);\r\n}\r\nstatic int __ref impd1_probe(struct lm_device *dev)\r\n{\r\nstruct impd1_module *impd1;\r\nint irq_base;\r\nint i;\r\nif (dev->id != module_id)\r\nreturn -EINVAL;\r\nif (!devm_request_mem_region(&dev->dev, dev->resource.start,\r\nSZ_4K, "LM registers"))\r\nreturn -EBUSY;\r\nimpd1 = devm_kzalloc(&dev->dev, sizeof(struct impd1_module),\r\nGFP_KERNEL);\r\nif (!impd1)\r\nreturn -ENOMEM;\r\nimpd1->base = devm_ioremap(&dev->dev, dev->resource.start, SZ_4K);\r\nif (!impd1->base)\r\nreturn -ENOMEM;\r\nintegrator_impd1_clk_init(impd1->base, dev->id);\r\nif (!devm_request_mem_region(&dev->dev,\r\ndev->resource.start + 0x03000000,\r\nSZ_4K, "VIC"))\r\nreturn -EBUSY;\r\nimpd1->vic_base = devm_ioremap(&dev->dev,\r\ndev->resource.start + 0x03000000,\r\nSZ_4K);\r\nif (!impd1->vic_base)\r\nreturn -ENOMEM;\r\nirq_base = vic_init_cascaded(impd1->vic_base, dev->irq,\r\nIMPD1_VALID_IRQS, 0);\r\nlm_set_drvdata(dev, impd1);\r\ndev_info(&dev->dev, "IM-PD1 found at 0x%08lx\n",\r\n(unsigned long)dev->resource.start);\r\nfor (i = 0; i < ARRAY_SIZE(impd1_devs); i++) {\r\nstruct impd1_device *idev = impd1_devs + i;\r\nstruct amba_device *d;\r\nunsigned long pc_base;\r\nchar devname[32];\r\nint irq1 = idev->irq[0];\r\nint irq2 = idev->irq[1];\r\nif (irq1)\r\nirq1 += irq_base;\r\nif (irq2)\r\nirq2 += irq_base;\r\npc_base = dev->resource.start + idev->offset;\r\nsnprintf(devname, 32, "lm%x:%5.5lx", dev->id, idev->offset >> 12);\r\nif (idev->offset == 0x00400000) {\r\nstruct gpiod_lookup_table *lookup;\r\nchar *chipname;\r\nchar *mmciname;\r\nlookup = devm_kzalloc(&dev->dev,\r\nsizeof(*lookup) + 3 * sizeof(struct gpiod_lookup),\r\nGFP_KERNEL);\r\nchipname = devm_kstrdup(&dev->dev, devname, GFP_KERNEL);\r\nmmciname = kasprintf(GFP_KERNEL, "lm%x:00700", dev->id);\r\nlookup->dev_id = mmciname;\r\nlookup->table[0].chip_label = chipname;\r\nlookup->table[0].chip_hwnum = 3;\r\nlookup->table[0].con_id = "wp";\r\nlookup->table[1].chip_label = chipname;\r\nlookup->table[1].chip_hwnum = 4;\r\nlookup->table[1].con_id = "cd";\r\nlookup->table[1].flags = GPIO_ACTIVE_LOW;\r\ngpiod_add_lookup_table(lookup);\r\n}\r\nd = amba_ahb_device_add_res(&dev->dev, devname, pc_base, SZ_4K,\r\nirq1, irq2,\r\nidev->platform_data, idev->id,\r\n&dev->resource);\r\nif (IS_ERR(d)) {\r\ndev_err(&dev->dev, "unable to register device: %ld\n", PTR_ERR(d));\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int impd1_remove_one(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void impd1_remove(struct lm_device *dev)\r\n{\r\ndevice_for_each_child(&dev->dev, NULL, impd1_remove_one);\r\nintegrator_impd1_clk_exit(dev->id);\r\nlm_set_drvdata(dev, NULL);\r\n}\r\nstatic int __init impd1_init(void)\r\n{\r\nreturn lm_driver_register(&impd1_driver);\r\n}\r\nstatic void __exit impd1_exit(void)\r\n{\r\nlm_driver_unregister(&impd1_driver);\r\n}
