int obd_connect_flags2str(char *page, int count, __u64 flags, char *sep)\r\n{\r\n__u64 mask = 1;\r\nint i, ret = 0;\r\nfor (i = 0; obd_connect_names[i]; i++, mask <<= 1) {\r\nif (flags & mask)\r\nret += snprintf(page + ret, count - ret, "%s%s",\r\nret ? sep : "", obd_connect_names[i]);\r\n}\r\nif (flags & ~(mask - 1))\r\nret += snprintf(page + ret, count - ret,\r\n"%sunknown flags %#llx",\r\nret ? sep : "", flags & ~(mask - 1));\r\nreturn ret;\r\n}\r\nstatic void obd_connect_data_seqprint(struct seq_file *m,\r\nstruct obd_connect_data *ocd)\r\n{\r\nu64 flags;\r\nLASSERT(ocd);\r\nflags = ocd->ocd_connect_flags;\r\nseq_printf(m, " connect_data:\n"\r\n" flags: %llx\n"\r\n" instance: %u\n",\r\nocd->ocd_connect_flags,\r\nocd->ocd_instance);\r\nif (flags & OBD_CONNECT_VERSION)\r\nseq_printf(m, " target_version: %u.%u.%u.%u\n",\r\nOBD_OCD_VERSION_MAJOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_MINOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_PATCH(ocd->ocd_version),\r\nOBD_OCD_VERSION_FIX(ocd->ocd_version));\r\nif (flags & OBD_CONNECT_MDS)\r\nseq_printf(m, " mdt_index: %d\n", ocd->ocd_group);\r\nif (flags & OBD_CONNECT_GRANT)\r\nseq_printf(m, " initial_grant: %d\n", ocd->ocd_grant);\r\nif (flags & OBD_CONNECT_INDEX)\r\nseq_printf(m, " target_index: %u\n", ocd->ocd_index);\r\nif (flags & OBD_CONNECT_BRW_SIZE)\r\nseq_printf(m, " max_brw_size: %d\n", ocd->ocd_brw_size);\r\nif (flags & OBD_CONNECT_IBITS)\r\nseq_printf(m, " ibits_known: %llx\n",\r\nocd->ocd_ibits_known);\r\nif (flags & OBD_CONNECT_GRANT_PARAM)\r\nseq_printf(m, " grant_block_size: %d\n"\r\n" grant_inode_size: %d\n"\r\n" grant_extent_overhead: %d\n",\r\nocd->ocd_blocksize,\r\nocd->ocd_inodespace,\r\nocd->ocd_grant_extent);\r\nif (flags & OBD_CONNECT_TRANSNO)\r\nseq_printf(m, " first_transno: %llx\n",\r\nocd->ocd_transno);\r\nif (flags & OBD_CONNECT_CKSUM)\r\nseq_printf(m, " cksum_types: %#x\n",\r\nocd->ocd_cksum_types);\r\nif (flags & OBD_CONNECT_MAX_EASIZE)\r\nseq_printf(m, " max_easize: %d\n", ocd->ocd_max_easize);\r\nif (flags & OBD_CONNECT_MAXBYTES)\r\nseq_printf(m, " max_object_bytes: %llx\n",\r\nocd->ocd_maxbytes);\r\nif (flags & OBD_CONNECT_MULTIMODRPCS)\r\nseq_printf(m, " max_mod_rpcs: %hu\n",\r\nocd->ocd_maxmodrpcs);\r\n}\r\nint lprocfs_read_frac_helper(char *buffer, unsigned long count, long val,\r\nint mult)\r\n{\r\nlong decimal_val, frac_val;\r\nint prtn;\r\nif (count < 10)\r\nreturn -EINVAL;\r\ndecimal_val = val / mult;\r\nprtn = snprintf(buffer, count, "%ld", decimal_val);\r\nfrac_val = val % mult;\r\nif (prtn < (count - 4) && frac_val > 0) {\r\nlong temp_frac;\r\nint i, temp_mult = 1, frac_bits = 0;\r\ntemp_frac = frac_val * 10;\r\nbuffer[prtn++] = '.';\r\nwhile (frac_bits < 2 && (temp_frac / mult) < 1) {\r\nbuffer[prtn++] = '0';\r\ntemp_frac *= 10;\r\nfrac_bits++;\r\n}\r\nfor (i = 0; i < (5 - prtn); i++)\r\ntemp_mult *= 10;\r\nfrac_bits = min((int)count - prtn, 3 - frac_bits);\r\nprtn += snprintf(buffer + prtn, frac_bits, "%ld",\r\nfrac_val * temp_mult / mult);\r\nprtn--;\r\nwhile (buffer[prtn] < '1' || buffer[prtn] > '9') {\r\nprtn--;\r\nif (buffer[prtn] == '.') {\r\nprtn--;\r\nbreak;\r\n}\r\n}\r\nprtn++;\r\n}\r\nbuffer[prtn++] = '\n';\r\nreturn prtn;\r\n}\r\nint lprocfs_write_frac_helper(const char __user *buffer, unsigned long count,\r\nint *val, int mult)\r\n{\r\nchar kernbuf[20], *end, *pbuf;\r\nif (count > (sizeof(kernbuf) - 1))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = '\0';\r\npbuf = kernbuf;\r\nif (*pbuf == '-') {\r\nmult = -mult;\r\npbuf++;\r\n}\r\n*val = (int)simple_strtoul(pbuf, &end, 10) * mult;\r\nif (pbuf == end)\r\nreturn -EINVAL;\r\nif (end && *end == '.') {\r\nint temp_val, pow = 1;\r\nint i;\r\npbuf = end + 1;\r\nif (strlen(pbuf) > 5)\r\npbuf[5] = '\0';\r\ntemp_val = (int)simple_strtoul(pbuf, &end, 10) * mult;\r\nif (pbuf < end) {\r\nfor (i = 0; i < (end - pbuf); i++)\r\npow *= 10;\r\n*val += temp_val / pow;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint lprocfs_single_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nint lprocfs_seq_release(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_release(inode, file);\r\n}\r\nstruct dentry *ldebugfs_add_simple(struct dentry *root,\r\nchar *name, void *data,\r\nstruct file_operations *fops)\r\n{\r\nstruct dentry *entry;\r\numode_t mode = 0;\r\nif (!root || !name || !fops)\r\nreturn ERR_PTR(-EINVAL);\r\nif (fops->read)\r\nmode = 0444;\r\nif (fops->write)\r\nmode |= 0200;\r\nentry = debugfs_create_file(name, mode, root, data, fops);\r\nif (IS_ERR_OR_NULL(entry)) {\r\nCERROR("LprocFS: No memory to create <debugfs> entry %s\n", name);\r\nreturn entry ?: ERR_PTR(-ENOMEM);\r\n}\r\nreturn entry;\r\n}\r\nint ldebugfs_add_vars(struct dentry *parent,\r\nstruct lprocfs_vars *list,\r\nvoid *data)\r\n{\r\nif (IS_ERR_OR_NULL(parent) || IS_ERR_OR_NULL(list))\r\nreturn -EINVAL;\r\nwhile (list->name) {\r\nstruct dentry *entry;\r\numode_t mode = 0;\r\nif (list->proc_mode != 0000) {\r\nmode = list->proc_mode;\r\n} else if (list->fops) {\r\nif (list->fops->read)\r\nmode = 0444;\r\nif (list->fops->write)\r\nmode |= 0200;\r\n}\r\nentry = debugfs_create_file(list->name, mode, parent,\r\nlist->data ?: data,\r\nlist->fops ?: &lprocfs_generic_fops\r\n);\r\nif (IS_ERR_OR_NULL(entry))\r\nreturn entry ? PTR_ERR(entry) : -ENOMEM;\r\nlist++;\r\n}\r\nreturn 0;\r\n}\r\nvoid ldebugfs_remove(struct dentry **entryp)\r\n{\r\ndebugfs_remove_recursive(*entryp);\r\n*entryp = NULL;\r\n}\r\nstruct dentry *ldebugfs_register(const char *name,\r\nstruct dentry *parent,\r\nstruct lprocfs_vars *list, void *data)\r\n{\r\nstruct dentry *entry;\r\nentry = debugfs_create_dir(name, parent);\r\nif (IS_ERR_OR_NULL(entry)) {\r\nentry = entry ?: ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nif (!IS_ERR_OR_NULL(list)) {\r\nint rc;\r\nrc = ldebugfs_add_vars(entry, list, data);\r\nif (rc != 0) {\r\ndebugfs_remove(entry);\r\nentry = ERR_PTR(rc);\r\n}\r\n}\r\nout:\r\nreturn entry;\r\n}\r\nint lprocfs_rd_uint(struct seq_file *m, void *data)\r\n{\r\nseq_printf(m, "%u\n", *(unsigned int *)data);\r\nreturn 0;\r\n}\r\nint lprocfs_wr_uint(struct file *file, const char __user *buffer,\r\nunsigned long count, void *data)\r\n{\r\nunsigned *p = data;\r\nchar dummy[MAX_STRING_SIZE + 1], *end;\r\nunsigned long tmp;\r\nif (count >= sizeof(dummy))\r\nreturn -EINVAL;\r\nif (count == 0)\r\nreturn 0;\r\nif (copy_from_user(dummy, buffer, count))\r\nreturn -EFAULT;\r\ndummy[count] = '\0';\r\ntmp = simple_strtoul(dummy, &end, 0);\r\nif (dummy == end)\r\nreturn -EINVAL;\r\n*p = (unsigned int)tmp;\r\nreturn count;\r\n}\r\nstatic ssize_t uuid_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%s\n", obd->obd_uuid.uuid);\r\n}\r\nstatic ssize_t blocksize_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%u\n", osfs.os_bsize);\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytestotal_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_blocks;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nreturn sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytesfree_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bfree;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nreturn sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytesavail_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bavail;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nreturn sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t filestotal_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%llu\n", osfs.os_files);\r\nreturn rc;\r\n}\r\nstatic ssize_t filesfree_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct obd_statfs osfs;\r\nint rc = obd_statfs(NULL, obd->obd_self_export, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%llu\n", osfs.os_ffree);\r\nreturn rc;\r\n}\r\nint lprocfs_rd_server_uuid(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nchar *imp_state_name = NULL;\r\nint rc;\r\nLASSERT(obd);\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nimp = obd->u.cli.cl_import;\r\nimp_state_name = ptlrpc_import_state_name(imp->imp_state);\r\nseq_printf(m, "%s\t%s%s\n",\r\nobd2cli_tgt(obd), imp_state_name,\r\nimp->imp_deactive ? "\tDEACTIVATED" : "");\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_conn_uuid(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct ptlrpc_connection *conn;\r\nint rc;\r\nLASSERT(obd);\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nconn = obd->u.cli.cl_import->imp_connection;\r\nif (conn && obd->u.cli.cl_import)\r\nseq_printf(m, "%s\n", conn->c_remote_uuid.uuid);\r\nelse\r\nseq_puts(m, "<none>\n");\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nvoid lprocfs_stats_collect(struct lprocfs_stats *stats, int idx,\r\nstruct lprocfs_counter *cnt)\r\n{\r\nunsigned int num_entry;\r\nstruct lprocfs_counter *percpu_cntr;\r\nint i;\r\nunsigned long flags = 0;\r\nmemset(cnt, 0, sizeof(*cnt));\r\nif (!stats) {\r\ncnt->lc_count = 1;\r\nreturn;\r\n}\r\ncnt->lc_min = LC_MIN_INIT;\r\nnum_entry = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_entry; i++) {\r\nif (!stats->ls_percpu[i])\r\ncontinue;\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, idx);\r\ncnt->lc_count += percpu_cntr->lc_count;\r\ncnt->lc_sum += percpu_cntr->lc_sum;\r\nif (percpu_cntr->lc_min < cnt->lc_min)\r\ncnt->lc_min = percpu_cntr->lc_min;\r\nif (percpu_cntr->lc_max > cnt->lc_max)\r\ncnt->lc_max = percpu_cntr->lc_max;\r\ncnt->lc_sumsquare += percpu_cntr->lc_sumsquare;\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nstatic int obd_import_flags2str(struct obd_import *imp, struct seq_file *m)\r\n{\r\nbool first = true;\r\nif (imp->imp_obd->obd_no_recov) {\r\nseq_printf(m, "no_recov");\r\nfirst = false;\r\n}\r\nflag2str(invalid, first);\r\nfirst = false;\r\nflag2str(deactive, first);\r\nflag2str(replayable, first);\r\nflag2str(pingable, first);\r\nreturn 0;\r\n}\r\nstatic void obd_connect_seq_flags2str(struct seq_file *m, __u64 flags, char *sep)\r\n{\r\n__u64 mask = 1;\r\nint i;\r\nbool first = true;\r\nfor (i = 0; obd_connect_names[i]; i++, mask <<= 1) {\r\nif (flags & mask) {\r\nseq_printf(m, "%s%s",\r\nfirst ? sep : "", obd_connect_names[i]);\r\nfirst = false;\r\n}\r\n}\r\nif (flags & ~(mask - 1))\r\nseq_printf(m, "%sunknown flags %#llx",\r\nfirst ? sep : "", flags & ~(mask - 1));\r\n}\r\nint lprocfs_rd_import(struct seq_file *m, void *data)\r\n{\r\nchar nidstr[LNET_NIDSTR_SIZE];\r\nstruct lprocfs_counter ret;\r\nstruct lprocfs_counter_header *header;\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nstruct obd_import_conn *conn;\r\nstruct obd_connect_data *ocd;\r\nint j;\r\nint k;\r\nint rw = 0;\r\nint rc;\r\nLASSERT(obd);\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nimp = obd->u.cli.cl_import;\r\nocd = &imp->imp_connect_data;\r\nseq_printf(m, "import:\n"\r\n" name: %s\n"\r\n" target: %s\n"\r\n" state: %s\n"\r\n" instance: %u\n"\r\n" connect_flags: [ ",\r\nobd->obd_name,\r\nobd2cli_tgt(obd),\r\nptlrpc_import_state_name(imp->imp_state),\r\nimp->imp_connect_data.ocd_instance);\r\nobd_connect_seq_flags2str(m, imp->imp_connect_data.ocd_connect_flags,\r\n", ");\r\nseq_printf(m, " ]\n");\r\nobd_connect_data_seqprint(m, ocd);\r\nseq_printf(m, " import_flags: [ ");\r\nobd_import_flags2str(imp, m);\r\nseq_printf(m,\r\n" ]\n"\r\n" connection:\n"\r\n" failover_nids: [ ");\r\nspin_lock(&imp->imp_lock);\r\nj = 0;\r\nlist_for_each_entry(conn, &imp->imp_conn_list, oic_item) {\r\nlibcfs_nid2str_r(conn->oic_conn->c_peer.nid,\r\nnidstr, sizeof(nidstr));\r\nseq_printf(m, "%s%s", j ? ", " : "", nidstr);\r\nj++;\r\n}\r\nif (imp->imp_connection)\r\nlibcfs_nid2str_r(imp->imp_connection->c_peer.nid,\r\nnidstr, sizeof(nidstr));\r\nelse\r\nstrncpy(nidstr, "<none>", sizeof(nidstr));\r\nseq_printf(m,\r\n" ]\n"\r\n" current_connection: %s\n"\r\n" connection_attempts: %u\n"\r\n" generation: %u\n"\r\n" in-progress_invalidations: %u\n",\r\nnidstr,\r\nimp->imp_conn_cnt,\r\nimp->imp_generation,\r\natomic_read(&imp->imp_inval_count));\r\nspin_unlock(&imp->imp_lock);\r\nif (!obd->obd_svc_stats)\r\ngoto out_climp;\r\nheader = &obd->obd_svc_stats->ls_cnt_header[PTLRPC_REQWAIT_CNTR];\r\nlprocfs_stats_collect(obd->obd_svc_stats, PTLRPC_REQWAIT_CNTR, &ret);\r\nif (ret.lc_count != 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\n} else {\r\nret.lc_sum = 0;\r\n}\r\nseq_printf(m,\r\n" rpcs:\n"\r\n" inflight: %u\n"\r\n" unregistering: %u\n"\r\n" timeouts: %u\n"\r\n" avg_waittime: %llu %s\n",\r\natomic_read(&imp->imp_inflight),\r\natomic_read(&imp->imp_unregistering),\r\natomic_read(&imp->imp_timeouts),\r\nret.lc_sum, header->lc_units);\r\nk = 0;\r\nfor (j = 0; j < IMP_AT_MAX_PORTALS; j++) {\r\nif (imp->imp_at.iat_portal[j] == 0)\r\nbreak;\r\nk = max_t(unsigned int, k,\r\nat_get(&imp->imp_at.iat_service_estimate[j]));\r\n}\r\nseq_printf(m,\r\n" service_estimates:\n"\r\n" services: %u sec\n"\r\n" network: %u sec\n",\r\nk,\r\nat_get(&imp->imp_at.iat_net_latency));\r\nseq_printf(m,\r\n" transactions:\n"\r\n" last_replay: %llu\n"\r\n" peer_committed: %llu\n"\r\n" last_checked: %llu\n",\r\nimp->imp_last_replay_transno,\r\nimp->imp_peer_committed_transno,\r\nimp->imp_last_transno_checked);\r\nfor (rw = 0; rw <= 1; rw++) {\r\nlprocfs_stats_collect(obd->obd_svc_stats,\r\nPTLRPC_LAST_CNTR + BRW_READ_BYTES + rw,\r\n&ret);\r\nif (ret.lc_sum > 0 && ret.lc_count > 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\nseq_printf(m,\r\n" %s_data_averages:\n"\r\n" bytes_per_rpc: %llu\n",\r\nrw ? "write" : "read",\r\nret.lc_sum);\r\n}\r\nk = (int)ret.lc_sum;\r\nj = opcode_offset(OST_READ + rw) + EXTRA_MAX_OPCODES;\r\nheader = &obd->obd_svc_stats->ls_cnt_header[j];\r\nlprocfs_stats_collect(obd->obd_svc_stats, j, &ret);\r\nif (ret.lc_sum > 0 && ret.lc_count != 0) {\r\n__u64 sum = ret.lc_sum;\r\ndo_div(sum, ret.lc_count);\r\nret.lc_sum = sum;\r\nseq_printf(m,\r\n" %s_per_rpc: %llu\n",\r\nheader->lc_units, ret.lc_sum);\r\nj = (int)ret.lc_sum;\r\nif (j > 0)\r\nseq_printf(m,\r\n" MB_per_sec: %u.%.02u\n",\r\nk / j, (100 * k / j) % 100);\r\n}\r\n}\r\nout_climp:\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_state(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nint j, k, rc;\r\nLASSERT(obd);\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nimp = obd->u.cli.cl_import;\r\nseq_printf(m, "current_state: %s\n",\r\nptlrpc_import_state_name(imp->imp_state));\r\nseq_printf(m, "state_history:\n");\r\nk = imp->imp_state_hist_idx;\r\nfor (j = 0; j < IMP_STATE_HIST_LEN; j++) {\r\nstruct import_state_hist *ish =\r\n&imp->imp_state_hist[(k + j) % IMP_STATE_HIST_LEN];\r\nif (ish->ish_state == 0)\r\ncontinue;\r\nseq_printf(m, " - [ %lld, %s ]\n", (s64)ish->ish_time,\r\nptlrpc_import_state_name(ish->ish_state));\r\n}\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nint lprocfs_at_hist_helper(struct seq_file *m, struct adaptive_timeout *at)\r\n{\r\nint i;\r\nfor (i = 0; i < AT_BINS; i++)\r\nseq_printf(m, "%3u ", at->at_hist[i]);\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nint lprocfs_rd_timeouts(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nunsigned int cur, worst;\r\ntime64_t now, worstt;\r\nstruct dhms ts;\r\nint i, rc;\r\nLASSERT(obd);\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nimp = obd->u.cli.cl_import;\r\nnow = ktime_get_real_seconds();\r\ns2dhms(&ts, now - imp->imp_last_reply_time);\r\nseq_printf(m, "%-10s : %lld, " DHMS_FMT " ago\n",\r\n"last reply", (s64)imp->imp_last_reply_time, DHMS_VARS(&ts));\r\ncur = at_get(&imp->imp_at.iat_net_latency);\r\nworst = imp->imp_at.iat_net_latency.at_worst_ever;\r\nworstt = imp->imp_at.iat_net_latency.at_worst_time;\r\ns2dhms(&ts, now - worstt);\r\nseq_printf(m, "%-10s : cur %3u worst %3u (at %lld, " DHMS_FMT " ago) ",\r\n"network", cur, worst, (s64)worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &imp->imp_at.iat_net_latency);\r\nfor (i = 0; i < IMP_AT_MAX_PORTALS; i++) {\r\nif (imp->imp_at.iat_portal[i] == 0)\r\nbreak;\r\ncur = at_get(&imp->imp_at.iat_service_estimate[i]);\r\nworst = imp->imp_at.iat_service_estimate[i].at_worst_ever;\r\nworstt = imp->imp_at.iat_service_estimate[i].at_worst_time;\r\ns2dhms(&ts, now - worstt);\r\nseq_printf(m, "portal %-2d : cur %3u worst %3u (at %lld, "\r\nDHMS_FMT " ago) ", imp->imp_at.iat_portal[i],\r\ncur, worst, (s64)worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &imp->imp_at.iat_service_estimate[i]);\r\n}\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nint lprocfs_rd_connect_flags(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\n__u64 flags;\r\nint rc;\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nflags = obd->u.cli.cl_import->imp_connect_data.ocd_connect_flags;\r\nseq_printf(m, "flags=%#llx\n", flags);\r\nobd_connect_seq_flags2str(m, flags, "\n");\r\nseq_printf(m, "\n");\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nstatic void obd_sysfs_release(struct kobject *kobj)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\ncomplete(&obd->obd_kobj_unregister);\r\n}\r\nint lprocfs_obd_setup(struct obd_device *obd, struct lprocfs_vars *list,\r\nstruct attribute_group *attrs)\r\n{\r\nint rc = 0;\r\ninit_completion(&obd->obd_kobj_unregister);\r\nrc = kobject_init_and_add(&obd->obd_kobj, &obd_ktype,\r\nobd->obd_type->typ_kobj,\r\n"%s", obd->obd_name);\r\nif (rc)\r\nreturn rc;\r\nif (attrs) {\r\nrc = sysfs_create_group(&obd->obd_kobj, attrs);\r\nif (rc) {\r\nkobject_put(&obd->obd_kobj);\r\nreturn rc;\r\n}\r\n}\r\nobd->obd_debugfs_entry = ldebugfs_register(obd->obd_name,\r\nobd->obd_type->typ_debugfs_entry,\r\nlist, obd);\r\nif (IS_ERR_OR_NULL(obd->obd_debugfs_entry)) {\r\nrc = obd->obd_debugfs_entry ? PTR_ERR(obd->obd_debugfs_entry)\r\n: -ENOMEM;\r\nCERROR("error %d setting up lprocfs for %s\n",\r\nrc, obd->obd_name);\r\nobd->obd_debugfs_entry = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_obd_cleanup(struct obd_device *obd)\r\n{\r\nif (!obd)\r\nreturn -EINVAL;\r\nif (!IS_ERR_OR_NULL(obd->obd_debugfs_entry))\r\nldebugfs_remove(&obd->obd_debugfs_entry);\r\nkobject_put(&obd->obd_kobj);\r\nwait_for_completion(&obd->obd_kobj_unregister);\r\nreturn 0;\r\n}\r\nint lprocfs_stats_alloc_one(struct lprocfs_stats *stats, unsigned int cpuid)\r\n{\r\nstruct lprocfs_counter *cntr;\r\nunsigned int percpusize;\r\nint rc = -ENOMEM;\r\nunsigned long flags = 0;\r\nint i;\r\nLASSERT(!stats->ls_percpu[cpuid]);\r\nLASSERT((stats->ls_flags & LPROCFS_STATS_FLAG_NOPERCPU) == 0);\r\npercpusize = lprocfs_stats_counter_size(stats);\r\nLIBCFS_ALLOC_ATOMIC(stats->ls_percpu[cpuid], percpusize);\r\nif (stats->ls_percpu[cpuid]) {\r\nrc = 0;\r\nif (unlikely(stats->ls_biggest_alloc_num <= cpuid)) {\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE)\r\nspin_lock_irqsave(&stats->ls_lock, flags);\r\nelse\r\nspin_lock(&stats->ls_lock);\r\nif (stats->ls_biggest_alloc_num <= cpuid)\r\nstats->ls_biggest_alloc_num = cpuid + 1;\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE)\r\nspin_unlock_irqrestore(&stats->ls_lock, flags);\r\nelse\r\nspin_unlock(&stats->ls_lock);\r\n}\r\nfor (i = 0; i < stats->ls_num; ++i) {\r\ncntr = lprocfs_stats_counter_get(stats, cpuid, i);\r\ncntr->lc_min = LC_MIN_INIT;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstruct lprocfs_stats *lprocfs_alloc_stats(unsigned int num,\r\nenum lprocfs_stats_flags flags)\r\n{\r\nstruct lprocfs_stats *stats;\r\nunsigned int num_entry;\r\nunsigned int percpusize = 0;\r\nint i;\r\nif (num == 0)\r\nreturn NULL;\r\nif (lprocfs_no_percpu_stats != 0)\r\nflags |= LPROCFS_STATS_FLAG_NOPERCPU;\r\nif (flags & LPROCFS_STATS_FLAG_NOPERCPU)\r\nnum_entry = 1;\r\nelse\r\nnum_entry = num_possible_cpus();\r\nLIBCFS_ALLOC(stats, offsetof(typeof(*stats), ls_percpu[num_entry]));\r\nif (!stats)\r\nreturn NULL;\r\nstats->ls_num = num;\r\nstats->ls_flags = flags;\r\nspin_lock_init(&stats->ls_lock);\r\nLIBCFS_ALLOC(stats->ls_cnt_header,\r\nstats->ls_num * sizeof(struct lprocfs_counter_header));\r\nif (!stats->ls_cnt_header)\r\ngoto fail;\r\nif ((flags & LPROCFS_STATS_FLAG_NOPERCPU) != 0) {\r\npercpusize = lprocfs_stats_counter_size(stats);\r\nLIBCFS_ALLOC_ATOMIC(stats->ls_percpu[0], percpusize);\r\nif (!stats->ls_percpu[0])\r\ngoto fail;\r\nstats->ls_biggest_alloc_num = 1;\r\n} else if ((flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0) {\r\nfor (i = 0; i < num_entry; ++i)\r\nif (lprocfs_stats_alloc_one(stats, i) < 0)\r\ngoto fail;\r\n}\r\nreturn stats;\r\nfail:\r\nlprocfs_free_stats(&stats);\r\nreturn NULL;\r\n}\r\nvoid lprocfs_free_stats(struct lprocfs_stats **statsh)\r\n{\r\nstruct lprocfs_stats *stats = *statsh;\r\nunsigned int num_entry;\r\nunsigned int percpusize;\r\nunsigned int i;\r\nif (!stats || stats->ls_num == 0)\r\nreturn;\r\n*statsh = NULL;\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_NOPERCPU)\r\nnum_entry = 1;\r\nelse\r\nnum_entry = num_possible_cpus();\r\npercpusize = lprocfs_stats_counter_size(stats);\r\nfor (i = 0; i < num_entry; i++)\r\nif (stats->ls_percpu[i])\r\nLIBCFS_FREE(stats->ls_percpu[i], percpusize);\r\nif (stats->ls_cnt_header)\r\nLIBCFS_FREE(stats->ls_cnt_header, stats->ls_num *\r\nsizeof(struct lprocfs_counter_header));\r\nLIBCFS_FREE(stats, offsetof(typeof(*stats), ls_percpu[num_entry]));\r\n}\r\nvoid lprocfs_clear_stats(struct lprocfs_stats *stats)\r\n{\r\nstruct lprocfs_counter *percpu_cntr;\r\nint i;\r\nint j;\r\nunsigned int num_entry;\r\nunsigned long flags = 0;\r\nnum_entry = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_entry; i++) {\r\nif (!stats->ls_percpu[i])\r\ncontinue;\r\nfor (j = 0; j < stats->ls_num; j++) {\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, j);\r\npercpu_cntr->lc_count = 0;\r\npercpu_cntr->lc_min = LC_MIN_INIT;\r\npercpu_cntr->lc_max = 0;\r\npercpu_cntr->lc_sumsquare = 0;\r\npercpu_cntr->lc_sum = 0;\r\nif (stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE)\r\npercpu_cntr->lc_sum_irq = 0;\r\n}\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nstatic ssize_t lprocfs_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct lprocfs_stats *stats = seq->private;\r\nlprocfs_clear_stats(stats);\r\nreturn len;\r\n}\r\nstatic void *lprocfs_stats_seq_start(struct seq_file *p, loff_t *pos)\r\n{\r\nstruct lprocfs_stats *stats = p->private;\r\nreturn (*pos < stats->ls_num) ? pos : NULL;\r\n}\r\nstatic void lprocfs_stats_seq_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nstatic void *lprocfs_stats_seq_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn lprocfs_stats_seq_start(p, pos);\r\n}\r\nstatic int lprocfs_stats_seq_show(struct seq_file *p, void *v)\r\n{\r\nstruct lprocfs_stats *stats = p->private;\r\nstruct lprocfs_counter_header *hdr;\r\nstruct lprocfs_counter ctr;\r\nint idx = *(loff_t *)v;\r\nif (idx == 0) {\r\nstruct timespec64 now;\r\nktime_get_real_ts64(&now);\r\nseq_printf(p, "%-25s %llu.%9lu secs.usecs\n",\r\n"snapshot_time",\r\n(s64)now.tv_sec, (unsigned long)now.tv_nsec);\r\n}\r\nhdr = &stats->ls_cnt_header[idx];\r\nlprocfs_stats_collect(stats, idx, &ctr);\r\nif (ctr.lc_count != 0) {\r\nseq_printf(p, "%-25s %lld samples [%s]",\r\nhdr->lc_name, ctr.lc_count, hdr->lc_units);\r\nif ((hdr->lc_config & LPROCFS_CNTR_AVGMINMAX) &&\r\n(ctr.lc_count > 0)) {\r\nseq_printf(p, " %lld %lld %lld",\r\nctr.lc_min, ctr.lc_max, ctr.lc_sum);\r\nif (hdr->lc_config & LPROCFS_CNTR_STDDEV)\r\nseq_printf(p, " %lld", ctr.lc_sumsquare);\r\n}\r\nseq_putc(p, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int lprocfs_stats_seq_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint rc;\r\nrc = seq_open(file, &lprocfs_stats_seq_sops);\r\nif (rc)\r\nreturn rc;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nint ldebugfs_register_stats(struct dentry *parent, const char *name,\r\nstruct lprocfs_stats *stats)\r\n{\r\nstruct dentry *entry;\r\nLASSERT(!IS_ERR_OR_NULL(parent));\r\nentry = debugfs_create_file(name, 0644, parent, stats,\r\n&lprocfs_stats_seq_fops);\r\nif (IS_ERR_OR_NULL(entry))\r\nreturn entry ? PTR_ERR(entry) : -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid lprocfs_counter_init(struct lprocfs_stats *stats, int index,\r\nunsigned int conf, const char *name,\r\nconst char *units)\r\n{\r\nstruct lprocfs_counter_header *header;\r\nstruct lprocfs_counter *percpu_cntr;\r\nunsigned long flags = 0;\r\nunsigned int i;\r\nunsigned int num_cpu;\r\nheader = &stats->ls_cnt_header[index];\r\nLASSERTF(header, "Failed to allocate stats header:[%d]%s/%s\n",\r\nindex, name, units);\r\nheader->lc_config = conf;\r\nheader->lc_name = name;\r\nheader->lc_units = units;\r\nnum_cpu = lprocfs_stats_lock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\nfor (i = 0; i < num_cpu; ++i) {\r\nif (!stats->ls_percpu[i])\r\ncontinue;\r\npercpu_cntr = lprocfs_stats_counter_get(stats, i, index);\r\npercpu_cntr->lc_count = 0;\r\npercpu_cntr->lc_min = LC_MIN_INIT;\r\npercpu_cntr->lc_max = 0;\r\npercpu_cntr->lc_sumsquare = 0;\r\npercpu_cntr->lc_sum = 0;\r\nif ((stats->ls_flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)\r\npercpu_cntr->lc_sum_irq = 0;\r\n}\r\nlprocfs_stats_unlock(stats, LPROCFS_GET_NUM_CPU, &flags);\r\n}\r\nint lprocfs_exp_cleanup(struct obd_export *exp)\r\n{\r\nreturn 0;\r\n}\r\n__s64 lprocfs_read_helper(struct lprocfs_counter *lc,\r\nstruct lprocfs_counter_header *header,\r\nenum lprocfs_stats_flags flags,\r\nenum lprocfs_fields_flags field)\r\n{\r\n__s64 ret = 0;\r\nif (!lc || !header)\r\nreturn 0;\r\nswitch (field) {\r\ncase LPROCFS_FIELDS_FLAGS_CONFIG:\r\nret = header->lc_config;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_SUM:\r\nret = lc->lc_sum;\r\nif ((flags & LPROCFS_STATS_FLAG_IRQ_SAFE) != 0)\r\nret += lc->lc_sum_irq;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_MIN:\r\nret = lc->lc_min;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_MAX:\r\nret = lc->lc_max;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_AVG:\r\nret = (lc->lc_max - lc->lc_min) / 2;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_SUMSQUARE:\r\nret = lc->lc_sumsquare;\r\nbreak;\r\ncase LPROCFS_FIELDS_FLAGS_COUNT:\r\nret = lc->lc_count;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint lprocfs_write_helper(const char __user *buffer, unsigned long count,\r\nint *val)\r\n{\r\nreturn lprocfs_write_frac_helper(buffer, count, val, 1);\r\n}\r\nint lprocfs_write_u64_helper(const char __user *buffer, unsigned long count,\r\n__u64 *val)\r\n{\r\nreturn lprocfs_write_frac_u64_helper(buffer, count, val, 1);\r\n}\r\nint lprocfs_write_frac_u64_helper(const char __user *buffer,\r\nunsigned long count, __u64 *val, int mult)\r\n{\r\nchar kernbuf[22], *end, *pbuf;\r\n__u64 whole, frac = 0, units;\r\nunsigned frac_d = 1;\r\nint sign = 1;\r\nif (count > (sizeof(kernbuf) - 1))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = '\0';\r\npbuf = kernbuf;\r\nif (*pbuf == '-') {\r\nsign = -1;\r\npbuf++;\r\n}\r\nwhole = simple_strtoull(pbuf, &end, 10);\r\nif (pbuf == end)\r\nreturn -EINVAL;\r\nif (*end == '.') {\r\nint i;\r\npbuf = end + 1;\r\nif (strlen(pbuf) > 10)\r\npbuf[10] = '\0';\r\nfrac = simple_strtoull(pbuf, &end, 10);\r\nfor (i = 0; i < (end - pbuf); i++)\r\nfrac_d *= 10;\r\n}\r\nunits = 1;\r\nif (end) {\r\nswitch (tolower(*end)) {\r\ncase 'p':\r\nunits <<= 10;\r\ncase 't':\r\nunits <<= 10;\r\ncase 'g':\r\nunits <<= 10;\r\ncase 'm':\r\nunits <<= 10;\r\ncase 'k':\r\nunits <<= 10;\r\n}\r\n}\r\nif (units > 1)\r\nmult = units;\r\nfrac *= mult;\r\ndo_div(frac, frac_d);\r\n*val = sign * (whole * mult + frac);\r\nreturn 0;\r\n}\r\nstatic char *lprocfs_strnstr(const char *s1, const char *s2, size_t len)\r\n{\r\nsize_t l2;\r\nl2 = strlen(s2);\r\nif (!l2)\r\nreturn (char *)s1;\r\nwhile (len >= l2) {\r\nlen--;\r\nif (!memcmp(s1, s2, l2))\r\nreturn (char *)s1;\r\ns1++;\r\n}\r\nreturn NULL;\r\n}\r\nchar *lprocfs_find_named_value(const char *buffer, const char *name,\r\nsize_t *count)\r\n{\r\nchar *val;\r\nsize_t buflen = *count;\r\nval = lprocfs_strnstr(buffer, name, buflen);\r\nif (!val)\r\nreturn (char *)buffer;\r\nval += strlen(name);\r\nwhile (val < buffer + buflen && isspace(*val))\r\nval++;\r\n*count = 0;\r\nwhile (val < buffer + buflen && isalnum(*val)) {\r\n++*count;\r\n++val;\r\n}\r\nreturn val - *count;\r\n}\r\nint ldebugfs_seq_create(struct dentry *parent, const char *name,\r\numode_t mode, const struct file_operations *seq_fops,\r\nvoid *data)\r\n{\r\nstruct dentry *entry;\r\nLASSERT((seq_fops->write == NULL) == ((mode & 0222) == 0));\r\nentry = debugfs_create_file(name, mode, parent, data, seq_fops);\r\nif (IS_ERR_OR_NULL(entry))\r\nreturn entry ? PTR_ERR(entry) : -ENOMEM;\r\nreturn 0;\r\n}\r\nint ldebugfs_obd_seq_create(struct obd_device *dev,\r\nconst char *name,\r\numode_t mode,\r\nconst struct file_operations *seq_fops,\r\nvoid *data)\r\n{\r\nreturn ldebugfs_seq_create(dev->obd_debugfs_entry, name,\r\nmode, seq_fops, data);\r\n}\r\nvoid lprocfs_oh_tally(struct obd_histogram *oh, unsigned int value)\r\n{\r\nif (value >= OBD_HIST_MAX)\r\nvalue = OBD_HIST_MAX - 1;\r\nspin_lock(&oh->oh_lock);\r\noh->oh_buckets[value]++;\r\nspin_unlock(&oh->oh_lock);\r\n}\r\nvoid lprocfs_oh_tally_log2(struct obd_histogram *oh, unsigned int value)\r\n{\r\nunsigned int val = 0;\r\nif (likely(value != 0))\r\nval = min(fls(value - 1), OBD_HIST_MAX);\r\nlprocfs_oh_tally(oh, val);\r\n}\r\nunsigned long lprocfs_oh_sum(struct obd_histogram *oh)\r\n{\r\nunsigned long ret = 0;\r\nint i;\r\nfor (i = 0; i < OBD_HIST_MAX; i++)\r\nret += oh->oh_buckets[i];\r\nreturn ret;\r\n}\r\nvoid lprocfs_oh_clear(struct obd_histogram *oh)\r\n{\r\nspin_lock(&oh->oh_lock);\r\nmemset(oh->oh_buckets, 0, sizeof(oh->oh_buckets));\r\nspin_unlock(&oh->oh_lock);\r\n}\r\nint lprocfs_wr_root_squash(const char __user *buffer, unsigned long count,\r\nstruct root_squash_info *squash, char *name)\r\n{\r\nchar kernbuf[64], *tmp, *errmsg;\r\nunsigned long uid, gid;\r\nint rc;\r\nif (count >= sizeof(kernbuf)) {\r\nerrmsg = "string too long";\r\nrc = -EINVAL;\r\ngoto failed_noprint;\r\n}\r\nif (copy_from_user(kernbuf, buffer, count)) {\r\nerrmsg = "bad address";\r\nrc = -EFAULT;\r\ngoto failed_noprint;\r\n}\r\nkernbuf[count] = '\0';\r\ntmp = strchr(kernbuf, ':');\r\nif (!tmp) {\r\nerrmsg = "needs uid:gid format";\r\nrc = -EINVAL;\r\ngoto failed;\r\n}\r\n*tmp = '\0';\r\ntmp++;\r\nif (kstrtoul(kernbuf, 0, &uid) != 0) {\r\nerrmsg = "bad uid";\r\nrc = -EINVAL;\r\ngoto failed;\r\n}\r\nif (kstrtoul(tmp, 0, &gid) != 0) {\r\nerrmsg = "bad gid";\r\nrc = -EINVAL;\r\ngoto failed;\r\n}\r\nsquash->rsi_uid = uid;\r\nsquash->rsi_gid = gid;\r\nLCONSOLE_INFO("%s: root_squash is set to %u:%u\n",\r\nname, squash->rsi_uid, squash->rsi_gid);\r\nreturn count;\r\nfailed:\r\nif (tmp) {\r\ntmp--;\r\n*tmp = ':';\r\n}\r\nCWARN("%s: failed to set root_squash to \"%s\", %s, rc = %d\n",\r\nname, kernbuf, errmsg, rc);\r\nreturn rc;\r\nfailed_noprint:\r\nCWARN("%s: failed to set root_squash due to %s, rc = %d\n",\r\nname, errmsg, rc);\r\nreturn rc;\r\n}\r\nint lprocfs_wr_nosquash_nids(const char __user *buffer, unsigned long count,\r\nstruct root_squash_info *squash, char *name)\r\n{\r\nchar *kernbuf = NULL, *errmsg;\r\nstruct list_head tmp;\r\nint len = count;\r\nint rc;\r\nif (count > 4096) {\r\nerrmsg = "string too long";\r\nrc = -EINVAL;\r\ngoto failed;\r\n}\r\nkernbuf = kzalloc(count + 1, GFP_NOFS);\r\nif (!kernbuf) {\r\nerrmsg = "no memory";\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nif (copy_from_user(kernbuf, buffer, count)) {\r\nerrmsg = "bad address";\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nkernbuf[count] = '\0';\r\nif (count > 0 && kernbuf[count - 1] == '\n')\r\nlen = count - 1;\r\nif ((len == 4 && !strncmp(kernbuf, "NONE", len)) ||\r\n(len == 5 && !strncmp(kernbuf, "clear", len))) {\r\ndown_write(&squash->rsi_sem);\r\nif (!list_empty(&squash->rsi_nosquash_nids))\r\ncfs_free_nidlist(&squash->rsi_nosquash_nids);\r\nup_write(&squash->rsi_sem);\r\nLCONSOLE_INFO("%s: nosquash_nids is cleared\n", name);\r\nkfree(kernbuf);\r\nreturn count;\r\n}\r\nINIT_LIST_HEAD(&tmp);\r\nif (cfs_parse_nidlist(kernbuf, count, &tmp) <= 0) {\r\nerrmsg = "can't parse";\r\nrc = -EINVAL;\r\ngoto failed;\r\n}\r\nLCONSOLE_INFO("%s: nosquash_nids set to %s\n",\r\nname, kernbuf);\r\nkfree(kernbuf);\r\nkernbuf = NULL;\r\ndown_write(&squash->rsi_sem);\r\nif (!list_empty(&squash->rsi_nosquash_nids))\r\ncfs_free_nidlist(&squash->rsi_nosquash_nids);\r\nlist_splice(&tmp, &squash->rsi_nosquash_nids);\r\nup_write(&squash->rsi_sem);\r\nreturn count;\r\nfailed:\r\nif (kernbuf) {\r\nCWARN("%s: failed to set nosquash_nids to \"%s\", %s rc = %d\n",\r\nname, kernbuf, errmsg, rc);\r\nkfree(kernbuf);\r\nkernbuf = NULL;\r\n} else {\r\nCWARN("%s: failed to set nosquash_nids due to %s rc = %d\n",\r\nname, errmsg, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t lustre_attr_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct lustre_attr *a = container_of(attr, struct lustre_attr, attr);\r\nreturn a->show ? a->show(kobj, attr, buf) : 0;\r\n}\r\nstatic ssize_t lustre_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct lustre_attr *a = container_of(attr, struct lustre_attr, attr);\r\nreturn a->store ? a->store(kobj, attr, buf, len) : len;\r\n}
