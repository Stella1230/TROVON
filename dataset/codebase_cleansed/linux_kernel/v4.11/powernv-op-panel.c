static loff_t oppanel_llseek(struct file *filp, loff_t offset, int whence)\r\n{\r\nreturn fixed_size_llseek(filp, offset, whence, oppanel_size);\r\n}\r\nstatic ssize_t oppanel_read(struct file *filp, char __user *userbuf, size_t len,\r\nloff_t *f_pos)\r\n{\r\nreturn simple_read_from_buffer(userbuf, len, f_pos, oppanel_data,\r\noppanel_size);\r\n}\r\nstatic int __op_panel_update_display(void)\r\n{\r\nstruct opal_msg msg;\r\nint rc, token;\r\ntoken = opal_async_get_token_interruptible();\r\nif (token < 0) {\r\nif (token != -ERESTARTSYS)\r\npr_debug("Couldn't get OPAL async token [token=%d]\n",\r\ntoken);\r\nreturn token;\r\n}\r\nrc = opal_write_oppanel_async(token, oppanel_lines, num_lines);\r\nswitch (rc) {\r\ncase OPAL_ASYNC_COMPLETION:\r\nrc = opal_async_wait_response(token, &msg);\r\nif (rc) {\r\npr_debug("Failed to wait for async response [rc=%d]\n",\r\nrc);\r\nbreak;\r\n}\r\nrc = opal_get_async_rc(msg);\r\nif (rc != OPAL_SUCCESS) {\r\npr_debug("OPAL async call returned failed [rc=%d]\n",\r\nrc);\r\nbreak;\r\n}\r\ncase OPAL_SUCCESS:\r\nbreak;\r\ndefault:\r\npr_debug("OPAL write op-panel call failed [rc=%d]\n", rc);\r\n}\r\nopal_async_release_token(token);\r\nreturn rc;\r\n}\r\nstatic ssize_t oppanel_write(struct file *filp, const char __user *userbuf,\r\nsize_t len, loff_t *f_pos)\r\n{\r\nloff_t f_pos_prev = *f_pos;\r\nssize_t ret;\r\nint rc;\r\nif (!*f_pos)\r\nmemset(oppanel_data, ' ', oppanel_size);\r\nelse if (*f_pos >= oppanel_size)\r\nreturn -EFBIG;\r\nret = simple_write_to_buffer(oppanel_data, oppanel_size, f_pos, userbuf,\r\nlen);\r\nif (ret > 0) {\r\nrc = __op_panel_update_display();\r\nif (rc != OPAL_SUCCESS) {\r\npr_err_ratelimited("OPAL call failed to write to op panel display [rc=%d]\n",\r\nrc);\r\n*f_pos = f_pos_prev;\r\nreturn -EIO;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int oppanel_open(struct inode *inode, struct file *filp)\r\n{\r\nif (!mutex_trylock(&oppanel_mutex)) {\r\npr_debug("Device Busy\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int oppanel_release(struct inode *inode, struct file *filp)\r\n{\r\nmutex_unlock(&oppanel_mutex);\r\nreturn 0;\r\n}\r\nstatic int oppanel_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 line_len;\r\nint rc, i;\r\nrc = of_property_read_u32(np, "#length", &line_len);\r\nif (rc) {\r\npr_err_ratelimited("Operator panel length property not found\n");\r\nreturn rc;\r\n}\r\nrc = of_property_read_u32(np, "#lines", &num_lines);\r\nif (rc) {\r\npr_err_ratelimited("Operator panel lines property not found\n");\r\nreturn rc;\r\n}\r\noppanel_size = line_len * num_lines;\r\npr_devel("Operator panel of size %u found with %u lines of length %u\n",\r\noppanel_size, num_lines, line_len);\r\noppanel_data = kcalloc(oppanel_size, sizeof(*oppanel_data), GFP_KERNEL);\r\nif (!oppanel_data)\r\nreturn -ENOMEM;\r\noppanel_lines = kcalloc(num_lines, sizeof(oppanel_line_t), GFP_KERNEL);\r\nif (!oppanel_lines) {\r\nrc = -ENOMEM;\r\ngoto free_oppanel_data;\r\n}\r\nmemset(oppanel_data, ' ', oppanel_size);\r\nfor (i = 0; i < num_lines; i++) {\r\noppanel_lines[i].line_len = cpu_to_be64(line_len);\r\noppanel_lines[i].line = cpu_to_be64(__pa(&oppanel_data[i *\r\nline_len]));\r\n}\r\nrc = misc_register(&oppanel_dev);\r\nif (rc) {\r\npr_err_ratelimited("Failed to register as misc device\n");\r\ngoto free_oppanel;\r\n}\r\nreturn 0;\r\nfree_oppanel:\r\nkfree(oppanel_lines);\r\nfree_oppanel_data:\r\nkfree(oppanel_data);\r\nreturn rc;\r\n}\r\nstatic int oppanel_remove(struct platform_device *pdev)\r\n{\r\nmisc_deregister(&oppanel_dev);\r\nkfree(oppanel_lines);\r\nkfree(oppanel_data);\r\nreturn 0;\r\n}
