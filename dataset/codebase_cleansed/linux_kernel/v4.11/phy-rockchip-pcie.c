static inline void phy_wr_cfg(struct rockchip_pcie_phy *rk_phy,\r\nu32 addr, u32 data)\r\n{\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(data,\r\nPHY_CFG_DATA_MASK,\r\nPHY_CFG_DATA_SHIFT) |\r\nHIWORD_UPDATE(addr,\r\nPHY_CFG_ADDR_MASK,\r\nPHY_CFG_ADDR_SHIFT));\r\nudelay(1);\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(PHY_CFG_WR_ENABLE,\r\nPHY_CFG_WR_MASK,\r\nPHY_CFG_WR_SHIFT));\r\nudelay(1);\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(PHY_CFG_WR_DISABLE,\r\nPHY_CFG_WR_MASK,\r\nPHY_CFG_WR_SHIFT));\r\n}\r\nstatic inline u32 phy_rd_cfg(struct rockchip_pcie_phy *rk_phy,\r\nu32 addr)\r\n{\r\nu32 val;\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(addr,\r\nPHY_CFG_RD_MASK,\r\nPHY_CFG_ADDR_SHIFT));\r\nregmap_read(rk_phy->reg_base,\r\nrk_phy->phy_data->pcie_status,\r\n&val);\r\nreturn val;\r\n}\r\nstatic int rockchip_pcie_phy_power_off(struct phy *phy)\r\n{\r\nstruct rockchip_pcie_phy *rk_phy = phy_get_drvdata(phy);\r\nint err = 0;\r\nerr = reset_control_assert(rk_phy->phy_rst);\r\nif (err) {\r\ndev_err(&phy->dev, "assert phy_rst err %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_pcie_phy_power_on(struct phy *phy)\r\n{\r\nstruct rockchip_pcie_phy *rk_phy = phy_get_drvdata(phy);\r\nint err = 0;\r\nu32 status;\r\nunsigned long timeout;\r\nerr = reset_control_deassert(rk_phy->phy_rst);\r\nif (err) {\r\ndev_err(&phy->dev, "deassert phy_rst err %d\n", err);\r\nreturn err;\r\n}\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(PHY_CFG_PLL_LOCK,\r\nPHY_CFG_ADDR_MASK,\r\nPHY_CFG_ADDR_SHIFT));\r\ntimeout = jiffies + msecs_to_jiffies(1000);\r\nerr = -EINVAL;\r\nwhile (time_before(jiffies, timeout)) {\r\nregmap_read(rk_phy->reg_base,\r\nrk_phy->phy_data->pcie_status,\r\n&status);\r\nif (status & PHY_PLL_LOCKED) {\r\ndev_dbg(&phy->dev, "pll locked!\n");\r\nerr = 0;\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nif (err) {\r\ndev_err(&phy->dev, "pll lock timeout!\n");\r\ngoto err_pll_lock;\r\n}\r\nphy_wr_cfg(rk_phy, PHY_CFG_CLK_TEST, PHY_CFG_SEPE_RATE);\r\nphy_wr_cfg(rk_phy, PHY_CFG_CLK_SCC, PHY_CFG_PLL_100M);\r\nerr = -ETIMEDOUT;\r\nwhile (time_before(jiffies, timeout)) {\r\nregmap_read(rk_phy->reg_base,\r\nrk_phy->phy_data->pcie_status,\r\n&status);\r\nif (!(status & PHY_PLL_OUTPUT)) {\r\ndev_dbg(&phy->dev, "pll output enable done!\n");\r\nerr = 0;\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nif (err) {\r\ndev_err(&phy->dev, "pll output enable timeout!\n");\r\ngoto err_pll_lock;\r\n}\r\nregmap_write(rk_phy->reg_base, rk_phy->phy_data->pcie_conf,\r\nHIWORD_UPDATE(PHY_CFG_PLL_LOCK,\r\nPHY_CFG_ADDR_MASK,\r\nPHY_CFG_ADDR_SHIFT));\r\nerr = -EINVAL;\r\nwhile (time_before(jiffies, timeout)) {\r\nregmap_read(rk_phy->reg_base,\r\nrk_phy->phy_data->pcie_status,\r\n&status);\r\nif (status & PHY_PLL_LOCKED) {\r\ndev_dbg(&phy->dev, "pll relocked!\n");\r\nerr = 0;\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nif (err) {\r\ndev_err(&phy->dev, "pll relock timeout!\n");\r\ngoto err_pll_lock;\r\n}\r\nreturn 0;\r\nerr_pll_lock:\r\nreset_control_assert(rk_phy->phy_rst);\r\nreturn err;\r\n}\r\nstatic int rockchip_pcie_phy_init(struct phy *phy)\r\n{\r\nstruct rockchip_pcie_phy *rk_phy = phy_get_drvdata(phy);\r\nint err = 0;\r\nerr = clk_prepare_enable(rk_phy->clk_pciephy_ref);\r\nif (err) {\r\ndev_err(&phy->dev, "Fail to enable pcie ref clock.\n");\r\ngoto err_refclk;\r\n}\r\nerr = reset_control_assert(rk_phy->phy_rst);\r\nif (err) {\r\ndev_err(&phy->dev, "assert phy_rst err %d\n", err);\r\ngoto err_reset;\r\n}\r\nreturn err;\r\nerr_reset:\r\nclk_disable_unprepare(rk_phy->clk_pciephy_ref);\r\nerr_refclk:\r\nreturn err;\r\n}\r\nstatic int rockchip_pcie_phy_exit(struct phy *phy)\r\n{\r\nstruct rockchip_pcie_phy *rk_phy = phy_get_drvdata(phy);\r\nclk_disable_unprepare(rk_phy->clk_pciephy_ref);\r\nreturn 0;\r\n}\r\nstatic int rockchip_pcie_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rockchip_pcie_phy *rk_phy;\r\nstruct phy *generic_phy;\r\nstruct phy_provider *phy_provider;\r\nstruct regmap *grf;\r\nconst struct of_device_id *of_id;\r\ngrf = syscon_node_to_regmap(dev->parent->of_node);\r\nif (IS_ERR(grf)) {\r\ndev_err(dev, "Cannot find GRF syscon\n");\r\nreturn PTR_ERR(grf);\r\n}\r\nrk_phy = devm_kzalloc(dev, sizeof(*rk_phy), GFP_KERNEL);\r\nif (!rk_phy)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(rockchip_pcie_phy_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nrk_phy->phy_data = (struct rockchip_pcie_data *)of_id->data;\r\nrk_phy->reg_base = grf;\r\nrk_phy->phy_rst = devm_reset_control_get(dev, "phy");\r\nif (IS_ERR(rk_phy->phy_rst)) {\r\nif (PTR_ERR(rk_phy->phy_rst) != -EPROBE_DEFER)\r\ndev_err(dev,\r\n"missing phy property for reset controller\n");\r\nreturn PTR_ERR(rk_phy->phy_rst);\r\n}\r\nrk_phy->clk_pciephy_ref = devm_clk_get(dev, "refclk");\r\nif (IS_ERR(rk_phy->clk_pciephy_ref)) {\r\ndev_err(dev, "refclk not found.\n");\r\nreturn PTR_ERR(rk_phy->clk_pciephy_ref);\r\n}\r\ngeneric_phy = devm_phy_create(dev, dev->of_node, &ops);\r\nif (IS_ERR(generic_phy)) {\r\ndev_err(dev, "failed to create PHY\n");\r\nreturn PTR_ERR(generic_phy);\r\n}\r\nphy_set_drvdata(generic_phy, rk_phy);\r\nphy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
