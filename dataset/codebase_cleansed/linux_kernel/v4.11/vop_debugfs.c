static int vop_dp_show(struct seq_file *s, void *pos)\r\n{\r\nstruct mic_device_desc *d;\r\nstruct mic_device_ctrl *dc;\r\nstruct mic_vqconfig *vqconfig;\r\n__u32 *features;\r\n__u8 *config;\r\nstruct vop_info *vi = s->private;\r\nstruct vop_device *vpdev = vi->vpdev;\r\nstruct mic_bootparam *bootparam = vpdev->hw_ops->get_dp(vpdev);\r\nint j, k;\r\nseq_printf(s, "Bootparam: magic 0x%x\n",\r\nbootparam->magic);\r\nseq_printf(s, "Bootparam: h2c_config_db %d\n",\r\nbootparam->h2c_config_db);\r\nseq_printf(s, "Bootparam: node_id %d\n",\r\nbootparam->node_id);\r\nseq_printf(s, "Bootparam: c2h_scif_db %d\n",\r\nbootparam->c2h_scif_db);\r\nseq_printf(s, "Bootparam: h2c_scif_db %d\n",\r\nbootparam->h2c_scif_db);\r\nseq_printf(s, "Bootparam: scif_host_dma_addr 0x%llx\n",\r\nbootparam->scif_host_dma_addr);\r\nseq_printf(s, "Bootparam: scif_card_dma_addr 0x%llx\n",\r\nbootparam->scif_card_dma_addr);\r\nfor (j = sizeof(*bootparam);\r\nj < MIC_DP_SIZE; j += mic_total_desc_size(d)) {\r\nd = (void *)bootparam + j;\r\ndc = (void *)d + mic_aligned_desc_size(d);\r\nif (d->type == 0)\r\nbreak;\r\nif (d->type == -1)\r\ncontinue;\r\nseq_printf(s, "Type %d ", d->type);\r\nseq_printf(s, "Num VQ %d ", d->num_vq);\r\nseq_printf(s, "Feature Len %d\n", d->feature_len);\r\nseq_printf(s, "Config Len %d ", d->config_len);\r\nseq_printf(s, "Shutdown Status %d\n", d->status);\r\nfor (k = 0; k < d->num_vq; k++) {\r\nvqconfig = mic_vq_config(d) + k;\r\nseq_printf(s, "vqconfig[%d]: ", k);\r\nseq_printf(s, "address 0x%llx ",\r\nvqconfig->address);\r\nseq_printf(s, "num %d ", vqconfig->num);\r\nseq_printf(s, "used address 0x%llx\n",\r\nvqconfig->used_address);\r\n}\r\nfeatures = (__u32 *)mic_vq_features(d);\r\nseq_printf(s, "Features: Host 0x%x ", features[0]);\r\nseq_printf(s, "Guest 0x%x\n", features[1]);\r\nconfig = mic_vq_configspace(d);\r\nfor (k = 0; k < d->config_len; k++)\r\nseq_printf(s, "config[%d]=%d\n", k, config[k]);\r\nseq_puts(s, "Device control:\n");\r\nseq_printf(s, "Config Change %d ", dc->config_change);\r\nseq_printf(s, "Vdev reset %d\n", dc->vdev_reset);\r\nseq_printf(s, "Guest Ack %d ", dc->guest_ack);\r\nseq_printf(s, "Host ack %d\n", dc->host_ack);\r\nseq_printf(s, "Used address updated %d ",\r\ndc->used_address_updated);\r\nseq_printf(s, "Vdev 0x%llx\n", dc->vdev);\r\nseq_printf(s, "c2h doorbell %d ", dc->c2h_vdev_db);\r\nseq_printf(s, "h2c doorbell %d\n", dc->h2c_vdev_db);\r\n}\r\nschedule_work(&vi->hotplug_work);\r\nreturn 0;\r\n}\r\nstatic int vop_dp_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vop_dp_show, inode->i_private);\r\n}\r\nstatic int vop_dp_debug_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nstatic int vop_vdev_info_show(struct seq_file *s, void *unused)\r\n{\r\nstruct vop_info *vi = s->private;\r\nstruct list_head *pos, *tmp;\r\nstruct vop_vdev *vdev;\r\nint i, j;\r\nmutex_lock(&vi->vop_mutex);\r\nlist_for_each_safe(pos, tmp, &vi->vdev_list) {\r\nvdev = list_entry(pos, struct vop_vdev, list);\r\nseq_printf(s, "VDEV type %d state %s in %ld out %ld in_dma %ld out_dma %ld\n",\r\nvdev->virtio_id,\r\nvop_vdevup(vdev) ? "UP" : "DOWN",\r\nvdev->in_bytes,\r\nvdev->out_bytes,\r\nvdev->in_bytes_dma,\r\nvdev->out_bytes_dma);\r\nfor (i = 0; i < MIC_MAX_VRINGS; i++) {\r\nstruct vring_desc *desc;\r\nstruct vring_avail *avail;\r\nstruct vring_used *used;\r\nstruct vop_vringh *vvr = &vdev->vvr[i];\r\nstruct vringh *vrh = &vvr->vrh;\r\nint num = vrh->vring.num;\r\nif (!num)\r\ncontinue;\r\ndesc = vrh->vring.desc;\r\nseq_printf(s, "vring i %d avail_idx %d",\r\ni, vvr->vring.info->avail_idx & (num - 1));\r\nseq_printf(s, " vring i %d avail_idx %d\n",\r\ni, vvr->vring.info->avail_idx);\r\nseq_printf(s, "vrh i %d weak_barriers %d",\r\ni, vrh->weak_barriers);\r\nseq_printf(s, " last_avail_idx %d last_used_idx %d",\r\nvrh->last_avail_idx, vrh->last_used_idx);\r\nseq_printf(s, " completed %d\n", vrh->completed);\r\nfor (j = 0; j < num; j++) {\r\nseq_printf(s, "desc[%d] addr 0x%llx len %d",\r\nj, desc->addr, desc->len);\r\nseq_printf(s, " flags 0x%x next %d\n",\r\ndesc->flags, desc->next);\r\ndesc++;\r\n}\r\navail = vrh->vring.avail;\r\nseq_printf(s, "avail flags 0x%x idx %d\n",\r\nvringh16_to_cpu(vrh, avail->flags),\r\nvringh16_to_cpu(vrh,\r\navail->idx) & (num - 1));\r\nseq_printf(s, "avail flags 0x%x idx %d\n",\r\nvringh16_to_cpu(vrh, avail->flags),\r\nvringh16_to_cpu(vrh, avail->idx));\r\nfor (j = 0; j < num; j++)\r\nseq_printf(s, "avail ring[%d] %d\n",\r\nj, avail->ring[j]);\r\nused = vrh->vring.used;\r\nseq_printf(s, "used flags 0x%x idx %d\n",\r\nvringh16_to_cpu(vrh, used->flags),\r\nvringh16_to_cpu(vrh, used->idx) & (num - 1));\r\nseq_printf(s, "used flags 0x%x idx %d\n",\r\nvringh16_to_cpu(vrh, used->flags),\r\nvringh16_to_cpu(vrh, used->idx));\r\nfor (j = 0; j < num; j++)\r\nseq_printf(s, "used ring[%d] id %d len %d\n",\r\nj, vringh32_to_cpu(vrh,\r\nused->ring[j].id),\r\nvringh32_to_cpu(vrh,\r\nused->ring[j].len));\r\n}\r\n}\r\nmutex_unlock(&vi->vop_mutex);\r\nreturn 0;\r\n}\r\nstatic int vop_vdev_info_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, vop_vdev_info_show, inode->i_private);\r\n}\r\nstatic int vop_vdev_info_debug_release(struct inode *inode, struct file *file)\r\n{\r\nreturn single_release(inode, file);\r\n}\r\nvoid vop_init_debugfs(struct vop_info *vi)\r\n{\r\nchar name[16];\r\nsnprintf(name, sizeof(name), "%s%d", KBUILD_MODNAME, vi->vpdev->dnode);\r\nvi->dbg = debugfs_create_dir(name, NULL);\r\nif (!vi->dbg) {\r\npr_err("can't create debugfs dir vop\n");\r\nreturn;\r\n}\r\ndebugfs_create_file("dp", 0444, vi->dbg, vi, &dp_ops);\r\ndebugfs_create_file("vdev_info", 0444, vi->dbg, vi, &vdev_info_ops);\r\n}\r\nvoid vop_exit_debugfs(struct vop_info *vi)\r\n{\r\ndebugfs_remove_recursive(vi->dbg);\r\n}
