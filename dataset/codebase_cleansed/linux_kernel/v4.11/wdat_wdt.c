static int wdat_wdt_read(struct wdat_wdt *wdat,\r\nconst struct wdat_instruction *instr, u32 *value)\r\n{\r\nconst struct acpi_generic_address *gas = &instr->entry.register_region;\r\nswitch (gas->access_width) {\r\ncase 1:\r\n*value = ioread8(instr->reg);\r\nbreak;\r\ncase 2:\r\n*value = ioread16(instr->reg);\r\nbreak;\r\ncase 3:\r\n*value = ioread32(instr->reg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&wdat->pdev->dev, "Read %#x from 0x%08llx\n", *value,\r\ngas->address);\r\nreturn 0;\r\n}\r\nstatic int wdat_wdt_write(struct wdat_wdt *wdat,\r\nconst struct wdat_instruction *instr, u32 value)\r\n{\r\nconst struct acpi_generic_address *gas = &instr->entry.register_region;\r\nswitch (gas->access_width) {\r\ncase 1:\r\niowrite8((u8)value, instr->reg);\r\nbreak;\r\ncase 2:\r\niowrite16((u16)value, instr->reg);\r\nbreak;\r\ncase 3:\r\niowrite32(value, instr->reg);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&wdat->pdev->dev, "Wrote %#x to 0x%08llx\n", value,\r\ngas->address);\r\nreturn 0;\r\n}\r\nstatic int wdat_wdt_run_action(struct wdat_wdt *wdat, unsigned int action,\r\nu32 param, u32 *retval)\r\n{\r\nstruct wdat_instruction *instr;\r\nif (action >= ARRAY_SIZE(wdat->instructions))\r\nreturn -EINVAL;\r\nif (!wdat->instructions[action])\r\nreturn -EOPNOTSUPP;\r\ndev_dbg(&wdat->pdev->dev, "Running action %#x\n", action);\r\nlist_for_each_entry(instr, wdat->instructions[action], node) {\r\nconst struct acpi_wdat_entry *entry = &instr->entry;\r\nconst struct acpi_generic_address *gas;\r\nu32 flags, value, mask, x, y;\r\nbool preserve;\r\nint ret;\r\ngas = &entry->register_region;\r\npreserve = entry->instruction & ACPI_WDAT_PRESERVE_REGISTER;\r\nflags = entry->instruction & ~ACPI_WDAT_PRESERVE_REGISTER;\r\nvalue = entry->value;\r\nmask = entry->mask;\r\nswitch (flags) {\r\ncase ACPI_WDAT_READ_VALUE:\r\nret = wdat_wdt_read(wdat, instr, &x);\r\nif (ret)\r\nreturn ret;\r\nx >>= gas->bit_offset;\r\nx &= mask;\r\nif (retval)\r\n*retval = x == value;\r\nbreak;\r\ncase ACPI_WDAT_READ_COUNTDOWN:\r\nret = wdat_wdt_read(wdat, instr, &x);\r\nif (ret)\r\nreturn ret;\r\nx >>= gas->bit_offset;\r\nx &= mask;\r\nif (retval)\r\n*retval = x;\r\nbreak;\r\ncase ACPI_WDAT_WRITE_VALUE:\r\nx = value & mask;\r\nx <<= gas->bit_offset;\r\nif (preserve) {\r\nret = wdat_wdt_read(wdat, instr, &y);\r\nif (ret)\r\nreturn ret;\r\ny = y & ~(mask << gas->bit_offset);\r\nx |= y;\r\n}\r\nret = wdat_wdt_write(wdat, instr, x);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase ACPI_WDAT_WRITE_COUNTDOWN:\r\nx = param;\r\nx &= mask;\r\nx <<= gas->bit_offset;\r\nif (preserve) {\r\nret = wdat_wdt_read(wdat, instr, &y);\r\nif (ret)\r\nreturn ret;\r\ny = y & ~(mask << gas->bit_offset);\r\nx |= y;\r\n}\r\nret = wdat_wdt_write(wdat, instr, x);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ndev_err(&wdat->pdev->dev, "Unknown instruction: %u\n",\r\nflags);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wdat_wdt_enable_reboot(struct wdat_wdt *wdat)\r\n{\r\nint ret;\r\nret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_REBOOT, 0, NULL);\r\nif (ret && ret != -EOPNOTSUPP) {\r\ndev_err(&wdat->pdev->dev,\r\n"Failed to enable reboot when watchdog triggers\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wdat_wdt_boot_status(struct wdat_wdt *wdat)\r\n{\r\nu32 boot_status = 0;\r\nint ret;\r\nret = wdat_wdt_run_action(wdat, ACPI_WDAT_GET_STATUS, 0, &boot_status);\r\nif (ret && ret != -EOPNOTSUPP) {\r\ndev_err(&wdat->pdev->dev, "Failed to read boot status\n");\r\nreturn;\r\n}\r\nif (boot_status)\r\nwdat->wdd.bootstatus = WDIOF_CARDRESET;\r\nret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_STATUS, 0, NULL);\r\nif (ret && ret != -EOPNOTSUPP)\r\ndev_err(&wdat->pdev->dev, "Failed to clear boot status\n");\r\n}\r\nstatic void wdat_wdt_set_running(struct wdat_wdt *wdat)\r\n{\r\nu32 running = 0;\r\nint ret;\r\nret = wdat_wdt_run_action(wdat, ACPI_WDAT_GET_RUNNING_STATE, 0,\r\n&running);\r\nif (ret && ret != -EOPNOTSUPP)\r\ndev_err(&wdat->pdev->dev, "Failed to read running state\n");\r\nif (running)\r\nset_bit(WDOG_HW_RUNNING, &wdat->wdd.status);\r\n}\r\nstatic int wdat_wdt_start(struct watchdog_device *wdd)\r\n{\r\nreturn wdat_wdt_run_action(to_wdat_wdt(wdd),\r\nACPI_WDAT_SET_RUNNING_STATE, 0, NULL);\r\n}\r\nstatic int wdat_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nreturn wdat_wdt_run_action(to_wdat_wdt(wdd),\r\nACPI_WDAT_SET_STOPPED_STATE, 0, NULL);\r\n}\r\nstatic int wdat_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nreturn wdat_wdt_run_action(to_wdat_wdt(wdd), ACPI_WDAT_RESET, 0, NULL);\r\n}\r\nstatic int wdat_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct wdat_wdt *wdat = to_wdat_wdt(wdd);\r\nunsigned int periods;\r\nint ret;\r\nperiods = timeout * 1000 / wdat->period;\r\nret = wdat_wdt_run_action(wdat, ACPI_WDAT_SET_COUNTDOWN, periods, NULL);\r\nif (!ret)\r\nwdd->timeout = timeout;\r\nreturn ret;\r\n}\r\nstatic unsigned int wdat_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct wdat_wdt *wdat = to_wdat_wdt(wdd);\r\nu32 periods = 0;\r\nwdat_wdt_run_action(wdat, ACPI_WDAT_GET_COUNTDOWN, 0, &periods);\r\nreturn periods * wdat->period / 1000;\r\n}\r\nstatic int wdat_wdt_probe(struct platform_device *pdev)\r\n{\r\nconst struct acpi_wdat_entry *entries;\r\nconst struct acpi_table_wdat *tbl;\r\nstruct wdat_wdt *wdat;\r\nstruct resource *res;\r\nvoid __iomem **regs;\r\nacpi_status status;\r\nint i, ret;\r\nstatus = acpi_get_table(ACPI_SIG_WDAT, 0,\r\n(struct acpi_table_header **)&tbl);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nwdat = devm_kzalloc(&pdev->dev, sizeof(*wdat), GFP_KERNEL);\r\nif (!wdat)\r\nreturn -ENOMEM;\r\nregs = devm_kcalloc(&pdev->dev, pdev->num_resources, sizeof(*regs),\r\nGFP_KERNEL);\r\nif (!regs)\r\nreturn -ENOMEM;\r\nif (tbl->timer_period < 1)\r\nreturn -EINVAL;\r\nif (tbl->min_count > tbl->max_count)\r\nreturn -EINVAL;\r\nwdat->period = tbl->timer_period;\r\nwdat->wdd.min_hw_heartbeat_ms = wdat->period * tbl->min_count;\r\nwdat->wdd.max_hw_heartbeat_ms = wdat->period * tbl->max_count;\r\nwdat->stopped_in_sleep = tbl->flags & ACPI_WDAT_STOPPED;\r\nwdat->wdd.info = &wdat_wdt_info;\r\nwdat->wdd.ops = &wdat_wdt_ops;\r\nwdat->pdev = pdev;\r\nfor (i = 0; i < pdev->num_resources; i++) {\r\nvoid __iomem *reg;\r\nres = &pdev->resource[i];\r\nif (resource_type(res) == IORESOURCE_MEM) {\r\nreg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\n} else if (resource_type(res) == IORESOURCE_IO) {\r\nreg = devm_ioport_map(&pdev->dev, res->start, 1);\r\nif (!reg)\r\nreturn -ENOMEM;\r\n} else {\r\ndev_err(&pdev->dev, "Unsupported resource\n");\r\nreturn -EINVAL;\r\n}\r\nregs[i] = reg;\r\n}\r\nentries = (struct acpi_wdat_entry *)(tbl + 1);\r\nfor (i = 0; i < tbl->entries; i++) {\r\nconst struct acpi_generic_address *gas;\r\nstruct wdat_instruction *instr;\r\nstruct list_head *instructions;\r\nunsigned int action;\r\nstruct resource r;\r\nint j;\r\naction = entries[i].action;\r\nif (action >= MAX_WDAT_ACTIONS) {\r\ndev_dbg(&pdev->dev, "Skipping unknown action: %u\n",\r\naction);\r\ncontinue;\r\n}\r\ninstr = devm_kzalloc(&pdev->dev, sizeof(*instr), GFP_KERNEL);\r\nif (!instr)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&instr->node);\r\ninstr->entry = entries[i];\r\ngas = &entries[i].register_region;\r\nmemset(&r, 0, sizeof(r));\r\nr.start = gas->address;\r\nr.end = r.start + gas->access_width;\r\nif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nr.flags = IORESOURCE_MEM;\r\n} else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\r\nr.flags = IORESOURCE_IO;\r\n} else {\r\ndev_dbg(&pdev->dev, "Unsupported address space: %d\n",\r\ngas->space_id);\r\ncontinue;\r\n}\r\nfor (j = 0; j < pdev->num_resources; j++) {\r\nres = &pdev->resource[j];\r\nif (resource_contains(res, &r)) {\r\ninstr->reg = regs[j] + r.start - res->start;\r\nbreak;\r\n}\r\n}\r\nif (!instr->reg) {\r\ndev_err(&pdev->dev, "I/O resource not found\n");\r\nreturn -EINVAL;\r\n}\r\ninstructions = wdat->instructions[action];\r\nif (!instructions) {\r\ninstructions = devm_kzalloc(&pdev->dev,\r\nsizeof(*instructions), GFP_KERNEL);\r\nif (!instructions)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(instructions);\r\nwdat->instructions[action] = instructions;\r\n}\r\nlist_add_tail(&instr->node, instructions);\r\n}\r\nwdat_wdt_boot_status(wdat);\r\nwdat_wdt_set_running(wdat);\r\nret = wdat_wdt_enable_reboot(wdat);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, wdat);\r\nwatchdog_set_nowayout(&wdat->wdd, nowayout);\r\nreturn devm_watchdog_register_device(&pdev->dev, &wdat->wdd);\r\n}\r\nstatic int wdat_wdt_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct wdat_wdt *wdat = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!watchdog_active(&wdat->wdd))\r\nreturn 0;\r\nwdat->stopped = false;\r\nif (acpi_target_system_state() == ACPI_STATE_S0 ||\r\n!wdat->stopped_in_sleep) {\r\nret = wdat_wdt_stop(&wdat->wdd);\r\nif (!ret)\r\nwdat->stopped = true;\r\n} else {\r\nret = wdat_wdt_ping(&wdat->wdd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int wdat_wdt_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct wdat_wdt *wdat = platform_get_drvdata(pdev);\r\nint ret;\r\nif (!watchdog_active(&wdat->wdd))\r\nreturn 0;\r\nif (!wdat->stopped) {\r\nret = wdat_wdt_stop(&wdat->wdd);\r\nif (ret)\r\nreturn ret;\r\nret = wdat_wdt_set_timeout(&wdat->wdd, wdat->wdd.timeout);\r\nif (ret)\r\nreturn ret;\r\nret = wdat_wdt_enable_reboot(wdat);\r\nif (ret)\r\nreturn ret;\r\nret = wdat_wdt_ping(&wdat->wdd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn wdat_wdt_start(&wdat->wdd);\r\n}
