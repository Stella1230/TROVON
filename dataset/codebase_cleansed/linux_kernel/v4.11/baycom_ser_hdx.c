static inline void baycom_int_freq(struct baycom_state *bc)\r\n{\r\n#ifdef BAYCOM_DEBUG\r\nunsigned long cur_jiffies = jiffies;\r\nbc->debug_vals.cur_intcnt++;\r\nif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\r\nbc->debug_vals.last_jiffies = cur_jiffies;\r\nbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\r\nbc->debug_vals.cur_intcnt = 0;\r\nbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\r\nbc->debug_vals.cur_pllcorr = 0;\r\n}\r\n#endif\r\n}\r\nstatic inline void ser12_set_divisor(struct net_device *dev,\r\nunsigned char divisor)\r\n{\r\noutb(0x81, LCR(dev->base_addr));\r\noutb(divisor, DLL(dev->base_addr));\r\noutb(0, DLM(dev->base_addr));\r\noutb(0x01, LCR(dev->base_addr));\r\noutb(0x00, THR(dev->base_addr));\r\n}\r\nstatic inline void ser12_tx(struct net_device *dev, struct baycom_state *bc)\r\n{\r\nser12_set_divisor(dev, 12);\r\noutb(0x0e | (!!bc->modem.ser12.tx_bit), MCR(dev->base_addr));\r\nif (bc->modem.shreg <= 1)\r\nbc->modem.shreg = 0x10000 | hdlcdrv_getbits(&bc->hdrv);\r\nbc->modem.ser12.tx_bit = !(bc->modem.ser12.tx_bit ^\r\n(bc->modem.shreg & 1));\r\nbc->modem.shreg >>= 1;\r\n}\r\nstatic inline void ser12_rx(struct net_device *dev, struct baycom_state *bc)\r\n{\r\nunsigned char cur_s;\r\ncur_s = inb(MSR(dev->base_addr)) & 0x10;\r\nhdlcdrv_channelbit(&bc->hdrv, cur_s);\r\nbc->modem.ser12.dcd_shreg = (bc->modem.ser12.dcd_shreg << 1) |\r\n(cur_s != bc->modem.ser12.last_sample);\r\nbc->modem.ser12.last_sample = cur_s;\r\nif(bc->modem.ser12.dcd_shreg & 1) {\r\nif (!bc->opt_dcd) {\r\nunsigned int dcdspos, dcdsneg;\r\ndcdspos = dcdsneg = 0;\r\ndcdspos += ((bc->modem.ser12.dcd_shreg >> 1) & 1);\r\nif (!(bc->modem.ser12.dcd_shreg & 0x7ffffffe))\r\ndcdspos += 2;\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 2) & 1);\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 3) & 1);\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 4) & 1);\r\nbc->modem.ser12.dcd_sum0 += 16*dcdspos - dcdsneg;\r\n} else\r\nbc->modem.ser12.dcd_sum0--;\r\n}\r\nif(!bc->modem.ser12.dcd_time) {\r\nhdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 +\r\nbc->modem.ser12.dcd_sum1 +\r\nbc->modem.ser12.dcd_sum2) < 0);\r\nbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\r\nbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\r\nbc->modem.ser12.dcd_sum0 = 2;\r\nbc->modem.ser12.dcd_time = SER12_DCD_INTERVAL(bc);\r\n}\r\nbc->modem.ser12.dcd_time--;\r\nif (!bc->opt_dcd) {\r\nif (bc->modem.ser12.interm_sample) {\r\nser12_set_divisor(dev, 4);\r\n} else {\r\nswitch (bc->modem.ser12.dcd_shreg & 7) {\r\ncase 1:\r\nser12_set_divisor(dev, 5);\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.cur_pllcorr++;\r\n#endif\r\nbreak;\r\ncase 4:\r\nser12_set_divisor(dev, 3);\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.cur_pllcorr--;\r\n#endif\r\nbreak;\r\ndefault:\r\nser12_set_divisor(dev, 4);\r\nbreak;\r\n}\r\nbc->modem.shreg >>= 1;\r\nif (bc->modem.ser12.last_sample ==\r\nbc->modem.ser12.last_rxbit)\r\nbc->modem.shreg |= 0x10000;\r\nbc->modem.ser12.last_rxbit =\r\nbc->modem.ser12.last_sample;\r\n}\r\nif (++bc->modem.ser12.interm_sample >= 3)\r\nbc->modem.ser12.interm_sample = 0;\r\nif (bc->modem.ser12.dcd_shreg & 1) {\r\nunsigned int dcdspos, dcdsneg;\r\ndcdspos = dcdsneg = 0;\r\ndcdspos += ((bc->modem.ser12.dcd_shreg >> 1) & 1);\r\ndcdspos += (!(bc->modem.ser12.dcd_shreg & 0x7ffffffe))\r\n<< 1;\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 2) & 1);\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 3) & 1);\r\ndcdsneg += ((bc->modem.ser12.dcd_shreg >> 4) & 1);\r\nbc->modem.ser12.dcd_sum0 += 16*dcdspos - dcdsneg;\r\n}\r\n} else {\r\nif (bc->modem.ser12.interm_sample) {\r\nser12_set_divisor(dev, 6);\r\n} else {\r\nswitch (bc->modem.ser12.dcd_shreg & 3) {\r\ncase 1:\r\nser12_set_divisor(dev, 7);\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.cur_pllcorr++;\r\n#endif\r\nbreak;\r\ncase 2:\r\nser12_set_divisor(dev, 5);\r\n#ifdef BAYCOM_DEBUG\r\nbc->debug_vals.cur_pllcorr--;\r\n#endif\r\nbreak;\r\ndefault:\r\nser12_set_divisor(dev, 6);\r\nbreak;\r\n}\r\nbc->modem.shreg >>= 1;\r\nif (bc->modem.ser12.last_sample ==\r\nbc->modem.ser12.last_rxbit)\r\nbc->modem.shreg |= 0x10000;\r\nbc->modem.ser12.last_rxbit =\r\nbc->modem.ser12.last_sample;\r\n}\r\nbc->modem.ser12.interm_sample = !bc->modem.ser12.interm_sample;\r\nbc->modem.ser12.dcd_sum0 -= (bc->modem.ser12.dcd_shreg & 1);\r\n}\r\noutb(0x0d, MCR(dev->base_addr));\r\nif (bc->modem.shreg & 1) {\r\nhdlcdrv_putbits(&bc->hdrv, bc->modem.shreg >> 1);\r\nbc->modem.shreg = 0x10000;\r\n}\r\nif(!bc->modem.ser12.dcd_time) {\r\nif (bc->opt_dcd & 1)\r\nhdlcdrv_setdcd(&bc->hdrv, !((inb(MSR(dev->base_addr)) ^ bc->opt_dcd) & 0x80));\r\nelse\r\nhdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 +\r\nbc->modem.ser12.dcd_sum1 +\r\nbc->modem.ser12.dcd_sum2) < 0);\r\nbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\r\nbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\r\nbc->modem.ser12.dcd_sum0 = 2;\r\nbc->modem.ser12.dcd_time = SER12_DCD_INTERVAL(bc);\r\n}\r\nbc->modem.ser12.dcd_time--;\r\n}\r\nstatic irqreturn_t ser12_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nunsigned char iir;\r\nif (!dev || !bc || bc->hdrv.magic != HDLCDRV_MAGIC)\r\nreturn IRQ_NONE;\r\nif ((iir = inb(IIR(dev->base_addr))) & 1)\r\nreturn IRQ_NONE;\r\nbaycom_int_freq(bc);\r\ndo {\r\nswitch (iir & 6) {\r\ncase 6:\r\ninb(LSR(dev->base_addr));\r\nbreak;\r\ncase 4:\r\ninb(RBR(dev->base_addr));\r\nbreak;\r\ncase 2:\r\nif (hdlcdrv_ptt(&bc->hdrv))\r\nser12_tx(dev, bc);\r\nelse {\r\nser12_rx(dev, bc);\r\nbc->modem.arb_divider--;\r\n}\r\noutb(0x00, THR(dev->base_addr));\r\nbreak;\r\ndefault:\r\ninb(MSR(dev->base_addr));\r\nbreak;\r\n}\r\niir = inb(IIR(dev->base_addr));\r\n} while (!(iir & 1));\r\nif (bc->modem.arb_divider <= 0) {\r\nbc->modem.arb_divider = SER12_ARB_DIVIDER(bc);\r\nlocal_irq_enable();\r\nhdlcdrv_arbitrate(dev, &bc->hdrv);\r\n}\r\nlocal_irq_enable();\r\nhdlcdrv_transmitter(dev, &bc->hdrv);\r\nhdlcdrv_receiver(dev, &bc->hdrv);\r\nlocal_irq_disable();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum uart ser12_check_uart(unsigned int iobase)\r\n{\r\nunsigned char b1,b2,b3;\r\nenum uart u;\r\nenum uart uart_tab[] =\r\n{ c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A };\r\nb1 = inb(MCR(iobase));\r\noutb(b1 | 0x10, MCR(iobase));\r\nb2 = inb(MSR(iobase));\r\noutb(0x1a, MCR(iobase));\r\nb3 = inb(MSR(iobase)) & 0xf0;\r\noutb(b1, MCR(iobase));\r\noutb(b2, MSR(iobase));\r\nif (b3 != 0x90)\r\nreturn c_uart_unknown;\r\ninb(RBR(iobase));\r\ninb(RBR(iobase));\r\noutb(0x01, FCR(iobase));\r\nu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\r\nif (u == c_uart_16450) {\r\noutb(0x5a, SCR(iobase));\r\nb1 = inb(SCR(iobase));\r\noutb(0xa5, SCR(iobase));\r\nb2 = inb(SCR(iobase));\r\nif ((b1 != 0x5a) || (b2 != 0xa5))\r\nu = c_uart_8250;\r\n}\r\nreturn u;\r\n}\r\nstatic int ser12_open(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nenum uart u;\r\nif (!dev || !bc)\r\nreturn -ENXIO;\r\nif (!dev->base_addr || dev->base_addr > 0x1000-SER12_EXTENT ||\r\ndev->irq < 2 || dev->irq > 15)\r\nreturn -ENXIO;\r\nif (!request_region(dev->base_addr, SER12_EXTENT, "baycom_ser12"))\r\nreturn -EACCES;\r\nmemset(&bc->modem, 0, sizeof(bc->modem));\r\nbc->hdrv.par.bitrate = 1200;\r\nif ((u = ser12_check_uart(dev->base_addr)) == c_uart_unknown) {\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nreturn -EIO;\r\n}\r\noutb(0, FCR(dev->base_addr));\r\noutb(0x0d, MCR(dev->base_addr));\r\noutb(0, IER(dev->base_addr));\r\nif (request_irq(dev->irq, ser12_interrupt, IRQF_SHARED,\r\n"baycom_ser12", dev)) {\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nreturn -EBUSY;\r\n}\r\noutb(2, IER(dev->base_addr));\r\nser12_set_divisor(dev, bc->opt_dcd ? 6 : 4);\r\nprintk(KERN_INFO "%s: ser12 at iobase 0x%lx irq %u uart %s\n",\r\nbc_drvname, dev->base_addr, dev->irq, uart_str[u]);\r\nreturn 0;\r\n}\r\nstatic int ser12_close(struct net_device *dev)\r\n{\r\nstruct baycom_state *bc = netdev_priv(dev);\r\nif (!dev || !bc)\r\nreturn -EINVAL;\r\noutb(0, IER(dev->base_addr));\r\noutb(1, MCR(dev->base_addr));\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, SER12_EXTENT);\r\nprintk(KERN_INFO "%s: close ser12 at iobase 0x%lx irq %u\n",\r\nbc_drvname, dev->base_addr, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\r\n{\r\nif (strchr(modestr, '*'))\r\nbc->opt_dcd = 0;\r\nelse if (strchr(modestr, '+'))\r\nbc->opt_dcd = -1;\r\nelse if (strchr(modestr, '@'))\r\nbc->opt_dcd = -2;\r\nelse\r\nbc->opt_dcd = 1;\r\nreturn 0;\r\n}\r\nstatic int baycom_ioctl(struct net_device *dev, struct ifreq *ifr,\r\nstruct hdlcdrv_ioctl *hi, int cmd)\r\n{\r\nstruct baycom_state *bc;\r\nstruct baycom_ioctl bi;\r\nif (!dev)\r\nreturn -EINVAL;\r\nbc = netdev_priv(dev);\r\nBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\r\nif (cmd != SIOCDEVPRIVATE)\r\nreturn -ENOIOCTLCMD;\r\nswitch (hi->cmd) {\r\ndefault:\r\nbreak;\r\ncase HDLCDRVCTL_GETMODE:\r\nstrcpy(hi->data.modename, "ser12");\r\nif (bc->opt_dcd <= 0)\r\nstrcat(hi->data.modename, (!bc->opt_dcd) ? "*" : (bc->opt_dcd == -2) ? "@" : "+");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_SETMODE:\r\nif (netif_running(dev) || !capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nhi->data.modename[sizeof(hi->data.modename)-1] = '\0';\r\nreturn baycom_setmode(bc, hi->data.modename);\r\ncase HDLCDRVCTL_MODELIST:\r\nstrcpy(hi->data.modename, "ser12");\r\nif (copy_to_user(ifr->ifr_data, hi, sizeof(struct hdlcdrv_ioctl)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDLCDRVCTL_MODEMPARMASK:\r\nreturn HDLCDRV_PARMASK_IOBASE | HDLCDRV_PARMASK_IRQ;\r\n}\r\nif (copy_from_user(&bi, ifr->ifr_data, sizeof(bi)))\r\nreturn -EFAULT;\r\nswitch (bi.cmd) {\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n#ifdef BAYCOM_DEBUG\r\ncase BAYCOMCTL_GETDEBUG:\r\nbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\r\nbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\r\nbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\r\nbreak;\r\n#endif\r\n}\r\nif (copy_to_user(ifr->ifr_data, &bi, sizeof(bi)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int __init init_baycomserhdx(void)\r\n{\r\nint i, found = 0;\r\nchar set_hw = 1;\r\nprintk(bc_drvinfo);\r\nfor (i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev;\r\nstruct baycom_state *bc;\r\nchar ifname[IFNAMSIZ];\r\nsprintf(ifname, "bcsh%d", i);\r\nif (!mode[i])\r\nset_hw = 0;\r\nif (!set_hw)\r\niobase[i] = irq[i] = 0;\r\ndev = hdlcdrv_register(&ser12_ops,\r\nsizeof(struct baycom_state),\r\nifname, iobase[i], irq[i], 0);\r\nif (IS_ERR(dev))\r\nbreak;\r\nbc = netdev_priv(dev);\r\nif (set_hw && baycom_setmode(bc, mode[i]))\r\nset_hw = 0;\r\nfound++;\r\nbaycom_device[i] = dev;\r\n}\r\nif (!found)\r\nreturn -ENXIO;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_baycomserhdx(void)\r\n{\r\nint i;\r\nfor(i = 0; i < NR_PORTS; i++) {\r\nstruct net_device *dev = baycom_device[i];\r\nif (dev)\r\nhdlcdrv_unregister(dev);\r\n}\r\n}\r\nstatic int __init baycom_ser_hdx_setup(char *str)\r\n{\r\nstatic unsigned nr_dev;\r\nint ints[3];\r\nif (nr_dev >= NR_PORTS)\r\nreturn 0;\r\nstr = get_options(str, 3, ints);\r\nif (ints[0] < 2)\r\nreturn 0;\r\nmode[nr_dev] = str;\r\niobase[nr_dev] = ints[1];\r\nirq[nr_dev] = ints[2];\r\nnr_dev++;\r\nreturn 1;\r\n}
