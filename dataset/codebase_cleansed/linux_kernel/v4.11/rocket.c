static inline int rocket_paranoia_check(struct r_port *info,\r\nconst char *routine)\r\n{\r\n#ifdef ROCKET_PARANOIA_CHECK\r\nif (!info)\r\nreturn 1;\r\nif (info->magic != RPORT_MAGIC) {\r\nprintk(KERN_WARNING "Warning: bad magic number for rocketport "\r\n"struct in %s\n", routine);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void rp_do_receive(struct r_port *info, CHANNEL_t *cp,\r\nunsigned int ChanStatus)\r\n{\r\nunsigned int CharNStat;\r\nint ToRecv, wRecv, space;\r\nunsigned char *cbuf;\r\nToRecv = sGetRxCnt(cp);\r\n#ifdef ROCKET_DEBUG_INTR\r\nprintk(KERN_INFO "rp_do_receive(%d)...\n", ToRecv);\r\n#endif\r\nif (ToRecv == 0)\r\nreturn;\r\nif (ChanStatus & (RXFOVERFL | RXBREAK | RXFRAME | RXPARITY)) {\r\nif (!(ChanStatus & STATMODE)) {\r\n#ifdef ROCKET_DEBUG_RECEIVE\r\nprintk(KERN_INFO "Entering STATMODE...\n");\r\n#endif\r\nChanStatus |= STATMODE;\r\nsEnRxStatusMode(cp);\r\n}\r\n}\r\nif (ChanStatus & STATMODE) {\r\n#ifdef ROCKET_DEBUG_RECEIVE\r\nprintk(KERN_INFO "Ignore %x, read %x...\n",\r\ninfo->ignore_status_mask, info->read_status_mask);\r\n#endif\r\nwhile (ToRecv) {\r\nchar flag;\r\nCharNStat = sInW(sGetTxRxDataIO(cp));\r\n#ifdef ROCKET_DEBUG_RECEIVE\r\nprintk(KERN_INFO "%x...\n", CharNStat);\r\n#endif\r\nif (CharNStat & STMBREAKH)\r\nCharNStat &= ~(STMFRAMEH | STMPARITYH);\r\nif (CharNStat & info->ignore_status_mask) {\r\nToRecv--;\r\ncontinue;\r\n}\r\nCharNStat &= info->read_status_mask;\r\nif (CharNStat & STMBREAKH)\r\nflag = TTY_BREAK;\r\nelse if (CharNStat & STMPARITYH)\r\nflag = TTY_PARITY;\r\nelse if (CharNStat & STMFRAMEH)\r\nflag = TTY_FRAME;\r\nelse if (CharNStat & STMRCVROVRH)\r\nflag = TTY_OVERRUN;\r\nelse\r\nflag = TTY_NORMAL;\r\ntty_insert_flip_char(&info->port, CharNStat & 0xff,\r\nflag);\r\nToRecv--;\r\n}\r\nif (sGetRxCnt(cp) == 0) {\r\n#ifdef ROCKET_DEBUG_RECEIVE\r\nprintk(KERN_INFO "Status mode off.\n");\r\n#endif\r\nsDisRxStatusMode(cp);\r\n}\r\n} else {\r\nspace = tty_prepare_flip_string(&info->port, &cbuf, ToRecv);\r\nif (space < ToRecv) {\r\n#ifdef ROCKET_DEBUG_RECEIVE\r\nprintk(KERN_INFO "rp_do_receive:insufficient space ToRecv=%d space=%d\n", ToRecv, space);\r\n#endif\r\nif (space <= 0)\r\nreturn;\r\nToRecv = space;\r\n}\r\nwRecv = ToRecv >> 1;\r\nif (wRecv)\r\nsInStrW(sGetTxRxDataIO(cp), (unsigned short *) cbuf, wRecv);\r\nif (ToRecv & 1)\r\ncbuf[ToRecv - 1] = sInB(sGetTxRxDataIO(cp));\r\n}\r\ntty_flip_buffer_push(&info->port);\r\n}\r\nstatic void rp_do_transmit(struct r_port *info)\r\n{\r\nint c;\r\nCHANNEL_t *cp = &info->channel;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\n#ifdef ROCKET_DEBUG_INTR\r\nprintk(KERN_DEBUG "%s\n", __func__);\r\n#endif\r\nif (!info)\r\nreturn;\r\ntty = tty_port_tty_get(&info->port);\r\nif (tty == NULL) {\r\nprintk(KERN_WARNING "rp: WARNING %s called with tty==NULL\n", __func__);\r\nclear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_fifo_room = TXFIFO_SIZE - sGetTxCnt(cp);\r\nwhile (1) {\r\nif (tty->stopped)\r\nbreak;\r\nc = min(info->xmit_fifo_room, info->xmit_cnt);\r\nc = min(c, XMIT_BUF_SIZE - info->xmit_tail);\r\nif (c <= 0 || info->xmit_fifo_room <= 0)\r\nbreak;\r\nsOutStrW(sGetTxRxDataIO(cp), (unsigned short *) (info->xmit_buf + info->xmit_tail), c / 2);\r\nif (c & 1)\r\nsOutB(sGetTxRxDataIO(cp), info->xmit_buf[info->xmit_tail + c - 1]);\r\ninfo->xmit_tail += c;\r\ninfo->xmit_tail &= XMIT_BUF_SIZE - 1;\r\ninfo->xmit_cnt -= c;\r\ninfo->xmit_fifo_room -= c;\r\n#ifdef ROCKET_DEBUG_INTR\r\nprintk(KERN_INFO "tx %d chars...\n", c);\r\n#endif\r\n}\r\nif (info->xmit_cnt == 0)\r\nclear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nif (info->xmit_cnt < WAKEUP_CHARS) {\r\ntty_wakeup(tty);\r\n#ifdef ROCKETPORT_HAVE_POLL_WAIT\r\nwake_up_interruptible(&tty->poll_wait);\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&info->slock, flags);\r\ntty_kref_put(tty);\r\n#ifdef ROCKET_DEBUG_INTR\r\nprintk(KERN_DEBUG "(%d,%d,%d,%d)...\n", info->xmit_cnt, info->xmit_head,\r\ninfo->xmit_tail, info->xmit_fifo_room);\r\n#endif\r\n}\r\nstatic void rp_handle_port(struct r_port *info)\r\n{\r\nCHANNEL_t *cp;\r\nunsigned int IntMask, ChanStatus;\r\nif (!info)\r\nreturn;\r\nif (!tty_port_initialized(&info->port)) {\r\nprintk(KERN_WARNING "rp: WARNING: rp_handle_port called with "\r\n"info->flags & NOT_INIT\n");\r\nreturn;\r\n}\r\ncp = &info->channel;\r\nIntMask = sGetChanIntID(cp) & info->intmask;\r\n#ifdef ROCKET_DEBUG_INTR\r\nprintk(KERN_INFO "rp_interrupt %02x...\n", IntMask);\r\n#endif\r\nChanStatus = sGetChanStatus(cp);\r\nif (IntMask & RXF_TRIG) {\r\nrp_do_receive(info, cp, ChanStatus);\r\n}\r\nif (IntMask & DELTA_CD) {\r\n#if (defined(ROCKET_DEBUG_OPEN) || defined(ROCKET_DEBUG_INTR) || defined(ROCKET_DEBUG_HANGUP))\r\nprintk(KERN_INFO "ttyR%d CD now %s...\n", info->line,\r\n(ChanStatus & CD_ACT) ? "on" : "off");\r\n#endif\r\nif (!(ChanStatus & CD_ACT) && info->cd_status) {\r\n#ifdef ROCKET_DEBUG_HANGUP\r\nprintk(KERN_INFO "CD drop, calling hangup.\n");\r\n#endif\r\ntty_port_tty_hangup(&info->port, false);\r\n}\r\ninfo->cd_status = (ChanStatus & CD_ACT) ? 1 : 0;\r\nwake_up_interruptible(&info->port.open_wait);\r\n}\r\n#ifdef ROCKET_DEBUG_INTR\r\nif (IntMask & DELTA_CTS) {\r\nprintk(KERN_INFO "CTS change...\n");\r\n}\r\nif (IntMask & DELTA_DSR) {\r\nprintk(KERN_INFO "DSR change...\n");\r\n}\r\n#endif\r\n}\r\nstatic void rp_do_poll(unsigned long dummy)\r\n{\r\nCONTROLLER_t *ctlp;\r\nint ctrl, aiop, ch, line;\r\nunsigned int xmitmask, i;\r\nunsigned int CtlMask;\r\nunsigned char AiopMask;\r\nWord_t bit;\r\nfor (ctrl = 0; ctrl < max_board; ctrl++) {\r\nif (rcktpt_io_addr[ctrl] <= 0)\r\ncontinue;\r\nctlp = sCtlNumToCtlPtr(ctrl);\r\n#ifdef CONFIG_PCI\r\nif (ctlp->BusType == isPCI)\r\nCtlMask = sPCIGetControllerIntStatus(ctlp);\r\nelse\r\n#endif\r\nCtlMask = sGetControllerIntStatus(ctlp);\r\nfor (aiop = 0; CtlMask; aiop++) {\r\nbit = ctlp->AiopIntrBits[aiop];\r\nif (CtlMask & bit) {\r\nCtlMask &= ~bit;\r\nAiopMask = sGetAiopIntStatus(ctlp, aiop);\r\nfor (ch = 0; AiopMask; AiopMask >>= 1, ch++) {\r\nif (AiopMask & 1) {\r\nline = GetLineNumber(ctrl, aiop, ch);\r\nrp_handle_port(rp_table[line]);\r\n}\r\n}\r\n}\r\n}\r\nxmitmask = xmit_flags[ctrl];\r\nif (xmitmask) {\r\nfor (i = 0; i < rocketModel[ctrl].numPorts; i++) {\r\nif (xmitmask & (1 << i)) {\r\naiop = (i & 0x18) >> 3;\r\nch = i & 0x07;\r\nline = GetLineNumber(ctrl, aiop, ch);\r\nrp_do_transmit(rp_table[line]);\r\n}\r\n}\r\n}\r\n}\r\nif (atomic_read(&rp_num_ports_open))\r\nmod_timer(&rocket_timer, jiffies + POLL_PERIOD);\r\n}\r\nstatic void __init\r\ninit_r_port(int board, int aiop, int chan, struct pci_dev *pci_dev)\r\n{\r\nunsigned rocketMode;\r\nstruct r_port *info;\r\nint line;\r\nCONTROLLER_T *ctlp;\r\nline = SetLineNumber(board, aiop, chan);\r\nctlp = sCtlNumToCtlPtr(board);\r\ninfo = kzalloc(sizeof (struct r_port), GFP_KERNEL);\r\nif (!info) {\r\nprintk(KERN_ERR "Couldn't allocate info struct for line #%d\n",\r\nline);\r\nreturn;\r\n}\r\ninfo->magic = RPORT_MAGIC;\r\ninfo->line = line;\r\ninfo->ctlp = ctlp;\r\ninfo->board = board;\r\ninfo->aiop = aiop;\r\ninfo->chan = chan;\r\ntty_port_init(&info->port);\r\ninfo->port.ops = &rocket_port_ops;\r\ninfo->flags &= ~ROCKET_MODE_MASK;\r\nswitch (pc104[board][line]) {\r\ncase 422:\r\ninfo->flags |= ROCKET_MODE_RS422;\r\nbreak;\r\ncase 485:\r\ninfo->flags |= ROCKET_MODE_RS485;\r\nbreak;\r\ncase 232:\r\ndefault:\r\ninfo->flags |= ROCKET_MODE_RS232;\r\nbreak;\r\n}\r\ninfo->intmask = RXF_TRIG | TXFIFO_MT | SRC_INT | DELTA_CD | DELTA_CTS | DELTA_DSR;\r\nif (sInitChan(ctlp, &info->channel, aiop, chan) == 0) {\r\nprintk(KERN_ERR "RocketPort sInitChan(%d, %d, %d) failed!\n",\r\nboard, aiop, chan);\r\ntty_port_destroy(&info->port);\r\nkfree(info);\r\nreturn;\r\n}\r\nrocketMode = info->flags & ROCKET_MODE_MASK;\r\nif ((info->flags & ROCKET_RTS_TOGGLE) || (rocketMode == ROCKET_MODE_RS485))\r\nsEnRTSToggle(&info->channel);\r\nelse\r\nsDisRTSToggle(&info->channel);\r\nif (ctlp->boardType == ROCKET_TYPE_PC104) {\r\nswitch (rocketMode) {\r\ncase ROCKET_MODE_RS485:\r\nsSetInterfaceMode(&info->channel, InterfaceModeRS485);\r\nbreak;\r\ncase ROCKET_MODE_RS422:\r\nsSetInterfaceMode(&info->channel, InterfaceModeRS422);\r\nbreak;\r\ncase ROCKET_MODE_RS232:\r\ndefault:\r\nif (info->flags & ROCKET_RTS_TOGGLE)\r\nsSetInterfaceMode(&info->channel, InterfaceModeRS232T);\r\nelse\r\nsSetInterfaceMode(&info->channel, InterfaceModeRS232);\r\nbreak;\r\n}\r\n}\r\nspin_lock_init(&info->slock);\r\nmutex_init(&info->write_mtx);\r\nrp_table[line] = info;\r\ntty_port_register_device(&info->port, rocket_driver, line,\r\npci_dev ? &pci_dev->dev : NULL);\r\n}\r\nstatic void configure_r_port(struct tty_struct *tty, struct r_port *info,\r\nstruct ktermios *old_termios)\r\n{\r\nunsigned cflag;\r\nunsigned long flags;\r\nunsigned rocketMode;\r\nint bits, baud, divisor;\r\nCHANNEL_t *cp;\r\nstruct ktermios *t = &tty->termios;\r\ncp = &info->channel;\r\ncflag = t->c_cflag;\r\nif ((cflag & CSIZE) == CS8) {\r\nsSetData8(cp);\r\nbits = 10;\r\n} else {\r\nsSetData7(cp);\r\nbits = 9;\r\n}\r\nif (cflag & CSTOPB) {\r\nsSetStop2(cp);\r\nbits++;\r\n} else {\r\nsSetStop1(cp);\r\n}\r\nif (cflag & PARENB) {\r\nsEnParity(cp);\r\nbits++;\r\nif (cflag & PARODD) {\r\nsSetOddParity(cp);\r\n} else {\r\nsSetEvenParity(cp);\r\n}\r\n} else {\r\nsDisParity(cp);\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\ndivisor = ((rp_baud_base[info->board] + (baud >> 1)) / baud) - 1;\r\nif ((divisor >= 8192 || divisor < 0) && old_termios) {\r\nbaud = tty_termios_baud_rate(old_termios);\r\nif (!baud)\r\nbaud = 9600;\r\ndivisor = (rp_baud_base[info->board] / baud) - 1;\r\n}\r\nif (divisor >= 8192 || divisor < 0) {\r\nbaud = 9600;\r\ndivisor = (rp_baud_base[info->board] / baud) - 1;\r\n}\r\ninfo->cps = baud / bits;\r\nsSetBaud(cp, divisor);\r\ntty_encode_baud_rate(tty, baud, baud);\r\nif (cflag & CRTSCTS) {\r\ninfo->intmask |= DELTA_CTS;\r\nsEnCTSFlowCtl(cp);\r\n} else {\r\ninfo->intmask &= ~DELTA_CTS;\r\nsDisCTSFlowCtl(cp);\r\n}\r\nif (cflag & CLOCAL) {\r\ninfo->intmask &= ~DELTA_CD;\r\n} else {\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (sGetChanStatus(cp) & CD_ACT)\r\ninfo->cd_status = 1;\r\nelse\r\ninfo->cd_status = 0;\r\ninfo->intmask |= DELTA_CD;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\n#ifdef ROCKET_SOFT_FLOW\r\nif (I_IXON(tty)) {\r\nsEnTxSoftFlowCtl(cp);\r\nif (I_IXANY(tty)) {\r\nsEnIXANY(cp);\r\n} else {\r\nsDisIXANY(cp);\r\n}\r\nsSetTxXONChar(cp, START_CHAR(tty));\r\nsSetTxXOFFChar(cp, STOP_CHAR(tty));\r\n} else {\r\nsDisTxSoftFlowCtl(cp);\r\nsDisIXANY(cp);\r\nsClrTxXOFF(cp);\r\n}\r\n#endif\r\ninfo->read_status_mask = STMRCVROVRH | 0xFF;\r\nif (I_INPCK(tty))\r\ninfo->read_status_mask |= STMFRAMEH | STMPARITYH;\r\nif (I_BRKINT(tty) || I_PARMRK(tty))\r\ninfo->read_status_mask |= STMBREAKH;\r\ninfo->ignore_status_mask = 0;\r\nif (I_IGNPAR(tty))\r\ninfo->ignore_status_mask |= STMFRAMEH | STMPARITYH;\r\nif (I_IGNBRK(tty)) {\r\ninfo->ignore_status_mask |= STMBREAKH;\r\nif (I_IGNPAR(tty))\r\ninfo->ignore_status_mask |= STMRCVROVRH;\r\n}\r\nrocketMode = info->flags & ROCKET_MODE_MASK;\r\nif ((info->flags & ROCKET_RTS_TOGGLE)\r\n|| (rocketMode == ROCKET_MODE_RS485))\r\nsEnRTSToggle(cp);\r\nelse\r\nsDisRTSToggle(cp);\r\nsSetRTS(&info->channel);\r\nif (cp->CtlP->boardType == ROCKET_TYPE_PC104) {\r\nswitch (rocketMode) {\r\ncase ROCKET_MODE_RS485:\r\nsSetInterfaceMode(cp, InterfaceModeRS485);\r\nbreak;\r\ncase ROCKET_MODE_RS422:\r\nsSetInterfaceMode(cp, InterfaceModeRS422);\r\nbreak;\r\ncase ROCKET_MODE_RS232:\r\ndefault:\r\nif (info->flags & ROCKET_RTS_TOGGLE)\r\nsSetInterfaceMode(cp, InterfaceModeRS232T);\r\nelse\r\nsSetInterfaceMode(cp, InterfaceModeRS232);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int carrier_raised(struct tty_port *port)\r\n{\r\nstruct r_port *info = container_of(port, struct r_port, port);\r\nreturn (sGetChanStatusLo(&info->channel) & CD_ACT) ? 1 : 0;\r\n}\r\nstatic void dtr_rts(struct tty_port *port, int on)\r\n{\r\nstruct r_port *info = container_of(port, struct r_port, port);\r\nif (on) {\r\nsSetDTR(&info->channel);\r\nsSetRTS(&info->channel);\r\n} else {\r\nsClrDTR(&info->channel);\r\nsClrRTS(&info->channel);\r\n}\r\n}\r\nstatic int rp_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct r_port *info;\r\nstruct tty_port *port;\r\nint retval;\r\nCHANNEL_t *cp;\r\nunsigned long page;\r\ninfo = rp_table[tty->index];\r\nif (info == NULL)\r\nreturn -ENXIO;\r\nport = &info->port;\r\npage = __get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nif (info->xmit_buf)\r\nfree_page(page);\r\nelse\r\ninfo->xmit_buf = (unsigned char *) page;\r\ntty->driver_data = info;\r\ntty_port_tty_set(port, tty);\r\nif (port->count++ == 0) {\r\natomic_inc(&rp_num_ports_open);\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "rocket mod++ = %d...\n",\r\natomic_read(&rp_num_ports_open));\r\n#endif\r\n}\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "rp_open ttyR%d, count=%d\n", info->line, info->port.count);\r\n#endif\r\nif (!tty_port_initialized(port)) {\r\ncp = &info->channel;\r\nsSetRxTrigger(cp, TRIG_1);\r\nif (sGetChanStatus(cp) & CD_ACT)\r\ninfo->cd_status = 1;\r\nelse\r\ninfo->cd_status = 0;\r\nsDisRxStatusMode(cp);\r\nsFlushRxFIFO(cp);\r\nsFlushTxFIFO(cp);\r\nsEnInterrupts(cp, (TXINT_EN | MCINT_EN | RXINT_EN | SRCINT_EN | CHANINT_EN));\r\nsSetRxTrigger(cp, TRIG_1);\r\nsGetChanStatus(cp);\r\nsDisRxStatusMode(cp);\r\nsClrTxXOFF(cp);\r\nsDisCTSFlowCtl(cp);\r\nsDisTxSoftFlowCtl(cp);\r\nsEnRxFIFO(cp);\r\nsEnTransmit(cp);\r\ntty_port_set_initialized(&info->port, 1);\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_HI)\r\ntty->alt_speed = 57600;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_VHI)\r\ntty->alt_speed = 115200;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_SHI)\r\ntty->alt_speed = 230400;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_WARP)\r\ntty->alt_speed = 460800;\r\nconfigure_r_port(tty, info, NULL);\r\nif (C_BAUD(tty)) {\r\nsSetDTR(cp);\r\nsSetRTS(cp);\r\n}\r\n}\r\nmod_timer(&rocket_timer, jiffies + POLL_PERIOD);\r\nretval = tty_port_block_til_ready(port, tty, filp);\r\nif (retval) {\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "rp_open returning after block_til_ready with %d\n", retval);\r\n#endif\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rp_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nstruct tty_port *port = &info->port;\r\nint timeout;\r\nCHANNEL_t *cp;\r\nif (rocket_paranoia_check(info, "rp_close"))\r\nreturn;\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "rp_close ttyR%d, count = %d\n", info->line, info->port.count);\r\n#endif\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\nreturn;\r\nmutex_lock(&port->mutex);\r\ncp = &info->channel;\r\ntimeout = (sGetTxCnt(cp) + 1) * HZ / info->cps;\r\nif (timeout == 0)\r\ntimeout = 1;\r\nrp_wait_until_sent(tty, timeout);\r\nclear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nsDisTransmit(cp);\r\nsDisInterrupts(cp, (TXINT_EN | MCINT_EN | RXINT_EN | SRCINT_EN | CHANINT_EN));\r\nsDisCTSFlowCtl(cp);\r\nsDisTxSoftFlowCtl(cp);\r\nsClrTxXOFF(cp);\r\nsFlushRxFIFO(cp);\r\nsFlushTxFIFO(cp);\r\nsClrRTS(cp);\r\nif (C_HUPCL(tty))\r\nsClrDTR(cp);\r\nrp_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\nclear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nif (port->blocked_open) {\r\nif (port->close_delay) {\r\nmsleep_interruptible(jiffies_to_msecs(port->close_delay));\r\n}\r\nwake_up_interruptible(&port->open_wait);\r\n} else {\r\nif (info->xmit_buf) {\r\nfree_page((unsigned long) info->xmit_buf);\r\ninfo->xmit_buf = NULL;\r\n}\r\n}\r\nspin_lock_irq(&port->lock);\r\ntty->closing = 0;\r\nspin_unlock_irq(&port->lock);\r\ntty_port_set_initialized(port, 0);\r\ntty_port_set_active(port, 0);\r\nmutex_unlock(&port->mutex);\r\ntty_port_tty_set(port, NULL);\r\natomic_dec(&rp_num_ports_open);\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "rocket mod-- = %d...\n",\r\natomic_read(&rp_num_ports_open));\r\nprintk(KERN_INFO "rp_close ttyR%d complete shutdown\n", info->line);\r\n#endif\r\n}\r\nstatic void rp_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nunsigned cflag;\r\nif (rocket_paranoia_check(info, "rp_set_termios"))\r\nreturn;\r\ncflag = tty->termios.c_cflag;\r\nif (((cflag & CSIZE) == CS5) || ((cflag & CSIZE) == CS6))\r\ntty->termios.c_cflag =\r\n((cflag & ~CSIZE) | (old_termios->c_cflag & CSIZE));\r\ntty->termios.c_cflag &= ~CMSPAR;\r\nconfigure_r_port(tty, info, old_termios);\r\ncp = &info->channel;\r\nif ((old_termios->c_cflag & CBAUD) && !C_BAUD(tty)) {\r\nsClrDTR(cp);\r\nsClrRTS(cp);\r\n}\r\nif (!(old_termios->c_cflag & CBAUD) && C_BAUD(tty)) {\r\nsSetRTS(cp);\r\nsSetDTR(cp);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) && !C_CRTSCTS(tty))\r\nrp_start(tty);\r\n}\r\nstatic int rp_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (rocket_paranoia_check(info, "rp_break"))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&info->slock, flags);\r\nif (break_state == -1)\r\nsSendBreak(&info->channel);\r\nelse\r\nsClrBreak(&info->channel);\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int sGetChanRI(CHANNEL_T * ChP)\r\n{\r\nCONTROLLER_t *CtlP = ChP->CtlP;\r\nint ChanNum = ChP->ChanNum;\r\nint RingInd = 0;\r\nif (CtlP->UPCIRingInd)\r\nRingInd = !(sInB(CtlP->UPCIRingInd) & sBitMapSetTbl[ChanNum]);\r\nelse if (CtlP->AltChanRingIndicator)\r\nRingInd = sInB((ByteIO_t) (ChP->ChanStat + 8)) & DSR_ACT;\r\nelse if (CtlP->boardType == ROCKET_TYPE_PC104)\r\nRingInd = !(sInB(CtlP->AiopIO[3]) & sBitMapSetTbl[ChanNum]);\r\nreturn RingInd;\r\n}\r\nstatic int rp_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nunsigned int control, result, ChanStatus;\r\nChanStatus = sGetChanStatusLo(&info->channel);\r\ncontrol = info->channel.TxControl[3];\r\nresult = ((control & SET_RTS) ? TIOCM_RTS : 0) |\r\n((control & SET_DTR) ? TIOCM_DTR : 0) |\r\n((ChanStatus & CD_ACT) ? TIOCM_CAR : 0) |\r\n(sGetChanRI(&info->channel) ? TIOCM_RNG : 0) |\r\n((ChanStatus & DSR_ACT) ? TIOCM_DSR : 0) |\r\n((ChanStatus & CTS_ACT) ? TIOCM_CTS : 0);\r\nreturn result;\r\n}\r\nstatic int rp_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nif (set & TIOCM_RTS)\r\ninfo->channel.TxControl[3] |= SET_RTS;\r\nif (set & TIOCM_DTR)\r\ninfo->channel.TxControl[3] |= SET_DTR;\r\nif (clear & TIOCM_RTS)\r\ninfo->channel.TxControl[3] &= ~SET_RTS;\r\nif (clear & TIOCM_DTR)\r\ninfo->channel.TxControl[3] &= ~SET_DTR;\r\nout32(info->channel.IndexAddr, info->channel.TxControl);\r\nreturn 0;\r\n}\r\nstatic int get_config(struct r_port *info, struct rocket_config __user *retinfo)\r\n{\r\nstruct rocket_config tmp;\r\nmemset(&tmp, 0, sizeof (tmp));\r\nmutex_lock(&info->port.mutex);\r\ntmp.line = info->line;\r\ntmp.flags = info->flags;\r\ntmp.close_delay = info->port.close_delay;\r\ntmp.closing_wait = info->port.closing_wait;\r\ntmp.port = rcktpt_io_addr[(info->line >> 5) & 3];\r\nmutex_unlock(&info->port.mutex);\r\nif (copy_to_user(retinfo, &tmp, sizeof (*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_config(struct tty_struct *tty, struct r_port *info,\r\nstruct rocket_config __user *new_info)\r\n{\r\nstruct rocket_config new_serial;\r\nif (copy_from_user(&new_serial, new_info, sizeof (new_serial)))\r\nreturn -EFAULT;\r\nmutex_lock(&info->port.mutex);\r\nif (!capable(CAP_SYS_ADMIN))\r\n{\r\nif ((new_serial.flags & ~ROCKET_USR_MASK) != (info->flags & ~ROCKET_USR_MASK)) {\r\nmutex_unlock(&info->port.mutex);\r\nreturn -EPERM;\r\n}\r\ninfo->flags = ((info->flags & ~ROCKET_USR_MASK) | (new_serial.flags & ROCKET_USR_MASK));\r\nconfigure_r_port(tty, info, NULL);\r\nmutex_unlock(&info->port.mutex);\r\nreturn 0;\r\n}\r\ninfo->flags = ((info->flags & ~ROCKET_FLAGS) | (new_serial.flags & ROCKET_FLAGS));\r\ninfo->port.close_delay = new_serial.close_delay;\r\ninfo->port.closing_wait = new_serial.closing_wait;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_HI)\r\ntty->alt_speed = 57600;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_VHI)\r\ntty->alt_speed = 115200;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_SHI)\r\ntty->alt_speed = 230400;\r\nif ((info->flags & ROCKET_SPD_MASK) == ROCKET_SPD_WARP)\r\ntty->alt_speed = 460800;\r\nmutex_unlock(&info->port.mutex);\r\nconfigure_r_port(tty, info, NULL);\r\nreturn 0;\r\n}\r\nstatic int get_ports(struct r_port *info, struct rocket_ports __user *retports)\r\n{\r\nstruct rocket_ports tmp;\r\nint board;\r\nmemset(&tmp, 0, sizeof (tmp));\r\ntmp.tty_major = rocket_driver->major;\r\nfor (board = 0; board < 4; board++) {\r\ntmp.rocketModel[board].model = rocketModel[board].model;\r\nstrcpy(tmp.rocketModel[board].modelString, rocketModel[board].modelString);\r\ntmp.rocketModel[board].numPorts = rocketModel[board].numPorts;\r\ntmp.rocketModel[board].loadrm2 = rocketModel[board].loadrm2;\r\ntmp.rocketModel[board].startingPortNumber = rocketModel[board].startingPortNumber;\r\n}\r\nif (copy_to_user(retports, &tmp, sizeof (*retports)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int reset_rm2(struct r_port *info, void __user *arg)\r\n{\r\nint reset;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&reset, arg, sizeof (int)))\r\nreturn -EFAULT;\r\nif (reset)\r\nreset = 1;\r\nif (rcktpt_type[info->board] != ROCKET_TYPE_MODEMII &&\r\nrcktpt_type[info->board] != ROCKET_TYPE_MODEMIII)\r\nreturn -EINVAL;\r\nif (info->ctlp->BusType == isISA)\r\nsModemReset(info->ctlp, info->chan, reset);\r\nelse\r\nsPCIModemReset(info->ctlp, info->chan, reset);\r\nreturn 0;\r\n}\r\nstatic int get_version(struct r_port *info, struct rocket_version __user *retvers)\r\n{\r\nif (copy_to_user(retvers, &driver_version, sizeof (*retvers)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int rp_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret = 0;\r\nif (cmd != RCKP_GET_PORTS && rocket_paranoia_check(info, "rp_ioctl"))\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase RCKP_GET_STRUCT:\r\nif (copy_to_user(argp, info, sizeof (struct r_port)))\r\nret = -EFAULT;\r\nbreak;\r\ncase RCKP_GET_CONFIG:\r\nret = get_config(info, argp);\r\nbreak;\r\ncase RCKP_SET_CONFIG:\r\nret = set_config(tty, info, argp);\r\nbreak;\r\ncase RCKP_GET_PORTS:\r\nret = get_ports(info, argp);\r\nbreak;\r\ncase RCKP_RESET_RM2:\r\nret = reset_rm2(info, argp);\r\nbreak;\r\ncase RCKP_GET_VERSION:\r\nret = get_version(info, argp);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rp_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nif (rocket_paranoia_check(info, "rp_send_xchar"))\r\nreturn;\r\ncp = &info->channel;\r\nif (sGetTxCnt(cp))\r\nsWriteTxPrioByte(cp, ch);\r\nelse\r\nsWriteTxByte(sGetTxRxDataIO(cp), ch);\r\n}\r\nstatic void rp_throttle(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\n#ifdef ROCKET_DEBUG_THROTTLE\r\nprintk(KERN_INFO "throttle %s ....\n", tty->name);\r\n#endif\r\nif (rocket_paranoia_check(info, "rp_throttle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nrp_send_xchar(tty, STOP_CHAR(tty));\r\nsClrRTS(&info->channel);\r\n}\r\nstatic void rp_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\n#ifdef ROCKET_DEBUG_THROTTLE\r\nprintk(KERN_INFO "unthrottle %s ....\n", tty->name);\r\n#endif\r\nif (rocket_paranoia_check(info, "rp_unthrottle"))\r\nreturn;\r\nif (I_IXOFF(tty))\r\nrp_send_xchar(tty, START_CHAR(tty));\r\nsSetRTS(&info->channel);\r\n}\r\nstatic void rp_stop(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\n#ifdef ROCKET_DEBUG_FLOW\r\nprintk(KERN_INFO "stop %s: %d %d....\n", tty->name,\r\ninfo->xmit_cnt, info->xmit_fifo_room);\r\n#endif\r\nif (rocket_paranoia_check(info, "rp_stop"))\r\nreturn;\r\nif (sGetTxCnt(&info->channel))\r\nsDisTransmit(&info->channel);\r\n}\r\nstatic void rp_start(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\n#ifdef ROCKET_DEBUG_FLOW\r\nprintk(KERN_INFO "start %s: %d %d....\n", tty->name,\r\ninfo->xmit_cnt, info->xmit_fifo_room);\r\n#endif\r\nif (rocket_paranoia_check(info, "rp_stop"))\r\nreturn;\r\nsEnTransmit(&info->channel);\r\nset_bit((info->aiop * 8) + info->chan,\r\n(void *) &xmit_flags[info->board]);\r\n}\r\nstatic void rp_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nunsigned long orig_jiffies;\r\nint check_time, exit_time;\r\nint txcnt;\r\nif (rocket_paranoia_check(info, "rp_wait_until_sent"))\r\nreturn;\r\ncp = &info->channel;\r\norig_jiffies = jiffies;\r\n#ifdef ROCKET_DEBUG_WAIT_UNTIL_SENT\r\nprintk(KERN_INFO "In %s(%d) (jiff=%lu)...\n", __func__, timeout,\r\njiffies);\r\nprintk(KERN_INFO "cps=%d...\n", info->cps);\r\n#endif\r\nwhile (1) {\r\ntxcnt = sGetTxCnt(cp);\r\nif (!txcnt) {\r\nif (sGetChanStatusLo(cp) & TXSHRMT)\r\nbreak;\r\ncheck_time = (HZ / info->cps) / 5;\r\n} else {\r\ncheck_time = HZ * txcnt / info->cps;\r\n}\r\nif (timeout) {\r\nexit_time = orig_jiffies + timeout - jiffies;\r\nif (exit_time <= 0)\r\nbreak;\r\nif (exit_time < check_time)\r\ncheck_time = exit_time;\r\n}\r\nif (check_time == 0)\r\ncheck_time = 1;\r\n#ifdef ROCKET_DEBUG_WAIT_UNTIL_SENT\r\nprintk(KERN_INFO "txcnt = %d (jiff=%lu,check=%d)...\n", txcnt,\r\njiffies, check_time);\r\n#endif\r\nmsleep_interruptible(jiffies_to_msecs(check_time));\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\n#ifdef ROCKET_DEBUG_WAIT_UNTIL_SENT\r\nprintk(KERN_INFO "txcnt = %d (jiff=%lu)...done\n", txcnt, jiffies);\r\n#endif\r\n}\r\nstatic void rp_hangup(struct tty_struct *tty)\r\n{\r\nCHANNEL_t *cp;\r\nstruct r_port *info = tty->driver_data;\r\nunsigned long flags;\r\nif (rocket_paranoia_check(info, "rp_hangup"))\r\nreturn;\r\n#if (defined(ROCKET_DEBUG_OPEN) || defined(ROCKET_DEBUG_HANGUP))\r\nprintk(KERN_INFO "rp_hangup of ttyR%d...\n", info->line);\r\n#endif\r\nrp_flush_buffer(tty);\r\nspin_lock_irqsave(&info->port.lock, flags);\r\nif (info->port.count)\r\natomic_dec(&rp_num_ports_open);\r\nclear_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nspin_unlock_irqrestore(&info->port.lock, flags);\r\ntty_port_hangup(&info->port);\r\ncp = &info->channel;\r\nsDisRxFIFO(cp);\r\nsDisTransmit(cp);\r\nsDisInterrupts(cp, (TXINT_EN | MCINT_EN | RXINT_EN | SRCINT_EN | CHANINT_EN));\r\nsDisCTSFlowCtl(cp);\r\nsDisTxSoftFlowCtl(cp);\r\nsClrTxXOFF(cp);\r\ntty_port_set_initialized(&info->port, 0);\r\nwake_up_interruptible(&info->port.open_wait);\r\n}\r\nstatic int rp_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nunsigned long flags;\r\nif (rocket_paranoia_check(info, "rp_put_char"))\r\nreturn 0;\r\nmutex_lock(&info->write_mtx);\r\n#ifdef ROCKET_DEBUG_WRITE\r\nprintk(KERN_INFO "rp_put_char %c...\n", ch);\r\n#endif\r\nspin_lock_irqsave(&info->slock, flags);\r\ncp = &info->channel;\r\nif (!tty->stopped && info->xmit_fifo_room == 0)\r\ninfo->xmit_fifo_room = TXFIFO_SIZE - sGetTxCnt(cp);\r\nif (tty->stopped || info->xmit_fifo_room == 0 || info->xmit_cnt != 0) {\r\ninfo->xmit_buf[info->xmit_head++] = ch;\r\ninfo->xmit_head &= XMIT_BUF_SIZE - 1;\r\ninfo->xmit_cnt++;\r\nset_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\n} else {\r\nsOutB(sGetTxRxDataIO(cp), ch);\r\ninfo->xmit_fifo_room--;\r\n}\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nmutex_unlock(&info->write_mtx);\r\nreturn 1;\r\n}\r\nstatic int rp_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nconst unsigned char *b;\r\nint c, retval = 0;\r\nunsigned long flags;\r\nif (count <= 0 || rocket_paranoia_check(info, "rp_write"))\r\nreturn 0;\r\nif (mutex_lock_interruptible(&info->write_mtx))\r\nreturn -ERESTARTSYS;\r\n#ifdef ROCKET_DEBUG_WRITE\r\nprintk(KERN_INFO "rp_write %d chars...\n", count);\r\n#endif\r\ncp = &info->channel;\r\nif (!tty->stopped && info->xmit_fifo_room < count)\r\ninfo->xmit_fifo_room = TXFIFO_SIZE - sGetTxCnt(cp);\r\nif (!tty->stopped && info->xmit_cnt == 0 && info->xmit_fifo_room > 0) {\r\nc = min(count, info->xmit_fifo_room);\r\nb = buf;\r\nsOutStrW(sGetTxRxDataIO(cp), (unsigned short *) b, c / 2);\r\nif (c & 1)\r\nsOutB(sGetTxRxDataIO(cp), b[c - 1]);\r\nretval += c;\r\nbuf += c;\r\ncount -= c;\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_fifo_room -= c;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n}\r\nif (!count)\r\ngoto end;\r\nwhile (1) {\r\nif (!tty_port_active(&info->port))\r\ngoto end;\r\nc = min(count, XMIT_BUF_SIZE - info->xmit_cnt - 1);\r\nc = min(c, XMIT_BUF_SIZE - info->xmit_head);\r\nif (c <= 0)\r\nbreak;\r\nb = buf;\r\nmemcpy(info->xmit_buf + info->xmit_head, b, c);\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_head =\r\n(info->xmit_head + c) & (XMIT_BUF_SIZE - 1);\r\ninfo->xmit_cnt += c;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\nbuf += c;\r\ncount -= c;\r\nretval += c;\r\n}\r\nif ((retval > 0) && !tty->stopped)\r\nset_bit((info->aiop * 8) + info->chan, (void *) &xmit_flags[info->board]);\r\nend:\r\nif (info->xmit_cnt < WAKEUP_CHARS) {\r\ntty_wakeup(tty);\r\n#ifdef ROCKETPORT_HAVE_POLL_WAIT\r\nwake_up_interruptible(&tty->poll_wait);\r\n#endif\r\n}\r\nmutex_unlock(&info->write_mtx);\r\nreturn retval;\r\n}\r\nstatic int rp_write_room(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nint ret;\r\nif (rocket_paranoia_check(info, "rp_write_room"))\r\nreturn 0;\r\nret = XMIT_BUF_SIZE - info->xmit_cnt - 1;\r\nif (ret < 0)\r\nret = 0;\r\n#ifdef ROCKET_DEBUG_WRITE\r\nprintk(KERN_INFO "rp_write_room returns %d...\n", ret);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int rp_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nif (rocket_paranoia_check(info, "rp_chars_in_buffer"))\r\nreturn 0;\r\n#ifdef ROCKET_DEBUG_WRITE\r\nprintk(KERN_INFO "rp_chars_in_buffer returns %d...\n", info->xmit_cnt);\r\n#endif\r\nreturn info->xmit_cnt;\r\n}\r\nstatic void rp_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct r_port *info = tty->driver_data;\r\nCHANNEL_t *cp;\r\nunsigned long flags;\r\nif (rocket_paranoia_check(info, "rp_flush_buffer"))\r\nreturn;\r\nspin_lock_irqsave(&info->slock, flags);\r\ninfo->xmit_cnt = info->xmit_head = info->xmit_tail = 0;\r\nspin_unlock_irqrestore(&info->slock, flags);\r\n#ifdef ROCKETPORT_HAVE_POLL_WAIT\r\nwake_up_interruptible(&tty->poll_wait);\r\n#endif\r\ntty_wakeup(tty);\r\ncp = &info->channel;\r\nsFlushTxFIFO(cp);\r\n}\r\nstatic void rmSpeakerReset(CONTROLLER_T * CtlP, unsigned long model)\r\n{\r\nByteIO_t addr;\r\nif ((model == MODEL_RP4M) || (model == MODEL_RP6M)) {\r\naddr = CtlP->AiopIO[0] + 0x4F;\r\nsOutB(addr, 0);\r\n}\r\nif ((model == MODEL_UPCI_RM3_8PORT)\r\n|| (model == MODEL_UPCI_RM3_4PORT)) {\r\naddr = CtlP->AiopIO[0] + 0x88;\r\nsOutB(addr, 0);\r\n}\r\n}\r\nstatic int sPCIInitController(CONTROLLER_T * CtlP, int CtlNum,\r\nByteIO_t * AiopIOList, int AiopIOListSize,\r\nWordIO_t ConfigIO, int IRQNum, Byte_t Frequency,\r\nint PeriodicOnly, int altChanRingIndicator,\r\nint UPCIRingInd)\r\n{\r\nint i;\r\nByteIO_t io;\r\nCtlP->AltChanRingIndicator = altChanRingIndicator;\r\nCtlP->UPCIRingInd = UPCIRingInd;\r\nCtlP->CtlNum = CtlNum;\r\nCtlP->CtlID = CTLID_0001;\r\nCtlP->BusType = isPCI;\r\nif (ConfigIO) {\r\nCtlP->isUPCI = 1;\r\nCtlP->PCIIO = ConfigIO + _PCI_9030_INT_CTRL;\r\nCtlP->PCIIO2 = ConfigIO + _PCI_9030_GPIO_CTRL;\r\nCtlP->AiopIntrBits = upci_aiop_intr_bits;\r\n} else {\r\nCtlP->isUPCI = 0;\r\nCtlP->PCIIO =\r\n(WordIO_t) ((ByteIO_t) AiopIOList[0] + _PCI_INT_FUNC);\r\nCtlP->AiopIntrBits = aiop_intr_bits;\r\n}\r\nsPCIControllerEOI(CtlP);\r\nCtlP->NumAiop = 0;\r\nfor (i = 0; i < AiopIOListSize; i++) {\r\nio = AiopIOList[i];\r\nCtlP->AiopIO[i] = (WordIO_t) io;\r\nCtlP->AiopIntChanIO[i] = io + _INT_CHAN;\r\nCtlP->AiopID[i] = sReadAiopID(io);\r\nif (CtlP->AiopID[i] == AIOPID_NULL)\r\nbreak;\r\nCtlP->AiopNumChan[i] = sReadAiopNumChan((WordIO_t) io);\r\nsOutW((WordIO_t) io + _INDX_ADDR, _CLK_PRE);\r\nsOutB(io + _INDX_DATA, sClockPrescale);\r\nCtlP->NumAiop++;\r\n}\r\nif (CtlP->NumAiop == 0)\r\nreturn (-1);\r\nelse\r\nreturn (CtlP->NumAiop);\r\n}\r\nstatic __init int register_PCI(int i, struct pci_dev *dev)\r\n{\r\nint num_aiops, aiop, max_num_aiops, num_chan, chan;\r\nunsigned int aiopio[MAX_AIOPS_PER_BOARD];\r\nCONTROLLER_t *ctlp;\r\nint fast_clock = 0;\r\nint altChanRingIndicator = 0;\r\nint ports_per_aiop = 8;\r\nWordIO_t ConfigIO = 0;\r\nByteIO_t UPCIRingInd = 0;\r\nif (!dev || !pci_match_id(rocket_pci_ids, dev) ||\r\npci_enable_device(dev))\r\nreturn 0;\r\nrcktpt_io_addr[i] = pci_resource_start(dev, 0);\r\nrcktpt_type[i] = ROCKET_TYPE_NORMAL;\r\nrocketModel[i].loadrm2 = 0;\r\nrocketModel[i].startingPortNumber = nextLineNumber;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_RP4QUAD:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 4;\r\nrocketModel[i].model = MODEL_RP4QUAD;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 4 port w/quad cable");\r\nrocketModel[i].numPorts = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP8OCTA:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_RP8OCTA;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 8 port w/octa cable");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_URP8OCTA:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_UPCI_RP8OCTA;\r\nstrcpy(rocketModel[i].modelString, "RocketPort UPCI 8 port w/octa cable");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP8INTF:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_RP8INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 8 port w/external I/F");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_URP8INTF:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_UPCI_RP8INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort UPCI 8 port w/external I/F");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP8J:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_RP8J;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 8 port w/RJ11 connectors");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP4J:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 4;\r\nrocketModel[i].model = MODEL_RP4J;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 4 port w/RJ45 connectors");\r\nrocketModel[i].numPorts = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP8SNI:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_RP8SNI;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 8 port w/ custom DB78");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP16SNI:\r\nmax_num_aiops = 2;\r\nrocketModel[i].model = MODEL_RP16SNI;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 16 port w/ custom DB78");\r\nrocketModel[i].numPorts = 16;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP16INTF:\r\nmax_num_aiops = 2;\r\nrocketModel[i].model = MODEL_RP16INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 16 port w/external I/F");\r\nrocketModel[i].numPorts = 16;\r\nbreak;\r\ncase PCI_DEVICE_ID_URP16INTF:\r\nmax_num_aiops = 2;\r\nrocketModel[i].model = MODEL_UPCI_RP16INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort UPCI 16 port w/external I/F");\r\nrocketModel[i].numPorts = 16;\r\nbreak;\r\ncase PCI_DEVICE_ID_CRP16INTF:\r\nmax_num_aiops = 2;\r\nrocketModel[i].model = MODEL_CPCI_RP16INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort Compact PCI 16 port w/external I/F");\r\nrocketModel[i].numPorts = 16;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP32INTF:\r\nmax_num_aiops = 4;\r\nrocketModel[i].model = MODEL_RP32INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort 32 port w/external I/F");\r\nrocketModel[i].numPorts = 32;\r\nbreak;\r\ncase PCI_DEVICE_ID_URP32INTF:\r\nmax_num_aiops = 4;\r\nrocketModel[i].model = MODEL_UPCI_RP32INTF;\r\nstrcpy(rocketModel[i].modelString, "RocketPort UPCI 32 port w/external I/F");\r\nrocketModel[i].numPorts = 32;\r\nbreak;\r\ncase PCI_DEVICE_ID_RPP4:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 4;\r\naltChanRingIndicator++;\r\nfast_clock++;\r\nrocketModel[i].model = MODEL_RPP4;\r\nstrcpy(rocketModel[i].modelString, "RocketPort Plus 4 port");\r\nrocketModel[i].numPorts = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RPP8:\r\nmax_num_aiops = 2;\r\nports_per_aiop = 4;\r\naltChanRingIndicator++;\r\nfast_clock++;\r\nrocketModel[i].model = MODEL_RPP8;\r\nstrcpy(rocketModel[i].modelString, "RocketPort Plus 8 port");\r\nrocketModel[i].numPorts = 8;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP2_232:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 2;\r\naltChanRingIndicator++;\r\nfast_clock++;\r\nrocketModel[i].model = MODEL_RP2_232;\r\nstrcpy(rocketModel[i].modelString, "RocketPort Plus 2 port RS232");\r\nrocketModel[i].numPorts = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP2_422:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 2;\r\naltChanRingIndicator++;\r\nfast_clock++;\r\nrocketModel[i].model = MODEL_RP2_422;\r\nstrcpy(rocketModel[i].modelString, "RocketPort Plus 2 port RS422");\r\nrocketModel[i].numPorts = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP6M:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 6;\r\nif (dev->revision == 1) {\r\nrcktpt_type[i] = ROCKET_TYPE_MODEMII;\r\nrocketModel[i].loadrm2 = 1;\r\n} else {\r\nrcktpt_type[i] = ROCKET_TYPE_MODEM;\r\n}\r\nrocketModel[i].model = MODEL_RP6M;\r\nstrcpy(rocketModel[i].modelString, "RocketModem 6 port");\r\nrocketModel[i].numPorts = 6;\r\nbreak;\r\ncase PCI_DEVICE_ID_RP4M:\r\nmax_num_aiops = 1;\r\nports_per_aiop = 4;\r\nif (dev->revision == 1) {\r\nrcktpt_type[i] = ROCKET_TYPE_MODEMII;\r\nrocketModel[i].loadrm2 = 1;\r\n} else {\r\nrcktpt_type[i] = ROCKET_TYPE_MODEM;\r\n}\r\nrocketModel[i].model = MODEL_RP4M;\r\nstrcpy(rocketModel[i].modelString, "RocketModem 4 port");\r\nrocketModel[i].numPorts = 4;\r\nbreak;\r\ndefault:\r\nmax_num_aiops = 0;\r\nbreak;\r\n}\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_URP32INTF:\r\ncase PCI_DEVICE_ID_URP8INTF:\r\ncase PCI_DEVICE_ID_URP16INTF:\r\ncase PCI_DEVICE_ID_CRP16INTF:\r\ncase PCI_DEVICE_ID_URP8OCTA:\r\nrcktpt_io_addr[i] = pci_resource_start(dev, 2);\r\nConfigIO = pci_resource_start(dev, 1);\r\nif (dev->device == PCI_DEVICE_ID_URP8OCTA) {\r\nUPCIRingInd = rcktpt_io_addr[i] + _PCI_9030_RING_IND;\r\nif (!\r\n(sInW(ConfigIO + _PCI_9030_GPIO_CTRL) &\r\nPCI_GPIO_CTRL_8PORT)) {\r\nports_per_aiop = 4;\r\nrocketModel[i].numPorts = 4;\r\n}\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_UPCI_RM3_8PORT:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_UPCI_RM3_8PORT;\r\nstrcpy(rocketModel[i].modelString, "RocketModem III 8 port");\r\nrocketModel[i].numPorts = 8;\r\nrcktpt_io_addr[i] = pci_resource_start(dev, 2);\r\nUPCIRingInd = rcktpt_io_addr[i] + _PCI_9030_RING_IND;\r\nConfigIO = pci_resource_start(dev, 1);\r\nrcktpt_type[i] = ROCKET_TYPE_MODEMIII;\r\nbreak;\r\ncase PCI_DEVICE_ID_UPCI_RM3_4PORT:\r\nmax_num_aiops = 1;\r\nrocketModel[i].model = MODEL_UPCI_RM3_4PORT;\r\nstrcpy(rocketModel[i].modelString, "RocketModem III 4 port");\r\nrocketModel[i].numPorts = 4;\r\nrcktpt_io_addr[i] = pci_resource_start(dev, 2);\r\nUPCIRingInd = rcktpt_io_addr[i] + _PCI_9030_RING_IND;\r\nConfigIO = pci_resource_start(dev, 1);\r\nrcktpt_type[i] = ROCKET_TYPE_MODEMIII;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (fast_clock) {\r\nsClockPrescale = 0x12;\r\nrp_baud_base[i] = 921600;\r\n} else {\r\nif (support_low_speed) {\r\nsClockPrescale = 0x19;\r\nrp_baud_base[i] = 230400;\r\n} else {\r\nsClockPrescale = 0x14;\r\nrp_baud_base[i] = 460800;\r\n}\r\n}\r\nfor (aiop = 0; aiop < max_num_aiops; aiop++)\r\naiopio[aiop] = rcktpt_io_addr[i] + (aiop * 0x40);\r\nctlp = sCtlNumToCtlPtr(i);\r\nnum_aiops = sPCIInitController(ctlp, i, aiopio, max_num_aiops, ConfigIO, 0, FREQ_DIS, 0, altChanRingIndicator, UPCIRingInd);\r\nfor (aiop = 0; aiop < max_num_aiops; aiop++)\r\nctlp->AiopNumChan[aiop] = ports_per_aiop;\r\ndev_info(&dev->dev, "comtrol PCI controller #%d found at "\r\n"address %04lx, %d AIOP(s) (%s), creating ttyR%d - %ld\n",\r\ni, rcktpt_io_addr[i], num_aiops, rocketModel[i].modelString,\r\nrocketModel[i].startingPortNumber,\r\nrocketModel[i].startingPortNumber + rocketModel[i].numPorts-1);\r\nif (num_aiops <= 0) {\r\nrcktpt_io_addr[i] = 0;\r\nreturn (0);\r\n}\r\nis_PCI[i] = 1;\r\nfor (aiop = 0; aiop < num_aiops; aiop++) {\r\nsResetAiopByNum(ctlp, aiop);\r\nnum_chan = ports_per_aiop;\r\nfor (chan = 0; chan < num_chan; chan++)\r\ninit_r_port(i, aiop, chan, dev);\r\n}\r\nif ((rcktpt_type[i] == ROCKET_TYPE_MODEM) ||\r\n(rcktpt_type[i] == ROCKET_TYPE_MODEMII) ||\r\n(rcktpt_type[i] == ROCKET_TYPE_MODEMIII)) {\r\nnum_chan = ports_per_aiop;\r\nfor (chan = 0; chan < num_chan; chan++)\r\nsPCIModemReset(ctlp, chan, 1);\r\nmsleep(500);\r\nfor (chan = 0; chan < num_chan; chan++)\r\nsPCIModemReset(ctlp, chan, 0);\r\nmsleep(500);\r\nrmSpeakerReset(ctlp, rocketModel[i].model);\r\n}\r\nreturn (1);\r\n}\r\nstatic int __init init_PCI(int boards_found)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nint count = 0;\r\nwhile ((dev = pci_get_device(PCI_VENDOR_ID_RP, PCI_ANY_ID, dev))) {\r\nif (register_PCI(count + boards_found, dev))\r\ncount++;\r\n}\r\nreturn (count);\r\n}\r\nstatic int __init init_ISA(int i)\r\n{\r\nint num_aiops, num_chan = 0, total_num_chan = 0;\r\nint aiop, chan;\r\nunsigned int aiopio[MAX_AIOPS_PER_BOARD];\r\nCONTROLLER_t *ctlp;\r\nchar *type_string;\r\nif (rcktpt_io_addr[i] == 0)\r\nreturn (0);\r\nif (!request_region(rcktpt_io_addr[i], 64, "Comtrol RocketPort")) {\r\nprintk(KERN_ERR "Unable to reserve IO region for configured "\r\n"ISA RocketPort at address 0x%lx, board not "\r\n"installed...\n", rcktpt_io_addr[i]);\r\nrcktpt_io_addr[i] = 0;\r\nreturn (0);\r\n}\r\nctlp = sCtlNumToCtlPtr(i);\r\nctlp->boardType = rcktpt_type[i];\r\nswitch (rcktpt_type[i]) {\r\ncase ROCKET_TYPE_PC104:\r\ntype_string = "(PC104)";\r\nbreak;\r\ncase ROCKET_TYPE_MODEM:\r\ntype_string = "(RocketModem)";\r\nbreak;\r\ncase ROCKET_TYPE_MODEMII:\r\ntype_string = "(RocketModem II)";\r\nbreak;\r\ndefault:\r\ntype_string = "";\r\nbreak;\r\n}\r\nif (support_low_speed) {\r\nsClockPrescale = 0x19;\r\nrp_baud_base[i] = 230400;\r\n} else {\r\nsClockPrescale = 0x14;\r\nrp_baud_base[i] = 460800;\r\n}\r\nfor (aiop = 0; aiop < MAX_AIOPS_PER_BOARD; aiop++)\r\naiopio[aiop] = rcktpt_io_addr[i] + (aiop * 0x400);\r\nnum_aiops = sInitController(ctlp, i, controller + (i * 0x400), aiopio, MAX_AIOPS_PER_BOARD, 0, FREQ_DIS, 0);\r\nif (ctlp->boardType == ROCKET_TYPE_PC104) {\r\nsEnAiop(ctlp, 2);\r\nsEnAiop(ctlp, 3);\r\n}\r\nif (num_aiops <= 0) {\r\nrelease_region(rcktpt_io_addr[i], 64);\r\nrcktpt_io_addr[i] = 0;\r\nreturn (0);\r\n}\r\nrocketModel[i].startingPortNumber = nextLineNumber;\r\nfor (aiop = 0; aiop < num_aiops; aiop++) {\r\nsResetAiopByNum(ctlp, aiop);\r\nsEnAiop(ctlp, aiop);\r\nnum_chan = sGetAiopNumChan(ctlp, aiop);\r\ntotal_num_chan += num_chan;\r\nfor (chan = 0; chan < num_chan; chan++)\r\ninit_r_port(i, aiop, chan, NULL);\r\n}\r\nis_PCI[i] = 0;\r\nif ((rcktpt_type[i] == ROCKET_TYPE_MODEM) || (rcktpt_type[i] == ROCKET_TYPE_MODEMII)) {\r\nnum_chan = sGetAiopNumChan(ctlp, 0);\r\ntotal_num_chan = num_chan;\r\nfor (chan = 0; chan < num_chan; chan++)\r\nsModemReset(ctlp, chan, 1);\r\nmsleep(500);\r\nfor (chan = 0; chan < num_chan; chan++)\r\nsModemReset(ctlp, chan, 0);\r\nmsleep(500);\r\nstrcpy(rocketModel[i].modelString, "RocketModem ISA");\r\n} else {\r\nstrcpy(rocketModel[i].modelString, "RocketPort ISA");\r\n}\r\nrocketModel[i].numPorts = total_num_chan;\r\nrocketModel[i].model = MODEL_ISA;\r\nprintk(KERN_INFO "RocketPort ISA card #%d found at 0x%lx - %d AIOPs %s\n",\r\ni, rcktpt_io_addr[i], num_aiops, type_string);\r\nprintk(KERN_INFO "Installing %s, creating /dev/ttyR%d - %ld\n",\r\nrocketModel[i].modelString,\r\nrocketModel[i].startingPortNumber,\r\nrocketModel[i].startingPortNumber +\r\nrocketModel[i].numPorts - 1);\r\nreturn (1);\r\n}\r\nstatic int __init rp_init(void)\r\n{\r\nint ret = -ENOMEM, pci_boards_found, isa_boards_found, i;\r\nprintk(KERN_INFO "RocketPort device driver module, version %s, %s\n",\r\nROCKET_VERSION, ROCKET_DATE);\r\nrocket_driver = alloc_tty_driver(MAX_RP_PORTS);\r\nif (!rocket_driver)\r\ngoto err;\r\nif (board1) {\r\nif (controller == 0)\r\ncontroller = board1 + 0x40;\r\n} else {\r\ncontroller = 0;\r\n}\r\nif (controller && (!request_region(controller, 4, "Comtrol RocketPort"))) {\r\nprintk(KERN_ERR "Unable to reserve IO region for first "\r\n"configured ISA RocketPort controller 0x%lx. "\r\n"Driver exiting\n", controller);\r\nret = -EBUSY;\r\ngoto err_tty;\r\n}\r\nrcktpt_io_addr[0] = board1;\r\nrcktpt_io_addr[1] = board2;\r\nrcktpt_io_addr[2] = board3;\r\nrcktpt_io_addr[3] = board4;\r\nrcktpt_type[0] = modem1 ? ROCKET_TYPE_MODEM : ROCKET_TYPE_NORMAL;\r\nrcktpt_type[0] = pc104_1[0] ? ROCKET_TYPE_PC104 : rcktpt_type[0];\r\nrcktpt_type[1] = modem2 ? ROCKET_TYPE_MODEM : ROCKET_TYPE_NORMAL;\r\nrcktpt_type[1] = pc104_2[0] ? ROCKET_TYPE_PC104 : rcktpt_type[1];\r\nrcktpt_type[2] = modem3 ? ROCKET_TYPE_MODEM : ROCKET_TYPE_NORMAL;\r\nrcktpt_type[2] = pc104_3[0] ? ROCKET_TYPE_PC104 : rcktpt_type[2];\r\nrcktpt_type[3] = modem4 ? ROCKET_TYPE_MODEM : ROCKET_TYPE_NORMAL;\r\nrcktpt_type[3] = pc104_4[0] ? ROCKET_TYPE_PC104 : rcktpt_type[3];\r\nrocket_driver->flags = TTY_DRIVER_DYNAMIC_DEV;\r\nrocket_driver->name = "ttyR";\r\nrocket_driver->driver_name = "Comtrol RocketPort";\r\nrocket_driver->major = TTY_ROCKET_MAJOR;\r\nrocket_driver->minor_start = 0;\r\nrocket_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nrocket_driver->subtype = SERIAL_TYPE_NORMAL;\r\nrocket_driver->init_termios = tty_std_termios;\r\nrocket_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nrocket_driver->init_termios.c_ispeed = 9600;\r\nrocket_driver->init_termios.c_ospeed = 9600;\r\n#ifdef ROCKET_SOFT_FLOW\r\nrocket_driver->flags |= TTY_DRIVER_REAL_RAW;\r\n#endif\r\ntty_set_operations(rocket_driver, &rocket_ops);\r\nret = tty_register_driver(rocket_driver);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "Couldn't install tty RocketPort driver\n");\r\ngoto err_controller;\r\n}\r\n#ifdef ROCKET_DEBUG_OPEN\r\nprintk(KERN_INFO "RocketPort driver is major %d\n", rocket_driver.major);\r\n#endif\r\nisa_boards_found = 0;\r\npci_boards_found = 0;\r\nfor (i = 0; i < NUM_BOARDS; i++) {\r\nif (init_ISA(i))\r\nisa_boards_found++;\r\n}\r\n#ifdef CONFIG_PCI\r\nif (isa_boards_found < NUM_BOARDS)\r\npci_boards_found = init_PCI(isa_boards_found);\r\n#endif\r\nmax_board = pci_boards_found + isa_boards_found;\r\nif (max_board == 0) {\r\nprintk(KERN_ERR "No rocketport ports found; unloading driver\n");\r\nret = -ENXIO;\r\ngoto err_ttyu;\r\n}\r\nreturn 0;\r\nerr_ttyu:\r\ntty_unregister_driver(rocket_driver);\r\nerr_controller:\r\nif (controller)\r\nrelease_region(controller, 4);\r\nerr_tty:\r\nput_tty_driver(rocket_driver);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void rp_cleanup_module(void)\r\n{\r\nint retval;\r\nint i;\r\ndel_timer_sync(&rocket_timer);\r\nretval = tty_unregister_driver(rocket_driver);\r\nif (retval)\r\nprintk(KERN_ERR "Error %d while trying to unregister "\r\n"rocketport driver\n", -retval);\r\nfor (i = 0; i < MAX_RP_PORTS; i++)\r\nif (rp_table[i]) {\r\ntty_unregister_device(rocket_driver, i);\r\ntty_port_destroy(&rp_table[i]->port);\r\nkfree(rp_table[i]);\r\n}\r\nput_tty_driver(rocket_driver);\r\nfor (i = 0; i < NUM_BOARDS; i++) {\r\nif (rcktpt_io_addr[i] <= 0 || is_PCI[i])\r\ncontinue;\r\nrelease_region(rcktpt_io_addr[i], 64);\r\n}\r\nif (controller)\r\nrelease_region(controller, 4);\r\n}\r\nstatic int sInitController(CONTROLLER_T * CtlP, int CtlNum, ByteIO_t MudbacIO,\r\nByteIO_t * AiopIOList, int AiopIOListSize,\r\nint IRQNum, Byte_t Frequency, int PeriodicOnly)\r\n{\r\nint i;\r\nByteIO_t io;\r\nint done;\r\nCtlP->AiopIntrBits = aiop_intr_bits;\r\nCtlP->AltChanRingIndicator = 0;\r\nCtlP->CtlNum = CtlNum;\r\nCtlP->CtlID = CTLID_0001;\r\nCtlP->BusType = isISA;\r\nCtlP->MBaseIO = MudbacIO;\r\nCtlP->MReg1IO = MudbacIO + 1;\r\nCtlP->MReg2IO = MudbacIO + 2;\r\nCtlP->MReg3IO = MudbacIO + 3;\r\n#if 1\r\nCtlP->MReg2 = 0;\r\nCtlP->MReg3 = 0;\r\n#else\r\nif (sIRQMap[IRQNum] == 0) {\r\nCtlP->MReg2 = 0;\r\nCtlP->MReg3 = 0;\r\n} else {\r\nCtlP->MReg2 = sIRQMap[IRQNum];\r\nCtlP->MReg3 = Frequency;\r\nif (PeriodicOnly) {\r\nCtlP->MReg3 |= PERIODIC_ONLY;\r\n}\r\n}\r\n#endif\r\nsOutB(CtlP->MReg2IO, CtlP->MReg2);\r\nsOutB(CtlP->MReg3IO, CtlP->MReg3);\r\nsControllerEOI(CtlP);\r\nCtlP->NumAiop = 0;\r\nfor (i = done = 0; i < AiopIOListSize; i++) {\r\nio = AiopIOList[i];\r\nCtlP->AiopIO[i] = (WordIO_t) io;\r\nCtlP->AiopIntChanIO[i] = io + _INT_CHAN;\r\nsOutB(CtlP->MReg2IO, CtlP->MReg2 | (i & 0x03));\r\nsOutB(MudbacIO, (Byte_t) (io >> 6));\r\nif (done)\r\ncontinue;\r\nsEnAiop(CtlP, i);\r\nCtlP->AiopID[i] = sReadAiopID(io);\r\nif (CtlP->AiopID[i] == AIOPID_NULL)\r\ndone = 1;\r\nelse {\r\nCtlP->AiopNumChan[i] = sReadAiopNumChan((WordIO_t) io);\r\nsOutW((WordIO_t) io + _INDX_ADDR, _CLK_PRE);\r\nsOutB(io + _INDX_DATA, sClockPrescale);\r\nCtlP->NumAiop++;\r\n}\r\nsDisAiop(CtlP, i);\r\n}\r\nif (CtlP->NumAiop == 0)\r\nreturn (-1);\r\nelse\r\nreturn (CtlP->NumAiop);\r\n}\r\nstatic int sReadAiopID(ByteIO_t io)\r\n{\r\nByte_t AiopID;\r\nsOutB(io + _CMD_REG, RESET_ALL);\r\nsOutB(io + _CMD_REG, 0x0);\r\nAiopID = sInW(io + _CHN_STAT0) & 0x07;\r\nif (AiopID == 0x06)\r\nreturn (1);\r\nelse\r\nreturn (-1);\r\n}\r\nstatic int sReadAiopNumChan(WordIO_t io)\r\n{\r\nWord_t x;\r\nstatic Byte_t R[4] = { 0x00, 0x00, 0x34, 0x12 };\r\nout32((DWordIO_t) io + _INDX_ADDR, R);\r\nsOutW(io + _INDX_ADDR, 0);\r\nx = sInW(io + _INDX_DATA);\r\nsOutW(io + _INDX_ADDR, 0x4000);\r\nif (x != sInW(io + _INDX_DATA))\r\nreturn (8);\r\nelse\r\nreturn (4);\r\n}\r\nstatic int sInitChan(CONTROLLER_T * CtlP, CHANNEL_T * ChP, int AiopNum,\r\nint ChanNum)\r\n{\r\nint i;\r\nWordIO_t AiopIO;\r\nWordIO_t ChIOOff;\r\nByte_t *ChR;\r\nWord_t ChOff;\r\nstatic Byte_t R[4];\r\nint brd9600;\r\nif (ChanNum >= CtlP->AiopNumChan[AiopNum])\r\nreturn 0;\r\nChP->CtlP = CtlP;\r\nChP->ChanID = CtlP->AiopID[AiopNum];\r\nChP->AiopNum = AiopNum;\r\nChP->ChanNum = ChanNum;\r\nAiopIO = CtlP->AiopIO[AiopNum];\r\nChP->Cmd = (ByteIO_t) AiopIO + _CMD_REG;\r\nChP->IntChan = (ByteIO_t) AiopIO + _INT_CHAN;\r\nChP->IntMask = (ByteIO_t) AiopIO + _INT_MASK;\r\nChP->IndexAddr = (DWordIO_t) AiopIO + _INDX_ADDR;\r\nChP->IndexData = AiopIO + _INDX_DATA;\r\nChIOOff = AiopIO + ChP->ChanNum * 2;\r\nChP->TxRxData = ChIOOff + _TD0;\r\nChP->ChanStat = ChIOOff + _CHN_STAT0;\r\nChP->TxRxCount = ChIOOff + _FIFO_CNT0;\r\nChP->IntID = (ByteIO_t) AiopIO + ChP->ChanNum + _INT_ID0;\r\nfor (i = 0; i < RDATASIZE; i += 4) {\r\nR[0] = RData[i];\r\nR[1] = RData[i + 1] + 0x10 * ChanNum;\r\nR[2] = RData[i + 2];\r\nR[3] = RData[i + 3];\r\nout32(ChP->IndexAddr, R);\r\n}\r\nChR = ChP->R;\r\nfor (i = 0; i < RREGDATASIZE; i += 4) {\r\nChR[i] = RRegData[i];\r\nChR[i + 1] = RRegData[i + 1] + 0x10 * ChanNum;\r\nChR[i + 2] = RRegData[i + 2];\r\nChR[i + 3] = RRegData[i + 3];\r\n}\r\nChOff = (Word_t) ChanNum *0x1000;\r\nif (sClockPrescale == 0x14)\r\nbrd9600 = 47;\r\nelse\r\nbrd9600 = 23;\r\nChP->BaudDiv[0] = (Byte_t) (ChOff + _BAUD);\r\nChP->BaudDiv[1] = (Byte_t) ((ChOff + _BAUD) >> 8);\r\nChP->BaudDiv[2] = (Byte_t) brd9600;\r\nChP->BaudDiv[3] = (Byte_t) (brd9600 >> 8);\r\nout32(ChP->IndexAddr, ChP->BaudDiv);\r\nChP->TxControl[0] = (Byte_t) (ChOff + _TX_CTRL);\r\nChP->TxControl[1] = (Byte_t) ((ChOff + _TX_CTRL) >> 8);\r\nChP->TxControl[2] = 0;\r\nChP->TxControl[3] = 0;\r\nout32(ChP->IndexAddr, ChP->TxControl);\r\nChP->RxControl[0] = (Byte_t) (ChOff + _RX_CTRL);\r\nChP->RxControl[1] = (Byte_t) ((ChOff + _RX_CTRL) >> 8);\r\nChP->RxControl[2] = 0;\r\nChP->RxControl[3] = 0;\r\nout32(ChP->IndexAddr, ChP->RxControl);\r\nChP->TxEnables[0] = (Byte_t) (ChOff + _TX_ENBLS);\r\nChP->TxEnables[1] = (Byte_t) ((ChOff + _TX_ENBLS) >> 8);\r\nChP->TxEnables[2] = 0;\r\nChP->TxEnables[3] = 0;\r\nout32(ChP->IndexAddr, ChP->TxEnables);\r\nChP->TxCompare[0] = (Byte_t) (ChOff + _TXCMP1);\r\nChP->TxCompare[1] = (Byte_t) ((ChOff + _TXCMP1) >> 8);\r\nChP->TxCompare[2] = 0;\r\nChP->TxCompare[3] = 0;\r\nout32(ChP->IndexAddr, ChP->TxCompare);\r\nChP->TxReplace1[0] = (Byte_t) (ChOff + _TXREP1B1);\r\nChP->TxReplace1[1] = (Byte_t) ((ChOff + _TXREP1B1) >> 8);\r\nChP->TxReplace1[2] = 0;\r\nChP->TxReplace1[3] = 0;\r\nout32(ChP->IndexAddr, ChP->TxReplace1);\r\nChP->TxReplace2[0] = (Byte_t) (ChOff + _TXREP2);\r\nChP->TxReplace2[1] = (Byte_t) ((ChOff + _TXREP2) >> 8);\r\nChP->TxReplace2[2] = 0;\r\nChP->TxReplace2[3] = 0;\r\nout32(ChP->IndexAddr, ChP->TxReplace2);\r\nChP->TxFIFOPtrs = ChOff + _TXF_OUTP;\r\nChP->TxFIFO = ChOff + _TX_FIFO;\r\nsOutB(ChP->Cmd, (Byte_t) ChanNum | RESTXFCNT);\r\nsOutB(ChP->Cmd, (Byte_t) ChanNum);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->TxFIFOPtrs);\r\nsOutW(ChP->IndexData, 0);\r\nChP->RxFIFOPtrs = ChOff + _RXF_OUTP;\r\nChP->RxFIFO = ChOff + _RX_FIFO;\r\nsOutB(ChP->Cmd, (Byte_t) ChanNum | RESRXFCNT);\r\nsOutB(ChP->Cmd, (Byte_t) ChanNum);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->RxFIFOPtrs);\r\nsOutW(ChP->IndexData, 0);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->RxFIFOPtrs + 2);\r\nsOutW(ChP->IndexData, 0);\r\nChP->TxPrioCnt = ChOff + _TXP_CNT;\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->TxPrioCnt);\r\nsOutB(ChP->IndexData, 0);\r\nChP->TxPrioPtr = ChOff + _TXP_PNTR;\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->TxPrioPtr);\r\nsOutB(ChP->IndexData, 0);\r\nChP->TxPrioBuf = ChOff + _TXP_BUF;\r\nsEnRxProcessor(ChP);\r\nreturn 1;\r\n}\r\nstatic void sStopRxProcessor(CHANNEL_T * ChP)\r\n{\r\nByte_t R[4];\r\nR[0] = ChP->R[0];\r\nR[1] = ChP->R[1];\r\nR[2] = 0x0a;\r\nR[3] = ChP->R[3];\r\nout32(ChP->IndexAddr, R);\r\n}\r\nstatic void sFlushRxFIFO(CHANNEL_T * ChP)\r\n{\r\nint i;\r\nByte_t Ch;\r\nint RxFIFOEnabled;\r\nif (sGetRxCnt(ChP) == 0)\r\nreturn;\r\nRxFIFOEnabled = 0;\r\nif (ChP->R[0x32] == 0x08) {\r\nRxFIFOEnabled = 1;\r\nsDisRxFIFO(ChP);\r\nfor (i = 0; i < 2000 / 200; i++)\r\nsInB(ChP->IntChan);\r\n}\r\nsGetChanStatus(ChP);\r\nCh = (Byte_t) sGetChanNum(ChP);\r\nsOutB(ChP->Cmd, Ch | RESRXFCNT);\r\nsOutB(ChP->Cmd, Ch);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->RxFIFOPtrs);\r\nsOutW(ChP->IndexData, 0);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->RxFIFOPtrs + 2);\r\nsOutW(ChP->IndexData, 0);\r\nif (RxFIFOEnabled)\r\nsEnRxFIFO(ChP);\r\n}\r\nstatic void sFlushTxFIFO(CHANNEL_T * ChP)\r\n{\r\nint i;\r\nByte_t Ch;\r\nint TxEnabled;\r\nif (sGetTxCnt(ChP) == 0)\r\nreturn;\r\nTxEnabled = 0;\r\nif (ChP->TxControl[3] & TX_ENABLE) {\r\nTxEnabled = 1;\r\nsDisTransmit(ChP);\r\n}\r\nsStopRxProcessor(ChP);\r\nfor (i = 0; i < 4000 / 200; i++)\r\nsInB(ChP->IntChan);\r\nCh = (Byte_t) sGetChanNum(ChP);\r\nsOutB(ChP->Cmd, Ch | RESTXFCNT);\r\nsOutB(ChP->Cmd, Ch);\r\nsOutW((WordIO_t) ChP->IndexAddr, ChP->TxFIFOPtrs);\r\nsOutW(ChP->IndexData, 0);\r\nif (TxEnabled)\r\nsEnTransmit(ChP);\r\nsStartRxProcessor(ChP);\r\n}\r\nstatic int sWriteTxPrioByte(CHANNEL_T * ChP, Byte_t Data)\r\n{\r\nByte_t DWBuf[4];\r\nWord_t *WordPtr;\r\nregister DWordIO_t IndexAddr;\r\nif (sGetTxCnt(ChP) > 1) {\r\nIndexAddr = ChP->IndexAddr;\r\nsOutW((WordIO_t) IndexAddr, ChP->TxPrioCnt);\r\nif (sInB((ByteIO_t) ChP->IndexData) & PRI_PEND)\r\nreturn (0);\r\nWordPtr = (Word_t *) (&DWBuf[0]);\r\n*WordPtr = ChP->TxPrioBuf;\r\nDWBuf[2] = Data;\r\nout32(IndexAddr, DWBuf);\r\n*WordPtr = ChP->TxPrioCnt;\r\nDWBuf[2] = PRI_PEND + 1;\r\nDWBuf[3] = 0;\r\nout32(IndexAddr, DWBuf);\r\n} else {\r\nsWriteTxByte(sGetTxRxDataIO(ChP), Data);\r\n}\r\nreturn (1);\r\n}\r\nstatic void sEnInterrupts(CHANNEL_T * ChP, Word_t Flags)\r\n{\r\nByte_t Mask;\r\nChP->RxControl[2] |=\r\n((Byte_t) Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));\r\nout32(ChP->IndexAddr, ChP->RxControl);\r\nChP->TxControl[2] |= ((Byte_t) Flags & TXINT_EN);\r\nout32(ChP->IndexAddr, ChP->TxControl);\r\nif (Flags & CHANINT_EN) {\r\nMask = sInB(ChP->IntMask) | sBitMapSetTbl[ChP->ChanNum];\r\nsOutB(ChP->IntMask, Mask);\r\n}\r\n}\r\nstatic void sDisInterrupts(CHANNEL_T * ChP, Word_t Flags)\r\n{\r\nByte_t Mask;\r\nChP->RxControl[2] &=\r\n~((Byte_t) Flags & (RXINT_EN | SRCINT_EN | MCINT_EN));\r\nout32(ChP->IndexAddr, ChP->RxControl);\r\nChP->TxControl[2] &= ~((Byte_t) Flags & TXINT_EN);\r\nout32(ChP->IndexAddr, ChP->TxControl);\r\nif (Flags & CHANINT_EN) {\r\nMask = sInB(ChP->IntMask) & sBitMapClrTbl[ChP->ChanNum];\r\nsOutB(ChP->IntMask, Mask);\r\n}\r\n}\r\nstatic void sSetInterfaceMode(CHANNEL_T * ChP, Byte_t mode)\r\n{\r\nsOutB(ChP->CtlP->AiopIO[2], (mode & 0x18) | ChP->ChanNum);\r\n}\r\nstatic void sModemReset(CONTROLLER_T * CtlP, int chan, int on)\r\n{\r\nByteIO_t addr;\r\nByte_t val;\r\naddr = CtlP->AiopIO[0] + 0x400;\r\nval = sInB(CtlP->MReg3IO);\r\nif ((val & 2) == 0) {\r\nval = sInB(CtlP->MReg2IO);\r\nsOutB(CtlP->MReg2IO, (val & 0xfc) | (1 & 0x03));\r\nsOutB(CtlP->MBaseIO, (unsigned char) (addr >> 6));\r\n}\r\nsEnAiop(CtlP, 1);\r\nif (!on)\r\naddr += 8;\r\nsOutB(addr + chan, 0);\r\nsDisAiop(CtlP, 1);\r\n}\r\nstatic void sPCIModemReset(CONTROLLER_T * CtlP, int chan, int on)\r\n{\r\nByteIO_t addr;\r\naddr = CtlP->AiopIO[0] + 0x40;\r\nif (!on)\r\naddr += 8;\r\nsOutB(addr + chan, 0);\r\n}\r\nstatic unsigned char GetLineNumber(int ctrl, int aiop, int ch)\r\n{\r\nreturn lineNumbers[(ctrl << 5) | (aiop << 3) | ch];\r\n}\r\nstatic unsigned char SetLineNumber(int ctrl, int aiop, int ch)\r\n{\r\nlineNumbers[(ctrl << 5) | (aiop << 3) | ch] = nextLineNumber++;\r\nreturn (nextLineNumber - 1);\r\n}
