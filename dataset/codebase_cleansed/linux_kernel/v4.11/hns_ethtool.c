static u32 hns_nic_get_link(struct net_device *net_dev)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nu32 link_stat = priv->link;\r\nstruct hnae_handle *h;\r\nh = priv->ae_handle;\r\nif (net_dev->phydev) {\r\nif (!genphy_read_status(net_dev->phydev))\r\nlink_stat = net_dev->phydev->link;\r\nelse\r\nlink_stat = 0;\r\n}\r\nif (h->dev && h->dev->ops && h->dev->ops->get_status)\r\nlink_stat = link_stat && h->dev->ops->get_status(h);\r\nelse\r\nlink_stat = 0;\r\nreturn link_stat;\r\n}\r\nstatic void hns_get_mdix_mode(struct net_device *net_dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nint mdix_ctrl, mdix, retval, is_resolved;\r\nstruct phy_device *phy_dev = net_dev->phydev;\r\nif (!phy_dev || !phy_dev->mdio.bus) {\r\ncmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\r\ncmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\r\nreturn;\r\n}\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_MDIX);\r\nretval = phy_read(phy_dev, HNS_PHY_CSC_REG);\r\nmdix_ctrl = hnae_get_field(retval, PHY_MDIX_CTRL_M, PHY_MDIX_CTRL_S);\r\nretval = phy_read(phy_dev, HNS_PHY_CSS_REG);\r\nmdix = hnae_get_bit(retval, PHY_MDIX_STATUS_B);\r\nis_resolved = hnae_get_bit(retval, PHY_SPEED_DUP_RESOLVE_B);\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_COPPER);\r\nswitch (mdix_ctrl) {\r\ncase 0x0:\r\ncmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI;\r\nbreak;\r\ncase 0x1:\r\ncmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_X;\r\nbreak;\r\ncase 0x3:\r\ncmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\r\nbreak;\r\ndefault:\r\ncmd->base.eth_tp_mdix_ctrl = ETH_TP_MDI_INVALID;\r\nbreak;\r\n}\r\nif (!is_resolved)\r\ncmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\r\nelse if (mdix)\r\ncmd->base.eth_tp_mdix = ETH_TP_MDI_X;\r\nelse\r\ncmd->base.eth_tp_mdix = ETH_TP_MDI;\r\n}\r\nstatic int hns_nic_get_link_ksettings(struct net_device *net_dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_handle *h;\r\nu32 link_stat;\r\nint ret;\r\nu8 duplex;\r\nu16 speed;\r\nu32 supported, advertising;\r\nif (!priv || !priv->ae_handle)\r\nreturn -ESRCH;\r\nh = priv->ae_handle;\r\nif (!h->dev || !h->dev->ops || !h->dev->ops->get_info)\r\nreturn -ESRCH;\r\nret = h->dev->ops->get_info(h, NULL, &speed, &duplex);\r\nif (ret < 0) {\r\nnetdev_err(net_dev, "%s get_info error!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nethtool_convert_link_mode_to_legacy_u32(&supported,\r\ncmd->link_modes.supported);\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\ncmd->base.autoneg = false;\r\ncmd->base.cmd = speed;\r\ncmd->base.duplex = duplex;\r\nif (net_dev->phydev)\r\n(void)phy_ethtool_ksettings_get(net_dev->phydev, cmd);\r\nlink_stat = hns_nic_get_link(net_dev);\r\nif (!link_stat) {\r\ncmd->base.speed = (u32)SPEED_UNKNOWN;\r\ncmd->base.duplex = DUPLEX_UNKNOWN;\r\n}\r\nif (cmd->base.autoneg)\r\nadvertising |= ADVERTISED_Autoneg;\r\nsupported |= h->if_support;\r\nif (h->phy_if == PHY_INTERFACE_MODE_SGMII) {\r\nsupported |= SUPPORTED_TP;\r\nadvertising |= ADVERTISED_1000baseT_Full;\r\n} else if (h->phy_if == PHY_INTERFACE_MODE_XGMII) {\r\nsupported |= SUPPORTED_FIBRE;\r\nadvertising |= ADVERTISED_10000baseKR_Full;\r\n}\r\nswitch (h->media_type) {\r\ncase HNAE_MEDIA_TYPE_FIBER:\r\ncmd->base.port = PORT_FIBRE;\r\nbreak;\r\ncase HNAE_MEDIA_TYPE_COPPER:\r\ncmd->base.port = PORT_TP;\r\nbreak;\r\ncase HNAE_MEDIA_TYPE_UNKNOWN:\r\ndefault:\r\nbreak;\r\n}\r\nif (!(AE_IS_VER1(priv->enet_ver) && h->port_type == HNAE_PORT_DEBUG))\r\nsupported |= SUPPORTED_Pause;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\ncmd->base.mdio_support = ETH_MDIO_SUPPORTS_C45 | ETH_MDIO_SUPPORTS_C22;\r\nhns_get_mdix_mode(net_dev, cmd);\r\nreturn 0;\r\n}\r\nstatic int hns_nic_set_link_ksettings(struct net_device *net_dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_handle *h;\r\nu32 speed;\r\nif (!netif_running(net_dev))\r\nreturn -ESRCH;\r\nif (!priv || !priv->ae_handle || !priv->ae_handle->dev ||\r\n!priv->ae_handle->dev->ops)\r\nreturn -ENODEV;\r\nh = priv->ae_handle;\r\nspeed = cmd->base.speed;\r\nif (h->phy_if == PHY_INTERFACE_MODE_XGMII) {\r\nif (cmd->base.autoneg == AUTONEG_ENABLE ||\r\nspeed != SPEED_10000 ||\r\ncmd->base.duplex != DUPLEX_FULL)\r\nreturn -EINVAL;\r\n} else if (h->phy_if == PHY_INTERFACE_MODE_SGMII) {\r\nif (!net_dev->phydev && cmd->base.autoneg == AUTONEG_ENABLE)\r\nreturn -EINVAL;\r\nif (speed == SPEED_1000 && cmd->base.duplex == DUPLEX_HALF)\r\nreturn -EINVAL;\r\nif (net_dev->phydev)\r\nreturn phy_ethtool_ksettings_set(net_dev->phydev, cmd);\r\nif ((speed != SPEED_10 && speed != SPEED_100 &&\r\nspeed != SPEED_1000) || (cmd->base.duplex != DUPLEX_HALF &&\r\ncmd->base.duplex != DUPLEX_FULL))\r\nreturn -EINVAL;\r\n} else {\r\nnetdev_err(net_dev, "Not supported!");\r\nreturn -ENOTSUPP;\r\n}\r\nif (h->dev->ops->adjust_link) {\r\nh->dev->ops->adjust_link(h, (int)speed, cmd->base.duplex);\r\nreturn 0;\r\n}\r\nnetdev_err(net_dev, "Not supported!");\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int hns_nic_config_phy_loopback(struct phy_device *phy_dev, u8 en)\r\n{\r\n#define COPPER_CONTROL_REG 0\r\n#define PHY_POWER_DOWN BIT(11)\r\n#define PHY_LOOP_BACK BIT(14)\r\nu16 val = 0;\r\nif (phy_dev->is_c45)\r\nreturn -ENOTSUPP;\r\nif (en) {\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 2);\r\nphy_write(phy_dev, 21, 0x1046);\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 0);\r\nphy_write(phy_dev, 9, 0x1F00);\r\nphy_write(phy_dev, 0, 0x9140);\r\nphy_write(phy_dev, 0, 0x9140);\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 0xFA);\r\nphy_write(phy_dev, 1, 0x418);\r\nphy_write(phy_dev, 7, 0x20C);\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 0);\r\nval = phy_read(phy_dev, COPPER_CONTROL_REG);\r\nval |= PHY_LOOP_BACK;\r\nval &= ~PHY_POWER_DOWN;\r\nphy_write(phy_dev, COPPER_CONTROL_REG, val);\r\n} else {\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 0xFA);\r\nphy_write(phy_dev, 1, 0x400);\r\nphy_write(phy_dev, 7, 0x200);\r\nphy_write(phy_dev, HNS_PHY_PAGE_REG, 0);\r\nphy_write(phy_dev, 9, 0xF00);\r\nval = phy_read(phy_dev, COPPER_CONTROL_REG);\r\nval &= ~PHY_LOOP_BACK;\r\nval |= PHY_POWER_DOWN;\r\nphy_write(phy_dev, COPPER_CONTROL_REG, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __lb_setup(struct net_device *ndev,\r\nenum hnae_loop loop)\r\n{\r\nint ret = 0;\r\nstruct hns_nic_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phy_dev = ndev->phydev;\r\nstruct hnae_handle *h = priv->ae_handle;\r\nswitch (loop) {\r\ncase MAC_INTERNALLOOP_PHY:\r\nif ((phy_dev) && (!phy_dev->is_c45)) {\r\nret = hns_nic_config_phy_loopback(phy_dev, 0x1);\r\nret |= h->dev->ops->set_loopback(h, loop, 0x1);\r\n}\r\nbreak;\r\ncase MAC_INTERNALLOOP_MAC:\r\nif ((h->dev->ops->set_loopback) &&\r\n(priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII))\r\nret = h->dev->ops->set_loopback(h, loop, 0x1);\r\nbreak;\r\ncase MAC_INTERNALLOOP_SERDES:\r\nif (h->dev->ops->set_loopback)\r\nret = h->dev->ops->set_loopback(h, loop, 0x1);\r\nbreak;\r\ncase MAC_LOOP_NONE:\r\nif ((phy_dev) && (!phy_dev->is_c45))\r\nret |= hns_nic_config_phy_loopback(phy_dev, 0x0);\r\nif (h->dev->ops->set_loopback) {\r\nif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)\r\nret |= h->dev->ops->set_loopback(h,\r\nMAC_INTERNALLOOP_MAC, 0x0);\r\nret |= h->dev->ops->set_loopback(h,\r\nMAC_INTERNALLOOP_SERDES, 0x0);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!ret) {\r\nif (loop == MAC_LOOP_NONE)\r\nh->dev->ops->set_promisc_mode(\r\nh, ndev->flags & IFF_PROMISC);\r\nelse\r\nh->dev->ops->set_promisc_mode(h, 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __lb_up(struct net_device *ndev,\r\nenum hnae_loop loop_mode)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(ndev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nint speed, duplex;\r\nint ret;\r\nhns_nic_net_reset(ndev);\r\nret = __lb_setup(ndev, loop_mode);\r\nif (ret)\r\nreturn ret;\r\nmsleep(200);\r\nret = h->dev->ops->start ? h->dev->ops->start(h) : 0;\r\nif (ret)\r\nreturn ret;\r\nif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII)\r\nspeed = 1000;\r\nelse\r\nspeed = 10000;\r\nduplex = 1;\r\nh->dev->ops->adjust_link(h, speed, duplex);\r\nreturn 0;\r\n}\r\nstatic void __lb_other_process(struct hns_nic_ring_data *ring_data,\r\nstruct sk_buff *skb)\r\n{\r\nstruct net_device *ndev;\r\nstruct hns_nic_priv *priv;\r\nstruct hnae_ring *ring;\r\nstruct netdev_queue *dev_queue;\r\nstruct sk_buff *new_skb;\r\nunsigned int frame_size;\r\nint check_ok;\r\nu32 i;\r\nchar buff[33];\r\nif (!ring_data) {\r\nndev = skb->dev;\r\npriv = netdev_priv(ndev);\r\nframe_size = skb->len;\r\nmemset(skb->data, 0xFF, frame_size);\r\nif ((!AE_IS_VER1(priv->enet_ver)) &&\r\n(priv->ae_handle->port_type == HNAE_PORT_SERVICE)) {\r\nmemcpy(skb->data, ndev->dev_addr, 6);\r\nskb->data[5] += 0x1f;\r\n}\r\nframe_size &= ~1ul;\r\nmemset(&skb->data[frame_size / 2], 0xAA, frame_size / 2 - 1);\r\nmemset(&skb->data[frame_size / 2 + 10], 0xBE,\r\nframe_size / 2 - 11);\r\nmemset(&skb->data[frame_size / 2 + 12], 0xAF,\r\nframe_size / 2 - 13);\r\nreturn;\r\n}\r\nring = ring_data->ring;\r\nndev = ring_data->napi.dev;\r\nif (is_tx_ring(ring)) {\r\ndev_queue = netdev_get_tx_queue(ndev, ring_data->queue_index);\r\nnetdev_tx_reset_queue(dev_queue);\r\nreturn;\r\n}\r\nframe_size = skb->len;\r\nframe_size &= ~1ul;\r\nnew_skb = skb_copy(skb, GFP_ATOMIC);\r\ndev_kfree_skb_any(skb);\r\nskb = new_skb;\r\ncheck_ok = 0;\r\nif (*(skb->data + 10) == 0xFF) {\r\nif ((*(skb->data + frame_size / 2 + 10) == 0xBE) &&\r\n(*(skb->data + frame_size / 2 + 12) == 0xAF))\r\ncheck_ok = 1;\r\n}\r\nif (check_ok) {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += skb->len;\r\n} else {\r\nndev->stats.rx_frame_errors++;\r\nfor (i = 0; i < skb->len; i++) {\r\nsnprintf(buff + i % 16 * 2, 3,\r\n"%02x", *(skb->data + i));\r\nif ((i % 16 == 15) || (i == skb->len - 1))\r\npr_info("%s\n", buff);\r\n}\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int __lb_clean_rings(struct hns_nic_priv *priv,\r\nint ringid0, int ringid1, int budget)\r\n{\r\nint i, ret;\r\nstruct hns_nic_ring_data *ring_data;\r\nstruct net_device *ndev = priv->netdev;\r\nunsigned long rx_packets = ndev->stats.rx_packets;\r\nunsigned long rx_bytes = ndev->stats.rx_bytes;\r\nunsigned long rx_frame_errors = ndev->stats.rx_frame_errors;\r\nfor (i = ringid0; i <= ringid1; i++) {\r\nring_data = &priv->ring_data[i];\r\n(void)ring_data->poll_one(ring_data,\r\nbudget, __lb_other_process);\r\n}\r\nret = (int)(ndev->stats.rx_packets - rx_packets);\r\nndev->stats.rx_packets = rx_packets;\r\nndev->stats.rx_bytes = rx_bytes;\r\nndev->stats.rx_frame_errors = rx_frame_errors;\r\nreturn ret;\r\n}\r\nstatic int __lb_run_test(struct net_device *ndev,\r\nenum hnae_loop loop_mode)\r\n{\r\n#define NIC_LB_TEST_PKT_NUM_PER_CYCLE 1\r\n#define NIC_LB_TEST_RING_ID 0\r\n#define NIC_LB_TEST_FRAME_SIZE 128\r\n#define NIC_LB_TEST_NO_MEM_ERR 1\r\n#define NIC_LB_TEST_TX_CNT_ERR 2\r\n#define NIC_LB_TEST_RX_CNT_ERR 3\r\n#define NIC_LB_TEST_RX_PKG_ERR 4\r\nstruct hns_nic_priv *priv = netdev_priv(ndev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nint i, j, lc, good_cnt, ret_val = 0;\r\nunsigned int size;\r\nnetdev_tx_t tx_ret_val;\r\nstruct sk_buff *skb;\r\nsize = NIC_LB_TEST_FRAME_SIZE;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (!skb)\r\nreturn NIC_LB_TEST_NO_MEM_ERR;\r\n(void)skb_put(skb, size);\r\nskb->dev = ndev;\r\n__lb_other_process(NULL, skb);\r\nskb->queue_mapping = NIC_LB_TEST_RING_ID;\r\nlc = 1;\r\nfor (j = 0; j < lc; j++) {\r\ngood_cnt = 0;\r\nfor (i = 0; i < NIC_LB_TEST_PKT_NUM_PER_CYCLE; i++) {\r\n(void)skb_get(skb);\r\ntx_ret_val = (netdev_tx_t)hns_nic_net_xmit_hw(\r\nndev, skb,\r\n&tx_ring_data(priv, skb->queue_mapping));\r\nif (tx_ret_val == NETDEV_TX_OK)\r\ngood_cnt++;\r\nelse\r\nbreak;\r\n}\r\nif (good_cnt != NIC_LB_TEST_PKT_NUM_PER_CYCLE) {\r\nret_val = NIC_LB_TEST_TX_CNT_ERR;\r\ndev_err(priv->dev, "%s sent fail, cnt=0x%x, budget=0x%x\n",\r\nhns_nic_test_strs[loop_mode], good_cnt,\r\nNIC_LB_TEST_PKT_NUM_PER_CYCLE);\r\nbreak;\r\n}\r\nmsleep(100);\r\ngood_cnt = __lb_clean_rings(priv,\r\nh->q_num, h->q_num * 2 - 1,\r\nNIC_LB_TEST_PKT_NUM_PER_CYCLE);\r\nif (good_cnt != NIC_LB_TEST_PKT_NUM_PER_CYCLE) {\r\nret_val = NIC_LB_TEST_RX_CNT_ERR;\r\ndev_err(priv->dev, "%s recv fail, cnt=0x%x, budget=0x%x\n",\r\nhns_nic_test_strs[loop_mode], good_cnt,\r\nNIC_LB_TEST_PKT_NUM_PER_CYCLE);\r\nbreak;\r\n}\r\n(void)__lb_clean_rings(priv,\r\nNIC_LB_TEST_RING_ID, NIC_LB_TEST_RING_ID,\r\nNIC_LB_TEST_PKT_NUM_PER_CYCLE);\r\n}\r\nkfree_skb(skb);\r\nreturn ret_val;\r\n}\r\nstatic int __lb_down(struct net_device *ndev)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(ndev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nint ret;\r\nret = __lb_setup(ndev, MAC_LOOP_NONE);\r\nif (ret)\r\nnetdev_err(ndev, "%s: __lb_setup return error(%d)!\n",\r\n__func__,\r\nret);\r\nif (h->dev->ops->stop)\r\nh->dev->ops->stop(h);\r\nusleep_range(10000, 20000);\r\n(void)__lb_clean_rings(priv, 0, h->q_num - 1, 256);\r\nhns_nic_net_reset(ndev);\r\nreturn 0;\r\n}\r\nstatic void hns_nic_self_test(struct net_device *ndev,\r\nstruct ethtool_test *eth_test, u64 *data)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(ndev);\r\nbool if_running = netif_running(ndev);\r\n#define SELF_TEST_TPYE_NUM 3\r\nint st_param[SELF_TEST_TPYE_NUM][2];\r\nint i;\r\nint test_index = 0;\r\nst_param[0][0] = MAC_INTERNALLOOP_MAC;\r\nst_param[0][1] = (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII);\r\nst_param[1][0] = MAC_INTERNALLOOP_SERDES;\r\nst_param[1][1] = 1;\r\nst_param[2][0] = MAC_INTERNALLOOP_PHY;\r\nst_param[2][1] = ((!!(priv->ae_handle->phy_dev)) &&\r\n(priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII));\r\nif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\r\nset_bit(NIC_STATE_TESTING, &priv->state);\r\nif (if_running)\r\n(void)dev_close(ndev);\r\nfor (i = 0; i < SELF_TEST_TPYE_NUM; i++) {\r\nif (!st_param[i][1])\r\ncontinue;\r\ndata[test_index] = __lb_up(ndev,\r\n(enum hnae_loop)st_param[i][0]);\r\nif (!data[test_index]) {\r\ndata[test_index] = __lb_run_test(\r\nndev, (enum hnae_loop)st_param[i][0]);\r\n(void)__lb_down(ndev);\r\n}\r\nif (data[test_index])\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ntest_index++;\r\n}\r\nhns_nic_net_reset(priv->netdev);\r\nclear_bit(NIC_STATE_TESTING, &priv->state);\r\nif (if_running)\r\n(void)dev_open(ndev);\r\n}\r\n(void)msleep_interruptible(4 * 1000);\r\n}\r\nstatic void hns_nic_get_drvinfo(struct net_device *net_dev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstrncpy(drvinfo->version, HNAE_DRIVER_VERSION,\r\nsizeof(drvinfo->version));\r\ndrvinfo->version[sizeof(drvinfo->version) - 1] = '\0';\r\nstrncpy(drvinfo->driver, HNAE_DRIVER_NAME, sizeof(drvinfo->driver));\r\ndrvinfo->driver[sizeof(drvinfo->driver) - 1] = '\0';\r\nstrncpy(drvinfo->bus_info, priv->dev->bus->name,\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->bus_info[ETHTOOL_BUSINFO_LEN - 1] = '\0';\r\nstrncpy(drvinfo->fw_version, "N/A", ETHTOOL_FWVERS_LEN);\r\ndrvinfo->eedump_len = 0;\r\n}\r\nvoid hns_get_ringparam(struct net_device *net_dev,\r\nstruct ethtool_ringparam *param)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nstruct hnae_queue *queue;\r\nu32 uplimit = 0;\r\nqueue = priv->ae_handle->qs[0];\r\nops = priv->ae_handle->dev->ops;\r\nif (ops->get_ring_bdnum_limit)\r\nops->get_ring_bdnum_limit(queue, &uplimit);\r\nparam->rx_max_pending = uplimit;\r\nparam->tx_max_pending = uplimit;\r\nparam->rx_pending = queue->rx_ring.desc_num;\r\nparam->tx_pending = queue->tx_ring.desc_num;\r\n}\r\nstatic void hns_get_pauseparam(struct net_device *net_dev,\r\nstruct ethtool_pauseparam *param)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nops = priv->ae_handle->dev->ops;\r\nif (ops->get_pauseparam)\r\nops->get_pauseparam(priv->ae_handle, &param->autoneg,\r\n&param->rx_pause, &param->tx_pause);\r\n}\r\nstatic int hns_set_pauseparam(struct net_device *net_dev,\r\nstruct ethtool_pauseparam *param)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_handle *h;\r\nstruct hnae_ae_ops *ops;\r\nh = priv->ae_handle;\r\nops = h->dev->ops;\r\nif (!ops->set_pauseparam)\r\nreturn -ESRCH;\r\nreturn ops->set_pauseparam(priv->ae_handle, param->autoneg,\r\nparam->rx_pause, param->tx_pause);\r\n}\r\nstatic int hns_get_coalesce(struct net_device *net_dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nops = priv->ae_handle->dev->ops;\r\nec->use_adaptive_rx_coalesce = 1;\r\nec->use_adaptive_tx_coalesce = 1;\r\nif ((!ops->get_coalesce_usecs) ||\r\n(!ops->get_rx_max_coalesced_frames))\r\nreturn -ESRCH;\r\nops->get_coalesce_usecs(priv->ae_handle,\r\n&ec->tx_coalesce_usecs,\r\n&ec->rx_coalesce_usecs);\r\nops->get_rx_max_coalesced_frames(\r\npriv->ae_handle,\r\n&ec->tx_max_coalesced_frames,\r\n&ec->rx_max_coalesced_frames);\r\nops->get_coalesce_range(priv->ae_handle,\r\n&ec->tx_max_coalesced_frames_low,\r\n&ec->rx_max_coalesced_frames_low,\r\n&ec->tx_max_coalesced_frames_high,\r\n&ec->rx_max_coalesced_frames_high,\r\n&ec->tx_coalesce_usecs_low,\r\n&ec->rx_coalesce_usecs_low,\r\n&ec->tx_coalesce_usecs_high,\r\n&ec->rx_coalesce_usecs_high);\r\nreturn 0;\r\n}\r\nstatic int hns_set_coalesce(struct net_device *net_dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nint ret;\r\nops = priv->ae_handle->dev->ops;\r\nif (ec->tx_coalesce_usecs != ec->rx_coalesce_usecs)\r\nreturn -EINVAL;\r\nif (ec->rx_max_coalesced_frames != ec->tx_max_coalesced_frames)\r\nreturn -EINVAL;\r\nif ((!ops->set_coalesce_usecs) ||\r\n(!ops->set_coalesce_frames))\r\nreturn -ESRCH;\r\nret = ops->set_coalesce_usecs(priv->ae_handle,\r\nec->rx_coalesce_usecs);\r\nif (ret)\r\nreturn ret;\r\nret = ops->set_coalesce_frames(\r\npriv->ae_handle,\r\nec->rx_max_coalesced_frames);\r\nreturn ret;\r\n}\r\nvoid hns_get_channels(struct net_device *net_dev, struct ethtool_channels *ch)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nch->max_rx = priv->ae_handle->q_num;\r\nch->max_tx = priv->ae_handle->q_num;\r\nch->rx_count = priv->ae_handle->q_num;\r\nch->tx_count = priv->ae_handle->q_num;\r\n}\r\nvoid hns_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nu64 *p = data;\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nconst struct rtnl_link_stats64 *net_stats;\r\nstruct rtnl_link_stats64 temp;\r\nif (!h->dev->ops->get_stats || !h->dev->ops->update_stats) {\r\nnetdev_err(netdev, "get_stats or update_stats is null!\n");\r\nreturn;\r\n}\r\nh->dev->ops->update_stats(h, &netdev->stats);\r\nnet_stats = dev_get_stats(netdev, &temp);\r\np[0] = net_stats->rx_packets;\r\np[1] = net_stats->tx_packets;\r\np[2] = net_stats->rx_bytes;\r\np[3] = net_stats->tx_bytes;\r\np[4] = net_stats->rx_errors;\r\np[5] = net_stats->tx_errors;\r\np[6] = net_stats->rx_dropped;\r\np[7] = net_stats->tx_dropped;\r\np[8] = net_stats->multicast;\r\np[9] = net_stats->collisions;\r\np[10] = net_stats->rx_over_errors;\r\np[11] = net_stats->rx_crc_errors;\r\np[12] = net_stats->rx_frame_errors;\r\np[13] = net_stats->rx_fifo_errors;\r\np[14] = net_stats->rx_missed_errors;\r\np[15] = net_stats->tx_aborted_errors;\r\np[16] = net_stats->tx_carrier_errors;\r\np[17] = net_stats->tx_fifo_errors;\r\np[18] = net_stats->tx_heartbeat_errors;\r\np[19] = net_stats->rx_length_errors;\r\np[20] = net_stats->tx_window_errors;\r\np[21] = net_stats->rx_compressed;\r\np[22] = net_stats->tx_compressed;\r\np[23] = netdev->rx_dropped.counter;\r\np[24] = netdev->tx_dropped.counter;\r\np[25] = priv->tx_timeout_count;\r\nh->dev->ops->get_stats(h, &p[26]);\r\n}\r\nvoid hns_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nchar *buff = (char *)data;\r\nif (!h->dev->ops->get_strings) {\r\nnetdev_err(netdev, "h->dev->ops->get_strings is null!\n");\r\nreturn;\r\n}\r\nif (stringset == ETH_SS_TEST) {\r\nif (priv->ae_handle->phy_if != PHY_INTERFACE_MODE_XGMII) {\r\nmemcpy(buff, hns_nic_test_strs[MAC_INTERNALLOOP_MAC],\r\nETH_GSTRING_LEN);\r\nbuff += ETH_GSTRING_LEN;\r\n}\r\nmemcpy(buff, hns_nic_test_strs[MAC_INTERNALLOOP_SERDES],\r\nETH_GSTRING_LEN);\r\nbuff += ETH_GSTRING_LEN;\r\nif ((netdev->phydev) && (!netdev->phydev->is_c45))\r\nmemcpy(buff, hns_nic_test_strs[MAC_INTERNALLOOP_PHY],\r\nETH_GSTRING_LEN);\r\n} else {\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_packets");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_packets");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_bytes");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_bytes");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_dropped");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_dropped");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "multicast");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "collisions");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_over_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_crc_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_frame_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_fifo_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_missed_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_aborted_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_carrier_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_fifo_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_heartbeat_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_length_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_window_errors");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "rx_compressed");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "tx_compressed");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "netdev_rx_dropped");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "netdev_tx_dropped");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nsnprintf(buff, ETH_GSTRING_LEN, "netdev_tx_timeout");\r\nbuff = buff + ETH_GSTRING_LEN;\r\nh->dev->ops->get_strings(h, stringset, (u8 *)buff);\r\n}\r\n}\r\nint hns_get_sset_count(struct net_device *netdev, int stringset)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nstruct hnae_ae_ops *ops = h->dev->ops;\r\nif (!ops->get_sset_count) {\r\nnetdev_err(netdev, "get_sset_count is null!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (stringset == ETH_SS_TEST) {\r\nu32 cnt = (sizeof(hns_nic_test_strs) / ETH_GSTRING_LEN);\r\nif (priv->ae_handle->phy_if == PHY_INTERFACE_MODE_XGMII)\r\ncnt--;\r\nif ((!netdev->phydev) || (netdev->phydev->is_c45))\r\ncnt--;\r\nreturn cnt;\r\n} else {\r\nreturn (HNS_NET_STATS_CNT + ops->get_sset_count(h, stringset));\r\n}\r\n}\r\nint hns_phy_led_set(struct net_device *netdev, int value)\r\n{\r\nint retval;\r\nstruct phy_device *phy_dev = netdev->phydev;\r\nretval = phy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_LED);\r\nretval |= phy_write(phy_dev, HNS_LED_FC_REG, value);\r\nretval |= phy_write(phy_dev, HNS_PHY_PAGE_REG, HNS_PHY_PAGE_COPPER);\r\nif (retval) {\r\nnetdev_err(netdev, "mdiobus_write fail !\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nint hns_set_phys_id(struct net_device *netdev, enum ethtool_phys_id_state state)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_handle *h = priv->ae_handle;\r\nstruct phy_device *phy_dev = netdev->phydev;\r\nint ret;\r\nif (phy_dev)\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\r\nHNS_PHY_PAGE_LED);\r\nif (ret)\r\nreturn ret;\r\npriv->phy_led_val = phy_read(phy_dev, HNS_LED_FC_REG);\r\nret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\r\nHNS_PHY_PAGE_COPPER);\r\nif (ret)\r\nreturn ret;\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\nret = hns_phy_led_set(netdev, HNS_LED_FORCE_ON);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nret = hns_phy_led_set(netdev, HNS_LED_FORCE_OFF);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\r\nHNS_PHY_PAGE_LED);\r\nif (ret)\r\nreturn ret;\r\nret = phy_write(phy_dev, HNS_LED_FC_REG,\r\npriv->phy_led_val);\r\nif (ret)\r\nreturn ret;\r\nret = phy_write(phy_dev, HNS_PHY_PAGE_REG,\r\nHNS_PHY_PAGE_COPPER);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nelse\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nreturn h->dev->ops->set_led_id(h, HNAE_LED_ACTIVE);\r\ncase ETHTOOL_ID_ON:\r\nreturn h->dev->ops->set_led_id(h, HNAE_LED_ON);\r\ncase ETHTOOL_ID_OFF:\r\nreturn h->dev->ops->set_led_id(h, HNAE_LED_OFF);\r\ncase ETHTOOL_ID_INACTIVE:\r\nreturn h->dev->ops->set_led_id(h, HNAE_LED_INACTIVE);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid hns_get_regs(struct net_device *net_dev, struct ethtool_regs *cmd,\r\nvoid *data)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nops = priv->ae_handle->dev->ops;\r\ncmd->version = HNS_CHIP_VERSION;\r\nif (!ops->get_regs) {\r\nnetdev_err(net_dev, "ops->get_regs is null!\n");\r\nreturn;\r\n}\r\nops->get_regs(priv->ae_handle, data);\r\n}\r\nstatic int hns_get_regs_len(struct net_device *net_dev)\r\n{\r\nu32 reg_num;\r\nstruct hns_nic_priv *priv = netdev_priv(net_dev);\r\nstruct hnae_ae_ops *ops;\r\nops = priv->ae_handle->dev->ops;\r\nif (!ops->get_regs_len) {\r\nnetdev_err(net_dev, "ops->get_regs_len is null!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nreg_num = ops->get_regs_len(priv->ae_handle);\r\nif (reg_num > 0)\r\nreturn reg_num * sizeof(u32);\r\nelse\r\nreturn reg_num;\r\n}\r\nstatic int hns_nic_nway_reset(struct net_device *netdev)\r\n{\r\nint ret = 0;\r\nstruct phy_device *phy = netdev->phydev;\r\nif (netif_running(netdev)) {\r\nif (phy && phy->autoneg == AUTONEG_ENABLE)\r\nret = genphy_restart_aneg(phy);\r\n}\r\nreturn ret;\r\n}\r\nstatic u32\r\nhns_get_rss_key_size(struct net_device *netdev)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_ae_ops *ops;\r\nif (AE_IS_VER1(priv->enet_ver)) {\r\nnetdev_err(netdev,\r\n"RSS feature is not supported on this hardware\n");\r\nreturn 0;\r\n}\r\nops = priv->ae_handle->dev->ops;\r\nreturn ops->get_rss_key_size(priv->ae_handle);\r\n}\r\nstatic u32\r\nhns_get_rss_indir_size(struct net_device *netdev)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_ae_ops *ops;\r\nif (AE_IS_VER1(priv->enet_ver)) {\r\nnetdev_err(netdev,\r\n"RSS feature is not supported on this hardware\n");\r\nreturn 0;\r\n}\r\nops = priv->ae_handle->dev->ops;\r\nreturn ops->get_rss_indir_size(priv->ae_handle);\r\n}\r\nstatic int\r\nhns_get_rss(struct net_device *netdev, u32 *indir, u8 *key, u8 *hfunc)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_ae_ops *ops;\r\nif (AE_IS_VER1(priv->enet_ver)) {\r\nnetdev_err(netdev,\r\n"RSS feature is not supported on this hardware\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nops = priv->ae_handle->dev->ops;\r\nif (!indir)\r\nreturn 0;\r\nreturn ops->get_rss(priv->ae_handle, indir, key, hfunc);\r\n}\r\nstatic int\r\nhns_set_rss(struct net_device *netdev, const u32 *indir, const u8 *key,\r\nconst u8 hfunc)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nstruct hnae_ae_ops *ops;\r\nif (AE_IS_VER1(priv->enet_ver)) {\r\nnetdev_err(netdev,\r\n"RSS feature is not supported on this hardware\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nops = priv->ae_handle->dev->ops;\r\nif (key ||\r\n(hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\r\nreturn -EOPNOTSUPP;\r\nif (!indir)\r\nreturn 0;\r\nreturn ops->set_rss(priv->ae_handle, indir, key, hfunc);\r\n}\r\nstatic int hns_get_rxnfc(struct net_device *netdev,\r\nstruct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct hns_nic_priv *priv = netdev_priv(netdev);\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = priv->ae_handle->q_num;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nvoid hns_ethtool_set_ops(struct net_device *ndev)\r\n{\r\nndev->ethtool_ops = &hns_ethtool_ops;\r\n}
