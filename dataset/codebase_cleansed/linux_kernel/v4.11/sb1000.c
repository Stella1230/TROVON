static int\r\nsb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)\r\n{\r\nstruct net_device *dev;\r\nunsigned short ioaddr[2], irq;\r\nunsigned int serial_number;\r\nint error = -ENODEV;\r\nif (pnp_device_attach(pdev) < 0)\r\nreturn -ENODEV;\r\nif (pnp_activate_dev(pdev) < 0)\r\ngoto out_detach;\r\nif (!pnp_port_valid(pdev, 0) || !pnp_port_valid(pdev, 1))\r\ngoto out_disable;\r\nif (!pnp_irq_valid(pdev, 0))\r\ngoto out_disable;\r\nserial_number = pdev->card->serial;\r\nioaddr[0] = pnp_port_start(pdev, 0);\r\nioaddr[1] = pnp_port_start(pdev, 0);\r\nirq = pnp_irq(pdev, 0);\r\nif (!request_region(ioaddr[0], 16, "sb1000"))\r\ngoto out_disable;\r\nif (!request_region(ioaddr[1], 16, "sb1000"))\r\ngoto out_release_region0;\r\ndev = alloc_etherdev(sizeof(struct sb1000_private));\r\nif (!dev) {\r\nerror = -ENOMEM;\r\ngoto out_release_regions;\r\n}\r\ndev->base_addr = ioaddr[0];\r\ndev->mem_start = ioaddr[1];\r\ndev->irq = irq;\r\nif (sb1000_debug > 0)\r\nprintk(KERN_NOTICE "%s: sb1000 at (%#3.3lx,%#3.3lx), "\r\n"S/N %#8.8x, IRQ %d.\n", dev->name, dev->base_addr,\r\ndev->mem_start, serial_number, dev->irq);\r\ndev->flags = IFF_POINTOPOINT|IFF_NOARP;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nif (sb1000_debug > 0)\r\nprintk(KERN_NOTICE "%s", version);\r\ndev->netdev_ops = &sb1000_netdev_ops;\r\ndev->dev_addr[2] = serial_number >> 24 & 0xff;\r\ndev->dev_addr[3] = serial_number >> 16 & 0xff;\r\ndev->dev_addr[4] = serial_number >> 8 & 0xff;\r\ndev->dev_addr[5] = serial_number >> 0 & 0xff;\r\npnp_set_drvdata(pdev, dev);\r\nerror = register_netdev(dev);\r\nif (error)\r\ngoto out_free_netdev;\r\nreturn 0;\r\nout_free_netdev:\r\nfree_netdev(dev);\r\nout_release_regions:\r\nrelease_region(ioaddr[1], 16);\r\nout_release_region0:\r\nrelease_region(ioaddr[0], 16);\r\nout_disable:\r\npnp_disable_dev(pdev);\r\nout_detach:\r\npnp_device_detach(pdev);\r\nreturn error;\r\n}\r\nstatic void\r\nsb1000_remove_one(struct pnp_dev *pdev)\r\n{\r\nstruct net_device *dev = pnp_get_drvdata(pdev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, 16);\r\nrelease_region(dev->mem_start, 16);\r\nfree_netdev(dev);\r\n}\r\nstatic int\r\ncard_wait_for_busy_clear(const int ioaddr[], const char* name)\r\n{\r\nunsigned char a;\r\nunsigned long timeout;\r\na = inb(ioaddr[0] + 7);\r\ntimeout = jiffies + TimeOutJiffies;\r\nwhile (a & 0x80 || a & 0x40) {\r\nyield();\r\na = inb(ioaddr[0] + 7);\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: card_wait_for_busy_clear timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncard_wait_for_ready(const int ioaddr[], const char* name, unsigned char in[])\r\n{\r\nunsigned char a;\r\nunsigned long timeout;\r\na = inb(ioaddr[1] + 6);\r\ntimeout = jiffies + TimeOutJiffies;\r\nwhile (a & 0x80 || !(a & 0x40)) {\r\nyield();\r\na = inb(ioaddr[1] + 6);\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: card_wait_for_ready timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\nin[1] = inb(ioaddr[0] + 1);\r\nin[2] = inb(ioaddr[0] + 2);\r\nin[3] = inb(ioaddr[0] + 3);\r\nin[4] = inb(ioaddr[0] + 4);\r\nin[0] = inb(ioaddr[0] + 5);\r\nin[6] = inb(ioaddr[0] + 6);\r\nin[5] = inb(ioaddr[1] + 6);\r\nreturn 0;\r\n}\r\nstatic int\r\ncard_send_command(const int ioaddr[], const char* name,\r\nconst unsigned char out[], unsigned char in[])\r\n{\r\nint status, x;\r\nif ((status = card_wait_for_busy_clear(ioaddr, name)))\r\nreturn status;\r\noutb(0xa0, ioaddr[0] + 6);\r\noutb(out[2], ioaddr[0] + 1);\r\noutb(out[3], ioaddr[0] + 2);\r\noutb(out[4], ioaddr[0] + 3);\r\noutb(out[5], ioaddr[0] + 4);\r\noutb(out[1], ioaddr[0] + 5);\r\noutb(0xa0, ioaddr[0] + 6);\r\noutb(out[0], ioaddr[0] + 7);\r\nif (out[0] != 0x20 && out[0] != 0x30) {\r\nif ((status = card_wait_for_ready(ioaddr, name, in)))\r\nreturn status;\r\ninb(ioaddr[0] + 7);\r\nif (sb1000_debug > 3)\r\nprintk(KERN_DEBUG "%s: card_send_command "\r\n"out: %02x%02x%02x%02x%02x%02x "\r\n"in: %02x%02x%02x%02x%02x%02x%02x\n", name,\r\nout[0], out[1], out[2], out[3], out[4], out[5],\r\nin[0], in[1], in[2], in[3], in[4], in[5], in[6]);\r\n} else {\r\nif (sb1000_debug > 3)\r\nprintk(KERN_DEBUG "%s: card_send_command "\r\n"out: %02x%02x%02x%02x%02x%02x\n", name,\r\nout[0], out[1], out[2], out[3], out[4], out[5]);\r\n}\r\nif (out[1] == 0x1b) {\r\nx = (out[2] == 0x02);\r\n} else {\r\nif (out[0] >= 0x80 && in[0] != (out[1] | 0x80))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsb1000_wait_for_ready(const int ioaddr[], const char* name)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + Sb1000TimeOutJiffies;\r\nwhile (inb(ioaddr[1] + 6) & 0x80) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\ntimeout = jiffies + Sb1000TimeOutJiffies;\r\nwhile (!(inb(ioaddr[1] + 6) & 0x40)) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: sb1000_wait_for_ready timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\ninb(ioaddr[0] + 7);\r\nreturn 0;\r\n}\r\nstatic int\r\nsb1000_wait_for_ready_clear(const int ioaddr[], const char* name)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + Sb1000TimeOutJiffies;\r\nwhile (inb(ioaddr[1] + 6) & 0x80) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\ntimeout = jiffies + Sb1000TimeOutJiffies;\r\nwhile (inb(ioaddr[1] + 6) & 0x40) {\r\nif (time_after_eq(jiffies, timeout)) {\r\nprintk(KERN_WARNING "%s: sb1000_wait_for_ready_clear timeout\n",\r\nname);\r\nreturn -ETIME;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsb1000_send_command(const int ioaddr[], const char* name,\r\nconst unsigned char out[])\r\n{\r\noutb(out[2], ioaddr[0] + 1);\r\noutb(out[3], ioaddr[0] + 2);\r\noutb(out[4], ioaddr[0] + 3);\r\noutb(out[5], ioaddr[0] + 4);\r\noutb(out[1], ioaddr[0] + 5);\r\noutb(out[0], ioaddr[0] + 7);\r\nif (sb1000_debug > 3)\r\nprintk(KERN_DEBUG "%s: sb1000_send_command out: %02x%02x%02x%02x"\r\n"%02x%02x\n", name, out[0], out[1], out[2], out[3], out[4], out[5]);\r\n}\r\nstatic void\r\nsb1000_read_status(const int ioaddr[], unsigned char in[])\r\n{\r\nin[1] = inb(ioaddr[0] + 1);\r\nin[2] = inb(ioaddr[0] + 2);\r\nin[3] = inb(ioaddr[0] + 3);\r\nin[4] = inb(ioaddr[0] + 4);\r\nin[0] = inb(ioaddr[0] + 5);\r\n}\r\nstatic void\r\nsb1000_issue_read_command(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};\r\nsb1000_wait_for_ready_clear(ioaddr, name);\r\noutb(0xa0, ioaddr[0] + 6);\r\nsb1000_send_command(ioaddr, name, Command0);\r\n}\r\nstatic int\r\nsb1000_reset(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint port, status;\r\nport = ioaddr[1] + 6;\r\noutb(0x4, port);\r\ninb(port);\r\nudelay(1000);\r\noutb(0x0, port);\r\ninb(port);\r\nssleep(1);\r\noutb(0x4, port);\r\ninb(port);\r\nudelay(1000);\r\noutb(0x0, port);\r\ninb(port);\r\nudelay(0);\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nif (st[3] != 0xf0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nsb1000_check_CRC(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint crc, status;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nif (st[1] != st[3] || st[2] != st[4])\r\nreturn -EIO;\r\ncrc = st[1] << 8 | st[2];\r\nreturn 0;\r\n}\r\nstatic inline int\r\nsb1000_start_get_set_command(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x1b, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nreturn card_send_command(ioaddr, name, Command0, st);\r\n}\r\nstatic int\r\nsb1000_end_get_set_command(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x1b, 0x02, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command1[6] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint status;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nreturn card_send_command(ioaddr, name, Command1, st);\r\n}\r\nstatic int\r\nsb1000_activate(const int ioaddr[], const char* name)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint status;\r\nssleep(1);\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nif ((status = card_send_command(ioaddr, name, Command1, st)))\r\nreturn status;\r\nif (st[3] != 0xf1) {\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\nreturn -EIO;\r\n}\r\nudelay(1000);\r\nreturn sb1000_start_get_set_command(ioaddr, name);\r\n}\r\nstatic int\r\nsb1000_get_firmware_version(const int ioaddr[], const char* name,\r\nunsigned char version[], int do_end)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x23, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint status;\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nif (st[0] != 0xa3)\r\nreturn -EIO;\r\nversion[0] = st[1];\r\nversion[1] = st[2];\r\nif (do_end)\r\nreturn sb1000_end_get_set_command(ioaddr, name);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\nsb1000_get_frequency(const int ioaddr[], const char* name, int* frequency)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint status;\r\nudelay(1000);\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\n*frequency = ((st[1] << 8 | st[2]) << 8 | st[3]) << 8 | st[4];\r\nreturn sb1000_end_get_set_command(ioaddr, name);\r\n}\r\nstatic int\r\nsb1000_set_frequency(const int ioaddr[], const char* name, int frequency)\r\n{\r\nunsigned char st[7];\r\nint status;\r\nunsigned char Command0[6] = {0x80, 0x29, 0x00, 0x00, 0x00, 0x00};\r\nconst int FrequencyLowerLimit = 57000;\r\nconst int FrequencyUpperLimit = 804000;\r\nif (frequency < FrequencyLowerLimit || frequency > FrequencyUpperLimit) {\r\nprintk(KERN_ERR "%s: frequency chosen (%d kHz) is not in the range "\r\n"[%d,%d] kHz\n", name, frequency, FrequencyLowerLimit,\r\nFrequencyUpperLimit);\r\nreturn -EINVAL;\r\n}\r\nudelay(1000);\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\nCommand0[5] = frequency & 0xff;\r\nfrequency >>= 8;\r\nCommand0[4] = frequency & 0xff;\r\nfrequency >>= 8;\r\nCommand0[3] = frequency & 0xff;\r\nfrequency >>= 8;\r\nCommand0[2] = frequency & 0xff;\r\nreturn card_send_command(ioaddr, name, Command0, st);\r\n}\r\nstatic int\r\nsb1000_get_PIDs(const int ioaddr[], const char* name, short PID[])\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x40, 0x00, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command1[6] = {0x80, 0x41, 0x00, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command2[6] = {0x80, 0x42, 0x00, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command3[6] = {0x80, 0x43, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nint status;\r\nudelay(1000);\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\nPID[0] = st[1] << 8 | st[2];\r\nif ((status = card_send_command(ioaddr, name, Command1, st)))\r\nreturn status;\r\nPID[1] = st[1] << 8 | st[2];\r\nif ((status = card_send_command(ioaddr, name, Command2, st)))\r\nreturn status;\r\nPID[2] = st[1] << 8 | st[2];\r\nif ((status = card_send_command(ioaddr, name, Command3, st)))\r\nreturn status;\r\nPID[3] = st[1] << 8 | st[2];\r\nreturn sb1000_end_get_set_command(ioaddr, name);\r\n}\r\nstatic int\r\nsb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])\r\n{\r\nstatic const unsigned char Command4[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char st[7];\r\nshort p;\r\nint status;\r\nunsigned char Command0[6] = {0x80, 0x31, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char Command1[6] = {0x80, 0x32, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char Command2[6] = {0x80, 0x33, 0x00, 0x00, 0x00, 0x00};\r\nunsigned char Command3[6] = {0x80, 0x34, 0x00, 0x00, 0x00, 0x00};\r\nudelay(1000);\r\nif ((status = sb1000_start_get_set_command(ioaddr, name)))\r\nreturn status;\r\np = PID[0];\r\nCommand0[3] = p & 0xff;\r\np >>= 8;\r\nCommand0[2] = p & 0xff;\r\nif ((status = card_send_command(ioaddr, name, Command0, st)))\r\nreturn status;\r\np = PID[1];\r\nCommand1[3] = p & 0xff;\r\np >>= 8;\r\nCommand1[2] = p & 0xff;\r\nif ((status = card_send_command(ioaddr, name, Command1, st)))\r\nreturn status;\r\np = PID[2];\r\nCommand2[3] = p & 0xff;\r\np >>= 8;\r\nCommand2[2] = p & 0xff;\r\nif ((status = card_send_command(ioaddr, name, Command2, st)))\r\nreturn status;\r\np = PID[3];\r\nCommand3[3] = p & 0xff;\r\np >>= 8;\r\nCommand3[2] = p & 0xff;\r\nif ((status = card_send_command(ioaddr, name, Command3, st)))\r\nreturn status;\r\nif ((status = card_send_command(ioaddr, name, Command4, st)))\r\nreturn status;\r\nreturn sb1000_end_get_set_command(ioaddr, name);\r\n}\r\nstatic void\r\nsb1000_print_status_buffer(const char* name, unsigned char st[],\r\nunsigned char buffer[], int size)\r\n{\r\nint i, j, k;\r\nprintk(KERN_DEBUG "%s: status: %02x %02x\n", name, st[0], st[1]);\r\nif (buffer[24] == 0x08 && buffer[25] == 0x00 && buffer[26] == 0x45) {\r\nprintk(KERN_DEBUG "%s: length: %d protocol: %d from: %d.%d.%d.%d:%d "\r\n"to %d.%d.%d.%d:%d\n", name, buffer[28] << 8 | buffer[29],\r\nbuffer[35], buffer[38], buffer[39], buffer[40], buffer[41],\r\nbuffer[46] << 8 | buffer[47],\r\nbuffer[42], buffer[43], buffer[44], buffer[45],\r\nbuffer[48] << 8 | buffer[49]);\r\n} else {\r\nfor (i = 0, k = 0; i < (size + 7) / 8; i++) {\r\nprintk(KERN_DEBUG "%s: %s", name, i ? " " : "buffer:");\r\nfor (j = 0; j < 8 && k < size; j++, k++)\r\nprintk(" %02x", buffer[k]);\r\nprintk("\n");\r\n}\r\n}\r\n}\r\nstatic int\r\nsb1000_rx(struct net_device *dev)\r\n{\r\n#define FRAMESIZE 184\r\nunsigned char st[2], buffer[FRAMESIZE], session_id, frame_id;\r\nshort dlen;\r\nint ioaddr, ns;\r\nunsigned int skbsize;\r\nstruct sk_buff *skb;\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nconst int FrameSize = FRAMESIZE;\r\nconst int NewDatagramHeaderSkip = 8;\r\nconst int NewDatagramHeaderSize = NewDatagramHeaderSkip + 18;\r\nconst int NewDatagramDataSize = FrameSize - NewDatagramHeaderSize;\r\nconst int ContDatagramHeaderSkip = 7;\r\nconst int ContDatagramHeaderSize = ContDatagramHeaderSkip + 1;\r\nconst int ContDatagramDataSize = FrameSize - ContDatagramHeaderSize;\r\nconst int TrailerSize = 4;\r\nioaddr = dev->base_addr;\r\ninsw(ioaddr, (unsigned short*) st, 1);\r\n#ifdef XXXDEBUG\r\nprintk("cm0: received: %02x %02x\n", st[0], st[1]);\r\n#endif\r\nlp->rx_frames++;\r\nfor (ns = 0; ns < NPIDS; ns++) {\r\nsession_id = lp->rx_session_id[ns];\r\nframe_id = lp->rx_frame_id[ns];\r\nif (st[0] == session_id) {\r\nif (st[1] == frame_id || (!frame_id && (st[1] & 0xf0) == 0x30)) {\r\ngoto good_frame;\r\n} else if ((st[1] & 0xf0) == 0x30 && (st[0] & 0x40)) {\r\ngoto skipped_frame;\r\n} else {\r\ngoto bad_frame;\r\n}\r\n} else if (st[0] == (session_id | 0x40)) {\r\nif ((st[1] & 0xf0) == 0x30) {\r\ngoto skipped_frame;\r\n} else {\r\ngoto bad_frame;\r\n}\r\n}\r\n}\r\ngoto bad_frame;\r\nskipped_frame:\r\nstats->rx_frame_errors++;\r\nskb = lp->rx_skb[ns];\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: missing frame(s): got %02x %02x "\r\n"expecting %02x %02x\n", dev->name, st[0], st[1],\r\nskb ? session_id : session_id | 0x40, frame_id);\r\nif (skb) {\r\ndev_kfree_skb(skb);\r\nskb = NULL;\r\n}\r\ngood_frame:\r\nlp->rx_frame_id[ns] = 0x30 | ((st[1] + 1) & 0x0f);\r\nif (st[0] & 0x40) {\r\ninsw(ioaddr, buffer, NewDatagramHeaderSize / 2);\r\n#ifdef XXXDEBUG\r\nprintk("cm0: IP identification: %02x%02x fragment offset: %02x%02x\n", buffer[30], buffer[31], buffer[32], buffer[33]);\r\n#endif\r\nif (buffer[0] != NewDatagramHeaderSkip) {\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: new datagram header skip error: "\r\n"got %02x expecting %02x\n", dev->name, buffer[0],\r\nNewDatagramHeaderSkip);\r\nstats->rx_length_errors++;\r\ninsw(ioaddr, buffer, NewDatagramDataSize / 2);\r\ngoto bad_frame_next;\r\n}\r\ndlen = ((buffer[NewDatagramHeaderSkip + 3] & 0x0f) << 8 |\r\nbuffer[NewDatagramHeaderSkip + 4]) - 17;\r\nif (dlen > SB1000_MRU) {\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: datagram length (%d) greater "\r\n"than MRU (%d)\n", dev->name, dlen, SB1000_MRU);\r\nstats->rx_length_errors++;\r\ninsw(ioaddr, buffer, NewDatagramDataSize / 2);\r\ngoto bad_frame_next;\r\n}\r\nlp->rx_dlen[ns] = dlen;\r\nskbsize = dlen + FrameSize;\r\nif ((skb = alloc_skb(skbsize, GFP_ATOMIC)) == NULL) {\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: can't allocate %d bytes long "\r\n"skbuff\n", dev->name, skbsize);\r\nstats->rx_dropped++;\r\ninsw(ioaddr, buffer, NewDatagramDataSize / 2);\r\ngoto dropped_frame;\r\n}\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = (unsigned short) buffer[NewDatagramHeaderSkip + 16];\r\ninsw(ioaddr, skb_put(skb, NewDatagramDataSize),\r\nNewDatagramDataSize / 2);\r\nlp->rx_skb[ns] = skb;\r\n} else {\r\ninsw(ioaddr, buffer, ContDatagramHeaderSize / 2);\r\nif (buffer[0] != ContDatagramHeaderSkip) {\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: cont datagram header skip error: "\r\n"got %02x expecting %02x\n", dev->name, buffer[0],\r\nContDatagramHeaderSkip);\r\nstats->rx_length_errors++;\r\ninsw(ioaddr, buffer, ContDatagramDataSize / 2);\r\ngoto bad_frame_next;\r\n}\r\nskb = lp->rx_skb[ns];\r\ninsw(ioaddr, skb_put(skb, ContDatagramDataSize),\r\nContDatagramDataSize / 2);\r\ndlen = lp->rx_dlen[ns];\r\n}\r\nif (skb->len < dlen + TrailerSize) {\r\nlp->rx_session_id[ns] &= ~0x40;\r\nreturn 0;\r\n}\r\nskb_trim(skb, dlen);\r\nnetif_rx(skb);\r\nstats->rx_bytes+=dlen;\r\nstats->rx_packets++;\r\nlp->rx_skb[ns] = NULL;\r\nlp->rx_session_id[ns] |= 0x40;\r\nreturn 0;\r\nbad_frame:\r\ninsw(ioaddr, buffer, FrameSize / 2);\r\nif (sb1000_debug > 1)\r\nprintk(KERN_WARNING "%s: frame error: got %02x %02x\n",\r\ndev->name, st[0], st[1]);\r\nstats->rx_frame_errors++;\r\nbad_frame_next:\r\nif (sb1000_debug > 2)\r\nsb1000_print_status_buffer(dev->name, st, buffer, FrameSize);\r\ndropped_frame:\r\nstats->rx_errors++;\r\nif (ns < NPIDS) {\r\nif ((skb = lp->rx_skb[ns])) {\r\ndev_kfree_skb(skb);\r\nlp->rx_skb[ns] = NULL;\r\n}\r\nlp->rx_session_id[ns] |= 0x40;\r\n}\r\nreturn -1;\r\n}\r\nstatic void\r\nsb1000_error_dpc(struct net_device *dev)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x26, 0x00, 0x00, 0x00, 0x00};\r\nchar *name;\r\nunsigned char st[5];\r\nint ioaddr[2];\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nconst int ErrorDpcCounterInitialize = 200;\r\nioaddr[0] = dev->base_addr;\r\nioaddr[1] = dev->mem_start;\r\nname = dev->name;\r\nsb1000_wait_for_ready_clear(ioaddr, name);\r\nsb1000_send_command(ioaddr, name, Command0);\r\nsb1000_wait_for_ready(ioaddr, name);\r\nsb1000_read_status(ioaddr, st);\r\nif (st[1] & 0x10)\r\nlp->rx_error_dpc_count = ErrorDpcCounterInitialize;\r\n}\r\nstatic int\r\nsb1000_open(struct net_device *dev)\r\n{\r\nchar *name;\r\nint ioaddr[2], status;\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nconst unsigned short FirmwareVersion[] = {0x01, 0x01};\r\nioaddr[0] = dev->base_addr;\r\nioaddr[1] = dev->mem_start;\r\nname = dev->name;\r\nif ((status = sb1000_reset(ioaddr, name)))\r\nreturn status;\r\nssleep(1);\r\nif ((status = sb1000_check_CRC(ioaddr, name)))\r\nreturn status;\r\nlp->rx_skb[0] = NULL;\r\nlp->rx_skb[1] = NULL;\r\nlp->rx_skb[2] = NULL;\r\nlp->rx_skb[3] = NULL;\r\nlp->rx_dlen[0] = 0;\r\nlp->rx_dlen[1] = 0;\r\nlp->rx_dlen[2] = 0;\r\nlp->rx_dlen[3] = 0;\r\nlp->rx_frames = 0;\r\nlp->rx_error_count = 0;\r\nlp->rx_error_dpc_count = 0;\r\nlp->rx_session_id[0] = 0x50;\r\nlp->rx_session_id[1] = 0x48;\r\nlp->rx_session_id[2] = 0x44;\r\nlp->rx_session_id[3] = 0x42;\r\nlp->rx_frame_id[0] = 0;\r\nlp->rx_frame_id[1] = 0;\r\nlp->rx_frame_id[2] = 0;\r\nlp->rx_frame_id[3] = 0;\r\nif (request_irq(dev->irq, sb1000_interrupt, 0, "sb1000", dev)) {\r\nreturn -EAGAIN;\r\n}\r\nif (sb1000_debug > 2)\r\nprintk(KERN_DEBUG "%s: Opening, IRQ %d\n", name, dev->irq);\r\nudelay(1000);\r\nif ((status = sb1000_activate(ioaddr, name)))\r\nreturn status;\r\nudelay(0);\r\nif ((status = sb1000_get_firmware_version(ioaddr, name, version, 0)))\r\nreturn status;\r\nif (version[0] != FirmwareVersion[0] || version[1] != FirmwareVersion[1])\r\nprintk(KERN_WARNING "%s: found firmware version %x.%02x "\r\n"(should be %x.%02x)\n", name, version[0], version[1],\r\nFirmwareVersion[0], FirmwareVersion[1]);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sb1000_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nchar* name;\r\nunsigned char version[2];\r\nshort PID[4];\r\nint ioaddr[2], status, frequency;\r\nunsigned int stats[5];\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nif (!(dev && dev->flags & IFF_UP))\r\nreturn -ENODEV;\r\nioaddr[0] = dev->base_addr;\r\nioaddr[1] = dev->mem_start;\r\nname = dev->name;\r\nswitch (cmd) {\r\ncase SIOCGCMSTATS:\r\nstats[0] = dev->stats.rx_bytes;\r\nstats[1] = lp->rx_frames;\r\nstats[2] = dev->stats.rx_packets;\r\nstats[3] = dev->stats.rx_errors;\r\nstats[4] = dev->stats.rx_dropped;\r\nif(copy_to_user(ifr->ifr_data, stats, sizeof(stats)))\r\nreturn -EFAULT;\r\nstatus = 0;\r\nbreak;\r\ncase SIOCGCMFIRMWARE:\r\nif ((status = sb1000_get_firmware_version(ioaddr, name, version, 1)))\r\nreturn status;\r\nif(copy_to_user(ifr->ifr_data, version, sizeof(version)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SIOCGCMFREQUENCY:\r\nif ((status = sb1000_get_frequency(ioaddr, name, &frequency)))\r\nreturn status;\r\nif(put_user(frequency, (int __user *) ifr->ifr_data))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SIOCSCMFREQUENCY:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif(get_user(frequency, (int __user *) ifr->ifr_data))\r\nreturn -EFAULT;\r\nif ((status = sb1000_set_frequency(ioaddr, name, frequency)))\r\nreturn status;\r\nbreak;\r\ncase SIOCGCMPIDS:\r\nif ((status = sb1000_get_PIDs(ioaddr, name, PID)))\r\nreturn status;\r\nif(copy_to_user(ifr->ifr_data, PID, sizeof(PID)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SIOCSCMPIDS:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif(copy_from_user(PID, ifr->ifr_data, sizeof(PID)))\r\nreturn -EFAULT;\r\nif ((status = sb1000_set_PIDs(ioaddr, name, PID)))\r\nreturn status;\r\nlp->rx_session_id[0] = 0x50 | (PID[0] & 0x0f);\r\nlp->rx_session_id[1] = 0x48;\r\nlp->rx_session_id[2] = 0x44;\r\nlp->rx_session_id[3] = 0x42;\r\nlp->rx_frame_id[0] = 0;\r\nlp->rx_frame_id[1] = 0;\r\nlp->rx_frame_id[2] = 0;\r\nlp->rx_frame_id[3] = 0;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic netdev_tx_t\r\nsb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nprintk(KERN_WARNING "%s: trying to transmit!!!\n", dev->name);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t sb1000_interrupt(int irq, void *dev_id)\r\n{\r\nstatic const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};\r\nstatic const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};\r\nchar *name;\r\nunsigned char st;\r\nint ioaddr[2];\r\nstruct net_device *dev = dev_id;\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nconst int MaxRxErrorCount = 6;\r\nioaddr[0] = dev->base_addr;\r\nioaddr[1] = dev->mem_start;\r\nname = dev->name;\r\nst = inb(ioaddr[1] + 6);\r\nif (!(st & 0x08 && st & 0x20)) {\r\nreturn IRQ_NONE;\r\n}\r\nif (sb1000_debug > 3)\r\nprintk(KERN_DEBUG "%s: entering interrupt\n", dev->name);\r\nst = inb(ioaddr[0] + 7);\r\nif (sb1000_rx(dev))\r\nlp->rx_error_count++;\r\n#ifdef SB1000_DELAY\r\nudelay(SB1000_DELAY);\r\n#endif\r\nsb1000_issue_read_command(ioaddr, name);\r\nif (st & 0x01) {\r\nsb1000_error_dpc(dev);\r\nsb1000_issue_read_command(ioaddr, name);\r\n}\r\nif (lp->rx_error_dpc_count && !(--lp->rx_error_dpc_count)) {\r\nsb1000_wait_for_ready_clear(ioaddr, name);\r\nsb1000_send_command(ioaddr, name, Command0);\r\nsb1000_wait_for_ready(ioaddr, name);\r\nsb1000_issue_read_command(ioaddr, name);\r\n}\r\nif (lp->rx_error_count >= MaxRxErrorCount) {\r\nsb1000_wait_for_ready_clear(ioaddr, name);\r\nsb1000_send_command(ioaddr, name, Command1);\r\nsb1000_wait_for_ready(ioaddr, name);\r\nsb1000_issue_read_command(ioaddr, name);\r\nlp->rx_error_count = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sb1000_close(struct net_device *dev)\r\n{\r\nint i;\r\nint ioaddr[2];\r\nstruct sb1000_private *lp = netdev_priv(dev);\r\nif (sb1000_debug > 2)\r\nprintk(KERN_DEBUG "%s: Shutting down sb1000.\n", dev->name);\r\nnetif_stop_queue(dev);\r\nioaddr[0] = dev->base_addr;\r\nioaddr[1] = dev->mem_start;\r\nfree_irq(dev->irq, dev);\r\nrelease_region(ioaddr[1], SB1000_IO_EXTENT);\r\nrelease_region(ioaddr[0], SB1000_IO_EXTENT);\r\nfor (i=0; i<4; i++) {\r\nif (lp->rx_skb[i]) {\r\ndev_kfree_skb(lp->rx_skb[i]);\r\n}\r\n}\r\nreturn 0;\r\n}
