static unsigned int tbg_get_mult(void __iomem *reg, const struct tbg_def *ptbg)\r\n{\r\nu32 val;\r\nval = readl(reg + TBG_CTRL0);\r\nreturn ((val >> ptbg->fbdiv_offset) & TBG_DIV_MASK) << 2;\r\n}\r\nstatic unsigned int tbg_get_div(void __iomem *reg, const struct tbg_def *ptbg)\r\n{\r\nu32 val;\r\nunsigned int div;\r\nval = readl(reg + TBG_CTRL7);\r\ndiv = (val >> ptbg->refdiv_offset) & TBG_DIV_MASK;\r\nif (div == 0)\r\ndiv = 1;\r\nval = readl(reg + ptbg->vcodiv_reg);\r\ndiv *= 1 << ((val >> ptbg->vcodiv_offset) & TBG_DIV_MASK);\r\nreturn div;\r\n}\r\nstatic int armada_3700_tbg_clock_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct clk_hw_onecell_data *hw_tbg_data;\r\nstruct device *dev = &pdev->dev;\r\nconst char *parent_name;\r\nstruct resource *res;\r\nstruct clk *parent;\r\nvoid __iomem *reg;\r\nint i, ret;\r\nhw_tbg_data = devm_kzalloc(&pdev->dev, sizeof(*hw_tbg_data)\r\n+ sizeof(*hw_tbg_data->hws) * NUM_TBG,\r\nGFP_KERNEL);\r\nif (!hw_tbg_data)\r\nreturn -ENOMEM;\r\nhw_tbg_data->num = NUM_TBG;\r\nplatform_set_drvdata(pdev, hw_tbg_data);\r\nparent = devm_clk_get(dev, NULL);\r\nif (IS_ERR(parent)) {\r\ndev_err(dev, "Could get the clock parent\n");\r\nreturn -EINVAL;\r\n}\r\nparent_name = __clk_get_name(parent);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nfor (i = 0; i < NUM_TBG; i++) {\r\nconst char *name;\r\nunsigned int mult, div;\r\nname = tbg[i].name;\r\nmult = tbg_get_mult(reg, &tbg[i]);\r\ndiv = tbg_get_div(reg, &tbg[i]);\r\nhw_tbg_data->hws[i] = clk_hw_register_fixed_factor(NULL, name,\r\nparent_name, 0, mult, div);\r\nif (IS_ERR(hw_tbg_data->hws[i]))\r\ndev_err(dev, "Can't register TBG clock %s\n", name);\r\n}\r\nret = of_clk_add_hw_provider(np, of_clk_hw_onecell_get, hw_tbg_data);\r\nreturn ret;\r\n}\r\nstatic int armada_3700_tbg_clock_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct clk_hw_onecell_data *hw_tbg_data = platform_get_drvdata(pdev);\r\nof_clk_del_provider(pdev->dev.of_node);\r\nfor (i = 0; i < hw_tbg_data->num; i++)\r\nclk_hw_unregister_fixed_factor(hw_tbg_data->hws[i]);\r\nreturn 0;\r\n}
