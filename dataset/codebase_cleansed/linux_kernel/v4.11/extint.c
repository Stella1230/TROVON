static void eic_ack_irq(struct irq_data *d)\r\n{\r\nstruct eic *eic = irq_data_get_irq_chip_data(d);\r\neic_writel(eic, ICR, 1 << (d->irq - eic->first_irq));\r\n}\r\nstatic void eic_mask_irq(struct irq_data *d)\r\n{\r\nstruct eic *eic = irq_data_get_irq_chip_data(d);\r\neic_writel(eic, IDR, 1 << (d->irq - eic->first_irq));\r\n}\r\nstatic void eic_mask_ack_irq(struct irq_data *d)\r\n{\r\nstruct eic *eic = irq_data_get_irq_chip_data(d);\r\neic_writel(eic, ICR, 1 << (d->irq - eic->first_irq));\r\neic_writel(eic, IDR, 1 << (d->irq - eic->first_irq));\r\n}\r\nstatic void eic_unmask_irq(struct irq_data *d)\r\n{\r\nstruct eic *eic = irq_data_get_irq_chip_data(d);\r\neic_writel(eic, IER, 1 << (d->irq - eic->first_irq));\r\n}\r\nstatic int eic_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct eic *eic = irq_data_get_irq_chip_data(d);\r\nunsigned int irq = d->irq;\r\nunsigned int i = irq - eic->first_irq;\r\nu32 mode, edge, level;\r\nflow_type &= IRQ_TYPE_SENSE_MASK;\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\nmode = eic_readl(eic, MODE);\r\nedge = eic_readl(eic, EDGE);\r\nlevel = eic_readl(eic, LEVEL);\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nmode |= 1 << i;\r\nlevel &= ~(1 << i);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nmode |= 1 << i;\r\nlevel |= 1 << i;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nmode &= ~(1 << i);\r\nedge |= 1 << i;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nmode &= ~(1 << i);\r\nedge &= ~(1 << i);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\neic_writel(eic, MODE, mode);\r\neic_writel(eic, EDGE, edge);\r\neic_writel(eic, LEVEL, level);\r\nirqd_set_trigger_type(d, flow_type);\r\nif (flow_type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\nirq_set_handler_locked(d, handle_level_irq);\r\nelse\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nstatic void demux_eic_irq(struct irq_desc *desc)\r\n{\r\nstruct eic *eic = irq_desc_get_handler_data(desc);\r\nunsigned long status, pending;\r\nunsigned int i;\r\nstatus = eic_readl(eic, ISR);\r\npending = status & eic_readl(eic, IMR);\r\nwhile (pending) {\r\ni = fls(pending) - 1;\r\npending &= ~(1 << i);\r\ngeneric_handle_irq(i + eic->first_irq);\r\n}\r\n}\r\nint nmi_enable(void)\r\n{\r\nnmi_enabled = true;\r\nif (nmi_eic)\r\neic_writel(nmi_eic, NMIC, EIC_NMIC_ENABLE);\r\nreturn 0;\r\n}\r\nvoid nmi_disable(void)\r\n{\r\nif (nmi_eic)\r\neic_writel(nmi_eic, NMIC, 0);\r\nnmi_enabled = false;\r\n}\r\nstatic int __init eic_probe(struct platform_device *pdev)\r\n{\r\nstruct eic *eic;\r\nstruct resource *regs;\r\nunsigned int i;\r\nunsigned int nr_of_irqs;\r\nunsigned int int_irq;\r\nint ret;\r\nu32 pattern;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint_irq = platform_get_irq(pdev, 0);\r\nif (!regs || (int)int_irq <= 0) {\r\ndev_dbg(&pdev->dev, "missing regs and/or irq resource\n");\r\nreturn -ENXIO;\r\n}\r\nret = -ENOMEM;\r\neic = kzalloc(sizeof(struct eic), GFP_KERNEL);\r\nif (!eic) {\r\ndev_dbg(&pdev->dev, "no memory for eic structure\n");\r\ngoto err_kzalloc;\r\n}\r\neic->first_irq = EIM_IRQ_BASE + 32 * pdev->id;\r\neic->regs = ioremap(regs->start, resource_size(regs));\r\nif (!eic->regs) {\r\ndev_dbg(&pdev->dev, "failed to map regs\n");\r\ngoto err_ioremap;\r\n}\r\neic_writel(eic, IDR, ~0UL);\r\neic_writel(eic, MODE, ~0UL);\r\npattern = eic_readl(eic, MODE);\r\nnr_of_irqs = fls(pattern);\r\neic_writel(eic, EDGE, 0UL);\r\neic_writel(eic, LEVEL, 0UL);\r\neic->chip = &eic_chip;\r\nfor (i = 0; i < nr_of_irqs; i++) {\r\nirq_set_chip_and_handler(eic->first_irq + i, &eic_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(eic->first_irq + i, eic);\r\n}\r\nirq_set_chained_handler_and_data(int_irq, demux_eic_irq, eic);\r\nif (pdev->id == 0) {\r\nnmi_eic = eic;\r\nif (nmi_enabled)\r\nnmi_enable();\r\n}\r\ndev_info(&pdev->dev,\r\n"External Interrupt Controller at 0x%p, IRQ %u\n",\r\neic->regs, int_irq);\r\ndev_info(&pdev->dev,\r\n"Handling %u external IRQs, starting with IRQ %u\n",\r\nnr_of_irqs, eic->first_irq);\r\nreturn 0;\r\nerr_ioremap:\r\nkfree(eic);\r\nerr_kzalloc:\r\nreturn ret;\r\n}\r\nstatic int __init eic_init(void)\r\n{\r\nreturn platform_driver_probe(&eic_driver, eic_probe);\r\n}
