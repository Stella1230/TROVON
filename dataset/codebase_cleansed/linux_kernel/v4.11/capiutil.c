static unsigned command_2_index(u8 c, u8 sc)\r\n{\r\nif (c & 0x80)\r\nc = 0x9 + (c & 0x0f);\r\nelse if (c == 0x41)\r\nc = 0x9 + 0x1;\r\nif (c > 0x18)\r\nc = 0x00;\r\nreturn (sc & 3) * (0x9 + 0x9) + c;\r\n}\r\nstatic unsigned char *capi_cmd2par(u8 cmd, u8 subcmd)\r\n{\r\nreturn cpars[command_2_index(cmd, subcmd)];\r\n}\r\nstatic void jumpcstruct(_cmsg *cmsg)\r\n{\r\nunsigned layer;\r\nfor (cmsg->p++, layer = 1; layer;) {\r\ncmsg->p++;\r\nswitch (TYP) {\r\ncase _CMSTRUCT:\r\nlayer++;\r\nbreak;\r\ncase _CEND:\r\nlayer--;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pars_2_message(_cmsg *cmsg)\r\n{\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nswitch (TYP) {\r\ncase _CBYTE:\r\nbyteTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\nwordTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ndwordTLcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\nif (*(u8 **) OFF == NULL) {\r\n*(cmsg->m + cmsg->l) = '\0';\r\ncmsg->l++;\r\n} else if (**(_cstruct *) OFF != 0xff) {\r\nstructTLcpy(cmsg->m + cmsg->l, *(_cstruct *) OFF, 1 + **(_cstruct *) OFF);\r\ncmsg->l += 1 + **(_cstruct *) OFF;\r\n} else {\r\n_cstruct s = *(_cstruct *) OFF;\r\nstructTLcpy(cmsg->m + cmsg->l, s, 3 + *(u16 *) (s + 1));\r\ncmsg->l += 3 + *(u16 *) (s + 1);\r\n}\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (*(_cmstruct *) OFF == CAPI_DEFAULT) {\r\n*(cmsg->m + cmsg->l) = '\0';\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n}\r\nelse {\r\nunsigned _l = cmsg->l;\r\nunsigned _ls;\r\ncmsg->l++;\r\ncmsg->p++;\r\npars_2_message(cmsg);\r\n_ls = cmsg->l - _l - 1;\r\nif (_ls < 255)\r\n(cmsg->m + _l)[0] = (u8) _ls;\r\nelse {\r\nstructTLcpyovl(cmsg->m + _l + 3, cmsg->m + _l + 1, _ls);\r\n(cmsg->m + _l)[0] = 0xff;\r\nwordTLcpy(cmsg->m + _l + 1, &_ls);\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nunsigned capi_cmsg2message(_cmsg *cmsg, u8 *msg)\r\n{\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\ncmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);\r\nif (!cmsg->par)\r\nreturn 1;\r\npars_2_message(cmsg);\r\nwordTLcpy(msg + 0, &cmsg->l);\r\nbyteTLcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTLcpy(cmsg->m + 5, &cmsg->Subcommand);\r\nwordTLcpy(cmsg->m + 2, &cmsg->ApplId);\r\nwordTLcpy(cmsg->m + 6, &cmsg->Messagenumber);\r\nreturn 0;\r\n}\r\nstatic void message_2_pars(_cmsg *cmsg)\r\n{\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nswitch (TYP) {\r\ncase _CBYTE:\r\nbyteTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\nwordTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ndwordTRcpy(cmsg->m + cmsg->l, OFF);\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\n*(u8 **) OFF = cmsg->m + cmsg->l;\r\nif (cmsg->m[cmsg->l] != 0xff)\r\ncmsg->l += 1 + cmsg->m[cmsg->l];\r\nelse\r\ncmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (cmsg->m[cmsg->l] == '\0') {\r\n*(_cmstruct *) OFF = CAPI_DEFAULT;\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n} else {\r\nunsigned _l = cmsg->l;\r\n*(_cmstruct *) OFF = CAPI_COMPOSE;\r\ncmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;\r\ncmsg->p++;\r\nmessage_2_pars(cmsg);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nunsigned capi_message2cmsg(_cmsg *cmsg, u8 *msg)\r\n{\r\nmemset(cmsg, 0, sizeof(_cmsg));\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\nbyteTRcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTRcpy(cmsg->m + 5, &cmsg->Subcommand);\r\ncmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);\r\nif (!cmsg->par)\r\nreturn 1;\r\nmessage_2_pars(cmsg);\r\nwordTRcpy(msg + 0, &cmsg->l);\r\nwordTRcpy(cmsg->m + 2, &cmsg->ApplId);\r\nwordTRcpy(cmsg->m + 6, &cmsg->Messagenumber);\r\nreturn 0;\r\n}\r\nunsigned capi_cmsg_header(_cmsg *cmsg, u16 _ApplId,\r\nu8 _Command, u8 _Subcommand,\r\nu16 _Messagenumber, u32 _Controller)\r\n{\r\nmemset(cmsg, 0, sizeof(_cmsg));\r\ncmsg->ApplId = _ApplId;\r\ncmsg->Command = _Command;\r\ncmsg->Subcommand = _Subcommand;\r\ncmsg->Messagenumber = _Messagenumber;\r\ncmsg->adr.adrController = _Controller;\r\nreturn 0;\r\n}\r\nchar *capi_cmd2str(u8 cmd, u8 subcmd)\r\n{\r\nchar *result;\r\nresult = mnames[command_2_index(cmd, subcmd)];\r\nif (result == NULL)\r\nresult = "INVALID_COMMAND";\r\nreturn result;\r\n}\r\nstatic _cdebbuf *bufprint(_cdebbuf *cdb, char *fmt, ...)\r\n{\r\nva_list f;\r\nsize_t n, r;\r\nif (!cdb)\r\nreturn NULL;\r\nva_start(f, fmt);\r\nr = cdb->size - cdb->pos;\r\nn = vsnprintf(cdb->p, r, fmt, f);\r\nva_end(f);\r\nif (n >= r) {\r\nsize_t ns = 2 * cdb->size;\r\nu_char *nb;\r\nwhile ((ns - cdb->pos) <= n)\r\nns *= 2;\r\nnb = kmalloc(ns, GFP_ATOMIC);\r\nif (!nb) {\r\ncdebbuf_free(cdb);\r\nreturn NULL;\r\n}\r\nmemcpy(nb, cdb->buf, cdb->pos);\r\nkfree(cdb->buf);\r\nnb[cdb->pos] = 0;\r\ncdb->buf = nb;\r\ncdb->p = cdb->buf + cdb->pos;\r\ncdb->size = ns;\r\nva_start(f, fmt);\r\nr = cdb->size - cdb->pos;\r\nn = vsnprintf(cdb->p, r, fmt, f);\r\nva_end(f);\r\n}\r\ncdb->p += n;\r\ncdb->pos += n;\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *printstructlen(_cdebbuf *cdb, u8 *m, unsigned len)\r\n{\r\nunsigned hex = 0;\r\nif (!cdb)\r\nreturn NULL;\r\nfor (; len; len--, m++)\r\nif (isalnum(*m) || *m == ' ') {\r\nif (hex)\r\ncdb = bufprint(cdb, ">");\r\ncdb = bufprint(cdb, "%c", *m);\r\nhex = 0;\r\n} else {\r\nif (!hex)\r\ncdb = bufprint(cdb, "<%02x", *m);\r\nelse\r\ncdb = bufprint(cdb, " %02x", *m);\r\nhex = 1;\r\n}\r\nif (hex)\r\ncdb = bufprint(cdb, ">");\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *printstruct(_cdebbuf *cdb, u8 *m)\r\n{\r\nunsigned len;\r\nif (m[0] != 0xff) {\r\nlen = m[0];\r\nm += 1;\r\n} else {\r\nlen = ((u16 *) (m + 1))[0];\r\nm += 3;\r\n}\r\ncdb = printstructlen(cdb, m, len);\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *protocol_message_2_pars(_cdebbuf *cdb, _cmsg *cmsg, int level)\r\n{\r\nif (!cmsg->par)\r\nreturn NULL;\r\nfor (; TYP != _CEND; cmsg->p++) {\r\nint slen = 29 + 3 - level;\r\nint i;\r\nif (!cdb)\r\nreturn NULL;\r\ncdb = bufprint(cdb, " ");\r\nfor (i = 0; i < level - 1; i++)\r\ncdb = bufprint(cdb, " ");\r\nswitch (TYP) {\r\ncase _CBYTE:\r\ncdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u8 *) (cmsg->m + cmsg->l));\r\ncmsg->l++;\r\nbreak;\r\ncase _CWORD:\r\ncdb = bufprint(cdb, "%-*s = 0x%x\n", slen, NAME, *(u16 *) (cmsg->m + cmsg->l));\r\ncmsg->l += 2;\r\nbreak;\r\ncase _CDWORD:\r\ncdb = bufprint(cdb, "%-*s = 0x%lx\n", slen, NAME, *(u32 *) (cmsg->m + cmsg->l));\r\ncmsg->l += 4;\r\nbreak;\r\ncase _CSTRUCT:\r\ncdb = bufprint(cdb, "%-*s = ", slen, NAME);\r\nif (cmsg->m[cmsg->l] == '\0')\r\ncdb = bufprint(cdb, "default");\r\nelse\r\ncdb = printstruct(cdb, cmsg->m + cmsg->l);\r\ncdb = bufprint(cdb, "\n");\r\nif (cmsg->m[cmsg->l] != 0xff)\r\ncmsg->l += 1 + cmsg->m[cmsg->l];\r\nelse\r\ncmsg->l += 3 + *(u16 *) (cmsg->m + cmsg->l + 1);\r\nbreak;\r\ncase _CMSTRUCT:\r\nif (cmsg->m[cmsg->l] == '\0') {\r\ncdb = bufprint(cdb, "%-*s = default\n", slen, NAME);\r\ncmsg->l++;\r\njumpcstruct(cmsg);\r\n} else {\r\nchar *name = NAME;\r\nunsigned _l = cmsg->l;\r\ncdb = bufprint(cdb, "%-*s\n", slen, name);\r\ncmsg->l = (cmsg->m + _l)[0] == 255 ? cmsg->l + 3 : cmsg->l + 1;\r\ncmsg->p++;\r\ncdb = protocol_message_2_pars(cdb, cmsg, level + 1);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn cdb;\r\n}\r\nstatic _cdebbuf *cdebbuf_alloc(void)\r\n{\r\n_cdebbuf *cdb;\r\nif (likely(!test_and_set_bit(1, &g_debbuf_lock))) {\r\ncdb = g_debbuf;\r\ngoto init;\r\n} else\r\ncdb = kmalloc(sizeof(_cdebbuf), GFP_ATOMIC);\r\nif (!cdb)\r\nreturn NULL;\r\ncdb->buf = kmalloc(CDEBUG_SIZE, GFP_ATOMIC);\r\nif (!cdb->buf) {\r\nkfree(cdb);\r\nreturn NULL;\r\n}\r\ncdb->size = CDEBUG_SIZE;\r\ninit:\r\ncdb->buf[0] = 0;\r\ncdb->p = cdb->buf;\r\ncdb->pos = 0;\r\nreturn cdb;\r\n}\r\nvoid cdebbuf_free(_cdebbuf *cdb)\r\n{\r\nif (likely(cdb == g_debbuf)) {\r\ntest_and_clear_bit(1, &g_debbuf_lock);\r\nreturn;\r\n}\r\nif (likely(cdb))\r\nkfree(cdb->buf);\r\nkfree(cdb);\r\n}\r\n_cdebbuf *capi_message2str(u8 *msg)\r\n{\r\n_cdebbuf *cdb;\r\n_cmsg *cmsg;\r\ncdb = cdebbuf_alloc();\r\nif (unlikely(!cdb))\r\nreturn NULL;\r\nif (likely(cdb == g_debbuf))\r\ncmsg = g_cmsg;\r\nelse\r\ncmsg = kmalloc(sizeof(_cmsg), GFP_ATOMIC);\r\nif (unlikely(!cmsg)) {\r\ncdebbuf_free(cdb);\r\nreturn NULL;\r\n}\r\ncmsg->m = msg;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\nbyteTRcpy(cmsg->m + 4, &cmsg->Command);\r\nbyteTRcpy(cmsg->m + 5, &cmsg->Subcommand);\r\ncmsg->par = capi_cmd2par(cmsg->Command, cmsg->Subcommand);\r\ncdb = bufprint(cdb, "%-26s ID=%03d #0x%04x LEN=%04d\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\n((unsigned short *) msg)[1],\r\n((unsigned short *) msg)[3],\r\n((unsigned short *) msg)[0]);\r\ncdb = protocol_message_2_pars(cdb, cmsg, 1);\r\nif (unlikely(cmsg != g_cmsg))\r\nkfree(cmsg);\r\nreturn cdb;\r\n}\r\n_cdebbuf *capi_cmsg2str(_cmsg *cmsg)\r\n{\r\n_cdebbuf *cdb;\r\nif (!cmsg->m)\r\nreturn NULL;\r\ncdb = cdebbuf_alloc();\r\nif (!cdb)\r\nreturn NULL;\r\ncmsg->l = 8;\r\ncmsg->p = 0;\r\ncdb = bufprint(cdb, "%s ID=%03d #0x%04x LEN=%04d\n",\r\ncapi_cmd2str(cmsg->Command, cmsg->Subcommand),\r\n((u16 *) cmsg->m)[1],\r\n((u16 *) cmsg->m)[3],\r\n((u16 *) cmsg->m)[0]);\r\ncdb = protocol_message_2_pars(cdb, cmsg, 1);\r\nreturn cdb;\r\n}\r\nint __init cdebug_init(void)\r\n{\r\ng_cmsg = kmalloc(sizeof(_cmsg), GFP_KERNEL);\r\nif (!g_cmsg)\r\nreturn -ENOMEM;\r\ng_debbuf = kmalloc(sizeof(_cdebbuf), GFP_KERNEL);\r\nif (!g_debbuf) {\r\nkfree(g_cmsg);\r\nreturn -ENOMEM;\r\n}\r\ng_debbuf->buf = kmalloc(CDEBUG_GSIZE, GFP_KERNEL);\r\nif (!g_debbuf->buf) {\r\nkfree(g_cmsg);\r\nkfree(g_debbuf);\r\nreturn -ENOMEM;\r\n}\r\ng_debbuf->size = CDEBUG_GSIZE;\r\ng_debbuf->buf[0] = 0;\r\ng_debbuf->p = g_debbuf->buf;\r\ng_debbuf->pos = 0;\r\nreturn 0;\r\n}\r\nvoid __exit cdebug_exit(void)\r\n{\r\nif (g_debbuf)\r\nkfree(g_debbuf->buf);\r\nkfree(g_debbuf);\r\nkfree(g_cmsg);\r\n}\r\n_cdebbuf *capi_message2str(u8 *msg)\r\n{\r\nreturn &g_debbuf;\r\n}\r\n_cdebbuf *capi_cmsg2str(_cmsg *cmsg)\r\n{\r\nreturn &g_debbuf;\r\n}\r\nvoid cdebbuf_free(_cdebbuf *cdb)\r\n{\r\n}\r\nint __init cdebug_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid __exit cdebug_exit(void)\r\n{\r\n}
