static void octeon_i2c_int_enable(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, TWSI_INT_CORE_EN);\r\n}\r\nstatic void octeon_i2c_int_disable(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, 0);\r\n}\r\nstatic void octeon_i2c_int_enable78(struct octeon_i2c *i2c)\r\n{\r\natomic_inc_return(&i2c->int_enable_cnt);\r\nenable_irq(i2c->irq);\r\n}\r\nstatic void __octeon_i2c_irq_disable(atomic_t *cnt, int irq)\r\n{\r\nint count;\r\ncount = atomic_dec_if_positive(cnt);\r\nif (count >= 0)\r\ndisable_irq_nosync(irq);\r\n}\r\nstatic void octeon_i2c_int_disable78(struct octeon_i2c *i2c)\r\n{\r\n__octeon_i2c_irq_disable(&i2c->int_enable_cnt, i2c->irq);\r\n}\r\nstatic void octeon_i2c_hlc_int_enable78(struct octeon_i2c *i2c)\r\n{\r\natomic_inc_return(&i2c->hlc_int_enable_cnt);\r\nenable_irq(i2c->hlc_irq);\r\n}\r\nstatic void octeon_i2c_hlc_int_disable78(struct octeon_i2c *i2c)\r\n{\r\n__octeon_i2c_irq_disable(&i2c->hlc_int_enable_cnt, i2c->hlc_irq);\r\n}\r\nstatic irqreturn_t octeon_i2c_hlc_isr78(int irq, void *dev_id)\r\n{\r\nstruct octeon_i2c *i2c = dev_id;\r\ni2c->hlc_int_disable(i2c);\r\nwake_up(&i2c->queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void octeon_i2c_hlc_int_enable(struct octeon_i2c *i2c)\r\n{\r\nocteon_i2c_write_int(i2c, TWSI_INT_ST_EN);\r\n}\r\nstatic u32 octeon_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_SMBUS_BLOCK_PROC_CALL;\r\n}\r\nstatic int octeon_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nint irq, result = 0, hlc_irq = 0;\r\nstruct resource *res_mem;\r\nstruct octeon_i2c *i2c;\r\nbool cn78xx_style;\r\ncn78xx_style = of_device_is_compatible(node, "cavium,octeon-7890-twsi");\r\nif (cn78xx_style) {\r\nhlc_irq = platform_get_irq(pdev, 0);\r\nif (hlc_irq < 0)\r\nreturn hlc_irq;\r\nirq = platform_get_irq(pdev, 2);\r\nif (irq < 0)\r\nreturn irq;\r\n} else {\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\n}\r\ni2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c) {\r\nresult = -ENOMEM;\r\ngoto out;\r\n}\r\ni2c->dev = &pdev->dev;\r\ni2c->roff.sw_twsi = 0x00;\r\ni2c->roff.twsi_int = 0x10;\r\ni2c->roff.sw_twsi_ext = 0x18;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c->twsi_base = devm_ioremap_resource(&pdev->dev, res_mem);\r\nif (IS_ERR(i2c->twsi_base)) {\r\nresult = PTR_ERR(i2c->twsi_base);\r\ngoto out;\r\n}\r\nif (of_property_read_u32(node, "clock-frequency", &i2c->twsi_freq) &&\r\nof_property_read_u32(node, "clock-rate", &i2c->twsi_freq)) {\r\ndev_err(i2c->dev,\r\n"no I2C 'clock-rate' or 'clock-frequency' property\n");\r\nresult = -ENXIO;\r\ngoto out;\r\n}\r\ni2c->sys_freq = octeon_get_io_clock_rate();\r\ninit_waitqueue_head(&i2c->queue);\r\ni2c->irq = irq;\r\nif (cn78xx_style) {\r\ni2c->hlc_irq = hlc_irq;\r\ni2c->int_enable = octeon_i2c_int_enable78;\r\ni2c->int_disable = octeon_i2c_int_disable78;\r\ni2c->hlc_int_enable = octeon_i2c_hlc_int_enable78;\r\ni2c->hlc_int_disable = octeon_i2c_hlc_int_disable78;\r\nirq_set_status_flags(i2c->irq, IRQ_NOAUTOEN);\r\nirq_set_status_flags(i2c->hlc_irq, IRQ_NOAUTOEN);\r\nresult = devm_request_irq(&pdev->dev, i2c->hlc_irq,\r\nocteon_i2c_hlc_isr78, 0,\r\nDRV_NAME, i2c);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to attach interrupt\n");\r\ngoto out;\r\n}\r\n} else {\r\ni2c->int_enable = octeon_i2c_int_enable;\r\ni2c->int_disable = octeon_i2c_int_disable;\r\ni2c->hlc_int_enable = octeon_i2c_hlc_int_enable;\r\ni2c->hlc_int_disable = octeon_i2c_int_disable;\r\n}\r\nresult = devm_request_irq(&pdev->dev, i2c->irq,\r\nocteon_i2c_isr, 0, DRV_NAME, i2c);\r\nif (result < 0) {\r\ndev_err(i2c->dev, "failed to attach interrupt\n");\r\ngoto out;\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN38XX))\r\ni2c->broken_irq_check = true;\r\nresult = octeon_i2c_init_lowlevel(i2c);\r\nif (result) {\r\ndev_err(i2c->dev, "init low level failed\n");\r\ngoto out;\r\n}\r\nocteon_i2c_set_clock(i2c);\r\ni2c->adap = octeon_i2c_ops;\r\ni2c->adap.timeout = msecs_to_jiffies(2);\r\ni2c->adap.retries = 5;\r\ni2c->adap.bus_recovery_info = &octeon_i2c_recovery_info;\r\ni2c->adap.dev.parent = &pdev->dev;\r\ni2c->adap.dev.of_node = node;\r\ni2c_set_adapdata(&i2c->adap, i2c);\r\nplatform_set_drvdata(pdev, i2c);\r\nresult = i2c_add_adapter(&i2c->adap);\r\nif (result < 0)\r\ngoto out;\r\ndev_info(i2c->dev, "probed\n");\r\nreturn 0;\r\nout:\r\nreturn result;\r\n}\r\nstatic int octeon_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct octeon_i2c *i2c = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c->adap);\r\nreturn 0;\r\n}
