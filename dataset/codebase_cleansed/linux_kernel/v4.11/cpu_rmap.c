struct cpu_rmap *alloc_cpu_rmap(unsigned int size, gfp_t flags)\r\n{\r\nstruct cpu_rmap *rmap;\r\nunsigned int cpu;\r\nsize_t obj_offset;\r\nif (size > 0xffff)\r\nreturn NULL;\r\nobj_offset = ALIGN(offsetof(struct cpu_rmap, near[nr_cpu_ids]),\r\nsizeof(void *));\r\nrmap = kzalloc(obj_offset + size * sizeof(rmap->obj[0]), flags);\r\nif (!rmap)\r\nreturn NULL;\r\nkref_init(&rmap->refcount);\r\nrmap->obj = (void **)((char *)rmap + obj_offset);\r\nfor_each_possible_cpu(cpu) {\r\nrmap->near[cpu].index = cpu % size;\r\nrmap->near[cpu].dist = CPU_RMAP_DIST_INF;\r\n}\r\nrmap->size = size;\r\nreturn rmap;\r\n}\r\nstatic void cpu_rmap_release(struct kref *ref)\r\n{\r\nstruct cpu_rmap *rmap = container_of(ref, struct cpu_rmap, refcount);\r\nkfree(rmap);\r\n}\r\nstatic inline void cpu_rmap_get(struct cpu_rmap *rmap)\r\n{\r\nkref_get(&rmap->refcount);\r\n}\r\nint cpu_rmap_put(struct cpu_rmap *rmap)\r\n{\r\nreturn kref_put(&rmap->refcount, cpu_rmap_release);\r\n}\r\nstatic bool cpu_rmap_copy_neigh(struct cpu_rmap *rmap, unsigned int cpu,\r\nconst struct cpumask *mask, u16 dist)\r\n{\r\nint neigh;\r\nfor_each_cpu(neigh, mask) {\r\nif (rmap->near[cpu].dist > dist &&\r\nrmap->near[neigh].dist <= dist) {\r\nrmap->near[cpu].index = rmap->near[neigh].index;\r\nrmap->near[cpu].dist = dist;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void debug_print_rmap(const struct cpu_rmap *rmap, const char *prefix)\r\n{\r\nunsigned index;\r\nunsigned int cpu;\r\npr_info("cpu_rmap %p, %s:\n", rmap, prefix);\r\nfor_each_possible_cpu(cpu) {\r\nindex = rmap->near[cpu].index;\r\npr_info("cpu %d -> obj %u (distance %u)\n",\r\ncpu, index, rmap->near[cpu].dist);\r\n}\r\n}\r\nstatic inline void\r\ndebug_print_rmap(const struct cpu_rmap *rmap, const char *prefix)\r\n{\r\n}\r\nint cpu_rmap_add(struct cpu_rmap *rmap, void *obj)\r\n{\r\nu16 index;\r\nBUG_ON(rmap->used >= rmap->size);\r\nindex = rmap->used++;\r\nrmap->obj[index] = obj;\r\nreturn index;\r\n}\r\nint cpu_rmap_update(struct cpu_rmap *rmap, u16 index,\r\nconst struct cpumask *affinity)\r\n{\r\ncpumask_var_t update_mask;\r\nunsigned int cpu;\r\nif (unlikely(!zalloc_cpumask_var(&update_mask, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nfor_each_online_cpu(cpu) {\r\nif (rmap->near[cpu].index == index) {\r\nrmap->near[cpu].dist = CPU_RMAP_DIST_INF;\r\ncpumask_set_cpu(cpu, update_mask);\r\n}\r\n}\r\ndebug_print_rmap(rmap, "after invalidating old distances");\r\nfor_each_cpu(cpu, affinity) {\r\nrmap->near[cpu].index = index;\r\nrmap->near[cpu].dist = 0;\r\ncpumask_or(update_mask, update_mask,\r\ncpumask_of_node(cpu_to_node(cpu)));\r\n}\r\ndebug_print_rmap(rmap, "after updating neighbours");\r\nfor_each_cpu(cpu, update_mask) {\r\nif (cpu_rmap_copy_neigh(rmap, cpu,\r\ntopology_sibling_cpumask(cpu), 1))\r\ncontinue;\r\nif (cpu_rmap_copy_neigh(rmap, cpu,\r\ntopology_core_cpumask(cpu), 2))\r\ncontinue;\r\nif (cpu_rmap_copy_neigh(rmap, cpu,\r\ncpumask_of_node(cpu_to_node(cpu)), 3))\r\ncontinue;\r\n}\r\ndebug_print_rmap(rmap, "after copying neighbours");\r\nfree_cpumask_var(update_mask);\r\nreturn 0;\r\n}\r\nvoid free_irq_cpu_rmap(struct cpu_rmap *rmap)\r\n{\r\nstruct irq_glue *glue;\r\nu16 index;\r\nif (!rmap)\r\nreturn;\r\nfor (index = 0; index < rmap->used; index++) {\r\nglue = rmap->obj[index];\r\nirq_set_affinity_notifier(glue->notify.irq, NULL);\r\n}\r\ncpu_rmap_put(rmap);\r\n}\r\nstatic void\r\nirq_cpu_rmap_notify(struct irq_affinity_notify *notify, const cpumask_t *mask)\r\n{\r\nstruct irq_glue *glue =\r\ncontainer_of(notify, struct irq_glue, notify);\r\nint rc;\r\nrc = cpu_rmap_update(glue->rmap, glue->index, mask);\r\nif (rc)\r\npr_warning("irq_cpu_rmap_notify: update failed: %d\n", rc);\r\n}\r\nstatic void irq_cpu_rmap_release(struct kref *ref)\r\n{\r\nstruct irq_glue *glue =\r\ncontainer_of(ref, struct irq_glue, notify.kref);\r\ncpu_rmap_put(glue->rmap);\r\nkfree(glue);\r\n}\r\nint irq_cpu_rmap_add(struct cpu_rmap *rmap, int irq)\r\n{\r\nstruct irq_glue *glue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nint rc;\r\nif (!glue)\r\nreturn -ENOMEM;\r\nglue->notify.notify = irq_cpu_rmap_notify;\r\nglue->notify.release = irq_cpu_rmap_release;\r\nglue->rmap = rmap;\r\ncpu_rmap_get(rmap);\r\nglue->index = cpu_rmap_add(rmap, glue);\r\nrc = irq_set_affinity_notifier(irq, &glue->notify);\r\nif (rc) {\r\ncpu_rmap_put(glue->rmap);\r\nkfree(glue);\r\n}\r\nreturn rc;\r\n}
