static inline struct vf610_nfc *mtd_to_nfc(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd_to_nand(mtd), struct vf610_nfc, chip);\r\n}\r\nstatic inline u32 vf610_nfc_read(struct vf610_nfc *nfc, uint reg)\r\n{\r\nreturn readl(nfc->regs + reg);\r\n}\r\nstatic inline void vf610_nfc_write(struct vf610_nfc *nfc, uint reg, u32 val)\r\n{\r\nwritel(val, nfc->regs + reg);\r\n}\r\nstatic inline void vf610_nfc_set(struct vf610_nfc *nfc, uint reg, u32 bits)\r\n{\r\nvf610_nfc_write(nfc, reg, vf610_nfc_read(nfc, reg) | bits);\r\n}\r\nstatic inline void vf610_nfc_clear(struct vf610_nfc *nfc, uint reg, u32 bits)\r\n{\r\nvf610_nfc_write(nfc, reg, vf610_nfc_read(nfc, reg) & ~bits);\r\n}\r\nstatic inline void vf610_nfc_set_field(struct vf610_nfc *nfc, u32 reg,\r\nu32 mask, u32 shift, u32 val)\r\n{\r\nvf610_nfc_write(nfc, reg,\r\n(vf610_nfc_read(nfc, reg) & (~mask)) | val << shift);\r\n}\r\nstatic inline void vf610_nfc_memcpy(void *dst, const void __iomem *src,\r\nsize_t n)\r\n{\r\nmemcpy(dst, src, n);\r\n}\r\nstatic inline void vf610_nfc_clear_status(struct vf610_nfc *nfc)\r\n{\r\nu32 tmp = vf610_nfc_read(nfc, NFC_IRQ_STATUS);\r\ntmp |= CMD_DONE_CLEAR_BIT | IDLE_CLEAR_BIT;\r\nvf610_nfc_write(nfc, NFC_IRQ_STATUS, tmp);\r\n}\r\nstatic void vf610_nfc_done(struct vf610_nfc *nfc)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(100);\r\nvf610_nfc_set(nfc, NFC_IRQ_STATUS, IDLE_EN_BIT);\r\nvf610_nfc_set(nfc, NFC_FLASH_CMD2, START_BIT);\r\nif (!wait_for_completion_timeout(&nfc->cmd_done, timeout))\r\ndev_warn(nfc->dev, "Timeout while waiting for BUSY.\n");\r\nvf610_nfc_clear_status(nfc);\r\n}\r\nstatic u8 vf610_nfc_get_id(struct vf610_nfc *nfc, int col)\r\n{\r\nu32 flash_id;\r\nif (col < 4) {\r\nflash_id = vf610_nfc_read(nfc, NFC_FLASH_STATUS1);\r\nflash_id >>= (3 - col) * 8;\r\n} else {\r\nflash_id = vf610_nfc_read(nfc, NFC_FLASH_STATUS2);\r\nflash_id >>= 24;\r\n}\r\nreturn flash_id & 0xff;\r\n}\r\nstatic u8 vf610_nfc_get_status(struct vf610_nfc *nfc)\r\n{\r\nreturn vf610_nfc_read(nfc, NFC_FLASH_STATUS2) & STATUS_BYTE1_MASK;\r\n}\r\nstatic void vf610_nfc_send_command(struct vf610_nfc *nfc, u32 cmd_byte1,\r\nu32 cmd_code)\r\n{\r\nu32 tmp;\r\nvf610_nfc_clear_status(nfc);\r\ntmp = vf610_nfc_read(nfc, NFC_FLASH_CMD2);\r\ntmp &= ~(CMD_BYTE1_MASK | CMD_CODE_MASK | BUFNO_MASK);\r\ntmp |= cmd_byte1 << CMD_BYTE1_SHIFT;\r\ntmp |= cmd_code << CMD_CODE_SHIFT;\r\nvf610_nfc_write(nfc, NFC_FLASH_CMD2, tmp);\r\n}\r\nstatic void vf610_nfc_send_commands(struct vf610_nfc *nfc, u32 cmd_byte1,\r\nu32 cmd_byte2, u32 cmd_code)\r\n{\r\nu32 tmp;\r\nvf610_nfc_send_command(nfc, cmd_byte1, cmd_code);\r\ntmp = vf610_nfc_read(nfc, NFC_FLASH_CMD1);\r\ntmp &= ~CMD_BYTE2_MASK;\r\ntmp |= cmd_byte2 << CMD_BYTE2_SHIFT;\r\nvf610_nfc_write(nfc, NFC_FLASH_CMD1, tmp);\r\n}\r\nstatic irqreturn_t vf610_nfc_irq(int irq, void *data)\r\n{\r\nstruct mtd_info *mtd = data;\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nvf610_nfc_clear(nfc, NFC_IRQ_STATUS, IDLE_EN_BIT);\r\ncomplete(&nfc->cmd_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void vf610_nfc_addr_cycle(struct vf610_nfc *nfc, int column, int page)\r\n{\r\nif (column != -1) {\r\nif (nfc->chip.options & NAND_BUSWIDTH_16)\r\ncolumn = column / 2;\r\nvf610_nfc_set_field(nfc, NFC_COL_ADDR, COL_ADDR_MASK,\r\nCOL_ADDR_SHIFT, column);\r\n}\r\nif (page != -1)\r\nvf610_nfc_set_field(nfc, NFC_ROW_ADDR, ROW_ADDR_MASK,\r\nROW_ADDR_SHIFT, page);\r\n}\r\nstatic inline void vf610_nfc_ecc_mode(struct vf610_nfc *nfc, int ecc_mode)\r\n{\r\nvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG,\r\nCONFIG_ECC_MODE_MASK,\r\nCONFIG_ECC_MODE_SHIFT, ecc_mode);\r\n}\r\nstatic inline void vf610_nfc_transfer_size(struct vf610_nfc *nfc, int size)\r\n{\r\nvf610_nfc_write(nfc, NFC_SECTOR_SIZE, size);\r\n}\r\nstatic void vf610_nfc_command(struct mtd_info *mtd, unsigned command,\r\nint column, int page)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nint trfr_sz = nfc->chip.options & NAND_BUSWIDTH_16 ? 1 : 0;\r\nnfc->buf_offset = max(column, 0);\r\nnfc->alt_buf = ALT_BUF_DATA;\r\nswitch (command) {\r\ncase NAND_CMD_SEQIN:\r\nvf610_nfc_addr_cycle(nfc, column, page);\r\nnfc->buf_offset = 0;\r\nreturn;\r\ncase NAND_CMD_PAGEPROG:\r\ntrfr_sz += nfc->write_sz;\r\nvf610_nfc_transfer_size(nfc, trfr_sz);\r\nvf610_nfc_send_commands(nfc, NAND_CMD_SEQIN,\r\ncommand, PROGRAM_PAGE_CMD_CODE);\r\nif (nfc->use_hw_ecc)\r\nvf610_nfc_ecc_mode(nfc, nfc->ecc_mode);\r\nelse\r\nvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\r\nbreak;\r\ncase NAND_CMD_RESET:\r\nvf610_nfc_transfer_size(nfc, 0);\r\nvf610_nfc_send_command(nfc, command, RESET_CMD_CODE);\r\nbreak;\r\ncase NAND_CMD_READOOB:\r\ntrfr_sz += mtd->oobsize;\r\ncolumn = mtd->writesize;\r\nvf610_nfc_transfer_size(nfc, trfr_sz);\r\nvf610_nfc_send_commands(nfc, NAND_CMD_READ0,\r\nNAND_CMD_READSTART, READ_PAGE_CMD_CODE);\r\nvf610_nfc_addr_cycle(nfc, column, page);\r\nvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ntrfr_sz += mtd->writesize + mtd->oobsize;\r\nvf610_nfc_transfer_size(nfc, trfr_sz);\r\nvf610_nfc_send_commands(nfc, NAND_CMD_READ0,\r\nNAND_CMD_READSTART, READ_PAGE_CMD_CODE);\r\nvf610_nfc_addr_cycle(nfc, column, page);\r\nvf610_nfc_ecc_mode(nfc, nfc->ecc_mode);\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\nnfc->alt_buf = ALT_BUF_ONFI;\r\ntrfr_sz = 3 * sizeof(struct nand_onfi_params);\r\nvf610_nfc_transfer_size(nfc, trfr_sz);\r\nvf610_nfc_send_command(nfc, command, READ_ONFI_PARAM_CMD_CODE);\r\nvf610_nfc_addr_cycle(nfc, -1, column);\r\nvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nvf610_nfc_transfer_size(nfc, 0);\r\nvf610_nfc_send_commands(nfc, command,\r\nNAND_CMD_ERASE2, ERASE_CMD_CODE);\r\nvf610_nfc_addr_cycle(nfc, column, page);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nnfc->alt_buf = ALT_BUF_ID;\r\nnfc->buf_offset = 0;\r\nvf610_nfc_transfer_size(nfc, 0);\r\nvf610_nfc_send_command(nfc, command, READ_ID_CMD_CODE);\r\nvf610_nfc_addr_cycle(nfc, -1, column);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nnfc->alt_buf = ALT_BUF_STAT;\r\nvf610_nfc_transfer_size(nfc, 0);\r\nvf610_nfc_send_command(nfc, command, STATUS_READ_CMD_CODE);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nvf610_nfc_done(nfc);\r\nnfc->use_hw_ecc = false;\r\nnfc->write_sz = 0;\r\n}\r\nstatic void vf610_nfc_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nuint c = nfc->buf_offset;\r\nWARN_ON(nfc->alt_buf);\r\nvf610_nfc_memcpy(buf, nfc->regs + NFC_MAIN_AREA(0) + c, len);\r\nnfc->buf_offset += len;\r\n}\r\nstatic void vf610_nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf,\r\nint len)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nuint c = nfc->buf_offset;\r\nuint l;\r\nl = min_t(uint, len, mtd->writesize + mtd->oobsize - c);\r\nvf610_nfc_memcpy(nfc->regs + NFC_MAIN_AREA(0) + c, buf, l);\r\nnfc->write_sz += l;\r\nnfc->buf_offset += l;\r\n}\r\nstatic uint8_t vf610_nfc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nu8 tmp;\r\nuint c = nfc->buf_offset;\r\nswitch (nfc->alt_buf) {\r\ncase ALT_BUF_ID:\r\ntmp = vf610_nfc_get_id(nfc, c);\r\nbreak;\r\ncase ALT_BUF_STAT:\r\ntmp = vf610_nfc_get_status(nfc);\r\nbreak;\r\n#ifdef __LITTLE_ENDIAN\r\ncase ALT_BUF_ONFI:\r\nc = nfc->buf_offset ^ 0x3;\r\n#endif\r\ndefault:\r\ntmp = *((u8 *)(nfc->regs + NFC_MAIN_AREA(0) + c));\r\nbreak;\r\n}\r\nnfc->buf_offset++;\r\nreturn tmp;\r\n}\r\nstatic u16 vf610_nfc_read_word(struct mtd_info *mtd)\r\n{\r\nu16 tmp;\r\nvf610_nfc_read_buf(mtd, (u_char *)&tmp, sizeof(tmp));\r\nreturn tmp;\r\n}\r\nstatic int vf610_nfc_dev_ready(struct mtd_info *mtd)\r\n{\r\nreturn 1;\r\n}\r\nstatic void vf610_nfc_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nu32 tmp = vf610_nfc_read(nfc, NFC_ROW_ADDR);\r\nif (nfc->variant != NFC_VFC610)\r\nreturn;\r\ntmp &= ~(ROW_ADDR_CHIP_SEL_RB_MASK | ROW_ADDR_CHIP_SEL_MASK);\r\nif (chip >= 0) {\r\ntmp |= 1 << ROW_ADDR_CHIP_SEL_RB_SHIFT;\r\ntmp |= BIT(chip) << ROW_ADDR_CHIP_SEL_SHIFT;\r\n}\r\nvf610_nfc_write(nfc, NFC_ROW_ADDR, tmp);\r\n}\r\nstatic inline int count_written_bits(uint8_t *buff, int size, int max_bits)\r\n{\r\nuint32_t *buff32 = (uint32_t *)buff;\r\nint k, written_bits = 0;\r\nfor (k = 0; k < (size / 4); k++) {\r\nwritten_bits += hweight32(~buff32[k]);\r\nif (unlikely(written_bits > max_bits))\r\nbreak;\r\n}\r\nreturn written_bits;\r\n}\r\nstatic inline int vf610_nfc_correct_data(struct mtd_info *mtd, uint8_t *dat,\r\nuint8_t *oob, int page)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nu32 ecc_status_off = NFC_MAIN_AREA(0) + ECC_SRAM_ADDR + ECC_STATUS;\r\nu8 ecc_status;\r\nu8 ecc_count;\r\nint flips_threshold = nfc->chip.ecc.strength / 2;\r\necc_status = vf610_nfc_read(nfc, ecc_status_off) & 0xff;\r\necc_count = ecc_status & ECC_STATUS_ERR_COUNT;\r\nif (!(ecc_status & ECC_STATUS_MASK))\r\nreturn ecc_count;\r\nvf610_nfc_command(mtd, NAND_CMD_READOOB, 0, page);\r\nvf610_nfc_read_buf(mtd, oob, mtd->oobsize);\r\nreturn nand_check_erased_ecc_chunk(dat, nfc->chip.ecc.size, oob,\r\nmtd->oobsize, NULL, 0,\r\nflips_threshold);\r\n}\r\nstatic int vf610_nfc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nint eccsize = chip->ecc.size;\r\nint stat;\r\nvf610_nfc_read_buf(mtd, buf, eccsize);\r\nif (oob_required)\r\nvf610_nfc_read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nstat = vf610_nfc_correct_data(mtd, buf, chip->oob_poi, page);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\nreturn 0;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nreturn stat;\r\n}\r\n}\r\nstatic int vf610_nfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nvf610_nfc_write_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nvf610_nfc_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nnfc->use_hw_ecc = true;\r\nnfc->write_sz = mtd->writesize + mtd->oobsize;\r\nreturn 0;\r\n}\r\nstatic void vf610_nfc_preinit_controller(struct vf610_nfc *nfc)\r\n{\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_ADDR_AUTO_INCR_BIT);\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_BUFNO_AUTO_INCR_BIT);\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_BOOT_MODE_BIT);\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_DMA_REQ_BIT);\r\nvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_FAST_FLASH_BIT);\r\nvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG, CONFIG_PAGE_CNT_MASK,\r\nCONFIG_PAGE_CNT_SHIFT, 1);\r\n}\r\nstatic void vf610_nfc_init_controller(struct vf610_nfc *nfc)\r\n{\r\nif (nfc->chip.options & NAND_BUSWIDTH_16)\r\nvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\r\nelse\r\nvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\r\nif (nfc->chip.ecc.mode == NAND_ECC_HW) {\r\nvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG,\r\nCONFIG_ECC_SRAM_ADDR_MASK,\r\nCONFIG_ECC_SRAM_ADDR_SHIFT,\r\nECC_SRAM_ADDR >> 3);\r\nvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_ECC_SRAM_REQ_BIT);\r\n}\r\n}\r\nstatic int vf610_nfc_probe(struct platform_device *pdev)\r\n{\r\nstruct vf610_nfc *nfc;\r\nstruct resource *res;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nstruct device_node *child;\r\nconst struct of_device_id *of_id;\r\nint err;\r\nint irq;\r\nnfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);\r\nif (!nfc)\r\nreturn -ENOMEM;\r\nnfc->dev = &pdev->dev;\r\nchip = &nfc->chip;\r\nmtd = nand_to_mtd(chip);\r\nmtd->owner = THIS_MODULE;\r\nmtd->dev.parent = nfc->dev;\r\nmtd->name = DRV_NAME;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnfc->regs = devm_ioremap_resource(nfc->dev, res);\r\nif (IS_ERR(nfc->regs))\r\nreturn PTR_ERR(nfc->regs);\r\nnfc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(nfc->clk))\r\nreturn PTR_ERR(nfc->clk);\r\nerr = clk_prepare_enable(nfc->clk);\r\nif (err) {\r\ndev_err(nfc->dev, "Unable to enable clock!\n");\r\nreturn err;\r\n}\r\nof_id = of_match_device(vf610_nfc_dt_ids, &pdev->dev);\r\nnfc->variant = (enum vf610_nfc_variant)of_id->data;\r\nfor_each_available_child_of_node(nfc->dev->of_node, child) {\r\nif (of_device_is_compatible(child, "fsl,vf610-nfc-nandcs")) {\r\nif (nand_get_flash_node(chip)) {\r\ndev_err(nfc->dev,\r\n"Only one NAND chip supported!\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nnand_set_flash_node(chip, child);\r\n}\r\n}\r\nif (!nand_get_flash_node(chip)) {\r\ndev_err(nfc->dev, "NAND chip sub-node missing!\n");\r\nerr = -ENODEV;\r\ngoto err_clk;\r\n}\r\nchip->dev_ready = vf610_nfc_dev_ready;\r\nchip->cmdfunc = vf610_nfc_command;\r\nchip->read_byte = vf610_nfc_read_byte;\r\nchip->read_word = vf610_nfc_read_word;\r\nchip->read_buf = vf610_nfc_read_buf;\r\nchip->write_buf = vf610_nfc_write_buf;\r\nchip->select_chip = vf610_nfc_select_chip;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE;\r\ninit_completion(&nfc->cmd_done);\r\nerr = devm_request_irq(nfc->dev, irq, vf610_nfc_irq, 0, DRV_NAME, mtd);\r\nif (err) {\r\ndev_err(nfc->dev, "Error requesting IRQ!\n");\r\ngoto error;\r\n}\r\nvf610_nfc_preinit_controller(nfc);\r\nerr = nand_scan_ident(mtd, 1, NULL);\r\nif (err)\r\ngoto error;\r\nvf610_nfc_init_controller(nfc);\r\nif (chip->bbt_options & NAND_BBT_USE_FLASH)\r\nchip->bbt_options |= NAND_BBT_NO_OOB;\r\nif (mtd->writesize + mtd->oobsize > PAGE_2K + OOB_MAX - 8) {\r\ndev_err(nfc->dev, "Unsupported flash page size\n");\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nif (chip->ecc.mode == NAND_ECC_HW) {\r\nif (mtd->writesize != PAGE_2K && mtd->oobsize < 64) {\r\ndev_err(nfc->dev, "Unsupported flash with hwecc\n");\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nif (chip->ecc.size != mtd->writesize) {\r\ndev_err(nfc->dev, "Step size needs to be page size\n");\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nif (mtd->oobsize > 64)\r\nmtd->oobsize = 64;\r\nif (chip->ecc.strength == 32) {\r\nnfc->ecc_mode = ECC_60_BYTE;\r\nchip->ecc.bytes = 60;\r\n} else if (chip->ecc.strength == 24) {\r\nnfc->ecc_mode = ECC_45_BYTE;\r\nchip->ecc.bytes = 45;\r\n} else {\r\ndev_err(nfc->dev, "Unsupported ECC strength\n");\r\nerr = -ENXIO;\r\ngoto error;\r\n}\r\nchip->ecc.read_page = vf610_nfc_read_page;\r\nchip->ecc.write_page = vf610_nfc_write_page;\r\nchip->ecc.size = PAGE_2K;\r\n}\r\nerr = nand_scan_tail(mtd);\r\nif (err)\r\ngoto error;\r\nplatform_set_drvdata(pdev, mtd);\r\nreturn mtd_device_register(mtd, NULL, 0);\r\nerror:\r\nof_node_put(nand_get_flash_node(chip));\r\nerr_clk:\r\nclk_disable_unprepare(nfc->clk);\r\nreturn err;\r\n}\r\nstatic int vf610_nfc_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nnand_release(mtd);\r\nclk_disable_unprepare(nfc->clk);\r\nreturn 0;\r\n}\r\nstatic int vf610_nfc_suspend(struct device *dev)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\nclk_disable_unprepare(nfc->clk);\r\nreturn 0;\r\n}\r\nstatic int vf610_nfc_resume(struct device *dev)\r\n{\r\nstruct mtd_info *mtd = dev_get_drvdata(dev);\r\nstruct vf610_nfc *nfc = mtd_to_nfc(mtd);\r\npinctrl_pm_select_default_state(dev);\r\nclk_prepare_enable(nfc->clk);\r\nvf610_nfc_preinit_controller(nfc);\r\nvf610_nfc_init_controller(nfc);\r\nreturn 0;\r\n}
