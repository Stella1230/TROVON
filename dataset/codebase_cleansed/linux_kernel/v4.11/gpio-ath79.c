static struct ath79_gpio_ctrl *irq_data_to_ath79_gpio(struct irq_data *data)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nreturn container_of(gc, struct ath79_gpio_ctrl, gc);\r\n}\r\nstatic u32 ath79_gpio_read(struct ath79_gpio_ctrl *ctrl, unsigned reg)\r\n{\r\nreturn readl(ctrl->base + reg);\r\n}\r\nstatic void ath79_gpio_write(struct ath79_gpio_ctrl *ctrl,\r\nunsigned reg, u32 val)\r\n{\r\nreturn writel(val, ctrl->base + reg);\r\n}\r\nstatic bool ath79_gpio_update_bits(\r\nstruct ath79_gpio_ctrl *ctrl, unsigned reg, u32 mask, u32 bits)\r\n{\r\nu32 old_val, new_val;\r\nold_val = ath79_gpio_read(ctrl, reg);\r\nnew_val = (old_val & ~mask) | (bits & mask);\r\nif (new_val != old_val)\r\nath79_gpio_write(ctrl, reg, new_val);\r\nreturn new_val != old_val;\r\n}\r\nstatic void ath79_gpio_irq_unmask(struct irq_data *data)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\r\nu32 mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, mask);\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\n}\r\nstatic void ath79_gpio_irq_mask(struct irq_data *data)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\r\nu32 mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, 0);\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\n}\r\nstatic void ath79_gpio_irq_enable(struct irq_data *data)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\r\nu32 mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, mask);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, mask);\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\n}\r\nstatic void ath79_gpio_irq_disable(struct irq_data *data)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\r\nu32 mask = BIT(irqd_to_hwirq(data));\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_MASK, mask, 0);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, 0);\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\n}\r\nstatic int ath79_gpio_irq_set_type(struct irq_data *data,\r\nunsigned int flow_type)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = irq_data_to_ath79_gpio(data);\r\nu32 mask = BIT(irqd_to_hwirq(data));\r\nu32 type = 0, polarity = 0;\r\nunsigned long flags;\r\nbool disabled;\r\nswitch (flow_type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\npolarity |= mask;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\npolarity |= mask;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntype |= mask;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\nif (flow_type == IRQ_TYPE_EDGE_BOTH) {\r\nctrl->both_edges |= mask;\r\npolarity = ~ath79_gpio_read(ctrl, AR71XX_GPIO_REG_IN);\r\n} else {\r\nctrl->both_edges &= ~mask;\r\n}\r\ndisabled = ath79_gpio_update_bits(\r\nctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, 0);\r\nath79_gpio_update_bits(\r\nctrl, AR71XX_GPIO_REG_INT_TYPE, mask, type);\r\nath79_gpio_update_bits(\r\nctrl, AR71XX_GPIO_REG_INT_POLARITY, mask, polarity);\r\nif (disabled)\r\nath79_gpio_update_bits(\r\nctrl, AR71XX_GPIO_REG_INT_ENABLE, mask, mask);\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ath79_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nstruct ath79_gpio_ctrl *ctrl =\r\ncontainer_of(gc, struct ath79_gpio_ctrl, gc);\r\nunsigned long flags, pending;\r\nu32 both_edges, state;\r\nint irq;\r\nchained_irq_enter(irqchip, desc);\r\nspin_lock_irqsave(&ctrl->lock, flags);\r\npending = ath79_gpio_read(ctrl, AR71XX_GPIO_REG_INT_PENDING);\r\nboth_edges = ctrl->both_edges & pending;\r\nif (both_edges) {\r\nstate = ath79_gpio_read(ctrl, AR71XX_GPIO_REG_IN);\r\nath79_gpio_update_bits(ctrl, AR71XX_GPIO_REG_INT_POLARITY,\r\nboth_edges, ~state);\r\n}\r\nspin_unlock_irqrestore(&ctrl->lock, flags);\r\nif (pending) {\r\nfor_each_set_bit(irq, &pending, gc->ngpio)\r\ngeneric_handle_irq(\r\nirq_linear_revmap(gc->irqdomain, irq));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic int ath79_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct ath79_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct ath79_gpio_ctrl *ctrl;\r\nstruct resource *res;\r\nu32 ath79_gpio_count;\r\nbool oe_inverted;\r\nint err;\r\nctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ctrl);\r\nif (np) {\r\nerr = of_property_read_u32(np, "ngpios", &ath79_gpio_count);\r\nif (err) {\r\ndev_err(&pdev->dev, "ngpios property is not valid\n");\r\nreturn err;\r\n}\r\noe_inverted = of_device_is_compatible(np, "qca,ar9340-gpio");\r\n} else if (pdata) {\r\nath79_gpio_count = pdata->ngpios;\r\noe_inverted = pdata->oe_inverted;\r\n} else {\r\ndev_err(&pdev->dev, "No DT node or platform data found\n");\r\nreturn -EINVAL;\r\n}\r\nif (ath79_gpio_count >= 32) {\r\ndev_err(&pdev->dev, "ngpios must be less than 32\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nctrl->base = devm_ioremap_nocache(\r\n&pdev->dev, res->start, resource_size(res));\r\nif (!ctrl->base)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ctrl->lock);\r\nerr = bgpio_init(&ctrl->gc, &pdev->dev, 4,\r\nctrl->base + AR71XX_GPIO_REG_IN,\r\nctrl->base + AR71XX_GPIO_REG_SET,\r\nctrl->base + AR71XX_GPIO_REG_CLEAR,\r\noe_inverted ? NULL : ctrl->base + AR71XX_GPIO_REG_OE,\r\noe_inverted ? ctrl->base + AR71XX_GPIO_REG_OE : NULL,\r\n0);\r\nif (err) {\r\ndev_err(&pdev->dev, "bgpio_init failed\n");\r\nreturn err;\r\n}\r\nctrl->gc.base = 0;\r\nerr = gpiochip_add_data(&ctrl->gc, ctrl);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"cannot add AR71xx GPIO chip, error=%d", err);\r\nreturn err;\r\n}\r\nif (np && !of_property_read_bool(np, "interrupt-controller"))\r\nreturn 0;\r\nerr = gpiochip_irqchip_add(&ctrl->gc, &ath79_gpio_irqchip, 0,\r\nhandle_simple_irq, IRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to add gpiochip_irqchip\n");\r\ngoto gpiochip_remove;\r\n}\r\ngpiochip_set_chained_irqchip(&ctrl->gc, &ath79_gpio_irqchip,\r\nplatform_get_irq(pdev, 0),\r\nath79_gpio_irq_handler);\r\nreturn 0;\r\ngpiochip_remove:\r\ngpiochip_remove(&ctrl->gc);\r\nreturn err;\r\n}\r\nstatic int ath79_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct ath79_gpio_ctrl *ctrl = platform_get_drvdata(pdev);\r\ngpiochip_remove(&ctrl->gc);\r\nreturn 0;\r\n}
