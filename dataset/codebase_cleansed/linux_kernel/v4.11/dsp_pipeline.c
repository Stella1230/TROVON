static ssize_t\r\nattr_show_args(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct mISDN_dsp_element *elem = dev_get_drvdata(dev);\r\nint i;\r\nchar *p = buf;\r\n*buf = 0;\r\nfor (i = 0; i < elem->num_args; i++)\r\np += sprintf(p, "Name: %s\n%s%s%sDescription: %s\n\n",\r\nelem->args[i].name,\r\nelem->args[i].def ? "Default: " : "",\r\nelem->args[i].def ? elem->args[i].def : "",\r\nelem->args[i].def ? "\n" : "",\r\nelem->args[i].desc);\r\nreturn p - buf;\r\n}\r\nstatic void\r\nmISDN_dsp_dev_release(struct device *dev)\r\n{\r\nstruct dsp_element_entry *entry =\r\ncontainer_of(dev, struct dsp_element_entry, dev);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nint mISDN_dsp_element_register(struct mISDN_dsp_element *elem)\r\n{\r\nstruct dsp_element_entry *entry;\r\nint ret, i;\r\nif (!elem)\r\nreturn -EINVAL;\r\nentry = kzalloc(sizeof(struct dsp_element_entry), GFP_ATOMIC);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->elem = elem;\r\nentry->dev.class = elements_class;\r\nentry->dev.release = mISDN_dsp_dev_release;\r\ndev_set_drvdata(&entry->dev, elem);\r\ndev_set_name(&entry->dev, "%s", elem->name);\r\nret = device_register(&entry->dev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to register %s\n",\r\n__func__, elem->name);\r\ngoto err1;\r\n}\r\nlist_add_tail(&entry->list, &dsp_elements);\r\nfor (i = 0; i < ARRAY_SIZE(element_attributes); ++i) {\r\nret = device_create_file(&entry->dev,\r\n&element_attributes[i]);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: failed to create device file\n",\r\n__func__);\r\ngoto err2;\r\n}\r\n}\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: %s registered\n", __func__, elem->name);\r\n#endif\r\nreturn 0;\r\nerr2:\r\ndevice_unregister(&entry->dev);\r\nreturn ret;\r\nerr1:\r\nkfree(entry);\r\nreturn ret;\r\n}\r\nvoid mISDN_dsp_element_unregister(struct mISDN_dsp_element *elem)\r\n{\r\nstruct dsp_element_entry *entry, *n;\r\nif (!elem)\r\nreturn;\r\nlist_for_each_entry_safe(entry, n, &dsp_elements, list)\r\nif (entry->elem == elem) {\r\ndevice_unregister(&entry->dev);\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: %s unregistered\n",\r\n__func__, elem->name);\r\n#endif\r\nreturn;\r\n}\r\nprintk(KERN_ERR "%s: element %s not in list.\n", __func__, elem->name);\r\n}\r\nint dsp_pipeline_module_init(void)\r\n{\r\nelements_class = class_create(THIS_MODULE, "dsp_pipeline");\r\nif (IS_ERR(elements_class))\r\nreturn PTR_ERR(elements_class);\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: dsp pipeline module initialized\n", __func__);\r\n#endif\r\ndsp_hwec_init();\r\nreturn 0;\r\n}\r\nvoid dsp_pipeline_module_exit(void)\r\n{\r\nstruct dsp_element_entry *entry, *n;\r\ndsp_hwec_exit();\r\nclass_destroy(elements_class);\r\nlist_for_each_entry_safe(entry, n, &dsp_elements, list) {\r\nlist_del(&entry->list);\r\nprintk(KERN_WARNING "%s: element was still registered: %s\n",\r\n__func__, entry->elem->name);\r\nkfree(entry);\r\n}\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: dsp pipeline module exited\n", __func__);\r\n#endif\r\n}\r\nint dsp_pipeline_init(struct dsp_pipeline *pipeline)\r\n{\r\nif (!pipeline)\r\nreturn -EINVAL;\r\nINIT_LIST_HEAD(&pipeline->list);\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: dsp pipeline ready\n", __func__);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void _dsp_pipeline_destroy(struct dsp_pipeline *pipeline)\r\n{\r\nstruct dsp_pipeline_entry *entry, *n;\r\nlist_for_each_entry_safe(entry, n, &pipeline->list, list) {\r\nlist_del(&entry->list);\r\nif (entry->elem == dsp_hwec)\r\ndsp_hwec_disable(container_of(pipeline, struct dsp,\r\npipeline));\r\nelse\r\nentry->elem->free(entry->p);\r\nkfree(entry);\r\n}\r\n}\r\nvoid dsp_pipeline_destroy(struct dsp_pipeline *pipeline)\r\n{\r\nif (!pipeline)\r\nreturn;\r\n_dsp_pipeline_destroy(pipeline);\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: dsp pipeline destroyed\n", __func__);\r\n#endif\r\n}\r\nint dsp_pipeline_build(struct dsp_pipeline *pipeline, const char *cfg)\r\n{\r\nint incomplete = 0, found = 0;\r\nchar *dup, *tok, *name, *args;\r\nstruct dsp_element_entry *entry, *n;\r\nstruct dsp_pipeline_entry *pipeline_entry;\r\nstruct mISDN_dsp_element *elem;\r\nif (!pipeline)\r\nreturn -EINVAL;\r\nif (!list_empty(&pipeline->list))\r\n_dsp_pipeline_destroy(pipeline);\r\ndup = kstrdup(cfg, GFP_ATOMIC);\r\nif (!dup)\r\nreturn 0;\r\nwhile ((tok = strsep(&dup, "|"))) {\r\nif (!strlen(tok))\r\ncontinue;\r\nname = strsep(&tok, "(");\r\nargs = strsep(&tok, ")");\r\nif (args && !*args)\r\nargs = NULL;\r\nlist_for_each_entry_safe(entry, n, &dsp_elements, list)\r\nif (!strcmp(entry->elem->name, name)) {\r\nelem = entry->elem;\r\npipeline_entry = kmalloc(sizeof(struct\r\ndsp_pipeline_entry), GFP_ATOMIC);\r\nif (!pipeline_entry) {\r\nprintk(KERN_ERR "%s: failed to add "\r\n"entry to pipeline: %s (out of "\r\n"memory)\n", __func__, elem->name);\r\nincomplete = 1;\r\ngoto _out;\r\n}\r\npipeline_entry->elem = elem;\r\nif (elem == dsp_hwec) {\r\ndsp_hwec_enable(container_of(pipeline,\r\nstruct dsp, pipeline), args);\r\nlist_add_tail(&pipeline_entry->list,\r\n&pipeline->list);\r\n} else {\r\npipeline_entry->p = elem->new(args);\r\nif (pipeline_entry->p) {\r\nlist_add_tail(&pipeline_entry->\r\nlist, &pipeline->list);\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: created "\r\n"instance of %s%s%s\n",\r\n__func__, name, args ?\r\n" with args " : "", args ?\r\nargs : "");\r\n#endif\r\n} else {\r\nprintk(KERN_ERR "%s: failed "\r\n"to add entry to pipeline: "\r\n"%s (new() returned NULL)\n",\r\n__func__, elem->name);\r\nkfree(pipeline_entry);\r\nincomplete = 1;\r\n}\r\n}\r\nfound = 1;\r\nbreak;\r\n}\r\nif (found)\r\nfound = 0;\r\nelse {\r\nprintk(KERN_ERR "%s: element not found, skipping: "\r\n"%s\n", __func__, name);\r\nincomplete = 1;\r\n}\r\n}\r\n_out:\r\nif (!list_empty(&pipeline->list))\r\npipeline->inuse = 1;\r\nelse\r\npipeline->inuse = 0;\r\n#ifdef PIPELINE_DEBUG\r\nprintk(KERN_DEBUG "%s: dsp pipeline built%s: %s\n",\r\n__func__, incomplete ? " incomplete" : "", cfg);\r\n#endif\r\nkfree(dup);\r\nreturn 0;\r\n}\r\nvoid dsp_pipeline_process_tx(struct dsp_pipeline *pipeline, u8 *data, int len)\r\n{\r\nstruct dsp_pipeline_entry *entry;\r\nif (!pipeline)\r\nreturn;\r\nlist_for_each_entry(entry, &pipeline->list, list)\r\nif (entry->elem->process_tx)\r\nentry->elem->process_tx(entry->p, data, len);\r\n}\r\nvoid dsp_pipeline_process_rx(struct dsp_pipeline *pipeline, u8 *data, int len,\r\nunsigned int txlen)\r\n{\r\nstruct dsp_pipeline_entry *entry;\r\nif (!pipeline)\r\nreturn;\r\nlist_for_each_entry_reverse(entry, &pipeline->list, list)\r\nif (entry->elem->process_rx)\r\nentry->elem->process_rx(entry->p, data, len, txlen);\r\n}
