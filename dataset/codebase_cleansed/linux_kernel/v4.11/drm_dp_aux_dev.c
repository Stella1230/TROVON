static struct drm_dp_aux_dev *drm_dp_aux_dev_get_by_minor(unsigned index)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev = NULL;\r\nmutex_lock(&aux_idr_mutex);\r\naux_dev = idr_find(&aux_idr, index);\r\nif (!kref_get_unless_zero(&aux_dev->refcount))\r\naux_dev = NULL;\r\nmutex_unlock(&aux_idr_mutex);\r\nreturn aux_dev;\r\n}\r\nstatic struct drm_dp_aux_dev *alloc_drm_dp_aux_dev(struct drm_dp_aux *aux)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev;\r\nint index;\r\naux_dev = kzalloc(sizeof(*aux_dev), GFP_KERNEL);\r\nif (!aux_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\naux_dev->aux = aux;\r\natomic_set(&aux_dev->usecount, 1);\r\nkref_init(&aux_dev->refcount);\r\nmutex_lock(&aux_idr_mutex);\r\nindex = idr_alloc_cyclic(&aux_idr, aux_dev, 0, DRM_AUX_MINORS,\r\nGFP_KERNEL);\r\nmutex_unlock(&aux_idr_mutex);\r\nif (index < 0) {\r\nkfree(aux_dev);\r\nreturn ERR_PTR(index);\r\n}\r\naux_dev->index = index;\r\nreturn aux_dev;\r\n}\r\nstatic void release_drm_dp_aux_dev(struct kref *ref)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev =\r\ncontainer_of(ref, struct drm_dp_aux_dev, refcount);\r\nkfree(aux_dev);\r\n}\r\nstatic ssize_t name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t res;\r\nstruct drm_dp_aux_dev *aux_dev =\r\ndrm_dp_aux_dev_get_by_minor(MINOR(dev->devt));\r\nif (!aux_dev)\r\nreturn -ENODEV;\r\nres = sprintf(buf, "%s\n", aux_dev->aux->name);\r\nkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\r\nreturn res;\r\n}\r\nstatic int auxdev_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct drm_dp_aux_dev *aux_dev;\r\naux_dev = drm_dp_aux_dev_get_by_minor(minor);\r\nif (!aux_dev)\r\nreturn -ENODEV;\r\nfile->private_data = aux_dev;\r\nreturn 0;\r\n}\r\nstatic loff_t auxdev_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nreturn fixed_size_llseek(file, offset, whence, AUX_MAX_OFFSET);\r\n}\r\nstatic ssize_t auxdev_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *offset)\r\n{\r\nsize_t bytes_pending, num_bytes_processed = 0;\r\nstruct drm_dp_aux_dev *aux_dev = file->private_data;\r\nssize_t res = 0;\r\nif (!atomic_inc_not_zero(&aux_dev->usecount))\r\nreturn -ENODEV;\r\nbytes_pending = min((loff_t)count, AUX_MAX_OFFSET - (*offset));\r\nif (!access_ok(VERIFY_WRITE, buf, bytes_pending)) {\r\nres = -EFAULT;\r\ngoto out;\r\n}\r\nwhile (bytes_pending > 0) {\r\nuint8_t localbuf[DP_AUX_MAX_PAYLOAD_BYTES];\r\nssize_t todo = min_t(size_t, bytes_pending, sizeof(localbuf));\r\nif (signal_pending(current)) {\r\nres = num_bytes_processed ?\r\nnum_bytes_processed : -ERESTARTSYS;\r\ngoto out;\r\n}\r\nres = drm_dp_dpcd_read(aux_dev->aux, *offset, localbuf, todo);\r\nif (res <= 0) {\r\nres = num_bytes_processed ? num_bytes_processed : res;\r\ngoto out;\r\n}\r\nif (__copy_to_user(buf + num_bytes_processed, localbuf, res)) {\r\nres = num_bytes_processed ?\r\nnum_bytes_processed : -EFAULT;\r\ngoto out;\r\n}\r\nbytes_pending -= res;\r\n*offset += res;\r\nnum_bytes_processed += res;\r\nres = num_bytes_processed;\r\n}\r\nout:\r\natomic_dec(&aux_dev->usecount);\r\nwake_up_atomic_t(&aux_dev->usecount);\r\nreturn res;\r\n}\r\nstatic ssize_t auxdev_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nsize_t bytes_pending, num_bytes_processed = 0;\r\nstruct drm_dp_aux_dev *aux_dev = file->private_data;\r\nssize_t res = 0;\r\nif (!atomic_inc_not_zero(&aux_dev->usecount))\r\nreturn -ENODEV;\r\nbytes_pending = min((loff_t)count, AUX_MAX_OFFSET - *offset);\r\nif (!access_ok(VERIFY_READ, buf, bytes_pending)) {\r\nres = -EFAULT;\r\ngoto out;\r\n}\r\nwhile (bytes_pending > 0) {\r\nuint8_t localbuf[DP_AUX_MAX_PAYLOAD_BYTES];\r\nssize_t todo = min_t(size_t, bytes_pending, sizeof(localbuf));\r\nif (signal_pending(current)) {\r\nres = num_bytes_processed ?\r\nnum_bytes_processed : -ERESTARTSYS;\r\ngoto out;\r\n}\r\nif (__copy_from_user(localbuf,\r\nbuf + num_bytes_processed, todo)) {\r\nres = num_bytes_processed ?\r\nnum_bytes_processed : -EFAULT;\r\ngoto out;\r\n}\r\nres = drm_dp_dpcd_write(aux_dev->aux, *offset, localbuf, todo);\r\nif (res <= 0) {\r\nres = num_bytes_processed ? num_bytes_processed : res;\r\ngoto out;\r\n}\r\nbytes_pending -= res;\r\n*offset += res;\r\nnum_bytes_processed += res;\r\nres = num_bytes_processed;\r\n}\r\nout:\r\natomic_dec(&aux_dev->usecount);\r\nwake_up_atomic_t(&aux_dev->usecount);\r\nreturn res;\r\n}\r\nstatic int auxdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev = file->private_data;\r\nkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\r\nreturn 0;\r\n}\r\nstatic struct drm_dp_aux_dev *drm_dp_aux_dev_get_by_aux(struct drm_dp_aux *aux)\r\n{\r\nstruct drm_dp_aux_dev *iter, *aux_dev = NULL;\r\nint id;\r\nmutex_lock(&aux_idr_mutex);\r\nidr_for_each_entry(&aux_idr, iter, id) {\r\nif (iter->aux == aux) {\r\naux_dev = iter;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&aux_idr_mutex);\r\nreturn aux_dev;\r\n}\r\nstatic int auxdev_wait_atomic_t(atomic_t *p)\r\n{\r\nschedule();\r\nreturn 0;\r\n}\r\nvoid drm_dp_aux_unregister_devnode(struct drm_dp_aux *aux)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev;\r\nunsigned int minor;\r\naux_dev = drm_dp_aux_dev_get_by_aux(aux);\r\nif (!aux_dev)\r\nreturn;\r\nmutex_lock(&aux_idr_mutex);\r\nidr_remove(&aux_idr, aux_dev->index);\r\nmutex_unlock(&aux_idr_mutex);\r\natomic_dec(&aux_dev->usecount);\r\nwait_on_atomic_t(&aux_dev->usecount, auxdev_wait_atomic_t,\r\nTASK_UNINTERRUPTIBLE);\r\nminor = aux_dev->index;\r\nif (aux_dev->dev)\r\ndevice_destroy(drm_dp_aux_dev_class,\r\nMKDEV(drm_dev_major, minor));\r\nDRM_DEBUG("drm_dp_aux_dev: aux [%s] unregistering\n", aux->name);\r\nkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\r\n}\r\nint drm_dp_aux_register_devnode(struct drm_dp_aux *aux)\r\n{\r\nstruct drm_dp_aux_dev *aux_dev;\r\nint res;\r\naux_dev = alloc_drm_dp_aux_dev(aux);\r\nif (IS_ERR(aux_dev))\r\nreturn PTR_ERR(aux_dev);\r\naux_dev->dev = device_create(drm_dp_aux_dev_class, aux->dev,\r\nMKDEV(drm_dev_major, aux_dev->index), NULL,\r\n"drm_dp_aux%d", aux_dev->index);\r\nif (IS_ERR(aux_dev->dev)) {\r\nres = PTR_ERR(aux_dev->dev);\r\naux_dev->dev = NULL;\r\ngoto error;\r\n}\r\nDRM_DEBUG("drm_dp_aux_dev: aux [%s] registered as minor %d\n",\r\naux->name, aux_dev->index);\r\nreturn 0;\r\nerror:\r\ndrm_dp_aux_unregister_devnode(aux);\r\nreturn res;\r\n}\r\nint drm_dp_aux_dev_init(void)\r\n{\r\nint res;\r\ndrm_dp_aux_dev_class = class_create(THIS_MODULE, "drm_dp_aux_dev");\r\nif (IS_ERR(drm_dp_aux_dev_class)) {\r\nreturn PTR_ERR(drm_dp_aux_dev_class);\r\n}\r\ndrm_dp_aux_dev_class->dev_groups = drm_dp_aux_groups;\r\nres = register_chrdev(0, "aux", &auxdev_fops);\r\nif (res < 0)\r\ngoto out;\r\ndrm_dev_major = res;\r\nreturn 0;\r\nout:\r\nclass_destroy(drm_dp_aux_dev_class);\r\nreturn res;\r\n}\r\nvoid drm_dp_aux_dev_exit(void)\r\n{\r\nunregister_chrdev(drm_dev_major, "aux");\r\nclass_destroy(drm_dp_aux_dev_class);\r\n}
