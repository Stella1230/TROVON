struct mlx5_cqe64 *mlx5e_get_cqe(struct mlx5e_cq *cq)\r\n{\r\nstruct mlx5_cqwq *wq = &cq->wq;\r\nu32 ci = mlx5_cqwq_get_ci(wq);\r\nstruct mlx5_cqe64 *cqe = mlx5_cqwq_get_wqe(wq, ci);\r\nint cqe_ownership_bit = cqe->op_own & MLX5_CQE_OWNER_MASK;\r\nint sw_ownership_val = mlx5_cqwq_get_wrap_cnt(wq) & 1;\r\nif (cqe_ownership_bit != sw_ownership_val)\r\nreturn NULL;\r\nrmb();\r\nreturn cqe;\r\n}\r\nstatic void mlx5e_poll_ico_cq(struct mlx5e_cq *cq)\r\n{\r\nstruct mlx5e_sq *sq = container_of(cq, struct mlx5e_sq, cq);\r\nstruct mlx5_wq_cyc *wq;\r\nstruct mlx5_cqe64 *cqe;\r\nu16 sqcc;\r\nif (unlikely(!test_bit(MLX5E_SQ_STATE_ENABLED, &sq->state)))\r\nreturn;\r\ncqe = mlx5e_get_cqe(cq);\r\nif (likely(!cqe))\r\nreturn;\r\nwq = &sq->wq;\r\nsqcc = sq->cc;\r\ndo {\r\nu16 ci = be16_to_cpu(cqe->wqe_counter) & wq->sz_m1;\r\nstruct mlx5e_sq_wqe_info *icowi = &sq->db.ico_wqe[ci];\r\nmlx5_cqwq_pop(&cq->wq);\r\nsqcc += icowi->num_wqebbs;\r\nif (unlikely((cqe->op_own >> 4) != MLX5_CQE_REQ)) {\r\nWARN_ONCE(true, "mlx5e: Bad OP in ICOSQ CQE: 0x%x\n",\r\ncqe->op_own);\r\nbreak;\r\n}\r\nswitch (icowi->opcode) {\r\ncase MLX5_OPCODE_NOP:\r\nbreak;\r\ncase MLX5_OPCODE_UMR:\r\nmlx5e_post_rx_mpwqe(&sq->channel->rq);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(true,\r\n"mlx5e: Bad OPCODE in ICOSQ WQE info: 0x%x\n",\r\nicowi->opcode);\r\n}\r\n} while ((cqe = mlx5e_get_cqe(cq)));\r\nmlx5_cqwq_update_db_record(&cq->wq);\r\nwmb();\r\nsq->cc = sqcc;\r\n}\r\nstatic inline bool mlx5e_poll_xdp_tx_cq(struct mlx5e_cq *cq)\r\n{\r\nstruct mlx5e_sq *sq;\r\nu16 sqcc;\r\nint i;\r\nsq = container_of(cq, struct mlx5e_sq, cq);\r\nif (unlikely(!test_bit(MLX5E_SQ_STATE_ENABLED, &sq->state)))\r\nreturn false;\r\nsqcc = sq->cc;\r\nfor (i = 0; i < MLX5E_TX_CQ_POLL_BUDGET; i++) {\r\nstruct mlx5_cqe64 *cqe;\r\nu16 wqe_counter;\r\nbool last_wqe;\r\ncqe = mlx5e_get_cqe(cq);\r\nif (!cqe)\r\nbreak;\r\nmlx5_cqwq_pop(&cq->wq);\r\nwqe_counter = be16_to_cpu(cqe->wqe_counter);\r\ndo {\r\nstruct mlx5e_sq_wqe_info *wi;\r\nstruct mlx5e_dma_info *di;\r\nu16 ci;\r\nlast_wqe = (sqcc == wqe_counter);\r\nci = sqcc & sq->wq.sz_m1;\r\ndi = &sq->db.xdp.di[ci];\r\nwi = &sq->db.xdp.wqe_info[ci];\r\nif (unlikely(wi->opcode == MLX5_OPCODE_NOP)) {\r\nsqcc++;\r\ncontinue;\r\n}\r\nsqcc += wi->num_wqebbs;\r\nmlx5e_page_release(&sq->channel->rq, di, true);\r\n} while (!last_wqe);\r\n}\r\nmlx5_cqwq_update_db_record(&cq->wq);\r\nwmb();\r\nsq->cc = sqcc;\r\nreturn (i == MLX5E_TX_CQ_POLL_BUDGET);\r\n}\r\nint mlx5e_napi_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct mlx5e_channel *c = container_of(napi, struct mlx5e_channel,\r\nnapi);\r\nbool busy = false;\r\nint work_done;\r\nint i;\r\nclear_bit(MLX5E_CHANNEL_NAPI_SCHED, &c->flags);\r\nfor (i = 0; i < c->num_tc; i++)\r\nbusy |= mlx5e_poll_tx_cq(&c->sq[i].cq, budget);\r\nwork_done = mlx5e_poll_rx_cq(&c->rq.cq, budget);\r\nbusy |= work_done == budget;\r\nif (c->xdp)\r\nbusy |= mlx5e_poll_xdp_tx_cq(&c->xdp_sq.cq);\r\nmlx5e_poll_ico_cq(&c->icosq.cq);\r\nbusy |= mlx5e_post_rx_wqes(&c->rq);\r\nif (busy)\r\nreturn budget;\r\nnapi_complete_done(napi, work_done);\r\nif (test_bit(MLX5E_CHANNEL_NAPI_SCHED, &c->flags)) {\r\nnapi_schedule(napi);\r\nreturn work_done;\r\n}\r\nfor (i = 0; i < c->num_tc; i++)\r\nmlx5e_cq_arm(&c->sq[i].cq);\r\nif (test_bit(MLX5E_RQ_STATE_AM, &c->rq.state))\r\nmlx5e_rx_am(&c->rq);\r\nmlx5e_cq_arm(&c->rq.cq);\r\nmlx5e_cq_arm(&c->icosq.cq);\r\nreturn work_done;\r\n}\r\nvoid mlx5e_completion_event(struct mlx5_core_cq *mcq)\r\n{\r\nstruct mlx5e_cq *cq = container_of(mcq, struct mlx5e_cq, mcq);\r\ncq->event_ctr++;\r\nset_bit(MLX5E_CHANNEL_NAPI_SCHED, &cq->channel->flags);\r\nnapi_schedule(cq->napi);\r\n}\r\nvoid mlx5e_cq_error_event(struct mlx5_core_cq *mcq, enum mlx5_event event)\r\n{\r\nstruct mlx5e_cq *cq = container_of(mcq, struct mlx5e_cq, mcq);\r\nstruct mlx5e_channel *c = cq->channel;\r\nstruct mlx5e_priv *priv = c->priv;\r\nstruct net_device *netdev = priv->netdev;\r\nnetdev_err(netdev, "%s: cqn=0x%.6x event=0x%.2x\n",\r\n__func__, mcq->cqn, event);\r\n}
