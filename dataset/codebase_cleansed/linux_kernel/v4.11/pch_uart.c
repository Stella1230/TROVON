static ssize_t port_show_regs(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct eg20t_port *priv = file->private_data;\r\nchar *buf;\r\nu32 len = 0;\r\nssize_t ret;\r\nunsigned char lcr;\r\nbuf = kzalloc(PCH_REGS_BUFSIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn 0;\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"PCH EG20T port[%d] regs:\n", priv->port.line);\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"=================================\n");\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"IER: \t0x%02x\n", ioread8(priv->membase + UART_IER));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"IIR: \t0x%02x\n", ioread8(priv->membase + UART_IIR));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"LCR: \t0x%02x\n", ioread8(priv->membase + UART_LCR));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"MCR: \t0x%02x\n", ioread8(priv->membase + UART_MCR));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"LSR: \t0x%02x\n", ioread8(priv->membase + UART_LSR));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"MSR: \t0x%02x\n", ioread8(priv->membase + UART_MSR));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"BRCSR: \t0x%02x\n",\r\nioread8(priv->membase + PCH_UART_BRCSR));\r\nlcr = ioread8(priv->membase + UART_LCR);\r\niowrite8(PCH_UART_LCR_DLAB, priv->membase + UART_LCR);\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"DLL: \t0x%02x\n", ioread8(priv->membase + UART_DLL));\r\nlen += snprintf(buf + len, PCH_REGS_BUFSIZE - len,\r\n"DLM: \t0x%02x\n", ioread8(priv->membase + UART_DLM));\r\niowrite8(lcr, priv->membase + UART_LCR);\r\nif (len > PCH_REGS_BUFSIZE)\r\nlen = PCH_REGS_BUFSIZE;\r\nret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic unsigned int pch_uart_get_uartclk(void)\r\n{\r\nconst struct dmi_system_id *d;\r\nif (user_uartclk)\r\nreturn user_uartclk;\r\nd = dmi_first_match(pch_uart_dmi_table);\r\nif (d)\r\nreturn (unsigned long)d->driver_data;\r\nreturn DEFAULT_UARTCLK;\r\n}\r\nstatic void pch_uart_hal_enable_interrupt(struct eg20t_port *priv,\r\nunsigned int flag)\r\n{\r\nu8 ier = ioread8(priv->membase + UART_IER);\r\nier |= flag & PCH_UART_IER_MASK;\r\niowrite8(ier, priv->membase + UART_IER);\r\n}\r\nstatic void pch_uart_hal_disable_interrupt(struct eg20t_port *priv,\r\nunsigned int flag)\r\n{\r\nu8 ier = ioread8(priv->membase + UART_IER);\r\nier &= ~(flag & PCH_UART_IER_MASK);\r\niowrite8(ier, priv->membase + UART_IER);\r\n}\r\nstatic int pch_uart_hal_set_line(struct eg20t_port *priv, unsigned int baud,\r\nunsigned int parity, unsigned int bits,\r\nunsigned int stb)\r\n{\r\nunsigned int dll, dlm, lcr;\r\nint div;\r\ndiv = DIV_ROUND_CLOSEST(priv->uartclk / 16, baud);\r\nif (div < 0 || USHRT_MAX <= div) {\r\ndev_err(priv->port.dev, "Invalid Baud(div=0x%x)\n", div);\r\nreturn -EINVAL;\r\n}\r\ndll = (unsigned int)div & 0x00FFU;\r\ndlm = ((unsigned int)div >> 8) & 0x00FFU;\r\nif (parity & ~(PCH_UART_LCR_PEN | PCH_UART_LCR_EPS | PCH_UART_LCR_SP)) {\r\ndev_err(priv->port.dev, "Invalid parity(0x%x)\n", parity);\r\nreturn -EINVAL;\r\n}\r\nif (bits & ~PCH_UART_LCR_WLS) {\r\ndev_err(priv->port.dev, "Invalid bits(0x%x)\n", bits);\r\nreturn -EINVAL;\r\n}\r\nif (stb & ~PCH_UART_LCR_STB) {\r\ndev_err(priv->port.dev, "Invalid STB(0x%x)\n", stb);\r\nreturn -EINVAL;\r\n}\r\nlcr = parity;\r\nlcr |= bits;\r\nlcr |= stb;\r\ndev_dbg(priv->port.dev, "%s:baud = %u, div = %04x, lcr = %02x (%lu)\n",\r\n__func__, baud, div, lcr, jiffies);\r\niowrite8(PCH_UART_LCR_DLAB, priv->membase + UART_LCR);\r\niowrite8(dll, priv->membase + PCH_UART_DLL);\r\niowrite8(dlm, priv->membase + PCH_UART_DLM);\r\niowrite8(lcr, priv->membase + UART_LCR);\r\nreturn 0;\r\n}\r\nstatic int pch_uart_hal_fifo_reset(struct eg20t_port *priv,\r\nunsigned int flag)\r\n{\r\nif (flag & ~(PCH_UART_FCR_TFR | PCH_UART_FCR_RFR)) {\r\ndev_err(priv->port.dev, "%s:Invalid flag(0x%x)\n",\r\n__func__, flag);\r\nreturn -EINVAL;\r\n}\r\niowrite8(PCH_UART_FCR_FIFOE | priv->fcr, priv->membase + UART_FCR);\r\niowrite8(PCH_UART_FCR_FIFOE | priv->fcr | flag,\r\npriv->membase + UART_FCR);\r\niowrite8(priv->fcr, priv->membase + UART_FCR);\r\nreturn 0;\r\n}\r\nstatic int pch_uart_hal_set_fifo(struct eg20t_port *priv,\r\nunsigned int dmamode,\r\nunsigned int fifo_size, unsigned int trigger)\r\n{\r\nu8 fcr;\r\nif (dmamode & ~PCH_UART_FCR_DMS) {\r\ndev_err(priv->port.dev, "%s:Invalid DMA Mode(0x%x)\n",\r\n__func__, dmamode);\r\nreturn -EINVAL;\r\n}\r\nif (fifo_size & ~(PCH_UART_FCR_FIFOE | PCH_UART_FCR_FIFO256)) {\r\ndev_err(priv->port.dev, "%s:Invalid FIFO SIZE(0x%x)\n",\r\n__func__, fifo_size);\r\nreturn -EINVAL;\r\n}\r\nif (trigger & ~PCH_UART_FCR_RFTL) {\r\ndev_err(priv->port.dev, "%s:Invalid TRIGGER(0x%x)\n",\r\n__func__, trigger);\r\nreturn -EINVAL;\r\n}\r\nswitch (priv->fifo_size) {\r\ncase 256:\r\npriv->trigger_level =\r\ntrigger_level_256[trigger >> PCH_UART_FCR_RFTL_SHIFT];\r\nbreak;\r\ncase 64:\r\npriv->trigger_level =\r\ntrigger_level_64[trigger >> PCH_UART_FCR_RFTL_SHIFT];\r\nbreak;\r\ncase 16:\r\npriv->trigger_level =\r\ntrigger_level_16[trigger >> PCH_UART_FCR_RFTL_SHIFT];\r\nbreak;\r\ndefault:\r\npriv->trigger_level =\r\ntrigger_level_1[trigger >> PCH_UART_FCR_RFTL_SHIFT];\r\nbreak;\r\n}\r\nfcr =\r\ndmamode | fifo_size | trigger | PCH_UART_FCR_RFR | PCH_UART_FCR_TFR;\r\niowrite8(PCH_UART_FCR_FIFOE, priv->membase + UART_FCR);\r\niowrite8(PCH_UART_FCR_FIFOE | PCH_UART_FCR_RFR | PCH_UART_FCR_TFR,\r\npriv->membase + UART_FCR);\r\niowrite8(fcr, priv->membase + UART_FCR);\r\npriv->fcr = fcr;\r\nreturn 0;\r\n}\r\nstatic u8 pch_uart_hal_get_modem(struct eg20t_port *priv)\r\n{\r\nunsigned int msr = ioread8(priv->membase + UART_MSR);\r\npriv->dmsr = msr & PCH_UART_MSR_DELTA;\r\nreturn (u8)msr;\r\n}\r\nstatic void pch_uart_hal_write(struct eg20t_port *priv,\r\nconst unsigned char *buf, int tx_size)\r\n{\r\nint i;\r\nunsigned int thr;\r\nfor (i = 0; i < tx_size;) {\r\nthr = buf[i++];\r\niowrite8(thr, priv->membase + PCH_UART_THR);\r\n}\r\n}\r\nstatic int pch_uart_hal_read(struct eg20t_port *priv, unsigned char *buf,\r\nint rx_size)\r\n{\r\nint i;\r\nu8 rbr, lsr;\r\nstruct uart_port *port = &priv->port;\r\nlsr = ioread8(priv->membase + UART_LSR);\r\nfor (i = 0, lsr = ioread8(priv->membase + UART_LSR);\r\ni < rx_size && lsr & (UART_LSR_DR | UART_LSR_BI);\r\nlsr = ioread8(priv->membase + UART_LSR)) {\r\nrbr = ioread8(priv->membase + PCH_UART_RBR);\r\nif (lsr & UART_LSR_BI) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\n#ifdef SUPPORT_SYSRQ\r\nif (port->sysrq) {\r\nif (uart_handle_sysrq_char(port, rbr))\r\ncontinue;\r\n}\r\n#endif\r\nbuf[i++] = rbr;\r\n}\r\nreturn i;\r\n}\r\nstatic unsigned char pch_uart_hal_get_iid(struct eg20t_port *priv)\r\n{\r\nreturn ioread8(priv->membase + UART_IIR) &\\r\n(PCH_UART_IIR_IID | PCH_UART_IIR_TOI | PCH_UART_IIR_IP);\r\n}\r\nstatic u8 pch_uart_hal_get_line_status(struct eg20t_port *priv)\r\n{\r\nreturn ioread8(priv->membase + UART_LSR);\r\n}\r\nstatic void pch_uart_hal_set_break(struct eg20t_port *priv, int on)\r\n{\r\nunsigned int lcr;\r\nlcr = ioread8(priv->membase + UART_LCR);\r\nif (on)\r\nlcr |= PCH_UART_LCR_SB;\r\nelse\r\nlcr &= ~PCH_UART_LCR_SB;\r\niowrite8(lcr, priv->membase + UART_LCR);\r\n}\r\nstatic int push_rx(struct eg20t_port *priv, const unsigned char *buf,\r\nint size)\r\n{\r\nstruct uart_port *port = &priv->port;\r\nstruct tty_port *tport = &port->state->port;\r\ntty_insert_flip_string(tport, buf, size);\r\ntty_flip_buffer_push(tport);\r\nreturn 0;\r\n}\r\nstatic int pop_tx_x(struct eg20t_port *priv, unsigned char *buf)\r\n{\r\nint ret = 0;\r\nstruct uart_port *port = &priv->port;\r\nif (port->x_char) {\r\ndev_dbg(priv->port.dev, "%s:X character send %02x (%lu)\n",\r\n__func__, port->x_char, jiffies);\r\nbuf[0] = port->x_char;\r\nport->x_char = 0;\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dma_push_rx(struct eg20t_port *priv, int size)\r\n{\r\nint room;\r\nstruct uart_port *port = &priv->port;\r\nstruct tty_port *tport = &port->state->port;\r\nroom = tty_buffer_request_room(tport, size);\r\nif (room < size)\r\ndev_warn(port->dev, "Rx overrun: dropping %u bytes\n",\r\nsize - room);\r\nif (!room)\r\nreturn 0;\r\ntty_insert_flip_string(tport, sg_virt(&priv->sg_rx), size);\r\nport->icount.rx += room;\r\nreturn room;\r\n}\r\nstatic void pch_free_dma(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\nif (priv->chan_tx) {\r\ndma_release_channel(priv->chan_tx);\r\npriv->chan_tx = NULL;\r\n}\r\nif (priv->chan_rx) {\r\ndma_release_channel(priv->chan_rx);\r\npriv->chan_rx = NULL;\r\n}\r\nif (priv->rx_buf_dma) {\r\ndma_free_coherent(port->dev, port->fifosize, priv->rx_buf_virt,\r\npriv->rx_buf_dma);\r\npriv->rx_buf_virt = NULL;\r\npriv->rx_buf_dma = 0;\r\n}\r\nreturn;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct pch_dma_slave *param = slave;\r\nif ((chan->chan_id == param->chan_id) && (param->dma_dev ==\r\nchan->device->dev)) {\r\nchan->private = param;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic void pch_request_dma(struct uart_port *port)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct dma_chan *chan;\r\nstruct pci_dev *dma_dev;\r\nstruct pch_dma_slave *param;\r\nstruct eg20t_port *priv =\r\ncontainer_of(port, struct eg20t_port, port);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_dev = pci_get_slot(priv->pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(priv->pdev->devfn), 0));\r\nparam = &priv->param_tx;\r\nparam->dma_dev = &dma_dev->dev;\r\nparam->chan_id = priv->port.line * 2;\r\nparam->tx_reg = port->mapbase + UART_TX;\r\nchan = dma_request_channel(mask, filter, param);\r\nif (!chan) {\r\ndev_err(priv->port.dev, "%s:dma_request_channel FAILS(Tx)\n",\r\n__func__);\r\nreturn;\r\n}\r\npriv->chan_tx = chan;\r\nparam = &priv->param_rx;\r\nparam->dma_dev = &dma_dev->dev;\r\nparam->chan_id = priv->port.line * 2 + 1;\r\nparam->rx_reg = port->mapbase + UART_RX;\r\nchan = dma_request_channel(mask, filter, param);\r\nif (!chan) {\r\ndev_err(priv->port.dev, "%s:dma_request_channel FAILS(Rx)\n",\r\n__func__);\r\ndma_release_channel(priv->chan_tx);\r\npriv->chan_tx = NULL;\r\nreturn;\r\n}\r\npriv->rx_buf_virt = dma_alloc_coherent(port->dev, port->fifosize,\r\n&priv->rx_buf_dma, GFP_KERNEL);\r\npriv->chan_rx = chan;\r\n}\r\nstatic void pch_dma_rx_complete(void *arg)\r\n{\r\nstruct eg20t_port *priv = arg;\r\nstruct uart_port *port = &priv->port;\r\nint count;\r\ndma_sync_sg_for_cpu(port->dev, &priv->sg_rx, 1, DMA_FROM_DEVICE);\r\ncount = dma_push_rx(priv, priv->trigger_level);\r\nif (count)\r\ntty_flip_buffer_push(&port->state->port);\r\nasync_tx_ack(priv->desc_rx);\r\npch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\n}\r\nstatic void pch_dma_tx_complete(void *arg)\r\n{\r\nstruct eg20t_port *priv = arg;\r\nstruct uart_port *port = &priv->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct scatterlist *sg = priv->sg_tx_p;\r\nint i;\r\nfor (i = 0; i < priv->nent; i++, sg++) {\r\nxmit->tail += sg_dma_len(sg);\r\nport->icount.tx += sg_dma_len(sg);\r\n}\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nasync_tx_ack(priv->desc_tx);\r\ndma_unmap_sg(port->dev, sg, priv->nent, DMA_TO_DEVICE);\r\npriv->tx_dma_use = 0;\r\npriv->nent = 0;\r\nkfree(priv->sg_tx_p);\r\npch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\n}\r\nstatic int pop_tx(struct eg20t_port *priv, int size)\r\n{\r\nint count = 0;\r\nstruct uart_port *port = &priv->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_tx_stopped(port) || uart_circ_empty(xmit) || count >= size)\r\ngoto pop_tx_end;\r\ndo {\r\nint cnt_to_end =\r\nCIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\nint sz = min(size - count, cnt_to_end);\r\npch_uart_hal_write(priv, &xmit->buf[xmit->tail], sz);\r\nxmit->tail = (xmit->tail + sz) & (UART_XMIT_SIZE - 1);\r\ncount += sz;\r\n} while (!uart_circ_empty(xmit) && count < size);\r\npop_tx_end:\r\ndev_dbg(priv->port.dev, "%d characters. Remained %d characters.(%lu)\n",\r\ncount, size - count, jiffies);\r\nreturn count;\r\n}\r\nstatic int handle_rx_to(struct eg20t_port *priv)\r\n{\r\nstruct pch_uart_buffer *buf;\r\nint rx_size;\r\nint ret;\r\nif (!priv->start_rx) {\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\nreturn 0;\r\n}\r\nbuf = &priv->rxbuf;\r\ndo {\r\nrx_size = pch_uart_hal_read(priv, buf->buf, buf->size);\r\nret = push_rx(priv, buf->buf, rx_size);\r\nif (ret)\r\nreturn 0;\r\n} while (rx_size == buf->size);\r\nreturn PCH_UART_HANDLED_RX_INT;\r\n}\r\nstatic int handle_rx(struct eg20t_port *priv)\r\n{\r\nreturn handle_rx_to(priv);\r\n}\r\nstatic int dma_handle_rx(struct eg20t_port *priv)\r\n{\r\nstruct uart_port *port = &priv->port;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist *sg;\r\npriv = container_of(port, struct eg20t_port, port);\r\nsg = &priv->sg_rx;\r\nsg_init_table(&priv->sg_rx, 1);\r\nsg_dma_len(sg) = priv->trigger_level;\r\nsg_set_page(&priv->sg_rx, virt_to_page(priv->rx_buf_virt),\r\nsg_dma_len(sg), (unsigned long)priv->rx_buf_virt &\r\n~PAGE_MASK);\r\nsg_dma_address(sg) = priv->rx_buf_dma;\r\ndesc = dmaengine_prep_slave_sg(priv->chan_rx,\r\nsg, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc)\r\nreturn 0;\r\npriv->desc_rx = desc;\r\ndesc->callback = pch_dma_rx_complete;\r\ndesc->callback_param = priv;\r\ndesc->tx_submit(desc);\r\ndma_async_issue_pending(priv->chan_rx);\r\nreturn PCH_UART_HANDLED_RX_INT;\r\n}\r\nstatic unsigned int handle_tx(struct eg20t_port *priv)\r\n{\r\nstruct uart_port *port = &priv->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint fifo_size;\r\nint tx_size;\r\nint size;\r\nint tx_empty;\r\nif (!priv->start_tx) {\r\ndev_info(priv->port.dev, "%s:Tx isn't started. (%lu)\n",\r\n__func__, jiffies);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\npriv->tx_empty = 1;\r\nreturn 0;\r\n}\r\nfifo_size = max(priv->fifo_size, 1);\r\ntx_empty = 1;\r\nif (pop_tx_x(priv, xmit->buf)) {\r\npch_uart_hal_write(priv, xmit->buf, 1);\r\nport->icount.tx++;\r\ntx_empty = 0;\r\nfifo_size--;\r\n}\r\nsize = min(xmit->head - xmit->tail, fifo_size);\r\nif (size < 0)\r\nsize = fifo_size;\r\ntx_size = pop_tx(priv, size);\r\nif (tx_size > 0) {\r\nport->icount.tx += tx_size;\r\ntx_empty = 0;\r\n}\r\npriv->tx_empty = tx_empty;\r\nif (tx_empty) {\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\nuart_write_wakeup(port);\r\n}\r\nreturn PCH_UART_HANDLED_TX_INT;\r\n}\r\nstatic unsigned int dma_handle_tx(struct eg20t_port *priv)\r\n{\r\nstruct uart_port *port = &priv->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct scatterlist *sg;\r\nint nent;\r\nint fifo_size;\r\nint tx_empty;\r\nstruct dma_async_tx_descriptor *desc;\r\nint num;\r\nint i;\r\nint bytes;\r\nint size;\r\nint rem;\r\nif (!priv->start_tx) {\r\ndev_info(priv->port.dev, "%s:Tx isn't started. (%lu)\n",\r\n__func__, jiffies);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\npriv->tx_empty = 1;\r\nreturn 0;\r\n}\r\nif (priv->tx_dma_use) {\r\ndev_dbg(priv->port.dev, "%s:Tx is not completed. (%lu)\n",\r\n__func__, jiffies);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\npriv->tx_empty = 1;\r\nreturn 0;\r\n}\r\nfifo_size = max(priv->fifo_size, 1);\r\ntx_empty = 1;\r\nif (pop_tx_x(priv, xmit->buf)) {\r\npch_uart_hal_write(priv, xmit->buf, 1);\r\nport->icount.tx++;\r\ntx_empty = 0;\r\nfifo_size--;\r\n}\r\nbytes = min((int)CIRC_CNT(xmit->head, xmit->tail,\r\nUART_XMIT_SIZE), CIRC_CNT_TO_END(xmit->head,\r\nxmit->tail, UART_XMIT_SIZE));\r\nif (!bytes) {\r\ndev_dbg(priv->port.dev, "%s 0 bytes return\n", __func__);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\nuart_write_wakeup(port);\r\nreturn 0;\r\n}\r\nif (bytes > fifo_size) {\r\nnum = bytes / fifo_size + 1;\r\nsize = fifo_size;\r\nrem = bytes % fifo_size;\r\n} else {\r\nnum = 1;\r\nsize = bytes;\r\nrem = bytes;\r\n}\r\ndev_dbg(priv->port.dev, "%s num=%d size=%d rem=%d\n",\r\n__func__, num, size, rem);\r\npriv->tx_dma_use = 1;\r\npriv->sg_tx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);\r\nif (!priv->sg_tx_p) {\r\ndev_err(priv->port.dev, "%s:kzalloc Failed\n", __func__);\r\nreturn 0;\r\n}\r\nsg_init_table(priv->sg_tx_p, num);\r\nsg = priv->sg_tx_p;\r\nfor (i = 0; i < num; i++, sg++) {\r\nif (i == (num - 1))\r\nsg_set_page(sg, virt_to_page(xmit->buf),\r\nrem, fifo_size * i);\r\nelse\r\nsg_set_page(sg, virt_to_page(xmit->buf),\r\nsize, fifo_size * i);\r\n}\r\nsg = priv->sg_tx_p;\r\nnent = dma_map_sg(port->dev, sg, num, DMA_TO_DEVICE);\r\nif (!nent) {\r\ndev_err(priv->port.dev, "%s:dma_map_sg Failed\n", __func__);\r\nreturn 0;\r\n}\r\npriv->nent = nent;\r\nfor (i = 0; i < nent; i++, sg++) {\r\nsg->offset = (xmit->tail & (UART_XMIT_SIZE - 1)) +\r\nfifo_size * i;\r\nsg_dma_address(sg) = (sg_dma_address(sg) &\r\n~(UART_XMIT_SIZE - 1)) + sg->offset;\r\nif (i == (nent - 1))\r\nsg_dma_len(sg) = rem;\r\nelse\r\nsg_dma_len(sg) = size;\r\n}\r\ndesc = dmaengine_prep_slave_sg(priv->chan_tx,\r\npriv->sg_tx_p, nent, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(priv->port.dev, "%s:dmaengine_prep_slave_sg Failed\n",\r\n__func__);\r\nreturn 0;\r\n}\r\ndma_sync_sg_for_device(port->dev, priv->sg_tx_p, nent, DMA_TO_DEVICE);\r\npriv->desc_tx = desc;\r\ndesc->callback = pch_dma_tx_complete;\r\ndesc->callback_param = priv;\r\ndesc->tx_submit(desc);\r\ndma_async_issue_pending(priv->chan_tx);\r\nreturn PCH_UART_HANDLED_TX_INT;\r\n}\r\nstatic void pch_uart_err_ir(struct eg20t_port *priv, unsigned int lsr)\r\n{\r\nstruct uart_port *port = &priv->port;\r\nstruct tty_struct *tty = tty_port_tty_get(&port->state->port);\r\nchar *error_msg[5] = {};\r\nint i = 0;\r\nif (lsr & PCH_UART_LSR_ERR)\r\nerror_msg[i++] = "Error data in FIFO\n";\r\nif (lsr & UART_LSR_FE) {\r\nport->icount.frame++;\r\nerror_msg[i++] = " Framing Error\n";\r\n}\r\nif (lsr & UART_LSR_PE) {\r\nport->icount.parity++;\r\nerror_msg[i++] = " Parity Error\n";\r\n}\r\nif (lsr & UART_LSR_OE) {\r\nport->icount.overrun++;\r\nerror_msg[i++] = " Overrun Error\n";\r\n}\r\nif (tty == NULL) {\r\nfor (i = 0; error_msg[i] != NULL; i++)\r\ndev_err(&priv->pdev->dev, error_msg[i]);\r\n} else {\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic irqreturn_t pch_uart_interrupt(int irq, void *dev_id)\r\n{\r\nstruct eg20t_port *priv = dev_id;\r\nunsigned int handled;\r\nu8 lsr;\r\nint ret = 0;\r\nunsigned char iid;\r\nunsigned long flags;\r\nint next = 1;\r\nu8 msr;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nhandled = 0;\r\nwhile (next) {\r\niid = pch_uart_hal_get_iid(priv);\r\nif (iid & PCH_UART_IIR_IP)\r\nbreak;\r\nswitch (iid) {\r\ncase PCH_UART_IID_RLS:\r\nlsr = pch_uart_hal_get_line_status(priv);\r\nif (lsr & (PCH_UART_LSR_ERR | UART_LSR_FE |\r\nUART_LSR_PE | UART_LSR_OE)) {\r\npch_uart_err_ir(priv, lsr);\r\nret = PCH_UART_HANDLED_RX_ERR_INT;\r\n} else {\r\nret = PCH_UART_HANDLED_LS_INT;\r\n}\r\nbreak;\r\ncase PCH_UART_IID_RDR:\r\nif (priv->use_dma) {\r\npch_uart_hal_disable_interrupt(priv,\r\nPCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\nret = dma_handle_rx(priv);\r\nif (!ret)\r\npch_uart_hal_enable_interrupt(priv,\r\nPCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\n} else {\r\nret = handle_rx(priv);\r\n}\r\nbreak;\r\ncase PCH_UART_IID_RDR_TO:\r\nret = handle_rx_to(priv);\r\nbreak;\r\ncase PCH_UART_IID_THRE:\r\nif (priv->use_dma)\r\nret = dma_handle_tx(priv);\r\nelse\r\nret = handle_tx(priv);\r\nbreak;\r\ncase PCH_UART_IID_MS:\r\nmsr = pch_uart_hal_get_modem(priv);\r\nnext = 0;\r\nif ((msr & UART_MSR_ANY_DELTA) == 0)\r\nbreak;\r\nret |= PCH_UART_HANDLED_MS_INT;\r\nbreak;\r\ndefault:\r\ndev_err(priv->port.dev, "%s:iid=%02x (%lu)\n", __func__,\r\niid, jiffies);\r\nret = -1;\r\nnext = 0;\r\nbreak;\r\n}\r\nhandled |= (unsigned int)ret;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned int pch_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\nif (priv->tx_empty)\r\nreturn TIOCSER_TEMT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned int pch_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\nu8 modem;\r\nunsigned int ret = 0;\r\npriv = container_of(port, struct eg20t_port, port);\r\nmodem = pch_uart_hal_get_modem(priv);\r\nif (modem & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (modem & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (modem & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (modem & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void pch_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nu32 mcr = 0;\r\nstruct eg20t_port *priv = container_of(port, struct eg20t_port, port);\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nif (priv->mcr & UART_MCR_AFE)\r\nmcr |= UART_MCR_AFE;\r\nif (mctrl)\r\niowrite8(mcr, priv->membase + UART_MCR);\r\n}\r\nstatic void pch_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\npriv->start_tx = 0;\r\npriv->tx_dma_use = 0;\r\n}\r\nstatic void pch_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\nif (priv->use_dma) {\r\nif (priv->tx_dma_use) {\r\ndev_dbg(priv->port.dev, "%s : Tx DMA is NOT empty.\n",\r\n__func__);\r\nreturn;\r\n}\r\n}\r\npriv->start_tx = 1;\r\npch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_TX_INT);\r\n}\r\nstatic void pch_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\npriv->start_rx = 0;\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\n}\r\nstatic void pch_uart_enable_ms(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\npch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_MS_INT);\r\n}\r\nstatic void pch_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\nstruct eg20t_port *priv;\r\nunsigned long flags;\r\npriv = container_of(port, struct eg20t_port, port);\r\nspin_lock_irqsave(&priv->lock, flags);\r\npch_uart_hal_set_break(priv, ctl);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int pch_uart_startup(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\nint ret;\r\nint fifo_size;\r\nint trigger_level;\r\npriv = container_of(port, struct eg20t_port, port);\r\npriv->tx_empty = 1;\r\nif (port->uartclk)\r\npriv->uartclk = port->uartclk;\r\nelse\r\nport->uartclk = priv->uartclk;\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\r\nret = pch_uart_hal_set_line(priv, default_baud,\r\nPCH_UART_HAL_PARITY_NONE, PCH_UART_HAL_8BIT,\r\nPCH_UART_HAL_STB1);\r\nif (ret)\r\nreturn ret;\r\nswitch (priv->fifo_size) {\r\ncase 256:\r\nfifo_size = PCH_UART_HAL_FIFO256;\r\nbreak;\r\ncase 64:\r\nfifo_size = PCH_UART_HAL_FIFO64;\r\nbreak;\r\ncase 16:\r\nfifo_size = PCH_UART_HAL_FIFO16;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nfifo_size = PCH_UART_HAL_FIFO_DIS;\r\nbreak;\r\n}\r\nswitch (priv->trigger) {\r\ncase PCH_UART_HAL_TRIGGER1:\r\ntrigger_level = 1;\r\nbreak;\r\ncase PCH_UART_HAL_TRIGGER_L:\r\ntrigger_level = priv->fifo_size / 4;\r\nbreak;\r\ncase PCH_UART_HAL_TRIGGER_M:\r\ntrigger_level = priv->fifo_size / 2;\r\nbreak;\r\ncase PCH_UART_HAL_TRIGGER_H:\r\ndefault:\r\ntrigger_level = priv->fifo_size - (priv->fifo_size / 8);\r\nbreak;\r\n}\r\npriv->trigger_level = trigger_level;\r\nret = pch_uart_hal_set_fifo(priv, PCH_UART_HAL_DMA_MODE0,\r\nfifo_size, priv->trigger);\r\nif (ret < 0)\r\nreturn ret;\r\nret = request_irq(priv->port.irq, pch_uart_interrupt, IRQF_SHARED,\r\npriv->irq_name, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nif (priv->use_dma)\r\npch_request_dma(port);\r\npriv->start_rx = 1;\r\npch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |\r\nPCH_UART_HAL_RX_ERR_INT);\r\nuart_update_timeout(port, CS8, default_baud);\r\nreturn 0;\r\n}\r\nstatic void pch_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\nint ret;\r\npriv = container_of(port, struct eg20t_port, port);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\r\npch_uart_hal_fifo_reset(priv, PCH_UART_HAL_CLR_ALL_FIFO);\r\nret = pch_uart_hal_set_fifo(priv, PCH_UART_HAL_DMA_MODE0,\r\nPCH_UART_HAL_FIFO_DIS, PCH_UART_HAL_TRIGGER1);\r\nif (ret)\r\ndev_err(priv->port.dev,\r\n"pch_uart_hal_set_fifo Failed(ret=%d)\n", ret);\r\npch_free_dma(port);\r\nfree_irq(priv->port.irq, priv);\r\n}\r\nstatic void pch_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nint rtn;\r\nunsigned int baud, parity, bits, stb;\r\nstruct eg20t_port *priv;\r\nunsigned long flags;\r\npriv = container_of(port, struct eg20t_port, port);\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nbits = PCH_UART_HAL_5BIT;\r\nbreak;\r\ncase CS6:\r\nbits = PCH_UART_HAL_6BIT;\r\nbreak;\r\ncase CS7:\r\nbits = PCH_UART_HAL_7BIT;\r\nbreak;\r\ndefault:\r\nbits = PCH_UART_HAL_8BIT;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nstb = PCH_UART_HAL_STB2;\r\nelse\r\nstb = PCH_UART_HAL_STB1;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & PARODD)\r\nparity = PCH_UART_HAL_PARITY_ODD;\r\nelse\r\nparity = PCH_UART_HAL_PARITY_EVEN;\r\n} else\r\nparity = PCH_UART_HAL_PARITY_NONE;\r\nif ((termios->c_cflag & CRTSCTS) && (priv->fifo_size == 256))\r\npriv->mcr |= UART_MCR_AFE;\r\nelse\r\npriv->mcr &= ~UART_MCR_AFE;\r\ntermios->c_cflag &= ~CMSPAR;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nspin_lock(&port->lock);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nrtn = pch_uart_hal_set_line(priv, baud, parity, bits, stb);\r\nif (rtn)\r\ngoto out;\r\npch_uart_set_mctrl(&priv->port, priv->port.mctrl);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nout:\r\nspin_unlock(&port->lock);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic const char *pch_uart_type(struct uart_port *port)\r\n{\r\nreturn KBUILD_MODNAME;\r\n}\r\nstatic void pch_uart_release_port(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\npci_iounmap(priv->pdev, priv->membase);\r\npci_release_regions(priv->pdev);\r\n}\r\nstatic int pch_uart_request_port(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv;\r\nint ret;\r\nvoid __iomem *membase;\r\npriv = container_of(port, struct eg20t_port, port);\r\nret = pci_request_regions(priv->pdev, KBUILD_MODNAME);\r\nif (ret < 0)\r\nreturn -EBUSY;\r\nmembase = pci_iomap(priv->pdev, 1, 0);\r\nif (!membase) {\r\npci_release_regions(priv->pdev);\r\nreturn -EBUSY;\r\n}\r\npriv->membase = port->membase = membase;\r\nreturn 0;\r\n}\r\nstatic void pch_uart_config_port(struct uart_port *port, int type)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\nif (type & UART_CONFIG_TYPE) {\r\nport->type = priv->port_type;\r\npch_uart_request_port(port);\r\n}\r\n}\r\nstatic int pch_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *serinfo)\r\n{\r\nstruct eg20t_port *priv;\r\npriv = container_of(port, struct eg20t_port, port);\r\nif (serinfo->flags & UPF_LOW_LATENCY) {\r\ndev_info(priv->port.dev,\r\n"PCH UART : Use PIO Mode (without DMA)\n");\r\npriv->use_dma = 0;\r\nserinfo->flags &= ~UPF_LOW_LATENCY;\r\n} else {\r\n#ifndef CONFIG_PCH_DMA\r\ndev_err(priv->port.dev, "%s : PCH DMA is not Loaded.\n",\r\n__func__);\r\nreturn -EOPNOTSUPP;\r\n#endif\r\nif (!priv->use_dma) {\r\npch_request_dma(port);\r\nif (priv->chan_rx)\r\npriv->use_dma = 1;\r\n}\r\ndev_info(priv->port.dev, "PCH UART: %s\n",\r\npriv->use_dma ?\r\n"Use DMA Mode" : "No DMA");\r\n}\r\nreturn 0;\r\n}\r\nstatic void wait_for_xmitr(struct eg20t_port *up, int bits)\r\n{\r\nunsigned int status, tmout = 10000;\r\nfor (;;) {\r\nstatus = ioread8(up->membase + UART_LSR);\r\nif ((status & bits) == bits)\r\nbreak;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\nunsigned int tmout;\r\nfor (tmout = 1000000; tmout; tmout--) {\r\nunsigned int msr = ioread8(up->membase + UART_MSR);\r\nif (msr & UART_MSR_CTS)\r\nbreak;\r\nudelay(1);\r\ntouch_nmi_watchdog();\r\n}\r\n}\r\n}\r\nstatic int pch_uart_get_poll_char(struct uart_port *port)\r\n{\r\nstruct eg20t_port *priv =\r\ncontainer_of(port, struct eg20t_port, port);\r\nu8 lsr = ioread8(priv->membase + UART_LSR);\r\nif (!(lsr & UART_LSR_DR))\r\nreturn NO_POLL_CHAR;\r\nreturn ioread8(priv->membase + PCH_UART_RBR);\r\n}\r\nstatic void pch_uart_put_poll_char(struct uart_port *port,\r\nunsigned char c)\r\n{\r\nunsigned int ier;\r\nstruct eg20t_port *priv =\r\ncontainer_of(port, struct eg20t_port, port);\r\nier = ioread8(priv->membase + UART_IER);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\r\nwait_for_xmitr(priv, UART_LSR_THRE);\r\niowrite8(c, priv->membase + PCH_UART_THR);\r\nwait_for_xmitr(priv, BOTH_EMPTY);\r\niowrite8(ier, priv->membase + UART_IER);\r\n}\r\nstatic void pch_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct eg20t_port *priv =\r\ncontainer_of(port, struct eg20t_port, port);\r\nwait_for_xmitr(priv, UART_LSR_THRE);\r\niowrite8(ch, priv->membase + PCH_UART_THR);\r\n}\r\nstatic void\r\npch_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct eg20t_port *priv;\r\nunsigned long flags;\r\nint priv_locked = 1;\r\nint port_locked = 1;\r\nu8 ier;\r\npriv = pch_uart_ports[co->index];\r\ntouch_nmi_watchdog();\r\nlocal_irq_save(flags);\r\nif (priv->port.sysrq) {\r\npriv_locked = 0;\r\nport_locked = 0;\r\n} else if (oops_in_progress) {\r\npriv_locked = spin_trylock(&priv->lock);\r\nport_locked = spin_trylock(&priv->port.lock);\r\n} else {\r\nspin_lock(&priv->lock);\r\nspin_lock(&priv->port.lock);\r\n}\r\nier = ioread8(priv->membase + UART_IER);\r\npch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_ALL_INT);\r\nuart_console_write(&priv->port, s, count, pch_console_putchar);\r\nwait_for_xmitr(priv, BOTH_EMPTY);\r\niowrite8(ier, priv->membase + UART_IER);\r\nif (port_locked)\r\nspin_unlock(&priv->port.lock);\r\nif (priv_locked)\r\nspin_unlock(&priv->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init pch_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nint baud = default_baud;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= PCH_UART_NR)\r\nco->index = 0;\r\nport = &pch_uart_ports[co->index]->port;\r\nif (!port || (!port->iobase && !port->membase))\r\nreturn -ENODEV;\r\nport->uartclk = pch_uart_get_uartclk();\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic struct eg20t_port *pch_uart_init_port(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct eg20t_port *priv;\r\nint ret;\r\nunsigned int iobase;\r\nunsigned int mapbase;\r\nunsigned char *rxbuf;\r\nint fifosize;\r\nint port_type;\r\nstruct pch_uart_driver_data *board;\r\n#ifdef CONFIG_DEBUG_FS\r\nchar name[32];\r\n#endif\r\nboard = &drv_dat[id->driver_data];\r\nport_type = board->port_type;\r\npriv = kzalloc(sizeof(struct eg20t_port), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto init_port_alloc_err;\r\nrxbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\r\nif (!rxbuf)\r\ngoto init_port_free_txbuf;\r\nswitch (port_type) {\r\ncase PORT_UNKNOWN:\r\nfifosize = 256;\r\nbreak;\r\ncase PORT_8250:\r\nfifosize = 64;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid Port Type(=%d)\n", port_type);\r\ngoto init_port_hal_free;\r\n}\r\npci_enable_msi(pdev);\r\npci_set_master(pdev);\r\nspin_lock_init(&priv->lock);\r\niobase = pci_resource_start(pdev, 0);\r\nmapbase = pci_resource_start(pdev, 1);\r\npriv->mapbase = mapbase;\r\npriv->iobase = iobase;\r\npriv->pdev = pdev;\r\npriv->tx_empty = 1;\r\npriv->rxbuf.buf = rxbuf;\r\npriv->rxbuf.size = PAGE_SIZE;\r\npriv->fifo_size = fifosize;\r\npriv->uartclk = pch_uart_get_uartclk();\r\npriv->port_type = PORT_MAX_8250 + port_type + 1;\r\npriv->port.dev = &pdev->dev;\r\npriv->port.iobase = iobase;\r\npriv->port.membase = NULL;\r\npriv->port.mapbase = mapbase;\r\npriv->port.irq = pdev->irq;\r\npriv->port.iotype = UPIO_PORT;\r\npriv->port.ops = &pch_uart_ops;\r\npriv->port.flags = UPF_BOOT_AUTOCONF;\r\npriv->port.fifosize = fifosize;\r\npriv->port.line = board->line_no;\r\npriv->trigger = PCH_UART_HAL_TRIGGER_M;\r\nsnprintf(priv->irq_name, IRQ_NAME_SIZE,\r\nKBUILD_MODNAME ":" PCH_UART_DRIVER_DEVICE "%d",\r\npriv->port.line);\r\nspin_lock_init(&priv->port.lock);\r\npci_set_drvdata(pdev, priv);\r\npriv->trigger_level = 1;\r\npriv->fcr = 0;\r\nif (pdev->dev.of_node)\r\nof_property_read_u32(pdev->dev.of_node, "clock-frequency"\r\n, &user_uartclk);\r\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\r\npch_uart_ports[board->line_no] = priv;\r\n#endif\r\nret = uart_add_one_port(&pch_uart_driver, &priv->port);\r\nif (ret < 0)\r\ngoto init_port_hal_free;\r\n#ifdef CONFIG_DEBUG_FS\r\nsnprintf(name, sizeof(name), "uart%d_regs", board->line_no);\r\npriv->debugfs = debugfs_create_file(name, S_IFREG | S_IRUGO,\r\nNULL, priv, &port_regs_ops);\r\n#endif\r\nreturn priv;\r\ninit_port_hal_free:\r\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\r\npch_uart_ports[board->line_no] = NULL;\r\n#endif\r\nfree_page((unsigned long)rxbuf);\r\ninit_port_free_txbuf:\r\nkfree(priv);\r\ninit_port_alloc_err:\r\nreturn NULL;\r\n}\r\nstatic void pch_uart_exit_port(struct eg20t_port *priv)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nif (priv->debugfs)\r\ndebugfs_remove(priv->debugfs);\r\n#endif\r\nuart_remove_one_port(&pch_uart_driver, &priv->port);\r\nfree_page((unsigned long)priv->rxbuf.buf);\r\n}\r\nstatic void pch_uart_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct eg20t_port *priv = pci_get_drvdata(pdev);\r\npci_disable_msi(pdev);\r\n#ifdef CONFIG_SERIAL_PCH_UART_CONSOLE\r\npch_uart_ports[priv->port.line] = NULL;\r\n#endif\r\npch_uart_exit_port(priv);\r\npci_disable_device(pdev);\r\nkfree(priv);\r\nreturn;\r\n}\r\nstatic int pch_uart_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct eg20t_port *priv = pci_get_drvdata(pdev);\r\nuart_suspend_port(&pch_uart_driver, &priv->port);\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pch_uart_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct eg20t_port *priv = pci_get_drvdata(pdev);\r\nint ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"%s-pci_enable_device failed(ret=%d) ", __func__, ret);\r\nreturn ret;\r\n}\r\nuart_resume_port(&pch_uart_driver, &priv->port);\r\nreturn 0;\r\n}\r\nstatic int pch_uart_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint ret;\r\nstruct eg20t_port *priv;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0)\r\ngoto probe_error;\r\npriv = pch_uart_init_port(pdev, id);\r\nif (!priv) {\r\nret = -EBUSY;\r\ngoto probe_disable_device;\r\n}\r\npci_set_drvdata(pdev, priv);\r\nreturn ret;\r\nprobe_disable_device:\r\npci_disable_msi(pdev);\r\npci_disable_device(pdev);\r\nprobe_error:\r\nreturn ret;\r\n}\r\nstatic int __init pch_uart_module_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&pch_uart_driver);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pci_register_driver(&pch_uart_pci_driver);\r\nif (ret < 0)\r\nuart_unregister_driver(&pch_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit pch_uart_module_exit(void)\r\n{\r\npci_unregister_driver(&pch_uart_pci_driver);\r\nuart_unregister_driver(&pch_uart_driver);\r\n}
