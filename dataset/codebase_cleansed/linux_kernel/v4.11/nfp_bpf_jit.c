static bool\r\nnfp_meta_has_next(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn meta->l.next != &nfp_prog->insns;\r\n}\r\nstatic bool\r\nnfp_meta_has_prev(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn meta->l.prev != &nfp_prog->insns;\r\n}\r\nstatic void nfp_prog_free(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta, *tmp;\r\nlist_for_each_entry_safe(meta, tmp, &nfp_prog->insns, l) {\r\nlist_del(&meta->l);\r\nkfree(meta);\r\n}\r\nkfree(nfp_prog);\r\n}\r\nstatic void nfp_prog_push(struct nfp_prog *nfp_prog, u64 insn)\r\n{\r\nif (nfp_prog->__prog_alloc_len == nfp_prog->prog_len) {\r\nnfp_prog->error = -ENOSPC;\r\nreturn;\r\n}\r\nnfp_prog->prog[nfp_prog->prog_len] = insn;\r\nnfp_prog->prog_len++;\r\n}\r\nstatic unsigned int nfp_prog_current_offset(struct nfp_prog *nfp_prog)\r\n{\r\nreturn nfp_prog->start_off + nfp_prog->prog_len;\r\n}\r\nstatic unsigned int\r\nnfp_prog_offset_to_index(struct nfp_prog *nfp_prog, unsigned int offset)\r\n{\r\nreturn offset - nfp_prog->start_off;\r\n}\r\nstatic u16 nfp_swreg_to_unreg(u32 swreg, bool is_dst)\r\n{\r\nu16 val = FIELD_GET(NN_REG_VAL, swreg);\r\nswitch (FIELD_GET(NN_REG_TYPE, swreg)) {\r\ncase NN_REG_GPR_A:\r\ncase NN_REG_GPR_B:\r\ncase NN_REG_GPR_BOTH:\r\nreturn val;\r\ncase NN_REG_NNR:\r\nreturn UR_REG_NN | val;\r\ncase NN_REG_XFER:\r\nreturn UR_REG_XFR | val;\r\ncase NN_REG_IMM:\r\nif (val & ~0xff) {\r\npr_err("immediate too large\n");\r\nreturn 0;\r\n}\r\nreturn UR_REG_IMM_encode(val);\r\ncase NN_REG_NONE:\r\nreturn is_dst ? UR_REG_NO_DST : REG_NONE;\r\ndefault:\r\npr_err("unrecognized reg encoding %08x\n", swreg);\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\nswreg_to_unrestricted(u32 dst, u32 lreg, u32 rreg, struct nfp_insn_ur_regs *reg)\r\n{\r\nmemset(reg, 0, sizeof(*reg));\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_IMM)\r\nreturn -EFAULT;\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_GPR_B)\r\nreg->dst_ab = ALU_DST_B;\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_GPR_BOTH)\r\nreg->wr_both = true;\r\nreg->dst = nfp_swreg_to_unreg(dst, true);\r\nif (FIELD_GET(NN_REG_TYPE, lreg) == FIELD_GET(NN_REG_TYPE, rreg))\r\nreturn -EFAULT;\r\nif (FIELD_GET(NN_REG_TYPE, lreg) == NN_REG_GPR_B ||\r\nFIELD_GET(NN_REG_TYPE, rreg) == NN_REG_GPR_A) {\r\nreg->areg = nfp_swreg_to_unreg(rreg, false);\r\nreg->breg = nfp_swreg_to_unreg(lreg, false);\r\nreg->swap = true;\r\n} else {\r\nreg->areg = nfp_swreg_to_unreg(lreg, false);\r\nreg->breg = nfp_swreg_to_unreg(rreg, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 nfp_swreg_to_rereg(u32 swreg, bool is_dst, bool has_imm8, bool *i8)\r\n{\r\nu16 val = FIELD_GET(NN_REG_VAL, swreg);\r\nswitch (FIELD_GET(NN_REG_TYPE, swreg)) {\r\ncase NN_REG_GPR_A:\r\ncase NN_REG_GPR_B:\r\ncase NN_REG_GPR_BOTH:\r\nreturn val;\r\ncase NN_REG_XFER:\r\nreturn RE_REG_XFR | val;\r\ncase NN_REG_IMM:\r\nif (val & ~(0x7f | has_imm8 << 7)) {\r\npr_err("immediate too large\n");\r\nreturn 0;\r\n}\r\n*i8 = val & 0x80;\r\nreturn RE_REG_IMM_encode(val & 0x7f);\r\ncase NN_REG_NONE:\r\nreturn is_dst ? RE_REG_NO_DST : REG_NONE;\r\ndefault:\r\npr_err("unrecognized reg encoding\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\nswreg_to_restricted(u32 dst, u32 lreg, u32 rreg, struct nfp_insn_re_regs *reg,\r\nbool has_imm8)\r\n{\r\nmemset(reg, 0, sizeof(*reg));\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_IMM)\r\nreturn -EFAULT;\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_GPR_B)\r\nreg->dst_ab = ALU_DST_B;\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_GPR_BOTH)\r\nreg->wr_both = true;\r\nreg->dst = nfp_swreg_to_rereg(dst, true, false, NULL);\r\nif (FIELD_GET(NN_REG_TYPE, lreg) == FIELD_GET(NN_REG_TYPE, rreg))\r\nreturn -EFAULT;\r\nif (FIELD_GET(NN_REG_TYPE, lreg) == NN_REG_GPR_B ||\r\nFIELD_GET(NN_REG_TYPE, rreg) == NN_REG_GPR_A) {\r\nreg->areg = nfp_swreg_to_rereg(rreg, false, has_imm8, &reg->i8);\r\nreg->breg = nfp_swreg_to_rereg(lreg, false, has_imm8, &reg->i8);\r\nreg->swap = true;\r\n} else {\r\nreg->areg = nfp_swreg_to_rereg(lreg, false, has_imm8, &reg->i8);\r\nreg->breg = nfp_swreg_to_rereg(rreg, false, has_imm8, &reg->i8);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\n__emit_cmd(struct nfp_prog *nfp_prog, enum cmd_tgt_map op,\r\nu8 mode, u8 xfer, u8 areg, u8 breg, u8 size, bool sync)\r\n{\r\nenum cmd_ctx_swap ctx;\r\nu64 insn;\r\nif (sync)\r\nctx = CMD_CTX_SWAP;\r\nelse\r\nctx = CMD_CTX_NO_SWAP;\r\ninsn = FIELD_PREP(OP_CMD_A_SRC, areg) |\r\nFIELD_PREP(OP_CMD_CTX, ctx) |\r\nFIELD_PREP(OP_CMD_B_SRC, breg) |\r\nFIELD_PREP(OP_CMD_TOKEN, cmd_tgt_act[op].token) |\r\nFIELD_PREP(OP_CMD_XFER, xfer) |\r\nFIELD_PREP(OP_CMD_CNT, size) |\r\nFIELD_PREP(OP_CMD_SIG, sync) |\r\nFIELD_PREP(OP_CMD_TGT_CMD, cmd_tgt_act[op].tgt_cmd) |\r\nFIELD_PREP(OP_CMD_MODE, mode);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_cmd(struct nfp_prog *nfp_prog, enum cmd_tgt_map op,\r\nu8 mode, u8 xfer, u32 lreg, u32 rreg, u8 size, bool sync)\r\n{\r\nstruct nfp_insn_re_regs reg;\r\nint err;\r\nerr = swreg_to_restricted(reg_none(), lreg, rreg, &reg, false);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\nif (reg.swap) {\r\npr_err("cmd can't swap arguments\n");\r\nnfp_prog->error = -EFAULT;\r\nreturn;\r\n}\r\n__emit_cmd(nfp_prog, op, mode, xfer, reg.areg, reg.breg, size, sync);\r\n}\r\nstatic void\r\n__emit_br(struct nfp_prog *nfp_prog, enum br_mask mask, enum br_ev_pip ev_pip,\r\nenum br_ctx_signal_state css, u16 addr, u8 defer)\r\n{\r\nu16 addr_lo, addr_hi;\r\nu64 insn;\r\naddr_lo = addr & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));\r\naddr_hi = addr != addr_lo;\r\ninsn = OP_BR_BASE |\r\nFIELD_PREP(OP_BR_MASK, mask) |\r\nFIELD_PREP(OP_BR_EV_PIP, ev_pip) |\r\nFIELD_PREP(OP_BR_CSS, css) |\r\nFIELD_PREP(OP_BR_DEFBR, defer) |\r\nFIELD_PREP(OP_BR_ADDR_LO, addr_lo) |\r\nFIELD_PREP(OP_BR_ADDR_HI, addr_hi);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void emit_br_def(struct nfp_prog *nfp_prog, u16 addr, u8 defer)\r\n{\r\nif (defer > 2) {\r\npr_err("BUG: branch defer out of bounds %d\n", defer);\r\nnfp_prog->error = -EFAULT;\r\nreturn;\r\n}\r\n__emit_br(nfp_prog, BR_UNC, BR_EV_PIP_UNCOND, BR_CSS_NONE, addr, defer);\r\n}\r\nstatic void\r\nemit_br(struct nfp_prog *nfp_prog, enum br_mask mask, u16 addr, u8 defer)\r\n{\r\n__emit_br(nfp_prog, mask,\r\nmask != BR_UNC ? BR_EV_PIP_COND : BR_EV_PIP_UNCOND,\r\nBR_CSS_NONE, addr, defer);\r\n}\r\nstatic void\r\n__emit_br_byte(struct nfp_prog *nfp_prog, u8 areg, u8 breg, bool imm8,\r\nu8 byte, bool equal, u16 addr, u8 defer)\r\n{\r\nu16 addr_lo, addr_hi;\r\nu64 insn;\r\naddr_lo = addr & (OP_BB_ADDR_LO >> __bf_shf(OP_BB_ADDR_LO));\r\naddr_hi = addr != addr_lo;\r\ninsn = OP_BBYTE_BASE |\r\nFIELD_PREP(OP_BB_A_SRC, areg) |\r\nFIELD_PREP(OP_BB_BYTE, byte) |\r\nFIELD_PREP(OP_BB_B_SRC, breg) |\r\nFIELD_PREP(OP_BB_I8, imm8) |\r\nFIELD_PREP(OP_BB_EQ, equal) |\r\nFIELD_PREP(OP_BB_DEFBR, defer) |\r\nFIELD_PREP(OP_BB_ADDR_LO, addr_lo) |\r\nFIELD_PREP(OP_BB_ADDR_HI, addr_hi);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_br_byte_neq(struct nfp_prog *nfp_prog,\r\nu32 dst, u8 imm, u8 byte, u16 addr, u8 defer)\r\n{\r\nstruct nfp_insn_re_regs reg;\r\nint err;\r\nerr = swreg_to_restricted(reg_none(), dst, reg_imm(imm), &reg, true);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\n__emit_br_byte(nfp_prog, reg.areg, reg.breg, reg.i8, byte, false, addr,\r\ndefer);\r\n}\r\nstatic void\r\n__emit_immed(struct nfp_prog *nfp_prog, u16 areg, u16 breg, u16 imm_hi,\r\nenum immed_width width, bool invert,\r\nenum immed_shift shift, bool wr_both)\r\n{\r\nu64 insn;\r\ninsn = OP_IMMED_BASE |\r\nFIELD_PREP(OP_IMMED_A_SRC, areg) |\r\nFIELD_PREP(OP_IMMED_B_SRC, breg) |\r\nFIELD_PREP(OP_IMMED_IMM, imm_hi) |\r\nFIELD_PREP(OP_IMMED_WIDTH, width) |\r\nFIELD_PREP(OP_IMMED_INV, invert) |\r\nFIELD_PREP(OP_IMMED_SHIFT, shift) |\r\nFIELD_PREP(OP_IMMED_WR_AB, wr_both);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_immed(struct nfp_prog *nfp_prog, u32 dst, u16 imm,\r\nenum immed_width width, bool invert, enum immed_shift shift)\r\n{\r\nstruct nfp_insn_ur_regs reg;\r\nint err;\r\nif (FIELD_GET(NN_REG_TYPE, dst) == NN_REG_IMM) {\r\nnfp_prog->error = -EFAULT;\r\nreturn;\r\n}\r\nerr = swreg_to_unrestricted(dst, dst, reg_imm(imm & 0xff), &reg);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\n__emit_immed(nfp_prog, reg.areg, reg.breg, imm >> 8, width,\r\ninvert, shift, reg.wr_both);\r\n}\r\nstatic void\r\n__emit_shf(struct nfp_prog *nfp_prog, u16 dst, enum alu_dst_ab dst_ab,\r\nenum shf_sc sc, u8 shift,\r\nu16 areg, enum shf_op op, u16 breg, bool i8, bool sw, bool wr_both)\r\n{\r\nu64 insn;\r\nif (!FIELD_FIT(OP_SHF_SHIFT, shift)) {\r\nnfp_prog->error = -EFAULT;\r\nreturn;\r\n}\r\nif (sc == SHF_SC_L_SHF)\r\nshift = 32 - shift;\r\ninsn = OP_SHF_BASE |\r\nFIELD_PREP(OP_SHF_A_SRC, areg) |\r\nFIELD_PREP(OP_SHF_SC, sc) |\r\nFIELD_PREP(OP_SHF_B_SRC, breg) |\r\nFIELD_PREP(OP_SHF_I8, i8) |\r\nFIELD_PREP(OP_SHF_SW, sw) |\r\nFIELD_PREP(OP_SHF_DST, dst) |\r\nFIELD_PREP(OP_SHF_SHIFT, shift) |\r\nFIELD_PREP(OP_SHF_OP, op) |\r\nFIELD_PREP(OP_SHF_DST_AB, dst_ab) |\r\nFIELD_PREP(OP_SHF_WR_AB, wr_both);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_shf(struct nfp_prog *nfp_prog, u32 dst, u32 lreg, enum shf_op op, u32 rreg,\r\nenum shf_sc sc, u8 shift)\r\n{\r\nstruct nfp_insn_re_regs reg;\r\nint err;\r\nerr = swreg_to_restricted(dst, lreg, rreg, &reg, true);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\n__emit_shf(nfp_prog, reg.dst, reg.dst_ab, sc, shift,\r\nreg.areg, op, reg.breg, reg.i8, reg.swap, reg.wr_both);\r\n}\r\nstatic void\r\n__emit_alu(struct nfp_prog *nfp_prog, u16 dst, enum alu_dst_ab dst_ab,\r\nu16 areg, enum alu_op op, u16 breg, bool swap, bool wr_both)\r\n{\r\nu64 insn;\r\ninsn = OP_ALU_BASE |\r\nFIELD_PREP(OP_ALU_A_SRC, areg) |\r\nFIELD_PREP(OP_ALU_B_SRC, breg) |\r\nFIELD_PREP(OP_ALU_DST, dst) |\r\nFIELD_PREP(OP_ALU_SW, swap) |\r\nFIELD_PREP(OP_ALU_OP, op) |\r\nFIELD_PREP(OP_ALU_DST_AB, dst_ab) |\r\nFIELD_PREP(OP_ALU_WR_AB, wr_both);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_alu(struct nfp_prog *nfp_prog, u32 dst, u32 lreg, enum alu_op op, u32 rreg)\r\n{\r\nstruct nfp_insn_ur_regs reg;\r\nint err;\r\nerr = swreg_to_unrestricted(dst, lreg, rreg, &reg);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\n__emit_alu(nfp_prog, reg.dst, reg.dst_ab,\r\nreg.areg, op, reg.breg, reg.swap, reg.wr_both);\r\n}\r\nstatic void\r\n__emit_ld_field(struct nfp_prog *nfp_prog, enum shf_sc sc,\r\nu8 areg, u8 bmask, u8 breg, u8 shift, bool imm8,\r\nbool zero, bool swap, bool wr_both)\r\n{\r\nu64 insn;\r\ninsn = OP_LDF_BASE |\r\nFIELD_PREP(OP_LDF_A_SRC, areg) |\r\nFIELD_PREP(OP_LDF_SC, sc) |\r\nFIELD_PREP(OP_LDF_B_SRC, breg) |\r\nFIELD_PREP(OP_LDF_I8, imm8) |\r\nFIELD_PREP(OP_LDF_SW, swap) |\r\nFIELD_PREP(OP_LDF_ZF, zero) |\r\nFIELD_PREP(OP_LDF_BMASK, bmask) |\r\nFIELD_PREP(OP_LDF_SHF, shift) |\r\nFIELD_PREP(OP_LDF_WR_AB, wr_both);\r\nnfp_prog_push(nfp_prog, insn);\r\n}\r\nstatic void\r\nemit_ld_field_any(struct nfp_prog *nfp_prog, enum shf_sc sc, u8 shift,\r\nu32 dst, u8 bmask, u32 src, bool zero)\r\n{\r\nstruct nfp_insn_re_regs reg;\r\nint err;\r\nerr = swreg_to_restricted(reg_none(), dst, src, &reg, true);\r\nif (err) {\r\nnfp_prog->error = err;\r\nreturn;\r\n}\r\n__emit_ld_field(nfp_prog, sc, reg.areg, bmask, reg.breg, shift,\r\nreg.i8, zero, reg.swap, reg.wr_both);\r\n}\r\nstatic void\r\nemit_ld_field(struct nfp_prog *nfp_prog, u32 dst, u8 bmask, u32 src,\r\nenum shf_sc sc, u8 shift)\r\n{\r\nemit_ld_field_any(nfp_prog, sc, shift, dst, bmask, src, false);\r\n}\r\nstatic bool pack_immed(u32 imm, u16 *val, enum immed_shift *shift)\r\n{\r\nif (!(imm & 0xffff0000)) {\r\n*val = imm;\r\n*shift = IMMED_SHIFT_0B;\r\n} else if (!(imm & 0xff0000ff)) {\r\n*val = imm >> 8;\r\n*shift = IMMED_SHIFT_1B;\r\n} else if (!(imm & 0x0000ffff)) {\r\n*val = imm >> 16;\r\n*shift = IMMED_SHIFT_2B;\r\n} else {\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void wrp_immed(struct nfp_prog *nfp_prog, u32 dst, u32 imm)\r\n{\r\nenum immed_shift shift;\r\nu16 val;\r\nif (pack_immed(imm, &val, &shift)) {\r\nemit_immed(nfp_prog, dst, val, IMMED_WIDTH_ALL, false, shift);\r\n} else if (pack_immed(~imm, &val, &shift)) {\r\nemit_immed(nfp_prog, dst, val, IMMED_WIDTH_ALL, true, shift);\r\n} else {\r\nemit_immed(nfp_prog, dst, imm & 0xffff, IMMED_WIDTH_ALL,\r\nfalse, IMMED_SHIFT_0B);\r\nemit_immed(nfp_prog, dst, imm >> 16, IMMED_WIDTH_WORD,\r\nfalse, IMMED_SHIFT_2B);\r\n}\r\n}\r\nstatic u32 ur_load_imm_any(struct nfp_prog *nfp_prog, u32 imm, u32 tmp_reg)\r\n{\r\nif (FIELD_FIT(UR_REG_IMM_MAX, imm))\r\nreturn reg_imm(imm);\r\nwrp_immed(nfp_prog, tmp_reg, imm);\r\nreturn tmp_reg;\r\n}\r\nstatic u32 re_load_imm_any(struct nfp_prog *nfp_prog, u32 imm, u32 tmp_reg)\r\n{\r\nif (FIELD_FIT(RE_REG_IMM_MAX, imm))\r\nreturn reg_imm(imm);\r\nwrp_immed(nfp_prog, tmp_reg, imm);\r\nreturn tmp_reg;\r\n}\r\nstatic void\r\nwrp_br_special(struct nfp_prog *nfp_prog, enum br_mask mask,\r\nenum br_special special)\r\n{\r\nemit_br(nfp_prog, mask, 0, 0);\r\nnfp_prog->prog[nfp_prog->prog_len - 1] |=\r\nFIELD_PREP(OP_BR_SPECIAL, special);\r\n}\r\nstatic void wrp_reg_mov(struct nfp_prog *nfp_prog, u16 dst, u16 src)\r\n{\r\nemit_alu(nfp_prog, reg_both(dst), reg_none(), ALU_OP_NONE, reg_b(src));\r\n}\r\nstatic int\r\nconstruct_data_ind_ld(struct nfp_prog *nfp_prog, u16 offset,\r\nu16 src, bool src_valid, u8 size)\r\n{\r\nunsigned int i;\r\nu16 shift, sz;\r\nu32 tmp_reg;\r\nsz = size < 4 ? 4 : size;\r\nshift = size < 4 ? 4 - size : 0;\r\nif (src_valid) {\r\ntmp_reg = ur_load_imm_any(nfp_prog, offset, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, imm_both(nfp_prog),\r\nreg_a(src), ALU_OP_ADD, tmp_reg);\r\nemit_alu(nfp_prog, imm_a(nfp_prog),\r\nimm_a(nfp_prog), ALU_OP_ADD, reg_imm(size));\r\nemit_alu(nfp_prog, reg_none(),\r\nNFP_BPF_ABI_LEN, ALU_OP_SUB, imm_a(nfp_prog));\r\nwrp_br_special(nfp_prog, BR_BLO, OP_BR_GO_ABORT);\r\nemit_cmd(nfp_prog, CMD_TGT_READ8, CMD_MODE_32b, 0,\r\npkt_reg(nfp_prog), imm_b(nfp_prog), sz - 1, true);\r\n} else {\r\ntmp_reg = ur_load_imm_any(nfp_prog, offset + size,\r\nimm_a(nfp_prog));\r\nemit_alu(nfp_prog, reg_none(),\r\nNFP_BPF_ABI_LEN, ALU_OP_SUB, tmp_reg);\r\nwrp_br_special(nfp_prog, BR_BLO, OP_BR_GO_ABORT);\r\ntmp_reg = re_load_imm_any(nfp_prog, offset, imm_b(nfp_prog));\r\nemit_cmd(nfp_prog, CMD_TGT_READ8, CMD_MODE_32b, 0,\r\npkt_reg(nfp_prog), tmp_reg, sz - 1, true);\r\n}\r\ni = 0;\r\nif (shift)\r\nemit_shf(nfp_prog, reg_both(0), reg_none(), SHF_OP_NONE,\r\nreg_xfer(0), SHF_SC_R_SHF, shift * 8);\r\nelse\r\nfor (; i * 4 < size; i++)\r\nemit_alu(nfp_prog, reg_both(i),\r\nreg_none(), ALU_OP_NONE, reg_xfer(i));\r\nif (i < 2)\r\nwrp_immed(nfp_prog, reg_both(1), 0);\r\nreturn 0;\r\n}\r\nstatic int construct_data_ld(struct nfp_prog *nfp_prog, u16 offset, u8 size)\r\n{\r\nreturn construct_data_ind_ld(nfp_prog, offset, 0, false, size);\r\n}\r\nstatic int wrp_set_mark(struct nfp_prog *nfp_prog, u8 src)\r\n{\r\nemit_alu(nfp_prog, NFP_BPF_ABI_MARK,\r\nreg_none(), ALU_OP_NONE, reg_b(src));\r\nemit_alu(nfp_prog, NFP_BPF_ABI_FLAGS,\r\nNFP_BPF_ABI_FLAGS, ALU_OP_OR, reg_imm(NFP_BPF_ABI_FLAG_MARK));\r\nreturn 0;\r\n}\r\nstatic void\r\nwrp_alu_imm(struct nfp_prog *nfp_prog, u8 dst, enum alu_op alu_op, u32 imm)\r\n{\r\nu32 tmp_reg;\r\nif (alu_op == ALU_OP_AND) {\r\nif (!imm)\r\nwrp_immed(nfp_prog, reg_both(dst), 0);\r\nif (!imm || !~imm)\r\nreturn;\r\n}\r\nif (alu_op == ALU_OP_OR) {\r\nif (!~imm)\r\nwrp_immed(nfp_prog, reg_both(dst), ~0U);\r\nif (!imm || !~imm)\r\nreturn;\r\n}\r\nif (alu_op == ALU_OP_XOR) {\r\nif (!~imm)\r\nemit_alu(nfp_prog, reg_both(dst), reg_none(),\r\nALU_OP_NEG, reg_b(dst));\r\nif (!imm || !~imm)\r\nreturn;\r\n}\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, tmp_reg);\r\n}\r\nstatic int\r\nwrp_alu64_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum alu_op alu_op, bool skip)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nif (skip) {\r\nmeta->skip = true;\r\nreturn 0;\r\n}\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2, alu_op, imm & ~0U);\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, alu_op, imm >> 32);\r\nreturn 0;\r\n}\r\nstatic int\r\nwrp_alu64_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum alu_op alu_op)\r\n{\r\nu8 dst = meta->insn.dst_reg * 2, src = meta->insn.src_reg * 2;\r\nemit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, reg_b(src));\r\nemit_alu(nfp_prog, reg_both(dst + 1),\r\nreg_a(dst + 1), alu_op, reg_b(src + 1));\r\nreturn 0;\r\n}\r\nstatic int\r\nwrp_alu32_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum alu_op alu_op, bool skip)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (skip) {\r\nmeta->skip = true;\r\nreturn 0;\r\n}\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2, alu_op, insn->imm);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nwrp_alu32_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum alu_op alu_op)\r\n{\r\nu8 dst = meta->insn.dst_reg * 2, src = meta->insn.src_reg * 2;\r\nemit_alu(nfp_prog, reg_both(dst), reg_a(dst), alu_op, reg_b(src));\r\nwrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic void\r\nwrp_test_reg_one(struct nfp_prog *nfp_prog, u8 dst, enum alu_op alu_op, u8 src,\r\nenum br_mask br_mask, u16 off)\r\n{\r\nemit_alu(nfp_prog, reg_none(), reg_a(dst), alu_op, reg_b(src));\r\nemit_br(nfp_prog, br_mask, off, 0);\r\n}\r\nstatic int\r\nwrp_test_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum alu_op alu_op, enum br_mask br_mask)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nwrp_test_reg_one(nfp_prog, insn->dst_reg * 2, alu_op,\r\ninsn->src_reg * 2, br_mask, insn->off);\r\nwrp_test_reg_one(nfp_prog, insn->dst_reg * 2 + 1, alu_op,\r\ninsn->src_reg * 2 + 1, br_mask, insn->off);\r\nreturn 0;\r\n}\r\nstatic int\r\nwrp_cmp_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum br_mask br_mask, bool swap)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nu8 reg = insn->dst_reg * 2;\r\nu32 tmp_reg;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\r\nif (!swap)\r\nemit_alu(nfp_prog, reg_none(), reg_a(reg), ALU_OP_SUB, tmp_reg);\r\nelse\r\nemit_alu(nfp_prog, reg_none(), tmp_reg, ALU_OP_SUB, reg_a(reg));\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\r\nif (!swap)\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(reg + 1), ALU_OP_SUB_C, tmp_reg);\r\nelse\r\nemit_alu(nfp_prog, reg_none(),\r\ntmp_reg, ALU_OP_SUB_C, reg_a(reg + 1));\r\nemit_br(nfp_prog, br_mask, insn->off, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nwrp_cmp_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nenum br_mask br_mask, bool swap)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu8 areg = insn->src_reg * 2, breg = insn->dst_reg * 2;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nif (swap) {\r\nareg ^= breg;\r\nbreg ^= areg;\r\nareg ^= breg;\r\n}\r\nemit_alu(nfp_prog, reg_none(), reg_a(areg), ALU_OP_SUB, reg_b(breg));\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(areg + 1), ALU_OP_SUB_C, reg_b(breg + 1));\r\nemit_br(nfp_prog, br_mask, insn->off, 0);\r\nreturn 0;\r\n}\r\nstatic int mov_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nwrp_reg_mov(nfp_prog, insn->dst_reg * 2, insn->src_reg * 2);\r\nwrp_reg_mov(nfp_prog, insn->dst_reg * 2 + 1, insn->src_reg * 2 + 1);\r\nreturn 0;\r\n}\r\nstatic int mov_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nu64 imm = meta->insn.imm;\r\nwrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2), imm & ~0U);\r\nwrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), imm >> 32);\r\nreturn 0;\r\n}\r\nstatic int xor_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_XOR);\r\n}\r\nstatic int xor_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_XOR, !meta->insn.imm);\r\n}\r\nstatic int and_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_AND);\r\n}\r\nstatic int and_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_AND, !~meta->insn.imm);\r\n}\r\nstatic int or_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_reg(nfp_prog, meta, ALU_OP_OR);\r\n}\r\nstatic int or_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu64_imm(nfp_prog, meta, ALU_OP_OR, !meta->insn.imm);\r\n}\r\nstatic int add_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nemit_alu(nfp_prog, reg_both(insn->dst_reg * 2),\r\nreg_a(insn->dst_reg * 2), ALU_OP_ADD,\r\nreg_b(insn->src_reg * 2));\r\nemit_alu(nfp_prog, reg_both(insn->dst_reg * 2 + 1),\r\nreg_a(insn->dst_reg * 2 + 1), ALU_OP_ADD_C,\r\nreg_b(insn->src_reg * 2 + 1));\r\nreturn 0;\r\n}\r\nstatic int add_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2, ALU_OP_ADD, imm & ~0U);\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, ALU_OP_ADD_C, imm >> 32);\r\nreturn 0;\r\n}\r\nstatic int sub_reg64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nemit_alu(nfp_prog, reg_both(insn->dst_reg * 2),\r\nreg_a(insn->dst_reg * 2), ALU_OP_SUB,\r\nreg_b(insn->src_reg * 2));\r\nemit_alu(nfp_prog, reg_both(insn->dst_reg * 2 + 1),\r\nreg_a(insn->dst_reg * 2 + 1), ALU_OP_SUB_C,\r\nreg_b(insn->src_reg * 2 + 1));\r\nreturn 0;\r\n}\r\nstatic int sub_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2, ALU_OP_SUB, imm & ~0U);\r\nwrp_alu_imm(nfp_prog, insn->dst_reg * 2 + 1, ALU_OP_SUB_C, imm >> 32);\r\nreturn 0;\r\n}\r\nstatic int shl_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (insn->imm != 32)\r\nreturn 1;\r\nwrp_reg_mov(nfp_prog, insn->dst_reg * 2 + 1, insn->dst_reg * 2);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2), 0);\r\nreturn 0;\r\n}\r\nstatic int shr_imm64(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (insn->imm != 32)\r\nreturn 1;\r\nwrp_reg_mov(nfp_prog, insn->dst_reg * 2, insn->dst_reg * 2 + 1);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic int mov_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nwrp_reg_mov(nfp_prog, insn->dst_reg * 2, insn->src_reg * 2);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic int mov_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2), insn->imm);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic int xor_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_XOR);\r\n}\r\nstatic int xor_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_XOR, !~meta->insn.imm);\r\n}\r\nstatic int and_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_AND);\r\n}\r\nstatic int and_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_AND, !~meta->insn.imm);\r\n}\r\nstatic int or_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_OR);\r\n}\r\nstatic int or_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_OR, !meta->insn.imm);\r\n}\r\nstatic int add_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_ADD);\r\n}\r\nstatic int add_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_ADD, !meta->insn.imm);\r\n}\r\nstatic int sub_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_reg(nfp_prog, meta, ALU_OP_SUB);\r\n}\r\nstatic int sub_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_alu32_imm(nfp_prog, meta, ALU_OP_SUB, !meta->insn.imm);\r\n}\r\nstatic int shl_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (!insn->imm)\r\nreturn 1;\r\nemit_shf(nfp_prog, reg_both(insn->dst_reg * 2),\r\nreg_none(), SHF_OP_NONE, reg_b(insn->dst_reg * 2),\r\nSHF_SC_L_SHF, insn->imm);\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2 + 1), 0);\r\nreturn 0;\r\n}\r\nstatic int imm_ld8_part2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nwrp_immed(nfp_prog, reg_both(nfp_meta_prev(meta)->insn.dst_reg * 2 + 1),\r\nmeta->insn.imm);\r\nreturn 0;\r\n}\r\nstatic int imm_ld8(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nmeta->double_cb = imm_ld8_part2;\r\nwrp_immed(nfp_prog, reg_both(insn->dst_reg * 2), insn->imm);\r\nreturn 0;\r\n}\r\nstatic int data_ld1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ld(nfp_prog, meta->insn.imm, 1);\r\n}\r\nstatic int data_ld2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ld(nfp_prog, meta->insn.imm, 2);\r\n}\r\nstatic int data_ld4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ld(nfp_prog, meta->insn.imm, 4);\r\n}\r\nstatic int data_ind_ld1(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ind_ld(nfp_prog, meta->insn.imm,\r\nmeta->insn.src_reg * 2, true, 1);\r\n}\r\nstatic int data_ind_ld2(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ind_ld(nfp_prog, meta->insn.imm,\r\nmeta->insn.src_reg * 2, true, 2);\r\n}\r\nstatic int data_ind_ld4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn construct_data_ind_ld(nfp_prog, meta->insn.imm,\r\nmeta->insn.src_reg * 2, true, 4);\r\n}\r\nstatic int mem_ldx4_skb(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nif (meta->insn.off == offsetof(struct sk_buff, len))\r\nemit_alu(nfp_prog, reg_both(meta->insn.dst_reg * 2),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_LEN);\r\nelse\r\nreturn -ENOTSUPP;\r\nreturn 0;\r\n}\r\nstatic int mem_ldx4_xdp(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nu32 dst = reg_both(meta->insn.dst_reg * 2);\r\nif (meta->insn.off != offsetof(struct xdp_md, data) &&\r\nmeta->insn.off != offsetof(struct xdp_md, data_end))\r\nreturn -ENOTSUPP;\r\nemit_alu(nfp_prog, dst, reg_none(), ALU_OP_NONE, NFP_BPF_ABI_PKT);\r\nif (meta->insn.off == offsetof(struct xdp_md, data))\r\nreturn 0;\r\nemit_alu(nfp_prog, dst, dst, ALU_OP_ADD, NFP_BPF_ABI_LEN);\r\nreturn 0;\r\n}\r\nstatic int mem_ldx4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nint ret;\r\nif (nfp_prog->act == NN_ACT_XDP)\r\nret = mem_ldx4_xdp(nfp_prog, meta);\r\nelse\r\nret = mem_ldx4_skb(nfp_prog, meta);\r\nwrp_immed(nfp_prog, reg_both(meta->insn.dst_reg * 2 + 1), 0);\r\nreturn ret;\r\n}\r\nstatic int mem_stx4_skb(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nif (meta->insn.off == offsetof(struct sk_buff, mark))\r\nreturn wrp_set_mark(nfp_prog, meta->insn.src_reg * 2);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int mem_stx4_xdp(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int mem_stx4(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nif (nfp_prog->act == NN_ACT_XDP)\r\nreturn mem_stx4_xdp(nfp_prog, meta);\r\nreturn mem_stx4_skb(nfp_prog, meta);\r\n}\r\nstatic int jump(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nif (meta->insn.off < 0)\r\nreturn -ENOTSUPP;\r\nemit_br(nfp_prog, BR_UNC, meta->insn.off, 0);\r\nreturn 0;\r\n}\r\nstatic int jeq_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nu32 or1 = reg_a(insn->dst_reg * 2), or2 = reg_b(insn->dst_reg * 2 + 1);\r\nu32 tmp_reg;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nif (imm & ~0U) {\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, imm_a(nfp_prog),\r\nreg_a(insn->dst_reg * 2), ALU_OP_XOR, tmp_reg);\r\nor1 = imm_a(nfp_prog);\r\n}\r\nif (imm >> 32) {\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, imm_b(nfp_prog),\r\nreg_a(insn->dst_reg * 2 + 1), ALU_OP_XOR, tmp_reg);\r\nor2 = imm_b(nfp_prog);\r\n}\r\nemit_alu(nfp_prog, reg_none(), or1, ALU_OP_OR, or2);\r\nemit_br(nfp_prog, BR_BEQ, insn->off, 0);\r\nreturn 0;\r\n}\r\nstatic int jgt_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_cmp_imm(nfp_prog, meta, BR_BLO, false);\r\n}\r\nstatic int jge_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_cmp_imm(nfp_prog, meta, BR_BHS, true);\r\n}\r\nstatic int jset_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nu32 tmp_reg;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nif (!imm) {\r\nmeta->skip = true;\r\nreturn 0;\r\n}\r\nif (imm & ~0U) {\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(insn->dst_reg * 2), ALU_OP_AND, tmp_reg);\r\nemit_br(nfp_prog, BR_BNE, insn->off, 0);\r\n}\r\nif (imm >> 32) {\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(insn->dst_reg * 2 + 1), ALU_OP_AND, tmp_reg);\r\nemit_br(nfp_prog, BR_BNE, insn->off, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int jne_imm(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nu64 imm = insn->imm;\r\nu32 tmp_reg;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nif (!imm) {\r\nemit_alu(nfp_prog, reg_none(), reg_a(insn->dst_reg * 2),\r\nALU_OP_OR, reg_b(insn->dst_reg * 2 + 1));\r\nemit_br(nfp_prog, BR_BNE, insn->off, 0);\r\n}\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm & ~0U, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(insn->dst_reg * 2), ALU_OP_XOR, tmp_reg);\r\nemit_br(nfp_prog, BR_BNE, insn->off, 0);\r\ntmp_reg = ur_load_imm_any(nfp_prog, imm >> 32, imm_b(nfp_prog));\r\nemit_alu(nfp_prog, reg_none(),\r\nreg_a(insn->dst_reg * 2 + 1), ALU_OP_XOR, tmp_reg);\r\nemit_br(nfp_prog, BR_BNE, insn->off, 0);\r\nreturn 0;\r\n}\r\nstatic int jeq_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nconst struct bpf_insn *insn = &meta->insn;\r\nif (insn->off < 0)\r\nreturn -ENOTSUPP;\r\nemit_alu(nfp_prog, imm_a(nfp_prog), reg_a(insn->dst_reg * 2),\r\nALU_OP_XOR, reg_b(insn->src_reg * 2));\r\nemit_alu(nfp_prog, imm_b(nfp_prog), reg_a(insn->dst_reg * 2 + 1),\r\nALU_OP_XOR, reg_b(insn->src_reg * 2 + 1));\r\nemit_alu(nfp_prog, reg_none(),\r\nimm_a(nfp_prog), ALU_OP_OR, imm_b(nfp_prog));\r\nemit_br(nfp_prog, BR_BEQ, insn->off, 0);\r\nreturn 0;\r\n}\r\nstatic int jgt_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_cmp_reg(nfp_prog, meta, BR_BLO, false);\r\n}\r\nstatic int jge_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_cmp_reg(nfp_prog, meta, BR_BHS, true);\r\n}\r\nstatic int jset_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_test_reg(nfp_prog, meta, ALU_OP_AND, BR_BNE);\r\n}\r\nstatic int jne_reg(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nreturn wrp_test_reg(nfp_prog, meta, ALU_OP_XOR, BR_BNE);\r\n}\r\nstatic int goto_out(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta)\r\n{\r\nwrp_br_special(nfp_prog, BR_UNC, OP_BR_GO_OUT);\r\nreturn 0;\r\n}\r\nstatic void br_set_offset(u64 *instr, u16 offset)\r\n{\r\nu16 addr_lo, addr_hi;\r\naddr_lo = offset & (OP_BR_ADDR_LO >> __bf_shf(OP_BR_ADDR_LO));\r\naddr_hi = offset != addr_lo;\r\n*instr &= ~(OP_BR_ADDR_HI | OP_BR_ADDR_LO);\r\n*instr |= FIELD_PREP(OP_BR_ADDR_HI, addr_hi);\r\n*instr |= FIELD_PREP(OP_BR_ADDR_LO, addr_lo);\r\n}\r\nstatic int nfp_fixup_branches(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta, *next;\r\nu32 off, br_idx;\r\nu32 idx;\r\nnfp_for_each_insn_walk2(nfp_prog, meta, next) {\r\nif (meta->skip)\r\ncontinue;\r\nif (BPF_CLASS(meta->insn.code) != BPF_JMP)\r\ncontinue;\r\nbr_idx = nfp_prog_offset_to_index(nfp_prog, next->off) - 1;\r\nif (!nfp_is_br(nfp_prog->prog[br_idx])) {\r\npr_err("Fixup found block not ending in branch %d %02x %016llx!!\n",\r\nbr_idx, meta->insn.code, nfp_prog->prog[br_idx]);\r\nreturn -ELOOP;\r\n}\r\nif (FIELD_GET(OP_BR_SPECIAL, nfp_prog->prog[br_idx]))\r\ncontinue;\r\noff = meta->insn.off;\r\nif (!off) {\r\npr_err("Fixup found zero offset!!\n");\r\nreturn -ELOOP;\r\n}\r\nwhile (off && nfp_meta_has_next(nfp_prog, next)) {\r\nnext = nfp_meta_next(next);\r\noff--;\r\n}\r\nif (off) {\r\npr_err("Fixup found too large jump!! %d\n", off);\r\nreturn -ELOOP;\r\n}\r\nif (next->skip) {\r\npr_err("Branch landing on removed instruction!!\n");\r\nreturn -ELOOP;\r\n}\r\nfor (idx = nfp_prog_offset_to_index(nfp_prog, meta->off);\r\nidx <= br_idx; idx++) {\r\nif (!nfp_is_br(nfp_prog->prog[idx]))\r\ncontinue;\r\nbr_set_offset(&nfp_prog->prog[idx], next->off);\r\n}\r\n}\r\nfor (br_idx = 0; br_idx < nfp_prog->prog_len; br_idx++) {\r\nenum br_special special;\r\nif ((nfp_prog->prog[br_idx] & OP_BR_BASE_MASK) != OP_BR_BASE)\r\ncontinue;\r\nspecial = FIELD_GET(OP_BR_SPECIAL, nfp_prog->prog[br_idx]);\r\nswitch (special) {\r\ncase OP_BR_NORMAL:\r\nbreak;\r\ncase OP_BR_GO_OUT:\r\nbr_set_offset(&nfp_prog->prog[br_idx],\r\nnfp_prog->tgt_out);\r\nbreak;\r\ncase OP_BR_GO_ABORT:\r\nbr_set_offset(&nfp_prog->prog[br_idx],\r\nnfp_prog->tgt_abort);\r\nbreak;\r\n}\r\nnfp_prog->prog[br_idx] &= ~OP_BR_SPECIAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfp_intro(struct nfp_prog *nfp_prog)\r\n{\r\nemit_alu(nfp_prog, pkt_reg(nfp_prog),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_PKT);\r\n}\r\nstatic void nfp_outro_tc_legacy(struct nfp_prog *nfp_prog)\r\n{\r\nconst u8 act2code[] = {\r\n[NN_ACT_TC_DROP] = 0x22,\r\n[NN_ACT_TC_REDIR] = 0x24\r\n};\r\nnfp_prog->tgt_abort = nfp_prog_current_offset(nfp_prog);\r\nwrp_immed(nfp_prog, reg_both(0), 0);\r\nnfp_prog->tgt_out = nfp_prog_current_offset(nfp_prog);\r\nemit_br_byte_neq(nfp_prog, reg_b(0), 0xff, 0, nfp_prog->tgt_done, 2);\r\nemit_alu(nfp_prog, reg_a(0),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_FLAGS);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(0x11), SHF_SC_L_SHF, 16);\r\nemit_br(nfp_prog, BR_UNC, nfp_prog->tgt_done, 1);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(act2code[nfp_prog->act]),\r\nSHF_SC_L_SHF, 16);\r\n}\r\nstatic void nfp_outro_tc_da(struct nfp_prog *nfp_prog)\r\n{\r\nnfp_prog->tgt_abort = nfp_prog_current_offset(nfp_prog);\r\nemit_br_def(nfp_prog, nfp_prog->tgt_done, 2);\r\nemit_alu(nfp_prog, reg_a(0),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_FLAGS);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(0x11), SHF_SC_L_SHF, 16);\r\nnfp_prog->tgt_out = nfp_prog_current_offset(nfp_prog);\r\nemit_alu(nfp_prog, reg_none(), reg_imm(7), ALU_OP_SUB, reg_b(0));\r\nemit_br(nfp_prog, BR_BLO, nfp_prog->tgt_abort, 0);\r\nemit_alu(nfp_prog, reg_a(0),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_FLAGS);\r\nwrp_immed(nfp_prog, reg_b(2), 0x41221211);\r\nwrp_immed(nfp_prog, reg_b(3), 0x41001211);\r\nemit_shf(nfp_prog, reg_a(1),\r\nreg_none(), SHF_OP_NONE, reg_b(0), SHF_SC_L_SHF, 2);\r\nemit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\r\nemit_shf(nfp_prog, reg_a(2),\r\nreg_imm(0xf), SHF_OP_AND, reg_b(2), SHF_SC_R_SHF, 0);\r\nemit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\r\nemit_shf(nfp_prog, reg_b(2),\r\nreg_imm(0xf), SHF_OP_AND, reg_b(3), SHF_SC_R_SHF, 0);\r\nemit_br_def(nfp_prog, nfp_prog->tgt_done, 2);\r\nemit_shf(nfp_prog, reg_b(2),\r\nreg_a(2), SHF_OP_OR, reg_b(2), SHF_SC_L_SHF, 4);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_b(2), SHF_SC_L_SHF, 16);\r\n}\r\nstatic void nfp_outro_xdp(struct nfp_prog *nfp_prog)\r\n{\r\nnfp_prog->tgt_abort = nfp_prog_current_offset(nfp_prog);\r\nemit_br_def(nfp_prog, nfp_prog->tgt_done, 2);\r\nemit_alu(nfp_prog, reg_a(0),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_FLAGS);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_imm(0x82), SHF_SC_L_SHF, 16);\r\nnfp_prog->tgt_out = nfp_prog_current_offset(nfp_prog);\r\nemit_alu(nfp_prog, reg_none(), reg_imm(3), ALU_OP_SUB, reg_b(0));\r\nemit_br(nfp_prog, BR_BLO, nfp_prog->tgt_abort, 0);\r\nwrp_immed(nfp_prog, reg_b(2), 0x44112282);\r\nemit_shf(nfp_prog, reg_a(1),\r\nreg_none(), SHF_OP_NONE, reg_b(0), SHF_SC_L_SHF, 3);\r\nemit_alu(nfp_prog, reg_none(), reg_a(1), ALU_OP_OR, reg_imm(0));\r\nemit_shf(nfp_prog, reg_b(2),\r\nreg_imm(0xff), SHF_OP_AND, reg_b(2), SHF_SC_R_SHF, 0);\r\nemit_br_def(nfp_prog, nfp_prog->tgt_done, 2);\r\nemit_alu(nfp_prog, reg_a(0),\r\nreg_none(), ALU_OP_NONE, NFP_BPF_ABI_FLAGS);\r\nemit_ld_field(nfp_prog, reg_a(0), 0xc, reg_b(2), SHF_SC_L_SHF, 16);\r\n}\r\nstatic void nfp_outro(struct nfp_prog *nfp_prog)\r\n{\r\nswitch (nfp_prog->act) {\r\ncase NN_ACT_DIRECT:\r\nnfp_outro_tc_da(nfp_prog);\r\nbreak;\r\ncase NN_ACT_TC_DROP:\r\ncase NN_ACT_TC_REDIR:\r\nnfp_outro_tc_legacy(nfp_prog);\r\nbreak;\r\ncase NN_ACT_XDP:\r\nnfp_outro_xdp(nfp_prog);\r\nbreak;\r\n}\r\n}\r\nstatic int nfp_translate(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta;\r\nint err;\r\nnfp_intro(nfp_prog);\r\nif (nfp_prog->error)\r\nreturn nfp_prog->error;\r\nlist_for_each_entry(meta, &nfp_prog->insns, l) {\r\ninstr_cb_t cb = instr_cb[meta->insn.code];\r\nmeta->off = nfp_prog_current_offset(nfp_prog);\r\nif (meta->skip) {\r\nnfp_prog->n_translated++;\r\ncontinue;\r\n}\r\nif (nfp_meta_has_prev(nfp_prog, meta) &&\r\nnfp_meta_prev(meta)->double_cb)\r\ncb = nfp_meta_prev(meta)->double_cb;\r\nif (!cb)\r\nreturn -ENOENT;\r\nerr = cb(nfp_prog, meta);\r\nif (err)\r\nreturn err;\r\nnfp_prog->n_translated++;\r\n}\r\nnfp_outro(nfp_prog);\r\nif (nfp_prog->error)\r\nreturn nfp_prog->error;\r\nreturn nfp_fixup_branches(nfp_prog);\r\n}\r\nstatic int\r\nnfp_prog_prepare(struct nfp_prog *nfp_prog, const struct bpf_insn *prog,\r\nunsigned int cnt)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < cnt; i++) {\r\nstruct nfp_insn_meta *meta;\r\nmeta = kzalloc(sizeof(*meta), GFP_KERNEL);\r\nif (!meta)\r\nreturn -ENOMEM;\r\nmeta->insn = prog[i];\r\nmeta->n = i;\r\nlist_add_tail(&meta->l, &nfp_prog->insns);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfp_bpf_opt_reg_init(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta;\r\nlist_for_each_entry(meta, &nfp_prog->insns, l) {\r\nstruct bpf_insn insn = meta->insn;\r\nif (insn.code == (BPF_ALU64 | BPF_XOR | BPF_X) &&\r\ninsn.src_reg == insn.dst_reg)\r\ncontinue;\r\nif (insn.code == (BPF_ALU64 | BPF_MOV | BPF_X) &&\r\ninsn.src_reg == 1 && insn.dst_reg == 6)\r\nmeta->skip = true;\r\nif (!meta->skip)\r\nreturn;\r\n}\r\n}\r\nstatic int nfp_bpf_opt_reg_rename(struct nfp_prog *nfp_prog)\r\n{\r\nbool reg_used[MAX_BPF_REG] = {};\r\nu8 tgt_reg[MAX_BPF_REG] = {};\r\nstruct nfp_insn_meta *meta;\r\nunsigned int i, j;\r\nlist_for_each_entry(meta, &nfp_prog->insns, l) {\r\nif (meta->skip)\r\ncontinue;\r\nreg_used[meta->insn.src_reg] = true;\r\nreg_used[meta->insn.dst_reg] = true;\r\n}\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(tgt_reg); i++) {\r\nif (!reg_used[i])\r\ncontinue;\r\ntgt_reg[i] = j++;\r\n}\r\nnfp_prog->num_regs = j;\r\nlist_for_each_entry(meta, &nfp_prog->insns, l) {\r\nmeta->insn.src_reg = tgt_reg[meta->insn.src_reg];\r\nmeta->insn.dst_reg = tgt_reg[meta->insn.dst_reg];\r\n}\r\nreturn 0;\r\n}\r\nstatic void nfp_bpf_opt_ld_mask(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta1, *meta2;\r\nconst s32 exp_mask[] = {\r\n[BPF_B] = 0x000000ffU,\r\n[BPF_H] = 0x0000ffffU,\r\n[BPF_W] = 0xffffffffU,\r\n};\r\nnfp_for_each_insn_walk2(nfp_prog, meta1, meta2) {\r\nstruct bpf_insn insn, next;\r\ninsn = meta1->insn;\r\nnext = meta2->insn;\r\nif (BPF_CLASS(insn.code) != BPF_LD)\r\ncontinue;\r\nif (BPF_MODE(insn.code) != BPF_ABS &&\r\nBPF_MODE(insn.code) != BPF_IND)\r\ncontinue;\r\nif (next.code != (BPF_ALU64 | BPF_AND | BPF_K))\r\ncontinue;\r\nif (!exp_mask[BPF_SIZE(insn.code)])\r\ncontinue;\r\nif (exp_mask[BPF_SIZE(insn.code)] != next.imm)\r\ncontinue;\r\nif (next.src_reg || next.dst_reg)\r\ncontinue;\r\nmeta2->skip = true;\r\n}\r\n}\r\nstatic void nfp_bpf_opt_ld_shift(struct nfp_prog *nfp_prog)\r\n{\r\nstruct nfp_insn_meta *meta1, *meta2, *meta3;\r\nnfp_for_each_insn_walk3(nfp_prog, meta1, meta2, meta3) {\r\nstruct bpf_insn insn, next1, next2;\r\ninsn = meta1->insn;\r\nnext1 = meta2->insn;\r\nnext2 = meta3->insn;\r\nif (BPF_CLASS(insn.code) != BPF_LD)\r\ncontinue;\r\nif (BPF_MODE(insn.code) != BPF_ABS &&\r\nBPF_MODE(insn.code) != BPF_IND)\r\ncontinue;\r\nif (BPF_SIZE(insn.code) != BPF_W)\r\ncontinue;\r\nif (!(next1.code == (BPF_LSH | BPF_K | BPF_ALU64) &&\r\nnext2.code == (BPF_RSH | BPF_K | BPF_ALU64)) &&\r\n!(next1.code == (BPF_RSH | BPF_K | BPF_ALU64) &&\r\nnext2.code == (BPF_LSH | BPF_K | BPF_ALU64)))\r\ncontinue;\r\nif (next1.src_reg || next1.dst_reg ||\r\nnext2.src_reg || next2.dst_reg)\r\ncontinue;\r\nif (next1.imm != 0x20 || next2.imm != 0x20)\r\ncontinue;\r\nmeta2->skip = true;\r\nmeta3->skip = true;\r\n}\r\n}\r\nstatic int nfp_bpf_optimize(struct nfp_prog *nfp_prog)\r\n{\r\nint ret;\r\nnfp_bpf_opt_reg_init(nfp_prog);\r\nret = nfp_bpf_opt_reg_rename(nfp_prog);\r\nif (ret)\r\nreturn ret;\r\nnfp_bpf_opt_ld_mask(nfp_prog);\r\nnfp_bpf_opt_ld_shift(nfp_prog);\r\nreturn 0;\r\n}\r\nint\r\nnfp_bpf_jit(struct bpf_prog *filter, void *prog_mem,\r\nenum nfp_bpf_action_type act,\r\nunsigned int prog_start, unsigned int prog_done,\r\nunsigned int prog_sz, struct nfp_bpf_result *res)\r\n{\r\nstruct nfp_prog *nfp_prog;\r\nint ret;\r\nnfp_prog = kzalloc(sizeof(*nfp_prog), GFP_KERNEL);\r\nif (!nfp_prog)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&nfp_prog->insns);\r\nnfp_prog->act = act;\r\nnfp_prog->start_off = prog_start;\r\nnfp_prog->tgt_done = prog_done;\r\nret = nfp_prog_prepare(nfp_prog, filter->insnsi, filter->len);\r\nif (ret)\r\ngoto out;\r\nret = nfp_prog_verify(nfp_prog, filter);\r\nif (ret)\r\ngoto out;\r\nret = nfp_bpf_optimize(nfp_prog);\r\nif (ret)\r\ngoto out;\r\nif (nfp_prog->num_regs <= 7)\r\nnfp_prog->regs_per_thread = 16;\r\nelse\r\nnfp_prog->regs_per_thread = 32;\r\nnfp_prog->prog = prog_mem;\r\nnfp_prog->__prog_alloc_len = prog_sz;\r\nret = nfp_translate(nfp_prog);\r\nif (ret) {\r\npr_err("Translation failed with error %d (translated: %u)\n",\r\nret, nfp_prog->n_translated);\r\nret = -EINVAL;\r\n}\r\nres->n_instr = nfp_prog->prog_len;\r\nres->dense_mode = nfp_prog->num_regs <= 7;\r\nout:\r\nnfp_prog_free(nfp_prog);\r\nreturn ret;\r\n}
