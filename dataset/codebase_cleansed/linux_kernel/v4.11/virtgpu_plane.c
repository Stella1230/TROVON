static void virtio_gpu_plane_destroy(struct drm_plane *plane)\r\n{\r\nkfree(plane);\r\n}\r\nstatic int virtio_gpu_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_primary_plane_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_output *output = NULL;\r\nstruct virtio_gpu_framebuffer *vgfb;\r\nstruct virtio_gpu_object *bo;\r\nuint32_t handle;\r\nif (plane->state->crtc)\r\noutput = drm_crtc_to_virtio_gpu_output(plane->state->crtc);\r\nif (old_state->crtc)\r\noutput = drm_crtc_to_virtio_gpu_output(old_state->crtc);\r\nif (WARN_ON(!output))\r\nreturn;\r\nif (plane->state->fb) {\r\nvgfb = to_virtio_gpu_framebuffer(plane->state->fb);\r\nbo = gem_to_virtio_gpu_obj(vgfb->obj);\r\nhandle = bo->hw_res_handle;\r\nif (bo->dumb) {\r\nvirtio_gpu_cmd_transfer_to_host_2d\r\n(vgdev, handle, 0,\r\ncpu_to_le32(plane->state->src_w >> 16),\r\ncpu_to_le32(plane->state->src_h >> 16),\r\ncpu_to_le32(plane->state->src_x >> 16),\r\ncpu_to_le32(plane->state->src_y >> 16), NULL);\r\n}\r\n} else {\r\nhandle = 0;\r\n}\r\nDRM_DEBUG("handle 0x%x, crtc %dx%d+%d+%d, src %dx%d+%d+%d\n", handle,\r\nplane->state->crtc_w, plane->state->crtc_h,\r\nplane->state->crtc_x, plane->state->crtc_y,\r\nplane->state->src_w >> 16,\r\nplane->state->src_h >> 16,\r\nplane->state->src_x >> 16,\r\nplane->state->src_y >> 16);\r\nvirtio_gpu_cmd_set_scanout(vgdev, output->index, handle,\r\nplane->state->src_w >> 16,\r\nplane->state->src_h >> 16,\r\nplane->state->src_x >> 16,\r\nplane->state->src_y >> 16);\r\nvirtio_gpu_cmd_resource_flush(vgdev, handle,\r\nplane->state->src_x >> 16,\r\nplane->state->src_y >> 16,\r\nplane->state->src_w >> 16,\r\nplane->state->src_h >> 16);\r\n}\r\nstatic void virtio_gpu_cursor_plane_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_output *output = NULL;\r\nstruct virtio_gpu_framebuffer *vgfb;\r\nstruct virtio_gpu_fence *fence = NULL;\r\nstruct virtio_gpu_object *bo = NULL;\r\nuint32_t handle;\r\nint ret = 0;\r\nif (plane->state->crtc)\r\noutput = drm_crtc_to_virtio_gpu_output(plane->state->crtc);\r\nif (old_state->crtc)\r\noutput = drm_crtc_to_virtio_gpu_output(old_state->crtc);\r\nif (WARN_ON(!output))\r\nreturn;\r\nif (plane->state->fb) {\r\nvgfb = to_virtio_gpu_framebuffer(plane->state->fb);\r\nbo = gem_to_virtio_gpu_obj(vgfb->obj);\r\nhandle = bo->hw_res_handle;\r\n} else {\r\nhandle = 0;\r\n}\r\nif (bo && bo->dumb && (plane->state->fb != old_state->fb)) {\r\nvirtio_gpu_cmd_transfer_to_host_2d\r\n(vgdev, handle, 0,\r\ncpu_to_le32(plane->state->crtc_w),\r\ncpu_to_le32(plane->state->crtc_h),\r\n0, 0, &fence);\r\nret = virtio_gpu_object_reserve(bo, false);\r\nif (!ret) {\r\nreservation_object_add_excl_fence(bo->tbo.resv,\r\n&fence->f);\r\ndma_fence_put(&fence->f);\r\nfence = NULL;\r\nvirtio_gpu_object_unreserve(bo);\r\nvirtio_gpu_object_wait(bo, false);\r\n}\r\n}\r\nif (plane->state->fb != old_state->fb) {\r\nDRM_DEBUG("update, handle %d, pos +%d+%d, hot %d,%d\n", handle,\r\nplane->state->crtc_x,\r\nplane->state->crtc_y,\r\nplane->state->fb ? plane->state->fb->hot_x : 0,\r\nplane->state->fb ? plane->state->fb->hot_y : 0);\r\noutput->cursor.hdr.type =\r\ncpu_to_le32(VIRTIO_GPU_CMD_UPDATE_CURSOR);\r\noutput->cursor.resource_id = cpu_to_le32(handle);\r\nif (plane->state->fb) {\r\noutput->cursor.hot_x =\r\ncpu_to_le32(plane->state->fb->hot_x);\r\noutput->cursor.hot_y =\r\ncpu_to_le32(plane->state->fb->hot_y);\r\n} else {\r\noutput->cursor.hot_x = cpu_to_le32(0);\r\noutput->cursor.hot_y = cpu_to_le32(0);\r\n}\r\n} else {\r\nDRM_DEBUG("move +%d+%d\n",\r\nplane->state->crtc_x,\r\nplane->state->crtc_y);\r\noutput->cursor.hdr.type =\r\ncpu_to_le32(VIRTIO_GPU_CMD_MOVE_CURSOR);\r\n}\r\noutput->cursor.pos.x = cpu_to_le32(plane->state->crtc_x);\r\noutput->cursor.pos.y = cpu_to_le32(plane->state->crtc_y);\r\nvirtio_gpu_cursor_ping(vgdev, output);\r\n}\r\nstruct drm_plane *virtio_gpu_plane_init(struct virtio_gpu_device *vgdev,\r\nenum drm_plane_type type,\r\nint index)\r\n{\r\nstruct drm_device *dev = vgdev->ddev;\r\nconst struct drm_plane_helper_funcs *funcs;\r\nstruct drm_plane *plane;\r\nconst uint32_t *formats;\r\nint ret, nformats;\r\nplane = kzalloc(sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (type == DRM_PLANE_TYPE_CURSOR) {\r\nformats = virtio_gpu_cursor_formats;\r\nnformats = ARRAY_SIZE(virtio_gpu_cursor_formats);\r\nfuncs = &virtio_gpu_cursor_helper_funcs;\r\n} else {\r\nformats = virtio_gpu_formats;\r\nnformats = ARRAY_SIZE(virtio_gpu_formats);\r\nfuncs = &virtio_gpu_primary_helper_funcs;\r\n}\r\nret = drm_universal_plane_init(dev, plane, 1 << index,\r\n&virtio_gpu_plane_funcs,\r\nformats, nformats,\r\ntype, NULL);\r\nif (ret)\r\ngoto err_plane_init;\r\ndrm_plane_helper_add(plane, funcs);\r\nreturn plane;\r\nerr_plane_init:\r\nkfree(plane);\r\nreturn ERR_PTR(ret);\r\n}
