static int rockchip_saradc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct rockchip_saradc *info = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nreinit_completion(&info->completion);\r\nwritel_relaxed(8, info->regs + SARADC_DLY_PU_SOC);\r\nwritel(SARADC_CTRL_POWER_CTRL\r\n| (chan->channel & SARADC_CTRL_CHN_MASK)\r\n| SARADC_CTRL_IRQ_ENABLE,\r\ninfo->regs + SARADC_CTRL);\r\nif (!wait_for_completion_timeout(&info->completion,\r\nSARADC_TIMEOUT)) {\r\nwritel_relaxed(0, info->regs + SARADC_CTRL);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -ETIMEDOUT;\r\n}\r\n*val = info->last_val;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = regulator_get_voltage(info->vref);\r\nif (ret < 0) {\r\ndev_err(&indio_dev->dev, "failed to get voltage\n");\r\nreturn ret;\r\n}\r\n*val = ret / 1000;\r\n*val2 = info->data->num_bits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic irqreturn_t rockchip_saradc_isr(int irq, void *dev_id)\r\n{\r\nstruct rockchip_saradc *info = (struct rockchip_saradc *)dev_id;\r\ninfo->last_val = readl_relaxed(info->regs + SARADC_DATA);\r\ninfo->last_val &= GENMASK(info->data->num_bits - 1, 0);\r\nwritel_relaxed(0, info->regs + SARADC_CTRL);\r\ncomplete(&info->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rockchip_saradc_reset_controller(struct reset_control *reset)\r\n{\r\nreset_control_assert(reset);\r\nusleep_range(10, 20);\r\nreset_control_deassert(reset);\r\n}\r\nstatic int rockchip_saradc_probe(struct platform_device *pdev)\r\n{\r\nstruct rockchip_saradc *info = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct iio_dev *indio_dev = NULL;\r\nstruct resource *mem;\r\nconst struct of_device_id *match;\r\nint ret;\r\nint irq;\r\nif (!np)\r\nreturn -ENODEV;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\nmatch = of_match_device(rockchip_saradc_match, &pdev->dev);\r\ninfo->data = match->data;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\ninfo->reset = devm_reset_control_get(&pdev->dev, "saradc-apb");\r\nif (IS_ERR(info->reset)) {\r\nret = PTR_ERR(info->reset);\r\nif (ret != -ENOENT)\r\nreturn ret;\r\ndev_dbg(&pdev->dev, "no reset control found\n");\r\ninfo->reset = NULL;\r\n}\r\ninit_completion(&info->completion);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, rockchip_saradc_isr,\r\n0, dev_name(&pdev->dev), info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed requesting irq %d\n", irq);\r\nreturn ret;\r\n}\r\ninfo->pclk = devm_clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(info->pclk)) {\r\ndev_err(&pdev->dev, "failed to get pclk\n");\r\nreturn PTR_ERR(info->pclk);\r\n}\r\ninfo->clk = devm_clk_get(&pdev->dev, "saradc");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to get adc clock\n");\r\nreturn PTR_ERR(info->clk);\r\n}\r\ninfo->vref = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(info->vref)) {\r\ndev_err(&pdev->dev, "failed to get regulator, %ld\n",\r\nPTR_ERR(info->vref));\r\nreturn PTR_ERR(info->vref);\r\n}\r\nif (info->reset)\r\nrockchip_saradc_reset_controller(info->reset);\r\nret = clk_set_rate(info->clk, info->data->clk_rate);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to set adc clk rate, %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_enable(info->vref);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable vref regulator\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(info->pclk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable pclk\n");\r\ngoto err_reg_voltage;\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable converter clock\n");\r\ngoto err_pclk;\r\n}\r\nplatform_set_drvdata(pdev, indio_dev);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &rockchip_saradc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = info->data->channels;\r\nindio_dev->num_channels = info->data->num_channels;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto err_clk;\r\nreturn 0;\r\nerr_clk:\r\nclk_disable_unprepare(info->clk);\r\nerr_pclk:\r\nclk_disable_unprepare(info->pclk);\r\nerr_reg_voltage:\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}\r\nstatic int rockchip_saradc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct rockchip_saradc *info = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nclk_disable_unprepare(info->clk);\r\nclk_disable_unprepare(info->pclk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int rockchip_saradc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct rockchip_saradc *info = iio_priv(indio_dev);\r\nclk_disable_unprepare(info->clk);\r\nclk_disable_unprepare(info->pclk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int rockchip_saradc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct rockchip_saradc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vref);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(info->pclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(info->clk);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}
