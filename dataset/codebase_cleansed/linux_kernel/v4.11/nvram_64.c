int nvram_write_os_partition(struct nvram_os_partition *part,\r\nchar *buff, int length,\r\nunsigned int err_type,\r\nunsigned int error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1)\r\nreturn -ESPIPE;\r\nif (length > part->size)\r\nlength = part->size;\r\ninfo.error_type = cpu_to_be32(err_type);\r\ninfo.seq_num = cpu_to_be32(error_log_cnt);\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\r\n&tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_write(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint nvram_read_partition(struct nvram_os_partition *part, char *buff,\r\nint length, unsigned int *err_type,\r\nunsigned int *error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1)\r\nreturn -1;\r\nif (length > part->size)\r\nlength = part->size;\r\ntmp_index = part->index;\r\nif (part->os_partition) {\r\nrc = ppc_md.nvram_read((char *)&info,\r\nsizeof(struct err_log_info),\r\n&tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_read (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = ppc_md.nvram_read(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_read (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif (part->os_partition) {\r\n*error_log_cnt = be32_to_cpu(info.seq_num);\r\n*err_type = be32_to_cpu(info.error_type);\r\n}\r\nreturn 0;\r\n}\r\nint __init nvram_init_os_partition(struct nvram_os_partition *part)\r\n{\r\nloff_t p;\r\nint size;\r\np = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\r\nif (p && size < part->min_size) {\r\npr_info("nvram: Found too small %s partition,"\r\n" removing it...\n", part->name);\r\nnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\r\np = 0;\r\n}\r\nif (!p) {\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\nif (p == -ENOSPC) {\r\npr_info("nvram: No room to create %s partition, "\r\n"deleting any obsolete OS partitions...\n",\r\npart->name);\r\nnvram_remove_partition(NULL, NVRAM_SIG_OS,\r\nnvram_os_partitions);\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\n}\r\n}\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find or create %s"\r\n" partition, err %d\n", part->name, (int)p);\r\nreturn -1;\r\n}\r\npart->index = p;\r\npart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\r\nreturn 0;\r\n}\r\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\r\nsize_t outlen)\r\n{\r\nint err, ret;\r\nret = -EIO;\r\nerr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\r\nMEM_LEVEL, Z_DEFAULT_STRATEGY);\r\nif (err != Z_OK)\r\ngoto error;\r\nstream.next_in = in;\r\nstream.avail_in = inlen;\r\nstream.total_in = 0;\r\nstream.next_out = out;\r\nstream.avail_out = outlen;\r\nstream.total_out = 0;\r\nerr = zlib_deflate(&stream, Z_FINISH);\r\nif (err != Z_STREAM_END)\r\ngoto error;\r\nerr = zlib_deflateEnd(&stream);\r\nif (err != Z_OK)\r\ngoto error;\r\nif (stream.total_out >= stream.total_in)\r\ngoto error;\r\nret = stream.total_out;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int zip_oops(size_t text_len)\r\n{\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\r\nint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\r\noops_data_sz);\r\nif (zipped_len < 0) {\r\npr_err("nvram: compression failed; returned %d\n", zipped_len);\r\npr_err("nvram: logging uncompressed oops/panic report\n");\r\nreturn -1;\r\n}\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(zipped_len);\r\noops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\r\nreturn 0;\r\n}\r\nstatic int nvram_pstore_open(struct pstore_info *psi)\r\n{\r\nread_type = -1;\r\nreturn 0;\r\n}\r\nstatic int nvram_pstore_write(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason,\r\nu64 *id, unsigned int part, int count,\r\nbool compressed, size_t size,\r\nstruct pstore_info *psi)\r\n{\r\nint rc;\r\nunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\r\nif (part > 1 || (type != PSTORE_TYPE_DMESG))\r\nreturn -1;\r\nif (clobbering_unread_rtas_event())\r\nreturn -1;\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(size);\r\noops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\r\nif (compressed)\r\nerr_type = ERR_TYPE_KERNEL_PANIC_GZ;\r\nrc = nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) (sizeof(*oops_hdr) + size), err_type, count);\r\nif (rc != 0)\r\nreturn rc;\r\n*id = part;\r\nreturn 0;\r\n}\r\nstatic ssize_t nvram_pstore_read(u64 *id, enum pstore_type_id *type,\r\nint *count, struct timespec *time, char **buf,\r\nbool *compressed, ssize_t *ecc_notice_size,\r\nstruct pstore_info *psi)\r\n{\r\nstruct oops_log_info *oops_hdr;\r\nunsigned int err_type, id_no, size = 0;\r\nstruct nvram_os_partition *part = NULL;\r\nchar *buff = NULL;\r\nint sig = 0;\r\nloff_t p;\r\nread_type++;\r\nswitch (nvram_type_ids[read_type]) {\r\ncase PSTORE_TYPE_DMESG:\r\npart = &oops_log_partition;\r\n*type = PSTORE_TYPE_DMESG;\r\nbreak;\r\ncase PSTORE_TYPE_PPC_COMMON:\r\nsig = NVRAM_SIG_SYS;\r\npart = &common_partition;\r\n*type = PSTORE_TYPE_PPC_COMMON;\r\n*id = PSTORE_TYPE_PPC_COMMON;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nbreak;\r\n#ifdef CONFIG_PPC_PSERIES\r\ncase PSTORE_TYPE_PPC_RTAS:\r\npart = &rtas_log_partition;\r\n*type = PSTORE_TYPE_PPC_RTAS;\r\ntime->tv_sec = last_rtas_event;\r\ntime->tv_nsec = 0;\r\nbreak;\r\ncase PSTORE_TYPE_PPC_OF:\r\nsig = NVRAM_SIG_OF;\r\npart = &of_config_partition;\r\n*type = PSTORE_TYPE_PPC_OF;\r\n*id = PSTORE_TYPE_PPC_OF;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_PPC_POWERNV\r\ncase PSTORE_TYPE_PPC_OPAL:\r\nsig = NVRAM_SIG_FW;\r\npart = &skiboot_partition;\r\n*type = PSTORE_TYPE_PPC_OPAL;\r\n*id = PSTORE_TYPE_PPC_OPAL;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!part->os_partition) {\r\np = nvram_find_partition(part->name, sig, &size);\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find partition %s, "\r\n"err %d\n", part->name, (int)p);\r\nreturn 0;\r\n}\r\npart->index = p;\r\npart->size = size;\r\n}\r\nbuff = kmalloc(part->size, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\r\nkfree(buff);\r\nreturn 0;\r\n}\r\n*count = 0;\r\nif (part->os_partition)\r\n*id = id_no;\r\nif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\r\nsize_t length, hdr_size;\r\noops_hdr = (struct oops_log_info *)buff;\r\nif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\r\nhdr_size = sizeof(u16);\r\nlength = be16_to_cpu(oops_hdr->version);\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\n} else {\r\nhdr_size = sizeof(*oops_hdr);\r\nlength = be16_to_cpu(oops_hdr->report_length);\r\ntime->tv_sec = be64_to_cpu(oops_hdr->timestamp);\r\ntime->tv_nsec = 0;\r\n}\r\n*buf = kmemdup(buff + hdr_size, length, GFP_KERNEL);\r\nkfree(buff);\r\nif (*buf == NULL)\r\nreturn -ENOMEM;\r\n*ecc_notice_size = 0;\r\nif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\r\n*compressed = true;\r\nelse\r\n*compressed = false;\r\nreturn length;\r\n}\r\n*buf = buff;\r\nreturn part->size;\r\n}\r\nstatic int nvram_pstore_init(void)\r\n{\r\nint rc = 0;\r\nif (machine_is(pseries)) {\r\nnvram_type_ids[2] = PSTORE_TYPE_PPC_RTAS;\r\nnvram_type_ids[3] = PSTORE_TYPE_PPC_OF;\r\n} else\r\nnvram_type_ids[2] = PSTORE_TYPE_PPC_OPAL;\r\nnvram_pstore_info.buf = oops_data;\r\nnvram_pstore_info.bufsize = oops_data_sz;\r\nspin_lock_init(&nvram_pstore_info.buf_lock);\r\nrc = pstore_register(&nvram_pstore_info);\r\nif (rc && (rc != -EPERM))\r\npr_err("nvram: pstore_register() failed, returned %d. "\r\n"Defaults to kmsg_dump\n", rc);\r\nreturn rc;\r\n}\r\nstatic int nvram_pstore_init(void)\r\n{\r\nreturn -1;\r\n}\r\nvoid __init nvram_init_oops_partition(int rtas_partition_exists)\r\n{\r\nint rc;\r\nrc = nvram_init_os_partition(&oops_log_partition);\r\nif (rc != 0) {\r\n#ifdef CONFIG_PPC_PSERIES\r\nif (!rtas_partition_exists) {\r\npr_err("nvram: Failed to initialize oops partition!");\r\nreturn;\r\n}\r\npr_notice("nvram: Using %s partition to log both"\r\n" RTAS errors and oops/panic reports\n",\r\nrtas_log_partition.name);\r\nmemcpy(&oops_log_partition, &rtas_log_partition,\r\nsizeof(rtas_log_partition));\r\n#else\r\npr_err("nvram: Failed to initialize oops partition!");\r\nreturn;\r\n#endif\r\n}\r\noops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\r\nif (!oops_buf) {\r\npr_err("nvram: No memory for %s partition\n",\r\noops_log_partition.name);\r\nreturn;\r\n}\r\noops_data = oops_buf + sizeof(struct oops_log_info);\r\noops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\r\nrc = nvram_pstore_init();\r\nif (!rc)\r\nreturn;\r\nbig_oops_buf_sz = (oops_data_sz * 100) / 45;\r\nbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\r\nif (big_oops_buf) {\r\nstream.workspace = kmalloc(zlib_deflate_workspacesize(\r\nWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\r\nif (!stream.workspace) {\r\npr_err("nvram: No memory for compression workspace; "\r\n"skipping compression of %s partition data\n",\r\noops_log_partition.name);\r\nkfree(big_oops_buf);\r\nbig_oops_buf = NULL;\r\n}\r\n} else {\r\npr_err("No memory for uncompressed %s data; "\r\n"skipping compression\n", oops_log_partition.name);\r\nstream.workspace = NULL;\r\n}\r\nrc = kmsg_dump_register(&nvram_kmsg_dumper);\r\nif (rc != 0) {\r\npr_err("nvram: kmsg_dump_register() failed; returned %d\n", rc);\r\nkfree(oops_buf);\r\nkfree(big_oops_buf);\r\nkfree(stream.workspace);\r\n}\r\n}\r\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\r\nenum kmsg_dump_reason reason)\r\n{\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\r\nstatic unsigned int oops_count = 0;\r\nstatic bool panicking = false;\r\nstatic DEFINE_SPINLOCK(lock);\r\nunsigned long flags;\r\nsize_t text_len;\r\nunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\r\nint rc = -1;\r\nswitch (reason) {\r\ncase KMSG_DUMP_RESTART:\r\ncase KMSG_DUMP_HALT:\r\ncase KMSG_DUMP_POWEROFF:\r\nreturn;\r\ncase KMSG_DUMP_OOPS:\r\nbreak;\r\ncase KMSG_DUMP_PANIC:\r\npanicking = true;\r\nbreak;\r\ncase KMSG_DUMP_EMERG:\r\nif (panicking)\r\nreturn;\r\nbreak;\r\ndefault:\r\npr_err("%s: ignoring unrecognized KMSG_DUMP_* reason %d\n",\r\n__func__, (int) reason);\r\nreturn;\r\n}\r\nif (clobbering_unread_rtas_event())\r\nreturn;\r\nif (!spin_trylock_irqsave(&lock, flags))\r\nreturn;\r\nif (big_oops_buf) {\r\nkmsg_dump_get_buffer(dumper, false,\r\nbig_oops_buf, big_oops_buf_sz, &text_len);\r\nrc = zip_oops(text_len);\r\n}\r\nif (rc != 0) {\r\nkmsg_dump_rewind(dumper);\r\nkmsg_dump_get_buffer(dumper, false,\r\noops_data, oops_data_sz, &text_len);\r\nerr_type = ERR_TYPE_KERNEL_PANIC;\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(text_len);\r\noops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\r\n}\r\n(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) (sizeof(*oops_hdr) + text_len), err_type,\r\n++oops_count);\r\nspin_unlock_irqrestore(&lock, flags);\r\n}\r\nstatic loff_t dev_nvram_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nif (ppc_md.nvram_size == NULL)\r\nreturn -ENODEV;\r\nreturn generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,\r\nppc_md.nvram_size());\r\n}\r\nstatic ssize_t dev_nvram_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nchar *tmp = NULL;\r\nssize_t size;\r\nif (!ppc_md.nvram_size) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsize = ppc_md.nvram_size();\r\nif (size < 0) {\r\nret = size;\r\ngoto out;\r\n}\r\nif (*ppos >= size) {\r\nret = 0;\r\ngoto out;\r\n}\r\ncount = min_t(size_t, count, size - *ppos);\r\ncount = min(count, PAGE_SIZE);\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = ppc_md.nvram_read(tmp, count, ppos);\r\nif (ret <= 0)\r\ngoto out;\r\nif (copy_to_user(buf, tmp, ret))\r\nret = -EFAULT;\r\nout:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic ssize_t dev_nvram_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t ret;\r\nchar *tmp = NULL;\r\nssize_t size;\r\nret = -ENODEV;\r\nif (!ppc_md.nvram_size)\r\ngoto out;\r\nret = 0;\r\nsize = ppc_md.nvram_size();\r\nif (*ppos >= size || size < 0)\r\ngoto out;\r\ncount = min_t(size_t, count, size - *ppos);\r\ncount = min(count, PAGE_SIZE);\r\nret = -ENOMEM;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp)\r\ngoto out;\r\nret = -EFAULT;\r\nif (copy_from_user(tmp, buf, count))\r\ngoto out;\r\nret = ppc_md.nvram_write(tmp, count, ppos);\r\nout:\r\nkfree(tmp);\r\nreturn ret;\r\n}\r\nstatic long dev_nvram_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch(cmd) {\r\n#ifdef CONFIG_PPC_PMAC\r\ncase OBSOLETE_PMAC_NVRAM_GET_OFFSET:\r\nprintk(KERN_WARNING "nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\n");\r\ncase IOC_NVRAM_GET_OFFSET: {\r\nint part, offset;\r\nif (!machine_is(powermac))\r\nreturn -EINVAL;\r\nif (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)\r\nreturn -EFAULT;\r\nif (part < pmac_nvram_OF || part > pmac_nvram_NR)\r\nreturn -EINVAL;\r\noffset = pmac_get_partition(part);\r\nif (offset < 0)\r\nreturn offset;\r\nif (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void __init nvram_print_partitions(char * label)\r\n{\r\nstruct nvram_partition * tmp_part;\r\nprintk(KERN_WARNING "--------%s---------\n", label);\r\nprintk(KERN_WARNING "indx\t\tsig\tchks\tlen\tname\n");\r\nlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\r\nprintk(KERN_WARNING "%4d \t%02x\t%02x\t%d\t%12.12s\n",\r\ntmp_part->index, tmp_part->header.signature,\r\ntmp_part->header.checksum, tmp_part->header.length,\r\ntmp_part->header.name);\r\n}\r\n}\r\nstatic int __init nvram_write_header(struct nvram_partition * part)\r\n{\r\nloff_t tmp_index;\r\nint rc;\r\nstruct nvram_header phead;\r\nmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\r\nphead.length = cpu_to_be16(phead.length);\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\r\nreturn rc;\r\n}\r\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\r\n{\r\nunsigned int c_sum, c_sum2;\r\nunsigned short *sp = (unsigned short *)p->name;\r\nc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\r\nc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\r\nc_sum2 = (c_sum >> 8) + (c_sum << 8);\r\nc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\r\nreturn c_sum;\r\n}\r\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\r\nconst char *name, int sig, const char *exceptions[])\r\n{\r\nif (part->header.signature != sig)\r\nreturn 0;\r\nif (name) {\r\nif (strncmp(name, part->header.name, 12))\r\nreturn 0;\r\n} else if (exceptions) {\r\nconst char **except;\r\nfor (except = exceptions; *except; except++) {\r\nif (!strncmp(*except, part->header.name, 12))\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint __init nvram_remove_partition(const char *name, int sig,\r\nconst char *exceptions[])\r\n{\r\nstruct nvram_partition *part, *prev, *tmp;\r\nint rc;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (!nvram_can_remove_partition(part, name, sig, exceptions))\r\ncontinue;\r\npart->header.signature = NVRAM_SIG_FREE;\r\nmemset(part->header.name, 'w', 12);\r\npart->header.checksum = nvram_checksum(&part->header);\r\nrc = nvram_write_header(part);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_remove_partition: nvram_write failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nprev = NULL;\r\nlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\r\nif (part->header.signature != NVRAM_SIG_FREE) {\r\nprev = NULL;\r\ncontinue;\r\n}\r\nif (prev) {\r\nprev->header.length += part->header.length;\r\nprev->header.checksum = nvram_checksum(&prev->header);\r\nrc = nvram_write_header(prev);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_remove_partition: nvram_write failed (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlist_del(&part->partition);\r\nkfree(part);\r\n} else\r\nprev = part;\r\n}\r\nreturn 0;\r\n}\r\nloff_t __init nvram_create_partition(const char *name, int sig,\r\nint req_size, int min_size)\r\n{\r\nstruct nvram_partition *part;\r\nstruct nvram_partition *new_part;\r\nstruct nvram_partition *free_part = NULL;\r\nstatic char nv_init_vals[16];\r\nloff_t tmp_index;\r\nlong size = 0;\r\nint rc;\r\nreq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\r\nmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\r\nif (min_size == 0)\r\nmin_size = req_size;\r\nif (min_size > req_size)\r\nreturn -EINVAL;\r\nreq_size += 1;\r\nmin_size += 1;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (part->header.signature != NVRAM_SIG_FREE)\r\ncontinue;\r\nif (part->header.length >= req_size) {\r\nsize = req_size;\r\nfree_part = part;\r\nbreak;\r\n}\r\nif (part->header.length > size &&\r\npart->header.length >= min_size) {\r\nsize = part->header.length;\r\nfree_part = part;\r\n}\r\n}\r\nif (!size)\r\nreturn -ENOSPC;\r\nnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\r\nif (!new_part) {\r\npr_err("%s: kmalloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nnew_part->index = free_part->index;\r\nnew_part->header.signature = sig;\r\nnew_part->header.length = size;\r\nstrncpy(new_part->header.name, name, 12);\r\nnew_part->header.checksum = nvram_checksum(&new_part->header);\r\nrc = nvram_write_header(new_part);\r\nif (rc <= 0) {\r\npr_err("%s: nvram_write_header failed (%d)\n", __func__, rc);\r\nkfree(new_part);\r\nreturn rc;\r\n}\r\nlist_add_tail(&new_part->partition, &free_part->partition);\r\nif (free_part->header.length > size) {\r\nfree_part->index += size * NVRAM_BLOCK_LEN;\r\nfree_part->header.length -= size;\r\nfree_part->header.checksum = nvram_checksum(&free_part->header);\r\nrc = nvram_write_header(free_part);\r\nif (rc <= 0) {\r\npr_err("%s: nvram_write_header failed (%d)\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\n} else {\r\nlist_del(&free_part->partition);\r\nkfree(free_part);\r\n}\r\nfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\r\ntmp_index < ((size - 1) * NVRAM_BLOCK_LEN);\r\ntmp_index += NVRAM_BLOCK_LEN) {\r\nrc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: nvram_write failed (%d)\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\n}\r\nreturn new_part->index + NVRAM_HEADER_LEN;\r\n}\r\nint nvram_get_partition_size(loff_t data_index)\r\n{\r\nstruct nvram_partition *part;\r\nlist_for_each_entry(part, &nvram_partitions, partition) {\r\nif (part->index + NVRAM_HEADER_LEN == data_index)\r\nreturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\r\n}\r\nreturn -1;\r\n}\r\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\r\n{\r\nstruct nvram_partition *p;\r\nlist_for_each_entry(p, &nvram_partitions, partition) {\r\nif (p->header.signature == sig &&\r\n(!name || !strncmp(p->header.name, name, 12))) {\r\nif (out_size)\r\n*out_size = (p->header.length - 1) *\r\nNVRAM_BLOCK_LEN;\r\nreturn p->index + NVRAM_HEADER_LEN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __init nvram_scan_partitions(void)\r\n{\r\nloff_t cur_index = 0;\r\nstruct nvram_header phead;\r\nstruct nvram_partition * tmp_part;\r\nunsigned char c_sum;\r\nchar * header;\r\nint total_size;\r\nint err;\r\nif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\r\nreturn -ENODEV;\r\ntotal_size = ppc_md.nvram_size();\r\nheader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\r\nif (!header) {\r\nprintk(KERN_ERR "nvram_scan_partitions: Failed kmalloc\n");\r\nreturn -ENOMEM;\r\n}\r\nwhile (cur_index < total_size) {\r\nerr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\r\nif (err != NVRAM_HEADER_LEN) {\r\nprintk(KERN_ERR "nvram_scan_partitions: Error parsing "\r\n"nvram partitions\n");\r\ngoto out;\r\n}\r\ncur_index -= NVRAM_HEADER_LEN;\r\nmemcpy(&phead, header, NVRAM_HEADER_LEN);\r\nphead.length = be16_to_cpu(phead.length);\r\nerr = 0;\r\nc_sum = nvram_checksum(&phead);\r\nif (c_sum != phead.checksum) {\r\nprintk(KERN_WARNING "WARNING: nvram partition checksum"\r\n" was %02x, should be %02x!\n",\r\nphead.checksum, c_sum);\r\nprintk(KERN_WARNING "Terminating nvram partition scan\n");\r\ngoto out;\r\n}\r\nif (!phead.length) {\r\nprintk(KERN_WARNING "WARNING: nvram corruption "\r\n"detected: 0-length partition\n");\r\ngoto out;\r\n}\r\ntmp_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!tmp_part) {\r\nprintk(KERN_ERR "nvram_scan_partitions: kmalloc failed\n");\r\ngoto out;\r\n}\r\nmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\r\ntmp_part->index = cur_index;\r\nlist_add_tail(&tmp_part->partition, &nvram_partitions);\r\ncur_index += phead.length * NVRAM_BLOCK_LEN;\r\n}\r\nerr = 0;\r\n#ifdef DEBUG_NVRAM\r\nnvram_print_partitions("NVRAM Partitions");\r\n#endif\r\nout:\r\nkfree(header);\r\nreturn err;\r\n}\r\nstatic int __init nvram_init(void)\r\n{\r\nint rc;\r\nBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\r\nif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\r\nreturn -ENODEV;\r\nrc = misc_register(&nvram_dev);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "nvram_init: failed to register device\n");\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}
