void __init paging_init(void)\r\n{\r\npgd_t *pg_dir;\r\npte_t *pg_table;\r\nunsigned long address, size;\r\nunsigned long next_pgtable, bootmem_end;\r\nunsigned long zones_size[MAX_NR_ZONES];\r\nenum zone_type zone;\r\nint i;\r\nempty_zero_page = (void *) alloc_bootmem_pages(PAGE_SIZE);\r\nmemset((void *) empty_zero_page, 0, PAGE_SIZE);\r\npg_dir = swapper_pg_dir;\r\nmemset(swapper_pg_dir, 0, sizeof(swapper_pg_dir));\r\nsize = num_pages * sizeof(pte_t);\r\nsize = (size + PAGE_SIZE) & ~(PAGE_SIZE-1);\r\nnext_pgtable = (unsigned long) alloc_bootmem_pages(size);\r\nbootmem_end = (next_pgtable + size + PAGE_SIZE) & PAGE_MASK;\r\npg_dir += PAGE_OFFSET >> PGDIR_SHIFT;\r\naddress = PAGE_OFFSET;\r\nwhile (address < (unsigned long)high_memory) {\r\npg_table = (pte_t *) next_pgtable;\r\nnext_pgtable += PTRS_PER_PTE * sizeof(pte_t);\r\npgd_val(*pg_dir) = (unsigned long) pg_table;\r\npg_dir++;\r\nfor (i = 0; i < PTRS_PER_PTE; ++i, ++pg_table) {\r\npte_t pte = pfn_pte(virt_to_pfn(address), PAGE_INIT);\r\nif (address >= (unsigned long) high_memory)\r\npte_val(pte) = 0;\r\nset_pte(pg_table, pte);\r\naddress += PAGE_SIZE;\r\n}\r\n}\r\ncurrent->mm = NULL;\r\nfor (zone = 0; zone < MAX_NR_ZONES; zone++)\r\nzones_size[zone] = 0x0;\r\nzones_size[ZONE_DMA] = num_pages;\r\nfree_area_init(zones_size);\r\n}\r\nint cf_tlb_miss(struct pt_regs *regs, int write, int dtlb, int extension_word)\r\n{\r\nunsigned long flags, mmuar, mmutr;\r\nstruct mm_struct *mm;\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte;\r\nint asid;\r\nlocal_irq_save(flags);\r\nmmuar = (dtlb) ? mmu_read(MMUAR) :\r\nregs->pc + (extension_word * sizeof(long));\r\nmm = (!user_mode(regs) && KMAPAREA(mmuar)) ? &init_mm : current->mm;\r\nif (!mm) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\npgd = pgd_offset(mm, mmuar);\r\nif (pgd_none(*pgd)) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\npmd = pmd_offset(pgd, mmuar);\r\nif (pmd_none(*pmd)) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\npte = (KMAPAREA(mmuar)) ? pte_offset_kernel(pmd, mmuar)\r\n: pte_offset_map(pmd, mmuar);\r\nif (pte_none(*pte) || !pte_present(*pte)) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\nif (write) {\r\nif (!pte_write(*pte)) {\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\nset_pte(pte, pte_mkdirty(*pte));\r\n}\r\nset_pte(pte, pte_mkyoung(*pte));\r\nasid = mm->context & 0xff;\r\nif (!pte_dirty(*pte) && !KMAPAREA(mmuar))\r\nset_pte(pte, pte_wrprotect(*pte));\r\nmmutr = (mmuar & PAGE_MASK) | (asid << MMUTR_IDN) | MMUTR_V;\r\nif ((mmuar < TASK_UNMAPPED_BASE) || (mmuar >= TASK_SIZE))\r\nmmutr |= (pte->pte & CF_PAGE_MMUTR_MASK) >> CF_PAGE_MMUTR_SHIFT;\r\nmmu_write(MMUTR, mmutr);\r\nmmu_write(MMUDR, (pte_val(*pte) & PAGE_MASK) |\r\n((pte->pte) & CF_PAGE_MMUDR_MASK) | MMUDR_SZ_8KB | MMUDR_X);\r\nif (dtlb)\r\nmmu_write(MMUOR, MMUOR_ACC | MMUOR_UAA);\r\nelse\r\nmmu_write(MMUOR, MMUOR_ITLB | MMUOR_ACC | MMUOR_UAA);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid __init cf_bootmem_alloc(void)\r\n{\r\nunsigned long start_pfn;\r\nunsigned long memstart;\r\nm68k_memory[0].addr = _rambase;\r\nm68k_memory[0].size = _ramend - _rambase;\r\nnum_pages = PFN_DOWN(_ramend - _rambase);\r\nmemstart = PAGE_ALIGN(_ramstart);\r\nmin_low_pfn = PFN_DOWN(_rambase);\r\nstart_pfn = PFN_DOWN(memstart);\r\nmax_pfn = max_low_pfn = PFN_DOWN(_ramend);\r\nhigh_memory = (void *)_ramend;\r\nm68k_virt_to_node_shift = fls(_ramend - _rambase - 1) - 6;\r\nmodule_fixup(NULL, __start_fixup, __stop_fixup);\r\nm68k_setup_node(0);\r\nmemstart += init_bootmem_node(NODE_DATA(0), start_pfn,\r\nmin_low_pfn, max_low_pfn);\r\nfree_bootmem_node(NODE_DATA(0), memstart, _ramend - memstart);\r\n}\r\nvoid __init mmu_context_init(void)\r\n{\r\ncontext_map[0] = (1 << FIRST_CONTEXT) - 1;\r\nnext_mmu_context = FIRST_CONTEXT;\r\natomic_set(&nr_free_contexts, LAST_CONTEXT - FIRST_CONTEXT + 1);\r\n}\r\nvoid steal_context(void)\r\n{\r\nstruct mm_struct *mm;\r\nif (next_mmu_context < FIRST_CONTEXT)\r\nnext_mmu_context = FIRST_CONTEXT;\r\nmm = context_mm[next_mmu_context];\r\nflush_tlb_mm(mm);\r\ndestroy_context(mm);\r\n}
