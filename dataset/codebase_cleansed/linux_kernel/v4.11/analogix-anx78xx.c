static inline struct anx78xx *connector_to_anx78xx(struct drm_connector *c)\r\n{\r\nreturn container_of(c, struct anx78xx, connector);\r\n}\r\nstatic inline struct anx78xx *bridge_to_anx78xx(struct drm_bridge *bridge)\r\n{\r\nreturn container_of(bridge, struct anx78xx, bridge);\r\n}\r\nstatic int anx78xx_set_bits(struct regmap *map, u8 reg, u8 mask)\r\n{\r\nreturn regmap_update_bits(map, reg, mask, mask);\r\n}\r\nstatic int anx78xx_clear_bits(struct regmap *map, u8 reg, u8 mask)\r\n{\r\nreturn regmap_update_bits(map, reg, mask, 0);\r\n}\r\nstatic bool anx78xx_aux_op_finished(struct anx78xx *anx78xx)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL2_REG,\r\n&value);\r\nif (err < 0)\r\nreturn false;\r\nreturn (value & SP_AUX_EN) == 0;\r\n}\r\nstatic int anx78xx_aux_wait(struct anx78xx *anx78xx)\r\n{\r\nunsigned long timeout;\r\nunsigned int status;\r\nint err;\r\ntimeout = jiffies + msecs_to_jiffies(AUX_WAIT_TIMEOUT_MS) + 1;\r\nwhile (!anx78xx_aux_op_finished(anx78xx)) {\r\nif (time_after(jiffies, timeout)) {\r\nif (!anx78xx_aux_op_finished(anx78xx)) {\r\nDRM_ERROR("Timed out waiting AUX to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nbreak;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_CH_STATUS_REG,\r\n&status);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to read from AUX channel: %d\n", err);\r\nreturn err;\r\n}\r\nif (status & SP_AUX_STATUS) {\r\nDRM_ERROR("Failed to wait for AUX channel (status: %02x)\n",\r\nstatus);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int anx78xx_aux_address(struct anx78xx *anx78xx, unsigned int addr)\r\n{\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_ADDR_7_0_REG,\r\naddr & 0xff);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_ADDR_15_8_REG,\r\n(addr & 0xff00) >> 8);\r\nif (err)\r\nreturn err;\r\nerr = regmap_update_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_AUX_ADDR_19_16_REG,\r\nSP_AUX_ADDR_19_16_MASK,\r\n(addr & 0xf0000) >> 16);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic ssize_t anx78xx_aux_transfer(struct drm_dp_aux *aux,\r\nstruct drm_dp_aux_msg *msg)\r\n{\r\nstruct anx78xx *anx78xx = container_of(aux, struct anx78xx, aux);\r\nu8 ctrl1 = msg->request;\r\nu8 ctrl2 = SP_AUX_EN;\r\nu8 *buffer = msg->buffer;\r\nint err;\r\nif (WARN_ON(msg->size > AUX_CH_BUFFER_SIZE))\r\nreturn -E2BIG;\r\nif (msg->size < 1)\r\nctrl2 |= SP_ADDR_ONLY;\r\nelse\r\nctrl1 |= (msg->size - 1) << SP_AUX_LENGTH_SHIFT;\r\nif ((msg->request & DP_AUX_I2C_READ) == 0) {\r\nerr = regmap_bulk_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_BUF_DATA0_REG, buffer,\r\nmsg->size);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = anx78xx_aux_address(anx78xx, msg->address);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL1_REG,\r\nctrl1);\r\nif (err)\r\nreturn err;\r\nerr = regmap_update_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_AUX_CH_CTRL2_REG, SP_ADDR_ONLY |\r\nSP_AUX_EN, ctrl2);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_aux_wait(anx78xx);\r\nif (err)\r\nreturn err;\r\nmsg->reply = DP_AUX_I2C_REPLY_ACK;\r\nif ((msg->size > 0) && (msg->request & DP_AUX_I2C_READ)) {\r\nerr = regmap_bulk_read(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_BUF_DATA0_REG, buffer,\r\nmsg->size);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_AUX_CH_CTRL2_REG, SP_ADDR_ONLY);\r\nif (err)\r\nreturn err;\r\nreturn msg->size;\r\n}\r\nstatic int anx78xx_set_hpd(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_TMDS_CTRL_BASE + 7, SP_PD_RT);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL3_REG,\r\nSP_HPD_OUT);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_clear_hpd(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL3_REG,\r\nSP_HPD_OUT);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_TMDS_CTRL_BASE + 7, SP_PD_RT);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_rx_initialization(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_HDMI_MUTE_CTRL_REG,\r\nSP_AUD_MUTE | SP_VID_MUTE);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0], SP_CHIP_CTRL_REG,\r\nSP_MAN_HDMI5V_DET | SP_PLLLOCK_CKDT_EN |\r\nSP_DIGITAL_CKDT_EN);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_SOFTWARE_RESET1_REG, SP_HDCP_MAN_RST |\r\nSP_SW_MAN_RST | SP_TMDS_RST | SP_VIDEO_RST);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_SOFTWARE_RESET1_REG, SP_HDCP_MAN_RST |\r\nSP_SW_MAN_RST | SP_TMDS_RST | SP_VIDEO_RST);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_AUD_EXCEPTION_ENABLE_BASE + 1, BIT(5) |\r\nBIT(6));\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_AUD_EXCEPTION_ENABLE_BASE + 3,\r\nSP_AEC_EN21);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0], SP_AUDVID_CTRL_REG,\r\nSP_AVC_EN | SP_AAC_OE | SP_AAC_EN);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_SYSTEM_POWER_DOWN1_REG, SP_PWDN_CTRL);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_VID_DATA_RANGE_CTRL_REG, SP_R2Y_INPUT_LIMIT);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_EXTRA_I2C_DEV_ADDR_REG, SP_I2C_EXTRA_ADDR);\r\nif (err)\r\nreturn err;\r\nerr = regmap_multi_reg_write(anx78xx->map[I2C_IDX_RX_P0],\r\ntmds_phy_initialization,\r\nARRAY_SIZE(tmds_phy_initialization));\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_hpd(anx78xx);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_link_phy_initialization(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_ANALOG_CTRL0_REG,\r\n0x02);\r\nif (err)\r\nreturn err;\r\nerr = regmap_bulk_write(anx78xx->map[I2C_IDX_TX_P1],\r\nSP_DP_TX_LT_CTRL0_REG,\r\ndp_tx_output_precise_tune_bits,\r\nARRAY_SIZE(dp_tx_output_precise_tune_bits));\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_xtal_clk_sel(struct anx78xx *anx78xx)\r\n{\r\nunsigned int value;\r\nint err;\r\nerr = regmap_update_bits(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_ANALOG_DEBUG2_REG,\r\nSP_XTAL_FRQ | SP_FORCE_SW_OFF_BYPASS,\r\nSP_XTAL_FRQ_27M);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL3_REG,\r\nXTAL_CLK & SP_WAIT_COUNTER_7_0_MASK);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL4_REG,\r\n((XTAL_CLK & 0xff00) >> 2) | (XTAL_CLK / 10));\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_I2C_GEN_10US_TIMER0_REG, XTAL_CLK & 0xff);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_I2C_GEN_10US_TIMER1_REG,\r\n(XTAL_CLK & 0xff00) >> 8);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_MISC_CTRL_REG,\r\nXTAL_CLK / 10 - 1);\r\nif (err)\r\nreturn err;\r\nerr = regmap_read(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_HDMI_US_TIMER_CTRL_REG,\r\n&value);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_HDMI_US_TIMER_CTRL_REG,\r\n(value & SP_MS_TIMER_MARGIN_10_8_MASK) |\r\n((((XTAL_CLK / 10) >> 1) - 2) << 3));\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_tx_initialization(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL2_REG,\r\n0x30);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_AUX_CH_CTRL2_REG, 0x08);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_HDCP_CTRL_REG, SP_AUTO_EN |\r\nSP_AUTO_START);\r\nif (err)\r\nreturn err;\r\nerr = regmap_multi_reg_write(anx78xx->map[I2C_IDX_TX_P0],\r\notp_key_protect,\r\nARRAY_SIZE(otp_key_protect));\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_HDCP_KEY_COMMAND_REG, SP_DISABLE_SYNC_HDCP);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL8_REG,\r\nSP_VID_VRES_TH);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_HDCP_AUTO_TIMER_REG,\r\n0x00);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_HDCP_CTRL_REG, SP_LINK_POLLING);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_LINK_DEBUG_CTRL_REG, SP_M_VID_DEBUG);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_ANALOG_DEBUG2_REG, SP_POWERON_TIME_1P5MS);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_xtal_clk_sel(anx78xx);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_DEFER_CTRL_REG,\r\nSP_DEFER_CTRL_EN | 0x0c);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_POLLING_CTRL_REG,\r\nSP_AUTO_POLLING_DISABLE);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_HDCP_LINK_CHECK_TIMER_REG, 0x1d);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_MISC_CTRL_REG, SP_EQ_TRAINING_LOOP);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_ANALOG_POWER_DOWN_REG, SP_CH0_PD);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_link_phy_initialization(anx78xx);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_M_CALCULATION_CTRL_REG, SP_M_GEN_CLK_SEL);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_enable_interrupts(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_INT_CTRL_REG, 0x01);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_COMMON_INT_MASK4_REG, SP_HPD_LOST | SP_HPD_PLUG);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_MASK1_REG,\r\nSP_TRAINING_FINISH);\r\nif (err)\r\nreturn err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_INT_MASK1_REG,\r\nSP_CKDT_CHG | SP_SCDT_CHG);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void anx78xx_poweron(struct anx78xx *anx78xx)\r\n{\r\nstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\r\nint err;\r\nif (WARN_ON(anx78xx->powered))\r\nreturn;\r\nif (pdata->dvdd10) {\r\nerr = regulator_enable(pdata->dvdd10);\r\nif (err) {\r\nDRM_ERROR("Failed to enable DVDD10 regulator: %d\n",\r\nerr);\r\nreturn;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\ngpiod_set_value_cansleep(pdata->gpiod_reset, 1);\r\nusleep_range(1000, 2000);\r\ngpiod_set_value_cansleep(pdata->gpiod_pd, 0);\r\nusleep_range(1000, 2000);\r\ngpiod_set_value_cansleep(pdata->gpiod_reset, 0);\r\nanx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\r\nSP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\r\nanx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\r\nSP_REGISTER_PD | SP_TOTAL_PD);\r\nanx78xx->powered = true;\r\n}\r\nstatic void anx78xx_poweroff(struct anx78xx *anx78xx)\r\n{\r\nstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\r\nint err;\r\nif (WARN_ON(!anx78xx->powered))\r\nreturn;\r\ngpiod_set_value_cansleep(pdata->gpiod_reset, 1);\r\nusleep_range(1000, 2000);\r\ngpiod_set_value_cansleep(pdata->gpiod_pd, 1);\r\nusleep_range(1000, 2000);\r\nif (pdata->dvdd10) {\r\nerr = regulator_disable(pdata->dvdd10);\r\nif (err) {\r\nDRM_ERROR("Failed to disable DVDD10 regulator: %d\n",\r\nerr);\r\nreturn;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\nanx78xx->powered = false;\r\n}\r\nstatic int anx78xx_start(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_POWERDOWN_CTRL_REG,\r\nSP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD |\r\nSP_LINK_PD);\r\nerr = anx78xx_enable_interrupts(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to enable interrupts: %d\n", err);\r\ngoto err_poweroff;\r\n}\r\nerr = anx78xx_rx_initialization(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed receiver initialization: %d\n", err);\r\ngoto err_poweroff;\r\n}\r\nerr = anx78xx_tx_initialization(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed transmitter initialization: %d\n", err);\r\ngoto err_poweroff;\r\n}\r\nusleep_range(10000, 15000);\r\nreturn 0;\r\nerr_poweroff:\r\nDRM_ERROR("Failed SlimPort transmitter initialization: %d\n", err);\r\nanx78xx_poweroff(anx78xx);\r\nreturn err;\r\n}\r\nstatic int anx78xx_init_pdata(struct anx78xx *anx78xx)\r\n{\r\nstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\r\nstruct device *dev = &anx78xx->client->dev;\r\npdata->dvdd10 = devm_regulator_get(dev, "dvdd10");\r\nif (IS_ERR(pdata->dvdd10)) {\r\nDRM_ERROR("DVDD10 regulator not found\n");\r\nreturn PTR_ERR(pdata->dvdd10);\r\n}\r\npdata->gpiod_hpd = devm_gpiod_get(dev, "hpd", GPIOD_IN);\r\nif (IS_ERR(pdata->gpiod_hpd))\r\nreturn PTR_ERR(pdata->gpiod_hpd);\r\npdata->gpiod_pd = devm_gpiod_get(dev, "pd", GPIOD_OUT_HIGH);\r\nif (IS_ERR(pdata->gpiod_pd))\r\nreturn PTR_ERR(pdata->gpiod_pd);\r\npdata->gpiod_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);\r\nreturn PTR_ERR_OR_ZERO(pdata->gpiod_reset);\r\n}\r\nstatic int anx78xx_dp_link_training(struct anx78xx *anx78xx)\r\n{\r\nu8 dp_bw, value;\r\nint err;\r\nerr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_HDMI_MUTE_CTRL_REG,\r\n0x0);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_POWERDOWN_CTRL_REG,\r\nSP_TOTAL_PD);\r\nif (err)\r\nreturn err;\r\nerr = drm_dp_dpcd_readb(&anx78xx->aux, DP_MAX_LINK_RATE, &dp_bw);\r\nif (err < 0)\r\nreturn err;\r\nswitch (dp_bw) {\r\ncase DP_LINK_BW_1_62:\r\ncase DP_LINK_BW_2_7:\r\ncase DP_LINK_BW_5_4:\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("DP bandwidth (%#02x) not supported\n", dp_bw);\r\nreturn -EINVAL;\r\n}\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\r\nSP_VIDEO_MUTE);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_VID_CTRL1_REG, SP_VIDEO_EN);\r\nif (err)\r\nreturn err;\r\nerr = drm_dp_dpcd_read(&anx78xx->aux, DP_DPCD_REV,\r\n&anx78xx->dpcd, DP_RECEIVER_CAP_SIZE);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to read DPCD: %d\n", err);\r\nreturn err;\r\n}\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_ANALOG_POWER_DOWN_REG, SP_CH0_PD);\r\nif (err)\r\nreturn err;\r\nerr = drm_dp_link_probe(&anx78xx->aux, &anx78xx->link);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to probe link capabilities: %d\n", err);\r\nreturn err;\r\n}\r\nerr = drm_dp_link_power_up(&anx78xx->aux, &anx78xx->link);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to power up DisplayPort link: %d\n", err);\r\nreturn err;\r\n}\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_DOWNSPREAD_CTRL1_REG, 0);\r\nif (err)\r\nreturn err;\r\nif (anx78xx->dpcd[DP_MAX_DOWNSPREAD] & DP_MAX_DOWNSPREAD_0_5) {\r\nDRM_DEBUG("Enable downspread on the sink\n");\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_DOWNSPREAD_CTRL1_REG, 8);\r\nif (err)\r\nreturn err;\r\nerr = drm_dp_dpcd_writeb(&anx78xx->aux, DP_DOWNSPREAD_CTRL,\r\nDP_SPREAD_AMP_0_5);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = drm_dp_dpcd_writeb(&anx78xx->aux, DP_DOWNSPREAD_CTRL, 0);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (drm_dp_enhanced_frame_cap(anx78xx->dpcd))\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_SYSTEM_CTRL_BASE + 4,\r\nSP_ENHANCED_MODE);\r\nelse\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_SYSTEM_CTRL_BASE + 4,\r\nSP_ENHANCED_MODE);\r\nif (err)\r\nreturn err;\r\nvalue = drm_dp_link_rate_to_bw_code(anx78xx->link.rate);\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_DP_MAIN_LINK_BW_SET_REG, value);\r\nif (err)\r\nreturn err;\r\nerr = drm_dp_link_configure(&anx78xx->aux, &anx78xx->link);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to configure DisplayPort link: %d\n", err);\r\nreturn err;\r\n}\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_LT_CTRL_REG,\r\nSP_LT_EN);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_config_dp_output(struct anx78xx *anx78xx)\r\n{\r\nint err;\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\r\nSP_VIDEO_MUTE);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\r\nSP_VIDEO_EN);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_send_video_infoframe(struct anx78xx *anx78xx,\r\nstruct hdmi_avi_infoframe *frame)\r\n{\r\nu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\r\nint err;\r\nerr = hdmi_avi_infoframe_pack(frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("Failed to pack AVI infoframe: %d\n", err);\r\nreturn err;\r\n}\r\nerr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_PACKET_SEND_CTRL_REG, SP_AVI_IF_EN);\r\nif (err)\r\nreturn err;\r\nerr = regmap_bulk_write(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_INFOFRAME_AVI_DB1_REG, buffer,\r\nframe->length);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_PACKET_SEND_CTRL_REG, SP_AVI_IF_UD);\r\nif (err)\r\nreturn err;\r\nerr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\r\nSP_PACKET_SEND_CTRL_REG, SP_AVI_IF_EN);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int anx78xx_get_downstream_info(struct anx78xx *anx78xx)\r\n{\r\nu8 value;\r\nint err;\r\nerr = drm_dp_dpcd_readb(&anx78xx->aux, DP_SINK_COUNT, &value);\r\nif (err < 0) {\r\nDRM_ERROR("Get sink count failed %d\n", err);\r\nreturn err;\r\n}\r\nif (!DP_GET_SINK_COUNT(value)) {\r\nDRM_ERROR("Downstream disconnected\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int anx78xx_get_modes(struct drm_connector *connector)\r\n{\r\nstruct anx78xx *anx78xx = connector_to_anx78xx(connector);\r\nint err, num_modes = 0;\r\nif (WARN_ON(!anx78xx->powered))\r\nreturn 0;\r\nif (anx78xx->edid)\r\nreturn drm_add_edid_modes(connector, anx78xx->edid);\r\nmutex_lock(&anx78xx->lock);\r\nerr = anx78xx_get_downstream_info(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to get downstream info: %d\n", err);\r\ngoto unlock;\r\n}\r\nanx78xx->edid = drm_get_edid(connector, &anx78xx->aux.ddc);\r\nif (!anx78xx->edid) {\r\nDRM_ERROR("Failed to read EDID\n");\r\ngoto unlock;\r\n}\r\nerr = drm_mode_connector_update_edid_property(connector,\r\nanx78xx->edid);\r\nif (err) {\r\nDRM_ERROR("Failed to update EDID property: %d\n", err);\r\ngoto unlock;\r\n}\r\nnum_modes = drm_add_edid_modes(connector, anx78xx->edid);\r\ndrm_edid_to_eld(connector, anx78xx->edid);\r\nunlock:\r\nmutex_unlock(&anx78xx->lock);\r\nreturn num_modes;\r\n}\r\nstatic enum drm_connector_status anx78xx_detect(struct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct anx78xx *anx78xx = connector_to_anx78xx(connector);\r\nif (!gpiod_get_value(anx78xx->pdata.gpiod_hpd))\r\nreturn connector_status_disconnected;\r\nreturn connector_status_connected;\r\n}\r\nstatic int anx78xx_bridge_attach(struct drm_bridge *bridge)\r\n{\r\nstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\r\nint err;\r\nif (!bridge->encoder) {\r\nDRM_ERROR("Parent encoder object not found");\r\nreturn -ENODEV;\r\n}\r\nanx78xx->aux.name = "DP-AUX";\r\nanx78xx->aux.dev = &anx78xx->client->dev;\r\nanx78xx->aux.transfer = anx78xx_aux_transfer;\r\nerr = drm_dp_aux_register(&anx78xx->aux);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to register aux channel: %d\n", err);\r\nreturn err;\r\n}\r\nerr = drm_connector_init(bridge->dev, &anx78xx->connector,\r\n&anx78xx_connector_funcs,\r\nDRM_MODE_CONNECTOR_DisplayPort);\r\nif (err) {\r\nDRM_ERROR("Failed to initialize connector: %d\n", err);\r\nreturn err;\r\n}\r\ndrm_connector_helper_add(&anx78xx->connector,\r\n&anx78xx_connector_helper_funcs);\r\nerr = drm_connector_register(&anx78xx->connector);\r\nif (err) {\r\nDRM_ERROR("Failed to register connector: %d\n", err);\r\nreturn err;\r\n}\r\nanx78xx->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\nerr = drm_mode_connector_attach_encoder(&anx78xx->connector,\r\nbridge->encoder);\r\nif (err) {\r\nDRM_ERROR("Failed to link up connector to encoder: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool anx78xx_bridge_mode_fixup(struct drm_bridge *bridge,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn false;\r\nif (mode->clock > 154000)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void anx78xx_bridge_disable(struct drm_bridge *bridge)\r\n{\r\nstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\r\nanx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\r\nSP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\r\n}\r\nstatic void anx78xx_bridge_mode_set(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\r\nstruct hdmi_avi_infoframe frame;\r\nint err;\r\nif (WARN_ON(!anx78xx->powered))\r\nreturn;\r\nmutex_lock(&anx78xx->lock);\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, adjusted_mode);\r\nif (err) {\r\nDRM_ERROR("Failed to setup AVI infoframe: %d\n", err);\r\ngoto unlock;\r\n}\r\nerr = anx78xx_send_video_infoframe(anx78xx, &frame);\r\nif (err)\r\nDRM_ERROR("Failed to send AVI infoframe: %d\n", err);\r\nunlock:\r\nmutex_unlock(&anx78xx->lock);\r\n}\r\nstatic void anx78xx_bridge_enable(struct drm_bridge *bridge)\r\n{\r\nstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\r\nint err;\r\nerr = anx78xx_start(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to initialize: %d\n", err);\r\nreturn;\r\n}\r\nerr = anx78xx_set_hpd(anx78xx);\r\nif (err)\r\nDRM_ERROR("Failed to set HPD: %d\n", err);\r\n}\r\nstatic irqreturn_t anx78xx_hpd_threaded_handler(int irq, void *data)\r\n{\r\nstruct anx78xx *anx78xx = data;\r\nint err;\r\nif (anx78xx->powered)\r\nreturn IRQ_HANDLED;\r\nmutex_lock(&anx78xx->lock);\r\nanx78xx_poweron(anx78xx);\r\nerr = anx78xx_enable_interrupts(anx78xx);\r\nif (err)\r\nDRM_ERROR("Failed to enable interrupts: %d\n", err);\r\nmutex_unlock(&anx78xx->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int anx78xx_handle_dp_int_1(struct anx78xx *anx78xx, u8 irq)\r\n{\r\nint err;\r\nDRM_DEBUG_KMS("Handle DP interrupt 1: %02x\n", irq);\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_STATUS1_REG,\r\nirq);\r\nif (err)\r\nreturn err;\r\nif (irq & SP_TRAINING_FINISH) {\r\nDRM_DEBUG_KMS("IRQ: hardware link training finished\n");\r\nerr = anx78xx_config_dp_output(anx78xx);\r\n}\r\nreturn err;\r\n}\r\nstatic bool anx78xx_handle_common_int_4(struct anx78xx *anx78xx, u8 irq)\r\n{\r\nbool event = false;\r\nint err;\r\nDRM_DEBUG_KMS("Handle common interrupt 4: %02x\n", irq);\r\nerr = regmap_write(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_COMMON_INT_STATUS4_REG, irq);\r\nif (err) {\r\nDRM_ERROR("Failed to write SP_COMMON_INT_STATUS4 %d\n", err);\r\nreturn event;\r\n}\r\nif (irq & SP_HPD_LOST) {\r\nDRM_DEBUG_KMS("IRQ: Hot plug detect - cable is pulled out\n");\r\nevent = true;\r\nanx78xx_poweroff(anx78xx);\r\nkfree(anx78xx->edid);\r\nanx78xx->edid = NULL;\r\n} else if (irq & SP_HPD_PLUG) {\r\nDRM_DEBUG_KMS("IRQ: Hot plug detect - cable plug\n");\r\nevent = true;\r\n}\r\nreturn event;\r\n}\r\nstatic void anx78xx_handle_hdmi_int_1(struct anx78xx *anx78xx, u8 irq)\r\n{\r\nunsigned int value;\r\nint err;\r\nDRM_DEBUG_KMS("Handle HDMI interrupt 1: %02x\n", irq);\r\nerr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_INT_STATUS1_REG,\r\nirq);\r\nif (err) {\r\nDRM_ERROR("Write HDMI int 1 failed: %d\n", err);\r\nreturn;\r\n}\r\nif ((irq & SP_CKDT_CHG) || (irq & SP_SCDT_CHG)) {\r\nDRM_DEBUG_KMS("IRQ: HDMI input detected\n");\r\nerr = regmap_read(anx78xx->map[I2C_IDX_RX_P0],\r\nSP_SYSTEM_STATUS_REG, &value);\r\nif (err) {\r\nDRM_ERROR("Read system status reg failed: %d\n", err);\r\nreturn;\r\n}\r\nif (!(value & SP_TMDS_CLOCK_DET)) {\r\nDRM_DEBUG_KMS("IRQ: *** Waiting for HDMI clock ***\n");\r\nreturn;\r\n}\r\nif (!(value & SP_TMDS_DE_DET)) {\r\nDRM_DEBUG_KMS("IRQ: *** Waiting for HDMI signal ***\n");\r\nreturn;\r\n}\r\nerr = anx78xx_dp_link_training(anx78xx);\r\nif (err)\r\nDRM_ERROR("Failed to start link training: %d\n", err);\r\n}\r\n}\r\nstatic irqreturn_t anx78xx_intp_threaded_handler(int unused, void *data)\r\n{\r\nstruct anx78xx *anx78xx = data;\r\nbool event = false;\r\nunsigned int irq;\r\nint err;\r\nmutex_lock(&anx78xx->lock);\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_STATUS1_REG,\r\n&irq);\r\nif (err) {\r\nDRM_ERROR("Failed to read DP interrupt 1 status: %d\n", err);\r\ngoto unlock;\r\n}\r\nif (irq)\r\nanx78xx_handle_dp_int_1(anx78xx, irq);\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P2],\r\nSP_COMMON_INT_STATUS4_REG, &irq);\r\nif (err) {\r\nDRM_ERROR("Failed to read common interrupt 4 status: %d\n",\r\nerr);\r\ngoto unlock;\r\n}\r\nif (irq)\r\nevent = anx78xx_handle_common_int_4(anx78xx, irq);\r\nif (!anx78xx->powered)\r\ngoto unlock;\r\nerr = regmap_read(anx78xx->map[I2C_IDX_RX_P0], SP_INT_STATUS1_REG,\r\n&irq);\r\nif (err) {\r\nDRM_ERROR("Failed to read HDMI int 1 status: %d\n", err);\r\ngoto unlock;\r\n}\r\nif (irq)\r\nanx78xx_handle_hdmi_int_1(anx78xx, irq);\r\nunlock:\r\nmutex_unlock(&anx78xx->lock);\r\nif (event)\r\ndrm_helper_hpd_irq_event(anx78xx->connector.dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void unregister_i2c_dummy_clients(struct anx78xx *anx78xx)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(anx78xx->i2c_dummy); i++)\r\nif (anx78xx->i2c_dummy[i])\r\ni2c_unregister_device(anx78xx->i2c_dummy[i]);\r\n}\r\nstatic int anx78xx_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct anx78xx *anx78xx;\r\nstruct anx78xx_platform_data *pdata;\r\nunsigned int i, idl, idh, version;\r\nbool found = false;\r\nint err;\r\nanx78xx = devm_kzalloc(&client->dev, sizeof(*anx78xx), GFP_KERNEL);\r\nif (!anx78xx)\r\nreturn -ENOMEM;\r\npdata = &anx78xx->pdata;\r\nmutex_init(&anx78xx->lock);\r\n#if IS_ENABLED(CONFIG_OF)\r\nanx78xx->bridge.of_node = client->dev.of_node;\r\n#endif\r\nanx78xx->client = client;\r\ni2c_set_clientdata(client, anx78xx);\r\nerr = anx78xx_init_pdata(anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to initialize pdata: %d\n", err);\r\nreturn err;\r\n}\r\npdata->hpd_irq = gpiod_to_irq(pdata->gpiod_hpd);\r\nif (pdata->hpd_irq < 0) {\r\nDRM_ERROR("Failed to get HPD IRQ: %d\n", pdata->hpd_irq);\r\nreturn -ENODEV;\r\n}\r\npdata->intp_irq = client->irq;\r\nif (!pdata->intp_irq) {\r\nDRM_ERROR("Failed to get CABLE_DET and INTP IRQ\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < I2C_NUM_ADDRESSES; i++) {\r\nanx78xx->i2c_dummy[i] = i2c_new_dummy(client->adapter,\r\nanx78xx_i2c_addresses[i] >> 1);\r\nif (!anx78xx->i2c_dummy[i]) {\r\nerr = -ENOMEM;\r\nDRM_ERROR("Failed to reserve I2C bus %02x\n",\r\nanx78xx_i2c_addresses[i]);\r\ngoto err_unregister_i2c;\r\n}\r\nanx78xx->map[i] = devm_regmap_init_i2c(anx78xx->i2c_dummy[i],\r\n&anx78xx_regmap_config);\r\nif (IS_ERR(anx78xx->map[i])) {\r\nerr = PTR_ERR(anx78xx->map[i]);\r\nDRM_ERROR("Failed regmap initialization %02x\n",\r\nanx78xx_i2c_addresses[i]);\r\ngoto err_unregister_i2c;\r\n}\r\n}\r\nanx78xx_poweron(anx78xx);\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_IDL_REG,\r\n&idl);\r\nif (err)\r\ngoto err_poweroff;\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_IDH_REG,\r\n&idh);\r\nif (err)\r\ngoto err_poweroff;\r\nanx78xx->chipid = (u8)idl | ((u8)idh << 8);\r\nerr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_VERSION_REG,\r\n&version);\r\nif (err)\r\ngoto err_poweroff;\r\nfor (i = 0; i < ARRAY_SIZE(anx78xx_chipid_list); i++) {\r\nif (anx78xx->chipid == anx78xx_chipid_list[i]) {\r\nDRM_INFO("Found ANX%x (ver. %d) SlimPort Transmitter\n",\r\nanx78xx->chipid, version);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nDRM_ERROR("ANX%x (ver. %d) not supported by this driver\n",\r\nanx78xx->chipid, version);\r\nerr = -ENODEV;\r\ngoto err_poweroff;\r\n}\r\nerr = devm_request_threaded_irq(&client->dev, pdata->hpd_irq, NULL,\r\nanx78xx_hpd_threaded_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"anx78xx-hpd", anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to request CABLE_DET threaded IRQ: %d\n",\r\nerr);\r\ngoto err_poweroff;\r\n}\r\nerr = devm_request_threaded_irq(&client->dev, pdata->intp_irq, NULL,\r\nanx78xx_intp_threaded_handler,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"anx78xx-intp", anx78xx);\r\nif (err) {\r\nDRM_ERROR("Failed to request INTP threaded IRQ: %d\n", err);\r\ngoto err_poweroff;\r\n}\r\nanx78xx->bridge.funcs = &anx78xx_bridge_funcs;\r\nerr = drm_bridge_add(&anx78xx->bridge);\r\nif (err < 0) {\r\nDRM_ERROR("Failed to add drm bridge: %d\n", err);\r\ngoto err_poweroff;\r\n}\r\nif (!gpiod_get_value(anx78xx->pdata.gpiod_hpd))\r\nanx78xx_poweroff(anx78xx);\r\nreturn 0;\r\nerr_poweroff:\r\nanx78xx_poweroff(anx78xx);\r\nerr_unregister_i2c:\r\nunregister_i2c_dummy_clients(anx78xx);\r\nreturn err;\r\n}\r\nstatic int anx78xx_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct anx78xx *anx78xx = i2c_get_clientdata(client);\r\ndrm_bridge_remove(&anx78xx->bridge);\r\nunregister_i2c_dummy_clients(anx78xx);\r\nkfree(anx78xx->edid);\r\nreturn 0;\r\n}
