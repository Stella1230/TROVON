static int rcar_sysc_pwr_on_off(const struct rcar_sysc_ch *sysc_ch, bool on)\r\n{\r\nunsigned int sr_bit, reg_offs;\r\nint k;\r\nif (on) {\r\nsr_bit = SYSCSR_PONENB;\r\nreg_offs = PWRONCR_OFFS;\r\n} else {\r\nsr_bit = SYSCSR_POFFENB;\r\nreg_offs = PWROFFCR_OFFS;\r\n}\r\nfor (k = 0; k < SYSCSR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCSR) & BIT(sr_bit))\r\nbreak;\r\nudelay(SYSCSR_DELAY_US);\r\n}\r\nif (k == SYSCSR_RETRIES)\r\nreturn -EAGAIN;\r\niowrite32(BIT(sysc_ch->chan_bit),\r\nrcar_sysc_base + sysc_ch->chan_offs + reg_offs);\r\nreturn 0;\r\n}\r\nstatic int rcar_sysc_power(const struct rcar_sysc_ch *sysc_ch, bool on)\r\n{\r\nunsigned int isr_mask = BIT(sysc_ch->isr_bit);\r\nunsigned int chan_mask = BIT(sysc_ch->chan_bit);\r\nunsigned int status;\r\nunsigned long flags;\r\nint ret = 0;\r\nint k;\r\nspin_lock_irqsave(&rcar_sysc_lock, flags);\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\nfor (k = 0; k < PWRER_RETRIES; k++) {\r\nret = rcar_sysc_pwr_on_off(sysc_ch, on);\r\nif (ret)\r\ngoto out;\r\nstatus = ioread32(rcar_sysc_base +\r\nsysc_ch->chan_offs + PWRER_OFFS);\r\nif (!(status & chan_mask))\r\nbreak;\r\nudelay(PWRER_DELAY_US);\r\n}\r\nif (k == PWRER_RETRIES) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nfor (k = 0; k < SYSCISR_RETRIES; k++) {\r\nif (ioread32(rcar_sysc_base + SYSCISR) & isr_mask)\r\nbreak;\r\nudelay(SYSCISR_DELAY_US);\r\n}\r\nif (k == SYSCISR_RETRIES)\r\nret = -EIO;\r\niowrite32(isr_mask, rcar_sysc_base + SYSCISCR);\r\nout:\r\nspin_unlock_irqrestore(&rcar_sysc_lock, flags);\r\npr_debug("sysc power %s domain %d: %08x -> %d\n", on ? "on" : "off",\r\nsysc_ch->isr_bit, ioread32(rcar_sysc_base + SYSCISR), ret);\r\nreturn ret;\r\n}\r\nint rcar_sysc_power_down(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_power(sysc_ch, false);\r\n}\r\nint rcar_sysc_power_up(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nreturn rcar_sysc_power(sysc_ch, true);\r\n}\r\nstatic bool rcar_sysc_power_is_off(const struct rcar_sysc_ch *sysc_ch)\r\n{\r\nunsigned int st;\r\nst = ioread32(rcar_sysc_base + sysc_ch->chan_offs + PWRSR_OFFS);\r\nif (st & BIT(sysc_ch->chan_bit))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline struct rcar_sysc_pd *to_rcar_pd(struct generic_pm_domain *d)\r\n{\r\nreturn container_of(d, struct rcar_sysc_pd, genpd);\r\n}\r\nstatic int rcar_sysc_pd_power_off(struct generic_pm_domain *genpd)\r\n{\r\nstruct rcar_sysc_pd *pd = to_rcar_pd(genpd);\r\npr_debug("%s: %s\n", __func__, genpd->name);\r\nif (pd->flags & PD_NO_CR) {\r\npr_debug("%s: Cannot control %s\n", __func__, genpd->name);\r\nreturn -EBUSY;\r\n}\r\nif (pd->flags & PD_BUSY) {\r\npr_debug("%s: %s busy\n", __func__, genpd->name);\r\nreturn -EBUSY;\r\n}\r\nreturn rcar_sysc_power_down(&pd->ch);\r\n}\r\nstatic int rcar_sysc_pd_power_on(struct generic_pm_domain *genpd)\r\n{\r\nstruct rcar_sysc_pd *pd = to_rcar_pd(genpd);\r\npr_debug("%s: %s\n", __func__, genpd->name);\r\nif (pd->flags & PD_NO_CR) {\r\npr_debug("%s: Cannot control %s\n", __func__, genpd->name);\r\nreturn 0;\r\n}\r\nreturn rcar_sysc_power_up(&pd->ch);\r\n}\r\nstatic void __init rcar_sysc_pd_setup(struct rcar_sysc_pd *pd)\r\n{\r\nstruct generic_pm_domain *genpd = &pd->genpd;\r\nconst char *name = pd->genpd.name;\r\nstruct dev_power_governor *gov = &simple_qos_governor;\r\nif (pd->flags & PD_CPU) {\r\npr_debug("PM domain %s contains %s\n", name, "CPU");\r\npd->flags |= PD_BUSY;\r\ngov = &pm_domain_always_on_gov;\r\n} else if (pd->flags & PD_SCU) {\r\npr_debug("PM domain %s contains %s\n", name, "SCU");\r\npd->flags |= PD_BUSY;\r\ngov = &pm_domain_always_on_gov;\r\n} else if (pd->flags & PD_NO_CR) {\r\npd->flags |= PD_BUSY;\r\ngov = &pm_domain_always_on_gov;\r\n}\r\nif (!(pd->flags & (PD_CPU | PD_SCU))) {\r\ngenpd->flags = GENPD_FLAG_PM_CLK;\r\nif (has_cpg_mstp) {\r\ngenpd->attach_dev = cpg_mstp_attach_dev;\r\ngenpd->detach_dev = cpg_mstp_detach_dev;\r\n} else {\r\ngenpd->attach_dev = cpg_mssr_attach_dev;\r\ngenpd->detach_dev = cpg_mssr_detach_dev;\r\n}\r\n}\r\ngenpd->power_off = rcar_sysc_pd_power_off;\r\ngenpd->power_on = rcar_sysc_pd_power_on;\r\nif (pd->flags & (PD_CPU | PD_NO_CR)) {\r\npr_debug("%s: Not touching %s\n", __func__, genpd->name);\r\ngoto finalize;\r\n}\r\nif (!rcar_sysc_power_is_off(&pd->ch)) {\r\npr_debug("%s: %s is already powered\n", __func__, genpd->name);\r\ngoto finalize;\r\n}\r\nrcar_sysc_power_up(&pd->ch);\r\nfinalize:\r\npm_genpd_init(genpd, gov, false);\r\n}\r\nstatic int __init rcar_sysc_pd_init(void)\r\n{\r\nconst struct rcar_sysc_info *info;\r\nconst struct of_device_id *match;\r\nstruct rcar_pm_domains *domains;\r\nstruct device_node *np;\r\nu32 syscier, syscimr;\r\nvoid __iomem *base;\r\nunsigned int i;\r\nint error;\r\nif (rcar_sysc_base)\r\nreturn 0;\r\nnp = of_find_matching_node_and_match(NULL, rcar_sysc_matches, &match);\r\nif (!np)\r\nreturn -ENODEV;\r\ninfo = match->data;\r\nhas_cpg_mstp = of_find_compatible_node(NULL, NULL,\r\n"renesas,cpg-mstp-clocks");\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_warn("%s: Cannot map regs\n", np->full_name);\r\nerror = -ENOMEM;\r\ngoto out_put;\r\n}\r\nrcar_sysc_base = base;\r\ndomains = kzalloc(sizeof(*domains), GFP_KERNEL);\r\nif (!domains) {\r\nerror = -ENOMEM;\r\ngoto out_put;\r\n}\r\ndomains->onecell_data.domains = domains->domains;\r\ndomains->onecell_data.num_domains = ARRAY_SIZE(domains->domains);\r\nfor (i = 0, syscier = 0; i < info->num_areas; i++)\r\nsyscier |= BIT(info->areas[i].isr_bit);\r\nsyscimr = ioread32(base + SYSCIMR);\r\nsyscimr |= syscier;\r\npr_debug("%s: syscimr = 0x%08x\n", np->full_name, syscimr);\r\niowrite32(syscimr, base + SYSCIMR);\r\npr_debug("%s: syscier = 0x%08x\n", np->full_name, syscier);\r\niowrite32(syscier, base + SYSCIER);\r\nfor (i = 0; i < info->num_areas; i++) {\r\nconst struct rcar_sysc_area *area = &info->areas[i];\r\nstruct rcar_sysc_pd *pd;\r\npd = kzalloc(sizeof(*pd) + strlen(area->name) + 1, GFP_KERNEL);\r\nif (!pd) {\r\nerror = -ENOMEM;\r\ngoto out_put;\r\n}\r\nstrcpy(pd->name, area->name);\r\npd->genpd.name = pd->name;\r\npd->ch.chan_offs = area->chan_offs;\r\npd->ch.chan_bit = area->chan_bit;\r\npd->ch.isr_bit = area->isr_bit;\r\npd->flags = area->flags;\r\nrcar_sysc_pd_setup(pd);\r\nif (area->parent >= 0)\r\npm_genpd_add_subdomain(domains->domains[area->parent],\r\n&pd->genpd);\r\ndomains->domains[area->isr_bit] = &pd->genpd;\r\n}\r\nerror = of_genpd_add_provider_onecell(np, &domains->onecell_data);\r\nout_put:\r\nof_node_put(np);\r\nreturn error;\r\n}\r\nvoid __init rcar_sysc_init(phys_addr_t base, u32 syscier)\r\n{\r\nu32 syscimr;\r\nif (!rcar_sysc_pd_init())\r\nreturn;\r\nrcar_sysc_base = ioremap_nocache(base, PAGE_SIZE);\r\nsyscimr = ioread32(rcar_sysc_base + SYSCIMR);\r\nsyscimr |= syscier;\r\npr_debug("%s: syscimr = 0x%08x\n", __func__, syscimr);\r\niowrite32(syscimr, rcar_sysc_base + SYSCIMR);\r\npr_debug("%s: syscier = 0x%08x\n", __func__, syscier);\r\niowrite32(syscier, rcar_sysc_base + SYSCIER);\r\n}
