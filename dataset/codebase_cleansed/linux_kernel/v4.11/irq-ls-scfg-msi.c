static void ls_scfg_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)\r\n{\r\nstruct ls_scfg_msi *msi_data = irq_data_get_irq_chip_data(data);\r\nmsg->address_hi = upper_32_bits(msi_data->msiir_addr);\r\nmsg->address_lo = lower_32_bits(msi_data->msiir_addr);\r\nmsg->data = data->hwirq << MSI_IBS_SHIFT;\r\n}\r\nstatic int ls_scfg_msi_set_affinity(struct irq_data *irq_data,\r\nconst struct cpumask *mask, bool force)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ls_scfg_msi_domain_irq_alloc(struct irq_domain *domain,\r\nunsigned int virq,\r\nunsigned int nr_irqs,\r\nvoid *args)\r\n{\r\nstruct ls_scfg_msi *msi_data = domain->host_data;\r\nint pos, err = 0;\r\nWARN_ON(nr_irqs != 1);\r\nspin_lock(&msi_data->lock);\r\npos = find_first_zero_bit(msi_data->used, MSI_MAX_IRQS);\r\nif (pos < MSI_MAX_IRQS)\r\n__set_bit(pos, msi_data->used);\r\nelse\r\nerr = -ENOSPC;\r\nspin_unlock(&msi_data->lock);\r\nif (err)\r\nreturn err;\r\nirq_domain_set_info(domain, virq, pos,\r\n&ls_scfg_msi_parent_chip, msi_data,\r\nhandle_simple_irq, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic void ls_scfg_msi_domain_irq_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *d = irq_domain_get_irq_data(domain, virq);\r\nstruct ls_scfg_msi *msi_data = irq_data_get_irq_chip_data(d);\r\nint pos;\r\npos = d->hwirq;\r\nif (pos < 0 || pos >= MSI_MAX_IRQS) {\r\npr_err("failed to teardown msi. Invalid hwirq %d\n", pos);\r\nreturn;\r\n}\r\nspin_lock(&msi_data->lock);\r\n__clear_bit(pos, msi_data->used);\r\nspin_unlock(&msi_data->lock);\r\n}\r\nstatic void ls_scfg_msi_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct ls_scfg_msi *msi_data = irq_desc_get_handler_data(desc);\r\nunsigned long val;\r\nint pos, virq;\r\nchained_irq_enter(irq_desc_get_chip(desc), desc);\r\nval = ioread32be(msi_data->regs + MSIR);\r\nfor_each_set_bit(pos, &val, MSI_MAX_IRQS) {\r\nvirq = irq_find_mapping(msi_data->parent, (31 - pos));\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\n}\r\nchained_irq_exit(irq_desc_get_chip(desc), desc);\r\n}\r\nstatic int ls_scfg_msi_domains_init(struct ls_scfg_msi *msi_data)\r\n{\r\nmsi_data->parent = irq_domain_add_linear(NULL,\r\nMSI_MAX_IRQS,\r\n&ls_scfg_msi_domain_ops,\r\nmsi_data);\r\nif (!msi_data->parent) {\r\ndev_err(&msi_data->pdev->dev, "failed to create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nmsi_data->msi_domain = pci_msi_create_irq_domain(\r\nof_node_to_fwnode(msi_data->pdev->dev.of_node),\r\n&ls_scfg_msi_domain_info,\r\nmsi_data->parent);\r\nif (!msi_data->msi_domain) {\r\ndev_err(&msi_data->pdev->dev, "failed to create MSI domain\n");\r\nirq_domain_remove(msi_data->parent);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ls_scfg_msi_probe(struct platform_device *pdev)\r\n{\r\nstruct ls_scfg_msi *msi_data;\r\nstruct resource *res;\r\nint ret;\r\nmsi_data = devm_kzalloc(&pdev->dev, sizeof(*msi_data), GFP_KERNEL);\r\nif (!msi_data)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmsi_data->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(msi_data->regs)) {\r\ndev_err(&pdev->dev, "failed to initialize 'regs'\n");\r\nreturn PTR_ERR(msi_data->regs);\r\n}\r\nmsi_data->msiir_addr = res->start;\r\nmsi_data->irq = platform_get_irq(pdev, 0);\r\nif (msi_data->irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get MSI irq\n");\r\nreturn -ENODEV;\r\n}\r\nmsi_data->pdev = pdev;\r\nspin_lock_init(&msi_data->lock);\r\nret = ls_scfg_msi_domains_init(msi_data);\r\nif (ret)\r\nreturn ret;\r\nirq_set_chained_handler_and_data(msi_data->irq,\r\nls_scfg_msi_irq_handler,\r\nmsi_data);\r\nplatform_set_drvdata(pdev, msi_data);\r\nreturn 0;\r\n}\r\nstatic int ls_scfg_msi_remove(struct platform_device *pdev)\r\n{\r\nstruct ls_scfg_msi *msi_data = platform_get_drvdata(pdev);\r\nirq_set_chained_handler_and_data(msi_data->irq, NULL, NULL);\r\nirq_domain_remove(msi_data->msi_domain);\r\nirq_domain_remove(msi_data->parent);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
