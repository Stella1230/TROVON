static inline struct xfs_rui_log_item *RUI_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_rui_log_item, rui_item);\r\n}\r\nvoid\r\nxfs_rui_item_free(\r\nstruct xfs_rui_log_item *ruip)\r\n{\r\nif (ruip->rui_format.rui_nextents > XFS_RUI_MAX_FAST_EXTENTS)\r\nkmem_free(ruip);\r\nelse\r\nkmem_zone_free(xfs_rui_zone, ruip);\r\n}\r\nSTATIC void\r\nxfs_rui_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\nstruct xfs_rui_log_item *ruip = RUI_ITEM(lip);\r\n*nvecs += 1;\r\n*nbytes += xfs_rui_log_format_sizeof(ruip->rui_format.rui_nextents);\r\n}\r\nSTATIC void\r\nxfs_rui_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_rui_log_item *ruip = RUI_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(atomic_read(&ruip->rui_next_extent) ==\r\nruip->rui_format.rui_nextents);\r\nruip->rui_format.rui_type = XFS_LI_RUI;\r\nruip->rui_format.rui_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_RUI_FORMAT, &ruip->rui_format,\r\nxfs_rui_log_format_sizeof(ruip->rui_format.rui_nextents));\r\n}\r\nSTATIC void\r\nxfs_rui_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_rui_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\nstruct xfs_rui_log_item *ruip = RUI_ITEM(lip);\r\nxfs_rui_release(ruip);\r\n}\r\nSTATIC uint\r\nxfs_rui_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_rui_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_rui_item_free(RUI_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_rui_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_rui_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_rui_log_item *\r\nxfs_rui_init(\r\nstruct xfs_mount *mp,\r\nuint nextents)\r\n{\r\nstruct xfs_rui_log_item *ruip;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_RUI_MAX_FAST_EXTENTS)\r\nruip = kmem_zalloc(xfs_rui_log_item_sizeof(nextents), KM_SLEEP);\r\nelse\r\nruip = kmem_zone_zalloc(xfs_rui_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &ruip->rui_item, XFS_LI_RUI, &xfs_rui_item_ops);\r\nruip->rui_format.rui_nextents = nextents;\r\nruip->rui_format.rui_id = (uintptr_t)(void *)ruip;\r\natomic_set(&ruip->rui_next_extent, 0);\r\natomic_set(&ruip->rui_refcount, 2);\r\nreturn ruip;\r\n}\r\nint\r\nxfs_rui_copy_format(\r\nstruct xfs_log_iovec *buf,\r\nstruct xfs_rui_log_format *dst_rui_fmt)\r\n{\r\nstruct xfs_rui_log_format *src_rui_fmt;\r\nuint len;\r\nsrc_rui_fmt = buf->i_addr;\r\nlen = xfs_rui_log_format_sizeof(src_rui_fmt->rui_nextents);\r\nif (buf->i_len != len)\r\nreturn -EFSCORRUPTED;\r\nmemcpy(dst_rui_fmt, src_rui_fmt, len);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_rui_release(\r\nstruct xfs_rui_log_item *ruip)\r\n{\r\nif (atomic_dec_and_test(&ruip->rui_refcount)) {\r\nxfs_trans_ail_remove(&ruip->rui_item, SHUTDOWN_LOG_IO_ERROR);\r\nxfs_rui_item_free(ruip);\r\n}\r\n}\r\nstatic inline struct xfs_rud_log_item *RUD_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_rud_log_item, rud_item);\r\n}\r\nSTATIC void\r\nxfs_rud_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += sizeof(struct xfs_rud_log_format);\r\n}\r\nSTATIC void\r\nxfs_rud_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_rud_log_item *rudp = RUD_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nrudp->rud_format.rud_type = XFS_LI_RUD;\r\nrudp->rud_format.rud_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_RUD_FORMAT, &rudp->rud_format,\r\nsizeof(struct xfs_rud_log_format));\r\n}\r\nSTATIC void\r\nxfs_rud_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_rud_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\n}\r\nSTATIC uint\r\nxfs_rud_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_rud_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_rud_log_item *rudp = RUD_ITEM(lip);\r\nif (lip->li_flags & XFS_LI_ABORTED) {\r\nxfs_rui_release(rudp->rud_ruip);\r\nkmem_zone_free(xfs_rud_zone, rudp);\r\n}\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_rud_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_rud_log_item *rudp = RUD_ITEM(lip);\r\nxfs_rui_release(rudp->rud_ruip);\r\nkmem_zone_free(xfs_rud_zone, rudp);\r\nreturn (xfs_lsn_t)-1;\r\n}\r\nSTATIC void\r\nxfs_rud_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_rud_log_item *\r\nxfs_rud_init(\r\nstruct xfs_mount *mp,\r\nstruct xfs_rui_log_item *ruip)\r\n{\r\nstruct xfs_rud_log_item *rudp;\r\nrudp = kmem_zone_zalloc(xfs_rud_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &rudp->rud_item, XFS_LI_RUD, &xfs_rud_item_ops);\r\nrudp->rud_ruip = ruip;\r\nrudp->rud_format.rud_rui_id = ruip->rui_format.rui_id;\r\nreturn rudp;\r\n}\r\nint\r\nxfs_rui_recover(\r\nstruct xfs_mount *mp,\r\nstruct xfs_rui_log_item *ruip)\r\n{\r\nint i;\r\nint error = 0;\r\nstruct xfs_map_extent *rmap;\r\nxfs_fsblock_t startblock_fsb;\r\nbool op_ok;\r\nstruct xfs_rud_log_item *rudp;\r\nenum xfs_rmap_intent_type type;\r\nint whichfork;\r\nxfs_exntst_t state;\r\nstruct xfs_trans *tp;\r\nstruct xfs_btree_cur *rcur = NULL;\r\nASSERT(!test_bit(XFS_RUI_RECOVERED, &ruip->rui_flags));\r\nfor (i = 0; i < ruip->rui_format.rui_nextents; i++) {\r\nrmap = &ruip->rui_format.rui_extents[i];\r\nstartblock_fsb = XFS_BB_TO_FSB(mp,\r\nXFS_FSB_TO_DADDR(mp, rmap->me_startblock));\r\nswitch (rmap->me_flags & XFS_RMAP_EXTENT_TYPE_MASK) {\r\ncase XFS_RMAP_EXTENT_MAP:\r\ncase XFS_RMAP_EXTENT_MAP_SHARED:\r\ncase XFS_RMAP_EXTENT_UNMAP:\r\ncase XFS_RMAP_EXTENT_UNMAP_SHARED:\r\ncase XFS_RMAP_EXTENT_CONVERT:\r\ncase XFS_RMAP_EXTENT_CONVERT_SHARED:\r\ncase XFS_RMAP_EXTENT_ALLOC:\r\ncase XFS_RMAP_EXTENT_FREE:\r\nop_ok = true;\r\nbreak;\r\ndefault:\r\nop_ok = false;\r\nbreak;\r\n}\r\nif (!op_ok || startblock_fsb == 0 ||\r\nrmap->me_len == 0 ||\r\nstartblock_fsb >= mp->m_sb.sb_dblocks ||\r\nrmap->me_len >= mp->m_sb.sb_agblocks ||\r\n(rmap->me_flags & ~XFS_RMAP_EXTENT_FLAGS)) {\r\nset_bit(XFS_RUI_RECOVERED, &ruip->rui_flags);\r\nxfs_rui_release(ruip);\r\nreturn -EIO;\r\n}\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nrudp = xfs_trans_get_rud(tp, ruip);\r\nfor (i = 0; i < ruip->rui_format.rui_nextents; i++) {\r\nrmap = &ruip->rui_format.rui_extents[i];\r\nstate = (rmap->me_flags & XFS_RMAP_EXTENT_UNWRITTEN) ?\r\nXFS_EXT_UNWRITTEN : XFS_EXT_NORM;\r\nwhichfork = (rmap->me_flags & XFS_RMAP_EXTENT_ATTR_FORK) ?\r\nXFS_ATTR_FORK : XFS_DATA_FORK;\r\nswitch (rmap->me_flags & XFS_RMAP_EXTENT_TYPE_MASK) {\r\ncase XFS_RMAP_EXTENT_MAP:\r\ntype = XFS_RMAP_MAP;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_MAP_SHARED:\r\ntype = XFS_RMAP_MAP_SHARED;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_UNMAP:\r\ntype = XFS_RMAP_UNMAP;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_UNMAP_SHARED:\r\ntype = XFS_RMAP_UNMAP_SHARED;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_CONVERT:\r\ntype = XFS_RMAP_CONVERT;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_CONVERT_SHARED:\r\ntype = XFS_RMAP_CONVERT_SHARED;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_ALLOC:\r\ntype = XFS_RMAP_ALLOC;\r\nbreak;\r\ncase XFS_RMAP_EXTENT_FREE:\r\ntype = XFS_RMAP_FREE;\r\nbreak;\r\ndefault:\r\nerror = -EFSCORRUPTED;\r\ngoto abort_error;\r\n}\r\nerror = xfs_trans_log_finish_rmap_update(tp, rudp, type,\r\nrmap->me_owner, whichfork,\r\nrmap->me_startoff, rmap->me_startblock,\r\nrmap->me_len, state, &rcur);\r\nif (error)\r\ngoto abort_error;\r\n}\r\nxfs_rmap_finish_one_cleanup(tp, rcur, error);\r\nset_bit(XFS_RUI_RECOVERED, &ruip->rui_flags);\r\nerror = xfs_trans_commit(tp);\r\nreturn error;\r\nabort_error:\r\nxfs_rmap_finish_one_cleanup(tp, rcur, error);\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}
