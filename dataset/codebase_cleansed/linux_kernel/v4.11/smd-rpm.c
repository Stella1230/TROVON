int qcom_rpm_smd_write(struct qcom_smd_rpm *rpm,\r\nint state,\r\nu32 type, u32 id,\r\nvoid *buf,\r\nsize_t count)\r\n{\r\nstatic unsigned msg_id = 1;\r\nint left;\r\nint ret;\r\nstruct {\r\nstruct qcom_rpm_header hdr;\r\nstruct qcom_rpm_request req;\r\nu8 payload[];\r\n} *pkt;\r\nsize_t size = sizeof(*pkt) + count;\r\nif (WARN_ON(size >= 256))\r\nreturn -EINVAL;\r\npkt = kmalloc(size, GFP_KERNEL);\r\nif (!pkt)\r\nreturn -ENOMEM;\r\nmutex_lock(&rpm->lock);\r\npkt->hdr.service_type = cpu_to_le32(RPM_SERVICE_TYPE_REQUEST);\r\npkt->hdr.length = cpu_to_le32(sizeof(struct qcom_rpm_request) + count);\r\npkt->req.msg_id = cpu_to_le32(msg_id++);\r\npkt->req.flags = cpu_to_le32(state);\r\npkt->req.type = cpu_to_le32(type);\r\npkt->req.id = cpu_to_le32(id);\r\npkt->req.data_len = cpu_to_le32(count);\r\nmemcpy(pkt->payload, buf, count);\r\nret = qcom_smd_send(rpm->rpm_channel, pkt, size);\r\nif (ret)\r\ngoto out;\r\nleft = wait_for_completion_timeout(&rpm->ack, RPM_REQUEST_TIMEOUT);\r\nif (!left)\r\nret = -ETIMEDOUT;\r\nelse\r\nret = rpm->ack_status;\r\nout:\r\nkfree(pkt);\r\nmutex_unlock(&rpm->lock);\r\nreturn ret;\r\n}\r\nstatic int qcom_smd_rpm_callback(struct qcom_smd_channel *channel,\r\nconst void *data,\r\nsize_t count)\r\n{\r\nconst struct qcom_rpm_header *hdr = data;\r\nsize_t hdr_length = le32_to_cpu(hdr->length);\r\nconst struct qcom_rpm_message *msg;\r\nstruct qcom_smd_rpm *rpm = qcom_smd_get_drvdata(channel);\r\nconst u8 *buf = data + sizeof(struct qcom_rpm_header);\r\nconst u8 *end = buf + hdr_length;\r\nchar msgbuf[32];\r\nint status = 0;\r\nu32 len, msg_length;\r\nif (le32_to_cpu(hdr->service_type) != RPM_SERVICE_TYPE_REQUEST ||\r\nhdr_length < sizeof(struct qcom_rpm_message)) {\r\ndev_err(rpm->dev, "invalid request\n");\r\nreturn 0;\r\n}\r\nwhile (buf < end) {\r\nmsg = (struct qcom_rpm_message *)buf;\r\nmsg_length = le32_to_cpu(msg->length);\r\nswitch (le32_to_cpu(msg->msg_type)) {\r\ncase RPM_MSG_TYPE_MSG_ID:\r\nbreak;\r\ncase RPM_MSG_TYPE_ERR:\r\nlen = min_t(u32, ALIGN(msg_length, 4), sizeof(msgbuf));\r\nmemcpy_fromio(msgbuf, msg->message, len);\r\nmsgbuf[len - 1] = 0;\r\nif (!strcmp(msgbuf, "resource does not exist"))\r\nstatus = -ENXIO;\r\nelse\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nbuf = PTR_ALIGN(buf + 2 * sizeof(u32) + msg_length, 4);\r\n}\r\nrpm->ack_status = status;\r\ncomplete(&rpm->ack);\r\nreturn 0;\r\n}\r\nstatic int qcom_smd_rpm_probe(struct qcom_smd_device *sdev)\r\n{\r\nstruct qcom_smd_rpm *rpm;\r\nrpm = devm_kzalloc(&sdev->dev, sizeof(*rpm), GFP_KERNEL);\r\nif (!rpm)\r\nreturn -ENOMEM;\r\nmutex_init(&rpm->lock);\r\ninit_completion(&rpm->ack);\r\nrpm->dev = &sdev->dev;\r\nrpm->rpm_channel = sdev->channel;\r\nqcom_smd_set_drvdata(sdev->channel, rpm);\r\ndev_set_drvdata(&sdev->dev, rpm);\r\nreturn of_platform_populate(sdev->dev.of_node, NULL, NULL, &sdev->dev);\r\n}\r\nstatic void qcom_smd_rpm_remove(struct qcom_smd_device *sdev)\r\n{\r\nof_platform_depopulate(&sdev->dev);\r\n}\r\nstatic int __init qcom_smd_rpm_init(void)\r\n{\r\nreturn qcom_smd_driver_register(&qcom_smd_rpm_driver);\r\n}\r\nstatic void __exit qcom_smd_rpm_exit(void)\r\n{\r\nqcom_smd_driver_unregister(&qcom_smd_rpm_driver);\r\n}
