static bool digicolor_uart_tx_full(struct uart_port *port)\r\n{\r\nreturn !!(readb_relaxed(port->membase + UA_STATUS_FIFO) &\r\nUA_STATUS_FIFO_TX_FULL);\r\n}\r\nstatic bool digicolor_uart_rx_empty(struct uart_port *port)\r\n{\r\nreturn !!(readb_relaxed(port->membase + UA_STATUS_FIFO) &\r\nUA_STATUS_FIFO_RX_EMPTY);\r\n}\r\nstatic void digicolor_uart_stop_tx(struct uart_port *port)\r\n{\r\nu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\r\nint_enable &= ~UA_INT_TX;\r\nwriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\r\n}\r\nstatic void digicolor_uart_start_tx(struct uart_port *port)\r\n{\r\nu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\r\nint_enable |= UA_INT_TX;\r\nwriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\r\n}\r\nstatic void digicolor_uart_stop_rx(struct uart_port *port)\r\n{\r\nu8 int_enable = readb_relaxed(port->membase + UA_INT_ENABLE);\r\nint_enable &= ~UA_INT_RX;\r\nwriteb_relaxed(int_enable, port->membase + UA_INT_ENABLE);\r\n}\r\nstatic void digicolor_rx_poll(struct work_struct *work)\r\n{\r\nstruct digicolor_port *dp =\r\ncontainer_of(to_delayed_work(work),\r\nstruct digicolor_port, rx_poll_work);\r\nif (!digicolor_uart_rx_empty(&dp->port))\r\nwriteb_relaxed(UA_INT_RX, dp->port.membase + UA_INTFLAG_SET);\r\nschedule_delayed_work(&dp->rx_poll_work, msecs_to_jiffies(100));\r\n}\r\nstatic void digicolor_uart_rx(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (1) {\r\nu8 status, ch;\r\nunsigned int ch_flag;\r\nif (digicolor_uart_rx_empty(port))\r\nbreak;\r\nch = readb_relaxed(port->membase + UA_EMI_REC);\r\nstatus = readb_relaxed(port->membase + UA_STATUS);\r\nport->icount.rx++;\r\nch_flag = TTY_NORMAL;\r\nif (status) {\r\nif (status & UA_STATUS_PARITY_ERR)\r\nport->icount.parity++;\r\nelse if (status & UA_STATUS_FRAME_ERR)\r\nport->icount.frame++;\r\nelse if (status & UA_STATUS_OVERRUN_ERR)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & UA_STATUS_PARITY_ERR)\r\nch_flag = TTY_PARITY;\r\nelse if (status & UA_STATUS_FRAME_ERR)\r\nch_flag = TTY_FRAME;\r\nelse if (status & UA_STATUS_OVERRUN_ERR)\r\nch_flag = TTY_OVERRUN;\r\n}\r\nif (status & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, status, UA_STATUS_OVERRUN_ERR, ch,\r\nch_flag);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void digicolor_uart_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned long flags;\r\nif (digicolor_uart_tx_full(port))\r\nreturn;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (port->x_char) {\r\nwriteb_relaxed(port->x_char, port->membase + UA_EMI_REC);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\ndigicolor_uart_stop_tx(port);\r\ngoto out;\r\n}\r\nwhile (!uart_circ_empty(xmit)) {\r\nwriteb(xmit->buf[xmit->tail], port->membase + UA_EMI_REC);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (digicolor_uart_tx_full(port))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nout:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic irqreturn_t digicolor_uart_int(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nu8 int_status = readb_relaxed(port->membase + UA_INT_STATUS);\r\nwriteb_relaxed(UA_INT_RX | UA_INT_TX,\r\nport->membase + UA_INTFLAG_CLEAR);\r\nif (int_status & UA_INT_RX)\r\ndigicolor_uart_rx(port);\r\nif (int_status & UA_INT_TX)\r\ndigicolor_uart_tx(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int digicolor_uart_tx_empty(struct uart_port *port)\r\n{\r\nu8 status = readb_relaxed(port->membase + UA_STATUS);\r\nreturn (status & UA_STATUS_TX_READY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int digicolor_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS;\r\n}\r\nstatic void digicolor_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void digicolor_uart_break_ctl(struct uart_port *port, int state)\r\n{\r\n}\r\nstatic int digicolor_uart_startup(struct uart_port *port)\r\n{\r\nstruct digicolor_port *dp =\r\ncontainer_of(port, struct digicolor_port, port);\r\nwriteb_relaxed(UA_ENABLE_ENABLE, port->membase + UA_ENABLE);\r\nwriteb_relaxed(UA_CONTROL_SOFT_RESET, port->membase + UA_CONTROL);\r\nwriteb_relaxed(0, port->membase + UA_CONTROL);\r\nwriteb_relaxed(UA_CONFIG_FIFO_RX_FIFO_MODE\r\n| UA_CONFIG_FIFO_TX_FIFO_MODE | UA_CONFIG_FIFO_RX_THRESH,\r\nport->membase + UA_CONFIG_FIFO);\r\nwriteb_relaxed(UA_STATUS_FIFO_RX_INT_ALMOST,\r\nport->membase + UA_STATUS_FIFO);\r\nwriteb_relaxed(UA_CONTROL_RX_ENABLE | UA_CONTROL_TX_ENABLE,\r\nport->membase + UA_CONTROL);\r\nwriteb_relaxed(UA_INT_TX | UA_INT_RX,\r\nport->membase + UA_INT_ENABLE);\r\nschedule_delayed_work(&dp->rx_poll_work, msecs_to_jiffies(100));\r\nreturn 0;\r\n}\r\nstatic void digicolor_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct digicolor_port *dp =\r\ncontainer_of(port, struct digicolor_port, port);\r\nwriteb_relaxed(0, port->membase + UA_ENABLE);\r\ncancel_delayed_work_sync(&dp->rx_poll_work);\r\n}\r\nstatic void digicolor_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud, divisor;\r\nu8 config = 0;\r\nunsigned long flags;\r\ntermios->c_cflag &= ~CMSPAR;\r\ntermios->c_iflag &= ~(BRKINT | IGNBRK);\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / (0x10000*16),\r\nport->uartclk / 256);\r\ndivisor = uart_get_divisor(port, baud) - 1;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS7:\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nconfig |= UA_CONFIG_CHAR_LEN;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nconfig |= UA_CONFIG_STOP_BITS;\r\nif (termios->c_cflag & PARENB) {\r\nconfig |= UA_CONFIG_PARITY;\r\nif (termios->c_cflag & PARODD)\r\nconfig |= UA_CONFIG_ODD_PARITY;\r\n}\r\nport->read_status_mask = UA_STATUS_OVERRUN_ERR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UA_STATUS_PARITY_ERR\r\n| UA_STATUS_FRAME_ERR;\r\nport->ignore_status_mask = 0;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= UA_STATUS_OVERRUN_ERR\r\n| UA_STATUS_PARITY_ERR | UA_STATUS_FRAME_ERR;\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nwriteb_relaxed(config, port->membase + UA_CONFIG);\r\nwriteb_relaxed(divisor & 0xff, port->membase + UA_HBAUD_LO);\r\nwriteb_relaxed(divisor >> 8, port->membase + UA_HBAUD_HI);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *digicolor_uart_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_DIGICOLOR) ? "DIGICOLOR USART" : NULL;\r\n}\r\nstatic void digicolor_uart_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_DIGICOLOR;\r\n}\r\nstatic void digicolor_uart_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int digicolor_uart_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void digicolor_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (digicolor_uart_tx_full(port))\r\ncpu_relax();\r\nwriteb_relaxed(ch, port->membase + UA_EMI_REC);\r\n}\r\nstatic void digicolor_uart_console_write(struct console *co, const char *c,\r\nunsigned n)\r\n{\r\nstruct uart_port *port = digicolor_ports[co->index];\r\nu8 status;\r\nunsigned long flags;\r\nint locked = 1;\r\nif (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_console_write(port, c, n, digicolor_uart_console_putchar);\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ndo {\r\nstatus = readb_relaxed(port->membase + UA_STATUS);\r\n} while ((status & UA_STATUS_TX_READY) == 0);\r\n}\r\nstatic int digicolor_uart_console_setup(struct console *co, char *options)\r\n{\r\nint baud = 115200, bits = 8, parity = 'n', flow = 'n';\r\nstruct uart_port *port;\r\nif (co->index < 0 || co->index >= DIGICOLOR_USART_NR)\r\nreturn -EINVAL;\r\nport = digicolor_ports[co->index];\r\nif (!port)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int digicolor_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint irq, ret, index;\r\nstruct digicolor_port *dp;\r\nstruct resource *res;\r\nstruct clk *uart_clk;\r\nif (!np) {\r\ndev_err(&pdev->dev, "Missing device tree node\n");\r\nreturn -ENXIO;\r\n}\r\nindex = of_alias_get_id(np, "serial");\r\nif (index < 0 || index >= DIGICOLOR_USART_NR)\r\nreturn -EINVAL;\r\ndp = devm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);\r\nif (!dp)\r\nreturn -ENOMEM;\r\nuart_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(uart_clk))\r\nreturn PTR_ERR(uart_clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndp->port.mapbase = res->start;\r\ndp->port.membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dp->port.membase))\r\nreturn PTR_ERR(dp->port.membase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ndp->port.irq = irq;\r\ndp->port.iotype = UPIO_MEM;\r\ndp->port.uartclk = clk_get_rate(uart_clk);\r\ndp->port.fifosize = 16;\r\ndp->port.dev = &pdev->dev;\r\ndp->port.ops = &digicolor_uart_ops;\r\ndp->port.line = index;\r\ndp->port.type = PORT_DIGICOLOR;\r\nspin_lock_init(&dp->port.lock);\r\ndigicolor_ports[index] = &dp->port;\r\nplatform_set_drvdata(pdev, &dp->port);\r\nINIT_DELAYED_WORK(&dp->rx_poll_work, digicolor_rx_poll);\r\nret = devm_request_irq(&pdev->dev, dp->port.irq, digicolor_uart_int, 0,\r\ndev_name(&pdev->dev), &dp->port);\r\nif (ret)\r\nreturn ret;\r\nreturn uart_add_one_port(&digicolor_uart, &dp->port);\r\n}\r\nstatic int digicolor_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nuart_remove_one_port(&digicolor_uart, port);\r\nreturn 0;\r\n}\r\nstatic int __init digicolor_uart_init(void)\r\n{\r\nint ret;\r\nif (IS_ENABLED(CONFIG_SERIAL_CONEXANT_DIGICOLOR_CONSOLE)) {\r\ndigicolor_uart.cons = &digicolor_console;\r\ndigicolor_console.data = &digicolor_uart;\r\n}\r\nret = uart_register_driver(&digicolor_uart);\r\nif (ret)\r\nreturn ret;\r\nreturn platform_driver_register(&digicolor_uart_platform);\r\n}\r\nstatic void __exit digicolor_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&digicolor_uart_platform);\r\nuart_unregister_driver(&digicolor_uart);\r\n}
