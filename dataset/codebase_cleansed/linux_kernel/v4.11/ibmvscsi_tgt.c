static void ibmvscsis_determine_resid(struct se_cmd *se_cmd,\r\nstruct srp_rsp *rsp)\r\n{\r\nu32 residual_count = se_cmd->residual_count;\r\nif (!residual_count)\r\nreturn;\r\nif (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\nif (se_cmd->data_direction == DMA_TO_DEVICE) {\r\nrsp->flags = SRP_RSP_FLAG_DOUNDER;\r\nrsp->data_out_res_cnt = cpu_to_be32(residual_count);\r\n} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {\r\nrsp->flags = SRP_RSP_FLAG_DIUNDER;\r\nrsp->data_in_res_cnt = cpu_to_be32(residual_count);\r\n}\r\n} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\nif (se_cmd->data_direction == DMA_TO_DEVICE) {\r\nrsp->flags = SRP_RSP_FLAG_DOOVER;\r\nrsp->data_out_res_cnt = cpu_to_be32(residual_count);\r\n} else if (se_cmd->data_direction == DMA_FROM_DEVICE) {\r\nrsp->flags = SRP_RSP_FLAG_DIOVER;\r\nrsp->data_in_res_cnt = cpu_to_be32(residual_count);\r\n}\r\n}\r\n}\r\nstatic bool connection_broken(struct scsi_info *vscsi)\r\n{\r\nstruct viosrp_crq *crq;\r\nu64 buffer[2] = { 0, 0 };\r\nlong h_return_code;\r\nbool rc = false;\r\ncrq = (struct viosrp_crq *)&buffer;\r\ncrq->valid = VALID_CMD_RESP_EL;\r\ncrq->format = MESSAGE_IN_CRQ;\r\ncrq->status = PING;\r\nh_return_code = h_send_crq(vscsi->dds.unit_id,\r\ncpu_to_be64(buffer[MSG_HI]),\r\ncpu_to_be64(buffer[MSG_LOW]));\r\npr_debug("connection_broken: rc %ld\n", h_return_code);\r\nif (h_return_code == H_CLOSED)\r\nrc = true;\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_unregister_command_q(struct scsi_info *vscsi)\r\n{\r\nlong qrc;\r\nlong rc = ADAPT_SUCCESS;\r\nint ticks = 0;\r\ndo {\r\nqrc = h_free_crq(vscsi->dds.unit_id);\r\nswitch (qrc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_HARDWARE:\r\ncase H_PARAMETER:\r\ndev_err(&vscsi->dev, "unregister_command_q: error from h_free_crq %ld\n",\r\nqrc);\r\nrc = ERROR;\r\nbreak;\r\ncase H_BUSY:\r\ncase H_LONG_BUSY_ORDER_1_MSEC:\r\nusleep_range(1000, 2000);\r\nticks += 1;\r\nbreak;\r\ncase H_LONG_BUSY_ORDER_10_MSEC:\r\nusleep_range(10000, 20000);\r\nticks += 10;\r\nbreak;\r\ncase H_LONG_BUSY_ORDER_100_MSEC:\r\nmsleep(100);\r\nticks += 100;\r\nbreak;\r\ncase H_LONG_BUSY_ORDER_1_SEC:\r\nssleep(1);\r\nticks += 1000;\r\nbreak;\r\ncase H_LONG_BUSY_ORDER_10_SEC:\r\nssleep(10);\r\nticks += 10000;\r\nbreak;\r\ncase H_LONG_BUSY_ORDER_100_SEC:\r\nssleep(100);\r\nticks += 100000;\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "unregister_command_q: unknown error %ld from h_free_crq\n",\r\nqrc);\r\nrc = ERROR;\r\nbreak;\r\n}\r\nif (ticks > 300000 && qrc != H_SUCCESS) {\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "Excessive wait for h_free_crq\n");\r\n}\r\n} while (qrc != H_SUCCESS && rc == ADAPT_SUCCESS);\r\npr_debug("Freeing CRQ: phyp rc %ld, rc %ld\n", qrc, rc);\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_delete_client_info(struct scsi_info *vscsi,\r\nbool client_closed)\r\n{\r\nvscsi->client_cap = 0;\r\nif (client_closed)\r\nvscsi->client_data.os_type = 0;\r\n}\r\nstatic long ibmvscsis_free_command_q(struct scsi_info *vscsi)\r\n{\r\nint bytes;\r\nu32 flags_under_lock;\r\nu16 state_under_lock;\r\nlong rc = ADAPT_SUCCESS;\r\nif (!(vscsi->flags & CRQ_CLOSED)) {\r\nvio_disable_interrupts(vscsi->dma_dev);\r\nstate_under_lock = vscsi->new_state;\r\nflags_under_lock = vscsi->flags;\r\nvscsi->phyp_acr_state = 0;\r\nvscsi->phyp_acr_flags = 0;\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nrc = ibmvscsis_unregister_command_q(vscsi);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nif (state_under_lock != vscsi->new_state)\r\nvscsi->phyp_acr_state = vscsi->new_state;\r\nvscsi->phyp_acr_flags = ((~flags_under_lock) & vscsi->flags);\r\nif (rc == ADAPT_SUCCESS) {\r\nbytes = vscsi->cmd_q.size * PAGE_SIZE;\r\nmemset(vscsi->cmd_q.base_addr, 0, bytes);\r\nvscsi->cmd_q.index = 0;\r\nvscsi->flags |= CRQ_CLOSED;\r\nibmvscsis_delete_client_info(vscsi, false);\r\n}\r\npr_debug("free_command_q: flags 0x%x, state 0x%hx, acr_flags 0x%x, acr_state 0x%hx\n",\r\nvscsi->flags, vscsi->state, vscsi->phyp_acr_flags,\r\nvscsi->phyp_acr_state);\r\n}\r\nreturn rc;\r\n}\r\nstatic struct viosrp_crq *ibmvscsis_cmd_q_dequeue(uint mask,\r\nuint *current_index,\r\nstruct viosrp_crq *base_addr)\r\n{\r\nstruct viosrp_crq *ptr;\r\nptr = base_addr + *current_index;\r\nif (ptr->valid) {\r\n*current_index = (*current_index + 1) & mask;\r\ndma_rmb();\r\n} else {\r\nptr = NULL;\r\n}\r\nreturn ptr;\r\n}\r\nstatic long ibmvscsis_send_init_message(struct scsi_info *vscsi, u8 format)\r\n{\r\nstruct viosrp_crq *crq;\r\nu64 buffer[2] = { 0, 0 };\r\nlong rc;\r\ncrq = (struct viosrp_crq *)&buffer;\r\ncrq->valid = VALID_INIT_MSG;\r\ncrq->format = format;\r\nrc = h_send_crq(vscsi->dds.unit_id, cpu_to_be64(buffer[MSG_HI]),\r\ncpu_to_be64(buffer[MSG_LOW]));\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_check_init_msg(struct scsi_info *vscsi, uint *format)\r\n{\r\nstruct viosrp_crq *crq;\r\nlong rc = ADAPT_SUCCESS;\r\ncrq = ibmvscsis_cmd_q_dequeue(vscsi->cmd_q.mask, &vscsi->cmd_q.index,\r\nvscsi->cmd_q.base_addr);\r\nif (!crq) {\r\n*format = (uint)UNUSED_FORMAT;\r\n} else if (crq->valid == VALID_INIT_MSG && crq->format == INIT_MSG) {\r\n*format = (uint)INIT_MSG;\r\ncrq->valid = INVALIDATE_CMD_RESP_EL;\r\ndma_rmb();\r\ncrq = ibmvscsis_cmd_q_dequeue(vscsi->cmd_q.mask,\r\n&vscsi->cmd_q.index,\r\nvscsi->cmd_q.base_addr);\r\nif (crq) {\r\n*format = (uint)(crq->format);\r\nrc = ERROR;\r\ncrq->valid = INVALIDATE_CMD_RESP_EL;\r\ndma_rmb();\r\n}\r\n} else {\r\n*format = (uint)(crq->format);\r\nrc = ERROR;\r\ncrq->valid = INVALIDATE_CMD_RESP_EL;\r\ndma_rmb();\r\n}\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_disconnect(struct work_struct *work)\r\n{\r\nstruct scsi_info *vscsi = container_of(work, struct scsi_info,\r\nproc_work);\r\nu16 new_state;\r\nbool wait_idle = false;\r\nspin_lock_bh(&vscsi->intr_lock);\r\nnew_state = vscsi->new_state;\r\nvscsi->new_state = 0;\r\npr_debug("disconnect: flags 0x%x, state 0x%hx\n", vscsi->flags,\r\nvscsi->state);\r\nswitch (vscsi->state) {\r\ncase NO_QUEUE:\r\ncase UNCONFIGURING:\r\nbreak;\r\ncase ERR_DISCONNECT:\r\nif (new_state == UNCONFIGURING)\r\nvscsi->state = new_state;\r\nbreak;\r\ncase ERR_DISCONNECT_RECONNECT:\r\nswitch (new_state) {\r\ncase UNCONFIGURING:\r\ncase ERR_DISCONNECT:\r\nvscsi->state = new_state;\r\nbreak;\r\ncase WAIT_IDLE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ERR_DISCONNECTED:\r\nif (new_state == UNCONFIGURING)\r\nvscsi->state = new_state;\r\nbreak;\r\ncase WAIT_ENABLED:\r\nswitch (new_state) {\r\ncase UNCONFIGURING:\r\nvscsi->state = new_state;\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nvscsi->flags &= ~(SCHEDULE_DISCONNECT |\r\nDISCONNECT_SCHEDULED);\r\ndma_rmb();\r\nif (vscsi->flags & CFG_SLEEPING) {\r\nvscsi->flags &= ~CFG_SLEEPING;\r\ncomplete(&vscsi->unconfig);\r\n}\r\nbreak;\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ncase WAIT_IDLE:\r\ndev_err(&vscsi->dev, "disconnect: invalid state %d for WAIT_IDLE\n",\r\nvscsi->state);\r\nbreak;\r\n}\r\nbreak;\r\ncase WAIT_IDLE:\r\nswitch (new_state) {\r\ncase UNCONFIGURING:\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nvscsi->state = new_state;\r\nvscsi->flags &= ~(SCHEDULE_DISCONNECT |\r\nDISCONNECT_SCHEDULED);\r\nibmvscsis_free_command_q(vscsi);\r\nbreak;\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\nvscsi->state = new_state;\r\nbreak;\r\n}\r\nbreak;\r\ncase WAIT_CONNECTION:\r\ncase CONNECTED:\r\ncase SRP_PROCESSING:\r\nwait_idle = true;\r\nvscsi->state = new_state;\r\nbreak;\r\ncase UNDEFINED:\r\nif (new_state == UNCONFIGURING)\r\nvscsi->state = new_state;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (wait_idle) {\r\npr_debug("disconnect start wait, active %d, sched %d\n",\r\n(int)list_empty(&vscsi->active_q),\r\n(int)list_empty(&vscsi->schedule_q));\r\nif (!list_empty(&vscsi->active_q) ||\r\n!list_empty(&vscsi->schedule_q)) {\r\nvscsi->flags |= WAIT_FOR_IDLE;\r\npr_debug("disconnect flags 0x%x\n", vscsi->flags);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nwait_for_completion(&vscsi->wait_idle);\r\nspin_lock_bh(&vscsi->intr_lock);\r\n}\r\npr_debug("disconnect stop wait\n");\r\nibmvscsis_adapter_idle(vscsi);\r\n}\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\nstatic void ibmvscsis_post_disconnect(struct scsi_info *vscsi, uint new_state,\r\nuint flag_bits)\r\n{\r\nuint state;\r\nswitch (new_state) {\r\ncase UNCONFIGURING:\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ncase WAIT_IDLE:\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "post_disconnect: Invalid new state %d\n",\r\nnew_state);\r\nreturn;\r\n}\r\nvscsi->flags |= flag_bits;\r\npr_debug("post_disconnect: new_state 0x%x, flag_bits 0x%x, vscsi->flags 0x%x, state %hx\n",\r\nnew_state, flag_bits, vscsi->flags, vscsi->state);\r\nif (!(vscsi->flags & (DISCONNECT_SCHEDULED | SCHEDULE_DISCONNECT))) {\r\nvscsi->flags |= SCHEDULE_DISCONNECT;\r\nvscsi->new_state = new_state;\r\nINIT_WORK(&vscsi->proc_work, ibmvscsis_disconnect);\r\n(void)queue_work(vscsi->work_q, &vscsi->proc_work);\r\n} else {\r\nif (vscsi->new_state)\r\nstate = vscsi->new_state;\r\nelse\r\nstate = vscsi->state;\r\nswitch (state) {\r\ncase NO_QUEUE:\r\ncase UNCONFIGURING:\r\nbreak;\r\ncase ERR_DISCONNECTED:\r\ncase ERR_DISCONNECT:\r\ncase UNDEFINED:\r\nif (new_state == UNCONFIGURING)\r\nvscsi->new_state = new_state;\r\nbreak;\r\ncase ERR_DISCONNECT_RECONNECT:\r\nswitch (new_state) {\r\ncase UNCONFIGURING:\r\ncase ERR_DISCONNECT:\r\nvscsi->new_state = new_state;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase WAIT_ENABLED:\r\ncase WAIT_IDLE:\r\ncase WAIT_CONNECTION:\r\ncase CONNECTED:\r\ncase SRP_PROCESSING:\r\nvscsi->new_state = new_state;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\npr_debug("Leaving post_disconnect: flags 0x%x, new_state 0x%x\n",\r\nvscsi->flags, vscsi->new_state);\r\n}\r\nstatic long ibmvscsis_handle_init_compl_msg(struct scsi_info *vscsi)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\nswitch (vscsi->state) {\r\ncase NO_QUEUE:\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ncase ERR_DISCONNECTED:\r\ncase UNCONFIGURING:\r\ncase UNDEFINED:\r\nrc = ERROR;\r\nbreak;\r\ncase WAIT_CONNECTION:\r\nvscsi->state = CONNECTED;\r\nbreak;\r\ncase WAIT_IDLE:\r\ncase SRP_PROCESSING:\r\ncase CONNECTED:\r\ncase WAIT_ENABLED:\r\ndefault:\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "init_msg: invalid state %d to get init compl msg\n",\r\nvscsi->state);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_handle_init_msg(struct scsi_info *vscsi)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\nswitch (vscsi->state) {\r\ncase WAIT_CONNECTION:\r\nrc = ibmvscsis_send_init_message(vscsi, INIT_COMPLETE_MSG);\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nvscsi->state = CONNECTED;\r\nbreak;\r\ncase H_PARAMETER:\r\ndev_err(&vscsi->dev, "init_msg: failed to send, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\r\nbreak;\r\ncase H_DROPPED:\r\ndev_err(&vscsi->dev, "init_msg: failed to send, rc %ld\n",\r\nrc);\r\nrc = ERROR;\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\ncase H_CLOSED:\r\npr_warn("init_msg: failed to send, rc %ld\n", rc);\r\nrc = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase UNDEFINED:\r\nrc = ERROR;\r\nbreak;\r\ncase UNCONFIGURING:\r\nbreak;\r\ncase WAIT_ENABLED:\r\ncase CONNECTED:\r\ncase SRP_PROCESSING:\r\ncase WAIT_IDLE:\r\ncase NO_QUEUE:\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ncase ERR_DISCONNECTED:\r\ndefault:\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "init_msg: invalid state %d to get init msg\n",\r\nvscsi->state);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_init_msg(struct scsi_info *vscsi, struct viosrp_crq *crq)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\npr_debug("init_msg: state 0x%hx\n", vscsi->state);\r\nrc = h_vioctl(vscsi->dds.unit_id, H_GET_PARTNER_INFO,\r\n(u64)vscsi->map_ioba | ((u64)PAGE_SIZE << 32), 0, 0, 0,\r\n0);\r\nif (rc == H_SUCCESS) {\r\nvscsi->client_data.partition_number =\r\nbe64_to_cpu(*(u64 *)vscsi->map_buf);\r\npr_debug("init_msg, part num %d\n",\r\nvscsi->client_data.partition_number);\r\n} else {\r\npr_debug("init_msg h_vioctl rc %ld\n", rc);\r\nrc = ADAPT_SUCCESS;\r\n}\r\nif (crq->format == INIT_MSG) {\r\nrc = ibmvscsis_handle_init_msg(vscsi);\r\n} else if (crq->format == INIT_COMPLETE_MSG) {\r\nrc = ibmvscsis_handle_init_compl_msg(vscsi);\r\n} else {\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "init_msg: invalid format %d\n",\r\n(uint)crq->format);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_establish_new_q(struct scsi_info *vscsi)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\nuint format;\r\nvscsi->flags &= PRESERVE_FLAG_FIELDS;\r\nvscsi->rsp_q_timer.timer_pops = 0;\r\nvscsi->debit = 0;\r\nvscsi->credit = 0;\r\nrc = vio_enable_interrupts(vscsi->dma_dev);\r\nif (rc) {\r\npr_warn("establish_new_q: failed to enable interrupts, rc %ld\n",\r\nrc);\r\nreturn rc;\r\n}\r\nrc = ibmvscsis_check_init_msg(vscsi, &format);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "establish_new_q: check_init_msg failed, rc %ld\n",\r\nrc);\r\nreturn rc;\r\n}\r\nif (format == UNUSED_FORMAT) {\r\nrc = ibmvscsis_send_init_message(vscsi, INIT_MSG);\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\ncase H_DROPPED:\r\ncase H_CLOSED:\r\nrc = ADAPT_SUCCESS;\r\nbreak;\r\ncase H_PARAMETER:\r\ncase H_HARDWARE:\r\nbreak;\r\ndefault:\r\nvscsi->state = UNDEFINED;\r\nrc = H_HARDWARE;\r\nbreak;\r\n}\r\n} else if (format == INIT_MSG) {\r\nrc = ibmvscsis_handle_init_msg(vscsi);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_reset_queue(struct scsi_info *vscsi)\r\n{\r\nint bytes;\r\nlong rc = ADAPT_SUCCESS;\r\npr_debug("reset_queue: flags 0x%x\n", vscsi->flags);\r\nif (vscsi->flags & (CLIENT_FAILED | TRANS_EVENT)) {\r\nvscsi->flags &= PRESERVE_FLAG_FIELDS;\r\nvscsi->rsp_q_timer.timer_pops = 0;\r\nvscsi->debit = 0;\r\nvscsi->credit = 0;\r\nvscsi->state = WAIT_CONNECTION;\r\nvio_enable_interrupts(vscsi->dma_dev);\r\n} else {\r\nrc = ibmvscsis_free_command_q(vscsi);\r\nif (rc == ADAPT_SUCCESS) {\r\nvscsi->state = WAIT_CONNECTION;\r\nbytes = vscsi->cmd_q.size * PAGE_SIZE;\r\nrc = h_reg_crq(vscsi->dds.unit_id,\r\nvscsi->cmd_q.crq_token, bytes);\r\nif (rc == H_CLOSED || rc == H_SUCCESS) {\r\nrc = ibmvscsis_establish_new_q(vscsi);\r\n}\r\nif (rc != ADAPT_SUCCESS) {\r\npr_debug("reset_queue: reg_crq rc %ld\n", rc);\r\nvscsi->state = ERR_DISCONNECTED;\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nibmvscsis_free_command_q(vscsi);\r\n}\r\n} else {\r\nvscsi->state = ERR_DISCONNECTED;\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\n}\r\n}\r\n}\r\nstatic void ibmvscsis_free_cmd_resources(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nswitch (cmd->type) {\r\ncase TASK_MANAGEMENT:\r\ncase SCSI_CDB:\r\nif (vscsi->debit)\r\nvscsi->debit -= 1;\r\nbreak;\r\ncase ADAPTER_MAD:\r\nvscsi->flags &= ~PROCESSING_MAD;\r\nbreak;\r\ncase UNSET_TYPE:\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "free_cmd_resources unknown type %d\n",\r\ncmd->type);\r\nbreak;\r\n}\r\ncmd->iue = NULL;\r\nlist_add_tail(&cmd->list, &vscsi->free_cmd);\r\nsrp_iu_put(iue);\r\nif (list_empty(&vscsi->active_q) && list_empty(&vscsi->schedule_q) &&\r\nlist_empty(&vscsi->waiting_rsp) && (vscsi->flags & WAIT_FOR_IDLE)) {\r\nvscsi->flags &= ~WAIT_FOR_IDLE;\r\ncomplete(&vscsi->wait_idle);\r\n}\r\n}\r\nstatic long ibmvscsis_trans_event(struct scsi_info *vscsi,\r\nstruct viosrp_crq *crq)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\npr_debug("trans_event: format %d, flags 0x%x, state 0x%hx\n",\r\n(int)crq->format, vscsi->flags, vscsi->state);\r\nswitch (crq->format) {\r\ncase MIGRATED:\r\ncase PARTNER_FAILED:\r\ncase PARTNER_DEREGISTER:\r\nibmvscsis_delete_client_info(vscsi, true);\r\nbreak;\r\ndefault:\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "trans_event: invalid format %d\n",\r\n(uint)crq->format);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT,\r\nRESPONSE_Q_DOWN);\r\nbreak;\r\n}\r\nif (rc == ADAPT_SUCCESS) {\r\nswitch (vscsi->state) {\r\ncase NO_QUEUE:\r\ncase ERR_DISCONNECTED:\r\ncase UNDEFINED:\r\nbreak;\r\ncase UNCONFIGURING:\r\nvscsi->flags |= (RESPONSE_Q_DOWN | TRANS_EVENT);\r\nbreak;\r\ncase WAIT_ENABLED:\r\nbreak;\r\ncase WAIT_CONNECTION:\r\nbreak;\r\ncase CONNECTED:\r\nibmvscsis_post_disconnect(vscsi, WAIT_IDLE,\r\n(RESPONSE_Q_DOWN |\r\nTRANS_EVENT));\r\nbreak;\r\ncase SRP_PROCESSING:\r\nif ((vscsi->debit > 0) ||\r\n!list_empty(&vscsi->schedule_q) ||\r\n!list_empty(&vscsi->waiting_rsp) ||\r\n!list_empty(&vscsi->active_q)) {\r\npr_debug("debit %d, sched %d, wait %d, active %d\n",\r\nvscsi->debit,\r\n(int)list_empty(&vscsi->schedule_q),\r\n(int)list_empty(&vscsi->waiting_rsp),\r\n(int)list_empty(&vscsi->active_q));\r\npr_warn("connection lost with outstanding work\n");\r\n} else {\r\npr_debug("trans_event: SRP Processing, but no outstanding work\n");\r\n}\r\nibmvscsis_post_disconnect(vscsi, WAIT_IDLE,\r\n(RESPONSE_Q_DOWN |\r\nTRANS_EVENT));\r\nbreak;\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ncase WAIT_IDLE:\r\nvscsi->flags |= (RESPONSE_Q_DOWN | TRANS_EVENT);\r\nbreak;\r\n}\r\n}\r\nrc = vscsi->flags & SCHEDULE_DISCONNECT;\r\npr_debug("Leaving trans_event: flags 0x%x, state 0x%hx, rc %ld\n",\r\nvscsi->flags, vscsi->state, rc);\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_poll_cmd_q(struct scsi_info *vscsi)\r\n{\r\nstruct viosrp_crq *crq;\r\nlong rc;\r\nbool ack = true;\r\nvolatile u8 valid;\r\npr_debug("poll_cmd_q: flags 0x%x, state 0x%hx, q index %ud\n",\r\nvscsi->flags, vscsi->state, vscsi->cmd_q.index);\r\nrc = vscsi->flags & SCHEDULE_DISCONNECT;\r\ncrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\r\nvalid = crq->valid;\r\ndma_rmb();\r\nwhile (valid) {\r\npoll_work:\r\nvscsi->cmd_q.index =\r\n(vscsi->cmd_q.index + 1) & vscsi->cmd_q.mask;\r\nif (!rc) {\r\nrc = ibmvscsis_parse_command(vscsi, crq);\r\n} else {\r\nif ((uint)crq->valid == VALID_TRANS_EVENT) {\r\nrc = ibmvscsis_trans_event(vscsi, crq);\r\n} else if (vscsi->flags & TRANS_EVENT) {\r\npr_debug("poll_cmd_q, ignoring\n");\r\nif (vscsi->cmd_q.index)\r\nvscsi->cmd_q.index -= 1;\r\nelse\r\nvscsi->cmd_q.index = vscsi->cmd_q.mask;\r\nbreak;\r\n}\r\n}\r\ncrq->valid = INVALIDATE_CMD_RESP_EL;\r\ncrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\r\nvalid = crq->valid;\r\ndma_rmb();\r\n}\r\nif (!rc) {\r\nif (ack) {\r\nvio_enable_interrupts(vscsi->dma_dev);\r\nack = false;\r\npr_debug("poll_cmd_q, reenabling interrupts\n");\r\n}\r\nvalid = crq->valid;\r\ndma_rmb();\r\nif (valid)\r\ngoto poll_work;\r\n}\r\npr_debug("Leaving poll_cmd_q: rc %ld\n", rc);\r\n}\r\nstatic void ibmvscsis_free_cmd_qs(struct scsi_info *vscsi)\r\n{\r\nstruct ibmvscsis_cmd *cmd, *nxt;\r\npr_debug("free_cmd_qs: waiting_rsp empty %d, timer starter %d\n",\r\n(int)list_empty(&vscsi->waiting_rsp),\r\nvscsi->rsp_q_timer.started);\r\nlist_for_each_entry_safe(cmd, nxt, &vscsi->waiting_rsp, list) {\r\nlist_del(&cmd->list);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\n}\r\n}\r\nstatic struct ibmvscsis_cmd *ibmvscsis_get_free_cmd(struct scsi_info *vscsi)\r\n{\r\nstruct ibmvscsis_cmd *cmd = NULL;\r\nstruct iu_entry *iue;\r\niue = srp_iu_get(&vscsi->target);\r\nif (iue) {\r\ncmd = list_first_entry_or_null(&vscsi->free_cmd,\r\nstruct ibmvscsis_cmd, list);\r\nif (cmd) {\r\nlist_del(&cmd->list);\r\ncmd->iue = iue;\r\ncmd->type = UNSET_TYPE;\r\nmemset(&cmd->se_cmd, 0, sizeof(cmd->se_cmd));\r\n} else {\r\nsrp_iu_put(iue);\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstatic void ibmvscsis_adapter_idle(struct scsi_info *vscsi)\r\n{\r\nint free_qs = false;\r\npr_debug("adapter_idle: flags 0x%x, state 0x%hx\n", vscsi->flags,\r\nvscsi->state);\r\nif (vscsi->state != WAIT_CONNECTION || vscsi->flags & TRANS_EVENT)\r\nfree_qs = true;\r\nswitch (vscsi->state) {\r\ncase UNCONFIGURING:\r\nibmvscsis_free_command_q(vscsi);\r\ndma_rmb();\r\nisync();\r\nif (vscsi->flags & CFG_SLEEPING) {\r\nvscsi->flags &= ~CFG_SLEEPING;\r\ncomplete(&vscsi->unconfig);\r\n}\r\nbreak;\r\ncase ERR_DISCONNECT_RECONNECT:\r\nibmvscsis_reset_queue(vscsi);\r\npr_debug("adapter_idle, disc_rec: flags 0x%x\n", vscsi->flags);\r\nbreak;\r\ncase ERR_DISCONNECT:\r\nibmvscsis_free_command_q(vscsi);\r\nvscsi->flags &= ~(SCHEDULE_DISCONNECT | DISCONNECT_SCHEDULED);\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nif (vscsi->tport.enabled)\r\nvscsi->state = ERR_DISCONNECTED;\r\nelse\r\nvscsi->state = WAIT_ENABLED;\r\npr_debug("adapter_idle, disc: flags 0x%x, state 0x%hx\n",\r\nvscsi->flags, vscsi->state);\r\nbreak;\r\ncase WAIT_IDLE:\r\nvscsi->rsp_q_timer.timer_pops = 0;\r\nvscsi->debit = 0;\r\nvscsi->credit = 0;\r\nif (vscsi->flags & TRANS_EVENT) {\r\nvscsi->state = WAIT_CONNECTION;\r\nvscsi->flags &= PRESERVE_FLAG_FIELDS;\r\n} else {\r\nvscsi->state = CONNECTED;\r\nvscsi->flags &= ~DISCONNECT_SCHEDULED;\r\n}\r\npr_debug("adapter_idle, wait: flags 0x%x, state 0x%hx\n",\r\nvscsi->flags, vscsi->state);\r\nibmvscsis_poll_cmd_q(vscsi);\r\nbreak;\r\ncase ERR_DISCONNECTED:\r\nvscsi->flags &= ~DISCONNECT_SCHEDULED;\r\npr_debug("adapter_idle, disconnected: flags 0x%x, state 0x%hx\n",\r\nvscsi->flags, vscsi->state);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "adapter_idle: in invalid state %d\n",\r\nvscsi->state);\r\nbreak;\r\n}\r\nif (free_qs)\r\nibmvscsis_free_cmd_qs(vscsi);\r\nif (vscsi->phyp_acr_state != 0) {\r\nvscsi->flags |= vscsi->phyp_acr_flags;\r\nibmvscsis_post_disconnect(vscsi, vscsi->phyp_acr_state, 0);\r\nvscsi->phyp_acr_state = 0;\r\nvscsi->phyp_acr_flags = 0;\r\npr_debug("adapter_idle: flags 0x%x, state 0x%hx, acr_flags 0x%x, acr_state 0x%hx\n",\r\nvscsi->flags, vscsi->state, vscsi->phyp_acr_flags,\r\nvscsi->phyp_acr_state);\r\n}\r\npr_debug("Leaving adapter_idle: flags 0x%x, state 0x%hx, new_state 0x%x\n",\r\nvscsi->flags, vscsi->state, vscsi->new_state);\r\n}\r\nstatic long ibmvscsis_copy_crq_packet(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd,\r\nstruct viosrp_crq *crq)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nlong rc = 0;\r\nu16 len;\r\nlen = be16_to_cpu(crq->IU_length);\r\nif ((len > SRP_MAX_IU_LEN) || (len == 0)) {\r\ndev_err(&vscsi->dev, "copy_crq: Invalid len %d passed", len);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nreturn SRP_VIOLATION;\r\n}\r\nrc = h_copy_rdma(len, vscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(crq->IU_data_ptr),\r\nvscsi->dds.window[LOCAL].liobn, iue->sbuf->dma);\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\ncmd->init_time = mftb();\r\niue->remote_token = crq->IU_data_ptr;\r\niue->iu_len = len;\r\npr_debug("copy_crq: ioba 0x%llx, init_time 0x%llx\n",\r\nbe64_to_cpu(crq->IU_data_ptr), cmd->init_time);\r\nbreak;\r\ncase H_PERMISSION:\r\nif (connection_broken(vscsi))\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT,\r\n(RESPONSE_Q_DOWN |\r\nCLIENT_FAILED));\r\nelse\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT, 0);\r\ndev_err(&vscsi->dev, "copy_crq: h_copy_rdma failed, rc %ld\n",\r\nrc);\r\nbreak;\r\ncase H_DEST_PARM:\r\ncase H_SOURCE_PARM:\r\ndefault:\r\ndev_err(&vscsi->dev, "copy_crq: h_copy_rdma failed, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_adapter_info(struct scsi_info *vscsi,\r\nstruct iu_entry *iue)\r\n{\r\nstruct viosrp_adapter_info *mad = &vio_iu(iue)->mad.adapter_info;\r\nstruct mad_adapter_info_data *info;\r\nuint flag_bits = 0;\r\ndma_addr_t token;\r\nlong rc;\r\nmad->common.status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\r\nif (be16_to_cpu(mad->common.length) > sizeof(*info)) {\r\nmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\r\nreturn 0;\r\n}\r\ninfo = dma_alloc_coherent(&vscsi->dma_dev->dev, sizeof(*info), &token,\r\nGFP_ATOMIC);\r\nif (!info) {\r\ndev_err(&vscsi->dev, "bad dma_alloc_coherent %p\n",\r\niue->target);\r\nmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\r\nreturn 0;\r\n}\r\nrc = h_copy_rdma(be16_to_cpu(mad->common.length),\r\nvscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(mad->buffer),\r\nvscsi->dds.window[LOCAL].liobn, token);\r\nif (rc != H_SUCCESS) {\r\nif (rc == H_PERMISSION) {\r\nif (connection_broken(vscsi))\r\nflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\r\n}\r\npr_warn("adapter_info: h_copy_rdma from client failed, rc %ld\n",\r\nrc);\r\npr_debug("adapter_info: ioba 0x%llx, flags 0x%x, flag_bits 0x%x\n",\r\nbe64_to_cpu(mad->buffer), vscsi->flags, flag_bits);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\ngoto free_dma;\r\n}\r\nif (vscsi->client_data.partition_number == 0)\r\nvscsi->client_data.partition_number =\r\nbe32_to_cpu(info->partition_number);\r\nstrncpy(vscsi->client_data.srp_version, info->srp_version,\r\nsizeof(vscsi->client_data.srp_version));\r\nstrncpy(vscsi->client_data.partition_name, info->partition_name,\r\nsizeof(vscsi->client_data.partition_name));\r\nvscsi->client_data.mad_version = be32_to_cpu(info->mad_version);\r\nvscsi->client_data.os_type = be32_to_cpu(info->os_type);\r\nstrncpy(info->srp_version, SRP_VERSION,\r\nsizeof(info->srp_version));\r\nstrncpy(info->partition_name, vscsi->dds.partition_name,\r\nsizeof(info->partition_name));\r\ninfo->partition_number = cpu_to_be32(vscsi->dds.partition_num);\r\ninfo->mad_version = cpu_to_be32(MAD_VERSION_1);\r\ninfo->os_type = cpu_to_be32(LINUX);\r\nmemset(&info->port_max_txu[0], 0, sizeof(info->port_max_txu));\r\ninfo->port_max_txu[0] = cpu_to_be32(MAX_TXU);\r\ndma_wmb();\r\nrc = h_copy_rdma(sizeof(*info), vscsi->dds.window[LOCAL].liobn,\r\ntoken, vscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(mad->buffer));\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_SOURCE_PARM:\r\ncase H_DEST_PARM:\r\ncase H_PERMISSION:\r\nif (connection_broken(vscsi))\r\nflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\r\ndefault:\r\ndev_err(&vscsi->dev, "adapter_info: h_copy_rdma to client failed, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\nbreak;\r\n}\r\nfree_dma:\r\ndma_free_coherent(&vscsi->dma_dev->dev, sizeof(*info), info, token);\r\npr_debug("Leaving adapter_info, rc %ld\n", rc);\r\nreturn rc;\r\n}\r\nstatic int ibmvscsis_cap_mad(struct scsi_info *vscsi, struct iu_entry *iue)\r\n{\r\nstruct viosrp_capabilities *mad = &vio_iu(iue)->mad.capabilities;\r\nstruct capabilities *cap;\r\nstruct mad_capability_common *common;\r\ndma_addr_t token;\r\nu16 olen, len, status, min_len, cap_len;\r\nu32 flag;\r\nuint flag_bits = 0;\r\nlong rc = 0;\r\nolen = be16_to_cpu(mad->common.length);\r\nmin_len = offsetof(struct capabilities, migration);\r\nif ((olen < min_len) || (olen > PAGE_SIZE)) {\r\npr_warn("cap_mad: invalid len %d\n", olen);\r\nmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\r\nreturn 0;\r\n}\r\ncap = dma_alloc_coherent(&vscsi->dma_dev->dev, olen, &token,\r\nGFP_ATOMIC);\r\nif (!cap) {\r\ndev_err(&vscsi->dev, "bad dma_alloc_coherent %p\n",\r\niue->target);\r\nmad->common.status = cpu_to_be16(VIOSRP_MAD_FAILED);\r\nreturn 0;\r\n}\r\nrc = h_copy_rdma(olen, vscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(mad->buffer),\r\nvscsi->dds.window[LOCAL].liobn, token);\r\nif (rc == H_SUCCESS) {\r\nstrncpy(cap->name, dev_name(&vscsi->dma_dev->dev),\r\nSRP_MAX_LOC_LEN);\r\nlen = olen - min_len;\r\nstatus = VIOSRP_MAD_SUCCESS;\r\ncommon = (struct mad_capability_common *)&cap->migration;\r\nwhile ((len > 0) && (status == VIOSRP_MAD_SUCCESS) && !rc) {\r\npr_debug("cap_mad: len left %hd, cap type %d, cap len %hd\n",\r\nlen, be32_to_cpu(common->cap_type),\r\nbe16_to_cpu(common->length));\r\ncap_len = be16_to_cpu(common->length);\r\nif (cap_len > len) {\r\ndev_err(&vscsi->dev, "cap_mad: cap len mismatch with total len\n");\r\nstatus = VIOSRP_MAD_FAILED;\r\nbreak;\r\n}\r\nif (cap_len == 0) {\r\ndev_err(&vscsi->dev, "cap_mad: cap len is 0\n");\r\nstatus = VIOSRP_MAD_FAILED;\r\nbreak;\r\n}\r\nswitch (common->cap_type) {\r\ndefault:\r\npr_debug("cap_mad: unsupported capability\n");\r\ncommon->server_support = 0;\r\nflag = cpu_to_be32((u32)CAP_LIST_SUPPORTED);\r\ncap->flags &= ~flag;\r\nbreak;\r\n}\r\nlen = len - cap_len;\r\ncommon = (struct mad_capability_common *)\r\n((char *)common + cap_len);\r\n}\r\nmad->common.status = cpu_to_be16(status);\r\ndma_wmb();\r\nrc = h_copy_rdma(olen, vscsi->dds.window[LOCAL].liobn, token,\r\nvscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(mad->buffer));\r\nif (rc != H_SUCCESS) {\r\npr_debug("cap_mad: failed to copy to client, rc %ld\n",\r\nrc);\r\nif (rc == H_PERMISSION) {\r\nif (connection_broken(vscsi))\r\nflag_bits = (RESPONSE_Q_DOWN |\r\nCLIENT_FAILED);\r\n}\r\npr_warn("cap_mad: error copying data to client, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\n}\r\n}\r\ndma_free_coherent(&vscsi->dma_dev->dev, olen, cap, token);\r\npr_debug("Leaving cap_mad, rc %ld, client_cap 0x%x\n",\r\nrc, vscsi->client_cap);\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_process_mad(struct scsi_info *vscsi, struct iu_entry *iue)\r\n{\r\nstruct mad_common *mad = (struct mad_common *)&vio_iu(iue)->mad;\r\nstruct viosrp_empty_iu *empty;\r\nlong rc = ADAPT_SUCCESS;\r\nswitch (be32_to_cpu(mad->type)) {\r\ncase VIOSRP_EMPTY_IU_TYPE:\r\nempty = &vio_iu(iue)->mad.empty_iu;\r\nvscsi->empty_iu_id = be64_to_cpu(empty->buffer);\r\nvscsi->empty_iu_tag = be64_to_cpu(empty->common.tag);\r\nmad->status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\r\nbreak;\r\ncase VIOSRP_ADAPTER_INFO_TYPE:\r\nrc = ibmvscsis_adapter_info(vscsi, iue);\r\nbreak;\r\ncase VIOSRP_CAPABILITIES_TYPE:\r\nrc = ibmvscsis_cap_mad(vscsi, iue);\r\nbreak;\r\ncase VIOSRP_ENABLE_FAST_FAIL:\r\nif (vscsi->state == CONNECTED) {\r\nvscsi->fast_fail = true;\r\nmad->status = cpu_to_be16(VIOSRP_MAD_SUCCESS);\r\n} else {\r\npr_warn("fast fail mad sent after login\n");\r\nmad->status = cpu_to_be16(VIOSRP_MAD_FAILED);\r\n}\r\nbreak;\r\ndefault:\r\nmad->status = cpu_to_be16(VIOSRP_MAD_NOT_SUPPORTED);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void srp_snd_msg_failed(struct scsi_info *vscsi, long rc)\r\n{\r\nktime_t kt;\r\nif (rc != H_DROPPED) {\r\nibmvscsis_free_cmd_qs(vscsi);\r\nif (rc == H_CLOSED)\r\nvscsi->flags |= CLIENT_FAILED;\r\nif (!(vscsi->flags & RESPONSE_Q_DOWN)) {\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nif (!(vscsi->state & (ERR_DISCONNECT |\r\nERR_DISCONNECT_RECONNECT |\r\nERR_DISCONNECTED | UNDEFINED))) {\r\ndev_err(&vscsi->dev, "snd_msg_failed: setting RESPONSE_Q_DOWN, state 0x%hx, flags 0x%x, rc %ld\n",\r\nvscsi->state, vscsi->flags, rc);\r\n}\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT, 0);\r\n}\r\nreturn;\r\n}\r\nif ((vscsi->rsp_q_timer.timer_pops < MAX_TIMER_POPS) ||\r\n(vscsi->state == SRP_PROCESSING)) {\r\npr_debug("snd_msg_failed: response queue full, flags 0x%x, timer started %d, pops %d\n",\r\nvscsi->flags, (int)vscsi->rsp_q_timer.started,\r\nvscsi->rsp_q_timer.timer_pops);\r\nif (!vscsi->rsp_q_timer.started) {\r\nif (vscsi->rsp_q_timer.timer_pops <\r\nMAX_TIMER_POPS) {\r\nkt = WAIT_NANO_SECONDS;\r\n} else {\r\nkt = ktime_set(WAIT_SECONDS, 0);\r\n}\r\nvscsi->rsp_q_timer.started = true;\r\nhrtimer_start(&vscsi->rsp_q_timer.timer, kt,\r\nHRTIMER_MODE_REL);\r\n}\r\n} else {\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\nibmvscsis_free_cmd_qs(vscsi);\r\nif (!(vscsi->state & (ERR_DISCONNECT |\r\nERR_DISCONNECT_RECONNECT |\r\nERR_DISCONNECTED | UNDEFINED))) {\r\ndev_err(&vscsi->dev, "client crq full too long\n");\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT,\r\n0);\r\n}\r\n}\r\n}\r\nstatic void ibmvscsis_send_messages(struct scsi_info *vscsi)\r\n{\r\nu64 msg_hi = 0;\r\nstruct viosrp_crq *crq = (struct viosrp_crq *)&msg_hi;\r\nstruct ibmvscsis_cmd *cmd, *nxt;\r\nstruct iu_entry *iue;\r\nlong rc = ADAPT_SUCCESS;\r\nif (!(vscsi->flags & RESPONSE_Q_DOWN)) {\r\nlist_for_each_entry_safe(cmd, nxt, &vscsi->waiting_rsp, list) {\r\niue = cmd->iue;\r\ncrq->valid = VALID_CMD_RESP_EL;\r\ncrq->format = cmd->rsp.format;\r\nif (cmd->flags & CMD_FAST_FAIL)\r\ncrq->status = VIOSRP_ADAPTER_FAIL;\r\ncrq->IU_length = cpu_to_be16(cmd->rsp.len);\r\nrc = h_send_crq(vscsi->dma_dev->unit_address,\r\nbe64_to_cpu(msg_hi),\r\nbe64_to_cpu(cmd->rsp.tag));\r\npr_debug("send_messages: cmd %p, tag 0x%llx, rc %ld\n",\r\ncmd, be64_to_cpu(cmd->rsp.tag), rc);\r\nif (rc == H_SUCCESS) {\r\nvscsi->rsp_q_timer.timer_pops = 0;\r\nlist_del(&cmd->list);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\n} else {\r\nsrp_snd_msg_failed(vscsi, rc);\r\nbreak;\r\n}\r\n}\r\nif (!rc) {\r\nvscsi->rsp_q_timer.timer_pops = 0;\r\n}\r\n} else {\r\nibmvscsis_free_cmd_qs(vscsi);\r\n}\r\n}\r\nstatic void ibmvscsis_send_mad_resp(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd,\r\nstruct viosrp_crq *crq)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct mad_common *mad = (struct mad_common *)&vio_iu(iue)->mad;\r\nuint flag_bits = 0;\r\nlong rc;\r\ndma_wmb();\r\nrc = h_copy_rdma(sizeof(struct mad_common),\r\nvscsi->dds.window[LOCAL].liobn, iue->sbuf->dma,\r\nvscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(crq->IU_data_ptr));\r\nif (!rc) {\r\ncmd->rsp.format = VIOSRP_MAD_FORMAT;\r\ncmd->rsp.len = sizeof(struct mad_common);\r\ncmd->rsp.tag = mad->tag;\r\nlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\r\nibmvscsis_send_messages(vscsi);\r\n} else {\r\npr_debug("Error sending mad response, rc %ld\n", rc);\r\nif (rc == H_PERMISSION) {\r\nif (connection_broken(vscsi))\r\nflag_bits = (RESPONSE_Q_DOWN | CLIENT_FAILED);\r\n}\r\ndev_err(&vscsi->dev, "mad: failed to copy to client, rc %ld\n",\r\nrc);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\n}\r\n}\r\nstatic long ibmvscsis_mad(struct scsi_info *vscsi, struct viosrp_crq *crq)\r\n{\r\nstruct iu_entry *iue;\r\nstruct ibmvscsis_cmd *cmd;\r\nstruct mad_common *mad;\r\nlong rc = ADAPT_SUCCESS;\r\nswitch (vscsi->state) {\r\ncase WAIT_CONNECTION:\r\npr_debug("mad: in Wait Connection state, ignoring MAD, flags %d\n",\r\nvscsi->flags);\r\nreturn ADAPT_SUCCESS;\r\ncase SRP_PROCESSING:\r\ncase CONNECTED:\r\nbreak;\r\ncase UNCONFIGURING:\r\ncase WAIT_IDLE:\r\ncase ERR_DISCONNECT:\r\ncase ERR_DISCONNECT_RECONNECT:\r\ndefault:\r\ndev_err(&vscsi->dev, "mad: invalid adapter state %d for mad\n",\r\nvscsi->state);\r\nreturn ADAPT_SUCCESS;\r\n}\r\ncmd = ibmvscsis_get_free_cmd(vscsi);\r\nif (!cmd) {\r\ndev_err(&vscsi->dev, "mad: failed to get cmd, debit %d\n",\r\nvscsi->debit);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nreturn ERROR;\r\n}\r\niue = cmd->iue;\r\ncmd->type = ADAPTER_MAD;\r\nrc = ibmvscsis_copy_crq_packet(vscsi, cmd, crq);\r\nif (!rc) {\r\nmad = (struct mad_common *)&vio_iu(iue)->mad;\r\npr_debug("mad: type %d\n", be32_to_cpu(mad->type));\r\nrc = ibmvscsis_process_mad(vscsi, iue);\r\npr_debug("mad: status %hd, rc %ld\n", be16_to_cpu(mad->status),\r\nrc);\r\nif (!rc)\r\nibmvscsis_send_mad_resp(vscsi, cmd, crq);\r\n} else {\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\n}\r\npr_debug("Leaving mad, rc %ld\n", rc);\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_login_rsp(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_login_rsp *rsp = &vio_iu(iue)->srp.login_rsp;\r\nstruct format_code *fmt;\r\nuint flag_bits = 0;\r\nlong rc = ADAPT_SUCCESS;\r\nmemset(rsp, 0, sizeof(struct srp_login_rsp));\r\nrsp->opcode = SRP_LOGIN_RSP;\r\nrsp->req_lim_delta = cpu_to_be32(vscsi->request_limit);\r\nrsp->tag = cmd->rsp.tag;\r\nrsp->max_it_iu_len = cpu_to_be32(SRP_MAX_IU_LEN);\r\nrsp->max_ti_iu_len = cpu_to_be32(SRP_MAX_IU_LEN);\r\nfmt = (struct format_code *)&rsp->buf_fmt;\r\nfmt->buffers = SUPPORTED_FORMATS;\r\nvscsi->credit = 0;\r\ncmd->rsp.len = sizeof(struct srp_login_rsp);\r\ndma_wmb();\r\nrc = h_copy_rdma(cmd->rsp.len, vscsi->dds.window[LOCAL].liobn,\r\niue->sbuf->dma, vscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(iue->remote_token));\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_PERMISSION:\r\nif (connection_broken(vscsi))\r\nflag_bits = RESPONSE_Q_DOWN | CLIENT_FAILED;\r\ndev_err(&vscsi->dev, "login_rsp: error copying to client, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\nbreak;\r\ncase H_SOURCE_PARM:\r\ncase H_DEST_PARM:\r\ndefault:\r\ndev_err(&vscsi->dev, "login_rsp: error copying to client, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_srp_login_rej(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd, u32 reason)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_login_rej *rej = &vio_iu(iue)->srp.login_rej;\r\nstruct format_code *fmt;\r\nuint flag_bits = 0;\r\nlong rc = ADAPT_SUCCESS;\r\nmemset(rej, 0, sizeof(*rej));\r\nrej->opcode = SRP_LOGIN_REJ;\r\nrej->reason = cpu_to_be32(reason);\r\nrej->tag = cmd->rsp.tag;\r\nfmt = (struct format_code *)&rej->buf_fmt;\r\nfmt->buffers = SUPPORTED_FORMATS;\r\ncmd->rsp.len = sizeof(*rej);\r\ndma_wmb();\r\nrc = h_copy_rdma(cmd->rsp.len, vscsi->dds.window[LOCAL].liobn,\r\niue->sbuf->dma, vscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(iue->remote_token));\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_PERMISSION:\r\nif (connection_broken(vscsi))\r\nflag_bits = RESPONSE_Q_DOWN | CLIENT_FAILED;\r\ndev_err(&vscsi->dev, "login_rej: error copying to client, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT,\r\nflag_bits);\r\nbreak;\r\ncase H_SOURCE_PARM:\r\ncase H_DEST_PARM:\r\ndefault:\r\ndev_err(&vscsi->dev, "login_rej: error copying to client, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ibmvscsis_make_nexus(struct ibmvscsis_tport *tport)\r\n{\r\nchar *name = tport->tport_name;\r\nstruct ibmvscsis_nexus *nexus;\r\nint rc;\r\nif (tport->ibmv_nexus) {\r\npr_debug("tport->ibmv_nexus already exists\n");\r\nreturn 0;\r\n}\r\nnexus = kzalloc(sizeof(*nexus), GFP_KERNEL);\r\nif (!nexus) {\r\npr_err("Unable to allocate struct ibmvscsis_nexus\n");\r\nreturn -ENOMEM;\r\n}\r\nnexus->se_sess = target_alloc_session(&tport->se_tpg, 0, 0,\r\nTARGET_PROT_NORMAL, name, nexus,\r\nNULL);\r\nif (IS_ERR(nexus->se_sess)) {\r\nrc = PTR_ERR(nexus->se_sess);\r\ngoto transport_init_fail;\r\n}\r\ntport->ibmv_nexus = nexus;\r\nreturn 0;\r\ntransport_init_fail:\r\nkfree(nexus);\r\nreturn rc;\r\n}\r\nstatic int ibmvscsis_drop_nexus(struct ibmvscsis_tport *tport)\r\n{\r\nstruct se_session *se_sess;\r\nstruct ibmvscsis_nexus *nexus;\r\nnexus = tport->ibmv_nexus;\r\nif (!nexus)\r\nreturn -ENODEV;\r\nse_sess = nexus->se_sess;\r\nif (!se_sess)\r\nreturn -ENODEV;\r\ntarget_wait_for_sess_cmds(se_sess);\r\ntransport_deregister_session_configfs(se_sess);\r\ntransport_deregister_session(se_sess);\r\ntport->ibmv_nexus = NULL;\r\nkfree(nexus);\r\nreturn 0;\r\n}\r\nstatic long ibmvscsis_srp_login(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd,\r\nstruct viosrp_crq *crq)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_login_req *req = &vio_iu(iue)->srp.login_req;\r\nstruct port_id {\r\n__be64 id_extension;\r\n__be64 io_guid;\r\n} *iport, *tport;\r\nstruct format_code *fmt;\r\nu32 reason = 0x0;\r\nlong rc = ADAPT_SUCCESS;\r\niport = (struct port_id *)req->initiator_port_id;\r\ntport = (struct port_id *)req->target_port_id;\r\nfmt = (struct format_code *)&req->req_buf_fmt;\r\nif (be32_to_cpu(req->req_it_iu_len) > SRP_MAX_IU_LEN)\r\nreason = SRP_LOGIN_REJ_REQ_IT_IU_LENGTH_TOO_LARGE;\r\nelse if (be32_to_cpu(req->req_it_iu_len) < 64)\r\nreason = SRP_LOGIN_REJ_UNABLE_ESTABLISH_CHANNEL;\r\nelse if ((be64_to_cpu(iport->id_extension) > (MAX_NUM_PORTS - 1)) ||\r\n(be64_to_cpu(tport->id_extension) > (MAX_NUM_PORTS - 1)))\r\nreason = SRP_LOGIN_REJ_UNABLE_ASSOCIATE_CHANNEL;\r\nelse if (req->req_flags & SRP_MULTICHAN_MULTI)\r\nreason = SRP_LOGIN_REJ_MULTI_CHANNEL_UNSUPPORTED;\r\nelse if (fmt->buffers & (~SUPPORTED_FORMATS))\r\nreason = SRP_LOGIN_REJ_UNSUPPORTED_DESCRIPTOR_FMT;\r\nelse if ((fmt->buffers & SUPPORTED_FORMATS) == 0)\r\nreason = SRP_LOGIN_REJ_UNSUPPORTED_DESCRIPTOR_FMT;\r\nif (vscsi->state == SRP_PROCESSING)\r\nreason = SRP_LOGIN_REJ_CHANNEL_LIMIT_REACHED;\r\nrc = ibmvscsis_make_nexus(&vscsi->tport);\r\nif (rc)\r\nreason = SRP_LOGIN_REJ_UNABLE_ESTABLISH_CHANNEL;\r\ncmd->rsp.format = VIOSRP_SRP_FORMAT;\r\ncmd->rsp.tag = req->tag;\r\npr_debug("srp_login: reason 0x%x\n", reason);\r\nif (reason)\r\nrc = ibmvscsis_srp_login_rej(vscsi, cmd, reason);\r\nelse\r\nrc = ibmvscsis_login_rsp(vscsi, cmd);\r\nif (!rc) {\r\nif (!reason)\r\nvscsi->state = SRP_PROCESSING;\r\nlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\r\nibmvscsis_send_messages(vscsi);\r\n} else {\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\n}\r\npr_debug("Leaving srp_login, rc %ld\n", rc);\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_srp_i_logout(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd,\r\nstruct viosrp_crq *crq)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_i_logout *log_out = &vio_iu(iue)->srp.i_logout;\r\nlong rc = ADAPT_SUCCESS;\r\nif ((vscsi->debit > 0) || !list_empty(&vscsi->schedule_q) ||\r\n!list_empty(&vscsi->waiting_rsp)) {\r\ndev_err(&vscsi->dev, "i_logout: outstanding work\n");\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\r\n} else {\r\ncmd->rsp.format = SRP_FORMAT;\r\ncmd->rsp.tag = log_out->tag;\r\ncmd->rsp.len = sizeof(struct mad_common);\r\nlist_add_tail(&cmd->list, &vscsi->waiting_rsp);\r\nibmvscsis_send_messages(vscsi);\r\nibmvscsis_post_disconnect(vscsi, WAIT_IDLE, 0);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_srp_cmd(struct scsi_info *vscsi, struct viosrp_crq *crq)\r\n{\r\nstruct ibmvscsis_cmd *cmd;\r\nstruct iu_entry *iue;\r\nstruct srp_cmd *srp;\r\nstruct srp_tsk_mgmt *tsk;\r\nlong rc;\r\nif (vscsi->request_limit - vscsi->debit <= 0) {\r\ndev_err(&vscsi->dev, "Client exceeded the request limit (%d), debit %d\n",\r\nvscsi->request_limit, vscsi->debit);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nreturn;\r\n}\r\ncmd = ibmvscsis_get_free_cmd(vscsi);\r\nif (!cmd) {\r\ndev_err(&vscsi->dev, "srp_cmd failed to get cmd, debit %d\n",\r\nvscsi->debit);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nreturn;\r\n}\r\niue = cmd->iue;\r\nsrp = &vio_iu(iue)->srp.cmd;\r\nrc = ibmvscsis_copy_crq_packet(vscsi, cmd, crq);\r\nif (rc) {\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nreturn;\r\n}\r\nif (vscsi->state == SRP_PROCESSING) {\r\nswitch (srp->opcode) {\r\ncase SRP_LOGIN_REQ:\r\nrc = ibmvscsis_srp_login(vscsi, cmd, crq);\r\nbreak;\r\ncase SRP_TSK_MGMT:\r\ntsk = &vio_iu(iue)->srp.tsk_mgmt;\r\npr_debug("tsk_mgmt tag: %llu (0x%llx)\n", tsk->tag,\r\ntsk->tag);\r\ncmd->rsp.tag = tsk->tag;\r\nvscsi->debit += 1;\r\ncmd->type = TASK_MANAGEMENT;\r\nlist_add_tail(&cmd->list, &vscsi->schedule_q);\r\nqueue_work(vscsi->work_q, &cmd->work);\r\nbreak;\r\ncase SRP_CMD:\r\npr_debug("srp_cmd tag: %llu (0x%llx)\n", srp->tag,\r\nsrp->tag);\r\ncmd->rsp.tag = srp->tag;\r\nvscsi->debit += 1;\r\ncmd->type = SCSI_CDB;\r\nlist_add_tail(&cmd->list, &vscsi->schedule_q);\r\nqueue_work(vscsi->work_q, &cmd->work);\r\nbreak;\r\ncase SRP_I_LOGOUT:\r\nrc = ibmvscsis_srp_i_logout(vscsi, cmd, crq);\r\nbreak;\r\ncase SRP_CRED_RSP:\r\ncase SRP_AER_RSP:\r\ndefault:\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\ndev_err(&vscsi->dev, "invalid srp cmd, opcode %d\n",\r\n(uint)srp->opcode);\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\n} else if (srp->opcode == SRP_LOGIN_REQ && vscsi->state == CONNECTED) {\r\nrc = ibmvscsis_srp_login(vscsi, cmd, crq);\r\n} else {\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\ndev_err(&vscsi->dev, "Invalid state %d to handle srp cmd\n",\r\nvscsi->state);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\n}\r\n}\r\nstatic long ibmvscsis_ping_response(struct scsi_info *vscsi)\r\n{\r\nstruct viosrp_crq *crq;\r\nu64 buffer[2] = { 0, 0 };\r\nlong rc;\r\ncrq = (struct viosrp_crq *)&buffer;\r\ncrq->valid = VALID_CMD_RESP_EL;\r\ncrq->format = (u8)MESSAGE_IN_CRQ;\r\ncrq->status = PING_RESPONSE;\r\nrc = h_send_crq(vscsi->dds.unit_id, cpu_to_be64(buffer[MSG_HI]),\r\ncpu_to_be64(buffer[MSG_LOW]));\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_CLOSED:\r\nvscsi->flags |= CLIENT_FAILED;\r\ncase H_DROPPED:\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\ncase H_REMOTE_PARM:\r\ndev_err(&vscsi->dev, "ping_response: h_send_crq failed, rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "ping_response: h_send_crq returned unknown rc %ld\n",\r\nrc);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_parse_command(struct scsi_info *vscsi,\r\nstruct viosrp_crq *crq)\r\n{\r\nlong rc = ADAPT_SUCCESS;\r\nswitch (crq->valid) {\r\ncase VALID_CMD_RESP_EL:\r\nswitch (crq->format) {\r\ncase OS400_FORMAT:\r\ncase AIX_FORMAT:\r\ncase LINUX_FORMAT:\r\ncase MAD_FORMAT:\r\nif (vscsi->flags & PROCESSING_MAD) {\r\nrc = ERROR;\r\ndev_err(&vscsi->dev, "parse_command: already processing mad\n");\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT,\r\n0);\r\n} else {\r\nvscsi->flags |= PROCESSING_MAD;\r\nrc = ibmvscsis_mad(vscsi, crq);\r\n}\r\nbreak;\r\ncase SRP_FORMAT:\r\nibmvscsis_srp_cmd(vscsi, crq);\r\nbreak;\r\ncase MESSAGE_IN_CRQ:\r\nif (crq->status == PING)\r\nibmvscsis_ping_response(vscsi);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "parse_command: invalid format %d\n",\r\n(uint)crq->format);\r\nibmvscsis_post_disconnect(vscsi,\r\nERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nbreak;\r\ncase VALID_TRANS_EVENT:\r\nrc = ibmvscsis_trans_event(vscsi, crq);\r\nbreak;\r\ncase VALID_INIT_MSG:\r\nrc = ibmvscsis_init_msg(vscsi, crq);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "parse_command: invalid valid field %d\n",\r\n(uint)crq->valid);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nbreak;\r\n}\r\nrc = vscsi->flags & SCHEDULE_DISCONNECT;\r\nreturn rc;\r\n}\r\nstatic int read_dma_window(struct scsi_info *vscsi)\r\n{\r\nstruct vio_dev *vdev = vscsi->dma_dev;\r\nconst __be32 *dma_window;\r\nconst __be32 *prop;\r\ndma_window = (const __be32 *)vio_get_attribute(vdev,\r\n"ibm,my-dma-window",\r\nNULL);\r\nif (!dma_window) {\r\npr_err("Couldn't find ibm,my-dma-window property\n");\r\nreturn -1;\r\n}\r\nvscsi->dds.window[LOCAL].liobn = be32_to_cpu(*dma_window);\r\ndma_window++;\r\nprop = (const __be32 *)vio_get_attribute(vdev, "ibm,#dma-address-cells",\r\nNULL);\r\nif (!prop) {\r\npr_warn("Couldn't find ibm,#dma-address-cells property\n");\r\ndma_window++;\r\n} else {\r\ndma_window += be32_to_cpu(*prop);\r\n}\r\nprop = (const __be32 *)vio_get_attribute(vdev, "ibm,#dma-size-cells",\r\nNULL);\r\nif (!prop) {\r\npr_warn("Couldn't find ibm,#dma-size-cells property\n");\r\ndma_window++;\r\n} else {\r\ndma_window += be32_to_cpu(*prop);\r\n}\r\nvscsi->dds.window[REMOTE].liobn = be32_to_cpu(*dma_window);\r\nreturn 0;\r\n}\r\nstatic struct ibmvscsis_tport *ibmvscsis_lookup_port(const char *name)\r\n{\r\nstruct ibmvscsis_tport *tport = NULL;\r\nstruct vio_dev *vdev;\r\nstruct scsi_info *vscsi;\r\nspin_lock_bh(&ibmvscsis_dev_lock);\r\nlist_for_each_entry(vscsi, &ibmvscsis_dev_list, list) {\r\nvdev = vscsi->dma_dev;\r\nif (!strcmp(dev_name(&vdev->dev), name)) {\r\ntport = &vscsi->tport;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&ibmvscsis_dev_lock);\r\nreturn tport;\r\n}\r\nstatic void ibmvscsis_parse_cmd(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_cmd *srp = (struct srp_cmd *)iue->sbuf->buf;\r\nstruct ibmvscsis_nexus *nexus;\r\nu64 data_len = 0;\r\nenum dma_data_direction dir;\r\nint attr = 0;\r\nint rc = 0;\r\nnexus = vscsi->tport.ibmv_nexus;\r\nif (srp->add_cdb_len & 0x03) {\r\ndev_err(&vscsi->dev, "parse_cmd: reserved bits set in IU\n");\r\nspin_lock_bh(&vscsi->intr_lock);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nreturn;\r\n}\r\nif (srp_get_desc_table(srp, &dir, &data_len)) {\r\ndev_err(&vscsi->dev, "0x%llx: parsing SRP descriptor table failed.\n",\r\nsrp->tag);\r\ngoto fail;\r\n}\r\ncmd->rsp.sol_not = srp->sol_not;\r\nswitch (srp->task_attr) {\r\ncase SRP_SIMPLE_TASK:\r\nattr = TCM_SIMPLE_TAG;\r\nbreak;\r\ncase SRP_ORDERED_TASK:\r\nattr = TCM_ORDERED_TAG;\r\nbreak;\r\ncase SRP_HEAD_TASK:\r\nattr = TCM_HEAD_TAG;\r\nbreak;\r\ncase SRP_ACA_TASK:\r\nattr = TCM_ACA_TAG;\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "Invalid task attribute %d\n",\r\nsrp->task_attr);\r\ngoto fail;\r\n}\r\ncmd->se_cmd.tag = be64_to_cpu(srp->tag);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_add_tail(&cmd->list, &vscsi->active_q);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nsrp->lun.scsi_lun[0] &= 0x3f;\r\nrc = target_submit_cmd(&cmd->se_cmd, nexus->se_sess, srp->cdb,\r\ncmd->sense_buf, scsilun_to_int(&srp->lun),\r\ndata_len, attr, dir, 0);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "target_submit_cmd failed, rc %d\n", rc);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_del(&cmd->list);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\ngoto fail;\r\n}\r\nreturn;\r\nfail:\r\nspin_lock_bh(&vscsi->intr_lock);\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT_RECONNECT, 0);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\nstatic void ibmvscsis_parse_task(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_tsk_mgmt *srp_tsk = &vio_iu(iue)->srp.tsk_mgmt;\r\nint tcm_type;\r\nu64 tag_to_abort = 0;\r\nint rc = 0;\r\nstruct ibmvscsis_nexus *nexus;\r\nnexus = vscsi->tport.ibmv_nexus;\r\ncmd->rsp.sol_not = srp_tsk->sol_not;\r\nswitch (srp_tsk->tsk_mgmt_func) {\r\ncase SRP_TSK_ABORT_TASK:\r\ntcm_type = TMR_ABORT_TASK;\r\ntag_to_abort = be64_to_cpu(srp_tsk->task_tag);\r\nbreak;\r\ncase SRP_TSK_ABORT_TASK_SET:\r\ntcm_type = TMR_ABORT_TASK_SET;\r\nbreak;\r\ncase SRP_TSK_CLEAR_TASK_SET:\r\ntcm_type = TMR_CLEAR_TASK_SET;\r\nbreak;\r\ncase SRP_TSK_LUN_RESET:\r\ntcm_type = TMR_LUN_RESET;\r\nbreak;\r\ncase SRP_TSK_CLEAR_ACA:\r\ntcm_type = TMR_CLEAR_ACA;\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "unknown task mgmt func %d\n",\r\nsrp_tsk->tsk_mgmt_func);\r\ncmd->se_cmd.se_tmr_req->response =\r\nTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\r\nrc = -1;\r\nbreak;\r\n}\r\nif (!rc) {\r\ncmd->se_cmd.tag = be64_to_cpu(srp_tsk->tag);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_add_tail(&cmd->list, &vscsi->active_q);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nsrp_tsk->lun.scsi_lun[0] &= 0x3f;\r\npr_debug("calling submit_tmr, func %d\n",\r\nsrp_tsk->tsk_mgmt_func);\r\nrc = target_submit_tmr(&cmd->se_cmd, nexus->se_sess, NULL,\r\nscsilun_to_int(&srp_tsk->lun), srp_tsk,\r\ntcm_type, GFP_KERNEL, tag_to_abort, 0);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "target_submit_tmr failed, rc %d\n",\r\nrc);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_del(&cmd->list);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\ncmd->se_cmd.se_tmr_req->response =\r\nTMR_FUNCTION_REJECTED;\r\n}\r\n}\r\nif (rc)\r\ntransport_send_check_condition_and_sense(&cmd->se_cmd, 0, 0);\r\n}\r\nstatic void ibmvscsis_scheduler(struct work_struct *work)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(work, struct ibmvscsis_cmd,\r\nwork);\r\nstruct scsi_info *vscsi = cmd->adapter;\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_del(&cmd->list);\r\nif (vscsi->flags & (SCHEDULE_DISCONNECT | DISCONNECT_SCHEDULED)) {\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nif (list_empty(&vscsi->active_q) &&\r\nlist_empty(&vscsi->schedule_q) &&\r\n(vscsi->flags & WAIT_FOR_IDLE)) {\r\nvscsi->flags &= ~WAIT_FOR_IDLE;\r\ncomplete(&vscsi->wait_idle);\r\n}\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nswitch (cmd->type) {\r\ncase SCSI_CDB:\r\nibmvscsis_parse_cmd(vscsi, cmd);\r\nbreak;\r\ncase TASK_MANAGEMENT:\r\nibmvscsis_parse_task(vscsi, cmd);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "scheduler, invalid cmd type %d\n",\r\ncmd->type);\r\nspin_lock_bh(&vscsi->intr_lock);\r\nibmvscsis_free_cmd_resources(vscsi, cmd);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nbreak;\r\n}\r\n}\r\nstatic int ibmvscsis_alloc_cmds(struct scsi_info *vscsi, int num)\r\n{\r\nstruct ibmvscsis_cmd *cmd;\r\nint i;\r\nINIT_LIST_HEAD(&vscsi->free_cmd);\r\nvscsi->cmd_pool = kcalloc(num, sizeof(struct ibmvscsis_cmd),\r\nGFP_KERNEL);\r\nif (!vscsi->cmd_pool)\r\nreturn -ENOMEM;\r\nfor (i = 0, cmd = (struct ibmvscsis_cmd *)vscsi->cmd_pool; i < num;\r\ni++, cmd++) {\r\ncmd->adapter = vscsi;\r\nINIT_WORK(&cmd->work, ibmvscsis_scheduler);\r\nlist_add_tail(&cmd->list, &vscsi->free_cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ibmvscsis_free_cmds(struct scsi_info *vscsi)\r\n{\r\nkfree(vscsi->cmd_pool);\r\nvscsi->cmd_pool = NULL;\r\nINIT_LIST_HEAD(&vscsi->free_cmd);\r\n}\r\nstatic enum hrtimer_restart ibmvscsis_service_wait_q(struct hrtimer *timer)\r\n{\r\nstruct timer_cb *p_timer = container_of(timer, struct timer_cb, timer);\r\nstruct scsi_info *vscsi = container_of(p_timer, struct scsi_info,\r\nrsp_q_timer);\r\nspin_lock_bh(&vscsi->intr_lock);\r\np_timer->timer_pops += 1;\r\np_timer->started = false;\r\nibmvscsis_send_messages(vscsi);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic long ibmvscsis_alloctimer(struct scsi_info *vscsi)\r\n{\r\nstruct timer_cb *p_timer;\r\np_timer = &vscsi->rsp_q_timer;\r\nhrtimer_init(&p_timer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\np_timer->timer.function = ibmvscsis_service_wait_q;\r\np_timer->started = false;\r\np_timer->timer_pops = 0;\r\nreturn ADAPT_SUCCESS;\r\n}\r\nstatic void ibmvscsis_freetimer(struct scsi_info *vscsi)\r\n{\r\nstruct timer_cb *p_timer;\r\np_timer = &vscsi->rsp_q_timer;\r\n(void)hrtimer_cancel(&p_timer->timer);\r\np_timer->started = false;\r\np_timer->timer_pops = 0;\r\n}\r\nstatic irqreturn_t ibmvscsis_interrupt(int dummy, void *data)\r\n{\r\nstruct scsi_info *vscsi = data;\r\nvio_disable_interrupts(vscsi->dma_dev);\r\ntasklet_schedule(&vscsi->work_task);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic long ibmvscsis_enable_change_state(struct scsi_info *vscsi)\r\n{\r\nint bytes;\r\nlong rc = ADAPT_SUCCESS;\r\nbytes = vscsi->cmd_q.size * PAGE_SIZE;\r\nrc = h_reg_crq(vscsi->dds.unit_id, vscsi->cmd_q.crq_token, bytes);\r\nif (rc == H_CLOSED || rc == H_SUCCESS) {\r\nvscsi->state = WAIT_CONNECTION;\r\nrc = ibmvscsis_establish_new_q(vscsi);\r\n}\r\nif (rc != ADAPT_SUCCESS) {\r\nvscsi->state = ERR_DISCONNECTED;\r\nvscsi->flags |= RESPONSE_Q_DOWN;\r\n}\r\nreturn rc;\r\n}\r\nstatic long ibmvscsis_create_command_q(struct scsi_info *vscsi, int num_cmds)\r\n{\r\nint pages;\r\nstruct vio_dev *vdev = vscsi->dma_dev;\r\npages = 1;\r\nvscsi->cmd_q.size = pages;\r\nvscsi->cmd_q.base_addr =\r\n(struct viosrp_crq *)get_zeroed_page(GFP_KERNEL);\r\nif (!vscsi->cmd_q.base_addr)\r\nreturn -ENOMEM;\r\nvscsi->cmd_q.mask = ((uint)pages * CRQ_PER_PAGE) - 1;\r\nvscsi->cmd_q.crq_token = dma_map_single(&vdev->dev,\r\nvscsi->cmd_q.base_addr,\r\nPAGE_SIZE, DMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(&vdev->dev, vscsi->cmd_q.crq_token)) {\r\nfree_page((unsigned long)vscsi->cmd_q.base_addr);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ibmvscsis_destroy_command_q(struct scsi_info *vscsi)\r\n{\r\ndma_unmap_single(&vscsi->dma_dev->dev, vscsi->cmd_q.crq_token,\r\nPAGE_SIZE, DMA_BIDIRECTIONAL);\r\nfree_page((unsigned long)vscsi->cmd_q.base_addr);\r\nvscsi->cmd_q.base_addr = NULL;\r\nvscsi->state = NO_QUEUE;\r\n}\r\nstatic u8 ibmvscsis_fast_fail(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct srp_cmd *srp = (struct srp_cmd *)iue->sbuf->buf;\r\nstruct scsi_sense_hdr sshdr;\r\nu8 rc = se_cmd->scsi_status;\r\nif (vscsi->fast_fail && (READ_CMD(srp->cdb) || WRITE_CMD(srp->cdb)))\r\nif (scsi_normalize_sense(se_cmd->sense_buffer,\r\nse_cmd->scsi_sense_length, &sshdr))\r\nif (sshdr.sense_key == HARDWARE_ERROR &&\r\n(se_cmd->residual_count == 0 ||\r\nse_cmd->residual_count == se_cmd->data_length)) {\r\nrc = NO_SENSE;\r\ncmd->flags |= CMD_FAST_FAIL;\r\n}\r\nreturn rc;\r\n}\r\nstatic long srp_build_response(struct scsi_info *vscsi,\r\nstruct ibmvscsis_cmd *cmd, uint *len_p)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nstruct srp_rsp *rsp;\r\nuint len;\r\nu32 rsp_code;\r\nchar *data;\r\nu32 *tsk_status;\r\nlong rc = ADAPT_SUCCESS;\r\nspin_lock_bh(&vscsi->intr_lock);\r\nrsp = &vio_iu(iue)->srp.rsp;\r\nlen = sizeof(*rsp);\r\nmemset(rsp, 0, len);\r\ndata = rsp->data;\r\nrsp->opcode = SRP_RSP;\r\nif (vscsi->credit > 0 && vscsi->state == SRP_PROCESSING)\r\nrsp->req_lim_delta = cpu_to_be32(vscsi->credit);\r\nelse\r\nrsp->req_lim_delta = cpu_to_be32(1 + vscsi->credit);\r\nrsp->tag = cmd->rsp.tag;\r\nrsp->flags = 0;\r\nif (cmd->type == SCSI_CDB) {\r\nrsp->status = ibmvscsis_fast_fail(vscsi, cmd);\r\nif (rsp->status) {\r\npr_debug("build_resp: cmd %p, scsi status %d\n", cmd,\r\n(int)rsp->status);\r\nibmvscsis_determine_resid(se_cmd, rsp);\r\nif (se_cmd->scsi_sense_length && se_cmd->sense_buffer) {\r\nrsp->sense_data_len =\r\ncpu_to_be32(se_cmd->scsi_sense_length);\r\nrsp->flags |= SRP_RSP_FLAG_SNSVALID;\r\nlen += se_cmd->scsi_sense_length;\r\nmemcpy(data, se_cmd->sense_buffer,\r\nse_cmd->scsi_sense_length);\r\n}\r\nrsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\r\nUCSOLNT_RESP_SHIFT;\r\n} else if (cmd->flags & CMD_FAST_FAIL) {\r\npr_debug("build_resp: cmd %p, fast fail\n", cmd);\r\nrsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\r\nUCSOLNT_RESP_SHIFT;\r\n} else {\r\nrsp->sol_not = (cmd->rsp.sol_not & SCSOLNT) >>\r\nSCSOLNT_RESP_SHIFT;\r\n}\r\n} else {\r\nrsp->status = 0;\r\nrsp->resp_data_len = cpu_to_be32(4);\r\nrsp->flags |= SRP_RSP_FLAG_RSPVALID;\r\nswitch (se_cmd->se_tmr_req->response) {\r\ncase TMR_FUNCTION_COMPLETE:\r\ncase TMR_TASK_DOES_NOT_EXIST:\r\nrsp_code = SRP_TASK_MANAGEMENT_FUNCTION_COMPLETE;\r\nrsp->sol_not = (cmd->rsp.sol_not & SCSOLNT) >>\r\nSCSOLNT_RESP_SHIFT;\r\nbreak;\r\ncase TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:\r\ncase TMR_LUN_DOES_NOT_EXIST:\r\nrsp_code = SRP_TASK_MANAGEMENT_FUNCTION_NOT_SUPPORTED;\r\nrsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\r\nUCSOLNT_RESP_SHIFT;\r\nbreak;\r\ncase TMR_FUNCTION_FAILED:\r\ncase TMR_FUNCTION_REJECTED:\r\ndefault:\r\nrsp_code = SRP_TASK_MANAGEMENT_FUNCTION_FAILED;\r\nrsp->sol_not = (cmd->rsp.sol_not & UCSOLNT) >>\r\nUCSOLNT_RESP_SHIFT;\r\nbreak;\r\n}\r\ntsk_status = (u32 *)data;\r\n*tsk_status = cpu_to_be32(rsp_code);\r\ndata = (char *)(tsk_status + 1);\r\nlen += 4;\r\n}\r\ndma_wmb();\r\nrc = h_copy_rdma(len, vscsi->dds.window[LOCAL].liobn, iue->sbuf->dma,\r\nvscsi->dds.window[REMOTE].liobn,\r\nbe64_to_cpu(iue->remote_token));\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nvscsi->credit = 0;\r\n*len_p = len;\r\nbreak;\r\ncase H_PERMISSION:\r\nif (connection_broken(vscsi))\r\nvscsi->flags |= RESPONSE_Q_DOWN | CLIENT_FAILED;\r\ndev_err(&vscsi->dev, "build_response: error copying to client, rc %ld, flags 0x%x, state 0x%hx\n",\r\nrc, vscsi->flags, vscsi->state);\r\nbreak;\r\ncase H_SOURCE_PARM:\r\ncase H_DEST_PARM:\r\ndefault:\r\ndev_err(&vscsi->dev, "build_response: error copying to client, rc %ld\n",\r\nrc);\r\nbreak;\r\n}\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nreturn rc;\r\n}\r\nstatic int ibmvscsis_rdma(struct ibmvscsis_cmd *cmd, struct scatterlist *sg,\r\nint nsg, struct srp_direct_buf *md, int nmd,\r\nenum dma_data_direction dir, unsigned int bytes)\r\n{\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct srp_target *target = iue->target;\r\nstruct scsi_info *vscsi = target->ldata;\r\nstruct scatterlist *sgp;\r\ndma_addr_t client_ioba, server_ioba;\r\nulong buf_len;\r\nulong client_len, server_len;\r\nint md_idx;\r\nlong tx_len;\r\nlong rc = 0;\r\nif (bytes == 0)\r\nreturn 0;\r\nsgp = sg;\r\nclient_len = 0;\r\nserver_len = 0;\r\nmd_idx = 0;\r\ntx_len = bytes;\r\ndo {\r\nif (client_len == 0) {\r\nif (md_idx >= nmd) {\r\ndev_err(&vscsi->dev, "rdma: ran out of client memory descriptors\n");\r\nrc = -EIO;\r\nbreak;\r\n}\r\nclient_ioba = be64_to_cpu(md[md_idx].va);\r\nclient_len = be32_to_cpu(md[md_idx].len);\r\n}\r\nif (server_len == 0) {\r\nif (!sgp) {\r\ndev_err(&vscsi->dev, "rdma: ran out of scatter/gather list\n");\r\nrc = -EIO;\r\nbreak;\r\n}\r\nserver_ioba = sg_dma_address(sgp);\r\nserver_len = sg_dma_len(sgp);\r\n}\r\nbuf_len = tx_len;\r\nif (buf_len > client_len)\r\nbuf_len = client_len;\r\nif (buf_len > server_len)\r\nbuf_len = server_len;\r\nif (buf_len > max_vdma_size)\r\nbuf_len = max_vdma_size;\r\nif (dir == DMA_TO_DEVICE) {\r\nrc = h_copy_rdma(buf_len,\r\nvscsi->dds.window[REMOTE].liobn,\r\nclient_ioba,\r\nvscsi->dds.window[LOCAL].liobn,\r\nserver_ioba);\r\n} else {\r\nisync();\r\ndma_wmb();\r\nrc = h_copy_rdma(buf_len,\r\nvscsi->dds.window[LOCAL].liobn,\r\nserver_ioba,\r\nvscsi->dds.window[REMOTE].liobn,\r\nclient_ioba);\r\n}\r\nswitch (rc) {\r\ncase H_SUCCESS:\r\nbreak;\r\ncase H_PERMISSION:\r\ncase H_SOURCE_PARM:\r\ncase H_DEST_PARM:\r\nif (connection_broken(vscsi)) {\r\nspin_lock_bh(&vscsi->intr_lock);\r\nvscsi->flags |=\r\n(RESPONSE_Q_DOWN | CLIENT_FAILED);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\ndev_err(&vscsi->dev, "rdma: h_copy_rdma failed, rc %ld\n",\r\nrc);\r\nbreak;\r\ndefault:\r\ndev_err(&vscsi->dev, "rdma: unknown error %ld from h_copy_rdma\n",\r\nrc);\r\nbreak;\r\n}\r\nif (!rc) {\r\ntx_len -= buf_len;\r\nif (tx_len) {\r\nclient_len -= buf_len;\r\nif (client_len == 0)\r\nmd_idx++;\r\nelse\r\nclient_ioba += buf_len;\r\nserver_len -= buf_len;\r\nif (server_len == 0)\r\nsgp = sg_next(sgp);\r\nelse\r\nserver_ioba += buf_len;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n} while (!rc);\r\nreturn rc;\r\n}\r\nstatic void ibmvscsis_handle_crq(unsigned long data)\r\n{\r\nstruct scsi_info *vscsi = (struct scsi_info *)data;\r\nstruct viosrp_crq *crq;\r\nlong rc;\r\nbool ack = true;\r\nvolatile u8 valid;\r\nspin_lock_bh(&vscsi->intr_lock);\r\npr_debug("got interrupt\n");\r\nif (TARGET_STOP(vscsi)) {\r\nvio_enable_interrupts(vscsi->dma_dev);\r\npr_debug("handle_crq, don't process: flags 0x%x, state 0x%hx\n",\r\nvscsi->flags, vscsi->state);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nreturn;\r\n}\r\nrc = vscsi->flags & SCHEDULE_DISCONNECT;\r\ncrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\r\nvalid = crq->valid;\r\ndma_rmb();\r\nwhile (valid) {\r\ncmd_work:\r\nvscsi->cmd_q.index =\r\n(vscsi->cmd_q.index + 1) & vscsi->cmd_q.mask;\r\nif (!rc) {\r\nrc = ibmvscsis_parse_command(vscsi, crq);\r\n} else {\r\nif ((uint)crq->valid == VALID_TRANS_EVENT) {\r\nrc = ibmvscsis_trans_event(vscsi, crq);\r\n} else if (vscsi->flags & TRANS_EVENT) {\r\nif (vscsi->cmd_q.index)\r\nvscsi->cmd_q.index -= 1;\r\nelse\r\nvscsi->cmd_q.index = vscsi->cmd_q.mask;\r\nbreak;\r\n}\r\n}\r\ncrq->valid = INVALIDATE_CMD_RESP_EL;\r\ncrq = vscsi->cmd_q.base_addr + vscsi->cmd_q.index;\r\nvalid = crq->valid;\r\ndma_rmb();\r\n}\r\nif (!rc) {\r\nif (ack) {\r\nvio_enable_interrupts(vscsi->dma_dev);\r\nack = false;\r\npr_debug("handle_crq, reenabling interrupts\n");\r\n}\r\nvalid = crq->valid;\r\ndma_rmb();\r\nif (valid)\r\ngoto cmd_work;\r\n} else {\r\npr_debug("handle_crq, error: flags 0x%x, state 0x%hx, crq index 0x%x\n",\r\nvscsi->flags, vscsi->state, vscsi->cmd_q.index);\r\n}\r\npr_debug("Leaving handle_crq: schedule_q empty %d, flags 0x%x, state 0x%hx\n",\r\n(int)list_empty(&vscsi->schedule_q), vscsi->flags,\r\nvscsi->state);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\nstatic int ibmvscsis_probe(struct vio_dev *vdev,\r\nconst struct vio_device_id *id)\r\n{\r\nstruct scsi_info *vscsi;\r\nint rc = 0;\r\nlong hrc = 0;\r\nchar wq_name[24];\r\nvscsi = kzalloc(sizeof(*vscsi), GFP_KERNEL);\r\nif (!vscsi) {\r\nrc = -ENOMEM;\r\npr_err("probe: allocation of adapter failed\n");\r\nreturn rc;\r\n}\r\nvscsi->dma_dev = vdev;\r\nvscsi->dev = vdev->dev;\r\nINIT_LIST_HEAD(&vscsi->schedule_q);\r\nINIT_LIST_HEAD(&vscsi->waiting_rsp);\r\nINIT_LIST_HEAD(&vscsi->active_q);\r\nsnprintf(vscsi->tport.tport_name, IBMVSCSIS_NAMELEN, "%s",\r\ndev_name(&vdev->dev));\r\npr_debug("probe tport_name: %s\n", vscsi->tport.tport_name);\r\nrc = read_dma_window(vscsi);\r\nif (rc)\r\ngoto free_adapter;\r\npr_debug("Probe: liobn 0x%x, riobn 0x%x\n",\r\nvscsi->dds.window[LOCAL].liobn,\r\nvscsi->dds.window[REMOTE].liobn);\r\nstrcpy(vscsi->eye, "VSCSI ");\r\nstrncat(vscsi->eye, vdev->name, MAX_EYE);\r\nvscsi->dds.unit_id = vdev->unit_address;\r\nstrncpy(vscsi->dds.partition_name, partition_name,\r\nsizeof(vscsi->dds.partition_name));\r\nvscsi->dds.partition_num = partition_number;\r\nspin_lock_bh(&ibmvscsis_dev_lock);\r\nlist_add_tail(&vscsi->list, &ibmvscsis_dev_list);\r\nspin_unlock_bh(&ibmvscsis_dev_lock);\r\nvscsi->request_limit = INITIAL_SRP_LIMIT;\r\nrc = srp_target_alloc(&vscsi->target, &vdev->dev, vscsi->request_limit,\r\nSRP_MAX_IU_LEN);\r\nif (rc)\r\ngoto rem_list;\r\nvscsi->target.ldata = vscsi;\r\nrc = ibmvscsis_alloc_cmds(vscsi, vscsi->request_limit);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "alloc_cmds failed, rc %d, num %d\n",\r\nrc, vscsi->request_limit);\r\ngoto free_target;\r\n}\r\nspin_lock_init(&vscsi->intr_lock);\r\nrc = ibmvscsis_alloctimer(vscsi);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "probe: alloctimer failed, rc %d\n", rc);\r\ngoto free_cmds;\r\n}\r\nrc = ibmvscsis_create_command_q(vscsi, 256);\r\nif (rc) {\r\ndev_err(&vscsi->dev, "probe: create_command_q failed, rc %d\n",\r\nrc);\r\ngoto free_timer;\r\n}\r\nvscsi->map_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!vscsi->map_buf) {\r\nrc = -ENOMEM;\r\ndev_err(&vscsi->dev, "probe: allocating cmd buffer failed\n");\r\ngoto destroy_queue;\r\n}\r\nvscsi->map_ioba = dma_map_single(&vdev->dev, vscsi->map_buf, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(&vdev->dev, vscsi->map_ioba)) {\r\nrc = -ENOMEM;\r\ndev_err(&vscsi->dev, "probe: error mapping command buffer\n");\r\ngoto free_buf;\r\n}\r\nhrc = h_vioctl(vscsi->dds.unit_id, H_GET_PARTNER_INFO,\r\n(u64)vscsi->map_ioba | ((u64)PAGE_SIZE << 32), 0, 0, 0,\r\n0);\r\nif (hrc == H_SUCCESS)\r\nvscsi->client_data.partition_number =\r\nbe64_to_cpu(*(u64 *)vscsi->map_buf);\r\npr_debug("probe hrc %ld, client partition num %d\n",\r\nhrc, vscsi->client_data.partition_number);\r\ntasklet_init(&vscsi->work_task, ibmvscsis_handle_crq,\r\n(unsigned long)vscsi);\r\ninit_completion(&vscsi->wait_idle);\r\ninit_completion(&vscsi->unconfig);\r\nsnprintf(wq_name, 24, "ibmvscsis%s", dev_name(&vdev->dev));\r\nvscsi->work_q = create_workqueue(wq_name);\r\nif (!vscsi->work_q) {\r\nrc = -ENOMEM;\r\ndev_err(&vscsi->dev, "create_workqueue failed\n");\r\ngoto unmap_buf;\r\n}\r\nrc = request_irq(vdev->irq, ibmvscsis_interrupt, 0, "ibmvscsis", vscsi);\r\nif (rc) {\r\nrc = -EPERM;\r\ndev_err(&vscsi->dev, "probe: request_irq failed, rc %d\n", rc);\r\ngoto destroy_WQ;\r\n}\r\nvscsi->state = WAIT_ENABLED;\r\ndev_set_drvdata(&vdev->dev, vscsi);\r\nreturn 0;\r\ndestroy_WQ:\r\ndestroy_workqueue(vscsi->work_q);\r\nunmap_buf:\r\ndma_unmap_single(&vdev->dev, vscsi->map_ioba, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nfree_buf:\r\nkfree(vscsi->map_buf);\r\ndestroy_queue:\r\ntasklet_kill(&vscsi->work_task);\r\nibmvscsis_unregister_command_q(vscsi);\r\nibmvscsis_destroy_command_q(vscsi);\r\nfree_timer:\r\nibmvscsis_freetimer(vscsi);\r\nfree_cmds:\r\nibmvscsis_free_cmds(vscsi);\r\nfree_target:\r\nsrp_target_free(&vscsi->target);\r\nrem_list:\r\nspin_lock_bh(&ibmvscsis_dev_lock);\r\nlist_del(&vscsi->list);\r\nspin_unlock_bh(&ibmvscsis_dev_lock);\r\nfree_adapter:\r\nkfree(vscsi);\r\nreturn rc;\r\n}\r\nstatic int ibmvscsis_remove(struct vio_dev *vdev)\r\n{\r\nstruct scsi_info *vscsi = dev_get_drvdata(&vdev->dev);\r\npr_debug("remove (%s)\n", dev_name(&vscsi->dma_dev->dev));\r\nspin_lock_bh(&vscsi->intr_lock);\r\nibmvscsis_post_disconnect(vscsi, UNCONFIGURING, 0);\r\nvscsi->flags |= CFG_SLEEPING;\r\nspin_unlock_bh(&vscsi->intr_lock);\r\nwait_for_completion(&vscsi->unconfig);\r\nvio_disable_interrupts(vdev);\r\nfree_irq(vdev->irq, vscsi);\r\ndestroy_workqueue(vscsi->work_q);\r\ndma_unmap_single(&vdev->dev, vscsi->map_ioba, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nkfree(vscsi->map_buf);\r\ntasklet_kill(&vscsi->work_task);\r\nibmvscsis_destroy_command_q(vscsi);\r\nibmvscsis_freetimer(vscsi);\r\nibmvscsis_free_cmds(vscsi);\r\nsrp_target_free(&vscsi->target);\r\nspin_lock_bh(&ibmvscsis_dev_lock);\r\nlist_del(&vscsi->list);\r\nspin_unlock_bh(&ibmvscsis_dev_lock);\r\nkfree(vscsi);\r\nreturn 0;\r\n}\r\nstatic ssize_t system_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", system_id);\r\n}\r\nstatic ssize_t partition_number_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", partition_number);\r\n}\r\nstatic ssize_t unit_address_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_info *vscsi = container_of(dev, struct scsi_info, dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", vscsi->dma_dev->unit_address);\r\n}\r\nstatic int ibmvscsis_get_system_info(void)\r\n{\r\nstruct device_node *rootdn, *vdevdn;\r\nconst char *id, *model, *name;\r\nconst uint *num;\r\nrootdn = of_find_node_by_path("/");\r\nif (!rootdn)\r\nreturn -ENOENT;\r\nmodel = of_get_property(rootdn, "model", NULL);\r\nid = of_get_property(rootdn, "system-id", NULL);\r\nif (model && id)\r\nsnprintf(system_id, sizeof(system_id), "%s-%s", model, id);\r\nname = of_get_property(rootdn, "ibm,partition-name", NULL);\r\nif (name)\r\nstrncpy(partition_name, name, sizeof(partition_name));\r\nnum = of_get_property(rootdn, "ibm,partition-no", NULL);\r\nif (num)\r\npartition_number = of_read_number(num, 1);\r\nof_node_put(rootdn);\r\nvdevdn = of_find_node_by_path("/vdevice");\r\nif (vdevdn) {\r\nconst uint *mvds;\r\nmvds = of_get_property(vdevdn, "ibm,max-virtual-dma-size",\r\nNULL);\r\nif (mvds)\r\nmax_vdma_size = *mvds;\r\nof_node_put(vdevdn);\r\n}\r\nreturn 0;\r\n}\r\nstatic char *ibmvscsis_get_fabric_name(void)\r\n{\r\nreturn "ibmvscsis";\r\n}\r\nstatic char *ibmvscsis_get_fabric_wwn(struct se_portal_group *se_tpg)\r\n{\r\nstruct ibmvscsis_tport *tport =\r\ncontainer_of(se_tpg, struct ibmvscsis_tport, se_tpg);\r\nreturn tport->tport_name;\r\n}\r\nstatic u16 ibmvscsis_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nstruct ibmvscsis_tport *tport =\r\ncontainer_of(se_tpg, struct ibmvscsis_tport, se_tpg);\r\nreturn tport->tport_tpgt;\r\n}\r\nstatic u32 ibmvscsis_get_default_depth(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ibmvscsis_check_true(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ibmvscsis_check_false(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 ibmvscsis_tpg_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int ibmvscsis_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nreturn target_put_sess_cmd(se_cmd);\r\n}\r\nstatic void ibmvscsis_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\r\nse_cmd);\r\nstruct scsi_info *vscsi = cmd->adapter;\r\nspin_lock_bh(&vscsi->intr_lock);\r\nlist_move_tail(&cmd->list, &vscsi->waiting_rsp);\r\nibmvscsis_send_messages(vscsi);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\nstatic u32 ibmvscsis_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ibmvscsis_write_pending(struct se_cmd *se_cmd)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\r\nse_cmd);\r\nstruct iu_entry *iue = cmd->iue;\r\nint rc;\r\nrc = srp_transfer_data(cmd, &vio_iu(iue)->srp.cmd, ibmvscsis_rdma,\r\n1, 1);\r\nif (rc) {\r\npr_err("srp_transfer_data() failed: %d\n", rc);\r\nreturn -EIO;\r\n}\r\ntarget_execute_cmd(se_cmd);\r\nreturn 0;\r\n}\r\nstatic int ibmvscsis_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ibmvscsis_set_default_node_attrs(struct se_node_acl *nacl)\r\n{\r\n}\r\nstatic int ibmvscsis_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ibmvscsis_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\r\nse_cmd);\r\nstruct iu_entry *iue = cmd->iue;\r\nstruct scsi_info *vscsi = cmd->adapter;\r\nchar *sd;\r\nuint len = 0;\r\nint rc;\r\nrc = srp_transfer_data(cmd, &vio_iu(iue)->srp.cmd, ibmvscsis_rdma, 1,\r\n1);\r\nif (rc) {\r\npr_err("srp_transfer_data failed: %d\n", rc);\r\nsd = se_cmd->sense_buffer;\r\nse_cmd->scsi_sense_length = 18;\r\nmemset(se_cmd->sense_buffer, 0, se_cmd->scsi_sense_length);\r\nscsi_build_sense_buffer(0, se_cmd->sense_buffer, MEDIUM_ERROR,\r\n0x08, 0x01);\r\n}\r\nsrp_build_response(vscsi, cmd, &len);\r\ncmd->rsp.format = SRP_FORMAT;\r\ncmd->rsp.len = len;\r\nreturn 0;\r\n}\r\nstatic int ibmvscsis_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\r\nse_cmd);\r\nstruct scsi_info *vscsi = cmd->adapter;\r\nuint len;\r\npr_debug("queue_status %p\n", se_cmd);\r\nsrp_build_response(vscsi, cmd, &len);\r\ncmd->rsp.format = SRP_FORMAT;\r\ncmd->rsp.len = len;\r\nreturn 0;\r\n}\r\nstatic void ibmvscsis_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\nstruct ibmvscsis_cmd *cmd = container_of(se_cmd, struct ibmvscsis_cmd,\r\nse_cmd);\r\nstruct scsi_info *vscsi = cmd->adapter;\r\nuint len;\r\npr_debug("queue_tm_rsp %p, status %d\n",\r\nse_cmd, (int)se_cmd->se_tmr_req->response);\r\nsrp_build_response(vscsi, cmd, &len);\r\ncmd->rsp.format = SRP_FORMAT;\r\ncmd->rsp.len = len;\r\n}\r\nstatic void ibmvscsis_aborted_task(struct se_cmd *se_cmd)\r\n{\r\npr_debug("ibmvscsis_aborted_task %p\n", se_cmd);\r\n}\r\nstatic struct se_wwn *ibmvscsis_make_tport(struct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ibmvscsis_tport *tport;\r\ntport = ibmvscsis_lookup_port(name);\r\nif (tport) {\r\ntport->tport_proto_id = SCSI_PROTOCOL_SRP;\r\npr_debug("make_tport(%s), pointer:%p, tport_id:%x\n",\r\nname, tport, tport->tport_proto_id);\r\nreturn &tport->tport_wwn;\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void ibmvscsis_drop_tport(struct se_wwn *wwn)\r\n{\r\nstruct ibmvscsis_tport *tport = container_of(wwn,\r\nstruct ibmvscsis_tport,\r\ntport_wwn);\r\npr_debug("drop_tport(%s)\n",\r\nconfig_item_name(&tport->tport_wwn.wwn_group.cg_item));\r\n}\r\nstatic struct se_portal_group *ibmvscsis_make_tpg(struct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct ibmvscsis_tport *tport =\r\ncontainer_of(wwn, struct ibmvscsis_tport, tport_wwn);\r\nint rc;\r\ntport->releasing = false;\r\nrc = core_tpg_register(&tport->tport_wwn, &tport->se_tpg,\r\ntport->tport_proto_id);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn &tport->se_tpg;\r\n}\r\nstatic void ibmvscsis_drop_tpg(struct se_portal_group *se_tpg)\r\n{\r\nstruct ibmvscsis_tport *tport = container_of(se_tpg,\r\nstruct ibmvscsis_tport,\r\nse_tpg);\r\ntport->releasing = true;\r\ntport->enabled = false;\r\nibmvscsis_drop_nexus(tport);\r\ncore_tpg_deregister(se_tpg);\r\n}\r\nstatic ssize_t ibmvscsis_wwn_version_show(struct config_item *item,\r\nchar *page)\r\n{\r\nreturn scnprintf(page, PAGE_SIZE, "%s\n", IBMVSCSIS_VERSION);\r\n}\r\nstatic ssize_t ibmvscsis_tpg_enable_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct ibmvscsis_tport *tport = container_of(se_tpg,\r\nstruct ibmvscsis_tport,\r\nse_tpg);\r\nreturn snprintf(page, PAGE_SIZE, "%d\n", (tport->enabled) ? 1 : 0);\r\n}\r\nstatic ssize_t ibmvscsis_tpg_enable_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct ibmvscsis_tport *tport = container_of(se_tpg,\r\nstruct ibmvscsis_tport,\r\nse_tpg);\r\nstruct scsi_info *vscsi = container_of(tport, struct scsi_info, tport);\r\nunsigned long tmp;\r\nint rc;\r\nlong lrc;\r\nrc = kstrtoul(page, 0, &tmp);\r\nif (rc < 0) {\r\npr_err("Unable to extract srpt_tpg_store_enable\n");\r\nreturn -EINVAL;\r\n}\r\nif ((tmp != 0) && (tmp != 1)) {\r\npr_err("Illegal value for srpt_tpg_store_enable\n");\r\nreturn -EINVAL;\r\n}\r\nif (tmp) {\r\nspin_lock_bh(&vscsi->intr_lock);\r\ntport->enabled = true;\r\nlrc = ibmvscsis_enable_change_state(vscsi);\r\nif (lrc)\r\npr_err("enable_change_state failed, rc %ld state %d\n",\r\nlrc, vscsi->state);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n} else {\r\nspin_lock_bh(&vscsi->intr_lock);\r\ntport->enabled = false;\r\nibmvscsis_post_disconnect(vscsi, ERR_DISCONNECT, 0);\r\nspin_unlock_bh(&vscsi->intr_lock);\r\n}\r\npr_debug("tpg_enable_store, tmp %ld, state %d\n", tmp, vscsi->state);\r\nreturn count;\r\n}\r\nstatic void ibmvscsis_dev_release(struct device *dev) {}\r\nstatic int __init ibmvscsis_init(void)\r\n{\r\nint rc = 0;\r\nrc = ibmvscsis_get_system_info();\r\nif (rc) {\r\npr_err("rc %d from get_system_info\n", rc);\r\ngoto out;\r\n}\r\nrc = class_register(&ibmvscsis_class);\r\nif (rc) {\r\npr_err("failed class register\n");\r\ngoto out;\r\n}\r\nrc = target_register_template(&ibmvscsis_ops);\r\nif (rc) {\r\npr_err("rc %d from target_register_template\n", rc);\r\ngoto unregister_class;\r\n}\r\nrc = vio_register_driver(&ibmvscsis_driver);\r\nif (rc) {\r\npr_err("rc %d from vio_register_driver\n", rc);\r\ngoto unregister_target;\r\n}\r\nreturn 0;\r\nunregister_target:\r\ntarget_unregister_template(&ibmvscsis_ops);\r\nunregister_class:\r\nclass_unregister(&ibmvscsis_class);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit ibmvscsis_exit(void)\r\n{\r\npr_info("Unregister IBM virtual SCSI host driver\n");\r\nvio_unregister_driver(&ibmvscsis_driver);\r\ntarget_unregister_template(&ibmvscsis_ops);\r\nclass_unregister(&ibmvscsis_class);\r\n}
