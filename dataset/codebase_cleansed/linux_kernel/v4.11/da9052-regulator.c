static int verify_range(struct da9052_regulator_info *info,\r\nint min_uV, int max_uV)\r\n{\r\nif (min_uV > info->max_uV || max_uV < info->min_uV)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int da9052_dcdc_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nint offset = rdev_get_id(rdev);\r\nint ret, row = 2;\r\nret = da9052_reg_read(regulator->da9052, DA9052_BUCKA_REG + offset/2);\r\nif (ret < 0)\r\nreturn ret;\r\nif (offset % 2 == 0)\r\nret = (ret & DA9052_BUCK_ILIM_MASK_EVEN) >> 2;\r\nelse\r\nret = (ret & DA9052_BUCK_ILIM_MASK_ODD) >> 6;\r\nif (regulator->da9052->chip_id == DA9052)\r\nrow = 0;\r\nelse if (offset == 0)\r\nrow = 1;\r\nreturn da9052_current_limits[row][ret];\r\n}\r\nstatic int da9052_dcdc_set_current_limit(struct regulator_dev *rdev, int min_uA,\r\nint max_uA)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nint offset = rdev_get_id(rdev);\r\nint reg_val = 0;\r\nint i, row = 2;\r\nif (regulator->da9052->chip_id == DA9052)\r\nrow = 0;\r\nelse if (offset == 0)\r\nrow = 1;\r\nfor (i = DA9052_CURRENT_RANGE - 1; i >= 0; i--) {\r\nif ((min_uA <= da9052_current_limits[row][i]) &&\r\n(da9052_current_limits[row][i] <= max_uA)) {\r\nreg_val = i;\r\nbreak;\r\n}\r\n}\r\nif (i < 0)\r\nreturn -EINVAL;\r\nif (offset % 2 == 0)\r\nreturn da9052_reg_update(regulator->da9052,\r\nDA9052_BUCKA_REG + offset/2,\r\nDA9052_BUCK_ILIM_MASK_EVEN,\r\nreg_val << 2);\r\nelse\r\nreturn da9052_reg_update(regulator->da9052,\r\nDA9052_BUCKA_REG + offset/2,\r\nDA9052_BUCK_ILIM_MASK_ODD,\r\nreg_val << 6);\r\n}\r\nstatic int da9052_list_voltage(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9052_regulator_info *info = regulator->info;\r\nint id = rdev_get_id(rdev);\r\nint volt_uV;\r\nif ((id == DA9052_ID_BUCK4) && (regulator->da9052->chip_id == DA9052)\r\n&& (selector >= DA9052_BUCK_PERI_REG_MAP_UPTO_3uV)) {\r\nvolt_uV = ((DA9052_BUCK_PERI_REG_MAP_UPTO_3uV * info->step_uV)\r\n+ info->min_uV);\r\nvolt_uV += (selector - DA9052_BUCK_PERI_REG_MAP_UPTO_3uV)\r\n* (DA9052_BUCK_PERI_3uV_STEP);\r\n} else {\r\nvolt_uV = (selector * info->step_uV) + info->min_uV;\r\n}\r\nif (volt_uV > info->max_uV)\r\nreturn -EINVAL;\r\nreturn volt_uV;\r\n}\r\nstatic int da9052_map_voltage(struct regulator_dev *rdev,\r\nint min_uV, int max_uV)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9052_regulator_info *info = regulator->info;\r\nint id = rdev_get_id(rdev);\r\nint ret, sel;\r\nret = verify_range(info, min_uV, max_uV);\r\nif (ret < 0)\r\nreturn ret;\r\nif (min_uV < info->min_uV)\r\nmin_uV = info->min_uV;\r\nif ((id == DA9052_ID_BUCK4) && (regulator->da9052->chip_id == DA9052)\r\n&& (min_uV >= DA9052_CONST_3uV)) {\r\nsel = DA9052_BUCK_PERI_REG_MAP_UPTO_3uV +\r\nDIV_ROUND_UP(min_uV - DA9052_CONST_3uV,\r\nDA9052_BUCK_PERI_3uV_STEP);\r\n} else {\r\nsel = DIV_ROUND_UP(min_uV - info->min_uV, info->step_uV);\r\n}\r\nret = da9052_list_voltage(rdev, sel);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sel;\r\n}\r\nstatic int da9052_regulator_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned int selector)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9052_regulator_info *info = regulator->info;\r\nint id = rdev_get_id(rdev);\r\nint ret;\r\nret = da9052_reg_update(regulator->da9052, rdev->desc->vsel_reg,\r\nrdev->desc->vsel_mask, selector);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (id) {\r\ncase DA9052_ID_BUCK1:\r\ncase DA9052_ID_BUCK2:\r\ncase DA9052_ID_BUCK3:\r\ncase DA9052_ID_LDO2:\r\ncase DA9052_ID_LDO3:\r\nret = da9052_reg_update(regulator->da9052, DA9052_SUPPLY_REG,\r\ninfo->activate_bit, info->activate_bit);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int da9052_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_sel,\r\nunsigned int new_sel)\r\n{\r\nstruct da9052_regulator *regulator = rdev_get_drvdata(rdev);\r\nstruct da9052_regulator_info *info = regulator->info;\r\nint id = rdev_get_id(rdev);\r\nint ret = 0;\r\nswitch (id) {\r\ncase DA9052_ID_BUCK1:\r\ncase DA9052_ID_BUCK2:\r\ncase DA9052_ID_BUCK3:\r\ncase DA9052_ID_LDO2:\r\ncase DA9052_ID_LDO3:\r\nret = (new_sel - old_sel) * info->step_uV / 6250;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline struct da9052_regulator_info *find_regulator_info(u8 chip_id,\r\nint id)\r\n{\r\nstruct da9052_regulator_info *info;\r\nint i;\r\nswitch (chip_id) {\r\ncase DA9052:\r\nfor (i = 0; i < ARRAY_SIZE(da9052_regulator_info); i++) {\r\ninfo = &da9052_regulator_info[i];\r\nif (info->reg_desc.id == id)\r\nreturn info;\r\n}\r\nbreak;\r\ncase DA9053_AA:\r\ncase DA9053_BA:\r\ncase DA9053_BB:\r\ncase DA9053_BC:\r\nfor (i = 0; i < ARRAY_SIZE(da9053_regulator_info); i++) {\r\ninfo = &da9053_regulator_info[i];\r\nif (info->reg_desc.id == id)\r\nreturn info;\r\n}\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int da9052_regulator_probe(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nstruct regulator_config config = { };\r\nstruct da9052_regulator *regulator;\r\nstruct da9052 *da9052;\r\nstruct da9052_pdata *pdata;\r\nregulator = devm_kzalloc(&pdev->dev, sizeof(struct da9052_regulator),\r\nGFP_KERNEL);\r\nif (!regulator)\r\nreturn -ENOMEM;\r\nda9052 = dev_get_drvdata(pdev->dev.parent);\r\npdata = dev_get_platdata(da9052->dev);\r\nregulator->da9052 = da9052;\r\nregulator->info = find_regulator_info(regulator->da9052->chip_id,\r\ncell->id);\r\nif (regulator->info == NULL) {\r\ndev_err(&pdev->dev, "invalid regulator ID specified\n");\r\nreturn -EINVAL;\r\n}\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = regulator;\r\nconfig.regmap = da9052->regmap;\r\nif (pdata && pdata->regulators) {\r\nconfig.init_data = pdata->regulators[cell->id];\r\n} else {\r\n#ifdef CONFIG_OF\r\nstruct device_node *nproot = da9052->dev->of_node;\r\nstruct device_node *np;\r\nif (!nproot)\r\nreturn -ENODEV;\r\nnproot = of_get_child_by_name(nproot, "regulators");\r\nif (!nproot)\r\nreturn -ENODEV;\r\nfor_each_child_of_node(nproot, np) {\r\nif (!of_node_cmp(np->name,\r\nregulator->info->reg_desc.name)) {\r\nconfig.init_data = of_get_regulator_init_data(\r\n&pdev->dev, np,\r\n&regulator->info->reg_desc);\r\nconfig.of_node = np;\r\nbreak;\r\n}\r\n}\r\nof_node_put(nproot);\r\n#endif\r\n}\r\nregulator->rdev = devm_regulator_register(&pdev->dev,\r\n&regulator->info->reg_desc,\r\n&config);\r\nif (IS_ERR(regulator->rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nregulator->info->reg_desc.name);\r\nreturn PTR_ERR(regulator->rdev);\r\n}\r\nplatform_set_drvdata(pdev, regulator);\r\nreturn 0;\r\n}\r\nstatic int __init da9052_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&da9052_regulator_driver);\r\n}\r\nstatic void __exit da9052_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&da9052_regulator_driver);\r\n}
