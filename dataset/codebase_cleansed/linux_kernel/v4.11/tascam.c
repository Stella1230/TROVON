static int identify_model(struct snd_tscm *tscm)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(tscm->unit);\r\nconst u32 *config_rom = fw_dev->config_rom;\r\nchar model[9];\r\nunsigned int i;\r\nu8 c;\r\nif (fw_dev->config_rom_length < 30) {\r\ndev_err(&tscm->unit->device,\r\n"Configuration ROM is too short.\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nc = config_rom[28 + i / 4] >> (24 - 8 * (i % 4));\r\nif (c == '\0')\r\nbreak;\r\nmodel[i] = c;\r\n}\r\nmodel[i] = '\0';\r\nfor (i = 0; i < ARRAY_SIZE(model_specs); i++) {\r\nif (strcmp(model, model_specs[i].name) == 0) {\r\ntscm->spec = &model_specs[i];\r\nbreak;\r\n}\r\n}\r\nif (tscm->spec == NULL)\r\nreturn -ENODEV;\r\nstrcpy(tscm->card->driver, "FW-TASCAM");\r\nstrcpy(tscm->card->shortname, model);\r\nstrcpy(tscm->card->mixername, model);\r\nsnprintf(tscm->card->longname, sizeof(tscm->card->longname),\r\n"TASCAM %s, GUID %08x%08x at %s, S%d", model,\r\nfw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&tscm->unit->device), 100 << fw_dev->max_speed);\r\nreturn 0;\r\n}\r\nstatic void tscm_free(struct snd_tscm *tscm)\r\n{\r\nsnd_tscm_transaction_unregister(tscm);\r\nsnd_tscm_stream_destroy_duplex(tscm);\r\nfw_unit_put(tscm->unit);\r\nmutex_destroy(&tscm->mutex);\r\n}\r\nstatic void tscm_card_free(struct snd_card *card)\r\n{\r\ntscm_free(card->private_data);\r\n}\r\nstatic void do_registration(struct work_struct *work)\r\n{\r\nstruct snd_tscm *tscm = container_of(work, struct snd_tscm, dwork.work);\r\nint err;\r\nerr = snd_card_new(&tscm->unit->device, -1, NULL, THIS_MODULE, 0,\r\n&tscm->card);\r\nif (err < 0)\r\nreturn;\r\nerr = identify_model(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_tscm_transaction_register(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_tscm_stream_init_duplex(tscm);\r\nif (err < 0)\r\ngoto error;\r\nsnd_tscm_proc_init(tscm);\r\nerr = snd_tscm_create_pcm_devices(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_tscm_create_midi_devices(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_tscm_create_hwdep_device(tscm);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(tscm->card);\r\nif (err < 0)\r\ngoto error;\r\ntscm->card->private_free = tscm_card_free;\r\ntscm->card->private_data = tscm;\r\ntscm->registered = true;\r\nreturn;\r\nerror:\r\nsnd_tscm_transaction_unregister(tscm);\r\nsnd_tscm_stream_destroy_duplex(tscm);\r\nsnd_card_free(tscm->card);\r\ndev_info(&tscm->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int snd_tscm_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_tscm *tscm;\r\ntscm = kzalloc(sizeof(struct snd_tscm), GFP_KERNEL);\r\nif (tscm == NULL)\r\nreturn -ENOMEM;\r\ntscm->unit = fw_unit_get(unit);\r\ndev_set_drvdata(&unit->device, tscm);\r\nmutex_init(&tscm->mutex);\r\nspin_lock_init(&tscm->lock);\r\ninit_waitqueue_head(&tscm->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&tscm->dwork, do_registration);\r\nsnd_fw_schedule_registration(unit, &tscm->dwork);\r\nreturn 0;\r\n}\r\nstatic void snd_tscm_update(struct fw_unit *unit)\r\n{\r\nstruct snd_tscm *tscm = dev_get_drvdata(&unit->device);\r\nif (!tscm->registered)\r\nsnd_fw_schedule_registration(unit, &tscm->dwork);\r\nsnd_tscm_transaction_reregister(tscm);\r\nif (tscm->registered) {\r\nmutex_lock(&tscm->mutex);\r\nsnd_tscm_stream_update_duplex(tscm);\r\nmutex_unlock(&tscm->mutex);\r\n}\r\n}\r\nstatic void snd_tscm_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_tscm *tscm = dev_get_drvdata(&unit->device);\r\ncancel_delayed_work_sync(&tscm->dwork);\r\nif (tscm->registered) {\r\nsnd_card_free_when_closed(tscm->card);\r\n} else {\r\ntscm_free(tscm);\r\n}\r\n}\r\nstatic int __init snd_tscm_init(void)\r\n{\r\nreturn driver_register(&tscm_driver.driver);\r\n}\r\nstatic void __exit snd_tscm_exit(void)\r\n{\r\ndriver_unregister(&tscm_driver.driver);\r\n}
