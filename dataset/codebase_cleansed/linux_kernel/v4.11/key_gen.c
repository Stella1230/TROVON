static inline u32 split_key_len(u32 hash)\r\n{\r\nstatic const u8 mdpadlen[] = { 16, 20, 32, 32, 64, 64 };\r\nu32 idx;\r\nidx = (hash & OP_ALG_ALGSEL_SUBMASK) >> OP_ALG_ALGSEL_SHIFT;\r\nreturn (u32)(mdpadlen[idx] * 2);\r\n}\r\nstatic inline u32 split_key_pad_len(u32 hash)\r\n{\r\nreturn ALIGN(split_key_len(hash), 16);\r\n}\r\nvoid split_key_done(struct device *dev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct split_key_result *res = context;\r\n#ifdef DEBUG\r\ndev_err(dev, "%s %d: err 0x%x\n", __func__, __LINE__, err);\r\n#endif\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nres->err = err;\r\ncomplete(&res->completion);\r\n}\r\nint gen_split_key(struct device *jrdev, u8 *key_out,\r\nstruct alginfo * const adata, const u8 *key_in, u32 keylen,\r\nint max_keylen)\r\n{\r\nu32 *desc;\r\nstruct split_key_result result;\r\ndma_addr_t dma_addr_in, dma_addr_out;\r\nint ret = -ENOMEM;\r\nadata->keylen = split_key_len(adata->algtype & OP_ALG_ALGSEL_MASK);\r\nadata->keylen_pad = split_key_pad_len(adata->algtype &\r\nOP_ALG_ALGSEL_MASK);\r\n#ifdef DEBUG\r\ndev_err(jrdev, "split keylen %d split keylen padded %d\n",\r\nadata->keylen, adata->keylen_pad);\r\nprint_hex_dump(KERN_ERR, "ctx.key@" __stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key_in, keylen, 1);\r\n#endif\r\nif (adata->keylen_pad > max_keylen)\r\nreturn -EINVAL;\r\ndesc = kmalloc(CAAM_CMD_SZ * 6 + CAAM_PTR_SZ * 2, GFP_KERNEL | GFP_DMA);\r\nif (!desc) {\r\ndev_err(jrdev, "unable to allocate key input memory\n");\r\nreturn ret;\r\n}\r\ndma_addr_in = dma_map_single(jrdev, (void *)key_in, keylen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, dma_addr_in)) {\r\ndev_err(jrdev, "unable to map key input memory\n");\r\ngoto out_free;\r\n}\r\ndma_addr_out = dma_map_single(jrdev, key_out, adata->keylen_pad,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(jrdev, dma_addr_out)) {\r\ndev_err(jrdev, "unable to map key output memory\n");\r\ngoto out_unmap_in;\r\n}\r\ninit_job_desc(desc, 0);\r\nappend_key(desc, dma_addr_in, keylen, CLASS_2 | KEY_DEST_CLASS_REG);\r\nappend_operation(desc, (adata->algtype & OP_ALG_ALGSEL_MASK) |\r\nOP_ALG_AAI_HMAC | OP_TYPE_CLASS2_ALG | OP_ALG_DECRYPT |\r\nOP_ALG_AS_INIT);\r\nappend_fifo_load_as_imm(desc, NULL, 0, LDST_CLASS_2_CCB |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2);\r\nappend_fifo_store(desc, dma_addr_out, adata->keylen,\r\nLDST_CLASS_2_CCB | FIFOST_TYPE_SPLIT_KEK);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ctx.key@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key_in, keylen, 1);\r\nprint_hex_dump(KERN_ERR, "jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc, desc_bytes(desc), 1);\r\n#endif\r\nresult.err = 0;\r\ninit_completion(&result.completion);\r\nret = caam_jr_enqueue(jrdev, desc, split_key_done, &result);\r\nif (!ret) {\r\nwait_for_completion_interruptible(&result.completion);\r\nret = result.err;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ctx.key@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key_out,\r\nadata->keylen_pad, 1);\r\n#endif\r\n}\r\ndma_unmap_single(jrdev, dma_addr_out, adata->keylen_pad,\r\nDMA_FROM_DEVICE);\r\nout_unmap_in:\r\ndma_unmap_single(jrdev, dma_addr_in, keylen, DMA_TO_DEVICE);\r\nout_free:\r\nkfree(desc);\r\nreturn ret;\r\n}
