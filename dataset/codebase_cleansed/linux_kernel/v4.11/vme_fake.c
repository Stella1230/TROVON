static void fake_VIRQ_tasklet(unsigned long data)\r\n{\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = (struct vme_bridge *) data;\r\nbridge = fake_bridge->driver_priv;\r\nvme_irq_handler(fake_bridge, bridge->int_level, bridge->int_statid);\r\n}\r\nstatic void fake_irq_set(struct vme_bridge *fake_bridge, int level,\r\nint state, int sync)\r\n{\r\n}\r\nstatic void *fake_pci_to_ptr(dma_addr_t addr)\r\n{\r\nreturn (void *)(uintptr_t)addr;\r\n}\r\nstatic dma_addr_t fake_ptr_to_pci(void *addr)\r\n{\r\nreturn (dma_addr_t)(uintptr_t)addr;\r\n}\r\nstatic int fake_irq_generate(struct vme_bridge *fake_bridge, int level,\r\nint statid)\r\n{\r\nstruct fake_driver *bridge;\r\nbridge = fake_bridge->driver_priv;\r\nmutex_lock(&bridge->vme_int);\r\nbridge->int_level = level;\r\nbridge->int_statid = statid;\r\ntasklet_schedule(&bridge->int_tasklet);\r\nmutex_unlock(&bridge->vme_int);\r\nreturn 0;\r\n}\r\nstatic int fake_slave_set(struct vme_slave_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size,\r\ndma_addr_t buf_base, u32 aspace, u32 cycle)\r\n{\r\nunsigned int i, granularity = 0;\r\nunsigned long long vme_bound;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = image->parent;\r\nbridge = fake_bridge->driver_priv;\r\ni = image->number;\r\nswitch (aspace) {\r\ncase VME_A16:\r\ngranularity = 0x10;\r\nbreak;\r\ncase VME_A24:\r\ngranularity = 0x1000;\r\nbreak;\r\ncase VME_A32:\r\ngranularity = 0x10000;\r\nbreak;\r\ncase VME_A64:\r\ngranularity = 0x10000;\r\nbreak;\r\ncase VME_CRCSR:\r\ncase VME_USER1:\r\ncase VME_USER2:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\ndefault:\r\npr_err("Invalid address space\n");\r\nreturn -EINVAL;\r\n}\r\nvme_bound = vme_base + size - granularity;\r\nif (vme_base & (granularity - 1)) {\r\npr_err("Invalid VME base alignment\n");\r\nreturn -EINVAL;\r\n}\r\nif (vme_bound & (granularity - 1)) {\r\npr_err("Invalid VME bound alignment\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&image->mtx);\r\nbridge->slaves[i].enabled = enabled;\r\nbridge->slaves[i].vme_base = vme_base;\r\nbridge->slaves[i].size = size;\r\nbridge->slaves[i].buf_base = fake_pci_to_ptr(buf_base);\r\nbridge->slaves[i].aspace = aspace;\r\nbridge->slaves[i].cycle = cycle;\r\nmutex_unlock(&image->mtx);\r\nreturn 0;\r\n}\r\nstatic int fake_slave_get(struct vme_slave_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\ndma_addr_t *buf_base, u32 *aspace, u32 *cycle)\r\n{\r\nunsigned int i;\r\nstruct fake_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nmutex_lock(&image->mtx);\r\n*enabled = bridge->slaves[i].enabled;\r\n*vme_base = bridge->slaves[i].vme_base;\r\n*size = bridge->slaves[i].size;\r\n*buf_base = fake_ptr_to_pci(bridge->slaves[i].buf_base);\r\n*aspace = bridge->slaves[i].aspace;\r\n*cycle = bridge->slaves[i].cycle;\r\nmutex_unlock(&image->mtx);\r\nreturn 0;\r\n}\r\nstatic int fake_master_set(struct vme_master_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size,\r\nu32 aspace, u32 cycle, u32 dwidth)\r\n{\r\nint retval = 0;\r\nunsigned int i;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = image->parent;\r\nbridge = fake_bridge->driver_priv;\r\nif (vme_base & 0xFFFF) {\r\npr_err("Invalid VME Window alignment\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nif (size & 0xFFFF) {\r\npr_err("Invalid size alignment\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nif ((size == 0) && (enabled != 0)) {\r\npr_err("Size must be non-zero for enabled windows\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nswitch (dwidth) {\r\ncase VME_D8:\r\ncase VME_D16:\r\ncase VME_D32:\r\nbreak;\r\ndefault:\r\npr_err("Invalid data width\n");\r\nretval = -EINVAL;\r\ngoto err_dwidth;\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\ncase VME_A24:\r\ncase VME_A32:\r\ncase VME_A64:\r\ncase VME_CRCSR:\r\ncase VME_USER1:\r\ncase VME_USER2:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\nbreak;\r\ndefault:\r\npr_err("Invalid address space\n");\r\nretval = -EINVAL;\r\ngoto err_aspace;\r\n}\r\nspin_lock(&image->lock);\r\ni = image->number;\r\nbridge->masters[i].enabled = enabled;\r\nbridge->masters[i].vme_base = vme_base;\r\nbridge->masters[i].size = size;\r\nbridge->masters[i].aspace = aspace;\r\nbridge->masters[i].cycle = cycle;\r\nbridge->masters[i].dwidth = dwidth;\r\nspin_unlock(&image->lock);\r\nreturn 0;\r\nerr_aspace:\r\nerr_dwidth:\r\nerr_window:\r\nreturn retval;\r\n}\r\nstatic int __fake_master_get(struct vme_master_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\nu32 *aspace, u32 *cycle, u32 *dwidth)\r\n{\r\nunsigned int i;\r\nstruct fake_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\n*enabled = bridge->masters[i].enabled;\r\n*vme_base = bridge->masters[i].vme_base;\r\n*size = bridge->masters[i].size;\r\n*aspace = bridge->masters[i].aspace;\r\n*cycle = bridge->masters[i].cycle;\r\n*dwidth = bridge->masters[i].dwidth;\r\nreturn 0;\r\n}\r\nstatic int fake_master_get(struct vme_master_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\nu32 *aspace, u32 *cycle, u32 *dwidth)\r\n{\r\nint retval;\r\nspin_lock(&image->lock);\r\nretval = __fake_master_get(image, enabled, vme_base, size, aspace,\r\ncycle, dwidth);\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic void fake_lm_check(struct fake_driver *bridge, unsigned long long addr,\r\nu32 aspace, u32 cycle)\r\n{\r\nstruct vme_bridge *fake_bridge;\r\nunsigned long long lm_base;\r\nu32 lm_aspace, lm_cycle;\r\nint i;\r\nstruct vme_lm_resource *lm;\r\nstruct list_head *pos = NULL, *n;\r\nfake_bridge = bridge->parent;\r\nlist_for_each_safe(pos, n, &fake_bridge->lm_resources) {\r\nlm = list_entry(pos, struct vme_lm_resource, list);\r\nif (bridge->lm_enabled == 0)\r\nreturn;\r\nlm_base = bridge->lm_base;\r\nlm_aspace = bridge->lm_aspace;\r\nlm_cycle = bridge->lm_cycle;\r\nif ((lm_aspace == aspace) && (lm_cycle == cycle)) {\r\nfor (i = 0; i < lm->monitors; i++) {\r\nif (((lm_base + (8 * i)) <= addr) &&\r\n((lm_base + (8 * i) + 8) > addr)) {\r\nif (bridge->lm_callback[i] != NULL)\r\nbridge->lm_callback[i](\r\nbridge->lm_data[i]);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic u8 fake_vmeread8(struct fake_driver *bridge, unsigned long long addr,\r\nu32 aspace, u32 cycle)\r\n{\r\nu8 retval = 0xff;\r\nint i;\r\nunsigned long long start, end, offset;\r\nu8 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nif ((addr >= start) && (addr < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u8 *)(bridge->slaves[i].buf_base + offset);\r\nretval = *loc;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\nreturn retval;\r\n}\r\nstatic u16 fake_vmeread16(struct fake_driver *bridge, unsigned long long addr,\r\nu32 aspace, u32 cycle)\r\n{\r\nu16 retval = 0xffff;\r\nint i;\r\nunsigned long long start, end, offset;\r\nu16 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif ((addr >= start) && ((addr + 1) < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u16 *)(bridge->slaves[i].buf_base + offset);\r\nretval = *loc;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\nreturn retval;\r\n}\r\nstatic u32 fake_vmeread32(struct fake_driver *bridge, unsigned long long addr,\r\nu32 aspace, u32 cycle)\r\n{\r\nu32 retval = 0xffffffff;\r\nint i;\r\nunsigned long long start, end, offset;\r\nu32 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif ((addr >= start) && ((addr + 3) < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u32 *)(bridge->slaves[i].buf_base + offset);\r\nretval = *loc;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\nreturn retval;\r\n}\r\nstatic ssize_t fake_master_read(struct vme_master_resource *image, void *buf,\r\nsize_t count, loff_t offset)\r\n{\r\nint retval;\r\nu32 aspace, cycle, dwidth;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *priv;\r\nint i;\r\nunsigned long long addr;\r\nunsigned int done = 0;\r\nunsigned int count32;\r\nfake_bridge = image->parent;\r\npriv = fake_bridge->driver_priv;\r\ni = image->number;\r\naddr = (unsigned long long)priv->masters[i].vme_base + offset;\r\naspace = priv->masters[i].aspace;\r\ncycle = priv->masters[i].cycle;\r\ndwidth = priv->masters[i].dwidth;\r\nspin_lock(&image->lock);\r\nif (addr & 0x1) {\r\n*(u8 *)buf = fake_vmeread8(priv, addr, aspace, cycle);\r\ndone += 1;\r\nif (done == count)\r\ngoto out;\r\n}\r\nif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\r\nif ((addr + done) & 0x2) {\r\nif ((count - done) < 2) {\r\n*(u8 *)(buf + done) = fake_vmeread8(priv,\r\naddr + done, aspace, cycle);\r\ndone += 1;\r\ngoto out;\r\n} else {\r\n*(u16 *)(buf + done) = fake_vmeread16(priv,\r\naddr + done, aspace, cycle);\r\ndone += 2;\r\n}\r\n}\r\n}\r\nif (dwidth == VME_D32) {\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\n*(u32 *)(buf + done) = fake_vmeread32(priv, addr + done,\r\naspace, cycle);\r\ndone += 4;\r\n}\r\n} else if (dwidth == VME_D16) {\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\n*(u16 *)(buf + done) = fake_vmeread16(priv, addr + done,\r\naspace, cycle);\r\ndone += 2;\r\n}\r\n} else if (dwidth == VME_D8) {\r\ncount32 = (count - done);\r\nwhile (done < count32) {\r\n*(u8 *)(buf + done) = fake_vmeread8(priv, addr + done,\r\naspace, cycle);\r\ndone += 1;\r\n}\r\n}\r\nif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\r\nif ((count - done) & 0x2) {\r\n*(u16 *)(buf + done) = fake_vmeread16(priv, addr + done,\r\naspace, cycle);\r\ndone += 2;\r\n}\r\n}\r\nif ((count - done) & 0x1) {\r\n*(u8 *)(buf + done) = fake_vmeread8(priv, addr + done, aspace,\r\ncycle);\r\ndone += 1;\r\n}\r\nout:\r\nretval = count;\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic void fake_vmewrite8(struct fake_driver *bridge, u8 *buf,\r\nunsigned long long addr, u32 aspace, u32 cycle)\r\n{\r\nint i;\r\nunsigned long long start, end, offset;\r\nu8 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif ((addr >= start) && (addr < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u8 *)((void *)bridge->slaves[i].buf_base + offset);\r\n*loc = *buf;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\n}\r\nstatic void fake_vmewrite16(struct fake_driver *bridge, u16 *buf,\r\nunsigned long long addr, u32 aspace, u32 cycle)\r\n{\r\nint i;\r\nunsigned long long start, end, offset;\r\nu16 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif ((addr >= start) && ((addr + 1) < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u16 *)((void *)bridge->slaves[i].buf_base + offset);\r\n*loc = *buf;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\n}\r\nstatic void fake_vmewrite32(struct fake_driver *bridge, u32 *buf,\r\nunsigned long long addr, u32 aspace, u32 cycle)\r\n{\r\nint i;\r\nunsigned long long start, end, offset;\r\nu32 *loc;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nif (aspace != bridge->slaves[i].aspace)\r\ncontinue;\r\nif (cycle != bridge->slaves[i].cycle)\r\ncontinue;\r\nstart = bridge->slaves[i].vme_base;\r\nend = bridge->slaves[i].vme_base + bridge->slaves[i].size;\r\nif ((addr >= start) && ((addr + 3) < end)) {\r\noffset = addr - bridge->slaves[i].vme_base;\r\nloc = (u32 *)((void *)bridge->slaves[i].buf_base + offset);\r\n*loc = *buf;\r\nbreak;\r\n}\r\n}\r\nfake_lm_check(bridge, addr, aspace, cycle);\r\n}\r\nstatic ssize_t fake_master_write(struct vme_master_resource *image, void *buf,\r\nsize_t count, loff_t offset)\r\n{\r\nint retval = 0;\r\nu32 aspace, cycle, dwidth;\r\nunsigned long long addr;\r\nint i;\r\nunsigned int done = 0;\r\nunsigned int count32;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = image->parent;\r\nbridge = fake_bridge->driver_priv;\r\ni = image->number;\r\naddr = bridge->masters[i].vme_base + offset;\r\naspace = bridge->masters[i].aspace;\r\ncycle = bridge->masters[i].cycle;\r\ndwidth = bridge->masters[i].dwidth;\r\nspin_lock(&image->lock);\r\nif (addr & 0x1) {\r\nfake_vmewrite8(bridge, (u8 *)buf, addr, aspace, cycle);\r\ndone += 1;\r\nif (done == count)\r\ngoto out;\r\n}\r\nif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\r\nif ((addr + done) & 0x2) {\r\nif ((count - done) < 2) {\r\nfake_vmewrite8(bridge, (u8 *)(buf + done),\r\naddr + done, aspace, cycle);\r\ndone += 1;\r\ngoto out;\r\n} else {\r\nfake_vmewrite16(bridge, (u16 *)(buf + done),\r\naddr + done, aspace, cycle);\r\ndone += 2;\r\n}\r\n}\r\n}\r\nif (dwidth == VME_D32) {\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\nfake_vmewrite32(bridge, (u32 *)(buf + done),\r\naddr + done, aspace, cycle);\r\ndone += 4;\r\n}\r\n} else if (dwidth == VME_D16) {\r\ncount32 = (count - done) & ~0x3;\r\nwhile (done < count32) {\r\nfake_vmewrite16(bridge, (u16 *)(buf + done),\r\naddr + done, aspace, cycle);\r\ndone += 2;\r\n}\r\n} else if (dwidth == VME_D8) {\r\ncount32 = (count - done);\r\nwhile (done < count32) {\r\nfake_vmewrite8(bridge, (u8 *)(buf + done), addr + done,\r\naspace, cycle);\r\ndone += 1;\r\n}\r\n}\r\nif ((dwidth == VME_D16) || (dwidth == VME_D32)) {\r\nif ((count - done) & 0x2) {\r\nfake_vmewrite16(bridge, (u16 *)(buf + done),\r\naddr + done, aspace, cycle);\r\ndone += 2;\r\n}\r\n}\r\nif ((count - done) & 0x1) {\r\nfake_vmewrite8(bridge, (u8 *)(buf + done), addr + done, aspace,\r\ncycle);\r\ndone += 1;\r\n}\r\nout:\r\nretval = count;\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic unsigned int fake_master_rmw(struct vme_master_resource *image,\r\nunsigned int mask, unsigned int compare, unsigned int swap,\r\nloff_t offset)\r\n{\r\nu32 tmp, base;\r\nu32 aspace, cycle;\r\nint i;\r\nstruct fake_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nbase = bridge->masters[i].vme_base;\r\naspace = bridge->masters[i].aspace;\r\ncycle = bridge->masters[i].cycle;\r\nspin_lock(&image->lock);\r\ntmp = fake_vmeread32(bridge, base + offset, aspace, cycle);\r\nif ((tmp && mask) == (compare && mask)) {\r\ntmp = tmp | (mask | swap);\r\ntmp = tmp & (~mask | swap);\r\nfake_vmewrite32(bridge, &tmp, base + offset, aspace, cycle);\r\n}\r\nspin_unlock(&image->lock);\r\nreturn tmp;\r\n}\r\nstatic int fake_lm_set(struct vme_lm_resource *lm, unsigned long long lm_base,\r\nu32 aspace, u32 cycle)\r\n{\r\nint i;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = lm->parent;\r\nbridge = fake_bridge->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nfor (i = 0; i < lm->monitors; i++) {\r\nif (bridge->lm_callback[i] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\npr_err("Location monitor callback attached, can't reset\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\ncase VME_A24:\r\ncase VME_A32:\r\ncase VME_A64:\r\nbreak;\r\ndefault:\r\nmutex_unlock(&lm->mtx);\r\npr_err("Invalid address space\n");\r\nreturn -EINVAL;\r\n}\r\nbridge->lm_base = lm_base;\r\nbridge->lm_aspace = aspace;\r\nbridge->lm_cycle = cycle;\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int fake_lm_get(struct vme_lm_resource *lm,\r\nunsigned long long *lm_base, u32 *aspace, u32 *cycle)\r\n{\r\nstruct fake_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\n*lm_base = bridge->lm_base;\r\n*aspace = bridge->lm_aspace;\r\n*cycle = bridge->lm_cycle;\r\nmutex_unlock(&lm->mtx);\r\nreturn bridge->lm_enabled;\r\n}\r\nstatic int fake_lm_attach(struct vme_lm_resource *lm, int monitor,\r\nvoid (*callback)(void *), void *data)\r\n{\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = lm->parent;\r\nbridge = fake_bridge->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nif (bridge->lm_cycle == 0) {\r\nmutex_unlock(&lm->mtx);\r\npr_err("Location monitor not properly configured\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->lm_callback[monitor] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\npr_err("Existing callback attached\n");\r\nreturn -EBUSY;\r\n}\r\nbridge->lm_callback[monitor] = callback;\r\nbridge->lm_data[monitor] = data;\r\nbridge->lm_enabled = 1;\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int fake_lm_detach(struct vme_lm_resource *lm, int monitor)\r\n{\r\nu32 tmp;\r\nint i;\r\nstruct fake_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nbridge->lm_callback[monitor] = NULL;\r\nbridge->lm_data[monitor] = NULL;\r\ntmp = 0;\r\nfor (i = 0; i < lm->monitors; i++) {\r\nif (bridge->lm_callback[i] != NULL)\r\ntmp = 1;\r\n}\r\nif (tmp == 0)\r\nbridge->lm_enabled = 0;\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int fake_slot_get(struct vme_bridge *fake_bridge)\r\n{\r\nreturn geoid;\r\n}\r\nstatic void *fake_alloc_consistent(struct device *parent, size_t size,\r\ndma_addr_t *dma)\r\n{\r\nvoid *alloc = kmalloc(size, GFP_KERNEL);\r\nif (alloc != NULL)\r\n*dma = fake_ptr_to_pci(alloc);\r\nreturn alloc;\r\n}\r\nstatic void fake_free_consistent(struct device *parent, size_t size,\r\nvoid *vaddr, dma_addr_t dma)\r\n{\r\nkfree(vaddr);\r\n}\r\nstatic int fake_crcsr_init(struct vme_bridge *fake_bridge)\r\n{\r\nu32 vstat;\r\nstruct fake_driver *bridge;\r\nbridge = fake_bridge->driver_priv;\r\nbridge->crcsr_kernel = kzalloc(VME_CRCSR_BUF_SIZE, GFP_KERNEL);\r\nbridge->crcsr_bus = fake_ptr_to_pci(bridge->crcsr_kernel);\r\nif (bridge->crcsr_kernel == NULL)\r\nreturn -ENOMEM;\r\nvstat = fake_slot_get(fake_bridge);\r\npr_info("CR/CSR Offset: %d\n", vstat);\r\nreturn 0;\r\n}\r\nstatic void fake_crcsr_exit(struct vme_bridge *fake_bridge)\r\n{\r\nstruct fake_driver *bridge;\r\nbridge = fake_bridge->driver_priv;\r\nkfree(bridge->crcsr_kernel);\r\n}\r\nstatic int __init fake_init(void)\r\n{\r\nint retval, i;\r\nstruct list_head *pos = NULL, *n;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *fake_device;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nstruct vme_lm_resource *lm;\r\nvme_root = __root_device_register("vme", THIS_MODULE);\r\nfake_bridge = kzalloc(sizeof(struct vme_bridge), GFP_KERNEL);\r\nif (fake_bridge == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_struct;\r\n}\r\nfake_device = kzalloc(sizeof(struct fake_driver), GFP_KERNEL);\r\nif (fake_device == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_driver;\r\n}\r\nfake_bridge->driver_priv = fake_device;\r\nfake_bridge->parent = vme_root;\r\nfake_device->parent = fake_bridge;\r\nmutex_init(&fake_device->vme_int);\r\nmutex_init(&fake_bridge->irq_mtx);\r\ntasklet_init(&fake_device->int_tasklet, fake_VIRQ_tasklet,\r\n(unsigned long) fake_bridge);\r\nstrcpy(fake_bridge->name, driver_name);\r\nINIT_LIST_HEAD(&fake_bridge->master_resources);\r\nfor (i = 0; i < FAKE_MAX_MASTER; i++) {\r\nmaster_image = kmalloc(sizeof(struct vme_master_resource),\r\nGFP_KERNEL);\r\nif (master_image == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_master;\r\n}\r\nmaster_image->parent = fake_bridge;\r\nspin_lock_init(&master_image->lock);\r\nmaster_image->locked = 0;\r\nmaster_image->number = i;\r\nmaster_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\r\nVME_A64;\r\nmaster_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\r\nVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\r\nVME_PROG | VME_DATA;\r\nmaster_image->width_attr = VME_D16 | VME_D32;\r\nmemset(&master_image->bus_resource, 0,\r\nsizeof(struct resource));\r\nmaster_image->kern_base = NULL;\r\nlist_add_tail(&master_image->list,\r\n&fake_bridge->master_resources);\r\n}\r\nINIT_LIST_HEAD(&fake_bridge->slave_resources);\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++) {\r\nslave_image = kmalloc(sizeof(struct vme_slave_resource),\r\nGFP_KERNEL);\r\nif (slave_image == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_slave;\r\n}\r\nslave_image->parent = fake_bridge;\r\nmutex_init(&slave_image->mtx);\r\nslave_image->locked = 0;\r\nslave_image->number = i;\r\nslave_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\r\nVME_A64 | VME_CRCSR | VME_USER1 | VME_USER2 |\r\nVME_USER3 | VME_USER4;\r\nslave_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\r\nVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\r\nVME_PROG | VME_DATA;\r\nlist_add_tail(&slave_image->list,\r\n&fake_bridge->slave_resources);\r\n}\r\nINIT_LIST_HEAD(&fake_bridge->lm_resources);\r\nlm = kmalloc(sizeof(struct vme_lm_resource), GFP_KERNEL);\r\nif (lm == NULL) {\r\npr_err("Failed to allocate memory for location monitor resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_lm;\r\n}\r\nlm->parent = fake_bridge;\r\nmutex_init(&lm->mtx);\r\nlm->locked = 0;\r\nlm->number = 1;\r\nlm->monitors = 4;\r\nlist_add_tail(&lm->list, &fake_bridge->lm_resources);\r\nfake_bridge->slave_get = fake_slave_get;\r\nfake_bridge->slave_set = fake_slave_set;\r\nfake_bridge->master_get = fake_master_get;\r\nfake_bridge->master_set = fake_master_set;\r\nfake_bridge->master_read = fake_master_read;\r\nfake_bridge->master_write = fake_master_write;\r\nfake_bridge->master_rmw = fake_master_rmw;\r\nfake_bridge->irq_set = fake_irq_set;\r\nfake_bridge->irq_generate = fake_irq_generate;\r\nfake_bridge->lm_set = fake_lm_set;\r\nfake_bridge->lm_get = fake_lm_get;\r\nfake_bridge->lm_attach = fake_lm_attach;\r\nfake_bridge->lm_detach = fake_lm_detach;\r\nfake_bridge->slot_get = fake_slot_get;\r\nfake_bridge->alloc_consistent = fake_alloc_consistent;\r\nfake_bridge->free_consistent = fake_free_consistent;\r\npr_info("Board is%s the VME system controller\n",\r\n(geoid == 1) ? "" : " not");\r\npr_info("VME geographical address is set to %d\n", geoid);\r\nretval = fake_crcsr_init(fake_bridge);\r\nif (retval) {\r\npr_err("CR/CSR configuration failed.\n");\r\ngoto err_crcsr;\r\n}\r\nretval = vme_register_bridge(fake_bridge);\r\nif (retval != 0) {\r\npr_err("Chip Registration failed.\n");\r\ngoto err_reg;\r\n}\r\nexit_pointer = fake_bridge;\r\nreturn 0;\r\nerr_reg:\r\nfake_crcsr_exit(fake_bridge);\r\nerr_crcsr:\r\nerr_lm:\r\nlist_for_each_safe(pos, n, &fake_bridge->lm_resources) {\r\nlm = list_entry(pos, struct vme_lm_resource, list);\r\nlist_del(pos);\r\nkfree(lm);\r\n}\r\nerr_slave:\r\nlist_for_each_safe(pos, n, &fake_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nerr_master:\r\nlist_for_each_safe(pos, n, &fake_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\nkfree(fake_device);\r\nerr_driver:\r\nkfree(fake_bridge);\r\nerr_struct:\r\nreturn retval;\r\n}\r\nstatic void __exit fake_exit(void)\r\n{\r\nstruct list_head *pos = NULL;\r\nstruct list_head *tmplist;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nint i;\r\nstruct vme_bridge *fake_bridge;\r\nstruct fake_driver *bridge;\r\nfake_bridge = exit_pointer;\r\nbridge = fake_bridge->driver_priv;\r\npr_debug("Driver is being unloaded.\n");\r\nfor (i = 0; i < FAKE_MAX_MASTER; i++)\r\nbridge->masters[i].enabled = 0;\r\nfor (i = 0; i < FAKE_MAX_SLAVE; i++)\r\nbridge->slaves[i].enabled = 0;\r\nbridge->lm_enabled = 0;\r\nvme_unregister_bridge(fake_bridge);\r\nfake_crcsr_exit(fake_bridge);\r\nlist_for_each_safe(pos, tmplist, &fake_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nlist_for_each_safe(pos, tmplist, &fake_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\nkfree(fake_bridge->driver_priv);\r\nkfree(fake_bridge);\r\nroot_device_unregister(vme_root);\r\n}
