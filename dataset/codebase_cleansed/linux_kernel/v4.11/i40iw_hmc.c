static inline void i40iw_find_sd_index_limit(struct i40iw_hmc_info *hmc_info,\r\nu32 type,\r\nu32 idx,\r\nu32 cnt,\r\nu32 *sd_idx,\r\nu32 *sd_limit)\r\n{\r\nu64 fpm_addr, fpm_limit;\r\nfpm_addr = hmc_info->hmc_obj[(type)].base +\r\nhmc_info->hmc_obj[type].size * idx;\r\nfpm_limit = fpm_addr + hmc_info->hmc_obj[type].size * cnt;\r\n*sd_idx = (u32)(fpm_addr / I40IW_HMC_DIRECT_BP_SIZE);\r\n*sd_limit = (u32)((fpm_limit - 1) / I40IW_HMC_DIRECT_BP_SIZE);\r\n*sd_limit += 1;\r\n}\r\nstatic inline void i40iw_find_pd_index_limit(struct i40iw_hmc_info *hmc_info,\r\nu32 type,\r\nu32 idx,\r\nu32 cnt,\r\nu32 *pd_idx,\r\nu32 *pd_limit)\r\n{\r\nu64 fpm_adr, fpm_limit;\r\nfpm_adr = hmc_info->hmc_obj[type].base +\r\nhmc_info->hmc_obj[type].size * idx;\r\nfpm_limit = fpm_adr + (hmc_info)->hmc_obj[(type)].size * (cnt);\r\n*(pd_idx) = (u32)(fpm_adr / I40IW_HMC_PAGED_BP_SIZE);\r\n*(pd_limit) = (u32)((fpm_limit - 1) / I40IW_HMC_PAGED_BP_SIZE);\r\n*(pd_limit) += 1;\r\n}\r\nstatic inline void i40iw_set_sd_entry(u64 pa,\r\nu32 idx,\r\nenum i40iw_sd_entry_type type,\r\nstruct update_sd_entry *entry)\r\n{\r\nentry->data = pa | (I40IW_HMC_MAX_BP_COUNT << I40E_PFHMC_SDDATALOW_PMSDBPCOUNT_SHIFT) |\r\n(((type == I40IW_SD_TYPE_PAGED) ? 0 : 1) <<\r\nI40E_PFHMC_SDDATALOW_PMSDTYPE_SHIFT) |\r\n(1 << I40E_PFHMC_SDDATALOW_PMSDVALID_SHIFT);\r\nentry->cmd = (idx | (1 << I40E_PFHMC_SDCMD_PMSDWR_SHIFT) | (1 << 15));\r\n}\r\nstatic inline void i40iw_clr_sd_entry(u32 idx, enum i40iw_sd_entry_type type,\r\nstruct update_sd_entry *entry)\r\n{\r\nentry->data = (I40IW_HMC_MAX_BP_COUNT <<\r\nI40E_PFHMC_SDDATALOW_PMSDBPCOUNT_SHIFT) |\r\n(((type == I40IW_SD_TYPE_PAGED) ? 0 : 1) <<\r\nI40E_PFHMC_SDDATALOW_PMSDTYPE_SHIFT);\r\nentry->cmd = (idx | (1 << I40E_PFHMC_SDCMD_PMSDWR_SHIFT) | (1 << 15));\r\n}\r\nenum i40iw_status_code i40iw_hmc_sd_one(struct i40iw_sc_dev *dev,\r\nu8 hmc_fn_id,\r\nu64 pa, u32 sd_idx,\r\nenum i40iw_sd_entry_type type,\r\nbool setsd)\r\n{\r\nstruct i40iw_update_sds_info sdinfo;\r\nsdinfo.cnt = 1;\r\nsdinfo.hmc_fn_id = hmc_fn_id;\r\nif (setsd)\r\ni40iw_set_sd_entry(pa, sd_idx, type, sdinfo.entry);\r\nelse\r\ni40iw_clr_sd_entry(sd_idx, type, sdinfo.entry);\r\nreturn dev->cqp->process_cqp_sds(dev, &sdinfo);\r\n}\r\nstatic enum i40iw_status_code i40iw_hmc_sd_grp(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_info *hmc_info,\r\nu32 sd_index,\r\nu32 sd_cnt,\r\nbool setsd)\r\n{\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nstruct i40iw_update_sds_info sdinfo;\r\nu64 pa;\r\nu32 i;\r\nenum i40iw_status_code ret_code = 0;\r\nmemset(&sdinfo, 0, sizeof(sdinfo));\r\nsdinfo.hmc_fn_id = hmc_info->hmc_fn_id;\r\nfor (i = sd_index; i < sd_index + sd_cnt; i++) {\r\nsd_entry = &hmc_info->sd_table.sd_entry[i];\r\nif (!sd_entry ||\r\n(!sd_entry->valid && setsd) ||\r\n(sd_entry->valid && !setsd))\r\ncontinue;\r\nif (setsd) {\r\npa = (sd_entry->entry_type == I40IW_SD_TYPE_PAGED) ?\r\nsd_entry->u.pd_table.pd_page_addr.pa :\r\nsd_entry->u.bp.addr.pa;\r\ni40iw_set_sd_entry(pa, i, sd_entry->entry_type,\r\n&sdinfo.entry[sdinfo.cnt]);\r\n} else {\r\ni40iw_clr_sd_entry(i, sd_entry->entry_type,\r\n&sdinfo.entry[sdinfo.cnt]);\r\n}\r\nsdinfo.cnt++;\r\nif (sdinfo.cnt == I40IW_MAX_SD_ENTRIES) {\r\nret_code = dev->cqp->process_cqp_sds(dev, &sdinfo);\r\nif (ret_code) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC,\r\n"i40iw_hmc_sd_grp: sd_programming failed err=%d\n",\r\nret_code);\r\nreturn ret_code;\r\n}\r\nsdinfo.cnt = 0;\r\n}\r\n}\r\nif (sdinfo.cnt)\r\nret_code = dev->cqp->process_cqp_sds(dev, &sdinfo);\r\nreturn ret_code;\r\n}\r\nstruct i40iw_vfdev *i40iw_vfdev_from_fpm(struct i40iw_sc_dev *dev, u8 hmc_fn_id)\r\n{\r\nstruct i40iw_vfdev *vf_dev = NULL;\r\nu16 idx;\r\nfor (idx = 0; idx < I40IW_MAX_PE_ENABLED_VF_COUNT; idx++) {\r\nif (dev->vf_dev[idx] &&\r\n((u8)dev->vf_dev[idx]->pmf_index == hmc_fn_id)) {\r\nvf_dev = dev->vf_dev[idx];\r\nbreak;\r\n}\r\n}\r\nreturn vf_dev;\r\n}\r\nstruct i40iw_hmc_info *i40iw_vf_hmcinfo_from_fpm(struct i40iw_sc_dev *dev,\r\nu8 hmc_fn_id)\r\n{\r\nstruct i40iw_hmc_info *hmc_info = NULL;\r\nu16 idx;\r\nfor (idx = 0; idx < I40IW_MAX_PE_ENABLED_VF_COUNT; idx++) {\r\nif (dev->vf_dev[idx] &&\r\n((u8)dev->vf_dev[idx]->pmf_index == hmc_fn_id)) {\r\nhmc_info = &dev->vf_dev[idx]->hmc_info;\r\nbreak;\r\n}\r\n}\r\nreturn hmc_info;\r\n}\r\nstatic enum i40iw_status_code i40iw_hmc_finish_add_sd_reg(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_create_obj_info *info)\r\n{\r\nif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt)\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_INDEX;\r\nif ((info->start_idx + info->count) >\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt)\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_COUNT;\r\nif (!info->add_sd_cnt)\r\nreturn 0;\r\nreturn i40iw_hmc_sd_grp(dev, info->hmc_info,\r\ninfo->hmc_info->sd_indexes[0],\r\ninfo->add_sd_cnt, true);\r\n}\r\nenum i40iw_status_code i40iw_sc_create_hmc_obj(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_create_obj_info *info)\r\n{\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nu32 sd_idx, sd_lmt;\r\nu32 pd_idx = 0, pd_lmt = 0;\r\nu32 pd_idx1 = 0, pd_lmt1 = 0;\r\nu32 i, j;\r\nbool pd_error = false;\r\nenum i40iw_status_code ret_code = 0;\r\nif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt)\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_INDEX;\r\nif ((info->start_idx + info->count) >\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC,\r\n"%s: error type %u, start = %u, req cnt %u, cnt = %u\n",\r\n__func__, info->rsrc_type, info->start_idx, info->count,\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt);\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_COUNT;\r\n}\r\nif (!dev->is_pf)\r\nreturn i40iw_vchnl_vf_add_hmc_objs(dev, info->rsrc_type, 0, info->count);\r\ni40iw_find_sd_index_limit(info->hmc_info, info->rsrc_type,\r\ninfo->start_idx, info->count,\r\n&sd_idx, &sd_lmt);\r\nif (sd_idx >= info->hmc_info->sd_table.sd_cnt ||\r\nsd_lmt > info->hmc_info->sd_table.sd_cnt) {\r\nreturn I40IW_ERR_INVALID_SD_INDEX;\r\n}\r\ni40iw_find_pd_index_limit(info->hmc_info, info->rsrc_type,\r\ninfo->start_idx, info->count, &pd_idx, &pd_lmt);\r\nfor (j = sd_idx; j < sd_lmt; j++) {\r\nret_code = i40iw_add_sd_table_entry(dev->hw, info->hmc_info,\r\nj,\r\ninfo->entry_type,\r\nI40IW_HMC_DIRECT_BP_SIZE);\r\nif (ret_code)\r\ngoto exit_sd_error;\r\nsd_entry = &info->hmc_info->sd_table.sd_entry[j];\r\nif ((sd_entry->entry_type == I40IW_SD_TYPE_PAGED) &&\r\n((dev->hmc_info == info->hmc_info) &&\r\n(info->rsrc_type != I40IW_HMC_IW_PBLE))) {\r\npd_idx1 = max(pd_idx, (j * I40IW_HMC_MAX_BP_COUNT));\r\npd_lmt1 = min(pd_lmt,\r\n(j + 1) * I40IW_HMC_MAX_BP_COUNT);\r\nfor (i = pd_idx1; i < pd_lmt1; i++) {\r\nret_code = i40iw_add_pd_table_entry(dev->hw, info->hmc_info,\r\ni, NULL);\r\nif (ret_code) {\r\npd_error = true;\r\nbreak;\r\n}\r\n}\r\nif (pd_error) {\r\nwhile (i && (i > pd_idx1)) {\r\ni40iw_remove_pd_bp(dev->hw, info->hmc_info, (i - 1),\r\ninfo->is_pf);\r\ni--;\r\n}\r\n}\r\n}\r\nif (sd_entry->valid)\r\ncontinue;\r\ninfo->hmc_info->sd_indexes[info->add_sd_cnt] = (u16)j;\r\ninfo->add_sd_cnt++;\r\nsd_entry->valid = true;\r\n}\r\nreturn i40iw_hmc_finish_add_sd_reg(dev, info);\r\nexit_sd_error:\r\nwhile (j && (j > sd_idx)) {\r\nsd_entry = &info->hmc_info->sd_table.sd_entry[j - 1];\r\nswitch (sd_entry->entry_type) {\r\ncase I40IW_SD_TYPE_PAGED:\r\npd_idx1 = max(pd_idx,\r\n(j - 1) * I40IW_HMC_MAX_BP_COUNT);\r\npd_lmt1 = min(pd_lmt, (j * I40IW_HMC_MAX_BP_COUNT));\r\nfor (i = pd_idx1; i < pd_lmt1; i++)\r\ni40iw_prep_remove_pd_page(info->hmc_info, i);\r\nbreak;\r\ncase I40IW_SD_TYPE_DIRECT:\r\ni40iw_prep_remove_pd_page(info->hmc_info, (j - 1));\r\nbreak;\r\ndefault:\r\nret_code = I40IW_ERR_INVALID_SD_TYPE;\r\nbreak;\r\n}\r\nj--;\r\n}\r\nreturn ret_code;\r\n}\r\nstatic enum i40iw_status_code i40iw_finish_del_sd_reg(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_del_obj_info *info,\r\nbool reset)\r\n{\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nenum i40iw_status_code ret_code = 0;\r\nu32 i, sd_idx;\r\nstruct i40iw_dma_mem *mem;\r\nif (dev->is_pf && !reset)\r\nret_code = i40iw_hmc_sd_grp(dev, info->hmc_info,\r\ninfo->hmc_info->sd_indexes[0],\r\ninfo->del_sd_cnt, false);\r\nif (ret_code)\r\ni40iw_debug(dev, I40IW_DEBUG_HMC, "%s: error cqp sd sd_grp\n", __func__);\r\nfor (i = 0; i < info->del_sd_cnt; i++) {\r\nsd_idx = info->hmc_info->sd_indexes[i];\r\nsd_entry = &info->hmc_info->sd_table.sd_entry[sd_idx];\r\nif (!sd_entry)\r\ncontinue;\r\nmem = (sd_entry->entry_type == I40IW_SD_TYPE_PAGED) ?\r\n&sd_entry->u.pd_table.pd_page_addr :\r\n&sd_entry->u.bp.addr;\r\nif (!mem || !mem->va)\r\ni40iw_debug(dev, I40IW_DEBUG_HMC, "%s: error cqp sd mem\n", __func__);\r\nelse\r\ni40iw_free_dma_mem(dev->hw, mem);\r\n}\r\nreturn ret_code;\r\n}\r\nenum i40iw_status_code i40iw_sc_del_hmc_obj(struct i40iw_sc_dev *dev,\r\nstruct i40iw_hmc_del_obj_info *info,\r\nbool reset)\r\n{\r\nstruct i40iw_hmc_pd_table *pd_table;\r\nu32 sd_idx, sd_lmt;\r\nu32 pd_idx, pd_lmt, rel_pd_idx;\r\nu32 i, j;\r\nenum i40iw_status_code ret_code = 0;\r\nif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC,\r\n"%s: error start_idx[%04d] >= [type %04d].cnt[%04d]\n",\r\n__func__, info->start_idx, info->rsrc_type,\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt);\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_INDEX;\r\n}\r\nif ((info->start_idx + info->count) >\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC,\r\n"%s: error start_idx[%04d] + count %04d >= [type %04d].cnt[%04d]\n",\r\n__func__, info->start_idx, info->count,\r\ninfo->rsrc_type,\r\ninfo->hmc_info->hmc_obj[info->rsrc_type].cnt);\r\nreturn I40IW_ERR_INVALID_HMC_OBJ_COUNT;\r\n}\r\nif (!dev->is_pf) {\r\nret_code = i40iw_vchnl_vf_del_hmc_obj(dev, info->rsrc_type, 0,\r\ninfo->count);\r\nif (info->rsrc_type != I40IW_HMC_IW_PBLE)\r\nreturn ret_code;\r\n}\r\ni40iw_find_pd_index_limit(info->hmc_info, info->rsrc_type,\r\ninfo->start_idx, info->count, &pd_idx, &pd_lmt);\r\nfor (j = pd_idx; j < pd_lmt; j++) {\r\nsd_idx = j / I40IW_HMC_PD_CNT_IN_SD;\r\nif (info->hmc_info->sd_table.sd_entry[sd_idx].entry_type !=\r\nI40IW_SD_TYPE_PAGED)\r\ncontinue;\r\nrel_pd_idx = j % I40IW_HMC_PD_CNT_IN_SD;\r\npd_table = &info->hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\r\nif (pd_table->pd_entry[rel_pd_idx].valid) {\r\nret_code = i40iw_remove_pd_bp(dev->hw, info->hmc_info, j,\r\ninfo->is_pf);\r\nif (ret_code) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC, "%s: error\n", __func__);\r\nreturn ret_code;\r\n}\r\n}\r\n}\r\ni40iw_find_sd_index_limit(info->hmc_info, info->rsrc_type,\r\ninfo->start_idx, info->count, &sd_idx, &sd_lmt);\r\nif (sd_idx >= info->hmc_info->sd_table.sd_cnt ||\r\nsd_lmt > info->hmc_info->sd_table.sd_cnt) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC, "%s: error invalid sd_idx\n", __func__);\r\nreturn I40IW_ERR_INVALID_SD_INDEX;\r\n}\r\nfor (i = sd_idx; i < sd_lmt; i++) {\r\nif (!info->hmc_info->sd_table.sd_entry[i].valid)\r\ncontinue;\r\nswitch (info->hmc_info->sd_table.sd_entry[i].entry_type) {\r\ncase I40IW_SD_TYPE_DIRECT:\r\nret_code = i40iw_prep_remove_sd_bp(info->hmc_info, i);\r\nif (!ret_code) {\r\ninfo->hmc_info->sd_indexes[info->del_sd_cnt] = (u16)i;\r\ninfo->del_sd_cnt++;\r\n}\r\nbreak;\r\ncase I40IW_SD_TYPE_PAGED:\r\nret_code = i40iw_prep_remove_pd_page(info->hmc_info, i);\r\nif (!ret_code) {\r\ninfo->hmc_info->sd_indexes[info->del_sd_cnt] = (u16)i;\r\ninfo->del_sd_cnt++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn i40iw_finish_del_sd_reg(dev, info, reset);\r\n}\r\nenum i40iw_status_code i40iw_add_sd_table_entry(struct i40iw_hw *hw,\r\nstruct i40iw_hmc_info *hmc_info,\r\nu32 sd_index,\r\nenum i40iw_sd_entry_type type,\r\nu64 direct_mode_sz)\r\n{\r\nenum i40iw_status_code ret_code = 0;\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nbool dma_mem_alloc_done = false;\r\nstruct i40iw_dma_mem mem;\r\nu64 alloc_len;\r\nsd_entry = &hmc_info->sd_table.sd_entry[sd_index];\r\nif (!sd_entry->valid) {\r\nif (type == I40IW_SD_TYPE_PAGED)\r\nalloc_len = I40IW_HMC_PAGED_BP_SIZE;\r\nelse\r\nalloc_len = direct_mode_sz;\r\nret_code = i40iw_allocate_dma_mem(hw, &mem, alloc_len,\r\nI40IW_HMC_PD_BP_BUF_ALIGNMENT);\r\nif (ret_code)\r\ngoto exit;\r\ndma_mem_alloc_done = true;\r\nif (type == I40IW_SD_TYPE_PAGED) {\r\nret_code = i40iw_allocate_virt_mem(hw,\r\n&sd_entry->u.pd_table.pd_entry_virt_mem,\r\nsizeof(struct i40iw_hmc_pd_entry) * 512);\r\nif (ret_code)\r\ngoto exit;\r\nsd_entry->u.pd_table.pd_entry = (struct i40iw_hmc_pd_entry *)\r\nsd_entry->u.pd_table.pd_entry_virt_mem.va;\r\nmemcpy(&sd_entry->u.pd_table.pd_page_addr, &mem, sizeof(struct i40iw_dma_mem));\r\n} else {\r\nmemcpy(&sd_entry->u.bp.addr, &mem, sizeof(struct i40iw_dma_mem));\r\nsd_entry->u.bp.sd_pd_index = sd_index;\r\n}\r\nhmc_info->sd_table.sd_entry[sd_index].entry_type = type;\r\nI40IW_INC_SD_REFCNT(&hmc_info->sd_table);\r\n}\r\nif (sd_entry->entry_type == I40IW_SD_TYPE_DIRECT)\r\nI40IW_INC_BP_REFCNT(&sd_entry->u.bp);\r\nexit:\r\nif (ret_code)\r\nif (dma_mem_alloc_done)\r\ni40iw_free_dma_mem(hw, &mem);\r\nreturn ret_code;\r\n}\r\nenum i40iw_status_code i40iw_add_pd_table_entry(struct i40iw_hw *hw,\r\nstruct i40iw_hmc_info *hmc_info,\r\nu32 pd_index,\r\nstruct i40iw_dma_mem *rsrc_pg)\r\n{\r\nenum i40iw_status_code ret_code = 0;\r\nstruct i40iw_hmc_pd_table *pd_table;\r\nstruct i40iw_hmc_pd_entry *pd_entry;\r\nstruct i40iw_dma_mem mem;\r\nstruct i40iw_dma_mem *page = &mem;\r\nu32 sd_idx, rel_pd_idx;\r\nu64 *pd_addr;\r\nu64 page_desc;\r\nif (pd_index / I40IW_HMC_PD_CNT_IN_SD >= hmc_info->sd_table.sd_cnt)\r\nreturn I40IW_ERR_INVALID_PAGE_DESC_INDEX;\r\nsd_idx = (pd_index / I40IW_HMC_PD_CNT_IN_SD);\r\nif (hmc_info->sd_table.sd_entry[sd_idx].entry_type != I40IW_SD_TYPE_PAGED)\r\nreturn 0;\r\nrel_pd_idx = (pd_index % I40IW_HMC_PD_CNT_IN_SD);\r\npd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\r\npd_entry = &pd_table->pd_entry[rel_pd_idx];\r\nif (!pd_entry->valid) {\r\nif (rsrc_pg) {\r\npd_entry->rsrc_pg = true;\r\npage = rsrc_pg;\r\n} else {\r\nret_code = i40iw_allocate_dma_mem(hw, page,\r\nI40IW_HMC_PAGED_BP_SIZE,\r\nI40IW_HMC_PD_BP_BUF_ALIGNMENT);\r\nif (ret_code)\r\nreturn ret_code;\r\npd_entry->rsrc_pg = false;\r\n}\r\nmemcpy(&pd_entry->bp.addr, page, sizeof(struct i40iw_dma_mem));\r\npd_entry->bp.sd_pd_index = pd_index;\r\npd_entry->bp.entry_type = I40IW_SD_TYPE_PAGED;\r\npage_desc = page->pa | 0x1;\r\npd_addr = (u64 *)pd_table->pd_page_addr.va;\r\npd_addr += rel_pd_idx;\r\nmemcpy(pd_addr, &page_desc, sizeof(*pd_addr));\r\npd_entry->sd_index = sd_idx;\r\npd_entry->valid = true;\r\nI40IW_INC_PD_REFCNT(pd_table);\r\nif (hmc_info->hmc_fn_id < I40IW_FIRST_VF_FPM_ID)\r\nI40IW_INVALIDATE_PF_HMC_PD(hw, sd_idx, rel_pd_idx);\r\nelse if (hw->hmc.hmc_fn_id != hmc_info->hmc_fn_id)\r\nI40IW_INVALIDATE_VF_HMC_PD(hw, sd_idx, rel_pd_idx,\r\nhmc_info->hmc_fn_id);\r\n}\r\nI40IW_INC_BP_REFCNT(&pd_entry->bp);\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_remove_pd_bp(struct i40iw_hw *hw,\r\nstruct i40iw_hmc_info *hmc_info,\r\nu32 idx,\r\nbool is_pf)\r\n{\r\nstruct i40iw_hmc_pd_entry *pd_entry;\r\nstruct i40iw_hmc_pd_table *pd_table;\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nu32 sd_idx, rel_pd_idx;\r\nstruct i40iw_dma_mem *mem;\r\nu64 *pd_addr;\r\nsd_idx = idx / I40IW_HMC_PD_CNT_IN_SD;\r\nrel_pd_idx = idx % I40IW_HMC_PD_CNT_IN_SD;\r\nif (sd_idx >= hmc_info->sd_table.sd_cnt)\r\nreturn I40IW_ERR_INVALID_PAGE_DESC_INDEX;\r\nsd_entry = &hmc_info->sd_table.sd_entry[sd_idx];\r\nif (sd_entry->entry_type != I40IW_SD_TYPE_PAGED)\r\nreturn I40IW_ERR_INVALID_SD_TYPE;\r\npd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\r\npd_entry = &pd_table->pd_entry[rel_pd_idx];\r\nI40IW_DEC_BP_REFCNT(&pd_entry->bp);\r\nif (pd_entry->bp.ref_cnt)\r\nreturn 0;\r\npd_entry->valid = false;\r\nI40IW_DEC_PD_REFCNT(pd_table);\r\npd_addr = (u64 *)pd_table->pd_page_addr.va;\r\npd_addr += rel_pd_idx;\r\nmemset(pd_addr, 0, sizeof(u64));\r\nif (is_pf)\r\nI40IW_INVALIDATE_PF_HMC_PD(hw, sd_idx, idx);\r\nelse\r\nI40IW_INVALIDATE_VF_HMC_PD(hw, sd_idx, idx,\r\nhmc_info->hmc_fn_id);\r\nif (!pd_entry->rsrc_pg) {\r\nmem = &pd_entry->bp.addr;\r\nif (!mem || !mem->va)\r\nreturn I40IW_ERR_PARAM;\r\ni40iw_free_dma_mem(hw, mem);\r\n}\r\nif (!pd_table->ref_cnt)\r\ni40iw_free_virt_mem(hw, &pd_table->pd_entry_virt_mem);\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_prep_remove_sd_bp(struct i40iw_hmc_info *hmc_info, u32 idx)\r\n{\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nsd_entry = &hmc_info->sd_table.sd_entry[idx];\r\nI40IW_DEC_BP_REFCNT(&sd_entry->u.bp);\r\nif (sd_entry->u.bp.ref_cnt)\r\nreturn I40IW_ERR_NOT_READY;\r\nI40IW_DEC_SD_REFCNT(&hmc_info->sd_table);\r\nsd_entry->valid = false;\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_prep_remove_pd_page(struct i40iw_hmc_info *hmc_info,\r\nu32 idx)\r\n{\r\nstruct i40iw_hmc_sd_entry *sd_entry;\r\nsd_entry = &hmc_info->sd_table.sd_entry[idx];\r\nif (sd_entry->u.pd_table.ref_cnt)\r\nreturn I40IW_ERR_NOT_READY;\r\nsd_entry->valid = false;\r\nI40IW_DEC_SD_REFCNT(&hmc_info->sd_table);\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_pf_init_vfhmc(struct i40iw_sc_dev *dev,\r\nu8 vf_hmc_fn_id,\r\nu32 *vf_cnt_array)\r\n{\r\nstruct i40iw_hmc_info *hmc_info;\r\nenum i40iw_status_code ret_code = 0;\r\nu32 i;\r\nif ((vf_hmc_fn_id < I40IW_FIRST_VF_FPM_ID) ||\r\n(vf_hmc_fn_id >= I40IW_FIRST_VF_FPM_ID +\r\nI40IW_MAX_PE_ENABLED_VF_COUNT)) {\r\ni40iw_debug(dev, I40IW_DEBUG_HMC, "%s: invalid vf_hmc_fn_id 0x%x\n",\r\n__func__, vf_hmc_fn_id);\r\nreturn I40IW_ERR_INVALID_HMCFN_ID;\r\n}\r\nret_code = i40iw_sc_init_iw_hmc(dev, vf_hmc_fn_id);\r\nif (ret_code)\r\nreturn ret_code;\r\nhmc_info = i40iw_vf_hmcinfo_from_fpm(dev, vf_hmc_fn_id);\r\nfor (i = I40IW_HMC_IW_QP; i < I40IW_HMC_IW_MAX; i++)\r\nif (vf_cnt_array)\r\nhmc_info->hmc_obj[i].cnt =\r\nvf_cnt_array[i - I40IW_HMC_IW_QP];\r\nelse\r\nhmc_info->hmc_obj[i].cnt = hmc_info->hmc_obj[i].max_cnt;\r\nreturn 0;\r\n}
