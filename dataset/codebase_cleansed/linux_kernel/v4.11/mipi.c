static inline u32 tegra_mipi_readl(struct tegra_mipi *mipi,\r\nunsigned long offset)\r\n{\r\nreturn readl(mipi->regs + (offset << 2));\r\n}\r\nstatic inline void tegra_mipi_writel(struct tegra_mipi *mipi, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, mipi->regs + (offset << 2));\r\n}\r\nstatic int tegra_mipi_power_up(struct tegra_mipi *mipi)\r\n{\r\nu32 value;\r\nint err;\r\nerr = clk_enable(mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG0);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_PDVCLAMP;\r\nif (mipi->soc->needs_vclamp_ref)\r\nvalue |= MIPI_CAL_BIAS_PAD_E_VCLAMP_REF;\r\ntegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG0);\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG2);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_PDVREG;\r\ntegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\r\nclk_disable(mipi->clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_mipi_power_down(struct tegra_mipi *mipi)\r\n{\r\nu32 value;\r\nint err;\r\nerr = clk_enable(mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG2);\r\nvalue |= MIPI_CAL_BIAS_PAD_PDVREG;\r\ntegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_BIAS_PAD_CFG0);\r\nif (mipi->soc->needs_vclamp_ref)\r\nvalue &= ~MIPI_CAL_BIAS_PAD_E_VCLAMP_REF;\r\nvalue |= MIPI_CAL_BIAS_PAD_PDVCLAMP;\r\ntegra_mipi_writel(mipi, value, MIPI_CAL_BIAS_PAD_CFG0);\r\nreturn 0;\r\n}\r\nstruct tegra_mipi_device *tegra_mipi_request(struct device *device)\r\n{\r\nstruct device_node *np = device->of_node;\r\nstruct tegra_mipi_device *dev;\r\nstruct of_phandle_args args;\r\nint err;\r\nerr = of_parse_phandle_with_args(np, "nvidia,mipi-calibrate",\r\n"#nvidia,mipi-calibrate-cells", 0,\r\n&args);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ndev->pdev = of_find_device_by_node(args.np);\r\nif (!dev->pdev) {\r\nerr = -ENODEV;\r\ngoto free;\r\n}\r\ndev->mipi = platform_get_drvdata(dev->pdev);\r\nif (!dev->mipi) {\r\nerr = -EPROBE_DEFER;\r\ngoto put;\r\n}\r\nof_node_put(args.np);\r\ndev->pads = args.args[0];\r\ndev->device = device;\r\nreturn dev;\r\nput:\r\nplatform_device_put(dev->pdev);\r\nfree:\r\nkfree(dev);\r\nout:\r\nof_node_put(args.np);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid tegra_mipi_free(struct tegra_mipi_device *device)\r\n{\r\nplatform_device_put(device->pdev);\r\nkfree(device);\r\n}\r\nint tegra_mipi_enable(struct tegra_mipi_device *dev)\r\n{\r\nint err = 0;\r\nmutex_lock(&dev->mipi->lock);\r\nif (dev->mipi->usage_count++ == 0)\r\nerr = tegra_mipi_power_up(dev->mipi);\r\nmutex_unlock(&dev->mipi->lock);\r\nreturn err;\r\n}\r\nint tegra_mipi_disable(struct tegra_mipi_device *dev)\r\n{\r\nint err = 0;\r\nmutex_lock(&dev->mipi->lock);\r\nif (--dev->mipi->usage_count == 0)\r\nerr = tegra_mipi_power_down(dev->mipi);\r\nmutex_unlock(&dev->mipi->lock);\r\nreturn err;\r\n}\r\nstatic int tegra_mipi_wait(struct tegra_mipi *mipi)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(250);\r\nu32 value;\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_STATUS);\r\nif ((value & MIPI_CAL_STATUS_ACTIVE) == 0 &&\r\n(value & MIPI_CAL_STATUS_DONE) != 0)\r\nreturn 0;\r\nusleep_range(10, 50);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint tegra_mipi_calibrate(struct tegra_mipi_device *device)\r\n{\r\nconst struct tegra_mipi_soc *soc = device->mipi->soc;\r\nunsigned int i;\r\nu32 value;\r\nint err;\r\nerr = clk_enable(device->mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&device->mipi->lock);\r\nvalue = MIPI_CAL_BIAS_PAD_DRV_DN_REF(soc->pad_drive_down_ref) |\r\nMIPI_CAL_BIAS_PAD_DRV_UP_REF(soc->pad_drive_up_ref);\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG1);\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_BIAS_PAD_CFG2);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_VCLAMP(0x7);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_VAUXP(0x7);\r\nvalue |= MIPI_CAL_BIAS_PAD_VCLAMP(soc->pad_vclamp_level);\r\nvalue |= MIPI_CAL_BIAS_PAD_VAUXP(soc->pad_vauxp_level);\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\r\nfor (i = 0; i < soc->num_pads; i++) {\r\nu32 clk = 0, data = 0;\r\nif (device->pads & BIT(i)) {\r\ndata = MIPI_CAL_CONFIG_SELECT |\r\nMIPI_CAL_CONFIG_HSPDOS(soc->hspdos) |\r\nMIPI_CAL_CONFIG_HSPUOS(soc->hspuos) |\r\nMIPI_CAL_CONFIG_TERMOS(soc->termos);\r\nclk = MIPI_CAL_CONFIG_SELECT |\r\nMIPI_CAL_CONFIG_HSCLKPDOSD(soc->hsclkpdos) |\r\nMIPI_CAL_CONFIG_HSCLKPUOSD(soc->hsclkpuos);\r\n}\r\ntegra_mipi_writel(device->mipi, data, soc->pads[i].data);\r\nif (soc->has_clk_lane && soc->pads[i].clk != 0)\r\ntegra_mipi_writel(device->mipi, clk, soc->pads[i].clk);\r\n}\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_CTRL);\r\nvalue &= ~MIPI_CAL_CTRL_NOISE_FILTER(0xf);\r\nvalue &= ~MIPI_CAL_CTRL_PRESCALE(0x3);\r\nvalue |= MIPI_CAL_CTRL_NOISE_FILTER(0xa);\r\nvalue |= MIPI_CAL_CTRL_PRESCALE(0x2);\r\nif (!soc->clock_enable_override)\r\nvalue &= ~MIPI_CAL_CTRL_CLKEN_OVR;\r\nelse\r\nvalue |= MIPI_CAL_CTRL_CLKEN_OVR;\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_CTRL);\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_STATUS);\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_STATUS);\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_CTRL);\r\nvalue |= MIPI_CAL_CTRL_START;\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_CTRL);\r\nerr = tegra_mipi_wait(device->mipi);\r\nmutex_unlock(&device->mipi->lock);\r\nclk_disable(device->mipi->clk);\r\nreturn err;\r\n}\r\nstatic int tegra_mipi_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct tegra_mipi *mipi;\r\nstruct resource *res;\r\nint err;\r\nmatch = of_match_node(tegra_mipi_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nmipi = devm_kzalloc(&pdev->dev, sizeof(*mipi), GFP_KERNEL);\r\nif (!mipi)\r\nreturn -ENOMEM;\r\nmipi->soc = match->data;\r\nmipi->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmipi->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mipi->regs))\r\nreturn PTR_ERR(mipi->regs);\r\nmutex_init(&mipi->lock);\r\nmipi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mipi->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(mipi->clk);\r\n}\r\nerr = clk_prepare(mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nplatform_set_drvdata(pdev, mipi);\r\nreturn 0;\r\n}\r\nstatic int tegra_mipi_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_mipi *mipi = platform_get_drvdata(pdev);\r\nclk_unprepare(mipi->clk);\r\nreturn 0;\r\n}
