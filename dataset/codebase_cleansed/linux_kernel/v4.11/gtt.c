static inline uint32_t psb_gtt_mask_pte(uint32_t pfn, int type)\r\n{\r\nuint32_t mask = PSB_PTE_VALID;\r\nBUG_ON(pfn & ~(0xFFFFFFFF >> PAGE_SHIFT));\r\nif (type & PSB_MMU_CACHED_MEMORY)\r\nmask |= PSB_PTE_CACHED;\r\nif (type & PSB_MMU_RO_MEMORY)\r\nmask |= PSB_PTE_RO;\r\nif (type & PSB_MMU_WO_MEMORY)\r\nmask |= PSB_PTE_WO;\r\nreturn (pfn << PAGE_SHIFT) | mask;\r\n}\r\nstatic u32 __iomem *psb_gtt_entry(struct drm_device *dev, struct gtt_range *r)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned long offset;\r\noffset = r->resource.start - dev_priv->gtt_mem->start;\r\nreturn dev_priv->gtt_map + (offset >> PAGE_SHIFT);\r\n}\r\nstatic int psb_gtt_insert(struct drm_device *dev, struct gtt_range *r,\r\nint resume)\r\n{\r\nu32 __iomem *gtt_slot;\r\nu32 pte;\r\nstruct page **pages;\r\nint i;\r\nif (r->pages == NULL) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(r->stolen);\r\ngtt_slot = psb_gtt_entry(dev, r);\r\npages = r->pages;\r\nif (!resume) {\r\nset_pages_array_wc(pages, r->npage);\r\n}\r\nfor (i = r->roll; i < r->npage; i++) {\r\npte = psb_gtt_mask_pte(page_to_pfn(r->pages[i]),\r\nPSB_MMU_CACHED_MEMORY);\r\niowrite32(pte, gtt_slot++);\r\n}\r\nfor (i = 0; i < r->roll; i++) {\r\npte = psb_gtt_mask_pte(page_to_pfn(r->pages[i]),\r\nPSB_MMU_CACHED_MEMORY);\r\niowrite32(pte, gtt_slot++);\r\n}\r\nioread32(gtt_slot - 1);\r\nreturn 0;\r\n}\r\nstatic void psb_gtt_remove(struct drm_device *dev, struct gtt_range *r)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 __iomem *gtt_slot;\r\nu32 pte;\r\nint i;\r\nWARN_ON(r->stolen);\r\ngtt_slot = psb_gtt_entry(dev, r);\r\npte = psb_gtt_mask_pte(page_to_pfn(dev_priv->scratch_page),\r\nPSB_MMU_CACHED_MEMORY);\r\nfor (i = 0; i < r->npage; i++)\r\niowrite32(pte, gtt_slot++);\r\nioread32(gtt_slot - 1);\r\nset_pages_array_wb(r->pages, r->npage);\r\n}\r\nvoid psb_gtt_roll(struct drm_device *dev, struct gtt_range *r, int roll)\r\n{\r\nu32 __iomem *gtt_slot;\r\nu32 pte;\r\nint i;\r\nif (roll >= r->npage) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nr->roll = roll;\r\nif (!r->stolen && !r->in_gart)\r\nreturn;\r\ngtt_slot = psb_gtt_entry(dev, r);\r\nfor (i = r->roll; i < r->npage; i++) {\r\npte = psb_gtt_mask_pte(page_to_pfn(r->pages[i]),\r\nPSB_MMU_CACHED_MEMORY);\r\niowrite32(pte, gtt_slot++);\r\n}\r\nfor (i = 0; i < r->roll; i++) {\r\npte = psb_gtt_mask_pte(page_to_pfn(r->pages[i]),\r\nPSB_MMU_CACHED_MEMORY);\r\niowrite32(pte, gtt_slot++);\r\n}\r\nioread32(gtt_slot - 1);\r\n}\r\nstatic int psb_gtt_attach_pages(struct gtt_range *gt)\r\n{\r\nstruct page **pages;\r\nWARN_ON(gt->pages);\r\npages = drm_gem_get_pages(&gt->gem);\r\nif (IS_ERR(pages))\r\nreturn PTR_ERR(pages);\r\ngt->npage = gt->gem.size / PAGE_SIZE;\r\ngt->pages = pages;\r\nreturn 0;\r\n}\r\nstatic void psb_gtt_detach_pages(struct gtt_range *gt)\r\n{\r\ndrm_gem_put_pages(&gt->gem, gt->pages, true, false);\r\ngt->pages = NULL;\r\n}\r\nint psb_gtt_pin(struct gtt_range *gt)\r\n{\r\nint ret = 0;\r\nstruct drm_device *dev = gt->gem.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 gpu_base = dev_priv->gtt.gatt_start;\r\nmutex_lock(&dev_priv->gtt_mutex);\r\nif (gt->in_gart == 0 && gt->stolen == 0) {\r\nret = psb_gtt_attach_pages(gt);\r\nif (ret < 0)\r\ngoto out;\r\nret = psb_gtt_insert(dev, gt, 0);\r\nif (ret < 0) {\r\npsb_gtt_detach_pages(gt);\r\ngoto out;\r\n}\r\npsb_mmu_insert_pages(psb_mmu_get_default_pd(dev_priv->mmu),\r\ngt->pages, (gpu_base + gt->offset),\r\ngt->npage, 0, 0, PSB_MMU_CACHED_MEMORY);\r\n}\r\ngt->in_gart++;\r\nout:\r\nmutex_unlock(&dev_priv->gtt_mutex);\r\nreturn ret;\r\n}\r\nvoid psb_gtt_unpin(struct gtt_range *gt)\r\n{\r\nstruct drm_device *dev = gt->gem.dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 gpu_base = dev_priv->gtt.gatt_start;\r\nint ret;\r\nmutex_lock(&dev_priv->gtt_mutex);\r\nret = gma_blt_wait_idle(dev_priv);\r\nif (ret) {\r\nDRM_ERROR("Failed to idle the blitter, unpin failed!");\r\ngoto out;\r\n}\r\nWARN_ON(!gt->in_gart);\r\ngt->in_gart--;\r\nif (gt->in_gart == 0 && gt->stolen == 0) {\r\npsb_mmu_remove_pages(psb_mmu_get_default_pd(dev_priv->mmu),\r\n(gpu_base + gt->offset), gt->npage, 0, 0);\r\npsb_gtt_remove(dev, gt);\r\npsb_gtt_detach_pages(gt);\r\n}\r\nout:\r\nmutex_unlock(&dev_priv->gtt_mutex);\r\n}\r\nstruct gtt_range *psb_gtt_alloc_range(struct drm_device *dev, int len,\r\nconst char *name, int backed, u32 align)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gtt_range *gt;\r\nstruct resource *r = dev_priv->gtt_mem;\r\nint ret;\r\nunsigned long start, end;\r\nif (backed) {\r\nstart = r->start;\r\nend = r->start + dev_priv->gtt.stolen_size - 1;\r\n} else {\r\nstart = r->start + dev_priv->gtt.stolen_size;\r\nend = r->end;\r\n}\r\ngt = kzalloc(sizeof(struct gtt_range), GFP_KERNEL);\r\nif (gt == NULL)\r\nreturn NULL;\r\ngt->resource.name = name;\r\ngt->stolen = backed;\r\ngt->in_gart = backed;\r\ngt->roll = 0;\r\ngt->gem.dev = dev;\r\nret = allocate_resource(dev_priv->gtt_mem, &gt->resource,\r\nlen, start, end, align, NULL, NULL);\r\nif (ret == 0) {\r\ngt->offset = gt->resource.start - r->start;\r\nreturn gt;\r\n}\r\nkfree(gt);\r\nreturn NULL;\r\n}\r\nvoid psb_gtt_free_range(struct drm_device *dev, struct gtt_range *gt)\r\n{\r\nif (gt->mmapping) {\r\npsb_gtt_unpin(gt);\r\ngt->mmapping = 0;\r\n}\r\nWARN_ON(gt->in_gart && !gt->stolen);\r\nrelease_resource(&gt->resource);\r\nkfree(gt);\r\n}\r\nstatic void psb_gtt_alloc(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\ninit_rwsem(&dev_priv->gtt.sem);\r\n}\r\nvoid psb_gtt_takedown(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv->gtt_map) {\r\niounmap(dev_priv->gtt_map);\r\ndev_priv->gtt_map = NULL;\r\n}\r\nif (dev_priv->gtt_initialized) {\r\npci_write_config_word(dev->pdev, PSB_GMCH_CTRL,\r\ndev_priv->gmch_ctrl);\r\nPSB_WVDC32(dev_priv->pge_ctl, PSB_PGETBL_CTL);\r\n(void) PSB_RVDC32(PSB_PGETBL_CTL);\r\n}\r\nif (dev_priv->vram_addr)\r\niounmap(dev_priv->gtt_map);\r\n}\r\nint psb_gtt_init(struct drm_device *dev, int resume)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nunsigned gtt_pages;\r\nunsigned long stolen_size, vram_stolen_size;\r\nunsigned i, num_pages;\r\nunsigned pfn_base;\r\nstruct psb_gtt *pg;\r\nint ret = 0;\r\nuint32_t pte;\r\nif (!resume) {\r\nmutex_init(&dev_priv->gtt_mutex);\r\nmutex_init(&dev_priv->mmap_mutex);\r\npsb_gtt_alloc(dev);\r\n}\r\npg = &dev_priv->gtt;\r\npci_read_config_word(dev->pdev, PSB_GMCH_CTRL, &dev_priv->gmch_ctrl);\r\npci_write_config_word(dev->pdev, PSB_GMCH_CTRL,\r\ndev_priv->gmch_ctrl | _PSB_GMCH_ENABLED);\r\ndev_priv->pge_ctl = PSB_RVDC32(PSB_PGETBL_CTL);\r\nPSB_WVDC32(dev_priv->pge_ctl | _PSB_PGETBL_ENABLED, PSB_PGETBL_CTL);\r\n(void) PSB_RVDC32(PSB_PGETBL_CTL);\r\ndev_priv->gtt_initialized = 1;\r\npg->gtt_phys_start = dev_priv->pge_ctl & PAGE_MASK;\r\npg->mmu_gatt_start = 0xE0000000;\r\npg->gtt_start = pci_resource_start(dev->pdev, PSB_GTT_RESOURCE);\r\ngtt_pages = pci_resource_len(dev->pdev, PSB_GTT_RESOURCE)\r\n>> PAGE_SHIFT;\r\nif (pg->gtt_start == 0 || gtt_pages == 0) {\r\ndev_dbg(dev->dev, "GTT PCI BAR not initialized.\n");\r\ngtt_pages = 64;\r\npg->gtt_start = dev_priv->pge_ctl;\r\n}\r\npg->gatt_start = pci_resource_start(dev->pdev, PSB_GATT_RESOURCE);\r\npg->gatt_pages = pci_resource_len(dev->pdev, PSB_GATT_RESOURCE)\r\n>> PAGE_SHIFT;\r\ndev_priv->gtt_mem = &dev->pdev->resource[PSB_GATT_RESOURCE];\r\nif (pg->gatt_pages == 0 || pg->gatt_start == 0) {\r\nstatic struct resource fudge;\r\ndev_dbg(dev->dev, "GATT PCI BAR not initialized.\n");\r\npg->gatt_start = 0x40000000;\r\npg->gatt_pages = (128 * 1024 * 1024) >> PAGE_SHIFT;\r\nfudge.start = 0x40000000;\r\nfudge.end = 0x40000000 + 128 * 1024 * 1024 - 1;\r\nfudge.name = "fudge";\r\nfudge.flags = IORESOURCE_MEM;\r\ndev_priv->gtt_mem = &fudge;\r\n}\r\npci_read_config_dword(dev->pdev, PSB_BSM, &dev_priv->stolen_base);\r\nvram_stolen_size = pg->gtt_phys_start - dev_priv->stolen_base\r\n- PAGE_SIZE;\r\nstolen_size = vram_stolen_size;\r\ndev_dbg(dev->dev, "Stolen memory base 0x%x, size %luK\n",\r\ndev_priv->stolen_base, vram_stolen_size / 1024);\r\nif (resume && (gtt_pages != pg->gtt_pages) &&\r\n(stolen_size != pg->stolen_size)) {\r\ndev_err(dev->dev, "GTT resume error.\n");\r\nret = -EINVAL;\r\ngoto out_err;\r\n}\r\npg->gtt_pages = gtt_pages;\r\npg->stolen_size = stolen_size;\r\ndev_priv->vram_stolen_size = vram_stolen_size;\r\nif (!resume)\r\ndev_priv->gtt_map = ioremap_nocache(pg->gtt_phys_start,\r\ngtt_pages << PAGE_SHIFT);\r\nif (!dev_priv->gtt_map) {\r\ndev_err(dev->dev, "Failure to map gtt.\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nif (!resume)\r\ndev_priv->vram_addr = ioremap_wc(dev_priv->stolen_base,\r\nstolen_size);\r\nif (!dev_priv->vram_addr) {\r\ndev_err(dev->dev, "Failure to map stolen base.\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\npfn_base = dev_priv->stolen_base >> PAGE_SHIFT;\r\nnum_pages = vram_stolen_size >> PAGE_SHIFT;\r\ndev_dbg(dev->dev, "Set up %d stolen pages starting at 0x%08x, GTT offset %dK\n",\r\nnum_pages, pfn_base << PAGE_SHIFT, 0);\r\nfor (i = 0; i < num_pages; ++i) {\r\npte = psb_gtt_mask_pte(pfn_base + i, PSB_MMU_CACHED_MEMORY);\r\niowrite32(pte, dev_priv->gtt_map + i);\r\n}\r\npfn_base = page_to_pfn(dev_priv->scratch_page);\r\npte = psb_gtt_mask_pte(pfn_base, PSB_MMU_CACHED_MEMORY);\r\nfor (; i < gtt_pages; ++i)\r\niowrite32(pte, dev_priv->gtt_map + i);\r\n(void) ioread32(dev_priv->gtt_map + i - 1);\r\nreturn 0;\r\nout_err:\r\npsb_gtt_takedown(dev);\r\nreturn ret;\r\n}\r\nint psb_gtt_restore(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct resource *r = dev_priv->gtt_mem->child;\r\nstruct gtt_range *range;\r\nunsigned int restored = 0, total = 0, size = 0;\r\nmutex_lock(&dev_priv->gtt_mutex);\r\npsb_gtt_init(dev, 1);\r\nwhile (r != NULL) {\r\nrange = container_of(r, struct gtt_range, resource);\r\nif (range->pages) {\r\npsb_gtt_insert(dev, range, 1);\r\nsize += range->resource.end - range->resource.start;\r\nrestored++;\r\n}\r\nr = r->sibling;\r\ntotal++;\r\n}\r\nmutex_unlock(&dev_priv->gtt_mutex);\r\nDRM_DEBUG_DRIVER("Restored %u of %u gtt ranges (%u KB)", restored,\r\ntotal, (size / 1024));\r\nreturn 0;\r\n}
