int dibusb_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.fifo_ctrl != NULL)\r\nif (st->ops.fifo_ctrl(adap->fe_adap[0].fe, onoff)) {\r\nerr("error while controlling the fifo of the demod.");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.pid_ctrl != NULL)\r\nst->ops.pid_ctrl(adap->fe_adap[0].fe,\r\nindex, pid, onoff);\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nif (adap->priv != NULL) {\r\nstruct dibusb_state *st = adap->priv;\r\nif (st->ops.pid_parse != NULL)\r\nif (st->ops.pid_parse(adap->fe_adap[0].fe, onoff) < 0)\r\nerr("could not handle pid_parser");\r\n}\r\nreturn 0;\r\n}\r\nint dibusb_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 *b;\r\nint ret;\r\nb = kmalloc(3, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nb[0] = DIBUSB_REQ_SET_IOCTL;\r\nb[1] = DIBUSB_IOCTL_CMD_POWER_MODE;\r\nb[2] = onoff ? DIBUSB_IOCTL_POWER_WAKEUP : DIBUSB_IOCTL_POWER_SLEEP;\r\nret = dvb_usb_generic_write(d, b, 3);\r\nkfree(b);\r\nmsleep(10);\r\nreturn ret;\r\n}\r\nint dibusb2_0_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\nu8 *b;\r\nb = kmalloc(3, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nif ((ret = dibusb_streaming_ctrl(adap,onoff)) < 0)\r\ngoto ret;\r\nif (onoff) {\r\nb[0] = DIBUSB_REQ_SET_STREAMING_MODE;\r\nb[1] = 0x00;\r\nret = dvb_usb_generic_write(adap->dev, b, 2);\r\nif (ret < 0)\r\ngoto ret;\r\n}\r\nb[0] = DIBUSB_REQ_SET_IOCTL;\r\nb[1] = onoff ? DIBUSB_IOCTL_CMD_ENABLE_STREAM : DIBUSB_IOCTL_CMD_DISABLE_STREAM;\r\nret = dvb_usb_generic_write(adap->dev, b, 3);\r\nret:\r\nkfree(b);\r\nreturn ret;\r\n}\r\nint dibusb2_0_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nu8 *b;\r\nint ret;\r\nif (!onoff)\r\nreturn 0;\r\nb = kmalloc(3, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nb[0] = DIBUSB_REQ_SET_IOCTL;\r\nb[1] = DIBUSB_IOCTL_CMD_POWER_MODE;\r\nb[2] = DIBUSB_IOCTL_POWER_WAKEUP;\r\nret = dvb_usb_generic_write(d, b, 3);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int dibusb_i2c_msg(struct dvb_usb_device *d, u8 addr,\r\nu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\r\n{\r\nu8 *sndbuf;\r\nint ret, wo, len;\r\nwo = (rbuf == NULL || rlen == 0);\r\nlen = 2 + wlen + (wo ? 0 : 2);\r\nsndbuf = kmalloc(MAX_XFER_SIZE, GFP_KERNEL);\r\nif (!sndbuf)\r\nreturn -ENOMEM;\r\nif (4 + wlen > MAX_XFER_SIZE) {\r\nwarn("i2c wr: len=%d is too big!\n", wlen);\r\nret = -EOPNOTSUPP;\r\ngoto ret;\r\n}\r\nsndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;\r\nsndbuf[1] = (addr << 1) | (wo ? 0 : 1);\r\nmemcpy(&sndbuf[2], wbuf, wlen);\r\nif (!wo) {\r\nsndbuf[wlen + 2] = (rlen >> 8) & 0xff;\r\nsndbuf[wlen + 3] = rlen & 0xff;\r\n}\r\nret = dvb_usb_generic_rw(d, sndbuf, len, rbuf, rlen, 0);\r\nret:\r\nkfree(sndbuf);\r\nreturn ret;\r\n}\r\nstatic int dibusb_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (i+1 < num && (msg[i].flags & I2C_M_RD) == 0\r\n&& (msg[i+1].flags & I2C_M_RD)) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,\r\nmsg[i+1].buf,msg[i+1].len) < 0)\r\nbreak;\r\ni++;\r\n} else if ((msg[i].flags & I2C_M_RD) == 0) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, msg[i].buf,msg[i].len,NULL,0) < 0)\r\nbreak;\r\n} else if (msg[i].addr != 0x50) {\r\nif (dibusb_i2c_msg(d, msg[i].addr, NULL, 0, msg[i].buf, msg[i].len) < 0)\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 dibusb_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint dibusb_read_eeprom_byte(struct dvb_usb_device *d, u8 offs, u8 *val)\r\n{\r\nu8 wbuf[1] = { offs };\r\nreturn dibusb_i2c_msg(d, 0x50, wbuf, 1, val, 1);\r\n}\r\nint dibusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)\r\n{\r\nu8 *buf;\r\nint ret;\r\nbuf = kmalloc(5, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = DIBUSB_REQ_POLL_REMOTE;\r\nret = dvb_usb_generic_rw(d, buf, 1, buf, 5, 0);\r\nif (ret < 0)\r\ngoto ret;\r\ndvb_usb_nec_rc_key_to_event(d, buf, event, state);\r\nif (buf[0] != 0)\r\ndeb_info("key: %*ph\n", 5, buf);\r\nret:\r\nkfree(buf);\r\nreturn ret;\r\n}
