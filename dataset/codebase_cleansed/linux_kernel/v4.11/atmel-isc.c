static int isc_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nu32 id = isc_clk->id;\r\nstruct regmap *regmap = isc_clk->regmap;\r\ndev_dbg(isc_clk->dev, "ISC CLK: %s, div = %d, parent id = %d\n",\r\n__func__, isc_clk->div, isc_clk->parent_id);\r\nregmap_update_bits(regmap, ISC_CLKCFG,\r\nISC_CLKCFG_DIV_MASK(id) | ISC_CLKCFG_SEL_MASK(id),\r\n(isc_clk->div << ISC_CLKCFG_DIV_SHIFT(id)) |\r\n(isc_clk->parent_id << ISC_CLKCFG_SEL_SHIFT(id)));\r\nregmap_write(regmap, ISC_CLKEN, ISC_CLK(id));\r\nreturn 0;\r\n}\r\nstatic void isc_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nu32 id = isc_clk->id;\r\nregmap_write(isc_clk->regmap, ISC_CLKDIS, ISC_CLK(id));\r\n}\r\nstatic int isc_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nu32 status;\r\nregmap_read(isc_clk->regmap, ISC_CLKSR, &status);\r\nreturn status & ISC_CLK(isc_clk->id) ? 1 : 0;\r\n}\r\nstatic unsigned long\r\nisc_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nreturn DIV_ROUND_CLOSEST(parent_rate, isc_clk->div + 1);\r\n}\r\nstatic int isc_clk_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nlong best_rate = -EINVAL;\r\nint best_diff = -1;\r\nunsigned int i, div;\r\nfor (i = 0; i < clk_hw_get_num_parents(hw); i++) {\r\nstruct clk_hw *parent;\r\nunsigned long parent_rate;\r\nparent = clk_hw_get_parent_by_index(hw, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = clk_hw_get_rate(parent);\r\nif (!parent_rate)\r\ncontinue;\r\nfor (div = 1; div < ISC_CLK_MAX_DIV + 2; div++) {\r\nunsigned long rate;\r\nint diff;\r\nrate = DIV_ROUND_CLOSEST(parent_rate, div);\r\ndiff = abs(req->rate - rate);\r\nif (best_diff < 0 || best_diff > diff) {\r\nbest_rate = rate;\r\nbest_diff = diff;\r\nreq->best_parent_rate = parent_rate;\r\nreq->best_parent_hw = parent;\r\n}\r\nif (!best_diff || rate < req->rate)\r\nbreak;\r\n}\r\nif (!best_diff)\r\nbreak;\r\n}\r\ndev_dbg(isc_clk->dev,\r\n"ISC CLK: %s, best_rate = %ld, parent clk: %s @ %ld\n",\r\n__func__, best_rate,\r\n__clk_get_name((req->best_parent_hw)->clk),\r\nreq->best_parent_rate);\r\nif (best_rate < 0)\r\nreturn best_rate;\r\nreq->rate = best_rate;\r\nreturn 0;\r\n}\r\nstatic int isc_clk_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nif (index >= clk_hw_get_num_parents(hw))\r\nreturn -EINVAL;\r\nisc_clk->parent_id = index;\r\nreturn 0;\r\n}\r\nstatic u8 isc_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nreturn isc_clk->parent_id;\r\n}\r\nstatic int isc_clk_set_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct isc_clk *isc_clk = to_isc_clk(hw);\r\nu32 div;\r\nif (!rate)\r\nreturn -EINVAL;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nif (div > (ISC_CLK_MAX_DIV + 1) || !div)\r\nreturn -EINVAL;\r\nisc_clk->div = div - 1;\r\nreturn 0;\r\n}\r\nstatic int isc_clk_register(struct isc_device *isc, unsigned int id)\r\n{\r\nstruct regmap *regmap = isc->regmap;\r\nstruct device_node *np = isc->dev->of_node;\r\nstruct isc_clk *isc_clk;\r\nstruct clk_init_data init;\r\nconst char *clk_name = np->name;\r\nconst char *parent_names[3];\r\nint num_parents;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents < 1 || num_parents > 3)\r\nreturn -EINVAL;\r\nif (num_parents > 2 && id == ISC_ISPCK)\r\nnum_parents = 2;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nif (id == ISC_MCK)\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\nelse\r\nclk_name = "isc-ispck";\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.name = clk_name;\r\ninit.ops = &isc_clk_ops;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nisc_clk = &isc->isc_clks[id];\r\nisc_clk->hw.init = &init;\r\nisc_clk->regmap = regmap;\r\nisc_clk->id = id;\r\nisc_clk->dev = isc->dev;\r\nisc_clk->clk = clk_register(isc->dev, &isc_clk->hw);\r\nif (IS_ERR(isc_clk->clk)) {\r\ndev_err(isc->dev, "%s: clock register fail\n", clk_name);\r\nreturn PTR_ERR(isc_clk->clk);\r\n} else if (id == ISC_MCK)\r\nof_clk_add_provider(np, of_clk_src_simple_get, isc_clk->clk);\r\nreturn 0;\r\n}\r\nstatic int isc_clk_init(struct isc_device *isc)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++)\r\nisc->isc_clks[i].clk = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++) {\r\nret = isc_clk_register(isc, i);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isc_clk_cleanup(struct isc_device *isc)\r\n{\r\nunsigned int i;\r\nof_clk_del_provider(isc->dev->of_node);\r\nfor (i = 0; i < ARRAY_SIZE(isc->isc_clks); i++) {\r\nstruct isc_clk *isc_clk = &isc->isc_clks[i];\r\nif (!IS_ERR(isc_clk->clk))\r\nclk_unregister(isc_clk->clk);\r\n}\r\n}\r\nstatic int isc_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct isc_device *isc = vb2_get_drv_priv(vq);\r\nunsigned int size = isc->fmt.fmt.pix.sizeimage;\r\nif (*nplanes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int isc_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct isc_device *isc = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size = isc->fmt.fmt.pix.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nv4l2_err(&isc->v4l2_dev, "buffer too small (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nvbuf->field = isc->fmt.fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic inline void isc_start_dma(struct regmap *regmap,\r\nstruct isc_buffer *frm, u32 dview)\r\n{\r\ndma_addr_t addr;\r\naddr = vb2_dma_contig_plane_dma_addr(&frm->vb.vb2_buf, 0);\r\nregmap_write(regmap, ISC_DCTRL, dview | ISC_DCTRL_IE_IS);\r\nregmap_write(regmap, ISC_DAD0, addr);\r\nregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_CAPTURE);\r\n}\r\nstatic void isc_set_pipeline(struct isc_device *isc, u32 pipeline)\r\n{\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < ISC_PIPE_LINE_NODE_NUM; i++) {\r\nval = pipeline & BIT(i) ? 1 : 0;\r\nregmap_field_write(isc->pipeline[i], val);\r\n}\r\n}\r\nstatic int isc_configure(struct isc_device *isc)\r\n{\r\nstruct regmap *regmap = isc->regmap;\r\nconst struct isc_format *current_fmt = isc->current_fmt;\r\nstruct isc_subdev_entity *subdev = isc->current_subdev;\r\nu32 val, mask;\r\nint counter = 10;\r\nval = current_fmt->reg_bps | subdev->pfe_cfg0 |\r\nISC_PFE_CFG0_MODE_PROGRESSIVE;\r\nmask = ISC_PFE_CFG0_BPS_MASK | ISC_PFE_CFG0_HPOL_LOW |\r\nISC_PFE_CFG0_VPOL_LOW | ISC_PFE_CFG0_PPOL_LOW |\r\nISC_PFE_CFG0_MODE_MASK;\r\nregmap_update_bits(regmap, ISC_PFE_CFG0, mask, val);\r\nregmap_update_bits(regmap, ISC_RLP_CFG, ISC_RLP_CFG_MODE_MASK,\r\ncurrent_fmt->reg_rlp_mode);\r\nregmap_update_bits(regmap, ISC_DCFG, ISC_DCFG_IMODE_MASK,\r\ncurrent_fmt->reg_dcfg_imode);\r\nisc_set_pipeline(isc, 0x0);\r\nregmap_write(regmap, ISC_CTRLEN, ISC_CTRL_UPPRO);\r\nregmap_read(regmap, ISC_CTRLSR, &val);\r\nwhile ((val & ISC_CTRL_UPPRO) && counter--) {\r\nusleep_range(1000, 2000);\r\nregmap_read(regmap, ISC_CTRLSR, &val);\r\n}\r\nif (counter < 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int isc_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct isc_device *isc = vb2_get_drv_priv(vq);\r\nstruct regmap *regmap = isc->regmap;\r\nstruct isc_buffer *buf;\r\nunsigned long flags;\r\nint ret;\r\nu32 val;\r\nret = v4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 1);\r\nif (ret && ret != -ENOIOCTLCMD) {\r\nv4l2_err(&isc->v4l2_dev, "stream on failed in subdev\n");\r\ngoto err_start_stream;\r\n}\r\npm_runtime_get_sync(isc->dev);\r\nregmap_write(isc->regmap, ISC_INTDIS, (u32)~0UL);\r\nregmap_read(regmap, ISC_INTSR, &val);\r\nret = isc_configure(isc);\r\nif (unlikely(ret))\r\ngoto err_configure;\r\nregmap_write(regmap, ISC_INTEN, ISC_INT_DDONE);\r\nspin_lock_irqsave(&isc->dma_queue_lock, flags);\r\nisc->sequence = 0;\r\nisc->stop = false;\r\nreinit_completion(&isc->comp);\r\nisc->cur_frm = list_first_entry(&isc->dma_queue,\r\nstruct isc_buffer, list);\r\nlist_del(&isc->cur_frm->list);\r\nisc_start_dma(regmap, isc->cur_frm, isc->current_fmt->reg_dctrl_dview);\r\nspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\r\nreturn 0;\r\nerr_configure:\r\npm_runtime_put_sync(isc->dev);\r\nv4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 0);\r\nerr_start_stream:\r\nspin_lock_irqsave(&isc->dma_queue_lock, flags);\r\nlist_for_each_entry(buf, &isc->dma_queue, list)\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\nINIT_LIST_HEAD(&isc->dma_queue);\r\nspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void isc_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct isc_device *isc = vb2_get_drv_priv(vq);\r\nunsigned long flags;\r\nstruct isc_buffer *buf;\r\nint ret;\r\nisc->stop = true;\r\nif (isc->cur_frm && !wait_for_completion_timeout(&isc->comp, 5 * HZ))\r\nv4l2_err(&isc->v4l2_dev,\r\n"Timeout waiting for end of the capture\n");\r\nregmap_write(isc->regmap, ISC_INTDIS, ISC_INT_DDONE);\r\npm_runtime_put_sync(isc->dev);\r\nret = v4l2_subdev_call(isc->current_subdev->sd, video, s_stream, 0);\r\nif (ret && ret != -ENOIOCTLCMD)\r\nv4l2_err(&isc->v4l2_dev, "stream off failed in subdev\n");\r\nspin_lock_irqsave(&isc->dma_queue_lock, flags);\r\nif (unlikely(isc->cur_frm)) {\r\nvb2_buffer_done(&isc->cur_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\nisc->cur_frm = NULL;\r\n}\r\nlist_for_each_entry(buf, &isc->dma_queue, list)\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nINIT_LIST_HEAD(&isc->dma_queue);\r\nspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\r\n}\r\nstatic void isc_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct isc_buffer *buf = container_of(vbuf, struct isc_buffer, vb);\r\nstruct isc_device *isc = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags;\r\nspin_lock_irqsave(&isc->dma_queue_lock, flags);\r\nif (!isc->cur_frm && list_empty(&isc->dma_queue) &&\r\nvb2_is_streaming(vb->vb2_queue)) {\r\nisc->cur_frm = buf;\r\nisc_start_dma(isc->regmap, isc->cur_frm,\r\nisc->current_fmt->reg_dctrl_dview);\r\n} else\r\nlist_add_tail(&buf->list, &isc->dma_queue);\r\nspin_unlock_irqrestore(&isc->dma_queue_lock, flags);\r\n}\r\nstatic int isc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nstrcpy(cap->driver, ATMEL_ISC_NAME);\r\nstrcpy(cap->card, "Atmel Image Sensor Controller");\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", isc->v4l2_dev.name);\r\nreturn 0;\r\n}\r\nstatic int isc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nu32 index = f->index;\r\nif (index >= isc->num_user_formats)\r\nreturn -EINVAL;\r\nf->pixelformat = isc->user_formats[index]->fourcc;\r\nreturn 0;\r\n}\r\nstatic int isc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\n*fmt = isc->fmt;\r\nreturn 0;\r\n}\r\nstatic struct isc_format *find_format_by_fourcc(struct isc_device *isc,\r\nunsigned int fourcc)\r\n{\r\nunsigned int num_formats = isc->num_user_formats;\r\nstruct isc_format *fmt;\r\nunsigned int i;\r\nfor (i = 0; i < num_formats; i++) {\r\nfmt = isc->user_formats[i];\r\nif (fmt->fourcc == fourcc)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int isc_try_fmt(struct isc_device *isc, struct v4l2_format *f,\r\nstruct isc_format **current_fmt)\r\n{\r\nstruct isc_format *isc_fmt;\r\nstruct v4l2_pix_format *pixfmt = &f->fmt.pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nint ret;\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nisc_fmt = find_format_by_fourcc(isc, pixfmt->pixelformat);\r\nif (!isc_fmt) {\r\nv4l2_warn(&isc->v4l2_dev, "Format 0x%x not found\n",\r\npixfmt->pixelformat);\r\nisc_fmt = isc->user_formats[isc->num_user_formats - 1];\r\npixfmt->pixelformat = isc_fmt->fourcc;\r\n}\r\nif (pixfmt->width > ISC_MAX_SUPPORT_WIDTH)\r\npixfmt->width = ISC_MAX_SUPPORT_WIDTH;\r\nif (pixfmt->height > ISC_MAX_SUPPORT_HEIGHT)\r\npixfmt->height = ISC_MAX_SUPPORT_HEIGHT;\r\nv4l2_fill_mbus_format(&format.format, pixfmt, isc_fmt->mbus_code);\r\nret = v4l2_subdev_call(isc->current_subdev->sd, pad, set_fmt,\r\nisc->current_subdev->config, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_fill_pix_format(pixfmt, &format.format);\r\npixfmt->field = V4L2_FIELD_NONE;\r\npixfmt->bytesperline = pixfmt->width * isc_fmt->bpp;\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nif (current_fmt)\r\n*current_fmt = isc_fmt;\r\nreturn 0;\r\n}\r\nstatic int isc_set_fmt(struct isc_device *isc, struct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct isc_format *current_fmt;\r\nint ret;\r\nret = isc_try_fmt(isc, f, &current_fmt);\r\nif (ret)\r\nreturn ret;\r\nv4l2_fill_mbus_format(&format.format, &f->fmt.pix,\r\ncurrent_fmt->mbus_code);\r\nret = v4l2_subdev_call(isc->current_subdev->sd, pad,\r\nset_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nisc->fmt = *f;\r\nisc->current_fmt = current_fmt;\r\nreturn 0;\r\n}\r\nstatic int isc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nif (vb2_is_streaming(&isc->vb2_vidq))\r\nreturn -EBUSY;\r\nreturn isc_set_fmt(isc, f);\r\n}\r\nstatic int isc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nreturn isc_try_fmt(isc, f, NULL);\r\n}\r\nstatic int isc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index != 0)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = 0;\r\nstrcpy(inp->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int isc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int isc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int isc_g_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(isc->current_subdev->sd, video, g_parm, a);\r\n}\r\nstatic int isc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(isc->current_subdev->sd, video, s_parm, a);\r\n}\r\nstatic int isc_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nconst struct isc_format *isc_fmt;\r\nstruct v4l2_subdev_frame_size_enum fse = {\r\n.index = fsize->index,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint ret;\r\nisc_fmt = find_format_by_fourcc(isc, fsize->pixel_format);\r\nif (!isc_fmt)\r\nreturn -EINVAL;\r\nfse.code = isc_fmt->mbus_code;\r\nret = v4l2_subdev_call(isc->current_subdev->sd, pad, enum_frame_size,\r\nNULL, &fse);\r\nif (ret)\r\nreturn ret;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = fse.max_width;\r\nfsize->discrete.height = fse.max_height;\r\nreturn 0;\r\n}\r\nstatic int isc_enum_frameintervals(struct file *file, void *fh,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nconst struct isc_format *isc_fmt;\r\nstruct v4l2_subdev_frame_interval_enum fie = {\r\n.index = fival->index,\r\n.width = fival->width,\r\n.height = fival->height,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint ret;\r\nisc_fmt = find_format_by_fourcc(isc, fival->pixel_format);\r\nif (!isc_fmt)\r\nreturn -EINVAL;\r\nfie.code = isc_fmt->mbus_code;\r\nret = v4l2_subdev_call(isc->current_subdev->sd, pad,\r\nenum_frame_interval, NULL, &fie);\r\nif (ret)\r\nreturn ret;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete = fie.interval;\r\nreturn 0;\r\n}\r\nstatic int isc_open(struct file *file)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nstruct v4l2_subdev *sd = isc->current_subdev->sd;\r\nint ret;\r\nif (mutex_lock_interruptible(&isc->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(file);\r\nif (ret < 0)\r\ngoto unlock;\r\nif (!v4l2_fh_is_singular_file(file))\r\ngoto unlock;\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nv4l2_fh_release(file);\r\ngoto unlock;\r\n}\r\nret = isc_set_fmt(isc, &isc->fmt);\r\nif (ret) {\r\nv4l2_subdev_call(sd, core, s_power, 0);\r\nv4l2_fh_release(file);\r\n}\r\nunlock:\r\nmutex_unlock(&isc->lock);\r\nreturn ret;\r\n}\r\nstatic int isc_release(struct file *file)\r\n{\r\nstruct isc_device *isc = video_drvdata(file);\r\nstruct v4l2_subdev *sd = isc->current_subdev->sd;\r\nbool fh_singular;\r\nint ret;\r\nmutex_lock(&isc->lock);\r\nfh_singular = v4l2_fh_is_singular_file(file);\r\nret = _vb2_fop_release(file, NULL);\r\nif (fh_singular)\r\nv4l2_subdev_call(sd, core, s_power, 0);\r\nmutex_unlock(&isc->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t isc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct isc_device *isc = (struct isc_device *)dev_id;\r\nstruct regmap *regmap = isc->regmap;\r\nu32 isc_intsr, isc_intmask, pending;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&isc->dma_queue_lock);\r\nregmap_read(regmap, ISC_INTSR, &isc_intsr);\r\nregmap_read(regmap, ISC_INTMASK, &isc_intmask);\r\npending = isc_intsr & isc_intmask;\r\nif (likely(pending & ISC_INT_DDONE)) {\r\nif (isc->cur_frm) {\r\nstruct vb2_v4l2_buffer *vbuf = &isc->cur_frm->vb;\r\nstruct vb2_buffer *vb = &vbuf->vb2_buf;\r\nvb->timestamp = ktime_get_ns();\r\nvbuf->sequence = isc->sequence++;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\nisc->cur_frm = NULL;\r\n}\r\nif (!list_empty(&isc->dma_queue) && !isc->stop) {\r\nisc->cur_frm = list_first_entry(&isc->dma_queue,\r\nstruct isc_buffer, list);\r\nlist_del(&isc->cur_frm->list);\r\nisc_start_dma(regmap, isc->cur_frm,\r\nisc->current_fmt->reg_dctrl_dview);\r\n}\r\nif (isc->stop)\r\ncomplete(&isc->comp);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&isc->dma_queue_lock);\r\nreturn ret;\r\n}\r\nstatic int isc_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct isc_device *isc = container_of(notifier->v4l2_dev,\r\nstruct isc_device, v4l2_dev);\r\nstruct isc_subdev_entity *subdev_entity =\r\ncontainer_of(notifier, struct isc_subdev_entity, notifier);\r\nif (video_is_registered(&isc->video_dev)) {\r\nv4l2_err(&isc->v4l2_dev, "only supports one sub-device.\n");\r\nreturn -EBUSY;\r\n}\r\nsubdev_entity->sd = subdev;\r\nreturn 0;\r\n}\r\nstatic void isc_async_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct isc_device *isc = container_of(notifier->v4l2_dev,\r\nstruct isc_device, v4l2_dev);\r\nvideo_unregister_device(&isc->video_dev);\r\nif (isc->current_subdev->config)\r\nv4l2_subdev_free_pad_config(isc->current_subdev->config);\r\n}\r\nstatic struct isc_format *find_format_by_code(unsigned int code, int *index)\r\n{\r\nstruct isc_format *fmt = &isc_formats[0];\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isc_formats); i++) {\r\nif (fmt->mbus_code == code) {\r\n*index = i;\r\nreturn fmt;\r\n}\r\nfmt++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int isc_formats_init(struct isc_device *isc)\r\n{\r\nstruct isc_format *fmt;\r\nstruct v4l2_subdev *subdev = isc->current_subdev->sd;\r\nint num_fmts = 0, i, j;\r\nstruct v4l2_subdev_mbus_code_enum mbus_code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nfmt = &isc_formats[0];\r\nfor (i = 0; i < ARRAY_SIZE(isc_formats); i++) {\r\nfmt->support = false;\r\nfmt++;\r\n}\r\nwhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code,\r\nNULL, &mbus_code)) {\r\nmbus_code.index++;\r\nfmt = find_format_by_code(mbus_code.code, &i);\r\nif (!fmt)\r\ncontinue;\r\nfmt->support = true;\r\nnum_fmts++;\r\n}\r\nif (!num_fmts)\r\nreturn -ENXIO;\r\nisc->num_user_formats = num_fmts;\r\nisc->user_formats = devm_kcalloc(isc->dev,\r\nnum_fmts, sizeof(struct isc_format *),\r\nGFP_KERNEL);\r\nif (!isc->user_formats) {\r\nv4l2_err(&isc->v4l2_dev, "could not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfmt = &isc_formats[0];\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(isc_formats); i++) {\r\nif (fmt->support)\r\nisc->user_formats[j++] = fmt;\r\nfmt++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isc_set_default_fmt(struct isc_device *isc)\r\n{\r\nstruct v4l2_format f = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n.fmt.pix = {\r\n.width = VGA_WIDTH,\r\n.height = VGA_HEIGHT,\r\n.field = V4L2_FIELD_NONE,\r\n.pixelformat = isc->user_formats[0]->fourcc,\r\n},\r\n};\r\nint ret;\r\nret = isc_try_fmt(isc, &f, NULL);\r\nif (ret)\r\nreturn ret;\r\nisc->current_fmt = isc->user_formats[0];\r\nisc->fmt = f;\r\nreturn 0;\r\n}\r\nstatic int isc_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct isc_device *isc = container_of(notifier->v4l2_dev,\r\nstruct isc_device, v4l2_dev);\r\nstruct isc_subdev_entity *sd_entity;\r\nstruct video_device *vdev = &isc->video_dev;\r\nstruct vb2_queue *q = &isc->vb2_vidq;\r\nint ret;\r\nisc->current_subdev = container_of(notifier,\r\nstruct isc_subdev_entity, notifier);\r\nsd_entity = isc->current_subdev;\r\nmutex_init(&isc->lock);\r\ninit_completion(&isc->comp);\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = isc;\r\nq->buf_struct_size = sizeof(struct isc_buffer);\r\nq->ops = &isc_vb2_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &isc->lock;\r\nq->min_buffers_needed = 1;\r\nq->dev = isc->dev;\r\nret = vb2_queue_init(q);\r\nif (ret < 0) {\r\nv4l2_err(&isc->v4l2_dev,\r\n"vb2_queue_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&isc->dma_queue);\r\nspin_lock_init(&isc->dma_queue_lock);\r\nsd_entity->config = v4l2_subdev_alloc_pad_config(sd_entity->sd);\r\nif (sd_entity->config == NULL)\r\nreturn -ENOMEM;\r\nret = isc_formats_init(isc);\r\nif (ret < 0) {\r\nv4l2_err(&isc->v4l2_dev,\r\n"Init format failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = isc_set_default_fmt(isc);\r\nif (ret) {\r\nv4l2_err(&isc->v4l2_dev, "Could not set default format\n");\r\nreturn ret;\r\n}\r\nstrlcpy(vdev->name, ATMEL_ISC_NAME, sizeof(vdev->name));\r\nvdev->release = video_device_release_empty;\r\nvdev->fops = &isc_fops;\r\nvdev->ioctl_ops = &isc_ioctl_ops;\r\nvdev->v4l2_dev = &isc->v4l2_dev;\r\nvdev->vfl_dir = VFL_DIR_RX;\r\nvdev->queue = q;\r\nvdev->lock = &isc->lock;\r\nvdev->ctrl_handler = isc->current_subdev->sd->ctrl_handler;\r\nvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE;\r\nvideo_set_drvdata(vdev, isc);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nv4l2_err(&isc->v4l2_dev,\r\n"video_register_device failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isc_subdev_cleanup(struct isc_device *isc)\r\n{\r\nstruct isc_subdev_entity *subdev_entity;\r\nlist_for_each_entry(subdev_entity, &isc->subdev_entities, list)\r\nv4l2_async_notifier_unregister(&subdev_entity->notifier);\r\nINIT_LIST_HEAD(&isc->subdev_entities);\r\n}\r\nstatic int isc_pipeline_init(struct isc_device *isc)\r\n{\r\nstruct device *dev = isc->dev;\r\nstruct regmap *regmap = isc->regmap;\r\nstruct regmap_field *regs;\r\nunsigned int i;\r\nconst struct reg_field regfields[ISC_PIPE_LINE_NODE_NUM] = {\r\nREG_FIELD(ISC_WB_CTRL, 0, 0),\r\nREG_FIELD(ISC_CFA_CTRL, 0, 0),\r\nREG_FIELD(ISC_CC_CTRL, 0, 0),\r\nREG_FIELD(ISC_GAM_CTRL, 0, 0),\r\nREG_FIELD(ISC_GAM_CTRL, 1, 1),\r\nREG_FIELD(ISC_GAM_CTRL, 2, 2),\r\nREG_FIELD(ISC_GAM_CTRL, 3, 3),\r\nREG_FIELD(ISC_CSC_CTRL, 0, 0),\r\nREG_FIELD(ISC_CBC_CTRL, 0, 0),\r\nREG_FIELD(ISC_SUB422_CTRL, 0, 0),\r\nREG_FIELD(ISC_SUB420_CTRL, 0, 0),\r\n};\r\nfor (i = 0; i < ISC_PIPE_LINE_NODE_NUM; i++) {\r\nregs = devm_regmap_field_alloc(dev, regmap, regfields[i]);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nisc->pipeline[i] = regs;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isc_parse_dt(struct device *dev, struct isc_device *isc)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *epn = NULL, *rem;\r\nstruct v4l2_of_endpoint v4l2_epn;\r\nstruct isc_subdev_entity *subdev_entity;\r\nunsigned int flags;\r\nint ret;\r\nINIT_LIST_HEAD(&isc->subdev_entities);\r\nfor (; ;) {\r\nepn = of_graph_get_next_endpoint(np, epn);\r\nif (!epn)\r\nbreak;\r\nrem = of_graph_get_remote_port_parent(epn);\r\nif (!rem) {\r\ndev_notice(dev, "Remote device at %s not found\n",\r\nof_node_full_name(epn));\r\ncontinue;\r\n}\r\nret = v4l2_of_parse_endpoint(epn, &v4l2_epn);\r\nif (ret) {\r\nof_node_put(rem);\r\nret = -EINVAL;\r\ndev_err(dev, "Could not parse the endpoint\n");\r\nbreak;\r\n}\r\nsubdev_entity = devm_kzalloc(dev,\r\nsizeof(*subdev_entity), GFP_KERNEL);\r\nif (subdev_entity == NULL) {\r\nof_node_put(rem);\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nsubdev_entity->asd = devm_kzalloc(dev,\r\nsizeof(*subdev_entity->asd), GFP_KERNEL);\r\nif (subdev_entity->asd == NULL) {\r\nof_node_put(rem);\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nflags = v4l2_epn.bus.parallel.flags;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\nsubdev_entity->pfe_cfg0 = ISC_PFE_CFG0_HPOL_LOW;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\nsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_VPOL_LOW;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nsubdev_entity->pfe_cfg0 |= ISC_PFE_CFG0_PPOL_LOW;\r\nsubdev_entity->asd->match_type = V4L2_ASYNC_MATCH_OF;\r\nsubdev_entity->asd->match.of.node = rem;\r\nlist_add_tail(&subdev_entity->list, &isc->subdev_entities);\r\n}\r\nof_node_put(epn);\r\nreturn ret;\r\n}\r\nstatic int atmel_isc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct isc_device *isc;\r\nstruct resource *res;\r\nvoid __iomem *io_base;\r\nstruct isc_subdev_entity *subdev_entity;\r\nint irq;\r\nint ret;\r\nisc = devm_kzalloc(dev, sizeof(*isc), GFP_KERNEL);\r\nif (!isc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, isc);\r\nisc->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nio_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(io_base))\r\nreturn PTR_ERR(io_base);\r\nisc->regmap = devm_regmap_init_mmio(dev, io_base, &isc_regmap_config);\r\nif (IS_ERR(isc->regmap)) {\r\nret = PTR_ERR(isc->regmap);\r\ndev_err(dev, "failed to init register map: %d\n", ret);\r\nreturn ret;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ndev_err(dev, "failed to get irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(dev, irq, isc_interrupt, 0,\r\nATMEL_ISC_NAME, isc);\r\nif (ret < 0) {\r\ndev_err(dev, "can't register ISR for IRQ %u (ret=%i)\n",\r\nirq, ret);\r\nreturn ret;\r\n}\r\nret = isc_pipeline_init(isc);\r\nif (ret)\r\nreturn ret;\r\nisc->hclock = devm_clk_get(dev, "hclock");\r\nif (IS_ERR(isc->hclock)) {\r\nret = PTR_ERR(isc->hclock);\r\ndev_err(dev, "failed to get hclock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = isc_clk_init(isc);\r\nif (ret) {\r\ndev_err(dev, "failed to init isc clock: %d\n", ret);\r\ngoto clean_isc_clk;\r\n}\r\nisc->ispck = isc->isc_clks[ISC_ISPCK].clk;\r\nret = clk_set_rate(isc->ispck, clk_get_rate(isc->hclock));\r\nif (ret) {\r\ndev_err(dev, "failed to set ispck rate: %d\n", ret);\r\ngoto clean_isc_clk;\r\n}\r\nret = v4l2_device_register(dev, &isc->v4l2_dev);\r\nif (ret) {\r\ndev_err(dev, "unable to register v4l2 device.\n");\r\ngoto clean_isc_clk;\r\n}\r\nret = isc_parse_dt(dev, isc);\r\nif (ret) {\r\ndev_err(dev, "fail to parse device tree\n");\r\ngoto unregister_v4l2_device;\r\n}\r\nif (list_empty(&isc->subdev_entities)) {\r\ndev_err(dev, "no subdev found\n");\r\nret = -ENODEV;\r\ngoto unregister_v4l2_device;\r\n}\r\nlist_for_each_entry(subdev_entity, &isc->subdev_entities, list) {\r\nsubdev_entity->notifier.subdevs = &subdev_entity->asd;\r\nsubdev_entity->notifier.num_subdevs = 1;\r\nsubdev_entity->notifier.bound = isc_async_bound;\r\nsubdev_entity->notifier.unbind = isc_async_unbind;\r\nsubdev_entity->notifier.complete = isc_async_complete;\r\nret = v4l2_async_notifier_register(&isc->v4l2_dev,\r\n&subdev_entity->notifier);\r\nif (ret) {\r\ndev_err(dev, "fail to register async notifier\n");\r\ngoto cleanup_subdev;\r\n}\r\nif (video_is_registered(&isc->video_dev))\r\nbreak;\r\n}\r\npm_runtime_enable(dev);\r\nreturn 0;\r\ncleanup_subdev:\r\nisc_subdev_cleanup(isc);\r\nunregister_v4l2_device:\r\nv4l2_device_unregister(&isc->v4l2_dev);\r\nclean_isc_clk:\r\nisc_clk_cleanup(isc);\r\nreturn ret;\r\n}\r\nstatic int atmel_isc_remove(struct platform_device *pdev)\r\n{\r\nstruct isc_device *isc = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nisc_subdev_cleanup(isc);\r\nv4l2_device_unregister(&isc->v4l2_dev);\r\nisc_clk_cleanup(isc);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused isc_runtime_suspend(struct device *dev)\r\n{\r\nstruct isc_device *isc = dev_get_drvdata(dev);\r\nclk_disable_unprepare(isc->ispck);\r\nclk_disable_unprepare(isc->hclock);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused isc_runtime_resume(struct device *dev)\r\n{\r\nstruct isc_device *isc = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(isc->hclock);\r\nif (ret)\r\nreturn ret;\r\nreturn clk_prepare_enable(isc->ispck);\r\n}
