static inline struct xfs_bui_log_item *BUI_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_bui_log_item, bui_item);\r\n}\r\nvoid\r\nxfs_bui_item_free(\r\nstruct xfs_bui_log_item *buip)\r\n{\r\nkmem_zone_free(xfs_bui_zone, buip);\r\n}\r\nSTATIC void\r\nxfs_bui_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\nstruct xfs_bui_log_item *buip = BUI_ITEM(lip);\r\n*nvecs += 1;\r\n*nbytes += xfs_bui_log_format_sizeof(buip->bui_format.bui_nextents);\r\n}\r\nSTATIC void\r\nxfs_bui_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_bui_log_item *buip = BUI_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(atomic_read(&buip->bui_next_extent) ==\r\nbuip->bui_format.bui_nextents);\r\nbuip->bui_format.bui_type = XFS_LI_BUI;\r\nbuip->bui_format.bui_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_BUI_FORMAT, &buip->bui_format,\r\nxfs_bui_log_format_sizeof(buip->bui_format.bui_nextents));\r\n}\r\nSTATIC void\r\nxfs_bui_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_bui_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\nstruct xfs_bui_log_item *buip = BUI_ITEM(lip);\r\nxfs_bui_release(buip);\r\n}\r\nSTATIC uint\r\nxfs_bui_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_bui_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_bui_item_free(BUI_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_bui_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_bui_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_bui_log_item *\r\nxfs_bui_init(\r\nstruct xfs_mount *mp)\r\n{\r\nstruct xfs_bui_log_item *buip;\r\nbuip = kmem_zone_zalloc(xfs_bui_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &buip->bui_item, XFS_LI_BUI, &xfs_bui_item_ops);\r\nbuip->bui_format.bui_nextents = XFS_BUI_MAX_FAST_EXTENTS;\r\nbuip->bui_format.bui_id = (uintptr_t)(void *)buip;\r\natomic_set(&buip->bui_next_extent, 0);\r\natomic_set(&buip->bui_refcount, 2);\r\nreturn buip;\r\n}\r\nvoid\r\nxfs_bui_release(\r\nstruct xfs_bui_log_item *buip)\r\n{\r\nif (atomic_dec_and_test(&buip->bui_refcount)) {\r\nxfs_trans_ail_remove(&buip->bui_item, SHUTDOWN_LOG_IO_ERROR);\r\nxfs_bui_item_free(buip);\r\n}\r\n}\r\nstatic inline struct xfs_bud_log_item *BUD_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_bud_log_item, bud_item);\r\n}\r\nSTATIC void\r\nxfs_bud_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += sizeof(struct xfs_bud_log_format);\r\n}\r\nSTATIC void\r\nxfs_bud_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_bud_log_item *budp = BUD_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nbudp->bud_format.bud_type = XFS_LI_BUD;\r\nbudp->bud_format.bud_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_BUD_FORMAT, &budp->bud_format,\r\nsizeof(struct xfs_bud_log_format));\r\n}\r\nSTATIC void\r\nxfs_bud_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_bud_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\n}\r\nSTATIC uint\r\nxfs_bud_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_bud_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nstruct xfs_bud_log_item *budp = BUD_ITEM(lip);\r\nif (lip->li_flags & XFS_LI_ABORTED) {\r\nxfs_bui_release(budp->bud_buip);\r\nkmem_zone_free(xfs_bud_zone, budp);\r\n}\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_bud_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_bud_log_item *budp = BUD_ITEM(lip);\r\nxfs_bui_release(budp->bud_buip);\r\nkmem_zone_free(xfs_bud_zone, budp);\r\nreturn (xfs_lsn_t)-1;\r\n}\r\nSTATIC void\r\nxfs_bud_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_bud_log_item *\r\nxfs_bud_init(\r\nstruct xfs_mount *mp,\r\nstruct xfs_bui_log_item *buip)\r\n{\r\nstruct xfs_bud_log_item *budp;\r\nbudp = kmem_zone_zalloc(xfs_bud_zone, KM_SLEEP);\r\nxfs_log_item_init(mp, &budp->bud_item, XFS_LI_BUD, &xfs_bud_item_ops);\r\nbudp->bud_buip = buip;\r\nbudp->bud_format.bud_bui_id = buip->bui_format.bui_id;\r\nreturn budp;\r\n}\r\nint\r\nxfs_bui_recover(\r\nstruct xfs_mount *mp,\r\nstruct xfs_bui_log_item *buip)\r\n{\r\nint error = 0;\r\nunsigned int bui_type;\r\nstruct xfs_map_extent *bmap;\r\nxfs_fsblock_t startblock_fsb;\r\nxfs_fsblock_t inode_fsb;\r\nbool op_ok;\r\nstruct xfs_bud_log_item *budp;\r\nenum xfs_bmap_intent_type type;\r\nint whichfork;\r\nxfs_exntst_t state;\r\nstruct xfs_trans *tp;\r\nstruct xfs_inode *ip = NULL;\r\nstruct xfs_defer_ops dfops;\r\nxfs_fsblock_t firstfsb;\r\nASSERT(!test_bit(XFS_BUI_RECOVERED, &buip->bui_flags));\r\nif (buip->bui_format.bui_nextents != XFS_BUI_MAX_FAST_EXTENTS) {\r\nset_bit(XFS_BUI_RECOVERED, &buip->bui_flags);\r\nxfs_bui_release(buip);\r\nreturn -EIO;\r\n}\r\nbmap = &buip->bui_format.bui_extents[0];\r\nstartblock_fsb = XFS_BB_TO_FSB(mp,\r\nXFS_FSB_TO_DADDR(mp, bmap->me_startblock));\r\ninode_fsb = XFS_BB_TO_FSB(mp, XFS_FSB_TO_DADDR(mp,\r\nXFS_INO_TO_FSB(mp, bmap->me_owner)));\r\nswitch (bmap->me_flags & XFS_BMAP_EXTENT_TYPE_MASK) {\r\ncase XFS_BMAP_MAP:\r\ncase XFS_BMAP_UNMAP:\r\nop_ok = true;\r\nbreak;\r\ndefault:\r\nop_ok = false;\r\nbreak;\r\n}\r\nif (!op_ok || startblock_fsb == 0 ||\r\nbmap->me_len == 0 ||\r\ninode_fsb == 0 ||\r\nstartblock_fsb >= mp->m_sb.sb_dblocks ||\r\nbmap->me_len >= mp->m_sb.sb_agblocks ||\r\ninode_fsb >= mp->m_sb.sb_dblocks ||\r\n(bmap->me_flags & ~XFS_BMAP_EXTENT_FLAGS)) {\r\nset_bit(XFS_BUI_RECOVERED, &buip->bui_flags);\r\nxfs_bui_release(buip);\r\nreturn -EIO;\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nbudp = xfs_trans_get_bud(tp, buip);\r\nerror = xfs_iget(mp, tp, bmap->me_owner, 0, XFS_ILOCK_EXCL, &ip);\r\nif (error)\r\ngoto err_inode;\r\nif (VFS_I(ip)->i_nlink == 0)\r\nxfs_iflags_set(ip, XFS_IRECOVERY);\r\nxfs_defer_init(&dfops, &firstfsb);\r\nstate = (bmap->me_flags & XFS_BMAP_EXTENT_UNWRITTEN) ?\r\nXFS_EXT_UNWRITTEN : XFS_EXT_NORM;\r\nwhichfork = (bmap->me_flags & XFS_BMAP_EXTENT_ATTR_FORK) ?\r\nXFS_ATTR_FORK : XFS_DATA_FORK;\r\nbui_type = bmap->me_flags & XFS_BMAP_EXTENT_TYPE_MASK;\r\nswitch (bui_type) {\r\ncase XFS_BMAP_MAP:\r\ncase XFS_BMAP_UNMAP:\r\ntype = bui_type;\r\nbreak;\r\ndefault:\r\nerror = -EFSCORRUPTED;\r\ngoto err_dfops;\r\n}\r\nxfs_trans_ijoin(tp, ip, 0);\r\nerror = xfs_trans_log_finish_bmap_update(tp, budp, &dfops, type,\r\nip, whichfork, bmap->me_startoff,\r\nbmap->me_startblock, bmap->me_len,\r\nstate);\r\nif (error)\r\ngoto err_dfops;\r\nerror = xfs_defer_finish(&tp, &dfops, NULL);\r\nif (error)\r\ngoto err_dfops;\r\nset_bit(XFS_BUI_RECOVERED, &buip->bui_flags);\r\nerror = xfs_trans_commit(tp);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\nreturn error;\r\nerr_dfops:\r\nxfs_defer_cancel(&dfops);\r\nerr_inode:\r\nxfs_trans_cancel(tp);\r\nif (ip) {\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\n}\r\nreturn error;\r\n}
