static inline struct s6e8aa0 *panel_to_s6e8aa0(struct drm_panel *panel)\r\n{\r\nreturn container_of(panel, struct s6e8aa0, panel);\r\n}\r\nstatic int s6e8aa0_clear_error(struct s6e8aa0 *ctx)\r\n{\r\nint ret = ctx->error;\r\nctx->error = 0;\r\nreturn ret;\r\n}\r\nstatic void s6e8aa0_dcs_write(struct s6e8aa0 *ctx, const void *data, size_t len)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\r\nssize_t ret;\r\nif (ctx->error < 0)\r\nreturn;\r\nret = mipi_dsi_dcs_write_buffer(dsi, data, len);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "error %zd writing dcs seq: %*ph\n", ret,\r\n(int)len, data);\r\nctx->error = ret;\r\n}\r\n}\r\nstatic int s6e8aa0_dcs_read(struct s6e8aa0 *ctx, u8 cmd, void *data, size_t len)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\r\nint ret;\r\nif (ctx->error < 0)\r\nreturn ctx->error;\r\nret = mipi_dsi_dcs_read(dsi, cmd, data, len);\r\nif (ret < 0) {\r\ndev_err(ctx->dev, "error %d reading dcs seq(%#x)\n", ret, cmd);\r\nctx->error = ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void s6e8aa0_apply_level_1_key(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_dcs_write_seq_static(ctx, 0xf0, 0x5a, 0x5a);\r\n}\r\nstatic void s6e8aa0_panel_cond_set_v142(struct s6e8aa0 *ctx)\r\n{\r\nstatic const u8 aids[] = {\r\n0x04, 0x04, 0x04, 0x04, 0x04, 0x60, 0x80, 0xA0\r\n};\r\nu8 aid = aids[ctx->id >> 5];\r\nu8 cfg = 0x3d;\r\nu8 clk_con = 0xc8;\r\nu8 int_con = 0x08;\r\nu8 bictl_con = 0x48;\r\nu8 em_clk1_con = 0xff;\r\nu8 em_clk2_con = 0xff;\r\nu8 em_int_con = 0xc8;\r\nif (ctx->flip_vertical) {\r\ncfg &= ~(PANELCTL_GTCON_MASK);\r\ncfg |= (PANELCTL_GTCON_110);\r\n}\r\nif (ctx->flip_horizontal) {\r\ncfg &= ~(PANELCTL_SS_MASK);\r\ncfg |= (PANELCTL_SS_1_800);\r\n}\r\nif (ctx->flip_horizontal || ctx->flip_vertical) {\r\nclk_con &= ~(PANELCTL_CLK1_CON_MASK |\r\nPANELCTL_CLK2_CON_MASK);\r\nclk_con |= (PANELCTL_CLK1_000 | PANELCTL_CLK2_001);\r\nint_con &= ~(PANELCTL_INT1_CON_MASK |\r\nPANELCTL_INT2_CON_MASK);\r\nint_con |= (PANELCTL_INT1_000 | PANELCTL_INT2_001);\r\nbictl_con &= ~(PANELCTL_BICTL_CON_MASK |\r\nPANELCTL_BICTLB_CON_MASK);\r\nbictl_con |= (PANELCTL_BICTL_000 |\r\nPANELCTL_BICTLB_001);\r\nem_clk1_con &= ~(PANELCTL_EM_CLK1_CON_MASK |\r\nPANELCTL_EM_CLK1B_CON_MASK);\r\nem_clk1_con |= (PANELCTL_EM_CLK1_110 |\r\nPANELCTL_EM_CLK1B_110);\r\nem_clk2_con &= ~(PANELCTL_EM_CLK2_CON_MASK |\r\nPANELCTL_EM_CLK2B_CON_MASK);\r\nem_clk2_con |= (PANELCTL_EM_CLK2_110 |\r\nPANELCTL_EM_CLK2B_110);\r\nem_int_con &= ~(PANELCTL_EM_INT1_CON_MASK |\r\nPANELCTL_EM_INT2_CON_MASK);\r\nem_int_con |= (PANELCTL_EM_INT1_000 |\r\nPANELCTL_EM_INT2_001);\r\n}\r\ns6e8aa0_dcs_write_seq(ctx,\r\n0xf8, cfg, 0x35, 0x00, 0x00, 0x00, 0x93, 0x00,\r\n0x3c, 0x78, 0x08, 0x27, 0x7d, 0x3f, 0x00, 0x00,\r\n0x00, 0x20, aid, 0x08, 0x6e, 0x00, 0x00, 0x00,\r\n0x02, 0x07, 0x07, 0x23, 0x23, 0xc0, clk_con, int_con,\r\nbictl_con, 0xc1, 0x00, 0xc1, em_clk1_con, em_clk2_con,\r\nem_int_con);\r\n}\r\nstatic void s6e8aa0_panel_cond_set(struct s6e8aa0 *ctx)\r\n{\r\nif (ctx->version < 142)\r\ns6e8aa0_dcs_write_seq_static(ctx,\r\n0xf8, 0x19, 0x35, 0x00, 0x00, 0x00, 0x94, 0x00,\r\n0x3c, 0x78, 0x10, 0x27, 0x08, 0x6e, 0x00, 0x00,\r\n0x00, 0x00, 0x04, 0x08, 0x6e, 0x00, 0x00, 0x00,\r\n0x00, 0x07, 0x07, 0x23, 0x6e, 0xc0, 0xc1, 0x01,\r\n0x81, 0xc1, 0x00, 0xc3, 0xf6, 0xf6, 0xc1\r\n);\r\nelse\r\ns6e8aa0_panel_cond_set_v142(ctx);\r\n}\r\nstatic void s6e8aa0_display_condition_set(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_dcs_write_seq_static(ctx, 0xf2, 0x80, 0x03, 0x0d);\r\n}\r\nstatic void s6e8aa0_etc_source_control(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_dcs_write_seq_static(ctx, 0xf6, 0x00, 0x02, 0x00);\r\n}\r\nstatic void s6e8aa0_etc_pentile_control(struct s6e8aa0 *ctx)\r\n{\r\nstatic const u8 pent32[] = {\r\n0xb6, 0x0c, 0x02, 0x03, 0x32, 0xc0, 0x44, 0x44, 0xc0, 0x00\r\n};\r\nstatic const u8 pent142[] = {\r\n0xb6, 0x0c, 0x02, 0x03, 0x32, 0xff, 0x44, 0x44, 0xc0, 0x00\r\n};\r\nif (ctx->version < 142)\r\ns6e8aa0_dcs_write(ctx, pent32, ARRAY_SIZE(pent32));\r\nelse\r\ns6e8aa0_dcs_write(ctx, pent142, ARRAY_SIZE(pent142));\r\n}\r\nstatic void s6e8aa0_etc_power_control(struct s6e8aa0 *ctx)\r\n{\r\nstatic const u8 pwr142[] = {\r\n0xf4, 0xcf, 0x0a, 0x12, 0x10, 0x1e, 0x33, 0x02\r\n};\r\nstatic const u8 pwr32[] = {\r\n0xf4, 0xcf, 0x0a, 0x15, 0x10, 0x19, 0x33, 0x02\r\n};\r\nif (ctx->version < 142)\r\ns6e8aa0_dcs_write(ctx, pwr32, ARRAY_SIZE(pwr32));\r\nelse\r\ns6e8aa0_dcs_write(ctx, pwr142, ARRAY_SIZE(pwr142));\r\n}\r\nstatic void s6e8aa0_etc_elvss_control(struct s6e8aa0 *ctx)\r\n{\r\nu8 id = ctx->id ? 0 : 0x95;\r\ns6e8aa0_dcs_write_seq(ctx, 0xb1, 0x04, id);\r\n}\r\nstatic void s6e8aa0_elvss_nvm_set_v142(struct s6e8aa0 *ctx)\r\n{\r\nu8 br;\r\nswitch (ctx->brightness) {\r\ncase 0 ... 6:\r\nbr = 0xdf;\r\nbreak;\r\ncase 7 ... 11:\r\nbr = 0xdd;\r\nbreak;\r\ncase 12 ... 15:\r\ndefault:\r\nbr = 0xd9;\r\nbreak;\r\ncase 16 ... 24:\r\nbr = 0xd0;\r\nbreak;\r\n}\r\ns6e8aa0_dcs_write_seq(ctx, 0xd9, 0x14, 0x40, 0x0c, 0xcb, 0xce, 0x6e,\r\n0xc4, 0x0f, 0x40, 0x41, br, 0x00, 0x60, 0x19);\r\n}\r\nstatic void s6e8aa0_elvss_nvm_set(struct s6e8aa0 *ctx)\r\n{\r\nif (ctx->version < 142)\r\ns6e8aa0_dcs_write_seq_static(ctx,\r\n0xd9, 0x14, 0x40, 0x0c, 0xcb, 0xce, 0x6e, 0xc4, 0x07,\r\n0x40, 0x41, 0xc1, 0x00, 0x60, 0x19);\r\nelse\r\ns6e8aa0_elvss_nvm_set_v142(ctx);\r\n}\r\nstatic void s6e8aa0_apply_level_2_key(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_dcs_write_seq_static(ctx, 0xfc, 0x5a, 0x5a);\r\n}\r\nstatic void s6e8aa0_brightness_set(struct s6e8aa0 *ctx)\r\n{\r\nconst u8 *gamma;\r\nif (ctx->error)\r\nreturn;\r\ngamma = ctx->variant->gamma_tables[ctx->brightness];\r\nif (ctx->version >= 142)\r\ns6e8aa0_elvss_nvm_set(ctx);\r\ns6e8aa0_dcs_write(ctx, gamma, GAMMA_TABLE_LEN);\r\ns6e8aa0_dcs_write_seq_static(ctx, 0xf7, 0x03);\r\n}\r\nstatic void s6e8aa0_panel_init(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_apply_level_1_key(ctx);\r\ns6e8aa0_apply_level_2_key(ctx);\r\nmsleep(20);\r\ns6e8aa0_dcs_write_seq_static(ctx, MIPI_DCS_EXIT_SLEEP_MODE);\r\nmsleep(40);\r\ns6e8aa0_panel_cond_set(ctx);\r\ns6e8aa0_display_condition_set(ctx);\r\ns6e8aa0_brightness_set(ctx);\r\ns6e8aa0_etc_source_control(ctx);\r\ns6e8aa0_etc_pentile_control(ctx);\r\ns6e8aa0_elvss_nvm_set(ctx);\r\ns6e8aa0_etc_power_control(ctx);\r\ns6e8aa0_etc_elvss_control(ctx);\r\nmsleep(ctx->init_delay);\r\n}\r\nstatic void s6e8aa0_set_maximum_return_packet_size(struct s6e8aa0 *ctx,\r\nu16 size)\r\n{\r\nstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\r\nint ret;\r\nif (ctx->error < 0)\r\nreturn;\r\nret = mipi_dsi_set_maximum_return_packet_size(dsi, size);\r\nif (ret < 0) {\r\ndev_err(ctx->dev,\r\n"error %d setting maximum return packet size to %d\n",\r\nret, size);\r\nctx->error = ret;\r\n}\r\n}\r\nstatic void s6e8aa0_read_mtp_id(struct s6e8aa0 *ctx)\r\n{\r\nu8 id[3];\r\nint ret, i;\r\nret = s6e8aa0_dcs_read(ctx, 0xd1, id, ARRAY_SIZE(id));\r\nif (ret < ARRAY_SIZE(id) || id[0] == 0x00) {\r\ndev_err(ctx->dev, "read id failed\n");\r\nctx->error = -EIO;\r\nreturn;\r\n}\r\ndev_info(ctx->dev, "ID: 0x%2x, 0x%2x, 0x%2x\n", id[0], id[1], id[2]);\r\nfor (i = 0; i < ARRAY_SIZE(s6e8aa0_variants); ++i) {\r\nif (id[1] == s6e8aa0_variants[i].version)\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(s6e8aa0_variants)) {\r\ndev_err(ctx->dev, "unsupported display version %d\n", id[1]);\r\nctx->error = -EINVAL;\r\nreturn;\r\n}\r\nctx->variant = &s6e8aa0_variants[i];\r\nctx->version = id[1];\r\nctx->id = id[2];\r\n}\r\nstatic void s6e8aa0_set_sequence(struct s6e8aa0 *ctx)\r\n{\r\ns6e8aa0_set_maximum_return_packet_size(ctx, 3);\r\ns6e8aa0_read_mtp_id(ctx);\r\ns6e8aa0_panel_init(ctx);\r\ns6e8aa0_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_ON);\r\n}\r\nstatic int s6e8aa0_power_on(struct s6e8aa0 *ctx)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(ctx->power_on_delay);\r\ngpiod_set_value(ctx->reset_gpio, 0);\r\nusleep_range(10000, 11000);\r\ngpiod_set_value(ctx->reset_gpio, 1);\r\nmsleep(ctx->reset_delay);\r\nreturn 0;\r\n}\r\nstatic int s6e8aa0_power_off(struct s6e8aa0 *ctx)\r\n{\r\nreturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\r\n}\r\nstatic int s6e8aa0_disable(struct drm_panel *panel)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s6e8aa0_unprepare(struct drm_panel *panel)\r\n{\r\nstruct s6e8aa0 *ctx = panel_to_s6e8aa0(panel);\r\ns6e8aa0_dcs_write_seq_static(ctx, MIPI_DCS_ENTER_SLEEP_MODE);\r\ns6e8aa0_dcs_write_seq_static(ctx, MIPI_DCS_SET_DISPLAY_OFF);\r\nmsleep(40);\r\ns6e8aa0_clear_error(ctx);\r\nreturn s6e8aa0_power_off(ctx);\r\n}\r\nstatic int s6e8aa0_prepare(struct drm_panel *panel)\r\n{\r\nstruct s6e8aa0 *ctx = panel_to_s6e8aa0(panel);\r\nint ret;\r\nret = s6e8aa0_power_on(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\ns6e8aa0_set_sequence(ctx);\r\nret = ctx->error;\r\nif (ret < 0)\r\ns6e8aa0_unprepare(panel);\r\nreturn ret;\r\n}\r\nstatic int s6e8aa0_enable(struct drm_panel *panel)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s6e8aa0_get_modes(struct drm_panel *panel)\r\n{\r\nstruct drm_connector *connector = panel->connector;\r\nstruct s6e8aa0 *ctx = panel_to_s6e8aa0(panel);\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(&ctx->vm, mode);\r\nmode->width_mm = ctx->width_mm;\r\nmode->height_mm = ctx->height_mm;\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nstatic int s6e8aa0_parse_dt(struct s6e8aa0 *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nret = of_get_videomode(np, &ctx->vm, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nof_property_read_u32(np, "power-on-delay", &ctx->power_on_delay);\r\nof_property_read_u32(np, "reset-delay", &ctx->reset_delay);\r\nof_property_read_u32(np, "init-delay", &ctx->init_delay);\r\nof_property_read_u32(np, "panel-width-mm", &ctx->width_mm);\r\nof_property_read_u32(np, "panel-height-mm", &ctx->height_mm);\r\nctx->flip_horizontal = of_property_read_bool(np, "flip-horizontal");\r\nctx->flip_vertical = of_property_read_bool(np, "flip-vertical");\r\nreturn 0;\r\n}\r\nstatic int s6e8aa0_probe(struct mipi_dsi_device *dsi)\r\n{\r\nstruct device *dev = &dsi->dev;\r\nstruct s6e8aa0 *ctx;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(struct s6e8aa0), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmipi_dsi_set_drvdata(dsi, ctx);\r\nctx->dev = dev;\r\ndsi->lanes = 4;\r\ndsi->format = MIPI_DSI_FMT_RGB888;\r\ndsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST\r\n| MIPI_DSI_MODE_VIDEO_HFP | MIPI_DSI_MODE_VIDEO_HBP\r\n| MIPI_DSI_MODE_VIDEO_HSA | MIPI_DSI_MODE_EOT_PACKET\r\n| MIPI_DSI_MODE_VSYNC_FLUSH | MIPI_DSI_MODE_VIDEO_AUTO_VERT;\r\nret = s6e8aa0_parse_dt(ctx);\r\nif (ret < 0)\r\nreturn ret;\r\nctx->supplies[0].supply = "vdd3";\r\nctx->supplies[1].supply = "vci";\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),\r\nctx->supplies);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get regulators: %d\n", ret);\r\nreturn ret;\r\n}\r\nctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ctx->reset_gpio)) {\r\ndev_err(dev, "cannot get reset-gpios %ld\n",\r\nPTR_ERR(ctx->reset_gpio));\r\nreturn PTR_ERR(ctx->reset_gpio);\r\n}\r\nctx->brightness = GAMMA_LEVEL_NUM - 1;\r\ndrm_panel_init(&ctx->panel);\r\nctx->panel.dev = dev;\r\nctx->panel.funcs = &s6e8aa0_drm_funcs;\r\nret = drm_panel_add(&ctx->panel);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mipi_dsi_attach(dsi);\r\nif (ret < 0)\r\ndrm_panel_remove(&ctx->panel);\r\nreturn ret;\r\n}\r\nstatic int s6e8aa0_remove(struct mipi_dsi_device *dsi)\r\n{\r\nstruct s6e8aa0 *ctx = mipi_dsi_get_drvdata(dsi);\r\nmipi_dsi_detach(dsi);\r\ndrm_panel_remove(&ctx->panel);\r\nreturn 0;\r\n}
