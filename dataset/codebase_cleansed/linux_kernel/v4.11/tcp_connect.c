void rds_tcp_state_change(struct sock *sk)\r\n{\r\nvoid (*state_change)(struct sock *sk);\r\nstruct rds_conn_path *cp;\r\nstruct rds_tcp_connection *tc;\r\nread_lock_bh(&sk->sk_callback_lock);\r\ncp = sk->sk_user_data;\r\nif (!cp) {\r\nstate_change = sk->sk_state_change;\r\ngoto out;\r\n}\r\ntc = cp->cp_transport_data;\r\nstate_change = tc->t_orig_state_change;\r\nrdsdebug("sock %p state_change to %d\n", tc->t_sock, sk->sk_state);\r\nswitch (sk->sk_state) {\r\ncase TCP_SYN_SENT:\r\ncase TCP_SYN_RECV:\r\nbreak;\r\ncase TCP_ESTABLISHED:\r\nif (cp->cp_conn->c_laddr > cp->cp_conn->c_faddr &&\r\nrds_conn_path_transition(cp, RDS_CONN_CONNECTING,\r\nRDS_CONN_ERROR)) {\r\nrds_conn_path_drop(cp);\r\n} else {\r\nrds_connect_path_complete(cp, RDS_CONN_CONNECTING);\r\n}\r\nbreak;\r\ncase TCP_CLOSE_WAIT:\r\ncase TCP_CLOSE:\r\nrds_conn_path_drop(cp);\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nstate_change(sk);\r\n}\r\nint rds_tcp_conn_path_connect(struct rds_conn_path *cp)\r\n{\r\nstruct socket *sock = NULL;\r\nstruct sockaddr_in src, dest;\r\nint ret;\r\nstruct rds_connection *conn = cp->cp_conn;\r\nstruct rds_tcp_connection *tc = cp->cp_transport_data;\r\nif (cp->cp_index > 0 && cp->cp_conn->c_npaths < 2)\r\nreturn -EAGAIN;\r\nmutex_lock(&tc->t_conn_path_lock);\r\nif (rds_conn_path_up(cp)) {\r\nmutex_unlock(&tc->t_conn_path_lock);\r\nreturn 0;\r\n}\r\nret = sock_create_kern(rds_conn_net(conn), PF_INET,\r\nSOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (ret < 0)\r\ngoto out;\r\nrds_tcp_tune(sock);\r\nsrc.sin_family = AF_INET;\r\nsrc.sin_addr.s_addr = (__force u32)conn->c_laddr;\r\nsrc.sin_port = (__force u16)htons(0);\r\nret = sock->ops->bind(sock, (struct sockaddr *)&src, sizeof(src));\r\nif (ret) {\r\nrdsdebug("bind failed with %d at address %pI4\n",\r\nret, &conn->c_laddr);\r\ngoto out;\r\n}\r\ndest.sin_family = AF_INET;\r\ndest.sin_addr.s_addr = (__force u32)conn->c_faddr;\r\ndest.sin_port = (__force u16)htons(RDS_TCP_PORT);\r\nrds_tcp_set_callbacks(sock, cp);\r\nret = sock->ops->connect(sock, (struct sockaddr *)&dest, sizeof(dest),\r\nO_NONBLOCK);\r\ncp->cp_outgoing = 1;\r\nrdsdebug("connect to address %pI4 returned %d\n", &conn->c_faddr, ret);\r\nif (ret == -EINPROGRESS)\r\nret = 0;\r\nif (ret == 0) {\r\nrds_tcp_keepalive(sock);\r\nsock = NULL;\r\n} else {\r\nrds_tcp_restore_callbacks(sock, cp->cp_transport_data);\r\n}\r\nout:\r\nmutex_unlock(&tc->t_conn_path_lock);\r\nif (sock)\r\nsock_release(sock);\r\nreturn ret;\r\n}\r\nvoid rds_tcp_conn_path_shutdown(struct rds_conn_path *cp)\r\n{\r\nstruct rds_tcp_connection *tc = cp->cp_transport_data;\r\nstruct socket *sock = tc->t_sock;\r\nrdsdebug("shutting down conn %p tc %p sock %p\n",\r\ncp->cp_conn, tc, sock);\r\nif (sock) {\r\nsock->ops->shutdown(sock, RCV_SHUTDOWN | SEND_SHUTDOWN);\r\nlock_sock(sock->sk);\r\nrds_tcp_restore_callbacks(sock, tc);\r\nrelease_sock(sock->sk);\r\nsock_release(sock);\r\n}\r\nif (tc->t_tinc) {\r\nrds_inc_put(&tc->t_tinc->ti_inc);\r\ntc->t_tinc = NULL;\r\n}\r\ntc->t_tinc_hdr_rem = sizeof(struct rds_header);\r\ntc->t_tinc_data_rem = 0;\r\n}
