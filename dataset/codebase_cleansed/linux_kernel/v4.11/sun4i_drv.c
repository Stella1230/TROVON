static int sun4i_drv_enable_vblank(struct drm_device *drm, unsigned int pipe)\r\n{\r\nstruct sun4i_drv *drv = drm->dev_private;\r\nstruct sun4i_tcon *tcon = drv->tcon;\r\nDRM_DEBUG_DRIVER("Enabling VBLANK on pipe %d\n", pipe);\r\nsun4i_tcon_enable_vblank(tcon, true);\r\nreturn 0;\r\n}\r\nstatic void sun4i_drv_disable_vblank(struct drm_device *drm, unsigned int pipe)\r\n{\r\nstruct sun4i_drv *drv = drm->dev_private;\r\nstruct sun4i_tcon *tcon = drv->tcon;\r\nDRM_DEBUG_DRIVER("Disabling VBLANK on pipe %d\n", pipe);\r\nsun4i_tcon_enable_vblank(tcon, false);\r\n}\r\nstatic void sun4i_remove_framebuffers(void)\r\n{\r\nstruct apertures_struct *ap;\r\nap = alloc_apertures(1);\r\nif (!ap)\r\nreturn;\r\nap->ranges[0].base = 0;\r\nap->ranges[0].size = ~0;\r\ndrm_fb_helper_remove_conflicting_framebuffers(ap, "sun4i-drm-fb", false);\r\nkfree(ap);\r\n}\r\nstatic int sun4i_drv_bind(struct device *dev)\r\n{\r\nstruct drm_device *drm;\r\nstruct sun4i_drv *drv;\r\nint ret;\r\ndrm = drm_dev_alloc(&sun4i_drv_driver, dev);\r\nif (IS_ERR(drm))\r\nreturn PTR_ERR(drm);\r\ndrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\r\nif (!drv) {\r\nret = -ENOMEM;\r\ngoto free_drm;\r\n}\r\ndrm->dev_private = drv;\r\ndrm_vblank_init(drm, 1);\r\ndrm_mode_config_init(drm);\r\nret = component_bind_all(drm->dev, drm);\r\nif (ret) {\r\ndev_err(drm->dev, "Couldn't bind all pipelines components\n");\r\ngoto free_drm;\r\n}\r\ndrv->layers = sun4i_layers_init(drm);\r\nif (IS_ERR(drv->layers)) {\r\ndev_err(drm->dev, "Couldn't create the planes\n");\r\nret = PTR_ERR(drv->layers);\r\ngoto free_drm;\r\n}\r\ndrv->crtc = sun4i_crtc_init(drm);\r\nif (!drv->crtc) {\r\ndev_err(drm->dev, "Couldn't create the CRTC\n");\r\nret = -EINVAL;\r\ngoto free_drm;\r\n}\r\ndrm->irq_enabled = true;\r\nsun4i_remove_framebuffers();\r\ndrv->fbdev = sun4i_framebuffer_init(drm);\r\nif (IS_ERR(drv->fbdev)) {\r\ndev_err(drm->dev, "Couldn't create our framebuffer\n");\r\nret = PTR_ERR(drv->fbdev);\r\ngoto free_drm;\r\n}\r\ndrm_kms_helper_poll_init(drm);\r\nret = drm_dev_register(drm, 0);\r\nif (ret)\r\ngoto free_drm;\r\nreturn 0;\r\nfree_drm:\r\ndrm_dev_unref(drm);\r\nreturn ret;\r\n}\r\nstatic void sun4i_drv_unbind(struct device *dev)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(dev);\r\ndrm_dev_unregister(drm);\r\ndrm_kms_helper_poll_fini(drm);\r\nsun4i_framebuffer_free(drm);\r\ndrm_vblank_cleanup(drm);\r\ndrm_dev_unref(drm);\r\n}\r\nstatic bool sun4i_drv_node_is_frontend(struct device_node *node)\r\n{\r\nreturn of_device_is_compatible(node, "allwinner,sun5i-a13-display-frontend") ||\r\nof_device_is_compatible(node, "allwinner,sun6i-a31-display-frontend") ||\r\nof_device_is_compatible(node, "allwinner,sun8i-a33-display-frontend");\r\n}\r\nstatic bool sun4i_drv_node_is_tcon(struct device_node *node)\r\n{\r\nreturn of_device_is_compatible(node, "allwinner,sun5i-a13-tcon") ||\r\nof_device_is_compatible(node, "allwinner,sun6i-a31-tcon") ||\r\nof_device_is_compatible(node, "allwinner,sun6i-a31s-tcon") ||\r\nof_device_is_compatible(node, "allwinner,sun8i-a33-tcon");\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nDRM_DEBUG_DRIVER("Comparing of node %s with %s\n",\r\nof_node_full_name(dev->of_node),\r\nof_node_full_name(data));\r\nreturn dev->of_node == data;\r\n}\r\nstatic int sun4i_drv_add_endpoints(struct device *dev,\r\nstruct component_match **match,\r\nstruct device_node *node)\r\n{\r\nstruct device_node *port, *ep, *remote;\r\nint count = 0;\r\nif (!sun4i_drv_node_is_frontend(node) &&\r\n!of_device_is_available(node))\r\nreturn 0;\r\nif (!sun4i_drv_node_is_frontend(node)) {\r\nDRM_DEBUG_DRIVER("Adding component %s\n",\r\nof_node_full_name(node));\r\ndrm_of_component_match_add(dev, match, compare_of, node);\r\ncount++;\r\n}\r\nport = of_graph_get_port_by_id(node, 1);\r\nif (!port) {\r\nDRM_DEBUG_DRIVER("No output to bind\n");\r\nreturn count;\r\n}\r\nfor_each_available_child_of_node(port, ep) {\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote) {\r\nDRM_DEBUG_DRIVER("Error retrieving the output node\n");\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\nif (sun4i_drv_node_is_tcon(node)) {\r\nstruct of_endpoint endpoint;\r\nif (of_graph_parse_endpoint(ep, &endpoint)) {\r\nDRM_DEBUG_DRIVER("Couldn't parse endpoint\n");\r\ncontinue;\r\n}\r\nif (!endpoint.id) {\r\nDRM_DEBUG_DRIVER("Endpoint is our panel... skipping\n");\r\ncontinue;\r\n}\r\n}\r\ncount += sun4i_drv_add_endpoints(dev, match, remote);\r\nof_node_put(remote);\r\n}\r\nreturn count;\r\n}\r\nstatic int sun4i_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct component_match *match = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint i, count = 0;\r\nfor (i = 0;; i++) {\r\nstruct device_node *pipeline = of_parse_phandle(np,\r\n"allwinner,pipelines",\r\ni);\r\nif (!pipeline)\r\nbreak;\r\ncount += sun4i_drv_add_endpoints(&pdev->dev, &match,\r\npipeline);\r\nof_node_put(pipeline);\r\nDRM_DEBUG_DRIVER("Queued %d outputs on pipeline %d\n",\r\ncount, i);\r\n}\r\nif (count)\r\nreturn component_master_add_with_match(&pdev->dev,\r\n&sun4i_drv_master_ops,\r\nmatch);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int sun4i_drv_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
