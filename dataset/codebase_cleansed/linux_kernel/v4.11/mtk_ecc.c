static inline void mtk_ecc_wait_idle(struct mtk_ecc *ecc,\r\nenum mtk_ecc_operation op)\r\n{\r\nstruct device *dev = ecc->dev;\r\nu32 val;\r\nint ret;\r\nret = readl_poll_timeout_atomic(ecc->regs + ECC_IDLE_REG(op), val,\r\nval & ECC_IDLE_MASK,\r\n10, ECC_TIMEOUT);\r\nif (ret)\r\ndev_warn(dev, "%s NOT idle\n",\r\nop == ECC_ENCODE ? "encoder" : "decoder");\r\n}\r\nstatic irqreturn_t mtk_ecc_irq(int irq, void *id)\r\n{\r\nstruct mtk_ecc *ecc = id;\r\nenum mtk_ecc_operation op;\r\nu32 dec, enc;\r\ndec = readw(ecc->regs + ECC_DECIRQ_STA) & ECC_IRQ_EN;\r\nif (dec) {\r\nop = ECC_DECODE;\r\ndec = readw(ecc->regs + ECC_DECDONE);\r\nif (dec & ecc->sectors) {\r\necc->sectors = 0;\r\ncomplete(&ecc->done);\r\n} else {\r\nreturn IRQ_HANDLED;\r\n}\r\n} else {\r\nenc = readl(ecc->regs + ECC_ENCIRQ_STA) & ECC_IRQ_EN;\r\nif (enc) {\r\nop = ECC_ENCODE;\r\ncomplete(&ecc->done);\r\n} else {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nwritel(0, ecc->regs + ECC_IRQ_REG(op));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mtk_ecc_config(struct mtk_ecc *ecc, struct mtk_ecc_config *config)\r\n{\r\nu32 ecc_bit = ECC_CNFG_4BIT, dec_sz, enc_sz;\r\nu32 reg;\r\nswitch (config->strength) {\r\ncase 4:\r\necc_bit = ECC_CNFG_4BIT;\r\nbreak;\r\ncase 6:\r\necc_bit = ECC_CNFG_6BIT;\r\nbreak;\r\ncase 8:\r\necc_bit = ECC_CNFG_8BIT;\r\nbreak;\r\ncase 10:\r\necc_bit = ECC_CNFG_10BIT;\r\nbreak;\r\ncase 12:\r\necc_bit = ECC_CNFG_12BIT;\r\nbreak;\r\ncase 14:\r\necc_bit = ECC_CNFG_14BIT;\r\nbreak;\r\ncase 16:\r\necc_bit = ECC_CNFG_16BIT;\r\nbreak;\r\ncase 18:\r\necc_bit = ECC_CNFG_18BIT;\r\nbreak;\r\ncase 20:\r\necc_bit = ECC_CNFG_20BIT;\r\nbreak;\r\ncase 22:\r\necc_bit = ECC_CNFG_22BIT;\r\nbreak;\r\ncase 24:\r\necc_bit = ECC_CNFG_24BIT;\r\nbreak;\r\ncase 28:\r\necc_bit = ECC_CNFG_28BIT;\r\nbreak;\r\ncase 32:\r\necc_bit = ECC_CNFG_32BIT;\r\nbreak;\r\ncase 36:\r\necc_bit = ECC_CNFG_36BIT;\r\nbreak;\r\ncase 40:\r\necc_bit = ECC_CNFG_40BIT;\r\nbreak;\r\ncase 44:\r\necc_bit = ECC_CNFG_44BIT;\r\nbreak;\r\ncase 48:\r\necc_bit = ECC_CNFG_48BIT;\r\nbreak;\r\ncase 52:\r\necc_bit = ECC_CNFG_52BIT;\r\nbreak;\r\ncase 56:\r\necc_bit = ECC_CNFG_56BIT;\r\nbreak;\r\ncase 60:\r\necc_bit = ECC_CNFG_60BIT;\r\nbreak;\r\ndefault:\r\ndev_err(ecc->dev, "invalid strength %d, default to 4 bits\n",\r\nconfig->strength);\r\n}\r\nif (config->op == ECC_ENCODE) {\r\nenc_sz = config->len << 3;\r\nreg = ecc_bit | (config->mode << ECC_MODE_SHIFT);\r\nreg |= (enc_sz << ECC_MS_SHIFT);\r\nwritel(reg, ecc->regs + ECC_ENCCNFG);\r\nif (config->mode != ECC_NFI_MODE)\r\nwritel(lower_32_bits(config->addr),\r\necc->regs + ECC_ENCDIADDR);\r\n} else {\r\ndec_sz = (config->len << 3) +\r\nconfig->strength * ECC_PARITY_BITS;\r\nreg = ecc_bit | (config->mode << ECC_MODE_SHIFT);\r\nreg |= (dec_sz << ECC_MS_SHIFT) | DEC_CNFG_CORRECT;\r\nreg |= DEC_EMPTY_EN;\r\nwritel(reg, ecc->regs + ECC_DECCNFG);\r\nif (config->sectors)\r\necc->sectors = 1 << (config->sectors - 1);\r\n}\r\n}\r\nvoid mtk_ecc_get_stats(struct mtk_ecc *ecc, struct mtk_ecc_stats *stats,\r\nint sectors)\r\n{\r\nu32 offset, i, err;\r\nu32 bitflips = 0;\r\nstats->corrected = 0;\r\nstats->failed = 0;\r\nfor (i = 0; i < sectors; i++) {\r\noffset = (i >> 2) << 2;\r\nerr = readl(ecc->regs + ECC_DECENUM0 + offset);\r\nerr = err >> ((i % 4) * 8);\r\nerr &= ERR_MASK;\r\nif (err == ERR_MASK) {\r\nstats->failed++;\r\ncontinue;\r\n}\r\nstats->corrected += err;\r\nbitflips = max_t(u32, bitflips, err);\r\n}\r\nstats->bitflips = bitflips;\r\n}\r\nvoid mtk_ecc_release(struct mtk_ecc *ecc)\r\n{\r\nclk_disable_unprepare(ecc->clk);\r\nput_device(ecc->dev);\r\n}\r\nstatic void mtk_ecc_hw_init(struct mtk_ecc *ecc)\r\n{\r\nmtk_ecc_wait_idle(ecc, ECC_ENCODE);\r\nwritew(ECC_OP_DISABLE, ecc->regs + ECC_ENCCON);\r\nmtk_ecc_wait_idle(ecc, ECC_DECODE);\r\nwritel(ECC_OP_DISABLE, ecc->regs + ECC_DECCON);\r\n}\r\nstatic struct mtk_ecc *mtk_ecc_get(struct device_node *np)\r\n{\r\nstruct platform_device *pdev;\r\nstruct mtk_ecc *ecc;\r\npdev = of_find_device_by_node(np);\r\nif (!pdev || !platform_get_drvdata(pdev))\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nget_device(&pdev->dev);\r\necc = platform_get_drvdata(pdev);\r\nclk_prepare_enable(ecc->clk);\r\nmtk_ecc_hw_init(ecc);\r\nreturn ecc;\r\n}\r\nstruct mtk_ecc *of_mtk_ecc_get(struct device_node *of_node)\r\n{\r\nstruct mtk_ecc *ecc = NULL;\r\nstruct device_node *np;\r\nnp = of_parse_phandle(of_node, "ecc-engine", 0);\r\nif (np) {\r\necc = mtk_ecc_get(np);\r\nof_node_put(np);\r\n}\r\nreturn ecc;\r\n}\r\nint mtk_ecc_enable(struct mtk_ecc *ecc, struct mtk_ecc_config *config)\r\n{\r\nenum mtk_ecc_operation op = config->op;\r\nint ret;\r\nret = mutex_lock_interruptible(&ecc->lock);\r\nif (ret) {\r\ndev_err(ecc->dev, "interrupted when attempting to lock\n");\r\nreturn ret;\r\n}\r\nmtk_ecc_wait_idle(ecc, op);\r\nmtk_ecc_config(ecc, config);\r\nwritew(ECC_OP_ENABLE, ecc->regs + ECC_CTL_REG(op));\r\ninit_completion(&ecc->done);\r\nwritew(ECC_IRQ_EN, ecc->regs + ECC_IRQ_REG(op));\r\nreturn 0;\r\n}\r\nvoid mtk_ecc_disable(struct mtk_ecc *ecc)\r\n{\r\nenum mtk_ecc_operation op = ECC_ENCODE;\r\nif (readw(ecc->regs + ECC_CTL_REG(op)) != ECC_OP_ENABLE)\r\nop = ECC_DECODE;\r\nmtk_ecc_wait_idle(ecc, op);\r\nwritew(0, ecc->regs + ECC_IRQ_REG(op));\r\nwritew(ECC_OP_DISABLE, ecc->regs + ECC_CTL_REG(op));\r\nmutex_unlock(&ecc->lock);\r\n}\r\nint mtk_ecc_wait_done(struct mtk_ecc *ecc, enum mtk_ecc_operation op)\r\n{\r\nint ret;\r\nret = wait_for_completion_timeout(&ecc->done, msecs_to_jiffies(500));\r\nif (!ret) {\r\ndev_err(ecc->dev, "%s timeout - interrupt did not arrive)\n",\r\n(op == ECC_ENCODE) ? "encoder" : "decoder");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint mtk_ecc_encode(struct mtk_ecc *ecc, struct mtk_ecc_config *config,\r\nu8 *data, u32 bytes)\r\n{\r\ndma_addr_t addr;\r\nu32 len;\r\nint ret;\r\naddr = dma_map_single(ecc->dev, data, bytes, DMA_TO_DEVICE);\r\nret = dma_mapping_error(ecc->dev, addr);\r\nif (ret) {\r\ndev_err(ecc->dev, "dma mapping error\n");\r\nreturn -EINVAL;\r\n}\r\nconfig->op = ECC_ENCODE;\r\nconfig->addr = addr;\r\nret = mtk_ecc_enable(ecc, config);\r\nif (ret) {\r\ndma_unmap_single(ecc->dev, addr, bytes, DMA_TO_DEVICE);\r\nreturn ret;\r\n}\r\nret = mtk_ecc_wait_done(ecc, ECC_ENCODE);\r\nif (ret)\r\ngoto timeout;\r\nmtk_ecc_wait_idle(ecc, ECC_ENCODE);\r\nlen = (config->strength * ECC_PARITY_BITS + 7) >> 3;\r\n__ioread32_copy(ecc->eccdata, ecc->regs + ECC_ENCPAR(0), round_up(len, 4));\r\nmemcpy(data + bytes, ecc->eccdata, len);\r\ntimeout:\r\ndma_unmap_single(ecc->dev, addr, bytes, DMA_TO_DEVICE);\r\nmtk_ecc_disable(ecc);\r\nreturn ret;\r\n}\r\nvoid mtk_ecc_adjust_strength(u32 *p)\r\n{\r\nu32 ecc[] = {4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36,\r\n40, 44, 48, 52, 56, 60};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ecc); i++) {\r\nif (*p <= ecc[i]) {\r\nif (!i)\r\n*p = ecc[i];\r\nelse if (*p != ecc[i])\r\n*p = ecc[i - 1];\r\nreturn;\r\n}\r\n}\r\n*p = ecc[ARRAY_SIZE(ecc) - 1];\r\n}\r\nstatic int mtk_ecc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_ecc *ecc;\r\nstruct resource *res;\r\nint irq, ret;\r\necc = devm_kzalloc(dev, sizeof(*ecc), GFP_KERNEL);\r\nif (!ecc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\necc->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ecc->regs)) {\r\ndev_err(dev, "failed to map regs: %ld\n", PTR_ERR(ecc->regs));\r\nreturn PTR_ERR(ecc->regs);\r\n}\r\necc->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(ecc->clk)) {\r\ndev_err(dev, "failed to get clock: %ld\n", PTR_ERR(ecc->clk));\r\nreturn PTR_ERR(ecc->clk);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get irq\n");\r\nreturn -EINVAL;\r\n}\r\nret = dma_set_mask(dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(dev, "failed to set DMA mask\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(dev, irq, mtk_ecc_irq, 0x0, "mtk-ecc", ecc);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq\n");\r\nreturn -EINVAL;\r\n}\r\necc->dev = dev;\r\nmutex_init(&ecc->lock);\r\nplatform_set_drvdata(pdev, ecc);\r\ndev_info(dev, "probed\n");\r\nreturn 0;\r\n}\r\nstatic int mtk_ecc_suspend(struct device *dev)\r\n{\r\nstruct mtk_ecc *ecc = dev_get_drvdata(dev);\r\nclk_disable_unprepare(ecc->clk);\r\nreturn 0;\r\n}\r\nstatic int mtk_ecc_resume(struct device *dev)\r\n{\r\nstruct mtk_ecc *ecc = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(ecc->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clk\n");\r\nreturn ret;\r\n}\r\nmtk_ecc_hw_init(ecc);\r\nreturn 0;\r\n}
