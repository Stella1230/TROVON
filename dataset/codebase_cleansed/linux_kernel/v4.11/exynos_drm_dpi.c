static inline struct exynos_dpi *encoder_to_dpi(struct drm_encoder *e)\r\n{\r\nreturn container_of(e, struct exynos_dpi, encoder);\r\n}\r\nstatic enum drm_connector_status\r\nexynos_dpi_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct exynos_dpi *ctx = connector_to_dpi(connector);\r\nif (ctx->panel && !ctx->panel->connector)\r\ndrm_panel_attach(ctx->panel, &ctx->connector);\r\nreturn connector_status_connected;\r\n}\r\nstatic void exynos_dpi_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int exynos_dpi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_dpi *ctx = connector_to_dpi(connector);\r\nif (ctx->vm) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(ctx->vm, mode);\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nif (ctx->panel)\r\nreturn ctx->panel->funcs->get_modes(ctx->panel);\r\nreturn 0;\r\n}\r\nstatic int exynos_dpi_create_connector(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\r\nstruct drm_connector *connector = &ctx->connector;\r\nint ret;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(encoder->dev, connector,\r\n&exynos_dpi_connector_funcs,\r\nDRM_MODE_CONNECTOR_VGA);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector, &exynos_dpi_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void exynos_dpi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void exynos_dpi_enable(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\r\nif (ctx->panel) {\r\ndrm_panel_prepare(ctx->panel);\r\ndrm_panel_enable(ctx->panel);\r\n}\r\n}\r\nstatic void exynos_dpi_disable(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\r\nif (ctx->panel) {\r\ndrm_panel_disable(ctx->panel);\r\ndrm_panel_unprepare(ctx->panel);\r\n}\r\n}\r\nstatic struct device_node *exynos_dpi_of_find_panel_node(struct device *dev)\r\n{\r\nstruct device_node *np, *ep;\r\nep = of_graph_get_endpoint_by_regs(dev->of_node, FIMD_PORT_RGB, 0);\r\nif (!ep)\r\nreturn NULL;\r\nnp = of_graph_get_remote_port_parent(ep);\r\nof_node_put(ep);\r\nreturn np;\r\n}\r\nstatic int exynos_dpi_parse_dt(struct exynos_dpi *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct device_node *dn = dev->of_node;\r\nstruct device_node *np;\r\nctx->panel_node = exynos_dpi_of_find_panel_node(dev);\r\nnp = of_get_child_by_name(dn, "display-timings");\r\nif (np) {\r\nstruct videomode *vm;\r\nint ret;\r\nof_node_put(np);\r\nvm = devm_kzalloc(dev, sizeof(*ctx->vm), GFP_KERNEL);\r\nif (!vm)\r\nreturn -ENOMEM;\r\nret = of_get_videomode(dn, vm, 0);\r\nif (ret < 0) {\r\ndevm_kfree(dev, vm);\r\nreturn ret;\r\n}\r\nctx->vm = vm;\r\nreturn 0;\r\n}\r\nif (!ctx->panel_node)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint exynos_dpi_bind(struct drm_device *dev, struct drm_encoder *encoder)\r\n{\r\nint ret;\r\nret = exynos_drm_crtc_get_pipe_from_type(dev, EXYNOS_DISPLAY_TYPE_LCD);\r\nif (ret < 0)\r\nreturn ret;\r\nencoder->possible_crtcs = 1 << ret;\r\nDRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);\r\ndrm_encoder_init(dev, encoder, &exynos_dpi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\ndrm_encoder_helper_add(encoder, &exynos_dpi_encoder_helper_funcs);\r\nret = exynos_dpi_create_connector(encoder);\r\nif (ret) {\r\nDRM_ERROR("failed to create connector ret = %d\n", ret);\r\ndrm_encoder_cleanup(encoder);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct drm_encoder *exynos_dpi_probe(struct device *dev)\r\n{\r\nstruct exynos_dpi *ctx;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->dev = dev;\r\nret = exynos_dpi_parse_dt(ctx);\r\nif (ret < 0) {\r\ndevm_kfree(dev, ctx);\r\nreturn NULL;\r\n}\r\nif (ctx->panel_node) {\r\nctx->panel = of_drm_find_panel(ctx->panel_node);\r\nif (!ctx->panel)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\nreturn &ctx->encoder;\r\n}\r\nint exynos_dpi_remove(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_dpi *ctx = encoder_to_dpi(encoder);\r\nexynos_dpi_disable(&ctx->encoder);\r\nif (ctx->panel)\r\ndrm_panel_detach(ctx->panel);\r\nreturn 0;\r\n}
