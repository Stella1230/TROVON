int omap_usb2_set_comparator(struct phy_companion *comparator)\r\n{\r\nstruct omap_usb *phy;\r\nstruct usb_phy *x = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR(x))\r\nreturn -ENODEV;\r\nphy = phy_to_omapusb(x);\r\nphy->comparator = comparator;\r\nreturn 0;\r\n}\r\nstatic int omap_usb_set_vbus(struct usb_otg *otg, bool enabled)\r\n{\r\nstruct omap_usb *phy = phy_to_omapusb(otg->usb_phy);\r\nif (!phy->comparator)\r\nreturn -ENODEV;\r\nreturn phy->comparator->set_vbus(phy->comparator, enabled);\r\n}\r\nstatic int omap_usb_start_srp(struct usb_otg *otg)\r\n{\r\nstruct omap_usb *phy = phy_to_omapusb(otg->usb_phy);\r\nif (!phy->comparator)\r\nreturn -ENODEV;\r\nreturn phy->comparator->start_srp(phy->comparator);\r\n}\r\nstatic int omap_usb_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\notg->host = host;\r\nif (!host)\r\notg->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int omap_usb_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\notg->gadget = gadget;\r\nif (!gadget)\r\notg->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int omap_usb_phy_power(struct omap_usb *phy, int on)\r\n{\r\nu32 val;\r\nint ret;\r\nif (!phy->syscon_phy_power) {\r\nomap_control_phy_power(phy->control_dev, on);\r\nreturn 0;\r\n}\r\nif (on)\r\nval = phy->power_on;\r\nelse\r\nval = phy->power_off;\r\nret = regmap_update_bits(phy->syscon_phy_power, phy->power_reg,\r\nphy->mask, val);\r\nreturn ret;\r\n}\r\nstatic int omap_usb_power_off(struct phy *x)\r\n{\r\nstruct omap_usb *phy = phy_get_drvdata(x);\r\nreturn omap_usb_phy_power(phy, false);\r\n}\r\nstatic int omap_usb_power_on(struct phy *x)\r\n{\r\nstruct omap_usb *phy = phy_get_drvdata(x);\r\nreturn omap_usb_phy_power(phy, true);\r\n}\r\nstatic int omap_usb2_disable_clocks(struct omap_usb *phy)\r\n{\r\nclk_disable(phy->wkupclk);\r\nif (!IS_ERR(phy->optclk))\r\nclk_disable(phy->optclk);\r\nreturn 0;\r\n}\r\nstatic int omap_usb2_enable_clocks(struct omap_usb *phy)\r\n{\r\nint ret;\r\nret = clk_enable(phy->wkupclk);\r\nif (ret < 0) {\r\ndev_err(phy->dev, "Failed to enable wkupclk %d\n", ret);\r\ngoto err0;\r\n}\r\nif (!IS_ERR(phy->optclk)) {\r\nret = clk_enable(phy->optclk);\r\nif (ret < 0) {\r\ndev_err(phy->dev, "Failed to enable optclk %d\n", ret);\r\ngoto err1;\r\n}\r\n}\r\nreturn 0;\r\nerr1:\r\nclk_disable(phy->wkupclk);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int omap_usb_init(struct phy *x)\r\n{\r\nstruct omap_usb *phy = phy_get_drvdata(x);\r\nu32 val;\r\nomap_usb2_enable_clocks(phy);\r\nif (phy->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT) {\r\nval = omap_usb_readl(phy->phy_base, USB2PHY_ANA_CONFIG1);\r\nval |= USB2PHY_DISCON_BYP_LATCH;\r\nomap_usb_writel(phy->phy_base, USB2PHY_ANA_CONFIG1, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_usb_exit(struct phy *x)\r\n{\r\nstruct omap_usb *phy = phy_get_drvdata(x);\r\nreturn omap_usb2_disable_clocks(phy);\r\n}\r\nstatic int omap_usb2_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_usb *phy;\r\nstruct phy *generic_phy;\r\nstruct resource *res;\r\nstruct phy_provider *phy_provider;\r\nstruct usb_otg *otg;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *control_node;\r\nstruct platform_device *control_pdev;\r\nconst struct of_device_id *of_id;\r\nstruct usb_phy_data *phy_data;\r\nof_id = of_match_device(omap_usb2_id_table, &pdev->dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nphy_data = (struct usb_phy_data *)of_id->data;\r\nphy = devm_kzalloc(&pdev->dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\notg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\r\nif (!otg)\r\nreturn -ENOMEM;\r\nphy->dev = &pdev->dev;\r\nphy->phy.dev = phy->dev;\r\nphy->phy.label = phy_data->label;\r\nphy->phy.otg = otg;\r\nphy->phy.type = USB_PHY_TYPE_USB2;\r\nphy->mask = phy_data->mask;\r\nphy->power_on = phy_data->power_on;\r\nphy->power_off = phy_data->power_off;\r\nif (phy_data->flags & OMAP_USB2_CALIBRATE_FALSE_DISCONNECT) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nphy->phy_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(phy->phy_base))\r\nreturn PTR_ERR(phy->phy_base);\r\nphy->flags |= OMAP_USB2_CALIBRATE_FALSE_DISCONNECT;\r\n}\r\nphy->syscon_phy_power = syscon_regmap_lookup_by_phandle(node,\r\n"syscon-phy-power");\r\nif (IS_ERR(phy->syscon_phy_power)) {\r\ndev_dbg(&pdev->dev,\r\n"can't get syscon-phy-power, using control device\n");\r\nphy->syscon_phy_power = NULL;\r\ncontrol_node = of_parse_phandle(node, "ctrl-module", 0);\r\nif (!control_node) {\r\ndev_err(&pdev->dev,\r\n"Failed to get control device phandle\n");\r\nreturn -EINVAL;\r\n}\r\ncontrol_pdev = of_find_device_by_node(control_node);\r\nif (!control_pdev) {\r\ndev_err(&pdev->dev, "Failed to get control device\n");\r\nreturn -EINVAL;\r\n}\r\nphy->control_dev = &control_pdev->dev;\r\n} else {\r\nif (of_property_read_u32_index(node,\r\n"syscon-phy-power", 1,\r\n&phy->power_reg)) {\r\ndev_err(&pdev->dev,\r\n"couldn't get power reg. offset\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\notg->set_host = omap_usb_set_host;\r\notg->set_peripheral = omap_usb_set_peripheral;\r\nif (phy_data->flags & OMAP_USB2_HAS_SET_VBUS)\r\notg->set_vbus = omap_usb_set_vbus;\r\nif (phy_data->flags & OMAP_USB2_HAS_START_SRP)\r\notg->start_srp = omap_usb_start_srp;\r\notg->usb_phy = &phy->phy;\r\nplatform_set_drvdata(pdev, phy);\r\npm_runtime_enable(phy->dev);\r\ngeneric_phy = devm_phy_create(phy->dev, NULL, &ops);\r\nif (IS_ERR(generic_phy)) {\r\npm_runtime_disable(phy->dev);\r\nreturn PTR_ERR(generic_phy);\r\n}\r\nphy_set_drvdata(generic_phy, phy);\r\nomap_usb_power_off(generic_phy);\r\nphy_provider = devm_of_phy_provider_register(phy->dev,\r\nof_phy_simple_xlate);\r\nif (IS_ERR(phy_provider)) {\r\npm_runtime_disable(phy->dev);\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nphy->wkupclk = devm_clk_get(phy->dev, "wkupclk");\r\nif (IS_ERR(phy->wkupclk)) {\r\ndev_warn(&pdev->dev, "unable to get wkupclk, trying old name\n");\r\nphy->wkupclk = devm_clk_get(phy->dev, "usb_phy_cm_clk32k");\r\nif (IS_ERR(phy->wkupclk)) {\r\ndev_err(&pdev->dev, "unable to get usb_phy_cm_clk32k\n");\r\npm_runtime_disable(phy->dev);\r\nreturn PTR_ERR(phy->wkupclk);\r\n} else {\r\ndev_warn(&pdev->dev,\r\n"found usb_phy_cm_clk32k, please fix DTS\n");\r\n}\r\n}\r\nclk_prepare(phy->wkupclk);\r\nphy->optclk = devm_clk_get(phy->dev, "refclk");\r\nif (IS_ERR(phy->optclk)) {\r\ndev_dbg(&pdev->dev, "unable to get refclk, trying old name\n");\r\nphy->optclk = devm_clk_get(phy->dev, "usb_otg_ss_refclk960m");\r\nif (IS_ERR(phy->optclk)) {\r\ndev_dbg(&pdev->dev,\r\n"unable to get usb_otg_ss_refclk960m\n");\r\n} else {\r\ndev_warn(&pdev->dev,\r\n"found usb_otg_ss_refclk960m, please fix DTS\n");\r\n}\r\n}\r\nif (!IS_ERR(phy->optclk))\r\nclk_prepare(phy->optclk);\r\nusb_add_phy_dev(&phy->phy);\r\nreturn 0;\r\n}\r\nstatic int omap_usb2_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_usb *phy = platform_get_drvdata(pdev);\r\nclk_unprepare(phy->wkupclk);\r\nif (!IS_ERR(phy->optclk))\r\nclk_unprepare(phy->optclk);\r\nusb_remove_phy(&phy->phy);\r\npm_runtime_disable(phy->dev);\r\nreturn 0;\r\n}
