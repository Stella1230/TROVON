static bool ir_pre_enabled(struct intel_iommu *iommu)\r\n{\r\nreturn (iommu->flags & VTD_FLAG_IRQ_REMAP_PRE_ENABLED);\r\n}\r\nstatic void clear_ir_pre_enabled(struct intel_iommu *iommu)\r\n{\r\niommu->flags &= ~VTD_FLAG_IRQ_REMAP_PRE_ENABLED;\r\n}\r\nstatic void init_ir_status(struct intel_iommu *iommu)\r\n{\r\nu32 gsts;\r\ngsts = readl(iommu->reg + DMAR_GSTS_REG);\r\nif (gsts & DMA_GSTS_IRES)\r\niommu->flags |= VTD_FLAG_IRQ_REMAP_PRE_ENABLED;\r\n}\r\nstatic int alloc_irte(struct intel_iommu *iommu, int irq,\r\nstruct irq_2_iommu *irq_iommu, u16 count)\r\n{\r\nstruct ir_table *table = iommu->ir_table;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nint index;\r\nif (!count || !irq_iommu)\r\nreturn -1;\r\nif (count > 1) {\r\ncount = __roundup_pow_of_two(count);\r\nmask = ilog2(count);\r\n}\r\nif (mask > ecap_max_handle_mask(iommu->ecap)) {\r\npr_err("Requested mask %x exceeds the max invalidation handle"\r\n" mask value %Lx\n", mask,\r\necap_max_handle_mask(iommu->ecap));\r\nreturn -1;\r\n}\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nindex = bitmap_find_free_region(table->bitmap,\r\nINTR_REMAP_TABLE_ENTRIES, mask);\r\nif (index < 0) {\r\npr_warn("IR%d: can't allocate an IRTE\n", iommu->seq_id);\r\n} else {\r\nirq_iommu->iommu = iommu;\r\nirq_iommu->irte_index = index;\r\nirq_iommu->sub_handle = 0;\r\nirq_iommu->irte_mask = mask;\r\nirq_iommu->mode = IRQ_REMAPPING;\r\n}\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn index;\r\n}\r\nstatic int qi_flush_iec(struct intel_iommu *iommu, int index, int mask)\r\n{\r\nstruct qi_desc desc;\r\ndesc.low = QI_IEC_IIDEX(index) | QI_IEC_TYPE | QI_IEC_IM(mask)\r\n| QI_IEC_SELECTIVE;\r\ndesc.high = 0;\r\nreturn qi_submit_sync(&desc, iommu);\r\n}\r\nstatic int modify_irte(struct irq_2_iommu *irq_iommu,\r\nstruct irte *irte_modified)\r\n{\r\nstruct intel_iommu *iommu;\r\nunsigned long flags;\r\nstruct irte *irte;\r\nint rc, index;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\nirte = &iommu->ir_table->base[index];\r\n#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE)\r\nif ((irte->pst == 1) || (irte_modified->pst == 1)) {\r\nbool ret;\r\nret = cmpxchg_double(&irte->low, &irte->high,\r\nirte->low, irte->high,\r\nirte_modified->low, irte_modified->high);\r\nWARN_ON(!ret);\r\n} else\r\n#endif\r\n{\r\nset_64bit(&irte->low, irte_modified->low);\r\nset_64bit(&irte->high, irte_modified->high);\r\n}\r\n__iommu_flush_cache(iommu, irte, sizeof(*irte));\r\nrc = qi_flush_iec(iommu, index, 0);\r\nirq_iommu->mode = irte->pst ? IRQ_POSTING : IRQ_REMAPPING;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn rc;\r\n}\r\nstatic struct intel_iommu *map_hpet_to_ir(u8 hpet_id)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_HPET_TBS; i++)\r\nif (ir_hpet[i].id == hpet_id && ir_hpet[i].iommu)\r\nreturn ir_hpet[i].iommu;\r\nreturn NULL;\r\n}\r\nstatic struct intel_iommu *map_ioapic_to_ir(int apic)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_IO_APICS; i++)\r\nif (ir_ioapic[i].id == apic && ir_ioapic[i].iommu)\r\nreturn ir_ioapic[i].iommu;\r\nreturn NULL;\r\n}\r\nstatic struct intel_iommu *map_dev_to_ir(struct pci_dev *dev)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\ndrhd = dmar_find_matched_drhd_unit(dev);\r\nif (!drhd)\r\nreturn NULL;\r\nreturn drhd->iommu;\r\n}\r\nstatic int clear_entries(struct irq_2_iommu *irq_iommu)\r\n{\r\nstruct irte *start, *entry, *end;\r\nstruct intel_iommu *iommu;\r\nint index;\r\nif (irq_iommu->sub_handle)\r\nreturn 0;\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index;\r\nstart = iommu->ir_table->base + index;\r\nend = start + (1 << irq_iommu->irte_mask);\r\nfor (entry = start; entry < end; entry++) {\r\nset_64bit(&entry->low, 0);\r\nset_64bit(&entry->high, 0);\r\n}\r\nbitmap_release_region(iommu->ir_table->bitmap, index,\r\nirq_iommu->irte_mask);\r\nreturn qi_flush_iec(iommu, index, irq_iommu->irte_mask);\r\n}\r\nstatic void set_irte_sid(struct irte *irte, unsigned int svt,\r\nunsigned int sq, unsigned int sid)\r\n{\r\nif (disable_sourceid_checking)\r\nsvt = SVT_NO_VERIFY;\r\nirte->svt = svt;\r\nirte->sq = sq;\r\nirte->sid = sid;\r\n}\r\nstatic int set_ioapic_sid(struct irte *irte, int apic)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\ndown_read(&dmar_global_lock);\r\nfor (i = 0; i < MAX_IO_APICS; i++) {\r\nif (ir_ioapic[i].iommu && ir_ioapic[i].id == apic) {\r\nsid = (ir_ioapic[i].bus << 8) | ir_ioapic[i].devfn;\r\nbreak;\r\n}\r\n}\r\nup_read(&dmar_global_lock);\r\nif (sid == 0) {\r\npr_warn("Failed to set source-id of IOAPIC (%d)\n", apic);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16, sid);\r\nreturn 0;\r\n}\r\nstatic int set_hpet_sid(struct irte *irte, u8 id)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\ndown_read(&dmar_global_lock);\r\nfor (i = 0; i < MAX_HPET_TBS; i++) {\r\nif (ir_hpet[i].iommu && ir_hpet[i].id == id) {\r\nsid = (ir_hpet[i].bus << 8) | ir_hpet[i].devfn;\r\nbreak;\r\n}\r\n}\r\nup_read(&dmar_global_lock);\r\nif (sid == 0) {\r\npr_warn("Failed to set source-id of HPET block (%d)\n", id);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_13_IGNORE_3, sid);\r\nreturn 0;\r\n}\r\nstatic int set_msi_sid_cb(struct pci_dev *pdev, u16 alias, void *opaque)\r\n{\r\nstruct set_msi_sid_data *data = opaque;\r\ndata->pdev = pdev;\r\ndata->alias = alias;\r\nreturn 0;\r\n}\r\nstatic int set_msi_sid(struct irte *irte, struct pci_dev *dev)\r\n{\r\nstruct set_msi_sid_data data;\r\nif (!irte || !dev)\r\nreturn -1;\r\npci_for_each_dma_alias(dev, set_msi_sid_cb, &data);\r\nif (PCI_BUS_NUM(data.alias) != data.pdev->bus->number)\r\nset_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,\r\nPCI_DEVID(PCI_BUS_NUM(data.alias),\r\ndev->bus->number));\r\nelse if (data.pdev->bus->number != dev->bus->number)\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16, data.alias);\r\nelse\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\r\nPCI_DEVID(dev->bus->number, dev->devfn));\r\nreturn 0;\r\n}\r\nstatic int iommu_load_old_irte(struct intel_iommu *iommu)\r\n{\r\nstruct irte *old_ir_table;\r\nphys_addr_t irt_phys;\r\nunsigned int i;\r\nsize_t size;\r\nu64 irta;\r\nif (!is_kdump_kernel()) {\r\npr_warn("IRQ remapping was enabled on %s but we are not in kdump mode\n",\r\niommu->name);\r\nclear_ir_pre_enabled(iommu);\r\niommu_disable_irq_remapping(iommu);\r\nreturn -EINVAL;\r\n}\r\nirta = dmar_readq(iommu->reg + DMAR_IRTA_REG);\r\nif ((irta & INTR_REMAP_TABLE_REG_SIZE_MASK)\r\n!= INTR_REMAP_TABLE_REG_SIZE)\r\nreturn -EINVAL;\r\nirt_phys = irta & VTD_PAGE_MASK;\r\nsize = INTR_REMAP_TABLE_ENTRIES*sizeof(struct irte);\r\nold_ir_table = memremap(irt_phys, size, MEMREMAP_WB);\r\nif (!old_ir_table)\r\nreturn -ENOMEM;\r\nmemcpy(iommu->ir_table->base, old_ir_table, size);\r\n__iommu_flush_cache(iommu, iommu->ir_table->base, size);\r\nfor (i = 0; i < INTR_REMAP_TABLE_ENTRIES; i++) {\r\nif (iommu->ir_table->base[i].present)\r\nbitmap_set(iommu->ir_table->bitmap, i, 1);\r\n}\r\nmemunmap(old_ir_table);\r\nreturn 0;\r\n}\r\nstatic void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)\r\n{\r\nunsigned long flags;\r\nu64 addr;\r\nu32 sts;\r\naddr = virt_to_phys((void *)iommu->ir_table->base);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\ndmar_writeq(iommu->reg + DMAR_IRTA_REG,\r\n(addr) | IR_X2APIC_MODE(mode) | INTR_REMAP_TABLE_REG_SIZE);\r\nwritel(iommu->gcmd | DMA_GCMD_SIRTP, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRTPS), sts);\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\nqi_global_iec(iommu);\r\n}\r\nstatic void iommu_enable_irq_remapping(struct intel_iommu *iommu)\r\n{\r\nunsigned long flags;\r\nu32 sts;\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\niommu->gcmd |= DMA_GCMD_IRE;\r\niommu->gcmd &= ~DMA_GCMD_CFI;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRES), sts);\r\nif (sts & DMA_GSTS_CFIS)\r\nWARN(1, KERN_WARNING\r\n"Compatibility-format IRQs enabled despite intr remapping;\n"\r\n"you are vulnerable to IRQ injection.\n");\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int intel_setup_irq_remapping(struct intel_iommu *iommu)\r\n{\r\nstruct ir_table *ir_table;\r\nstruct page *pages;\r\nunsigned long *bitmap;\r\nif (iommu->ir_table)\r\nreturn 0;\r\nir_table = kzalloc(sizeof(struct ir_table), GFP_KERNEL);\r\nif (!ir_table)\r\nreturn -ENOMEM;\r\npages = alloc_pages_node(iommu->node, GFP_KERNEL | __GFP_ZERO,\r\nINTR_REMAP_PAGE_ORDER);\r\nif (!pages) {\r\npr_err("IR%d: failed to allocate pages of order %d\n",\r\niommu->seq_id, INTR_REMAP_PAGE_ORDER);\r\ngoto out_free_table;\r\n}\r\nbitmap = kcalloc(BITS_TO_LONGS(INTR_REMAP_TABLE_ENTRIES),\r\nsizeof(long), GFP_ATOMIC);\r\nif (bitmap == NULL) {\r\npr_err("IR%d: failed to allocate bitmap\n", iommu->seq_id);\r\ngoto out_free_pages;\r\n}\r\niommu->ir_domain = irq_domain_add_hierarchy(arch_get_ir_parent_domain(),\r\n0, INTR_REMAP_TABLE_ENTRIES,\r\nNULL, &intel_ir_domain_ops,\r\niommu);\r\nif (!iommu->ir_domain) {\r\npr_err("IR%d: failed to allocate irqdomain\n", iommu->seq_id);\r\ngoto out_free_bitmap;\r\n}\r\niommu->ir_msi_domain = arch_create_msi_irq_domain(iommu->ir_domain);\r\nir_table->base = page_address(pages);\r\nir_table->bitmap = bitmap;\r\niommu->ir_table = ir_table;\r\nif (!iommu->qi) {\r\ndmar_fault(-1, iommu);\r\ndmar_disable_qi(iommu);\r\nif (dmar_enable_qi(iommu)) {\r\npr_err("Failed to enable queued invalidation\n");\r\ngoto out_free_bitmap;\r\n}\r\n}\r\ninit_ir_status(iommu);\r\nif (ir_pre_enabled(iommu)) {\r\nif (iommu_load_old_irte(iommu))\r\npr_err("Failed to copy IR table for %s from previous kernel\n",\r\niommu->name);\r\nelse\r\npr_info("Copied IR table for %s from previous kernel\n",\r\niommu->name);\r\n}\r\niommu_set_irq_remapping(iommu, eim_mode);\r\nreturn 0;\r\nout_free_bitmap:\r\nkfree(bitmap);\r\nout_free_pages:\r\n__free_pages(pages, INTR_REMAP_PAGE_ORDER);\r\nout_free_table:\r\nkfree(ir_table);\r\niommu->ir_table = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void intel_teardown_irq_remapping(struct intel_iommu *iommu)\r\n{\r\nif (iommu && iommu->ir_table) {\r\nif (iommu->ir_msi_domain) {\r\nirq_domain_remove(iommu->ir_msi_domain);\r\niommu->ir_msi_domain = NULL;\r\n}\r\nif (iommu->ir_domain) {\r\nirq_domain_remove(iommu->ir_domain);\r\niommu->ir_domain = NULL;\r\n}\r\nfree_pages((unsigned long)iommu->ir_table->base,\r\nINTR_REMAP_PAGE_ORDER);\r\nkfree(iommu->ir_table->bitmap);\r\nkfree(iommu->ir_table);\r\niommu->ir_table = NULL;\r\n}\r\n}\r\nstatic void iommu_disable_irq_remapping(struct intel_iommu *iommu)\r\n{\r\nunsigned long flags;\r\nu32 sts;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn;\r\nqi_global_iec(iommu);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\nsts = readl(iommu->reg + DMAR_GSTS_REG);\r\nif (!(sts & DMA_GSTS_IRES))\r\ngoto end;\r\niommu->gcmd &= ~DMA_GCMD_IRE;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, !(sts & DMA_GSTS_IRES), sts);\r\nend:\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int __init dmar_x2apic_optout(void)\r\n{\r\nstruct acpi_table_dmar *dmar;\r\ndmar = (struct acpi_table_dmar *)dmar_tbl;\r\nif (!dmar || no_x2apic_optout)\r\nreturn 0;\r\nreturn dmar->flags & DMAR_X2APIC_OPT_OUT;\r\n}\r\nstatic void __init intel_cleanup_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu;\r\nfor_each_iommu(iommu, drhd) {\r\nif (ecap_ir_support(iommu->ecap)) {\r\niommu_disable_irq_remapping(iommu);\r\nintel_teardown_irq_remapping(iommu);\r\n}\r\n}\r\nif (x2apic_supported())\r\npr_warn("Failed to enable irq remapping. You are vulnerable to irq-injection attacks.\n");\r\n}\r\nstatic int __init intel_prepare_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu;\r\nint eim = 0;\r\nif (irq_remap_broken) {\r\npr_warn("This system BIOS has enabled interrupt remapping\n"\r\n"on a chipset that contains an erratum making that\n"\r\n"feature unstable. To maintain system stability\n"\r\n"interrupt remapping is being disabled. Please\n"\r\n"contact your BIOS vendor for an update\n");\r\nadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\r\nreturn -ENODEV;\r\n}\r\nif (dmar_table_init() < 0)\r\nreturn -ENODEV;\r\nif (!dmar_ir_support())\r\nreturn -ENODEV;\r\nif (parse_ioapics_under_ir()) {\r\npr_info("Not enabling interrupt remapping\n");\r\ngoto error;\r\n}\r\nfor_each_iommu(iommu, drhd)\r\nif (!ecap_ir_support(iommu->ecap))\r\ngoto error;\r\nif (x2apic_supported()) {\r\neim = !dmar_x2apic_optout();\r\nif (!eim) {\r\npr_info("x2apic is disabled because BIOS sets x2apic opt out bit.");\r\npr_info("Use 'intremap=no_x2apic_optout' to override the BIOS setting.\n");\r\n}\r\n}\r\nfor_each_iommu(iommu, drhd) {\r\nif (eim && !ecap_eim_support(iommu->ecap)) {\r\npr_info("%s does not support EIM\n", iommu->name);\r\neim = 0;\r\n}\r\n}\r\neim_mode = eim;\r\nif (eim)\r\npr_info("Queued invalidation will be enabled to support x2apic and Intr-remapping.\n");\r\nfor_each_iommu(iommu, drhd) {\r\nif (intel_setup_irq_remapping(iommu)) {\r\npr_err("Failed to setup irq remapping for %s\n",\r\niommu->name);\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nintel_cleanup_irq_remapping();\r\nreturn -ENODEV;\r\n}\r\nstatic inline void set_irq_posting_cap(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu;\r\nif (!disable_irq_post) {\r\nif (boot_cpu_has(X86_FEATURE_CX16))\r\nintel_irq_remap_ops.capability |= 1 << IRQ_POSTING_CAP;\r\nfor_each_iommu(iommu, drhd)\r\nif (!cap_pi_support(iommu->cap)) {\r\nintel_irq_remap_ops.capability &=\r\n~(1 << IRQ_POSTING_CAP);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int __init intel_enable_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu;\r\nbool setup = false;\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ir_pre_enabled(iommu))\r\niommu_enable_irq_remapping(iommu);\r\nsetup = true;\r\n}\r\nif (!setup)\r\ngoto error;\r\nirq_remapping_enabled = 1;\r\nset_irq_posting_cap();\r\npr_info("Enabled IRQ remapping in %s mode\n", eim_mode ? "x2apic" : "xapic");\r\nreturn eim_mode ? IRQ_REMAP_X2APIC_MODE : IRQ_REMAP_XAPIC_MODE;\r\nerror:\r\nintel_cleanup_irq_remapping();\r\nreturn -1;\r\n}\r\nstatic int ir_parse_one_hpet_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu,\r\nstruct acpi_dmar_hardware_unit *drhd)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count, free = -1;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->device, path->function,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nfor (count = 0; count < MAX_HPET_TBS; count++) {\r\nif (ir_hpet[count].iommu == iommu &&\r\nir_hpet[count].id == scope->enumeration_id)\r\nreturn 0;\r\nelse if (ir_hpet[count].iommu == NULL && free == -1)\r\nfree = count;\r\n}\r\nif (free == -1) {\r\npr_warn("Exceeded Max HPET blocks\n");\r\nreturn -ENOSPC;\r\n}\r\nir_hpet[free].iommu = iommu;\r\nir_hpet[free].id = scope->enumeration_id;\r\nir_hpet[free].bus = bus;\r\nir_hpet[free].devfn = PCI_DEVFN(path->device, path->function);\r\npr_info("HPET id %d under DRHD base 0x%Lx\n",\r\nscope->enumeration_id, drhd->address);\r\nreturn 0;\r\n}\r\nstatic int ir_parse_one_ioapic_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu,\r\nstruct acpi_dmar_hardware_unit *drhd)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count, free = -1;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->device, path->function,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nfor (count = 0; count < MAX_IO_APICS; count++) {\r\nif (ir_ioapic[count].iommu == iommu &&\r\nir_ioapic[count].id == scope->enumeration_id)\r\nreturn 0;\r\nelse if (ir_ioapic[count].iommu == NULL && free == -1)\r\nfree = count;\r\n}\r\nif (free == -1) {\r\npr_warn("Exceeded Max IO APICS\n");\r\nreturn -ENOSPC;\r\n}\r\nir_ioapic[free].bus = bus;\r\nir_ioapic[free].devfn = PCI_DEVFN(path->device, path->function);\r\nir_ioapic[free].iommu = iommu;\r\nir_ioapic[free].id = scope->enumeration_id;\r\npr_info("IOAPIC id %d under DRHD base 0x%Lx IOMMU %d\n",\r\nscope->enumeration_id, drhd->address, iommu->seq_id);\r\nreturn 0;\r\n}\r\nstatic int ir_parse_ioapic_hpet_scope(struct acpi_dmar_header *header,\r\nstruct intel_iommu *iommu)\r\n{\r\nint ret = 0;\r\nstruct acpi_dmar_hardware_unit *drhd;\r\nstruct acpi_dmar_device_scope *scope;\r\nvoid *start, *end;\r\ndrhd = (struct acpi_dmar_hardware_unit *)header;\r\nstart = (void *)(drhd + 1);\r\nend = ((void *)drhd) + header->length;\r\nwhile (start < end && ret == 0) {\r\nscope = start;\r\nif (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC)\r\nret = ir_parse_one_ioapic_scope(scope, iommu, drhd);\r\nelse if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_HPET)\r\nret = ir_parse_one_hpet_scope(scope, iommu, drhd);\r\nstart += scope->length;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ir_remove_ioapic_hpet_scope(struct intel_iommu *iommu)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_HPET_TBS; i++)\r\nif (ir_hpet[i].iommu == iommu)\r\nir_hpet[i].iommu = NULL;\r\nfor (i = 0; i < MAX_IO_APICS; i++)\r\nif (ir_ioapic[i].iommu == iommu)\r\nir_ioapic[i].iommu = NULL;\r\n}\r\nstatic int __init parse_ioapics_under_ir(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu;\r\nbool ir_supported = false;\r\nint ioapic_idx;\r\nfor_each_iommu(iommu, drhd) {\r\nint ret;\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\nret = ir_parse_ioapic_hpet_scope(drhd->hdr, iommu);\r\nif (ret)\r\nreturn ret;\r\nir_supported = true;\r\n}\r\nif (!ir_supported)\r\nreturn -ENODEV;\r\nfor (ioapic_idx = 0; ioapic_idx < nr_ioapics; ioapic_idx++) {\r\nint ioapic_id = mpc_ioapic_id(ioapic_idx);\r\nif (!map_ioapic_to_ir(ioapic_id)) {\r\npr_err(FW_BUG "ioapic %d has no mapping iommu, "\r\n"interrupt remapping will be disabled\n",\r\nioapic_id);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ir_dev_scope_init(void)\r\n{\r\nint ret;\r\nif (!irq_remapping_enabled)\r\nreturn 0;\r\ndown_write(&dmar_global_lock);\r\nret = dmar_dev_scope_init();\r\nup_write(&dmar_global_lock);\r\nreturn ret;\r\n}\r\nstatic void disable_irq_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_disable_irq_remapping(iommu);\r\n}\r\nif (!disable_irq_post)\r\nintel_irq_remap_ops.capability &= ~(1 << IRQ_POSTING_CAP);\r\n}\r\nstatic int reenable_irq_remapping(int eim)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nbool setup = false;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd)\r\nif (iommu->qi)\r\ndmar_reenable_qi(iommu);\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_set_irq_remapping(iommu, eim);\r\niommu_enable_irq_remapping(iommu);\r\nsetup = true;\r\n}\r\nif (!setup)\r\ngoto error;\r\nset_irq_posting_cap();\r\nreturn 0;\r\nerror:\r\nreturn -1;\r\n}\r\nstatic void prepare_irte(struct irte *irte, int vector, unsigned int dest)\r\n{\r\nmemset(irte, 0, sizeof(*irte));\r\nirte->present = 1;\r\nirte->dst_mode = apic->irq_dest_mode;\r\nirte->trigger_mode = 0;\r\nirte->dlvry_mode = apic->irq_delivery_mode;\r\nirte->vector = vector;\r\nirte->dest_id = IRTE_DEST(dest);\r\nirte->redir_hint = 1;\r\n}\r\nstatic struct irq_domain *intel_get_ir_irq_domain(struct irq_alloc_info *info)\r\n{\r\nstruct intel_iommu *iommu = NULL;\r\nif (!info)\r\nreturn NULL;\r\nswitch (info->type) {\r\ncase X86_IRQ_ALLOC_TYPE_IOAPIC:\r\niommu = map_ioapic_to_ir(info->ioapic_id);\r\nbreak;\r\ncase X86_IRQ_ALLOC_TYPE_HPET:\r\niommu = map_hpet_to_ir(info->hpet_id);\r\nbreak;\r\ncase X86_IRQ_ALLOC_TYPE_MSI:\r\ncase X86_IRQ_ALLOC_TYPE_MSIX:\r\niommu = map_dev_to_ir(info->msi_dev);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nreturn iommu ? iommu->ir_domain : NULL;\r\n}\r\nstatic struct irq_domain *intel_get_irq_domain(struct irq_alloc_info *info)\r\n{\r\nstruct intel_iommu *iommu;\r\nif (!info)\r\nreturn NULL;\r\nswitch (info->type) {\r\ncase X86_IRQ_ALLOC_TYPE_MSI:\r\ncase X86_IRQ_ALLOC_TYPE_MSIX:\r\niommu = map_dev_to_ir(info->msi_dev);\r\nif (iommu)\r\nreturn iommu->ir_msi_domain;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nintel_ir_set_affinity(struct irq_data *data, const struct cpumask *mask,\r\nbool force)\r\n{\r\nstruct intel_ir_data *ir_data = data->chip_data;\r\nstruct irte *irte = &ir_data->irte_entry;\r\nstruct irq_cfg *cfg = irqd_cfg(data);\r\nstruct irq_data *parent = data->parent_data;\r\nint ret;\r\nret = parent->chip->irq_set_affinity(parent, mask, force);\r\nif (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)\r\nreturn ret;\r\nirte->vector = cfg->vector;\r\nirte->dest_id = IRTE_DEST(cfg->dest_apicid);\r\nif (ir_data->irq_2_iommu.mode == IRQ_REMAPPING)\r\nmodify_irte(&ir_data->irq_2_iommu, irte);\r\nsend_cleanup_vector(cfg);\r\nreturn IRQ_SET_MASK_OK_DONE;\r\n}\r\nstatic void intel_ir_compose_msi_msg(struct irq_data *irq_data,\r\nstruct msi_msg *msg)\r\n{\r\nstruct intel_ir_data *ir_data = irq_data->chip_data;\r\n*msg = ir_data->msi_entry;\r\n}\r\nstatic int intel_ir_set_vcpu_affinity(struct irq_data *data, void *info)\r\n{\r\nstruct intel_ir_data *ir_data = data->chip_data;\r\nstruct vcpu_data *vcpu_pi_info = info;\r\nif (!vcpu_pi_info) {\r\nmodify_irte(&ir_data->irq_2_iommu, &ir_data->irte_entry);\r\n} else {\r\nstruct irte irte_pi;\r\nmemset(&irte_pi, 0, sizeof(irte_pi));\r\ndmar_copy_shared_irte(&irte_pi, &ir_data->irte_entry);\r\nirte_pi.p_pst = 1;\r\nirte_pi.p_urgent = 0;\r\nirte_pi.p_vector = vcpu_pi_info->vector;\r\nirte_pi.pda_l = (vcpu_pi_info->pi_desc_addr >>\r\n(32 - PDA_LOW_BIT)) & ~(-1UL << PDA_LOW_BIT);\r\nirte_pi.pda_h = (vcpu_pi_info->pi_desc_addr >> 32) &\r\n~(-1UL << PDA_HIGH_BIT);\r\nmodify_irte(&ir_data->irq_2_iommu, &irte_pi);\r\n}\r\nreturn 0;\r\n}\r\nstatic void intel_irq_remapping_prepare_irte(struct intel_ir_data *data,\r\nstruct irq_cfg *irq_cfg,\r\nstruct irq_alloc_info *info,\r\nint index, int sub_handle)\r\n{\r\nstruct IR_IO_APIC_route_entry *entry;\r\nstruct irte *irte = &data->irte_entry;\r\nstruct msi_msg *msg = &data->msi_entry;\r\nprepare_irte(irte, irq_cfg->vector, irq_cfg->dest_apicid);\r\nswitch (info->type) {\r\ncase X86_IRQ_ALLOC_TYPE_IOAPIC:\r\nset_ioapic_sid(irte, info->ioapic_id);\r\napic_printk(APIC_VERBOSE, KERN_DEBUG "IOAPIC[%d]: Set IRTE entry (P:%d FPD:%d Dst_Mode:%d Redir_hint:%d Trig_Mode:%d Dlvry_Mode:%X Avail:%X Vector:%02X Dest:%08X SID:%04X SQ:%X SVT:%X)\n",\r\ninfo->ioapic_id, irte->present, irte->fpd,\r\nirte->dst_mode, irte->redir_hint,\r\nirte->trigger_mode, irte->dlvry_mode,\r\nirte->avail, irte->vector, irte->dest_id,\r\nirte->sid, irte->sq, irte->svt);\r\nentry = (struct IR_IO_APIC_route_entry *)info->ioapic_entry;\r\ninfo->ioapic_entry = NULL;\r\nmemset(entry, 0, sizeof(*entry));\r\nentry->index2 = (index >> 15) & 0x1;\r\nentry->zero = 0;\r\nentry->format = 1;\r\nentry->index = (index & 0x7fff);\r\nentry->vector = info->ioapic_pin;\r\nentry->mask = 0;\r\nentry->trigger = info->ioapic_trigger;\r\nentry->polarity = info->ioapic_polarity;\r\nif (info->ioapic_trigger)\r\nentry->mask = 1;\r\nbreak;\r\ncase X86_IRQ_ALLOC_TYPE_HPET:\r\ncase X86_IRQ_ALLOC_TYPE_MSI:\r\ncase X86_IRQ_ALLOC_TYPE_MSIX:\r\nif (info->type == X86_IRQ_ALLOC_TYPE_HPET)\r\nset_hpet_sid(irte, info->hpet_id);\r\nelse\r\nset_msi_sid(irte, info->msi_dev);\r\nmsg->address_hi = MSI_ADDR_BASE_HI;\r\nmsg->data = sub_handle;\r\nmsg->address_lo = MSI_ADDR_BASE_LO | MSI_ADDR_IR_EXT_INT |\r\nMSI_ADDR_IR_SHV |\r\nMSI_ADDR_IR_INDEX1(index) |\r\nMSI_ADDR_IR_INDEX2(index);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void intel_free_irq_resources(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nstruct irq_data *irq_data;\r\nstruct intel_ir_data *data;\r\nstruct irq_2_iommu *irq_iommu;\r\nunsigned long flags;\r\nint i;\r\nfor (i = 0; i < nr_irqs; i++) {\r\nirq_data = irq_domain_get_irq_data(domain, virq + i);\r\nif (irq_data && irq_data->chip_data) {\r\ndata = irq_data->chip_data;\r\nirq_iommu = &data->irq_2_iommu;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nclear_entries(irq_iommu);\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nirq_domain_reset_irq_data(irq_data);\r\nkfree(data);\r\n}\r\n}\r\n}\r\nstatic int intel_irq_remapping_alloc(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs,\r\nvoid *arg)\r\n{\r\nstruct intel_iommu *iommu = domain->host_data;\r\nstruct irq_alloc_info *info = arg;\r\nstruct intel_ir_data *data, *ird;\r\nstruct irq_data *irq_data;\r\nstruct irq_cfg *irq_cfg;\r\nint i, ret, index;\r\nif (!info || !iommu)\r\nreturn -EINVAL;\r\nif (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_MSI &&\r\ninfo->type != X86_IRQ_ALLOC_TYPE_MSIX)\r\nreturn -EINVAL;\r\nif (info->type == X86_IRQ_ALLOC_TYPE_MSI)\r\ninfo->flags &= ~X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;\r\nret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto out_free_parent;\r\ndown_read(&dmar_global_lock);\r\nindex = alloc_irte(iommu, virq, &data->irq_2_iommu, nr_irqs);\r\nup_read(&dmar_global_lock);\r\nif (index < 0) {\r\npr_warn("Failed to allocate IRTE\n");\r\nkfree(data);\r\ngoto out_free_parent;\r\n}\r\nfor (i = 0; i < nr_irqs; i++) {\r\nirq_data = irq_domain_get_irq_data(domain, virq + i);\r\nirq_cfg = irqd_cfg(irq_data);\r\nif (!irq_data || !irq_cfg) {\r\nret = -EINVAL;\r\ngoto out_free_data;\r\n}\r\nif (i > 0) {\r\nird = kzalloc(sizeof(*ird), GFP_KERNEL);\r\nif (!ird)\r\ngoto out_free_data;\r\nird->irq_2_iommu = data->irq_2_iommu;\r\nird->irq_2_iommu.sub_handle = i;\r\n} else {\r\nird = data;\r\n}\r\nirq_data->hwirq = (index << 16) + i;\r\nirq_data->chip_data = ird;\r\nirq_data->chip = &intel_ir_chip;\r\nintel_irq_remapping_prepare_irte(ird, irq_cfg, info, index, i);\r\nirq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);\r\n}\r\nreturn 0;\r\nout_free_data:\r\nintel_free_irq_resources(domain, virq, i);\r\nout_free_parent:\r\nirq_domain_free_irqs_common(domain, virq, nr_irqs);\r\nreturn ret;\r\n}\r\nstatic void intel_irq_remapping_free(struct irq_domain *domain,\r\nunsigned int virq, unsigned int nr_irqs)\r\n{\r\nintel_free_irq_resources(domain, virq, nr_irqs);\r\nirq_domain_free_irqs_common(domain, virq, nr_irqs);\r\n}\r\nstatic void intel_irq_remapping_activate(struct irq_domain *domain,\r\nstruct irq_data *irq_data)\r\n{\r\nstruct intel_ir_data *data = irq_data->chip_data;\r\nmodify_irte(&data->irq_2_iommu, &data->irte_entry);\r\n}\r\nstatic void intel_irq_remapping_deactivate(struct irq_domain *domain,\r\nstruct irq_data *irq_data)\r\n{\r\nstruct intel_ir_data *data = irq_data->chip_data;\r\nstruct irte entry;\r\nmemset(&entry, 0, sizeof(entry));\r\nmodify_irte(&data->irq_2_iommu, &entry);\r\n}\r\nstatic int dmar_ir_add(struct dmar_drhd_unit *dmaru, struct intel_iommu *iommu)\r\n{\r\nint ret;\r\nint eim = x2apic_enabled();\r\nif (eim && !ecap_eim_support(iommu->ecap)) {\r\npr_info("DRHD %Lx: EIM not supported by DRHD, ecap %Lx\n",\r\niommu->reg_phys, iommu->ecap);\r\nreturn -ENODEV;\r\n}\r\nif (ir_parse_ioapic_hpet_scope(dmaru->hdr, iommu)) {\r\npr_warn("DRHD %Lx: failed to parse managed IOAPIC/HPET\n",\r\niommu->reg_phys);\r\nreturn -ENODEV;\r\n}\r\nret = intel_setup_irq_remapping(iommu);\r\nif (ret) {\r\npr_err("Failed to setup irq remapping for %s\n",\r\niommu->name);\r\nintel_teardown_irq_remapping(iommu);\r\nir_remove_ioapic_hpet_scope(iommu);\r\n} else {\r\niommu_enable_irq_remapping(iommu);\r\n}\r\nreturn ret;\r\n}\r\nint dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert)\r\n{\r\nint ret = 0;\r\nstruct intel_iommu *iommu = dmaru->iommu;\r\nif (!irq_remapping_enabled)\r\nreturn 0;\r\nif (iommu == NULL)\r\nreturn -EINVAL;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn 0;\r\nif (irq_remapping_cap(IRQ_POSTING_CAP) &&\r\n!cap_pi_support(iommu->cap))\r\nreturn -EBUSY;\r\nif (insert) {\r\nif (!iommu->ir_table)\r\nret = dmar_ir_add(dmaru, iommu);\r\n} else {\r\nif (iommu->ir_table) {\r\nif (!bitmap_empty(iommu->ir_table->bitmap,\r\nINTR_REMAP_TABLE_ENTRIES)) {\r\nret = -EBUSY;\r\n} else {\r\niommu_disable_irq_remapping(iommu);\r\nintel_teardown_irq_remapping(iommu);\r\nir_remove_ioapic_hpet_scope(iommu);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}
