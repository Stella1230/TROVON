int mxl111sf_ctrl_msg(struct dvb_usb_device *d,\r\nu8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nint wo = (rbuf == NULL || rlen == 0);\r\nint ret;\r\nu8 sndbuf[MAX_XFER_SIZE];\r\nif (1 + wlen > sizeof(sndbuf)) {\r\npr_warn("%s: len=%d is too big!\n", __func__, wlen);\r\nreturn -EOPNOTSUPP;\r\n}\r\npr_debug("%s(wlen = %d, rlen = %d)\n", __func__, wlen, rlen);\r\nmemset(sndbuf, 0, 1+wlen);\r\nsndbuf[0] = cmd;\r\nmemcpy(&sndbuf[1], wbuf, wlen);\r\nret = (wo) ? dvb_usbv2_generic_write(d, sndbuf, 1+wlen) :\r\ndvb_usbv2_generic_rw(d, sndbuf, 1+wlen, rbuf, rlen);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}\r\nint mxl111sf_read_reg(struct mxl111sf_state *state, u8 addr, u8 *data)\r\n{\r\nu8 buf[2];\r\nint ret;\r\nret = mxl111sf_ctrl_msg(state->d, MXL_CMD_REG_READ, &addr, 1, buf, 2);\r\nif (mxl_fail(ret)) {\r\nmxl_debug("error reading reg: 0x%02x", addr);\r\ngoto fail;\r\n}\r\nif (buf[0] == addr)\r\n*data = buf[1];\r\nelse {\r\npr_err("invalid response reading reg: 0x%02x != 0x%02x, 0x%02x",\r\naddr, buf[0], buf[1]);\r\nret = -EINVAL;\r\n}\r\npr_debug("R: (0x%02x, 0x%02x)\n", addr, buf[1]);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_write_reg(struct mxl111sf_state *state, u8 addr, u8 data)\r\n{\r\nu8 buf[] = { addr, data };\r\nint ret;\r\npr_debug("W: (0x%02x, 0x%02x)\n", addr, data);\r\nret = mxl111sf_ctrl_msg(state->d, MXL_CMD_REG_WRITE, buf, 2, NULL, 0);\r\nif (mxl_fail(ret))\r\npr_err("error writing reg: 0x%02x, val: 0x%02x", addr, data);\r\nreturn ret;\r\n}\r\nint mxl111sf_write_reg_mask(struct mxl111sf_state *state,\r\nu8 addr, u8 mask, u8 data)\r\n{\r\nint ret;\r\nu8 val = 0;\r\nif (mask != 0xff) {\r\nret = mxl111sf_read_reg(state, addr, &val);\r\n#if 1\r\nif (mxl_fail(ret))\r\npr_err("error writing addr: 0x%02x, mask: 0x%02x, data: 0x%02x, retrying...",\r\naddr, mask, data);\r\nret = mxl111sf_read_reg(state, addr, &val);\r\n#endif\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n}\r\nval &= ~mask;\r\nval |= data;\r\nret = mxl111sf_write_reg(state, addr, val);\r\nmxl_fail(ret);\r\nfail:\r\nreturn ret;\r\n}\r\nint mxl111sf_ctrl_program_regs(struct mxl111sf_state *state,\r\nstruct mxl111sf_reg_ctrl_info *ctrl_reg_info)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; ctrl_reg_info[i].addr |\r\nctrl_reg_info[i].mask |\r\nctrl_reg_info[i].data; i++) {\r\nret = mxl111sf_write_reg_mask(state,\r\nctrl_reg_info[i].addr,\r\nctrl_reg_info[i].mask,\r\nctrl_reg_info[i].data);\r\nif (mxl_fail(ret)) {\r\npr_err("failed on reg #%d (0x%02x)", i,\r\nctrl_reg_info[i].addr);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl1x1sf_get_chip_info(struct mxl111sf_state *state)\r\n{\r\nint ret;\r\nu8 id, ver;\r\nchar *mxl_chip, *mxl_rev;\r\nif ((state->chip_id) && (state->chip_ver))\r\nreturn 0;\r\nret = mxl111sf_read_reg(state, CHIP_ID_REG, &id);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->chip_id = id;\r\nret = mxl111sf_read_reg(state, TOP_CHIP_REV_ID_REG, &ver);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->chip_ver = ver;\r\nswitch (id) {\r\ncase 0x61:\r\nmxl_chip = "MxL101SF";\r\nbreak;\r\ncase 0x63:\r\nmxl_chip = "MxL111SF";\r\nbreak;\r\ndefault:\r\nmxl_chip = "UNKNOWN MxL1X1";\r\nbreak;\r\n}\r\nswitch (ver) {\r\ncase 0x36:\r\nstate->chip_rev = MXL111SF_V6;\r\nmxl_rev = "v6";\r\nbreak;\r\ncase 0x08:\r\nstate->chip_rev = MXL111SF_V8_100;\r\nmxl_rev = "v8_100";\r\nbreak;\r\ncase 0x18:\r\nstate->chip_rev = MXL111SF_V8_200;\r\nmxl_rev = "v8_200";\r\nbreak;\r\ndefault:\r\nstate->chip_rev = 0;\r\nmxl_rev = "UNKNOWN REVISION";\r\nbreak;\r\n}\r\npr_info("%s detected, %s (0x%x)", mxl_chip, mxl_rev, ver);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_adap_fe_init(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\r\nint err;\r\nif (!state->chip_id) {\r\nmxl_debug("driver not yet initialized, exit.");\r\ngoto fail;\r\n}\r\npr_debug("%s()\n", __func__);\r\nmutex_lock(&state->fe_lock);\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nerr = mxl1x1sf_soft_reset(state);\r\nmxl_fail(err);\r\nerr = mxl111sf_init_tuner_demod(state);\r\nmxl_fail(err);\r\nerr = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nmxl_fail(err);\r\nerr = mxl111sf_enable_usb_output(state);\r\nmxl_fail(err);\r\nerr = mxl1x1sf_top_master_ctrl(state, 1);\r\nmxl_fail(err);\r\nif ((MXL111SF_GPIO_MOD_DVBT != adap_state->gpio_mode) &&\r\n(state->chip_rev > MXL111SF_V6)) {\r\nmxl111sf_config_pin_mux_modes(state,\r\nPIN_MUX_TS_SPI_IN_MODE_1);\r\nmxl_fail(err);\r\n}\r\nerr = mxl111sf_init_port_expander(state);\r\nif (!mxl_fail(err)) {\r\nstate->gpio_mode = adap_state->gpio_mode;\r\nerr = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nmxl_fail(err);\r\n#if 0\r\nerr = fe->ops.init(fe);\r\n#endif\r\nmsleep(100);\r\n}\r\nreturn (adap_state->fe_init) ? adap_state->fe_init(fe) : 0;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int mxl111sf_adap_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\r\nint err;\r\nif (!state->chip_id) {\r\nmxl_debug("driver not yet initialized, exit.");\r\ngoto fail;\r\n}\r\npr_debug("%s()\n", __func__);\r\nerr = (adap_state->fe_sleep) ? adap_state->fe_sleep(fe) : 0;\r\nmutex_unlock(&state->fe_lock);\r\nreturn err;\r\nfail:\r\nreturn -ENODEV;\r\n}\r\nstatic int mxl111sf_ep6_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe->id];\r\nint ret = 0;\r\npr_debug("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\nret = mxl111sf_config_mpeg_in(state, 1, 1,\r\nadap_state->ep6_clockphase,\r\n0, 0);\r\nmxl_fail(ret);\r\n#if 0\r\n} else {\r\nret = mxl111sf_disable_656_port(state);\r\nmxl_fail(ret);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_ep5_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nint ret = 0;\r\npr_debug("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\nret = mxl111sf_init_i2s_port(state, 200);\r\nmxl_fail(ret);\r\nret = mxl111sf_config_i2s(state, 0, 15);\r\nmxl_fail(ret);\r\n} else {\r\nret = mxl111sf_disable_i2s_port(state);\r\nmxl_fail(ret);\r\n}\r\nif (state->chip_rev > MXL111SF_V6)\r\nret = mxl111sf_config_spi(state, onoff);\r\nmxl_fail(ret);\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_ep4_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nint ret = 0;\r\npr_debug("%s(%d)\n", __func__, onoff);\r\nif (onoff) {\r\nret = mxl111sf_enable_usb_output(state);\r\nmxl_fail(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lgdt3305_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_ATSC;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe[fe_id] = dvb_attach(lgdt3305_attach,\r\n&hauppauge_lgdt3305_config,\r\n&d->i2c_adap);\r\nif (adap->fe[fe_id]) {\r\nstate->num_frontends++;\r\nadap_state->fe_init = adap->fe[fe_id]->ops.init;\r\nadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\r\nadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2160_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe[fe_id] = dvb_attach(lg2160_attach,\r\n&hauppauge_lg2160_config,\r\n&d->i2c_adap);\r\nif (adap->fe[fe_id]) {\r\nstate->num_frontends++;\r\nadap_state->fe_init = adap->fe[fe_id]->ops.init;\r\nadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\r\nadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2161_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe[fe_id] = dvb_attach(lg2160_attach,\r\n(MXL111SF_V8_200 == state->chip_rev) ?\r\n&hauppauge_lg2161_1040_config :\r\n&hauppauge_lg2161_1019_config,\r\n&d->i2c_adap);\r\nif (adap->fe[fe_id]) {\r\nstate->num_frontends++;\r\nadap_state->fe_init = adap->fe[fe_id]->ops.init;\r\nadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\r\nadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_lg2161_ep6_frontend_attach(struct dvb_usb_adapter *adap, u8 fe_id)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 2 : 1;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_MH;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_TUNER_MODE;\r\nadap_state->ep6_clockphase = 0;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_port_expander(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_gpio_mode_switch(state, state->gpio_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nadap->fe[fe_id] = dvb_attach(lg2160_attach,\r\n(MXL111SF_V8_200 == state->chip_rev) ?\r\n&hauppauge_lg2161_1040_ep6_config :\r\n&hauppauge_lg2161_1019_ep6_config,\r\n&d->i2c_adap);\r\nif (adap->fe[fe_id]) {\r\nstate->num_frontends++;\r\nadap_state->fe_init = adap->fe[fe_id]->ops.init;\r\nadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\r\nadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_attach_demod(struct dvb_usb_adapter *adap, u8 fe_id)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nstruct mxl111sf_adap_state *adap_state = &state->adap_state[fe_id];\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nstate->d = d;\r\nadap_state->alt_mode = (dvb_usb_mxl111sf_isoc) ? 1 : 2;\r\nstate->alt_mode = adap_state->alt_mode;\r\nif (usb_set_interface(d->udev, 0, state->alt_mode) < 0)\r\npr_err("set interface failed");\r\nstate->gpio_mode = MXL111SF_GPIO_MOD_DVBT;\r\nadap_state->gpio_mode = state->gpio_mode;\r\nadap_state->device_mode = MXL_SOC_MODE;\r\nadap_state->ep6_clockphase = 1;\r\nret = mxl1x1sf_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_init_tuner_demod(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_set_device_mode(state, adap_state->device_mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_enable_usb_output(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_top_master_ctrl(state, 1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmxl111sf_init_port_expander(state);\r\nadap->fe[fe_id] = dvb_attach(mxl111sf_demod_attach, state,\r\n&mxl_demod_config);\r\nif (adap->fe[fe_id]) {\r\nstate->num_frontends++;\r\nadap_state->fe_init = adap->fe[fe_id]->ops.init;\r\nadap->fe[fe_id]->ops.init = mxl111sf_adap_fe_init;\r\nadap_state->fe_sleep = adap->fe[fe_id]->ops.sleep;\r\nadap->fe[fe_id]->ops.sleep = mxl111sf_adap_fe_sleep;\r\nreturn 0;\r\n}\r\nret = -EIO;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic inline int mxl111sf_set_ant_path(struct mxl111sf_state *state,\r\nint antpath)\r\n{\r\nreturn mxl111sf_idac_config(state, 1, 1,\r\n(antpath == ANT_PATH_INTERNAL) ?\r\n0x3f : 0x00, 0);\r\n}\r\nstatic int mxl111sf_ant_hunt(struct dvb_frontend *fe)\r\n{\r\nstruct mxl111sf_state *state = fe_to_priv(fe);\r\nint antctrl = dvb_usb_mxl111sf_rfswitch;\r\nu16 rxPwrA, rxPwr0, rxPwr1, rxPwr2;\r\nmxl111sf_set_ant_path(state, antctrl == ANT_PATH_AUTO ?\r\nANT_PATH_EXTERNAL : antctrl);\r\nif (antctrl == ANT_PATH_AUTO) {\r\n#if 0\r\nmsleep(ANT_HUNT_SLEEP);\r\n#endif\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwrA);\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr0);\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr1);\r\nmxl111sf_set_ant_path(state, ANT_PATH_INTERNAL);\r\nmsleep(ANT_HUNT_SLEEP);\r\nfe->ops.tuner_ops.get_rf_strength(fe, &rxPwr2);\r\nif (rxPwr1+ANT_EXT_TWEAK >= rxPwr2) {\r\nmxl111sf_set_ant_path(state, ANT_PATH_EXTERNAL);\r\nDbgAntHunt(ANT_PATH_EXTERNAL, rxPwrA,\r\nrxPwr0, rxPwr1, rxPwr2);\r\n} else {\r\nDbgAntHunt(ANT_PATH_INTERNAL, rxPwrA,\r\nrxPwr0, rxPwr1, rxPwr2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_attach_tuner(struct dvb_usb_adapter *adap)\r\n{\r\nstruct mxl111sf_state *state = adap_to_priv(adap);\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nstruct media_device *mdev = dvb_get_media_controller(&adap->dvb_adap);\r\nint ret;\r\n#endif\r\nint i;\r\npr_debug("%s()\n", __func__);\r\nfor (i = 0; i < state->num_frontends; i++) {\r\nif (dvb_attach(mxl111sf_tuner_attach, adap->fe[i], state,\r\n&mxl_tuner_config) == NULL)\r\nreturn -EIO;\r\nadap->fe[i]->ops.read_signal_strength = adap->fe[i]->ops.tuner_ops.get_rf_strength;\r\n}\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nstate->tuner.function = MEDIA_ENT_F_TUNER;\r\nstate->tuner.name = "mxl111sf tuner";\r\nstate->tuner_pads[TUNER_PAD_RF_INPUT].flags = MEDIA_PAD_FL_SINK;\r\nstate->tuner_pads[TUNER_PAD_OUTPUT].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&state->tuner,\r\nTUNER_NUM_PADS, state->tuner_pads);\r\nif (ret)\r\nreturn ret;\r\nret = media_device_register_entity(mdev, &state->tuner);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic u32 mxl111sf_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int mxl111sf_init(struct dvb_usb_device *d)\r\n{\r\nstruct mxl111sf_state *state = d_to_priv(d);\r\nint ret;\r\nstatic u8 eeprom[256];\r\nstruct i2c_client c;\r\nret = get_chip_info(state);\r\nif (mxl_fail(ret))\r\npr_err("failed to get chip info during probe");\r\nmutex_init(&state->fe_lock);\r\nif (state->chip_rev > MXL111SF_V6)\r\nmxl111sf_config_pin_mux_modes(state, PIN_MUX_TS_SPI_IN_MODE_1);\r\nc.adapter = &d->i2c_adap;\r\nc.addr = 0xa0 >> 1;\r\nret = tveeprom_read(&c, eeprom, sizeof(eeprom));\r\nif (mxl_fail(ret))\r\nreturn 0;\r\ntveeprom_hauppauge_analog(&c, &state->tv, (0x84 == eeprom[0xa0]) ?\r\neeprom + 0xa0 : eeprom + 0x80);\r\n#if 0\r\nswitch (state->tv.model) {\r\ncase 117001:\r\ncase 126001:\r\ncase 138001:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: warning: unknown hauppauge model #%d\n",\r\n__func__, state->tv.model);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_frontend_attach_dvbt(struct dvb_usb_adapter *adap)\r\n{\r\nreturn mxl111sf_attach_demod(adap, 0);\r\n}\r\nstatic int mxl111sf_frontend_attach_atsc(struct dvb_usb_adapter *adap)\r\n{\r\nreturn mxl111sf_lgdt3305_frontend_attach(adap, 0);\r\n}\r\nstatic int mxl111sf_frontend_attach_mh(struct dvb_usb_adapter *adap)\r\n{\r\nreturn mxl111sf_lg2160_frontend_attach(adap, 0);\r\n}\r\nstatic int mxl111sf_frontend_attach_atsc_mh(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\npr_debug("%s\n", __func__);\r\nret = mxl111sf_lgdt3305_frontend_attach(adap, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mxl111sf_attach_demod(adap, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mxl111sf_lg2160_frontend_attach(adap, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_frontend_attach_mercury(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\npr_debug("%s\n", __func__);\r\nret = mxl111sf_lgdt3305_frontend_attach(adap, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mxl111sf_attach_demod(adap, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mxl111sf_lg2161_ep6_frontend_attach(adap, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_frontend_attach_mercury_mh(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\npr_debug("%s\n", __func__);\r\nret = mxl111sf_attach_demod(adap, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dvb_usb_mxl111sf_spi)\r\nret = mxl111sf_lg2161_frontend_attach(adap, 1);\r\nelse\r\nret = mxl111sf_lg2161_ep6_frontend_attach(adap, 1);\r\nreturn ret;\r\n}\r\nstatic void mxl111sf_stream_config_bulk(struct usb_data_stream_properties *stream, u8 endpoint)\r\n{\r\npr_debug("%s: endpoint=%d size=8192\n", __func__, endpoint);\r\nstream->type = USB_BULK;\r\nstream->count = 5;\r\nstream->endpoint = endpoint;\r\nstream->u.bulk.buffersize = 8192;\r\n}\r\nstatic void mxl111sf_stream_config_isoc(struct usb_data_stream_properties *stream,\r\nu8 endpoint, int framesperurb, int framesize)\r\n{\r\npr_debug("%s: endpoint=%d size=%d\n", __func__, endpoint,\r\nframesperurb * framesize);\r\nstream->type = USB_ISOC;\r\nstream->count = 5;\r\nstream->endpoint = endpoint;\r\nstream->u.isoc.framesperurb = framesperurb;\r\nstream->u.isoc.framesize = framesize;\r\nstream->u.isoc.interval = 1;\r\n}\r\nstatic int mxl111sf_get_stream_config_dvbt(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 4, 96, 564);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 4);\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_get_stream_config_atsc(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 6);\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_get_stream_config_mh(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 5, 96, 200);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 5);\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_get_stream_config_atsc_mh(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\nif (fe->id == 0) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 6);\r\n} else if (fe->id == 1) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 4, 96, 564);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 4);\r\n} else if (fe->id == 2) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 5, 96, 200);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 5);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_streaming_ctrl_atsc_mh(struct dvb_frontend *fe, int onoff)\r\n{\r\npr_debug("%s: fe=%d onoff=%d\n", __func__, fe->id, onoff);\r\nif (fe->id == 0)\r\nreturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 1)\r\nreturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 2)\r\nreturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_get_stream_config_mercury(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\nif (fe->id == 0) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 6);\r\n} else if (fe->id == 1) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 4, 96, 564);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 4);\r\n} else if (fe->id == 2 && dvb_usb_mxl111sf_spi) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 5, 96, 200);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 5);\r\n} else if (fe->id == 2 && !dvb_usb_mxl111sf_spi) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 6);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_streaming_ctrl_mercury(struct dvb_frontend *fe, int onoff)\r\n{\r\npr_debug("%s: fe=%d onoff=%d\n", __func__, fe->id, onoff);\r\nif (fe->id == 0)\r\nreturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 1)\r\nreturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 2 && dvb_usb_mxl111sf_spi)\r\nreturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 2 && !dvb_usb_mxl111sf_spi)\r\nreturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_get_stream_config_mercury_mh(struct dvb_frontend *fe,\r\nu8 *ts_type, struct usb_data_stream_properties *stream)\r\n{\r\npr_debug("%s: fe=%d\n", __func__, fe->id);\r\nif (fe->id == 0) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_188;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 4, 96, 564);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 4);\r\n} else if (fe->id == 1 && dvb_usb_mxl111sf_spi) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 5, 96, 200);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 5);\r\n} else if (fe->id == 1 && !dvb_usb_mxl111sf_spi) {\r\n*ts_type = DVB_USB_FE_TS_TYPE_RAW;\r\nif (dvb_usb_mxl111sf_isoc)\r\nmxl111sf_stream_config_isoc(stream, 6, 24, 3072);\r\nelse\r\nmxl111sf_stream_config_bulk(stream, 6);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_streaming_ctrl_mercury_mh(struct dvb_frontend *fe, int onoff)\r\n{\r\npr_debug("%s: fe=%d onoff=%d\n", __func__, fe->id, onoff);\r\nif (fe->id == 0)\r\nreturn mxl111sf_ep4_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 1 && dvb_usb_mxl111sf_spi)\r\nreturn mxl111sf_ep5_streaming_ctrl(fe, onoff);\r\nelse if (fe->id == 1 && !dvb_usb_mxl111sf_spi)\r\nreturn mxl111sf_ep6_streaming_ctrl(fe, onoff);\r\nreturn 0;\r\n}
