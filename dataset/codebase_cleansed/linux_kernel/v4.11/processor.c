static void\r\ninit_percpu_prof(unsigned long cpunum)\r\n{\r\n}\r\nstatic int processor_probe(struct parisc_device *dev)\r\n{\r\nunsigned long txn_addr;\r\nunsigned long cpuid;\r\nstruct cpuinfo_parisc *p;\r\nstruct pdc_pat_cpu_num cpu_info __maybe_unused;\r\n#ifdef CONFIG_SMP\r\nif (num_online_cpus() >= nr_cpu_ids) {\r\nprintk(KERN_INFO "num_online_cpus() >= nr_cpu_ids\n");\r\nreturn 1;\r\n}\r\n#else\r\nif (boot_cpu_data.cpu_count > 0) {\r\nprintk(KERN_INFO "CONFIG_SMP=n ignoring additional CPUs\n");\r\nreturn 1;\r\n}\r\n#endif\r\ncpuid = boot_cpu_data.cpu_count;\r\ntxn_addr = dev->hpa.start;\r\n#ifdef CONFIG_64BIT\r\nif (is_pdc_pat()) {\r\nulong status;\r\nunsigned long bytecnt;\r\npdc_pat_cell_mod_maddr_block_t *pa_pdc_cell;\r\npa_pdc_cell = kmalloc(sizeof (*pa_pdc_cell), GFP_KERNEL);\r\nif (!pa_pdc_cell)\r\npanic("couldn't allocate memory for PDC_PAT_CELL!");\r\nstatus = pdc_pat_cell_module(&bytecnt, dev->pcell_loc,\r\ndev->mod_index, PA_VIEW, pa_pdc_cell);\r\nBUG_ON(PDC_OK != status);\r\nBUG_ON(dev->mod_info != pa_pdc_cell->mod_info);\r\nBUG_ON(dev->pmod_loc != pa_pdc_cell->mod_location);\r\ntxn_addr = pa_pdc_cell->mod[0];\r\nkfree(pa_pdc_cell);\r\nstatus = pdc_pat_cpu_get_number(&cpu_info, dev->hpa.start);\r\nBUG_ON(PDC_OK != status);\r\npr_info("Logical CPU #%lu is physical cpu #%lu at location "\r\n"0x%lx with hpa %pa\n",\r\ncpuid, cpu_info.cpu_num, cpu_info.cpu_loc,\r\n&dev->hpa.start);\r\n#undef USE_PAT_CPUID\r\n#ifdef USE_PAT_CPUID\r\nif (cpu_info.cpu_num >= NR_CPUS) {\r\nprintk(KERN_WARNING "IGNORING CPU at %pa,"\r\n" cpu_slot_id > NR_CPUS"\r\n" (%ld > %d)\n",\r\n&dev->hpa.start, cpu_info.cpu_num, NR_CPUS);\r\nboot_cpu_data.cpu_count--;\r\nreturn 1;\r\n} else {\r\ncpuid = cpu_info.cpu_num;\r\n}\r\n#endif\r\n}\r\n#endif\r\np = &per_cpu(cpu_data, cpuid);\r\nboot_cpu_data.cpu_count++;\r\nif (cpuid)\r\nmemset(p, 0, sizeof(struct cpuinfo_parisc));\r\np->loops_per_jiffy = loops_per_jiffy;\r\np->dev = dev;\r\np->hpa = dev->hpa.start;\r\np->cpuid = cpuid;\r\np->txn_addr = txn_addr;\r\n#ifdef CONFIG_SMP\r\ninit_percpu_prof(cpuid);\r\n#endif\r\n#if 0\r\nif (cpuid) {\r\nstruct irqaction actions[];\r\nactions = kmalloc(sizeof(struct irqaction)*MAX_CPU_IRQ, GFP_ATOMIC);\r\nif (!actions) {\r\nactions = cpu_irq_actions[0];\r\n}\r\ncpu_irq_actions[cpuid] = actions;\r\n}\r\n#endif\r\n#ifdef CONFIG_SMP\r\nif (cpuid) {\r\nset_cpu_present(cpuid, true);\r\ncpu_up(cpuid);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid __init collect_boot_cpu_data(void)\r\n{\r\nmemset(&boot_cpu_data, 0, sizeof(boot_cpu_data));\r\nboot_cpu_data.cpu_hz = 100 * PAGE0->mem_10msec;\r\n#define p ((unsigned long *)&boot_cpu_data.pdc.model)\r\nif (pdc_model_info(&boot_cpu_data.pdc.model) == PDC_OK)\r\nprintk(KERN_INFO\r\n"model %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",\r\np[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]);\r\n#undef p\r\nif (pdc_model_versions(&boot_cpu_data.pdc.versions, 0) == PDC_OK)\r\nprintk(KERN_INFO "vers %08lx\n",\r\nboot_cpu_data.pdc.versions);\r\nif (pdc_model_cpuid(&boot_cpu_data.pdc.cpuid) == PDC_OK)\r\nprintk(KERN_INFO "CPUID vers %ld rev %ld (0x%08lx)\n",\r\n(boot_cpu_data.pdc.cpuid >> 5) & 127,\r\nboot_cpu_data.pdc.cpuid & 31,\r\nboot_cpu_data.pdc.cpuid);\r\nif (pdc_model_capabilities(&boot_cpu_data.pdc.capabilities) == PDC_OK)\r\nprintk(KERN_INFO "capabilities 0x%lx\n",\r\nboot_cpu_data.pdc.capabilities);\r\nif (pdc_model_sysmodel(boot_cpu_data.pdc.sys_model_name) == PDC_OK)\r\nprintk(KERN_INFO "model %s\n",\r\nboot_cpu_data.pdc.sys_model_name);\r\nboot_cpu_data.hversion = boot_cpu_data.pdc.model.hversion;\r\nboot_cpu_data.sversion = boot_cpu_data.pdc.model.sversion;\r\nboot_cpu_data.cpu_type = parisc_get_cpu_type(boot_cpu_data.hversion);\r\nboot_cpu_data.cpu_name = cpu_name_version[boot_cpu_data.cpu_type][0];\r\nboot_cpu_data.family_name = cpu_name_version[boot_cpu_data.cpu_type][1];\r\n#ifdef CONFIG_PA8X00\r\n_parisc_requires_coherency = (boot_cpu_data.cpu_type == mako) ||\r\n(boot_cpu_data.cpu_type == mako2);\r\n#endif\r\n}\r\nint init_per_cpu(int cpunum)\r\n{\r\nint ret;\r\nstruct pdc_coproc_cfg coproc_cfg;\r\nset_firmware_width();\r\nret = pdc_coproc_cfg(&coproc_cfg);\r\nif(ret >= 0 && coproc_cfg.ccr_functional) {\r\nmtctl(coproc_cfg.ccr_functional, 10);\r\nper_cpu(cpu_data, cpunum).fp_rev = coproc_cfg.revision;\r\nper_cpu(cpu_data, cpunum).fp_model = coproc_cfg.model;\r\nif (cpunum == 0)\r\nprintk(KERN_INFO "FP[%d] enabled: Rev %ld Model %ld\n",\r\ncpunum, coproc_cfg.revision, coproc_cfg.model);\r\nasm volatile ("fstd %fr0,8(%sp)");\r\n} else {\r\nprintk(KERN_WARNING "WARNING: No FP CoProcessor?!"\r\n" (coproc_cfg.ccr_functional == 0x%lx, expected 0xc0)\n"\r\n#ifdef CONFIG_64BIT\r\n"Halting Machine - FP required\n"\r\n#endif\r\n, coproc_cfg.ccr_functional);\r\n#ifdef CONFIG_64BIT\r\nmdelay(100);\r\npanic("FP CoProc not reported");\r\n#endif\r\n}\r\ninit_percpu_prof(cpunum);\r\nreturn ret;\r\n}\r\nint\r\nshow_cpuinfo (struct seq_file *m, void *v)\r\n{\r\nunsigned long cpu;\r\nfor_each_online_cpu(cpu) {\r\nconst struct cpuinfo_parisc *cpuinfo = &per_cpu(cpu_data, cpu);\r\n#ifdef CONFIG_SMP\r\nif (0 == cpuinfo->hpa)\r\ncontinue;\r\n#endif\r\nseq_printf(m, "processor\t: %lu\n"\r\n"cpu family\t: PA-RISC %s\n",\r\ncpu, boot_cpu_data.family_name);\r\nseq_printf(m, "cpu\t\t: %s\n", boot_cpu_data.cpu_name );\r\nseq_printf(m, "cpu MHz\t\t: %d.%06d\n",\r\nboot_cpu_data.cpu_hz / 1000000,\r\nboot_cpu_data.cpu_hz % 1000000 );\r\nseq_printf(m, "capabilities\t:");\r\nif (boot_cpu_data.pdc.capabilities & PDC_MODEL_OS32)\r\nseq_puts(m, " os32");\r\nif (boot_cpu_data.pdc.capabilities & PDC_MODEL_OS64)\r\nseq_puts(m, " os64");\r\nif (boot_cpu_data.pdc.capabilities & PDC_MODEL_IOPDIR_FDC)\r\nseq_puts(m, " iopdir_fdc");\r\nswitch (boot_cpu_data.pdc.capabilities & PDC_MODEL_NVA_MASK) {\r\ncase PDC_MODEL_NVA_SUPPORTED:\r\nseq_puts(m, " nva_supported");\r\nbreak;\r\ncase PDC_MODEL_NVA_SLOW:\r\nseq_puts(m, " nva_slow");\r\nbreak;\r\ncase PDC_MODEL_NVA_UNSUPPORTED:\r\nseq_puts(m, " needs_equivalent_aliasing");\r\nbreak;\r\n}\r\nseq_printf(m, " (0x%02lx)\n", boot_cpu_data.pdc.capabilities);\r\nseq_printf(m, "model\t\t: %s\n"\r\n"model name\t: %s\n",\r\nboot_cpu_data.pdc.sys_model_name,\r\ncpuinfo->dev ?\r\ncpuinfo->dev->name : "Unknown");\r\nseq_printf(m, "hversion\t: 0x%08x\n"\r\n"sversion\t: 0x%08x\n",\r\nboot_cpu_data.hversion,\r\nboot_cpu_data.sversion );\r\nshow_cache_info(m);\r\nseq_printf(m, "bogomips\t: %lu.%02lu\n",\r\ncpuinfo->loops_per_jiffy / (500000 / HZ),\r\n(cpuinfo->loops_per_jiffy / (5000 / HZ)) % 100);\r\nseq_printf(m, "software id\t: %ld\n\n",\r\nboot_cpu_data.pdc.model.sw_id);\r\n}\r\nreturn 0;\r\n}\r\nvoid __init processor_init(void)\r\n{\r\nregister_parisc_driver(&cpu_driver);\r\n}
