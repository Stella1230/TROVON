static int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\r\n{\r\nstruct snd_interval t;\r\nt.empty = 0;\r\nt.min = t.max = val;\r\nt.openmin = t.openmax = 0;\r\nt.integer = 1;\r\nreturn snd_interval_refine(i, &t);\r\n}\r\nstatic int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,\r\nsnd_pcm_hw_param_t var, unsigned int val,\r\nint dir)\r\n{\r\nint changed;\r\nif (hw_is_mask(var)) {\r\nstruct snd_mask *m = hw_param_mask(params, var);\r\nif (val == 0 && dir < 0) {\r\nchanged = -EINVAL;\r\nsnd_mask_none(m);\r\n} else {\r\nif (dir > 0)\r\nval++;\r\nelse if (dir < 0)\r\nval--;\r\nchanged = snd_mask_refine_set(\r\nhw_param_mask(params, var), val);\r\n}\r\n} else if (hw_is_interval(var)) {\r\nstruct snd_interval *i = hw_param_interval(params, var);\r\nif (val == 0 && dir < 0) {\r\nchanged = -EINVAL;\r\nsnd_interval_none(i);\r\n} else if (dir == 0)\r\nchanged = snd_interval_refine_set(i, val);\r\nelse {\r\nstruct snd_interval t;\r\nt.openmin = 1;\r\nt.openmax = 1;\r\nt.empty = 0;\r\nt.integer = 0;\r\nif (dir < 0) {\r\nt.min = val - 1;\r\nt.max = val;\r\n} else {\r\nt.min = val;\r\nt.max = val+1;\r\n}\r\nchanged = snd_interval_refine(i, &t);\r\n}\r\n} else\r\nreturn -EINVAL;\r\nif (changed) {\r\nparams->cmask |= 1 << var;\r\nparams->rmask |= 1 << var;\r\n}\r\nreturn changed;\r\n}\r\nstatic int playback_default_hw_params(struct gaudio_snd_dev *snd)\r\n{\r\nstruct snd_pcm_substream *substream = snd->substream;\r\nstruct snd_pcm_hw_params *params;\r\nsnd_pcm_sframes_t result;\r\nsnd->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;\r\nsnd->format = SNDRV_PCM_FORMAT_S16_LE;\r\nsnd->channels = 2;\r\nsnd->rate = 48000;\r\nparams = kzalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\n_snd_pcm_hw_params_any(params);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,\r\nsnd->access, 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,\r\nsnd->format, 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd->channels, 0);\r\n_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd->rate, 0);\r\nsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\r\nsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_HW_PARAMS, params);\r\nresult = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_PREPARE, NULL);\r\nif (result < 0) {\r\nERROR(snd->card,\r\n"Preparing sound card failed: %d\n", (int)result);\r\nkfree(params);\r\nreturn result;\r\n}\r\nsnd->access = params_access(params);\r\nsnd->format = params_format(params);\r\nsnd->channels = params_channels(params);\r\nsnd->rate = params_rate(params);\r\nkfree(params);\r\nINFO(snd->card,\r\n"Hardware params: access %x, format %x, channels %d, rate %d\n",\r\nsnd->access, snd->format, snd->channels, snd->rate);\r\nreturn 0;\r\n}\r\nsize_t u_audio_playback(struct gaudio *card, void *buf, size_t count)\r\n{\r\nstruct gaudio_snd_dev *snd = &card->playback;\r\nstruct snd_pcm_substream *substream = snd->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nmm_segment_t old_fs;\r\nssize_t result;\r\nsnd_pcm_sframes_t frames;\r\ntry_again:\r\nif (runtime->status->state == SNDRV_PCM_STATE_XRUN ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\nresult = snd_pcm_kernel_ioctl(substream,\r\nSNDRV_PCM_IOCTL_PREPARE, NULL);\r\nif (result < 0) {\r\nERROR(card, "Preparing sound card failed: %d\n",\r\n(int)result);\r\nreturn result;\r\n}\r\n}\r\nframes = bytes_to_frames(runtime, count);\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nresult = snd_pcm_lib_write(snd->substream, (void __user *)buf, frames);\r\nif (result != frames) {\r\nERROR(card, "Playback error: %d\n", (int)result);\r\nset_fs(old_fs);\r\ngoto try_again;\r\n}\r\nset_fs(old_fs);\r\nreturn 0;\r\n}\r\nint u_audio_get_playback_channels(struct gaudio *card)\r\n{\r\nreturn card->playback.channels;\r\n}\r\nint u_audio_get_playback_rate(struct gaudio *card)\r\n{\r\nreturn card->playback.rate;\r\n}\r\nstatic int gaudio_open_snd_dev(struct gaudio *card)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct gaudio_snd_dev *snd;\r\nstruct f_uac1_opts *opts;\r\nchar *fn_play, *fn_cap, *fn_cntl;\r\nopts = container_of(card->func.fi, struct f_uac1_opts, func_inst);\r\nfn_play = opts->fn_play;\r\nfn_cap = opts->fn_cap;\r\nfn_cntl = opts->fn_cntl;\r\nsnd = &card->control;\r\nsnd->filp = filp_open(fn_cntl, O_RDWR, 0);\r\nif (IS_ERR(snd->filp)) {\r\nint ret = PTR_ERR(snd->filp);\r\nERROR(card, "unable to open sound control device file: %s\n",\r\nfn_cntl);\r\nsnd->filp = NULL;\r\nreturn ret;\r\n}\r\nsnd->card = card;\r\nsnd = &card->playback;\r\nsnd->filp = filp_open(fn_play, O_WRONLY, 0);\r\nif (IS_ERR(snd->filp)) {\r\nint ret = PTR_ERR(snd->filp);\r\nERROR(card, "No such PCM playback device: %s\n", fn_play);\r\nsnd->filp = NULL;\r\nreturn ret;\r\n}\r\npcm_file = snd->filp->private_data;\r\nsnd->substream = pcm_file->substream;\r\nsnd->card = card;\r\nplayback_default_hw_params(snd);\r\nsnd = &card->capture;\r\nsnd->filp = filp_open(fn_cap, O_RDONLY, 0);\r\nif (IS_ERR(snd->filp)) {\r\nERROR(card, "No such PCM capture device: %s\n", fn_cap);\r\nsnd->substream = NULL;\r\nsnd->card = NULL;\r\nsnd->filp = NULL;\r\n} else {\r\npcm_file = snd->filp->private_data;\r\nsnd->substream = pcm_file->substream;\r\nsnd->card = card;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gaudio_close_snd_dev(struct gaudio *gau)\r\n{\r\nstruct gaudio_snd_dev *snd;\r\nsnd = &gau->control;\r\nif (snd->filp)\r\nfilp_close(snd->filp, NULL);\r\nsnd = &gau->playback;\r\nif (snd->filp)\r\nfilp_close(snd->filp, NULL);\r\nsnd = &gau->capture;\r\nif (snd->filp)\r\nfilp_close(snd->filp, NULL);\r\nreturn 0;\r\n}\r\nint gaudio_setup(struct gaudio *card)\r\n{\r\nint ret;\r\nret = gaudio_open_snd_dev(card);\r\nif (ret)\r\nERROR(card, "we need at least one control device\n");\r\nreturn ret;\r\n}\r\nvoid gaudio_cleanup(struct gaudio *the_card)\r\n{\r\nif (the_card)\r\ngaudio_close_snd_dev(the_card);\r\n}
