static void bcm_kona_i2c_send_cmd_to_ctrl(struct bcm_kona_i2c_dev *dev,\r\nenum bcm_kona_cmd_t cmd)\r\n{\r\ndev_dbg(dev->device, "%s, %d\n", __func__, cmd);\r\nswitch (cmd) {\r\ncase BCM_CMD_NOACTION:\r\nwritel((CS_CMD_CMD_NO_ACTION << CS_CMD_SHIFT) |\r\n(CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\r\ndev->base + CS_OFFSET);\r\nbreak;\r\ncase BCM_CMD_START:\r\nwritel((CS_ACK_CMD_GEN_START << CS_ACK_SHIFT) |\r\n(CS_CMD_CMD_START_RESTART << CS_CMD_SHIFT) |\r\n(CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\r\ndev->base + CS_OFFSET);\r\nbreak;\r\ncase BCM_CMD_RESTART:\r\nwritel((CS_ACK_CMD_GEN_RESTART << CS_ACK_SHIFT) |\r\n(CS_CMD_CMD_START_RESTART << CS_CMD_SHIFT) |\r\n(CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\r\ndev->base + CS_OFFSET);\r\nbreak;\r\ncase BCM_CMD_STOP:\r\nwritel((CS_CMD_CMD_STOP << CS_CMD_SHIFT) |\r\n(CS_EN_CMD_ENABLE_BSC << CS_EN_SHIFT),\r\ndev->base + CS_OFFSET);\r\nbreak;\r\ndefault:\r\ndev_err(dev->device, "Unknown command %d\n", cmd);\r\n}\r\n}\r\nstatic void bcm_kona_i2c_enable_clock(struct bcm_kona_i2c_dev *dev)\r\n{\r\nwritel(readl(dev->base + CLKEN_OFFSET) | CLKEN_CLKEN_MASK,\r\ndev->base + CLKEN_OFFSET);\r\n}\r\nstatic void bcm_kona_i2c_disable_clock(struct bcm_kona_i2c_dev *dev)\r\n{\r\nwritel(readl(dev->base + CLKEN_OFFSET) & ~CLKEN_CLKEN_MASK,\r\ndev->base + CLKEN_OFFSET);\r\n}\r\nstatic irqreturn_t bcm_kona_i2c_isr(int irq, void *devid)\r\n{\r\nstruct bcm_kona_i2c_dev *dev = devid;\r\nuint32_t status = readl(dev->base + ISR_OFFSET);\r\nif ((status & ~ISR_RESERVED_MASK) == 0)\r\nreturn IRQ_NONE;\r\nif (status & ISR_NOACK_MASK)\r\nwritel(TXFCR_FIFO_FLUSH_MASK | TXFCR_FIFO_EN_MASK,\r\ndev->base + TXFCR_OFFSET);\r\nwritel(status & ~ISR_RESERVED_MASK, dev->base + ISR_OFFSET);\r\ncomplete(&dev->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_kona_i2c_wait_if_busy(struct bcm_kona_i2c_dev *dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(I2C_TIMEOUT);\r\nwhile (readl(dev->base + ISR_OFFSET) & ISR_CMDBUSY_MASK)\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(dev->device, "CMDBUSY timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_send_i2c_cmd(struct bcm_kona_i2c_dev *dev,\r\nenum bcm_kona_cmd_t cmd)\r\n{\r\nint rc;\r\nunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\r\nrc = bcm_kona_i2c_wait_if_busy(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nwritel(IER_I2C_INT_EN_MASK, dev->base + IER_OFFSET);\r\nreinit_completion(&dev->done);\r\nbcm_kona_i2c_send_cmd_to_ctrl(dev, cmd);\r\ntime_left = wait_for_completion_timeout(&dev->done, time_left);\r\nwritel(0, dev->base + IER_OFFSET);\r\nif (!time_left) {\r\ndev_err(dev->device, "controller timed out\n");\r\nrc = -ETIMEDOUT;\r\n}\r\nbcm_kona_i2c_send_cmd_to_ctrl(dev, BCM_CMD_NOACTION);\r\nreturn rc;\r\n}\r\nstatic int bcm_kona_i2c_read_fifo_single(struct bcm_kona_i2c_dev *dev,\r\nuint8_t *buf, unsigned int len,\r\nunsigned int last_byte_nak)\r\n{\r\nunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\r\nreinit_completion(&dev->done);\r\nwritel(IER_READ_COMPLETE_INT_MASK, dev->base + IER_OFFSET);\r\nwritel((last_byte_nak << RXFCR_NACK_EN_SHIFT) |\r\n(len << RXFCR_READ_COUNT_SHIFT),\r\ndev->base + RXFCR_OFFSET);\r\ntime_left = wait_for_completion_timeout(&dev->done, time_left);\r\nwritel(0, dev->base + IER_OFFSET);\r\nif (!time_left) {\r\ndev_err(dev->device, "RX FIFO time out\n");\r\nreturn -EREMOTEIO;\r\n}\r\nfor (; len > 0; len--, buf++)\r\n*buf = readl(dev->base + RXFIFORDOUT_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_read_fifo(struct bcm_kona_i2c_dev *dev,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned int bytes_to_read = MAX_RX_FIFO_SIZE;\r\nunsigned int last_byte_nak = 0;\r\nunsigned int bytes_read = 0;\r\nint rc;\r\nuint8_t *tmp_buf = msg->buf;\r\nwhile (bytes_read < msg->len) {\r\nif (msg->len - bytes_read <= MAX_RX_FIFO_SIZE) {\r\nlast_byte_nak = 1;\r\nbytes_to_read = msg->len - bytes_read;\r\n}\r\nrc = bcm_kona_i2c_read_fifo_single(dev, tmp_buf, bytes_to_read,\r\nlast_byte_nak);\r\nif (rc < 0)\r\nreturn -EREMOTEIO;\r\nbytes_read += bytes_to_read;\r\ntmp_buf += bytes_to_read;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_write_byte(struct bcm_kona_i2c_dev *dev, uint8_t data,\r\nunsigned int nak_expected)\r\n{\r\nint rc;\r\nunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\r\nunsigned int nak_received;\r\nrc = bcm_kona_i2c_wait_if_busy(dev);\r\nif (rc < 0)\r\nreturn rc;\r\nwritel(ISR_SES_DONE_MASK, dev->base + ISR_OFFSET);\r\nwritel(IER_I2C_INT_EN_MASK, dev->base + IER_OFFSET);\r\nreinit_completion(&dev->done);\r\nwritel(data, dev->base + DAT_OFFSET);\r\ntime_left = wait_for_completion_timeout(&dev->done, time_left);\r\nwritel(0, dev->base + IER_OFFSET);\r\nif (!time_left) {\r\ndev_dbg(dev->device, "controller timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nnak_received = readl(dev->base + CS_OFFSET) & CS_ACK_MASK ? 1 : 0;\r\nif (nak_received ^ nak_expected) {\r\ndev_dbg(dev->device, "unexpected NAK/ACK\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_write_fifo_single(struct bcm_kona_i2c_dev *dev,\r\nuint8_t *buf, unsigned int len)\r\n{\r\nint k;\r\nunsigned long time_left = msecs_to_jiffies(I2C_TIMEOUT);\r\nunsigned int fifo_status;\r\nreinit_completion(&dev->done);\r\nwritel(IER_FIFO_INT_EN_MASK | IER_NOACK_EN_MASK,\r\ndev->base + IER_OFFSET);\r\ndisable_irq(dev->irq);\r\nfor (k = 0; k < len; k++)\r\nwritel(buf[k], (dev->base + DAT_OFFSET));\r\nenable_irq(dev->irq);\r\ndo {\r\ntime_left = wait_for_completion_timeout(&dev->done, time_left);\r\nfifo_status = readl(dev->base + FIFO_STATUS_OFFSET);\r\n} while (time_left && !(fifo_status & FIFO_STATUS_TXFIFO_EMPTY_MASK));\r\nwritel(0, dev->base + IER_OFFSET);\r\nif (readl(dev->base + CS_OFFSET) & CS_ACK_MASK) {\r\ndev_err(dev->device, "unexpected NAK\n");\r\nreturn -EREMOTEIO;\r\n}\r\nif (!time_left) {\r\ndev_err(dev->device, "completion timed out\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_write_fifo(struct bcm_kona_i2c_dev *dev,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned int bytes_to_write = MAX_TX_FIFO_SIZE;\r\nunsigned int bytes_written = 0;\r\nint rc;\r\nuint8_t *tmp_buf = msg->buf;\r\nwhile (bytes_written < msg->len) {\r\nif (msg->len - bytes_written <= MAX_TX_FIFO_SIZE)\r\nbytes_to_write = msg->len - bytes_written;\r\nrc = bcm_kona_i2c_write_fifo_single(dev, tmp_buf,\r\nbytes_to_write);\r\nif (rc < 0)\r\nreturn -EREMOTEIO;\r\nbytes_written += bytes_to_write;\r\ntmp_buf += bytes_to_write;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_do_addr(struct bcm_kona_i2c_dev *dev,\r\nstruct i2c_msg *msg)\r\n{\r\nunsigned char addr;\r\nif (msg->flags & I2C_M_TEN) {\r\naddr = 0xF0 | ((msg->addr & 0x300) >> 7);\r\nif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\naddr = msg->addr & 0xFF;\r\nif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\nif (msg->flags & I2C_M_RD) {\r\nif (bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART) < 0)\r\nreturn -EREMOTEIO;\r\naddr = 0xF0 | ((msg->addr & 0x300) >> 7) | 0x01;\r\nif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\n}\r\n} else {\r\naddr = i2c_8bit_addr_from_msg(msg);\r\nif (bcm_kona_i2c_write_byte(dev, addr, 0) < 0)\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm_kona_i2c_enable_autosense(struct bcm_kona_i2c_dev *dev)\r\n{\r\nwritel(readl(dev->base + CLKEN_OFFSET) & ~CLKEN_AUTOSENSE_OFF_MASK,\r\ndev->base + CLKEN_OFFSET);\r\n}\r\nstatic void bcm_kona_i2c_config_timing(struct bcm_kona_i2c_dev *dev)\r\n{\r\nwritel(readl(dev->base + HSTIM_OFFSET) & ~HSTIM_HS_MODE_MASK,\r\ndev->base + HSTIM_OFFSET);\r\nwritel((dev->std_cfg->prescale << TIM_PRESCALE_SHIFT) |\r\n(dev->std_cfg->time_p << TIM_P_SHIFT) |\r\n(dev->std_cfg->no_div << TIM_NO_DIV_SHIFT) |\r\n(dev->std_cfg->time_div << TIM_DIV_SHIFT),\r\ndev->base + TIM_OFFSET);\r\nwritel((dev->std_cfg->time_m << CLKEN_M_SHIFT) |\r\n(dev->std_cfg->time_n << CLKEN_N_SHIFT) |\r\nCLKEN_CLKEN_MASK,\r\ndev->base + CLKEN_OFFSET);\r\n}\r\nstatic void bcm_kona_i2c_config_timing_hs(struct bcm_kona_i2c_dev *dev)\r\n{\r\nwritel((dev->hs_cfg->prescale << TIM_PRESCALE_SHIFT) |\r\n(dev->hs_cfg->time_p << TIM_P_SHIFT) |\r\n(dev->hs_cfg->no_div << TIM_NO_DIV_SHIFT) |\r\n(dev->hs_cfg->time_div << TIM_DIV_SHIFT),\r\ndev->base + TIM_OFFSET);\r\nwritel((dev->hs_cfg->hs_hold << HSTIM_HS_HOLD_SHIFT) |\r\n(dev->hs_cfg->hs_high_phase << HSTIM_HS_HIGH_PHASE_SHIFT) |\r\n(dev->hs_cfg->hs_setup << HSTIM_HS_SETUP_SHIFT),\r\ndev->base + HSTIM_OFFSET);\r\nwritel(readl(dev->base + HSTIM_OFFSET) | HSTIM_HS_MODE_MASK,\r\ndev->base + HSTIM_OFFSET);\r\n}\r\nstatic int bcm_kona_i2c_switch_to_hs(struct bcm_kona_i2c_dev *dev)\r\n{\r\nint rc;\r\nrc = bcm_kona_i2c_write_byte(dev, MASTERCODE, 1);\r\nif (rc < 0) {\r\npr_err("High speed handshake failed\n");\r\nreturn rc;\r\n}\r\nrc = clk_set_rate(dev->external_clk, HS_EXT_CLK_FREQ);\r\nif (rc) {\r\ndev_err(dev->device, "%s: clk_set_rate returned %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nbcm_kona_i2c_config_timing_hs(dev);\r\nrc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART);\r\nif (rc < 0)\r\ndev_err(dev->device, "High speed restart command failed\n");\r\nreturn rc;\r\n}\r\nstatic int bcm_kona_i2c_switch_to_std(struct bcm_kona_i2c_dev *dev)\r\n{\r\nint rc;\r\nbcm_kona_i2c_config_timing(dev);\r\nrc = clk_set_rate(dev->external_clk, STD_EXT_CLK_FREQ);\r\nif (rc) {\r\ndev_err(dev->device, "%s: clk_set_rate returned %d\n",\r\n__func__, rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int bcm_kona_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct bcm_kona_i2c_dev *dev = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *pmsg;\r\nint rc = 0;\r\nint i;\r\nrc = clk_prepare_enable(dev->external_clk);\r\nif (rc) {\r\ndev_err(dev->device, "%s: peri clock enable failed. err %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nwritel(0, dev->base + PADCTL_OFFSET);\r\nbcm_kona_i2c_enable_clock(dev);\r\nrc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_START);\r\nif (rc < 0) {\r\ndev_err(dev->device, "Start command failed rc = %d\n", rc);\r\ngoto xfer_disable_pad;\r\n}\r\nif (dev->hs_cfg) {\r\nrc = bcm_kona_i2c_switch_to_hs(dev);\r\nif (rc < 0)\r\ngoto xfer_send_stop;\r\n}\r\nfor (i = 0; i < num; i++) {\r\npmsg = &msgs[i];\r\nif ((i != 0) && ((pmsg->flags & I2C_M_NOSTART) == 0)) {\r\nrc = bcm_kona_send_i2c_cmd(dev, BCM_CMD_RESTART);\r\nif (rc < 0) {\r\ndev_err(dev->device,\r\n"restart cmd failed rc = %d\n", rc);\r\ngoto xfer_send_stop;\r\n}\r\n}\r\nif (!(pmsg->flags & I2C_M_NOSTART)) {\r\nrc = bcm_kona_i2c_do_addr(dev, pmsg);\r\nif (rc < 0) {\r\ndev_err(dev->device,\r\n"NAK from addr %2.2x msg#%d rc = %d\n",\r\npmsg->addr, i, rc);\r\ngoto xfer_send_stop;\r\n}\r\n}\r\nif (pmsg->flags & I2C_M_RD) {\r\nrc = bcm_kona_i2c_read_fifo(dev, pmsg);\r\nif (rc < 0) {\r\ndev_err(dev->device, "read failure\n");\r\ngoto xfer_send_stop;\r\n}\r\n} else {\r\nrc = bcm_kona_i2c_write_fifo(dev, pmsg);\r\nif (rc < 0) {\r\ndev_err(dev->device, "write failure");\r\ngoto xfer_send_stop;\r\n}\r\n}\r\n}\r\nrc = num;\r\nxfer_send_stop:\r\nbcm_kona_send_i2c_cmd(dev, BCM_CMD_STOP);\r\nif (dev->hs_cfg) {\r\nint hs_rc = bcm_kona_i2c_switch_to_std(dev);\r\nif (hs_rc)\r\nrc = hs_rc;\r\n}\r\nxfer_disable_pad:\r\nwritel(PADCTL_PAD_OUT_EN_MASK, dev->base + PADCTL_OFFSET);\r\nbcm_kona_i2c_disable_clock(dev);\r\nclk_disable_unprepare(dev->external_clk);\r\nreturn rc;\r\n}\r\nstatic uint32_t bcm_kona_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_NOSTART;\r\n}\r\nstatic int bcm_kona_i2c_assign_bus_speed(struct bcm_kona_i2c_dev *dev)\r\n{\r\nunsigned int bus_speed;\r\nint ret = of_property_read_u32(dev->device->of_node, "clock-frequency",\r\n&bus_speed);\r\nif (ret < 0) {\r\ndev_err(dev->device, "missing clock-frequency property\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (bus_speed) {\r\ncase 100000:\r\ndev->std_cfg = &std_cfg_table[BCM_SPD_100K];\r\nbreak;\r\ncase 400000:\r\ndev->std_cfg = &std_cfg_table[BCM_SPD_400K];\r\nbreak;\r\ncase 1000000:\r\ndev->std_cfg = &std_cfg_table[BCM_SPD_1MHZ];\r\nbreak;\r\ncase 3400000:\r\ndev->std_cfg = &std_cfg_table[BCM_SPD_100K];\r\ndev->hs_cfg = &hs_cfg_table[BCM_SPD_3P4MHZ];\r\nbreak;\r\ndefault:\r\npr_err("%d hz bus speed not supported\n", bus_speed);\r\npr_err("Valid speeds are 100khz, 400khz, 1mhz, and 3.4mhz\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_kona_i2c_probe(struct platform_device *pdev)\r\n{\r\nint rc = 0;\r\nstruct bcm_kona_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *iomem;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->device = &pdev->dev;\r\ninit_completion(&dev->done);\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->base = devm_ioremap_resource(dev->device, iomem);\r\nif (IS_ERR(dev->base))\r\nreturn -ENOMEM;\r\ndev->external_clk = devm_clk_get(dev->device, NULL);\r\nif (IS_ERR(dev->external_clk)) {\r\ndev_err(dev->device, "couldn't get clock\n");\r\nreturn -ENODEV;\r\n}\r\nrc = clk_set_rate(dev->external_clk, STD_EXT_CLK_FREQ);\r\nif (rc) {\r\ndev_err(dev->device, "%s: clk_set_rate returned %d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nrc = clk_prepare_enable(dev->external_clk);\r\nif (rc) {\r\ndev_err(dev->device, "couldn't enable clock\n");\r\nreturn rc;\r\n}\r\nrc = bcm_kona_i2c_assign_bus_speed(dev);\r\nif (rc)\r\ngoto probe_disable_clk;\r\nbcm_kona_i2c_enable_clock(dev);\r\nbcm_kona_i2c_config_timing(dev);\r\nwritel(0, dev->base + TOUT_OFFSET);\r\nbcm_kona_i2c_enable_autosense(dev);\r\nwritel(TXFCR_FIFO_FLUSH_MASK | TXFCR_FIFO_EN_MASK,\r\ndev->base + TXFCR_OFFSET);\r\nwritel(0, dev->base + IER_OFFSET);\r\nwritel(ISR_CMDBUSY_MASK |\r\nISR_READ_COMPLETE_MASK |\r\nISR_SES_DONE_MASK |\r\nISR_ERR_MASK |\r\nISR_TXFIFOEMPTY_MASK |\r\nISR_NOACK_MASK,\r\ndev->base + ISR_OFFSET);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (dev->irq < 0) {\r\ndev_err(dev->device, "no irq resource\n");\r\nrc = -ENODEV;\r\ngoto probe_disable_clk;\r\n}\r\nrc = devm_request_irq(&pdev->dev, dev->irq, bcm_kona_i2c_isr,\r\nIRQF_SHARED, pdev->name, dev);\r\nif (rc) {\r\ndev_err(dev->device, "failed to request irq %i\n", dev->irq);\r\ngoto probe_disable_clk;\r\n}\r\nbcm_kona_i2c_send_cmd_to_ctrl(dev, BCM_CMD_NOACTION);\r\nwritel(PADCTL_PAD_OUT_EN_MASK, dev->base + PADCTL_OFFSET);\r\nbcm_kona_i2c_disable_clock(dev);\r\nclk_disable_unprepare(dev->external_clk);\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nstrlcpy(adap->name, "Broadcom I2C adapter", sizeof(adap->name));\r\nadap->algo = &bcm_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nrc = i2c_add_adapter(adap);\r\nif (rc)\r\nreturn rc;\r\ndev_info(dev->device, "device registered successfully\n");\r\nreturn 0;\r\nprobe_disable_clk:\r\nbcm_kona_i2c_disable_clock(dev);\r\nclk_disable_unprepare(dev->external_clk);\r\nreturn rc;\r\n}\r\nstatic int bcm_kona_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm_kona_i2c_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adapter);\r\nreturn 0;\r\n}
