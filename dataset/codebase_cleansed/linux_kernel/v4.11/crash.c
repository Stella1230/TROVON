static int handle_fault(struct pt_regs *regs)\r\n{\r\nif (crash_shutdown_cpu == smp_processor_id())\r\nlongjmp(crash_shutdown_buf, 1);\r\nreturn 0;\r\n}\r\nstatic void crash_ipi_callback(struct pt_regs *regs)\r\n{\r\nstatic cpumask_t cpus_state_saved = CPU_MASK_NONE;\r\nint cpu = smp_processor_id();\r\nif (!cpu_online(cpu))\r\nreturn;\r\nhard_irq_disable();\r\nif (!cpumask_test_cpu(cpu, &cpus_state_saved)) {\r\ncrash_save_cpu(regs, cpu);\r\ncpumask_set_cpu(cpu, &cpus_state_saved);\r\n}\r\natomic_inc(&cpus_in_crash);\r\nsmp_mb__after_atomic();\r\nwhile (!time_to_dump)\r\ncpu_relax();\r\nif (ppc_md.kexec_cpu_down)\r\nppc_md.kexec_cpu_down(1, 1);\r\n#ifdef CONFIG_PPC64\r\nkexec_smp_wait();\r\n#else\r\nfor (;;);\r\n#endif\r\n}\r\nstatic void crash_kexec_prepare_cpus(int cpu)\r\n{\r\nunsigned int msecs;\r\nunsigned int ncpus = num_online_cpus() - 1;\r\nint tries = 0;\r\nint (*old_handler)(struct pt_regs *regs);\r\nprintk(KERN_EMERG "Sending IPI to other CPUs\n");\r\ncrash_send_ipi(crash_ipi_callback);\r\nsmp_wmb();\r\nagain:\r\nmsecs = IPI_TIMEOUT;\r\nwhile ((atomic_read(&cpus_in_crash) < ncpus) && (--msecs > 0))\r\nmdelay(1);\r\nif (atomic_read(&cpus_in_crash) >= ncpus) {\r\nprintk(KERN_EMERG "IPI complete\n");\r\nreturn;\r\n}\r\nprintk(KERN_EMERG "ERROR: %d cpu(s) not responding\n",\r\nncpus - atomic_read(&cpus_in_crash));\r\nif ((panic_timeout > 0) || (tries > 0))\r\nreturn;\r\nold_handler = __debugger;\r\n__debugger = handle_fault;\r\ncrash_shutdown_cpu = smp_processor_id();\r\nif (setjmp(crash_shutdown_buf) == 0) {\r\nprintk(KERN_EMERG "Activate system reset (dumprestart) "\r\n"to stop other cpu(s)\n");\r\natomic_set(&cpus_in_crash, 0);\r\nsmp_mb();\r\nwhile (atomic_read(&cpus_in_crash) < ncpus)\r\ncpu_relax();\r\n}\r\ncrash_shutdown_cpu = -1;\r\n__debugger = old_handler;\r\ntries++;\r\ngoto again;\r\n}\r\nvoid crash_kexec_secondary(struct pt_regs *regs)\r\n{\r\nunsigned long flags;\r\nint msecs = SECONDARY_TIMEOUT;\r\nlocal_irq_save(flags);\r\nwhile (crashing_cpu < 0) {\r\nif (--msecs < 0) {\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nmdelay(1);\r\n}\r\ncrash_ipi_callback(regs);\r\n}\r\nstatic void crash_kexec_prepare_cpus(int cpu)\r\n{\r\n#ifdef CONFIG_PPC64\r\nsmp_release_cpus();\r\n#else\r\n#endif\r\n}\r\nvoid crash_kexec_secondary(struct pt_regs *regs)\r\n{\r\n}\r\nstatic void __maybe_unused crash_kexec_wait_realmode(int cpu)\r\n{\r\nunsigned int msecs;\r\nint i;\r\nmsecs = REAL_MODE_TIMEOUT;\r\nfor (i=0; i < nr_cpu_ids && msecs > 0; i++) {\r\nif (i == cpu)\r\ncontinue;\r\nwhile (paca[i].kexec_state < KEXEC_STATE_REAL_MODE) {\r\nbarrier();\r\nif (!cpu_possible(i) || !cpu_online(i) || (msecs <= 0))\r\nbreak;\r\nmsecs--;\r\nmdelay(1);\r\n}\r\n}\r\nmb();\r\n}\r\nstatic inline void crash_kexec_wait_realmode(int cpu) {}\r\nint crash_shutdown_register(crash_shutdown_t handler)\r\n{\r\nunsigned int i, rc;\r\nspin_lock(&crash_handlers_lock);\r\nfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\r\nif (!crash_shutdown_handles[i]) {\r\ncrash_shutdown_handles[i] = handler;\r\nrc = 0;\r\nbreak;\r\n}\r\nif (i == CRASH_HANDLER_MAX) {\r\nprintk(KERN_ERR "Crash shutdown handles full, "\r\n"not registered.\n");\r\nrc = 1;\r\n}\r\nspin_unlock(&crash_handlers_lock);\r\nreturn rc;\r\n}\r\nint crash_shutdown_unregister(crash_shutdown_t handler)\r\n{\r\nunsigned int i, rc;\r\nspin_lock(&crash_handlers_lock);\r\nfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\r\nif (crash_shutdown_handles[i] == handler)\r\nbreak;\r\nif (i == CRASH_HANDLER_MAX) {\r\nprintk(KERN_ERR "Crash shutdown handle not found\n");\r\nrc = 1;\r\n} else {\r\nfor (; i < (CRASH_HANDLER_MAX - 1); i++)\r\ncrash_shutdown_handles[i] =\r\ncrash_shutdown_handles[i+1];\r\ncrash_shutdown_handles[i] = NULL;\r\nrc = 0;\r\n}\r\nspin_unlock(&crash_handlers_lock);\r\nreturn rc;\r\n}\r\nvoid default_machine_crash_shutdown(struct pt_regs *regs)\r\n{\r\nunsigned int i;\r\nint (*old_handler)(struct pt_regs *regs);\r\nhard_irq_disable();\r\ncrashing_cpu = smp_processor_id();\r\nif (TRAP(regs) == 0x100)\r\nmdelay(PRIMARY_TIMEOUT);\r\ncrash_kexec_prepare_cpus(crashing_cpu);\r\ncrash_save_cpu(regs, crashing_cpu);\r\ntime_to_dump = 1;\r\ncrash_kexec_wait_realmode(crashing_cpu);\r\nmachine_kexec_mask_interrupts();\r\nold_handler = __debugger_fault_handler;\r\n__debugger_fault_handler = handle_fault;\r\ncrash_shutdown_cpu = smp_processor_id();\r\nfor (i = 0; i < CRASH_HANDLER_MAX && crash_shutdown_handles[i]; i++) {\r\nif (setjmp(crash_shutdown_buf) == 0) {\r\nasm volatile("sync; isync");\r\ncrash_shutdown_handles[i]();\r\nasm volatile("sync; isync");\r\n}\r\n}\r\ncrash_shutdown_cpu = -1;\r\n__debugger_fault_handler = old_handler;\r\nif (ppc_md.kexec_cpu_down)\r\nppc_md.kexec_cpu_down(1, 0);\r\n}
