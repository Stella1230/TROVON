static __le32 *cx88_risc_field(__le32 *rp, struct scatterlist *sglist,\r\nunsigned int offset, u32 sync_line,\r\nunsigned int bpl, unsigned int padding,\r\nunsigned int lines, unsigned int lpi, bool jump)\r\n{\r\nstruct scatterlist *sg;\r\nunsigned int line, todo, sol;\r\nif (jump) {\r\n(*rp++) = cpu_to_le32(RISC_JUMP);\r\n(*rp++) = 0;\r\n}\r\nif (sync_line != NO_SYNC_LINE)\r\n*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);\r\nsg = sglist;\r\nfor (line = 0; line < lines; line++) {\r\nwhile (offset && offset >= sg_dma_len(sg)) {\r\noffset -= sg_dma_len(sg);\r\nsg = sg_next(sg);\r\n}\r\nif (lpi && line > 0 && !(line % lpi))\r\nsol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;\r\nelse\r\nsol = RISC_SOL;\r\nif (bpl <= sg_dma_len(sg) - offset) {\r\n*(rp++) = cpu_to_le32(RISC_WRITE | sol |\r\nRISC_EOL | bpl);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\noffset += bpl;\r\n} else {\r\ntodo = bpl;\r\n*(rp++) = cpu_to_le32(RISC_WRITE | sol |\r\n(sg_dma_len(sg) - offset));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg) + offset);\r\ntodo -= (sg_dma_len(sg) - offset);\r\noffset = 0;\r\nsg = sg_next(sg);\r\nwhile (todo > sg_dma_len(sg)) {\r\n*(rp++) = cpu_to_le32(RISC_WRITE |\r\nsg_dma_len(sg));\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\ntodo -= sg_dma_len(sg);\r\nsg = sg_next(sg);\r\n}\r\n*(rp++) = cpu_to_le32(RISC_WRITE | RISC_EOL | todo);\r\n*(rp++) = cpu_to_le32(sg_dma_address(sg));\r\noffset += todo;\r\n}\r\noffset += padding;\r\n}\r\nreturn rp;\r\n}\r\nint cx88_risc_buffer(struct pci_dev *pci, struct cx88_riscmem *risc,\r\nstruct scatterlist *sglist,\r\nunsigned int top_offset, unsigned int bottom_offset,\r\nunsigned int bpl, unsigned int padding, unsigned int lines)\r\n{\r\nu32 instructions, fields;\r\n__le32 *rp;\r\nfields = 0;\r\nif (top_offset != UNSET)\r\nfields++;\r\nif (bottom_offset != UNSET)\r\nfields++;\r\ninstructions = fields * (1 + ((bpl + padding) * lines) /\r\nPAGE_SIZE + lines);\r\ninstructions += 4;\r\nrisc->size = instructions * 8;\r\nrisc->dma = 0;\r\nrisc->cpu = pci_zalloc_consistent(pci, risc->size, &risc->dma);\r\nif (!risc->cpu)\r\nreturn -ENOMEM;\r\nrp = risc->cpu;\r\nif (top_offset != UNSET)\r\nrp = cx88_risc_field(rp, sglist, top_offset, 0,\r\nbpl, padding, lines, 0, true);\r\nif (bottom_offset != UNSET)\r\nrp = cx88_risc_field(rp, sglist, bottom_offset, 0x200,\r\nbpl, padding, lines, 0,\r\ntop_offset == UNSET);\r\nrisc->jmp = rp;\r\nWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx88_risc_databuffer(struct pci_dev *pci, struct cx88_riscmem *risc,\r\nstruct scatterlist *sglist, unsigned int bpl,\r\nunsigned int lines, unsigned int lpi)\r\n{\r\nu32 instructions;\r\n__le32 *rp;\r\ninstructions = 1 + (bpl * lines) / PAGE_SIZE + lines;\r\ninstructions += 3;\r\nrisc->size = instructions * 8;\r\nrisc->dma = 0;\r\nrisc->cpu = pci_zalloc_consistent(pci, risc->size, &risc->dma);\r\nif (!risc->cpu)\r\nreturn -ENOMEM;\r\nrp = risc->cpu;\r\nrp = cx88_risc_field(rp, sglist, 0, NO_SYNC_LINE, bpl, 0,\r\nlines, lpi, !lpi);\r\nrisc->jmp = rp;\r\nWARN_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);\r\nreturn 0;\r\n}\r\nint cx88_sram_channel_setup(struct cx88_core *core,\r\nconst struct sram_channel *ch,\r\nunsigned int bpl, u32 risc)\r\n{\r\nunsigned int i, lines;\r\nu32 cdt;\r\nbpl = (bpl + 7) & ~7;\r\ncdt = ch->cdt;\r\nlines = ch->fifo_size / bpl;\r\nif (lines > 6)\r\nlines = 6;\r\nWARN_ON(lines < 2);\r\nfor (i = 0; i < lines; i++)\r\ncx_write(cdt + 16 * i, ch->fifo_start + bpl * i);\r\ncx_write(ch->cmds_start + 0, risc);\r\ncx_write(ch->cmds_start + 4, cdt);\r\ncx_write(ch->cmds_start + 8, (lines * 16) >> 3);\r\ncx_write(ch->cmds_start + 12, ch->ctrl_start);\r\ncx_write(ch->cmds_start + 16, 64 >> 2);\r\nfor (i = 20; i < 64; i += 4)\r\ncx_write(ch->cmds_start + i, 0);\r\ncx_write(ch->ptr1_reg, ch->fifo_start);\r\ncx_write(ch->ptr2_reg, cdt);\r\ncx_write(ch->cnt1_reg, (bpl >> 3) - 1);\r\ncx_write(ch->cnt2_reg, (lines * 16) >> 3);\r\ndprintk(2, "sram setup %s: bpl=%d lines=%d\n", ch->name, bpl, lines);\r\nreturn 0;\r\n}\r\nstatic int cx88_risc_decode(u32 risc)\r\n{\r\nstatic const char * const instr[16] = {\r\n[RISC_SYNC >> 28] = "sync",\r\n[RISC_WRITE >> 28] = "write",\r\n[RISC_WRITEC >> 28] = "writec",\r\n[RISC_READ >> 28] = "read",\r\n[RISC_READC >> 28] = "readc",\r\n[RISC_JUMP >> 28] = "jump",\r\n[RISC_SKIP >> 28] = "skip",\r\n[RISC_WRITERM >> 28] = "writerm",\r\n[RISC_WRITECM >> 28] = "writecm",\r\n[RISC_WRITECR >> 28] = "writecr",\r\n};\r\nstatic int const incr[16] = {\r\n[RISC_WRITE >> 28] = 2,\r\n[RISC_JUMP >> 28] = 2,\r\n[RISC_WRITERM >> 28] = 3,\r\n[RISC_WRITECM >> 28] = 3,\r\n[RISC_WRITECR >> 28] = 4,\r\n};\r\nstatic const char * const bits[] = {\r\n"12", "13", "14", "resync",\r\n"cnt0", "cnt1", "18", "19",\r\n"20", "21", "22", "23",\r\n"irq1", "irq2", "eol", "sol",\r\n};\r\nint i;\r\ndprintk0("0x%08x [ %s", risc,\r\ninstr[risc >> 28] ? instr[risc >> 28] : "INVALID");\r\nfor (i = ARRAY_SIZE(bits) - 1; i >= 0; i--)\r\nif (risc & (1 << (i + 12)))\r\npr_cont(" %s", bits[i]);\r\npr_cont(" count=%d ]\n", risc & 0xfff);\r\nreturn incr[risc >> 28] ? incr[risc >> 28] : 1;\r\n}\r\nvoid cx88_sram_channel_dump(struct cx88_core *core,\r\nconst struct sram_channel *ch)\r\n{\r\nstatic const char * const name[] = {\r\n"initial risc",\r\n"cdt base",\r\n"cdt size",\r\n"iq base",\r\n"iq size",\r\n"risc pc",\r\n"iq wr ptr",\r\n"iq rd ptr",\r\n"cdt current",\r\n"pci target",\r\n"line / byte",\r\n};\r\nu32 risc;\r\nunsigned int i, j, n;\r\ndprintk0("%s - dma channel status dump\n", ch->name);\r\nfor (i = 0; i < ARRAY_SIZE(name); i++)\r\ndprintk0(" cmds: %-12s: 0x%08x\n",\r\nname[i], cx_read(ch->cmds_start + 4 * i));\r\nfor (n = 1, i = 0; i < 4; i++) {\r\nrisc = cx_read(ch->cmds_start + 4 * (i + 11));\r\npr_cont(" risc%d: ", i);\r\nif (--n)\r\npr_cont("0x%08x [ arg #%d ]\n", risc, n);\r\nelse\r\nn = cx88_risc_decode(risc);\r\n}\r\nfor (i = 0; i < 16; i += n) {\r\nrisc = cx_read(ch->ctrl_start + 4 * i);\r\ndprintk0(" iq %x: ", i);\r\nn = cx88_risc_decode(risc);\r\nfor (j = 1; j < n; j++) {\r\nrisc = cx_read(ch->ctrl_start + 4 * (i + j));\r\npr_cont(" iq %x: 0x%08x [ arg #%d ]\n",\r\ni + j, risc, j);\r\n}\r\n}\r\ndprintk0("fifo: 0x%08x -> 0x%x\n",\r\nch->fifo_start, ch->fifo_start + ch->fifo_size);\r\ndprintk0("ctrl: 0x%08x -> 0x%x\n",\r\nch->ctrl_start, ch->ctrl_start + 6 * 16);\r\ndprintk0(" ptr1_reg: 0x%08x\n", cx_read(ch->ptr1_reg));\r\ndprintk0(" ptr2_reg: 0x%08x\n", cx_read(ch->ptr2_reg));\r\ndprintk0(" cnt1_reg: 0x%08x\n", cx_read(ch->cnt1_reg));\r\ndprintk0(" cnt2_reg: 0x%08x\n", cx_read(ch->cnt2_reg));\r\n}\r\nvoid cx88_print_irqbits(const char *tag, const char *strings[],\r\nint len, u32 bits, u32 mask)\r\n{\r\nunsigned int i;\r\ndprintk0("%s [0x%x]", tag, bits);\r\nfor (i = 0; i < len; i++) {\r\nif (!(bits & (1 << i)))\r\ncontinue;\r\nif (strings[i])\r\npr_cont(" %s", strings[i]);\r\nelse\r\npr_cont(" %d", i);\r\nif (!(mask & (1 << i)))\r\ncontinue;\r\npr_cont("*");\r\n}\r\npr_cont("\n");\r\n}\r\nint cx88_core_irq(struct cx88_core *core, u32 status)\r\n{\r\nint handled = 0;\r\nif (status & PCI_INT_IR_SMPINT) {\r\ncx88_ir_irq(core);\r\nhandled++;\r\n}\r\nif (!handled)\r\ncx88_print_irqbits("irq pci",\r\ncx88_pci_irqs, ARRAY_SIZE(cx88_pci_irqs),\r\nstatus, core->pci_irqmask);\r\nreturn handled;\r\n}\r\nvoid cx88_wakeup(struct cx88_core *core,\r\nstruct cx88_dmaqueue *q, u32 count)\r\n{\r\nstruct cx88_buffer *buf;\r\nbuf = list_entry(q->active.next,\r\nstruct cx88_buffer, list);\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nbuf->vb.field = core->field;\r\nbuf->vb.sequence = q->count++;\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nvoid cx88_shutdown(struct cx88_core *core)\r\n{\r\ncx_write(MO_DEV_CNTRL2, 0);\r\ncx_write(MO_VID_DMACNTRL, 0x0);\r\ncx_write(MO_AUD_DMACNTRL, 0x0);\r\ncx_write(MO_TS_DMACNTRL, 0x0);\r\ncx_write(MO_VIP_DMACNTRL, 0x0);\r\ncx_write(MO_GPHST_DMACNTRL, 0x0);\r\ncx_write(MO_PCI_INTMSK, 0x0);\r\ncx_write(MO_VID_INTMSK, 0x0);\r\ncx_write(MO_AUD_INTMSK, 0x0);\r\ncx_write(MO_TS_INTMSK, 0x0);\r\ncx_write(MO_VIP_INTMSK, 0x0);\r\ncx_write(MO_GPHST_INTMSK, 0x0);\r\ncx_write(VID_CAPTURE_CONTROL, 0);\r\n}\r\nint cx88_reset(struct cx88_core *core)\r\n{\r\ndprintk(1, "");\r\ncx88_shutdown(core);\r\ncx_write(MO_VID_INTSTAT, 0xFFFFFFFF);\r\ncx_write(MO_PCI_INTSTAT, 0xFFFFFFFF);\r\ncx_write(MO_INT1_STAT, 0xFFFFFFFF);\r\nmsleep(100);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],\r\n720 * 4, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH22], 128, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH23], 128, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH24], 128, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH25], 128, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH26], 128, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH28],\r\n188 * 4, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH27], 128, 0);\r\ncx_write(MO_INPUT_FORMAT, ((1 << 13) |\r\n(1 << 12) |\r\n(1 << 11) |\r\n(0 << 10) |\r\n(0 << 9) |\r\n(7)));\r\ncx_andor(MO_COLOR_CTRL, 0x4000, 0x4000);\r\ncx_write(MO_PDMA_STHRSH, 0x0807);\r\ncx_write(MO_PDMA_DTHRSH, 0x0807);\r\ncx_write(MO_AGC_SYNC_TIP1, 0x0380000F);\r\ncx_write(MO_AGC_BACK_VBI, 0x00E00555);\r\ncx_write(MO_VID_INTSTAT, 0xFFFFFFFF);\r\ncx_write(MO_PCI_INTSTAT, 0xFFFFFFFF);\r\ncx_write(MO_INT1_STAT, 0xFFFFFFFF);\r\ncx_write(MO_SRST_IO, 0);\r\nusleep_range(10000, 20000);\r\ncx_write(MO_SRST_IO, 1);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int norm_swidth(v4l2_std_id norm)\r\n{\r\nreturn (norm & (V4L2_STD_MN & ~V4L2_STD_PAL_Nc)) ? 754 : 922;\r\n}\r\nstatic inline unsigned int norm_hdelay(v4l2_std_id norm)\r\n{\r\nreturn (norm & (V4L2_STD_MN & ~V4L2_STD_PAL_Nc)) ? 135 : 186;\r\n}\r\nstatic inline unsigned int norm_vdelay(v4l2_std_id norm)\r\n{\r\nreturn (norm & V4L2_STD_625_50) ? 0x24 : 0x18;\r\n}\r\nstatic inline unsigned int norm_fsc8(v4l2_std_id norm)\r\n{\r\nif (norm & V4L2_STD_PAL_M)\r\nreturn 28604892;\r\nif (norm & (V4L2_STD_PAL_Nc))\r\nreturn 28656448;\r\nif (norm & V4L2_STD_NTSC)\r\nreturn 28636360;\r\nreturn 35468950;\r\n}\r\nstatic inline unsigned int norm_htotal(v4l2_std_id norm)\r\n{\r\nunsigned int fsc4 = norm_fsc8(norm) / 2;\r\nreturn (norm & V4L2_STD_625_50) ?\r\n((fsc4 + 312) / 625 + 12) / 25 :\r\n((fsc4 + 262) / 525 * 1001 + 15000) / 30000;\r\n}\r\nstatic inline unsigned int norm_vbipack(v4l2_std_id norm)\r\n{\r\nreturn (norm & V4L2_STD_625_50) ? 511 : 400;\r\n}\r\nint cx88_set_scale(struct cx88_core *core, unsigned int width,\r\nunsigned int height, enum v4l2_field field)\r\n{\r\nunsigned int swidth = norm_swidth(core->tvnorm);\r\nunsigned int sheight = norm_maxh(core->tvnorm);\r\nu32 value;\r\ndprintk(1, "set_scale: %dx%d [%s%s,%s]\n", width, height,\r\nV4L2_FIELD_HAS_TOP(field) ? "T" : "",\r\nV4L2_FIELD_HAS_BOTTOM(field) ? "B" : "",\r\nv4l2_norm_to_name(core->tvnorm));\r\nif (!V4L2_FIELD_HAS_BOTH(field))\r\nheight *= 2;\r\nvalue = (width * norm_hdelay(core->tvnorm)) / swidth;\r\nvalue &= 0x3fe;\r\ncx_write(MO_HDELAY_EVEN, value);\r\ncx_write(MO_HDELAY_ODD, value);\r\ndprintk(1, "set_scale: hdelay 0x%04x (width %d)\n", value, swidth);\r\nvalue = (swidth * 4096 / width) - 4096;\r\ncx_write(MO_HSCALE_EVEN, value);\r\ncx_write(MO_HSCALE_ODD, value);\r\ndprintk(1, "set_scale: hscale 0x%04x\n", value);\r\ncx_write(MO_HACTIVE_EVEN, width);\r\ncx_write(MO_HACTIVE_ODD, width);\r\ndprintk(1, "set_scale: hactive 0x%04x\n", width);\r\ncx_write(MO_VDELAY_EVEN, norm_vdelay(core->tvnorm));\r\ncx_write(MO_VDELAY_ODD, norm_vdelay(core->tvnorm));\r\ndprintk(1, "set_scale: vdelay 0x%04x\n", norm_vdelay(core->tvnorm));\r\nvalue = (0x10000 - (sheight * 512 / height - 512)) & 0x1fff;\r\ncx_write(MO_VSCALE_EVEN, value);\r\ncx_write(MO_VSCALE_ODD, value);\r\ndprintk(1, "set_scale: vscale 0x%04x\n", value);\r\ncx_write(MO_VACTIVE_EVEN, sheight);\r\ncx_write(MO_VACTIVE_ODD, sheight);\r\ndprintk(1, "set_scale: vactive 0x%04x\n", sheight);\r\nvalue = 0;\r\nvalue |= (1 << 19);\r\nif (core->tvnorm & V4L2_STD_SECAM) {\r\nvalue |= (1 << 15);\r\nvalue |= (1 << 16);\r\n}\r\nif (INPUT(core->input).type == CX88_VMUX_SVIDEO)\r\nvalue |= (1 << 13) | (1 << 5);\r\nif (field == V4L2_FIELD_INTERLACED)\r\nvalue |= (1 << 3);\r\nif (width < 385)\r\nvalue |= (1 << 0);\r\nif (width < 193)\r\nvalue |= (1 << 1);\r\nif (nocomb)\r\nvalue |= (3 << 5);\r\ncx_andor(MO_FILTER_EVEN, 0x7ffc7f, value);\r\ncx_andor(MO_FILTER_ODD, 0x7ffc7f, value);\r\ndprintk(1, "set_scale: filter 0x%04x\n", value);\r\nreturn 0;\r\n}\r\nstatic int set_pll(struct cx88_core *core, int prescale, u32 ofreq)\r\n{\r\nstatic const u32 pre[] = { 0, 0, 0, 3, 2, 1 };\r\nu64 pll;\r\nu32 reg;\r\nint i;\r\nif (prescale < 2)\r\nprescale = 2;\r\nif (prescale > 5)\r\nprescale = 5;\r\npll = ofreq * 8 * prescale * (u64)(1 << 20);\r\ndo_div(pll, xtal);\r\nreg = (pll & 0x3ffffff) | (pre[prescale] << 26);\r\nif (((reg >> 20) & 0x3f) < 14) {\r\npr_err("pll out of range\n");\r\nreturn -1;\r\n}\r\ndprintk(1, "set_pll: MO_PLL_REG 0x%08x [old=0x%08x,freq=%d]\n",\r\nreg, cx_read(MO_PLL_REG), ofreq);\r\ncx_write(MO_PLL_REG, reg);\r\nfor (i = 0; i < 100; i++) {\r\nreg = cx_read(MO_DEVICE_STATUS);\r\nif (reg & (1 << 2)) {\r\ndprintk(1, "pll locked [pre=%d,ofreq=%d]\n",\r\nprescale, ofreq);\r\nreturn 0;\r\n}\r\ndprintk(1, "pll not locked yet, waiting ...\n");\r\nusleep_range(10000, 20000);\r\n}\r\ndprintk(1, "pll NOT locked [pre=%d,ofreq=%d]\n", prescale, ofreq);\r\nreturn -1;\r\n}\r\nint cx88_start_audio_dma(struct cx88_core *core)\r\n{\r\nint bpl = cx88_sram_channels[SRAM_CH25].fifo_size / 4;\r\nint rds_bpl = cx88_sram_channels[SRAM_CH27].fifo_size / AUD_RDS_LINES;\r\nif (cx_read(MO_AUD_DMACNTRL) & 0x10)\r\nreturn 0;\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH25], bpl, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH26], bpl, 0);\r\ncx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH27],\r\nrds_bpl, 0);\r\ncx_write(MO_AUDD_LNGTH, bpl);\r\ncx_write(MO_AUDR_LNGTH, rds_bpl);\r\ncx_write(MO_AUD_DMACNTRL, 0x0007);\r\nreturn 0;\r\n}\r\nint cx88_stop_audio_dma(struct cx88_core *core)\r\n{\r\nif (cx_read(MO_AUD_DMACNTRL) & 0x10)\r\nreturn 0;\r\ncx_write(MO_AUD_DMACNTRL, 0x0000);\r\nreturn 0;\r\n}\r\nstatic int set_tvaudio(struct cx88_core *core)\r\n{\r\nv4l2_std_id norm = core->tvnorm;\r\nif (INPUT(core->input).type != CX88_VMUX_TELEVISION &&\r\nINPUT(core->input).type != CX88_VMUX_CABLE)\r\nreturn 0;\r\nif (V4L2_STD_PAL_BG & norm) {\r\ncore->tvaudio = WW_BG;\r\n} else if (V4L2_STD_PAL_DK & norm) {\r\ncore->tvaudio = WW_DK;\r\n} else if (V4L2_STD_PAL_I & norm) {\r\ncore->tvaudio = WW_I;\r\n} else if (V4L2_STD_SECAM_L & norm) {\r\ncore->tvaudio = WW_L;\r\n} else if ((V4L2_STD_SECAM_B | V4L2_STD_SECAM_G | V4L2_STD_SECAM_H) &\r\nnorm) {\r\ncore->tvaudio = WW_BG;\r\n} else if (V4L2_STD_SECAM_DK & norm) {\r\ncore->tvaudio = WW_DK;\r\n} else if ((V4L2_STD_NTSC_M & norm) ||\r\n(V4L2_STD_PAL_M & norm)) {\r\ncore->tvaudio = WW_BTSC;\r\n} else if (V4L2_STD_NTSC_M_JP & norm) {\r\ncore->tvaudio = WW_EIAJ;\r\n} else {\r\npr_info("tvaudio support needs work for this tv norm [%s], sorry\n",\r\nv4l2_norm_to_name(core->tvnorm));\r\ncore->tvaudio = WW_NONE;\r\nreturn 0;\r\n}\r\ncx_andor(MO_AFECFG_IO, 0x1f, 0x0);\r\ncx88_set_tvaudio(core);\r\ncx88_start_audio_dma(core);\r\nreturn 0;\r\n}\r\nint cx88_set_tvnorm(struct cx88_core *core, v4l2_std_id norm)\r\n{\r\nu32 fsc8;\r\nu32 adc_clock;\r\nu32 vdec_clock;\r\nu32 step_db, step_dr;\r\nu64 tmp64;\r\nu32 bdelay, agcdelay, htotal;\r\nu32 cxiformat, cxoformat;\r\nif (norm == core->tvnorm)\r\nreturn 0;\r\nif (core->v4ldev && (vb2_is_busy(&core->v4ldev->vb2_vidq) ||\r\nvb2_is_busy(&core->v4ldev->vb2_vbiq)))\r\nreturn -EBUSY;\r\nif (core->dvbdev && vb2_is_busy(&core->dvbdev->vb2_mpegq))\r\nreturn -EBUSY;\r\ncore->tvnorm = norm;\r\nfsc8 = norm_fsc8(norm);\r\nadc_clock = xtal;\r\nvdec_clock = fsc8;\r\nstep_db = fsc8;\r\nstep_dr = fsc8;\r\nif (norm & V4L2_STD_NTSC_M_JP) {\r\ncxiformat = VideoFormatNTSCJapan;\r\ncxoformat = 0x181f0008;\r\n} else if (norm & V4L2_STD_NTSC_443) {\r\ncxiformat = VideoFormatNTSC443;\r\ncxoformat = 0x181f0008;\r\n} else if (norm & V4L2_STD_PAL_M) {\r\ncxiformat = VideoFormatPALM;\r\ncxoformat = 0x1c1f0008;\r\n} else if (norm & V4L2_STD_PAL_N) {\r\ncxiformat = VideoFormatPALN;\r\ncxoformat = 0x1c1f0008;\r\n} else if (norm & V4L2_STD_PAL_Nc) {\r\ncxiformat = VideoFormatPALNC;\r\ncxoformat = 0x1c1f0008;\r\n} else if (norm & V4L2_STD_PAL_60) {\r\ncxiformat = VideoFormatPAL60;\r\ncxoformat = 0x181f0008;\r\n} else if (norm & V4L2_STD_NTSC) {\r\ncxiformat = VideoFormatNTSC;\r\ncxoformat = 0x181f0008;\r\n} else if (norm & V4L2_STD_SECAM) {\r\nstep_db = 4250000 * 8;\r\nstep_dr = 4406250 * 8;\r\ncxiformat = VideoFormatSECAM;\r\ncxoformat = 0x181f0008;\r\n} else {\r\ncxiformat = VideoFormatPAL;\r\ncxoformat = 0x181f0008;\r\n}\r\ndprintk(1, "set_tvnorm: \"%s\" fsc8=%d adc=%d vdec=%d db/dr=%d/%d\n",\r\nv4l2_norm_to_name(core->tvnorm), fsc8, adc_clock, vdec_clock,\r\nstep_db, step_dr);\r\nset_pll(core, 2, vdec_clock);\r\ndprintk(1, "set_tvnorm: MO_INPUT_FORMAT 0x%08x [old=0x%08x]\n",\r\ncxiformat, cx_read(MO_INPUT_FORMAT) & 0x0f);\r\ncx_andor(MO_INPUT_FORMAT, 0x40f,\r\nnorm & V4L2_STD_SECAM ? cxiformat : cxiformat | 0x400);\r\ndprintk(1, "set_tvnorm: MO_OUTPUT_FORMAT 0x%08x [old=0x%08x]\n",\r\ncxoformat, cx_read(MO_OUTPUT_FORMAT));\r\ncx_write(MO_OUTPUT_FORMAT, cxoformat);\r\ntmp64 = adc_clock * (u64)(1 << 17);\r\ndo_div(tmp64, vdec_clock);\r\ndprintk(1, "set_tvnorm: MO_SCONV_REG 0x%08x [old=0x%08x]\n",\r\n(u32)tmp64, cx_read(MO_SCONV_REG));\r\ncx_write(MO_SCONV_REG, (u32)tmp64);\r\ntmp64 = step_db * (u64)(1 << 22);\r\ndo_div(tmp64, vdec_clock);\r\ndprintk(1, "set_tvnorm: MO_SUB_STEP 0x%08x [old=0x%08x]\n",\r\n(u32)tmp64, cx_read(MO_SUB_STEP));\r\ncx_write(MO_SUB_STEP, (u32)tmp64);\r\ntmp64 = step_dr * (u64)(1 << 22);\r\ndo_div(tmp64, vdec_clock);\r\ndprintk(1, "set_tvnorm: MO_SUB_STEP_DR 0x%08x [old=0x%08x]\n",\r\n(u32)tmp64, cx_read(MO_SUB_STEP_DR));\r\ncx_write(MO_SUB_STEP_DR, (u32)tmp64);\r\nbdelay = vdec_clock * 65 / 20000000 + 21;\r\nagcdelay = vdec_clock * 68 / 20000000 + 15;\r\ndprintk(1,\r\n"set_tvnorm: MO_AGC_BURST 0x%08x [old=0x%08x,bdelay=%d,agcdelay=%d]\n",\r\n(bdelay << 8) | agcdelay, cx_read(MO_AGC_BURST),\r\nbdelay, agcdelay);\r\ncx_write(MO_AGC_BURST, (bdelay << 8) | agcdelay);\r\ntmp64 = norm_htotal(norm) * (u64)vdec_clock;\r\ndo_div(tmp64, fsc8);\r\nhtotal = (u32)tmp64;\r\ndprintk(1,\r\n"set_tvnorm: MO_HTOTAL 0x%08x [old=0x%08x,htotal=%d]\n",\r\nhtotal, cx_read(MO_HTOTAL), (u32)tmp64);\r\ncx_andor(MO_HTOTAL, 0x07ff, htotal);\r\ncx_write(MO_VBI_PACKET, (10 << 11) | norm_vbipack(norm));\r\ncx88_set_scale(core, 320, 240, V4L2_FIELD_INTERLACED);\r\nset_tvaudio(core);\r\ncall_all(core, video, s_std, norm);\r\nv4l2_ctrl_grab(core->chroma_agc, cxiformat == VideoFormatSECAM);\r\nreturn 0;\r\n}\r\nvoid cx88_vdev_init(struct cx88_core *core,\r\nstruct pci_dev *pci,\r\nstruct video_device *vfd,\r\nconst struct video_device *template_,\r\nconst char *type)\r\n{\r\n*vfd = *template_;\r\nvfd->v4l2_dev = &core->v4l2_dev;\r\nvfd->dev_parent = &pci->dev;\r\nvfd->release = video_device_release_empty;\r\nvfd->lock = &core->lock;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)",\r\ncore->name, type, core->board.name);\r\n}\r\nstruct cx88_core *cx88_core_get(struct pci_dev *pci)\r\n{\r\nstruct cx88_core *core;\r\nmutex_lock(&devlist);\r\nlist_for_each_entry(core, &cx88_devlist, devlist) {\r\nif (pci->bus->number != core->pci_bus)\r\ncontinue;\r\nif (PCI_SLOT(pci->devfn) != core->pci_slot)\r\ncontinue;\r\nif (cx88_get_resources(core, pci) != 0) {\r\nmutex_unlock(&devlist);\r\nreturn NULL;\r\n}\r\natomic_inc(&core->refcount);\r\nmutex_unlock(&devlist);\r\nreturn core;\r\n}\r\ncore = cx88_core_create(pci, cx88_devcount);\r\nif (core) {\r\ncx88_devcount++;\r\nlist_add_tail(&core->devlist, &cx88_devlist);\r\n}\r\nmutex_unlock(&devlist);\r\nreturn core;\r\n}\r\nvoid cx88_core_put(struct cx88_core *core, struct pci_dev *pci)\r\n{\r\nrelease_mem_region(pci_resource_start(pci, 0),\r\npci_resource_len(pci, 0));\r\nif (!atomic_dec_and_test(&core->refcount))\r\nreturn;\r\nmutex_lock(&devlist);\r\ncx88_ir_fini(core);\r\nif (core->i2c_rc == 0) {\r\nif (core->i2c_rtc)\r\ni2c_unregister_device(core->i2c_rtc);\r\ni2c_del_adapter(&core->i2c_adap);\r\n}\r\nlist_del(&core->devlist);\r\niounmap(core->lmmio);\r\ncx88_devcount--;\r\nmutex_unlock(&devlist);\r\nv4l2_ctrl_handler_free(&core->video_hdl);\r\nv4l2_ctrl_handler_free(&core->audio_hdl);\r\nv4l2_device_unregister(&core->v4l2_dev);\r\nkfree(core);\r\n}
