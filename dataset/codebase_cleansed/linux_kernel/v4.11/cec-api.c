static inline struct cec_devnode *cec_devnode_data(struct file *filp)\r\n{\r\nstruct cec_fh *fh = filp->private_data;\r\nreturn &fh->adap->devnode;\r\n}\r\nstatic unsigned int cec_poll(struct file *filp,\r\nstruct poll_table_struct *poll)\r\n{\r\nstruct cec_devnode *devnode = cec_devnode_data(filp);\r\nstruct cec_fh *fh = filp->private_data;\r\nstruct cec_adapter *adap = fh->adap;\r\nunsigned int res = 0;\r\nif (!devnode->registered)\r\nreturn POLLERR | POLLHUP;\r\nmutex_lock(&adap->lock);\r\nif (adap->is_configured &&\r\nadap->transmit_queue_sz < CEC_MAX_MSG_TX_QUEUE_SZ)\r\nres |= POLLOUT | POLLWRNORM;\r\nif (fh->queued_msgs)\r\nres |= POLLIN | POLLRDNORM;\r\nif (fh->pending_events)\r\nres |= POLLPRI;\r\npoll_wait(filp, &fh->wait, poll);\r\nmutex_unlock(&adap->lock);\r\nreturn res;\r\n}\r\nstatic bool cec_is_busy(const struct cec_adapter *adap,\r\nconst struct cec_fh *fh)\r\n{\r\nbool valid_initiator = adap->cec_initiator && adap->cec_initiator == fh;\r\nbool valid_follower = adap->cec_follower && adap->cec_follower == fh;\r\nif (valid_initiator || valid_follower)\r\nreturn false;\r\nreturn adap->cec_initiator ||\r\nfh->mode_initiator == CEC_MODE_NO_INITIATOR;\r\n}\r\nstatic long cec_adap_g_caps(struct cec_adapter *adap,\r\nstruct cec_caps __user *parg)\r\n{\r\nstruct cec_caps caps = {};\r\nstrlcpy(caps.driver, adap->devnode.dev.parent->driver->name,\r\nsizeof(caps.driver));\r\nstrlcpy(caps.name, adap->name, sizeof(caps.name));\r\ncaps.available_log_addrs = adap->available_log_addrs;\r\ncaps.capabilities = adap->capabilities;\r\ncaps.version = LINUX_VERSION_CODE;\r\nif (copy_to_user(parg, &caps, sizeof(caps)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_adap_g_phys_addr(struct cec_adapter *adap,\r\n__u16 __user *parg)\r\n{\r\nu16 phys_addr;\r\nmutex_lock(&adap->lock);\r\nphys_addr = adap->phys_addr;\r\nmutex_unlock(&adap->lock);\r\nif (copy_to_user(parg, &phys_addr, sizeof(phys_addr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_adap_s_phys_addr(struct cec_adapter *adap, struct cec_fh *fh,\r\nbool block, __u16 __user *parg)\r\n{\r\nu16 phys_addr;\r\nlong err;\r\nif (!(adap->capabilities & CEC_CAP_PHYS_ADDR))\r\nreturn -ENOTTY;\r\nif (copy_from_user(&phys_addr, parg, sizeof(phys_addr)))\r\nreturn -EFAULT;\r\nerr = cec_phys_addr_validate(phys_addr, NULL, NULL);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&adap->lock);\r\nif (cec_is_busy(adap, fh))\r\nerr = -EBUSY;\r\nelse\r\n__cec_s_phys_addr(adap, phys_addr, block);\r\nmutex_unlock(&adap->lock);\r\nreturn err;\r\n}\r\nstatic long cec_adap_g_log_addrs(struct cec_adapter *adap,\r\nstruct cec_log_addrs __user *parg)\r\n{\r\nstruct cec_log_addrs log_addrs;\r\nmutex_lock(&adap->lock);\r\nlog_addrs = adap->log_addrs;\r\nif (!adap->is_configured)\r\nmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\r\nsizeof(log_addrs.log_addr));\r\nmutex_unlock(&adap->lock);\r\nif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_adap_s_log_addrs(struct cec_adapter *adap, struct cec_fh *fh,\r\nbool block, struct cec_log_addrs __user *parg)\r\n{\r\nstruct cec_log_addrs log_addrs;\r\nlong err = -EBUSY;\r\nif (!(adap->capabilities & CEC_CAP_LOG_ADDRS))\r\nreturn -ENOTTY;\r\nif (copy_from_user(&log_addrs, parg, sizeof(log_addrs)))\r\nreturn -EFAULT;\r\nlog_addrs.flags &= CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK |\r\nCEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU |\r\nCEC_LOG_ADDRS_FL_CDC_ONLY;\r\nmutex_lock(&adap->lock);\r\nif (!adap->is_configuring &&\r\n(!log_addrs.num_log_addrs || !adap->is_configured) &&\r\n!cec_is_busy(adap, fh)) {\r\nerr = __cec_s_log_addrs(adap, &log_addrs, block);\r\nif (!err)\r\nlog_addrs = adap->log_addrs;\r\n}\r\nmutex_unlock(&adap->lock);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_transmit(struct cec_adapter *adap, struct cec_fh *fh,\r\nbool block, struct cec_msg __user *parg)\r\n{\r\nstruct cec_msg msg = {};\r\nlong err = 0;\r\nif (!(adap->capabilities & CEC_CAP_TRANSMIT))\r\nreturn -ENOTTY;\r\nif (copy_from_user(&msg, parg, sizeof(msg)))\r\nreturn -EFAULT;\r\nif ((adap->log_addrs.flags & CEC_LOG_ADDRS_FL_CDC_ONLY) &&\r\n(msg.len == 1 || msg.msg[1] != CEC_MSG_CDC_MESSAGE))\r\nreturn -EINVAL;\r\nmutex_lock(&adap->lock);\r\nif (!adap->is_configured)\r\nerr = -ENONET;\r\nelse if (cec_is_busy(adap, fh))\r\nerr = -EBUSY;\r\nelse\r\nerr = cec_transmit_msg_fh(adap, &msg, fh, block);\r\nmutex_unlock(&adap->lock);\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(parg, &msg, sizeof(msg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int cec_receive_msg(struct cec_fh *fh, struct cec_msg *msg, bool block)\r\n{\r\nu32 timeout = msg->timeout;\r\nint res;\r\ndo {\r\nmutex_lock(&fh->lock);\r\nif (fh->queued_msgs) {\r\nstruct cec_msg_entry *entry =\r\nlist_first_entry(&fh->msgs,\r\nstruct cec_msg_entry, list);\r\nlist_del(&entry->list);\r\n*msg = entry->msg;\r\nkfree(entry);\r\nfh->queued_msgs--;\r\nmutex_unlock(&fh->lock);\r\nmsg->timeout = timeout;\r\nreturn 0;\r\n}\r\nmutex_unlock(&fh->lock);\r\nif (!block)\r\nreturn -EAGAIN;\r\nif (msg->timeout) {\r\nres = wait_event_interruptible_timeout(fh->wait,\r\nfh->queued_msgs,\r\nmsecs_to_jiffies(msg->timeout));\r\nif (res == 0)\r\nres = -ETIMEDOUT;\r\nelse if (res > 0)\r\nres = 0;\r\n} else {\r\nres = wait_event_interruptible(fh->wait,\r\nfh->queued_msgs);\r\n}\r\n} while (!res);\r\nreturn res;\r\n}\r\nstatic long cec_receive(struct cec_adapter *adap, struct cec_fh *fh,\r\nbool block, struct cec_msg __user *parg)\r\n{\r\nstruct cec_msg msg = {};\r\nlong err = 0;\r\nif (copy_from_user(&msg, parg, sizeof(msg)))\r\nreturn -EFAULT;\r\nmutex_lock(&adap->lock);\r\nif (!adap->is_configured && fh->mode_follower < CEC_MODE_MONITOR)\r\nerr = -ENONET;\r\nmutex_unlock(&adap->lock);\r\nif (err)\r\nreturn err;\r\nerr = cec_receive_msg(fh, &msg, block);\r\nif (err)\r\nreturn err;\r\nmsg.flags = 0;\r\nif (copy_to_user(parg, &msg, sizeof(msg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_dqevent(struct cec_adapter *adap, struct cec_fh *fh,\r\nbool block, struct cec_event __user *parg)\r\n{\r\nstruct cec_event *ev = NULL;\r\nu64 ts = ~0ULL;\r\nunsigned int i;\r\nlong err = 0;\r\nmutex_lock(&fh->lock);\r\nwhile (!fh->pending_events && block) {\r\nmutex_unlock(&fh->lock);\r\nerr = wait_event_interruptible(fh->wait, fh->pending_events);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&fh->lock);\r\n}\r\nfor (i = 0; i < CEC_NUM_EVENTS; i++) {\r\nif (fh->pending_events & (1 << (i + 1)) &&\r\nfh->events[i].ts <= ts) {\r\nev = &fh->events[i];\r\nts = ev->ts;\r\n}\r\n}\r\nif (!ev) {\r\nerr = -EAGAIN;\r\ngoto unlock;\r\n}\r\nif (copy_to_user(parg, ev, sizeof(*ev))) {\r\nerr = -EFAULT;\r\ngoto unlock;\r\n}\r\nfh->pending_events &= ~(1 << ev->event);\r\nunlock:\r\nmutex_unlock(&fh->lock);\r\nreturn err;\r\n}\r\nstatic long cec_g_mode(struct cec_adapter *adap, struct cec_fh *fh,\r\nu32 __user *parg)\r\n{\r\nu32 mode = fh->mode_initiator | fh->mode_follower;\r\nif (copy_to_user(parg, &mode, sizeof(mode)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long cec_s_mode(struct cec_adapter *adap, struct cec_fh *fh,\r\nu32 __user *parg)\r\n{\r\nu32 mode;\r\nu8 mode_initiator;\r\nu8 mode_follower;\r\nlong err = 0;\r\nif (copy_from_user(&mode, parg, sizeof(mode)))\r\nreturn -EFAULT;\r\nif (mode & ~(CEC_MODE_INITIATOR_MSK | CEC_MODE_FOLLOWER_MSK))\r\nreturn -EINVAL;\r\nmode_initiator = mode & CEC_MODE_INITIATOR_MSK;\r\nmode_follower = mode & CEC_MODE_FOLLOWER_MSK;\r\nif (mode_initiator > CEC_MODE_EXCL_INITIATOR ||\r\nmode_follower > CEC_MODE_MONITOR_ALL)\r\nreturn -EINVAL;\r\nif (mode_follower == CEC_MODE_MONITOR_ALL &&\r\n!(adap->capabilities & CEC_CAP_MONITOR_ALL))\r\nreturn -EINVAL;\r\nif ((mode_initiator == CEC_MODE_NO_INITIATOR ||\r\n!(adap->capabilities & CEC_CAP_TRANSMIT)) &&\r\nmode_follower >= CEC_MODE_FOLLOWER &&\r\nmode_follower <= CEC_MODE_EXCL_FOLLOWER_PASSTHRU)\r\nreturn -EINVAL;\r\nif (mode_initiator && mode_follower >= CEC_MODE_MONITOR)\r\nreturn -EINVAL;\r\nif (mode_follower >= CEC_MODE_MONITOR && !capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&adap->lock);\r\nif ((mode_follower == CEC_MODE_EXCL_FOLLOWER ||\r\nmode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU) &&\r\nadap->cec_follower && adap->cec_follower != fh)\r\nerr = -EBUSY;\r\nif (mode_initiator == CEC_MODE_EXCL_INITIATOR &&\r\nadap->cec_initiator && adap->cec_initiator != fh)\r\nerr = -EBUSY;\r\nif (!err) {\r\nbool old_mon_all = fh->mode_follower == CEC_MODE_MONITOR_ALL;\r\nbool new_mon_all = mode_follower == CEC_MODE_MONITOR_ALL;\r\nif (old_mon_all != new_mon_all) {\r\nif (new_mon_all)\r\nerr = cec_monitor_all_cnt_inc(adap);\r\nelse\r\ncec_monitor_all_cnt_dec(adap);\r\n}\r\n}\r\nif (err) {\r\nmutex_unlock(&adap->lock);\r\nreturn err;\r\n}\r\nif (fh->mode_follower == CEC_MODE_FOLLOWER)\r\nadap->follower_cnt--;\r\nif (mode_follower == CEC_MODE_FOLLOWER)\r\nadap->follower_cnt++;\r\nif (mode_follower == CEC_MODE_EXCL_FOLLOWER ||\r\nmode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU) {\r\nadap->passthrough =\r\nmode_follower == CEC_MODE_EXCL_FOLLOWER_PASSTHRU;\r\nadap->cec_follower = fh;\r\n} else if (adap->cec_follower == fh) {\r\nadap->passthrough = false;\r\nadap->cec_follower = NULL;\r\n}\r\nif (mode_initiator == CEC_MODE_EXCL_INITIATOR)\r\nadap->cec_initiator = fh;\r\nelse if (adap->cec_initiator == fh)\r\nadap->cec_initiator = NULL;\r\nfh->mode_initiator = mode_initiator;\r\nfh->mode_follower = mode_follower;\r\nmutex_unlock(&adap->lock);\r\nreturn 0;\r\n}\r\nstatic long cec_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct cec_devnode *devnode = cec_devnode_data(filp);\r\nstruct cec_fh *fh = filp->private_data;\r\nstruct cec_adapter *adap = fh->adap;\r\nbool block = !(filp->f_flags & O_NONBLOCK);\r\nvoid __user *parg = (void __user *)arg;\r\nif (!devnode->registered)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase CEC_ADAP_G_CAPS:\r\nreturn cec_adap_g_caps(adap, parg);\r\ncase CEC_ADAP_G_PHYS_ADDR:\r\nreturn cec_adap_g_phys_addr(adap, parg);\r\ncase CEC_ADAP_S_PHYS_ADDR:\r\nreturn cec_adap_s_phys_addr(adap, fh, block, parg);\r\ncase CEC_ADAP_G_LOG_ADDRS:\r\nreturn cec_adap_g_log_addrs(adap, parg);\r\ncase CEC_ADAP_S_LOG_ADDRS:\r\nreturn cec_adap_s_log_addrs(adap, fh, block, parg);\r\ncase CEC_TRANSMIT:\r\nreturn cec_transmit(adap, fh, block, parg);\r\ncase CEC_RECEIVE:\r\nreturn cec_receive(adap, fh, block, parg);\r\ncase CEC_DQEVENT:\r\nreturn cec_dqevent(adap, fh, block, parg);\r\ncase CEC_G_MODE:\r\nreturn cec_g_mode(adap, fh, parg);\r\ncase CEC_S_MODE:\r\nreturn cec_s_mode(adap, fh, parg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int cec_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct cec_devnode *devnode =\r\ncontainer_of(inode->i_cdev, struct cec_devnode, cdev);\r\nstruct cec_adapter *adap = to_cec_adapter(devnode);\r\nstruct cec_fh *fh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nstruct cec_event ev_state = {\r\n.event = CEC_EVENT_STATE_CHANGE,\r\n.flags = CEC_EVENT_FL_INITIAL_STATE,\r\n};\r\nint err;\r\nif (!fh)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&fh->msgs);\r\nINIT_LIST_HEAD(&fh->xfer_list);\r\nmutex_init(&fh->lock);\r\ninit_waitqueue_head(&fh->wait);\r\nfh->mode_initiator = CEC_MODE_INITIATOR;\r\nfh->adap = adap;\r\nerr = cec_get_device(devnode);\r\nif (err) {\r\nkfree(fh);\r\nreturn err;\r\n}\r\nfilp->private_data = fh;\r\nmutex_lock(&devnode->lock);\r\nev_state.state_change.phys_addr = adap->phys_addr;\r\nev_state.state_change.log_addr_mask = adap->log_addrs.log_addr_mask;\r\ncec_queue_event_fh(fh, &ev_state, 0);\r\nlist_add(&fh->list, &devnode->fhs);\r\nmutex_unlock(&devnode->lock);\r\nreturn 0;\r\n}\r\nstatic int cec_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct cec_devnode *devnode = cec_devnode_data(filp);\r\nstruct cec_adapter *adap = to_cec_adapter(devnode);\r\nstruct cec_fh *fh = filp->private_data;\r\nmutex_lock(&adap->lock);\r\nif (adap->cec_initiator == fh)\r\nadap->cec_initiator = NULL;\r\nif (adap->cec_follower == fh) {\r\nadap->cec_follower = NULL;\r\nadap->passthrough = false;\r\n}\r\nif (fh->mode_follower == CEC_MODE_FOLLOWER)\r\nadap->follower_cnt--;\r\nif (fh->mode_follower == CEC_MODE_MONITOR_ALL)\r\ncec_monitor_all_cnt_dec(adap);\r\nmutex_unlock(&adap->lock);\r\nmutex_lock(&devnode->lock);\r\nlist_del(&fh->list);\r\nmutex_unlock(&devnode->lock);\r\nmutex_lock(&adap->lock);\r\nwhile (!list_empty(&fh->xfer_list)) {\r\nstruct cec_data *data =\r\nlist_first_entry(&fh->xfer_list, struct cec_data, xfer_list);\r\ndata->blocking = false;\r\ndata->fh = NULL;\r\nlist_del(&data->xfer_list);\r\n}\r\nmutex_unlock(&adap->lock);\r\nwhile (!list_empty(&fh->msgs)) {\r\nstruct cec_msg_entry *entry =\r\nlist_first_entry(&fh->msgs, struct cec_msg_entry, list);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nkfree(fh);\r\ncec_put_device(devnode);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}
