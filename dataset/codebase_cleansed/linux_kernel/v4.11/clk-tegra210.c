void tegra210_xusb_pll_hw_control_enable(void)\r\n{\r\nu32 val;\r\nval = readl_relaxed(clk_base + XUSBIO_PLL_CFG0);\r\nval &= ~(XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL |\r\nXUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL);\r\nval |= XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET |\r\nXUSBIO_PLL_CFG0_PADPLL_SLEEP_IDDQ;\r\nwritel_relaxed(val, clk_base + XUSBIO_PLL_CFG0);\r\n}\r\nvoid tegra210_xusb_pll_hw_sequence_start(void)\r\n{\r\nu32 val;\r\nval = readl_relaxed(clk_base + XUSBIO_PLL_CFG0);\r\nval |= XUSBIO_PLL_CFG0_SEQ_ENABLE;\r\nwritel_relaxed(val, clk_base + XUSBIO_PLL_CFG0);\r\n}\r\nvoid tegra210_sata_pll_hw_control_enable(void)\r\n{\r\nu32 val;\r\nval = readl_relaxed(clk_base + SATA_PLL_CFG0);\r\nval &= ~SATA_PLL_CFG0_PADPLL_RESET_SWCTL;\r\nval |= SATA_PLL_CFG0_PADPLL_USE_LOCKDET |\r\nSATA_PLL_CFG0_PADPLL_SLEEP_IDDQ;\r\nwritel_relaxed(val, clk_base + SATA_PLL_CFG0);\r\n}\r\nvoid tegra210_sata_pll_hw_sequence_start(void)\r\n{\r\nu32 val;\r\nval = readl_relaxed(clk_base + SATA_PLL_CFG0);\r\nval |= SATA_PLL_CFG0_SEQ_ENABLE;\r\nwritel_relaxed(val, clk_base + SATA_PLL_CFG0);\r\n}\r\nstatic inline void _pll_misc_chk_default(void __iomem *base,\r\nstruct tegra_clk_pll_params *params,\r\nu8 misc_num, u32 default_val, u32 mask)\r\n{\r\nu32 boot_val = readl_relaxed(base + params->ext_misc_reg[misc_num]);\r\nboot_val &= mask;\r\ndefault_val &= mask;\r\nif (boot_val != default_val) {\r\npr_warn("boot misc%d 0x%x: expected 0x%x\n",\r\nmisc_num, boot_val, default_val);\r\npr_warn(" (comparison mask = 0x%x)\n", mask);\r\nparams->defaults_set = false;\r\n}\r\n}\r\nstatic void pllcx_check_defaults(struct tegra_clk_pll_params *params)\r\n{\r\nu32 default_val;\r\ndefault_val = PLLCX_MISC0_DEFAULT_VALUE & (~PLLCX_MISC0_RESET);\r\n_pll_misc_chk_default(clk_base, params, 0, default_val,\r\nPLLCX_MISC0_WRITE_MASK);\r\ndefault_val = PLLCX_MISC1_DEFAULT_VALUE & (~PLLCX_MISC1_IDDQ);\r\n_pll_misc_chk_default(clk_base, params, 1, default_val,\r\nPLLCX_MISC1_WRITE_MASK);\r\ndefault_val = PLLCX_MISC2_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, params, 2, default_val,\r\nPLLCX_MISC2_WRITE_MASK);\r\ndefault_val = PLLCX_MISC3_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, params, 3, default_val,\r\nPLLCX_MISC3_WRITE_MASK);\r\n}\r\nstatic void tegra210_pllcx_set_defaults(const char *name,\r\nstruct tegra_clk_pll *pllcx)\r\n{\r\npllcx->params->defaults_set = true;\r\nif (readl_relaxed(clk_base + pllcx->params->base_reg) &\r\nPLL_ENABLE) {\r\npllcx_check_defaults(pllcx->params);\r\npr_warn("%s already enabled. Postponing set full defaults\n",\r\nname);\r\nreturn;\r\n}\r\nwritel_relaxed(PLLCX_MISC0_DEFAULT_VALUE,\r\nclk_base + pllcx->params->ext_misc_reg[0]);\r\nwritel_relaxed(PLLCX_MISC1_DEFAULT_VALUE,\r\nclk_base + pllcx->params->ext_misc_reg[1]);\r\nwritel_relaxed(PLLCX_MISC2_DEFAULT_VALUE,\r\nclk_base + pllcx->params->ext_misc_reg[2]);\r\nwritel_relaxed(PLLCX_MISC3_DEFAULT_VALUE,\r\nclk_base + pllcx->params->ext_misc_reg[3]);\r\nudelay(1);\r\n}\r\nstatic void _pllc_set_defaults(struct tegra_clk_pll *pllcx)\r\n{\r\ntegra210_pllcx_set_defaults("PLL_C", pllcx);\r\n}\r\nstatic void _pllc2_set_defaults(struct tegra_clk_pll *pllcx)\r\n{\r\ntegra210_pllcx_set_defaults("PLL_C2", pllcx);\r\n}\r\nstatic void _pllc3_set_defaults(struct tegra_clk_pll *pllcx)\r\n{\r\ntegra210_pllcx_set_defaults("PLL_C3", pllcx);\r\n}\r\nstatic void _plla1_set_defaults(struct tegra_clk_pll *pllcx)\r\n{\r\ntegra210_pllcx_set_defaults("PLL_A1", pllcx);\r\n}\r\nstatic void tegra210_plla_set_defaults(struct tegra_clk_pll *plla)\r\n{\r\nu32 mask;\r\nu32 val = readl_relaxed(clk_base + plla->params->base_reg);\r\nplla->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\nif (val & PLLA_BASE_IDDQ) {\r\npr_warn("PLL_A boot enabled with IDDQ set\n");\r\nplla->params->defaults_set = false;\r\n}\r\npr_warn("PLL_A already enabled. Postponing set full defaults\n");\r\nval = PLLA_MISC0_DEFAULT_VALUE;\r\nmask = PLLA_MISC0_LOCK_ENABLE | PLLA_MISC0_LOCK_OVERRIDE;\r\n_pll_misc_chk_default(clk_base, plla->params, 0, val,\r\n~mask & PLLA_MISC0_WRITE_MASK);\r\nval = PLLA_MISC2_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, plla->params, 2, val,\r\nPLLA_MISC2_EN_DYNRAMP);\r\nval = readl_relaxed(clk_base + plla->params->ext_misc_reg[0]);\r\nval &= ~mask;\r\nval |= PLLA_MISC0_DEFAULT_VALUE & mask;\r\nwritel_relaxed(val, clk_base + plla->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nval |= PLLA_BASE_IDDQ;\r\nwritel_relaxed(val, clk_base + plla->params->base_reg);\r\nwritel_relaxed(PLLA_MISC0_DEFAULT_VALUE,\r\nclk_base + plla->params->ext_misc_reg[0]);\r\nwritel_relaxed(PLLA_MISC2_DEFAULT_VALUE,\r\nclk_base + plla->params->ext_misc_reg[2]);\r\nudelay(1);\r\n}\r\nstatic void tegra210_plld_set_defaults(struct tegra_clk_pll *plld)\r\n{\r\nu32 val;\r\nu32 mask = 0xffff;\r\nplld->params->defaults_set = true;\r\nif (readl_relaxed(clk_base + plld->params->base_reg) &\r\nPLL_ENABLE) {\r\npr_warn("PLL_D already enabled. Postponing set full defaults\n");\r\nval = PLLD_MISC1_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, plld->params, 1,\r\nval, PLLD_MISC1_WRITE_MASK);\r\nval = PLLD_MISC0_DEFAULT_VALUE & (~PLLD_MISC0_IDDQ);\r\nmask |= PLLD_MISC0_DSI_CLKENABLE | PLLD_MISC0_LOCK_ENABLE |\r\nPLLD_MISC0_LOCK_OVERRIDE | PLLD_MISC0_EN_SDM;\r\n_pll_misc_chk_default(clk_base, plld->params, 0, val,\r\n~mask & PLLD_MISC0_WRITE_MASK);\r\nmask = PLLD_MISC0_LOCK_ENABLE | PLLD_MISC0_LOCK_OVERRIDE;\r\nval = readl_relaxed(clk_base + plld->params->ext_misc_reg[0]);\r\nval &= ~mask;\r\nval |= PLLD_MISC0_DEFAULT_VALUE & mask;\r\nwritel_relaxed(val, clk_base + plld->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nval = readl_relaxed(clk_base + plld->params->ext_misc_reg[0]);\r\nval &= PLLD_MISC0_DSI_CLKENABLE;\r\nval |= PLLD_MISC0_DEFAULT_VALUE;\r\nwritel_relaxed(val, clk_base + plld->params->ext_misc_reg[0]);\r\nwritel_relaxed(PLLD_MISC1_DEFAULT_VALUE, clk_base +\r\nplld->params->ext_misc_reg[1]);\r\nudelay(1);\r\n}\r\nstatic void plldss_defaults(const char *pll_name, struct tegra_clk_pll *plldss,\r\nu32 misc0_val, u32 misc1_val, u32 misc2_val, u32 misc3_val)\r\n{\r\nu32 default_val;\r\nu32 val = readl_relaxed(clk_base + plldss->params->base_reg);\r\nplldss->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\npr_warn("%s already enabled. Postponing set full defaults\n",\r\npll_name);\r\nif (val & PLLDSS_BASE_IDDQ) {\r\npr_warn("plldss boot enabled with IDDQ set\n");\r\nplldss->params->defaults_set = false;\r\n}\r\ndefault_val = misc0_val;\r\n_pll_misc_chk_default(clk_base, plldss->params, 0, default_val,\r\nPLLDSS_MISC0_WRITE_MASK &\r\n(~PLLDSS_MISC0_LOCK_ENABLE));\r\nif (plldss->params->ssc_ctrl_en_mask) {\r\ndefault_val = misc1_val;\r\n_pll_misc_chk_default(clk_base, plldss->params, 1,\r\ndefault_val, PLLDSS_MISC1_CFG_WRITE_MASK);\r\ndefault_val = misc2_val;\r\n_pll_misc_chk_default(clk_base, plldss->params, 2,\r\ndefault_val, PLLDSS_MISC2_CTRL1_WRITE_MASK);\r\ndefault_val = misc3_val;\r\n_pll_misc_chk_default(clk_base, plldss->params, 3,\r\ndefault_val, PLLDSS_MISC3_CTRL2_WRITE_MASK);\r\n} else if (plldss->params->ext_misc_reg[1]) {\r\ndefault_val = misc1_val;\r\n_pll_misc_chk_default(clk_base, plldss->params, 1,\r\ndefault_val, PLLDSS_MISC1_CFG_WRITE_MASK &\r\n(~PLLDSS_MISC1_CFG_EN_SDM));\r\n}\r\nif (val & PLLDSS_BASE_LOCK_OVERRIDE) {\r\nval &= ~PLLDSS_BASE_LOCK_OVERRIDE;\r\nwritel_relaxed(val, clk_base +\r\nplldss->params->base_reg);\r\n}\r\nval = readl_relaxed(clk_base + plldss->params->ext_misc_reg[0]);\r\nval &= ~PLLDSS_MISC0_LOCK_ENABLE;\r\nval |= misc0_val & PLLDSS_MISC0_LOCK_ENABLE;\r\nwritel_relaxed(val, clk_base + plldss->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nval |= PLLDSS_BASE_IDDQ;\r\nval &= ~PLLDSS_BASE_LOCK_OVERRIDE;\r\nwritel_relaxed(val, clk_base + plldss->params->base_reg);\r\nif (!plldss->params->ext_misc_reg[1]) {\r\nwritel_relaxed(misc0_val, clk_base +\r\nplldss->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nwritel_relaxed(misc0_val, clk_base +\r\nplldss->params->ext_misc_reg[0]);\r\nwritel_relaxed(misc1_val & (~PLLDSS_MISC1_CFG_EN_SSC),\r\nclk_base + plldss->params->ext_misc_reg[1]);\r\nwritel_relaxed(misc2_val, clk_base + plldss->params->ext_misc_reg[2]);\r\nwritel_relaxed(misc3_val, clk_base + plldss->params->ext_misc_reg[3]);\r\nudelay(1);\r\n}\r\nstatic void tegra210_plld2_set_defaults(struct tegra_clk_pll *plld2)\r\n{\r\nplldss_defaults("PLL_D2", plld2, PLLD2_MISC0_DEFAULT_VALUE,\r\nPLLD2_MISC1_CFG_DEFAULT_VALUE,\r\nPLLD2_MISC2_CTRL1_DEFAULT_VALUE,\r\nPLLD2_MISC3_CTRL2_DEFAULT_VALUE);\r\n}\r\nstatic void tegra210_plldp_set_defaults(struct tegra_clk_pll *plldp)\r\n{\r\nplldss_defaults("PLL_DP", plldp, PLLDP_MISC0_DEFAULT_VALUE,\r\nPLLDP_MISC1_CFG_DEFAULT_VALUE,\r\nPLLDP_MISC2_CTRL1_DEFAULT_VALUE,\r\nPLLDP_MISC3_CTRL2_DEFAULT_VALUE);\r\n}\r\nstatic void tegra210_pllc4_set_defaults(struct tegra_clk_pll *pllc4)\r\n{\r\nplldss_defaults("PLL_C4", pllc4, PLLC4_MISC0_DEFAULT_VALUE, 0, 0, 0);\r\n}\r\nstatic void tegra210_pllre_set_defaults(struct tegra_clk_pll *pllre)\r\n{\r\nu32 mask;\r\nu32 val = readl_relaxed(clk_base + pllre->params->base_reg);\r\npllre->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\npr_warn("PLL_RE already enabled. Postponing set full defaults\n");\r\nval &= PLLRE_BASE_DEFAULT_MASK;\r\nif (val != PLLRE_BASE_DEFAULT_VALUE) {\r\npr_warn("pllre boot base 0x%x : expected 0x%x\n",\r\nval, PLLRE_BASE_DEFAULT_VALUE);\r\npr_warn("(comparison mask = 0x%x)\n",\r\nPLLRE_BASE_DEFAULT_MASK);\r\npllre->params->defaults_set = false;\r\n}\r\nval = PLLRE_MISC0_DEFAULT_VALUE & (~PLLRE_MISC0_IDDQ);\r\nmask = PLLRE_MISC0_LOCK_ENABLE | PLLRE_MISC0_LOCK_OVERRIDE;\r\n_pll_misc_chk_default(clk_base, pllre->params, 0, val,\r\n~mask & PLLRE_MISC0_WRITE_MASK);\r\nval = readl_relaxed(clk_base + pllre->params->ext_misc_reg[0]);\r\nval &= ~mask;\r\nval |= PLLRE_MISC0_DEFAULT_VALUE & mask;\r\nwritel_relaxed(val, clk_base + pllre->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nval &= ~PLLRE_BASE_DEFAULT_MASK;\r\nval |= PLLRE_BASE_DEFAULT_VALUE & PLLRE_BASE_DEFAULT_MASK;\r\nwritel_relaxed(val, clk_base + pllre->params->base_reg);\r\nwritel_relaxed(PLLRE_MISC0_DEFAULT_VALUE,\r\nclk_base + pllre->params->ext_misc_reg[0]);\r\nudelay(1);\r\n}\r\nstatic void pllx_get_dyn_steps(struct clk_hw *hw, u32 *step_a, u32 *step_b)\r\n{\r\nunsigned long input_rate;\r\nif (!IS_ERR_OR_NULL(hw->clk))\r\ninput_rate = clk_hw_get_rate(clk_hw_get_parent(hw));\r\nelse\r\ninput_rate = 38400000;\r\ninput_rate /= tegra_pll_get_fixed_mdiv(hw, input_rate);\r\nswitch (input_rate) {\r\ncase 12000000:\r\ncase 12800000:\r\ncase 13000000:\r\n*step_a = 0x2B;\r\n*step_b = 0x0B;\r\nreturn;\r\ncase 19200000:\r\n*step_a = 0x12;\r\n*step_b = 0x08;\r\nreturn;\r\ncase 38400000:\r\n*step_a = 0x04;\r\n*step_b = 0x05;\r\nreturn;\r\ndefault:\r\npr_err("%s: Unexpected reference rate %lu\n",\r\n__func__, input_rate);\r\nBUG();\r\n}\r\n}\r\nstatic void pllx_check_defaults(struct tegra_clk_pll *pll)\r\n{\r\nu32 default_val;\r\ndefault_val = PLLX_MISC0_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, pll->params, 0, default_val,\r\nPLLX_MISC0_WRITE_MASK & (~PLLX_MISC0_LOCK_ENABLE));\r\ndefault_val = PLLX_MISC1_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, pll->params, 1, default_val,\r\nPLLX_MISC1_WRITE_MASK);\r\ndefault_val = PLLX_MISC2_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, pll->params, 2,\r\ndefault_val, PLLX_MISC2_EN_DYNRAMP);\r\ndefault_val = PLLX_MISC3_DEFAULT_VALUE & (~PLLX_MISC3_IDDQ);\r\n_pll_misc_chk_default(clk_base, pll->params, 3, default_val,\r\nPLLX_MISC3_WRITE_MASK);\r\ndefault_val = PLLX_MISC4_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, pll->params, 4, default_val,\r\nPLLX_MISC4_WRITE_MASK);\r\ndefault_val = PLLX_MISC5_DEFAULT_VALUE;\r\n_pll_misc_chk_default(clk_base, pll->params, 5, default_val,\r\nPLLX_MISC5_WRITE_MASK);\r\n}\r\nstatic void tegra210_pllx_set_defaults(struct tegra_clk_pll *pllx)\r\n{\r\nu32 val;\r\nu32 step_a, step_b;\r\npllx->params->defaults_set = true;\r\npllx_get_dyn_steps(&pllx->hw, &step_a, &step_b);\r\nval = PLLX_MISC2_DEFAULT_VALUE & (~PLLX_MISC2_DYNRAMP_STEPA_MASK) &\r\n(~PLLX_MISC2_DYNRAMP_STEPB_MASK);\r\nval |= step_a << PLLX_MISC2_DYNRAMP_STEPA_SHIFT;\r\nval |= step_b << PLLX_MISC2_DYNRAMP_STEPB_SHIFT;\r\nif (readl_relaxed(clk_base + pllx->params->base_reg) & PLL_ENABLE) {\r\npr_warn("PLL_X already enabled. Postponing set full defaults\n");\r\npllx_check_defaults(pllx);\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\r\nval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[0]);\r\nval &= ~PLLX_MISC0_LOCK_ENABLE;\r\nval |= PLLX_MISC0_DEFAULT_VALUE & PLLX_MISC0_LOCK_ENABLE;\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nwritel_relaxed(PLLX_MISC0_DEFAULT_VALUE, clk_base +\r\npllx->params->ext_misc_reg[0]);\r\nwritel_relaxed(PLLX_MISC1_DEFAULT_VALUE, clk_base +\r\npllx->params->ext_misc_reg[1]);\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\r\nwritel_relaxed(PLLX_MISC3_DEFAULT_VALUE, clk_base +\r\npllx->params->ext_misc_reg[3]);\r\nwritel_relaxed(PLLX_MISC4_DEFAULT_VALUE, clk_base +\r\npllx->params->ext_misc_reg[4]);\r\nwritel_relaxed(PLLX_MISC5_DEFAULT_VALUE, clk_base +\r\npllx->params->ext_misc_reg[5]);\r\nudelay(1);\r\n}\r\nstatic void tegra210_pllmb_set_defaults(struct tegra_clk_pll *pllmb)\r\n{\r\nu32 mask, val = readl_relaxed(clk_base + pllmb->params->base_reg);\r\npllmb->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\npr_warn("PLL_MB already enabled. Postponing set full defaults\n");\r\nval = PLLMB_MISC1_DEFAULT_VALUE & (~PLLMB_MISC1_IDDQ);\r\nmask = PLLMB_MISC1_LOCK_ENABLE | PLLMB_MISC1_LOCK_OVERRIDE;\r\n_pll_misc_chk_default(clk_base, pllmb->params, 0, val,\r\n~mask & PLLMB_MISC1_WRITE_MASK);\r\nval = readl_relaxed(clk_base + pllmb->params->ext_misc_reg[0]);\r\nval &= ~mask;\r\nval |= PLLMB_MISC1_DEFAULT_VALUE & mask;\r\nwritel_relaxed(val, clk_base + pllmb->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nwritel_relaxed(PLLMB_MISC1_DEFAULT_VALUE,\r\nclk_base + pllmb->params->ext_misc_reg[0]);\r\nudelay(1);\r\n}\r\nstatic void pllp_check_defaults(struct tegra_clk_pll *pll, bool enabled)\r\n{\r\nu32 val, mask;\r\nval = PLLP_MISC0_DEFAULT_VALUE & (~PLLP_MISC0_IDDQ);\r\nmask = PLLP_MISC0_LOCK_ENABLE | PLLP_MISC0_LOCK_OVERRIDE;\r\nif (!enabled)\r\nmask |= PLLP_MISC0_IDDQ;\r\n_pll_misc_chk_default(clk_base, pll->params, 0, val,\r\n~mask & PLLP_MISC0_WRITE_MASK);\r\nval = PLLP_MISC1_DEFAULT_VALUE;\r\nmask = PLLP_MISC1_HSIO_EN | PLLP_MISC1_XUSB_EN;\r\n_pll_misc_chk_default(clk_base, pll->params, 1, val,\r\n~mask & PLLP_MISC1_WRITE_MASK);\r\n}\r\nstatic void tegra210_pllp_set_defaults(struct tegra_clk_pll *pllp)\r\n{\r\nu32 mask;\r\nu32 val = readl_relaxed(clk_base + pllp->params->base_reg);\r\npllp->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\npr_warn("PLL_P already enabled. Postponing set full defaults\n");\r\npllp_check_defaults(pllp, true);\r\nval = readl_relaxed(clk_base + pllp->params->ext_misc_reg[0]);\r\nmask = PLLP_MISC0_LOCK_ENABLE | PLLP_MISC0_LOCK_OVERRIDE;\r\nval &= ~mask;\r\nval |= PLLP_MISC0_DEFAULT_VALUE & mask;\r\nwritel_relaxed(val, clk_base + pllp->params->ext_misc_reg[0]);\r\nudelay(1);\r\nreturn;\r\n}\r\nwritel_relaxed(PLLP_MISC0_DEFAULT_VALUE,\r\nclk_base + pllp->params->ext_misc_reg[0]);\r\nval = readl_relaxed(clk_base + pllp->params->ext_misc_reg[1]);\r\nmask = PLLP_MISC1_HSIO_EN | PLLP_MISC1_XUSB_EN;\r\nval &= mask;\r\nval |= ~mask & PLLP_MISC1_DEFAULT_VALUE;\r\nwritel_relaxed(val, clk_base + pllp->params->ext_misc_reg[1]);\r\nudelay(1);\r\n}\r\nstatic void pllu_check_defaults(struct tegra_clk_pll *pll, bool hw_control)\r\n{\r\nu32 val, mask;\r\nval = PLLU_MISC0_DEFAULT_VALUE & (~PLLU_MISC0_IDDQ);\r\nmask = PLLU_MISC0_LOCK_ENABLE | (hw_control ? PLLU_MISC0_IDDQ : 0);\r\n_pll_misc_chk_default(clk_base, pll->params, 0, val,\r\n~mask & PLLU_MISC0_WRITE_MASK);\r\nval = PLLU_MISC1_DEFAULT_VALUE;\r\nmask = PLLU_MISC1_LOCK_OVERRIDE;\r\n_pll_misc_chk_default(clk_base, pll->params, 1, val,\r\n~mask & PLLU_MISC1_WRITE_MASK);\r\n}\r\nstatic void tegra210_pllu_set_defaults(struct tegra_clk_pll *pllu)\r\n{\r\nu32 val = readl_relaxed(clk_base + pllu->params->base_reg);\r\npllu->params->defaults_set = true;\r\nif (val & PLL_ENABLE) {\r\npr_warn("PLL_U already enabled. Postponing set full defaults\n");\r\npllu_check_defaults(pllu, false);\r\nval = readl_relaxed(clk_base + pllu->params->ext_misc_reg[0]);\r\nval &= ~PLLU_MISC0_LOCK_ENABLE;\r\nval |= PLLU_MISC0_DEFAULT_VALUE & PLLU_MISC0_LOCK_ENABLE;\r\nwritel_relaxed(val, clk_base + pllu->params->ext_misc_reg[0]);\r\nval = readl_relaxed(clk_base + pllu->params->ext_misc_reg[1]);\r\nval &= ~PLLU_MISC1_LOCK_OVERRIDE;\r\nval |= PLLU_MISC1_DEFAULT_VALUE & PLLU_MISC1_LOCK_OVERRIDE;\r\nwritel_relaxed(val, clk_base + pllu->params->ext_misc_reg[1]);\r\nudelay(1);\r\nreturn;\r\n}\r\nwritel_relaxed(PLLU_MISC0_DEFAULT_VALUE,\r\nclk_base + pllu->params->ext_misc_reg[0]);\r\nwritel_relaxed(PLLU_MISC1_DEFAULT_VALUE,\r\nclk_base + pllu->params->ext_misc_reg[1]);\r\nudelay(1);\r\n}\r\nstatic int tegra210_wait_for_mask(struct tegra_clk_pll *pll,\r\nu32 reg, u32 mask)\r\n{\r\nint i;\r\nu32 val = 0;\r\nfor (i = 0; i < pll->params->lock_delay / PLL_LOCKDET_DELAY + 1; i++) {\r\nudelay(PLL_LOCKDET_DELAY);\r\nval = readl_relaxed(clk_base + reg);\r\nif ((val & mask) == mask) {\r\nudelay(PLL_LOCKDET_DELAY);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra210_pllx_dyn_ramp(struct tegra_clk_pll *pllx,\r\nstruct tegra_clk_pll_freq_table *cfg)\r\n{\r\nu32 val, base, ndiv_new_mask;\r\nndiv_new_mask = (divn_mask(pllx) >> pllx->params->div_nmp->divn_shift)\r\n<< PLLX_MISC2_NDIV_NEW_SHIFT;\r\nval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[2]);\r\nval &= (~ndiv_new_mask);\r\nval |= cfg->n << PLLX_MISC2_NDIV_NEW_SHIFT;\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\r\nudelay(1);\r\nval = readl_relaxed(clk_base + pllx->params->ext_misc_reg[2]);\r\nval |= PLLX_MISC2_EN_DYNRAMP;\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\r\nudelay(1);\r\ntegra210_wait_for_mask(pllx, pllx->params->ext_misc_reg[2],\r\nPLLX_MISC2_DYNRAMP_DONE);\r\nbase = readl_relaxed(clk_base + pllx->params->base_reg) &\r\n(~divn_mask_shifted(pllx));\r\nbase |= cfg->n << pllx->params->div_nmp->divn_shift;\r\nwritel_relaxed(base, clk_base + pllx->params->base_reg);\r\nudelay(1);\r\nval &= ~PLLX_MISC2_EN_DYNRAMP;\r\nwritel_relaxed(val, clk_base + pllx->params->ext_misc_reg[2]);\r\nudelay(1);\r\npr_debug("%s: dynamic ramp to m = %u n = %u p = %u, Fout = %lu kHz\n",\r\n__clk_get_name(pllx->hw.clk), cfg->m, cfg->n, cfg->p,\r\ncfg->input_rate / cfg->m * cfg->n /\r\npllx->params->pdiv_tohw[cfg->p].pdiv / 1000);\r\nreturn 0;\r\n}\r\nstatic int tegra210_pll_fixed_mdiv_cfg(struct clk_hw *hw,\r\nstruct tegra_clk_pll_freq_table *cfg,\r\nunsigned long rate, unsigned long input_rate)\r\n{\r\nstruct tegra_clk_pll *pll = to_clk_pll(hw);\r\nstruct tegra_clk_pll_params *params = pll->params;\r\nint p;\r\nunsigned long cf, p_rate;\r\nu32 pdiv;\r\nif (!rate)\r\nreturn -EINVAL;\r\nif (!(params->flags & TEGRA_PLL_VCO_OUT)) {\r\np = DIV_ROUND_UP(params->vco_min, rate);\r\np = params->round_p_to_pdiv(p, &pdiv);\r\n} else {\r\np = rate >= params->vco_min ? 1 : -EINVAL;\r\n}\r\nif (p < 0)\r\nreturn -EINVAL;\r\ncfg->m = tegra_pll_get_fixed_mdiv(hw, input_rate);\r\ncfg->p = p;\r\ncfg->p = tegra_pll_p_div_to_hw(pll, cfg->p);\r\np_rate = rate * p;\r\nif (p_rate > params->vco_max)\r\np_rate = params->vco_max;\r\ncf = input_rate / cfg->m;\r\ncfg->n = p_rate / cf;\r\ncfg->sdm_data = 0;\r\nif (params->sdm_ctrl_reg) {\r\nunsigned long rem = p_rate - cf * cfg->n;\r\nif (rem || params->ssc_ctrl_reg) {\r\nu64 s = rem * PLL_SDM_COEFF;\r\ndo_div(s, cf);\r\ns -= PLL_SDM_COEFF / 2;\r\ncfg->sdm_data = sdin_din_to_data(s);\r\n}\r\n}\r\ncfg->input_rate = input_rate;\r\ncfg->output_rate = rate;\r\nreturn 0;\r\n}\r\nstatic void tegra210_clk_pll_set_gain(struct tegra_clk_pll_freq_table *cfg)\r\n{\r\ncfg->n = cfg->n * PLL_SDM_COEFF + PLL_SDM_COEFF/2 +\r\nsdin_data_to_din(cfg->sdm_data);\r\ncfg->m *= PLL_SDM_COEFF;\r\n}\r\nstatic unsigned long\r\ntegra210_clk_adjust_vco_min(struct tegra_clk_pll_params *params,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long vco_min = params->vco_min;\r\nparams->vco_min += DIV_ROUND_UP(parent_rate, PLL_SDM_COEFF);\r\nvco_min = min(vco_min, params->vco_min);\r\nreturn vco_min;\r\n}\r\nstatic u32 pll_qlin_p_to_pdiv(u32 p, u32 *pdiv)\r\n{\r\nint i;\r\nif (p) {\r\nfor (i = 0; i <= PLL_QLIN_PDIV_MAX; i++) {\r\nif (p <= pll_qlin_pdiv_to_hw[i].pdiv) {\r\nif (pdiv)\r\n*pdiv = i;\r\nreturn pll_qlin_pdiv_to_hw[i].pdiv;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 pll_expo_p_to_pdiv(u32 p, u32 *pdiv)\r\n{\r\nif (p) {\r\nu32 i = fls(p);\r\nif (i == ffs(p))\r\ni--;\r\nif (i <= PLL_EXPO_PDIV_MAX) {\r\nif (pdiv)\r\n*pdiv = i;\r\nreturn 1 << i;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic __init void tegra210_periph_clk_init(void __iomem *clk_base,\r\nvoid __iomem *pmc_base)\r\n{\r\nstruct clk *clk;\r\nclk = clk_register_fixed_factor(NULL, "xusb_ss_div2", "xusb_ss_src", 0,\r\n1, 2);\r\nclks[TEGRA210_CLK_XUSB_SS_DIV2] = clk;\r\nclk = tegra_clk_register_periph_fixed("sor_safe", "pll_p", 0, clk_base,\r\n1, 17, 222);\r\nclks[TEGRA210_CLK_SOR_SAFE] = clk;\r\nclk = tegra_clk_register_periph_fixed("dpaux", "sor_safe", 0, clk_base,\r\n1, 17, 181);\r\nclks[TEGRA210_CLK_DPAUX] = clk;\r\nclk = tegra_clk_register_periph_fixed("dpaux1", "sor_safe", 0, clk_base,\r\n1, 17, 207);\r\nclks[TEGRA210_CLK_DPAUX1] = clk;\r\nclk = clk_register_gate(NULL, "pll_d_dsi_out", "pll_d_out0", 0,\r\nclk_base + PLLD_MISC0, 21, 0, &pll_d_lock);\r\nclks[TEGRA210_CLK_PLL_D_DSI_OUT] = clk;\r\nclk = tegra_clk_register_periph_gate("dsia", "pll_d_dsi_out", 0,\r\nclk_base, 0, 48,\r\nperiph_clk_enb_refcnt);\r\nclks[TEGRA210_CLK_DSIA] = clk;\r\nclk = tegra_clk_register_periph_gate("dsib", "pll_d_dsi_out", 0,\r\nclk_base, 0, 82,\r\nperiph_clk_enb_refcnt);\r\nclks[TEGRA210_CLK_DSIB] = clk;\r\nclk = clk_register_mux(NULL, "emc_mux", mux_pllmcp_clkm,\r\nARRAY_SIZE(mux_pllmcp_clkm), 0,\r\nclk_base + CLK_SOURCE_EMC,\r\n29, 3, 0, &emc_lock);\r\nclk = tegra_clk_register_mc("mc", "emc_mux", clk_base + CLK_SOURCE_EMC,\r\n&emc_lock);\r\nclks[TEGRA210_CLK_MC] = clk;\r\nclk = clk_register_gate(NULL, "cml0", "pll_e", 0, clk_base + PLLE_AUX,\r\n0, 0, &pll_e_lock);\r\nclk_register_clkdev(clk, "cml0", NULL);\r\nclks[TEGRA210_CLK_CML0] = clk;\r\nclk = clk_register_gate(NULL, "cml1", "pll_e", 0, clk_base + PLLE_AUX,\r\n1, 0, &pll_e_lock);\r\nclk_register_clkdev(clk, "cml1", NULL);\r\nclks[TEGRA210_CLK_CML1] = clk;\r\ntegra_periph_clk_init(clk_base, pmc_base, tegra210_clks, &pll_p_params);\r\n}\r\nstatic void __init tegra210_pll_init(void __iomem *clk_base,\r\nvoid __iomem *pmc)\r\n{\r\nstruct clk *clk;\r\nclk = tegra_clk_register_pllxc_tegra210("pll_c", "pll_ref", clk_base,\r\npmc, 0, &pll_c_params, NULL);\r\nif (!WARN_ON(IS_ERR(clk)))\r\nclk_register_clkdev(clk, "pll_c", NULL);\r\nclks[TEGRA210_CLK_PLL_C] = clk;\r\nclk = tegra_clk_register_divider("pll_c_out1_div", "pll_c",\r\nclk_base + PLLC_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\r\n8, 8, 1, NULL);\r\nclk = tegra_clk_register_pll_out("pll_c_out1", "pll_c_out1_div",\r\nclk_base + PLLC_OUT, 1, 0,\r\nCLK_SET_RATE_PARENT, 0, NULL);\r\nclk_register_clkdev(clk, "pll_c_out1", NULL);\r\nclks[TEGRA210_CLK_PLL_C_OUT1] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_c_ud", "pll_c",\r\nCLK_SET_RATE_PARENT, 1, 1);\r\nclk_register_clkdev(clk, "pll_c_ud", NULL);\r\nclks[TEGRA210_CLK_PLL_C_UD] = clk;\r\nclk = tegra_clk_register_pllc_tegra210("pll_c2", "pll_ref", clk_base,\r\npmc, 0, &pll_c2_params, NULL);\r\nclk_register_clkdev(clk, "pll_c2", NULL);\r\nclks[TEGRA210_CLK_PLL_C2] = clk;\r\nclk = tegra_clk_register_pllc_tegra210("pll_c3", "pll_ref", clk_base,\r\npmc, 0, &pll_c3_params, NULL);\r\nclk_register_clkdev(clk, "pll_c3", NULL);\r\nclks[TEGRA210_CLK_PLL_C3] = clk;\r\nclk = tegra_clk_register_pllm("pll_m", "osc", clk_base, pmc,\r\nCLK_SET_RATE_GATE, &pll_m_params, NULL);\r\nclk_register_clkdev(clk, "pll_m", NULL);\r\nclks[TEGRA210_CLK_PLL_M] = clk;\r\nclk = tegra_clk_register_pllmb("pll_mb", "osc", clk_base, pmc,\r\nCLK_SET_RATE_GATE, &pll_mb_params, NULL);\r\nclk_register_clkdev(clk, "pll_mb", NULL);\r\nclks[TEGRA210_CLK_PLL_MB] = clk;\r\nclk_register_clkdev(clk, "pll_m_out1", NULL);\r\nclks[TEGRA210_CLK_PLL_M_OUT1] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_m_ud", "pll_m",\r\nCLK_SET_RATE_PARENT, 1, 1);\r\nclk_register_clkdev(clk, "pll_m_ud", NULL);\r\nclks[TEGRA210_CLK_PLL_M_UD] = clk;\r\nclk = tegra_clk_register_pllu_tegra210("pll_u_vco", "pll_ref",\r\nclk_base, 0, &pll_u_vco_params,\r\n&pll_u_lock);\r\nclk_register_clkdev(clk, "pll_u_vco", NULL);\r\nclks[TEGRA210_CLK_PLL_U] = clk;\r\nclk = clk_register_divider_table(NULL, "pll_u_out", "pll_u_vco", 0,\r\nclk_base + PLLU_BASE, 16, 4, 0,\r\npll_vco_post_div_table, NULL);\r\nclk_register_clkdev(clk, "pll_u_out", NULL);\r\nclks[TEGRA210_CLK_PLL_U_OUT] = clk;\r\nclk = tegra_clk_register_divider("pll_u_out1_div", "pll_u_out",\r\nclk_base + PLLU_OUTA, 0,\r\nTEGRA_DIVIDER_ROUND_UP,\r\n8, 8, 1, &pll_u_lock);\r\nclk = tegra_clk_register_pll_out("pll_u_out1", "pll_u_out1_div",\r\nclk_base + PLLU_OUTA, 1, 0,\r\nCLK_SET_RATE_PARENT, 0, &pll_u_lock);\r\nclk_register_clkdev(clk, "pll_u_out1", NULL);\r\nclks[TEGRA210_CLK_PLL_U_OUT1] = clk;\r\nclk = tegra_clk_register_divider("pll_u_out2_div", "pll_u_out",\r\nclk_base + PLLU_OUTA, 0,\r\nTEGRA_DIVIDER_ROUND_UP,\r\n24, 8, 1, &pll_u_lock);\r\nclk = tegra_clk_register_pll_out("pll_u_out2", "pll_u_out2_div",\r\nclk_base + PLLU_OUTA, 17, 16,\r\nCLK_SET_RATE_PARENT, 0, &pll_u_lock);\r\nclk_register_clkdev(clk, "pll_u_out2", NULL);\r\nclks[TEGRA210_CLK_PLL_U_OUT2] = clk;\r\nclk = clk_register_gate(NULL, "pll_u_480M", "pll_u_vco",\r\nCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\r\n22, 0, &pll_u_lock);\r\nclk_register_clkdev(clk, "pll_u_480M", NULL);\r\nclks[TEGRA210_CLK_PLL_U_480M] = clk;\r\nclk = clk_register_gate(NULL, "pll_u_60M", "pll_u_out2",\r\nCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\r\n23, 0, NULL);\r\nclk_register_clkdev(clk, "pll_u_60M", NULL);\r\nclks[TEGRA210_CLK_PLL_U_60M] = clk;\r\nclk = clk_register_gate(NULL, "pll_u_48M", "pll_u_out1",\r\nCLK_SET_RATE_PARENT, clk_base + PLLU_BASE,\r\n25, 0, NULL);\r\nclk_register_clkdev(clk, "pll_u_48M", NULL);\r\nclks[TEGRA210_CLK_PLL_U_48M] = clk;\r\nclk = tegra_clk_register_pll("pll_d", "pll_ref", clk_base, pmc, 0,\r\n&pll_d_params, &pll_d_lock);\r\nclk_register_clkdev(clk, "pll_d", NULL);\r\nclks[TEGRA210_CLK_PLL_D] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_d_out0", "pll_d",\r\nCLK_SET_RATE_PARENT, 1, 2);\r\nclk_register_clkdev(clk, "pll_d_out0", NULL);\r\nclks[TEGRA210_CLK_PLL_D_OUT0] = clk;\r\nclk = tegra_clk_register_pllre_tegra210("pll_re_vco", "pll_ref",\r\nclk_base, pmc, 0,\r\n&pll_re_vco_params,\r\n&pll_re_lock, pll_ref_freq);\r\nclk_register_clkdev(clk, "pll_re_vco", NULL);\r\nclks[TEGRA210_CLK_PLL_RE_VCO] = clk;\r\nclk = clk_register_divider_table(NULL, "pll_re_out", "pll_re_vco", 0,\r\nclk_base + PLLRE_BASE, 16, 5, 0,\r\npll_vco_post_div_table, &pll_re_lock);\r\nclk_register_clkdev(clk, "pll_re_out", NULL);\r\nclks[TEGRA210_CLK_PLL_RE_OUT] = clk;\r\nclk = tegra_clk_register_divider("pll_re_out1_div", "pll_re_vco",\r\nclk_base + PLLRE_OUT1, 0,\r\nTEGRA_DIVIDER_ROUND_UP,\r\n8, 8, 1, NULL);\r\nclk = tegra_clk_register_pll_out("pll_re_out1", "pll_re_out1_div",\r\nclk_base + PLLRE_OUT1, 1, 0,\r\nCLK_SET_RATE_PARENT, 0, NULL);\r\nclks[TEGRA210_CLK_PLL_RE_OUT1] = clk;\r\nclk = tegra_clk_register_plle_tegra210("pll_e", "pll_ref",\r\nclk_base, 0, &pll_e_params, NULL);\r\nclk_register_clkdev(clk, "pll_e", NULL);\r\nclks[TEGRA210_CLK_PLL_E] = clk;\r\nclk = tegra_clk_register_pllre("pll_c4_vco", "pll_ref", clk_base, pmc,\r\n0, &pll_c4_vco_params, NULL, pll_ref_freq);\r\nclk_register_clkdev(clk, "pll_c4_vco", NULL);\r\nclks[TEGRA210_CLK_PLL_C4] = clk;\r\nclk = clk_register_divider_table(NULL, "pll_c4_out0", "pll_c4_vco", 0,\r\nclk_base + PLLC4_BASE, 19, 4, 0,\r\npll_vco_post_div_table, NULL);\r\nclk_register_clkdev(clk, "pll_c4_out0", NULL);\r\nclks[TEGRA210_CLK_PLL_C4_OUT0] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_c4_out1", "pll_c4_vco",\r\nCLK_SET_RATE_PARENT, 1, 3);\r\nclk_register_clkdev(clk, "pll_c4_out1", NULL);\r\nclks[TEGRA210_CLK_PLL_C4_OUT1] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_c4_out2", "pll_c4_vco",\r\nCLK_SET_RATE_PARENT, 1, 5);\r\nclk_register_clkdev(clk, "pll_c4_out2", NULL);\r\nclks[TEGRA210_CLK_PLL_C4_OUT2] = clk;\r\nclk = tegra_clk_register_divider("pll_c4_out3_div", "pll_c4_out0",\r\nclk_base + PLLC4_OUT, 0, TEGRA_DIVIDER_ROUND_UP,\r\n8, 8, 1, NULL);\r\nclk = tegra_clk_register_pll_out("pll_c4_out3", "pll_c4_out3_div",\r\nclk_base + PLLC4_OUT, 1, 0,\r\nCLK_SET_RATE_PARENT, 0, NULL);\r\nclk_register_clkdev(clk, "pll_c4_out3", NULL);\r\nclks[TEGRA210_CLK_PLL_C4_OUT3] = clk;\r\nclk = tegra_clk_register_pllss_tegra210("pll_dp", "pll_ref", clk_base,\r\n0, &pll_dp_params, NULL);\r\nclk_register_clkdev(clk, "pll_dp", NULL);\r\nclks[TEGRA210_CLK_PLL_DP] = clk;\r\nclk = tegra_clk_register_pllss_tegra210("pll_d2", "pll_ref", clk_base,\r\n0, &pll_d2_params, NULL);\r\nclk_register_clkdev(clk, "pll_d2", NULL);\r\nclks[TEGRA210_CLK_PLL_D2] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_d2_out0", "pll_d2",\r\nCLK_SET_RATE_PARENT, 1, 1);\r\nclk_register_clkdev(clk, "pll_d2_out0", NULL);\r\nclks[TEGRA210_CLK_PLL_D2_OUT0] = clk;\r\nclk = clk_register_fixed_factor(NULL, "pll_p_out2", "pll_p",\r\nCLK_SET_RATE_PARENT, 1, 2);\r\nclk_register_clkdev(clk, "pll_p_out2", NULL);\r\nclks[TEGRA210_CLK_PLL_P_OUT2] = clk;\r\n}\r\nstatic void tegra210_wait_cpu_in_reset(u32 cpu)\r\n{\r\nunsigned int reg;\r\ndo {\r\nreg = readl(clk_base + CLK_RST_CONTROLLER_CPU_CMPLX_STATUS);\r\ncpu_relax();\r\n} while (!(reg & (1 << cpu)));\r\n}\r\nstatic void tegra210_disable_cpu_clock(u32 cpu)\r\n{\r\n}\r\nstatic void tegra210_cpu_clock_suspend(void)\r\n{\r\ntegra210_cpu_clk_sctx.clk_csite_src =\r\nreadl(clk_base + CLK_SOURCE_CSITE);\r\nwritel(3 << 30, clk_base + CLK_SOURCE_CSITE);\r\n}\r\nstatic void tegra210_cpu_clock_resume(void)\r\n{\r\nwritel(tegra210_cpu_clk_sctx.clk_csite_src,\r\nclk_base + CLK_SOURCE_CSITE);\r\n}\r\nstatic void __init tegra210_clock_apply_init_table(void)\r\n{\r\ntegra_init_from_table(init_table, clks, TEGRA210_CLK_CLK_MAX);\r\n}\r\nstatic void __init tegra210_clock_init(struct device_node *np)\r\n{\r\nstruct device_node *node;\r\nu32 value, clk_m_div;\r\nclk_base = of_iomap(np, 0);\r\nif (!clk_base) {\r\npr_err("ioremap tegra210 CAR failed\n");\r\nreturn;\r\n}\r\nnode = of_find_matching_node(NULL, pmc_match);\r\nif (!node) {\r\npr_err("Failed to find pmc node\n");\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npmc_base = of_iomap(node, 0);\r\nif (!pmc_base) {\r\npr_err("Can't map pmc registers\n");\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nclks = tegra_clk_init(clk_base, TEGRA210_CLK_CLK_MAX,\r\nTEGRA210_CAR_BANK_COUNT);\r\nif (!clks)\r\nreturn;\r\nvalue = clk_readl(clk_base + SPARE_REG0) >> CLK_M_DIVISOR_SHIFT;\r\nclk_m_div = (value & CLK_M_DIVISOR_MASK) + 1;\r\nif (tegra_osc_clk_init(clk_base, tegra210_clks, tegra210_input_freq,\r\nARRAY_SIZE(tegra210_input_freq), clk_m_div,\r\n&osc_freq, &pll_ref_freq) < 0)\r\nreturn;\r\ntegra_fixed_clk_init(tegra210_clks);\r\ntegra210_pll_init(clk_base, pmc_base);\r\ntegra210_periph_clk_init(clk_base, pmc_base);\r\ntegra_audio_clk_init(clk_base, pmc_base, tegra210_clks,\r\ntegra210_audio_plls,\r\nARRAY_SIZE(tegra210_audio_plls));\r\ntegra_pmc_clk_init(pmc_base, tegra210_clks);\r\nvalue = clk_readl(clk_base + PLLD_BASE);\r\nvalue &= ~BIT(25);\r\nclk_writel(value, clk_base + PLLD_BASE);\r\ntegra_clk_apply_init_table = tegra210_clock_apply_init_table;\r\ntegra_super_clk_gen5_init(clk_base, pmc_base, tegra210_clks,\r\n&pll_x_params);\r\ntegra_add_of_provider(np);\r\ntegra_register_devclks(devclks, ARRAY_SIZE(devclks));\r\ntegra_cpu_car_ops = &tegra210_cpu_car_ops;\r\n}
