static int cs_etm_parse_snapshot_options(struct auxtrace_record *itr,\r\nstruct record_opts *opts,\r\nconst char *str)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nunsigned long long snapshot_size = 0;\r\nchar *endptr;\r\nif (str) {\r\nsnapshot_size = strtoull(str, &endptr, 0);\r\nif (*endptr || snapshot_size > SIZE_MAX)\r\nreturn -1;\r\n}\r\nopts->auxtrace_snapshot_mode = true;\r\nopts->auxtrace_snapshot_size = snapshot_size;\r\nptr->snapshot_size = snapshot_size;\r\nreturn 0;\r\n}\r\nstatic int cs_etm_recording_options(struct auxtrace_record *itr,\r\nstruct perf_evlist *evlist,\r\nstruct record_opts *opts)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\r\nstruct perf_evsel *evsel, *cs_etm_evsel = NULL;\r\nconst struct cpu_map *cpus = evlist->cpus;\r\nbool privileged = (geteuid() == 0 || perf_event_paranoid() < 0);\r\nptr->evlist = evlist;\r\nptr->snapshot_mode = opts->auxtrace_snapshot_mode;\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (evsel->attr.type == cs_etm_pmu->type) {\r\nif (cs_etm_evsel) {\r\npr_err("There may be only one %s event\n",\r\nCORESIGHT_ETM_PMU_NAME);\r\nreturn -EINVAL;\r\n}\r\nevsel->attr.freq = 0;\r\nevsel->attr.sample_period = 1;\r\ncs_etm_evsel = evsel;\r\nopts->full_auxtrace = true;\r\n}\r\n}\r\nif (!cs_etm_evsel)\r\nreturn 0;\r\nif (opts->use_clockid) {\r\npr_err("Cannot use clockid (-k option) with %s\n",\r\nCORESIGHT_ETM_PMU_NAME);\r\nreturn -EINVAL;\r\n}\r\nif (opts->auxtrace_snapshot_mode) {\r\nif (!opts->auxtrace_snapshot_size &&\r\n!opts->auxtrace_mmap_pages) {\r\nif (privileged) {\r\nopts->auxtrace_mmap_pages = MiB(4) / page_size;\r\n} else {\r\nopts->auxtrace_mmap_pages =\r\nKiB(128) / page_size;\r\nif (opts->mmap_pages == UINT_MAX)\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\n} else if (!opts->auxtrace_mmap_pages && !privileged &&\r\nopts->mmap_pages == UINT_MAX) {\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\nif (!opts->auxtrace_snapshot_size) {\r\nopts->auxtrace_snapshot_size =\r\nopts->auxtrace_mmap_pages * (size_t)page_size;\r\n}\r\nif (!opts->auxtrace_mmap_pages) {\r\nsize_t sz = opts->auxtrace_snapshot_size;\r\nsz = round_up(sz, page_size) / page_size;\r\nopts->auxtrace_mmap_pages = roundup_pow_of_two(sz);\r\n}\r\nif (opts->auxtrace_snapshot_size >\r\nopts->auxtrace_mmap_pages * (size_t)page_size) {\r\npr_err("Snapshot size %zu must not be greater than AUX area tracing mmap size %zu\n",\r\nopts->auxtrace_snapshot_size,\r\nopts->auxtrace_mmap_pages * (size_t)page_size);\r\nreturn -EINVAL;\r\n}\r\nif (!opts->auxtrace_snapshot_size ||\r\n!opts->auxtrace_mmap_pages) {\r\npr_err("Failed to calculate default snapshot size and/or AUX area tracing mmap pages\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (opts->full_auxtrace && !opts->auxtrace_mmap_pages) {\r\nif (privileged) {\r\nopts->auxtrace_mmap_pages = MiB(4) / page_size;\r\n} else {\r\nopts->auxtrace_mmap_pages = KiB(128) / page_size;\r\nif (opts->mmap_pages == UINT_MAX)\r\nopts->mmap_pages = KiB(256) / page_size;\r\n}\r\n}\r\nif (opts->auxtrace_mmap_pages) {\r\nunsigned int max_page = (KiB(128) / page_size);\r\nsize_t sz = opts->auxtrace_mmap_pages * (size_t)page_size;\r\nif (!privileged &&\r\nopts->auxtrace_mmap_pages > max_page) {\r\nopts->auxtrace_mmap_pages = max_page;\r\npr_err("auxtrace too big, truncating to %d\n",\r\nmax_page);\r\n}\r\nif (!is_power_of_2(sz)) {\r\npr_err("Invalid mmap size for %s: must be a power of 2\n",\r\nCORESIGHT_ETM_PMU_NAME);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (opts->auxtrace_snapshot_mode)\r\npr_debug2("%s snapshot size: %zu\n", CORESIGHT_ETM_PMU_NAME,\r\nopts->auxtrace_snapshot_size);\r\nif (cs_etm_evsel) {\r\nperf_evlist__to_front(evlist, cs_etm_evsel);\r\nif (!cpu_map__empty(cpus))\r\nperf_evsel__set_sample_bit(cs_etm_evsel, CPU);\r\n}\r\nif (opts->full_auxtrace) {\r\nstruct perf_evsel *tracking_evsel;\r\nint err;\r\nerr = parse_events(evlist, "dummy:u", NULL);\r\nif (err)\r\nreturn err;\r\ntracking_evsel = perf_evlist__last(evlist);\r\nperf_evlist__set_tracking_event(evlist, tracking_evsel);\r\ntracking_evsel->attr.freq = 0;\r\ntracking_evsel->attr.sample_period = 1;\r\nif (!cpu_map__empty(cpus))\r\nperf_evsel__set_sample_bit(tracking_evsel, TIME);\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 cs_etm_get_config(struct auxtrace_record *itr)\r\n{\r\nu64 config = 0;\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\r\nstruct perf_evlist *evlist = ptr->evlist;\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(evlist, evsel) {\r\nif (evsel->attr.type == cs_etm_pmu->type) {\r\nconfig = evsel->attr.config;\r\nbreak;\r\n}\r\n}\r\nreturn config;\r\n}\r\nstatic size_t\r\ncs_etm_info_priv_size(struct auxtrace_record *itr __maybe_unused,\r\nstruct perf_evlist *evlist __maybe_unused)\r\n{\r\nint i;\r\nint etmv3 = 0, etmv4 = 0;\r\nconst struct cpu_map *cpus = evlist->cpus;\r\nif (!cpu_map__empty(cpus)) {\r\nfor (i = 0; i < cpu_map__nr(cpus); i++) {\r\nif (cs_etm_is_etmv4(itr, cpus->map[i]))\r\netmv4++;\r\nelse\r\netmv3++;\r\n}\r\n} else {\r\nfor (i = 0; i < cpu__max_cpu(); i++) {\r\nif (cs_etm_is_etmv4(itr, i))\r\netmv4++;\r\nelse\r\netmv3++;\r\n}\r\n}\r\nreturn (CS_ETM_HEADER_SIZE +\r\n(etmv4 * CS_ETMV4_PRIV_SIZE) +\r\n(etmv3 * CS_ETMV3_PRIV_SIZE));\r\n}\r\nstatic bool cs_etm_is_etmv4(struct auxtrace_record *itr, int cpu)\r\n{\r\nbool ret = false;\r\nchar path[PATH_MAX];\r\nint scan;\r\nunsigned int val;\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\r\nsnprintf(path, PATH_MAX, "cpu%d/%s",\r\ncpu, metadata_etmv4_ro[CS_ETMV4_TRCIDR0]);\r\nscan = perf_pmu__scan_file(cs_etm_pmu, path, "%x", &val);\r\nif (scan == 1)\r\nret = true;\r\nreturn ret;\r\n}\r\nstatic int cs_etm_get_ro(struct perf_pmu *pmu, int cpu, const char *path)\r\n{\r\nchar pmu_path[PATH_MAX];\r\nint scan;\r\nunsigned int val = 0;\r\nsnprintf(pmu_path, PATH_MAX, "cpu%d/%s", cpu, path);\r\nscan = perf_pmu__scan_file(pmu, pmu_path, "%x", &val);\r\nif (scan != 1)\r\npr_err("%s: error reading: %s\n", __func__, pmu_path);\r\nreturn val;\r\n}\r\nstatic void cs_etm_get_metadata(int cpu, u32 *offset,\r\nstruct auxtrace_record *itr,\r\nstruct auxtrace_info_event *info)\r\n{\r\nu32 increment;\r\nu64 magic;\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\r\nif (cs_etm_is_etmv4(itr, cpu)) {\r\nmagic = __perf_cs_etmv4_magic;\r\ninfo->priv[*offset + CS_ETMV4_TRCCONFIGR] =\r\ncs_etm_get_config(itr);\r\ninfo->priv[*offset + CS_ETMV4_TRCTRACEIDR] =\r\ncoresight_get_trace_id(cpu);\r\ninfo->priv[*offset + CS_ETMV4_TRCIDR0] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv4_ro[CS_ETMV4_TRCIDR0]);\r\ninfo->priv[*offset + CS_ETMV4_TRCIDR1] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv4_ro[CS_ETMV4_TRCIDR1]);\r\ninfo->priv[*offset + CS_ETMV4_TRCIDR2] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv4_ro[CS_ETMV4_TRCIDR2]);\r\ninfo->priv[*offset + CS_ETMV4_TRCIDR8] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv4_ro[CS_ETMV4_TRCIDR8]);\r\ninfo->priv[*offset + CS_ETMV4_TRCAUTHSTATUS] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv4_ro\r\n[CS_ETMV4_TRCAUTHSTATUS]);\r\nincrement = CS_ETMV4_PRIV_MAX;\r\n} else {\r\nmagic = __perf_cs_etmv3_magic;\r\ninfo->priv[*offset + CS_ETM_ETMCR] = cs_etm_get_config(itr);\r\ninfo->priv[*offset + CS_ETM_ETMTRACEIDR] =\r\ncoresight_get_trace_id(cpu);\r\ninfo->priv[*offset + CS_ETM_ETMCCER] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv3_ro[CS_ETM_ETMCCER]);\r\ninfo->priv[*offset + CS_ETM_ETMIDR] =\r\ncs_etm_get_ro(cs_etm_pmu, cpu,\r\nmetadata_etmv3_ro[CS_ETM_ETMIDR]);\r\nincrement = CS_ETM_PRIV_MAX;\r\n}\r\ninfo->priv[*offset + CS_ETM_MAGIC] = magic;\r\ninfo->priv[*offset + CS_ETM_CPU] = cpu;\r\n*offset += increment;\r\n}\r\nstatic int cs_etm_info_fill(struct auxtrace_record *itr,\r\nstruct perf_session *session,\r\nstruct auxtrace_info_event *info,\r\nsize_t priv_size)\r\n{\r\nint i;\r\nu32 offset;\r\nu64 nr_cpu, type;\r\nconst struct cpu_map *cpus = session->evlist->cpus;\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;\r\nif (priv_size != cs_etm_info_priv_size(itr, session->evlist))\r\nreturn -EINVAL;\r\nif (!session->evlist->nr_mmaps)\r\nreturn -EINVAL;\r\nnr_cpu = cpu_map__empty(cpus) ? cpu__max_cpu() : cpu_map__nr(cpus);\r\ntype = cs_etm_pmu->type;\r\ninfo->type = PERF_AUXTRACE_CS_ETM;\r\ninfo->priv[CS_HEADER_VERSION_0] = 0;\r\ninfo->priv[CS_PMU_TYPE_CPUS] = type << 32;\r\ninfo->priv[CS_PMU_TYPE_CPUS] |= nr_cpu;\r\ninfo->priv[CS_ETM_SNAPSHOT] = ptr->snapshot_mode;\r\noffset = CS_ETM_SNAPSHOT + 1;\r\nif (!cpu_map__empty(cpus)) {\r\nfor (i = 0; i < cpu_map__nr(cpus) && offset < priv_size; i++)\r\ncs_etm_get_metadata(cpus->map[i], &offset, itr, info);\r\n} else {\r\nfor (i = 0; i < cpu__max_cpu(); i++)\r\ncs_etm_get_metadata(i, &offset, itr, info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs_etm_find_snapshot(struct auxtrace_record *itr __maybe_unused,\r\nint idx, struct auxtrace_mmap *mm,\r\nunsigned char *data __maybe_unused,\r\nu64 *head, u64 *old)\r\n{\r\npr_debug3("%s: mmap index %d old head %zu new head %zu size %zu\n",\r\n__func__, idx, (size_t)*old, (size_t)*head, mm->len);\r\n*old = *head;\r\n*head += mm->len;\r\nreturn 0;\r\n}\r\nstatic int cs_etm_snapshot_start(struct auxtrace_record *itr)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(ptr->evlist, evsel) {\r\nif (evsel->attr.type == ptr->cs_etm_pmu->type)\r\nreturn perf_evsel__disable(evsel);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs_etm_snapshot_finish(struct auxtrace_record *itr)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(ptr->evlist, evsel) {\r\nif (evsel->attr.type == ptr->cs_etm_pmu->type)\r\nreturn perf_evsel__enable(evsel);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u64 cs_etm_reference(struct auxtrace_record *itr __maybe_unused)\r\n{\r\nreturn (((u64) rand() << 0) & 0x00000000FFFFFFFFull) |\r\n(((u64) rand() << 32) & 0xFFFFFFFF00000000ull);\r\n}\r\nstatic void cs_etm_recording_free(struct auxtrace_record *itr)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nfree(ptr);\r\n}\r\nstatic int cs_etm_read_finish(struct auxtrace_record *itr, int idx)\r\n{\r\nstruct cs_etm_recording *ptr =\r\ncontainer_of(itr, struct cs_etm_recording, itr);\r\nstruct perf_evsel *evsel;\r\nevlist__for_each_entry(ptr->evlist, evsel) {\r\nif (evsel->attr.type == ptr->cs_etm_pmu->type)\r\nreturn perf_evlist__enable_event_idx(ptr->evlist,\r\nevsel, idx);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstruct auxtrace_record *cs_etm_record_init(int *err)\r\n{\r\nstruct perf_pmu *cs_etm_pmu;\r\nstruct cs_etm_recording *ptr;\r\ncs_etm_pmu = perf_pmu__find(CORESIGHT_ETM_PMU_NAME);\r\nif (!cs_etm_pmu) {\r\n*err = -EINVAL;\r\ngoto out;\r\n}\r\nptr = zalloc(sizeof(struct cs_etm_recording));\r\nif (!ptr) {\r\n*err = -ENOMEM;\r\ngoto out;\r\n}\r\nptr->cs_etm_pmu = cs_etm_pmu;\r\nptr->itr.parse_snapshot_options = cs_etm_parse_snapshot_options;\r\nptr->itr.recording_options = cs_etm_recording_options;\r\nptr->itr.info_priv_size = cs_etm_info_priv_size;\r\nptr->itr.info_fill = cs_etm_info_fill;\r\nptr->itr.find_snapshot = cs_etm_find_snapshot;\r\nptr->itr.snapshot_start = cs_etm_snapshot_start;\r\nptr->itr.snapshot_finish = cs_etm_snapshot_finish;\r\nptr->itr.reference = cs_etm_reference;\r\nptr->itr.free = cs_etm_recording_free;\r\nptr->itr.read_finish = cs_etm_read_finish;\r\n*err = 0;\r\nreturn &ptr->itr;\r\nout:\r\nreturn NULL;\r\n}\r\nstatic FILE *cs_device__open_file(const char *name)\r\n{\r\nstruct stat st;\r\nchar path[PATH_MAX];\r\nconst char *sysfs;\r\nsysfs = sysfs__mountpoint();\r\nif (!sysfs)\r\nreturn NULL;\r\nsnprintf(path, PATH_MAX,\r\n"%s" CS_BUS_DEVICE_PATH "%s", sysfs, name);\r\nif (stat(path, &st) < 0)\r\nreturn NULL;\r\nreturn fopen(path, "w");\r\n}
