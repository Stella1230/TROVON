static int at25_ee_read(void *priv, unsigned int offset,\r\nvoid *val, size_t count)\r\n{\r\nstruct at25_data *at25 = priv;\r\nchar *buf = val;\r\nu8 command[EE_MAXADDRLEN + 1];\r\nu8 *cp;\r\nssize_t status;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nu8 instr;\r\nif (unlikely(offset >= at25->chip.byte_len))\r\nreturn -EINVAL;\r\nif ((offset + count) > at25->chip.byte_len)\r\ncount = at25->chip.byte_len - offset;\r\nif (unlikely(!count))\r\nreturn -EINVAL;\r\ncp = command;\r\ninstr = AT25_READ;\r\nif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\r\nif (offset >= (1U << (at25->addrlen * 8)))\r\ninstr |= AT25_INSTR_BIT3;\r\n*cp++ = instr;\r\nswitch (at25->addrlen) {\r\ndefault:\r\n*cp++ = offset >> 16;\r\ncase 2:\r\n*cp++ = offset >> 8;\r\ncase 1:\r\ncase 0:\r\n*cp++ = offset >> 0;\r\n}\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof t);\r\nt[0].tx_buf = command;\r\nt[0].len = at25->addrlen + 1;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&at25->lock);\r\nstatus = spi_sync(at25->spi, &m);\r\ndev_dbg(&at25->spi->dev, "read %zu bytes at %d --> %zd\n",\r\ncount, offset, status);\r\nmutex_unlock(&at25->lock);\r\nreturn status;\r\n}\r\nstatic int at25_ee_write(void *priv, unsigned int off, void *val, size_t count)\r\n{\r\nstruct at25_data *at25 = priv;\r\nconst char *buf = val;\r\nint status = 0;\r\nunsigned buf_size;\r\nu8 *bounce;\r\nif (unlikely(off >= at25->chip.byte_len))\r\nreturn -EFBIG;\r\nif ((off + count) > at25->chip.byte_len)\r\ncount = at25->chip.byte_len - off;\r\nif (unlikely(!count))\r\nreturn -EINVAL;\r\nbuf_size = at25->chip.page_size;\r\nif (buf_size > io_limit)\r\nbuf_size = io_limit;\r\nbounce = kmalloc(buf_size + at25->addrlen + 1, GFP_KERNEL);\r\nif (!bounce)\r\nreturn -ENOMEM;\r\nmutex_lock(&at25->lock);\r\ndo {\r\nunsigned long timeout, retries;\r\nunsigned segment;\r\nunsigned offset = (unsigned) off;\r\nu8 *cp = bounce;\r\nint sr;\r\nu8 instr;\r\n*cp = AT25_WREN;\r\nstatus = spi_write(at25->spi, cp, 1);\r\nif (status < 0) {\r\ndev_dbg(&at25->spi->dev, "WREN --> %d\n", status);\r\nbreak;\r\n}\r\ninstr = AT25_WRITE;\r\nif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\r\nif (offset >= (1U << (at25->addrlen * 8)))\r\ninstr |= AT25_INSTR_BIT3;\r\n*cp++ = instr;\r\nswitch (at25->addrlen) {\r\ndefault:\r\n*cp++ = offset >> 16;\r\ncase 2:\r\n*cp++ = offset >> 8;\r\ncase 1:\r\ncase 0:\r\n*cp++ = offset >> 0;\r\n}\r\nsegment = buf_size - (offset % buf_size);\r\nif (segment > count)\r\nsegment = count;\r\nmemcpy(cp, buf, segment);\r\nstatus = spi_write(at25->spi, bounce,\r\nsegment + at25->addrlen + 1);\r\ndev_dbg(&at25->spi->dev, "write %u bytes at %u --> %d\n",\r\nsegment, offset, status);\r\nif (status < 0)\r\nbreak;\r\ntimeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);\r\nretries = 0;\r\ndo {\r\nsr = spi_w8r8(at25->spi, AT25_RDSR);\r\nif (sr < 0 || (sr & AT25_SR_nRDY)) {\r\ndev_dbg(&at25->spi->dev,\r\n"rdsr --> %d (%02x)\n", sr, sr);\r\nmsleep(1);\r\ncontinue;\r\n}\r\nif (!(sr & AT25_SR_nRDY))\r\nbreak;\r\n} while (retries++ < 3 || time_before_eq(jiffies, timeout));\r\nif ((sr < 0) || (sr & AT25_SR_nRDY)) {\r\ndev_err(&at25->spi->dev,\r\n"write %u bytes offset %u, timeout after %u msecs\n",\r\nsegment, offset,\r\njiffies_to_msecs(jiffies -\r\n(timeout - EE_TIMEOUT)));\r\nstatus = -ETIMEDOUT;\r\nbreak;\r\n}\r\noff += segment;\r\nbuf += segment;\r\ncount -= segment;\r\n} while (count > 0);\r\nmutex_unlock(&at25->lock);\r\nkfree(bounce);\r\nreturn status;\r\n}\r\nstatic int at25_fw_to_chip(struct device *dev, struct spi_eeprom *chip)\r\n{\r\nu32 val;\r\nmemset(chip, 0, sizeof(*chip));\r\nstrncpy(chip->name, "at25", sizeof(chip->name));\r\nif (device_property_read_u32(dev, "size", &val) == 0 ||\r\ndevice_property_read_u32(dev, "at25,byte-len", &val) == 0) {\r\nchip->byte_len = val;\r\n} else {\r\ndev_err(dev, "Error: missing \"size\" property\n");\r\nreturn -ENODEV;\r\n}\r\nif (device_property_read_u32(dev, "pagesize", &val) == 0 ||\r\ndevice_property_read_u32(dev, "at25,page-size", &val) == 0) {\r\nchip->page_size = (u16)val;\r\n} else {\r\ndev_err(dev, "Error: missing \"pagesize\" property\n");\r\nreturn -ENODEV;\r\n}\r\nif (device_property_read_u32(dev, "at25,addr-mode", &val) == 0) {\r\nchip->flags = (u16)val;\r\n} else {\r\nif (device_property_read_u32(dev, "address-width", &val)) {\r\ndev_err(dev,\r\n"Error: missing \"address-width\" property\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (val) {\r\ncase 8:\r\nchip->flags |= EE_ADDR1;\r\nbreak;\r\ncase 16:\r\nchip->flags |= EE_ADDR2;\r\nbreak;\r\ncase 24:\r\nchip->flags |= EE_ADDR3;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"Error: bad \"address-width\" property: %u\n",\r\nval);\r\nreturn -ENODEV;\r\n}\r\nif (device_property_present(dev, "read-only"))\r\nchip->flags |= EE_READONLY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at25_probe(struct spi_device *spi)\r\n{\r\nstruct at25_data *at25 = NULL;\r\nstruct spi_eeprom chip;\r\nint err;\r\nint sr;\r\nint addrlen;\r\nif (!spi->dev.platform_data) {\r\nerr = at25_fw_to_chip(&spi->dev, &chip);\r\nif (err)\r\nreturn err;\r\n} else\r\nchip = *(struct spi_eeprom *)spi->dev.platform_data;\r\nif (chip.flags & EE_ADDR1)\r\naddrlen = 1;\r\nelse if (chip.flags & EE_ADDR2)\r\naddrlen = 2;\r\nelse if (chip.flags & EE_ADDR3)\r\naddrlen = 3;\r\nelse {\r\ndev_dbg(&spi->dev, "unsupported address type\n");\r\nreturn -EINVAL;\r\n}\r\nsr = spi_w8r8(spi, AT25_RDSR);\r\nif (sr < 0 || sr & AT25_SR_nRDY) {\r\ndev_dbg(&spi->dev, "rdsr --> %d (%02x)\n", sr, sr);\r\nreturn -ENXIO;\r\n}\r\nat25 = devm_kzalloc(&spi->dev, sizeof(struct at25_data), GFP_KERNEL);\r\nif (!at25)\r\nreturn -ENOMEM;\r\nmutex_init(&at25->lock);\r\nat25->chip = chip;\r\nat25->spi = spi;\r\nspi_set_drvdata(spi, at25);\r\nat25->addrlen = addrlen;\r\nat25->nvmem_config.name = dev_name(&spi->dev);\r\nat25->nvmem_config.dev = &spi->dev;\r\nat25->nvmem_config.read_only = chip.flags & EE_READONLY;\r\nat25->nvmem_config.root_only = true;\r\nat25->nvmem_config.owner = THIS_MODULE;\r\nat25->nvmem_config.compat = true;\r\nat25->nvmem_config.base_dev = &spi->dev;\r\nat25->nvmem_config.reg_read = at25_ee_read;\r\nat25->nvmem_config.reg_write = at25_ee_write;\r\nat25->nvmem_config.priv = at25;\r\nat25->nvmem_config.stride = 4;\r\nat25->nvmem_config.word_size = 1;\r\nat25->nvmem_config.size = chip.byte_len;\r\nat25->nvmem = nvmem_register(&at25->nvmem_config);\r\nif (IS_ERR(at25->nvmem))\r\nreturn PTR_ERR(at25->nvmem);\r\ndev_info(&spi->dev, "%d %s %s eeprom%s, pagesize %u\n",\r\n(chip.byte_len < 1024) ? chip.byte_len : (chip.byte_len / 1024),\r\n(chip.byte_len < 1024) ? "Byte" : "KByte",\r\nat25->chip.name,\r\n(chip.flags & EE_READONLY) ? " (readonly)" : "",\r\nat25->chip.page_size);\r\nreturn 0;\r\n}\r\nstatic int at25_remove(struct spi_device *spi)\r\n{\r\nstruct at25_data *at25;\r\nat25 = spi_get_drvdata(spi);\r\nnvmem_unregister(at25->nvmem);\r\nreturn 0;\r\n}
