static int cfs_crypto_hash_alloc(enum cfs_crypto_hash_alg hash_alg,\r\nconst struct cfs_crypto_hash_type **type,\r\nstruct ahash_request **req,\r\nunsigned char *key,\r\nunsigned int key_len)\r\n{\r\nstruct crypto_ahash *tfm;\r\nint err = 0;\r\n*type = cfs_crypto_hash_type(hash_alg);\r\nif (!*type) {\r\nCWARN("Unsupported hash algorithm id = %d, max id is %d\n",\r\nhash_alg, CFS_HASH_ALG_MAX);\r\nreturn -EINVAL;\r\n}\r\ntfm = crypto_alloc_ahash((*type)->cht_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\nCDEBUG(D_INFO, "Failed to alloc crypto hash %s\n",\r\n(*type)->cht_name);\r\nreturn PTR_ERR(tfm);\r\n}\r\n*req = ahash_request_alloc(tfm, GFP_KERNEL);\r\nif (!*req) {\r\nCDEBUG(D_INFO, "Failed to alloc ahash_request for %s\n",\r\n(*type)->cht_name);\r\ncrypto_free_ahash(tfm);\r\nreturn -ENOMEM;\r\n}\r\nahash_request_set_callback(*req, 0, NULL, NULL);\r\nif (key)\r\nerr = crypto_ahash_setkey(tfm, key, key_len);\r\nelse if ((*type)->cht_key)\r\nerr = crypto_ahash_setkey(tfm,\r\n(unsigned char *)&((*type)->cht_key),\r\n(*type)->cht_size);\r\nif (err) {\r\nahash_request_free(*req);\r\ncrypto_free_ahash(tfm);\r\nreturn err;\r\n}\r\nCDEBUG(D_INFO, "Using crypto hash: %s (%s) speed %d MB/s\n",\r\ncrypto_ahash_alg_name(tfm), crypto_ahash_driver_name(tfm),\r\ncfs_crypto_hash_speeds[hash_alg]);\r\nerr = crypto_ahash_init(*req);\r\nif (err) {\r\nahash_request_free(*req);\r\ncrypto_free_ahash(tfm);\r\n}\r\nreturn err;\r\n}\r\nint cfs_crypto_hash_digest(enum cfs_crypto_hash_alg hash_alg,\r\nconst void *buf, unsigned int buf_len,\r\nunsigned char *key, unsigned int key_len,\r\nunsigned char *hash, unsigned int *hash_len)\r\n{\r\nstruct scatterlist sl;\r\nstruct ahash_request *req;\r\nint err;\r\nconst struct cfs_crypto_hash_type *type;\r\nif (!buf || !buf_len || !hash_len)\r\nreturn -EINVAL;\r\nerr = cfs_crypto_hash_alloc(hash_alg, &type, &req, key, key_len);\r\nif (err)\r\nreturn err;\r\nif (!hash || *hash_len < type->cht_size) {\r\n*hash_len = type->cht_size;\r\ncrypto_free_ahash(crypto_ahash_reqtfm(req));\r\nahash_request_free(req);\r\nreturn -ENOSPC;\r\n}\r\nsg_init_one(&sl, buf, buf_len);\r\nahash_request_set_crypt(req, &sl, hash, sl.length);\r\nerr = crypto_ahash_digest(req);\r\ncrypto_free_ahash(crypto_ahash_reqtfm(req));\r\nahash_request_free(req);\r\nreturn err;\r\n}\r\nstruct cfs_crypto_hash_desc *\r\ncfs_crypto_hash_init(enum cfs_crypto_hash_alg hash_alg,\r\nunsigned char *key, unsigned int key_len)\r\n{\r\nstruct ahash_request *req;\r\nint err;\r\nconst struct cfs_crypto_hash_type *type;\r\nerr = cfs_crypto_hash_alloc(hash_alg, &type, &req, key, key_len);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nreturn (struct cfs_crypto_hash_desc *)req;\r\n}\r\nint cfs_crypto_hash_update_page(struct cfs_crypto_hash_desc *hdesc,\r\nstruct page *page, unsigned int offset,\r\nunsigned int len)\r\n{\r\nstruct ahash_request *req = (void *)hdesc;\r\nstruct scatterlist sl;\r\nsg_init_table(&sl, 1);\r\nsg_set_page(&sl, page, len, offset & ~PAGE_MASK);\r\nahash_request_set_crypt(req, &sl, NULL, sl.length);\r\nreturn crypto_ahash_update(req);\r\n}\r\nint cfs_crypto_hash_update(struct cfs_crypto_hash_desc *hdesc,\r\nconst void *buf, unsigned int buf_len)\r\n{\r\nstruct ahash_request *req = (void *)hdesc;\r\nstruct scatterlist sl;\r\nsg_init_one(&sl, buf, buf_len);\r\nahash_request_set_crypt(req, &sl, NULL, sl.length);\r\nreturn crypto_ahash_update(req);\r\n}\r\nint cfs_crypto_hash_final(struct cfs_crypto_hash_desc *hdesc,\r\nunsigned char *hash, unsigned int *hash_len)\r\n{\r\nint err;\r\nstruct ahash_request *req = (void *)hdesc;\r\nint size = crypto_ahash_digestsize(crypto_ahash_reqtfm(req));\r\nif (!hash || !hash_len) {\r\nerr = 0;\r\ngoto free_ahash;\r\n}\r\nif (*hash_len < size) {\r\nerr = -EOVERFLOW;\r\ngoto free_ahash;\r\n}\r\nahash_request_set_crypt(req, NULL, hash, 0);\r\nerr = crypto_ahash_final(req);\r\nif (!err)\r\n*hash_len = size;\r\nfree_ahash:\r\ncrypto_free_ahash(crypto_ahash_reqtfm(req));\r\nahash_request_free(req);\r\nreturn err;\r\n}\r\nstatic void cfs_crypto_performance_test(enum cfs_crypto_hash_alg hash_alg)\r\n{\r\nint buf_len = max(PAGE_SIZE, 1048576UL);\r\nvoid *buf;\r\nunsigned long start, end;\r\nint bcount, err = 0;\r\nstruct page *page;\r\nunsigned char hash[CFS_CRYPTO_HASH_DIGESTSIZE_MAX];\r\nunsigned int hash_len = sizeof(hash);\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nbuf = kmap(page);\r\nmemset(buf, 0xAD, PAGE_SIZE);\r\nkunmap(page);\r\nfor (start = jiffies, end = start + msecs_to_jiffies(MSEC_PER_SEC),\r\nbcount = 0; time_before(jiffies, end); bcount++) {\r\nstruct cfs_crypto_hash_desc *hdesc;\r\nint i;\r\nhdesc = cfs_crypto_hash_init(hash_alg, NULL, 0);\r\nif (IS_ERR(hdesc)) {\r\nerr = PTR_ERR(hdesc);\r\nbreak;\r\n}\r\nfor (i = 0; i < buf_len / PAGE_SIZE; i++) {\r\nerr = cfs_crypto_hash_update_page(hdesc, page, 0,\r\nPAGE_SIZE);\r\nif (err)\r\nbreak;\r\n}\r\nerr = cfs_crypto_hash_final(hdesc, hash, &hash_len);\r\nif (err)\r\nbreak;\r\n}\r\nend = jiffies;\r\n__free_page(page);\r\nout_err:\r\nif (err) {\r\ncfs_crypto_hash_speeds[hash_alg] = err;\r\nCDEBUG(D_INFO, "Crypto hash algorithm %s test error: rc = %d\n",\r\ncfs_crypto_hash_name(hash_alg), err);\r\n} else {\r\nunsigned long tmp;\r\ntmp = ((bcount * buf_len / jiffies_to_msecs(end - start)) *\r\n1000) / (1024 * 1024);\r\ncfs_crypto_hash_speeds[hash_alg] = (int)tmp;\r\nCDEBUG(D_CONFIG, "Crypto hash algorithm %s speed = %d MB/s\n",\r\ncfs_crypto_hash_name(hash_alg),\r\ncfs_crypto_hash_speeds[hash_alg]);\r\n}\r\n}\r\nint cfs_crypto_hash_speed(enum cfs_crypto_hash_alg hash_alg)\r\n{\r\nif (hash_alg < CFS_HASH_ALG_MAX)\r\nreturn cfs_crypto_hash_speeds[hash_alg];\r\nreturn -ENOENT;\r\n}\r\nstatic int cfs_crypto_test_hashes(void)\r\n{\r\nenum cfs_crypto_hash_alg hash_alg;\r\nfor (hash_alg = 0; hash_alg < CFS_HASH_ALG_MAX; hash_alg++)\r\ncfs_crypto_performance_test(hash_alg);\r\nreturn 0;\r\n}\r\nint cfs_crypto_register(void)\r\n{\r\nrequest_module("crc32c");\r\nadler32 = cfs_crypto_adler32_register();\r\ncfs_crypto_test_hashes();\r\nreturn 0;\r\n}\r\nvoid cfs_crypto_unregister(void)\r\n{\r\nif (!adler32)\r\ncfs_crypto_adler32_unregister();\r\n}
