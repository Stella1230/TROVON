static void arm_tb(void)\r\n{\r\nu64 scdperfcnt;\r\nu64 next = (1ULL << 40) - tb_period;\r\nu64 tb_options = M_SCD_TRACE_CFG_FREEZE_FULL;\r\n__raw_writeq(0, IOADDR(A_SCD_PERF_CNT_1));\r\nscdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));\r\n#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)\r\n__raw_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) |\r\nV_SPC_CFG_SRC1(1),\r\nIOADDR(A_BCM1480_SCD_PERF_CNT_CFG0));\r\n__raw_writeq(\r\nM_SPC_CFG_ENABLE |\r\nM_SPC_CFG_CLEAR |\r\nV_SPC_CFG_SRC1(1),\r\nIOADDR(A_BCM1480_SCD_PERF_CNT_CFG1));\r\n#else\r\n__raw_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) |\r\nM_SPC_CFG_ENABLE |\r\nM_SPC_CFG_CLEAR |\r\nV_SPC_CFG_SRC1(1),\r\nIOADDR(A_SCD_PERF_CNT_CFG));\r\n#endif\r\n__raw_writeq(next, IOADDR(A_SCD_PERF_CNT_1));\r\n__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));\r\n#if 0 && defined(M_SCD_TRACE_CFG_FORCECNT)\r\ntb_options |= M_SCD_TRACE_CFG_FORCECNT;\r\n#endif\r\n__raw_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));\r\nsbp.tb_armed = 1;\r\n}\r\nstatic irqreturn_t sbprof_tb_intr(int irq, void *dev_id)\r\n{\r\nint i;\r\npr_debug(DEVNAME ": tb_intr\n");\r\nif (sbp.next_tb_sample < MAX_TB_SAMPLES) {\r\nu64 *p = sbp.sbprof_tbbuf[sbp.next_tb_sample++];\r\n__raw_writeq(M_SCD_TRACE_CFG_START_READ,\r\nIOADDR(A_SCD_TRACE_CFG));\r\n__asm__ __volatile__ ("sync" : : : "memory");\r\nfor (i = 256 * 6; i > 0; i -= 6) {\r\np[i - 1] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\np[i - 2] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\np[i - 3] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\np[i - 4] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\np[i - 5] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\np[i - 6] = __raw_readq(IOADDR(A_SCD_TRACE_READ));\r\n}\r\nif (!sbp.tb_enable) {\r\npr_debug(DEVNAME ": tb_intr shutdown\n");\r\n__raw_writeq(M_SCD_TRACE_CFG_RESET,\r\nIOADDR(A_SCD_TRACE_CFG));\r\nsbp.tb_armed = 0;\r\nwake_up_interruptible(&sbp.tb_sync);\r\n} else {\r\narm_tb();\r\n}\r\n} else {\r\npr_debug(DEVNAME ": tb_intr full\n");\r\n__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));\r\nsbp.tb_armed = 0;\r\nif (!sbp.tb_enable)\r\nwake_up_interruptible(&sbp.tb_sync);\r\nwake_up_interruptible(&sbp.tb_read);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sbprof_pc_intr(int irq, void *dev_id)\r\n{\r\nprintk(DEVNAME ": unexpected pc_intr");\r\nreturn IRQ_NONE;\r\n}\r\nstatic int sbprof_zbprof_start(struct file *filp)\r\n{\r\nu64 scdperfcnt;\r\nint err;\r\nif (xchg(&sbp.tb_enable, 1))\r\nreturn -EBUSY;\r\npr_debug(DEVNAME ": starting\n");\r\nsbp.next_tb_sample = 0;\r\nfilp->f_pos = 0;\r\nerr = request_irq(K_INT_TRACE_FREEZE, sbprof_tb_intr, 0,\r\nDEVNAME " trace freeze", &sbp);\r\nif (err)\r\nreturn -EBUSY;\r\nscdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));\r\n__raw_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |\r\nM_SPC_CFG_ENABLE | M_SPC_CFG_CLEAR | V_SPC_CFG_SRC1(1),\r\nIOADDR(A_SCD_PERF_CNT_CFG));\r\nif (request_irq(K_INT_PERF_CNT, sbprof_pc_intr, 0, DEVNAME " scd perfcnt", &sbp)) {\r\nfree_irq(K_INT_TRACE_FREEZE, &sbp);\r\nreturn -EBUSY;\r\n}\r\n#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)\r\n__raw_writeq(K_BCM1480_INT_MAP_I3,\r\nIOADDR(A_BCM1480_IMR_REGISTER(0, R_BCM1480_IMR_INTERRUPT_MAP_BASE_L) +\r\n((K_BCM1480_INT_PERF_CNT & 0x3f) << 3)));\r\n#else\r\n__raw_writeq(K_INT_MAP_I3,\r\nIOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +\r\n(K_INT_PERF_CNT << 3)));\r\n#endif\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));\r\n__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));\r\n__raw_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));\r\n__raw_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,\r\nIOADDR(A_SCD_TRACE_SEQUENCE_0));\r\n__raw_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |\r\nK_SCD_TRSEQ_TRIGGER_ALL,\r\nIOADDR(A_SCD_TRACE_SEQUENCE_1));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));\r\n__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));\r\n#if defined(CONFIG_SIBYTE_BCM1x55) || defined(CONFIG_SIBYTE_BCM1x80)\r\n__raw_writeq(1ULL << (K_BCM1480_INT_PERF_CNT & 0x3f),\r\nIOADDR(A_BCM1480_IMR_REGISTER(0, R_BCM1480_IMR_INTERRUPT_TRACE_L)));\r\n#else\r\n__raw_writeq(1ULL << K_INT_PERF_CNT,\r\nIOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));\r\n#endif\r\narm_tb();\r\npr_debug(DEVNAME ": done starting\n");\r\nreturn 0;\r\n}\r\nstatic int sbprof_zbprof_stop(void)\r\n{\r\nint err = 0;\r\npr_debug(DEVNAME ": stopping\n");\r\nif (sbp.tb_enable) {\r\npr_debug(DEVNAME ": wait for disarm\n");\r\nerr = wait_event_interruptible(sbp.tb_sync, !sbp.tb_armed);\r\npr_debug(DEVNAME ": disarm complete, stat %d\n", err);\r\nif (err)\r\nreturn err;\r\nsbp.tb_enable = 0;\r\nfree_irq(K_INT_TRACE_FREEZE, &sbp);\r\nfree_irq(K_INT_PERF_CNT, &sbp);\r\n}\r\npr_debug(DEVNAME ": done stopping\n");\r\nreturn err;\r\n}\r\nstatic int sbprof_tb_open(struct inode *inode, struct file *filp)\r\n{\r\nint minor;\r\nminor = iminor(inode);\r\nif (minor != 0)\r\nreturn -ENODEV;\r\nif (xchg(&sbp.open, SB_OPENING) != SB_CLOSED)\r\nreturn -EBUSY;\r\nmemset(&sbp, 0, sizeof(struct sbprof_tb));\r\nsbp.sbprof_tbbuf = vzalloc(MAX_TBSAMPLE_BYTES);\r\nif (!sbp.sbprof_tbbuf) {\r\nsbp.open = SB_CLOSED;\r\nwmb();\r\nreturn -ENOMEM;\r\n}\r\ninit_waitqueue_head(&sbp.tb_sync);\r\ninit_waitqueue_head(&sbp.tb_read);\r\nmutex_init(&sbp.lock);\r\nsbp.open = SB_OPEN;\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int sbprof_tb_release(struct inode *inode, struct file *filp)\r\n{\r\nint minor;\r\nminor = iminor(inode);\r\nif (minor != 0 || sbp.open != SB_CLOSED)\r\nreturn -ENODEV;\r\nmutex_lock(&sbp.lock);\r\nif (sbp.tb_armed || sbp.tb_enable)\r\nsbprof_zbprof_stop();\r\nvfree(sbp.sbprof_tbbuf);\r\nsbp.open = SB_CLOSED;\r\nwmb();\r\nmutex_unlock(&sbp.lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t sbprof_tb_read(struct file *filp, char *buf,\r\nsize_t size, loff_t *offp)\r\n{\r\nint cur_sample, sample_off, cur_count, sample_left;\r\nchar *src;\r\nint count = 0;\r\nchar *dest = buf;\r\nlong cur_off = *offp;\r\nif (!access_ok(VERIFY_WRITE, buf, size))\r\nreturn -EFAULT;\r\nmutex_lock(&sbp.lock);\r\ncount = 0;\r\ncur_sample = cur_off / TB_SAMPLE_SIZE;\r\nsample_off = cur_off % TB_SAMPLE_SIZE;\r\nsample_left = TB_SAMPLE_SIZE - sample_off;\r\nwhile (size && (cur_sample < sbp.next_tb_sample)) {\r\nint err;\r\ncur_count = size < sample_left ? size : sample_left;\r\nsrc = (char *)(((long)sbp.sbprof_tbbuf[cur_sample])+sample_off);\r\nerr = __copy_to_user(dest, src, cur_count);\r\nif (err) {\r\n*offp = cur_off + cur_count - err;\r\nmutex_unlock(&sbp.lock);\r\nreturn err;\r\n}\r\npr_debug(DEVNAME ": read from sample %d, %d bytes\n",\r\ncur_sample, cur_count);\r\nsize -= cur_count;\r\nsample_left -= cur_count;\r\nif (!sample_left) {\r\ncur_sample++;\r\nsample_off = 0;\r\nsample_left = TB_SAMPLE_SIZE;\r\n} else {\r\nsample_off += cur_count;\r\n}\r\ncur_off += cur_count;\r\ndest += cur_count;\r\ncount += cur_count;\r\n}\r\n*offp = cur_off;\r\nmutex_unlock(&sbp.lock);\r\nreturn count;\r\n}\r\nstatic long sbprof_tb_ioctl(struct file *filp,\r\nunsigned int command,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nswitch (command) {\r\ncase SBPROF_ZBSTART:\r\nmutex_lock(&sbp.lock);\r\nerr = sbprof_zbprof_start(filp);\r\nmutex_unlock(&sbp.lock);\r\nbreak;\r\ncase SBPROF_ZBSTOP:\r\nmutex_lock(&sbp.lock);\r\nerr = sbprof_zbprof_stop();\r\nmutex_unlock(&sbp.lock);\r\nbreak;\r\ncase SBPROF_ZBWAITFULL: {\r\nerr = wait_event_interruptible(sbp.tb_read, TB_FULL);\r\nif (err)\r\nbreak;\r\nerr = put_user(TB_FULL, (int *) arg);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __init sbprof_tb_init(void)\r\n{\r\nstruct device *dev;\r\nstruct class *tbc;\r\nint err;\r\nif (register_chrdev(SBPROF_TB_MAJOR, DEVNAME, &sbprof_tb_fops)) {\r\nprintk(KERN_WARNING DEVNAME ": initialization failed (dev %d)\n",\r\nSBPROF_TB_MAJOR);\r\nreturn -EIO;\r\n}\r\ntbc = class_create(THIS_MODULE, "sb_tracebuffer");\r\nif (IS_ERR(tbc)) {\r\nerr = PTR_ERR(tbc);\r\ngoto out_chrdev;\r\n}\r\ntb_class = tbc;\r\ndev = device_create(tbc, NULL, MKDEV(SBPROF_TB_MAJOR, 0), NULL, "tb");\r\nif (IS_ERR(dev)) {\r\nerr = PTR_ERR(dev);\r\ngoto out_class;\r\n}\r\ntb_dev = dev;\r\nsbp.open = SB_CLOSED;\r\nwmb();\r\ntb_period = zbbus_mhz * 10000LL;\r\npr_info(DEVNAME ": initialized - tb_period = %lld\n",\r\n(long long) tb_period);\r\nreturn 0;\r\nout_class:\r\nclass_destroy(tb_class);\r\nout_chrdev:\r\nunregister_chrdev(SBPROF_TB_MAJOR, DEVNAME);\r\nreturn err;\r\n}\r\nstatic void __exit sbprof_tb_cleanup(void)\r\n{\r\ndevice_destroy(tb_class, MKDEV(SBPROF_TB_MAJOR, 0));\r\nunregister_chrdev(SBPROF_TB_MAJOR, DEVNAME);\r\nclass_destroy(tb_class);\r\n}
