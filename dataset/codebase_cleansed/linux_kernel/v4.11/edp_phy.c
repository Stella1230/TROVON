bool msm_edp_phy_ready(struct edp_phy *phy)\r\n{\r\nu32 status;\r\nint cnt = 100;\r\nwhile (--cnt) {\r\nstatus = edp_read(phy->base +\r\nREG_EDP_PHY_GLB_PHY_STATUS);\r\nif (status & 0x01)\r\nbreak;\r\nusleep_range(500, 1000);\r\n}\r\nif (cnt == 0) {\r\npr_err("%s: PHY NOT ready\n", __func__);\r\nreturn false;\r\n} else {\r\nreturn true;\r\n}\r\n}\r\nvoid msm_edp_phy_ctrl(struct edp_phy *phy, int enable)\r\n{\r\nDBG("enable=%d", enable);\r\nif (enable) {\r\nedp_write(phy->base + REG_EDP_PHY_CTRL,\r\nEDP_PHY_CTRL_SW_RESET | EDP_PHY_CTRL_SW_RESET_PLL);\r\nwmb();\r\nusleep_range(500, 1000);\r\nedp_write(phy->base + REG_EDP_PHY_CTRL, 0x000);\r\nedp_write(phy->base + REG_EDP_PHY_GLB_PD_CTL, 0x3f);\r\nedp_write(phy->base + REG_EDP_PHY_GLB_CFG, 0x1);\r\n} else {\r\nedp_write(phy->base + REG_EDP_PHY_GLB_PD_CTL, 0xc0);\r\n}\r\n}\r\nvoid msm_edp_phy_vm_pe_init(struct edp_phy *phy)\r\n{\r\nedp_write(phy->base + REG_EDP_PHY_GLB_VM_CFG0, 0x3);\r\nedp_write(phy->base + REG_EDP_PHY_GLB_VM_CFG1, 0x64);\r\nedp_write(phy->base + REG_EDP_PHY_GLB_MISC9, 0x6c);\r\n}\r\nvoid msm_edp_phy_vm_pe_cfg(struct edp_phy *phy, u32 v0, u32 v1)\r\n{\r\nedp_write(phy->base + REG_EDP_PHY_GLB_VM_CFG0, v0);\r\nedp_write(phy->base + REG_EDP_PHY_GLB_VM_CFG1, v1);\r\n}\r\nvoid msm_edp_phy_lane_power_ctrl(struct edp_phy *phy, bool up, u32 max_lane)\r\n{\r\nu32 i;\r\nu32 data;\r\nif (up)\r\ndata = 0;\r\nelse\r\ndata = 0x7;\r\nfor (i = 0; i < max_lane; i++)\r\nedp_write(phy->base + REG_EDP_PHY_LN_PD_CTL(i) , data);\r\ndata = 0x7;\r\nfor (i = max_lane; i < EDP_MAX_LANE; i++)\r\nedp_write(phy->base + REG_EDP_PHY_LN_PD_CTL(i) , data);\r\n}\r\nvoid *msm_edp_phy_init(struct device *dev, void __iomem *regbase)\r\n{\r\nstruct edp_phy *phy = NULL;\r\nphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn NULL;\r\nphy->base = regbase;\r\nreturn phy;\r\n}
