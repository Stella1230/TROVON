static bool pll_28nm_poll_for_ready(struct dsi_pll_28nm *pll_28nm,\r\nint nb_tries, int timeout_us)\r\n{\r\nbool pll_locked = false;\r\nu32 val;\r\nwhile (nb_tries--) {\r\nval = pll_read(pll_28nm->mmio + REG_DSI_28nm_8960_PHY_PLL_RDY);\r\npll_locked = !!(val & DSI_28nm_8960_PHY_PLL_RDY_PLL_RDY);\r\nif (pll_locked)\r\nbreak;\r\nudelay(timeout_us);\r\n}\r\nDBG("DSI PLL is %slocked", pll_locked ? "" : "*not* ");\r\nreturn pll_locked;\r\n}\r\nstatic int dsi_pll_28nm_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nvoid __iomem *base = pll_28nm->mmio;\r\nu32 val, temp, fb_divider;\r\nDBG("rate=%lu, parent's=%lu", rate, parent_rate);\r\ntemp = rate / 10;\r\nval = VCO_REF_CLK_RATE / 10;\r\nfb_divider = (temp * VCO_PREF_DIV_RATIO) / val;\r\nfb_divider = fb_divider / 2 - 1;\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_1,\r\nfb_divider & 0xff);\r\nval = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2);\r\nval |= (fb_divider >> 8) & 0x07;\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2,\r\nval);\r\nval = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3);\r\nval |= (VCO_PREF_DIV_RATIO - 1) & 0x3f;\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3,\r\nval);\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_6,\r\n0xf);\r\nval = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\r\nval |= 0x7 << 4;\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8,\r\nval);\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_28nm_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nreturn pll_28nm_poll_for_ready(pll_28nm, POLL_MAX_READS,\r\nPOLL_TIMEOUT_US);\r\n}\r\nstatic unsigned long dsi_pll_28nm_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct msm_dsi_pll *pll = hw_clk_to_pll(hw);\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nvoid __iomem *base = pll_28nm->mmio;\r\nunsigned long vco_rate;\r\nu32 status, fb_divider, temp, ref_divider;\r\nVERB("parent_rate=%lu", parent_rate);\r\nstatus = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_0);\r\nif (status & DSI_28nm_8960_PHY_PLL_CTRL_0_ENABLE) {\r\nfb_divider = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_1);\r\nfb_divider &= 0xff;\r\ntemp = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_2) & 0x07;\r\nfb_divider = (temp << 8) | fb_divider;\r\nfb_divider += 1;\r\nref_divider = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_3);\r\nref_divider &= 0x3f;\r\nref_divider += 1;\r\nvco_rate = (parent_rate / ref_divider) * fb_divider * 2;\r\n} else {\r\nvco_rate = 0;\r\n}\r\nDBG("returning vco rate = %lu", vco_rate);\r\nreturn vco_rate;\r\n}\r\nstatic unsigned long clk_bytediv_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_bytediv *bytediv = to_clk_bytediv(hw);\r\nunsigned int div;\r\ndiv = pll_read(bytediv->reg) & 0xff;\r\nreturn parent_rate / (div + 1);\r\n}\r\nstatic unsigned int get_vco_mul_factor(unsigned long byte_clk_rate)\r\n{\r\nunsigned long bit_mhz;\r\nbit_mhz = (byte_clk_rate * 8) / 1000000;\r\nif (bit_mhz < 125)\r\nreturn 64;\r\nelse if (bit_mhz < 250)\r\nreturn 32;\r\nelse if (bit_mhz < 600)\r\nreturn 16;\r\nelse\r\nreturn 8;\r\n}\r\nstatic long clk_bytediv_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long best_parent;\r\nunsigned int factor;\r\nfactor = get_vco_mul_factor(rate);\r\nbest_parent = rate * factor;\r\n*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\r\nreturn *prate / factor;\r\n}\r\nstatic int clk_bytediv_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_bytediv *bytediv = to_clk_bytediv(hw);\r\nu32 val;\r\nunsigned int factor;\r\nfactor = get_vco_mul_factor(rate);\r\nval = pll_read(bytediv->reg);\r\nval |= (factor - 1) & 0xff;\r\npll_write(bytediv->reg, val);\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_28nm_enable_seq(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nbool locked;\r\nunsigned int bit_div, byte_div;\r\nint max_reads = 1000, timeout_us = 100;\r\nu32 val;\r\nDBG("id=%d", pll_28nm->id);\r\nval = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9);\r\nbyte_div = val + 1;\r\nbit_div = byte_div / 8;\r\nval = pll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\r\nval &= ~0xf;\r\nval |= (bit_div - 1);\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8, val);\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_0,\r\nDSI_28nm_8960_PHY_PLL_CTRL_0_ENABLE);\r\nlocked = pll_28nm_poll_for_ready(pll_28nm, max_reads, timeout_us);\r\nif (unlikely(!locked))\r\ndev_err(dev, "DSI PLL lock failed\n");\r\nelse\r\nDBG("DSI PLL lock success");\r\nreturn locked ? 0 : -EINVAL;\r\n}\r\nstatic void dsi_pll_28nm_disable_seq(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nDBG("id=%d", pll_28nm->id);\r\npll_write(pll_28nm->mmio + REG_DSI_28nm_8960_PHY_PLL_CTRL_0, 0x00);\r\n}\r\nstatic void dsi_pll_28nm_save_state(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\r\nvoid __iomem *base = pll_28nm->mmio;\r\ncached_state->postdiv3 =\r\npll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_10);\r\ncached_state->postdiv2 =\r\npll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9);\r\ncached_state->postdiv1 =\r\npll_read(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8);\r\ncached_state->vco_rate = clk_hw_get_rate(&pll->clk_hw);\r\n}\r\nstatic int dsi_pll_28nm_restore_state(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nstruct pll_28nm_cached_state *cached_state = &pll_28nm->cached_state;\r\nvoid __iomem *base = pll_28nm->mmio;\r\nint ret;\r\nret = dsi_pll_28nm_clk_set_rate(&pll->clk_hw,\r\ncached_state->vco_rate, 0);\r\nif (ret) {\r\ndev_err(&pll_28nm->pdev->dev,\r\n"restore vco rate failed. ret=%d\n", ret);\r\nreturn ret;\r\n}\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_10,\r\ncached_state->postdiv3);\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_9,\r\ncached_state->postdiv2);\r\npll_write(base + REG_DSI_28nm_8960_PHY_PLL_CTRL_8,\r\ncached_state->postdiv1);\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_28nm_get_provider(struct msm_dsi_pll *pll,\r\nstruct clk **byte_clk_provider,\r\nstruct clk **pixel_clk_provider)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nif (byte_clk_provider)\r\n*byte_clk_provider = pll_28nm->provided_clks[DSI_BYTE_PLL_CLK];\r\nif (pixel_clk_provider)\r\n*pixel_clk_provider =\r\npll_28nm->provided_clks[DSI_PIXEL_PLL_CLK];\r\nreturn 0;\r\n}\r\nstatic void dsi_pll_28nm_destroy(struct msm_dsi_pll *pll)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm = to_pll_28nm(pll);\r\nmsm_dsi_pll_helper_unregister_clks(pll_28nm->pdev,\r\npll_28nm->clks, pll_28nm->num_clks);\r\n}\r\nstatic int pll_28nm_register(struct dsi_pll_28nm *pll_28nm)\r\n{\r\nchar *clk_name, *parent_name, *vco_name;\r\nstruct clk_init_data vco_init = {\r\n.parent_names = (const char *[]){ "pxo" },\r\n.num_parents = 1,\r\n.flags = CLK_IGNORE_UNUSED,\r\n.ops = &clk_ops_dsi_pll_28nm_vco,\r\n};\r\nstruct device *dev = &pll_28nm->pdev->dev;\r\nstruct clk **clks = pll_28nm->clks;\r\nstruct clk **provided_clks = pll_28nm->provided_clks;\r\nstruct clk_bytediv *bytediv;\r\nstruct clk_init_data bytediv_init = { };\r\nint ret, num = 0;\r\nDBG("%d", pll_28nm->id);\r\nbytediv = devm_kzalloc(dev, sizeof(*bytediv), GFP_KERNEL);\r\nif (!bytediv)\r\nreturn -ENOMEM;\r\nvco_name = devm_kzalloc(dev, 32, GFP_KERNEL);\r\nif (!vco_name)\r\nreturn -ENOMEM;\r\nparent_name = devm_kzalloc(dev, 32, GFP_KERNEL);\r\nif (!parent_name)\r\nreturn -ENOMEM;\r\nclk_name = devm_kzalloc(dev, 32, GFP_KERNEL);\r\nif (!clk_name)\r\nreturn -ENOMEM;\r\npll_28nm->bytediv = bytediv;\r\nsnprintf(vco_name, 32, "dsi%dvco_clk", pll_28nm->id);\r\nvco_init.name = vco_name;\r\npll_28nm->base.clk_hw.init = &vco_init;\r\nclks[num++] = clk_register(dev, &pll_28nm->base.clk_hw);\r\nbytediv->hw.init = &bytediv_init;\r\nbytediv->reg = pll_28nm->mmio + REG_DSI_28nm_8960_PHY_PLL_CTRL_9;\r\nsnprintf(parent_name, 32, "dsi%dvco_clk", pll_28nm->id);\r\nsnprintf(clk_name, 32, "dsi%dpllbyte", pll_28nm->id);\r\nbytediv_init.name = clk_name;\r\nbytediv_init.ops = &clk_bytediv_ops;\r\nbytediv_init.flags = CLK_SET_RATE_PARENT;\r\nbytediv_init.parent_names = (const char * const *) &parent_name;\r\nbytediv_init.num_parents = 1;\r\nclks[num++] = provided_clks[DSI_BYTE_PLL_CLK] =\r\nclk_register(dev, &bytediv->hw);\r\nsnprintf(clk_name, 32, "dsi%dpll", pll_28nm->id);\r\nclks[num++] = provided_clks[DSI_PIXEL_PLL_CLK] =\r\nclk_register_divider(dev, clk_name,\r\nparent_name, 0, pll_28nm->mmio +\r\nREG_DSI_28nm_8960_PHY_PLL_CTRL_10,\r\n0, 8, 0, NULL);\r\npll_28nm->num_clks = num;\r\npll_28nm->clk_data.clk_num = NUM_PROVIDED_CLKS;\r\npll_28nm->clk_data.clks = provided_clks;\r\nret = of_clk_add_provider(dev->of_node,\r\nof_clk_src_onecell_get, &pll_28nm->clk_data);\r\nif (ret) {\r\ndev_err(dev, "failed to register clk provider: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct msm_dsi_pll *msm_dsi_pll_28nm_8960_init(struct platform_device *pdev,\r\nint id)\r\n{\r\nstruct dsi_pll_28nm *pll_28nm;\r\nstruct msm_dsi_pll *pll;\r\nint ret;\r\nif (!pdev)\r\nreturn ERR_PTR(-ENODEV);\r\npll_28nm = devm_kzalloc(&pdev->dev, sizeof(*pll_28nm), GFP_KERNEL);\r\nif (!pll_28nm)\r\nreturn ERR_PTR(-ENOMEM);\r\npll_28nm->pdev = pdev;\r\npll_28nm->id = id + 1;\r\npll_28nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");\r\nif (IS_ERR_OR_NULL(pll_28nm->mmio)) {\r\ndev_err(&pdev->dev, "%s: failed to map pll base\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npll = &pll_28nm->base;\r\npll->min_rate = VCO_MIN_RATE;\r\npll->max_rate = VCO_MAX_RATE;\r\npll->get_provider = dsi_pll_28nm_get_provider;\r\npll->destroy = dsi_pll_28nm_destroy;\r\npll->disable_seq = dsi_pll_28nm_disable_seq;\r\npll->save_state = dsi_pll_28nm_save_state;\r\npll->restore_state = dsi_pll_28nm_restore_state;\r\npll->en_seq_cnt = 1;\r\npll->enable_seqs[0] = dsi_pll_28nm_enable_seq;\r\nret = pll_28nm_register(pll_28nm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register PLL: %d\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn pll;\r\n}
