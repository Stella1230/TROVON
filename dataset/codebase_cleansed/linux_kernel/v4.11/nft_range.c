static void nft_range_eval(const struct nft_expr *expr,\r\nstruct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_range_expr *priv = nft_expr_priv(expr);\r\nint d1, d2;\r\nd1 = memcmp(&regs->data[priv->sreg], &priv->data_from, priv->len);\r\nd2 = memcmp(&regs->data[priv->sreg], &priv->data_to, priv->len);\r\nswitch (priv->op) {\r\ncase NFT_RANGE_EQ:\r\nif (d1 < 0 || d2 > 0)\r\nregs->verdict.code = NFT_BREAK;\r\nbreak;\r\ncase NFT_RANGE_NEQ:\r\nif (d1 >= 0 && d2 <= 0)\r\nregs->verdict.code = NFT_BREAK;\r\nbreak;\r\n}\r\n}\r\nstatic int nft_range_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_range_expr *priv = nft_expr_priv(expr);\r\nstruct nft_data_desc desc_from, desc_to;\r\nint err;\r\nu32 op;\r\nif (!tb[NFTA_RANGE_SREG] ||\r\n!tb[NFTA_RANGE_OP] ||\r\n!tb[NFTA_RANGE_FROM_DATA] ||\r\n!tb[NFTA_RANGE_TO_DATA])\r\nreturn -EINVAL;\r\nerr = nft_data_init(NULL, &priv->data_from, sizeof(priv->data_from),\r\n&desc_from, tb[NFTA_RANGE_FROM_DATA]);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_data_init(NULL, &priv->data_to, sizeof(priv->data_to),\r\n&desc_to, tb[NFTA_RANGE_TO_DATA]);\r\nif (err < 0)\r\ngoto err1;\r\nif (desc_from.len != desc_to.len) {\r\nerr = -EINVAL;\r\ngoto err2;\r\n}\r\npriv->sreg = nft_parse_register(tb[NFTA_RANGE_SREG]);\r\nerr = nft_validate_register_load(priv->sreg, desc_from.len);\r\nif (err < 0)\r\ngoto err2;\r\nerr = nft_parse_u32_check(tb[NFTA_RANGE_OP], U8_MAX, &op);\r\nif (err < 0)\r\ngoto err2;\r\nswitch (op) {\r\ncase NFT_RANGE_EQ:\r\ncase NFT_RANGE_NEQ:\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto err2;\r\n}\r\npriv->op = op;\r\npriv->len = desc_from.len;\r\nreturn 0;\r\nerr2:\r\nnft_data_uninit(&priv->data_to, desc_to.type);\r\nerr1:\r\nnft_data_uninit(&priv->data_from, desc_from.type);\r\nreturn err;\r\n}\r\nstatic int nft_range_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_range_expr *priv = nft_expr_priv(expr);\r\nif (nft_dump_register(skb, NFTA_RANGE_SREG, priv->sreg))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_RANGE_OP, htonl(priv->op)))\r\ngoto nla_put_failure;\r\nif (nft_data_dump(skb, NFTA_RANGE_FROM_DATA, &priv->data_from,\r\nNFT_DATA_VALUE, priv->len) < 0 ||\r\nnft_data_dump(skb, NFTA_RANGE_TO_DATA, &priv->data_to,\r\nNFT_DATA_VALUE, priv->len) < 0)\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}
