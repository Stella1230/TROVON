static int\r\nsddr55_bulk_transport(struct us_data *us, int direction,\r\nunsigned char *data, unsigned int len) {\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\r\nunsigned int pipe = (direction == DMA_FROM_DEVICE) ?\r\nus->recv_bulk_pipe : us->send_bulk_pipe;\r\nif (!len)\r\nreturn USB_STOR_XFER_GOOD;\r\ninfo->last_access = jiffies;\r\nreturn usb_stor_bulk_transfer_buf(us, pipe, data, len, NULL);\r\n}\r\nstatic int sddr55_status(struct us_data *us)\r\n{\r\nint result;\r\nunsigned char *command = us->iobuf;\r\nunsigned char *status = us->iobuf;\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\r\nmemset(command, 0, 8);\r\ncommand[5] = 0xB0;\r\ncommand[7] = 0x80;\r\nresult = sddr55_bulk_transport(us,\r\nDMA_TO_DEVICE, command, 8);\r\nusb_stor_dbg(us, "Result for send_command in status %d\n", result);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nset_sense_info (4, 0, 0);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, status, 4);\r\nif (result == USB_STOR_XFER_SHORT || result == USB_STOR_XFER_STALLED) {\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\ninfo->lba_to_pba = NULL;\r\ninfo->pba_to_lba = NULL;\r\ninfo->fatal_error = 0;\r\ninfo->force_read_only = 0;\r\nset_sense_info (2, 0x3a, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (result != USB_STOR_XFER_GOOD) {\r\nset_sense_info (4, 0, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\ninfo->read_only = (status[0] & 0x20);\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, status, 2);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nset_sense_info (4, 0, 0);\r\n}\r\nreturn (result == USB_STOR_XFER_GOOD ?\r\nUSB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_FAILED);\r\n}\r\nstatic int sddr55_read_data(struct us_data *us,\r\nunsigned int lba,\r\nunsigned int page,\r\nunsigned short sectors) {\r\nint result = USB_STOR_TRANSPORT_GOOD;\r\nunsigned char *command = us->iobuf;\r\nunsigned char *status = us->iobuf;\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\r\nunsigned char *buffer;\r\nunsigned int pba;\r\nunsigned long address;\r\nunsigned short pages;\r\nunsigned int len, offset;\r\nstruct scatterlist *sg;\r\nlen = min((unsigned int) sectors, (unsigned int) info->blocksize >>\r\ninfo->smallpageshift) * PAGESIZE;\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors>0) {\r\nif (lba >= info->max_log_blks)\r\nbreak;\r\npba = info->lba_to_pba[lba];\r\npages = min((unsigned int) sectors << info->smallpageshift,\r\ninfo->blocksize - page);\r\nlen = pages << info->pageshift;\r\nusb_stor_dbg(us, "Read %02X pages, from PBA %04X (LBA %04X) page %02X\n",\r\npages, pba, lba, page);\r\nif (pba == NOT_ALLOCATED) {\r\nmemset (buffer, 0, len);\r\n} else {\r\naddress = (pba << info->blockshift) + page;\r\ncommand[0] = 0;\r\ncommand[1] = LSB_of(address>>16);\r\ncommand[2] = LSB_of(address>>8);\r\ncommand[3] = LSB_of(address);\r\ncommand[4] = 0;\r\ncommand[5] = 0xB0;\r\ncommand[6] = LSB_of(pages << (1 - info->smallpageshift));\r\ncommand[7] = 0x85;\r\nresult = sddr55_bulk_transport(us,\r\nDMA_TO_DEVICE, command, 8);\r\nusb_stor_dbg(us, "Result for send_command in read_data %d\n",\r\nresult);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, status, 2);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nif (status[0] == 0xff && status[1] == 0x4) {\r\nset_sense_info (3, 0x11, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\n}\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, TO_XFER_BUF);\r\npage = 0;\r\nlba++;\r\nsectors -= pages >> info->smallpageshift;\r\n}\r\nresult = USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int sddr55_write_data(struct us_data *us,\r\nunsigned int lba,\r\nunsigned int page,\r\nunsigned short sectors) {\r\nint result = USB_STOR_TRANSPORT_GOOD;\r\nunsigned char *command = us->iobuf;\r\nunsigned char *status = us->iobuf;\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\r\nunsigned char *buffer;\r\nunsigned int pba;\r\nunsigned int new_pba;\r\nunsigned long address;\r\nunsigned short pages;\r\nint i;\r\nunsigned int len, offset;\r\nstruct scatterlist *sg;\r\nif (info->read_only || info->force_read_only) {\r\nset_sense_info (7, 0x27, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nlen = min((unsigned int) sectors, (unsigned int) info->blocksize >>\r\ninfo->smallpageshift) * PAGESIZE;\r\nbuffer = kmalloc(len, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\noffset = 0;\r\nsg = NULL;\r\nwhile (sectors > 0) {\r\nif (lba >= info->max_log_blks)\r\nbreak;\r\npba = info->lba_to_pba[lba];\r\npages = min((unsigned int) sectors << info->smallpageshift,\r\ninfo->blocksize - page);\r\nlen = pages << info->pageshift;\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &offset, FROM_XFER_BUF);\r\nusb_stor_dbg(us, "Write %02X pages, to PBA %04X (LBA %04X) page %02X\n",\r\npages, pba, lba, page);\r\ncommand[4] = 0;\r\nif (pba == NOT_ALLOCATED) {\r\nint max_pba = (info->max_log_blks / 250 ) * 256;\r\nint found_count = 0;\r\nint found_pba = -1;\r\npba = (lba / 1000) * 1024;\r\nusb_stor_dbg(us, "No PBA for LBA %04X\n", lba);\r\nif (max_pba > 1024)\r\nmax_pba = 1024;\r\nfor (i = 0; i < max_pba; i++, pba++) {\r\nif (info->pba_to_lba[pba] == UNUSED_BLOCK) {\r\nfound_pba = pba;\r\nif (found_count++ > 16)\r\nbreak;\r\n}\r\n}\r\npba = found_pba;\r\nif (pba == -1) {\r\nusb_stor_dbg(us, "Couldn't find unallocated block\n");\r\nset_sense_info (3, 0x31, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\nusb_stor_dbg(us, "Allocating PBA %04X for LBA %04X\n",\r\npba, lba);\r\ncommand[4] = 0x40;\r\n}\r\naddress = (pba << info->blockshift) + page;\r\ncommand[1] = LSB_of(address>>16);\r\ncommand[2] = LSB_of(address>>8);\r\ncommand[3] = LSB_of(address);\r\ncommand[0] = LSB_of(lba % 1000);\r\ncommand[6] = MSB_of(lba % 1000);\r\ncommand[4] |= LSB_of(pages >> info->smallpageshift);\r\ncommand[5] = 0xB0;\r\ncommand[7] = 0x86;\r\nresult = sddr55_bulk_transport(us,\r\nDMA_TO_DEVICE, command, 8);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Result for send_command in write_data %d\n",\r\nresult);\r\nset_sense_info (3, 0x3, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\nresult = sddr55_bulk_transport(us,\r\nDMA_TO_DEVICE, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Result for send_data in write_data %d\n",\r\nresult);\r\nset_sense_info (3, 0x3, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\nresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, status, 6);\r\nif (result != USB_STOR_XFER_GOOD) {\r\nusb_stor_dbg(us, "Result for get_status in write_data %d\n",\r\nresult);\r\nset_sense_info (3, 0x3, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\nnew_pba = (status[3] + (status[4] << 8) + (status[5] << 16))\r\n>> info->blockshift;\r\nif (status[0] == 0xff && status[1] == 0x4) {\r\ninfo->pba_to_lba[new_pba] = BAD_BLOCK;\r\nset_sense_info (3, 0x0c, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\nusb_stor_dbg(us, "Updating maps for LBA %04X: old PBA %04X, new PBA %04X\n",\r\nlba, pba, new_pba);\r\ninfo->lba_to_pba[lba] = new_pba;\r\ninfo->pba_to_lba[pba] = UNUSED_BLOCK;\r\nif (info->pba_to_lba[new_pba] != UNUSED_BLOCK) {\r\nprintk(KERN_ERR "sddr55 error: new PBA %04X already in use for LBA %04X\n",\r\nnew_pba, info->pba_to_lba[new_pba]);\r\ninfo->fatal_error = 1;\r\nset_sense_info (3, 0x31, 0);\r\nresult = USB_STOR_TRANSPORT_FAILED;\r\ngoto leave;\r\n}\r\ninfo->pba_to_lba[new_pba] = lba % 1000;\r\npage = 0;\r\nlba++;\r\nsectors -= pages >> info->smallpageshift;\r\n}\r\nresult = USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(buffer);\r\nreturn result;\r\n}\r\nstatic int sddr55_read_deviceID(struct us_data *us,\r\nunsigned char *manufacturerID,\r\nunsigned char *deviceID) {\r\nint result;\r\nunsigned char *command = us->iobuf;\r\nunsigned char *content = us->iobuf;\r\nmemset(command, 0, 8);\r\ncommand[5] = 0xB0;\r\ncommand[7] = 0x84;\r\nresult = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);\r\nusb_stor_dbg(us, "Result of send_control for device ID is %d\n",\r\nresult);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, content, 4);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n*manufacturerID = content[0];\r\n*deviceID = content[1];\r\nif (content[0] != 0xff) {\r\nresult = sddr55_bulk_transport(us,\r\nDMA_FROM_DEVICE, content, 2);\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int sddr55_reset(struct us_data *us)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned long sddr55_get_capacity(struct us_data *us) {\r\nunsigned char uninitialized_var(manufacturerID);\r\nunsigned char uninitialized_var(deviceID);\r\nint result;\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\r\nusb_stor_dbg(us, "Reading capacity...\n");\r\nresult = sddr55_read_deviceID(us,\r\n&manufacturerID,\r\n&deviceID);\r\nusb_stor_dbg(us, "Result of read_deviceID is %d\n", result);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn 0;\r\nusb_stor_dbg(us, "Device ID = %02X\n", deviceID);\r\nusb_stor_dbg(us, "Manuf ID = %02X\n", manufacturerID);\r\ninfo->pageshift = 9;\r\ninfo->smallpageshift = 0;\r\ninfo->blocksize = 16;\r\ninfo->blockshift = 4;\r\ninfo->blockmask = 15;\r\nswitch (deviceID) {\r\ncase 0x6e:\r\ncase 0xe8:\r\ncase 0xec:\r\ninfo->pageshift = 8;\r\ninfo->smallpageshift = 1;\r\nreturn 0x00100000;\r\ncase 0xea:\r\ncase 0x64:\r\ninfo->pageshift = 8;\r\ninfo->smallpageshift = 1;\r\ncase 0x5d:\r\nreturn 0x00200000;\r\ncase 0xe3:\r\ncase 0xe5:\r\ncase 0x6b:\r\ncase 0xd5:\r\nreturn 0x00400000;\r\ncase 0xe6:\r\ncase 0xd6:\r\nreturn 0x00800000;\r\ncase 0x73:\r\ninfo->blocksize = 32;\r\ninfo->blockshift = 5;\r\ninfo->blockmask = 31;\r\nreturn 0x01000000;\r\ncase 0x75:\r\ninfo->blocksize = 32;\r\ninfo->blockshift = 5;\r\ninfo->blockmask = 31;\r\nreturn 0x02000000;\r\ncase 0x76:\r\ninfo->blocksize = 32;\r\ninfo->blockshift = 5;\r\ninfo->blockmask = 31;\r\nreturn 0x04000000;\r\ncase 0x79:\r\ninfo->blocksize = 32;\r\ninfo->blockshift = 5;\r\ninfo->blockmask = 31;\r\nreturn 0x08000000;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int sddr55_read_map(struct us_data *us) {\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)(us->extra);\r\nint numblocks;\r\nunsigned char *buffer;\r\nunsigned char *command = us->iobuf;\r\nint i;\r\nunsigned short lba;\r\nunsigned short max_lba;\r\nint result;\r\nif (!info->capacity)\r\nreturn -1;\r\nnumblocks = info->capacity >> (info->blockshift + info->pageshift);\r\nbuffer = kmalloc( numblocks * 2, GFP_NOIO );\r\nif (!buffer)\r\nreturn -1;\r\nmemset(command, 0, 8);\r\ncommand[5] = 0xB0;\r\ncommand[6] = numblocks * 2 / 256;\r\ncommand[7] = 0x8A;\r\nresult = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);\r\nif ( result != USB_STOR_XFER_GOOD) {\r\nkfree (buffer);\r\nreturn -1;\r\n}\r\nresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, buffer, numblocks * 2);\r\nif ( result != USB_STOR_XFER_GOOD) {\r\nkfree (buffer);\r\nreturn -1;\r\n}\r\nresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, command, 2);\r\nif ( result != USB_STOR_XFER_GOOD) {\r\nkfree (buffer);\r\nreturn -1;\r\n}\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\ninfo->lba_to_pba = kmalloc(numblocks*sizeof(int), GFP_NOIO);\r\ninfo->pba_to_lba = kmalloc(numblocks*sizeof(int), GFP_NOIO);\r\nif (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\ninfo->lba_to_pba = NULL;\r\ninfo->pba_to_lba = NULL;\r\nkfree(buffer);\r\nreturn -1;\r\n}\r\nmemset(info->lba_to_pba, 0xff, numblocks*sizeof(int));\r\nmemset(info->pba_to_lba, 0xff, numblocks*sizeof(int));\r\nmax_lba = info->max_log_blks;\r\nif (max_lba > 1000)\r\nmax_lba = 1000;\r\nfor (i=0; i<numblocks; i++) {\r\nint zone = i / 1024;\r\nlba = short_pack(buffer[i * 2], buffer[i * 2 + 1]);\r\ninfo->pba_to_lba[i] = lba;\r\nif (lba >= max_lba) {\r\ncontinue;\r\n}\r\nif (info->lba_to_pba[lba + zone * 1000] != NOT_ALLOCATED &&\r\n!info->force_read_only) {\r\nprintk(KERN_WARNING\r\n"sddr55: map inconsistency at LBA %04X\n",\r\nlba + zone * 1000);\r\ninfo->force_read_only = 1;\r\n}\r\nif (lba<0x10 || (lba>=0x3E0 && lba<0x3EF))\r\nusb_stor_dbg(us, "LBA %04X <-> PBA %04X\n", lba, i);\r\ninfo->lba_to_pba[lba + zone * 1000] = i;\r\n}\r\nkfree(buffer);\r\nreturn 0;\r\n}\r\nstatic void sddr55_card_info_destructor(void *extra) {\r\nstruct sddr55_card_info *info = (struct sddr55_card_info *)extra;\r\nif (!extra)\r\nreturn;\r\nkfree(info->lba_to_pba);\r\nkfree(info->pba_to_lba);\r\n}\r\nstatic int sddr55_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nint result;\r\nstatic unsigned char inquiry_response[8] = {\r\n0x00, 0x80, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00\r\n};\r\nstatic unsigned char mode_page_01[20] = {\r\n0x0, 0x12, 0x00, 0x80, 0x0, 0x0, 0x0, 0x0,\r\n0x01, 0x0A,\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\nunsigned char *ptr = us->iobuf;\r\nunsigned long capacity;\r\nunsigned int lba;\r\nunsigned int pba;\r\nunsigned int page;\r\nunsigned short pages;\r\nstruct sddr55_card_info *info;\r\nif (!us->extra) {\r\nus->extra = kzalloc(\r\nsizeof(struct sddr55_card_info), GFP_NOIO);\r\nif (!us->extra)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nus->extra_destructor = sddr55_card_info_destructor;\r\n}\r\ninfo = (struct sddr55_card_info *)(us->extra);\r\nif (srb->cmnd[0] == REQUEST_SENSE) {\r\nusb_stor_dbg(us, "request sense %02x/%02x/%02x\n",\r\ninfo->sense_data[2],\r\ninfo->sense_data[12],\r\ninfo->sense_data[13]);\r\nmemcpy (ptr, info->sense_data, sizeof info->sense_data);\r\nptr[0] = 0x70;\r\nptr[7] = 11;\r\nusb_stor_set_xfer_buf (ptr, sizeof info->sense_data, srb);\r\nmemset (info->sense_data, 0, sizeof info->sense_data);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nmemset (info->sense_data, 0, sizeof info->sense_data);\r\nif (srb->cmnd[0] == INQUIRY) {\r\nmemcpy(ptr, inquiry_response, 8);\r\nfill_inquiry_response(us, ptr, 36);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (info->lba_to_pba == NULL || time_after(jiffies, info->last_access + HZ/2)) {\r\nresult = sddr55_status (us);\r\nif (result) {\r\nresult = sddr55_status (us);\r\nif (!result) {\r\nset_sense_info (6, 0x28, 0);\r\n}\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\n}\r\nif (info->fatal_error) {\r\nset_sense_info (3, 0x31, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (srb->cmnd[0] == READ_CAPACITY) {\r\ncapacity = sddr55_get_capacity(us);\r\nif (!capacity) {\r\nset_sense_info (3, 0x30, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\ninfo->capacity = capacity;\r\ninfo->max_log_blks = ((info->capacity >> (info->pageshift + info->blockshift)) / 256) * 250;\r\ncapacity = (capacity / 256) * 250;\r\ncapacity /= PAGESIZE;\r\ncapacity--;\r\n((__be32 *) ptr)[0] = cpu_to_be32(capacity);\r\n((__be32 *) ptr)[1] = cpu_to_be32(PAGESIZE);\r\nusb_stor_set_xfer_buf(ptr, 8, srb);\r\nsddr55_read_map(us);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE_10) {\r\nmemcpy(ptr, mode_page_01, sizeof mode_page_01);\r\nptr[3] = (info->read_only || info->force_read_only) ? 0x80 : 0;\r\nusb_stor_set_xfer_buf(ptr, sizeof(mode_page_01), srb);\r\nif ( (srb->cmnd[2] & 0x3F) == 0x01 ) {\r\nusb_stor_dbg(us, "Dummy up request for mode page 1\n");\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n} else if ( (srb->cmnd[2] & 0x3F) == 0x3F ) {\r\nusb_stor_dbg(us, "Dummy up request for all mode pages\n");\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nset_sense_info (5, 0x24, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nusb_stor_dbg(us, "%s medium removal. Not that I can do anything about it...\n",\r\n(srb->cmnd[4]&0x03) ? "Prevent" : "Allow");\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10) {\r\npage = short_pack(srb->cmnd[3], srb->cmnd[2]);\r\npage <<= 16;\r\npage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\r\npages = short_pack(srb->cmnd[8], srb->cmnd[7]);\r\npage <<= info->smallpageshift;\r\nlba = page >> info->blockshift;\r\npage = page & info->blockmask;\r\nif (lba >= info->max_log_blks) {\r\nusb_stor_dbg(us, "Error: Requested LBA %04X exceeds maximum block %04X\n",\r\nlba, info->max_log_blks - 1);\r\nset_sense_info (5, 0x24, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\npba = info->lba_to_pba[lba];\r\nif (srb->cmnd[0] == WRITE_10) {\r\nusb_stor_dbg(us, "WRITE_10: write block %04X (LBA %04X) page %01X pages %d\n",\r\npba, lba, page, pages);\r\nreturn sddr55_write_data(us, lba, page, pages);\r\n} else {\r\nusb_stor_dbg(us, "READ_10: read block %04X (LBA %04X) page %01X pages %d\n",\r\npba, lba, page, pages);\r\nreturn sddr55_read_data(us, lba, page, pages);\r\n}\r\n}\r\nif (srb->cmnd[0] == TEST_UNIT_READY) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == START_STOP) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nset_sense_info (5, 0x20, 0);\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nstatic int sddr55_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - sddr55_usb_ids) + sddr55_unusual_dev_list,\r\n&sddr55_host_template);\r\nif (result)\r\nreturn result;\r\nus->transport_name = "SDDR55";\r\nus->transport = sddr55_transport;\r\nus->transport_reset = sddr55_reset;\r\nus->max_lun = 0;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
