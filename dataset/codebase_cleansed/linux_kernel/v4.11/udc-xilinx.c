static void xudc_write32(void __iomem *addr, u32 offset, u32 val)\r\n{\r\niowrite32(val, addr + offset);\r\n}\r\nstatic unsigned int xudc_read32(void __iomem *addr)\r\n{\r\nreturn ioread32(addr);\r\n}\r\nstatic void xudc_write32_be(void __iomem *addr, u32 offset, u32 val)\r\n{\r\niowrite32be(val, addr + offset);\r\n}\r\nstatic unsigned int xudc_read32_be(void __iomem *addr)\r\n{\r\nreturn ioread32be(addr);\r\n}\r\nstatic void xudc_wrstatus(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\r\nu32 epcfgreg;\r\nepcfgreg = udc->read_fn(udc->addr + ep0->offset)|\r\nXUSB_EP_CFG_DATA_TOGGLE_MASK;\r\nudc->write_fn(udc->addr, ep0->offset, epcfgreg);\r\nudc->write_fn(udc->addr, ep0->offset + XUSB_EP_BUF0COUNT_OFFSET, 0);\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\r\n}\r\nstatic void xudc_epconfig(struct xusb_ep *ep, struct xusb_udc *udc)\r\n{\r\nu32 epcfgreg;\r\nepcfgreg = ((ep->is_in << 29) | (ep->is_iso << 28) |\r\n(ep->ep_usb.maxpacket << 15) | (ep->rambase));\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\nudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF0COUNT_OFFSET,\r\nep->buffer0count);\r\nudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF1COUNT_OFFSET,\r\nep->buffer1count);\r\nif (ep->buffer0ready)\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n1 << ep->epnumber);\r\nif (ep->buffer1ready)\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\r\n}\r\nstatic int xudc_start_dma(struct xusb_ep *ep, dma_addr_t src,\r\ndma_addr_t dst, u32 length)\r\n{\r\nstruct xusb_udc *udc = ep->udc;\r\nint rc = 0;\r\nu32 timeout = 500;\r\nu32 reg;\r\nudc->write_fn(udc->addr, XUSB_DMA_DSAR_ADDR_OFFSET, src);\r\nudc->write_fn(udc->addr, XUSB_DMA_DDAR_ADDR_OFFSET, dst);\r\nudc->write_fn(udc->addr, XUSB_DMA_LENGTH_OFFSET, length);\r\ndo {\r\nreg = udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET);\r\nif (!(reg & XUSB_DMA_DMASR_BUSY))\r\nbreak;\r\ntimeout--;\r\nif (!timeout) {\r\ndev_err(udc->dev, "DMA timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\n} while (1);\r\nif ((udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET) &\r\nXUSB_DMA_DMASR_ERROR) == XUSB_DMA_DMASR_ERROR){\r\ndev_err(udc->dev, "DMA Error\n");\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int xudc_dma_send(struct xusb_ep *ep, struct xusb_req *req,\r\nu8 *buffer, u32 length)\r\n{\r\nu32 *eprambase;\r\ndma_addr_t src;\r\ndma_addr_t dst;\r\nstruct xusb_udc *udc = ep->udc;\r\nsrc = req->usb_req.dma + req->usb_req.actual;\r\nif (req->usb_req.length)\r\ndma_sync_single_for_device(udc->dev, src,\r\nlength, DMA_TO_DEVICE);\r\nif (!ep->curbufnum && !ep->buffer0ready) {\r\neprambase = (u32 __force *)(udc->addr + ep->rambase);\r\ndst = virt_to_phys(eprambase);\r\nudc->write_fn(udc->addr, ep->offset +\r\nXUSB_EP_BUF0COUNT_OFFSET, length);\r\nudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\r\nXUSB_DMA_BRR_CTRL | (1 << ep->epnumber));\r\nep->buffer0ready = 1;\r\nep->curbufnum = 1;\r\n} else if (ep->curbufnum && !ep->buffer1ready) {\r\neprambase = (u32 __force *)(udc->addr + ep->rambase +\r\nep->ep_usb.maxpacket);\r\ndst = virt_to_phys(eprambase);\r\nudc->write_fn(udc->addr, ep->offset +\r\nXUSB_EP_BUF1COUNT_OFFSET, length);\r\nudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\r\nXUSB_DMA_BRR_CTRL | (1 << (ep->epnumber +\r\nXUSB_STATUS_EP_BUFF2_SHIFT)));\r\nep->buffer1ready = 1;\r\nep->curbufnum = 0;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\nreturn xudc_start_dma(ep, src, dst, length);\r\n}\r\nstatic int xudc_dma_receive(struct xusb_ep *ep, struct xusb_req *req,\r\nu8 *buffer, u32 length)\r\n{\r\nu32 *eprambase;\r\ndma_addr_t src;\r\ndma_addr_t dst;\r\nstruct xusb_udc *udc = ep->udc;\r\ndst = req->usb_req.dma + req->usb_req.actual;\r\nif (!ep->curbufnum && !ep->buffer0ready) {\r\neprambase = (u32 __force *)(udc->addr + ep->rambase);\r\nsrc = virt_to_phys(eprambase);\r\nudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\r\nXUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\r\n(1 << ep->epnumber));\r\nep->buffer0ready = 1;\r\nep->curbufnum = 1;\r\n} else if (ep->curbufnum && !ep->buffer1ready) {\r\neprambase = (u32 __force *)(udc->addr +\r\nep->rambase + ep->ep_usb.maxpacket);\r\nsrc = virt_to_phys(eprambase);\r\nudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\r\nXUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\r\n(1 << (ep->epnumber +\r\nXUSB_STATUS_EP_BUFF2_SHIFT)));\r\nep->buffer1ready = 1;\r\nep->curbufnum = 0;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\nreturn xudc_start_dma(ep, src, dst, length);\r\n}\r\nstatic int xudc_eptxrx(struct xusb_ep *ep, struct xusb_req *req,\r\nu8 *bufferptr, u32 bufferlen)\r\n{\r\nu32 *eprambase;\r\nu32 bytestosend;\r\nint rc = 0;\r\nstruct xusb_udc *udc = ep->udc;\r\nbytestosend = bufferlen;\r\nif (udc->dma_enabled) {\r\nif (ep->is_in)\r\nrc = xudc_dma_send(ep, req, bufferptr, bufferlen);\r\nelse\r\nrc = xudc_dma_receive(ep, req, bufferptr, bufferlen);\r\nreturn rc;\r\n}\r\nif (!ep->curbufnum && !ep->buffer0ready) {\r\neprambase = (u32 __force *)(udc->addr + ep->rambase);\r\nif (ep->is_in) {\r\nmemcpy(eprambase, bufferptr, bytestosend);\r\nudc->write_fn(udc->addr, ep->offset +\r\nXUSB_EP_BUF0COUNT_OFFSET, bufferlen);\r\n} else {\r\nmemcpy(bufferptr, eprambase, bytestosend);\r\n}\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n1 << ep->epnumber);\r\nep->buffer0ready = 1;\r\nep->curbufnum = 1;\r\n} else if (ep->curbufnum && !ep->buffer1ready) {\r\neprambase = (u32 __force *)(udc->addr + ep->rambase +\r\nep->ep_usb.maxpacket);\r\nif (ep->is_in) {\r\nmemcpy(eprambase, bufferptr, bytestosend);\r\nudc->write_fn(udc->addr, ep->offset +\r\nXUSB_EP_BUF1COUNT_OFFSET, bufferlen);\r\n} else {\r\nmemcpy(bufferptr, eprambase, bytestosend);\r\n}\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\r\nep->buffer1ready = 1;\r\nep->curbufnum = 0;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\nreturn rc;\r\n}\r\nstatic void xudc_done(struct xusb_ep *ep, struct xusb_req *req, int status)\r\n{\r\nstruct xusb_udc *udc = ep->udc;\r\nlist_del_init(&req->queue);\r\nif (req->usb_req.status == -EINPROGRESS)\r\nreq->usb_req.status = status;\r\nelse\r\nstatus = req->usb_req.status;\r\nif (status && status != -ESHUTDOWN)\r\ndev_dbg(udc->dev, "%s done %p, status %d\n",\r\nep->ep_usb.name, req, status);\r\nif (udc->dma_enabled && ep->epnumber && req->usb_req.length)\r\nusb_gadget_unmap_request(&udc->gadget, &req->usb_req,\r\nep->is_in);\r\nif (req->usb_req.complete) {\r\nspin_unlock(&udc->lock);\r\nreq->usb_req.complete(&ep->ep_usb, &req->usb_req);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nstatic int xudc_read_fifo(struct xusb_ep *ep, struct xusb_req *req)\r\n{\r\nu8 *buf;\r\nu32 is_short, count, bufferspace;\r\nu8 bufoffset;\r\nu8 two_pkts = 0;\r\nint ret;\r\nint retval = -EAGAIN;\r\nstruct xusb_udc *udc = ep->udc;\r\nif (ep->buffer0ready && ep->buffer1ready) {\r\ndev_dbg(udc->dev, "Packet NOT ready!\n");\r\nreturn retval;\r\n}\r\ntop:\r\nif (ep->curbufnum)\r\nbufoffset = XUSB_EP_BUF1COUNT_OFFSET;\r\nelse\r\nbufoffset = XUSB_EP_BUF0COUNT_OFFSET;\r\ncount = udc->read_fn(udc->addr + ep->offset + bufoffset);\r\nif (!ep->buffer0ready && !ep->buffer1ready)\r\ntwo_pkts = 1;\r\nbuf = req->usb_req.buf + req->usb_req.actual;\r\nprefetchw(buf);\r\nbufferspace = req->usb_req.length - req->usb_req.actual;\r\nis_short = count < ep->ep_usb.maxpacket;\r\nif (unlikely(!bufferspace)) {\r\nif (req->usb_req.status != -EOVERFLOW)\r\ndev_dbg(udc->dev, "%s overflow %d\n",\r\nep->ep_usb.name, count);\r\nreq->usb_req.status = -EOVERFLOW;\r\nxudc_done(ep, req, -EOVERFLOW);\r\nreturn 0;\r\n}\r\nret = xudc_eptxrx(ep, req, buf, count);\r\nswitch (ret) {\r\ncase 0:\r\nreq->usb_req.actual += min(count, bufferspace);\r\ndev_dbg(udc->dev, "read %s, %d bytes%s req %p %d/%d\n",\r\nep->ep_usb.name, count, is_short ? "/S" : "", req,\r\nreq->usb_req.actual, req->usb_req.length);\r\nbufferspace -= count;\r\nif ((req->usb_req.actual == req->usb_req.length) || is_short) {\r\nif (udc->dma_enabled && req->usb_req.length)\r\ndma_sync_single_for_cpu(udc->dev,\r\nreq->usb_req.dma,\r\nreq->usb_req.actual,\r\nDMA_FROM_DEVICE);\r\nxudc_done(ep, req, 0);\r\nreturn 0;\r\n}\r\nif (two_pkts) {\r\ntwo_pkts = 0;\r\ngoto top;\r\n}\r\nbreak;\r\ncase -EAGAIN:\r\ndev_dbg(udc->dev, "receive busy\n");\r\nbreak;\r\ncase -EINVAL:\r\ncase -ETIMEDOUT:\r\nxudc_done(ep, req, -ECONNRESET);\r\nretval = 0;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int xudc_write_fifo(struct xusb_ep *ep, struct xusb_req *req)\r\n{\r\nu32 max;\r\nu32 length;\r\nint ret;\r\nint retval = -EAGAIN;\r\nstruct xusb_udc *udc = ep->udc;\r\nint is_last, is_short = 0;\r\nu8 *buf;\r\nmax = le16_to_cpu(ep->desc->wMaxPacketSize);\r\nbuf = req->usb_req.buf + req->usb_req.actual;\r\nprefetch(buf);\r\nlength = req->usb_req.length - req->usb_req.actual;\r\nlength = min(length, max);\r\nret = xudc_eptxrx(ep, req, buf, length);\r\nswitch (ret) {\r\ncase 0:\r\nreq->usb_req.actual += length;\r\nif (unlikely(length != max)) {\r\nis_last = is_short = 1;\r\n} else {\r\nif (likely(req->usb_req.length !=\r\nreq->usb_req.actual) || req->usb_req.zero)\r\nis_last = 0;\r\nelse\r\nis_last = 1;\r\n}\r\ndev_dbg(udc->dev, "%s: wrote %s %d bytes%s%s %d left %p\n",\r\n__func__, ep->ep_usb.name, length, is_last ? "/L" : "",\r\nis_short ? "/S" : "",\r\nreq->usb_req.length - req->usb_req.actual, req);\r\nif (is_last) {\r\nxudc_done(ep, req, 0);\r\nretval = 0;\r\n}\r\nbreak;\r\ncase -EAGAIN:\r\ndev_dbg(udc->dev, "Send busy\n");\r\nbreak;\r\ncase -EINVAL:\r\ncase -ETIMEDOUT:\r\nxudc_done(ep, req, -ECONNRESET);\r\nretval = 0;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void xudc_nuke(struct xusb_ep *ep, int status)\r\n{\r\nstruct xusb_req *req;\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_first_entry(&ep->queue, struct xusb_req, queue);\r\nxudc_done(ep, req, status);\r\n}\r\n}\r\nstatic int xudc_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct xusb_ep *ep = to_xusb_ep(_ep);\r\nstruct xusb_udc *udc;\r\nunsigned long flags;\r\nu32 epcfgreg;\r\nif (!_ep || (!ep->desc && ep->epnumber)) {\r\npr_debug("%s: bad ep or descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (ep->is_in && (!list_empty(&ep->queue)) && value) {\r\ndev_dbg(udc->dev, "requests pending can't halt\n");\r\nreturn -EAGAIN;\r\n}\r\nif (ep->buffer0ready || ep->buffer1ready) {\r\ndev_dbg(udc->dev, "HW buffers busy can't halt\n");\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (value) {\r\nepcfgreg = udc->read_fn(udc->addr + ep->offset);\r\nepcfgreg |= XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\n} else {\r\nepcfgreg = udc->read_fn(udc->addr + ep->offset);\r\nepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\nif (ep->epnumber) {\r\nepcfgreg = udc->read_fn(ep->udc->addr + ep->offset);\r\nepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __xudc_ep_enable(struct xusb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct xusb_udc *udc = ep->udc;\r\nu32 tmp;\r\nu32 epcfg;\r\nu32 ier;\r\nu16 maxpacket;\r\nep->is_in = ((desc->bEndpointAddress & USB_DIR_IN) != 0);\r\nep->epnumber = (desc->bEndpointAddress & 0x0f);\r\nep->desc = desc;\r\nep->ep_usb.desc = desc;\r\ntmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nep->ep_usb.maxpacket = maxpacket = le16_to_cpu(desc->wMaxPacketSize);\r\nswitch (tmp) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ndev_dbg(udc->dev, "only one control endpoint\n");\r\nep->is_iso = 0;\r\nreturn -EINVAL;\r\ncase USB_ENDPOINT_XFER_INT:\r\nep->is_iso = 0;\r\nif (maxpacket > 64) {\r\ndev_dbg(udc->dev, "bogus maxpacket %d\n", maxpacket);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nep->is_iso = 0;\r\nif (!(is_power_of_2(maxpacket) && maxpacket >= 8 &&\r\nmaxpacket <= 512)) {\r\ndev_dbg(udc->dev, "bogus maxpacket %d\n", maxpacket);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nep->is_iso = 1;\r\nbreak;\r\n}\r\nep->buffer0ready = 0;\r\nep->buffer1ready = 0;\r\nep->curbufnum = 0;\r\nep->rambase = rambase[ep->epnumber];\r\nxudc_epconfig(ep, udc);\r\ndev_dbg(udc->dev, "Enable Endpoint %d max pkt is %d\n",\r\nep->epnumber, maxpacket);\r\nepcfg = udc->read_fn(udc->addr + ep->offset);\r\nepcfg |= XUSB_EP_CFG_VALID_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfg);\r\nif (ep->epnumber)\r\nep->rambase <<= 2;\r\nier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nier |= (XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK << ep->epnumber);\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\r\nif (ep->epnumber && !ep->is_in) {\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n1 << ep->epnumber);\r\nep->buffer0ready = 1;\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\r\n(1 << (ep->epnumber +\r\nXUSB_STATUS_EP_BUFF2_SHIFT)));\r\nep->buffer1ready = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xudc_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct xusb_ep *ep;\r\nstruct xusb_udc *udc;\r\nunsigned long flags;\r\nint ret;\r\nif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\r\npr_debug("%s: bad ep or descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = to_xusb_ep(_ep);\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_dbg(udc->dev, "bogus device state\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nret = __xudc_ep_enable(ep, desc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int xudc_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct xusb_ep *ep;\r\nunsigned long flags;\r\nu32 epcfg;\r\nstruct xusb_udc *udc;\r\nif (!_ep) {\r\npr_debug("%s: invalid ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nep = to_xusb_ep(_ep);\r\nudc = ep->udc;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nxudc_nuke(ep, -ESHUTDOWN);\r\nep->desc = NULL;\r\nep->ep_usb.desc = NULL;\r\ndev_dbg(udc->dev, "USB Ep %d disable\n ", ep->epnumber);\r\nepcfg = udc->read_fn(udc->addr + ep->offset);\r\nepcfg &= ~XUSB_EP_CFG_VALID_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfg);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *xudc_ep_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct xusb_ep *ep = to_xusb_ep(_ep);\r\nstruct xusb_udc *udc;\r\nstruct xusb_req *req;\r\nudc = ep->udc;\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreq->ep = ep;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->usb_req;\r\n}\r\nstatic void xudc_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct xusb_req *req = to_xusb_req(_req);\r\nkfree(req);\r\n}\r\nstatic int __xudc_ep0_queue(struct xusb_ep *ep0, struct xusb_req *req)\r\n{\r\nstruct xusb_udc *udc = ep0->udc;\r\nu32 length;\r\nu8 *corebuf;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_dbg(udc->dev, "%s, bogus device state\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!list_empty(&ep0->queue)) {\r\ndev_dbg(udc->dev, "%s:ep0 busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nreq->usb_req.status = -EINPROGRESS;\r\nreq->usb_req.actual = 0;\r\nlist_add_tail(&req->queue, &ep0->queue);\r\nif (udc->setup.bRequestType & USB_DIR_IN) {\r\nprefetch(req->usb_req.buf);\r\nlength = req->usb_req.length;\r\ncorebuf = (void __force *) ((ep0->rambase << 2) +\r\nudc->addr);\r\nlength = req->usb_req.actual = min_t(u32, length,\r\nEP0_MAX_PACKET);\r\nmemcpy(corebuf, req->usb_req.buf, length);\r\nudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, length);\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\r\n} else {\r\nif (udc->setup.wLength) {\r\nudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\r\n} else {\r\nxudc_wrstatus(udc);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xudc_ep0_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct xusb_req *req = to_xusb_req(_req);\r\nstruct xusb_ep *ep0 = to_xusb_ep(_ep);\r\nstruct xusb_udc *udc = ep0->udc;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nret = __xudc_ep0_queue(ep0, req);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int xudc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct xusb_req *req = to_xusb_req(_req);\r\nstruct xusb_ep *ep = to_xusb_ep(_ep);\r\nstruct xusb_udc *udc = ep->udc;\r\nint ret;\r\nunsigned long flags;\r\nif (!ep->desc) {\r\ndev_dbg(udc->dev, "%s:queing request to disabled %s\n",\r\n__func__, ep->name);\r\nreturn -ESHUTDOWN;\r\n}\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_dbg(udc->dev, "%s, bogus device state\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (udc->dma_enabled) {\r\nret = usb_gadget_map_request(&udc->gadget, &req->usb_req,\r\nep->is_in);\r\nif (ret) {\r\ndev_dbg(udc->dev, "gadget_map failed ep%d\n",\r\nep->epnumber);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nif (list_empty(&ep->queue)) {\r\nif (ep->is_in) {\r\ndev_dbg(udc->dev, "xudc_write_fifo from ep_queue\n");\r\nif (!xudc_write_fifo(ep, req))\r\nreq = NULL;\r\n} else {\r\ndev_dbg(udc->dev, "xudc_read_fifo from ep_queue\n");\r\nif (!xudc_read_fifo(ep, req))\r\nreq = NULL;\r\n}\r\n}\r\nif (req != NULL)\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xudc_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct xusb_ep *ep = to_xusb_ep(_ep);\r\nstruct xusb_req *req = to_xusb_req(_req);\r\nstruct xusb_udc *udc = ep->udc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->usb_req == _req)\r\nbreak;\r\n}\r\nif (&req->usb_req != _req) {\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nxudc_done(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xudc_ep0_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int xudc_ep0_disable(struct usb_ep *ep)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int xudc_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct xusb_udc *udc;\r\nint frame;\r\nif (!gadget)\r\nreturn -ENODEV;\r\nudc = to_udc(gadget);\r\nframe = udc->read_fn(udc->addr + XUSB_FRAMENUM_OFFSET);\r\nreturn frame;\r\n}\r\nstatic int xudc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct xusb_udc *udc = to_udc(gadget);\r\nu32 crtlreg;\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!udc->remote_wkp)\r\ngoto done;\r\ncrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\r\ncrtlreg |= XUSB_CONTROL_USB_RMTWAKE_MASK;\r\nudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\r\nmdelay(2);\r\ncrtlreg &= ~XUSB_CONTROL_USB_RMTWAKE_MASK;\r\nudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\r\nstatus = 0;\r\ndone:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic int xudc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct xusb_udc *udc = to_udc(gadget);\r\nunsigned long flags;\r\nu32 crtlreg;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ncrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\r\nif (is_on)\r\ncrtlreg |= XUSB_CONTROL_USB_READY_MASK;\r\nelse\r\ncrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\r\nudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void xudc_eps_init(struct xusb_udc *udc)\r\n{\r\nu32 ep_number;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nfor (ep_number = 0; ep_number < XUSB_MAX_ENDPOINTS; ep_number++) {\r\nstruct xusb_ep *ep = &udc->ep[ep_number];\r\nif (ep_number) {\r\nlist_add_tail(&ep->ep_usb.ep_list,\r\n&udc->gadget.ep_list);\r\nusb_ep_set_maxpacket_limit(&ep->ep_usb,\r\n(unsigned short) ~0);\r\nsnprintf(ep->name, EPNAME_SIZE, "ep%d", ep_number);\r\nep->ep_usb.name = ep->name;\r\nep->ep_usb.ops = &xusb_ep_ops;\r\nep->ep_usb.caps.type_iso = true;\r\nep->ep_usb.caps.type_bulk = true;\r\nep->ep_usb.caps.type_int = true;\r\n} else {\r\nep->ep_usb.name = ep0name;\r\nusb_ep_set_maxpacket_limit(&ep->ep_usb, EP0_MAX_PACKET);\r\nep->ep_usb.ops = &xusb_ep0_ops;\r\nep->ep_usb.caps.type_control = true;\r\n}\r\nep->ep_usb.caps.dir_in = true;\r\nep->ep_usb.caps.dir_out = true;\r\nep->udc = udc;\r\nep->epnumber = ep_number;\r\nep->desc = NULL;\r\nep->offset = XUSB_EP0_CONFIG_OFFSET + (ep_number * 0x10);\r\nep->is_in = 0;\r\nep->is_iso = 0;\r\nep->maxpacket = 0;\r\nxudc_epconfig(ep, udc);\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\n}\r\nstatic void xudc_stop_activity(struct xusb_udc *udc)\r\n{\r\nint i;\r\nstruct xusb_ep *ep;\r\nfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\r\nep = &udc->ep[i];\r\nxudc_nuke(ep, -ESHUTDOWN);\r\n}\r\n}\r\nstatic int xudc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct xusb_udc *udc = to_udc(gadget);\r\nstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\r\nconst struct usb_endpoint_descriptor *desc = &config_bulk_out_desc;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (udc->driver) {\r\ndev_err(udc->dev, "%s is already bound to %s\n",\r\nudc->gadget.name, udc->driver->driver.name);\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nudc->driver = driver;\r\nudc->gadget.speed = driver->max_speed;\r\nret = __xudc_ep_enable(ep0, desc);\r\nudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\r\nudc->remote_wkp = 0;\r\nerr:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int xudc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct xusb_udc *udc = to_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->driver = NULL;\r\nudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\r\nudc->remote_wkp = 0;\r\nxudc_stop_activity(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void xudc_clear_stall_all_ep(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep;\r\nu32 epcfgreg;\r\nint i;\r\nfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\r\nep = &udc->ep[i];\r\nepcfgreg = udc->read_fn(udc->addr + ep->offset);\r\nepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\nif (ep->epnumber) {\r\nepcfgreg = udc->read_fn(udc->addr + ep->offset);\r\nepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\r\nudc->write_fn(udc->addr, ep->offset, epcfgreg);\r\n}\r\n}\r\n}\r\nstatic void xudc_startup_handler(struct xusb_udc *udc, u32 intrstatus)\r\n{\r\nu32 intrreg;\r\nif (intrstatus & XUSB_STATUS_RESET_MASK) {\r\ndev_dbg(udc->dev, "Reset\n");\r\nif (intrstatus & XUSB_STATUS_HIGH_SPEED_MASK)\r\nudc->gadget.speed = USB_SPEED_HIGH;\r\nelse\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nxudc_stop_activity(udc);\r\nxudc_clear_stall_all_ep(udc);\r\nudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\r\nudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\r\nudc->remote_wkp = 0;\r\nintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nintrreg |= XUSB_STATUS_SUSPEND_MASK | XUSB_STATUS_RESUME_MASK |\r\nXUSB_STATUS_DISCONNECT_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\r\n}\r\nif (intrstatus & XUSB_STATUS_SUSPEND_MASK) {\r\ndev_dbg(udc->dev, "Suspend\n");\r\nintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\r\nXUSB_STATUS_DISCONNECT_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\r\nudc->usb_state = USB_STATE_SUSPENDED;\r\nif (udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nif (intrstatus & XUSB_STATUS_RESUME_MASK) {\r\nbool condition = (udc->usb_state != USB_STATE_SUSPENDED);\r\ndev_WARN_ONCE(udc->dev, condition,\r\n"Resume IRQ while not suspended\n");\r\ndev_dbg(udc->dev, "Resume\n");\r\nintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_SUSPEND_MASK |\r\nXUSB_STATUS_DISCONNECT_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\r\nudc->usb_state = 0;\r\nif (udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nif (intrstatus & XUSB_STATUS_DISCONNECT_MASK) {\r\ndev_dbg(udc->dev, "Disconnect\n");\r\nintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\r\nXUSB_STATUS_SUSPEND_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\r\nif (udc->driver && udc->driver->disconnect) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\n}\r\nstatic void xudc_ep0_stall(struct xusb_udc *udc)\r\n{\r\nu32 epcfgreg;\r\nstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\r\nepcfgreg = udc->read_fn(udc->addr + ep0->offset);\r\nepcfgreg |= XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr, ep0->offset, epcfgreg);\r\n}\r\nstatic void xudc_setaddress(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct xusb_req *req = udc->req;\r\nint ret;\r\nreq->usb_req.length = 0;\r\nret = __xudc_ep0_queue(ep0, req);\r\nif (ret == 0)\r\nreturn;\r\ndev_err(udc->dev, "Can't respond to SET ADDRESS request\n");\r\nxudc_ep0_stall(udc);\r\n}\r\nstatic void xudc_getstatus(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct xusb_req *req = udc->req;\r\nstruct xusb_ep *target_ep;\r\nu16 status = 0;\r\nu32 epcfgreg;\r\nint epnum;\r\nu32 halt;\r\nint ret;\r\nswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nstatus = 1 << USB_DEVICE_SELF_POWERED;\r\nif (udc->remote_wkp)\r\nstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\r\ntarget_ep = &udc->ep[epnum];\r\nepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\r\nhalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\r\nif (udc->setup.wIndex & USB_DIR_IN) {\r\nif (!target_ep->is_in)\r\ngoto stall;\r\n} else {\r\nif (target_ep->is_in)\r\ngoto stall;\r\n}\r\nif (halt)\r\nstatus = 1 << USB_ENDPOINT_HALT;\r\nbreak;\r\ndefault:\r\ngoto stall;\r\n}\r\nreq->usb_req.length = 2;\r\n*(u16 *)req->usb_req.buf = cpu_to_le16(status);\r\nret = __xudc_ep0_queue(ep0, req);\r\nif (ret == 0)\r\nreturn;\r\nstall:\r\ndev_err(udc->dev, "Can't respond to getstatus request\n");\r\nxudc_ep0_stall(udc);\r\n}\r\nstatic void xudc_set_clear_feature(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct xusb_req *req = udc->req;\r\nstruct xusb_ep *target_ep;\r\nu8 endpoint;\r\nu8 outinbit;\r\nu32 epcfgreg;\r\nint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\r\nint ret;\r\nswitch (udc->setup.bRequestType) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (udc->setup.wValue) {\r\ncase USB_DEVICE_TEST_MODE:\r\nbreak;\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nif (flag)\r\nudc->remote_wkp = 1;\r\nelse\r\nudc->remote_wkp = 0;\r\nbreak;\r\ndefault:\r\nxudc_ep0_stall(udc);\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (!udc->setup.wValue) {\r\nendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\r\ntarget_ep = &udc->ep[endpoint];\r\noutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\r\noutinbit = outinbit >> 7;\r\nif (outinbit != target_ep->is_in) {\r\nxudc_ep0_stall(udc);\r\nreturn;\r\n}\r\nepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\r\nif (!endpoint) {\r\nepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr,\r\ntarget_ep->offset, epcfgreg);\r\n} else {\r\nif (flag) {\r\nepcfgreg |= XUSB_EP_CFG_STALL_MASK;\r\nudc->write_fn(udc->addr,\r\ntarget_ep->offset,\r\nepcfgreg);\r\n} else {\r\nepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\r\nXUSB_EP_CFG_DATA_TOGGLE_MASK);\r\nudc->write_fn(udc->addr,\r\ntarget_ep->offset,\r\nepcfgreg);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nxudc_ep0_stall(udc);\r\nreturn;\r\n}\r\nreq->usb_req.length = 0;\r\nret = __xudc_ep0_queue(ep0, req);\r\nif (ret == 0)\r\nreturn;\r\ndev_err(udc->dev, "Can't respond to SET/CLEAR FEATURE\n");\r\nxudc_ep0_stall(udc);\r\n}\r\nstatic void xudc_handle_setup(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct usb_ctrlrequest setup;\r\nu32 *ep0rambase;\r\nep0rambase = (u32 __force *) (udc->addr + XUSB_SETUP_PKT_ADDR_OFFSET);\r\nmemcpy(&setup, ep0rambase, 8);\r\nudc->setup = setup;\r\nudc->setup.wValue = cpu_to_le16(setup.wValue);\r\nudc->setup.wIndex = cpu_to_le16(setup.wIndex);\r\nudc->setup.wLength = cpu_to_le16(setup.wLength);\r\nxudc_nuke(ep0, -ECONNRESET);\r\nif (udc->setup.bRequestType & USB_DIR_IN) {\r\nudc->setupseqrx = STATUS_PHASE;\r\nudc->setupseqtx = DATA_PHASE;\r\n} else {\r\nudc->setupseqrx = DATA_PHASE;\r\nudc->setupseqtx = STATUS_PHASE;\r\n}\r\nswitch (udc->setup.bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nif ((udc->setup.bRequestType &\r\n(USB_DIR_IN | USB_TYPE_MASK)) !=\r\n(USB_DIR_IN | USB_TYPE_STANDARD))\r\nbreak;\r\nxudc_getstatus(udc);\r\nreturn;\r\ncase USB_REQ_SET_ADDRESS:\r\nif (udc->setup.bRequestType != (USB_DIR_OUT |\r\nUSB_TYPE_STANDARD | USB_RECIP_DEVICE))\r\nbreak;\r\nxudc_setaddress(udc);\r\nreturn;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nif ((udc->setup.bRequestType & USB_TYPE_MASK)\r\n!= USB_TYPE_STANDARD)\r\nbreak;\r\nxudc_set_clear_feature(udc);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock(&udc->lock);\r\nif (udc->driver->setup(&udc->gadget, &setup) < 0)\r\nxudc_ep0_stall(udc);\r\nspin_lock(&udc->lock);\r\n}\r\nstatic void xudc_ep0_out(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct xusb_req *req;\r\nu8 *ep0rambase;\r\nunsigned int bytes_to_rx;\r\nvoid *buffer;\r\nreq = list_first_entry(&ep0->queue, struct xusb_req, queue);\r\nswitch (udc->setupseqrx) {\r\ncase STATUS_PHASE:\r\nudc->setupseqrx = SETUP_PHASE;\r\nudc->setupseqtx = SETUP_PHASE;\r\nreq->usb_req.actual = req->usb_req.length;\r\nxudc_done(ep0, req, 0);\r\nbreak;\r\ncase DATA_PHASE:\r\nbytes_to_rx = udc->read_fn(udc->addr +\r\nXUSB_EP_BUF0COUNT_OFFSET);\r\nep0rambase = (u8 __force *) (udc->addr +\r\n(ep0->rambase << 2));\r\nbuffer = req->usb_req.buf + req->usb_req.actual;\r\nreq->usb_req.actual = req->usb_req.actual + bytes_to_rx;\r\nmemcpy(buffer, ep0rambase, bytes_to_rx);\r\nif (req->usb_req.length == req->usb_req.actual) {\r\nxudc_wrstatus(udc);\r\n} else {\r\nudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void xudc_ep0_in(struct xusb_udc *udc)\r\n{\r\nstruct xusb_ep *ep0 = &udc->ep[0];\r\nstruct xusb_req *req;\r\nunsigned int bytes_to_tx;\r\nvoid *buffer;\r\nu32 epcfgreg;\r\nu16 count = 0;\r\nu16 length;\r\nu8 *ep0rambase;\r\nu8 test_mode = udc->setup.wIndex >> 8;\r\nreq = list_first_entry(&ep0->queue, struct xusb_req, queue);\r\nbytes_to_tx = req->usb_req.length - req->usb_req.actual;\r\nswitch (udc->setupseqtx) {\r\ncase STATUS_PHASE:\r\nswitch (udc->setup.bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET,\r\nudc->setup.wValue);\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nif (udc->setup.bRequestType ==\r\nUSB_RECIP_DEVICE) {\r\nif (udc->setup.wValue ==\r\nUSB_DEVICE_TEST_MODE)\r\nudc->write_fn(udc->addr,\r\nXUSB_TESTMODE_OFFSET,\r\ntest_mode);\r\n}\r\nbreak;\r\n}\r\nreq->usb_req.actual = req->usb_req.length;\r\nxudc_done(ep0, req, 0);\r\nbreak;\r\ncase DATA_PHASE:\r\nif (!bytes_to_tx) {\r\nepcfgreg = udc->read_fn(udc->addr + ep0->offset);\r\nepcfgreg |= XUSB_EP_CFG_DATA_TOGGLE_MASK;\r\nudc->write_fn(udc->addr, ep0->offset, epcfgreg);\r\nudc->setupseqtx = STATUS_PHASE;\r\n} else {\r\nlength = count = min_t(u32, bytes_to_tx,\r\nEP0_MAX_PACKET);\r\nep0rambase = (u8 __force *) (udc->addr +\r\n(ep0->rambase << 2));\r\nbuffer = req->usb_req.buf + req->usb_req.actual;\r\nreq->usb_req.actual = req->usb_req.actual + length;\r\nmemcpy(ep0rambase, buffer, length);\r\n}\r\nudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, count);\r\nudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void xudc_ctrl_ep_handler(struct xusb_udc *udc, u32 intrstatus)\r\n{\r\nif (intrstatus & XUSB_STATUS_SETUP_PACKET_MASK) {\r\nxudc_handle_setup(udc);\r\n} else {\r\nif (intrstatus & XUSB_STATUS_FIFO_BUFF_RDY_MASK)\r\nxudc_ep0_out(udc);\r\nelse if (intrstatus & XUSB_STATUS_FIFO_BUFF_FREE_MASK)\r\nxudc_ep0_in(udc);\r\n}\r\n}\r\nstatic void xudc_nonctrl_ep_handler(struct xusb_udc *udc, u8 epnum,\r\nu32 intrstatus)\r\n{\r\nstruct xusb_req *req;\r\nstruct xusb_ep *ep;\r\nep = &udc->ep[epnum];\r\nif (intrstatus & (XUSB_STATUS_EP0_BUFF1_COMP_MASK << epnum))\r\nep->buffer0ready = 0;\r\nif (intrstatus & (XUSB_STATUS_EP0_BUFF2_COMP_MASK << epnum))\r\nep->buffer1ready = 0;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nreq = list_first_entry(&ep->queue, struct xusb_req, queue);\r\nif (ep->is_in)\r\nxudc_write_fifo(ep, req);\r\nelse\r\nxudc_read_fifo(ep, req);\r\n}\r\nstatic irqreturn_t xudc_irq(int irq, void *_udc)\r\n{\r\nstruct xusb_udc *udc = _udc;\r\nu32 intrstatus;\r\nu32 ier;\r\nu8 index;\r\nu32 bufintr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nier &= ~XUSB_STATUS_INTR_EVENT_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\r\nintrstatus = udc->read_fn(udc->addr + XUSB_STATUS_OFFSET);\r\nif (intrstatus & XUSB_STATUS_INTR_EVENT_MASK) {\r\nxudc_startup_handler(udc, intrstatus);\r\n}\r\nif (intrstatus & XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK) {\r\nier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\r\nier |= XUSB_STATUS_INTR_EVENT_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\r\nif (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK)\r\nxudc_ctrl_ep_handler(udc, intrstatus);\r\nfor (index = 1; index < 8; index++) {\r\nbufintr = ((intrstatus &\r\n(XUSB_STATUS_EP1_BUFF1_COMP_MASK <<\r\n(index - 1))) || (intrstatus &\r\n(XUSB_STATUS_EP1_BUFF2_COMP_MASK <<\r\n(index - 1))));\r\nif (bufintr) {\r\nxudc_nonctrl_ep_handler(udc, index,\r\nintrstatus);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xudc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nstruct xusb_udc *udc;\r\nint irq;\r\nint ret;\r\nu32 ier;\r\nu8 *buff;\r\nudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\nreturn -ENOMEM;\r\nudc->req = devm_kzalloc(&pdev->dev, sizeof(struct xusb_req),\r\nGFP_KERNEL);\r\nif (!udc->req)\r\nreturn -ENOMEM;\r\nbuff = devm_kzalloc(&pdev->dev, STATUSBUFF_SIZE, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nudc->req->usb_req.buf = buff;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nudc->addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(udc->addr))\r\nreturn PTR_ERR(udc->addr);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "unable to get irq\n");\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, xudc_irq, 0,\r\ndev_name(&pdev->dev), udc);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "unable to request irq %d", irq);\r\ngoto fail;\r\n}\r\nudc->dma_enabled = of_property_read_bool(np, "xlnx,has-builtin-dma");\r\nudc->gadget.ops = &xusb_udc_ops;\r\nudc->gadget.max_speed = USB_SPEED_HIGH;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO].ep_usb;\r\nudc->gadget.name = driver_name;\r\nspin_lock_init(&udc->lock);\r\nudc->write_fn = xudc_write32_be;\r\nudc->read_fn = xudc_read32_be;\r\nudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, TEST_J);\r\nif ((udc->read_fn(udc->addr + XUSB_TESTMODE_OFFSET))\r\n!= TEST_J) {\r\nudc->write_fn = xudc_write32;\r\nudc->read_fn = xudc_read32;\r\n}\r\nudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\r\nxudc_eps_init(udc);\r\nudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\r\nret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\r\nif (ret)\r\ngoto fail;\r\nudc->dev = &udc->gadget.dev;\r\nier = XUSB_STATUS_GLOBAL_INTR_MASK | XUSB_STATUS_INTR_EVENT_MASK |\r\nXUSB_STATUS_FIFO_BUFF_RDY_MASK | XUSB_STATUS_FIFO_BUFF_FREE_MASK |\r\nXUSB_STATUS_SETUP_PACKET_MASK |\r\nXUSB_STATUS_INTR_BUFF_COMP_ALL_MASK;\r\nudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\r\nplatform_set_drvdata(pdev, udc);\r\ndev_vdbg(&pdev->dev, "%s at 0x%08X mapped to %p %s\n",\r\ndriver_name, (u32)res->start, udc->addr,\r\nudc->dma_enabled ? "with DMA" : "without DMA");\r\nreturn 0;\r\nfail:\r\ndev_err(&pdev->dev, "probe failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int xudc_remove(struct platform_device *pdev)\r\n{\r\nstruct xusb_udc *udc = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&udc->gadget);\r\nreturn 0;\r\n}
