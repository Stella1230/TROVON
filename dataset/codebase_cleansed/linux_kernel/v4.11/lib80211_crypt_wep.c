static void *lib80211_wep_init(int keyidx)\r\n{\r\nstruct lib80211_wep_data *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\r\nif (priv == NULL)\r\ngoto fail;\r\npriv->key_idx = keyidx;\r\npriv->tx_tfm = crypto_alloc_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->tx_tfm)) {\r\npriv->tx_tfm = NULL;\r\ngoto fail;\r\n}\r\npriv->rx_tfm = crypto_alloc_skcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(priv->rx_tfm)) {\r\npriv->rx_tfm = NULL;\r\ngoto fail;\r\n}\r\nget_random_bytes(&priv->iv, 4);\r\nreturn priv;\r\nfail:\r\nif (priv) {\r\ncrypto_free_skcipher(priv->tx_tfm);\r\ncrypto_free_skcipher(priv->rx_tfm);\r\nkfree(priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void lib80211_wep_deinit(void *priv)\r\n{\r\nstruct lib80211_wep_data *_priv = priv;\r\nif (_priv) {\r\ncrypto_free_skcipher(_priv->tx_tfm);\r\ncrypto_free_skcipher(_priv->rx_tfm);\r\n}\r\nkfree(priv);\r\n}\r\nstatic int lib80211_wep_build_iv(struct sk_buff *skb, int hdr_len,\r\nu8 *key, int keylen, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nu32 klen;\r\nu8 *pos;\r\nif (skb_headroom(skb) < 4 || skb->len < hdr_len)\r\nreturn -1;\r\npos = skb_push(skb, 4);\r\nmemmove(pos, pos + 4, hdr_len);\r\npos += hdr_len;\r\nklen = 3 + wep->key_len;\r\nwep->iv++;\r\nif ((wep->iv & 0xff00) == 0xff00) {\r\nu8 B = (wep->iv >> 16) & 0xff;\r\nif (B >= 3 && B < klen)\r\nwep->iv += 0x0100;\r\n}\r\n*pos++ = (wep->iv >> 16) & 0xff;\r\n*pos++ = (wep->iv >> 8) & 0xff;\r\n*pos++ = wep->iv & 0xff;\r\n*pos++ = wep->key_idx << 6;\r\nreturn 0;\r\n}\r\nstatic int lib80211_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nSKCIPHER_REQUEST_ON_STACK(req, wep->tx_tfm);\r\nu32 crc, klen, len;\r\nu8 *pos, *icv;\r\nstruct scatterlist sg;\r\nu8 key[WEP_KEY_LEN + 3];\r\nint err;\r\nif (skb_tailroom(skb) < 4)\r\nreturn -1;\r\nif (lib80211_wep_build_iv(skb, hdr_len, NULL, 0, priv))\r\nreturn -1;\r\nskb_copy_from_linear_data_offset(skb, hdr_len, key, 3);\r\nmemcpy(key + 3, wep->key, wep->key_len);\r\nlen = skb->len - hdr_len - 4;\r\npos = skb->data + hdr_len + 4;\r\nklen = 3 + wep->key_len;\r\ncrc = ~crc32_le(~0, pos, len);\r\nicv = skb_put(skb, 4);\r\nicv[0] = crc;\r\nicv[1] = crc >> 8;\r\nicv[2] = crc >> 16;\r\nicv[3] = crc >> 24;\r\ncrypto_skcipher_setkey(wep->tx_tfm, key, klen);\r\nsg_init_one(&sg, pos, len + 4);\r\nskcipher_request_set_tfm(req, wep->tx_tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, len + 4, NULL);\r\nerr = crypto_skcipher_encrypt(req);\r\nskcipher_request_zero(req);\r\nreturn err;\r\n}\r\nstatic int lib80211_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nSKCIPHER_REQUEST_ON_STACK(req, wep->rx_tfm);\r\nu32 crc, klen, plen;\r\nu8 key[WEP_KEY_LEN + 3];\r\nu8 keyidx, *pos, icv[4];\r\nstruct scatterlist sg;\r\nint err;\r\nif (skb->len < hdr_len + 8)\r\nreturn -1;\r\npos = skb->data + hdr_len;\r\nkey[0] = *pos++;\r\nkey[1] = *pos++;\r\nkey[2] = *pos++;\r\nkeyidx = *pos++ >> 6;\r\nif (keyidx != wep->key_idx)\r\nreturn -1;\r\nklen = 3 + wep->key_len;\r\nmemcpy(key + 3, wep->key, wep->key_len);\r\nplen = skb->len - hdr_len - 8;\r\ncrypto_skcipher_setkey(wep->rx_tfm, key, klen);\r\nsg_init_one(&sg, pos, plen + 4);\r\nskcipher_request_set_tfm(req, wep->rx_tfm);\r\nskcipher_request_set_callback(req, 0, NULL, NULL);\r\nskcipher_request_set_crypt(req, &sg, &sg, plen + 4, NULL);\r\nerr = crypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nif (err)\r\nreturn -7;\r\ncrc = ~crc32_le(~0, pos, plen);\r\nicv[0] = crc;\r\nicv[1] = crc >> 8;\r\nicv[2] = crc >> 16;\r\nicv[3] = crc >> 24;\r\nif (memcmp(icv, pos + plen, 4) != 0) {\r\nreturn -2;\r\n}\r\nmemmove(skb->data + 4, skb->data, hdr_len);\r\nskb_pull(skb, 4);\r\nskb_trim(skb, skb->len - 4);\r\nreturn 0;\r\n}\r\nstatic int lib80211_wep_set_key(void *key, int len, u8 * seq, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nif (len < 0 || len > WEP_KEY_LEN)\r\nreturn -1;\r\nmemcpy(wep->key, key, len);\r\nwep->key_len = len;\r\nreturn 0;\r\n}\r\nstatic int lib80211_wep_get_key(void *key, int len, u8 * seq, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nif (len < wep->key_len)\r\nreturn -1;\r\nmemcpy(key, wep->key, wep->key_len);\r\nreturn wep->key_len;\r\n}\r\nstatic void lib80211_wep_print_stats(struct seq_file *m, void *priv)\r\n{\r\nstruct lib80211_wep_data *wep = priv;\r\nseq_printf(m, "key[%d] alg=WEP len=%d\n", wep->key_idx, wep->key_len);\r\n}\r\nstatic int __init lib80211_crypto_wep_init(void)\r\n{\r\nreturn lib80211_register_crypto_ops(&lib80211_crypt_wep);\r\n}\r\nstatic void __exit lib80211_crypto_wep_exit(void)\r\n{\r\nlib80211_unregister_crypto_ops(&lib80211_crypt_wep);\r\n}
