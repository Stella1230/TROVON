static u8 ip6_frag_ecn(const struct ipv6hdr *ipv6h)\r\n{\r\nreturn 1 << (ipv6_get_dsfield(ipv6h) & INET_ECN_MASK);\r\n}\r\nstatic unsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nnet_get_random_once(&ip6_frags.rnd, sizeof(ip6_frags.rnd));\r\nreturn jhash_3words(ipv6_addr_hash(saddr), ipv6_addr_hash(daddr),\r\n(__force u32)id, ip6_frags.rnd);\r\n}\r\nstatic unsigned int ip6_hashfn(const struct inet_frag_queue *q)\r\n{\r\nconst struct frag_queue *fq;\r\nfq = container_of(q, struct frag_queue, q);\r\nreturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr);\r\n}\r\nbool ip6_frag_match(const struct inet_frag_queue *q, const void *a)\r\n{\r\nconst struct frag_queue *fq;\r\nconst struct ip6_create_arg *arg = a;\r\nfq = container_of(q, struct frag_queue, q);\r\nreturn fq->id == arg->id &&\r\nfq->user == arg->user &&\r\nipv6_addr_equal(&fq->saddr, arg->src) &&\r\nipv6_addr_equal(&fq->daddr, arg->dst) &&\r\n(arg->iif == fq->iif ||\r\n!(ipv6_addr_type(arg->dst) & (IPV6_ADDR_MULTICAST |\r\nIPV6_ADDR_LINKLOCAL)));\r\n}\r\nvoid ip6_frag_init(struct inet_frag_queue *q, const void *a)\r\n{\r\nstruct frag_queue *fq = container_of(q, struct frag_queue, q);\r\nconst struct ip6_create_arg *arg = a;\r\nfq->id = arg->id;\r\nfq->user = arg->user;\r\nfq->saddr = *arg->src;\r\nfq->daddr = *arg->dst;\r\nfq->ecn = arg->ecn;\r\n}\r\nvoid ip6_expire_frag_queue(struct net *net, struct frag_queue *fq,\r\nstruct inet_frags *frags)\r\n{\r\nstruct net_device *dev = NULL;\r\nspin_lock(&fq->q.lock);\r\nif (fq->q.flags & INET_FRAG_COMPLETE)\r\ngoto out;\r\ninet_frag_kill(&fq->q, frags);\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(net, fq->iif);\r\nif (!dev)\r\ngoto out_rcu_unlock;\r\n__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\r\nif (inet_frag_evicting(&fq->q))\r\ngoto out_rcu_unlock;\r\n__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);\r\nif (!(fq->q.flags & INET_FRAG_FIRST_IN) || !fq->q.fragments)\r\ngoto out_rcu_unlock;\r\nfq->q.fragments->dev = dev;\r\nicmpv6_send(fq->q.fragments, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);\r\nout_rcu_unlock:\r\nrcu_read_unlock();\r\nout:\r\nspin_unlock(&fq->q.lock);\r\ninet_frag_put(&fq->q, frags);\r\n}\r\nstatic void ip6_frag_expire(unsigned long data)\r\n{\r\nstruct frag_queue *fq;\r\nstruct net *net;\r\nfq = container_of((struct inet_frag_queue *)data, struct frag_queue, q);\r\nnet = container_of(fq->q.net, struct net, ipv6.frags);\r\nip6_expire_frag_queue(net, fq, &ip6_frags);\r\n}\r\nstatic struct frag_queue *\r\nfq_find(struct net *net, __be32 id, const struct in6_addr *src,\r\nconst struct in6_addr *dst, int iif, u8 ecn)\r\n{\r\nstruct inet_frag_queue *q;\r\nstruct ip6_create_arg arg;\r\nunsigned int hash;\r\narg.id = id;\r\narg.user = IP6_DEFRAG_LOCAL_DELIVER;\r\narg.src = src;\r\narg.dst = dst;\r\narg.iif = iif;\r\narg.ecn = ecn;\r\nhash = inet6_hash_frag(id, src, dst);\r\nq = inet_frag_find(&net->ipv6.frags, &ip6_frags, &arg, hash);\r\nif (IS_ERR_OR_NULL(q)) {\r\ninet_frag_maybe_warn_overflow(q, pr_fmt());\r\nreturn NULL;\r\n}\r\nreturn container_of(q, struct frag_queue, q);\r\n}\r\nstatic int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\r\nstruct frag_hdr *fhdr, int nhoff)\r\n{\r\nstruct sk_buff *prev, *next;\r\nstruct net_device *dev;\r\nint offset, end, fragsize;\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nu8 ecn;\r\nif (fq->q.flags & INET_FRAG_COMPLETE)\r\ngoto err;\r\noffset = ntohs(fhdr->frag_off) & ~0x7;\r\nend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\r\n((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\r\nif ((unsigned int)end > IPV6_MAXPLEN) {\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\n((u8 *)&fhdr->frag_off -\r\nskb_network_header(skb)));\r\nreturn -1;\r\n}\r\necn = ip6_frag_ecn(ipv6_hdr(skb));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nskb->csum = csum_sub(skb->csum,\r\ncsum_partial(nh, (u8 *)(fhdr + 1) - nh,\r\n0));\r\n}\r\nif (!(fhdr->frag_off & htons(IP6_MF))) {\r\nif (end < fq->q.len ||\r\n((fq->q.flags & INET_FRAG_LAST_IN) && end != fq->q.len))\r\ngoto err;\r\nfq->q.flags |= INET_FRAG_LAST_IN;\r\nfq->q.len = end;\r\n} else {\r\nif (end & 0x7) {\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\r\noffsetof(struct ipv6hdr, payload_len));\r\nreturn -1;\r\n}\r\nif (end > fq->q.len) {\r\nif (fq->q.flags & INET_FRAG_LAST_IN)\r\ngoto err;\r\nfq->q.len = end;\r\n}\r\n}\r\nif (end == offset)\r\ngoto err;\r\nif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\r\ngoto err;\r\nif (pskb_trim_rcsum(skb, end - offset))\r\ngoto err;\r\nprev = fq->q.fragments_tail;\r\nif (!prev || FRAG6_CB(prev)->offset < offset) {\r\nnext = NULL;\r\ngoto found;\r\n}\r\nprev = NULL;\r\nfor (next = fq->q.fragments; next != NULL; next = next->next) {\r\nif (FRAG6_CB(next)->offset >= offset)\r\nbreak;\r\nprev = next;\r\n}\r\nfound:\r\nif (prev &&\r\n(FRAG6_CB(prev)->offset + prev->len) > offset)\r\ngoto discard_fq;\r\nif (next && FRAG6_CB(next)->offset < end)\r\ngoto discard_fq;\r\nFRAG6_CB(skb)->offset = offset;\r\nskb->next = next;\r\nif (!next)\r\nfq->q.fragments_tail = skb;\r\nif (prev)\r\nprev->next = skb;\r\nelse\r\nfq->q.fragments = skb;\r\ndev = skb->dev;\r\nif (dev) {\r\nfq->iif = dev->ifindex;\r\nskb->dev = NULL;\r\n}\r\nfq->q.stamp = skb->tstamp;\r\nfq->q.meat += skb->len;\r\nfq->ecn |= ecn;\r\nadd_frag_mem_limit(fq->q.net, skb->truesize);\r\nfragsize = -skb_network_offset(skb) + skb->len;\r\nif (fragsize > fq->q.max_size)\r\nfq->q.max_size = fragsize;\r\nif (offset == 0) {\r\nfq->nhoffset = nhoff;\r\nfq->q.flags |= INET_FRAG_FIRST_IN;\r\n}\r\nif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\r\nfq->q.meat == fq->q.len) {\r\nint res;\r\nunsigned long orefdst = skb->_skb_refdst;\r\nskb->_skb_refdst = 0UL;\r\nres = ip6_frag_reasm(fq, prev, dev);\r\nskb->_skb_refdst = orefdst;\r\nreturn res;\r\n}\r\nskb_dst_drop(skb);\r\nreturn -1;\r\ndiscard_fq:\r\ninet_frag_kill(&fq->q, &ip6_frags);\r\nerr:\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_REASMFAILS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\r\nstruct net_device *dev)\r\n{\r\nstruct net *net = container_of(fq->q.net, struct net, ipv6.frags);\r\nstruct sk_buff *fp, *head = fq->q.fragments;\r\nint payload_len;\r\nunsigned int nhoff;\r\nint sum_truesize;\r\nu8 ecn;\r\ninet_frag_kill(&fq->q, &ip6_frags);\r\necn = ip_frag_ecn_table[fq->ecn];\r\nif (unlikely(ecn == 0xff))\r\ngoto out_fail;\r\nif (prev) {\r\nhead = prev->next;\r\nfp = skb_clone(head, GFP_ATOMIC);\r\nif (!fp)\r\ngoto out_oom;\r\nfp->next = head->next;\r\nif (!fp->next)\r\nfq->q.fragments_tail = fp;\r\nprev->next = fp;\r\nskb_morph(head, fq->q.fragments);\r\nhead->next = fq->q.fragments->next;\r\nconsume_skb(fq->q.fragments);\r\nfq->q.fragments = head;\r\n}\r\nWARN_ON(head == NULL);\r\nWARN_ON(FRAG6_CB(head)->offset != 0);\r\npayload_len = ((head->data - skb_network_header(head)) -\r\nsizeof(struct ipv6hdr) + fq->q.len -\r\nsizeof(struct frag_hdr));\r\nif (payload_len > IPV6_MAXPLEN)\r\ngoto out_oversize;\r\nif (skb_unclone(head, GFP_ATOMIC))\r\ngoto out_oom;\r\nif (skb_has_frag_list(head)) {\r\nstruct sk_buff *clone;\r\nint i, plen = 0;\r\nclone = alloc_skb(0, GFP_ATOMIC);\r\nif (!clone)\r\ngoto out_oom;\r\nclone->next = head->next;\r\nhead->next = clone;\r\nskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\r\nskb_frag_list_init(head);\r\nfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\r\nplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\r\nclone->len = clone->data_len = head->data_len - plen;\r\nhead->data_len -= clone->len;\r\nhead->len -= clone->len;\r\nclone->csum = 0;\r\nclone->ip_summed = head->ip_summed;\r\nadd_frag_mem_limit(fq->q.net, clone->truesize);\r\n}\r\nnhoff = fq->nhoffset;\r\nskb_network_header(head)[nhoff] = skb_transport_header(head)[0];\r\nmemmove(head->head + sizeof(struct frag_hdr), head->head,\r\n(head->data - head->head) - sizeof(struct frag_hdr));\r\nif (skb_mac_header_was_set(head))\r\nhead->mac_header += sizeof(struct frag_hdr);\r\nhead->network_header += sizeof(struct frag_hdr);\r\nskb_reset_transport_header(head);\r\nskb_push(head, head->data - skb_network_header(head));\r\nsum_truesize = head->truesize;\r\nfor (fp = head->next; fp;) {\r\nbool headstolen;\r\nint delta;\r\nstruct sk_buff *next = fp->next;\r\nsum_truesize += fp->truesize;\r\nif (head->ip_summed != fp->ip_summed)\r\nhead->ip_summed = CHECKSUM_NONE;\r\nelse if (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_add(head->csum, fp->csum);\r\nif (skb_try_coalesce(head, fp, &headstolen, &delta)) {\r\nkfree_skb_partial(fp, headstolen);\r\n} else {\r\nif (!skb_shinfo(head)->frag_list)\r\nskb_shinfo(head)->frag_list = fp;\r\nhead->data_len += fp->len;\r\nhead->len += fp->len;\r\nhead->truesize += fp->truesize;\r\n}\r\nfp = next;\r\n}\r\nsub_frag_mem_limit(fq->q.net, sum_truesize);\r\nhead->next = NULL;\r\nhead->dev = dev;\r\nhead->tstamp = fq->q.stamp;\r\nipv6_hdr(head)->payload_len = htons(payload_len);\r\nipv6_change_dsfield(ipv6_hdr(head), 0xff, ecn);\r\nIP6CB(head)->nhoff = nhoff;\r\nIP6CB(head)->flags |= IP6SKB_FRAGMENTED;\r\nIP6CB(head)->frag_max_size = fq->q.max_size;\r\nskb_postpush_rcsum(head, skb_network_header(head),\r\nskb_network_header_len(head));\r\nrcu_read_lock();\r\n__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);\r\nrcu_read_unlock();\r\nfq->q.fragments = NULL;\r\nfq->q.fragments_tail = NULL;\r\nreturn 1;\r\nout_oversize:\r\nnet_dbg_ratelimited("ip6_frag_reasm: payload len = %d\n", payload_len);\r\ngoto out_fail;\r\nout_oom:\r\nnet_dbg_ratelimited("ip6_frag_reasm: no memory for reassembly\n");\r\nout_fail:\r\nrcu_read_lock();\r\n__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);\r\nrcu_read_unlock();\r\nreturn -1;\r\n}\r\nstatic int ipv6_frag_rcv(struct sk_buff *skb)\r\n{\r\nstruct frag_hdr *fhdr;\r\nstruct frag_queue *fq;\r\nconst struct ipv6hdr *hdr = ipv6_hdr(skb);\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED)\r\ngoto fail_hdr;\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMREQDS);\r\nif (hdr->payload_len == 0)\r\ngoto fail_hdr;\r\nif (!pskb_may_pull(skb, (skb_transport_offset(skb) +\r\nsizeof(struct frag_hdr))))\r\ngoto fail_hdr;\r\nhdr = ipv6_hdr(skb);\r\nfhdr = (struct frag_hdr *)skb_transport_header(skb);\r\nif (!(fhdr->frag_off & htons(0xFFF9))) {\r\nskb->transport_header += sizeof(struct frag_hdr);\r\n__IP6_INC_STATS(net,\r\nip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMOKS);\r\nIP6CB(skb)->nhoff = (u8 *)fhdr - skb_network_header(skb);\r\nIP6CB(skb)->flags |= IP6SKB_FRAGMENTED;\r\nreturn 1;\r\n}\r\nfq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr,\r\nskb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\r\nif (fq) {\r\nint ret;\r\nspin_lock(&fq->q.lock);\r\nret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)->nhoff);\r\nspin_unlock(&fq->q.lock);\r\ninet_frag_put(&fq->q, &ip6_frags);\r\nreturn ret;\r\n}\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMFAILS);\r\nkfree_skb(skb);\r\nreturn -1;\r\nfail_hdr:\r\n__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\r\nIPSTATS_MIB_INHDRERRORS);\r\nicmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));\r\nreturn -1;\r\n}\r\nstatic int __net_init ip6_frags_ns_sysctl_register(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_table_header *hdr;\r\ntable = ip6_frags_ns_ctl_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(table, sizeof(ip6_frags_ns_ctl_table), GFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\ntable[0].data = &net->ipv6.frags.high_thresh;\r\ntable[0].extra1 = &net->ipv6.frags.low_thresh;\r\ntable[0].extra2 = &init_net.ipv6.frags.high_thresh;\r\ntable[1].data = &net->ipv6.frags.low_thresh;\r\ntable[1].extra2 = &net->ipv6.frags.high_thresh;\r\ntable[2].data = &net->ipv6.frags.timeout;\r\nif (net->user_ns != &init_user_ns)\r\ntable[0].procname = NULL;\r\n}\r\nhdr = register_net_sysctl(net, "net/ipv6", table);\r\nif (!hdr)\r\ngoto err_reg;\r\nnet->ipv6.sysctl.frags_hdr = hdr;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit ip6_frags_ns_sysctl_unregister(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->ipv6.sysctl.frags_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->ipv6.sysctl.frags_hdr);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int ip6_frags_sysctl_register(void)\r\n{\r\nip6_ctl_header = register_net_sysctl(&init_net, "net/ipv6",\r\nip6_frags_ctl_table);\r\nreturn ip6_ctl_header == NULL ? -ENOMEM : 0;\r\n}\r\nstatic void ip6_frags_sysctl_unregister(void)\r\n{\r\nunregister_net_sysctl_table(ip6_ctl_header);\r\n}\r\nstatic int ip6_frags_ns_sysctl_register(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ip6_frags_ns_sysctl_unregister(struct net *net)\r\n{\r\n}\r\nstatic int ip6_frags_sysctl_register(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ip6_frags_sysctl_unregister(void)\r\n{\r\n}\r\nstatic int __net_init ipv6_frags_init_net(struct net *net)\r\n{\r\nint res;\r\nnet->ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\r\nnet->ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\r\nnet->ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;\r\nres = inet_frags_init_net(&net->ipv6.frags);\r\nif (res)\r\nreturn res;\r\nres = ip6_frags_ns_sysctl_register(net);\r\nif (res)\r\ninet_frags_uninit_net(&net->ipv6.frags);\r\nreturn res;\r\n}\r\nstatic void __net_exit ipv6_frags_exit_net(struct net *net)\r\n{\r\nip6_frags_ns_sysctl_unregister(net);\r\ninet_frags_exit_net(&net->ipv6.frags, &ip6_frags);\r\n}\r\nint __init ipv6_frag_init(void)\r\n{\r\nint ret;\r\nret = inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\nif (ret)\r\ngoto out;\r\nret = ip6_frags_sysctl_register();\r\nif (ret)\r\ngoto err_sysctl;\r\nret = register_pernet_subsys(&ip6_frags_ops);\r\nif (ret)\r\ngoto err_pernet;\r\nip6_frags.hashfn = ip6_hashfn;\r\nip6_frags.constructor = ip6_frag_init;\r\nip6_frags.destructor = NULL;\r\nip6_frags.qsize = sizeof(struct frag_queue);\r\nip6_frags.match = ip6_frag_match;\r\nip6_frags.frag_expire = ip6_frag_expire;\r\nip6_frags.frags_cache_name = ip6_frag_cache_name;\r\nret = inet_frags_init(&ip6_frags);\r\nif (ret)\r\ngoto err_pernet;\r\nout:\r\nreturn ret;\r\nerr_pernet:\r\nip6_frags_sysctl_unregister();\r\nerr_sysctl:\r\ninet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\ngoto out;\r\n}\r\nvoid ipv6_frag_exit(void)\r\n{\r\ninet_frags_fini(&ip6_frags);\r\nip6_frags_sysctl_unregister();\r\nunregister_pernet_subsys(&ip6_frags_ops);\r\ninet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\r\n}
