static inline u32\r\nmfsdram(const dcr_host_t *dcr_host, unsigned int idcr_n)\r\n{\r\nreturn __mfdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,\r\ndcr_host->base + SDRAM_DCR_DATA_OFFSET,\r\nidcr_n);\r\n}\r\nstatic inline void\r\nmtsdram(const dcr_host_t *dcr_host, unsigned int idcr_n, u32 value)\r\n{\r\nreturn __mtdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,\r\ndcr_host->base + SDRAM_DCR_DATA_OFFSET,\r\nidcr_n,\r\nvalue);\r\n}\r\nstatic bool\r\nppc4xx_edac_check_bank_error(const struct ppc4xx_ecc_status *status,\r\nunsigned int bank)\r\n{\r\nswitch (bank) {\r\ncase 0:\r\nreturn status->ecces & SDRAM_ECCES_BK0ER;\r\ncase 1:\r\nreturn status->ecces & SDRAM_ECCES_BK1ER;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int\r\nppc4xx_edac_generate_bank_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nint n, total = 0;\r\nunsigned int row, rows;\r\nn = snprintf(buffer, size, "%s: Banks: ", mci->dev_name);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nfor (rows = 0, row = 0; row < mci->nr_csrows; row++) {\r\nif (ppc4xx_edac_check_bank_error(status, row)) {\r\nn = snprintf(buffer, size, "%s%u",\r\n(rows++ ? ", " : ""), row);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\n}\r\n}\r\nn = snprintf(buffer, size, "%s; ", rows ? "" : "None");\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nfail:\r\nreturn total;\r\n}\r\nstatic int\r\nppc4xx_edac_generate_checkbit_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nconst char *ckber = NULL;\r\nswitch (status->ecces & SDRAM_ECCES_CKBER_MASK) {\r\ncase SDRAM_ECCES_CKBER_NONE:\r\nckber = "None";\r\nbreak;\r\ncase SDRAM_ECCES_CKBER_32_ECC_0_3:\r\nckber = "ECC0:3";\r\nbreak;\r\ncase SDRAM_ECCES_CKBER_32_ECC_4_8:\r\nswitch (mfsdram(&pdata->dcr_host, SDRAM_MCOPT1) &\r\nSDRAM_MCOPT1_WDTH_MASK) {\r\ncase SDRAM_MCOPT1_WDTH_16:\r\nckber = "ECC0:3";\r\nbreak;\r\ncase SDRAM_MCOPT1_WDTH_32:\r\nckber = "ECC4:8";\r\nbreak;\r\ndefault:\r\nckber = "Unknown";\r\nbreak;\r\n}\r\nbreak;\r\ncase SDRAM_ECCES_CKBER_32_ECC_0_8:\r\nckber = "ECC0:8";\r\nbreak;\r\ndefault:\r\nckber = "Unknown";\r\nbreak;\r\n}\r\nreturn snprintf(buffer, size, "Checkbit Error: %s", ckber);\r\n}\r\nstatic int\r\nppc4xx_edac_generate_lane_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nint n, total = 0;\r\nunsigned int lane, lanes;\r\nconst unsigned int first_lane = 0;\r\nconst unsigned int lane_count = 16;\r\nn = snprintf(buffer, size, "; Byte Lane Errors: ");\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nfor (lanes = 0, lane = first_lane; lane < lane_count; lane++) {\r\nif ((status->ecces & SDRAM_ECCES_BNCE_ENCODE(lane)) != 0) {\r\nn = snprintf(buffer, size,\r\n"%s%u",\r\n(lanes++ ? ", " : ""), lane);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\n}\r\n}\r\nn = snprintf(buffer, size, "%s; ", lanes ? "" : "None");\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nfail:\r\nreturn total;\r\n}\r\nstatic int\r\nppc4xx_edac_generate_ecc_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nint n, total = 0;\r\nn = ppc4xx_edac_generate_bank_message(mci, status, buffer, size);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nn = ppc4xx_edac_generate_checkbit_message(mci, status, buffer, size);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nn = ppc4xx_edac_generate_lane_message(mci, status, buffer, size);\r\nif (n < 0 || n >= size)\r\ngoto fail;\r\nbuffer += n;\r\nsize -= n;\r\ntotal += n;\r\nfail:\r\nreturn total;\r\n}\r\nstatic int\r\nppc4xx_edac_generate_plb_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nunsigned int master;\r\nbool read;\r\nif ((status->besr & SDRAM_BESR_MASK) == 0)\r\nreturn 0;\r\nif ((status->besr & SDRAM_BESR_M0ET_MASK) == SDRAM_BESR_M0ET_NONE)\r\nreturn 0;\r\nread = ((status->besr & SDRAM_BESR_M0RW_MASK) == SDRAM_BESR_M0RW_READ);\r\nmaster = SDRAM_BESR_M0ID_DECODE(status->besr);\r\nreturn snprintf(buffer, size,\r\n"%s error w/ PLB master %u \"%s\"; ",\r\n(read ? "Read" : "Write"),\r\nmaster,\r\n(((master >= SDRAM_PLB_M0ID_FIRST) &&\r\n(master <= SDRAM_PLB_M0ID_LAST)) ?\r\nppc4xx_plb_masters[master] : "UNKNOWN"));\r\n}\r\nstatic void\r\nppc4xx_edac_generate_message(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status,\r\nchar *buffer,\r\nsize_t size)\r\n{\r\nint n;\r\nif (buffer == NULL || size == 0)\r\nreturn;\r\nn = ppc4xx_edac_generate_ecc_message(mci, status, buffer, size);\r\nif (n < 0 || n >= size)\r\nreturn;\r\nbuffer += n;\r\nsize -= n;\r\nppc4xx_edac_generate_plb_message(mci, status, buffer, size);\r\n}\r\nstatic void\r\nppc4xx_ecc_dump_status(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status)\r\n{\r\nchar message[PPC4XX_EDAC_MESSAGE_SIZE];\r\nppc4xx_edac_generate_message(mci, status, message, sizeof(message));\r\nppc4xx_edac_mc_printk(KERN_INFO, mci,\r\n"\n"\r\n"\tECCES: 0x%08x\n"\r\n"\tWMIRQ: 0x%08x\n"\r\n"\tBESR: 0x%08x\n"\r\n"\tBEAR: 0x%08x%08x\n"\r\n"\t%s\n",\r\nstatus->ecces,\r\nstatus->wmirq,\r\nstatus->besr,\r\nstatus->bearh,\r\nstatus->bearl,\r\nmessage);\r\n}\r\nstatic void\r\nppc4xx_ecc_get_status(const struct mem_ctl_info *mci,\r\nstruct ppc4xx_ecc_status *status)\r\n{\r\nconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nconst dcr_host_t *dcr_host = &pdata->dcr_host;\r\nstatus->ecces = mfsdram(dcr_host, SDRAM_ECCES) & SDRAM_ECCES_MASK;\r\nstatus->wmirq = mfsdram(dcr_host, SDRAM_WMIRQ) & SDRAM_WMIRQ_MASK;\r\nstatus->besr = mfsdram(dcr_host, SDRAM_BESR) & SDRAM_BESR_MASK;\r\nstatus->bearl = mfsdram(dcr_host, SDRAM_BEARL);\r\nstatus->bearh = mfsdram(dcr_host, SDRAM_BEARH);\r\n}\r\nstatic void\r\nppc4xx_ecc_clear_status(const struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status)\r\n{\r\nconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nconst dcr_host_t *dcr_host = &pdata->dcr_host;\r\nmtsdram(dcr_host, SDRAM_ECCES, status->ecces & SDRAM_ECCES_MASK);\r\nmtsdram(dcr_host, SDRAM_WMIRQ, status->wmirq & SDRAM_WMIRQ_MASK);\r\nmtsdram(dcr_host, SDRAM_BESR, status->besr & SDRAM_BESR_MASK);\r\nmtsdram(dcr_host, SDRAM_BEARL, 0);\r\nmtsdram(dcr_host, SDRAM_BEARH, 0);\r\n}\r\nstatic void\r\nppc4xx_edac_handle_ce(struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status)\r\n{\r\nint row;\r\nchar message[PPC4XX_EDAC_MESSAGE_SIZE];\r\nppc4xx_edac_generate_message(mci, status, message, sizeof(message));\r\nfor (row = 0; row < mci->nr_csrows; row++)\r\nif (ppc4xx_edac_check_bank_error(status, row))\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\n0, 0, 0,\r\nrow, 0, -1,\r\nmessage, "");\r\n}\r\nstatic void\r\nppc4xx_edac_handle_ue(struct mem_ctl_info *mci,\r\nconst struct ppc4xx_ecc_status *status)\r\n{\r\nconst u64 bear = ((u64)status->bearh << 32 | status->bearl);\r\nconst unsigned long page = bear >> PAGE_SHIFT;\r\nconst unsigned long offset = bear & ~PAGE_MASK;\r\nint row;\r\nchar message[PPC4XX_EDAC_MESSAGE_SIZE];\r\nppc4xx_edac_generate_message(mci, status, message, sizeof(message));\r\nfor (row = 0; row < mci->nr_csrows; row++)\r\nif (ppc4xx_edac_check_bank_error(status, row))\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\npage, offset, 0,\r\nrow, 0, -1,\r\nmessage, "");\r\n}\r\nstatic void\r\nppc4xx_edac_check(struct mem_ctl_info *mci)\r\n{\r\n#ifdef DEBUG\r\nstatic unsigned int count;\r\n#endif\r\nstruct ppc4xx_ecc_status status;\r\nppc4xx_ecc_get_status(mci, &status);\r\n#ifdef DEBUG\r\nif (count++ % 30 == 0)\r\nppc4xx_ecc_dump_status(mci, &status);\r\n#endif\r\nif (status.ecces & SDRAM_ECCES_UE)\r\nppc4xx_edac_handle_ue(mci, &status);\r\nif (status.ecces & SDRAM_ECCES_CE)\r\nppc4xx_edac_handle_ce(mci, &status);\r\nppc4xx_ecc_clear_status(mci, &status);\r\n}\r\nstatic irqreturn_t\r\nppc4xx_edac_isr(int irq, void *dev_id)\r\n{\r\nstruct mem_ctl_info *mci = dev_id;\r\nppc4xx_edac_check(mci);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum dev_type ppc4xx_edac_get_dtype(u32 mcopt1)\r\n{\r\nswitch (mcopt1 & SDRAM_MCOPT1_WDTH_MASK) {\r\ncase SDRAM_MCOPT1_WDTH_16:\r\nreturn DEV_X2;\r\ncase SDRAM_MCOPT1_WDTH_32:\r\nreturn DEV_X4;\r\ndefault:\r\nreturn DEV_UNKNOWN;\r\n}\r\n}\r\nstatic enum mem_type ppc4xx_edac_get_mtype(u32 mcopt1)\r\n{\r\nbool rden = ((mcopt1 & SDRAM_MCOPT1_RDEN_MASK) == SDRAM_MCOPT1_RDEN);\r\nswitch (mcopt1 & SDRAM_MCOPT1_DDR_TYPE_MASK) {\r\ncase SDRAM_MCOPT1_DDR2_TYPE:\r\nreturn rden ? MEM_RDDR2 : MEM_DDR2;\r\ncase SDRAM_MCOPT1_DDR1_TYPE:\r\nreturn rden ? MEM_RDDR : MEM_DDR;\r\ndefault:\r\nreturn MEM_UNKNOWN;\r\n}\r\n}\r\nstatic int ppc4xx_edac_init_csrows(struct mem_ctl_info *mci, u32 mcopt1)\r\n{\r\nconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nint status = 0;\r\nenum mem_type mtype;\r\nenum dev_type dtype;\r\nenum edac_type edac_mode;\r\nint row, j;\r\nu32 mbxcf, size, nr_pages;\r\nmtype = ppc4xx_edac_get_mtype(mcopt1);\r\ndtype = ppc4xx_edac_get_dtype(mcopt1);\r\nif (mci->edac_cap & EDAC_FLAG_SECDED)\r\nedac_mode = EDAC_SECDED;\r\nelse if (mci->edac_cap & EDAC_FLAG_EC)\r\nedac_mode = EDAC_EC;\r\nelse\r\nedac_mode = EDAC_NONE;\r\nfor (row = 0; row < mci->nr_csrows; row++) {\r\nstruct csrow_info *csi = mci->csrows[row];\r\nmbxcf = mfsdram(&pdata->dcr_host, SDRAM_MBXCF(row));\r\nif ((mbxcf & SDRAM_MBCF_BE_MASK) != SDRAM_MBCF_BE_ENABLE)\r\ncontinue;\r\nsize = mbxcf & SDRAM_MBCF_SZ_MASK;\r\nswitch (size) {\r\ncase SDRAM_MBCF_SZ_4MB:\r\ncase SDRAM_MBCF_SZ_8MB:\r\ncase SDRAM_MBCF_SZ_16MB:\r\ncase SDRAM_MBCF_SZ_32MB:\r\ncase SDRAM_MBCF_SZ_64MB:\r\ncase SDRAM_MBCF_SZ_128MB:\r\ncase SDRAM_MBCF_SZ_256MB:\r\ncase SDRAM_MBCF_SZ_512MB:\r\ncase SDRAM_MBCF_SZ_1GB:\r\ncase SDRAM_MBCF_SZ_2GB:\r\ncase SDRAM_MBCF_SZ_4GB:\r\ncase SDRAM_MBCF_SZ_8GB:\r\nnr_pages = SDRAM_MBCF_SZ_TO_PAGES(size);\r\nbreak;\r\ndefault:\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Unrecognized memory bank %d "\r\n"size 0x%08x\n",\r\nrow, SDRAM_MBCF_SZ_DECODE(size));\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nfor (j = 0; j < csi->nr_channels; j++) {\r\nstruct dimm_info *dimm = csi->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / csi->nr_channels;\r\ndimm->grain = 1;\r\ndimm->mtype = mtype;\r\ndimm->dtype = dtype;\r\ndimm->edac_mode = edac_mode;\r\n}\r\n}\r\ndone:\r\nreturn status;\r\n}\r\nstatic int ppc4xx_edac_mc_init(struct mem_ctl_info *mci,\r\nstruct platform_device *op,\r\nconst dcr_host_t *dcr_host, u32 mcopt1)\r\n{\r\nint status = 0;\r\nconst u32 memcheck = (mcopt1 & SDRAM_MCOPT1_MCHK_MASK);\r\nstruct ppc4xx_edac_pdata *pdata = NULL;\r\nconst struct device_node *np = op->dev.of_node;\r\nif (of_match_device(ppc4xx_edac_match, &op->dev) == NULL)\r\nreturn -EINVAL;\r\nmci->pdev = &op->dev;\r\ndev_set_drvdata(mci->pdev, mci);\r\npdata = mci->pvt_info;\r\npdata->dcr_host = *dcr_host;\r\nmci->mtype_cap = (MEM_FLAG_DDR | MEM_FLAG_RDDR |\r\nMEM_FLAG_DDR2 | MEM_FLAG_RDDR2);\r\nmci->edac_ctl_cap = (EDAC_FLAG_NONE |\r\nEDAC_FLAG_EC |\r\nEDAC_FLAG_SECDED);\r\nmci->scrub_cap = SCRUB_NONE;\r\nmci->scrub_mode = SCRUB_NONE;\r\nswitch (memcheck) {\r\ncase SDRAM_MCOPT1_MCHK_CHK:\r\nmci->edac_cap = EDAC_FLAG_EC;\r\nbreak;\r\ncase SDRAM_MCOPT1_MCHK_CHK_REP:\r\nmci->edac_cap = (EDAC_FLAG_EC | EDAC_FLAG_SECDED);\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nbreak;\r\ndefault:\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nbreak;\r\n}\r\nmci->mod_name = PPC4XX_EDAC_MODULE_NAME;\r\nmci->mod_ver = PPC4XX_EDAC_MODULE_REVISION;\r\nmci->ctl_name = ppc4xx_edac_match->compatible,\r\nmci->dev_name = np->full_name;\r\nmci->edac_check = ppc4xx_edac_check;\r\nmci->ctl_page_to_phys = NULL;\r\nstatus = ppc4xx_edac_init_csrows(mci, mcopt1);\r\nif (status)\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Failed to initialize rows!\n");\r\nreturn status;\r\n}\r\nstatic int ppc4xx_edac_register_irq(struct platform_device *op,\r\nstruct mem_ctl_info *mci)\r\n{\r\nint status = 0;\r\nint ded_irq, sec_irq;\r\nstruct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nstruct device_node *np = op->dev.of_node;\r\nded_irq = irq_of_parse_and_map(np, INTMAP_ECCDED_INDEX);\r\nsec_irq = irq_of_parse_and_map(np, INTMAP_ECCSEC_INDEX);\r\nif (!ded_irq || !sec_irq) {\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Unable to map interrupts.\n");\r\nstatus = -ENODEV;\r\ngoto fail;\r\n}\r\nstatus = request_irq(ded_irq,\r\nppc4xx_edac_isr,\r\n0,\r\n"[EDAC] MC ECCDED",\r\nmci);\r\nif (status < 0) {\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Unable to request irq %d for ECC DED",\r\nded_irq);\r\nstatus = -ENODEV;\r\ngoto fail1;\r\n}\r\nstatus = request_irq(sec_irq,\r\nppc4xx_edac_isr,\r\n0,\r\n"[EDAC] MC ECCSEC",\r\nmci);\r\nif (status < 0) {\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Unable to request irq %d for ECC SEC",\r\nsec_irq);\r\nstatus = -ENODEV;\r\ngoto fail2;\r\n}\r\nppc4xx_edac_mc_printk(KERN_INFO, mci, "ECCDED irq is %d\n", ded_irq);\r\nppc4xx_edac_mc_printk(KERN_INFO, mci, "ECCSEC irq is %d\n", sec_irq);\r\npdata->irqs.ded = ded_irq;\r\npdata->irqs.sec = sec_irq;\r\nreturn 0;\r\nfail2:\r\nfree_irq(sec_irq, mci);\r\nfail1:\r\nfree_irq(ded_irq, mci);\r\nfail:\r\nreturn status;\r\n}\r\nstatic int ppc4xx_edac_map_dcrs(const struct device_node *np,\r\ndcr_host_t *dcr_host)\r\n{\r\nunsigned int dcr_base, dcr_len;\r\nif (np == NULL || dcr_host == NULL)\r\nreturn -EINVAL;\r\ndcr_base = dcr_resource_start(np, 0);\r\ndcr_len = dcr_resource_len(np, 0);\r\nif (dcr_base == 0 || dcr_len == 0) {\r\nppc4xx_edac_printk(KERN_ERR,\r\n"Failed to obtain DCR property.\n");\r\nreturn -ENODEV;\r\n}\r\nif (dcr_len != SDRAM_DCR_RESOURCE_LEN) {\r\nppc4xx_edac_printk(KERN_ERR,\r\n"Unexpected DCR length %d, expected %d.\n",\r\ndcr_len, SDRAM_DCR_RESOURCE_LEN);\r\nreturn -ENODEV;\r\n}\r\n*dcr_host = dcr_map(np, dcr_base, dcr_len);\r\nif (!DCR_MAP_OK(*dcr_host)) {\r\nppc4xx_edac_printk(KERN_INFO, "Failed to map DCRs.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ppc4xx_edac_probe(struct platform_device *op)\r\n{\r\nint status = 0;\r\nu32 mcopt1, memcheck;\r\ndcr_host_t dcr_host;\r\nconst struct device_node *np = op->dev.of_node;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nstatic int ppc4xx_edac_instance;\r\nif (!of_device_is_compatible(np, "ibm,sdram-405ex") &&\r\n!of_device_is_compatible(np, "ibm,sdram-405exr")) {\r\nppc4xx_edac_printk(KERN_NOTICE,\r\n"Only the PPC405EX[r] is supported.\n");\r\nreturn -ENODEV;\r\n}\r\nstatus = ppc4xx_edac_map_dcrs(np, &dcr_host);\r\nif (status)\r\nreturn status;\r\nmcopt1 = mfsdram(&dcr_host, SDRAM_MCOPT1);\r\nmemcheck = (mcopt1 & SDRAM_MCOPT1_MCHK_MASK);\r\nif (memcheck == SDRAM_MCOPT1_MCHK_NON) {\r\nppc4xx_edac_printk(KERN_INFO, "%s: No ECC memory detected or "\r\n"ECC is disabled.\n", np->full_name);\r\nstatus = -ENODEV;\r\ngoto done;\r\n}\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = ppc4xx_edac_nr_csrows;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = ppc4xx_edac_nr_chans;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(ppc4xx_edac_instance, ARRAY_SIZE(layers), layers,\r\nsizeof(struct ppc4xx_edac_pdata));\r\nif (mci == NULL) {\r\nppc4xx_edac_printk(KERN_ERR, "%s: "\r\n"Failed to allocate EDAC MC instance!\n",\r\nnp->full_name);\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nstatus = ppc4xx_edac_mc_init(mci, op, &dcr_host, mcopt1);\r\nif (status) {\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Failed to initialize instance!\n");\r\ngoto fail;\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\nppc4xx_edac_mc_printk(KERN_ERR, mci,\r\n"Failed to add instance!\n");\r\nstatus = -ENODEV;\r\ngoto fail;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nstatus = ppc4xx_edac_register_irq(op, mci);\r\nif (status)\r\ngoto fail1;\r\n}\r\nppc4xx_edac_instance++;\r\nreturn 0;\r\nfail1:\r\nedac_mc_del_mc(mci->pdev);\r\nfail:\r\nedac_mc_free(mci);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int\r\nppc4xx_edac_remove(struct platform_device *op)\r\n{\r\nstruct mem_ctl_info *mci = dev_get_drvdata(&op->dev);\r\nstruct ppc4xx_edac_pdata *pdata = mci->pvt_info;\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nfree_irq(pdata->irqs.sec, mci);\r\nfree_irq(pdata->irqs.ded, mci);\r\n}\r\ndcr_unmap(pdata->dcr_host, SDRAM_DCR_RESOURCE_LEN);\r\nedac_mc_del_mc(mci->pdev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic inline void __init\r\nppc4xx_edac_opstate_init(void)\r\n{\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\nppc4xx_edac_printk(KERN_INFO, "Reporting type: %s\n",\r\n((edac_op_state == EDAC_OPSTATE_POLL) ?\r\nEDAC_OPSTATE_POLL_STR :\r\n((edac_op_state == EDAC_OPSTATE_INT) ?\r\nEDAC_OPSTATE_INT_STR :\r\nEDAC_OPSTATE_UNKNOWN_STR)));\r\n}\r\nstatic int __init\r\nppc4xx_edac_init(void)\r\n{\r\nppc4xx_edac_printk(KERN_INFO, PPC4XX_EDAC_MODULE_REVISION "\n");\r\nppc4xx_edac_opstate_init();\r\nreturn platform_driver_register(&ppc4xx_edac_driver);\r\n}\r\nstatic void __exit\r\nppc4xx_edac_exit(void)\r\n{\r\nplatform_driver_unregister(&ppc4xx_edac_driver);\r\n}
