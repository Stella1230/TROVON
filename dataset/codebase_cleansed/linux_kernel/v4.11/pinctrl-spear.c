static void muxregs_endisable(struct spear_pmx *pmx,\r\nstruct spear_muxreg *muxregs, u8 count, bool enable)\r\n{\r\nstruct spear_muxreg *muxreg;\r\nu32 val, temp, j;\r\nfor (j = 0; j < count; j++) {\r\nmuxreg = &muxregs[j];\r\nval = pmx_readl(pmx, muxreg->reg);\r\nval &= ~muxreg->mask;\r\nif (enable)\r\ntemp = muxreg->val;\r\nelse\r\ntemp = ~muxreg->val;\r\nval |= muxreg->mask & temp;\r\npmx_writel(pmx, val, muxreg->reg);\r\n}\r\n}\r\nstatic int set_mode(struct spear_pmx *pmx, int mode)\r\n{\r\nstruct spear_pmx_mode *pmx_mode = NULL;\r\nint i;\r\nu32 val;\r\nif (!pmx->machdata->pmx_modes || !pmx->machdata->npmx_modes)\r\nreturn -EINVAL;\r\nfor (i = 0; i < pmx->machdata->npmx_modes; i++) {\r\nif (pmx->machdata->pmx_modes[i]->mode == (1 << mode)) {\r\npmx_mode = pmx->machdata->pmx_modes[i];\r\nbreak;\r\n}\r\n}\r\nif (!pmx_mode)\r\nreturn -EINVAL;\r\nval = pmx_readl(pmx, pmx_mode->reg);\r\nval &= ~pmx_mode->mask;\r\nval |= pmx_mode->val;\r\npmx_writel(pmx, val, pmx_mode->reg);\r\npmx->machdata->mode = pmx_mode->mode;\r\ndev_info(pmx->dev, "Configured Mode: %s with id: %x\n\n",\r\npmx_mode->name ? pmx_mode->name : "no_name",\r\npmx_mode->reg);\r\nreturn 0;\r\n}\r\nvoid pmx_init_gpio_pingroup_addr(struct spear_gpio_pingroup *gpio_pingroup,\r\nunsigned count, u16 reg)\r\n{\r\nint i, j;\r\nfor (i = 0; i < count; i++)\r\nfor (j = 0; j < gpio_pingroup[i].nmuxregs; j++)\r\ngpio_pingroup[i].muxregs[j].reg = reg;\r\n}\r\nvoid pmx_init_addr(struct spear_pinctrl_machdata *machdata, u16 reg)\r\n{\r\nstruct spear_pingroup *pgroup;\r\nstruct spear_modemux *modemux;\r\nint i, j, group;\r\nfor (group = 0; group < machdata->ngroups; group++) {\r\npgroup = machdata->groups[group];\r\nfor (i = 0; i < pgroup->nmodemuxs; i++) {\r\nmodemux = &pgroup->modemuxs[i];\r\nfor (j = 0; j < modemux->nmuxregs; j++)\r\nif (modemux->muxregs[j].reg == 0xFFFF)\r\nmodemux->muxregs[j].reg = reg;\r\n}\r\n}\r\n}\r\nstatic int spear_pinctrl_get_groups_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->machdata->ngroups;\r\n}\r\nstatic const char *spear_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->machdata->groups[group]->name;\r\n}\r\nstatic int spear_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group, const unsigned **pins, unsigned *num_pins)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->machdata->groups[group]->pins;\r\n*num_pins = pmx->machdata->groups[group]->npins;\r\nreturn 0;\r\n}\r\nstatic void spear_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nseq_printf(s, " " DRIVER_NAME);\r\n}\r\nstatic int spear_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct device_node *np;\r\nstruct property *prop;\r\nconst char *function, *group;\r\nint ret, index = 0, count = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = of_property_read_string(np, "st,function", &function);\r\nif (ret < 0)\r\nreturn ret;\r\nret = of_property_count_strings(np, "st,pins");\r\nif (ret < 0)\r\nreturn ret;\r\ncount += ret;\r\n}\r\nif (!count) {\r\ndev_err(pmx->dev, "No child nodes passed via DT\n");\r\nreturn -ENODEV;\r\n}\r\n*map = kzalloc(sizeof(**map) * count, GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(np_config, np) {\r\nof_property_read_string(np, "st,function", &function);\r\nof_property_for_each_string(np, "st,pins", prop, group) {\r\n(*map)[index].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[index].data.mux.group = group;\r\n(*map)[index].data.mux.function = function;\r\nindex++;\r\n}\r\n}\r\n*num_maps = count;\r\nreturn 0;\r\n}\r\nstatic void spear_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic int spear_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->machdata->nfunctions;\r\n}\r\nstatic const char *spear_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->machdata->functions[function]->name;\r\n}\r\nstatic int spear_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function, const char *const **groups,\r\nunsigned * const ngroups)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmx->machdata->functions[function]->groups;\r\n*ngroups = pmx->machdata->functions[function]->ngroups;\r\nreturn 0;\r\n}\r\nstatic int spear_pinctrl_endisable(struct pinctrl_dev *pctldev,\r\nunsigned function, unsigned group, bool enable)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct spear_pingroup *pgroup;\r\nconst struct spear_modemux *modemux;\r\nint i;\r\nbool found = false;\r\npgroup = pmx->machdata->groups[group];\r\nfor (i = 0; i < pgroup->nmodemuxs; i++) {\r\nmodemux = &pgroup->modemuxs[i];\r\nif (pmx->machdata->modes_supported) {\r\nif (!(pmx->machdata->mode & modemux->modes))\r\ncontinue;\r\n}\r\nfound = true;\r\nmuxregs_endisable(pmx, modemux->muxregs, modemux->nmuxregs,\r\nenable);\r\n}\r\nif (!found) {\r\ndev_err(pmx->dev, "pinmux group: %s not supported\n",\r\npgroup->name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spear_pinctrl_set_mux(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nreturn spear_pinctrl_endisable(pctldev, function, group, true);\r\n}\r\nstatic struct spear_gpio_pingroup *get_gpio_pingroup(struct spear_pmx *pmx,\r\nunsigned pin)\r\n{\r\nstruct spear_gpio_pingroup *gpio_pingroup;\r\nint i, j;\r\nif (!pmx->machdata->gpio_pingroups)\r\nreturn NULL;\r\nfor (i = 0; i < pmx->machdata->ngpio_pingroups; i++) {\r\ngpio_pingroup = &pmx->machdata->gpio_pingroups[i];\r\nfor (j = 0; j < gpio_pingroup->npins; j++) {\r\nif (gpio_pingroup->pins[j] == pin)\r\nreturn gpio_pingroup;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gpio_request_endisable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool enable)\r\n{\r\nstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nstruct spear_pinctrl_machdata *machdata = pmx->machdata;\r\nstruct spear_gpio_pingroup *gpio_pingroup;\r\ngpio_pingroup = get_gpio_pingroup(pmx, offset);\r\nif (gpio_pingroup)\r\nmuxregs_endisable(pmx, gpio_pingroup->muxregs,\r\ngpio_pingroup->nmuxregs, enable);\r\nif (machdata->gpio_request_endisable)\r\nmachdata->gpio_request_endisable(pmx, offset, enable);\r\nreturn 0;\r\n}\r\nstatic int gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nreturn gpio_request_endisable(pctldev, range, offset, true);\r\n}\r\nstatic void gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\ngpio_request_endisable(pctldev, range, offset, false);\r\n}\r\nint spear_pinctrl_probe(struct platform_device *pdev,\r\nstruct spear_pinctrl_machdata *machdata)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *res;\r\nstruct spear_pmx *pmx;\r\nif (!machdata)\r\nreturn -ENODEV;\r\npmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\r\nif (!pmx) {\r\ndev_err(&pdev->dev, "Can't alloc spear_pmx\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npmx->vbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pmx->vbase))\r\nreturn PTR_ERR(pmx->vbase);\r\npmx->dev = &pdev->dev;\r\npmx->machdata = machdata;\r\nif (machdata->modes_supported) {\r\nint mode = 0;\r\nif (of_property_read_u32(np, "st,pinmux-mode", &mode)) {\r\ndev_err(&pdev->dev, "OF: pinmux mode not passed\n");\r\nreturn -EINVAL;\r\n}\r\nif (set_mode(pmx, mode)) {\r\ndev_err(&pdev->dev, "OF: Couldn't configure mode: %x\n",\r\nmode);\r\nreturn -EINVAL;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, pmx);\r\nspear_pinctrl_desc.pins = machdata->pins;\r\nspear_pinctrl_desc.npins = machdata->npins;\r\npmx->pctl = devm_pinctrl_register(&pdev->dev, &spear_pinctrl_desc, pmx);\r\nif (IS_ERR(pmx->pctl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pmx->pctl);\r\n}\r\nreturn 0;\r\n}
