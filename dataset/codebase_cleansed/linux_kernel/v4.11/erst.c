static inline int erst_errno(int command_status)\r\n{\r\nswitch (command_status) {\r\ncase ERST_STATUS_SUCCESS:\r\nreturn 0;\r\ncase ERST_STATUS_HARDWARE_NOT_AVAILABLE:\r\nreturn -ENODEV;\r\ncase ERST_STATUS_NOT_ENOUGH_SPACE:\r\nreturn -ENOSPC;\r\ncase ERST_STATUS_RECORD_STORE_EMPTY:\r\ncase ERST_STATUS_RECORD_NOT_FOUND:\r\nreturn -ENOENT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int erst_timedout(u64 *t, u64 spin_unit)\r\n{\r\nif ((s64)*t < spin_unit) {\r\npr_warn(FW_WARN "Firmware does not respond in time.\n");\r\nreturn 1;\r\n}\r\n*t -= spin_unit;\r\nndelay(spin_unit);\r\ntouch_nmi_watchdog();\r\nreturn 0;\r\n}\r\nstatic int erst_exec_load_var1(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_read_register(entry, &ctx->var1);\r\n}\r\nstatic int erst_exec_load_var2(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_read_register(entry, &ctx->var2);\r\n}\r\nstatic int erst_exec_store_var1(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_write_register(entry, ctx->var1);\r\n}\r\nstatic int erst_exec_add(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nctx->var1 += ctx->var2;\r\nreturn 0;\r\n}\r\nstatic int erst_exec_subtract(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nctx->var1 -= ctx->var2;\r\nreturn 0;\r\n}\r\nstatic int erst_exec_add_value(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 val;\r\nrc = __apei_exec_read_register(entry, &val);\r\nif (rc)\r\nreturn rc;\r\nval += ctx->value;\r\nrc = __apei_exec_write_register(entry, val);\r\nreturn rc;\r\n}\r\nstatic int erst_exec_subtract_value(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 val;\r\nrc = __apei_exec_read_register(entry, &val);\r\nif (rc)\r\nreturn rc;\r\nval -= ctx->value;\r\nrc = __apei_exec_write_register(entry, val);\r\nreturn rc;\r\n}\r\nstatic int erst_exec_stall(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nu64 stall_time;\r\nif (ctx->value > FIRMWARE_MAX_STALL) {\r\nif (!in_nmi())\r\npr_warn(FW_WARN\r\n"Too long stall time for stall instruction: 0x%llx.\n",\r\nctx->value);\r\nstall_time = FIRMWARE_MAX_STALL;\r\n} else\r\nstall_time = ctx->value;\r\nudelay(stall_time);\r\nreturn 0;\r\n}\r\nstatic int erst_exec_stall_while_true(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 val;\r\nu64 timeout = FIRMWARE_TIMEOUT;\r\nu64 stall_time;\r\nif (ctx->var1 > FIRMWARE_MAX_STALL) {\r\nif (!in_nmi())\r\npr_warn(FW_WARN\r\n"Too long stall time for stall while true instruction: 0x%llx.\n",\r\nctx->var1);\r\nstall_time = FIRMWARE_MAX_STALL;\r\n} else\r\nstall_time = ctx->var1;\r\nfor (;;) {\r\nrc = __apei_exec_read_register(entry, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val != ctx->value)\r\nbreak;\r\nif (erst_timedout(&timeout, stall_time * NSEC_PER_USEC))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int erst_exec_skip_next_instruction_if_true(\r\nstruct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 val;\r\nrc = __apei_exec_read_register(entry, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val == ctx->value) {\r\nctx->ip += 2;\r\nreturn APEI_EXEC_SET_IP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int erst_exec_goto(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nctx->ip = ctx->value;\r\nreturn APEI_EXEC_SET_IP;\r\n}\r\nstatic int erst_exec_set_src_address_base(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_read_register(entry, &ctx->src_base);\r\n}\r\nstatic int erst_exec_set_dst_address_base(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nreturn __apei_exec_read_register(entry, &ctx->dst_base);\r\n}\r\nstatic int erst_exec_move_data(struct apei_exec_context *ctx,\r\nstruct acpi_whea_header *entry)\r\n{\r\nint rc;\r\nu64 offset;\r\nvoid *src, *dst;\r\nif (in_interrupt()) {\r\npr_warn("MOVE_DATA can not be used in interrupt context.\n");\r\nreturn -EBUSY;\r\n}\r\nrc = __apei_exec_read_register(entry, &offset);\r\nif (rc)\r\nreturn rc;\r\nsrc = ioremap(ctx->src_base + offset, ctx->var2);\r\nif (!src)\r\nreturn -ENOMEM;\r\ndst = ioremap(ctx->dst_base + offset, ctx->var2);\r\nif (!dst) {\r\niounmap(src);\r\nreturn -ENOMEM;\r\n}\r\nmemmove(dst, src, ctx->var2);\r\niounmap(src);\r\niounmap(dst);\r\nreturn 0;\r\n}\r\nstatic inline void erst_exec_ctx_init(struct apei_exec_context *ctx)\r\n{\r\napei_exec_ctx_init(ctx, erst_ins_type, ARRAY_SIZE(erst_ins_type),\r\nERST_TAB_ENTRY(erst_tab), erst_tab->entries);\r\n}\r\nstatic int erst_get_erange(struct erst_erange *range)\r\n{\r\nstruct apei_exec_context ctx;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_RANGE);\r\nif (rc)\r\nreturn rc;\r\nrange->base = apei_exec_ctx_get_output(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_LENGTH);\r\nif (rc)\r\nreturn rc;\r\nrange->size = apei_exec_ctx_get_output(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_ATTRIBUTES);\r\nif (rc)\r\nreturn rc;\r\nrange->attr = apei_exec_ctx_get_output(&ctx);\r\nreturn 0;\r\n}\r\nstatic ssize_t __erst_get_record_count(void)\r\n{\r\nstruct apei_exec_context ctx;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_RECORD_COUNT);\r\nif (rc)\r\nreturn rc;\r\nreturn apei_exec_ctx_get_output(&ctx);\r\n}\r\nssize_t erst_get_record_count(void)\r\n{\r\nssize_t count;\r\nunsigned long flags;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nraw_spin_lock_irqsave(&erst_lock, flags);\r\ncount = __erst_get_record_count();\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nreturn count;\r\n}\r\nstatic int __erst_get_next_record_id(u64 *record_id)\r\n{\r\nstruct apei_exec_context ctx;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_RECORD_ID);\r\nif (rc)\r\nreturn rc;\r\n*record_id = apei_exec_ctx_get_output(&ctx);\r\nreturn 0;\r\n}\r\nint erst_get_record_id_begin(int *pos)\r\n{\r\nint rc;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nrc = mutex_lock_interruptible(&erst_record_id_cache.lock);\r\nif (rc)\r\nreturn rc;\r\nerst_record_id_cache.refcount++;\r\nmutex_unlock(&erst_record_id_cache.lock);\r\n*pos = 0;\r\nreturn 0;\r\n}\r\nstatic int __erst_record_id_cache_add_one(void)\r\n{\r\nu64 id, prev_id, first_id;\r\nint i, rc;\r\nu64 *entries;\r\nunsigned long flags;\r\nid = prev_id = first_id = APEI_ERST_INVALID_RECORD_ID;\r\nretry:\r\nraw_spin_lock_irqsave(&erst_lock, flags);\r\nrc = __erst_get_next_record_id(&id);\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nif (rc == -ENOENT)\r\nreturn 0;\r\nif (rc)\r\nreturn rc;\r\nif (id == APEI_ERST_INVALID_RECORD_ID)\r\nreturn 0;\r\nif (id == prev_id || id == first_id)\r\nreturn 0;\r\nif (first_id == APEI_ERST_INVALID_RECORD_ID)\r\nfirst_id = id;\r\nprev_id = id;\r\nentries = erst_record_id_cache.entries;\r\nfor (i = 0; i < erst_record_id_cache.len; i++) {\r\nif (entries[i] == id)\r\nbreak;\r\n}\r\nif (i < erst_record_id_cache.len)\r\ngoto retry;\r\nif (erst_record_id_cache.len >= erst_record_id_cache.size) {\r\nint new_size, alloc_size;\r\nu64 *new_entries;\r\nnew_size = erst_record_id_cache.size * 2;\r\nnew_size = clamp_val(new_size, ERST_RECORD_ID_CACHE_SIZE_MIN,\r\nERST_RECORD_ID_CACHE_SIZE_MAX);\r\nif (new_size <= erst_record_id_cache.size) {\r\nif (printk_ratelimit())\r\npr_warn(FW_WARN "too many record IDs!\n");\r\nreturn 0;\r\n}\r\nalloc_size = new_size * sizeof(entries[0]);\r\nif (alloc_size < PAGE_SIZE)\r\nnew_entries = kmalloc(alloc_size, GFP_KERNEL);\r\nelse\r\nnew_entries = vmalloc(alloc_size);\r\nif (!new_entries)\r\nreturn -ENOMEM;\r\nmemcpy(new_entries, entries,\r\nerst_record_id_cache.len * sizeof(entries[0]));\r\nkvfree(entries);\r\nerst_record_id_cache.entries = entries = new_entries;\r\nerst_record_id_cache.size = new_size;\r\n}\r\nentries[i] = id;\r\nerst_record_id_cache.len++;\r\nreturn 1;\r\n}\r\nint erst_get_record_id_next(int *pos, u64 *record_id)\r\n{\r\nint rc = 0;\r\nu64 *entries;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nBUG_ON(!erst_record_id_cache.refcount);\r\nBUG_ON(*pos < 0 || *pos > erst_record_id_cache.len);\r\nmutex_lock(&erst_record_id_cache.lock);\r\nentries = erst_record_id_cache.entries;\r\nfor (; *pos < erst_record_id_cache.len; (*pos)++)\r\nif (entries[*pos] != APEI_ERST_INVALID_RECORD_ID)\r\nbreak;\r\nif (*pos < erst_record_id_cache.len) {\r\n*record_id = entries[*pos];\r\n(*pos)++;\r\ngoto out_unlock;\r\n}\r\nrc = __erst_record_id_cache_add_one();\r\nif (rc < 0)\r\ngoto out_unlock;\r\nif (rc == 1) {\r\n*record_id = erst_record_id_cache.entries[*pos];\r\n(*pos)++;\r\nrc = 0;\r\n} else {\r\n*pos = -1;\r\n*record_id = APEI_ERST_INVALID_RECORD_ID;\r\n}\r\nout_unlock:\r\nmutex_unlock(&erst_record_id_cache.lock);\r\nreturn rc;\r\n}\r\nstatic void __erst_record_id_cache_compact(void)\r\n{\r\nint i, wpos = 0;\r\nu64 *entries;\r\nif (erst_record_id_cache.refcount)\r\nreturn;\r\nentries = erst_record_id_cache.entries;\r\nfor (i = 0; i < erst_record_id_cache.len; i++) {\r\nif (entries[i] == APEI_ERST_INVALID_RECORD_ID)\r\ncontinue;\r\nif (wpos != i)\r\nentries[wpos] = entries[i];\r\nwpos++;\r\n}\r\nerst_record_id_cache.len = wpos;\r\n}\r\nvoid erst_get_record_id_end(void)\r\n{\r\nBUG_ON(erst_disable);\r\nmutex_lock(&erst_record_id_cache.lock);\r\nerst_record_id_cache.refcount--;\r\nBUG_ON(erst_record_id_cache.refcount < 0);\r\n__erst_record_id_cache_compact();\r\nmutex_unlock(&erst_record_id_cache.lock);\r\n}\r\nstatic int __erst_write_to_storage(u64 offset)\r\n{\r\nstruct apei_exec_context ctx;\r\nu64 timeout = FIRMWARE_TIMEOUT;\r\nu64 val;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_WRITE);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, offset);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_OFFSET);\r\nif (rc)\r\nreturn rc;\r\nrc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\r\nif (rc)\r\nreturn rc;\r\nfor (;;) {\r\nrc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (!val)\r\nbreak;\r\nif (erst_timedout(&timeout, SPIN_UNIT))\r\nreturn -EIO;\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\r\nif (rc)\r\nreturn rc;\r\nreturn erst_errno(val);\r\n}\r\nstatic int __erst_read_from_storage(u64 record_id, u64 offset)\r\n{\r\nstruct apei_exec_context ctx;\r\nu64 timeout = FIRMWARE_TIMEOUT;\r\nu64 val;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_READ);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, offset);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_OFFSET);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, record_id);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_ID);\r\nif (rc)\r\nreturn rc;\r\nrc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\r\nif (rc)\r\nreturn rc;\r\nfor (;;) {\r\nrc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (!val)\r\nbreak;\r\nif (erst_timedout(&timeout, SPIN_UNIT))\r\nreturn -EIO;\r\n};\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\r\nif (rc)\r\nreturn rc;\r\nreturn erst_errno(val);\r\n}\r\nstatic int __erst_clear_from_storage(u64 record_id)\r\n{\r\nstruct apei_exec_context ctx;\r\nu64 timeout = FIRMWARE_TIMEOUT;\r\nu64 val;\r\nint rc;\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_CLEAR);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, record_id);\r\nrc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_ID);\r\nif (rc)\r\nreturn rc;\r\nrc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\r\nif (rc)\r\nreturn rc;\r\nfor (;;) {\r\nrc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (!val)\r\nbreak;\r\nif (erst_timedout(&timeout, SPIN_UNIT))\r\nreturn -EIO;\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\r\nif (rc)\r\nreturn rc;\r\nreturn erst_errno(val);\r\n}\r\nstatic void pr_unimpl_nvram(void)\r\n{\r\nif (printk_ratelimit())\r\npr_warn("NVRAM ERST Log Address Range not implemented yet.\n");\r\n}\r\nstatic int __erst_write_to_nvram(const struct cper_record_header *record)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int __erst_read_to_erange_from_nvram(u64 record_id, u64 *offset)\r\n{\r\npr_unimpl_nvram();\r\nreturn -ENOSYS;\r\n}\r\nstatic int __erst_clear_from_nvram(u64 record_id)\r\n{\r\npr_unimpl_nvram();\r\nreturn -ENOSYS;\r\n}\r\nint erst_write(const struct cper_record_header *record)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nstruct cper_record_header *rcd_erange;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nif (memcmp(record->signature, CPER_SIG_RECORD, CPER_SIG_SIZE))\r\nreturn -EINVAL;\r\nif (erst_erange.attr & ERST_RANGE_NVRAM) {\r\nif (!raw_spin_trylock_irqsave(&erst_lock, flags))\r\nreturn -EBUSY;\r\nrc = __erst_write_to_nvram(record);\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nreturn rc;\r\n}\r\nif (record->record_length > erst_erange.size)\r\nreturn -EINVAL;\r\nif (!raw_spin_trylock_irqsave(&erst_lock, flags))\r\nreturn -EBUSY;\r\nmemcpy(erst_erange.vaddr, record, record->record_length);\r\nrcd_erange = erst_erange.vaddr;\r\nmemcpy(&rcd_erange->persistence_information, "ER", 2);\r\nrc = __erst_write_to_storage(0);\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int __erst_read_to_erange(u64 record_id, u64 *offset)\r\n{\r\nint rc;\r\nif (erst_erange.attr & ERST_RANGE_NVRAM)\r\nreturn __erst_read_to_erange_from_nvram(\r\nrecord_id, offset);\r\nrc = __erst_read_from_storage(record_id, 0);\r\nif (rc)\r\nreturn rc;\r\n*offset = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t __erst_read(u64 record_id, struct cper_record_header *record,\r\nsize_t buflen)\r\n{\r\nint rc;\r\nu64 offset, len = 0;\r\nstruct cper_record_header *rcd_tmp;\r\nrc = __erst_read_to_erange(record_id, &offset);\r\nif (rc)\r\nreturn rc;\r\nrcd_tmp = erst_erange.vaddr + offset;\r\nlen = rcd_tmp->record_length;\r\nif (len <= buflen)\r\nmemcpy(record, rcd_tmp, len);\r\nreturn len;\r\n}\r\nssize_t erst_read(u64 record_id, struct cper_record_header *record,\r\nsize_t buflen)\r\n{\r\nssize_t len;\r\nunsigned long flags;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nraw_spin_lock_irqsave(&erst_lock, flags);\r\nlen = __erst_read(record_id, record, buflen);\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nreturn len;\r\n}\r\nint erst_clear(u64 record_id)\r\n{\r\nint rc, i;\r\nunsigned long flags;\r\nu64 *entries;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nrc = mutex_lock_interruptible(&erst_record_id_cache.lock);\r\nif (rc)\r\nreturn rc;\r\nraw_spin_lock_irqsave(&erst_lock, flags);\r\nif (erst_erange.attr & ERST_RANGE_NVRAM)\r\nrc = __erst_clear_from_nvram(record_id);\r\nelse\r\nrc = __erst_clear_from_storage(record_id);\r\nraw_spin_unlock_irqrestore(&erst_lock, flags);\r\nif (rc)\r\ngoto out;\r\nentries = erst_record_id_cache.entries;\r\nfor (i = 0; i < erst_record_id_cache.len; i++) {\r\nif (entries[i] == record_id)\r\nentries[i] = APEI_ERST_INVALID_RECORD_ID;\r\n}\r\n__erst_record_id_cache_compact();\r\nout:\r\nmutex_unlock(&erst_record_id_cache.lock);\r\nreturn rc;\r\n}\r\nstatic int __init setup_erst_disable(char *str)\r\n{\r\nerst_disable = 1;\r\nreturn 0;\r\n}\r\nstatic int erst_check_table(struct acpi_table_erst *erst_tab)\r\n{\r\nif ((erst_tab->header_length !=\r\n(sizeof(struct acpi_table_erst) - sizeof(erst_tab->header)))\r\n&& (erst_tab->header_length != sizeof(struct acpi_table_erst)))\r\nreturn -EINVAL;\r\nif (erst_tab->header.length < sizeof(struct acpi_table_erst))\r\nreturn -EINVAL;\r\nif (erst_tab->entries !=\r\n(erst_tab->header.length - sizeof(struct acpi_table_erst)) /\r\nsizeof(struct acpi_erst_entry))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int erst_open_pstore(struct pstore_info *psi)\r\n{\r\nint rc;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nrc = erst_get_record_id_begin(&reader_pos);\r\nreturn rc;\r\n}\r\nstatic int erst_close_pstore(struct pstore_info *psi)\r\n{\r\nerst_get_record_id_end();\r\nreturn 0;\r\n}\r\nstatic ssize_t erst_reader(u64 *id, enum pstore_type_id *type, int *count,\r\nstruct timespec *time, char **buf,\r\nbool *compressed, ssize_t *ecc_notice_size,\r\nstruct pstore_info *psi)\r\n{\r\nint rc;\r\nssize_t len = 0;\r\nu64 record_id;\r\nstruct cper_pstore_record *rcd;\r\nsize_t rcd_len = sizeof(*rcd) + erst_info.bufsize;\r\nif (erst_disable)\r\nreturn -ENODEV;\r\nrcd = kmalloc(rcd_len, GFP_KERNEL);\r\nif (!rcd) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nskip:\r\nrc = erst_get_record_id_next(&reader_pos, &record_id);\r\nif (rc)\r\ngoto out;\r\nif (record_id == APEI_ERST_INVALID_RECORD_ID) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlen = erst_read(record_id, &rcd->hdr, rcd_len);\r\nif (len == -ENOENT)\r\ngoto skip;\r\nelse if (len < sizeof(*rcd)) {\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nif (uuid_le_cmp(rcd->hdr.creator_id, CPER_CREATOR_PSTORE) != 0)\r\ngoto skip;\r\n*buf = kmalloc(len, GFP_KERNEL);\r\nif (*buf == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(*buf, rcd->data, len - sizeof(*rcd));\r\n*id = record_id;\r\n*compressed = false;\r\n*ecc_notice_size = 0;\r\nif (uuid_le_cmp(rcd->sec_hdr.section_type,\r\nCPER_SECTION_TYPE_DMESG_Z) == 0) {\r\n*type = PSTORE_TYPE_DMESG;\r\n*compressed = true;\r\n} else if (uuid_le_cmp(rcd->sec_hdr.section_type,\r\nCPER_SECTION_TYPE_DMESG) == 0)\r\n*type = PSTORE_TYPE_DMESG;\r\nelse if (uuid_le_cmp(rcd->sec_hdr.section_type,\r\nCPER_SECTION_TYPE_MCE) == 0)\r\n*type = PSTORE_TYPE_MCE;\r\nelse\r\n*type = PSTORE_TYPE_UNKNOWN;\r\nif (rcd->hdr.validation_bits & CPER_VALID_TIMESTAMP)\r\ntime->tv_sec = rcd->hdr.timestamp;\r\nelse\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nout:\r\nkfree(rcd);\r\nreturn (rc < 0) ? rc : (len - sizeof(*rcd));\r\n}\r\nstatic int erst_writer(enum pstore_type_id type, enum kmsg_dump_reason reason,\r\nu64 *id, unsigned int part, int count, bool compressed,\r\nsize_t size, struct pstore_info *psi)\r\n{\r\nstruct cper_pstore_record *rcd = (struct cper_pstore_record *)\r\n(erst_info.buf - sizeof(*rcd));\r\nint ret;\r\nmemset(rcd, 0, sizeof(*rcd));\r\nmemcpy(rcd->hdr.signature, CPER_SIG_RECORD, CPER_SIG_SIZE);\r\nrcd->hdr.revision = CPER_RECORD_REV;\r\nrcd->hdr.signature_end = CPER_SIG_END;\r\nrcd->hdr.section_count = 1;\r\nrcd->hdr.error_severity = CPER_SEV_FATAL;\r\nrcd->hdr.validation_bits = CPER_VALID_TIMESTAMP;\r\nrcd->hdr.timestamp = get_seconds();\r\nrcd->hdr.record_length = sizeof(*rcd) + size;\r\nrcd->hdr.creator_id = CPER_CREATOR_PSTORE;\r\nrcd->hdr.notification_type = CPER_NOTIFY_MCE;\r\nrcd->hdr.record_id = cper_next_record_id();\r\nrcd->hdr.flags = CPER_HW_ERROR_FLAGS_PREVERR;\r\nrcd->sec_hdr.section_offset = sizeof(*rcd);\r\nrcd->sec_hdr.section_length = size;\r\nrcd->sec_hdr.revision = CPER_SEC_REV;\r\nrcd->sec_hdr.validation_bits = 0;\r\nrcd->sec_hdr.flags = CPER_SEC_PRIMARY;\r\nswitch (type) {\r\ncase PSTORE_TYPE_DMESG:\r\nif (compressed)\r\nrcd->sec_hdr.section_type = CPER_SECTION_TYPE_DMESG_Z;\r\nelse\r\nrcd->sec_hdr.section_type = CPER_SECTION_TYPE_DMESG;\r\nbreak;\r\ncase PSTORE_TYPE_MCE:\r\nrcd->sec_hdr.section_type = CPER_SECTION_TYPE_MCE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrcd->sec_hdr.section_severity = CPER_SEV_FATAL;\r\nret = erst_write(&rcd->hdr);\r\n*id = rcd->hdr.record_id;\r\nreturn ret;\r\n}\r\nstatic int erst_clearer(enum pstore_type_id type, u64 id, int count,\r\nstruct timespec time, struct pstore_info *psi)\r\n{\r\nreturn erst_clear(id);\r\n}\r\nstatic int __init erst_init(void)\r\n{\r\nint rc = 0;\r\nacpi_status status;\r\nstruct apei_exec_context ctx;\r\nstruct apei_resources erst_resources;\r\nstruct resource *r;\r\nchar *buf;\r\nif (acpi_disabled)\r\ngoto err;\r\nif (erst_disable) {\r\npr_info(\r\n"Error Record Serialization Table (ERST) support is disabled.\n");\r\ngoto err;\r\n}\r\nstatus = acpi_get_table(ACPI_SIG_ERST, 0,\r\n(struct acpi_table_header **)&erst_tab);\r\nif (status == AE_NOT_FOUND)\r\ngoto err;\r\nelse if (ACPI_FAILURE(status)) {\r\nconst char *msg = acpi_format_exception(status);\r\npr_err("Failed to get table, %s\n", msg);\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nrc = erst_check_table(erst_tab);\r\nif (rc) {\r\npr_err(FW_BUG "ERST table is invalid.\n");\r\ngoto err;\r\n}\r\napei_resources_init(&erst_resources);\r\nerst_exec_ctx_init(&ctx);\r\nrc = apei_exec_collect_resources(&ctx, &erst_resources);\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_resources_request(&erst_resources, "APEI ERST");\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_exec_pre_map_gars(&ctx);\r\nif (rc)\r\ngoto err_release;\r\nrc = erst_get_erange(&erst_erange);\r\nif (rc) {\r\nif (rc == -ENODEV)\r\npr_info(\r\n"The corresponding hardware device or firmware implementation "\r\n"is not available.\n");\r\nelse\r\npr_err("Failed to get Error Log Address Range.\n");\r\ngoto err_unmap_reg;\r\n}\r\nr = request_mem_region(erst_erange.base, erst_erange.size, "APEI ERST");\r\nif (!r) {\r\npr_err("Can not request [mem %#010llx-%#010llx] for ERST.\n",\r\n(unsigned long long)erst_erange.base,\r\n(unsigned long long)erst_erange.base + erst_erange.size - 1);\r\nrc = -EIO;\r\ngoto err_unmap_reg;\r\n}\r\nrc = -ENOMEM;\r\nerst_erange.vaddr = ioremap_cache(erst_erange.base,\r\nerst_erange.size);\r\nif (!erst_erange.vaddr)\r\ngoto err_release_erange;\r\npr_info(\r\n"Error Record Serialization Table (ERST) support is initialized.\n");\r\nbuf = kmalloc(erst_erange.size, GFP_KERNEL);\r\nspin_lock_init(&erst_info.buf_lock);\r\nif (buf) {\r\nerst_info.buf = buf + sizeof(struct cper_pstore_record);\r\nerst_info.bufsize = erst_erange.size -\r\nsizeof(struct cper_pstore_record);\r\nrc = pstore_register(&erst_info);\r\nif (rc) {\r\nif (rc != -EPERM)\r\npr_info(\r\n"Could not register with persistent store.\n");\r\nerst_info.buf = NULL;\r\nerst_info.bufsize = 0;\r\nkfree(buf);\r\n}\r\n} else\r\npr_err(\r\n"Failed to allocate %lld bytes for persistent store error log.\n",\r\nerst_erange.size);\r\napei_resources_fini(&erst_resources);\r\nreturn 0;\r\nerr_release_erange:\r\nrelease_mem_region(erst_erange.base, erst_erange.size);\r\nerr_unmap_reg:\r\napei_exec_post_unmap_gars(&ctx);\r\nerr_release:\r\napei_resources_release(&erst_resources);\r\nerr_fini:\r\napei_resources_fini(&erst_resources);\r\nerr:\r\nerst_disable = 1;\r\nreturn rc;\r\n}
