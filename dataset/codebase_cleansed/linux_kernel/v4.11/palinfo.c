static void bitvector_process(struct seq_file *m, u64 vector)\r\n{\r\nint i,j;\r\nstatic const char *units[]={ "", "K", "M", "G", "T" };\r\nfor (i=0, j=0; i < 64; i++ , j=i/10) {\r\nif (vector & 0x1)\r\nseq_printf(m, "%d%s ", 1 << (i-j*10), units[j]);\r\nvector >>= 1;\r\n}\r\n}\r\nstatic void bitregister_process(struct seq_file *m, u64 *reg_info, int max)\r\n{\r\nint i, begin, skip = 0;\r\nu64 value = reg_info[0];\r\nvalue >>= i = begin = ffs(value) - 1;\r\nfor(; i < max; i++ ) {\r\nif (i != 0 && (i%64) == 0) value = *++reg_info;\r\nif ((value & 0x1) == 0 && skip == 0) {\r\nif (begin <= i - 2)\r\nseq_printf(m, "%d-%d ", begin, i-1);\r\nelse\r\nseq_printf(m, "%d ", i-1);\r\nskip = 1;\r\nbegin = -1;\r\n} else if ((value & 0x1) && skip == 1) {\r\nskip = 0;\r\nbegin = i;\r\n}\r\nvalue >>=1;\r\n}\r\nif (begin > -1) {\r\nif (begin < 127)\r\nseq_printf(m, "%d-127", begin);\r\nelse\r\nseq_puts(m, "127");\r\n}\r\n}\r\nstatic int power_info(struct seq_file *m)\r\n{\r\ns64 status;\r\nu64 halt_info_buffer[8];\r\npal_power_mgmt_info_u_t *halt_info =(pal_power_mgmt_info_u_t *)halt_info_buffer;\r\nint i;\r\nstatus = ia64_pal_halt_info(halt_info);\r\nif (status != 0) return 0;\r\nfor (i=0; i < 8 ; i++ ) {\r\nif (halt_info[i].pal_power_mgmt_info_s.im == 1) {\r\nseq_printf(m,\r\n"Power level %d:\n"\r\n"\tentry_latency : %d cycles\n"\r\n"\texit_latency : %d cycles\n"\r\n"\tpower consumption : %d mW\n"\r\n"\tCache+TLB coherency : %s\n", i,\r\nhalt_info[i].pal_power_mgmt_info_s.entry_latency,\r\nhalt_info[i].pal_power_mgmt_info_s.exit_latency,\r\nhalt_info[i].pal_power_mgmt_info_s.power_consumption,\r\nhalt_info[i].pal_power_mgmt_info_s.co ? "Yes" : "No");\r\n} else {\r\nseq_printf(m,"Power level %d: not implemented\n", i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cache_info(struct seq_file *m)\r\n{\r\nunsigned long i, levels, unique_caches;\r\npal_cache_config_info_t cci;\r\nint j, k;\r\nlong status;\r\nif ((status = ia64_pal_cache_summary(&levels, &unique_caches)) != 0) {\r\nprintk(KERN_ERR "ia64_pal_cache_summary=%ld\n", status);\r\nreturn 0;\r\n}\r\nseq_printf(m, "Cache levels : %ld\nUnique caches : %ld\n\n",\r\nlevels, unique_caches);\r\nfor (i=0; i < levels; i++) {\r\nfor (j=2; j >0 ; j--) {\r\nif ((status=ia64_pal_cache_config_info(i,j, &cci)) != 0)\r\ncontinue;\r\nseq_printf(m,\r\n"%s Cache level %lu:\n"\r\n"\tSize : %u bytes\n"\r\n"\tAttributes : ",\r\ncache_types[j+cci.pcci_unified], i+1,\r\ncci.pcci_cache_size);\r\nif (cci.pcci_unified)\r\nseq_puts(m, "Unified ");\r\nseq_printf(m, "%s\n", cache_mattrib[cci.pcci_cache_attr]);\r\nseq_printf(m,\r\n"\tAssociativity : %d\n"\r\n"\tLine size : %d bytes\n"\r\n"\tStride : %d bytes\n",\r\ncci.pcci_assoc,\r\n1<<cci.pcci_line_size,\r\n1<<cci.pcci_stride);\r\nif (j == 1)\r\nseq_puts(m, "\tStore latency : N/A\n");\r\nelse\r\nseq_printf(m, "\tStore latency : %d cycle(s)\n",\r\ncci.pcci_st_latency);\r\nseq_printf(m,\r\n"\tLoad latency : %d cycle(s)\n"\r\n"\tStore hints : ", cci.pcci_ld_latency);\r\nfor(k=0; k < 8; k++ ) {\r\nif ( cci.pcci_st_hints & 0x1)\r\nseq_printf(m, "[%s]", cache_st_hints[k]);\r\ncci.pcci_st_hints >>=1;\r\n}\r\nseq_puts(m, "\n\tLoad hints : ");\r\nfor(k=0; k < 8; k++ ) {\r\nif (cci.pcci_ld_hints & 0x1)\r\nseq_printf(m, "[%s]", cache_ld_hints[k]);\r\ncci.pcci_ld_hints >>=1;\r\n}\r\nseq_printf(m,\r\n"\n\tAlias boundary : %d byte(s)\n"\r\n"\tTag LSB : %d\n"\r\n"\tTag MSB : %d\n",\r\n1<<cci.pcci_alias_boundary, cci.pcci_tag_lsb,\r\ncci.pcci_tag_msb);\r\nif (cci.pcci_unified)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vm_info(struct seq_file *m)\r\n{\r\nu64 tr_pages =0, vw_pages=0, tc_pages;\r\nu64 attrib;\r\npal_vm_info_1_u_t vm_info_1;\r\npal_vm_info_2_u_t vm_info_2;\r\npal_tc_info_u_t tc_info;\r\nia64_ptce_info_t ptce;\r\nconst char *sep;\r\nint i, j;\r\nlong status;\r\nif ((status = ia64_pal_vm_summary(&vm_info_1, &vm_info_2)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_summary=%ld\n", status);\r\n} else {\r\nseq_printf(m,\r\n"Physical Address Space : %d bits\n"\r\n"Virtual Address Space : %d bits\n"\r\n"Protection Key Registers(PKR) : %d\n"\r\n"Implemented bits in PKR.key : %d\n"\r\n"Hash Tag ID : 0x%x\n"\r\n"Size of RR.rid : %d\n"\r\n"Max Purges : ",\r\nvm_info_1.pal_vm_info_1_s.phys_add_size,\r\nvm_info_2.pal_vm_info_2_s.impl_va_msb+1,\r\nvm_info_1.pal_vm_info_1_s.max_pkr+1,\r\nvm_info_1.pal_vm_info_1_s.key_size,\r\nvm_info_1.pal_vm_info_1_s.hash_tag_id,\r\nvm_info_2.pal_vm_info_2_s.rid_size);\r\nif (vm_info_2.pal_vm_info_2_s.max_purges == PAL_MAX_PURGES)\r\nseq_puts(m, "unlimited\n");\r\nelse\r\nseq_printf(m, "%d\n",\r\nvm_info_2.pal_vm_info_2_s.max_purges ?\r\nvm_info_2.pal_vm_info_2_s.max_purges : 1);\r\n}\r\nif (ia64_pal_mem_attrib(&attrib) == 0) {\r\nseq_puts(m, "Supported memory attributes : ");\r\nsep = "";\r\nfor (i = 0; i < 8; i++) {\r\nif (attrib & (1 << i)) {\r\nseq_printf(m, "%s%s", sep, mem_attrib[i]);\r\nsep = ", ";\r\n}\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nif ((status = ia64_pal_vm_page_size(&tr_pages, &vw_pages)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_page_size=%ld\n", status);\r\n} else {\r\nseq_printf(m,\r\n"\nTLB walker : %simplemented\n"\r\n"Number of DTR : %d\n"\r\n"Number of ITR : %d\n"\r\n"TLB insertable page sizes : ",\r\nvm_info_1.pal_vm_info_1_s.vw ? "" : "not ",\r\nvm_info_1.pal_vm_info_1_s.max_dtr_entry+1,\r\nvm_info_1.pal_vm_info_1_s.max_itr_entry+1);\r\nbitvector_process(m, tr_pages);\r\nseq_puts(m, "\nTLB purgeable page sizes : ");\r\nbitvector_process(m, vw_pages);\r\n}\r\nif ((status = ia64_get_ptce(&ptce)) != 0) {\r\nprintk(KERN_ERR "ia64_get_ptce=%ld\n", status);\r\n} else {\r\nseq_printf(m,\r\n"\nPurge base address : 0x%016lx\n"\r\n"Purge outer loop count : %d\n"\r\n"Purge inner loop count : %d\n"\r\n"Purge outer loop stride : %d\n"\r\n"Purge inner loop stride : %d\n",\r\nptce.base, ptce.count[0], ptce.count[1],\r\nptce.stride[0], ptce.stride[1]);\r\nseq_printf(m,\r\n"TC Levels : %d\n"\r\n"Unique TC(s) : %d\n",\r\nvm_info_1.pal_vm_info_1_s.num_tc_levels,\r\nvm_info_1.pal_vm_info_1_s.max_unique_tcs);\r\nfor(i=0; i < vm_info_1.pal_vm_info_1_s.num_tc_levels; i++) {\r\nfor (j=2; j>0 ; j--) {\r\ntc_pages = 0;\r\nif ((status=ia64_pal_vm_info(i,j, &tc_info, &tc_pages)) != 0)\r\ncontinue;\r\nseq_printf(m,\r\n"\n%s Translation Cache Level %d:\n"\r\n"\tHash sets : %d\n"\r\n"\tAssociativity : %d\n"\r\n"\tNumber of entries : %d\n"\r\n"\tFlags : ",\r\ncache_types[j+tc_info.tc_unified], i+1,\r\ntc_info.tc_num_sets,\r\ntc_info.tc_associativity,\r\ntc_info.tc_num_entries);\r\nif (tc_info.tc_pf)\r\nseq_puts(m, "PreferredPageSizeOptimized ");\r\nif (tc_info.tc_unified)\r\nseq_puts(m, "Unified ");\r\nif (tc_info.tc_reduce_tr)\r\nseq_puts(m, "TCReduction");\r\nseq_puts(m, "\n\tSupported page sizes: ");\r\nbitvector_process(m, tc_pages);\r\nif (tc_info.tc_unified)\r\nbreak;\r\n}\r\n}\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int register_info(struct seq_file *m)\r\n{\r\nu64 reg_info[2];\r\nu64 info;\r\nunsigned long phys_stacked;\r\npal_hints_u_t hints;\r\nunsigned long iregs, dregs;\r\nstatic const char * const info_type[] = {\r\n"Implemented AR(s)",\r\n"AR(s) with read side-effects",\r\n"Implemented CR(s)",\r\n"CR(s) with read side-effects",\r\n};\r\nfor(info=0; info < 4; info++) {\r\nif (ia64_pal_register_info(info, &reg_info[0], &reg_info[1]) != 0)\r\nreturn 0;\r\nseq_printf(m, "%-32s : ", info_type[info]);\r\nbitregister_process(m, reg_info, 128);\r\nseq_putc(m, '\n');\r\n}\r\nif (ia64_pal_rse_info(&phys_stacked, &hints) == 0)\r\nseq_printf(m,\r\n"RSE stacked physical registers : %ld\n"\r\n"RSE load/store hints : %ld (%s)\n",\r\nphys_stacked, hints.ph_data,\r\nhints.ph_data < RSE_HINTS_COUNT ? rse_hints[hints.ph_data]: "(??)");\r\nif (ia64_pal_debug_info(&iregs, &dregs))\r\nreturn 0;\r\nseq_printf(m,\r\n"Instruction debug register pairs : %ld\n"\r\n"Data debug register pairs : %ld\n", iregs, dregs);\r\nreturn 0;\r\n}\r\nstatic void feature_set_info(struct seq_file *m, u64 avail, u64 status, u64 control,\r\nunsigned long set)\r\n{\r\nconst char *const *vf, *const *v;\r\nint i;\r\nvf = v = proc_features[set];\r\nfor(i=0; i < 64; i++, avail >>=1, status >>=1, control >>=1) {\r\nif (!(control))\r\nbreak;\r\nif (!(avail & 0x1))\r\ncontinue;\r\nif (vf)\r\nv = vf + i;\r\nif ( v && *v ) {\r\nseq_printf(m, "%-40s : %s %s\n", *v,\r\navail & 0x1 ? (status & 0x1 ?\r\n"On " : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ?\r\n"Ctrl" : "NoCtrl"): "");\r\n} else {\r\nseq_printf(m, "Feature set %2ld bit %2d\t\t\t"\r\n" : %s %s\n",\r\nset, i,\r\navail & 0x1 ? (status & 0x1 ?\r\n"On " : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ?\r\n"Ctrl" : "NoCtrl"): "");\r\n}\r\n}\r\n}\r\nstatic int processor_info(struct seq_file *m)\r\n{\r\nu64 avail=1, status=1, control=1, feature_set=0;\r\ns64 ret;\r\ndo {\r\nret = ia64_pal_proc_get_features(&avail, &status, &control,\r\nfeature_set);\r\nif (ret < 0)\r\nreturn 0;\r\nif (ret == 1) {\r\nfeature_set++;\r\ncontinue;\r\n}\r\nfeature_set_info(m, avail, status, control, feature_set);\r\nfeature_set++;\r\n} while(1);\r\nreturn 0;\r\n}\r\nstatic int bus_info(struct seq_file *m)\r\n{\r\nconst char *const *v = bus_features;\r\npal_bus_features_u_t av, st, ct;\r\nu64 avail, status, control;\r\nint i;\r\ns64 ret;\r\nif ((ret=ia64_pal_bus_get_features(&av, &st, &ct)) != 0)\r\nreturn 0;\r\navail = av.pal_bus_features_val;\r\nstatus = st.pal_bus_features_val;\r\ncontrol = ct.pal_bus_features_val;\r\nfor(i=0; i < 64; i++, v++, avail >>=1, status >>=1, control >>=1) {\r\nif ( ! *v )\r\ncontinue;\r\nseq_printf(m, "%-48s : %s%s %s\n", *v,\r\navail & 0x1 ? "" : "NotImpl",\r\navail & 0x1 ? (status & 0x1 ? "On" : "Off"): "",\r\navail & 0x1 ? (control & 0x1 ? "Ctrl" : "NoCtrl"): "");\r\n}\r\nreturn 0;\r\n}\r\nstatic int version_info(struct seq_file *m)\r\n{\r\npal_version_u_t min_ver, cur_ver;\r\nif (ia64_pal_version(&min_ver, &cur_ver) != 0)\r\nreturn 0;\r\nseq_printf(m,\r\n"PAL_vendor : 0x%02x (min=0x%02x)\n"\r\n"PAL_A : %02x.%02x (min=%02x.%02x)\n"\r\n"PAL_B : %02x.%02x (min=%02x.%02x)\n",\r\ncur_ver.pal_version_s.pv_pal_vendor,\r\nmin_ver.pal_version_s.pv_pal_vendor,\r\ncur_ver.pal_version_s.pv_pal_a_model,\r\ncur_ver.pal_version_s.pv_pal_a_rev,\r\nmin_ver.pal_version_s.pv_pal_a_model,\r\nmin_ver.pal_version_s.pv_pal_a_rev,\r\ncur_ver.pal_version_s.pv_pal_b_model,\r\ncur_ver.pal_version_s.pv_pal_b_rev,\r\nmin_ver.pal_version_s.pv_pal_b_model,\r\nmin_ver.pal_version_s.pv_pal_b_rev);\r\nreturn 0;\r\n}\r\nstatic int perfmon_info(struct seq_file *m)\r\n{\r\nu64 pm_buffer[16];\r\npal_perf_mon_info_u_t pm_info;\r\nif (ia64_pal_perf_mon_info(pm_buffer, &pm_info) != 0)\r\nreturn 0;\r\nseq_printf(m,\r\n"PMC/PMD pairs : %d\n"\r\n"Counter width : %d bits\n"\r\n"Cycle event number : %d\n"\r\n"Retired event number : %d\n"\r\n"Implemented PMC : ",\r\npm_info.pal_perf_mon_info_s.generic,\r\npm_info.pal_perf_mon_info_s.width,\r\npm_info.pal_perf_mon_info_s.cycles,\r\npm_info.pal_perf_mon_info_s.retired);\r\nbitregister_process(m, pm_buffer, 256);\r\nseq_puts(m, "\nImplemented PMD : ");\r\nbitregister_process(m, pm_buffer+4, 256);\r\nseq_puts(m, "\nCycles count capable : ");\r\nbitregister_process(m, pm_buffer+8, 256);\r\nseq_puts(m, "\nRetired bundles count capable : ");\r\n#ifdef CONFIG_ITANIUM\r\nif (pm_buffer[12] == 0x10)\r\npm_buffer[12]=0x30;\r\n#endif\r\nbitregister_process(m, pm_buffer+12, 256);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int frequency_info(struct seq_file *m)\r\n{\r\nstruct pal_freq_ratio proc, itc, bus;\r\nunsigned long base;\r\nif (ia64_pal_freq_base(&base) == -1)\r\nseq_puts(m, "Output clock : not implemented\n");\r\nelse\r\nseq_printf(m, "Output clock : %ld ticks/s\n", base);\r\nif (ia64_pal_freq_ratios(&proc, &bus, &itc) != 0) return 0;\r\nseq_printf(m,\r\n"Processor/Clock ratio : %d/%d\n"\r\n"Bus/Clock ratio : %d/%d\n"\r\n"ITC/Clock ratio : %d/%d\n",\r\nproc.num, proc.den, bus.num, bus.den, itc.num, itc.den);\r\nreturn 0;\r\n}\r\nstatic int tr_info(struct seq_file *m)\r\n{\r\nlong status;\r\npal_tr_valid_u_t tr_valid;\r\nu64 tr_buffer[4];\r\npal_vm_info_1_u_t vm_info_1;\r\npal_vm_info_2_u_t vm_info_2;\r\nunsigned long i, j;\r\nunsigned long max[3], pgm;\r\nstruct ifa_reg {\r\nunsigned long valid:1;\r\nunsigned long ig:11;\r\nunsigned long vpn:52;\r\n} *ifa_reg;\r\nstruct itir_reg {\r\nunsigned long rv1:2;\r\nunsigned long ps:6;\r\nunsigned long key:24;\r\nunsigned long rv2:32;\r\n} *itir_reg;\r\nstruct gr_reg {\r\nunsigned long p:1;\r\nunsigned long rv1:1;\r\nunsigned long ma:3;\r\nunsigned long a:1;\r\nunsigned long d:1;\r\nunsigned long pl:2;\r\nunsigned long ar:3;\r\nunsigned long ppn:38;\r\nunsigned long rv2:2;\r\nunsigned long ed:1;\r\nunsigned long ig:11;\r\n} *gr_reg;\r\nstruct rid_reg {\r\nunsigned long ig1:1;\r\nunsigned long rv1:1;\r\nunsigned long ig2:6;\r\nunsigned long rid:24;\r\nunsigned long rv2:32;\r\n} *rid_reg;\r\nif ((status = ia64_pal_vm_summary(&vm_info_1, &vm_info_2)) !=0) {\r\nprintk(KERN_ERR "ia64_pal_vm_summary=%ld\n", status);\r\nreturn 0;\r\n}\r\nmax[0] = vm_info_1.pal_vm_info_1_s.max_itr_entry+1;\r\nmax[1] = vm_info_1.pal_vm_info_1_s.max_dtr_entry+1;\r\nfor (i=0; i < 2; i++ ) {\r\nfor (j=0; j < max[i]; j++) {\r\nstatus = ia64_pal_tr_read(j, i, tr_buffer, &tr_valid);\r\nif (status != 0) {\r\nprintk(KERN_ERR "palinfo: pal call failed on tr[%lu:%lu]=%ld\n",\r\ni, j, status);\r\ncontinue;\r\n}\r\nifa_reg = (struct ifa_reg *)&tr_buffer[2];\r\nif (ifa_reg->valid == 0)\r\ncontinue;\r\ngr_reg = (struct gr_reg *)tr_buffer;\r\nitir_reg = (struct itir_reg *)&tr_buffer[1];\r\nrid_reg = (struct rid_reg *)&tr_buffer[3];\r\npgm = -1 << (itir_reg->ps - 12);\r\nseq_printf(m,\r\n"%cTR%lu: av=%d pv=%d dv=%d mv=%d\n"\r\n"\tppn : 0x%lx\n"\r\n"\tvpn : 0x%lx\n"\r\n"\tps : ",\r\n"ID"[i], j,\r\ntr_valid.pal_tr_valid_s.access_rights_valid,\r\ntr_valid.pal_tr_valid_s.priv_level_valid,\r\ntr_valid.pal_tr_valid_s.dirty_bit_valid,\r\ntr_valid.pal_tr_valid_s.mem_attr_valid,\r\n(gr_reg->ppn & pgm)<< 12, (ifa_reg->vpn & pgm)<< 12);\r\nbitvector_process(m, 1<< itir_reg->ps);\r\nseq_printf(m,\r\n"\n\tpl : %d\n"\r\n"\tar : %d\n"\r\n"\trid : %x\n"\r\n"\tp : %d\n"\r\n"\tma : %d\n"\r\n"\td : %d\n",\r\ngr_reg->pl, gr_reg->ar, rid_reg->rid, gr_reg->p, gr_reg->ma,\r\ngr_reg->d);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\npalinfo_smp_call(void *info)\r\n{\r\npalinfo_smp_data_t *data = (palinfo_smp_data_t *)info;\r\ndata->ret = (*data->func)(data->m);\r\n}\r\nstatic\r\nint palinfo_handle_smp(struct seq_file *m, pal_func_cpu_u_t *f)\r\n{\r\npalinfo_smp_data_t ptr;\r\nint ret;\r\nptr.func = palinfo_entries[f->func_id].proc_read;\r\nptr.m = m;\r\nptr.ret = 0;\r\nif ((ret=smp_call_function_single(f->req_cpu, palinfo_smp_call, &ptr, 1))) {\r\nprintk(KERN_ERR "palinfo: remote CPU call from %d to %d on function %d: "\r\n"error %d\n", smp_processor_id(), f->req_cpu, f->func_id, ret);\r\nreturn 0;\r\n}\r\nreturn ptr.ret;\r\n}\r\nstatic\r\nint palinfo_handle_smp(struct seq_file *m, pal_func_cpu_u_t *f)\r\n{\r\nprintk(KERN_ERR "palinfo: should not be called with non SMP kernel\n");\r\nreturn 0;\r\n}\r\nstatic int proc_palinfo_show(struct seq_file *m, void *v)\r\n{\r\npal_func_cpu_u_t *f = (pal_func_cpu_u_t *)&m->private;\r\nif (f->req_cpu == get_cpu())\r\n(*palinfo_entries[f->func_id].proc_read)(m);\r\nelse\r\npalinfo_handle_smp(m, f);\r\nput_cpu();\r\nreturn 0;\r\n}\r\nstatic int proc_palinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_palinfo_show, PDE_DATA(inode));\r\n}\r\nstatic int palinfo_add_proc(unsigned int cpu)\r\n{\r\npal_func_cpu_u_t f;\r\nstruct proc_dir_entry *cpu_dir;\r\nint j;\r\nchar cpustr[3+4+1];\r\nsprintf(cpustr, "cpu%d", cpu);\r\ncpu_dir = proc_mkdir(cpustr, palinfo_dir);\r\nif (!cpu_dir)\r\nreturn -EINVAL;\r\nf.req_cpu = cpu;\r\nfor (j=0; j < NR_PALINFO_ENTRIES; j++) {\r\nf.func_id = j;\r\nproc_create_data(palinfo_entries[j].name, 0, cpu_dir,\r\n&proc_palinfo_fops, (void *)f.value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int palinfo_del_proc(unsigned int hcpu)\r\n{\r\nchar cpustr[3+4+1];\r\nsprintf(cpustr, "cpu%d", hcpu);\r\nremove_proc_subtree(cpustr, palinfo_dir);\r\nreturn 0;\r\n}\r\nstatic int __init palinfo_init(void)\r\n{\r\nint i = 0;\r\nprintk(KERN_INFO "PAL Information Facility v%s\n", PALINFO_VERSION);\r\npalinfo_dir = proc_mkdir("pal", NULL);\r\nif (!palinfo_dir)\r\nreturn -ENOMEM;\r\ni = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "ia64/palinfo:online",\r\npalinfo_add_proc, palinfo_del_proc);\r\nif (i < 0) {\r\nremove_proc_subtree("pal", NULL);\r\nreturn i;\r\n}\r\nhp_online = i;\r\nreturn 0;\r\n}\r\nstatic void __exit palinfo_exit(void)\r\n{\r\ncpuhp_remove_state(hp_online);\r\nremove_proc_subtree("pal", NULL);\r\n}
