static void mdfld_wait_for_HS_DATA_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPI_GEN_FIFO_STAT_REG(pipe);\r\nint timeout = 0;\r\nudelay(500);\r\nwhile ((timeout < 20000) &&\r\n(REG_READ(gen_fifo_stat_reg) & DSI_FIFO_GEN_HS_DATA_FULL)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\nDRM_INFO("MIPI: HS Data FIFO was never cleared!\n");\r\n}\r\nstatic void mdfld_wait_for_HS_CTRL_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPI_GEN_FIFO_STAT_REG(pipe);\r\nint timeout = 0;\r\nudelay(500);\r\nwhile ((timeout < 20000) && (REG_READ(gen_fifo_stat_reg)\r\n& DSI_FIFO_GEN_HS_CTRL_FULL)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\nDRM_INFO("MIPI: HS CMD FIFO was never cleared!\n");\r\n}\r\nstatic void mdfld_wait_for_DPI_CTRL_FIFO(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 gen_fifo_stat_reg = MIPI_GEN_FIFO_STAT_REG(pipe);\r\nint timeout = 0;\r\nudelay(500);\r\nwhile ((timeout < 20000) && ((REG_READ(gen_fifo_stat_reg) &\r\nDPI_FIFO_EMPTY) != DPI_FIFO_EMPTY)) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\nDRM_ERROR("MIPI: DPI FIFO was never cleared\n");\r\n}\r\nstatic void mdfld_wait_for_SPL_PKG_SENT(struct drm_device *dev, u32 pipe)\r\n{\r\nu32 intr_stat_reg = MIPI_INTR_STAT_REG(pipe);\r\nint timeout = 0;\r\nudelay(500);\r\nwhile ((timeout < 20000) && (!(REG_READ(intr_stat_reg)\r\n& DSI_INTR_STATE_SPL_PKG_SENT))) {\r\nudelay(100);\r\ntimeout++;\r\n}\r\nif (timeout == 20000)\r\nDRM_ERROR("MIPI: SPL_PKT_SENT_INTERRUPT was not sent successfully!\n");\r\n}\r\nstatic void dsi_set_device_ready_state(struct drm_device *dev, int state,\r\nint pipe)\r\n{\r\nREG_FLD_MOD(MIPI_DEVICE_READY_REG(pipe), !!state, 0, 0);\r\n}\r\nstatic void dsi_set_pipe_plane_enable_state(struct drm_device *dev,\r\nint state, int pipe)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 dspcntr = dev_priv->dspcntr[pipe];\r\nu32 mipi = MIPI_PORT_EN | PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;\r\nif (pipe) {\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\n} else\r\nmipi &= (~0x03);\r\nif (state) {\r\nREG_WRITE(pipeconf_reg, BIT(31));\r\nif (REG_BIT_WAIT(pipeconf_reg, 1, 30))\r\ndev_err(&dev->pdev->dev, "%s: Pipe enable timeout\n",\r\n__func__);\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\n} else {\r\nu32 dspbase_reg = pipe ? MDFLD_DSPCBASE : MRST_DSPABASE;\r\nREG_FLD_MOD(MIPI_DEVICE_READY_REG(pipe), 2, 2, 1);\r\nREG_READ(MIPI_DEVICE_READY_REG(pipe));\r\nREG_FLD_MOD(MIPI_PORT_CONTROL(pipe), 0, 16, 16);\r\nREG_READ(MIPI_PORT_CONTROL(pipe));\r\nREG_FLD_MOD(dspcntr_reg, 0, 31, 31);\r\nREG_WRITE(dspbase_reg, REG_READ(dspbase_reg));\r\nREG_READ(dspbase_reg);\r\nREG_FLD_MOD(pipeconf_reg, 0, 31, 31);\r\nif (REG_BIT_WAIT(pipeconf_reg, 0, 30))\r\ndev_err(&dev->pdev->dev, "%s: Pipe disable timeout\n",\r\n__func__);\r\nif (REG_BIT_WAIT(MIPI_GEN_FIFO_STAT_REG(pipe), 1, 28))\r\ndev_err(&dev->pdev->dev, "%s: FIFO not empty\n",\r\n__func__);\r\n}\r\n}\r\nstatic void mdfld_dsi_configure_down(struct mdfld_dsi_encoder *dsi_encoder,\r\nint pipe)\r\n{\r\nstruct mdfld_dsi_dpi_output *dpi_output =\r\nMDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!dev_priv->dpi_panel_on[pipe]) {\r\ndev_err(dev->dev, "DPI panel is already off\n");\r\nreturn;\r\n}\r\ntc35876x_toshiba_bridge_panel_off(dev);\r\ntc35876x_set_bridge_reset_state(dev, 1);\r\ndsi_set_pipe_plane_enable_state(dev, 0, pipe);\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\ndsi_set_device_ready_state(dev, 0, pipe);\r\n}\r\nstatic void mdfld_dsi_configure_up(struct mdfld_dsi_encoder *dsi_encoder,\r\nint pipe)\r\n{\r\nstruct mdfld_dsi_dpi_output *dpi_output =\r\nMDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv->dpi_panel_on[pipe]) {\r\ndev_err(dev->dev, "DPI panel is already on\n");\r\nreturn;\r\n}\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\ndsi_set_device_ready_state(dev, 0, pipe);\r\ndsi_set_device_ready_state(dev, 1, pipe);\r\ntc35876x_set_bridge_reset_state(dev, 0);\r\ntc35876x_configure_lvds_bridge(dev);\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\ndsi_set_pipe_plane_enable_state(dev, 1, pipe);\r\n}\r\nstatic void mdfld_dsi_tpo_ic_init(struct mdfld_dsi_config *dsi_config, u32 pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nu32 dcsChannelNumber = dsi_config->channel_num;\r\nu32 gen_data_reg = MIPI_HS_GEN_DATA_REG(pipe);\r\nu32 gen_ctrl_reg = MIPI_HS_GEN_CTRL_REG(pipe);\r\nu32 gen_ctrl_val = GEN_LONG_WRITE;\r\nDRM_INFO("Enter mrst init TPO MIPI display.\n");\r\ngen_ctrl_val |= dcsChannelNumber << DCS_CHANNEL_NUMBER_POS;\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00008036);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x02 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5af0);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5af1);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x005a5afc);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x770000b7);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000044);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x05 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000a0ab6);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x081010f2);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x4a070708);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000000c5);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x024003f8);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x01030a04);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x0e020220);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000004);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x0d << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x398fc3e2);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x0000916f);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x06 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000000b0);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x02 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x240242f4);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x78ee2002);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2a071050);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x507fee10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x10300710);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x14 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x19fe07ba);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x101c0a31);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000010);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x28ff07bb);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x24280a31);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000034);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x09 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535d05fb);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1b1a2130);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x221e180e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x131d2120);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535d0508);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1c1a2131);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x231f160d);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x111b2220);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x535c2008);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1f1d2433);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2c251a10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2c34372d);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000023);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x31 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x525c0bfa);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1c1c232f);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x2623190e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x18212625);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x545d0d0e);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1e1d2333);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x26231a10);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x1a222725);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x545d280f);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x21202635);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x31292013);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x31393d33);\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x00000029);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x31 << WORD_COUNTS_POS));\r\nmdfld_wait_for_HS_DATA_FIFO(dev, pipe);\r\nREG_WRITE(gen_data_reg, 0x000100f7);\r\nmdfld_wait_for_HS_CTRL_FIFO(dev, pipe);\r\nREG_WRITE(gen_ctrl_reg, gen_ctrl_val | (0x03 << WORD_COUNTS_POS));\r\n}\r\nstatic u16 mdfld_dsi_dpi_to_byte_clock_count(int pixel_clock_count,\r\nint num_lane, int bpp)\r\n{\r\nreturn (u16)((pixel_clock_count * bpp) / (num_lane * 8));\r\n}\r\nint mdfld_dsi_dpi_timing_calculation(struct drm_display_mode *mode,\r\nstruct mdfld_dsi_dpi_timing *dpi_timing,\r\nint num_lane, int bpp)\r\n{\r\nint pclk_hsync, pclk_hfp, pclk_hbp, pclk_hactive;\r\nint pclk_vsync, pclk_vfp, pclk_vbp;\r\npclk_hactive = mode->hdisplay;\r\npclk_hfp = mode->hsync_start - mode->hdisplay;\r\npclk_hsync = mode->hsync_end - mode->hsync_start;\r\npclk_hbp = mode->htotal - mode->hsync_end;\r\npclk_vfp = mode->vsync_start - mode->vdisplay;\r\npclk_vsync = mode->vsync_end - mode->vsync_start;\r\npclk_vbp = mode->vtotal - mode->vsync_end;\r\ndpi_timing->hsync_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_hsync, num_lane, bpp);\r\ndpi_timing->hbp_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_hbp, num_lane, bpp);\r\ndpi_timing->hfp_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_hfp, num_lane, bpp);\r\ndpi_timing->hactive_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_hactive, num_lane, bpp);\r\ndpi_timing->vsync_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_vsync, num_lane, bpp);\r\ndpi_timing->vbp_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_vbp, num_lane, bpp);\r\ndpi_timing->vfp_count = mdfld_dsi_dpi_to_byte_clock_count(\r\npclk_vfp, num_lane, bpp);\r\nreturn 0;\r\n}\r\nvoid mdfld_dsi_dpi_controller_init(struct mdfld_dsi_config *dsi_config,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nint lane_count = dsi_config->lane_count;\r\nstruct mdfld_dsi_dpi_timing dpi_timing;\r\nstruct drm_display_mode *mode = dsi_config->mode;\r\nu32 val;\r\nREG_FLD_MOD(MIPI_DEVICE_READY_REG(pipe), 0, 0, 0);\r\nREG_WRITE(MIPI_CTRL_REG(pipe), 0x00000018);\r\nREG_WRITE(MIPI_INTR_EN_REG(pipe), 0xffffffff);\r\nval = lane_count;\r\nval |= dsi_config->channel_num << DSI_DPI_VIRT_CHANNEL_OFFSET;\r\nswitch (dsi_config->bpp) {\r\ncase 16:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB565;\r\nbreak;\r\ncase 18:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB666;\r\nbreak;\r\ncase 24:\r\nval |= DSI_DPI_COLOR_FORMAT_RGB888;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported color format, bpp = %d\n",\r\ndsi_config->bpp);\r\n}\r\nREG_WRITE(MIPI_DSI_FUNC_PRG_REG(pipe), val);\r\nREG_WRITE(MIPI_HS_TX_TIMEOUT_REG(pipe),\r\n(mode->vtotal * mode->htotal * dsi_config->bpp /\r\n(8 * lane_count)) & DSI_HS_TX_TIMEOUT_MASK);\r\nREG_WRITE(MIPI_LP_RX_TIMEOUT_REG(pipe),\r\n0xffff & DSI_LP_RX_TIMEOUT_MASK);\r\nREG_WRITE(MIPI_TURN_AROUND_TIMEOUT_REG(pipe),\r\n0x14 & DSI_TURN_AROUND_TIMEOUT_MASK);\r\nREG_WRITE(MIPI_DEVICE_RESET_TIMER_REG(pipe),\r\n0xffff & DSI_RESET_TIMER_MASK);\r\nREG_WRITE(MIPI_DPI_RESOLUTION_REG(pipe),\r\nmode->vdisplay << 16 | mode->hdisplay);\r\nmdfld_dsi_dpi_timing_calculation(mode, &dpi_timing,\r\ndsi_config->lane_count, dsi_config->bpp);\r\nREG_WRITE(MIPI_HSYNC_COUNT_REG(pipe),\r\ndpi_timing.hsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HBP_COUNT_REG(pipe),\r\ndpi_timing.hbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HFP_COUNT_REG(pipe),\r\ndpi_timing.hfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HACTIVE_COUNT_REG(pipe),\r\ndpi_timing.hactive_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VSYNC_COUNT_REG(pipe),\r\ndpi_timing.vsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VBP_COUNT_REG(pipe),\r\ndpi_timing.vbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VFP_COUNT_REG(pipe),\r\ndpi_timing.vfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HIGH_LOW_SWITCH_COUNT_REG(pipe), 0x46);\r\nREG_WRITE(MIPI_INIT_COUNT_REG(pipe), 0x000007d0);\r\nval = dsi_config->video_mode | DSI_DPI_COMPLETE_LAST_LINE;\r\nREG_WRITE(MIPI_VIDEO_MODE_FORMAT_REG(pipe), val);\r\nREG_WRITE(MIPI_EOT_DISABLE_REG(pipe), 0x00000000);\r\nREG_WRITE(MIPI_LP_BYTECLK_REG(pipe), 0x00000004);\r\nif (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nREG_WRITE(MIPI_DPHY_PARAM_REG(pipe), 0x2A0c6008);\r\nelse\r\nREG_WRITE(MIPI_DPHY_PARAM_REG(pipe), 0x150c3408);\r\nREG_WRITE(MIPI_CLK_LANE_SWITCH_TIME_CNT_REG(pipe), (0xa << 16) | 0x14);\r\nif (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\ntc35876x_set_bridge_reset_state(dev, 0);\r\nREG_FLD_MOD(MIPI_DEVICE_READY_REG(pipe), 1, 0, 0);\r\n}\r\nvoid mdfld_dsi_dpi_turn_on(struct mdfld_dsi_dpi_output *output, int pipe)\r\n{\r\nstruct drm_device *dev = output->dev;\r\nif (REG_READ(MIPI_INTR_STAT_REG(pipe)) & DSI_INTR_STATE_SPL_PKG_SENT)\r\nREG_WRITE(MIPI_INTR_STAT_REG(pipe),\r\nDSI_INTR_STATE_SPL_PKG_SENT);\r\nREG_WRITE(MIPI_DPI_CONTROL_REG(pipe), DSI_DPI_CTRL_HS_TURN_ON);\r\nmdfld_wait_for_SPL_PKG_SENT(dev, pipe);\r\nif (REG_READ(MIPI_INTR_STAT_REG(pipe)) & DSI_INTR_STATE_SPL_PKG_SENT)\r\nREG_WRITE(MIPI_INTR_STAT_REG(pipe),\r\nDSI_INTR_STATE_SPL_PKG_SENT);\r\noutput->panel_on = 1;\r\n}\r\nstatic void mdfld_dsi_dpi_shut_down(struct mdfld_dsi_dpi_output *output,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = output->dev;\r\nif ((!output->panel_on) || output->first_boot) {\r\noutput->first_boot = 0;\r\nreturn;\r\n}\r\nmdfld_wait_for_DPI_CTRL_FIFO(dev, pipe);\r\nif (REG_READ(MIPI_INTR_STAT_REG(pipe)) & DSI_INTR_STATE_SPL_PKG_SENT)\r\nREG_WRITE(MIPI_INTR_STAT_REG(pipe),\r\nDSI_INTR_STATE_SPL_PKG_SENT);\r\nif (REG_READ(MIPI_DPI_CONTROL_REG(pipe)) == DSI_DPI_CTRL_HS_SHUTDOWN)\r\ngoto shutdown_out;\r\nREG_WRITE(MIPI_DPI_CONTROL_REG(pipe), DSI_DPI_CTRL_HS_SHUTDOWN);\r\nshutdown_out:\r\noutput->panel_on = 0;\r\noutput->first_boot = 0;\r\n}\r\nstatic void mdfld_dsi_dpi_set_power(struct drm_encoder *encoder, bool on)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = mdfld_dsi_encoder(encoder);\r\nstruct mdfld_dsi_dpi_output *dpi_output =\r\nMDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nint pipe = mdfld_dsi_encoder_get_pipe(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nif (on) {\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID)\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\nelse if (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nmdfld_dsi_configure_up(dsi_encoder, pipe);\r\nelse {\r\nREG_WRITE(MIPI_PORT_CONTROL(pipe),\r\nREG_READ(MIPI_PORT_CONTROL(pipe)) | BIT(31));\r\nREG_READ(MIPI_PORT_CONTROL(pipe));\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\nmdfld_dsi_tpo_ic_init(dsi_config, pipe);\r\n}\r\ndev_priv->dpi_panel_on[pipe] = true;\r\n} else {\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID)\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\nelse if (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nmdfld_dsi_configure_down(dsi_encoder, pipe);\r\nelse {\r\nmdfld_dsi_dpi_shut_down(dpi_output, pipe);\r\nREG_WRITE(MIPI_PORT_CONTROL(pipe),\r\nREG_READ(MIPI_PORT_CONTROL(pipe)) & ~BIT(31));\r\nREG_READ(MIPI_PORT_CONTROL(pipe));\r\n}\r\ndev_priv->dpi_panel_on[pipe] = false;\r\n}\r\ngma_power_end(dev);\r\n}\r\nvoid mdfld_dsi_dpi_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nmdfld_dsi_dpi_set_power(encoder, mode == DRM_MODE_DPMS_ON);\r\n}\r\nbool mdfld_dsi_dpi_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = mdfld_dsi_encoder(encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_display_mode *fixed_mode = dsi_config->fixed_mode;\r\nif (fixed_mode) {\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\n}\r\nreturn true;\r\n}\r\nvoid mdfld_dsi_dpi_prepare(struct drm_encoder *encoder)\r\n{\r\nmdfld_dsi_dpi_set_power(encoder, false);\r\n}\r\nvoid mdfld_dsi_dpi_commit(struct drm_encoder *encoder)\r\n{\r\nmdfld_dsi_dpi_set_power(encoder, true);\r\n}\r\nstatic void mipi_set_properties(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nREG_WRITE(MIPI_CTRL_REG(pipe), 0x00000018);\r\nREG_WRITE(MIPI_INTR_EN_REG(pipe), 0xffffffff);\r\nREG_WRITE(MIPI_HS_TX_TIMEOUT_REG(pipe), 0xffffff);\r\nREG_WRITE(MIPI_LP_RX_TIMEOUT_REG(pipe), 0xffffff);\r\nREG_WRITE(MIPI_TURN_AROUND_TIMEOUT_REG(pipe), 0x14);\r\nREG_WRITE(MIPI_DEVICE_RESET_TIMER_REG(pipe), 0xff);\r\nREG_WRITE(MIPI_HIGH_LOW_SWITCH_COUNT_REG(pipe), 0x25);\r\nREG_WRITE(MIPI_INIT_COUNT_REG(pipe), 0xf0);\r\nREG_WRITE(MIPI_EOT_DISABLE_REG(pipe), 0x00000000);\r\nREG_WRITE(MIPI_LP_BYTECLK_REG(pipe), 0x00000004);\r\nREG_WRITE(MIPI_DBI_BW_CTRL_REG(pipe), 0x00000820);\r\nREG_WRITE(MIPI_CLK_LANE_SWITCH_TIME_CNT_REG(pipe), (0xa << 16) | 0x14);\r\n}\r\nstatic void mdfld_mipi_set_video_timing(struct mdfld_dsi_config *dsi_config,\r\nint pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct mdfld_dsi_dpi_timing dpi_timing;\r\nstruct drm_display_mode *mode = dsi_config->mode;\r\nmdfld_dsi_dpi_timing_calculation(mode, &dpi_timing,\r\ndsi_config->lane_count,\r\ndsi_config->bpp);\r\nREG_WRITE(MIPI_DPI_RESOLUTION_REG(pipe),\r\nmode->vdisplay << 16 | mode->hdisplay);\r\nREG_WRITE(MIPI_HSYNC_COUNT_REG(pipe),\r\ndpi_timing.hsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HBP_COUNT_REG(pipe),\r\ndpi_timing.hbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HFP_COUNT_REG(pipe),\r\ndpi_timing.hfp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_HACTIVE_COUNT_REG(pipe),\r\ndpi_timing.hactive_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VSYNC_COUNT_REG(pipe),\r\ndpi_timing.vsync_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VBP_COUNT_REG(pipe),\r\ndpi_timing.vbp_count & DSI_DPI_TIMING_MASK);\r\nREG_WRITE(MIPI_VFP_COUNT_REG(pipe),\r\ndpi_timing.vfp_count & DSI_DPI_TIMING_MASK);\r\n}\r\nstatic void mdfld_mipi_config(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nint lane_count = dsi_config->lane_count;\r\nif (pipe) {\r\nREG_WRITE(MIPI_PORT_CONTROL(0), 0x00000002);\r\nREG_WRITE(MIPI_PORT_CONTROL(2), 0x80000000);\r\n} else {\r\nREG_WRITE(MIPI_PORT_CONTROL(0), 0x80010000);\r\nREG_WRITE(MIPI_PORT_CONTROL(2), 0x00);\r\n}\r\nREG_WRITE(MIPI_DPHY_PARAM_REG(pipe), 0x150A600F);\r\nREG_WRITE(MIPI_VIDEO_MODE_FORMAT_REG(pipe), 0x0000000F);\r\nREG_WRITE(MIPI_DSI_FUNC_PRG_REG(pipe), 0x00000200 | lane_count);\r\nmdfld_mipi_set_video_timing(dsi_config, pipe);\r\n}\r\nstatic void mdfld_set_pipe_timing(struct mdfld_dsi_config *dsi_config, int pipe)\r\n{\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_display_mode *mode = dsi_config->mode;\r\nREG_WRITE(HTOTAL_A, ((mode->htotal - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(HBLANK_A, ((mode->htotal - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(HSYNC_A,\r\n((mode->hsync_end - 1) << 16) | (mode->hsync_start - 1));\r\nREG_WRITE(VTOTAL_A, ((mode->vtotal - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(VBLANK_A, ((mode->vtotal - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(VSYNC_A,\r\n((mode->vsync_end - 1) << 16) | (mode->vsync_start - 1));\r\nREG_WRITE(PIPEASRC,\r\n((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\r\n}\r\nvoid mdfld_dsi_dpi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct mdfld_dsi_encoder *dsi_encoder = mdfld_dsi_encoder(encoder);\r\nstruct mdfld_dsi_dpi_output *dpi_output =\r\nMDFLD_DSI_DPI_OUTPUT(dsi_encoder);\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_encoder_get_config(dsi_encoder);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = mdfld_dsi_encoder_get_pipe(dsi_encoder);\r\nu32 pipeconf_reg = PIPEACONF;\r\nu32 dspcntr_reg = DSPACNTR;\r\nu32 pipeconf, dspcntr;\r\nu32 mipi = MIPI_PORT_EN | PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;\r\nif (WARN_ON(pipe < 0))\r\nreturn;\r\npipeconf = dev_priv->pipeconf[pipe];\r\ndspcntr = dev_priv->dspcntr[pipe];\r\nif (pipe) {\r\npipeconf_reg = PIPECCONF;\r\ndspcntr_reg = DSPCCNTR;\r\n} else {\r\nif (mdfld_get_panel_type(dev, pipe) == TC35876X)\r\nmipi &= (~0x03);\r\nelse\r\nmipi |= 2;\r\n}\r\nif (!gma_power_begin(dev, true))\r\nreturn;\r\nif (mdfld_get_panel_type(dev, pipe) == TC35876X) {\r\ntc35876x_set_bridge_reset_state(dev, 0);\r\ntc35876x_toshiba_bridge_panel_on(dev);\r\nudelay(100);\r\nREG_WRITE(MRST_DPLL_A, 0x00);\r\nREG_WRITE(MRST_FPA0, 0xC1);\r\nREG_WRITE(MRST_DPLL_A, 0x00800000);\r\nudelay(500);\r\nREG_WRITE(MRST_DPLL_A, 0x80800000);\r\nif (REG_BIT_WAIT(pipeconf_reg, 1, 29))\r\ndev_err(&dev->pdev->dev, "%s: DSI PLL lock timeout\n",\r\n__func__);\r\nREG_WRITE(MIPI_DPHY_PARAM_REG(pipe), 0x2A0c6008);\r\nmipi_set_properties(dsi_config, pipe);\r\nmdfld_mipi_config(dsi_config, pipe);\r\nmdfld_set_pipe_timing(dsi_config, pipe);\r\nREG_WRITE(DSPABASE, 0x00);\r\nREG_WRITE(DSPASIZE,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(DSPACNTR, 0x98000000);\r\nREG_WRITE(DSPASURF, 0x00);\r\nREG_WRITE(VGACNTRL, 0x80000000);\r\nREG_WRITE(DEVICE_READY_REG, 0x00000001);\r\nREG_WRITE(MIPI_PORT_CONTROL(pipe), 0x80810000);\r\n} else {\r\nREG_WRITE(MIPI_PORT_CONTROL(pipe), mipi);\r\n}\r\nREG_READ(MIPI_PORT_CONTROL(pipe));\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID) {\r\n} else if (mdfld_get_panel_type(dev, pipe) == TC35876X) {\r\nmdfld_dsi_dpi_controller_init(dsi_config, pipe);\r\ntc35876x_configure_lvds_bridge(dev);\r\ndev_priv->dpi_panel_on[pipe] = true;\r\n} else {\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\n}\r\nREG_WRITE(pipeconf_reg, pipeconf);\r\nREG_READ(pipeconf_reg);\r\nREG_WRITE(dspcntr_reg, dspcntr);\r\nREG_READ(dspcntr_reg);\r\nmsleep(20);\r\nif (mdfld_get_panel_type(dev, pipe) == TMD_VID) {\r\n} else if (mdfld_get_panel_type(dev, pipe) == TC35876X) {\r\nmdfld_dsi_dpi_turn_on(dpi_output, pipe);\r\n} else {\r\nmdfld_dsi_tpo_ic_init(dsi_config, pipe);\r\nmdfld_dsi_brightness_init(dsi_config, pipe);\r\n}\r\ngma_power_end(dev);\r\n}\r\nstruct mdfld_dsi_encoder *mdfld_dsi_dpi_init(struct drm_device *dev,\r\nstruct mdfld_dsi_connector *dsi_connector,\r\nconst struct panel_funcs *p_funcs)\r\n{\r\nstruct mdfld_dsi_dpi_output *dpi_output = NULL;\r\nstruct mdfld_dsi_config *dsi_config;\r\nstruct drm_connector *connector = NULL;\r\nstruct drm_encoder *encoder = NULL;\r\nint pipe;\r\nu32 data;\r\nint ret;\r\npipe = dsi_connector->pipe;\r\nif (mdfld_get_panel_type(dev, pipe) != TC35876X) {\r\ndsi_config = mdfld_dsi_get_config(dsi_connector);\r\nif (p_funcs->reset) {\r\nret = p_funcs->reset(pipe);\r\nif (ret) {\r\nDRM_ERROR("Panel %d hard-reset failed\n", pipe);\r\nreturn NULL;\r\n}\r\n}\r\nif (p_funcs->drv_ic_init)\r\np_funcs->drv_ic_init(dsi_config, pipe);\r\nret = mdfld_dsi_get_power_mode(dsi_config, &data, false);\r\nif (ret) {\r\nDRM_ERROR("Panel %d get power mode failed\n", pipe);\r\ndsi_connector->status = connector_status_disconnected;\r\n} else {\r\nDRM_INFO("pipe %d power mode 0x%x\n", pipe, data);\r\ndsi_connector->status = connector_status_connected;\r\n}\r\n}\r\ndpi_output = kzalloc(sizeof(struct mdfld_dsi_dpi_output), GFP_KERNEL);\r\nif (!dpi_output) {\r\nDRM_ERROR("No memory\n");\r\nreturn NULL;\r\n}\r\ndpi_output->panel_on = 0;\r\ndpi_output->dev = dev;\r\nif (mdfld_get_panel_type(dev, pipe) != TC35876X)\r\ndpi_output->p_funcs = p_funcs;\r\ndpi_output->first_boot = 1;\r\ndsi_config = mdfld_dsi_get_config(dsi_connector);\r\nconnector = &dsi_connector->base.base;\r\nencoder = &dpi_output->base.base.base;\r\ndrm_encoder_init(dev,\r\nencoder,\r\np_funcs->encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS, NULL);\r\ndrm_encoder_helper_add(encoder,\r\np_funcs->encoder_helper_funcs);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nif (dsi_connector->pipe) {\r\nencoder->possible_crtcs = (1 << 2);\r\nencoder->possible_clones = (1 << 1);\r\n} else {\r\nencoder->possible_crtcs = (1 << 0);\r\nencoder->possible_clones = (1 << 0);\r\n}\r\ndsi_connector->base.encoder = &dpi_output->base.base;\r\nreturn &dpi_output->base;\r\n}
