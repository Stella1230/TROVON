static void wacom_handle_model_response(struct wacom *wacom)\r\n{\r\nint major_v, minor_v, r = 0;\r\nchar *p;\r\np = strrchr(wacom->data, 'V');\r\nif (p)\r\nr = sscanf(p + 1, "%u.%u", &major_v, &minor_v);\r\nif (r != 2)\r\nmajor_v = minor_v = 0;\r\nswitch (wacom->data[2] << 8 | wacom->data[3]) {\r\ncase MODEL_CINTIQ:\r\ncase MODEL_CINTIQ2:\r\nif ((wacom->data[2] << 8 | wacom->data[3]) == MODEL_CINTIQ) {\r\nwacom->dev->name = "Wacom Cintiq";\r\nwacom->dev->id.version = MODEL_CINTIQ;\r\n} else {\r\nwacom->dev->name = "Wacom Cintiq II";\r\nwacom->dev->id.version = MODEL_CINTIQ2;\r\n}\r\nwacom->res_x = 508;\r\nwacom->res_y = 508;\r\nswitch (wacom->data[5] << 8 | wacom->data[6]) {\r\ncase 0x3731:\r\nwacom->res_x = 2540;\r\nwacom->res_y = 2540;\r\ncase 0x3535:\r\ncase 0x3830:\r\nwacom->extra_z_bits = 2;\r\n}\r\nwacom->flags = F_COVERS_SCREEN;\r\nbreak;\r\ncase MODEL_PENPARTNER:\r\nwacom->dev->name = "Wacom Penpartner";\r\nwacom->dev->id.version = MODEL_PENPARTNER;\r\nwacom->res_x = 1000;\r\nwacom->res_y = 1000;\r\nbreak;\r\ncase MODEL_GRAPHIRE:\r\nwacom->dev->name = "Wacom Graphire";\r\nwacom->dev->id.version = MODEL_GRAPHIRE;\r\nwacom->res_x = 1016;\r\nwacom->res_y = 1016;\r\nwacom->max_x = 5103;\r\nwacom->max_y = 3711;\r\nwacom->extra_z_bits = 2;\r\nwacom->eraser_mask = 0x08;\r\nwacom->flags = F_HAS_STYLUS2 | F_HAS_SCROLLWHEEL;\r\nbreak;\r\ncase MODEL_DIGITIZER_II:\r\nwacom->dev->name = "Wacom Digitizer II";\r\nwacom->dev->id.version = MODEL_DIGITIZER_II;\r\nif (major_v == 1 && minor_v <= 2)\r\nwacom->extra_z_bits = 0;\r\nbreak;\r\ndefault:\r\ndev_err(&wacom->dev->dev, "Unsupported Wacom model %s\n",\r\nwacom->data);\r\nwacom->result = -ENODEV;\r\nreturn;\r\n}\r\ndev_info(&wacom->dev->dev, "%s tablet, version %u.%u\n",\r\nwacom->dev->name, major_v, minor_v);\r\n}\r\nstatic void wacom_handle_configuration_response(struct wacom *wacom)\r\n{\r\nint r, skip;\r\ndev_dbg(&wacom->dev->dev, "Configuration string: %s\n", wacom->data);\r\nr = sscanf(wacom->data, "~R%x,%u,%u,%u,%u", &skip, &skip, &skip,\r\n&wacom->res_x, &wacom->res_y);\r\nif (r != 5)\r\ndev_warn(&wacom->dev->dev, "could not get resolution\n");\r\n}\r\nstatic void wacom_handle_coordinates_response(struct wacom *wacom)\r\n{\r\nint r;\r\ndev_dbg(&wacom->dev->dev, "Coordinates string: %s\n", wacom->data);\r\nr = sscanf(wacom->data, "~C%u,%u", &wacom->max_x, &wacom->max_y);\r\nif (r != 2)\r\ndev_warn(&wacom->dev->dev, "could not get max coordinates\n");\r\n}\r\nstatic void wacom_handle_response(struct wacom *wacom)\r\n{\r\nif (wacom->data[0] != '~' || wacom->data[1] != wacom->expect) {\r\ndev_err(&wacom->dev->dev,\r\n"Wacom got an unexpected response: %s\n", wacom->data);\r\nwacom->result = -EIO;\r\n} else {\r\nwacom->result = 0;\r\nswitch (wacom->data[1]) {\r\ncase '#':\r\nwacom_handle_model_response(wacom);\r\nbreak;\r\ncase 'R':\r\nwacom_handle_configuration_response(wacom);\r\nbreak;\r\ncase 'C':\r\nwacom_handle_coordinates_response(wacom);\r\nbreak;\r\n}\r\n}\r\ncomplete(&wacom->cmd_done);\r\n}\r\nstatic void wacom_handle_packet(struct wacom *wacom)\r\n{\r\nu8 in_proximity_p, stylus_p, button;\r\nunsigned int tool;\r\nint x, y, z;\r\nin_proximity_p = wacom->data[0] & 0x40;\r\nstylus_p = wacom->data[0] & 0x20;\r\nbutton = (wacom->data[3] & 0x78) >> 3;\r\nx = (wacom->data[0] & 3) << 14 | wacom->data[1]<<7 | wacom->data[2];\r\ny = (wacom->data[3] & 3) << 14 | wacom->data[4]<<7 | wacom->data[5];\r\nif (in_proximity_p && stylus_p) {\r\nz = wacom->data[6] & 0x7f;\r\nif (wacom->extra_z_bits >= 1)\r\nz = z << 1 | (wacom->data[3] & 0x4) >> 2;\r\nif (wacom->extra_z_bits > 1)\r\nz = z << 1 | (wacom->data[0] & 0x4) >> 2;\r\nz = z ^ (0x40 << wacom->extra_z_bits);\r\n} else {\r\nz = -1;\r\n}\r\nif (stylus_p)\r\ntool = (button & wacom->eraser_mask) ? ERASER : STYLUS;\r\nelse\r\ntool = CURSOR;\r\nif (tool != wacom->tool && wacom->tool != 0) {\r\ninput_report_key(wacom->dev, tools[wacom->tool].input_id, 0);\r\ninput_sync(wacom->dev);\r\n}\r\nwacom->tool = tool;\r\ninput_report_key(wacom->dev, tools[tool].input_id, in_proximity_p);\r\ninput_report_abs(wacom->dev, ABS_MISC,\r\nin_proximity_p ? tools[tool].device_id : 0);\r\ninput_report_abs(wacom->dev, ABS_X, x);\r\ninput_report_abs(wacom->dev, ABS_Y, y);\r\ninput_report_abs(wacom->dev, ABS_PRESSURE, z);\r\nif (stylus_p) {\r\ninput_report_key(wacom->dev, BTN_TOUCH, button & 1);\r\ninput_report_key(wacom->dev, BTN_STYLUS, button & 2);\r\ninput_report_key(wacom->dev, BTN_STYLUS2, button & 4);\r\n} else {\r\ninput_report_key(wacom->dev, BTN_LEFT, button & 1);\r\ninput_report_key(wacom->dev, BTN_RIGHT, button & 2);\r\ninput_report_key(wacom->dev, BTN_MIDDLE, button & 4);\r\nz = (wacom->data[6] & 0x30) >> 4;\r\nif (wacom->data[6] & 0x40)\r\nz = -z;\r\ninput_report_rel(wacom->dev, REL_WHEEL, z);\r\n}\r\ninput_sync(wacom->dev);\r\n}\r\nstatic void wacom_clear_data_buf(struct wacom *wacom)\r\n{\r\nmemset(wacom->data, 0, DATA_SIZE);\r\nwacom->idx = 0;\r\n}\r\nstatic irqreturn_t wacom_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int flags)\r\n{\r\nstruct wacom *wacom = serio_get_drvdata(serio);\r\nif (data & 0x80)\r\nwacom->idx = 0;\r\nif (data == '\r' && !(wacom->data[0] & 0x80)) {\r\nwacom_handle_response(wacom);\r\nwacom_clear_data_buf(wacom);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (wacom->idx > (DATA_SIZE - 2)) {\r\ndev_dbg(&wacom->dev->dev,\r\n"throwing away %d bytes of garbage\n", wacom->idx);\r\nwacom_clear_data_buf(wacom);\r\n}\r\nwacom->data[wacom->idx++] = data;\r\nif (wacom->idx == PACKET_LENGTH && (wacom->data[0] & 0x80)) {\r\nwacom_handle_packet(wacom);\r\nwacom_clear_data_buf(wacom);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wacom_disconnect(struct serio *serio)\r\n{\r\nstruct wacom *wacom = serio_get_drvdata(serio);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\ninput_unregister_device(wacom->dev);\r\nkfree(wacom);\r\n}\r\nstatic int wacom_send(struct serio *serio, const u8 *command)\r\n{\r\nint err = 0;\r\nfor (; !err && *command; command++)\r\nerr = serio_write(serio, *command);\r\nreturn err;\r\n}\r\nstatic int wacom_send_setup_string(struct wacom *wacom, struct serio *serio)\r\n{\r\nconst u8 *cmd;\r\nswitch (wacom->dev->id.version) {\r\ncase MODEL_CINTIQ:\r\ncmd = COMMAND_ORIGIN_IN_UPPER_LEFT\r\nCOMMAND_TRANSMIT_AT_MAX_RATE\r\nCOMMAND_ENABLE_CONTINUOUS_MODE\r\nCOMMAND_START_SENDING_PACKETS;\r\nbreak;\r\ncase MODEL_PENPARTNER:\r\ncmd = COMMAND_ENABLE_PRESSURE_MODE\r\nCOMMAND_START_SENDING_PACKETS;\r\nbreak;\r\ndefault:\r\ncmd = COMMAND_MULTI_MODE_INPUT\r\nCOMMAND_ORIGIN_IN_UPPER_LEFT\r\nCOMMAND_ENABLE_ALL_MACRO_BUTTONS\r\nCOMMAND_DISABLE_GROUP_1_MACRO_BUTTONS\r\nCOMMAND_TRANSMIT_AT_MAX_RATE\r\nCOMMAND_DISABLE_INCREMENTAL_MODE\r\nCOMMAND_ENABLE_CONTINUOUS_MODE\r\nCOMMAND_Z_FILTER\r\nCOMMAND_START_SENDING_PACKETS;\r\nbreak;\r\n}\r\nreturn wacom_send(serio, cmd);\r\n}\r\nstatic int wacom_send_and_wait(struct wacom *wacom, struct serio *serio,\r\nconst u8 *cmd, const char *desc)\r\n{\r\nint err;\r\nunsigned long u;\r\nwacom->expect = cmd[1];\r\ninit_completion(&wacom->cmd_done);\r\nerr = wacom_send(serio, cmd);\r\nif (err)\r\nreturn err;\r\nu = wait_for_completion_timeout(&wacom->cmd_done, HZ);\r\nif (u == 0) {\r\nwacom_handle_response(wacom);\r\n}\r\nwacom->expect = 0;\r\nreturn wacom->result;\r\n}\r\nstatic int wacom_setup(struct wacom *wacom, struct serio *serio)\r\n{\r\nint err;\r\nerr = wacom_send_and_wait(wacom, serio, REQUEST_MODEL_AND_ROM_VERSION,\r\n"model and version");\r\nif (err)\r\nreturn err;\r\nif (!(wacom->res_x && wacom->res_y)) {\r\nerr = wacom_send_and_wait(wacom, serio,\r\nREQUEST_CONFIGURATION_STRING,\r\n"configuration string");\r\nif (err)\r\nreturn err;\r\n}\r\nif (!(wacom->max_x && wacom->max_y)) {\r\nerr = wacom_send_and_wait(wacom, serio,\r\nREQUEST_MAX_COORDINATES,\r\n"coordinates string");\r\nif (err)\r\nreturn err;\r\n}\r\nreturn wacom_send_setup_string(wacom, serio);\r\n}\r\nstatic int wacom_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct wacom *wacom;\r\nstruct input_dev *input_dev;\r\nint err = -ENOMEM;\r\nwacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!wacom || !input_dev)\r\ngoto free_device;\r\nwacom->dev = input_dev;\r\nwacom->extra_z_bits = 1;\r\nwacom->eraser_mask = 0x04;\r\nwacom->tool = wacom->idx = 0;\r\nsnprintf(wacom->phys, sizeof(wacom->phys), "%s/input0", serio->phys);\r\ninput_dev->phys = wacom->phys;\r\ninput_dev->id.bustype = BUS_RS232;\r\ninput_dev->id.vendor = SERIO_WACOM_IV;\r\ninput_dev->id.product = serio->id.extra;\r\ninput_dev->dev.parent = &serio->dev;\r\ninput_dev->evbit[0] =\r\nBIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) | BIT_MASK(EV_REL);\r\nset_bit(ABS_MISC, input_dev->absbit);\r\nset_bit(BTN_TOOL_PEN, input_dev->keybit);\r\nset_bit(BTN_TOOL_RUBBER, input_dev->keybit);\r\nset_bit(BTN_TOOL_MOUSE, input_dev->keybit);\r\nset_bit(BTN_TOUCH, input_dev->keybit);\r\nset_bit(BTN_STYLUS, input_dev->keybit);\r\nset_bit(BTN_LEFT, input_dev->keybit);\r\nset_bit(BTN_RIGHT, input_dev->keybit);\r\nset_bit(BTN_MIDDLE, input_dev->keybit);\r\nserio_set_drvdata(serio, wacom);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto free_device;\r\nerr = wacom_setup(wacom, serio);\r\nif (err)\r\ngoto close_serio;\r\nset_bit(INPUT_PROP_DIRECT, input_dev->propbit);\r\nif (!(wacom->flags & F_COVERS_SCREEN))\r\n__set_bit(INPUT_PROP_POINTER, input_dev->propbit);\r\nif (wacom->flags & F_HAS_STYLUS2)\r\n__set_bit(BTN_STYLUS2, input_dev->keybit);\r\nif (wacom->flags & F_HAS_SCROLLWHEEL)\r\n__set_bit(REL_WHEEL, input_dev->relbit);\r\ninput_abs_set_res(wacom->dev, ABS_X, wacom->res_x);\r\ninput_abs_set_res(wacom->dev, ABS_Y, wacom->res_y);\r\ninput_set_abs_params(wacom->dev, ABS_X, 0, wacom->max_x, 0, 0);\r\ninput_set_abs_params(wacom->dev, ABS_Y, 0, wacom->max_y, 0, 0);\r\ninput_set_abs_params(wacom->dev, ABS_PRESSURE, -1,\r\n(1 << (7 + wacom->extra_z_bits)) - 1, 0, 0);\r\nerr = input_register_device(wacom->dev);\r\nif (err)\r\ngoto close_serio;\r\nreturn 0;\r\nclose_serio:\r\nserio_close(serio);\r\nfree_device:\r\nserio_set_drvdata(serio, NULL);\r\ninput_free_device(input_dev);\r\nkfree(wacom);\r\nreturn err;\r\n}
