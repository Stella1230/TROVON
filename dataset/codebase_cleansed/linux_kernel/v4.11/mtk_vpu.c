static inline void vpu_cfg_writel(struct mtk_vpu *vpu, u32 val, u32 offset)\r\n{\r\nwritel(val, vpu->reg.cfg + offset);\r\n}\r\nstatic inline u32 vpu_cfg_readl(struct mtk_vpu *vpu, u32 offset)\r\n{\r\nreturn readl(vpu->reg.cfg + offset);\r\n}\r\nstatic inline bool vpu_running(struct mtk_vpu *vpu)\r\n{\r\nreturn vpu_cfg_readl(vpu, VPU_RESET) & BIT(0);\r\n}\r\nstatic void vpu_clock_disable(struct mtk_vpu *vpu)\r\n{\r\nmutex_lock(&vpu->vpu_mutex);\r\nif (!--vpu->wdt_refcnt)\r\nvpu_cfg_writel(vpu,\r\nvpu_cfg_readl(vpu, VPU_WDT_REG) & ~(1L << 31),\r\nVPU_WDT_REG);\r\nmutex_unlock(&vpu->vpu_mutex);\r\nclk_disable(vpu->clk);\r\n}\r\nstatic int vpu_clock_enable(struct mtk_vpu *vpu)\r\n{\r\nint ret;\r\nret = clk_enable(vpu->clk);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&vpu->vpu_mutex);\r\nif (!vpu->wdt_refcnt++)\r\nvpu_cfg_writel(vpu,\r\nvpu_cfg_readl(vpu, VPU_WDT_REG) | (1L << 31),\r\nVPU_WDT_REG);\r\nmutex_unlock(&vpu->vpu_mutex);\r\nreturn ret;\r\n}\r\nint vpu_ipi_register(struct platform_device *pdev,\r\nenum ipi_id id, ipi_handler_t handler,\r\nconst char *name, void *priv)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nstruct vpu_ipi_desc *ipi_desc;\r\nif (!vpu) {\r\ndev_err(&pdev->dev, "vpu device in not ready\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (id >= 0 && id < IPI_MAX && handler) {\r\nipi_desc = vpu->ipi_desc;\r\nipi_desc[id].name = name;\r\nipi_desc[id].handler = handler;\r\nipi_desc[id].priv = priv;\r\nreturn 0;\r\n}\r\ndev_err(&pdev->dev, "register vpu ipi id %d with invalid arguments\n",\r\nid);\r\nreturn -EINVAL;\r\n}\r\nint vpu_ipi_send(struct platform_device *pdev,\r\nenum ipi_id id, void *buf,\r\nunsigned int len)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nstruct share_obj *send_obj = vpu->send_buf;\r\nunsigned long timeout;\r\nint ret = 0;\r\nif (id <= IPI_VPU_INIT || id >= IPI_MAX ||\r\nlen > sizeof(send_obj->share_buf) || !buf) {\r\ndev_err(vpu->dev, "failed to send ipi message\n");\r\nreturn -EINVAL;\r\n}\r\nret = vpu_clock_enable(vpu);\r\nif (ret) {\r\ndev_err(vpu->dev, "failed to enable vpu clock\n");\r\nreturn ret;\r\n}\r\nif (!vpu_running(vpu)) {\r\ndev_err(vpu->dev, "vpu_ipi_send: VPU is not running\n");\r\nret = -EINVAL;\r\ngoto clock_disable;\r\n}\r\nmutex_lock(&vpu->vpu_mutex);\r\ntimeout = jiffies + msecs_to_jiffies(IPI_TIMEOUT_MS);\r\ndo {\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(vpu->dev, "vpu_ipi_send: IPI timeout!\n");\r\nret = -EIO;\r\ngoto mut_unlock;\r\n}\r\n} while (vpu_cfg_readl(vpu, HOST_TO_VPU));\r\nmemcpy((void *)send_obj->share_buf, buf, len);\r\nsend_obj->len = len;\r\nsend_obj->id = id;\r\nvpu->ipi_id_ack[id] = false;\r\nvpu_cfg_writel(vpu, 0x1, HOST_TO_VPU);\r\nmutex_unlock(&vpu->vpu_mutex);\r\ntimeout = msecs_to_jiffies(IPI_TIMEOUT_MS);\r\nret = wait_event_timeout(vpu->ack_wq, vpu->ipi_id_ack[id], timeout);\r\nvpu->ipi_id_ack[id] = false;\r\nif (ret == 0) {\r\ndev_err(vpu->dev, "vpu ipi %d ack time out !", id);\r\nret = -EIO;\r\ngoto clock_disable;\r\n}\r\nvpu_clock_disable(vpu);\r\nreturn 0;\r\nmut_unlock:\r\nmutex_unlock(&vpu->vpu_mutex);\r\nclock_disable:\r\nvpu_clock_disable(vpu);\r\nreturn ret;\r\n}\r\nstatic void vpu_wdt_reset_func(struct work_struct *ws)\r\n{\r\nstruct vpu_wdt *wdt = container_of(ws, struct vpu_wdt, ws);\r\nstruct mtk_vpu *vpu = container_of(wdt, struct mtk_vpu, wdt);\r\nstruct vpu_wdt_handler *handler = wdt->handler;\r\nint index, ret;\r\ndev_info(vpu->dev, "vpu reset\n");\r\nret = vpu_clock_enable(vpu);\r\nif (ret) {\r\ndev_err(vpu->dev, "[VPU] wdt enables clock failed %d\n", ret);\r\nreturn;\r\n}\r\nmutex_lock(&vpu->vpu_mutex);\r\nvpu_cfg_writel(vpu, 0x0, VPU_RESET);\r\nvpu->fw_loaded = false;\r\nmutex_unlock(&vpu->vpu_mutex);\r\nvpu_clock_disable(vpu);\r\nfor (index = 0; index < VPU_RST_MAX; index++) {\r\nif (handler[index].reset_func) {\r\nhandler[index].reset_func(handler[index].priv);\r\ndev_dbg(vpu->dev, "wdt handler func %d\n", index);\r\n}\r\n}\r\n}\r\nint vpu_wdt_reg_handler(struct platform_device *pdev,\r\nvoid wdt_reset(void *),\r\nvoid *priv, enum rst_id id)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nstruct vpu_wdt_handler *handler;\r\nif (!vpu) {\r\ndev_err(&pdev->dev, "vpu device in not ready\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nhandler = vpu->wdt.handler;\r\nif (id >= 0 && id < VPU_RST_MAX && wdt_reset) {\r\ndev_dbg(vpu->dev, "wdt register id %d\n", id);\r\nmutex_lock(&vpu->vpu_mutex);\r\nhandler[id].reset_func = wdt_reset;\r\nhandler[id].priv = priv;\r\nmutex_unlock(&vpu->vpu_mutex);\r\nreturn 0;\r\n}\r\ndev_err(vpu->dev, "register vpu wdt handler failed\n");\r\nreturn -EINVAL;\r\n}\r\nunsigned int vpu_get_vdec_hw_capa(struct platform_device *pdev)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nreturn vpu->run.dec_capability;\r\n}\r\nunsigned int vpu_get_venc_hw_capa(struct platform_device *pdev)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nreturn vpu->run.enc_capability;\r\n}\r\nvoid *vpu_mapping_dm_addr(struct platform_device *pdev,\r\nu32 dtcm_dmem_addr)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\nif (!dtcm_dmem_addr ||\r\n(dtcm_dmem_addr > (VPU_DTCM_SIZE + VPU_EXT_D_SIZE))) {\r\ndev_err(vpu->dev, "invalid virtual data memory address\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (dtcm_dmem_addr < VPU_DTCM_SIZE)\r\nreturn (__force void *)(dtcm_dmem_addr + vpu->reg.tcm +\r\nVPU_DTCM_OFFSET);\r\nreturn vpu->extmem[D_FW].va + (dtcm_dmem_addr - VPU_DTCM_SIZE);\r\n}\r\nstruct platform_device *vpu_get_plat_device(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *vpu_node;\r\nstruct platform_device *vpu_pdev;\r\nvpu_node = of_parse_phandle(dev->of_node, "mediatek,vpu", 0);\r\nif (!vpu_node) {\r\ndev_err(dev, "can't get vpu node\n");\r\nreturn NULL;\r\n}\r\nvpu_pdev = of_find_device_by_node(vpu_node);\r\nif (WARN_ON(!vpu_pdev)) {\r\ndev_err(dev, "vpu pdev failed\n");\r\nof_node_put(vpu_node);\r\nreturn NULL;\r\n}\r\nreturn vpu_pdev;\r\n}\r\nstatic int load_requested_vpu(struct mtk_vpu *vpu,\r\nconst struct firmware *vpu_fw,\r\nu8 fw_type)\r\n{\r\nsize_t tcm_size = fw_type ? VPU_DTCM_SIZE : VPU_PTCM_SIZE;\r\nsize_t fw_size = fw_type ? VPU_D_FW_SIZE : VPU_P_FW_SIZE;\r\nchar *fw_name = fw_type ? VPU_D_FW : VPU_P_FW;\r\nsize_t dl_size = 0;\r\nsize_t extra_fw_size = 0;\r\nvoid *dest;\r\nint ret;\r\nret = request_firmware(&vpu_fw, fw_name, vpu->dev);\r\nif (ret < 0) {\r\ndev_err(vpu->dev, "Failed to load %s, %d\n", fw_name, ret);\r\nreturn ret;\r\n}\r\ndl_size = vpu_fw->size;\r\nif (dl_size > fw_size) {\r\ndev_err(vpu->dev, "fw %s size %zu is abnormal\n", fw_name,\r\ndl_size);\r\nrelease_firmware(vpu_fw);\r\nreturn -EFBIG;\r\n}\r\ndev_dbg(vpu->dev, "Downloaded fw %s size: %zu.\n",\r\nfw_name,\r\ndl_size);\r\nvpu_cfg_writel(vpu, 0x0, VPU_RESET);\r\nif (dl_size > tcm_size) {\r\ndev_dbg(vpu->dev, "fw size %zu > limited fw size %zu\n",\r\ndl_size, tcm_size);\r\nextra_fw_size = dl_size - tcm_size;\r\ndev_dbg(vpu->dev, "extra_fw_size %zu\n", extra_fw_size);\r\ndl_size = tcm_size;\r\n}\r\ndest = (__force void *)vpu->reg.tcm;\r\nif (fw_type == D_FW)\r\ndest += VPU_DTCM_OFFSET;\r\nmemcpy(dest, vpu_fw->data, dl_size);\r\nif (extra_fw_size > 0) {\r\ndest = vpu->extmem[fw_type].va;\r\ndev_dbg(vpu->dev, "download extended memory type %x\n",\r\nfw_type);\r\nmemcpy(dest, vpu_fw->data + tcm_size, extra_fw_size);\r\n}\r\nrelease_firmware(vpu_fw);\r\nreturn 0;\r\n}\r\nint vpu_load_firmware(struct platform_device *pdev)\r\n{\r\nstruct mtk_vpu *vpu;\r\nstruct device *dev = &pdev->dev;\r\nstruct vpu_run *run;\r\nconst struct firmware *vpu_fw = NULL;\r\nint ret;\r\nif (!pdev) {\r\ndev_err(dev, "VPU platform device is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nvpu = platform_get_drvdata(pdev);\r\nrun = &vpu->run;\r\nmutex_lock(&vpu->vpu_mutex);\r\nif (vpu->fw_loaded) {\r\nmutex_unlock(&vpu->vpu_mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&vpu->vpu_mutex);\r\nret = vpu_clock_enable(vpu);\r\nif (ret) {\r\ndev_err(dev, "enable clock failed %d\n", ret);\r\nreturn ret;\r\n}\r\nmutex_lock(&vpu->vpu_mutex);\r\nrun->signaled = false;\r\ndev_dbg(vpu->dev, "firmware request\n");\r\nret = load_requested_vpu(vpu, vpu_fw, P_FW);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request %s, %d\n", VPU_P_FW, ret);\r\ngoto OUT_LOAD_FW;\r\n}\r\nret = load_requested_vpu(vpu, vpu_fw, D_FW);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to request %s, %d\n", VPU_D_FW, ret);\r\ngoto OUT_LOAD_FW;\r\n}\r\nvpu->fw_loaded = true;\r\nvpu_cfg_writel(vpu, 0x1, VPU_RESET);\r\nret = wait_event_interruptible_timeout(run->wq,\r\nrun->signaled,\r\nmsecs_to_jiffies(INIT_TIMEOUT_MS)\r\n);\r\nif (ret == 0) {\r\nret = -ETIME;\r\ndev_err(dev, "wait vpu initialization timout!\n");\r\ngoto OUT_LOAD_FW;\r\n} else if (-ERESTARTSYS == ret) {\r\ndev_err(dev, "wait vpu interrupted by a signal!\n");\r\ngoto OUT_LOAD_FW;\r\n}\r\nret = 0;\r\ndev_info(dev, "vpu is ready. Fw version %s\n", run->fw_ver);\r\nOUT_LOAD_FW:\r\nmutex_unlock(&vpu->vpu_mutex);\r\nvpu_clock_disable(vpu);\r\nreturn ret;\r\n}\r\nstatic void vpu_init_ipi_handler(void *data, unsigned int len, void *priv)\r\n{\r\nstruct mtk_vpu *vpu = (struct mtk_vpu *)priv;\r\nstruct vpu_run *run = (struct vpu_run *)data;\r\nvpu->run.signaled = run->signaled;\r\nstrncpy(vpu->run.fw_ver, run->fw_ver, VPU_FW_VER_LEN);\r\nvpu->run.dec_capability = run->dec_capability;\r\nvpu->run.enc_capability = run->enc_capability;\r\nwake_up_interruptible(&vpu->run.wq);\r\n}\r\nstatic ssize_t vpu_debug_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[256];\r\nunsigned int len;\r\nunsigned int running, pc, vpu_to_host, host_to_vpu, wdt;\r\nint ret;\r\nstruct device *dev = file->private_data;\r\nstruct mtk_vpu *vpu = dev_get_drvdata(dev);\r\nret = vpu_clock_enable(vpu);\r\nif (ret) {\r\ndev_err(vpu->dev, "[VPU] enable clock failed %d\n", ret);\r\nreturn 0;\r\n}\r\nrunning = vpu_running(vpu);\r\npc = vpu_cfg_readl(vpu, VPU_PC_REG);\r\nwdt = vpu_cfg_readl(vpu, VPU_WDT_REG);\r\nhost_to_vpu = vpu_cfg_readl(vpu, HOST_TO_VPU);\r\nvpu_to_host = vpu_cfg_readl(vpu, VPU_TO_HOST);\r\nvpu_clock_disable(vpu);\r\nif (running) {\r\nlen = snprintf(buf, sizeof(buf), "VPU is running\n\n"\r\n"FW Version: %s\n"\r\n"PC: 0x%x\n"\r\n"WDT: 0x%x\n"\r\n"Host to VPU: 0x%x\n"\r\n"VPU to Host: 0x%x\n",\r\nvpu->run.fw_ver, pc, wdt,\r\nhost_to_vpu, vpu_to_host);\r\n} else {\r\nlen = snprintf(buf, sizeof(buf), "VPU not running\n");\r\n}\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic void vpu_free_ext_mem(struct mtk_vpu *vpu, u8 fw_type)\r\n{\r\nstruct device *dev = vpu->dev;\r\nsize_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;\r\ndma_free_coherent(dev, fw_ext_size, vpu->extmem[fw_type].va,\r\nvpu->extmem[fw_type].pa);\r\n}\r\nstatic int vpu_alloc_ext_mem(struct mtk_vpu *vpu, u32 fw_type)\r\n{\r\nstruct device *dev = vpu->dev;\r\nsize_t fw_ext_size = fw_type ? VPU_EXT_D_SIZE : VPU_EXT_P_SIZE;\r\nu32 vpu_ext_mem0 = fw_type ? VPU_DMEM_EXT0_ADDR : VPU_PMEM_EXT0_ADDR;\r\nu32 vpu_ext_mem1 = fw_type ? VPU_DMEM_EXT1_ADDR : VPU_PMEM_EXT1_ADDR;\r\nu32 offset_4gb = vpu->enable_4GB ? 0x40000000 : 0;\r\nvpu->extmem[fw_type].va = dma_alloc_coherent(dev,\r\nfw_ext_size,\r\n&vpu->extmem[fw_type].pa,\r\nGFP_KERNEL);\r\nif (!vpu->extmem[fw_type].va) {\r\ndev_err(dev, "Failed to allocate the extended program memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvpu_cfg_writel(vpu, 0x1, vpu_ext_mem0);\r\nvpu_cfg_writel(vpu, (vpu->extmem[fw_type].pa & 0xFFFFF000) + offset_4gb,\r\nvpu_ext_mem1);\r\ndev_info(dev, "%s extend memory phy=0x%llx virt=0x%p\n",\r\nfw_type ? "Data" : "Program",\r\n(unsigned long long)vpu->extmem[fw_type].pa,\r\nvpu->extmem[fw_type].va);\r\nreturn 0;\r\n}\r\nstatic void vpu_ipi_handler(struct mtk_vpu *vpu)\r\n{\r\nstruct share_obj *rcv_obj = vpu->recv_buf;\r\nstruct vpu_ipi_desc *ipi_desc = vpu->ipi_desc;\r\nif (rcv_obj->id < IPI_MAX && ipi_desc[rcv_obj->id].handler) {\r\nipi_desc[rcv_obj->id].handler(rcv_obj->share_buf,\r\nrcv_obj->len,\r\nipi_desc[rcv_obj->id].priv);\r\nif (rcv_obj->id > IPI_VPU_INIT) {\r\nvpu->ipi_id_ack[rcv_obj->id] = true;\r\nwake_up(&vpu->ack_wq);\r\n}\r\n} else {\r\ndev_err(vpu->dev, "No such ipi id = %d\n", rcv_obj->id);\r\n}\r\n}\r\nstatic int vpu_ipi_init(struct mtk_vpu *vpu)\r\n{\r\nvpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);\r\nvpu->recv_buf = (__force struct share_obj *)(vpu->reg.tcm +\r\nVPU_DTCM_OFFSET);\r\nvpu->send_buf = vpu->recv_buf + 1;\r\nmemset(vpu->recv_buf, 0, sizeof(struct share_obj));\r\nmemset(vpu->send_buf, 0, sizeof(struct share_obj));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t vpu_irq_handler(int irq, void *priv)\r\n{\r\nstruct mtk_vpu *vpu = priv;\r\nu32 vpu_to_host;\r\nint ret;\r\nret = clk_enable(vpu->clk);\r\nif (ret) {\r\ndev_err(vpu->dev, "[VPU] enable clock failed %d\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nvpu_to_host = vpu_cfg_readl(vpu, VPU_TO_HOST);\r\nif (vpu_to_host & VPU_IPC_INT) {\r\nvpu_ipi_handler(vpu);\r\n} else {\r\ndev_err(vpu->dev, "vpu watchdog timeout! 0x%x", vpu_to_host);\r\nqueue_work(vpu->wdt.wq, &vpu->wdt.ws);\r\n}\r\nvpu_cfg_writel(vpu, 0x0, VPU_TO_HOST);\r\nclk_disable(vpu->clk);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mtk_vpu_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_vpu *vpu;\r\nstruct device *dev;\r\nstruct resource *res;\r\nint ret = 0;\r\ndev_dbg(&pdev->dev, "initialization\n");\r\ndev = &pdev->dev;\r\nvpu = devm_kzalloc(dev, sizeof(*vpu), GFP_KERNEL);\r\nif (!vpu)\r\nreturn -ENOMEM;\r\nvpu->dev = &pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tcm");\r\nvpu->reg.tcm = devm_ioremap_resource(dev, res);\r\nif (IS_ERR((__force void *)vpu->reg.tcm))\r\nreturn PTR_ERR((__force void *)vpu->reg.tcm);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_reg");\r\nvpu->reg.cfg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR((__force void *)vpu->reg.cfg))\r\nreturn PTR_ERR((__force void *)vpu->reg.cfg);\r\nvpu->clk = devm_clk_get(dev, "main");\r\nif (IS_ERR(vpu->clk)) {\r\ndev_err(dev, "get vpu clock failed\n");\r\nreturn PTR_ERR(vpu->clk);\r\n}\r\nplatform_set_drvdata(pdev, vpu);\r\nret = clk_prepare(vpu->clk);\r\nif (ret) {\r\ndev_err(dev, "prepare vpu clock failed\n");\r\nreturn ret;\r\n}\r\nvpu->wdt.wq = create_singlethread_workqueue("vpu_wdt");\r\nif (!vpu->wdt.wq) {\r\ndev_err(dev, "initialize wdt workqueue failed\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&vpu->wdt.ws, vpu_wdt_reset_func);\r\nmutex_init(&vpu->vpu_mutex);\r\nret = vpu_clock_enable(vpu);\r\nif (ret) {\r\ndev_err(dev, "enable vpu clock failed\n");\r\ngoto workqueue_destroy;\r\n}\r\ndev_dbg(dev, "vpu ipi init\n");\r\nret = vpu_ipi_init(vpu);\r\nif (ret) {\r\ndev_err(dev, "Failed to init ipi\n");\r\ngoto disable_vpu_clk;\r\n}\r\nret = vpu_ipi_register(pdev, IPI_VPU_INIT, vpu_init_ipi_handler,\r\n"vpu_init", vpu);\r\nif (ret) {\r\ndev_err(dev, "Failed to register IPI_VPU_INIT\n");\r\ngoto vpu_mutex_destroy;\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\nvpu_debugfs = debugfs_create_file("mtk_vpu", S_IRUGO, NULL, (void *)dev,\r\n&vpu_debug_fops);\r\nif (!vpu_debugfs) {\r\nret = -ENOMEM;\r\ngoto cleanup_ipi;\r\n}\r\n#endif\r\nvpu_cfg_writel(vpu, 0x2, VPU_TCM_CFG);\r\nvpu->enable_4GB = !!(totalram_pages > (SZ_2G >> PAGE_SHIFT));\r\ndev_info(dev, "4GB mode %u\n", vpu->enable_4GB);\r\nif (vpu->enable_4GB) {\r\nret = of_reserved_mem_device_init(dev);\r\nif (ret)\r\ndev_info(dev, "init reserved memory failed\n");\r\n}\r\nret = vpu_alloc_ext_mem(vpu, D_FW);\r\nif (ret) {\r\ndev_err(dev, "Allocate DM failed\n");\r\ngoto remove_debugfs;\r\n}\r\nret = vpu_alloc_ext_mem(vpu, P_FW);\r\nif (ret) {\r\ndev_err(dev, "Allocate PM failed\n");\r\ngoto free_d_mem;\r\n}\r\ninit_waitqueue_head(&vpu->run.wq);\r\ninit_waitqueue_head(&vpu->ack_wq);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "get IRQ resource failed.\n");\r\nret = -ENXIO;\r\ngoto free_p_mem;\r\n}\r\nvpu->reg.irq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(dev, vpu->reg.irq, vpu_irq_handler, 0,\r\npdev->name, vpu);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq\n");\r\ngoto free_p_mem;\r\n}\r\nvpu_clock_disable(vpu);\r\ndev_dbg(dev, "initialization completed\n");\r\nreturn 0;\r\nfree_p_mem:\r\nvpu_free_ext_mem(vpu, P_FW);\r\nfree_d_mem:\r\nvpu_free_ext_mem(vpu, D_FW);\r\nremove_debugfs:\r\nof_reserved_mem_device_release(dev);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_remove(vpu_debugfs);\r\ncleanup_ipi:\r\n#endif\r\nmemset(vpu->ipi_desc, 0, sizeof(struct vpu_ipi_desc) * IPI_MAX);\r\nvpu_mutex_destroy:\r\nmutex_destroy(&vpu->vpu_mutex);\r\ndisable_vpu_clk:\r\nvpu_clock_disable(vpu);\r\nworkqueue_destroy:\r\ndestroy_workqueue(vpu->wdt.wq);\r\nreturn ret;\r\n}\r\nstatic int mtk_vpu_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_vpu *vpu = platform_get_drvdata(pdev);\r\n#ifdef CONFIG_DEBUG_FS\r\ndebugfs_remove(vpu_debugfs);\r\n#endif\r\nif (vpu->wdt.wq) {\r\nflush_workqueue(vpu->wdt.wq);\r\ndestroy_workqueue(vpu->wdt.wq);\r\n}\r\nvpu_free_ext_mem(vpu, P_FW);\r\nvpu_free_ext_mem(vpu, D_FW);\r\nmutex_destroy(&vpu->vpu_mutex);\r\nclk_unprepare(vpu->clk);\r\nreturn 0;\r\n}
