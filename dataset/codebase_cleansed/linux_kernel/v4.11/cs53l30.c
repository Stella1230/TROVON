static bool cs53l30_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg == CS53L30_IS)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool cs53l30_writeable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS53L30_DEVID_AB:\r\ncase CS53L30_DEVID_CD:\r\ncase CS53L30_DEVID_E:\r\ncase CS53L30_REVID:\r\ncase CS53L30_IS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic bool cs53l30_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase CS53L30_DEVID_AB:\r\ncase CS53L30_DEVID_CD:\r\ncase CS53L30_DEVID_E:\r\ncase CS53L30_REVID:\r\ncase CS53L30_PWRCTL:\r\ncase CS53L30_MCLKCTL:\r\ncase CS53L30_INT_SR_CTL:\r\ncase CS53L30_MICBIAS_CTL:\r\ncase CS53L30_ASPCFG_CTL:\r\ncase CS53L30_ASP_CTL1:\r\ncase CS53L30_ASP_TDMTX_CTL1:\r\ncase CS53L30_ASP_TDMTX_CTL2:\r\ncase CS53L30_ASP_TDMTX_CTL3:\r\ncase CS53L30_ASP_TDMTX_CTL4:\r\ncase CS53L30_ASP_TDMTX_EN1:\r\ncase CS53L30_ASP_TDMTX_EN2:\r\ncase CS53L30_ASP_TDMTX_EN3:\r\ncase CS53L30_ASP_TDMTX_EN4:\r\ncase CS53L30_ASP_TDMTX_EN5:\r\ncase CS53L30_ASP_TDMTX_EN6:\r\ncase CS53L30_ASP_CTL2:\r\ncase CS53L30_SFT_RAMP:\r\ncase CS53L30_LRCK_CTL1:\r\ncase CS53L30_LRCK_CTL2:\r\ncase CS53L30_MUTEP_CTL1:\r\ncase CS53L30_MUTEP_CTL2:\r\ncase CS53L30_INBIAS_CTL1:\r\ncase CS53L30_INBIAS_CTL2:\r\ncase CS53L30_DMIC1_STR_CTL:\r\ncase CS53L30_DMIC2_STR_CTL:\r\ncase CS53L30_ADCDMIC1_CTL1:\r\ncase CS53L30_ADCDMIC1_CTL2:\r\ncase CS53L30_ADC1_CTL3:\r\ncase CS53L30_ADC1_NG_CTL:\r\ncase CS53L30_ADC1A_AFE_CTL:\r\ncase CS53L30_ADC1B_AFE_CTL:\r\ncase CS53L30_ADC1A_DIG_VOL:\r\ncase CS53L30_ADC1B_DIG_VOL:\r\ncase CS53L30_ADCDMIC2_CTL1:\r\ncase CS53L30_ADCDMIC2_CTL2:\r\ncase CS53L30_ADC2_CTL3:\r\ncase CS53L30_ADC2_NG_CTL:\r\ncase CS53L30_ADC2A_AFE_CTL:\r\ncase CS53L30_ADC2B_AFE_CTL:\r\ncase CS53L30_ADC2A_DIG_VOL:\r\ncase CS53L30_ADC2B_DIG_VOL:\r\ncase CS53L30_INT_MASK:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int cs53l30_get_mclkx_coeff(int mclkx)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs53l30_mclkx_coeffs); i++) {\r\nif (cs53l30_mclkx_coeffs[i].mclkx == mclkx)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs53l30_get_mclk_coeff(int mclk_rate, int srate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cs53l30_mclk_coeffs); i++) {\r\nif (cs53l30_mclk_coeffs[i].mclk_rate == mclk_rate &&\r\ncs53l30_mclk_coeffs[i].srate == srate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int cs53l30_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nint mclkx_coeff;\r\nu32 mclk_rate;\r\nmclkx_coeff = cs53l30_get_mclkx_coeff(freq);\r\nif (mclkx_coeff < 0)\r\nreturn mclkx_coeff;\r\nmclk_rate = cs53l30_mclkx_coeffs[mclkx_coeff].mclkx /\r\ncs53l30_mclkx_coeffs[mclkx_coeff].ratio;\r\nregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\r\nCS53L30_MCLK_DIV_MASK,\r\ncs53l30_mclkx_coeffs[mclkx_coeff].mclkdiv);\r\npriv->mclk_rate = mclk_rate;\r\nreturn 0;\r\n}\r\nstatic int cs53l30_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nu8 aspcfg = 0, aspctl1 = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naspcfg |= CS53L30_ASP_MS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naspctl1 |= CS53L30_ASP_TDM_PDN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naspctl1 |= CS53L30_SHIFT_LEFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naspcfg ^= CS53L30_ASP_SCLK_INV;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nregmap_update_bits(priv->regmap, CS53L30_ASPCFG_CTL,\r\nCS53L30_ASP_MS | CS53L30_ASP_SCLK_INV, aspcfg);\r\nregmap_update_bits(priv->regmap, CS53L30_ASP_CTL1,\r\nCS53L30_ASP_TDM_PDN | CS53L30_SHIFT_LEFT, aspctl1);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nint srate = params_rate(params);\r\nint mclk_coeff;\r\nmclk_coeff = cs53l30_get_mclk_coeff(priv->mclk_rate, srate);\r\nif (mclk_coeff < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(priv->regmap, CS53L30_INT_SR_CTL,\r\nCS53L30_INTRNL_FS_RATIO_MASK,\r\ncs53l30_mclk_coeffs[mclk_coeff].internal_fs_ratio);\r\nregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\r\nCS53L30_MCLK_INT_SCALE_MASK,\r\ncs53l30_mclk_coeffs[mclk_coeff].mclk_int_scale);\r\nregmap_update_bits(priv->regmap, CS53L30_ASPCFG_CTL,\r\nCS53L30_ASP_RATE_MASK,\r\ncs53l30_mclk_coeffs[mclk_coeff].asp_rate);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nint i, inter_max_check, ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (dapm->bias_level == SND_SOC_BIAS_STANDBY)\r\nregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\r\nCS53L30_PDN_LP_MASK, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (dapm->bias_level == SND_SOC_BIAS_OFF) {\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"failed to enable MCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\nregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\r\nCS53L30_MCLK_DIS_MASK, 0);\r\nregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\r\nCS53L30_PDN_ULP_MASK, 0);\r\nmsleep(50);\r\n} else {\r\nregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\r\nCS53L30_PDN_ULP_MASK,\r\nCS53L30_PDN_ULP);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(priv->regmap, CS53L30_INT_MASK,\r\nCS53L30_PDN_DONE, 0);\r\nregmap_read(priv->regmap, CS53L30_SFT_RAMP, &reg);\r\nif (reg & CS53L30_DIGSFT_MASK)\r\ninter_max_check = CS53L30_PDN_POLL_MAX;\r\nelse\r\ninter_max_check = 10;\r\nregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\r\nCS53L30_PDN_ULP_MASK,\r\nCS53L30_PDN_ULP);\r\nmsleep(20);\r\nregmap_read(priv->regmap, CS53L30_IS, &reg);\r\nfor (i = 0; i < inter_max_check; i++) {\r\nif (inter_max_check < 10) {\r\nusleep_range(1000, 1100);\r\nregmap_read(priv->regmap, CS53L30_IS, &reg);\r\nif (reg & CS53L30_PDN_DONE)\r\nbreak;\r\n} else {\r\nusleep_range(10000, 10100);\r\nregmap_read(priv->regmap, CS53L30_IS, &reg);\r\nif (reg & CS53L30_PDN_DONE)\r\nbreak;\r\n}\r\n}\r\nregmap_update_bits(priv->regmap, CS53L30_INT_MASK,\r\nCS53L30_PDN_DONE, CS53L30_PDN_DONE);\r\nregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\r\nCS53L30_MCLK_DIS_MASK,\r\nCS53L30_MCLK_DIS);\r\nclk_disable_unprepare(priv->mclk);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs53l30_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nu8 val = tristate ? CS53L30_ASP_3ST : 0;\r\nreturn regmap_update_bits(priv->regmap, CS53L30_ASP_CTL1,\r\nCS53L30_ASP_3ST_MASK, val);\r\n}\r\nstatic int cs53l30_pcm_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &src_constraints);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int loc[CS53L30_TDM_SLOT_MAX] = {48, 48, 48, 48};\r\nunsigned int slot_next, slot_step;\r\nu64 tx_enable = 0;\r\nint i;\r\nif (!rx_mask) {\r\ndev_err(dai->dev, "rx masks must not be 0\n");\r\nreturn -EINVAL;\r\n}\r\nif (slots <= 0 || slot_width <= 0 || slot_width > 64) {\r\ndev_err(dai->dev, "invalid slot number or slot width\n");\r\nreturn -EINVAL;\r\n}\r\nif (slot_width & 0x7) {\r\ndev_err(dai->dev, "slot width must count in byte\n");\r\nreturn -EINVAL;\r\n}\r\nslot_step = slot_width >> 3;\r\nfor (i = 0; rx_mask && i < CS53L30_TDM_SLOT_MAX; i++) {\r\nslot_next = __ffs(rx_mask);\r\nloc[i] = slot_next * slot_step;\r\ntx_enable |= (u64)((u64)(1 << slot_step) - 1) << (u64)loc[i];\r\nrx_mask &= ~(1 << slot_next);\r\n}\r\nif (rx_mask && i == CS53L30_TDM_SLOT_MAX) {\r\ndev_err(dai->dev, "rx_mask exceeds max slot number: %d\n",\r\nCS53L30_TDM_SLOT_MAX);\r\nreturn -EINVAL;\r\n}\r\nslot_next = loc[i - 1] + slot_step - 1;\r\nif (slot_next > 47) {\r\ndev_err(dai->dev, "slot selection out of bounds: %u\n",\r\nslot_next);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < CS53L30_TDM_SLOT_MAX && loc[i] != 48; i++) {\r\nregmap_update_bits(priv->regmap, CS53L30_ASP_TDMTX_CTL(i),\r\nCS53L30_ASP_CHx_TX_LOC_MASK, loc[i]);\r\ndev_dbg(dai->dev, "loc[%d]=%x\n", i, loc[i]);\r\n}\r\nfor (i = 0; i < CS53L30_ASP_TDMTX_ENx_MAX && tx_enable; i++) {\r\nregmap_write(priv->regmap, CS53L30_ASP_TDMTX_ENx(i),\r\ntx_enable & 0xff);\r\ntx_enable >>= 8;\r\ndev_dbg(dai->dev, "en_reg=%x, tx_enable=%llx\n",\r\nCS53L30_ASP_TDMTX_ENx(i), tx_enable & 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs53l30_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(dai->codec);\r\nif (priv->mute_gpio)\r\ngpiod_set_value_cansleep(priv->mute_gpio, mute);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct cs53l30_private *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nif (priv->use_sdout2)\r\nsnd_soc_dapm_add_routes(dapm, cs53l30_dapm_routes_sdout2,\r\nARRAY_SIZE(cs53l30_dapm_routes_sdout2));\r\nelse\r\nsnd_soc_dapm_add_routes(dapm, cs53l30_dapm_routes_sdout1,\r\nARRAY_SIZE(cs53l30_dapm_routes_sdout1));\r\nreturn 0;\r\n}\r\nstatic int cs53l30_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct device_node *np = client->dev.of_node;\r\nstruct device *dev = &client->dev;\r\nstruct cs53l30_private *cs53l30;\r\nunsigned int devid = 0;\r\nunsigned int reg;\r\nint ret = 0, i;\r\nu8 val;\r\ncs53l30 = devm_kzalloc(dev, sizeof(*cs53l30), GFP_KERNEL);\r\nif (!cs53l30)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(cs53l30->supplies); i++)\r\ncs53l30->supplies[i].supply = cs53l30_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\ncs53l30->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(cs53l30->reset_gpio)) {\r\nret = PTR_ERR(cs53l30->reset_gpio);\r\ngoto error;\r\n}\r\nif (cs53l30->reset_gpio)\r\ngpiod_set_value_cansleep(cs53l30->reset_gpio, 1);\r\ni2c_set_clientdata(client, cs53l30);\r\ncs53l30->mclk_rate = 0;\r\ncs53l30->regmap = devm_regmap_init_i2c(client, &cs53l30_regmap);\r\nif (IS_ERR(cs53l30->regmap)) {\r\nret = PTR_ERR(cs53l30->regmap);\r\ndev_err(dev, "regmap_init() failed: %d\n", ret);\r\ngoto error;\r\n}\r\nret = regmap_read(cs53l30->regmap, CS53L30_DEVID_AB, &reg);\r\ndevid = reg << 12;\r\nret = regmap_read(cs53l30->regmap, CS53L30_DEVID_CD, &reg);\r\ndevid |= reg << 4;\r\nret = regmap_read(cs53l30->regmap, CS53L30_DEVID_E, &reg);\r\ndevid |= (reg & 0xF0) >> 4;\r\nif (devid != CS53L30_DEVID) {\r\nret = -ENODEV;\r\ndev_err(dev, "Device ID (%X). Expected %X\n",\r\ndevid, CS53L30_DEVID);\r\ngoto error;\r\n}\r\nret = regmap_read(cs53l30->regmap, CS53L30_REVID, &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get Revision ID: %d\n", ret);\r\ngoto error;\r\n}\r\ncs53l30->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(cs53l30->mclk)) {\r\nif (PTR_ERR(cs53l30->mclk) != -ENOENT) {\r\nret = PTR_ERR(cs53l30->mclk);\r\ngoto error;\r\n}\r\ncs53l30->mclk = NULL;\r\n}\r\ncs53l30->mute_gpio = devm_gpiod_get_optional(dev, "mute",\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(cs53l30->mute_gpio)) {\r\nret = PTR_ERR(cs53l30->mute_gpio);\r\ngoto error;\r\n}\r\nif (cs53l30->mute_gpio) {\r\nregmap_write(cs53l30->regmap, CS53L30_MUTEP_CTL1,\r\nCS53L30_MUTEP_CTL1_MUTEALL);\r\nif (gpiod_is_active_low(cs53l30->mute_gpio))\r\nregmap_update_bits(cs53l30->regmap, CS53L30_MUTEP_CTL2,\r\nCS53L30_MUTE_PIN_POLARITY, 0);\r\n}\r\nif (!of_property_read_u8(np, "cirrus,micbias-lvl", &val))\r\nregmap_update_bits(cs53l30->regmap, CS53L30_MICBIAS_CTL,\r\nCS53L30_MIC_BIAS_CTRL_MASK, val);\r\nif (of_property_read_bool(np, "cirrus,use-sdout2"))\r\ncs53l30->use_sdout2 = true;\r\ndev_info(dev, "Cirrus Logic CS53L30, Revision: %02X\n", reg & 0xFF);\r\nret = snd_soc_register_codec(dev, &cs53l30_driver, &cs53l30_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "failed to register codec: %d\n", ret);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nreturn ret;\r\n}\r\nstatic int cs53l30_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct cs53l30_private *cs53l30 = i2c_get_clientdata(client);\r\nsnd_soc_unregister_codec(&client->dev);\r\nif (cs53l30->reset_gpio)\r\ngpiod_set_value_cansleep(cs53l30->reset_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_runtime_suspend(struct device *dev)\r\n{\r\nstruct cs53l30_private *cs53l30 = dev_get_drvdata(dev);\r\nregcache_cache_only(cs53l30->regmap, true);\r\nif (cs53l30->reset_gpio)\r\ngpiod_set_value_cansleep(cs53l30->reset_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nreturn 0;\r\n}\r\nstatic int cs53l30_runtime_resume(struct device *dev)\r\n{\r\nstruct cs53l30_private *cs53l30 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(cs53l30->supplies),\r\ncs53l30->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (cs53l30->reset_gpio)\r\ngpiod_set_value_cansleep(cs53l30->reset_gpio, 1);\r\nregcache_cache_only(cs53l30->regmap, false);\r\nret = regcache_sync(cs53l30->regmap);\r\nif (ret) {\r\ndev_err(dev, "failed to synchronize regcache: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
