static inline struct adv7511_state *get_adv7511_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7511_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7511_state, hdl)->sd;\r\n}\r\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\r\nu8 command, bool check)\r\n{\r\nunion i2c_smbus_data data;\r\nif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data))\r\nreturn data.byte;\r\nif (check)\r\nv4l_err(client, "error reading %02x, %02x\n",\r\nclient->addr, command);\r\nreturn -1;\r\n}\r\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nint ret = adv_smbus_read_byte_data_check(client, command, true);\r\nif (ret >= 0) {\r\nif (i)\r\nv4l_err(client, "read ok after %d retries\n", i);\r\nreturn ret;\r\n}\r\n}\r\nv4l_err(client, "read failed\n");\r\nreturn -1;\r\n}\r\nstatic int adv7511_rd(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int adv7511_wr(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "%s: i2c write error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic inline void adv7511_wr_and_or(struct v4l2_subdev *sd, u8 reg, u8 clr_mask, u8 val_mask)\r\n{\r\nadv7511_wr(sd, reg, (adv7511_rd(sd, reg) & clr_mask) | val_mask);\r\n}\r\nstatic int adv_smbus_read_i2c_block_data(struct i2c_client *client,\r\nu8 command, unsigned length, u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint ret;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nret = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\nmemcpy(values, data.block + 1, length);\r\nreturn ret;\r\n}\r\nstatic void adv7511_edid_rd(struct v4l2_subdev *sd, uint16_t len, uint8_t *buf)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nint i;\r\nint err = 0;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nfor (i = 0; !err && i < len; i += I2C_SMBUS_BLOCK_MAX)\r\nerr = adv_smbus_read_i2c_block_data(state->i2c_edid, i,\r\nI2C_SMBUS_BLOCK_MAX, buf + i);\r\nif (err)\r\nv4l2_err(sd, "%s: i2c read error\n", __func__);\r\n}\r\nstatic inline int adv7511_cec_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nreturn i2c_smbus_read_byte_data(state->i2c_cec, reg);\r\n}\r\nstatic int adv7511_cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(state->i2c_cec, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "%s: I2C Write Problem\n", __func__);\r\nreturn ret;\r\n}\r\nstatic inline int adv7511_cec_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask,\r\nu8 val)\r\n{\r\nreturn adv7511_cec_write(sd, reg, (adv7511_cec_read(sd, reg) & mask) | val);\r\n}\r\nstatic int adv7511_pktmem_rd(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_pktmem, reg);\r\n}\r\nstatic int adv7511_pktmem_wr(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(state->i2c_pktmem, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "%s: i2c write error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic inline void adv7511_pktmem_wr_and_or(struct v4l2_subdev *sd, u8 reg, u8 clr_mask, u8 val_mask)\r\n{\r\nadv7511_pktmem_wr(sd, reg, (adv7511_pktmem_rd(sd, reg) & clr_mask) | val_mask);\r\n}\r\nstatic inline bool adv7511_have_hotplug(struct v4l2_subdev *sd)\r\n{\r\nreturn adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT;\r\n}\r\nstatic inline bool adv7511_have_rx_sense(struct v4l2_subdev *sd)\r\n{\r\nreturn adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT;\r\n}\r\nstatic void adv7511_csc_conversion_mode(struct v4l2_subdev *sd, u8 mode)\r\n{\r\nadv7511_wr_and_or(sd, 0x18, 0x9f, (mode & 0x3)<<5);\r\n}\r\nstatic void adv7511_csc_coeff(struct v4l2_subdev *sd,\r\nu16 A1, u16 A2, u16 A3, u16 A4,\r\nu16 B1, u16 B2, u16 B3, u16 B4,\r\nu16 C1, u16 C2, u16 C3, u16 C4)\r\n{\r\nadv7511_wr_and_or(sd, 0x18, 0xe0, A1>>8);\r\nadv7511_wr(sd, 0x19, A1);\r\nadv7511_wr_and_or(sd, 0x1A, 0xe0, A2>>8);\r\nadv7511_wr(sd, 0x1B, A2);\r\nadv7511_wr_and_or(sd, 0x1c, 0xe0, A3>>8);\r\nadv7511_wr(sd, 0x1d, A3);\r\nadv7511_wr_and_or(sd, 0x1e, 0xe0, A4>>8);\r\nadv7511_wr(sd, 0x1f, A4);\r\nadv7511_wr_and_or(sd, 0x20, 0xe0, B1>>8);\r\nadv7511_wr(sd, 0x21, B1);\r\nadv7511_wr_and_or(sd, 0x22, 0xe0, B2>>8);\r\nadv7511_wr(sd, 0x23, B2);\r\nadv7511_wr_and_or(sd, 0x24, 0xe0, B3>>8);\r\nadv7511_wr(sd, 0x25, B3);\r\nadv7511_wr_and_or(sd, 0x26, 0xe0, B4>>8);\r\nadv7511_wr(sd, 0x27, B4);\r\nadv7511_wr_and_or(sd, 0x28, 0xe0, C1>>8);\r\nadv7511_wr(sd, 0x29, C1);\r\nadv7511_wr_and_or(sd, 0x2A, 0xe0, C2>>8);\r\nadv7511_wr(sd, 0x2B, C2);\r\nadv7511_wr_and_or(sd, 0x2C, 0xe0, C3>>8);\r\nadv7511_wr(sd, 0x2D, C3);\r\nadv7511_wr_and_or(sd, 0x2E, 0xe0, C4>>8);\r\nadv7511_wr(sd, 0x2F, C4);\r\n}\r\nstatic void adv7511_csc_rgb_full2limit(struct v4l2_subdev *sd, bool enable)\r\n{\r\nif (enable) {\r\nu8 csc_mode = 0;\r\nadv7511_csc_conversion_mode(sd, csc_mode);\r\nadv7511_csc_coeff(sd,\r\n4096-564, 0, 0, 256,\r\n0, 4096-564, 0, 256,\r\n0, 0, 4096-564, 256);\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x80);\r\nadv7511_wr_and_or(sd, 0x57, 0xf3, 0x04);\r\n} else {\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x57, 0xf3, 0x08);\r\n}\r\n}\r\nstatic void adv7511_set_rgb_quantization_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif (state->fmt_code != MEDIA_BUS_FMT_RGB888_1X24) {\r\nadv7511_csc_rgb_full2limit(sd, false);\r\nreturn;\r\n}\r\nswitch (ctrl->val) {\r\ncase V4L2_DV_RGB_RANGE_AUTO:\r\nif (state->dv_timings.bt.flags & V4L2_DV_FL_IS_CE_VIDEO) {\r\nadv7511_csc_rgb_full2limit(sd, true);\r\n} else {\r\nadv7511_csc_rgb_full2limit(sd, false);\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nadv7511_csc_rgb_full2limit(sd, true);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nadv7511_csc_rgb_full2limit(sd, false);\r\nbreak;\r\n}\r\n}\r\nstatic int adv7511_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: ctrl id: %d, ctrl->val %d\n", __func__, ctrl->id, ctrl->val);\r\nif (state->hdmi_mode_ctrl == ctrl) {\r\nadv7511_wr_and_or(sd, 0xaf, 0xfd, ctrl->val == V4L2_DV_TX_MODE_HDMI ? 0x02 : 0x00);\r\nreturn 0;\r\n}\r\nif (state->rgb_quantization_range_ctrl == ctrl) {\r\nadv7511_set_rgb_quantization_mode(sd, ctrl);\r\nreturn 0;\r\n}\r\nif (state->content_type_ctrl == ctrl) {\r\nu8 itc, cn;\r\nstate->content_type = ctrl->val;\r\nitc = state->content_type != V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\r\ncn = itc ? state->content_type : V4L2_DV_IT_CONTENT_TYPE_GRAPHICS;\r\nadv7511_wr_and_or(sd, 0x57, 0x7f, itc << 7);\r\nadv7511_wr_and_or(sd, 0x59, 0xcf, cn << 4);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void adv7511_inv_register(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_info(sd, "0x000-0x0ff: Main Map\n");\r\nif (state->i2c_cec)\r\nv4l2_info(sd, "0x100-0x1ff: CEC Map\n");\r\n}\r\nstatic int adv7511_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nreg->size = 1;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nreg->val = adv7511_rd(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 1:\r\nif (state->i2c_cec) {\r\nreg->val = adv7511_cec_read(sd, reg->reg & 0xff);\r\nbreak;\r\n}\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7511_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nadv7511_wr(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 1:\r\nif (state->i2c_cec) {\r\nadv7511_cec_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\n}\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7511_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 hdmi_infoframe_checksum(u8 *ptr, size_t size)\r\n{\r\nu8 csum = 0;\r\nsize_t i;\r\nfor (i = 0; i < size; i++)\r\ncsum += ptr[i];\r\nreturn 256 - csum;\r\n}\r\nstatic void log_infoframe(struct v4l2_subdev *sd, const struct adv7511_cfg_read_infoframe *cri)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct device *dev = &client->dev;\r\nunion hdmi_infoframe frame;\r\nu8 buffer[32];\r\nu8 len;\r\nint i;\r\nif (!(adv7511_rd(sd, cri->present_reg) & cri->present_mask)) {\r\nv4l2_info(sd, "%s infoframe not transmitted\n", cri->desc);\r\nreturn;\r\n}\r\nmemcpy(buffer, cri->header, sizeof(cri->header));\r\nlen = buffer[2];\r\nif (len + 4 > sizeof(buffer)) {\r\nv4l2_err(sd, "%s: invalid %s infoframe length %d\n", __func__, cri->desc, len);\r\nreturn;\r\n}\r\nif (cri->payload_addr >= 0x100) {\r\nfor (i = 0; i < len; i++)\r\nbuffer[i + 4] = adv7511_pktmem_rd(sd, cri->payload_addr + i - 0x100);\r\n} else {\r\nfor (i = 0; i < len; i++)\r\nbuffer[i + 4] = adv7511_rd(sd, cri->payload_addr + i);\r\n}\r\nbuffer[3] = 0;\r\nbuffer[3] = hdmi_infoframe_checksum(buffer, len + 4);\r\nif (hdmi_infoframe_unpack(&frame, buffer) < 0) {\r\nv4l2_err(sd, "%s: unpack of %s infoframe failed\n", __func__, cri->desc);\r\nreturn;\r\n}\r\nhdmi_infoframe_log(KERN_INFO, dev, &frame);\r\n}\r\nstatic void adv7511_log_infoframes(struct v4l2_subdev *sd)\r\n{\r\nstatic const struct adv7511_cfg_read_infoframe cri[] = {\r\n{ "AVI", 0x44, 0x10, { 0x82, 2, 13 }, 0x55 },\r\n{ "Audio", 0x44, 0x08, { 0x84, 1, 10 }, 0x73 },\r\n{ "SDP", 0x40, 0x40, { 0x83, 1, 25 }, 0x103 },\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cri); i++)\r\nlog_infoframe(sd, &cri[i]);\r\n}\r\nstatic int adv7511_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct adv7511_state_edid *edid = &state->edid;\r\nint i;\r\nstatic const char * const states[] = {\r\n"in reset",\r\n"reading EDID",\r\n"idle",\r\n"initializing HDCP",\r\n"HDCP enabled",\r\n"initializing HDCP repeater",\r\n"6", "7", "8", "9", "A", "B", "C", "D", "E", "F"\r\n};\r\nstatic const char * const errors[] = {\r\n"no error",\r\n"bad receiver BKSV",\r\n"Ri mismatch",\r\n"Pj mismatch",\r\n"i2c error",\r\n"timed out",\r\n"max repeater cascade exceeded",\r\n"hash check failed",\r\n"too many devices",\r\n"9", "A", "B", "C", "D", "E", "F"\r\n};\r\nv4l2_info(sd, "power %s\n", state->power_on ? "on" : "off");\r\nv4l2_info(sd, "%s hotplug, %s Rx Sense, %s EDID (%d block(s))\n",\r\n(adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT) ? "detected" : "no",\r\n(adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT) ? "detected" : "no",\r\nedid->segments ? "found" : "no",\r\nedid->blocks);\r\nv4l2_info(sd, "%s output %s\n",\r\n(adv7511_rd(sd, 0xaf) & 0x02) ?\r\n"HDMI" : "DVI-D",\r\n(adv7511_rd(sd, 0xa1) & 0x3c) ?\r\n"disabled" : "enabled");\r\nv4l2_info(sd, "state: %s, error: %s, detect count: %u, msk/irq: %02x/%02x\n",\r\nstates[adv7511_rd(sd, 0xc8) & 0xf],\r\nerrors[adv7511_rd(sd, 0xc8) >> 4], state->edid_detect_counter,\r\nadv7511_rd(sd, 0x94), adv7511_rd(sd, 0x96));\r\nv4l2_info(sd, "RGB quantization: %s range\n", adv7511_rd(sd, 0x18) & 0x80 ? "limited" : "full");\r\nif (adv7511_rd(sd, 0xaf) & 0x02) {\r\nu8 manual_cts = adv7511_rd(sd, 0x0a) & 0x80;\r\nu32 N = (adv7511_rd(sd, 0x01) & 0xf) << 16 |\r\nadv7511_rd(sd, 0x02) << 8 |\r\nadv7511_rd(sd, 0x03);\r\nu8 vic_detect = adv7511_rd(sd, 0x3e) >> 2;\r\nu8 vic_sent = adv7511_rd(sd, 0x3d) & 0x3f;\r\nu32 CTS;\r\nif (manual_cts)\r\nCTS = (adv7511_rd(sd, 0x07) & 0xf) << 16 |\r\nadv7511_rd(sd, 0x08) << 8 |\r\nadv7511_rd(sd, 0x09);\r\nelse\r\nCTS = (adv7511_rd(sd, 0x04) & 0xf) << 16 |\r\nadv7511_rd(sd, 0x05) << 8 |\r\nadv7511_rd(sd, 0x06);\r\nv4l2_info(sd, "CTS %s mode: N %d, CTS %d\n",\r\nmanual_cts ? "manual" : "automatic", N, CTS);\r\nv4l2_info(sd, "VIC: detected %d, sent %d\n",\r\nvic_detect, vic_sent);\r\nadv7511_log_infoframes(sd);\r\n}\r\nif (state->dv_timings.type == V4L2_DV_BT_656_1120)\r\nv4l2_print_dv_timings(sd->name, "timings: ",\r\n&state->dv_timings, false);\r\nelse\r\nv4l2_info(sd, "no timings set\n");\r\nv4l2_info(sd, "i2c edid addr: 0x%x\n", state->i2c_edid_addr);\r\nif (state->i2c_cec == NULL)\r\nreturn 0;\r\nv4l2_info(sd, "i2c cec addr: 0x%x\n", state->i2c_cec_addr);\r\nv4l2_info(sd, "CEC: %s\n", state->cec_enabled_adap ?\r\n"enabled" : "disabled");\r\nif (state->cec_enabled_adap) {\r\nfor (i = 0; i < ADV7511_MAX_ADDRS; i++) {\r\nbool is_valid = state->cec_valid_addrs & (1 << i);\r\nif (is_valid)\r\nv4l2_info(sd, "CEC Logical Address: 0x%x\n",\r\nstate->cec_addr[i]);\r\n}\r\n}\r\nv4l2_info(sd, "i2c pktmem addr: 0x%x\n", state->i2c_pktmem_addr);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nconst int retries = 20;\r\nint i;\r\nv4l2_dbg(1, debug, sd, "%s: power %s\n", __func__, on ? "on" : "off");\r\nstate->power_on = on;\r\nif (!on) {\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nreturn true;\r\n}\r\nfor (i = 0; i < retries; i++) {\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x0);\r\nif ((adv7511_rd(sd, 0x41) & 0x40) == 0)\r\nbreak;\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nmsleep(10);\r\n}\r\nif (i == retries) {\r\nv4l2_dbg(1, debug, sd, "%s: failed to powerup the adv7511!\n", __func__);\r\nadv7511_s_power(sd, 0);\r\nreturn false;\r\n}\r\nif (i > 1)\r\nv4l2_dbg(1, debug, sd, "%s: needed %d retries to powerup the adv7511\n", __func__, i);\r\nadv7511_wr(sd, 0x98, 0x03);\r\nadv7511_wr_and_or(sd, 0x9a, 0xfe, 0x70);\r\nadv7511_wr(sd, 0x9c, 0x30);\r\nadv7511_wr_and_or(sd, 0x9d, 0xfc, 0x01);\r\nadv7511_wr(sd, 0xa2, 0xa4);\r\nadv7511_wr(sd, 0xa3, 0xa4);\r\nadv7511_wr(sd, 0xe0, 0xd0);\r\nadv7511_wr(sd, 0xf9, 0x00);\r\nadv7511_wr(sd, 0x43, state->i2c_edid_addr);\r\nadv7511_wr(sd, 0x45, state->i2c_pktmem_addr);\r\nadv7511_wr(sd, 0xc9, 0xf);\r\nreturn true;\r\n}\r\nstatic int adv7511_cec_adap_enable(struct cec_adapter *adap, bool enable)\r\n{\r\nstruct adv7511_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nif (state->i2c_cec == NULL)\r\nreturn -EIO;\r\nif (!state->cec_enabled_adap && enable) {\r\nadv7511_cec_write_and_or(sd, 0x4e, 0xfc, 0x01);\r\nadv7511_cec_write(sd, 0x4a, 0x07);\r\nadv7511_cec_write(sd, 0x4a, 0);\r\nadv7511_cec_write_and_or(sd, 0x11, 0xfe, 0);\r\nif (state->enabled_irq)\r\nadv7511_wr_and_or(sd, 0x95, 0xc0, 0x39);\r\n} else if (state->cec_enabled_adap && !enable) {\r\nif (state->enabled_irq)\r\nadv7511_wr_and_or(sd, 0x95, 0xc0, 0x00);\r\nadv7511_cec_write_and_or(sd, 0x4b, 0x8f, 0x00);\r\nadv7511_cec_write_and_or(sd, 0x4e, 0xfc, 0x00);\r\nstate->cec_valid_addrs = 0;\r\n}\r\nstate->cec_enabled_adap = enable;\r\nreturn 0;\r\n}\r\nstatic int adv7511_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\r\n{\r\nstruct adv7511_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nunsigned int i, free_idx = ADV7511_MAX_ADDRS;\r\nif (!state->cec_enabled_adap)\r\nreturn addr == CEC_LOG_ADDR_INVALID ? 0 : -EIO;\r\nif (addr == CEC_LOG_ADDR_INVALID) {\r\nadv7511_cec_write_and_or(sd, 0x4b, 0x8f, 0);\r\nstate->cec_valid_addrs = 0;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ADV7511_MAX_ADDRS; i++) {\r\nbool is_valid = state->cec_valid_addrs & (1 << i);\r\nif (free_idx == ADV7511_MAX_ADDRS && !is_valid)\r\nfree_idx = i;\r\nif (is_valid && state->cec_addr[i] == addr)\r\nreturn 0;\r\n}\r\nif (i == ADV7511_MAX_ADDRS) {\r\ni = free_idx;\r\nif (i == ADV7511_MAX_ADDRS)\r\nreturn -ENXIO;\r\n}\r\nstate->cec_addr[i] = addr;\r\nstate->cec_valid_addrs |= 1 << i;\r\nswitch (i) {\r\ncase 0:\r\nadv7511_cec_write_and_or(sd, 0x4b, 0xef, 0x10);\r\nadv7511_cec_write_and_or(sd, 0x4c, 0xf0, addr);\r\nbreak;\r\ncase 1:\r\nadv7511_cec_write_and_or(sd, 0x4b, 0xdf, 0x20);\r\nadv7511_cec_write_and_or(sd, 0x4c, 0x0f, addr << 4);\r\nbreak;\r\ncase 2:\r\nadv7511_cec_write_and_or(sd, 0x4b, 0xbf, 0x40);\r\nadv7511_cec_write_and_or(sd, 0x4d, 0xf0, addr);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\r\nu32 signal_free_time, struct cec_msg *msg)\r\n{\r\nstruct adv7511_state *state = adap->priv;\r\nstruct v4l2_subdev *sd = &state->sd;\r\nu8 len = msg->len;\r\nunsigned int i;\r\nv4l2_dbg(1, debug, sd, "%s: len %d\n", __func__, len);\r\nif (len > 16) {\r\nv4l2_err(sd, "%s: len exceeded 16 (%d)\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nadv7511_cec_write_and_or(sd, 0x12, ~0x70, max(1, attempts - 1) << 4);\r\nadv7511_wr_and_or(sd, 0x97, 0xc7, 0x38);\r\nfor (i = 0; i < len; i++)\r\nadv7511_cec_write(sd, i, msg->msg[i]);\r\nadv7511_cec_write(sd, 0x10, len);\r\nadv7511_cec_write(sd, 0x11, 0x01);\r\nreturn 0;\r\n}\r\nstatic void adv_cec_tx_raw_status(struct v4l2_subdev *sd, u8 tx_raw_status)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif ((adv7511_cec_read(sd, 0x11) & 0x01) == 0) {\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: tx disabled\n", __func__);\r\nreturn;\r\n}\r\nif (tx_raw_status & 0x10) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: tx raw: arbitration lost\n", __func__);\r\ncec_transmit_done(state->cec_adap, CEC_TX_STATUS_ARB_LOST,\r\n1, 0, 0, 0);\r\nreturn;\r\n}\r\nif (tx_raw_status & 0x08) {\r\nu8 status;\r\nu8 nack_cnt;\r\nu8 low_drive_cnt;\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: retry failed\n", __func__);\r\nstatus = CEC_TX_STATUS_MAX_RETRIES;\r\nnack_cnt = adv7511_cec_read(sd, 0x14) & 0xf;\r\nif (nack_cnt)\r\nstatus |= CEC_TX_STATUS_NACK;\r\nlow_drive_cnt = adv7511_cec_read(sd, 0x14) >> 4;\r\nif (low_drive_cnt)\r\nstatus |= CEC_TX_STATUS_LOW_DRIVE;\r\ncec_transmit_done(state->cec_adap, status,\r\n0, nack_cnt, low_drive_cnt, 0);\r\nreturn;\r\n}\r\nif (tx_raw_status & 0x20) {\r\nv4l2_dbg(1, debug, sd, "%s: tx raw: ready ok\n", __func__);\r\ncec_transmit_done(state->cec_adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void adv7511_set_isr(struct v4l2_subdev *sd, bool enable)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu8 irqs = MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT;\r\nu8 irqs_rd;\r\nint retries = 100;\r\nv4l2_dbg(2, debug, sd, "%s: %s\n", __func__, enable ? "enable" : "disable");\r\nif (state->enabled_irq == enable)\r\nreturn;\r\nstate->enabled_irq = enable;\r\nif (!enable)\r\nirqs = 0;\r\nelse if (adv7511_have_hotplug(sd))\r\nirqs |= MASK_ADV7511_EDID_RDY_INT;\r\nadv7511_wr_and_or(sd, 0x95, 0xc0,\r\n(state->cec_enabled_adap && enable) ? 0x39 : 0x00);\r\ndo {\r\nadv7511_wr(sd, 0x94, irqs);\r\nirqs_rd = adv7511_rd(sd, 0x94);\r\n} while (retries-- && irqs_rd != irqs);\r\nif (irqs_rd == irqs)\r\nreturn;\r\nv4l2_err(sd, "Could not set interrupts: hw failure?\n");\r\n}\r\nstatic int adv7511_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nu8 irq_status;\r\nu8 cec_irq;\r\nadv7511_set_isr(sd, false);\r\nirq_status = adv7511_rd(sd, 0x96);\r\ncec_irq = adv7511_rd(sd, 0x97);\r\nadv7511_wr(sd, 0x96, irq_status);\r\nadv7511_wr(sd, 0x97, cec_irq);\r\nv4l2_dbg(1, debug, sd, "%s: irq 0x%x, cec-irq 0x%x\n", __func__,\r\nirq_status, cec_irq);\r\nif (irq_status & (MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT))\r\nadv7511_check_monitor_present_status(sd);\r\nif (irq_status & MASK_ADV7511_EDID_RDY_INT)\r\nadv7511_check_edid_status(sd);\r\n#if IS_ENABLED(CONFIG_VIDEO_ADV7511_CEC)\r\nif (cec_irq & 0x38)\r\nadv_cec_tx_raw_status(sd, cec_irq);\r\nif (cec_irq & 1) {\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct cec_msg msg;\r\nmsg.len = adv7511_cec_read(sd, 0x25) & 0x1f;\r\nv4l2_dbg(1, debug, sd, "%s: cec msg len %d\n", __func__,\r\nmsg.len);\r\nif (msg.len > 16)\r\nmsg.len = 16;\r\nif (msg.len) {\r\nu8 i;\r\nfor (i = 0; i < msg.len; i++)\r\nmsg.msg[i] = adv7511_cec_read(sd, i + 0x15);\r\nadv7511_cec_write(sd, 0x4a, 1);\r\nadv7511_cec_write(sd, 0x4a, 0);\r\ncec_received_msg(state->cec_adap, &msg);\r\n}\r\n}\r\n#endif\r\nadv7511_set_isr(sd, true);\r\nif (handled)\r\n*handled = true;\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nadv7511_wr_and_or(sd, 0xa1, ~0x3c, (enable ? 0 : 0x3c));\r\nif (enable) {\r\nadv7511_check_monitor_present_status(sd);\r\n} else {\r\nadv7511_s_power(sd, 0);\r\nstate->have_monitor = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nu32 fps;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!v4l2_valid_dv_timings(timings, &adv7511_timings_cap, NULL, NULL))\r\nreturn -EINVAL;\r\nv4l2_find_dv_timings_cap(timings, &adv7511_timings_cap, 0, NULL, NULL);\r\nstate->dv_timings = *timings;\r\nadv7511_wr_and_or(sd, 0x17, 0x9f,\r\n((bt->polarities & V4L2_DV_VSYNC_POS_POL) ? 0 : 0x40) |\r\n((bt->polarities & V4L2_DV_HSYNC_POS_POL) ? 0 : 0x20));\r\nfps = (u32)bt->pixelclock / (V4L2_DV_BT_FRAME_WIDTH(bt) * V4L2_DV_BT_FRAME_HEIGHT(bt));\r\nswitch (fps) {\r\ncase 24:\r\nadv7511_wr_and_or(sd, 0xfb, 0xf9, 1 << 1);\r\nbreak;\r\ncase 25:\r\nadv7511_wr_and_or(sd, 0xfb, 0xf9, 2 << 1);\r\nbreak;\r\ncase 30:\r\nadv7511_wr_and_or(sd, 0xfb, 0xf9, 3 << 1);\r\nbreak;\r\ndefault:\r\nadv7511_wr_and_or(sd, 0xfb, 0xf9, 0);\r\nbreak;\r\n}\r\nadv7511_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\r\nreturn 0;\r\n}\r\nstatic int adv7511_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!timings)\r\nreturn -EINVAL;\r\n*timings = state->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int adv7511_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\nreturn v4l2_enum_dv_timings_cap(timings, &adv7511_timings_cap, NULL, NULL);\r\n}\r\nstatic int adv7511_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nif (cap->pad != 0)\r\nreturn -EINVAL;\r\n*cap = adv7511_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_audio_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nif (enable)\r\nadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x80);\r\nelse\r\nadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x40);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 N;\r\nswitch (freq) {\r\ncase 32000: N = 4096; break;\r\ncase 44100: N = 6272; break;\r\ncase 48000: N = 6144; break;\r\ncase 88200: N = 12544; break;\r\ncase 96000: N = 12288; break;\r\ncase 176400: N = 25088; break;\r\ncase 192000: N = 24576; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadv7511_wr(sd, 0x01, (N >> 16) & 0xf);\r\nadv7511_wr(sd, 0x02, (N >> 8) & 0xff);\r\nadv7511_wr(sd, 0x03, N & 0xff);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 i2s_sf;\r\nswitch (freq) {\r\ncase 32000: i2s_sf = 0x30; break;\r\ncase 44100: i2s_sf = 0x00; break;\r\ncase 48000: i2s_sf = 0x20; break;\r\ncase 88200: i2s_sf = 0x80; break;\r\ncase 96000: i2s_sf = 0xa0; break;\r\ncase 176400: i2s_sf = 0xc0; break;\r\ncase 192000: i2s_sf = 0xe0; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadv7511_wr_and_or(sd, 0x15, 0xf, i2s_sf);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)\r\n{\r\nadv7511_wr_and_or(sd, 0x73, 0xf8, 0x1);\r\nadv7511_wr(sd, 0x76, 0x00);\r\nadv7511_wr_and_or(sd, 0x14, 0xf0, 0x02);\r\nreturn 0;\r\n}\r\nstatic int adv7511_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nmemset(edid->reserved, 0, sizeof(edid->reserved));\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->start_block == 0 && edid->blocks == 0) {\r\nedid->blocks = state->edid.segments * 2;\r\nreturn 0;\r\n}\r\nif (state->edid.segments == 0)\r\nreturn -ENODATA;\r\nif (edid->start_block >= state->edid.segments * 2)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > state->edid.segments * 2)\r\nedid->blocks = state->edid.segments * 2 - edid->start_block;\r\nmemcpy(edid->edid, &state->edid.data[edid->start_block * 128],\r\n128 * edid->blocks);\r\nreturn 0;\r\n}\r\nstatic int adv7511_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad != 0)\r\nreturn -EINVAL;\r\nswitch (code->index) {\r\ncase 0:\r\ncode->code = MEDIA_BUS_FMT_RGB888_1X24;\r\nbreak;\r\ncase 1:\r\ncode->code = MEDIA_BUS_FMT_YUYV8_1X16;\r\nbreak;\r\ncase 2:\r\ncode->code = MEDIA_BUS_FMT_UYVY8_1X16;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adv7511_fill_format(struct adv7511_state *state,\r\nstruct v4l2_mbus_framefmt *format)\r\n{\r\nformat->width = state->dv_timings.bt.width;\r\nformat->height = state->dv_timings.bt.height;\r\nformat->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int adv7511_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif (format->pad != 0)\r\nreturn -EINVAL;\r\nmemset(&format->format, 0, sizeof(format->format));\r\nadv7511_fill_format(state, &format->format);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nformat->format.code = fmt->code;\r\nformat->format.colorspace = fmt->colorspace;\r\nformat->format.ycbcr_enc = fmt->ycbcr_enc;\r\nformat->format.quantization = fmt->quantization;\r\nformat->format.xfer_func = fmt->xfer_func;\r\n} else {\r\nformat->format.code = state->fmt_code;\r\nformat->format.colorspace = state->colorspace;\r\nformat->format.ycbcr_enc = state->ycbcr_enc;\r\nformat->format.quantization = state->quantization;\r\nformat->format.xfer_func = state->xfer_func;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu8 c = HDMI_COLORIMETRY_NONE;\r\nu8 ec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\r\nu8 y = HDMI_COLORSPACE_RGB;\r\nu8 q = HDMI_QUANTIZATION_RANGE_DEFAULT;\r\nu8 yq = HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\r\nu8 itc = state->content_type != V4L2_DV_IT_CONTENT_TYPE_NO_ITC;\r\nu8 cn = itc ? state->content_type : V4L2_DV_IT_CONTENT_TYPE_GRAPHICS;\r\nif (format->pad != 0)\r\nreturn -EINVAL;\r\nswitch (format->format.code) {\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadv7511_fill_format(state, &format->format);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nstruct v4l2_mbus_framefmt *fmt;\r\nfmt = v4l2_subdev_get_try_format(sd, cfg, format->pad);\r\nfmt->code = format->format.code;\r\nfmt->colorspace = format->format.colorspace;\r\nfmt->ycbcr_enc = format->format.ycbcr_enc;\r\nfmt->quantization = format->format.quantization;\r\nfmt->xfer_func = format->format.xfer_func;\r\nreturn 0;\r\n}\r\nswitch (format->format.code) {\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nadv7511_wr_and_or(sd, 0x15, 0xf0, 0x01);\r\nadv7511_wr_and_or(sd, 0x16, 0x03, 0xb8);\r\ny = HDMI_COLORSPACE_YUV422;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nadv7511_wr_and_or(sd, 0x15, 0xf0, 0x01);\r\nadv7511_wr_and_or(sd, 0x16, 0x03, 0xbc);\r\ny = HDMI_COLORSPACE_YUV422;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\ndefault:\r\nadv7511_wr_and_or(sd, 0x15, 0xf0, 0x00);\r\nadv7511_wr_and_or(sd, 0x16, 0x03, 0x00);\r\nbreak;\r\n}\r\nstate->fmt_code = format->format.code;\r\nstate->colorspace = format->format.colorspace;\r\nstate->ycbcr_enc = format->format.ycbcr_enc;\r\nstate->quantization = format->format.quantization;\r\nstate->xfer_func = format->format.xfer_func;\r\nswitch (format->format.colorspace) {\r\ncase V4L2_COLORSPACE_ADOBERGB:\r\nc = HDMI_COLORIMETRY_EXTENDED;\r\nec = y ? HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601 :\r\nHDMI_EXTENDED_COLORIMETRY_ADOBE_RGB;\r\nbreak;\r\ncase V4L2_COLORSPACE_SMPTE170M:\r\nc = y ? HDMI_COLORIMETRY_ITU_601 : HDMI_COLORIMETRY_NONE;\r\nif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_XV601) {\r\nc = HDMI_COLORIMETRY_EXTENDED;\r\nec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\r\n}\r\nbreak;\r\ncase V4L2_COLORSPACE_REC709:\r\nc = y ? HDMI_COLORIMETRY_ITU_709 : HDMI_COLORIMETRY_NONE;\r\nif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_XV709) {\r\nc = HDMI_COLORIMETRY_EXTENDED;\r\nec = HDMI_EXTENDED_COLORIMETRY_XV_YCC_709;\r\n}\r\nbreak;\r\ncase V4L2_COLORSPACE_SRGB:\r\nc = y ? HDMI_COLORIMETRY_EXTENDED : HDMI_COLORIMETRY_NONE;\r\nec = y ? HDMI_EXTENDED_COLORIMETRY_S_YCC_601 :\r\nHDMI_EXTENDED_COLORIMETRY_XV_YCC_601;\r\nbreak;\r\ncase V4L2_COLORSPACE_BT2020:\r\nc = HDMI_COLORIMETRY_EXTENDED;\r\nif (y && format->format.ycbcr_enc == V4L2_YCBCR_ENC_BT2020_CONST_LUM)\r\nec = 5;\r\nelse\r\nec = 6;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (format->format.quantization) {\r\ncase V4L2_QUANTIZATION_FULL_RANGE:\r\nq = y ? HDMI_QUANTIZATION_RANGE_DEFAULT :\r\nHDMI_QUANTIZATION_RANGE_FULL;\r\nyq = q ? q - 1 : HDMI_YCC_QUANTIZATION_RANGE_FULL;\r\nbreak;\r\ncase V4L2_QUANTIZATION_LIM_RANGE:\r\nq = y ? HDMI_QUANTIZATION_RANGE_DEFAULT :\r\nHDMI_QUANTIZATION_RANGE_LIMITED;\r\nyq = q ? q - 1 : HDMI_YCC_QUANTIZATION_RANGE_LIMITED;\r\nbreak;\r\n}\r\nadv7511_wr_and_or(sd, 0x4a, 0xbf, 0);\r\nadv7511_wr_and_or(sd, 0x55, 0x9f, y << 5);\r\nadv7511_wr_and_or(sd, 0x56, 0x3f, c << 6);\r\nadv7511_wr_and_or(sd, 0x57, 0x83, (ec << 4) | (q << 2) | (itc << 7));\r\nadv7511_wr_and_or(sd, 0x59, 0x0f, (yq << 6) | (cn << 4));\r\nadv7511_wr_and_or(sd, 0x4a, 0xff, 1);\r\nadv7511_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\r\nreturn 0;\r\n}\r\nstatic void adv7511_dbg_dump_edid(int lvl, int debug, struct v4l2_subdev *sd, int segment, u8 *buf)\r\n{\r\nif (debug >= lvl) {\r\nint i, j;\r\nv4l2_dbg(lvl, debug, sd, "edid segment %d\n", segment);\r\nfor (i = 0; i < 256; i += 16) {\r\nu8 b[128];\r\nu8 *bp = b;\r\nif (i == 128)\r\nv4l2_dbg(lvl, debug, sd, "\n");\r\nfor (j = i; j < i + 16; j++) {\r\nsprintf(bp, "0x%02x, ", buf[j]);\r\nbp += 6;\r\n}\r\nbp[0] = '\0';\r\nv4l2_dbg(lvl, debug, sd, "%s\n", b);\r\n}\r\n}\r\n}\r\nstatic void adv7511_notify_no_edid(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct adv7511_edid_detect ed;\r\ned.present = false;\r\ned.segment = adv7511_rd(sd, 0xc4);\r\ned.phys_addr = CEC_PHYS_ADDR_INVALID;\r\ncec_s_phys_addr(state->cec_adap, ed.phys_addr, false);\r\nv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, 0x0);\r\n}\r\nstatic void adv7511_edid_handler(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct adv7511_state *state = container_of(dwork, struct adv7511_state, edid_handler);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (adv7511_check_edid_status(sd)) {\r\nreturn;\r\n}\r\nif (adv7511_have_hotplug(sd)) {\r\nif (state->edid.read_retries) {\r\nstate->edid.read_retries--;\r\nv4l2_dbg(1, debug, sd, "%s: edid read failed\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_s_power(sd, false);\r\nadv7511_s_power(sd, true);\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\nreturn;\r\n}\r\n}\r\nadv7511_notify_no_edid(sd);\r\nv4l2_dbg(1, debug, sd, "%s: no edid found\n", __func__);\r\n}\r\nstatic void adv7511_audio_setup(struct v4l2_subdev *sd)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_s_i2s_clock_freq(sd, 48000);\r\nadv7511_s_clock_freq(sd, 48000);\r\nadv7511_s_routing(sd, 0, 0, 0);\r\n}\r\nstatic void adv7511_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_wr_and_or(sd, 0x15, 0xf0, 0x0);\r\nadv7511_wr_and_or(sd, 0x16, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x17, 0xf9, 0x06);\r\nadv7511_wr_and_or(sd, 0x3b, 0x9f, 0x0);\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x55, 0x9c, 0x12);\r\nadv7511_wr_and_or(sd, 0x44, 0xe7, 0x10);\r\nadv7511_wr(sd, 0x56, 0xa8);\r\nadv7511_wr_and_or(sd, 0xaf, 0xed, 0x0);\r\nadv7511_wr_and_or(sd, 0xba, 0x1f, 0x60);\r\nadv7511_audio_setup(sd);\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\n}\r\nstatic void adv7511_notify_monitor_detect(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_monitor_detect mdt;\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nmdt.present = state->have_monitor;\r\nv4l2_subdev_notify(sd, ADV7511_MONITOR_DETECT, (void *)&mdt);\r\n}\r\nstatic void adv7511_check_monitor_present_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu8 status = adv7511_rd(sd, 0x42);\r\nv4l2_dbg(1, debug, sd, "%s: status: 0x%x%s%s\n",\r\n__func__,\r\nstatus,\r\nstatus & MASK_ADV7511_HPD_DETECT ? ", hotplug" : "",\r\nstatus & MASK_ADV7511_MSEN_DETECT ? ", rx-sense" : "");\r\nv4l2_ctrl_s_ctrl(state->hotplug_ctrl, adv7511_have_hotplug(sd) ? 0x1 : 0x0);\r\nv4l2_ctrl_s_ctrl(state->rx_sense_ctrl, adv7511_have_rx_sense(sd) ? 0x1 : 0x0);\r\nif ((status & MASK_ADV7511_HPD_DETECT) && ((status & MASK_ADV7511_MSEN_DETECT) || state->edid.segments)) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug and (rx-sense or edid)\n", __func__);\r\nif (!state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor detected\n", __func__);\r\nstate->have_monitor = true;\r\nadv7511_set_isr(sd, true);\r\nif (!adv7511_s_power(sd, true)) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor detected, powerup failed\n", __func__);\r\nreturn;\r\n}\r\nadv7511_setup(sd);\r\nadv7511_notify_monitor_detect(sd);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\n}\r\n} else if (status & MASK_ADV7511_HPD_DETECT) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug detected\n", __func__);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\n} else if (!(status & MASK_ADV7511_HPD_DETECT)) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug not detected\n", __func__);\r\nif (state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor not detected\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_notify_monitor_detect(sd);\r\n}\r\nadv7511_s_power(sd, false);\r\nmemset(&state->edid, 0, sizeof(struct adv7511_state_edid));\r\nadv7511_notify_no_edid(sd);\r\n}\r\n}\r\nstatic bool edid_block_verify_crc(u8 *edid_block)\r\n{\r\nu8 sum = 0;\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\nsum += edid_block[i];\r\nreturn sum == 0;\r\n}\r\nstatic bool edid_verify_crc(struct v4l2_subdev *sd, u32 segment)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu32 blocks = state->edid.blocks;\r\nu8 *data = state->edid.data;\r\nif (!edid_block_verify_crc(&data[segment * 256]))\r\nreturn false;\r\nif ((segment + 1) * 2 <= blocks)\r\nreturn edid_block_verify_crc(&data[segment * 256 + 128]);\r\nreturn true;\r\n}\r\nstatic bool edid_verify_header(struct v4l2_subdev *sd, u32 segment)\r\n{\r\nstatic const u8 hdmi_header[] = {\r\n0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00\r\n};\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu8 *data = state->edid.data;\r\nif (segment != 0)\r\nreturn true;\r\nreturn !memcmp(data, hdmi_header, sizeof(hdmi_header));\r\n}\r\nstatic bool adv7511_check_edid_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu8 edidRdy = adv7511_rd(sd, 0xc5);\r\nv4l2_dbg(1, debug, sd, "%s: edid ready (retries: %d)\n",\r\n__func__, EDID_MAX_RETRIES - state->edid.read_retries);\r\nif (state->edid.complete)\r\nreturn true;\r\nif (edidRdy & MASK_ADV7511_EDID_RDY) {\r\nint segment = adv7511_rd(sd, 0xc4);\r\nstruct adv7511_edid_detect ed;\r\nif (segment >= EDID_MAX_SEGM) {\r\nv4l2_err(sd, "edid segment number too big\n");\r\nreturn false;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: got segment %d\n", __func__, segment);\r\nadv7511_edid_rd(sd, 256, &state->edid.data[segment * 256]);\r\nadv7511_dbg_dump_edid(2, debug, sd, segment, &state->edid.data[segment * 256]);\r\nif (segment == 0) {\r\nstate->edid.blocks = state->edid.data[0x7e] + 1;\r\nv4l2_dbg(1, debug, sd, "%s: %d blocks in total\n", __func__, state->edid.blocks);\r\n}\r\nif (!edid_verify_crc(sd, segment) ||\r\n!edid_verify_header(sd, segment)) {\r\nv4l2_err(sd, "%s: edid crc or header error\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_s_power(sd, false);\r\nadv7511_s_power(sd, true);\r\nreturn false;\r\n}\r\nstate->edid.segments = segment + 1;\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, 0x1);\r\nif (((state->edid.data[0x7e] >> 1) + 1) > state->edid.segments) {\r\nv4l2_dbg(1, debug, sd, "%s: request segment %d\n", __func__, state->edid.segments);\r\nadv7511_wr(sd, 0xc9, 0xf);\r\nadv7511_wr(sd, 0xc4, state->edid.segments);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\nreturn false;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: edid complete with %d segment(s)\n", __func__, state->edid.segments);\r\nstate->edid.complete = true;\r\ned.phys_addr = cec_get_edid_phys_addr(state->edid.data,\r\nstate->edid.segments * 256,\r\nNULL);\r\ned.present = true;\r\ned.segment = 0;\r\nstate->edid_detect_counter++;\r\ncec_s_phys_addr(state->cec_adap, ed.phys_addr, false);\r\nv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\r\nreturn ed.present;\r\n}\r\nreturn false;\r\n}\r\nstatic int adv7511_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint err;\r\nerr = cec_register_adapter(state->cec_adap, &client->dev);\r\nif (err)\r\ncec_delete_adapter(state->cec_adap);\r\nreturn err;\r\n}\r\nstatic void adv7511_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\ncec_unregister_adapter(state->cec_adap);\r\n}\r\nstatic void adv7511_init_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct adv7511_state_edid *edid = &state->edid;\r\nu32 cec_clk = state->pdata.cec_clk;\r\nu8 ratio;\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_wr(sd, 0x96, 0xff);\r\nadv7511_wr(sd, 0x97, 0xff);\r\nadv7511_wr_and_or(sd, 0xd6, 0x3f, 0xc0);\r\nmemset(edid, 0, sizeof(struct adv7511_state_edid));\r\nstate->have_monitor = false;\r\nadv7511_set_isr(sd, false);\r\nadv7511_s_stream(sd, false);\r\nadv7511_s_audio_stream(sd, false);\r\nif (state->i2c_cec == NULL)\r\nreturn;\r\nv4l2_dbg(1, debug, sd, "%s: cec_clk %d\n", __func__, cec_clk);\r\nadv7511_cec_write(sd, 0x50, 0x01);\r\nadv7511_cec_write(sd, 0x50, 0x00);\r\nadv7511_cec_write(sd, 0x4a, 0x00);\r\nif (cec_clk % 750000 != 0)\r\nv4l2_err(sd, "%s: cec_clk %d, not multiple of 750 Khz\n",\r\n__func__, cec_clk);\r\nratio = (cec_clk / 750000) - 1;\r\nadv7511_cec_write(sd, 0x4e, ratio << 2);\r\n}\r\nstatic int adv7511_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct adv7511_state *state;\r\nstruct adv7511_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nu8 chip_id[2];\r\nint err = -EIO;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nstate = devm_kzalloc(&client->dev, sizeof(struct adv7511_state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nif (!pdata) {\r\nv4l_err(client, "No platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(&state->pdata, pdata, sizeof(state->pdata));\r\nstate->fmt_code = MEDIA_BUS_FMT_RGB888_1X24;\r\nstate->colorspace = V4L2_COLORSPACE_SRGB;\r\nsd = &state->sd;\r\nv4l2_dbg(1, debug, sd, "detecting adv7511 client on address 0x%x\n",\r\nclient->addr << 1);\r\nv4l2_i2c_subdev_init(sd, client, &adv7511_ops);\r\nsd->internal_ops = &adv7511_int_ops;\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 10);\r\nstate->hdmi_mode_ctrl = v4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\r\nV4L2_CID_DV_TX_MODE, V4L2_DV_TX_MODE_HDMI,\r\n0, V4L2_DV_TX_MODE_DVI_D);\r\nstate->hotplug_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_HOTPLUG, 0, 1, 0, 0);\r\nstate->rx_sense_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_RXSENSE, 0, 1, 0, 0);\r\nstate->have_edid0_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_EDID_PRESENT, 0, 1, 0, 0);\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\r\nV4L2_CID_DV_TX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nstate->content_type_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\r\nV4L2_CID_DV_TX_IT_CONTENT_TYPE, V4L2_DV_IT_CONTENT_TYPE_NO_ITC,\r\n0, V4L2_DV_IT_CONTENT_TYPE_NO_ITC);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nstate->pad.flags = MEDIA_PAD_FL_SINK;\r\nerr = media_entity_pads_init(&sd->entity, 1, &state->pad);\r\nif (err)\r\ngoto err_hdl;\r\nstate->i2c_edid_addr = state->pdata.i2c_edid << 1;\r\nstate->i2c_cec_addr = state->pdata.i2c_cec << 1;\r\nstate->i2c_pktmem_addr = state->pdata.i2c_pktmem << 1;\r\nstate->chip_revision = adv7511_rd(sd, 0x0);\r\nchip_id[0] = adv7511_rd(sd, 0xf5);\r\nchip_id[1] = adv7511_rd(sd, 0xf6);\r\nif (chip_id[0] != 0x75 || chip_id[1] != 0x11) {\r\nv4l2_err(sd, "chip_id != 0x7511, read 0x%02x%02x\n", chip_id[0],\r\nchip_id[1]);\r\nerr = -EIO;\r\ngoto err_entity;\r\n}\r\nstate->i2c_edid = i2c_new_dummy(client->adapter,\r\nstate->i2c_edid_addr >> 1);\r\nif (state->i2c_edid == NULL) {\r\nv4l2_err(sd, "failed to register edid i2c client\n");\r\nerr = -ENOMEM;\r\ngoto err_entity;\r\n}\r\nadv7511_wr(sd, 0xe1, state->i2c_cec_addr);\r\nif (state->pdata.cec_clk < 3000000 ||\r\nstate->pdata.cec_clk > 100000000) {\r\nv4l2_err(sd, "%s: cec_clk %u outside range, disabling cec\n",\r\n__func__, state->pdata.cec_clk);\r\nstate->pdata.cec_clk = 0;\r\n}\r\nif (state->pdata.cec_clk) {\r\nstate->i2c_cec = i2c_new_dummy(client->adapter,\r\nstate->i2c_cec_addr >> 1);\r\nif (state->i2c_cec == NULL) {\r\nv4l2_err(sd, "failed to register cec i2c client\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg_edid;\r\n}\r\nadv7511_wr(sd, 0xe2, 0x00);\r\n} else {\r\nadv7511_wr(sd, 0xe2, 0x01);\r\n}\r\nstate->i2c_pktmem = i2c_new_dummy(client->adapter, state->i2c_pktmem_addr >> 1);\r\nif (state->i2c_pktmem == NULL) {\r\nv4l2_err(sd, "failed to register pktmem i2c client\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg_cec;\r\n}\r\nstate->work_queue = create_singlethread_workqueue(sd->name);\r\nif (state->work_queue == NULL) {\r\nv4l2_err(sd, "could not create workqueue\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg_pktmem;\r\n}\r\nINIT_DELAYED_WORK(&state->edid_handler, adv7511_edid_handler);\r\nadv7511_init_setup(sd);\r\n#if IS_ENABLED(CONFIG_VIDEO_ADV7511_CEC)\r\nstate->cec_adap = cec_allocate_adapter(&adv7511_cec_adap_ops,\r\nstate, dev_name(&client->dev), CEC_CAP_TRANSMIT |\r\nCEC_CAP_LOG_ADDRS | CEC_CAP_PASSTHROUGH | CEC_CAP_RC,\r\nADV7511_MAX_ADDRS);\r\nerr = PTR_ERR_OR_ZERO(state->cec_adap);\r\nif (err) {\r\ndestroy_workqueue(state->work_queue);\r\ngoto err_unreg_pktmem;\r\n}\r\n#endif\r\nadv7511_set_isr(sd, true);\r\nadv7511_check_monitor_present_status(sd);\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_unreg_pktmem:\r\ni2c_unregister_device(state->i2c_pktmem);\r\nerr_unreg_cec:\r\nif (state->i2c_cec)\r\ni2c_unregister_device(state->i2c_cec);\r\nerr_unreg_edid:\r\ni2c_unregister_device(state->i2c_edid);\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nstatic int adv7511_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstate->chip_revision = -1;\r\nv4l2_dbg(1, debug, sd, "%s removed @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nadv7511_set_isr(sd, false);\r\nadv7511_init_setup(sd);\r\ncancel_delayed_work(&state->edid_handler);\r\ni2c_unregister_device(state->i2c_edid);\r\nif (state->i2c_cec)\r\ni2c_unregister_device(state->i2c_cec);\r\ni2c_unregister_device(state->i2c_pktmem);\r\ndestroy_workqueue(state->work_queue);\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
