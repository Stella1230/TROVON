static int usage_id_cmp(const void *p1, const void *p2)\r\n{\r\nif (*(int *)p1 < *(int *)p2)\r\nreturn -1;\r\nif (*(int *)p1 > *(int *)p2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t enable_sensor_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\r\nreturn sprintf(buf, "%d\n", sensor_inst->enable);\r\n}\r\nstatic int set_power_report_state(struct hid_sensor_custom *sensor_inst,\r\nbool state)\r\n{\r\nint power_val = -1;\r\nint report_val = -1;\r\nu32 power_state_usage_id;\r\nu32 report_state_usage_id;\r\nint ret;\r\nif (state) {\r\npower_state_usage_id =\r\nHID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM;\r\nreport_state_usage_id =\r\nHID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM;\r\n} else {\r\npower_state_usage_id =\r\nHID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM;\r\nreport_state_usage_id =\r\nHID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM;\r\n}\r\nif (sensor_inst->power_state)\r\npower_val = hid_sensor_get_usage_index(sensor_inst->hsdev,\r\nsensor_inst->power_state->attribute.report_id,\r\nsensor_inst->power_state->attribute.index,\r\npower_state_usage_id);\r\nif (sensor_inst->report_state)\r\nreport_val = hid_sensor_get_usage_index(sensor_inst->hsdev,\r\nsensor_inst->report_state->attribute.report_id,\r\nsensor_inst->report_state->attribute.index,\r\nreport_state_usage_id);\r\nif (power_val >= 0) {\r\npower_val +=\r\nsensor_inst->power_state->attribute.logical_minimum;\r\nret = sensor_hub_set_feature(sensor_inst->hsdev,\r\nsensor_inst->power_state->attribute.report_id,\r\nsensor_inst->power_state->attribute.index,\r\nsizeof(power_val),\r\n&power_val);\r\nif (ret) {\r\nhid_err(sensor_inst->hsdev->hdev,\r\n"Set power state failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (report_val >= 0) {\r\nreport_val +=\r\nsensor_inst->report_state->attribute.logical_minimum;\r\nret = sensor_hub_set_feature(sensor_inst->hsdev,\r\nsensor_inst->report_state->attribute.report_id,\r\nsensor_inst->report_state->attribute.index,\r\nsizeof(report_val),\r\n&report_val);\r\nif (ret) {\r\nhid_err(sensor_inst->hsdev->hdev,\r\n"Set report state failed\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t enable_sensor_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\r\nint value;\r\nint ret = -EINVAL;\r\nif (kstrtoint(buf, 0, &value) != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&sensor_inst->mutex);\r\nif (value && !sensor_inst->enable) {\r\nret = sensor_hub_device_open(sensor_inst->hsdev);\r\nif (ret)\r\ngoto unlock_state;\r\nret = set_power_report_state(sensor_inst, true);\r\nif (ret) {\r\nsensor_hub_device_close(sensor_inst->hsdev);\r\ngoto unlock_state;\r\n}\r\nsensor_inst->enable = true;\r\n} else if (!value && sensor_inst->enable) {\r\nret = set_power_report_state(sensor_inst, false);\r\nsensor_hub_device_close(sensor_inst->hsdev);\r\nsensor_inst->enable = false;\r\n}\r\nunlock_state:\r\nmutex_unlock(&sensor_inst->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_value(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\r\nstruct hid_sensor_hub_attribute_info *attribute;\r\nint index, usage, field_index;\r\nchar name[HID_CUSTOM_NAME_LENGTH];\r\nbool feature = false;\r\nbool input = false;\r\nint value = 0;\r\nif (sscanf(attr->attr.name, "feature-%x-%x-%s", &index, &usage,\r\nname) == 3) {\r\nfeature = true;\r\nfield_index = index + sensor_inst->input_field_count;\r\n} else if (sscanf(attr->attr.name, "input-%x-%x-%s", &index, &usage,\r\nname) == 3) {\r\ninput = true;\r\nfield_index = index;\r\n} else\r\nreturn -EINVAL;\r\nif (!strncmp(name, "value", strlen("value"))) {\r\nu32 report_id;\r\nint ret;\r\nattribute = &sensor_inst->fields[field_index].attribute;\r\nreport_id = attribute->report_id;\r\nif (feature) {\r\nu8 values[HID_CUSTOM_MAX_FEATURE_BYTES];\r\nint len = 0;\r\nu64 value = 0;\r\nint i = 0;\r\nret = sensor_hub_get_feature(sensor_inst->hsdev,\r\nreport_id,\r\nindex,\r\nsizeof(values), values);\r\nif (ret < 0)\r\nreturn ret;\r\nwhile (i < ret) {\r\nif (i + attribute->size > ret) {\r\nlen += snprintf(&buf[len],\r\nPAGE_SIZE - len,\r\n"%d ", values[i]);\r\nbreak;\r\n}\r\nswitch (attribute->size) {\r\ncase 2:\r\nvalue = (u64) *(u16 *)&values[i];\r\ni += attribute->size;\r\nbreak;\r\ncase 4:\r\nvalue = (u64) *(u32 *)&values[i];\r\ni += attribute->size;\r\nbreak;\r\ncase 8:\r\nvalue = *(u64 *)&values[i];\r\ni += attribute->size;\r\nbreak;\r\ndefault:\r\nvalue = (u64) values[i];\r\n++i;\r\nbreak;\r\n}\r\nlen += snprintf(&buf[len], PAGE_SIZE - len,\r\n"%lld ", value);\r\n}\r\nlen += snprintf(&buf[len], PAGE_SIZE - len, "\n");\r\nreturn len;\r\n} else if (input)\r\nvalue = sensor_hub_input_attr_get_raw_value(\r\nsensor_inst->hsdev,\r\nsensor_inst->hsdev->usage,\r\nusage, report_id,\r\nSENSOR_HUB_SYNC);\r\n} else if (!strncmp(name, "units", strlen("units")))\r\nvalue = sensor_inst->fields[field_index].attribute.units;\r\nelse if (!strncmp(name, "unit-expo", strlen("unit-expo")))\r\nvalue = sensor_inst->fields[field_index].attribute.unit_expo;\r\nelse if (!strncmp(name, "size", strlen("size")))\r\nvalue = sensor_inst->fields[field_index].attribute.size;\r\nelse if (!strncmp(name, "minimum", strlen("minimum")))\r\nvalue = sensor_inst->fields[field_index].attribute.\r\nlogical_minimum;\r\nelse if (!strncmp(name, "maximum", strlen("maximum")))\r\nvalue = sensor_inst->fields[field_index].attribute.\r\nlogical_maximum;\r\nelse if (!strncmp(name, "name", strlen("name"))) {\r\nstruct hid_custom_usage_desc *usage_desc;\r\nusage_desc = bsearch(&usage, hid_custom_usage_desc_table,\r\nARRAY_SIZE(hid_custom_usage_desc_table),\r\nsizeof(struct hid_custom_usage_desc),\r\nusage_id_cmp);\r\nif (usage_desc)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\nusage_desc->desc);\r\nelse\r\nreturn sprintf(buf, "not-specified\n");\r\n} else\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic ssize_t store_value(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\r\nint index, field_index, usage;\r\nchar name[HID_CUSTOM_NAME_LENGTH];\r\nint value;\r\nif (sscanf(attr->attr.name, "feature-%x-%x-%s", &index, &usage,\r\nname) == 3) {\r\nfield_index = index + sensor_inst->input_field_count;\r\n} else\r\nreturn -EINVAL;\r\nif (!strncmp(name, "value", strlen("value"))) {\r\nu32 report_id;\r\nint ret;\r\nif (kstrtoint(buf, 0, &value) != 0)\r\nreturn -EINVAL;\r\nreport_id = sensor_inst->fields[field_index].attribute.\r\nreport_id;\r\nret = sensor_hub_set_feature(sensor_inst->hsdev, report_id,\r\nindex, sizeof(value), &value);\r\n} else\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int hid_sensor_capture_sample(struct hid_sensor_hub_device *hsdev,\r\nunsigned usage_id, size_t raw_len,\r\nchar *raw_data, void *priv)\r\n{\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(priv);\r\nstruct hid_sensor_sample header;\r\nif (sensor_inst->input_skip_sample) {\r\nhid_err(sensor_inst->hsdev->hdev, "Skipped remaining data\n");\r\nreturn 0;\r\n}\r\nhid_dbg(sensor_inst->hsdev->hdev, "%s received %d of %d\n", __func__,\r\n(int) (sensor_inst->input_report_recd_size + raw_len),\r\nsensor_inst->input_report_size);\r\nif (!test_bit(0, &sensor_inst->misc_opened))\r\nreturn 0;\r\nif (!sensor_inst->input_report_recd_size) {\r\nint required_size = sizeof(struct hid_sensor_sample) +\r\nsensor_inst->input_report_size;\r\nheader.usage_id = hsdev->usage;\r\nheader.raw_len = sensor_inst->input_report_size;\r\nheader.timestamp = ktime_get_real_ns();\r\nif (kfifo_avail(&sensor_inst->data_fifo) >= required_size) {\r\nkfifo_in(&sensor_inst->data_fifo,\r\n(unsigned char *)&header,\r\nsizeof(header));\r\n} else\r\nsensor_inst->input_skip_sample = true;\r\n}\r\nif (kfifo_avail(&sensor_inst->data_fifo) >= raw_len)\r\nkfifo_in(&sensor_inst->data_fifo, (unsigned char *)raw_data,\r\nraw_len);\r\nsensor_inst->input_report_recd_size += raw_len;\r\nreturn 0;\r\n}\r\nstatic int hid_sensor_send_event(struct hid_sensor_hub_device *hsdev,\r\nunsigned usage_id, void *priv)\r\n{\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(priv);\r\nif (!test_bit(0, &sensor_inst->misc_opened))\r\nreturn 0;\r\nsensor_inst->input_report_recd_size = 0;\r\nsensor_inst->input_skip_sample = false;\r\nwake_up(&sensor_inst->wait);\r\nreturn 0;\r\n}\r\nstatic int hid_sensor_custom_add_field(struct hid_sensor_custom *sensor_inst,\r\nint index, int report_type,\r\nstruct hid_report *report,\r\nstruct hid_field *field)\r\n{\r\nstruct hid_sensor_custom_field *sensor_field;\r\nvoid *fields;\r\nfields = krealloc(sensor_inst->fields,\r\n(sensor_inst->sensor_field_count + 1) *\r\nsizeof(struct hid_sensor_custom_field), GFP_KERNEL);\r\nif (!fields) {\r\nkfree(sensor_inst->fields);\r\nreturn -ENOMEM;\r\n}\r\nsensor_inst->fields = fields;\r\nsensor_field = &sensor_inst->fields[sensor_inst->sensor_field_count];\r\nsensor_field->attribute.usage_id = sensor_inst->hsdev->usage;\r\nif (field->logical)\r\nsensor_field->attribute.attrib_id = field->logical;\r\nelse\r\nsensor_field->attribute.attrib_id = field->usage[0].hid;\r\nsensor_field->attribute.index = index;\r\nsensor_field->attribute.report_id = report->id;\r\nsensor_field->attribute.units = field->unit;\r\nsensor_field->attribute.unit_expo = field->unit_exponent;\r\nsensor_field->attribute.size = (field->report_size / 8);\r\nsensor_field->attribute.logical_minimum = field->logical_minimum;\r\nsensor_field->attribute.logical_maximum = field->logical_maximum;\r\nif (report_type == HID_FEATURE_REPORT)\r\nsnprintf(sensor_field->group_name,\r\nsizeof(sensor_field->group_name), "feature-%x-%x",\r\nsensor_field->attribute.index,\r\nsensor_field->attribute.attrib_id);\r\nelse if (report_type == HID_INPUT_REPORT) {\r\nsnprintf(sensor_field->group_name,\r\nsizeof(sensor_field->group_name),\r\n"input-%x-%x", sensor_field->attribute.index,\r\nsensor_field->attribute.attrib_id);\r\nsensor_inst->input_field_count++;\r\nsensor_inst->input_report_size += (field->report_size *\r\nfield->report_count) / 8;\r\n}\r\nmemset(&sensor_field->hid_custom_attribute_group, 0,\r\nsizeof(struct attribute_group));\r\nsensor_inst->sensor_field_count++;\r\nreturn 0;\r\n}\r\nstatic int hid_sensor_custom_add_fields(struct hid_sensor_custom *sensor_inst,\r\nstruct hid_report_enum *report_enum,\r\nint report_type)\r\n{\r\nint i;\r\nint ret;\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nstruct hid_sensor_hub_device *hsdev = sensor_inst->hsdev;\r\nlist_for_each_entry(report, &report_enum->report_list, list) {\r\nfor (i = 0; i < report->maxfield; ++i) {\r\nfield = report->field[i];\r\nif (field->maxusage &&\r\n((field->usage[0].collection_index >=\r\nhsdev->start_collection_index) &&\r\n(field->usage[0].collection_index <\r\nhsdev->end_collection_index))) {\r\nret = hid_sensor_custom_add_field(sensor_inst,\r\ni,\r\nreport_type,\r\nreport,\r\nfield);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hid_sensor_custom_add_attributes(struct hid_sensor_custom\r\n*sensor_inst)\r\n{\r\nstruct hid_sensor_hub_device *hsdev = sensor_inst->hsdev;\r\nstruct hid_device *hdev = hsdev->hdev;\r\nint ret = -1;\r\nint i, j;\r\nfor (j = 0; j < HID_REPORT_TYPES; ++j) {\r\nif (j == HID_OUTPUT_REPORT)\r\ncontinue;\r\nret = hid_sensor_custom_add_fields(sensor_inst,\r\n&hdev->report_enum[j], j);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < sensor_inst->sensor_field_count; ++i) {\r\nj = 0;\r\nwhile (j < HID_CUSTOM_TOTAL_ATTRS &&\r\nhid_custom_attrs[j].name) {\r\nstruct device_attribute *device_attr;\r\ndevice_attr = &sensor_inst->fields[i].sd_attrs[j];\r\nsnprintf((char *)&sensor_inst->fields[i].attr_name[j],\r\nHID_CUSTOM_NAME_LENGTH, "%s-%s",\r\nsensor_inst->fields[i].group_name,\r\nhid_custom_attrs[j].name);\r\nsysfs_attr_init(&device_attr->attr);\r\ndevice_attr->attr.name =\r\n(char *)&sensor_inst->fields[i].attr_name[j];\r\ndevice_attr->attr.mode = hid_custom_attrs[j].mode;\r\ndevice_attr->show = show_value;\r\nif (hid_custom_attrs[j].mode & S_IWUSR)\r\ndevice_attr->store = store_value;\r\nsensor_inst->fields[i].attrs[j] = &device_attr->attr;\r\n++j;\r\n}\r\nsensor_inst->fields[i].attrs[j] = NULL;\r\nsensor_inst->fields[i].hid_custom_attribute_group.attrs =\r\nsensor_inst->fields[i].attrs;\r\nsensor_inst->fields[i].hid_custom_attribute_group.name =\r\nsensor_inst->fields[i].group_name;\r\nret = sysfs_create_group(&sensor_inst->pdev->dev.kobj,\r\n&sensor_inst->fields[i].\r\nhid_custom_attribute_group);\r\nif (ret)\r\nbreak;\r\nif (sensor_inst->fields[i].attribute.attrib_id ==\r\nHID_USAGE_SENSOR_PROY_POWER_STATE)\r\nsensor_inst->power_state = &sensor_inst->fields[i];\r\nelse if (sensor_inst->fields[i].attribute.attrib_id ==\r\nHID_USAGE_SENSOR_PROP_REPORT_STATE)\r\nsensor_inst->report_state = &sensor_inst->fields[i];\r\n}\r\nreturn ret;\r\n}\r\nstatic void hid_sensor_custom_remove_attributes(struct hid_sensor_custom *\r\nsensor_inst)\r\n{\r\nint i;\r\nfor (i = 0; i < sensor_inst->sensor_field_count; ++i)\r\nsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\r\n&sensor_inst->fields[i].\r\nhid_custom_attribute_group);\r\nkfree(sensor_inst->fields);\r\n}\r\nstatic ssize_t hid_sensor_custom_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *f_ps)\r\n{\r\nstruct hid_sensor_custom *sensor_inst;\r\nunsigned int copied;\r\nint ret;\r\nsensor_inst = container_of(file->private_data,\r\nstruct hid_sensor_custom, custom_dev);\r\nif (count < sizeof(struct hid_sensor_sample))\r\nreturn -EINVAL;\r\ndo {\r\nif (kfifo_is_empty(&sensor_inst->data_fifo)) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(sensor_inst->wait,\r\n!kfifo_is_empty(&sensor_inst->data_fifo));\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = kfifo_to_user(&sensor_inst->data_fifo, buf, count,\r\n&copied);\r\nif (ret)\r\nreturn ret;\r\n} while (copied == 0);\r\nreturn copied;\r\n}\r\nstatic int hid_sensor_custom_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hid_sensor_custom *sensor_inst;\r\nsensor_inst = container_of(file->private_data,\r\nstruct hid_sensor_custom, custom_dev);\r\nclear_bit(0, &sensor_inst->misc_opened);\r\nreturn 0;\r\n}\r\nstatic int hid_sensor_custom_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hid_sensor_custom *sensor_inst;\r\nsensor_inst = container_of(file->private_data,\r\nstruct hid_sensor_custom, custom_dev);\r\nif (test_and_set_bit(0, &sensor_inst->misc_opened))\r\nreturn -EBUSY;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic unsigned int hid_sensor_custom_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct hid_sensor_custom *sensor_inst;\r\nunsigned int mask = 0;\r\nsensor_inst = container_of(file->private_data,\r\nstruct hid_sensor_custom, custom_dev);\r\npoll_wait(file, &sensor_inst->wait, wait);\r\nif (!kfifo_is_empty(&sensor_inst->data_fifo))\r\nmask = POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int hid_sensor_custom_dev_if_add(struct hid_sensor_custom *sensor_inst)\r\n{\r\nint ret;\r\nret = kfifo_alloc(&sensor_inst->data_fifo, HID_CUSTOM_FIFO_SIZE,\r\nGFP_KERNEL);\r\nif (ret)\r\nreturn ret;\r\ninit_waitqueue_head(&sensor_inst->wait);\r\nsensor_inst->custom_dev.minor = MISC_DYNAMIC_MINOR;\r\nsensor_inst->custom_dev.name = dev_name(&sensor_inst->pdev->dev);\r\nsensor_inst->custom_dev.fops = &hid_sensor_custom_fops,\r\nret = misc_register(&sensor_inst->custom_dev);\r\nif (ret) {\r\nkfifo_free(&sensor_inst->data_fifo);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hid_sensor_custom_dev_if_remove(struct hid_sensor_custom\r\n*sensor_inst)\r\n{\r\nwake_up(&sensor_inst->wait);\r\nmisc_deregister(&sensor_inst->custom_dev);\r\nkfifo_free(&sensor_inst->data_fifo);\r\n}\r\nstatic int hid_sensor_custom_probe(struct platform_device *pdev)\r\n{\r\nstruct hid_sensor_custom *sensor_inst;\r\nstruct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;\r\nint ret;\r\nsensor_inst = devm_kzalloc(&pdev->dev, sizeof(*sensor_inst),\r\nGFP_KERNEL);\r\nif (!sensor_inst)\r\nreturn -ENOMEM;\r\nsensor_inst->callbacks.capture_sample = hid_sensor_capture_sample;\r\nsensor_inst->callbacks.send_event = hid_sensor_send_event;\r\nsensor_inst->callbacks.pdev = pdev;\r\nsensor_inst->hsdev = hsdev;\r\nsensor_inst->pdev = pdev;\r\nmutex_init(&sensor_inst->mutex);\r\nplatform_set_drvdata(pdev, sensor_inst);\r\nret = sensor_hub_register_callback(hsdev, hsdev->usage,\r\n&sensor_inst->callbacks);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "callback reg failed\n");\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&sensor_inst->pdev->dev.kobj,\r\n&enable_sensor_attr_group);\r\nif (ret)\r\ngoto err_remove_callback;\r\nret = hid_sensor_custom_add_attributes(sensor_inst);\r\nif (ret)\r\ngoto err_remove_group;\r\nret = hid_sensor_custom_dev_if_add(sensor_inst);\r\nif (ret)\r\ngoto err_remove_attributes;\r\nreturn 0;\r\nerr_remove_attributes:\r\nhid_sensor_custom_remove_attributes(sensor_inst);\r\nerr_remove_group:\r\nsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\r\n&enable_sensor_attr_group);\r\nerr_remove_callback:\r\nsensor_hub_remove_callback(hsdev, hsdev->usage);\r\nreturn ret;\r\n}\r\nstatic int hid_sensor_custom_remove(struct platform_device *pdev)\r\n{\r\nstruct hid_sensor_custom *sensor_inst = platform_get_drvdata(pdev);\r\nstruct hid_sensor_hub_device *hsdev = pdev->dev.platform_data;\r\nhid_sensor_custom_dev_if_remove(sensor_inst);\r\nhid_sensor_custom_remove_attributes(sensor_inst);\r\nsysfs_remove_group(&sensor_inst->pdev->dev.kobj,\r\n&enable_sensor_attr_group);\r\nsensor_hub_remove_callback(hsdev, hsdev->usage);\r\nreturn 0;\r\n}
