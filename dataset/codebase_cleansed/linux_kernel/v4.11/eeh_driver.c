static inline const char *eeh_pcid_name(struct pci_dev *pdev)\r\n{\r\nif (pdev && pdev->dev.driver)\r\nreturn pdev->dev.driver->name;\r\nreturn "";\r\n}\r\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn NULL;\r\nif (!try_module_get(pdev->driver->driver.owner))\r\nreturn NULL;\r\nreturn pdev->driver;\r\n}\r\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn;\r\nmodule_put(pdev->driver->driver.owner);\r\n}\r\nstatic void eeh_disable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nif (dev->msi_enabled || dev->msix_enabled)\r\nreturn;\r\nif (!irq_has_action(dev->irq))\r\nreturn;\r\nedev->mode |= EEH_DEV_IRQ_DISABLED;\r\ndisable_irq_nosync(dev->irq);\r\n}\r\nstatic void eeh_enable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\r\nedev->mode &= ~EEH_DEV_IRQ_DISABLED;\r\nif (irqd_irq_disabled(irq_get_irq_data(dev->irq)))\r\nenable_irq(dev->irq);\r\n}\r\n}\r\nstatic bool eeh_dev_removed(struct eeh_dev *edev)\r\n{\r\nif (!edev || (edev->mode & EEH_DEV_REMOVED))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void *eeh_dev_save_state(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = data;\r\nstruct pci_dev *pdev;\r\nif (!edev)\r\nreturn NULL;\r\nif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED))\r\nreturn NULL;\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (!pdev)\r\nreturn NULL;\r\npci_save_state(pdev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_error(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev || eeh_dev_removed(edev) || eeh_pe_passed(edev->pe))\r\nreturn NULL;\r\ndev->error_state = pci_channel_io_frozen;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->error_detected(dev, pci_channel_io_frozen);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\nedev->in_error = true;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_mmio_enabled(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev || eeh_dev_removed(edev) || eeh_pe_passed(edev->pe))\r\nreturn NULL;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\nif (!driver->err_handler ||\r\n!driver->err_handler->mmio_enabled ||\r\n(edev->mode & EEH_DEV_NO_HANDLER)) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->mmio_enabled(dev);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_reset(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev || eeh_dev_removed(edev) || eeh_pe_passed(edev->pe))\r\nreturn NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->slot_reset ||\r\n(edev->mode & EEH_DEV_NO_HANDLER) ||\r\n(!edev->in_error)) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->slot_reset(dev);\r\nif ((*res == PCI_ERS_RESULT_NONE) ||\r\n(*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\r\nif (*res == PCI_ERS_RESULT_DISCONNECT &&\r\nrc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_dev_restore_state(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = data;\r\nstruct pci_dev *pdev;\r\nif (!edev)\r\nreturn NULL;\r\nif (edev->pe && (edev->pe->state & EEH_PE_CFG_RESTRICTED)) {\r\nif (list_is_last(&edev->list, &edev->pe->edevs))\r\neeh_pe_restore_bars(edev->pe);\r\nreturn NULL;\r\n}\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (!pdev)\r\nreturn NULL;\r\npci_restore_state(pdev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_resume(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nbool was_in_error;\r\nstruct pci_driver *driver;\r\nif (!dev || eeh_dev_removed(edev) || eeh_pe_passed(edev->pe))\r\nreturn NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\nwas_in_error = edev->in_error;\r\nedev->in_error = false;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->resume ||\r\n(edev->mode & EEH_DEV_NO_HANDLER) || !was_in_error) {\r\nedev->mode &= ~EEH_DEV_NO_HANDLER;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->resume(dev);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_failure(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_driver *driver;\r\nif (!dev || eeh_dev_removed(edev) || eeh_pe_passed(edev->pe))\r\nreturn NULL;\r\ndev->error_state = pci_channel_io_perm_failure;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_add_virt_device(void *data, void *userdata)\r\n{\r\nstruct pci_driver *driver;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nif (!(edev->physfn)) {\r\npr_warn("%s: EEH dev %04x:%02x:%02x.%01x not for VF\n",\r\n__func__, edev->phb->global_number, pdn->busno,\r\nPCI_SLOT(pdn->devfn), PCI_FUNC(pdn->devfn));\r\nreturn NULL;\r\n}\r\ndriver = eeh_pcid_get(dev);\r\nif (driver) {\r\neeh_pcid_put(dev);\r\nif (driver->err_handler)\r\nreturn NULL;\r\n}\r\n#ifdef CONFIG_PPC_POWERNV\r\npci_iov_add_virtfn(edev->physfn, pdn->vf_index, 0);\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic void *eeh_rmv_device(void *data, void *userdata)\r\n{\r\nstruct pci_driver *driver;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct eeh_rmv_data *rmv_data = (struct eeh_rmv_data *)userdata;\r\nint *removed = rmv_data ? &rmv_data->removed : NULL;\r\nif (!dev || (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE))\r\nreturn NULL;\r\nif (eeh_dev_removed(edev))\r\nreturn NULL;\r\ndriver = eeh_pcid_get(dev);\r\nif (driver) {\r\neeh_pcid_put(dev);\r\nif (removed &&\r\neeh_pe_passed(edev->pe))\r\nreturn NULL;\r\nif (removed &&\r\ndriver->err_handler &&\r\ndriver->err_handler->error_detected &&\r\ndriver->err_handler->slot_reset)\r\nreturn NULL;\r\n}\r\npr_debug("EEH: Removing %s without EEH sensitive driver\n",\r\npci_name(dev));\r\nedev->bus = dev->bus;\r\nedev->mode |= EEH_DEV_DISCONNECTED;\r\nif (removed)\r\n(*removed)++;\r\nif (edev->physfn) {\r\n#ifdef CONFIG_PPC_POWERNV\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\npci_iov_remove_virtfn(edev->physfn, pdn->vf_index, 0);\r\nedev->pdev = NULL;\r\npdn->pe_number = IODA_INVALID_PE;\r\n#endif\r\nif (rmv_data)\r\nlist_add(&edev->rmv_list, &rmv_data->edev_list);\r\n} else {\r\npci_lock_rescan_remove();\r\npci_stop_and_remove_bus_device(dev);\r\npci_unlock_rescan_remove();\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *eeh_pe_detach_dev(void *data, void *userdata)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nstruct eeh_dev *edev, *tmp;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\nif (!(edev->mode & EEH_DEV_DISCONNECTED))\r\ncontinue;\r\nedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\r\neeh_rmv_from_parent_pe(edev);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *__eeh_clear_pe_frozen_state(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nbool clear_sw_state = *(bool *)flag;\r\nint i, rc = 1;\r\nfor (i = 0; rc && i < 3; i++)\r\nrc = eeh_unfreeze_pe(pe, clear_sw_state);\r\nif (rc) {\r\npr_warn("%s: Failure %d unfreezing PHB#%x-PE#%x\n",\r\n__func__, rc, pe->phb->global_number, pe->addr);\r\nreturn (void *)pe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int eeh_clear_pe_frozen_state(struct eeh_pe *pe,\r\nbool clear_sw_state)\r\n{\r\nvoid *rc;\r\nrc = eeh_pe_traverse(pe, __eeh_clear_pe_frozen_state, &clear_sw_state);\r\nif (!rc)\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED);\r\nreturn rc ? -EIO : 0;\r\n}\r\nint eeh_pe_reset_and_recover(struct eeh_pe *pe)\r\n{\r\nint ret;\r\nif (pe->state & EEH_PE_RECOVERING)\r\nreturn 0;\r\neeh_pe_state_mark(pe, EEH_PE_RECOVERING);\r\neeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);\r\nret = eeh_pe_reset_full(pe);\r\nif (ret) {\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\nreturn ret;\r\n}\r\nret = eeh_clear_pe_frozen_state(pe, true);\r\nif (ret) {\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\nreturn ret;\r\n}\r\neeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\nreturn 0;\r\n}\r\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus,\r\nstruct eeh_rmv_data *rmv_data)\r\n{\r\nstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\r\nstruct timeval tstamp;\r\nint cnt, rc;\r\nstruct eeh_dev *edev;\r\ncnt = pe->freeze_count;\r\ntstamp = pe->tstamp;\r\neeh_pe_state_mark(pe, EEH_PE_KEEP);\r\nif (bus) {\r\nif (pe->type & EEH_PE_VF) {\r\neeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\r\n} else {\r\npci_lock_rescan_remove();\r\npci_hp_remove_devices(bus);\r\npci_unlock_rescan_remove();\r\n}\r\n} else if (frozen_bus) {\r\neeh_pe_dev_traverse(pe, eeh_rmv_device, rmv_data);\r\n}\r\nrc = eeh_pe_reset_full(pe);\r\nif (rc)\r\nreturn rc;\r\npci_lock_rescan_remove();\r\neeh_ops->configure_bridge(pe);\r\neeh_pe_restore_bars(pe);\r\nrc = eeh_clear_pe_frozen_state(pe, false);\r\nif (rc) {\r\npci_unlock_rescan_remove();\r\nreturn rc;\r\n}\r\nif (bus) {\r\npr_info("EEH: Sleep 5s ahead of complete hotplug\n");\r\nssleep(5);\r\nedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\r\neeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\r\nif (pe->type & EEH_PE_VF) {\r\neeh_add_virt_device(edev, NULL);\r\n} else {\r\neeh_pe_state_clear(pe, EEH_PE_PRI_BUS);\r\npci_hp_add_devices(bus);\r\n}\r\n} else if (frozen_bus && rmv_data->removed) {\r\npr_info("EEH: Sleep 5s ahead of partial hotplug\n");\r\nssleep(5);\r\nedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\r\neeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\r\nif (pe->type & EEH_PE_VF)\r\neeh_add_virt_device(edev, NULL);\r\nelse\r\npci_hp_add_devices(frozen_bus);\r\n}\r\neeh_pe_state_clear(pe, EEH_PE_KEEP);\r\npe->tstamp = tstamp;\r\npe->freeze_count = cnt;\r\npci_unlock_rescan_remove();\r\nreturn 0;\r\n}\r\nstatic void eeh_handle_normal_event(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *frozen_bus;\r\nstruct eeh_dev *edev, *tmp;\r\nint rc = 0;\r\nenum pci_ers_result result = PCI_ERS_RESULT_NONE;\r\nstruct eeh_rmv_data rmv_data = {LIST_HEAD_INIT(rmv_data.edev_list), 0};\r\nfrozen_bus = eeh_pe_bus_get(pe);\r\nif (!frozen_bus) {\r\npr_err("%s: Cannot find PCI bus for PHB#%x-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->addr);\r\nreturn;\r\n}\r\neeh_pe_update_time_stamp(pe);\r\npe->freeze_count++;\r\nif (pe->freeze_count > eeh_max_freezes)\r\ngoto excess_failures;\r\npr_warn("EEH: This PCI device has failed %d times in the last hour\n",\r\npe->freeze_count);\r\npr_info("EEH: Notify device drivers to shutdown\n");\r\neeh_pe_dev_traverse(pe, eeh_report_error, &result);\r\nif ((pe->type & EEH_PE_PHB) &&\r\nresult != PCI_ERS_RESULT_NONE &&\r\nresult != PCI_ERS_RESULT_NEED_RESET)\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\nrc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\r\nif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\r\npr_warn("EEH: Permanent failure\n");\r\ngoto hard_fail;\r\n}\r\npr_info("EEH: Collect temporary log\n");\r\neeh_slot_error_detail(pe, EEH_LOG_TEMP);\r\nif (result == PCI_ERS_RESULT_NONE) {\r\npr_info("EEH: Reset with hotplug activity\n");\r\nrc = eeh_reset_device(pe, frozen_bus, NULL);\r\nif (rc) {\r\npr_warn("%s: Unable to reset, err=%d\n",\r\n__func__, rc);\r\ngoto hard_fail;\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\npr_info("EEH: Enable I/O for affected devices\n");\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc) {\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\n} else {\r\npr_info("EEH: Notify device drivers to resume I/O\n");\r\neeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\npr_info("EEH: Enabled DMA for affected devices\n");\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc) {\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\n} else {\r\neeh_pe_state_clear(pe, EEH_PE_ISOLATED);\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_DISCONNECT) {\r\npr_warn("EEH: Device driver gave up\n");\r\ngoto hard_fail;\r\n}\r\nif (result == PCI_ERS_RESULT_NEED_RESET) {\r\npr_info("EEH: Reset without hotplug activity\n");\r\nrc = eeh_reset_device(pe, NULL, &rmv_data);\r\nif (rc) {\r\npr_warn("%s: Cannot reset, err=%d\n",\r\n__func__, rc);\r\ngoto hard_fail;\r\n}\r\npr_info("EEH: Notify device drivers "\r\n"the completion of reset\n");\r\nresult = PCI_ERS_RESULT_NONE;\r\neeh_pe_dev_traverse(pe, eeh_report_reset, &result);\r\n}\r\nif ((result != PCI_ERS_RESULT_RECOVERED) &&\r\n(result != PCI_ERS_RESULT_NONE)) {\r\npr_warn("EEH: Not recovered\n");\r\ngoto hard_fail;\r\n}\r\nlist_for_each_entry_safe(edev, tmp, &rmv_data.edev_list, rmv_list) {\r\neeh_add_virt_device(edev, NULL);\r\nlist_del(&edev->rmv_list);\r\n}\r\npr_info("EEH: Notify device driver to resume\n");\r\neeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\r\nreturn;\r\nexcess_failures:\r\npr_err("EEH: PHB#%x-PE#%x has failed %d times in the\n"\r\n"last hour and has been permanently disabled.\n"\r\n"Please try reseating or replacing it.\n",\r\npe->phb->global_number, pe->addr,\r\npe->freeze_count);\r\ngoto perm_error;\r\nhard_fail:\r\npr_err("EEH: Unable to recover from failure from PHB#%x-PE#%x.\n"\r\n"Please try reseating or replacing it\n",\r\npe->phb->global_number, pe->addr);\r\nperm_error:\r\neeh_slot_error_detail(pe, EEH_LOG_PERM);\r\neeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\r\neeh_pe_state_mark(pe, EEH_PE_REMOVED);\r\nif (frozen_bus) {\r\nif (pe->type & EEH_PE_VF) {\r\neeh_pe_dev_traverse(pe, eeh_rmv_device, NULL);\r\neeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\r\n} else {\r\neeh_pe_state_clear(pe, EEH_PE_PRI_BUS);\r\neeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);\r\npci_lock_rescan_remove();\r\npci_hp_remove_devices(frozen_bus);\r\npci_unlock_rescan_remove();\r\n}\r\n}\r\n}\r\nstatic void eeh_handle_special_event(void)\r\n{\r\nstruct eeh_pe *pe, *phb_pe;\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose;\r\nunsigned long flags;\r\nint rc;\r\ndo {\r\nrc = eeh_ops->next_error(&pe);\r\nswitch (rc) {\r\ncase EEH_NEXT_ERR_DEAD_IOC:\r\neeh_serialize_lock(&flags);\r\neeh_remove_event(NULL, true);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe) continue;\r\neeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);\r\n}\r\neeh_serialize_unlock(flags);\r\nbreak;\r\ncase EEH_NEXT_ERR_FROZEN_PE:\r\ncase EEH_NEXT_ERR_FENCED_PHB:\r\ncase EEH_NEXT_ERR_DEAD_PHB:\r\neeh_serialize_lock(&flags);\r\neeh_remove_event(pe, true);\r\nif (rc == EEH_NEXT_ERR_DEAD_PHB)\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\nelse\r\neeh_pe_state_mark(pe,\r\nEEH_PE_ISOLATED | EEH_PE_RECOVERING);\r\neeh_serialize_unlock(flags);\r\nbreak;\r\ncase EEH_NEXT_ERR_NONE:\r\nreturn;\r\ndefault:\r\npr_warn("%s: Invalid value %d from next_error()\n",\r\n__func__, rc);\r\nreturn;\r\n}\r\nif (rc == EEH_NEXT_ERR_FROZEN_PE ||\r\nrc == EEH_NEXT_ERR_FENCED_PHB) {\r\neeh_handle_normal_event(pe);\r\neeh_pe_state_clear(pe, EEH_PE_RECOVERING);\r\n} else {\r\npci_lock_rescan_remove();\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe ||\r\n!(phb_pe->state & EEH_PE_ISOLATED) ||\r\n(phb_pe->state & EEH_PE_RECOVERING))\r\ncontinue;\r\neeh_pe_state_clear(pe, EEH_PE_PRI_BUS);\r\neeh_pe_dev_traverse(pe,\r\neeh_report_failure, NULL);\r\nbus = eeh_pe_bus_get(phb_pe);\r\nif (!bus) {\r\npr_err("%s: Cannot find PCI bus for "\r\n"PHB#%x-PE#%x\n",\r\n__func__,\r\npe->phb->global_number,\r\npe->addr);\r\nbreak;\r\n}\r\npci_hp_remove_devices(bus);\r\n}\r\npci_unlock_rescan_remove();\r\n}\r\nif (rc == EEH_NEXT_ERR_DEAD_IOC)\r\nbreak;\r\n} while (rc != EEH_NEXT_ERR_NONE);\r\n}\r\nvoid eeh_handle_event(struct eeh_pe *pe)\r\n{\r\nif (pe)\r\neeh_handle_normal_event(pe);\r\nelse\r\neeh_handle_special_event();\r\n}
