static void i810_screen_off(u8 __iomem *mmio, u8 mode)\r\n{\r\nu32 count = WAIT_COUNT;\r\nu8 val;\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\nval = i810_readb(SR_DATA, mmio);\r\nval = (mode == OFF) ? val | SCR_OFF :\r\nval & ~SCR_OFF;\r\nwhile((i810_readw(DISP_SL, mmio) & 0xFFF) && count--);\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\ni810_writeb(SR_DATA, mmio, val);\r\n}\r\nstatic void i810_dram_off(u8 __iomem *mmio, u8 mode)\r\n{\r\nu8 val;\r\nval = i810_readb(DRAMCH, mmio);\r\nval &= DRAM_OFF;\r\nval = (mode == OFF) ? val : val | DRAM_ON;\r\ni810_writeb(DRAMCH, mmio, val);\r\n}\r\nstatic void i810_protect_regs(u8 __iomem *mmio, int mode)\r\n{\r\nu8 reg;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR11);\r\nreg = i810_readb(CR_DATA_CGA, mmio);\r\nreg = (mode == OFF) ? reg & ~0x80 :\r\nreg | 0x80;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR11);\r\ni810_writeb(CR_DATA_CGA, mmio, reg);\r\n}\r\nstatic void i810_load_pll(struct i810fb_par *par)\r\n{\r\nu32 tmp1, tmp2;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntmp1 = par->regs.M | par->regs.N << 16;\r\ntmp2 = i810_readl(DCLK_2D, mmio);\r\ntmp2 &= ~MN_MASK;\r\ni810_writel(DCLK_2D, mmio, tmp1 | tmp2);\r\ntmp1 = par->regs.P;\r\ntmp2 = i810_readl(DCLK_0DS, mmio);\r\ntmp2 &= ~(P_OR << 16);\r\ni810_writel(DCLK_0DS, mmio, (tmp1 << 16) | tmp2);\r\ni810_writeb(MSR_WRITE, mmio, par->regs.msr | 0xC8 | 1);\r\n}\r\nstatic void i810_load_vga(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR70);\r\ni810_writeb(CR_DATA_CGA, mmio, par->interlace);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR00);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr00);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR01);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr01);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR02);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr02);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR03);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr03);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR04);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr04);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR05);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr05);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR06);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr06);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR09);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr09);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR10);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr10);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR11);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr11);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR12);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr12);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR15);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr15);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR16);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr16);\r\n}\r\nstatic void i810_load_vgax(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR30);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr30);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR31);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr31);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR32);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr32);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR33);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr33);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR35);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr35);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR39);\r\ni810_writeb(CR_DATA_CGA, mmio, par->regs.cr39);\r\n}\r\nstatic void i810_load_2d(struct i810fb_par *par)\r\n{\r\nu32 tmp;\r\nu8 tmp8;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_writel(FW_BLC, mmio, par->watermark);\r\ntmp = i810_readl(PIXCONF, mmio);\r\ntmp |= 1 | 1 << 20;\r\ni810_writel(PIXCONF, mmio, tmp);\r\ni810_writel(OVRACT, mmio, par->ovract);\r\ni810_writeb(GR_INDEX, mmio, GR10);\r\ntmp8 = i810_readb(GR_DATA, mmio);\r\ntmp8 |= 2;\r\ni810_writeb(GR_INDEX, mmio, GR10);\r\ni810_writeb(GR_DATA, mmio, tmp8);\r\n}\r\nstatic void i810_hires(u8 __iomem *mmio)\r\n{\r\nu8 val;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR80);\r\nval = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR80);\r\ni810_writeb(CR_DATA_CGA, mmio, val | 1);\r\ni810_writel(MEM_MODE, mmio, i810_readl(MEM_MODE, mmio) | 4);\r\n}\r\nstatic void i810_load_pitch(struct i810fb_par *par)\r\n{\r\nu32 tmp, pitch;\r\nu8 val;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\npitch = par->pitch >> 3;\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\nval = i810_readb(SR_DATA, mmio);\r\nval &= 0xE0;\r\nval |= 1 | 1 << 2;\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\ni810_writeb(SR_DATA, mmio, val);\r\ntmp = pitch & 0xFF;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR13);\r\ni810_writeb(CR_DATA_CGA, mmio, (u8) tmp);\r\ntmp = pitch >> 8;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR41);\r\nval = i810_readb(CR_DATA_CGA, mmio) & ~0x0F;\r\ni810_writeb(CR_INDEX_CGA, mmio, CR41);\r\ni810_writeb(CR_DATA_CGA, mmio, (u8) tmp | val);\r\n}\r\nstatic void i810_load_color(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nu32 reg1;\r\nu16 reg2;\r\nreg1 = i810_readl(PIXCONF, mmio) & ~(0xF0000 | 1 << 27);\r\nreg2 = i810_readw(BLTCNTL, mmio) & ~0x30;\r\nreg1 |= 0x8000 | par->pixconf;\r\nreg2 |= par->bltcntl;\r\ni810_writel(PIXCONF, mmio, reg1);\r\ni810_writew(BLTCNTL, mmio, reg2);\r\n}\r\nstatic void i810_load_regs(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_screen_off(mmio, OFF);\r\ni810_protect_regs(mmio, OFF);\r\ni810_dram_off(mmio, OFF);\r\ni810_load_pll(par);\r\ni810_load_vga(par);\r\ni810_load_vgax(par);\r\ni810_dram_off(mmio, ON);\r\ni810_load_2d(par);\r\ni810_hires(mmio);\r\ni810_screen_off(mmio, ON);\r\ni810_protect_regs(mmio, ON);\r\ni810_load_color(par);\r\ni810_load_pitch(par);\r\n}\r\nstatic void i810_write_dac(u8 regno, u8 red, u8 green, u8 blue,\r\nu8 __iomem *mmio)\r\n{\r\ni810_writeb(CLUT_INDEX_WRITE, mmio, regno);\r\ni810_writeb(CLUT_DATA, mmio, red);\r\ni810_writeb(CLUT_DATA, mmio, green);\r\ni810_writeb(CLUT_DATA, mmio, blue);\r\n}\r\nstatic void i810_read_dac(u8 regno, u8 *red, u8 *green, u8 *blue,\r\nu8 __iomem *mmio)\r\n{\r\ni810_writeb(CLUT_INDEX_READ, mmio, regno);\r\n*red = i810_readb(CLUT_DATA, mmio);\r\n*green = i810_readb(CLUT_DATA, mmio);\r\n*blue = i810_readb(CLUT_DATA, mmio);\r\n}\r\nstatic void i810_restore_pll(struct i810fb_par *par)\r\n{\r\nu32 tmp1, tmp2;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntmp1 = par->hw_state.dclk_2d;\r\ntmp2 = i810_readl(DCLK_2D, mmio);\r\ntmp1 &= ~MN_MASK;\r\ntmp2 &= MN_MASK;\r\ni810_writel(DCLK_2D, mmio, tmp1 | tmp2);\r\ntmp1 = par->hw_state.dclk_1d;\r\ntmp2 = i810_readl(DCLK_1D, mmio);\r\ntmp1 &= ~MN_MASK;\r\ntmp2 &= MN_MASK;\r\ni810_writel(DCLK_1D, mmio, tmp1 | tmp2);\r\ni810_writel(DCLK_0DS, mmio, par->hw_state.dclk_0ds);\r\n}\r\nstatic void i810_restore_dac(struct i810fb_par *par)\r\n{\r\nu32 tmp1, tmp2;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntmp1 = par->hw_state.pixconf;\r\ntmp2 = i810_readl(PIXCONF, mmio);\r\ntmp1 &= DAC_BIT;\r\ntmp2 &= ~DAC_BIT;\r\ni810_writel(PIXCONF, mmio, tmp1 | tmp2);\r\n}\r\nstatic void i810_restore_vgax(struct i810fb_par *par)\r\n{\r\nu8 i, j;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nfor (i = 0; i < 4; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR30+i);\r\ni810_writeb(CR_DATA_CGA, mmio, *(&(par->hw_state.cr30) + i));\r\n}\r\ni810_writeb(CR_INDEX_CGA, mmio, CR35);\r\ni810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr35);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR39);\r\ni810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr39);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR41);\r\ni810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr39);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR70);\r\ni = par->hw_state.cr70;\r\ni &= INTERLACE_BIT;\r\nj = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR70);\r\ni810_writeb(CR_DATA_CGA, mmio, j | i);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR80);\r\ni810_writeb(CR_DATA_CGA, mmio, par->hw_state.cr80);\r\ni810_writeb(MSR_WRITE, mmio, par->hw_state.msr);\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\ni = (par->hw_state.sr01) & ~0xE0 ;\r\nj = i810_readb(SR_DATA, mmio) & 0xE0;\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\ni810_writeb(SR_DATA, mmio, i | j);\r\n}\r\nstatic void i810_restore_vga(struct i810fb_par *par)\r\n{\r\nu8 i;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nfor (i = 0; i < 10; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR00 + i);\r\ni810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr00) + i));\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR10 + i);\r\ni810_writeb(CR_DATA_CGA, mmio, *((&par->hw_state.cr10) + i));\r\n}\r\n}\r\nstatic void i810_restore_addr_map(struct i810fb_par *par)\r\n{\r\nu8 tmp;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_writeb(GR_INDEX, mmio, GR10);\r\ntmp = i810_readb(GR_DATA, mmio);\r\ntmp &= ADDR_MAP_MASK;\r\ntmp |= par->hw_state.gr10;\r\ni810_writeb(GR_INDEX, mmio, GR10);\r\ni810_writeb(GR_DATA, mmio, tmp);\r\n}\r\nstatic void i810_restore_2d(struct i810fb_par *par)\r\n{\r\nu32 tmp_long;\r\nu16 tmp_word;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ntmp_word = i810_readw(BLTCNTL, mmio);\r\ntmp_word &= ~(3 << 4);\r\ntmp_word |= par->hw_state.bltcntl;\r\ni810_writew(BLTCNTL, mmio, tmp_word);\r\ni810_dram_off(mmio, OFF);\r\ni810_writel(PIXCONF, mmio, par->hw_state.pixconf);\r\ni810_dram_off(mmio, ON);\r\ntmp_word = i810_readw(HWSTAM, mmio);\r\ntmp_word &= 3 << 13;\r\ntmp_word |= par->hw_state.hwstam;\r\ni810_writew(HWSTAM, mmio, tmp_word);\r\ntmp_long = i810_readl(FW_BLC, mmio);\r\ntmp_long &= FW_BLC_MASK;\r\ntmp_long |= par->hw_state.fw_blc;\r\ni810_writel(FW_BLC, mmio, tmp_long);\r\ni810_writel(HWS_PGA, mmio, par->hw_state.hws_pga);\r\ni810_writew(IER, mmio, par->hw_state.ier);\r\ni810_writew(IMR, mmio, par->hw_state.imr);\r\ni810_writel(DPLYSTAS, mmio, par->hw_state.dplystas);\r\n}\r\nstatic void i810_restore_vga_state(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_screen_off(mmio, OFF);\r\ni810_protect_regs(mmio, OFF);\r\ni810_dram_off(mmio, OFF);\r\ni810_restore_pll(par);\r\ni810_restore_dac(par);\r\ni810_restore_vga(par);\r\ni810_restore_vgax(par);\r\ni810_restore_addr_map(par);\r\ni810_dram_off(mmio, ON);\r\ni810_restore_2d(par);\r\ni810_screen_off(mmio, ON);\r\ni810_protect_regs(mmio, ON);\r\n}\r\nstatic void i810_save_vgax(struct i810fb_par *par)\r\n{\r\nu8 i;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nfor (i = 0; i < 4; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR30 + i);\r\n*(&(par->hw_state.cr30) + i) = i810_readb(CR_DATA_CGA, mmio);\r\n}\r\ni810_writeb(CR_INDEX_CGA, mmio, CR35);\r\npar->hw_state.cr35 = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR39);\r\npar->hw_state.cr39 = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR41);\r\npar->hw_state.cr41 = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR70);\r\npar->hw_state.cr70 = i810_readb(CR_DATA_CGA, mmio);\r\npar->hw_state.msr = i810_readb(MSR_READ, mmio);\r\ni810_writeb(CR_INDEX_CGA, mmio, CR80);\r\npar->hw_state.cr80 = i810_readb(CR_DATA_CGA, mmio);\r\ni810_writeb(SR_INDEX, mmio, SR01);\r\npar->hw_state.sr01 = i810_readb(SR_DATA, mmio);\r\n}\r\nstatic void i810_save_vga(struct i810fb_par *par)\r\n{\r\nu8 i;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nfor (i = 0; i < 10; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR00 + i);\r\n*((&par->hw_state.cr00) + i) = i810_readb(CR_DATA_CGA, mmio);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ni810_writeb(CR_INDEX_CGA, mmio, CR10 + i);\r\n*((&par->hw_state.cr10) + i) = i810_readb(CR_DATA_CGA, mmio);\r\n}\r\n}\r\nstatic void i810_save_2d(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\npar->hw_state.dclk_2d = i810_readl(DCLK_2D, mmio);\r\npar->hw_state.dclk_1d = i810_readl(DCLK_1D, mmio);\r\npar->hw_state.dclk_0ds = i810_readl(DCLK_0DS, mmio);\r\npar->hw_state.pixconf = i810_readl(PIXCONF, mmio);\r\npar->hw_state.fw_blc = i810_readl(FW_BLC, mmio);\r\npar->hw_state.bltcntl = i810_readw(BLTCNTL, mmio);\r\npar->hw_state.hwstam = i810_readw(HWSTAM, mmio);\r\npar->hw_state.hws_pga = i810_readl(HWS_PGA, mmio);\r\npar->hw_state.ier = i810_readw(IER, mmio);\r\npar->hw_state.imr = i810_readw(IMR, mmio);\r\npar->hw_state.dplystas = i810_readl(DPLYSTAS, mmio);\r\n}\r\nstatic void i810_save_vga_state(struct i810fb_par *par)\r\n{\r\ni810_save_vga(par);\r\ni810_save_vgax(par);\r\ni810_save_2d(par);\r\n}\r\nstatic u32 get_line_length(struct i810fb_par *par, int xres_virtual, int bpp)\r\n{\r\nu32 length;\r\nlength = xres_virtual*bpp;\r\nlength = (length+31)&-32;\r\nlength >>= 3;\r\nreturn length;\r\n}\r\nstatic void i810_calc_dclk(u32 freq, u32 *m, u32 *n, u32 *p)\r\n{\r\nu32 m_reg, n_reg, p_divisor, n_target_max;\r\nu32 m_target, n_target, p_target, n_best, m_best, mod;\r\nu32 f_out, target_freq, diff = 0, mod_min, diff_min;\r\ndiff_min = mod_min = 0xFFFFFFFF;\r\nn_best = m_best = m_target = f_out = 0;\r\ntarget_freq = freq;\r\nn_target_max = 30;\r\np_divisor = 1;\r\np_target = 0;\r\nwhile(!((1000000 * p_divisor)/(16 * 24 * target_freq)) &&\r\np_divisor <= 32) {\r\np_divisor <<= 1;\r\np_target++;\r\n}\r\nn_reg = m_reg = n_target = 3;\r\nwhile (diff_min && mod_min && (n_target < n_target_max)) {\r\nf_out = (p_divisor * n_reg * 1000000)/(4 * 24 * m_reg);\r\nmod = (p_divisor * n_reg * 1000000) % (4 * 24 * m_reg);\r\nm_target = m_reg;\r\nn_target = n_reg;\r\nif (f_out <= target_freq) {\r\nn_reg++;\r\ndiff = target_freq - f_out;\r\n} else {\r\nm_reg++;\r\ndiff = f_out - target_freq;\r\n}\r\nif (diff_min > diff) {\r\ndiff_min = diff;\r\nn_best = n_target;\r\nm_best = m_target;\r\n}\r\nif (!diff && mod_min > mod) {\r\nmod_min = mod;\r\nn_best = n_target;\r\nm_best = m_target;\r\n}\r\n}\r\nif (m) *m = (m_best - 2) & 0x3FF;\r\nif (n) *n = (n_best - 2) & 0x3FF;\r\nif (p) *p = (p_target << 4);\r\n}\r\nstatic void i810_enable_cursor(u8 __iomem *mmio, int mode)\r\n{\r\nu32 temp;\r\ntemp = i810_readl(PIXCONF, mmio);\r\ntemp = (mode == ON) ? temp | CURSOR_ENABLE_MASK :\r\ntemp & ~CURSOR_ENABLE_MASK;\r\ni810_writel(PIXCONF, mmio, temp);\r\n}\r\nstatic void i810_reset_cursor_image(struct i810fb_par *par)\r\n{\r\nu8 __iomem *addr = par->cursor_heap.virtual;\r\nint i, j;\r\nfor (i = 64; i--; ) {\r\nfor (j = 0; j < 8; j++) {\r\ni810_writeb(j, addr, 0xff);\r\ni810_writeb(j+8, addr, 0x00);\r\n}\r\naddr +=16;\r\n}\r\n}\r\nstatic void i810_load_cursor_image(int width, int height, u8 *data,\r\nstruct i810fb_par *par)\r\n{\r\nu8 __iomem *addr = par->cursor_heap.virtual;\r\nint i, j, w = width/8;\r\nint mod = width % 8, t_mask, d_mask;\r\nt_mask = 0xff >> mod;\r\nd_mask = ~(0xff >> mod);\r\nfor (i = height; i--; ) {\r\nfor (j = 0; j < w; j++) {\r\ni810_writeb(j+0, addr, 0x00);\r\ni810_writeb(j+8, addr, *data++);\r\n}\r\nif (mod) {\r\ni810_writeb(j+0, addr, t_mask);\r\ni810_writeb(j+8, addr, *data++ & d_mask);\r\n}\r\naddr += 16;\r\n}\r\n}\r\nstatic void i810_load_cursor_colors(int fg, int bg, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nu8 red, green, blue, trans, temp;\r\ni810fb_getcolreg(bg, &red, &green, &blue, &trans, info);\r\ntemp = i810_readb(PIXCONF1, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp | EXTENDED_PALETTE);\r\ni810_write_dac(4, red, green, blue, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp);\r\ni810fb_getcolreg(fg, &red, &green, &blue, &trans, info);\r\ntemp = i810_readb(PIXCONF1, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp | EXTENDED_PALETTE);\r\ni810_write_dac(5, red, green, blue, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp);\r\n}\r\nstatic void i810_init_cursor(struct i810fb_par *par)\r\n{\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\ni810_enable_cursor(mmio, OFF);\r\ni810_writel(CURBASE, mmio, par->cursor_heap.physical);\r\ni810_writew(CURCNTR, mmio, COORD_ACTIVE | CURSOR_MODE_64_XOR);\r\n}\r\nstatic void i810_round_off(struct fb_var_screeninfo *var)\r\n{\r\nu32 xres, yres, vxres, vyres;\r\nxres = var->xres;\r\nyres = var->yres;\r\nvxres = var->xres_virtual;\r\nvyres = var->yres_virtual;\r\nvar->bits_per_pixel += 7;\r\nvar->bits_per_pixel &= ~7;\r\nif (var->bits_per_pixel < 8)\r\nvar->bits_per_pixel = 8;\r\nif (var->bits_per_pixel > 32)\r\nvar->bits_per_pixel = 32;\r\nround_off_xres(&xres);\r\nif (xres < 40)\r\nxres = 40;\r\nif (xres > 2048)\r\nxres = 2048;\r\nxres = (xres + 7) & ~7;\r\nif (vxres < xres)\r\nvxres = xres;\r\nround_off_yres(&xres, &yres);\r\nif (yres < 1)\r\nyres = 1;\r\nif (yres >= 2048)\r\nyres = 2048;\r\nif (vyres < yres)\r\nvyres = yres;\r\nif (var->bits_per_pixel == 32)\r\nvar->accel_flags = 0;\r\nvar->left_margin = (var->left_margin + 4) & ~7;\r\nvar->right_margin = (var->right_margin + 4) & ~7;\r\nvar->hsync_len = (var->hsync_len + 4) & ~7;\r\nif (var->vmode & FB_VMODE_INTERLACED) {\r\nif (!((yres + var->upper_margin + var->vsync_len +\r\nvar->lower_margin) & 1))\r\nvar->upper_margin++;\r\n}\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nvar->xres_virtual = vxres;\r\nvar->yres_virtual = vyres;\r\n}\r\nstatic void set_color_bitfields(struct fb_var_screeninfo *var)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->green.length = (var->green.length == 5) ? 5 : 6;\r\nvar->red.length = 5;\r\nvar->blue.length = 5;\r\nvar->transp.length = 6 - var->green.length;\r\nvar->blue.offset = 0;\r\nvar->green.offset = 5;\r\nvar->red.offset = 5 + var->green.length;\r\nvar->transp.offset = (5 + var->red.offset) & 15;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nvar->transp.length = var->bits_per_pixel - 24;\r\nvar->transp.offset = (var->transp.length) ? 24 : 0;\r\nbreak;\r\n}\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\n}\r\nstatic int i810_check_params(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nint line_length, vidmem, mode_valid = 0, retval = 0;\r\nu32 vyres = var->yres_virtual, vxres = var->xres_virtual;\r\nline_length = get_line_length(par, vxres, var->bits_per_pixel);\r\nvidmem = line_length*vyres;\r\nif (vidmem > par->fb.size) {\r\nvyres = par->fb.size/line_length;\r\nif (vyres < var->yres) {\r\nvyres = info->var.yres;\r\nvxres = par->fb.size/vyres;\r\nvxres /= var->bits_per_pixel >> 3;\r\nline_length = get_line_length(par, vxres,\r\nvar->bits_per_pixel);\r\nvidmem = line_length * info->var.yres;\r\nif (vxres < var->xres) {\r\nprintk("i810fb: required video memory, "\r\n"%d bytes, for %dx%d-%d (virtual) "\r\n"is out of range\n",\r\nvidmem, vxres, vyres,\r\nvar->bits_per_pixel);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\nvar->xres_virtual = vxres;\r\nvar->yres_virtual = vyres;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ninfo->monspecs.dclkmax = 234000000;\r\nbreak;\r\ncase 16:\r\ninfo->monspecs.dclkmax = 229000000;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ninfo->monspecs.dclkmax = 204000000;\r\nbreak;\r\n}\r\ninfo->monspecs.dclkmin = 15000000;\r\nif (!fb_validate_mode(var, info))\r\nmode_valid = 1;\r\n#ifdef CONFIG_FB_I810_I2C\r\nif (!mode_valid && info->monspecs.gtf &&\r\n!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\r\nmode_valid = 1;\r\nif (!mode_valid && info->monspecs.modedb_len) {\r\nconst struct fb_videomode *mode;\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (mode) {\r\nfb_videomode_to_var(var, mode);\r\nmode_valid = 1;\r\n}\r\n}\r\n#endif\r\nif (!mode_valid && info->monspecs.modedb_len == 0) {\r\nif (fb_get_mode(FB_MAXTIMINGS, 0, var, info)) {\r\nint default_sync = (info->monspecs.hfmin-HFMIN)\r\n|(info->monspecs.hfmax-HFMAX)\r\n|(info->monspecs.vfmin-VFMIN)\r\n|(info->monspecs.vfmax-VFMAX);\r\nprintk("i810fb: invalid video mode%s\n",\r\ndefault_sync ? "" : ". Specifying "\r\n"vsyncN/hsyncN parameters may help");\r\nretval = -EINVAL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic int encode_fix(struct fb_fix_screeninfo *fix, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nmemset(fix, 0, sizeof(struct fb_fix_screeninfo));\r\nstrcpy(fix->id, "I810");\r\nmutex_lock(&info->mm_lock);\r\nfix->smem_start = par->fb.physical;\r\nfix->smem_len = par->fb.size;\r\nmutex_unlock(&info->mm_lock);\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->type_aux = 0;\r\nfix->xpanstep = 8;\r\nfix->ypanstep = 1;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\nif (info->var.nonstd)\r\nfix->visual = FB_VISUAL_DIRECTCOLOR;\r\nelse\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfix->ywrapstep = 0;\r\nfix->line_length = par->pitch;\r\nfix->mmio_start = par->mmio_start_phys;\r\nfix->mmio_len = MMIO_SIZE;\r\nfix->accel = FB_ACCEL_I810;\r\nreturn 0;\r\n}\r\nstatic void decode_var(const struct fb_var_screeninfo *var,\r\nstruct i810fb_par *par)\r\n{\r\nu32 xres, yres, vxres, vyres;\r\nxres = var->xres;\r\nyres = var->yres;\r\nvxres = var->xres_virtual;\r\nvyres = var->yres_virtual;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\npar->pixconf = PIXCONF8;\r\npar->bltcntl = 0;\r\npar->depth = 1;\r\npar->blit_bpp = BPP8;\r\nbreak;\r\ncase 16:\r\nif (var->green.length == 5)\r\npar->pixconf = PIXCONF15;\r\nelse\r\npar->pixconf = PIXCONF16;\r\npar->bltcntl = 16;\r\npar->depth = 2;\r\npar->blit_bpp = BPP16;\r\nbreak;\r\ncase 24:\r\npar->pixconf = PIXCONF24;\r\npar->bltcntl = 32;\r\npar->depth = 3;\r\npar->blit_bpp = BPP24;\r\nbreak;\r\ncase 32:\r\npar->pixconf = PIXCONF32;\r\npar->bltcntl = 0;\r\npar->depth = 4;\r\npar->blit_bpp = 3 << 24;\r\nbreak;\r\n}\r\nif (var->nonstd && var->bits_per_pixel != 8)\r\npar->pixconf |= 1 << 27;\r\ni810_calc_dclk(var->pixclock, &par->regs.M,\r\n&par->regs.N, &par->regs.P);\r\ni810fb_encode_registers(var, par, xres, yres);\r\npar->watermark = i810_get_watermark(var, par);\r\npar->pitch = get_line_length(par, vxres, var->bits_per_pixel);\r\n}\r\nstatic int i810fb_getcolreg(u8 regno, u8 *red, u8 *green, u8 *blue,\r\nu8 *transp, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nu8 temp;\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nif ((info->var.green.length == 5 && regno > 31) ||\r\n(info->var.green.length == 6 && regno > 63))\r\nreturn 1;\r\n}\r\ntemp = i810_readb(PIXCONF1, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp & ~EXTENDED_PALETTE);\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\r\ninfo->var.green.length == 5)\r\ni810_read_dac(regno * 8, red, green, blue, mmio);\r\nelse if (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\r\ninfo->var.green.length == 6) {\r\nu8 tmp;\r\ni810_read_dac(regno * 8, red, &tmp, blue, mmio);\r\ni810_read_dac(regno * 4, &tmp, green, &tmp, mmio);\r\n}\r\nelse\r\ni810_read_dac(regno, red, green, blue, mmio);\r\n*transp = 0;\r\ni810_writeb(PIXCONF1, mmio, temp);\r\nreturn 0;\r\n}\r\nstatic int i810fb_open(struct fb_info *info, int user)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nmutex_lock(&par->open_lock);\r\nif (par->use_count == 0) {\r\nmemset(&par->state, 0, sizeof(struct vgastate));\r\npar->state.flags = VGA_SAVE_CMAP;\r\npar->state.vgabase = par->mmio_start_virtual;\r\nsave_vga(&par->state);\r\ni810_save_vga_state(par);\r\n}\r\npar->use_count++;\r\nmutex_unlock(&par->open_lock);\r\nreturn 0;\r\n}\r\nstatic int i810fb_release(struct fb_info *info, int user)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nmutex_lock(&par->open_lock);\r\nif (par->use_count == 0) {\r\nmutex_unlock(&par->open_lock);\r\nreturn -EINVAL;\r\n}\r\nif (par->use_count == 1) {\r\ni810_restore_vga_state(par);\r\nrestore_vga(&par->state);\r\n}\r\npar->use_count--;\r\nmutex_unlock(&par->open_lock);\r\nreturn 0;\r\n}\r\nstatic int i810fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nu8 temp;\r\nint i;\r\nif (regno > 255) return 1;\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nif ((info->var.green.length == 5 && regno > 31) ||\r\n(info->var.green.length == 6 && regno > 63))\r\nreturn 1;\r\n}\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\ntemp = i810_readb(PIXCONF1, mmio);\r\ni810_writeb(PIXCONF1, mmio, temp & ~EXTENDED_PALETTE);\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\r\ninfo->var.green.length == 5) {\r\nfor (i = 0; i < 8; i++)\r\ni810_write_dac((u8) (regno * 8) + i, (u8) red,\r\n(u8) green, (u8) blue, mmio);\r\n} else if (info->fix.visual == FB_VISUAL_DIRECTCOLOR &&\r\ninfo->var.green.length == 6) {\r\nu8 r, g, b;\r\nif (regno < 32) {\r\nfor (i = 0; i < 8; i++)\r\ni810_write_dac((u8) (regno * 8) + i,\r\n(u8) red, (u8) green,\r\n(u8) blue, mmio);\r\n}\r\ni810_read_dac((u8) (regno*4), &r, &g, &b, mmio);\r\nfor (i = 0; i < 4; i++)\r\ni810_write_dac((u8) (regno*4) + i, r, (u8) green,\r\nb, mmio);\r\n} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR) {\r\ni810_write_dac((u8) regno, (u8) red, (u8) green,\r\n(u8) blue, mmio);\r\n}\r\ni810_writeb(PIXCONF1, mmio, temp);\r\nif (regno < 16) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nif (info->var.green.length == 5)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n(regno << 10) | (regno << 5) |\r\nregno;\r\nelse\r\n((u32 *)info->pseudo_palette)[regno] =\r\n(regno << 11) | (regno << 5) |\r\nregno;\r\n} else {\r\nif (info->var.green.length == 5) {\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\n} else {\r\n((u32 *)info->pseudo_palette)[regno] =\r\n(red & 0xf800) |\r\n((green & 0xf800) >> 5) |\r\n((blue & 0xf800) >> 11);\r\n}\r\n}\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\n((u32 *)info->pseudo_palette)[regno] =\r\n(regno << 16) | (regno << 8) |\r\nregno;\r\nelse\r\n((u32 *)info->pseudo_palette)[regno] =\r\n((red & 0xff00) << 8) |\r\n(green & 0xff00) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu32 total;\r\ntotal = var->xoffset * par->depth +\r\nvar->yoffset * info->fix.line_length;\r\ni810fb_load_front(total, info);\r\nreturn 0;\r\n}\r\nstatic int i810fb_blank (int blank_mode, struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nint mode = 0, pwr, scr_off = 0;\r\npwr = i810_readl(PWR_CLKC, mmio);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nmode = POWERON;\r\npwr |= 1;\r\nscr_off = ON;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nmode = POWERON;\r\npwr |= 1;\r\nscr_off = OFF;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nmode = STANDBY;\r\npwr |= 1;\r\nscr_off = OFF;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nmode = SUSPEND;\r\npwr |= 1;\r\nscr_off = OFF;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nmode = POWERDOWN;\r\npwr &= ~1;\r\nscr_off = OFF;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni810_screen_off(mmio, scr_off);\r\ni810_writel(HVSYNC, mmio, mode);\r\ni810_writel(PWR_CLKC, mmio, pwr);\r\nreturn 0;\r\n}\r\nstatic int i810fb_set_par(struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\ndecode_var(&info->var, par);\r\ni810_load_regs(par);\r\ni810_init_cursor(par);\r\nencode_fix(&info->fix, info);\r\nif (info->var.accel_flags && !(par->dev_flags & LOCKUP)) {\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\ninfo->pixmap.scan_align = 2;\r\n} else {\r\ninfo->pixmap.scan_align = 1;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint err;\r\nif (IS_DVT) {\r\nvar->vmode &= ~FB_VMODE_MASK;\r\nvar->vmode |= FB_VMODE_NONINTERLACED;\r\n}\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\nvar->vmode &= ~FB_VMODE_MASK;\r\nvar->vmode |= FB_VMODE_NONINTERLACED;\r\n}\r\ni810_round_off(var);\r\nif ((err = i810_check_params(var, info)))\r\nreturn err;\r\ni810fb_fill_var_timings(var);\r\nset_color_bitfields(var);\r\nreturn 0;\r\n}\r\nstatic int i810fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nif (par->dev_flags & LOCKUP)\r\nreturn -ENXIO;\r\nif (cursor->image.width > 64 || cursor->image.height > 64)\r\nreturn -ENXIO;\r\nif ((i810_readl(CURBASE, mmio) & 0xf) != par->cursor_heap.physical) {\r\ni810_init_cursor(par);\r\ncursor->set |= FB_CUR_SETALL;\r\n}\r\ni810_enable_cursor(mmio, OFF);\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nu32 tmp;\r\ntmp = (cursor->image.dx - info->var.xoffset) & 0xffff;\r\ntmp |= (cursor->image.dy - info->var.yoffset) << 16;\r\ni810_writel(CURPOS, mmio, tmp);\r\n}\r\nif (cursor->set & FB_CUR_SETSIZE)\r\ni810_reset_cursor_image(par);\r\nif (cursor->set & FB_CUR_SETCMAP)\r\ni810_load_cursor_colors(cursor->image.fg_color,\r\ncursor->image.bg_color,\r\ninfo);\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nint size = ((cursor->image.width + 7) >> 3) *\r\ncursor->image.height;\r\nint i;\r\nu8 *data = kmalloc(64 * 8, GFP_ATOMIC);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < size; i++)\r\ndata[i] = cursor->image.data[i] ^ cursor->mask[i];\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nfor (i = 0; i < size; i++)\r\ndata[i] = cursor->image.data[i] & cursor->mask[i];\r\nbreak;\r\n}\r\ni810_load_cursor_image(cursor->image.width,\r\ncursor->image.height, data,\r\npar);\r\nkfree(data);\r\n}\r\nif (cursor->enable)\r\ni810_enable_cursor(mmio, ON);\r\nreturn 0;\r\n}\r\nstatic int i810fb_suspend(struct pci_dev *dev, pm_message_t mesg)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct i810fb_par *par = info->par;\r\npar->cur_state = mesg.event;\r\nswitch (mesg.event) {\r\ncase PM_EVENT_FREEZE:\r\ncase PM_EVENT_PRETHAW:\r\ndev->dev.power.power_state = mesg;\r\nreturn 0;\r\n}\r\nconsole_lock();\r\nfb_set_suspend(info, 1);\r\nif (info->fbops->fb_sync)\r\ninfo->fbops->fb_sync(info);\r\ni810fb_blank(FB_BLANK_POWERDOWN, info);\r\nagp_unbind_memory(par->i810_gtt.i810_fb_memory);\r\nagp_unbind_memory(par->i810_gtt.i810_cursor_memory);\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, mesg));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int i810fb_resume(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct i810fb_par *par = info->par;\r\nint cur_state = par->cur_state;\r\npar->cur_state = PM_EVENT_ON;\r\nif (cur_state == PM_EVENT_FREEZE) {\r\npci_set_power_state(dev, PCI_D0);\r\nreturn 0;\r\n}\r\nconsole_lock();\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nif (pci_enable_device(dev))\r\ngoto fail;\r\npci_set_master(dev);\r\nagp_bind_memory(par->i810_gtt.i810_fb_memory,\r\npar->fb.offset);\r\nagp_bind_memory(par->i810_gtt.i810_cursor_memory,\r\npar->cursor_heap.offset);\r\ni810fb_set_par(info);\r\nfb_set_suspend (info, 0);\r\ninfo->fbops->fb_blank(VESA_NO_BLANKING, info);\r\nfail:\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic void i810_fix_pointers(struct i810fb_par *par)\r\n{\r\npar->fb.physical = par->aperture.physical+(par->fb.offset << 12);\r\npar->fb.virtual = par->aperture.virtual+(par->fb.offset << 12);\r\npar->iring.physical = par->aperture.physical +\r\n(par->iring.offset << 12);\r\npar->iring.virtual = par->aperture.virtual +\r\n(par->iring.offset << 12);\r\npar->cursor_heap.virtual = par->aperture.virtual+\r\n(par->cursor_heap.offset << 12);\r\n}\r\nstatic void i810_fix_offsets(struct i810fb_par *par)\r\n{\r\nif (vram + 1 > par->aperture.size >> 20)\r\nvram = (par->aperture.size >> 20) - 1;\r\nif (v_offset_default > (par->aperture.size >> 20))\r\nv_offset_default = (par->aperture.size >> 20);\r\nif (vram + v_offset_default + 1 > par->aperture.size >> 20)\r\nv_offset_default = (par->aperture.size >> 20) - (vram + 1);\r\npar->fb.size = vram << 20;\r\npar->fb.offset = v_offset_default << 20;\r\npar->fb.offset >>= 12;\r\npar->iring.offset = par->fb.offset + (par->fb.size >> 12);\r\npar->iring.size = RINGBUFFER_SIZE;\r\npar->cursor_heap.offset = par->iring.offset + (RINGBUFFER_SIZE >> 12);\r\npar->cursor_heap.size = 4096;\r\n}\r\nstatic int i810_alloc_agp_mem(struct fb_info *info)\r\n{\r\nstruct i810fb_par *par = info->par;\r\nint size;\r\nstruct agp_bridge_data *bridge;\r\ni810_fix_offsets(par);\r\nsize = par->fb.size + par->iring.size;\r\nif (!(bridge = agp_backend_acquire(par->dev))) {\r\nprintk("i810fb_alloc_fbmem: cannot acquire agpgart\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(par->i810_gtt.i810_fb_memory =\r\nagp_allocate_memory(bridge, size >> 12, AGP_NORMAL_MEMORY))) {\r\nprintk("i810fb_alloc_fbmem: can't allocate framebuffer "\r\n"memory\n");\r\nagp_backend_release(bridge);\r\nreturn -ENOMEM;\r\n}\r\nif (agp_bind_memory(par->i810_gtt.i810_fb_memory,\r\npar->fb.offset)) {\r\nprintk("i810fb_alloc_fbmem: can't bind framebuffer memory\n");\r\nagp_backend_release(bridge);\r\nreturn -EBUSY;\r\n}\r\nif (!(par->i810_gtt.i810_cursor_memory =\r\nagp_allocate_memory(bridge, par->cursor_heap.size >> 12,\r\nAGP_PHYSICAL_MEMORY))) {\r\nprintk("i810fb_alloc_cursormem: can't allocate "\r\n"cursor memory\n");\r\nagp_backend_release(bridge);\r\nreturn -ENOMEM;\r\n}\r\nif (agp_bind_memory(par->i810_gtt.i810_cursor_memory,\r\npar->cursor_heap.offset)) {\r\nprintk("i810fb_alloc_cursormem: cannot bind cursor memory\n");\r\nagp_backend_release(bridge);\r\nreturn -EBUSY;\r\n}\r\npar->cursor_heap.physical = par->i810_gtt.i810_cursor_memory->physical;\r\ni810_fix_pointers(par);\r\nagp_backend_release(bridge);\r\nreturn 0;\r\n}\r\nstatic void i810_init_monspecs(struct fb_info *info)\r\n{\r\nif (!hsync1)\r\nhsync1 = HFMIN;\r\nif (!hsync2)\r\nhsync2 = HFMAX;\r\nif (!info->monspecs.hfmax)\r\ninfo->monspecs.hfmax = hsync2;\r\nif (!info->monspecs.hfmin)\r\ninfo->monspecs.hfmin = hsync1;\r\nif (hsync2 < hsync1)\r\ninfo->monspecs.hfmin = hsync2;\r\nif (!vsync1)\r\nvsync1 = VFMIN;\r\nif (!vsync2)\r\nvsync2 = VFMAX;\r\nif (IS_DVT && vsync1 < 60)\r\nvsync1 = 60;\r\nif (!info->monspecs.vfmax)\r\ninfo->monspecs.vfmax = vsync2;\r\nif (!info->monspecs.vfmin)\r\ninfo->monspecs.vfmin = vsync1;\r\nif (vsync2 < vsync1)\r\ninfo->monspecs.vfmin = vsync2;\r\n}\r\nstatic void i810_init_defaults(struct i810fb_par *par, struct fb_info *info)\r\n{\r\nmutex_init(&par->open_lock);\r\nif (voffset)\r\nv_offset_default = voffset;\r\nelse if (par->aperture.size > 32 * 1024 * 1024)\r\nv_offset_default = 16;\r\nelse\r\nv_offset_default = 8;\r\nif (!vram)\r\nvram = 1;\r\nif (accel)\r\npar->dev_flags |= HAS_ACCELERATION;\r\nif (sync)\r\npar->dev_flags |= ALWAYS_SYNC;\r\npar->ddc_num = (ddc3 ? 3 : 2);\r\nif (bpp < 8)\r\nbpp = 8;\r\npar->i810fb_ops = i810fb_ops;\r\nif (xres)\r\ninfo->var.xres = xres;\r\nelse\r\ninfo->var.xres = 640;\r\nif (yres)\r\ninfo->var.yres = yres;\r\nelse\r\ninfo->var.yres = 480;\r\nif (!vyres)\r\nvyres = (vram << 20)/(info->var.xres*bpp >> 3);\r\ninfo->var.yres_virtual = vyres;\r\ninfo->var.bits_per_pixel = bpp;\r\nif (dcolor)\r\ninfo->var.nonstd = 1;\r\nif (par->dev_flags & HAS_ACCELERATION)\r\ninfo->var.accel_flags = 1;\r\ni810_init_monspecs(info);\r\n}\r\nstatic void i810_init_device(struct i810fb_par *par)\r\n{\r\nu8 reg;\r\nu8 __iomem *mmio = par->mmio_start_virtual;\r\nif (mtrr)\r\npar->wc_cookie= arch_phys_wc_add((u32) par->aperture.physical,\r\npar->aperture.size);\r\ni810_init_cursor(par);\r\nif (extvga) {\r\ni810_writel(HVSYNC, mmio, 0);\r\ni810_writel(PWR_CLKC, mmio, 3);\r\n}\r\npci_read_config_byte(par->dev, 0x50, &reg);\r\nreg &= FREQ_MASK;\r\npar->mem_freq = (reg) ? 133 : 100;\r\n}\r\nstatic int i810_allocate_pci_resource(struct i810fb_par *par,\r\nconst struct pci_device_id *entry)\r\n{\r\nint err;\r\nif ((err = pci_enable_device(par->dev))) {\r\nprintk("i810fb_init: cannot enable device\n");\r\nreturn err;\r\n}\r\npar->res_flags |= PCI_DEVICE_ENABLED;\r\nif (pci_resource_len(par->dev, 0) > 512 * 1024) {\r\npar->aperture.physical = pci_resource_start(par->dev, 0);\r\npar->aperture.size = pci_resource_len(par->dev, 0);\r\npar->mmio_start_phys = pci_resource_start(par->dev, 1);\r\n} else {\r\npar->aperture.physical = pci_resource_start(par->dev, 1);\r\npar->aperture.size = pci_resource_len(par->dev, 1);\r\npar->mmio_start_phys = pci_resource_start(par->dev, 0);\r\n}\r\nif (!par->aperture.size) {\r\nprintk("i810fb_init: device is disabled\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!request_mem_region(par->aperture.physical,\r\npar->aperture.size,\r\ni810_pci_list[entry->driver_data])) {\r\nprintk("i810fb_init: cannot request framebuffer region\n");\r\nreturn -ENODEV;\r\n}\r\npar->res_flags |= FRAMEBUFFER_REQ;\r\npar->aperture.virtual = ioremap_wc(par->aperture.physical,\r\npar->aperture.size);\r\nif (!par->aperture.virtual) {\r\nprintk("i810fb_init: cannot remap framebuffer region\n");\r\nreturn -ENODEV;\r\n}\r\nif (!request_mem_region(par->mmio_start_phys,\r\nMMIO_SIZE,\r\ni810_pci_list[entry->driver_data])) {\r\nprintk("i810fb_init: cannot request mmio region\n");\r\nreturn -ENODEV;\r\n}\r\npar->res_flags |= MMIO_REQ;\r\npar->mmio_start_virtual = ioremap_nocache(par->mmio_start_phys,\r\nMMIO_SIZE);\r\nif (!par->mmio_start_virtual) {\r\nprintk("i810fb_init: cannot remap mmio region\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i810fb_find_init_mode(struct fb_info *info)\r\n{\r\nstruct fb_videomode mode;\r\nstruct fb_var_screeninfo var;\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nint found = 0;\r\n#ifdef CONFIG_FB_I810_I2C\r\nint i;\r\nint err = 1;\r\nstruct i810fb_par *par = info->par;\r\n#endif\r\nINIT_LIST_HEAD(&info->modelist);\r\nmemset(&mode, 0, sizeof(struct fb_videomode));\r\nvar = info->var;\r\n#ifdef CONFIG_FB_I810_I2C\r\ni810_create_i2c_busses(par);\r\nfor (i = 0; i < par->ddc_num + 1; i++) {\r\nerr = i810_probe_i2c_connector(info, &par->edid, i);\r\nif (!err)\r\nbreak;\r\n}\r\nif (!err)\r\nprintk("i810fb_init_pci: DDC probe successful\n");\r\nfb_edid_to_monspecs(par->edid, specs);\r\nif (specs->modedb == NULL)\r\nprintk("i810fb_init_pci: Unable to get Mode Database\n");\r\nfb_videomode_to_modelist(specs->modedb, specs->modedb_len,\r\n&info->modelist);\r\nif (specs->modedb != NULL) {\r\nconst struct fb_videomode *m;\r\nif (xres && yres) {\r\nif ((m = fb_find_best_mode(&var, &info->modelist))) {\r\nmode = *m;\r\nfound = 1;\r\n}\r\n}\r\nif (!found) {\r\nm = fb_find_best_display(&info->monspecs, &info->modelist);\r\nmode = *m;\r\nfound = 1;\r\n}\r\nfb_videomode_to_var(&var, &mode);\r\n}\r\n#endif\r\nif (mode_option)\r\nfb_find_mode(&var, info, mode_option, specs->modedb,\r\nspecs->modedb_len, (found) ? &mode : NULL,\r\ninfo->var.bits_per_pixel);\r\ninfo->var = var;\r\nfb_destroy_modedb(specs->modedb);\r\nspecs->modedb = NULL;\r\n}\r\nstatic int i810fb_setup(char *options)\r\n{\r\nchar *this_opt, *suffix = NULL;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "mtrr", 4))\r\nmtrr = 1;\r\nelse if (!strncmp(this_opt, "accel", 5))\r\naccel = 1;\r\nelse if (!strncmp(this_opt, "extvga", 6))\r\nextvga = 1;\r\nelse if (!strncmp(this_opt, "sync", 4))\r\nsync = 1;\r\nelse if (!strncmp(this_opt, "vram:", 5))\r\nvram = (simple_strtoul(this_opt+5, NULL, 0));\r\nelse if (!strncmp(this_opt, "voffset:", 8))\r\nvoffset = (simple_strtoul(this_opt+8, NULL, 0));\r\nelse if (!strncmp(this_opt, "xres:", 5))\r\nxres = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "yres:", 5))\r\nyres = simple_strtoul(this_opt+5, NULL, 0);\r\nelse if (!strncmp(this_opt, "vyres:", 6))\r\nvyres = simple_strtoul(this_opt+6, NULL, 0);\r\nelse if (!strncmp(this_opt, "bpp:", 4))\r\nbpp = simple_strtoul(this_opt+4, NULL, 0);\r\nelse if (!strncmp(this_opt, "hsync1:", 7)) {\r\nhsync1 = simple_strtoul(this_opt+7, &suffix, 0);\r\nif (strncmp(suffix, "H", 1))\r\nhsync1 *= 1000;\r\n} else if (!strncmp(this_opt, "hsync2:", 7)) {\r\nhsync2 = simple_strtoul(this_opt+7, &suffix, 0);\r\nif (strncmp(suffix, "H", 1))\r\nhsync2 *= 1000;\r\n} else if (!strncmp(this_opt, "vsync1:", 7))\r\nvsync1 = simple_strtoul(this_opt+7, NULL, 0);\r\nelse if (!strncmp(this_opt, "vsync2:", 7))\r\nvsync2 = simple_strtoul(this_opt+7, NULL, 0);\r\nelse if (!strncmp(this_opt, "dcolor", 6))\r\ndcolor = 1;\r\nelse if (!strncmp(this_opt, "ddc3", 4))\r\nddc3 = true;\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i810fb_init_pci(struct pci_dev *dev,\r\nconst struct pci_device_id *entry)\r\n{\r\nstruct fb_info *info;\r\nstruct i810fb_par *par = NULL;\r\nstruct fb_videomode mode;\r\nint err = -1, vfreq, hfreq, pixclock;\r\ninfo = framebuffer_alloc(sizeof(struct i810fb_par), &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npar->dev = dev;\r\nif (!(info->pixmap.addr = kzalloc(8*1024, GFP_KERNEL))) {\r\ni810fb_release_resource(info, par);\r\nreturn -ENOMEM;\r\n}\r\ninfo->pixmap.size = 8*1024;\r\ninfo->pixmap.buf_align = 8;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif ((err = i810_allocate_pci_resource(par, entry))) {\r\ni810fb_release_resource(info, par);\r\nreturn err;\r\n}\r\ni810_init_defaults(par, info);\r\nif ((err = i810_alloc_agp_mem(info))) {\r\ni810fb_release_resource(info, par);\r\nreturn err;\r\n}\r\ni810_init_device(par);\r\ninfo->screen_base = par->fb.virtual;\r\ninfo->fbops = &par->i810fb_ops;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nfb_alloc_cmap(&info->cmap, 256, 0);\r\ni810fb_find_init_mode(info);\r\nif ((err = info->fbops->fb_check_var(&info->var, info))) {\r\ni810fb_release_resource(info, par);\r\nreturn err;\r\n}\r\nfb_var_to_videomode(&mode, &info->var);\r\nfb_add_videomode(&mode, &info->modelist);\r\ni810fb_init_ringbuffer(info);\r\nerr = register_framebuffer(info);\r\nif (err < 0) {\r\ni810fb_release_resource(info, par);\r\nprintk("i810fb_init: cannot register framebuffer device\n");\r\nreturn err;\r\n}\r\npci_set_drvdata(dev, info);\r\npixclock = 1000000000/(info->var.pixclock);\r\npixclock *= 1000;\r\nhfreq = pixclock/(info->var.xres + info->var.left_margin +\r\ninfo->var.hsync_len + info->var.right_margin);\r\nvfreq = hfreq/(info->var.yres + info->var.upper_margin +\r\ninfo->var.vsync_len + info->var.lower_margin);\r\nprintk("I810FB: fb%d : %s v%d.%d.%d%s\n"\r\n"I810FB: Video RAM : %dK\n"\r\n"I810FB: Monitor : H: %d-%d KHz V: %d-%d Hz\n"\r\n"I810FB: Mode : %dx%d-%dbpp@%dHz\n",\r\ninfo->node,\r\ni810_pci_list[entry->driver_data],\r\nVERSION_MAJOR, VERSION_MINOR, VERSION_TEENIE, BRANCH_VERSION,\r\n(int) par->fb.size>>10, info->monspecs.hfmin/1000,\r\ninfo->monspecs.hfmax/1000, info->monspecs.vfmin,\r\ninfo->monspecs.vfmax, info->var.xres,\r\ninfo->var.yres, info->var.bits_per_pixel, vfreq);\r\nreturn 0;\r\n}\r\nstatic void i810fb_release_resource(struct fb_info *info,\r\nstruct i810fb_par *par)\r\n{\r\nstruct gtt_data *gtt = &par->i810_gtt;\r\narch_phys_wc_del(par->wc_cookie);\r\ni810_delete_i2c_busses(par);\r\nif (par->i810_gtt.i810_cursor_memory)\r\nagp_free_memory(gtt->i810_cursor_memory);\r\nif (par->i810_gtt.i810_fb_memory)\r\nagp_free_memory(gtt->i810_fb_memory);\r\nif (par->mmio_start_virtual)\r\niounmap(par->mmio_start_virtual);\r\nif (par->aperture.virtual)\r\niounmap(par->aperture.virtual);\r\nkfree(par->edid);\r\nif (par->res_flags & FRAMEBUFFER_REQ)\r\nrelease_mem_region(par->aperture.physical,\r\npar->aperture.size);\r\nif (par->res_flags & MMIO_REQ)\r\nrelease_mem_region(par->mmio_start_phys, MMIO_SIZE);\r\nframebuffer_release(info);\r\n}\r\nstatic void __exit i810fb_remove_pci(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct i810fb_par *par = info->par;\r\nunregister_framebuffer(info);\r\ni810fb_release_resource(info, par);\r\nprintk("cleanup_module: unloaded i810 framebuffer device\n");\r\n}\r\nstatic int i810fb_init(void)\r\n{\r\nchar *option = NULL;\r\nif (fb_get_options("i810fb", &option))\r\nreturn -ENODEV;\r\ni810fb_setup(option);\r\nreturn pci_register_driver(&i810fb_driver);\r\n}\r\nstatic int i810fb_init(void)\r\n{\r\nhsync1 *= 1000;\r\nhsync2 *= 1000;\r\nreturn pci_register_driver(&i810fb_driver);\r\n}\r\nstatic void __exit i810fb_exit(void)\r\n{\r\npci_unregister_driver(&i810fb_driver);\r\n}
