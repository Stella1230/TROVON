static unsigned int rotary_encoder_get_state(struct rotary_encoder *encoder)\r\n{\r\nint i;\r\nunsigned int ret = 0;\r\nfor (i = 0; i < encoder->gpios->ndescs; ++i) {\r\nint val = gpiod_get_value_cansleep(encoder->gpios->desc[i]);\r\nif (encoder->encoding == ROTENC_GRAY && ret & 1)\r\nval = !val;\r\nret = ret << 1 | val;\r\n}\r\nreturn ret & 3;\r\n}\r\nstatic void rotary_encoder_report_event(struct rotary_encoder *encoder)\r\n{\r\nif (encoder->relative_axis) {\r\ninput_report_rel(encoder->input,\r\nencoder->axis, encoder->dir);\r\n} else {\r\nunsigned int pos = encoder->pos;\r\nif (encoder->dir < 0) {\r\nif (encoder->rollover)\r\npos += encoder->steps;\r\nif (pos)\r\npos--;\r\n} else {\r\nif (encoder->rollover || pos < encoder->steps)\r\npos++;\r\n}\r\nif (encoder->rollover)\r\npos %= encoder->steps;\r\nencoder->pos = pos;\r\ninput_report_abs(encoder->input, encoder->axis, encoder->pos);\r\n}\r\ninput_sync(encoder->input);\r\n}\r\nstatic irqreturn_t rotary_encoder_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nunsigned int state;\r\nmutex_lock(&encoder->access_mutex);\r\nstate = rotary_encoder_get_state(encoder);\r\nswitch (state) {\r\ncase 0x0:\r\nif (encoder->armed) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->armed = false;\r\n}\r\nbreak;\r\ncase 0x1:\r\ncase 0x3:\r\nif (encoder->armed)\r\nencoder->dir = 2 - state;\r\nbreak;\r\ncase 0x2:\r\nencoder->armed = true;\r\nbreak;\r\n}\r\nmutex_unlock(&encoder->access_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t rotary_encoder_half_period_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nunsigned int state;\r\nmutex_lock(&encoder->access_mutex);\r\nstate = rotary_encoder_get_state(encoder);\r\nif (state & 1) {\r\nencoder->dir = ((encoder->last_stable - state + 1) % 4) - 1;\r\n} else {\r\nif (state != encoder->last_stable) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->last_stable = state;\r\n}\r\n}\r\nmutex_unlock(&encoder->access_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t rotary_encoder_quarter_period_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nunsigned int state;\r\nmutex_lock(&encoder->access_mutex);\r\nstate = rotary_encoder_get_state(encoder);\r\nif ((encoder->last_stable + 1) % 4 == state)\r\nencoder->dir = 1;\r\nelse if (encoder->last_stable == (state + 1) % 4)\r\nencoder->dir = -1;\r\nelse\r\ngoto out;\r\nrotary_encoder_report_event(encoder);\r\nout:\r\nencoder->last_stable = state;\r\nmutex_unlock(&encoder->access_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rotary_encoder_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rotary_encoder *encoder;\r\nstruct input_dev *input;\r\nirq_handler_t handler;\r\nu32 steps_per_period;\r\nunsigned int i;\r\nint err;\r\nencoder = devm_kzalloc(dev, sizeof(struct rotary_encoder), GFP_KERNEL);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nmutex_init(&encoder->access_mutex);\r\ndevice_property_read_u32(dev, "rotary-encoder,steps", &encoder->steps);\r\nerr = device_property_read_u32(dev, "rotary-encoder,steps-per-period",\r\n&steps_per_period);\r\nif (err) {\r\nsteps_per_period = device_property_read_bool(dev,\r\n"rotary-encoder,half-period") ? 2 : 1;\r\n}\r\nencoder->rollover =\r\ndevice_property_read_bool(dev, "rotary-encoder,rollover");\r\nif (!device_property_present(dev, "rotary-encoder,encoding") ||\r\n!device_property_match_string(dev, "rotary-encoder,encoding",\r\n"gray")) {\r\ndev_info(dev, "gray");\r\nencoder->encoding = ROTENC_GRAY;\r\n} else if (!device_property_match_string(dev, "rotary-encoder,encoding",\r\n"binary")) {\r\ndev_info(dev, "binary");\r\nencoder->encoding = ROTENC_BINARY;\r\n} else {\r\ndev_err(dev, "unknown encoding setting\n");\r\nreturn -EINVAL;\r\n}\r\ndevice_property_read_u32(dev, "linux,axis", &encoder->axis);\r\nencoder->relative_axis =\r\ndevice_property_read_bool(dev, "rotary-encoder,relative-axis");\r\nencoder->gpios = devm_gpiod_get_array(dev, NULL, GPIOD_IN);\r\nif (IS_ERR(encoder->gpios)) {\r\ndev_err(dev, "unable to get gpios\n");\r\nreturn PTR_ERR(encoder->gpios);\r\n}\r\nif (encoder->gpios->ndescs < 2) {\r\ndev_err(dev, "not enough gpios found\n");\r\nreturn -EINVAL;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nencoder->input = input;\r\ninput->name = pdev->name;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = dev;\r\nif (encoder->relative_axis)\r\ninput_set_capability(input, EV_REL, encoder->axis);\r\nelse\r\ninput_set_abs_params(input,\r\nencoder->axis, 0, encoder->steps, 0, 1);\r\nswitch (steps_per_period >> (encoder->gpios->ndescs - 2)) {\r\ncase 4:\r\nhandler = &rotary_encoder_quarter_period_irq;\r\nencoder->last_stable = rotary_encoder_get_state(encoder);\r\nbreak;\r\ncase 2:\r\nhandler = &rotary_encoder_half_period_irq;\r\nencoder->last_stable = rotary_encoder_get_state(encoder);\r\nbreak;\r\ncase 1:\r\nhandler = &rotary_encoder_irq;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "'%d' is not a valid steps-per-period value\n",\r\nsteps_per_period);\r\nreturn -EINVAL;\r\n}\r\nencoder->irq =\r\ndevm_kzalloc(dev,\r\nsizeof(*encoder->irq) * encoder->gpios->ndescs,\r\nGFP_KERNEL);\r\nif (!encoder->irq)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < encoder->gpios->ndescs; ++i) {\r\nencoder->irq[i] = gpiod_to_irq(encoder->gpios->desc[i]);\r\nerr = devm_request_threaded_irq(dev, encoder->irq[i],\r\nNULL, handler,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nDRV_NAME, encoder);\r\nif (err) {\r\ndev_err(dev, "unable to request IRQ %d (gpio#%d)\n",\r\nencoder->irq[i], i);\r\nreturn err;\r\n}\r\n}\r\nerr = input_register_device(input);\r\nif (err) {\r\ndev_err(dev, "failed to register input device\n");\r\nreturn err;\r\n}\r\ndevice_init_wakeup(dev,\r\ndevice_property_read_bool(dev, "wakeup-source"));\r\nplatform_set_drvdata(pdev, encoder);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rotary_encoder_suspend(struct device *dev)\r\n{\r\nstruct rotary_encoder *encoder = dev_get_drvdata(dev);\r\nunsigned int i;\r\nif (device_may_wakeup(dev)) {\r\nfor (i = 0; i < encoder->gpios->ndescs; ++i)\r\nenable_irq_wake(encoder->irq[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused rotary_encoder_resume(struct device *dev)\r\n{\r\nstruct rotary_encoder *encoder = dev_get_drvdata(dev);\r\nunsigned int i;\r\nif (device_may_wakeup(dev)) {\r\nfor (i = 0; i < encoder->gpios->ndescs; ++i)\r\ndisable_irq_wake(encoder->irq[i]);\r\n}\r\nreturn 0;\r\n}
