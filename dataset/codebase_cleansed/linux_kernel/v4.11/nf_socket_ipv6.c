static int\r\nextract_icmp6_fields(const struct sk_buff *skb,\r\nunsigned int outside_hdrlen,\r\nint *protocol,\r\nconst struct in6_addr **raddr,\r\nconst struct in6_addr **laddr,\r\n__be16 *rport,\r\n__be16 *lport,\r\nstruct ipv6hdr *ipv6_var)\r\n{\r\nconst struct ipv6hdr *inside_iph;\r\nstruct icmp6hdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nu8 inside_nexthdr;\r\n__be16 inside_fragoff;\r\nint inside_hdrlen;\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nif (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)\r\nreturn 1;\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph),\r\nsizeof(*ipv6_var), ipv6_var);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\ninside_nexthdr = inside_iph->nexthdr;\r\ninside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) +\r\nsizeof(*ipv6_var),\r\n&inside_nexthdr, &inside_fragoff);\r\nif (inside_hdrlen < 0)\r\nreturn 1;\r\nif (inside_nexthdr != IPPROTO_TCP &&\r\ninside_nexthdr != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, inside_hdrlen,\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_nexthdr;\r\n*laddr = &inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = &inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic struct sock *\r\nnf_socket_get_sock_v6(struct net *net, struct sk_buff *skb, int doff,\r\nconst u8 protocol,\r\nconst struct in6_addr *saddr, const struct in6_addr *daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in)\r\n{\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nreturn inet6_lookup(net, &tcp_hashinfo, skb, doff,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\ncase IPPROTO_UDP:\r\nreturn udp6_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\n}\r\nreturn NULL;\r\n}\r\nstruct sock *nf_sk_lookup_slow_v6(struct net *net, const struct sk_buff *skb,\r\nconst struct net_device *indev)\r\n{\r\n__be16 uninitialized_var(dport), uninitialized_var(sport);\r\nconst struct in6_addr *daddr = NULL, *saddr = NULL;\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct sk_buff *data_skb = NULL;\r\nint doff = 0;\r\nint thoff = 0, tproto;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NULL;\r\n}\r\nif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\r\nstruct udphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NULL;\r\nsaddr = &iph->saddr;\r\nsport = hp->source;\r\ndaddr = &iph->daddr;\r\ndport = hp->dest;\r\ndata_skb = (struct sk_buff *)skb;\r\ndoff = tproto == IPPROTO_TCP ?\r\nthoff + __tcp_hdrlen((struct tcphdr *)hp) :\r\nthoff + sizeof(*hp);\r\n} else if (tproto == IPPROTO_ICMPV6) {\r\nstruct ipv6hdr ipv6_var;\r\nif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\r\n&sport, &dport, &ipv6_var))\r\nreturn NULL;\r\n} else {\r\nreturn NULL;\r\n}\r\nreturn nf_socket_get_sock_v6(net, data_skb, doff, tproto, saddr, daddr,\r\nsport, dport, indev);\r\n}
