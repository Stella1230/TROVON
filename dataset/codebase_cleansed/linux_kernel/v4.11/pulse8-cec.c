static void pulse8_irq_work_handler(struct work_struct *work)\r\n{\r\nstruct pulse8 *pulse8 =\r\ncontainer_of(work, struct pulse8, work);\r\nswitch (pulse8->data[0] & 0x3f) {\r\ncase MSGCODE_FRAME_DATA:\r\ncec_received_msg(pulse8->adap, &pulse8->rx_msg);\r\nbreak;\r\ncase MSGCODE_TRANSMIT_SUCCEEDED:\r\ncec_transmit_done(pulse8->adap, CEC_TX_STATUS_OK,\r\n0, 0, 0, 0);\r\nbreak;\r\ncase MSGCODE_TRANSMIT_FAILED_ACK:\r\ncec_transmit_done(pulse8->adap, CEC_TX_STATUS_NACK,\r\n0, 1, 0, 0);\r\nbreak;\r\ncase MSGCODE_TRANSMIT_FAILED_LINE:\r\ncase MSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA:\r\ncase MSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE:\r\ncec_transmit_done(pulse8->adap, CEC_TX_STATUS_ERROR,\r\n0, 0, 0, 1);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t pulse8_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int flags)\r\n{\r\nstruct pulse8 *pulse8 = serio_get_drvdata(serio);\r\nif (!pulse8->started && data != MSGSTART)\r\nreturn IRQ_HANDLED;\r\nif (data == MSGESC) {\r\npulse8->escape = true;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (pulse8->escape) {\r\ndata += MSGOFFSET;\r\npulse8->escape = false;\r\n} else if (data == MSGEND) {\r\nstruct cec_msg *msg = &pulse8->rx_msg;\r\nif (debug)\r\ndev_info(pulse8->dev, "received: %*ph\n",\r\npulse8->idx, pulse8->buf);\r\npulse8->data[0] = pulse8->buf[0];\r\nswitch (pulse8->buf[0] & 0x3f) {\r\ncase MSGCODE_FRAME_START:\r\nmsg->len = 1;\r\nmsg->msg[0] = pulse8->buf[1];\r\nbreak;\r\ncase MSGCODE_FRAME_DATA:\r\nif (msg->len == CEC_MAX_MSG_SIZE)\r\nbreak;\r\nmsg->msg[msg->len++] = pulse8->buf[1];\r\nif (pulse8->buf[0] & MSGCODE_FRAME_EOM)\r\nschedule_work(&pulse8->work);\r\nbreak;\r\ncase MSGCODE_TRANSMIT_SUCCEEDED:\r\ncase MSGCODE_TRANSMIT_FAILED_LINE:\r\ncase MSGCODE_TRANSMIT_FAILED_ACK:\r\ncase MSGCODE_TRANSMIT_FAILED_TIMEOUT_DATA:\r\ncase MSGCODE_TRANSMIT_FAILED_TIMEOUT_LINE:\r\nschedule_work(&pulse8->work);\r\nbreak;\r\ncase MSGCODE_HIGH_ERROR:\r\ncase MSGCODE_LOW_ERROR:\r\ncase MSGCODE_RECEIVE_FAILED:\r\ncase MSGCODE_TIMEOUT_ERROR:\r\nbreak;\r\ncase MSGCODE_COMMAND_ACCEPTED:\r\ncase MSGCODE_COMMAND_REJECTED:\r\ndefault:\r\nif (pulse8->idx == 0)\r\nbreak;\r\nmemcpy(pulse8->data, pulse8->buf, pulse8->idx);\r\npulse8->len = pulse8->idx;\r\ncomplete(&pulse8->cmd_done);\r\nbreak;\r\n}\r\npulse8->idx = 0;\r\npulse8->started = false;\r\nreturn IRQ_HANDLED;\r\n} else if (data == MSGSTART) {\r\npulse8->idx = 0;\r\npulse8->started = true;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (pulse8->idx >= DATA_SIZE) {\r\ndev_dbg(pulse8->dev,\r\n"throwing away %d bytes of garbage\n", pulse8->idx);\r\npulse8->idx = 0;\r\n}\r\npulse8->buf[pulse8->idx++] = data;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pulse8_disconnect(struct serio *serio)\r\n{\r\nstruct pulse8 *pulse8 = serio_get_drvdata(serio);\r\ncec_unregister_adapter(pulse8->adap);\r\ncancel_delayed_work_sync(&pulse8->ping_eeprom_work);\r\ndev_info(&serio->dev, "disconnected\n");\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nkfree(pulse8);\r\n}\r\nstatic int pulse8_send(struct serio *serio, const u8 *command, u8 cmd_len)\r\n{\r\nint err = 0;\r\nerr = serio_write(serio, MSGSTART);\r\nif (err)\r\nreturn err;\r\nfor (; !err && cmd_len; command++, cmd_len--) {\r\nif (*command >= MSGESC) {\r\nerr = serio_write(serio, MSGESC);\r\nif (!err)\r\nerr = serio_write(serio, *command - MSGOFFSET);\r\n} else {\r\nerr = serio_write(serio, *command);\r\n}\r\n}\r\nif (!err)\r\nerr = serio_write(serio, MSGEND);\r\nreturn err;\r\n}\r\nstatic int pulse8_send_and_wait_once(struct pulse8 *pulse8,\r\nconst u8 *cmd, u8 cmd_len,\r\nu8 response, u8 size)\r\n{\r\nint err;\r\ninit_completion(&pulse8->cmd_done);\r\nerr = pulse8_send(pulse8->serio, cmd, cmd_len);\r\nif (err)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&pulse8->cmd_done, HZ))\r\nreturn -ETIMEDOUT;\r\nif ((pulse8->data[0] & 0x3f) == MSGCODE_COMMAND_REJECTED &&\r\ncmd[0] != MSGCODE_SET_CONTROLLED &&\r\ncmd[0] != MSGCODE_SET_AUTO_ENABLED &&\r\ncmd[0] != MSGCODE_GET_BUILDDATE)\r\nreturn -ENOTTY;\r\nif (response &&\r\n((pulse8->data[0] & 0x3f) != response || pulse8->len < size + 1)) {\r\ndev_info(pulse8->dev, "transmit: failed %02x\n",\r\npulse8->data[0] & 0x3f);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pulse8_send_and_wait(struct pulse8 *pulse8,\r\nconst u8 *cmd, u8 cmd_len, u8 response, u8 size)\r\n{\r\nu8 cmd_sc[2];\r\nint err;\r\nmutex_lock(&pulse8->write_lock);\r\nerr = pulse8_send_and_wait_once(pulse8, cmd, cmd_len, response, size);\r\nif (err == -ENOTTY) {\r\ncmd_sc[0] = MSGCODE_SET_CONTROLLED;\r\ncmd_sc[1] = 1;\r\nerr = pulse8_send_and_wait_once(pulse8, cmd_sc, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\nif (err)\r\ngoto unlock;\r\nerr = pulse8_send_and_wait_once(pulse8, cmd, cmd_len,\r\nresponse, size);\r\n}\r\nunlock:\r\nmutex_unlock(&pulse8->write_lock);\r\nreturn err == -ENOTTY ? -EIO : err;\r\n}\r\nstatic int pulse8_setup(struct pulse8 *pulse8, struct serio *serio,\r\nstruct cec_log_addrs *log_addrs, u16 *pa)\r\n{\r\nu8 *data = pulse8->data + 1;\r\nu8 cmd[2];\r\nint err;\r\nstruct tm tm;\r\ntime_t date;\r\npulse8->vers = 0;\r\ncmd[0] = MSGCODE_FIRMWARE_VERSION;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 2);\r\nif (err)\r\nreturn err;\r\npulse8->vers = (data[0] << 8) | data[1];\r\ndev_info(pulse8->dev, "Firmware version %04x\n", pulse8->vers);\r\nif (pulse8->vers < 2) {\r\n*pa = CEC_PHYS_ADDR_INVALID;\r\nreturn 0;\r\n}\r\ncmd[0] = MSGCODE_GET_BUILDDATE;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 4);\r\nif (err)\r\nreturn err;\r\ndate = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];\r\ntime_to_tm(date, 0, &tm);\r\ndev_info(pulse8->dev, "Firmware build date %04ld.%02d.%02d %02d:%02d:%02d\n",\r\ntm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,\r\ntm.tm_hour, tm.tm_min, tm.tm_sec);\r\ndev_dbg(pulse8->dev, "Persistent config:\n");\r\ncmd[0] = MSGCODE_GET_AUTO_ENABLED;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\r\nif (err)\r\nreturn err;\r\npulse8->autonomous = data[0];\r\ndev_dbg(pulse8->dev, "Autonomous mode: %s",\r\ndata[0] ? "on" : "off");\r\ncmd[0] = MSGCODE_GET_DEVICE_TYPE;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\r\nif (err)\r\nreturn err;\r\nlog_addrs->primary_device_type[0] = data[0];\r\ndev_dbg(pulse8->dev, "Primary device type: %d\n", data[0]);\r\nswitch (log_addrs->primary_device_type[0]) {\r\ncase CEC_OP_PRIM_DEVTYPE_TV:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_TV;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_TV;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_RECORD:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_RECORD;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_RECORD;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_TUNER:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_TUNER;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_TUNER;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_PLAYBACK:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_PLAYBACK;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_PLAYBACK;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_PLAYBACK;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_SWITCH:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_PROCESSOR:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_SPECIFIC;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\r\nbreak;\r\ndefault:\r\nlog_addrs->log_addr_type[0] = CEC_LOG_ADDR_TYPE_UNREGISTERED;\r\nlog_addrs->all_device_types[0] = CEC_OP_ALL_DEVTYPE_SWITCH;\r\ndev_info(pulse8->dev, "Unknown Primary Device Type: %d\n",\r\nlog_addrs->primary_device_type[0]);\r\nbreak;\r\n}\r\ncmd[0] = MSGCODE_GET_LOGICAL_ADDRESS_MASK;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 2);\r\nif (err)\r\nreturn err;\r\nlog_addrs->log_addr_mask = (data[0] << 8) | data[1];\r\ndev_dbg(pulse8->dev, "Logical address ACK mask: %x\n",\r\nlog_addrs->log_addr_mask);\r\nif (log_addrs->log_addr_mask)\r\nlog_addrs->num_log_addrs = 1;\r\ncmd[0] = MSGCODE_GET_PHYSICAL_ADDRESS;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\r\nif (err)\r\nreturn err;\r\n*pa = (data[0] << 8) | data[1];\r\ndev_dbg(pulse8->dev, "Physical address: %x.%x.%x.%x\n",\r\ncec_phys_addr_exp(*pa));\r\ncmd[0] = MSGCODE_GET_HDMI_VERSION;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 1);\r\nif (err)\r\nreturn err;\r\nlog_addrs->cec_version = data[0];\r\ndev_dbg(pulse8->dev, "CEC version: %d\n", log_addrs->cec_version);\r\ncmd[0] = MSGCODE_GET_OSD_NAME;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1, cmd[0], 0);\r\nif (err)\r\nreturn err;\r\nstrncpy(log_addrs->osd_name, data, 13);\r\ndev_dbg(pulse8->dev, "OSD name: %s\n", log_addrs->osd_name);\r\nreturn 0;\r\n}\r\nstatic int pulse8_apply_persistent_config(struct pulse8 *pulse8,\r\nstruct cec_log_addrs *log_addrs,\r\nu16 pa)\r\n{\r\nint err;\r\nerr = cec_s_log_addrs(pulse8->adap, log_addrs, false);\r\nif (err)\r\nreturn err;\r\ncec_s_phys_addr(pulse8->adap, pa, false);\r\nreturn 0;\r\n}\r\nstatic int pulse8_cec_adap_enable(struct cec_adapter *adap, bool enable)\r\n{\r\nstruct pulse8 *pulse8 = adap->priv;\r\nu8 cmd[16];\r\nint err;\r\ncmd[0] = MSGCODE_SET_CONTROLLED;\r\ncmd[1] = enable;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\nreturn enable ? err : 0;\r\n}\r\nstatic int pulse8_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\r\n{\r\nstruct pulse8 *pulse8 = adap->priv;\r\nu16 mask = 0;\r\nu16 pa = adap->phys_addr;\r\nu8 cmd[16];\r\nint err = 0;\r\nmutex_lock(&pulse8->config_lock);\r\nif (log_addr != CEC_LOG_ADDR_INVALID)\r\nmask = 1 << log_addr;\r\ncmd[0] = MSGCODE_SET_ACK_MASK;\r\ncmd[1] = mask >> 8;\r\ncmd[2] = mask & 0xff;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 3,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif ((err && mask != 0) || pulse8->restoring_config)\r\ngoto unlock;\r\ncmd[0] = MSGCODE_SET_AUTO_ENABLED;\r\ncmd[1] = log_addr == CEC_LOG_ADDR_INVALID ? 0 : 1;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\npulse8->autonomous = cmd[1];\r\nif (log_addr == CEC_LOG_ADDR_INVALID)\r\ngoto unlock;\r\ncmd[0] = MSGCODE_SET_DEVICE_TYPE;\r\ncmd[1] = adap->log_addrs.primary_device_type[0];\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\nswitch (adap->log_addrs.primary_device_type[0]) {\r\ncase CEC_OP_PRIM_DEVTYPE_TV:\r\nmask = CEC_LOG_ADDR_MASK_TV;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_RECORD:\r\nmask = CEC_LOG_ADDR_MASK_RECORD;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_TUNER:\r\nmask = CEC_LOG_ADDR_MASK_TUNER;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_PLAYBACK:\r\nmask = CEC_LOG_ADDR_MASK_PLAYBACK;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM:\r\nmask = CEC_LOG_ADDR_MASK_AUDIOSYSTEM;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_SWITCH:\r\nmask = CEC_LOG_ADDR_MASK_UNREGISTERED;\r\nbreak;\r\ncase CEC_OP_PRIM_DEVTYPE_PROCESSOR:\r\nmask = CEC_LOG_ADDR_MASK_SPECIFIC;\r\nbreak;\r\ndefault:\r\nmask = 0;\r\nbreak;\r\n}\r\ncmd[0] = MSGCODE_SET_LOGICAL_ADDRESS_MASK;\r\ncmd[1] = mask >> 8;\r\ncmd[2] = mask & 0xff;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 3,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\ncmd[0] = MSGCODE_SET_DEFAULT_LOGICAL_ADDRESS;\r\ncmd[1] = log_addr;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\ncmd[0] = MSGCODE_SET_PHYSICAL_ADDRESS;\r\ncmd[1] = pa >> 8;\r\ncmd[2] = pa & 0xff;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 3,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\ncmd[0] = MSGCODE_SET_HDMI_VERSION;\r\ncmd[1] = adap->log_addrs.cec_version;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\nif (adap->log_addrs.osd_name[0]) {\r\nsize_t osd_len = strlen(adap->log_addrs.osd_name);\r\nchar *osd_str = cmd + 1;\r\ncmd[0] = MSGCODE_SET_OSD_NAME;\r\nstrncpy(cmd + 1, adap->log_addrs.osd_name, 13);\r\nif (osd_len < 4) {\r\nmemset(osd_str + osd_len, ' ', 4 - osd_len);\r\nosd_len = 4;\r\nosd_str[osd_len] = '\0';\r\nstrcpy(adap->log_addrs.osd_name, osd_str);\r\n}\r\nerr = pulse8_send_and_wait(pulse8, cmd, 1 + osd_len,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (err)\r\ngoto unlock;\r\n}\r\nunlock:\r\nif (pulse8->restoring_config)\r\npulse8->restoring_config = false;\r\nelse\r\npulse8->config_pending = true;\r\nmutex_unlock(&pulse8->config_lock);\r\nreturn err;\r\n}\r\nstatic int pulse8_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\r\nu32 signal_free_time, struct cec_msg *msg)\r\n{\r\nstruct pulse8 *pulse8 = adap->priv;\r\nu8 cmd[2];\r\nunsigned int i;\r\nint err;\r\ncmd[0] = MSGCODE_TRANSMIT_IDLETIME;\r\ncmd[1] = signal_free_time;\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\ncmd[0] = MSGCODE_TRANSMIT_ACK_POLARITY;\r\ncmd[1] = cec_msg_is_broadcast(msg);\r\nif (!err)\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\ncmd[0] = msg->len == 1 ? MSGCODE_TRANSMIT_EOM : MSGCODE_TRANSMIT;\r\ncmd[1] = msg->msg[0];\r\nif (!err)\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\nif (!err && msg->len > 1) {\r\ncmd[0] = msg->len == 2 ? MSGCODE_TRANSMIT_EOM :\r\nMSGCODE_TRANSMIT;\r\ncmd[1] = msg->msg[1];\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\nfor (i = 0; !err && i + 2 < msg->len; i++) {\r\ncmd[0] = (i + 2 == msg->len - 1) ?\r\nMSGCODE_TRANSMIT_EOM : MSGCODE_TRANSMIT;\r\ncmd[1] = msg->msg[i + 2];\r\nerr = pulse8_send_and_wait(pulse8, cmd, 2,\r\nMSGCODE_COMMAND_ACCEPTED, 1);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int pulse8_received(struct cec_adapter *adap, struct cec_msg *msg)\r\n{\r\nreturn -ENOMSG;\r\n}\r\nstatic int pulse8_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nu32 caps = CEC_CAP_TRANSMIT | CEC_CAP_LOG_ADDRS | CEC_CAP_PHYS_ADDR |\r\nCEC_CAP_PASSTHROUGH | CEC_CAP_RC | CEC_CAP_MONITOR_ALL;\r\nstruct pulse8 *pulse8;\r\nint err = -ENOMEM;\r\nstruct cec_log_addrs log_addrs = {};\r\nu16 pa = CEC_PHYS_ADDR_INVALID;\r\npulse8 = kzalloc(sizeof(*pulse8), GFP_KERNEL);\r\nif (!pulse8)\r\nreturn -ENOMEM;\r\npulse8->serio = serio;\r\npulse8->adap = cec_allocate_adapter(&pulse8_cec_adap_ops, pulse8,\r\n"HDMI CEC", caps, 1);\r\nerr = PTR_ERR_OR_ZERO(pulse8->adap);\r\nif (err < 0)\r\ngoto free_device;\r\npulse8->dev = &serio->dev;\r\nserio_set_drvdata(serio, pulse8);\r\nINIT_WORK(&pulse8->work, pulse8_irq_work_handler);\r\nmutex_init(&pulse8->write_lock);\r\nmutex_init(&pulse8->config_lock);\r\npulse8->config_pending = false;\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto delete_adap;\r\nerr = pulse8_setup(pulse8, serio, &log_addrs, &pa);\r\nif (err)\r\ngoto close_serio;\r\nerr = cec_register_adapter(pulse8->adap, &serio->dev);\r\nif (err < 0)\r\ngoto close_serio;\r\npulse8->dev = &pulse8->adap->devnode.dev;\r\nif (persistent_config && pulse8->autonomous) {\r\nerr = pulse8_apply_persistent_config(pulse8, &log_addrs, pa);\r\nif (err)\r\ngoto close_serio;\r\npulse8->restoring_config = true;\r\n}\r\nINIT_DELAYED_WORK(&pulse8->ping_eeprom_work,\r\npulse8_ping_eeprom_work_handler);\r\nschedule_delayed_work(&pulse8->ping_eeprom_work, PING_PERIOD);\r\nreturn 0;\r\nclose_serio:\r\nserio_close(serio);\r\ndelete_adap:\r\ncec_delete_adapter(pulse8->adap);\r\nserio_set_drvdata(serio, NULL);\r\nfree_device:\r\nkfree(pulse8);\r\nreturn err;\r\n}\r\nstatic void pulse8_ping_eeprom_work_handler(struct work_struct *work)\r\n{\r\nstruct pulse8 *pulse8 =\r\ncontainer_of(work, struct pulse8, ping_eeprom_work.work);\r\nu8 cmd;\r\nschedule_delayed_work(&pulse8->ping_eeprom_work, PING_PERIOD);\r\ncmd = MSGCODE_PING;\r\npulse8_send_and_wait(pulse8, &cmd, 1,\r\nMSGCODE_COMMAND_ACCEPTED, 0);\r\nif (pulse8->vers < 2)\r\nreturn;\r\nmutex_lock(&pulse8->config_lock);\r\nif (pulse8->config_pending && persistent_config) {\r\ndev_dbg(pulse8->dev, "writing pending config to EEPROM\n");\r\ncmd = MSGCODE_WRITE_EEPROM;\r\nif (pulse8_send_and_wait(pulse8, &cmd, 1,\r\nMSGCODE_COMMAND_ACCEPTED, 0))\r\ndev_info(pulse8->dev, "failed to write pending config to EEPROM\n");\r\nelse\r\npulse8->config_pending = false;\r\n}\r\nmutex_unlock(&pulse8->config_lock);\r\n}
