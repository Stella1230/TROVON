static void sharpsl_pcmcia_init_reset(struct soc_pcmcia_socket *skt)\r\n{\r\nstruct scoop_pcmcia_dev *scoopdev = &SCOOP_DEV[skt->nr];\r\nreset_scoop(scoopdev->dev);\r\nif (platform_scoop_config->power_ctrl)\r\nplatform_scoop_config->power_ctrl(scoopdev->dev, 0x0000, skt->nr);\r\nelse\r\nwrite_scoop_reg(scoopdev->dev, SCOOP_CPR, 0x0000);\r\nscoopdev->keep_vs = NO_KEEP_VS;\r\nscoopdev->keep_rd = 0;\r\n}\r\nstatic int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\r\n{\r\nif (SCOOP_DEV[skt->nr].cd_irq >= 0) {\r\nskt->stat[SOC_STAT_CD].irq = SCOOP_DEV[skt->nr].cd_irq;\r\nskt->stat[SOC_STAT_CD].name = SCOOP_DEV[skt->nr].cd_irq_str;\r\n}\r\nskt->socket.pci_irq = SCOOP_DEV[skt->nr].irq;\r\nreturn 0;\r\n}\r\nstatic void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,\r\nstruct pcmcia_state *state)\r\n{\r\nunsigned short cpr, csr;\r\nstruct device *scoop = SCOOP_DEV[skt->nr].dev;\r\ncpr = read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR);\r\nwrite_scoop_reg(scoop, SCOOP_IRM, 0x00FF);\r\nwrite_scoop_reg(scoop, SCOOP_ISR, 0x0000);\r\nwrite_scoop_reg(scoop, SCOOP_IRM, 0x0000);\r\ncsr = read_scoop_reg(scoop, SCOOP_CSR);\r\nif (csr & 0x0004) {\r\nwrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\r\nSCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;\r\n}\r\nelse if (!(SCOOP_DEV[skt->nr].keep_vs & NO_KEEP_VS)) {\r\nwrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\r\ncsr |= SCOOP_DEV[skt->nr].keep_vs;\r\n}\r\nelse if (cpr & 0x0003) {\r\nwrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\r\nSCOOP_DEV[skt->nr].keep_vs = (csr & 0x00C0);\r\n}\r\nelse {\r\nif ((machine_is_spitz() || machine_is_borzoi()) && skt->nr == 1) {\r\nwrite_scoop_reg(scoop, SCOOP_CDR, 0x0000);\r\n} else {\r\nwrite_scoop_reg(scoop, SCOOP_CDR, 0x0002);\r\n}\r\n}\r\nstate->detect = (csr & 0x0004) ? 0 : 1;\r\nstate->ready = (csr & 0x0002) ? 1 : 0;\r\nstate->bvd1 = (csr & 0x0010) ? 1 : 0;\r\nstate->bvd2 = (csr & 0x0020) ? 1 : 0;\r\nstate->wrprot = (csr & 0x0008) ? 1 : 0;\r\nstate->vs_3v = (csr & 0x0040) ? 0 : 1;\r\nstate->vs_Xv = (csr & 0x0080) ? 0 : 1;\r\nif ((cpr & 0x0080) && ((cpr & 0x8040) != 0x8040)) {\r\nprintk(KERN_ERR "sharpsl_pcmcia_socket_state(): CPR=%04X, Low voltage!\n", cpr);\r\n}\r\n}\r\nstatic int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,\r\nconst socket_state_t *state)\r\n{\r\nunsigned long flags;\r\nstruct device *scoop = SCOOP_DEV[skt->nr].dev;\r\nunsigned short cpr, ncpr, ccr, nccr, mcr, nmcr, imr, nimr;\r\nswitch (state->Vcc) {\r\ncase 0: break;\r\ncase 33: break;\r\ncase 50: break;\r\ndefault:\r\nprintk(KERN_ERR "sharpsl_pcmcia_configure_socket(): bad Vcc %u\n", state->Vcc);\r\nreturn -1;\r\n}\r\nif ((state->Vpp!=state->Vcc) && (state->Vpp!=0)) {\r\nprintk(KERN_ERR "CF slot cannot support Vpp %u\n", state->Vpp);\r\nreturn -1;\r\n}\r\nlocal_irq_save(flags);\r\nnmcr = (mcr = read_scoop_reg(scoop, SCOOP_MCR)) & ~0x0010;\r\nncpr = (cpr = read_scoop_reg(scoop, SCOOP_CPR)) & ~0x0083;\r\nnccr = (ccr = read_scoop_reg(scoop, SCOOP_CCR)) & ~0x0080;\r\nnimr = (imr = read_scoop_reg(scoop, SCOOP_IMR)) & ~0x003E;\r\nif ((machine_is_spitz() || machine_is_borzoi() || machine_is_akita()) && skt->nr == 0) {\r\nncpr |= (state->Vcc == 33) ? 0x0002 :\r\n(state->Vcc == 50) ? 0x0002 : 0;\r\n} else {\r\nncpr |= (state->Vcc == 33) ? 0x0001 :\r\n(state->Vcc == 50) ? 0x0002 : 0;\r\n}\r\nnmcr |= (state->flags&SS_IOCARD) ? 0x0010 : 0;\r\nncpr |= (state->flags&SS_OUTPUT_ENA) ? 0x0080 : 0;\r\nnccr |= (state->flags&SS_RESET)? 0x0080: 0;\r\nnimr |= ((skt->status&SS_DETECT) ? 0x0004 : 0)|\r\n((skt->status&SS_READY) ? 0x0002 : 0)|\r\n((skt->status&SS_BATDEAD)? 0x0010 : 0)|\r\n((skt->status&SS_BATWARN)? 0x0020 : 0)|\r\n((skt->status&SS_STSCHG) ? 0x0010 : 0)|\r\n((skt->status&SS_WRPROT) ? 0x0008 : 0);\r\nif (!(ncpr & 0x0003)) {\r\nSCOOP_DEV[skt->nr].keep_rd = 0;\r\n} else if (!SCOOP_DEV[skt->nr].keep_rd) {\r\nif (nccr & 0x0080)\r\nSCOOP_DEV[skt->nr].keep_rd = 1;\r\nelse\r\nnccr |= 0x0080;\r\n}\r\nif (mcr != nmcr)\r\nwrite_scoop_reg(scoop, SCOOP_MCR, nmcr);\r\nif (cpr != ncpr) {\r\nif (platform_scoop_config->power_ctrl)\r\nplatform_scoop_config->power_ctrl(scoop, ncpr , skt->nr);\r\nelse\r\nwrite_scoop_reg(scoop, SCOOP_CPR, ncpr);\r\n}\r\nif (ccr != nccr)\r\nwrite_scoop_reg(scoop, SCOOP_CCR, nccr);\r\nif (imr != nimr)\r\nwrite_scoop_reg(scoop, SCOOP_IMR, nimr);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)\r\n{\r\nsharpsl_pcmcia_init_reset(skt);\r\nwrite_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_IMR, 0x00C0);\r\nwrite_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_MCR, 0x0101);\r\nSCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;\r\n}\r\nstatic void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)\r\n{\r\nsharpsl_pcmcia_init_reset(skt);\r\n}\r\nint pcmcia_collie_init(struct device *dev)\r\n{\r\nint ret = -ENODEV;\r\nif (machine_is_collie())\r\nret = sa11xx_drv_pcmcia_probe(dev, &sharpsl_pcmcia_ops, 0, 1);\r\nreturn ret;\r\n}\r\nstatic int __init sharpsl_pcmcia_init(void)\r\n{\r\nint ret;\r\nif (!platform_scoop_config)\r\nreturn -ENODEV;\r\nsharpsl_pcmcia_ops.nr = platform_scoop_config->num_devs;\r\nsharpsl_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);\r\nif (!sharpsl_pcmcia_device)\r\nreturn -ENOMEM;\r\nret = platform_device_add_data(sharpsl_pcmcia_device,\r\n&sharpsl_pcmcia_ops, sizeof(sharpsl_pcmcia_ops));\r\nif (ret == 0) {\r\nsharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;\r\nret = platform_device_add(sharpsl_pcmcia_device);\r\n}\r\nif (ret)\r\nplatform_device_put(sharpsl_pcmcia_device);\r\nreturn ret;\r\n}\r\nstatic void __exit sharpsl_pcmcia_exit(void)\r\n{\r\nplatform_device_unregister(sharpsl_pcmcia_device);\r\n}
