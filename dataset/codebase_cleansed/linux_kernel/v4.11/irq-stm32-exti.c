static void stm32_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_domain *domain = irq_desc_get_handler_data(desc);\r\nstruct irq_chip_generic *gc = domain->gc->gc[0];\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long pending;\r\nint n;\r\nchained_irq_enter(chip, desc);\r\nwhile ((pending = irq_reg_readl(gc, EXTI_PR))) {\r\nfor_each_set_bit(n, &pending, BITS_PER_LONG) {\r\ngeneric_handle_irq(irq_find_mapping(domain, n));\r\nirq_reg_writel(gc, BIT(n), EXTI_PR);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int stm32_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nint pin = data->hwirq;\r\nu32 rtsr, ftsr;\r\nirq_gc_lock(gc);\r\nrtsr = irq_reg_readl(gc, EXTI_RTSR);\r\nftsr = irq_reg_readl(gc, EXTI_FTSR);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nrtsr |= BIT(pin);\r\nftsr &= ~BIT(pin);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nrtsr &= ~BIT(pin);\r\nftsr |= BIT(pin);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nrtsr |= BIT(pin);\r\nftsr |= BIT(pin);\r\nbreak;\r\ndefault:\r\nirq_gc_unlock(gc);\r\nreturn -EINVAL;\r\n}\r\nirq_reg_writel(gc, rtsr, EXTI_RTSR);\r\nirq_reg_writel(gc, ftsr, EXTI_FTSR);\r\nirq_gc_unlock(gc);\r\nreturn 0;\r\n}\r\nstatic int stm32_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(data);\r\nint pin = data->hwirq;\r\nu32 emr;\r\nirq_gc_lock(gc);\r\nemr = irq_reg_readl(gc, EXTI_EMR);\r\nif (on)\r\nemr |= BIT(pin);\r\nelse\r\nemr &= ~BIT(pin);\r\nirq_reg_writel(gc, emr, EXTI_EMR);\r\nirq_gc_unlock(gc);\r\nreturn 0;\r\n}\r\nstatic int stm32_exti_alloc(struct irq_domain *d, unsigned int virq,\r\nunsigned int nr_irqs, void *data)\r\n{\r\nstruct irq_chip_generic *gc = d->gc->gc[0];\r\nstruct irq_fwspec *fwspec = data;\r\nirq_hw_number_t hwirq;\r\nhwirq = fwspec->param[0];\r\nirq_map_generic_chip(d, virq, hwirq);\r\nirq_domain_set_info(d, virq, hwirq, &gc->chip_types->chip, gc,\r\nhandle_simple_irq, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic void stm32_exti_free(struct irq_domain *d, unsigned int virq,\r\nunsigned int nr_irqs)\r\n{\r\nstruct irq_data *data = irq_domain_get_irq_data(d, virq);\r\nirq_domain_reset_irq_data(data);\r\n}\r\nstatic int __init stm32_exti_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nint nr_irqs, nr_exti, ret, i;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_domain *domain;\r\nvoid *base;\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\npr_err("%s: Unable to map registers\n", node->full_name);\r\nreturn -ENOMEM;\r\n}\r\nwritel_relaxed(~0UL, base + EXTI_RTSR);\r\nnr_exti = fls(readl_relaxed(base + EXTI_RTSR));\r\nwritel_relaxed(0, base + EXTI_RTSR);\r\npr_info("%s: %d External IRQs detected\n", node->full_name, nr_exti);\r\ndomain = irq_domain_add_linear(node, nr_exti,\r\n&irq_exti_domain_ops, NULL);\r\nif (!domain) {\r\npr_err("%s: Could not register interrupt domain.\n",\r\nnode->name);\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nret = irq_alloc_domain_generic_chips(domain, nr_exti, 1, "exti",\r\nhandle_edge_irq, clr, 0, 0);\r\nif (ret) {\r\npr_err("%s: Could not allocate generic interrupt chip.\n",\r\nnode->full_name);\r\ngoto out_free_domain;\r\n}\r\ngc = domain->gc->gc[0];\r\ngc->reg_base = base;\r\ngc->chip_types->type = IRQ_TYPE_EDGE_BOTH;\r\ngc->chip_types->chip.name = gc->chip_types[0].chip.name;\r\ngc->chip_types->chip.irq_ack = irq_gc_ack_set_bit;\r\ngc->chip_types->chip.irq_mask = irq_gc_mask_clr_bit;\r\ngc->chip_types->chip.irq_unmask = irq_gc_mask_set_bit;\r\ngc->chip_types->chip.irq_set_type = stm32_irq_set_type;\r\ngc->chip_types->chip.irq_set_wake = stm32_irq_set_wake;\r\ngc->chip_types->regs.ack = EXTI_PR;\r\ngc->chip_types->regs.mask = EXTI_IMR;\r\ngc->chip_types->handler = handle_edge_irq;\r\nnr_irqs = of_irq_count(node);\r\nfor (i = 0; i < nr_irqs; i++) {\r\nunsigned int irq = irq_of_parse_and_map(node, i);\r\nirq_set_handler_data(irq, domain);\r\nirq_set_chained_handler(irq, stm32_irq_handler);\r\n}\r\nreturn 0;\r\nout_free_domain:\r\nirq_domain_remove(domain);\r\nout_unmap:\r\niounmap(base);\r\nreturn ret;\r\n}
