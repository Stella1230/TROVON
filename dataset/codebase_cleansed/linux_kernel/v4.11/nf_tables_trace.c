static int trace_fill_id(struct sk_buff *nlskb, struct sk_buff *skb)\r\n{\r\n__be32 id;\r\nid = (__be32)jhash_2words(hash32_ptr(skb), skb_get_hash(skb),\r\nskb->skb_iif);\r\nreturn nla_put_be32(nlskb, NFTA_TRACE_ID, id);\r\n}\r\nstatic int trace_fill_header(struct sk_buff *nlskb, u16 type,\r\nconst struct sk_buff *skb,\r\nint off, unsigned int len)\r\n{\r\nstruct nlattr *nla;\r\nif (len == 0)\r\nreturn 0;\r\nnla = nla_reserve(nlskb, type, len);\r\nif (!nla || skb_copy_bits(skb, off, nla_data(nla), len))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int nf_trace_fill_ll_header(struct sk_buff *nlskb,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct vlan_ethhdr veth;\r\nint off;\r\nBUILD_BUG_ON(sizeof(veth) > NFT_TRACETYPE_LL_HSIZE);\r\noff = skb_mac_header(skb) - skb->data;\r\nif (off != -ETH_HLEN)\r\nreturn -1;\r\nif (skb_copy_bits(skb, off, &veth, ETH_HLEN))\r\nreturn -1;\r\nveth.h_vlan_proto = skb->vlan_proto;\r\nveth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));\r\nveth.h_vlan_encapsulated_proto = skb->protocol;\r\nreturn nla_put(nlskb, NFTA_TRACE_LL_HEADER, sizeof(veth), &veth);\r\n}\r\nstatic int nf_trace_fill_dev_info(struct sk_buff *nlskb,\r\nconst struct net_device *indev,\r\nconst struct net_device *outdev)\r\n{\r\nif (indev) {\r\nif (nla_put_be32(nlskb, NFTA_TRACE_IIF,\r\nhtonl(indev->ifindex)))\r\nreturn -1;\r\nif (nla_put_be16(nlskb, NFTA_TRACE_IIFTYPE,\r\nhtons(indev->type)))\r\nreturn -1;\r\n}\r\nif (outdev) {\r\nif (nla_put_be32(nlskb, NFTA_TRACE_OIF,\r\nhtonl(outdev->ifindex)))\r\nreturn -1;\r\nif (nla_put_be16(nlskb, NFTA_TRACE_OIFTYPE,\r\nhtons(outdev->type)))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nf_trace_fill_pkt_info(struct sk_buff *nlskb,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct sk_buff *skb = pkt->skb;\r\nint off = skb_network_offset(skb);\r\nunsigned int len, nh_end;\r\nnh_end = pkt->tprot_set ? pkt->xt.thoff : skb->len;\r\nlen = min_t(unsigned int, nh_end - skb_network_offset(skb),\r\nNFT_TRACETYPE_NETWORK_HSIZE);\r\nif (trace_fill_header(nlskb, NFTA_TRACE_NETWORK_HEADER, skb, off, len))\r\nreturn -1;\r\nif (pkt->tprot_set) {\r\nlen = min_t(unsigned int, skb->len - pkt->xt.thoff,\r\nNFT_TRACETYPE_TRANSPORT_HSIZE);\r\nif (trace_fill_header(nlskb, NFTA_TRACE_TRANSPORT_HEADER, skb,\r\npkt->xt.thoff, len))\r\nreturn -1;\r\n}\r\nif (!skb_mac_header_was_set(skb))\r\nreturn 0;\r\nif (skb_vlan_tag_get(skb))\r\nreturn nf_trace_fill_ll_header(nlskb, skb);\r\noff = skb_mac_header(skb) - skb->data;\r\nlen = min_t(unsigned int, -off, NFT_TRACETYPE_LL_HSIZE);\r\nreturn trace_fill_header(nlskb, NFTA_TRACE_LL_HEADER,\r\nskb, off, len);\r\n}\r\nstatic int nf_trace_fill_rule_info(struct sk_buff *nlskb,\r\nconst struct nft_traceinfo *info)\r\n{\r\nif (!info->rule)\r\nreturn 0;\r\nif (info->type == NFT_TRACETYPE_RETURN &&\r\ninfo->verdict->code == NFT_CONTINUE)\r\nreturn 0;\r\nreturn nla_put_be64(nlskb, NFTA_TRACE_RULE_HANDLE,\r\ncpu_to_be64(info->rule->handle),\r\nNFTA_TRACE_PAD);\r\n}\r\nvoid nft_trace_notify(struct nft_traceinfo *info)\r\n{\r\nconst struct nft_pktinfo *pkt = info->pkt;\r\nstruct nfgenmsg *nfmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nunsigned int size;\r\nint event = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_TRACE;\r\nif (!nfnetlink_has_listeners(nft_net(pkt), NFNLGRP_NFTRACE))\r\nreturn;\r\nsize = nlmsg_total_size(sizeof(struct nfgenmsg)) +\r\nnla_total_size(NFT_TABLE_MAXNAMELEN) +\r\nnla_total_size(NFT_CHAIN_MAXNAMELEN) +\r\nnla_total_size_64bit(sizeof(__be64)) +\r\nnla_total_size(sizeof(__be32)) +\r\nnla_total_size(0) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(NFT_CHAIN_MAXNAMELEN) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(NFT_TRACETYPE_LL_HSIZE) +\r\nnla_total_size(NFT_TRACETYPE_NETWORK_HSIZE) +\r\nnla_total_size(NFT_TRACETYPE_TRANSPORT_HSIZE) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(__be16)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(__be16)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32));\r\nskb = nlmsg_new(size, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nnlh = nlmsg_put(skb, 0, 0, event, sizeof(struct nfgenmsg), 0);\r\nif (!nlh)\r\ngoto nla_put_failure;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = info->basechain->type->family;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = 0;\r\nif (nla_put_be32(skb, NFTA_TRACE_NFPROTO, htonl(nft_pf(pkt))))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_TRACE_TYPE, htonl(info->type)))\r\ngoto nla_put_failure;\r\nif (trace_fill_id(skb, pkt->skb))\r\ngoto nla_put_failure;\r\nif (info->chain) {\r\nif (nla_put_string(skb, NFTA_TRACE_CHAIN,\r\ninfo->chain->name))\r\ngoto nla_put_failure;\r\nif (nla_put_string(skb, NFTA_TRACE_TABLE,\r\ninfo->chain->table->name))\r\ngoto nla_put_failure;\r\n}\r\nif (nf_trace_fill_rule_info(skb, info))\r\ngoto nla_put_failure;\r\nswitch (info->type) {\r\ncase NFT_TRACETYPE_UNSPEC:\r\ncase __NFT_TRACETYPE_MAX:\r\nbreak;\r\ncase NFT_TRACETYPE_RETURN:\r\ncase NFT_TRACETYPE_RULE:\r\nif (nft_verdict_dump(skb, NFTA_TRACE_VERDICT, info->verdict))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase NFT_TRACETYPE_POLICY:\r\nif (nla_put_be32(skb, NFTA_TRACE_POLICY,\r\nhtonl(info->basechain->policy)))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nif (pkt->skb->mark &&\r\nnla_put_be32(skb, NFTA_TRACE_MARK, htonl(pkt->skb->mark)))\r\ngoto nla_put_failure;\r\nif (!info->packet_dumped) {\r\nif (nf_trace_fill_dev_info(skb, nft_in(pkt), nft_out(pkt)))\r\ngoto nla_put_failure;\r\nif (nf_trace_fill_pkt_info(skb, pkt))\r\ngoto nla_put_failure;\r\ninfo->packet_dumped = true;\r\n}\r\nnlmsg_end(skb, nlh);\r\nnfnetlink_send(skb, nft_net(pkt), 0, NFNLGRP_NFTRACE, 0, GFP_ATOMIC);\r\nreturn;\r\nnla_put_failure:\r\nWARN_ON_ONCE(1);\r\nkfree_skb(skb);\r\n}\r\nvoid nft_trace_init(struct nft_traceinfo *info, const struct nft_pktinfo *pkt,\r\nconst struct nft_verdict *verdict,\r\nconst struct nft_chain *chain)\r\n{\r\ninfo->basechain = nft_base_chain(chain);\r\ninfo->trace = true;\r\ninfo->packet_dumped = false;\r\ninfo->pkt = pkt;\r\ninfo->verdict = verdict;\r\n}
