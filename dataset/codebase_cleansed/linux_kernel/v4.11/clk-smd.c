static unsigned long at91sam9x5_clk_smd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nunsigned int smdr;\r\nu8 smddiv;\r\nregmap_read(smd->regmap, AT91_PMC_SMD, &smdr);\r\nsmddiv = (smdr & AT91_PMC_SMD_DIV) >> SMD_DIV_SHIFT;\r\nreturn parent_rate / (smddiv + 1);\r\n}\r\nstatic long at91sam9x5_clk_smd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long div;\r\nunsigned long bestrate;\r\nunsigned long tmp;\r\nif (rate >= *parent_rate)\r\nreturn *parent_rate;\r\ndiv = *parent_rate / rate;\r\nif (div > SMD_MAX_DIV)\r\nreturn *parent_rate / (SMD_MAX_DIV + 1);\r\nbestrate = *parent_rate / div;\r\ntmp = *parent_rate / (div + 1);\r\nif (bestrate - rate > rate - tmp)\r\nbestrate = tmp;\r\nreturn bestrate;\r\n}\r\nstatic int at91sam9x5_clk_smd_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nif (index > 1)\r\nreturn -EINVAL;\r\nregmap_update_bits(smd->regmap, AT91_PMC_SMD, AT91_PMC_SMDS,\r\nindex ? AT91_PMC_SMDS : 0);\r\nreturn 0;\r\n}\r\nstatic u8 at91sam9x5_clk_smd_get_parent(struct clk_hw *hw)\r\n{\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nunsigned int smdr;\r\nregmap_read(smd->regmap, AT91_PMC_SMD, &smdr);\r\nreturn smdr & AT91_PMC_SMDS;\r\n}\r\nstatic int at91sam9x5_clk_smd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct at91sam9x5_clk_smd *smd = to_at91sam9x5_clk_smd(hw);\r\nunsigned long div = parent_rate / rate;\r\nif (parent_rate % rate || div < 1 || div > (SMD_MAX_DIV + 1))\r\nreturn -EINVAL;\r\nregmap_update_bits(smd->regmap, AT91_PMC_SMD, AT91_PMC_SMD_DIV,\r\n(div - 1) << SMD_DIV_SHIFT);\r\nreturn 0;\r\n}\r\nstatic struct clk_hw * __init\r\nat91sam9x5_clk_register_smd(struct regmap *regmap, const char *name,\r\nconst char **parent_names, u8 num_parents)\r\n{\r\nstruct at91sam9x5_clk_smd *smd;\r\nstruct clk_hw *hw;\r\nstruct clk_init_data init;\r\nint ret;\r\nsmd = kzalloc(sizeof(*smd), GFP_KERNEL);\r\nif (!smd)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &at91sam9x5_smd_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nsmd->hw.init = &init;\r\nsmd->regmap = regmap;\r\nhw = &smd->hw;\r\nret = clk_hw_register(NULL, &smd->hw);\r\nif (ret) {\r\nkfree(smd);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstatic void __init of_at91sam9x5_clk_smd_setup(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nunsigned int num_parents;\r\nconst char *parent_names[SMD_SOURCE_MAX];\r\nconst char *name = np->name;\r\nstruct regmap *regmap;\r\nnum_parents = of_clk_get_parent_count(np);\r\nif (num_parents == 0 || num_parents > SMD_SOURCE_MAX)\r\nreturn;\r\nof_clk_parent_fill(np, parent_names, num_parents);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nregmap = syscon_node_to_regmap(of_get_parent(np));\r\nif (IS_ERR(regmap))\r\nreturn;\r\nhw = at91sam9x5_clk_register_smd(regmap, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(hw))\r\nreturn;\r\nof_clk_add_hw_provider(np, of_clk_hw_simple_get, hw);\r\n}
