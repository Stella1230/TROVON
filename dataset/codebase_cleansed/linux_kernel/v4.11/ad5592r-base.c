static int ad5592r_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ad5592r_state *st = gpiochip_get_data(chip);\r\nint ret = 0;\r\nu8 val;\r\nmutex_lock(&st->gpio_lock);\r\nif (st->gpio_out & BIT(offset))\r\nval = st->gpio_val;\r\nelse\r\nret = st->ops->gpio_read(st, &val);\r\nmutex_unlock(&st->gpio_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn !!(val & BIT(offset));\r\n}\r\nstatic void ad5592r_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct ad5592r_state *st = gpiochip_get_data(chip);\r\nmutex_lock(&st->gpio_lock);\r\nif (value)\r\nst->gpio_val |= BIT(offset);\r\nelse\r\nst->gpio_val &= ~BIT(offset);\r\nst->ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\r\nmutex_unlock(&st->gpio_lock);\r\n}\r\nstatic int ad5592r_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ad5592r_state *st = gpiochip_get_data(chip);\r\nint ret;\r\nmutex_lock(&st->gpio_lock);\r\nst->gpio_out &= ~BIT(offset);\r\nst->gpio_in |= BIT(offset);\r\nret = st->ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = st->ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\r\nerr_unlock:\r\nmutex_unlock(&st->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int ad5592r_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct ad5592r_state *st = gpiochip_get_data(chip);\r\nint ret;\r\nmutex_lock(&st->gpio_lock);\r\nif (value)\r\nst->gpio_val |= BIT(offset);\r\nelse\r\nst->gpio_val &= ~BIT(offset);\r\nst->gpio_in &= ~BIT(offset);\r\nst->gpio_out |= BIT(offset);\r\nret = st->ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = st->ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = st->ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\r\nerr_unlock:\r\nmutex_unlock(&st->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int ad5592r_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ad5592r_state *st = gpiochip_get_data(chip);\r\nif (!(st->gpio_map & BIT(offset))) {\r\ndev_err(st->dev, "GPIO %d is reserved by alternate function\n",\r\noffset);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5592r_gpio_init(struct ad5592r_state *st)\r\n{\r\nif (!st->gpio_map)\r\nreturn 0;\r\nst->gpiochip.label = dev_name(st->dev);\r\nst->gpiochip.base = -1;\r\nst->gpiochip.ngpio = 8;\r\nst->gpiochip.parent = st->dev;\r\nst->gpiochip.can_sleep = true;\r\nst->gpiochip.direction_input = ad5592r_gpio_direction_input;\r\nst->gpiochip.direction_output = ad5592r_gpio_direction_output;\r\nst->gpiochip.get = ad5592r_gpio_get;\r\nst->gpiochip.set = ad5592r_gpio_set;\r\nst->gpiochip.request = ad5592r_gpio_request;\r\nst->gpiochip.owner = THIS_MODULE;\r\nmutex_init(&st->gpio_lock);\r\nreturn gpiochip_add_data(&st->gpiochip, st);\r\n}\r\nstatic void ad5592r_gpio_cleanup(struct ad5592r_state *st)\r\n{\r\nif (st->gpio_map)\r\ngpiochip_remove(&st->gpiochip);\r\n}\r\nstatic int ad5592r_reset(struct ad5592r_state *st)\r\n{\r\nstruct gpio_desc *gpio;\r\nstruct iio_dev *iio_dev = iio_priv_to_dev(st);\r\ngpio = devm_gpiod_get_optional(st->dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(gpio))\r\nreturn PTR_ERR(gpio);\r\nif (gpio) {\r\nudelay(1);\r\ngpiod_set_value(gpio, 1);\r\n} else {\r\nmutex_lock(&iio_dev->mlock);\r\nst->ops->reg_write(st, AD5592R_REG_RESET, 0xdac);\r\nmutex_unlock(&iio_dev->mlock);\r\n}\r\nudelay(250);\r\nreturn 0;\r\n}\r\nstatic int ad5592r_get_vref(struct ad5592r_state *st)\r\n{\r\nint ret;\r\nif (st->reg) {\r\nret = regulator_get_voltage(st->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret / 1000;\r\n} else {\r\nreturn 2500;\r\n}\r\n}\r\nstatic int ad5592r_set_channel_modes(struct ad5592r_state *st)\r\n{\r\nconst struct ad5592r_rw_ops *ops = st->ops;\r\nint ret;\r\nunsigned i;\r\nstruct iio_dev *iio_dev = iio_priv_to_dev(st);\r\nu8 pulldown = 0, tristate = 0, dac = 0, adc = 0;\r\nu16 read_back;\r\nfor (i = 0; i < st->num_channels; i++) {\r\nswitch (st->channel_modes[i]) {\r\ncase CH_MODE_DAC:\r\ndac |= BIT(i);\r\nbreak;\r\ncase CH_MODE_ADC:\r\nadc |= BIT(i);\r\nbreak;\r\ncase CH_MODE_DAC_AND_ADC:\r\ndac |= BIT(i);\r\nadc |= BIT(i);\r\nbreak;\r\ncase CH_MODE_GPIO:\r\nst->gpio_map |= BIT(i);\r\nst->gpio_in |= BIT(i);\r\nbreak;\r\ncase CH_MODE_UNUSED:\r\ndefault:\r\nswitch (st->channel_offstate[i]) {\r\ncase CH_OFFSTATE_OUT_TRISTATE:\r\ntristate |= BIT(i);\r\nbreak;\r\ncase CH_OFFSTATE_OUT_LOW:\r\nst->gpio_out |= BIT(i);\r\nbreak;\r\ncase CH_OFFSTATE_OUT_HIGH:\r\nst->gpio_out |= BIT(i);\r\nst->gpio_val |= BIT(i);\r\nbreak;\r\ncase CH_OFFSTATE_PULLDOWN:\r\ndefault:\r\npulldown |= BIT(i);\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_lock(&iio_dev->mlock);\r\nret = ops->reg_write(st, AD5592R_REG_PULLDOWN, pulldown);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_TRISTATE, tristate);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_DAC_EN, dac);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_ADC_EN, adc);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_GPIO_SET, st->gpio_val);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_GPIO_OUT_EN, st->gpio_out);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_write(st, AD5592R_REG_GPIO_IN_EN, st->gpio_in);\r\nif (ret)\r\ngoto err_unlock;\r\nret = ops->reg_read(st, AD5592R_REG_ADC_EN, &read_back);\r\nif (!ret && (read_back & 0xff) != adc)\r\nret = -EIO;\r\nerr_unlock:\r\nmutex_unlock(&iio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5592r_reset_channel_modes(struct ad5592r_state *st)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(st->channel_modes); i++)\r\nst->channel_modes[i] = CH_MODE_UNUSED;\r\nreturn ad5592r_set_channel_modes(st);\r\n}\r\nstatic int ad5592r_write_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nstruct ad5592r_state *st = iio_priv(iio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val >= (1 << chan->scan_type.realbits) || val < 0)\r\nreturn -EINVAL;\r\nif (!chan->output)\r\nreturn -EINVAL;\r\nmutex_lock(&iio_dev->mlock);\r\nret = st->ops->write_dac(st, chan->channel, val);\r\nif (!ret)\r\nst->cached_dac[chan->channel] = val;\r\nmutex_unlock(&iio_dev->mlock);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_VOLTAGE) {\r\nbool gain;\r\nif (val == st->scale_avail[0][0] &&\r\nval2 == st->scale_avail[0][1])\r\ngain = false;\r\nelse if (val == st->scale_avail[1][0] &&\r\nval2 == st->scale_avail[1][1])\r\ngain = true;\r\nelse\r\nreturn -EINVAL;\r\nmutex_lock(&iio_dev->mlock);\r\nret = st->ops->reg_read(st, AD5592R_REG_CTRL,\r\n&st->cached_gp_ctrl);\r\nif (ret < 0) {\r\nmutex_unlock(&iio_dev->mlock);\r\nreturn ret;\r\n}\r\nif (chan->output) {\r\nif (gain)\r\nst->cached_gp_ctrl |=\r\nAD5592R_REG_CTRL_DAC_RANGE;\r\nelse\r\nst->cached_gp_ctrl &=\r\n~AD5592R_REG_CTRL_DAC_RANGE;\r\n} else {\r\nif (gain)\r\nst->cached_gp_ctrl |=\r\nAD5592R_REG_CTRL_ADC_RANGE;\r\nelse\r\nst->cached_gp_ctrl &=\r\n~AD5592R_REG_CTRL_ADC_RANGE;\r\n}\r\nret = st->ops->reg_write(st, AD5592R_REG_CTRL,\r\nst->cached_gp_ctrl);\r\nmutex_unlock(&iio_dev->mlock);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad5592r_read_raw(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long m)\r\n{\r\nstruct ad5592r_state *st = iio_priv(iio_dev);\r\nu16 read_val;\r\nint ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&iio_dev->mlock);\r\nif (!chan->output) {\r\nret = st->ops->read_adc(st, chan->channel, &read_val);\r\nif (ret)\r\ngoto unlock;\r\nif ((read_val >> 12 & 0x7) != (chan->channel & 0x7)) {\r\ndev_err(st->dev, "Error while reading channel %u\n",\r\nchan->channel);\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nread_val &= GENMASK(11, 0);\r\n} else {\r\nread_val = st->cached_dac[chan->channel];\r\n}\r\ndev_dbg(st->dev, "Channel %u read: 0x%04hX\n",\r\nchan->channel, read_val);\r\n*val = (int) read_val;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = ad5592r_get_vref(st);\r\nif (chan->type == IIO_TEMP) {\r\ns64 tmp = *val * (3767897513LL / 25LL);\r\n*val = div_s64_rem(tmp, 1000000000LL, val2);\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n} else {\r\nint mult;\r\nmutex_lock(&iio_dev->mlock);\r\nif (chan->output)\r\nmult = !!(st->cached_gp_ctrl &\r\nAD5592R_REG_CTRL_DAC_RANGE);\r\nelse\r\nmult = !!(st->cached_gp_ctrl &\r\nAD5592R_REG_CTRL_ADC_RANGE);\r\n*val *= ++mult;\r\n*val2 = chan->scan_type.realbits;\r\nret = IIO_VAL_FRACTIONAL_LOG2;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nret = ad5592r_get_vref(st);\r\nmutex_lock(&iio_dev->mlock);\r\nif (st->cached_gp_ctrl & AD5592R_REG_CTRL_ADC_RANGE)\r\n*val = (-34365 * 25) / ret;\r\nelse\r\n*val = (-75365 * 25) / ret;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nunlock:\r\nmutex_unlock(&iio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5592r_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, long mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ndefault:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad5592r_show_scale_available(struct iio_dev *iio_dev,\r\nuintptr_t private,\r\nconst struct iio_chan_spec *chan,\r\nchar *buf)\r\n{\r\nstruct ad5592r_state *st = iio_priv(iio_dev);\r\nreturn sprintf(buf, "%d.%09u %d.%09u\n",\r\nst->scale_avail[0][0], st->scale_avail[0][1],\r\nst->scale_avail[1][0], st->scale_avail[1][1]);\r\n}\r\nstatic void ad5592r_setup_channel(struct iio_dev *iio_dev,\r\nstruct iio_chan_spec *chan, bool output, unsigned id)\r\n{\r\nchan->type = IIO_VOLTAGE;\r\nchan->indexed = 1;\r\nchan->output = output;\r\nchan->channel = id;\r\nchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\r\nchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\r\nchan->scan_type.sign = 'u';\r\nchan->scan_type.realbits = 12;\r\nchan->scan_type.storagebits = 16;\r\nchan->ext_info = ad5592r_ext_info;\r\n}\r\nstatic int ad5592r_alloc_channels(struct ad5592r_state *st)\r\n{\r\nunsigned i, curr_channel = 0,\r\nnum_channels = st->num_channels;\r\nstruct iio_dev *iio_dev = iio_priv_to_dev(st);\r\nstruct iio_chan_spec *channels;\r\nstruct fwnode_handle *child;\r\nu32 reg, tmp;\r\nint ret;\r\ndevice_for_each_child_node(st->dev, child) {\r\nret = fwnode_property_read_u32(child, "reg", &reg);\r\nif (ret || reg >= ARRAY_SIZE(st->channel_modes))\r\ncontinue;\r\nret = fwnode_property_read_u32(child, "adi,mode", &tmp);\r\nif (!ret)\r\nst->channel_modes[reg] = tmp;\r\nfwnode_property_read_u32(child, "adi,off-state", &tmp);\r\nif (!ret)\r\nst->channel_offstate[reg] = tmp;\r\n}\r\nchannels = devm_kzalloc(st->dev,\r\n(1 + 2 * num_channels) * sizeof(*channels), GFP_KERNEL);\r\nif (!channels)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_channels; i++) {\r\nswitch (st->channel_modes[i]) {\r\ncase CH_MODE_DAC:\r\nad5592r_setup_channel(iio_dev, &channels[curr_channel],\r\ntrue, i);\r\ncurr_channel++;\r\nbreak;\r\ncase CH_MODE_ADC:\r\nad5592r_setup_channel(iio_dev, &channels[curr_channel],\r\nfalse, i);\r\ncurr_channel++;\r\nbreak;\r\ncase CH_MODE_DAC_AND_ADC:\r\nad5592r_setup_channel(iio_dev, &channels[curr_channel],\r\ntrue, i);\r\ncurr_channel++;\r\nad5592r_setup_channel(iio_dev, &channels[curr_channel],\r\nfalse, i);\r\ncurr_channel++;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nchannels[curr_channel].type = IIO_TEMP;\r\nchannels[curr_channel].channel = 8;\r\nchannels[curr_channel].info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\r\nBIT(IIO_CHAN_INFO_SCALE) |\r\nBIT(IIO_CHAN_INFO_OFFSET);\r\ncurr_channel++;\r\niio_dev->num_channels = curr_channel;\r\niio_dev->channels = channels;\r\nreturn 0;\r\n}\r\nstatic void ad5592r_init_scales(struct ad5592r_state *st, int vref_mV)\r\n{\r\ns64 tmp = (s64)vref_mV * 1000000000LL >> 12;\r\nst->scale_avail[0][0] =\r\ndiv_s64_rem(tmp, 1000000000LL, &st->scale_avail[0][1]);\r\nst->scale_avail[1][0] =\r\ndiv_s64_rem(tmp * 2, 1000000000LL, &st->scale_avail[1][1]);\r\n}\r\nint ad5592r_probe(struct device *dev, const char *name,\r\nconst struct ad5592r_rw_ops *ops)\r\n{\r\nstruct iio_dev *iio_dev;\r\nstruct ad5592r_state *st;\r\nint ret;\r\niio_dev = devm_iio_device_alloc(dev, sizeof(*st));\r\nif (!iio_dev)\r\nreturn -ENOMEM;\r\nst = iio_priv(iio_dev);\r\nst->dev = dev;\r\nst->ops = ops;\r\nst->num_channels = 8;\r\ndev_set_drvdata(dev, iio_dev);\r\nst->reg = devm_regulator_get_optional(dev, "vref");\r\nif (IS_ERR(st->reg)) {\r\nif ((PTR_ERR(st->reg) != -ENODEV) && dev->of_node)\r\nreturn PTR_ERR(st->reg);\r\nst->reg = NULL;\r\n} else {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ret;\r\n}\r\niio_dev->dev.parent = dev;\r\niio_dev->name = name;\r\niio_dev->info = &ad5592r_info;\r\niio_dev->modes = INDIO_DIRECT_MODE;\r\nad5592r_init_scales(st, ad5592r_get_vref(st));\r\nret = ad5592r_reset(st);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ops->reg_write(st, AD5592R_REG_PD,\r\n(st->reg == NULL) ? AD5592R_REG_PD_EN_REF : 0);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad5592r_alloc_channels(st);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad5592r_set_channel_modes(st);\r\nif (ret)\r\ngoto error_reset_ch_modes;\r\nret = iio_device_register(iio_dev);\r\nif (ret)\r\ngoto error_reset_ch_modes;\r\nret = ad5592r_gpio_init(st);\r\nif (ret)\r\ngoto error_dev_unregister;\r\nreturn 0;\r\nerror_dev_unregister:\r\niio_device_unregister(iio_dev);\r\nerror_reset_ch_modes:\r\nad5592r_reset_channel_modes(st);\r\nerror_disable_reg:\r\nif (st->reg)\r\nregulator_disable(st->reg);\r\nreturn ret;\r\n}\r\nint ad5592r_remove(struct device *dev)\r\n{\r\nstruct iio_dev *iio_dev = dev_get_drvdata(dev);\r\nstruct ad5592r_state *st = iio_priv(iio_dev);\r\niio_device_unregister(iio_dev);\r\nad5592r_reset_channel_modes(st);\r\nad5592r_gpio_cleanup(st);\r\nif (st->reg)\r\nregulator_disable(st->reg);\r\nreturn 0;\r\n}
