static int m88ds3103_update_bits(struct m88ds3103_dev *dev,\r\nu8 reg, u8 mask, u8 val)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = regmap_bulk_read(dev->regmap, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn regmap_bulk_write(dev->regmap, reg, &val, 1);\r\n}\r\nstatic int m88ds3103_wr_reg_val_tab(struct m88ds3103_dev *dev,\r\nconst struct m88ds3103_reg_val *tab, int tab_len)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nint ret, i, j;\r\nu8 buf[83];\r\ndev_dbg(&client->dev, "tab_len=%d\n", tab_len);\r\nif (tab_len > 86) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (i = 0, j = 0; i < tab_len; i++, j++) {\r\nbuf[j] = tab[i].val;\r\nif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1 ||\r\n!((j + 1) % (dev->cfg->i2c_wr_max - 1))) {\r\nret = regmap_bulk_write(dev->regmap, tab[i].reg - j, buf, j + 1);\r\nif (ret)\r\ngoto err;\r\nj = -1;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nint m88ds3103_get_agc_pwm(struct dvb_frontend *fe, u8 *_agc_pwm)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nunsigned tmp;\r\nint ret;\r\nret = regmap_read(dev->regmap, 0x3f, &tmp);\r\nif (ret == 0)\r\n*_agc_pwm = tmp;\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, itmp;\r\nunsigned int utmp;\r\nu8 buf[3];\r\n*status = 0;\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = regmap_read(dev->regmap, 0xd1, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x07) == 0x07)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = regmap_read(dev->regmap, 0x0d, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x8f) == 0x8f)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev->fe_status = *status;\r\ndev_dbg(&client->dev, "lock=%02x status=%02x\n", utmp, *status);\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nunsigned int cnr, noise, signal, noise_tot, signal_tot;\r\ncnr = 0;\r\n#define M88DS3103_SNR_ITERATIONS 3\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nitmp = 0;\r\nfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\r\nret = regmap_read(dev->regmap, 0xff, &utmp);\r\nif (ret)\r\ngoto err;\r\nitmp += utmp;\r\n}\r\nitmp = DIV_ROUND_CLOSEST(itmp, 8 * M88DS3103_SNR_ITERATIONS);\r\nif (itmp)\r\ncnr = div_u64((u64) 10000 * intlog2(itmp), intlog2(10));\r\nbreak;\r\ncase SYS_DVBS2:\r\nnoise_tot = 0;\r\nsignal_tot = 0;\r\nfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\r\nret = regmap_bulk_read(dev->regmap, 0x8c, buf, 3);\r\nif (ret)\r\ngoto err;\r\nnoise = buf[1] << 6;\r\nnoise |= buf[0] & 0x3f;\r\nnoise >>= 2;\r\nsignal = buf[2] * buf[2];\r\nsignal >>= 1;\r\nnoise_tot += noise;\r\nsignal_tot += signal;\r\n}\r\nnoise = noise_tot / M88DS3103_SNR_ITERATIONS;\r\nsignal = signal_tot / M88DS3103_SNR_ITERATIONS;\r\nif (signal > noise) {\r\nitmp = signal / noise;\r\ncnr = div_u64((u64) 10000 * intlog10(itmp), (1 << 24));\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (cnr) {\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = cnr;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nunsigned int utmp, post_bit_error, post_bit_count;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = regmap_write(dev->regmap, 0xf9, 0x04);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0xf8, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!(utmp & 0x10)) {\r\nret = regmap_bulk_read(dev->regmap, 0xf6, buf, 2);\r\nif (ret)\r\ngoto err;\r\npost_bit_error = buf[1] << 8 | buf[0] << 0;\r\npost_bit_count = 0x800000;\r\ndev->post_bit_error += post_bit_error;\r\ndev->post_bit_count += post_bit_count;\r\ndev->dvbv3_ber = post_bit_error;\r\nutmp |= 0x10;\r\nret = regmap_write(dev->regmap, 0xf8, utmp);\r\nif (ret)\r\ngoto err;\r\n}\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = regmap_bulk_read(dev->regmap, 0xd5, buf, 3);\r\nif (ret)\r\ngoto err;\r\nutmp = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;\r\nif (utmp > 4000) {\r\nret = regmap_bulk_read(dev->regmap, 0xf7, buf, 2);\r\nif (ret)\r\ngoto err;\r\npost_bit_error = buf[1] << 8 | buf[0] << 0;\r\npost_bit_count = 32 * utmp;\r\ndev->post_bit_error += post_bit_error;\r\ndev->post_bit_count += post_bit_count;\r\ndev->dvbv3_ber = post_bit_error;\r\nret = regmap_write(dev->regmap, 0xd1, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xf9, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xf9, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xd1, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\r\n} else {\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, len;\r\nconst struct m88ds3103_reg_val *init;\r\nu8 u8tmp, u8tmp1 = 0, u8tmp2 = 0;\r\nu8 buf[3];\r\nu16 u16tmp;\r\nu32 tuner_frequency_khz, target_mclk;\r\ns32 s32tmp;\r\ndev_dbg(&client->dev,\r\n"delivery_system=%d modulation=%d frequency=%u symbol_rate=%d inversion=%d pilot=%d rolloff=%d\n",\r\nc->delivery_system, c->modulation, c->frequency, c->symbol_rate,\r\nc->inversion, c->pilot, c->rolloff);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x07, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x07, 0x00);\r\nif (ret)\r\ngoto err;\r\nif (dev->chip_id == M88RS6000_CHIP_ID) {\r\nret = regmap_write(dev->regmap, 0x06, 0xe0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.get_frequency) {\r\nret = fe->ops.tuner_ops.get_frequency(fe, &tuner_frequency_khz);\r\nif (ret)\r\ngoto err;\r\n} else {\r\ntuner_frequency_khz = c->frequency;\r\n}\r\nif (dev->chip_id == M88RS6000_CHIP_ID) {\r\nif (c->symbol_rate > 45010000)\r\ndev->mclk = 110250000;\r\nelse\r\ndev->mclk = 96000000;\r\nif (c->delivery_system == SYS_DVBS)\r\ntarget_mclk = 96000000;\r\nelse\r\ntarget_mclk = 144000000;\r\nret = regmap_write(dev->regmap, 0x06, 0x00);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\n} else {\r\ndev->mclk = 96000000;\r\nswitch (dev->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\ncase M88DS3103_TS_SERIAL_D7:\r\ntarget_mclk = dev->cfg->ts_clk;\r\nbreak;\r\ncase M88DS3103_TS_PARALLEL:\r\ncase M88DS3103_TS_CI:\r\nif (c->delivery_system == SYS_DVBS)\r\ntarget_mclk = 96000000;\r\nelse {\r\nif (c->symbol_rate < 18000000)\r\ntarget_mclk = 96000000;\r\nelse if (c->symbol_rate < 28000000)\r\ntarget_mclk = 144000000;\r\nelse\r\ntarget_mclk = 192000000;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid ts_mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (target_mclk) {\r\ncase 96000000:\r\nu8tmp1 = 0x02;\r\nu8tmp2 = 0x01;\r\nbreak;\r\ncase 144000000:\r\nu8tmp1 = 0x00;\r\nu8tmp2 = 0x01;\r\nbreak;\r\ncase 192000000:\r\nu8tmp1 = 0x03;\r\nu8tmp2 = 0x00;\r\nbreak;\r\n}\r\nret = m88ds3103_update_bits(dev, 0x22, 0xc0, u8tmp1 << 6);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x24, 0xc0, u8tmp2 << 6);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0xb2, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nif (dev->chip_id == M88RS6000_CHIP_ID) {\r\nlen = ARRAY_SIZE(m88rs6000_dvbs_init_reg_vals);\r\ninit = m88rs6000_dvbs_init_reg_vals;\r\n} else {\r\nlen = ARRAY_SIZE(m88ds3103_dvbs_init_reg_vals);\r\ninit = m88ds3103_dvbs_init_reg_vals;\r\n}\r\nbreak;\r\ncase SYS_DVBS2:\r\nif (dev->chip_id == M88RS6000_CHIP_ID) {\r\nlen = ARRAY_SIZE(m88rs6000_dvbs2_init_reg_vals);\r\ninit = m88rs6000_dvbs2_init_reg_vals;\r\n} else {\r\nlen = ARRAY_SIZE(m88ds3103_dvbs2_init_reg_vals);\r\ninit = m88ds3103_dvbs2_init_reg_vals;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (c->delivery_system != dev->delivery_system) {\r\nret = m88ds3103_wr_reg_val_tab(dev, init, len);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (dev->chip_id == M88RS6000_CHIP_ID) {\r\nif (c->delivery_system == SYS_DVBS2 &&\r\nc->symbol_rate <= 5000000) {\r\nret = regmap_write(dev->regmap, 0xc0, 0x04);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = 0x09;\r\nbuf[1] = 0x22;\r\nbuf[2] = 0x88;\r\nret = regmap_bulk_write(dev->regmap, 0x8a, buf, 3);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_update_bits(dev, 0x9d, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xf1, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x30, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\n}\r\nswitch (dev->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\nu8tmp1 = 0x00;\r\nu8tmp = 0x06;\r\nbreak;\r\ncase M88DS3103_TS_SERIAL_D7:\r\nu8tmp1 = 0x20;\r\nu8tmp = 0x06;\r\nbreak;\r\ncase M88DS3103_TS_PARALLEL:\r\nu8tmp = 0x02;\r\nbreak;\r\ncase M88DS3103_TS_CI:\r\nu8tmp = 0x03;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid ts_mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (dev->cfg->ts_clk_pol)\r\nu8tmp |= 0x40;\r\nret = regmap_write(dev->regmap, 0xfd, u8tmp);\r\nif (ret)\r\ngoto err;\r\nswitch (dev->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\ncase M88DS3103_TS_SERIAL_D7:\r\nret = m88ds3103_update_bits(dev, 0x29, 0x20, u8tmp1);\r\nif (ret)\r\ngoto err;\r\nu16tmp = 0;\r\nu8tmp1 = 0x3f;\r\nu8tmp2 = 0x3f;\r\nbreak;\r\ndefault:\r\nu16tmp = DIV_ROUND_UP(target_mclk, dev->cfg->ts_clk);\r\nu8tmp1 = u16tmp / 2 - 1;\r\nu8tmp2 = DIV_ROUND_UP(u16tmp, 2) - 1;\r\n}\r\ndev_dbg(&client->dev, "target_mclk=%u ts_clk=%u ts_clk_divide_ratio=%u\n",\r\ntarget_mclk, dev->cfg->ts_clk, u16tmp);\r\nu8tmp = (u8tmp1 >> 2) & 0x0f;\r\nret = regmap_update_bits(dev->regmap, 0xfe, 0x0f, u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp = ((u8tmp1 & 0x03) << 6) | u8tmp2 >> 0;\r\nret = regmap_write(dev->regmap, 0xea, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (c->symbol_rate <= 3000000)\r\nu8tmp = 0x20;\r\nelse if (c->symbol_rate <= 10000000)\r\nu8tmp = 0x10;\r\nelse\r\nu8tmp = 0x06;\r\nret = regmap_write(dev->regmap, 0xc3, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xc8, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xc4, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xc7, 0x00);\r\nif (ret)\r\ngoto err;\r\nu16tmp = DIV_ROUND_CLOSEST_ULL((u64)c->symbol_rate * 0x10000, dev->mclk);\r\nbuf[0] = (u16tmp >> 0) & 0xff;\r\nbuf[1] = (u16tmp >> 8) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, 0x61, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x4d, 0x02, dev->cfg->spec_inv << 1);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x30, 0x10, dev->cfg->agc_inv << 4);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x33, dev->cfg->agc);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "carrier offset=%d\n",\r\n(tuner_frequency_khz - c->frequency));\r\ns32tmp = 0x10000 * (tuner_frequency_khz - c->frequency);\r\ns32tmp = DIV_ROUND_CLOSEST(s32tmp, dev->mclk / 1000);\r\nbuf[0] = (s32tmp >> 0) & 0xff;\r\nbuf[1] = (s32tmp >> 8) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, 0x5e, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xb2, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev->delivery_system = c->delivery_system;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, len, rem;\r\nunsigned int utmp;\r\nconst struct firmware *firmware;\r\nconst char *name;\r\ndev_dbg(&client->dev, "\n");\r\ndev->warm = false;\r\nret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0xb9, &utmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "firmware=%02x\n", utmp);\r\nif (utmp)\r\ngoto warm;\r\nret = regmap_write(dev->regmap, 0x07, 0xe0);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x07, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_info(&client->dev, "found a '%s' in cold state\n",\r\nm88ds3103_ops.info.name);\r\nif (dev->chip_id == M88RS6000_CHIP_ID)\r\nname = M88RS6000_FIRMWARE;\r\nelse\r\nname = M88DS3103_FIRMWARE;\r\nret = request_firmware(&firmware, name, &client->dev);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware file '%s' not found\n", name);\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "downloading firmware from file '%s'\n", name);\r\nret = regmap_write(dev->regmap, 0xb2, 0x01);\r\nif (ret)\r\ngoto err_release_firmware;\r\nfor (rem = firmware->size; rem > 0; rem -= (dev->cfg->i2c_wr_max - 1)) {\r\nlen = min(dev->cfg->i2c_wr_max - 1, rem);\r\nret = regmap_bulk_write(dev->regmap, 0xb0,\r\n&firmware->data[firmware->size - rem],\r\nlen);\r\nif (ret) {\r\ndev_err(&client->dev, "firmware download failed %d\n",\r\nret);\r\ngoto err_release_firmware;\r\n}\r\n}\r\nret = regmap_write(dev->regmap, 0xb2, 0x00);\r\nif (ret)\r\ngoto err_release_firmware;\r\nrelease_firmware(firmware);\r\nret = regmap_read(dev->regmap, 0xb9, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (!utmp) {\r\nret = -EINVAL;\r\ndev_info(&client->dev, "firmware did not run\n");\r\ngoto err;\r\n}\r\ndev_info(&client->dev, "found a '%s' in warm state\n",\r\nm88ds3103_ops.info.name);\r\ndev_info(&client->dev, "firmware version: %X.%X\n",\r\n(utmp >> 4) & 0xf, (utmp >> 0 & 0xf));\r\nwarm:\r\ndev->warm = true;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn 0;\r\nerr_release_firmware:\r\nrelease_firmware(firmware);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp;\r\ndev_dbg(&client->dev, "\n");\r\ndev->fe_status = 0;\r\ndev->delivery_system = SYS_UNDEFINED;\r\nif (dev->chip_id == M88RS6000_CHIP_ID)\r\nutmp = 0x29;\r\nelse\r\nutmp = 0x27;\r\nret = m88ds3103_update_bits(dev, utmp, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 buf[3];\r\ndev_dbg(&client->dev, "\n");\r\nif (!dev->warm || !(dev->fe_status & FE_HAS_LOCK)) {\r\nret = 0;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = regmap_bulk_read(dev->regmap, 0xe0, &buf[0], 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0xe6, &buf[1], 1);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 2) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 5) & 0x07) {\r\ncase 0:\r\nc->fec_inner = FEC_7_8;\r\nbreak;\r\ncase 1:\r\nc->fec_inner = FEC_5_6;\r\nbreak;\r\ncase 2:\r\nc->fec_inner = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->fec_inner = FEC_2_3;\r\nbreak;\r\ncase 4:\r\nc->fec_inner = FEC_1_2;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fec_inner\n");\r\n}\r\nc->modulation = QPSK;\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = regmap_bulk_read(dev->regmap, 0x7e, &buf[0], 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0x89, &buf[1], 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0xf2, &buf[2], 1);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 0x0f) {\r\ncase 2:\r\nc->fec_inner = FEC_2_5;\r\nbreak;\r\ncase 3:\r\nc->fec_inner = FEC_1_2;\r\nbreak;\r\ncase 4:\r\nc->fec_inner = FEC_3_5;\r\nbreak;\r\ncase 5:\r\nc->fec_inner = FEC_2_3;\r\nbreak;\r\ncase 6:\r\nc->fec_inner = FEC_3_4;\r\nbreak;\r\ncase 7:\r\nc->fec_inner = FEC_4_5;\r\nbreak;\r\ncase 8:\r\nc->fec_inner = FEC_5_6;\r\nbreak;\r\ncase 9:\r\nc->fec_inner = FEC_8_9;\r\nbreak;\r\ncase 10:\r\nc->fec_inner = FEC_9_10;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fec_inner\n");\r\n}\r\nswitch ((buf[0] >> 5) & 0x01) {\r\ncase 0:\r\nc->pilot = PILOT_OFF;\r\nbreak;\r\ncase 1:\r\nc->pilot = PILOT_ON;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 6) & 0x07) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = PSK_8;\r\nbreak;\r\ncase 2:\r\nc->modulation = APSK_16;\r\nbreak;\r\ncase 3:\r\nc->modulation = APSK_32;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid modulation\n");\r\n}\r\nswitch ((buf[1] >> 7) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 0x03) {\r\ncase 0:\r\nc->rolloff = ROLLOFF_35;\r\nbreak;\r\ncase 1:\r\nc->rolloff = ROLLOFF_25;\r\nbreak;\r\ncase 2:\r\nc->rolloff = ROLLOFF_20;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid rolloff\n");\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid delivery_system\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_bulk_read(dev->regmap, 0x6d, buf, 2);\r\nif (ret)\r\ngoto err;\r\nc->symbol_rate = DIV_ROUND_CLOSEST_ULL((u64)(buf[1] << 8 | buf[0] << 0) * dev->mclk, 0x10000);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL)\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int m88ds3103_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\n*ber = dev->dvbv3_ber;\r\nreturn 0;\r\n}\r\nstatic int m88ds3103_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode fe_sec_tone_mode)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp, tone, reg_a1_mask;\r\ndev_dbg(&client->dev, "fe_sec_tone_mode=%d\n", fe_sec_tone_mode);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (fe_sec_tone_mode) {\r\ncase SEC_TONE_ON:\r\ntone = 0;\r\nreg_a1_mask = 0x47;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ntone = 1;\r\nreg_a1_mask = 0x00;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_tone_mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nutmp = tone << 7 | dev->cfg->envelope_mode << 5;\r\nret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\r\nif (ret)\r\ngoto err;\r\nutmp = 1 << 2;\r\nret = m88ds3103_update_bits(dev, 0xa1, reg_a1_mask, utmp);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage fe_sec_voltage)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp;\r\nbool voltage_sel, voltage_dis;\r\ndev_dbg(&client->dev, "fe_sec_voltage=%d\n", fe_sec_voltage);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (fe_sec_voltage) {\r\ncase SEC_VOLTAGE_18:\r\nvoltage_sel = true;\r\nvoltage_dis = false;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\nvoltage_sel = false;\r\nvoltage_dis = false;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nvoltage_sel = false;\r\nvoltage_dis = true;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_voltage\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nvoltage_sel ^= dev->cfg->lnb_hv_pol;\r\nvoltage_dis ^= dev->cfg->lnb_en_pol;\r\nutmp = voltage_dis << 1 | voltage_sel << 0;\r\nret = m88ds3103_update_bits(dev, 0xa2, 0x03, utmp);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_diseqc_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *diseqc_cmd)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp;\r\nunsigned long timeout;\r\ndev_dbg(&client->dev, "msg=%*ph\n",\r\ndiseqc_cmd->msg_len, diseqc_cmd->msg);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nutmp = dev->cfg->envelope_mode << 5;\r\nret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(dev->regmap, 0xa3, diseqc_cmd->msg,\r\ndiseqc_cmd->msg_len);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0xa1,\r\n(diseqc_cmd->msg_len - 1) << 3 | 0x07);\r\nif (ret)\r\ngoto err;\r\n#define SEND_MASTER_CMD_TIMEOUT 120\r\ntimeout = jiffies + msecs_to_jiffies(SEND_MASTER_CMD_TIMEOUT);\r\nutmp = diseqc_cmd->msg_len * 13500;\r\nusleep_range(utmp - 4000, utmp);\r\nfor (utmp = 1; !time_after(jiffies, timeout) && utmp;) {\r\nret = regmap_read(dev->regmap, 0xa1, &utmp);\r\nif (ret)\r\ngoto err;\r\nutmp = (utmp >> 6) & 0x1;\r\n}\r\nif (utmp == 0) {\r\ndev_dbg(&client->dev, "diseqc tx took %u ms\n",\r\njiffies_to_msecs(jiffies) -\r\n(jiffies_to_msecs(timeout) - SEND_MASTER_CMD_TIMEOUT));\r\n} else {\r\ndev_dbg(&client->dev, "diseqc tx timeout\n");\r\nret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);\r\nif (ret)\r\ngoto err;\r\nif (utmp == 1) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd fe_sec_mini_cmd)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp, burst;\r\nunsigned long timeout;\r\ndev_dbg(&client->dev, "fe_sec_mini_cmd=%d\n", fe_sec_mini_cmd);\r\nif (!dev->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nutmp = dev->cfg->envelope_mode << 5;\r\nret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);\r\nif (ret)\r\ngoto err;\r\nswitch (fe_sec_mini_cmd) {\r\ncase SEC_MINI_A:\r\nburst = 0x02;\r\nbreak;\r\ncase SEC_MINI_B:\r\nburst = 0x01;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid fe_sec_mini_cmd\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0xa1, burst);\r\nif (ret)\r\ngoto err;\r\n#define SEND_BURST_TIMEOUT 40\r\ntimeout = jiffies + msecs_to_jiffies(SEND_BURST_TIMEOUT);\r\nusleep_range(8500, 12500);\r\nfor (utmp = 1; !time_after(jiffies, timeout) && utmp;) {\r\nret = regmap_read(dev->regmap, 0xa1, &utmp);\r\nif (ret)\r\ngoto err;\r\nutmp = (utmp >> 6) & 0x1;\r\n}\r\nif (utmp == 0) {\r\ndev_dbg(&client->dev, "diseqc tx took %u ms\n",\r\njiffies_to_msecs(jiffies) -\r\n(jiffies_to_msecs(timeout) - SEND_BURST_TIMEOUT));\r\n} else {\r\ndev_dbg(&client->dev, "diseqc tx timeout\n");\r\nret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);\r\nif (ret)\r\ngoto err;\r\nif (utmp == 1) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 3000;\r\nreturn 0;\r\n}\r\nstatic void m88ds3103_release(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\ni2c_unregister_device(client);\r\n}\r\nstatic int m88ds3103_select(struct i2c_mux_core *muxc, u32 chan)\r\n{\r\nstruct m88ds3103_dev *dev = i2c_mux_priv(muxc);\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = "\x03\x11",\r\n};\r\nret = __i2c_transfer(client->adapter, &msg, 1);\r\nif (ret != 1) {\r\ndev_warn(&client->dev, "i2c wr failed=%d\n", ret);\r\nif (ret >= 0)\r\nret = -EREMOTEIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *cfg,\r\nstruct i2c_adapter *i2c, struct i2c_adapter **tuner_i2c_adapter)\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info;\r\nstruct m88ds3103_platform_data pdata;\r\npdata.clk = cfg->clock;\r\npdata.i2c_wr_max = cfg->i2c_wr_max;\r\npdata.ts_mode = cfg->ts_mode;\r\npdata.ts_clk = cfg->ts_clk;\r\npdata.ts_clk_pol = cfg->ts_clk_pol;\r\npdata.spec_inv = cfg->spec_inv;\r\npdata.agc = cfg->agc;\r\npdata.agc_inv = cfg->agc_inv;\r\npdata.clk_out = cfg->clock_out;\r\npdata.envelope_mode = cfg->envelope_mode;\r\npdata.lnb_hv_pol = cfg->lnb_hv_pol;\r\npdata.lnb_en_pol = cfg->lnb_en_pol;\r\npdata.attach_in_use = true;\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "m88ds3103", I2C_NAME_SIZE);\r\nboard_info.addr = cfg->i2c_addr;\r\nboard_info.platform_data = &pdata;\r\nclient = i2c_new_device(i2c, &board_info);\r\nif (!client || !client->dev.driver)\r\nreturn NULL;\r\n*tuner_i2c_adapter = pdata.get_i2c_adapter(client);\r\nreturn pdata.get_dvb_frontend(client);\r\n}\r\nstatic struct dvb_frontend *m88ds3103_get_dvb_frontend(struct i2c_client *client)\r\n{\r\nstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn &dev->fe;\r\n}\r\nstatic struct i2c_adapter *m88ds3103_get_i2c_adapter(struct i2c_client *client)\r\n{\r\nstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nreturn dev->muxc->adapter[0];\r\n}\r\nstatic int m88ds3103_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct m88ds3103_dev *dev;\r\nstruct m88ds3103_platform_data *pdata = client->dev.platform_data;\r\nint ret;\r\nunsigned int utmp;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->client = client;\r\ndev->config.clock = pdata->clk;\r\ndev->config.i2c_wr_max = pdata->i2c_wr_max;\r\ndev->config.ts_mode = pdata->ts_mode;\r\ndev->config.ts_clk = pdata->ts_clk * 1000;\r\ndev->config.ts_clk_pol = pdata->ts_clk_pol;\r\ndev->config.spec_inv = pdata->spec_inv;\r\ndev->config.agc_inv = pdata->agc_inv;\r\ndev->config.clock_out = pdata->clk_out;\r\ndev->config.envelope_mode = pdata->envelope_mode;\r\ndev->config.agc = pdata->agc;\r\ndev->config.lnb_hv_pol = pdata->lnb_hv_pol;\r\ndev->config.lnb_en_pol = pdata->lnb_en_pol;\r\ndev->cfg = &dev->config;\r\ndev->regmap_config.reg_bits = 8,\r\ndev->regmap_config.val_bits = 8,\r\ndev->regmap_config.lock_arg = dev,\r\ndev->regmap = devm_regmap_init_i2c(client, &dev->regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nret = regmap_read(dev->regmap, 0x00, &utmp);\r\nif (ret)\r\ngoto err_kfree;\r\ndev->chip_id = utmp >> 1;\r\ndev_dbg(&client->dev, "chip_id=%02x\n", dev->chip_id);\r\nswitch (dev->chip_id) {\r\ncase M88RS6000_CHIP_ID:\r\ncase M88DS3103_CHIP_ID:\r\nbreak;\r\ndefault:\r\ngoto err_kfree;\r\n}\r\nswitch (dev->cfg->clock_out) {\r\ncase M88DS3103_CLOCK_OUT_DISABLED:\r\nutmp = 0x80;\r\nbreak;\r\ncase M88DS3103_CLOCK_OUT_ENABLED:\r\nutmp = 0x00;\r\nbreak;\r\ncase M88DS3103_CLOCK_OUT_ENABLED_DIV2:\r\nutmp = 0x10;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_kfree;\r\n}\r\nif (!pdata->ts_clk) {\r\nret = -EINVAL;\r\ngoto err_kfree;\r\n}\r\nif (dev->chip_id == M88RS6000_CHIP_ID)\r\nutmp = 0x00;\r\nret = regmap_write(dev->regmap, 0x29, utmp);\r\nif (ret)\r\ngoto err_kfree;\r\nret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);\r\nif (ret)\r\ngoto err_kfree;\r\nret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);\r\nif (ret)\r\ngoto err_kfree;\r\nret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);\r\nif (ret)\r\ngoto err_kfree;\r\ndev->muxc = i2c_mux_alloc(client->adapter, &client->dev, 1, 0, 0,\r\nm88ds3103_select, NULL);\r\nif (!dev->muxc) {\r\nret = -ENOMEM;\r\ngoto err_kfree;\r\n}\r\ndev->muxc->priv = dev;\r\nret = i2c_mux_add_adapter(dev->muxc, 0, 0, 0);\r\nif (ret)\r\ngoto err_kfree;\r\nmemcpy(&dev->fe.ops, &m88ds3103_ops, sizeof(struct dvb_frontend_ops));\r\nif (dev->chip_id == M88RS6000_CHIP_ID)\r\nstrncpy(dev->fe.ops.info.name, "Montage Technology M88RS6000",\r\nsizeof(dev->fe.ops.info.name));\r\nif (!pdata->attach_in_use)\r\ndev->fe.ops.release = NULL;\r\ndev->fe.demodulator_priv = dev;\r\ni2c_set_clientdata(client, dev);\r\npdata->get_dvb_frontend = m88ds3103_get_dvb_frontend;\r\npdata->get_i2c_adapter = m88ds3103_get_i2c_adapter;\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_remove(struct i2c_client *client)\r\n{\r\nstruct m88ds3103_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\ni2c_mux_del_adapters(dev->muxc);\r\nkfree(dev);\r\nreturn 0;\r\n}
