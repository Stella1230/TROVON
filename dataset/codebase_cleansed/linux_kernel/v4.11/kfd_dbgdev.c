static void dbgdev_address_watch_disable_nodiq(struct kfd_dev *dev)\r\n{\r\nBUG_ON(!dev || !dev->kfd2kgd);\r\ndev->kfd2kgd->address_watch_disable(dev->kgd);\r\n}\r\nstatic int dbgdev_diq_submit_ib(struct kfd_dbgdev *dbgdev,\r\nunsigned int pasid, uint64_t vmid0_address,\r\nuint32_t *packet_buff, size_t size_in_bytes)\r\n{\r\nstruct pm4__release_mem *rm_packet;\r\nstruct pm4__indirect_buffer_pasid *ib_packet;\r\nstruct kfd_mem_obj *mem_obj;\r\nsize_t pq_packets_size_in_bytes;\r\nunion ULARGE_INTEGER *largep;\r\nunion ULARGE_INTEGER addr;\r\nstruct kernel_queue *kq;\r\nuint64_t *rm_state;\r\nunsigned int *ib_packet_buff;\r\nint status;\r\nBUG_ON(!dbgdev || !dbgdev->kq || !packet_buff || !size_in_bytes);\r\nkq = dbgdev->kq;\r\npq_packets_size_in_bytes = sizeof(struct pm4__release_mem) +\r\nsizeof(struct pm4__indirect_buffer_pasid);\r\nstatus = kq->ops.acquire_packet_buffer(kq,\r\npq_packets_size_in_bytes / sizeof(uint32_t),\r\n&ib_packet_buff);\r\nif (status != 0) {\r\npr_err("amdkfd: acquire_packet_buffer failed\n");\r\nreturn status;\r\n}\r\nmemset(ib_packet_buff, 0, pq_packets_size_in_bytes);\r\nib_packet = (struct pm4__indirect_buffer_pasid *) (ib_packet_buff);\r\nib_packet->header.count = 3;\r\nib_packet->header.opcode = IT_INDIRECT_BUFFER_PASID;\r\nib_packet->header.type = PM4_TYPE_3;\r\nlargep = (union ULARGE_INTEGER *) &vmid0_address;\r\nib_packet->bitfields2.ib_base_lo = largep->u.low_part >> 2;\r\nib_packet->bitfields3.ib_base_hi = largep->u.high_part;\r\nib_packet->control = (1 << 23) | (1 << 31) |\r\n((size_in_bytes / sizeof(uint32_t)) & 0xfffff);\r\nib_packet->bitfields5.pasid = pasid;\r\nrm_packet = (struct pm4__release_mem *) (ib_packet_buff +\r\n(sizeof(struct pm4__indirect_buffer_pasid) /\r\nsizeof(unsigned int)));\r\nstatus = kfd_gtt_sa_allocate(dbgdev->dev, sizeof(uint64_t),\r\n&mem_obj);\r\nif (status != 0) {\r\npr_err("amdkfd: Failed to allocate GART memory\n");\r\nkq->ops.rollback_packet(kq);\r\nreturn status;\r\n}\r\nrm_state = (uint64_t *) mem_obj->cpu_ptr;\r\n*rm_state = QUEUESTATE__ACTIVE_COMPLETION_PENDING;\r\nrm_packet->header.opcode = IT_RELEASE_MEM;\r\nrm_packet->header.type = PM4_TYPE_3;\r\nrm_packet->header.count = sizeof(struct pm4__release_mem) /\r\nsizeof(unsigned int) - 2;\r\nrm_packet->bitfields2.event_type = CACHE_FLUSH_AND_INV_TS_EVENT;\r\nrm_packet->bitfields2.event_index =\r\nevent_index___release_mem__end_of_pipe;\r\nrm_packet->bitfields2.cache_policy = cache_policy___release_mem__lru;\r\nrm_packet->bitfields2.atc = 0;\r\nrm_packet->bitfields2.tc_wb_action_ena = 1;\r\naddr.quad_part = mem_obj->gpu_addr;\r\nrm_packet->bitfields4.address_lo_32b = addr.u.low_part >> 2;\r\nrm_packet->address_hi = addr.u.high_part;\r\nrm_packet->bitfields3.data_sel =\r\ndata_sel___release_mem__send_64_bit_data;\r\nrm_packet->bitfields3.int_sel =\r\nint_sel___release_mem__send_data_after_write_confirm;\r\nrm_packet->bitfields3.dst_sel =\r\ndst_sel___release_mem__memory_controller;\r\nrm_packet->data_lo = QUEUESTATE__ACTIVE;\r\nkq->ops.submit_packet(kq);\r\nstatus = amdkfd_fence_wait_timeout(\r\n(unsigned int *) rm_state,\r\nQUEUESTATE__ACTIVE, 1500);\r\nkfd_gtt_sa_free(dbgdev->dev, mem_obj);\r\nreturn status;\r\n}\r\nstatic int dbgdev_register_nodiq(struct kfd_dbgdev *dbgdev)\r\n{\r\nBUG_ON(!dbgdev);\r\ndbgdev->kq = NULL;\r\nreturn 0;\r\n}\r\nstatic int dbgdev_register_diq(struct kfd_dbgdev *dbgdev)\r\n{\r\nstruct queue_properties properties;\r\nunsigned int qid;\r\nstruct kernel_queue *kq = NULL;\r\nint status;\r\nBUG_ON(!dbgdev || !dbgdev->pqm || !dbgdev->dev);\r\nstatus = pqm_create_queue(dbgdev->pqm, dbgdev->dev, NULL,\r\n&properties, 0, KFD_QUEUE_TYPE_DIQ,\r\n&qid);\r\nif (status) {\r\npr_err("amdkfd: Failed to create DIQ\n");\r\nreturn status;\r\n}\r\npr_debug("DIQ Created with queue id: %d\n", qid);\r\nkq = pqm_get_kernel_queue(dbgdev->pqm, qid);\r\nif (kq == NULL) {\r\npr_err("amdkfd: Error getting DIQ\n");\r\npqm_destroy_queue(dbgdev->pqm, qid);\r\nreturn -EFAULT;\r\n}\r\ndbgdev->kq = kq;\r\nreturn status;\r\n}\r\nstatic int dbgdev_unregister_nodiq(struct kfd_dbgdev *dbgdev)\r\n{\r\nBUG_ON(!dbgdev || !dbgdev->dev);\r\ndbgdev_address_watch_disable_nodiq(dbgdev->dev);\r\nreturn 0;\r\n}\r\nstatic int dbgdev_unregister_diq(struct kfd_dbgdev *dbgdev)\r\n{\r\nint status;\r\nBUG_ON(!dbgdev || !dbgdev->pqm || !dbgdev->kq);\r\nstatus = pqm_destroy_queue(dbgdev->pqm,\r\ndbgdev->kq->queue->properties.queue_id);\r\ndbgdev->kq = NULL;\r\nreturn status;\r\n}\r\nstatic void dbgdev_address_watch_set_registers(\r\nconst struct dbg_address_watch_info *adw_info,\r\nunion TCP_WATCH_ADDR_H_BITS *addrHi,\r\nunion TCP_WATCH_ADDR_L_BITS *addrLo,\r\nunion TCP_WATCH_CNTL_BITS *cntl,\r\nunsigned int index, unsigned int vmid)\r\n{\r\nunion ULARGE_INTEGER addr;\r\nBUG_ON(!adw_info || !addrHi || !addrLo || !cntl);\r\naddr.quad_part = 0;\r\naddrHi->u32All = 0;\r\naddrLo->u32All = 0;\r\ncntl->u32All = 0;\r\nif (adw_info->watch_mask != NULL)\r\ncntl->bitfields.mask =\r\n(uint32_t) (adw_info->watch_mask[index] &\r\nADDRESS_WATCH_REG_CNTL_DEFAULT_MASK);\r\nelse\r\ncntl->bitfields.mask = ADDRESS_WATCH_REG_CNTL_DEFAULT_MASK;\r\naddr.quad_part = (unsigned long long) adw_info->watch_address[index];\r\naddrHi->bitfields.addr = addr.u.high_part &\r\nADDRESS_WATCH_REG_ADDHIGH_MASK;\r\naddrLo->bitfields.addr =\r\n(addr.u.low_part >> ADDRESS_WATCH_REG_ADDLOW_SHIFT);\r\ncntl->bitfields.mode = adw_info->watch_mode[index];\r\ncntl->bitfields.vmid = (uint32_t) vmid;\r\ncntl->u32All |= ADDRESS_WATCH_REG_CNTL_ATC_BIT;\r\npr_debug("\t\t%20s %08x\n", "set reg mask :", cntl->bitfields.mask);\r\npr_debug("\t\t%20s %08x\n", "set reg add high :",\r\naddrHi->bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "set reg add low :",\r\naddrLo->bitfields.addr);\r\n}\r\nstatic int dbgdev_address_watch_nodiq(struct kfd_dbgdev *dbgdev,\r\nstruct dbg_address_watch_info *adw_info)\r\n{\r\nunion TCP_WATCH_ADDR_H_BITS addrHi;\r\nunion TCP_WATCH_ADDR_L_BITS addrLo;\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\nstruct kfd_process_device *pdd;\r\nunsigned int i;\r\nBUG_ON(!dbgdev || !dbgdev->dev || !adw_info);\r\npdd = kfd_get_process_device_data(dbgdev->dev,\r\nadw_info->process);\r\nif (!pdd) {\r\npr_err("amdkfd: Failed to get pdd for wave control no DIQ\n");\r\nreturn -EFAULT;\r\n}\r\naddrHi.u32All = 0;\r\naddrLo.u32All = 0;\r\ncntl.u32All = 0;\r\nif ((adw_info->num_watch_points > MAX_WATCH_ADDRESSES) ||\r\n(adw_info->num_watch_points == 0)) {\r\npr_err("amdkfd: num_watch_points is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif ((adw_info->watch_mode == NULL) ||\r\n(adw_info->watch_address == NULL)) {\r\npr_err("amdkfd: adw_info fields are not valid\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0 ; i < adw_info->num_watch_points ; i++) {\r\ndbgdev_address_watch_set_registers(adw_info, &addrHi, &addrLo,\r\n&cntl, i, pdd->qpd.vmid);\r\npr_debug("\t\t%30s\n", "* * * * * * * * * * * * * * * * * *");\r\npr_debug("\t\t%20s %08x\n", "register index :", i);\r\npr_debug("\t\t%20s %08x\n", "vmid is :", pdd->qpd.vmid);\r\npr_debug("\t\t%20s %08x\n", "Address Low is :",\r\naddrLo.bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "Address high is :",\r\naddrHi.bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "Address high is :",\r\naddrHi.bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "Control Mask is :",\r\ncntl.bitfields.mask);\r\npr_debug("\t\t%20s %08x\n", "Control Mode is :",\r\ncntl.bitfields.mode);\r\npr_debug("\t\t%20s %08x\n", "Control Vmid is :",\r\ncntl.bitfields.vmid);\r\npr_debug("\t\t%20s %08x\n", "Control atc is :",\r\ncntl.bitfields.atc);\r\npr_debug("\t\t%30s\n", "* * * * * * * * * * * * * * * * * *");\r\npdd->dev->kfd2kgd->address_watch_execute(\r\ndbgdev->dev->kgd,\r\ni,\r\ncntl.u32All,\r\naddrHi.u32All,\r\naddrLo.u32All);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dbgdev_address_watch_diq(struct kfd_dbgdev *dbgdev,\r\nstruct dbg_address_watch_info *adw_info)\r\n{\r\nstruct pm4__set_config_reg *packets_vec;\r\nunion TCP_WATCH_ADDR_H_BITS addrHi;\r\nunion TCP_WATCH_ADDR_L_BITS addrLo;\r\nunion TCP_WATCH_CNTL_BITS cntl;\r\nstruct kfd_mem_obj *mem_obj;\r\nunsigned int aw_reg_add_dword;\r\nuint32_t *packet_buff_uint;\r\nunsigned int i;\r\nint status;\r\nsize_t ib_size = sizeof(struct pm4__set_config_reg) * 4;\r\nunsigned int vmid = 0;\r\nBUG_ON(!dbgdev || !dbgdev->dev || !adw_info);\r\naddrHi.u32All = 0;\r\naddrLo.u32All = 0;\r\ncntl.u32All = 0;\r\nif ((adw_info->num_watch_points > MAX_WATCH_ADDRESSES) ||\r\n(adw_info->num_watch_points == 0)) {\r\npr_err("amdkfd: num_watch_points is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif ((NULL == adw_info->watch_mode) ||\r\n(NULL == adw_info->watch_address)) {\r\npr_err("amdkfd: adw_info fields are not valid\n");\r\nreturn -EINVAL;\r\n}\r\nstatus = kfd_gtt_sa_allocate(dbgdev->dev, ib_size, &mem_obj);\r\nif (status != 0) {\r\npr_err("amdkfd: Failed to allocate GART memory\n");\r\nreturn status;\r\n}\r\npacket_buff_uint = mem_obj->cpu_ptr;\r\nmemset(packet_buff_uint, 0, ib_size);\r\npackets_vec = (struct pm4__set_config_reg *) (packet_buff_uint);\r\npackets_vec[0].header.count = 1;\r\npackets_vec[0].header.opcode = IT_SET_CONFIG_REG;\r\npackets_vec[0].header.type = PM4_TYPE_3;\r\npackets_vec[0].bitfields2.vmid_shift = ADDRESS_WATCH_CNTL_OFFSET;\r\npackets_vec[0].bitfields2.insert_vmid = 1;\r\npackets_vec[1].ordinal1 = packets_vec[0].ordinal1;\r\npackets_vec[1].bitfields2.insert_vmid = 0;\r\npackets_vec[2].ordinal1 = packets_vec[0].ordinal1;\r\npackets_vec[2].bitfields2.insert_vmid = 0;\r\npackets_vec[3].ordinal1 = packets_vec[0].ordinal1;\r\npackets_vec[3].bitfields2.vmid_shift = ADDRESS_WATCH_CNTL_OFFSET;\r\npackets_vec[3].bitfields2.insert_vmid = 1;\r\nfor (i = 0; i < adw_info->num_watch_points; i++) {\r\ndbgdev_address_watch_set_registers(adw_info,\r\n&addrHi,\r\n&addrLo,\r\n&cntl,\r\ni,\r\nvmid);\r\npr_debug("\t\t%30s\n", "* * * * * * * * * * * * * * * * * *");\r\npr_debug("\t\t%20s %08x\n", "register index :", i);\r\npr_debug("\t\t%20s %08x\n", "vmid is :", vmid);\r\npr_debug("\t\t%20s %p\n", "Add ptr is :",\r\nadw_info->watch_address);\r\npr_debug("\t\t%20s %08llx\n", "Add is :",\r\nadw_info->watch_address[i]);\r\npr_debug("\t\t%20s %08x\n", "Address Low is :",\r\naddrLo.bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "Address high is :",\r\naddrHi.bitfields.addr);\r\npr_debug("\t\t%20s %08x\n", "Control Mask is :",\r\ncntl.bitfields.mask);\r\npr_debug("\t\t%20s %08x\n", "Control Mode is :",\r\ncntl.bitfields.mode);\r\npr_debug("\t\t%20s %08x\n", "Control Vmid is :",\r\ncntl.bitfields.vmid);\r\npr_debug("\t\t%20s %08x\n", "Control atc is :",\r\ncntl.bitfields.atc);\r\npr_debug("\t\t%30s\n", "* * * * * * * * * * * * * * * * * *");\r\naw_reg_add_dword =\r\ndbgdev->dev->kfd2kgd->address_watch_get_offset(\r\ndbgdev->dev->kgd,\r\ni,\r\nADDRESS_WATCH_REG_CNTL);\r\naw_reg_add_dword /= sizeof(uint32_t);\r\npackets_vec[0].bitfields2.reg_offset =\r\naw_reg_add_dword - AMD_CONFIG_REG_BASE;\r\npackets_vec[0].reg_data[0] = cntl.u32All;\r\naw_reg_add_dword =\r\ndbgdev->dev->kfd2kgd->address_watch_get_offset(\r\ndbgdev->dev->kgd,\r\ni,\r\nADDRESS_WATCH_REG_ADDR_HI);\r\naw_reg_add_dword /= sizeof(uint32_t);\r\npackets_vec[1].bitfields2.reg_offset =\r\naw_reg_add_dword - AMD_CONFIG_REG_BASE;\r\npackets_vec[1].reg_data[0] = addrHi.u32All;\r\naw_reg_add_dword =\r\ndbgdev->dev->kfd2kgd->address_watch_get_offset(\r\ndbgdev->dev->kgd,\r\ni,\r\nADDRESS_WATCH_REG_ADDR_LO);\r\naw_reg_add_dword /= sizeof(uint32_t);\r\npackets_vec[2].bitfields2.reg_offset =\r\naw_reg_add_dword - AMD_CONFIG_REG_BASE;\r\npackets_vec[2].reg_data[0] = addrLo.u32All;\r\nif (adw_info->watch_address[i] > 0)\r\ncntl.bitfields.valid = 1;\r\nelse\r\ncntl.bitfields.valid = 0;\r\naw_reg_add_dword =\r\ndbgdev->dev->kfd2kgd->address_watch_get_offset(\r\ndbgdev->dev->kgd,\r\ni,\r\nADDRESS_WATCH_REG_CNTL);\r\naw_reg_add_dword /= sizeof(uint32_t);\r\npackets_vec[3].bitfields2.reg_offset =\r\naw_reg_add_dword - AMD_CONFIG_REG_BASE;\r\npackets_vec[3].reg_data[0] = cntl.u32All;\r\nstatus = dbgdev_diq_submit_ib(\r\ndbgdev,\r\nadw_info->process->pasid,\r\nmem_obj->gpu_addr,\r\npacket_buff_uint,\r\nib_size);\r\nif (status != 0) {\r\npr_err("amdkfd: Failed to submit IB to DIQ\n");\r\nbreak;\r\n}\r\n}\r\nkfd_gtt_sa_free(dbgdev->dev, mem_obj);\r\nreturn status;\r\n}\r\nstatic int dbgdev_wave_control_set_registers(\r\nstruct dbg_wave_control_info *wac_info,\r\nunion SQ_CMD_BITS *in_reg_sq_cmd,\r\nunion GRBM_GFX_INDEX_BITS *in_reg_gfx_index)\r\n{\r\nint status = 0;\r\nunion SQ_CMD_BITS reg_sq_cmd;\r\nunion GRBM_GFX_INDEX_BITS reg_gfx_index;\r\nstruct HsaDbgWaveMsgAMDGen2 *pMsg;\r\nBUG_ON(!wac_info || !in_reg_sq_cmd || !in_reg_gfx_index);\r\nreg_sq_cmd.u32All = 0;\r\nreg_gfx_index.u32All = 0;\r\npMsg = &wac_info->dbgWave_msg.DbgWaveMsg.WaveMsgInfoGen2;\r\nswitch (wac_info->mode) {\r\ncase HSA_DBG_WAVEMODE_SINGLE:\r\nreg_sq_cmd.bits.check_vmid = 1;\r\nreg_sq_cmd.bits.simd_id = pMsg->ui32.SIMD;\r\nreg_sq_cmd.bits.wave_id = pMsg->ui32.WaveId;\r\nreg_sq_cmd.bits.mode = SQ_IND_CMD_MODE_SINGLE;\r\nreg_gfx_index.bits.sh_index = pMsg->ui32.ShaderArray;\r\nreg_gfx_index.bits.se_index = pMsg->ui32.ShaderEngine;\r\nreg_gfx_index.bits.instance_index = pMsg->ui32.HSACU;\r\nbreak;\r\ncase HSA_DBG_WAVEMODE_BROADCAST_PROCESS:\r\nreg_gfx_index.bits.sh_broadcast_writes = 1;\r\nreg_gfx_index.bits.se_broadcast_writes = 1;\r\nreg_gfx_index.bits.instance_broadcast_writes = 1;\r\nreg_sq_cmd.bits.mode = SQ_IND_CMD_MODE_BROADCAST;\r\nbreak;\r\ncase HSA_DBG_WAVEMODE_BROADCAST_PROCESS_CU:\r\nreg_sq_cmd.bits.check_vmid = 1;\r\nreg_sq_cmd.bits.mode = SQ_IND_CMD_MODE_BROADCAST;\r\nreg_gfx_index.bits.sh_index = pMsg->ui32.ShaderArray;\r\nreg_gfx_index.bits.se_index = pMsg->ui32.ShaderEngine;\r\nreg_gfx_index.bits.instance_index = pMsg->ui32.HSACU;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (wac_info->operand) {\r\ncase HSA_DBG_WAVEOP_HALT:\r\nreg_sq_cmd.bits.cmd = SQ_IND_CMD_CMD_HALT;\r\nbreak;\r\ncase HSA_DBG_WAVEOP_RESUME:\r\nreg_sq_cmd.bits.cmd = SQ_IND_CMD_CMD_RESUME;\r\nbreak;\r\ncase HSA_DBG_WAVEOP_KILL:\r\nreg_sq_cmd.bits.cmd = SQ_IND_CMD_CMD_KILL;\r\nbreak;\r\ncase HSA_DBG_WAVEOP_DEBUG:\r\nreg_sq_cmd.bits.cmd = SQ_IND_CMD_CMD_DEBUG;\r\nbreak;\r\ncase HSA_DBG_WAVEOP_TRAP:\r\nif (wac_info->trapId < MAX_TRAPID) {\r\nreg_sq_cmd.bits.cmd = SQ_IND_CMD_CMD_TRAP;\r\nreg_sq_cmd.bits.trap_id = wac_info->trapId;\r\n} else {\r\nstatus = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (status == 0) {\r\n*in_reg_sq_cmd = reg_sq_cmd;\r\n*in_reg_gfx_index = reg_gfx_index;\r\n}\r\nreturn status;\r\n}\r\nstatic int dbgdev_wave_control_diq(struct kfd_dbgdev *dbgdev,\r\nstruct dbg_wave_control_info *wac_info)\r\n{\r\nint status;\r\nunion SQ_CMD_BITS reg_sq_cmd;\r\nunion GRBM_GFX_INDEX_BITS reg_gfx_index;\r\nstruct kfd_mem_obj *mem_obj;\r\nuint32_t *packet_buff_uint;\r\nstruct pm4__set_config_reg *packets_vec;\r\nsize_t ib_size = sizeof(struct pm4__set_config_reg) * 3;\r\nBUG_ON(!dbgdev || !wac_info);\r\nreg_sq_cmd.u32All = 0;\r\nstatus = dbgdev_wave_control_set_registers(wac_info, &reg_sq_cmd,\r\n&reg_gfx_index);\r\nif (status) {\r\npr_err("amdkfd: Failed to set wave control registers\n");\r\nreturn status;\r\n}\r\nreg_sq_cmd.bits.vm_id = 0;\r\npr_debug("\t\t %30s\n", "* * * * * * * * * * * * * * * * * *");\r\npr_debug("\t\t mode is: %u\n", wac_info->mode);\r\npr_debug("\t\t operand is: %u\n", wac_info->operand);\r\npr_debug("\t\t trap id is: %u\n", wac_info->trapId);\r\npr_debug("\t\t msg value is: %u\n",\r\nwac_info->dbgWave_msg.DbgWaveMsg.WaveMsgInfoGen2.Value);\r\npr_debug("\t\t vmid is: N/A\n");\r\npr_debug("\t\t chk_vmid is : %u\n", reg_sq_cmd.bitfields.check_vmid);\r\npr_debug("\t\t command is : %u\n", reg_sq_cmd.bitfields.cmd);\r\npr_debug("\t\t queue id is : %u\n", reg_sq_cmd.bitfields.queue_id);\r\npr_debug("\t\t simd id is : %u\n", reg_sq_cmd.bitfields.simd_id);\r\npr_debug("\t\t mode is : %u\n", reg_sq_cmd.bitfields.mode);\r\npr_debug("\t\t vm_id is : %u\n", reg_sq_cmd.bitfields.vm_id);\r\npr_debug("\t\t wave_id is : %u\n", reg_sq_cmd.bitfields.wave_id);\r\npr_debug("\t\t ibw is : %u\n",\r\nreg_gfx_index.bitfields.instance_broadcast_writes);\r\npr_debug("\t\t ii is : %u\n",\r\nreg_gfx_index.bitfields.instance_index);\r\npr_debug("\t\t sebw is : %u\n",\r\nreg_gfx_index.bitfields.se_broadcast_writes);\r\npr_debug("\t\t se_ind is : %u\n", reg_gfx_index.bitfields.se_index);\r\npr_debug("\t\t sh_ind is : %u\n", reg_gfx_index.bitfields.sh_index);\r\npr_debug("\t\t sbw is : %u\n",\r\nreg_gfx_index.bitfields.sh_broadcast_writes);\r\npr_debug("\t\t %30s\n", "* * * * * * * * * * * * * * * * * *");\r\nstatus = kfd_gtt_sa_allocate(dbgdev->dev, ib_size, &mem_obj);\r\nif (status != 0) {\r\npr_err("amdkfd: Failed to allocate GART memory\n");\r\nreturn status;\r\n}\r\npacket_buff_uint = mem_obj->cpu_ptr;\r\nmemset(packet_buff_uint, 0, ib_size);\r\npackets_vec = (struct pm4__set_config_reg *) packet_buff_uint;\r\npackets_vec[0].header.count = 1;\r\npackets_vec[0].header.opcode = IT_SET_UCONFIG_REG;\r\npackets_vec[0].header.type = PM4_TYPE_3;\r\npackets_vec[0].bitfields2.reg_offset =\r\nGRBM_GFX_INDEX / (sizeof(uint32_t)) -\r\nUSERCONFIG_REG_BASE;\r\npackets_vec[0].bitfields2.insert_vmid = 0;\r\npackets_vec[0].reg_data[0] = reg_gfx_index.u32All;\r\npackets_vec[1].header.count = 1;\r\npackets_vec[1].header.opcode = IT_SET_CONFIG_REG;\r\npackets_vec[1].header.type = PM4_TYPE_3;\r\npackets_vec[1].bitfields2.reg_offset = SQ_CMD / (sizeof(uint32_t)) -\r\nAMD_CONFIG_REG_BASE;\r\npackets_vec[1].bitfields2.vmid_shift = SQ_CMD_VMID_OFFSET;\r\npackets_vec[1].bitfields2.insert_vmid = 1;\r\npackets_vec[1].reg_data[0] = reg_sq_cmd.u32All;\r\nreg_gfx_index.u32All = 0;\r\nreg_gfx_index.bits.sh_broadcast_writes = 1;\r\nreg_gfx_index.bits.instance_broadcast_writes = 1;\r\nreg_gfx_index.bits.se_broadcast_writes = 1;\r\npackets_vec[2].ordinal1 = packets_vec[0].ordinal1;\r\npackets_vec[2].bitfields2.reg_offset =\r\nGRBM_GFX_INDEX / (sizeof(uint32_t)) -\r\nUSERCONFIG_REG_BASE;\r\npackets_vec[2].bitfields2.insert_vmid = 0;\r\npackets_vec[2].reg_data[0] = reg_gfx_index.u32All;\r\nstatus = dbgdev_diq_submit_ib(\r\ndbgdev,\r\nwac_info->process->pasid,\r\nmem_obj->gpu_addr,\r\npacket_buff_uint,\r\nib_size);\r\nif (status != 0)\r\npr_err("amdkfd: Failed to submit IB to DIQ\n");\r\nkfd_gtt_sa_free(dbgdev->dev, mem_obj);\r\nreturn status;\r\n}\r\nstatic int dbgdev_wave_control_nodiq(struct kfd_dbgdev *dbgdev,\r\nstruct dbg_wave_control_info *wac_info)\r\n{\r\nint status;\r\nunion SQ_CMD_BITS reg_sq_cmd;\r\nunion GRBM_GFX_INDEX_BITS reg_gfx_index;\r\nstruct kfd_process_device *pdd;\r\nBUG_ON(!dbgdev || !dbgdev->dev || !wac_info);\r\nreg_sq_cmd.u32All = 0;\r\npdd = kfd_get_process_device_data(dbgdev->dev, wac_info->process);\r\nif (!pdd) {\r\npr_err("amdkfd: Failed to get pdd for wave control no DIQ\n");\r\nreturn -EFAULT;\r\n}\r\nstatus = dbgdev_wave_control_set_registers(wac_info, &reg_sq_cmd,\r\n&reg_gfx_index);\r\nif (status) {\r\npr_err("amdkfd: Failed to set wave control registers\n");\r\nreturn status;\r\n}\r\nreg_sq_cmd.bits.vm_id = pdd->qpd.vmid;\r\npr_debug("\t\t %30s\n", "* * * * * * * * * * * * * * * * * *");\r\npr_debug("\t\t mode is: %u\n", wac_info->mode);\r\npr_debug("\t\t operand is: %u\n", wac_info->operand);\r\npr_debug("\t\t trap id is: %u\n", wac_info->trapId);\r\npr_debug("\t\t msg value is: %u\n",\r\nwac_info->dbgWave_msg.DbgWaveMsg.WaveMsgInfoGen2.Value);\r\npr_debug("\t\t vmid is: %u\n", pdd->qpd.vmid);\r\npr_debug("\t\t chk_vmid is : %u\n", reg_sq_cmd.bitfields.check_vmid);\r\npr_debug("\t\t command is : %u\n", reg_sq_cmd.bitfields.cmd);\r\npr_debug("\t\t queue id is : %u\n", reg_sq_cmd.bitfields.queue_id);\r\npr_debug("\t\t simd id is : %u\n", reg_sq_cmd.bitfields.simd_id);\r\npr_debug("\t\t mode is : %u\n", reg_sq_cmd.bitfields.mode);\r\npr_debug("\t\t vm_id is : %u\n", reg_sq_cmd.bitfields.vm_id);\r\npr_debug("\t\t wave_id is : %u\n", reg_sq_cmd.bitfields.wave_id);\r\npr_debug("\t\t ibw is : %u\n",\r\nreg_gfx_index.bitfields.instance_broadcast_writes);\r\npr_debug("\t\t ii is : %u\n",\r\nreg_gfx_index.bitfields.instance_index);\r\npr_debug("\t\t sebw is : %u\n",\r\nreg_gfx_index.bitfields.se_broadcast_writes);\r\npr_debug("\t\t se_ind is : %u\n", reg_gfx_index.bitfields.se_index);\r\npr_debug("\t\t sh_ind is : %u\n", reg_gfx_index.bitfields.sh_index);\r\npr_debug("\t\t sbw is : %u\n",\r\nreg_gfx_index.bitfields.sh_broadcast_writes);\r\npr_debug("\t\t %30s\n", "* * * * * * * * * * * * * * * * * *");\r\nreturn dbgdev->dev->kfd2kgd->wave_control_execute(dbgdev->dev->kgd,\r\nreg_gfx_index.u32All,\r\nreg_sq_cmd.u32All);\r\n}\r\nint dbgdev_wave_reset_wavefronts(struct kfd_dev *dev, struct kfd_process *p)\r\n{\r\nint status = 0;\r\nunsigned int vmid;\r\nunion SQ_CMD_BITS reg_sq_cmd;\r\nunion GRBM_GFX_INDEX_BITS reg_gfx_index;\r\nstruct kfd_process_device *pdd;\r\nstruct dbg_wave_control_info wac_info;\r\nint temp;\r\nint first_vmid_to_scan = 8;\r\nint last_vmid_to_scan = 15;\r\nfirst_vmid_to_scan = ffs(dev->shared_resources.compute_vmid_bitmap) - 1;\r\ntemp = dev->shared_resources.compute_vmid_bitmap >> first_vmid_to_scan;\r\nlast_vmid_to_scan = first_vmid_to_scan + ffz(temp);\r\nreg_sq_cmd.u32All = 0;\r\nstatus = 0;\r\nwac_info.mode = HSA_DBG_WAVEMODE_BROADCAST_PROCESS;\r\nwac_info.operand = HSA_DBG_WAVEOP_KILL;\r\npr_debug("Killing all process wavefronts\n");\r\nfor (vmid = first_vmid_to_scan; vmid <= last_vmid_to_scan; vmid++) {\r\nif (dev->kfd2kgd->get_atc_vmid_pasid_mapping_valid\r\n(dev->kgd, vmid)) {\r\nif (dev->kfd2kgd->get_atc_vmid_pasid_mapping_valid\r\n(dev->kgd, vmid) == p->pasid) {\r\npr_debug("Killing wave fronts of vmid %d and pasid %d\n",\r\nvmid, p->pasid);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (vmid > last_vmid_to_scan) {\r\npr_err("amdkfd: didn't found vmid for pasid (%d)\n", p->pasid);\r\nreturn -EFAULT;\r\n}\r\npdd = kfd_get_process_device_data(dev, p);\r\nif (!pdd)\r\nreturn -EFAULT;\r\nstatus = dbgdev_wave_control_set_registers(&wac_info, &reg_sq_cmd,\r\n&reg_gfx_index);\r\nif (status != 0)\r\nreturn -EINVAL;\r\nreg_sq_cmd.bits.vm_id = vmid;\r\ndev->kfd2kgd->wave_control_execute(dev->kgd,\r\nreg_gfx_index.u32All,\r\nreg_sq_cmd.u32All);\r\nreturn 0;\r\n}\r\nvoid kfd_dbgdev_init(struct kfd_dbgdev *pdbgdev, struct kfd_dev *pdev,\r\nenum DBGDEV_TYPE type)\r\n{\r\nBUG_ON(!pdbgdev || !pdev);\r\npdbgdev->dev = pdev;\r\npdbgdev->kq = NULL;\r\npdbgdev->type = type;\r\npdbgdev->pqm = NULL;\r\nswitch (type) {\r\ncase DBGDEV_TYPE_NODIQ:\r\npdbgdev->dbgdev_register = dbgdev_register_nodiq;\r\npdbgdev->dbgdev_unregister = dbgdev_unregister_nodiq;\r\npdbgdev->dbgdev_wave_control = dbgdev_wave_control_nodiq;\r\npdbgdev->dbgdev_address_watch = dbgdev_address_watch_nodiq;\r\nbreak;\r\ncase DBGDEV_TYPE_DIQ:\r\ndefault:\r\npdbgdev->dbgdev_register = dbgdev_register_diq;\r\npdbgdev->dbgdev_unregister = dbgdev_unregister_diq;\r\npdbgdev->dbgdev_wave_control = dbgdev_wave_control_diq;\r\npdbgdev->dbgdev_address_watch = dbgdev_address_watch_diq;\r\nbreak;\r\n}\r\n}
