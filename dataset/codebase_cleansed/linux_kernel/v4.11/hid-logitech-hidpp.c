static int __hidpp_send_report(struct hid_device *hdev,\r\nstruct hidpp_report *hidpp_report)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nint fields_count, ret;\r\nhidpp = hid_get_drvdata(hdev);\r\nswitch (hidpp_report->report_id) {\r\ncase REPORT_ID_HIDPP_SHORT:\r\nfields_count = HIDPP_REPORT_SHORT_LENGTH;\r\nbreak;\r\ncase REPORT_ID_HIDPP_LONG:\r\nfields_count = HIDPP_REPORT_LONG_LENGTH;\r\nbreak;\r\ncase REPORT_ID_HIDPP_VERY_LONG:\r\nfields_count = HIDPP_REPORT_VERY_LONG_LENGTH;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nhidpp_report->device_index = 0xff;\r\nif (hidpp->quirks & HIDPP_QUIRK_FORCE_OUTPUT_REPORTS) {\r\nret = hid_hw_output_report(hdev, (u8 *)hidpp_report, fields_count);\r\n} else {\r\nret = hid_hw_raw_request(hdev, hidpp_report->report_id,\r\n(u8 *)hidpp_report, fields_count, HID_OUTPUT_REPORT,\r\nHID_REQ_SET_REPORT);\r\n}\r\nreturn ret == fields_count ? 0 : -1;\r\n}\r\nstatic int hidpp_send_message_sync(struct hidpp_device *hidpp,\r\nstruct hidpp_report *message,\r\nstruct hidpp_report *response)\r\n{\r\nint ret;\r\nmutex_lock(&hidpp->send_mutex);\r\nhidpp->send_receive_buf = response;\r\nhidpp->answer_available = false;\r\n*response = *message;\r\nret = __hidpp_send_report(hidpp->hid_dev, message);\r\nif (ret) {\r\ndbg_hid("__hidpp_send_report returned err: %d\n", ret);\r\nmemset(response, 0, sizeof(struct hidpp_report));\r\ngoto exit;\r\n}\r\nif (!wait_event_timeout(hidpp->wait, hidpp->answer_available,\r\n5*HZ)) {\r\ndbg_hid("%s:timeout waiting for response\n", __func__);\r\nmemset(response, 0, sizeof(struct hidpp_report));\r\nret = -ETIMEDOUT;\r\n}\r\nif (response->report_id == REPORT_ID_HIDPP_SHORT &&\r\nresponse->rap.sub_id == HIDPP_ERROR) {\r\nret = response->rap.params[1];\r\ndbg_hid("%s:got hidpp error %02X\n", __func__, ret);\r\ngoto exit;\r\n}\r\nif ((response->report_id == REPORT_ID_HIDPP_LONG ||\r\nresponse->report_id == REPORT_ID_HIDPP_VERY_LONG) &&\r\nresponse->fap.feature_index == HIDPP20_ERROR) {\r\nret = response->fap.params[1];\r\ndbg_hid("%s:got hidpp 2.0 error %02X\n", __func__, ret);\r\ngoto exit;\r\n}\r\nexit:\r\nmutex_unlock(&hidpp->send_mutex);\r\nreturn ret;\r\n}\r\nstatic int hidpp_send_fap_command_sync(struct hidpp_device *hidpp,\r\nu8 feat_index, u8 funcindex_clientid, u8 *params, int param_count,\r\nstruct hidpp_report *response)\r\n{\r\nstruct hidpp_report *message;\r\nint ret;\r\nif (param_count > sizeof(message->fap.params))\r\nreturn -EINVAL;\r\nmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\r\nif (!message)\r\nreturn -ENOMEM;\r\nif (param_count > (HIDPP_REPORT_LONG_LENGTH - 4))\r\nmessage->report_id = REPORT_ID_HIDPP_VERY_LONG;\r\nelse\r\nmessage->report_id = REPORT_ID_HIDPP_LONG;\r\nmessage->fap.feature_index = feat_index;\r\nmessage->fap.funcindex_clientid = funcindex_clientid;\r\nmemcpy(&message->fap.params, params, param_count);\r\nret = hidpp_send_message_sync(hidpp, message, response);\r\nkfree(message);\r\nreturn ret;\r\n}\r\nstatic int hidpp_send_rap_command_sync(struct hidpp_device *hidpp_dev,\r\nu8 report_id, u8 sub_id, u8 reg_address, u8 *params, int param_count,\r\nstruct hidpp_report *response)\r\n{\r\nstruct hidpp_report *message;\r\nint ret, max_count;\r\nswitch (report_id) {\r\ncase REPORT_ID_HIDPP_SHORT:\r\nmax_count = HIDPP_REPORT_SHORT_LENGTH - 4;\r\nbreak;\r\ncase REPORT_ID_HIDPP_LONG:\r\nmax_count = HIDPP_REPORT_LONG_LENGTH - 4;\r\nbreak;\r\ncase REPORT_ID_HIDPP_VERY_LONG:\r\nmax_count = HIDPP_REPORT_VERY_LONG_LENGTH - 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (param_count > max_count)\r\nreturn -EINVAL;\r\nmessage = kzalloc(sizeof(struct hidpp_report), GFP_KERNEL);\r\nif (!message)\r\nreturn -ENOMEM;\r\nmessage->report_id = report_id;\r\nmessage->rap.sub_id = sub_id;\r\nmessage->rap.reg_address = reg_address;\r\nmemcpy(&message->rap.params, params, param_count);\r\nret = hidpp_send_message_sync(hidpp_dev, message, response);\r\nkfree(message);\r\nreturn ret;\r\n}\r\nstatic void delayed_work_cb(struct work_struct *work)\r\n{\r\nstruct hidpp_device *hidpp = container_of(work, struct hidpp_device,\r\nwork);\r\nhidpp_connect_event(hidpp);\r\n}\r\nstatic inline bool hidpp_match_answer(struct hidpp_report *question,\r\nstruct hidpp_report *answer)\r\n{\r\nreturn (answer->fap.feature_index == question->fap.feature_index) &&\r\n(answer->fap.funcindex_clientid == question->fap.funcindex_clientid);\r\n}\r\nstatic inline bool hidpp_match_error(struct hidpp_report *question,\r\nstruct hidpp_report *answer)\r\n{\r\nreturn ((answer->rap.sub_id == HIDPP_ERROR) ||\r\n(answer->fap.feature_index == HIDPP20_ERROR)) &&\r\n(answer->fap.funcindex_clientid == question->fap.feature_index) &&\r\n(answer->fap.params[0] == question->fap.funcindex_clientid);\r\n}\r\nstatic inline bool hidpp_report_is_connect_event(struct hidpp_report *report)\r\n{\r\nreturn (report->report_id == REPORT_ID_HIDPP_SHORT) &&\r\n(report->rap.sub_id == 0x41);\r\n}\r\nstatic void hidpp_prefix_name(char **name, int name_length)\r\n{\r\n#define PREFIX_LENGTH 9\r\nint new_length;\r\nchar *new_name;\r\nif (name_length > PREFIX_LENGTH &&\r\nstrncmp(*name, "Logitech ", PREFIX_LENGTH) == 0)\r\nreturn;\r\nnew_length = PREFIX_LENGTH + name_length;\r\nnew_name = kzalloc(new_length, GFP_KERNEL);\r\nif (!new_name)\r\nreturn;\r\nsnprintf(new_name, new_length, "Logitech %s", *name);\r\nkfree(*name);\r\n*name = new_name;\r\n}\r\nstatic char *hidpp_get_unifying_name(struct hidpp_device *hidpp_dev)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 params[1] = { DEVICE_NAME };\r\nchar *name;\r\nint len;\r\nret = hidpp_send_rap_command_sync(hidpp_dev,\r\nREPORT_ID_HIDPP_SHORT,\r\nHIDPP_GET_LONG_REGISTER,\r\nHIDPP_REG_PAIRING_INFORMATION,\r\nparams, 1, &response);\r\nif (ret)\r\nreturn NULL;\r\nlen = response.rap.params[1];\r\nif (2 + len > sizeof(response.rap.params))\r\nreturn NULL;\r\nname = kzalloc(len + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn NULL;\r\nmemcpy(name, &response.rap.params[2], len);\r\nhidpp_prefix_name(&name, len + 1);\r\nreturn name;\r\n}\r\nstatic int hidpp_root_get_feature(struct hidpp_device *hidpp, u16 feature,\r\nu8 *feature_index, u8 *feature_type)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 params[2] = { feature >> 8, feature & 0x00FF };\r\nret = hidpp_send_fap_command_sync(hidpp,\r\nHIDPP_PAGE_ROOT_IDX,\r\nCMD_ROOT_GET_FEATURE,\r\nparams, 2, &response);\r\nif (ret)\r\nreturn ret;\r\n*feature_index = response.fap.params[0];\r\n*feature_type = response.fap.params[1];\r\nreturn ret;\r\n}\r\nstatic int hidpp_root_get_protocol_version(struct hidpp_device *hidpp)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nret = hidpp_send_fap_command_sync(hidpp,\r\nHIDPP_PAGE_ROOT_IDX,\r\nCMD_ROOT_GET_PROTOCOL_VERSION,\r\nNULL, 0, &response);\r\nif (ret == HIDPP_ERROR_INVALID_SUBID) {\r\nhidpp->protocol_major = 1;\r\nhidpp->protocol_minor = 0;\r\nreturn 0;\r\n}\r\nif (ret == HIDPP_ERROR_RESOURCE_ERROR)\r\nreturn -EIO;\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nhidpp->protocol_major = response.fap.params[0];\r\nhidpp->protocol_minor = response.fap.params[1];\r\nreturn ret;\r\n}\r\nstatic bool hidpp_is_connected(struct hidpp_device *hidpp)\r\n{\r\nint ret;\r\nret = hidpp_root_get_protocol_version(hidpp);\r\nif (!ret)\r\nhid_dbg(hidpp->hid_dev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\nreturn ret == 0;\r\n}\r\nstatic int hidpp_devicenametype_get_count(struct hidpp_device *hidpp,\r\nu8 feature_index, u8 *nameLength)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_GET_DEVICE_NAME_TYPE_GET_COUNT, NULL, 0, &response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\n*nameLength = response.fap.params[0];\r\nreturn ret;\r\n}\r\nstatic int hidpp_devicenametype_get_device_name(struct hidpp_device *hidpp,\r\nu8 feature_index, u8 char_index, char *device_name, int len_buf)\r\n{\r\nstruct hidpp_report response;\r\nint ret, i;\r\nint count;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_GET_DEVICE_NAME_TYPE_GET_DEVICE_NAME, &char_index, 1,\r\n&response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nswitch (response.report_id) {\r\ncase REPORT_ID_HIDPP_VERY_LONG:\r\ncount = HIDPP_REPORT_VERY_LONG_LENGTH - 4;\r\nbreak;\r\ncase REPORT_ID_HIDPP_LONG:\r\ncount = HIDPP_REPORT_LONG_LENGTH - 4;\r\nbreak;\r\ncase REPORT_ID_HIDPP_SHORT:\r\ncount = HIDPP_REPORT_SHORT_LENGTH - 4;\r\nbreak;\r\ndefault:\r\nreturn -EPROTO;\r\n}\r\nif (len_buf < count)\r\ncount = len_buf;\r\nfor (i = 0; i < count; i++)\r\ndevice_name[i] = response.fap.params[i];\r\nreturn count;\r\n}\r\nstatic char *hidpp_get_device_name(struct hidpp_device *hidpp)\r\n{\r\nu8 feature_type;\r\nu8 feature_index;\r\nu8 __name_length;\r\nchar *name;\r\nunsigned index = 0;\r\nint ret;\r\nret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_GET_DEVICE_NAME_TYPE,\r\n&feature_index, &feature_type);\r\nif (ret)\r\nreturn NULL;\r\nret = hidpp_devicenametype_get_count(hidpp, feature_index,\r\n&__name_length);\r\nif (ret)\r\nreturn NULL;\r\nname = kzalloc(__name_length + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn NULL;\r\nwhile (index < __name_length) {\r\nret = hidpp_devicenametype_get_device_name(hidpp,\r\nfeature_index, index, name + index,\r\n__name_length - index);\r\nif (ret <= 0) {\r\nkfree(name);\r\nreturn NULL;\r\n}\r\nindex += ret;\r\n}\r\nhidpp_prefix_name(&name, __name_length + 1);\r\nreturn name;\r\n}\r\nstatic int hidpp_touchpad_fw_items_set(struct hidpp_device *hidpp,\r\nu8 feature_index,\r\nstruct hidpp_touchpad_fw_items *items)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 *params = (u8 *)response.fap.params;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_TOUCHPAD_FW_ITEMS_SET, &items->state, 1, &response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nitems->presence = params[0];\r\nitems->desired_state = params[1];\r\nitems->state = params[2];\r\nitems->persistent = params[3];\r\nreturn 0;\r\n}\r\nstatic int hidpp_touchpad_get_raw_info(struct hidpp_device *hidpp,\r\nu8 feature_index, struct hidpp_touchpad_raw_info *raw_info)\r\n{\r\nstruct hidpp_report response;\r\nint ret;\r\nu8 *params = (u8 *)response.fap.params;\r\nret = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nCMD_TOUCHPAD_GET_RAW_INFO, NULL, 0, &response);\r\nif (ret > 0) {\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, ret);\r\nreturn -EPROTO;\r\n}\r\nif (ret)\r\nreturn ret;\r\nraw_info->x_size = get_unaligned_be16(&params[0]);\r\nraw_info->y_size = get_unaligned_be16(&params[2]);\r\nraw_info->z_range = params[4];\r\nraw_info->area_range = params[5];\r\nraw_info->maxcontacts = params[7];\r\nraw_info->origin = params[8];\r\nraw_info->res = get_unaligned_be16(&params[13]) * 2 / 51;\r\nreturn ret;\r\n}\r\nstatic int hidpp_touchpad_set_raw_report_state(struct hidpp_device *hidpp_dev,\r\nu8 feature_index, bool send_raw_reports,\r\nbool sensor_enhanced_settings)\r\n{\r\nstruct hidpp_report response;\r\nu8 params = send_raw_reports | (sensor_enhanced_settings << 2);\r\nreturn hidpp_send_fap_command_sync(hidpp_dev, feature_index,\r\nCMD_TOUCHPAD_SET_RAW_REPORT_STATE, &params, 1, &response);\r\n}\r\nstatic void hidpp_touchpad_touch_event(u8 *data,\r\nstruct hidpp_touchpad_raw_xy_finger *finger)\r\n{\r\nu8 x_m = data[0] << 2;\r\nu8 y_m = data[2] << 2;\r\nfinger->x = x_m << 6 | data[1];\r\nfinger->y = y_m << 6 | data[3];\r\nfinger->contact_type = data[0] >> 6;\r\nfinger->contact_status = data[2] >> 6;\r\nfinger->z = data[4];\r\nfinger->area = data[5];\r\nfinger->finger_id = data[6] >> 4;\r\n}\r\nstatic void hidpp_touchpad_raw_xy_event(struct hidpp_device *hidpp_dev,\r\nu8 *data, struct hidpp_touchpad_raw_xy *raw_xy)\r\n{\r\nmemset(raw_xy, 0, sizeof(struct hidpp_touchpad_raw_xy));\r\nraw_xy->end_of_frame = data[8] & 0x01;\r\nraw_xy->spurious_flag = (data[8] >> 1) & 0x01;\r\nraw_xy->finger_count = data[15] & 0x0f;\r\nraw_xy->button = (data[8] >> 2) & 0x01;\r\nif (raw_xy->finger_count) {\r\nhidpp_touchpad_touch_event(&data[2], &raw_xy->fingers[0]);\r\nhidpp_touchpad_touch_event(&data[9], &raw_xy->fingers[1]);\r\n}\r\n}\r\nstatic u8 hidpp_ff_find_effect(struct hidpp_ff_private_data *data, int effect_id)\r\n{\r\nint i;\r\nfor (i = 0; i < data->num_effects; i++)\r\nif (data->effect_ids[i] == effect_id)\r\nreturn i+1;\r\nreturn 0;\r\n}\r\nstatic void hidpp_ff_work_handler(struct work_struct *w)\r\n{\r\nstruct hidpp_ff_work_data *wd = container_of(w, struct hidpp_ff_work_data, work);\r\nstruct hidpp_ff_private_data *data = wd->data;\r\nstruct hidpp_report response;\r\nu8 slot;\r\nint ret;\r\nswitch (wd->effect_id) {\r\ncase HIDPP_FF_EFFECTID_AUTOCENTER:\r\nwd->params[0] = data->slot_autocenter;\r\nbreak;\r\ncase HIDPP_FF_EFFECTID_NONE:\r\nbreak;\r\ndefault:\r\nwd->params[0] = hidpp_ff_find_effect(data, wd->effect_id);\r\nbreak;\r\n}\r\nret = hidpp_send_fap_command_sync(data->hidpp, data->feature_index,\r\nwd->command, wd->params, wd->size, &response);\r\nif (ret) {\r\nhid_err(data->hidpp->hid_dev, "Failed to send command to device!\n");\r\ngoto out;\r\n}\r\nswitch (wd->command) {\r\ncase HIDPP_FF_DOWNLOAD_EFFECT:\r\nslot = response.fap.params[0];\r\nif (slot > 0 && slot <= data->num_effects) {\r\nif (wd->effect_id >= 0)\r\ndata->effect_ids[slot-1] = wd->effect_id;\r\nelse if (wd->effect_id >= HIDPP_FF_EFFECTID_AUTOCENTER)\r\ndata->slot_autocenter = slot;\r\n}\r\nbreak;\r\ncase HIDPP_FF_DESTROY_EFFECT:\r\nif (wd->effect_id >= 0)\r\ndata->effect_ids[wd->params[0]-1] = -1;\r\nelse if (wd->effect_id >= HIDPP_FF_EFFECTID_AUTOCENTER)\r\ndata->slot_autocenter = 0;\r\nbreak;\r\ncase HIDPP_FF_SET_GLOBAL_GAINS:\r\ndata->gain = (wd->params[0] << 8) + wd->params[1];\r\nbreak;\r\ncase HIDPP_FF_SET_APERTURE:\r\ndata->range = (wd->params[0] << 8) + wd->params[1];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\natomic_dec(&data->workqueue_size);\r\nkfree(wd);\r\n}\r\nstatic int hidpp_ff_queue_work(struct hidpp_ff_private_data *data, int effect_id, u8 command, u8 *params, u8 size)\r\n{\r\nstruct hidpp_ff_work_data *wd = kzalloc(sizeof(*wd), GFP_KERNEL);\r\nint s;\r\nif (!wd)\r\nreturn -ENOMEM;\r\nINIT_WORK(&wd->work, hidpp_ff_work_handler);\r\nwd->data = data;\r\nwd->effect_id = effect_id;\r\nwd->command = command;\r\nwd->size = size;\r\nmemcpy(wd->params, params, size);\r\natomic_inc(&data->workqueue_size);\r\nqueue_work(data->wq, &wd->work);\r\ns = atomic_read(&data->workqueue_size);\r\nif (s >= 20 && s % 20 == 0)\r\nhid_warn(data->hidpp->hid_dev, "Force feedback command queue contains %d commands, causing substantial delays!", s);\r\nreturn 0;\r\n}\r\nstatic int hidpp_ff_upload_effect(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nstruct hidpp_ff_private_data *data = dev->ff->private;\r\nu8 params[20];\r\nu8 size;\r\nint force;\r\nparams[2] = effect->replay.length >> 8;\r\nparams[3] = effect->replay.length & 255;\r\nparams[4] = effect->replay.delay >> 8;\r\nparams[5] = effect->replay.delay & 255;\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nforce = (effect->u.constant.level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\r\nparams[1] = HIDPP_FF_EFFECT_CONSTANT;\r\nparams[6] = force >> 8;\r\nparams[7] = force & 255;\r\nparams[8] = effect->u.constant.envelope.attack_level >> 7;\r\nparams[9] = effect->u.constant.envelope.attack_length >> 8;\r\nparams[10] = effect->u.constant.envelope.attack_length & 255;\r\nparams[11] = effect->u.constant.envelope.fade_level >> 7;\r\nparams[12] = effect->u.constant.envelope.fade_length >> 8;\r\nparams[13] = effect->u.constant.envelope.fade_length & 255;\r\nsize = 14;\r\ndbg_hid("Uploading constant force level=%d in dir %d = %d\n",\r\neffect->u.constant.level,\r\neffect->direction, force);\r\ndbg_hid(" envelope attack=(%d, %d ms) fade=(%d, %d ms)\n",\r\neffect->u.constant.envelope.attack_level,\r\neffect->u.constant.envelope.attack_length,\r\neffect->u.constant.envelope.fade_level,\r\neffect->u.constant.envelope.fade_length);\r\nbreak;\r\ncase FF_PERIODIC:\r\n{\r\nswitch (effect->u.periodic.waveform) {\r\ncase FF_SINE:\r\nparams[1] = HIDPP_FF_EFFECT_PERIODIC_SINE;\r\nbreak;\r\ncase FF_SQUARE:\r\nparams[1] = HIDPP_FF_EFFECT_PERIODIC_SQUARE;\r\nbreak;\r\ncase FF_SAW_UP:\r\nparams[1] = HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHUP;\r\nbreak;\r\ncase FF_SAW_DOWN:\r\nparams[1] = HIDPP_FF_EFFECT_PERIODIC_SAWTOOTHDOWN;\r\nbreak;\r\ncase FF_TRIANGLE:\r\nparams[1] = HIDPP_FF_EFFECT_PERIODIC_TRIANGLE;\r\nbreak;\r\ndefault:\r\nhid_err(data->hidpp->hid_dev, "Unexpected periodic waveform type %i!\n", effect->u.periodic.waveform);\r\nreturn -EINVAL;\r\n}\r\nforce = (effect->u.periodic.magnitude * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\r\nparams[6] = effect->u.periodic.magnitude >> 8;\r\nparams[7] = effect->u.periodic.magnitude & 255;\r\nparams[8] = effect->u.periodic.offset >> 8;\r\nparams[9] = effect->u.periodic.offset & 255;\r\nparams[10] = effect->u.periodic.period >> 8;\r\nparams[11] = effect->u.periodic.period & 255;\r\nparams[12] = effect->u.periodic.phase >> 8;\r\nparams[13] = effect->u.periodic.phase & 255;\r\nparams[14] = effect->u.periodic.envelope.attack_level >> 7;\r\nparams[15] = effect->u.periodic.envelope.attack_length >> 8;\r\nparams[16] = effect->u.periodic.envelope.attack_length & 255;\r\nparams[17] = effect->u.periodic.envelope.fade_level >> 7;\r\nparams[18] = effect->u.periodic.envelope.fade_length >> 8;\r\nparams[19] = effect->u.periodic.envelope.fade_length & 255;\r\nsize = 20;\r\ndbg_hid("Uploading periodic force mag=%d/dir=%d, offset=%d, period=%d ms, phase=%d\n",\r\neffect->u.periodic.magnitude, effect->direction,\r\neffect->u.periodic.offset,\r\neffect->u.periodic.period,\r\neffect->u.periodic.phase);\r\ndbg_hid(" envelope attack=(%d, %d ms) fade=(%d, %d ms)\n",\r\neffect->u.periodic.envelope.attack_level,\r\neffect->u.periodic.envelope.attack_length,\r\neffect->u.periodic.envelope.fade_level,\r\neffect->u.periodic.envelope.fade_length);\r\nbreak;\r\n}\r\ncase FF_RAMP:\r\nparams[1] = HIDPP_FF_EFFECT_RAMP;\r\nforce = (effect->u.ramp.start_level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\r\nparams[6] = force >> 8;\r\nparams[7] = force & 255;\r\nforce = (effect->u.ramp.end_level * fixp_sin16((effect->direction * 360) >> 16)) >> 15;\r\nparams[8] = force >> 8;\r\nparams[9] = force & 255;\r\nparams[10] = effect->u.ramp.envelope.attack_level >> 7;\r\nparams[11] = effect->u.ramp.envelope.attack_length >> 8;\r\nparams[12] = effect->u.ramp.envelope.attack_length & 255;\r\nparams[13] = effect->u.ramp.envelope.fade_level >> 7;\r\nparams[14] = effect->u.ramp.envelope.fade_length >> 8;\r\nparams[15] = effect->u.ramp.envelope.fade_length & 255;\r\nsize = 16;\r\ndbg_hid("Uploading ramp force level=%d -> %d in dir %d = %d\n",\r\neffect->u.ramp.start_level,\r\neffect->u.ramp.end_level,\r\neffect->direction, force);\r\ndbg_hid(" envelope attack=(%d, %d ms) fade=(%d, %d ms)\n",\r\neffect->u.ramp.envelope.attack_level,\r\neffect->u.ramp.envelope.attack_length,\r\neffect->u.ramp.envelope.fade_level,\r\neffect->u.ramp.envelope.fade_length);\r\nbreak;\r\ncase FF_FRICTION:\r\ncase FF_INERTIA:\r\ncase FF_SPRING:\r\ncase FF_DAMPER:\r\nparams[1] = HIDPP_FF_CONDITION_CMDS[effect->type - FF_SPRING];\r\nparams[6] = effect->u.condition[0].left_saturation >> 9;\r\nparams[7] = (effect->u.condition[0].left_saturation >> 1) & 255;\r\nparams[8] = effect->u.condition[0].left_coeff >> 8;\r\nparams[9] = effect->u.condition[0].left_coeff & 255;\r\nparams[10] = effect->u.condition[0].deadband >> 9;\r\nparams[11] = (effect->u.condition[0].deadband >> 1) & 255;\r\nparams[12] = effect->u.condition[0].center >> 8;\r\nparams[13] = effect->u.condition[0].center & 255;\r\nparams[14] = effect->u.condition[0].right_coeff >> 8;\r\nparams[15] = effect->u.condition[0].right_coeff & 255;\r\nparams[16] = effect->u.condition[0].right_saturation >> 9;\r\nparams[17] = (effect->u.condition[0].right_saturation >> 1) & 255;\r\nsize = 18;\r\ndbg_hid("Uploading %s force left coeff=%d, left sat=%d, right coeff=%d, right sat=%d\n",\r\nHIDPP_FF_CONDITION_NAMES[effect->type - FF_SPRING],\r\neffect->u.condition[0].left_coeff,\r\neffect->u.condition[0].left_saturation,\r\neffect->u.condition[0].right_coeff,\r\neffect->u.condition[0].right_saturation);\r\ndbg_hid(" deadband=%d, center=%d\n",\r\neffect->u.condition[0].deadband,\r\neffect->u.condition[0].center);\r\nbreak;\r\ndefault:\r\nhid_err(data->hidpp->hid_dev, "Unexpected force type %i!\n", effect->type);\r\nreturn -EINVAL;\r\n}\r\nreturn hidpp_ff_queue_work(data, effect->id, HIDPP_FF_DOWNLOAD_EFFECT, params, size);\r\n}\r\nstatic int hidpp_ff_playback(struct input_dev *dev, int effect_id, int value)\r\n{\r\nstruct hidpp_ff_private_data *data = dev->ff->private;\r\nu8 params[2];\r\nparams[1] = value ? HIDPP_FF_EFFECT_STATE_PLAY : HIDPP_FF_EFFECT_STATE_STOP;\r\ndbg_hid("St%sing playback of effect %d.\n", value?"art":"opp", effect_id);\r\nreturn hidpp_ff_queue_work(data, effect_id, HIDPP_FF_SET_EFFECT_STATE, params, ARRAY_SIZE(params));\r\n}\r\nstatic int hidpp_ff_erase_effect(struct input_dev *dev, int effect_id)\r\n{\r\nstruct hidpp_ff_private_data *data = dev->ff->private;\r\nu8 slot = 0;\r\ndbg_hid("Erasing effect %d.\n", effect_id);\r\nreturn hidpp_ff_queue_work(data, effect_id, HIDPP_FF_DESTROY_EFFECT, &slot, 1);\r\n}\r\nstatic void hidpp_ff_set_autocenter(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hidpp_ff_private_data *data = dev->ff->private;\r\nu8 params[18];\r\ndbg_hid("Setting autocenter to %d.\n", magnitude);\r\nparams[1] = HIDPP_FF_EFFECT_SPRING | HIDPP_FF_EFFECT_AUTOSTART;\r\nparams[2] = params[3] = params[4] = params[5] = 0;\r\nparams[8] = params[14] = magnitude >> 11;\r\nparams[9] = params[15] = (magnitude >> 3) & 255;\r\nparams[6] = params[16] = magnitude >> 9;\r\nparams[7] = params[17] = (magnitude >> 1) & 255;\r\nparams[10] = params[11] = params[12] = params[13] = 0;\r\nhidpp_ff_queue_work(data, HIDPP_FF_EFFECTID_AUTOCENTER, HIDPP_FF_DOWNLOAD_EFFECT, params, ARRAY_SIZE(params));\r\n}\r\nstatic void hidpp_ff_set_gain(struct input_dev *dev, u16 gain)\r\n{\r\nstruct hidpp_ff_private_data *data = dev->ff->private;\r\nu8 params[4];\r\ndbg_hid("Setting gain to %d.\n", gain);\r\nparams[0] = gain >> 8;\r\nparams[1] = gain & 255;\r\nparams[2] = 0;\r\nparams[3] = 0;\r\nhidpp_ff_queue_work(data, HIDPP_FF_EFFECTID_NONE, HIDPP_FF_SET_GLOBAL_GAINS, params, ARRAY_SIZE(params));\r\n}\r\nstatic ssize_t hidpp_ff_range_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *idev = hidinput->input;\r\nstruct hidpp_ff_private_data *data = idev->ff->private;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", data->range);\r\n}\r\nstatic ssize_t hidpp_ff_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hid = to_hid_device(dev);\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *idev = hidinput->input;\r\nstruct hidpp_ff_private_data *data = idev->ff->private;\r\nu8 params[2];\r\nint range = simple_strtoul(buf, NULL, 10);\r\nrange = clamp(range, 180, 900);\r\nparams[0] = range >> 8;\r\nparams[1] = range & 0x00FF;\r\nhidpp_ff_queue_work(data, -1, HIDPP_FF_SET_APERTURE, params, ARRAY_SIZE(params));\r\nreturn count;\r\n}\r\nstatic void hidpp_ff_destroy(struct ff_device *ff)\r\n{\r\nstruct hidpp_ff_private_data *data = ff->private;\r\nkfree(data->effect_ids);\r\n}\r\nstatic int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)\r\n{\r\nstruct hid_device *hid = hidpp->hid_dev;\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *dev = hidinput->input;\r\nconst struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid)->descriptor);\r\nconst u16 bcdDevice = le16_to_cpu(udesc->bcdDevice);\r\nstruct ff_device *ff;\r\nstruct hidpp_report response;\r\nstruct hidpp_ff_private_data *data;\r\nint error, j, num_slots;\r\nu8 version;\r\nif (!dev) {\r\nhid_err(hid, "Struct input_dev not set!\n");\r\nreturn -EINVAL;\r\n}\r\nversion = bcdDevice & 255;\r\nfor (j = 0; hiddpp_ff_effects[j] >= 0; j++)\r\nset_bit(hiddpp_ff_effects[j], dev->ffbit);\r\nif (version > 1)\r\nfor (j = 0; hiddpp_ff_effects_v2[j] >= 0; j++)\r\nset_bit(hiddpp_ff_effects_v2[j], dev->ffbit);\r\nerror = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nHIDPP_FF_GET_INFO, NULL, 0, &response);\r\nif (error) {\r\nif (error < 0)\r\nreturn error;\r\nhid_err(hidpp->hid_dev, "%s: received protocol error 0x%02x\n",\r\n__func__, error);\r\nreturn -EPROTO;\r\n}\r\nnum_slots = response.fap.params[0] - HIDPP_FF_RESERVED_SLOTS;\r\nerror = input_ff_create(dev, num_slots);\r\nif (error) {\r\nhid_err(dev, "Failed to create FF device!\n");\r\nreturn error;\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->effect_ids = kcalloc(num_slots, sizeof(int), GFP_KERNEL);\r\nif (!data->effect_ids) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\ndata->hidpp = hidpp;\r\ndata->feature_index = feature_index;\r\ndata->version = version;\r\ndata->slot_autocenter = 0;\r\ndata->num_effects = num_slots;\r\nfor (j = 0; j < num_slots; j++)\r\ndata->effect_ids[j] = -1;\r\nff = dev->ff;\r\nff->private = data;\r\nff->upload = hidpp_ff_upload_effect;\r\nff->erase = hidpp_ff_erase_effect;\r\nff->playback = hidpp_ff_playback;\r\nff->set_gain = hidpp_ff_set_gain;\r\nff->set_autocenter = hidpp_ff_set_autocenter;\r\nff->destroy = hidpp_ff_destroy;\r\nerror = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nHIDPP_FF_RESET_ALL, NULL, 0, &response);\r\nerror = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nHIDPP_FF_GET_APERTURE, NULL, 0, &response);\r\nif (error)\r\nhid_warn(hidpp->hid_dev, "Failed to read range from device!\n");\r\ndata->range = error ? 900 : get_unaligned_be16(&response.fap.params[0]);\r\nerror = device_create_file(&(hidpp->hid_dev->dev), &dev_attr_range);\r\nif (error)\r\nhid_warn(hidpp->hid_dev, "Unable to create sysfs interface for \"range\", errno %d!\n", error);\r\nerror = hidpp_send_fap_command_sync(hidpp, feature_index,\r\nHIDPP_FF_GET_GLOBAL_GAINS, NULL, 0, &response);\r\nif (error)\r\nhid_warn(hidpp->hid_dev, "Failed to read gain values from device!\n");\r\ndata->gain = error ? 0xffff : get_unaligned_be16(&response.fap.params[0]);\r\ndata->wq = create_singlethread_workqueue("hidpp-ff-sendqueue");\r\natomic_set(&data->workqueue_size, 0);\r\nhidpp_ff_set_autocenter(dev, 0);\r\nhid_info(hid, "Force feeback support loaded (firmware release %d).\n", version);\r\nreturn 0;\r\n}\r\nstatic int hidpp_ff_deinit(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct input_dev *dev = hidinput->input;\r\nstruct hidpp_ff_private_data *data;\r\nif (!dev) {\r\nhid_err(hid, "Struct input_dev not found!\n");\r\nreturn -EINVAL;\r\n}\r\nhid_info(hid, "Unloading HID++ force feedback.\n");\r\ndata = dev->ff->private;\r\nif (!data) {\r\nhid_err(hid, "Private data not found!\n");\r\nreturn -EINVAL;\r\n}\r\ndestroy_workqueue(data->wq);\r\ndevice_remove_file(&hid->dev, &dev_attr_range);\r\nreturn 0;\r\n}\r\nstatic int wtp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nreturn -1;\r\n}\r\nstatic void wtp_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input_dev, bool origin_is_hid_core)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__clear_bit(EV_REL, input_dev->evbit);\r\n__clear_bit(EV_LED, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, wd->x_size, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_X, wd->resolution);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, wd->y_size, 0, 0);\r\ninput_abs_set_res(input_dev, ABS_MT_POSITION_Y, wd->resolution);\r\ninput_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, 50, 0, 0);\r\ninput_set_capability(input_dev, EV_KEY, BTN_LEFT);\r\nif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS)\r\ninput_set_capability(input_dev, EV_KEY, BTN_RIGHT);\r\nelse\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\ninput_mt_init_slots(input_dev, wd->maxcontacts, INPUT_MT_POINTER |\r\nINPUT_MT_DROP_UNUSED);\r\nwd->input = input_dev;\r\n}\r\nstatic void wtp_touch_event(struct wtp_data *wd,\r\nstruct hidpp_touchpad_raw_xy_finger *touch_report)\r\n{\r\nint slot;\r\nif (!touch_report->finger_id || touch_report->contact_type)\r\nreturn;\r\nslot = input_mt_get_slot_by_key(wd->input, touch_report->finger_id);\r\ninput_mt_slot(wd->input, slot);\r\ninput_mt_report_slot_state(wd->input, MT_TOOL_FINGER,\r\ntouch_report->contact_status);\r\nif (touch_report->contact_status) {\r\ninput_event(wd->input, EV_ABS, ABS_MT_POSITION_X,\r\ntouch_report->x);\r\ninput_event(wd->input, EV_ABS, ABS_MT_POSITION_Y,\r\nwd->flip_y ? wd->y_size - touch_report->y :\r\ntouch_report->y);\r\ninput_event(wd->input, EV_ABS, ABS_MT_PRESSURE,\r\ntouch_report->area);\r\n}\r\n}\r\nstatic void wtp_send_raw_xy_event(struct hidpp_device *hidpp,\r\nstruct hidpp_touchpad_raw_xy *raw)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nwtp_touch_event(wd, &(raw->fingers[i]));\r\nif (raw->end_of_frame &&\r\n!(hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS))\r\ninput_event(wd->input, EV_KEY, BTN_LEFT, raw->button);\r\nif (raw->end_of_frame || raw->finger_count <= 2) {\r\ninput_mt_sync_frame(wd->input);\r\ninput_sync(wd->input);\r\n}\r\n}\r\nstatic int wtp_mouse_raw_xy_event(struct hidpp_device *hidpp, u8 *data)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nu8 c1_area = ((data[7] & 0xf) * (data[7] & 0xf) +\r\n(data[7] >> 4) * (data[7] >> 4)) / 2;\r\nu8 c2_area = ((data[13] & 0xf) * (data[13] & 0xf) +\r\n(data[13] >> 4) * (data[13] >> 4)) / 2;\r\nstruct hidpp_touchpad_raw_xy raw = {\r\n.timestamp = data[1],\r\n.fingers = {\r\n{\r\n.contact_type = 0,\r\n.contact_status = !!data[7],\r\n.x = get_unaligned_le16(&data[3]),\r\n.y = get_unaligned_le16(&data[5]),\r\n.z = c1_area,\r\n.area = c1_area,\r\n.finger_id = data[2],\r\n}, {\r\n.contact_type = 0,\r\n.contact_status = !!data[13],\r\n.x = get_unaligned_le16(&data[9]),\r\n.y = get_unaligned_le16(&data[11]),\r\n.z = c2_area,\r\n.area = c2_area,\r\n.finger_id = data[8],\r\n}\r\n},\r\n.finger_count = wd->maxcontacts,\r\n.spurious_flag = 0,\r\n.end_of_frame = (data[0] >> 7) == 0,\r\n.button = data[0] & 0x01,\r\n};\r\nwtp_send_raw_xy_event(hidpp, &raw);\r\nreturn 1;\r\n}\r\nstatic int wtp_raw_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd = hidpp->private_data;\r\nstruct hidpp_report *report = (struct hidpp_report *)data;\r\nstruct hidpp_touchpad_raw_xy raw;\r\nif (!wd || !wd->input)\r\nreturn 1;\r\nswitch (data[0]) {\r\ncase 0x02:\r\nif (size < 2) {\r\nhid_err(hdev, "Received HID report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS) {\r\ninput_event(wd->input, EV_KEY, BTN_LEFT,\r\n!!(data[1] & 0x01));\r\ninput_event(wd->input, EV_KEY, BTN_RIGHT,\r\n!!(data[1] & 0x02));\r\ninput_sync(wd->input);\r\nreturn 0;\r\n} else {\r\nif (size < 21)\r\nreturn 1;\r\nreturn wtp_mouse_raw_xy_event(hidpp, &data[7]);\r\n}\r\ncase REPORT_ID_HIDPP_LONG:\r\nif ((report->fap.feature_index != wd->mt_feature_index) ||\r\n(report->fap.funcindex_clientid != EVENT_TOUCHPAD_RAW_XY))\r\nreturn 1;\r\nhidpp_touchpad_raw_xy_event(hidpp, data + 4, &raw);\r\nwtp_send_raw_xy_event(hidpp, &raw);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wtp_get_config(struct hidpp_device *hidpp)\r\n{\r\nstruct wtp_data *wd = hidpp->private_data;\r\nstruct hidpp_touchpad_raw_info raw_info = {0};\r\nu8 feature_type;\r\nint ret;\r\nret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_TOUCHPAD_RAW_XY,\r\n&wd->mt_feature_index, &feature_type);\r\nif (ret)\r\nreturn ret;\r\nret = hidpp_touchpad_get_raw_info(hidpp, wd->mt_feature_index,\r\n&raw_info);\r\nif (ret)\r\nreturn ret;\r\nwd->x_size = raw_info.x_size;\r\nwd->y_size = raw_info.y_size;\r\nwd->maxcontacts = raw_info.maxcontacts;\r\nwd->flip_y = raw_info.origin == TOUCHPAD_RAW_XY_ORIGIN_LOWER_LEFT;\r\nwd->resolution = raw_info.res;\r\nif (!wd->resolution)\r\nwd->resolution = WTP_MANUAL_RESOLUTION;\r\nreturn 0;\r\n}\r\nstatic int wtp_allocate(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd;\r\nwd = devm_kzalloc(&hdev->dev, sizeof(struct wtp_data),\r\nGFP_KERNEL);\r\nif (!wd)\r\nreturn -ENOMEM;\r\nhidpp->private_data = wd;\r\nreturn 0;\r\n}\r\nstatic int wtp_connect(struct hid_device *hdev, bool connected)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct wtp_data *wd = hidpp->private_data;\r\nint ret;\r\nif (!connected)\r\nreturn 0;\r\nif (!wd->x_size) {\r\nret = wtp_get_config(hidpp);\r\nif (ret) {\r\nhid_err(hdev, "Can not get wtp config: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn hidpp_touchpad_set_raw_report_state(hidpp, wd->mt_feature_index,\r\ntrue, true);\r\n}\r\nstatic int m560_send_config_command(struct hid_device *hdev, bool connected)\r\n{\r\nstruct hidpp_report response;\r\nstruct hidpp_device *hidpp_dev;\r\nhidpp_dev = hid_get_drvdata(hdev);\r\nif (!connected)\r\nreturn -ENODEV;\r\nreturn hidpp_send_rap_command_sync(\r\nhidpp_dev,\r\nREPORT_ID_HIDPP_SHORT,\r\nM560_SUB_ID,\r\nM560_BUTTON_MODE_REGISTER,\r\n(u8 *)m560_config_parameter,\r\nsizeof(m560_config_parameter),\r\n&response\r\n);\r\n}\r\nstatic int m560_allocate(struct hid_device *hdev)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct m560_private_data *d;\r\nd = devm_kzalloc(&hdev->dev, sizeof(struct m560_private_data),\r\nGFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nhidpp->private_data = d;\r\nreturn 0;\r\n}\r\nstatic int m560_raw_event(struct hid_device *hdev, u8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct m560_private_data *mydata = hidpp->private_data;\r\nif (!mydata || !mydata->input) {\r\nhid_err(hdev, "error in parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (size < 7) {\r\nhid_err(hdev, "error in report\n");\r\nreturn 0;\r\n}\r\nif (data[0] == REPORT_ID_HIDPP_LONG &&\r\ndata[2] == M560_SUB_ID && data[6] == 0x00) {\r\nswitch (data[5]) {\r\ncase 0xaf:\r\ninput_report_key(mydata->input, BTN_MIDDLE, 1);\r\nbreak;\r\ncase 0xb0:\r\ninput_report_key(mydata->input, BTN_FORWARD, 1);\r\nbreak;\r\ncase 0xae:\r\ninput_report_key(mydata->input, BTN_BACK, 1);\r\nbreak;\r\ncase 0x00:\r\ninput_report_key(mydata->input, BTN_BACK, 0);\r\ninput_report_key(mydata->input, BTN_FORWARD, 0);\r\ninput_report_key(mydata->input, BTN_MIDDLE, 0);\r\nbreak;\r\ndefault:\r\nhid_err(hdev, "error in report\n");\r\nreturn 0;\r\n}\r\ninput_sync(mydata->input);\r\n} else if (data[0] == 0x02) {\r\nint v;\r\ninput_report_key(mydata->input, BTN_LEFT,\r\n!!(data[1] & M560_MOUSE_BTN_LEFT));\r\ninput_report_key(mydata->input, BTN_RIGHT,\r\n!!(data[1] & M560_MOUSE_BTN_RIGHT));\r\nif (data[1] & M560_MOUSE_BTN_WHEEL_LEFT)\r\ninput_report_rel(mydata->input, REL_HWHEEL, -1);\r\nelse if (data[1] & M560_MOUSE_BTN_WHEEL_RIGHT)\r\ninput_report_rel(mydata->input, REL_HWHEEL, 1);\r\nv = hid_snto32(hid_field_extract(hdev, data+3, 0, 12), 12);\r\ninput_report_rel(mydata->input, REL_X, v);\r\nv = hid_snto32(hid_field_extract(hdev, data+3, 12, 12), 12);\r\ninput_report_rel(mydata->input, REL_Y, v);\r\nv = hid_snto32(data[6], 8);\r\ninput_report_rel(mydata->input, REL_WHEEL, v);\r\ninput_sync(mydata->input);\r\n}\r\nreturn 1;\r\n}\r\nstatic void m560_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input_dev, bool origin_is_hid_core)\r\n{\r\nstruct m560_private_data *mydata = hidpp->private_data;\r\nmydata->input = input_dev;\r\n__set_bit(EV_KEY, mydata->input->evbit);\r\n__set_bit(BTN_MIDDLE, mydata->input->keybit);\r\n__set_bit(BTN_RIGHT, mydata->input->keybit);\r\n__set_bit(BTN_LEFT, mydata->input->keybit);\r\n__set_bit(BTN_BACK, mydata->input->keybit);\r\n__set_bit(BTN_FORWARD, mydata->input->keybit);\r\n__set_bit(EV_REL, mydata->input->evbit);\r\n__set_bit(REL_X, mydata->input->relbit);\r\n__set_bit(REL_Y, mydata->input->relbit);\r\n__set_bit(REL_WHEEL, mydata->input->relbit);\r\n__set_bit(REL_HWHEEL, mydata->input->relbit);\r\n}\r\nstatic int m560_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nreturn -1;\r\n}\r\nstatic int k400_disable_tap_to_click(struct hidpp_device *hidpp)\r\n{\r\nstruct k400_private_data *k400 = hidpp->private_data;\r\nstruct hidpp_touchpad_fw_items items = {};\r\nint ret;\r\nu8 feature_type;\r\nif (!k400->feature_index) {\r\nret = hidpp_root_get_feature(hidpp,\r\nHIDPP_PAGE_TOUCHPAD_FW_ITEMS,\r\n&k400->feature_index, &feature_type);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = hidpp_touchpad_fw_items_set(hidpp, k400->feature_index, &items);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int k400_allocate(struct hid_device *hdev)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct k400_private_data *k400;\r\nk400 = devm_kzalloc(&hdev->dev, sizeof(struct k400_private_data),\r\nGFP_KERNEL);\r\nif (!k400)\r\nreturn -ENOMEM;\r\nhidpp->private_data = k400;\r\nreturn 0;\r\n}\r\nstatic int k400_connect(struct hid_device *hdev, bool connected)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (!connected)\r\nreturn 0;\r\nif (!disable_tap_to_click)\r\nreturn 0;\r\nreturn k400_disable_tap_to_click(hidpp);\r\n}\r\nstatic int g920_get_config(struct hidpp_device *hidpp)\r\n{\r\nu8 feature_type;\r\nu8 feature_index;\r\nint ret;\r\nret = hidpp_root_get_feature(hidpp, HIDPP_PAGE_G920_FORCE_FEEDBACK,\r\n&feature_index, &feature_type);\r\nif (ret)\r\nreturn ret;\r\nret = hidpp_ff_init(hidpp, feature_index);\r\nif (ret)\r\nhid_warn(hidpp->hid_dev, "Unable to initialize force feedback support, errno %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nstatic int hidpp_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nreturn wtp_input_mapping(hdev, hi, field, usage, bit, max);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560 &&\r\nfield->application != HID_GD_MOUSE)\r\nreturn m560_input_mapping(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic int hidpp_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\r\nif (usage->type == EV_ABS && (usage->code == ABS_X ||\r\nusage->code == ABS_Y || usage->code == ABS_Z ||\r\nusage->code == ABS_RZ)) {\r\nfield->application = HID_GD_MULTIAXIS;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hidpp_populate_input(struct hidpp_device *hidpp,\r\nstruct input_dev *input, bool origin_is_hid_core)\r\n{\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nwtp_populate_input(hidpp, input, origin_is_hid_core);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\r\nm560_populate_input(hidpp, input, origin_is_hid_core);\r\n}\r\nstatic int hidpp_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nstruct input_dev *input = hidinput->input;\r\nhidpp_populate_input(hidpp, input, true);\r\nreturn 0;\r\n}\r\nstatic int hidpp_raw_hidpp_event(struct hidpp_device *hidpp, u8 *data,\r\nint size)\r\n{\r\nstruct hidpp_report *question = hidpp->send_receive_buf;\r\nstruct hidpp_report *answer = hidpp->send_receive_buf;\r\nstruct hidpp_report *report = (struct hidpp_report *)data;\r\nif (unlikely(mutex_is_locked(&hidpp->send_mutex))) {\r\nif (hidpp_match_answer(question, report) ||\r\nhidpp_match_error(question, report)) {\r\n*answer = *report;\r\nhidpp->answer_available = true;\r\nwake_up(&hidpp->wait);\r\nreturn 1;\r\n}\r\n}\r\nif (unlikely(hidpp_report_is_connect_event(report))) {\r\natomic_set(&hidpp->connected,\r\n!(report->rap.params[0] & (1 << 6)));\r\nif ((hidpp->quirks & HIDPP_QUIRK_CONNECT_EVENTS) &&\r\n(schedule_work(&hidpp->work) == 0))\r\ndbg_hid("%s: connect event already queued\n", __func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hidpp_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nint ret = 0;\r\nswitch (data[0]) {\r\ncase REPORT_ID_HIDPP_VERY_LONG:\r\nif (size != HIDPP_REPORT_VERY_LONG_LENGTH) {\r\nhid_err(hdev, "received hid++ report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nret = hidpp_raw_hidpp_event(hidpp, data, size);\r\nbreak;\r\ncase REPORT_ID_HIDPP_LONG:\r\nif (size != HIDPP_REPORT_LONG_LENGTH) {\r\nhid_err(hdev, "received hid++ report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nret = hidpp_raw_hidpp_event(hidpp, data, size);\r\nbreak;\r\ncase REPORT_ID_HIDPP_SHORT:\r\nif (size != HIDPP_REPORT_SHORT_LENGTH) {\r\nhid_err(hdev, "received hid++ report of bad size (%d)",\r\nsize);\r\nreturn 1;\r\n}\r\nret = hidpp_raw_hidpp_event(hidpp, data, size);\r\nbreak;\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)\r\nreturn wtp_raw_event(hdev, data, size);\r\nelse if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560)\r\nreturn m560_raw_event(hdev, data, size);\r\nreturn 0;\r\n}\r\nstatic void hidpp_overwrite_name(struct hid_device *hdev, bool use_unifying)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nchar *name;\r\nif (use_unifying)\r\nname = hidpp_get_unifying_name(hidpp);\r\nelse\r\nname = hidpp_get_device_name(hidpp);\r\nif (!name) {\r\nhid_err(hdev, "unable to retrieve the name of the device");\r\n} else {\r\ndbg_hid("HID++: Got name: %s\n", name);\r\nsnprintf(hdev->name, sizeof(hdev->name), "%s", name);\r\n}\r\nkfree(name);\r\n}\r\nstatic int hidpp_input_open(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nreturn hid_hw_open(hid);\r\n}\r\nstatic void hidpp_input_close(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nhid_hw_close(hid);\r\n}\r\nstatic struct input_dev *hidpp_allocate_input(struct hid_device *hdev)\r\n{\r\nstruct input_dev *input_dev = devm_input_allocate_device(&hdev->dev);\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (!input_dev)\r\nreturn NULL;\r\ninput_set_drvdata(input_dev, hdev);\r\ninput_dev->open = hidpp_input_open;\r\ninput_dev->close = hidpp_input_close;\r\ninput_dev->name = hidpp->name;\r\ninput_dev->phys = hdev->phys;\r\ninput_dev->uniq = hdev->uniq;\r\ninput_dev->id.bustype = hdev->bus;\r\ninput_dev->id.vendor = hdev->vendor;\r\ninput_dev->id.product = hdev->product;\r\ninput_dev->id.version = hdev->version;\r\ninput_dev->dev.parent = &hdev->dev;\r\nreturn input_dev;\r\n}\r\nstatic void hidpp_connect_event(struct hidpp_device *hidpp)\r\n{\r\nstruct hid_device *hdev = hidpp->hid_dev;\r\nint ret = 0;\r\nbool connected = atomic_read(&hidpp->connected);\r\nstruct input_dev *input;\r\nchar *name, *devm_name;\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\r\nret = wtp_connect(hdev, connected);\r\nif (ret)\r\nreturn;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560) {\r\nret = m560_send_config_command(hdev, connected);\r\nif (ret)\r\nreturn;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_K400) {\r\nret = k400_connect(hdev, connected);\r\nif (ret)\r\nreturn;\r\n}\r\nif (!connected || hidpp->delayed_input)\r\nreturn;\r\nif (!hidpp->protocol_major) {\r\nret = !hidpp_is_connected(hidpp);\r\nif (ret) {\r\nhid_err(hdev, "Can not get the protocol version.\n");\r\nreturn;\r\n}\r\nhid_info(hdev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\n}\r\nif (!(hidpp->quirks & HIDPP_QUIRK_NO_HIDINPUT))\r\nreturn;\r\nif (!hidpp->name || hidpp->name == hdev->name) {\r\nname = hidpp_get_device_name(hidpp);\r\nif (!name) {\r\nhid_err(hdev,\r\n"unable to retrieve the name of the device");\r\nreturn;\r\n}\r\ndevm_name = devm_kasprintf(&hdev->dev, GFP_KERNEL, "%s", name);\r\nkfree(name);\r\nif (!devm_name)\r\nreturn;\r\nhidpp->name = devm_name;\r\n}\r\ninput = hidpp_allocate_input(hdev);\r\nif (!input) {\r\nhid_err(hdev, "cannot allocate new input device: %d\n", ret);\r\nreturn;\r\n}\r\nhidpp_populate_input(hidpp, input, false);\r\nret = input_register_device(input);\r\nif (ret)\r\ninput_free_device(input);\r\nhidpp->delayed_input = input;\r\n}\r\nstatic int hidpp_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct hidpp_device *hidpp;\r\nint ret;\r\nbool connected;\r\nunsigned int connect_mask = HID_CONNECT_DEFAULT;\r\nhidpp = devm_kzalloc(&hdev->dev, sizeof(struct hidpp_device),\r\nGFP_KERNEL);\r\nif (!hidpp)\r\nreturn -ENOMEM;\r\nhidpp->hid_dev = hdev;\r\nhidpp->name = hdev->name;\r\nhid_set_drvdata(hdev, hidpp);\r\nhidpp->quirks = id->driver_data;\r\nif (disable_raw_mode) {\r\nhidpp->quirks &= ~HIDPP_QUIRK_CLASS_WTP;\r\nhidpp->quirks &= ~HIDPP_QUIRK_CONNECT_EVENTS;\r\nhidpp->quirks &= ~HIDPP_QUIRK_NO_HIDINPUT;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP) {\r\nret = wtp_allocate(hdev, id);\r\nif (ret)\r\ngoto allocate_fail;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_M560) {\r\nret = m560_allocate(hdev);\r\nif (ret)\r\ngoto allocate_fail;\r\n} else if (hidpp->quirks & HIDPP_QUIRK_CLASS_K400) {\r\nret = k400_allocate(hdev);\r\nif (ret)\r\ngoto allocate_fail;\r\n}\r\nINIT_WORK(&hidpp->work, delayed_work_cb);\r\nmutex_init(&hidpp->send_mutex);\r\ninit_waitqueue_head(&hidpp->wait);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "%s:parse failed\n", __func__);\r\ngoto hid_parse_fail;\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_NO_HIDINPUT)\r\nconnect_mask &= ~HID_CONNECT_HIDINPUT;\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto hid_hw_start_fail;\r\n}\r\nret = hid_hw_open(hdev);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "%s:hid_hw_open returned error:%d\n",\r\n__func__, ret);\r\nhid_hw_stop(hdev);\r\ngoto hid_hw_start_fail;\r\n}\r\n}\r\nhid_device_io_start(hdev);\r\nconnected = hidpp_is_connected(hidpp);\r\nif (id->group != HID_GROUP_LOGITECH_DJ_DEVICE) {\r\nif (!connected) {\r\nret = -ENODEV;\r\nhid_err(hdev, "Device not connected");\r\ngoto hid_hw_open_failed;\r\n}\r\nhid_info(hdev, "HID++ %u.%u device connected.\n",\r\nhidpp->protocol_major, hidpp->protocol_minor);\r\n}\r\nhidpp_overwrite_name(hdev, id->group == HID_GROUP_LOGITECH_DJ_DEVICE);\r\natomic_set(&hidpp->connected, connected);\r\nif (connected && (hidpp->quirks & HIDPP_QUIRK_CLASS_WTP)) {\r\nret = wtp_get_config(hidpp);\r\nif (ret)\r\ngoto hid_hw_open_failed;\r\n} else if (connected && (hidpp->quirks & HIDPP_QUIRK_CLASS_G920)) {\r\nret = g920_get_config(hidpp);\r\nif (ret)\r\ngoto hid_hw_open_failed;\r\n}\r\nhid_device_io_stop(hdev);\r\nif (!(hidpp->quirks & HIDPP_QUIRK_CLASS_G920)) {\r\nret = hid_hw_start(hdev, connect_mask);\r\nif (ret) {\r\nhid_err(hdev, "%s:hid_hw_start returned error\n", __func__);\r\ngoto hid_hw_start_fail;\r\n}\r\n}\r\nif (hidpp->quirks & HIDPP_QUIRK_CONNECT_EVENTS) {\r\nhid_device_io_start(hdev);\r\nhidpp_connect_event(hidpp);\r\n}\r\nreturn ret;\r\nhid_hw_open_failed:\r\nhid_device_io_stop(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\n}\r\nhid_hw_start_fail:\r\nhid_parse_fail:\r\ncancel_work_sync(&hidpp->work);\r\nmutex_destroy(&hidpp->send_mutex);\r\nallocate_fail:\r\nhid_set_drvdata(hdev, NULL);\r\nreturn ret;\r\n}\r\nstatic void hidpp_remove(struct hid_device *hdev)\r\n{\r\nstruct hidpp_device *hidpp = hid_get_drvdata(hdev);\r\nif (hidpp->quirks & HIDPP_QUIRK_CLASS_G920) {\r\nhidpp_ff_deinit(hdev);\r\nhid_hw_close(hdev);\r\n}\r\nhid_hw_stop(hdev);\r\ncancel_work_sync(&hidpp->work);\r\nmutex_destroy(&hidpp->send_mutex);\r\n}
