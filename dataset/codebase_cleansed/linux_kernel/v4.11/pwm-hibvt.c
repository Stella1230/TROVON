static inline struct hibvt_pwm_chip *to_hibvt_pwm_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct hibvt_pwm_chip, chip);\r\n}\r\nstatic void hibvt_pwm_set_bits(void __iomem *base, u32 offset,\r\nu32 mask, u32 data)\r\n{\r\nvoid __iomem *address = base + offset;\r\nu32 value;\r\nvalue = readl(address);\r\nvalue &= ~mask;\r\nvalue |= (data & mask);\r\nwritel(value, address);\r\n}\r\nstatic void hibvt_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\r\nPWM_ENABLE_MASK, 0x1);\r\n}\r\nstatic void hibvt_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\r\nPWM_ENABLE_MASK, 0x0);\r\n}\r\nstatic void hibvt_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_cycle_ns, int period_ns)\r\n{\r\nstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\r\nu32 freq, period, duty;\r\nfreq = div_u64(clk_get_rate(hi_pwm_chip->clk), 1000000);\r\nperiod = div_u64(freq * period_ns, 1000);\r\nduty = div_u64(period * duty_cycle_ns, period_ns);\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CFG0_ADDR(pwm->hwpwm),\r\nPWM_PERIOD_MASK, period);\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CFG1_ADDR(pwm->hwpwm),\r\nPWM_DUTY_MASK, duty);\r\n}\r\nstatic void hibvt_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\r\nif (polarity == PWM_POLARITY_INVERSED)\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\r\nPWM_POLARITY_MASK, (0x1 << PWM_POLARITY_SHIFT));\r\nelse\r\nhibvt_pwm_set_bits(hi_pwm_chip->base, PWM_CTRL_ADDR(pwm->hwpwm),\r\nPWM_POLARITY_MASK, (0x0 << PWM_POLARITY_SHIFT));\r\n}\r\nstatic void hibvt_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct hibvt_pwm_chip *hi_pwm_chip = to_hibvt_pwm_chip(chip);\r\nvoid __iomem *base;\r\nu32 freq, value;\r\nfreq = div_u64(clk_get_rate(hi_pwm_chip->clk), 1000000);\r\nbase = hi_pwm_chip->base;\r\nvalue = readl(base + PWM_CFG0_ADDR(pwm->hwpwm));\r\nstate->period = div_u64(value * 1000, freq);\r\nvalue = readl(base + PWM_CFG1_ADDR(pwm->hwpwm));\r\nstate->duty_cycle = div_u64(value * 1000, freq);\r\nvalue = readl(base + PWM_CTRL_ADDR(pwm->hwpwm));\r\nstate->enabled = (PWM_ENABLE_MASK & value);\r\n}\r\nstatic int hibvt_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nif (state->polarity != pwm->state.polarity)\r\nhibvt_pwm_set_polarity(chip, pwm, state->polarity);\r\nif (state->period != pwm->state.period ||\r\nstate->duty_cycle != pwm->state.duty_cycle)\r\nhibvt_pwm_config(chip, pwm, state->duty_cycle, state->period);\r\nif (state->enabled != pwm->state.enabled) {\r\nif (state->enabled)\r\nhibvt_pwm_enable(chip, pwm);\r\nelse\r\nhibvt_pwm_disable(chip, pwm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hibvt_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct hibvt_pwm_soc *soc =\r\nof_device_get_match_data(&pdev->dev);\r\nstruct hibvt_pwm_chip *pwm_chip;\r\nstruct resource *res;\r\nint ret;\r\nint i;\r\npwm_chip = devm_kzalloc(&pdev->dev, sizeof(*pwm_chip), GFP_KERNEL);\r\nif (pwm_chip == NULL)\r\nreturn -ENOMEM;\r\npwm_chip->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pwm_chip->clk)) {\r\ndev_err(&pdev->dev, "getting clock failed with %ld\n",\r\nPTR_ERR(pwm_chip->clk));\r\nreturn PTR_ERR(pwm_chip->clk);\r\n}\r\npwm_chip->chip.ops = &hibvt_pwm_ops;\r\npwm_chip->chip.dev = &pdev->dev;\r\npwm_chip->chip.base = -1;\r\npwm_chip->chip.npwm = soc->num_pwms;\r\npwm_chip->chip.of_xlate = of_pwm_xlate_with_flags;\r\npwm_chip->chip.of_pwm_n_cells = 3;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npwm_chip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pwm_chip->base))\r\nreturn PTR_ERR(pwm_chip->base);\r\nret = clk_prepare_enable(pwm_chip->clk);\r\nif (ret < 0)\r\nreturn ret;\r\npwm_chip->rstc = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(pwm_chip->rstc)) {\r\nclk_disable_unprepare(pwm_chip->clk);\r\nreturn PTR_ERR(pwm_chip->rstc);\r\n}\r\nreset_control_assert(pwm_chip->rstc);\r\nmsleep(30);\r\nreset_control_deassert(pwm_chip->rstc);\r\nret = pwmchip_add(&pwm_chip->chip);\r\nif (ret < 0) {\r\nclk_disable_unprepare(pwm_chip->clk);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < pwm_chip->chip.npwm; i++) {\r\nhibvt_pwm_set_bits(pwm_chip->base, PWM_CTRL_ADDR(i),\r\nPWM_KEEP_MASK, (0x1 << PWM_KEEP_SHIFT));\r\n}\r\nplatform_set_drvdata(pdev, pwm_chip);\r\nreturn 0;\r\n}\r\nstatic int hibvt_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct hibvt_pwm_chip *pwm_chip;\r\npwm_chip = platform_get_drvdata(pdev);\r\nreset_control_assert(pwm_chip->rstc);\r\nmsleep(30);\r\nreset_control_deassert(pwm_chip->rstc);\r\nclk_disable_unprepare(pwm_chip->clk);\r\nreturn pwmchip_remove(&pwm_chip->chip);\r\n}
