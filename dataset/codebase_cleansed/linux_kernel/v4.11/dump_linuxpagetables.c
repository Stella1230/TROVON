static void dump_flag_info(struct pg_state *st, const struct flag_info\r\n*flag, u64 pte, int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i++, flag++) {\r\nconst char *s = NULL;\r\nu64 val;\r\nif (flag->mask == 0)\r\ncontinue;\r\nif (flag->is_val) {\r\nval = pte & flag->val;\r\nif (flag->shift)\r\nval = val >> flag->shift;\r\nseq_printf(st->seq, " %s:%llx", flag->set, val);\r\n} else {\r\nif ((pte & flag->mask) == flag->val)\r\ns = flag->set;\r\nelse\r\ns = flag->clear;\r\nif (s)\r\nseq_printf(st->seq, " %s", s);\r\n}\r\nst->current_flags &= ~flag->mask;\r\n}\r\nif (st->current_flags != 0)\r\nseq_printf(st->seq, " unknown flags:%llx", st->current_flags);\r\n}\r\nstatic void dump_addr(struct pg_state *st, unsigned long addr)\r\n{\r\nstatic const char units[] = "KMGTPE";\r\nconst char *unit = units;\r\nunsigned long delta;\r\nseq_printf(st->seq, "0x%016lx-0x%016lx ", st->start_address, addr-1);\r\ndelta = (addr - st->start_address) >> 10;\r\nwhile (!(delta & 1023) && unit[1]) {\r\ndelta >>= 10;\r\nunit++;\r\n}\r\nseq_printf(st->seq, "%9lu%c", delta, *unit);\r\n}\r\nstatic void note_page(struct pg_state *st, unsigned long addr,\r\nunsigned int level, u64 val)\r\n{\r\nu64 flag = val & pg_level[level].mask;\r\nif (!st->level) {\r\nst->level = level;\r\nst->current_flags = flag;\r\nst->start_address = addr;\r\nseq_printf(st->seq, "---[ %s ]---\n", st->marker->name);\r\n} else if (flag != st->current_flags || level != st->level ||\r\naddr >= st->marker[1].start_address) {\r\nif (st->current_flags) {\r\ndump_addr(st, addr);\r\nif (pg_level[st->level].flag)\r\ndump_flag_info(st, pg_level[st->level].flag,\r\nst->current_flags,\r\npg_level[st->level].num);\r\nseq_puts(st->seq, "\n");\r\n}\r\nwhile (addr >= st->marker[1].start_address) {\r\nst->marker++;\r\nseq_printf(st->seq, "---[ %s ]---\n", st->marker->name);\r\n}\r\nst->start_address = addr;\r\nst->current_flags = flag;\r\nst->level = level;\r\n}\r\n}\r\nstatic void walk_pte(struct pg_state *st, pmd_t *pmd, unsigned long start)\r\n{\r\npte_t *pte = pte_offset_kernel(pmd, 0);\r\nunsigned long addr;\r\nunsigned int i;\r\nfor (i = 0; i < PTRS_PER_PTE; i++, pte++) {\r\naddr = start + i * PAGE_SIZE;\r\nnote_page(st, addr, 4, pte_val(*pte));\r\n}\r\n}\r\nstatic void walk_pmd(struct pg_state *st, pud_t *pud, unsigned long start)\r\n{\r\npmd_t *pmd = pmd_offset(pud, 0);\r\nunsigned long addr;\r\nunsigned int i;\r\nfor (i = 0; i < PTRS_PER_PMD; i++, pmd++) {\r\naddr = start + i * PMD_SIZE;\r\nif (!pmd_none(*pmd))\r\nwalk_pte(st, pmd, addr);\r\nelse\r\nnote_page(st, addr, 3, pmd_val(*pmd));\r\n}\r\n}\r\nstatic void walk_pud(struct pg_state *st, pgd_t *pgd, unsigned long start)\r\n{\r\npud_t *pud = pud_offset(pgd, 0);\r\nunsigned long addr;\r\nunsigned int i;\r\nfor (i = 0; i < PTRS_PER_PUD; i++, pud++) {\r\naddr = start + i * PUD_SIZE;\r\nif (!pud_none(*pud))\r\nwalk_pmd(st, pud, addr);\r\nelse\r\nnote_page(st, addr, 2, pud_val(*pud));\r\n}\r\n}\r\nstatic void walk_pagetables(struct pg_state *st)\r\n{\r\npgd_t *pgd = pgd_offset_k(0UL);\r\nunsigned int i;\r\nunsigned long addr;\r\nfor (i = 0; i < PTRS_PER_PGD; i++, pgd++) {\r\naddr = KERN_VIRT_START + i * PGDIR_SIZE;\r\nif (!pgd_none(*pgd))\r\nwalk_pud(st, pgd, addr);\r\nelse\r\nnote_page(st, addr, 1, pgd_val(*pgd));\r\n}\r\n}\r\nstatic void populate_markers(void)\r\n{\r\naddress_markers[0].start_address = PAGE_OFFSET;\r\naddress_markers[1].start_address = VMALLOC_START;\r\naddress_markers[2].start_address = VMALLOC_END;\r\naddress_markers[3].start_address = ISA_IO_BASE;\r\naddress_markers[4].start_address = ISA_IO_END;\r\naddress_markers[5].start_address = PHB_IO_BASE;\r\naddress_markers[6].start_address = PHB_IO_END;\r\naddress_markers[7].start_address = IOREMAP_BASE;\r\naddress_markers[8].start_address = IOREMAP_END;\r\n#ifdef CONFIG_PPC_STD_MMU_64\r\naddress_markers[9].start_address = H_VMEMMAP_BASE;\r\n#else\r\naddress_markers[9].start_address = VMEMMAP_BASE;\r\n#endif\r\n}\r\nstatic int ptdump_show(struct seq_file *m, void *v)\r\n{\r\nstruct pg_state st = {\r\n.seq = m,\r\n.start_address = KERN_VIRT_START,\r\n.marker = address_markers,\r\n};\r\nwalk_pagetables(&st);\r\nnote_page(&st, 0, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int ptdump_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ptdump_show, NULL);\r\n}\r\nstatic void build_pgtable_complete_mask(void)\r\n{\r\nunsigned int i, j;\r\nfor (i = 0; i < ARRAY_SIZE(pg_level); i++)\r\nif (pg_level[i].flag)\r\nfor (j = 0; j < pg_level[i].num; j++)\r\npg_level[i].mask |= pg_level[i].flag[j].mask;\r\n}\r\nstatic int ptdump_init(void)\r\n{\r\nstruct dentry *debugfs_file;\r\npopulate_markers();\r\nbuild_pgtable_complete_mask();\r\ndebugfs_file = debugfs_create_file("kernel_pagetables", 0400, NULL,\r\nNULL, &ptdump_fops);\r\nreturn debugfs_file ? 0 : -ENOMEM;\r\n}
