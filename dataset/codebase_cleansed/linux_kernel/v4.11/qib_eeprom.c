int qib_eeprom_read(struct qib_devdata *dd, u8 eeprom_offset,\r\nvoid *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (!ret) {\r\nret = qib_twsi_reset(dd);\r\nif (ret)\r\nqib_dev_err(dd, "EEPROM Reset for read failed\n");\r\nelse\r\nret = qib_twsi_blk_rd(dd, dd->twsi_eeprom_dev,\r\neeprom_offset, buff, len);\r\nmutex_unlock(&dd->eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int eeprom_write_with_enable(struct qib_devdata *dd, u8 offset,\r\nconst void *buf, int len)\r\n{\r\nint ret, pwen;\r\npwen = dd->f_eeprom_wen(dd, 1);\r\nret = qib_twsi_reset(dd);\r\nif (ret)\r\nqib_dev_err(dd, "EEPROM Reset for write failed\n");\r\nelse\r\nret = qib_twsi_blk_wr(dd, dd->twsi_eeprom_dev,\r\noffset, buf, len);\r\ndd->f_eeprom_wen(dd, pwen);\r\nreturn ret;\r\n}\r\nint qib_eeprom_write(struct qib_devdata *dd, u8 eeprom_offset,\r\nconst void *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (!ret) {\r\nret = eeprom_write_with_enable(dd, eeprom_offset, buff, len);\r\nmutex_unlock(&dd->eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 flash_csum(struct qib_flash *ifp, int adjust)\r\n{\r\nu8 *ip = (u8 *) ifp;\r\nu8 csum = 0, len;\r\nlen = ifp->if_length;\r\nif (len > sizeof(struct qib_flash))\r\nlen = sizeof(struct qib_flash);\r\nwhile (len--)\r\ncsum += *ip++;\r\ncsum -= ifp->if_csum;\r\ncsum = ~csum;\r\nif (adjust)\r\nifp->if_csum = csum;\r\nreturn csum;\r\n}\r\nvoid qib_get_eeprom_info(struct qib_devdata *dd)\r\n{\r\nvoid *buf;\r\nstruct qib_flash *ifp;\r\n__be64 guid;\r\nint len, eep_stat;\r\nu8 csum, *bguid;\r\nint t = dd->unit;\r\nstruct qib_devdata *dd0 = qib_lookup(0);\r\nif (t && dd0->nguid > 1 && t <= dd0->nguid) {\r\nu8 oguid;\r\ndd->base_guid = dd0->base_guid;\r\nbguid = (u8 *) &dd->base_guid;\r\noguid = bguid[7];\r\nbguid[7] += t;\r\nif (oguid > bguid[7]) {\r\nif (bguid[6] == 0xff) {\r\nif (bguid[5] == 0xff) {\r\nqib_dev_err(dd,\r\n"Can't set %s GUID from base, wraps to OUI!\n",\r\nqib_get_unit_name(t));\r\ndd->base_guid = 0;\r\ngoto bail;\r\n}\r\nbguid[5]++;\r\n}\r\nbguid[6]++;\r\n}\r\ndd->nguid = 1;\r\ngoto bail;\r\n}\r\nlen = sizeof(struct qib_flash);\r\nbuf = vmalloc(len);\r\nif (!buf)\r\ngoto bail;\r\neep_stat = qib_eeprom_read(dd, 0, buf, len);\r\nif (eep_stat) {\r\nqib_dev_err(dd, "Failed reading GUID from eeprom\n");\r\ngoto done;\r\n}\r\nifp = (struct qib_flash *)buf;\r\ncsum = flash_csum(ifp, 0);\r\nif (csum != ifp->if_csum) {\r\nqib_devinfo(dd->pcidev,\r\n"Bad I2C flash checksum: 0x%x, not 0x%x\n",\r\ncsum, ifp->if_csum);\r\ngoto done;\r\n}\r\nif (*(__be64 *) ifp->if_guid == cpu_to_be64(0) ||\r\n*(__be64 *) ifp->if_guid == ~cpu_to_be64(0)) {\r\nqib_dev_err(dd,\r\n"Invalid GUID %llx from flash; ignoring\n",\r\n*(unsigned long long *) ifp->if_guid);\r\ngoto done;\r\n}\r\nif (*(u64 *) ifp->if_guid == 0x100007511000000ULL)\r\nqib_devinfo(dd->pcidev,\r\n"Warning, GUID %llx is default, probably not correct!\n",\r\n*(unsigned long long *) ifp->if_guid);\r\nbguid = ifp->if_guid;\r\nif (!bguid[0] && !bguid[1] && !bguid[2]) {\r\nbguid[1] = bguid[3];\r\nbguid[2] = bguid[4];\r\nbguid[3] = 0;\r\nbguid[4] = 0;\r\nguid = *(__be64 *) ifp->if_guid;\r\n} else\r\nguid = *(__be64 *) ifp->if_guid;\r\ndd->base_guid = guid;\r\ndd->nguid = ifp->if_numguid;\r\nif ((ifp->if_fversion > 1) && ifp->if_sprefix[0] &&\r\n((u8 *) ifp->if_sprefix)[0] != 0xFF) {\r\nchar *snp = dd->serial;\r\nmemcpy(snp, ifp->if_sprefix, sizeof(ifp->if_sprefix));\r\nsnp[sizeof(ifp->if_sprefix)] = '\0';\r\nlen = strlen(snp);\r\nsnp += len;\r\nlen = sizeof(dd->serial) - len;\r\nif (len > sizeof(ifp->if_serial))\r\nlen = sizeof(ifp->if_serial);\r\nmemcpy(snp, ifp->if_serial, len);\r\n} else {\r\nmemcpy(dd->serial, ifp->if_serial, sizeof(ifp->if_serial));\r\n}\r\nif (!strstr(ifp->if_comment, "Tested successfully"))\r\nqib_dev_err(dd,\r\n"Board SN %s did not pass functional test: %s\n",\r\ndd->serial, ifp->if_comment);\r\ndone:\r\nvfree(buf);\r\nbail:;\r\n}
