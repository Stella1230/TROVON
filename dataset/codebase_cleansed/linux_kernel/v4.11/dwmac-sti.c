static void stih4xx_fix_retime_src(void *priv, u32 spd)\r\n{\r\nstruct sti_dwmac *dwmac = priv;\r\nu32 src = dwmac->tx_retime_src;\r\nu32 reg = dwmac->ctrl_reg;\r\nu32 freq = 0;\r\nif (dwmac->interface == PHY_INTERFACE_MODE_MII) {\r\nsrc = TX_RETIME_SRC_TXCLK;\r\n} else if (dwmac->interface == PHY_INTERFACE_MODE_RMII) {\r\nif (dwmac->ext_phyclk) {\r\nsrc = TX_RETIME_SRC_PHYCLK;\r\n} else {\r\nsrc = TX_RETIME_SRC_CLKGEN;\r\nfreq = DWMAC_50MHZ;\r\n}\r\n} else if (IS_PHY_IF_MODE_RGMII(dwmac->interface)) {\r\nif (spd == SPEED_1000) {\r\nfreq = DWMAC_125MHZ;\r\n} else {\r\nsrc = TX_RETIME_SRC_CLKGEN;\r\nif (spd == SPEED_100)\r\nfreq = DWMAC_25MHZ;\r\nelse if (spd == SPEED_10)\r\nfreq = DWMAC_2_5MHZ;\r\n}\r\n}\r\nif (src == TX_RETIME_SRC_CLKGEN && freq)\r\nclk_set_rate(dwmac->clk, freq);\r\nregmap_update_bits(dwmac->regmap, reg, STIH4XX_RETIME_SRC_MASK,\r\nstih4xx_tx_retime_val[src]);\r\n}\r\nstatic void stid127_fix_retime_src(void *priv, u32 spd)\r\n{\r\nstruct sti_dwmac *dwmac = priv;\r\nu32 reg = dwmac->ctrl_reg;\r\nu32 freq = 0;\r\nu32 val = 0;\r\nif (dwmac->interface == PHY_INTERFACE_MODE_MII) {\r\nval = STID127_ETH_SEL_INTERNAL_NOTEXT_TXCLK;\r\n} else if (dwmac->interface == PHY_INTERFACE_MODE_RMII) {\r\nif (!dwmac->ext_phyclk) {\r\nval = STID127_ETH_SEL_INTERNAL_NOTEXT_PHYCLK;\r\nfreq = DWMAC_50MHZ;\r\n}\r\n} else if (IS_PHY_IF_MODE_RGMII(dwmac->interface)) {\r\nval = STID127_ETH_SEL_INTERNAL_NOTEXT_TXCLK;\r\nif (spd == SPEED_1000)\r\nfreq = DWMAC_125MHZ;\r\nelse if (spd == SPEED_100)\r\nfreq = DWMAC_25MHZ;\r\nelse if (spd == SPEED_10)\r\nfreq = DWMAC_2_5MHZ;\r\n}\r\nif (freq)\r\nclk_set_rate(dwmac->clk, freq);\r\nregmap_update_bits(dwmac->regmap, reg, STID127_RETIME_SRC_MASK, val);\r\n}\r\nstatic int sti_dwmac_set_mode(struct sti_dwmac *dwmac)\r\n{\r\nstruct regmap *regmap = dwmac->regmap;\r\nint iface = dwmac->interface;\r\nu32 reg = dwmac->ctrl_reg;\r\nu32 val;\r\nif (dwmac->gmac_en)\r\nregmap_update_bits(regmap, reg, EN_MASK, EN);\r\nregmap_update_bits(regmap, reg, MII_PHY_SEL_MASK, phy_intf_sels[iface]);\r\nval = (iface == PHY_INTERFACE_MODE_REVMII) ? 0 : ENMII;\r\nregmap_update_bits(regmap, reg, ENMII_MASK, val);\r\ndwmac->fix_retime_src(dwmac, dwmac->speed);\r\nreturn 0;\r\n}\r\nstatic int sti_dwmac_parse_data(struct sti_dwmac *dwmac,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct regmap *regmap;\r\nint err;\r\ndwmac->clk_sel_reg = -ENXIO;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "sti-clkconf");\r\nif (res)\r\ndwmac->clk_sel_reg = res->start;\r\nregmap = syscon_regmap_lookup_by_phandle(np, "st,syscon");\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nerr = of_property_read_u32_index(np, "st,syscon", 1, &dwmac->ctrl_reg);\r\nif (err) {\r\ndev_err(dev, "Can't get sysconfig ctrl offset (%d)\n", err);\r\nreturn err;\r\n}\r\ndwmac->interface = of_get_phy_mode(np);\r\ndwmac->regmap = regmap;\r\ndwmac->gmac_en = of_property_read_bool(np, "st,gmac_en");\r\ndwmac->ext_phyclk = of_property_read_bool(np, "st,ext-phyclk");\r\ndwmac->tx_retime_src = TX_RETIME_SRC_NA;\r\ndwmac->speed = SPEED_100;\r\nif (IS_PHY_IF_MODE_GBIT(dwmac->interface)) {\r\nconst char *rs;\r\ndwmac->tx_retime_src = TX_RETIME_SRC_CLKGEN;\r\nerr = of_property_read_string(np, "st,tx-retime-src", &rs);\r\nif (err < 0) {\r\ndev_warn(dev, "Use internal clock source\n");\r\n} else {\r\nif (!strcasecmp(rs, "clk_125"))\r\ndwmac->tx_retime_src = TX_RETIME_SRC_CLK_125;\r\nelse if (!strcasecmp(rs, "txclk"))\r\ndwmac->tx_retime_src = TX_RETIME_SRC_TXCLK;\r\n}\r\ndwmac->speed = SPEED_1000;\r\n}\r\ndwmac->clk = devm_clk_get(dev, "sti-ethclk");\r\nif (IS_ERR(dwmac->clk)) {\r\ndev_warn(dev, "No phy clock provided...\n");\r\ndwmac->clk = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat;\r\nconst struct sti_dwmac_of_data *data;\r\nstruct stmmac_resources stmmac_res;\r\nstruct sti_dwmac *dwmac;\r\nint ret;\r\ndata = of_device_get_match_data(&pdev->dev);\r\nif (!data) {\r\ndev_err(&pdev->dev, "No OF match data provided\n");\r\nreturn -EINVAL;\r\n}\r\nret = stmmac_get_platform_resources(pdev, &stmmac_res);\r\nif (ret)\r\nreturn ret;\r\nplat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);\r\nif (IS_ERR(plat_dat))\r\nreturn PTR_ERR(plat_dat);\r\ndwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\r\nif (!dwmac) {\r\nret = -ENOMEM;\r\ngoto err_remove_config_dt;\r\n}\r\nret = sti_dwmac_parse_data(dwmac, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to parse OF data\n");\r\ngoto err_remove_config_dt;\r\n}\r\ndwmac->fix_retime_src = data->fix_retime_src;\r\nplat_dat->bsp_priv = dwmac;\r\nplat_dat->fix_mac_speed = data->fix_retime_src;\r\nret = clk_prepare_enable(dwmac->clk);\r\nif (ret)\r\ngoto err_remove_config_dt;\r\nret = sti_dwmac_set_mode(dwmac);\r\nif (ret)\r\ngoto disable_clk;\r\nret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\r\nif (ret)\r\ngoto disable_clk;\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(dwmac->clk);\r\nerr_remove_config_dt:\r\nstmmac_remove_config_dt(pdev, plat_dat);\r\nreturn ret;\r\n}\r\nstatic int sti_dwmac_remove(struct platform_device *pdev)\r\n{\r\nstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(&pdev->dev);\r\nint ret = stmmac_dvr_remove(&pdev->dev);\r\nclk_disable_unprepare(dwmac->clk);\r\nreturn ret;\r\n}\r\nstatic int sti_dwmac_suspend(struct device *dev)\r\n{\r\nstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(dev);\r\nint ret = stmmac_suspend(dev);\r\nclk_disable_unprepare(dwmac->clk);\r\nreturn ret;\r\n}\r\nstatic int sti_dwmac_resume(struct device *dev)\r\n{\r\nstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(dev);\r\nclk_prepare_enable(dwmac->clk);\r\nsti_dwmac_set_mode(dwmac);\r\nreturn stmmac_resume(dev);\r\n}
