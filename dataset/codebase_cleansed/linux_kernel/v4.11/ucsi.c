static int ucsi_acpi_cmd(struct ucsi *ucsi, struct ucsi_control *ctrl)\r\n{\r\nuuid_le uuid = UUID_LE(0x6f8398c2, 0x7ca4, 0x11e4,\r\n0xad, 0x36, 0x63, 0x10, 0x42, 0xb5, 0x00, 0x8f);\r\nunion acpi_object *obj;\r\nucsi->data->ctrl.raw_cmd = ctrl->raw_cmd;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(ucsi->dev), uuid.b, 1, 1, NULL);\r\nif (!obj) {\r\ndev_err(ucsi->dev, "%s: failed to evaluate _DSM\n", __func__);\r\nreturn -EIO;\r\n}\r\nACPI_FREE(obj);\r\nreturn 0;\r\n}\r\nstatic void ucsi_acpi_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ucsi *ucsi = data;\r\nstruct ucsi_cci *cci;\r\nspin_lock(&ucsi->dev_lock);\r\nucsi->status = UCSI_IDLE;\r\ncci = &ucsi->data->cci;\r\nif (!ucsi->data->raw_cci) {\r\nif (test_bit(EVENT_PENDING, &ucsi->flags))\r\ncomplete(&ucsi->complete);\r\nelse\r\ndev_WARN(ucsi->dev, "spurious notification\n");\r\ngoto out_unlock;\r\n}\r\nif (test_bit(COMMAND_PENDING, &ucsi->flags)) {\r\nif (cci->busy) {\r\nucsi->status = UCSI_BUSY;\r\ncomplete(&ucsi->complete);\r\ngoto out_unlock;\r\n} else if (cci->ack_complete || cci->cmd_complete) {\r\nif (cci->error && cci->cmd_complete)\r\nucsi->status = UCSI_ERROR;\r\nucsi->data->ctrl.raw_cmd = 0;\r\ncomplete(&ucsi->complete);\r\n}\r\n}\r\nif (cci->connector_change) {\r\nstruct ucsi_connector *con;\r\nif (!ucsi->connector)\r\ngoto out_unlock;\r\ncon = ucsi->connector + (cci->connector_change - 1);\r\nif (!test_and_set_bit(EVENT_PENDING, &ucsi->flags))\r\nschedule_work(&con->work);\r\n}\r\nout_unlock:\r\nspin_unlock(&ucsi->dev_lock);\r\n}\r\nstatic int ucsi_ack(struct ucsi *ucsi, u8 cmd)\r\n{\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nctrl.cmd.cmd = UCSI_ACK_CC_CI;\r\nctrl.cmd.length = 0;\r\nctrl.cmd.data = cmd;\r\nret = ucsi_acpi_cmd(ucsi, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nret = wait_for_completion_timeout(&ucsi->complete,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS));\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int ucsi_run_cmd(struct ucsi *ucsi, struct ucsi_control *ctrl,\r\nvoid *data, size_t size)\r\n{\r\nu16 err_value = 0;\r\nint ret;\r\nset_bit(COMMAND_PENDING, &ucsi->flags);\r\nret = ucsi_acpi_cmd(ucsi, ctrl);\r\nif (ret)\r\ngoto err_clear_flag;\r\nret = wait_for_completion_timeout(&ucsi->complete,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS));\r\nif (!ret) {\r\nret = -ETIMEDOUT;\r\ngoto err_clear_flag;\r\n}\r\nswitch (ucsi->status) {\r\ncase UCSI_IDLE:\r\nif (data)\r\nmemcpy(data, ucsi->data->message_in, size);\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nbreak;\r\ncase UCSI_BUSY:\r\nret = -EBUSY;\r\ngoto err_clear_flag;\r\ncase UCSI_ERROR:\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nif (ret)\r\ngoto err_clear_flag;\r\nctrl->cmd.cmd = UCSI_GET_ERROR_STATUS;\r\nctrl->cmd.length = 0;\r\nctrl->cmd.data = 0;\r\nret = ucsi_acpi_cmd(ucsi, ctrl);\r\nif (ret)\r\ngoto err_clear_flag;\r\nret = wait_for_completion_timeout(&ucsi->complete,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS));\r\nif (!ret) {\r\nret = -ETIMEDOUT;\r\ngoto err_clear_flag;\r\n}\r\nmemcpy(&err_value, ucsi->data->message_in, sizeof(err_value));\r\nif (WARN_ON(ucsi->status == UCSI_ERROR)) {\r\nret = -ENODEV;\r\ngoto err_clear_flag;\r\n}\r\nret = ucsi_ack(ucsi, UCSI_ACK_CMD);\r\nif (ret)\r\ngoto err_clear_flag;\r\nswitch (err_value) {\r\ncase UCSI_ERROR_INCOMPATIBLE_PARTNER:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase UCSI_ERROR_CC_COMMUNICATION_ERR:\r\nret = -ECOMM;\r\nbreak;\r\ncase UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL:\r\nret = -EIO;\r\nbreak;\r\ncase UCSI_ERROR_DEAD_BATTERY:\r\ndev_warn(ucsi->dev, "Dead battery condition!\n");\r\nret = -EPERM;\r\nbreak;\r\ncase UCSI_ERROR_INVALID_CON_NUM:\r\ncase UCSI_ERROR_UNREGONIZED_CMD:\r\ncase UCSI_ERROR_INVALID_CMD_ARGUMENT:\r\ndefault:\r\ndev_warn(ucsi->dev,\r\n"%s: possible UCSI driver bug - error %hu\n",\r\n__func__, err_value);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nctrl->raw_cmd = 0;\r\nerr_clear_flag:\r\nclear_bit(COMMAND_PENDING, &ucsi->flags);\r\nreturn ret;\r\n}\r\nstatic void ucsi_connector_change(struct work_struct *work)\r\n{\r\nstruct ucsi_connector *con = container_of(work, struct ucsi_connector,\r\nwork);\r\nstruct ucsi_connector_status constat;\r\nstruct ucsi *ucsi = con->ucsi;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nmutex_lock(&ucsi->ppm_lock);\r\nctrl.cmd.cmd = UCSI_GET_CONNECTOR_STATUS;\r\nctrl.cmd.length = 0;\r\nctrl.cmd.data = con->num;\r\nret = ucsi_run_cmd(con->ucsi, &ctrl, &constat, sizeof(constat));\r\nif (ret) {\r\ndev_err(ucsi->dev, "%s: failed to read connector status (%d)\n",\r\n__func__, ret);\r\ngoto out_ack_event;\r\n}\r\nif (!constat.connected || !(constat.change &\r\n(UCSI_CONSTAT_PARTNER_CHANGE | UCSI_CONSTAT_CONNECT_CHANGE)) ||\r\nconstat.partner_flags & UCSI_CONSTAT_PARTNER_FLAG_ALT_MODE)\r\ngoto out_ack_event;\r\nif (constat.partner_type & UCSI_CONSTAT_PARTNER_TYPE_DFP) {\r\nctrl.uor.cmd = UCSI_SET_UOR;\r\nctrl.uor.con_num = con->num;\r\nctrl.uor.role = UCSI_UOR_ROLE_DFP;\r\nret = ucsi_run_cmd(con->ucsi, &ctrl, NULL, 0);\r\nif (ret)\r\ndev_err(ucsi->dev, "%s: failed to swap role (%d)\n",\r\n__func__, ret);\r\n}\r\nout_ack_event:\r\nucsi_ack(ucsi, UCSI_ACK_EVENT);\r\nclear_bit(EVENT_PENDING, &ucsi->flags);\r\nmutex_unlock(&ucsi->ppm_lock);\r\n}\r\nstatic int ucsi_reset_ppm(struct ucsi *ucsi)\r\n{\r\nint timeout = UCSI_TIMEOUT_MS;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.cmd.cmd = UCSI_PPM_RESET;\r\nret = ucsi_acpi_cmd(ucsi, &ctrl);\r\nif (ret)\r\nreturn ret;\r\nwhile (!ucsi->data->cci.reset_complete && timeout--)\r\nusleep_range(1000, 2000);\r\nreturn 0;\r\n}\r\nstatic int ucsi_init(struct ucsi *ucsi)\r\n{\r\nstruct ucsi_connector *con;\r\nstruct ucsi_control ctrl;\r\nint ret;\r\nint i;\r\ninit_completion(&ucsi->complete);\r\nspin_lock_init(&ucsi->dev_lock);\r\nmutex_init(&ucsi->ppm_lock);\r\nret = ucsi_reset_ppm(ucsi);\r\nif (ret)\r\nreturn ret;\r\nret = ucsi_reset_ppm(ucsi);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&ucsi->ppm_lock);\r\nctrl.cmd.cmd = UCSI_SET_NOTIFICATION_ENABLE;\r\nctrl.cmd.length = 0;\r\nctrl.cmd.data = UCSI_ENABLE_NTFY_CMD_COMPLETE | UCSI_ENABLE_NTFY_ERROR;\r\nret = ucsi_run_cmd(ucsi, &ctrl, NULL, 0);\r\nif (ret)\r\ngoto err_reset;\r\nctrl.cmd.cmd = UCSI_GET_CAPABILITY;\r\nret = ucsi_run_cmd(ucsi, &ctrl, &ucsi->cap, sizeof(ucsi->cap));\r\nif (ret)\r\ngoto err_reset;\r\nif (!ucsi->cap.num_connectors) {\r\nret = -ENODEV;\r\ngoto err_reset;\r\n}\r\nucsi->connector = devm_kcalloc(ucsi->dev, ucsi->cap.num_connectors,\r\nsizeof(*ucsi->connector), GFP_KERNEL);\r\nif (!ucsi->connector) {\r\nret = -ENOMEM;\r\ngoto err_reset;\r\n}\r\nfor (i = 1, con = ucsi->connector; i < ucsi->cap.num_connectors + 1;\r\ni++, con++) {\r\nctrl.cmd.cmd = UCSI_GET_CONNECTOR_CAPABILITY;\r\nctrl.cmd.data = i;\r\nret = ucsi_run_cmd(ucsi, &ctrl, &con->cap, sizeof(con->cap));\r\nif (ret)\r\ngoto err_reset;\r\ncon->num = i;\r\ncon->ucsi = ucsi;\r\nINIT_WORK(&con->work, ucsi_connector_change);\r\n}\r\nctrl.cmd.cmd = UCSI_SET_NOTIFICATION_ENABLE;\r\nctrl.cmd.data = UCSI_ENABLE_NTFY_ALL;\r\nret = ucsi_run_cmd(ucsi, &ctrl, NULL, 0);\r\nif (ret < 0)\r\ngoto err_reset;\r\nmutex_unlock(&ucsi->ppm_lock);\r\nreturn 0;\r\nerr_reset:\r\nucsi_reset_ppm(ucsi);\r\nmutex_unlock(&ucsi->ppm_lock);\r\nreturn ret;\r\n}\r\nstatic int ucsi_acpi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nacpi_status status;\r\nstruct ucsi *ucsi;\r\nint ret;\r\nucsi = devm_kzalloc(&pdev->dev, sizeof(*ucsi), GFP_KERNEL);\r\nif (!ucsi)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "missing memory resource\n");\r\nreturn -ENODEV;\r\n}\r\nucsi->data = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!ucsi->data)\r\nreturn -ENOMEM;\r\nucsi->dev = &pdev->dev;\r\nstatus = acpi_install_notify_handler(ACPI_HANDLE(&pdev->dev),\r\nACPI_ALL_NOTIFY,\r\nucsi_acpi_notify, ucsi);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nret = ucsi_init(ucsi);\r\nif (ret) {\r\nacpi_remove_notify_handler(ACPI_HANDLE(&pdev->dev),\r\nACPI_ALL_NOTIFY,\r\nucsi_acpi_notify);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, ucsi);\r\nreturn 0;\r\n}\r\nstatic int ucsi_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct ucsi *ucsi = platform_get_drvdata(pdev);\r\nacpi_remove_notify_handler(ACPI_HANDLE(&pdev->dev),\r\nACPI_ALL_NOTIFY, ucsi_acpi_notify);\r\nif (wait_on_bit_timeout(&ucsi->flags, EVENT_PENDING,\r\nTASK_UNINTERRUPTIBLE,\r\nmsecs_to_jiffies(UCSI_TIMEOUT_MS)))\r\ndev_WARN(ucsi->dev, "%s: Events still pending\n", __func__);\r\nucsi_reset_ppm(ucsi);\r\nreturn 0;\r\n}
