static void meson_cvbs_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic enum drm_connector_status\r\nmeson_cvbs_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int meson_cvbs_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode;\r\nint i;\r\nfor (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {\r\nstruct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];\r\nmode = drm_mode_duplicate(dev, &meson_mode->mode);\r\nif (!mode) {\r\nDRM_ERROR("Failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\ndrm_mode_probed_add(connector, mode);\r\n}\r\nreturn i;\r\n}\r\nstatic int meson_cvbs_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void meson_venc_cvbs_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nstatic int meson_venc_cvbs_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nint i;\r\nfor (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {\r\nstruct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];\r\nif (drm_mode_equal(&crtc_state->mode, &meson_mode->mode))\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void meson_venc_cvbs_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct meson_venc_cvbs *meson_venc_cvbs =\r\nencoder_to_meson_venc_cvbs(encoder);\r\nstruct meson_drm *priv = meson_venc_cvbs->priv;\r\nregmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);\r\nregmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);\r\n}\r\nstatic void meson_venc_cvbs_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct meson_venc_cvbs *meson_venc_cvbs =\r\nencoder_to_meson_venc_cvbs(encoder);\r\nstruct meson_drm *priv = meson_venc_cvbs->priv;\r\nwritel_bits_relaxed(BIT(5), 0, priv->io_base + _REG(VENC_VDAC_DACSEL0));\r\nif (meson_vpu_is_compatible(priv, "amlogic,meson-gxbb-vpu"))\r\nregmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);\r\nelse if (meson_vpu_is_compatible(priv, "amlogic,meson-gxm-vpu") ||\r\nmeson_vpu_is_compatible(priv, "amlogic,meson-gxl-vpu"))\r\nregmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);\r\nregmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);\r\n}\r\nstatic void meson_venc_cvbs_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct meson_venc_cvbs *meson_venc_cvbs =\r\nencoder_to_meson_venc_cvbs(encoder);\r\nint i;\r\nfor (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {\r\nstruct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];\r\nif (drm_mode_equal(mode, &meson_mode->mode)) {\r\nmeson_venci_cvbs_mode_set(meson_venc_cvbs->priv,\r\nmeson_mode->enci);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic bool meson_venc_cvbs_connector_is_available(struct meson_drm *priv)\r\n{\r\nstruct device_node *ep, *remote;\r\nep = of_graph_get_endpoint_by_regs(priv->dev->of_node, 0, 0);\r\nif (!ep)\r\nreturn false;\r\nremote = of_graph_get_remote_port(ep);\r\nif (remote) {\r\nof_node_put(ep);\r\nreturn true;\r\n}\r\nof_node_put(ep);\r\nof_node_put(remote);\r\nreturn false;\r\n}\r\nint meson_venc_cvbs_create(struct meson_drm *priv)\r\n{\r\nstruct drm_device *drm = priv->drm;\r\nstruct meson_venc_cvbs *meson_venc_cvbs;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nint ret;\r\nif (!meson_venc_cvbs_connector_is_available(priv)) {\r\ndev_info(drm->dev, "CVBS Output connector not available\n");\r\nreturn -ENODEV;\r\n}\r\nmeson_venc_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_venc_cvbs),\r\nGFP_KERNEL);\r\nif (!meson_venc_cvbs)\r\nreturn -ENOMEM;\r\nmeson_venc_cvbs->priv = priv;\r\nencoder = &meson_venc_cvbs->encoder;\r\nconnector = &meson_venc_cvbs->connector;\r\ndrm_connector_helper_add(connector,\r\n&meson_cvbs_connector_helper_funcs);\r\nret = drm_connector_init(drm, connector, &meson_cvbs_connector_funcs,\r\nDRM_MODE_CONNECTOR_Composite);\r\nif (ret) {\r\ndev_err(priv->dev, "Failed to init CVBS connector\n");\r\nreturn ret;\r\n}\r\nconnector->interlace_allowed = 1;\r\ndrm_encoder_helper_add(encoder, &meson_venc_cvbs_encoder_helper_funcs);\r\nret = drm_encoder_init(drm, encoder, &meson_venc_cvbs_encoder_funcs,\r\nDRM_MODE_ENCODER_TVDAC, "meson_venc_cvbs");\r\nif (ret) {\r\ndev_err(priv->dev, "Failed to init CVBS encoder\n");\r\nreturn ret;\r\n}\r\nencoder->possible_crtcs = BIT(0);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}
