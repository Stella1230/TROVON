static int ipt_init_target(struct xt_entry_target *t, char *table,\r\nunsigned int hook)\r\n{\r\nstruct xt_tgchk_param par;\r\nstruct xt_target *target;\r\nint ret = 0;\r\ntarget = xt_request_find_target(AF_INET, t->u.user.name,\r\nt->u.user.revision);\r\nif (IS_ERR(target))\r\nreturn PTR_ERR(target);\r\nt->u.kernel.target = target;\r\npar.table = table;\r\npar.entryinfo = NULL;\r\npar.target = target;\r\npar.targinfo = t->data;\r\npar.hook_mask = hook;\r\npar.family = NFPROTO_IPV4;\r\nret = xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);\r\nif (ret < 0) {\r\nmodule_put(t->u.kernel.target->me);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipt_destroy_target(struct xt_entry_target *t)\r\n{\r\nstruct xt_tgdtor_param par = {\r\n.target = t->u.kernel.target,\r\n.targinfo = t->data,\r\n.family = NFPROTO_IPV4,\r\n};\r\nif (par.target->destroy != NULL)\r\npar.target->destroy(&par);\r\nmodule_put(par.target->me);\r\n}\r\nstatic void tcf_ipt_release(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_ipt *ipt = to_ipt(a);\r\nipt_destroy_target(ipt->tcfi_t);\r\nkfree(ipt->tcfi_tname);\r\nkfree(ipt->tcfi_t);\r\n}\r\nstatic int __tcf_ipt_init(struct tc_action_net *tn, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a,\r\nconst struct tc_action_ops *ops, int ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_IPT_MAX + 1];\r\nstruct tcf_ipt *ipt;\r\nstruct xt_entry_target *td, *t;\r\nchar *tname;\r\nbool exists = false;\r\nint ret = 0, err;\r\nu32 hook = 0;\r\nu32 index = 0;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_IPT_MAX, nla, ipt_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_IPT_INDEX] != NULL)\r\nindex = nla_get_u32(tb[TCA_IPT_INDEX]);\r\nexists = tcf_hash_check(tn, index, a, bind);\r\nif (exists && bind)\r\nreturn 0;\r\nif (tb[TCA_IPT_HOOK] == NULL || tb[TCA_IPT_TARG] == NULL) {\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn -EINVAL;\r\n}\r\ntd = (struct xt_entry_target *)nla_data(tb[TCA_IPT_TARG]);\r\nif (nla_len(tb[TCA_IPT_TARG]) < td->u.target_size) {\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn -EINVAL;\r\n}\r\nif (!exists) {\r\nret = tcf_hash_create(tn, index, est, a, ops, bind,\r\nfalse);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(*a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\nhook = nla_get_u32(tb[TCA_IPT_HOOK]);\r\nerr = -ENOMEM;\r\ntname = kmalloc(IFNAMSIZ, GFP_KERNEL);\r\nif (unlikely(!tname))\r\ngoto err1;\r\nif (tb[TCA_IPT_TABLE] == NULL ||\r\nnla_strlcpy(tname, tb[TCA_IPT_TABLE], IFNAMSIZ) >= IFNAMSIZ)\r\nstrcpy(tname, "mangle");\r\nt = kmemdup(td, td->u.target_size, GFP_KERNEL);\r\nif (unlikely(!t))\r\ngoto err2;\r\nerr = ipt_init_target(t, tname, hook);\r\nif (err < 0)\r\ngoto err3;\r\nipt = to_ipt(*a);\r\nspin_lock_bh(&ipt->tcf_lock);\r\nif (ret != ACT_P_CREATED) {\r\nipt_destroy_target(ipt->tcfi_t);\r\nkfree(ipt->tcfi_tname);\r\nkfree(ipt->tcfi_t);\r\n}\r\nipt->tcfi_tname = tname;\r\nipt->tcfi_t = t;\r\nipt->tcfi_hook = hook;\r\nspin_unlock_bh(&ipt->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(tn, *a);\r\nreturn ret;\r\nerr3:\r\nkfree(t);\r\nerr2:\r\nkfree(tname);\r\nerr1:\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_cleanup(*a, est);\r\nreturn err;\r\n}\r\nstatic int tcf_ipt_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a, int ovr,\r\nint bind)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, ipt_net_id);\r\nreturn __tcf_ipt_init(tn, nla, est, a, &act_ipt_ops, ovr, bind);\r\n}\r\nstatic int tcf_xt_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a, int ovr,\r\nint bind)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, xt_net_id);\r\nreturn __tcf_ipt_init(tn, nla, est, a, &act_xt_ops, ovr, bind);\r\n}\r\nstatic int tcf_ipt(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nint ret = 0, result = 0;\r\nstruct tcf_ipt *ipt = to_ipt(a);\r\nstruct xt_action_param par;\r\nstruct nf_hook_state state = {\r\n.net = dev_net(skb->dev),\r\n.in = skb->dev,\r\n.hook = ipt->tcfi_hook,\r\n.pf = NFPROTO_IPV4,\r\n};\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\nreturn TC_ACT_UNSPEC;\r\nspin_lock(&ipt->tcf_lock);\r\ntcf_lastuse_update(&ipt->tcf_tm);\r\nbstats_update(&ipt->tcf_bstats, skb);\r\npar.state = &state;\r\npar.target = ipt->tcfi_t->u.kernel.target;\r\npar.targinfo = ipt->tcfi_t->data;\r\nret = par.target->target(skb, &par);\r\nswitch (ret) {\r\ncase NF_ACCEPT:\r\nresult = TC_ACT_OK;\r\nbreak;\r\ncase NF_DROP:\r\nresult = TC_ACT_SHOT;\r\nipt->tcf_qstats.drops++;\r\nbreak;\r\ncase XT_CONTINUE:\r\nresult = TC_ACT_PIPE;\r\nbreak;\r\ndefault:\r\nnet_notice_ratelimited("tc filter: Bogus netfilter code %d assume ACCEPT\n",\r\nret);\r\nresult = TC_ACT_OK;\r\nbreak;\r\n}\r\nspin_unlock(&ipt->tcf_lock);\r\nreturn result;\r\n}\r\nstatic int tcf_ipt_dump(struct sk_buff *skb, struct tc_action *a, int bind,\r\nint ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_ipt *ipt = to_ipt(a);\r\nstruct xt_entry_target *t;\r\nstruct tcf_t tm;\r\nstruct tc_cnt c;\r\nt = kmemdup(ipt->tcfi_t, ipt->tcfi_t->u.user.target_size, GFP_ATOMIC);\r\nif (unlikely(!t))\r\ngoto nla_put_failure;\r\nc.bindcnt = ipt->tcf_bindcnt - bind;\r\nc.refcnt = ipt->tcf_refcnt - ref;\r\nstrcpy(t->u.user.name, ipt->tcfi_t->u.kernel.target->name);\r\nif (nla_put(skb, TCA_IPT_TARG, ipt->tcfi_t->u.user.target_size, t) ||\r\nnla_put_u32(skb, TCA_IPT_INDEX, ipt->tcf_index) ||\r\nnla_put_u32(skb, TCA_IPT_HOOK, ipt->tcfi_hook) ||\r\nnla_put(skb, TCA_IPT_CNT, sizeof(struct tc_cnt), &c) ||\r\nnla_put_string(skb, TCA_IPT_TABLE, ipt->tcfi_tname))\r\ngoto nla_put_failure;\r\ntcf_tm_dump(&tm, &ipt->tcf_tm);\r\nif (nla_put_64bit(skb, TCA_IPT_TM, sizeof(tm), &tm, TCA_IPT_PAD))\r\ngoto nla_put_failure;\r\nkfree(t);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nkfree(t);\r\nreturn -1;\r\n}\r\nstatic int tcf_ipt_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, ipt_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tcf_ipt_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, ipt_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int ipt_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, ipt_net_id);\r\nreturn tc_action_net_init(tn, &act_ipt_ops, IPT_TAB_MASK);\r\n}\r\nstatic void __net_exit ipt_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, ipt_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int tcf_xt_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, xt_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tcf_xt_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, xt_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int xt_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, xt_net_id);\r\nreturn tc_action_net_init(tn, &act_xt_ops, IPT_TAB_MASK);\r\n}\r\nstatic void __net_exit xt_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, xt_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int __init ipt_init_module(void)\r\n{\r\nint ret1, ret2;\r\nret1 = tcf_register_action(&act_xt_ops, &xt_net_ops);\r\nif (ret1 < 0)\r\npr_err("Failed to load xt action\n");\r\nret2 = tcf_register_action(&act_ipt_ops, &ipt_net_ops);\r\nif (ret2 < 0)\r\npr_err("Failed to load ipt action\n");\r\nif (ret1 < 0 && ret2 < 0) {\r\nreturn ret1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic void __exit ipt_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_ipt_ops, &ipt_net_ops);\r\ntcf_unregister_action(&act_xt_ops, &xt_net_ops);\r\n}
