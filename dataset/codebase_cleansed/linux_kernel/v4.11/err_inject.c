static ssize_t\r\nstore_call_start(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned int cpu=dev->id;\r\nunsigned long call_start = simple_strtoull(buf, NULL, 16);\r\n#ifdef ERR_INJ_DEBUG\r\nprintk(KERN_DEBUG "pal_mc_err_inject for cpu%d:\n", cpu);\r\nprintk(KERN_DEBUG "err_type_info=%lx,\n", err_type_info[cpu]);\r\nprintk(KERN_DEBUG "err_struct_info=%lx,\n", err_struct_info[cpu]);\r\nprintk(KERN_DEBUG "err_data_buffer=%lx, %lx, %lx.\n",\r\nerr_data_buffer[cpu].data1,\r\nerr_data_buffer[cpu].data2,\r\nerr_data_buffer[cpu].data3);\r\n#endif\r\nswitch (call_start) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nstatus[cpu]=ia64_pal_mc_error_inject_phys(err_type_info[cpu],\r\nerr_struct_info[cpu],\r\nia64_tpa(&err_data_buffer[cpu]),\r\n&capabilities[cpu],\r\n&resources[cpu]);\r\nbreak;\r\ncase 2:\r\nstatus[cpu]=ia64_pal_mc_error_inject_virt(err_type_info[cpu],\r\nerr_struct_info[cpu],\r\nia64_tpa(&err_data_buffer[cpu]),\r\n&capabilities[cpu],\r\n&resources[cpu]);\r\nbreak;\r\ndefault:\r\nstatus[cpu] = -EINVAL;\r\nbreak;\r\n}\r\n#ifdef ERR_INJ_DEBUG\r\nprintk(KERN_DEBUG "Returns: status=%d,\n", (int)status[cpu]);\r\nprintk(KERN_DEBUG "capapbilities=%lx,\n", capabilities[cpu]);\r\nprintk(KERN_DEBUG "resources=%lx\n", resources[cpu]);\r\n#endif\r\nreturn size;\r\n}\r\nstatic ssize_t\r\nshow_virtual_to_phys(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned int cpu=dev->id;\r\nreturn sprintf(buf, "%lx\n", phys_addr[cpu]);\r\n}\r\nstatic ssize_t\r\nstore_virtual_to_phys(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned int cpu=dev->id;\r\nu64 virt_addr=simple_strtoull(buf, NULL, 16);\r\nint ret;\r\nret = get_user_pages(virt_addr, 1, FOLL_WRITE, NULL, NULL);\r\nif (ret<=0) {\r\n#ifdef ERR_INJ_DEBUG\r\nprintk("Virtual address %lx is not existing.\n",virt_addr);\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nphys_addr[cpu] = ia64_tpa(virt_addr);\r\nreturn size;\r\n}\r\nstatic ssize_t\r\nshow_err_data_buffer(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned int cpu=dev->id;\r\nreturn sprintf(buf, "%lx, %lx, %lx\n",\r\nerr_data_buffer[cpu].data1,\r\nerr_data_buffer[cpu].data2,\r\nerr_data_buffer[cpu].data3);\r\n}\r\nstatic ssize_t\r\nstore_err_data_buffer(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nunsigned int cpu=dev->id;\r\nint ret;\r\n#ifdef ERR_INJ_DEBUG\r\nprintk("write err_data_buffer=[%lx,%lx,%lx] on cpu%d\n",\r\nerr_data_buffer[cpu].data1,\r\nerr_data_buffer[cpu].data2,\r\nerr_data_buffer[cpu].data3,\r\ncpu);\r\n#endif\r\nret=sscanf(buf, "%lx, %lx, %lx",\r\n&err_data_buffer[cpu].data1,\r\n&err_data_buffer[cpu].data2,\r\n&err_data_buffer[cpu].data3);\r\nif (ret!=ERR_DATA_BUFFER_SIZE)\r\nreturn -EINVAL;\r\nreturn size;\r\n}\r\nstatic int err_inject_add_dev(unsigned int cpu)\r\n{\r\nstruct device *sys_dev = get_cpu_device(cpu);\r\nreturn sysfs_create_group(&sys_dev->kobj, &err_inject_attr_group);\r\n}\r\nstatic int err_inject_remove_dev(unsigned int cpu)\r\n{\r\nstruct device *sys_dev = get_cpu_device(cpu);\r\nsysfs_remove_group(&sys_dev->kobj, &err_inject_attr_group);\r\nreturn 0;\r\n}\r\nstatic int __init err_inject_init(void)\r\n{\r\nint ret;\r\n#ifdef ERR_INJ_DEBUG\r\nprintk(KERN_INFO "Enter error injection driver.\n");\r\n#endif\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "ia64/err_inj:online",\r\nerr_inject_add_dev, err_inject_remove_dev);\r\nif (ret >= 0) {\r\nhp_online = ret;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit err_inject_exit(void)\r\n{\r\n#ifdef ERR_INJ_DEBUG\r\nprintk(KERN_INFO "Exit error injection driver.\n");\r\n#endif\r\ncpuhp_remove_state(hp_online);\r\n}
