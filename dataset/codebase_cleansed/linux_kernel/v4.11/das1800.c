static void das1800_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nunsigned short *array = data;\r\nunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\r\nunsigned int i;\r\nif (devpriv->ai_is_unipolar)\r\nreturn;\r\nfor (i = 0; i < num_samples; i++)\r\narray[i] = comedi_offset_munge(s, array[i]);\r\n}\r\nstatic void das1800_handle_fifo_half_full(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nunsigned int nsamples = comedi_nsamples_left(s, FIFO_SIZE / 2);\r\ninsw(dev->iobase + DAS1800_FIFO, devpriv->fifo_buf, nsamples);\r\ncomedi_buf_write_samples(s, devpriv->fifo_buf, nsamples);\r\n}\r\nstatic void das1800_handle_fifo_not_empty(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned short dpnt;\r\nwhile (inb(dev->iobase + DAS1800_STATUS) & FNE) {\r\ndpnt = inw(dev->iobase + DAS1800_FIFO);\r\ncomedi_buf_write_samples(s, &dpnt, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\nbreak;\r\n}\r\n}\r\nstatic void das1800_flush_dma_channel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_isadma_desc *desc)\r\n{\r\nunsigned int residue = comedi_isadma_disable(desc->chan);\r\nunsigned int nbytes = desc->size - residue;\r\nunsigned int nsamples;\r\nnsamples = comedi_bytes_to_samples(s, nbytes);\r\nnsamples = comedi_nsamples_left(s, nsamples);\r\ncomedi_buf_write_samples(s, desc->virt_addr, nsamples);\r\n}\r\nstatic void das1800_flush_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\r\ndas1800_flush_dma_channel(dev, s, desc);\r\nif (dual_dma) {\r\ndma->cur_dma = 1 - dma->cur_dma;\r\ndesc = &dma->desc[dma->cur_dma];\r\ndas1800_flush_dma_channel(dev, s, desc);\r\n}\r\ndas1800_handle_fifo_not_empty(dev, s);\r\n}\r\nstatic void das1800_handle_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int status)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\r\ndas1800_flush_dma_channel(dev, s, desc);\r\ncomedi_isadma_program(desc);\r\nif (status & DMATC) {\r\noutb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);\r\nif (dual_dma)\r\ndma->cur_dma = 1 - dma->cur_dma;\r\n}\r\n}\r\nstatic int das1800_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc;\r\nint i;\r\noutb(0x0, dev->iobase + DAS1800_STATUS);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_B);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_A);\r\nif (dma) {\r\nfor (i = 0; i < 2; i++) {\r\ndesc = &dma->desc[i];\r\nif (desc->chan)\r\ncomedi_isadma_disable(desc->chan);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void das1800_ai_handler(struct comedi_device *dev)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int status = inb(dev->iobase + DAS1800_STATUS);\r\noutb(ADC, dev->iobase + DAS1800_SELECT);\r\nif (devpriv->irq_dma_bits & DMA_ENABLED)\r\ndas1800_handle_dma(dev, s, status);\r\nelse if (status & FHF)\r\ndas1800_handle_fifo_half_full(dev, s);\r\nelse if (status & FNE)\r\ndas1800_handle_fifo_not_empty(dev, s);\r\nif (status & OVF) {\r\noutb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);\r\ndev_err(dev->class_dev, "FIFO overflow\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\ncomedi_handle_events(dev, s);\r\nreturn;\r\n}\r\nif (status & CT0TC) {\r\noutb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);\r\nif (devpriv->irq_dma_bits & DMA_ENABLED)\r\ndas1800_flush_dma(dev, s);\r\nelse\r\ndas1800_handle_fifo_not_empty(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n} else if (cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) {\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic int das1800_ai_poll(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndas1800_ai_handler(dev);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn comedi_buf_n_bytes_ready(s);\r\n}\r\nstatic irqreturn_t das1800_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned int status;\r\nif (!dev->attached) {\r\ndev_err(dev->class_dev, "premature interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&dev->spinlock);\r\nstatus = inb(dev->iobase + DAS1800_STATUS);\r\nif (!(status & INT)) {\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_NONE;\r\n}\r\noutb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);\r\ndas1800_ai_handler(dev);\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int das1800_ai_fixup_paced_timing(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int arg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nreturn comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\n}\r\nstatic int das1800_ai_fixup_burst_timing(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int arg = cmd->convert_arg;\r\nint err = 0;\r\nerr |= comedi_check_trigger_arg_max(&arg, 64000);\r\nswitch (cmd->flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\narg = DIV_ROUND_CLOSEST(arg, 1000);\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\narg = arg / 1000;\r\nbreak;\r\ncase CMDF_ROUND_UP:\r\narg = DIV_ROUND_UP(arg, 1000);\r\nbreak;\r\n}\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg * 1000);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->convert_arg * cmd->chanlist_len;\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\r\narg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nreturn err;\r\n}\r\nstatic int das1800_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int range = CR_RANGE(cmd->chanlist[0]);\r\nbool unipolar0 = comedi_range_is_unipolar(s, range);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nif (unipolar0 != comedi_range_is_unipolar(s, range)) {\r\ndev_dbg(dev->class_dev,\r\n"unipolar and bipolar ranges cannot be mixed in the chanlist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int das1800_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct das1800_board *board = dev->board_ptr;\r\nint err = 0;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src,\r\nTRIG_COUNT | TRIG_EXT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->convert_src != TRIG_TIMER)\r\nerr |= -EINVAL;\r\nif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg,\r\ncmd->stop_arg);\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg == TRIG_NOW)\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nerr |= das1800_ai_fixup_paced_timing(dev, cmd);\r\nelse\r\nerr |= das1800_ai_fixup_burst_timing(dev, cmd);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= das1800_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic unsigned char das1800_ai_chanspec_bits(struct comedi_subdevice *s,\r\nunsigned int chanspec)\r\n{\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nunsigned char bits;\r\nbits = UQEN;\r\nif (aref != AREF_DIFF)\r\nbits |= SD;\r\nif (aref == AREF_COMMON)\r\nbits |= CMEN;\r\nif (comedi_range_is_unipolar(s, range))\r\nbits |= UB;\r\nreturn bits;\r\n}\r\nstatic unsigned int das1800_ai_transfer_size(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int maxbytes,\r\nunsigned int ns)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int max_samples = comedi_bytes_to_samples(s, maxbytes);\r\nunsigned int samples;\r\nsamples = max_samples;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nif (cmd->convert_src == TRIG_TIMER)\r\nsamples = ns / cmd->convert_arg;\r\nbreak;\r\ncase TRIG_TIMER:\r\nsamples = ns / (cmd->scan_begin_arg * cmd->chanlist_len);\r\nbreak;\r\n}\r\nsamples = comedi_nsamples_left(s, samples);\r\nif (samples > max_samples)\r\nsamples = max_samples;\r\nif (samples < 1)\r\nsamples = 1;\r\nreturn comedi_samples_to_bytes(s, samples);\r\n}\r\nstatic void das1800_ai_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc;\r\nunsigned int bytes;\r\nif ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)\r\nreturn;\r\ndma->cur_dma = 0;\r\ndesc = &dma->desc[0];\r\nbytes = das1800_ai_transfer_size(dev, s, desc->maxsize, 300000000);\r\ndesc->size = bytes;\r\ncomedi_isadma_program(desc);\r\nif (devpriv->irq_dma_bits & DMA_DUAL) {\r\ndesc = &dma->desc[1];\r\ndesc->size = bytes;\r\ncomedi_isadma_program(desc);\r\n}\r\n}\r\nstatic void das1800_ai_set_chanlist(struct comedi_device *dev,\r\nunsigned int *chanlist, unsigned int len)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutb(QRAM, dev->iobase + DAS1800_SELECT);\r\noutb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\r\nfor (i = 0; i < len; i++) {\r\nunsigned int chan = CR_CHAN(chanlist[i]);\r\nunsigned int range = CR_RANGE(chanlist[i]);\r\nunsigned short val;\r\nval = chan | ((range & 0x3) << 8);\r\noutw(val, dev->iobase + DAS1800_QRAM);\r\n}\r\noutb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int das1800_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nint control_a, control_c;\r\nstruct comedi_async *async = s->async;\r\nconst struct comedi_cmd *cmd = &async->cmd;\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nif (cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY))\r\ndevpriv->irq_dma_bits &= ~DMA_ENABLED;\r\nelse\r\ndevpriv->irq_dma_bits |= devpriv->dma_bits;\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\ndevpriv->irq_dma_bits &= ~FIMD;\r\n} else {\r\ndevpriv->irq_dma_bits |= FIMD;\r\n}\r\ndas1800_ai_cancel(dev, s);\r\ndevpriv->ai_is_unipolar = comedi_range_is_unipolar(s, range0);\r\ncontrol_a = FFEN;\r\nif (cmd->stop_src == TRIG_EXT)\r\ncontrol_a |= ATEN;\r\nif (cmd->start_src == TRIG_EXT)\r\ncontrol_a |= TGEN | CGSL;\r\nelse\r\ncontrol_a |= CGEN;\r\nif (control_a & (ATEN | TGEN)) {\r\nif ((cmd->start_arg & CR_INVERT) || (cmd->stop_arg & CR_INVERT))\r\ncontrol_a |= TGPL;\r\n}\r\ncontrol_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ncontrol_c |= IPCLK;\r\n} else {\r\ncontrol_c |= XPCLK;\r\n}\r\n} else if (cmd->scan_begin_src == TRIG_TIMER) {\r\ncontrol_c |= BMDE | IPCLK;\r\n} else {\r\ncontrol_c |= BMDE | XPCLK;\r\n}\r\ndas1800_ai_set_chanlist(dev, cmd->chanlist, cmd->chanlist_len);\r\nif ((cmd->scan_begin_src == TRIG_FOLLOW ||\r\ncmd->scan_begin_src == TRIG_TIMER) &&\r\ncmd->convert_src == TRIG_TIMER) {\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\n}\r\nif (cmd->stop_src == TRIG_EXT)\r\ncomedi_8254_load(dev->pacer, 0, 1, I8254_MODE0 | I8254_BINARY);\r\ndas1800_ai_setup_dma(dev, s);\r\noutb(control_c, dev->iobase + DAS1800_CONTROL_C);\r\nif (control_c & BMDE) {\r\noutb(cmd->convert_arg / 1000 - 1,\r\ndev->iobase + DAS1800_BURST_RATE);\r\noutb(cmd->chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);\r\n}\r\noutb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);\r\noutb(control_a, dev->iobase + DAS1800_CONTROL_A);\r\noutb(CVEN, dev->iobase + DAS1800_STATUS);\r\nreturn 0;\r\n}\r\nstatic int das1800_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned char status;\r\nstatus = inb(dev->iobase + DAS1800_STATUS);\r\nif (status & FNE)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int das1800_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nbool is_unipolar = comedi_range_is_unipolar(s, range);\r\nint ret = 0;\r\nint n;\r\nunsigned short dpnt;\r\nunsigned long flags;\r\noutb(das1800_ai_chanspec_bits(s, insn->chanspec),\r\ndev->iobase + DAS1800_CONTROL_C);\r\noutb(CVEN, dev->iobase + DAS1800_STATUS);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_A);\r\noutb(FFEN, dev->iobase + DAS1800_CONTROL_A);\r\ndas1800_ai_set_chanlist(dev, &insn->chanspec, 1);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\noutb(ADC, dev->iobase + DAS1800_SELECT);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(0, dev->iobase + DAS1800_FIFO);\r\nret = comedi_timeout(dev, s, insn, das1800_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\ndpnt = inw(dev->iobase + DAS1800_FIFO);\r\nif (!is_unipolar)\r\ndpnt = comedi_offset_munge(s, dpnt);\r\ndata[n] = dpnt;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int das1800_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int update_chan = s->n_chan - 1;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\ns->readback[chan] = val;\r\nval = comedi_offset_munge(s, val);\r\noutb(DAC(chan), dev->iobase + DAS1800_SELECT);\r\noutw(val, dev->iobase + DAS1800_DAC);\r\nif (chan != update_chan) {\r\nval = comedi_offset_munge(s, s->readback[update_chan]);\r\noutb(DAC(update_chan), dev->iobase + DAS1800_SELECT);\r\noutw(val, dev->iobase + DAS1800_DAC);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn insn->n;\r\n}\r\nstatic int das1800_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;\r\ndata[0] = 0;\r\nreturn insn->n;\r\n}\r\nstatic int das1800_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutb(s->state, dev->iobase + DAS1800_DIGITAL);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void das1800_init_dma(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nunsigned int *dma_chan;\r\ndma_chan = &it->options[2];\r\nswitch ((dma_chan[0] & 0x7) | (dma_chan[1] << 4)) {\r\ncase 0x5:\r\ndevpriv->dma_bits = DMA_CH5;\r\nbreak;\r\ncase 0x6:\r\ndevpriv->dma_bits = DMA_CH6;\r\nbreak;\r\ncase 0x7:\r\ndevpriv->dma_bits = DMA_CH7;\r\nbreak;\r\ncase 0x65:\r\ndevpriv->dma_bits = DMA_CH5_CH6;\r\nbreak;\r\ncase 0x76:\r\ndevpriv->dma_bits = DMA_CH6_CH7;\r\nbreak;\r\ncase 0x57:\r\ndevpriv->dma_bits = DMA_CH7_CH5;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ndevpriv->dma = comedi_isadma_alloc(dev, dma_chan[1] ? 2 : 1,\r\ndma_chan[0], dma_chan[1],\r\nDMA_BUF_SIZE, COMEDI_ISADMA_READ);\r\nif (!devpriv->dma)\r\ndevpriv->dma_bits = 0;\r\n}\r\nstatic void das1800_free_dma(struct comedi_device *dev)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\nif (devpriv)\r\ncomedi_isadma_free(devpriv->dma);\r\n}\r\nstatic int das1800_probe(struct comedi_device *dev)\r\n{\r\nconst struct das1800_board *board = dev->board_ptr;\r\nunsigned char id;\r\nid = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;\r\nif (board) {\r\nif (board->id == id)\r\nreturn 0;\r\ndev_err(dev->class_dev,\r\n"probed id does not match board id (0x%x != 0x%x)\n",\r\nid, board->id);\r\nreturn -ENODEV;\r\n}\r\nswitch (id) {\r\ncase DAS1800_ID_ST_DA:\r\nboard = &das1800_boards[BOARD_DAS1801ST_DA];\r\nbreak;\r\ncase DAS1800_ID_HR_DA:\r\nboard = &das1800_boards[BOARD_DAS1802HR_DA];\r\nbreak;\r\ncase DAS1800_ID_AO:\r\nboard = &das1800_boards[BOARD_DAS1801AO];\r\nbreak;\r\ncase DAS1800_ID_HR:\r\nboard = &das1800_boards[BOARD_DAS1802HR];\r\nbreak;\r\ncase DAS1800_ID_ST:\r\nboard = &das1800_boards[BOARD_DAS1801ST];\r\nbreak;\r\ncase DAS1800_ID_HC:\r\nboard = &das1800_boards[BOARD_DAS1801HC];\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "invalid probe id 0x%x\n", id);\r\nreturn -ENODEV;\r\n}\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndev_warn(dev->class_dev,\r\n"probed id 0x%0x: %s series (not recommended)\n",\r\nid, board->name);\r\nreturn 0;\r\n}\r\nstatic int das1800_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct das1800_board *board;\r\nstruct das1800_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nunsigned int irq = it->options[1];\r\nbool is_16bit;\r\nint ret;\r\nint i;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0], DAS1800_SIZE);\r\nif (ret)\r\nreturn ret;\r\nret = das1800_probe(dev);\r\nif (ret)\r\nreturn ret;\r\nboard = dev->board_ptr;\r\nis_16bit = board->id == DAS1800_ID_HR || board->id == DAS1800_ID_HR_DA;\r\nif (board->id == DAS1800_ID_AO) {\r\nunsigned long iobase2 = dev->iobase + IOBASE2;\r\nret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->iobase2 = iobase2;\r\n}\r\nif (irq == 3 || irq == 5 || irq == 7 || irq == 10 || irq == 11 ||\r\nirq == 15) {\r\nret = request_irq(irq, das1800_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0) {\r\ndev->irq = irq;\r\nswitch (irq) {\r\ncase 3:\r\ndevpriv->irq_dma_bits |= 0x8;\r\nbreak;\r\ncase 5:\r\ndevpriv->irq_dma_bits |= 0x10;\r\nbreak;\r\ncase 7:\r\ndevpriv->irq_dma_bits |= 0x18;\r\nbreak;\r\ncase 10:\r\ndevpriv->irq_dma_bits |= 0x28;\r\nbreak;\r\ncase 11:\r\ndevpriv->irq_dma_bits |= 0x30;\r\nbreak;\r\ncase 15:\r\ndevpriv->irq_dma_bits |= 0x38;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (dev->irq & it->options[2])\r\ndas1800_init_dma(dev, it);\r\ndevpriv->fifo_buf = kmalloc_array(FIFO_SIZE,\r\nsizeof(*devpriv->fifo_buf),\r\nGFP_KERNEL);\r\nif (!devpriv->fifo_buf)\r\nreturn -ENOMEM;\r\ndev->pacer = comedi_8254_init(dev->iobase + DAS1800_COUNTER,\r\nI8254_OSC_BASE_5MHZ, I8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;\r\nif (board->id != DAS1800_ID_HC)\r\ns->subdev_flags |= SDF_COMMON;\r\ns->n_chan = (board->id == DAS1800_ID_HC) ? 64 : 256;\r\ns->maxdata = is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = board->is_01_series ? &das1801_ai_range\r\n: &das1802_ai_range;\r\ns->insn_read = das1800_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->do_cmd = das1800_ai_cmd;\r\ns->do_cmdtest = das1800_ai_cmdtest;\r\ns->poll = das1800_ai_poll;\r\ns->cancel = das1800_ai_cancel;\r\ns->munge = das1800_ai_munge;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->id == DAS1800_ID_ST_DA || board->id == DAS1800_ID_HR_DA) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = (board->id == DAS1800_ID_ST_DA) ? 4 : 2;\r\ns->maxdata = is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = das1800_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\noutb(DAC(i), dev->iobase + DAS1800_SELECT);\r\noutw(0, dev->iobase + DAS1800_DAC);\r\n}\r\n} else if (board->id == DAS1800_ID_AO) {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das1800_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = (board->id == DAS1800_ID_HC) ? 8 : 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das1800_do_insn_bits;\r\ndas1800_ai_cancel(dev, dev->read_subdev);\r\noutb(0, dev->iobase + DAS1800_DIGITAL);\r\nreturn 0;\r\n}\r\nstatic void das1800_detach(struct comedi_device *dev)\r\n{\r\nstruct das1800_private *devpriv = dev->private;\r\ndas1800_free_dma(dev);\r\nif (devpriv) {\r\nkfree(devpriv->fifo_buf);\r\nif (devpriv->iobase2)\r\nrelease_region(devpriv->iobase2, DAS1800_SIZE);\r\n}\r\ncomedi_legacy_detach(dev);\r\n}
