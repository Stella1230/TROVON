static inline u32 bcm2835aux_rd(struct bcm2835aux_spi *bs, unsigned reg)\r\n{\r\nreturn readl(bs->regs + reg);\r\n}\r\nstatic inline void bcm2835aux_wr(struct bcm2835aux_spi *bs, unsigned reg,\r\nu32 val)\r\n{\r\nwritel(val, bs->regs + reg);\r\n}\r\nstatic inline void bcm2835aux_rd_fifo(struct bcm2835aux_spi *bs)\r\n{\r\nu32 data;\r\nint count = min(bs->rx_len, 3);\r\ndata = bcm2835aux_rd(bs, BCM2835_AUX_SPI_IO);\r\nif (bs->rx_buf) {\r\nswitch (count) {\r\ncase 4:\r\n*bs->rx_buf++ = (data >> 24) & 0xff;\r\ncase 3:\r\n*bs->rx_buf++ = (data >> 16) & 0xff;\r\ncase 2:\r\n*bs->rx_buf++ = (data >> 8) & 0xff;\r\ncase 1:\r\n*bs->rx_buf++ = (data >> 0) & 0xff;\r\n}\r\n}\r\nbs->rx_len -= count;\r\nbs->pending -= count;\r\n}\r\nstatic inline void bcm2835aux_wr_fifo(struct bcm2835aux_spi *bs)\r\n{\r\nu32 data;\r\nu8 byte;\r\nint count;\r\nint i;\r\ncount = min(bs->tx_len, 3);\r\ndata = 0;\r\nfor (i = 0; i < count; i++) {\r\nbyte = bs->tx_buf ? *bs->tx_buf++ : 0;\r\ndata |= byte << (8 * (2 - i));\r\n}\r\ndata |= (count * 8) << 24;\r\nbs->tx_len -= count;\r\nbs->pending += count;\r\nif (bs->tx_len)\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_TXHOLD, data);\r\nelse\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_IO, data);\r\n}\r\nstatic void bcm2835aux_spi_reset_hw(struct bcm2835aux_spi *bs)\r\n{\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, 0);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0,\r\nBCM2835_AUX_SPI_CNTL0_CLEARFIFO);\r\n}\r\nstatic irqreturn_t bcm2835aux_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nirqreturn_t ret = IRQ_NONE;\r\nwhile (bs->rx_len &&\r\n(!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\r\nBCM2835_AUX_SPI_STAT_RX_EMPTY))) {\r\nbcm2835aux_rd_fifo(bs);\r\nret = IRQ_HANDLED;\r\n}\r\nwhile (bs->tx_len &&\r\n(bs->pending < 12) &&\r\n(!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\r\nBCM2835_AUX_SPI_STAT_TX_FULL))) {\r\nbcm2835aux_wr_fifo(bs);\r\nret = IRQ_HANDLED;\r\n}\r\nwhile (bs->rx_len &&\r\n(!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\r\nBCM2835_AUX_SPI_STAT_BUSY))) {\r\nbcm2835aux_rd_fifo(bs);\r\nret = IRQ_HANDLED;\r\n}\r\nif (!bs->tx_len) {\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1] |\r\nBCM2835_AUX_SPI_CNTL1_IDLE);\r\n}\r\nif (!bs->rx_len) {\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\r\ncomplete(&master->xfer_completion);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __bcm2835aux_spi_transfer_one_irq(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1] |\r\nBCM2835_AUX_SPI_CNTL1_TXEMPTY |\r\nBCM2835_AUX_SPI_CNTL1_IDLE);\r\nreturn 1;\r\n}\r\nstatic int bcm2835aux_spi_transfer_one_irq(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\r\nwhile ((bs->tx_len) &&\r\n(bs->pending < 12) &&\r\n(!(bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT) &\r\nBCM2835_AUX_SPI_STAT_TX_FULL))) {\r\nbcm2835aux_wr_fifo(bs);\r\n}\r\nreturn __bcm2835aux_spi_transfer_one_irq(master, spi, tfr);\r\n}\r\nstatic int bcm2835aux_spi_transfer_one_poll(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nunsigned long timeout;\r\nu32 stat;\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\r\ntimeout = jiffies + BCM2835_AUX_SPI_POLLING_JIFFIES;\r\nwhile (bs->rx_len) {\r\nstat = bcm2835aux_rd(bs, BCM2835_AUX_SPI_STAT);\r\nif ((bs->tx_len) && (!(stat & BCM2835_AUX_SPI_STAT_TX_FULL))) {\r\nbcm2835aux_wr_fifo(bs);\r\ncontinue;\r\n}\r\nif (!(stat & BCM2835_AUX_SPI_STAT_RX_EMPTY)) {\r\nbcm2835aux_rd_fifo(bs);\r\ncontinue;\r\n}\r\nif (!(stat & BCM2835_AUX_SPI_STAT_BUSY)) {\r\nbcm2835aux_rd_fifo(bs);\r\ncontinue;\r\n}\r\nif (bs->rx_len && time_after(jiffies, timeout)) {\r\ndev_dbg_ratelimited(&spi->dev,\r\n"timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\n",\r\njiffies - timeout,\r\nbs->tx_len, bs->rx_len);\r\nreturn __bcm2835aux_spi_transfer_one_irq(master,\r\nspi, tfr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835aux_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nunsigned long spi_hz, clk_hz, speed;\r\nunsigned long spi_used_hz;\r\nunsigned long long xfer_time_us;\r\nspi_hz = tfr->speed_hz;\r\nclk_hz = clk_get_rate(bs->clk);\r\nif (spi_hz >= clk_hz / 2) {\r\nspeed = 0;\r\n} else if (spi_hz) {\r\nspeed = DIV_ROUND_UP(clk_hz, 2 * spi_hz) - 1;\r\nif (speed > BCM2835_AUX_SPI_CNTL0_SPEED_MAX)\r\nspeed = BCM2835_AUX_SPI_CNTL0_SPEED_MAX;\r\n} else {\r\nspeed = BCM2835_AUX_SPI_CNTL0_SPEED_MAX;\r\n}\r\nbs->cntl[0] &= ~(BCM2835_AUX_SPI_CNTL0_SPEED);\r\nbs->cntl[0] |= speed << BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT;\r\nspi_used_hz = clk_hz / (2 * (speed + 1));\r\nbs->tx_buf = tfr->tx_buf;\r\nbs->rx_buf = tfr->rx_buf;\r\nbs->tx_len = tfr->len;\r\nbs->rx_len = tfr->len;\r\nbs->pending = 0;\r\nxfer_time_us = tfr->len * 9 * 1000000;\r\ndo_div(xfer_time_us, spi_used_hz);\r\nif (xfer_time_us < BCM2835_AUX_SPI_POLLING_LIMIT_US)\r\nreturn bcm2835aux_spi_transfer_one_poll(master, spi, tfr);\r\nreturn bcm2835aux_spi_transfer_one_irq(master, spi, tfr);\r\n}\r\nstatic int bcm2835aux_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbs->cntl[0] = BCM2835_AUX_SPI_CNTL0_ENABLE |\r\nBCM2835_AUX_SPI_CNTL0_VAR_WIDTH |\r\nBCM2835_AUX_SPI_CNTL0_MSBF_OUT;\r\nbs->cntl[1] = BCM2835_AUX_SPI_CNTL1_MSBF_IN;\r\nif (spi->mode & SPI_CPOL) {\r\nbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_CPOL;\r\nbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_OUT_RISING;\r\n} else {\r\nbs->cntl[0] |= BCM2835_AUX_SPI_CNTL0_IN_RISING;\r\n}\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL1, bs->cntl[1]);\r\nbcm2835aux_wr(bs, BCM2835_AUX_SPI_CNTL0, bs->cntl[0]);\r\nreturn 0;\r\n}\r\nstatic int bcm2835aux_spi_unprepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbcm2835aux_spi_reset_hw(bs);\r\nreturn 0;\r\n}\r\nstatic void bcm2835aux_spi_handle_err(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbcm2835aux_spi_reset_hw(bs);\r\n}\r\nstatic int bcm2835aux_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct bcm2835aux_spi *bs;\r\nstruct resource *res;\r\nunsigned long clk_hz;\r\nint err;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*bs));\r\nif (!master) {\r\ndev_err(&pdev->dev, "spi_alloc_master() failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nmaster->mode_bits = (SPI_CPOL | SPI_CS_HIGH | SPI_NO_CS);\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->num_chipselect = -1;\r\nmaster->transfer_one = bcm2835aux_spi_transfer_one;\r\nmaster->handle_err = bcm2835aux_spi_handle_err;\r\nmaster->prepare_message = bcm2835aux_spi_prepare_message;\r\nmaster->unprepare_message = bcm2835aux_spi_unprepare_message;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nbs = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbs->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(bs->regs)) {\r\nerr = PTR_ERR(bs->regs);\r\ngoto out_master_put;\r\n}\r\nbs->clk = devm_clk_get(&pdev->dev, NULL);\r\nif ((!bs->clk) || (IS_ERR(bs->clk))) {\r\nerr = PTR_ERR(bs->clk);\r\ndev_err(&pdev->dev, "could not get clk: %d\n", err);\r\ngoto out_master_put;\r\n}\r\nbs->irq = platform_get_irq(pdev, 0);\r\nif (bs->irq <= 0) {\r\ndev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);\r\nerr = bs->irq ? bs->irq : -ENODEV;\r\ngoto out_master_put;\r\n}\r\nerr = clk_prepare_enable(bs->clk);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not prepare clock: %d\n", err);\r\ngoto out_master_put;\r\n}\r\nclk_hz = clk_get_rate(bs->clk);\r\nif (!clk_hz) {\r\ndev_err(&pdev->dev, "clock returns 0 Hz\n");\r\nerr = -ENODEV;\r\ngoto out_clk_disable;\r\n}\r\nbcm2835aux_spi_reset_hw(bs);\r\nerr = devm_request_irq(&pdev->dev, bs->irq,\r\nbcm2835aux_spi_interrupt,\r\nIRQF_SHARED,\r\ndev_name(&pdev->dev), master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not request IRQ: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not register SPI master: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable_unprepare(bs->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int bcm2835aux_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bcm2835aux_spi *bs = spi_master_get_devdata(master);\r\nbcm2835aux_spi_reset_hw(bs);\r\nclk_disable_unprepare(bs->clk);\r\nreturn 0;\r\n}
