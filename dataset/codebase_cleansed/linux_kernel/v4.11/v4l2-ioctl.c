const char *v4l2_norm_to_name(v4l2_std_id id)\r\n{\r\nu32 myid = id;\r\nint i;\r\nBUG_ON(myid != id);\r\nfor (i = 0; standards[i].std; i++)\r\nif (myid == standards[i].std)\r\nbreak;\r\nreturn standards[i].descr;\r\n}\r\nvoid v4l2_video_std_frame_period(int id, struct v4l2_fract *frameperiod)\r\n{\r\nif (id & V4L2_STD_525_60) {\r\nframeperiod->numerator = 1001;\r\nframeperiod->denominator = 30000;\r\n} else {\r\nframeperiod->numerator = 1;\r\nframeperiod->denominator = 25;\r\n}\r\n}\r\nint v4l2_video_std_construct(struct v4l2_standard *vs,\r\nint id, const char *name)\r\n{\r\nvs->id = id;\r\nv4l2_video_std_frame_period(id, &vs->frameperiod);\r\nvs->framelines = (id & V4L2_STD_525_60) ? 525 : 625;\r\nstrlcpy(vs->name, name, sizeof(vs->name));\r\nreturn 0;\r\n}\r\nstatic void v4l_print_querycap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_capability *p = arg;\r\npr_cont("driver=%.*s, card=%.*s, bus=%.*s, version=0x%08x, capabilities=0x%08x, device_caps=0x%08x\n",\r\n(int)sizeof(p->driver), p->driver,\r\n(int)sizeof(p->card), p->card,\r\n(int)sizeof(p->bus_info), p->bus_info,\r\np->version, p->capabilities, p->device_caps);\r\n}\r\nstatic void v4l_print_enuminput(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_input *p = arg;\r\npr_cont("index=%u, name=%.*s, type=%u, audioset=0x%x, tuner=%u, std=0x%08Lx, status=0x%x, capabilities=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\r\np->tuner, (unsigned long long)p->std, p->status,\r\np->capabilities);\r\n}\r\nstatic void v4l_print_enumoutput(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_output *p = arg;\r\npr_cont("index=%u, name=%.*s, type=%u, audioset=0x%x, modulator=%u, std=0x%08Lx, capabilities=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\r\np->modulator, (unsigned long long)p->std, p->capabilities);\r\n}\r\nstatic void v4l_print_audio(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_audio *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, mode=0x%x\n", p->index, p->mode);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, mode=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name,\r\np->capability, p->mode);\r\n}\r\nstatic void v4l_print_audioout(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_audioout *p = arg;\r\nif (write_only)\r\npr_cont("index=%u\n", p->index);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, mode=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name,\r\np->capability, p->mode);\r\n}\r\nstatic void v4l_print_fmtdesc(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_fmtdesc *p = arg;\r\npr_cont("index=%u, type=%s, flags=0x%x, pixelformat=%c%c%c%c, description='%.*s'\n",\r\np->index, prt_names(p->type, v4l2_type_names),\r\np->flags, (p->pixelformat & 0xff),\r\n(p->pixelformat >> 8) & 0xff,\r\n(p->pixelformat >> 16) & 0xff,\r\n(p->pixelformat >> 24) & 0xff,\r\n(int)sizeof(p->description), p->description);\r\n}\r\nstatic void v4l_print_format(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_format *p = arg;\r\nconst struct v4l2_pix_format *pix;\r\nconst struct v4l2_pix_format_mplane *mp;\r\nconst struct v4l2_vbi_format *vbi;\r\nconst struct v4l2_sliced_vbi_format *sliced;\r\nconst struct v4l2_window *win;\r\nconst struct v4l2_sdr_format *sdr;\r\nunsigned i;\r\npr_cont("type=%s", prt_names(p->type, v4l2_type_names));\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\npix = &p->fmt.pix;\r\npr_cont(", width=%u, height=%u, pixelformat=%c%c%c%c, field=%s, bytesperline=%u, sizeimage=%u, colorspace=%d, flags=0x%x, ycbcr_enc=%u, quantization=%u, xfer_func=%u\n",\r\npix->width, pix->height,\r\n(pix->pixelformat & 0xff),\r\n(pix->pixelformat >> 8) & 0xff,\r\n(pix->pixelformat >> 16) & 0xff,\r\n(pix->pixelformat >> 24) & 0xff,\r\nprt_names(pix->field, v4l2_field_names),\r\npix->bytesperline, pix->sizeimage,\r\npix->colorspace, pix->flags, pix->ycbcr_enc,\r\npix->quantization, pix->xfer_func);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nmp = &p->fmt.pix_mp;\r\npr_cont(", width=%u, height=%u, format=%c%c%c%c, field=%s, colorspace=%d, num_planes=%u, flags=0x%x, ycbcr_enc=%u, quantization=%u, xfer_func=%u\n",\r\nmp->width, mp->height,\r\n(mp->pixelformat & 0xff),\r\n(mp->pixelformat >> 8) & 0xff,\r\n(mp->pixelformat >> 16) & 0xff,\r\n(mp->pixelformat >> 24) & 0xff,\r\nprt_names(mp->field, v4l2_field_names),\r\nmp->colorspace, mp->num_planes, mp->flags,\r\nmp->ycbcr_enc, mp->quantization, mp->xfer_func);\r\nfor (i = 0; i < mp->num_planes; i++)\r\nprintk(KERN_DEBUG "plane %u: bytesperline=%u sizeimage=%u\n", i,\r\nmp->plane_fmt[i].bytesperline,\r\nmp->plane_fmt[i].sizeimage);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nwin = &p->fmt.win;\r\npr_cont(", wxh=%dx%d, x,y=%d,%d, field=%s, chromakey=0x%08x, clipcount=%u, clips=%p, bitmap=%p, global_alpha=0x%02x\n",\r\nwin->w.width, win->w.height, win->w.left, win->w.top,\r\nprt_names(win->field, v4l2_field_names),\r\nwin->chromakey, win->clipcount, win->clips,\r\nwin->bitmap, win->global_alpha);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nvbi = &p->fmt.vbi;\r\npr_cont(", sampling_rate=%u, offset=%u, samples_per_line=%u, sample_format=%c%c%c%c, start=%u,%u, count=%u,%u\n",\r\nvbi->sampling_rate, vbi->offset,\r\nvbi->samples_per_line,\r\n(vbi->sample_format & 0xff),\r\n(vbi->sample_format >> 8) & 0xff,\r\n(vbi->sample_format >> 16) & 0xff,\r\n(vbi->sample_format >> 24) & 0xff,\r\nvbi->start[0], vbi->start[1],\r\nvbi->count[0], vbi->count[1]);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nsliced = &p->fmt.sliced;\r\npr_cont(", service_set=0x%08x, io_size=%d\n",\r\nsliced->service_set, sliced->io_size);\r\nfor (i = 0; i < 24; i++)\r\nprintk(KERN_DEBUG "line[%02u]=0x%04x, 0x%04x\n", i,\r\nsliced->service_lines[0][i],\r\nsliced->service_lines[1][i]);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nsdr = &p->fmt.sdr;\r\npr_cont(", pixelformat=%c%c%c%c\n",\r\n(sdr->pixelformat >> 0) & 0xff,\r\n(sdr->pixelformat >> 8) & 0xff,\r\n(sdr->pixelformat >> 16) & 0xff,\r\n(sdr->pixelformat >> 24) & 0xff);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_framebuffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_framebuffer *p = arg;\r\npr_cont("capability=0x%x, flags=0x%x, base=0x%p, width=%u, height=%u, pixelformat=%c%c%c%c, bytesperline=%u, sizeimage=%u, colorspace=%d\n",\r\np->capability, p->flags, p->base,\r\np->fmt.width, p->fmt.height,\r\n(p->fmt.pixelformat & 0xff),\r\n(p->fmt.pixelformat >> 8) & 0xff,\r\n(p->fmt.pixelformat >> 16) & 0xff,\r\n(p->fmt.pixelformat >> 24) & 0xff,\r\np->fmt.bytesperline, p->fmt.sizeimage,\r\np->fmt.colorspace);\r\n}\r\nstatic void v4l_print_buftype(const void *arg, bool write_only)\r\n{\r\npr_cont("type=%s\n", prt_names(*(u32 *)arg, v4l2_type_names));\r\n}\r\nstatic void v4l_print_modulator(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_modulator *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, txsubchans=0x%x\n", p->index, p->txsubchans);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, rangelow=%u, rangehigh=%u, txsubchans=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->capability,\r\np->rangelow, p->rangehigh, p->txsubchans);\r\n}\r\nstatic void v4l_print_tuner(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_tuner *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, audmode=%u\n", p->index, p->audmode);\r\nelse\r\npr_cont("index=%u, name=%.*s, type=%u, capability=0x%x, rangelow=%u, rangehigh=%u, signal=%u, afc=%d, rxsubchans=0x%x, audmode=%u\n",\r\np->index, (int)sizeof(p->name), p->name, p->type,\r\np->capability, p->rangelow,\r\np->rangehigh, p->signal, p->afc,\r\np->rxsubchans, p->audmode);\r\n}\r\nstatic void v4l_print_frequency(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frequency *p = arg;\r\npr_cont("tuner=%u, type=%u, frequency=%u\n",\r\np->tuner, p->type, p->frequency);\r\n}\r\nstatic void v4l_print_standard(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_standard *p = arg;\r\npr_cont("index=%u, id=0x%Lx, name=%.*s, fps=%u/%u, framelines=%u\n",\r\np->index,\r\n(unsigned long long)p->id, (int)sizeof(p->name), p->name,\r\np->frameperiod.numerator,\r\np->frameperiod.denominator,\r\np->framelines);\r\n}\r\nstatic void v4l_print_std(const void *arg, bool write_only)\r\n{\r\npr_cont("std=0x%08Lx\n", *(const long long unsigned *)arg);\r\n}\r\nstatic void v4l_print_hw_freq_seek(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_hw_freq_seek *p = arg;\r\npr_cont("tuner=%u, type=%u, seek_upward=%u, wrap_around=%u, spacing=%u, rangelow=%u, rangehigh=%u\n",\r\np->tuner, p->type, p->seek_upward, p->wrap_around, p->spacing,\r\np->rangelow, p->rangehigh);\r\n}\r\nstatic void v4l_print_requestbuffers(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_requestbuffers *p = arg;\r\npr_cont("count=%d, type=%s, memory=%s\n",\r\np->count,\r\nprt_names(p->type, v4l2_type_names),\r\nprt_names(p->memory, v4l2_memory_names));\r\n}\r\nstatic void v4l_print_buffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_buffer *p = arg;\r\nconst struct v4l2_timecode *tc = &p->timecode;\r\nconst struct v4l2_plane *plane;\r\nint i;\r\npr_cont("%02ld:%02d:%02d.%08ld index=%d, type=%s, flags=0x%08x, field=%s, sequence=%d, memory=%s",\r\np->timestamp.tv_sec / 3600,\r\n(int)(p->timestamp.tv_sec / 60) % 60,\r\n(int)(p->timestamp.tv_sec % 60),\r\n(long)p->timestamp.tv_usec,\r\np->index,\r\nprt_names(p->type, v4l2_type_names),\r\np->flags, prt_names(p->field, v4l2_field_names),\r\np->sequence, prt_names(p->memory, v4l2_memory_names));\r\nif (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {\r\npr_cont("\n");\r\nfor (i = 0; i < p->length; ++i) {\r\nplane = &p->m.planes[i];\r\nprintk(KERN_DEBUG\r\n"plane %d: bytesused=%d, data_offset=0x%08x, offset/userptr=0x%lx, length=%d\n",\r\ni, plane->bytesused, plane->data_offset,\r\nplane->m.userptr, plane->length);\r\n}\r\n} else {\r\npr_cont(", bytesused=%d, offset/userptr=0x%lx, length=%d\n",\r\np->bytesused, p->m.userptr, p->length);\r\n}\r\nprintk(KERN_DEBUG "timecode=%02d:%02d:%02d type=%d, flags=0x%08x, frames=%d, userbits=0x%08x\n",\r\ntc->hours, tc->minutes, tc->seconds,\r\ntc->type, tc->flags, tc->frames, *(__u32 *)tc->userbits);\r\n}\r\nstatic void v4l_print_exportbuffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_exportbuffer *p = arg;\r\npr_cont("fd=%d, type=%s, index=%u, plane=%u, flags=0x%08x\n",\r\np->fd, prt_names(p->type, v4l2_type_names),\r\np->index, p->plane, p->flags);\r\n}\r\nstatic void v4l_print_create_buffers(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_create_buffers *p = arg;\r\npr_cont("index=%d, count=%d, memory=%s, ",\r\np->index, p->count,\r\nprt_names(p->memory, v4l2_memory_names));\r\nv4l_print_format(&p->format, write_only);\r\n}\r\nstatic void v4l_print_streamparm(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_streamparm *p = arg;\r\npr_cont("type=%s", prt_names(p->type, v4l2_type_names));\r\nif (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\np->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nconst struct v4l2_captureparm *c = &p->parm.capture;\r\npr_cont(", capability=0x%x, capturemode=0x%x, timeperframe=%d/%d, extendedmode=%d, readbuffers=%d\n",\r\nc->capability, c->capturemode,\r\nc->timeperframe.numerator, c->timeperframe.denominator,\r\nc->extendedmode, c->readbuffers);\r\n} else if (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\np->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nconst struct v4l2_outputparm *c = &p->parm.output;\r\npr_cont(", capability=0x%x, outputmode=0x%x, timeperframe=%d/%d, extendedmode=%d, writebuffers=%d\n",\r\nc->capability, c->outputmode,\r\nc->timeperframe.numerator, c->timeperframe.denominator,\r\nc->extendedmode, c->writebuffers);\r\n} else {\r\npr_cont("\n");\r\n}\r\n}\r\nstatic void v4l_print_queryctrl(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_queryctrl *p = arg;\r\npr_cont("id=0x%x, type=%d, name=%.*s, min/max=%d/%d, step=%d, default=%d, flags=0x%08x\n",\r\np->id, p->type, (int)sizeof(p->name), p->name,\r\np->minimum, p->maximum,\r\np->step, p->default_value, p->flags);\r\n}\r\nstatic void v4l_print_query_ext_ctrl(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_query_ext_ctrl *p = arg;\r\npr_cont("id=0x%x, type=%d, name=%.*s, min/max=%lld/%lld, step=%lld, default=%lld, flags=0x%08x, elem_size=%u, elems=%u, nr_of_dims=%u, dims=%u,%u,%u,%u\n",\r\np->id, p->type, (int)sizeof(p->name), p->name,\r\np->minimum, p->maximum,\r\np->step, p->default_value, p->flags,\r\np->elem_size, p->elems, p->nr_of_dims,\r\np->dims[0], p->dims[1], p->dims[2], p->dims[3]);\r\n}\r\nstatic void v4l_print_querymenu(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_querymenu *p = arg;\r\npr_cont("id=0x%x, index=%d\n", p->id, p->index);\r\n}\r\nstatic void v4l_print_control(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_control *p = arg;\r\npr_cont("id=0x%x, value=%d\n", p->id, p->value);\r\n}\r\nstatic void v4l_print_ext_controls(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_ext_controls *p = arg;\r\nint i;\r\npr_cont("which=0x%x, count=%d, error_idx=%d",\r\np->which, p->count, p->error_idx);\r\nfor (i = 0; i < p->count; i++) {\r\nif (!p->controls[i].size)\r\npr_cont(", id/val=0x%x/0x%x",\r\np->controls[i].id, p->controls[i].value);\r\nelse\r\npr_cont(", id/size=0x%x/%u",\r\np->controls[i].id, p->controls[i].size);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void v4l_print_cropcap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_cropcap *p = arg;\r\npr_cont("type=%s, bounds wxh=%dx%d, x,y=%d,%d, defrect wxh=%dx%d, x,y=%d,%d, pixelaspect %d/%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->bounds.width, p->bounds.height,\r\np->bounds.left, p->bounds.top,\r\np->defrect.width, p->defrect.height,\r\np->defrect.left, p->defrect.top,\r\np->pixelaspect.numerator, p->pixelaspect.denominator);\r\n}\r\nstatic void v4l_print_crop(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_crop *p = arg;\r\npr_cont("type=%s, wxh=%dx%d, x,y=%d,%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->c.width, p->c.height,\r\np->c.left, p->c.top);\r\n}\r\nstatic void v4l_print_selection(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_selection *p = arg;\r\npr_cont("type=%s, target=%d, flags=0x%x, wxh=%dx%d, x,y=%d,%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->target, p->flags,\r\np->r.width, p->r.height, p->r.left, p->r.top);\r\n}\r\nstatic void v4l_print_jpegcompression(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_jpegcompression *p = arg;\r\npr_cont("quality=%d, APPn=%d, APP_len=%d, COM_len=%d, jpeg_markers=0x%x\n",\r\np->quality, p->APPn, p->APP_len,\r\np->COM_len, p->jpeg_markers);\r\n}\r\nstatic void v4l_print_enc_idx(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_enc_idx *p = arg;\r\npr_cont("entries=%d, entries_cap=%d\n",\r\np->entries, p->entries_cap);\r\n}\r\nstatic void v4l_print_encoder_cmd(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_encoder_cmd *p = arg;\r\npr_cont("cmd=%d, flags=0x%x\n",\r\np->cmd, p->flags);\r\n}\r\nstatic void v4l_print_decoder_cmd(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_decoder_cmd *p = arg;\r\npr_cont("cmd=%d, flags=0x%x\n", p->cmd, p->flags);\r\nif (p->cmd == V4L2_DEC_CMD_START)\r\npr_info("speed=%d, format=%u\n",\r\np->start.speed, p->start.format);\r\nelse if (p->cmd == V4L2_DEC_CMD_STOP)\r\npr_info("pts=%llu\n", p->stop.pts);\r\n}\r\nstatic void v4l_print_dbg_chip_info(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dbg_chip_info *p = arg;\r\npr_cont("type=%u, ", p->match.type);\r\nif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\r\npr_cont("name=%.*s, ",\r\n(int)sizeof(p->match.name), p->match.name);\r\nelse\r\npr_cont("addr=%u, ", p->match.addr);\r\npr_cont("name=%.*s\n", (int)sizeof(p->name), p->name);\r\n}\r\nstatic void v4l_print_dbg_register(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dbg_register *p = arg;\r\npr_cont("type=%u, ", p->match.type);\r\nif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\r\npr_cont("name=%.*s, ",\r\n(int)sizeof(p->match.name), p->match.name);\r\nelse\r\npr_cont("addr=%u, ", p->match.addr);\r\npr_cont("reg=0x%llx, val=0x%llx\n",\r\np->reg, p->val);\r\n}\r\nstatic void v4l_print_dv_timings(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dv_timings *p = arg;\r\nswitch (p->type) {\r\ncase V4L2_DV_BT_656_1120:\r\npr_cont("type=bt-656/1120, interlaced=%u, pixelclock=%llu, width=%u, height=%u, polarities=0x%x, hfrontporch=%u, hsync=%u, hbackporch=%u, vfrontporch=%u, vsync=%u, vbackporch=%u, il_vfrontporch=%u, il_vsync=%u, il_vbackporch=%u, standards=0x%x, flags=0x%x\n",\r\np->bt.interlaced, p->bt.pixelclock,\r\np->bt.width, p->bt.height,\r\np->bt.polarities, p->bt.hfrontporch,\r\np->bt.hsync, p->bt.hbackporch,\r\np->bt.vfrontporch, p->bt.vsync,\r\np->bt.vbackporch, p->bt.il_vfrontporch,\r\np->bt.il_vsync, p->bt.il_vbackporch,\r\np->bt.standards, p->bt.flags);\r\nbreak;\r\ndefault:\r\npr_cont("type=%d\n", p->type);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_enum_dv_timings(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_enum_dv_timings *p = arg;\r\npr_cont("index=%u, ", p->index);\r\nv4l_print_dv_timings(&p->timings, write_only);\r\n}\r\nstatic void v4l_print_dv_timings_cap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dv_timings_cap *p = arg;\r\nswitch (p->type) {\r\ncase V4L2_DV_BT_656_1120:\r\npr_cont("type=bt-656/1120, width=%u-%u, height=%u-%u, pixelclock=%llu-%llu, standards=0x%x, capabilities=0x%x\n",\r\np->bt.min_width, p->bt.max_width,\r\np->bt.min_height, p->bt.max_height,\r\np->bt.min_pixelclock, p->bt.max_pixelclock,\r\np->bt.standards, p->bt.capabilities);\r\nbreak;\r\ndefault:\r\npr_cont("type=%u\n", p->type);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_frmsizeenum(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frmsizeenum *p = arg;\r\npr_cont("index=%u, pixelformat=%c%c%c%c, type=%u",\r\np->index,\r\n(p->pixel_format & 0xff),\r\n(p->pixel_format >> 8) & 0xff,\r\n(p->pixel_format >> 16) & 0xff,\r\n(p->pixel_format >> 24) & 0xff,\r\np->type);\r\nswitch (p->type) {\r\ncase V4L2_FRMSIZE_TYPE_DISCRETE:\r\npr_cont(", wxh=%ux%u\n",\r\np->discrete.width, p->discrete.height);\r\nbreak;\r\ncase V4L2_FRMSIZE_TYPE_STEPWISE:\r\npr_cont(", min=%ux%u, max=%ux%u, step=%ux%u\n",\r\np->stepwise.min_width, p->stepwise.min_height,\r\np->stepwise.step_width, p->stepwise.step_height,\r\np->stepwise.max_width, p->stepwise.max_height);\r\nbreak;\r\ncase V4L2_FRMSIZE_TYPE_CONTINUOUS:\r\ndefault:\r\npr_cont("\n");\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_frmivalenum(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frmivalenum *p = arg;\r\npr_cont("index=%u, pixelformat=%c%c%c%c, wxh=%ux%u, type=%u",\r\np->index,\r\n(p->pixel_format & 0xff),\r\n(p->pixel_format >> 8) & 0xff,\r\n(p->pixel_format >> 16) & 0xff,\r\n(p->pixel_format >> 24) & 0xff,\r\np->width, p->height, p->type);\r\nswitch (p->type) {\r\ncase V4L2_FRMIVAL_TYPE_DISCRETE:\r\npr_cont(", fps=%d/%d\n",\r\np->discrete.numerator,\r\np->discrete.denominator);\r\nbreak;\r\ncase V4L2_FRMIVAL_TYPE_STEPWISE:\r\npr_cont(", min=%d/%d, max=%d/%d, step=%d/%d\n",\r\np->stepwise.min.numerator,\r\np->stepwise.min.denominator,\r\np->stepwise.max.numerator,\r\np->stepwise.max.denominator,\r\np->stepwise.step.numerator,\r\np->stepwise.step.denominator);\r\nbreak;\r\ncase V4L2_FRMIVAL_TYPE_CONTINUOUS:\r\ndefault:\r\npr_cont("\n");\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_event(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_event *p = arg;\r\nconst struct v4l2_event_ctrl *c;\r\npr_cont("type=0x%x, pending=%u, sequence=%u, id=%u, timestamp=%lu.%9.9lu\n",\r\np->type, p->pending, p->sequence, p->id,\r\np->timestamp.tv_sec, p->timestamp.tv_nsec);\r\nswitch (p->type) {\r\ncase V4L2_EVENT_VSYNC:\r\nprintk(KERN_DEBUG "field=%s\n",\r\nprt_names(p->u.vsync.field, v4l2_field_names));\r\nbreak;\r\ncase V4L2_EVENT_CTRL:\r\nc = &p->u.ctrl;\r\nprintk(KERN_DEBUG "changes=0x%x, type=%u, ",\r\nc->changes, c->type);\r\nif (c->type == V4L2_CTRL_TYPE_INTEGER64)\r\npr_cont("value64=%lld, ", c->value64);\r\nelse\r\npr_cont("value=%d, ", c->value);\r\npr_cont("flags=0x%x, minimum=%d, maximum=%d, step=%d, default_value=%d\n",\r\nc->flags, c->minimum, c->maximum,\r\nc->step, c->default_value);\r\nbreak;\r\ncase V4L2_EVENT_FRAME_SYNC:\r\npr_cont("frame_sequence=%u\n",\r\np->u.frame_sync.frame_sequence);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_event_subscription(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_event_subscription *p = arg;\r\npr_cont("type=0x%x, id=0x%x, flags=0x%x\n",\r\np->type, p->id, p->flags);\r\n}\r\nstatic void v4l_print_sliced_vbi_cap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_sliced_vbi_cap *p = arg;\r\nint i;\r\npr_cont("type=%s, service_set=0x%08x\n",\r\nprt_names(p->type, v4l2_type_names), p->service_set);\r\nfor (i = 0; i < 24; i++)\r\nprintk(KERN_DEBUG "line[%02u]=0x%04x, 0x%04x\n", i,\r\np->service_lines[0][i],\r\np->service_lines[1][i]);\r\n}\r\nstatic void v4l_print_freq_band(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frequency_band *p = arg;\r\npr_cont("tuner=%u, type=%u, index=%u, capability=0x%x, rangelow=%u, rangehigh=%u, modulation=0x%x\n",\r\np->tuner, p->type, p->index,\r\np->capability, p->rangelow,\r\np->rangehigh, p->modulation);\r\n}\r\nstatic void v4l_print_edid(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_edid *p = arg;\r\npr_cont("pad=%u, start_block=%u, blocks=%u\n",\r\np->pad, p->start_block, p->blocks);\r\n}\r\nstatic void v4l_print_u32(const void *arg, bool write_only)\r\n{\r\npr_cont("value=%u\n", *(const u32 *)arg);\r\n}\r\nstatic void v4l_print_newline(const void *arg, bool write_only)\r\n{\r\npr_cont("\n");\r\n}\r\nstatic void v4l_print_default(const void *arg, bool write_only)\r\n{\r\npr_cont("driver-specific ioctl\n");\r\n}\r\nstatic int check_ext_ctrls(struct v4l2_ext_controls *c, int allow_priv)\r\n{\r\n__u32 i;\r\nc->reserved[0] = c->reserved[1] = 0;\r\nfor (i = 0; i < c->count; i++)\r\nc->controls[i].reserved2[0] = 0;\r\nif (!allow_priv && c->which == V4L2_CID_PRIVATE_BASE)\r\nreturn 0;\r\nif (!c->which)\r\nreturn 1;\r\nfor (i = 0; i < c->count; i++) {\r\nif (V4L2_CTRL_ID2WHICH(c->controls[i].id) != c->which) {\r\nc->error_idx = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_fmt(struct file *file, enum v4l2_buf_type type)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_vbi = vfd->vfl_type == VFL_TYPE_VBI;\r\nbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\r\nbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nif (ops == NULL)\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif ((is_vid || is_tch) && is_rx &&\r\n(ops->vidioc_g_fmt_vid_cap || ops->vidioc_g_fmt_vid_cap_mplane))\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (is_vid && is_rx && ops->vidioc_g_fmt_vid_cap_mplane)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (is_vid && is_rx && ops->vidioc_g_fmt_vid_overlay)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (is_vid && is_tx &&\r\n(ops->vidioc_g_fmt_vid_out || ops->vidioc_g_fmt_vid_out_mplane))\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_mplane)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_overlay)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (is_vbi && is_rx && ops->vidioc_g_fmt_vbi_cap)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (is_vbi && is_tx && ops->vidioc_g_fmt_vbi_out)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (is_vbi && is_rx && ops->vidioc_g_fmt_sliced_vbi_cap)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (is_vbi && is_tx && ops->vidioc_g_fmt_sliced_vbi_out)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\nif (is_sdr && is_rx && ops->vidioc_g_fmt_sdr_cap)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nif (is_sdr && is_tx && ops->vidioc_g_fmt_sdr_out)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void v4l_sanitize_format(struct v4l2_format *fmt)\r\n{\r\nunsigned int offset;\r\nif (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nfmt->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn;\r\nif (fmt->fmt.pix.priv == V4L2_PIX_FMT_PRIV_MAGIC)\r\nreturn;\r\nfmt->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\noffset = offsetof(struct v4l2_pix_format, priv)\r\n+ sizeof(fmt->fmt.pix.priv);\r\nmemset(((void *)&fmt->fmt.pix) + offset, 0,\r\nsizeof(fmt->fmt.pix) - offset);\r\n}\r\nstatic int v4l_querycap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_capability *cap = (struct v4l2_capability *)arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nint ret;\r\ncap->version = LINUX_VERSION_CODE;\r\ncap->device_caps = vfd->device_caps;\r\ncap->capabilities = vfd->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nret = ops->vidioc_querycap(file, fh, cap);\r\ncap->capabilities |= V4L2_CAP_EXT_PIX_FORMAT;\r\nWARN(!(cap->capabilities & V4L2_CAP_DEVICE_CAPS) ||\r\n!cap->device_caps, "Bad caps for driver %s, %x %x",\r\ncap->driver, cap->capabilities, cap->device_caps);\r\ncap->device_caps |= V4L2_CAP_EXT_PIX_FORMAT;\r\nreturn ret;\r\n}\r\nstatic int v4l_s_input(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\nreturn ops->vidioc_s_input(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_s_output(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_s_output(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_g_priority(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd;\r\nu32 *p = arg;\r\nvfd = video_devdata(file);\r\n*p = v4l2_prio_max(vfd->prio);\r\nreturn 0;\r\n}\r\nstatic int v4l_s_priority(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd;\r\nstruct v4l2_fh *vfh;\r\nu32 *p = arg;\r\nvfd = video_devdata(file);\r\nif (!test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags))\r\nreturn -ENOTTY;\r\nvfh = file->private_data;\r\nreturn v4l2_prio_change(vfd->prio, &vfh->prio, *p);\r\n}\r\nstatic int v4l_enuminput(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_input *p = arg;\r\nif (is_valid_ioctl(vfd, VIDIOC_S_STD))\r\np->capabilities |= V4L2_IN_CAP_STD;\r\nreturn ops->vidioc_enum_input(file, fh, p);\r\n}\r\nstatic int v4l_enumoutput(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_output *p = arg;\r\nif (is_valid_ioctl(vfd, VIDIOC_S_STD))\r\np->capabilities |= V4L2_OUT_CAP_STD;\r\nreturn ops->vidioc_enum_output(file, fh, p);\r\n}\r\nstatic void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)\r\n{\r\nconst unsigned sz = sizeof(fmt->description);\r\nconst char *descr = NULL;\r\nu32 flags = 0;\r\nswitch (fmt->pixelformat) {\r\ncase V4L2_PIX_FMT_RGB332: descr = "8-bit RGB 3-3-2"; break;\r\ncase V4L2_PIX_FMT_RGB444: descr = "16-bit A/XRGB 4-4-4-4"; break;\r\ncase V4L2_PIX_FMT_ARGB444: descr = "16-bit ARGB 4-4-4-4"; break;\r\ncase V4L2_PIX_FMT_XRGB444: descr = "16-bit XRGB 4-4-4-4"; break;\r\ncase V4L2_PIX_FMT_RGB555: descr = "16-bit A/XRGB 1-5-5-5"; break;\r\ncase V4L2_PIX_FMT_ARGB555: descr = "16-bit ARGB 1-5-5-5"; break;\r\ncase V4L2_PIX_FMT_XRGB555: descr = "16-bit XRGB 1-5-5-5"; break;\r\ncase V4L2_PIX_FMT_RGB565: descr = "16-bit RGB 5-6-5"; break;\r\ncase V4L2_PIX_FMT_RGB555X: descr = "16-bit A/XRGB 1-5-5-5 BE"; break;\r\ncase V4L2_PIX_FMT_ARGB555X: descr = "16-bit ARGB 1-5-5-5 BE"; break;\r\ncase V4L2_PIX_FMT_XRGB555X: descr = "16-bit XRGB 1-5-5-5 BE"; break;\r\ncase V4L2_PIX_FMT_RGB565X: descr = "16-bit RGB 5-6-5 BE"; break;\r\ncase V4L2_PIX_FMT_BGR666: descr = "18-bit BGRX 6-6-6-14"; break;\r\ncase V4L2_PIX_FMT_BGR24: descr = "24-bit BGR 8-8-8"; break;\r\ncase V4L2_PIX_FMT_RGB24: descr = "24-bit RGB 8-8-8"; break;\r\ncase V4L2_PIX_FMT_BGR32: descr = "32-bit BGRA/X 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_ABGR32: descr = "32-bit BGRA 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_XBGR32: descr = "32-bit BGRX 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_RGB32: descr = "32-bit A/XRGB 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_ARGB32: descr = "32-bit ARGB 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_XRGB32: descr = "32-bit XRGB 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_GREY: descr = "8-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y4: descr = "4-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y6: descr = "6-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y10: descr = "10-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y12: descr = "12-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y16: descr = "16-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y16_BE: descr = "16-bit Greyscale BE"; break;\r\ncase V4L2_PIX_FMT_Y10BPACK: descr = "10-bit Greyscale (Packed)"; break;\r\ncase V4L2_PIX_FMT_Y8I: descr = "Interleaved 8-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Y12I: descr = "Interleaved 12-bit Greyscale"; break;\r\ncase V4L2_PIX_FMT_Z16: descr = "16-bit Depth"; break;\r\ncase V4L2_PIX_FMT_PAL8: descr = "8-bit Palette"; break;\r\ncase V4L2_PIX_FMT_UV8: descr = "8-bit Chrominance UV 4-4"; break;\r\ncase V4L2_PIX_FMT_YVU410: descr = "Planar YVU 4:1:0"; break;\r\ncase V4L2_PIX_FMT_YVU420: descr = "Planar YVU 4:2:0"; break;\r\ncase V4L2_PIX_FMT_YUYV: descr = "YUYV 4:2:2"; break;\r\ncase V4L2_PIX_FMT_YYUV: descr = "YYUV 4:2:2"; break;\r\ncase V4L2_PIX_FMT_YVYU: descr = "YVYU 4:2:2"; break;\r\ncase V4L2_PIX_FMT_UYVY: descr = "UYVY 4:2:2"; break;\r\ncase V4L2_PIX_FMT_VYUY: descr = "VYUY 4:2:2"; break;\r\ncase V4L2_PIX_FMT_YUV422P: descr = "Planar YUV 4:2:2"; break;\r\ncase V4L2_PIX_FMT_YUV411P: descr = "Planar YUV 4:1:1"; break;\r\ncase V4L2_PIX_FMT_Y41P: descr = "YUV 4:1:1 (Packed)"; break;\r\ncase V4L2_PIX_FMT_YUV444: descr = "16-bit A/XYUV 4-4-4-4"; break;\r\ncase V4L2_PIX_FMT_YUV555: descr = "16-bit A/XYUV 1-5-5-5"; break;\r\ncase V4L2_PIX_FMT_YUV565: descr = "16-bit YUV 5-6-5"; break;\r\ncase V4L2_PIX_FMT_YUV32: descr = "32-bit A/XYUV 8-8-8-8"; break;\r\ncase V4L2_PIX_FMT_YUV410: descr = "Planar YUV 4:1:0"; break;\r\ncase V4L2_PIX_FMT_YUV420: descr = "Planar YUV 4:2:0"; break;\r\ncase V4L2_PIX_FMT_HI240: descr = "8-bit Dithered RGB (BTTV)"; break;\r\ncase V4L2_PIX_FMT_HM12: descr = "YUV 4:2:0 (16x16 Macroblocks)"; break;\r\ncase V4L2_PIX_FMT_M420: descr = "YUV 4:2:0 (M420)"; break;\r\ncase V4L2_PIX_FMT_NV12: descr = "Y/CbCr 4:2:0"; break;\r\ncase V4L2_PIX_FMT_NV21: descr = "Y/CrCb 4:2:0"; break;\r\ncase V4L2_PIX_FMT_NV16: descr = "Y/CbCr 4:2:2"; break;\r\ncase V4L2_PIX_FMT_NV61: descr = "Y/CrCb 4:2:2"; break;\r\ncase V4L2_PIX_FMT_NV24: descr = "Y/CbCr 4:4:4"; break;\r\ncase V4L2_PIX_FMT_NV42: descr = "Y/CrCb 4:4:4"; break;\r\ncase V4L2_PIX_FMT_NV12M: descr = "Y/CbCr 4:2:0 (N-C)"; break;\r\ncase V4L2_PIX_FMT_NV21M: descr = "Y/CrCb 4:2:0 (N-C)"; break;\r\ncase V4L2_PIX_FMT_NV16M: descr = "Y/CbCr 4:2:2 (N-C)"; break;\r\ncase V4L2_PIX_FMT_NV61M: descr = "Y/CrCb 4:2:2 (N-C)"; break;\r\ncase V4L2_PIX_FMT_NV12MT: descr = "Y/CbCr 4:2:0 (64x32 MB, N-C)"; break;\r\ncase V4L2_PIX_FMT_NV12MT_16X16: descr = "Y/CbCr 4:2:0 (16x16 MB, N-C)"; break;\r\ncase V4L2_PIX_FMT_YUV420M: descr = "Planar YUV 4:2:0 (N-C)"; break;\r\ncase V4L2_PIX_FMT_YVU420M: descr = "Planar YVU 4:2:0 (N-C)"; break;\r\ncase V4L2_PIX_FMT_YUV422M: descr = "Planar YUV 4:2:2 (N-C)"; break;\r\ncase V4L2_PIX_FMT_YVU422M: descr = "Planar YVU 4:2:2 (N-C)"; break;\r\ncase V4L2_PIX_FMT_YUV444M: descr = "Planar YUV 4:4:4 (N-C)"; break;\r\ncase V4L2_PIX_FMT_YVU444M: descr = "Planar YVU 4:4:4 (N-C)"; break;\r\ncase V4L2_PIX_FMT_SBGGR8: descr = "8-bit Bayer BGBG/GRGR"; break;\r\ncase V4L2_PIX_FMT_SGBRG8: descr = "8-bit Bayer GBGB/RGRG"; break;\r\ncase V4L2_PIX_FMT_SGRBG8: descr = "8-bit Bayer GRGR/BGBG"; break;\r\ncase V4L2_PIX_FMT_SRGGB8: descr = "8-bit Bayer RGRG/GBGB"; break;\r\ncase V4L2_PIX_FMT_SBGGR10: descr = "10-bit Bayer BGBG/GRGR"; break;\r\ncase V4L2_PIX_FMT_SGBRG10: descr = "10-bit Bayer GBGB/RGRG"; break;\r\ncase V4L2_PIX_FMT_SGRBG10: descr = "10-bit Bayer GRGR/BGBG"; break;\r\ncase V4L2_PIX_FMT_SRGGB10: descr = "10-bit Bayer RGRG/GBGB"; break;\r\ncase V4L2_PIX_FMT_SBGGR12: descr = "12-bit Bayer BGBG/GRGR"; break;\r\ncase V4L2_PIX_FMT_SGBRG12: descr = "12-bit Bayer GBGB/RGRG"; break;\r\ncase V4L2_PIX_FMT_SGRBG12: descr = "12-bit Bayer GRGR/BGBG"; break;\r\ncase V4L2_PIX_FMT_SRGGB12: descr = "12-bit Bayer RGRG/GBGB"; break;\r\ncase V4L2_PIX_FMT_SBGGR10P: descr = "10-bit Bayer BGBG/GRGR Packed"; break;\r\ncase V4L2_PIX_FMT_SGBRG10P: descr = "10-bit Bayer GBGB/RGRG Packed"; break;\r\ncase V4L2_PIX_FMT_SGRBG10P: descr = "10-bit Bayer GRGR/BGBG Packed"; break;\r\ncase V4L2_PIX_FMT_SRGGB10P: descr = "10-bit Bayer RGRG/GBGB Packed"; break;\r\ncase V4L2_PIX_FMT_SBGGR10ALAW8: descr = "8-bit Bayer BGBG/GRGR (A-law)"; break;\r\ncase V4L2_PIX_FMT_SGBRG10ALAW8: descr = "8-bit Bayer GBGB/RGRG (A-law)"; break;\r\ncase V4L2_PIX_FMT_SGRBG10ALAW8: descr = "8-bit Bayer GRGR/BGBG (A-law)"; break;\r\ncase V4L2_PIX_FMT_SRGGB10ALAW8: descr = "8-bit Bayer RGRG/GBGB (A-law)"; break;\r\ncase V4L2_PIX_FMT_SBGGR10DPCM8: descr = "8-bit Bayer BGBG/GRGR (DPCM)"; break;\r\ncase V4L2_PIX_FMT_SGBRG10DPCM8: descr = "8-bit Bayer GBGB/RGRG (DPCM)"; break;\r\ncase V4L2_PIX_FMT_SGRBG10DPCM8: descr = "8-bit Bayer GRGR/BGBG (DPCM)"; break;\r\ncase V4L2_PIX_FMT_SRGGB10DPCM8: descr = "8-bit Bayer RGRG/GBGB (DPCM)"; break;\r\ncase V4L2_PIX_FMT_SBGGR16: descr = "16-bit Bayer BGBG/GRGR"; break;\r\ncase V4L2_PIX_FMT_SGBRG16: descr = "16-bit Bayer GBGB/RGRG"; break;\r\ncase V4L2_PIX_FMT_SGRBG16: descr = "16-bit Bayer GRGR/BGBG"; break;\r\ncase V4L2_PIX_FMT_SRGGB16: descr = "16-bit Bayer RGRG/GBGB"; break;\r\ncase V4L2_PIX_FMT_SN9C20X_I420: descr = "GSPCA SN9C20X I420"; break;\r\ncase V4L2_PIX_FMT_SPCA501: descr = "GSPCA SPCA501"; break;\r\ncase V4L2_PIX_FMT_SPCA505: descr = "GSPCA SPCA505"; break;\r\ncase V4L2_PIX_FMT_SPCA508: descr = "GSPCA SPCA508"; break;\r\ncase V4L2_PIX_FMT_STV0680: descr = "GSPCA STV0680"; break;\r\ncase V4L2_PIX_FMT_TM6000: descr = "A/V + VBI Mux Packet"; break;\r\ncase V4L2_PIX_FMT_CIT_YYVYUY: descr = "GSPCA CIT YYVYUY"; break;\r\ncase V4L2_PIX_FMT_KONICA420: descr = "GSPCA KONICA420"; break;\r\ncase V4L2_PIX_FMT_HSV24: descr = "24-bit HSV 8-8-8"; break;\r\ncase V4L2_PIX_FMT_HSV32: descr = "32-bit XHSV 8-8-8-8"; break;\r\ncase V4L2_SDR_FMT_CU8: descr = "Complex U8"; break;\r\ncase V4L2_SDR_FMT_CU16LE: descr = "Complex U16LE"; break;\r\ncase V4L2_SDR_FMT_CS8: descr = "Complex S8"; break;\r\ncase V4L2_SDR_FMT_CS14LE: descr = "Complex S14LE"; break;\r\ncase V4L2_SDR_FMT_RU12LE: descr = "Real U12LE"; break;\r\ncase V4L2_TCH_FMT_DELTA_TD16: descr = "16-bit signed deltas"; break;\r\ncase V4L2_TCH_FMT_DELTA_TD08: descr = "8-bit signed deltas"; break;\r\ncase V4L2_TCH_FMT_TU16: descr = "16-bit unsigned touch data"; break;\r\ncase V4L2_TCH_FMT_TU08: descr = "8-bit unsigned touch data"; break;\r\ndefault:\r\nflags = V4L2_FMT_FLAG_COMPRESSED;\r\nswitch (fmt->pixelformat) {\r\ncase V4L2_PIX_FMT_MJPEG: descr = "Motion-JPEG"; break;\r\ncase V4L2_PIX_FMT_JPEG: descr = "JFIF JPEG"; break;\r\ncase V4L2_PIX_FMT_DV: descr = "1394"; break;\r\ncase V4L2_PIX_FMT_MPEG: descr = "MPEG-1/2/4"; break;\r\ncase V4L2_PIX_FMT_H264: descr = "H.264"; break;\r\ncase V4L2_PIX_FMT_H264_NO_SC: descr = "H.264 (No Start Codes)"; break;\r\ncase V4L2_PIX_FMT_H264_MVC: descr = "H.264 MVC"; break;\r\ncase V4L2_PIX_FMT_H263: descr = "H.263"; break;\r\ncase V4L2_PIX_FMT_MPEG1: descr = "MPEG-1 ES"; break;\r\ncase V4L2_PIX_FMT_MPEG2: descr = "MPEG-2 ES"; break;\r\ncase V4L2_PIX_FMT_MPEG4: descr = "MPEG-4 part 2 ES"; break;\r\ncase V4L2_PIX_FMT_XVID: descr = "Xvid"; break;\r\ncase V4L2_PIX_FMT_VC1_ANNEX_G: descr = "VC-1 (SMPTE 412M Annex G)"; break;\r\ncase V4L2_PIX_FMT_VC1_ANNEX_L: descr = "VC-1 (SMPTE 412M Annex L)"; break;\r\ncase V4L2_PIX_FMT_VP8: descr = "VP8"; break;\r\ncase V4L2_PIX_FMT_VP9: descr = "VP9"; break;\r\ncase V4L2_PIX_FMT_CPIA1: descr = "GSPCA CPiA YUV"; break;\r\ncase V4L2_PIX_FMT_WNVA: descr = "WNVA"; break;\r\ncase V4L2_PIX_FMT_SN9C10X: descr = "GSPCA SN9C10X"; break;\r\ncase V4L2_PIX_FMT_PWC1: descr = "Raw Philips Webcam Type (Old)"; break;\r\ncase V4L2_PIX_FMT_PWC2: descr = "Raw Philips Webcam Type (New)"; break;\r\ncase V4L2_PIX_FMT_ET61X251: descr = "GSPCA ET61X251"; break;\r\ncase V4L2_PIX_FMT_SPCA561: descr = "GSPCA SPCA561"; break;\r\ncase V4L2_PIX_FMT_PAC207: descr = "GSPCA PAC207"; break;\r\ncase V4L2_PIX_FMT_MR97310A: descr = "GSPCA MR97310A"; break;\r\ncase V4L2_PIX_FMT_JL2005BCD: descr = "GSPCA JL2005BCD"; break;\r\ncase V4L2_PIX_FMT_SN9C2028: descr = "GSPCA SN9C2028"; break;\r\ncase V4L2_PIX_FMT_SQ905C: descr = "GSPCA SQ905C"; break;\r\ncase V4L2_PIX_FMT_PJPG: descr = "GSPCA PJPG"; break;\r\ncase V4L2_PIX_FMT_OV511: descr = "GSPCA OV511"; break;\r\ncase V4L2_PIX_FMT_OV518: descr = "GSPCA OV518"; break;\r\ncase V4L2_PIX_FMT_JPGL: descr = "JPEG Lite"; break;\r\ncase V4L2_PIX_FMT_SE401: descr = "GSPCA SE401"; break;\r\ncase V4L2_PIX_FMT_S5C_UYVY_JPG: descr = "S5C73MX interleaved UYVY/JPEG"; break;\r\ncase V4L2_PIX_FMT_MT21C: descr = "Mediatek Compressed Format"; break;\r\ndefault:\r\nWARN(1, "Unknown pixelformat 0x%08x\n", fmt->pixelformat);\r\nif (fmt->description[0])\r\nreturn;\r\nflags = 0;\r\nsnprintf(fmt->description, sz, "%c%c%c%c%s",\r\n(char)(fmt->pixelformat & 0x7f),\r\n(char)((fmt->pixelformat >> 8) & 0x7f),\r\n(char)((fmt->pixelformat >> 16) & 0x7f),\r\n(char)((fmt->pixelformat >> 24) & 0x7f),\r\n(fmt->pixelformat & (1 << 31)) ? "-BE" : "");\r\nbreak;\r\n}\r\n}\r\nif (descr)\r\nWARN_ON(strlcpy(fmt->description, descr, sz) >= sz);\r\nfmt->flags = flags;\r\n}\r\nstatic int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_fmtdesc *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\r\nbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nint ret = -EINVAL;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_enum_fmt_vid_cap))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_cap_mplane))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_overlay))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_vid_out(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out_mplane))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_vid_out_mplane(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\nif (unlikely(!is_rx || !is_sdr || !ops->vidioc_enum_fmt_sdr_cap))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_sdr_cap(file, fh, arg);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nif (unlikely(!is_tx || !is_sdr || !ops->vidioc_enum_fmt_sdr_out))\r\nbreak;\r\nret = ops->vidioc_enum_fmt_sdr_out(file, fh, arg);\r\nbreak;\r\n}\r\nif (ret == 0)\r\nv4l_fill_fmtdesc(p);\r\nreturn ret;\r\n}\r\nstatic int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\r\nbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nint ret;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: {\r\nstruct v4l2_clip __user *clips = p->fmt.win.clips;\r\nu32 clipcount = p->fmt.win.clipcount;\r\nvoid __user *bitmap = p->fmt.win.bitmap;\r\nmemset(&p->fmt, 0, sizeof(p->fmt));\r\np->fmt.win.clips = clips;\r\np->fmt.win.clipcount = clipcount;\r\np->fmt.win.bitmap = bitmap;\r\nbreak;\r\n}\r\ndefault:\r\nmemset(&p->fmt, 0, sizeof(p->fmt));\r\nbreak;\r\n}\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_g_fmt_vid_cap))\r\nbreak;\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nret = ops->vidioc_g_fmt_vid_cap(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_g_fmt_vid_cap_mplane))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_g_fmt_vid_overlay))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_g_fmt_vbi_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_g_fmt_sliced_vbi_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out))\r\nbreak;\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nret = ops->vidioc_g_fmt_vid_out(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out_mplane))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out_overlay))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_g_fmt_vbi_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_g_fmt_sliced_vbi_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sliced_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\nif (unlikely(!is_rx || !is_sdr || !ops->vidioc_g_fmt_sdr_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sdr_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nif (unlikely(!is_tx || !is_sdr || !ops->vidioc_g_fmt_sdr_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sdr_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void v4l_pix_format_touch(struct v4l2_pix_format *p)\r\n{\r\np->field = V4L2_FIELD_NONE;\r\np->colorspace = V4L2_COLORSPACE_RAW;\r\np->flags = 0;\r\np->ycbcr_enc = 0;\r\np->quantization = 0;\r\np->xfer_func = 0;\r\n}\r\nstatic int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\r\nbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\nv4l_sanitize_format(p);\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_s_fmt_vid_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nret = ops->vidioc_s_fmt_vid_cap(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nif (is_tch)\r\nv4l_pix_format_touch(&p->fmt.pix);\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\r\nreturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nret = ops->vidioc_s_fmt_vid_out(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\r\nreturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\nif (unlikely(!is_rx || !is_sdr || !ops->vidioc_s_fmt_sdr_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sdr);\r\nreturn ops->vidioc_s_fmt_sdr_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nif (unlikely(!is_tx || !is_sdr || !ops->vidioc_s_fmt_sdr_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sdr);\r\nreturn ops->vidioc_s_fmt_sdr_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\r\nbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nint ret;\r\nv4l_sanitize_format(p);\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_try_fmt_vid_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nret = ops->vidioc_try_fmt_vid_cap(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_try_fmt_vid_cap_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\r\nreturn ops->vidioc_try_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_try_fmt_vid_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_try_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_try_fmt_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_try_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_try_fmt_sliced_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_try_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nret = ops->vidioc_try_fmt_vid_out(file, fh, arg);\r\np->fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);\r\nreturn ops->vidioc_try_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_try_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_try_fmt_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_try_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_try_fmt_sliced_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_try_fmt_sliced_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\nif (unlikely(!is_rx || !is_sdr || !ops->vidioc_try_fmt_sdr_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sdr);\r\nreturn ops->vidioc_try_fmt_sdr_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nif (unlikely(!is_tx || !is_sdr || !ops->vidioc_try_fmt_sdr_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sdr);\r\nreturn ops->vidioc_try_fmt_sdr_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_streamon(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_streamon(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_streamoff(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_streamoff(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_g_tuner(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_tuner *p = arg;\r\nint err;\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nerr = ops->vidioc_g_tuner(file, fh, p);\r\nif (!err)\r\np->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\r\nreturn err;\r\n}\r\nstatic int v4l_s_tuner(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_tuner *p = arg;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nreturn ops->vidioc_s_tuner(file, fh, p);\r\n}\r\nstatic int v4l_g_modulator(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_modulator *p = arg;\r\nint err;\r\nif (vfd->vfl_type == VFL_TYPE_RADIO)\r\np->type = V4L2_TUNER_RADIO;\r\nerr = ops->vidioc_g_modulator(file, fh, p);\r\nif (!err)\r\np->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\r\nreturn err;\r\n}\r\nstatic int v4l_s_modulator(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_modulator *p = arg;\r\nif (vfd->vfl_type == VFL_TYPE_RADIO)\r\np->type = V4L2_TUNER_RADIO;\r\nreturn ops->vidioc_s_modulator(file, fh, p);\r\n}\r\nstatic int v4l_g_frequency(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_frequency *p = arg;\r\nif (vfd->vfl_type == VFL_TYPE_SDR)\r\np->type = V4L2_TUNER_SDR;\r\nelse\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nreturn ops->vidioc_g_frequency(file, fh, p);\r\n}\r\nstatic int v4l_s_frequency(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_frequency *p = arg;\r\nenum v4l2_tuner_type type;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\nif (vfd->vfl_type == VFL_TYPE_SDR) {\r\nif (p->type != V4L2_TUNER_SDR && p->type != V4L2_TUNER_RF)\r\nreturn -EINVAL;\r\n} else {\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (type != p->type)\r\nreturn -EINVAL;\r\n}\r\nreturn ops->vidioc_s_frequency(file, fh, p);\r\n}\r\nstatic int v4l_enumstd(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_standard *p = arg;\r\nv4l2_std_id id = vfd->tvnorms, curr_id = 0;\r\nunsigned int index = p->index, i, j = 0;\r\nconst char *descr = "";\r\nif (id == 0)\r\nreturn -ENODATA;\r\nfor (i = 0; i <= index && id; i++) {\r\nwhile ((id & standards[j].std) != standards[j].std)\r\nj++;\r\ncurr_id = standards[j].std;\r\ndescr = standards[j].descr;\r\nj++;\r\nif (curr_id == 0)\r\nbreak;\r\nif (curr_id != V4L2_STD_PAL &&\r\ncurr_id != V4L2_STD_SECAM &&\r\ncurr_id != V4L2_STD_NTSC)\r\nid &= ~curr_id;\r\n}\r\nif (i <= index)\r\nreturn -EINVAL;\r\nv4l2_video_std_construct(p, curr_id, descr);\r\nreturn 0;\r\n}\r\nstatic int v4l_s_std(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nv4l2_std_id id = *(v4l2_std_id *)arg, norm;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\nnorm = id & vfd->tvnorms;\r\nif (vfd->tvnorms && !norm)\r\nreturn -EINVAL;\r\nreturn ops->vidioc_s_std(file, fh, norm);\r\n}\r\nstatic int v4l_querystd(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nv4l2_std_id *p = arg;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\n*p = vfd->tvnorms;\r\nreturn ops->vidioc_querystd(file, fh, arg);\r\n}\r\nstatic int v4l_s_hw_freq_seek(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_hw_freq_seek *p = arg;\r\nenum v4l2_tuner_type type;\r\nint ret;\r\nret = v4l_enable_media_source(vfd);\r\nif (ret)\r\nreturn ret;\r\nif (vfd->vfl_type == VFL_TYPE_SDR)\r\nreturn -EINVAL;\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (p->type != type)\r\nreturn -EINVAL;\r\nreturn ops->vidioc_s_hw_freq_seek(file, fh, p);\r\n}\r\nstatic int v4l_overlay(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_overlay(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_reqbufs(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_requestbuffers *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nCLEAR_AFTER_FIELD(p, memory);\r\nreturn ops->vidioc_reqbufs(file, fh, p);\r\n}\r\nstatic int v4l_querybuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_querybuf(file, fh, p);\r\n}\r\nstatic int v4l_qbuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_qbuf(file, fh, p);\r\n}\r\nstatic int v4l_dqbuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_dqbuf(file, fh, p);\r\n}\r\nstatic int v4l_create_bufs(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_create_buffers *create = arg;\r\nint ret = check_fmt(file, create->format.type);\r\nif (ret)\r\nreturn ret;\r\nCLEAR_AFTER_FIELD(create, format);\r\nv4l_sanitize_format(&create->format);\r\nret = ops->vidioc_create_bufs(file, fh, create);\r\nif (create->format.type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\ncreate->format.type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\ncreate->format.fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;\r\nreturn ret;\r\n}\r\nstatic int v4l_prepare_buf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *b = arg;\r\nint ret = check_fmt(file, b->type);\r\nreturn ret ? ret : ops->vidioc_prepare_buf(file, fh, b);\r\n}\r\nstatic int v4l_g_parm(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_streamparm *p = arg;\r\nv4l2_std_id std;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nif (ops->vidioc_g_parm)\r\nreturn ops->vidioc_g_parm(file, fh, p);\r\nif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\np->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn -EINVAL;\r\np->parm.capture.readbuffers = 2;\r\nret = ops->vidioc_g_std(file, fh, &std);\r\nif (ret == 0)\r\nv4l2_video_std_frame_period(std, &p->parm.capture.timeperframe);\r\nreturn ret;\r\n}\r\nstatic int v4l_s_parm(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_streamparm *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_s_parm(file, fh, p);\r\n}\r\nstatic int v4l_queryctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_queryctrl *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_queryctrl(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_queryctrl(vfd->ctrl_handler, p);\r\nif (ops->vidioc_queryctrl)\r\nreturn ops->vidioc_queryctrl(file, fh, p);\r\nreturn -ENOTTY;\r\n}\r\nstatic int v4l_query_ext_ctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_query_ext_ctrl *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_query_ext_ctrl(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_query_ext_ctrl(vfd->ctrl_handler, p);\r\nif (ops->vidioc_query_ext_ctrl)\r\nreturn ops->vidioc_query_ext_ctrl(file, fh, p);\r\nreturn -ENOTTY;\r\n}\r\nstatic int v4l_querymenu(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_querymenu *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_querymenu(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_querymenu(vfd->ctrl_handler, p);\r\nif (ops->vidioc_querymenu)\r\nreturn ops->vidioc_querymenu(file, fh, p);\r\nreturn -ENOTTY;\r\n}\r\nstatic int v4l_g_ctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_control *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nstruct v4l2_ext_controls ctrls;\r\nstruct v4l2_ext_control ctrl;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_g_ctrl(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_g_ctrl(vfd->ctrl_handler, p);\r\nif (ops->vidioc_g_ctrl)\r\nreturn ops->vidioc_g_ctrl(file, fh, p);\r\nif (ops->vidioc_g_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nctrls.which = V4L2_CTRL_ID2WHICH(p->id);\r\nctrls.count = 1;\r\nctrls.controls = &ctrl;\r\nctrl.id = p->id;\r\nctrl.value = p->value;\r\nif (check_ext_ctrls(&ctrls, 1)) {\r\nint ret = ops->vidioc_g_ext_ctrls(file, fh, &ctrls);\r\nif (ret == 0)\r\np->value = ctrl.value;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_s_ctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_control *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nstruct v4l2_ext_controls ctrls;\r\nstruct v4l2_ext_control ctrl;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_s_ctrl(vfh, vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_s_ctrl(NULL, vfd->ctrl_handler, p);\r\nif (ops->vidioc_s_ctrl)\r\nreturn ops->vidioc_s_ctrl(file, fh, p);\r\nif (ops->vidioc_s_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nctrls.which = V4L2_CTRL_ID2WHICH(p->id);\r\nctrls.count = 1;\r\nctrls.controls = &ctrl;\r\nctrl.id = p->id;\r\nctrl.value = p->value;\r\nif (check_ext_ctrls(&ctrls, 1))\r\nreturn ops->vidioc_s_ext_ctrls(file, fh, &ctrls);\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_g_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_g_ext_ctrls(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_g_ext_ctrls(vfd->ctrl_handler, p);\r\nif (ops->vidioc_g_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_g_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_s_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_s_ext_ctrls(vfh, vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_s_ext_ctrls(NULL, vfd->ctrl_handler, p);\r\nif (ops->vidioc_s_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_s_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_try_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_try_ext_ctrls(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_try_ext_ctrls(vfd->ctrl_handler, p);\r\nif (ops->vidioc_try_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_try_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_g_crop(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_crop *p = arg;\r\nstruct v4l2_selection s = {\r\n.type = p->type,\r\n};\r\nint ret;\r\nif (ops->vidioc_g_crop)\r\nreturn ops->vidioc_g_crop(file, fh, p);\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_ACTIVE;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_ACTIVE;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (!ret)\r\np->c = s.r;\r\nreturn ret;\r\n}\r\nstatic int v4l_s_crop(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_crop *p = arg;\r\nstruct v4l2_selection s = {\r\n.type = p->type,\r\n.r = p->c,\r\n};\r\nif (ops->vidioc_s_crop)\r\nreturn ops->vidioc_s_crop(file, fh, p);\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_ACTIVE;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_ACTIVE;\r\nreturn ops->vidioc_s_selection(file, fh, &s);\r\n}\r\nstatic int v4l_cropcap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_cropcap *p = arg;\r\nstruct v4l2_selection s = { .type = p->type };\r\nint ret = 0;\r\np->pixelaspect.numerator = 1;\r\np->pixelaspect.denominator = 1;\r\nif (WARN_ON(!ops->vidioc_cropcap && !ops->vidioc_g_selection))\r\nreturn -ENOTTY;\r\nif (ops->vidioc_cropcap)\r\nret = ops->vidioc_cropcap(file, fh, p);\r\nif (!ops->vidioc_g_selection)\r\nreturn ret;\r\nif (ret && ret != -ENOTTY && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_BOUNDS;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_BOUNDS;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (ret)\r\nreturn ret;\r\np->bounds = s.r;\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_DEFAULT;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_DEFAULT;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (ret)\r\nreturn ret;\r\np->defrect = s.r;\r\nreturn 0;\r\n}\r\nstatic int v4l_log_status(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nint ret;\r\nif (vfd->v4l2_dev)\r\npr_info("%s: ================= START STATUS =================\n",\r\nvfd->v4l2_dev->name);\r\nret = ops->vidioc_log_status(file, fh);\r\nif (vfd->v4l2_dev)\r\npr_info("%s: ================== END STATUS ==================\n",\r\nvfd->v4l2_dev->name);\r\nreturn ret;\r\n}\r\nstatic int v4l_dbg_g_register(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nstruct v4l2_dbg_register *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\r\nif (vfd->v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\r\nif (p->match.addr == idx++)\r\nreturn v4l2_subdev_call(sd, core, g_register, p);\r\nreturn -EINVAL;\r\n}\r\nif (ops->vidioc_g_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\r\n(ops->vidioc_g_chip_info || p->match.addr == 0))\r\nreturn ops->vidioc_g_register(file, fh, p);\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dbg_s_register(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nconst struct v4l2_dbg_register *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\r\nif (vfd->v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\r\nif (p->match.addr == idx++)\r\nreturn v4l2_subdev_call(sd, core, s_register, p);\r\nreturn -EINVAL;\r\n}\r\nif (ops->vidioc_s_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\r\n(ops->vidioc_g_chip_info || p->match.addr == 0))\r\nreturn ops->vidioc_s_register(file, fh, p);\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dbg_g_chip_info(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_dbg_chip_info *p = arg;\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nswitch (p->match.type) {\r\ncase V4L2_CHIP_MATCH_BRIDGE:\r\nif (ops->vidioc_s_register)\r\np->flags |= V4L2_CHIP_FL_WRITABLE;\r\nif (ops->vidioc_g_register)\r\np->flags |= V4L2_CHIP_FL_READABLE;\r\nstrlcpy(p->name, vfd->v4l2_dev->name, sizeof(p->name));\r\nif (ops->vidioc_g_chip_info)\r\nreturn ops->vidioc_g_chip_info(file, fh, arg);\r\nif (p->match.addr)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_SUBDEV:\r\nif (vfd->v4l2_dev == NULL)\r\nbreak;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev) {\r\nif (p->match.addr != idx++)\r\ncontinue;\r\nif (sd->ops->core && sd->ops->core->s_register)\r\np->flags |= V4L2_CHIP_FL_WRITABLE;\r\nif (sd->ops->core && sd->ops->core->g_register)\r\np->flags |= V4L2_CHIP_FL_READABLE;\r\nstrlcpy(p->name, sd->name, sizeof(p->name));\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dqevent(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn v4l2_event_dequeue(fh, arg, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int v4l_subscribe_event(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_subscribe_event(fh, arg);\r\n}\r\nstatic int v4l_unsubscribe_event(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_unsubscribe_event(fh, arg);\r\n}\r\nstatic int v4l_g_sliced_vbi_cap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_sliced_vbi_cap *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nmemset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));\r\nreturn ops->vidioc_g_sliced_vbi_cap(file, fh, p);\r\n}\r\nstatic int v4l_enum_freq_bands(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_frequency_band *p = arg;\r\nenum v4l2_tuner_type type;\r\nint err;\r\nif (vfd->vfl_type == VFL_TYPE_SDR) {\r\nif (p->type != V4L2_TUNER_SDR && p->type != V4L2_TUNER_RF)\r\nreturn -EINVAL;\r\ntype = p->type;\r\n} else {\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (type != p->type)\r\nreturn -EINVAL;\r\n}\r\nif (ops->vidioc_enum_freq_bands) {\r\nerr = ops->vidioc_enum_freq_bands(file, fh, p);\r\nif (err != -ENOTTY)\r\nreturn err;\r\n}\r\nif (is_valid_ioctl(vfd, VIDIOC_G_TUNER)) {\r\nstruct v4l2_tuner t = {\r\n.index = p->tuner,\r\n.type = type,\r\n};\r\nif (p->index)\r\nreturn -EINVAL;\r\nerr = ops->vidioc_g_tuner(file, fh, &t);\r\nif (err)\r\nreturn err;\r\np->capability = t.capability | V4L2_TUNER_CAP_FREQ_BANDS;\r\np->rangelow = t.rangelow;\r\np->rangehigh = t.rangehigh;\r\np->modulation = (type == V4L2_TUNER_RADIO) ?\r\nV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\r\nreturn 0;\r\n}\r\nif (is_valid_ioctl(vfd, VIDIOC_G_MODULATOR)) {\r\nstruct v4l2_modulator m = {\r\n.index = p->tuner,\r\n};\r\nif (type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (p->index)\r\nreturn -EINVAL;\r\nerr = ops->vidioc_g_modulator(file, fh, &m);\r\nif (err)\r\nreturn err;\r\np->capability = m.capability | V4L2_TUNER_CAP_FREQ_BANDS;\r\np->rangelow = m.rangelow;\r\np->rangehigh = m.rangehigh;\r\np->modulation = (type == V4L2_TUNER_RADIO) ?\r\nV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\r\nreturn 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nbool v4l2_is_known_ioctl(unsigned int cmd)\r\n{\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS)\r\nreturn false;\r\nreturn v4l2_ioctls[_IOC_NR(cmd)].ioctl == cmd;\r\n}\r\nstruct mutex *v4l2_ioctl_get_lock(struct video_device *vdev, unsigned cmd)\r\n{\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS)\r\nreturn vdev->lock;\r\nif (test_bit(_IOC_NR(cmd), vdev->disable_locking))\r\nreturn NULL;\r\nif (vdev->queue && vdev->queue->lock &&\r\n(v4l2_ioctls[_IOC_NR(cmd)].flags & INFO_FL_QUEUE))\r\nreturn vdev->queue->lock;\r\nreturn vdev->lock;\r\n}\r\nvoid v4l_printk_ioctl(const char *prefix, unsigned int cmd)\r\n{\r\nconst char *dir, *type;\r\nif (prefix)\r\nprintk(KERN_DEBUG "%s: ", prefix);\r\nswitch (_IOC_TYPE(cmd)) {\r\ncase 'd':\r\ntype = "v4l2_int";\r\nbreak;\r\ncase 'V':\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS) {\r\ntype = "v4l2";\r\nbreak;\r\n}\r\npr_cont("%s", v4l2_ioctls[_IOC_NR(cmd)].name);\r\nreturn;\r\ndefault:\r\ntype = "unknown";\r\nbreak;\r\n}\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_NONE: dir = "--"; break;\r\ncase _IOC_READ: dir = "r-"; break;\r\ncase _IOC_WRITE: dir = "-w"; break;\r\ncase _IOC_READ | _IOC_WRITE: dir = "rw"; break;\r\ndefault: dir = "*ERR*"; break;\r\n}\r\npr_cont("%s ioctl '%c', dir=%s, #%d (0x%08x)",\r\ntype, _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);\r\n}\r\nstatic long __video_do_ioctl(struct file *file,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\r\nbool write_only = false;\r\nstruct v4l2_ioctl_info default_info;\r\nconst struct v4l2_ioctl_info *info;\r\nvoid *fh = file->private_data;\r\nstruct v4l2_fh *vfh = NULL;\r\nint dev_debug = vfd->dev_debug;\r\nlong ret = -ENOTTY;\r\nif (ops == NULL) {\r\npr_warn("%s: has no ioctl_ops.\n",\r\nvideo_device_node_name(vfd));\r\nreturn ret;\r\n}\r\nif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags))\r\nvfh = file->private_data;\r\nif (v4l2_is_known_ioctl(cmd)) {\r\ninfo = &v4l2_ioctls[_IOC_NR(cmd)];\r\nif (!test_bit(_IOC_NR(cmd), vfd->valid_ioctls) &&\r\n!((info->flags & INFO_FL_CTRL) && vfh && vfh->ctrl_handler))\r\ngoto done;\r\nif (vfh && (info->flags & INFO_FL_PRIO)) {\r\nret = v4l2_prio_check(vfd->prio, vfh->prio);\r\nif (ret)\r\ngoto done;\r\n}\r\n} else {\r\ndefault_info.ioctl = cmd;\r\ndefault_info.flags = 0;\r\ndefault_info.debug = v4l_print_default;\r\ninfo = &default_info;\r\n}\r\nwrite_only = _IOC_DIR(cmd) == _IOC_WRITE;\r\nif (info->flags & INFO_FL_STD) {\r\ntypedef int (*vidioc_op)(struct file *file, void *fh, void *p);\r\nconst void *p = vfd->ioctl_ops;\r\nconst vidioc_op *vidioc = p + info->u.offset;\r\nret = (*vidioc)(file, fh, arg);\r\n} else if (info->flags & INFO_FL_FUNC) {\r\nret = info->u.func(ops, file, fh, arg);\r\n} else if (!ops->vidioc_default) {\r\nret = -ENOTTY;\r\n} else {\r\nret = ops->vidioc_default(file, fh,\r\nvfh ? v4l2_prio_check(vfd->prio, vfh->prio) >= 0 : 0,\r\ncmd, arg);\r\n}\r\ndone:\r\nif (dev_debug & (V4L2_DEV_DEBUG_IOCTL | V4L2_DEV_DEBUG_IOCTL_ARG)) {\r\nif (!(dev_debug & V4L2_DEV_DEBUG_STREAMING) &&\r\n(cmd == VIDIOC_QBUF || cmd == VIDIOC_DQBUF))\r\nreturn ret;\r\nv4l_printk_ioctl(video_device_node_name(vfd), cmd);\r\nif (ret < 0)\r\npr_cont(": error %ld", ret);\r\nif (!(dev_debug & V4L2_DEV_DEBUG_IOCTL_ARG))\r\npr_cont("\n");\r\nelse if (_IOC_DIR(cmd) == _IOC_NONE)\r\ninfo->debug(arg, write_only);\r\nelse {\r\npr_cont(": ");\r\ninfo->debug(arg, write_only);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\r\nvoid __user **user_ptr, void ***kernel_ptr)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase VIDIOC_PREPARE_BUF:\r\ncase VIDIOC_QUERYBUF:\r\ncase VIDIOC_QBUF:\r\ncase VIDIOC_DQBUF: {\r\nstruct v4l2_buffer *buf = parg;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {\r\nif (buf->length > VIDEO_MAX_PLANES) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)buf->m.planes;\r\n*kernel_ptr = (void **)&buf->m.planes;\r\n*array_size = sizeof(struct v4l2_plane) * buf->length;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_EDID:\r\ncase VIDIOC_S_EDID: {\r\nstruct v4l2_edid *edid = parg;\r\nif (edid->blocks) {\r\nif (edid->blocks > 256) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)edid->edid;\r\n*kernel_ptr = (void **)&edid->edid;\r\n*array_size = edid->blocks * 128;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_EXT_CTRLS:\r\ncase VIDIOC_G_EXT_CTRLS:\r\ncase VIDIOC_TRY_EXT_CTRLS: {\r\nstruct v4l2_ext_controls *ctrls = parg;\r\nif (ctrls->count != 0) {\r\nif (ctrls->count > V4L2_CID_MAX_CTRLS) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)ctrls->controls;\r\n*kernel_ptr = (void **)&ctrls->controls;\r\n*array_size = sizeof(struct v4l2_ext_control)\r\n* ctrls->count;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nlong\r\nvideo_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\r\nv4l2_kioctl func)\r\n{\r\nchar sbuf[128];\r\nvoid *mbuf = NULL;\r\nvoid *parg = (void *)arg;\r\nlong err = -EINVAL;\r\nbool has_array_args;\r\nsize_t array_size = 0;\r\nvoid __user *user_ptr = NULL;\r\nvoid **kernel_ptr = NULL;\r\nif (_IOC_DIR(cmd) != _IOC_NONE) {\r\nif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\r\nparg = sbuf;\r\n} else {\r\nmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\r\nif (NULL == mbuf)\r\nreturn -ENOMEM;\r\nparg = mbuf;\r\n}\r\nerr = -EFAULT;\r\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\r\nunsigned int n = _IOC_SIZE(cmd);\r\nif (v4l2_is_known_ioctl(cmd)) {\r\nu32 flags = v4l2_ioctls[_IOC_NR(cmd)].flags;\r\nif (flags & INFO_FL_CLEAR_MASK)\r\nn = (flags & INFO_FL_CLEAR_MASK) >> 16;\r\n}\r\nif (copy_from_user(parg, (void __user *)arg, n))\r\ngoto out;\r\nif (n < _IOC_SIZE(cmd))\r\nmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\r\n} else {\r\nmemset(parg, 0, _IOC_SIZE(cmd));\r\n}\r\n}\r\nerr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\r\nif (err < 0)\r\ngoto out;\r\nhas_array_args = err;\r\nif (has_array_args) {\r\nmbuf = kmalloc(array_size, GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (NULL == mbuf)\r\ngoto out_array_args;\r\nerr = -EFAULT;\r\nif (copy_from_user(mbuf, user_ptr, array_size))\r\ngoto out_array_args;\r\n*kernel_ptr = mbuf;\r\n}\r\nerr = func(file, cmd, parg);\r\nif (err == -ENOIOCTLCMD)\r\nerr = -ENOTTY;\r\nif (err == 0) {\r\nif (cmd == VIDIOC_DQBUF)\r\ntrace_v4l2_dqbuf(video_devdata(file)->minor, parg);\r\nelse if (cmd == VIDIOC_QBUF)\r\ntrace_v4l2_qbuf(video_devdata(file)->minor, parg);\r\n}\r\nif (has_array_args) {\r\n*kernel_ptr = (void __force *)user_ptr;\r\nif (copy_to_user(user_ptr, mbuf, array_size))\r\nerr = -EFAULT;\r\ngoto out_array_args;\r\n}\r\nif (err < 0 && cmd != VIDIOC_QUERY_DV_TIMINGS)\r\ngoto out;\r\nout_array_args:\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_READ:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nout:\r\nkfree(mbuf);\r\nreturn err;\r\n}\r\nlong video_ioctl2(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn video_usercopy(file, cmd, arg, __video_do_ioctl);\r\n}
