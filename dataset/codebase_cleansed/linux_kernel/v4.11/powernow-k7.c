static int check_fsb(unsigned int fsbspeed)\r\n{\r\nint delta;\r\nunsigned int f = fsb / 1000;\r\ndelta = (fsbspeed > f) ? fsbspeed - f : f - fsbspeed;\r\nreturn delta < 5;\r\n}\r\nstatic int check_powernow(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nunsigned int maxei, eax, ebx, ecx, edx;\r\nif (!x86_match_cpu(powernow_k7_cpuids))\r\nreturn 0;\r\nmaxei = cpuid_eax(0x80000000);\r\nif (maxei < 0x80000007) {\r\n#ifdef MODULE\r\npr_info("No powernow capabilities detected\n");\r\n#endif\r\nreturn 0;\r\n}\r\nif ((c->x86_model == 6) && (c->x86_mask == 0)) {\r\npr_info("K7 660[A0] core detected, enabling errata workarounds\n");\r\nhave_a0 = 1;\r\n}\r\ncpuid(0x80000007, &eax, &ebx, &ecx, &edx);\r\nif (!(edx & (1 << 1 | 1 << 2)))\r\nreturn 0;\r\npr_info("PowerNOW! Technology present. Can scale: ");\r\nif (edx & 1 << 1) {\r\npr_cont("frequency");\r\ncan_scale_bus = 1;\r\n}\r\nif ((edx & (1 << 1 | 1 << 2)) == 0x6)\r\npr_cont(" and ");\r\nif (edx & 1 << 2) {\r\npr_cont("voltage");\r\ncan_scale_vid = 1;\r\n}\r\npr_cont("\n");\r\nreturn 1;\r\n}\r\nstatic void invalidate_entry(unsigned int entry)\r\n{\r\npowernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\nstatic int get_ranges(unsigned char *pst)\r\n{\r\nunsigned int j;\r\nunsigned int speed;\r\nu8 fid, vid;\r\npowernow_table = kzalloc((sizeof(*powernow_table) *\r\n(number_scales + 1)), GFP_KERNEL);\r\nif (!powernow_table)\r\nreturn -ENOMEM;\r\nfor (j = 0 ; j < number_scales; j++) {\r\nfid = *pst++;\r\npowernow_table[j].frequency = (fsb * fid_codes[fid]) / 10;\r\npowernow_table[j].driver_data = fid;\r\nspeed = powernow_table[j].frequency;\r\nif ((fid_codes[fid] % 10) == 5) {\r\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\r\nif (have_a0 == 1)\r\ninvalidate_entry(j);\r\n#endif\r\n}\r\nif (speed < minimum_speed)\r\nminimum_speed = speed;\r\nif (speed > maximum_speed)\r\nmaximum_speed = speed;\r\nvid = *pst++;\r\npowernow_table[j].driver_data |= (vid << 8);\r\npr_debug(" FID: 0x%x (%d.%dx [%dMHz]) "\r\n"VID: 0x%x (%d.%03dV)\n", fid, fid_codes[fid] / 10,\r\nfid_codes[fid] % 10, speed/1000, vid,\r\nmobile_vid_table[vid]/1000,\r\nmobile_vid_table[vid]%1000);\r\n}\r\npowernow_table[number_scales].frequency = CPUFREQ_TABLE_END;\r\npowernow_table[number_scales].driver_data = 0;\r\nreturn 0;\r\n}\r\nstatic void change_FID(int fid)\r\n{\r\nunion msr_fidvidctl fidvidctl;\r\nrdmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\r\nif (fidvidctl.bits.FID != fid) {\r\nfidvidctl.bits.SGTC = latency;\r\nfidvidctl.bits.FID = fid;\r\nfidvidctl.bits.VIDC = 0;\r\nfidvidctl.bits.FIDC = 1;\r\nwrmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\r\n}\r\n}\r\nstatic void change_VID(int vid)\r\n{\r\nunion msr_fidvidctl fidvidctl;\r\nrdmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\r\nif (fidvidctl.bits.VID != vid) {\r\nfidvidctl.bits.SGTC = latency;\r\nfidvidctl.bits.VID = vid;\r\nfidvidctl.bits.FIDC = 0;\r\nfidvidctl.bits.VIDC = 1;\r\nwrmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\r\n}\r\n}\r\nstatic int powernow_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nu8 fid, vid;\r\nstruct cpufreq_freqs freqs;\r\nunion msr_fidvidstatus fidvidstatus;\r\nint cfid;\r\nfid = powernow_table[index].driver_data & 0xFF;\r\nvid = (powernow_table[index].driver_data & 0xFF00) >> 8;\r\nrdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\r\ncfid = fidvidstatus.bits.CFID;\r\nfreqs.old = fsb * fid_codes[cfid] / 10;\r\nfreqs.new = powernow_table[index].frequency;\r\nif (have_a0 == 1)\r\nlocal_irq_disable();\r\nif (freqs.old > freqs.new) {\r\nchange_FID(fid);\r\nchange_VID(vid);\r\n} else {\r\nchange_VID(vid);\r\nchange_FID(fid);\r\n}\r\nif (have_a0 == 1)\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic int powernow_acpi_init(void)\r\n{\r\nint i;\r\nint retval = 0;\r\nunion powernow_acpi_control_t pc;\r\nif (acpi_processor_perf != NULL && powernow_table != NULL) {\r\nretval = -EINVAL;\r\ngoto err0;\r\n}\r\nacpi_processor_perf = kzalloc(sizeof(*acpi_processor_perf), GFP_KERNEL);\r\nif (!acpi_processor_perf) {\r\nretval = -ENOMEM;\r\ngoto err0;\r\n}\r\nif (!zalloc_cpumask_var(&acpi_processor_perf->shared_cpu_map,\r\nGFP_KERNEL)) {\r\nretval = -ENOMEM;\r\ngoto err05;\r\n}\r\nif (acpi_processor_register_performance(acpi_processor_perf, 0)) {\r\nretval = -EIO;\r\ngoto err1;\r\n}\r\nif (acpi_processor_perf->control_register.space_id !=\r\nACPI_ADR_SPACE_FIXED_HARDWARE) {\r\nretval = -ENODEV;\r\ngoto err2;\r\n}\r\nif (acpi_processor_perf->status_register.space_id !=\r\nACPI_ADR_SPACE_FIXED_HARDWARE) {\r\nretval = -ENODEV;\r\ngoto err2;\r\n}\r\nnumber_scales = acpi_processor_perf->state_count;\r\nif (number_scales < 2) {\r\nretval = -ENODEV;\r\ngoto err2;\r\n}\r\npowernow_table = kzalloc((sizeof(*powernow_table) *\r\n(number_scales + 1)), GFP_KERNEL);\r\nif (!powernow_table) {\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\npc.val = (unsigned long) acpi_processor_perf->states[0].control;\r\nfor (i = 0; i < number_scales; i++) {\r\nu8 fid, vid;\r\nstruct acpi_processor_px *state =\r\n&acpi_processor_perf->states[i];\r\nunsigned int speed, speed_mhz;\r\npc.val = (unsigned long) state->control;\r\npr_debug("acpi: P%d: %d MHz %d mW %d uS control %08x SGTC %d\n",\r\ni,\r\n(u32) state->core_frequency,\r\n(u32) state->power,\r\n(u32) state->transition_latency,\r\n(u32) state->control,\r\npc.bits.sgtc);\r\nvid = pc.bits.vid;\r\nfid = pc.bits.fid;\r\npowernow_table[i].frequency = fsb * fid_codes[fid] / 10;\r\npowernow_table[i].driver_data = fid;\r\npowernow_table[i].driver_data |= (vid << 8);\r\nspeed = powernow_table[i].frequency;\r\nspeed_mhz = speed / 1000;\r\nif (speed % 1000 > 0)\r\nspeed_mhz++;\r\nif ((fid_codes[fid] % 10) == 5) {\r\nif (have_a0 == 1)\r\ninvalidate_entry(i);\r\n}\r\npr_debug(" FID: 0x%x (%d.%dx [%dMHz]) "\r\n"VID: 0x%x (%d.%03dV)\n", fid, fid_codes[fid] / 10,\r\nfid_codes[fid] % 10, speed_mhz, vid,\r\nmobile_vid_table[vid]/1000,\r\nmobile_vid_table[vid]%1000);\r\nif (state->core_frequency != speed_mhz) {\r\nstate->core_frequency = speed_mhz;\r\npr_debug(" Corrected ACPI frequency to %d\n",\r\nspeed_mhz);\r\n}\r\nif (latency < pc.bits.sgtc)\r\nlatency = pc.bits.sgtc;\r\nif (speed < minimum_speed)\r\nminimum_speed = speed;\r\nif (speed > maximum_speed)\r\nmaximum_speed = speed;\r\n}\r\npowernow_table[i].frequency = CPUFREQ_TABLE_END;\r\npowernow_table[i].driver_data = 0;\r\nacpi_processor_notify_smm(THIS_MODULE);\r\nreturn 0;\r\nerr2:\r\nacpi_processor_unregister_performance(0);\r\nerr1:\r\nfree_cpumask_var(acpi_processor_perf->shared_cpu_map);\r\nerr05:\r\nkfree(acpi_processor_perf);\r\nerr0:\r\npr_warn("ACPI perflib can not be used on this platform\n");\r\nacpi_processor_perf = NULL;\r\nreturn retval;\r\n}\r\nstatic int powernow_acpi_init(void)\r\n{\r\npr_info("no support for ACPI processor found - please recompile your kernel with ACPI processor\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void print_pst_entry(struct pst_s *pst, unsigned int j)\r\n{\r\npr_debug("PST:%d (@%p)\n", j, pst);\r\npr_debug(" cpuid: 0x%x fsb: %d maxFID: 0x%x startvid: 0x%x\n",\r\npst->cpuid, pst->fsbspeed, pst->maxfid, pst->startvid);\r\n}\r\nstatic int powernow_decode_bios(int maxfid, int startvid)\r\n{\r\nstruct psb_s *psb;\r\nstruct pst_s *pst;\r\nunsigned int i, j;\r\nunsigned char *p;\r\nunsigned int etuple;\r\nunsigned int ret;\r\netuple = cpuid_eax(0x80000001);\r\nfor (i = 0xC0000; i < 0xffff0 ; i += 16) {\r\np = phys_to_virt(i);\r\nif (memcmp(p, "AMDK7PNOW!", 10) == 0) {\r\npr_debug("Found PSB header at %p\n", p);\r\npsb = (struct psb_s *) p;\r\npr_debug("Table version: 0x%x\n", psb->tableversion);\r\nif (psb->tableversion != 0x12) {\r\npr_info("Sorry, only v1.2 tables supported right now\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("Flags: 0x%x\n", psb->flags);\r\nif ((psb->flags & 1) == 0)\r\npr_debug("Mobile voltage regulator\n");\r\nelse\r\npr_debug("Desktop voltage regulator\n");\r\nlatency = psb->settlingtime;\r\nif (latency < 100) {\r\npr_info("BIOS set settling time to %d microseconds. Should be at least 100. Correcting.\n",\r\nlatency);\r\nlatency = 100;\r\n}\r\npr_debug("Settling Time: %d microseconds.\n",\r\npsb->settlingtime);\r\npr_debug("Has %d PST tables. (Only dumping ones "\r\n"relevant to this CPU).\n",\r\npsb->numpst);\r\np += sizeof(*psb);\r\npst = (struct pst_s *) p;\r\nfor (j = 0; j < psb->numpst; j++) {\r\npst = (struct pst_s *) p;\r\nnumber_scales = pst->numpstates;\r\nif ((etuple == pst->cpuid) &&\r\ncheck_fsb(pst->fsbspeed) &&\r\n(maxfid == pst->maxfid) &&\r\n(startvid == pst->startvid)) {\r\nprint_pst_entry(pst, j);\r\np = (char *)pst + sizeof(*pst);\r\nret = get_ranges(p);\r\nreturn ret;\r\n} else {\r\nunsigned int k;\r\np = (char *)pst + sizeof(*pst);\r\nfor (k = 0; k < number_scales; k++)\r\np += 2;\r\n}\r\n}\r\npr_info("No PST tables match this cpuid (0x%x)\n",\r\netuple);\r\npr_info("This is indicative of a broken BIOS\n");\r\nreturn -EINVAL;\r\n}\r\np++;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int fixup_sgtc(void)\r\n{\r\nunsigned int sgtc;\r\nunsigned int m;\r\nm = fsb / 3333;\r\nif ((m % 10) >= 5)\r\nm += 5;\r\nm /= 10;\r\nsgtc = 100 * m * latency;\r\nsgtc = sgtc / 3;\r\nif (sgtc > 0xfffff) {\r\npr_warn("SGTC too large %d\n", sgtc);\r\nsgtc = 0xfffff;\r\n}\r\nreturn sgtc;\r\n}\r\nstatic unsigned int powernow_get(unsigned int cpu)\r\n{\r\nunion msr_fidvidstatus fidvidstatus;\r\nunsigned int cfid;\r\nif (cpu)\r\nreturn 0;\r\nrdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\r\ncfid = fidvidstatus.bits.CFID;\r\nreturn fsb * fid_codes[cfid] / 10;\r\n}\r\nstatic int acer_cpufreq_pst(const struct dmi_system_id *d)\r\n{\r\npr_warn("%s laptop with broken PST tables in BIOS detected\n",\r\nd->ident);\r\npr_warn("You need to downgrade to 3A21 (09/09/2002), or try a newer BIOS than 3A71 (01/20/2003)\n");\r\npr_warn("cpufreq scaling has been disabled as a result of this\n");\r\nreturn 0;\r\n}\r\nstatic int powernow_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunion msr_fidvidstatus fidvidstatus;\r\nint result;\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nrdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\r\nrecalibrate_cpu_khz();\r\nfsb = (10 * cpu_khz) / fid_codes[fidvidstatus.bits.CFID];\r\nif (!fsb) {\r\npr_warn("can not determine bus frequency\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("FSB: %3dMHz\n", fsb/1000);\r\nif (dmi_check_system(powernow_dmi_table) || acpi_force) {\r\npr_info("PSB/PST known to be broken - trying ACPI instead\n");\r\nresult = powernow_acpi_init();\r\n} else {\r\nresult = powernow_decode_bios(fidvidstatus.bits.MFID,\r\nfidvidstatus.bits.SVID);\r\nif (result) {\r\npr_info("Trying ACPI perflib\n");\r\nmaximum_speed = 0;\r\nminimum_speed = -1;\r\nlatency = 0;\r\nresult = powernow_acpi_init();\r\nif (result) {\r\npr_info("ACPI and legacy methods failed\n");\r\n}\r\n} else {\r\nlatency = fixup_sgtc();\r\npr_info("SGTC: %d\n", latency);\r\n}\r\n}\r\nif (result)\r\nreturn result;\r\npr_info("Minimum speed %d MHz - Maximum speed %d MHz\n",\r\nminimum_speed/1000, maximum_speed/1000);\r\npolicy->cpuinfo.transition_latency =\r\ncpufreq_scale(2000000UL, fsb, latency);\r\nreturn cpufreq_table_validate_and_show(policy, powernow_table);\r\n}\r\nstatic int powernow_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\r\nif (acpi_processor_perf) {\r\nacpi_processor_unregister_performance(0);\r\nfree_cpumask_var(acpi_processor_perf->shared_cpu_map);\r\nkfree(acpi_processor_perf);\r\n}\r\n#endif\r\nkfree(powernow_table);\r\nreturn 0;\r\n}\r\nstatic int __init powernow_init(void)\r\n{\r\nif (check_powernow() == 0)\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&powernow_driver);\r\n}\r\nstatic void __exit powernow_exit(void)\r\n{\r\ncpufreq_unregister_driver(&powernow_driver);\r\n}
