static int acpi_get_rc_addr(struct acpi_device *adev, struct resource *res)\r\n{\r\nstruct device *dev = &adev->dev;\r\nstruct resource_entry *entry;\r\nstruct list_head list;\r\nunsigned long flags;\r\nint ret;\r\nINIT_LIST_HEAD(&list);\r\nflags = IORESOURCE_MEM;\r\nret = acpi_dev_get_resources(adev, &list,\r\nacpi_dev_filter_resource_type_cb,\r\n(void *) flags);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to parse _CRS method, error code %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\ndev_err(dev, "no IO and memory resources present in _CRS\n");\r\nreturn -EINVAL;\r\n}\r\nentry = list_first_entry(&list, struct resource_entry, node);\r\n*res = *entry->res;\r\nacpi_dev_free_resource_list(&list);\r\nreturn 0;\r\n}\r\nstatic acpi_status acpi_match_rc(acpi_handle handle, u32 lvl, void *context,\r\nvoid **retval)\r\n{\r\nu16 *segment = context;\r\nunsigned long long uid;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(handle, "_UID", NULL, &uid);\r\nif (ACPI_FAILURE(status) || uid != *segment)\r\nreturn AE_CTRL_DEPTH;\r\n*(acpi_handle *)retval = handle;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nint acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,\r\nstruct resource *res)\r\n{\r\nstruct acpi_device *adev;\r\nacpi_status status;\r\nacpi_handle handle;\r\nint ret;\r\nstatus = acpi_get_devices(hid, acpi_match_rc, &segment, &handle);\r\nif (ACPI_FAILURE(status)) {\r\ndev_err(dev, "can't find _HID %s device to locate resources\n",\r\nhid);\r\nreturn -ENODEV;\r\n}\r\nret = acpi_bus_get_device(handle, &adev);\r\nif (ret)\r\nreturn ret;\r\nret = acpi_get_rc_addr(adev, res);\r\nif (ret) {\r\ndev_err(dev, "can't get resource from %s\n",\r\ndev_name(&adev->dev));\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nphys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)\r\n{\r\nacpi_status status = AE_NOT_EXIST;\r\nunsigned long long mcfg_addr;\r\nif (handle)\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__CBA,\r\nNULL, &mcfg_addr);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn (phys_addr_t)mcfg_addr;\r\n}\r\nstatic acpi_status decode_type0_hpx_record(union acpi_object *record,\r\nstruct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 6)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 6; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t0 = &hpx->type0_data;\r\nhpx->t0->revision = revision;\r\nhpx->t0->cache_line_size = fields[2].integer.value;\r\nhpx->t0->latency_timer = fields[3].integer.value;\r\nhpx->t0->enable_serr = fields[4].integer.value;\r\nhpx->t0->enable_perr = fields[5].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 0 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status decode_type1_hpx_record(union acpi_object *record,\r\nstruct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 5)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 5; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t1 = &hpx->type1_data;\r\nhpx->t1->revision = revision;\r\nhpx->t1->max_mem_read = fields[2].integer.value;\r\nhpx->t1->avg_max_split = fields[3].integer.value;\r\nhpx->t1->tot_max_split = fields[4].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 1 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status decode_type2_hpx_record(union acpi_object *record,\r\nstruct hotplug_params *hpx)\r\n{\r\nint i;\r\nunion acpi_object *fields = record->package.elements;\r\nu32 revision = fields[1].integer.value;\r\nswitch (revision) {\r\ncase 1:\r\nif (record->package.count != 18)\r\nreturn AE_ERROR;\r\nfor (i = 2; i < 18; i++)\r\nif (fields[i].type != ACPI_TYPE_INTEGER)\r\nreturn AE_ERROR;\r\nhpx->t2 = &hpx->type2_data;\r\nhpx->t2->revision = revision;\r\nhpx->t2->unc_err_mask_and = fields[2].integer.value;\r\nhpx->t2->unc_err_mask_or = fields[3].integer.value;\r\nhpx->t2->unc_err_sever_and = fields[4].integer.value;\r\nhpx->t2->unc_err_sever_or = fields[5].integer.value;\r\nhpx->t2->cor_err_mask_and = fields[6].integer.value;\r\nhpx->t2->cor_err_mask_or = fields[7].integer.value;\r\nhpx->t2->adv_err_cap_and = fields[8].integer.value;\r\nhpx->t2->adv_err_cap_or = fields[9].integer.value;\r\nhpx->t2->pci_exp_devctl_and = fields[10].integer.value;\r\nhpx->t2->pci_exp_devctl_or = fields[11].integer.value;\r\nhpx->t2->pci_exp_lnkctl_and = fields[12].integer.value;\r\nhpx->t2->pci_exp_lnkctl_or = fields[13].integer.value;\r\nhpx->t2->sec_unc_err_sever_and = fields[14].integer.value;\r\nhpx->t2->sec_unc_err_sever_or = fields[15].integer.value;\r\nhpx->t2->sec_unc_err_mask_and = fields[16].integer.value;\r\nhpx->t2->sec_unc_err_mask_or = fields[17].integer.value;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"%s: Type 2 Revision %d record not supported\n",\r\n__func__, revision);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *package, *record, *fields;\r\nu32 type;\r\nint i;\r\nmemset(hpx, 0, sizeof(struct hotplug_params));\r\nstatus = acpi_evaluate_object(handle, "_HPX", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\npackage = (union acpi_object *)buffer.pointer;\r\nif (package->type != ACPI_TYPE_PACKAGE) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < package->package.count; i++) {\r\nrecord = &package->package.elements[i];\r\nif (record->type != ACPI_TYPE_PACKAGE) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfields = record->package.elements;\r\nif (fields[0].type != ACPI_TYPE_INTEGER ||\r\nfields[1].type != ACPI_TYPE_INTEGER) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\ntype = fields[0].integer.value;\r\nswitch (type) {\r\ncase 0:\r\nstatus = decode_type0_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ncase 1:\r\nstatus = decode_type1_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ncase 2:\r\nstatus = decode_type2_hpx_record(record, hpx);\r\nif (ACPI_FAILURE(status))\r\ngoto exit;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: Type %d record not supported\n",\r\n__func__, type);\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *package, *fields;\r\nint i;\r\nmemset(hpp, 0, sizeof(struct hotplug_params));\r\nstatus = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\npackage = (union acpi_object *) buffer.pointer;\r\nif (package->type != ACPI_TYPE_PACKAGE ||\r\npackage->package.count != 4) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\nfields = package->package.elements;\r\nfor (i = 0; i < 4; i++) {\r\nif (fields[i].type != ACPI_TYPE_INTEGER) {\r\nstatus = AE_ERROR;\r\ngoto exit;\r\n}\r\n}\r\nhpp->t0 = &hpp->type0_data;\r\nhpp->t0->revision = 1;\r\nhpp->t0->cache_line_size = fields[0].integer.value;\r\nhpp->t0->latency_timer = fields[1].integer.value;\r\nhpp->t0->enable_serr = fields[2].integer.value;\r\nhpp->t0->enable_perr = fields[3].integer.value;\r\nexit:\r\nkfree(buffer.pointer);\r\nreturn status;\r\n}\r\nint pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)\r\n{\r\nacpi_status status;\r\nacpi_handle handle, phandle;\r\nstruct pci_bus *pbus;\r\nif (acpi_pci_disabled)\r\nreturn -ENODEV;\r\nhandle = NULL;\r\nfor (pbus = dev->bus; pbus; pbus = pbus->parent) {\r\nhandle = acpi_pci_get_bridge_handle(pbus);\r\nif (handle)\r\nbreak;\r\n}\r\nwhile (handle) {\r\nstatus = acpi_run_hpx(handle, hpp);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nstatus = acpi_run_hpp(handle, hpp);\r\nif (ACPI_SUCCESS(status))\r\nreturn 0;\r\nif (acpi_is_root_bridge(handle))\r\nbreak;\r\nstatus = acpi_get_parent(handle, &phandle);\r\nif (ACPI_FAILURE(status))\r\nbreak;\r\nhandle = phandle;\r\n}\r\nreturn -ENODEV;\r\n}\r\nbool pciehp_is_native(struct pci_dev *pdev)\r\n{\r\nstruct acpi_pci_root *root;\r\nacpi_handle handle;\r\nhandle = acpi_find_root_bridge_handle(pdev);\r\nif (!handle)\r\nreturn false;\r\nroot = acpi_pci_find_root(handle);\r\nif (!root)\r\nreturn false;\r\nreturn root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;\r\n}\r\nstatic void pci_acpi_wake_bus(struct work_struct *work)\r\n{\r\nstruct acpi_device *adev;\r\nstruct acpi_pci_root *root;\r\nadev = container_of(work, struct acpi_device, wakeup.context.work);\r\nroot = acpi_driver_data(adev);\r\npci_pme_wakeup_bus(root->bus);\r\n}\r\nstatic void pci_acpi_wake_dev(struct work_struct *work)\r\n{\r\nstruct acpi_device_wakeup_context *context;\r\nstruct pci_dev *pci_dev;\r\ncontext = container_of(work, struct acpi_device_wakeup_context, work);\r\npci_dev = to_pci_dev(context->dev);\r\nif (pci_dev->pme_poll)\r\npci_dev->pme_poll = false;\r\nif (pci_dev->current_state == PCI_D3cold) {\r\npci_wakeup_event(pci_dev);\r\npm_runtime_resume(&pci_dev->dev);\r\nreturn;\r\n}\r\nif (pci_dev->pme_support)\r\npci_check_pme_status(pci_dev);\r\npci_wakeup_event(pci_dev);\r\npm_runtime_resume(&pci_dev->dev);\r\npci_pme_wakeup_bus(pci_dev->subordinate);\r\n}\r\nacpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)\r\n{\r\nreturn acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);\r\n}\r\nacpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,\r\nstruct pci_dev *pci_dev)\r\n{\r\nreturn acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);\r\n}\r\nstatic pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)\r\n{\r\nint acpi_state, d_max;\r\nif (pdev->no_d3cold)\r\nd_max = ACPI_STATE_D3_HOT;\r\nelse\r\nd_max = ACPI_STATE_D3_COLD;\r\nacpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL, d_max);\r\nif (acpi_state < 0)\r\nreturn PCI_POWER_ERROR;\r\nswitch (acpi_state) {\r\ncase ACPI_STATE_D0:\r\nreturn PCI_D0;\r\ncase ACPI_STATE_D1:\r\nreturn PCI_D1;\r\ncase ACPI_STATE_D2:\r\nreturn PCI_D2;\r\ncase ACPI_STATE_D3_HOT:\r\nreturn PCI_D3hot;\r\ncase ACPI_STATE_D3_COLD:\r\nreturn PCI_D3cold;\r\n}\r\nreturn PCI_POWER_ERROR;\r\n}\r\nstatic bool acpi_pci_power_manageable(struct pci_dev *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nreturn adev ? acpi_device_power_manageable(adev) : false;\r\n}\r\nstatic int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nstatic const u8 state_conv[] = {\r\n[PCI_D0] = ACPI_STATE_D0,\r\n[PCI_D1] = ACPI_STATE_D1,\r\n[PCI_D2] = ACPI_STATE_D2,\r\n[PCI_D3hot] = ACPI_STATE_D3_HOT,\r\n[PCI_D3cold] = ACPI_STATE_D3_COLD,\r\n};\r\nint error = -EINVAL;\r\nif (!adev || acpi_has_method(adev->handle, "_EJ0"))\r\nreturn -ENODEV;\r\nswitch (state) {\r\ncase PCI_D3cold:\r\nif (dev_pm_qos_flags(&dev->dev, PM_QOS_FLAG_NO_POWER_OFF) ==\r\nPM_QOS_FLAGS_ALL) {\r\nerror = -EBUSY;\r\nbreak;\r\n}\r\ncase PCI_D0:\r\ncase PCI_D1:\r\ncase PCI_D2:\r\ncase PCI_D3hot:\r\nerror = acpi_device_set_power(adev, state_conv[state]);\r\n}\r\nif (!error)\r\ndev_dbg(&dev->dev, "power state changed by ACPI to %s\n",\r\nacpi_power_state_string(state_conv[state]));\r\nreturn error;\r\n}\r\nstatic pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nstatic const pci_power_t state_conv[] = {\r\n[ACPI_STATE_D0] = PCI_D0,\r\n[ACPI_STATE_D1] = PCI_D1,\r\n[ACPI_STATE_D2] = PCI_D2,\r\n[ACPI_STATE_D3_HOT] = PCI_D3hot,\r\n[ACPI_STATE_D3_COLD] = PCI_D3cold,\r\n};\r\nint state;\r\nif (!adev || !acpi_device_power_manageable(adev))\r\nreturn PCI_UNKNOWN;\r\nif (acpi_device_get_power(adev, &state) || state == ACPI_STATE_UNKNOWN)\r\nreturn PCI_UNKNOWN;\r\nreturn state_conv[state];\r\n}\r\nstatic bool acpi_pci_can_wakeup(struct pci_dev *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nreturn adev ? acpi_device_can_wakeup(adev) : false;\r\n}\r\nstatic void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)\r\n{\r\nwhile (bus->parent) {\r\nif (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))\r\nreturn;\r\nbus = bus->parent;\r\n}\r\nif (bus->bridge)\r\nacpi_pm_device_sleep_wake(bus->bridge, enable);\r\n}\r\nstatic int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)\r\n{\r\nif (acpi_pci_can_wakeup(dev))\r\nreturn acpi_pm_device_sleep_wake(&dev->dev, enable);\r\nacpi_pci_propagate_wakeup_enable(dev->bus, enable);\r\nreturn 0;\r\n}\r\nstatic void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)\r\n{\r\nwhile (bus->parent) {\r\nstruct pci_dev *bridge = bus->self;\r\nif (bridge->pme_interrupt)\r\nreturn;\r\nif (!acpi_pm_device_run_wake(&bridge->dev, enable))\r\nreturn;\r\nbus = bus->parent;\r\n}\r\nif (bus->bridge)\r\nacpi_pm_device_run_wake(bus->bridge, enable);\r\n}\r\nstatic int acpi_pci_run_wake(struct pci_dev *dev, bool enable)\r\n{\r\nif (dev->pme_interrupt && !dev->runtime_d3cold)\r\nreturn 0;\r\nif (!acpi_pm_device_run_wake(&dev->dev, enable))\r\nreturn 0;\r\nacpi_pci_propagate_run_wake(dev->bus, enable);\r\nreturn 0;\r\n}\r\nstatic bool acpi_pci_need_resume(struct pci_dev *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(&dev->dev);\r\nif (!adev || !acpi_device_power_manageable(adev))\r\nreturn false;\r\nif (device_may_wakeup(&dev->dev) != !!adev->wakeup.prepare_count)\r\nreturn true;\r\nif (acpi_target_system_state() == ACPI_STATE_S0)\r\nreturn false;\r\nreturn !!adev->power.flags.dsw_present;\r\n}\r\nvoid acpi_pci_add_bus(struct pci_bus *bus)\r\n{\r\nunion acpi_object *obj;\r\nstruct pci_host_bridge *bridge;\r\nif (acpi_pci_disabled || !bus->bridge)\r\nreturn;\r\nacpi_pci_slot_enumerate(bus);\r\nacpiphp_enumerate_slots(bus);\r\nif (!pci_is_root_bus(bus))\r\nreturn;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), pci_acpi_dsm_uuid, 3,\r\nRESET_DELAY_DSM, NULL);\r\nif (!obj)\r\nreturn;\r\nif (obj->type == ACPI_TYPE_INTEGER && obj->integer.value == 1) {\r\nbridge = pci_find_host_bridge(bus);\r\nbridge->ignore_reset_delay = 1;\r\n}\r\nACPI_FREE(obj);\r\n}\r\nvoid acpi_pci_remove_bus(struct pci_bus *bus)\r\n{\r\nif (acpi_pci_disabled || !bus->bridge)\r\nreturn;\r\nacpiphp_remove_slots(bus);\r\nacpi_pci_slot_remove(bus);\r\n}\r\nstatic struct acpi_device *acpi_pci_find_companion(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nbool check_children;\r\nu64 addr;\r\ncheck_children = pci_is_bridge(pci_dev);\r\naddr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);\r\nreturn acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,\r\ncheck_children);\r\n}\r\nstatic void pci_acpi_optimize_delay(struct pci_dev *pdev,\r\nacpi_handle handle)\r\n{\r\nstruct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);\r\nint value;\r\nunion acpi_object *obj, *elements;\r\nif (bridge->ignore_reset_delay)\r\npdev->d3cold_delay = 0;\r\nobj = acpi_evaluate_dsm(handle, pci_acpi_dsm_uuid, 3,\r\nFUNCTION_DELAY_DSM, NULL);\r\nif (!obj)\r\nreturn;\r\nif (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 5) {\r\nelements = obj->package.elements;\r\nif (elements[0].type == ACPI_TYPE_INTEGER) {\r\nvalue = (int)elements[0].integer.value / 1000;\r\nif (value < PCI_PM_D3COLD_WAIT)\r\npdev->d3cold_delay = value;\r\n}\r\nif (elements[3].type == ACPI_TYPE_INTEGER) {\r\nvalue = (int)elements[3].integer.value / 1000;\r\nif (value < PCI_PM_D3_WAIT)\r\npdev->d3_delay = value;\r\n}\r\n}\r\nACPI_FREE(obj);\r\n}\r\nstatic void pci_acpi_setup(struct device *dev)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(dev);\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn;\r\npci_acpi_optimize_delay(pci_dev, adev->handle);\r\npci_acpi_add_pm_notifier(adev, pci_dev);\r\nif (!adev->wakeup.flags.valid)\r\nreturn;\r\ndevice_set_wakeup_capable(dev, true);\r\nacpi_pci_sleep_wake(pci_dev, false);\r\nif (adev->wakeup.flags.run_wake)\r\ndevice_set_run_wake(dev, true);\r\n}\r\nstatic void pci_acpi_cleanup(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn;\r\npci_acpi_remove_pm_notifier(adev);\r\nif (adev->wakeup.flags.valid) {\r\ndevice_set_wakeup_capable(dev, false);\r\ndevice_set_run_wake(dev, false);\r\n}\r\n}\r\nstatic bool pci_acpi_bus_match(struct device *dev)\r\n{\r\nreturn dev_is_pci(dev);\r\n}\r\nstruct irq_domain *pci_host_bridge_acpi_msi_domain(struct pci_bus *bus)\r\n{\r\nstruct fwnode_handle *fwnode;\r\nif (!pci_msi_get_fwnode_cb)\r\nreturn NULL;\r\nfwnode = pci_msi_get_fwnode_cb(&bus->dev);\r\nif (!fwnode)\r\nreturn NULL;\r\nreturn irq_find_matching_fwnode(fwnode, DOMAIN_BUS_PCI_MSI);\r\n}\r\nstatic int __init acpi_pci_init(void)\r\n{\r\nint ret;\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_MSI) {\r\npr_info("ACPI FADT declares the system doesn't support MSI, so disable it\n");\r\npci_no_msi();\r\n}\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\r\npr_info("ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");\r\npcie_no_aspm();\r\n}\r\nret = register_acpi_bus_type(&acpi_pci_bus);\r\nif (ret)\r\nreturn 0;\r\npci_set_platform_pm(&acpi_pci_platform_pm);\r\nacpi_pci_slot_init();\r\nacpiphp_init();\r\nreturn 0;\r\n}
