static u64 dlm_get_next_mig_cookie(void)\r\n{\r\nu64 c;\r\nspin_lock(&dlm_mig_cookie_lock);\r\nc = dlm_mig_cookie;\r\nif (dlm_mig_cookie == (~0ULL))\r\ndlm_mig_cookie = 1;\r\nelse\r\ndlm_mig_cookie++;\r\nspin_unlock(&dlm_mig_cookie_lock);\r\nreturn c;\r\n}\r\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\r\nu8 dead_node)\r\n{\r\nassert_spin_locked(&dlm->spinlock);\r\nif (dlm->reco.dead_node != dead_node)\r\nmlog(0, "%s: changing dead_node from %u to %u\n",\r\ndlm->name, dlm->reco.dead_node, dead_node);\r\ndlm->reco.dead_node = dead_node;\r\n}\r\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\r\nu8 master)\r\n{\r\nassert_spin_locked(&dlm->spinlock);\r\nmlog(0, "%s: changing new_master from %u to %u\n",\r\ndlm->name, dlm->reco.new_master, master);\r\ndlm->reco.new_master = master;\r\n}\r\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\r\n{\r\nassert_spin_locked(&dlm->spinlock);\r\nclear_bit(dlm->reco.dead_node, dlm->recovery_map);\r\ndlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\r\ndlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\r\n}\r\nstatic inline void dlm_reset_recovery(struct dlm_ctxt *dlm)\r\n{\r\nspin_lock(&dlm->spinlock);\r\n__dlm_reset_recovery(dlm);\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nvoid dlm_dispatch_work(struct work_struct *work)\r\n{\r\nstruct dlm_ctxt *dlm =\r\ncontainer_of(work, struct dlm_ctxt, dispatched_work);\r\nLIST_HEAD(tmp_list);\r\nstruct dlm_work_item *item, *next;\r\ndlm_workfunc_t *workfunc;\r\nint tot=0;\r\nspin_lock(&dlm->work_lock);\r\nlist_splice_init(&dlm->work_list, &tmp_list);\r\nspin_unlock(&dlm->work_lock);\r\nlist_for_each_entry(item, &tmp_list, list) {\r\ntot++;\r\n}\r\nmlog(0, "%s: work thread has %d work items\n", dlm->name, tot);\r\nlist_for_each_entry_safe(item, next, &tmp_list, list) {\r\nworkfunc = item->func;\r\nlist_del_init(&item->list);\r\nBUG_ON(item->dlm != dlm);\r\nworkfunc(item, item->data);\r\ndlm_put(dlm);\r\nkfree(item);\r\n}\r\n}\r\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\r\n{\r\nwake_up(&dlm->dlm_reco_thread_wq);\r\n}\r\nint dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\r\n{\r\nmlog(0, "starting dlm recovery thread...\n");\r\ndlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\r\n"dlm_reco-%s", dlm->name);\r\nif (IS_ERR(dlm->dlm_reco_thread_task)) {\r\nmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\r\ndlm->dlm_reco_thread_task = NULL;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\r\n{\r\nif (dlm->dlm_reco_thread_task) {\r\nmlog(0, "waiting for dlm recovery thread to exit\n");\r\nkthread_stop(dlm->dlm_reco_thread_task);\r\ndlm->dlm_reco_thread_task = NULL;\r\n}\r\n}\r\nstatic void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\r\n{\r\nstruct dlm_reco_node_data *ndata;\r\nstruct dlm_lock_resource *res;\r\nmlog(ML_NOTICE, "%s(%d): recovery info, state=%s, dead=%u, master=%u\n",\r\ndlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\r\ndlm->reco.state & DLM_RECO_STATE_ACTIVE ? "ACTIVE" : "inactive",\r\ndlm->reco.dead_node, dlm->reco.new_master);\r\nlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\r\nchar *st = "unknown";\r\nswitch (ndata->state) {\r\ncase DLM_RECO_NODE_DATA_INIT:\r\nst = "init";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_REQUESTING:\r\nst = "requesting";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DEAD:\r\nst = "dead";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_RECEIVING:\r\nst = "receiving";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_REQUESTED:\r\nst = "requested";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DONE:\r\nst = "done";\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_FINALIZE_SENT:\r\nst = "finalize-sent";\r\nbreak;\r\ndefault:\r\nst = "bad";\r\nbreak;\r\n}\r\nmlog(ML_NOTICE, "%s: reco state, node %u, state=%s\n",\r\ndlm->name, ndata->node_num, st);\r\n}\r\nlist_for_each_entry(res, &dlm->reco.resources, recovering) {\r\nmlog(ML_NOTICE, "%s: lockres %.*s on recovering list\n",\r\ndlm->name, res->lockname.len, res->lockname.name);\r\n}\r\n}\r\nstatic int dlm_recovery_thread(void *data)\r\n{\r\nint status;\r\nstruct dlm_ctxt *dlm = data;\r\nunsigned long timeout = msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS);\r\nmlog(0, "dlm thread running for %s...\n", dlm->name);\r\nwhile (!kthread_should_stop()) {\r\nif (dlm_domain_fully_joined(dlm)) {\r\nstatus = dlm_do_recovery(dlm);\r\nif (status == -EAGAIN) {\r\ncontinue;\r\n}\r\nif (status < 0)\r\nmlog_errno(status);\r\n}\r\nwait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\r\nkthread_should_stop(),\r\ntimeout);\r\n}\r\nmlog(0, "quitting DLM recovery thread\n");\r\nreturn 0;\r\n}\r\nstatic int dlm_reco_master_ready(struct dlm_ctxt *dlm)\r\n{\r\nint ready;\r\nspin_lock(&dlm->spinlock);\r\nready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\r\nspin_unlock(&dlm->spinlock);\r\nreturn ready;\r\n}\r\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\r\n{\r\nint dead;\r\nspin_lock(&dlm->spinlock);\r\ndead = !test_bit(node, dlm->domain_map);\r\nspin_unlock(&dlm->spinlock);\r\nreturn dead;\r\n}\r\nstatic int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\r\n{\r\nint recovered;\r\nspin_lock(&dlm->spinlock);\r\nrecovered = !test_bit(node, dlm->recovery_map);\r\nspin_unlock(&dlm->spinlock);\r\nreturn recovered;\r\n}\r\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\r\n{\r\nif (dlm_is_node_dead(dlm, node))\r\nreturn;\r\nprintk(KERN_NOTICE "o2dlm: Waiting on the death of node %u in "\r\n"domain %s\n", node, dlm->name);\r\nif (timeout)\r\nwait_event_timeout(dlm->dlm_reco_thread_wq,\r\ndlm_is_node_dead(dlm, node),\r\nmsecs_to_jiffies(timeout));\r\nelse\r\nwait_event(dlm->dlm_reco_thread_wq,\r\ndlm_is_node_dead(dlm, node));\r\n}\r\nvoid dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\r\n{\r\nif (dlm_is_node_recovered(dlm, node))\r\nreturn;\r\nprintk(KERN_NOTICE "o2dlm: Waiting on the recovery of node %u in "\r\n"domain %s\n", node, dlm->name);\r\nif (timeout)\r\nwait_event_timeout(dlm->dlm_reco_thread_wq,\r\ndlm_is_node_recovered(dlm, node),\r\nmsecs_to_jiffies(timeout));\r\nelse\r\nwait_event(dlm->dlm_reco_thread_wq,\r\ndlm_is_node_recovered(dlm, node));\r\n}\r\nstatic int dlm_in_recovery(struct dlm_ctxt *dlm)\r\n{\r\nint in_recovery;\r\nspin_lock(&dlm->spinlock);\r\nin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\r\nspin_unlock(&dlm->spinlock);\r\nreturn in_recovery;\r\n}\r\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm)\r\n{\r\nif (dlm_in_recovery(dlm)) {\r\nmlog(0, "%s: reco thread %d in recovery: "\r\n"state=%d, master=%u, dead=%u\n",\r\ndlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\r\ndlm->reco.state, dlm->reco.new_master,\r\ndlm->reco.dead_node);\r\n}\r\nwait_event(dlm->reco.event, !dlm_in_recovery(dlm));\r\n}\r\nstatic void dlm_begin_recovery(struct dlm_ctxt *dlm)\r\n{\r\nspin_lock(&dlm->spinlock);\r\nBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\r\nprintk(KERN_NOTICE "o2dlm: Begin recovery on domain %s for node %u\n",\r\ndlm->name, dlm->reco.dead_node);\r\ndlm->reco.state |= DLM_RECO_STATE_ACTIVE;\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nstatic void dlm_end_recovery(struct dlm_ctxt *dlm)\r\n{\r\nspin_lock(&dlm->spinlock);\r\nBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\r\ndlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\r\nspin_unlock(&dlm->spinlock);\r\nprintk(KERN_NOTICE "o2dlm: End recovery on domain %s\n", dlm->name);\r\nwake_up(&dlm->reco.event);\r\n}\r\nstatic void dlm_print_recovery_master(struct dlm_ctxt *dlm)\r\n{\r\nprintk(KERN_NOTICE "o2dlm: Node %u (%s) is the Recovery Master for the "\r\n"dead node %u in domain %s\n", dlm->reco.new_master,\r\n(dlm->node_num == dlm->reco.new_master ? "me" : "he"),\r\ndlm->reco.dead_node, dlm->name);\r\n}\r\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm)\r\n{\r\nint status = 0;\r\nint ret;\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\r\ntest_bit(dlm->reco.new_master, dlm->recovery_map)) {\r\nmlog(0, "new master %u died while recovering %u!\n",\r\ndlm->reco.new_master, dlm->reco.dead_node);\r\ndlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\r\n}\r\nif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\r\nint bit;\r\nbit = find_next_bit (dlm->recovery_map, O2NM_MAX_NODES, 0);\r\nif (bit >= O2NM_MAX_NODES || bit < 0)\r\ndlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\r\nelse\r\ndlm_set_reco_dead_node(dlm, bit);\r\n} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\r\nmlog(ML_ERROR, "dead_node %u no longer in recovery map!\n",\r\ndlm->reco.dead_node);\r\ndlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\r\n}\r\nif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\r\nspin_unlock(&dlm->spinlock);\r\nreturn 0;\r\n}\r\nmlog(0, "%s(%d):recovery thread found node %u in the recovery map!\n",\r\ndlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\r\ndlm->reco.dead_node);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_begin_recovery(dlm);\r\nif (dlm->reco.new_master == dlm->node_num)\r\ngoto master_here;\r\nif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\r\nret = dlm_pick_recovery_master(dlm);\r\nif (!ret) {\r\ngoto master_here;\r\n}\r\nmlog(0, "another node will master this recovery session.\n");\r\n}\r\ndlm_print_recovery_master(dlm);\r\ndlm_end_recovery(dlm);\r\nreturn 0;\r\nmaster_here:\r\ndlm_print_recovery_master(dlm);\r\nstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\r\nif (status < 0) {\r\nmlog(ML_ERROR, "%s: Error %d remastering locks for node %u, "\r\n"retrying.\n", dlm->name, status, dlm->reco.dead_node);\r\nmsleep(100);\r\n} else {\r\nmlog(0, "DONE mastering recovery of %s:%u here(this=%u)!\n",\r\ndlm->name, dlm->reco.dead_node, dlm->node_num);\r\nspin_lock(&dlm->spinlock);\r\n__dlm_reset_recovery(dlm);\r\ndlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\r\nspin_unlock(&dlm->spinlock);\r\n}\r\ndlm_end_recovery(dlm);\r\nreturn -EAGAIN;\r\n}\r\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\r\n{\r\nint status = 0;\r\nstruct dlm_reco_node_data *ndata;\r\nint all_nodes_done;\r\nint destroy = 0;\r\nint pass = 0;\r\ndo {\r\nstatus = dlm_init_recovery_area(dlm, dead_node);\r\nif (status < 0) {\r\nmlog(ML_ERROR, "%s: failed to alloc recovery area, "\r\n"retrying\n", dlm->name);\r\nmsleep(1000);\r\n}\r\n} while (status != 0);\r\nlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\r\nBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\r\nndata->state = DLM_RECO_NODE_DATA_REQUESTING;\r\nmlog(0, "%s: Requesting lock info from node %u\n", dlm->name,\r\nndata->node_num);\r\nif (ndata->node_num == dlm->node_num) {\r\nndata->state = DLM_RECO_NODE_DATA_DONE;\r\ncontinue;\r\n}\r\ndo {\r\nstatus = dlm_request_all_locks(dlm, ndata->node_num,\r\ndead_node);\r\nif (status < 0) {\r\nmlog_errno(status);\r\nif (dlm_is_host_down(status)) {\r\nstatus = 0;\r\nndata->state = DLM_RECO_NODE_DATA_DEAD;\r\nwait_event_timeout(dlm->dlm_reco_thread_wq,\r\ndlm_is_node_dead(dlm,\r\nndata->node_num),\r\nmsecs_to_jiffies(1000));\r\nmlog(0, "waited 1 sec for %u, "\r\n"dead? %s\n", ndata->node_num,\r\ndlm_is_node_dead(dlm, ndata->node_num) ?\r\n"yes" : "no");\r\n} else {\r\nmlog(0, "%s: node %u returned "\r\n"%d during recovery, retrying "\r\n"after a short wait\n",\r\ndlm->name, ndata->node_num,\r\nstatus);\r\nmsleep(100);\r\n}\r\n}\r\n} while (status != 0);\r\nspin_lock(&dlm_reco_state_lock);\r\nswitch (ndata->state) {\r\ncase DLM_RECO_NODE_DATA_INIT:\r\ncase DLM_RECO_NODE_DATA_FINALIZE_SENT:\r\ncase DLM_RECO_NODE_DATA_REQUESTED:\r\nBUG();\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DEAD:\r\nmlog(0, "node %u died after requesting "\r\n"recovery info for node %u\n",\r\nndata->node_num, dead_node);\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_REQUESTING:\r\nndata->state = DLM_RECO_NODE_DATA_REQUESTED;\r\nmlog(0, "now receiving recovery data from "\r\n"node %u for dead node %u\n",\r\nndata->node_num, dead_node);\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_RECEIVING:\r\nmlog(0, "already receiving recovery data from "\r\n"node %u for dead node %u\n",\r\nndata->node_num, dead_node);\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DONE:\r\nmlog(0, "already DONE receiving recovery data "\r\n"from node %u for dead node %u\n",\r\nndata->node_num, dead_node);\r\nbreak;\r\n}\r\nspin_unlock(&dlm_reco_state_lock);\r\n}\r\nmlog(0, "%s: Done requesting all lock info\n", dlm->name);\r\nwhile (1) {\r\nall_nodes_done = 1;\r\nspin_lock(&dlm_reco_state_lock);\r\nlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\r\nmlog(0, "checking recovery state of node %u\n",\r\nndata->node_num);\r\nswitch (ndata->state) {\r\ncase DLM_RECO_NODE_DATA_INIT:\r\ncase DLM_RECO_NODE_DATA_REQUESTING:\r\nmlog(ML_ERROR, "bad ndata state for "\r\n"node %u: state=%d\n",\r\nndata->node_num, ndata->state);\r\nBUG();\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DEAD:\r\nmlog(0, "node %u died after "\r\n"requesting recovery info for "\r\n"node %u\n", ndata->node_num,\r\ndead_node);\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_RECEIVING:\r\ncase DLM_RECO_NODE_DATA_REQUESTED:\r\nmlog(0, "%s: node %u still in state %s\n",\r\ndlm->name, ndata->node_num,\r\nndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\r\n"receiving" : "requested");\r\nall_nodes_done = 0;\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DONE:\r\nmlog(0, "%s: node %u state is done\n",\r\ndlm->name, ndata->node_num);\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_FINALIZE_SENT:\r\nmlog(0, "%s: node %u state is finalize\n",\r\ndlm->name, ndata->node_num);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dlm_reco_state_lock);\r\nmlog(0, "pass #%d, all_nodes_done?: %s\n", ++pass,\r\nall_nodes_done?"yes":"no");\r\nif (all_nodes_done) {\r\nint ret;\r\nspin_lock(&dlm->spinlock);\r\ndlm->reco.state |= DLM_RECO_STATE_FINALIZE;\r\nspin_unlock(&dlm->spinlock);\r\nmlog(0, "all nodes are done! send finalize\n");\r\nret = dlm_send_finalize_reco_message(dlm);\r\nif (ret < 0)\r\nmlog_errno(ret);\r\nspin_lock(&dlm->spinlock);\r\ndlm_finish_local_lockres_recovery(dlm, dead_node,\r\ndlm->node_num);\r\nspin_unlock(&dlm->spinlock);\r\nmlog(0, "should be done with recovery!\n");\r\nmlog(0, "finishing recovery of %s at %lu, "\r\n"dead=%u, this=%u, new=%u\n", dlm->name,\r\njiffies, dlm->reco.dead_node,\r\ndlm->node_num, dlm->reco.new_master);\r\ndestroy = 1;\r\nstatus = 0;\r\ndlm_kick_thread(dlm, NULL);\r\nbreak;\r\n}\r\nwait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\r\nkthread_should_stop(),\r\nmsecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\r\n}\r\nif (destroy)\r\ndlm_destroy_recovery_area(dlm, dead_node);\r\nreturn status;\r\n}\r\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\r\n{\r\nint num=0;\r\nstruct dlm_reco_node_data *ndata;\r\nspin_lock(&dlm->spinlock);\r\nmemcpy(dlm->reco.node_map, dlm->domain_map, sizeof(dlm->domain_map));\r\nspin_unlock(&dlm->spinlock);\r\nwhile (1) {\r\nnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\r\nif (num >= O2NM_MAX_NODES) {\r\nbreak;\r\n}\r\nBUG_ON(num == dead_node);\r\nndata = kzalloc(sizeof(*ndata), GFP_NOFS);\r\nif (!ndata) {\r\ndlm_destroy_recovery_area(dlm, dead_node);\r\nreturn -ENOMEM;\r\n}\r\nndata->node_num = num;\r\nndata->state = DLM_RECO_NODE_DATA_INIT;\r\nspin_lock(&dlm_reco_state_lock);\r\nlist_add_tail(&ndata->list, &dlm->reco.node_data);\r\nspin_unlock(&dlm_reco_state_lock);\r\nnum++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\r\n{\r\nstruct dlm_reco_node_data *ndata, *next;\r\nLIST_HEAD(tmplist);\r\nspin_lock(&dlm_reco_state_lock);\r\nlist_splice_init(&dlm->reco.node_data, &tmplist);\r\nspin_unlock(&dlm_reco_state_lock);\r\nlist_for_each_entry_safe(ndata, next, &tmplist, list) {\r\nlist_del_init(&ndata->list);\r\nkfree(ndata);\r\n}\r\n}\r\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\r\nu8 dead_node)\r\n{\r\nstruct dlm_lock_request lr;\r\nint ret;\r\nint status;\r\nmlog(0, "\n");\r\nmlog(0, "dlm_request_all_locks: dead node is %u, sending request "\r\n"to %u\n", dead_node, request_from);\r\nmemset(&lr, 0, sizeof(lr));\r\nlr.node_idx = dlm->node_num;\r\nlr.dead_node = dead_node;\r\nret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\r\n&lr, sizeof(lr), request_from, &status);\r\nif (ret < 0)\r\nmlog(ML_ERROR, "%s: Error %d send LOCK_REQUEST to node %u "\r\n"to recover dead node %u\n", dlm->name, ret,\r\nrequest_from, dead_node);\r\nelse\r\nret = status;\r\nreturn ret;\r\n}\r\nint dlm_request_all_locks_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_lock_request *lr = (struct dlm_lock_request *)msg->buf;\r\nchar *buf = NULL;\r\nstruct dlm_work_item *item = NULL;\r\nif (!dlm_grab(dlm))\r\nreturn -EINVAL;\r\nif (lr->dead_node != dlm->reco.dead_node) {\r\nmlog(ML_ERROR, "%s: node %u sent dead_node=%u, but local "\r\n"dead_node is %u\n", dlm->name, lr->node_idx,\r\nlr->dead_node, dlm->reco.dead_node);\r\ndlm_print_reco_node_status(dlm);\r\ndlm_put(dlm);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(lr->dead_node != dlm->reco.dead_node);\r\nitem = kzalloc(sizeof(*item), GFP_NOFS);\r\nif (!item) {\r\ndlm_put(dlm);\r\nreturn -ENOMEM;\r\n}\r\nbuf = (char *) __get_free_page(GFP_NOFS);\r\nif (!buf) {\r\nkfree(item);\r\ndlm_put(dlm);\r\nreturn -ENOMEM;\r\n}\r\ndlm_grab(dlm);\r\ndlm_init_work_item(dlm, item, dlm_request_all_locks_worker, buf);\r\nitem->u.ral.reco_master = lr->node_idx;\r\nitem->u.ral.dead_node = lr->dead_node;\r\nspin_lock(&dlm->work_lock);\r\nlist_add_tail(&item->list, &dlm->work_list);\r\nspin_unlock(&dlm->work_lock);\r\nqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\r\ndlm_put(dlm);\r\nreturn 0;\r\n}\r\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item, void *data)\r\n{\r\nstruct dlm_migratable_lockres *mres;\r\nstruct dlm_lock_resource *res;\r\nstruct dlm_ctxt *dlm;\r\nLIST_HEAD(resources);\r\nint ret;\r\nu8 dead_node, reco_master;\r\nint skip_all_done = 0;\r\ndlm = item->dlm;\r\ndead_node = item->u.ral.dead_node;\r\nreco_master = item->u.ral.reco_master;\r\nmres = (struct dlm_migratable_lockres *)data;\r\nmlog(0, "%s: recovery worker started, dead=%u, master=%u\n",\r\ndlm->name, dead_node, reco_master);\r\nif (dead_node != dlm->reco.dead_node ||\r\nreco_master != dlm->reco.new_master) {\r\nif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\r\nmlog(ML_NOTICE, "%s: will not send recovery state, "\r\n"recovery master %u died, thread=(dead=%u,mas=%u)"\r\n" current=(dead=%u,mas=%u)\n", dlm->name,\r\nreco_master, dead_node, reco_master,\r\ndlm->reco.dead_node, dlm->reco.new_master);\r\n} else {\r\nmlog(ML_NOTICE, "%s: reco state invalid: reco(dead=%u, "\r\n"master=%u), request(dead=%u, master=%u)\n",\r\ndlm->name, dlm->reco.dead_node,\r\ndlm->reco.new_master, dead_node, reco_master);\r\n}\r\ngoto leave;\r\n}\r\ndlm_move_reco_locks_to_list(dlm, &resources, dead_node);\r\nlist_for_each_entry(res, &resources, recovering) {\r\nret = dlm_send_one_lockres(dlm, res, mres, reco_master,\r\nDLM_MRES_RECOVERY);\r\nif (ret < 0) {\r\nmlog(ML_ERROR, "%s: node %u went down while sending "\r\n"recovery state for dead node %u, ret=%d\n", dlm->name,\r\nreco_master, dead_node, ret);\r\nskip_all_done = 1;\r\nbreak;\r\n}\r\n}\r\nspin_lock(&dlm->spinlock);\r\nlist_splice_init(&resources, &dlm->reco.resources);\r\nspin_unlock(&dlm->spinlock);\r\nif (!skip_all_done) {\r\nret = dlm_send_all_done_msg(dlm, dead_node, reco_master);\r\nif (ret < 0) {\r\nmlog(ML_ERROR, "%s: node %u went down while sending "\r\n"recovery all-done for dead node %u, ret=%d\n",\r\ndlm->name, reco_master, dead_node, ret);\r\n}\r\n}\r\nleave:\r\nfree_page((unsigned long)data);\r\n}\r\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\r\n{\r\nint ret, tmpret;\r\nstruct dlm_reco_data_done done_msg;\r\nmemset(&done_msg, 0, sizeof(done_msg));\r\ndone_msg.node_idx = dlm->node_num;\r\ndone_msg.dead_node = dead_node;\r\nmlog(0, "sending DATA DONE message to %u, "\r\n"my node=%u, dead node=%u\n", send_to, done_msg.node_idx,\r\ndone_msg.dead_node);\r\nret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\r\nsizeof(done_msg), send_to, &tmpret);\r\nif (ret < 0) {\r\nmlog(ML_ERROR, "%s: Error %d send RECO_DATA_DONE to node %u "\r\n"to recover dead node %u\n", dlm->name, ret, send_to,\r\ndead_node);\r\nif (!dlm_is_host_down(ret)) {\r\nBUG();\r\n}\r\n} else\r\nret = tmpret;\r\nreturn ret;\r\n}\r\nint dlm_reco_data_done_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_reco_data_done *done = (struct dlm_reco_data_done *)msg->buf;\r\nstruct dlm_reco_node_data *ndata = NULL;\r\nint ret = -EINVAL;\r\nif (!dlm_grab(dlm))\r\nreturn -EINVAL;\r\nmlog(0, "got DATA DONE: dead_node=%u, reco.dead_node=%u, "\r\n"node_idx=%u, this node=%u\n", done->dead_node,\r\ndlm->reco.dead_node, done->node_idx, dlm->node_num);\r\nmlog_bug_on_msg((done->dead_node != dlm->reco.dead_node),\r\n"Got DATA DONE: dead_node=%u, reco.dead_node=%u, "\r\n"node_idx=%u, this node=%u\n", done->dead_node,\r\ndlm->reco.dead_node, done->node_idx, dlm->node_num);\r\nspin_lock(&dlm_reco_state_lock);\r\nlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\r\nif (ndata->node_num != done->node_idx)\r\ncontinue;\r\nswitch (ndata->state) {\r\ncase DLM_RECO_NODE_DATA_INIT:\r\ncase DLM_RECO_NODE_DATA_DEAD:\r\ncase DLM_RECO_NODE_DATA_FINALIZE_SENT:\r\nmlog(ML_ERROR, "bad ndata state for node %u:"\r\n" state=%d\n", ndata->node_num,\r\nndata->state);\r\nBUG();\r\nbreak;\r\ncase DLM_RECO_NODE_DATA_DONE:\r\ncase DLM_RECO_NODE_DATA_RECEIVING:\r\ncase DLM_RECO_NODE_DATA_REQUESTED:\r\ncase DLM_RECO_NODE_DATA_REQUESTING:\r\nmlog(0, "node %u is DONE sending "\r\n"recovery data!\n",\r\nndata->node_num);\r\nndata->state = DLM_RECO_NODE_DATA_DONE;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dlm_reco_state_lock);\r\nif (!ret)\r\ndlm_kick_recovery_thread(dlm);\r\nif (ret < 0)\r\nmlog(ML_ERROR, "failed to find recovery node data for node "\r\n"%u\n", done->node_idx);\r\ndlm_put(dlm);\r\nmlog(0, "leaving reco data done handler, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\r\nstruct list_head *list,\r\nu8 dead_node)\r\n{\r\nstruct dlm_lock_resource *res, *next;\r\nstruct dlm_lock *lock;\r\nspin_lock(&dlm->spinlock);\r\nlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\r\nif (dlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nspin_lock(&res->spinlock);\r\nlist_for_each_entry(lock, &res->granted, list) {\r\nif (lock->ml.node == dead_node) {\r\nmlog(0, "AHA! there was "\r\n"a $RECOVERY lock for dead "\r\n"node %u (%s)!\n",\r\ndead_node, dlm->name);\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\ndlm_lock_put(lock);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\ncontinue;\r\n}\r\nif (res->owner == dead_node) {\r\nmlog(0, "found lockres owned by dead node while "\r\n"doing recovery for node %u. sending it.\n",\r\ndead_node);\r\nlist_move_tail(&res->recovering, list);\r\n} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nmlog(0, "found UNKNOWN owner while doing recovery "\r\n"for node %u. sending it.\n", dead_node);\r\nlist_move_tail(&res->recovering, list);\r\n}\r\n}\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\r\n{\r\nint total_locks = 0;\r\nstruct list_head *iter, *queue = &res->granted;\r\nint i;\r\nfor (i=0; i<3; i++) {\r\nlist_for_each(iter, queue)\r\ntotal_locks++;\r\nqueue++;\r\n}\r\nreturn total_locks;\r\n}\r\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\r\nstruct dlm_migratable_lockres *mres,\r\nu8 send_to,\r\nstruct dlm_lock_resource *res,\r\nint total_locks)\r\n{\r\nu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\r\nint mres_total_locks = be32_to_cpu(mres->total_locks);\r\nint sz, ret = 0, status = 0;\r\nu8 orig_flags = mres->flags,\r\norig_master = mres->master;\r\nBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\r\nif (!mres->num_locks)\r\nreturn 0;\r\nsz = sizeof(struct dlm_migratable_lockres) +\r\n(mres->num_locks * sizeof(struct dlm_migratable_lock));\r\norig_flags = mres->flags;\r\nBUG_ON(total_locks > mres_total_locks);\r\nif (total_locks == mres_total_locks)\r\nmres->flags |= DLM_MRES_ALL_DONE;\r\nmlog(0, "%s:%.*s: sending mig lockres (%s) to %u\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\norig_flags & DLM_MRES_MIGRATION ? "migration" : "recovery",\r\nsend_to);\r\nret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\r\nsz, send_to, &status);\r\nif (ret < 0) {\r\nmlog(ML_ERROR, "%s: res %.*s, Error %d send MIG_LOCKRES to "\r\n"node %u (%s)\n", dlm->name, mres->lockname_len,\r\nmres->lockname, ret, send_to,\r\n(orig_flags & DLM_MRES_MIGRATION ?\r\n"migration" : "recovery"));\r\n} else {\r\nret = status;\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nif (ret == -EFAULT) {\r\nmlog(ML_ERROR, "node %u told me to kill "\r\n"myself!\n", send_to);\r\nBUG();\r\n}\r\n}\r\n}\r\ndlm_init_migratable_lockres(mres, res->lockname.name,\r\nres->lockname.len, mres_total_locks,\r\nmig_cookie, orig_flags, orig_master);\r\nreturn ret;\r\n}\r\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\r\nconst char *lockname, int namelen,\r\nint total_locks, u64 cookie,\r\nu8 flags, u8 master)\r\n{\r\nclear_page(mres);\r\nmres->lockname_len = namelen;\r\nmemcpy(mres->lockname, lockname, namelen);\r\nmres->num_locks = 0;\r\nmres->total_locks = cpu_to_be32(total_locks);\r\nmres->mig_cookie = cpu_to_be64(cookie);\r\nmres->flags = flags;\r\nmres->master = master;\r\n}\r\nstatic void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\r\nstruct dlm_migratable_lockres *mres,\r\nint queue)\r\n{\r\nif (!lock->lksb)\r\nreturn;\r\nif (queue == DLM_BLOCKED_LIST)\r\nreturn;\r\nif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\r\nreturn;\r\nif (dlm_lvb_is_empty(mres->lvb)) {\r\nmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\r\nreturn;\r\n}\r\nif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\r\nreturn;\r\nmlog(ML_ERROR, "Mismatched lvb in lock cookie=%u:%llu, name=%.*s, "\r\n"node=%u\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\nlock->lockres->lockname.len, lock->lockres->lockname.name,\r\nlock->ml.node);\r\ndlm_print_one_lock_resource(lock->lockres);\r\nBUG();\r\n}\r\nstatic int dlm_add_lock_to_array(struct dlm_lock *lock,\r\nstruct dlm_migratable_lockres *mres, int queue)\r\n{\r\nstruct dlm_migratable_lock *ml;\r\nint lock_num = mres->num_locks;\r\nml = &(mres->ml[lock_num]);\r\nml->cookie = lock->ml.cookie;\r\nml->type = lock->ml.type;\r\nml->convert_type = lock->ml.convert_type;\r\nml->highest_blocked = lock->ml.highest_blocked;\r\nml->list = queue;\r\nif (lock->lksb) {\r\nml->flags = lock->lksb->flags;\r\ndlm_prepare_lvb_for_migration(lock, mres, queue);\r\n}\r\nml->node = lock->ml.node;\r\nmres->num_locks++;\r\nif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\r\nstruct dlm_migratable_lockres *mres)\r\n{\r\nstruct dlm_lock dummy;\r\nmemset(&dummy, 0, sizeof(dummy));\r\ndummy.ml.cookie = 0;\r\ndummy.ml.type = LKM_IVMODE;\r\ndummy.ml.convert_type = LKM_IVMODE;\r\ndummy.ml.highest_blocked = LKM_IVMODE;\r\ndummy.lksb = NULL;\r\ndummy.ml.node = dlm->node_num;\r\ndlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\r\n}\r\nstatic inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\r\nstruct dlm_migratable_lock *ml,\r\nu8 *nodenum)\r\n{\r\nif (unlikely(ml->cookie == 0 &&\r\nml->type == LKM_IVMODE &&\r\nml->convert_type == LKM_IVMODE &&\r\nml->highest_blocked == LKM_IVMODE &&\r\nml->list == DLM_BLOCKED_LIST)) {\r\n*nodenum = ml->node;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_migratable_lockres *mres,\r\nu8 send_to, u8 flags)\r\n{\r\nstruct list_head *queue;\r\nint total_locks, i;\r\nu64 mig_cookie = 0;\r\nstruct dlm_lock *lock;\r\nint ret = 0;\r\nBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\r\nmlog(0, "sending to %u\n", send_to);\r\ntotal_locks = dlm_num_locks_in_lockres(res);\r\nif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\r\nmlog(0, "argh. lockres has %d locks. this will "\r\n"require more than one network packet to "\r\n"migrate\n", total_locks);\r\nmig_cookie = dlm_get_next_mig_cookie();\r\n}\r\ndlm_init_migratable_lockres(mres, res->lockname.name,\r\nres->lockname.len, total_locks,\r\nmig_cookie, flags, res->owner);\r\ntotal_locks = 0;\r\nfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\r\nqueue = dlm_list_idx_to_ptr(res, i);\r\nlist_for_each_entry(lock, queue, list) {\r\ntotal_locks++;\r\nif (!dlm_add_lock_to_array(lock, mres, i))\r\ncontinue;\r\nret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\r\nres, total_locks);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\n}\r\nif (total_locks == 0) {\r\nmlog(0, "%s:%.*s: sending dummy lock to %u, %s\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\nsend_to, flags & DLM_MRES_RECOVERY ? "recovery" :\r\n"migration");\r\ndlm_add_dummy_lock(dlm, mres);\r\n}\r\nret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\r\nif (ret < 0)\r\ngoto error;\r\nreturn ret;\r\nerror:\r\nmlog(ML_ERROR, "%s: dlm_send_mig_lockres_msg returned %d\n",\r\ndlm->name, ret);\r\nif (!dlm_is_host_down(ret))\r\nBUG();\r\nmlog(0, "%s: node %u went down while sending %s "\r\n"lockres %.*s\n", dlm->name, send_to,\r\nflags & DLM_MRES_RECOVERY ? "recovery" : "migration",\r\nres->lockname.len, res->lockname.name);\r\nreturn ret;\r\n}\r\nint dlm_mig_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_migratable_lockres *mres =\r\n(struct dlm_migratable_lockres *)msg->buf;\r\nint ret = 0;\r\nu8 real_master;\r\nu8 extra_refs = 0;\r\nchar *buf = NULL;\r\nstruct dlm_work_item *item = NULL;\r\nstruct dlm_lock_resource *res = NULL;\r\nunsigned int hash;\r\nif (!dlm_grab(dlm))\r\nreturn -EINVAL;\r\nBUG_ON(!(mres->flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\r\nreal_master = mres->master;\r\nif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\r\n}\r\nmlog(0, "%s message received from node %u\n",\r\n(mres->flags & DLM_MRES_RECOVERY) ?\r\n"recovery" : "migration", mres->master);\r\nif (mres->flags & DLM_MRES_ALL_DONE)\r\nmlog(0, "all done flag. all lockres data received!\n");\r\nret = -ENOMEM;\r\nbuf = kmalloc(be16_to_cpu(msg->data_len), GFP_NOFS);\r\nitem = kzalloc(sizeof(*item), GFP_NOFS);\r\nif (!buf || !item)\r\ngoto leave;\r\nhash = dlm_lockid_hash(mres->lockname, mres->lockname_len);\r\nspin_lock(&dlm->spinlock);\r\nres = __dlm_lookup_lockres_full(dlm, mres->lockname, mres->lockname_len,\r\nhash);\r\nif (res) {\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_DROPPING_REF) {\r\nmlog(0, "%s: node is attempting to migrate "\r\n"lockres %.*s, but marked as dropping "\r\n" ref!\n", dlm->name,\r\nmres->lockname_len, mres->lockname);\r\nret = -EINVAL;\r\nspin_unlock(&res->spinlock);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_lockres_put(res);\r\ngoto leave;\r\n}\r\nif (mres->flags & DLM_MRES_RECOVERY) {\r\nres->state |= DLM_LOCK_RES_RECOVERING;\r\n} else {\r\nif (res->state & DLM_LOCK_RES_MIGRATING) {\r\nmlog(0, "lock %.*s is already migrating\n",\r\nmres->lockname_len,\r\nmres->lockname);\r\n} else if (res->state & DLM_LOCK_RES_RECOVERING) {\r\nmlog(ML_ERROR, "node is attempting to migrate "\r\n"lock %.*s, but marked as recovering!\n",\r\nmres->lockname_len, mres->lockname);\r\nret = -EFAULT;\r\nspin_unlock(&res->spinlock);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_lockres_put(res);\r\ngoto leave;\r\n}\r\nres->state |= DLM_LOCK_RES_MIGRATING;\r\n}\r\nspin_unlock(&res->spinlock);\r\nspin_unlock(&dlm->spinlock);\r\n} else {\r\nspin_unlock(&dlm->spinlock);\r\nres = dlm_new_lockres(dlm, mres->lockname, mres->lockname_len);\r\nif (!res)\r\ngoto leave;\r\ndlm_lockres_get(res);\r\nif (mres->flags & DLM_MRES_RECOVERY)\r\nres->state |= DLM_LOCK_RES_RECOVERING;\r\nelse\r\nres->state |= DLM_LOCK_RES_MIGRATING;\r\nspin_lock(&dlm->spinlock);\r\n__dlm_insert_lockres(dlm, res);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_lockres_get(res);\r\nextra_refs++;\r\nspin_lock(&res->spinlock);\r\nres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\n}\r\nret = 0;\r\nspin_lock(&res->spinlock);\r\ndlm_lockres_grab_inflight_ref(dlm, res);\r\nif (mres->master == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\r\nmlog(0, "recovery has passed me a lockres with an "\r\n"unknown owner.. will need to requery: "\r\n"%.*s\n", mres->lockname_len, mres->lockname);\r\n} else {\r\ndlm_change_lockres_owner(dlm, res, dlm->node_num);\r\n}\r\nspin_unlock(&res->spinlock);\r\ndlm_grab(dlm);\r\nmemcpy(buf, msg->buf, be16_to_cpu(msg->data_len));\r\ndlm_init_work_item(dlm, item, dlm_mig_lockres_worker, buf);\r\nitem->u.ml.lockres = res;\r\nitem->u.ml.real_master = real_master;\r\nitem->u.ml.extra_ref = extra_refs;\r\nspin_lock(&dlm->work_lock);\r\nlist_add_tail(&item->list, &dlm->work_list);\r\nspin_unlock(&dlm->work_lock);\r\nqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\r\nleave:\r\nif (extra_refs)\r\ndlm_lockres_put(res);\r\ndlm_put(dlm);\r\nif (ret < 0) {\r\nkfree(buf);\r\nkfree(item);\r\nmlog_errno(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data)\r\n{\r\nstruct dlm_ctxt *dlm;\r\nstruct dlm_migratable_lockres *mres;\r\nint ret = 0;\r\nstruct dlm_lock_resource *res;\r\nu8 real_master;\r\nu8 extra_ref;\r\ndlm = item->dlm;\r\nmres = (struct dlm_migratable_lockres *)data;\r\nres = item->u.ml.lockres;\r\nreal_master = item->u.ml.real_master;\r\nextra_ref = item->u.ml.extra_ref;\r\nif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nagain:\r\nret = dlm_lockres_master_requery(dlm, res, &real_master);\r\nif (ret < 0) {\r\nmlog(0, "dlm_lockres_master_requery ret=%d\n",\r\nret);\r\ngoto again;\r\n}\r\nif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nmlog(0, "lockres %.*s not claimed. "\r\n"this node will take it.\n",\r\nres->lockname.len, res->lockname.name);\r\n} else {\r\nspin_lock(&res->spinlock);\r\ndlm_lockres_drop_inflight_ref(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nmlog(0, "master needs to respond to sender "\r\n"that node %u still owns %.*s\n",\r\nreal_master, res->lockname.len,\r\nres->lockname.name);\r\ngoto leave;\r\n}\r\n}\r\nret = dlm_process_recovery_data(dlm, res, mres);\r\nif (ret < 0)\r\nmlog(0, "dlm_process_recovery_data returned %d\n", ret);\r\nelse\r\nmlog(0, "dlm_process_recovery_data succeeded\n");\r\nif ((mres->flags & (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) ==\r\n(DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) {\r\nret = dlm_finish_migration(dlm, res, mres->master);\r\nif (ret < 0)\r\nmlog_errno(ret);\r\n}\r\nleave:\r\nif (res) {\r\nif (extra_ref)\r\ndlm_lockres_put(res);\r\ndlm_lockres_put(res);\r\n}\r\nkfree(data);\r\n}\r\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nu8 *real_master)\r\n{\r\nstruct dlm_node_iter iter;\r\nint nodenum;\r\nint ret = 0;\r\n*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\r\nspin_lock(&dlm->spinlock);\r\ndlm_node_iter_init(dlm->domain_map, &iter);\r\nspin_unlock(&dlm->spinlock);\r\nwhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\r\nif (nodenum == dlm->node_num)\r\ncontinue;\r\nret = dlm_do_master_requery(dlm, res, nodenum, real_master);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nif (!dlm_is_host_down(ret))\r\nBUG();\r\n}\r\nif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nmlog(0, "lock master is %u\n", *real_master);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nu8 nodenum, u8 *real_master)\r\n{\r\nint ret = -EINVAL;\r\nstruct dlm_master_requery req;\r\nint status = DLM_LOCK_RES_OWNER_UNKNOWN;\r\nmemset(&req, 0, sizeof(req));\r\nreq.node_idx = dlm->node_num;\r\nreq.namelen = res->lockname.len;\r\nmemcpy(req.name, res->lockname.name, res->lockname.len);\r\nresend:\r\nret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\r\n&req, sizeof(req), nodenum, &status);\r\nif (ret < 0)\r\nmlog(ML_ERROR, "Error %d when sending message %u (key "\r\n"0x%x) to node %u\n", ret, DLM_MASTER_REQUERY_MSG,\r\ndlm->key, nodenum);\r\nelse if (status == -ENOMEM) {\r\nmlog_errno(status);\r\nmsleep(50);\r\ngoto resend;\r\n} else {\r\nBUG_ON(status < 0);\r\nBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\r\n*real_master = (u8) (status & 0xff);\r\nmlog(0, "node %u responded to master requery with %u\n",\r\nnodenum, *real_master);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_master_requery *req = (struct dlm_master_requery *)msg->buf;\r\nstruct dlm_lock_resource *res = NULL;\r\nunsigned int hash;\r\nint master = DLM_LOCK_RES_OWNER_UNKNOWN;\r\nu32 flags = DLM_ASSERT_MASTER_REQUERY;\r\nint dispatched = 0;\r\nif (!dlm_grab(dlm)) {\r\nreturn master;\r\n}\r\nhash = dlm_lockid_hash(req->name, req->namelen);\r\nspin_lock(&dlm->spinlock);\r\nres = __dlm_lookup_lockres(dlm, req->name, req->namelen, hash);\r\nif (res) {\r\nspin_lock(&res->spinlock);\r\nmaster = res->owner;\r\nif (master == dlm->node_num) {\r\nint ret = dlm_dispatch_assert_master(dlm, res,\r\n0, 0, flags);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nspin_unlock(&res->spinlock);\r\ndlm_lockres_put(res);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\nreturn ret;\r\n} else {\r\ndispatched = 1;\r\n__dlm_lockres_grab_inflight_worker(dlm, res);\r\nspin_unlock(&res->spinlock);\r\n}\r\n} else {\r\nspin_unlock(&res->spinlock);\r\ndlm_lockres_put(res);\r\n}\r\n}\r\nspin_unlock(&dlm->spinlock);\r\nif (!dispatched)\r\ndlm_put(dlm);\r\nreturn master;\r\n}\r\nstatic inline struct list_head *\r\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\r\n{\r\nstruct list_head *ret;\r\nBUG_ON(list_num < 0);\r\nBUG_ON(list_num > 2);\r\nret = &(res->granted);\r\nret += list_num;\r\nreturn ret;\r\n}\r\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res,\r\nstruct dlm_migratable_lockres *mres)\r\n{\r\nstruct dlm_migratable_lock *ml;\r\nstruct list_head *queue, *iter;\r\nstruct list_head *tmpq = NULL;\r\nstruct dlm_lock *newlock = NULL;\r\nstruct dlm_lockstatus *lksb = NULL;\r\nint ret = 0;\r\nint i, j, bad;\r\nstruct dlm_lock *lock;\r\nu8 from = O2NM_MAX_NODES;\r\nunsigned int added = 0;\r\n__be64 c;\r\nmlog(0, "running %d locks for this lockres\n", mres->num_locks);\r\nfor (i=0; i<mres->num_locks; i++) {\r\nml = &(mres->ml[i]);\r\nif (dlm_is_dummy_lock(dlm, ml, &from)) {\r\nBUG_ON(mres->num_locks != 1);\r\nmlog(0, "%s:%.*s: dummy lock for %u\n",\r\ndlm->name, mres->lockname_len, mres->lockname,\r\nfrom);\r\nspin_lock(&res->spinlock);\r\ndlm_lockres_set_refmap_bit(dlm, res, from);\r\nspin_unlock(&res->spinlock);\r\nadded++;\r\nbreak;\r\n}\r\nBUG_ON(ml->highest_blocked != LKM_IVMODE);\r\nnewlock = NULL;\r\nlksb = NULL;\r\nqueue = dlm_list_num_to_pointer(res, ml->list);\r\ntmpq = NULL;\r\nif (ml->node == dlm->node_num) {\r\nBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\r\nlock = NULL;\r\nspin_lock(&res->spinlock);\r\nfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\r\ntmpq = dlm_list_idx_to_ptr(res, j);\r\nlist_for_each(iter, tmpq) {\r\nlock = list_entry(iter,\r\nstruct dlm_lock, list);\r\nif (lock->ml.cookie == ml->cookie)\r\nbreak;\r\nlock = NULL;\r\n}\r\nif (lock)\r\nbreak;\r\n}\r\nif (!lock) {\r\nc = ml->cookie;\r\nmlog(ML_ERROR, "Could not find local lock "\r\n"with cookie %u:%llu, node %u, "\r\n"list %u, flags 0x%x, type %d, "\r\n"conv %d, highest blocked %d\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(c)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(c)),\r\nml->node, ml->list, ml->flags, ml->type,\r\nml->convert_type, ml->highest_blocked);\r\n__dlm_print_one_lock_resource(res);\r\nBUG();\r\n}\r\nif (lock->ml.node != ml->node) {\r\nc = lock->ml.cookie;\r\nmlog(ML_ERROR, "Mismatched node# in lock "\r\n"cookie %u:%llu, name %.*s, node %u\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(c)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(c)),\r\nres->lockname.len, res->lockname.name,\r\nlock->ml.node);\r\nc = ml->cookie;\r\nmlog(ML_ERROR, "Migrate lock cookie %u:%llu, "\r\n"node %u, list %u, flags 0x%x, type %d, "\r\n"conv %d, highest blocked %d\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(c)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(c)),\r\nml->node, ml->list, ml->flags, ml->type,\r\nml->convert_type, ml->highest_blocked);\r\n__dlm_print_one_lock_resource(res);\r\nBUG();\r\n}\r\nif (tmpq != queue) {\r\nc = ml->cookie;\r\nmlog(0, "Lock cookie %u:%llu was on list %u "\r\n"instead of list %u for %.*s\n",\r\ndlm_get_lock_cookie_node(be64_to_cpu(c)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(c)),\r\nj, ml->list, res->lockname.len,\r\nres->lockname.name);\r\n__dlm_print_one_lock_resource(res);\r\nspin_unlock(&res->spinlock);\r\ncontinue;\r\n}\r\nlist_move_tail(&lock->list, queue);\r\nspin_unlock(&res->spinlock);\r\nadded++;\r\nmlog(0, "just reordered a local lock!\n");\r\ncontinue;\r\n}\r\nnewlock = dlm_new_lock(ml->type, ml->node,\r\nbe64_to_cpu(ml->cookie), NULL);\r\nif (!newlock) {\r\nret = -ENOMEM;\r\ngoto leave;\r\n}\r\nlksb = newlock->lksb;\r\ndlm_lock_attach_lockres(newlock, res);\r\nif (ml->convert_type != LKM_IVMODE) {\r\nBUG_ON(queue != &res->converting);\r\nnewlock->ml.convert_type = ml->convert_type;\r\n}\r\nlksb->flags |= (ml->flags &\r\n(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\r\nif (ml->type == LKM_NLMODE)\r\ngoto skip_lvb;\r\nif (ml->list == DLM_BLOCKED_LIST)\r\ngoto skip_lvb;\r\nif (!dlm_lvb_is_empty(mres->lvb)) {\r\nif (lksb->flags & DLM_LKSB_PUT_LVB) {\r\nmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\r\nmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\r\n} else {\r\nBUG_ON(ml->type != LKM_EXMODE &&\r\nml->type != LKM_PRMODE);\r\nif (!dlm_lvb_is_empty(res->lvb) &&\r\n(ml->type == LKM_EXMODE ||\r\nmemcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\r\nint i;\r\nmlog(ML_ERROR, "%s:%.*s: received bad "\r\n"lvb! type=%d\n", dlm->name,\r\nres->lockname.len,\r\nres->lockname.name, ml->type);\r\nprintk("lockres lvb=[");\r\nfor (i=0; i<DLM_LVB_LEN; i++)\r\nprintk("%02x", res->lvb[i]);\r\nprintk("]\nmigrated lvb=[");\r\nfor (i=0; i<DLM_LVB_LEN; i++)\r\nprintk("%02x", mres->lvb[i]);\r\nprintk("]\n");\r\ndlm_print_one_lock_resource(res);\r\nBUG();\r\n}\r\nmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\r\n}\r\n}\r\nskip_lvb:\r\nbad = 0;\r\nspin_lock(&res->spinlock);\r\nlist_for_each_entry(lock, queue, list) {\r\nif (lock->ml.cookie == ml->cookie) {\r\nc = lock->ml.cookie;\r\nmlog(ML_ERROR, "%s:%.*s: %u:%llu: lock already "\r\n"exists on this lockres!\n", dlm->name,\r\nres->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(c)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(c)));\r\nmlog(ML_NOTICE, "sent lock: type=%d, conv=%d, "\r\n"node=%u, cookie=%u:%llu, queue=%d\n",\r\nml->type, ml->convert_type, ml->node,\r\ndlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\r\nml->list);\r\n__dlm_print_one_lock_resource(res);\r\nbad = 1;\r\nbreak;\r\n}\r\n}\r\nif (!bad) {\r\ndlm_lock_get(newlock);\r\nif (mres->flags & DLM_MRES_RECOVERY &&\r\nml->list == DLM_CONVERTING_LIST &&\r\nnewlock->ml.type >\r\nnewlock->ml.convert_type) {\r\nlist_add(&newlock->list, queue);\r\n} else\r\nlist_add_tail(&newlock->list, queue);\r\nmlog(0, "%s:%.*s: added lock for node %u, "\r\n"setting refmap bit\n", dlm->name,\r\nres->lockname.len, res->lockname.name, ml->node);\r\ndlm_lockres_set_refmap_bit(dlm, res, ml->node);\r\nadded++;\r\n}\r\nspin_unlock(&res->spinlock);\r\n}\r\nmlog(0, "done running all the locks\n");\r\nleave:\r\nspin_lock(&res->spinlock);\r\ndlm_lockres_drop_inflight_ref(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nif (ret < 0)\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res)\r\n{\r\nint i;\r\nstruct list_head *queue;\r\nstruct dlm_lock *lock, *next;\r\nassert_spin_locked(&dlm->spinlock);\r\nassert_spin_locked(&res->spinlock);\r\nres->state |= DLM_LOCK_RES_RECOVERING;\r\nif (!list_empty(&res->recovering)) {\r\nmlog(0,\r\n"Recovering res %s:%.*s, is already on recovery list!\n",\r\ndlm->name, res->lockname.len, res->lockname.name);\r\nlist_del_init(&res->recovering);\r\ndlm_lockres_put(res);\r\n}\r\ndlm_lockres_get(res);\r\nlist_add_tail(&res->recovering, &dlm->reco.resources);\r\nfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\r\nqueue = dlm_list_idx_to_ptr(res, i);\r\nlist_for_each_entry_safe(lock, next, queue, list) {\r\ndlm_lock_get(lock);\r\nif (lock->convert_pending) {\r\nmlog(0, "node died with convert pending "\r\n"on %.*s. move back to granted list.\n",\r\nres->lockname.len, res->lockname.name);\r\ndlm_revert_pending_convert(res, lock);\r\nlock->convert_pending = 0;\r\n} else if (lock->lock_pending) {\r\nBUG_ON(i != DLM_BLOCKED_LIST);\r\nmlog(0, "node died with lock pending "\r\n"on %.*s. remove from blocked list and skip.\n",\r\nres->lockname.len, res->lockname.name);\r\ndlm_revert_pending_lock(res, lock);\r\nlock->lock_pending = 0;\r\n} else if (lock->unlock_pending) {\r\nBUG_ON(i != DLM_GRANTED_LIST);\r\nmlog(0, "node died with unlock pending "\r\n"on %.*s. remove from blocked list and skip.\n",\r\nres->lockname.len, res->lockname.name);\r\ndlm_commit_pending_unlock(res, lock);\r\nlock->unlock_pending = 0;\r\n} else if (lock->cancel_pending) {\r\nBUG_ON(i != DLM_CONVERTING_LIST);\r\nmlog(0, "node died with cancel pending "\r\n"on %.*s. move back to granted list.\n",\r\nres->lockname.len, res->lockname.name);\r\ndlm_commit_pending_cancel(res, lock);\r\nlock->cancel_pending = 0;\r\n}\r\ndlm_lock_put(lock);\r\n}\r\n}\r\n}\r\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\r\nu8 dead_node, u8 new_master)\r\n{\r\nint i;\r\nstruct hlist_head *bucket;\r\nstruct dlm_lock_resource *res, *next;\r\nassert_spin_locked(&dlm->spinlock);\r\nlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\r\nif (res->owner == dead_node) {\r\nmlog(0, "%s: res %.*s, Changing owner from %u to %u\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\nres->owner, new_master);\r\nlist_del_init(&res->recovering);\r\nspin_lock(&res->spinlock);\r\ndlm_change_lockres_owner(dlm, res, new_master);\r\nres->state &= ~DLM_LOCK_RES_RECOVERING;\r\nif (__dlm_lockres_has_locks(res))\r\n__dlm_dirty_lockres(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\ndlm_lockres_put(res);\r\n}\r\n}\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\r\nbucket = dlm_lockres_hash(dlm, i);\r\nhlist_for_each_entry(res, bucket, hash_node) {\r\nif (res->state & DLM_LOCK_RES_RECOVERY_WAITING) {\r\nspin_lock(&res->spinlock);\r\nres->state &= ~DLM_LOCK_RES_RECOVERY_WAITING;\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\n}\r\nif (!(res->state & DLM_LOCK_RES_RECOVERING))\r\ncontinue;\r\nif (res->owner != dead_node &&\r\nres->owner != dlm->node_num)\r\ncontinue;\r\nif (!list_empty(&res->recovering)) {\r\nlist_del_init(&res->recovering);\r\ndlm_lockres_put(res);\r\n}\r\nmlog(0, "%s: res %.*s, Changing owner from %u to %u\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\nres->owner, new_master);\r\nspin_lock(&res->spinlock);\r\ndlm_change_lockres_owner(dlm, res, new_master);\r\nres->state &= ~DLM_LOCK_RES_RECOVERING;\r\nif (__dlm_lockres_has_locks(res))\r\n__dlm_dirty_lockres(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\n}\r\n}\r\n}\r\nstatic inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\r\n{\r\nif (local) {\r\nif (lock->ml.type != LKM_EXMODE &&\r\nlock->ml.type != LKM_PRMODE)\r\nreturn 1;\r\n} else if (lock->ml.type == LKM_EXMODE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res, u8 dead_node)\r\n{\r\nstruct list_head *queue;\r\nstruct dlm_lock *lock;\r\nint blank_lvb = 0, local = 0;\r\nint i;\r\nu8 search_node;\r\nassert_spin_locked(&dlm->spinlock);\r\nassert_spin_locked(&res->spinlock);\r\nif (res->owner == dlm->node_num)\r\nsearch_node = dead_node;\r\nelse {\r\nsearch_node = dlm->node_num;\r\nlocal = 1;\r\n}\r\nfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\r\nqueue = dlm_list_idx_to_ptr(res, i);\r\nlist_for_each_entry(lock, queue, list) {\r\nif (lock->ml.node == search_node) {\r\nif (dlm_lvb_needs_invalidation(lock, local)) {\r\nblank_lvb = 1;\r\nmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\r\n}\r\n}\r\n}\r\n}\r\nif (blank_lvb) {\r\nmlog(0, "clearing %.*s lvb, dead node %u had EX\n",\r\nres->lockname.len, res->lockname.name, dead_node);\r\nmemset(res->lvb, 0, DLM_LVB_LEN);\r\n}\r\n}\r\nstatic void dlm_free_dead_locks(struct dlm_ctxt *dlm,\r\nstruct dlm_lock_resource *res, u8 dead_node)\r\n{\r\nstruct dlm_lock *lock, *next;\r\nunsigned int freed = 0;\r\nassert_spin_locked(&dlm->spinlock);\r\nassert_spin_locked(&res->spinlock);\r\nlist_for_each_entry_safe(lock, next, &res->granted, list) {\r\nif (lock->ml.node == dead_node) {\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\ndlm_lock_put(lock);\r\nfreed++;\r\n}\r\n}\r\nlist_for_each_entry_safe(lock, next, &res->converting, list) {\r\nif (lock->ml.node == dead_node) {\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\ndlm_lock_put(lock);\r\nfreed++;\r\n}\r\n}\r\nlist_for_each_entry_safe(lock, next, &res->blocked, list) {\r\nif (lock->ml.node == dead_node) {\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\ndlm_lock_put(lock);\r\nfreed++;\r\n}\r\n}\r\nif (freed) {\r\nmlog(0, "%s:%.*s: freed %u locks for dead node %u, "\r\n"dropping ref from lockres\n", dlm->name,\r\nres->lockname.len, res->lockname.name, freed, dead_node);\r\nif(!test_bit(dead_node, res->refmap)) {\r\nmlog(ML_ERROR, "%s:%.*s: freed %u locks for dead node %u, "\r\n"but ref was not set\n", dlm->name,\r\nres->lockname.len, res->lockname.name, freed, dead_node);\r\n__dlm_print_one_lock_resource(res);\r\n}\r\nres->state |= DLM_LOCK_RES_RECOVERY_WAITING;\r\ndlm_lockres_clear_refmap_bit(dlm, res, dead_node);\r\n} else if (test_bit(dead_node, res->refmap)) {\r\nmlog(0, "%s:%.*s: dead node %u had a ref, but had "\r\n"no locks and had not purged before dying\n", dlm->name,\r\nres->lockname.len, res->lockname.name, dead_node);\r\ndlm_lockres_clear_refmap_bit(dlm, res, dead_node);\r\n}\r\n__dlm_dirty_lockres(dlm, res);\r\n}\r\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\r\n{\r\nstruct dlm_lock_resource *res;\r\nint i;\r\nstruct hlist_head *bucket;\r\nstruct hlist_node *tmp;\r\nstruct dlm_lock *lock;\r\ndlm_clean_master_list(dlm, dead_node);\r\nfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\r\nbucket = dlm_lockres_hash(dlm, i);\r\nhlist_for_each_entry_safe(res, tmp, bucket, hash_node) {\r\nif (dlm_is_recovery_lock(res->lockname.name,\r\nres->lockname.len)) {\r\nspin_lock(&res->spinlock);\r\nlist_for_each_entry(lock, &res->granted, list) {\r\nif (lock->ml.node == dead_node) {\r\nmlog(0, "AHA! there was "\r\n"a $RECOVERY lock for dead "\r\n"node %u (%s)!\n",\r\ndead_node, dlm->name);\r\nlist_del_init(&lock->list);\r\ndlm_lock_put(lock);\r\ndlm_lock_put(lock);\r\nbreak;\r\n}\r\n}\r\nif ((res->owner == dead_node) &&\r\n(res->state & DLM_LOCK_RES_DROPPING_REF)) {\r\ndlm_lockres_get(res);\r\n__dlm_do_purge_lockres(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\ndlm_lockres_put(res);\r\ncontinue;\r\n} else if (res->owner == dlm->node_num)\r\ndlm_lockres_clear_refmap_bit(dlm, res, dead_node);\r\nspin_unlock(&res->spinlock);\r\ncontinue;\r\n}\r\nspin_lock(&res->spinlock);\r\ndlm_revalidate_lvb(dlm, res, dead_node);\r\nif (res->owner == dead_node) {\r\nif (res->state & DLM_LOCK_RES_DROPPING_REF) {\r\nmlog(0, "%s:%.*s: owned by "\r\n"dead node %u, this node was "\r\n"dropping its ref when master died. "\r\n"continue, purging the lockres.\n",\r\ndlm->name, res->lockname.len,\r\nres->lockname.name, dead_node);\r\ndlm_lockres_get(res);\r\n__dlm_do_purge_lockres(dlm, res);\r\nspin_unlock(&res->spinlock);\r\nwake_up(&res->wq);\r\ndlm_lockres_put(res);\r\ncontinue;\r\n}\r\n} else if (res->owner == dlm->node_num) {\r\ndlm_free_dead_locks(dlm, res, dead_node);\r\n__dlm_lockres_calc_usage(dlm, res);\r\n} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\r\nif (test_bit(dead_node, res->refmap)) {\r\nmlog(0, "%s:%.*s: dead node %u had a ref, but had "\r\n"no locks and had not purged before dying\n",\r\ndlm->name, res->lockname.len,\r\nres->lockname.name, dead_node);\r\ndlm_lockres_clear_refmap_bit(dlm, res, dead_node);\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\n}\r\n}\r\n}\r\nstatic void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\r\n{\r\nassert_spin_locked(&dlm->spinlock);\r\nif (dlm->reco.new_master == idx) {\r\nmlog(0, "%s: recovery master %d just died\n",\r\ndlm->name, idx);\r\nif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\r\nmlog(0, "%s: dead master %d had reached "\r\n"finalize1 state, clearing\n", dlm->name, idx);\r\ndlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\r\n__dlm_reset_recovery(dlm);\r\n}\r\n}\r\nif (dlm->joining_node == idx) {\r\nmlog(0, "Clearing join state for node %u\n", idx);\r\n__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\r\n}\r\nif (!test_bit(idx, dlm->live_nodes_map)) {\r\nmlog(0, "for domain %s, node %d is already dead. "\r\n"another node likely did recovery already.\n",\r\ndlm->name, idx);\r\nreturn;\r\n}\r\nif (!test_bit(idx, dlm->domain_map)) {\r\nmlog(0, "node %u already removed from domain!\n", idx);\r\nreturn;\r\n}\r\nclear_bit(idx, dlm->live_nodes_map);\r\nif (!test_bit(idx, dlm->recovery_map))\r\ndlm_do_local_recovery_cleanup(dlm, idx);\r\ndlm_hb_event_notify_attached(dlm, idx, 0);\r\nmlog(0, "node %u being removed from domain map!\n", idx);\r\nclear_bit(idx, dlm->domain_map);\r\nclear_bit(idx, dlm->exit_domain_map);\r\nwake_up(&dlm->migration_wq);\r\nset_bit(idx, dlm->recovery_map);\r\n}\r\nvoid dlm_hb_node_down_cb(struct o2nm_node *node, int idx, void *data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nif (!dlm_grab(dlm))\r\nreturn;\r\nif (test_bit(idx, dlm->domain_map))\r\ndlm_fire_domain_eviction_callbacks(dlm, idx);\r\nspin_lock(&dlm->spinlock);\r\n__dlm_hb_node_down(dlm, idx);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\n}\r\nvoid dlm_hb_node_up_cb(struct o2nm_node *node, int idx, void *data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nif (!dlm_grab(dlm))\r\nreturn;\r\nspin_lock(&dlm->spinlock);\r\nset_bit(idx, dlm->live_nodes_map);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\n}\r\nstatic void dlm_reco_ast(void *astdata)\r\n{\r\nstruct dlm_ctxt *dlm = astdata;\r\nmlog(0, "ast for recovery lock fired!, this=%u, dlm=%s\n",\r\ndlm->node_num, dlm->name);\r\n}\r\nstatic void dlm_reco_bast(void *astdata, int blocked_type)\r\n{\r\nstruct dlm_ctxt *dlm = astdata;\r\nmlog(0, "bast for recovery lock fired!, this=%u, dlm=%s\n",\r\ndlm->node_num, dlm->name);\r\n}\r\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st)\r\n{\r\nmlog(0, "unlockast for recovery lock fired!\n");\r\n}\r\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\r\n{\r\nenum dlm_status ret;\r\nstruct dlm_lockstatus lksb;\r\nint status = -EINVAL;\r\nmlog(0, "starting recovery of %s at %lu, dead=%u, this=%u\n",\r\ndlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\r\nagain:\r\nmemset(&lksb, 0, sizeof(lksb));\r\nret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\r\nDLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\r\ndlm_reco_ast, dlm, dlm_reco_bast);\r\nmlog(0, "%s: dlmlock($RECOVERY) returned %d, lksb=%d\n",\r\ndlm->name, ret, lksb.status);\r\nif (ret == DLM_NORMAL) {\r\nmlog(0, "dlm=%s dlmlock says I got it (this=%u)\n",\r\ndlm->name, dlm->node_num);\r\nif (dlm_reco_master_ready(dlm)) {\r\nmlog(0, "%s: got reco EX lock, but %u will "\r\n"do the recovery\n", dlm->name,\r\ndlm->reco.new_master);\r\nstatus = -EEXIST;\r\n} else {\r\nstatus = 0;\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\r\nstatus = -EINVAL;\r\nmlog(0, "%s: got reco EX lock, but "\r\n"node got recovered already\n", dlm->name);\r\nif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\r\nmlog(ML_ERROR, "%s: new master is %u "\r\n"but no dead node!\n",\r\ndlm->name, dlm->reco.new_master);\r\nBUG();\r\n}\r\n}\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nif (!status) {\r\nmlog(0, "%s: dead=%u, this=%u, sending "\r\n"begin_reco now\n", dlm->name,\r\ndlm->reco.dead_node, dlm->node_num);\r\nstatus = dlm_send_begin_reco_message(dlm,\r\ndlm->reco.dead_node);\r\nBUG_ON(status);\r\nspin_lock(&dlm->spinlock);\r\ndlm_set_reco_master(dlm, dlm->node_num);\r\nspin_unlock(&dlm->spinlock);\r\n}\r\nret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\r\nif (ret == DLM_DENIED) {\r\nmlog(0, "got DLM_DENIED, trying LKM_CANCEL\n");\r\nret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\r\n}\r\nif (ret != DLM_NORMAL) {\r\nmlog(ML_ERROR, "dlmunlock returned %d\n", ret);\r\n}\r\n} else if (ret == DLM_NOTQUEUED) {\r\nmlog(0, "dlm=%s dlmlock says another node got it (this=%u)\n",\r\ndlm->name, dlm->node_num);\r\nwait_event_timeout(dlm->dlm_reco_thread_wq,\r\ndlm_reco_master_ready(dlm),\r\nmsecs_to_jiffies(1000));\r\nif (!dlm_reco_master_ready(dlm)) {\r\nmlog(0, "%s: reco master taking awhile\n",\r\ndlm->name);\r\ngoto again;\r\n}\r\nmlog(0, "%s: reco master %u is ready to recover %u\n",\r\ndlm->name, dlm->reco.new_master, dlm->reco.dead_node);\r\nstatus = -EEXIST;\r\n} else if (ret == DLM_RECOVERING) {\r\nmlog(0, "dlm=%s dlmlock says master node died (this=%u)\n",\r\ndlm->name, dlm->node_num);\r\ngoto again;\r\n} else {\r\nstruct dlm_lock_resource *res;\r\nmlog(ML_ERROR, "%s: got %s from dlmlock($RECOVERY), "\r\n"lksb.status=%s\n", dlm->name, dlm_errname(ret),\r\ndlm_errname(lksb.status));\r\nres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\r\nDLM_RECOVERY_LOCK_NAME_LEN);\r\nif (res) {\r\ndlm_print_one_lock_resource(res);\r\ndlm_lockres_put(res);\r\n} else {\r\nmlog(ML_ERROR, "recovery lock not found\n");\r\n}\r\nBUG();\r\n}\r\nreturn status;\r\n}\r\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\r\n{\r\nstruct dlm_begin_reco br;\r\nint ret = 0;\r\nstruct dlm_node_iter iter;\r\nint nodenum;\r\nint status;\r\nmlog(0, "%s: dead node is %u\n", dlm->name, dead_node);\r\nspin_lock(&dlm->spinlock);\r\ndlm_node_iter_init(dlm->domain_map, &iter);\r\nspin_unlock(&dlm->spinlock);\r\nclear_bit(dead_node, iter.node_map);\r\nmemset(&br, 0, sizeof(br));\r\nbr.node_idx = dlm->node_num;\r\nbr.dead_node = dead_node;\r\nwhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\r\nret = 0;\r\nif (nodenum == dead_node) {\r\nmlog(0, "not sending begin reco to dead node "\r\n"%u\n", dead_node);\r\ncontinue;\r\n}\r\nif (nodenum == dlm->node_num) {\r\nmlog(0, "not sending begin reco to self\n");\r\ncontinue;\r\n}\r\nretry:\r\nret = -EINVAL;\r\nmlog(0, "attempting to send begin reco msg to %d\n",\r\nnodenum);\r\nret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\r\n&br, sizeof(br), nodenum, &status);\r\nif (ret >= 0)\r\nret = status;\r\nif (dlm_is_host_down(ret)) {\r\nmlog(ML_NOTICE, "%s: node %u was down when sending "\r\n"begin reco msg (%d)\n", dlm->name, nodenum, ret);\r\nret = 0;\r\n}\r\nif (ret == -EAGAIN || ret == EAGAIN) {\r\nmlog(0, "%s: trying to start recovery of node "\r\n"%u, but node %u is waiting for last recovery "\r\n"to complete, backoff for a bit\n", dlm->name,\r\ndead_node, nodenum);\r\nmsleep(100);\r\ngoto retry;\r\n}\r\nif (ret < 0) {\r\nstruct dlm_lock_resource *res;\r\nmlog_errno(ret);\r\nmlog(ML_ERROR, "begin reco of dlm %s to node %u "\r\n"returned %d\n", dlm->name, nodenum, ret);\r\nres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\r\nDLM_RECOVERY_LOCK_NAME_LEN);\r\nif (res) {\r\ndlm_print_one_lock_resource(res);\r\ndlm_lockres_put(res);\r\n} else {\r\nmlog(ML_ERROR, "recovery lock not found\n");\r\n}\r\nmsleep(100);\r\ngoto retry;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint dlm_begin_reco_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_begin_reco *br = (struct dlm_begin_reco *)msg->buf;\r\nif (!dlm_grab(dlm))\r\nreturn 0;\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\r\nmlog(0, "%s: node %u wants to recover node %u (%u:%u) "\r\n"but this node is in finalize state, waiting on finalize2\n",\r\ndlm->name, br->node_idx, br->dead_node,\r\ndlm->reco.dead_node, dlm->reco.new_master);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_put(dlm);\r\nreturn -EAGAIN;\r\n}\r\nspin_unlock(&dlm->spinlock);\r\nmlog(0, "%s: node %u wants to recover node %u (%u:%u)\n",\r\ndlm->name, br->node_idx, br->dead_node,\r\ndlm->reco.dead_node, dlm->reco.new_master);\r\ndlm_fire_domain_eviction_callbacks(dlm, br->dead_node);\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\r\nif (test_bit(dlm->reco.new_master, dlm->recovery_map)) {\r\nmlog(0, "%s: new_master %u died, changing "\r\n"to %u\n", dlm->name, dlm->reco.new_master,\r\nbr->node_idx);\r\n} else {\r\nmlog(0, "%s: new_master %u NOT DEAD, changing "\r\n"to %u\n", dlm->name, dlm->reco.new_master,\r\nbr->node_idx);\r\n}\r\n}\r\nif (dlm->reco.dead_node != O2NM_INVALID_NODE_NUM) {\r\nmlog(ML_NOTICE, "%s: dead_node previously set to %u, "\r\n"node %u changing it to %u\n", dlm->name,\r\ndlm->reco.dead_node, br->node_idx, br->dead_node);\r\n}\r\ndlm_set_reco_master(dlm, br->node_idx);\r\ndlm_set_reco_dead_node(dlm, br->dead_node);\r\nif (!test_bit(br->dead_node, dlm->recovery_map)) {\r\nmlog(0, "recovery master %u sees %u as dead, but this "\r\n"node has not yet. marking %u as dead\n",\r\nbr->node_idx, br->dead_node, br->dead_node);\r\nif (!test_bit(br->dead_node, dlm->domain_map) ||\r\n!test_bit(br->dead_node, dlm->live_nodes_map))\r\nmlog(0, "%u not in domain/live_nodes map "\r\n"so setting it in reco map manually\n",\r\nbr->dead_node);\r\nset_bit(br->dead_node, dlm->domain_map);\r\nset_bit(br->dead_node, dlm->live_nodes_map);\r\n__dlm_hb_node_down(dlm, br->dead_node);\r\n}\r\nspin_unlock(&dlm->spinlock);\r\ndlm_kick_recovery_thread(dlm);\r\nmlog(0, "%s: recovery started by node %u, for %u (%u:%u)\n",\r\ndlm->name, br->node_idx, br->dead_node,\r\ndlm->reco.dead_node, dlm->reco.new_master);\r\ndlm_put(dlm);\r\nreturn 0;\r\n}\r\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\r\n{\r\nint ret = 0;\r\nstruct dlm_finalize_reco fr;\r\nstruct dlm_node_iter iter;\r\nint nodenum;\r\nint status;\r\nint stage = 1;\r\nmlog(0, "finishing recovery for node %s:%u, "\r\n"stage %d\n", dlm->name, dlm->reco.dead_node, stage);\r\nspin_lock(&dlm->spinlock);\r\ndlm_node_iter_init(dlm->domain_map, &iter);\r\nspin_unlock(&dlm->spinlock);\r\nstage2:\r\nmemset(&fr, 0, sizeof(fr));\r\nfr.node_idx = dlm->node_num;\r\nfr.dead_node = dlm->reco.dead_node;\r\nif (stage == 2)\r\nfr.flags |= DLM_FINALIZE_STAGE2;\r\nwhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\r\nif (nodenum == dlm->node_num)\r\ncontinue;\r\nret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\r\n&fr, sizeof(fr), nodenum, &status);\r\nif (ret >= 0)\r\nret = status;\r\nif (ret < 0) {\r\nmlog(ML_ERROR, "Error %d when sending message %u (key "\r\n"0x%x) to node %u\n", ret, DLM_FINALIZE_RECO_MSG,\r\ndlm->key, nodenum);\r\nif (dlm_is_host_down(ret)) {\r\nmlog(ML_ERROR, "node %u went down after this "\r\n"node finished recovery.\n", nodenum);\r\nret = 0;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (stage == 1) {\r\niter.curnode = -1;\r\nstage = 2;\r\ngoto stage2;\r\n}\r\nreturn ret;\r\n}\r\nint dlm_finalize_reco_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_finalize_reco *fr = (struct dlm_finalize_reco *)msg->buf;\r\nint stage = 1;\r\nif (!dlm_grab(dlm))\r\nreturn 0;\r\nif (fr->flags & DLM_FINALIZE_STAGE2)\r\nstage = 2;\r\nmlog(0, "%s: node %u finalizing recovery stage%d of "\r\n"node %u (%u:%u)\n", dlm->name, fr->node_idx, stage,\r\nfr->dead_node, dlm->reco.dead_node, dlm->reco.new_master);\r\nspin_lock(&dlm->spinlock);\r\nif (dlm->reco.new_master != fr->node_idx) {\r\nmlog(ML_ERROR, "node %u sent recovery finalize msg, but node "\r\n"%u is supposed to be the new master, dead=%u\n",\r\nfr->node_idx, dlm->reco.new_master, fr->dead_node);\r\nBUG();\r\n}\r\nif (dlm->reco.dead_node != fr->dead_node) {\r\nmlog(ML_ERROR, "node %u sent recovery finalize msg for dead "\r\n"node %u, but node %u is supposed to be dead\n",\r\nfr->node_idx, fr->dead_node, dlm->reco.dead_node);\r\nBUG();\r\n}\r\nswitch (stage) {\r\ncase 1:\r\ndlm_finish_local_lockres_recovery(dlm, fr->dead_node, fr->node_idx);\r\nif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\r\nmlog(ML_ERROR, "%s: received finalize1 from "\r\n"new master %u for dead node %u, but "\r\n"this node has already received it!\n",\r\ndlm->name, fr->node_idx, fr->dead_node);\r\ndlm_print_reco_node_status(dlm);\r\nBUG();\r\n}\r\ndlm->reco.state |= DLM_RECO_STATE_FINALIZE;\r\nspin_unlock(&dlm->spinlock);\r\nbreak;\r\ncase 2:\r\nif (!(dlm->reco.state & DLM_RECO_STATE_FINALIZE)) {\r\nmlog(ML_ERROR, "%s: received finalize2 from "\r\n"new master %u for dead node %u, but "\r\n"this node did not have finalize1!\n",\r\ndlm->name, fr->node_idx, fr->dead_node);\r\ndlm_print_reco_node_status(dlm);\r\nBUG();\r\n}\r\ndlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\r\n__dlm_reset_recovery(dlm);\r\nspin_unlock(&dlm->spinlock);\r\ndlm_kick_recovery_thread(dlm);\r\nbreak;\r\n}\r\nmlog(0, "%s: recovery done, reco master was %u, dead now %u, master now %u\n",\r\ndlm->name, fr->node_idx, dlm->reco.dead_node, dlm->reco.new_master);\r\ndlm_put(dlm);\r\nreturn 0;\r\n}
