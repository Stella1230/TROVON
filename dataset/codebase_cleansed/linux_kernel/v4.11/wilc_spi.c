static u8 crc7_byte(u8 crc, u8 data)\r\n{\r\nreturn crc7_syndrome_table[(crc << 1) ^ data];\r\n}\r\nstatic u8 crc7(u8 crc, const u8 *buffer, u32 len)\r\n{\r\nwhile (len--)\r\ncrc = crc7_byte(crc, *buffer++);\r\nreturn crc;\r\n}\r\nstatic int wilc_bus_probe(struct spi_device *spi)\r\n{\r\nint ret, gpio;\r\nstruct wilc *wilc;\r\ngpio = of_get_gpio(spi->dev.of_node, 0);\r\nif (gpio < 0)\r\ngpio = GPIO_NUM;\r\nret = wilc_netdev_init(&wilc, NULL, HIF_SPI, GPIO_NUM, &wilc_hif_spi);\r\nif (ret)\r\nreturn ret;\r\nspi_set_drvdata(spi, wilc);\r\nwilc->dev = &spi->dev;\r\nreturn 0;\r\n}\r\nstatic int wilc_bus_remove(struct spi_device *spi)\r\n{\r\nwilc_netdev_cleanup(spi_get_drvdata(spi));\r\nreturn 0;\r\n}\r\nstatic int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nstruct spi_message msg;\r\nif (len > 0 && b) {\r\nstruct spi_transfer tr = {\r\n.tx_buf = b,\r\n.len = len,\r\n.delay_usecs = 0,\r\n};\r\nchar *r_buffer = kzalloc(len, GFP_KERNEL);\r\nif (!r_buffer)\r\nreturn -ENOMEM;\r\ntr.rx_buf = r_buffer;\r\ndev_dbg(&spi->dev, "Request writing %d bytes\n", len);\r\nmemset(&msg, 0, sizeof(msg));\r\nspi_message_init(&msg);\r\nmsg.spi = spi;\r\nmsg.is_dma_mapped = USE_SPI_DMA;\r\nspi_message_add_tail(&tr, &msg);\r\nret = spi_sync(spi, &msg);\r\nif (ret < 0)\r\ndev_err(&spi->dev, "SPI transaction failed\n");\r\nkfree(r_buffer);\r\n} else {\r\ndev_err(&spi->dev,\r\n"can't write data with the following length: %d\n",\r\nlen);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nif (rlen > 0) {\r\nstruct spi_message msg;\r\nstruct spi_transfer tr = {\r\n.rx_buf = rb,\r\n.len = rlen,\r\n.delay_usecs = 0,\r\n};\r\nchar *t_buffer = kzalloc(rlen, GFP_KERNEL);\r\nif (!t_buffer)\r\nreturn -ENOMEM;\r\ntr.tx_buf = t_buffer;\r\nmemset(&msg, 0, sizeof(msg));\r\nspi_message_init(&msg);\r\nmsg.spi = spi;\r\nmsg.is_dma_mapped = USE_SPI_DMA;\r\nspi_message_add_tail(&tr, &msg);\r\nret = spi_sync(spi, &msg);\r\nif (ret < 0)\r\ndev_err(&spi->dev, "SPI transaction failed\n");\r\nkfree(t_buffer);\r\n} else {\r\ndev_err(&spi->dev,\r\n"can't read data with the following length: %u\n",\r\nrlen);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wilc_spi_tx_rx(struct wilc *wilc, u8 *wb, u8 *rb, u32 rlen)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nif (rlen > 0) {\r\nstruct spi_message msg;\r\nstruct spi_transfer tr = {\r\n.rx_buf = rb,\r\n.tx_buf = wb,\r\n.len = rlen,\r\n.bits_per_word = 8,\r\n.delay_usecs = 0,\r\n};\r\nmemset(&msg, 0, sizeof(msg));\r\nspi_message_init(&msg);\r\nmsg.spi = spi;\r\nmsg.is_dma_mapped = USE_SPI_DMA;\r\nspi_message_add_tail(&tr, &msg);\r\nret = spi_sync(spi, &msg);\r\nif (ret < 0)\r\ndev_err(&spi->dev, "SPI transaction failed\n");\r\n} else {\r\ndev_err(&spi->dev,\r\n"can't read data with the following length: %u\n",\r\nrlen);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,\r\nu8 clockless)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nu8 wb[32], rb[32];\r\nu8 wix, rix;\r\nu32 len2;\r\nu8 rsp;\r\nint len = 0;\r\nint result = N_OK;\r\nwb[0] = cmd;\r\nswitch (cmd) {\r\ncase CMD_SINGLE_READ:\r\nwb[1] = (u8)(adr >> 16);\r\nwb[2] = (u8)(adr >> 8);\r\nwb[3] = (u8)adr;\r\nlen = 5;\r\nbreak;\r\ncase CMD_INTERNAL_READ:\r\nwb[1] = (u8)(adr >> 8);\r\nif (clockless == 1)\r\nwb[1] |= BIT(7);\r\nwb[2] = (u8)adr;\r\nwb[3] = 0x00;\r\nlen = 5;\r\nbreak;\r\ncase CMD_TERMINATE:\r\nwb[1] = 0x00;\r\nwb[2] = 0x00;\r\nwb[3] = 0x00;\r\nlen = 5;\r\nbreak;\r\ncase CMD_REPEAT:\r\nwb[1] = 0x00;\r\nwb[2] = 0x00;\r\nwb[3] = 0x00;\r\nlen = 5;\r\nbreak;\r\ncase CMD_RESET:\r\nwb[1] = 0xff;\r\nwb[2] = 0xff;\r\nwb[3] = 0xff;\r\nlen = 5;\r\nbreak;\r\ncase CMD_DMA_WRITE:\r\ncase CMD_DMA_READ:\r\nwb[1] = (u8)(adr >> 16);\r\nwb[2] = (u8)(adr >> 8);\r\nwb[3] = (u8)adr;\r\nwb[4] = (u8)(sz >> 8);\r\nwb[5] = (u8)(sz);\r\nlen = 7;\r\nbreak;\r\ncase CMD_DMA_EXT_WRITE:\r\ncase CMD_DMA_EXT_READ:\r\nwb[1] = (u8)(adr >> 16);\r\nwb[2] = (u8)(adr >> 8);\r\nwb[3] = (u8)adr;\r\nwb[4] = (u8)(sz >> 16);\r\nwb[5] = (u8)(sz >> 8);\r\nwb[6] = (u8)(sz);\r\nlen = 8;\r\nbreak;\r\ncase CMD_INTERNAL_WRITE:\r\nwb[1] = (u8)(adr >> 8);\r\nif (clockless == 1)\r\nwb[1] |= BIT(7);\r\nwb[2] = (u8)(adr);\r\nwb[3] = b[3];\r\nwb[4] = b[2];\r\nwb[5] = b[1];\r\nwb[6] = b[0];\r\nlen = 8;\r\nbreak;\r\ncase CMD_SINGLE_WRITE:\r\nwb[1] = (u8)(adr >> 16);\r\nwb[2] = (u8)(adr >> 8);\r\nwb[3] = (u8)(adr);\r\nwb[4] = b[3];\r\nwb[5] = b[2];\r\nwb[6] = b[1];\r\nwb[7] = b[0];\r\nlen = 9;\r\nbreak;\r\ndefault:\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\nif (result != N_OK)\r\nreturn result;\r\nif (!g_spi.crc_off)\r\nwb[len - 1] = (crc7(0x7f, (const u8 *)&wb[0], len - 1)) << 1;\r\nelse\r\nlen -= 1;\r\n#define NUM_SKIP_BYTES (1)\r\n#define NUM_RSP_BYTES (2)\r\n#define NUM_DATA_HDR_BYTES (1)\r\n#define NUM_DATA_BYTES (4)\r\n#define NUM_CRC_BYTES (2)\r\n#define NUM_DUMMY_BYTES (3)\r\nif ((cmd == CMD_RESET) ||\r\n(cmd == CMD_TERMINATE) ||\r\n(cmd == CMD_REPEAT)) {\r\nlen2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);\r\n} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {\r\nif (!g_spi.crc_off) {\r\nlen2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES\r\n+ NUM_CRC_BYTES + NUM_DUMMY_BYTES);\r\n} else {\r\nlen2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES\r\n+ NUM_DUMMY_BYTES);\r\n}\r\n} else {\r\nlen2 = len + (NUM_RSP_BYTES + NUM_DUMMY_BYTES);\r\n}\r\n#undef NUM_DUMMY_BYTES\r\nif (len2 > ARRAY_SIZE(wb)) {\r\ndev_err(&spi->dev, "spi buffer size too small (%d) (%zu)\n",\r\nlen2, ARRAY_SIZE(wb));\r\nreturn N_FAIL;\r\n}\r\nfor (wix = len; wix < len2; wix++)\r\nwb[wix] = 0;\r\nrix = len;\r\nif (wilc_spi_tx_rx(wilc, wb, rb, len2)) {\r\ndev_err(&spi->dev, "Failed cmd write, bus error...\n");\r\nreturn N_FAIL;\r\n}\r\nif ((cmd == CMD_RESET) ||\r\n(cmd == CMD_TERMINATE) ||\r\n(cmd == CMD_REPEAT)) {\r\nrix++;\r\n}\r\nrsp = rb[rix++];\r\nif (rsp != cmd) {\r\ndev_err(&spi->dev,\r\n"Failed cmd response, cmd (%02x), resp (%02x)\n",\r\ncmd, rsp);\r\nreturn N_FAIL;\r\n}\r\nrsp = rb[rix++];\r\nif (rsp != 0x00) {\r\ndev_err(&spi->dev, "Failed cmd state response state (%02x)\n",\r\nrsp);\r\nreturn N_FAIL;\r\n}\r\nif ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)\r\n|| (cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {\r\nint retry;\r\nu8 crc[2];\r\nretry = 100;\r\ndo {\r\nif (rix < len2) {\r\nrsp = rb[rix++];\r\n} else {\r\nretry = 0;\r\nbreak;\r\n}\r\nif (((rsp >> 4) & 0xf) == 0xf)\r\nbreak;\r\n} while (retry--);\r\nif (retry <= 0) {\r\ndev_err(&spi->dev,\r\n"Error, data read response (%02x)\n", rsp);\r\nreturn N_RESET;\r\n}\r\nif ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {\r\nif ((rix + 3) < len2) {\r\nb[0] = rb[rix++];\r\nb[1] = rb[rix++];\r\nb[2] = rb[rix++];\r\nb[3] = rb[rix++];\r\n} else {\r\ndev_err(&spi->dev,\r\n"buffer overrun when reading data.\n");\r\nreturn N_FAIL;\r\n}\r\nif (!g_spi.crc_off) {\r\nif ((rix + 1) < len2) {\r\ncrc[0] = rb[rix++];\r\ncrc[1] = rb[rix++];\r\n} else {\r\ndev_err(&spi->dev, "buffer overrun when reading crc.\n");\r\nreturn N_FAIL;\r\n}\r\n}\r\n} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {\r\nint ix;\r\nfor (ix = 0; (rix < len2) && (ix < sz); )\r\nb[ix++] = rb[rix++];\r\nsz -= ix;\r\nif (sz > 0) {\r\nint nbytes;\r\nif (sz <= (DATA_PKT_SZ - ix))\r\nnbytes = sz;\r\nelse\r\nnbytes = DATA_PKT_SZ - ix;\r\nif (wilc_spi_rx(wilc, &b[ix], nbytes)) {\r\ndev_err(&spi->dev, "Failed data block read, bus error...\n");\r\nresult = N_FAIL;\r\ngoto _error_;\r\n}\r\nif (!g_spi.crc_off) {\r\nif (wilc_spi_rx(wilc, crc, 2)) {\r\ndev_err(&spi->dev, "Failed data block crc read, bus error...\n");\r\nresult = N_FAIL;\r\ngoto _error_;\r\n}\r\n}\r\nix += nbytes;\r\nsz -= nbytes;\r\n}\r\nwhile (sz > 0) {\r\nint nbytes;\r\nif (sz <= DATA_PKT_SZ)\r\nnbytes = sz;\r\nelse\r\nnbytes = DATA_PKT_SZ;\r\nretry = 10;\r\ndo {\r\nif (wilc_spi_rx(wilc, &rsp, 1)) {\r\ndev_err(&spi->dev, "Failed data response read, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\nif (((rsp >> 4) & 0xf) == 0xf)\r\nbreak;\r\n} while (retry--);\r\nif (result == N_FAIL)\r\nbreak;\r\nif (wilc_spi_rx(wilc, &b[ix], nbytes)) {\r\ndev_err(&spi->dev, "Failed data block read, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\nif (!g_spi.crc_off) {\r\nif (wilc_spi_rx(wilc, crc, 2)) {\r\ndev_err(&spi->dev, "Failed data block crc read, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\n}\r\nix += nbytes;\r\nsz -= nbytes;\r\n}\r\n}\r\n}\r\n_error_:\r\nreturn result;\r\n}\r\nstatic int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ix, nbytes;\r\nint result = 1;\r\nu8 cmd, order, crc[2] = {0};\r\nix = 0;\r\ndo {\r\nif (sz <= DATA_PKT_SZ)\r\nnbytes = sz;\r\nelse\r\nnbytes = DATA_PKT_SZ;\r\ncmd = 0xf0;\r\nif (ix == 0) {\r\nif (sz <= DATA_PKT_SZ)\r\norder = 0x3;\r\nelse\r\norder = 0x1;\r\n} else {\r\nif (sz <= DATA_PKT_SZ)\r\norder = 0x3;\r\nelse\r\norder = 0x2;\r\n}\r\ncmd |= order;\r\nif (wilc_spi_tx(wilc, &cmd, 1)) {\r\ndev_err(&spi->dev,\r\n"Failed data block cmd write, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\nif (wilc_spi_tx(wilc, &b[ix], nbytes)) {\r\ndev_err(&spi->dev,\r\n"Failed data block write, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\nif (!g_spi.crc_off) {\r\nif (wilc_spi_tx(wilc, crc, 2)) {\r\ndev_err(&spi->dev, "Failed data block crc write, bus error...\n");\r\nresult = N_FAIL;\r\nbreak;\r\n}\r\n}\r\nix += nbytes;\r\nsz -= nbytes;\r\n} while (sz);\r\nreturn result;\r\n}\r\nstatic int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint result;\r\ndat = cpu_to_le32(dat);\r\nresult = spi_cmd_complete(wilc, CMD_INTERNAL_WRITE, adr, (u8 *)&dat, 4,\r\n0);\r\nif (result != N_OK)\r\ndev_err(&spi->dev, "Failed internal write cmd...\n");\r\nreturn result;\r\n}\r\nstatic int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint result;\r\nresult = spi_cmd_complete(wilc, CMD_INTERNAL_READ, adr, (u8 *)data, 4,\r\n0);\r\nif (result != N_OK) {\r\ndev_err(&spi->dev, "Failed internal read cmd...\n");\r\nreturn 0;\r\n}\r\n*data = cpu_to_le32(*data);\r\nreturn 1;\r\n}\r\nstatic int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint result = N_OK;\r\nu8 cmd = CMD_SINGLE_WRITE;\r\nu8 clockless = 0;\r\ndata = cpu_to_le32(data);\r\nif (addr < 0x30) {\r\ncmd = CMD_INTERNAL_WRITE;\r\nclockless = 1;\r\n}\r\nresult = spi_cmd_complete(wilc, cmd, addr, (u8 *)&data, 4, clockless);\r\nif (result != N_OK)\r\ndev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);\r\nreturn result;\r\n}\r\nstatic int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint result;\r\nu8 cmd = CMD_DMA_EXT_WRITE;\r\nif (size <= 4)\r\nreturn 0;\r\nresult = spi_cmd_complete(wilc, cmd, addr, NULL, size, 0);\r\nif (result != N_OK) {\r\ndev_err(&spi->dev,\r\n"Failed cmd, write block (%08x)...\n", addr);\r\nreturn 0;\r\n}\r\nresult = spi_data_write(wilc, buf, size);\r\nif (result != N_OK)\r\ndev_err(&spi->dev, "Failed block data write...\n");\r\nreturn 1;\r\n}\r\nstatic int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint result = N_OK;\r\nu8 cmd = CMD_SINGLE_READ;\r\nu8 clockless = 0;\r\nif (addr < 0x30) {\r\ncmd = CMD_INTERNAL_READ;\r\nclockless = 1;\r\n}\r\nresult = spi_cmd_complete(wilc, cmd, addr, (u8 *)data, 4, clockless);\r\nif (result != N_OK) {\r\ndev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);\r\nreturn 0;\r\n}\r\n*data = cpu_to_le32(*data);\r\nreturn 1;\r\n}\r\nstatic int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nu8 cmd = CMD_DMA_EXT_READ;\r\nint result;\r\nif (size <= 4)\r\nreturn 0;\r\nresult = spi_cmd_complete(wilc, cmd, addr, buf, size, 0);\r\nif (result != N_OK) {\r\ndev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int _wilc_spi_deinit(struct wilc *wilc)\r\n{\r\nreturn 1;\r\n}\r\nstatic int wilc_spi_init(struct wilc *wilc, bool resume)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nu32 reg;\r\nu32 chipid;\r\nstatic int isinit;\r\nif (isinit) {\r\nif (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {\r\ndev_err(&spi->dev, "Fail cmd read chip id...\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nmemset(&g_spi, 0, sizeof(struct wilc_spi));\r\ng_spi.crc_off = 0;\r\nif (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {\r\ng_spi.crc_off = 1;\r\ndev_err(&spi->dev, "Failed internal read protocol with CRC on, retrying with CRC off...\n");\r\nif (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {\r\ndev_err(&spi->dev,\r\n"Failed internal read protocol...\n");\r\nreturn 0;\r\n}\r\n}\r\nif (g_spi.crc_off == 0) {\r\nreg &= ~0xc;\r\nreg &= ~0x70;\r\nreg |= (0x5 << 4);\r\nif (!spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg)) {\r\ndev_err(&spi->dev, "[wilc spi %d]: Failed internal write protocol reg...\n", __LINE__);\r\nreturn 0;\r\n}\r\ng_spi.crc_off = 1;\r\n}\r\nif (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {\r\ndev_err(&spi->dev, "Fail cmd read chip id...\n");\r\nreturn 0;\r\n}\r\ng_spi.has_thrpt_enh = 1;\r\nisinit = 1;\r\nreturn 1;\r\n}\r\nstatic int wilc_spi_read_size(struct wilc *wilc, u32 *size)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nif (g_spi.has_thrpt_enh) {\r\nret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,\r\nsize);\r\n*size = *size & IRQ_DMA_WD_CNT_MASK;\r\n} else {\r\nu32 tmp;\r\nu32 byte_cnt;\r\nret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,\r\n&byte_cnt);\r\nif (!ret) {\r\ndev_err(&spi->dev,\r\n"Failed read WILC_VMM_TO_HOST_SIZE ...\n");\r\ngoto _fail_;\r\n}\r\ntmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;\r\n*size = tmp;\r\n}\r\n_fail_:\r\nreturn ret;\r\n}\r\nstatic int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nif (g_spi.has_thrpt_enh) {\r\nret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,\r\nint_status);\r\n} else {\r\nu32 tmp;\r\nu32 byte_cnt;\r\nret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,\r\n&byte_cnt);\r\nif (!ret) {\r\ndev_err(&spi->dev,\r\n"Failed read WILC_VMM_TO_HOST_SIZE ...\n");\r\ngoto _fail_;\r\n}\r\ntmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;\r\n{\r\nint happended, j;\r\nj = 0;\r\ndo {\r\nu32 irq_flags;\r\nhappended = 0;\r\nwilc_spi_read_reg(wilc, 0x1a90, &irq_flags);\r\ntmp |= ((irq_flags >> 27) << IRG_FLAGS_OFFSET);\r\nif (g_spi.nint > 5) {\r\nwilc_spi_read_reg(wilc, 0x1a94,\r\n&irq_flags);\r\ntmp |= (((irq_flags >> 0) & 0x7) << (IRG_FLAGS_OFFSET + 5));\r\n}\r\n{\r\nu32 unkmown_mask;\r\nunkmown_mask = ~((1ul << g_spi.nint) - 1);\r\nif ((tmp >> IRG_FLAGS_OFFSET) & unkmown_mask) {\r\ndev_err(&spi->dev, "Unexpected interrupt (2): j=%d, tmp=%x, mask=%x\n", j, tmp, unkmown_mask);\r\nhappended = 1;\r\n}\r\n}\r\nj++;\r\n} while (happended);\r\n}\r\n*int_status = tmp;\r\n}\r\n_fail_:\r\nreturn ret;\r\n}\r\nstatic int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nint ret;\r\nif (g_spi.has_thrpt_enh) {\r\nret = spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE,\r\nval);\r\n} else {\r\nu32 flags;\r\nflags = val & (BIT(MAX_NUM_INT) - 1);\r\nif (flags) {\r\nint i;\r\nret = 1;\r\nfor (i = 0; i < g_spi.nint; i++) {\r\nif (flags & 1)\r\nret = wilc_spi_write_reg(wilc, 0x10c8 + i * 4, 1);\r\nif (!ret)\r\nbreak;\r\nflags >>= 1;\r\n}\r\nif (!ret) {\r\ndev_err(&spi->dev,\r\n"Failed wilc_spi_write_reg, set reg %x ...\n",\r\n0x10c8 + i * 4);\r\ngoto _fail_;\r\n}\r\nfor (i = g_spi.nint; i < MAX_NUM_INT; i++) {\r\nif (flags & 1)\r\ndev_err(&spi->dev,\r\n"Unexpected interrupt cleared %d...\n",\r\ni);\r\nflags >>= 1;\r\n}\r\n}\r\n{\r\nu32 tbl_ctl;\r\ntbl_ctl = 0;\r\nif ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)\r\ntbl_ctl |= BIT(0);\r\nif ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)\r\ntbl_ctl |= BIT(1);\r\nret = wilc_spi_write_reg(wilc, WILC_VMM_TBL_CTL,\r\ntbl_ctl);\r\nif (!ret) {\r\ndev_err(&spi->dev,\r\n"fail write reg vmm_tbl_ctl...\n");\r\ngoto _fail_;\r\n}\r\nif ((val & EN_VMM) == EN_VMM) {\r\nret = wilc_spi_write_reg(wilc,\r\nWILC_VMM_CORE_CTL, 1);\r\nif (!ret) {\r\ndev_err(&spi->dev, "fail write reg vmm_core_ctl...\n");\r\ngoto _fail_;\r\n}\r\n}\r\n}\r\n}\r\n_fail_:\r\nreturn ret;\r\n}\r\nstatic int wilc_spi_sync_ext(struct wilc *wilc, int nint)\r\n{\r\nstruct spi_device *spi = to_spi_device(wilc->dev);\r\nu32 reg;\r\nint ret, i;\r\nif (nint > MAX_NUM_INT) {\r\ndev_err(&spi->dev, "Too many interrupts (%d)...\n", nint);\r\nreturn 0;\r\n}\r\ng_spi.nint = nint;\r\nret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed read reg (%08x)...\n",\r\nWILC_PIN_MUX_0);\r\nreturn 0;\r\n}\r\nreg |= BIT(8);\r\nret = wilc_spi_write_reg(wilc, WILC_PIN_MUX_0, reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed write reg (%08x)...\n",\r\nWILC_PIN_MUX_0);\r\nreturn 0;\r\n}\r\nret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed read reg (%08x)...\n",\r\nWILC_INTR_ENABLE);\r\nreturn 0;\r\n}\r\nfor (i = 0; (i < 5) && (nint > 0); i++, nint--)\r\nreg |= (BIT((27 + i)));\r\nret = wilc_spi_write_reg(wilc, WILC_INTR_ENABLE, reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed write reg (%08x)...\n",\r\nWILC_INTR_ENABLE);\r\nreturn 0;\r\n}\r\nif (nint) {\r\nret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed read reg (%08x)...\n",\r\nWILC_INTR2_ENABLE);\r\nreturn 0;\r\n}\r\nfor (i = 0; (i < 3) && (nint > 0); i++, nint--)\r\nreg |= BIT(i);\r\nret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);\r\nif (!ret) {\r\ndev_err(&spi->dev, "Failed write reg (%08x)...\n",\r\nWILC_INTR2_ENABLE);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}
