static int tcf_vlan(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_vlan *v = to_vlan(a);\r\nint action;\r\nint err;\r\nu16 tci;\r\nspin_lock(&v->tcf_lock);\r\ntcf_lastuse_update(&v->tcf_tm);\r\nbstats_update(&v->tcf_bstats, skb);\r\naction = v->tcf_action;\r\nif (skb_at_tc_ingress(skb))\r\nskb_push_rcsum(skb, skb->mac_len);\r\nswitch (v->tcfv_action) {\r\ncase TCA_VLAN_ACT_POP:\r\nerr = skb_vlan_pop(skb);\r\nif (err)\r\ngoto drop;\r\nbreak;\r\ncase TCA_VLAN_ACT_PUSH:\r\nerr = skb_vlan_push(skb, v->tcfv_push_proto, v->tcfv_push_vid |\r\n(v->tcfv_push_prio << VLAN_PRIO_SHIFT));\r\nif (err)\r\ngoto drop;\r\nbreak;\r\ncase TCA_VLAN_ACT_MODIFY:\r\nif (!skb_vlan_tagged(skb))\r\ngoto unlock;\r\nif (skb_vlan_tag_present(skb)) {\r\ntci = skb_vlan_tag_get(skb);\r\nskb->vlan_tci = 0;\r\n} else {\r\nerr = __skb_vlan_pop(skb, &tci);\r\nif (err)\r\ngoto drop;\r\n}\r\ntci = (tci & ~VLAN_VID_MASK) | v->tcfv_push_vid;\r\nif (v->tcfv_push_prio) {\r\ntci &= ~VLAN_PRIO_MASK;\r\ntci |= v->tcfv_push_prio << VLAN_PRIO_SHIFT;\r\n}\r\n__vlan_hwaccel_put_tag(skb, v->tcfv_push_proto, tci);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ngoto unlock;\r\ndrop:\r\naction = TC_ACT_SHOT;\r\nv->tcf_qstats.drops++;\r\nunlock:\r\nif (skb_at_tc_ingress(skb))\r\nskb_pull_rcsum(skb, skb->mac_len);\r\nspin_unlock(&v->tcf_lock);\r\nreturn action;\r\n}\r\nstatic int tcf_vlan_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **a,\r\nint ovr, int bind)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, vlan_net_id);\r\nstruct nlattr *tb[TCA_VLAN_MAX + 1];\r\nstruct tc_vlan *parm;\r\nstruct tcf_vlan *v;\r\nint action;\r\n__be16 push_vid = 0;\r\n__be16 push_proto = 0;\r\nu8 push_prio = 0;\r\nbool exists = false;\r\nint ret = 0, err;\r\nif (!nla)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_VLAN_MAX, nla, vlan_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[TCA_VLAN_PARMS])\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_VLAN_PARMS]);\r\nexists = tcf_hash_check(tn, parm->index, a, bind);\r\nif (exists && bind)\r\nreturn 0;\r\nswitch (parm->v_action) {\r\ncase TCA_VLAN_ACT_POP:\r\nbreak;\r\ncase TCA_VLAN_ACT_PUSH:\r\ncase TCA_VLAN_ACT_MODIFY:\r\nif (!tb[TCA_VLAN_PUSH_VLAN_ID]) {\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn -EINVAL;\r\n}\r\npush_vid = nla_get_u16(tb[TCA_VLAN_PUSH_VLAN_ID]);\r\nif (push_vid >= VLAN_VID_MASK) {\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn -ERANGE;\r\n}\r\nif (tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]) {\r\npush_proto = nla_get_be16(tb[TCA_VLAN_PUSH_VLAN_PROTOCOL]);\r\nswitch (push_proto) {\r\ncase htons(ETH_P_8021Q):\r\ncase htons(ETH_P_8021AD):\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\n} else {\r\npush_proto = htons(ETH_P_8021Q);\r\n}\r\nif (tb[TCA_VLAN_PUSH_VLAN_PRIORITY])\r\npush_prio = nla_get_u8(tb[TCA_VLAN_PUSH_VLAN_PRIORITY]);\r\nbreak;\r\ndefault:\r\nif (exists)\r\ntcf_hash_release(*a, bind);\r\nreturn -EINVAL;\r\n}\r\naction = parm->v_action;\r\nif (!exists) {\r\nret = tcf_hash_create(tn, parm->index, est, a,\r\n&act_vlan_ops, bind, false);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\ntcf_hash_release(*a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\nv = to_vlan(*a);\r\nspin_lock_bh(&v->tcf_lock);\r\nv->tcfv_action = action;\r\nv->tcfv_push_vid = push_vid;\r\nv->tcfv_push_prio = push_prio;\r\nv->tcfv_push_proto = push_proto;\r\nv->tcf_action = parm->action;\r\nspin_unlock_bh(&v->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(tn, *a);\r\nreturn ret;\r\n}\r\nstatic int tcf_vlan_dump(struct sk_buff *skb, struct tc_action *a,\r\nint bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_vlan *v = to_vlan(a);\r\nstruct tc_vlan opt = {\r\n.index = v->tcf_index,\r\n.refcnt = v->tcf_refcnt - ref,\r\n.bindcnt = v->tcf_bindcnt - bind,\r\n.action = v->tcf_action,\r\n.v_action = v->tcfv_action,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_VLAN_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nif ((v->tcfv_action == TCA_VLAN_ACT_PUSH ||\r\nv->tcfv_action == TCA_VLAN_ACT_MODIFY) &&\r\n(nla_put_u16(skb, TCA_VLAN_PUSH_VLAN_ID, v->tcfv_push_vid) ||\r\nnla_put_be16(skb, TCA_VLAN_PUSH_VLAN_PROTOCOL,\r\nv->tcfv_push_proto) ||\r\n(nla_put_u8(skb, TCA_VLAN_PUSH_VLAN_PRIORITY,\r\nv->tcfv_push_prio))))\r\ngoto nla_put_failure;\r\ntcf_tm_dump(&t, &v->tcf_tm);\r\nif (nla_put_64bit(skb, TCA_VLAN_TM, sizeof(t), &t, TCA_VLAN_PAD))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int tcf_vlan_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, vlan_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tcf_vlan_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, vlan_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int vlan_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, vlan_net_id);\r\nreturn tc_action_net_init(tn, &act_vlan_ops, VLAN_TAB_MASK);\r\n}\r\nstatic void __net_exit vlan_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, vlan_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int __init vlan_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_vlan_ops, &vlan_net_ops);\r\n}\r\nstatic void __exit vlan_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_vlan_ops, &vlan_net_ops);\r\n}
