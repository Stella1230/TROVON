static int ses_probe(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nint err = -ENODEV;\r\nif (sdev->type != TYPE_ENCLOSURE)\r\ngoto out;\r\nerr = 0;\r\nsdev_printk(KERN_NOTICE, sdev, "Attached Enclosure device\n");\r\nout:\r\nreturn err;\r\n}\r\nstatic void init_device_slot_control(unsigned char *dest_desc,\r\nstruct enclosure_component *ecomp,\r\nunsigned char *status)\r\n{\r\nmemcpy(dest_desc, status, 4);\r\ndest_desc[0] = 0;\r\nif (ecomp->type == ENCLOSURE_COMPONENT_DEVICE)\r\ndest_desc[1] = 0;\r\ndest_desc[2] &= 0xde;\r\ndest_desc[3] &= 0x3c;\r\n}\r\nstatic int ses_recv_diag(struct scsi_device *sdev, int page_code,\r\nvoid *buf, int bufflen)\r\n{\r\nint ret;\r\nunsigned char cmd[] = {\r\nRECEIVE_DIAGNOSTIC,\r\n1,\r\npage_code,\r\nbufflen >> 8,\r\nbufflen & 0xff,\r\n0\r\n};\r\nunsigned char recv_page_code;\r\nret = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,\r\nNULL, SES_TIMEOUT, SES_RETRIES, NULL);\r\nif (unlikely(!ret))\r\nreturn ret;\r\nrecv_page_code = ((unsigned char *)buf)[0];\r\nif (likely(recv_page_code == page_code))\r\nreturn ret;\r\nsdev_printk(KERN_ERR, sdev,\r\n"Wrong diagnostic page; asked for %d got %u\n",\r\npage_code, recv_page_code);\r\nreturn -EINVAL;\r\n}\r\nstatic int ses_send_diag(struct scsi_device *sdev, int page_code,\r\nvoid *buf, int bufflen)\r\n{\r\nu32 result;\r\nunsigned char cmd[] = {\r\nSEND_DIAGNOSTIC,\r\n0x10,\r\n0,\r\nbufflen >> 8,\r\nbufflen & 0xff,\r\n0\r\n};\r\nresult = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, buf, bufflen,\r\nNULL, SES_TIMEOUT, SES_RETRIES, NULL);\r\nif (result)\r\nsdev_printk(KERN_ERR, sdev, "SEND DIAGNOSTIC result: %8x\n",\r\nresult);\r\nreturn result;\r\n}\r\nstatic int ses_set_page2_descriptor(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp,\r\nunsigned char *desc)\r\n{\r\nint i, j, count = 0, descriptor = ecomp->number;\r\nstruct scsi_device *sdev = to_scsi_device(edev->edev.parent);\r\nstruct ses_device *ses_dev = edev->scratch;\r\nunsigned char *type_ptr = ses_dev->page1_types;\r\nunsigned char *desc_ptr = ses_dev->page2 + 8;\r\nmemset(desc_ptr, 0, ses_dev->page2_len - 8);\r\nfor (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {\r\nfor (j = 0; j < type_ptr[1]; j++) {\r\ndesc_ptr += 4;\r\nif (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&\r\ntype_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)\r\ncontinue;\r\nif (count++ == descriptor) {\r\nmemcpy(desc_ptr, desc, 4);\r\ndesc_ptr[0] |= 0x80;\r\ndesc_ptr[0] &= 0xf0;\r\n}\r\n}\r\n}\r\nreturn ses_send_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);\r\n}\r\nstatic unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp)\r\n{\r\nint i, j, count = 0, descriptor = ecomp->number;\r\nstruct scsi_device *sdev = to_scsi_device(edev->edev.parent);\r\nstruct ses_device *ses_dev = edev->scratch;\r\nunsigned char *type_ptr = ses_dev->page1_types;\r\nunsigned char *desc_ptr = ses_dev->page2 + 8;\r\nses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);\r\nfor (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {\r\nfor (j = 0; j < type_ptr[1]; j++) {\r\ndesc_ptr += 4;\r\nif (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&\r\ntype_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)\r\ncontinue;\r\nif (count++ == descriptor)\r\nreturn desc_ptr;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ses_get_fault(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp)\r\n{\r\nunsigned char *desc;\r\ndesc = ses_get_page2_descriptor(edev, ecomp);\r\nif (desc)\r\necomp->fault = (desc[3] & 0x60) >> 4;\r\n}\r\nstatic int ses_set_fault(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp,\r\nenum enclosure_component_setting val)\r\n{\r\nunsigned char desc[4];\r\nunsigned char *desc_ptr;\r\ndesc_ptr = ses_get_page2_descriptor(edev, ecomp);\r\nif (!desc_ptr)\r\nreturn -EIO;\r\ninit_device_slot_control(desc, ecomp, desc_ptr);\r\nswitch (val) {\r\ncase ENCLOSURE_SETTING_DISABLED:\r\ndesc[3] &= 0xdf;\r\nbreak;\r\ncase ENCLOSURE_SETTING_ENABLED:\r\ndesc[3] |= 0x20;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ses_set_page2_descriptor(edev, ecomp, desc);\r\n}\r\nstatic void ses_get_status(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp)\r\n{\r\nunsigned char *desc;\r\ndesc = ses_get_page2_descriptor(edev, ecomp);\r\nif (desc)\r\necomp->status = (desc[0] & 0x0f);\r\n}\r\nstatic void ses_get_locate(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp)\r\n{\r\nunsigned char *desc;\r\ndesc = ses_get_page2_descriptor(edev, ecomp);\r\nif (desc)\r\necomp->locate = (desc[2] & 0x02) ? 1 : 0;\r\n}\r\nstatic int ses_set_locate(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp,\r\nenum enclosure_component_setting val)\r\n{\r\nunsigned char desc[4];\r\nunsigned char *desc_ptr;\r\ndesc_ptr = ses_get_page2_descriptor(edev, ecomp);\r\nif (!desc_ptr)\r\nreturn -EIO;\r\ninit_device_slot_control(desc, ecomp, desc_ptr);\r\nswitch (val) {\r\ncase ENCLOSURE_SETTING_DISABLED:\r\ndesc[2] &= 0xfd;\r\nbreak;\r\ncase ENCLOSURE_SETTING_ENABLED:\r\ndesc[2] |= 0x02;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ses_set_page2_descriptor(edev, ecomp, desc);\r\n}\r\nstatic int ses_set_active(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp,\r\nenum enclosure_component_setting val)\r\n{\r\nunsigned char desc[4];\r\nunsigned char *desc_ptr;\r\ndesc_ptr = ses_get_page2_descriptor(edev, ecomp);\r\nif (!desc_ptr)\r\nreturn -EIO;\r\ninit_device_slot_control(desc, ecomp, desc_ptr);\r\nswitch (val) {\r\ncase ENCLOSURE_SETTING_DISABLED:\r\ndesc[2] &= 0x7f;\r\necomp->active = 0;\r\nbreak;\r\ncase ENCLOSURE_SETTING_ENABLED:\r\ndesc[2] |= 0x80;\r\necomp->active = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ses_set_page2_descriptor(edev, ecomp, desc);\r\n}\r\nstatic int ses_show_id(struct enclosure_device *edev, char *buf)\r\n{\r\nstruct ses_device *ses_dev = edev->scratch;\r\nunsigned long long id = get_unaligned_be64(ses_dev->page1+8+4);\r\nreturn sprintf(buf, "%#llx\n", id);\r\n}\r\nstatic void ses_get_power_status(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp)\r\n{\r\nunsigned char *desc;\r\ndesc = ses_get_page2_descriptor(edev, ecomp);\r\nif (desc)\r\necomp->power_status = (desc[3] & 0x10) ? 0 : 1;\r\n}\r\nstatic int ses_set_power_status(struct enclosure_device *edev,\r\nstruct enclosure_component *ecomp,\r\nint val)\r\n{\r\nunsigned char desc[4];\r\nunsigned char *desc_ptr;\r\ndesc_ptr = ses_get_page2_descriptor(edev, ecomp);\r\nif (!desc_ptr)\r\nreturn -EIO;\r\ninit_device_slot_control(desc, ecomp, desc_ptr);\r\nswitch (val) {\r\ncase 0:\r\ndesc[3] |= 0x10;\r\nbreak;\r\ncase 1:\r\ndesc[3] &= 0xef;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\necomp->power_status = val;\r\nreturn ses_set_page2_descriptor(edev, ecomp, desc);\r\n}\r\nstatic void ses_process_descriptor(struct enclosure_component *ecomp,\r\nunsigned char *desc)\r\n{\r\nint eip = desc[0] & 0x10;\r\nint invalid = desc[0] & 0x80;\r\nenum scsi_protocol proto = desc[0] & 0x0f;\r\nu64 addr = 0;\r\nint slot = -1;\r\nstruct ses_component *scomp = ecomp->scratch;\r\nunsigned char *d;\r\nif (invalid)\r\nreturn;\r\nswitch (proto) {\r\ncase SCSI_PROTOCOL_FCP:\r\nif (eip) {\r\nd = desc + 4;\r\nslot = d[3];\r\n}\r\nbreak;\r\ncase SCSI_PROTOCOL_SAS:\r\nif (eip) {\r\nd = desc + 4;\r\nslot = d[3];\r\nd = desc + 8;\r\n} else\r\nd = desc + 4;\r\naddr = (u64)d[12] << 56 |\r\n(u64)d[13] << 48 |\r\n(u64)d[14] << 40 |\r\n(u64)d[15] << 32 |\r\n(u64)d[16] << 24 |\r\n(u64)d[17] << 16 |\r\n(u64)d[18] << 8 |\r\n(u64)d[19];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\necomp->slot = slot;\r\nscomp->addr = addr;\r\n}\r\nstatic int ses_enclosure_find_by_addr(struct enclosure_device *edev,\r\nvoid *data)\r\n{\r\nstruct efd *efd = data;\r\nint i;\r\nstruct ses_component *scomp;\r\nif (!edev->component[0].scratch)\r\nreturn 0;\r\nfor (i = 0; i < edev->components; i++) {\r\nscomp = edev->component[i].scratch;\r\nif (scomp->addr != efd->addr)\r\ncontinue;\r\nif (enclosure_add_device(edev, i, efd->dev) == 0)\r\nkobject_uevent(&efd->dev->kobj, KOBJ_CHANGE);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ses_enclosure_data_process(struct enclosure_device *edev,\r\nstruct scsi_device *sdev,\r\nint create)\r\n{\r\nu32 result;\r\nunsigned char *buf = NULL, *type_ptr, *desc_ptr, *addl_desc_ptr = NULL;\r\nint i, j, page7_len, len, components;\r\nstruct ses_device *ses_dev = edev->scratch;\r\nint types = ses_dev->page1_num_types;\r\nunsigned char *hdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);\r\nif (!hdr_buf)\r\ngoto simple_populate;\r\nif (ses_dev->page10)\r\nses_recv_diag(sdev, 10, ses_dev->page10, ses_dev->page10_len);\r\nresult = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);\r\nif (result)\r\ngoto simple_populate;\r\npage7_len = len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\r\nbuf = kzalloc(len + 1, GFP_KERNEL);\r\nif (!buf)\r\ngoto simple_populate;\r\nresult = ses_recv_diag(sdev, 7, buf, len);\r\nif (result) {\r\nsimple_populate:\r\nkfree(buf);\r\nbuf = NULL;\r\ndesc_ptr = NULL;\r\nlen = 0;\r\npage7_len = 0;\r\n} else {\r\ndesc_ptr = buf + 8;\r\nlen = (desc_ptr[2] << 8) + desc_ptr[3];\r\ndesc_ptr += len + 4;\r\n}\r\nif (ses_dev->page10)\r\naddl_desc_ptr = ses_dev->page10 + 8;\r\ntype_ptr = ses_dev->page1_types;\r\ncomponents = 0;\r\nfor (i = 0; i < types; i++, type_ptr += 4) {\r\nfor (j = 0; j < type_ptr[1]; j++) {\r\nchar *name = NULL;\r\nstruct enclosure_component *ecomp;\r\nif (desc_ptr) {\r\nif (desc_ptr >= buf + page7_len) {\r\ndesc_ptr = NULL;\r\n} else {\r\nlen = (desc_ptr[2] << 8) + desc_ptr[3];\r\ndesc_ptr += 4;\r\ndesc_ptr[len] = '\0';\r\nname = desc_ptr;\r\n}\r\n}\r\nif (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {\r\nif (create)\r\necomp = enclosure_component_alloc(\r\nedev,\r\ncomponents++,\r\ntype_ptr[0],\r\nname);\r\nelse\r\necomp = &edev->component[components++];\r\nif (!IS_ERR(ecomp)) {\r\nses_get_power_status(edev, ecomp);\r\nif (addl_desc_ptr)\r\nses_process_descriptor(\r\necomp,\r\naddl_desc_ptr);\r\nif (create)\r\nenclosure_component_register(\r\necomp);\r\n}\r\n}\r\nif (desc_ptr)\r\ndesc_ptr += len;\r\nif (addl_desc_ptr &&\r\n(type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))\r\naddl_desc_ptr += addl_desc_ptr[1] + 2;\r\n}\r\n}\r\nkfree(buf);\r\nkfree(hdr_buf);\r\n}\r\nstatic void ses_match_to_enclosure(struct enclosure_device *edev,\r\nstruct scsi_device *sdev)\r\n{\r\nstruct efd efd = {\r\n.addr = 0,\r\n};\r\nses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);\r\nif (scsi_is_sas_rphy(sdev->sdev_target->dev.parent))\r\nefd.addr = sas_get_address(sdev);\r\nif (efd.addr) {\r\nefd.dev = &sdev->sdev_gendev;\r\nenclosure_for_each_device(ses_enclosure_find_by_addr, &efd);\r\n}\r\n}\r\nstatic int ses_intf_add(struct device *cdev,\r\nstruct class_interface *intf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(cdev->parent);\r\nstruct scsi_device *tmp_sdev;\r\nunsigned char *buf = NULL, *hdr_buf, *type_ptr;\r\nstruct ses_device *ses_dev;\r\nu32 result;\r\nint i, types, len, components = 0;\r\nint err = -ENOMEM;\r\nint num_enclosures;\r\nstruct enclosure_device *edev;\r\nstruct ses_component *scomp = NULL;\r\nif (!scsi_device_enclosure(sdev)) {\r\nstruct enclosure_device *prev = NULL;\r\nwhile ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {\r\nses_match_to_enclosure(edev, sdev);\r\nprev = edev;\r\n}\r\nreturn -ENODEV;\r\n}\r\nif (sdev->type != TYPE_ENCLOSURE)\r\nsdev_printk(KERN_NOTICE, sdev, "Embedded Enclosure Device\n");\r\nses_dev = kzalloc(sizeof(*ses_dev), GFP_KERNEL);\r\nhdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);\r\nif (!hdr_buf || !ses_dev)\r\ngoto err_init_free;\r\nresult = ses_recv_diag(sdev, 1, hdr_buf, INIT_ALLOC_SIZE);\r\nif (result)\r\ngoto recv_failed;\r\nlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\r\nbuf = kzalloc(len, GFP_KERNEL);\r\nif (!buf)\r\ngoto err_free;\r\nresult = ses_recv_diag(sdev, 1, buf, len);\r\nif (result)\r\ngoto recv_failed;\r\ntypes = 0;\r\nnum_enclosures = buf[1] + 1;\r\ntype_ptr = buf + 8;\r\nfor (i = 0; i < num_enclosures && type_ptr < buf + len; i++) {\r\ntypes += type_ptr[2];\r\ntype_ptr += type_ptr[3] + 4;\r\n}\r\nses_dev->page1_types = type_ptr;\r\nses_dev->page1_num_types = types;\r\nfor (i = 0; i < types && type_ptr < buf + len; i++, type_ptr += 4) {\r\nif (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||\r\ntype_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)\r\ncomponents += type_ptr[1];\r\n}\r\nses_dev->page1 = buf;\r\nses_dev->page1_len = len;\r\nbuf = NULL;\r\nresult = ses_recv_diag(sdev, 2, hdr_buf, INIT_ALLOC_SIZE);\r\nif (result)\r\ngoto recv_failed;\r\nlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\r\nbuf = kzalloc(len, GFP_KERNEL);\r\nif (!buf)\r\ngoto err_free;\r\nresult = ses_recv_diag(sdev, 2, buf, len);\r\nif (result)\r\ngoto recv_failed;\r\nses_dev->page2 = buf;\r\nses_dev->page2_len = len;\r\nbuf = NULL;\r\nresult = ses_recv_diag(sdev, 10, hdr_buf, INIT_ALLOC_SIZE);\r\nif (!result) {\r\nlen = (hdr_buf[2] << 8) + hdr_buf[3] + 4;\r\nbuf = kzalloc(len, GFP_KERNEL);\r\nif (!buf)\r\ngoto err_free;\r\nresult = ses_recv_diag(sdev, 10, buf, len);\r\nif (result)\r\ngoto recv_failed;\r\nses_dev->page10 = buf;\r\nses_dev->page10_len = len;\r\nbuf = NULL;\r\n}\r\nscomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);\r\nif (!scomp)\r\ngoto err_free;\r\nedev = enclosure_register(cdev->parent, dev_name(&sdev->sdev_gendev),\r\ncomponents, &ses_enclosure_callbacks);\r\nif (IS_ERR(edev)) {\r\nerr = PTR_ERR(edev);\r\ngoto err_free;\r\n}\r\nkfree(hdr_buf);\r\nedev->scratch = ses_dev;\r\nfor (i = 0; i < components; i++)\r\nedev->component[i].scratch = scomp + i;\r\nses_enclosure_data_process(edev, sdev, 1);\r\nshost_for_each_device(tmp_sdev, sdev->host) {\r\nif (tmp_sdev->lun != 0 || scsi_device_enclosure(tmp_sdev))\r\ncontinue;\r\nses_match_to_enclosure(edev, tmp_sdev);\r\n}\r\nreturn 0;\r\nrecv_failed:\r\nsdev_printk(KERN_ERR, sdev, "Failed to get diagnostic page 0x%x\n",\r\nresult);\r\nerr = -ENODEV;\r\nerr_free:\r\nkfree(buf);\r\nkfree(scomp);\r\nkfree(ses_dev->page10);\r\nkfree(ses_dev->page2);\r\nkfree(ses_dev->page1);\r\nerr_init_free:\r\nkfree(ses_dev);\r\nkfree(hdr_buf);\r\nsdev_printk(KERN_ERR, sdev, "Failed to bind enclosure %d\n", err);\r\nreturn err;\r\n}\r\nstatic int ses_remove(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ses_intf_remove_component(struct scsi_device *sdev)\r\n{\r\nstruct enclosure_device *edev, *prev = NULL;\r\nwhile ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {\r\nprev = edev;\r\nif (!enclosure_remove_device(edev, &sdev->sdev_gendev))\r\nbreak;\r\n}\r\nif (edev)\r\nput_device(&edev->edev);\r\n}\r\nstatic void ses_intf_remove_enclosure(struct scsi_device *sdev)\r\n{\r\nstruct enclosure_device *edev;\r\nstruct ses_device *ses_dev;\r\nedev = enclosure_find(&sdev->sdev_gendev, NULL);\r\nif (!edev)\r\nreturn;\r\nenclosure_unregister(edev);\r\nses_dev = edev->scratch;\r\nedev->scratch = NULL;\r\nkfree(ses_dev->page10);\r\nkfree(ses_dev->page1);\r\nkfree(ses_dev->page2);\r\nkfree(ses_dev);\r\nkfree(edev->component[0].scratch);\r\nput_device(&edev->edev);\r\n}\r\nstatic void ses_intf_remove(struct device *cdev,\r\nstruct class_interface *intf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(cdev->parent);\r\nif (!scsi_device_enclosure(sdev))\r\nses_intf_remove_component(sdev);\r\nelse\r\nses_intf_remove_enclosure(sdev);\r\n}\r\nstatic int __init ses_init(void)\r\n{\r\nint err;\r\nerr = scsi_register_interface(&ses_interface);\r\nif (err)\r\nreturn err;\r\nerr = scsi_register_driver(&ses_template.gendrv);\r\nif (err)\r\ngoto out_unreg;\r\nreturn 0;\r\nout_unreg:\r\nscsi_unregister_interface(&ses_interface);\r\nreturn err;\r\n}\r\nstatic void __exit ses_exit(void)\r\n{\r\nscsi_unregister_driver(&ses_template.gendrv);\r\nscsi_unregister_interface(&ses_interface);\r\n}
