static inline long lm75_reg_to_mc(s16 temp, u8 resolution)\r\n{\r\nreturn ((temp >> (16 - resolution)) * 1000) >> (resolution - 8);\r\n}\r\nstatic int lm75_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nstruct lm75_data *data = dev_get_drvdata(dev);\r\nunsigned int regval;\r\nint err, reg;\r\nswitch (type) {\r\ncase hwmon_chip:\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\n*val = data->sample_time;\r\nbreak;;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase hwmon_temp:\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nreg = LM75_REG_TEMP;\r\nbreak;\r\ncase hwmon_temp_max:\r\nreg = LM75_REG_MAX;\r\nbreak;\r\ncase hwmon_temp_max_hyst:\r\nreg = LM75_REG_HYST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = regmap_read(data->regmap, reg, &regval);\r\nif (err < 0)\r\nreturn err;\r\n*val = lm75_reg_to_mc(regval, data->resolution);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lm75_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long temp)\r\n{\r\nstruct lm75_data *data = dev_get_drvdata(dev);\r\nu8 resolution;\r\nint reg;\r\nif (type != hwmon_temp)\r\nreturn -EINVAL;\r\nswitch (attr) {\r\ncase hwmon_temp_max:\r\nreg = LM75_REG_MAX;\r\nbreak;\r\ncase hwmon_temp_max_hyst:\r\nreg = LM75_REG_HYST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (data->resolution_limits)\r\nresolution = data->resolution_limits;\r\nelse\r\nresolution = data->resolution;\r\ntemp = clamp_val(temp, LM75_TEMP_MIN, LM75_TEMP_MAX);\r\ntemp = DIV_ROUND_CLOSEST(temp << (resolution - 8),\r\n1000) << (16 - resolution);\r\nreturn regmap_write(data->regmap, reg, temp);\r\n}\r\nstatic umode_t lm75_is_visible(const void *data, enum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_chip:\r\nswitch (attr) {\r\ncase hwmon_chip_update_interval:\r\nreturn S_IRUGO;\r\n}\r\nbreak;\r\ncase hwmon_temp:\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nreturn S_IRUGO;\r\ncase hwmon_temp_max:\r\ncase hwmon_temp_max_hyst:\r\nreturn S_IRUGO | S_IWUSR;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool lm75_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg != LM75_REG_TEMP;\r\n}\r\nstatic bool lm75_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == LM75_REG_TEMP;\r\n}\r\nstatic void lm75_remove(void *data)\r\n{\r\nstruct lm75_data *lm75 = data;\r\nstruct i2c_client *client = lm75->client;\r\ni2c_smbus_write_byte_data(client, LM75_REG_CONF, lm75->orig_conf);\r\n}\r\nstatic int\r\nlm75_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct lm75_data *data;\r\nint status, err;\r\nu8 set_mask, clr_mask;\r\nint new;\r\nenum lm75_type kind = id->driver_data;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(dev, sizeof(struct lm75_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\ndata->regmap = devm_regmap_init_i2c(client, &lm75_regmap_config);\r\nif (IS_ERR(data->regmap))\r\nreturn PTR_ERR(data->regmap);\r\nset_mask = 0;\r\nclr_mask = LM75_SHUTDOWN;\r\nswitch (kind) {\r\ncase adt75:\r\nclr_mask |= 1 << 5;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC / 8;\r\nbreak;\r\ncase ds1775:\r\ncase ds75:\r\ncase stds75:\r\nclr_mask |= 3 << 5;\r\nset_mask |= 2 << 5;\r\ndata->resolution = 11;\r\ndata->sample_time = MSEC_PER_SEC;\r\nbreak;\r\ncase ds7505:\r\nset_mask |= 3 << 5;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\ncase g751:\r\ncase lm75:\r\ncase lm75a:\r\ndata->resolution = 9;\r\ndata->sample_time = MSEC_PER_SEC / 2;\r\nbreak;\r\ncase lm75b:\r\ndata->resolution = 11;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\ncase max6625:\r\ndata->resolution = 9;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\ncase max6626:\r\ndata->resolution = 12;\r\ndata->resolution_limits = 9;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\ncase tcn75:\r\ndata->resolution = 9;\r\ndata->sample_time = MSEC_PER_SEC / 8;\r\nbreak;\r\ncase mcp980x:\r\ndata->resolution_limits = 9;\r\ncase tmp100:\r\ncase tmp101:\r\nset_mask |= 3 << 5;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC;\r\nclr_mask |= 1 << 7;\r\nbreak;\r\ncase tmp112:\r\nset_mask |= 3 << 5;\r\nclr_mask |= 1 << 7;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\ncase tmp105:\r\ncase tmp175:\r\ncase tmp275:\r\ncase tmp75:\r\nset_mask |= 3 << 5;\r\nclr_mask |= 1 << 7;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC / 2;\r\nbreak;\r\ncase tmp75c:\r\nclr_mask |= 1 << 5;\r\ndata->resolution = 12;\r\ndata->sample_time = MSEC_PER_SEC / 4;\r\nbreak;\r\n}\r\nstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\r\nif (status < 0) {\r\ndev_dbg(dev, "Can't read config? %d\n", status);\r\nreturn status;\r\n}\r\ndata->orig_conf = status;\r\nnew = status & ~clr_mask;\r\nnew |= set_mask;\r\nif (status != new)\r\ni2c_smbus_write_byte_data(client, LM75_REG_CONF, new);\r\nerr = devm_add_action_or_reset(dev, lm75_remove, data);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "Config %02x\n", new);\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata, &lm75_chip_info,\r\nNULL);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndev_info(dev, "%s: sensor '%s'\n", dev_name(hwmon_dev), client->name);\r\nreturn 0;\r\n}\r\nstatic int lm75_detect(struct i2c_client *new_client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = new_client->adapter;\r\nint i;\r\nint conf, hyst, os;\r\nbool is_lm75a = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -ENODEV;\r\nconf = i2c_smbus_read_byte_data(new_client, 1);\r\nif (conf & 0xe0)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(new_client, 7) == LM75A_ID) {\r\nif (i2c_smbus_read_byte_data(new_client, 4) != 0xff\r\n|| i2c_smbus_read_byte_data(new_client, 5) != 0xff\r\n|| i2c_smbus_read_byte_data(new_client, 6) != 0xff)\r\nreturn -ENODEV;\r\nis_lm75a = 1;\r\nhyst = i2c_smbus_read_byte_data(new_client, 2);\r\nos = i2c_smbus_read_byte_data(new_client, 3);\r\n} else {\r\nhyst = i2c_smbus_read_byte_data(new_client, 2);\r\nif (i2c_smbus_read_byte_data(new_client, 4) != hyst\r\n|| i2c_smbus_read_byte_data(new_client, 5) != hyst\r\n|| i2c_smbus_read_byte_data(new_client, 6) != hyst\r\n|| i2c_smbus_read_byte_data(new_client, 7) != hyst)\r\nreturn -ENODEV;\r\nos = i2c_smbus_read_byte_data(new_client, 3);\r\nif (i2c_smbus_read_byte_data(new_client, 4) != os\r\n|| i2c_smbus_read_byte_data(new_client, 5) != os\r\n|| i2c_smbus_read_byte_data(new_client, 6) != os\r\n|| i2c_smbus_read_byte_data(new_client, 7) != os)\r\nreturn -ENODEV;\r\n}\r\nif (hyst == 0 && os == 0)\r\nreturn -ENODEV;\r\nfor (i = 8; i <= 248; i += 40) {\r\nif (i2c_smbus_read_byte_data(new_client, i + 1) != conf\r\n|| i2c_smbus_read_byte_data(new_client, i + 2) != hyst\r\n|| i2c_smbus_read_byte_data(new_client, i + 3) != os)\r\nreturn -ENODEV;\r\nif (is_lm75a && i2c_smbus_read_byte_data(new_client, i + 7)\r\n!= LM75A_ID)\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, is_lm75a ? "lm75a" : "lm75", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int lm75_suspend(struct device *dev)\r\n{\r\nint status;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\r\nif (status < 0) {\r\ndev_dbg(&client->dev, "Can't read config? %d\n", status);\r\nreturn status;\r\n}\r\nstatus = status | LM75_SHUTDOWN;\r\ni2c_smbus_write_byte_data(client, LM75_REG_CONF, status);\r\nreturn 0;\r\n}\r\nstatic int lm75_resume(struct device *dev)\r\n{\r\nint status;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstatus = i2c_smbus_read_byte_data(client, LM75_REG_CONF);\r\nif (status < 0) {\r\ndev_dbg(&client->dev, "Can't read config? %d\n", status);\r\nreturn status;\r\n}\r\nstatus = status & ~LM75_SHUTDOWN;\r\ni2c_smbus_write_byte_data(client, LM75_REG_CONF, status);\r\nreturn 0;\r\n}
