static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct az6007_device_state *st = fe_to_priv(fe);\r\nstruct dvb_usb_adapter *adap = fe->sec_priv;\r\nint status = 0;\r\npr_debug("%s: %s\n", __func__, enable ? "enable" : "disable");\r\nif (!adap || !st)\r\nreturn -EINVAL;\r\nif (enable)\r\nstatus = st->gate_ctrl(fe, 1);\r\nelse\r\nstatus = st->gate_ctrl(fe, 0);\r\nreturn status;\r\n}\r\nstatic int __az6007_read(struct usb_device *udev, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\nret = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nvalue, index, b, blen, 5000);\r\nif (ret < 0) {\r\npr_warn("usb read operation failed. (%d)\n", ret);\r\nreturn -EIO;\r\n}\r\nif (az6007_xfer_debug) {\r\nprintk(KERN_DEBUG "az6007: IN req: %02x, value: %04x, index: %04x\n",\r\nreq, value, index);\r\nprint_hex_dump_bytes("az6007: payload: ",\r\nDUMP_PREFIX_NONE, b, blen);\r\n}\r\nreturn ret;\r\n}\r\nstatic int az6007_read(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct az6007_device_state *st = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&st->mutex) < 0)\r\nreturn -EAGAIN;\r\nret = __az6007_read(d->udev, req, value, index, b, blen);\r\nmutex_unlock(&st->mutex);\r\nreturn ret;\r\n}\r\nstatic int __az6007_write(struct usb_device *udev, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nint ret;\r\nif (az6007_xfer_debug) {\r\nprintk(KERN_DEBUG "az6007: OUT req: %02x, value: %04x, index: %04x\n",\r\nreq, value, index);\r\nprint_hex_dump_bytes("az6007: payload: ",\r\nDUMP_PREFIX_NONE, b, blen);\r\n}\r\nif (blen > 64) {\r\npr_err("az6007: tried to write %d bytes, but I2C max size is 64 bytes\n",\r\nblen);\r\nreturn -EOPNOTSUPP;\r\n}\r\nret = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nreq,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nvalue, index, b, blen, 5000);\r\nif (ret != blen) {\r\npr_err("usb write operation failed. (%d)\n", ret);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int az6007_write(struct dvb_usb_device *d, u8 req, u16 value,\r\nu16 index, u8 *b, int blen)\r\n{\r\nstruct az6007_device_state *st = d->priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&st->mutex) < 0)\r\nreturn -EAGAIN;\r\nret = __az6007_write(d->udev, req, value, index, b, blen);\r\nmutex_unlock(&st->mutex);\r\nreturn ret;\r\n}\r\nstatic int az6007_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\npr_debug("%s: %s\n", __func__, onoff ? "enable" : "disable");\r\nreturn az6007_write(d, 0xbc, onoff, 0, NULL, 0);\r\n}\r\nstatic int az6007_rc_query(struct dvb_usb_device *d)\r\n{\r\nstruct az6007_device_state *st = d_to_priv(d);\r\nunsigned code;\r\nenum rc_type proto;\r\naz6007_read(d, AZ6007_READ_IR, 0, 0, st->data, 10);\r\nif (st->data[1] == 0x44)\r\nreturn 0;\r\nif ((st->data[3] ^ st->data[4]) == 0xff) {\r\nif ((st->data[1] ^ st->data[2]) == 0xff) {\r\ncode = RC_SCANCODE_NEC(st->data[1], st->data[3]);\r\nproto = RC_TYPE_NEC;\r\n} else {\r\ncode = RC_SCANCODE_NECX(st->data[1] << 8 | st->data[2],\r\nst->data[3]);\r\nproto = RC_TYPE_NECX;\r\n}\r\n} else {\r\ncode = RC_SCANCODE_NEC32(st->data[1] << 24 |\r\nst->data[2] << 16 |\r\nst->data[3] << 8 |\r\nst->data[4]);\r\nproto = RC_TYPE_NEC32;\r\n}\r\nrc_keydown(d->rc_dev, proto, code, st->data[5]);\r\nreturn 0;\r\n}\r\nstatic int az6007_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\npr_debug("Getting az6007 Remote Control properties\n");\r\nrc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32;\r\nrc->query = az6007_rc_query;\r\nrc->interval = 400;\r\nreturn 0;\r\n}\r\nstatic int az6007_ci_read_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint address)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC1;\r\nvalue = address;\r\nindex = 0;\r\nblen = 1;\r\nret = az6007_read(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\npr_warn("usb in operation failed. (%d)\n", ret);\r\nret = -EINVAL;\r\n} else {\r\nret = b[0];\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_write_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nint address,\r\nu8 value)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value1;\r\nu16 index;\r\nint blen;\r\npr_debug("%s(), slot %d\n", __func__, slot);\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC2;\r\nvalue1 = address;\r\nindex = value;\r\nblen = 0;\r\nret = az6007_write(d, req, value1, index, NULL, blen);\r\nif (ret != 0)\r\npr_warn("usb out operation failed. (%d)\n", ret);\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_read_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC3;\r\nvalue = address;\r\nindex = 0;\r\nblen = 2;\r\nret = az6007_read(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\npr_warn("usb in operation failed. (%d)\n", ret);\r\nret = -EINVAL;\r\n} else {\r\nif (b[0] == 0)\r\npr_warn("Read CI IO error\n");\r\nret = b[1];\r\npr_debug("read cam data = %x from 0x%x\n", b[1], value);\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_write_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot,\r\nu8 address,\r\nu8 value)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value1;\r\nu16 index;\r\nint blen;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC4;\r\nvalue1 = address;\r\nindex = value;\r\nblen = 0;\r\nret = az6007_write(d, req, value1, index, NULL, blen);\r\nif (ret != 0) {\r\npr_warn("usb out operation failed. (%d)\n", ret);\r\ngoto failed;\r\n}\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int CI_CamReady(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nreq = 0xC8;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 1;\r\nret = az6007_read(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\npr_warn("usb in operation failed. (%d)\n", ret);\r\nret = -EIO;\r\n} else{\r\nret = b[0];\r\n}\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret, i;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC6;\r\nvalue = 1;\r\nindex = 0;\r\nblen = 0;\r\nret = az6007_write(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\npr_warn("usb out operation failed. (%d)\n", ret);\r\ngoto failed;\r\n}\r\nmsleep(500);\r\nreq = 0xC6;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 0;\r\nret = az6007_write(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\npr_warn("usb out operation failed. (%d)\n", ret);\r\ngoto failed;\r\n}\r\nfor (i = 0; i < 15; i++) {\r\nmsleep(100);\r\nif (CI_CamReady(ca, slot)) {\r\npr_debug("CAM Ready\n");\r\nbreak;\r\n}\r\n}\r\nmsleep(5000);\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nreturn 0;\r\n}\r\nstatic int az6007_ci_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\npr_debug("%s()\n", __func__);\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC7;\r\nvalue = 1;\r\nindex = 0;\r\nblen = 0;\r\nret = az6007_write(d, req, value, index, NULL, blen);\r\nif (ret != 0) {\r\npr_warn("usb out operation failed. (%d)\n", ret);\r\ngoto failed;\r\n}\r\nfailed:\r\nmutex_unlock(&state->ca_mutex);\r\nreturn ret;\r\n}\r\nstatic int az6007_ci_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nstruct dvb_usb_device *d = (struct dvb_usb_device *)ca->data;\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\nu8 req;\r\nu16 value;\r\nu16 index;\r\nint blen;\r\nu8 *b;\r\nb = kmalloc(12, GFP_KERNEL);\r\nif (!b)\r\nreturn -ENOMEM;\r\nmutex_lock(&state->ca_mutex);\r\nreq = 0xC5;\r\nvalue = 0;\r\nindex = 0;\r\nblen = 1;\r\nret = az6007_read(d, req, value, index, b, blen);\r\nif (ret < 0) {\r\npr_warn("usb in operation failed. (%d)\n", ret);\r\nret = -EIO;\r\n} else\r\nret = 0;\r\nif (!ret && b[0] == 1) {\r\nret = DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nmutex_unlock(&state->ca_mutex);\r\nkfree(b);\r\nreturn ret;\r\n}\r\nstatic void az6007_ci_uninit(struct dvb_usb_device *d)\r\n{\r\nstruct az6007_device_state *state;\r\npr_debug("%s()\n", __func__);\r\nif (NULL == d)\r\nreturn;\r\nstate = d_to_priv(d);\r\nif (NULL == state)\r\nreturn;\r\nif (NULL == state->ca.data)\r\nreturn;\r\ndvb_ca_en50221_release(&state->ca);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\n}\r\nstatic int az6007_ci_init(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct az6007_device_state *state = adap_to_priv(adap);\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nmutex_init(&state->ca_mutex);\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = az6007_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = az6007_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = az6007_ci_read_cam_control;\r\nstate->ca.write_cam_control = az6007_ci_write_cam_control;\r\nstate->ca.slot_reset = az6007_ci_slot_reset;\r\nstate->ca.slot_shutdown = az6007_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = az6007_ci_slot_ts_enable;\r\nstate->ca.poll_slot_status = az6007_ci_poll_slot_status;\r\nstate->ca.data = d;\r\nret = dvb_ca_en50221_init(&adap->dvb_adap,\r\n&state->ca,\r\n0,\r\n1);\r\nif (ret != 0) {\r\npr_err("Cannot initialize CI: Error %d.\n", ret);\r\nmemset(&state->ca, 0, sizeof(state->ca));\r\nreturn ret;\r\n}\r\npr_debug("CI initialized.\n");\r\nreturn 0;\r\n}\r\nstatic int az6007_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct az6007_device_state *st = adap_to_priv(adap);\r\nint ret;\r\nret = az6007_read(d, AZ6007_READ_DATA, 6, 0, st->data, 6);\r\nmemcpy(mac, st->data, 6);\r\nif (ret > 0)\r\npr_debug("%s: mac is %pM\n", __func__, mac);\r\nreturn ret;\r\n}\r\nstatic int az6007_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct az6007_device_state *st = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\npr_debug("attaching demod drxk\n");\r\nadap->fe[0] = dvb_attach(drxk_attach, &terratec_h7_drxk,\r\n&d->i2c_adap);\r\nif (!adap->fe[0])\r\nreturn -EINVAL;\r\nadap->fe[0]->sec_priv = adap;\r\nst->gate_ctrl = adap->fe[0]->ops.i2c_gate_ctrl;\r\nadap->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\naz6007_ci_init(adap);\r\nreturn 0;\r\n}\r\nstatic int az6007_cablestar_hdci_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct az6007_device_state *st = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\npr_debug("attaching demod drxk\n");\r\nadap->fe[0] = dvb_attach(drxk_attach, &cablestar_hdci_drxk,\r\n&d->i2c_adap);\r\nif (!adap->fe[0])\r\nreturn -EINVAL;\r\nadap->fe[0]->sec_priv = adap;\r\nst->gate_ctrl = adap->fe[0]->ops.i2c_gate_ctrl;\r\nadap->fe[0]->ops.i2c_gate_ctrl = drxk_gate_ctrl;\r\naz6007_ci_init(adap);\r\nreturn 0;\r\n}\r\nstatic int az6007_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\npr_debug("attaching tuner mt2063\n");\r\nif (adap->fe[0]->ops.i2c_gate_ctrl)\r\nadap->fe[0]->ops.i2c_gate_ctrl(adap->fe[0], 1);\r\nif (!dvb_attach(mt2063_attach, adap->fe[0],\r\n&az6007_mt2063_config,\r\n&d->i2c_adap))\r\nreturn -EINVAL;\r\nif (adap->fe[0]->ops.i2c_gate_ctrl)\r\nadap->fe[0]->ops.i2c_gate_ctrl(adap->fe[0], 0);\r\nreturn 0;\r\n}\r\nstatic int az6007_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct az6007_device_state *state = d_to_priv(d);\r\nint ret;\r\npr_debug("%s()\n", __func__);\r\nif (!state->warm) {\r\nmutex_init(&state->mutex);\r\nret = az6007_write(d, AZ6007_POWER, 0, 2, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(60);\r\nret = az6007_write(d, AZ6007_POWER, 1, 4, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = az6007_write(d, AZ6007_POWER, 1, 3, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(20);\r\nret = az6007_write(d, AZ6007_POWER, 1, 4, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(400);\r\nret = az6007_write(d, FX2_SCON1, 0, 3, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(150);\r\nret = az6007_write(d, FX2_SCON1, 1, 3, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(430);\r\nret = az6007_write(d, AZ6007_POWER, 0, 0, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->warm = true;\r\nreturn 0;\r\n}\r\nif (!onoff)\r\nreturn 0;\r\naz6007_write(d, AZ6007_POWER, 0, 0, NULL, 0);\r\naz6007_write(d, AZ6007_TS_THROUGH, 0, 0, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int az6007_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct az6007_device_state *st = d_to_priv(d);\r\nint i, j, len;\r\nint ret = 0;\r\nu16 index;\r\nu16 value;\r\nint length;\r\nu8 req, addr;\r\nif (mutex_lock_interruptible(&st->mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\naddr = msgs[i].addr << 1;\r\nif (((i + 1) < num)\r\n&& (msgs[i].len == 1)\r\n&& ((msgs[i].flags & I2C_M_RD) != I2C_M_RD)\r\n&& (msgs[i + 1].flags & I2C_M_RD)\r\n&& (msgs[i].addr == msgs[i + 1].addr)) {\r\nif (az6007_xfer_debug)\r\nprintk(KERN_DEBUG "az6007: I2C W/R addr=0x%x len=%d/%d\n",\r\naddr, msgs[i].len, msgs[i + 1].len);\r\nreq = AZ6007_I2C_RD;\r\nindex = msgs[i].buf[0];\r\nvalue = addr | (1 << 8);\r\nlength = 6 + msgs[i + 1].len;\r\nlen = msgs[i + 1].len;\r\nret = __az6007_read(d->udev, req, value, index,\r\nst->data, length);\r\nif (ret >= len) {\r\nfor (j = 0; j < len; j++)\r\nmsgs[i + 1].buf[j] = st->data[j + 5];\r\n} else\r\nret = -EIO;\r\ni++;\r\n} else if (!(msgs[i].flags & I2C_M_RD)) {\r\nif (az6007_xfer_debug)\r\nprintk(KERN_DEBUG "az6007: I2C W addr=0x%x len=%d\n",\r\naddr, msgs[i].len);\r\nreq = AZ6007_I2C_WR;\r\nindex = msgs[i].buf[0];\r\nvalue = addr | (1 << 8);\r\nlength = msgs[i].len - 1;\r\nlen = msgs[i].len - 1;\r\nfor (j = 0; j < len; j++)\r\nst->data[j] = msgs[i].buf[j + 1];\r\nret = __az6007_write(d->udev, req, value, index,\r\nst->data, length);\r\n} else {\r\nif (az6007_xfer_debug)\r\nprintk(KERN_DEBUG "az6007: I2C R addr=0x%x len=%d\n",\r\naddr, msgs[i].len);\r\nreq = AZ6007_I2C_RD;\r\nindex = msgs[i].buf[0];\r\nvalue = addr;\r\nlength = msgs[i].len + 6;\r\nlen = msgs[i].len;\r\nret = __az6007_read(d->udev, req, value, index,\r\nst->data, length);\r\nfor (j = 0; j < len; j++)\r\nmsgs[i].buf[j] = st->data[j + 5];\r\n}\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nerr:\r\nmutex_unlock(&st->mutex);\r\nif (ret < 0) {\r\npr_info("%s ERROR: %i\n", __func__, ret);\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 az6007_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int az6007_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nint ret;\r\nu8 *mac;\r\npr_debug("Identifying az6007 state\n");\r\nmac = kmalloc(6, GFP_ATOMIC);\r\nif (!mac)\r\nreturn -ENOMEM;\r\nret = __az6007_read(d->udev, AZ6007_READ_DATA, 6, 0, mac, 6);\r\nif (ret == 6)\r\nret = WARM;\r\nelse\r\nret = COLD;\r\nkfree(mac);\r\nif (ret == COLD) {\r\n__az6007_write(d->udev, 0x09, 1, 0, NULL, 0);\r\n__az6007_write(d->udev, 0x00, 0, 0, NULL, 0);\r\n__az6007_write(d->udev, 0x00, 0, 0, NULL, 0);\r\n}\r\npr_debug("Device is on %s state\n",\r\nret == WARM ? "warm" : "cold");\r\nreturn ret;\r\n}\r\nstatic void az6007_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\naz6007_ci_uninit(d);\r\ndvb_usbv2_disconnect(intf);\r\n}\r\nstatic int az6007_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\npr_debug("Loading az6007 firmware\n");\r\nreturn cypress_load_firmware(d->udev, fw, CYPRESS_FX2);\r\n}\r\nstatic int az6007_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\naz6007_ci_uninit(d);\r\nreturn dvb_usbv2_suspend(intf, msg);\r\n}\r\nstatic int az6007_resume(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nstruct dvb_usb_adapter *adap = &d->adapter[0];\r\naz6007_ci_init(adap);\r\nreturn dvb_usbv2_resume(intf);\r\n}
