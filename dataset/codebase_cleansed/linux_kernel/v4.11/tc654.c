static struct tc654_data *tc654_update_client(struct device *dev)\r\n{\r\nstruct tc654_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret = 0;\r\nmutex_lock(&data->update_lock);\r\nif (time_before(jiffies, data->last_updated + TC654_UPDATE_INTERVAL) &&\r\nlikely(data->valid))\r\ngoto out;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_RPM(0));\r\nif (ret < 0)\r\ngoto out;\r\ndata->rpm_output[0] = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_RPM(1));\r\nif (ret < 0)\r\ngoto out;\r\ndata->rpm_output[1] = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_FAN_FAULT(0));\r\nif (ret < 0)\r\ngoto out;\r\ndata->fan_fault[0] = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_FAN_FAULT(1));\r\nif (ret < 0)\r\ngoto out;\r\ndata->fan_fault[1] = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_CONFIG);\r\nif (ret < 0)\r\ngoto out;\r\ndata->config = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_STATUS);\r\nif (ret < 0)\r\ngoto out;\r\ndata->status = ret;\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_DUTY_CYCLE);\r\nif (ret < 0)\r\ngoto out;\r\ndata->duty_cycle = ret & 0x0f;\r\ndata->last_updated = jiffies;\r\ndata->valid = true;\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nif (ret < 0)\r\ndata = ERR_PTR(ret);\r\nreturn data;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nint val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (data->config & TC654_REG_CONFIG_RES)\r\nval = data->rpm_output[nr] * TC654_HIGH_RPM_RESOLUTION;\r\nelse\r\nval = data->rpm_output[nr] * TC654_LOW_RPM_RESOLUTION;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n",\r\nTC654_FAN_FAULT_FROM_REG(data->fan_fault[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nval = clamp_val(val, 0, 12750);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_fault[nr] = TC654_FAN_FAULT_TO_REG(val);\r\nret = i2c_smbus_write_byte_data(client, TC654_REG_FAN_FAULT(nr),\r\ndata->fan_fault[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t show_fan_alarm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nint val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (nr == 0)\r\nval = !!(data->status & TC654_REG_STATUS_F1F);\r\nelse\r\nval = !!(data->status & TC654_REG_STATUS_F2F);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t show_fan_pulses(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nu8 val;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nval = BIT((data->config >> TC654_FAN_PULSE_SHIFT[nr]) & 0x03);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t set_fan_pulses(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(da)->index;\r\nstruct tc654_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nu8 config;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase 1:\r\nconfig = 0;\r\nbreak;\r\ncase 2:\r\nconfig = 1;\r\nbreak;\r\ncase 4:\r\nconfig = 2;\r\nbreak;\r\ncase 8:\r\nconfig = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->config &= ~(0x03 << TC654_FAN_PULSE_SHIFT[nr]);\r\ndata->config |= (config << TC654_FAN_PULSE_SHIFT[nr]);\r\nret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev,\r\nstruct device_attribute *da, char *buf)\r\n{\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nreturn sprintf(buf, "%d\n", !!(data->config & TC654_REG_CONFIG_DUTYC));\r\n}\r\nstatic ssize_t set_pwm_mode(struct device *dev,\r\nstruct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tc654_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (val)\r\ndata->config |= TC654_REG_CONFIG_DUTYC;\r\nelse\r\ndata->config &= ~TC654_REG_CONFIG_DUTYC;\r\nret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct tc654_data *data = tc654_update_client(dev);\r\nint pwm;\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (data->config & TC654_REG_CONFIG_SDM)\r\npwm = 0;\r\nelse\r\npwm = tc654_pwm_map[data->duty_cycle];\r\nreturn sprintf(buf, "%d\n", pwm);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *da,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tc654_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long val;\r\nint ret;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nif (val == 0)\r\ndata->config |= TC654_REG_CONFIG_SDM;\r\nelse\r\ndata->config &= ~TC654_REG_CONFIG_SDM;\r\ndata->duty_cycle = find_closest(val, tc654_pwm_map,\r\nARRAY_SIZE(tc654_pwm_map));\r\nret = i2c_smbus_write_byte_data(client, TC654_REG_CONFIG, data->config);\r\nif (ret < 0)\r\ngoto out;\r\nret = i2c_smbus_write_byte_data(client, TC654_REG_DUTY_CYCLE,\r\ndata->duty_cycle);\r\nout:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int tc654_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct tc654_data *data;\r\nstruct device *hwmon_dev;\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(dev, sizeof(struct tc654_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nret = i2c_smbus_read_byte_data(client, TC654_REG_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->config = ret;\r\nhwmon_dev =\r\ndevm_hwmon_device_register_with_groups(dev, client->name, data,\r\ntc654_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
