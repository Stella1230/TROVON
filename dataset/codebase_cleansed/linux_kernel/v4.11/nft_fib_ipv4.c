static __be32 get_saddr(__be32 addr)\r\n{\r\nif (ipv4_is_multicast(addr) || ipv4_is_lbcast(addr) ||\r\nipv4_is_zeronet(addr))\r\nreturn 0;\r\nreturn addr;\r\n}\r\nvoid nft_fib4_eval_type(const struct nft_expr *expr, struct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nu32 *dst = &regs->data[priv->dreg];\r\nconst struct net_device *dev = NULL;\r\nconst struct iphdr *iph;\r\n__be32 addr;\r\nif (priv->flags & NFTA_FIB_F_IIF)\r\ndev = nft_in(pkt);\r\nelse if (priv->flags & NFTA_FIB_F_OIF)\r\ndev = nft_out(pkt);\r\niph = ip_hdr(pkt->skb);\r\nif (priv->flags & NFTA_FIB_F_DADDR)\r\naddr = iph->daddr;\r\nelse\r\naddr = iph->saddr;\r\n*dst = inet_dev_addr_type(nft_net(pkt), dev, addr);\r\n}\r\nstatic int get_ifindex(const struct net_device *dev)\r\n{\r\nreturn dev ? dev->ifindex : 0;\r\n}\r\nvoid nft_fib4_eval(const struct nft_expr *expr, struct nft_regs *regs,\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_fib *priv = nft_expr_priv(expr);\r\nu32 *dest = &regs->data[priv->dreg];\r\nconst struct iphdr *iph;\r\nstruct fib_result res;\r\nstruct flowi4 fl4 = {\r\n.flowi4_scope = RT_SCOPE_UNIVERSE,\r\n.flowi4_iif = LOOPBACK_IFINDEX,\r\n};\r\nconst struct net_device *oif;\r\nstruct net_device *found;\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nint i;\r\n#endif\r\nif (priv->flags & NFTA_FIB_F_OIF)\r\noif = nft_out(pkt);\r\nelse if (priv->flags & NFTA_FIB_F_IIF)\r\noif = nft_in(pkt);\r\nelse\r\noif = NULL;\r\nif (nft_hook(pkt) == NF_INET_PRE_ROUTING &&\r\nnft_fib_is_loopback(pkt->skb, nft_in(pkt))) {\r\nnft_fib_store_result(dest, priv->result, pkt,\r\nnft_in(pkt)->ifindex);\r\nreturn;\r\n}\r\niph = ip_hdr(pkt->skb);\r\nif (ipv4_is_zeronet(iph->saddr)) {\r\nif (ipv4_is_lbcast(iph->daddr) ||\r\nipv4_is_local_multicast(iph->daddr)) {\r\nnft_fib_store_result(dest, priv->result, pkt,\r\nget_ifindex(pkt->skb->dev));\r\nreturn;\r\n}\r\n}\r\nif (priv->flags & NFTA_FIB_F_MARK)\r\nfl4.flowi4_mark = pkt->skb->mark;\r\nfl4.flowi4_tos = iph->tos & DSCP_BITS;\r\nif (priv->flags & NFTA_FIB_F_DADDR) {\r\nfl4.daddr = iph->daddr;\r\nfl4.saddr = get_saddr(iph->saddr);\r\n} else {\r\nfl4.daddr = iph->saddr;\r\nfl4.saddr = get_saddr(iph->daddr);\r\n}\r\n*dest = 0;\r\nif (fib_lookup(nft_net(pkt), &fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE))\r\nreturn;\r\nswitch (res.type) {\r\ncase RTN_UNICAST:\r\nbreak;\r\ncase RTN_LOCAL:\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif (!oif) {\r\nfound = FIB_RES_DEV(res);\r\ngoto ok;\r\n}\r\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\r\nfor (i = 0; i < res.fi->fib_nhs; i++) {\r\nstruct fib_nh *nh = &res.fi->fib_nh[i];\r\nif (nh->nh_dev == oif) {\r\nfound = nh->nh_dev;\r\ngoto ok;\r\n}\r\n}\r\nreturn;\r\n#else\r\nfound = FIB_RES_DEV(res);\r\nif (found != oif)\r\nreturn;\r\n#endif\r\nok:\r\nswitch (priv->result) {\r\ncase NFT_FIB_RESULT_OIF:\r\n*dest = found->ifindex;\r\nbreak;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nstrncpy((char *)dest, found->name, IFNAMSIZ);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_fib4_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nenum nft_fib_result result;\r\nif (!tb[NFTA_FIB_RESULT])\r\nreturn ERR_PTR(-EINVAL);\r\nresult = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\r\nswitch (result) {\r\ncase NFT_FIB_RESULT_OIF:\r\nreturn &nft_fib4_ops;\r\ncase NFT_FIB_RESULT_OIFNAME:\r\nreturn &nft_fib4_ops;\r\ncase NFT_FIB_RESULT_ADDRTYPE:\r\nreturn &nft_fib4_type_ops;\r\ndefault:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\n}\r\nstatic int __init nft_fib4_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_fib4_type);\r\n}\r\nstatic void __exit nft_fib4_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_fib4_type);\r\n}
