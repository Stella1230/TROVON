int amdtp_stream_init(struct amdtp_stream *s, struct fw_unit *unit,\r\nenum amdtp_stream_direction dir, enum cip_flags flags,\r\nunsigned int fmt,\r\namdtp_stream_process_data_blocks_t process_data_blocks,\r\nunsigned int protocol_size)\r\n{\r\nif (process_data_blocks == NULL)\r\nreturn -EINVAL;\r\ns->protocol = kzalloc(protocol_size, GFP_KERNEL);\r\nif (!s->protocol)\r\nreturn -ENOMEM;\r\ns->unit = unit;\r\ns->direction = dir;\r\ns->flags = flags;\r\ns->context = ERR_PTR(-1);\r\nmutex_init(&s->mutex);\r\ntasklet_init(&s->period_tasklet, pcm_period_tasklet, (unsigned long)s);\r\ns->packet_index = 0;\r\ninit_waitqueue_head(&s->callback_wait);\r\ns->callbacked = false;\r\ns->fmt = fmt;\r\ns->process_data_blocks = process_data_blocks;\r\nreturn 0;\r\n}\r\nvoid amdtp_stream_destroy(struct amdtp_stream *s)\r\n{\r\nif (s->protocol == NULL)\r\nreturn;\r\nWARN_ON(amdtp_stream_running(s));\r\nkfree(s->protocol);\r\nmutex_destroy(&s->mutex);\r\n}\r\nint amdtp_stream_add_pcm_hw_constraints(struct amdtp_stream *s,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n5000, UINT_MAX);\r\nif (err < 0)\r\ngoto end;\r\nif (!(s->flags & CIP_BLOCKING))\r\ngoto end;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, 32);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\r\nend:\r\nreturn err;\r\n}\r\nint amdtp_stream_set_parameters(struct amdtp_stream *s, unsigned int rate,\r\nunsigned int data_block_quadlets)\r\n{\r\nunsigned int sfc;\r\nfor (sfc = 0; sfc < ARRAY_SIZE(amdtp_rate_table); ++sfc) {\r\nif (amdtp_rate_table[sfc] == rate)\r\nbreak;\r\n}\r\nif (sfc == ARRAY_SIZE(amdtp_rate_table))\r\nreturn -EINVAL;\r\ns->sfc = sfc;\r\ns->data_block_quadlets = data_block_quadlets;\r\ns->syt_interval = amdtp_syt_intervals[sfc];\r\ns->transfer_delay = TRANSFER_DELAY_TICKS - TICKS_PER_CYCLE;\r\nif (s->flags & CIP_BLOCKING)\r\ns->transfer_delay += TICKS_PER_SECOND * s->syt_interval / rate;\r\nreturn 0;\r\n}\r\nunsigned int amdtp_stream_get_max_payload(struct amdtp_stream *s)\r\n{\r\nunsigned int multiplier = 1;\r\nif (s->flags & CIP_JUMBO_PAYLOAD)\r\nmultiplier = 5;\r\nreturn 8 + s->syt_interval * s->data_block_quadlets * 4 * multiplier;\r\n}\r\nvoid amdtp_stream_pcm_prepare(struct amdtp_stream *s)\r\n{\r\ntasklet_kill(&s->period_tasklet);\r\ns->pcm_buffer_pointer = 0;\r\ns->pcm_period_pointer = 0;\r\n}\r\nstatic unsigned int calculate_data_blocks(struct amdtp_stream *s,\r\nunsigned int syt)\r\n{\r\nunsigned int phase, data_blocks;\r\nif (s->flags & CIP_BLOCKING) {\r\nif (syt == CIP_SYT_NO_INFO)\r\ndata_blocks = 0;\r\nelse\r\ndata_blocks = s->syt_interval;\r\n} else {\r\nif (!cip_sfc_is_base_44100(s->sfc)) {\r\ndata_blocks = s->data_block_state;\r\n} else {\r\nphase = s->data_block_state;\r\nif (s->sfc == CIP_SFC_44100)\r\ndata_blocks = 5 + ((phase & 1) ^\r\n(phase == 0 || phase >= 40));\r\nelse\r\ndata_blocks = 11 * (s->sfc >> 1) + (phase == 0);\r\nif (++phase >= (80 >> (s->sfc >> 1)))\r\nphase = 0;\r\ns->data_block_state = phase;\r\n}\r\n}\r\nreturn data_blocks;\r\n}\r\nstatic unsigned int calculate_syt(struct amdtp_stream *s,\r\nunsigned int cycle)\r\n{\r\nunsigned int syt_offset, phase, index, syt;\r\nif (s->last_syt_offset < TICKS_PER_CYCLE) {\r\nif (!cip_sfc_is_base_44100(s->sfc))\r\nsyt_offset = s->last_syt_offset + s->syt_offset_state;\r\nelse {\r\nphase = s->syt_offset_state;\r\nindex = phase % 13;\r\nsyt_offset = s->last_syt_offset;\r\nsyt_offset += 1386 + ((index && !(index & 3)) ||\r\nphase == 146);\r\nif (++phase >= 147)\r\nphase = 0;\r\ns->syt_offset_state = phase;\r\n}\r\n} else\r\nsyt_offset = s->last_syt_offset - TICKS_PER_CYCLE;\r\ns->last_syt_offset = syt_offset;\r\nif (syt_offset < TICKS_PER_CYCLE) {\r\nsyt_offset += s->transfer_delay;\r\nsyt = (cycle + syt_offset / TICKS_PER_CYCLE) << 12;\r\nsyt += syt_offset % TICKS_PER_CYCLE;\r\nreturn syt & CIP_SYT_MASK;\r\n} else {\r\nreturn CIP_SYT_NO_INFO;\r\n}\r\n}\r\nstatic void update_pcm_pointers(struct amdtp_stream *s,\r\nstruct snd_pcm_substream *pcm,\r\nunsigned int frames)\r\n{\r\nunsigned int ptr;\r\nptr = s->pcm_buffer_pointer + frames;\r\nif (ptr >= pcm->runtime->buffer_size)\r\nptr -= pcm->runtime->buffer_size;\r\nACCESS_ONCE(s->pcm_buffer_pointer) = ptr;\r\ns->pcm_period_pointer += frames;\r\nif (s->pcm_period_pointer >= pcm->runtime->period_size) {\r\ns->pcm_period_pointer -= pcm->runtime->period_size;\r\ntasklet_hi_schedule(&s->period_tasklet);\r\n}\r\n}\r\nstatic void pcm_period_tasklet(unsigned long data)\r\n{\r\nstruct amdtp_stream *s = (void *)data;\r\nstruct snd_pcm_substream *pcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\nsnd_pcm_period_elapsed(pcm);\r\n}\r\nstatic int queue_packet(struct amdtp_stream *s, unsigned int header_length,\r\nunsigned int payload_length)\r\n{\r\nstruct fw_iso_packet p = {0};\r\nint err = 0;\r\nif (IS_ERR(s->context))\r\ngoto end;\r\np.interrupt = IS_ALIGNED(s->packet_index + 1, INTERRUPT_INTERVAL);\r\np.tag = TAG_CIP;\r\np.header_length = header_length;\r\nif (payload_length > 0)\r\np.payload_length = payload_length;\r\nelse\r\np.skip = true;\r\nerr = fw_iso_context_queue(s->context, &p, &s->buffer.iso_buffer,\r\ns->buffer.packets[s->packet_index].offset);\r\nif (err < 0) {\r\ndev_err(&s->unit->device, "queueing error: %d\n", err);\r\ngoto end;\r\n}\r\nif (++s->packet_index >= QUEUE_LENGTH)\r\ns->packet_index = 0;\r\nend:\r\nreturn err;\r\n}\r\nstatic inline int queue_out_packet(struct amdtp_stream *s,\r\nunsigned int payload_length)\r\n{\r\nreturn queue_packet(s, OUT_PACKET_HEADER_SIZE, payload_length);\r\n}\r\nstatic inline int queue_in_packet(struct amdtp_stream *s)\r\n{\r\nreturn queue_packet(s, IN_PACKET_HEADER_SIZE,\r\namdtp_stream_get_max_payload(s));\r\n}\r\nstatic int handle_out_packet(struct amdtp_stream *s, unsigned int cycle,\r\nunsigned int index)\r\n{\r\n__be32 *buffer;\r\nunsigned int syt;\r\nunsigned int data_blocks;\r\nunsigned int payload_length;\r\nunsigned int pcm_frames;\r\nstruct snd_pcm_substream *pcm;\r\nbuffer = s->buffer.packets[s->packet_index].buffer;\r\nsyt = calculate_syt(s, cycle);\r\ndata_blocks = calculate_data_blocks(s, syt);\r\npcm_frames = s->process_data_blocks(s, buffer + 2, data_blocks, &syt);\r\nbuffer[0] = cpu_to_be32(ACCESS_ONCE(s->source_node_id_field) |\r\n(s->data_block_quadlets << CIP_DBS_SHIFT) |\r\ns->data_block_counter);\r\nbuffer[1] = cpu_to_be32(CIP_EOH |\r\n((s->fmt << CIP_FMT_SHIFT) & CIP_FMT_MASK) |\r\n((s->fdf << CIP_FDF_SHIFT) & CIP_FDF_MASK) |\r\n(syt & CIP_SYT_MASK));\r\ns->data_block_counter = (s->data_block_counter + data_blocks) & 0xff;\r\npayload_length = 8 + data_blocks * 4 * s->data_block_quadlets;\r\ntrace_out_packet(s, cycle, buffer, payload_length, index);\r\nif (queue_out_packet(s, payload_length) < 0)\r\nreturn -EIO;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm && pcm_frames > 0)\r\nupdate_pcm_pointers(s, pcm, pcm_frames);\r\nreturn 0;\r\n}\r\nstatic int handle_in_packet(struct amdtp_stream *s,\r\nunsigned int payload_quadlets, unsigned int cycle,\r\nunsigned int index)\r\n{\r\n__be32 *buffer;\r\nu32 cip_header[2];\r\nunsigned int fmt, fdf, syt;\r\nunsigned int data_block_quadlets, data_block_counter, dbc_interval;\r\nunsigned int data_blocks;\r\nstruct snd_pcm_substream *pcm;\r\nunsigned int pcm_frames;\r\nbool lost;\r\nbuffer = s->buffer.packets[s->packet_index].buffer;\r\ncip_header[0] = be32_to_cpu(buffer[0]);\r\ncip_header[1] = be32_to_cpu(buffer[1]);\r\ntrace_in_packet(s, cycle, cip_header, payload_quadlets, index);\r\nif (((cip_header[0] & CIP_EOH_MASK) == CIP_EOH) ||\r\n((cip_header[1] & CIP_EOH_MASK) != CIP_EOH)) {\r\ndev_info_ratelimited(&s->unit->device,\r\n"Invalid CIP header for AMDTP: %08X:%08X\n",\r\ncip_header[0], cip_header[1]);\r\ndata_blocks = 0;\r\npcm_frames = 0;\r\ngoto end;\r\n}\r\nfmt = (cip_header[1] & CIP_FMT_MASK) >> CIP_FMT_SHIFT;\r\nif (fmt != s->fmt) {\r\ndev_info_ratelimited(&s->unit->device,\r\n"Detect unexpected protocol: %08x %08x\n",\r\ncip_header[0], cip_header[1]);\r\ndata_blocks = 0;\r\npcm_frames = 0;\r\ngoto end;\r\n}\r\nfdf = (cip_header[1] & CIP_FDF_MASK) >> CIP_FDF_SHIFT;\r\nif (payload_quadlets < 3 ||\r\n(fmt == CIP_FMT_AM && fdf == AMDTP_FDF_NO_DATA)) {\r\ndata_blocks = 0;\r\n} else {\r\ndata_block_quadlets =\r\n(cip_header[0] & CIP_DBS_MASK) >> CIP_DBS_SHIFT;\r\nif (data_block_quadlets == 0) {\r\ndev_err(&s->unit->device,\r\n"Detect invalid value in dbs field: %08X\n",\r\ncip_header[0]);\r\nreturn -EPROTO;\r\n}\r\nif (s->flags & CIP_WRONG_DBS)\r\ndata_block_quadlets = s->data_block_quadlets;\r\ndata_blocks = (payload_quadlets - 2) / data_block_quadlets;\r\n}\r\ndata_block_counter = cip_header[0] & CIP_DBC_MASK;\r\nif (data_blocks == 0 && (s->flags & CIP_EMPTY_HAS_WRONG_DBC) &&\r\ns->data_block_counter != UINT_MAX)\r\ndata_block_counter = s->data_block_counter;\r\nif (((s->flags & CIP_SKIP_DBC_ZERO_CHECK) &&\r\ndata_block_counter == s->tx_first_dbc) ||\r\ns->data_block_counter == UINT_MAX) {\r\nlost = false;\r\n} else if (!(s->flags & CIP_DBC_IS_END_EVENT)) {\r\nlost = data_block_counter != s->data_block_counter;\r\n} else {\r\nif (data_blocks > 0 && s->tx_dbc_interval > 0)\r\ndbc_interval = s->tx_dbc_interval;\r\nelse\r\ndbc_interval = data_blocks;\r\nlost = data_block_counter !=\r\n((s->data_block_counter + dbc_interval) & 0xff);\r\n}\r\nif (lost) {\r\ndev_err(&s->unit->device,\r\n"Detect discontinuity of CIP: %02X %02X\n",\r\ns->data_block_counter, data_block_counter);\r\nreturn -EIO;\r\n}\r\nsyt = be32_to_cpu(buffer[1]) & CIP_SYT_MASK;\r\npcm_frames = s->process_data_blocks(s, buffer + 2, data_blocks, &syt);\r\nif (s->flags & CIP_DBC_IS_END_EVENT)\r\ns->data_block_counter = data_block_counter;\r\nelse\r\ns->data_block_counter =\r\n(data_block_counter + data_blocks) & 0xff;\r\nend:\r\nif (queue_in_packet(s) < 0)\r\nreturn -EIO;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm && pcm_frames > 0)\r\nupdate_pcm_pointers(s, pcm, pcm_frames);\r\nreturn 0;\r\n}\r\nstatic inline u32 compute_cycle_count(u32 tstamp)\r\n{\r\nreturn (((tstamp >> 13) & 0x07) * 8000) + (tstamp & 0x1fff);\r\n}\r\nstatic inline u32 increment_cycle_count(u32 cycle, unsigned int addend)\r\n{\r\ncycle += addend;\r\nif (cycle >= 8 * CYCLES_PER_SECOND)\r\ncycle -= 8 * CYCLES_PER_SECOND;\r\nreturn cycle;\r\n}\r\nstatic inline u32 decrement_cycle_count(u32 cycle, unsigned int subtrahend)\r\n{\r\nif (cycle < subtrahend)\r\ncycle += 8 * CYCLES_PER_SECOND;\r\nreturn cycle - subtrahend;\r\n}\r\nstatic void out_stream_callback(struct fw_iso_context *context, u32 tstamp,\r\nsize_t header_length, void *header,\r\nvoid *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\nunsigned int i, packets = header_length / 4;\r\nu32 cycle;\r\nif (s->packet_index < 0)\r\nreturn;\r\ncycle = compute_cycle_count(tstamp);\r\ncycle = increment_cycle_count(cycle, QUEUE_LENGTH - packets);\r\nfor (i = 0; i < packets; ++i) {\r\ncycle = increment_cycle_count(cycle, 1);\r\nif (handle_out_packet(s, cycle, i) < 0) {\r\ns->packet_index = -1;\r\namdtp_stream_pcm_abort(s);\r\nreturn;\r\n}\r\n}\r\nfw_iso_context_queue_flush(s->context);\r\n}\r\nstatic void in_stream_callback(struct fw_iso_context *context, u32 tstamp,\r\nsize_t header_length, void *header,\r\nvoid *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\nunsigned int i, packets;\r\nunsigned int payload_quadlets, max_payload_quadlets;\r\n__be32 *headers = header;\r\nu32 cycle;\r\nif (s->packet_index < 0)\r\nreturn;\r\npackets = header_length / IN_PACKET_HEADER_SIZE;\r\ncycle = compute_cycle_count(tstamp);\r\ncycle = decrement_cycle_count(cycle, packets);\r\nmax_payload_quadlets = amdtp_stream_get_max_payload(s) / 4;\r\nfor (i = 0; i < packets; i++) {\r\ncycle = increment_cycle_count(cycle, 1);\r\npayload_quadlets =\r\n(be32_to_cpu(headers[i]) >> ISO_DATA_LENGTH_SHIFT) / 4;\r\nif (payload_quadlets > max_payload_quadlets) {\r\ndev_err(&s->unit->device,\r\n"Detect jumbo payload: %02x %02x\n",\r\npayload_quadlets, max_payload_quadlets);\r\nbreak;\r\n}\r\nif (handle_in_packet(s, payload_quadlets, cycle, i) < 0)\r\nbreak;\r\n}\r\nif (i < packets) {\r\ns->packet_index = -1;\r\namdtp_stream_pcm_abort(s);\r\nreturn;\r\n}\r\nfw_iso_context_queue_flush(s->context);\r\n}\r\nstatic void amdtp_stream_first_callback(struct fw_iso_context *context,\r\nu32 tstamp, size_t header_length,\r\nvoid *header, void *private_data)\r\n{\r\nstruct amdtp_stream *s = private_data;\r\ns->callbacked = true;\r\nwake_up(&s->callback_wait);\r\nif (s->direction == AMDTP_IN_STREAM)\r\ncontext->callback.sc = in_stream_callback;\r\nelse\r\ncontext->callback.sc = out_stream_callback;\r\ncontext->callback.sc(context, tstamp, header_length, header, s);\r\n}\r\nint amdtp_stream_start(struct amdtp_stream *s, int channel, int speed)\r\n{\r\nstatic const struct {\r\nunsigned int data_block;\r\nunsigned int syt_offset;\r\n} initial_state[] = {\r\n[CIP_SFC_32000] = { 4, 3072 },\r\n[CIP_SFC_48000] = { 6, 1024 },\r\n[CIP_SFC_96000] = { 12, 1024 },\r\n[CIP_SFC_192000] = { 24, 1024 },\r\n[CIP_SFC_44100] = { 0, 67 },\r\n[CIP_SFC_88200] = { 0, 67 },\r\n[CIP_SFC_176400] = { 0, 67 },\r\n};\r\nunsigned int header_size;\r\nenum dma_data_direction dir;\r\nint type, tag, err;\r\nmutex_lock(&s->mutex);\r\nif (WARN_ON(amdtp_stream_running(s) ||\r\n(s->data_block_quadlets < 1))) {\r\nerr = -EBADFD;\r\ngoto err_unlock;\r\n}\r\nif (s->direction == AMDTP_IN_STREAM)\r\ns->data_block_counter = UINT_MAX;\r\nelse\r\ns->data_block_counter = 0;\r\ns->data_block_state = initial_state[s->sfc].data_block;\r\ns->syt_offset_state = initial_state[s->sfc].syt_offset;\r\ns->last_syt_offset = TICKS_PER_CYCLE;\r\nif (s->direction == AMDTP_IN_STREAM) {\r\ndir = DMA_FROM_DEVICE;\r\ntype = FW_ISO_CONTEXT_RECEIVE;\r\nheader_size = IN_PACKET_HEADER_SIZE;\r\n} else {\r\ndir = DMA_TO_DEVICE;\r\ntype = FW_ISO_CONTEXT_TRANSMIT;\r\nheader_size = OUT_PACKET_HEADER_SIZE;\r\n}\r\nerr = iso_packets_buffer_init(&s->buffer, s->unit, QUEUE_LENGTH,\r\namdtp_stream_get_max_payload(s), dir);\r\nif (err < 0)\r\ngoto err_unlock;\r\ns->context = fw_iso_context_create(fw_parent_device(s->unit)->card,\r\ntype, channel, speed, header_size,\r\namdtp_stream_first_callback, s);\r\nif (IS_ERR(s->context)) {\r\nerr = PTR_ERR(s->context);\r\nif (err == -EBUSY)\r\ndev_err(&s->unit->device,\r\n"no free stream on this controller\n");\r\ngoto err_buffer;\r\n}\r\namdtp_stream_update(s);\r\ns->packet_index = 0;\r\ndo {\r\nif (s->direction == AMDTP_IN_STREAM)\r\nerr = queue_in_packet(s);\r\nelse\r\nerr = queue_out_packet(s, 0);\r\nif (err < 0)\r\ngoto err_context;\r\n} while (s->packet_index > 0);\r\ntag = FW_ISO_CONTEXT_MATCH_TAG1;\r\nif (s->flags & CIP_EMPTY_WITH_TAG0)\r\ntag |= FW_ISO_CONTEXT_MATCH_TAG0;\r\ns->callbacked = false;\r\nerr = fw_iso_context_start(s->context, -1, 0, tag);\r\nif (err < 0)\r\ngoto err_context;\r\nmutex_unlock(&s->mutex);\r\nreturn 0;\r\nerr_context:\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\nerr_buffer:\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\nerr_unlock:\r\nmutex_unlock(&s->mutex);\r\nreturn err;\r\n}\r\nunsigned long amdtp_stream_pcm_pointer(struct amdtp_stream *s)\r\n{\r\nif (!in_interrupt() && amdtp_stream_running(s))\r\nfw_iso_context_flush_completions(s->context);\r\nreturn ACCESS_ONCE(s->pcm_buffer_pointer);\r\n}\r\nvoid amdtp_stream_update(struct amdtp_stream *s)\r\n{\r\nACCESS_ONCE(s->source_node_id_field) =\r\n(fw_parent_device(s->unit)->card->node_id << CIP_SID_SHIFT) &\r\nCIP_SID_MASK;\r\n}\r\nvoid amdtp_stream_stop(struct amdtp_stream *s)\r\n{\r\nmutex_lock(&s->mutex);\r\nif (!amdtp_stream_running(s)) {\r\nmutex_unlock(&s->mutex);\r\nreturn;\r\n}\r\ntasklet_kill(&s->period_tasklet);\r\nfw_iso_context_stop(s->context);\r\nfw_iso_context_destroy(s->context);\r\ns->context = ERR_PTR(-1);\r\niso_packets_buffer_destroy(&s->buffer, s->unit);\r\ns->callbacked = false;\r\nmutex_unlock(&s->mutex);\r\n}\r\nvoid amdtp_stream_pcm_abort(struct amdtp_stream *s)\r\n{\r\nstruct snd_pcm_substream *pcm;\r\npcm = ACCESS_ONCE(s->pcm);\r\nif (pcm)\r\nsnd_pcm_stop_xrun(pcm);\r\n}
