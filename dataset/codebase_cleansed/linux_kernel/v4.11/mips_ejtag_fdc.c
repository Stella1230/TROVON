static inline void mips_ejtag_fdc_write(struct mips_ejtag_fdc_tty *priv,\r\nunsigned int offs, unsigned int data)\r\n{\r\n__raw_writel(data, priv->reg + offs);\r\n}\r\nstatic inline unsigned int mips_ejtag_fdc_read(struct mips_ejtag_fdc_tty *priv,\r\nunsigned int offs)\r\n{\r\nreturn __raw_readl(priv->reg + offs);\r\n}\r\nstatic struct fdc_word mips_ejtag_fdc_encode(const char **ptrs,\r\nunsigned int *sizes,\r\nunsigned int ranges)\r\n{\r\nstruct fdc_word word = { 0, 0 };\r\nconst char **ptrs_end = ptrs + ranges;\r\nfor (; ptrs < ptrs_end; ++ptrs) {\r\nconst char *ptr = *(ptrs++);\r\nconst char *end = ptr + *(sizes++);\r\nfor (; ptr < end; ++ptr) {\r\nword.word |= (u8)*ptr << (8*word.bytes);\r\n++word.bytes;\r\nif (word.bytes == 4)\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nswitch (word.bytes) {\r\ncase 4:\r\nif ((word.word >> 8) != 0x808080 &&\r\n(word.word >> 16) != 0x8181 &&\r\n(word.word >> 24) != 0x82)\r\nbreak;\r\nword.bytes = 3;\r\nword.word &= 0x00ffffff;\r\ncase 3:\r\nword.word |= 0x82000000;\r\nbreak;\r\ncase 2:\r\nword.word |= 0x81810000;\r\nbreak;\r\ncase 1:\r\nword.word |= 0x80808000;\r\nbreak;\r\n}\r\nreturn word;\r\n}\r\nstatic unsigned int mips_ejtag_fdc_decode(u32 word, char *buf)\r\n{\r\nbuf[0] = (u8)word;\r\nword >>= 8;\r\nif (word == 0x808080)\r\nreturn 1;\r\nbuf[1] = (u8)word;\r\nword >>= 8;\r\nif (word == 0x8181)\r\nreturn 2;\r\nbuf[2] = (u8)word;\r\nword >>= 8;\r\nif (word == 0x82)\r\nreturn 3;\r\nbuf[3] = (u8)word;\r\nreturn 4;\r\n}\r\nstatic void mips_ejtag_fdc_console_write(struct console *c, const char *s,\r\nunsigned int count)\r\n{\r\nstruct mips_ejtag_fdc_console *cons =\r\ncontainer_of(c, struct mips_ejtag_fdc_console, cons);\r\nvoid __iomem *regs;\r\nstruct fdc_word word;\r\nunsigned long flags;\r\nunsigned int i, buf_len, cpu;\r\nbool done_cr = false;\r\nchar buf[4];\r\nconst char *buf_ptr = buf;\r\nu8 inc[4];\r\nlocal_irq_save(flags);\r\ncpu = smp_processor_id();\r\nregs = cons->regs[cpu];\r\nif (!regs) {\r\nregs = mips_cdmm_early_probe(0xfd);\r\ncons->regs[cpu] = regs;\r\n}\r\nif (IS_ERR(regs))\r\ngoto out;\r\nwhile (count) {\r\nfor (buf_len = 0, i = 0; buf_len < 4 && i < count; ++buf_len) {\r\nif (s[i] == '\n' && !done_cr) {\r\nbuf[buf_len] = '\r';\r\ndone_cr = true;\r\n} else {\r\nbuf[buf_len] = s[i];\r\ndone_cr = false;\r\n++i;\r\n}\r\ninc[buf_len] = i;\r\n}\r\nword = mips_ejtag_fdc_encode(&buf_ptr, &buf_len, 1);\r\ncount -= inc[word.bytes - 1];\r\ns += inc[word.bytes - 1];\r\nwhile (__raw_readl(regs + REG_FDSTAT) & REG_FDSTAT_TXF)\r\n;\r\n__raw_writel(word.word, regs + REG_FDTX(c->index));\r\n}\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nstatic struct tty_driver *mips_ejtag_fdc_console_device(struct console *c,\r\nint *index)\r\n{\r\nstruct mips_ejtag_fdc_console *cons =\r\ncontainer_of(c, struct mips_ejtag_fdc_console, cons);\r\n*index = c->index;\r\nreturn cons->tty_drv;\r\n}\r\nstatic int __init mips_ejtag_fdc_console_init(struct mips_ejtag_fdc_console *c)\r\n{\r\nvoid __iomem *regs;\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&c->lock, flags);\r\nif (c->initialised)\r\ngoto out;\r\nregs = mips_cdmm_early_probe(0xfd);\r\nif (IS_ERR(regs)) {\r\nret = PTR_ERR(regs);\r\ngoto out;\r\n}\r\nc->initialised = true;\r\nc->regs[smp_processor_id()] = regs;\r\nregister_console(&c->cons);\r\nout:\r\nraw_spin_unlock_irqrestore(&c->lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int mips_ejtag_fdc_put_chan(struct mips_ejtag_fdc_tty *priv,\r\nunsigned int chan)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport;\r\nstruct tty_struct *tty;\r\nconst char *ptrs[2];\r\nunsigned int sizes[2] = { 0 };\r\nstruct fdc_word word = { .bytes = 0 };\r\nunsigned long flags;\r\ndport = &priv->ports[chan];\r\nspin_lock(&dport->xmit_lock);\r\nif (dport->xmit_cnt) {\r\nptrs[0] = dport->port.xmit_buf + dport->xmit_tail;\r\nsizes[0] = min_t(unsigned int,\r\npriv->xmit_size - dport->xmit_tail,\r\ndport->xmit_cnt);\r\nptrs[1] = dport->port.xmit_buf;\r\nsizes[1] = dport->xmit_cnt - sizes[0];\r\nword = mips_ejtag_fdc_encode(ptrs, sizes, 1 + !!sizes[1]);\r\ndev_dbg(priv->dev, "%s%u: out %08x: \"%*pE%*pE\"\n",\r\npriv->driver_name, chan, word.word,\r\nmin_t(int, word.bytes, sizes[0]), ptrs[0],\r\nmax_t(int, 0, word.bytes - sizes[0]), ptrs[1]);\r\nlocal_irq_save(flags);\r\nif (mips_ejtag_fdc_read(priv, REG_FDSTAT) & REG_FDSTAT_TXF)\r\nword.bytes = 0;\r\nelse\r\nmips_ejtag_fdc_write(priv, REG_FDTX(chan), word.word);\r\nlocal_irq_restore(flags);\r\ndport->xmit_cnt -= word.bytes;\r\nif (!dport->xmit_cnt) {\r\ndport->xmit_head = 0;\r\ndport->xmit_tail = 0;\r\ncomplete(&dport->xmit_empty);\r\n} else {\r\ndport->xmit_tail += word.bytes;\r\nif (dport->xmit_tail >= priv->xmit_size)\r\ndport->xmit_tail -= priv->xmit_size;\r\n}\r\natomic_sub(word.bytes, &priv->xmit_total);\r\n}\r\nspin_unlock(&dport->xmit_lock);\r\nif (sizes[0] && word.bytes) {\r\ntty = tty_port_tty_get(&dport->port);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nreturn word.bytes;\r\n}\r\nstatic int mips_ejtag_fdc_put(void *arg)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = arg;\r\nstruct mips_ejtag_fdc_tty_port *dport;\r\nunsigned int ret;\r\nu32 cfg;\r\n__set_current_state(TASK_RUNNING);\r\nwhile (!kthread_should_stop()) {\r\nwait_event_interruptible(priv->waitqueue,\r\natomic_read(&priv->xmit_total) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop())\r\nbreak;\r\nraw_spin_lock_irq(&priv->lock);\r\nif (mips_ejtag_fdc_read(priv, REG_FDSTAT) & REG_FDSTAT_TXF) {\r\npriv->xmit_full = true;\r\nif (priv->irq >= 0) {\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~REG_FDCFG_TXINTTHRES;\r\ncfg |= REG_FDCFG_TXINTTHRES_NOTFULL;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\n}\r\n}\r\nraw_spin_unlock_irq(&priv->lock);\r\nwait_event_interruptible(priv->waitqueue,\r\n!(mips_ejtag_fdc_read(priv, REG_FDSTAT)\r\n& REG_FDSTAT_TXF) ||\r\nkthread_should_stop());\r\nif (kthread_should_stop())\r\nbreak;\r\nfor (;;) {\r\ndport = &priv->ports[priv->xmit_next];\r\nspin_lock(&dport->xmit_lock);\r\nret = dport->xmit_cnt;\r\nspin_unlock(&dport->xmit_lock);\r\nif (ret)\r\nbreak;\r\n++priv->xmit_next;\r\nif (priv->xmit_next >= NUM_TTY_CHANNELS)\r\npriv->xmit_next = 0;\r\n}\r\nret = mips_ejtag_fdc_put_chan(priv, priv->xmit_next);\r\nif (ret) {\r\n++priv->xmit_next;\r\nif (priv->xmit_next >= NUM_TTY_CHANNELS)\r\npriv->xmit_next = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mips_ejtag_fdc_handle(struct mips_ejtag_fdc_tty *priv)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport;\r\nunsigned int stat, channel, data, cfg, i, flipped;\r\nint len;\r\nchar buf[4];\r\nfor (;;) {\r\nstat = mips_ejtag_fdc_read(priv, REG_FDSTAT);\r\nif (stat & REG_FDSTAT_RXE)\r\nbreak;\r\nchannel = (stat & REG_FDSTAT_RXCHAN) >> REG_FDSTAT_RXCHAN_SHIFT;\r\ndport = &priv->ports[channel];\r\nraw_spin_lock(&dport->rx_lock);\r\ndata = mips_ejtag_fdc_read(priv, REG_FDRX);\r\nlen = mips_ejtag_fdc_decode(data, buf);\r\ndev_dbg(priv->dev, "%s%u: in %08x: \"%*pE\"\n",\r\npriv->driver_name, channel, data, len, buf);\r\nflipped = 0;\r\nfor (i = 0; i < len; ++i) {\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\n#ifdef CONFIG_MIPS_EJTAG_FDC_KGDB\r\nif (channel == CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN) {\r\nif (buf[i] == '\x03') {\r\nhandle_sysrq('g');\r\ncontinue;\r\n}\r\n}\r\n#endif\r\nif (channel == mips_ejtag_fdc_con.cons.index) {\r\nif (buf[i] == '\x0f') {\r\npriv->sysrq_pressed =\r\n!priv->sysrq_pressed;\r\nif (priv->sysrq_pressed)\r\ncontinue;\r\n} else if (priv->sysrq_pressed) {\r\nhandle_sysrq(buf[i]);\r\npriv->sysrq_pressed = false;\r\ncontinue;\r\n}\r\n}\r\n#endif\r\nif (!dport->rx_buf)\r\ncontinue;\r\nflipped += tty_insert_flip_char(&dport->port, buf[i],\r\nTTY_NORMAL);\r\n}\r\nif (flipped)\r\ntty_flip_buffer_push(&dport->port);\r\nraw_spin_unlock(&dport->rx_lock);\r\n}\r\nraw_spin_lock(&priv->lock);\r\nif (priv->xmit_full && !(stat & REG_FDSTAT_TXF)) {\r\npriv->xmit_full = false;\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~REG_FDCFG_TXINTTHRES;\r\ncfg |= REG_FDCFG_TXINTTHRES_DISABLED;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\nwake_up_interruptible(&priv->waitqueue);\r\n}\r\nraw_spin_unlock(&priv->lock);\r\n}\r\nstatic irqreturn_t mips_ejtag_fdc_isr(int irq, void *dev_id)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = dev_id;\r\nif (smp_processor_id() != priv->cpu)\r\nreturn IRQ_NONE;\r\nif (!(read_c0_cause() & CAUSEF_FDCI))\r\nreturn IRQ_NONE;\r\nmips_ejtag_fdc_handle(priv);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mips_ejtag_fdc_tty_timer(unsigned long opaque)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = (void *)opaque;\r\nmips_ejtag_fdc_handle(priv);\r\nif (!priv->removing)\r\nmod_timer(&priv->poll_timer, jiffies + FDC_TTY_POLL);\r\n}\r\nstatic int mips_ejtag_fdc_tty_port_activate(struct tty_port *port,\r\nstruct tty_struct *tty)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport =\r\ncontainer_of(port, struct mips_ejtag_fdc_tty_port, port);\r\nvoid *rx_buf;\r\nif (tty_port_alloc_xmit_buf(port) < 0)\r\ngoto err;\r\nrx_buf = kzalloc(RX_BUF_SIZE, GFP_KERNEL);\r\nif (!rx_buf)\r\ngoto err_free_xmit;\r\nraw_spin_lock_irq(&dport->rx_lock);\r\ndport->rx_buf = rx_buf;\r\nraw_spin_unlock_irq(&dport->rx_lock);\r\nreturn 0;\r\nerr_free_xmit:\r\ntty_port_free_xmit_buf(port);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void mips_ejtag_fdc_tty_port_shutdown(struct tty_port *port)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport =\r\ncontainer_of(port, struct mips_ejtag_fdc_tty_port, port);\r\nstruct mips_ejtag_fdc_tty *priv = dport->driver;\r\nvoid *rx_buf;\r\nunsigned int count;\r\nspin_lock(&dport->xmit_lock);\r\ncount = dport->xmit_cnt;\r\nspin_unlock(&dport->xmit_lock);\r\nif (count) {\r\nwake_up_interruptible(&priv->waitqueue);\r\nwait_for_completion(&dport->xmit_empty);\r\n}\r\nraw_spin_lock_irq(&dport->rx_lock);\r\nrx_buf = dport->rx_buf;\r\ndport->rx_buf = NULL;\r\nraw_spin_unlock_irq(&dport->rx_lock);\r\nkfree(rx_buf);\r\ntty_port_free_xmit_buf(port);\r\n}\r\nstatic int mips_ejtag_fdc_tty_install(struct tty_driver *driver,\r\nstruct tty_struct *tty)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = driver->driver_state;\r\ntty->driver_data = &priv->ports[tty->index];\r\nreturn tty_port_install(&priv->ports[tty->index].port, driver, tty);\r\n}\r\nstatic int mips_ejtag_fdc_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_open(tty->port, tty, filp);\r\n}\r\nstatic void mips_ejtag_fdc_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_close(tty->port, tty, filp);\r\n}\r\nstatic void mips_ejtag_fdc_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\r\nstruct mips_ejtag_fdc_tty *priv = dport->driver;\r\nspin_lock(&dport->xmit_lock);\r\nif (dport->xmit_cnt) {\r\natomic_sub(dport->xmit_cnt, &priv->xmit_total);\r\ndport->xmit_cnt = 0;\r\ndport->xmit_head = 0;\r\ndport->xmit_tail = 0;\r\ncomplete(&dport->xmit_empty);\r\n}\r\nspin_unlock(&dport->xmit_lock);\r\ntty_port_hangup(tty->port);\r\n}\r\nstatic int mips_ejtag_fdc_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int total)\r\n{\r\nint count, block;\r\nstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\r\nstruct mips_ejtag_fdc_tty *priv = dport->driver;\r\nspin_lock(&dport->xmit_lock);\r\ntotal = min(total, (int)(priv->xmit_size - dport->xmit_cnt));\r\natomic_add(total, &priv->xmit_total);\r\ndport->xmit_cnt += total;\r\nfor (count = total; count; count -= block) {\r\nblock = min(count, (int)(priv->xmit_size - dport->xmit_head));\r\nmemcpy(dport->port.xmit_buf + dport->xmit_head, buf, block);\r\ndport->xmit_head += block;\r\nif (dport->xmit_head >= priv->xmit_size)\r\ndport->xmit_head -= priv->xmit_size;\r\nbuf += block;\r\n}\r\ncount = dport->xmit_cnt;\r\nif (count)\r\nreinit_completion(&dport->xmit_empty);\r\nspin_unlock(&dport->xmit_lock);\r\nif (total)\r\nwake_up_interruptible(&priv->waitqueue);\r\nreturn total;\r\n}\r\nstatic int mips_ejtag_fdc_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\r\nstruct mips_ejtag_fdc_tty *priv = dport->driver;\r\nint room;\r\nspin_lock(&dport->xmit_lock);\r\nroom = priv->xmit_size - dport->xmit_cnt;\r\nspin_unlock(&dport->xmit_lock);\r\nreturn room;\r\n}\r\nstatic int mips_ejtag_fdc_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct mips_ejtag_fdc_tty_port *dport = tty->driver_data;\r\nint chars;\r\nspin_lock(&dport->xmit_lock);\r\nchars = dport->xmit_cnt;\r\nspin_unlock(&dport->xmit_lock);\r\nreturn chars;\r\n}\r\nint __weak get_c0_fdc_int(void)\r\n{\r\nreturn -1;\r\n}\r\nstatic int mips_ejtag_fdc_tty_probe(struct mips_cdmm_device *dev)\r\n{\r\nint ret, nport;\r\nstruct mips_ejtag_fdc_tty_port *dport;\r\nstruct mips_ejtag_fdc_tty *priv;\r\nstruct tty_driver *driver;\r\nunsigned int cfg, tx_fifo;\r\npriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->cpu = dev->cpu;\r\npriv->dev = &dev->dev;\r\nmips_cdmm_set_drvdata(dev, priv);\r\natomic_set(&priv->xmit_total, 0);\r\nraw_spin_lock_init(&priv->lock);\r\npriv->reg = devm_ioremap_nocache(priv->dev, dev->res.start,\r\nresource_size(&dev->res));\r\nif (!priv->reg) {\r\ndev_err(priv->dev, "ioremap failed for resource %pR\n",\r\n&dev->res);\r\nreturn -ENOMEM;\r\n}\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ntx_fifo = (cfg & REG_FDCFG_TXFIFOSIZE) >> REG_FDCFG_TXFIFOSIZE_SHIFT;\r\ncfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\r\ncfg |= REG_FDCFG_TXINTTHRES_DISABLED;\r\ncfg |= REG_FDCFG_RXINTTHRES_DISABLED;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\npriv->xmit_size = min(tx_fifo * 4, (unsigned int)SERIAL_XMIT_SIZE);\r\ndriver = tty_alloc_driver(NUM_TTY_CHANNELS, TTY_DRIVER_REAL_RAW);\r\nif (IS_ERR(driver))\r\nreturn PTR_ERR(driver);\r\npriv->driver = driver;\r\ndriver->driver_name = "ejtag_fdc";\r\nsnprintf(priv->fdc_name, sizeof(priv->fdc_name), "ttyFDC%u", dev->cpu);\r\nsnprintf(priv->driver_name, sizeof(priv->driver_name), "%sc",\r\npriv->fdc_name);\r\ndriver->name = priv->driver_name;\r\ndriver->major = 0;\r\ndriver->minor_start = 0;\r\ndriver->type = TTY_DRIVER_TYPE_SERIAL;\r\ndriver->subtype = SERIAL_TYPE_NORMAL;\r\ndriver->init_termios = tty_std_termios;\r\ndriver->init_termios.c_cflag |= CLOCAL;\r\ndriver->driver_state = priv;\r\ntty_set_operations(driver, &mips_ejtag_fdc_tty_ops);\r\nfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\r\ndport = &priv->ports[nport];\r\ndport->driver = priv;\r\ntty_port_init(&dport->port);\r\ndport->port.ops = &mips_ejtag_fdc_tty_port_ops;\r\nraw_spin_lock_init(&dport->rx_lock);\r\nspin_lock_init(&dport->xmit_lock);\r\ninit_completion(&dport->xmit_empty);\r\ncomplete(&dport->xmit_empty);\r\n}\r\nmips_ejtag_fdc_con.regs[dev->cpu] = priv->reg;\r\nif (dev->cpu == 0)\r\nmips_ejtag_fdc_con.tty_drv = driver;\r\ninit_waitqueue_head(&priv->waitqueue);\r\npriv->thread = kthread_create(mips_ejtag_fdc_put, priv, priv->fdc_name);\r\nif (IS_ERR(priv->thread)) {\r\nret = PTR_ERR(priv->thread);\r\ndev_err(priv->dev, "Couldn't create kthread (%d)\n", ret);\r\ngoto err_destroy_ports;\r\n}\r\nkthread_bind(priv->thread, dev->cpu);\r\nwake_up_process(priv->thread);\r\npriv->irq = get_c0_fdc_int();\r\nif (priv->irq >= 0) {\r\nret = devm_request_irq(priv->dev, priv->irq, mips_ejtag_fdc_isr,\r\nIRQF_PERCPU | IRQF_SHARED |\r\nIRQF_NO_THREAD | IRQF_COND_SUSPEND,\r\npriv->fdc_name, priv);\r\nif (ret)\r\npriv->irq = -1;\r\n}\r\nif (priv->irq >= 0) {\r\nraw_spin_lock_irq(&priv->lock);\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~REG_FDCFG_RXINTTHRES;\r\ncfg |= REG_FDCFG_RXINTTHRES_NOTEMPTY;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\nraw_spin_unlock_irq(&priv->lock);\r\n} else {\r\nsetup_pinned_timer(&priv->poll_timer, mips_ejtag_fdc_tty_timer,\r\n(unsigned long)priv);\r\npriv->poll_timer.expires = jiffies + FDC_TTY_POLL;\r\nadd_timer_on(&priv->poll_timer, dev->cpu);\r\ndev_info(priv->dev, "No usable IRQ, polling enabled\n");\r\n}\r\nret = tty_register_driver(driver);\r\nif (ret < 0) {\r\ndev_err(priv->dev, "Couldn't install tty driver (%d)\n", ret);\r\ngoto err_stop_irq;\r\n}\r\nreturn 0;\r\nerr_stop_irq:\r\nif (priv->irq >= 0) {\r\nraw_spin_lock_irq(&priv->lock);\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\r\ncfg |= REG_FDCFG_TXINTTHRES_DISABLED;\r\ncfg |= REG_FDCFG_RXINTTHRES_DISABLED;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\nraw_spin_unlock_irq(&priv->lock);\r\n} else {\r\npriv->removing = true;\r\ndel_timer_sync(&priv->poll_timer);\r\n}\r\nkthread_stop(priv->thread);\r\nerr_destroy_ports:\r\nif (dev->cpu == 0)\r\nmips_ejtag_fdc_con.tty_drv = NULL;\r\nfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\r\ndport = &priv->ports[nport];\r\ntty_port_destroy(&dport->port);\r\n}\r\nput_tty_driver(priv->driver);\r\nreturn ret;\r\n}\r\nstatic int mips_ejtag_fdc_tty_cpu_down(struct mips_cdmm_device *dev)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = mips_cdmm_get_drvdata(dev);\r\nunsigned int cfg;\r\nif (priv->irq >= 0) {\r\nraw_spin_lock_irq(&priv->lock);\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\r\ncfg |= REG_FDCFG_TXINTTHRES_DISABLED;\r\ncfg |= REG_FDCFG_RXINTTHRES_DISABLED;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\nraw_spin_unlock_irq(&priv->lock);\r\n} else {\r\npriv->removing = true;\r\ndel_timer_sync(&priv->poll_timer);\r\n}\r\nkthread_stop(priv->thread);\r\nreturn 0;\r\n}\r\nstatic int mips_ejtag_fdc_tty_cpu_up(struct mips_cdmm_device *dev)\r\n{\r\nstruct mips_ejtag_fdc_tty *priv = mips_cdmm_get_drvdata(dev);\r\nunsigned int cfg;\r\nint ret = 0;\r\nif (priv->irq >= 0) {\r\nraw_spin_lock_irq(&priv->lock);\r\ncfg = mips_ejtag_fdc_read(priv, REG_FDCFG);\r\ncfg &= ~(REG_FDCFG_TXINTTHRES | REG_FDCFG_RXINTTHRES);\r\ncfg |= REG_FDCFG_TXINTTHRES_DISABLED;\r\ncfg |= REG_FDCFG_RXINTTHRES_NOTEMPTY;\r\nmips_ejtag_fdc_write(priv, REG_FDCFG, cfg);\r\nraw_spin_unlock_irq(&priv->lock);\r\n} else {\r\npriv->removing = false;\r\nadd_timer_on(&priv->poll_timer, dev->cpu);\r\n}\r\npriv->thread = kthread_create(mips_ejtag_fdc_put, priv, priv->fdc_name);\r\nif (IS_ERR(priv->thread)) {\r\nret = PTR_ERR(priv->thread);\r\ndev_err(priv->dev, "Couldn't re-create kthread (%d)\n", ret);\r\ngoto out;\r\n}\r\nkthread_bind(priv->thread, dev->cpu);\r\nwake_up_process(priv->thread);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init mips_ejtag_fdc_init_console(void)\r\n{\r\nreturn mips_ejtag_fdc_console_init(&mips_ejtag_fdc_con);\r\n}\r\nint __init setup_early_fdc_console(void)\r\n{\r\nreturn mips_ejtag_fdc_console_init(&mips_ejtag_fdc_earlycon);\r\n}\r\nstatic void __iomem *kgdbfdc_setup(void)\r\n{\r\nvoid __iomem *regs;\r\nunsigned int cpu;\r\ncpu = smp_processor_id();\r\nregs = mips_ejtag_fdc_con.regs[cpu];\r\nif (!regs) {\r\nregs = mips_cdmm_early_probe(0xfd);\r\nmips_ejtag_fdc_con.regs[cpu] = regs;\r\n}\r\nif (IS_ERR(regs))\r\nreturn regs;\r\nreturn regs;\r\n}\r\nstatic int kgdbfdc_read_char(void)\r\n{\r\nunsigned int stat, channel, data;\r\nvoid __iomem *regs;\r\nif (kgdbfdc_rpos >= kgdbfdc_rbuflen) {\r\nkgdbfdc_rpos = 0;\r\nkgdbfdc_rbuflen = 0;\r\nregs = kgdbfdc_setup();\r\nif (IS_ERR(regs))\r\nreturn NO_POLL_CHAR;\r\ndo {\r\nstat = __raw_readl(regs + REG_FDSTAT);\r\nif (stat & REG_FDSTAT_RXE)\r\nreturn NO_POLL_CHAR;\r\nchannel = (stat & REG_FDSTAT_RXCHAN) >>\r\nREG_FDSTAT_RXCHAN_SHIFT;\r\ndata = __raw_readl(regs + REG_FDRX);\r\n} while (channel != CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN);\r\nkgdbfdc_rbuflen = mips_ejtag_fdc_decode(data, kgdbfdc_rbuf);\r\n}\r\npr_devel("kgdbfdc r %c\n", kgdbfdc_rbuf[kgdbfdc_rpos]);\r\nreturn kgdbfdc_rbuf[kgdbfdc_rpos++];\r\n}\r\nstatic void kgdbfdc_push_one(void)\r\n{\r\nconst char *bufs[1] = { kgdbfdc_wbuf };\r\nstruct fdc_word word;\r\nvoid __iomem *regs;\r\nunsigned int i;\r\nword = mips_ejtag_fdc_encode(bufs, &kgdbfdc_wbuflen, 1);\r\nkgdbfdc_wbuflen -= word.bytes;\r\nfor (i = 0; i < kgdbfdc_wbuflen; ++i)\r\nkgdbfdc_wbuf[i] = kgdbfdc_wbuf[i + word.bytes];\r\nregs = kgdbfdc_setup();\r\nif (IS_ERR(regs))\r\nreturn;\r\nwhile (__raw_readl(regs + REG_FDSTAT) & REG_FDSTAT_TXF)\r\n;\r\n__raw_writel(word.word,\r\nregs + REG_FDTX(CONFIG_MIPS_EJTAG_FDC_KGDB_CHAN));\r\n}\r\nstatic void kgdbfdc_flush(void)\r\n{\r\nwhile (kgdbfdc_wbuflen)\r\nkgdbfdc_push_one();\r\n}\r\nstatic void kgdbfdc_write_char(u8 chr)\r\n{\r\npr_devel("kgdbfdc w %c\n", chr);\r\nkgdbfdc_wbuf[kgdbfdc_wbuflen++] = chr;\r\nif (kgdbfdc_wbuflen >= sizeof(kgdbfdc_wbuf))\r\nkgdbfdc_push_one();\r\n}\r\nstatic int __init kgdbfdc_init(void)\r\n{\r\nkgdb_register_io_module(&kgdbfdc_io_ops);\r\nreturn 0;\r\n}
