struct macio_chip *macio_find(struct device_node *child, int type)\r\n{\r\nwhile(child) {\r\nint i;\r\nfor (i=0; i < MAX_MACIO_CHIPS && macio_chips[i].of_node; i++)\r\nif (child == macio_chips[i].of_node &&\r\n(!type || macio_chips[i].type == type))\r\nreturn &macio_chips[i];\r\nchild = child->parent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int simple_feature_tweak(struct device_node *node, int type,\r\nint reg, u32 mask, int value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nmacio = macio_find(node, type);\r\nif (!macio)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value)\r\nMACIO_BIS(reg, mask);\r\nelse\r\nMACIO_BIC(reg, mask);\r\n(void)MACIO_IN32(reg);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long ohare_htw_scc_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long chan_mask;\r\nunsigned long fcr;\r\nunsigned long flags;\r\nint htw, trans;\r\nunsigned long rmask;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (!strcmp(node->name, "ch-a"))\r\nchan_mask = MACIO_FLAG_SCCA_ON;\r\nelse if (!strcmp(node->name, "ch-b"))\r\nchan_mask = MACIO_FLAG_SCCB_ON;\r\nelse\r\nreturn -ENODEV;\r\nhtw = (macio->type == macio_heathrow || macio->type == macio_paddington\r\n|| macio->type == macio_gatwick);\r\ntrans = (pmac_mb.model_id != PMAC_TYPE_YOSEMITE &&\r\npmac_mb.model_id != PMAC_TYPE_YIKES);\r\nif (value) {\r\n#ifdef CONFIG_ADB_PMU\r\nif ((param & 0xfff) == PMAC_SCC_IRDA)\r\npmu_enable_irled(1);\r\n#endif\r\nLOCK(flags);\r\nfcr = MACIO_IN32(OHARE_FCR);\r\nif (!(fcr & OH_SCC_ENABLE)) {\r\nfcr |= OH_SCC_ENABLE;\r\nif (htw) {\r\nif (trans)\r\nfcr &= ~HRW_SCC_TRANS_EN_N;\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\nfcr |= (rmask = HRW_RESET_SCC);\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\n} else {\r\nfcr |= (rmask = OH_SCC_RESET);\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\n}\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(OHARE_FCR);\r\nmdelay(15);\r\nLOCK(flags);\r\nfcr &= ~rmask;\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\n}\r\nif (chan_mask & MACIO_FLAG_SCCA_ON)\r\nfcr |= OH_SCCA_IO;\r\nif (chan_mask & MACIO_FLAG_SCCB_ON)\r\nfcr |= OH_SCCB_IO;\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\nmacio->flags |= chan_mask;\r\nUNLOCK(flags);\r\nif (param & PMAC_SCC_FLAG_XMON)\r\nmacio->flags |= MACIO_FLAG_SCC_LOCKED;\r\n} else {\r\nif (macio->flags & MACIO_FLAG_SCC_LOCKED)\r\nreturn -EPERM;\r\nLOCK(flags);\r\nfcr = MACIO_IN32(OHARE_FCR);\r\nif (chan_mask & MACIO_FLAG_SCCA_ON)\r\nfcr &= ~OH_SCCA_IO;\r\nif (chan_mask & MACIO_FLAG_SCCB_ON)\r\nfcr &= ~OH_SCCB_IO;\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\nif ((fcr & (OH_SCCA_IO | OH_SCCB_IO)) == 0) {\r\nfcr &= ~OH_SCC_ENABLE;\r\nif (htw && trans)\r\nfcr |= HRW_SCC_TRANS_EN_N;\r\nMACIO_OUT32(OHARE_FCR, fcr);\r\n}\r\nmacio->flags &= ~(chan_mask);\r\nUNLOCK(flags);\r\nmdelay(10);\r\n#ifdef CONFIG_ADB_PMU\r\nif ((param & 0xfff) == PMAC_SCC_IRDA)\r\npmu_enable_irled(0);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic long ohare_floppy_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_FLOPPY_ENABLE, value);\r\n}\r\nstatic long ohare_mesh_enable(struct device_node *node, long param, long value)\r\n{\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_MESH_ENABLE, value);\r\n}\r\nstatic long ohare_ide_enable(struct device_node *node, long param, long value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nif (value)\r\nsimple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_IOBUS_ENABLE, 1);\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_IDE0_ENABLE, value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_BAY_IDE_ENABLE, value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long ohare_ide_reset(struct device_node *node, long param, long value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_IDE0_RESET_N, !value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_ohare,\r\nOHARE_FCR, OH_IDE1_RESET_N, !value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long ohare_sleep_state(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio = &macio_chips[0];\r\nif ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)\r\nreturn -EPERM;\r\nif (value == 1) {\r\nMACIO_BIC(OHARE_FCR, OH_IOBUS_ENABLE);\r\n} else if (value == 0) {\r\nMACIO_BIS(OHARE_FCR, OH_IOBUS_ENABLE);\r\n}\r\nreturn 0;\r\n}\r\nstatic long heathrow_modem_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nstruct macio_chip* macio;\r\nu8 gpio;\r\nunsigned long flags;\r\nmacio = macio_find(node, macio_unknown);\r\nif (!macio)\r\nreturn -ENODEV;\r\ngpio = MACIO_IN8(HRW_GPIO_MODEM_RESET) & ~1;\r\nif (!value) {\r\nLOCK(flags);\r\nMACIO_OUT8(HRW_GPIO_MODEM_RESET, gpio);\r\nUNLOCK(flags);\r\n(void)MACIO_IN8(HRW_GPIO_MODEM_RESET);\r\nmdelay(250);\r\n}\r\nif (pmac_mb.model_id != PMAC_TYPE_YOSEMITE &&\r\npmac_mb.model_id != PMAC_TYPE_YIKES) {\r\nLOCK(flags);\r\nif (value)\r\nMACIO_BIC(HEATHROW_FCR, HRW_SCC_TRANS_EN_N);\r\nelse\r\nMACIO_BIS(HEATHROW_FCR, HRW_SCC_TRANS_EN_N);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\nmdelay(250);\r\n}\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_OUT8(HRW_GPIO_MODEM_RESET, gpio | 1);\r\n(void)MACIO_IN8(HRW_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(HRW_GPIO_MODEM_RESET, gpio);\r\n(void)MACIO_IN8(HRW_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(HRW_GPIO_MODEM_RESET, gpio | 1);\r\n(void)MACIO_IN8(HRW_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250);\r\n}\r\nreturn 0;\r\n}\r\nstatic long heathrow_floppy_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nHEATHROW_FCR,\r\nHRW_SWIM_ENABLE|HRW_BAY_FLOPPY_ENABLE,\r\nvalue);\r\n}\r\nstatic long heathrow_mesh_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nmacio = macio_find(node, macio_unknown);\r\nif (!macio)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value)\r\nMACIO_BIS(HEATHROW_FCR, HRW_MESH_ENABLE);\r\nelse\r\nMACIO_BIC(HEATHROW_FCR, HRW_MESH_ENABLE);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\nudelay(10);\r\nif (value)\r\nMACIO_BIC(HEATHROW_MBCR, 0x04000000);\r\nelse\r\nMACIO_BIS(HEATHROW_MBCR, 0x04000000);\r\n(void)MACIO_IN32(HEATHROW_MBCR);\r\nudelay(10);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long heathrow_ide_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nHEATHROW_FCR, HRW_IDE0_ENABLE, value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nHEATHROW_FCR, HRW_BAY_IDE_ENABLE, value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long heathrow_ide_reset(struct device_node *node, long param,\r\nlong value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nHEATHROW_FCR, HRW_IDE0_RESET_N, !value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nHEATHROW_FCR, HRW_IDE1_RESET_N, !value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long heathrow_bmac_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_BIS(HEATHROW_FCR, HRW_BMAC_IO_ENABLE);\r\nMACIO_BIS(HEATHROW_FCR, HRW_BMAC_RESET);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\nmdelay(10);\r\nLOCK(flags);\r\nMACIO_BIC(HEATHROW_FCR, HRW_BMAC_RESET);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\nmdelay(10);\r\n} else {\r\nLOCK(flags);\r\nMACIO_BIC(HEATHROW_FCR, HRW_BMAC_IO_ENABLE);\r\nUNLOCK(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic long heathrow_sound_enable(struct device_node *node, long param,\r\nlong value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nif (pmac_mb.model_id == PMAC_TYPE_YOSEMITE ||\r\npmac_mb.model_id == PMAC_TYPE_YIKES)\r\nreturn 0;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_BIS(HEATHROW_FCR, HRW_SOUND_CLK_ENABLE);\r\nMACIO_BIC(HEATHROW_FCR, HRW_SOUND_POWER_N);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\n} else {\r\nLOCK(flags);\r\nMACIO_BIS(HEATHROW_FCR, HRW_SOUND_POWER_N);\r\nMACIO_BIC(HEATHROW_FCR, HRW_SOUND_CLK_ENABLE);\r\nUNLOCK(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dbdma_save(struct macio_chip *macio, struct dbdma_regs *save)\r\n{\r\nint i;\r\nfor (i = 0; i < 13; i++) {\r\nvolatile struct dbdma_regs __iomem * chan = (void __iomem *)\r\n(macio->base + ((0x8000+i*0x100)>>2));\r\nsave[i].cmdptr_hi = in_le32(&chan->cmdptr_hi);\r\nsave[i].cmdptr = in_le32(&chan->cmdptr);\r\nsave[i].intr_sel = in_le32(&chan->intr_sel);\r\nsave[i].br_sel = in_le32(&chan->br_sel);\r\nsave[i].wait_sel = in_le32(&chan->wait_sel);\r\n}\r\n}\r\nstatic void dbdma_restore(struct macio_chip *macio, struct dbdma_regs *save)\r\n{\r\nint i;\r\nfor (i = 0; i < 13; i++) {\r\nvolatile struct dbdma_regs __iomem * chan = (void __iomem *)\r\n(macio->base + ((0x8000+i*0x100)>>2));\r\nout_le32(&chan->control, (ACTIVE|DEAD|WAKE|FLUSH|PAUSE|RUN)<<16);\r\nwhile (in_le32(&chan->status) & ACTIVE)\r\nmb();\r\nout_le32(&chan->cmdptr_hi, save[i].cmdptr_hi);\r\nout_le32(&chan->cmdptr, save[i].cmdptr);\r\nout_le32(&chan->intr_sel, save[i].intr_sel);\r\nout_le32(&chan->br_sel, save[i].br_sel);\r\nout_le32(&chan->wait_sel, save[i].wait_sel);\r\n}\r\n}\r\nstatic void heathrow_sleep(struct macio_chip *macio, int secondary)\r\n{\r\nif (secondary) {\r\ndbdma_save(macio, save_alt_dbdma);\r\nsave_fcr[2] = MACIO_IN32(0x38);\r\nsave_fcr[3] = MACIO_IN32(0x3c);\r\n} else {\r\ndbdma_save(macio, save_dbdma);\r\nsave_fcr[0] = MACIO_IN32(0x38);\r\nsave_fcr[1] = MACIO_IN32(0x3c);\r\nsave_mbcr = MACIO_IN32(0x34);\r\nMACIO_BIS(HEATHROW_FCR, HRW_SOUND_POWER_N);\r\nMACIO_BIC(HEATHROW_FCR, HRW_SOUND_CLK_ENABLE);\r\nMACIO_BIC(HEATHROW_FCR, HRW_IOBUS_ENABLE);\r\nMACIO_BIC(HEATHROW_FCR, HRW_IDE0_RESET_N);\r\nMACIO_BIC(HEATHROW_FCR, HRW_BMAC_IO_ENABLE | HRW_BMAC_RESET);\r\n}\r\nMACIO_OUT8(HRW_GPIO_MODEM_RESET,\r\nMACIO_IN8(HRW_GPIO_MODEM_RESET) & ~1);\r\nMACIO_BIS(HEATHROW_FCR, HRW_SCC_TRANS_EN_N);\r\nMACIO_BIC(HEATHROW_FCR, OH_SCCA_IO|OH_SCCB_IO|HRW_SCC_ENABLE);\r\n(void)MACIO_IN32(HEATHROW_FCR);\r\n}\r\nstatic void heathrow_wakeup(struct macio_chip *macio, int secondary)\r\n{\r\nif (secondary) {\r\nMACIO_OUT32(0x38, save_fcr[2]);\r\n(void)MACIO_IN32(0x38);\r\nmdelay(1);\r\nMACIO_OUT32(0x3c, save_fcr[3]);\r\n(void)MACIO_IN32(0x38);\r\nmdelay(10);\r\ndbdma_restore(macio, save_alt_dbdma);\r\n} else {\r\nMACIO_OUT32(0x38, save_fcr[0] | HRW_IOBUS_ENABLE);\r\n(void)MACIO_IN32(0x38);\r\nmdelay(1);\r\nMACIO_OUT32(0x3c, save_fcr[1]);\r\n(void)MACIO_IN32(0x38);\r\nmdelay(1);\r\nMACIO_OUT32(0x34, save_mbcr);\r\n(void)MACIO_IN32(0x38);\r\nmdelay(10);\r\ndbdma_restore(macio, save_dbdma);\r\n}\r\n}\r\nstatic long heathrow_sleep_state(struct device_node *node, long param,\r\nlong value)\r\n{\r\nif ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)\r\nreturn -EPERM;\r\nif (value == 1) {\r\nif (macio_chips[1].type == macio_gatwick)\r\nheathrow_sleep(&macio_chips[0], 1);\r\nheathrow_sleep(&macio_chips[0], 0);\r\n} else if (value == 0) {\r\nheathrow_wakeup(&macio_chips[0], 0);\r\nif (macio_chips[1].type == macio_gatwick)\r\nheathrow_wakeup(&macio_chips[0], 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic long core99_scc_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nunsigned long chan_mask;\r\nu32 fcr;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (!strcmp(node->name, "ch-a"))\r\nchan_mask = MACIO_FLAG_SCCA_ON;\r\nelse if (!strcmp(node->name, "ch-b"))\r\nchan_mask = MACIO_FLAG_SCCB_ON;\r\nelse\r\nreturn -ENODEV;\r\nif (value) {\r\nint need_reset_scc = 0;\r\nint need_reset_irda = 0;\r\nLOCK(flags);\r\nfcr = MACIO_IN32(KEYLARGO_FCR0);\r\nif (!(fcr & KL0_SCC_CELL_ENABLE)) {\r\nfcr |= KL0_SCC_CELL_ENABLE;\r\nneed_reset_scc = 1;\r\n}\r\nif (chan_mask & MACIO_FLAG_SCCA_ON) {\r\nfcr |= KL0_SCCA_ENABLE;\r\nif ((param & 0xfff) == PMAC_SCC_I2S1)\r\nfcr &= ~KL0_SCC_A_INTF_ENABLE;\r\nelse\r\nfcr |= KL0_SCC_A_INTF_ENABLE;\r\n}\r\nif (chan_mask & MACIO_FLAG_SCCB_ON) {\r\nfcr |= KL0_SCCB_ENABLE;\r\nif ((param & 0xfff) == PMAC_SCC_IRDA) {\r\nfcr &= ~KL0_SCC_B_INTF_ENABLE;\r\nfcr |= KL0_IRDA_ENABLE;\r\nfcr |= KL0_IRDA_CLK32_ENABLE | KL0_IRDA_CLK19_ENABLE;\r\nfcr |= KL0_IRDA_SOURCE1_SEL;\r\nfcr &= ~(KL0_IRDA_FAST_CONNECT|KL0_IRDA_DEFAULT1|KL0_IRDA_DEFAULT0);\r\nfcr &= ~(KL0_IRDA_SOURCE2_SEL|KL0_IRDA_HIGH_BAND);\r\nneed_reset_irda = 1;\r\n} else\r\nfcr |= KL0_SCC_B_INTF_ENABLE;\r\n}\r\nMACIO_OUT32(KEYLARGO_FCR0, fcr);\r\nmacio->flags |= chan_mask;\r\nif (need_reset_scc) {\r\nMACIO_BIS(KEYLARGO_FCR0, KL0_SCC_RESET);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nUNLOCK(flags);\r\nmdelay(15);\r\nLOCK(flags);\r\nMACIO_BIC(KEYLARGO_FCR0, KL0_SCC_RESET);\r\n}\r\nif (need_reset_irda) {\r\nMACIO_BIS(KEYLARGO_FCR0, KL0_IRDA_RESET);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nUNLOCK(flags);\r\nmdelay(15);\r\nLOCK(flags);\r\nMACIO_BIC(KEYLARGO_FCR0, KL0_IRDA_RESET);\r\n}\r\nUNLOCK(flags);\r\nif (param & PMAC_SCC_FLAG_XMON)\r\nmacio->flags |= MACIO_FLAG_SCC_LOCKED;\r\n} else {\r\nif (macio->flags & MACIO_FLAG_SCC_LOCKED)\r\nreturn -EPERM;\r\nLOCK(flags);\r\nfcr = MACIO_IN32(KEYLARGO_FCR0);\r\nif (chan_mask & MACIO_FLAG_SCCA_ON)\r\nfcr &= ~KL0_SCCA_ENABLE;\r\nif (chan_mask & MACIO_FLAG_SCCB_ON) {\r\nfcr &= ~KL0_SCCB_ENABLE;\r\nif ((param & 0xfff) == PMAC_SCC_IRDA) {\r\nfcr &= ~KL0_IRDA_ENABLE;\r\nfcr &= ~(KL0_IRDA_CLK32_ENABLE | KL0_IRDA_CLK19_ENABLE);\r\nfcr &= ~(KL0_IRDA_FAST_CONNECT|KL0_IRDA_DEFAULT1|KL0_IRDA_DEFAULT0);\r\nfcr &= ~(KL0_IRDA_SOURCE1_SEL|KL0_IRDA_SOURCE2_SEL|KL0_IRDA_HIGH_BAND);\r\n}\r\n}\r\nMACIO_OUT32(KEYLARGO_FCR0, fcr);\r\nif ((fcr & (KL0_SCCA_ENABLE | KL0_SCCB_ENABLE)) == 0) {\r\nfcr &= ~KL0_SCC_CELL_ENABLE;\r\nMACIO_OUT32(KEYLARGO_FCR0, fcr);\r\n}\r\nmacio->flags &= ~(chan_mask);\r\nUNLOCK(flags);\r\nmdelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_modem_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio;\r\nu8 gpio;\r\nunsigned long flags;\r\nif (node == NULL) {\r\nif (macio_chips[0].type != macio_keylargo)\r\nreturn -ENODEV;\r\nnode = macio_chips[0].of_node;\r\n}\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\ngpio = MACIO_IN8(KL_GPIO_MODEM_RESET);\r\ngpio |= KEYLARGO_GPIO_OUTPUT_ENABLE;\r\ngpio &= ~KEYLARGO_GPIO_OUTOUT_DATA;\r\nif (!value) {\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio);\r\nUNLOCK(flags);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nmdelay(250);\r\n}\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_BIC(KEYLARGO_FCR2, KL2_ALT_DATA_OUT);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(KEYLARGO_FCR2);\r\nmdelay(250);\r\n} else {\r\nMACIO_BIS(KEYLARGO_FCR2, KL2_ALT_DATA_OUT);\r\nUNLOCK(flags);\r\n}\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio | KEYLARGO_GPIO_OUTOUT_DATA);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio | KEYLARGO_GPIO_OUTOUT_DATA);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250);\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\npangea_modem_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio;\r\nu8 gpio;\r\nunsigned long flags;\r\nif (node == NULL) {\r\nif (macio_chips[0].type != macio_pangea &&\r\nmacio_chips[0].type != macio_intrepid)\r\nreturn -ENODEV;\r\nnode = macio_chips[0].of_node;\r\n}\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\ngpio = MACIO_IN8(KL_GPIO_MODEM_RESET);\r\ngpio |= KEYLARGO_GPIO_OUTPUT_ENABLE;\r\ngpio &= ~KEYLARGO_GPIO_OUTOUT_DATA;\r\nif (!value) {\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio);\r\nUNLOCK(flags);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nmdelay(250);\r\n}\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_OUT8(KL_GPIO_MODEM_POWER,\r\nKEYLARGO_GPIO_OUTPUT_ENABLE);\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(KEYLARGO_FCR2);\r\nmdelay(250);\r\n} else {\r\nMACIO_OUT8(KL_GPIO_MODEM_POWER,\r\nKEYLARGO_GPIO_OUTPUT_ENABLE | KEYLARGO_GPIO_OUTOUT_DATA);\r\nUNLOCK(flags);\r\n}\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio | KEYLARGO_GPIO_OUTOUT_DATA);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250); LOCK(flags);\r\nMACIO_OUT8(KL_GPIO_MODEM_RESET, gpio | KEYLARGO_GPIO_OUTOUT_DATA);\r\n(void)MACIO_IN8(KL_GPIO_MODEM_RESET);\r\nUNLOCK(flags); mdelay(250);\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_ata100_enable(struct device_node *node, long value)\r\n{\r\nunsigned long flags;\r\nstruct pci_dev *pdev = NULL;\r\nu8 pbus, pid;\r\nint rc;\r\nif (uninorth_rev < 0x24)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value)\r\nUN_BIS(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_ATA100);\r\nelse\r\nUN_BIC(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_ATA100);\r\n(void)UN_IN(UNI_N_CLOCK_CNTL);\r\nUNLOCK(flags);\r\nudelay(20);\r\nif (value) {\r\nif (pci_device_from_OF_node(node, &pbus, &pid) == 0)\r\npdev = pci_get_bus_and_slot(pbus, pid);\r\nif (pdev == NULL)\r\nreturn 0;\r\nrc = pci_enable_device(pdev);\r\nif (rc == 0)\r\npci_set_master(pdev);\r\npci_dev_put(pdev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_ide_enable(struct device_node *node, long param, long value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_EIDE0_ENABLE, value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_EIDE1_ENABLE, value);\r\ncase 2:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_UIDE_ENABLE, value);\r\ncase 3:\r\nreturn core99_ata100_enable(node, value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long\r\ncore99_ide_reset(struct device_node *node, long param, long value)\r\n{\r\nswitch(param) {\r\ncase 0:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_EIDE0_RESET_N, !value);\r\ncase 1:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_EIDE1_RESET_N, !value);\r\ncase 2:\r\nreturn simple_feature_tweak(node, macio_unknown,\r\nKEYLARGO_FCR1, KL1_UIDE_RESET_N, !value);\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic long\r\ncore99_gmac_enable(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nLOCK(flags);\r\nif (value)\r\nUN_BIS(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_GMAC);\r\nelse\r\nUN_BIC(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_GMAC);\r\n(void)UN_IN(UNI_N_CLOCK_CNTL);\r\nUNLOCK(flags);\r\nudelay(20);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_gmac_phy_reset(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nstruct macio_chip *macio;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_ETH_PHY_RESET, KEYLARGO_GPIO_OUTPUT_ENABLE);\r\n(void)MACIO_IN8(KL_GPIO_ETH_PHY_RESET);\r\nUNLOCK(flags);\r\nmdelay(10);\r\nLOCK(flags);\r\nMACIO_OUT8(KL_GPIO_ETH_PHY_RESET,\r\nKEYLARGO_GPIO_OUTOUT_DATA);\r\nUNLOCK(flags);\r\nmdelay(10);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_sound_chip_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (pmac_mb.model_id == PMAC_TYPE_PISMO ||\r\npmac_mb.model_id == PMAC_TYPE_TITANIUM) {\r\nLOCK(flags);\r\nif (value)\r\nMACIO_OUT8(KL_GPIO_SOUND_POWER,\r\nKEYLARGO_GPIO_OUTPUT_ENABLE |\r\nKEYLARGO_GPIO_OUTOUT_DATA);\r\nelse\r\nMACIO_OUT8(KL_GPIO_SOUND_POWER,\r\nKEYLARGO_GPIO_OUTPUT_ENABLE);\r\n(void)MACIO_IN8(KL_GPIO_SOUND_POWER);\r\nUNLOCK(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_airport_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip* macio;\r\nunsigned long flags;\r\nint state;\r\nmacio = macio_find(node, 0);\r\nif (!macio)\r\nreturn -ENODEV;\r\nif (node != macio->of_node &&\r\n(!node->parent || node->parent != macio->of_node))\r\nreturn -ENODEV;\r\nstate = (macio->flags & MACIO_FLAG_AIRPORT_ON) != 0;\r\nif (value == state)\r\nreturn 0;\r\nif (value) {\r\nLOCK(flags);\r\nMACIO_OUT8(KEYLARGO_GPIO_0+0xf, 5);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_0+0xf);\r\nUNLOCK(flags);\r\nmdelay(10);\r\nLOCK(flags);\r\nMACIO_OUT8(KEYLARGO_GPIO_0+0xf, 4);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_0+0xf);\r\nUNLOCK(flags);\r\nmdelay(10);\r\nLOCK(flags);\r\nMACIO_BIC(KEYLARGO_FCR2, KL2_CARDSEL_16);\r\n(void)MACIO_IN32(KEYLARGO_FCR2);\r\nudelay(10);\r\nMACIO_OUT8(KEYLARGO_GPIO_EXTINT_0+0xb, 0);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_EXTINT_0+0xb);\r\nudelay(10);\r\nMACIO_OUT8(KEYLARGO_GPIO_EXTINT_0+0xa, 0x28);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_EXTINT_0+0xa);\r\nudelay(10);\r\nMACIO_OUT8(KEYLARGO_GPIO_EXTINT_0+0xd, 0x28);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_EXTINT_0+0xd);\r\nudelay(10);\r\nMACIO_OUT8(KEYLARGO_GPIO_0+0xd, 0x28);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_0+0xd);\r\nudelay(10);\r\nMACIO_OUT8(KEYLARGO_GPIO_0+0xe, 0x28);\r\n(void)MACIO_IN8(KEYLARGO_GPIO_0+0xe);\r\nUNLOCK(flags);\r\nudelay(10);\r\nMACIO_OUT32(0x1c000, 0);\r\nmdelay(1);\r\nMACIO_OUT8(0x1a3e0, 0x41);\r\n(void)MACIO_IN8(0x1a3e0);\r\nudelay(10);\r\nLOCK(flags);\r\nMACIO_BIS(KEYLARGO_FCR2, KL2_CARDSEL_16);\r\n(void)MACIO_IN32(KEYLARGO_FCR2);\r\nUNLOCK(flags);\r\nmdelay(100);\r\nmacio->flags |= MACIO_FLAG_AIRPORT_ON;\r\n} else {\r\nLOCK(flags);\r\nMACIO_BIC(KEYLARGO_FCR2, KL2_CARDSEL_16);\r\n(void)MACIO_IN32(KEYLARGO_FCR2);\r\nMACIO_OUT8(KL_GPIO_AIRPORT_0, 0);\r\nMACIO_OUT8(KL_GPIO_AIRPORT_1, 0);\r\nMACIO_OUT8(KL_GPIO_AIRPORT_2, 0);\r\nMACIO_OUT8(KL_GPIO_AIRPORT_3, 0);\r\nMACIO_OUT8(KL_GPIO_AIRPORT_4, 0);\r\n(void)MACIO_IN8(KL_GPIO_AIRPORT_4);\r\nUNLOCK(flags);\r\nmacio->flags &= ~MACIO_FLAG_AIRPORT_ON;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_reset_cpu(struct device_node *node, long param, long value)\r\n{\r\nunsigned int reset_io = 0;\r\nunsigned long flags;\r\nstruct macio_chip *macio;\r\nstruct device_node *np;\r\nstruct device_node *cpus;\r\nconst int dflt_reset_lines[] = { KL_GPIO_RESET_CPU0,\r\nKL_GPIO_RESET_CPU1,\r\nKL_GPIO_RESET_CPU2,\r\nKL_GPIO_RESET_CPU3 };\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo)\r\nreturn -ENODEV;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (cpus == NULL)\r\nreturn -ENODEV;\r\nfor (np = cpus->child; np != NULL; np = np->sibling) {\r\nconst u32 *num = of_get_property(np, "reg", NULL);\r\nconst u32 *rst = of_get_property(np, "soft-reset", NULL);\r\nif (num == NULL || rst == NULL)\r\ncontinue;\r\nif (param == *num) {\r\nreset_io = *rst;\r\nbreak;\r\n}\r\n}\r\nof_node_put(cpus);\r\nif (np == NULL || reset_io == 0)\r\nreset_io = dflt_reset_lines[param];\r\nLOCK(flags);\r\nMACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTPUT_ENABLE);\r\n(void)MACIO_IN8(reset_io);\r\nudelay(1);\r\nMACIO_OUT8(reset_io, 0);\r\n(void)MACIO_IN8(reset_io);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_usb_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio;\r\nunsigned long flags;\r\nconst char *prop;\r\nint number;\r\nu32 reg;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nprop = of_get_property(node, "AAPL,clock-id", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\nif (strncmp(prop, "usb0u048", 8) == 0)\r\nnumber = 0;\r\nelse if (strncmp(prop, "usb1u148", 8) == 0)\r\nnumber = 2;\r\nelse if (strncmp(prop, "usb2u248", 8) == 0)\r\nnumber = 4;\r\nelse\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value) {\r\nif (number == 0) {\r\nMACIO_BIC(KEYLARGO_FCR0, (KL0_USB0_PAD_SUSPEND0 | KL0_USB0_PAD_SUSPEND1));\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nUNLOCK(flags);\r\nmdelay(1);\r\nLOCK(flags);\r\nMACIO_BIS(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);\r\n} else if (number == 2) {\r\nMACIO_BIC(KEYLARGO_FCR0, (KL0_USB1_PAD_SUSPEND0 | KL0_USB1_PAD_SUSPEND1));\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nmdelay(1);\r\nLOCK(flags);\r\nMACIO_BIS(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);\r\n} else if (number == 4) {\r\nMACIO_BIC(KEYLARGO_FCR1, (KL1_USB2_PAD_SUSPEND0 | KL1_USB2_PAD_SUSPEND1));\r\nUNLOCK(flags);\r\n(void)MACIO_IN32(KEYLARGO_FCR1);\r\nmdelay(1);\r\nLOCK(flags);\r\nMACIO_BIS(KEYLARGO_FCR1, KL1_USB2_CELL_ENABLE);\r\n}\r\nif (number < 4) {\r\nreg = MACIO_IN32(KEYLARGO_FCR4);\r\nreg &= ~(KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |\r\nKL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number));\r\nreg &= ~(KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |\r\nKL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1));\r\nMACIO_OUT32(KEYLARGO_FCR4, reg);\r\n(void)MACIO_IN32(KEYLARGO_FCR4);\r\nudelay(10);\r\n} else {\r\nreg = MACIO_IN32(KEYLARGO_FCR3);\r\nreg &= ~(KL3_IT_PORT_WAKEUP_ENABLE(0) | KL3_IT_PORT_RESUME_WAKE_EN(0) |\r\nKL3_IT_PORT_CONNECT_WAKE_EN(0) | KL3_IT_PORT_DISCONNECT_WAKE_EN(0));\r\nreg &= ~(KL3_IT_PORT_WAKEUP_ENABLE(1) | KL3_IT_PORT_RESUME_WAKE_EN(1) |\r\nKL3_IT_PORT_CONNECT_WAKE_EN(1) | KL3_IT_PORT_DISCONNECT_WAKE_EN(1));\r\nMACIO_OUT32(KEYLARGO_FCR3, reg);\r\n(void)MACIO_IN32(KEYLARGO_FCR3);\r\nudelay(10);\r\n}\r\nif (macio->type == macio_intrepid) {\r\nu32 test0 = 0, test1 = 0;\r\nu32 status0, status1;\r\nint timeout = 1000;\r\nUNLOCK(flags);\r\nswitch (number) {\r\ncase 0:\r\ntest0 = UNI_N_CLOCK_STOPPED_USB0;\r\ntest1 = UNI_N_CLOCK_STOPPED_USB0PCI;\r\nbreak;\r\ncase 2:\r\ntest0 = UNI_N_CLOCK_STOPPED_USB1;\r\ntest1 = UNI_N_CLOCK_STOPPED_USB1PCI;\r\nbreak;\r\ncase 4:\r\ntest0 = UNI_N_CLOCK_STOPPED_USB2;\r\ntest1 = UNI_N_CLOCK_STOPPED_USB2PCI;\r\nbreak;\r\n}\r\ndo {\r\nif (--timeout <= 0) {\r\nprintk(KERN_ERR "core99_usb_enable: "\r\n"Timeout waiting for clocks\n");\r\nbreak;\r\n}\r\nmdelay(1);\r\nstatus0 = UN_IN(UNI_N_CLOCK_STOP_STATUS0);\r\nstatus1 = UN_IN(UNI_N_CLOCK_STOP_STATUS1);\r\n} while ((status0 & test0) | (status1 & test1));\r\nLOCK(flags);\r\n}\r\n} else {\r\nif (number < 4) {\r\nreg = MACIO_IN32(KEYLARGO_FCR4);\r\nreg |= KL4_PORT_WAKEUP_ENABLE(number) | KL4_PORT_RESUME_WAKE_EN(number) |\r\nKL4_PORT_CONNECT_WAKE_EN(number) | KL4_PORT_DISCONNECT_WAKE_EN(number);\r\nreg |= KL4_PORT_WAKEUP_ENABLE(number+1) | KL4_PORT_RESUME_WAKE_EN(number+1) |\r\nKL4_PORT_CONNECT_WAKE_EN(number+1) | KL4_PORT_DISCONNECT_WAKE_EN(number+1);\r\nMACIO_OUT32(KEYLARGO_FCR4, reg);\r\n(void)MACIO_IN32(KEYLARGO_FCR4);\r\nudelay(1);\r\n} else {\r\nreg = MACIO_IN32(KEYLARGO_FCR3);\r\nreg |= KL3_IT_PORT_WAKEUP_ENABLE(0) | KL3_IT_PORT_RESUME_WAKE_EN(0) |\r\nKL3_IT_PORT_CONNECT_WAKE_EN(0) | KL3_IT_PORT_DISCONNECT_WAKE_EN(0);\r\nreg |= KL3_IT_PORT_WAKEUP_ENABLE(1) | KL3_IT_PORT_RESUME_WAKE_EN(1) |\r\nKL3_IT_PORT_CONNECT_WAKE_EN(1) | KL3_IT_PORT_DISCONNECT_WAKE_EN(1);\r\nMACIO_OUT32(KEYLARGO_FCR3, reg);\r\n(void)MACIO_IN32(KEYLARGO_FCR3);\r\nudelay(1);\r\n}\r\nif (number == 0) {\r\nif (macio->type != macio_intrepid)\r\nMACIO_BIC(KEYLARGO_FCR0, KL0_USB0_CELL_ENABLE);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nudelay(1);\r\nMACIO_BIS(KEYLARGO_FCR0, (KL0_USB0_PAD_SUSPEND0 | KL0_USB0_PAD_SUSPEND1));\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\n} else if (number == 2) {\r\nif (macio->type != macio_intrepid)\r\nMACIO_BIC(KEYLARGO_FCR0, KL0_USB1_CELL_ENABLE);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nudelay(1);\r\nMACIO_BIS(KEYLARGO_FCR0, (KL0_USB1_PAD_SUSPEND0 | KL0_USB1_PAD_SUSPEND1));\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\n} else if (number == 4) {\r\nudelay(1);\r\nMACIO_BIS(KEYLARGO_FCR1, (KL1_USB2_PAD_SUSPEND0 | KL1_USB2_PAD_SUSPEND1));\r\n(void)MACIO_IN32(KEYLARGO_FCR1);\r\n}\r\nudelay(1);\r\n}\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_firewire_enable(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nstruct macio_chip *macio;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nif (!(macio->flags & MACIO_FLAG_FW_SUPPORTED))\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value) {\r\nUN_BIS(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_FW);\r\n(void)UN_IN(UNI_N_CLOCK_CNTL);\r\n} else {\r\nUN_BIC(UNI_N_CLOCK_CNTL, UNI_N_CLOCK_CNTL_FW);\r\n(void)UN_IN(UNI_N_CLOCK_CNTL);\r\n}\r\nUNLOCK(flags);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_firewire_cable_power(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nstruct macio_chip *macio;\r\nif ((pmac_mb.board_flags & PMAC_MB_HAS_FW_POWER) == 0)\r\nreturn -ENODEV;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nif (!(macio->flags & MACIO_FLAG_FW_SUPPORTED))\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_OUT8(KL_GPIO_FW_CABLE_POWER , 0);\r\nMACIO_IN8(KL_GPIO_FW_CABLE_POWER);\r\nudelay(10);\r\n} else {\r\nMACIO_OUT8(KL_GPIO_FW_CABLE_POWER , 4);\r\nMACIO_IN8(KL_GPIO_FW_CABLE_POWER); udelay(10);\r\n}\r\nUNLOCK(flags);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic long\r\nintrepid_aack_delay_enable(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nif (uninorth_rev < 0xd2)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (param)\r\nUN_BIS(UNI_N_AACK_DELAY, UNI_N_AACK_DELAY_ENABLE);\r\nelse\r\nUN_BIC(UNI_N_AACK_DELAY, UNI_N_AACK_DELAY_ENABLE);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_read_gpio(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nreturn MACIO_IN8(param);\r\n}\r\nstatic long\r\ncore99_write_gpio(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nMACIO_OUT8(param, (u8)(value & 0xff));\r\nreturn 0;\r\n}\r\nstatic long g5_gmac_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nunsigned long flags;\r\nif (node == NULL)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_BIS(KEYLARGO_FCR1, K2_FCR1_GMAC_CLK_ENABLE);\r\nmb();\r\nk2_skiplist[0] = NULL;\r\n} else {\r\nk2_skiplist[0] = node;\r\nmb();\r\nMACIO_BIC(KEYLARGO_FCR1, K2_FCR1_GMAC_CLK_ENABLE);\r\n}\r\nUNLOCK(flags);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic long g5_fw_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nunsigned long flags;\r\nif (node == NULL)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_BIS(KEYLARGO_FCR1, K2_FCR1_FW_CLK_ENABLE);\r\nmb();\r\nk2_skiplist[1] = NULL;\r\n} else {\r\nk2_skiplist[1] = node;\r\nmb();\r\nMACIO_BIC(KEYLARGO_FCR1, K2_FCR1_FW_CLK_ENABLE);\r\n}\r\nUNLOCK(flags);\r\nmdelay(1);\r\nreturn 0;\r\n}\r\nstatic long g5_mpic_enable(struct device_node *node, long param, long value)\r\n{\r\nunsigned long flags;\r\nstruct device_node *parent = of_get_parent(node);\r\nint is_u3;\r\nif (parent == NULL)\r\nreturn 0;\r\nis_u3 = strcmp(parent->name, "u3") == 0 ||\r\nstrcmp(parent->name, "u4") == 0;\r\nof_node_put(parent);\r\nif (!is_u3)\r\nreturn 0;\r\nLOCK(flags);\r\nUN_BIS(U3_TOGGLE_REG, U3_MPIC_RESET | U3_MPIC_OUTPUT_ENABLE);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long g5_eth_phy_reset(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nstruct device_node *phy;\r\nint need_reset;\r\nphy = of_get_next_child(node, NULL);\r\nif (!phy)\r\nreturn -ENODEV;\r\nneed_reset = of_device_is_compatible(phy, "B5221");\r\nof_node_put(phy);\r\nif (!need_reset)\r\nreturn 0;\r\nMACIO_OUT8(K2_GPIO_EXTINT_0 + 29,\r\nKEYLARGO_GPIO_OUTPUT_ENABLE | KEYLARGO_GPIO_OUTOUT_DATA);\r\nmsleep(10);\r\nMACIO_OUT8(K2_GPIO_EXTINT_0 + 29, 0);\r\nreturn 0;\r\n}\r\nstatic long g5_i2s_enable(struct device_node *node, long param, long value)\r\n{\r\nstruct macio_chip *macio = &macio_chips[0];\r\nunsigned long flags;\r\nint cell;\r\nu32 fcrs[3][3] = {\r\n{ 0,\r\nK2_FCR1_I2S0_CELL_ENABLE |\r\nK2_FCR1_I2S0_CLK_ENABLE_BIT | K2_FCR1_I2S0_ENABLE,\r\nKL3_I2S0_CLK18_ENABLE\r\n},\r\n{ KL0_SCC_A_INTF_ENABLE,\r\nK2_FCR1_I2S1_CELL_ENABLE |\r\nK2_FCR1_I2S1_CLK_ENABLE_BIT | K2_FCR1_I2S1_ENABLE,\r\nKL3_I2S1_CLK18_ENABLE\r\n},\r\n{ KL0_SCC_B_INTF_ENABLE,\r\nSH_FCR1_I2S2_CELL_ENABLE |\r\nSH_FCR1_I2S2_CLK_ENABLE_BIT | SH_FCR1_I2S2_ENABLE,\r\nSH_FCR3_I2S2_CLK18_ENABLE\r\n},\r\n};\r\nif (macio->type != macio_keylargo2 && macio->type != macio_shasta)\r\nreturn -ENODEV;\r\nif (strncmp(node->name, "i2s-", 4))\r\nreturn -ENODEV;\r\ncell = node->name[4] - 'a';\r\nswitch(cell) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nif (macio->type == macio_shasta)\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nLOCK(flags);\r\nif (value) {\r\nMACIO_BIC(KEYLARGO_FCR0, fcrs[cell][0]);\r\nMACIO_BIS(KEYLARGO_FCR1, fcrs[cell][1]);\r\nMACIO_BIS(KEYLARGO_FCR3, fcrs[cell][2]);\r\n} else {\r\nMACIO_BIC(KEYLARGO_FCR3, fcrs[cell][2]);\r\nMACIO_BIC(KEYLARGO_FCR1, fcrs[cell][1]);\r\nMACIO_BIS(KEYLARGO_FCR0, fcrs[cell][0]);\r\n}\r\nudelay(10);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nstatic long g5_reset_cpu(struct device_node *node, long param, long value)\r\n{\r\nunsigned int reset_io = 0;\r\nunsigned long flags;\r\nstruct macio_chip *macio;\r\nstruct device_node *np;\r\nstruct device_node *cpus;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo2 && macio->type != macio_shasta)\r\nreturn -ENODEV;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (cpus == NULL)\r\nreturn -ENODEV;\r\nfor (np = cpus->child; np != NULL; np = np->sibling) {\r\nconst u32 *num = of_get_property(np, "reg", NULL);\r\nconst u32 *rst = of_get_property(np, "soft-reset", NULL);\r\nif (num == NULL || rst == NULL)\r\ncontinue;\r\nif (param == *num) {\r\nreset_io = *rst;\r\nbreak;\r\n}\r\n}\r\nof_node_put(cpus);\r\nif (np == NULL || reset_io == 0)\r\nreturn -ENODEV;\r\nLOCK(flags);\r\nMACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTPUT_ENABLE);\r\n(void)MACIO_IN8(reset_io);\r\nudelay(1);\r\nMACIO_OUT8(reset_io, 0);\r\n(void)MACIO_IN8(reset_io);\r\nUNLOCK(flags);\r\nreturn 0;\r\n}\r\nvoid g5_phy_disable_cpu1(void)\r\n{\r\nif (uninorth_maj == 3)\r\nUN_OUT(U3_API_PHY_CONFIG_1, 0);\r\n}\r\nstatic void keylargo_shutdown(struct macio_chip *macio, int sleep_mode)\r\n{\r\nu32 temp;\r\nif (sleep_mode) {\r\nmdelay(1);\r\nMACIO_BIS(KEYLARGO_FCR0, KL0_USB_REF_SUSPEND);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nmdelay(1);\r\n}\r\nMACIO_BIC(KEYLARGO_FCR0,KL0_SCCA_ENABLE | KL0_SCCB_ENABLE |\r\nKL0_SCC_CELL_ENABLE |\r\nKL0_IRDA_ENABLE | KL0_IRDA_CLK32_ENABLE |\r\nKL0_IRDA_CLK19_ENABLE);\r\nMACIO_BIC(KEYLARGO_MBCR, KL_MBCR_MB0_DEV_MASK);\r\nMACIO_BIS(KEYLARGO_MBCR, KL_MBCR_MB0_IDE_ENABLE);\r\nMACIO_BIC(KEYLARGO_FCR1,\r\nKL1_AUDIO_SEL_22MCLK | KL1_AUDIO_CLK_ENABLE_BIT |\r\nKL1_AUDIO_CLK_OUT_ENABLE | KL1_AUDIO_CELL_ENABLE |\r\nKL1_I2S0_CELL_ENABLE | KL1_I2S0_CLK_ENABLE_BIT |\r\nKL1_I2S0_ENABLE | KL1_I2S1_CELL_ENABLE |\r\nKL1_I2S1_CLK_ENABLE_BIT | KL1_I2S1_ENABLE |\r\nKL1_EIDE0_ENABLE | KL1_EIDE0_RESET_N |\r\nKL1_EIDE1_ENABLE | KL1_EIDE1_RESET_N |\r\nKL1_UIDE_ENABLE);\r\nMACIO_BIS(KEYLARGO_FCR2, KL2_ALT_DATA_OUT);\r\nMACIO_BIC(KEYLARGO_FCR2, KL2_IOBUS_ENABLE);\r\ntemp = MACIO_IN32(KEYLARGO_FCR3);\r\nif (macio->rev >= 2) {\r\ntemp |= KL3_SHUTDOWN_PLL2X;\r\nif (sleep_mode)\r\ntemp |= KL3_SHUTDOWN_PLL_TOTAL;\r\n}\r\ntemp |= KL3_SHUTDOWN_PLLKW6 | KL3_SHUTDOWN_PLLKW4 |\r\nKL3_SHUTDOWN_PLLKW35;\r\nif (sleep_mode)\r\ntemp |= KL3_SHUTDOWN_PLLKW12;\r\ntemp &= ~(KL3_CLK66_ENABLE | KL3_CLK49_ENABLE | KL3_CLK45_ENABLE\r\n| KL3_CLK31_ENABLE | KL3_I2S1_CLK18_ENABLE | KL3_I2S0_CLK18_ENABLE);\r\nif (sleep_mode)\r\ntemp &= ~(KL3_TIMER_CLK18_ENABLE | KL3_VIA_CLK16_ENABLE);\r\nMACIO_OUT32(KEYLARGO_FCR3, temp);\r\n(void)MACIO_IN32(KEYLARGO_FCR0); mdelay(1);\r\n}\r\nstatic void pangea_shutdown(struct macio_chip *macio, int sleep_mode)\r\n{\r\nu32 temp;\r\nMACIO_BIC(KEYLARGO_FCR0,KL0_SCCA_ENABLE | KL0_SCCB_ENABLE |\r\nKL0_SCC_CELL_ENABLE |\r\nKL0_USB0_CELL_ENABLE | KL0_USB1_CELL_ENABLE);\r\nMACIO_BIC(KEYLARGO_FCR1,\r\nKL1_AUDIO_SEL_22MCLK | KL1_AUDIO_CLK_ENABLE_BIT |\r\nKL1_AUDIO_CLK_OUT_ENABLE | KL1_AUDIO_CELL_ENABLE |\r\nKL1_I2S0_CELL_ENABLE | KL1_I2S0_CLK_ENABLE_BIT |\r\nKL1_I2S0_ENABLE | KL1_I2S1_CELL_ENABLE |\r\nKL1_I2S1_CLK_ENABLE_BIT | KL1_I2S1_ENABLE |\r\nKL1_UIDE_ENABLE);\r\nif (pmac_mb.board_flags & PMAC_MB_MOBILE)\r\nMACIO_BIC(KEYLARGO_FCR1, KL1_UIDE_RESET_N);\r\nMACIO_BIS(KEYLARGO_FCR2, KL2_ALT_DATA_OUT);\r\ntemp = MACIO_IN32(KEYLARGO_FCR3);\r\ntemp |= KL3_SHUTDOWN_PLLKW6 | KL3_SHUTDOWN_PLLKW4 |\r\nKL3_SHUTDOWN_PLLKW35;\r\ntemp &= ~(KL3_CLK49_ENABLE | KL3_CLK45_ENABLE | KL3_CLK31_ENABLE\r\n| KL3_I2S0_CLK18_ENABLE | KL3_I2S1_CLK18_ENABLE);\r\nif (sleep_mode)\r\ntemp &= ~(KL3_VIA_CLK16_ENABLE | KL3_TIMER_CLK18_ENABLE);\r\nMACIO_OUT32(KEYLARGO_FCR3, temp);\r\n(void)MACIO_IN32(KEYLARGO_FCR0); mdelay(1);\r\n}\r\nstatic void intrepid_shutdown(struct macio_chip *macio, int sleep_mode)\r\n{\r\nu32 temp;\r\nMACIO_BIC(KEYLARGO_FCR0,KL0_SCCA_ENABLE | KL0_SCCB_ENABLE |\r\nKL0_SCC_CELL_ENABLE);\r\nMACIO_BIC(KEYLARGO_FCR1,\r\nKL1_I2S0_CELL_ENABLE | KL1_I2S0_CLK_ENABLE_BIT |\r\nKL1_I2S0_ENABLE | KL1_I2S1_CELL_ENABLE |\r\nKL1_I2S1_CLK_ENABLE_BIT | KL1_I2S1_ENABLE |\r\nKL1_EIDE0_ENABLE);\r\nif (pmac_mb.board_flags & PMAC_MB_MOBILE)\r\nMACIO_BIC(KEYLARGO_FCR1, KL1_UIDE_RESET_N);\r\ntemp = MACIO_IN32(KEYLARGO_FCR3);\r\ntemp &= ~(KL3_CLK49_ENABLE | KL3_CLK45_ENABLE |\r\nKL3_I2S1_CLK18_ENABLE | KL3_I2S0_CLK18_ENABLE);\r\nif (sleep_mode)\r\ntemp &= ~(KL3_TIMER_CLK18_ENABLE | KL3_IT_VIA_CLK32_ENABLE);\r\nMACIO_OUT32(KEYLARGO_FCR3, temp);\r\n(void)MACIO_IN32(KEYLARGO_FCR0);\r\nmdelay(10);\r\n}\r\nstatic int\r\ncore99_sleep(void)\r\n{\r\nstruct macio_chip *macio;\r\nint i;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nif (macio->flags & MACIO_FLAG_AIRPORT_ON)\r\ncore99_airport_enable(macio->of_node, 0, 0);\r\nif (macio->flags & MACIO_FLAG_FW_SUPPORTED) {\r\ncore99_firewire_enable(NULL, 0, 0);\r\ncore99_firewire_cable_power(NULL, 0, 0);\r\n}\r\nif (macio->type == macio_keylargo)\r\ncore99_modem_enable(macio->of_node, 0, 0);\r\nelse\r\npangea_modem_enable(macio->of_node, 0, 0);\r\ncore99_sound_chip_enable(macio->of_node, 0, 0);\r\nsave_gpio_levels[0] = MACIO_IN32(KEYLARGO_GPIO_LEVELS0);\r\nsave_gpio_levels[1] = MACIO_IN32(KEYLARGO_GPIO_LEVELS1);\r\nfor (i=0; i<KEYLARGO_GPIO_EXTINT_CNT; i++)\r\nsave_gpio_extint[i] = MACIO_IN8(KEYLARGO_GPIO_EXTINT_0+i);\r\nfor (i=0; i<KEYLARGO_GPIO_CNT; i++)\r\nsave_gpio_normal[i] = MACIO_IN8(KEYLARGO_GPIO_0+i);\r\nif (macio->type == macio_keylargo)\r\nsave_mbcr = MACIO_IN32(KEYLARGO_MBCR);\r\nsave_fcr[0] = MACIO_IN32(KEYLARGO_FCR0);\r\nsave_fcr[1] = MACIO_IN32(KEYLARGO_FCR1);\r\nsave_fcr[2] = MACIO_IN32(KEYLARGO_FCR2);\r\nsave_fcr[3] = MACIO_IN32(KEYLARGO_FCR3);\r\nsave_fcr[4] = MACIO_IN32(KEYLARGO_FCR4);\r\nif (macio->type == macio_pangea || macio->type == macio_intrepid)\r\nsave_fcr[5] = MACIO_IN32(KEYLARGO_FCR5);\r\ndbdma_save(macio, save_dbdma);\r\nif (macio->type == macio_pangea)\r\npangea_shutdown(macio, 1);\r\nelse if (macio->type == macio_intrepid)\r\nintrepid_shutdown(macio, 1);\r\nelse if (macio->type == macio_keylargo)\r\nkeylargo_shutdown(macio, 1);\r\nsave_unin_clock_ctl = UN_IN(UNI_N_CLOCK_CNTL);\r\nUN_OUT(UNI_N_CLOCK_CNTL, save_unin_clock_ctl &\r\n~(UNI_N_CLOCK_CNTL_FW));\r\nudelay(100);\r\nUN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_SLEEPING);\r\nUN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_SLEEP);\r\nmdelay(10);\r\nif (pmac_mb.model_id == PMAC_TYPE_SAWTOOTH) {\r\nMACIO_BIS(0x506e0, 0x00400000);\r\nMACIO_BIS(0x506e0, 0x80000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncore99_wake_up(void)\r\n{\r\nstruct macio_chip *macio;\r\nint i;\r\nmacio = &macio_chips[0];\r\nif (macio->type != macio_keylargo && macio->type != macio_pangea &&\r\nmacio->type != macio_intrepid)\r\nreturn -ENODEV;\r\nUN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_NORMAL);\r\nudelay(10);\r\nUN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_RUNNING);\r\nudelay(10);\r\nif (macio->type == macio_keylargo) {\r\nMACIO_OUT32(KEYLARGO_MBCR, save_mbcr);\r\n(void)MACIO_IN32(KEYLARGO_MBCR); udelay(10);\r\n}\r\nMACIO_OUT32(KEYLARGO_FCR0, save_fcr[0]);\r\n(void)MACIO_IN32(KEYLARGO_FCR0); udelay(10);\r\nMACIO_OUT32(KEYLARGO_FCR1, save_fcr[1]);\r\n(void)MACIO_IN32(KEYLARGO_FCR1); udelay(10);\r\nMACIO_OUT32(KEYLARGO_FCR2, save_fcr[2]);\r\n(void)MACIO_IN32(KEYLARGO_FCR2); udelay(10);\r\nMACIO_OUT32(KEYLARGO_FCR3, save_fcr[3]);\r\n(void)MACIO_IN32(KEYLARGO_FCR3); udelay(10);\r\nMACIO_OUT32(KEYLARGO_FCR4, save_fcr[4]);\r\n(void)MACIO_IN32(KEYLARGO_FCR4); udelay(10);\r\nif (macio->type == macio_pangea || macio->type == macio_intrepid) {\r\nMACIO_OUT32(KEYLARGO_FCR5, save_fcr[5]);\r\n(void)MACIO_IN32(KEYLARGO_FCR5); udelay(10);\r\n}\r\ndbdma_restore(macio, save_dbdma);\r\nMACIO_OUT32(KEYLARGO_GPIO_LEVELS0, save_gpio_levels[0]);\r\nMACIO_OUT32(KEYLARGO_GPIO_LEVELS1, save_gpio_levels[1]);\r\nfor (i=0; i<KEYLARGO_GPIO_EXTINT_CNT; i++)\r\nMACIO_OUT8(KEYLARGO_GPIO_EXTINT_0+i, save_gpio_extint[i]);\r\nfor (i=0; i<KEYLARGO_GPIO_CNT; i++)\r\nMACIO_OUT8(KEYLARGO_GPIO_0+i, save_gpio_normal[i]);\r\nif (pmac_mb.model_id == PMAC_TYPE_SAWTOOTH) {\r\nMACIO_BIC(0x506e0, 0x00400000);\r\nMACIO_BIC(0x506e0, 0x80000000);\r\n}\r\nUN_OUT(UNI_N_CLOCK_CNTL, save_unin_clock_ctl);\r\nudelay(100);\r\nreturn 0;\r\n}\r\nstatic long\r\ncore99_sleep_state(struct device_node *node, long param, long value)\r\n{\r\nif (param == 1) {\r\nif (value == 1) {\r\nUN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_SLEEPING);\r\nUN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_IDLE2);\r\n} else {\r\nUN_OUT(UNI_N_POWER_MGT, UNI_N_POWER_MGT_NORMAL);\r\nudelay(10);\r\nUN_OUT(UNI_N_HWINIT_STATE, UNI_N_HWINIT_STATE_RUNNING);\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nif ((pmac_mb.board_flags & PMAC_MB_CAN_SLEEP) == 0)\r\nreturn -EPERM;\r\n#ifdef CONFIG_PM\r\nif (value == 1)\r\nreturn core99_sleep();\r\nelse if (value == 0)\r\nreturn core99_wake_up();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic long\r\ngeneric_dev_can_wake(struct device_node *node, long param, long value)\r\n{\r\nif (pmac_mb.board_flags & PMAC_MB_MAY_SLEEP)\r\npmac_mb.board_flags |= PMAC_MB_CAN_SLEEP;\r\nreturn 0;\r\n}\r\nstatic long generic_get_mb_info(struct device_node *node, long param, long value)\r\n{\r\nswitch(param) {\r\ncase PMAC_MB_INFO_MODEL:\r\nreturn pmac_mb.model_id;\r\ncase PMAC_MB_INFO_FLAGS:\r\nreturn pmac_mb.board_flags;\r\ncase PMAC_MB_INFO_NAME:\r\n*((const char **)value) = pmac_mb.model_name;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nlong pmac_do_feature_call(unsigned int selector, ...)\r\n{\r\nstruct device_node *node;\r\nlong param, value;\r\nint i;\r\nfeature_call func = NULL;\r\nva_list args;\r\nif (pmac_mb.features)\r\nfor (i=0; pmac_mb.features[i].function; i++)\r\nif (pmac_mb.features[i].selector == selector) {\r\nfunc = pmac_mb.features[i].function;\r\nbreak;\r\n}\r\nif (!func)\r\nfor (i=0; any_features[i].function; i++)\r\nif (any_features[i].selector == selector) {\r\nfunc = any_features[i].function;\r\nbreak;\r\n}\r\nif (!func)\r\nreturn -ENODEV;\r\nva_start(args, selector);\r\nnode = (struct device_node*)va_arg(args, void*);\r\nparam = va_arg(args, long);\r\nvalue = va_arg(args, long);\r\nva_end(args);\r\nreturn func(node, param, value);\r\n}\r\nstatic int __init probe_motherboard(void)\r\n{\r\nint i;\r\nstruct macio_chip *macio = &macio_chips[0];\r\nconst char *model = NULL;\r\nstruct device_node *dt;\r\nint ret = 0;\r\ndt = of_find_node_by_name(NULL, "device-tree");\r\nif (dt != NULL)\r\nmodel = of_get_property(dt, "model", NULL);\r\nfor(i=0; model && i<ARRAY_SIZE(pmac_mb_defs); i++) {\r\nif (strcmp(model, pmac_mb_defs[i].model_string) == 0) {\r\npmac_mb = pmac_mb_defs[i];\r\ngoto found;\r\n}\r\n}\r\nfor(i=0; i<ARRAY_SIZE(pmac_mb_defs); i++) {\r\nif (of_machine_is_compatible(pmac_mb_defs[i].model_string)) {\r\npmac_mb = pmac_mb_defs[i];\r\ngoto found;\r\n}\r\n}\r\nswitch(macio->type) {\r\n#ifndef CONFIG_PPC64\r\ncase macio_grand_central:\r\npmac_mb.model_id = PMAC_TYPE_PSURGE;\r\npmac_mb.model_name = "Unknown PowerSurge";\r\nbreak;\r\ncase macio_ohare:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_OHARE;\r\npmac_mb.model_name = "Unknown OHare-based";\r\nbreak;\r\ncase macio_heathrow:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_HEATHROW;\r\npmac_mb.model_name = "Unknown Heathrow-based";\r\npmac_mb.features = heathrow_desktop_features;\r\nbreak;\r\ncase macio_paddington:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_PADDINGTON;\r\npmac_mb.model_name = "Unknown Paddington-based";\r\npmac_mb.features = paddington_features;\r\nbreak;\r\ncase macio_keylargo:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_CORE99;\r\npmac_mb.model_name = "Unknown Keylargo-based";\r\npmac_mb.features = core99_features;\r\nbreak;\r\ncase macio_pangea:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_PANGEA;\r\npmac_mb.model_name = "Unknown Pangea-based";\r\npmac_mb.features = pangea_features;\r\nbreak;\r\ncase macio_intrepid:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_INTREPID;\r\npmac_mb.model_name = "Unknown Intrepid-based";\r\npmac_mb.features = intrepid_features;\r\nbreak;\r\n#else\r\ncase macio_keylargo2:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_K2;\r\npmac_mb.model_name = "Unknown K2-based";\r\npmac_mb.features = g5_features;\r\nbreak;\r\ncase macio_shasta:\r\npmac_mb.model_id = PMAC_TYPE_UNKNOWN_SHASTA;\r\npmac_mb.model_name = "Unknown Shasta-based";\r\npmac_mb.features = g5_features;\r\nbreak;\r\n#endif\r\ndefault:\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nfound:\r\n#ifndef CONFIG_PPC64\r\nif (pmac_mb.model_id == PMAC_TYPE_HOOPER) {\r\nu32 __iomem * mach_id_ptr = ioremap(0xf3000034, 4);\r\nif (!mach_id_ptr) {\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif (__raw_readl(mach_id_ptr) & 0x20000000UL)\r\npmac_mb.model_id = PMAC_TYPE_COMET;\r\niounmap(mach_id_ptr);\r\n}\r\nwhile (uninorth_base && uninorth_rev > 3) {\r\nstruct device_node *cpus = of_find_node_by_path("/cpus");\r\nstruct device_node *np;\r\nif (!cpus || !cpus->child) {\r\nprintk(KERN_WARNING "Can't find CPU(s) in device tree !\n");\r\nof_node_put(cpus);\r\nbreak;\r\n}\r\nnp = cpus->child;\r\nif (np->sibling) {\r\nof_node_put(cpus);\r\nbreak;\r\n}\r\nif (of_get_property(np, "flush-on-lock", NULL)) {\r\nof_node_put(cpus);\r\nbreak;\r\n}\r\nof_node_put(cpus);\r\npowersave_nap = 1;\r\nprintk(KERN_DEBUG "Processor NAP mode on idle enabled.\n");\r\nbreak;\r\n}\r\npowersave_lowspeed = 1;\r\n#else\r\npowersave_nap = 1;\r\n#endif\r\nif (model && (strncmp(model, "PowerBook", 9) == 0\r\n|| strncmp(model, "iBook", 5) == 0))\r\npmac_mb.board_flags |= PMAC_MB_MOBILE;\r\nprintk(KERN_INFO "PowerMac motherboard: %s\n", pmac_mb.model_name);\r\ndone:\r\nof_node_put(dt);\r\nreturn ret;\r\n}\r\nstatic void __init probe_uninorth(void)\r\n{\r\nconst u32 *addrp;\r\nphys_addr_t address;\r\nunsigned long actrl;\r\nuninorth_node = of_find_node_by_name(NULL, "uni-n");\r\nuninorth_maj = 1;\r\nif (uninorth_node == NULL) {\r\nuninorth_node = of_find_node_by_name(NULL, "u3");\r\nuninorth_maj = 3;\r\n}\r\nif (uninorth_node == NULL) {\r\nuninorth_node = of_find_node_by_name(NULL, "u4");\r\nuninorth_maj = 4;\r\n}\r\nif (uninorth_node == NULL) {\r\nuninorth_maj = 0;\r\nreturn;\r\n}\r\naddrp = of_get_property(uninorth_node, "reg", NULL);\r\nif (addrp == NULL)\r\nreturn;\r\naddress = of_translate_address(uninorth_node, addrp);\r\nif (address == 0)\r\nreturn;\r\nuninorth_base = ioremap(address, 0x40000);\r\nif (uninorth_base == NULL)\r\nreturn;\r\nuninorth_rev = in_be32(UN_REG(UNI_N_VERSION));\r\nif (uninorth_maj == 3 || uninorth_maj == 4) {\r\nu3_ht_base = ioremap(address + U3_HT_CONFIG_BASE, 0x1000);\r\nif (u3_ht_base == NULL) {\r\niounmap(uninorth_base);\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_INFO "Found %s memory controller & host bridge"\r\n" @ 0x%08x revision: 0x%02x\n", uninorth_maj == 3 ? "U3" :\r\nuninorth_maj == 4 ? "U4" : "UniNorth",\r\n(unsigned int)address, uninorth_rev);\r\nprintk(KERN_INFO "Mapped at 0x%08lx\n", (unsigned long)uninorth_base);\r\nif (uninorth_rev < 0x11) {\r\nactrl = UN_IN(UNI_N_ARB_CTRL) & ~UNI_N_ARB_CTRL_QACK_DELAY_MASK;\r\nactrl |= ((uninorth_rev < 3) ? UNI_N_ARB_CTRL_QACK_DELAY105 :\r\nUNI_N_ARB_CTRL_QACK_DELAY) <<\r\nUNI_N_ARB_CTRL_QACK_DELAY_SHIFT;\r\nUN_OUT(UNI_N_ARB_CTRL, actrl);\r\n}\r\nif ((uninorth_rev >= 0x11 && uninorth_rev <= 0x24) ||\r\nuninorth_rev == 0xc0)\r\nUN_OUT(0x2160, UN_IN(0x2160) & 0x00ffffff);\r\n}\r\nstatic void __init probe_one_macio(const char *name, const char *compat, int type)\r\n{\r\nstruct device_node* node;\r\nint i;\r\nvolatile u32 __iomem *base;\r\nconst u32 *addrp, *revp;\r\nphys_addr_t addr;\r\nu64 size;\r\nfor (node = NULL; (node = of_find_node_by_name(node, name)) != NULL;) {\r\nif (!compat)\r\nbreak;\r\nif (of_device_is_compatible(node, compat))\r\nbreak;\r\n}\r\nif (!node)\r\nreturn;\r\nfor(i=0; i<MAX_MACIO_CHIPS; i++) {\r\nif (!macio_chips[i].of_node)\r\nbreak;\r\nif (macio_chips[i].of_node == node)\r\nreturn;\r\n}\r\nif (i >= MAX_MACIO_CHIPS) {\r\nprintk(KERN_ERR "pmac_feature: Please increase MAX_MACIO_CHIPS !\n");\r\nprintk(KERN_ERR "pmac_feature: %s skipped\n", node->full_name);\r\nreturn;\r\n}\r\naddrp = of_get_pci_address(node, 0, &size, NULL);\r\nif (addrp == NULL) {\r\nprintk(KERN_ERR "pmac_feature: %s: can't find base !\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\naddr = of_translate_address(node, addrp);\r\nif (addr == 0) {\r\nprintk(KERN_ERR "pmac_feature: %s, can't translate base !\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\nbase = ioremap(addr, (unsigned long)size);\r\nif (!base) {\r\nprintk(KERN_ERR "pmac_feature: %s, can't map mac-io chip !\n",\r\nnode->full_name);\r\nreturn;\r\n}\r\nif (type == macio_keylargo || type == macio_keylargo2) {\r\nconst u32 *did = of_get_property(node, "device-id", NULL);\r\nif (*did == 0x00000025)\r\ntype = macio_pangea;\r\nif (*did == 0x0000003e)\r\ntype = macio_intrepid;\r\nif (*did == 0x0000004f)\r\ntype = macio_shasta;\r\n}\r\nmacio_chips[i].of_node = node;\r\nmacio_chips[i].type = type;\r\nmacio_chips[i].base = base;\r\nmacio_chips[i].flags = MACIO_FLAG_SCCA_ON | MACIO_FLAG_SCCB_ON;\r\nmacio_chips[i].name = macio_names[type];\r\nrevp = of_get_property(node, "revision-id", NULL);\r\nif (revp)\r\nmacio_chips[i].rev = *revp;\r\nprintk(KERN_INFO "Found a %s mac-io controller, rev: %d, mapped at 0x%p\n",\r\nmacio_names[type], macio_chips[i].rev, macio_chips[i].base);\r\n}\r\nstatic int __init\r\nprobe_macios(void)\r\n{\r\nprobe_one_macio("gc", NULL, macio_grand_central);\r\nprobe_one_macio("ohare", NULL, macio_ohare);\r\nprobe_one_macio("pci106b,7", NULL, macio_ohareII);\r\nprobe_one_macio("mac-io", "keylargo", macio_keylargo);\r\nprobe_one_macio("mac-io", "paddington", macio_paddington);\r\nprobe_one_macio("mac-io", "gatwick", macio_gatwick);\r\nprobe_one_macio("mac-io", "heathrow", macio_heathrow);\r\nprobe_one_macio("mac-io", "K2-Keylargo", macio_keylargo2);\r\nif (macio_chips[0].type == macio_gatwick\r\n&& macio_chips[1].type == macio_heathrow) {\r\nstruct macio_chip temp = macio_chips[0];\r\nmacio_chips[0] = macio_chips[1];\r\nmacio_chips[1] = temp;\r\n}\r\nif (macio_chips[0].type == macio_ohareII\r\n&& macio_chips[1].type == macio_ohare) {\r\nstruct macio_chip temp = macio_chips[0];\r\nmacio_chips[0] = macio_chips[1];\r\nmacio_chips[1] = temp;\r\n}\r\nmacio_chips[0].lbus.index = 0;\r\nmacio_chips[1].lbus.index = 1;\r\nreturn (macio_chips[0].of_node == NULL) ? -ENODEV : 0;\r\n}\r\nstatic void __init\r\ninitial_serial_shutdown(struct device_node *np)\r\n{\r\nint len;\r\nconst struct slot_names_prop {\r\nint count;\r\nchar name[1];\r\n} *slots;\r\nconst char *conn;\r\nint port_type = PMAC_SCC_ASYNC;\r\nint modem = 0;\r\nslots = of_get_property(np, "slot-names", &len);\r\nconn = of_get_property(np, "AAPL,connector", &len);\r\nif (conn && (strcmp(conn, "infrared") == 0))\r\nport_type = PMAC_SCC_IRDA;\r\nelse if (of_device_is_compatible(np, "cobalt"))\r\nmodem = 1;\r\nelse if (slots && slots->count > 0) {\r\nif (strcmp(slots->name, "IrDA") == 0)\r\nport_type = PMAC_SCC_IRDA;\r\nelse if (strcmp(slots->name, "Modem") == 0)\r\nmodem = 1;\r\n}\r\nif (modem)\r\npmac_call_feature(PMAC_FTR_MODEM_ENABLE, np, 0, 0);\r\npmac_call_feature(PMAC_FTR_SCC_ENABLE, np, port_type, 0);\r\n}\r\nstatic void __init\r\nset_initial_features(void)\r\n{\r\nstruct device_node *np;\r\nif (macio_chips[0].type == macio_ohare) {\r\nstruct macio_chip *macio = &macio_chips[0];\r\nnp = of_find_node_by_name(NULL, "via-pmu");\r\nif (np)\r\nMACIO_BIS(OHARE_FCR, OH_IOBUS_ENABLE);\r\nelse\r\nMACIO_OUT32(OHARE_FCR, STARMAX_FEATURES);\r\nof_node_put(np);\r\n} else if (macio_chips[1].type == macio_ohare) {\r\nstruct macio_chip *macio = &macio_chips[1];\r\nMACIO_BIS(OHARE_FCR, OH_IOBUS_ENABLE);\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (macio_chips[0].type == macio_keylargo2 ||\r\nmacio_chips[0].type == macio_shasta) {\r\n#ifndef CONFIG_SMP\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (np != NULL)\r\nnp = of_find_node_by_type(np, "cpu");\r\nif (np != NULL) {\r\ng5_phy_disable_cpu1();\r\nof_node_put(np);\r\n}\r\n#endif\r\nfor_each_node_by_name(np, "ethernet")\r\nif (of_device_is_compatible(np, "K2-GMAC"))\r\ng5_gmac_enable(np, 0, 1);\r\nfor_each_node_by_name(np, "firewire") {\r\nif (of_device_is_compatible(np, "pci106b,5811")) {\r\nmacio_chips[0].flags |= MACIO_FLAG_FW_SUPPORTED;\r\ng5_fw_enable(np, 0, 1);\r\n}\r\n}\r\n}\r\n#else\r\nif (macio_chips[0].type == macio_keylargo ||\r\nmacio_chips[0].type == macio_pangea ||\r\nmacio_chips[0].type == macio_intrepid) {\r\nfor_each_node_by_name(np, "ethernet") {\r\nif (np->parent\r\n&& of_device_is_compatible(np->parent, "uni-north")\r\n&& of_device_is_compatible(np, "gmac"))\r\ncore99_gmac_enable(np, 0, 1);\r\n}\r\nfor_each_node_by_name(np, "firewire") {\r\nif (np->parent\r\n&& of_device_is_compatible(np->parent, "uni-north")\r\n&& (of_device_is_compatible(np, "pci106b,18") ||\r\nof_device_is_compatible(np, "pci106b,30") ||\r\nof_device_is_compatible(np, "pci11c1,5811"))) {\r\nmacio_chips[0].flags |= MACIO_FLAG_FW_SUPPORTED;\r\ncore99_firewire_enable(np, 0, 1);\r\n}\r\n}\r\nnp = of_find_node_by_name(NULL, "ata-6");\r\nfor_each_node_by_name(np, "ata-6") {\r\nif (np->parent\r\n&& of_device_is_compatible(np->parent, "uni-north")\r\n&& of_device_is_compatible(np, "kauai-ata")) {\r\ncore99_ata100_enable(np, 1);\r\n}\r\n}\r\nfor_each_node_by_name(np, "radio") {\r\nif (np->parent == macio_chips[0].of_node) {\r\nmacio_chips[0].flags |= MACIO_FLAG_AIRPORT_ON;\r\ncore99_airport_enable(np, 0, 0);\r\n}\r\n}\r\n}\r\nif (macio_chips[0].of_node)\r\npmac_do_feature_call(PMAC_FTR_SOUND_CHIP_ENABLE,\r\nmacio_chips[0].of_node, 0, 0);\r\nif (macio_chips[0].of_node && macio_chips[0].type == macio_heathrow\r\n&& (pmac_mb.model_id == PMAC_TYPE_GOSSAMER ||\r\npmac_mb.model_id == PMAC_TYPE_SILK)) {\r\nstruct macio_chip *macio = &macio_chips[0];\r\nMACIO_BIS(HEATHROW_FCR, HRW_SOUND_CLK_ENABLE);\r\nMACIO_BIC(HEATHROW_FCR, HRW_SOUND_POWER_N);\r\n}\r\n#endif\r\nfor_each_node_by_name(np, "ch-a")\r\ninitial_serial_shutdown(np);\r\nof_node_put(np);\r\nfor_each_node_by_name(np, "ch-b")\r\ninitial_serial_shutdown(np);\r\nof_node_put(np);\r\n}\r\nvoid __init\r\npmac_feature_init(void)\r\n{\r\nprobe_uninorth();\r\nif (probe_macios()) {\r\nprintk(KERN_WARNING "No mac-io chip found\n");\r\nreturn;\r\n}\r\nif (probe_motherboard())\r\nprintk(KERN_WARNING "Unknown PowerMac !\n");\r\nset_initial_features();\r\n}\r\nvoid pmac_set_early_video_resume(void (*proc)(void *data), void *data)\r\n{\r\nif (!machine_is(powermac))\r\nreturn;\r\npreempt_disable();\r\npmac_early_vresume_proc = proc;\r\npmac_early_vresume_data = data;\r\npreempt_enable();\r\n}\r\nvoid pmac_call_early_video_resume(void)\r\n{\r\nif (pmac_early_vresume_proc)\r\npmac_early_vresume_proc(pmac_early_vresume_data);\r\n}\r\nvoid pmac_register_agp_pm(struct pci_dev *bridge,\r\nint (*suspend)(struct pci_dev *bridge),\r\nint (*resume)(struct pci_dev *bridge))\r\n{\r\nif (suspend || resume) {\r\npmac_agp_bridge = bridge;\r\npmac_agp_suspend = suspend;\r\npmac_agp_resume = resume;\r\nreturn;\r\n}\r\nif (bridge != pmac_agp_bridge)\r\nreturn;\r\npmac_agp_suspend = pmac_agp_resume = NULL;\r\nreturn;\r\n}\r\nvoid pmac_suspend_agp_for_card(struct pci_dev *dev)\r\n{\r\nif (pmac_agp_bridge == NULL || pmac_agp_suspend == NULL)\r\nreturn;\r\nif (pmac_agp_bridge->bus != dev->bus)\r\nreturn;\r\npmac_agp_suspend(pmac_agp_bridge);\r\n}\r\nvoid pmac_resume_agp_for_card(struct pci_dev *dev)\r\n{\r\nif (pmac_agp_bridge == NULL || pmac_agp_resume == NULL)\r\nreturn;\r\nif (pmac_agp_bridge->bus != dev->bus)\r\nreturn;\r\npmac_agp_resume(pmac_agp_bridge);\r\n}\r\nint pmac_get_uninorth_variant(void)\r\n{\r\nreturn uninorth_maj;\r\n}
