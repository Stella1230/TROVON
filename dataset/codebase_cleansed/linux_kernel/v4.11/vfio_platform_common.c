static vfio_platform_reset_fn_t vfio_platform_lookup_reset(const char *compat,\r\nstruct module **module)\r\n{\r\nstruct vfio_platform_reset_node *iter;\r\nvfio_platform_reset_fn_t reset_fn = NULL;\r\nmutex_lock(&driver_lock);\r\nlist_for_each_entry(iter, &reset_list, link) {\r\nif (!strcmp(iter->compat, compat) &&\r\ntry_module_get(iter->owner)) {\r\n*module = iter->owner;\r\nreset_fn = iter->of_reset;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&driver_lock);\r\nreturn reset_fn;\r\n}\r\nstatic int vfio_platform_acpi_probe(struct vfio_platform_device *vdev,\r\nstruct device *dev)\r\n{\r\nstruct acpi_device *adev;\r\nif (acpi_disabled)\r\nreturn -ENOENT;\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev) {\r\npr_err("VFIO: ACPI companion device not found for %s\n",\r\nvdev->name);\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_ACPI\r\nvdev->acpihid = acpi_device_hid(adev);\r\n#endif\r\nreturn WARN_ON(!vdev->acpihid) ? -EINVAL : 0;\r\n}\r\nstatic int vfio_platform_acpi_call_reset(struct vfio_platform_device *vdev,\r\nconst char **extra_dbg)\r\n{\r\n#ifdef CONFIG_ACPI\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nstruct device *dev = vdev->device;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nacpi_status acpi_ret;\r\nacpi_ret = acpi_evaluate_object(handle, "_RST", NULL, &buffer);\r\nif (ACPI_FAILURE(acpi_ret)) {\r\nif (extra_dbg)\r\n*extra_dbg = acpi_format_exception(acpi_ret);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n#else\r\nreturn -ENOENT;\r\n#endif\r\n}\r\nstatic bool vfio_platform_acpi_has_reset(struct vfio_platform_device *vdev)\r\n{\r\n#ifdef CONFIG_ACPI\r\nstruct device *dev = vdev->device;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nreturn acpi_has_method(handle, "_RST");\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nstatic bool vfio_platform_has_reset(struct vfio_platform_device *vdev)\r\n{\r\nif (VFIO_PLATFORM_IS_ACPI(vdev))\r\nreturn vfio_platform_acpi_has_reset(vdev);\r\nreturn vdev->of_reset ? true : false;\r\n}\r\nstatic int vfio_platform_get_reset(struct vfio_platform_device *vdev)\r\n{\r\nif (VFIO_PLATFORM_IS_ACPI(vdev))\r\nreturn vfio_platform_acpi_has_reset(vdev) ? 0 : -ENOENT;\r\nvdev->of_reset = vfio_platform_lookup_reset(vdev->compat,\r\n&vdev->reset_module);\r\nif (!vdev->of_reset) {\r\nrequest_module("vfio-reset:%s", vdev->compat);\r\nvdev->of_reset = vfio_platform_lookup_reset(vdev->compat,\r\n&vdev->reset_module);\r\n}\r\nreturn vdev->of_reset ? 0 : -ENOENT;\r\n}\r\nstatic void vfio_platform_put_reset(struct vfio_platform_device *vdev)\r\n{\r\nif (VFIO_PLATFORM_IS_ACPI(vdev))\r\nreturn;\r\nif (vdev->of_reset)\r\nmodule_put(vdev->reset_module);\r\n}\r\nstatic int vfio_platform_regions_init(struct vfio_platform_device *vdev)\r\n{\r\nint cnt = 0, i;\r\nwhile (vdev->get_resource(vdev, cnt))\r\ncnt++;\r\nvdev->regions = kcalloc(cnt, sizeof(struct vfio_platform_region),\r\nGFP_KERNEL);\r\nif (!vdev->regions)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < cnt; i++) {\r\nstruct resource *res =\r\nvdev->get_resource(vdev, i);\r\nif (!res)\r\ngoto err;\r\nvdev->regions[i].addr = res->start;\r\nvdev->regions[i].size = resource_size(res);\r\nvdev->regions[i].flags = 0;\r\nswitch (resource_type(res)) {\r\ncase IORESOURCE_MEM:\r\nvdev->regions[i].type = VFIO_PLATFORM_REGION_TYPE_MMIO;\r\nvdev->regions[i].flags |= VFIO_REGION_INFO_FLAG_READ;\r\nif (!(res->flags & IORESOURCE_READONLY))\r\nvdev->regions[i].flags |=\r\nVFIO_REGION_INFO_FLAG_WRITE;\r\nif (!(vdev->regions[i].addr & ~PAGE_MASK) &&\r\n!(vdev->regions[i].size & ~PAGE_MASK))\r\nvdev->regions[i].flags |=\r\nVFIO_REGION_INFO_FLAG_MMAP;\r\nbreak;\r\ncase IORESOURCE_IO:\r\nvdev->regions[i].type = VFIO_PLATFORM_REGION_TYPE_PIO;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\nvdev->num_regions = cnt;\r\nreturn 0;\r\nerr:\r\nkfree(vdev->regions);\r\nreturn -EINVAL;\r\n}\r\nstatic void vfio_platform_regions_cleanup(struct vfio_platform_device *vdev)\r\n{\r\nint i;\r\nfor (i = 0; i < vdev->num_regions; i++)\r\niounmap(vdev->regions[i].ioaddr);\r\nvdev->num_regions = 0;\r\nkfree(vdev->regions);\r\n}\r\nstatic int vfio_platform_call_reset(struct vfio_platform_device *vdev,\r\nconst char **extra_dbg)\r\n{\r\nif (VFIO_PLATFORM_IS_ACPI(vdev)) {\r\ndev_info(vdev->device, "reset\n");\r\nreturn vfio_platform_acpi_call_reset(vdev, extra_dbg);\r\n} else if (vdev->of_reset) {\r\ndev_info(vdev->device, "reset\n");\r\nreturn vdev->of_reset(vdev);\r\n}\r\ndev_warn(vdev->device, "no reset function found!\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void vfio_platform_release(void *device_data)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nmutex_lock(&driver_lock);\r\nif (!(--vdev->refcnt)) {\r\nconst char *extra_dbg = NULL;\r\nint ret;\r\nret = vfio_platform_call_reset(vdev, &extra_dbg);\r\nif (ret && vdev->reset_required) {\r\ndev_warn(vdev->device, "reset driver is required and reset call failed in release (%d) %s\n",\r\nret, extra_dbg ? extra_dbg : "");\r\nWARN_ON(1);\r\n}\r\nvfio_platform_regions_cleanup(vdev);\r\nvfio_platform_irq_cleanup(vdev);\r\n}\r\nmutex_unlock(&driver_lock);\r\nmodule_put(vdev->parent_module);\r\n}\r\nstatic int vfio_platform_open(void *device_data)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nint ret;\r\nif (!try_module_get(vdev->parent_module))\r\nreturn -ENODEV;\r\nmutex_lock(&driver_lock);\r\nif (!vdev->refcnt) {\r\nconst char *extra_dbg = NULL;\r\nret = vfio_platform_regions_init(vdev);\r\nif (ret)\r\ngoto err_reg;\r\nret = vfio_platform_irq_init(vdev);\r\nif (ret)\r\ngoto err_irq;\r\nret = vfio_platform_call_reset(vdev, &extra_dbg);\r\nif (ret && vdev->reset_required) {\r\ndev_warn(vdev->device, "reset driver is required and reset call failed in open (%d) %s\n",\r\nret, extra_dbg ? extra_dbg : "");\r\ngoto err_rst;\r\n}\r\n}\r\nvdev->refcnt++;\r\nmutex_unlock(&driver_lock);\r\nreturn 0;\r\nerr_rst:\r\nvfio_platform_irq_cleanup(vdev);\r\nerr_irq:\r\nvfio_platform_regions_cleanup(vdev);\r\nerr_reg:\r\nmutex_unlock(&driver_lock);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nstatic long vfio_platform_ioctl(void *device_data,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nunsigned long minsz;\r\nif (cmd == VFIO_DEVICE_GET_INFO) {\r\nstruct vfio_device_info info;\r\nminsz = offsetofend(struct vfio_device_info, num_irqs);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif (info.argsz < minsz)\r\nreturn -EINVAL;\r\nif (vfio_platform_has_reset(vdev))\r\nvdev->flags |= VFIO_DEVICE_FLAGS_RESET;\r\ninfo.flags = vdev->flags;\r\ninfo.num_regions = vdev->num_regions;\r\ninfo.num_irqs = vdev->num_irqs;\r\nreturn copy_to_user((void __user *)arg, &info, minsz) ?\r\n-EFAULT : 0;\r\n} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {\r\nstruct vfio_region_info info;\r\nminsz = offsetofend(struct vfio_region_info, offset);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif (info.argsz < minsz)\r\nreturn -EINVAL;\r\nif (info.index >= vdev->num_regions)\r\nreturn -EINVAL;\r\ninfo.offset = VFIO_PLATFORM_INDEX_TO_OFFSET(info.index);\r\ninfo.size = vdev->regions[info.index].size;\r\ninfo.flags = vdev->regions[info.index].flags;\r\nreturn copy_to_user((void __user *)arg, &info, minsz) ?\r\n-EFAULT : 0;\r\n} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\r\nstruct vfio_irq_info info;\r\nminsz = offsetofend(struct vfio_irq_info, count);\r\nif (copy_from_user(&info, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nif (info.argsz < minsz)\r\nreturn -EINVAL;\r\nif (info.index >= vdev->num_irqs)\r\nreturn -EINVAL;\r\ninfo.flags = vdev->irqs[info.index].flags;\r\ninfo.count = vdev->irqs[info.index].count;\r\nreturn copy_to_user((void __user *)arg, &info, minsz) ?\r\n-EFAULT : 0;\r\n} else if (cmd == VFIO_DEVICE_SET_IRQS) {\r\nstruct vfio_irq_set hdr;\r\nu8 *data = NULL;\r\nint ret = 0;\r\nsize_t data_size = 0;\r\nminsz = offsetofend(struct vfio_irq_set, count);\r\nif (copy_from_user(&hdr, (void __user *)arg, minsz))\r\nreturn -EFAULT;\r\nret = vfio_set_irqs_validate_and_prepare(&hdr, vdev->num_irqs,\r\nvdev->num_irqs, &data_size);\r\nif (ret)\r\nreturn ret;\r\nif (data_size) {\r\ndata = memdup_user((void __user *)(arg + minsz),\r\ndata_size);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\n}\r\nmutex_lock(&vdev->igate);\r\nret = vfio_platform_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\r\nhdr.start, hdr.count, data);\r\nmutex_unlock(&vdev->igate);\r\nkfree(data);\r\nreturn ret;\r\n} else if (cmd == VFIO_DEVICE_RESET) {\r\nreturn vfio_platform_call_reset(vdev, NULL);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t vfio_platform_read_mmio(struct vfio_platform_region *reg,\r\nchar __user *buf, size_t count,\r\nloff_t off)\r\n{\r\nunsigned int done = 0;\r\nif (!reg->ioaddr) {\r\nreg->ioaddr =\r\nioremap_nocache(reg->addr, reg->size);\r\nif (!reg->ioaddr)\r\nreturn -ENOMEM;\r\n}\r\nwhile (count) {\r\nsize_t filled;\r\nif (count >= 4 && !(off % 4)) {\r\nu32 val;\r\nval = ioread32(reg->ioaddr + off);\r\nif (copy_to_user(buf, &val, 4))\r\ngoto err;\r\nfilled = 4;\r\n} else if (count >= 2 && !(off % 2)) {\r\nu16 val;\r\nval = ioread16(reg->ioaddr + off);\r\nif (copy_to_user(buf, &val, 2))\r\ngoto err;\r\nfilled = 2;\r\n} else {\r\nu8 val;\r\nval = ioread8(reg->ioaddr + off);\r\nif (copy_to_user(buf, &val, 1))\r\ngoto err;\r\nfilled = 1;\r\n}\r\ncount -= filled;\r\ndone += filled;\r\noff += filled;\r\nbuf += filled;\r\n}\r\nreturn done;\r\nerr:\r\nreturn -EFAULT;\r\n}\r\nstatic ssize_t vfio_platform_read(void *device_data, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nunsigned int index = VFIO_PLATFORM_OFFSET_TO_INDEX(*ppos);\r\nloff_t off = *ppos & VFIO_PLATFORM_OFFSET_MASK;\r\nif (index >= vdev->num_regions)\r\nreturn -EINVAL;\r\nif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ))\r\nreturn -EINVAL;\r\nif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\r\nreturn vfio_platform_read_mmio(&vdev->regions[index],\r\nbuf, count, off);\r\nelse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\r\nreturn -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t vfio_platform_write_mmio(struct vfio_platform_region *reg,\r\nconst char __user *buf, size_t count,\r\nloff_t off)\r\n{\r\nunsigned int done = 0;\r\nif (!reg->ioaddr) {\r\nreg->ioaddr =\r\nioremap_nocache(reg->addr, reg->size);\r\nif (!reg->ioaddr)\r\nreturn -ENOMEM;\r\n}\r\nwhile (count) {\r\nsize_t filled;\r\nif (count >= 4 && !(off % 4)) {\r\nu32 val;\r\nif (copy_from_user(&val, buf, 4))\r\ngoto err;\r\niowrite32(val, reg->ioaddr + off);\r\nfilled = 4;\r\n} else if (count >= 2 && !(off % 2)) {\r\nu16 val;\r\nif (copy_from_user(&val, buf, 2))\r\ngoto err;\r\niowrite16(val, reg->ioaddr + off);\r\nfilled = 2;\r\n} else {\r\nu8 val;\r\nif (copy_from_user(&val, buf, 1))\r\ngoto err;\r\niowrite8(val, reg->ioaddr + off);\r\nfilled = 1;\r\n}\r\ncount -= filled;\r\ndone += filled;\r\noff += filled;\r\nbuf += filled;\r\n}\r\nreturn done;\r\nerr:\r\nreturn -EFAULT;\r\n}\r\nstatic ssize_t vfio_platform_write(void *device_data, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nunsigned int index = VFIO_PLATFORM_OFFSET_TO_INDEX(*ppos);\r\nloff_t off = *ppos & VFIO_PLATFORM_OFFSET_MASK;\r\nif (index >= vdev->num_regions)\r\nreturn -EINVAL;\r\nif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE))\r\nreturn -EINVAL;\r\nif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\r\nreturn vfio_platform_write_mmio(&vdev->regions[index],\r\nbuf, count, off);\r\nelse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\r\nreturn -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic int vfio_platform_mmap_mmio(struct vfio_platform_region region,\r\nstruct vm_area_struct *vma)\r\n{\r\nu64 req_len, pgoff, req_start;\r\nreq_len = vma->vm_end - vma->vm_start;\r\npgoff = vma->vm_pgoff &\r\n((1U << (VFIO_PLATFORM_OFFSET_SHIFT - PAGE_SHIFT)) - 1);\r\nreq_start = pgoff << PAGE_SHIFT;\r\nif (region.size < PAGE_SIZE || req_start + req_len > region.size)\r\nreturn -EINVAL;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nvma->vm_pgoff = (region.addr >> PAGE_SHIFT) + pgoff;\r\nreturn remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nreq_len, vma->vm_page_prot);\r\n}\r\nstatic int vfio_platform_mmap(void *device_data, struct vm_area_struct *vma)\r\n{\r\nstruct vfio_platform_device *vdev = device_data;\r\nunsigned int index;\r\nindex = vma->vm_pgoff >> (VFIO_PLATFORM_OFFSET_SHIFT - PAGE_SHIFT);\r\nif (vma->vm_end < vma->vm_start)\r\nreturn -EINVAL;\r\nif (!(vma->vm_flags & VM_SHARED))\r\nreturn -EINVAL;\r\nif (index >= vdev->num_regions)\r\nreturn -EINVAL;\r\nif (vma->vm_start & ~PAGE_MASK)\r\nreturn -EINVAL;\r\nif (vma->vm_end & ~PAGE_MASK)\r\nreturn -EINVAL;\r\nif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_MMAP))\r\nreturn -EINVAL;\r\nif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_READ)\r\n&& (vma->vm_flags & VM_READ))\r\nreturn -EINVAL;\r\nif (!(vdev->regions[index].flags & VFIO_REGION_INFO_FLAG_WRITE)\r\n&& (vma->vm_flags & VM_WRITE))\r\nreturn -EINVAL;\r\nvma->vm_private_data = vdev;\r\nif (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_MMIO)\r\nreturn vfio_platform_mmap_mmio(vdev->regions[index], vma);\r\nelse if (vdev->regions[index].type & VFIO_PLATFORM_REGION_TYPE_PIO)\r\nreturn -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic int vfio_platform_of_probe(struct vfio_platform_device *vdev,\r\nstruct device *dev)\r\n{\r\nint ret;\r\nret = device_property_read_string(dev, "compatible",\r\n&vdev->compat);\r\nif (ret)\r\npr_err("VFIO: cannot retrieve compat for %s\n",\r\nvdev->name);\r\nreturn ret;\r\n}\r\nint vfio_platform_probe_common(struct vfio_platform_device *vdev,\r\nstruct device *dev)\r\n{\r\nstruct iommu_group *group;\r\nint ret;\r\nif (!vdev)\r\nreturn -EINVAL;\r\nret = vfio_platform_acpi_probe(vdev, dev);\r\nif (ret)\r\nret = vfio_platform_of_probe(vdev, dev);\r\nif (ret)\r\nreturn ret;\r\nvdev->device = dev;\r\nret = vfio_platform_get_reset(vdev);\r\nif (ret && vdev->reset_required) {\r\npr_err("vfio: no reset function found for device %s\n",\r\nvdev->name);\r\nreturn ret;\r\n}\r\ngroup = vfio_iommu_group_get(dev);\r\nif (!group) {\r\npr_err("VFIO: No IOMMU group for device %s\n", vdev->name);\r\nreturn -EINVAL;\r\n}\r\nret = vfio_add_group_dev(dev, &vfio_platform_ops, vdev);\r\nif (ret) {\r\nvfio_iommu_group_put(group, dev);\r\nreturn ret;\r\n}\r\nmutex_init(&vdev->igate);\r\nreturn 0;\r\n}\r\nstruct vfio_platform_device *vfio_platform_remove_common(struct device *dev)\r\n{\r\nstruct vfio_platform_device *vdev;\r\nvdev = vfio_del_group_dev(dev);\r\nif (vdev) {\r\nvfio_platform_put_reset(vdev);\r\nvfio_iommu_group_put(dev->iommu_group, dev);\r\n}\r\nreturn vdev;\r\n}\r\nvoid __vfio_platform_register_reset(struct vfio_platform_reset_node *node)\r\n{\r\nmutex_lock(&driver_lock);\r\nlist_add(&node->link, &reset_list);\r\nmutex_unlock(&driver_lock);\r\n}\r\nvoid vfio_platform_unregister_reset(const char *compat,\r\nvfio_platform_reset_fn_t fn)\r\n{\r\nstruct vfio_platform_reset_node *iter, *temp;\r\nmutex_lock(&driver_lock);\r\nlist_for_each_entry_safe(iter, temp, &reset_list, link) {\r\nif (!strcmp(iter->compat, compat) && (iter->of_reset == fn)) {\r\nlist_del(&iter->link);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&driver_lock);\r\n}
