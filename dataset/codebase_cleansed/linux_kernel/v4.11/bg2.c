static void __init berlin2_clock_setup(struct device_node *np)\r\n{\r\nstruct device_node *parent_np = of_get_parent(np);\r\nconst char *parent_names[9];\r\nstruct clk *clk;\r\nstruct clk_hw *hw;\r\nstruct clk_hw **hws;\r\nu8 avpll_flags = 0;\r\nint n, ret;\r\nclk_data = kzalloc(sizeof(*clk_data) +\r\nsizeof(*clk_data->hws) * MAX_CLKS, GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->num = MAX_CLKS;\r\nhws = clk_data->hws;\r\ngbase = of_iomap(parent_np, 0);\r\nif (!gbase)\r\nreturn;\r\nclk = of_clk_get_by_name(np, clk_names[REFCLK]);\r\nif (!IS_ERR(clk)) {\r\nclk_names[REFCLK] = __clk_get_name(clk);\r\nclk_put(clk);\r\n}\r\nclk = of_clk_get_by_name(np, clk_names[VIDEO_EXT0]);\r\nif (!IS_ERR(clk)) {\r\nclk_names[VIDEO_EXT0] = __clk_get_name(clk);\r\nclk_put(clk);\r\n}\r\nret = berlin2_pll_register(&bg2_pll_map, gbase + REG_SYSPLLCTL0,\r\nclk_names[SYSPLL], clk_names[REFCLK], 0);\r\nif (ret)\r\ngoto bg2_fail;\r\nret = berlin2_pll_register(&bg2_pll_map, gbase + REG_MEMPLLCTL0,\r\nclk_names[MEMPLL], clk_names[REFCLK], 0);\r\nif (ret)\r\ngoto bg2_fail;\r\nret = berlin2_pll_register(&bg2_pll_map, gbase + REG_CPUPLLCTL0,\r\nclk_names[CPUPLL], clk_names[REFCLK], 0);\r\nif (ret)\r\ngoto bg2_fail;\r\nif (of_device_is_compatible(np, "marvell,berlin2-global-register"))\r\navpll_flags |= BERLIN2_AVPLL_SCRAMBLE_QUIRK;\r\nret = berlin2_avpll_vco_register(gbase + REG_AVPLLCTL0, "avpll_vcoA",\r\nclk_names[REFCLK], avpll_flags, 0);\r\nif (ret)\r\ngoto bg2_fail;\r\nfor (n = 0; n < 8; n++) {\r\nret = berlin2_avpll_channel_register(gbase + REG_AVPLLCTL0,\r\nclk_names[AVPLL_A1 + n], n, "avpll_vcoA",\r\navpll_flags, 0);\r\nif (ret)\r\ngoto bg2_fail;\r\n}\r\nret = berlin2_avpll_vco_register(gbase + REG_AVPLLCTL31, "avpll_vcoB",\r\nclk_names[REFCLK], BERLIN2_AVPLL_BIT_QUIRK |\r\navpll_flags, 0);\r\nif (ret)\r\ngoto bg2_fail;\r\nfor (n = 0; n < 8; n++) {\r\nret = berlin2_avpll_channel_register(gbase + REG_AVPLLCTL31,\r\nclk_names[AVPLL_B1 + n], n, "avpll_vcoB",\r\nBERLIN2_AVPLL_BIT_QUIRK | avpll_flags, 0);\r\nif (ret)\r\ngoto bg2_fail;\r\n}\r\nparent_names[0] = clk_names[SYSPLL];\r\nparent_names[1] = clk_names[REFCLK];\r\nhw = clk_hw_register_mux(NULL, "syspll_byp", parent_names, 2,\r\n0, gbase + REG_CLKSWITCH0, 0, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nclk_names[SYSPLL] = clk_hw_get_name(hw);\r\nparent_names[0] = clk_names[MEMPLL];\r\nparent_names[1] = clk_names[REFCLK];\r\nhw = clk_hw_register_mux(NULL, "mempll_byp", parent_names, 2,\r\n0, gbase + REG_CLKSWITCH0, 1, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nclk_names[MEMPLL] = clk_hw_get_name(hw);\r\nparent_names[0] = clk_names[CPUPLL];\r\nparent_names[1] = clk_names[REFCLK];\r\nhw = clk_hw_register_mux(NULL, "cpupll_byp", parent_names, 2,\r\n0, gbase + REG_CLKSWITCH0, 2, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nclk_names[CPUPLL] = clk_hw_get_name(hw);\r\nparent_names[0] = clk_names[AVPLL_B3];\r\nparent_names[1] = clk_names[AVPLL_A3];\r\nhw = clk_hw_register_mux(NULL, clk_names[AUDIO1_PLL], parent_names, 2,\r\n0, gbase + REG_CLKSELECT2, 29, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nparent_names[0] = clk_names[VIDEO0_PLL];\r\nparent_names[1] = clk_names[VIDEO_EXT0];\r\nhw = clk_hw_register_mux(NULL, clk_names[VIDEO0_IN], parent_names, 2,\r\n0, gbase + REG_CLKSELECT3, 4, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nparent_names[0] = clk_names[VIDEO1_PLL];\r\nparent_names[1] = clk_names[VIDEO_EXT0];\r\nhw = clk_hw_register_mux(NULL, clk_names[VIDEO1_IN], parent_names, 2,\r\n0, gbase + REG_CLKSELECT3, 6, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nparent_names[0] = clk_names[AVPLL_A2];\r\nparent_names[1] = clk_names[AVPLL_B2];\r\nhw = clk_hw_register_mux(NULL, clk_names[VIDEO1_PLL], parent_names, 2,\r\n0, gbase + REG_CLKSELECT3, 7, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nparent_names[0] = clk_names[VIDEO2_PLL];\r\nparent_names[1] = clk_names[VIDEO_EXT0];\r\nhw = clk_hw_register_mux(NULL, clk_names[VIDEO2_IN], parent_names, 2,\r\n0, gbase + REG_CLKSELECT3, 9, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nparent_names[0] = clk_names[AVPLL_B1];\r\nparent_names[1] = clk_names[AVPLL_A5];\r\nhw = clk_hw_register_mux(NULL, clk_names[VIDEO2_PLL], parent_names, 2,\r\n0, gbase + REG_CLKSELECT3, 10, 1, 0, &lock);\r\nif (IS_ERR(hw))\r\ngoto bg2_fail;\r\nfor (n = 0; n < ARRAY_SIZE(bg2_divs); n++) {\r\nconst struct berlin2_div_data *dd = &bg2_divs[n];\r\nint k;\r\nfor (k = 0; k < dd->num_parents; k++)\r\nparent_names[k] = clk_names[dd->parent_ids[k]];\r\nhws[CLKID_SYS + n] = berlin2_div_register(&dd->map, gbase,\r\ndd->name, dd->div_flags, parent_names,\r\ndd->num_parents, dd->flags, &lock);\r\n}\r\nfor (n = 0; n < ARRAY_SIZE(bg2_gates); n++) {\r\nconst struct berlin2_gate_data *gd = &bg2_gates[n];\r\nhws[CLKID_GETH0 + n] = clk_hw_register_gate(NULL, gd->name,\r\ngd->parent_name, gd->flags, gbase + REG_CLKENABLE,\r\ngd->bit_idx, 0, &lock);\r\n}\r\nhws[CLKID_TWD] =\r\nclk_hw_register_fixed_factor(NULL, "twd", "cpu", 0, 1, 3);\r\nfor (n = 0; n < MAX_CLKS; n++) {\r\nif (!IS_ERR(hws[n]))\r\ncontinue;\r\npr_err("%s: Unable to register leaf clock %d\n",\r\nnp->full_name, n);\r\ngoto bg2_fail;\r\n}\r\nof_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\r\nreturn;\r\nbg2_fail:\r\niounmap(gbase);\r\n}
