static u64 notrace meson6_timer_sched_read(void)\r\n{\r\nreturn (u64)readl(timer_base + TIMER_ISA_VAL(CSD_ID));\r\n}\r\nstatic void meson6_clkevt_time_stop(unsigned char timer)\r\n{\r\nu32 val = readl(timer_base + TIMER_ISA_MUX);\r\nwritel(val & ~TIMER_ENABLE_BIT(timer), timer_base + TIMER_ISA_MUX);\r\n}\r\nstatic void meson6_clkevt_time_setup(unsigned char timer, unsigned long delay)\r\n{\r\nwritel(delay, timer_base + TIMER_ISA_VAL(timer));\r\n}\r\nstatic void meson6_clkevt_time_start(unsigned char timer, bool periodic)\r\n{\r\nu32 val = readl(timer_base + TIMER_ISA_MUX);\r\nif (periodic)\r\nval |= TIMER_PERIODIC_BIT(timer);\r\nelse\r\nval &= ~TIMER_PERIODIC_BIT(timer);\r\nwritel(val | TIMER_ENABLE_BIT(timer), timer_base + TIMER_ISA_MUX);\r\n}\r\nstatic int meson6_shutdown(struct clock_event_device *evt)\r\n{\r\nmeson6_clkevt_time_stop(CED_ID);\r\nreturn 0;\r\n}\r\nstatic int meson6_set_oneshot(struct clock_event_device *evt)\r\n{\r\nmeson6_clkevt_time_stop(CED_ID);\r\nmeson6_clkevt_time_start(CED_ID, false);\r\nreturn 0;\r\n}\r\nstatic int meson6_set_periodic(struct clock_event_device *evt)\r\n{\r\nmeson6_clkevt_time_stop(CED_ID);\r\nmeson6_clkevt_time_setup(CED_ID, USEC_PER_SEC / HZ - 1);\r\nmeson6_clkevt_time_start(CED_ID, true);\r\nreturn 0;\r\n}\r\nstatic int meson6_clkevt_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nmeson6_clkevt_time_stop(CED_ID);\r\nmeson6_clkevt_time_setup(CED_ID, evt);\r\nmeson6_clkevt_time_start(CED_ID, false);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t meson6_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = (struct clock_event_device *)dev_id;\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init meson6_timer_init(struct device_node *node)\r\n{\r\nu32 val;\r\nint ret, irq;\r\ntimer_base = of_io_request_and_map(node, 0, "meson6-timer");\r\nif (IS_ERR(timer_base)) {\r\npr_err("Can't map registers");\r\nreturn -ENXIO;\r\n}\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0) {\r\npr_err("Can't parse IRQ");\r\nreturn -EINVAL;\r\n}\r\nval = readl(timer_base + TIMER_ISA_MUX);\r\nval &= ~TIMER_CSD_INPUT_MASK;\r\nval |= TIMER_CSD_UNIT_1US << TIMER_INPUT_BIT(CSD_ID);\r\nwritel(val, timer_base + TIMER_ISA_MUX);\r\nsched_clock_register(meson6_timer_sched_read, 32, USEC_PER_SEC);\r\nclocksource_mmio_init(timer_base + TIMER_ISA_VAL(CSD_ID), node->name,\r\n1000 * 1000, 300, 32, clocksource_mmio_readl_up);\r\nval &= ~TIMER_CED_INPUT_MASK;\r\nval |= TIMER_CED_UNIT_1US << TIMER_INPUT_BIT(CED_ID);\r\nwritel(val, timer_base + TIMER_ISA_MUX);\r\nmeson6_clkevt_time_stop(CED_ID);\r\nret = setup_irq(irq, &meson6_timer_irq);\r\nif (ret) {\r\npr_warn("failed to setup irq %d\n", irq);\r\nreturn ret;\r\n}\r\nmeson6_clockevent.cpumask = cpu_possible_mask;\r\nmeson6_clockevent.irq = irq;\r\nclockevents_config_and_register(&meson6_clockevent, USEC_PER_SEC,\r\n1, 0xfffe);\r\nreturn 0;\r\n}
