static struct mbox_chan *get_pcc_channel(int id)\r\n{\r\nif (id < 0 || id > pcc_mbox_ctrl.num_chans)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &pcc_mbox_channels[id];\r\n}\r\nstatic int read_register(void __iomem *vaddr, u64 *val, unsigned int bit_width)\r\n{\r\nint ret_val = 0;\r\nswitch (bit_width) {\r\ncase 8:\r\n*val = readb(vaddr);\r\nbreak;\r\ncase 16:\r\n*val = readw(vaddr);\r\nbreak;\r\ncase 32:\r\n*val = readl(vaddr);\r\nbreak;\r\ncase 64:\r\n*val = readq(vaddr);\r\nbreak;\r\ndefault:\r\npr_debug("Error: Cannot read register of %u bit width",\r\nbit_width);\r\nret_val = -EFAULT;\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int write_register(void __iomem *vaddr, u64 val, unsigned int bit_width)\r\n{\r\nint ret_val = 0;\r\nswitch (bit_width) {\r\ncase 8:\r\nwriteb(val, vaddr);\r\nbreak;\r\ncase 16:\r\nwritew(val, vaddr);\r\nbreak;\r\ncase 32:\r\nwritel(val, vaddr);\r\nbreak;\r\ncase 64:\r\nwriteq(val, vaddr);\r\nbreak;\r\ndefault:\r\npr_debug("Error: Cannot write register of %u bit width",\r\nbit_width);\r\nret_val = -EFAULT;\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int pcc_map_interrupt(u32 interrupt, u32 flags)\r\n{\r\nint trigger, polarity;\r\nif (!interrupt)\r\nreturn 0;\r\ntrigger = (flags & ACPI_PCCT_INTERRUPT_MODE) ? ACPI_EDGE_SENSITIVE\r\n: ACPI_LEVEL_SENSITIVE;\r\npolarity = (flags & ACPI_PCCT_INTERRUPT_POLARITY) ? ACPI_ACTIVE_LOW\r\n: ACPI_ACTIVE_HIGH;\r\nreturn acpi_register_gsi(NULL, interrupt, trigger, polarity);\r\n}\r\nstatic irqreturn_t pcc_mbox_irq(int irq, void *p)\r\n{\r\nstruct acpi_generic_address *doorbell_ack;\r\nstruct acpi_pcct_hw_reduced *pcct_ss;\r\nstruct mbox_chan *chan = p;\r\nu64 doorbell_ack_preserve;\r\nu64 doorbell_ack_write;\r\nu64 doorbell_ack_val;\r\nint ret;\r\npcct_ss = chan->con_priv;\r\nmbox_chan_received_data(chan, NULL);\r\nif (pcct_ss->header.type == ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2) {\r\nstruct acpi_pcct_hw_reduced_type2 *pcct2_ss = chan->con_priv;\r\nu32 id = chan - pcc_mbox_channels;\r\ndoorbell_ack = &pcct2_ss->doorbell_ack_register;\r\ndoorbell_ack_preserve = pcct2_ss->ack_preserve_mask;\r\ndoorbell_ack_write = pcct2_ss->ack_write_mask;\r\nret = read_register(pcc_doorbell_ack_vaddr[id],\r\n&doorbell_ack_val,\r\ndoorbell_ack->bit_width);\r\nif (ret)\r\nreturn IRQ_NONE;\r\nret = write_register(pcc_doorbell_ack_vaddr[id],\r\n(doorbell_ack_val & doorbell_ack_preserve)\r\n| doorbell_ack_write,\r\ndoorbell_ack->bit_width);\r\nif (ret)\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct mbox_chan *pcc_mbox_request_channel(struct mbox_client *cl,\r\nint subspace_id)\r\n{\r\nstruct device *dev = pcc_mbox_ctrl.dev;\r\nstruct mbox_chan *chan;\r\nunsigned long flags;\r\nchan = get_pcc_channel(subspace_id);\r\nif (IS_ERR(chan) || chan->cl) {\r\ndev_err(dev, "Channel not found for idx: %d\n", subspace_id);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->msg_free = 0;\r\nchan->msg_count = 0;\r\nchan->active_req = NULL;\r\nchan->cl = cl;\r\ninit_completion(&chan->tx_complete);\r\nif (chan->txdone_method == TXDONE_BY_POLL && cl->knows_txdone)\r\nchan->txdone_method |= TXDONE_BY_ACK;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\nif (pcc_doorbell_irq[subspace_id] > 0) {\r\nint rc;\r\nrc = devm_request_irq(dev, pcc_doorbell_irq[subspace_id],\r\npcc_mbox_irq, 0, MBOX_IRQ_NAME, chan);\r\nif (unlikely(rc)) {\r\ndev_err(dev, "failed to register PCC interrupt %d\n",\r\npcc_doorbell_irq[subspace_id]);\r\npcc_mbox_free_channel(chan);\r\nchan = ERR_PTR(rc);\r\n}\r\n}\r\nreturn chan;\r\n}\r\nvoid pcc_mbox_free_channel(struct mbox_chan *chan)\r\n{\r\nu32 id = chan - pcc_mbox_channels;\r\nunsigned long flags;\r\nif (!chan || !chan->cl)\r\nreturn;\r\nif (id >= pcc_mbox_ctrl.num_chans) {\r\npr_debug("pcc_mbox_free_channel: Invalid mbox_chan passed\n");\r\nreturn;\r\n}\r\nif (pcc_doorbell_irq[id] > 0)\r\ndevm_free_irq(chan->mbox->dev, pcc_doorbell_irq[id], chan);\r\nspin_lock_irqsave(&chan->lock, flags);\r\nchan->cl = NULL;\r\nchan->active_req = NULL;\r\nif (chan->txdone_method == (TXDONE_BY_POLL | TXDONE_BY_ACK))\r\nchan->txdone_method = TXDONE_BY_POLL;\r\nspin_unlock_irqrestore(&chan->lock, flags);\r\n}\r\nstatic int pcc_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct acpi_pcct_hw_reduced *pcct_ss = chan->con_priv;\r\nstruct acpi_generic_address *doorbell;\r\nu64 doorbell_preserve;\r\nu64 doorbell_val;\r\nu64 doorbell_write;\r\nu32 id = chan - pcc_mbox_channels;\r\nint ret = 0;\r\nif (id >= pcc_mbox_ctrl.num_chans) {\r\npr_debug("pcc_send_data: Invalid mbox_chan passed\n");\r\nreturn -ENOENT;\r\n}\r\ndoorbell = &pcct_ss->doorbell_register;\r\ndoorbell_preserve = pcct_ss->preserve_mask;\r\ndoorbell_write = pcct_ss->write_mask;\r\nif (pcc_doorbell_vaddr[id]) {\r\nret = read_register(pcc_doorbell_vaddr[id], &doorbell_val,\r\ndoorbell->bit_width);\r\nif (ret)\r\nreturn ret;\r\nret = write_register(pcc_doorbell_vaddr[id],\r\n(doorbell_val & doorbell_preserve) | doorbell_write,\r\ndoorbell->bit_width);\r\n} else {\r\nret = acpi_read(&doorbell_val, doorbell);\r\nif (ret)\r\nreturn ret;\r\nret = acpi_write((doorbell_val & doorbell_preserve) | doorbell_write,\r\ndoorbell);\r\n}\r\nreturn ret;\r\n}\r\nstatic int parse_pcc_subspace(struct acpi_subtable_header *header,\r\nconst unsigned long end)\r\n{\r\nstruct acpi_pcct_hw_reduced *pcct_ss;\r\nif (pcc_mbox_ctrl.num_chans <= MAX_PCC_SUBSPACES) {\r\npcct_ss = (struct acpi_pcct_hw_reduced *) header;\r\nif ((pcct_ss->header.type !=\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE)\r\n&& (pcct_ss->header.type !=\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2)) {\r\npr_err("Incorrect PCC Subspace type detected\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcc_parse_subspace_irq(int id,\r\nstruct acpi_pcct_hw_reduced *pcct_ss)\r\n{\r\npcc_doorbell_irq[id] = pcc_map_interrupt(pcct_ss->doorbell_interrupt,\r\n(u32)pcct_ss->flags);\r\nif (pcc_doorbell_irq[id] <= 0) {\r\npr_err("PCC GSI %d not registered\n",\r\npcct_ss->doorbell_interrupt);\r\nreturn -EINVAL;\r\n}\r\nif (pcct_ss->header.type\r\n== ACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2) {\r\nstruct acpi_pcct_hw_reduced_type2 *pcct2_ss = (void *)pcct_ss;\r\npcc_doorbell_ack_vaddr[id] = acpi_os_ioremap(\r\npcct2_ss->doorbell_ack_register.address,\r\npcct2_ss->doorbell_ack_register.bit_width / 8);\r\nif (!pcc_doorbell_ack_vaddr[id]) {\r\npr_err("Failed to ioremap PCC ACK register\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init acpi_pcc_probe(void)\r\n{\r\nstruct acpi_table_header *pcct_tbl;\r\nstruct acpi_subtable_header *pcct_entry;\r\nstruct acpi_table_pcct *acpi_pcct_tbl;\r\nint count, i, rc;\r\nint sum = 0;\r\nacpi_status status = AE_OK;\r\nstatus = acpi_get_table(ACPI_SIG_PCCT, 0, &pcct_tbl);\r\nif (ACPI_FAILURE(status) || !pcct_tbl) {\r\npr_warn("PCCT header not found.\n");\r\nreturn -ENODEV;\r\n}\r\ncount = acpi_table_parse_entries(ACPI_SIG_PCCT,\r\nsizeof(struct acpi_table_pcct),\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE,\r\nparse_pcc_subspace, MAX_PCC_SUBSPACES);\r\nsum += (count > 0) ? count : 0;\r\ncount = acpi_table_parse_entries(ACPI_SIG_PCCT,\r\nsizeof(struct acpi_table_pcct),\r\nACPI_PCCT_TYPE_HW_REDUCED_SUBSPACE_TYPE2,\r\nparse_pcc_subspace, MAX_PCC_SUBSPACES);\r\nsum += (count > 0) ? count : 0;\r\nif (sum == 0 || sum >= MAX_PCC_SUBSPACES) {\r\npr_err("Error parsing PCC subspaces from PCCT\n");\r\nreturn -EINVAL;\r\n}\r\npcc_mbox_channels = kzalloc(sizeof(struct mbox_chan) *\r\nsum, GFP_KERNEL);\r\nif (!pcc_mbox_channels) {\r\npr_err("Could not allocate space for PCC mbox channels\n");\r\nreturn -ENOMEM;\r\n}\r\npcc_doorbell_vaddr = kcalloc(sum, sizeof(void *), GFP_KERNEL);\r\nif (!pcc_doorbell_vaddr) {\r\nrc = -ENOMEM;\r\ngoto err_free_mbox;\r\n}\r\npcc_doorbell_ack_vaddr = kcalloc(sum, sizeof(void *), GFP_KERNEL);\r\nif (!pcc_doorbell_ack_vaddr) {\r\nrc = -ENOMEM;\r\ngoto err_free_db_vaddr;\r\n}\r\npcc_doorbell_irq = kcalloc(sum, sizeof(int), GFP_KERNEL);\r\nif (!pcc_doorbell_irq) {\r\nrc = -ENOMEM;\r\ngoto err_free_db_ack_vaddr;\r\n}\r\npcct_entry = (struct acpi_subtable_header *) (\r\n(unsigned long) pcct_tbl + sizeof(struct acpi_table_pcct));\r\nacpi_pcct_tbl = (struct acpi_table_pcct *) pcct_tbl;\r\nif (acpi_pcct_tbl->flags & ACPI_PCCT_DOORBELL)\r\npcc_mbox_ctrl.txdone_irq = true;\r\nfor (i = 0; i < sum; i++) {\r\nstruct acpi_generic_address *db_reg;\r\nstruct acpi_pcct_hw_reduced *pcct_ss;\r\npcc_mbox_channels[i].con_priv = pcct_entry;\r\npcct_ss = (struct acpi_pcct_hw_reduced *) pcct_entry;\r\nif (pcc_mbox_ctrl.txdone_irq) {\r\nrc = pcc_parse_subspace_irq(i, pcct_ss);\r\nif (rc < 0)\r\ngoto err;\r\n}\r\ndb_reg = &pcct_ss->doorbell_register;\r\nif (db_reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\npcc_doorbell_vaddr[i] = acpi_os_ioremap(db_reg->address,\r\ndb_reg->bit_width/8);\r\npcct_entry = (struct acpi_subtable_header *)\r\n((unsigned long) pcct_entry + pcct_entry->length);\r\n}\r\npcc_mbox_ctrl.num_chans = sum;\r\npr_info("Detected %d PCC Subspaces\n", pcc_mbox_ctrl.num_chans);\r\nreturn 0;\r\nerr:\r\nkfree(pcc_doorbell_irq);\r\nerr_free_db_ack_vaddr:\r\nkfree(pcc_doorbell_ack_vaddr);\r\nerr_free_db_vaddr:\r\nkfree(pcc_doorbell_vaddr);\r\nerr_free_mbox:\r\nkfree(pcc_mbox_channels);\r\nreturn rc;\r\n}\r\nstatic int pcc_mbox_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\npcc_mbox_ctrl.chans = pcc_mbox_channels;\r\npcc_mbox_ctrl.ops = &pcc_chan_ops;\r\npcc_mbox_ctrl.dev = &pdev->dev;\r\npr_info("Registering PCC driver as Mailbox controller\n");\r\nret = mbox_controller_register(&pcc_mbox_ctrl);\r\nif (ret) {\r\npr_err("Err registering PCC as Mailbox controller: %d\n", ret);\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init pcc_init(void)\r\n{\r\nint ret;\r\nstruct platform_device *pcc_pdev;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nret = acpi_pcc_probe();\r\nif (ret) {\r\npr_debug("ACPI PCC probe failed.\n");\r\nreturn -ENODEV;\r\n}\r\npcc_pdev = platform_create_bundle(&pcc_mbox_driver,\r\npcc_mbox_probe, NULL, 0, NULL, 0);\r\nif (IS_ERR(pcc_pdev)) {\r\npr_debug("Err creating PCC platform bundle\n");\r\nreturn PTR_ERR(pcc_pdev);\r\n}\r\nreturn 0;\r\n}
