static bool nsec_valid(long nsec)\r\n{\r\nif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\r\nreturn true;\r\nreturn nsec >= 0 && nsec <= 999999999;\r\n}\r\nstatic int utimes_common(const struct path *path, struct timespec *times)\r\n{\r\nint error;\r\nstruct iattr newattrs;\r\nstruct inode *inode = path->dentry->d_inode;\r\nstruct inode *delegated_inode = NULL;\r\nerror = mnt_want_write(path->mnt);\r\nif (error)\r\ngoto out;\r\nif (times && times[0].tv_nsec == UTIME_NOW &&\r\ntimes[1].tv_nsec == UTIME_NOW)\r\ntimes = NULL;\r\nnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\r\nif (times) {\r\nif (times[0].tv_nsec == UTIME_OMIT)\r\nnewattrs.ia_valid &= ~ATTR_ATIME;\r\nelse if (times[0].tv_nsec != UTIME_NOW) {\r\nnewattrs.ia_atime.tv_sec = times[0].tv_sec;\r\nnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\r\nnewattrs.ia_valid |= ATTR_ATIME_SET;\r\n}\r\nif (times[1].tv_nsec == UTIME_OMIT)\r\nnewattrs.ia_valid &= ~ATTR_MTIME;\r\nelse if (times[1].tv_nsec != UTIME_NOW) {\r\nnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\r\nnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\r\nnewattrs.ia_valid |= ATTR_MTIME_SET;\r\n}\r\nnewattrs.ia_valid |= ATTR_TIMES_SET;\r\n} else {\r\nnewattrs.ia_valid |= ATTR_TOUCH;\r\n}\r\nretry_deleg:\r\ninode_lock(inode);\r\nerror = notify_change(path->dentry, &newattrs, &delegated_inode);\r\ninode_unlock(inode);\r\nif (delegated_inode) {\r\nerror = break_deleg_wait(&delegated_inode);\r\nif (!error)\r\ngoto retry_deleg;\r\n}\r\nmnt_drop_write(path->mnt);\r\nout:\r\nreturn error;\r\n}\r\nlong do_utimes(int dfd, const char __user *filename, struct timespec *times,\r\nint flags)\r\n{\r\nint error = -EINVAL;\r\nif (times && (!nsec_valid(times[0].tv_nsec) ||\r\n!nsec_valid(times[1].tv_nsec))) {\r\ngoto out;\r\n}\r\nif (flags & ~AT_SYMLINK_NOFOLLOW)\r\ngoto out;\r\nif (filename == NULL && dfd != AT_FDCWD) {\r\nstruct fd f;\r\nif (flags & AT_SYMLINK_NOFOLLOW)\r\ngoto out;\r\nf = fdget(dfd);\r\nerror = -EBADF;\r\nif (!f.file)\r\ngoto out;\r\nerror = utimes_common(&f.file->f_path, times);\r\nfdput(f);\r\n} else {\r\nstruct path path;\r\nint lookup_flags = 0;\r\nif (!(flags & AT_SYMLINK_NOFOLLOW))\r\nlookup_flags |= LOOKUP_FOLLOW;\r\nretry:\r\nerror = user_path_at(dfd, filename, lookup_flags, &path);\r\nif (error)\r\ngoto out;\r\nerror = utimes_common(&path, times);\r\npath_put(&path);\r\nif (retry_estale(error, lookup_flags)) {\r\nlookup_flags |= LOOKUP_REVAL;\r\ngoto retry;\r\n}\r\n}\r\nout:\r\nreturn error;\r\n}
