static void usbip_usage(void)\r\n{\r\nprintf("usage: %s", usbip_usage_string);\r\n}\r\nstatic int usbip_help(int argc, char *argv[])\r\n{\r\nconst struct command *cmd;\r\nint i;\r\nint ret = 0;\r\nif (argc > 1 && argv++) {\r\nfor (i = 0; cmds[i].name != NULL; i++)\r\nif (!strcmp(cmds[i].name, argv[0]) && cmds[i].usage) {\r\ncmds[i].usage();\r\ngoto done;\r\n}\r\nret = -1;\r\n}\r\nusbip_usage();\r\nprintf("\n");\r\nfor (cmd = cmds; cmd->name != NULL; cmd++)\r\nif (cmd->help != NULL)\r\nprintf(" %-10s %s\n", cmd->name, cmd->help);\r\nprintf("\n");\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int usbip_version(int argc, char *argv[])\r\n{\r\n(void) argc;\r\n(void) argv;\r\nprintf(PROGNAME " (%s)\n", usbip_version_string);\r\nreturn 0;\r\n}\r\nstatic int run_command(const struct command *cmd, int argc, char *argv[])\r\n{\r\ndbg("running command: `%s'", cmd->name);\r\nreturn cmd->fn(argc, argv);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "debug", no_argument, NULL, 'd' },\r\n{ "log", no_argument, NULL, 'l' },\r\n{ "tcp-port", required_argument, NULL, 't' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nchar *cmd;\r\nint opt;\r\nint i, rc = -1;\r\nusbip_use_stderr = 1;\r\nopterr = 0;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "+dlt:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'd':\r\nusbip_use_debug = 1;\r\nbreak;\r\ncase 'l':\r\nusbip_use_syslog = 1;\r\nopenlog("", LOG_PID, LOG_USER);\r\nbreak;\r\ncase 't':\r\nusbip_setup_port_number(optarg);\r\nbreak;\r\ncase '?':\r\nprintf("usbip: invalid option\n");\r\ndefault:\r\nusbip_usage();\r\ngoto out;\r\n}\r\n}\r\ncmd = argv[optind];\r\nif (cmd) {\r\nfor (i = 0; cmds[i].name != NULL; i++)\r\nif (!strcmp(cmds[i].name, cmd)) {\r\nargc -= optind;\r\nargv += optind;\r\noptind = 0;\r\nrc = run_command(&cmds[i], argc, argv);\r\ngoto out;\r\n}\r\n}\r\nusbip_help(0, NULL);\r\nout:\r\nreturn (rc > -1 ? EXIT_SUCCESS : EXIT_FAILURE);\r\n}
