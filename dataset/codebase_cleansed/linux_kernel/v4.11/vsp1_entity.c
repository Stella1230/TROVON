static inline struct vsp1_entity *\r\nmedia_entity_to_vsp1_entity(struct media_entity *entity)\r\n{\r\nreturn container_of(entity, struct vsp1_entity, subdev.entity);\r\n}\r\nvoid vsp1_entity_route_setup(struct vsp1_entity *source,\r\nstruct vsp1_dl_list *dl)\r\n{\r\nstruct vsp1_entity *sink;\r\nif (source->route->reg == 0)\r\nreturn;\r\nsink = media_entity_to_vsp1_entity(source->sink);\r\nvsp1_dl_list_write(dl, source->route->reg,\r\nsink->route->inputs[source->sink_pad]);\r\n}\r\nstruct v4l2_subdev_pad_config *\r\nvsp1_entity_get_pad_config(struct vsp1_entity *entity,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn entity->config;\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\ndefault:\r\nreturn cfg;\r\n}\r\n}\r\nstruct v4l2_mbus_framefmt *\r\nvsp1_entity_get_pad_format(struct vsp1_entity *entity,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad)\r\n{\r\nreturn v4l2_subdev_get_try_format(&entity->subdev, cfg, pad);\r\n}\r\nstruct v4l2_rect *\r\nvsp1_entity_get_pad_selection(struct vsp1_entity *entity,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nunsigned int pad, unsigned int target)\r\n{\r\nswitch (target) {\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nreturn v4l2_subdev_get_try_compose(&entity->subdev, cfg, pad);\r\ncase V4L2_SEL_TGT_CROP:\r\nreturn v4l2_subdev_get_try_crop(&entity->subdev, cfg, pad);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nint vsp1_entity_init_cfg(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg)\r\n{\r\nstruct v4l2_subdev_format format;\r\nunsigned int pad;\r\nfor (pad = 0; pad < subdev->entity.num_pads - 1; ++pad) {\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = pad;\r\nformat.which = cfg ? V4L2_SUBDEV_FORMAT_TRY\r\n: V4L2_SUBDEV_FORMAT_ACTIVE;\r\nv4l2_subdev_call(subdev, pad, set_fmt, cfg, &format);\r\n}\r\nreturn 0;\r\n}\r\nint vsp1_subdev_get_pad_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_entity *entity = to_vsp1_entity(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nconfig = vsp1_entity_get_pad_config(entity, cfg, fmt->which);\r\nif (!config)\r\nreturn -EINVAL;\r\nmutex_lock(&entity->lock);\r\nfmt->format = *vsp1_entity_get_pad_format(entity, config, fmt->pad);\r\nmutex_unlock(&entity->lock);\r\nreturn 0;\r\n}\r\nint vsp1_subdev_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code,\r\nconst unsigned int *codes, unsigned int ncodes)\r\n{\r\nstruct vsp1_entity *entity = to_vsp1_entity(subdev);\r\nif (code->pad == 0) {\r\nif (code->index >= ncodes)\r\nreturn -EINVAL;\r\ncode->code = codes[code->index];\r\n} else {\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->index)\r\nreturn -EINVAL;\r\nconfig = vsp1_entity_get_pad_config(entity, cfg, code->which);\r\nif (!config)\r\nreturn -EINVAL;\r\nmutex_lock(&entity->lock);\r\nformat = vsp1_entity_get_pad_format(entity, config, 0);\r\ncode->code = format->code;\r\nmutex_unlock(&entity->lock);\r\n}\r\nreturn 0;\r\n}\r\nint vsp1_subdev_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse,\r\nunsigned int min_width, unsigned int min_height,\r\nunsigned int max_width, unsigned int max_height)\r\n{\r\nstruct vsp1_entity *entity = to_vsp1_entity(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nconfig = vsp1_entity_get_pad_config(entity, cfg, fse->which);\r\nif (!config)\r\nreturn -EINVAL;\r\nformat = vsp1_entity_get_pad_format(entity, config, fse->pad);\r\nmutex_lock(&entity->lock);\r\nif (fse->index || fse->code != format->code) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (fse->pad == 0) {\r\nfse->min_width = min_width;\r\nfse->max_width = max_width;\r\nfse->min_height = min_height;\r\nfse->max_height = max_height;\r\n} else {\r\nfse->min_width = format->width;\r\nfse->max_width = format->width;\r\nfse->min_height = format->height;\r\nfse->max_height = format->height;\r\n}\r\ndone:\r\nmutex_unlock(&entity->lock);\r\nreturn ret;\r\n}\r\nint vsp1_entity_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct vsp1_entity *source;\r\nif (!(local->flags & MEDIA_PAD_FL_SOURCE))\r\nreturn 0;\r\nsource = media_entity_to_vsp1_entity(local->entity);\r\nif (!source->route)\r\nreturn 0;\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (source->sink)\r\nreturn -EBUSY;\r\nsource->sink = remote->entity;\r\nsource->sink_pad = remote->index;\r\n} else {\r\nsource->sink = NULL;\r\nsource->sink_pad = 0;\r\n}\r\nreturn 0;\r\n}\r\nint vsp1_entity_init(struct vsp1_device *vsp1, struct vsp1_entity *entity,\r\nconst char *name, unsigned int num_pads,\r\nconst struct v4l2_subdev_ops *ops, u32 function)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(vsp1_routes); ++i) {\r\nif (vsp1_routes[i].type == entity->type &&\r\nvsp1_routes[i].index == entity->index) {\r\nentity->route = &vsp1_routes[i];\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(vsp1_routes))\r\nreturn -EINVAL;\r\nmutex_init(&entity->lock);\r\nentity->vsp1 = vsp1;\r\nentity->source_pad = num_pads - 1;\r\nentity->pads = devm_kzalloc(vsp1->dev, num_pads * sizeof(*entity->pads),\r\nGFP_KERNEL);\r\nif (entity->pads == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_pads - 1; ++i)\r\nentity->pads[i].flags = MEDIA_PAD_FL_SINK;\r\nentity->pads[num_pads - 1].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_pads_init(&entity->subdev.entity, num_pads,\r\nentity->pads);\r\nif (ret < 0)\r\nreturn ret;\r\nsubdev = &entity->subdev;\r\nv4l2_subdev_init(subdev, ops);\r\nsubdev->entity.function = function;\r\nsubdev->entity.ops = &vsp1->media_ops;\r\nsubdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsnprintf(subdev->name, sizeof(subdev->name), "%s %s",\r\ndev_name(vsp1->dev), name);\r\nvsp1_entity_init_cfg(subdev, NULL);\r\nentity->config = v4l2_subdev_alloc_pad_config(&entity->subdev);\r\nif (entity->config == NULL) {\r\nmedia_entity_cleanup(&entity->subdev.entity);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid vsp1_entity_destroy(struct vsp1_entity *entity)\r\n{\r\nif (entity->ops && entity->ops->destroy)\r\nentity->ops->destroy(entity);\r\nif (entity->subdev.ctrl_handler)\r\nv4l2_ctrl_handler_free(entity->subdev.ctrl_handler);\r\nv4l2_subdev_free_pad_config(entity->config);\r\nmedia_entity_cleanup(&entity->subdev.entity);\r\n}
