static inline unsigned int reg_enable(struct bcm6345_l1_chip *intc,\r\nunsigned int word)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nreturn (1 * intc->n_words - word - 1) * sizeof(u32);\r\n#else\r\nreturn (0 * intc->n_words + word) * sizeof(u32);\r\n#endif\r\n}\r\nstatic inline unsigned int reg_status(struct bcm6345_l1_chip *intc,\r\nunsigned int word)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nreturn (2 * intc->n_words - word - 1) * sizeof(u32);\r\n#else\r\nreturn (1 * intc->n_words + word) * sizeof(u32);\r\n#endif\r\n}\r\nstatic inline unsigned int cpu_for_irq(struct bcm6345_l1_chip *intc,\r\nstruct irq_data *d)\r\n{\r\nreturn cpumask_first_and(&intc->cpumask, irq_data_get_affinity_mask(d));\r\n}\r\nstatic void bcm6345_l1_irq_handle(struct irq_desc *desc)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_desc_get_handler_data(desc);\r\nstruct bcm6345_l1_cpu *cpu;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int idx;\r\n#ifdef CONFIG_SMP\r\ncpu = intc->cpus[cpu_logical_map(smp_processor_id())];\r\n#else\r\ncpu = intc->cpus[0];\r\n#endif\r\nchained_irq_enter(chip, desc);\r\nfor (idx = 0; idx < intc->n_words; idx++) {\r\nint base = idx * IRQS_PER_WORD;\r\nunsigned long pending;\r\nirq_hw_number_t hwirq;\r\nunsigned int irq;\r\npending = __raw_readl(cpu->map_base + reg_status(intc, idx));\r\npending &= __raw_readl(cpu->map_base + reg_enable(intc, idx));\r\nfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD) {\r\nirq = irq_linear_revmap(intc->domain, base + hwirq);\r\nif (irq)\r\ndo_IRQ(irq);\r\nelse\r\nspurious_interrupt();\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic inline void __bcm6345_l1_unmask(struct irq_data *d)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nu32 word = d->hwirq / IRQS_PER_WORD;\r\nu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\r\nunsigned int cpu_idx = cpu_for_irq(intc, d);\r\nintc->cpus[cpu_idx]->enable_cache[word] |= mask;\r\n__raw_writel(intc->cpus[cpu_idx]->enable_cache[word],\r\nintc->cpus[cpu_idx]->map_base + reg_enable(intc, word));\r\n}\r\nstatic inline void __bcm6345_l1_mask(struct irq_data *d)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nu32 word = d->hwirq / IRQS_PER_WORD;\r\nu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\r\nunsigned int cpu_idx = cpu_for_irq(intc, d);\r\nintc->cpus[cpu_idx]->enable_cache[word] &= ~mask;\r\n__raw_writel(intc->cpus[cpu_idx]->enable_cache[word],\r\nintc->cpus[cpu_idx]->map_base + reg_enable(intc, word));\r\n}\r\nstatic void bcm6345_l1_unmask(struct irq_data *d)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\n__bcm6345_l1_unmask(d);\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\n}\r\nstatic void bcm6345_l1_mask(struct irq_data *d)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\n__bcm6345_l1_mask(d);\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\n}\r\nstatic int bcm6345_l1_set_affinity(struct irq_data *d,\r\nconst struct cpumask *dest,\r\nbool force)\r\n{\r\nstruct bcm6345_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nu32 word = d->hwirq / IRQS_PER_WORD;\r\nu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\r\nunsigned int old_cpu = cpu_for_irq(intc, d);\r\nunsigned int new_cpu;\r\nstruct cpumask valid;\r\nunsigned long flags;\r\nbool enabled;\r\nif (!cpumask_and(&valid, &intc->cpumask, dest))\r\nreturn -EINVAL;\r\nnew_cpu = cpumask_any_and(&valid, cpu_online_mask);\r\nif (new_cpu >= nr_cpu_ids)\r\nreturn -EINVAL;\r\ndest = cpumask_of(new_cpu);\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\nif (old_cpu != new_cpu) {\r\nenabled = intc->cpus[old_cpu]->enable_cache[word] & mask;\r\nif (enabled)\r\n__bcm6345_l1_mask(d);\r\ncpumask_copy(irq_data_get_affinity_mask(d), dest);\r\nif (enabled)\r\n__bcm6345_l1_unmask(d);\r\n} else {\r\ncpumask_copy(irq_data_get_affinity_mask(d), dest);\r\n}\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nstatic int __init bcm6345_l1_init_one(struct device_node *dn,\r\nunsigned int idx,\r\nstruct bcm6345_l1_chip *intc)\r\n{\r\nstruct resource res;\r\nresource_size_t sz;\r\nstruct bcm6345_l1_cpu *cpu;\r\nunsigned int i, n_words;\r\nif (of_address_to_resource(dn, idx, &res))\r\nreturn -EINVAL;\r\nsz = resource_size(&res);\r\nn_words = sz / REG_BYTES_PER_IRQ_WORD;\r\nif (!intc->n_words)\r\nintc->n_words = n_words;\r\nelse if (intc->n_words != n_words)\r\nreturn -EINVAL;\r\ncpu = intc->cpus[idx] = kzalloc(sizeof(*cpu) + n_words * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!cpu)\r\nreturn -ENOMEM;\r\ncpu->map_base = ioremap(res.start, sz);\r\nif (!cpu->map_base)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_words; i++) {\r\ncpu->enable_cache[i] = 0;\r\n__raw_writel(0, cpu->map_base + reg_enable(intc, i));\r\n}\r\ncpu->parent_irq = irq_of_parse_and_map(dn, idx);\r\nif (!cpu->parent_irq) {\r\npr_err("failed to map parent interrupt %d\n", cpu->parent_irq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_chained_handler_and_data(cpu->parent_irq,\r\nbcm6345_l1_irq_handle, intc);\r\nreturn 0;\r\n}\r\nstatic int bcm6345_l1_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw_irq)\r\n{\r\nirq_set_chip_and_handler(virq,\r\n&bcm6345_l1_irq_chip, handle_percpu_irq);\r\nirq_set_chip_data(virq, d->host_data);\r\nreturn 0;\r\n}\r\nstatic int __init bcm6345_l1_of_init(struct device_node *dn,\r\nstruct device_node *parent)\r\n{\r\nstruct bcm6345_l1_chip *intc;\r\nunsigned int idx;\r\nint ret;\r\nintc = kzalloc(sizeof(*intc), GFP_KERNEL);\r\nif (!intc)\r\nreturn -ENOMEM;\r\nfor_each_possible_cpu(idx) {\r\nret = bcm6345_l1_init_one(dn, idx, intc);\r\nif (ret)\r\npr_err("failed to init intc L1 for cpu %d: %d\n",\r\nidx, ret);\r\nelse\r\ncpumask_set_cpu(idx, &intc->cpumask);\r\n}\r\nif (!cpumask_weight(&intc->cpumask)) {\r\nret = -ENODEV;\r\ngoto out_free;\r\n}\r\nraw_spin_lock_init(&intc->lock);\r\nintc->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * intc->n_words,\r\n&bcm6345_l1_domain_ops,\r\nintc);\r\nif (!intc->domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\npr_info("registered BCM6345 L1 intc (IRQs: %d)\n",\r\nIRQS_PER_WORD * intc->n_words);\r\nfor_each_cpu(idx, &intc->cpumask) {\r\nstruct bcm6345_l1_cpu *cpu = intc->cpus[idx];\r\npr_info(" CPU%u at MMIO 0x%p (irq = %d)\n", idx,\r\ncpu->map_base, cpu->parent_irq);\r\n}\r\nreturn 0;\r\nout_unmap:\r\nfor_each_possible_cpu(idx) {\r\nstruct bcm6345_l1_cpu *cpu = intc->cpus[idx];\r\nif (cpu) {\r\nif (cpu->map_base)\r\niounmap(cpu->map_base);\r\nkfree(cpu);\r\n}\r\n}\r\nout_free:\r\nkfree(intc);\r\nreturn ret;\r\n}
