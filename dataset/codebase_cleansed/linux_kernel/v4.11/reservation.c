int reservation_object_reserve_shared(struct reservation_object *obj)\r\n{\r\nstruct reservation_object_list *fobj, *old;\r\nu32 max;\r\nold = reservation_object_get_list(obj);\r\nif (old && old->shared_max) {\r\nif (old->shared_count < old->shared_max) {\r\nkfree(obj->staged);\r\nobj->staged = NULL;\r\nreturn 0;\r\n} else\r\nmax = old->shared_max * 2;\r\n} else\r\nmax = 4;\r\nfobj = krealloc(obj->staged, offsetof(typeof(*fobj), shared[max]),\r\nGFP_KERNEL);\r\nif (!fobj)\r\nreturn -ENOMEM;\r\nobj->staged = fobj;\r\nfobj->shared_max = max;\r\nreturn 0;\r\n}\r\nstatic void\r\nreservation_object_add_shared_inplace(struct reservation_object *obj,\r\nstruct reservation_object_list *fobj,\r\nstruct dma_fence *fence)\r\n{\r\nu32 i;\r\ndma_fence_get(fence);\r\npreempt_disable();\r\nwrite_seqcount_begin(&obj->seq);\r\nfor (i = 0; i < fobj->shared_count; ++i) {\r\nstruct dma_fence *old_fence;\r\nold_fence = rcu_dereference_protected(fobj->shared[i],\r\nreservation_object_held(obj));\r\nif (old_fence->context == fence->context) {\r\nRCU_INIT_POINTER(fobj->shared[i], fence);\r\nwrite_seqcount_end(&obj->seq);\r\npreempt_enable();\r\ndma_fence_put(old_fence);\r\nreturn;\r\n}\r\n}\r\nRCU_INIT_POINTER(fobj->shared[fobj->shared_count], fence);\r\nfobj->shared_count++;\r\nwrite_seqcount_end(&obj->seq);\r\npreempt_enable();\r\n}\r\nstatic void\r\nreservation_object_add_shared_replace(struct reservation_object *obj,\r\nstruct reservation_object_list *old,\r\nstruct reservation_object_list *fobj,\r\nstruct dma_fence *fence)\r\n{\r\nunsigned i;\r\nstruct dma_fence *old_fence = NULL;\r\ndma_fence_get(fence);\r\nif (!old) {\r\nRCU_INIT_POINTER(fobj->shared[0], fence);\r\nfobj->shared_count = 1;\r\ngoto done;\r\n}\r\nfobj->shared_count = old->shared_count;\r\nfor (i = 0; i < old->shared_count; ++i) {\r\nstruct dma_fence *check;\r\ncheck = rcu_dereference_protected(old->shared[i],\r\nreservation_object_held(obj));\r\nif (!old_fence && check->context == fence->context) {\r\nold_fence = check;\r\nRCU_INIT_POINTER(fobj->shared[i], fence);\r\n} else\r\nRCU_INIT_POINTER(fobj->shared[i], check);\r\n}\r\nif (!old_fence) {\r\nRCU_INIT_POINTER(fobj->shared[fobj->shared_count], fence);\r\nfobj->shared_count++;\r\n}\r\ndone:\r\npreempt_disable();\r\nwrite_seqcount_begin(&obj->seq);\r\nRCU_INIT_POINTER(obj->fence, fobj);\r\nwrite_seqcount_end(&obj->seq);\r\npreempt_enable();\r\nif (old)\r\nkfree_rcu(old, rcu);\r\nif (old_fence)\r\ndma_fence_put(old_fence);\r\n}\r\nvoid reservation_object_add_shared_fence(struct reservation_object *obj,\r\nstruct dma_fence *fence)\r\n{\r\nstruct reservation_object_list *old, *fobj = obj->staged;\r\nold = reservation_object_get_list(obj);\r\nobj->staged = NULL;\r\nif (!fobj) {\r\nBUG_ON(old->shared_count >= old->shared_max);\r\nreservation_object_add_shared_inplace(obj, old, fence);\r\n} else\r\nreservation_object_add_shared_replace(obj, old, fobj, fence);\r\n}\r\nvoid reservation_object_add_excl_fence(struct reservation_object *obj,\r\nstruct dma_fence *fence)\r\n{\r\nstruct dma_fence *old_fence = reservation_object_get_excl(obj);\r\nstruct reservation_object_list *old;\r\nu32 i = 0;\r\nold = reservation_object_get_list(obj);\r\nif (old)\r\ni = old->shared_count;\r\nif (fence)\r\ndma_fence_get(fence);\r\npreempt_disable();\r\nwrite_seqcount_begin(&obj->seq);\r\nRCU_INIT_POINTER(obj->fence_excl, fence);\r\nif (old)\r\nold->shared_count = 0;\r\nwrite_seqcount_end(&obj->seq);\r\npreempt_enable();\r\nwhile (i--)\r\ndma_fence_put(rcu_dereference_protected(old->shared[i],\r\nreservation_object_held(obj)));\r\nif (old_fence)\r\ndma_fence_put(old_fence);\r\n}\r\nint reservation_object_get_fences_rcu(struct reservation_object *obj,\r\nstruct dma_fence **pfence_excl,\r\nunsigned *pshared_count,\r\nstruct dma_fence ***pshared)\r\n{\r\nstruct dma_fence **shared = NULL;\r\nstruct dma_fence *fence_excl;\r\nunsigned int shared_count;\r\nint ret = 1;\r\ndo {\r\nstruct reservation_object_list *fobj;\r\nunsigned seq;\r\nunsigned int i;\r\nshared_count = i = 0;\r\nrcu_read_lock();\r\nseq = read_seqcount_begin(&obj->seq);\r\nfence_excl = rcu_dereference(obj->fence_excl);\r\nif (fence_excl && !dma_fence_get_rcu(fence_excl))\r\ngoto unlock;\r\nfobj = rcu_dereference(obj->fence);\r\nif (fobj) {\r\nstruct dma_fence **nshared;\r\nsize_t sz = sizeof(*shared) * fobj->shared_max;\r\nnshared = krealloc(shared, sz,\r\nGFP_NOWAIT | __GFP_NOWARN);\r\nif (!nshared) {\r\nrcu_read_unlock();\r\nnshared = krealloc(shared, sz, GFP_KERNEL);\r\nif (nshared) {\r\nshared = nshared;\r\ncontinue;\r\n}\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nshared = nshared;\r\nshared_count = fobj->shared_count;\r\nfor (i = 0; i < shared_count; ++i) {\r\nshared[i] = rcu_dereference(fobj->shared[i]);\r\nif (!dma_fence_get_rcu(shared[i]))\r\nbreak;\r\n}\r\n}\r\nif (i != shared_count || read_seqcount_retry(&obj->seq, seq)) {\r\nwhile (i--)\r\ndma_fence_put(shared[i]);\r\ndma_fence_put(fence_excl);\r\ngoto unlock;\r\n}\r\nret = 0;\r\nunlock:\r\nrcu_read_unlock();\r\n} while (ret);\r\nif (!shared_count) {\r\nkfree(shared);\r\nshared = NULL;\r\n}\r\n*pshared_count = shared_count;\r\n*pshared = shared;\r\n*pfence_excl = fence_excl;\r\nreturn ret;\r\n}\r\nlong reservation_object_wait_timeout_rcu(struct reservation_object *obj,\r\nbool wait_all, bool intr,\r\nunsigned long timeout)\r\n{\r\nstruct dma_fence *fence;\r\nunsigned seq, shared_count, i = 0;\r\nlong ret = timeout ? timeout : 1;\r\nretry:\r\nfence = NULL;\r\nshared_count = 0;\r\nseq = read_seqcount_begin(&obj->seq);\r\nrcu_read_lock();\r\nif (wait_all) {\r\nstruct reservation_object_list *fobj =\r\nrcu_dereference(obj->fence);\r\nif (fobj)\r\nshared_count = fobj->shared_count;\r\nfor (i = 0; i < shared_count; ++i) {\r\nstruct dma_fence *lfence = rcu_dereference(fobj->shared[i]);\r\nif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT,\r\n&lfence->flags))\r\ncontinue;\r\nif (!dma_fence_get_rcu(lfence))\r\ngoto unlock_retry;\r\nif (dma_fence_is_signaled(lfence)) {\r\ndma_fence_put(lfence);\r\ncontinue;\r\n}\r\nfence = lfence;\r\nbreak;\r\n}\r\n}\r\nif (!shared_count) {\r\nstruct dma_fence *fence_excl = rcu_dereference(obj->fence_excl);\r\nif (fence_excl &&\r\n!test_bit(DMA_FENCE_FLAG_SIGNALED_BIT,\r\n&fence_excl->flags)) {\r\nif (!dma_fence_get_rcu(fence_excl))\r\ngoto unlock_retry;\r\nif (dma_fence_is_signaled(fence_excl))\r\ndma_fence_put(fence_excl);\r\nelse\r\nfence = fence_excl;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (fence) {\r\nif (read_seqcount_retry(&obj->seq, seq)) {\r\ndma_fence_put(fence);\r\ngoto retry;\r\n}\r\nret = dma_fence_wait_timeout(fence, intr, ret);\r\ndma_fence_put(fence);\r\nif (ret > 0 && wait_all && (i + 1 < shared_count))\r\ngoto retry;\r\n}\r\nreturn ret;\r\nunlock_retry:\r\nrcu_read_unlock();\r\ngoto retry;\r\n}\r\nstatic inline int\r\nreservation_object_test_signaled_single(struct dma_fence *passed_fence)\r\n{\r\nstruct dma_fence *fence, *lfence = passed_fence;\r\nint ret = 1;\r\nif (!test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &lfence->flags)) {\r\nfence = dma_fence_get_rcu(lfence);\r\nif (!fence)\r\nreturn -1;\r\nret = !!dma_fence_is_signaled(fence);\r\ndma_fence_put(fence);\r\n}\r\nreturn ret;\r\n}\r\nbool reservation_object_test_signaled_rcu(struct reservation_object *obj,\r\nbool test_all)\r\n{\r\nunsigned seq, shared_count;\r\nint ret;\r\nrcu_read_lock();\r\nretry:\r\nret = true;\r\nshared_count = 0;\r\nseq = read_seqcount_begin(&obj->seq);\r\nif (test_all) {\r\nunsigned i;\r\nstruct reservation_object_list *fobj =\r\nrcu_dereference(obj->fence);\r\nif (fobj)\r\nshared_count = fobj->shared_count;\r\nfor (i = 0; i < shared_count; ++i) {\r\nstruct dma_fence *fence = rcu_dereference(fobj->shared[i]);\r\nret = reservation_object_test_signaled_single(fence);\r\nif (ret < 0)\r\ngoto retry;\r\nelse if (!ret)\r\nbreak;\r\n}\r\nif (read_seqcount_retry(&obj->seq, seq))\r\ngoto retry;\r\n}\r\nif (!shared_count) {\r\nstruct dma_fence *fence_excl = rcu_dereference(obj->fence_excl);\r\nif (fence_excl) {\r\nret = reservation_object_test_signaled_single(\r\nfence_excl);\r\nif (ret < 0)\r\ngoto retry;\r\nif (read_seqcount_retry(&obj->seq, seq))\r\ngoto retry;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}
