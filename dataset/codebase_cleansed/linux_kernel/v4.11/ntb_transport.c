static int ntb_transport_bus_match(struct device *dev,\r\nstruct device_driver *drv)\r\n{\r\nreturn !strncmp(dev_name(dev), drv->name, strlen(drv->name));\r\n}\r\nstatic int ntb_transport_bus_probe(struct device *dev)\r\n{\r\nconst struct ntb_transport_client *client;\r\nint rc = -EINVAL;\r\nget_device(dev);\r\nclient = drv_client(dev->driver);\r\nrc = client->probe(dev);\r\nif (rc)\r\nput_device(dev);\r\nreturn rc;\r\n}\r\nstatic int ntb_transport_bus_remove(struct device *dev)\r\n{\r\nconst struct ntb_transport_client *client;\r\nclient = drv_client(dev->driver);\r\nclient->remove(dev);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int ntb_bus_init(struct ntb_transport_ctx *nt)\r\n{\r\nlist_add_tail(&nt->entry, &ntb_transport_list);\r\nreturn 0;\r\n}\r\nstatic void ntb_bus_remove(struct ntb_transport_ctx *nt)\r\n{\r\nstruct ntb_transport_client_dev *client_dev, *cd;\r\nlist_for_each_entry_safe(client_dev, cd, &nt->client_devs, entry) {\r\ndev_err(client_dev->dev.parent, "%s still attached to bus, removing\n",\r\ndev_name(&client_dev->dev));\r\nlist_del(&client_dev->entry);\r\ndevice_unregister(&client_dev->dev);\r\n}\r\nlist_del(&nt->entry);\r\n}\r\nstatic void ntb_transport_client_release(struct device *dev)\r\n{\r\nstruct ntb_transport_client_dev *client_dev;\r\nclient_dev = dev_client_dev(dev);\r\nkfree(client_dev);\r\n}\r\nvoid ntb_transport_unregister_client_dev(char *device_name)\r\n{\r\nstruct ntb_transport_client_dev *client, *cd;\r\nstruct ntb_transport_ctx *nt;\r\nlist_for_each_entry(nt, &ntb_transport_list, entry)\r\nlist_for_each_entry_safe(client, cd, &nt->client_devs, entry)\r\nif (!strncmp(dev_name(&client->dev), device_name,\r\nstrlen(device_name))) {\r\nlist_del(&client->entry);\r\ndevice_unregister(&client->dev);\r\n}\r\n}\r\nint ntb_transport_register_client_dev(char *device_name)\r\n{\r\nstruct ntb_transport_client_dev *client_dev;\r\nstruct ntb_transport_ctx *nt;\r\nint node;\r\nint rc, i = 0;\r\nif (list_empty(&ntb_transport_list))\r\nreturn -ENODEV;\r\nlist_for_each_entry(nt, &ntb_transport_list, entry) {\r\nstruct device *dev;\r\nnode = dev_to_node(&nt->ndev->dev);\r\nclient_dev = kzalloc_node(sizeof(*client_dev),\r\nGFP_KERNEL, node);\r\nif (!client_dev) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\ndev = &client_dev->dev;\r\ndev_set_name(dev, "%s%d", device_name, i);\r\ndev->bus = &ntb_transport_bus;\r\ndev->release = ntb_transport_client_release;\r\ndev->parent = &nt->ndev->dev;\r\nrc = device_register(dev);\r\nif (rc) {\r\nkfree(client_dev);\r\ngoto err;\r\n}\r\nlist_add_tail(&client_dev->entry, &nt->client_devs);\r\ni++;\r\n}\r\nreturn 0;\r\nerr:\r\nntb_transport_unregister_client_dev(device_name);\r\nreturn rc;\r\n}\r\nint ntb_transport_register_client(struct ntb_transport_client *drv)\r\n{\r\ndrv->driver.bus = &ntb_transport_bus;\r\nif (list_empty(&ntb_transport_list))\r\nreturn -ENODEV;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid ntb_transport_unregister_client(struct ntb_transport_client *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic ssize_t debugfs_read(struct file *filp, char __user *ubuf, size_t count,\r\nloff_t *offp)\r\n{\r\nstruct ntb_transport_qp *qp;\r\nchar *buf;\r\nssize_t ret, out_offset, out_count;\r\nqp = filp->private_data;\r\nif (!qp || !qp->link_is_up)\r\nreturn 0;\r\nout_count = 1000;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nout_offset = 0;\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"\nNTB QP stats:\n\n");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_bytes - \t%llu\n", qp->rx_bytes);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_pkts - \t%llu\n", qp->rx_pkts);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_memcpy - \t%llu\n", qp->rx_memcpy);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_async - \t%llu\n", qp->rx_async);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_ring_empty - %llu\n", qp->rx_ring_empty);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_no_buf - %llu\n", qp->rx_err_no_buf);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_oflow - \t%llu\n", qp->rx_err_oflow);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_ver - \t%llu\n", qp->rx_err_ver);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_buff - \t0x%p\n", qp->rx_buff);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_index - \t%u\n", qp->rx_index);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_max_entry - \t%u\n", qp->rx_max_entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_alloc_entry - \t%u\n\n", qp->rx_alloc_entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_bytes - \t%llu\n", qp->tx_bytes);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_pkts - \t%llu\n", qp->tx_pkts);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_memcpy - \t%llu\n", qp->tx_memcpy);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_async - \t%llu\n", qp->tx_async);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_ring_full - \t%llu\n", qp->tx_ring_full);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_err_no_buf - %llu\n", qp->tx_err_no_buf);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_mw - \t0x%p\n", qp->tx_mw);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_index (H) - \t%u\n", qp->tx_index);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"RRI (T) - \t%u\n",\r\nqp->remote_rx_info->entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_max_entry - \t%u\n", qp->tx_max_entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"free tx - \t%u\n",\r\nntb_transport_tx_free_entry(qp));\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"DMA tx prep err - \t%llu\n",\r\nqp->dma_tx_prep_err);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"DMA rx prep err - \t%llu\n",\r\nqp->dma_rx_prep_err);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"\n");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"Using TX DMA - \t%s\n",\r\nqp->tx_dma_chan ? "Yes" : "No");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"Using RX DMA - \t%s\n",\r\nqp->rx_dma_chan ? "Yes" : "No");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"QP Link - \t%s\n",\r\nqp->link_is_up ? "Up" : "Down");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"\n");\r\nif (out_offset > out_count)\r\nout_offset = out_count;\r\nret = simple_read_from_buffer(ubuf, count, offp, buf, out_offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void ntb_list_add(spinlock_t *lock, struct list_head *entry,\r\nstruct list_head *list)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_add_tail(entry, list);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nstatic struct ntb_queue_entry *ntb_list_rm(spinlock_t *lock,\r\nstruct list_head *list)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nif (list_empty(list)) {\r\nentry = NULL;\r\ngoto out;\r\n}\r\nentry = list_first_entry(list, struct ntb_queue_entry, entry);\r\nlist_del(&entry->entry);\r\nout:\r\nspin_unlock_irqrestore(lock, flags);\r\nreturn entry;\r\n}\r\nstatic struct ntb_queue_entry *ntb_list_mv(spinlock_t *lock,\r\nstruct list_head *list,\r\nstruct list_head *to_list)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nif (list_empty(list)) {\r\nentry = NULL;\r\n} else {\r\nentry = list_first_entry(list, struct ntb_queue_entry, entry);\r\nlist_move_tail(&entry->entry, to_list);\r\n}\r\nspin_unlock_irqrestore(lock, flags);\r\nreturn entry;\r\n}\r\nstatic int ntb_transport_setup_qp_mw(struct ntb_transport_ctx *nt,\r\nunsigned int qp_num)\r\n{\r\nstruct ntb_transport_qp *qp = &nt->qp_vec[qp_num];\r\nstruct ntb_transport_mw *mw;\r\nstruct ntb_dev *ndev = nt->ndev;\r\nstruct ntb_queue_entry *entry;\r\nunsigned int rx_size, num_qps_mw;\r\nunsigned int mw_num, mw_count, qp_count;\r\nunsigned int i;\r\nint node;\r\nmw_count = nt->mw_count;\r\nqp_count = nt->qp_count;\r\nmw_num = QP_TO_MW(nt, qp_num);\r\nmw = &nt->mw_vec[mw_num];\r\nif (!mw->virt_addr)\r\nreturn -ENOMEM;\r\nif (qp_count % mw_count && mw_num + 1 < qp_count / mw_count)\r\nnum_qps_mw = qp_count / mw_count + 1;\r\nelse\r\nnum_qps_mw = qp_count / mw_count;\r\nrx_size = (unsigned int)mw->xlat_size / num_qps_mw;\r\nqp->rx_buff = mw->virt_addr + rx_size * (qp_num / mw_count);\r\nrx_size -= sizeof(struct ntb_rx_info);\r\nqp->remote_rx_info = qp->rx_buff + rx_size;\r\nqp->rx_max_frame = min(transport_mtu, rx_size / 2);\r\nqp->rx_max_entry = rx_size / qp->rx_max_frame;\r\nqp->rx_index = 0;\r\nnode = dev_to_node(&ndev->dev);\r\nfor (i = qp->rx_alloc_entry; i < qp->rx_max_entry; i++) {\r\nentry = kzalloc_node(sizeof(*entry), GFP_ATOMIC, node);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->qp = qp;\r\nntb_list_add(&qp->ntb_rx_q_lock, &entry->entry,\r\n&qp->rx_free_q);\r\nqp->rx_alloc_entry++;\r\n}\r\nqp->remote_rx_info->entry = qp->rx_max_entry - 1;\r\nfor (i = 0; i < qp->rx_max_entry; i++) {\r\nvoid *offset = (qp->rx_buff + qp->rx_max_frame * (i + 1) -\r\nsizeof(struct ntb_payload_header));\r\nmemset(offset, 0, sizeof(struct ntb_payload_header));\r\n}\r\nqp->rx_pkts = 0;\r\nqp->tx_pkts = 0;\r\nqp->tx_index = 0;\r\nreturn 0;\r\n}\r\nstatic void ntb_free_mw(struct ntb_transport_ctx *nt, int num_mw)\r\n{\r\nstruct ntb_transport_mw *mw = &nt->mw_vec[num_mw];\r\nstruct pci_dev *pdev = nt->ndev->pdev;\r\nif (!mw->virt_addr)\r\nreturn;\r\nntb_mw_clear_trans(nt->ndev, num_mw);\r\ndma_free_coherent(&pdev->dev, mw->buff_size,\r\nmw->virt_addr, mw->dma_addr);\r\nmw->xlat_size = 0;\r\nmw->buff_size = 0;\r\nmw->virt_addr = NULL;\r\n}\r\nstatic int ntb_set_mw(struct ntb_transport_ctx *nt, int num_mw,\r\nresource_size_t size)\r\n{\r\nstruct ntb_transport_mw *mw = &nt->mw_vec[num_mw];\r\nstruct pci_dev *pdev = nt->ndev->pdev;\r\nsize_t xlat_size, buff_size;\r\nint rc;\r\nif (!size)\r\nreturn -EINVAL;\r\nxlat_size = round_up(size, mw->xlat_align_size);\r\nbuff_size = round_up(size, mw->xlat_align);\r\nif (mw->xlat_size == xlat_size)\r\nreturn 0;\r\nif (mw->buff_size)\r\nntb_free_mw(nt, num_mw);\r\nmw->xlat_size = xlat_size;\r\nmw->buff_size = buff_size;\r\nmw->virt_addr = dma_alloc_coherent(&pdev->dev, buff_size,\r\n&mw->dma_addr, GFP_KERNEL);\r\nif (!mw->virt_addr) {\r\nmw->xlat_size = 0;\r\nmw->buff_size = 0;\r\ndev_err(&pdev->dev, "Unable to alloc MW buff of size %zu\n",\r\nbuff_size);\r\nreturn -ENOMEM;\r\n}\r\nif (!IS_ALIGNED(mw->dma_addr, mw->xlat_align)) {\r\ndev_err(&pdev->dev, "DMA memory %pad is not aligned\n",\r\n&mw->dma_addr);\r\nntb_free_mw(nt, num_mw);\r\nreturn -ENOMEM;\r\n}\r\nrc = ntb_mw_set_trans(nt->ndev, num_mw, mw->dma_addr, mw->xlat_size);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Unable to set mw%d translation", num_mw);\r\nntb_free_mw(nt, num_mw);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ntb_qp_link_down_reset(struct ntb_transport_qp *qp)\r\n{\r\nqp->link_is_up = false;\r\nqp->active = false;\r\nqp->tx_index = 0;\r\nqp->rx_index = 0;\r\nqp->rx_bytes = 0;\r\nqp->rx_pkts = 0;\r\nqp->rx_ring_empty = 0;\r\nqp->rx_err_no_buf = 0;\r\nqp->rx_err_oflow = 0;\r\nqp->rx_err_ver = 0;\r\nqp->rx_memcpy = 0;\r\nqp->rx_async = 0;\r\nqp->tx_bytes = 0;\r\nqp->tx_pkts = 0;\r\nqp->tx_ring_full = 0;\r\nqp->tx_err_no_buf = 0;\r\nqp->tx_memcpy = 0;\r\nqp->tx_async = 0;\r\nqp->dma_tx_prep_err = 0;\r\nqp->dma_rx_prep_err = 0;\r\n}\r\nstatic void ntb_qp_link_cleanup(struct ntb_transport_qp *qp)\r\n{\r\nstruct ntb_transport_ctx *nt = qp->transport;\r\nstruct pci_dev *pdev = nt->ndev->pdev;\r\ndev_info(&pdev->dev, "qp %d: Link Cleanup\n", qp->qp_num);\r\ncancel_delayed_work_sync(&qp->link_work);\r\nntb_qp_link_down_reset(qp);\r\nif (qp->event_handler)\r\nqp->event_handler(qp->cb_data, qp->link_is_up);\r\n}\r\nstatic void ntb_qp_link_cleanup_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_qp *qp = container_of(work,\r\nstruct ntb_transport_qp,\r\nlink_cleanup);\r\nstruct ntb_transport_ctx *nt = qp->transport;\r\nntb_qp_link_cleanup(qp);\r\nif (nt->link_is_up)\r\nschedule_delayed_work(&qp->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic void ntb_qp_link_down(struct ntb_transport_qp *qp)\r\n{\r\nschedule_work(&qp->link_cleanup);\r\n}\r\nstatic void ntb_transport_link_cleanup(struct ntb_transport_ctx *nt)\r\n{\r\nstruct ntb_transport_qp *qp;\r\nu64 qp_bitmap_alloc;\r\nunsigned int i, count;\r\nqp_bitmap_alloc = nt->qp_bitmap & ~nt->qp_bitmap_free;\r\nfor (i = 0; i < nt->qp_count; i++)\r\nif (qp_bitmap_alloc & BIT_ULL(i)) {\r\nqp = &nt->qp_vec[i];\r\nntb_qp_link_cleanup(qp);\r\ncancel_work_sync(&qp->link_cleanup);\r\ncancel_delayed_work_sync(&qp->link_work);\r\n}\r\nif (!nt->link_is_up)\r\ncancel_delayed_work_sync(&nt->link_work);\r\ncount = ntb_spad_count(nt->ndev);\r\nfor (i = 0; i < count; i++)\r\nntb_spad_write(nt->ndev, i, 0);\r\n}\r\nstatic void ntb_transport_link_cleanup_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_ctx *nt =\r\ncontainer_of(work, struct ntb_transport_ctx, link_cleanup);\r\nntb_transport_link_cleanup(nt);\r\n}\r\nstatic void ntb_transport_event_callback(void *data)\r\n{\r\nstruct ntb_transport_ctx *nt = data;\r\nif (ntb_link_is_up(nt->ndev, NULL, NULL) == 1)\r\nschedule_delayed_work(&nt->link_work, 0);\r\nelse\r\nschedule_work(&nt->link_cleanup);\r\n}\r\nstatic void ntb_transport_link_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_ctx *nt =\r\ncontainer_of(work, struct ntb_transport_ctx, link_work.work);\r\nstruct ntb_dev *ndev = nt->ndev;\r\nstruct pci_dev *pdev = ndev->pdev;\r\nresource_size_t size;\r\nu32 val;\r\nint rc = 0, i, spad;\r\nfor (i = 0; i < nt->mw_count; i++) {\r\nsize = nt->mw_vec[i].phys_size;\r\nif (max_mw_size && size > max_mw_size)\r\nsize = max_mw_size;\r\nspad = MW0_SZ_HIGH + (i * 2);\r\nntb_peer_spad_write(ndev, spad, upper_32_bits(size));\r\nspad = MW0_SZ_LOW + (i * 2);\r\nntb_peer_spad_write(ndev, spad, lower_32_bits(size));\r\n}\r\nntb_peer_spad_write(ndev, NUM_MWS, nt->mw_count);\r\nntb_peer_spad_write(ndev, NUM_QPS, nt->qp_count);\r\nntb_peer_spad_write(ndev, VERSION, NTB_TRANSPORT_VERSION);\r\nval = ntb_spad_read(ndev, VERSION);\r\ndev_dbg(&pdev->dev, "Remote version = %d\n", val);\r\nif (val != NTB_TRANSPORT_VERSION)\r\ngoto out;\r\nval = ntb_spad_read(ndev, NUM_QPS);\r\ndev_dbg(&pdev->dev, "Remote max number of qps = %d\n", val);\r\nif (val != nt->qp_count)\r\ngoto out;\r\nval = ntb_spad_read(ndev, NUM_MWS);\r\ndev_dbg(&pdev->dev, "Remote number of mws = %d\n", val);\r\nif (val != nt->mw_count)\r\ngoto out;\r\nfor (i = 0; i < nt->mw_count; i++) {\r\nu64 val64;\r\nval = ntb_spad_read(ndev, MW0_SZ_HIGH + (i * 2));\r\nval64 = (u64)val << 32;\r\nval = ntb_spad_read(ndev, MW0_SZ_LOW + (i * 2));\r\nval64 |= val;\r\ndev_dbg(&pdev->dev, "Remote MW%d size = %#llx\n", i, val64);\r\nrc = ntb_set_mw(nt, i, val64);\r\nif (rc)\r\ngoto out1;\r\n}\r\nnt->link_is_up = true;\r\nfor (i = 0; i < nt->qp_count; i++) {\r\nstruct ntb_transport_qp *qp = &nt->qp_vec[i];\r\nntb_transport_setup_qp_mw(nt, i);\r\nif (qp->client_ready)\r\nschedule_delayed_work(&qp->link_work, 0);\r\n}\r\nreturn;\r\nout1:\r\nfor (i = 0; i < nt->mw_count; i++)\r\nntb_free_mw(nt, i);\r\nif (rc < 0) {\r\nntb_link_disable(ndev);\r\nreturn;\r\n}\r\nout:\r\nif (ntb_link_is_up(ndev, NULL, NULL) == 1)\r\nschedule_delayed_work(&nt->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic void ntb_qp_link_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_qp *qp = container_of(work,\r\nstruct ntb_transport_qp,\r\nlink_work.work);\r\nstruct pci_dev *pdev = qp->ndev->pdev;\r\nstruct ntb_transport_ctx *nt = qp->transport;\r\nint val;\r\nWARN_ON(!nt->link_is_up);\r\nval = ntb_spad_read(nt->ndev, QP_LINKS);\r\nntb_peer_spad_write(nt->ndev, QP_LINKS, val | BIT(qp->qp_num));\r\ndev_dbg_ratelimited(&pdev->dev, "Remote QP link status = %x\n", val);\r\nif (val & BIT(qp->qp_num)) {\r\ndev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);\r\nqp->link_is_up = true;\r\nqp->active = true;\r\nif (qp->event_handler)\r\nqp->event_handler(qp->cb_data, qp->link_is_up);\r\nif (qp->active)\r\ntasklet_schedule(&qp->rxc_db_work);\r\n} else if (nt->link_is_up)\r\nschedule_delayed_work(&qp->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic int ntb_transport_init_queue(struct ntb_transport_ctx *nt,\r\nunsigned int qp_num)\r\n{\r\nstruct ntb_transport_qp *qp;\r\nphys_addr_t mw_base;\r\nresource_size_t mw_size;\r\nunsigned int num_qps_mw, tx_size;\r\nunsigned int mw_num, mw_count, qp_count;\r\nu64 qp_offset;\r\nmw_count = nt->mw_count;\r\nqp_count = nt->qp_count;\r\nmw_num = QP_TO_MW(nt, qp_num);\r\nqp = &nt->qp_vec[qp_num];\r\nqp->qp_num = qp_num;\r\nqp->transport = nt;\r\nqp->ndev = nt->ndev;\r\nqp->client_ready = false;\r\nqp->event_handler = NULL;\r\nntb_qp_link_down_reset(qp);\r\nif (qp_count % mw_count && mw_num + 1 < qp_count / mw_count)\r\nnum_qps_mw = qp_count / mw_count + 1;\r\nelse\r\nnum_qps_mw = qp_count / mw_count;\r\nmw_base = nt->mw_vec[mw_num].phys_addr;\r\nmw_size = nt->mw_vec[mw_num].phys_size;\r\ntx_size = (unsigned int)mw_size / num_qps_mw;\r\nqp_offset = tx_size * (qp_num / mw_count);\r\nqp->tx_mw = nt->mw_vec[mw_num].vbase + qp_offset;\r\nif (!qp->tx_mw)\r\nreturn -EINVAL;\r\nqp->tx_mw_phys = mw_base + qp_offset;\r\nif (!qp->tx_mw_phys)\r\nreturn -EINVAL;\r\ntx_size -= sizeof(struct ntb_rx_info);\r\nqp->rx_info = qp->tx_mw + tx_size;\r\nqp->tx_max_frame = min(transport_mtu, tx_size / 2);\r\nqp->tx_max_entry = tx_size / qp->tx_max_frame;\r\nif (nt->debugfs_node_dir) {\r\nchar debugfs_name[4];\r\nsnprintf(debugfs_name, 4, "qp%d", qp_num);\r\nqp->debugfs_dir = debugfs_create_dir(debugfs_name,\r\nnt->debugfs_node_dir);\r\nqp->debugfs_stats = debugfs_create_file("stats", S_IRUSR,\r\nqp->debugfs_dir, qp,\r\n&ntb_qp_debugfs_stats);\r\n} else {\r\nqp->debugfs_dir = NULL;\r\nqp->debugfs_stats = NULL;\r\n}\r\nINIT_DELAYED_WORK(&qp->link_work, ntb_qp_link_work);\r\nINIT_WORK(&qp->link_cleanup, ntb_qp_link_cleanup_work);\r\nspin_lock_init(&qp->ntb_rx_q_lock);\r\nspin_lock_init(&qp->ntb_tx_free_q_lock);\r\nINIT_LIST_HEAD(&qp->rx_post_q);\r\nINIT_LIST_HEAD(&qp->rx_pend_q);\r\nINIT_LIST_HEAD(&qp->rx_free_q);\r\nINIT_LIST_HEAD(&qp->tx_free_q);\r\ntasklet_init(&qp->rxc_db_work, ntb_transport_rxc_db,\r\n(unsigned long)qp);\r\nreturn 0;\r\n}\r\nstatic int ntb_transport_probe(struct ntb_client *self, struct ntb_dev *ndev)\r\n{\r\nstruct ntb_transport_ctx *nt;\r\nstruct ntb_transport_mw *mw;\r\nunsigned int mw_count, qp_count, spad_count, max_mw_count_for_spads;\r\nu64 qp_bitmap;\r\nint node;\r\nint rc, i;\r\nmw_count = ntb_mw_count(ndev);\r\nif (ntb_db_is_unsafe(ndev))\r\ndev_dbg(&ndev->dev,\r\n"doorbell is unsafe, proceed anyway...\n");\r\nif (ntb_spad_is_unsafe(ndev))\r\ndev_dbg(&ndev->dev,\r\n"scratchpad is unsafe, proceed anyway...\n");\r\nnode = dev_to_node(&ndev->dev);\r\nnt = kzalloc_node(sizeof(*nt), GFP_KERNEL, node);\r\nif (!nt)\r\nreturn -ENOMEM;\r\nnt->ndev = ndev;\r\nspad_count = ntb_spad_count(ndev);\r\nif (spad_count < NTB_TRANSPORT_MIN_SPADS) {\r\nnt->mw_count = 0;\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nmax_mw_count_for_spads = (spad_count - MW0_SZ_HIGH) / 2;\r\nnt->mw_count = min(mw_count, max_mw_count_for_spads);\r\nnt->mw_vec = kzalloc_node(mw_count * sizeof(*nt->mw_vec),\r\nGFP_KERNEL, node);\r\nif (!nt->mw_vec) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < mw_count; i++) {\r\nmw = &nt->mw_vec[i];\r\nrc = ntb_mw_get_range(ndev, i, &mw->phys_addr, &mw->phys_size,\r\n&mw->xlat_align, &mw->xlat_align_size);\r\nif (rc)\r\ngoto err1;\r\nmw->vbase = ioremap_wc(mw->phys_addr, mw->phys_size);\r\nif (!mw->vbase) {\r\nrc = -ENOMEM;\r\ngoto err1;\r\n}\r\nmw->buff_size = 0;\r\nmw->xlat_size = 0;\r\nmw->virt_addr = NULL;\r\nmw->dma_addr = 0;\r\n}\r\nqp_bitmap = ntb_db_valid_mask(ndev);\r\nqp_count = ilog2(qp_bitmap);\r\nif (max_num_clients && max_num_clients < qp_count)\r\nqp_count = max_num_clients;\r\nelse if (mw_count < qp_count)\r\nqp_count = mw_count;\r\nqp_bitmap &= BIT_ULL(qp_count) - 1;\r\nnt->qp_count = qp_count;\r\nnt->qp_bitmap = qp_bitmap;\r\nnt->qp_bitmap_free = qp_bitmap;\r\nnt->qp_vec = kzalloc_node(qp_count * sizeof(*nt->qp_vec),\r\nGFP_KERNEL, node);\r\nif (!nt->qp_vec) {\r\nrc = -ENOMEM;\r\ngoto err1;\r\n}\r\nif (nt_debugfs_dir) {\r\nnt->debugfs_node_dir =\r\ndebugfs_create_dir(pci_name(ndev->pdev),\r\nnt_debugfs_dir);\r\n}\r\nfor (i = 0; i < qp_count; i++) {\r\nrc = ntb_transport_init_queue(nt, i);\r\nif (rc)\r\ngoto err2;\r\n}\r\nINIT_DELAYED_WORK(&nt->link_work, ntb_transport_link_work);\r\nINIT_WORK(&nt->link_cleanup, ntb_transport_link_cleanup_work);\r\nrc = ntb_set_ctx(ndev, nt, &ntb_transport_ops);\r\nif (rc)\r\ngoto err2;\r\nINIT_LIST_HEAD(&nt->client_devs);\r\nrc = ntb_bus_init(nt);\r\nif (rc)\r\ngoto err3;\r\nnt->link_is_up = false;\r\nntb_link_enable(ndev, NTB_SPEED_AUTO, NTB_WIDTH_AUTO);\r\nntb_link_event(ndev);\r\nreturn 0;\r\nerr3:\r\nntb_clear_ctx(ndev);\r\nerr2:\r\nkfree(nt->qp_vec);\r\nerr1:\r\nwhile (i--) {\r\nmw = &nt->mw_vec[i];\r\niounmap(mw->vbase);\r\n}\r\nkfree(nt->mw_vec);\r\nerr:\r\nkfree(nt);\r\nreturn rc;\r\n}\r\nstatic void ntb_transport_free(struct ntb_client *self, struct ntb_dev *ndev)\r\n{\r\nstruct ntb_transport_ctx *nt = ndev->ctx;\r\nstruct ntb_transport_qp *qp;\r\nu64 qp_bitmap_alloc;\r\nint i;\r\nntb_transport_link_cleanup(nt);\r\ncancel_work_sync(&nt->link_cleanup);\r\ncancel_delayed_work_sync(&nt->link_work);\r\nqp_bitmap_alloc = nt->qp_bitmap & ~nt->qp_bitmap_free;\r\nfor (i = 0; i < nt->qp_count; i++) {\r\nqp = &nt->qp_vec[i];\r\nif (qp_bitmap_alloc & BIT_ULL(i))\r\nntb_transport_free_queue(qp);\r\ndebugfs_remove_recursive(qp->debugfs_dir);\r\n}\r\nntb_link_disable(ndev);\r\nntb_clear_ctx(ndev);\r\nntb_bus_remove(nt);\r\nfor (i = nt->mw_count; i--; ) {\r\nntb_free_mw(nt, i);\r\niounmap(nt->mw_vec[i].vbase);\r\n}\r\nkfree(nt->qp_vec);\r\nkfree(nt->mw_vec);\r\nkfree(nt);\r\n}\r\nstatic void ntb_complete_rxc(struct ntb_transport_qp *qp)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nvoid *cb_data;\r\nunsigned int len;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&qp->ntb_rx_q_lock, irqflags);\r\nwhile (!list_empty(&qp->rx_post_q)) {\r\nentry = list_first_entry(&qp->rx_post_q,\r\nstruct ntb_queue_entry, entry);\r\nif (!(entry->flags & DESC_DONE_FLAG))\r\nbreak;\r\nentry->rx_hdr->flags = 0;\r\niowrite32(entry->rx_index, &qp->rx_info->entry);\r\ncb_data = entry->cb_data;\r\nlen = entry->len;\r\nlist_move_tail(&entry->entry, &qp->rx_free_q);\r\nspin_unlock_irqrestore(&qp->ntb_rx_q_lock, irqflags);\r\nif (qp->rx_handler && qp->client_ready)\r\nqp->rx_handler(qp, qp->cb_data, cb_data, len);\r\nspin_lock_irqsave(&qp->ntb_rx_q_lock, irqflags);\r\n}\r\nspin_unlock_irqrestore(&qp->ntb_rx_q_lock, irqflags);\r\n}\r\nstatic void ntb_rx_copy_callback(void *data,\r\nconst struct dmaengine_result *res)\r\n{\r\nstruct ntb_queue_entry *entry = data;\r\nif (res) {\r\nenum dmaengine_tx_result dma_err = res->result;\r\nswitch (dma_err) {\r\ncase DMA_TRANS_READ_FAILED:\r\ncase DMA_TRANS_WRITE_FAILED:\r\nentry->errors++;\r\ncase DMA_TRANS_ABORTED:\r\n{\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nvoid *offset = qp->rx_buff + qp->rx_max_frame *\r\nqp->rx_index;\r\nntb_memcpy_rx(entry, offset);\r\nqp->rx_memcpy++;\r\nreturn;\r\n}\r\ncase DMA_TRANS_NOERROR:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nentry->flags |= DESC_DONE_FLAG;\r\nntb_complete_rxc(entry->qp);\r\n}\r\nstatic void ntb_memcpy_rx(struct ntb_queue_entry *entry, void *offset)\r\n{\r\nvoid *buf = entry->buf;\r\nsize_t len = entry->len;\r\nmemcpy(buf, offset, len);\r\nwmb();\r\nntb_rx_copy_callback(entry, NULL);\r\n}\r\nstatic int ntb_async_rx_submit(struct ntb_queue_entry *entry, void *offset)\r\n{\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nstruct dma_chan *chan = qp->rx_dma_chan;\r\nstruct dma_device *device;\r\nsize_t pay_off, buff_off, len;\r\nstruct dmaengine_unmap_data *unmap;\r\ndma_cookie_t cookie;\r\nvoid *buf = entry->buf;\r\nint retries = 0;\r\nlen = entry->len;\r\ndevice = chan->device;\r\npay_off = (size_t)offset & ~PAGE_MASK;\r\nbuff_off = (size_t)buf & ~PAGE_MASK;\r\nif (!is_dma_copy_aligned(device, pay_off, buff_off, len))\r\ngoto err;\r\nunmap = dmaengine_get_unmap_data(device->dev, 2, GFP_NOWAIT);\r\nif (!unmap)\r\ngoto err;\r\nunmap->len = len;\r\nunmap->addr[0] = dma_map_page(device->dev, virt_to_page(offset),\r\npay_off, len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[0]))\r\ngoto err_get_unmap;\r\nunmap->to_cnt = 1;\r\nunmap->addr[1] = dma_map_page(device->dev, virt_to_page(buf),\r\nbuff_off, len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[1]))\r\ngoto err_get_unmap;\r\nunmap->from_cnt = 1;\r\nfor (retries = 0; retries < DMA_RETRIES; retries++) {\r\ntxd = device->device_prep_dma_memcpy(chan,\r\nunmap->addr[1],\r\nunmap->addr[0], len,\r\nDMA_PREP_INTERRUPT);\r\nif (txd)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(DMA_OUT_RESOURCE_TO);\r\n}\r\nif (!txd) {\r\nqp->dma_rx_prep_err++;\r\ngoto err_get_unmap;\r\n}\r\ntxd->callback_result = ntb_rx_copy_callback;\r\ntxd->callback_param = entry;\r\ndma_set_unmap(txd, unmap);\r\ncookie = dmaengine_submit(txd);\r\nif (dma_submit_error(cookie))\r\ngoto err_set_unmap;\r\ndmaengine_unmap_put(unmap);\r\nqp->last_cookie = cookie;\r\nqp->rx_async++;\r\nreturn 0;\r\nerr_set_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr_get_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr:\r\nreturn -ENXIO;\r\n}\r\nstatic void ntb_async_rx(struct ntb_queue_entry *entry, void *offset)\r\n{\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nstruct dma_chan *chan = qp->rx_dma_chan;\r\nint res;\r\nif (!chan)\r\ngoto err;\r\nif (entry->len < copy_bytes)\r\ngoto err;\r\nres = ntb_async_rx_submit(entry, offset);\r\nif (res < 0)\r\ngoto err;\r\nif (!entry->retries)\r\nqp->rx_async++;\r\nreturn;\r\nerr:\r\nntb_memcpy_rx(entry, offset);\r\nqp->rx_memcpy++;\r\n}\r\nstatic int ntb_process_rxc(struct ntb_transport_qp *qp)\r\n{\r\nstruct ntb_payload_header *hdr;\r\nstruct ntb_queue_entry *entry;\r\nvoid *offset;\r\noffset = qp->rx_buff + qp->rx_max_frame * qp->rx_index;\r\nhdr = offset + qp->rx_max_frame - sizeof(struct ntb_payload_header);\r\ndev_dbg(&qp->ndev->pdev->dev, "qp %d: RX ver %u len %d flags %x\n",\r\nqp->qp_num, hdr->ver, hdr->len, hdr->flags);\r\nif (!(hdr->flags & DESC_DONE_FLAG)) {\r\ndev_dbg(&qp->ndev->pdev->dev, "done flag not set\n");\r\nqp->rx_ring_empty++;\r\nreturn -EAGAIN;\r\n}\r\nif (hdr->flags & LINK_DOWN_FLAG) {\r\ndev_dbg(&qp->ndev->pdev->dev, "link down flag set\n");\r\nntb_qp_link_down(qp);\r\nhdr->flags = 0;\r\nreturn -EAGAIN;\r\n}\r\nif (hdr->ver != (u32)qp->rx_pkts) {\r\ndev_dbg(&qp->ndev->pdev->dev,\r\n"version mismatch, expected %llu - got %u\n",\r\nqp->rx_pkts, hdr->ver);\r\nqp->rx_err_ver++;\r\nreturn -EIO;\r\n}\r\nentry = ntb_list_mv(&qp->ntb_rx_q_lock, &qp->rx_pend_q, &qp->rx_post_q);\r\nif (!entry) {\r\ndev_dbg(&qp->ndev->pdev->dev, "no receive buffer\n");\r\nqp->rx_err_no_buf++;\r\nreturn -EAGAIN;\r\n}\r\nentry->rx_hdr = hdr;\r\nentry->rx_index = qp->rx_index;\r\nif (hdr->len > entry->len) {\r\ndev_dbg(&qp->ndev->pdev->dev,\r\n"receive buffer overflow! Wanted %d got %d\n",\r\nhdr->len, entry->len);\r\nqp->rx_err_oflow++;\r\nentry->len = -EIO;\r\nentry->flags |= DESC_DONE_FLAG;\r\nntb_complete_rxc(qp);\r\n} else {\r\ndev_dbg(&qp->ndev->pdev->dev,\r\n"RX OK index %u ver %u size %d into buf size %d\n",\r\nqp->rx_index, hdr->ver, hdr->len, entry->len);\r\nqp->rx_bytes += hdr->len;\r\nqp->rx_pkts++;\r\nentry->len = hdr->len;\r\nntb_async_rx(entry, offset);\r\n}\r\nqp->rx_index++;\r\nqp->rx_index %= qp->rx_max_entry;\r\nreturn 0;\r\n}\r\nstatic void ntb_transport_rxc_db(unsigned long data)\r\n{\r\nstruct ntb_transport_qp *qp = (void *)data;\r\nint rc, i;\r\ndev_dbg(&qp->ndev->pdev->dev, "%s: doorbell %d received\n",\r\n__func__, qp->qp_num);\r\nfor (i = 0; i < qp->rx_max_entry; i++) {\r\nrc = ntb_process_rxc(qp);\r\nif (rc)\r\nbreak;\r\n}\r\nif (i && qp->rx_dma_chan)\r\ndma_async_issue_pending(qp->rx_dma_chan);\r\nif (i == qp->rx_max_entry) {\r\nif (qp->active)\r\ntasklet_schedule(&qp->rxc_db_work);\r\n} else if (ntb_db_read(qp->ndev) & BIT_ULL(qp->qp_num)) {\r\nntb_db_clear(qp->ndev, BIT_ULL(qp->qp_num));\r\nntb_db_read(qp->ndev);\r\nif (qp->active)\r\ntasklet_schedule(&qp->rxc_db_work);\r\n}\r\n}\r\nstatic void ntb_tx_copy_callback(void *data,\r\nconst struct dmaengine_result *res)\r\n{\r\nstruct ntb_queue_entry *entry = data;\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nstruct ntb_payload_header __iomem *hdr = entry->tx_hdr;\r\nif (res) {\r\nenum dmaengine_tx_result dma_err = res->result;\r\nswitch (dma_err) {\r\ncase DMA_TRANS_READ_FAILED:\r\ncase DMA_TRANS_WRITE_FAILED:\r\nentry->errors++;\r\ncase DMA_TRANS_ABORTED:\r\n{\r\nvoid __iomem *offset =\r\nqp->tx_mw + qp->tx_max_frame *\r\nentry->tx_index;\r\nntb_memcpy_tx(entry, offset);\r\nqp->tx_memcpy++;\r\nreturn;\r\n}\r\ncase DMA_TRANS_NOERROR:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\niowrite32(entry->flags | DESC_DONE_FLAG, &hdr->flags);\r\nntb_peer_db_set(qp->ndev, BIT_ULL(qp->qp_num));\r\nif (entry->len > 0) {\r\nqp->tx_bytes += entry->len;\r\nif (qp->tx_handler)\r\nqp->tx_handler(qp, qp->cb_data, entry->cb_data,\r\nentry->len);\r\n}\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry, &qp->tx_free_q);\r\n}\r\nstatic void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)\r\n{\r\n#ifdef ARCH_HAS_NOCACHE_UACCESS\r\n__copy_from_user_inatomic_nocache(offset, entry->buf, entry->len);\r\n#else\r\nmemcpy_toio(offset, entry->buf, entry->len);\r\n#endif\r\nwmb();\r\nntb_tx_copy_callback(entry, NULL);\r\n}\r\nstatic int ntb_async_tx_submit(struct ntb_transport_qp *qp,\r\nstruct ntb_queue_entry *entry)\r\n{\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct dma_chan *chan = qp->tx_dma_chan;\r\nstruct dma_device *device;\r\nsize_t len = entry->len;\r\nvoid *buf = entry->buf;\r\nsize_t dest_off, buff_off;\r\nstruct dmaengine_unmap_data *unmap;\r\ndma_addr_t dest;\r\ndma_cookie_t cookie;\r\nint retries = 0;\r\ndevice = chan->device;\r\ndest = qp->tx_mw_phys + qp->tx_max_frame * entry->tx_index;\r\nbuff_off = (size_t)buf & ~PAGE_MASK;\r\ndest_off = (size_t)dest & ~PAGE_MASK;\r\nif (!is_dma_copy_aligned(device, buff_off, dest_off, len))\r\ngoto err;\r\nunmap = dmaengine_get_unmap_data(device->dev, 1, GFP_NOWAIT);\r\nif (!unmap)\r\ngoto err;\r\nunmap->len = len;\r\nunmap->addr[0] = dma_map_page(device->dev, virt_to_page(buf),\r\nbuff_off, len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[0]))\r\ngoto err_get_unmap;\r\nunmap->to_cnt = 1;\r\nfor (retries = 0; retries < DMA_RETRIES; retries++) {\r\ntxd = device->device_prep_dma_memcpy(chan, dest,\r\nunmap->addr[0], len,\r\nDMA_PREP_INTERRUPT);\r\nif (txd)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(DMA_OUT_RESOURCE_TO);\r\n}\r\nif (!txd) {\r\nqp->dma_tx_prep_err++;\r\ngoto err_get_unmap;\r\n}\r\ntxd->callback_result = ntb_tx_copy_callback;\r\ntxd->callback_param = entry;\r\ndma_set_unmap(txd, unmap);\r\ncookie = dmaengine_submit(txd);\r\nif (dma_submit_error(cookie))\r\ngoto err_set_unmap;\r\ndmaengine_unmap_put(unmap);\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\nerr_set_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr_get_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr:\r\nreturn -ENXIO;\r\n}\r\nstatic void ntb_async_tx(struct ntb_transport_qp *qp,\r\nstruct ntb_queue_entry *entry)\r\n{\r\nstruct ntb_payload_header __iomem *hdr;\r\nstruct dma_chan *chan = qp->tx_dma_chan;\r\nvoid __iomem *offset;\r\nint res;\r\nentry->tx_index = qp->tx_index;\r\noffset = qp->tx_mw + qp->tx_max_frame * entry->tx_index;\r\nhdr = offset + qp->tx_max_frame - sizeof(struct ntb_payload_header);\r\nentry->tx_hdr = hdr;\r\niowrite32(entry->len, &hdr->len);\r\niowrite32((u32)qp->tx_pkts, &hdr->ver);\r\nif (!chan)\r\ngoto err;\r\nif (entry->len < copy_bytes)\r\ngoto err;\r\nres = ntb_async_tx_submit(qp, entry);\r\nif (res < 0)\r\ngoto err;\r\nif (!entry->retries)\r\nqp->tx_async++;\r\nreturn;\r\nerr:\r\nntb_memcpy_tx(entry, offset);\r\nqp->tx_memcpy++;\r\n}\r\nstatic int ntb_process_tx(struct ntb_transport_qp *qp,\r\nstruct ntb_queue_entry *entry)\r\n{\r\nif (qp->tx_index == qp->remote_rx_info->entry) {\r\nqp->tx_ring_full++;\r\nreturn -EAGAIN;\r\n}\r\nif (entry->len > qp->tx_max_frame - sizeof(struct ntb_payload_header)) {\r\nif (qp->tx_handler)\r\nqp->tx_handler(qp, qp->cb_data, NULL, -EIO);\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\nreturn 0;\r\n}\r\nntb_async_tx(qp, entry);\r\nqp->tx_index++;\r\nqp->tx_index %= qp->tx_max_entry;\r\nqp->tx_pkts++;\r\nreturn 0;\r\n}\r\nstatic void ntb_send_link_down(struct ntb_transport_qp *qp)\r\n{\r\nstruct pci_dev *pdev = qp->ndev->pdev;\r\nstruct ntb_queue_entry *entry;\r\nint i, rc;\r\nif (!qp->link_is_up)\r\nreturn;\r\ndev_info(&pdev->dev, "qp %d: Send Link Down\n", qp->qp_num);\r\nfor (i = 0; i < NTB_LINK_DOWN_TIMEOUT; i++) {\r\nentry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q);\r\nif (entry)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (!entry)\r\nreturn;\r\nentry->cb_data = NULL;\r\nentry->buf = NULL;\r\nentry->len = 0;\r\nentry->flags = LINK_DOWN_FLAG;\r\nrc = ntb_process_tx(qp, entry);\r\nif (rc)\r\ndev_err(&pdev->dev, "ntb: QP%d unable to send linkdown msg\n",\r\nqp->qp_num);\r\nntb_qp_link_down_reset(qp);\r\n}\r\nstatic bool ntb_dma_filter_fn(struct dma_chan *chan, void *node)\r\n{\r\nreturn dev_to_node(&chan->dev->device) == (int)(unsigned long)node;\r\n}\r\nstruct ntb_transport_qp *\r\nntb_transport_create_queue(void *data, struct device *client_dev,\r\nconst struct ntb_queue_handlers *handlers)\r\n{\r\nstruct ntb_dev *ndev;\r\nstruct pci_dev *pdev;\r\nstruct ntb_transport_ctx *nt;\r\nstruct ntb_queue_entry *entry;\r\nstruct ntb_transport_qp *qp;\r\nu64 qp_bit;\r\nunsigned int free_queue;\r\ndma_cap_mask_t dma_mask;\r\nint node;\r\nint i;\r\nndev = dev_ntb(client_dev->parent);\r\npdev = ndev->pdev;\r\nnt = ndev->ctx;\r\nnode = dev_to_node(&ndev->dev);\r\nfree_queue = ffs(nt->qp_bitmap_free);\r\nif (!free_queue)\r\ngoto err;\r\nfree_queue--;\r\nqp = &nt->qp_vec[free_queue];\r\nqp_bit = BIT_ULL(qp->qp_num);\r\nnt->qp_bitmap_free &= ~qp_bit;\r\nqp->cb_data = data;\r\nqp->rx_handler = handlers->rx_handler;\r\nqp->tx_handler = handlers->tx_handler;\r\nqp->event_handler = handlers->event_handler;\r\ndma_cap_zero(dma_mask);\r\ndma_cap_set(DMA_MEMCPY, dma_mask);\r\nif (use_dma) {\r\nqp->tx_dma_chan =\r\ndma_request_channel(dma_mask, ntb_dma_filter_fn,\r\n(void *)(unsigned long)node);\r\nif (!qp->tx_dma_chan)\r\ndev_info(&pdev->dev, "Unable to allocate TX DMA channel\n");\r\nqp->rx_dma_chan =\r\ndma_request_channel(dma_mask, ntb_dma_filter_fn,\r\n(void *)(unsigned long)node);\r\nif (!qp->rx_dma_chan)\r\ndev_info(&pdev->dev, "Unable to allocate RX DMA channel\n");\r\n} else {\r\nqp->tx_dma_chan = NULL;\r\nqp->rx_dma_chan = NULL;\r\n}\r\ndev_dbg(&pdev->dev, "Using %s memcpy for TX\n",\r\nqp->tx_dma_chan ? "DMA" : "CPU");\r\ndev_dbg(&pdev->dev, "Using %s memcpy for RX\n",\r\nqp->rx_dma_chan ? "DMA" : "CPU");\r\nfor (i = 0; i < NTB_QP_DEF_NUM_ENTRIES; i++) {\r\nentry = kzalloc_node(sizeof(*entry), GFP_ATOMIC, node);\r\nif (!entry)\r\ngoto err1;\r\nentry->qp = qp;\r\nntb_list_add(&qp->ntb_rx_q_lock, &entry->entry,\r\n&qp->rx_free_q);\r\n}\r\nqp->rx_alloc_entry = NTB_QP_DEF_NUM_ENTRIES;\r\nfor (i = 0; i < qp->tx_max_entry; i++) {\r\nentry = kzalloc_node(sizeof(*entry), GFP_ATOMIC, node);\r\nif (!entry)\r\ngoto err2;\r\nentry->qp = qp;\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\n}\r\nntb_db_clear(qp->ndev, qp_bit);\r\nntb_db_clear_mask(qp->ndev, qp_bit);\r\ndev_info(&pdev->dev, "NTB Transport QP %d created\n", qp->qp_num);\r\nreturn qp;\r\nerr2:\r\nwhile ((entry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q)))\r\nkfree(entry);\r\nerr1:\r\nqp->rx_alloc_entry = 0;\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_free_q)))\r\nkfree(entry);\r\nif (qp->tx_dma_chan)\r\ndma_release_channel(qp->tx_dma_chan);\r\nif (qp->rx_dma_chan)\r\ndma_release_channel(qp->rx_dma_chan);\r\nnt->qp_bitmap_free |= qp_bit;\r\nerr:\r\nreturn NULL;\r\n}\r\nvoid ntb_transport_free_queue(struct ntb_transport_qp *qp)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct ntb_queue_entry *entry;\r\nu64 qp_bit;\r\nif (!qp)\r\nreturn;\r\npdev = qp->ndev->pdev;\r\nqp->active = false;\r\nif (qp->tx_dma_chan) {\r\nstruct dma_chan *chan = qp->tx_dma_chan;\r\nqp->tx_dma_chan = NULL;\r\ndma_sync_wait(chan, qp->last_cookie);\r\ndmaengine_terminate_all(chan);\r\ndma_release_channel(chan);\r\n}\r\nif (qp->rx_dma_chan) {\r\nstruct dma_chan *chan = qp->rx_dma_chan;\r\nqp->rx_dma_chan = NULL;\r\ndma_sync_wait(chan, qp->last_cookie);\r\ndmaengine_terminate_all(chan);\r\ndma_release_channel(chan);\r\n}\r\nqp_bit = BIT_ULL(qp->qp_num);\r\nntb_db_set_mask(qp->ndev, qp_bit);\r\ntasklet_kill(&qp->rxc_db_work);\r\ncancel_delayed_work_sync(&qp->link_work);\r\nqp->cb_data = NULL;\r\nqp->rx_handler = NULL;\r\nqp->tx_handler = NULL;\r\nqp->event_handler = NULL;\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_free_q)))\r\nkfree(entry);\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_pend_q))) {\r\ndev_warn(&pdev->dev, "Freeing item from non-empty rx_pend_q\n");\r\nkfree(entry);\r\n}\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_post_q))) {\r\ndev_warn(&pdev->dev, "Freeing item from non-empty rx_post_q\n");\r\nkfree(entry);\r\n}\r\nwhile ((entry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q)))\r\nkfree(entry);\r\nqp->transport->qp_bitmap_free |= qp_bit;\r\ndev_info(&pdev->dev, "NTB Transport QP %d freed\n", qp->qp_num);\r\n}\r\nvoid *ntb_transport_rx_remove(struct ntb_transport_qp *qp, unsigned int *len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nvoid *buf;\r\nif (!qp || qp->client_ready)\r\nreturn NULL;\r\nentry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_pend_q);\r\nif (!entry)\r\nreturn NULL;\r\nbuf = entry->cb_data;\r\n*len = entry->len;\r\nntb_list_add(&qp->ntb_rx_q_lock, &entry->entry, &qp->rx_free_q);\r\nreturn buf;\r\n}\r\nint ntb_transport_rx_enqueue(struct ntb_transport_qp *qp, void *cb, void *data,\r\nunsigned int len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nif (!qp)\r\nreturn -EINVAL;\r\nentry = ntb_list_rm(&qp->ntb_rx_q_lock, &qp->rx_free_q);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->cb_data = cb;\r\nentry->buf = data;\r\nentry->len = len;\r\nentry->flags = 0;\r\nentry->retries = 0;\r\nentry->errors = 0;\r\nentry->rx_index = 0;\r\nntb_list_add(&qp->ntb_rx_q_lock, &entry->entry, &qp->rx_pend_q);\r\nif (qp->active)\r\ntasklet_schedule(&qp->rxc_db_work);\r\nreturn 0;\r\n}\r\nint ntb_transport_tx_enqueue(struct ntb_transport_qp *qp, void *cb, void *data,\r\nunsigned int len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nint rc;\r\nif (!qp || !qp->link_is_up || !len)\r\nreturn -EINVAL;\r\nentry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q);\r\nif (!entry) {\r\nqp->tx_err_no_buf++;\r\nreturn -EBUSY;\r\n}\r\nentry->cb_data = cb;\r\nentry->buf = data;\r\nentry->len = len;\r\nentry->flags = 0;\r\nentry->errors = 0;\r\nentry->retries = 0;\r\nentry->tx_index = 0;\r\nrc = ntb_process_tx(qp, entry);\r\nif (rc)\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\nreturn rc;\r\n}\r\nvoid ntb_transport_link_up(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn;\r\nqp->client_ready = true;\r\nif (qp->transport->link_is_up)\r\nschedule_delayed_work(&qp->link_work, 0);\r\n}\r\nvoid ntb_transport_link_down(struct ntb_transport_qp *qp)\r\n{\r\nint val;\r\nif (!qp)\r\nreturn;\r\nqp->client_ready = false;\r\nval = ntb_spad_read(qp->ndev, QP_LINKS);\r\nntb_peer_spad_write(qp->ndev, QP_LINKS,\r\nval & ~BIT(qp->qp_num));\r\nif (qp->link_is_up)\r\nntb_send_link_down(qp);\r\nelse\r\ncancel_delayed_work_sync(&qp->link_work);\r\n}\r\nbool ntb_transport_link_query(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn false;\r\nreturn qp->link_is_up;\r\n}\r\nunsigned char ntb_transport_qp_num(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn 0;\r\nreturn qp->qp_num;\r\n}\r\nunsigned int ntb_transport_max_size(struct ntb_transport_qp *qp)\r\n{\r\nunsigned int max_size;\r\nunsigned int copy_align;\r\nstruct dma_chan *rx_chan, *tx_chan;\r\nif (!qp)\r\nreturn 0;\r\nrx_chan = qp->rx_dma_chan;\r\ntx_chan = qp->tx_dma_chan;\r\ncopy_align = max(rx_chan ? rx_chan->device->copy_align : 0,\r\ntx_chan ? tx_chan->device->copy_align : 0);\r\nmax_size = qp->tx_max_frame - sizeof(struct ntb_payload_header);\r\nmax_size = round_down(max_size, 1 << copy_align);\r\nreturn max_size;\r\n}\r\nunsigned int ntb_transport_tx_free_entry(struct ntb_transport_qp *qp)\r\n{\r\nunsigned int head = qp->tx_index;\r\nunsigned int tail = qp->remote_rx_info->entry;\r\nreturn tail > head ? tail - head : qp->tx_max_entry + tail - head;\r\n}\r\nstatic void ntb_transport_doorbell_callback(void *data, int vector)\r\n{\r\nstruct ntb_transport_ctx *nt = data;\r\nstruct ntb_transport_qp *qp;\r\nu64 db_bits;\r\nunsigned int qp_num;\r\ndb_bits = (nt->qp_bitmap & ~nt->qp_bitmap_free &\r\nntb_db_vector_mask(nt->ndev, vector));\r\nwhile (db_bits) {\r\nqp_num = __ffs(db_bits);\r\nqp = &nt->qp_vec[qp_num];\r\nif (qp->active)\r\ntasklet_schedule(&qp->rxc_db_work);\r\ndb_bits &= ~BIT_ULL(qp_num);\r\n}\r\n}\r\nstatic int __init ntb_transport_init(void)\r\n{\r\nint rc;\r\npr_info("%s, version %s\n", NTB_TRANSPORT_DESC, NTB_TRANSPORT_VER);\r\nif (debugfs_initialized())\r\nnt_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nrc = bus_register(&ntb_transport_bus);\r\nif (rc)\r\ngoto err_bus;\r\nrc = ntb_register_client(&ntb_transport_client);\r\nif (rc)\r\ngoto err_client;\r\nreturn 0;\r\nerr_client:\r\nbus_unregister(&ntb_transport_bus);\r\nerr_bus:\r\ndebugfs_remove_recursive(nt_debugfs_dir);\r\nreturn rc;\r\n}\r\nstatic void __exit ntb_transport_exit(void)\r\n{\r\nntb_unregister_client(&ntb_transport_client);\r\nbus_unregister(&ntb_transport_bus);\r\ndebugfs_remove_recursive(nt_debugfs_dir);\r\n}
