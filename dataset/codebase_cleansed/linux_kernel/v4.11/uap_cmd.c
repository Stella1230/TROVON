int mwifiex_set_secure_params(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_config,\r\nstruct cfg80211_ap_settings *params) {\r\nint i;\r\nstruct mwifiex_wep_key wep_key;\r\nif (!params->privacy) {\r\nbss_config->protocol = PROTOCOL_NO_SECURITY;\r\nbss_config->key_mgmt = KEY_MGMT_NONE;\r\nbss_config->wpa_cfg.length = 0;\r\npriv->sec_info.wep_enabled = 0;\r\npriv->sec_info.wpa_enabled = 0;\r\npriv->sec_info.wpa2_enabled = 0;\r\nreturn 0;\r\n}\r\nswitch (params->auth_type) {\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\nbss_config->auth_mode = WLAN_AUTH_OPEN;\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\nbss_config->auth_mode = WLAN_AUTH_SHARED_KEY;\r\nbreak;\r\ncase NL80211_AUTHTYPE_NETWORK_EAP:\r\nbss_config->auth_mode = WLAN_AUTH_LEAP;\r\nbreak;\r\ndefault:\r\nbss_config->auth_mode = MWIFIEX_AUTH_MODE_AUTO;\r\nbreak;\r\n}\r\nbss_config->key_mgmt_operation |= KEY_MGMT_ON_HOST;\r\nfor (i = 0; i < params->crypto.n_akm_suites; i++) {\r\nswitch (params->crypto.akm_suites[i]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nif (params->crypto.wpa_versions &\r\nNL80211_WPA_VERSION_1) {\r\nbss_config->protocol = PROTOCOL_WPA;\r\nbss_config->key_mgmt = KEY_MGMT_EAP;\r\n}\r\nif (params->crypto.wpa_versions &\r\nNL80211_WPA_VERSION_2) {\r\nbss_config->protocol |= PROTOCOL_WPA2;\r\nbss_config->key_mgmt = KEY_MGMT_EAP;\r\n}\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nif (params->crypto.wpa_versions &\r\nNL80211_WPA_VERSION_1) {\r\nbss_config->protocol = PROTOCOL_WPA;\r\nbss_config->key_mgmt = KEY_MGMT_PSK;\r\n}\r\nif (params->crypto.wpa_versions &\r\nNL80211_WPA_VERSION_2) {\r\nbss_config->protocol |= PROTOCOL_WPA2;\r\nbss_config->key_mgmt = KEY_MGMT_PSK;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < params->crypto.n_ciphers_pairwise; i++) {\r\nswitch (params->crypto.ciphers_pairwise[i]) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\nbss_config->wpa_cfg.pairwise_cipher_wpa |=\r\nCIPHER_TKIP;\r\nif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\nbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\r\nCIPHER_TKIP;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\nbss_config->wpa_cfg.pairwise_cipher_wpa |=\r\nCIPHER_AES_CCMP;\r\nif (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\nbss_config->wpa_cfg.pairwise_cipher_wpa2 |=\r\nCIPHER_AES_CCMP;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (params->crypto.cipher_group) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nif (priv->sec_info.wep_enabled) {\r\nbss_config->protocol = PROTOCOL_STATIC_WEP;\r\nbss_config->key_mgmt = KEY_MGMT_NONE;\r\nbss_config->wpa_cfg.length = 0;\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nwep_key = priv->wep_key[i];\r\nbss_config->wep_cfg[i].key_index = i;\r\nif (priv->wep_key_curr_index == i)\r\nbss_config->wep_cfg[i].is_default = 1;\r\nelse\r\nbss_config->wep_cfg[i].is_default = 0;\r\nbss_config->wep_cfg[i].length =\r\nwep_key.key_length;\r\nmemcpy(&bss_config->wep_cfg[i].key,\r\n&wep_key.key_material,\r\nwep_key.key_length);\r\n}\r\n}\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nbss_config->wpa_cfg.group_cipher = CIPHER_TKIP;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nbss_config->wpa_cfg.group_cipher = CIPHER_AES_CCMP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nmwifiex_set_ht_params(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_ap_settings *params)\r\n{\r\nconst u8 *ht_ie;\r\nu16 cap_info;\r\nif (!ISSUPP_11NENABLED(priv->adapter->fw_cap_info))\r\nreturn;\r\nht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, params->beacon.tail,\r\nparams->beacon.tail_len);\r\nif (ht_ie) {\r\nmemcpy(&bss_cfg->ht_cap, ht_ie + 2,\r\nsizeof(struct ieee80211_ht_cap));\r\ncap_info = le16_to_cpu(bss_cfg->ht_cap.cap_info);\r\nmemset(&bss_cfg->ht_cap.mcs, 0,\r\npriv->adapter->number_of_antenna);\r\nswitch (GET_RXSTBC(cap_info)) {\r\ncase MWIFIEX_RX_STBC1:\r\nbss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;\r\nbreak;\r\ncase MWIFIEX_RX_STBC12:\r\ncase MWIFIEX_RX_STBC123:\r\nbss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;\r\nbss_cfg->ht_cap.mcs.rx_mask[1] = 0xff;\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(priv->adapter, WARN,\r\n"Unsupported RX-STBC, default to 2x2\n");\r\nbss_cfg->ht_cap.mcs.rx_mask[0] = 0xff;\r\nbss_cfg->ht_cap.mcs.rx_mask[1] = 0xff;\r\nbreak;\r\n}\r\npriv->ap_11n_enabled = 1;\r\n} else {\r\nmemset(&bss_cfg->ht_cap, 0, sizeof(struct ieee80211_ht_cap));\r\nbss_cfg->ht_cap.cap_info = cpu_to_le16(MWIFIEX_DEF_HT_CAP);\r\nbss_cfg->ht_cap.ampdu_params_info = MWIFIEX_DEF_AMPDU;\r\n}\r\nreturn;\r\n}\r\nvoid mwifiex_set_vht_params(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_ap_settings *params)\r\n{\r\nconst u8 *vht_ie;\r\nvht_ie = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, params->beacon.tail,\r\nparams->beacon.tail_len);\r\nif (vht_ie) {\r\nmemcpy(&bss_cfg->vht_cap, vht_ie + 2,\r\nsizeof(struct ieee80211_vht_cap));\r\npriv->ap_11ac_enabled = 1;\r\n} else {\r\npriv->ap_11ac_enabled = 0;\r\n}\r\nreturn;\r\n}\r\nvoid mwifiex_set_tpc_params(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_ap_settings *params)\r\n{\r\nconst u8 *tpc_ie;\r\ntpc_ie = cfg80211_find_ie(WLAN_EID_TPC_REQUEST, params->beacon.tail,\r\nparams->beacon.tail_len);\r\nif (tpc_ie)\r\nbss_cfg->power_constraint = *(tpc_ie + 2);\r\nelse\r\nbss_cfg->power_constraint = 0;\r\n}\r\nvoid mwifiex_set_vht_width(struct mwifiex_private *priv,\r\nenum nl80211_chan_width width,\r\nbool ap_11ac_enable)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct mwifiex_11ac_vht_cfg vht_cfg;\r\nvht_cfg.band_config = VHT_CFG_5GHZ;\r\nvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\r\nif (!ap_11ac_enable) {\r\nvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\r\nvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\r\n} else {\r\nvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\r\nvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\r\n}\r\nvht_cfg.misc_config = VHT_CAP_UAP_ONLY;\r\nif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\r\nvht_cfg.misc_config |= VHT_BW_80_160_80P80;\r\nmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\r\nHostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\r\nreturn;\r\n}\r\nvoid\r\nmwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_ap_settings *params)\r\n{\r\nstruct ieee_types_header *rate_ie;\r\nint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nconst u8 *var_pos = params->beacon.head + var_offset;\r\nint len = params->beacon.head_len - var_offset;\r\nu8 rate_len = 0;\r\nrate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\r\nif (rate_ie) {\r\nmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\r\nrate_len = rate_ie->len;\r\n}\r\nrate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\r\nparams->beacon.tail,\r\nparams->beacon.tail_len);\r\nif (rate_ie)\r\nmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\r\nreturn;\r\n}\r\nvoid mwifiex_set_sys_config_invalid_data(struct mwifiex_uap_bss_param *config)\r\n{\r\nconfig->bcast_ssid_ctl = 0x7F;\r\nconfig->radio_ctl = 0x7F;\r\nconfig->dtim_period = 0x7F;\r\nconfig->beacon_period = 0x7FFF;\r\nconfig->auth_mode = 0x7F;\r\nconfig->rts_threshold = 0x7FFF;\r\nconfig->frag_threshold = 0x7FFF;\r\nconfig->retry_limit = 0x7F;\r\nconfig->qos_info = 0xFF;\r\n}\r\nstatic void\r\nmwifiex_uap_bss_wpa(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\r\n{\r\nstruct host_cmd_tlv_pwk_cipher *pwk_cipher;\r\nstruct host_cmd_tlv_gwk_cipher *gwk_cipher;\r\nstruct host_cmd_tlv_passphrase *passphrase;\r\nstruct host_cmd_tlv_akmp *tlv_akmp;\r\nstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\r\nu16 cmd_size = *param_size;\r\nu8 *tlv = *tlv_buf;\r\ntlv_akmp = (struct host_cmd_tlv_akmp *)tlv;\r\ntlv_akmp->header.type = cpu_to_le16(TLV_TYPE_UAP_AKMP);\r\ntlv_akmp->header.len = cpu_to_le16(sizeof(struct host_cmd_tlv_akmp) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ntlv_akmp->key_mgmt_operation = cpu_to_le16(bss_cfg->key_mgmt_operation);\r\ntlv_akmp->key_mgmt = cpu_to_le16(bss_cfg->key_mgmt);\r\ncmd_size += sizeof(struct host_cmd_tlv_akmp);\r\ntlv += sizeof(struct host_cmd_tlv_akmp);\r\nif (bss_cfg->wpa_cfg.pairwise_cipher_wpa & VALID_CIPHER_BITMAP) {\r\npwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\r\npwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\r\npwk_cipher->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\r\nsizeof(struct mwifiex_ie_types_header));\r\npwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA);\r\npwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa;\r\ncmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\r\ntlv += sizeof(struct host_cmd_tlv_pwk_cipher);\r\n}\r\nif (bss_cfg->wpa_cfg.pairwise_cipher_wpa2 & VALID_CIPHER_BITMAP) {\r\npwk_cipher = (struct host_cmd_tlv_pwk_cipher *)tlv;\r\npwk_cipher->header.type = cpu_to_le16(TLV_TYPE_PWK_CIPHER);\r\npwk_cipher->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_pwk_cipher) -\r\nsizeof(struct mwifiex_ie_types_header));\r\npwk_cipher->proto = cpu_to_le16(PROTOCOL_WPA2);\r\npwk_cipher->cipher = bss_cfg->wpa_cfg.pairwise_cipher_wpa2;\r\ncmd_size += sizeof(struct host_cmd_tlv_pwk_cipher);\r\ntlv += sizeof(struct host_cmd_tlv_pwk_cipher);\r\n}\r\nif (bss_cfg->wpa_cfg.group_cipher & VALID_CIPHER_BITMAP) {\r\ngwk_cipher = (struct host_cmd_tlv_gwk_cipher *)tlv;\r\ngwk_cipher->header.type = cpu_to_le16(TLV_TYPE_GWK_CIPHER);\r\ngwk_cipher->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_gwk_cipher) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ngwk_cipher->cipher = bss_cfg->wpa_cfg.group_cipher;\r\ncmd_size += sizeof(struct host_cmd_tlv_gwk_cipher);\r\ntlv += sizeof(struct host_cmd_tlv_gwk_cipher);\r\n}\r\nif (bss_cfg->wpa_cfg.length) {\r\npassphrase = (struct host_cmd_tlv_passphrase *)tlv;\r\npassphrase->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_WPA_PASSPHRASE);\r\npassphrase->header.len = cpu_to_le16(bss_cfg->wpa_cfg.length);\r\nmemcpy(passphrase->passphrase, bss_cfg->wpa_cfg.passphrase,\r\nbss_cfg->wpa_cfg.length);\r\ncmd_size += sizeof(struct mwifiex_ie_types_header) +\r\nbss_cfg->wpa_cfg.length;\r\ntlv += sizeof(struct mwifiex_ie_types_header) +\r\nbss_cfg->wpa_cfg.length;\r\n}\r\n*param_size = cmd_size;\r\n*tlv_buf = tlv;\r\nreturn;\r\n}\r\nvoid\r\nmwifiex_set_wmm_params(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_ap_settings *params)\r\n{\r\nconst u8 *vendor_ie;\r\nconst u8 *wmm_ie;\r\nu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\r\nvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WMM,\r\nparams->beacon.tail,\r\nparams->beacon.tail_len);\r\nif (vendor_ie) {\r\nwmm_ie = vendor_ie;\r\nmemcpy(&bss_cfg->wmm_info, wmm_ie +\r\nsizeof(struct ieee_types_header), *(wmm_ie + 1));\r\npriv->wmm_enabled = 1;\r\n} else {\r\nmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\r\nmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\r\nbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\r\nbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\r\npriv->wmm_enabled = 0;\r\n}\r\nbss_cfg->qos_info = 0x00;\r\nreturn;\r\n}\r\nstatic void\r\nmwifiex_uap_bss_wep(u8 **tlv_buf, void *cmd_buf, u16 *param_size)\r\n{\r\nstruct host_cmd_tlv_wep_key *wep_key;\r\nu16 cmd_size = *param_size;\r\nint i;\r\nu8 *tlv = *tlv_buf;\r\nstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\r\nfor (i = 0; i < NUM_WEP_KEYS; i++) {\r\nif (bss_cfg->wep_cfg[i].length &&\r\n(bss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP40 ||\r\nbss_cfg->wep_cfg[i].length == WLAN_KEY_LEN_WEP104)) {\r\nwep_key = (struct host_cmd_tlv_wep_key *)tlv;\r\nwep_key->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_WEP_KEY);\r\nwep_key->header.len =\r\ncpu_to_le16(bss_cfg->wep_cfg[i].length + 2);\r\nwep_key->key_index = bss_cfg->wep_cfg[i].key_index;\r\nwep_key->is_default = bss_cfg->wep_cfg[i].is_default;\r\nmemcpy(wep_key->key, bss_cfg->wep_cfg[i].key,\r\nbss_cfg->wep_cfg[i].length);\r\ncmd_size += sizeof(struct mwifiex_ie_types_header) + 2 +\r\nbss_cfg->wep_cfg[i].length;\r\ntlv += sizeof(struct mwifiex_ie_types_header) + 2 +\r\nbss_cfg->wep_cfg[i].length;\r\n}\r\n}\r\n*param_size = cmd_size;\r\n*tlv_buf = tlv;\r\nreturn;\r\n}\r\nstatic int\r\nmwifiex_uap_bss_param_prepare(u8 *tlv, void *cmd_buf, u16 *param_size)\r\n{\r\nstruct host_cmd_tlv_dtim_period *dtim_period;\r\nstruct host_cmd_tlv_beacon_period *beacon_period;\r\nstruct host_cmd_tlv_ssid *ssid;\r\nstruct host_cmd_tlv_bcast_ssid *bcast_ssid;\r\nstruct host_cmd_tlv_channel_band *chan_band;\r\nstruct host_cmd_tlv_frag_threshold *frag_threshold;\r\nstruct host_cmd_tlv_rts_threshold *rts_threshold;\r\nstruct host_cmd_tlv_retry_limit *retry_limit;\r\nstruct host_cmd_tlv_encrypt_protocol *encrypt_protocol;\r\nstruct host_cmd_tlv_auth_type *auth_type;\r\nstruct host_cmd_tlv_rates *tlv_rates;\r\nstruct host_cmd_tlv_ageout_timer *ao_timer, *ps_ao_timer;\r\nstruct host_cmd_tlv_power_constraint *pwr_ct;\r\nstruct mwifiex_ie_types_htcap *htcap;\r\nstruct mwifiex_ie_types_wmmcap *wmm_cap;\r\nstruct mwifiex_uap_bss_param *bss_cfg = cmd_buf;\r\nint i;\r\nu16 cmd_size = *param_size;\r\nif (bss_cfg->ssid.ssid_len) {\r\nssid = (struct host_cmd_tlv_ssid *)tlv;\r\nssid->header.type = cpu_to_le16(TLV_TYPE_UAP_SSID);\r\nssid->header.len = cpu_to_le16((u16)bss_cfg->ssid.ssid_len);\r\nmemcpy(ssid->ssid, bss_cfg->ssid.ssid, bss_cfg->ssid.ssid_len);\r\ncmd_size += sizeof(struct mwifiex_ie_types_header) +\r\nbss_cfg->ssid.ssid_len;\r\ntlv += sizeof(struct mwifiex_ie_types_header) +\r\nbss_cfg->ssid.ssid_len;\r\nbcast_ssid = (struct host_cmd_tlv_bcast_ssid *)tlv;\r\nbcast_ssid->header.type = cpu_to_le16(TLV_TYPE_UAP_BCAST_SSID);\r\nbcast_ssid->header.len =\r\ncpu_to_le16(sizeof(bcast_ssid->bcast_ctl));\r\nbcast_ssid->bcast_ctl = bss_cfg->bcast_ssid_ctl;\r\ncmd_size += sizeof(struct host_cmd_tlv_bcast_ssid);\r\ntlv += sizeof(struct host_cmd_tlv_bcast_ssid);\r\n}\r\nif (bss_cfg->rates[0]) {\r\ntlv_rates = (struct host_cmd_tlv_rates *)tlv;\r\ntlv_rates->header.type = cpu_to_le16(TLV_TYPE_UAP_RATES);\r\nfor (i = 0; i < MWIFIEX_SUPPORTED_RATES && bss_cfg->rates[i];\r\ni++)\r\ntlv_rates->rates[i] = bss_cfg->rates[i];\r\ntlv_rates->header.len = cpu_to_le16(i);\r\ncmd_size += sizeof(struct host_cmd_tlv_rates) + i;\r\ntlv += sizeof(struct host_cmd_tlv_rates) + i;\r\n}\r\nif (bss_cfg->channel &&\r\n(((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_BG &&\r\nbss_cfg->channel <= MAX_CHANNEL_BAND_BG) ||\r\n((bss_cfg->band_cfg & BIT(0)) == BAND_CONFIG_A &&\r\nbss_cfg->channel <= MAX_CHANNEL_BAND_A))) {\r\nchan_band = (struct host_cmd_tlv_channel_band *)tlv;\r\nchan_band->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);\r\nchan_band->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_channel_band) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nchan_band->band_config = bss_cfg->band_cfg;\r\nchan_band->channel = bss_cfg->channel;\r\ncmd_size += sizeof(struct host_cmd_tlv_channel_band);\r\ntlv += sizeof(struct host_cmd_tlv_channel_band);\r\n}\r\nif (bss_cfg->beacon_period >= MIN_BEACON_PERIOD &&\r\nbss_cfg->beacon_period <= MAX_BEACON_PERIOD) {\r\nbeacon_period = (struct host_cmd_tlv_beacon_period *)tlv;\r\nbeacon_period->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_BEACON_PERIOD);\r\nbeacon_period->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_beacon_period) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nbeacon_period->period = cpu_to_le16(bss_cfg->beacon_period);\r\ncmd_size += sizeof(struct host_cmd_tlv_beacon_period);\r\ntlv += sizeof(struct host_cmd_tlv_beacon_period);\r\n}\r\nif (bss_cfg->dtim_period >= MIN_DTIM_PERIOD &&\r\nbss_cfg->dtim_period <= MAX_DTIM_PERIOD) {\r\ndtim_period = (struct host_cmd_tlv_dtim_period *)tlv;\r\ndtim_period->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_DTIM_PERIOD);\r\ndtim_period->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_dtim_period) -\r\nsizeof(struct mwifiex_ie_types_header));\r\ndtim_period->period = bss_cfg->dtim_period;\r\ncmd_size += sizeof(struct host_cmd_tlv_dtim_period);\r\ntlv += sizeof(struct host_cmd_tlv_dtim_period);\r\n}\r\nif (bss_cfg->rts_threshold <= MWIFIEX_RTS_MAX_VALUE) {\r\nrts_threshold = (struct host_cmd_tlv_rts_threshold *)tlv;\r\nrts_threshold->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_RTS_THRESHOLD);\r\nrts_threshold->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_rts_threshold) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nrts_threshold->rts_thr = cpu_to_le16(bss_cfg->rts_threshold);\r\ncmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\r\ntlv += sizeof(struct host_cmd_tlv_frag_threshold);\r\n}\r\nif ((bss_cfg->frag_threshold >= MWIFIEX_FRAG_MIN_VALUE) &&\r\n(bss_cfg->frag_threshold <= MWIFIEX_FRAG_MAX_VALUE)) {\r\nfrag_threshold = (struct host_cmd_tlv_frag_threshold *)tlv;\r\nfrag_threshold->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_FRAG_THRESHOLD);\r\nfrag_threshold->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_frag_threshold) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nfrag_threshold->frag_thr = cpu_to_le16(bss_cfg->frag_threshold);\r\ncmd_size += sizeof(struct host_cmd_tlv_frag_threshold);\r\ntlv += sizeof(struct host_cmd_tlv_frag_threshold);\r\n}\r\nif (bss_cfg->retry_limit <= MWIFIEX_RETRY_LIMIT) {\r\nretry_limit = (struct host_cmd_tlv_retry_limit *)tlv;\r\nretry_limit->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_RETRY_LIMIT);\r\nretry_limit->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_retry_limit) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nretry_limit->limit = (u8)bss_cfg->retry_limit;\r\ncmd_size += sizeof(struct host_cmd_tlv_retry_limit);\r\ntlv += sizeof(struct host_cmd_tlv_retry_limit);\r\n}\r\nif ((bss_cfg->protocol & PROTOCOL_WPA) ||\r\n(bss_cfg->protocol & PROTOCOL_WPA2) ||\r\n(bss_cfg->protocol & PROTOCOL_EAP))\r\nmwifiex_uap_bss_wpa(&tlv, cmd_buf, &cmd_size);\r\nelse\r\nmwifiex_uap_bss_wep(&tlv, cmd_buf, &cmd_size);\r\nif ((bss_cfg->auth_mode <= WLAN_AUTH_SHARED_KEY) ||\r\n(bss_cfg->auth_mode == MWIFIEX_AUTH_MODE_AUTO)) {\r\nauth_type = (struct host_cmd_tlv_auth_type *)tlv;\r\nauth_type->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\r\nauth_type->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_auth_type) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nauth_type->auth_type = (u8)bss_cfg->auth_mode;\r\ncmd_size += sizeof(struct host_cmd_tlv_auth_type);\r\ntlv += sizeof(struct host_cmd_tlv_auth_type);\r\n}\r\nif (bss_cfg->protocol) {\r\nencrypt_protocol = (struct host_cmd_tlv_encrypt_protocol *)tlv;\r\nencrypt_protocol->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_ENCRY_PROTOCOL);\r\nencrypt_protocol->header.len =\r\ncpu_to_le16(sizeof(struct host_cmd_tlv_encrypt_protocol)\r\n- sizeof(struct mwifiex_ie_types_header));\r\nencrypt_protocol->proto = cpu_to_le16(bss_cfg->protocol);\r\ncmd_size += sizeof(struct host_cmd_tlv_encrypt_protocol);\r\ntlv += sizeof(struct host_cmd_tlv_encrypt_protocol);\r\n}\r\nif (bss_cfg->ht_cap.cap_info) {\r\nhtcap = (struct mwifiex_ie_types_htcap *)tlv;\r\nhtcap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\r\nhtcap->header.len =\r\ncpu_to_le16(sizeof(struct ieee80211_ht_cap));\r\nhtcap->ht_cap.cap_info = bss_cfg->ht_cap.cap_info;\r\nhtcap->ht_cap.ampdu_params_info =\r\nbss_cfg->ht_cap.ampdu_params_info;\r\nmemcpy(&htcap->ht_cap.mcs, &bss_cfg->ht_cap.mcs,\r\nsizeof(struct ieee80211_mcs_info));\r\nhtcap->ht_cap.extended_ht_cap_info =\r\nbss_cfg->ht_cap.extended_ht_cap_info;\r\nhtcap->ht_cap.tx_BF_cap_info = bss_cfg->ht_cap.tx_BF_cap_info;\r\nhtcap->ht_cap.antenna_selection_info =\r\nbss_cfg->ht_cap.antenna_selection_info;\r\ncmd_size += sizeof(struct mwifiex_ie_types_htcap);\r\ntlv += sizeof(struct mwifiex_ie_types_htcap);\r\n}\r\nif (bss_cfg->wmm_info.qos_info != 0xFF) {\r\nwmm_cap = (struct mwifiex_ie_types_wmmcap *)tlv;\r\nwmm_cap->header.type = cpu_to_le16(WLAN_EID_VENDOR_SPECIFIC);\r\nwmm_cap->header.len = cpu_to_le16(sizeof(wmm_cap->wmm_info));\r\nmemcpy(&wmm_cap->wmm_info, &bss_cfg->wmm_info,\r\nsizeof(wmm_cap->wmm_info));\r\ncmd_size += sizeof(struct mwifiex_ie_types_wmmcap);\r\ntlv += sizeof(struct mwifiex_ie_types_wmmcap);\r\n}\r\nif (bss_cfg->sta_ao_timer) {\r\nao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\r\nao_timer->header.type = cpu_to_le16(TLV_TYPE_UAP_AO_TIMER);\r\nao_timer->header.len = cpu_to_le16(sizeof(*ao_timer) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nao_timer->sta_ao_timer = cpu_to_le32(bss_cfg->sta_ao_timer);\r\ncmd_size += sizeof(*ao_timer);\r\ntlv += sizeof(*ao_timer);\r\n}\r\nif (bss_cfg->power_constraint) {\r\npwr_ct = (void *)tlv;\r\npwr_ct->header.type = cpu_to_le16(TLV_TYPE_PWR_CONSTRAINT);\r\npwr_ct->header.len = cpu_to_le16(sizeof(u8));\r\npwr_ct->constraint = bss_cfg->power_constraint;\r\ncmd_size += sizeof(*pwr_ct);\r\ntlv += sizeof(*pwr_ct);\r\n}\r\nif (bss_cfg->ps_sta_ao_timer) {\r\nps_ao_timer = (struct host_cmd_tlv_ageout_timer *)tlv;\r\nps_ao_timer->header.type =\r\ncpu_to_le16(TLV_TYPE_UAP_PS_AO_TIMER);\r\nps_ao_timer->header.len = cpu_to_le16(sizeof(*ps_ao_timer) -\r\nsizeof(struct mwifiex_ie_types_header));\r\nps_ao_timer->sta_ao_timer =\r\ncpu_to_le32(bss_cfg->ps_sta_ao_timer);\r\ncmd_size += sizeof(*ps_ao_timer);\r\ntlv += sizeof(*ps_ao_timer);\r\n}\r\n*param_size = cmd_size;\r\nreturn 0;\r\n}\r\nstatic int mwifiex_uap_custom_ie_prepare(u8 *tlv, void *cmd_buf, u16 *ie_size)\r\n{\r\nstruct mwifiex_ie_list *ap_ie = cmd_buf;\r\nstruct mwifiex_ie_types_header *tlv_ie = (void *)tlv;\r\nif (!ap_ie || !ap_ie->len)\r\nreturn -1;\r\n*ie_size += le16_to_cpu(ap_ie->len) +\r\nsizeof(struct mwifiex_ie_types_header);\r\ntlv_ie->type = cpu_to_le16(TLV_TYPE_MGMT_IE);\r\ntlv_ie->len = ap_ie->len;\r\ntlv += sizeof(struct mwifiex_ie_types_header);\r\nmemcpy(tlv, ap_ie->ie_list, le16_to_cpu(ap_ie->len));\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_cmd_uap_sys_config(struct host_cmd_ds_command *cmd, u16 cmd_action,\r\nu32 type, void *cmd_buf)\r\n{\r\nu8 *tlv;\r\nu16 cmd_size, param_size, ie_size;\r\nstruct host_cmd_ds_sys_config *sys_cfg;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_UAP_SYS_CONFIG);\r\ncmd_size = (u16)(sizeof(struct host_cmd_ds_sys_config) + S_DS_GEN);\r\nsys_cfg = (struct host_cmd_ds_sys_config *)&cmd->params.uap_sys_config;\r\nsys_cfg->action = cpu_to_le16(cmd_action);\r\ntlv = sys_cfg->tlv;\r\nswitch (type) {\r\ncase UAP_BSS_PARAMS_I:\r\nparam_size = cmd_size;\r\nif (mwifiex_uap_bss_param_prepare(tlv, cmd_buf, &param_size))\r\nreturn -1;\r\ncmd->size = cpu_to_le16(param_size);\r\nbreak;\r\ncase UAP_CUSTOM_IE_I:\r\nie_size = cmd_size;\r\nif (mwifiex_uap_custom_ie_prepare(tlv, cmd_buf, &ie_size))\r\nreturn -1;\r\ncmd->size = cpu_to_le16(ie_size);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd, u8 *mac)\r\n{\r\nstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\r\nmemcpy(sta_deauth->mac, mac, ETH_ALEN);\r\nsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\r\ncmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\r\nS_DS_GEN);\r\nreturn 0;\r\n}\r\nint mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,\r\nu16 cmd_action, u32 type,\r\nvoid *data_buf, void *cmd_buf)\r\n{\r\nstruct host_cmd_ds_command *cmd = cmd_buf;\r\nswitch (cmd_no) {\r\ncase HostCmd_CMD_UAP_SYS_CONFIG:\r\nif (mwifiex_cmd_uap_sys_config(cmd, cmd_action, type, data_buf))\r\nreturn -1;\r\nbreak;\r\ncase HostCmd_CMD_UAP_BSS_START:\r\ncase HostCmd_CMD_UAP_BSS_STOP:\r\ncase HOST_CMD_APCMD_SYS_RESET:\r\ncase HOST_CMD_APCMD_STA_LIST:\r\ncmd->command = cpu_to_le16(cmd_no);\r\ncmd->size = cpu_to_le16(S_DS_GEN);\r\nbreak;\r\ncase HostCmd_CMD_UAP_STA_DEAUTH:\r\nif (mwifiex_cmd_uap_sta_deauth(priv, cmd, data_buf))\r\nreturn -1;\r\nbreak;\r\ncase HostCmd_CMD_CHAN_REPORT_REQUEST:\r\nif (mwifiex_cmd_issue_chan_report_request(priv, cmd_buf,\r\ndata_buf))\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"PREP_CMD: unknown cmd %#x\n", cmd_no);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid mwifiex_uap_set_channel(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg,\r\nstruct cfg80211_chan_def chandef)\r\n{\r\nu8 config_bands = 0, old_bands = priv->adapter->config_bands;\r\npriv->bss_chandef = chandef;\r\nbss_cfg->channel = ieee80211_frequency_to_channel(\r\nchandef.chan->center_freq);\r\nif (chandef.chan->band == NL80211_BAND_2GHZ) {\r\nbss_cfg->band_cfg = BAND_CONFIG_BG;\r\nconfig_bands = BAND_B | BAND_G;\r\nif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\r\nconfig_bands |= BAND_GN;\r\n} else {\r\nbss_cfg->band_cfg = BAND_CONFIG_A;\r\nconfig_bands = BAND_A;\r\nif (chandef.width > NL80211_CHAN_WIDTH_20_NOHT)\r\nconfig_bands |= BAND_AN;\r\nif (chandef.width > NL80211_CHAN_WIDTH_40)\r\nconfig_bands |= BAND_AAC;\r\n}\r\nswitch (chandef.width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\ncase NL80211_CHAN_WIDTH_10:\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\ncase NL80211_CHAN_WIDTH_20:\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nif (chandef.center_freq1 < chandef.chan->center_freq)\r\nbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_BELOW;\r\nelse\r\nbss_cfg->band_cfg |= MWIFIEX_SEC_CHAN_ABOVE;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80:\r\ncase NL80211_CHAN_WIDTH_80P80:\r\ncase NL80211_CHAN_WIDTH_160:\r\nbss_cfg->band_cfg |=\r\nmwifiex_get_sec_chan_offset(bss_cfg->channel) << 4;\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(priv->adapter,\r\nWARN, "Unknown channel width: %d\n",\r\nchandef.width);\r\nbreak;\r\n}\r\npriv->adapter->config_bands = config_bands;\r\nif (old_bands != config_bands) {\r\nmwifiex_send_domain_info_cmd_fw(priv->adapter->wiphy);\r\nmwifiex_dnld_txpwr_table(priv);\r\n}\r\n}\r\nint mwifiex_config_start_uap(struct mwifiex_private *priv,\r\nstruct mwifiex_uap_bss_param *bss_cfg)\r\n{\r\nenum state_11d_t state_11d;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_SYS_CONFIG,\r\nHostCmd_ACT_GEN_SET,\r\nUAP_BSS_PARAMS_I, bss_cfg, true)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Failed to set AP configuration\n");\r\nreturn -1;\r\n}\r\nstate_11d = ENABLE_11D;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\r\nHostCmd_ACT_GEN_SET, DOT11D_I,\r\n&state_11d, true)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"11D: failed to enable 11D\n");\r\nreturn -1;\r\n}\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_UAP_BSS_START,\r\nHostCmd_ACT_GEN_SET, 0, NULL, true)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Failed to start the BSS\n");\r\nreturn -1;\r\n}\r\nif (priv->sec_info.wep_enabled)\r\npriv->curr_pkt_filter |= HostCmd_ACT_MAC_WEP_ENABLE;\r\nelse\r\npriv->curr_pkt_filter &= ~HostCmd_ACT_MAC_WEP_ENABLE;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\r\nHostCmd_ACT_GEN_SET, 0,\r\n&priv->curr_pkt_filter, true))\r\nreturn -1;\r\nreturn 0;\r\n}
