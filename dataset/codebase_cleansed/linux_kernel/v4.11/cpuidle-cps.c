static int cps_nc_enter(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nenum cps_pm_state pm_state;\r\nint err;\r\nif (!cpu_data[dev->cpu].core && (index > STATE_NC_WAIT))\r\nindex = STATE_NC_WAIT;\r\nswitch (index) {\r\ncase STATE_NC_WAIT:\r\npm_state = CPS_PM_NC_WAIT;\r\nbreak;\r\ncase STATE_CLOCK_GATED:\r\npm_state = CPS_PM_CLOCK_GATED;\r\nbreak;\r\ncase STATE_POWER_GATED:\r\npm_state = CPS_PM_POWER_GATED;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nif ((pm_state == CPS_PM_POWER_GATED) && cpu_pm_enter())\r\nreturn -EINTR;\r\nerr = cps_pm_enter_state(pm_state);\r\nif (pm_state == CPS_PM_POWER_GATED)\r\ncpu_pm_exit();\r\nreturn err ?: index;\r\n}\r\nstatic void __init cps_cpuidle_unregister(void)\r\n{\r\nint cpu;\r\nstruct cpuidle_device *device;\r\nfor_each_possible_cpu(cpu) {\r\ndevice = &per_cpu(cpuidle_dev, cpu);\r\ncpuidle_unregister_device(device);\r\n}\r\ncpuidle_unregister_driver(&cps_driver);\r\n}\r\nstatic int __init cps_cpuidle_init(void)\r\n{\r\nint err, cpu, core, i;\r\nstruct cpuidle_device *device;\r\nif (!cps_pm_support_state(CPS_PM_POWER_GATED))\r\ncps_driver.state_count = STATE_CLOCK_GATED + 1;\r\nif (!cps_pm_support_state(CPS_PM_CLOCK_GATED))\r\ncps_driver.state_count = STATE_NC_WAIT + 1;\r\nif (!cps_pm_support_state(CPS_PM_NC_WAIT))\r\ncps_driver.state_count = STATE_WAIT + 1;\r\nif (cps_driver.state_count < STATE_COUNT) {\r\npr_info("cpuidle-cps: limited to ");\r\nswitch (cps_driver.state_count - 1) {\r\ncase STATE_WAIT:\r\npr_cont("coherent wait\n");\r\nbreak;\r\ncase STATE_NC_WAIT:\r\npr_cont("non-coherent wait\n");\r\nbreak;\r\ncase STATE_CLOCK_GATED:\r\npr_cont("clock gating\n");\r\nbreak;\r\n}\r\n}\r\nif (coupled_coherence)\r\nfor (i = STATE_NC_WAIT; i < cps_driver.state_count; i++)\r\ncps_driver.states[i].flags |= CPUIDLE_FLAG_COUPLED;\r\nerr = cpuidle_register_driver(&cps_driver);\r\nif (err) {\r\npr_err("Failed to register CPS cpuidle driver\n");\r\nreturn err;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\ncore = cpu_data[cpu].core;\r\ndevice = &per_cpu(cpuidle_dev, cpu);\r\ndevice->cpu = cpu;\r\n#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED\r\ncpumask_copy(&device->coupled_cpus, &cpu_sibling_map[cpu]);\r\n#endif\r\nerr = cpuidle_register_device(device);\r\nif (err) {\r\npr_err("Failed to register CPU%d cpuidle device\n",\r\ncpu);\r\ngoto err_out;\r\n}\r\n}\r\nreturn 0;\r\nerr_out:\r\ncps_cpuidle_unregister();\r\nreturn err;\r\n}
