static inline struct bc_timer *rk_timer(struct clock_event_device *ce)\r\n{\r\nreturn container_of(ce, struct bc_timer, ce);\r\n}\r\nstatic inline void __iomem *rk_base(struct clock_event_device *ce)\r\n{\r\nreturn rk_timer(ce)->base;\r\n}\r\nstatic inline void __iomem *rk_ctrl(struct clock_event_device *ce)\r\n{\r\nreturn rk_timer(ce)->ctrl;\r\n}\r\nstatic inline void rk_timer_disable(struct clock_event_device *ce)\r\n{\r\nwritel_relaxed(TIMER_DISABLE, rk_ctrl(ce));\r\n}\r\nstatic inline void rk_timer_enable(struct clock_event_device *ce, u32 flags)\r\n{\r\nwritel_relaxed(TIMER_ENABLE | TIMER_INT_UNMASK | flags,\r\nrk_ctrl(ce));\r\n}\r\nstatic void rk_timer_update_counter(unsigned long cycles,\r\nstruct clock_event_device *ce)\r\n{\r\nwritel_relaxed(cycles, rk_base(ce) + TIMER_LOAD_COUNT0);\r\nwritel_relaxed(0, rk_base(ce) + TIMER_LOAD_COUNT1);\r\n}\r\nstatic void rk_timer_interrupt_clear(struct clock_event_device *ce)\r\n{\r\nwritel_relaxed(1, rk_base(ce) + TIMER_INT_STATUS);\r\n}\r\nstatic inline int rk_timer_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nrk_timer_update_counter(cycles, ce);\r\nrk_timer_enable(ce, TIMER_MODE_USER_DEFINED_COUNT);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_shutdown(struct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nreturn 0;\r\n}\r\nstatic int rk_timer_set_periodic(struct clock_event_device *ce)\r\n{\r\nrk_timer_disable(ce);\r\nrk_timer_update_counter(rk_timer(ce)->freq / HZ - 1, ce);\r\nrk_timer_enable(ce, TIMER_MODE_FREE_RUNNING);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rk_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *ce = dev_id;\r\nrk_timer_interrupt_clear(ce);\r\nif (clockevent_state_oneshot(ce))\r\nrk_timer_disable(ce);\r\nce->event_handler(ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init rk_timer_init(struct device_node *np, u32 ctrl_reg)\r\n{\r\nstruct clock_event_device *ce = &bc_timer.ce;\r\nstruct clk *timer_clk;\r\nstruct clk *pclk;\r\nint ret = -EINVAL, irq;\r\nbc_timer.base = of_iomap(np, 0);\r\nif (!bc_timer.base) {\r\npr_err("Failed to get base address for '%s'\n", TIMER_NAME);\r\nreturn -ENXIO;\r\n}\r\nbc_timer.ctrl = bc_timer.base + ctrl_reg;\r\npclk = of_clk_get_by_name(np, "pclk");\r\nif (IS_ERR(pclk)) {\r\nret = PTR_ERR(pclk);\r\npr_err("Failed to get pclk for '%s'\n", TIMER_NAME);\r\ngoto out_unmap;\r\n}\r\nret = clk_prepare_enable(pclk);\r\nif (ret) {\r\npr_err("Failed to enable pclk for '%s'\n", TIMER_NAME);\r\ngoto out_unmap;\r\n}\r\ntimer_clk = of_clk_get_by_name(np, "timer");\r\nif (IS_ERR(timer_clk)) {\r\nret = PTR_ERR(timer_clk);\r\npr_err("Failed to get timer clock for '%s'\n", TIMER_NAME);\r\ngoto out_timer_clk;\r\n}\r\nret = clk_prepare_enable(timer_clk);\r\nif (ret) {\r\npr_err("Failed to enable timer clock\n");\r\ngoto out_timer_clk;\r\n}\r\nbc_timer.freq = clk_get_rate(timer_clk);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\nret = -EINVAL;\r\npr_err("Failed to map interrupts for '%s'\n", TIMER_NAME);\r\ngoto out_irq;\r\n}\r\nce->name = TIMER_NAME;\r\nce->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_DYNIRQ;\r\nce->set_next_event = rk_timer_set_next_event;\r\nce->set_state_shutdown = rk_timer_shutdown;\r\nce->set_state_periodic = rk_timer_set_periodic;\r\nce->irq = irq;\r\nce->cpumask = cpu_possible_mask;\r\nce->rating = 250;\r\nrk_timer_interrupt_clear(ce);\r\nrk_timer_disable(ce);\r\nret = request_irq(irq, rk_timer_interrupt, IRQF_TIMER, TIMER_NAME, ce);\r\nif (ret) {\r\npr_err("Failed to initialize '%s': %d\n", TIMER_NAME, ret);\r\ngoto out_irq;\r\n}\r\nclockevents_config_and_register(ce, bc_timer.freq, 1, UINT_MAX);\r\nreturn 0;\r\nout_irq:\r\nclk_disable_unprepare(timer_clk);\r\nout_timer_clk:\r\nclk_disable_unprepare(pclk);\r\nout_unmap:\r\niounmap(bc_timer.base);\r\nreturn ret;\r\n}\r\nstatic int __init rk3288_timer_init(struct device_node *np)\r\n{\r\nreturn rk_timer_init(np, TIMER_CONTROL_REG3288);\r\n}\r\nstatic int __init rk3399_timer_init(struct device_node *np)\r\n{\r\nreturn rk_timer_init(np, TIMER_CONTROL_REG3399);\r\n}
