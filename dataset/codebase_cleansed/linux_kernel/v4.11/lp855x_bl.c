static int lp855x_write_byte(struct lp855x *lp, u8 reg, u8 data)\r\n{\r\nreturn i2c_smbus_write_byte_data(lp->client, reg, data);\r\n}\r\nstatic int lp855x_update_bit(struct lp855x *lp, u8 reg, u8 mask, u8 data)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = i2c_smbus_read_byte_data(lp->client, reg);\r\nif (ret < 0) {\r\ndev_err(lp->dev, "failed to read 0x%.2x\n", reg);\r\nreturn ret;\r\n}\r\ntmp = (u8)ret;\r\ntmp &= ~mask;\r\ntmp |= data & mask;\r\nreturn lp855x_write_byte(lp, reg, tmp);\r\n}\r\nstatic bool lp855x_is_valid_rom_area(struct lp855x *lp, u8 addr)\r\n{\r\nu8 start, end;\r\nswitch (lp->chip_id) {\r\ncase LP8550:\r\ncase LP8551:\r\ncase LP8552:\r\ncase LP8553:\r\nstart = LP855X_EEPROM_START;\r\nend = LP855X_EEPROM_END;\r\nbreak;\r\ncase LP8556:\r\nstart = LP8556_EPROM_START;\r\nend = LP8556_EPROM_END;\r\nbreak;\r\ncase LP8555:\r\nstart = LP8555_EPROM_START;\r\nend = LP8555_EPROM_END;\r\nbreak;\r\ncase LP8557:\r\nstart = LP8557_EPROM_START;\r\nend = LP8557_EPROM_END;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn addr >= start && addr <= end;\r\n}\r\nstatic int lp8557_bl_off(struct lp855x *lp)\r\n{\r\nreturn lp855x_update_bit(lp, LP8557_BL_CMD, LP8557_BL_MASK,\r\nLP8557_BL_OFF);\r\n}\r\nstatic int lp8557_bl_on(struct lp855x *lp)\r\n{\r\nreturn lp855x_update_bit(lp, LP8557_BL_CMD, LP8557_BL_MASK,\r\nLP8557_BL_ON);\r\n}\r\nstatic int lp855x_configure(struct lp855x *lp)\r\n{\r\nu8 val, addr;\r\nint i, ret;\r\nstruct lp855x_platform_data *pd = lp->pdata;\r\nswitch (lp->chip_id) {\r\ncase LP8550:\r\ncase LP8551:\r\ncase LP8552:\r\ncase LP8553:\r\ncase LP8556:\r\nlp->cfg = &lp855x_dev_cfg;\r\nbreak;\r\ncase LP8555:\r\ncase LP8557:\r\nlp->cfg = &lp8557_dev_cfg;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (lp->cfg->pre_init_device) {\r\nret = lp->cfg->pre_init_device(lp);\r\nif (ret) {\r\ndev_err(lp->dev, "pre init device err: %d\n", ret);\r\ngoto err;\r\n}\r\n}\r\nval = pd->initial_brightness;\r\nret = lp855x_write_byte(lp, lp->cfg->reg_brightness, val);\r\nif (ret)\r\ngoto err;\r\nval = pd->device_control;\r\nret = lp855x_write_byte(lp, lp->cfg->reg_devicectrl, val);\r\nif (ret)\r\ngoto err;\r\nif (pd->size_program > 0) {\r\nfor (i = 0; i < pd->size_program; i++) {\r\naddr = pd->rom_data[i].addr;\r\nval = pd->rom_data[i].val;\r\nif (!lp855x_is_valid_rom_area(lp, addr))\r\ncontinue;\r\nret = lp855x_write_byte(lp, addr, val);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nif (lp->cfg->post_init_device) {\r\nret = lp->cfg->post_init_device(lp);\r\nif (ret) {\r\ndev_err(lp->dev, "post init device err: %d\n", ret);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void lp855x_pwm_ctrl(struct lp855x *lp, int br, int max_br)\r\n{\r\nunsigned int period = lp->pdata->period_ns;\r\nunsigned int duty = br * period / max_br;\r\nstruct pwm_device *pwm;\r\nif (!lp->pwm) {\r\npwm = devm_pwm_get(lp->dev, lp->chipname);\r\nif (IS_ERR(pwm))\r\nreturn;\r\nlp->pwm = pwm;\r\npwm_apply_args(pwm);\r\n}\r\npwm_config(lp->pwm, duty, period);\r\nif (duty)\r\npwm_enable(lp->pwm);\r\nelse\r\npwm_disable(lp->pwm);\r\n}\r\nstatic int lp855x_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct lp855x *lp = bl_get_data(bl);\r\nint brightness = bl->props.brightness;\r\nif (bl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))\r\nbrightness = 0;\r\nif (lp->mode == PWM_BASED)\r\nlp855x_pwm_ctrl(lp, brightness, bl->props.max_brightness);\r\nelse if (lp->mode == REGISTER_BASED)\r\nlp855x_write_byte(lp, lp->cfg->reg_brightness, (u8)brightness);\r\nreturn 0;\r\n}\r\nstatic int lp855x_backlight_register(struct lp855x *lp)\r\n{\r\nstruct backlight_device *bl;\r\nstruct backlight_properties props;\r\nstruct lp855x_platform_data *pdata = lp->pdata;\r\nconst char *name = pdata->name ? : DEFAULT_BL_NAME;\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nif (pdata->initial_brightness > props.max_brightness)\r\npdata->initial_brightness = props.max_brightness;\r\nprops.brightness = pdata->initial_brightness;\r\nbl = devm_backlight_device_register(lp->dev, name, lp->dev, lp,\r\n&lp855x_bl_ops, &props);\r\nif (IS_ERR(bl))\r\nreturn PTR_ERR(bl);\r\nlp->bl = bl;\r\nreturn 0;\r\n}\r\nstatic ssize_t lp855x_get_chip_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp855x *lp = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", lp->chipname);\r\n}\r\nstatic ssize_t lp855x_get_bl_ctl_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp855x *lp = dev_get_drvdata(dev);\r\nchar *strmode = NULL;\r\nif (lp->mode == PWM_BASED)\r\nstrmode = "pwm based";\r\nelse if (lp->mode == REGISTER_BASED)\r\nstrmode = "register based";\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", strmode);\r\n}\r\nstatic int lp855x_parse_dt(struct lp855x *lp)\r\n{\r\nstruct device *dev = lp->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct lp855x_platform_data *pdata;\r\nint rom_length;\r\nif (!node) {\r\ndev_err(dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nof_property_read_string(node, "bl-name", &pdata->name);\r\nof_property_read_u8(node, "dev-ctrl", &pdata->device_control);\r\nof_property_read_u8(node, "init-brt", &pdata->initial_brightness);\r\nof_property_read_u32(node, "pwm-period", &pdata->period_ns);\r\nrom_length = of_get_child_count(node);\r\nif (rom_length > 0) {\r\nstruct lp855x_rom_data *rom;\r\nstruct device_node *child;\r\nint i = 0;\r\nrom = devm_kzalloc(dev, sizeof(*rom) * rom_length, GFP_KERNEL);\r\nif (!rom)\r\nreturn -ENOMEM;\r\nfor_each_child_of_node(node, child) {\r\nof_property_read_u8(child, "rom-addr", &rom[i].addr);\r\nof_property_read_u8(child, "rom-val", &rom[i].val);\r\ni++;\r\n}\r\npdata->size_program = rom_length;\r\npdata->rom_data = &rom[0];\r\n}\r\nlp->pdata = pdata;\r\nreturn 0;\r\n}\r\nstatic int lp855x_parse_dt(struct lp855x *lp)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int lp855x_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct lp855x *lp;\r\nint ret;\r\nif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\nlp = devm_kzalloc(&cl->dev, sizeof(struct lp855x), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nlp->client = cl;\r\nlp->dev = &cl->dev;\r\nlp->chipname = id->name;\r\nlp->chip_id = id->driver_data;\r\nlp->pdata = dev_get_platdata(&cl->dev);\r\nif (!lp->pdata) {\r\nret = lp855x_parse_dt(lp);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (lp->pdata->period_ns > 0)\r\nlp->mode = PWM_BASED;\r\nelse\r\nlp->mode = REGISTER_BASED;\r\nlp->supply = devm_regulator_get(lp->dev, "power");\r\nif (IS_ERR(lp->supply)) {\r\nif (PTR_ERR(lp->supply) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nlp->supply = NULL;\r\n}\r\nlp->enable = devm_regulator_get_optional(lp->dev, "enable");\r\nif (IS_ERR(lp->enable)) {\r\nret = PTR_ERR(lp->enable);\r\nif (ret == -ENODEV) {\r\nlp->enable = NULL;\r\n} else {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(lp->dev, "error getting enable regulator: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (lp->supply) {\r\nret = regulator_enable(lp->supply);\r\nif (ret < 0) {\r\ndev_err(&cl->dev, "failed to enable supply: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (lp->enable) {\r\nret = regulator_enable(lp->enable);\r\nif (ret < 0) {\r\ndev_err(lp->dev, "failed to enable vddio: %d\n", ret);\r\nreturn ret;\r\n}\r\nusleep_range(1000, 2000);\r\n}\r\ni2c_set_clientdata(cl, lp);\r\nret = lp855x_configure(lp);\r\nif (ret) {\r\ndev_err(lp->dev, "device config err: %d", ret);\r\nreturn ret;\r\n}\r\nret = lp855x_backlight_register(lp);\r\nif (ret) {\r\ndev_err(lp->dev,\r\n"failed to register backlight. err: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&lp->dev->kobj, &lp855x_attr_group);\r\nif (ret) {\r\ndev_err(lp->dev, "failed to register sysfs. err: %d\n", ret);\r\nreturn ret;\r\n}\r\nbacklight_update_status(lp->bl);\r\nreturn 0;\r\n}\r\nstatic int lp855x_remove(struct i2c_client *cl)\r\n{\r\nstruct lp855x *lp = i2c_get_clientdata(cl);\r\nlp->bl->props.brightness = 0;\r\nbacklight_update_status(lp->bl);\r\nif (lp->supply)\r\nregulator_disable(lp->supply);\r\nsysfs_remove_group(&lp->dev->kobj, &lp855x_attr_group);\r\nreturn 0;\r\n}
