static const char *mei_wdt_state_str(enum mei_wdt_state state)\r\n{\r\nswitch (state) {\r\ncase MEI_WDT_PROBE:\r\nreturn "PROBE";\r\ncase MEI_WDT_IDLE:\r\nreturn "IDLE";\r\ncase MEI_WDT_START:\r\nreturn "START";\r\ncase MEI_WDT_RUNNING:\r\nreturn "RUNNING";\r\ncase MEI_WDT_STOPPING:\r\nreturn "STOPPING";\r\ncase MEI_WDT_NOT_REQUIRED:\r\nreturn "NOT_REQUIRED";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic int mei_wdt_ping(struct mei_wdt *wdt)\r\n{\r\nstruct mei_wdt_start_request req;\r\nconst size_t req_len = sizeof(req);\r\nint ret;\r\nmemset(&req, 0, req_len);\r\nreq.hdr.command = MEI_MANAGEMENT_CONTROL;\r\nreq.hdr.bytecount = req_len - offsetof(struct mei_mc_hdr, subcommand);\r\nreq.hdr.subcommand = MEI_MC_START_WD_TIMER_REQ;\r\nreq.hdr.versionnumber = MEI_MC_VERSION_NUMBER;\r\nreq.timeout = wdt->timeout;\r\nret = mei_cldev_send(wdt->cldev, (u8 *)&req, req_len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mei_wdt_stop(struct mei_wdt *wdt)\r\n{\r\nstruct mei_wdt_stop_request req;\r\nconst size_t req_len = sizeof(req);\r\nint ret;\r\nmemset(&req, 0, req_len);\r\nreq.hdr.command = MEI_MANAGEMENT_CONTROL;\r\nreq.hdr.bytecount = req_len - offsetof(struct mei_mc_hdr, subcommand);\r\nreq.hdr.subcommand = MEI_MC_STOP_WD_TIMER_REQ;\r\nreq.hdr.versionnumber = MEI_MC_VERSION_NUMBER;\r\nret = mei_cldev_send(wdt->cldev, (u8 *)&req, req_len);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mei_wdt_ops_start(struct watchdog_device *wdd)\r\n{\r\nstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->state = MEI_WDT_START;\r\nwdd->timeout = wdt->timeout;\r\nreturn 0;\r\n}\r\nstatic int mei_wdt_ops_stop(struct watchdog_device *wdd)\r\n{\r\nstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\r\nint ret;\r\nif (wdt->state != MEI_WDT_RUNNING)\r\nreturn 0;\r\nwdt->state = MEI_WDT_STOPPING;\r\nret = mei_wdt_stop(wdt);\r\nif (ret)\r\nreturn ret;\r\nwdt->state = MEI_WDT_IDLE;\r\nreturn 0;\r\n}\r\nstatic int mei_wdt_ops_ping(struct watchdog_device *wdd)\r\n{\r\nstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\r\nint ret;\r\nif (wdt->state != MEI_WDT_START && wdt->state != MEI_WDT_RUNNING)\r\nreturn 0;\r\nif (wdt->resp_required)\r\ninit_completion(&wdt->response);\r\nwdt->state = MEI_WDT_RUNNING;\r\nret = mei_wdt_ping(wdt);\r\nif (ret)\r\nreturn ret;\r\nif (wdt->resp_required)\r\nret = wait_for_completion_killable(&wdt->response);\r\nreturn ret;\r\n}\r\nstatic int mei_wdt_ops_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct mei_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->timeout = timeout;\r\nwdd->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic inline bool __mei_wdt_is_registered(struct mei_wdt *wdt)\r\n{\r\nreturn !!watchdog_get_drvdata(&wdt->wdd);\r\n}\r\nstatic void mei_wdt_unregister(struct mei_wdt *wdt)\r\n{\r\nmutex_lock(&wdt->reg_lock);\r\nif (__mei_wdt_is_registered(wdt)) {\r\nwatchdog_unregister_device(&wdt->wdd);\r\nwatchdog_set_drvdata(&wdt->wdd, NULL);\r\nmemset(&wdt->wdd, 0, sizeof(wdt->wdd));\r\n}\r\nmutex_unlock(&wdt->reg_lock);\r\n}\r\nstatic int mei_wdt_register(struct mei_wdt *wdt)\r\n{\r\nstruct device *dev;\r\nint ret;\r\nif (!wdt || !wdt->cldev)\r\nreturn -EINVAL;\r\ndev = &wdt->cldev->dev;\r\nmutex_lock(&wdt->reg_lock);\r\nif (__mei_wdt_is_registered(wdt)) {\r\nret = 0;\r\ngoto out;\r\n}\r\nwdt->wdd.info = &wd_info;\r\nwdt->wdd.ops = &wd_ops;\r\nwdt->wdd.parent = dev;\r\nwdt->wdd.timeout = MEI_WDT_DEFAULT_TIMEOUT;\r\nwdt->wdd.min_timeout = MEI_WDT_MIN_TIMEOUT;\r\nwdt->wdd.max_timeout = MEI_WDT_MAX_TIMEOUT;\r\nwatchdog_set_drvdata(&wdt->wdd, wdt);\r\nwatchdog_stop_on_reboot(&wdt->wdd);\r\nret = watchdog_register_device(&wdt->wdd);\r\nif (ret) {\r\ndev_err(dev, "unable to register watchdog device = %d.\n", ret);\r\nwatchdog_set_drvdata(&wdt->wdd, NULL);\r\n}\r\nwdt->state = MEI_WDT_IDLE;\r\nout:\r\nmutex_unlock(&wdt->reg_lock);\r\nreturn ret;\r\n}\r\nstatic void mei_wdt_unregister_work(struct work_struct *work)\r\n{\r\nstruct mei_wdt *wdt = container_of(work, struct mei_wdt, unregister);\r\nmei_wdt_unregister(wdt);\r\n}\r\nstatic void mei_wdt_rx(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\r\nstruct mei_wdt_start_response res;\r\nconst size_t res_len = sizeof(res);\r\nint ret;\r\nret = mei_cldev_recv(wdt->cldev, (u8 *)&res, res_len);\r\nif (ret < 0) {\r\ndev_err(&cldev->dev, "failure in recv %d\n", ret);\r\nreturn;\r\n}\r\nif (ret == 0)\r\nreturn;\r\nif (ret < sizeof(struct mei_mc_hdr)) {\r\ndev_err(&cldev->dev, "recv small data %d\n", ret);\r\nreturn;\r\n}\r\nif (res.hdr.command != MEI_MANAGEMENT_CONTROL ||\r\nres.hdr.versionnumber != MEI_MC_VERSION_NUMBER) {\r\ndev_err(&cldev->dev, "wrong command received\n");\r\nreturn;\r\n}\r\nif (res.hdr.subcommand != MEI_MC_START_WD_TIMER_RES) {\r\ndev_warn(&cldev->dev, "unsupported command %d :%s[%d]\n",\r\nres.hdr.subcommand,\r\nmei_wdt_state_str(wdt->state),\r\nwdt->state);\r\nreturn;\r\n}\r\nif (wdt->state == MEI_WDT_RUNNING) {\r\nif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {\r\nwdt->state = MEI_WDT_NOT_REQUIRED;\r\nschedule_work(&wdt->unregister);\r\n}\r\ngoto out;\r\n}\r\nif (wdt->state == MEI_WDT_PROBE) {\r\nif (res.wdstate & MEI_WDT_WDSTATE_NOT_REQUIRED) {\r\nwdt->state = MEI_WDT_NOT_REQUIRED;\r\n} else {\r\nmei_wdt_stop(wdt);\r\nmei_wdt_register(wdt);\r\n}\r\nreturn;\r\n}\r\ndev_warn(&cldev->dev, "not in correct state %s[%d]\n",\r\nmei_wdt_state_str(wdt->state), wdt->state);\r\nout:\r\nif (!completion_done(&wdt->response))\r\ncomplete(&wdt->response);\r\n}\r\nstatic void mei_wdt_notif(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\r\nif (wdt->state != MEI_WDT_NOT_REQUIRED)\r\nreturn;\r\nmei_wdt_register(wdt);\r\n}\r\nstatic ssize_t mei_dbgfs_read_activation(struct file *file, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nstruct mei_wdt *wdt = file->private_data;\r\nconst size_t bufsz = 32;\r\nchar buf[32];\r\nssize_t pos;\r\nmutex_lock(&wdt->reg_lock);\r\npos = scnprintf(buf, bufsz, "%s\n",\r\n__mei_wdt_is_registered(wdt) ? "activated" : "deactivated");\r\nmutex_unlock(&wdt->reg_lock);\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);\r\n}\r\nstatic ssize_t mei_dbgfs_read_state(struct file *file, char __user *ubuf,\r\nsize_t cnt, loff_t *ppos)\r\n{\r\nstruct mei_wdt *wdt = file->private_data;\r\nconst size_t bufsz = 32;\r\nchar buf[bufsz];\r\nssize_t pos;\r\npos = scnprintf(buf, bufsz, "state: %s\n",\r\nmei_wdt_state_str(wdt->state));\r\nreturn simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);\r\n}\r\nstatic void dbgfs_unregister(struct mei_wdt *wdt)\r\n{\r\ndebugfs_remove_recursive(wdt->dbgfs_dir);\r\nwdt->dbgfs_dir = NULL;\r\n}\r\nstatic int dbgfs_register(struct mei_wdt *wdt)\r\n{\r\nstruct dentry *dir, *f;\r\ndir = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\nwdt->dbgfs_dir = dir;\r\nf = debugfs_create_file("state", S_IRUSR, dir, wdt, &dbgfs_fops_state);\r\nif (!f)\r\ngoto err;\r\nf = debugfs_create_file("activation", S_IRUSR,\r\ndir, wdt, &dbgfs_fops_activation);\r\nif (!f)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndbgfs_unregister(wdt);\r\nreturn -ENODEV;\r\n}\r\nstatic inline void dbgfs_unregister(struct mei_wdt *wdt) {}\r\nstatic inline int dbgfs_register(struct mei_wdt *wdt)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mei_wdt_probe(struct mei_cl_device *cldev,\r\nconst struct mei_cl_device_id *id)\r\n{\r\nstruct mei_wdt *wdt;\r\nint ret;\r\nwdt = kzalloc(sizeof(struct mei_wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdt->timeout = MEI_WDT_DEFAULT_TIMEOUT;\r\nwdt->state = MEI_WDT_PROBE;\r\nwdt->cldev = cldev;\r\nwdt->resp_required = mei_cldev_ver(cldev) > 0x1;\r\nmutex_init(&wdt->reg_lock);\r\ninit_completion(&wdt->response);\r\nINIT_WORK(&wdt->unregister, mei_wdt_unregister_work);\r\nmei_cldev_set_drvdata(cldev, wdt);\r\nret = mei_cldev_enable(cldev);\r\nif (ret < 0) {\r\ndev_err(&cldev->dev, "Could not enable cl device\n");\r\ngoto err_out;\r\n}\r\nret = mei_cldev_register_rx_cb(wdt->cldev, mei_wdt_rx);\r\nif (ret) {\r\ndev_err(&cldev->dev, "Could not reg rx event ret=%d\n", ret);\r\ngoto err_disable;\r\n}\r\nret = mei_cldev_register_notif_cb(wdt->cldev, mei_wdt_notif);\r\nif (ret && ret != -EOPNOTSUPP) {\r\ndev_err(&cldev->dev, "Could not reg notif event ret=%d\n", ret);\r\ngoto err_disable;\r\n}\r\nwd_info.firmware_version = mei_cldev_ver(cldev);\r\nif (wdt->resp_required)\r\nret = mei_wdt_ping(wdt);\r\nelse\r\nret = mei_wdt_register(wdt);\r\nif (ret)\r\ngoto err_disable;\r\nif (dbgfs_register(wdt))\r\ndev_warn(&cldev->dev, "cannot register debugfs\n");\r\nreturn 0;\r\nerr_disable:\r\nmei_cldev_disable(cldev);\r\nerr_out:\r\nkfree(wdt);\r\nreturn ret;\r\n}\r\nstatic int mei_wdt_remove(struct mei_cl_device *cldev)\r\n{\r\nstruct mei_wdt *wdt = mei_cldev_get_drvdata(cldev);\r\nif (!completion_done(&wdt->response))\r\ncomplete(&wdt->response);\r\ncancel_work_sync(&wdt->unregister);\r\nmei_wdt_unregister(wdt);\r\nmei_cldev_disable(cldev);\r\ndbgfs_unregister(wdt);\r\nkfree(wdt);\r\nreturn 0;\r\n}
