int ll_xattr_init(void)\r\n{\r\nreturn lu_kmem_init(xattr_caches);\r\n}\r\nvoid ll_xattr_fini(void)\r\n{\r\nlu_kmem_fini(xattr_caches);\r\n}\r\nstatic void ll_xattr_cache_init(struct ll_inode_info *lli)\r\n{\r\nINIT_LIST_HEAD(&lli->lli_xattrs);\r\nset_bit(LLIF_XATTR_CACHE, &lli->lli_flags);\r\n}\r\nstatic int ll_xattr_cache_find(struct list_head *cache,\r\nconst char *xattr_name,\r\nstruct ll_xattr_entry **xattr)\r\n{\r\nstruct ll_xattr_entry *entry;\r\nlist_for_each_entry(entry, cache, xe_list) {\r\nif (!xattr_name || strcmp(xattr_name, entry->xe_name) == 0) {\r\n*xattr = entry;\r\nCDEBUG(D_CACHE, "find: [%s]=%.*s\n",\r\nentry->xe_name, entry->xe_vallen,\r\nentry->xe_value);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic int ll_xattr_cache_add(struct list_head *cache,\r\nconst char *xattr_name,\r\nconst char *xattr_val,\r\nunsigned int xattr_val_len)\r\n{\r\nstruct ll_xattr_entry *xattr;\r\nif (ll_xattr_cache_find(cache, xattr_name, &xattr) == 0) {\r\nCDEBUG(D_CACHE, "duplicate xattr: [%s]\n", xattr_name);\r\nreturn -EPROTO;\r\n}\r\nxattr = kmem_cache_zalloc(xattr_kmem, GFP_NOFS);\r\nif (!xattr) {\r\nCDEBUG(D_CACHE, "failed to allocate xattr\n");\r\nreturn -ENOMEM;\r\n}\r\nxattr->xe_name = kstrdup(xattr_name, GFP_NOFS);\r\nif (!xattr->xe_name) {\r\nCDEBUG(D_CACHE, "failed to alloc xattr name %u\n",\r\nxattr->xe_namelen);\r\ngoto err_name;\r\n}\r\nxattr->xe_value = kmemdup(xattr_val, xattr_val_len, GFP_NOFS);\r\nif (!xattr->xe_value)\r\ngoto err_value;\r\nxattr->xe_vallen = xattr_val_len;\r\nlist_add(&xattr->xe_list, cache);\r\nCDEBUG(D_CACHE, "set: [%s]=%.*s\n", xattr_name, xattr_val_len,\r\nxattr_val);\r\nreturn 0;\r\nerr_value:\r\nkfree(xattr->xe_name);\r\nerr_name:\r\nkmem_cache_free(xattr_kmem, xattr);\r\nreturn -ENOMEM;\r\n}\r\nstatic int ll_xattr_cache_del(struct list_head *cache,\r\nconst char *xattr_name)\r\n{\r\nstruct ll_xattr_entry *xattr;\r\nCDEBUG(D_CACHE, "del xattr: %s\n", xattr_name);\r\nif (ll_xattr_cache_find(cache, xattr_name, &xattr) == 0) {\r\nlist_del(&xattr->xe_list);\r\nkfree(xattr->xe_name);\r\nkfree(xattr->xe_value);\r\nkmem_cache_free(xattr_kmem, xattr);\r\nreturn 0;\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic int ll_xattr_cache_list(struct list_head *cache,\r\nchar *xld_buffer,\r\nint xld_size)\r\n{\r\nstruct ll_xattr_entry *xattr, *tmp;\r\nint xld_tail = 0;\r\nlist_for_each_entry_safe(xattr, tmp, cache, xe_list) {\r\nCDEBUG(D_CACHE, "list: buffer=%p[%d] name=%s\n",\r\nxld_buffer, xld_tail, xattr->xe_name);\r\nif (xld_buffer) {\r\nxld_size -= xattr->xe_namelen;\r\nif (xld_size < 0)\r\nbreak;\r\nmemcpy(&xld_buffer[xld_tail],\r\nxattr->xe_name, xattr->xe_namelen);\r\n}\r\nxld_tail += xattr->xe_namelen;\r\n}\r\nif (xld_size < 0)\r\nreturn -ERANGE;\r\nreturn xld_tail;\r\n}\r\nstatic int ll_xattr_cache_valid(struct ll_inode_info *lli)\r\n{\r\nreturn test_bit(LLIF_XATTR_CACHE, &lli->lli_flags);\r\n}\r\nstatic int ll_xattr_cache_destroy_locked(struct ll_inode_info *lli)\r\n{\r\nif (!ll_xattr_cache_valid(lli))\r\nreturn 0;\r\nwhile (ll_xattr_cache_del(&lli->lli_xattrs, NULL) == 0)\r\n;\r\nclear_bit(LLIF_XATTR_CACHE, &lli->lli_flags);\r\nreturn 0;\r\n}\r\nint ll_xattr_cache_destroy(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nint rc;\r\ndown_write(&lli->lli_xattrs_list_rwsem);\r\nrc = ll_xattr_cache_destroy_locked(lli);\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nreturn rc;\r\n}\r\nstatic int ll_xattr_find_get_lock(struct inode *inode,\r\nstruct lookup_intent *oit,\r\nstruct ptlrpc_request **req)\r\n{\r\nenum ldlm_mode mode;\r\nstruct lustre_handle lockh = { 0 };\r\nstruct md_op_data *op_data;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ldlm_enqueue_info einfo = {\r\n.ei_type = LDLM_IBITS,\r\n.ei_mode = it_to_lock_mode(oit),\r\n.ei_cb_bl = &ll_md_blocking_ast,\r\n.ei_cb_cp = &ldlm_completion_ast,\r\n};\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct obd_export *exp = sbi->ll_md_exp;\r\nint rc;\r\nmutex_lock(&lli->lli_xattrs_enq_lock);\r\nif (ll_xattr_cache_valid(lli)) {\r\nmode = ll_take_md_lock(inode, MDS_INODELOCK_XATTR, &lockh, 0,\r\nLCK_PR);\r\nif (mode != 0) {\r\noit->it_lock_handle = lockh.cookie;\r\noit->it_lock_mode = mode;\r\ngoto out;\r\n}\r\n}\r\nop_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,\r\nLUSTRE_OPC_ANY, NULL);\r\nif (IS_ERR(op_data)) {\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn PTR_ERR(op_data);\r\n}\r\nop_data->op_valid = OBD_MD_FLXATTR | OBD_MD_FLXATTRLS;\r\nrc = md_enqueue(exp, &einfo, NULL, oit, op_data, &lockh, 0);\r\nll_finish_md_op_data(op_data);\r\nif (rc < 0) {\r\nCDEBUG(D_CACHE,\r\n"md_intent_lock failed with %d for fid "DFID"\n",\r\nrc, PFID(ll_inode2fid(inode)));\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn rc;\r\n}\r\n*req = oit->it_request;\r\nout:\r\ndown_write(&lli->lli_xattrs_list_rwsem);\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn 0;\r\n}\r\nstatic int ll_xattr_cache_refill(struct inode *inode, struct lookup_intent *oit)\r\n{\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct ptlrpc_request *req = NULL;\r\nconst char *xdata, *xval, *xtail, *xvtail;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct mdt_body *body;\r\n__u32 *xsizes;\r\nint rc, i;\r\nrc = ll_xattr_find_get_lock(inode, oit, &req);\r\nif (rc)\r\ngoto out_no_unlock;\r\nif (ll_xattr_cache_valid(lli)) {\r\nll_stats_ops_tally(sbi, LPROC_LL_GETXATTR_HITS, 1);\r\nrc = 0;\r\ngoto out_maybe_drop;\r\n}\r\nif (unlikely(!req)) {\r\nCDEBUG(D_CACHE, "cancelled by a parallel getxattr\n");\r\nrc = -EIO;\r\ngoto out_maybe_drop;\r\n}\r\nif (oit->it_status < 0) {\r\nCDEBUG(D_CACHE, "getxattr intent returned %d for fid "DFID"\n",\r\noit->it_status, PFID(ll_inode2fid(inode)));\r\nrc = oit->it_status;\r\nif (rc == -ERANGE)\r\nrc = -EAGAIN;\r\ngoto out_destroy;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (!body) {\r\nCERROR("no MDT BODY in the refill xattr reply\n");\r\nrc = -EPROTO;\r\ngoto out_destroy;\r\n}\r\nxdata = req_capsule_server_sized_get(&req->rq_pill, &RMF_EADATA,\r\nbody->mbo_eadatasize);\r\nxval = req_capsule_server_sized_get(&req->rq_pill, &RMF_EAVALS,\r\nbody->mbo_aclsize);\r\nxsizes = req_capsule_server_sized_get(&req->rq_pill, &RMF_EAVALS_LENS,\r\nbody->mbo_max_mdsize * sizeof(__u32));\r\nif (!xdata || !xval || !xsizes) {\r\nCERROR("wrong setxattr reply\n");\r\nrc = -EPROTO;\r\ngoto out_destroy;\r\n}\r\nxtail = xdata + body->mbo_eadatasize;\r\nxvtail = xval + body->mbo_aclsize;\r\nCDEBUG(D_CACHE, "caching: xdata=%p xtail=%p\n", xdata, xtail);\r\nll_xattr_cache_init(lli);\r\nfor (i = 0; i < body->mbo_max_mdsize; i++) {\r\nCDEBUG(D_CACHE, "caching [%s]=%.*s\n", xdata, *xsizes, xval);\r\nif (!memchr(xdata, 0, xtail - xdata)) {\r\nCERROR("xattr protocol violation (names are broken)\n");\r\nrc = -EPROTO;\r\n} else if (xval + *xsizes > xvtail) {\r\nCERROR("xattr protocol violation (vals are broken)\n");\r\nrc = -EPROTO;\r\n} else if (OBD_FAIL_CHECK(OBD_FAIL_LLITE_XATTR_ENOMEM)) {\r\nrc = -ENOMEM;\r\n} else if (!strcmp(xdata, XATTR_NAME_ACL_ACCESS)) {\r\nCDEBUG(D_CACHE, "not caching %s\n",\r\nXATTR_NAME_ACL_ACCESS);\r\nrc = 0;\r\n} else if (!strcmp(xdata, "security.selinux")) {\r\nCDEBUG(D_CACHE, "not caching security.selinux\n");\r\nrc = 0;\r\n} else {\r\nrc = ll_xattr_cache_add(&lli->lli_xattrs, xdata, xval,\r\n*xsizes);\r\n}\r\nif (rc < 0) {\r\nll_xattr_cache_destroy_locked(lli);\r\ngoto out_destroy;\r\n}\r\nxdata += strlen(xdata) + 1;\r\nxval += *xsizes;\r\nxsizes++;\r\n}\r\nif (xdata != xtail || xval != xvtail)\r\nCERROR("a hole in xattr data\n");\r\nll_set_lock_data(sbi->ll_md_exp, inode, oit, NULL);\r\ngoto out_maybe_drop;\r\nout_maybe_drop:\r\nll_intent_drop_lock(oit);\r\nif (rc != 0)\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nout_no_unlock:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\nout_destroy:\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nldlm_lock_decref_and_cancel((struct lustre_handle *)\r\n&oit->it_lock_handle,\r\noit->it_lock_mode);\r\ngoto out_no_unlock;\r\n}\r\nint ll_xattr_cache_get(struct inode *inode, const char *name, char *buffer,\r\nsize_t size, __u64 valid)\r\n{\r\nstruct lookup_intent oit = { .it_op = IT_GETXATTR };\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nint rc = 0;\r\nLASSERT(!!(valid & OBD_MD_FLXATTR) ^ !!(valid & OBD_MD_FLXATTRLS));\r\ndown_read(&lli->lli_xattrs_list_rwsem);\r\nif (!ll_xattr_cache_valid(lli)) {\r\nup_read(&lli->lli_xattrs_list_rwsem);\r\nrc = ll_xattr_cache_refill(inode, &oit);\r\nif (rc)\r\nreturn rc;\r\ndowngrade_write(&lli->lli_xattrs_list_rwsem);\r\n} else {\r\nll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_GETXATTR_HITS, 1);\r\n}\r\nif (valid & OBD_MD_FLXATTR) {\r\nstruct ll_xattr_entry *xattr;\r\nrc = ll_xattr_cache_find(&lli->lli_xattrs, name, &xattr);\r\nif (rc == 0) {\r\nrc = xattr->xe_vallen;\r\nif (size != 0) {\r\nif (size >= xattr->xe_vallen)\r\nmemcpy(buffer, xattr->xe_value,\r\nxattr->xe_vallen);\r\nelse\r\nrc = -ERANGE;\r\n}\r\n}\r\n} else if (valid & OBD_MD_FLXATTRLS) {\r\nrc = ll_xattr_cache_list(&lli->lli_xattrs,\r\nsize ? buffer : NULL, size);\r\n}\r\ngoto out;\r\nout:\r\nup_read(&lli->lli_xattrs_list_rwsem);\r\nreturn rc;\r\n}
