static int tw5864_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,\r\nunsigned int *num_planes, unsigned int sizes[],\r\nstruct device *alloc_ctxs[])\r\n{\r\nif (*num_planes)\r\nreturn sizes[0] < H264_VLC_BUF_SIZE ? -EINVAL : 0;\r\nsizes[0] = H264_VLC_BUF_SIZE;\r\n*num_planes = 1;\r\nreturn 0;\r\n}\r\nstatic void tw5864_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct tw5864_input *dev = vb2_get_drv_priv(vq);\r\nstruct tw5864_buf *buf = container_of(vbuf, struct tw5864_buf, vb);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nlist_add_tail(&buf->list, &dev->active);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int tw5864_input_std_get(struct tw5864_input *input,\r\nenum tw5864_vid_std *std)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nu8 std_reg = tw_indir_readb(TW5864_INDIR_VIN_E(input->nr));\r\n*std = (std_reg & 0x70) >> 4;\r\nif (std_reg & 0x80) {\r\ndev_dbg(&dev->pci->dev,\r\n"Video format detection is in progress, please wait\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw5864_enable_input(struct tw5864_input *input)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nint nr = input->nr;\r\nunsigned long flags;\r\nint d1_width = 720;\r\nint d1_height;\r\nint frame_width_bus_value = 0;\r\nint frame_height_bus_value = 0;\r\nint reg_frame_bus = 0x1c;\r\nint fmt_reg_value = 0;\r\nint downscale_enabled = 0;\r\ndev_dbg(&dev->pci->dev, "Enabling channel %d\n", nr);\r\ninput->frame_seqno = 0;\r\ninput->frame_gop_seqno = 0;\r\ninput->h264_idr_pic_id = 0;\r\ninput->reg_dsp_qp = input->qp;\r\ninput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\r\ninput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\r\ninput->reg_emu = TW5864_EMU_EN_LPF | TW5864_EMU_EN_BHOST\r\n| TW5864_EMU_EN_SEN | TW5864_EMU_EN_ME | TW5864_EMU_EN_DDR;\r\ninput->reg_dsp = nr\r\n| TW5864_DSP_CHROM_SW\r\n| ((0xa << 8) & TW5864_DSP_MB_DELAY)\r\n;\r\ninput->resolution = D1;\r\nd1_height = (input->std == STD_NTSC) ? 480 : 576;\r\ninput->width = d1_width;\r\ninput->height = d1_height;\r\ninput->reg_interlacing = 0x4;\r\nswitch (input->resolution) {\r\ncase D1:\r\nframe_width_bus_value = 0x2cf;\r\nframe_height_bus_value = input->height - 1;\r\nreg_frame_bus = 0x1c;\r\nfmt_reg_value = 0;\r\ndownscale_enabled = 0;\r\ninput->reg_dsp_codec |= TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD;\r\ninput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\r\ninput->reg_interlacing = TW5864_DI_EN | TW5864_DSP_INTER_ST;\r\ntw_setl(TW5864_FULL_HALF_FLAG, 1 << nr);\r\nbreak;\r\ncase HD1:\r\ninput->height /= 2;\r\ninput->width /= 2;\r\nframe_width_bus_value = 0x2cf;\r\nframe_height_bus_value = input->height * 2 - 1;\r\nreg_frame_bus = 0x1c;\r\nfmt_reg_value = 0;\r\ndownscale_enabled = 0;\r\ninput->reg_dsp_codec |= TW5864_HD1_MAP_MD;\r\ninput->reg_emu |= TW5864_DSP_FRAME_TYPE_D1;\r\ntw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\r\nbreak;\r\ncase CIF:\r\ninput->height /= 4;\r\ninput->width /= 2;\r\nframe_width_bus_value = 0x15f;\r\nframe_height_bus_value = input->height * 2 - 1;\r\nreg_frame_bus = 0x07;\r\nfmt_reg_value = 1;\r\ndownscale_enabled = 1;\r\ninput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\r\ntw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\r\nbreak;\r\ncase QCIF:\r\ninput->height /= 4;\r\ninput->width /= 4;\r\nframe_width_bus_value = 0x15f;\r\nframe_height_bus_value = input->height * 2 - 1;\r\nreg_frame_bus = 0x07;\r\nfmt_reg_value = 1;\r\ndownscale_enabled = 1;\r\ninput->reg_dsp_codec |= TW5864_CIF_MAP_MD;\r\ntw_clearl(TW5864_FULL_HALF_FLAG, 1 << nr);\r\nbreak;\r\n}\r\ntw_indir_writeb(TW5864_INDIR_IN_PIC_WIDTH(nr), d1_width / 4);\r\ntw_indir_writeb(TW5864_INDIR_IN_PIC_HEIGHT(nr), d1_height / 4);\r\ntw_indir_writeb(TW5864_INDIR_OUT_PIC_WIDTH(nr), input->width / 4);\r\ntw_indir_writeb(TW5864_INDIR_OUT_PIC_HEIGHT(nr), input->height / 4);\r\ninput->width = 704;\r\ntw_indir_writeb(TW5864_INDIR_CROP_ETC,\r\ntw_indir_readb(TW5864_INDIR_CROP_ETC) |\r\nTW5864_INDIR_CROP_ETC_CROP_EN);\r\ntw_writel(TW5864_DSP_PIC_MAX_MB,\r\n((input->width / 16) << 8) | (input->height / 16));\r\ntw_writel(TW5864_FRAME_WIDTH_BUS_A(nr),\r\nframe_width_bus_value);\r\ntw_writel(TW5864_FRAME_WIDTH_BUS_B(nr),\r\nframe_width_bus_value);\r\ntw_writel(TW5864_FRAME_HEIGHT_BUS_A(nr),\r\nframe_height_bus_value);\r\ntw_writel(TW5864_FRAME_HEIGHT_BUS_B(nr),\r\n(frame_height_bus_value + 1) / 2 - 1);\r\ntw5864_frame_interval_set(input);\r\nif (downscale_enabled)\r\ntw_setl(TW5864_H264EN_CH_DNS, 1 << nr);\r\ntw_mask_shift_writel(TW5864_H264EN_CH_FMT_REG1, 0x3, 2 * nr,\r\nfmt_reg_value);\r\ntw_mask_shift_writel((nr < 2\r\n? TW5864_H264EN_RATE_MAX_LINE_REG1\r\n: TW5864_H264EN_RATE_MAX_LINE_REG2),\r\n0x1f, 5 * (nr % 2),\r\ninput->std == STD_NTSC ? 29 : 24);\r\ntw_mask_shift_writel((nr < 2) ? TW5864_FRAME_BUS1 :\r\nTW5864_FRAME_BUS2, 0xff, (nr % 2) * 8,\r\nreg_frame_bus);\r\nspin_lock_irqsave(&dev->slock, flags);\r\ninput->enabled = 1;\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}\r\nvoid tw5864_request_encoded_frame(struct tw5864_input *input)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nu32 enc_buf_id_new;\r\ntw_setl(TW5864_DSP_CODEC, TW5864_CIF_MAP_MD | TW5864_HD1_MAP_MD);\r\ntw_writel(TW5864_EMU, input->reg_emu);\r\ntw_writel(TW5864_INTERLACING, input->reg_interlacing);\r\ntw_writel(TW5864_DSP, input->reg_dsp);\r\ntw_writel(TW5864_DSP_QP, input->reg_dsp_qp);\r\ntw_writel(TW5864_DSP_REF_MVP_LAMBDA, input->reg_dsp_ref_mvp_lambda);\r\ntw_writel(TW5864_DSP_I4x4_WEIGHT, input->reg_dsp_i4x4_weight);\r\ntw_mask_shift_writel(TW5864_DSP_INTRA_MODE, TW5864_DSP_INTRA_MODE_MASK,\r\nTW5864_DSP_INTRA_MODE_SHIFT,\r\nTW5864_DSP_INTRA_MODE_16x16);\r\nif (input->frame_gop_seqno == 0) {\r\ntw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN);\r\ninput->h264_idr_pic_id++;\r\ninput->h264_idr_pic_id &= TW5864_DSP_REF_FRM;\r\n} else {\r\ntw_writel(TW5864_MOTION_SEARCH_ETC, TW5864_INTRA_EN |\r\nTW5864_ME_EN | BIT(5) );\r\n}\r\ntw5864_prepare_frame_headers(input);\r\ntw_writel(TW5864_VLC,\r\nTW5864_VLC_PCI_SEL |\r\n((input->tail_nb_bits + 24) << TW5864_VLC_BIT_ALIGN_SHIFT) |\r\ninput->reg_dsp_qp);\r\nenc_buf_id_new = tw_mask_shift_readl(TW5864_ENC_BUF_PTR_REC1, 0x3,\r\n2 * input->nr);\r\ntw_writel(TW5864_DSP_ENC_ORG_PTR_REG,\r\nenc_buf_id_new << TW5864_DSP_ENC_ORG_PTR_SHIFT);\r\ntw_writel(TW5864_DSP_ENC_REC,\r\nenc_buf_id_new << 12 | ((enc_buf_id_new + 3) & 3));\r\ntw_writel(TW5864_SLICE, TW5864_START_NSLICE);\r\ntw_writel(TW5864_SLICE, 0);\r\n}\r\nstatic int tw5864_disable_input(struct tw5864_input *input)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nunsigned long flags;\r\ndev_dbg(&dev->pci->dev, "Disabling channel %d\n", input->nr);\r\nspin_lock_irqsave(&dev->slock, flags);\r\ninput->enabled = 0;\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int tw5864_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct tw5864_input *input = vb2_get_drv_priv(q);\r\nint ret;\r\nret = tw5864_enable_input(input);\r\nif (!ret)\r\nreturn 0;\r\nwhile (!list_empty(&input->active)) {\r\nstruct tw5864_buf *buf = list_entry(input->active.next,\r\nstruct tw5864_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void tw5864_stop_streaming(struct vb2_queue *q)\r\n{\r\nunsigned long flags;\r\nstruct tw5864_input *input = vb2_get_drv_priv(q);\r\ntw5864_disable_input(input);\r\nspin_lock_irqsave(&input->slock, flags);\r\nif (input->vb) {\r\nvb2_buffer_done(&input->vb->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\ninput->vb = NULL;\r\n}\r\nwhile (!list_empty(&input->active)) {\r\nstruct tw5864_buf *buf = list_entry(input->active.next,\r\nstruct tw5864_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&input->slock, flags);\r\n}\r\nstatic int tw5864_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw5864_input *input =\r\ncontainer_of(ctrl->handler, struct tw5864_input, hdl);\r\nstruct tw5864_dev *dev = input->root;\r\nunsigned long flags;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ntw_indir_writeb(TW5864_INDIR_VIN_A_BRIGHT(input->nr),\r\n(u8)ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ntw_indir_writeb(TW5864_INDIR_VIN_7_HUE(input->nr),\r\n(u8)ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ntw_indir_writeb(TW5864_INDIR_VIN_9_CNTRST(input->nr),\r\n(u8)ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ntw_indir_writeb(TW5864_INDIR_VIN_B_SAT_U(input->nr),\r\n(u8)ctrl->val);\r\ntw_indir_writeb(TW5864_INDIR_VIN_C_SAT_V(input->nr),\r\n(u8)ctrl->val);\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\ninput->gop = ctrl->val;\r\nreturn 0;\r\ncase V4L2_CID_MPEG_VIDEO_H264_MIN_QP:\r\nspin_lock_irqsave(&input->slock, flags);\r\ninput->qp = ctrl->val;\r\ninput->reg_dsp_qp = input->qp;\r\ninput->reg_dsp_ref_mvp_lambda = lambda_lookup_table[input->qp];\r\ninput->reg_dsp_i4x4_weight = intra4x4_lambda3[input->qp];\r\nspin_unlock_irqrestore(&input->slock, flags);\r\nreturn 0;\r\ncase V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD:\r\nmemset(input->md_threshold_grid_values, ctrl->val,\r\nsizeof(input->md_threshold_grid_values));\r\nreturn 0;\r\ncase V4L2_CID_DETECT_MD_MODE:\r\nreturn 0;\r\ncase V4L2_CID_DETECT_MD_THRESHOLD_GRID:\r\nmemcpy(input->md_threshold_grid_values,\r\ninput->md_threshold_grid_ctrl->p_new.p_u16,\r\nsizeof(input->md_threshold_grid_values));\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw5864_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nf->fmt.pix.width = 704;\r\nswitch (input->std) {\r\ndefault:\r\nWARN_ON_ONCE(1);\r\ncase STD_NTSC:\r\nf->fmt.pix.height = 480;\r\nbreak;\r\ncase STD_PAL:\r\ncase STD_SECAM:\r\nf->fmt.pix.height = 576;\r\nbreak;\r\n}\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_H264;\r\nf->fmt.pix.sizeimage = H264_VLC_BUF_SIZE;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int tw5864_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct tw5864_dev *dev = input->root;\r\nu8 indir_0x000 = tw_indir_readb(TW5864_INDIR_VIN_0(input->nr));\r\nu8 indir_0x00d = tw_indir_readb(TW5864_INDIR_VIN_D(input->nr));\r\nu8 v1 = indir_0x000;\r\nu8 v2 = indir_0x00d;\r\nif (i->index)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nsnprintf(i->name, sizeof(i->name), "Encoder %d", input->nr);\r\ni->std = TW5864_NORMS;\r\nif (v1 & (1 << 7))\r\ni->status |= V4L2_IN_ST_NO_SYNC;\r\nif (!(v1 & (1 << 6)))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\nif (v1 & (1 << 2))\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (v1 & (1 << 1))\r\ni->status |= V4L2_IN_ST_NO_COLOR;\r\nif (v2 & (1 << 2))\r\ni->status |= V4L2_IN_ST_MACROVISION;\r\nreturn 0;\r\n}\r\nstatic int tw5864_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int tw5864_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int tw5864_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstrcpy(cap->driver, "tw5864");\r\nsnprintf(cap->card, sizeof(cap->card), "TW5864 Encoder %d",\r\ninput->nr);\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(input->root->pci));\r\nreturn 0;\r\n}\r\nstatic int tw5864_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nenum tw5864_vid_std tw_std;\r\nint ret;\r\nret = tw5864_input_std_get(input, &tw_std);\r\nif (ret)\r\nreturn ret;\r\n*std = tw5864_get_v4l2_std(tw_std);\r\nreturn 0;\r\n}\r\nstatic int tw5864_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\n*std = input->v4l2_std;\r\nreturn 0;\r\n}\r\nstatic int tw5864_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct tw5864_dev *dev = input->root;\r\ninput->v4l2_std = std;\r\ninput->std = tw5864_from_v4l2_std(std);\r\ntw_indir_writeb(TW5864_INDIR_VIN_E(input->nr), input->std);\r\nreturn 0;\r\n}\r\nstatic int tw5864_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\nf->pixelformat = V4L2_PIX_FMT_H264;\r\nreturn 0;\r\n}\r\nstatic int tw5864_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_ctrl_subscribe_event(fh, sub);\r\ncase V4L2_EVENT_MOTION_DET:\r\nreturn v4l2_event_subscribe(fh, sub, 30, NULL);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void tw5864_frame_interval_set(struct tw5864_input *input)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nu32 unary_framerate = 0;\r\nint shift = 0;\r\nint std_max_fps = input->std == STD_NTSC ? 30 : 25;\r\nfor (shift = 0; shift < std_max_fps; shift += input->frame_interval)\r\nunary_framerate |= 0x00000001 << shift;\r\ntw_writel(TW5864_H264EN_RATE_CNTL_LO_WORD(input->nr, 0),\r\nunary_framerate >> 16);\r\ntw_writel(TW5864_H264EN_RATE_CNTL_HI_WORD(input->nr, 0),\r\nunary_framerate & 0xffff);\r\n}\r\nstatic int tw5864_frameinterval_get(struct tw5864_input *input,\r\nstruct v4l2_fract *frameinterval)\r\n{\r\nswitch (input->std) {\r\ncase STD_NTSC:\r\nframeinterval->numerator = 1001;\r\nframeinterval->denominator = 30000;\r\nbreak;\r\ncase STD_PAL:\r\ncase STD_SECAM:\r\nframeinterval->numerator = 1;\r\nframeinterval->denominator = 25;\r\nbreak;\r\ndefault:\r\nWARN(1, "tw5864_frameinterval_get requested for unknown std %d\n",\r\ninput->std);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw5864_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nif (fsize->index > 0)\r\nreturn -EINVAL;\r\nif (fsize->pixel_format != V4L2_PIX_FMT_H264)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = 704;\r\nfsize->discrete.height = input->std == STD_NTSC ? 480 : 576;\r\nreturn 0;\r\n}\r\nstatic int tw5864_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fintv)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct v4l2_fract frameinterval;\r\nint std_max_fps = input->std == STD_NTSC ? 30 : 25;\r\nstruct v4l2_frmsizeenum fsize = { .index = fintv->index,\r\n.pixel_format = fintv->pixel_format };\r\nint ret;\r\nret = tw5864_enum_framesizes(file, priv, &fsize);\r\nif (ret)\r\nreturn ret;\r\nif (fintv->width != fsize.discrete.width ||\r\nfintv->height != fsize.discrete.height)\r\nreturn -EINVAL;\r\nfintv->type = V4L2_FRMIVAL_TYPE_STEPWISE;\r\nret = tw5864_frameinterval_get(input, &frameinterval);\r\nfintv->stepwise.step = frameinterval;\r\nfintv->stepwise.min = frameinterval;\r\nfintv->stepwise.max = frameinterval;\r\nfintv->stepwise.max.numerator *= std_max_fps;\r\nreturn ret;\r\n}\r\nstatic int tw5864_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\nint ret;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\nret = tw5864_frameinterval_get(input, &cp->timeperframe);\r\ncp->timeperframe.numerator *= input->frame_interval;\r\ncp->capturemode = 0;\r\ncp->readbuffers = 2;\r\nreturn ret;\r\n}\r\nstatic int tw5864_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct v4l2_fract *t = &sp->parm.capture.timeperframe;\r\nstruct v4l2_fract time_base;\r\nint ret;\r\nret = tw5864_frameinterval_get(input, &time_base);\r\nif (ret)\r\nreturn ret;\r\nif (!t->numerator || !t->denominator) {\r\nt->numerator = time_base.numerator * input->frame_interval;\r\nt->denominator = time_base.denominator;\r\n} else if (t->denominator != time_base.denominator) {\r\nt->numerator = t->numerator * time_base.denominator /\r\nt->denominator;\r\nt->denominator = time_base.denominator;\r\n}\r\ninput->frame_interval = t->numerator / time_base.numerator;\r\nif (input->frame_interval < 1)\r\ninput->frame_interval = 1;\r\ntw5864_frame_interval_set(input);\r\nreturn tw5864_g_parm(file, priv, sp);\r\n}\r\nstatic int tw5864_g_reg(struct file *file, void *fh,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct tw5864_dev *dev = input->root;\r\nif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\r\nif (reg->reg > 0x87fff)\r\nreturn -EINVAL;\r\nreg->size = 4;\r\nreg->val = tw_readl(reg->reg);\r\n} else {\r\n__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\r\nif (indir_addr > 0xefe)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nreg->val = tw_indir_readb(reg->reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw5864_s_reg(struct file *file, void *fh,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct tw5864_input *input = video_drvdata(file);\r\nstruct tw5864_dev *dev = input->root;\r\nif (reg->reg < INDIR_SPACE_MAP_SHIFT) {\r\nif (reg->reg > 0x87fff)\r\nreturn -EINVAL;\r\ntw_writel(reg->reg, reg->val);\r\n} else {\r\n__u64 indir_addr = reg->reg - INDIR_SPACE_MAP_SHIFT;\r\nif (indir_addr > 0xefe)\r\nreturn -EINVAL;\r\ntw_indir_writeb(reg->reg, reg->val);\r\n}\r\nreturn 0;\r\n}\r\nint tw5864_video_init(struct tw5864_dev *dev, int *video_nr)\r\n{\r\nint i;\r\nint ret;\r\nunsigned long flags;\r\nint last_dma_allocated = -1;\r\nint last_input_nr_registered = -1;\r\nfor (i = 0; i < H264_BUF_CNT; i++) {\r\nstruct tw5864_h264_frame *frame = &dev->h264_buf[i];\r\nframe->vlc.addr = dma_alloc_coherent(&dev->pci->dev,\r\nH264_VLC_BUF_SIZE,\r\n&frame->vlc.dma_addr,\r\nGFP_KERNEL | GFP_DMA32);\r\nif (!frame->vlc.addr) {\r\ndev_err(&dev->pci->dev, "dma alloc fail\n");\r\nret = -ENOMEM;\r\ngoto free_dma;\r\n}\r\nframe->mv.addr = dma_alloc_coherent(&dev->pci->dev,\r\nH264_MV_BUF_SIZE,\r\n&frame->mv.dma_addr,\r\nGFP_KERNEL | GFP_DMA32);\r\nif (!frame->mv.addr) {\r\ndev_err(&dev->pci->dev, "dma alloc fail\n");\r\nret = -ENOMEM;\r\ndma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\r\nframe->vlc.addr, frame->vlc.dma_addr);\r\ngoto free_dma;\r\n}\r\nlast_dma_allocated = i;\r\n}\r\ntw5864_encoder_tables_upload(dev);\r\ntw_indir_writeb(TW5864_INDIR_VD_108_POL, TW5864_INDIR_VD_108_POL_BOTH);\r\ntw_indir_writeb(TW5864_INDIR_CLK0_SEL, 0x00);\r\ntw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL0, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_DDRA_DLL_DQS_SEL1, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_DDRA_DLL_CLK90_SEL, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL0, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_DDRB_DLL_DQS_SEL1, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_DDRB_DLL_CLK90_SEL, 0x02);\r\ntw_indir_writeb(TW5864_INDIR_RESET, 0);\r\ntw_indir_writeb(TW5864_INDIR_RESET, TW5864_INDIR_RESET_VD |\r\nTW5864_INDIR_RESET_DLL | TW5864_INDIR_RESET_MUX_CORE);\r\nmsleep(20);\r\ntw_writel(TW5864_FULL_HALF_MODE_SEL, 0);\r\ntw_indir_writeb(TW5864_INDIR_PV_VD_CK_POL,\r\nTW5864_INDIR_PV_VD_CK_POL_VD(0) |\r\nTW5864_INDIR_PV_VD_CK_POL_VD(1) |\r\nTW5864_INDIR_PV_VD_CK_POL_VD(2) |\r\nTW5864_INDIR_PV_VD_CK_POL_VD(3));\r\nspin_lock_irqsave(&dev->slock, flags);\r\ndev->encoder_busy = 0;\r\ndev->h264_buf_r_index = 0;\r\ndev->h264_buf_w_index = 0;\r\ntw_writel(TW5864_VLC_STREAM_BASE_ADDR,\r\ndev->h264_buf[dev->h264_buf_w_index].vlc.dma_addr);\r\ntw_writel(TW5864_MV_STREAM_BASE_ADDR,\r\ndev->h264_buf[dev->h264_buf_w_index].mv.dma_addr);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ntw_writel(TW5864_SEN_EN_CH, 0x000f);\r\ntw_writel(TW5864_H264EN_CH_EN, 0x000f);\r\ntw_writel(TW5864_H264EN_BUS0_MAP, 0x00000000);\r\ntw_writel(TW5864_H264EN_BUS1_MAP, 0x00001111);\r\ntw_writel(TW5864_H264EN_BUS2_MAP, 0x00002222);\r\ntw_writel(TW5864_H264EN_BUS3_MAP, 0x00003333);\r\ntw_writel(TW5864_ENC_BUF_PTR_REC1, 0x00ff);\r\ntw_writel(TW5864_PCI_INTTM_SCALE, 0);\r\ntw_writel(TW5864_INTERLACING, TW5864_DI_EN);\r\ntw_writel(TW5864_MASTER_ENB_REG, TW5864_PCI_VLC_INTR_ENB);\r\ntw_writel(TW5864_PCI_INTR_CTL,\r\nTW5864_TIMER_INTR_ENB | TW5864_PCI_MAST_ENB |\r\nTW5864_MVD_VLC_MAST_ENB);\r\ndev->irqmask |= TW5864_INTR_VLC_DONE | TW5864_INTR_TIMER;\r\ntw5864_irqmask_apply(dev);\r\ntasklet_init(&dev->tasklet, tw5864_handle_frame_task,\r\n(unsigned long)dev);\r\nfor (i = 0; i < TW5864_INPUTS; i++) {\r\ndev->inputs[i].root = dev;\r\ndev->inputs[i].nr = i;\r\nret = tw5864_video_input_init(&dev->inputs[i], video_nr[i]);\r\nif (ret)\r\ngoto fini_video_inputs;\r\nlast_input_nr_registered = i;\r\n}\r\nreturn 0;\r\nfini_video_inputs:\r\nfor (i = last_input_nr_registered; i >= 0; i--)\r\ntw5864_video_input_fini(&dev->inputs[i]);\r\ntasklet_kill(&dev->tasklet);\r\nfree_dma:\r\nfor (i = last_dma_allocated; i >= 0; i--) {\r\ndma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\r\ndev->h264_buf[i].vlc.addr,\r\ndev->h264_buf[i].vlc.dma_addr);\r\ndma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\r\ndev->h264_buf[i].mv.addr,\r\ndev->h264_buf[i].mv.dma_addr);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tw5864_video_input_init(struct tw5864_input *input, int video_nr)\r\n{\r\nstruct tw5864_dev *dev = input->root;\r\nint ret;\r\nstruct v4l2_ctrl_handler *hdl = &input->hdl;\r\nmutex_init(&input->lock);\r\nspin_lock_init(&input->slock);\r\nINIT_LIST_HEAD(&input->active);\r\ninput->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ninput->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\ninput->vidq.io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\r\ninput->vidq.ops = &tw5864_video_qops;\r\ninput->vidq.mem_ops = &vb2_dma_contig_memops;\r\ninput->vidq.drv_priv = input;\r\ninput->vidq.gfp_flags = 0;\r\ninput->vidq.buf_struct_size = sizeof(struct tw5864_buf);\r\ninput->vidq.lock = &input->lock;\r\ninput->vidq.min_buffers_needed = 2;\r\ninput->vidq.dev = &input->root->pci->dev;\r\nret = vb2_queue_init(&input->vidq);\r\nif (ret)\r\ngoto free_mutex;\r\ninput->vdev = tw5864_video_template;\r\ninput->vdev.v4l2_dev = &input->root->v4l2_dev;\r\ninput->vdev.lock = &input->lock;\r\ninput->vdev.queue = &input->vidq;\r\nvideo_set_drvdata(&input->vdev, input);\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 100);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_HUE, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops, V4L2_CID_MPEG_VIDEO_GOP_SIZE,\r\n1, MAX_GOP_SIZE, 1, GOP_SIZE);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_MPEG_VIDEO_H264_MIN_QP, 28, 51, 1, QP_VALUE);\r\nv4l2_ctrl_new_std_menu(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_DETECT_MD_MODE,\r\nV4L2_DETECT_MD_MODE_THRESHOLD_GRID, 0,\r\nV4L2_DETECT_MD_MODE_DISABLED);\r\nv4l2_ctrl_new_std(hdl, &tw5864_ctrl_ops,\r\nV4L2_CID_DETECT_MD_GLOBAL_THRESHOLD,\r\ntw5864_md_thresholds.min, tw5864_md_thresholds.max,\r\ntw5864_md_thresholds.step, tw5864_md_thresholds.def);\r\ninput->md_threshold_grid_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &tw5864_md_thresholds, NULL);\r\nif (hdl->error) {\r\nret = hdl->error;\r\ngoto free_v4l2_hdl;\r\n}\r\ninput->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_setup(hdl);\r\ninput->qp = QP_VALUE;\r\ninput->gop = GOP_SIZE;\r\ninput->frame_interval = 1;\r\nret = video_register_device(&input->vdev, VFL_TYPE_GRABBER, video_nr);\r\nif (ret)\r\ngoto free_v4l2_hdl;\r\ndev_info(&input->root->pci->dev, "Registered video device %s\n",\r\nvideo_device_node_name(&input->vdev));\r\ninput->v4l2_std = V4L2_STD_NTSC_M;\r\ninput->std = STD_NTSC;\r\ntw_indir_writeb(TW5864_INDIR_VIN_E(video_nr), 0x07);\r\ntw_indir_writeb(TW5864_INDIR_VIN_F(video_nr), 0xff);\r\nreturn 0;\r\nfree_v4l2_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nvb2_queue_release(&input->vidq);\r\nfree_mutex:\r\nmutex_destroy(&input->lock);\r\nreturn ret;\r\n}\r\nstatic void tw5864_video_input_fini(struct tw5864_input *dev)\r\n{\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nvb2_queue_release(&dev->vidq);\r\n}\r\nvoid tw5864_video_fini(struct tw5864_dev *dev)\r\n{\r\nint i;\r\ntasklet_kill(&dev->tasklet);\r\nfor (i = 0; i < TW5864_INPUTS; i++)\r\ntw5864_video_input_fini(&dev->inputs[i]);\r\nfor (i = 0; i < H264_BUF_CNT; i++) {\r\ndma_free_coherent(&dev->pci->dev, H264_VLC_BUF_SIZE,\r\ndev->h264_buf[i].vlc.addr,\r\ndev->h264_buf[i].vlc.dma_addr);\r\ndma_free_coherent(&dev->pci->dev, H264_MV_BUF_SIZE,\r\ndev->h264_buf[i].mv.addr,\r\ndev->h264_buf[i].mv.dma_addr);\r\n}\r\n}\r\nvoid tw5864_prepare_frame_headers(struct tw5864_input *input)\r\n{\r\nstruct tw5864_buf *vb = input->vb;\r\nu8 *dst;\r\nsize_t dst_space;\r\nunsigned long flags;\r\nif (!vb) {\r\nspin_lock_irqsave(&input->slock, flags);\r\nif (list_empty(&input->active)) {\r\nspin_unlock_irqrestore(&input->slock, flags);\r\ninput->vb = NULL;\r\nreturn;\r\n}\r\nvb = list_first_entry(&input->active, struct tw5864_buf, list);\r\nlist_del(&vb->list);\r\nspin_unlock_irqrestore(&input->slock, flags);\r\n}\r\ndst = vb2_plane_vaddr(&vb->vb.vb2_buf, 0);\r\ndst_space = vb2_plane_size(&vb->vb.vb2_buf, 0);\r\nif (WARN_ON_ONCE(dst_space < 128))\r\nreturn;\r\nif (input->frame_gop_seqno == 0)\r\ntw5864_h264_put_stream_header(&dst, &dst_space, input->qp,\r\ninput->width, input->height);\r\ntw5864_h264_put_slice_header(&dst, &dst_space, input->h264_idr_pic_id,\r\ninput->frame_gop_seqno,\r\n&input->tail_nb_bits, &input->tail);\r\ninput->vb = vb;\r\ninput->buf_cur_ptr = dst;\r\ninput->buf_cur_space_left = dst_space;\r\n}\r\nstatic unsigned int tw5864_md_metric_from_mvd(u32 mvd)\r\n{\r\nunsigned int mv_y = (mvd >> 10) & 0x3ff;\r\nunsigned int mv_x = mvd & 0x3ff;\r\nmv_x &= 0x0f;\r\nmv_y &= 0x0f;\r\nreturn mv_y + mv_x;\r\n}\r\nstatic int tw5864_is_motion_triggered(struct tw5864_h264_frame *frame)\r\n{\r\nstruct tw5864_input *input = frame->input;\r\nu32 *mv = (u32 *)frame->mv.addr;\r\nint i;\r\nint detected = 0;\r\nfor (i = 0; i < MD_CELLS; i++) {\r\nconst u16 thresh = input->md_threshold_grid_values[i];\r\nconst unsigned int metric = tw5864_md_metric_from_mvd(mv[i]);\r\nif (metric > thresh)\r\ndetected = 1;\r\nif (detected)\r\nbreak;\r\n}\r\nreturn detected;\r\n}\r\nstatic void tw5864_handle_frame_task(unsigned long data)\r\n{\r\nstruct tw5864_dev *dev = (struct tw5864_dev *)data;\r\nunsigned long flags;\r\nint batch_size = H264_BUF_CNT;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (dev->h264_buf_r_index != dev->h264_buf_w_index && batch_size--) {\r\nstruct tw5864_h264_frame *frame =\r\n&dev->h264_buf[dev->h264_buf_r_index];\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\ndma_sync_single_for_cpu(&dev->pci->dev, frame->vlc.dma_addr,\r\nH264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\r\ndma_sync_single_for_cpu(&dev->pci->dev, frame->mv.dma_addr,\r\nH264_MV_BUF_SIZE, DMA_FROM_DEVICE);\r\ntw5864_handle_frame(frame);\r\ndma_sync_single_for_device(&dev->pci->dev, frame->vlc.dma_addr,\r\nH264_VLC_BUF_SIZE, DMA_FROM_DEVICE);\r\ndma_sync_single_for_device(&dev->pci->dev, frame->mv.dma_addr,\r\nH264_MV_BUF_SIZE, DMA_FROM_DEVICE);\r\nspin_lock_irqsave(&dev->slock, flags);\r\ndev->h264_buf_r_index++;\r\ndev->h264_buf_r_index %= H264_BUF_CNT;\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic u32 tw5864_vlc_checksum(u32 *data, int len)\r\n{\r\nu32 val, count_len = len;\r\nval = *data++;\r\nwhile (((count_len >> 2) - 1) > 0) {\r\nval ^= *data++;\r\ncount_len -= 4;\r\n}\r\nval ^= htonl((len >> 2));\r\nreturn val;\r\n}\r\nstatic void tw5864_handle_frame(struct tw5864_h264_frame *frame)\r\n{\r\n#define SKIP_VLCBUF_BYTES 3\r\nstruct tw5864_input *input = frame->input;\r\nstruct tw5864_dev *dev = input->root;\r\nstruct tw5864_buf *vb;\r\nstruct vb2_v4l2_buffer *v4l2_buf;\r\nint frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;\r\nu8 *dst = input->buf_cur_ptr;\r\nu8 tail_mask, vlc_mask = 0;\r\nint i;\r\nu8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];\r\nunsigned long flags;\r\nint zero_run;\r\nu8 *src;\r\nu8 *src_end;\r\n#ifdef DEBUG\r\nif (frame->checksum !=\r\ntw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))\r\ndev_err(&dev->pci->dev,\r\n"Checksum of encoded frame doesn't match!\n");\r\n#endif\r\nspin_lock_irqsave(&input->slock, flags);\r\nvb = input->vb;\r\ninput->vb = NULL;\r\nspin_unlock_irqrestore(&input->slock, flags);\r\nv4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);\r\nif (!vb) {\r\ndev_dbg(&dev->pci->dev, "vb is empty, dropping frame\n");\r\nreturn;\r\n}\r\nif (input->buf_cur_space_left < frame_len * 5 / 4) {\r\ndev_err_once(&dev->pci->dev,\r\n"Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\n",\r\ninput->buf_cur_space_left, frame_len);\r\nreturn;\r\n}\r\nfor (i = 0; i < 8 - input->tail_nb_bits; i++)\r\nvlc_mask |= 1 << i;\r\ntail_mask = (~vlc_mask) & 0xff;\r\ndst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);\r\nframe_len--;\r\ndst++;\r\nsrc = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;\r\nsrc_end = src + frame_len;\r\nzero_run = 0;\r\nfor (; src < src_end; src++) {\r\nif (zero_run < 2) {\r\nif (*src == 0)\r\n++zero_run;\r\nelse\r\nzero_run = 0;\r\n} else {\r\nif ((*src & ~0x03) == 0)\r\n*dst++ = 0x03;\r\nzero_run = *src == 0;\r\n}\r\n*dst++ = *src;\r\n}\r\nvb2_set_plane_payload(&vb->vb.vb2_buf, 0,\r\ndst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));\r\nvb->vb.vb2_buf.timestamp = frame->timestamp;\r\nv4l2_buf->field = V4L2_FIELD_INTERLACED;\r\nv4l2_buf->sequence = frame->seqno;\r\nif (frame->gop_seqno &&\r\ntw5864_is_motion_triggered(frame)) {\r\nstruct v4l2_event ev = {\r\n.type = V4L2_EVENT_MOTION_DET,\r\n.u.motion_det = {\r\n.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,\r\n.frame_sequence = v4l2_buf->sequence,\r\n},\r\n};\r\nv4l2_event_queue(&input->vdev, &ev);\r\n}\r\nvb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nstatic v4l2_std_id tw5864_get_v4l2_std(enum tw5864_vid_std std)\r\n{\r\nswitch (std) {\r\ncase STD_NTSC: return V4L2_STD_NTSC_M;\r\ncase STD_PAL: return V4L2_STD_PAL_B;\r\ncase STD_SECAM: return V4L2_STD_SECAM_B;\r\ncase STD_NTSC443: return V4L2_STD_NTSC_443;\r\ncase STD_PAL_M: return V4L2_STD_PAL_M;\r\ncase STD_PAL_CN: return V4L2_STD_PAL_Nc;\r\ncase STD_PAL_60: return V4L2_STD_PAL_60;\r\ncase STD_INVALID: return V4L2_STD_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum tw5864_vid_std tw5864_from_v4l2_std(v4l2_std_id v4l2_std)\r\n{\r\nif (v4l2_std & V4L2_STD_NTSC_M)\r\nreturn STD_NTSC;\r\nif (v4l2_std & V4L2_STD_PAL_B)\r\nreturn STD_PAL;\r\nif (v4l2_std & V4L2_STD_SECAM_B)\r\nreturn STD_SECAM;\r\nif (v4l2_std & V4L2_STD_NTSC_443)\r\nreturn STD_NTSC443;\r\nif (v4l2_std & V4L2_STD_PAL_M)\r\nreturn STD_PAL_M;\r\nif (v4l2_std & V4L2_STD_PAL_Nc)\r\nreturn STD_PAL_CN;\r\nif (v4l2_std & V4L2_STD_PAL_60)\r\nreturn STD_PAL_60;\r\nreturn STD_INVALID;\r\n}\r\nstatic void tw5864_encoder_tables_upload(struct tw5864_dev *dev)\r\n{\r\nint i;\r\ntw_writel(TW5864_VLC_RD, 0x1);\r\nfor (i = 0; i < VLC_LOOKUP_TABLE_LEN; i++) {\r\ntw_writel((TW5864_VLC_STREAM_MEM_START + i * 4),\r\nencoder_vlc_lookup_table[i]);\r\n}\r\ntw_writel(TW5864_VLC_RD, 0x0);\r\nfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\r\ntw_writel((TW5864_QUAN_TAB + i * 4),\r\nforward_quantization_table[i]);\r\n}\r\nfor (i = 0; i < QUANTIZATION_TABLE_LEN; i++) {\r\ntw_writel((TW5864_QUAN_TAB + i * 4),\r\ninverse_quantization_table[i]);\r\n}\r\n}
