static void event_dump(void)\r\n{\r\n}\r\nstatic void EVENT(const char *s,unsigned long a,unsigned long b)\r\n{\r\nev[ec] = s;\r\nev_a[ec] = a;\r\nev_b[ec] = b;\r\nec = (ec+1) % EV;\r\n}\r\nstatic void event_dump(void)\r\n{\r\nint n,i;\r\nprintk(KERN_NOTICE "----- event dump follows -----\n");\r\nfor (n = 0; n < EV; n++) {\r\ni = (ec+n) % EV;\r\nprintk(KERN_NOTICE);\r\nprintk(ev[i] ? ev[i] : "(null)",ev_a[i],ev_b[i]);\r\n}\r\nprintk(KERN_NOTICE "----- event dump ends here -----\n");\r\n}\r\nstatic void zpokel(struct zatm_dev *zatm_dev,u32 value,u32 addr)\r\n{\r\nzwait;\r\nzout(value,CER);\r\nzout(uPD98401_IND_ACC | uPD98401_IA_BALL |\r\n(uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);\r\n}\r\nstatic u32 zpeekl(struct zatm_dev *zatm_dev,u32 addr)\r\n{\r\nzwait;\r\nzout(uPD98401_IND_ACC | uPD98401_IA_BALL | uPD98401_IA_RW |\r\n(uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);\r\nzwait;\r\nreturn zin(CER);\r\n}\r\nstatic void refill_pool(struct atm_dev *dev,int pool)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct sk_buff *skb;\r\nstruct rx_buffer_head *first;\r\nunsigned long flags;\r\nint align,offset,free,count,size;\r\nEVENT("refill_pool\n",0,0);\r\nzatm_dev = ZATM_DEV(dev);\r\nsize = (64 << (pool <= ZATM_AAL5_POOL_BASE ? 0 :\r\npool-ZATM_AAL5_POOL_BASE))+sizeof(struct rx_buffer_head);\r\nif (size < PAGE_SIZE) {\r\nalign = 32;\r\noffset = sizeof(struct rx_buffer_head);\r\n}\r\nelse {\r\nalign = 4096;\r\noffset = zatm_dev->pool_info[pool].offset+\r\nsizeof(struct rx_buffer_head);\r\n}\r\nsize += align;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nfree = zpeekl(zatm_dev,zatm_dev->pool_base+2*pool) &\r\nuPD98401_RXFP_REMAIN;\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nif (free >= zatm_dev->pool_info[pool].low_water) return;\r\nEVENT("starting ... POOL: 0x%x, 0x%x\n",\r\nzpeekl(zatm_dev,zatm_dev->pool_base+2*pool),\r\nzpeekl(zatm_dev,zatm_dev->pool_base+2*pool+1));\r\nEVENT("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);\r\ncount = 0;\r\nfirst = NULL;\r\nwhile (free < zatm_dev->pool_info[pool].high_water) {\r\nstruct rx_buffer_head *head;\r\nskb = alloc_skb(size,GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_WARNING DEV_LABEL "(Itf %d): got no new "\r\n"skb (%d) with %d free\n",dev->number,size,free);\r\nbreak;\r\n}\r\nskb_reserve(skb,(unsigned char *) ((((unsigned long) skb->data+\r\nalign+offset-1) & ~(unsigned long) (align-1))-offset)-\r\nskb->data);\r\nhead = (struct rx_buffer_head *) skb->data;\r\nskb_reserve(skb,sizeof(struct rx_buffer_head));\r\nif (!first) first = head;\r\ncount++;\r\nhead->buffer = virt_to_bus(skb->data);\r\nhead->link = 0;\r\nhead->skb = skb;\r\nEVENT("enq skb 0x%08lx/0x%08lx\n",(unsigned long) skb,\r\n(unsigned long) head);\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nif (zatm_dev->last_free[pool])\r\n((struct rx_buffer_head *) (zatm_dev->last_free[pool]->\r\ndata))[-1].link = virt_to_bus(head);\r\nzatm_dev->last_free[pool] = skb;\r\nskb_queue_tail(&zatm_dev->pool[pool],skb);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nfree++;\r\n}\r\nif (first) {\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzwait;\r\nzout(virt_to_bus(first),CER);\r\nzout(uPD98401_ADD_BAT | (pool << uPD98401_POOL_SHIFT) | count,\r\nCMR);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nEVENT ("POOL: 0x%x, 0x%x\n",\r\nzpeekl(zatm_dev,zatm_dev->pool_base+2*pool),\r\nzpeekl(zatm_dev,zatm_dev->pool_base+2*pool+1));\r\nEVENT("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);\r\n}\r\n}\r\nstatic void drain_free(struct atm_dev *dev,int pool)\r\n{\r\nskb_queue_purge(&ZATM_DEV(dev)->pool[pool]);\r\n}\r\nstatic int pool_index(int max_pdu)\r\n{\r\nint i;\r\nif (max_pdu % ATM_CELL_PAYLOAD)\r\nprintk(KERN_ERR DEV_LABEL ": driver error in pool_index: "\r\n"max_pdu is %d\n",max_pdu);\r\nif (max_pdu > 65536) return -1;\r\nfor (i = 0; (64 << i) < max_pdu; i++);\r\nreturn i+ZATM_AAL5_POOL_BASE;\r\n}\r\nstatic void use_pool(struct atm_dev *dev,int pool)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long flags;\r\nint size;\r\nzatm_dev = ZATM_DEV(dev);\r\nif (!(zatm_dev->pool_info[pool].ref_count++)) {\r\nskb_queue_head_init(&zatm_dev->pool[pool]);\r\nsize = pool-ZATM_AAL5_POOL_BASE;\r\nif (size < 0) size = 0;\r\nelse if (size > 10) size = 10;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzpokel(zatm_dev,((zatm_dev->pool_info[pool].low_water/4) <<\r\nuPD98401_RXFP_ALERT_SHIFT) |\r\n(1 << uPD98401_RXFP_BTSZ_SHIFT) |\r\n(size << uPD98401_RXFP_BFSZ_SHIFT),\r\nzatm_dev->pool_base+pool*2);\r\nzpokel(zatm_dev,(unsigned long) dummy,zatm_dev->pool_base+\r\npool*2+1);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nzatm_dev->last_free[pool] = NULL;\r\nrefill_pool(dev,pool);\r\n}\r\nDPRINTK("pool %d: %d\n",pool,zatm_dev->pool_info[pool].ref_count);\r\n}\r\nstatic void unuse_pool(struct atm_dev *dev,int pool)\r\n{\r\nif (!(--ZATM_DEV(dev)->pool_info[pool].ref_count))\r\ndrain_free(dev,pool);\r\n}\r\nstatic void poll_rx(struct atm_dev *dev,int mbx)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long pos;\r\nu32 x;\r\nint error;\r\nEVENT("poll_rx\n",0,0);\r\nzatm_dev = ZATM_DEV(dev);\r\npos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));\r\nwhile (x = zin(MWA(mbx)), (pos & 0xffff) != x) {\r\nu32 *here;\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\nint cells,size,chan;\r\nEVENT("MBX: host 0x%lx, nic 0x%x\n",pos,x);\r\nhere = (u32 *) pos;\r\nif (((pos += 16) & 0xffff) == zatm_dev->mbx_end[mbx])\r\npos = zatm_dev->mbx_start[mbx];\r\ncells = here[0] & uPD98401_AAL5_SIZE;\r\n#if 0\r\nprintk("RX IND: 0x%x, 0x%x, 0x%x, 0x%x\n",here[0],here[1],here[2],here[3]);\r\n{\r\nunsigned long *x;\r\nprintk("POOL: 0x%08x, 0x%08x\n",zpeekl(zatm_dev,\r\nzatm_dev->pool_base),\r\nzpeekl(zatm_dev,zatm_dev->pool_base+1));\r\nx = (unsigned long *) here[2];\r\nprintk("[0..3] = 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",\r\nx[0],x[1],x[2],x[3]);\r\n}\r\n#endif\r\nerror = 0;\r\nif (here[3] & uPD98401_AAL5_ERR) {\r\nerror = (here[3] & uPD98401_AAL5_ES) >>\r\nuPD98401_AAL5_ES_SHIFT;\r\nif (error == uPD98401_AAL5_ES_DEACT ||\r\nerror == uPD98401_AAL5_ES_FREE) continue;\r\n}\r\nEVENT("error code 0x%x/0x%x\n",(here[3] & uPD98401_AAL5_ES) >>\r\nuPD98401_AAL5_ES_SHIFT,error);\r\nskb = ((struct rx_buffer_head *) bus_to_virt(here[2]))->skb;\r\n__net_timestamp(skb);\r\n#if 0\r\nprintk("[-3..0] 0x%08lx 0x%08lx 0x%08lx 0x%08lx\n",((unsigned *) skb->data)[-3],\r\n((unsigned *) skb->data)[-2],((unsigned *) skb->data)[-1],\r\n((unsigned *) skb->data)[0]);\r\n#endif\r\nEVENT("skb 0x%lx, here 0x%lx\n",(unsigned long) skb,\r\n(unsigned long) here);\r\n#if 0\r\nprintk("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);\r\n#endif\r\nsize = error ? 0 : ntohs(((__be16 *) skb->data)[cells*\r\nATM_CELL_PAYLOAD/sizeof(u16)-3]);\r\nEVENT("got skb 0x%lx, size %d\n",(unsigned long) skb,size);\r\nchan = (here[3] & uPD98401_AAL5_CHAN) >>\r\nuPD98401_AAL5_CHAN_SHIFT;\r\nif (chan < zatm_dev->chans && zatm_dev->rx_map[chan]) {\r\nint pos;\r\nvcc = zatm_dev->rx_map[chan];\r\npos = ZATM_VCC(vcc)->pool;\r\nif (skb == zatm_dev->last_free[pos])\r\nzatm_dev->last_free[pos] = NULL;\r\nskb_unlink(skb, zatm_dev->pool + pos);\r\n}\r\nelse {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): RX indication "\r\n"for non-existing channel\n",dev->number);\r\nsize = 0;\r\nvcc = NULL;\r\nevent_dump();\r\n}\r\nif (error) {\r\nstatic unsigned long silence = 0;\r\nstatic int last_error = 0;\r\nif (error != last_error ||\r\ntime_after(jiffies, silence) || silence == 0){\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): "\r\n"chan %d error %s\n",dev->number,chan,\r\nerr_txt[error]);\r\nlast_error = error;\r\nsilence = (jiffies+2*HZ)|1;\r\n}\r\nsize = 0;\r\n}\r\nif (size && (size > cells*ATM_CELL_PAYLOAD-ATM_AAL5_TRAILER ||\r\nsize <= (cells-1)*ATM_CELL_PAYLOAD-ATM_AAL5_TRAILER)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): size %d with %d "\r\n"cells\n",dev->number,size,cells);\r\nsize = 0;\r\nevent_dump();\r\n}\r\nif (size > ATM_MAX_AAL5_PDU) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): size too big "\r\n"(%d)\n",dev->number,size);\r\nsize = 0;\r\nevent_dump();\r\n}\r\nif (!size) {\r\ndev_kfree_skb_irq(skb);\r\nif (vcc) atomic_inc(&vcc->stats->rx_err);\r\ncontinue;\r\n}\r\nif (!atm_charge(vcc,skb->truesize)) {\r\ndev_kfree_skb_irq(skb);\r\ncontinue;\r\n}\r\nskb->len = size;\r\nATM_SKB(skb)->vcc = vcc;\r\nvcc->push(vcc,skb);\r\natomic_inc(&vcc->stats->rx);\r\n}\r\nzout(pos & 0xffff,MTA(mbx));\r\n#if 0\r\nrefill_pool(dev,zatm_vcc->pool);\r\n#endif\r\n}\r\nstatic int open_rx_first(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nunsigned short chan;\r\nint cells;\r\nDPRINTK("open_rx_first (0x%x)\n",inb_p(0xc053));\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nzatm_vcc->rx_chan = 0;\r\nif (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;\r\nif (vcc->qos.aal == ATM_AAL5) {\r\nif (vcc->qos.rxtp.max_sdu > 65464)\r\nvcc->qos.rxtp.max_sdu = 65464;\r\ncells = DIV_ROUND_UP(vcc->qos.rxtp.max_sdu + ATM_AAL5_TRAILER,\r\nATM_CELL_PAYLOAD);\r\nzatm_vcc->pool = pool_index(cells*ATM_CELL_PAYLOAD);\r\n}\r\nelse {\r\ncells = 1;\r\nzatm_vcc->pool = ZATM_AAL0_POOL;\r\n}\r\nif (zatm_vcc->pool < 0) return -EMSGSIZE;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzwait;\r\nzout(uPD98401_OPEN_CHAN,CMR);\r\nzwait;\r\nDPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));\r\nchan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nDPRINTK("chan is %d\n",chan);\r\nif (!chan) return -EAGAIN;\r\nuse_pool(vcc->dev,zatm_vcc->pool);\r\nDPRINTK("pool %d\n",zatm_vcc->pool);\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzpokel(zatm_dev,zatm_vcc->pool << uPD98401_RXVC_POOL_SHIFT,\r\nchan*VC_SIZE/4);\r\nzpokel(zatm_dev,uPD98401_RXVC_OD | (vcc->qos.aal == ATM_AAL5 ?\r\nuPD98401_RXVC_AR : 0) | cells,chan*VC_SIZE/4+1);\r\nzpokel(zatm_dev,0,chan*VC_SIZE/4+2);\r\nzatm_vcc->rx_chan = chan;\r\nzatm_dev->rx_map[chan] = vcc;\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int open_rx_second(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nint pos,shift;\r\nDPRINTK("open_rx_second (0x%x)\n",inb_p(0xc053));\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nif (!zatm_vcc->rx_chan) return 0;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\npos = vcc->vci >> 1;\r\nshift = (1-(vcc->vci & 1)) << 4;\r\nzpokel(zatm_dev,(zpeekl(zatm_dev,pos) & ~(0xffff << shift)) |\r\n((zatm_vcc->rx_chan | uPD98401_RXLT_ENBL) << shift),pos);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void close_rx(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nint pos,shift;\r\nzatm_vcc = ZATM_VCC(vcc);\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nif (!zatm_vcc->rx_chan) return;\r\nDPRINTK("close_rx\n");\r\nif (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\npos = vcc->vci >> 1;\r\nshift = (1-(vcc->vci & 1)) << 4;\r\nzpokel(zatm_dev,zpeekl(zatm_dev,pos) & ~(0xffff << shift),pos);\r\nzwait;\r\nzout(uPD98401_NOP,CMR);\r\nzwait;\r\nzout(uPD98401_NOP,CMR);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\n}\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzwait;\r\nzout(uPD98401_DEACT_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<\r\nuPD98401_CHAN_ADDR_SHIFT),CMR);\r\nzwait;\r\nudelay(10);\r\nzout(uPD98401_CLOSE_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<\r\nuPD98401_CHAN_ADDR_SHIFT),CMR);\r\nzwait;\r\nif (!(zin(CMR) & uPD98401_CHAN_ADDR))\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): can't close RX channel "\r\n"%d\n",vcc->dev->number,zatm_vcc->rx_chan);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nzatm_dev->rx_map[zatm_vcc->rx_chan] = NULL;\r\nzatm_vcc->rx_chan = 0;\r\nunuse_pool(vcc->dev,zatm_vcc->pool);\r\n}\r\nstatic int start_rx(struct atm_dev *dev)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nint i;\r\nDPRINTK("start_rx\n");\r\nzatm_dev = ZATM_DEV(dev);\r\nzatm_dev->rx_map = kcalloc(zatm_dev->chans,\r\nsizeof(*zatm_dev->rx_map),\r\nGFP_KERNEL);\r\nif (!zatm_dev->rx_map) return -ENOMEM;\r\nzpokel(zatm_dev,(1 << dev->ci_range.vci_bits)-1,uPD98401_VRR);\r\nfor (i = 0; i <= ZATM_LAST_POOL; i++) {\r\nzatm_dev->pool_info[i].ref_count = 0;\r\nzatm_dev->pool_info[i].rqa_count = 0;\r\nzatm_dev->pool_info[i].rqu_count = 0;\r\nzatm_dev->pool_info[i].low_water = LOW_MARK;\r\nzatm_dev->pool_info[i].high_water = HIGH_MARK;\r\nzatm_dev->pool_info[i].offset = 0;\r\nzatm_dev->pool_info[i].next_off = 0;\r\nzatm_dev->pool_info[i].next_cnt = 0;\r\nzatm_dev->pool_info[i].next_thres = OFF_CNG_THRES;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_tx(struct sk_buff *skb)\r\n{\r\nstruct atm_vcc *vcc;\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nu32 *dsc;\r\nunsigned long flags;\r\nEVENT("do_tx\n",0,0);\r\nDPRINTK("sending skb %p\n",skb);\r\nvcc = ATM_SKB(skb)->vcc;\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nEVENT("iovcnt=%d\n",skb_shinfo(skb)->nr_frags,0);\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nif (!skb_shinfo(skb)->nr_frags) {\r\nif (zatm_vcc->txing == RING_ENTRIES-1) {\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn RING_BUSY;\r\n}\r\nzatm_vcc->txing++;\r\ndsc = zatm_vcc->ring+zatm_vcc->ring_curr;\r\nzatm_vcc->ring_curr = (zatm_vcc->ring_curr+RING_WORDS) &\r\n(RING_ENTRIES*RING_WORDS-1);\r\ndsc[1] = 0;\r\ndsc[2] = skb->len;\r\ndsc[3] = virt_to_bus(skb->data);\r\nmb();\r\ndsc[0] = uPD98401_TXPD_V | uPD98401_TXPD_DP | uPD98401_TXPD_SM\r\n| (vcc->qos.aal == ATM_AAL5 ? uPD98401_TXPD_AAL5 : 0 |\r\n(ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ?\r\nuPD98401_CLPM_1 : uPD98401_CLPM_0));\r\nEVENT("dsc (0x%lx)\n",(unsigned long) dsc,0);\r\n}\r\nelse {\r\nprintk("NONONONOO!!!!\n");\r\ndsc = NULL;\r\n#if 0\r\nu32 *put;\r\nint i;\r\ndsc = kmalloc(uPD98401_TXPD_SIZE * 2 +\r\nuPD98401_TXBD_SIZE * ATM_SKB(skb)->iovcnt, GFP_ATOMIC);\r\nif (!dsc) {\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_irq(skb);\r\nreturn -EAGAIN;\r\n}\r\nput = dsc+8;\r\ndsc[0] = uPD98401_TXPD_V | uPD98401_TXPD_DP |\r\n(vcc->aal == ATM_AAL5 ? uPD98401_TXPD_AAL5 : 0 |\r\n(ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ?\r\nuPD98401_CLPM_1 : uPD98401_CLPM_0));\r\ndsc[1] = 0;\r\ndsc[2] = ATM_SKB(skb)->iovcnt * uPD98401_TXBD_SIZE;\r\ndsc[3] = virt_to_bus(put);\r\nfor (i = 0; i < ATM_SKB(skb)->iovcnt; i++) {\r\n*put++ = ((struct iovec *) skb->data)[i].iov_len;\r\n*put++ = virt_to_bus(((struct iovec *)\r\nskb->data)[i].iov_base);\r\n}\r\nput[-2] |= uPD98401_TXBD_LAST;\r\n#endif\r\n}\r\nZATM_PRV_DSC(skb) = dsc;\r\nskb_queue_tail(&zatm_vcc->tx_queue,skb);\r\nDPRINTK("QRP=0x%08lx\n",zpeekl(zatm_dev,zatm_vcc->tx_chan*VC_SIZE/4+\r\nuPD98401_TXVC_QRP));\r\nzwait;\r\nzout(uPD98401_TX_READY | (zatm_vcc->tx_chan <<\r\nuPD98401_CHAN_ADDR_SHIFT),CMR);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nEVENT("done\n",0,0);\r\nreturn 0;\r\n}\r\nstatic inline void dequeue_tx(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_vcc *zatm_vcc;\r\nstruct sk_buff *skb;\r\nEVENT("dequeue_tx\n",0,0);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nskb = skb_dequeue(&zatm_vcc->tx_queue);\r\nif (!skb) {\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): dequeue_tx but not "\r\n"txing\n",vcc->dev->number);\r\nreturn;\r\n}\r\n#if 0\r\nif (*ZATM_PRV_DSC(skb) != (uPD98401_TXPD_V | uPD98401_TXPD_DP |\r\nuPD98401_TXPD_SM | uPD98401_TXPD_AAL5)) printk("@#*$!!!! (%08x)\n",\r\n*ZATM_PRV_DSC(skb));\r\n#endif\r\n*ZATM_PRV_DSC(skb) = 0;\r\nzatm_vcc->txing--;\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb_irq(skb);\r\nwhile ((skb = skb_dequeue(&zatm_vcc->backlog)))\r\nif (do_tx(skb) == RING_BUSY) {\r\nskb_queue_head(&zatm_vcc->backlog,skb);\r\nbreak;\r\n}\r\natomic_inc(&vcc->stats->tx);\r\nwake_up(&zatm_vcc->tx_wait);\r\n}\r\nstatic void poll_tx(struct atm_dev *dev,int mbx)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long pos;\r\nu32 x;\r\nEVENT("poll_tx\n",0,0);\r\nzatm_dev = ZATM_DEV(dev);\r\npos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));\r\nwhile (x = zin(MWA(mbx)), (pos & 0xffff) != x) {\r\nint chan;\r\n#if 1\r\nu32 data,*addr;\r\nEVENT("MBX: host 0x%lx, nic 0x%x\n",pos,x);\r\naddr = (u32 *) pos;\r\ndata = *addr;\r\nchan = (data & uPD98401_TXI_CONN) >> uPD98401_TXI_CONN_SHIFT;\r\nEVENT("addr = 0x%lx, data = 0x%08x,",(unsigned long) addr,\r\ndata);\r\nEVENT("chan = %d\n",chan,0);\r\n#else\r\nNO !\r\nchan = (zatm_dev->mbx_start[mbx][pos >> 2] & uPD98401_TXI_CONN)\r\n>> uPD98401_TXI_CONN_SHIFT;\r\n#endif\r\nif (chan < zatm_dev->chans && zatm_dev->tx_map[chan])\r\ndequeue_tx(zatm_dev->tx_map[chan]);\r\nelse {\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): TX indication "\r\n"for non-existing channel %d\n",dev->number,chan);\r\nevent_dump();\r\n}\r\nif (((pos += 4) & 0xffff) == zatm_dev->mbx_end[mbx])\r\npos = zatm_dev->mbx_start[mbx];\r\n}\r\nzout(pos & 0xffff,MTA(mbx));\r\n}\r\nstatic int alloc_shaper(struct atm_dev *dev,int *pcr,int min,int max,int ubr)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long flags;\r\nunsigned long i,m,c;\r\nint shaper;\r\nDPRINTK("alloc_shaper (min = %d, max = %d)\n",min,max);\r\nzatm_dev = ZATM_DEV(dev);\r\nif (!zatm_dev->free_shapers) return -EAGAIN;\r\nfor (shaper = 0; !((zatm_dev->free_shapers >> shaper) & 1); shaper++);\r\nzatm_dev->free_shapers &= ~1 << shaper;\r\nif (ubr) {\r\nc = 5;\r\ni = m = 1;\r\nzatm_dev->ubr_ref_cnt++;\r\nzatm_dev->ubr = shaper;\r\n*pcr = 0;\r\n}\r\nelse {\r\nif (min) {\r\nif (min <= 255) {\r\ni = min;\r\nm = ATM_OC3_PCR;\r\n}\r\nelse {\r\ni = 255;\r\nm = ATM_OC3_PCR*255/min;\r\n}\r\n}\r\nelse {\r\nif (max > zatm_dev->tx_bw) max = zatm_dev->tx_bw;\r\nif (max <= 255) {\r\ni = max;\r\nm = ATM_OC3_PCR;\r\n}\r\nelse {\r\ni = 255;\r\nm = DIV_ROUND_UP(ATM_OC3_PCR*255, max);\r\n}\r\n}\r\nif (i > m) {\r\nprintk(KERN_CRIT DEV_LABEL "shaper algorithm botched "\r\n"[%d,%d] -> i=%ld,m=%ld\n",min,max,i,m);\r\nm = i;\r\n}\r\n*pcr = i*ATM_OC3_PCR/m;\r\nc = 20;\r\nif ((min && *pcr < min) || (max && *pcr > max)) return -EINVAL;\r\nif (zatm_dev->tx_bw < *pcr) return -EAGAIN;\r\nzatm_dev->tx_bw -= *pcr;\r\n}\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nDPRINTK("i = %d, m = %d, PCR = %d\n",i,m,*pcr);\r\nzpokel(zatm_dev,(i << uPD98401_IM_I_SHIFT) | m,uPD98401_IM(shaper));\r\nzpokel(zatm_dev,c << uPD98401_PC_C_SHIFT,uPD98401_PC(shaper));\r\nzpokel(zatm_dev,0,uPD98401_X(shaper));\r\nzpokel(zatm_dev,0,uPD98401_Y(shaper));\r\nzpokel(zatm_dev,uPD98401_PS_E,uPD98401_PS(shaper));\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn shaper;\r\n}\r\nstatic void dealloc_shaper(struct atm_dev *dev,int shaper)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long flags;\r\nzatm_dev = ZATM_DEV(dev);\r\nif (shaper == zatm_dev->ubr) {\r\nif (--zatm_dev->ubr_ref_cnt) return;\r\nzatm_dev->ubr = -1;\r\n}\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzpokel(zatm_dev,zpeekl(zatm_dev,uPD98401_PS(shaper)) & ~uPD98401_PS_E,\r\nuPD98401_PS(shaper));\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nzatm_dev->free_shapers |= 1 << shaper;\r\n}\r\nstatic void close_tx(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nint chan;\r\nzatm_vcc = ZATM_VCC(vcc);\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nchan = zatm_vcc->tx_chan;\r\nif (!chan) return;\r\nDPRINTK("close_tx\n");\r\nif (skb_peek(&zatm_vcc->backlog)) {\r\nprintk("waiting for backlog to drain ...\n");\r\nevent_dump();\r\nwait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->backlog));\r\n}\r\nif (skb_peek(&zatm_vcc->tx_queue)) {\r\nprintk("waiting for TX queue to drain ...\n");\r\nevent_dump();\r\nwait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->tx_queue));\r\n}\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\n#if 0\r\nzwait;\r\nzout(uPD98401_DEACT_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);\r\n#endif\r\nzwait;\r\nzout(uPD98401_CLOSE_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);\r\nzwait;\r\nif (!(zin(CMR) & uPD98401_CHAN_ADDR))\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): can't close TX channel "\r\n"%d\n",vcc->dev->number,chan);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nzatm_vcc->tx_chan = 0;\r\nzatm_dev->tx_map[chan] = NULL;\r\nif (zatm_vcc->shaper != zatm_dev->ubr) {\r\nzatm_dev->tx_bw += vcc->qos.txtp.min_pcr;\r\ndealloc_shaper(vcc->dev,zatm_vcc->shaper);\r\n}\r\nkfree(zatm_vcc->ring);\r\n}\r\nstatic int open_tx_first(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nu32 *loop;\r\nunsigned short chan;\r\nint unlimited;\r\nDPRINTK("open_tx_first\n");\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nzatm_vcc->tx_chan = 0;\r\nif (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzwait;\r\nzout(uPD98401_OPEN_CHAN,CMR);\r\nzwait;\r\nDPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));\r\nchan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nDPRINTK("chan is %d\n",chan);\r\nif (!chan) return -EAGAIN;\r\nunlimited = vcc->qos.txtp.traffic_class == ATM_UBR &&\r\n(!vcc->qos.txtp.max_pcr || vcc->qos.txtp.max_pcr == ATM_MAX_PCR ||\r\nvcc->qos.txtp.max_pcr >= ATM_OC3_PCR);\r\nif (unlimited && zatm_dev->ubr != -1) zatm_vcc->shaper = zatm_dev->ubr;\r\nelse {\r\nint uninitialized_var(pcr);\r\nif (unlimited) vcc->qos.txtp.max_sdu = ATM_MAX_AAL5_PDU;\r\nif ((zatm_vcc->shaper = alloc_shaper(vcc->dev,&pcr,\r\nvcc->qos.txtp.min_pcr,vcc->qos.txtp.max_pcr,unlimited))\r\n< 0) {\r\nclose_tx(vcc);\r\nreturn zatm_vcc->shaper;\r\n}\r\nif (pcr > ATM_OC3_PCR) pcr = ATM_OC3_PCR;\r\nvcc->qos.txtp.min_pcr = vcc->qos.txtp.max_pcr = pcr;\r\n}\r\nzatm_vcc->tx_chan = chan;\r\nskb_queue_head_init(&zatm_vcc->tx_queue);\r\ninit_waitqueue_head(&zatm_vcc->tx_wait);\r\nzatm_vcc->ring = kzalloc(RING_SIZE,GFP_KERNEL);\r\nif (!zatm_vcc->ring) return -ENOMEM;\r\nloop = zatm_vcc->ring+RING_ENTRIES*RING_WORDS;\r\nloop[0] = uPD98401_TXPD_V;\r\nloop[1] = loop[2] = 0;\r\nloop[3] = virt_to_bus(zatm_vcc->ring);\r\nzatm_vcc->ring_curr = 0;\r\nzatm_vcc->txing = 0;\r\nskb_queue_head_init(&zatm_vcc->backlog);\r\nzpokel(zatm_dev,virt_to_bus(zatm_vcc->ring),\r\nchan*VC_SIZE/4+uPD98401_TXVC_QRP);\r\nreturn 0;\r\n}\r\nstatic int open_tx_second(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nunsigned long flags;\r\nDPRINTK("open_tx_second\n");\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nzatm_vcc = ZATM_VCC(vcc);\r\nif (!zatm_vcc->tx_chan) return 0;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzpokel(zatm_dev,0,zatm_vcc->tx_chan*VC_SIZE/4);\r\nzpokel(zatm_dev,uPD98401_TXVC_L | (zatm_vcc->shaper <<\r\nuPD98401_TXVC_SHP_SHIFT) | (vcc->vpi << uPD98401_TXVC_VPI_SHIFT) |\r\nvcc->vci,zatm_vcc->tx_chan*VC_SIZE/4+1);\r\nzpokel(zatm_dev,0,zatm_vcc->tx_chan*VC_SIZE/4+2);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nzatm_dev->tx_map[zatm_vcc->tx_chan] = vcc;\r\nreturn 0;\r\n}\r\nstatic int start_tx(struct atm_dev *dev)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nint i;\r\nDPRINTK("start_tx\n");\r\nzatm_dev = ZATM_DEV(dev);\r\nzatm_dev->tx_map = kmalloc_array(zatm_dev->chans,\r\nsizeof(*zatm_dev->tx_map),\r\nGFP_KERNEL);\r\nif (!zatm_dev->tx_map) return -ENOMEM;\r\nzatm_dev->tx_bw = ATM_OC3_PCR;\r\nzatm_dev->free_shapers = (1 << NR_SHAPERS)-1;\r\nzatm_dev->ubr = -1;\r\nzatm_dev->ubr_ref_cnt = 0;\r\nfor (i = 0; i < NR_SHAPERS; i++) zpokel(zatm_dev,0,uPD98401_PS(i));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t zatm_int(int irq,void *dev_id)\r\n{\r\nstruct atm_dev *dev;\r\nstruct zatm_dev *zatm_dev;\r\nu32 reason;\r\nint handled = 0;\r\ndev = dev_id;\r\nzatm_dev = ZATM_DEV(dev);\r\nwhile ((reason = zin(GSR))) {\r\nhandled = 1;\r\nEVENT("reason 0x%x\n",reason,0);\r\nif (reason & uPD98401_INT_PI) {\r\nEVENT("PHY int\n",0,0);\r\ndev->phy->interrupt(dev);\r\n}\r\nif (reason & uPD98401_INT_RQA) {\r\nunsigned long pools;\r\nint i;\r\npools = zin(RQA);\r\nEVENT("RQA (0x%08x)\n",pools,0);\r\nfor (i = 0; pools; i++) {\r\nif (pools & 1) {\r\nrefill_pool(dev,i);\r\nzatm_dev->pool_info[i].rqa_count++;\r\n}\r\npools >>= 1;\r\n}\r\n}\r\nif (reason & uPD98401_INT_RQU) {\r\nunsigned long pools;\r\nint i;\r\npools = zin(RQU);\r\nprintk(KERN_WARNING DEV_LABEL "(itf %d): RQU 0x%08lx\n",\r\ndev->number,pools);\r\nevent_dump();\r\nfor (i = 0; pools; i++) {\r\nif (pools & 1) {\r\nrefill_pool(dev,i);\r\nzatm_dev->pool_info[i].rqu_count++;\r\n}\r\npools >>= 1;\r\n}\r\n}\r\nif (reason & uPD98401_INT_SPE)\r\nprintk(KERN_ALERT DEV_LABEL "(itf %d): system parity "\r\n"error at 0x%08x\n",dev->number,zin(ADDR));\r\nif (reason & uPD98401_INT_CPE)\r\nprintk(KERN_ALERT DEV_LABEL "(itf %d): control memory "\r\n"parity error at 0x%08x\n",dev->number,zin(ADDR));\r\nif (reason & uPD98401_INT_SBE) {\r\nprintk(KERN_ALERT DEV_LABEL "(itf %d): system bus "\r\n"error at 0x%08x\n",dev->number,zin(ADDR));\r\nevent_dump();\r\n}\r\nif (reason & uPD98401_INT_MF) {\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): mailbox full "\r\n"(0x%x)\n",dev->number,(reason & uPD98401_INT_MF)\r\n>> uPD98401_INT_MF_SHIFT);\r\nevent_dump();\r\n}\r\nif (reason & uPD98401_INT_MM) {\r\nif (reason & 1) poll_rx(dev,0);\r\nif (reason & 2) poll_rx(dev,1);\r\nif (reason & 4) poll_tx(dev,2);\r\nif (reason & 8) poll_tx(dev,3);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void eprom_set(struct zatm_dev *zatm_dev, unsigned long value,\r\nunsigned short cmd)\r\n{\r\nint error;\r\nif ((error = pci_write_config_dword(zatm_dev->pci_dev,cmd,value)))\r\nprintk(KERN_ERR DEV_LABEL ": PCI write failed (0x%02x)\n",\r\nerror);\r\n}\r\nstatic unsigned long eprom_get(struct zatm_dev *zatm_dev, unsigned short cmd)\r\n{\r\nunsigned int value;\r\nint error;\r\nif ((error = pci_read_config_dword(zatm_dev->pci_dev,cmd,&value)))\r\nprintk(KERN_ERR DEV_LABEL ": PCI read failed (0x%02x)\n",\r\nerror);\r\nreturn value;\r\n}\r\nstatic void eprom_put_bits(struct zatm_dev *zatm_dev, unsigned long data,\r\nint bits, unsigned short cmd)\r\n{\r\nunsigned long value;\r\nint i;\r\nfor (i = bits-1; i >= 0; i--) {\r\nvalue = ZEPROM_CS | (((data >> i) & 1) ? ZEPROM_DI : 0);\r\neprom_set(zatm_dev,value,cmd);\r\neprom_set(zatm_dev,value | ZEPROM_SK,cmd);\r\neprom_set(zatm_dev,value,cmd);\r\n}\r\n}\r\nstatic void eprom_get_byte(struct zatm_dev *zatm_dev, unsigned char *byte,\r\nunsigned short cmd)\r\n{\r\nint i;\r\n*byte = 0;\r\nfor (i = 8; i; i--) {\r\neprom_set(zatm_dev,ZEPROM_CS,cmd);\r\neprom_set(zatm_dev,ZEPROM_CS | ZEPROM_SK,cmd);\r\n*byte <<= 1;\r\nif (eprom_get(zatm_dev,cmd) & ZEPROM_DO) *byte |= 1;\r\neprom_set(zatm_dev,ZEPROM_CS,cmd);\r\n}\r\n}\r\nstatic unsigned char eprom_try_esi(struct atm_dev *dev, unsigned short cmd,\r\nint offset, int swap)\r\n{\r\nunsigned char buf[ZEPROM_SIZE];\r\nstruct zatm_dev *zatm_dev;\r\nint i;\r\nzatm_dev = ZATM_DEV(dev);\r\nfor (i = 0; i < ZEPROM_SIZE; i += 2) {\r\neprom_set(zatm_dev,ZEPROM_CS,cmd);\r\neprom_put_bits(zatm_dev,ZEPROM_CMD_READ,ZEPROM_CMD_LEN,cmd);\r\neprom_put_bits(zatm_dev,i >> 1,ZEPROM_ADDR_LEN,cmd);\r\neprom_get_byte(zatm_dev,buf+i+swap,cmd);\r\neprom_get_byte(zatm_dev,buf+i+1-swap,cmd);\r\neprom_set(zatm_dev,0,cmd);\r\n}\r\nmemcpy(dev->esi,buf+offset,ESI_LEN);\r\nreturn memcmp(dev->esi,"\0\0\0\0\0",ESI_LEN);\r\n}\r\nstatic void eprom_get_esi(struct atm_dev *dev)\r\n{\r\nif (eprom_try_esi(dev,ZEPROM_V1_REG,ZEPROM_V1_ESI_OFF,1)) return;\r\n(void) eprom_try_esi(dev,ZEPROM_V2_REG,ZEPROM_V2_ESI_OFF,0);\r\n}\r\nstatic int zatm_init(struct atm_dev *dev)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned short command;\r\nint error,i,last;\r\nunsigned long t0,t1,t2;\r\nDPRINTK(">zatm_init\n");\r\nzatm_dev = ZATM_DEV(dev);\r\nspin_lock_init(&zatm_dev->lock);\r\npci_dev = zatm_dev->pci_dev;\r\nzatm_dev->base = pci_resource_start(pci_dev, 0);\r\nzatm_dev->irq = pci_dev->irq;\r\nif ((error = pci_read_config_word(pci_dev,PCI_COMMAND,&command))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%02x\n",\r\ndev->number,error);\r\nreturn -EINVAL;\r\n}\r\nif ((error = pci_write_config_word(pci_dev,PCI_COMMAND,\r\ncommand | PCI_COMMAND_IO | PCI_COMMAND_MASTER))) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't enable IO (0x%02x)"\r\n"\n",dev->number,error);\r\nreturn -EIO;\r\n}\r\neprom_get_esi(dev);\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d,base=0x%x,irq=%d,",\r\ndev->number,pci_dev->revision,zatm_dev->base,zatm_dev->irq);\r\nzout(0,SWR);\r\nwhile (!(zin(GSR) & uPD98401_INT_IND));\r\nzout(uPD98401_GMR_ONE ,GMR);\r\nlast = MAX_CRAM_SIZE;\r\nfor (i = last-RAM_INCREMENT; i >= 0; i -= RAM_INCREMENT) {\r\nzpokel(zatm_dev,0x55555555,i);\r\nif (zpeekl(zatm_dev,i) != 0x55555555) last = i;\r\nelse {\r\nzpokel(zatm_dev,0xAAAAAAAA,i);\r\nif (zpeekl(zatm_dev,i) != 0xAAAAAAAA) last = i;\r\nelse zpokel(zatm_dev,i,i);\r\n}\r\n}\r\nfor (i = 0; i < last; i += RAM_INCREMENT)\r\nif (zpeekl(zatm_dev,i) != i) break;\r\nzatm_dev->mem = i << 2;\r\nwhile (i) zpokel(zatm_dev,0,--i);\r\nzout(0,SWR);\r\nwhile (!(zin(GSR) & uPD98401_INT_IND));\r\nzout(uPD98401_GMR_ONE | uPD98401_BURST8 | uPD98401_BURST4 |\r\nuPD98401_BURST2 | uPD98401_GMR_PM | uPD98401_GMR_DR,GMR);\r\nprintk("mem=%dkB,%s (",zatm_dev->mem >> 10,zatm_dev->copper ? "UTP" :\r\n"MMF");\r\nfor (i = 0; i < ESI_LEN; i++)\r\nprintk("%02X%s",dev->esi[i],i == ESI_LEN-1 ? ")\n" : "-");\r\ndo {\r\nunsigned long flags;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nt0 = zpeekl(zatm_dev,uPD98401_TSR);\r\nudelay(10);\r\nt1 = zpeekl(zatm_dev,uPD98401_TSR);\r\nudelay(1010);\r\nt2 = zpeekl(zatm_dev,uPD98401_TSR);\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\n}\r\nwhile (t0 > t1 || t1 > t2);\r\nzatm_dev->khz = t2-2*t1+t0;\r\nprintk(KERN_NOTICE DEV_LABEL "(itf %d): uPD98401 %d.%d at %d.%03d "\r\n"MHz\n",dev->number,\r\n(zin(VER) & uPD98401_MAJOR) >> uPD98401_MAJOR_SHIFT,\r\nzin(VER) & uPD98401_MINOR,zatm_dev->khz/1000,zatm_dev->khz % 1000);\r\nreturn uPD98402_init(dev);\r\n}\r\nstatic int zatm_start(struct atm_dev *dev)\r\n{\r\nstruct zatm_dev *zatm_dev = ZATM_DEV(dev);\r\nstruct pci_dev *pdev = zatm_dev->pci_dev;\r\nunsigned long curr;\r\nint pools,vccs,rx;\r\nint error, i, ld;\r\nDPRINTK("zatm_start\n");\r\nzatm_dev->rx_map = zatm_dev->tx_map = NULL;\r\nfor (i = 0; i < NR_MBX; i++)\r\nzatm_dev->mbx_start[i] = 0;\r\nerror = request_irq(zatm_dev->irq, zatm_int, IRQF_SHARED, DEV_LABEL, dev);\r\nif (error < 0) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",\r\ndev->number,zatm_dev->irq);\r\ngoto done;\r\n}\r\npools = NR_POOLS;\r\nif (NR_SHAPERS*SHAPER_SIZE > pools*POOL_SIZE)\r\npools = NR_SHAPERS*SHAPER_SIZE/POOL_SIZE;\r\nvccs = (zatm_dev->mem-NR_SHAPERS*SHAPER_SIZE-pools*POOL_SIZE)/\r\n(2*VC_SIZE+RX_SIZE);\r\nld = -1;\r\nfor (rx = 1; rx < vccs; rx <<= 1) ld++;\r\ndev->ci_range.vpi_bits = 0;\r\ndev->ci_range.vci_bits = ld;\r\ndev->link_rate = ATM_OC3_PCR;\r\nzatm_dev->chans = vccs;\r\ncurr = rx*RX_SIZE/4;\r\nDPRINTK("RX pool 0x%08lx\n",curr);\r\nzpokel(zatm_dev,curr,uPD98401_PMA);\r\nzatm_dev->pool_base = curr;\r\ncurr += pools*POOL_SIZE/4;\r\nDPRINTK("Shapers 0x%08lx\n",curr);\r\nzpokel(zatm_dev,curr,uPD98401_SMA);\r\ncurr += NR_SHAPERS*SHAPER_SIZE/4;\r\nDPRINTK("Free 0x%08lx\n",curr);\r\nzpokel(zatm_dev,curr,uPD98401_TOS);\r\nprintk(KERN_INFO DEV_LABEL "(itf %d): %d shapers, %d pools, %d RX, "\r\n"%ld VCs\n",dev->number,NR_SHAPERS,pools,rx,\r\n(zatm_dev->mem-curr*4)/VC_SIZE);\r\nfor (i = 0; i < NR_MBX; i++) {\r\nvoid *mbx;\r\ndma_addr_t mbx_dma;\r\nif (!mbx_entries[i])\r\ncontinue;\r\nmbx = dma_alloc_coherent(&pdev->dev,\r\n2 * MBX_SIZE(i), &mbx_dma, GFP_KERNEL);\r\nif (!mbx) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nif (((unsigned long)mbx ^ mbx_dma) & 0xffff) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): system "\r\n"bus incompatible with driver\n", dev->number);\r\ndma_free_coherent(&pdev->dev, 2*MBX_SIZE(i), mbx, mbx_dma);\r\nerror = -ENODEV;\r\ngoto out;\r\n}\r\nDPRINTK("mbx@0x%08lx-0x%08lx\n", mbx, mbx + MBX_SIZE(i));\r\nzatm_dev->mbx_start[i] = (unsigned long)mbx;\r\nzatm_dev->mbx_dma[i] = mbx_dma;\r\nzatm_dev->mbx_end[i] = (zatm_dev->mbx_start[i] + MBX_SIZE(i)) &\r\n0xffff;\r\nzout(mbx_dma >> 16, MSH(i));\r\nzout(mbx_dma, MSL(i));\r\nzout(zatm_dev->mbx_end[i], MBA(i));\r\nzout((unsigned long)mbx & 0xffff, MTA(i));\r\nzout((unsigned long)mbx & 0xffff, MWA(i));\r\n}\r\nerror = start_tx(dev);\r\nif (error)\r\ngoto out;\r\nerror = start_rx(dev);\r\nif (error)\r\ngoto out_tx;\r\nerror = dev->phy->start(dev);\r\nif (error)\r\ngoto out_rx;\r\nzout(0xffffffff,IMR);\r\nzout(zin(GMR) | uPD98401_GMR_SE | uPD98401_GMR_RE,GMR);\r\ndone:\r\nreturn error;\r\nout_rx:\r\nkfree(zatm_dev->rx_map);\r\nout_tx:\r\nkfree(zatm_dev->tx_map);\r\nout:\r\nwhile (i-- > 0) {\r\ndma_free_coherent(&pdev->dev, 2 * MBX_SIZE(i),\r\n(void *)zatm_dev->mbx_start[i],\r\nzatm_dev->mbx_dma[i]);\r\n}\r\nfree_irq(zatm_dev->irq, dev);\r\ngoto done;\r\n}\r\nstatic void zatm_close(struct atm_vcc *vcc)\r\n{\r\nDPRINTK(">zatm_close\n");\r\nif (!ZATM_VCC(vcc)) return;\r\nclear_bit(ATM_VF_READY,&vcc->flags);\r\nclose_rx(vcc);\r\nEVENT("close_tx\n",0,0);\r\nclose_tx(vcc);\r\nDPRINTK("zatm_close: done waiting\n");\r\nkfree(ZATM_VCC(vcc));\r\nvcc->dev_data = NULL;\r\nclear_bit(ATM_VF_ADDR,&vcc->flags);\r\n}\r\nstatic int zatm_open(struct atm_vcc *vcc)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nstruct zatm_vcc *zatm_vcc;\r\nshort vpi = vcc->vpi;\r\nint vci = vcc->vci;\r\nint error;\r\nDPRINTK(">zatm_open\n");\r\nzatm_dev = ZATM_DEV(vcc->dev);\r\nif (!test_bit(ATM_VF_PARTIAL,&vcc->flags))\r\nvcc->dev_data = NULL;\r\nif (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)\r\nset_bit(ATM_VF_ADDR,&vcc->flags);\r\nif (vcc->qos.aal != ATM_AAL5) return -EINVAL;\r\nDPRINTK(DEV_LABEL "(itf %d): open %d.%d\n",vcc->dev->number,vcc->vpi,\r\nvcc->vci);\r\nif (!test_bit(ATM_VF_PARTIAL,&vcc->flags)) {\r\nzatm_vcc = kmalloc(sizeof(*zatm_vcc), GFP_KERNEL);\r\nif (!zatm_vcc) {\r\nclear_bit(ATM_VF_ADDR,&vcc->flags);\r\nreturn -ENOMEM;\r\n}\r\nvcc->dev_data = zatm_vcc;\r\nZATM_VCC(vcc)->tx_chan = 0;\r\nif ((error = open_rx_first(vcc))) {\r\nzatm_close(vcc);\r\nreturn error;\r\n}\r\nif ((error = open_tx_first(vcc))) {\r\nzatm_close(vcc);\r\nreturn error;\r\n}\r\n}\r\nif (vci == ATM_VPI_UNSPEC || vpi == ATM_VCI_UNSPEC) return 0;\r\nif ((error = open_rx_second(vcc))) {\r\nzatm_close(vcc);\r\nreturn error;\r\n}\r\nif ((error = open_tx_second(vcc))) {\r\nzatm_close(vcc);\r\nreturn error;\r\n}\r\nset_bit(ATM_VF_READY,&vcc->flags);\r\nreturn 0;\r\n}\r\nstatic int zatm_change_qos(struct atm_vcc *vcc,struct atm_qos *qos,int flags)\r\n{\r\nprintk("Not yet implemented\n");\r\nreturn -ENOSYS;\r\n}\r\nstatic int zatm_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nunsigned long flags;\r\nzatm_dev = ZATM_DEV(dev);\r\nswitch (cmd) {\r\ncase ZATM_GETPOOLZ:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\ncase ZATM_GETPOOL:\r\n{\r\nstruct zatm_pool_info info;\r\nint pool;\r\nif (get_user(pool,\r\n&((struct zatm_pool_req __user *) arg)->pool_num))\r\nreturn -EFAULT;\r\nif (pool < 0 || pool > ZATM_LAST_POOL)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\ninfo = zatm_dev->pool_info[pool];\r\nif (cmd == ZATM_GETPOOLZ) {\r\nzatm_dev->pool_info[pool].rqa_count = 0;\r\nzatm_dev->pool_info[pool].rqu_count = 0;\r\n}\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn copy_to_user(\r\n&((struct zatm_pool_req __user *) arg)->info,\r\n&info,sizeof(info)) ? -EFAULT : 0;\r\n}\r\ncase ZATM_SETPOOL:\r\n{\r\nstruct zatm_pool_info info;\r\nint pool;\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (get_user(pool,\r\n&((struct zatm_pool_req __user *) arg)->pool_num))\r\nreturn -EFAULT;\r\nif (pool < 0 || pool > ZATM_LAST_POOL)\r\nreturn -EINVAL;\r\nif (copy_from_user(&info,\r\n&((struct zatm_pool_req __user *) arg)->info,\r\nsizeof(info))) return -EFAULT;\r\nif (!info.low_water)\r\ninfo.low_water = zatm_dev->\r\npool_info[pool].low_water;\r\nif (!info.high_water)\r\ninfo.high_water = zatm_dev->\r\npool_info[pool].high_water;\r\nif (!info.next_thres)\r\ninfo.next_thres = zatm_dev->\r\npool_info[pool].next_thres;\r\nif (info.low_water >= info.high_water ||\r\ninfo.low_water < 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&zatm_dev->lock, flags);\r\nzatm_dev->pool_info[pool].low_water =\r\ninfo.low_water;\r\nzatm_dev->pool_info[pool].high_water =\r\ninfo.high_water;\r\nzatm_dev->pool_info[pool].next_thres =\r\ninfo.next_thres;\r\nspin_unlock_irqrestore(&zatm_dev->lock, flags);\r\nreturn 0;\r\n}\r\ndefault:\r\nif (!dev->phy->ioctl) return -ENOIOCTLCMD;\r\nreturn dev->phy->ioctl(dev,cmd,arg);\r\n}\r\n}\r\nstatic int zatm_getsockopt(struct atm_vcc *vcc,int level,int optname,\r\nvoid __user *optval,int optlen)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int zatm_setsockopt(struct atm_vcc *vcc,int level,int optname,\r\nvoid __user *optval,unsigned int optlen)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int zatm_send(struct atm_vcc *vcc,struct sk_buff *skb)\r\n{\r\nint error;\r\nEVENT(">zatm_send 0x%lx\n",(unsigned long) skb,0);\r\nif (!ZATM_VCC(vcc)->tx_chan || !test_bit(ATM_VF_READY,&vcc->flags)) {\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nelse dev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!skb) {\r\nprintk(KERN_CRIT "!skb in zatm_send ?\n");\r\nif (vcc->pop) vcc->pop(vcc,skb);\r\nreturn -EINVAL;\r\n}\r\nATM_SKB(skb)->vcc = vcc;\r\nerror = do_tx(skb);\r\nif (error != RING_BUSY) return error;\r\nskb_queue_tail(&ZATM_VCC(vcc)->backlog,skb);\r\nreturn 0;\r\n}\r\nstatic void zatm_phy_put(struct atm_dev *dev,unsigned char value,\r\nunsigned long addr)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nzatm_dev = ZATM_DEV(dev);\r\nzwait;\r\nzout(value,CER);\r\nzout(uPD98401_IND_ACC | uPD98401_IA_B0 |\r\n(uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);\r\n}\r\nstatic unsigned char zatm_phy_get(struct atm_dev *dev,unsigned long addr)\r\n{\r\nstruct zatm_dev *zatm_dev;\r\nzatm_dev = ZATM_DEV(dev);\r\nzwait;\r\nzout(uPD98401_IND_ACC | uPD98401_IA_B0 | uPD98401_IA_RW |\r\n(uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);\r\nzwait;\r\nreturn zin(CER) & 0xff;\r\n}\r\nstatic int zatm_init_one(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct atm_dev *dev;\r\nstruct zatm_dev *zatm_dev;\r\nint ret = -ENOMEM;\r\nzatm_dev = kmalloc(sizeof(*zatm_dev), GFP_KERNEL);\r\nif (!zatm_dev) {\r\nprintk(KERN_EMERG "%s: memory shortage\n", DEV_LABEL);\r\ngoto out;\r\n}\r\ndev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &ops, -1, NULL);\r\nif (!dev)\r\ngoto out_free;\r\nret = pci_enable_device(pci_dev);\r\nif (ret < 0)\r\ngoto out_deregister;\r\nret = pci_request_regions(pci_dev, DEV_LABEL);\r\nif (ret < 0)\r\ngoto out_disable;\r\nret = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\ngoto out_disable;\r\nzatm_dev->pci_dev = pci_dev;\r\ndev->dev_data = zatm_dev;\r\nzatm_dev->copper = (int)ent->driver_data;\r\nif ((ret = zatm_init(dev)) || (ret = zatm_start(dev)))\r\ngoto out_release;\r\npci_set_drvdata(pci_dev, dev);\r\nzatm_dev->more = zatm_boards;\r\nzatm_boards = dev;\r\nret = 0;\r\nout:\r\nreturn ret;\r\nout_release:\r\npci_release_regions(pci_dev);\r\nout_disable:\r\npci_disable_device(pci_dev);\r\nout_deregister:\r\natm_dev_deregister(dev);\r\nout_free:\r\nkfree(zatm_dev);\r\ngoto out;\r\n}\r\nstatic int __init zatm_init_module(void)\r\n{\r\nreturn pci_register_driver(&zatm_driver);\r\n}
