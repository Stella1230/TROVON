void i40iw_free_sqbuf(struct i40iw_sc_vsi *vsi, void *bufp)\r\n{\r\nstruct i40iw_puda_buf *buf = (struct i40iw_puda_buf *)bufp;\r\nstruct i40iw_puda_rsrc *ilq = vsi->ilq;\r\nif (!atomic_dec_return(&buf->refcount))\r\ni40iw_puda_ret_bufpool(ilq, buf);\r\n}\r\nstatic u8 i40iw_derive_hw_ird_setting(u16 cm_ird)\r\n{\r\nu8 encoded_ird_size;\r\nu8 pof2_cm_ird = 1;\r\nwhile (pof2_cm_ird < cm_ird)\r\npof2_cm_ird *= 2;\r\nswitch (pof2_cm_ird) {\r\ncase I40IW_HW_IRD_SETTING_64:\r\nencoded_ird_size = 3;\r\nbreak;\r\ncase I40IW_HW_IRD_SETTING_32:\r\ncase I40IW_HW_IRD_SETTING_16:\r\nencoded_ird_size = 2;\r\nbreak;\r\ncase I40IW_HW_IRD_SETTING_8:\r\ncase I40IW_HW_IRD_SETTING_4:\r\nencoded_ird_size = 1;\r\nbreak;\r\ncase I40IW_HW_IRD_SETTING_2:\r\ndefault:\r\nencoded_ird_size = 0;\r\nbreak;\r\n}\r\nreturn encoded_ird_size;\r\n}\r\nstatic void i40iw_record_ird_ord(struct i40iw_cm_node *cm_node, u16 conn_ird, u16 conn_ord)\r\n{\r\nif (conn_ird > I40IW_MAX_IRD_SIZE)\r\nconn_ird = I40IW_MAX_IRD_SIZE;\r\nif (conn_ord > I40IW_MAX_ORD_SIZE)\r\nconn_ord = I40IW_MAX_ORD_SIZE;\r\ncm_node->ird_size = conn_ird;\r\ncm_node->ord_size = conn_ord;\r\n}\r\nvoid i40iw_copy_ip_ntohl(u32 *dst, __be32 *src)\r\n{\r\n*dst++ = ntohl(*src++);\r\n*dst++ = ntohl(*src++);\r\n*dst++ = ntohl(*src++);\r\n*dst = ntohl(*src);\r\n}\r\nstatic inline void i40iw_copy_ip_htonl(__be32 *dst, u32 *src)\r\n{\r\n*dst++ = htonl(*src++);\r\n*dst++ = htonl(*src++);\r\n*dst++ = htonl(*src++);\r\n*dst = htonl(*src);\r\n}\r\nstatic inline void i40iw_fill_sockaddr4(struct i40iw_cm_node *cm_node,\r\nstruct iw_cm_event *event)\r\n{\r\nstruct sockaddr_in *laddr = (struct sockaddr_in *)&event->local_addr;\r\nstruct sockaddr_in *raddr = (struct sockaddr_in *)&event->remote_addr;\r\nladdr->sin_family = AF_INET;\r\nraddr->sin_family = AF_INET;\r\nladdr->sin_port = htons(cm_node->loc_port);\r\nraddr->sin_port = htons(cm_node->rem_port);\r\nladdr->sin_addr.s_addr = htonl(cm_node->loc_addr[0]);\r\nraddr->sin_addr.s_addr = htonl(cm_node->rem_addr[0]);\r\n}\r\nstatic inline void i40iw_fill_sockaddr6(struct i40iw_cm_node *cm_node,\r\nstruct iw_cm_event *event)\r\n{\r\nstruct sockaddr_in6 *laddr6 = (struct sockaddr_in6 *)&event->local_addr;\r\nstruct sockaddr_in6 *raddr6 = (struct sockaddr_in6 *)&event->remote_addr;\r\nladdr6->sin6_family = AF_INET6;\r\nraddr6->sin6_family = AF_INET6;\r\nladdr6->sin6_port = htons(cm_node->loc_port);\r\nraddr6->sin6_port = htons(cm_node->rem_port);\r\ni40iw_copy_ip_htonl(laddr6->sin6_addr.in6_u.u6_addr32,\r\ncm_node->loc_addr);\r\ni40iw_copy_ip_htonl(raddr6->sin6_addr.in6_u.u6_addr32,\r\ncm_node->rem_addr);\r\n}\r\nstatic void i40iw_get_addr_info(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_cm_info *cm_info)\r\n{\r\ncm_info->ipv4 = cm_node->ipv4;\r\ncm_info->vlan_id = cm_node->vlan_id;\r\nmemcpy(cm_info->loc_addr, cm_node->loc_addr, sizeof(cm_info->loc_addr));\r\nmemcpy(cm_info->rem_addr, cm_node->rem_addr, sizeof(cm_info->rem_addr));\r\ncm_info->loc_port = cm_node->loc_port;\r\ncm_info->rem_port = cm_node->rem_port;\r\ncm_info->user_pri = cm_node->user_pri;\r\n}\r\nstatic inline void i40iw_get_cmevent_info(struct i40iw_cm_node *cm_node,\r\nstruct iw_cm_id *cm_id,\r\nstruct iw_cm_event *event)\r\n{\r\nmemcpy(&event->local_addr, &cm_id->m_local_addr,\r\nsizeof(event->local_addr));\r\nmemcpy(&event->remote_addr, &cm_id->m_remote_addr,\r\nsizeof(event->remote_addr));\r\nif (cm_node) {\r\nevent->private_data = (void *)cm_node->pdata_buf;\r\nevent->private_data_len = (u8)cm_node->pdata.size;\r\nevent->ird = cm_node->ird_size;\r\nevent->ord = cm_node->ord_size;\r\n}\r\n}\r\nstatic int i40iw_send_cm_event(struct i40iw_cm_node *cm_node,\r\nstruct iw_cm_id *cm_id,\r\nenum iw_cm_event_type type,\r\nint status)\r\n{\r\nstruct iw_cm_event event;\r\nmemset(&event, 0, sizeof(event));\r\nevent.event = type;\r\nevent.status = status;\r\nswitch (type) {\r\ncase IW_CM_EVENT_CONNECT_REQUEST:\r\nif (cm_node->ipv4)\r\ni40iw_fill_sockaddr4(cm_node, &event);\r\nelse\r\ni40iw_fill_sockaddr6(cm_node, &event);\r\nevent.provider_data = (void *)cm_node;\r\nevent.private_data = (void *)cm_node->pdata_buf;\r\nevent.private_data_len = (u8)cm_node->pdata.size;\r\nevent.ird = cm_node->ird_size;\r\nbreak;\r\ncase IW_CM_EVENT_CONNECT_REPLY:\r\ni40iw_get_cmevent_info(cm_node, cm_id, &event);\r\nbreak;\r\ncase IW_CM_EVENT_ESTABLISHED:\r\nevent.ird = cm_node->ird_size;\r\nevent.ord = cm_node->ord_size;\r\nbreak;\r\ncase IW_CM_EVENT_DISCONNECT:\r\nbreak;\r\ncase IW_CM_EVENT_CLOSE:\r\nbreak;\r\ndefault:\r\ni40iw_pr_err("event type received type = %d\n", type);\r\nreturn -1;\r\n}\r\nreturn cm_id->event_handler(cm_id, &event);\r\n}\r\nstatic struct i40iw_cm_event *i40iw_create_event(struct i40iw_cm_node *cm_node,\r\nenum i40iw_cm_event_type type)\r\n{\r\nstruct i40iw_cm_event *event;\r\nif (!cm_node->cm_id)\r\nreturn NULL;\r\nevent = kzalloc(sizeof(*event), GFP_ATOMIC);\r\nif (!event)\r\nreturn NULL;\r\nevent->type = type;\r\nevent->cm_node = cm_node;\r\nmemcpy(event->cm_info.rem_addr, cm_node->rem_addr, sizeof(event->cm_info.rem_addr));\r\nmemcpy(event->cm_info.loc_addr, cm_node->loc_addr, sizeof(event->cm_info.loc_addr));\r\nevent->cm_info.rem_port = cm_node->rem_port;\r\nevent->cm_info.loc_port = cm_node->loc_port;\r\nevent->cm_info.cm_id = cm_node->cm_id;\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"node=%p event=%p type=%u dst=%pI4 src=%pI4\n",\r\ncm_node,\r\nevent,\r\ntype,\r\nevent->cm_info.loc_addr,\r\nevent->cm_info.rem_addr);\r\ni40iw_cm_post_event(event);\r\nreturn event;\r\n}\r\nstatic void i40iw_free_retrans_entry(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_device *iwdev = cm_node->iwdev;\r\nstruct i40iw_timer_entry *send_entry;\r\nsend_entry = cm_node->send_entry;\r\nif (send_entry) {\r\ncm_node->send_entry = NULL;\r\ni40iw_free_sqbuf(&iwdev->vsi, (void *)send_entry->sqbuf);\r\nkfree(send_entry);\r\natomic_dec(&cm_node->ref_count);\r\n}\r\n}\r\nstatic void i40iw_cleanup_retrans_entry(struct i40iw_cm_node *cm_node)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\ni40iw_free_retrans_entry(cm_node);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\n}\r\nstatic struct i40iw_puda_buf *i40iw_form_cm_frame(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_kmem_info *options,\r\nstruct i40iw_kmem_info *hdr,\r\nstruct i40iw_kmem_info *pdata,\r\nu8 flags)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nstruct i40iw_sc_vsi *vsi = &cm_node->iwdev->vsi;\r\nu8 *buf;\r\nstruct tcphdr *tcph;\r\nstruct iphdr *iph;\r\nstruct ipv6hdr *ip6h;\r\nstruct ethhdr *ethh;\r\nu16 packetsize;\r\nu16 eth_hlen = ETH_HLEN;\r\nu32 opts_len = 0;\r\nu32 pd_len = 0;\r\nu32 hdr_len = 0;\r\nu16 vtag;\r\nsqbuf = i40iw_puda_get_bufpool(vsi->ilq);\r\nif (!sqbuf)\r\nreturn NULL;\r\nbuf = sqbuf->mem.va;\r\nif (options)\r\nopts_len = (u32)options->size;\r\nif (hdr)\r\nhdr_len = hdr->size;\r\nif (pdata)\r\npd_len = pdata->size;\r\nif (cm_node->vlan_id < VLAN_TAG_PRESENT)\r\neth_hlen += 4;\r\nif (cm_node->ipv4)\r\npacketsize = sizeof(*iph) + sizeof(*tcph);\r\nelse\r\npacketsize = sizeof(*ip6h) + sizeof(*tcph);\r\npacketsize += opts_len + hdr_len + pd_len;\r\nmemset(buf, 0x00, eth_hlen + packetsize);\r\nsqbuf->totallen = packetsize + eth_hlen;\r\nsqbuf->maclen = eth_hlen;\r\nsqbuf->tcphlen = sizeof(*tcph) + opts_len;\r\nsqbuf->scratch = (void *)cm_node;\r\nethh = (struct ethhdr *)buf;\r\nbuf += eth_hlen;\r\nif (cm_node->ipv4) {\r\nsqbuf->ipv4 = true;\r\niph = (struct iphdr *)buf;\r\nbuf += sizeof(*iph);\r\ntcph = (struct tcphdr *)buf;\r\nbuf += sizeof(*tcph);\r\nether_addr_copy(ethh->h_dest, cm_node->rem_mac);\r\nether_addr_copy(ethh->h_source, cm_node->loc_mac);\r\nif (cm_node->vlan_id < VLAN_TAG_PRESENT) {\r\n((struct vlan_ethhdr *)ethh)->h_vlan_proto = htons(ETH_P_8021Q);\r\nvtag = (cm_node->user_pri << VLAN_PRIO_SHIFT) | cm_node->vlan_id;\r\n((struct vlan_ethhdr *)ethh)->h_vlan_TCI = htons(vtag);\r\n((struct vlan_ethhdr *)ethh)->h_vlan_encapsulated_proto = htons(ETH_P_IP);\r\n} else {\r\nethh->h_proto = htons(ETH_P_IP);\r\n}\r\niph->version = IPVERSION;\r\niph->ihl = 5;\r\niph->tos = cm_node->tos;\r\niph->tot_len = htons(packetsize);\r\niph->id = htons(++cm_node->tcp_cntxt.loc_id);\r\niph->frag_off = htons(0x4000);\r\niph->ttl = 0x40;\r\niph->protocol = IPPROTO_TCP;\r\niph->saddr = htonl(cm_node->loc_addr[0]);\r\niph->daddr = htonl(cm_node->rem_addr[0]);\r\n} else {\r\nsqbuf->ipv4 = false;\r\nip6h = (struct ipv6hdr *)buf;\r\nbuf += sizeof(*ip6h);\r\ntcph = (struct tcphdr *)buf;\r\nbuf += sizeof(*tcph);\r\nether_addr_copy(ethh->h_dest, cm_node->rem_mac);\r\nether_addr_copy(ethh->h_source, cm_node->loc_mac);\r\nif (cm_node->vlan_id < VLAN_TAG_PRESENT) {\r\n((struct vlan_ethhdr *)ethh)->h_vlan_proto = htons(ETH_P_8021Q);\r\nvtag = (cm_node->user_pri << VLAN_PRIO_SHIFT) | cm_node->vlan_id;\r\n((struct vlan_ethhdr *)ethh)->h_vlan_TCI = htons(vtag);\r\n((struct vlan_ethhdr *)ethh)->h_vlan_encapsulated_proto = htons(ETH_P_IPV6);\r\n} else {\r\nethh->h_proto = htons(ETH_P_IPV6);\r\n}\r\nip6h->version = 6;\r\nip6h->priority = cm_node->tos >> 4;\r\nip6h->flow_lbl[0] = cm_node->tos << 4;\r\nip6h->flow_lbl[1] = 0;\r\nip6h->flow_lbl[2] = 0;\r\nip6h->payload_len = htons(packetsize - sizeof(*ip6h));\r\nip6h->nexthdr = 6;\r\nip6h->hop_limit = 128;\r\ni40iw_copy_ip_htonl(ip6h->saddr.in6_u.u6_addr32,\r\ncm_node->loc_addr);\r\ni40iw_copy_ip_htonl(ip6h->daddr.in6_u.u6_addr32,\r\ncm_node->rem_addr);\r\n}\r\ntcph->source = htons(cm_node->loc_port);\r\ntcph->dest = htons(cm_node->rem_port);\r\ntcph->seq = htonl(cm_node->tcp_cntxt.loc_seq_num);\r\nif (flags & SET_ACK) {\r\ncm_node->tcp_cntxt.loc_ack_num = cm_node->tcp_cntxt.rcv_nxt;\r\ntcph->ack_seq = htonl(cm_node->tcp_cntxt.loc_ack_num);\r\ntcph->ack = 1;\r\n} else {\r\ntcph->ack_seq = 0;\r\n}\r\nif (flags & SET_SYN) {\r\ncm_node->tcp_cntxt.loc_seq_num++;\r\ntcph->syn = 1;\r\n} else {\r\ncm_node->tcp_cntxt.loc_seq_num += hdr_len + pd_len;\r\n}\r\nif (flags & SET_FIN) {\r\ncm_node->tcp_cntxt.loc_seq_num++;\r\ntcph->fin = 1;\r\n}\r\nif (flags & SET_RST)\r\ntcph->rst = 1;\r\ntcph->doff = (u16)((sizeof(*tcph) + opts_len + 3) >> 2);\r\nsqbuf->tcphlen = tcph->doff << 2;\r\ntcph->window = htons(cm_node->tcp_cntxt.rcv_wnd);\r\ntcph->urg_ptr = 0;\r\nif (opts_len) {\r\nmemcpy(buf, options->addr, opts_len);\r\nbuf += opts_len;\r\n}\r\nif (hdr_len) {\r\nmemcpy(buf, hdr->addr, hdr_len);\r\nbuf += hdr_len;\r\n}\r\nif (pdata && pdata->addr)\r\nmemcpy(buf, pdata->addr, pdata->size);\r\natomic_set(&sqbuf->refcount, 1);\r\nreturn sqbuf;\r\n}\r\nstatic int i40iw_send_reset(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nint flags = SET_RST | SET_ACK;\r\nsqbuf = i40iw_form_cm_frame(cm_node, NULL, NULL, NULL, flags);\r\nif (!sqbuf) {\r\ni40iw_pr_err("no sqbuf\n");\r\nreturn -1;\r\n}\r\nreturn i40iw_schedule_cm_timer(cm_node, sqbuf, I40IW_TIMER_TYPE_SEND, 0, 1);\r\n}\r\nstatic void i40iw_active_open_err(struct i40iw_cm_node *cm_node, bool reset)\r\n{\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->cm_core->stats_connect_errs++;\r\nif (reset) {\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"%s cm_node=%p state=%d\n",\r\n__func__,\r\ncm_node,\r\ncm_node->state);\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\n}\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_create_event(cm_node, I40IW_CM_EVENT_ABORTED);\r\n}\r\nstatic void i40iw_passive_open_err(struct i40iw_cm_node *cm_node, bool reset)\r\n{\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->cm_core->stats_passive_errs++;\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"%s cm_node=%p state =%d\n",\r\n__func__,\r\ncm_node,\r\ncm_node->state);\r\nif (reset)\r\ni40iw_send_reset(cm_node);\r\nelse\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\nstatic void i40iw_event_connect_error(struct i40iw_cm_event *event)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nstruct iw_cm_id *cm_id;\r\ncm_id = event->cm_node->cm_id;\r\nif (!cm_id)\r\nreturn;\r\niwqp = cm_id->provider_data;\r\nif (!iwqp || !iwqp->iwdev)\r\nreturn;\r\niwqp->cm_id = NULL;\r\ncm_id->provider_data = NULL;\r\ni40iw_send_cm_event(event->cm_node, cm_id,\r\nIW_CM_EVENT_CONNECT_REPLY,\r\n-ECONNRESET);\r\ncm_id->rem_ref(cm_id);\r\ni40iw_rem_ref_cm_node(event->cm_node);\r\n}\r\nstatic int i40iw_process_options(struct i40iw_cm_node *cm_node,\r\nu8 *optionsloc,\r\nu32 optionsize,\r\nu32 syn_packet)\r\n{\r\nu32 tmp;\r\nu32 offset = 0;\r\nunion all_known_options *all_options;\r\nchar got_mss_option = 0;\r\nwhile (offset < optionsize) {\r\nall_options = (union all_known_options *)(optionsloc + offset);\r\nswitch (all_options->as_base.optionnum) {\r\ncase OPTION_NUMBER_END:\r\noffset = optionsize;\r\nbreak;\r\ncase OPTION_NUMBER_NONE:\r\noffset += 1;\r\ncontinue;\r\ncase OPTION_NUMBER_MSS:\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"%s: MSS Length: %d Offset: %d Size: %d\n",\r\n__func__,\r\nall_options->as_mss.length,\r\noffset,\r\noptionsize);\r\ngot_mss_option = 1;\r\nif (all_options->as_mss.length != 4)\r\nreturn -1;\r\ntmp = ntohs(all_options->as_mss.mss);\r\nif (tmp > 0 && tmp < cm_node->tcp_cntxt.mss)\r\ncm_node->tcp_cntxt.mss = tmp;\r\nbreak;\r\ncase OPTION_NUMBER_WINDOW_SCALE:\r\ncm_node->tcp_cntxt.snd_wscale =\r\nall_options->as_windowscale.shiftcount;\r\nbreak;\r\ndefault:\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"TCP Option not understood: %x\n",\r\nall_options->as_base.optionnum);\r\nbreak;\r\n}\r\noffset += all_options->as_base.length;\r\n}\r\nif (!got_mss_option && syn_packet)\r\ncm_node->tcp_cntxt.mss = I40IW_CM_DEFAULT_MSS;\r\nreturn 0;\r\n}\r\nstatic int i40iw_handle_tcp_options(struct i40iw_cm_node *cm_node,\r\nstruct tcphdr *tcph,\r\nint optionsize,\r\nint passive)\r\n{\r\nu8 *optionsloc = (u8 *)&tcph[1];\r\nif (optionsize) {\r\nif (i40iw_process_options(cm_node,\r\noptionsloc,\r\noptionsize,\r\n(u32)tcph->syn)) {\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"%s: Node %p, Sending RESET\n",\r\n__func__,\r\ncm_node);\r\nif (passive)\r\ni40iw_passive_open_err(cm_node, true);\r\nelse\r\ni40iw_active_open_err(cm_node, true);\r\nreturn -1;\r\n}\r\n}\r\ncm_node->tcp_cntxt.snd_wnd = ntohs(tcph->window) <<\r\ncm_node->tcp_cntxt.snd_wscale;\r\nif (cm_node->tcp_cntxt.snd_wnd > cm_node->tcp_cntxt.max_snd_wnd)\r\ncm_node->tcp_cntxt.max_snd_wnd = cm_node->tcp_cntxt.snd_wnd;\r\nreturn 0;\r\n}\r\nstatic void i40iw_build_mpa_v1(struct i40iw_cm_node *cm_node,\r\nvoid *start_addr,\r\nu8 mpa_key)\r\n{\r\nstruct ietf_mpa_v1 *mpa_frame = (struct ietf_mpa_v1 *)start_addr;\r\nswitch (mpa_key) {\r\ncase MPA_KEY_REQUEST:\r\nmemcpy(mpa_frame->key, IEFT_MPA_KEY_REQ, IETF_MPA_KEY_SIZE);\r\nbreak;\r\ncase MPA_KEY_REPLY:\r\nmemcpy(mpa_frame->key, IEFT_MPA_KEY_REP, IETF_MPA_KEY_SIZE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmpa_frame->flags = IETF_MPA_FLAGS_CRC;\r\nmpa_frame->rev = cm_node->mpa_frame_rev;\r\nmpa_frame->priv_data_len = htons(cm_node->pdata.size);\r\n}\r\nstatic void i40iw_build_mpa_v2(struct i40iw_cm_node *cm_node,\r\nvoid *start_addr,\r\nu8 mpa_key)\r\n{\r\nstruct ietf_mpa_v2 *mpa_frame = (struct ietf_mpa_v2 *)start_addr;\r\nstruct ietf_rtr_msg *rtr_msg = &mpa_frame->rtr_msg;\r\nu16 ctrl_ird, ctrl_ord;\r\ni40iw_build_mpa_v1(cm_node, start_addr, mpa_key);\r\nmpa_frame->flags |= IETF_MPA_V2_FLAG;\r\nmpa_frame->priv_data_len += htons(IETF_RTR_MSG_SIZE);\r\nif (cm_node->mpav2_ird_ord == IETF_NO_IRD_ORD) {\r\nctrl_ird = IETF_NO_IRD_ORD;\r\nctrl_ord = IETF_NO_IRD_ORD;\r\n} else {\r\nctrl_ird = (cm_node->ird_size > IETF_NO_IRD_ORD) ?\r\nIETF_NO_IRD_ORD : cm_node->ird_size;\r\nctrl_ord = (cm_node->ord_size > IETF_NO_IRD_ORD) ?\r\nIETF_NO_IRD_ORD : cm_node->ord_size;\r\n}\r\nctrl_ird |= IETF_PEER_TO_PEER;\r\nctrl_ird |= IETF_FLPDU_ZERO_LEN;\r\nswitch (mpa_key) {\r\ncase MPA_KEY_REQUEST:\r\nctrl_ord |= IETF_RDMA0_WRITE;\r\nctrl_ord |= IETF_RDMA0_READ;\r\nbreak;\r\ncase MPA_KEY_REPLY:\r\nswitch (cm_node->send_rdma0_op) {\r\ncase SEND_RDMA_WRITE_ZERO:\r\nctrl_ord |= IETF_RDMA0_WRITE;\r\nbreak;\r\ncase SEND_RDMA_READ_ZERO:\r\nctrl_ord |= IETF_RDMA0_READ;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrtr_msg->ctrl_ird = htons(ctrl_ird);\r\nrtr_msg->ctrl_ord = htons(ctrl_ord);\r\n}\r\nstatic int i40iw_cm_build_mpa_frame(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_kmem_info *mpa,\r\nu8 mpa_key)\r\n{\r\nint hdr_len = 0;\r\nswitch (cm_node->mpa_frame_rev) {\r\ncase IETF_MPA_V1:\r\nhdr_len = sizeof(struct ietf_mpa_v1);\r\ni40iw_build_mpa_v1(cm_node, mpa->addr, mpa_key);\r\nbreak;\r\ncase IETF_MPA_V2:\r\nhdr_len = sizeof(struct ietf_mpa_v2);\r\ni40iw_build_mpa_v2(cm_node, mpa->addr, mpa_key);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn hdr_len;\r\n}\r\nstatic int i40iw_send_mpa_request(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nif (!cm_node) {\r\ni40iw_pr_err("cm_node == NULL\n");\r\nreturn -1;\r\n}\r\ncm_node->mpa_hdr.addr = &cm_node->mpa_frame;\r\ncm_node->mpa_hdr.size = i40iw_cm_build_mpa_frame(cm_node,\r\n&cm_node->mpa_hdr,\r\nMPA_KEY_REQUEST);\r\nif (!cm_node->mpa_hdr.size) {\r\ni40iw_pr_err("mpa size = %d\n", cm_node->mpa_hdr.size);\r\nreturn -1;\r\n}\r\nsqbuf = i40iw_form_cm_frame(cm_node,\r\nNULL,\r\n&cm_node->mpa_hdr,\r\n&cm_node->pdata,\r\nSET_ACK);\r\nif (!sqbuf) {\r\ni40iw_pr_err("sq_buf == NULL\n");\r\nreturn -1;\r\n}\r\nreturn i40iw_schedule_cm_timer(cm_node, sqbuf, I40IW_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstatic int i40iw_send_mpa_reject(struct i40iw_cm_node *cm_node,\r\nconst void *pdata,\r\nu8 plen)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nstruct i40iw_kmem_info priv_info;\r\ncm_node->mpa_hdr.addr = &cm_node->mpa_frame;\r\ncm_node->mpa_hdr.size = i40iw_cm_build_mpa_frame(cm_node,\r\n&cm_node->mpa_hdr,\r\nMPA_KEY_REPLY);\r\ncm_node->mpa_frame.flags |= IETF_MPA_FLAGS_REJECT;\r\npriv_info.addr = (void *)pdata;\r\npriv_info.size = plen;\r\nsqbuf = i40iw_form_cm_frame(cm_node,\r\nNULL,\r\n&cm_node->mpa_hdr,\r\n&priv_info,\r\nSET_ACK | SET_FIN);\r\nif (!sqbuf) {\r\ni40iw_pr_err("no sqbuf\n");\r\nreturn -ENOMEM;\r\n}\r\ncm_node->state = I40IW_CM_STATE_FIN_WAIT1;\r\nreturn i40iw_schedule_cm_timer(cm_node, sqbuf, I40IW_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstatic int i40iw_parse_mpa(struct i40iw_cm_node *cm_node, u8 *buffer, u32 *type, u32 len)\r\n{\r\nstruct ietf_mpa_v1 *mpa_frame;\r\nstruct ietf_mpa_v2 *mpa_v2_frame;\r\nstruct ietf_rtr_msg *rtr_msg;\r\nint mpa_hdr_len;\r\nint priv_data_len;\r\n*type = I40IW_MPA_REQUEST_ACCEPT;\r\nif (len < sizeof(struct ietf_mpa_v1)) {\r\ni40iw_pr_err("ietf buffer small (%x)\n", len);\r\nreturn -1;\r\n}\r\nmpa_frame = (struct ietf_mpa_v1 *)buffer;\r\nmpa_hdr_len = sizeof(struct ietf_mpa_v1);\r\npriv_data_len = ntohs(mpa_frame->priv_data_len);\r\nif (priv_data_len > IETF_MAX_PRIV_DATA_LEN) {\r\ni40iw_pr_err("large pri_data %d\n", priv_data_len);\r\nreturn -1;\r\n}\r\nif (mpa_frame->rev != IETF_MPA_V1 && mpa_frame->rev != IETF_MPA_V2) {\r\ni40iw_pr_err("unsupported mpa rev = %d\n", mpa_frame->rev);\r\nreturn -1;\r\n}\r\nif (mpa_frame->rev > cm_node->mpa_frame_rev) {\r\ni40iw_pr_err("rev %d\n", mpa_frame->rev);\r\nreturn -1;\r\n}\r\ncm_node->mpa_frame_rev = mpa_frame->rev;\r\nif (cm_node->state != I40IW_CM_STATE_MPAREQ_SENT) {\r\nif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REQ, IETF_MPA_KEY_SIZE)) {\r\ni40iw_pr_err("Unexpected MPA Key received\n");\r\nreturn -1;\r\n}\r\n} else {\r\nif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REP, IETF_MPA_KEY_SIZE)) {\r\ni40iw_pr_err("Unexpected MPA Key received\n");\r\nreturn -1;\r\n}\r\n}\r\nif (priv_data_len + mpa_hdr_len > len) {\r\ni40iw_pr_err("ietf buffer len(%x + %x != %x)\n",\r\npriv_data_len, mpa_hdr_len, len);\r\nreturn -1;\r\n}\r\nif (len > MAX_CM_BUFFER) {\r\ni40iw_pr_err("ietf buffer large len = %d\n", len);\r\nreturn -1;\r\n}\r\nswitch (mpa_frame->rev) {\r\ncase IETF_MPA_V2:{\r\nu16 ird_size;\r\nu16 ord_size;\r\nu16 ctrl_ord;\r\nu16 ctrl_ird;\r\nmpa_v2_frame = (struct ietf_mpa_v2 *)buffer;\r\nmpa_hdr_len += IETF_RTR_MSG_SIZE;\r\nrtr_msg = &mpa_v2_frame->rtr_msg;\r\nctrl_ord = ntohs(rtr_msg->ctrl_ord);\r\nctrl_ird = ntohs(rtr_msg->ctrl_ird);\r\nird_size = ctrl_ird & IETF_NO_IRD_ORD;\r\nord_size = ctrl_ord & IETF_NO_IRD_ORD;\r\nif (!(ctrl_ird & IETF_PEER_TO_PEER))\r\nreturn -1;\r\nif (ird_size == IETF_NO_IRD_ORD || ord_size == IETF_NO_IRD_ORD) {\r\ncm_node->mpav2_ird_ord = IETF_NO_IRD_ORD;\r\ngoto negotiate_done;\r\n}\r\nif (cm_node->state != I40IW_CM_STATE_MPAREQ_SENT) {\r\nif (!ord_size && (ctrl_ord & IETF_RDMA0_READ))\r\ncm_node->ird_size = 1;\r\nif (cm_node->ord_size > ird_size)\r\ncm_node->ord_size = ird_size;\r\n} else {\r\nif (!ird_size && (ctrl_ord & IETF_RDMA0_READ))\r\nreturn -1;\r\nif (cm_node->ord_size > ird_size)\r\ncm_node->ord_size = ird_size;\r\nif (cm_node->ird_size < ord_size)\r\nreturn -1;\r\n}\r\nnegotiate_done:\r\nif (ctrl_ord & IETF_RDMA0_READ)\r\ncm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\r\nelse if (ctrl_ord & IETF_RDMA0_WRITE)\r\ncm_node->send_rdma0_op = SEND_RDMA_WRITE_ZERO;\r\nelse\r\nreturn -1;\r\ni40iw_debug(cm_node->dev, I40IW_DEBUG_CM,\r\n"MPAV2: Negotiated ORD: %d, IRD: %d\n",\r\ncm_node->ord_size, cm_node->ird_size);\r\nbreak;\r\n}\r\nbreak;\r\ncase IETF_MPA_V1:\r\ndefault:\r\nbreak;\r\n}\r\nmemcpy(cm_node->pdata_buf, buffer + mpa_hdr_len, priv_data_len);\r\ncm_node->pdata.size = priv_data_len;\r\nif (mpa_frame->flags & IETF_MPA_FLAGS_REJECT)\r\n*type = I40IW_MPA_REQUEST_REJECT;\r\nif (mpa_frame->flags & IETF_MPA_FLAGS_MARKERS)\r\ncm_node->snd_mark_en = true;\r\nreturn 0;\r\n}\r\nint i40iw_schedule_cm_timer(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *sqbuf,\r\nenum i40iw_timer_type type,\r\nint send_retrans,\r\nint close_when_complete)\r\n{\r\nstruct i40iw_sc_vsi *vsi = &cm_node->iwdev->vsi;\r\nstruct i40iw_cm_core *cm_core = cm_node->cm_core;\r\nstruct i40iw_timer_entry *new_send;\r\nint ret = 0;\r\nu32 was_timer_set;\r\nunsigned long flags;\r\nnew_send = kzalloc(sizeof(*new_send), GFP_ATOMIC);\r\nif (!new_send) {\r\ni40iw_free_sqbuf(vsi, (void *)sqbuf);\r\nreturn -ENOMEM;\r\n}\r\nnew_send->retrycount = I40IW_DEFAULT_RETRYS;\r\nnew_send->retranscount = I40IW_DEFAULT_RETRANS;\r\nnew_send->sqbuf = sqbuf;\r\nnew_send->timetosend = jiffies;\r\nnew_send->type = type;\r\nnew_send->send_retrans = send_retrans;\r\nnew_send->close_when_complete = close_when_complete;\r\nif (type == I40IW_TIMER_TYPE_CLOSE) {\r\nnew_send->timetosend += (HZ / 10);\r\nif (cm_node->close_entry) {\r\nkfree(new_send);\r\ni40iw_free_sqbuf(vsi, (void *)sqbuf);\r\ni40iw_pr_err("already close entry\n");\r\nreturn -EINVAL;\r\n}\r\ncm_node->close_entry = new_send;\r\n}\r\nif (type == I40IW_TIMER_TYPE_SEND) {\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\ncm_node->send_entry = new_send;\r\natomic_inc(&cm_node->ref_count);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\nnew_send->timetosend = jiffies + I40IW_RETRY_TIMEOUT;\r\natomic_inc(&sqbuf->refcount);\r\ni40iw_puda_send_buf(vsi->ilq, sqbuf);\r\nif (!send_retrans) {\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nif (close_when_complete)\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn ret;\r\n}\r\n}\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nwas_timer_set = timer_pending(&cm_core->tcp_timer);\r\nif (!was_timer_set) {\r\ncm_core->tcp_timer.expires = new_send->timetosend;\r\nadd_timer(&cm_core->tcp_timer);\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void i40iw_retrans_expired(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nenum i40iw_cm_node_state state = cm_node->state;\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\nswitch (state) {\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ncase I40IW_CM_STATE_CLOSING:\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncase I40IW_CM_STATE_LAST_ACK:\r\nif (cm_node->cm_id)\r\ncm_id->rem_ref(cm_id);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ndefault:\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\ni40iw_create_event(cm_node, I40IW_CM_EVENT_ABORTED);\r\nbreak;\r\n}\r\n}\r\nstatic void i40iw_handle_close_entry(struct i40iw_cm_node *cm_node, u32 rem_node)\r\n{\r\nstruct i40iw_timer_entry *close_entry = cm_node->close_entry;\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nstruct i40iw_qp *iwqp;\r\nunsigned long flags;\r\nif (!close_entry)\r\nreturn;\r\niwqp = (struct i40iw_qp *)close_entry->sqbuf;\r\nif (iwqp) {\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\nif (iwqp->cm_id) {\r\niwqp->hw_tcp_state = I40IW_TCP_STATE_CLOSED;\r\niwqp->hw_iwarp_state = I40IW_QP_STATE_ERROR;\r\niwqp->last_aeq = I40IW_AE_RESET_SENT;\r\niwqp->ibqp_state = IB_QPS_ERR;\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\ni40iw_cm_disconn(iwqp);\r\n} else {\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\n}\r\n} else if (rem_node) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\nif (cm_id)\r\ncm_id->rem_ref(cm_id);\r\nkfree(close_entry);\r\ncm_node->close_entry = NULL;\r\n}\r\nstatic void i40iw_cm_timer_tick(unsigned long pass)\r\n{\r\nunsigned long nexttimeout = jiffies + I40IW_LONG_TIME;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_timer_entry *send_entry, *close_entry;\r\nstruct list_head *list_core_temp;\r\nstruct i40iw_sc_vsi *vsi;\r\nstruct list_head *list_node;\r\nstruct i40iw_cm_core *cm_core = (struct i40iw_cm_core *)pass;\r\nu32 settimer = 0;\r\nunsigned long timetosend;\r\nstruct i40iw_sc_dev *dev;\r\nunsigned long flags;\r\nstruct list_head timer_list;\r\nINIT_LIST_HEAD(&timer_list);\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp, &cm_core->connected_nodes) {\r\ncm_node = container_of(list_node, struct i40iw_cm_node, list);\r\nif (cm_node->close_entry || cm_node->send_entry) {\r\natomic_inc(&cm_node->ref_count);\r\nlist_add(&cm_node->timer_entry, &timer_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp, &timer_list) {\r\ncm_node = container_of(list_node,\r\nstruct i40iw_cm_node,\r\ntimer_entry);\r\nclose_entry = cm_node->close_entry;\r\nif (close_entry) {\r\nif (time_after(close_entry->timetosend, jiffies)) {\r\nif (nexttimeout > close_entry->timetosend ||\r\n!settimer) {\r\nnexttimeout = close_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\ni40iw_handle_close_entry(cm_node, 1);\r\n}\r\n}\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\nsend_entry = cm_node->send_entry;\r\nif (!send_entry)\r\ngoto done;\r\nif (time_after(send_entry->timetosend, jiffies)) {\r\nif (cm_node->state != I40IW_CM_STATE_OFFLOADED) {\r\nif ((nexttimeout > send_entry->timetosend) ||\r\n!settimer) {\r\nnexttimeout = send_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\ni40iw_free_retrans_entry(cm_node);\r\n}\r\ngoto done;\r\n}\r\nif ((cm_node->state == I40IW_CM_STATE_OFFLOADED) ||\r\n(cm_node->state == I40IW_CM_STATE_CLOSED)) {\r\ni40iw_free_retrans_entry(cm_node);\r\ngoto done;\r\n}\r\nif (!send_entry->retranscount || !send_entry->retrycount) {\r\ni40iw_free_retrans_entry(cm_node);\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\ni40iw_retrans_expired(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\ngoto done;\r\n}\r\ncm_node->cm_core->stats_pkt_retrans++;\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\nvsi = &cm_node->iwdev->vsi;\r\ndev = cm_node->dev;\r\natomic_inc(&send_entry->sqbuf->refcount);\r\ni40iw_puda_send_buf(vsi->ilq, send_entry->sqbuf);\r\nspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\r\nif (send_entry->send_retrans) {\r\nsend_entry->retranscount--;\r\ntimetosend = (I40IW_RETRY_TIMEOUT <<\r\n(I40IW_DEFAULT_RETRANS -\r\nsend_entry->retranscount));\r\nsend_entry->timetosend = jiffies +\r\nmin(timetosend, I40IW_MAX_TIMEOUT);\r\nif (nexttimeout > send_entry->timetosend || !settimer) {\r\nnexttimeout = send_entry->timetosend;\r\nsettimer = 1;\r\n}\r\n} else {\r\nint close_when_complete;\r\nclose_when_complete = send_entry->close_when_complete;\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"cm_node=%p state=%d\n",\r\ncm_node,\r\ncm_node->state);\r\ni40iw_free_retrans_entry(cm_node);\r\nif (close_when_complete)\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\nif (settimer) {\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nif (!timer_pending(&cm_core->tcp_timer)) {\r\ncm_core->tcp_timer.expires = nexttimeout;\r\nadd_timer(&cm_core->tcp_timer);\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\n}\r\n}\r\nint i40iw_send_syn(struct i40iw_cm_node *cm_node, u32 sendack)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nint flags = SET_SYN;\r\nchar optionsbuffer[sizeof(struct option_mss) +\r\nsizeof(struct option_windowscale) +\r\nsizeof(struct option_base) + TCP_OPTIONS_PADDING];\r\nstruct i40iw_kmem_info opts;\r\nint optionssize = 0;\r\nunion all_known_options *options;\r\nopts.addr = optionsbuffer;\r\nif (!cm_node) {\r\ni40iw_pr_err("no cm_node\n");\r\nreturn -EINVAL;\r\n}\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_mss.optionnum = OPTION_NUMBER_MSS;\r\noptions->as_mss.length = sizeof(struct option_mss);\r\noptions->as_mss.mss = htons(cm_node->tcp_cntxt.mss);\r\noptionssize += sizeof(struct option_mss);\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_windowscale.optionnum = OPTION_NUMBER_WINDOW_SCALE;\r\noptions->as_windowscale.length = sizeof(struct option_windowscale);\r\noptions->as_windowscale.shiftcount = cm_node->tcp_cntxt.rcv_wscale;\r\noptionssize += sizeof(struct option_windowscale);\r\noptions = (union all_known_options *)&optionsbuffer[optionssize];\r\noptions->as_end = OPTION_NUMBER_END;\r\noptionssize += 1;\r\nif (sendack)\r\nflags |= SET_ACK;\r\nopts.size = optionssize;\r\nsqbuf = i40iw_form_cm_frame(cm_node, &opts, NULL, NULL, flags);\r\nif (!sqbuf) {\r\ni40iw_pr_err("no sqbuf\n");\r\nreturn -1;\r\n}\r\nreturn i40iw_schedule_cm_timer(cm_node, sqbuf, I40IW_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstatic void i40iw_send_ack(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nstruct i40iw_sc_vsi *vsi = &cm_node->iwdev->vsi;\r\nsqbuf = i40iw_form_cm_frame(cm_node, NULL, NULL, NULL, SET_ACK);\r\nif (sqbuf)\r\ni40iw_puda_send_buf(vsi->ilq, sqbuf);\r\nelse\r\ni40iw_pr_err("no sqbuf\n");\r\n}\r\nstatic int i40iw_send_fin(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_puda_buf *sqbuf;\r\nsqbuf = i40iw_form_cm_frame(cm_node, NULL, NULL, NULL, SET_ACK | SET_FIN);\r\nif (!sqbuf) {\r\ni40iw_pr_err("no sqbuf\n");\r\nreturn -1;\r\n}\r\nreturn i40iw_schedule_cm_timer(cm_node, sqbuf, I40IW_TIMER_TYPE_SEND, 1, 0);\r\n}\r\nstruct i40iw_cm_node *i40iw_find_node(struct i40iw_cm_core *cm_core,\r\nu16 rem_port,\r\nu32 *rem_addr,\r\nu16 loc_port,\r\nu32 *loc_addr,\r\nbool add_refcnt)\r\n{\r\nstruct list_head *hte;\r\nstruct i40iw_cm_node *cm_node;\r\nunsigned long flags;\r\nhte = &cm_core->connected_nodes;\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_entry(cm_node, hte, list) {\r\nif (!memcmp(cm_node->loc_addr, loc_addr, sizeof(cm_node->loc_addr)) &&\r\n(cm_node->loc_port == loc_port) &&\r\n!memcmp(cm_node->rem_addr, rem_addr, sizeof(cm_node->rem_addr)) &&\r\n(cm_node->rem_port == rem_port)) {\r\nif (add_refcnt)\r\natomic_inc(&cm_node->ref_count);\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn cm_node;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic struct i40iw_cm_listener *i40iw_find_listener(\r\nstruct i40iw_cm_core *cm_core,\r\nu32 *dst_addr,\r\nu16 dst_port,\r\nu16 vlan_id,\r\nenum i40iw_cm_listener_state\r\nlistener_state)\r\n{\r\nstruct i40iw_cm_listener *listen_node;\r\nstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\r\nu32 listen_addr[4];\r\nu16 listen_port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_for_each_entry(listen_node, &cm_core->listen_nodes, list) {\r\nmemcpy(listen_addr, listen_node->loc_addr, sizeof(listen_addr));\r\nlisten_port = listen_node->loc_port;\r\nif ((!memcmp(listen_addr, dst_addr, sizeof(listen_addr)) ||\r\n!memcmp(listen_addr, ip_zero, sizeof(listen_addr))) &&\r\n(listen_port == dst_port) &&\r\n(listener_state & listen_node->listener_state)) {\r\natomic_inc(&listen_node->ref_count);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nreturn listen_node;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void i40iw_add_hte_node(struct i40iw_cm_core *cm_core,\r\nstruct i40iw_cm_node *cm_node)\r\n{\r\nstruct list_head *hte;\r\nunsigned long flags;\r\nif (!cm_node || !cm_core) {\r\ni40iw_pr_err("cm_node or cm_core == NULL\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nhte = &cm_core->connected_nodes;\r\nlist_add_tail(&cm_node->list, hte);\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\n}\r\nstatic bool i40iw_listen_port_in_use(struct i40iw_cm_core *cm_core, u16 port)\r\n{\r\nstruct i40iw_cm_listener *listen_node;\r\nunsigned long flags;\r\nbool ret = false;\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_for_each_entry(listen_node, &cm_core->listen_nodes, list) {\r\nif (listen_node->loc_port == port) {\r\nret = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic enum i40iw_status_code i40iw_del_multiple_qhash(\r\nstruct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cm_info,\r\nstruct i40iw_cm_listener *cm_parent_listen_node)\r\n{\r\nstruct i40iw_cm_listener *child_listen_node;\r\nenum i40iw_status_code ret = I40IW_ERR_CONFIG;\r\nstruct list_head *pos, *tpos;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iwdev->cm_core.listen_list_lock, flags);\r\nlist_for_each_safe(pos, tpos, &cm_parent_listen_node->child_listen_list) {\r\nchild_listen_node = list_entry(pos, struct i40iw_cm_listener, child_listen_list);\r\nif (child_listen_node->ipv4)\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"removing child listen for IP=%pI4, port=%d, vlan=%d\n",\r\nchild_listen_node->loc_addr,\r\nchild_listen_node->loc_port,\r\nchild_listen_node->vlan_id);\r\nelse\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_CM,\r\n"removing child listen for IP=%pI6, port=%d, vlan=%d\n",\r\nchild_listen_node->loc_addr,\r\nchild_listen_node->loc_port,\r\nchild_listen_node->vlan_id);\r\nlist_del(pos);\r\nmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\r\nsizeof(cm_info->loc_addr));\r\ncm_info->vlan_id = child_listen_node->vlan_id;\r\nif (child_listen_node->qhash_set) {\r\nret = i40iw_manage_qhash(iwdev, cm_info,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL, false);\r\nchild_listen_node->qhash_set = false;\r\n} else {\r\nret = I40IW_SUCCESS;\r\n}\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"freed pointer = %p\n",\r\nchild_listen_node);\r\nkfree(child_listen_node);\r\ncm_parent_listen_node->cm_core->stats_listen_nodes_destroyed++;\r\n}\r\nspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct net_device *i40iw_netdev_vlan_ipv6(u32 *addr, u16 *vlan_id, u8 *mac)\r\n{\r\nstruct net_device *ip_dev = NULL;\r\nstruct in6_addr laddr6;\r\nif (!IS_ENABLED(CONFIG_IPV6))\r\nreturn NULL;\r\ni40iw_copy_ip_htonl(laddr6.in6_u.u6_addr32, addr);\r\nif (vlan_id)\r\n*vlan_id = I40IW_NO_VLAN;\r\nif (mac)\r\neth_zero_addr(mac);\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, ip_dev) {\r\nif (ipv6_chk_addr(&init_net, &laddr6, ip_dev, 1)) {\r\nif (vlan_id)\r\n*vlan_id = rdma_vlan_dev_vlan_id(ip_dev);\r\nif (ip_dev->dev_addr && mac)\r\nether_addr_copy(mac, ip_dev->dev_addr);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn ip_dev;\r\n}\r\nstatic u16 i40iw_get_vlan_ipv4(u32 *addr)\r\n{\r\nstruct net_device *netdev;\r\nu16 vlan_id = I40IW_NO_VLAN;\r\nnetdev = ip_dev_find(&init_net, htonl(addr[0]));\r\nif (netdev) {\r\nvlan_id = rdma_vlan_dev_vlan_id(netdev);\r\ndev_put(netdev);\r\n}\r\nreturn vlan_id;\r\n}\r\nstatic enum i40iw_status_code i40iw_add_mqh_6(struct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cm_info,\r\nstruct i40iw_cm_listener *cm_parent_listen_node)\r\n{\r\nstruct net_device *ip_dev;\r\nstruct inet6_dev *idev;\r\nstruct inet6_ifaddr *ifp, *tmp;\r\nenum i40iw_status_code ret = 0;\r\nstruct i40iw_cm_listener *child_listen_node;\r\nunsigned long flags;\r\nrtnl_lock();\r\nfor_each_netdev_rcu(&init_net, ip_dev) {\r\nif ((((rdma_vlan_dev_vlan_id(ip_dev) < I40IW_NO_VLAN) &&\r\n(rdma_vlan_dev_real_dev(ip_dev) == iwdev->netdev)) ||\r\n(ip_dev == iwdev->netdev)) && (ip_dev->flags & IFF_UP)) {\r\nidev = __in6_dev_get(ip_dev);\r\nif (!idev) {\r\ni40iw_pr_err("idev == NULL\n");\r\nbreak;\r\n}\r\nlist_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"IP=%pI6, vlan_id=%d, MAC=%pM\n",\r\n&ifp->addr,\r\nrdma_vlan_dev_vlan_id(ip_dev),\r\nip_dev->dev_addr);\r\nchild_listen_node =\r\nkzalloc(sizeof(*child_listen_node), GFP_ATOMIC);\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"Allocating child listener %p\n",\r\nchild_listen_node);\r\nif (!child_listen_node) {\r\nret = I40IW_ERR_NO_MEMORY;\r\ngoto exit;\r\n}\r\ncm_info->vlan_id = rdma_vlan_dev_vlan_id(ip_dev);\r\ncm_parent_listen_node->vlan_id = cm_info->vlan_id;\r\nmemcpy(child_listen_node, cm_parent_listen_node,\r\nsizeof(*child_listen_node));\r\ni40iw_copy_ip_ntohl(child_listen_node->loc_addr,\r\nifp->addr.in6_u.u6_addr32);\r\nmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\r\nsizeof(cm_info->loc_addr));\r\nret = i40iw_manage_qhash(iwdev, cm_info,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nI40IW_QHASH_MANAGE_TYPE_ADD,\r\nNULL, true);\r\nif (!ret) {\r\nchild_listen_node->qhash_set = true;\r\nspin_lock_irqsave(&iwdev->cm_core.listen_list_lock, flags);\r\nlist_add(&child_listen_node->child_listen_list,\r\n&cm_parent_listen_node->child_listen_list);\r\nspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\r\ncm_parent_listen_node->cm_core->stats_listen_nodes_created++;\r\n} else {\r\nkfree(child_listen_node);\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic enum i40iw_status_code i40iw_add_mqh_4(\r\nstruct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cm_info,\r\nstruct i40iw_cm_listener *cm_parent_listen_node)\r\n{\r\nstruct net_device *dev;\r\nstruct in_device *idev;\r\nstruct i40iw_cm_listener *child_listen_node;\r\nenum i40iw_status_code ret = 0;\r\nunsigned long flags;\r\nrtnl_lock();\r\nfor_each_netdev(&init_net, dev) {\r\nif ((((rdma_vlan_dev_vlan_id(dev) < I40IW_NO_VLAN) &&\r\n(rdma_vlan_dev_real_dev(dev) == iwdev->netdev)) ||\r\n(dev == iwdev->netdev)) && (dev->flags & IFF_UP)) {\r\nidev = in_dev_get(dev);\r\nfor_ifa(idev) {\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"Allocating child CM Listener forIP=%pI4, vlan_id=%d, MAC=%pM\n",\r\n&ifa->ifa_address,\r\nrdma_vlan_dev_vlan_id(dev),\r\ndev->dev_addr);\r\nchild_listen_node = kzalloc(sizeof(*child_listen_node), GFP_ATOMIC);\r\ncm_parent_listen_node->cm_core->stats_listen_nodes_created++;\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"Allocating child listener %p\n",\r\nchild_listen_node);\r\nif (!child_listen_node) {\r\nin_dev_put(idev);\r\nret = I40IW_ERR_NO_MEMORY;\r\ngoto exit;\r\n}\r\ncm_info->vlan_id = rdma_vlan_dev_vlan_id(dev);\r\ncm_parent_listen_node->vlan_id = cm_info->vlan_id;\r\nmemcpy(child_listen_node,\r\ncm_parent_listen_node,\r\nsizeof(*child_listen_node));\r\nchild_listen_node->loc_addr[0] = ntohl(ifa->ifa_address);\r\nmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\r\nsizeof(cm_info->loc_addr));\r\nret = i40iw_manage_qhash(iwdev,\r\ncm_info,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nI40IW_QHASH_MANAGE_TYPE_ADD,\r\nNULL,\r\ntrue);\r\nif (!ret) {\r\nchild_listen_node->qhash_set = true;\r\nspin_lock_irqsave(&iwdev->cm_core.listen_list_lock, flags);\r\nlist_add(&child_listen_node->child_listen_list,\r\n&cm_parent_listen_node->child_listen_list);\r\nspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\r\n} else {\r\nkfree(child_listen_node);\r\ncm_parent_listen_node->cm_core->stats_listen_nodes_created--;\r\n}\r\n}\r\nendfor_ifa(idev);\r\nin_dev_put(idev);\r\n}\r\n}\r\nexit:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int i40iw_dec_refcnt_listen(struct i40iw_cm_core *cm_core,\r\nstruct i40iw_cm_listener *listener,\r\nint free_hanging_nodes, bool apbvt_del)\r\n{\r\nint ret = -EINVAL;\r\nint err = 0;\r\nstruct list_head *list_pos;\r\nstruct list_head *list_temp;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct list_head reset_list;\r\nstruct i40iw_cm_info nfo;\r\nstruct i40iw_cm_node *loopback;\r\nenum i40iw_cm_node_state old_state;\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&reset_list);\r\nif (free_hanging_nodes) {\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_pos, list_temp, &cm_core->connected_nodes) {\r\ncm_node = container_of(list_pos, struct i40iw_cm_node, list);\r\nif ((cm_node->listener == listener) && !cm_node->accelerated) {\r\natomic_inc(&cm_node->ref_count);\r\nlist_add(&cm_node->reset_entry, &reset_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\n}\r\nlist_for_each_safe(list_pos, list_temp, &reset_list) {\r\ncm_node = container_of(list_pos, struct i40iw_cm_node, reset_entry);\r\nloopback = cm_node->loopbackpartner;\r\nif (cm_node->state >= I40IW_CM_STATE_FIN_WAIT1) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\n} else {\r\nif (!loopback) {\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nerr = i40iw_send_reset(cm_node);\r\nif (err) {\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_pr_err("send reset\n");\r\n} else {\r\nold_state = cm_node->state;\r\ncm_node->state = I40IW_CM_STATE_LISTENER_DESTROYED;\r\nif (old_state != I40IW_CM_STATE_MPAREQ_RCVD)\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\n} else {\r\nstruct i40iw_cm_event event;\r\nevent.cm_node = loopback;\r\nmemcpy(event.cm_info.rem_addr,\r\nloopback->rem_addr, sizeof(event.cm_info.rem_addr));\r\nmemcpy(event.cm_info.loc_addr,\r\nloopback->loc_addr, sizeof(event.cm_info.loc_addr));\r\nevent.cm_info.rem_port = loopback->rem_port;\r\nevent.cm_info.loc_port = loopback->loc_port;\r\nevent.cm_info.cm_id = loopback->cm_id;\r\nevent.cm_info.ipv4 = loopback->ipv4;\r\natomic_inc(&loopback->ref_count);\r\nloopback->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_event_connect_error(&event);\r\ncm_node->state = I40IW_CM_STATE_LISTENER_DESTROYED;\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\n}\r\n}\r\nif (!atomic_dec_return(&listener->ref_count)) {\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_del(&listener->list);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nif (listener->iwdev) {\r\nif (apbvt_del && !i40iw_listen_port_in_use(cm_core, listener->loc_port))\r\ni40iw_manage_apbvt(listener->iwdev,\r\nlistener->loc_port,\r\nI40IW_MANAGE_APBVT_DEL);\r\nmemcpy(nfo.loc_addr, listener->loc_addr, sizeof(nfo.loc_addr));\r\nnfo.loc_port = listener->loc_port;\r\nnfo.ipv4 = listener->ipv4;\r\nnfo.vlan_id = listener->vlan_id;\r\nnfo.user_pri = listener->user_pri;\r\nif (!list_empty(&listener->child_listen_list)) {\r\ni40iw_del_multiple_qhash(listener->iwdev, &nfo, listener);\r\n} else {\r\nif (listener->qhash_set)\r\ni40iw_manage_qhash(listener->iwdev,\r\n&nfo,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL,\r\nfalse);\r\n}\r\n}\r\ncm_core->stats_listen_destroyed++;\r\nkfree(listener);\r\ncm_core->stats_listen_nodes_destroyed++;\r\nlistener = NULL;\r\nret = 0;\r\n}\r\nif (listener) {\r\nif (atomic_read(&listener->pend_accepts_cnt) > 0)\r\ni40iw_debug(cm_core->dev,\r\nI40IW_DEBUG_CM,\r\n"%s: listener (%p) pending accepts=%u\n",\r\n__func__,\r\nlistener,\r\natomic_read(&listener->pend_accepts_cnt));\r\n}\r\nreturn ret;\r\n}\r\nstatic int i40iw_cm_del_listen(struct i40iw_cm_core *cm_core,\r\nstruct i40iw_cm_listener *listener,\r\nbool apbvt_del)\r\n{\r\nlistener->listener_state = I40IW_CM_LISTENER_PASSIVE_STATE;\r\nlistener->cm_id = NULL;\r\nreturn i40iw_dec_refcnt_listen(cm_core, listener, 1, apbvt_del);\r\n}\r\nstatic int i40iw_addr_resolve_neigh(struct i40iw_device *iwdev,\r\nu32 src_ip,\r\nu32 dst_ip,\r\nint arpindex)\r\n{\r\nstruct rtable *rt;\r\nstruct neighbour *neigh;\r\nint rc = arpindex;\r\nstruct net_device *netdev = iwdev->netdev;\r\n__be32 dst_ipaddr = htonl(dst_ip);\r\n__be32 src_ipaddr = htonl(src_ip);\r\nrt = ip_route_output(&init_net, dst_ipaddr, src_ipaddr, 0, 0);\r\nif (IS_ERR(rt)) {\r\ni40iw_pr_err("ip_route_output\n");\r\nreturn rc;\r\n}\r\nif (netif_is_bond_slave(netdev))\r\nnetdev = netdev_master_upper_dev_get(netdev);\r\nneigh = dst_neigh_lookup(&rt->dst, &dst_ipaddr);\r\nrcu_read_lock();\r\nif (neigh) {\r\nif (neigh->nud_state & NUD_VALID) {\r\nif (arpindex >= 0) {\r\nif (ether_addr_equal(iwdev->arp_table[arpindex].mac_addr,\r\nneigh->ha))\r\ngoto resolve_neigh_exit;\r\ni40iw_manage_arp_cache(iwdev,\r\niwdev->arp_table[arpindex].mac_addr,\r\n&dst_ip,\r\ntrue,\r\nI40IW_ARP_DELETE);\r\n}\r\ni40iw_manage_arp_cache(iwdev, neigh->ha, &dst_ip, true, I40IW_ARP_ADD);\r\nrc = i40iw_arp_table(iwdev, &dst_ip, true, NULL, I40IW_ARP_RESOLVE);\r\n} else {\r\nneigh_event_send(neigh, NULL);\r\n}\r\n}\r\nresolve_neigh_exit:\r\nrcu_read_unlock();\r\nif (neigh)\r\nneigh_release(neigh);\r\nip_rt_put(rt);\r\nreturn rc;\r\n}\r\nstatic struct dst_entry *i40iw_get_dst_ipv6(struct sockaddr_in6 *src_addr,\r\nstruct sockaddr_in6 *dst_addr)\r\n{\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.daddr = dst_addr->sin6_addr;\r\nfl6.saddr = src_addr->sin6_addr;\r\nif (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)\r\nfl6.flowi6_oif = dst_addr->sin6_scope_id;\r\ndst = ip6_route_output(&init_net, NULL, &fl6);\r\nreturn dst;\r\n}\r\nstatic int i40iw_addr_resolve_neigh_ipv6(struct i40iw_device *iwdev,\r\nu32 *src,\r\nu32 *dest,\r\nint arpindex)\r\n{\r\nstruct neighbour *neigh;\r\nint rc = arpindex;\r\nstruct net_device *netdev = iwdev->netdev;\r\nstruct dst_entry *dst;\r\nstruct sockaddr_in6 dst_addr;\r\nstruct sockaddr_in6 src_addr;\r\nmemset(&dst_addr, 0, sizeof(dst_addr));\r\ndst_addr.sin6_family = AF_INET6;\r\ni40iw_copy_ip_htonl(dst_addr.sin6_addr.in6_u.u6_addr32, dest);\r\nmemset(&src_addr, 0, sizeof(src_addr));\r\nsrc_addr.sin6_family = AF_INET6;\r\ni40iw_copy_ip_htonl(src_addr.sin6_addr.in6_u.u6_addr32, src);\r\ndst = i40iw_get_dst_ipv6(&src_addr, &dst_addr);\r\nif (!dst || dst->error) {\r\nif (dst) {\r\ndst_release(dst);\r\ni40iw_pr_err("ip6_route_output returned dst->error = %d\n",\r\ndst->error);\r\n}\r\nreturn rc;\r\n}\r\nif (netif_is_bond_slave(netdev))\r\nnetdev = netdev_master_upper_dev_get(netdev);\r\nneigh = dst_neigh_lookup(dst, &dst_addr);\r\nrcu_read_lock();\r\nif (neigh) {\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_CM, "dst_neigh_lookup MAC=%pM\n", neigh->ha);\r\nif (neigh->nud_state & NUD_VALID) {\r\nif (arpindex >= 0) {\r\nif (ether_addr_equal\r\n(iwdev->arp_table[arpindex].mac_addr,\r\nneigh->ha)) {\r\ngoto resolve_neigh_exit6;\r\n}\r\ni40iw_manage_arp_cache(iwdev,\r\niwdev->arp_table[arpindex].mac_addr,\r\ndest,\r\nfalse,\r\nI40IW_ARP_DELETE);\r\n}\r\ni40iw_manage_arp_cache(iwdev,\r\nneigh->ha,\r\ndest,\r\nfalse,\r\nI40IW_ARP_ADD);\r\nrc = i40iw_arp_table(iwdev,\r\ndest,\r\nfalse,\r\nNULL,\r\nI40IW_ARP_RESOLVE);\r\n} else {\r\nneigh_event_send(neigh, NULL);\r\n}\r\n}\r\nresolve_neigh_exit6:\r\nrcu_read_unlock();\r\nif (neigh)\r\nneigh_release(neigh);\r\ndst_release(dst);\r\nreturn rc;\r\n}\r\nstatic bool i40iw_ipv4_is_loopback(u32 loc_addr, u32 rem_addr)\r\n{\r\nreturn ipv4_is_loopback(htonl(rem_addr)) || (loc_addr == rem_addr);\r\n}\r\nstatic bool i40iw_ipv6_is_loopback(u32 *loc_addr, u32 *rem_addr)\r\n{\r\nstruct in6_addr raddr6;\r\ni40iw_copy_ip_htonl(raddr6.in6_u.u6_addr32, rem_addr);\r\nreturn !memcmp(loc_addr, rem_addr, 16) || ipv6_addr_loopback(&raddr6);\r\n}\r\nstatic struct i40iw_cm_node *i40iw_make_cm_node(\r\nstruct i40iw_cm_core *cm_core,\r\nstruct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cm_info,\r\nstruct i40iw_cm_listener *listener)\r\n{\r\nstruct i40iw_cm_node *cm_node;\r\nstruct timespec ts;\r\nint oldarpindex;\r\nint arpindex;\r\nstruct net_device *netdev = iwdev->netdev;\r\ncm_node = kzalloc(sizeof(*cm_node), GFP_ATOMIC);\r\nif (!cm_node)\r\nreturn NULL;\r\ncm_node->ipv4 = cm_info->ipv4;\r\ncm_node->vlan_id = cm_info->vlan_id;\r\nif ((cm_node->vlan_id == I40IW_NO_VLAN) && iwdev->dcb)\r\ncm_node->vlan_id = 0;\r\ncm_node->tos = cm_info->tos;\r\ncm_node->user_pri = cm_info->user_pri;\r\nif (listener) {\r\nif (listener->tos != cm_info->tos)\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_DCB,\r\n"application TOS[%d] and remote client TOS[%d] mismatch\n",\r\nlistener->tos, cm_info->tos);\r\ncm_node->tos = max(listener->tos, cm_info->tos);\r\ncm_node->user_pri = rt_tos2priority(cm_node->tos);\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_DCB, "listener: TOS:[%d] UP:[%d]\n",\r\ncm_node->tos, cm_node->user_pri);\r\n}\r\nmemcpy(cm_node->loc_addr, cm_info->loc_addr, sizeof(cm_node->loc_addr));\r\nmemcpy(cm_node->rem_addr, cm_info->rem_addr, sizeof(cm_node->rem_addr));\r\ncm_node->loc_port = cm_info->loc_port;\r\ncm_node->rem_port = cm_info->rem_port;\r\ncm_node->mpa_frame_rev = iwdev->mpa_version;\r\ncm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\r\ncm_node->ird_size = I40IW_MAX_IRD_SIZE;\r\ncm_node->ord_size = I40IW_MAX_ORD_SIZE;\r\ncm_node->listener = listener;\r\ncm_node->cm_id = cm_info->cm_id;\r\nether_addr_copy(cm_node->loc_mac, netdev->dev_addr);\r\nspin_lock_init(&cm_node->retrans_list_lock);\r\natomic_set(&cm_node->ref_count, 1);\r\ncm_node->cm_core = cm_core;\r\ncm_node->tcp_cntxt.loc_id = I40IW_CM_DEF_LOCAL_ID;\r\ncm_node->tcp_cntxt.rcv_wscale = I40IW_CM_DEFAULT_RCV_WND_SCALE;\r\ncm_node->tcp_cntxt.rcv_wnd =\r\nI40IW_CM_DEFAULT_RCV_WND_SCALED >> I40IW_CM_DEFAULT_RCV_WND_SCALE;\r\nts = current_kernel_time();\r\ncm_node->tcp_cntxt.loc_seq_num = ts.tv_nsec;\r\ncm_node->tcp_cntxt.mss = iwdev->vsi.mss;\r\ncm_node->iwdev = iwdev;\r\ncm_node->dev = &iwdev->sc_dev;\r\nif ((cm_node->ipv4 &&\r\ni40iw_ipv4_is_loopback(cm_node->loc_addr[0], cm_node->rem_addr[0])) ||\r\n(!cm_node->ipv4 && i40iw_ipv6_is_loopback(cm_node->loc_addr,\r\ncm_node->rem_addr))) {\r\narpindex = i40iw_arp_table(iwdev,\r\ncm_node->rem_addr,\r\nfalse,\r\nNULL,\r\nI40IW_ARP_RESOLVE);\r\n} else {\r\noldarpindex = i40iw_arp_table(iwdev,\r\ncm_node->rem_addr,\r\nfalse,\r\nNULL,\r\nI40IW_ARP_RESOLVE);\r\nif (cm_node->ipv4)\r\narpindex = i40iw_addr_resolve_neigh(iwdev,\r\ncm_info->loc_addr[0],\r\ncm_info->rem_addr[0],\r\noldarpindex);\r\nelse if (IS_ENABLED(CONFIG_IPV6))\r\narpindex = i40iw_addr_resolve_neigh_ipv6(iwdev,\r\ncm_info->loc_addr,\r\ncm_info->rem_addr,\r\noldarpindex);\r\nelse\r\narpindex = -EINVAL;\r\n}\r\nif (arpindex < 0) {\r\ni40iw_pr_err("cm_node arpindex\n");\r\nkfree(cm_node);\r\nreturn NULL;\r\n}\r\nether_addr_copy(cm_node->rem_mac, iwdev->arp_table[arpindex].mac_addr);\r\ni40iw_add_hte_node(cm_core, cm_node);\r\ncm_core->stats_nodes_created++;\r\nreturn cm_node;\r\n}\r\nstatic void i40iw_rem_ref_cm_node(struct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_cm_core *cm_core = cm_node->cm_core;\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_cm_info nfo;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cm_node->cm_core->ht_lock, flags);\r\nif (atomic_dec_return(&cm_node->ref_count)) {\r\nspin_unlock_irqrestore(&cm_node->cm_core->ht_lock, flags);\r\nreturn;\r\n}\r\nlist_del(&cm_node->list);\r\nspin_unlock_irqrestore(&cm_node->cm_core->ht_lock, flags);\r\nif (!cm_node->accelerated && cm_node->accept_pend) {\r\npr_err("node destroyed before established\n");\r\natomic_dec(&cm_node->listener->pend_accepts_cnt);\r\n}\r\nif (cm_node->close_entry)\r\ni40iw_handle_close_entry(cm_node, 0);\r\nif (cm_node->listener) {\r\ni40iw_dec_refcnt_listen(cm_core, cm_node->listener, 0, true);\r\n} else {\r\nif (!i40iw_listen_port_in_use(cm_core, cm_node->loc_port) &&\r\ncm_node->apbvt_set) {\r\ni40iw_manage_apbvt(cm_node->iwdev,\r\ncm_node->loc_port,\r\nI40IW_MANAGE_APBVT_DEL);\r\ni40iw_get_addr_info(cm_node, &nfo);\r\nif (cm_node->qhash_set) {\r\ni40iw_manage_qhash(cm_node->iwdev,\r\n&nfo,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL,\r\nfalse);\r\ncm_node->qhash_set = 0;\r\n}\r\n}\r\n}\r\niwqp = cm_node->iwqp;\r\nif (iwqp) {\r\niwqp->cm_node = NULL;\r\ni40iw_rem_ref(&iwqp->ibqp);\r\ncm_node->iwqp = NULL;\r\n} else if (cm_node->qhash_set) {\r\ni40iw_get_addr_info(cm_node, &nfo);\r\ni40iw_manage_qhash(cm_node->iwdev,\r\n&nfo,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL,\r\nfalse);\r\ncm_node->qhash_set = 0;\r\n}\r\ncm_node->cm_core->stats_nodes_destroyed++;\r\nkfree(cm_node);\r\n}\r\nstatic void i40iw_handle_fin_pkt(struct i40iw_cm_node *cm_node)\r\n{\r\nu32 ret;\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_MPAREJ_RCVD:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_LAST_ACK;\r\ni40iw_send_fin(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ni40iw_create_event(cm_node, I40IW_CM_EVENT_ABORTED);\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSING;\r\ni40iw_send_ack(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_TIME_WAIT;\r\ni40iw_send_ack(cm_node);\r\nret =\r\ni40iw_schedule_cm_timer(cm_node, NULL, I40IW_TIMER_TYPE_CLOSE, 1, 0);\r\nif (ret)\r\ni40iw_pr_err("node %p state = %d\n", cm_node, cm_node->state);\r\nbreak;\r\ncase I40IW_CM_STATE_TIME_WAIT:\r\ncm_node->tcp_cntxt.rcv_nxt++;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ndefault:\r\ni40iw_pr_err("bad state node %p state = %d\n", cm_node, cm_node->state);\r\nbreak;\r\n}\r\n}\r\nstatic void i40iw_handle_rst_pkt(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\nswitch (cm_node->mpa_frame_rev) {\r\ncase IETF_MPA_V2:\r\ncm_node->mpa_frame_rev = IETF_MPA_V1;\r\ncm_node->state = I40IW_CM_STATE_SYN_SENT;\r\nif (i40iw_send_syn(cm_node, 0))\r\ni40iw_active_open_err(cm_node, false);\r\nbreak;\r\ncase IETF_MPA_V1:\r\ndefault:\r\ni40iw_active_open_err(cm_node, false);\r\nbreak;\r\n}\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREQ_RCVD:\r\natomic_add_return(1, &cm_node->passive_state);\r\nbreak;\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ncase I40IW_CM_STATE_LISTENING:\r\ni40iw_pr_err("Bad state state = %d\n", cm_node->state);\r\ni40iw_passive_open_err(cm_node, false);\r\nbreak;\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ni40iw_active_open_err(cm_node, false);\r\nbreak;\r\ncase I40IW_CM_STATE_CLOSED:\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncase I40IW_CM_STATE_LAST_ACK:\r\ncm_node->cm_id->rem_ref(cm_node->cm_id);\r\ncase I40IW_CM_STATE_TIME_WAIT:\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i40iw_handle_rcv_mpa(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\nint ret;\r\nint datasize = rbuf->datalen;\r\nu8 *dataloc = rbuf->data;\r\nenum i40iw_cm_event_type type = I40IW_CM_EVENT_UNKNOWN;\r\nu32 res_type;\r\nret = i40iw_parse_mpa(cm_node, dataloc, &res_type, datasize);\r\nif (ret) {\r\nif (cm_node->state == I40IW_CM_STATE_MPAREQ_SENT)\r\ni40iw_active_open_err(cm_node, true);\r\nelse\r\ni40iw_passive_open_err(cm_node, true);\r\nreturn;\r\n}\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\nif (res_type == I40IW_MPA_REQUEST_REJECT)\r\ni40iw_pr_err("state for reject\n");\r\ncm_node->state = I40IW_CM_STATE_MPAREQ_RCVD;\r\ntype = I40IW_CM_EVENT_MPA_REQ;\r\ni40iw_send_ack(cm_node);\r\natomic_set(&cm_node->passive_state,\r\nI40IW_PASSIVE_STATE_INDICATED);\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nif (res_type == I40IW_MPA_REQUEST_REJECT) {\r\ntype = I40IW_CM_EVENT_MPA_REJECT;\r\ncm_node->state = I40IW_CM_STATE_MPAREJ_RCVD;\r\n} else {\r\ntype = I40IW_CM_EVENT_CONNECTED;\r\ncm_node->state = I40IW_CM_STATE_OFFLOADED;\r\ni40iw_send_ack(cm_node);\r\n}\r\nbreak;\r\ndefault:\r\npr_err("%s wrong cm_node state =%d\n", __func__, cm_node->state);\r\nbreak;\r\n}\r\ni40iw_create_event(cm_node, type);\r\n}\r\nstatic void i40iw_indicate_pkt_err(struct i40iw_cm_node *cm_node)\r\n{\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ni40iw_active_open_err(cm_node, true);\r\nbreak;\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ni40iw_passive_open_err(cm_node, true);\r\nbreak;\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int i40iw_check_syn(struct i40iw_cm_node *cm_node, struct tcphdr *tcph)\r\n{\r\nint err = 0;\r\nif (ntohl(tcph->ack_seq) != cm_node->tcp_cntxt.loc_seq_num) {\r\nerr = 1;\r\ni40iw_active_open_err(cm_node, true);\r\n}\r\nreturn err;\r\n}\r\nstatic int i40iw_check_seq(struct i40iw_cm_node *cm_node, struct tcphdr *tcph)\r\n{\r\nint err = 0;\r\nu32 seq;\r\nu32 ack_seq;\r\nu32 loc_seq_num = cm_node->tcp_cntxt.loc_seq_num;\r\nu32 rcv_nxt = cm_node->tcp_cntxt.rcv_nxt;\r\nu32 rcv_wnd;\r\nseq = ntohl(tcph->seq);\r\nack_seq = ntohl(tcph->ack_seq);\r\nrcv_wnd = cm_node->tcp_cntxt.rcv_wnd;\r\nif (ack_seq != loc_seq_num)\r\nerr = -1;\r\nelse if (!between(seq, rcv_nxt, (rcv_nxt + rcv_wnd)))\r\nerr = -1;\r\nif (err) {\r\ni40iw_pr_err("seq number\n");\r\ni40iw_indicate_pkt_err(cm_node);\r\n}\r\nreturn err;\r\n}\r\nstatic void i40iw_handle_syn_pkt(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\nstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\r\nint ret;\r\nu32 inc_sequence;\r\nint optionsize;\r\nstruct i40iw_cm_info nfo;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\ninc_sequence = ntohl(tcph->seq);\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ni40iw_active_open_err(cm_node, 1);\r\nbreak;\r\ncase I40IW_CM_STATE_LISTENING:\r\nif (atomic_read(&cm_node->listener->pend_accepts_cnt) >\r\ncm_node->listener->backlog) {\r\ncm_node->cm_core->stats_backlog_drops++;\r\ni40iw_passive_open_err(cm_node, false);\r\nbreak;\r\n}\r\nret = i40iw_handle_tcp_options(cm_node, tcph, optionsize, 1);\r\nif (ret) {\r\ni40iw_passive_open_err(cm_node, false);\r\nbreak;\r\n}\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\r\ncm_node->accept_pend = 1;\r\natomic_inc(&cm_node->listener->pend_accepts_cnt);\r\ncm_node->state = I40IW_CM_STATE_SYN_RCVD;\r\ni40iw_get_addr_info(cm_node, &nfo);\r\nret = i40iw_manage_qhash(cm_node->iwdev,\r\n&nfo,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_ADD,\r\n(void *)cm_node,\r\nfalse);\r\ncm_node->qhash_set = true;\r\nbreak;\r\ncase I40IW_CM_STATE_CLOSED:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncase I40IW_CM_STATE_MPAREQ_RCVD:\r\ncase I40IW_CM_STATE_LAST_ACK:\r\ncase I40IW_CM_STATE_CLOSING:\r\ncase I40IW_CM_STATE_UNKNOWN:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void i40iw_handle_synack_pkt(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\nstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\r\nint ret;\r\nu32 inc_sequence;\r\nint optionsize;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\ninc_sequence = ntohl(tcph->seq);\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nif (i40iw_check_syn(cm_node, tcph)) {\r\ni40iw_pr_err("check syn fail\n");\r\nreturn;\r\n}\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\nret = i40iw_handle_tcp_options(cm_node, tcph, optionsize, 0);\r\nif (ret) {\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"cm_node=%p tcp_options failed\n",\r\ncm_node);\r\nbreak;\r\n}\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\r\ni40iw_send_ack(cm_node);\r\nret = i40iw_send_mpa_request(cm_node);\r\nif (ret) {\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"cm_node=%p i40iw_send_mpa_request failed\n",\r\ncm_node);\r\nbreak;\r\n}\r\ncm_node->state = I40IW_CM_STATE_MPAREQ_SENT;\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREQ_RCVD:\r\ni40iw_passive_open_err(cm_node, true);\r\nbreak;\r\ncase I40IW_CM_STATE_LISTENING:\r\ncm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_CLOSED:\r\ncm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\r\ni40iw_cleanup_retrans_entry(cm_node);\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncase I40IW_CM_STATE_LAST_ACK:\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ncase I40IW_CM_STATE_CLOSING:\r\ncase I40IW_CM_STATE_UNKNOWN:\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int i40iw_handle_ack_pkt(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\nstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\r\nu32 inc_sequence;\r\nint ret = 0;\r\nint optionsize;\r\nu32 datasize = rbuf->datalen;\r\noptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\r\nif (i40iw_check_seq(cm_node, tcph))\r\nreturn -EINVAL;\r\ninc_sequence = ntohl(tcph->seq);\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nret = i40iw_handle_tcp_options(cm_node, tcph, optionsize, 1);\r\nif (ret)\r\nbreak;\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\ncm_node->state = I40IW_CM_STATE_ESTABLISHED;\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\ni40iw_handle_rcv_mpa(cm_node, rbuf);\r\n}\r\nbreak;\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\ni40iw_handle_rcv_mpa(cm_node, rbuf);\r\n}\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ncm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\r\nif (datasize) {\r\ncm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\r\ni40iw_handle_rcv_mpa(cm_node, rbuf);\r\n}\r\nbreak;\r\ncase I40IW_CM_STATE_LISTENING:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_CLOSED:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\natomic_inc(&cm_node->ref_count);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_LAST_ACK:\r\ncase I40IW_CM_STATE_CLOSING:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\nif (!cm_node->accept_pend)\r\ncm_node->cm_id->rem_ref(cm_node->cm_id);\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ncm_node->state = I40IW_CM_STATE_FIN_WAIT2;\r\nbreak;\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncase I40IW_CM_STATE_OFFLOADED:\r\ncase I40IW_CM_STATE_MPAREQ_RCVD:\r\ncase I40IW_CM_STATE_UNKNOWN:\r\ndefault:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void i40iw_process_packet(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_puda_buf *rbuf)\r\n{\r\nenum i40iw_tcpip_pkt_type pkt_type = I40IW_PKT_TYPE_UNKNOWN;\r\nstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\r\nu32 fin_set = 0;\r\nint ret;\r\nif (tcph->rst) {\r\npkt_type = I40IW_PKT_TYPE_RST;\r\n} else if (tcph->syn) {\r\npkt_type = I40IW_PKT_TYPE_SYN;\r\nif (tcph->ack)\r\npkt_type = I40IW_PKT_TYPE_SYNACK;\r\n} else if (tcph->ack) {\r\npkt_type = I40IW_PKT_TYPE_ACK;\r\n}\r\nif (tcph->fin)\r\nfin_set = 1;\r\nswitch (pkt_type) {\r\ncase I40IW_PKT_TYPE_SYN:\r\ni40iw_handle_syn_pkt(cm_node, rbuf);\r\nbreak;\r\ncase I40IW_PKT_TYPE_SYNACK:\r\ni40iw_handle_synack_pkt(cm_node, rbuf);\r\nbreak;\r\ncase I40IW_PKT_TYPE_ACK:\r\nret = i40iw_handle_ack_pkt(cm_node, rbuf);\r\nif (fin_set && !ret)\r\ni40iw_handle_fin_pkt(cm_node);\r\nbreak;\r\ncase I40IW_PKT_TYPE_RST:\r\ni40iw_handle_rst_pkt(cm_node, rbuf);\r\nbreak;\r\ndefault:\r\nif (fin_set &&\r\n(!i40iw_check_seq(cm_node, (struct tcphdr *)rbuf->tcph)))\r\ni40iw_handle_fin_pkt(cm_node);\r\nbreak;\r\n}\r\n}\r\nstatic struct i40iw_cm_listener *i40iw_make_listen_node(\r\nstruct i40iw_cm_core *cm_core,\r\nstruct i40iw_device *iwdev,\r\nstruct i40iw_cm_info *cm_info)\r\n{\r\nstruct i40iw_cm_listener *listener;\r\nunsigned long flags;\r\nlistener = i40iw_find_listener(cm_core, cm_info->loc_addr,\r\ncm_info->loc_port,\r\ncm_info->vlan_id,\r\nI40IW_CM_LISTENER_EITHER_STATE);\r\nif (listener &&\r\n(listener->listener_state == I40IW_CM_LISTENER_ACTIVE_STATE)) {\r\natomic_dec(&listener->ref_count);\r\ni40iw_debug(cm_core->dev,\r\nI40IW_DEBUG_CM,\r\n"Not creating listener since it already exists\n");\r\nreturn NULL;\r\n}\r\nif (!listener) {\r\nlistener = kzalloc(sizeof(*listener), GFP_ATOMIC);\r\nif (!listener)\r\nreturn NULL;\r\ncm_core->stats_listen_nodes_created++;\r\nmemcpy(listener->loc_addr, cm_info->loc_addr, sizeof(listener->loc_addr));\r\nlistener->loc_port = cm_info->loc_port;\r\nINIT_LIST_HEAD(&listener->child_listen_list);\r\natomic_set(&listener->ref_count, 1);\r\n} else {\r\nlistener->reused_node = 1;\r\n}\r\nlistener->cm_id = cm_info->cm_id;\r\nlistener->ipv4 = cm_info->ipv4;\r\nlistener->vlan_id = cm_info->vlan_id;\r\natomic_set(&listener->pend_accepts_cnt, 0);\r\nlistener->cm_core = cm_core;\r\nlistener->iwdev = iwdev;\r\nlistener->backlog = cm_info->backlog;\r\nlistener->listener_state = I40IW_CM_LISTENER_ACTIVE_STATE;\r\nif (!listener->reused_node) {\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_add(&listener->list, &cm_core->listen_nodes);\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\n}\r\nreturn listener;\r\n}\r\nstatic struct i40iw_cm_node *i40iw_create_cm_node(\r\nstruct i40iw_cm_core *cm_core,\r\nstruct i40iw_device *iwdev,\r\nu16 private_data_len,\r\nvoid *private_data,\r\nstruct i40iw_cm_info *cm_info)\r\n{\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_cm_listener *loopback_remotelistener;\r\nstruct i40iw_cm_node *loopback_remotenode;\r\nstruct i40iw_cm_info loopback_cm_info;\r\ncm_node = i40iw_make_cm_node(cm_core, iwdev, cm_info, NULL);\r\nif (!cm_node)\r\nreturn ERR_PTR(-ENOMEM);\r\ncm_node->tcp_cntxt.client = 1;\r\ncm_node->tcp_cntxt.rcv_wscale = I40IW_CM_DEFAULT_RCV_WND_SCALE;\r\nif (!memcmp(cm_info->loc_addr, cm_info->rem_addr, sizeof(cm_info->loc_addr))) {\r\nloopback_remotelistener = i40iw_find_listener(\r\ncm_core,\r\ncm_info->rem_addr,\r\ncm_node->rem_port,\r\ncm_node->vlan_id,\r\nI40IW_CM_LISTENER_ACTIVE_STATE);\r\nif (!loopback_remotelistener) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn ERR_PTR(-ECONNREFUSED);\r\n} else {\r\nloopback_cm_info = *cm_info;\r\nloopback_cm_info.loc_port = cm_info->rem_port;\r\nloopback_cm_info.rem_port = cm_info->loc_port;\r\nloopback_cm_info.cm_id = loopback_remotelistener->cm_id;\r\nloopback_cm_info.ipv4 = cm_info->ipv4;\r\nloopback_remotenode = i40iw_make_cm_node(cm_core,\r\niwdev,\r\n&loopback_cm_info,\r\nloopback_remotelistener);\r\nif (!loopback_remotenode) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncm_core->stats_loopbacks++;\r\nloopback_remotenode->loopbackpartner = cm_node;\r\nloopback_remotenode->tcp_cntxt.rcv_wscale =\r\nI40IW_CM_DEFAULT_RCV_WND_SCALE;\r\ncm_node->loopbackpartner = loopback_remotenode;\r\nmemcpy(loopback_remotenode->pdata_buf, private_data,\r\nprivate_data_len);\r\nloopback_remotenode->pdata.size = private_data_len;\r\ncm_node->state = I40IW_CM_STATE_OFFLOADED;\r\ncm_node->tcp_cntxt.rcv_nxt =\r\nloopback_remotenode->tcp_cntxt.loc_seq_num;\r\nloopback_remotenode->tcp_cntxt.rcv_nxt =\r\ncm_node->tcp_cntxt.loc_seq_num;\r\ncm_node->tcp_cntxt.max_snd_wnd =\r\nloopback_remotenode->tcp_cntxt.rcv_wnd;\r\nloopback_remotenode->tcp_cntxt.max_snd_wnd = cm_node->tcp_cntxt.rcv_wnd;\r\ncm_node->tcp_cntxt.snd_wnd = loopback_remotenode->tcp_cntxt.rcv_wnd;\r\nloopback_remotenode->tcp_cntxt.snd_wnd = cm_node->tcp_cntxt.rcv_wnd;\r\ncm_node->tcp_cntxt.snd_wscale = loopback_remotenode->tcp_cntxt.rcv_wscale;\r\nloopback_remotenode->tcp_cntxt.snd_wscale = cm_node->tcp_cntxt.rcv_wscale;\r\nloopback_remotenode->state = I40IW_CM_STATE_MPAREQ_RCVD;\r\ni40iw_create_event(loopback_remotenode, I40IW_CM_EVENT_MPA_REQ);\r\n}\r\nreturn cm_node;\r\n}\r\ncm_node->pdata.size = private_data_len;\r\ncm_node->pdata.addr = cm_node->pdata_buf;\r\nmemcpy(cm_node->pdata_buf, private_data, private_data_len);\r\ncm_node->state = I40IW_CM_STATE_SYN_SENT;\r\nreturn cm_node;\r\n}\r\nstatic int i40iw_cm_reject(struct i40iw_cm_node *cm_node, const void *pdata, u8 plen)\r\n{\r\nint ret = 0;\r\nint err;\r\nint passive_state;\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nstruct i40iw_cm_node *loopback = cm_node->loopbackpartner;\r\nif (cm_node->tcp_cntxt.client)\r\nreturn ret;\r\ni40iw_cleanup_retrans_entry(cm_node);\r\nif (!loopback) {\r\npassive_state = atomic_add_return(1, &cm_node->passive_state);\r\nif (passive_state == I40IW_SEND_RESET_EVENT) {\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\ni40iw_rem_ref_cm_node(cm_node);\r\n} else {\r\nif (cm_node->state == I40IW_CM_STATE_LISTENER_DESTROYED) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\n} else {\r\nret = i40iw_send_mpa_reject(cm_node, pdata, plen);\r\nif (ret) {\r\ncm_node->state = I40IW_CM_STATE_CLOSED;\r\nerr = i40iw_send_reset(cm_node);\r\nif (err)\r\ni40iw_pr_err("send reset failed\n");\r\n} else {\r\ncm_id->add_ref(cm_id);\r\n}\r\n}\r\n}\r\n} else {\r\ncm_node->cm_id = NULL;\r\nif (cm_node->state == I40IW_CM_STATE_LISTENER_DESTROYED) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\ni40iw_rem_ref_cm_node(loopback);\r\n} else {\r\nret = i40iw_send_cm_event(loopback,\r\nloopback->cm_id,\r\nIW_CM_EVENT_CONNECT_REPLY,\r\n-ECONNREFUSED);\r\ni40iw_rem_ref_cm_node(cm_node);\r\nloopback->state = I40IW_CM_STATE_CLOSING;\r\ncm_id = loopback->cm_id;\r\ni40iw_rem_ref_cm_node(loopback);\r\ncm_id->rem_ref(cm_id);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int i40iw_cm_close(struct i40iw_cm_node *cm_node)\r\n{\r\nint ret = 0;\r\nif (!cm_node)\r\nreturn -EINVAL;\r\nswitch (cm_node->state) {\r\ncase I40IW_CM_STATE_SYN_RCVD:\r\ncase I40IW_CM_STATE_SYN_SENT:\r\ncase I40IW_CM_STATE_ONE_SIDE_ESTABLISHED:\r\ncase I40IW_CM_STATE_ESTABLISHED:\r\ncase I40IW_CM_STATE_ACCEPTING:\r\ncase I40IW_CM_STATE_MPAREQ_SENT:\r\ncase I40IW_CM_STATE_MPAREQ_RCVD:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_CLOSE_WAIT:\r\ncm_node->state = I40IW_CM_STATE_LAST_ACK;\r\ni40iw_send_fin(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_FIN_WAIT1:\r\ncase I40IW_CM_STATE_FIN_WAIT2:\r\ncase I40IW_CM_STATE_LAST_ACK:\r\ncase I40IW_CM_STATE_TIME_WAIT:\r\ncase I40IW_CM_STATE_CLOSING:\r\nret = -1;\r\nbreak;\r\ncase I40IW_CM_STATE_LISTENING:\r\ni40iw_cleanup_retrans_entry(cm_node);\r\ni40iw_send_reset(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_MPAREJ_RCVD:\r\ncase I40IW_CM_STATE_UNKNOWN:\r\ncase I40IW_CM_STATE_INITED:\r\ncase I40IW_CM_STATE_CLOSED:\r\ncase I40IW_CM_STATE_LISTENER_DESTROYED:\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\ncase I40IW_CM_STATE_OFFLOADED:\r\nif (cm_node->send_entry)\r\ni40iw_pr_err("send_entry\n");\r\ni40iw_rem_ref_cm_node(cm_node);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid i40iw_receive_ilq(struct i40iw_sc_vsi *vsi, struct i40iw_puda_buf *rbuf)\r\n{\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_cm_listener *listener;\r\nstruct iphdr *iph;\r\nstruct ipv6hdr *ip6h;\r\nstruct tcphdr *tcph;\r\nstruct i40iw_cm_info cm_info;\r\nstruct i40iw_sc_dev *dev = vsi->dev;\r\nstruct i40iw_device *iwdev = (struct i40iw_device *)dev->back_dev;\r\nstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\r\nstruct vlan_ethhdr *ethh;\r\nu16 vtag;\r\niph = (struct iphdr *)rbuf->iph;\r\nmemset(&cm_info, 0, sizeof(cm_info));\r\ni40iw_debug_buf(dev,\r\nI40IW_DEBUG_ILQ,\r\n"RECEIVE ILQ BUFFER",\r\nrbuf->mem.va,\r\nrbuf->totallen);\r\nethh = (struct vlan_ethhdr *)rbuf->mem.va;\r\nif (ethh->h_vlan_proto == htons(ETH_P_8021Q)) {\r\nvtag = ntohs(ethh->h_vlan_TCI);\r\ncm_info.user_pri = (vtag & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\r\ncm_info.vlan_id = vtag & VLAN_VID_MASK;\r\ni40iw_debug(cm_core->dev,\r\nI40IW_DEBUG_CM,\r\n"%s vlan_id=%d\n",\r\n__func__,\r\ncm_info.vlan_id);\r\n} else {\r\ncm_info.vlan_id = I40IW_NO_VLAN;\r\n}\r\ntcph = (struct tcphdr *)rbuf->tcph;\r\nif (rbuf->ipv4) {\r\ncm_info.loc_addr[0] = ntohl(iph->daddr);\r\ncm_info.rem_addr[0] = ntohl(iph->saddr);\r\ncm_info.ipv4 = true;\r\ncm_info.tos = iph->tos;\r\n} else {\r\nip6h = (struct ipv6hdr *)rbuf->iph;\r\ni40iw_copy_ip_ntohl(cm_info.loc_addr,\r\nip6h->daddr.in6_u.u6_addr32);\r\ni40iw_copy_ip_ntohl(cm_info.rem_addr,\r\nip6h->saddr.in6_u.u6_addr32);\r\ncm_info.ipv4 = false;\r\ncm_info.tos = (ip6h->priority << 4) | (ip6h->flow_lbl[0] >> 4);\r\n}\r\ncm_info.loc_port = ntohs(tcph->dest);\r\ncm_info.rem_port = ntohs(tcph->source);\r\ncm_node = i40iw_find_node(cm_core,\r\ncm_info.rem_port,\r\ncm_info.rem_addr,\r\ncm_info.loc_port,\r\ncm_info.loc_addr,\r\ntrue);\r\nif (!cm_node) {\r\nif (!tcph->syn || tcph->ack)\r\nreturn;\r\nlistener =\r\ni40iw_find_listener(cm_core,\r\ncm_info.loc_addr,\r\ncm_info.loc_port,\r\ncm_info.vlan_id,\r\nI40IW_CM_LISTENER_ACTIVE_STATE);\r\nif (!listener) {\r\ncm_info.cm_id = NULL;\r\ni40iw_debug(cm_core->dev,\r\nI40IW_DEBUG_CM,\r\n"%s no listener found\n",\r\n__func__);\r\nreturn;\r\n}\r\ncm_info.cm_id = listener->cm_id;\r\ncm_node = i40iw_make_cm_node(cm_core, iwdev, &cm_info, listener);\r\nif (!cm_node) {\r\ni40iw_debug(cm_core->dev,\r\nI40IW_DEBUG_CM,\r\n"%s allocate node failed\n",\r\n__func__);\r\natomic_dec(&listener->ref_count);\r\nreturn;\r\n}\r\nif (!tcph->rst && !tcph->fin) {\r\ncm_node->state = I40IW_CM_STATE_LISTENING;\r\n} else {\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn;\r\n}\r\natomic_inc(&cm_node->ref_count);\r\n} else if (cm_node->state == I40IW_CM_STATE_OFFLOADED) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn;\r\n}\r\ni40iw_process_packet(cm_node, rbuf);\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\nvoid i40iw_setup_cm_core(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\r\ncm_core->iwdev = iwdev;\r\ncm_core->dev = &iwdev->sc_dev;\r\nINIT_LIST_HEAD(&cm_core->connected_nodes);\r\nINIT_LIST_HEAD(&cm_core->listen_nodes);\r\ninit_timer(&cm_core->tcp_timer);\r\ncm_core->tcp_timer.function = i40iw_cm_timer_tick;\r\ncm_core->tcp_timer.data = (unsigned long)cm_core;\r\nspin_lock_init(&cm_core->ht_lock);\r\nspin_lock_init(&cm_core->listen_list_lock);\r\ncm_core->event_wq = alloc_ordered_workqueue("iwewq",\r\nWQ_MEM_RECLAIM);\r\ncm_core->disconn_wq = alloc_ordered_workqueue("iwdwq",\r\nWQ_MEM_RECLAIM);\r\n}\r\nvoid i40iw_cleanup_cm_core(struct i40iw_cm_core *cm_core)\r\n{\r\nunsigned long flags;\r\nif (!cm_core)\r\nreturn;\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nif (timer_pending(&cm_core->tcp_timer))\r\ndel_timer_sync(&cm_core->tcp_timer);\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\ndestroy_workqueue(cm_core->event_wq);\r\ndestroy_workqueue(cm_core->disconn_wq);\r\n}\r\nstatic void i40iw_init_tcp_ctx(struct i40iw_cm_node *cm_node,\r\nstruct i40iw_tcp_offload_info *tcp_info,\r\nstruct i40iw_qp *iwqp)\r\n{\r\ntcp_info->ipv4 = cm_node->ipv4;\r\ntcp_info->drop_ooo_seg = true;\r\ntcp_info->wscale = true;\r\ntcp_info->ignore_tcp_opt = true;\r\ntcp_info->ignore_tcp_uns_opt = true;\r\ntcp_info->no_nagle = false;\r\ntcp_info->ttl = I40IW_DEFAULT_TTL;\r\ntcp_info->rtt_var = cpu_to_le32(I40IW_DEFAULT_RTT_VAR);\r\ntcp_info->ss_thresh = cpu_to_le32(I40IW_DEFAULT_SS_THRESH);\r\ntcp_info->rexmit_thresh = I40IW_DEFAULT_REXMIT_THRESH;\r\ntcp_info->tcp_state = I40IW_TCP_STATE_ESTABLISHED;\r\ntcp_info->snd_wscale = cm_node->tcp_cntxt.snd_wscale;\r\ntcp_info->rcv_wscale = cm_node->tcp_cntxt.rcv_wscale;\r\ntcp_info->snd_nxt = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\ntcp_info->snd_wnd = cpu_to_le32(cm_node->tcp_cntxt.snd_wnd);\r\ntcp_info->rcv_nxt = cpu_to_le32(cm_node->tcp_cntxt.rcv_nxt);\r\ntcp_info->snd_max = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\ntcp_info->snd_una = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\ntcp_info->cwnd = cpu_to_le32(2 * cm_node->tcp_cntxt.mss);\r\ntcp_info->snd_wl1 = cpu_to_le32(cm_node->tcp_cntxt.rcv_nxt);\r\ntcp_info->snd_wl2 = cpu_to_le32(cm_node->tcp_cntxt.loc_seq_num);\r\ntcp_info->max_snd_window = cpu_to_le32(cm_node->tcp_cntxt.max_snd_wnd);\r\ntcp_info->rcv_wnd = cpu_to_le32(cm_node->tcp_cntxt.rcv_wnd <<\r\ncm_node->tcp_cntxt.rcv_wscale);\r\ntcp_info->flow_label = 0;\r\ntcp_info->snd_mss = cpu_to_le32(((u32)cm_node->tcp_cntxt.mss));\r\nif (cm_node->vlan_id < VLAN_TAG_PRESENT) {\r\ntcp_info->insert_vlan_tag = true;\r\ntcp_info->vlan_tag = cpu_to_le16(cm_node->vlan_id);\r\n}\r\nif (cm_node->ipv4) {\r\ntcp_info->src_port = cpu_to_le16(cm_node->loc_port);\r\ntcp_info->dst_port = cpu_to_le16(cm_node->rem_port);\r\ntcp_info->dest_ip_addr3 = cpu_to_le32(cm_node->rem_addr[0]);\r\ntcp_info->local_ipaddr3 = cpu_to_le32(cm_node->loc_addr[0]);\r\ntcp_info->arp_idx =\r\ncpu_to_le16((u16)i40iw_arp_table(\r\niwqp->iwdev,\r\n&tcp_info->dest_ip_addr3,\r\ntrue,\r\nNULL,\r\nI40IW_ARP_RESOLVE));\r\n} else {\r\ntcp_info->src_port = cpu_to_le16(cm_node->loc_port);\r\ntcp_info->dst_port = cpu_to_le16(cm_node->rem_port);\r\ntcp_info->dest_ip_addr0 = cpu_to_le32(cm_node->rem_addr[0]);\r\ntcp_info->dest_ip_addr1 = cpu_to_le32(cm_node->rem_addr[1]);\r\ntcp_info->dest_ip_addr2 = cpu_to_le32(cm_node->rem_addr[2]);\r\ntcp_info->dest_ip_addr3 = cpu_to_le32(cm_node->rem_addr[3]);\r\ntcp_info->local_ipaddr0 = cpu_to_le32(cm_node->loc_addr[0]);\r\ntcp_info->local_ipaddr1 = cpu_to_le32(cm_node->loc_addr[1]);\r\ntcp_info->local_ipaddr2 = cpu_to_le32(cm_node->loc_addr[2]);\r\ntcp_info->local_ipaddr3 = cpu_to_le32(cm_node->loc_addr[3]);\r\ntcp_info->arp_idx =\r\ncpu_to_le16((u16)i40iw_arp_table(\r\niwqp->iwdev,\r\n&tcp_info->dest_ip_addr0,\r\nfalse,\r\nNULL,\r\nI40IW_ARP_RESOLVE));\r\n}\r\n}\r\nstatic void i40iw_cm_init_tsa_conn(struct i40iw_qp *iwqp,\r\nstruct i40iw_cm_node *cm_node)\r\n{\r\nstruct i40iw_tcp_offload_info tcp_info;\r\nstruct i40iwarp_offload_info *iwarp_info;\r\nstruct i40iw_qp_host_ctx_info *ctx_info;\r\nstruct i40iw_device *iwdev = iwqp->iwdev;\r\nstruct i40iw_sc_dev *dev = &iwqp->iwdev->sc_dev;\r\nmemset(&tcp_info, 0x00, sizeof(struct i40iw_tcp_offload_info));\r\niwarp_info = &iwqp->iwarp_info;\r\nctx_info = &iwqp->ctx_info;\r\nctx_info->tcp_info = &tcp_info;\r\nctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\r\nctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\r\niwarp_info->ord_size = cm_node->ord_size;\r\niwarp_info->ird_size = i40iw_derive_hw_ird_setting(cm_node->ird_size);\r\nif (iwarp_info->ord_size == 1)\r\niwarp_info->ord_size = 2;\r\niwarp_info->rd_enable = true;\r\niwarp_info->rdmap_ver = 1;\r\niwarp_info->ddp_ver = 1;\r\niwarp_info->pd_id = iwqp->iwpd->sc_pd.pd_id;\r\nctx_info->tcp_info_valid = true;\r\nctx_info->iwarp_info_valid = true;\r\nctx_info->add_to_qoslist = true;\r\nctx_info->user_pri = cm_node->user_pri;\r\ni40iw_init_tcp_ctx(cm_node, &tcp_info, iwqp);\r\nif (cm_node->snd_mark_en) {\r\niwarp_info->snd_mark_en = true;\r\niwarp_info->snd_mark_offset = (tcp_info.snd_nxt &\r\nSNDMARKER_SEQNMASK) + cm_node->lsmm_size;\r\n}\r\ncm_node->state = I40IW_CM_STATE_OFFLOADED;\r\ntcp_info.tcp_state = I40IW_TCP_STATE_ESTABLISHED;\r\ntcp_info.src_mac_addr_idx = iwdev->mac_ip_table_idx;\r\ntcp_info.tos = cm_node->tos;\r\ndev->iw_priv_qp_ops->qp_setctx(&iwqp->sc_qp, (u64 *)(iwqp->host_ctx.va), ctx_info);\r\nctx_info->tcp_info_valid = false;\r\nctx_info->iwarp_info_valid = false;\r\nctx_info->add_to_qoslist = false;\r\n}\r\nvoid i40iw_cm_disconn(struct i40iw_qp *iwqp)\r\n{\r\nstruct disconn_work *work;\r\nstruct i40iw_device *iwdev = iwqp->iwdev;\r\nstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\r\nunsigned long flags;\r\nwork = kzalloc(sizeof(*work), GFP_ATOMIC);\r\nif (!work)\r\nreturn;\r\nspin_lock_irqsave(&iwdev->qptable_lock, flags);\r\nif (!iwdev->qp_table[iwqp->ibqp.qp_num]) {\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_CM,\r\n"%s qp_id %d is already freed\n",\r\n__func__, iwqp->ibqp.qp_num);\r\nkfree(work);\r\nreturn;\r\n}\r\ni40iw_add_ref(&iwqp->ibqp);\r\nspin_unlock_irqrestore(&iwdev->qptable_lock, flags);\r\nwork->iwqp = iwqp;\r\nINIT_WORK(&work->work, i40iw_disconnect_worker);\r\nqueue_work(cm_core->disconn_wq, &work->work);\r\nreturn;\r\n}\r\nstatic void i40iw_qp_disconnect(struct i40iw_qp *iwqp)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_ib_device *iwibdev;\r\niwdev = to_iwdev(iwqp->ibqp.device);\r\nif (!iwdev) {\r\ni40iw_pr_err("iwdev == NULL\n");\r\nreturn;\r\n}\r\niwibdev = iwdev->iwibdev;\r\nif (iwqp->active_conn) {\r\niwqp->active_conn = 0;\r\n} else {\r\nif (iwqp->ietf_mem.va) {\r\nif (iwqp->lsmm_mr)\r\niwibdev->ibdev.dereg_mr(iwqp->lsmm_mr);\r\ni40iw_free_dma_mem(iwdev->sc_dev.hw, &iwqp->ietf_mem);\r\n}\r\n}\r\nif (iwqp->cm_node) {\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_CM, "%s Call close API\n", __func__);\r\ni40iw_cm_close(iwqp->cm_node);\r\n}\r\n}\r\nstatic void i40iw_cm_disconn_true(struct i40iw_qp *iwqp)\r\n{\r\nstruct iw_cm_id *cm_id;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_sc_qp *qp = &iwqp->sc_qp;\r\nu16 last_ae;\r\nu8 original_hw_tcp_state;\r\nu8 original_ibqp_state;\r\nint disconn_status = 0;\r\nint issue_disconn = 0;\r\nint issue_close = 0;\r\nint issue_flush = 0;\r\nstruct ib_event ibevent;\r\nunsigned long flags;\r\nint ret;\r\nif (!iwqp) {\r\ni40iw_pr_err("iwqp == NULL\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&iwqp->lock, flags);\r\ncm_id = iwqp->cm_id;\r\nif (!cm_id) {\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nreturn;\r\n}\r\niwdev = to_iwdev(iwqp->ibqp.device);\r\noriginal_hw_tcp_state = iwqp->hw_tcp_state;\r\noriginal_ibqp_state = iwqp->ibqp_state;\r\nlast_ae = iwqp->last_aeq;\r\nif (qp->term_flags) {\r\nissue_disconn = 1;\r\nissue_close = 1;\r\niwqp->cm_id = NULL;\r\ni40iw_terminate_del_timer(qp);\r\nif (!iwqp->flush_issued) {\r\niwqp->flush_issued = 1;\r\nissue_flush = 1;\r\n}\r\n} else if ((original_hw_tcp_state == I40IW_TCP_STATE_CLOSE_WAIT) ||\r\n((original_ibqp_state == IB_QPS_RTS) &&\r\n(last_ae == I40IW_AE_LLP_CONNECTION_RESET))) {\r\nissue_disconn = 1;\r\nif (last_ae == I40IW_AE_LLP_CONNECTION_RESET)\r\ndisconn_status = -ECONNRESET;\r\n}\r\nif (((original_hw_tcp_state == I40IW_TCP_STATE_CLOSED) ||\r\n(original_hw_tcp_state == I40IW_TCP_STATE_TIME_WAIT) ||\r\n(last_ae == I40IW_AE_RDMAP_ROE_BAD_LLP_CLOSE) ||\r\n(last_ae == I40IW_AE_LLP_CONNECTION_RESET))) {\r\nissue_close = 1;\r\niwqp->cm_id = NULL;\r\nif (!iwqp->flush_issued) {\r\niwqp->flush_issued = 1;\r\nissue_flush = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iwqp->lock, flags);\r\nif (issue_flush && !iwqp->destroyed) {\r\ni40iw_flush_wqes(iwdev, iwqp);\r\nif (qp->term_flags && iwqp->ibqp.event_handler) {\r\nibevent.device = iwqp->ibqp.device;\r\nibevent.event = (qp->eventtype == TERM_EVENT_QP_FATAL) ?\r\nIB_EVENT_QP_FATAL : IB_EVENT_QP_ACCESS_ERR;\r\nibevent.element.qp = &iwqp->ibqp;\r\niwqp->ibqp.event_handler(&ibevent, iwqp->ibqp.qp_context);\r\n}\r\n}\r\nif (cm_id && cm_id->event_handler) {\r\nif (issue_disconn) {\r\nret = i40iw_send_cm_event(NULL,\r\ncm_id,\r\nIW_CM_EVENT_DISCONNECT,\r\ndisconn_status);\r\nif (ret)\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"disconnect event failed %s: - cm_id = %p\n",\r\n__func__, cm_id);\r\n}\r\nif (issue_close) {\r\ni40iw_qp_disconnect(iwqp);\r\ncm_id->provider_data = iwqp;\r\nret = i40iw_send_cm_event(NULL, cm_id, IW_CM_EVENT_CLOSE, 0);\r\nif (ret)\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"close event failed %s: - cm_id = %p\n",\r\n__func__, cm_id);\r\ncm_id->rem_ref(cm_id);\r\n}\r\n}\r\n}\r\nstatic void i40iw_disconnect_worker(struct work_struct *work)\r\n{\r\nstruct disconn_work *dwork = container_of(work, struct disconn_work, work);\r\nstruct i40iw_qp *iwqp = dwork->iwqp;\r\nkfree(dwork);\r\ni40iw_cm_disconn_true(iwqp);\r\ni40iw_rem_ref(&iwqp->ibqp);\r\n}\r\nint i40iw_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\r\n{\r\nstruct ib_qp *ibqp;\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_sc_dev *dev;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct ib_qp_attr attr;\r\nint passive_state;\r\nstruct ib_mr *ibmr;\r\nstruct i40iw_pd *iwpd;\r\nu16 buf_len = 0;\r\nstruct i40iw_kmem_info accept;\r\nenum i40iw_status_code status;\r\nu64 tagged_offset;\r\nmemset(&attr, 0, sizeof(attr));\r\nibqp = i40iw_get_qp(cm_id->device, conn_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\niwqp = to_iwqp(ibqp);\r\niwdev = iwqp->iwdev;\r\ndev = &iwdev->sc_dev;\r\ncm_node = (struct i40iw_cm_node *)cm_id->provider_data;\r\nif (((struct sockaddr_in *)&cm_id->local_addr)->sin_family == AF_INET) {\r\ncm_node->ipv4 = true;\r\ncm_node->vlan_id = i40iw_get_vlan_ipv4(cm_node->loc_addr);\r\n} else {\r\ncm_node->ipv4 = false;\r\ni40iw_netdev_vlan_ipv6(cm_node->loc_addr, &cm_node->vlan_id, NULL);\r\n}\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"Accept vlan_id=%d\n",\r\ncm_node->vlan_id);\r\nif (cm_node->state == I40IW_CM_STATE_LISTENER_DESTROYED) {\r\nif (cm_node->loopbackpartner)\r\ni40iw_rem_ref_cm_node(cm_node->loopbackpartner);\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn -EINVAL;\r\n}\r\npassive_state = atomic_add_return(1, &cm_node->passive_state);\r\nif (passive_state == I40IW_SEND_RESET_EVENT) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\nreturn -ECONNRESET;\r\n}\r\ncm_node->cm_core->stats_accepts++;\r\niwqp->cm_node = (void *)cm_node;\r\ncm_node->iwqp = iwqp;\r\nbuf_len = conn_param->private_data_len + I40IW_MAX_IETF_SIZE;\r\nstatus = i40iw_allocate_dma_mem(dev->hw, &iwqp->ietf_mem, buf_len, 1);\r\nif (status)\r\nreturn -ENOMEM;\r\ncm_node->pdata.size = conn_param->private_data_len;\r\naccept.addr = iwqp->ietf_mem.va;\r\naccept.size = i40iw_cm_build_mpa_frame(cm_node, &accept, MPA_KEY_REPLY);\r\nmemcpy(accept.addr + accept.size, conn_param->private_data,\r\nconn_param->private_data_len);\r\nif ((cm_node->ipv4 &&\r\n!i40iw_ipv4_is_loopback(cm_node->loc_addr[0], cm_node->rem_addr[0])) ||\r\n(!cm_node->ipv4 &&\r\n!i40iw_ipv6_is_loopback(cm_node->loc_addr, cm_node->rem_addr))) {\r\niwpd = iwqp->iwpd;\r\ntagged_offset = (uintptr_t)iwqp->ietf_mem.va;\r\nibmr = i40iw_reg_phys_mr(&iwpd->ibpd,\r\niwqp->ietf_mem.pa,\r\nbuf_len,\r\nIB_ACCESS_LOCAL_WRITE,\r\n&tagged_offset);\r\nif (IS_ERR(ibmr)) {\r\ni40iw_free_dma_mem(dev->hw, &iwqp->ietf_mem);\r\nreturn -ENOMEM;\r\n}\r\nibmr->pd = &iwpd->ibpd;\r\nibmr->device = iwpd->ibpd.device;\r\niwqp->lsmm_mr = ibmr;\r\nif (iwqp->page)\r\niwqp->sc_qp.qp_uk.sq_base = kmap(iwqp->page);\r\ndev->iw_priv_qp_ops->qp_send_lsmm(&iwqp->sc_qp,\r\niwqp->ietf_mem.va,\r\n(accept.size + conn_param->private_data_len),\r\nibmr->lkey);\r\n} else {\r\nif (iwqp->page)\r\niwqp->sc_qp.qp_uk.sq_base = kmap(iwqp->page);\r\ndev->iw_priv_qp_ops->qp_send_lsmm(&iwqp->sc_qp, NULL, 0, 0);\r\n}\r\nif (iwqp->page)\r\nkunmap(iwqp->page);\r\niwqp->cm_id = cm_id;\r\ncm_node->cm_id = cm_id;\r\ncm_id->provider_data = (void *)iwqp;\r\niwqp->active_conn = 0;\r\ncm_node->lsmm_size = accept.size + conn_param->private_data_len;\r\ni40iw_cm_init_tsa_conn(iwqp, cm_node);\r\ncm_id->add_ref(cm_id);\r\ni40iw_add_ref(&iwqp->ibqp);\r\ni40iw_send_cm_event(cm_node, cm_id, IW_CM_EVENT_ESTABLISHED, 0);\r\nattr.qp_state = IB_QPS_RTS;\r\ncm_node->qhash_set = false;\r\ni40iw_modify_qp(&iwqp->ibqp, &attr, IB_QP_STATE, NULL);\r\nif (cm_node->loopbackpartner) {\r\ncm_node->loopbackpartner->pdata.size = conn_param->private_data_len;\r\nmemcpy(cm_node->loopbackpartner->pdata_buf,\r\nconn_param->private_data,\r\nconn_param->private_data_len);\r\ni40iw_create_event(cm_node->loopbackpartner, I40IW_CM_EVENT_CONNECTED);\r\n}\r\ncm_node->accelerated = 1;\r\nif (cm_node->accept_pend) {\r\nif (!cm_node->listener)\r\ni40iw_pr_err("cm_node->listener NULL for passive node\n");\r\natomic_dec(&cm_node->listener->pend_accepts_cnt);\r\ncm_node->accept_pend = 0;\r\n}\r\nreturn 0;\r\n}\r\nint i40iw_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_cm_node *loopback;\r\ncm_node = (struct i40iw_cm_node *)cm_id->provider_data;\r\nloopback = cm_node->loopbackpartner;\r\ncm_node->cm_id = cm_id;\r\ncm_node->pdata.size = pdata_len;\r\niwdev = to_iwdev(cm_id->device);\r\nif (!iwdev)\r\nreturn -EINVAL;\r\ncm_node->cm_core->stats_rejects++;\r\nif (pdata_len + sizeof(struct ietf_mpa_v2) > MAX_CM_BUFFER)\r\nreturn -EINVAL;\r\nif (loopback) {\r\nmemcpy(&loopback->pdata_buf, pdata, pdata_len);\r\nloopback->pdata.size = pdata_len;\r\n}\r\nreturn i40iw_cm_reject(cm_node, pdata, pdata_len);\r\n}\r\nint i40iw_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\r\n{\r\nstruct ib_qp *ibqp;\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_cm_info cm_info;\r\nstruct sockaddr_in *laddr;\r\nstruct sockaddr_in *raddr;\r\nstruct sockaddr_in6 *laddr6;\r\nstruct sockaddr_in6 *raddr6;\r\nbool qhash_set = false;\r\nint apbvt_set = 0;\r\nint err = 0;\r\nenum i40iw_status_code status;\r\nibqp = i40iw_get_qp(cm_id->device, conn_param->qpn);\r\nif (!ibqp)\r\nreturn -EINVAL;\r\niwqp = to_iwqp(ibqp);\r\nif (!iwqp)\r\nreturn -EINVAL;\r\niwdev = to_iwdev(iwqp->ibqp.device);\r\nif (!iwdev)\r\nreturn -EINVAL;\r\nladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\r\nraddr = (struct sockaddr_in *)&cm_id->m_remote_addr;\r\nladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\r\nraddr6 = (struct sockaddr_in6 *)&cm_id->m_remote_addr;\r\nif (!(laddr->sin_port) || !(raddr->sin_port))\r\nreturn -EINVAL;\r\niwqp->active_conn = 1;\r\niwqp->cm_id = NULL;\r\ncm_id->provider_data = iwqp;\r\nif (cm_id->remote_addr.ss_family == AF_INET) {\r\ncm_info.ipv4 = true;\r\nmemset(cm_info.loc_addr, 0, sizeof(cm_info.loc_addr));\r\nmemset(cm_info.rem_addr, 0, sizeof(cm_info.rem_addr));\r\ncm_info.loc_addr[0] = ntohl(laddr->sin_addr.s_addr);\r\ncm_info.rem_addr[0] = ntohl(raddr->sin_addr.s_addr);\r\ncm_info.loc_port = ntohs(laddr->sin_port);\r\ncm_info.rem_port = ntohs(raddr->sin_port);\r\ncm_info.vlan_id = i40iw_get_vlan_ipv4(cm_info.loc_addr);\r\n} else {\r\ncm_info.ipv4 = false;\r\ni40iw_copy_ip_ntohl(cm_info.loc_addr,\r\nladdr6->sin6_addr.in6_u.u6_addr32);\r\ni40iw_copy_ip_ntohl(cm_info.rem_addr,\r\nraddr6->sin6_addr.in6_u.u6_addr32);\r\ncm_info.loc_port = ntohs(laddr6->sin6_port);\r\ncm_info.rem_port = ntohs(raddr6->sin6_port);\r\ni40iw_netdev_vlan_ipv6(cm_info.loc_addr, &cm_info.vlan_id, NULL);\r\n}\r\ncm_info.cm_id = cm_id;\r\ncm_info.tos = cm_id->tos;\r\ncm_info.user_pri = rt_tos2priority(cm_id->tos);\r\ni40iw_debug(&iwdev->sc_dev, I40IW_DEBUG_DCB, "%s TOS:[%d] UP:[%d]\n",\r\n__func__, cm_id->tos, cm_info.user_pri);\r\nif ((cm_info.ipv4 && (laddr->sin_addr.s_addr != raddr->sin_addr.s_addr)) ||\r\n(!cm_info.ipv4 && memcmp(laddr6->sin6_addr.in6_u.u6_addr32,\r\nraddr6->sin6_addr.in6_u.u6_addr32,\r\nsizeof(laddr6->sin6_addr.in6_u.u6_addr32)))) {\r\nstatus = i40iw_manage_qhash(iwdev,\r\n&cm_info,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_ADD,\r\nNULL,\r\ntrue);\r\nif (status)\r\nreturn -EINVAL;\r\nqhash_set = true;\r\n}\r\nstatus = i40iw_manage_apbvt(iwdev, cm_info.loc_port, I40IW_MANAGE_APBVT_ADD);\r\nif (status) {\r\ni40iw_manage_qhash(iwdev,\r\n&cm_info,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL,\r\nfalse);\r\nreturn -EINVAL;\r\n}\r\napbvt_set = 1;\r\ncm_id->add_ref(cm_id);\r\ncm_node = i40iw_create_cm_node(&iwdev->cm_core, iwdev,\r\nconn_param->private_data_len,\r\n(void *)conn_param->private_data,\r\n&cm_info);\r\nif (IS_ERR(cm_node)) {\r\nerr = PTR_ERR(cm_node);\r\ngoto err_out;\r\n}\r\ni40iw_record_ird_ord(cm_node, (u16)conn_param->ird, (u16)conn_param->ord);\r\nif (cm_node->send_rdma0_op == SEND_RDMA_READ_ZERO &&\r\n!cm_node->ord_size)\r\ncm_node->ord_size = 1;\r\ncm_node->apbvt_set = apbvt_set;\r\ncm_node->qhash_set = qhash_set;\r\niwqp->cm_node = cm_node;\r\ncm_node->iwqp = iwqp;\r\niwqp->cm_id = cm_id;\r\ni40iw_add_ref(&iwqp->ibqp);\r\nif (cm_node->state != I40IW_CM_STATE_OFFLOADED) {\r\ncm_node->state = I40IW_CM_STATE_SYN_SENT;\r\nerr = i40iw_send_syn(cm_node, 0);\r\nif (err) {\r\ni40iw_rem_ref_cm_node(cm_node);\r\ngoto err_out;\r\n}\r\n}\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"Api - connect(): port=0x%04x, cm_node=%p, cm_id = %p.\n",\r\ncm_node->rem_port,\r\ncm_node,\r\ncm_node->cm_id);\r\nreturn 0;\r\nerr_out:\r\nif (cm_info.ipv4)\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"Api - connect() FAILED: dest addr=%pI4",\r\ncm_info.rem_addr);\r\nelse\r\ni40iw_debug(&iwdev->sc_dev,\r\nI40IW_DEBUG_CM,\r\n"Api - connect() FAILED: dest addr=%pI6",\r\ncm_info.rem_addr);\r\nif (qhash_set)\r\ni40iw_manage_qhash(iwdev,\r\n&cm_info,\r\nI40IW_QHASH_TYPE_TCP_ESTABLISHED,\r\nI40IW_QHASH_MANAGE_TYPE_DELETE,\r\nNULL,\r\nfalse);\r\nif (apbvt_set && !i40iw_listen_port_in_use(&iwdev->cm_core,\r\ncm_info.loc_port))\r\ni40iw_manage_apbvt(iwdev,\r\ncm_info.loc_port,\r\nI40IW_MANAGE_APBVT_DEL);\r\ncm_id->rem_ref(cm_id);\r\niwdev->cm_core.stats_connect_errs++;\r\nreturn err;\r\n}\r\nint i40iw_create_listen(struct iw_cm_id *cm_id, int backlog)\r\n{\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_cm_listener *cm_listen_node;\r\nstruct i40iw_cm_info cm_info;\r\nenum i40iw_status_code ret;\r\nstruct sockaddr_in *laddr;\r\nstruct sockaddr_in6 *laddr6;\r\nbool wildcard = false;\r\niwdev = to_iwdev(cm_id->device);\r\nif (!iwdev)\r\nreturn -EINVAL;\r\nladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\r\nladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\r\nmemset(&cm_info, 0, sizeof(cm_info));\r\nif (laddr->sin_family == AF_INET) {\r\ncm_info.ipv4 = true;\r\ncm_info.loc_addr[0] = ntohl(laddr->sin_addr.s_addr);\r\ncm_info.loc_port = ntohs(laddr->sin_port);\r\nif (laddr->sin_addr.s_addr != INADDR_ANY)\r\ncm_info.vlan_id = i40iw_get_vlan_ipv4(cm_info.loc_addr);\r\nelse\r\nwildcard = true;\r\n} else {\r\ncm_info.ipv4 = false;\r\ni40iw_copy_ip_ntohl(cm_info.loc_addr,\r\nladdr6->sin6_addr.in6_u.u6_addr32);\r\ncm_info.loc_port = ntohs(laddr6->sin6_port);\r\nif (ipv6_addr_type(&laddr6->sin6_addr) != IPV6_ADDR_ANY)\r\ni40iw_netdev_vlan_ipv6(cm_info.loc_addr,\r\n&cm_info.vlan_id,\r\nNULL);\r\nelse\r\nwildcard = true;\r\n}\r\ncm_info.backlog = backlog;\r\ncm_info.cm_id = cm_id;\r\ncm_listen_node = i40iw_make_listen_node(&iwdev->cm_core, iwdev, &cm_info);\r\nif (!cm_listen_node) {\r\ni40iw_pr_err("cm_listen_node == NULL\n");\r\nreturn -ENOMEM;\r\n}\r\ncm_id->provider_data = cm_listen_node;\r\ncm_listen_node->tos = cm_id->tos;\r\ncm_listen_node->user_pri = rt_tos2priority(cm_id->tos);\r\ncm_info.user_pri = cm_listen_node->user_pri;\r\nif (!cm_listen_node->reused_node) {\r\nif (wildcard) {\r\nif (cm_info.ipv4)\r\nret = i40iw_add_mqh_4(iwdev,\r\n&cm_info,\r\ncm_listen_node);\r\nelse\r\nret = i40iw_add_mqh_6(iwdev,\r\n&cm_info,\r\ncm_listen_node);\r\nif (ret)\r\ngoto error;\r\nret = i40iw_manage_apbvt(iwdev,\r\ncm_info.loc_port,\r\nI40IW_MANAGE_APBVT_ADD);\r\nif (ret)\r\ngoto error;\r\n} else {\r\nret = i40iw_manage_qhash(iwdev,\r\n&cm_info,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nI40IW_QHASH_MANAGE_TYPE_ADD,\r\nNULL,\r\ntrue);\r\nif (ret)\r\ngoto error;\r\ncm_listen_node->qhash_set = true;\r\nret = i40iw_manage_apbvt(iwdev,\r\ncm_info.loc_port,\r\nI40IW_MANAGE_APBVT_ADD);\r\nif (ret)\r\ngoto error;\r\n}\r\n}\r\ncm_id->add_ref(cm_id);\r\ncm_listen_node->cm_core->stats_listen_created++;\r\nreturn 0;\r\nerror:\r\ni40iw_cm_del_listen(&iwdev->cm_core, (void *)cm_listen_node, false);\r\nreturn -EINVAL;\r\n}\r\nint i40iw_destroy_listen(struct iw_cm_id *cm_id)\r\n{\r\nstruct i40iw_device *iwdev;\r\niwdev = to_iwdev(cm_id->device);\r\nif (cm_id->provider_data)\r\ni40iw_cm_del_listen(&iwdev->cm_core, cm_id->provider_data, true);\r\nelse\r\ni40iw_pr_err("cm_id->provider_data was NULL\n");\r\ncm_id->rem_ref(cm_id);\r\nreturn 0;\r\n}\r\nstatic void i40iw_cm_event_connected(struct i40iw_cm_event *event)\r\n{\r\nstruct i40iw_qp *iwqp;\r\nstruct i40iw_device *iwdev;\r\nstruct i40iw_cm_node *cm_node;\r\nstruct i40iw_sc_dev *dev;\r\nstruct ib_qp_attr attr;\r\nstruct iw_cm_id *cm_id;\r\nint status;\r\nbool read0;\r\ncm_node = event->cm_node;\r\ncm_id = cm_node->cm_id;\r\niwqp = (struct i40iw_qp *)cm_id->provider_data;\r\niwdev = to_iwdev(iwqp->ibqp.device);\r\ndev = &iwdev->sc_dev;\r\nif (iwqp->destroyed) {\r\nstatus = -ETIMEDOUT;\r\ngoto error;\r\n}\r\ni40iw_cm_init_tsa_conn(iwqp, cm_node);\r\nread0 = (cm_node->send_rdma0_op == SEND_RDMA_READ_ZERO);\r\nif (iwqp->page)\r\niwqp->sc_qp.qp_uk.sq_base = kmap(iwqp->page);\r\ndev->iw_priv_qp_ops->qp_send_rtt(&iwqp->sc_qp, read0);\r\nif (iwqp->page)\r\nkunmap(iwqp->page);\r\nstatus = i40iw_send_cm_event(cm_node, cm_id, IW_CM_EVENT_CONNECT_REPLY, 0);\r\nif (status)\r\ni40iw_pr_err("send cm event\n");\r\nmemset(&attr, 0, sizeof(attr));\r\nattr.qp_state = IB_QPS_RTS;\r\ncm_node->qhash_set = false;\r\ni40iw_modify_qp(&iwqp->ibqp, &attr, IB_QP_STATE, NULL);\r\ncm_node->accelerated = 1;\r\nif (cm_node->accept_pend) {\r\nif (!cm_node->listener)\r\ni40iw_pr_err("listener is null for passive node\n");\r\natomic_dec(&cm_node->listener->pend_accepts_cnt);\r\ncm_node->accept_pend = 0;\r\n}\r\nreturn;\r\nerror:\r\niwqp->cm_id = NULL;\r\ncm_id->provider_data = NULL;\r\ni40iw_send_cm_event(event->cm_node,\r\ncm_id,\r\nIW_CM_EVENT_CONNECT_REPLY,\r\nstatus);\r\ncm_id->rem_ref(cm_id);\r\ni40iw_rem_ref_cm_node(event->cm_node);\r\n}\r\nstatic void i40iw_cm_event_reset(struct i40iw_cm_event *event)\r\n{\r\nstruct i40iw_cm_node *cm_node = event->cm_node;\r\nstruct iw_cm_id *cm_id = cm_node->cm_id;\r\nstruct i40iw_qp *iwqp;\r\nif (!cm_id)\r\nreturn;\r\niwqp = cm_id->provider_data;\r\nif (!iwqp)\r\nreturn;\r\ni40iw_debug(cm_node->dev,\r\nI40IW_DEBUG_CM,\r\n"reset event %p - cm_id = %p\n",\r\nevent->cm_node, cm_id);\r\niwqp->cm_id = NULL;\r\ni40iw_send_cm_event(cm_node, cm_node->cm_id, IW_CM_EVENT_DISCONNECT, -ECONNRESET);\r\ni40iw_send_cm_event(cm_node, cm_node->cm_id, IW_CM_EVENT_CLOSE, 0);\r\n}\r\nstatic void i40iw_cm_event_handler(struct work_struct *work)\r\n{\r\nstruct i40iw_cm_event *event = container_of(work,\r\nstruct i40iw_cm_event,\r\nevent_work);\r\nstruct i40iw_cm_node *cm_node;\r\nif (!event || !event->cm_node || !event->cm_node->cm_core)\r\nreturn;\r\ncm_node = event->cm_node;\r\nswitch (event->type) {\r\ncase I40IW_CM_EVENT_MPA_REQ:\r\ni40iw_send_cm_event(cm_node,\r\ncm_node->cm_id,\r\nIW_CM_EVENT_CONNECT_REQUEST,\r\n0);\r\nbreak;\r\ncase I40IW_CM_EVENT_RESET:\r\ni40iw_cm_event_reset(event);\r\nbreak;\r\ncase I40IW_CM_EVENT_CONNECTED:\r\nif (!event->cm_node->cm_id ||\r\n(event->cm_node->state != I40IW_CM_STATE_OFFLOADED))\r\nbreak;\r\ni40iw_cm_event_connected(event);\r\nbreak;\r\ncase I40IW_CM_EVENT_MPA_REJECT:\r\nif (!event->cm_node->cm_id ||\r\n(cm_node->state == I40IW_CM_STATE_OFFLOADED))\r\nbreak;\r\ni40iw_send_cm_event(cm_node,\r\ncm_node->cm_id,\r\nIW_CM_EVENT_CONNECT_REPLY,\r\n-ECONNREFUSED);\r\nbreak;\r\ncase I40IW_CM_EVENT_ABORTED:\r\nif (!event->cm_node->cm_id ||\r\n(event->cm_node->state == I40IW_CM_STATE_OFFLOADED))\r\nbreak;\r\ni40iw_event_connect_error(event);\r\nbreak;\r\ndefault:\r\ni40iw_pr_err("event type = %d\n", event->type);\r\nbreak;\r\n}\r\nevent->cm_info.cm_id->rem_ref(event->cm_info.cm_id);\r\ni40iw_rem_ref_cm_node(event->cm_node);\r\nkfree(event);\r\n}\r\nstatic void i40iw_cm_post_event(struct i40iw_cm_event *event)\r\n{\r\natomic_inc(&event->cm_node->ref_count);\r\nevent->cm_info.cm_id->add_ref(event->cm_info.cm_id);\r\nINIT_WORK(&event->event_work, i40iw_cm_event_handler);\r\nqueue_work(event->cm_node->cm_core->event_wq, &event->event_work);\r\n}\r\nstatic void i40iw_qhash_ctrl(struct i40iw_device *iwdev,\r\nstruct i40iw_cm_listener *parent_listen_node,\r\nstruct i40iw_cm_info *nfo,\r\nu32 *ipaddr, bool ipv4, bool ifup)\r\n{\r\nstruct list_head *child_listen_list = &parent_listen_node->child_listen_list;\r\nstruct i40iw_cm_listener *child_listen_node;\r\nstruct list_head *pos, *tpos;\r\nenum i40iw_status_code ret;\r\nbool node_allocated = false;\r\nenum i40iw_quad_hash_manage_type op =\r\nifup ? I40IW_QHASH_MANAGE_TYPE_ADD : I40IW_QHASH_MANAGE_TYPE_DELETE;\r\nlist_for_each_safe(pos, tpos, child_listen_list) {\r\nchild_listen_node =\r\nlist_entry(pos,\r\nstruct i40iw_cm_listener,\r\nchild_listen_list);\r\nif (!memcmp(child_listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16))\r\ngoto set_qhash;\r\n}\r\nif (!ifup)\r\nreturn;\r\nchild_listen_node = kzalloc(sizeof(*child_listen_node), GFP_ATOMIC);\r\nif (!child_listen_node)\r\nreturn;\r\nnode_allocated = true;\r\nmemcpy(child_listen_node, parent_listen_node, sizeof(*child_listen_node));\r\nmemcpy(child_listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16);\r\nset_qhash:\r\nmemcpy(nfo->loc_addr,\r\nchild_listen_node->loc_addr,\r\nsizeof(nfo->loc_addr));\r\nnfo->vlan_id = child_listen_node->vlan_id;\r\nret = i40iw_manage_qhash(iwdev, nfo,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nop,\r\nNULL, false);\r\nif (!ret) {\r\nchild_listen_node->qhash_set = ifup;\r\nif (node_allocated)\r\nlist_add(&child_listen_node->child_listen_list,\r\n&parent_listen_node->child_listen_list);\r\n} else if (node_allocated) {\r\nkfree(child_listen_node);\r\n}\r\n}\r\nvoid i40iw_cm_disconnect_all(struct i40iw_device *iwdev)\r\n{\r\nstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\r\nstruct list_head *list_core_temp;\r\nstruct list_head *list_node;\r\nstruct i40iw_cm_node *cm_node;\r\nunsigned long flags;\r\nstruct list_head connected_list;\r\nstruct ib_qp_attr attr;\r\nINIT_LIST_HEAD(&connected_list);\r\nspin_lock_irqsave(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp, &cm_core->connected_nodes) {\r\ncm_node = container_of(list_node, struct i40iw_cm_node, list);\r\natomic_inc(&cm_node->ref_count);\r\nlist_add(&cm_node->connected_entry, &connected_list);\r\n}\r\nspin_unlock_irqrestore(&cm_core->ht_lock, flags);\r\nlist_for_each_safe(list_node, list_core_temp, &connected_list) {\r\ncm_node = container_of(list_node, struct i40iw_cm_node, connected_entry);\r\nattr.qp_state = IB_QPS_ERR;\r\ni40iw_modify_qp(&cm_node->iwqp->ibqp, &attr, IB_QP_STATE, NULL);\r\ni40iw_rem_ref_cm_node(cm_node);\r\n}\r\n}\r\nvoid i40iw_if_notify(struct i40iw_device *iwdev, struct net_device *netdev,\r\nu32 *ipaddr, bool ipv4, bool ifup)\r\n{\r\nstruct i40iw_cm_core *cm_core = &iwdev->cm_core;\r\nunsigned long flags;\r\nstruct i40iw_cm_listener *listen_node;\r\nstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\r\nstruct i40iw_cm_info nfo;\r\nu16 vlan_id = rdma_vlan_dev_vlan_id(netdev);\r\nenum i40iw_status_code ret;\r\nenum i40iw_quad_hash_manage_type op =\r\nifup ? I40IW_QHASH_MANAGE_TYPE_ADD : I40IW_QHASH_MANAGE_TYPE_DELETE;\r\nspin_lock_irqsave(&cm_core->listen_list_lock, flags);\r\nlist_for_each_entry(listen_node, &cm_core->listen_nodes, list) {\r\nif (vlan_id == listen_node->vlan_id &&\r\n(!memcmp(listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16) ||\r\n!memcmp(listen_node->loc_addr, ip_zero, ipv4 ? 4 : 16))) {\r\nmemcpy(nfo.loc_addr, listen_node->loc_addr,\r\nsizeof(nfo.loc_addr));\r\nnfo.loc_port = listen_node->loc_port;\r\nnfo.ipv4 = listen_node->ipv4;\r\nnfo.vlan_id = listen_node->vlan_id;\r\nnfo.user_pri = listen_node->user_pri;\r\nif (!list_empty(&listen_node->child_listen_list)) {\r\ni40iw_qhash_ctrl(iwdev,\r\nlisten_node,\r\n&nfo,\r\nipaddr, ipv4, ifup);\r\n} else if (memcmp(listen_node->loc_addr, ip_zero,\r\nipv4 ? 4 : 16)) {\r\nret = i40iw_manage_qhash(iwdev,\r\n&nfo,\r\nI40IW_QHASH_TYPE_TCP_SYN,\r\nop,\r\nNULL,\r\nfalse);\r\nif (!ret)\r\nlisten_node->qhash_set = ifup;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\r\nif (!ifup)\r\ni40iw_cm_disconnect_all(iwdev);\r\n}
