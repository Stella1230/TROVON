static void kvp_acquire_lock(int pool)\r\n{\r\nstruct flock fl = {F_WRLCK, SEEK_SET, 0, 0, 0};\r\nfl.l_pid = getpid();\r\nif (fcntl(kvp_file_info[pool].fd, F_SETLKW, &fl) == -1) {\r\nsyslog(LOG_ERR, "Failed to acquire the lock pool: %d; error: %d %s", pool,\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nstatic void kvp_release_lock(int pool)\r\n{\r\nstruct flock fl = {F_UNLCK, SEEK_SET, 0, 0, 0};\r\nfl.l_pid = getpid();\r\nif (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {\r\nsyslog(LOG_ERR, "Failed to release the lock pool: %d; error: %d %s", pool,\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nstatic void kvp_update_file(int pool)\r\n{\r\nFILE *filep;\r\nkvp_acquire_lock(pool);\r\nfilep = fopen(kvp_file_info[pool].fname, "we");\r\nif (!filep) {\r\nsyslog(LOG_ERR, "Failed to open file, pool: %d; error: %d %s", pool,\r\nerrno, strerror(errno));\r\nkvp_release_lock(pool);\r\nexit(EXIT_FAILURE);\r\n}\r\nfwrite(kvp_file_info[pool].records, sizeof(struct kvp_record),\r\nkvp_file_info[pool].num_records, filep);\r\nif (ferror(filep) || fclose(filep)) {\r\nkvp_release_lock(pool);\r\nsyslog(LOG_ERR, "Failed to write file, pool: %d", pool);\r\nexit(EXIT_FAILURE);\r\n}\r\nkvp_release_lock(pool);\r\n}\r\nstatic void kvp_update_mem_state(int pool)\r\n{\r\nFILE *filep;\r\nsize_t records_read = 0;\r\nstruct kvp_record *record = kvp_file_info[pool].records;\r\nstruct kvp_record *readp;\r\nint num_blocks = kvp_file_info[pool].num_blocks;\r\nint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\r\nkvp_acquire_lock(pool);\r\nfilep = fopen(kvp_file_info[pool].fname, "re");\r\nif (!filep) {\r\nsyslog(LOG_ERR, "Failed to open file, pool: %d; error: %d %s", pool,\r\nerrno, strerror(errno));\r\nkvp_release_lock(pool);\r\nexit(EXIT_FAILURE);\r\n}\r\nfor (;;) {\r\nreadp = &record[records_read];\r\nrecords_read += fread(readp, sizeof(struct kvp_record),\r\nENTRIES_PER_BLOCK * num_blocks,\r\nfilep);\r\nif (ferror(filep)) {\r\nsyslog(LOG_ERR, "Failed to read file, pool: %d", pool);\r\nexit(EXIT_FAILURE);\r\n}\r\nif (!feof(filep)) {\r\nnum_blocks++;\r\nrecord = realloc(record, alloc_unit * num_blocks);\r\nif (record == NULL) {\r\nsyslog(LOG_ERR, "malloc failed");\r\nexit(EXIT_FAILURE);\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nkvp_file_info[pool].num_blocks = num_blocks;\r\nkvp_file_info[pool].records = record;\r\nkvp_file_info[pool].num_records = records_read;\r\nfclose(filep);\r\nkvp_release_lock(pool);\r\n}\r\nstatic int kvp_file_init(void)\r\n{\r\nint fd;\r\nFILE *filep;\r\nsize_t records_read;\r\nchar *fname;\r\nstruct kvp_record *record;\r\nstruct kvp_record *readp;\r\nint num_blocks;\r\nint i;\r\nint alloc_unit = sizeof(struct kvp_record) * ENTRIES_PER_BLOCK;\r\nif (access(KVP_CONFIG_LOC, F_OK)) {\r\nif (mkdir(KVP_CONFIG_LOC, 0755 )) {\r\nsyslog(LOG_ERR, "Failed to create '%s'; error: %d %s", KVP_CONFIG_LOC,\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nfor (i = 0; i < KVP_POOL_COUNT; i++) {\r\nfname = kvp_file_info[i].fname;\r\nrecords_read = 0;\r\nnum_blocks = 1;\r\nsprintf(fname, "%s/.kvp_pool_%d", KVP_CONFIG_LOC, i);\r\nfd = open(fname, O_RDWR | O_CREAT | O_CLOEXEC, 0644 );\r\nif (fd == -1)\r\nreturn 1;\r\nfilep = fopen(fname, "re");\r\nif (!filep) {\r\nclose(fd);\r\nreturn 1;\r\n}\r\nrecord = malloc(alloc_unit * num_blocks);\r\nif (record == NULL) {\r\nfclose(filep);\r\nclose(fd);\r\nreturn 1;\r\n}\r\nfor (;;) {\r\nreadp = &record[records_read];\r\nrecords_read += fread(readp, sizeof(struct kvp_record),\r\nENTRIES_PER_BLOCK,\r\nfilep);\r\nif (ferror(filep)) {\r\nsyslog(LOG_ERR, "Failed to read file, pool: %d",\r\ni);\r\nexit(EXIT_FAILURE);\r\n}\r\nif (!feof(filep)) {\r\nnum_blocks++;\r\nrecord = realloc(record, alloc_unit *\r\nnum_blocks);\r\nif (record == NULL) {\r\nfclose(filep);\r\nclose(fd);\r\nreturn 1;\r\n}\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nkvp_file_info[i].fd = fd;\r\nkvp_file_info[i].num_blocks = num_blocks;\r\nkvp_file_info[i].records = record;\r\nkvp_file_info[i].num_records = records_read;\r\nfclose(filep);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvp_key_delete(int pool, const __u8 *key, int key_size)\r\n{\r\nint i;\r\nint j, k;\r\nint num_records;\r\nstruct kvp_record *record;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nif (i == num_records) {\r\nkvp_file_info[pool].num_records--;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nj = i;\r\nk = j + 1;\r\nfor (; k < num_records; k++) {\r\nstrcpy(record[j].key, record[k].key);\r\nstrcpy(record[j].value, record[k].value);\r\nj++;\r\n}\r\nkvp_file_info[pool].num_records--;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int kvp_key_add_or_modify(int pool, const __u8 *key, int key_size,\r\nconst __u8 *value, int value_size)\r\n{\r\nint i;\r\nint num_records;\r\nstruct kvp_record *record;\r\nint num_blocks;\r\nif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\r\n(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\r\nreturn 1;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nnum_blocks = kvp_file_info[pool].num_blocks;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nmemcpy(record[i].value, value, value_size);\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nif (num_records == (ENTRIES_PER_BLOCK * num_blocks)) {\r\nrecord = realloc(record, sizeof(struct kvp_record) *\r\nENTRIES_PER_BLOCK * (num_blocks + 1));\r\nif (record == NULL)\r\nreturn 1;\r\nkvp_file_info[pool].num_blocks++;\r\n}\r\nmemcpy(record[i].value, value, value_size);\r\nmemcpy(record[i].key, key, key_size);\r\nkvp_file_info[pool].records = record;\r\nkvp_file_info[pool].num_records++;\r\nkvp_update_file(pool);\r\nreturn 0;\r\n}\r\nstatic int kvp_get_value(int pool, const __u8 *key, int key_size, __u8 *value,\r\nint value_size)\r\n{\r\nint i;\r\nint num_records;\r\nstruct kvp_record *record;\r\nif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\r\n(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\r\nreturn 1;\r\nkvp_update_mem_state(pool);\r\nnum_records = kvp_file_info[pool].num_records;\r\nrecord = kvp_file_info[pool].records;\r\nfor (i = 0; i < num_records; i++) {\r\nif (memcmp(key, record[i].key, key_size))\r\ncontinue;\r\nmemcpy(value, record[i].value, value_size);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int kvp_pool_enumerate(int pool, int index, __u8 *key, int key_size,\r\n__u8 *value, int value_size)\r\n{\r\nstruct kvp_record *record;\r\nkvp_update_mem_state(pool);\r\nrecord = kvp_file_info[pool].records;\r\nif (index >= kvp_file_info[pool].num_records) {\r\nreturn 1;\r\n}\r\nmemcpy(key, record[index].key, key_size);\r\nmemcpy(value, record[index].value, value_size);\r\nreturn 0;\r\n}\r\nvoid kvp_get_os_info(void)\r\n{\r\nFILE *file;\r\nchar *p, buf[512];\r\nuname(&uts_buf);\r\nos_version = uts_buf.release;\r\nos_build = strdup(uts_buf.release);\r\nos_name = uts_buf.sysname;\r\nprocessor_arch = uts_buf.machine;\r\np = strchr(os_version, '-');\r\nif (p)\r\n*p = '\0';\r\nfile = fopen("/etc/os-release", "r");\r\nif (file != NULL) {\r\nwhile (fgets(buf, sizeof(buf), file)) {\r\nchar *value, *q;\r\nif (buf[0] == '#')\r\ncontinue;\r\np = strchr(buf, '=');\r\nif (!p)\r\ncontinue;\r\n*p++ = 0;\r\nvalue = p;\r\nq = p;\r\nwhile (*p) {\r\nif (*p == '\\') {\r\n++p;\r\nif (!*p)\r\nbreak;\r\n*q++ = *p++;\r\n} else if (*p == '\'' || *p == '"' ||\r\n*p == '\n') {\r\n++p;\r\n} else {\r\n*q++ = *p++;\r\n}\r\n}\r\n*q = 0;\r\nif (!strcmp(buf, "NAME")) {\r\np = strdup(value);\r\nif (!p)\r\nbreak;\r\nos_name = p;\r\n} else if (!strcmp(buf, "VERSION_ID")) {\r\np = strdup(value);\r\nif (!p)\r\nbreak;\r\nos_major = p;\r\n}\r\n}\r\nfclose(file);\r\nreturn;\r\n}\r\nfile = fopen("/etc/SuSE-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nfile = fopen("/etc/redhat-release", "r");\r\nif (file != NULL)\r\ngoto kvp_osinfo_found;\r\nreturn;\r\nkvp_osinfo_found:\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_name = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (!p)\r\ngoto done;\r\nos_major = p;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = '\0';\r\np = strdup(buf);\r\nif (p)\r\nos_minor = p;\r\n}\r\n}\r\n}\r\ndone:\r\nfclose(file);\r\nreturn;\r\n}\r\nstatic char *kvp_get_if_name(char *guid)\r\n{\r\nDIR *dir;\r\nstruct dirent *entry;\r\nFILE *file;\r\nchar *p, *q, *x;\r\nchar *if_name = NULL;\r\nchar buf[256];\r\nchar *kvp_net_dir = "/sys/class/net/";\r\nchar dev_id[256];\r\ndir = opendir(kvp_net_dir);\r\nif (dir == NULL)\r\nreturn NULL;\r\nsnprintf(dev_id, sizeof(dev_id), "%s", kvp_net_dir);\r\nq = dev_id + strlen(kvp_net_dir);\r\nwhile ((entry = readdir(dir)) != NULL) {\r\n*q = '\0';\r\nstrcat(dev_id, entry->d_name);\r\nstrcat(dev_id, "/device/device_id");\r\nfile = fopen(dev_id, "r");\r\nif (file == NULL)\r\ncontinue;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\nx = strchr(p, '\n');\r\nif (x)\r\n*x = '\0';\r\nif (!strcmp(p, guid)) {\r\nif_name = strdup(entry->d_name);\r\nfclose(file);\r\nbreak;\r\n}\r\n}\r\nfclose(file);\r\n}\r\nclosedir(dir);\r\nreturn if_name;\r\n}\r\nstatic char *kvp_if_name_to_mac(char *if_name)\r\n{\r\nFILE *file;\r\nchar *p, *x;\r\nchar buf[256];\r\nchar addr_file[256];\r\nunsigned int i;\r\nchar *mac_addr = NULL;\r\nsnprintf(addr_file, sizeof(addr_file), "%s%s%s", "/sys/class/net/",\r\nif_name, "/address");\r\nfile = fopen(addr_file, "r");\r\nif (file == NULL)\r\nreturn NULL;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\nx = strchr(p, '\n');\r\nif (x)\r\n*x = '\0';\r\nfor (i = 0; i < strlen(p); i++)\r\np[i] = toupper(p[i]);\r\nmac_addr = strdup(p);\r\n}\r\nfclose(file);\r\nreturn mac_addr;\r\n}\r\nstatic char *kvp_mac_to_if_name(char *mac)\r\n{\r\nDIR *dir;\r\nstruct dirent *entry;\r\nFILE *file;\r\nchar *p, *q, *x;\r\nchar *if_name = NULL;\r\nchar buf[256];\r\nchar *kvp_net_dir = "/sys/class/net/";\r\nchar dev_id[256];\r\nunsigned int i;\r\ndir = opendir(kvp_net_dir);\r\nif (dir == NULL)\r\nreturn NULL;\r\nsnprintf(dev_id, sizeof(dev_id), "%s", kvp_net_dir);\r\nq = dev_id + strlen(kvp_net_dir);\r\nwhile ((entry = readdir(dir)) != NULL) {\r\n*q = '\0';\r\nstrcat(dev_id, entry->d_name);\r\nstrcat(dev_id, "/address");\r\nfile = fopen(dev_id, "r");\r\nif (file == NULL)\r\ncontinue;\r\np = fgets(buf, sizeof(buf), file);\r\nif (p) {\r\nx = strchr(p, '\n');\r\nif (x)\r\n*x = '\0';\r\nfor (i = 0; i < strlen(p); i++)\r\np[i] = toupper(p[i]);\r\nif (!strcmp(p, mac)) {\r\nif_name = strdup(entry->d_name);\r\nfclose(file);\r\nbreak;\r\n}\r\n}\r\nfclose(file);\r\n}\r\nclosedir(dir);\r\nreturn if_name;\r\n}\r\nstatic void kvp_process_ipconfig_file(char *cmd,\r\nchar *config_buf, unsigned int len,\r\nint element_size, int offset)\r\n{\r\nchar buf[256];\r\nchar *p;\r\nchar *x;\r\nFILE *file;\r\nfile = popen(cmd, "r");\r\nif (file == NULL)\r\nreturn;\r\nif (offset == 0)\r\nmemset(config_buf, 0, len);\r\nwhile ((p = fgets(buf, sizeof(buf), file)) != NULL) {\r\nif (len < strlen(config_buf) + element_size + 1)\r\nbreak;\r\nx = strchr(p, '\n');\r\nif (x)\r\n*x = '\0';\r\nstrcat(config_buf, p);\r\nstrcat(config_buf, ";");\r\n}\r\npclose(file);\r\n}\r\nstatic void kvp_get_ipconfig_info(char *if_name,\r\nstruct hv_kvp_ipaddr_value *buffer)\r\n{\r\nchar cmd[512];\r\nchar dhcp_info[128];\r\nchar *p;\r\nFILE *file;\r\nsprintf(cmd, "%s %s", "ip route show dev", if_name);\r\nstrcat(cmd, " | awk '/default/ {print $3 }'");\r\nkvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,\r\n(MAX_GATEWAY_SIZE * 2), INET_ADDRSTRLEN, 0);\r\nsprintf(cmd, "%s %s", "ip -f inet6 route show dev", if_name);\r\nstrcat(cmd, " | awk '/default/ {print $3 }'");\r\nkvp_process_ipconfig_file(cmd, (char *)buffer->gate_way,\r\n(MAX_GATEWAY_SIZE * 2), INET6_ADDRSTRLEN, 1);\r\nsprintf(cmd, KVP_SCRIPTS_PATH "%s", "hv_get_dns_info");\r\nkvp_process_ipconfig_file(cmd, (char *)buffer->dns_addr,\r\n(MAX_IP_ADDR_SIZE * 2), INET_ADDRSTRLEN, 0);\r\nsprintf(cmd, KVP_SCRIPTS_PATH "%s %s", "hv_get_dhcp_info", if_name);\r\nfile = popen(cmd, "r");\r\nif (file == NULL)\r\nreturn;\r\np = fgets(dhcp_info, sizeof(dhcp_info), file);\r\nif (p == NULL) {\r\npclose(file);\r\nreturn;\r\n}\r\nif (!strncmp(p, "Enabled", 7))\r\nbuffer->dhcp_enabled = 1;\r\nelse\r\nbuffer->dhcp_enabled = 0;\r\npclose(file);\r\n}\r\nstatic unsigned int hweight32(unsigned int *w)\r\n{\r\nunsigned int res = *w - ((*w >> 1) & 0x55555555);\r\nres = (res & 0x33333333) + ((res >> 2) & 0x33333333);\r\nres = (res + (res >> 4)) & 0x0F0F0F0F;\r\nres = res + (res >> 8);\r\nreturn (res + (res >> 16)) & 0x000000FF;\r\n}\r\nstatic int kvp_process_ip_address(void *addrp,\r\nint family, char *buffer,\r\nint length, int *offset)\r\n{\r\nstruct sockaddr_in *addr;\r\nstruct sockaddr_in6 *addr6;\r\nint addr_length;\r\nchar tmp[50];\r\nconst char *str;\r\nif (family == AF_INET) {\r\naddr = (struct sockaddr_in *)addrp;\r\nstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\r\naddr_length = INET_ADDRSTRLEN;\r\n} else {\r\naddr6 = (struct sockaddr_in6 *)addrp;\r\nstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\r\naddr_length = INET6_ADDRSTRLEN;\r\n}\r\nif ((length - *offset) < addr_length + 2)\r\nreturn HV_E_FAIL;\r\nif (str == NULL) {\r\nstrcpy(buffer, "inet_ntop failed\n");\r\nreturn HV_E_FAIL;\r\n}\r\nif (*offset == 0)\r\nstrcpy(buffer, tmp);\r\nelse {\r\nstrcat(buffer, ";");\r\nstrcat(buffer, tmp);\r\n}\r\n*offset += strlen(str) + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nkvp_get_ip_info(int family, char *if_name, int op,\r\nvoid *out_buffer, unsigned int length)\r\n{\r\nstruct ifaddrs *ifap;\r\nstruct ifaddrs *curp;\r\nint offset = 0;\r\nint sn_offset = 0;\r\nint error = 0;\r\nchar *buffer;\r\nstruct hv_kvp_ipaddr_value *ip_buffer;\r\nchar cidr_mask[5];\r\nint weight;\r\nint i;\r\nunsigned int *w;\r\nchar *sn_str;\r\nstruct sockaddr_in6 *addr6;\r\nif (op == KVP_OP_ENUMERATE) {\r\nbuffer = out_buffer;\r\n} else {\r\nip_buffer = out_buffer;\r\nbuffer = (char *)ip_buffer->ip_addr;\r\nip_buffer->addr_family = 0;\r\n}\r\nif (getifaddrs(&ifap)) {\r\nstrcpy(buffer, "getifaddrs failed\n");\r\nreturn HV_E_FAIL;\r\n}\r\ncurp = ifap;\r\nwhile (curp != NULL) {\r\nif (curp->ifa_addr == NULL) {\r\ncurp = curp->ifa_next;\r\ncontinue;\r\n}\r\nif ((if_name != NULL) &&\r\n(strncmp(curp->ifa_name, if_name, strlen(if_name)))) {\r\ncurp = curp->ifa_next;\r\ncontinue;\r\n}\r\nif ((((family != 0) &&\r\n(curp->ifa_addr->sa_family != family))) ||\r\n(curp->ifa_flags & IFF_LOOPBACK)) {\r\ncurp = curp->ifa_next;\r\ncontinue;\r\n}\r\nif ((curp->ifa_addr->sa_family != AF_INET) &&\r\n(curp->ifa_addr->sa_family != AF_INET6)) {\r\ncurp = curp->ifa_next;\r\ncontinue;\r\n}\r\nif (op == KVP_OP_GET_IP_INFO) {\r\nif (curp->ifa_addr->sa_family == AF_INET) {\r\nip_buffer->addr_family |= ADDR_FAMILY_IPV4;\r\nerror = kvp_process_ip_address(\r\ncurp->ifa_netmask,\r\nAF_INET,\r\n(char *)\r\nip_buffer->sub_net,\r\nlength,\r\n&sn_offset);\r\nif (error)\r\ngoto gather_ipaddr;\r\n} else {\r\nip_buffer->addr_family |= ADDR_FAMILY_IPV6;\r\nweight = 0;\r\nsn_str = (char *)ip_buffer->sub_net;\r\naddr6 = (struct sockaddr_in6 *)\r\ncurp->ifa_netmask;\r\nw = addr6->sin6_addr.s6_addr32;\r\nfor (i = 0; i < 4; i++)\r\nweight += hweight32(&w[i]);\r\nsprintf(cidr_mask, "/%d", weight);\r\nif (length < sn_offset + strlen(cidr_mask) + 1)\r\ngoto gather_ipaddr;\r\nif (sn_offset == 0)\r\nstrcpy(sn_str, cidr_mask);\r\nelse {\r\nstrcat((char *)ip_buffer->sub_net, ";");\r\nstrcat(sn_str, cidr_mask);\r\n}\r\nsn_offset += strlen(sn_str) + 1;\r\n}\r\nkvp_get_ipconfig_info(if_name, ip_buffer);\r\n}\r\ngather_ipaddr:\r\nerror = kvp_process_ip_address(curp->ifa_addr,\r\ncurp->ifa_addr->sa_family,\r\nbuffer,\r\nlength, &offset);\r\nif (error)\r\ngoto getaddr_done;\r\ncurp = curp->ifa_next;\r\n}\r\ngetaddr_done:\r\nfreeifaddrs(ifap);\r\nreturn error;\r\n}\r\nstatic int expand_ipv6(char *addr, int type)\r\n{\r\nint ret;\r\nstruct in6_addr v6_addr;\r\nret = inet_pton(AF_INET6, addr, &v6_addr);\r\nif (ret != 1) {\r\nif (type == NETMASK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nsprintf(addr, "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:"\r\n"%02x%02x:%02x%02x:%02x%02x",\r\n(int)v6_addr.s6_addr[0], (int)v6_addr.s6_addr[1],\r\n(int)v6_addr.s6_addr[2], (int)v6_addr.s6_addr[3],\r\n(int)v6_addr.s6_addr[4], (int)v6_addr.s6_addr[5],\r\n(int)v6_addr.s6_addr[6], (int)v6_addr.s6_addr[7],\r\n(int)v6_addr.s6_addr[8], (int)v6_addr.s6_addr[9],\r\n(int)v6_addr.s6_addr[10], (int)v6_addr.s6_addr[11],\r\n(int)v6_addr.s6_addr[12], (int)v6_addr.s6_addr[13],\r\n(int)v6_addr.s6_addr[14], (int)v6_addr.s6_addr[15]);\r\nreturn 1;\r\n}\r\nstatic int is_ipv4(char *addr)\r\n{\r\nint ret;\r\nstruct in_addr ipv4_addr;\r\nret = inet_pton(AF_INET, addr, &ipv4_addr);\r\nif (ret == 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int parse_ip_val_buffer(char *in_buf, int *offset,\r\nchar *out_buf, int out_len)\r\n{\r\nchar *x;\r\nchar *start;\r\nstart = in_buf + *offset;\r\nx = strchr(start, ';');\r\nif (x)\r\n*x = 0;\r\nelse\r\nx = start + strlen(start);\r\nif (strlen(start) != 0) {\r\nint i = 0;\r\nwhile (start[i] == ' ')\r\ni++;\r\nif ((x - start) <= out_len) {\r\nstrcpy(out_buf, (start + i));\r\n*offset += (x - start) + 1;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvp_write_file(FILE *f, char *s1, char *s2, char *s3)\r\n{\r\nint ret;\r\nret = fprintf(f, "%s%s%s%s\n", s1, s2, "=", s3);\r\nif (ret < 0)\r\nreturn HV_E_FAIL;\r\nreturn 0;\r\n}\r\nstatic int process_ip_string(FILE *f, char *ip_string, int type)\r\n{\r\nint error = 0;\r\nchar addr[INET6_ADDRSTRLEN];\r\nint i = 0;\r\nint j = 0;\r\nchar str[256];\r\nchar sub_str[10];\r\nint offset = 0;\r\nmemset(addr, 0, sizeof(addr));\r\nwhile (parse_ip_val_buffer(ip_string, &offset, addr,\r\n(MAX_IP_ADDR_SIZE * 2))) {\r\nsub_str[0] = 0;\r\nif (is_ipv4(addr)) {\r\nswitch (type) {\r\ncase IPADDR:\r\nsnprintf(str, sizeof(str), "%s", "IPADDR");\r\nbreak;\r\ncase NETMASK:\r\nsnprintf(str, sizeof(str), "%s", "NETMASK");\r\nbreak;\r\ncase GATEWAY:\r\nsnprintf(str, sizeof(str), "%s", "GATEWAY");\r\nbreak;\r\ncase DNS:\r\nsnprintf(str, sizeof(str), "%s", "DNS");\r\nbreak;\r\n}\r\nif (type == DNS) {\r\nsnprintf(sub_str, sizeof(sub_str), "%d", ++i);\r\n} else if (type == GATEWAY && i == 0) {\r\n++i;\r\n} else {\r\nsnprintf(sub_str, sizeof(sub_str), "%d", i++);\r\n}\r\n} else if (expand_ipv6(addr, type)) {\r\nswitch (type) {\r\ncase IPADDR:\r\nsnprintf(str, sizeof(str), "%s", "IPV6ADDR");\r\nbreak;\r\ncase NETMASK:\r\nsnprintf(str, sizeof(str), "%s", "IPV6NETMASK");\r\nbreak;\r\ncase GATEWAY:\r\nsnprintf(str, sizeof(str), "%s",\r\n"IPV6_DEFAULTGW");\r\nbreak;\r\ncase DNS:\r\nsnprintf(str, sizeof(str), "%s", "DNS");\r\nbreak;\r\n}\r\nif (type == DNS) {\r\nsnprintf(sub_str, sizeof(sub_str), "%d", ++i);\r\n} else if (j == 0) {\r\n++j;\r\n} else {\r\nsnprintf(sub_str, sizeof(sub_str), "_%d", j++);\r\n}\r\n} else {\r\nreturn HV_INVALIDARG;\r\n}\r\nerror = kvp_write_file(f, str, sub_str, addr);\r\nif (error)\r\nreturn error;\r\nmemset(addr, 0, sizeof(addr));\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvp_set_ip_info(char *if_name, struct hv_kvp_ipaddr_value *new_val)\r\n{\r\nint error = 0;\r\nchar if_file[128];\r\nFILE *file;\r\nchar cmd[512];\r\nchar *mac_addr;\r\nsnprintf(if_file, sizeof(if_file), "%s%s%s", KVP_CONFIG_LOC,\r\n"/ifcfg-", if_name);\r\nfile = fopen(if_file, "w");\r\nif (file == NULL) {\r\nsyslog(LOG_ERR, "Failed to open config file; error: %d %s",\r\nerrno, strerror(errno));\r\nreturn HV_E_FAIL;\r\n}\r\nmac_addr = kvp_if_name_to_mac(if_name);\r\nif (mac_addr == NULL) {\r\nerror = HV_E_FAIL;\r\ngoto setval_error;\r\n}\r\nerror = kvp_write_file(file, "HWADDR", "", mac_addr);\r\nfree(mac_addr);\r\nif (error)\r\ngoto setval_error;\r\nerror = kvp_write_file(file, "DEVICE", "", if_name);\r\nif (error)\r\ngoto setval_error;\r\nif (new_val->dhcp_enabled) {\r\nerror = kvp_write_file(file, "BOOTPROTO", "", "dhcp");\r\nif (error)\r\ngoto setval_error;\r\n} else {\r\nerror = kvp_write_file(file, "BOOTPROTO", "", "none");\r\nif (error)\r\ngoto setval_error;\r\n}\r\nerror = process_ip_string(file, (char *)new_val->ip_addr, IPADDR);\r\nif (error)\r\ngoto setval_error;\r\nerror = process_ip_string(file, (char *)new_val->sub_net, NETMASK);\r\nif (error)\r\ngoto setval_error;\r\nerror = process_ip_string(file, (char *)new_val->gate_way, GATEWAY);\r\nif (error)\r\ngoto setval_error;\r\nerror = process_ip_string(file, (char *)new_val->dns_addr, DNS);\r\nif (error)\r\ngoto setval_error;\r\nfclose(file);\r\nsnprintf(cmd, sizeof(cmd), KVP_SCRIPTS_PATH "%s %s",\r\n"hv_set_ifconfig", if_file);\r\nif (system(cmd)) {\r\nsyslog(LOG_ERR, "Failed to execute cmd '%s'; error: %d %s",\r\ncmd, errno, strerror(errno));\r\nreturn HV_E_FAIL;\r\n}\r\nreturn 0;\r\nsetval_error:\r\nsyslog(LOG_ERR, "Failed to write config file");\r\nfclose(file);\r\nreturn error;\r\n}\r\nstatic void\r\nkvp_get_domain_name(char *buffer, int length)\r\n{\r\nstruct addrinfo hints, *info ;\r\nint error = 0;\r\ngethostname(buffer, length);\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = AF_INET;\r\nhints.ai_socktype = SOCK_STREAM;\r\nhints.ai_flags = AI_CANONNAME;\r\nerror = getaddrinfo(buffer, NULL, &hints, &info);\r\nif (error != 0) {\r\nsnprintf(buffer, length, "getaddrinfo failed: 0x%x %s",\r\nerror, gai_strerror(error));\r\nreturn;\r\n}\r\nsnprintf(buffer, length, "%s", info->ai_canonname);\r\nfreeaddrinfo(info);\r\n}\r\nvoid print_usage(char *argv[])\r\n{\r\nfprintf(stderr, "Usage: %s [options]\n"\r\n"Options are:\n"\r\n" -n, --no-daemon stay in foreground, don't daemonize\n"\r\n" -h, --help print this help\n", argv[0]);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint kvp_fd, len;\r\nint error;\r\nstruct pollfd pfd;\r\nchar *p;\r\nstruct hv_kvp_msg hv_msg[1];\r\nchar *key_value;\r\nchar *key_name;\r\nint op;\r\nint pool;\r\nchar *if_name;\r\nstruct hv_kvp_ipaddr_value *kvp_ip_val;\r\nint daemonize = 1, long_index = 0, opt;\r\nstatic struct option long_options[] = {\r\n{"help", no_argument, 0, 'h' },\r\n{"no-daemon", no_argument, 0, 'n' },\r\n{0, 0, 0, 0 }\r\n};\r\nwhile ((opt = getopt_long(argc, argv, "hn", long_options,\r\n&long_index)) != -1) {\r\nswitch (opt) {\r\ncase 'n':\r\ndaemonize = 0;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nprint_usage(argv);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nif (daemonize && daemon(1, 0))\r\nreturn 1;\r\nopenlog("KVP", 0, LOG_USER);\r\nsyslog(LOG_INFO, "KVP starting; pid is:%d", getpid());\r\nkvp_fd = open("/dev/vmbus/hv_kvp", O_RDWR | O_CLOEXEC);\r\nif (kvp_fd < 0) {\r\nsyslog(LOG_ERR, "open /dev/vmbus/hv_kvp failed; error: %d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\nkvp_get_os_info();\r\nkvp_get_domain_name(full_domain_name, sizeof(full_domain_name));\r\nif (kvp_file_init()) {\r\nsyslog(LOG_ERR, "Failed to initialize the pools");\r\nexit(EXIT_FAILURE);\r\n}\r\nhv_msg->kvp_hdr.operation = KVP_OP_REGISTER1;\r\nlen = write(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\r\nif (len != sizeof(struct hv_kvp_msg)) {\r\nsyslog(LOG_ERR, "registration to kernel failed; error: %d %s",\r\nerrno, strerror(errno));\r\nclose(kvp_fd);\r\nexit(EXIT_FAILURE);\r\n}\r\npfd.fd = kvp_fd;\r\nwhile (1) {\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\nif (poll(&pfd, 1, -1) < 0) {\r\nsyslog(LOG_ERR, "poll failed; error: %d %s", errno, strerror(errno));\r\nif (errno == EINVAL) {\r\nclose(kvp_fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nelse\r\ncontinue;\r\n}\r\nlen = read(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\r\nif (len != sizeof(struct hv_kvp_msg)) {\r\nsyslog(LOG_ERR, "read failed; error:%d %s",\r\nerrno, strerror(errno));\r\nclose(kvp_fd);\r\nreturn EXIT_FAILURE;\r\n}\r\nop = hv_msg->kvp_hdr.operation;\r\npool = hv_msg->kvp_hdr.pool;\r\nhv_msg->error = HV_S_OK;\r\nif ((in_hand_shake) && (op == KVP_OP_REGISTER1)) {\r\nin_hand_shake = 0;\r\np = (char *)hv_msg->body.kvp_register.version;\r\nlic_version = malloc(strlen(p) + 1);\r\nif (lic_version) {\r\nstrcpy(lic_version, p);\r\nsyslog(LOG_INFO, "KVP LIC Version: %s",\r\nlic_version);\r\n} else {\r\nsyslog(LOG_ERR, "malloc failed");\r\n}\r\ncontinue;\r\n}\r\nswitch (op) {\r\ncase KVP_OP_GET_IP_INFO:\r\nkvp_ip_val = &hv_msg->body.kvp_ip_val;\r\nif_name =\r\nkvp_mac_to_if_name((char *)kvp_ip_val->adapter_id);\r\nif (if_name == NULL) {\r\nhv_msg->error = HV_E_FAIL;\r\nbreak;\r\n}\r\nerror = kvp_get_ip_info(\r\n0, if_name, KVP_OP_GET_IP_INFO,\r\nkvp_ip_val,\r\n(MAX_IP_ADDR_SIZE * 2));\r\nif (error)\r\nhv_msg->error = error;\r\nfree(if_name);\r\nbreak;\r\ncase KVP_OP_SET_IP_INFO:\r\nkvp_ip_val = &hv_msg->body.kvp_ip_val;\r\nif_name = kvp_get_if_name(\r\n(char *)kvp_ip_val->adapter_id);\r\nif (if_name == NULL) {\r\nhv_msg->error = HV_GUID_NOTFOUND;\r\nbreak;\r\n}\r\nerror = kvp_set_ip_info(if_name, kvp_ip_val);\r\nif (error)\r\nhv_msg->error = error;\r\nfree(if_name);\r\nbreak;\r\ncase KVP_OP_SET:\r\nif (kvp_key_add_or_modify(pool,\r\nhv_msg->body.kvp_set.data.key,\r\nhv_msg->body.kvp_set.data.key_size,\r\nhv_msg->body.kvp_set.data.value,\r\nhv_msg->body.kvp_set.data.value_size))\r\nhv_msg->error = HV_S_CONT;\r\nbreak;\r\ncase KVP_OP_GET:\r\nif (kvp_get_value(pool,\r\nhv_msg->body.kvp_set.data.key,\r\nhv_msg->body.kvp_set.data.key_size,\r\nhv_msg->body.kvp_set.data.value,\r\nhv_msg->body.kvp_set.data.value_size))\r\nhv_msg->error = HV_S_CONT;\r\nbreak;\r\ncase KVP_OP_DELETE:\r\nif (kvp_key_delete(pool,\r\nhv_msg->body.kvp_delete.key,\r\nhv_msg->body.kvp_delete.key_size))\r\nhv_msg->error = HV_S_CONT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (op != KVP_OP_ENUMERATE)\r\ngoto kvp_done;\r\nif (pool != KVP_POOL_AUTO) {\r\nif (kvp_pool_enumerate(pool,\r\nhv_msg->body.kvp_enum_data.index,\r\nhv_msg->body.kvp_enum_data.data.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE,\r\nhv_msg->body.kvp_enum_data.data.value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE))\r\nhv_msg->error = HV_S_CONT;\r\ngoto kvp_done;\r\n}\r\nkey_name = (char *)hv_msg->body.kvp_enum_data.data.key;\r\nkey_value = (char *)hv_msg->body.kvp_enum_data.data.value;\r\nswitch (hv_msg->body.kvp_enum_data.index) {\r\ncase FullyQualifiedDomainName:\r\nstrcpy(key_value, full_domain_name);\r\nstrcpy(key_name, "FullyQualifiedDomainName");\r\nbreak;\r\ncase IntegrationServicesVersion:\r\nstrcpy(key_name, "IntegrationServicesVersion");\r\nstrcpy(key_value, lic_version);\r\nbreak;\r\ncase NetworkAddressIPv4:\r\nkvp_get_ip_info(AF_INET, NULL, KVP_OP_ENUMERATE,\r\nkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv4");\r\nbreak;\r\ncase NetworkAddressIPv6:\r\nkvp_get_ip_info(AF_INET6, NULL, KVP_OP_ENUMERATE,\r\nkey_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE);\r\nstrcpy(key_name, "NetworkAddressIPv6");\r\nbreak;\r\ncase OSBuildNumber:\r\nstrcpy(key_value, os_build);\r\nstrcpy(key_name, "OSBuildNumber");\r\nbreak;\r\ncase OSName:\r\nstrcpy(key_value, os_name);\r\nstrcpy(key_name, "OSName");\r\nbreak;\r\ncase OSMajorVersion:\r\nstrcpy(key_value, os_major);\r\nstrcpy(key_name, "OSMajorVersion");\r\nbreak;\r\ncase OSMinorVersion:\r\nstrcpy(key_value, os_minor);\r\nstrcpy(key_name, "OSMinorVersion");\r\nbreak;\r\ncase OSVersion:\r\nstrcpy(key_value, os_version);\r\nstrcpy(key_name, "OSVersion");\r\nbreak;\r\ncase ProcessorArchitecture:\r\nstrcpy(key_value, processor_arch);\r\nstrcpy(key_name, "ProcessorArchitecture");\r\nbreak;\r\ndefault:\r\nhv_msg->error = HV_S_CONT;\r\nbreak;\r\n}\r\nkvp_done:\r\nlen = write(kvp_fd, hv_msg, sizeof(struct hv_kvp_msg));\r\nif (len != sizeof(struct hv_kvp_msg)) {\r\nsyslog(LOG_ERR, "write failed; error: %d %s", errno,\r\nstrerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nclose(kvp_fd);\r\nexit(0);\r\n}
