static void ipgre_err(struct sk_buff *skb, u32 info,\r\nconst struct tnl_ptk_info *tpi)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn;\r\nconst struct iphdr *iph;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nunsigned int data_len = 0;\r\nstruct ip_tunnel *t;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_PARAMETERPROB:\r\nreturn;\r\ncase ICMP_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMP_SR_FAILED:\r\ncase ICMP_PORT_UNREACH:\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nif (code != ICMP_EXC_TTL)\r\nreturn;\r\ndata_len = icmp_hdr(skb)->un.reserved[1] * 4;\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nbreak;\r\n}\r\nif (tpi->proto == htons(ETH_P_TEB))\r\nitn = net_generic(net, gre_tap_net_id);\r\nelse\r\nitn = net_generic(net, ipgre_net_id);\r\niph = (const struct iphdr *)(icmp_hdr(skb) + 1);\r\nt = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\r\niph->daddr, iph->saddr, tpi->key);\r\nif (!t)\r\nreturn;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tpi->proto == htons(ETH_P_IPV6) &&\r\n!ip6_err_gen_icmpv6_unreach(skb, iph->ihl * 4 + tpi->hdr_len,\r\ntype, data_len))\r\nreturn;\r\n#endif\r\nif (t->parms.iph.daddr == 0 ||\r\nipv4_is_multicast(t->parms.iph.daddr))\r\nreturn;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\nreturn;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\n}\r\nstatic void gre_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct iphdr *iph = (struct iphdr *)skb->data;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct tnl_ptk_info tpi;\r\nbool csum_err = false;\r\nif (gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IP),\r\niph->ihl * 4) < 0) {\r\nif (!csum_err)\r\nreturn;\r\n}\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nskb->dev->ifindex, 0, IPPROTO_GRE, 0);\r\nreturn;\r\n}\r\nif (type == ICMP_REDIRECT) {\r\nipv4_redirect(skb, dev_net(skb->dev), skb->dev->ifindex, 0,\r\nIPPROTO_GRE, 0);\r\nreturn;\r\n}\r\nipgre_err(skb, info, &tpi);\r\n}\r\nstatic int __ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,\r\nstruct ip_tunnel_net *itn, int hdr_len, bool raw_proto)\r\n{\r\nstruct metadata_dst *tun_dst = NULL;\r\nconst struct iphdr *iph;\r\nstruct ip_tunnel *tunnel;\r\niph = ip_hdr(skb);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\r\niph->saddr, iph->daddr, tpi->key);\r\nif (tunnel) {\r\nif (__iptunnel_pull_header(skb, hdr_len, tpi->proto,\r\nraw_proto, false) < 0)\r\ngoto drop;\r\nif (tunnel->dev->type != ARPHRD_NONE)\r\nskb_pop_mac_header(skb);\r\nelse\r\nskb_reset_mac_header(skb);\r\nif (tunnel->collect_md) {\r\n__be16 flags;\r\n__be64 tun_id;\r\nflags = tpi->flags & (TUNNEL_CSUM | TUNNEL_KEY);\r\ntun_id = key32_to_tunnel_id(tpi->key);\r\ntun_dst = ip_tun_rx_dst(skb, flags, tun_id, 0);\r\nif (!tun_dst)\r\nreturn PACKET_REJECT;\r\n}\r\nip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\r\nreturn PACKET_RCVD;\r\n}\r\nreturn PACKET_NEXT;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn PACKET_RCVD;\r\n}\r\nstatic int ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,\r\nint hdr_len)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn;\r\nint res;\r\nif (tpi->proto == htons(ETH_P_TEB))\r\nitn = net_generic(net, gre_tap_net_id);\r\nelse\r\nitn = net_generic(net, ipgre_net_id);\r\nres = __ipgre_rcv(skb, tpi, itn, hdr_len, false);\r\nif (res == PACKET_NEXT && tpi->proto == htons(ETH_P_TEB)) {\r\nitn = net_generic(net, ipgre_net_id);\r\nres = __ipgre_rcv(skb, tpi, itn, hdr_len, true);\r\n}\r\nreturn res;\r\n}\r\nstatic int gre_rcv(struct sk_buff *skb)\r\n{\r\nstruct tnl_ptk_info tpi;\r\nbool csum_err = false;\r\nint hdr_len;\r\n#ifdef CONFIG_NET_IPGRE_BROADCAST\r\nif (ipv4_is_multicast(ip_hdr(skb)->daddr)) {\r\nif (rt_is_output_route(skb_rtable(skb)))\r\ngoto drop;\r\n}\r\n#endif\r\nhdr_len = gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IP), 0);\r\nif (hdr_len < 0)\r\ngoto drop;\r\nif (ipgre_rcv(skb, &tpi, hdr_len) == PACKET_RCVD)\r\nreturn 0;\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void __gre_xmit(struct sk_buff *skb, struct net_device *dev,\r\nconst struct iphdr *tnl_params,\r\n__be16 proto)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nif (tunnel->parms.o_flags & TUNNEL_SEQ)\r\ntunnel->o_seqno++;\r\ngre_build_header(skb, tunnel->tun_hlen,\r\ntunnel->parms.o_flags, proto, tunnel->parms.o_key,\r\nhtonl(tunnel->o_seqno));\r\nip_tunnel_xmit(skb, dev, tnl_params, tnl_params->protocol);\r\n}\r\nstatic int gre_handle_offloads(struct sk_buff *skb, bool csum)\r\n{\r\nreturn iptunnel_handle_offloads(skb, csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);\r\n}\r\nstatic struct rtable *gre_get_rt(struct sk_buff *skb,\r\nstruct net_device *dev,\r\nstruct flowi4 *fl,\r\nconst struct ip_tunnel_key *key)\r\n{\r\nstruct net *net = dev_net(dev);\r\nmemset(fl, 0, sizeof(*fl));\r\nfl->daddr = key->u.ipv4.dst;\r\nfl->saddr = key->u.ipv4.src;\r\nfl->flowi4_tos = RT_TOS(key->tos);\r\nfl->flowi4_mark = skb->mark;\r\nfl->flowi4_proto = IPPROTO_GRE;\r\nreturn ip_route_output_key(net, fl);\r\n}\r\nstatic void gre_fb_xmit(struct sk_buff *skb, struct net_device *dev,\r\n__be16 proto)\r\n{\r\nstruct ip_tunnel_info *tun_info;\r\nconst struct ip_tunnel_key *key;\r\nstruct rtable *rt = NULL;\r\nstruct flowi4 fl;\r\nint min_headroom;\r\nint tunnel_hlen;\r\n__be16 df, flags;\r\nbool use_cache;\r\nint err;\r\ntun_info = skb_tunnel_info(skb);\r\nif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\r\nip_tunnel_info_af(tun_info) != AF_INET))\r\ngoto err_free_skb;\r\nkey = &tun_info->key;\r\nuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\r\nif (use_cache)\r\nrt = dst_cache_get_ip4(&tun_info->dst_cache, &fl.saddr);\r\nif (!rt) {\r\nrt = gre_get_rt(skb, dev, &fl, key);\r\nif (IS_ERR(rt))\r\ngoto err_free_skb;\r\nif (use_cache)\r\ndst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\r\nfl.saddr);\r\n}\r\ntunnel_hlen = gre_calc_hlen(key->tun_flags);\r\nmin_headroom = LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len\r\n+ tunnel_hlen + sizeof(struct iphdr);\r\nif (skb_headroom(skb) < min_headroom || skb_header_cloned(skb)) {\r\nint head_delta = SKB_DATA_ALIGN(min_headroom -\r\nskb_headroom(skb) +\r\n16);\r\nerr = pskb_expand_head(skb, max_t(int, head_delta, 0),\r\n0, GFP_ATOMIC);\r\nif (unlikely(err))\r\ngoto err_free_rt;\r\n}\r\nif (gre_handle_offloads(skb, !!(tun_info->key.tun_flags & TUNNEL_CSUM)))\r\ngoto err_free_rt;\r\nflags = tun_info->key.tun_flags & (TUNNEL_CSUM | TUNNEL_KEY);\r\ngre_build_header(skb, tunnel_hlen, flags, proto,\r\ntunnel_id_to_key32(tun_info->key.tun_id), 0);\r\ndf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\r\niptunnel_xmit(skb->sk, rt, skb, fl.saddr, key->u.ipv4.dst, IPPROTO_GRE,\r\nkey->tos, key->ttl, df, false);\r\nreturn;\r\nerr_free_rt:\r\nip_rt_put(rt);\r\nerr_free_skb:\r\nkfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\n}\r\nstatic int gre_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct ip_tunnel_info *info = skb_tunnel_info(skb);\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nif (ip_tunnel_info_af(info) != AF_INET)\r\nreturn -EINVAL;\r\nrt = gre_get_rt(skb, dev, &fl4, &info->key);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\nip_rt_put(rt);\r\ninfo->key.u.ipv4.src = fl4.saddr;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ipgre_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tnl_params;\r\nif (tunnel->collect_md) {\r\ngre_fb_xmit(skb, dev, skb->protocol);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (dev->header_ops) {\r\nif (skb_cow_head(skb, dev->needed_headroom -\r\n(tunnel->hlen + sizeof(struct iphdr))))\r\ngoto free_skb;\r\ntnl_params = (const struct iphdr *)skb->data;\r\nskb_pull(skb, tunnel->hlen + sizeof(struct iphdr));\r\nskb_reset_mac_header(skb);\r\n} else {\r\nif (skb_cow_head(skb, dev->needed_headroom))\r\ngoto free_skb;\r\ntnl_params = &tunnel->parms.iph;\r\n}\r\nif (gre_handle_offloads(skb, !!(tunnel->parms.o_flags & TUNNEL_CSUM)))\r\ngoto free_skb;\r\n__gre_xmit(skb, dev, tnl_params, skb->protocol);\r\nreturn NETDEV_TX_OK;\r\nfree_skb:\r\nkfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t gre_tap_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nif (tunnel->collect_md) {\r\ngre_fb_xmit(skb, dev, htons(ETH_P_TEB));\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (gre_handle_offloads(skb, !!(tunnel->parms.o_flags & TUNNEL_CSUM)))\r\ngoto free_skb;\r\nif (skb_cow_head(skb, dev->needed_headroom))\r\ngoto free_skb;\r\n__gre_xmit(skb, dev, &tunnel->parms.iph, htons(ETH_P_TEB));\r\nreturn NETDEV_TX_OK;\r\nfree_skb:\r\nkfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ipgre_tunnel_ioctl(struct net_device *dev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nint err;\r\nstruct ip_tunnel_parm p;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nreturn -EFAULT;\r\nif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_GRE ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)) ||\r\n((p.i_flags|p.o_flags)&(GRE_VERSION|GRE_ROUTING)))\r\nreturn -EINVAL;\r\n}\r\np.i_flags = gre_flags_to_tnl_flags(p.i_flags);\r\np.o_flags = gre_flags_to_tnl_flags(p.o_flags);\r\nerr = ip_tunnel_ioctl(dev, &p, cmd);\r\nif (err)\r\nreturn err;\r\np.i_flags = gre_tnl_flags_to_gre_flags(p.i_flags);\r\np.o_flags = gre_tnl_flags_to_gre_flags(p.o_flags);\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ipgre_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned int len)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct iphdr *iph;\r\nstruct gre_base_hdr *greh;\r\niph = (struct iphdr *)skb_push(skb, t->hlen + sizeof(*iph));\r\ngreh = (struct gre_base_hdr *)(iph+1);\r\ngreh->flags = gre_tnl_flags_to_gre_flags(t->parms.o_flags);\r\ngreh->protocol = htons(type);\r\nmemcpy(iph, &t->parms.iph, sizeof(struct iphdr));\r\nif (saddr)\r\nmemcpy(&iph->saddr, saddr, 4);\r\nif (daddr)\r\nmemcpy(&iph->daddr, daddr, 4);\r\nif (iph->daddr)\r\nreturn t->hlen + sizeof(*iph);\r\nreturn -(t->hlen + sizeof(*iph));\r\n}\r\nstatic int ipgre_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst struct iphdr *iph = (const struct iphdr *) skb_mac_header(skb);\r\nmemcpy(haddr, &iph->saddr, 4);\r\nreturn 4;\r\n}\r\nstatic int ipgre_open(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nif (ipv4_is_multicast(t->parms.iph.daddr)) {\r\nstruct flowi4 fl4;\r\nstruct rtable *rt;\r\nrt = ip_route_output_gre(t->net, &fl4,\r\nt->parms.iph.daddr,\r\nt->parms.iph.saddr,\r\nt->parms.o_key,\r\nRT_TOS(t->parms.iph.tos),\r\nt->parms.link);\r\nif (IS_ERR(rt))\r\nreturn -EADDRNOTAVAIL;\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (!__in_dev_get_rtnl(dev))\r\nreturn -EADDRNOTAVAIL;\r\nt->mlink = dev->ifindex;\r\nip_mc_inc_group(__in_dev_get_rtnl(dev), t->parms.iph.daddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipgre_close(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\r\nstruct in_device *in_dev;\r\nin_dev = inetdev_by_index(t->net, t->mlink);\r\nif (in_dev)\r\nip_mc_dec_group(in_dev, t->parms.iph.daddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipgre_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ipgre_netdev_ops;\r\ndev->type = ARPHRD_IPGRE;\r\nip_tunnel_setup(dev, ipgre_net_id);\r\n}\r\nstatic void __gre_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel;\r\nint t_hlen;\r\ntunnel = netdev_priv(dev);\r\ntunnel->tun_hlen = gre_calc_hlen(tunnel->parms.o_flags);\r\ntunnel->parms.iph.protocol = IPPROTO_GRE;\r\ntunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen;\r\nt_hlen = tunnel->hlen + sizeof(struct iphdr);\r\ndev->needed_headroom = LL_MAX_HEADER + t_hlen + 4;\r\ndev->mtu = ETH_DATA_LEN - t_hlen - 4;\r\ndev->features |= GRE_FEATURES;\r\ndev->hw_features |= GRE_FEATURES;\r\nif (!(tunnel->parms.o_flags & TUNNEL_SEQ)) {\r\nif (!(tunnel->parms.o_flags & TUNNEL_CSUM) ||\r\n(tunnel->encap.type == TUNNEL_ENCAP_NONE)) {\r\ndev->features |= NETIF_F_GSO_SOFTWARE;\r\ndev->hw_features |= NETIF_F_GSO_SOFTWARE;\r\n}\r\ndev->features |= NETIF_F_LLTX;\r\n}\r\n}\r\nstatic int ipgre_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\n__gre_tunnel_init(dev);\r\nmemcpy(dev->dev_addr, &iph->saddr, 4);\r\nmemcpy(dev->broadcast, &iph->daddr, 4);\r\ndev->flags = IFF_NOARP;\r\nnetif_keep_dst(dev);\r\ndev->addr_len = 4;\r\nif (iph->daddr && !tunnel->collect_md) {\r\n#ifdef CONFIG_NET_IPGRE_BROADCAST\r\nif (ipv4_is_multicast(iph->daddr)) {\r\nif (!iph->saddr)\r\nreturn -EINVAL;\r\ndev->flags = IFF_BROADCAST;\r\ndev->header_ops = &ipgre_header_ops;\r\n}\r\n#endif\r\n} else if (!tunnel->collect_md) {\r\ndev->header_ops = &ipgre_header_ops;\r\n}\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic int __net_init ipgre_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, ipgre_net_id, &ipgre_link_ops, NULL);\r\n}\r\nstatic void __net_exit ipgre_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, ipgre_net_id);\r\nip_tunnel_delete_net(itn, &ipgre_link_ops);\r\n}\r\nstatic int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\n__be16 flags;\r\nif (!data)\r\nreturn 0;\r\nflags = 0;\r\nif (data[IFLA_GRE_IFLAGS])\r\nflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\r\nif (data[IFLA_GRE_OFLAGS])\r\nflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\r\nif (flags & (GRE_VERSION|GRE_ROUTING))\r\nreturn -EINVAL;\r\nif (data[IFLA_GRE_COLLECT_METADATA] &&\r\ndata[IFLA_GRE_ENCAP_TYPE] &&\r\nnla_get_u16(data[IFLA_GRE_ENCAP_TYPE]) != TUNNEL_ENCAP_NONE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipgre_tap_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\n__be32 daddr;\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (!data)\r\ngoto out;\r\nif (data[IFLA_GRE_REMOTE]) {\r\nmemcpy(&daddr, nla_data(data[IFLA_GRE_REMOTE]), 4);\r\nif (!daddr)\r\nreturn -EINVAL;\r\n}\r\nout:\r\nreturn ipgre_tunnel_validate(tb, data);\r\n}\r\nstatic int ipgre_netlink_parms(struct net_device *dev,\r\nstruct nlattr *data[],\r\nstruct nlattr *tb[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.protocol = IPPROTO_GRE;\r\nif (!data)\r\nreturn 0;\r\nif (data[IFLA_GRE_LINK])\r\nparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\r\nif (data[IFLA_GRE_IFLAGS])\r\nparms->i_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_IFLAGS]));\r\nif (data[IFLA_GRE_OFLAGS])\r\nparms->o_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_OFLAGS]));\r\nif (data[IFLA_GRE_IKEY])\r\nparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\r\nif (data[IFLA_GRE_OKEY])\r\nparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\r\nif (data[IFLA_GRE_LOCAL])\r\nparms->iph.saddr = nla_get_in_addr(data[IFLA_GRE_LOCAL]);\r\nif (data[IFLA_GRE_REMOTE])\r\nparms->iph.daddr = nla_get_in_addr(data[IFLA_GRE_REMOTE]);\r\nif (data[IFLA_GRE_TTL])\r\nparms->iph.ttl = nla_get_u8(data[IFLA_GRE_TTL]);\r\nif (data[IFLA_GRE_TOS])\r\nparms->iph.tos = nla_get_u8(data[IFLA_GRE_TOS]);\r\nif (!data[IFLA_GRE_PMTUDISC] || nla_get_u8(data[IFLA_GRE_PMTUDISC])) {\r\nif (t->ignore_df)\r\nreturn -EINVAL;\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nif (data[IFLA_GRE_COLLECT_METADATA]) {\r\nt->collect_md = true;\r\nif (dev->type == ARPHRD_IPGRE)\r\ndev->type = ARPHRD_NONE;\r\n}\r\nif (data[IFLA_GRE_IGNORE_DF]) {\r\nif (nla_get_u8(data[IFLA_GRE_IGNORE_DF])\r\n&& (parms->iph.frag_off & htons(IP_DF)))\r\nreturn -EINVAL;\r\nt->ignore_df = !!nla_get_u8(data[IFLA_GRE_IGNORE_DF]);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ipgre_netlink_encap_parms(struct nlattr *data[],\r\nstruct ip_tunnel_encap *ipencap)\r\n{\r\nbool ret = false;\r\nmemset(ipencap, 0, sizeof(*ipencap));\r\nif (!data)\r\nreturn ret;\r\nif (data[IFLA_GRE_ENCAP_TYPE]) {\r\nret = true;\r\nipencap->type = nla_get_u16(data[IFLA_GRE_ENCAP_TYPE]);\r\n}\r\nif (data[IFLA_GRE_ENCAP_FLAGS]) {\r\nret = true;\r\nipencap->flags = nla_get_u16(data[IFLA_GRE_ENCAP_FLAGS]);\r\n}\r\nif (data[IFLA_GRE_ENCAP_SPORT]) {\r\nret = true;\r\nipencap->sport = nla_get_be16(data[IFLA_GRE_ENCAP_SPORT]);\r\n}\r\nif (data[IFLA_GRE_ENCAP_DPORT]) {\r\nret = true;\r\nipencap->dport = nla_get_be16(data[IFLA_GRE_ENCAP_DPORT]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gre_tap_init(struct net_device *dev)\r\n{\r\n__gre_tunnel_init(dev);\r\ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic void ipgre_tap_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->netdev_ops = &gre_tap_netdev_ops;\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\nip_tunnel_setup(dev, gre_tap_net_id);\r\n}\r\nstatic int ipgre_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_encap ipencap;\r\nint err;\r\nif (ipgre_netlink_encap_parms(data, &ipencap)) {\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nerr = ip_tunnel_encap_setup(t, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = ipgre_netlink_parms(dev, data, tb, &p);\r\nif (err < 0)\r\nreturn err;\r\nreturn ip_tunnel_newlink(dev, tb, &p);\r\n}\r\nstatic int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_encap ipencap;\r\nint err;\r\nif (ipgre_netlink_encap_parms(data, &ipencap)) {\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nerr = ip_tunnel_encap_setup(t, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = ipgre_netlink_parms(dev, data, tb, &p);\r\nif (err < 0)\r\nreturn err;\r\nreturn ip_tunnel_changelink(dev, tb, &p);\r\n}\r\nstatic size_t ipgre_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(0) +\r\nnla_total_size(1) +\r\n0;\r\n}\r\nstatic int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm *p = &t->parms;\r\nif (nla_put_u32(skb, IFLA_GRE_LINK, p->link) ||\r\nnla_put_be16(skb, IFLA_GRE_IFLAGS,\r\ngre_tnl_flags_to_gre_flags(p->i_flags)) ||\r\nnla_put_be16(skb, IFLA_GRE_OFLAGS,\r\ngre_tnl_flags_to_gre_flags(p->o_flags)) ||\r\nnla_put_be32(skb, IFLA_GRE_IKEY, p->i_key) ||\r\nnla_put_be32(skb, IFLA_GRE_OKEY, p->o_key) ||\r\nnla_put_in_addr(skb, IFLA_GRE_LOCAL, p->iph.saddr) ||\r\nnla_put_in_addr(skb, IFLA_GRE_REMOTE, p->iph.daddr) ||\r\nnla_put_u8(skb, IFLA_GRE_TTL, p->iph.ttl) ||\r\nnla_put_u8(skb, IFLA_GRE_TOS, p->iph.tos) ||\r\nnla_put_u8(skb, IFLA_GRE_PMTUDISC,\r\n!!(p->iph.frag_off & htons(IP_DF))))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_GRE_ENCAP_TYPE,\r\nt->encap.type) ||\r\nnla_put_be16(skb, IFLA_GRE_ENCAP_SPORT,\r\nt->encap.sport) ||\r\nnla_put_be16(skb, IFLA_GRE_ENCAP_DPORT,\r\nt->encap.dport) ||\r\nnla_put_u16(skb, IFLA_GRE_ENCAP_FLAGS,\r\nt->encap.flags))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_GRE_IGNORE_DF, t->ignore_df))\r\ngoto nla_put_failure;\r\nif (t->collect_md) {\r\nif (nla_put_flag(skb, IFLA_GRE_COLLECT_METADATA))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstruct net_device *gretap_fb_dev_create(struct net *net, const char *name,\r\nu8 name_assign_type)\r\n{\r\nstruct nlattr *tb[IFLA_MAX + 1];\r\nstruct net_device *dev;\r\nLIST_HEAD(list_kill);\r\nstruct ip_tunnel *t;\r\nint err;\r\nmemset(&tb, 0, sizeof(tb));\r\ndev = rtnl_create_link(net, name, name_assign_type,\r\n&ipgre_tap_ops, tb);\r\nif (IS_ERR(dev))\r\nreturn dev;\r\nt = netdev_priv(dev);\r\nt->collect_md = true;\r\nerr = ipgre_newlink(net, dev, tb, NULL);\r\nif (err < 0) {\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = __ip_tunnel_change_mtu(dev, IP_MAX_MTU, false);\r\nif (err)\r\ngoto out;\r\nerr = rtnl_configure_link(dev, NULL);\r\nif (err < 0)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nip_tunnel_dellink(dev, &list_kill);\r\nunregister_netdevice_many(&list_kill);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __net_init ipgre_tap_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, gre_tap_net_id, &ipgre_tap_ops, "gretap0");\r\n}\r\nstatic void __net_exit ipgre_tap_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, gre_tap_net_id);\r\nip_tunnel_delete_net(itn, &ipgre_tap_ops);\r\n}\r\nstatic int __init ipgre_init(void)\r\n{\r\nint err;\r\npr_info("GRE over IPv4 tunneling driver\n");\r\nerr = register_pernet_device(&ipgre_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = register_pernet_device(&ipgre_tap_net_ops);\r\nif (err < 0)\r\ngoto pnet_tap_faied;\r\nerr = gre_add_protocol(&ipgre_protocol, GREPROTO_CISCO);\r\nif (err < 0) {\r\npr_info("%s: can't add protocol\n", __func__);\r\ngoto add_proto_failed;\r\n}\r\nerr = rtnl_link_register(&ipgre_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nerr = rtnl_link_register(&ipgre_tap_ops);\r\nif (err < 0)\r\ngoto tap_ops_failed;\r\nreturn 0;\r\ntap_ops_failed:\r\nrtnl_link_unregister(&ipgre_link_ops);\r\nrtnl_link_failed:\r\ngre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\r\nadd_proto_failed:\r\nunregister_pernet_device(&ipgre_tap_net_ops);\r\npnet_tap_faied:\r\nunregister_pernet_device(&ipgre_net_ops);\r\nreturn err;\r\n}\r\nstatic void __exit ipgre_fini(void)\r\n{\r\nrtnl_link_unregister(&ipgre_tap_ops);\r\nrtnl_link_unregister(&ipgre_link_ops);\r\ngre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\r\nunregister_pernet_device(&ipgre_tap_net_ops);\r\nunregister_pernet_device(&ipgre_net_ops);\r\n}
