static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)\r\n{\r\n#ifdef CONFIG_FSL_PAMU\r\nstruct device *dev = pcfg->dev;\r\nint window_count = 1;\r\nstruct iommu_domain_geometry geom_attr;\r\nstruct pamu_stash_attribute stash_attr;\r\nint ret;\r\npcfg->iommu_domain = iommu_domain_alloc(&platform_bus_type);\r\nif (!pcfg->iommu_domain) {\r\ndev_err(dev, "%s(): iommu_domain_alloc() failed", __func__);\r\ngoto no_iommu;\r\n}\r\ngeom_attr.aperture_start = 0;\r\ngeom_attr.aperture_end =\r\n((dma_addr_t)1 << min(8 * sizeof(dma_addr_t), (size_t)36)) - 1;\r\ngeom_attr.force_aperture = true;\r\nret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_GEOMETRY,\r\n&geom_attr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_domain_set_attr() = %d", __func__,\r\nret);\r\ngoto out_domain_free;\r\n}\r\nret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_WINDOWS,\r\n&window_count);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_domain_set_attr() = %d", __func__,\r\nret);\r\ngoto out_domain_free;\r\n}\r\nstash_attr.cpu = cpu;\r\nstash_attr.cache = PAMU_ATTR_CACHE_L1;\r\nret = iommu_domain_set_attr(pcfg->iommu_domain,\r\nDOMAIN_ATTR_FSL_PAMU_STASH,\r\n&stash_attr);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_domain_set_attr() = %d",\r\n__func__, ret);\r\ngoto out_domain_free;\r\n}\r\nret = iommu_domain_window_enable(pcfg->iommu_domain, 0, 0, 1ULL << 36,\r\nIOMMU_READ | IOMMU_WRITE);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_domain_window_enable() = %d",\r\n__func__, ret);\r\ngoto out_domain_free;\r\n}\r\nret = iommu_attach_device(pcfg->iommu_domain, dev);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_device_attach() = %d", __func__,\r\nret);\r\ngoto out_domain_free;\r\n}\r\nret = iommu_domain_set_attr(pcfg->iommu_domain,\r\nDOMAIN_ATTR_FSL_PAMU_ENABLE,\r\n&window_count);\r\nif (ret < 0) {\r\ndev_err(dev, "%s(): iommu_domain_set_attr() = %d", __func__,\r\nret);\r\ngoto out_detach_device;\r\n}\r\nno_iommu:\r\n#endif\r\nqman_set_sdest(pcfg->channel, cpu);\r\nreturn;\r\n#ifdef CONFIG_FSL_PAMU\r\nout_detach_device:\r\niommu_detach_device(pcfg->iommu_domain, NULL);\r\nout_domain_free:\r\niommu_domain_free(pcfg->iommu_domain);\r\npcfg->iommu_domain = NULL;\r\n#endif\r\n}\r\nstatic struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)\r\n{\r\nstruct qman_portal *p;\r\nu32 irq_sources = 0;\r\nqman_liodn_fixup(pcfg->channel);\r\npcfg->iommu_domain = NULL;\r\nportal_set_cpu(pcfg, pcfg->cpu);\r\np = qman_create_affine_portal(pcfg, NULL);\r\nif (!p) {\r\ndev_crit(pcfg->dev, "%s: Portal failure on cpu %d\n",\r\n__func__, pcfg->cpu);\r\nreturn NULL;\r\n}\r\n#ifdef CONFIG_FSL_DPA_PIRQ_SLOW\r\nirq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI | QM_PIRQ_MRI |\r\nQM_PIRQ_CSCI;\r\n#endif\r\n#ifdef CONFIG_FSL_DPA_PIRQ_FAST\r\nirq_sources |= QM_PIRQ_DQRI;\r\n#endif\r\nqman_p_irqsource_add(p, irq_sources);\r\nspin_lock(&qman_lock);\r\nif (cpumask_equal(&portal_cpus, cpu_possible_mask)) {\r\nqman_init_cgr_all();\r\n}\r\nif (!qman_dma_portal)\r\nqman_dma_portal = p;\r\nspin_unlock(&qman_lock);\r\ndev_info(pcfg->dev, "Portal initialised, cpu %d\n", pcfg->cpu);\r\nreturn p;\r\n}\r\nstatic void qman_portal_update_sdest(const struct qm_portal_config *pcfg,\r\nunsigned int cpu)\r\n{\r\n#ifdef CONFIG_FSL_PAMU\r\nstruct pamu_stash_attribute stash_attr;\r\nint ret;\r\nif (pcfg->iommu_domain) {\r\nstash_attr.cpu = cpu;\r\nstash_attr.cache = PAMU_ATTR_CACHE_L1;\r\nret = iommu_domain_set_attr(pcfg->iommu_domain,\r\nDOMAIN_ATTR_FSL_PAMU_STASH, &stash_attr);\r\nif (ret < 0) {\r\ndev_err(pcfg->dev,\r\n"Failed to update pamu stash setting\n");\r\nreturn;\r\n}\r\n}\r\n#endif\r\nqman_set_sdest(pcfg->channel, cpu);\r\n}\r\nstatic int qman_offline_cpu(unsigned int cpu)\r\n{\r\nstruct qman_portal *p;\r\nconst struct qm_portal_config *pcfg;\r\np = affine_portals[cpu];\r\nif (p) {\r\npcfg = qman_get_qm_portal_config(p);\r\nif (pcfg) {\r\nirq_set_affinity(pcfg->irq, cpumask_of(0));\r\nqman_portal_update_sdest(pcfg, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qman_online_cpu(unsigned int cpu)\r\n{\r\nstruct qman_portal *p;\r\nconst struct qm_portal_config *pcfg;\r\np = affine_portals[cpu];\r\nif (p) {\r\npcfg = qman_get_qm_portal_config(p);\r\nif (pcfg) {\r\nirq_set_affinity(pcfg->irq, cpumask_of(cpu));\r\nqman_portal_update_sdest(pcfg, cpu);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qman_portal_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct qm_portal_config *pcfg;\r\nstruct resource *addr_phys[2];\r\nvoid __iomem *va;\r\nint irq, cpu, err;\r\nu32 val;\r\npcfg = devm_kmalloc(dev, sizeof(*pcfg), GFP_KERNEL);\r\nif (!pcfg)\r\nreturn -ENOMEM;\r\npcfg->dev = dev;\r\naddr_phys[0] = platform_get_resource(pdev, IORESOURCE_MEM,\r\nDPAA_PORTAL_CE);\r\nif (!addr_phys[0]) {\r\ndev_err(dev, "Can't get %s property 'reg::CE'\n",\r\nnode->full_name);\r\nreturn -ENXIO;\r\n}\r\naddr_phys[1] = platform_get_resource(pdev, IORESOURCE_MEM,\r\nDPAA_PORTAL_CI);\r\nif (!addr_phys[1]) {\r\ndev_err(dev, "Can't get %s property 'reg::CI'\n",\r\nnode->full_name);\r\nreturn -ENXIO;\r\n}\r\nerr = of_property_read_u32(node, "cell-index", &val);\r\nif (err) {\r\ndev_err(dev, "Can't get %s property 'cell-index'\n",\r\nnode->full_name);\r\nreturn err;\r\n}\r\npcfg->channel = val;\r\npcfg->cpu = -1;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "Can't get %s IRQ\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\npcfg->irq = irq;\r\nva = ioremap_prot(addr_phys[0]->start, resource_size(addr_phys[0]), 0);\r\nif (!va) {\r\ndev_err(dev, "ioremap::CE failed\n");\r\ngoto err_ioremap1;\r\n}\r\npcfg->addr_virt[DPAA_PORTAL_CE] = va;\r\nva = ioremap_prot(addr_phys[1]->start, resource_size(addr_phys[1]),\r\n_PAGE_GUARDED | _PAGE_NO_CACHE);\r\nif (!va) {\r\ndev_err(dev, "ioremap::CI failed\n");\r\ngoto err_ioremap2;\r\n}\r\npcfg->addr_virt[DPAA_PORTAL_CI] = va;\r\npcfg->pools = qm_get_pools_sdqcr();\r\nspin_lock(&qman_lock);\r\ncpu = cpumask_next_zero(-1, &portal_cpus);\r\nif (cpu >= nr_cpu_ids) {\r\nspin_unlock(&qman_lock);\r\nreturn 0;\r\n}\r\ncpumask_set_cpu(cpu, &portal_cpus);\r\nspin_unlock(&qman_lock);\r\npcfg->cpu = cpu;\r\nif (dma_set_mask(dev, DMA_BIT_MASK(40))) {\r\ndev_err(dev, "dma_set_mask() failed\n");\r\ngoto err_portal_init;\r\n}\r\nif (!init_pcfg(pcfg)) {\r\ndev_err(dev, "portal init failed\n");\r\ngoto err_portal_init;\r\n}\r\nif (!cpu_online(cpu))\r\nqman_offline_cpu(cpu);\r\nreturn 0;\r\nerr_portal_init:\r\niounmap(pcfg->addr_virt[DPAA_PORTAL_CI]);\r\nerr_ioremap2:\r\niounmap(pcfg->addr_virt[DPAA_PORTAL_CE]);\r\nerr_ioremap1:\r\nreturn -ENXIO;\r\n}\r\nstatic int __init qman_portal_driver_register(struct platform_driver *drv)\r\n{\r\nint ret;\r\nret = platform_driver_register(drv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\r\n"soc/qman_portal:online",\r\nqman_online_cpu, qman_offline_cpu);\r\nif (ret < 0) {\r\npr_err("qman: failed to register hotplug callbacks.\n");\r\nplatform_driver_unregister(drv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
