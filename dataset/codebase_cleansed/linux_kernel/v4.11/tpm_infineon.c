static inline void tpm_data_out(unsigned char data, unsigned char offset)\r\n{\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT)\r\noutb(data, tpm_dev.data_regs + offset);\r\nelse\r\nwriteb(data, tpm_dev.mem_base + tpm_dev.data_regs + offset);\r\n}\r\nstatic inline unsigned char tpm_data_in(unsigned char offset)\r\n{\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT)\r\nreturn inb(tpm_dev.data_regs + offset);\r\nelse\r\nreturn readb(tpm_dev.mem_base + tpm_dev.data_regs + offset);\r\n}\r\nstatic inline void tpm_config_out(unsigned char data, unsigned char offset)\r\n{\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT)\r\noutb(data, tpm_dev.config_port + offset);\r\nelse\r\nwriteb(data, tpm_dev.mem_base + tpm_dev.index_off + offset);\r\n}\r\nstatic inline unsigned char tpm_config_in(unsigned char offset)\r\n{\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT)\r\nreturn inb(tpm_dev.config_port + offset);\r\nelse\r\nreturn readb(tpm_dev.mem_base + tpm_dev.index_off + offset);\r\n}\r\nstatic int empty_fifo(struct tpm_chip *chip, int clear_wrfifo)\r\n{\r\nint status;\r\nint check = 0;\r\nint i;\r\nif (clear_wrfifo) {\r\nfor (i = 0; i < 4096; i++) {\r\nstatus = tpm_data_in(WRFIFO);\r\nif (status == 0xff) {\r\nif (check == 5)\r\nbreak;\r\nelse\r\ncheck++;\r\n}\r\n}\r\n}\r\ni = 0;\r\ndo {\r\nstatus = tpm_data_in(RDFIFO);\r\nstatus = tpm_data_in(STAT);\r\ni++;\r\nif (i == TPM_MAX_TRIES)\r\nreturn -EIO;\r\n} while ((status & (1 << STAT_RDA)) != 0);\r\nreturn 0;\r\n}\r\nstatic int wait(struct tpm_chip *chip, int wait_for_bit)\r\n{\r\nint status;\r\nint i;\r\nfor (i = 0; i < TPM_MAX_TRIES; i++) {\r\nstatus = tpm_data_in(STAT);\r\nif (status & 1 << wait_for_bit)\r\nbreak;\r\nmsleep(TPM_MSLEEP_TIME);\r\n}\r\nif (i == TPM_MAX_TRIES) {\r\nif (wait_for_bit == STAT_XFE)\r\ndev_err(&chip->dev, "Timeout in wait(STAT_XFE)\n");\r\nif (wait_for_bit == STAT_RDA)\r\ndev_err(&chip->dev, "Timeout in wait(STAT_RDA)\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wait_and_send(struct tpm_chip *chip, u8 sendbyte)\r\n{\r\nwait(chip, STAT_XFE);\r\ntpm_data_out(sendbyte, WRFIFO);\r\n}\r\nstatic void tpm_wtx(struct tpm_chip *chip)\r\n{\r\nnumber_of_wtx++;\r\ndev_info(&chip->dev, "Granting WTX (%02d / %02d)\n",\r\nnumber_of_wtx, TPM_MAX_WTX_PACKAGES);\r\nwait_and_send(chip, TPM_VL_VER);\r\nwait_and_send(chip, TPM_CTRL_WTX);\r\nwait_and_send(chip, 0x00);\r\nwait_and_send(chip, 0x00);\r\nmsleep(TPM_WTX_MSLEEP_TIME);\r\n}\r\nstatic void tpm_wtx_abort(struct tpm_chip *chip)\r\n{\r\ndev_info(&chip->dev, "Aborting WTX\n");\r\nwait_and_send(chip, TPM_VL_VER);\r\nwait_and_send(chip, TPM_CTRL_WTX_ABORT);\r\nwait_and_send(chip, 0x00);\r\nwait_and_send(chip, 0x00);\r\nnumber_of_wtx = 0;\r\nmsleep(TPM_WTX_MSLEEP_TIME);\r\n}\r\nstatic int tpm_inf_recv(struct tpm_chip *chip, u8 * buf, size_t count)\r\n{\r\nint i;\r\nint ret;\r\nu32 size = 0;\r\nnumber_of_wtx = 0;\r\nrecv_begin:\r\nfor (i = 0; i < 4; i++) {\r\nret = wait(chip, STAT_RDA);\r\nif (ret)\r\nreturn -EIO;\r\nbuf[i] = tpm_data_in(RDFIFO);\r\n}\r\nif (buf[0] != TPM_VL_VER) {\r\ndev_err(&chip->dev,\r\n"Wrong transport protocol implementation!\n");\r\nreturn -EIO;\r\n}\r\nif (buf[1] == TPM_CTRL_DATA) {\r\nsize = ((buf[2] << 8) | buf[3]);\r\nfor (i = 0; i < size; i++) {\r\nwait(chip, STAT_RDA);\r\nbuf[i] = tpm_data_in(RDFIFO);\r\n}\r\nif ((size == 0x6D00) && (buf[1] == 0x80)) {\r\ndev_err(&chip->dev, "Error handling on vendor layer!\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < size; i++)\r\nbuf[i] = buf[i + 6];\r\nsize = size - 6;\r\nreturn size;\r\n}\r\nif (buf[1] == TPM_CTRL_WTX) {\r\ndev_info(&chip->dev, "WTX-package received\n");\r\nif (number_of_wtx < TPM_MAX_WTX_PACKAGES) {\r\ntpm_wtx(chip);\r\ngoto recv_begin;\r\n} else {\r\ntpm_wtx_abort(chip);\r\ngoto recv_begin;\r\n}\r\n}\r\nif (buf[1] == TPM_CTRL_WTX_ABORT_ACK) {\r\ndev_info(&chip->dev, "WTX-abort acknowledged\n");\r\nreturn size;\r\n}\r\nif (buf[1] == TPM_CTRL_ERROR) {\r\ndev_err(&chip->dev, "ERROR-package received:\n");\r\nif (buf[4] == TPM_INF_NAK)\r\ndev_err(&chip->dev,\r\n"-> Negative acknowledgement"\r\n" - retransmit command!\n");\r\nreturn -EIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int tpm_inf_send(struct tpm_chip *chip, u8 * buf, size_t count)\r\n{\r\nint i;\r\nint ret;\r\nu8 count_high, count_low, count_4, count_3, count_2, count_1;\r\ntpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\r\nret = empty_fifo(chip, 1);\r\nif (ret) {\r\ndev_err(&chip->dev, "Timeout while clearing FIFO\n");\r\nreturn -EIO;\r\n}\r\nret = wait(chip, STAT_XFE);\r\nif (ret)\r\nreturn -EIO;\r\ncount_4 = (count & 0xff000000) >> 24;\r\ncount_3 = (count & 0x00ff0000) >> 16;\r\ncount_2 = (count & 0x0000ff00) >> 8;\r\ncount_1 = (count & 0x000000ff);\r\ncount_high = ((count + 6) & 0xffffff00) >> 8;\r\ncount_low = ((count + 6) & 0x000000ff);\r\nwait_and_send(chip, TPM_VL_VER);\r\nwait_and_send(chip, TPM_CTRL_DATA);\r\nwait_and_send(chip, count_high);\r\nwait_and_send(chip, count_low);\r\nwait_and_send(chip, TPM_VL_VER);\r\nwait_and_send(chip, TPM_VL_CHANNEL_TPM);\r\nwait_and_send(chip, count_4);\r\nwait_and_send(chip, count_3);\r\nwait_and_send(chip, count_2);\r\nwait_and_send(chip, count_1);\r\nfor (i = 0; i < count; i++) {\r\nwait_and_send(chip, buf[i]);\r\n}\r\nreturn count;\r\n}\r\nstatic void tpm_inf_cancel(struct tpm_chip *chip)\r\n{\r\n}\r\nstatic u8 tpm_inf_status(struct tpm_chip *chip)\r\n{\r\nreturn tpm_data_in(STAT);\r\n}\r\nstatic int tpm_inf_pnp_probe(struct pnp_dev *dev,\r\nconst struct pnp_device_id *dev_id)\r\n{\r\nint rc = 0;\r\nu8 iol, ioh;\r\nint vendorid[2];\r\nint version[2];\r\nint productid[2];\r\nchar chipname[20];\r\nstruct tpm_chip *chip;\r\nif (pnp_port_valid(dev, 0) && pnp_port_valid(dev, 1) &&\r\n!(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED)) {\r\ntpm_dev.iotype = TPM_INF_IO_PORT;\r\ntpm_dev.config_port = pnp_port_start(dev, 0);\r\ntpm_dev.config_size = pnp_port_len(dev, 0);\r\ntpm_dev.data_regs = pnp_port_start(dev, 1);\r\ntpm_dev.data_size = pnp_port_len(dev, 1);\r\nif ((tpm_dev.data_size < 4) || (tpm_dev.config_size < 2)) {\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\ndev_info(&dev->dev, "Found %s with ID %s\n",\r\ndev->name, dev_id->id);\r\nif (!((tpm_dev.data_regs >> 8) & 0xff)) {\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\nif (request_region(tpm_dev.data_regs, tpm_dev.data_size,\r\n"tpm_infineon0") == NULL) {\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\nif (request_region(tpm_dev.config_port, tpm_dev.config_size,\r\n"tpm_infineon0") == NULL) {\r\nrelease_region(tpm_dev.data_regs, tpm_dev.data_size);\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\n} else if (pnp_mem_valid(dev, 0) &&\r\n!(pnp_mem_flags(dev, 0) & IORESOURCE_DISABLED)) {\r\ntpm_dev.iotype = TPM_INF_IO_MEM;\r\ntpm_dev.map_base = pnp_mem_start(dev, 0);\r\ntpm_dev.map_size = pnp_mem_len(dev, 0);\r\ndev_info(&dev->dev, "Found %s with ID %s\n",\r\ndev->name, dev_id->id);\r\nif (request_mem_region(tpm_dev.map_base, tpm_dev.map_size,\r\n"tpm_infineon0") == NULL) {\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\ntpm_dev.mem_base = ioremap(tpm_dev.map_base, tpm_dev.map_size);\r\nif (tpm_dev.mem_base == NULL) {\r\nrelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\ntpm_dev.index_off = TPM_ADDR;\r\ntpm_dev.data_regs = 0x0;\r\n} else {\r\nrc = -EINVAL;\r\ngoto err_last;\r\n}\r\ntpm_config_out(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);\r\ntpm_config_out(IDVENL, TPM_INF_ADDR);\r\nvendorid[1] = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(IDVENH, TPM_INF_ADDR);\r\nvendorid[0] = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(IDPDL, TPM_INF_ADDR);\r\nproductid[1] = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(IDPDH, TPM_INF_ADDR);\r\nproductid[0] = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(CHIP_ID1, TPM_INF_ADDR);\r\nversion[1] = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(CHIP_ID2, TPM_INF_ADDR);\r\nversion[0] = tpm_config_in(TPM_INF_DATA);\r\nswitch ((productid[0] << 8) | productid[1]) {\r\ncase 6:\r\nsnprintf(chipname, sizeof(chipname), " (SLD 9630 TT 1.1)");\r\nbreak;\r\ncase 11:\r\nsnprintf(chipname, sizeof(chipname), " (SLB 9635 TT 1.2)");\r\nbreak;\r\ndefault:\r\nsnprintf(chipname, sizeof(chipname), " (unknown chip)");\r\nbreak;\r\n}\r\nif ((vendorid[0] << 8 | vendorid[1]) == (TPM_INFINEON_DEV_VEN_VALUE)) {\r\ntpm_config_out(IOLIMH, TPM_INF_ADDR);\r\ntpm_config_out((tpm_dev.data_regs >> 8) & 0xff, TPM_INF_DATA);\r\ntpm_config_out(IOLIML, TPM_INF_ADDR);\r\ntpm_config_out((tpm_dev.data_regs & 0xff), TPM_INF_DATA);\r\ntpm_config_out(IOLIMH, TPM_INF_ADDR);\r\nioh = tpm_config_in(TPM_INF_DATA);\r\ntpm_config_out(IOLIML, TPM_INF_ADDR);\r\niol = tpm_config_in(TPM_INF_DATA);\r\nif ((ioh << 8 | iol) != tpm_dev.data_regs) {\r\ndev_err(&dev->dev,\r\n"Could not set IO-data registers to 0x%x\n",\r\ntpm_dev.data_regs);\r\nrc = -EIO;\r\ngoto err_release_region;\r\n}\r\ntpm_config_out(TPM_DAR, TPM_INF_ADDR);\r\ntpm_config_out(0x01, TPM_INF_DATA);\r\ntpm_config_out(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);\r\ntpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\r\ndev_info(&dev->dev, "TPM found: "\r\n"config base 0x%lx, "\r\n"data base 0x%lx, "\r\n"chip version 0x%02x%02x, "\r\n"vendor id 0x%x%x (Infineon), "\r\n"product id 0x%02x%02x"\r\n"%s\n",\r\ntpm_dev.iotype == TPM_INF_IO_PORT ?\r\ntpm_dev.config_port :\r\ntpm_dev.map_base + tpm_dev.index_off,\r\ntpm_dev.iotype == TPM_INF_IO_PORT ?\r\ntpm_dev.data_regs :\r\ntpm_dev.map_base + tpm_dev.data_regs,\r\nversion[0], version[1],\r\nvendorid[0], vendorid[1],\r\nproductid[0], productid[1], chipname);\r\nchip = tpmm_chip_alloc(&dev->dev, &tpm_inf);\r\nif (IS_ERR(chip)) {\r\nrc = PTR_ERR(chip);\r\ngoto err_release_region;\r\n}\r\nrc = tpm_chip_register(chip);\r\nif (rc)\r\ngoto err_release_region;\r\nreturn 0;\r\n} else {\r\nrc = -ENODEV;\r\ngoto err_release_region;\r\n}\r\nerr_release_region:\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT) {\r\nrelease_region(tpm_dev.data_regs, tpm_dev.data_size);\r\nrelease_region(tpm_dev.config_port, tpm_dev.config_size);\r\n} else {\r\niounmap(tpm_dev.mem_base);\r\nrelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\r\n}\r\nerr_last:\r\nreturn rc;\r\n}\r\nstatic void tpm_inf_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct tpm_chip *chip = pnp_get_drvdata(dev);\r\ntpm_chip_unregister(chip);\r\nif (tpm_dev.iotype == TPM_INF_IO_PORT) {\r\nrelease_region(tpm_dev.data_regs, tpm_dev.data_size);\r\nrelease_region(tpm_dev.config_port,\r\ntpm_dev.config_size);\r\n} else {\r\niounmap(tpm_dev.mem_base);\r\nrelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\r\n}\r\n}\r\nstatic int tpm_inf_resume(struct device *dev)\r\n{\r\ntpm_config_out(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);\r\ntpm_config_out(IOLIMH, TPM_INF_ADDR);\r\ntpm_config_out((tpm_dev.data_regs >> 8) & 0xff, TPM_INF_DATA);\r\ntpm_config_out(IOLIML, TPM_INF_ADDR);\r\ntpm_config_out((tpm_dev.data_regs & 0xff), TPM_INF_DATA);\r\ntpm_config_out(TPM_DAR, TPM_INF_ADDR);\r\ntpm_config_out(0x01, TPM_INF_DATA);\r\ntpm_config_out(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);\r\ntpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\r\nreturn tpm_pm_resume(dev);\r\n}
