static struct bio *next_bio(struct bio *bio, unsigned int nr_pages,\r\ngfp_t gfp)\r\n{\r\nstruct bio *new = bio_alloc(gfp, nr_pages);\r\nif (bio) {\r\nbio_chain(bio, new);\r\nsubmit_bio(bio);\r\n}\r\nreturn new;\r\n}\r\nint __blkdev_issue_discard(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask, int flags,\r\nstruct bio **biop)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bdev);\r\nstruct bio *bio = *biop;\r\nunsigned int granularity;\r\nunsigned int op;\r\nint alignment;\r\nsector_t bs_mask;\r\nif (!q)\r\nreturn -ENXIO;\r\nif (flags & BLKDEV_DISCARD_SECURE) {\r\nif (flags & BLKDEV_DISCARD_ZERO)\r\nreturn -EOPNOTSUPP;\r\nif (!blk_queue_secure_erase(q))\r\nreturn -EOPNOTSUPP;\r\nop = REQ_OP_SECURE_ERASE;\r\n} else {\r\nif (!blk_queue_discard(q))\r\nreturn -EOPNOTSUPP;\r\nif ((flags & BLKDEV_DISCARD_ZERO) &&\r\n!q->limits.discard_zeroes_data)\r\nreturn -EOPNOTSUPP;\r\nop = REQ_OP_DISCARD;\r\n}\r\nbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\r\nif ((sector | nr_sects) & bs_mask)\r\nreturn -EINVAL;\r\ngranularity = max(q->limits.discard_granularity >> 9, 1U);\r\nalignment = (bdev_discard_alignment(bdev) >> 9) % granularity;\r\nwhile (nr_sects) {\r\nunsigned int req_sects;\r\nsector_t end_sect, tmp;\r\nreq_sects = min_t(sector_t, nr_sects, UINT_MAX >> 9);\r\nend_sect = sector + req_sects;\r\ntmp = end_sect;\r\nif (req_sects < nr_sects &&\r\nsector_div(tmp, granularity) != alignment) {\r\nend_sect = end_sect - alignment;\r\nsector_div(end_sect, granularity);\r\nend_sect = end_sect * granularity + alignment;\r\nreq_sects = end_sect - sector;\r\n}\r\nbio = next_bio(bio, 0, gfp_mask);\r\nbio->bi_iter.bi_sector = sector;\r\nbio->bi_bdev = bdev;\r\nbio_set_op_attrs(bio, op, 0);\r\nbio->bi_iter.bi_size = req_sects << 9;\r\nnr_sects -= req_sects;\r\nsector = end_sect;\r\ncond_resched();\r\n}\r\n*biop = bio;\r\nreturn 0;\r\n}\r\nint blkdev_issue_discard(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask, unsigned long flags)\r\n{\r\nstruct bio *bio = NULL;\r\nstruct blk_plug plug;\r\nint ret;\r\nblk_start_plug(&plug);\r\nret = __blkdev_issue_discard(bdev, sector, nr_sects, gfp_mask, flags,\r\n&bio);\r\nif (!ret && bio) {\r\nret = submit_bio_wait(bio);\r\nif (ret == -EOPNOTSUPP && !(flags & BLKDEV_DISCARD_ZERO))\r\nret = 0;\r\nbio_put(bio);\r\n}\r\nblk_finish_plug(&plug);\r\nreturn ret;\r\n}\r\nstatic int __blkdev_issue_write_same(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask, struct page *page,\r\nstruct bio **biop)\r\n{\r\nstruct request_queue *q = bdev_get_queue(bdev);\r\nunsigned int max_write_same_sectors;\r\nstruct bio *bio = *biop;\r\nsector_t bs_mask;\r\nif (!q)\r\nreturn -ENXIO;\r\nbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\r\nif ((sector | nr_sects) & bs_mask)\r\nreturn -EINVAL;\r\nif (!bdev_write_same(bdev))\r\nreturn -EOPNOTSUPP;\r\nmax_write_same_sectors = UINT_MAX >> 9;\r\nwhile (nr_sects) {\r\nbio = next_bio(bio, 1, gfp_mask);\r\nbio->bi_iter.bi_sector = sector;\r\nbio->bi_bdev = bdev;\r\nbio->bi_vcnt = 1;\r\nbio->bi_io_vec->bv_page = page;\r\nbio->bi_io_vec->bv_offset = 0;\r\nbio->bi_io_vec->bv_len = bdev_logical_block_size(bdev);\r\nbio_set_op_attrs(bio, REQ_OP_WRITE_SAME, 0);\r\nif (nr_sects > max_write_same_sectors) {\r\nbio->bi_iter.bi_size = max_write_same_sectors << 9;\r\nnr_sects -= max_write_same_sectors;\r\nsector += max_write_same_sectors;\r\n} else {\r\nbio->bi_iter.bi_size = nr_sects << 9;\r\nnr_sects = 0;\r\n}\r\ncond_resched();\r\n}\r\n*biop = bio;\r\nreturn 0;\r\n}\r\nint blkdev_issue_write_same(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask,\r\nstruct page *page)\r\n{\r\nstruct bio *bio = NULL;\r\nstruct blk_plug plug;\r\nint ret;\r\nblk_start_plug(&plug);\r\nret = __blkdev_issue_write_same(bdev, sector, nr_sects, gfp_mask, page,\r\n&bio);\r\nif (ret == 0 && bio) {\r\nret = submit_bio_wait(bio);\r\nbio_put(bio);\r\n}\r\nblk_finish_plug(&plug);\r\nreturn ret;\r\n}\r\nstatic int __blkdev_issue_write_zeroes(struct block_device *bdev,\r\nsector_t sector, sector_t nr_sects, gfp_t gfp_mask,\r\nstruct bio **biop)\r\n{\r\nstruct bio *bio = *biop;\r\nunsigned int max_write_zeroes_sectors;\r\nstruct request_queue *q = bdev_get_queue(bdev);\r\nif (!q)\r\nreturn -ENXIO;\r\nmax_write_zeroes_sectors = bdev_write_zeroes_sectors(bdev);\r\nif (max_write_zeroes_sectors == 0)\r\nreturn -EOPNOTSUPP;\r\nwhile (nr_sects) {\r\nbio = next_bio(bio, 0, gfp_mask);\r\nbio->bi_iter.bi_sector = sector;\r\nbio->bi_bdev = bdev;\r\nbio_set_op_attrs(bio, REQ_OP_WRITE_ZEROES, 0);\r\nif (nr_sects > max_write_zeroes_sectors) {\r\nbio->bi_iter.bi_size = max_write_zeroes_sectors << 9;\r\nnr_sects -= max_write_zeroes_sectors;\r\nsector += max_write_zeroes_sectors;\r\n} else {\r\nbio->bi_iter.bi_size = nr_sects << 9;\r\nnr_sects = 0;\r\n}\r\ncond_resched();\r\n}\r\n*biop = bio;\r\nreturn 0;\r\n}\r\nint __blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask, struct bio **biop,\r\nbool discard)\r\n{\r\nint ret;\r\nint bi_size = 0;\r\nstruct bio *bio = *biop;\r\nunsigned int sz;\r\nsector_t bs_mask;\r\nbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\r\nif ((sector | nr_sects) & bs_mask)\r\nreturn -EINVAL;\r\nret = __blkdev_issue_write_zeroes(bdev, sector, nr_sects, gfp_mask,\r\nbiop);\r\nif (ret == 0 || (ret && ret != -EOPNOTSUPP))\r\ngoto out;\r\nret = 0;\r\nwhile (nr_sects != 0) {\r\nbio = next_bio(bio, min(nr_sects, (sector_t)BIO_MAX_PAGES),\r\ngfp_mask);\r\nbio->bi_iter.bi_sector = sector;\r\nbio->bi_bdev = bdev;\r\nbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\r\nwhile (nr_sects != 0) {\r\nsz = min((sector_t) PAGE_SIZE >> 9 , nr_sects);\r\nbi_size = bio_add_page(bio, ZERO_PAGE(0), sz << 9, 0);\r\nnr_sects -= bi_size >> 9;\r\nsector += bi_size >> 9;\r\nif (bi_size < (sz << 9))\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\n*biop = bio;\r\nout:\r\nreturn ret;\r\n}\r\nint blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,\r\nsector_t nr_sects, gfp_t gfp_mask, bool discard)\r\n{\r\nint ret;\r\nstruct bio *bio = NULL;\r\nstruct blk_plug plug;\r\nif (discard) {\r\nif (!blkdev_issue_discard(bdev, sector, nr_sects, gfp_mask,\r\nBLKDEV_DISCARD_ZERO))\r\nreturn 0;\r\n}\r\nif (!blkdev_issue_write_same(bdev, sector, nr_sects, gfp_mask,\r\nZERO_PAGE(0)))\r\nreturn 0;\r\nblk_start_plug(&plug);\r\nret = __blkdev_issue_zeroout(bdev, sector, nr_sects, gfp_mask,\r\n&bio, discard);\r\nif (ret == 0 && bio) {\r\nret = submit_bio_wait(bio);\r\nbio_put(bio);\r\n}\r\nblk_finish_plug(&plug);\r\nreturn ret;\r\n}
