static irqreturn_t uniphier_i2c_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uniphier_i2c_priv *priv = dev_id;\r\ncomplete(&priv->comp);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int uniphier_i2c_xfer_byte(struct i2c_adapter *adap, u32 txdata,\r\nu32 *rxdatap)\r\n{\r\nstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\r\nunsigned long time_left;\r\nu32 rxdata;\r\nreinit_completion(&priv->comp);\r\ntxdata |= UNIPHIER_I2C_DTRM_IRQEN;\r\ndev_dbg(&adap->dev, "write data: 0x%04x\n", txdata);\r\nwritel(txdata, priv->membase + UNIPHIER_I2C_DTRM);\r\ntime_left = wait_for_completion_timeout(&priv->comp, adap->timeout);\r\nif (unlikely(!time_left)) {\r\ndev_err(&adap->dev, "transaction timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nrxdata = readl(priv->membase + UNIPHIER_I2C_DREC);\r\ndev_dbg(&adap->dev, "read data: 0x%04x\n", rxdata);\r\nif (rxdatap)\r\n*rxdatap = rxdata;\r\nreturn 0;\r\n}\r\nstatic int uniphier_i2c_send_byte(struct i2c_adapter *adap, u32 txdata)\r\n{\r\nu32 rxdata;\r\nint ret;\r\nret = uniphier_i2c_xfer_byte(adap, txdata, &rxdata);\r\nif (ret)\r\nreturn ret;\r\nif (unlikely(rxdata & UNIPHIER_I2C_DREC_LAB)) {\r\ndev_dbg(&adap->dev, "arbitration lost\n");\r\nreturn -EAGAIN;\r\n}\r\nif (unlikely(rxdata & UNIPHIER_I2C_DREC_LRB)) {\r\ndev_dbg(&adap->dev, "could not get ACK\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_i2c_tx(struct i2c_adapter *adap, u16 addr, u16 len,\r\nconst u8 *buf)\r\n{\r\nint ret;\r\ndev_dbg(&adap->dev, "start condition\n");\r\nret = uniphier_i2c_send_byte(adap, addr << 1 |\r\nUNIPHIER_I2C_DTRM_STA |\r\nUNIPHIER_I2C_DTRM_NACK);\r\nif (ret)\r\nreturn ret;\r\nwhile (len--) {\r\nret = uniphier_i2c_send_byte(adap,\r\nUNIPHIER_I2C_DTRM_NACK | *buf++);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_i2c_rx(struct i2c_adapter *adap, u16 addr, u16 len,\r\nu8 *buf)\r\n{\r\nint ret;\r\ndev_dbg(&adap->dev, "start condition\n");\r\nret = uniphier_i2c_send_byte(adap, addr << 1 |\r\nUNIPHIER_I2C_DTRM_STA |\r\nUNIPHIER_I2C_DTRM_NACK |\r\nUNIPHIER_I2C_DTRM_RD);\r\nif (ret)\r\nreturn ret;\r\nwhile (len--) {\r\nu32 rxdata;\r\nret = uniphier_i2c_xfer_byte(adap,\r\nlen ? 0 : UNIPHIER_I2C_DTRM_NACK,\r\n&rxdata);\r\nif (ret)\r\nreturn ret;\r\n*buf++ = rxdata;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uniphier_i2c_stop(struct i2c_adapter *adap)\r\n{\r\ndev_dbg(&adap->dev, "stop condition\n");\r\nreturn uniphier_i2c_send_byte(adap, UNIPHIER_I2C_DTRM_STO |\r\nUNIPHIER_I2C_DTRM_NACK);\r\n}\r\nstatic int uniphier_i2c_master_xfer_one(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, bool stop)\r\n{\r\nbool is_read = msg->flags & I2C_M_RD;\r\nbool recovery = false;\r\nint ret;\r\ndev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",\r\nis_read ? "receive" : "transmit", msg->addr, msg->len, stop);\r\nif (is_read)\r\nret = uniphier_i2c_rx(adap, msg->addr, msg->len, msg->buf);\r\nelse\r\nret = uniphier_i2c_tx(adap, msg->addr, msg->len, msg->buf);\r\nif (ret == -EAGAIN)\r\nreturn ret;\r\nif (ret == -ETIMEDOUT) {\r\nstop = false;\r\nrecovery = true;\r\n}\r\nif (stop) {\r\nint ret2 = uniphier_i2c_stop(adap);\r\nif (ret2) {\r\nrecovery = true;\r\nret = ret ?: ret2;\r\n}\r\n}\r\nif (recovery)\r\ni2c_recover_bus(adap);\r\nreturn ret;\r\n}\r\nstatic int uniphier_i2c_check_bus_busy(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\r\nif (!(readl(priv->membase + UNIPHIER_I2C_DREC) &\r\nUNIPHIER_I2C_DREC_BBN)) {\r\nif (priv->busy_cnt++ > 3) {\r\ni2c_recover_bus(adap);\r\npriv->busy_cnt = 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\npriv->busy_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic int uniphier_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_msg *msg, *emsg = msgs + num;\r\nint ret;\r\nret = uniphier_i2c_check_bus_busy(adap);\r\nif (ret)\r\nreturn ret;\r\nfor (msg = msgs; msg < emsg; msg++) {\r\nbool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);\r\nif (msg->flags & I2C_M_STOP)\r\nstop = true;\r\nret = uniphier_i2c_master_xfer_one(adap, msg, stop);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn num;\r\n}\r\nstatic u32 uniphier_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void uniphier_i2c_reset(struct uniphier_i2c_priv *priv, bool reset_on)\r\n{\r\nu32 val = UNIPHIER_I2C_BRST_RSCL;\r\nval |= reset_on ? 0 : UNIPHIER_I2C_BRST_FOEN;\r\nwritel(val, priv->membase + UNIPHIER_I2C_BRST);\r\n}\r\nstatic int uniphier_i2c_get_scl(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\r\nreturn !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &\r\nUNIPHIER_I2C_BSTS_SCL);\r\n}\r\nstatic void uniphier_i2c_set_scl(struct i2c_adapter *adap, int val)\r\n{\r\nstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\r\nwritel(val ? UNIPHIER_I2C_BRST_RSCL : 0,\r\npriv->membase + UNIPHIER_I2C_BRST);\r\n}\r\nstatic int uniphier_i2c_get_sda(struct i2c_adapter *adap)\r\n{\r\nstruct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);\r\nreturn !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &\r\nUNIPHIER_I2C_BSTS_SDA);\r\n}\r\nstatic void uniphier_i2c_unprepare_recovery(struct i2c_adapter *adap)\r\n{\r\nuniphier_i2c_reset(i2c_get_adapdata(adap), false);\r\n}\r\nstatic void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv,\r\nu32 bus_speed, unsigned long clk_rate)\r\n{\r\nuniphier_i2c_reset(priv, true);\r\nwritel((clk_rate / bus_speed / 2 << 16) | (clk_rate / bus_speed),\r\npriv->membase + UNIPHIER_I2C_CLK);\r\nuniphier_i2c_reset(priv, false);\r\n}\r\nstatic int uniphier_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uniphier_i2c_priv *priv;\r\nstruct resource *regs;\r\nu32 bus_speed;\r\nunsigned long clk_rate;\r\nint irq, ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->membase = devm_ioremap_resource(dev, regs);\r\nif (IS_ERR(priv->membase))\r\nreturn PTR_ERR(priv->membase);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get IRQ number\n");\r\nreturn irq;\r\n}\r\nif (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))\r\nbus_speed = UNIPHIER_I2C_DEFAULT_SPEED;\r\nif (!bus_speed || bus_speed > UNIPHIER_I2C_MAX_SPEED) {\r\ndev_err(dev, "invalid clock-frequency %d\n", bus_speed);\r\nreturn -EINVAL;\r\n}\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\nreturn ret;\r\nclk_rate = clk_get_rate(priv->clk);\r\nif (!clk_rate) {\r\ndev_err(dev, "input clock rate should not be zero\n");\r\nret = -EINVAL;\r\ngoto disable_clk;\r\n}\r\ninit_completion(&priv->comp);\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.algo = &uniphier_i2c_algo;\r\npriv->adap.dev.parent = dev;\r\npriv->adap.dev.of_node = dev->of_node;\r\nstrlcpy(priv->adap.name, "UniPhier I2C", sizeof(priv->adap.name));\r\npriv->adap.bus_recovery_info = &uniphier_i2c_bus_recovery_info;\r\ni2c_set_adapdata(&priv->adap, priv);\r\nplatform_set_drvdata(pdev, priv);\r\nuniphier_i2c_hw_init(priv, bus_speed, clk_rate);\r\nret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,\r\npriv);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq %d\n", irq);\r\ngoto disable_clk;\r\n}\r\nret = i2c_add_adapter(&priv->adap);\r\ndisable_clk:\r\nif (ret)\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int uniphier_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct uniphier_i2c_priv *priv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
