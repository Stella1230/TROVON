static inline u32 intc_readl(struct tangox_irq_chip *chip, int reg)\r\n{\r\nreturn readl_relaxed(chip->base + reg);\r\n}\r\nstatic inline void intc_writel(struct tangox_irq_chip *chip, int reg, u32 val)\r\n{\r\nwritel_relaxed(val, chip->base + reg);\r\n}\r\nstatic void tangox_dispatch_irqs(struct irq_domain *dom, unsigned int status,\r\nint base)\r\n{\r\nunsigned int hwirq;\r\nunsigned int virq;\r\nwhile (status) {\r\nhwirq = __ffs(status);\r\nvirq = irq_find_mapping(dom, base + hwirq);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nstatus &= ~BIT(hwirq);\r\n}\r\n}\r\nstatic void tangox_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_domain *dom = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *host_chip = irq_desc_get_chip(desc);\r\nstruct tangox_irq_chip *chip = dom->host_data;\r\nunsigned int status_lo, status_hi;\r\nchained_irq_enter(host_chip, desc);\r\nstatus_lo = intc_readl(chip, chip->ctl + IRQ_STATUS);\r\nstatus_hi = intc_readl(chip, chip->ctl + IRQ_CTL_HI + IRQ_STATUS);\r\ntangox_dispatch_irqs(dom, status_lo, 0);\r\ntangox_dispatch_irqs(dom, status_hi, 32);\r\nchained_irq_exit(host_chip, desc);\r\n}\r\nstatic int tangox_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct tangox_irq_chip *chip = gc->domain->host_data;\r\nstruct irq_chip_regs *regs = &gc->chip_types[0].regs;\r\nswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nintc_writel(chip, regs->type + EDGE_CFG_RISE_SET, d->mask);\r\nintc_writel(chip, regs->type + EDGE_CFG_FALL_CLR, d->mask);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nintc_writel(chip, regs->type + EDGE_CFG_RISE_CLR, d->mask);\r\nintc_writel(chip, regs->type + EDGE_CFG_FALL_SET, d->mask);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nintc_writel(chip, regs->type + EDGE_CFG_RISE_CLR, d->mask);\r\nintc_writel(chip, regs->type + EDGE_CFG_FALL_CLR, d->mask);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nintc_writel(chip, regs->type + EDGE_CFG_RISE_SET, d->mask);\r\nintc_writel(chip, regs->type + EDGE_CFG_FALL_SET, d->mask);\r\nbreak;\r\ndefault:\r\npr_err("Invalid trigger mode %x for IRQ %d\n",\r\nflow_type, d->irq);\r\nreturn -EINVAL;\r\n}\r\nreturn irq_setup_alt_chip(d, flow_type);\r\n}\r\nstatic void __init tangox_irq_init_chip(struct irq_chip_generic *gc,\r\nunsigned long ctl_offs,\r\nunsigned long edge_offs)\r\n{\r\nstruct tangox_irq_chip *chip = gc->domain->host_data;\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nunsigned long ctl_base = chip->ctl + ctl_offs;\r\nunsigned long edge_base = EDGE_CTL_BASE + edge_offs;\r\nint i;\r\ngc->reg_base = chip->base;\r\ngc->unused = 0;\r\nfor (i = 0; i < 2; i++) {\r\nct[i].chip.irq_ack = irq_gc_ack_set_bit;\r\nct[i].chip.irq_mask = irq_gc_mask_disable_reg;\r\nct[i].chip.irq_mask_ack = irq_gc_mask_disable_reg_and_ack;\r\nct[i].chip.irq_unmask = irq_gc_unmask_enable_reg;\r\nct[i].chip.irq_set_type = tangox_irq_set_type;\r\nct[i].chip.name = gc->domain->name;\r\nct[i].regs.enable = ctl_base + IRQ_EN_SET;\r\nct[i].regs.disable = ctl_base + IRQ_EN_CLR;\r\nct[i].regs.ack = edge_base + EDGE_RAWSTAT;\r\nct[i].regs.type = edge_base;\r\n}\r\nct[0].type = IRQ_TYPE_LEVEL_MASK;\r\nct[0].handler = handle_level_irq;\r\nct[1].type = IRQ_TYPE_EDGE_BOTH;\r\nct[1].handler = handle_edge_irq;\r\nintc_writel(chip, ct->regs.disable, 0xffffffff);\r\nintc_writel(chip, ct->regs.ack, 0xffffffff);\r\n}\r\nstatic void __init tangox_irq_domain_init(struct irq_domain *dom)\r\n{\r\nstruct irq_chip_generic *gc;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ngc = irq_get_domain_generic_chip(dom, i * 32);\r\ntangox_irq_init_chip(gc, i * IRQ_CTL_HI, i * EDGE_CTL_HI);\r\n}\r\n}\r\nstatic int __init tangox_irq_init(void __iomem *base, struct resource *baseres,\r\nstruct device_node *node)\r\n{\r\nstruct tangox_irq_chip *chip;\r\nstruct irq_domain *dom;\r\nstruct resource res;\r\nint irq;\r\nint err;\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (!irq)\r\npanic("%s: failed to get IRQ", node->name);\r\nerr = of_address_to_resource(node, 0, &res);\r\nif (err)\r\npanic("%s: failed to get address", node->name);\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nchip->ctl = res.start - baseres->start;\r\nchip->base = base;\r\ndom = irq_domain_add_linear(node, 64, &irq_generic_chip_ops, chip);\r\nif (!dom)\r\npanic("%s: failed to create irqdomain", node->name);\r\nerr = irq_alloc_domain_generic_chips(dom, 32, 2, node->name,\r\nhandle_level_irq, 0, 0, 0);\r\nif (err)\r\npanic("%s: failed to allocate irqchip", node->name);\r\ntangox_irq_domain_init(dom);\r\nirq_set_chained_handler(irq, tangox_irq_handler);\r\nirq_set_handler_data(irq, dom);\r\nreturn 0;\r\n}\r\nstatic int __init tangox_of_irq_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct device_node *c;\r\nstruct resource res;\r\nvoid __iomem *base;\r\nbase = of_iomap(node, 0);\r\nif (!base)\r\npanic("%s: of_iomap failed", node->name);\r\nof_address_to_resource(node, 0, &res);\r\nfor_each_child_of_node(node, c)\r\ntangox_irq_init(base, &res, c);\r\nreturn 0;\r\n}
