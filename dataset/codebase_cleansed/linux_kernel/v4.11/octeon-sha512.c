static void octeon_sha512_store_hash(struct sha512_state *sctx)\r\n{\r\nwrite_octeon_64bit_hash_sha512(sctx->state[0], 0);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[1], 1);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[2], 2);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[3], 3);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[4], 4);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[5], 5);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[6], 6);\r\nwrite_octeon_64bit_hash_sha512(sctx->state[7], 7);\r\n}\r\nstatic void octeon_sha512_read_hash(struct sha512_state *sctx)\r\n{\r\nsctx->state[0] = read_octeon_64bit_hash_sha512(0);\r\nsctx->state[1] = read_octeon_64bit_hash_sha512(1);\r\nsctx->state[2] = read_octeon_64bit_hash_sha512(2);\r\nsctx->state[3] = read_octeon_64bit_hash_sha512(3);\r\nsctx->state[4] = read_octeon_64bit_hash_sha512(4);\r\nsctx->state[5] = read_octeon_64bit_hash_sha512(5);\r\nsctx->state[6] = read_octeon_64bit_hash_sha512(6);\r\nsctx->state[7] = read_octeon_64bit_hash_sha512(7);\r\n}\r\nstatic void octeon_sha512_transform(const void *_block)\r\n{\r\nconst u64 *block = _block;\r\nwrite_octeon_64bit_block_sha512(block[0], 0);\r\nwrite_octeon_64bit_block_sha512(block[1], 1);\r\nwrite_octeon_64bit_block_sha512(block[2], 2);\r\nwrite_octeon_64bit_block_sha512(block[3], 3);\r\nwrite_octeon_64bit_block_sha512(block[4], 4);\r\nwrite_octeon_64bit_block_sha512(block[5], 5);\r\nwrite_octeon_64bit_block_sha512(block[6], 6);\r\nwrite_octeon_64bit_block_sha512(block[7], 7);\r\nwrite_octeon_64bit_block_sha512(block[8], 8);\r\nwrite_octeon_64bit_block_sha512(block[9], 9);\r\nwrite_octeon_64bit_block_sha512(block[10], 10);\r\nwrite_octeon_64bit_block_sha512(block[11], 11);\r\nwrite_octeon_64bit_block_sha512(block[12], 12);\r\nwrite_octeon_64bit_block_sha512(block[13], 13);\r\nwrite_octeon_64bit_block_sha512(block[14], 14);\r\nocteon_sha512_start(block[15]);\r\n}\r\nstatic int octeon_sha512_init(struct shash_desc *desc)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nsctx->state[0] = SHA512_H0;\r\nsctx->state[1] = SHA512_H1;\r\nsctx->state[2] = SHA512_H2;\r\nsctx->state[3] = SHA512_H3;\r\nsctx->state[4] = SHA512_H4;\r\nsctx->state[5] = SHA512_H5;\r\nsctx->state[6] = SHA512_H6;\r\nsctx->state[7] = SHA512_H7;\r\nsctx->count[0] = sctx->count[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int octeon_sha384_init(struct shash_desc *desc)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nsctx->state[0] = SHA384_H0;\r\nsctx->state[1] = SHA384_H1;\r\nsctx->state[2] = SHA384_H2;\r\nsctx->state[3] = SHA384_H3;\r\nsctx->state[4] = SHA384_H4;\r\nsctx->state[5] = SHA384_H5;\r\nsctx->state[6] = SHA384_H6;\r\nsctx->state[7] = SHA384_H7;\r\nsctx->count[0] = sctx->count[1] = 0;\r\nreturn 0;\r\n}\r\nstatic void __octeon_sha512_update(struct sha512_state *sctx, const u8 *data,\r\nunsigned int len)\r\n{\r\nunsigned int part_len;\r\nunsigned int index;\r\nunsigned int i;\r\nindex = sctx->count[0] % SHA512_BLOCK_SIZE;\r\nif ((sctx->count[0] += len) < len)\r\nsctx->count[1]++;\r\npart_len = SHA512_BLOCK_SIZE - index;\r\nif (len >= part_len) {\r\nmemcpy(&sctx->buf[index], data, part_len);\r\nocteon_sha512_transform(sctx->buf);\r\nfor (i = part_len; i + SHA512_BLOCK_SIZE <= len;\r\ni += SHA512_BLOCK_SIZE)\r\nocteon_sha512_transform(&data[i]);\r\nindex = 0;\r\n} else {\r\ni = 0;\r\n}\r\nmemcpy(&sctx->buf[index], &data[i], len - i);\r\n}\r\nstatic int octeon_sha512_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nstruct octeon_cop2_state state;\r\nunsigned long flags;\r\nif ((sctx->count[0] % SHA512_BLOCK_SIZE) + len < SHA512_BLOCK_SIZE)\r\nreturn crypto_sha512_update(desc, data, len);\r\nflags = octeon_crypto_enable(&state);\r\nocteon_sha512_store_hash(sctx);\r\n__octeon_sha512_update(sctx, data, len);\r\nocteon_sha512_read_hash(sctx);\r\nocteon_crypto_disable(&state, flags);\r\nreturn 0;\r\n}\r\nstatic int octeon_sha512_final(struct shash_desc *desc, u8 *hash)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nstatic u8 padding[128] = { 0x80, };\r\nstruct octeon_cop2_state state;\r\n__be64 *dst = (__be64 *)hash;\r\nunsigned int pad_len;\r\nunsigned long flags;\r\nunsigned int index;\r\n__be64 bits[2];\r\nint i;\r\nbits[1] = cpu_to_be64(sctx->count[0] << 3);\r\nbits[0] = cpu_to_be64(sctx->count[1] << 3 | sctx->count[0] >> 61);\r\nindex = sctx->count[0] & 0x7f;\r\npad_len = (index < 112) ? (112 - index) : ((128+112) - index);\r\nflags = octeon_crypto_enable(&state);\r\nocteon_sha512_store_hash(sctx);\r\n__octeon_sha512_update(sctx, padding, pad_len);\r\n__octeon_sha512_update(sctx, (const u8 *)bits, sizeof(bits));\r\nocteon_sha512_read_hash(sctx);\r\nocteon_crypto_disable(&state, flags);\r\nfor (i = 0; i < 8; i++)\r\ndst[i] = cpu_to_be64(sctx->state[i]);\r\nmemset(sctx, 0, sizeof(struct sha512_state));\r\nreturn 0;\r\n}\r\nstatic int octeon_sha384_final(struct shash_desc *desc, u8 *hash)\r\n{\r\nu8 D[64];\r\nocteon_sha512_final(desc, D);\r\nmemcpy(hash, D, 48);\r\nmemzero_explicit(D, 64);\r\nreturn 0;\r\n}\r\nstatic int __init octeon_sha512_mod_init(void)\r\n{\r\nif (!octeon_has_crypto())\r\nreturn -ENOTSUPP;\r\nreturn crypto_register_shashes(octeon_sha512_algs,\r\nARRAY_SIZE(octeon_sha512_algs));\r\n}\r\nstatic void __exit octeon_sha512_mod_fini(void)\r\n{\r\ncrypto_unregister_shashes(octeon_sha512_algs,\r\nARRAY_SIZE(octeon_sha512_algs));\r\n}
