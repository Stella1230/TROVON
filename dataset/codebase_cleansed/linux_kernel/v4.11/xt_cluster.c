static inline u32 nf_ct_orig_ipv4_src(const struct nf_conn *ct)\r\n{\r\nreturn (__force u32)ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\r\n}\r\nstatic inline const u32 *nf_ct_orig_ipv6_src(const struct nf_conn *ct)\r\n{\r\nreturn (__force u32 *)ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip6;\r\n}\r\nstatic inline u_int32_t\r\nxt_cluster_hash_ipv4(u_int32_t ip, const struct xt_cluster_match_info *info)\r\n{\r\nreturn jhash_1word(ip, info->hash_seed);\r\n}\r\nstatic inline u_int32_t\r\nxt_cluster_hash_ipv6(const void *ip, const struct xt_cluster_match_info *info)\r\n{\r\nreturn jhash2(ip, NF_CT_TUPLE_L3SIZE / sizeof(__u32), info->hash_seed);\r\n}\r\nstatic inline u_int32_t\r\nxt_cluster_hash(const struct nf_conn *ct,\r\nconst struct xt_cluster_match_info *info)\r\n{\r\nu_int32_t hash = 0;\r\nswitch(nf_ct_l3num(ct)) {\r\ncase AF_INET:\r\nhash = xt_cluster_hash_ipv4(nf_ct_orig_ipv4_src(ct), info);\r\nbreak;\r\ncase AF_INET6:\r\nhash = xt_cluster_hash_ipv6(nf_ct_orig_ipv6_src(ct), info);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn reciprocal_scale(hash, info->total_nodes);\r\n}\r\nstatic inline bool\r\nxt_cluster_ipv6_is_multicast(const struct in6_addr *addr)\r\n{\r\n__be32 st = addr->s6_addr32[0];\r\nreturn ((st & htonl(0xFF000000)) == htonl(0xFF000000));\r\n}\r\nstatic inline bool\r\nxt_cluster_is_multicast_addr(const struct sk_buff *skb, u_int8_t family)\r\n{\r\nbool is_multicast = false;\r\nswitch(family) {\r\ncase NFPROTO_IPV4:\r\nis_multicast = ipv4_is_multicast(ip_hdr(skb)->daddr);\r\nbreak;\r\ncase NFPROTO_IPV6:\r\nis_multicast =\r\nxt_cluster_ipv6_is_multicast(&ipv6_hdr(skb)->daddr);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nreturn is_multicast;\r\n}\r\nstatic bool\r\nxt_cluster_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct sk_buff *pskb = (struct sk_buff *)skb;\r\nconst struct xt_cluster_match_info *info = par->matchinfo;\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nunsigned long hash;\r\nif (!xt_cluster_is_multicast_addr(skb, xt_family(par)) &&\r\nskb->pkt_type == PACKET_MULTICAST) {\r\npskb->pkt_type = PACKET_HOST;\r\n}\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn false;\r\nif (nf_ct_is_untracked(ct))\r\nreturn false;\r\nif (ct->master)\r\nhash = xt_cluster_hash(ct->master, info);\r\nelse\r\nhash = xt_cluster_hash(ct, info);\r\nreturn !!((1 << hash) & info->node_mask) ^\r\n!!(info->flags & XT_CLUSTER_F_INV);\r\n}\r\nstatic int xt_cluster_mt_checkentry(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_cluster_match_info *info = par->matchinfo;\r\nif (info->total_nodes > XT_CLUSTER_NODES_MAX) {\r\npr_info("you have exceeded the maximum "\r\n"number of cluster nodes (%u > %u)\n",\r\ninfo->total_nodes, XT_CLUSTER_NODES_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (info->node_mask >= (1ULL << info->total_nodes)) {\r\npr_info("this node mask cannot be "\r\n"higher than the total number of nodes\n");\r\nreturn -EDOM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xt_cluster_mt_init(void)\r\n{\r\nreturn xt_register_match(&xt_cluster_match);\r\n}\r\nstatic void __exit xt_cluster_mt_fini(void)\r\n{\r\nxt_unregister_match(&xt_cluster_match);\r\n}
