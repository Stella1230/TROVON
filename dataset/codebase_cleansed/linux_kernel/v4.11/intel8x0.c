static inline u8 igetbyte(struct intel8x0 *chip, u32 offset)\r\n{\r\nreturn ioread8(chip->bmaddr + offset);\r\n}\r\nstatic inline u16 igetword(struct intel8x0 *chip, u32 offset)\r\n{\r\nreturn ioread16(chip->bmaddr + offset);\r\n}\r\nstatic inline u32 igetdword(struct intel8x0 *chip, u32 offset)\r\n{\r\nreturn ioread32(chip->bmaddr + offset);\r\n}\r\nstatic inline void iputbyte(struct intel8x0 *chip, u32 offset, u8 val)\r\n{\r\niowrite8(val, chip->bmaddr + offset);\r\n}\r\nstatic inline void iputword(struct intel8x0 *chip, u32 offset, u16 val)\r\n{\r\niowrite16(val, chip->bmaddr + offset);\r\n}\r\nstatic inline void iputdword(struct intel8x0 *chip, u32 offset, u32 val)\r\n{\r\niowrite32(val, chip->bmaddr + offset);\r\n}\r\nstatic inline u16 iagetword(struct intel8x0 *chip, u32 offset)\r\n{\r\nreturn ioread16(chip->addr + offset);\r\n}\r\nstatic inline void iaputword(struct intel8x0 *chip, u32 offset, u16 val)\r\n{\r\niowrite16(val, chip->addr + offset);\r\n}\r\nstatic int snd_intel8x0_codec_semaphore(struct intel8x0 *chip, unsigned int codec)\r\n{\r\nint time;\r\nif (codec > 2)\r\nreturn -EIO;\r\nif (chip->in_sdin_init) {\r\ncodec = chip->codec_isr_bits;\r\n} else {\r\ncodec = chip->codec_bit[chip->ac97_sdin[codec]];\r\n}\r\nif ((igetdword(chip, ICHREG(GLOB_STA)) & codec) == 0)\r\nreturn -EIO;\r\nif (chip->buggy_semaphore)\r\nreturn 0;\r\ntime = 100;\r\ndo {\r\nif (!(igetbyte(chip, ICHREG(ACC_SEMA)) & ICH_CAS))\r\nreturn 0;\r\nudelay(10);\r\n} while (time--);\r\ndev_err(chip->card->dev,\r\n"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",\r\nigetbyte(chip, ICHREG(ACC_SEMA)), igetdword(chip, ICHREG(GLOB_STA)));\r\niagetword(chip, 0);\r\nreturn -EBUSY;\r\n}\r\nstatic void snd_intel8x0_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct intel8x0 *chip = ac97->private_data;\r\nif (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_write %d: semaphore is not ready for register 0x%x\n",\r\nac97->num, reg);\r\n}\r\niaputword(chip, reg + ac97->num * 0x80, val);\r\n}\r\nstatic unsigned short snd_intel8x0_codec_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct intel8x0 *chip = ac97->private_data;\r\nunsigned short res;\r\nunsigned int tmp;\r\nif (snd_intel8x0_codec_semaphore(chip, ac97->num) < 0) {\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_read %d: semaphore is not ready for register 0x%x\n",\r\nac97->num, reg);\r\nres = 0xffff;\r\n} else {\r\nres = iagetword(chip, reg + ac97->num * 0x80);\r\nif ((tmp = igetdword(chip, ICHREG(GLOB_STA))) & ICH_RCS) {\r\niputdword(chip, ICHREG(GLOB_STA), tmp &\r\n~(chip->codec_ready_bits | ICH_GSCI));\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_read %d: read timeout for register 0x%x\n",\r\nac97->num, reg);\r\nres = 0xffff;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic void snd_intel8x0_codec_read_test(struct intel8x0 *chip,\r\nunsigned int codec)\r\n{\r\nunsigned int tmp;\r\nif (snd_intel8x0_codec_semaphore(chip, codec) >= 0) {\r\niagetword(chip, codec * 0x80);\r\nif ((tmp = igetdword(chip, ICHREG(GLOB_STA))) & ICH_RCS) {\r\niputdword(chip, ICHREG(GLOB_STA), tmp &\r\n~(chip->codec_ready_bits | ICH_GSCI));\r\n}\r\n}\r\n}\r\nstatic int snd_intel8x0_ali_codec_ready(struct intel8x0 *chip, int mask)\r\n{\r\nint count = 0;\r\nfor (count = 0; count < 0x7f; count++) {\r\nint val = igetbyte(chip, ICHREG(ALI_CSPSR));\r\nif (val & mask)\r\nreturn 0;\r\n}\r\nif (! chip->in_ac97_init)\r\ndev_warn(chip->card->dev, "AC97 codec ready timeout.\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int snd_intel8x0_ali_codec_semaphore(struct intel8x0 *chip)\r\n{\r\nint time = 100;\r\nif (chip->buggy_semaphore)\r\nreturn 0;\r\nwhile (--time && (igetdword(chip, ICHREG(ALI_CAS)) & ALI_CAS_SEM_BUSY))\r\nudelay(1);\r\nif (! time && ! chip->in_ac97_init)\r\ndev_warn(chip->card->dev, "ali_codec_semaphore timeout\n");\r\nreturn snd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_CODEC_READY);\r\n}\r\nstatic unsigned short snd_intel8x0_ali_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct intel8x0 *chip = ac97->private_data;\r\nunsigned short data = 0xffff;\r\nif (snd_intel8x0_ali_codec_semaphore(chip))\r\ngoto __err;\r\nreg |= ALI_CPR_ADDR_READ;\r\nif (ac97->num)\r\nreg |= ALI_CPR_ADDR_SECONDARY;\r\niputword(chip, ICHREG(ALI_CPR_ADDR), reg);\r\nif (snd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_READ_OK))\r\ngoto __err;\r\ndata = igetword(chip, ICHREG(ALI_SPR));\r\n__err:\r\nreturn data;\r\n}\r\nstatic void snd_intel8x0_ali_codec_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct intel8x0 *chip = ac97->private_data;\r\nif (snd_intel8x0_ali_codec_semaphore(chip))\r\nreturn;\r\niputword(chip, ICHREG(ALI_CPR), val);\r\nif (ac97->num)\r\nreg |= ALI_CPR_ADDR_SECONDARY;\r\niputword(chip, ICHREG(ALI_CPR_ADDR), reg);\r\nsnd_intel8x0_ali_codec_ready(chip, ALI_CSPSR_WRITE_OK);\r\n}\r\nstatic void snd_intel8x0_setup_periods(struct intel8x0 *chip, struct ichdev *ichdev)\r\n{\r\nint idx;\r\nu32 *bdbar = ichdev->bdbar;\r\nunsigned long port = ichdev->reg_offset;\r\niputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\r\nif (ichdev->size == ichdev->fragsize) {\r\nichdev->ack_reload = ichdev->ack = 2;\r\nichdev->fragsize1 = ichdev->fragsize >> 1;\r\nfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 4) {\r\nbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf);\r\nbdbar[idx + 1] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize1 >> ichdev->pos_shift);\r\nbdbar[idx + 2] = cpu_to_le32(ichdev->physbuf + (ichdev->size >> 1));\r\nbdbar[idx + 3] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize1 >> ichdev->pos_shift);\r\n}\r\nichdev->frags = 2;\r\n} else {\r\nichdev->ack_reload = ichdev->ack = 1;\r\nichdev->fragsize1 = ichdev->fragsize;\r\nfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 2) {\r\nbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf +\r\n(((idx >> 1) * ichdev->fragsize) %\r\nichdev->size));\r\nbdbar[idx + 1] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize >> ichdev->pos_shift);\r\n#if 0\r\ndev_dbg(chip->card->dev, "bdbar[%i] = 0x%x [0x%x]\n",\r\nidx + 0, bdbar[idx + 0], bdbar[idx + 1]);\r\n#endif\r\n}\r\nichdev->frags = ichdev->size / ichdev->fragsize;\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi = ICH_REG_LVI_MASK);\r\nichdev->civ = 0;\r\niputbyte(chip, port + ICH_REG_OFF_CIV, 0);\r\nichdev->lvi_frag = ICH_REG_LVI_MASK % ichdev->frags;\r\nichdev->position = 0;\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"lvi_frag = %i, frags = %i, period_size = 0x%x, period_size1 = 0x%x\n",\r\nichdev->lvi_frag, ichdev->frags, ichdev->fragsize,\r\nichdev->fragsize1);\r\n#endif\r\niputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\r\n}\r\nstatic void fill_nocache(void *buf, int size, int nocache)\r\n{\r\nsize = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (nocache)\r\nset_pages_uc(virt_to_page(buf), size);\r\nelse\r\nset_pages_wb(virt_to_page(buf), size);\r\n}\r\nstatic inline void snd_intel8x0_update(struct intel8x0 *chip, struct ichdev *ichdev)\r\n{\r\nunsigned long port = ichdev->reg_offset;\r\nunsigned long flags;\r\nint status, civ, i, step;\r\nint ack = 0;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nstatus = igetbyte(chip, port + ichdev->roff_sr);\r\nciv = igetbyte(chip, port + ICH_REG_OFF_CIV);\r\nif (!(status & ICH_BCIS)) {\r\nstep = 0;\r\n} else if (civ == ichdev->civ) {\r\nstep = 1;\r\nichdev->civ++;\r\nichdev->civ &= ICH_REG_LVI_MASK;\r\n} else {\r\nstep = civ - ichdev->civ;\r\nif (step < 0)\r\nstep += ICH_REG_LVI_MASK + 1;\r\nichdev->civ = civ;\r\n}\r\nichdev->position += step * ichdev->fragsize1;\r\nif (! chip->in_measurement)\r\nichdev->position %= ichdev->size;\r\nichdev->lvi += step;\r\nichdev->lvi &= ICH_REG_LVI_MASK;\r\niputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\r\nfor (i = 0; i < step; i++) {\r\nichdev->lvi_frag++;\r\nichdev->lvi_frag %= ichdev->frags;\r\nichdev->bdbar[ichdev->lvi * 2] = cpu_to_le32(ichdev->physbuf + ichdev->lvi_frag * ichdev->fragsize1);\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"new: bdbar[%i] = 0x%x [0x%x], prefetch = %i, all = 0x%x, 0x%x\n",\r\nichdev->lvi * 2, ichdev->bdbar[ichdev->lvi * 2],\r\nichdev->bdbar[ichdev->lvi * 2 + 1], inb(ICH_REG_OFF_PIV + port),\r\ninl(port + 4), inb(port + ICH_REG_OFF_CR));\r\n#endif\r\nif (--ichdev->ack == 0) {\r\nichdev->ack = ichdev->ack_reload;\r\nack = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (ack && ichdev->substream) {\r\nsnd_pcm_period_elapsed(ichdev->substream);\r\n}\r\niputbyte(chip, port + ichdev->roff_sr,\r\nstatus & (ICH_FIFOE | ICH_BCIS | ICH_LVBCI));\r\n}\r\nstatic irqreturn_t snd_intel8x0_interrupt(int irq, void *dev_id)\r\n{\r\nstruct intel8x0 *chip = dev_id;\r\nstruct ichdev *ichdev;\r\nunsigned int status;\r\nunsigned int i;\r\nstatus = igetdword(chip, chip->int_sta_reg);\r\nif (status == 0xffffffff)\r\nreturn IRQ_NONE;\r\nif ((status & chip->int_sta_mask) == 0) {\r\nif (status) {\r\niputdword(chip, chip->int_sta_reg, status);\r\nif (! chip->buggy_irq)\r\nstatus = 0;\r\n}\r\nreturn IRQ_RETVAL(status);\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nif (status & ichdev->int_sta_mask)\r\nsnd_intel8x0_update(chip, ichdev);\r\n}\r\niputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_intel8x0_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nunsigned char val = 0;\r\nunsigned long port = ichdev->reg_offset;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nichdev->suspended = 0;\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nval = ICH_IOCE | ICH_STARTBM;\r\nichdev->last_pos = ichdev->position;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nichdev->suspended = 1;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nval = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval = ICH_IOCE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_CR, val);\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nwhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH)) ;\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_ali_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nunsigned long port = ichdev->reg_offset;\r\nstatic int fiforeg[] = {\r\nICHREG(ALI_FIFOCR1), ICHREG(ALI_FIFOCR2), ICHREG(ALI_FIFOCR3)\r\n};\r\nunsigned int val, fifo;\r\nval = igetdword(chip, ICHREG(ALI_DMACR));\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nichdev->suspended = 0;\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfifo = igetdword(chip, fiforeg[ichdev->ali_slot / 4]);\r\nfifo &= ~(0xff << (ichdev->ali_slot % 4));\r\nfifo |= 0x83 << (ichdev->ali_slot % 4);\r\niputdword(chip, fiforeg[ichdev->ali_slot / 4], fifo);\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE);\r\nval &= ~(1 << (ichdev->ali_slot + 16));\r\niputdword(chip, ICHREG(ALI_DMACR), val | (1 << ichdev->ali_slot));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nichdev->suspended = 1;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\niputdword(chip, ICHREG(ALI_DMACR), val | (1 << (ichdev->ali_slot + 16)));\r\niputbyte(chip, port + ICH_REG_OFF_CR, 0);\r\nwhile (igetbyte(chip, port + ICH_REG_OFF_CR))\r\n;\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\r\nbreak;\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\r\niputbyte(chip, port + ICH_REG_OFF_SR,\r\nigetbyte(chip, port + ICH_REG_OFF_SR) | 0x1e);\r\niputdword(chip, ICHREG(ALI_INTERRUPTSR),\r\nigetdword(chip, ICHREG(ALI_INTERRUPTSR)) & ichdev->int_sta_mask);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint dbl = params_rate(hw_params) > 48000;\r\nint err;\r\nif (chip->fix_nocache && ichdev->page_attr_changed) {\r\nfill_nocache(runtime->dma_area, runtime->dma_bytes, 0);\r\nichdev->page_attr_changed = 0;\r\n}\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (chip->fix_nocache) {\r\nif (runtime->dma_area && ! ichdev->page_attr_changed) {\r\nfill_nocache(runtime->dma_area, runtime->dma_bytes, 1);\r\nichdev->page_attr_changed = 1;\r\n}\r\n}\r\nif (ichdev->pcm_open_flag) {\r\nsnd_ac97_pcm_close(ichdev->pcm);\r\nichdev->pcm_open_flag = 0;\r\n}\r\nerr = snd_ac97_pcm_open(ichdev->pcm, params_rate(hw_params),\r\nparams_channels(hw_params),\r\nichdev->pcm->r[dbl].slots);\r\nif (err >= 0) {\r\nichdev->pcm_open_flag = 1;\r\nif (ichdev->ichd == ICHD_PCMOUT && chip->spdif_idx < 0)\r\nsnd_ac97_set_rate(ichdev->pcm->r[0].codec[0], AC97_SPDIF,\r\nparams_rate(hw_params));\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_intel8x0_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nif (ichdev->pcm_open_flag) {\r\nsnd_ac97_pcm_close(ichdev->pcm);\r\nichdev->pcm_open_flag = 0;\r\n}\r\nif (chip->fix_nocache && ichdev->page_attr_changed) {\r\nfill_nocache(substream->runtime->dma_area, substream->runtime->dma_bytes, 0);\r\nichdev->page_attr_changed = 0;\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void snd_intel8x0_setup_pcm_out(struct intel8x0 *chip,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nunsigned int cnt;\r\nint dbl = runtime->rate > 48000;\r\nspin_lock_irq(&chip->reg_lock);\r\nswitch (chip->device_type) {\r\ncase DEVICE_ALI:\r\ncnt = igetdword(chip, ICHREG(ALI_SCR));\r\ncnt &= ~ICH_ALI_SC_PCM_246_MASK;\r\nif (runtime->channels == 4 || dbl)\r\ncnt |= ICH_ALI_SC_PCM_4;\r\nelse if (runtime->channels == 6)\r\ncnt |= ICH_ALI_SC_PCM_6;\r\niputdword(chip, ICHREG(ALI_SCR), cnt);\r\nbreak;\r\ncase DEVICE_SIS:\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\ncnt &= ~ICH_SIS_PCM_246_MASK;\r\nif (runtime->channels == 4 || dbl)\r\ncnt |= ICH_SIS_PCM_4;\r\nelse if (runtime->channels == 6)\r\ncnt |= ICH_SIS_PCM_6;\r\niputdword(chip, ICHREG(GLOB_CNT), cnt);\r\nbreak;\r\ndefault:\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\ncnt &= ~(ICH_PCM_246_MASK | ICH_PCM_20BIT);\r\nif (runtime->channels == 4 || dbl)\r\ncnt |= ICH_PCM_4;\r\nelse if (runtime->channels == 6)\r\ncnt |= ICH_PCM_6;\r\nelse if (runtime->channels == 8)\r\ncnt |= ICH_PCM_8;\r\nif (chip->device_type == DEVICE_NFORCE) {\r\nif (cnt & ICH_PCM_246_MASK) {\r\niputdword(chip, ICHREG(GLOB_CNT), cnt & ~ICH_PCM_246_MASK);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmsleep(50);\r\nspin_lock_irq(&chip->reg_lock);\r\n}\r\n} else if (chip->device_type == DEVICE_INTEL_ICH4) {\r\nif (runtime->sample_bits > 16)\r\ncnt |= ICH_PCM_20BIT;\r\n}\r\niputdword(chip, ICHREG(GLOB_CNT), cnt);\r\nbreak;\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic int snd_intel8x0_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nichdev->physbuf = runtime->dma_addr;\r\nichdev->size = snd_pcm_lib_buffer_bytes(substream);\r\nichdev->fragsize = snd_pcm_lib_period_bytes(substream);\r\nif (ichdev->ichd == ICHD_PCMOUT) {\r\nsnd_intel8x0_setup_pcm_out(chip, runtime);\r\nif (chip->device_type == DEVICE_INTEL_ICH4)\r\nichdev->pos_shift = (runtime->sample_bits > 16) ? 2 : 1;\r\n}\r\nsnd_intel8x0_setup_periods(chip, ichdev);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_intel8x0_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nsize_t ptr1, ptr;\r\nint civ, timeout = 10;\r\nunsigned int position;\r\nspin_lock(&chip->reg_lock);\r\ndo {\r\nciv = igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV);\r\nptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb);\r\nposition = ichdev->position;\r\nif (ptr1 == 0) {\r\nudelay(10);\r\ncontinue;\r\n}\r\nif (civ != igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV))\r\ncontinue;\r\nif (chip->inside_vm)\r\nbreak;\r\nif (ptr1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))\r\nbreak;\r\n} while (timeout--);\r\nptr = ichdev->last_pos;\r\nif (ptr1 != 0) {\r\nptr1 <<= ichdev->pos_shift;\r\nptr = ichdev->fragsize1 - ptr1;\r\nptr += position;\r\nif (ptr < ichdev->last_pos) {\r\nunsigned int pos_base, last_base;\r\npos_base = position / ichdev->fragsize1;\r\nlast_base = ichdev->last_pos / ichdev->fragsize1;\r\nif (pos_base == last_base)\r\nptr = ichdev->last_pos;\r\n}\r\n}\r\nichdev->last_pos = ptr;\r\nspin_unlock(&chip->reg_lock);\r\nif (ptr >= ichdev->size)\r\nreturn 0;\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_intel8x0_pcm_open(struct snd_pcm_substream *substream, struct ichdev *ichdev)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nichdev->substream = substream;\r\nruntime->hw = snd_intel8x0_stream;\r\nruntime->hw.rates = ichdev->pcm->rates;\r\nsnd_pcm_limit_hw_rates(runtime);\r\nif (chip->device_type == DEVICE_SIS) {\r\nruntime->hw.buffer_bytes_max = 64*1024;\r\nruntime->hw.period_bytes_max = 64*1024;\r\n}\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nruntime->private_data = ichdev;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMOUT]);\r\nif (err < 0)\r\nreturn err;\r\nif (chip->multi8) {\r\nruntime->hw.channels_max = 8;\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_channels8);\r\n} else if (chip->multi6) {\r\nruntime->hw.channels_max = 6;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_channels6);\r\n} else if (chip->multi4) {\r\nruntime->hw.channels_max = 4;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\n&hw_constraints_channels4);\r\n}\r\nif (chip->dra) {\r\nsnd_ac97_pcm_double_rate_rules(runtime);\r\n}\r\nif (chip->smp20bit) {\r\nruntime->hw.formats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 20);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_PCMOUT].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCMIN]);\r\n}\r\nstatic int snd_intel8x0_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_PCMIN].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_mic_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC]);\r\n}\r\nstatic int snd_intel8x0_mic_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_MIC].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_mic2_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_MIC2]);\r\n}\r\nstatic int snd_intel8x0_mic2_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_MIC2].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_capture2_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[ICHD_PCM2IN]);\r\n}\r\nstatic int snd_intel8x0_capture2_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_PCM2IN].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nint idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[idx]);\r\n}\r\nstatic int snd_intel8x0_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nint idx = chip->device_type == DEVICE_NFORCE ? NVD_SPBAR : ICHD_SPBAR;\r\nchip->ichd[idx].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_ali_ac97spdifout_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nunsigned int val;\r\nspin_lock_irq(&chip->reg_lock);\r\nval = igetdword(chip, ICHREG(ALI_INTERFACECR));\r\nval |= ICH_ALI_IF_AC97SP;\r\niputdword(chip, ICHREG(ALI_INTERFACECR), val);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn snd_intel8x0_pcm_open(substream, &chip->ichd[ALID_AC97SPDIFOUT]);\r\n}\r\nstatic int snd_intel8x0_ali_ac97spdifout_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0 *chip = snd_pcm_substream_chip(substream);\r\nunsigned int val;\r\nchip->ichd[ALID_AC97SPDIFOUT].substream = NULL;\r\nspin_lock_irq(&chip->reg_lock);\r\nval = igetdword(chip, ICHREG(ALI_INTERFACECR));\r\nval &= ~ICH_ALI_IF_AC97SP;\r\niputdword(chip, ICHREG(ALI_INTERFACECR), val);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_pcm1(struct intel8x0 *chip, int device,\r\nstruct ich_pcm_table *rec)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nchar name[32];\r\nif (rec->suffix)\r\nsprintf(name, "Intel ICH - %s", rec->suffix);\r\nelse\r\nstrcpy(name, "Intel ICH");\r\nerr = snd_pcm_new(chip->card, name, device,\r\nrec->playback_ops ? 1 : 0,\r\nrec->capture_ops ? 1 : 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (rec->playback_ops)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);\r\nif (rec->capture_ops)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nif (rec->suffix)\r\nsprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);\r\nelse\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm[device] = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nrec->prealloc_size, rec->prealloc_max_size);\r\nif (rec->playback_ops &&\r\nrec->playback_ops->open == snd_intel8x0_playback_open) {\r\nstruct snd_pcm_chmap *chmap;\r\nint chs = 2;\r\nif (chip->multi8)\r\nchs = 8;\r\nelse if (chip->multi6)\r\nchs = 6;\r\nelse if (chip->multi4)\r\nchs = 4;\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_alt_chmaps, chs, 0,\r\n&chmap);\r\nif (err < 0)\r\nreturn err;\r\nchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\r\nchip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_pcm(struct intel8x0 *chip)\r\n{\r\nint i, tblsize, device, err;\r\nstruct ich_pcm_table *tbl, *rec;\r\nswitch (chip->device_type) {\r\ncase DEVICE_INTEL_ICH4:\r\ntbl = intel_pcms;\r\ntblsize = ARRAY_SIZE(intel_pcms);\r\nif (spdif_aclink)\r\ntblsize--;\r\nbreak;\r\ncase DEVICE_NFORCE:\r\ntbl = nforce_pcms;\r\ntblsize = ARRAY_SIZE(nforce_pcms);\r\nif (spdif_aclink)\r\ntblsize--;\r\nbreak;\r\ncase DEVICE_ALI:\r\ntbl = ali_pcms;\r\ntblsize = ARRAY_SIZE(ali_pcms);\r\nbreak;\r\ndefault:\r\ntbl = intel_pcms;\r\ntblsize = 2;\r\nbreak;\r\n}\r\ndevice = 0;\r\nfor (i = 0; i < tblsize; i++) {\r\nrec = tbl + i;\r\nif (i > 0 && rec->ac97_idx) {\r\nif (! chip->ichd[rec->ac97_idx].pcm)\r\ncontinue;\r\n}\r\nerr = snd_intel8x0_pcm1(chip, device, rec);\r\nif (err < 0)\r\nreturn err;\r\ndevice++;\r\n}\r\nchip->pcm_devs = device;\r\nreturn 0;\r\n}\r\nstatic void snd_intel8x0_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct intel8x0 *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_intel8x0_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct intel8x0 *chip = ac97->private_data;\r\nchip->ac97[ac97->num] = NULL;\r\n}\r\nstatic int snd_intel8x0_mixer(struct intel8x0 *chip, int ac97_clock,\r\nconst char *quirk_override)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nunsigned int i, codecs;\r\nunsigned int glob_sta = 0;\r\nstruct snd_ac97_bus_ops *ops;\r\nstatic struct snd_ac97_bus_ops standard_bus_ops = {\r\n.write = snd_intel8x0_codec_write,\r\n.read = snd_intel8x0_codec_read,\r\n};\r\nstatic struct snd_ac97_bus_ops ali_bus_ops = {\r\n.write = snd_intel8x0_ali_codec_write,\r\n.read = snd_intel8x0_ali_codec_read,\r\n};\r\nchip->spdif_idx = -1;\r\nif (!spdif_aclink) {\r\nswitch (chip->device_type) {\r\ncase DEVICE_NFORCE:\r\nchip->spdif_idx = NVD_SPBAR;\r\nbreak;\r\ncase DEVICE_ALI:\r\nchip->spdif_idx = ALID_AC97SPDIFOUT;\r\nbreak;\r\ncase DEVICE_INTEL_ICH4:\r\nchip->spdif_idx = ICHD_SPBAR;\r\nbreak;\r\n}\r\n}\r\nchip->in_ac97_init = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_intel8x0_mixer_free_ac97;\r\nac97.scaps = AC97_SCAP_SKIP_MODEM | AC97_SCAP_POWER_SAVE;\r\nif (chip->xbox)\r\nac97.scaps |= AC97_SCAP_DETECT_BY_VENDOR;\r\nif (chip->device_type != DEVICE_ALI) {\r\nglob_sta = igetdword(chip, ICHREG(GLOB_STA));\r\nops = &standard_bus_ops;\r\nchip->in_sdin_init = 1;\r\ncodecs = 0;\r\nfor (i = 0; i < chip->max_codecs; i++) {\r\nif (! (glob_sta & chip->codec_bit[i]))\r\ncontinue;\r\nif (chip->device_type == DEVICE_INTEL_ICH4) {\r\nsnd_intel8x0_codec_read_test(chip, codecs);\r\nchip->ac97_sdin[codecs] =\r\nigetbyte(chip, ICHREG(SDM)) & ICH_LDI_MASK;\r\nif (snd_BUG_ON(chip->ac97_sdin[codecs] >= 3))\r\nchip->ac97_sdin[codecs] = 0;\r\n} else\r\nchip->ac97_sdin[codecs] = i;\r\ncodecs++;\r\n}\r\nchip->in_sdin_init = 0;\r\nif (! codecs)\r\ncodecs = 1;\r\n} else {\r\nops = &ali_bus_ops;\r\ncodecs = 1;\r\nfor (i = 0; i < 100; i++) {\r\nunsigned int reg = igetdword(chip, ICHREG(ALI_RTSR));\r\nif (reg & 0x40) {\r\ncodecs = 2;\r\nbreak;\r\n}\r\niputdword(chip, ICHREG(ALI_RTSR), reg | 0x40);\r\nudelay(1);\r\n}\r\n}\r\nif ((err = snd_ac97_bus(chip->card, 0, ops, chip, &pbus)) < 0)\r\ngoto __err;\r\npbus->private_free = snd_intel8x0_mixer_free_ac97_bus;\r\nif (ac97_clock >= 8000 && ac97_clock <= 48000)\r\npbus->clock = ac97_clock;\r\nif (chip->device_type == DEVICE_ALI)\r\npbus->no_vra = 1;\r\nelse\r\npbus->dra = 1;\r\nchip->ac97_bus = pbus;\r\nchip->ncodecs = codecs;\r\nac97.pci = chip->pci;\r\nfor (i = 0; i < codecs; i++) {\r\nac97.num = i;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97[i])) < 0) {\r\nif (err != -EACCES)\r\ndev_err(chip->card->dev,\r\n"Unable to initialize codec #%d\n", i);\r\nif (i == 0)\r\ngoto __err;\r\n}\r\n}\r\nsnd_ac97_tune_hardware(chip->ac97[0], ac97_quirks, quirk_override);\r\nif (chip->device_type == DEVICE_INTEL_ICH4)\r\npbus->isdin = 1;\r\ni = ARRAY_SIZE(ac97_pcm_defs);\r\nif (chip->device_type != DEVICE_INTEL_ICH4)\r\ni -= 2;\r\nif (chip->spdif_idx < 0)\r\ni--;\r\nerr = snd_ac97_pcm_assign(pbus, i, ac97_pcm_defs);\r\nif (err < 0)\r\ngoto __err;\r\nchip->ichd[ICHD_PCMOUT].pcm = &pbus->pcms[0];\r\nchip->ichd[ICHD_PCMIN].pcm = &pbus->pcms[1];\r\nchip->ichd[ICHD_MIC].pcm = &pbus->pcms[2];\r\nif (chip->spdif_idx >= 0)\r\nchip->ichd[chip->spdif_idx].pcm = &pbus->pcms[3];\r\nif (chip->device_type == DEVICE_INTEL_ICH4) {\r\nchip->ichd[ICHD_PCM2IN].pcm = &pbus->pcms[4];\r\nchip->ichd[ICHD_MIC2].pcm = &pbus->pcms[5];\r\n}\r\nif (chip->device_type == DEVICE_INTEL_ICH4) {\r\nstruct ac97_pcm *pcm = chip->ichd[ICHD_PCM2IN].pcm;\r\nu8 tmp = igetbyte(chip, ICHREG(SDM));\r\ntmp &= ~(ICH_DI2L_MASK|ICH_DI1L_MASK);\r\nif (pcm) {\r\ntmp |= ICH_SE;\r\ntmp |= chip->ac97_sdin[0] << ICH_DI1L_SHIFT;\r\nfor (i = 1; i < 4; i++) {\r\nif (pcm->r[0].codec[i]) {\r\ntmp |= chip->ac97_sdin[pcm->r[0].codec[1]->num] << ICH_DI2L_SHIFT;\r\nbreak;\r\n}\r\n}\r\n} else {\r\ntmp &= ~ICH_SE;\r\n}\r\niputbyte(chip, ICHREG(SDM), tmp);\r\n}\r\nif (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_PCM_SLEFT)) {\r\nchip->multi4 = 1;\r\nif (pbus->pcms[0].r[0].slots & (1 << AC97_SLOT_LFE)) {\r\nchip->multi6 = 1;\r\nif (chip->ac97[0]->flags & AC97_HAS_8CH)\r\nchip->multi8 = 1;\r\n}\r\n}\r\nif (pbus->pcms[0].r[1].rslots[0]) {\r\nchip->dra = 1;\r\n}\r\nif (chip->device_type == DEVICE_INTEL_ICH4) {\r\nif ((igetdword(chip, ICHREG(GLOB_STA)) & ICH_SAMPLE_CAP) == ICH_SAMPLE_16_20)\r\nchip->smp20bit = 1;\r\n}\r\nif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\r\nchip->ichd[chip->spdif_idx].pcm->rates = SNDRV_PCM_RATE_48000;\r\n}\r\nif (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {\r\nu32 val;\r\nval = igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_PCM_SPDIF_MASK;\r\nval |= ICH_PCM_SPDIF_1011;\r\niputdword(chip, ICHREG(GLOB_CNT), val);\r\nsnd_ac97_update_bits(chip->ac97[0], AC97_EXTENDED_STATUS, 0x03 << 4, 0x03 << 4);\r\n}\r\nchip->in_ac97_init = 0;\r\nreturn 0;\r\n__err:\r\nif (chip->device_type != DEVICE_ALI)\r\niputdword(chip, ICHREG(GLOB_CNT),\r\nigetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_AC97COLD);\r\nreturn err;\r\n}\r\nstatic void do_ali_reset(struct intel8x0 *chip)\r\n{\r\niputdword(chip, ICHREG(ALI_SCR), ICH_ALI_SC_RESET);\r\niputdword(chip, ICHREG(ALI_FIFOCR1), 0x83838383);\r\niputdword(chip, ICHREG(ALI_FIFOCR2), 0x83838383);\r\niputdword(chip, ICHREG(ALI_FIFOCR3), 0x83838383);\r\niputdword(chip, ICHREG(ALI_INTERFACECR),\r\nICH_ALI_IF_PI|ICH_ALI_IF_PO);\r\niputdword(chip, ICHREG(ALI_INTERRUPTCR), 0x00000000);\r\niputdword(chip, ICHREG(ALI_INTERRUPTSR), 0x00000000);\r\n}\r\nstatic int snd_intel8x0_ich_chip_cold_reset(struct intel8x0 *chip)\r\n{\r\nunsigned int cnt;\r\nif (snd_pci_quirk_lookup(chip->pci, ich_chip_reset_mode))\r\nreturn -EIO;\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\ncnt &= ~(ICH_ACLINK | ICH_PCM_246_MASK);\r\niputdword(chip, ICHREG(GLOB_CNT), cnt & ~ICH_AC97COLD);\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\nudelay(10);\r\niputdword(chip, ICHREG(GLOB_CNT), cnt | ICH_AC97COLD);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_ich_chip_reset(struct intel8x0 *chip)\r\n{\r\nunsigned long end_time;\r\nunsigned int cnt;\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\ncnt &= ~(ICH_ACLINK | ICH_PCM_246_MASK);\r\ncnt |= (cnt & ICH_AC97COLD) == 0 ? ICH_AC97COLD : ICH_AC97WARM;\r\niputdword(chip, ICHREG(GLOB_CNT), cnt);\r\nend_time = (jiffies + (HZ / 4)) + 1;\r\ndo {\r\nif ((igetdword(chip, ICHREG(GLOB_CNT)) & ICH_AC97WARM) == 0)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(chip->card->dev, "AC'97 warm reset still in progress? [0x%x]\n",\r\nigetdword(chip, ICHREG(GLOB_CNT)));\r\nreturn -EIO;\r\n}\r\nstatic int snd_intel8x0_ich_chip_init(struct intel8x0 *chip, int probing)\r\n{\r\nunsigned long end_time;\r\nunsigned int status, nstatus;\r\nunsigned int cnt;\r\nint err;\r\nstatus = ICH_RCS | ICH_MCINT | ICH_POINT | ICH_PIINT;\r\nif (chip->device_type == DEVICE_NFORCE)\r\nstatus |= ICH_NVSPINT;\r\ncnt = igetdword(chip, ICHREG(GLOB_STA));\r\niputdword(chip, ICHREG(GLOB_STA), cnt & status);\r\nif (snd_intel8x0_ich_chip_can_cold_reset(chip))\r\nerr = snd_intel8x0_ich_chip_cold_reset(chip);\r\nelse\r\nerr = snd_intel8x0_ich_chip_reset(chip);\r\nif (err < 0)\r\nreturn err;\r\nif (probing) {\r\nend_time = jiffies + HZ;\r\ndo {\r\nstatus = igetdword(chip, ICHREG(GLOB_STA)) &\r\nchip->codec_isr_bits;\r\nif (status)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nif (! status) {\r\ndev_err(chip->card->dev,\r\n"codec_ready: codec is not ready [0x%x]\n",\r\nigetdword(chip, ICHREG(GLOB_STA)));\r\nreturn -EIO;\r\n}\r\nend_time = jiffies + HZ / 4;\r\nwhile (status != chip->codec_isr_bits &&\r\ntime_after_eq(end_time, jiffies)) {\r\nschedule_timeout_uninterruptible(1);\r\nstatus |= igetdword(chip, ICHREG(GLOB_STA)) &\r\nchip->codec_isr_bits;\r\n}\r\n} else {\r\nint i;\r\nstatus = 0;\r\nfor (i = 0; i < chip->ncodecs; i++)\r\nif (chip->ac97[i])\r\nstatus |= chip->codec_bit[chip->ac97_sdin[i]];\r\nend_time = jiffies + HZ;\r\ndo {\r\nnstatus = igetdword(chip, ICHREG(GLOB_STA)) &\r\nchip->codec_isr_bits;\r\nif (status == nstatus)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\n}\r\nif (chip->device_type == DEVICE_SIS) {\r\niputword(chip, 0x4c, igetword(chip, 0x4c) | 1);\r\n}\r\nif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\r\nunsigned int val;\r\npci_read_config_dword(chip->pci, 0x4c, &val);\r\nval |= 0x1000000;\r\npci_write_config_dword(chip->pci, 0x4c, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_ali_chip_init(struct intel8x0 *chip, int probing)\r\n{\r\nu32 reg;\r\nint i = 0;\r\nreg = igetdword(chip, ICHREG(ALI_SCR));\r\nif ((reg & 2) == 0)\r\nreg |= 2;\r\nelse\r\nreg |= 1;\r\nreg &= ~0x80000000;\r\niputdword(chip, ICHREG(ALI_SCR), reg);\r\nfor (i = 0; i < HZ / 2; i++) {\r\nif (! (igetdword(chip, ICHREG(ALI_INTERRUPTSR)) & ALI_INT_GPIO))\r\ngoto __ok;\r\nschedule_timeout_uninterruptible(1);\r\n}\r\ndev_err(chip->card->dev, "AC'97 reset failed.\n");\r\nif (probing)\r\nreturn -EIO;\r\n__ok:\r\nfor (i = 0; i < HZ / 2; i++) {\r\nreg = igetdword(chip, ICHREG(ALI_RTSR));\r\nif (reg & 0x80)\r\nbreak;\r\niputdword(chip, ICHREG(ALI_RTSR), reg | 0x80);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\ndo_ali_reset(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_chip_init(struct intel8x0 *chip, int probing)\r\n{\r\nunsigned int i, timeout;\r\nint err;\r\nif (chip->device_type != DEVICE_ALI) {\r\nif ((err = snd_intel8x0_ich_chip_init(chip, probing)) < 0)\r\nreturn err;\r\niagetword(chip, 0);\r\n} else {\r\nif ((err = snd_intel8x0_ali_chip_init(chip, probing)) < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\ntimeout = 100000;\r\nwhile (--timeout != 0) {\r\nif ((igetbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset) & ICH_RESETREGS) == 0)\r\nbreak;\r\n}\r\nif (timeout == 0)\r\ndev_err(chip->card->dev, "reset of registers failed?\n");\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset,\r\nchip->ichd[i].bdbar_addr);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_free(struct intel8x0 *chip)\r\n{\r\nunsigned int i;\r\nif (chip->irq < 0)\r\ngoto __hw_end;\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\r\nif (chip->device_type == DEVICE_NFORCE && !spdif_aclink) {\r\nunsigned int val;\r\npci_read_config_dword(chip->pci, 0x4c, &val);\r\nval &= ~0x1000000;\r\npci_write_config_dword(chip->pci, 0x4c, val);\r\n}\r\n__hw_end:\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->bdbars.area) {\r\nif (chip->fix_nocache)\r\nfill_nocache(chip->bdbars.area, chip->bdbars.bytes, 0);\r\nsnd_dma_free_pages(&chip->bdbars);\r\n}\r\nif (chip->addr)\r\npci_iounmap(chip->pci, chip->addr);\r\nif (chip->bmaddr)\r\npci_iounmap(chip->pci, chip->bmaddr);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int intel8x0_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct intel8x0 *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < chip->pcm_devs; i++)\r\nsnd_pcm_suspend_all(chip->pcm[i]);\r\nif (chip->fix_nocache) {\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nstruct ichdev *ichdev = &chip->ichd[i];\r\nif (ichdev->substream && ichdev->page_attr_changed) {\r\nstruct snd_pcm_runtime *runtime = ichdev->substream->runtime;\r\nif (runtime->dma_area)\r\nfill_nocache(runtime->dma_area, runtime->dma_bytes, 0);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < chip->ncodecs; i++)\r\nsnd_ac97_suspend(chip->ac97[i]);\r\nif (chip->device_type == DEVICE_INTEL_ICH4)\r\nchip->sdm_saved = igetbyte(chip, ICHREG(SDM));\r\nif (chip->irq >= 0) {\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel8x0_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct intel8x0 *chip = card->private_data;\r\nint i;\r\nsnd_intel8x0_chip_init(chip, 0);\r\nif (request_irq(pci->irq, snd_intel8x0_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\ndev_err(dev, "unable to grab IRQ %d, disabling device\n",\r\npci->irq);\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nchip->irq = pci->irq;\r\nsynchronize_irq(chip->irq);\r\nif (chip->device_type == DEVICE_INTEL_ICH4 && !spdif_aclink) {\r\niputbyte(chip, ICHREG(SDM), chip->sdm_saved);\r\niputdword(chip, ICHREG(GLOB_CNT),\r\n(igetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_PCM_SPDIF_MASK) |\r\nICH_PCM_SPDIF_1011);\r\n}\r\nif (chip->fix_nocache)\r\nfill_nocache(chip->bdbars.area, chip->bdbars.bytes, 1);\r\nfor (i = 0; i < chip->ncodecs; i++)\r\nsnd_ac97_resume(chip->ac97[i]);\r\nif (chip->fix_nocache) {\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nstruct ichdev *ichdev = &chip->ichd[i];\r\nif (ichdev->substream && ichdev->page_attr_changed) {\r\nstruct snd_pcm_runtime *runtime = ichdev->substream->runtime;\r\nif (runtime->dma_area)\r\nfill_nocache(runtime->dma_area, runtime->dma_bytes, 1);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nstruct ichdev *ichdev = &chip->ichd[i];\r\nunsigned long port = ichdev->reg_offset;\r\nif (! ichdev->substream || ! ichdev->suspended)\r\ncontinue;\r\nif (ichdev->ichd == ICHD_PCMOUT)\r\nsnd_intel8x0_setup_pcm_out(chip, ichdev->substream->runtime);\r\niputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\r\niputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\r\niputbyte(chip, port + ICH_REG_OFF_CIV, ichdev->civ);\r\niputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\r\n}\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic void intel8x0_measure_ac97_clock(struct intel8x0 *chip)\r\n{\r\nstruct snd_pcm_substream *subs;\r\nstruct ichdev *ichdev;\r\nunsigned long port;\r\nunsigned long pos, pos1, t;\r\nint civ, timeout = 1000, attempt = 1;\r\nktime_t start_time, stop_time;\r\nif (chip->ac97_bus->clock != 48000)\r\nreturn;\r\n__again:\r\nsubs = chip->pcm[0]->streams[0].substream;\r\nif (! subs || subs->dma_buffer.bytes < INTEL8X0_TESTBUF_SIZE) {\r\ndev_warn(chip->card->dev,\r\n"no playback buffer allocated - aborting measure ac97 clock\n");\r\nreturn;\r\n}\r\nichdev = &chip->ichd[ICHD_PCMOUT];\r\nichdev->physbuf = subs->dma_buffer.addr;\r\nichdev->size = ichdev->fragsize = INTEL8X0_TESTBUF_SIZE;\r\nichdev->substream = NULL;\r\nif (snd_ac97_set_rate(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 48000) < 0) {\r\ndev_err(chip->card->dev, "cannot set ac97 rate: clock = %d\n",\r\nchip->ac97_bus->clock);\r\nreturn;\r\n}\r\nsnd_intel8x0_setup_periods(chip, ichdev);\r\nport = ichdev->reg_offset;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->in_measurement = 1;\r\nif (chip->device_type != DEVICE_ALI)\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE | ICH_STARTBM);\r\nelse {\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_IOCE);\r\niputdword(chip, ICHREG(ALI_DMACR), 1 << ichdev->ali_slot);\r\n}\r\nstart_time = ktime_get();\r\nspin_unlock_irq(&chip->reg_lock);\r\nmsleep(50);\r\nspin_lock_irq(&chip->reg_lock);\r\ndo {\r\nciv = igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV);\r\npos1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb);\r\nif (pos1 == 0) {\r\nudelay(10);\r\ncontinue;\r\n}\r\nif (civ == igetbyte(chip, ichdev->reg_offset + ICH_REG_OFF_CIV) &&\r\npos1 == igetword(chip, ichdev->reg_offset + ichdev->roff_picb))\r\nbreak;\r\n} while (timeout--);\r\nif (pos1 == 0) {\r\npos = 0;\r\n} else {\r\npos = ichdev->fragsize1;\r\npos -= pos1 << ichdev->pos_shift;\r\npos += ichdev->position;\r\n}\r\nchip->in_measurement = 0;\r\nstop_time = ktime_get();\r\nif (chip->device_type == DEVICE_ALI) {\r\niputdword(chip, ICHREG(ALI_DMACR), 1 << (ichdev->ali_slot + 16));\r\niputbyte(chip, port + ICH_REG_OFF_CR, 0);\r\nwhile (igetbyte(chip, port + ICH_REG_OFF_CR))\r\n;\r\n} else {\r\niputbyte(chip, port + ICH_REG_OFF_CR, 0);\r\nwhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH))\r\n;\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (pos == 0) {\r\ndev_err(chip->card->dev,\r\n"measure - unreliable DMA position..\n");\r\n__retry:\r\nif (attempt < 3) {\r\nmsleep(300);\r\nattempt++;\r\ngoto __again;\r\n}\r\ngoto __end;\r\n}\r\npos /= 4;\r\nt = ktime_us_delta(stop_time, start_time);\r\ndev_info(chip->card->dev,\r\n"%s: measured %lu usecs (%lu samples)\n", __func__, t, pos);\r\nif (t == 0) {\r\ndev_err(chip->card->dev, "?? calculation error..\n");\r\ngoto __retry;\r\n}\r\npos *= 1000;\r\npos = (pos / t) * 1000 + ((pos % t) * 1000) / t;\r\nif (pos < 40000 || pos >= 60000) {\r\ndev_info(chip->card->dev, "measured clock %ld rejected\n", pos);\r\ngoto __retry;\r\n} else if (pos > 40500 && pos < 41500)\r\nchip->ac97_bus->clock = 41000;\r\nelse if (pos > 43600 && pos < 44600)\r\nchip->ac97_bus->clock = 44100;\r\nelse if (pos < 47500 || pos > 48500)\r\nchip->ac97_bus->clock = (chip->ac97_bus->clock * 48000) / pos;\r\n__end:\r\ndev_info(chip->card->dev, "clocking to %d\n", chip->ac97_bus->clock);\r\nsnd_ac97_update_power(chip->ac97[0], AC97_PCM_FRONT_DAC_RATE, 0);\r\n}\r\nstatic int intel8x0_in_clock_list(struct intel8x0 *chip)\r\n{\r\nstruct pci_dev *pci = chip->pci;\r\nconst struct snd_pci_quirk *wl;\r\nwl = snd_pci_quirk_lookup(pci, intel8x0_clock_list);\r\nif (!wl)\r\nreturn 0;\r\ndev_info(chip->card->dev, "white list rate for %04x:%04x is %i\n",\r\npci->subsystem_vendor, pci->subsystem_device, wl->value);\r\nchip->ac97_bus->clock = wl->value;\r\nreturn 1;\r\n}\r\nstatic void snd_intel8x0_proc_read(struct snd_info_entry * entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct intel8x0 *chip = entry->private_data;\r\nunsigned int tmp;\r\nsnd_iprintf(buffer, "Intel8x0\n\n");\r\nif (chip->device_type == DEVICE_ALI)\r\nreturn;\r\ntmp = igetdword(chip, ICHREG(GLOB_STA));\r\nsnd_iprintf(buffer, "Global control : 0x%08x\n", igetdword(chip, ICHREG(GLOB_CNT)));\r\nsnd_iprintf(buffer, "Global status : 0x%08x\n", tmp);\r\nif (chip->device_type == DEVICE_INTEL_ICH4)\r\nsnd_iprintf(buffer, "SDM : 0x%08x\n", igetdword(chip, ICHREG(SDM)));\r\nsnd_iprintf(buffer, "AC'97 codecs ready :");\r\nif (tmp & chip->codec_isr_bits) {\r\nint i;\r\nstatic const char *codecs[3] = {\r\n"primary", "secondary", "tertiary"\r\n};\r\nfor (i = 0; i < chip->max_codecs; i++)\r\nif (tmp & chip->codec_bit[i])\r\nsnd_iprintf(buffer, " %s", codecs[i]);\r\n} else\r\nsnd_iprintf(buffer, " none");\r\nsnd_iprintf(buffer, "\n");\r\nif (chip->device_type == DEVICE_INTEL_ICH4 ||\r\nchip->device_type == DEVICE_SIS)\r\nsnd_iprintf(buffer, "AC'97 codecs SDIN : %i %i %i\n",\r\nchip->ac97_sdin[0],\r\nchip->ac97_sdin[1],\r\nchip->ac97_sdin[2]);\r\n}\r\nstatic void snd_intel8x0_proc_init(struct intel8x0 *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "intel8x0", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_intel8x0_proc_read);\r\n}\r\nstatic int snd_intel8x0_dev_free(struct snd_device *device)\r\n{\r\nstruct intel8x0 *chip = device->device_data;\r\nreturn snd_intel8x0_free(chip);\r\n}\r\nstatic int snd_intel8x0_inside_vm(struct pci_dev *pci)\r\n{\r\nint result = inside_vm;\r\nchar *msg = NULL;\r\nif (result >= 0) {\r\nmsg = result ? "enable (forced) VM" : "disable (forced) VM";\r\ngoto fini;\r\n}\r\nresult = 0;\r\nif (pci->subsystem_vendor == PCI_SUBVENDOR_ID_REDHAT_QUMRANET &&\r\npci->subsystem_device == PCI_SUBDEVICE_ID_QEMU) {\r\nmsg = "enable KVM";\r\nresult = 1;\r\n} else if (pci->subsystem_vendor == 0x1ab8) {\r\nmsg = "enable Parallels VM";\r\nresult = 1;\r\n}\r\nfini:\r\nif (msg != NULL)\r\ndev_info(&pci->dev, "%s optimization\n", msg);\r\nreturn result;\r\n}\r\nstatic int snd_intel8x0_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nunsigned long device_type,\r\nstruct intel8x0 **r_intel8x0)\r\n{\r\nstruct intel8x0 *chip;\r\nint err;\r\nunsigned int i;\r\nunsigned int int_sta_masks;\r\nstruct ichdev *ichdev;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_intel8x0_dev_free,\r\n};\r\nstatic unsigned int bdbars[] = {\r\n3,\r\n6,\r\n3,\r\n6,\r\n4,\r\n};\r\nstatic struct ich_reg_info intel_regs[6] = {\r\n{ ICH_PIINT, 0 },\r\n{ ICH_POINT, 0x10 },\r\n{ ICH_MCINT, 0x20 },\r\n{ ICH_M2INT, 0x40 },\r\n{ ICH_P2INT, 0x50 },\r\n{ ICH_SPINT, 0x60 },\r\n};\r\nstatic struct ich_reg_info nforce_regs[4] = {\r\n{ ICH_PIINT, 0 },\r\n{ ICH_POINT, 0x10 },\r\n{ ICH_MCINT, 0x20 },\r\n{ ICH_NVSPINT, 0x70 },\r\n};\r\nstatic struct ich_reg_info ali_regs[6] = {\r\n{ ALI_INT_PCMIN, 0x40 },\r\n{ ALI_INT_PCMOUT, 0x50 },\r\n{ ALI_INT_MICIN, 0x60 },\r\n{ ALI_INT_CODECSPDIFOUT, 0x70 },\r\n{ ALI_INT_SPDIFIN, 0xa0 },\r\n{ ALI_INT_SPDIFOUT, 0xb0 },\r\n};\r\nstruct ich_reg_info *tbl;\r\n*r_intel8x0 = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->device_type = device_type;\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->buggy_irq = buggy_irq;\r\nchip->buggy_semaphore = buggy_semaphore;\r\nif (xbox)\r\nchip->xbox = 1;\r\nchip->inside_vm = snd_intel8x0_inside_vm(pci);\r\nif (pci->vendor == PCI_VENDOR_ID_INTEL &&\r\npci->device == PCI_DEVICE_ID_INTEL_440MX)\r\nchip->fix_nocache = 1;\r\nif ((err = pci_request_regions(pci, card->shortname)) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nif (device_type == DEVICE_ALI) {\r\nchip->bmaddr = pci_iomap(pci, 0, 0);\r\ngoto port_inited;\r\n}\r\nif (pci_resource_flags(pci, 2) & IORESOURCE_MEM)\r\nchip->addr = pci_iomap(pci, 2, 0);\r\nelse\r\nchip->addr = pci_iomap(pci, 0, 0);\r\nif (!chip->addr) {\r\ndev_err(card->dev, "AC'97 space ioremap problem\n");\r\nsnd_intel8x0_free(chip);\r\nreturn -EIO;\r\n}\r\nif (pci_resource_flags(pci, 3) & IORESOURCE_MEM)\r\nchip->bmaddr = pci_iomap(pci, 3, 0);\r\nelse\r\nchip->bmaddr = pci_iomap(pci, 1, 0);\r\nport_inited:\r\nif (!chip->bmaddr) {\r\ndev_err(card->dev, "Controller space ioremap problem\n");\r\nsnd_intel8x0_free(chip);\r\nreturn -EIO;\r\n}\r\nchip->bdbars_count = bdbars[device_type];\r\nswitch (device_type) {\r\ncase DEVICE_NFORCE:\r\ntbl = nforce_regs;\r\nbreak;\r\ncase DEVICE_ALI:\r\ntbl = ali_regs;\r\nbreak;\r\ndefault:\r\ntbl = intel_regs;\r\nbreak;\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nichdev->ichd = i;\r\nichdev->reg_offset = tbl[i].offset;\r\nichdev->int_sta_mask = tbl[i].int_sta_mask;\r\nif (device_type == DEVICE_SIS) {\r\nichdev->roff_sr = ICH_REG_OFF_PICB;\r\nichdev->roff_picb = ICH_REG_OFF_SR;\r\n} else {\r\nichdev->roff_sr = ICH_REG_OFF_SR;\r\nichdev->roff_picb = ICH_REG_OFF_PICB;\r\n}\r\nif (device_type == DEVICE_ALI)\r\nichdev->ali_slot = (ichdev->reg_offset - 0x40) / 0x10;\r\nichdev->pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;\r\n}\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nchip->bdbars_count * sizeof(u32) * ICH_MAX_FRAGS * 2,\r\n&chip->bdbars) < 0) {\r\nsnd_intel8x0_free(chip);\r\ndev_err(card->dev, "cannot allocate buffer descriptors\n");\r\nreturn -ENOMEM;\r\n}\r\nif (chip->fix_nocache)\r\nfill_nocache(chip->bdbars.area, chip->bdbars.bytes, 1);\r\nint_sta_masks = 0;\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nichdev->bdbar = ((u32 *)chip->bdbars.area) +\r\n(i * ICH_MAX_FRAGS * 2);\r\nichdev->bdbar_addr = chip->bdbars.addr +\r\n(i * sizeof(u32) * ICH_MAX_FRAGS * 2);\r\nint_sta_masks |= ichdev->int_sta_mask;\r\n}\r\nchip->int_sta_reg = device_type == DEVICE_ALI ?\r\nICH_REG_ALI_INTERRUPTSR : ICH_REG_GLOB_STA;\r\nchip->int_sta_mask = int_sta_masks;\r\npci_set_master(pci);\r\nswitch(chip->device_type) {\r\ncase DEVICE_INTEL_ICH4:\r\nchip->max_codecs = 3;\r\nchip->codec_bit = ich_codec_bits;\r\nchip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_TRI;\r\nbreak;\r\ncase DEVICE_SIS:\r\nchip->max_codecs = 3;\r\nchip->codec_bit = sis_codec_bits;\r\nchip->codec_ready_bits = ICH_PRI | ICH_SRI | ICH_SIS_TRI;\r\nbreak;\r\ndefault:\r\nchip->max_codecs = 2;\r\nchip->codec_bit = ich_codec_bits;\r\nchip->codec_ready_bits = ICH_PRI | ICH_SRI;\r\nbreak;\r\n}\r\nfor (i = 0; i < chip->max_codecs; i++)\r\nchip->codec_isr_bits |= chip->codec_bit[i];\r\nif ((err = snd_intel8x0_chip_init(chip, 1)) < 0) {\r\nsnd_intel8x0_free(chip);\r\nreturn err;\r\n}\r\nif (request_irq(pci->irq, snd_intel8x0_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_intel8x0_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_intel8x0_free(chip);\r\nreturn err;\r\n}\r\n*r_intel8x0 = chip;\r\nreturn 0;\r\n}\r\nstatic int check_default_spdif_aclink(struct pci_dev *pci)\r\n{\r\nconst struct snd_pci_quirk *w;\r\nw = snd_pci_quirk_lookup(pci, spdif_aclink_defaults);\r\nif (w) {\r\nif (w->value)\r\ndev_dbg(&pci->dev,\r\n"Using SPDIF over AC-Link for %s\n",\r\nsnd_pci_quirk_name(w));\r\nelse\r\ndev_dbg(&pci->dev,\r\n"Using integrated SPDIF DMA for %s\n",\r\nsnd_pci_quirk_name(w));\r\nreturn w->value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct intel8x0 *chip;\r\nint err;\r\nstruct shortname_table *name;\r\nerr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif (spdif_aclink < 0)\r\nspdif_aclink = check_default_spdif_aclink(pci);\r\nstrcpy(card->driver, "ICH");\r\nif (!spdif_aclink) {\r\nswitch (pci_id->driver_data) {\r\ncase DEVICE_NFORCE:\r\nstrcpy(card->driver, "NFORCE");\r\nbreak;\r\ncase DEVICE_INTEL_ICH4:\r\nstrcpy(card->driver, "ICH4");\r\n}\r\n}\r\nstrcpy(card->shortname, "Intel ICH");\r\nfor (name = shortnames; name->id; name++) {\r\nif (pci->device == name->id) {\r\nstrcpy(card->shortname, name->s);\r\nbreak;\r\n}\r\n}\r\nif (buggy_irq < 0) {\r\nif (pci_id->driver_data == DEVICE_NFORCE)\r\nbuggy_irq = 1;\r\nelse\r\nbuggy_irq = 0;\r\n}\r\nif ((err = snd_intel8x0_create(card, pci, pci_id->driver_data,\r\n&chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nif ((err = snd_intel8x0_mixer(chip, ac97_clock, ac97_quirk)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_intel8x0_pcm(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_intel8x0_proc_init(chip);\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s with %s at irq %i", card->shortname,\r\nsnd_ac97_get_short_name(chip->ac97[0]), chip->irq);\r\nif (ac97_clock == 0 || ac97_clock == 1) {\r\nif (ac97_clock == 0) {\r\nif (intel8x0_in_clock_list(chip) == 0)\r\nintel8x0_measure_ac97_clock(chip);\r\n} else {\r\nintel8x0_measure_ac97_clock(chip);\r\n}\r\n}\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\n}\r\nstatic void snd_intel8x0_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
