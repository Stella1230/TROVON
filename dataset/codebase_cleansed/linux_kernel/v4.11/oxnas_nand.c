static uint8_t oxnas_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct oxnas_nand_ctrl *oxnas = nand_get_controller_data(chip);\r\nreturn readb(oxnas->io_base);\r\n}\r\nstatic void oxnas_nand_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct oxnas_nand_ctrl *oxnas = nand_get_controller_data(chip);\r\nioread8_rep(oxnas->io_base, buf, len);\r\n}\r\nstatic void oxnas_nand_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct oxnas_nand_ctrl *oxnas = nand_get_controller_data(chip);\r\niowrite8_rep(oxnas->io_base, buf, len);\r\n}\r\nstatic void oxnas_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct oxnas_nand_ctrl *oxnas = nand_get_controller_data(chip);\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, oxnas->io_base + OXNAS_NAND_CMD_CLE);\r\nelse if (ctrl & NAND_ALE)\r\nwriteb(cmd, oxnas->io_base + OXNAS_NAND_CMD_ALE);\r\n}\r\nstatic int oxnas_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *nand_np;\r\nstruct oxnas_nand_ctrl *oxnas;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nstruct resource *res;\r\nint nchips = 0;\r\nint count = 0;\r\nint err = 0;\r\noxnas = devm_kzalloc(&pdev->dev, sizeof(struct nand_chip),\r\nGFP_KERNEL);\r\nif (!oxnas)\r\nreturn -ENOMEM;\r\nnand_hw_control_init(&oxnas->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\noxnas->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(oxnas->io_base))\r\nreturn PTR_ERR(oxnas->io_base);\r\noxnas->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(oxnas->clk))\r\noxnas->clk = NULL;\r\ncount = of_get_child_count(np);\r\nif (count > 1)\r\nreturn -EINVAL;\r\nclk_prepare_enable(oxnas->clk);\r\ndevice_reset_optional(&pdev->dev);\r\nfor_each_child_of_node(np, nand_np) {\r\nchip = devm_kzalloc(&pdev->dev, sizeof(struct nand_chip),\r\nGFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->controller = &oxnas->base;\r\nnand_set_flash_node(chip, nand_np);\r\nnand_set_controller_data(chip, oxnas);\r\nmtd = nand_to_mtd(chip);\r\nmtd->dev.parent = &pdev->dev;\r\nmtd->priv = chip;\r\nchip->cmd_ctrl = oxnas_nand_cmd_ctrl;\r\nchip->read_buf = oxnas_nand_read_buf;\r\nchip->read_byte = oxnas_nand_read_byte;\r\nchip->write_buf = oxnas_nand_write_buf;\r\nchip->chip_delay = 30;\r\nerr = nand_scan(mtd, 1);\r\nif (err)\r\nreturn err;\r\nerr = mtd_device_register(mtd, NULL, 0);\r\nif (err) {\r\nnand_release(mtd);\r\nreturn err;\r\n}\r\noxnas->chips[nchips] = chip;\r\n++nchips;\r\n}\r\nif (!nchips)\r\nreturn -ENODEV;\r\nplatform_set_drvdata(pdev, oxnas);\r\nreturn 0;\r\n}\r\nstatic int oxnas_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct oxnas_nand_ctrl *oxnas = platform_get_drvdata(pdev);\r\nif (oxnas->chips[0])\r\nnand_release(nand_to_mtd(oxnas->chips[0]));\r\nclk_disable_unprepare(oxnas->clk);\r\nreturn 0;\r\n}
