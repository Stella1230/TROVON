static int cx24117_writereg(struct cx24117_state *state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->priv->demod_address,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nint ret;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d i2c wr @0x%02x=0x%02x\n",\r\n__func__, state->demod, reg, data);\r\nret = i2c_transfer(state->priv->i2c, &msg, 1);\r\nif (ret < 0) {\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod%d i2c wr err(%i) @0x%02x=0x%02x\n",\r\nKBUILD_MODNAME, state->demod, ret, reg, data);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24117_writecmd(struct cx24117_state *state,\r\nstruct cx24117_cmd *cmd)\r\n{\r\nstruct i2c_msg msg;\r\nu8 buf[CX24117_ARGLEN+1];\r\nint ret;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d i2c wr cmd len=%d\n",\r\n__func__, state->demod, cmd->len);\r\nbuf[0] = CX24117_REG_COMMAND;\r\nmemcpy(&buf[1], cmd->args, cmd->len);\r\nmsg.addr = state->priv->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = cmd->len+1;\r\nmsg.buf = buf;\r\nret = i2c_transfer(state->priv->i2c, &msg, 1);\r\nif (ret < 0) {\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod%d i2c wr cmd err(%i) len=%d\n",\r\nKBUILD_MODNAME, state->demod, ret, cmd->len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24117_readreg(struct cx24117_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 recv = 0;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->priv->demod_address, .flags = 0,\r\n.buf = &reg, .len = 1 },\r\n{ .addr = state->priv->demod_address, .flags = I2C_M_RD,\r\n.buf = &recv, .len = 1 }\r\n};\r\nret = i2c_transfer(state->priv->i2c, msg, 2);\r\nif (ret < 0) {\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod%d i2c rd err(%d) @0x%x\n",\r\nKBUILD_MODNAME, state->demod, ret, reg);\r\nreturn ret;\r\n}\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d i2c rd @0x%02x=0x%02x\n",\r\n__func__, state->demod, reg, recv);\r\nreturn recv;\r\n}\r\nstatic int cx24117_readregN(struct cx24117_state *state,\r\nu8 reg, u8 *buf, int len)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->priv->demod_address, .flags = 0,\r\n.buf = &reg, .len = 1 },\r\n{ .addr = state->priv->demod_address, .flags = I2C_M_RD,\r\n.buf = buf, .len = len }\r\n};\r\nret = i2c_transfer(state->priv->i2c, msg, 2);\r\nif (ret < 0) {\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod%d i2c rd err(%d) @0x%x\n",\r\nKBUILD_MODNAME, state->demod, ret, reg);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24117_set_inversion(struct cx24117_state *state,\r\nenum fe_spectral_inversion inversion)\r\n{\r\ndev_dbg(&state->priv->i2c->dev, "%s(%d) demod%d\n",\r\n__func__, inversion, state->demod);\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\nstate->dnxt.inversion_val = 0x00;\r\nbreak;\r\ncase INVERSION_ON:\r\nstate->dnxt.inversion_val = 0x04;\r\nbreak;\r\ncase INVERSION_AUTO:\r\nstate->dnxt.inversion_val = 0x0C;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.inversion = inversion;\r\nreturn 0;\r\n}\r\nstatic int cx24117_lookup_fecmod(struct cx24117_state *state,\r\nenum fe_delivery_system d, enum fe_modulation m, enum fe_code_rate f)\r\n{\r\nint i, ret = -EINVAL;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s(demod(0x%02x,0x%02x) demod%d\n",\r\n__func__, m, f, state->demod);\r\nfor (i = 0; i < ARRAY_SIZE(cx24117_modfec_modes); i++) {\r\nif ((d == cx24117_modfec_modes[i].delivery_system) &&\r\n(m == cx24117_modfec_modes[i].modulation) &&\r\n(f == cx24117_modfec_modes[i].fec)) {\r\nret = i;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cx24117_set_fec(struct cx24117_state *state,\r\nenum fe_delivery_system delsys,\r\nenum fe_modulation mod,\r\nenum fe_code_rate fec)\r\n{\r\nint ret;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s(0x%02x,0x%02x) demod%d\n",\r\n__func__, mod, fec, state->demod);\r\nret = cx24117_lookup_fecmod(state, delsys, mod, fec);\r\nif (ret < 0)\r\nreturn ret;\r\nstate->dnxt.fec = fec;\r\nstate->dnxt.fec_val = cx24117_modfec_modes[ret].val;\r\nstate->dnxt.fec_mask = cx24117_modfec_modes[ret].mask;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d mask/val = 0x%02x/0x%02x\n", __func__,\r\nstate->demod, state->dnxt.fec_mask, state->dnxt.fec_val);\r\nreturn 0;\r\n}\r\nstatic int cx24117_set_symbolrate(struct cx24117_state *state, u32 rate)\r\n{\r\ndev_dbg(&state->priv->i2c->dev, "%s(%d) demod%d\n",\r\n__func__, rate, state->demod);\r\nstate->dnxt.symbol_rate = rate;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d symbol_rate = %d\n",\r\n__func__, state->demod, rate);\r\nreturn 0;\r\n}\r\nstatic int cx24117_firmware_ondemand(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nconst struct firmware *fw;\r\nint ret = 0;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d skip_fw_load=%d\n",\r\n__func__, state->demod, state->priv->skip_fw_load);\r\nif (state->priv->skip_fw_load)\r\nreturn 0;\r\nif (cx24117_readreg(state, 0xeb) != 0xa) {\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: Waiting for firmware upload (%s)...\n",\r\n__func__, CX24117_DEFAULT_FIRMWARE);\r\nret = request_firmware(&fw, CX24117_DEFAULT_FIRMWARE,\r\nstate->priv->i2c->dev.parent);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: Waiting for firmware upload(2)...\n", __func__);\r\nif (ret) {\r\ndev_err(&state->priv->i2c->dev,\r\n"%s: No firmware uploaded (timeout or file not found?)\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nstate->priv->skip_fw_load = 1;\r\nret = cx24117_load_firmware(fe, fw);\r\nif (ret)\r\ndev_err(&state->priv->i2c->dev,\r\n"%s: Writing firmware failed\n", __func__);\r\nrelease_firmware(fw);\r\ndev_info(&state->priv->i2c->dev,\r\n"%s: Firmware upload %s\n", __func__,\r\nret == 0 ? "complete" : "failed");\r\nstate->priv->skip_fw_load = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cx24117_cmd_execute_nolock(struct dvb_frontend *fe,\r\nstruct cx24117_cmd *cmd)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint i, ret;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d\n",\r\n__func__, state->demod);\r\nret = cx24117_firmware_ondemand(fe);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24117_writecmd(state, cmd);\r\ncx24117_writereg(state, CX24117_REG_EXECUTE, 0x01);\r\ni = 0;\r\nwhile (cx24117_readreg(state, CX24117_REG_EXECUTE)) {\r\nmsleep(20);\r\nif (i++ > 40) {\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s() Firmware not responding\n", __func__);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24117_cmd_execute(struct dvb_frontend *fe, struct cx24117_cmd *cmd)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint ret;\r\nmutex_lock(&state->priv->fe_lock);\r\nret = cx24117_cmd_execute_nolock(fe, cmd);\r\nmutex_unlock(&state->priv->fe_lock);\r\nreturn ret;\r\n}\r\nstatic int cx24117_load_firmware(struct dvb_frontend *fe,\r\nconst struct firmware *fw)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nint i, ret;\r\nunsigned char vers[4];\r\nstruct i2c_msg msg;\r\nu8 *buf;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d FW is %zu bytes (%02x %02x .. %02x %02x)\n",\r\n__func__, state->demod, fw->size, fw->data[0], fw->data[1],\r\nfw->data[fw->size - 2], fw->data[fw->size - 1]);\r\ncx24117_writereg(state, 0xea, 0x00);\r\ncx24117_writereg(state, 0xea, 0x01);\r\ncx24117_writereg(state, 0xea, 0x00);\r\ncx24117_writereg(state, 0xce, 0x92);\r\ncx24117_writereg(state, 0xfb, 0x00);\r\ncx24117_writereg(state, 0xfc, 0x00);\r\ncx24117_writereg(state, 0xc3, 0x04);\r\ncx24117_writereg(state, 0xc4, 0x04);\r\ncx24117_writereg(state, 0xce, 0x00);\r\ncx24117_writereg(state, 0xcf, 0x00);\r\ncx24117_writereg(state, 0xea, 0x00);\r\ncx24117_writereg(state, 0xeb, 0x0c);\r\ncx24117_writereg(state, 0xec, 0x06);\r\ncx24117_writereg(state, 0xed, 0x05);\r\ncx24117_writereg(state, 0xee, 0x03);\r\ncx24117_writereg(state, 0xef, 0x05);\r\ncx24117_writereg(state, 0xf3, 0x03);\r\ncx24117_writereg(state, 0xf4, 0x44);\r\ncx24117_writereg(state, CX24117_REG_RATEDIV0, 0x04);\r\ncx24117_writereg(state, CX24117_REG_CLKDIV0, 0x02);\r\ncx24117_writereg(state, CX24117_REG_RATEDIV1, 0x04);\r\ncx24117_writereg(state, CX24117_REG_CLKDIV1, 0x02);\r\ncx24117_writereg(state, 0xf2, 0x04);\r\ncx24117_writereg(state, 0xe8, 0x02);\r\ncx24117_writereg(state, 0xea, 0x01);\r\ncx24117_writereg(state, 0xc8, 0x00);\r\ncx24117_writereg(state, 0xc9, 0x00);\r\ncx24117_writereg(state, 0xca, 0x00);\r\ncx24117_writereg(state, 0xcb, 0x00);\r\ncx24117_writereg(state, 0xcc, 0x00);\r\ncx24117_writereg(state, 0xcd, 0x00);\r\ncx24117_writereg(state, 0xe4, 0x03);\r\ncx24117_writereg(state, 0xeb, 0x0a);\r\ncx24117_writereg(state, 0xfb, 0x00);\r\ncx24117_writereg(state, 0xe0, 0x76);\r\ncx24117_writereg(state, 0xf7, 0x81);\r\ncx24117_writereg(state, 0xf8, 0x00);\r\ncx24117_writereg(state, 0xf9, 0x00);\r\nbuf = kmalloc(fw->size + 1, GFP_KERNEL);\r\nif (buf == NULL) {\r\nstate->priv->skip_fw_load = 0;\r\nreturn -ENOMEM;\r\n}\r\nbuf[0] = 0xfa;\r\nmemcpy(&buf[1], fw->data, fw->size);\r\nmsg.addr = state->priv->demod_address;\r\nmsg.flags = 0;\r\nmsg.len = fw->size + 1;\r\nmsg.buf = buf;\r\nret = i2c_transfer(state->priv->i2c, &msg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nkfree(buf);\r\ncx24117_writereg(state, 0xf7, 0x0c);\r\ncx24117_writereg(state, 0xe0, 0x00);\r\ncmd.args[0] = CMD_DEMODINIT;\r\ncmd.args[1] = 0x00;\r\ncmd.args[2] = 0x01;\r\ncmd.args[3] = 0x00;\r\ncmd.len = 4;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\ncmd.args[0] = CMD_SET_VCOFREQ;\r\ncmd.args[1] = 0x06;\r\ncmd.args[2] = 0x2b;\r\ncmd.args[3] = 0xd8;\r\ncmd.args[4] = 0xa5;\r\ncmd.args[5] = 0xee;\r\ncmd.args[6] = 0x03;\r\ncmd.args[7] = 0x9d;\r\ncmd.args[8] = 0xfc;\r\ncmd.args[9] = 0x06;\r\ncmd.args[10] = 0x02;\r\ncmd.args[11] = 0x9d;\r\ncmd.args[12] = 0xfc;\r\ncmd.len = 13;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\ncmd.args[0] = CMD_TUNERINIT;\r\ncmd.args[1] = 0x00;\r\ncmd.args[2] = 0x01;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x00;\r\ncmd.args[5] = 0x01;\r\ncmd.args[6] = 0x01;\r\ncmd.args[7] = 0x01;\r\ncmd.args[8] = 0x00;\r\ncmd.args[9] = 0x05;\r\ncmd.args[10] = 0x02;\r\ncmd.args[11] = 0x02;\r\ncmd.args[12] = 0x00;\r\ncmd.len = 13;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\ncmd.args[0] = CMD_GLOBAL_MPEGCFG;\r\ncmd.args[1] = 0x00;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.args[4] = 0x01;\r\ncmd.args[5] = 0x00;\r\ncmd.len = 6;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\nfor (i = 0; i < 2; i++) {\r\ncmd.args[0] = CMD_MPEGCFG;\r\ncmd.args[1] = (u8) i;\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x05;\r\ncmd.args[4] = 0x00;\r\ncmd.args[5] = 0x00;\r\ncmd.args[6] = 0x55;\r\ncmd.args[7] = 0x00;\r\ncmd.len = 8;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\n}\r\ncx24117_writereg(state, 0xce, 0xc0);\r\ncx24117_writereg(state, 0xcf, 0x00);\r\ncx24117_writereg(state, 0xe5, 0x04);\r\ncmd.args[0] = CMD_FWVERSION;\r\ncmd.len = 2;\r\nfor (i = 0; i < 4; i++) {\r\ncmd.args[1] = i;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto error;\r\nvers[i] = cx24117_readreg(state, 0x33);\r\n}\r\ndev_info(&state->priv->i2c->dev,\r\n"%s: FW version %i.%i.%i.%i\n", __func__,\r\nvers[0], vers[1], vers[2], vers[3]);\r\nreturn 0;\r\nerror:\r\nstate->priv->skip_fw_load = 0;\r\ndev_err(&state->priv->i2c->dev, "%s() Error running FW.\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int cx24117_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint lock;\r\nlock = cx24117_readreg(state,\r\n(state->demod == 0) ? CX24117_REG_SSTATUS0 :\r\nCX24117_REG_SSTATUS1) &\r\nCX24117_STATUS_MASK;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d status = 0x%02x\n",\r\n__func__, state->demod, lock);\r\n*status = 0;\r\nif (lock & CX24117_HAS_SIGNAL)\r\n*status |= FE_HAS_SIGNAL;\r\nif (lock & CX24117_HAS_CARRIER)\r\n*status |= FE_HAS_CARRIER;\r\nif (lock & CX24117_HAS_VITERBI)\r\n*status |= FE_HAS_VITERBI;\r\nif (lock & CX24117_HAS_SYNCLOCK)\r\n*status |= FE_HAS_SYNC | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cx24117_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[4];\r\nu8 base_reg = (state->demod == 0) ?\r\nCX24117_REG_BER4_0 :\r\nCX24117_REG_BER4_1;\r\nret = cx24117_readregN(state, base_reg, buf, 4);\r\nif (ret != 0)\r\nreturn ret;\r\n*ber = (buf[0] << 24) | (buf[1] << 16) |\r\n(buf[1] << 8) | buf[0];\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d ber=0x%04x\n",\r\n__func__, state->demod, *ber);\r\nreturn 0;\r\n}\r\nstatic int cx24117_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nint ret;\r\nu16 sig_reading;\r\nu8 buf[2];\r\nu8 reg = (state->demod == 0) ?\r\nCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1;\r\ncmd.args[0] = CMD_GET_AGCACC;\r\ncmd.args[1] = (u8) state->demod;\r\ncmd.len = 2;\r\nret = cx24117_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24117_readregN(state, reg, buf, 2);\r\nif (ret != 0)\r\nreturn ret;\r\nsig_reading = ((buf[0] & CX24117_SIGNAL_MASK) << 2) | buf[1];\r\n*signal_strength = -100 * sig_reading + 94324;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d raw / cooked = 0x%04x / 0x%04x\n",\r\n__func__, state->demod, sig_reading, *signal_strength);\r\nreturn 0;\r\n}\r\nstatic int cx24117_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint ret;\r\nu8 buf[2];\r\nu8 reg = (state->demod == 0) ?\r\nCX24117_REG_QUALITY2_0 : CX24117_REG_QUALITY2_1;\r\nret = cx24117_readregN(state, reg, buf, 2);\r\nif (ret != 0)\r\nreturn ret;\r\n*snr = (buf[0] << 8) | buf[1];\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d snr = 0x%04x\n",\r\n__func__, state->demod, *snr);\r\nreturn ret;\r\n}\r\nstatic int cx24117_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nenum fe_delivery_system delsys = fe->dtv_property_cache.delivery_system;\r\nint ret;\r\nu8 buf[2];\r\nu8 reg = (state->demod == 0) ?\r\nCX24117_REG_DVBS_UCB2_0 :\r\nCX24117_REG_DVBS_UCB2_1;\r\nswitch (delsys) {\r\ncase SYS_DVBS:\r\nbreak;\r\ncase SYS_DVBS2:\r\nreg += (CX24117_REG_DVBS2_UCB2_0 - CX24117_REG_DVBS_UCB2_0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = cx24117_readregN(state, reg, buf, 2);\r\nif (ret != 0)\r\nreturn ret;\r\n*ucblocks = (buf[0] << 8) | buf[1];\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d ucb=0x%04x\n",\r\n__func__, state->demod, *ucblocks);\r\nreturn 0;\r\n}\r\nstatic void cx24117_clone_params(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstate->dcur = state->dnxt;\r\n}\r\nstatic int cx24117_wait_for_lnb(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 val, reg = (state->demod == 0) ? CX24117_REG_QSTATUS0 :\r\nCX24117_REG_QSTATUS1;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d qstatus = 0x%02x\n",\r\n__func__, state->demod, cx24117_readreg(state, reg));\r\nfor (i = 0; i < 10; i++) {\r\nval = cx24117_readreg(state, reg) & 0x01;\r\nif (val != 0)\r\nreturn 0;\r\nmsleep(30);\r\n}\r\ndev_warn(&state->priv->i2c->dev, "%s: demod%d LNB not ready\n",\r\nKBUILD_MODNAME, state->demod);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int cx24117_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nint ret;\r\nu8 reg = (state->demod == 0) ? 0x10 : 0x20;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d %s\n",\r\n__func__, state->demod,\r\nvoltage == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" :\r\nvoltage == SEC_VOLTAGE_18 ? "SEC_VOLTAGE_18" :\r\n"SEC_VOLTAGE_OFF");\r\ncmd.args[0] = CMD_SET_GPIOOUT;\r\ncmd.args[2] = reg;\r\ncmd.len = 3;\r\nif ((voltage == SEC_VOLTAGE_13) ||\r\n(voltage == SEC_VOLTAGE_18)) {\r\ncmd.args[1] = reg;\r\nret = cx24117_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24117_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(100);\r\ncmd.args[0] = CMD_LNBDCLEVEL;\r\ncmd.args[1] = state->demod ? 0 : 1;\r\ncmd.args[2] = (voltage == SEC_VOLTAGE_18 ? 0x01 : 0x00);\r\ncmd.len = 3;\r\nret = cx24117_cmd_execute(fe, &cmd);\r\nmsleep(20);\r\n} else {\r\ncmd.args[1] = 0x00;\r\nret = cx24117_cmd_execute(fe, &cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cx24117_set_tone(struct dvb_frontend *fe,\r\nenum fe_sec_tone_mode tone)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nint ret;\r\ndev_dbg(&state->priv->i2c->dev, "%s(%d) demod%d\n",\r\n__func__, state->demod, tone);\r\nif ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {\r\ndev_warn(&state->priv->i2c->dev, "%s: demod%d invalid tone=%d\n",\r\nKBUILD_MODNAME, state->demod, tone);\r\nreturn -EINVAL;\r\n}\r\nret = cx24117_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(20);\r\ncmd.args[0] = CMD_LNBPCBCONFIG;\r\ncmd.args[1] = (state->demod ? 0 : 1);\r\ncmd.args[2] = 0x00;\r\ncmd.args[3] = 0x00;\r\ncmd.len = 5;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\ncmd.args[4] = 0x01;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ncmd.args[4] = 0x00;\r\nbreak;\r\n}\r\nmsleep(20);\r\nreturn cx24117_cmd_execute(fe, &cmd);\r\n}\r\nstatic int cx24117_diseqc_init(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstate->dsec_cmd.args[0] = CMD_LNBSEND;\r\nstate->dsec_cmd.args[CX24117_DISEQC_DEMOD] = state->demod ? 0 : 1;\r\nstate->dsec_cmd.args[CX24117_DISEQC_BURST] = CX24117_DISEQC_MINI_A;\r\nstate->dsec_cmd.args[CX24117_DISEQC_ARG3_2] = 0x02;\r\nstate->dsec_cmd.args[CX24117_DISEQC_ARG4_0] = 0x00;\r\nstate->dsec_cmd.args[CX24117_DISEQC_ARG5_0] = 0x00;\r\nstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN] = 0x00;\r\nstate->dsec_cmd.len = 7;\r\nreturn 0;\r\n}\r\nstatic int cx24117_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *d)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nint i, ret;\r\ndev_dbg(&state->priv->i2c->dev, "%s: demod %d (",\r\n__func__, state->demod);\r\nfor (i = 0; i < d->msg_len; i++)\r\ndev_dbg(&state->priv->i2c->dev, "0x%02x ", d->msg[i]);\r\ndev_dbg(&state->priv->i2c->dev, ")\n");\r\nif (d->msg_len > sizeof(d->msg))\r\nreturn -EINVAL;\r\nfor (i = 0; i < d->msg_len; i++)\r\nstate->dsec_cmd.args[CX24117_DISEQC_MSGOFS + i] = d->msg[i];\r\nstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN] = d->msg_len;\r\nstate->dsec_cmd.len = CX24117_DISEQC_MSGOFS +\r\nstate->dsec_cmd.args[CX24117_DISEQC_MSGLEN];\r\nif (d->msg_len >= 4 && d->msg[2] == 0x38)\r\nstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\r\n((d->msg[3] & 4) >> 2);\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d burst=%d\n",\r\n__func__, state->demod,\r\nstate->dsec_cmd.args[CX24117_DISEQC_BURST]);\r\nret = cx24117_wait_for_lnb(fe);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep(100);\r\nret = cx24117_cmd_execute(fe, &state->dsec_cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nmsleep((state->dsec_cmd.args[CX24117_DISEQC_MSGLEN] << 4) + 60);\r\nreturn 0;\r\n}\r\nstatic int cx24117_diseqc_send_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->priv->i2c->dev, "%s(%d) demod=%d\n",\r\n__func__, burst, state->demod);\r\nif (burst == SEC_MINI_A)\r\nstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\r\nCX24117_DISEQC_MINI_A;\r\nelse if (burst == SEC_MINI_B)\r\nstate->dsec_cmd.args[CX24117_DISEQC_BURST] =\r\nCX24117_DISEQC_MINI_B;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cx24117_get_priv(struct cx24117_priv **priv,\r\nstruct i2c_adapter *i2c, u8 client_address)\r\n{\r\nint ret;\r\nmutex_lock(&cx24117_list_mutex);\r\nret = hybrid_tuner_request_state(struct cx24117_priv, (*priv),\r\nhybrid_tuner_instance_list, i2c, client_address, "cx24117");\r\nmutex_unlock(&cx24117_list_mutex);\r\nreturn ret;\r\n}\r\nstatic void cx24117_release_priv(struct cx24117_priv *priv)\r\n{\r\nmutex_lock(&cx24117_list_mutex);\r\nif (priv != NULL)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&cx24117_list_mutex);\r\n}\r\nstatic void cx24117_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->priv->i2c->dev, "%s demod%d\n",\r\n__func__, state->demod);\r\ncx24117_release_priv(state->priv);\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *cx24117_attach(const struct cx24117_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cx24117_state *state = NULL;\r\nstruct cx24117_priv *priv = NULL;\r\nint demod = 0;\r\ndemod = cx24117_get_priv(&priv, i2c, config->demod_address);\r\nswitch (demod) {\r\ncase 0:\r\ndev_err(&i2c->dev,\r\n"%s: Error attaching frontend %d\n",\r\nKBUILD_MODNAME, demod);\r\ngoto error1;\r\nbreak;\r\ncase 1:\r\npriv->i2c = i2c;\r\npriv->demod_address = config->demod_address;\r\nmutex_init(&priv->fe_lock);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstate = kzalloc(sizeof(struct cx24117_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error2;\r\nstate->demod = demod - 1;\r\nstate->priv = priv;\r\ndev_info(&state->priv->i2c->dev,\r\n"%s: Attaching frontend %d\n",\r\nKBUILD_MODNAME, state->demod);\r\nmemcpy(&state->frontend.ops, &cx24117_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror2:\r\ncx24117_release_priv(priv);\r\nerror1:\r\nreturn NULL;\r\n}\r\nstatic int cx24117_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nint ret;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d\n",\r\n__func__, state->demod);\r\nmutex_lock(&state->priv->fe_lock);\r\ncmd.args[0] = CMD_SET_SLEEPMODE;\r\ncmd.args[1] = (state->demod ? 1 : 0);\r\ncmd.args[2] = 0;\r\ncmd.len = 3;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto exit;\r\nret = cx24117_diseqc_init(fe);\r\nif (ret != 0)\r\ngoto exit;\r\ncmd.args[0] = CMD_BERCTRL;\r\ncmd.args[1] = (state->demod ? 1 : 0);\r\ncmd.args[2] = 0x10;\r\ncmd.args[3] = 0x10;\r\ncmd.len = 4;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto exit;\r\ncmd.args[0] = CMD_ENABLERSCORR;\r\ncmd.args[1] = (state->demod ? 1 : 0);\r\ncmd.args[2] = CX24117_OCC;\r\ncmd.len = 3;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nif (ret != 0)\r\ngoto exit;\r\ncmd.args[0] = CMD_SET_GPIODIR;\r\ncmd.args[1] = 0x30;\r\ncmd.args[2] = 0x30;\r\ncmd.len = 3;\r\nret = cx24117_cmd_execute_nolock(fe, &cmd);\r\nexit:\r\nmutex_unlock(&state->priv->fe_lock);\r\nreturn ret;\r\n}\r\nstatic int cx24117_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d\n",\r\n__func__, state->demod);\r\ncmd.args[0] = CMD_SET_SLEEPMODE;\r\ncmd.args[1] = (state->demod ? 1 : 0);\r\ncmd.args[2] = 1;\r\ncmd.len = 3;\r\nreturn cx24117_cmd_execute(fe, &cmd);\r\n}\r\nstatic int cx24117_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct cx24117_cmd cmd;\r\nenum fe_status tunerstat;\r\nint i, status, ret, retune = 1;\r\nu8 reg_clkdiv, reg_ratediv;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d\n",\r\n__func__, state->demod);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d DVB-S\n",\r\n__func__, state->demod);\r\nif (c->modulation != QPSK) {\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d unsupported modulation (%d)\n",\r\n__func__, state->demod, c->modulation);\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.pilot_val = CX24117_PILOT_OFF;\r\nstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\r\nbreak;\r\ncase SYS_DVBS2:\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d DVB-S2\n",\r\n__func__, state->demod);\r\nif (c->modulation != PSK_8 && c->modulation != QPSK) {\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d unsupported modulation (%d)\n",\r\n__func__, state->demod, c->modulation);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (c->pilot) {\r\ncase PILOT_AUTO:\r\nstate->dnxt.pilot_val = CX24117_PILOT_AUTO;\r\nbreak;\r\ncase PILOT_OFF:\r\nstate->dnxt.pilot_val = CX24117_PILOT_OFF;\r\nbreak;\r\ncase PILOT_ON:\r\nstate->dnxt.pilot_val = CX24117_PILOT_ON;\r\nbreak;\r\ndefault:\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d unsupported pilot mode (%d)\n",\r\n__func__, state->demod, c->pilot);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (c->rolloff) {\r\ncase ROLLOFF_20:\r\nstate->dnxt.rolloff_val = CX24117_ROLLOFF_020;\r\nbreak;\r\ncase ROLLOFF_25:\r\nstate->dnxt.rolloff_val = CX24117_ROLLOFF_025;\r\nbreak;\r\ncase ROLLOFF_35:\r\nstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\r\nbreak;\r\ncase ROLLOFF_AUTO:\r\nstate->dnxt.rolloff_val = CX24117_ROLLOFF_035;\r\nretune = 3;\r\nbreak;\r\ndefault:\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod%d unsupported rolloff (%d)\n",\r\nKBUILD_MODNAME, state->demod, c->rolloff);\r\nreturn -EOPNOTSUPP;\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(&state->priv->i2c->dev,\r\n"%s: demod %d unsupported delivery system (%d)\n",\r\nKBUILD_MODNAME, state->demod, c->delivery_system);\r\nreturn -EINVAL;\r\n}\r\nstate->dnxt.delsys = c->delivery_system;\r\nstate->dnxt.modulation = c->modulation;\r\nstate->dnxt.frequency = c->frequency;\r\nstate->dnxt.pilot = c->pilot;\r\nstate->dnxt.rolloff = c->rolloff;\r\nret = cx24117_set_inversion(state, c->inversion);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24117_set_fec(state,\r\nc->delivery_system, c->modulation, c->fec_inner);\r\nif (ret != 0)\r\nreturn ret;\r\nret = cx24117_set_symbolrate(state, c->symbol_rate);\r\nif (ret != 0)\r\nreturn ret;\r\ncx24117_clone_params(fe);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: delsys = %d\n", __func__, state->dcur.delsys);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: modulation = %d\n", __func__, state->dcur.modulation);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: frequency = %d\n", __func__, state->dcur.frequency);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: pilot = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.pilot, state->dcur.pilot_val);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: retune = %d\n", __func__, retune);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: rolloff = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.rolloff, state->dcur.rolloff_val);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: symbol_rate = %d\n", __func__, state->dcur.symbol_rate);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: FEC = %d (mask/val = 0x%02x/0x%02x)\n", __func__,\r\nstate->dcur.fec, state->dcur.fec_mask, state->dcur.fec_val);\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s: Inversion = %d (val = 0x%02x)\n", __func__,\r\nstate->dcur.inversion, state->dcur.inversion_val);\r\ncmd.args[0] = CMD_TUNEREQUEST;\r\ncmd.args[1] = state->demod;\r\ncmd.args[2] = (state->dcur.frequency & 0xff0000) >> 16;\r\ncmd.args[3] = (state->dcur.frequency & 0x00ff00) >> 8;\r\ncmd.args[4] = (state->dcur.frequency & 0x0000ff);\r\ncmd.args[5] = ((state->dcur.symbol_rate / 1000) & 0xff00) >> 8;\r\ncmd.args[6] = ((state->dcur.symbol_rate / 1000) & 0x00ff);\r\ncmd.args[7] = state->dcur.inversion_val;\r\ncmd.args[8] = state->dcur.fec_val | state->dcur.pilot_val;\r\ncmd.args[9] = CX24117_SEARCH_RANGE_KHZ >> 8;\r\ncmd.args[10] = CX24117_SEARCH_RANGE_KHZ & 0xff;\r\ncmd.args[11] = state->dcur.rolloff_val;\r\ncmd.args[12] = state->dcur.fec_mask;\r\nif (state->dcur.symbol_rate > 30000000) {\r\nreg_ratediv = 0x04;\r\nreg_clkdiv = 0x02;\r\n} else if (state->dcur.symbol_rate > 10000000) {\r\nreg_ratediv = 0x06;\r\nreg_clkdiv = 0x03;\r\n} else {\r\nreg_ratediv = 0x0a;\r\nreg_clkdiv = 0x05;\r\n}\r\ncmd.args[13] = reg_ratediv;\r\ncmd.args[14] = reg_clkdiv;\r\ncx24117_writereg(state, (state->demod == 0) ?\r\nCX24117_REG_CLKDIV0 : CX24117_REG_CLKDIV1, reg_clkdiv);\r\ncx24117_writereg(state, (state->demod == 0) ?\r\nCX24117_REG_RATEDIV0 : CX24117_REG_RATEDIV1, reg_ratediv);\r\ncmd.args[15] = CX24117_PNE;\r\ncmd.len = 16;\r\ndo {\r\nstatus = cx24117_readreg(state, (state->demod == 0) ?\r\nCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1) &\r\nCX24117_SIGNAL_MASK;\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d status_setfe = %02x\n",\r\n__func__, state->demod, status);\r\ncx24117_writereg(state, (state->demod == 0) ?\r\nCX24117_REG_SSTATUS0 : CX24117_REG_SSTATUS1, status);\r\nret = cx24117_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nbreak;\r\nfor (i = 0; i < 50; i++) {\r\ncx24117_read_status(fe, &tunerstat);\r\nstatus = tunerstat & (FE_HAS_SIGNAL | FE_HAS_SYNC);\r\nif (status == (FE_HAS_SIGNAL | FE_HAS_SYNC)) {\r\ndev_dbg(&state->priv->i2c->dev,\r\n"%s() demod%d tuned\n",\r\n__func__, state->demod);\r\nreturn 0;\r\n}\r\nmsleep(20);\r\n}\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d not tuned\n",\r\n__func__, state->demod);\r\nif (state->dcur.rolloff == 3)\r\ncmd.args[11]--;\r\n} while (--retune);\r\nreturn -EINVAL;\r\n}\r\nstatic int cx24117_tune(struct dvb_frontend *fe, bool re_tune,\r\nunsigned int mode_flags, unsigned int *delay, enum fe_status *status)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\ndev_dbg(&state->priv->i2c->dev, "%s() demod%d\n",\r\n__func__, state->demod);\r\n*delay = HZ / 5;\r\nif (re_tune) {\r\nint ret = cx24117_set_frontend(fe);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn cx24117_read_status(fe, status);\r\n}\r\nstatic int cx24117_get_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_HW;\r\n}\r\nstatic int cx24117_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct cx24117_state *state = fe->demodulator_priv;\r\nstruct cx24117_cmd cmd;\r\nu8 reg, st, inv;\r\nint ret, idx;\r\nunsigned int freq;\r\nshort srate_os, freq_os;\r\nu8 buf[0x1f-4];\r\ncmd.args[0] = CMD_GETCTLACC;\r\ncmd.args[1] = (u8) state->demod;\r\ncmd.len = 2;\r\nret = cx24117_cmd_execute(fe, &cmd);\r\nif (ret != 0)\r\nreturn ret;\r\nreg = (state->demod == 0) ? CX24117_REG_FREQ3_0 : CX24117_REG_FREQ3_1;\r\nret = cx24117_readregN(state, reg, buf, 0x1f-4);\r\nif (ret != 0)\r\nreturn ret;\r\nst = buf[5];\r\ninv = (((state->demod == 0) ? ~st : st) >> 6) & 1;\r\nif (inv == 0)\r\nc->inversion = INVERSION_OFF;\r\nelse\r\nc->inversion = INVERSION_ON;\r\nidx = st & 0x3f;\r\nif (c->delivery_system == SYS_DVBS2) {\r\nif (idx > 11)\r\nidx += 9;\r\nelse\r\nidx += 7;\r\n}\r\nc->modulation = cx24117_modfec_modes[idx].modulation;\r\nc->fec_inner = cx24117_modfec_modes[idx].fec;\r\nfreq = (buf[0] << 16) | (buf[1] << 8) | buf[2];\r\nfreq_os = (buf[8] << 8) | buf[9];\r\nc->frequency = freq + freq_os;\r\nsrate_os = (buf[10] << 8) | buf[11];\r\nc->symbol_rate = -1000 * srate_os + state->dcur.symbol_rate;\r\nreturn 0;\r\n}
