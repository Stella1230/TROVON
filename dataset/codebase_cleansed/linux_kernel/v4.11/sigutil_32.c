int save_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_SMP\r\nif (test_tsk_thread_flag(current, TIF_USEDFPU)) {\r\nput_psr(get_psr() | PSR_EF);\r\nfpsave(&current->thread.float_regs[0], &current->thread.fsr,\r\n&current->thread.fpqueue[0], &current->thread.fpqdepth);\r\nregs->psr &= ~(PSR_EF);\r\nclear_tsk_thread_flag(current, TIF_USEDFPU);\r\n}\r\n#else\r\nif (current == last_task_used_math) {\r\nput_psr(get_psr() | PSR_EF);\r\nfpsave(&current->thread.float_regs[0], &current->thread.fsr,\r\n&current->thread.fpqueue[0], &current->thread.fpqdepth);\r\nlast_task_used_math = NULL;\r\nregs->psr &= ~(PSR_EF);\r\n}\r\n#endif\r\nerr |= __copy_to_user(&fpu->si_float_regs[0],\r\n&current->thread.float_regs[0],\r\n(sizeof(unsigned long) * 32));\r\nerr |= __put_user(current->thread.fsr, &fpu->si_fsr);\r\nerr |= __put_user(current->thread.fpqdepth, &fpu->si_fpqdepth);\r\nif (current->thread.fpqdepth != 0)\r\nerr |= __copy_to_user(&fpu->si_fpqueue[0],\r\n&current->thread.fpqueue[0],\r\n((sizeof(unsigned long) +\r\n(sizeof(unsigned long *)))*16));\r\nclear_used_math();\r\nreturn err;\r\n}\r\nint restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)\r\n{\r\nint err;\r\nif (((unsigned long) fpu) & 3)\r\nreturn -EFAULT;\r\n#ifdef CONFIG_SMP\r\nif (test_tsk_thread_flag(current, TIF_USEDFPU))\r\nregs->psr &= ~PSR_EF;\r\n#else\r\nif (current == last_task_used_math) {\r\nlast_task_used_math = NULL;\r\nregs->psr &= ~PSR_EF;\r\n}\r\n#endif\r\nset_used_math();\r\nclear_tsk_thread_flag(current, TIF_USEDFPU);\r\nif (!access_ok(VERIFY_READ, fpu, sizeof(*fpu)))\r\nreturn -EFAULT;\r\nerr = __copy_from_user(&current->thread.float_regs[0], &fpu->si_float_regs[0],\r\n(sizeof(unsigned long) * 32));\r\nerr |= __get_user(current->thread.fsr, &fpu->si_fsr);\r\nerr |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);\r\nif (current->thread.fpqdepth != 0)\r\nerr |= __copy_from_user(&current->thread.fpqueue[0],\r\n&fpu->si_fpqueue[0],\r\n((sizeof(unsigned long) +\r\n(sizeof(unsigned long *)))*16));\r\nreturn err;\r\n}\r\nint save_rwin_state(int wsaved, __siginfo_rwin_t __user *rwin)\r\n{\r\nint i, err = __put_user(wsaved, &rwin->wsaved);\r\nfor (i = 0; i < wsaved; i++) {\r\nstruct reg_window32 *rp;\r\nunsigned long fp;\r\nrp = &current_thread_info()->reg_window[i];\r\nfp = current_thread_info()->rwbuf_stkptrs[i];\r\nerr |= copy_to_user(&rwin->reg_window[i], rp,\r\nsizeof(struct reg_window32));\r\nerr |= __put_user(fp, &rwin->rwbuf_stkptrs[i]);\r\n}\r\nreturn err;\r\n}\r\nint restore_rwin_state(__siginfo_rwin_t __user *rp)\r\n{\r\nstruct thread_info *t = current_thread_info();\r\nint i, wsaved, err;\r\nif (((unsigned long) rp) & 3)\r\nreturn -EFAULT;\r\nget_user(wsaved, &rp->wsaved);\r\nif (wsaved > NSWINS)\r\nreturn -EFAULT;\r\nerr = 0;\r\nfor (i = 0; i < wsaved; i++) {\r\nerr |= copy_from_user(&t->reg_window[i],\r\n&rp->reg_window[i],\r\nsizeof(struct reg_window32));\r\nerr |= __get_user(t->rwbuf_stkptrs[i],\r\n&rp->rwbuf_stkptrs[i]);\r\n}\r\nif (err)\r\nreturn err;\r\nt->w_saved = wsaved;\r\nsynchronize_user_stack();\r\nif (t->w_saved)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}
