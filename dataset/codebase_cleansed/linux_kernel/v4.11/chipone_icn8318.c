static int icn8318_read_touch_data(struct i2c_client *client,\r\nstruct icn8318_touch_data *touch_data)\r\n{\r\nu8 reg = ICN8318_REG_TOUCHDATA;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 1,\r\n.buf = &reg\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = sizeof(struct icn8318_touch_data),\r\n.buf = (u8 *)touch_data\r\n}\r\n};\r\nreturn i2c_transfer(client->adapter, msg, 2);\r\n}\r\nstatic inline bool icn8318_touch_active(u8 event)\r\n{\r\nreturn (event == ICN8318_EVENT_UPDATE1) ||\r\n(event == ICN8318_EVENT_UPDATE2);\r\n}\r\nstatic irqreturn_t icn8318_irq(int irq, void *dev_id)\r\n{\r\nstruct icn8318_data *data = dev_id;\r\nstruct device *dev = &data->client->dev;\r\nstruct icn8318_touch_data touch_data;\r\nint i, ret;\r\nret = icn8318_read_touch_data(data->client, &touch_data);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading touch data: %d\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (touch_data.softbutton) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (touch_data.touch_count > ICN8318_MAX_TOUCHES) {\r\ndev_warn(dev, "Too much touches %d > %d\n",\r\ntouch_data.touch_count, ICN8318_MAX_TOUCHES);\r\ntouch_data.touch_count = ICN8318_MAX_TOUCHES;\r\n}\r\nfor (i = 0; i < touch_data.touch_count; i++) {\r\nstruct icn8318_touch *touch = &touch_data.touches[i];\r\nbool act = icn8318_touch_active(touch->event);\r\ninput_mt_slot(data->input, touch->slot);\r\ninput_mt_report_slot_state(data->input, MT_TOOL_FINGER, act);\r\nif (!act)\r\ncontinue;\r\ntouchscreen_report_pos(data->input, &data->prop,\r\nbe16_to_cpu(touch->x),\r\nbe16_to_cpu(touch->y), true);\r\n}\r\ninput_mt_sync_frame(data->input);\r\ninput_sync(data->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int icn8318_start(struct input_dev *dev)\r\n{\r\nstruct icn8318_data *data = input_get_drvdata(dev);\r\nenable_irq(data->client->irq);\r\ngpiod_set_value_cansleep(data->wake_gpio, 1);\r\nreturn 0;\r\n}\r\nstatic void icn8318_stop(struct input_dev *dev)\r\n{\r\nstruct icn8318_data *data = input_get_drvdata(dev);\r\ndisable_irq(data->client->irq);\r\ni2c_smbus_write_byte_data(data->client, ICN8318_REG_POWER,\r\nICN8318_POWER_HIBERNATE);\r\ngpiod_set_value_cansleep(data->wake_gpio, 0);\r\n}\r\nstatic int icn8318_suspend(struct device *dev)\r\n{\r\nstruct icn8318_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nmutex_lock(&data->input->mutex);\r\nif (data->input->users)\r\nicn8318_stop(data->input);\r\nmutex_unlock(&data->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int icn8318_resume(struct device *dev)\r\n{\r\nstruct icn8318_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nmutex_lock(&data->input->mutex);\r\nif (data->input->users)\r\nicn8318_start(data->input);\r\nmutex_unlock(&data->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int icn8318_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct icn8318_data *data;\r\nstruct input_dev *input;\r\nint error;\r\nif (!client->irq) {\r\ndev_err(dev, "Error no irq specified\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->wake_gpio = devm_gpiod_get(dev, "wake", GPIOD_OUT_LOW);\r\nif (IS_ERR(data->wake_gpio)) {\r\nerror = PTR_ERR(data->wake_gpio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Error getting wake gpio: %d\n", error);\r\nreturn error;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->open = icn8318_start;\r\ninput->close = icn8318_stop;\r\ninput->dev.parent = dev;\r\ninput_set_capability(input, EV_ABS, ABS_MT_POSITION_X);\r\ninput_set_capability(input, EV_ABS, ABS_MT_POSITION_Y);\r\ntouchscreen_parse_properties(input, true, &data->prop);\r\nif (!input_abs_get_max(input, ABS_MT_POSITION_X) ||\r\n!input_abs_get_max(input, ABS_MT_POSITION_Y)) {\r\ndev_err(dev, "Error touchscreen-size-x and/or -y missing\n");\r\nreturn -EINVAL;\r\n}\r\nerror = input_mt_init_slots(input, ICN8318_MAX_TOUCHES,\r\nINPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);\r\nif (error)\r\nreturn error;\r\ndata->client = client;\r\ndata->input = input;\r\ninput_set_drvdata(input, data);\r\nerror = devm_request_threaded_irq(dev, client->irq, NULL, icn8318_irq,\r\nIRQF_ONESHOT, client->name, data);\r\nif (error) {\r\ndev_err(dev, "Error requesting irq: %d\n", error);\r\nreturn error;\r\n}\r\nicn8318_stop(data->input);\r\nerror = input_register_device(input);\r\nif (error)\r\nreturn error;\r\ni2c_set_clientdata(client, data);\r\nreturn 0;\r\n}
