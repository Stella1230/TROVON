static int mxc_scc_get_data(struct mxc_scc_ctx *ctx,\r\nstruct crypto_async_request *req)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mxc_scc *scc = ctx->scc;\r\nsize_t len;\r\nvoid __iomem *from;\r\nif (ctx->ctrl & SCC_SCM_CTRL_DECRYPT_MODE)\r\nfrom = scc->red_memory;\r\nelse\r\nfrom = scc->black_memory;\r\ndev_dbg(scc->dev, "pcopy: from 0x%p %d bytes\n", from,\r\nctx->dst_nents * 8);\r\nlen = sg_pcopy_from_buffer(ablkreq->dst, ctx->dst_nents,\r\nfrom, ctx->size, ctx->offset);\r\nif (!len) {\r\ndev_err(scc->dev, "pcopy err from 0x%p (len=%d)\n", from, len);\r\nreturn -EINVAL;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"red memory@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nscc->red_memory, ctx->size, 1);\r\nprint_hex_dump(KERN_ERR,\r\n"black memory@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nscc->black_memory, ctx->size, 1);\r\n#endif\r\nctx->offset += len;\r\nif (ctx->offset < ablkreq->nbytes)\r\nreturn -EINPROGRESS;\r\nreturn 0;\r\n}\r\nstatic int mxc_scc_ablkcipher_req_init(struct ablkcipher_request *req,\r\nstruct mxc_scc_ctx *ctx)\r\n{\r\nstruct mxc_scc *scc = ctx->scc;\r\nint nents;\r\nnents = sg_nents_for_len(req->src, req->nbytes);\r\nif (nents < 0) {\r\ndev_err(scc->dev, "Invalid number of src SC");\r\nreturn nents;\r\n}\r\nctx->src_nents = nents;\r\nnents = sg_nents_for_len(req->dst, req->nbytes);\r\nif (nents < 0) {\r\ndev_err(scc->dev, "Invalid number of dst SC");\r\nreturn nents;\r\n}\r\nctx->dst_nents = nents;\r\nctx->size = 0;\r\nctx->offset = 0;\r\nreturn 0;\r\n}\r\nstatic int mxc_scc_ablkcipher_req_complete(struct crypto_async_request *req,\r\nstruct mxc_scc_ctx *ctx,\r\nint result)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mxc_scc *scc = ctx->scc;\r\nscc->req = NULL;\r\nscc->bytes_remaining = scc->memory_size_bytes;\r\nif (ctx->ctrl & SCC_SCM_CTRL_CBC_MODE)\r\nmemcpy(ablkreq->info, scc->base + SCC_SCM_INIT_VECTOR_0,\r\nscc->block_size_bytes);\r\nreq->complete(req, result);\r\nscc->hw_busy = false;\r\nreturn 0;\r\n}\r\nstatic int mxc_scc_put_data(struct mxc_scc_ctx *ctx,\r\nstruct ablkcipher_request *req)\r\n{\r\nu8 padding_buffer[sizeof(u16) + sizeof(scc_block_padding)];\r\nsize_t len = min_t(size_t, req->nbytes - ctx->offset,\r\nctx->scc->bytes_remaining);\r\nunsigned int padding_byte_count = 0;\r\nstruct mxc_scc *scc = ctx->scc;\r\nvoid __iomem *to;\r\nif (ctx->ctrl & SCC_SCM_CTRL_DECRYPT_MODE)\r\nto = scc->black_memory;\r\nelse\r\nto = scc->red_memory;\r\nif (ctx->ctrl & SCC_SCM_CTRL_CBC_MODE && req->info)\r\nmemcpy(scc->base + SCC_SCM_INIT_VECTOR_0, req->info,\r\nscc->block_size_bytes);\r\nlen = sg_pcopy_to_buffer(req->src, ctx->src_nents,\r\nto, len, ctx->offset);\r\nif (!len) {\r\ndev_err(scc->dev, "pcopy err to 0x%p (len=%d)\n", to, len);\r\nreturn -EINVAL;\r\n}\r\nctx->size = len;\r\n#ifdef DEBUG\r\ndev_dbg(scc->dev, "copied %d bytes to 0x%p\n", len, to);\r\nprint_hex_dump(KERN_ERR,\r\n"init vector0@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nscc->base + SCC_SCM_INIT_VECTOR_0, scc->block_size_bytes,\r\n1);\r\nprint_hex_dump(KERN_ERR,\r\n"red memory@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nscc->red_memory, ctx->size, 1);\r\nprint_hex_dump(KERN_ERR,\r\n"black memory@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nscc->black_memory, ctx->size, 1);\r\n#endif\r\nscc->bytes_remaining -= len;\r\npadding_byte_count = len % scc->block_size_bytes;\r\nif (padding_byte_count) {\r\nmemcpy(padding_buffer, scc_block_padding, padding_byte_count);\r\nmemcpy(to + len, padding_buffer, padding_byte_count);\r\nctx->size += padding_byte_count;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"data to encrypt@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nto, ctx->size, 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void mxc_scc_ablkcipher_next(struct mxc_scc_ctx *ctx,\r\nstruct crypto_async_request *req)\r\n{\r\nstruct ablkcipher_request *ablkreq = ablkcipher_request_cast(req);\r\nstruct mxc_scc *scc = ctx->scc;\r\nint err;\r\ndev_dbg(scc->dev, "dispatch request (nbytes=%d, src=%p, dst=%p)\n",\r\nablkreq->nbytes, ablkreq->src, ablkreq->dst);\r\nwritel(0, scc->base + SCC_SCM_ERROR_STATUS);\r\nerr = mxc_scc_put_data(ctx, ablkreq);\r\nif (err) {\r\nmxc_scc_ablkcipher_req_complete(req, ctx, err);\r\nreturn;\r\n}\r\ndev_dbg(scc->dev, "Start encryption (0x%p/0x%p)\n",\r\n(void *)readl(scc->base + SCC_SCM_RED_START),\r\n(void *)readl(scc->base + SCC_SCM_BLACK_START));\r\nwritel(SCC_SCM_INTR_CTRL_CLR_INTR,\r\nscc->base + SCC_SCM_INTR_CTRL);\r\nwritel((ctx->size / ctx->scc->block_size_bytes) - 1,\r\nscc->base + SCC_SCM_LENGTH);\r\ndev_dbg(scc->dev, "Process %d block(s) in 0x%p\n",\r\nctx->size / ctx->scc->block_size_bytes,\r\n(ctx->ctrl & SCC_SCM_CTRL_DECRYPT_MODE) ? scc->black_memory :\r\nscc->red_memory);\r\nwritel(ctx->ctrl, scc->base + SCC_SCM_CTRL);\r\n}\r\nstatic irqreturn_t mxc_scc_int(int irq, void *priv)\r\n{\r\nstruct crypto_async_request *req;\r\nstruct mxc_scc_ctx *ctx;\r\nstruct mxc_scc *scc = priv;\r\nint status;\r\nint ret;\r\nstatus = readl(scc->base + SCC_SCM_STATUS);\r\nwritel(SCC_SCM_INTR_CTRL_CLR_INTR, scc->base + SCC_SCM_INTR_CTRL);\r\nif (status & SCC_SCM_STATUS_BUSY)\r\nreturn IRQ_NONE;\r\nreq = scc->req;\r\nif (req) {\r\nctx = crypto_tfm_ctx(req->tfm);\r\nret = mxc_scc_get_data(ctx, req);\r\nif (ret != -EINPROGRESS)\r\nmxc_scc_ablkcipher_req_complete(req, ctx, ret);\r\nelse\r\nmxc_scc_ablkcipher_next(ctx, req);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxc_scc_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct mxc_scc_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct mxc_scc_crypto_tmpl *algt;\r\nalgt = container_of(alg, struct mxc_scc_crypto_tmpl, alg);\r\nctx->scc = algt->scc;\r\nreturn 0;\r\n}\r\nstatic void mxc_scc_dequeue_req_unlocked(struct mxc_scc_ctx *ctx)\r\n{\r\nstruct crypto_async_request *req, *backlog;\r\nif (ctx->scc->hw_busy)\r\nreturn;\r\nspin_lock_bh(&ctx->scc->lock);\r\nbacklog = crypto_get_backlog(&ctx->scc->queue);\r\nreq = crypto_dequeue_request(&ctx->scc->queue);\r\nctx->scc->req = req;\r\nctx->scc->hw_busy = true;\r\nspin_unlock_bh(&ctx->scc->lock);\r\nif (!req)\r\nreturn;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nmxc_scc_ablkcipher_next(ctx, req);\r\n}\r\nstatic int mxc_scc_queue_req(struct mxc_scc_ctx *ctx,\r\nstruct crypto_async_request *req)\r\n{\r\nint ret;\r\nspin_lock_bh(&ctx->scc->lock);\r\nret = crypto_enqueue_request(&ctx->scc->queue, req);\r\nspin_unlock_bh(&ctx->scc->lock);\r\nif (ret != -EINPROGRESS)\r\nreturn ret;\r\nmxc_scc_dequeue_req_unlocked(ctx);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int mxc_scc_des3_op(struct mxc_scc_ctx *ctx,\r\nstruct ablkcipher_request *req)\r\n{\r\nint err;\r\nerr = mxc_scc_ablkcipher_req_init(req, ctx);\r\nif (err)\r\nreturn err;\r\nreturn mxc_scc_queue_req(ctx, &req->base);\r\n}\r\nstatic int mxc_scc_ecb_des_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct mxc_scc_ctx *ctx = crypto_ablkcipher_ctx(cipher);\r\nctx->ctrl = SCC_SCM_CTRL_START_CIPHER;\r\nreturn mxc_scc_des3_op(ctx, req);\r\n}\r\nstatic int mxc_scc_ecb_des_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct mxc_scc_ctx *ctx = crypto_ablkcipher_ctx(cipher);\r\nctx->ctrl = SCC_SCM_CTRL_START_CIPHER;\r\nctx->ctrl |= SCC_SCM_CTRL_DECRYPT_MODE;\r\nreturn mxc_scc_des3_op(ctx, req);\r\n}\r\nstatic int mxc_scc_cbc_des_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct mxc_scc_ctx *ctx = crypto_ablkcipher_ctx(cipher);\r\nctx->ctrl = SCC_SCM_CTRL_START_CIPHER;\r\nctx->ctrl |= SCC_SCM_CTRL_CBC_MODE;\r\nreturn mxc_scc_des3_op(ctx, req);\r\n}\r\nstatic int mxc_scc_cbc_des_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);\r\nstruct mxc_scc_ctx *ctx = crypto_ablkcipher_ctx(cipher);\r\nctx->ctrl = SCC_SCM_CTRL_START_CIPHER;\r\nctx->ctrl |= SCC_SCM_CTRL_CBC_MODE;\r\nctx->ctrl |= SCC_SCM_CTRL_DECRYPT_MODE;\r\nreturn mxc_scc_des3_op(ctx, req);\r\n}\r\nstatic void mxc_scc_hw_init(struct mxc_scc *scc)\r\n{\r\nint offset;\r\noffset = SCC_NON_RESERVED_OFFSET / scc->block_size_bytes;\r\nwritel(offset, scc->base + SCC_SCM_RED_START);\r\nwritel(offset, scc->base + SCC_SCM_BLACK_START);\r\nscc->red_memory = scc->base + SCC_SCM_RED_MEMORY +\r\nSCC_NON_RESERVED_OFFSET;\r\nscc->black_memory = scc->base + SCC_SCM_BLACK_MEMORY +\r\nSCC_NON_RESERVED_OFFSET;\r\nscc->bytes_remaining = scc->memory_size_bytes;\r\n}\r\nstatic int mxc_scc_get_config(struct mxc_scc *scc)\r\n{\r\nint config;\r\nconfig = readl(scc->base + SCC_SCM_CFG);\r\nscc->block_size_bytes = config & SCC_SCM_CFG_BLOCK_SIZE_MASK;\r\nscc->black_ram_size_blocks = config & SCC_SCM_CFG_BLACK_SIZE_MASK;\r\nscc->memory_size_bytes = (scc->block_size_bytes *\r\nscc->black_ram_size_blocks) -\r\nSCC_NON_RESERVED_OFFSET;\r\nreturn 0;\r\n}\r\nstatic enum mxc_scc_state mxc_scc_get_state(struct mxc_scc *scc)\r\n{\r\nenum mxc_scc_state state;\r\nint status;\r\nstatus = readl(scc->base + SCC_SMN_STATUS) &\r\nSCC_SMN_STATUS_STATE_MASK;\r\nif (status & SCC_SMN_STATE_HEALTH_CHECK) {\r\nwritel(0xaaaa, scc->base + SCC_SMN_SEQ_START);\r\nwritel(0x5555, scc->base + SCC_SMN_SEQ_END);\r\nwritel(0x5555, scc->base + SCC_SMN_SEQ_CHECK);\r\nstatus = readl(scc->base + SCC_SMN_STATUS) &\r\nSCC_SMN_STATUS_STATE_MASK;\r\n}\r\nswitch (status) {\r\ncase SCC_SMN_STATE_NON_SECURE:\r\ncase SCC_SMN_STATE_SECURE:\r\nstate = SCC_STATE_OK;\r\nbreak;\r\ncase SCC_SMN_STATE_FAIL:\r\nstate = SCC_STATE_FAILED;\r\nbreak;\r\ndefault:\r\nstate = SCC_STATE_UNIMPLEMENTED;\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic int mxc_scc_crypto_register(struct mxc_scc *scc)\r\n{\r\nint i;\r\nint err = 0;\r\nfor (i = 0; i < ARRAY_SIZE(scc_crypto_algs); i++) {\r\nscc_crypto_algs[i]->scc = scc;\r\nerr = crypto_register_alg(&scc_crypto_algs[i]->alg);\r\nif (err)\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nwhile (--i >= 0)\r\ncrypto_unregister_alg(&scc_crypto_algs[i]->alg);\r\nreturn err;\r\n}\r\nstatic void mxc_scc_crypto_unregister(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(scc_crypto_algs); i++)\r\ncrypto_unregister_alg(&scc_crypto_algs[i]->alg);\r\n}\r\nstatic int mxc_scc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct mxc_scc *scc;\r\nenum mxc_scc_state state;\r\nint irq;\r\nint ret;\r\nint i;\r\nscc = devm_kzalloc(dev, sizeof(*scc), GFP_KERNEL);\r\nif (!scc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nscc->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(scc->base))\r\nreturn PTR_ERR(scc->base);\r\nscc->clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(scc->clk)) {\r\ndev_err(dev, "Could not get ipg clock\n");\r\nreturn PTR_ERR(scc->clk);\r\n}\r\nret = clk_prepare_enable(scc->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(0x0, scc->base + SCC_SCM_ERROR_STATUS);\r\nwritel(SCC_SCM_INTR_CTRL_CLR_INTR |\r\nSCC_SCM_INTR_CTRL_MASK_INTR,\r\nscc->base + SCC_SCM_INTR_CTRL);\r\nwritel(SCC_SMN_COMMAND_CLR_INTR |\r\nSCC_SMN_COMMAND_EN_INTR,\r\nscc->base + SCC_SMN_COMMAND);\r\nscc->dev = dev;\r\nplatform_set_drvdata(pdev, scc);\r\nret = mxc_scc_get_config(scc);\r\nif (ret)\r\ngoto err_out;\r\nstate = mxc_scc_get_state(scc);\r\nif (state != SCC_STATE_OK) {\r\ndev_err(dev, "SCC in unusable state %d\n", state);\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nmxc_scc_hw_init(scc);\r\nspin_lock_init(&scc->lock);\r\ncrypto_init_queue(&scc->queue, 50);\r\nfor (i = 0; i < 2; i++) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get irq resource\n");\r\nret = -EINVAL;\r\ngoto err_out;\r\n}\r\nret = devm_request_threaded_irq(dev, irq, NULL, mxc_scc_int,\r\nIRQF_ONESHOT, dev_name(dev), scc);\r\nif (ret)\r\ngoto err_out;\r\n}\r\nret = mxc_scc_crypto_register(scc);\r\nif (ret) {\r\ndev_err(dev, "could not register algorithms");\r\ngoto err_out;\r\n}\r\ndev_info(dev, "registered successfully.\n");\r\nreturn 0;\r\nerr_out:\r\nclk_disable_unprepare(scc->clk);\r\nreturn ret;\r\n}\r\nstatic int mxc_scc_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_scc *scc = platform_get_drvdata(pdev);\r\nmxc_scc_crypto_unregister();\r\nclk_disable_unprepare(scc->clk);\r\nreturn 0;\r\n}
