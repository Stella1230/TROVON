static int hfsplus_ioctl_bless(struct file *file, int __user *user_flags)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct inode *inode = d_inode(dentry);\r\nstruct hfsplus_sb_info *sbi = HFSPLUS_SB(inode->i_sb);\r\nstruct hfsplus_vh *vh = sbi->s_vhdr;\r\nstruct hfsplus_vh *bvh = sbi->s_backup_vhdr;\r\nu32 cnid = (unsigned long)dentry->d_fsdata;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&sbi->vh_mutex);\r\nvh->finder_info[0] = bvh->finder_info[0] =\r\ncpu_to_be32(parent_ino(dentry));\r\nvh->finder_info[1] = bvh->finder_info[1] = cpu_to_be32(cnid);\r\nvh->finder_info[5] = bvh->finder_info[5] =\r\ncpu_to_be32(parent_ino(dentry));\r\nmutex_unlock(&sbi->vh_mutex);\r\nreturn 0;\r\n}\r\nstatic int hfsplus_ioctl_getflags(struct file *file, int __user *user_flags)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nunsigned int flags = 0;\r\nif (inode->i_flags & S_IMMUTABLE)\r\nflags |= FS_IMMUTABLE_FL;\r\nif (inode->i_flags & S_APPEND)\r\nflags |= FS_APPEND_FL;\r\nif (hip->userflags & HFSPLUS_FLG_NODUMP)\r\nflags |= FS_NODUMP_FL;\r\nreturn put_user(flags, user_flags);\r\n}\r\nstatic int hfsplus_ioctl_setflags(struct file *file, int __user *user_flags)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nunsigned int flags, new_fl = 0;\r\nint err = 0;\r\nerr = mnt_want_write_file(file);\r\nif (err)\r\ngoto out;\r\nif (!inode_owner_or_capable(inode)) {\r\nerr = -EACCES;\r\ngoto out_drop_write;\r\n}\r\nif (get_user(flags, user_flags)) {\r\nerr = -EFAULT;\r\ngoto out_drop_write;\r\n}\r\ninode_lock(inode);\r\nif ((flags & (FS_IMMUTABLE_FL|FS_APPEND_FL)) ||\r\ninode->i_flags & (S_IMMUTABLE|S_APPEND)) {\r\nif (!capable(CAP_LINUX_IMMUTABLE)) {\r\nerr = -EPERM;\r\ngoto out_unlock_inode;\r\n}\r\n}\r\nif (flags & ~(FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NODUMP_FL)) {\r\nerr = -EOPNOTSUPP;\r\ngoto out_unlock_inode;\r\n}\r\nif (flags & FS_IMMUTABLE_FL)\r\nnew_fl |= S_IMMUTABLE;\r\nif (flags & FS_APPEND_FL)\r\nnew_fl |= S_APPEND;\r\ninode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND);\r\nif (flags & FS_NODUMP_FL)\r\nhip->userflags |= HFSPLUS_FLG_NODUMP;\r\nelse\r\nhip->userflags &= ~HFSPLUS_FLG_NODUMP;\r\ninode->i_ctime = current_time(inode);\r\nmark_inode_dirty(inode);\r\nout_unlock_inode:\r\ninode_unlock(inode);\r\nout_drop_write:\r\nmnt_drop_write_file(file);\r\nout:\r\nreturn err;\r\n}\r\nlong hfsplus_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase HFSPLUS_IOC_EXT2_GETFLAGS:\r\nreturn hfsplus_ioctl_getflags(file, argp);\r\ncase HFSPLUS_IOC_EXT2_SETFLAGS:\r\nreturn hfsplus_ioctl_setflags(file, argp);\r\ncase HFSPLUS_IOC_BLESS:\r\nreturn hfsplus_ioctl_bless(file, argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}
